{
  "module_name": "phy-j721e-wiz.c",
  "hash_id": "b9788dc10b4c9e311ef6ee270279670f2772ddd5ab42fc41f5e2cfc57d7d40a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/ti/phy-j721e-wiz.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/phy/phy.h>\n#include <dt-bindings/phy/phy-ti.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mux/consumer.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n\n#define REF_CLK_19_2MHZ         19200000\n#define REF_CLK_25MHZ           25000000\n#define REF_CLK_100MHZ          100000000\n#define REF_CLK_156_25MHZ       156250000\n\n \n#define SERDES_SUP_CTRL\t\t0x4400\n\n \n#define WIZ_SERDES_CTRL\t\t0x404\n#define WIZ_SERDES_TOP_CTRL\t0x408\n#define WIZ_SERDES_RST\t\t0x40c\n#define WIZ_SERDES_TYPEC\t0x410\n#define WIZ_LANECTL(n)\t\t(0x480 + (0x40 * (n)))\n#define WIZ_LANEDIV(n)\t\t(0x484 + (0x40 * (n)))\n\n#define WIZ_MAX_INPUT_CLOCKS\t4\n \n#define WIZ_MAX_OUTPUT_CLOCKS\t32\n\n#define WIZ_MAX_LANES\t\t4\n#define WIZ_MUX_NUM_CLOCKS\t3\n#define WIZ_DIV_NUM_CLOCKS_16G\t2\n#define WIZ_DIV_NUM_CLOCKS_10G\t1\n\n#define WIZ_SERDES_TYPEC_LN10_SWAP\tBIT(30)\n\nenum wiz_lane_standard_mode {\n\tLANE_MODE_GEN1,\n\tLANE_MODE_GEN2,\n\tLANE_MODE_GEN3,\n\tLANE_MODE_GEN4,\n};\n\n \nenum wiz_typec_master_lane {\n\tLANE0 = 0,\n\tLANE2 = 2,\n};\n\nenum wiz_refclk_mux_sel {\n\tPLL0_REFCLK,\n\tPLL1_REFCLK,\n\tREFCLK_DIG,\n};\n\nenum wiz_refclk_div_sel {\n\tCMN_REFCLK_DIG_DIV,\n\tCMN_REFCLK1_DIG_DIV,\n};\n\nenum wiz_clock_input {\n\tWIZ_CORE_REFCLK,\n\tWIZ_EXT_REFCLK,\n\tWIZ_CORE_REFCLK1,\n\tWIZ_EXT_REFCLK1,\n};\n\nstatic const struct reg_field por_en = REG_FIELD(WIZ_SERDES_CTRL, 31, 31);\nstatic const struct reg_field phy_reset_n = REG_FIELD(WIZ_SERDES_RST, 31, 31);\nstatic const struct reg_field phy_en_refclk = REG_FIELD(WIZ_SERDES_RST, 30, 30);\nstatic const struct reg_field pll1_refclk_mux_sel =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_RST, 29, 29);\nstatic const struct reg_field pll1_refclk_mux_sel_2 =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_RST, 22, 23);\nstatic const struct reg_field pll0_refclk_mux_sel =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_RST, 28, 28);\nstatic const struct reg_field pll0_refclk_mux_sel_2 =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_RST, 28, 29);\nstatic const struct reg_field refclk_dig_sel_16g =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_RST, 24, 25);\nstatic const struct reg_field refclk_dig_sel_10g =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_RST, 24, 24);\nstatic const struct reg_field pma_cmn_refclk_int_mode =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_TOP_CTRL, 28, 29);\nstatic const struct reg_field pma_cmn_refclk1_int_mode =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_TOP_CTRL, 20, 21);\nstatic const struct reg_field pma_cmn_refclk_mode =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_TOP_CTRL, 30, 31);\nstatic const struct reg_field pma_cmn_refclk_dig_div =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_TOP_CTRL, 26, 27);\nstatic const struct reg_field pma_cmn_refclk1_dig_div =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_TOP_CTRL, 24, 25);\n\nstatic const struct reg_field sup_pll0_refclk_mux_sel =\n\t\t\t\t\tREG_FIELD(SERDES_SUP_CTRL, 0, 1);\nstatic const struct reg_field sup_pll1_refclk_mux_sel =\n\t\t\t\t\tREG_FIELD(SERDES_SUP_CTRL, 2, 3);\nstatic const struct reg_field sup_pma_cmn_refclk1_int_mode =\n\t\t\t\t\tREG_FIELD(SERDES_SUP_CTRL, 4, 5);\nstatic const struct reg_field sup_refclk_dig_sel_10g =\n\t\t\t\t\tREG_FIELD(SERDES_SUP_CTRL, 6, 7);\nstatic const struct reg_field sup_legacy_clk_override =\n\t\t\t\t\tREG_FIELD(SERDES_SUP_CTRL, 8, 8);\n\nstatic const char * const output_clk_names[] = {\n\t[TI_WIZ_PLL0_REFCLK] = \"pll0-refclk\",\n\t[TI_WIZ_PLL1_REFCLK] = \"pll1-refclk\",\n\t[TI_WIZ_REFCLK_DIG] = \"refclk-dig\",\n\t[TI_WIZ_PHY_EN_REFCLK] = \"phy-en-refclk\",\n};\n\nstatic const struct reg_field p_enable[WIZ_MAX_LANES] = {\n\tREG_FIELD(WIZ_LANECTL(0), 30, 31),\n\tREG_FIELD(WIZ_LANECTL(1), 30, 31),\n\tREG_FIELD(WIZ_LANECTL(2), 30, 31),\n\tREG_FIELD(WIZ_LANECTL(3), 30, 31),\n};\n\nenum p_enable { P_ENABLE = 2, P_ENABLE_FORCE = 1, P_ENABLE_DISABLE = 0 };\n\nstatic const struct reg_field p_align[WIZ_MAX_LANES] = {\n\tREG_FIELD(WIZ_LANECTL(0), 29, 29),\n\tREG_FIELD(WIZ_LANECTL(1), 29, 29),\n\tREG_FIELD(WIZ_LANECTL(2), 29, 29),\n\tREG_FIELD(WIZ_LANECTL(3), 29, 29),\n};\n\nstatic const struct reg_field p_raw_auto_start[WIZ_MAX_LANES] = {\n\tREG_FIELD(WIZ_LANECTL(0), 28, 28),\n\tREG_FIELD(WIZ_LANECTL(1), 28, 28),\n\tREG_FIELD(WIZ_LANECTL(2), 28, 28),\n\tREG_FIELD(WIZ_LANECTL(3), 28, 28),\n};\n\nstatic const struct reg_field p_standard_mode[WIZ_MAX_LANES] = {\n\tREG_FIELD(WIZ_LANECTL(0), 24, 25),\n\tREG_FIELD(WIZ_LANECTL(1), 24, 25),\n\tREG_FIELD(WIZ_LANECTL(2), 24, 25),\n\tREG_FIELD(WIZ_LANECTL(3), 24, 25),\n};\n\nstatic const struct reg_field p0_fullrt_div[WIZ_MAX_LANES] = {\n\tREG_FIELD(WIZ_LANECTL(0), 22, 23),\n\tREG_FIELD(WIZ_LANECTL(1), 22, 23),\n\tREG_FIELD(WIZ_LANECTL(2), 22, 23),\n\tREG_FIELD(WIZ_LANECTL(3), 22, 23),\n};\n\nstatic const struct reg_field p0_mac_src_sel[WIZ_MAX_LANES] = {\n\tREG_FIELD(WIZ_LANECTL(0), 20, 21),\n\tREG_FIELD(WIZ_LANECTL(1), 20, 21),\n\tREG_FIELD(WIZ_LANECTL(2), 20, 21),\n\tREG_FIELD(WIZ_LANECTL(3), 20, 21),\n};\n\nstatic const struct reg_field p0_rxfclk_sel[WIZ_MAX_LANES] = {\n\tREG_FIELD(WIZ_LANECTL(0), 6, 7),\n\tREG_FIELD(WIZ_LANECTL(1), 6, 7),\n\tREG_FIELD(WIZ_LANECTL(2), 6, 7),\n\tREG_FIELD(WIZ_LANECTL(3), 6, 7),\n};\n\nstatic const struct reg_field p0_refclk_sel[WIZ_MAX_LANES] = {\n\tREG_FIELD(WIZ_LANECTL(0), 18, 19),\n\tREG_FIELD(WIZ_LANECTL(1), 18, 19),\n\tREG_FIELD(WIZ_LANECTL(2), 18, 19),\n\tREG_FIELD(WIZ_LANECTL(3), 18, 19),\n};\nstatic const struct reg_field p_mac_div_sel0[WIZ_MAX_LANES] = {\n\tREG_FIELD(WIZ_LANEDIV(0), 16, 22),\n\tREG_FIELD(WIZ_LANEDIV(1), 16, 22),\n\tREG_FIELD(WIZ_LANEDIV(2), 16, 22),\n\tREG_FIELD(WIZ_LANEDIV(3), 16, 22),\n};\n\nstatic const struct reg_field p_mac_div_sel1[WIZ_MAX_LANES] = {\n\tREG_FIELD(WIZ_LANEDIV(0), 0, 8),\n\tREG_FIELD(WIZ_LANEDIV(1), 0, 8),\n\tREG_FIELD(WIZ_LANEDIV(2), 0, 8),\n\tREG_FIELD(WIZ_LANEDIV(3), 0, 8),\n};\n\nstatic const struct reg_field typec_ln10_swap =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_TYPEC, 30, 30);\n\nstatic const struct reg_field typec_ln23_swap =\n\t\t\t\t\tREG_FIELD(WIZ_SERDES_TYPEC, 31, 31);\n\nstruct wiz_clk_mux {\n\tstruct clk_hw\t\thw;\n\tstruct regmap_field\t*field;\n\tconst u32\t\t*table;\n\tstruct clk_init_data\tclk_data;\n};\n\n#define to_wiz_clk_mux(_hw) container_of(_hw, struct wiz_clk_mux, hw)\n\nstruct wiz_clk_divider {\n\tstruct clk_hw\t\thw;\n\tstruct regmap_field\t*field;\n\tconst struct clk_div_table\t*table;\n\tstruct clk_init_data\tclk_data;\n};\n\n#define to_wiz_clk_div(_hw) container_of(_hw, struct wiz_clk_divider, hw)\n\nstruct wiz_clk_mux_sel {\n\tu32\t\t\ttable[WIZ_MAX_INPUT_CLOCKS];\n\tconst char\t\t*node_name;\n\tu32\t\t\tnum_parents;\n\tu32\t\t\tparents[WIZ_MAX_INPUT_CLOCKS];\n};\n\nstruct wiz_clk_div_sel {\n\tconst struct clk_div_table *table;\n\tconst char\t\t*node_name;\n};\n\nstruct wiz_phy_en_refclk {\n\tstruct clk_hw\t\thw;\n\tstruct regmap_field\t*phy_en_refclk;\n\tstruct clk_init_data\tclk_data;\n};\n\n#define to_wiz_phy_en_refclk(_hw) container_of(_hw, struct wiz_phy_en_refclk, hw)\n\nstatic const struct wiz_clk_mux_sel clk_mux_sel_16g[] = {\n\t{\n\t\t \n\t\t.table = { 1, 0 },\n\t\t.node_name = \"pll0-refclk\",\n\t},\n\t{\n\t\t.table = { 1, 0 },\n\t\t.node_name = \"pll1-refclk\",\n\t},\n\t{\n\t\t.table = { 1, 3, 0, 2 },\n\t\t.node_name = \"refclk-dig\",\n\t},\n};\n\nstatic const struct wiz_clk_mux_sel clk_mux_sel_10g[] = {\n\t{\n\t\t \n\t\t.num_parents = 2,\n\t\t.parents = { WIZ_CORE_REFCLK, WIZ_EXT_REFCLK },\n\t\t.table = { 1, 0 },\n\t\t.node_name = \"pll0-refclk\",\n\t},\n\t{\n\t\t.num_parents = 2,\n\t\t.parents = { WIZ_CORE_REFCLK, WIZ_EXT_REFCLK },\n\t\t.table = { 1, 0 },\n\t\t.node_name = \"pll1-refclk\",\n\t},\n\t{\n\t\t.num_parents = 2,\n\t\t.parents = { WIZ_CORE_REFCLK, WIZ_EXT_REFCLK },\n\t\t.table = { 1, 0 },\n\t\t.node_name = \"refclk-dig\",\n\t},\n};\n\nstatic const struct wiz_clk_mux_sel clk_mux_sel_10g_2_refclk[] = {\n\t{\n\t\t.num_parents = 3,\n\t\t.parents = { WIZ_CORE_REFCLK, WIZ_CORE_REFCLK1, WIZ_EXT_REFCLK },\n\t\t.table = { 2, 3, 0 },\n\t\t.node_name = \"pll0-refclk\",\n\t},\n\t{\n\t\t.num_parents = 3,\n\t\t.parents = { WIZ_CORE_REFCLK, WIZ_CORE_REFCLK1, WIZ_EXT_REFCLK },\n\t\t.table = { 2, 3, 0 },\n\t\t.node_name = \"pll1-refclk\",\n\t},\n\t{\n\t\t.num_parents = 3,\n\t\t.parents = { WIZ_CORE_REFCLK, WIZ_CORE_REFCLK1, WIZ_EXT_REFCLK },\n\t\t.table = { 2, 3, 0 },\n\t\t.node_name = \"refclk-dig\",\n\t},\n};\n\nstatic const struct clk_div_table clk_div_table[] = {\n\t{ .val = 0, .div = 1, },\n\t{ .val = 1, .div = 2, },\n\t{ .val = 2, .div = 4, },\n\t{ .val = 3, .div = 8, },\n\t{   },\n};\n\nstatic const struct wiz_clk_div_sel clk_div_sel[] = {\n\t{\n\t\t.table = clk_div_table,\n\t\t.node_name = \"cmn-refclk-dig-div\",\n\t},\n\t{\n\t\t.table = clk_div_table,\n\t\t.node_name = \"cmn-refclk1-dig-div\",\n\t},\n};\n\nenum wiz_type {\n\tJ721E_WIZ_16G,\n\tJ721E_WIZ_10G,\t \n\tAM64_WIZ_10G,\n\tJ7200_WIZ_10G,   \n\tJ784S4_WIZ_10G,\n\tJ721S2_WIZ_10G,\n};\n\nstruct wiz_data {\n\tenum wiz_type type;\n\tconst struct reg_field *pll0_refclk_mux_sel;\n\tconst struct reg_field *pll1_refclk_mux_sel;\n\tconst struct reg_field *refclk_dig_sel;\n\tconst struct reg_field *pma_cmn_refclk1_dig_div;\n\tconst struct reg_field *pma_cmn_refclk1_int_mode;\n\tconst struct wiz_clk_mux_sel *clk_mux_sel;\n\tunsigned int clk_div_sel_num;\n};\n\n#define WIZ_TYPEC_DIR_DEBOUNCE_MIN\t100\t \n#define WIZ_TYPEC_DIR_DEBOUNCE_MAX\t1000\n\nstruct wiz {\n\tstruct regmap\t\t*regmap;\n\tstruct regmap\t\t*scm_regmap;\n\tenum wiz_type\t\ttype;\n\tconst struct wiz_clk_mux_sel *clk_mux_sel;\n\tconst struct wiz_clk_div_sel *clk_div_sel;\n\tunsigned int\t\tclk_div_sel_num;\n\tstruct regmap_field\t*por_en;\n\tstruct regmap_field\t*phy_reset_n;\n\tstruct regmap_field\t*phy_en_refclk;\n\tstruct regmap_field\t*p_enable[WIZ_MAX_LANES];\n\tstruct regmap_field\t*p_align[WIZ_MAX_LANES];\n\tstruct regmap_field\t*p_raw_auto_start[WIZ_MAX_LANES];\n\tstruct regmap_field\t*p_standard_mode[WIZ_MAX_LANES];\n\tstruct regmap_field\t*p_mac_div_sel0[WIZ_MAX_LANES];\n\tstruct regmap_field\t*p_mac_div_sel1[WIZ_MAX_LANES];\n\tstruct regmap_field\t*p0_fullrt_div[WIZ_MAX_LANES];\n\tstruct regmap_field\t*p0_mac_src_sel[WIZ_MAX_LANES];\n\tstruct regmap_field\t*p0_rxfclk_sel[WIZ_MAX_LANES];\n\tstruct regmap_field\t*p0_refclk_sel[WIZ_MAX_LANES];\n\tstruct regmap_field\t*pma_cmn_refclk_int_mode;\n\tstruct regmap_field\t*pma_cmn_refclk1_int_mode;\n\tstruct regmap_field\t*pma_cmn_refclk_mode;\n\tstruct regmap_field\t*pma_cmn_refclk_dig_div;\n\tstruct regmap_field\t*pma_cmn_refclk1_dig_div;\n\tstruct regmap_field\t*mux_sel_field[WIZ_MUX_NUM_CLOCKS];\n\tstruct regmap_field\t*div_sel_field[WIZ_DIV_NUM_CLOCKS_16G];\n\tstruct regmap_field\t*typec_ln10_swap;\n\tstruct regmap_field\t*typec_ln23_swap;\n\tstruct regmap_field\t*sup_legacy_clk_override;\n\n\tstruct device\t\t*dev;\n\tu32\t\t\tnum_lanes;\n\tstruct platform_device\t*serdes_pdev;\n\tstruct reset_controller_dev wiz_phy_reset_dev;\n\tstruct gpio_desc\t*gpio_typec_dir;\n\tint\t\t\ttypec_dir_delay;\n\tu32 lane_phy_type[WIZ_MAX_LANES];\n\tu32 master_lane_num[WIZ_MAX_LANES];\n\tstruct clk\t\t*input_clks[WIZ_MAX_INPUT_CLOCKS];\n\tstruct clk\t\t*output_clks[WIZ_MAX_OUTPUT_CLOCKS];\n\tstruct clk_onecell_data\tclk_data;\n\tconst struct wiz_data\t*data;\n};\n\nstatic int wiz_reset(struct wiz *wiz)\n{\n\tint ret;\n\n\tret = regmap_field_write(wiz->por_en, 0x1);\n\tif (ret)\n\t\treturn ret;\n\n\tmdelay(1);\n\n\tret = regmap_field_write(wiz->por_en, 0x0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int wiz_p_mac_div_sel(struct wiz *wiz)\n{\n\tu32 num_lanes = wiz->num_lanes;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < num_lanes; i++) {\n\t\tif (wiz->lane_phy_type[i] == PHY_TYPE_SGMII ||\n\t\t    wiz->lane_phy_type[i] == PHY_TYPE_QSGMII ||\n\t\t    wiz->lane_phy_type[i] == PHY_TYPE_USXGMII) {\n\t\t\tret = regmap_field_write(wiz->p_mac_div_sel0[i], 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = regmap_field_write(wiz->p_mac_div_sel1[i], 2);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wiz_mode_select(struct wiz *wiz)\n{\n\tu32 num_lanes = wiz->num_lanes;\n\tenum wiz_lane_standard_mode mode;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < num_lanes; i++) {\n\t\tif (wiz->lane_phy_type[i] == PHY_TYPE_DP) {\n\t\t\tmode = LANE_MODE_GEN1;\n\t\t} else if (wiz->lane_phy_type[i] == PHY_TYPE_QSGMII) {\n\t\t\tmode = LANE_MODE_GEN2;\n\t\t} else if (wiz->lane_phy_type[i] == PHY_TYPE_USXGMII) {\n\t\t\tret = regmap_field_write(wiz->p0_mac_src_sel[i], 0x3);\n\t\t\tret = regmap_field_write(wiz->p0_rxfclk_sel[i], 0x3);\n\t\t\tret = regmap_field_write(wiz->p0_refclk_sel[i], 0x3);\n\t\t\tmode = LANE_MODE_GEN1;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = regmap_field_write(wiz->p_standard_mode[i], mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wiz_init_raw_interface(struct wiz *wiz, bool enable)\n{\n\tu32 num_lanes = wiz->num_lanes;\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < num_lanes; i++) {\n\t\tret = regmap_field_write(wiz->p_align[i], enable);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_field_write(wiz->p_raw_auto_start[i], enable);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wiz_init(struct wiz *wiz)\n{\n\tstruct device *dev = wiz->dev;\n\tint ret;\n\n\tret = wiz_reset(wiz);\n\tif (ret) {\n\t\tdev_err(dev, \"WIZ reset failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = wiz_mode_select(wiz);\n\tif (ret) {\n\t\tdev_err(dev, \"WIZ mode select failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = wiz_p_mac_div_sel(wiz);\n\tif (ret) {\n\t\tdev_err(dev, \"Configuring P0 MAC DIV SEL failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = wiz_init_raw_interface(wiz, true);\n\tif (ret) {\n\t\tdev_err(dev, \"WIZ interface initialization failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wiz_regfield_init(struct wiz *wiz)\n{\n\tstruct regmap *regmap = wiz->regmap;\n\tstruct regmap *scm_regmap = wiz->regmap;  \n\tint num_lanes = wiz->num_lanes;\n\tstruct device *dev = wiz->dev;\n\tconst struct wiz_data *data = wiz->data;\n\tint i;\n\n\twiz->por_en = devm_regmap_field_alloc(dev, regmap, por_en);\n\tif (IS_ERR(wiz->por_en)) {\n\t\tdev_err(dev, \"POR_EN reg field init failed\\n\");\n\t\treturn PTR_ERR(wiz->por_en);\n\t}\n\n\twiz->phy_reset_n = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\t   phy_reset_n);\n\tif (IS_ERR(wiz->phy_reset_n)) {\n\t\tdev_err(dev, \"PHY_RESET_N reg field init failed\\n\");\n\t\treturn PTR_ERR(wiz->phy_reset_n);\n\t}\n\n\twiz->pma_cmn_refclk_int_mode =\n\t\tdevm_regmap_field_alloc(dev, regmap, pma_cmn_refclk_int_mode);\n\tif (IS_ERR(wiz->pma_cmn_refclk_int_mode)) {\n\t\tdev_err(dev, \"PMA_CMN_REFCLK_INT_MODE reg field init failed\\n\");\n\t\treturn PTR_ERR(wiz->pma_cmn_refclk_int_mode);\n\t}\n\n\twiz->pma_cmn_refclk_mode =\n\t\tdevm_regmap_field_alloc(dev, regmap, pma_cmn_refclk_mode);\n\tif (IS_ERR(wiz->pma_cmn_refclk_mode)) {\n\t\tdev_err(dev, \"PMA_CMN_REFCLK_MODE reg field init failed\\n\");\n\t\treturn PTR_ERR(wiz->pma_cmn_refclk_mode);\n\t}\n\n\twiz->div_sel_field[CMN_REFCLK_DIG_DIV] =\n\t\tdevm_regmap_field_alloc(dev, regmap, pma_cmn_refclk_dig_div);\n\tif (IS_ERR(wiz->div_sel_field[CMN_REFCLK_DIG_DIV])) {\n\t\tdev_err(dev, \"PMA_CMN_REFCLK_DIG_DIV reg field init failed\\n\");\n\t\treturn PTR_ERR(wiz->div_sel_field[CMN_REFCLK_DIG_DIV]);\n\t}\n\n\tif (data->pma_cmn_refclk1_dig_div) {\n\t\twiz->div_sel_field[CMN_REFCLK1_DIG_DIV] =\n\t\t\tdevm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\t*data->pma_cmn_refclk1_dig_div);\n\t\tif (IS_ERR(wiz->div_sel_field[CMN_REFCLK1_DIG_DIV])) {\n\t\t\tdev_err(dev, \"PMA_CMN_REFCLK1_DIG_DIV reg field init failed\\n\");\n\t\t\treturn PTR_ERR(wiz->div_sel_field[CMN_REFCLK1_DIG_DIV]);\n\t\t}\n\t}\n\n\tif (wiz->scm_regmap) {\n\t\tscm_regmap = wiz->scm_regmap;\n\t\twiz->sup_legacy_clk_override =\n\t\t\tdevm_regmap_field_alloc(dev, scm_regmap, sup_legacy_clk_override);\n\t\tif (IS_ERR(wiz->sup_legacy_clk_override)) {\n\t\t\tdev_err(dev, \"SUP_LEGACY_CLK_OVERRIDE reg field init failed\\n\");\n\t\t\treturn PTR_ERR(wiz->sup_legacy_clk_override);\n\t\t}\n\t}\n\n\twiz->mux_sel_field[PLL0_REFCLK] =\n\t\tdevm_regmap_field_alloc(dev, scm_regmap, *data->pll0_refclk_mux_sel);\n\tif (IS_ERR(wiz->mux_sel_field[PLL0_REFCLK])) {\n\t\tdev_err(dev, \"PLL0_REFCLK_SEL reg field init failed\\n\");\n\t\treturn PTR_ERR(wiz->mux_sel_field[PLL0_REFCLK]);\n\t}\n\n\twiz->mux_sel_field[PLL1_REFCLK] =\n\t\tdevm_regmap_field_alloc(dev, scm_regmap, *data->pll1_refclk_mux_sel);\n\tif (IS_ERR(wiz->mux_sel_field[PLL1_REFCLK])) {\n\t\tdev_err(dev, \"PLL1_REFCLK_SEL reg field init failed\\n\");\n\t\treturn PTR_ERR(wiz->mux_sel_field[PLL1_REFCLK]);\n\t}\n\n\twiz->mux_sel_field[REFCLK_DIG] = devm_regmap_field_alloc(dev, scm_regmap,\n\t\t\t\t\t\t\t\t *data->refclk_dig_sel);\n\tif (IS_ERR(wiz->mux_sel_field[REFCLK_DIG])) {\n\t\tdev_err(dev, \"REFCLK_DIG_SEL reg field init failed\\n\");\n\t\treturn PTR_ERR(wiz->mux_sel_field[REFCLK_DIG]);\n\t}\n\n\tif (data->pma_cmn_refclk1_int_mode) {\n\t\twiz->pma_cmn_refclk1_int_mode =\n\t\t\tdevm_regmap_field_alloc(dev, scm_regmap, *data->pma_cmn_refclk1_int_mode);\n\t\tif (IS_ERR(wiz->pma_cmn_refclk1_int_mode)) {\n\t\t\tdev_err(dev, \"PMA_CMN_REFCLK1_INT_MODE reg field init failed\\n\");\n\t\t\treturn PTR_ERR(wiz->pma_cmn_refclk1_int_mode);\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_lanes; i++) {\n\t\twiz->p_enable[i] = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\t\t   p_enable[i]);\n\t\tif (IS_ERR(wiz->p_enable[i])) {\n\t\t\tdev_err(dev, \"P%d_ENABLE reg field init failed\\n\", i);\n\t\t\treturn PTR_ERR(wiz->p_enable[i]);\n\t\t}\n\n\t\twiz->p_align[i] = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\t\t  p_align[i]);\n\t\tif (IS_ERR(wiz->p_align[i])) {\n\t\t\tdev_err(dev, \"P%d_ALIGN reg field init failed\\n\", i);\n\t\t\treturn PTR_ERR(wiz->p_align[i]);\n\t\t}\n\n\t\twiz->p_raw_auto_start[i] =\n\t\t  devm_regmap_field_alloc(dev, regmap, p_raw_auto_start[i]);\n\t\tif (IS_ERR(wiz->p_raw_auto_start[i])) {\n\t\t\tdev_err(dev, \"P%d_RAW_AUTO_START reg field init fail\\n\",\n\t\t\t\ti);\n\t\t\treturn PTR_ERR(wiz->p_raw_auto_start[i]);\n\t\t}\n\n\t\twiz->p_standard_mode[i] =\n\t\t  devm_regmap_field_alloc(dev, regmap, p_standard_mode[i]);\n\t\tif (IS_ERR(wiz->p_standard_mode[i])) {\n\t\t\tdev_err(dev, \"P%d_STANDARD_MODE reg field init fail\\n\",\n\t\t\t\ti);\n\t\t\treturn PTR_ERR(wiz->p_standard_mode[i]);\n\t\t}\n\n\t\twiz->p0_fullrt_div[i] = devm_regmap_field_alloc(dev, regmap, p0_fullrt_div[i]);\n\t\tif (IS_ERR(wiz->p0_fullrt_div[i])) {\n\t\t\tdev_err(dev, \"P%d_FULLRT_DIV reg field init failed\\n\", i);\n\t\t\treturn PTR_ERR(wiz->p0_fullrt_div[i]);\n\t\t}\n\n\t\twiz->p0_mac_src_sel[i] = devm_regmap_field_alloc(dev, regmap, p0_mac_src_sel[i]);\n\t\tif (IS_ERR(wiz->p0_mac_src_sel[i])) {\n\t\t\tdev_err(dev, \"P%d_MAC_SRC_SEL reg field init failed\\n\", i);\n\t\t\treturn PTR_ERR(wiz->p0_mac_src_sel[i]);\n\t\t}\n\n\t\twiz->p0_rxfclk_sel[i] = devm_regmap_field_alloc(dev, regmap, p0_rxfclk_sel[i]);\n\t\tif (IS_ERR(wiz->p0_rxfclk_sel[i])) {\n\t\t\tdev_err(dev, \"P%d_RXFCLK_SEL reg field init failed\\n\", i);\n\t\t\treturn PTR_ERR(wiz->p0_rxfclk_sel[i]);\n\t\t}\n\n\t\twiz->p0_refclk_sel[i] = devm_regmap_field_alloc(dev, regmap, p0_refclk_sel[i]);\n\t\tif (IS_ERR(wiz->p0_refclk_sel[i])) {\n\t\t\tdev_err(dev, \"P%d_REFCLK_SEL reg field init failed\\n\", i);\n\t\t\treturn PTR_ERR(wiz->p0_refclk_sel[i]);\n\t\t}\n\n\t\twiz->p_mac_div_sel0[i] =\n\t\t  devm_regmap_field_alloc(dev, regmap, p_mac_div_sel0[i]);\n\t\tif (IS_ERR(wiz->p_mac_div_sel0[i])) {\n\t\t\tdev_err(dev, \"P%d_MAC_DIV_SEL0 reg field init fail\\n\",\n\t\t\t\ti);\n\t\t\treturn PTR_ERR(wiz->p_mac_div_sel0[i]);\n\t\t}\n\n\t\twiz->p_mac_div_sel1[i] =\n\t\t  devm_regmap_field_alloc(dev, regmap, p_mac_div_sel1[i]);\n\t\tif (IS_ERR(wiz->p_mac_div_sel1[i])) {\n\t\t\tdev_err(dev, \"P%d_MAC_DIV_SEL1 reg field init fail\\n\",\n\t\t\t\ti);\n\t\t\treturn PTR_ERR(wiz->p_mac_div_sel1[i]);\n\t\t}\n\t}\n\n\twiz->typec_ln10_swap = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\t       typec_ln10_swap);\n\tif (IS_ERR(wiz->typec_ln10_swap)) {\n\t\tdev_err(dev, \"LN10_SWAP reg field init failed\\n\");\n\t\treturn PTR_ERR(wiz->typec_ln10_swap);\n\t}\n\n\twiz->typec_ln23_swap = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\t       typec_ln23_swap);\n\tif (IS_ERR(wiz->typec_ln23_swap)) {\n\t\tdev_err(dev, \"LN23_SWAP reg field init failed\\n\");\n\t\treturn PTR_ERR(wiz->typec_ln23_swap);\n\t}\n\n\twiz->phy_en_refclk = devm_regmap_field_alloc(dev, regmap, phy_en_refclk);\n\tif (IS_ERR(wiz->phy_en_refclk)) {\n\t\tdev_err(dev, \"PHY_EN_REFCLK reg field init failed\\n\");\n\t\treturn PTR_ERR(wiz->phy_en_refclk);\n\t}\n\n\treturn 0;\n}\n\nstatic int wiz_phy_en_refclk_enable(struct clk_hw *hw)\n{\n\tstruct wiz_phy_en_refclk *wiz_phy_en_refclk = to_wiz_phy_en_refclk(hw);\n\tstruct regmap_field *phy_en_refclk = wiz_phy_en_refclk->phy_en_refclk;\n\n\tregmap_field_write(phy_en_refclk, 1);\n\n\treturn 0;\n}\n\nstatic void wiz_phy_en_refclk_disable(struct clk_hw *hw)\n{\n\tstruct wiz_phy_en_refclk *wiz_phy_en_refclk = to_wiz_phy_en_refclk(hw);\n\tstruct regmap_field *phy_en_refclk = wiz_phy_en_refclk->phy_en_refclk;\n\n\tregmap_field_write(phy_en_refclk, 0);\n}\n\nstatic int wiz_phy_en_refclk_is_enabled(struct clk_hw *hw)\n{\n\tstruct wiz_phy_en_refclk *wiz_phy_en_refclk = to_wiz_phy_en_refclk(hw);\n\tstruct regmap_field *phy_en_refclk = wiz_phy_en_refclk->phy_en_refclk;\n\tint val;\n\n\tregmap_field_read(phy_en_refclk, &val);\n\n\treturn !!val;\n}\n\nstatic const struct clk_ops wiz_phy_en_refclk_ops = {\n\t.enable = wiz_phy_en_refclk_enable,\n\t.disable = wiz_phy_en_refclk_disable,\n\t.is_enabled = wiz_phy_en_refclk_is_enabled,\n};\n\nstatic int wiz_phy_en_refclk_register(struct wiz *wiz)\n{\n\tstruct wiz_phy_en_refclk *wiz_phy_en_refclk;\n\tstruct device *dev = wiz->dev;\n\tstruct clk_init_data *init;\n\tstruct clk *clk;\n\tchar *clk_name;\n\tunsigned int sz;\n\n\twiz_phy_en_refclk = devm_kzalloc(dev, sizeof(*wiz_phy_en_refclk), GFP_KERNEL);\n\tif (!wiz_phy_en_refclk)\n\t\treturn -ENOMEM;\n\n\tinit = &wiz_phy_en_refclk->clk_data;\n\n\tinit->ops = &wiz_phy_en_refclk_ops;\n\tinit->flags = 0;\n\n\tsz = strlen(dev_name(dev)) + strlen(output_clk_names[TI_WIZ_PHY_EN_REFCLK]) + 2;\n\n\tclk_name = kzalloc(sz, GFP_KERNEL);\n\tif (!clk_name)\n\t\treturn -ENOMEM;\n\n\tsnprintf(clk_name, sz, \"%s_%s\", dev_name(dev), output_clk_names[TI_WIZ_PHY_EN_REFCLK]);\n\tinit->name = clk_name;\n\n\twiz_phy_en_refclk->phy_en_refclk = wiz->phy_en_refclk;\n\twiz_phy_en_refclk->hw.init = init;\n\n\tclk = devm_clk_register(dev, &wiz_phy_en_refclk->hw);\n\n\tkfree(clk_name);\n\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\twiz->output_clks[TI_WIZ_PHY_EN_REFCLK] = clk;\n\n\treturn 0;\n}\n\nstatic u8 wiz_clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct wiz_clk_mux *mux = to_wiz_clk_mux(hw);\n\tstruct regmap_field *field = mux->field;\n\tunsigned int val;\n\n\tregmap_field_read(field, &val);\n\treturn clk_mux_val_to_index(hw, (u32 *)mux->table, 0, val);\n}\n\nstatic int wiz_clk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct wiz_clk_mux *mux = to_wiz_clk_mux(hw);\n\tstruct regmap_field *field = mux->field;\n\tint val;\n\n\tval = mux->table[index];\n\treturn regmap_field_write(field, val);\n}\n\nstatic const struct clk_ops wiz_clk_mux_ops = {\n\t.determine_rate = __clk_mux_determine_rate,\n\t.set_parent = wiz_clk_mux_set_parent,\n\t.get_parent = wiz_clk_mux_get_parent,\n};\n\nstatic int wiz_mux_clk_register(struct wiz *wiz, struct regmap_field *field,\n\t\t\t\tconst struct wiz_clk_mux_sel *mux_sel, int clk_index)\n{\n\tstruct device *dev = wiz->dev;\n\tstruct clk_init_data *init;\n\tconst char **parent_names;\n\tunsigned int num_parents;\n\tstruct wiz_clk_mux *mux;\n\tchar clk_name[100];\n\tstruct clk *clk;\n\tint ret = 0, i;\n\n\tmux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn -ENOMEM;\n\n\tnum_parents = mux_sel->num_parents;\n\n\tparent_names = kzalloc((sizeof(char *) * num_parents), GFP_KERNEL);\n\tif (!parent_names)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_parents; i++) {\n\t\tclk = wiz->input_clks[mux_sel->parents[i]];\n\t\tif (IS_ERR_OR_NULL(clk)) {\n\t\t\tdev_err(dev, \"Failed to get parent clk for %s\\n\",\n\t\t\t\toutput_clk_names[clk_index]);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tparent_names[i] = __clk_get_name(clk);\n\t}\n\n\tsnprintf(clk_name, sizeof(clk_name), \"%s_%s\", dev_name(dev), output_clk_names[clk_index]);\n\n\tinit = &mux->clk_data;\n\n\tinit->ops = &wiz_clk_mux_ops;\n\tinit->flags = CLK_SET_RATE_NO_REPARENT;\n\tinit->parent_names = parent_names;\n\tinit->num_parents = num_parents;\n\tinit->name = clk_name;\n\n\tmux->field = field;\n\tmux->table = mux_sel->table;\n\tmux->hw.init = init;\n\n\tclk = devm_clk_register(dev, &mux->hw);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto err;\n\t}\n\n\twiz->output_clks[clk_index] = clk;\n\nerr:\n\tkfree(parent_names);\n\n\treturn ret;\n}\n\nstatic int wiz_mux_of_clk_register(struct wiz *wiz, struct device_node *node,\n\t\t\t\t   struct regmap_field *field, const u32 *table)\n{\n\tstruct device *dev = wiz->dev;\n\tstruct clk_init_data *init;\n\tconst char **parent_names;\n\tunsigned int num_parents;\n\tstruct wiz_clk_mux *mux;\n\tchar clk_name[100];\n\tstruct clk *clk;\n\tint ret;\n\n\tmux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn -ENOMEM;\n\n\tnum_parents = of_clk_get_parent_count(node);\n\tif (num_parents < 2) {\n\t\tdev_err(dev, \"SERDES clock must have parents\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tparent_names = devm_kzalloc(dev, (sizeof(char *) * num_parents),\n\t\t\t\t    GFP_KERNEL);\n\tif (!parent_names)\n\t\treturn -ENOMEM;\n\n\tof_clk_parent_fill(node, parent_names, num_parents);\n\n\tsnprintf(clk_name, sizeof(clk_name), \"%s_%s\", dev_name(dev),\n\t\t node->name);\n\n\tinit = &mux->clk_data;\n\n\tinit->ops = &wiz_clk_mux_ops;\n\tinit->flags = CLK_SET_RATE_NO_REPARENT;\n\tinit->parent_names = parent_names;\n\tinit->num_parents = num_parents;\n\tinit->name = clk_name;\n\n\tmux->field = field;\n\tmux->table = table;\n\tmux->hw.init = init;\n\n\tclk = devm_clk_register(dev, &mux->hw);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tret = of_clk_add_provider(node, of_clk_src_simple_get, clk);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to add clock provider: %s\\n\", clk_name);\n\n\treturn ret;\n}\n\nstatic unsigned long wiz_clk_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct wiz_clk_divider *div = to_wiz_clk_div(hw);\n\tstruct regmap_field *field = div->field;\n\tint val;\n\n\tregmap_field_read(field, &val);\n\n\treturn divider_recalc_rate(hw, parent_rate, val, div->table, 0x0, 2);\n}\n\nstatic long wiz_clk_div_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long *prate)\n{\n\tstruct wiz_clk_divider *div = to_wiz_clk_div(hw);\n\n\treturn divider_round_rate(hw, rate, prate, div->table, 2, 0x0);\n}\n\nstatic int wiz_clk_div_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct wiz_clk_divider *div = to_wiz_clk_div(hw);\n\tstruct regmap_field *field = div->field;\n\tint val;\n\n\tval = divider_get_val(rate, parent_rate, div->table, 2, 0x0);\n\tif (val < 0)\n\t\treturn val;\n\n\treturn regmap_field_write(field, val);\n}\n\nstatic const struct clk_ops wiz_clk_div_ops = {\n\t.recalc_rate = wiz_clk_div_recalc_rate,\n\t.round_rate = wiz_clk_div_round_rate,\n\t.set_rate = wiz_clk_div_set_rate,\n};\n\nstatic int wiz_div_clk_register(struct wiz *wiz, struct device_node *node,\n\t\t\t\tstruct regmap_field *field,\n\t\t\t\tconst struct clk_div_table *table)\n{\n\tstruct device *dev = wiz->dev;\n\tstruct wiz_clk_divider *div;\n\tstruct clk_init_data *init;\n\tconst char **parent_names;\n\tchar clk_name[100];\n\tstruct clk *clk;\n\tint ret;\n\n\tdiv = devm_kzalloc(dev, sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn -ENOMEM;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"%s_%s\", dev_name(dev),\n\t\t node->name);\n\n\tparent_names = devm_kzalloc(dev, sizeof(char *), GFP_KERNEL);\n\tif (!parent_names)\n\t\treturn -ENOMEM;\n\n\tof_clk_parent_fill(node, parent_names, 1);\n\n\tinit = &div->clk_data;\n\n\tinit->ops = &wiz_clk_div_ops;\n\tinit->flags = 0;\n\tinit->parent_names = parent_names;\n\tinit->num_parents = 1;\n\tinit->name = clk_name;\n\n\tdiv->field = field;\n\tdiv->table = table;\n\tdiv->hw.init = init;\n\n\tclk = devm_clk_register(dev, &div->hw);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tret = of_clk_add_provider(node, of_clk_src_simple_get, clk);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to add clock provider: %s\\n\", clk_name);\n\n\treturn ret;\n}\n\nstatic void wiz_clock_cleanup(struct wiz *wiz, struct device_node *node)\n{\n\tconst struct wiz_clk_mux_sel *clk_mux_sel = wiz->clk_mux_sel;\n\tstruct device *dev = wiz->dev;\n\tstruct device_node *clk_node;\n\tint i;\n\n\tswitch (wiz->type) {\n\tcase AM64_WIZ_10G:\n\tcase J7200_WIZ_10G:\n\tcase J784S4_WIZ_10G:\n\tcase J721S2_WIZ_10G:\n\t\tof_clk_del_provider(dev->of_node);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < WIZ_MUX_NUM_CLOCKS; i++) {\n\t\tclk_node = of_get_child_by_name(node, clk_mux_sel[i].node_name);\n\t\tof_clk_del_provider(clk_node);\n\t\tof_node_put(clk_node);\n\t}\n\n\tfor (i = 0; i < wiz->clk_div_sel_num; i++) {\n\t\tclk_node = of_get_child_by_name(node, clk_div_sel[i].node_name);\n\t\tof_clk_del_provider(clk_node);\n\t\tof_node_put(clk_node);\n\t}\n\n\tof_clk_del_provider(wiz->dev->of_node);\n}\n\nstatic int wiz_clock_register(struct wiz *wiz)\n{\n\tconst struct wiz_clk_mux_sel *clk_mux_sel = wiz->clk_mux_sel;\n\tstruct device *dev = wiz->dev;\n\tstruct device_node *node = dev->of_node;\n\tint clk_index;\n\tint ret;\n\tint i;\n\n\tclk_index = TI_WIZ_PLL0_REFCLK;\n\tfor (i = 0; i < WIZ_MUX_NUM_CLOCKS; i++, clk_index++) {\n\t\tret = wiz_mux_clk_register(wiz, wiz->mux_sel_field[i], &clk_mux_sel[i], clk_index);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register clk: %s\\n\", output_clk_names[clk_index]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = wiz_phy_en_refclk_register(wiz);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add phy-en-refclk\\n\");\n\t\treturn ret;\n\t}\n\n\twiz->clk_data.clks = wiz->output_clks;\n\twiz->clk_data.clk_num = WIZ_MAX_OUTPUT_CLOCKS;\n\tret = of_clk_add_provider(node, of_clk_src_onecell_get, &wiz->clk_data);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to add clock provider: %s\\n\", node->name);\n\n\treturn ret;\n}\n\nstatic int wiz_clock_init(struct wiz *wiz, struct device_node *node)\n{\n\tconst struct wiz_clk_mux_sel *clk_mux_sel = wiz->clk_mux_sel;\n\tstruct device *dev = wiz->dev;\n\tstruct device_node *clk_node;\n\tconst char *node_name;\n\tunsigned long rate;\n\tstruct clk *clk;\n\tint ret;\n\tint i;\n\n\tclk = devm_clk_get(dev, \"core_ref_clk\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"core_ref_clk clock not found\\n\");\n\t\tret = PTR_ERR(clk);\n\t\treturn ret;\n\t}\n\twiz->input_clks[WIZ_CORE_REFCLK] = clk;\n\n\trate = clk_get_rate(clk);\n\tif (rate >= 100000000)\n\t\tregmap_field_write(wiz->pma_cmn_refclk_int_mode, 0x1);\n\telse\n\t\tregmap_field_write(wiz->pma_cmn_refclk_int_mode, 0x3);\n\n\tswitch (wiz->type) {\n\tcase AM64_WIZ_10G:\n\tcase J7200_WIZ_10G:\n\t\tswitch (rate) {\n\t\tcase REF_CLK_100MHZ:\n\t\t\tregmap_field_write(wiz->div_sel_field[CMN_REFCLK_DIG_DIV], 0x2);\n\t\t\tbreak;\n\t\tcase REF_CLK_156_25MHZ:\n\t\t\tregmap_field_write(wiz->div_sel_field[CMN_REFCLK_DIG_DIV], 0x3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tregmap_field_write(wiz->div_sel_field[CMN_REFCLK_DIG_DIV], 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (wiz->data->pma_cmn_refclk1_int_mode) {\n\t\tclk = devm_clk_get(dev, \"core_ref1_clk\");\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_err(dev, \"core_ref1_clk clock not found\\n\");\n\t\t\tret = PTR_ERR(clk);\n\t\t\treturn ret;\n\t\t}\n\t\twiz->input_clks[WIZ_CORE_REFCLK1] = clk;\n\n\t\trate = clk_get_rate(clk);\n\t\tif (rate >= 100000000)\n\t\t\tregmap_field_write(wiz->pma_cmn_refclk1_int_mode, 0x1);\n\t\telse\n\t\t\tregmap_field_write(wiz->pma_cmn_refclk1_int_mode, 0x3);\n\t}\n\n\tclk = devm_clk_get(dev, \"ext_ref_clk\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"ext_ref_clk clock not found\\n\");\n\t\tret = PTR_ERR(clk);\n\t\treturn ret;\n\t}\n\twiz->input_clks[WIZ_EXT_REFCLK] = clk;\n\n\trate = clk_get_rate(clk);\n\tif (rate >= 100000000)\n\t\tregmap_field_write(wiz->pma_cmn_refclk_mode, 0x0);\n\telse\n\t\tregmap_field_write(wiz->pma_cmn_refclk_mode, 0x2);\n\n\tswitch (wiz->type) {\n\tcase AM64_WIZ_10G:\n\tcase J7200_WIZ_10G:\n\tcase J784S4_WIZ_10G:\n\tcase J721S2_WIZ_10G:\n\t\tret = wiz_clock_register(wiz);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Failed to register wiz clocks\\n\");\n\t\treturn ret;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < WIZ_MUX_NUM_CLOCKS; i++) {\n\t\tnode_name = clk_mux_sel[i].node_name;\n\t\tclk_node = of_get_child_by_name(node, node_name);\n\t\tif (!clk_node) {\n\t\t\tdev_err(dev, \"Unable to get %s node\\n\", node_name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = wiz_mux_of_clk_register(wiz, clk_node, wiz->mux_sel_field[i],\n\t\t\t\t\t      clk_mux_sel[i].table);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register %s clock\\n\",\n\t\t\t\tnode_name);\n\t\t\tof_node_put(clk_node);\n\t\t\tgoto err;\n\t\t}\n\n\t\tof_node_put(clk_node);\n\t}\n\n\tfor (i = 0; i < wiz->clk_div_sel_num; i++) {\n\t\tnode_name = clk_div_sel[i].node_name;\n\t\tclk_node = of_get_child_by_name(node, node_name);\n\t\tif (!clk_node) {\n\t\t\tdev_err(dev, \"Unable to get %s node\\n\", node_name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = wiz_div_clk_register(wiz, clk_node, wiz->div_sel_field[i],\n\t\t\t\t\t   clk_div_sel[i].table);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register %s clock\\n\",\n\t\t\t\tnode_name);\n\t\t\tof_node_put(clk_node);\n\t\t\tgoto err;\n\t\t}\n\n\t\tof_node_put(clk_node);\n\t}\n\n\treturn 0;\nerr:\n\twiz_clock_cleanup(wiz, node);\n\n\treturn ret;\n}\n\nstatic int wiz_phy_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct device *dev = rcdev->dev;\n\tstruct wiz *wiz = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (id == 0) {\n\t\tret = regmap_field_write(wiz->phy_reset_n, false);\n\t\treturn ret;\n\t}\n\n\tret = regmap_field_write(wiz->p_enable[id - 1], P_ENABLE_DISABLE);\n\treturn ret;\n}\n\nstatic int wiz_phy_fullrt_div(struct wiz *wiz, int lane)\n{\n\tswitch (wiz->type) {\n\tcase AM64_WIZ_10G:\n\t\tif (wiz->lane_phy_type[lane] == PHY_TYPE_PCIE)\n\t\t\treturn regmap_field_write(wiz->p0_fullrt_div[lane], 0x1);\n\t\tbreak;\n\n\tcase J721E_WIZ_16G:\n\tcase J721E_WIZ_10G:\n\tcase J7200_WIZ_10G:\n\tcase J721S2_WIZ_10G:\n\t\tif (wiz->lane_phy_type[lane] == PHY_TYPE_SGMII)\n\t\t\treturn regmap_field_write(wiz->p0_fullrt_div[lane], 0x2);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int wiz_phy_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id)\n{\n\tstruct device *dev = rcdev->dev;\n\tstruct wiz *wiz = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (id == 0) {\n\t\t \n\t\tif (wiz->gpio_typec_dir) {\n\t\t\tif (wiz->typec_dir_delay)\n\t\t\t\tmsleep_interruptible(wiz->typec_dir_delay);\n\n\t\t\tif (gpiod_get_value_cansleep(wiz->gpio_typec_dir))\n\t\t\t\tregmap_field_write(wiz->typec_ln10_swap, 1);\n\t\t\telse\n\t\t\t\tregmap_field_write(wiz->typec_ln10_swap, 0);\n\t\t} else {\n\t\t\t \n\t\t\tu32 num_lanes = wiz->num_lanes;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < num_lanes; i++) {\n\t\t\t\tif (wiz->lane_phy_type[i] == PHY_TYPE_USB3) {\n\t\t\t\t\tswitch (wiz->master_lane_num[i]) {\n\t\t\t\t\tcase LANE0:\n\t\t\t\t\t\tregmap_field_write(wiz->typec_ln10_swap, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LANE2:\n\t\t\t\t\t\tregmap_field_write(wiz->typec_ln23_swap, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (id == 0) {\n\t\tret = regmap_field_write(wiz->phy_reset_n, true);\n\t\treturn ret;\n\t}\n\n\tret = wiz_phy_fullrt_div(wiz, id - 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (wiz->lane_phy_type[id - 1] == PHY_TYPE_DP)\n\t\tret = regmap_field_write(wiz->p_enable[id - 1], P_ENABLE);\n\telse\n\t\tret = regmap_field_write(wiz->p_enable[id - 1], P_ENABLE_FORCE);\n\n\treturn ret;\n}\n\nstatic const struct reset_control_ops wiz_phy_reset_ops = {\n\t.assert = wiz_phy_reset_assert,\n\t.deassert = wiz_phy_reset_deassert,\n};\n\nstatic const struct regmap_config wiz_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.fast_io = true,\n};\n\nstatic struct wiz_data j721e_16g_data = {\n\t.type = J721E_WIZ_16G,\n\t.pll0_refclk_mux_sel = &pll0_refclk_mux_sel,\n\t.pll1_refclk_mux_sel = &pll1_refclk_mux_sel,\n\t.refclk_dig_sel = &refclk_dig_sel_16g,\n\t.pma_cmn_refclk1_dig_div = &pma_cmn_refclk1_dig_div,\n\t.clk_mux_sel = clk_mux_sel_16g,\n\t.clk_div_sel_num = WIZ_DIV_NUM_CLOCKS_16G,\n};\n\nstatic struct wiz_data j721e_10g_data = {\n\t.type = J721E_WIZ_10G,\n\t.pll0_refclk_mux_sel = &pll0_refclk_mux_sel,\n\t.pll1_refclk_mux_sel = &pll1_refclk_mux_sel,\n\t.refclk_dig_sel = &refclk_dig_sel_10g,\n\t.clk_mux_sel = clk_mux_sel_10g,\n\t.clk_div_sel_num = WIZ_DIV_NUM_CLOCKS_10G,\n};\n\nstatic struct wiz_data am64_10g_data = {\n\t.type = AM64_WIZ_10G,\n\t.pll0_refclk_mux_sel = &pll0_refclk_mux_sel,\n\t.pll1_refclk_mux_sel = &pll1_refclk_mux_sel,\n\t.refclk_dig_sel = &refclk_dig_sel_10g,\n\t.clk_mux_sel = clk_mux_sel_10g,\n\t.clk_div_sel_num = WIZ_DIV_NUM_CLOCKS_10G,\n};\n\nstatic struct wiz_data j7200_pg2_10g_data = {\n\t.type = J7200_WIZ_10G,\n\t.pll0_refclk_mux_sel = &sup_pll0_refclk_mux_sel,\n\t.pll1_refclk_mux_sel = &sup_pll1_refclk_mux_sel,\n\t.refclk_dig_sel = &sup_refclk_dig_sel_10g,\n\t.pma_cmn_refclk1_int_mode = &sup_pma_cmn_refclk1_int_mode,\n\t.clk_mux_sel = clk_mux_sel_10g_2_refclk,\n\t.clk_div_sel_num = WIZ_DIV_NUM_CLOCKS_10G,\n};\n\nstatic struct wiz_data j784s4_10g_data = {\n\t.type = J784S4_WIZ_10G,\n\t.pll0_refclk_mux_sel = &pll0_refclk_mux_sel_2,\n\t.pll1_refclk_mux_sel = &pll1_refclk_mux_sel_2,\n\t.refclk_dig_sel = &refclk_dig_sel_16g,\n\t.pma_cmn_refclk1_int_mode = &pma_cmn_refclk1_int_mode,\n\t.clk_mux_sel = clk_mux_sel_10g_2_refclk,\n\t.clk_div_sel_num = WIZ_DIV_NUM_CLOCKS_10G,\n};\n\nstatic struct wiz_data j721s2_10g_data = {\n\t.type = J721S2_WIZ_10G,\n\t.pll0_refclk_mux_sel = &pll0_refclk_mux_sel,\n\t.pll1_refclk_mux_sel = &pll1_refclk_mux_sel,\n\t.refclk_dig_sel = &refclk_dig_sel_10g,\n\t.clk_mux_sel = clk_mux_sel_10g,\n\t.clk_div_sel_num = WIZ_DIV_NUM_CLOCKS_10G,\n};\n\nstatic const struct of_device_id wiz_id_table[] = {\n\t{\n\t\t.compatible = \"ti,j721e-wiz-16g\", .data = &j721e_16g_data,\n\t},\n\t{\n\t\t.compatible = \"ti,j721e-wiz-10g\", .data = &j721e_10g_data,\n\t},\n\t{\n\t\t.compatible = \"ti,am64-wiz-10g\", .data = &am64_10g_data,\n\t},\n\t{\n\t\t.compatible = \"ti,j7200-wiz-10g\", .data = &j7200_pg2_10g_data,\n\t},\n\t{\n\t\t.compatible = \"ti,j784s4-wiz-10g\", .data = &j784s4_10g_data,\n\t},\n\t{\n\t\t.compatible = \"ti,j721s2-wiz-10g\", .data = &j721s2_10g_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, wiz_id_table);\n\nstatic int wiz_get_lane_phy_types(struct device *dev, struct wiz *wiz)\n{\n\tstruct device_node *serdes, *subnode;\n\n\tserdes = of_get_child_by_name(dev->of_node, \"serdes\");\n\tif (!serdes) {\n\t\tdev_err(dev, \"%s: Getting \\\"serdes\\\"-node failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_child_of_node(serdes, subnode) {\n\t\tu32 reg, num_lanes = 1, phy_type = PHY_NONE;\n\t\tint ret, i;\n\n\t\tif (!(of_node_name_eq(subnode, \"phy\") ||\n\t\t      of_node_name_eq(subnode, \"link\")))\n\t\t\tcontinue;\n\n\t\tret = of_property_read_u32(subnode, \"reg\", &reg);\n\t\tif (ret) {\n\t\t\tof_node_put(subnode);\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: Reading \\\"reg\\\" from \\\"%s\\\" failed: %d\\n\",\n\t\t\t\t__func__, subnode->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tof_property_read_u32(subnode, \"cdns,num-lanes\", &num_lanes);\n\t\tof_property_read_u32(subnode, \"cdns,phy-type\", &phy_type);\n\n\t\tdev_dbg(dev, \"%s: Lanes %u-%u have phy-type %u\\n\", __func__,\n\t\t\treg, reg + num_lanes - 1, phy_type);\n\n\t\tfor (i = reg; i < reg + num_lanes; i++) {\n\t\t\twiz->master_lane_num[i] = reg;\n\t\t\twiz->lane_phy_type[i] = phy_type;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wiz_probe(struct platform_device *pdev)\n{\n\tstruct reset_controller_dev *phy_reset_dev;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct platform_device *serdes_pdev;\n\tbool already_configured = false;\n\tstruct device_node *child_node;\n\tstruct regmap *regmap;\n\tstruct resource res;\n\tvoid __iomem *base;\n\tstruct wiz *wiz;\n\tint ret, val, i;\n\tu32 num_lanes;\n\tconst struct wiz_data *data;\n\n\twiz = devm_kzalloc(dev, sizeof(*wiz), GFP_KERNEL);\n\tif (!wiz)\n\t\treturn -ENOMEM;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data) {\n\t\tdev_err(dev, \"NULL device data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twiz->data = data;\n\twiz->type = data->type;\n\n\tchild_node = of_get_child_by_name(node, \"serdes\");\n\tif (!child_node) {\n\t\tdev_err(dev, \"Failed to get SERDES child DT node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_address_to_resource(child_node, 0, &res);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get memory resource\\n\");\n\t\tgoto err_addr_to_resource;\n\t}\n\n\tbase = devm_ioremap(dev, res.start, resource_size(&res));\n\tif (!base) {\n\t\tret = -ENOMEM;\n\t\tgoto err_addr_to_resource;\n\t}\n\n\tregmap = devm_regmap_init_mmio(dev, base, &wiz_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"Failed to initialize regmap\\n\");\n\t\tret = PTR_ERR(regmap);\n\t\tgoto err_addr_to_resource;\n\t}\n\n\twiz->scm_regmap = syscon_regmap_lookup_by_phandle(node, \"ti,scm\");\n\tif (IS_ERR(wiz->scm_regmap)) {\n\t\tif (wiz->type == J7200_WIZ_10G) {\n\t\t\tdev_err(dev, \"Couldn't get ti,scm regmap\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_addr_to_resource;\n\t\t}\n\n\t\twiz->scm_regmap = NULL;\n\t}\n\n\tret = of_property_read_u32(node, \"num-lanes\", &num_lanes);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read num-lanes property\\n\");\n\t\tgoto err_addr_to_resource;\n\t}\n\n\tif (num_lanes > WIZ_MAX_LANES) {\n\t\tdev_err(dev, \"Cannot support %d lanes\\n\", num_lanes);\n\t\tret = -ENODEV;\n\t\tgoto err_addr_to_resource;\n\t}\n\n\twiz->gpio_typec_dir = devm_gpiod_get_optional(dev, \"typec-dir\",\n\t\t\t\t\t\t      GPIOD_IN);\n\tif (IS_ERR(wiz->gpio_typec_dir)) {\n\t\tret = PTR_ERR(wiz->gpio_typec_dir);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to request typec-dir gpio: %d\\n\",\n\t\t\t\tret);\n\t\tgoto err_addr_to_resource;\n\t}\n\n\tif (wiz->gpio_typec_dir) {\n\t\tret = of_property_read_u32(node, \"typec-dir-debounce-ms\",\n\t\t\t\t\t   &wiz->typec_dir_delay);\n\t\tif (ret && ret != -EINVAL) {\n\t\t\tdev_err(dev, \"Invalid typec-dir-debounce property\\n\");\n\t\t\tgoto err_addr_to_resource;\n\t\t}\n\n\t\t \n\t\tif (ret == -EINVAL)\n\t\t\twiz->typec_dir_delay = WIZ_TYPEC_DIR_DEBOUNCE_MIN;\n\n\t\tif (wiz->typec_dir_delay < WIZ_TYPEC_DIR_DEBOUNCE_MIN ||\n\t\t    wiz->typec_dir_delay > WIZ_TYPEC_DIR_DEBOUNCE_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(dev, \"Invalid typec-dir-debounce property\\n\");\n\t\t\tgoto err_addr_to_resource;\n\t\t}\n\t}\n\n\tret = wiz_get_lane_phy_types(dev, wiz);\n\tif (ret)\n\t\tgoto err_addr_to_resource;\n\n\twiz->dev = dev;\n\twiz->regmap = regmap;\n\twiz->num_lanes = num_lanes;\n\twiz->clk_mux_sel = data->clk_mux_sel;\n\twiz->clk_div_sel = clk_div_sel;\n\twiz->clk_div_sel_num = data->clk_div_sel_num;\n\n\tplatform_set_drvdata(pdev, wiz);\n\n\tret = wiz_regfield_init(wiz);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize regfields\\n\");\n\t\tgoto err_addr_to_resource;\n\t}\n\n\t \n\tif (wiz->scm_regmap)\n\t\tregmap_field_write(wiz->sup_legacy_clk_override, 1);\n\n\tphy_reset_dev = &wiz->wiz_phy_reset_dev;\n\tphy_reset_dev->dev = dev;\n\tphy_reset_dev->ops = &wiz_phy_reset_ops,\n\tphy_reset_dev->owner = THIS_MODULE,\n\tphy_reset_dev->of_node = node;\n\t \n\tphy_reset_dev->nr_resets = num_lanes + 1;\n\n\tret = devm_reset_controller_register(dev, phy_reset_dev);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to register reset controller\\n\");\n\t\tgoto err_addr_to_resource;\n\t}\n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pm_runtime_get_sync failed\\n\");\n\t\tgoto err_get_sync;\n\t}\n\n\tret = wiz_clock_init(wiz, node);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to initialize clocks\\n\");\n\t\tgoto err_get_sync;\n\t}\n\n\tfor (i = 0; i < wiz->num_lanes; i++) {\n\t\tregmap_field_read(wiz->p_enable[i], &val);\n\t\tif (val & (P_ENABLE | P_ENABLE_FORCE)) {\n\t\t\talready_configured = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!already_configured) {\n\t\tret = wiz_init(wiz);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"WIZ initialization failed\\n\");\n\t\t\tgoto err_wiz_init;\n\t\t}\n\t}\n\n\tserdes_pdev = of_platform_device_create(child_node, NULL, dev);\n\tif (!serdes_pdev) {\n\t\tdev_WARN(dev, \"Unable to create SERDES platform device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_wiz_init;\n\t}\n\twiz->serdes_pdev = serdes_pdev;\n\n\tof_node_put(child_node);\n\treturn 0;\n\nerr_wiz_init:\n\twiz_clock_cleanup(wiz, node);\n\nerr_get_sync:\n\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n\nerr_addr_to_resource:\n\tof_node_put(child_node);\n\n\treturn ret;\n}\n\nstatic void wiz_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct platform_device *serdes_pdev;\n\tstruct wiz *wiz;\n\n\twiz = dev_get_drvdata(dev);\n\tserdes_pdev = wiz->serdes_pdev;\n\n\tof_platform_device_destroy(&serdes_pdev->dev, NULL);\n\twiz_clock_cleanup(wiz, node);\n\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n}\n\nstatic struct platform_driver wiz_driver = {\n\t.probe\t\t= wiz_probe,\n\t.remove_new\t= wiz_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"wiz\",\n\t\t.of_match_table = wiz_id_table,\n\t},\n};\nmodule_platform_driver(wiz_driver);\n\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\nMODULE_DESCRIPTION(\"TI J721E WIZ driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}