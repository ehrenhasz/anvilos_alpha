{
  "module_name": "phy-dm816x-usb.c",
  "hash_id": "a0944c7a1976e0a446d214af2bbd25e9986994dcc6f808cbd715bd1fe25269b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/ti/phy-dm816x-usb.c",
  "human_readable_source": "\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/usb/phy_companion.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/pm_runtime.h>\n#include <linux/delay.h>\n#include <linux/phy/phy.h>\n#include <linux/of_platform.h>\n\n#include <linux/mfd/syscon.h>\n\n \n#define DM816X_USB_CTRL_PHYCLKSRC\tBIT(8)\t \n#define DM816X_USB_CTRL_PHYSLEEP1\tBIT(1)\t \n#define DM816X_USB_CTRL_PHYSLEEP0\tBIT(0)\t \n\n#define DM816X_USBPHY_CTRL_TXRISETUNE\t1\n#define DM816X_USBPHY_CTRL_TXVREFTUNE\t0xc\n#define DM816X_USBPHY_CTRL_TXPREEMTUNE\t0x2\n\nstruct dm816x_usb_phy {\n\tstruct regmap *syscon;\n\tstruct device *dev;\n\tunsigned int instance;\n\tstruct clk *refclk;\n\tstruct usb_phy phy;\n\tunsigned int usb_ctrl;\t\t \n\tunsigned int usbphy_ctrl;\n};\n\nstatic int dm816x_usb_phy_set_host(struct usb_otg *otg, struct usb_bus *host)\n{\n\totg->host = host;\n\tif (!host)\n\t\totg->state = OTG_STATE_UNDEFINED;\n\n\treturn 0;\n}\n\nstatic int dm816x_usb_phy_set_peripheral(struct usb_otg *otg,\n\t\t\t\t\t struct usb_gadget *gadget)\n{\n\totg->gadget = gadget;\n\tif (!gadget)\n\t\totg->state = OTG_STATE_UNDEFINED;\n\n\treturn 0;\n}\n\nstatic int dm816x_usb_phy_init(struct phy *x)\n{\n\tstruct dm816x_usb_phy *phy = phy_get_drvdata(x);\n\tunsigned int val;\n\n\tif (clk_get_rate(phy->refclk) != 24000000)\n\t\tdev_warn(phy->dev, \"nonstandard phy refclk\\n\");\n\n\t \n\tregmap_update_bits(phy->syscon, phy->usb_ctrl,\n\t\t\t   DM816X_USB_CTRL_PHYCLKSRC |\n\t\t\t   DM816X_USB_CTRL_PHYSLEEP1 |\n\t\t\t   DM816X_USB_CTRL_PHYSLEEP0,\n\t\t\t   0);\n\tregmap_read(phy->syscon, phy->usb_ctrl, &val);\n\tif ((val & 3) != 0)\n\t\tdev_info(phy->dev,\n\t\t\t \"Working dm816x USB_CTRL! (0x%08x)\\n\",\n\t\t\t val);\n\n\t \n\tregmap_read(phy->syscon, phy->usbphy_ctrl, &val);\n\tval |= DM816X_USBPHY_CTRL_TXRISETUNE |\n\t\tDM816X_USBPHY_CTRL_TXVREFTUNE |\n\t\tDM816X_USBPHY_CTRL_TXPREEMTUNE;\n\tregmap_write(phy->syscon, phy->usbphy_ctrl, val);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops ops = {\n\t.init\t\t= dm816x_usb_phy_init,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __maybe_unused dm816x_usb_phy_runtime_suspend(struct device *dev)\n{\n\tstruct dm816x_usb_phy *phy = dev_get_drvdata(dev);\n\tunsigned int mask, val;\n\tint error = 0;\n\n\tmask = BIT(phy->instance);\n\tval = ~BIT(phy->instance);\n\terror = regmap_update_bits(phy->syscon, phy->usb_ctrl,\n\t\t\t\t   mask, val);\n\tif (error)\n\t\tdev_err(phy->dev, \"phy%i failed to power off\\n\",\n\t\t\tphy->instance);\n\tclk_disable(phy->refclk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dm816x_usb_phy_runtime_resume(struct device *dev)\n{\n\tstruct dm816x_usb_phy *phy = dev_get_drvdata(dev);\n\tunsigned int mask, val;\n\tint error;\n\n\terror = clk_enable(phy->refclk);\n\tif (error)\n\t\treturn error;\n\n\t \n\tmask = BIT(phy->instance);\n\tval = BIT(phy->instance);\n\terror = regmap_update_bits(phy->syscon, phy->usb_ctrl,\n\t\t\t\t   mask, val);\n\tif (error) {\n\t\tdev_err(phy->dev, \"phy%i failed to power on\\n\",\n\t\t\tphy->instance);\n\t\tclk_disable(phy->refclk);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic UNIVERSAL_DEV_PM_OPS(dm816x_usb_phy_pm_ops,\n\t\t\t    dm816x_usb_phy_runtime_suspend,\n\t\t\t    dm816x_usb_phy_runtime_resume,\n\t\t\t    NULL);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id dm816x_usb_phy_id_table[] = {\n\t{\n\t\t.compatible = \"ti,dm8168-usb-phy\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dm816x_usb_phy_id_table);\n#endif\n\nstatic int dm816x_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct dm816x_usb_phy *phy;\n\tstruct resource *res;\n\tstruct phy *generic_phy;\n\tstruct phy_provider *phy_provider;\n\tstruct usb_otg *otg;\n\tconst struct of_device_id *of_id;\n\tint error;\n\n\tof_id = of_match_device(of_match_ptr(dm816x_usb_phy_id_table),\n\t\t\t\t&pdev->dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tphy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENOENT;\n\n\tphy->syscon = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t      \"syscon\");\n\tif (IS_ERR(phy->syscon))\n\t\treturn PTR_ERR(phy->syscon);\n\n\t \n\tphy->usb_ctrl = 0x20;\n\tphy->usbphy_ctrl = (res->start & 0xff) + 4;\n\tif (phy->usbphy_ctrl == 0x2c)\n\t\tphy->instance = 1;\n\n\totg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);\n\tif (!otg)\n\t\treturn -ENOMEM;\n\n\tphy->dev = &pdev->dev;\n\tphy->phy.dev = phy->dev;\n\tphy->phy.label = \"dm8168_usb_phy\";\n\tphy->phy.otg = otg;\n\tphy->phy.type = USB_PHY_TYPE_USB2;\n\totg->set_host = dm816x_usb_phy_set_host;\n\totg->set_peripheral = dm816x_usb_phy_set_peripheral;\n\totg->usb_phy = &phy->phy;\n\n\tplatform_set_drvdata(pdev, phy);\n\n\tphy->refclk = devm_clk_get(phy->dev, \"refclk\");\n\tif (IS_ERR(phy->refclk))\n\t\treturn PTR_ERR(phy->refclk);\n\terror = clk_prepare(phy->refclk);\n\tif (error)\n\t\treturn error;\n\n\tpm_runtime_enable(phy->dev);\n\tgeneric_phy = devm_phy_create(phy->dev, NULL, &ops);\n\tif (IS_ERR(generic_phy)) {\n\t\terror = PTR_ERR(generic_phy);\n\t\tgoto clk_unprepare;\n\t}\n\n\tphy_set_drvdata(generic_phy, phy);\n\n\tphy_provider = devm_of_phy_provider_register(phy->dev,\n\t\t\t\t\t\t     of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\terror = PTR_ERR(phy_provider);\n\t\tgoto clk_unprepare;\n\t}\n\n\tusb_add_phy_dev(&phy->phy);\n\n\treturn 0;\n\nclk_unprepare:\n\tpm_runtime_disable(phy->dev);\n\tclk_unprepare(phy->refclk);\n\treturn error;\n}\n\nstatic void dm816x_usb_phy_remove(struct platform_device *pdev)\n{\n\tstruct dm816x_usb_phy *phy = platform_get_drvdata(pdev);\n\n\tusb_remove_phy(&phy->phy);\n\tpm_runtime_disable(phy->dev);\n\tclk_unprepare(phy->refclk);\n}\n\nstatic struct platform_driver dm816x_usb_phy_driver = {\n\t.probe\t\t= dm816x_usb_phy_probe,\n\t.remove_new\t= dm816x_usb_phy_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"dm816x-usb-phy\",\n\t\t.pm\t= &dm816x_usb_phy_pm_ops,\n\t\t.of_match_table = of_match_ptr(dm816x_usb_phy_id_table),\n\t},\n};\n\nmodule_platform_driver(dm816x_usb_phy_driver);\n\nMODULE_ALIAS(\"platform:dm816x_usb\");\nMODULE_AUTHOR(\"Tony Lindgren <tony@atomide.com>\");\nMODULE_DESCRIPTION(\"dm816x usb phy driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}