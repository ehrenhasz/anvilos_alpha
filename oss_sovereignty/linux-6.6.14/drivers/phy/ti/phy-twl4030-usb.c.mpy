{
  "module_name": "phy-twl4030-usb.c",
  "hash_id": "ee13b11342f24b5f8a4ae3951623c28f18eea386415219b299e82337b3253dca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/ti/phy-twl4030-usb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/usb/otg.h>\n#include <linux/phy/phy.h>\n#include <linux/pm_runtime.h>\n#include <linux/usb/musb.h>\n#include <linux/usb/ulpi.h>\n#include <linux/mfd/twl.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n\n \n\n#define MCPC_CTRL\t\t\t0x30\n#define MCPC_CTRL_RTSOL\t\t\t(1 << 7)\n#define MCPC_CTRL_EXTSWR\t\t(1 << 6)\n#define MCPC_CTRL_EXTSWC\t\t(1 << 5)\n#define MCPC_CTRL_VOICESW\t\t(1 << 4)\n#define MCPC_CTRL_OUT64K\t\t(1 << 3)\n#define MCPC_CTRL_RTSCTSSW\t\t(1 << 2)\n#define MCPC_CTRL_HS_UART\t\t(1 << 0)\n\n#define MCPC_IO_CTRL\t\t\t0x33\n#define MCPC_IO_CTRL_MICBIASEN\t\t(1 << 5)\n#define MCPC_IO_CTRL_CTS_NPU\t\t(1 << 4)\n#define MCPC_IO_CTRL_RXD_PU\t\t(1 << 3)\n#define MCPC_IO_CTRL_TXDTYP\t\t(1 << 2)\n#define MCPC_IO_CTRL_CTSTYP\t\t(1 << 1)\n#define MCPC_IO_CTRL_RTSTYP\t\t(1 << 0)\n\n#define MCPC_CTRL2\t\t\t0x36\n#define MCPC_CTRL2_MCPC_CK_EN\t\t(1 << 0)\n\n#define OTHER_FUNC_CTRL\t\t\t0x80\n#define OTHER_FUNC_CTRL_BDIS_ACON_EN\t(1 << 4)\n#define OTHER_FUNC_CTRL_FIVEWIRE_MODE\t(1 << 2)\n\n#define OTHER_IFC_CTRL\t\t\t0x83\n#define OTHER_IFC_CTRL_OE_INT_EN\t(1 << 6)\n#define OTHER_IFC_CTRL_CEA2011_MODE\t(1 << 5)\n#define OTHER_IFC_CTRL_FSLSSERIALMODE_4PIN\t(1 << 4)\n#define OTHER_IFC_CTRL_HIZ_ULPI_60MHZ_OUT\t(1 << 3)\n#define OTHER_IFC_CTRL_HIZ_ULPI\t\t(1 << 2)\n#define OTHER_IFC_CTRL_ALT_INT_REROUTE\t(1 << 0)\n\n#define OTHER_INT_EN_RISE\t\t0x86\n#define OTHER_INT_EN_FALL\t\t0x89\n#define OTHER_INT_STS\t\t\t0x8C\n#define OTHER_INT_LATCH\t\t\t0x8D\n#define OTHER_INT_VB_SESS_VLD\t\t(1 << 7)\n#define OTHER_INT_DM_HI\t\t\t(1 << 6)  \n#define OTHER_INT_DP_HI\t\t\t(1 << 5)  \n#define OTHER_INT_BDIS_ACON\t\t(1 << 3)  \n#define OTHER_INT_MANU\t\t\t(1 << 1)\n#define OTHER_INT_ABNORMAL_STRESS\t(1 << 0)\n\n#define ID_STATUS\t\t\t0x96\n#define ID_RES_FLOAT\t\t\t(1 << 4)\n#define ID_RES_440K\t\t\t(1 << 3)\n#define ID_RES_200K\t\t\t(1 << 2)\n#define ID_RES_102K\t\t\t(1 << 1)\n#define ID_RES_GND\t\t\t(1 << 0)\n\n#define POWER_CTRL\t\t\t0xAC\n#define POWER_CTRL_OTG_ENAB\t\t(1 << 5)\n\n#define OTHER_IFC_CTRL2\t\t\t0xAF\n#define OTHER_IFC_CTRL2_ULPI_STP_LOW\t(1 << 4)\n#define OTHER_IFC_CTRL2_ULPI_TXEN_POL\t(1 << 3)\n#define OTHER_IFC_CTRL2_ULPI_4PIN_2430\t(1 << 2)\n#define OTHER_IFC_CTRL2_USB_INT_OUTSEL_MASK\t(3 << 0)  \n#define OTHER_IFC_CTRL2_USB_INT_OUTSEL_INT1N\t(0 << 0)\n#define OTHER_IFC_CTRL2_USB_INT_OUTSEL_INT2N\t(1 << 0)\n\n#define REG_CTRL_EN\t\t\t0xB2\n#define REG_CTRL_ERROR\t\t\t0xB5\n#define ULPI_I2C_CONFLICT_INTEN\t\t(1 << 0)\n\n#define OTHER_FUNC_CTRL2\t\t0xB8\n#define OTHER_FUNC_CTRL2_VBAT_TIMER_EN\t(1 << 0)\n\n \n#define VBUS_DEBOUNCE\t\t\t0xC0\n#define ID_DEBOUNCE\t\t\t0xC1\n#define VBAT_TIMER\t\t\t0xD3\n#define PHY_PWR_CTRL\t\t\t0xFD\n#define PHY_PWR_PHYPWD\t\t\t(1 << 0)\n#define PHY_CLK_CTRL\t\t\t0xFE\n#define PHY_CLK_CTRL_CLOCKGATING_EN\t(1 << 2)\n#define PHY_CLK_CTRL_CLK32K_EN\t\t(1 << 1)\n#define REQ_PHY_DPLL_CLK\t\t(1 << 0)\n#define PHY_CLK_CTRL_STS\t\t0xFF\n#define PHY_DPLL_CLK\t\t\t(1 << 0)\n\n \n#define STS_HW_CONDITIONS\t\t0x0F\n\n \n#define VUSB_DEDICATED1\t\t\t0x7D\n#define VUSB_DEDICATED2\t\t\t0x7E\n#define VUSB1V5_DEV_GRP\t\t\t0x71\n#define VUSB1V5_TYPE\t\t\t0x72\n#define VUSB1V5_REMAP\t\t\t0x73\n#define VUSB1V8_DEV_GRP\t\t\t0x74\n#define VUSB1V8_TYPE\t\t\t0x75\n#define VUSB1V8_REMAP\t\t\t0x76\n#define VUSB3V1_DEV_GRP\t\t\t0x77\n#define VUSB3V1_TYPE\t\t\t0x78\n#define VUSB3V1_REMAP\t\t\t0x79\n\n \n#define PMBR1\t\t\t\t0x0D\n#define GPIO_USB_4PIN_ULPI_2430C\t(3 << 0)\n\nstatic irqreturn_t twl4030_usb_irq(int irq, void *_twl);\n \nstatic inline bool cable_present(enum musb_vbus_id_status stat)\n{\n\treturn stat == MUSB_VBUS_VALID ||\n\t\tstat == MUSB_ID_GROUND;\n}\n\nstruct twl4030_usb {\n\tstruct usb_phy\t\tphy;\n\tstruct device\t\t*dev;\n\n\t \n\tstruct regulator\t*usb1v5;\n\tstruct regulator\t*usb1v8;\n\tstruct regulator\t*usb3v1;\n\n\t \n\tstruct mutex\t\tlock;\n\n\t \n\tenum twl4030_usb_mode\tusb_mode;\n\n\tint\t\t\tirq;\n\tenum musb_vbus_id_status linkstat;\n\tatomic_t\t\tconnected;\n\tbool\t\t\tvbus_supplied;\n\tbool\t\t\tmusb_mailbox_pending;\n\tunsigned long\t\truntime_suspended:1;\n\tunsigned long\t\tneeds_resume:1;\n\n\tstruct delayed_work\tid_workaround_work;\n};\n\n \n#define phy_to_twl(x)\t\tcontainer_of((x), struct twl4030_usb, phy)\n\n \n\nstatic int twl4030_i2c_write_u8_verify(struct twl4030_usb *twl,\n\t\tu8 module, u8 data, u8 address)\n{\n\tu8 check = 0xFF;\n\n\tif ((twl_i2c_write_u8(module, data, address) >= 0) &&\n\t    (twl_i2c_read_u8(module, &check, address) >= 0) &&\n\t\t\t\t\t\t(check == data))\n\t\treturn 0;\n\tdev_dbg(twl->dev, \"Write%d[%d,0x%x] wrote %02x but read %02x\\n\",\n\t\t\t1, module, address, check, data);\n\n\t \n\tif ((twl_i2c_write_u8(module, data, address) >= 0) &&\n\t    (twl_i2c_read_u8(module, &check, address) >= 0) &&\n\t\t\t\t\t\t(check == data))\n\t\treturn 0;\n\tdev_dbg(twl->dev, \"Write%d[%d,0x%x] wrote %02x but read %02x\\n\",\n\t\t\t2, module, address, check, data);\n\n\t \n\treturn -EBUSY;\n}\n\n#define twl4030_usb_write_verify(twl, address, data)\t\\\n\ttwl4030_i2c_write_u8_verify(twl, TWL_MODULE_USB, (data), (address))\n\nstatic inline int twl4030_usb_write(struct twl4030_usb *twl,\n\t\tu8 address, u8 data)\n{\n\tint ret = 0;\n\n\tret = twl_i2c_write_u8(TWL_MODULE_USB, data, address);\n\tif (ret < 0)\n\t\tdev_dbg(twl->dev,\n\t\t\t\"TWL4030:USB:Write[0x%x] Error %d\\n\", address, ret);\n\treturn ret;\n}\n\nstatic inline int twl4030_readb(struct twl4030_usb *twl, u8 module, u8 address)\n{\n\tu8 data;\n\tint ret = 0;\n\n\tret = twl_i2c_read_u8(module, &data, address);\n\tif (ret >= 0)\n\t\tret = data;\n\telse\n\t\tdev_dbg(twl->dev,\n\t\t\t\"TWL4030:readb[0x%x,0x%x] Error %d\\n\",\n\t\t\t\t\tmodule, address, ret);\n\n\treturn ret;\n}\n\nstatic inline int twl4030_usb_read(struct twl4030_usb *twl, u8 address)\n{\n\treturn twl4030_readb(twl, TWL_MODULE_USB, address);\n}\n\n \n\nstatic inline int\ntwl4030_usb_set_bits(struct twl4030_usb *twl, u8 reg, u8 bits)\n{\n\treturn twl4030_usb_write(twl, ULPI_SET(reg), bits);\n}\n\nstatic inline int\ntwl4030_usb_clear_bits(struct twl4030_usb *twl, u8 reg, u8 bits)\n{\n\treturn twl4030_usb_write(twl, ULPI_CLR(reg), bits);\n}\n\n \n\nstatic bool twl4030_is_driving_vbus(struct twl4030_usb *twl)\n{\n\tint ret;\n\n\tret = twl4030_usb_read(twl, PHY_CLK_CTRL_STS);\n\tif (ret < 0 || !(ret & PHY_DPLL_CLK))\n\t\t \n\t\treturn false;\n\n\tret = twl4030_usb_read(twl, ULPI_OTG_CTRL);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn (ret & (ULPI_OTG_DRVVBUS | ULPI_OTG_CHRGVBUS)) ? true : false;\n}\n\nstatic enum musb_vbus_id_status\n\ttwl4030_usb_linkstat(struct twl4030_usb *twl)\n{\n\tint\tstatus;\n\tenum musb_vbus_id_status linkstat = MUSB_UNKNOWN;\n\n\ttwl->vbus_supplied = false;\n\n\t \n\tstatus = twl4030_readb(twl, TWL_MODULE_PM_MASTER, STS_HW_CONDITIONS);\n\tif (status < 0)\n\t\tdev_err(twl->dev, \"USB link status err %d\\n\", status);\n\telse if (status & (BIT(7) | BIT(2))) {\n\t\tif (status & BIT(7)) {\n\t\t\tif (twl4030_is_driving_vbus(twl))\n\t\t\t\tstatus &= ~BIT(7);\n\t\t\telse\n\t\t\t\ttwl->vbus_supplied = true;\n\t\t}\n\n\t\tif (status & BIT(2))\n\t\t\tlinkstat = MUSB_ID_GROUND;\n\t\telse if (status & BIT(7))\n\t\t\tlinkstat = MUSB_VBUS_VALID;\n\t\telse\n\t\t\tlinkstat = MUSB_VBUS_OFF;\n\t} else {\n\t\tif (twl->linkstat != MUSB_UNKNOWN)\n\t\t\tlinkstat = MUSB_VBUS_OFF;\n\t}\n\n\tkobject_uevent(&twl->dev->kobj, linkstat == MUSB_VBUS_VALID\n\t\t\t\t\t? KOBJ_ONLINE : KOBJ_OFFLINE);\n\n\tdev_dbg(twl->dev, \"HW_CONDITIONS 0x%02x/%d; link %d\\n\",\n\t\t\tstatus, status, linkstat);\n\n\t \n\n\treturn linkstat;\n}\n\nstatic void twl4030_usb_set_mode(struct twl4030_usb *twl, int mode)\n{\n\ttwl->usb_mode = mode;\n\n\tswitch (mode) {\n\tcase T2_USB_MODE_ULPI:\n\t\ttwl4030_usb_clear_bits(twl, ULPI_IFC_CTRL,\n\t\t\t\t\tULPI_IFC_CTRL_CARKITMODE);\n\t\ttwl4030_usb_set_bits(twl, POWER_CTRL, POWER_CTRL_OTG_ENAB);\n\t\ttwl4030_usb_clear_bits(twl, ULPI_FUNC_CTRL,\n\t\t\t\t\tULPI_FUNC_CTRL_XCVRSEL_MASK |\n\t\t\t\t\tULPI_FUNC_CTRL_OPMODE_MASK);\n\t\tbreak;\n\tcase -1:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(twl->dev, \"unsupported T2 transceiver mode %d\\n\",\n\t\t\t\tmode);\n\t\tbreak;\n\t}\n}\n\nstatic void twl4030_i2c_access(struct twl4030_usb *twl, int on)\n{\n\tunsigned long timeout;\n\tint val = twl4030_usb_read(twl, PHY_CLK_CTRL);\n\n\tif (val >= 0) {\n\t\tif (on) {\n\t\t\t \n\t\t\tval |= REQ_PHY_DPLL_CLK;\n\t\t\tWARN_ON(twl4030_usb_write_verify(twl, PHY_CLK_CTRL,\n\t\t\t\t\t\t(u8)val) < 0);\n\n\t\t\ttimeout = jiffies + HZ;\n\t\t\twhile (!(twl4030_usb_read(twl, PHY_CLK_CTRL_STS) &\n\t\t\t\t\t\t\tPHY_DPLL_CLK)\n\t\t\t\t&& time_before(jiffies, timeout))\n\t\t\t\t\tudelay(10);\n\t\t\tif (!(twl4030_usb_read(twl, PHY_CLK_CTRL_STS) &\n\t\t\t\t\t\t\tPHY_DPLL_CLK))\n\t\t\t\tdev_err(twl->dev, \"Timeout setting T2 HSUSB \"\n\t\t\t\t\t\t\"PHY DPLL clock\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tval &= ~REQ_PHY_DPLL_CLK;\n\t\t\tWARN_ON(twl4030_usb_write_verify(twl, PHY_CLK_CTRL,\n\t\t\t\t\t\t(u8)val) < 0);\n\t\t}\n\t}\n}\n\nstatic void __twl4030_phy_power(struct twl4030_usb *twl, int on)\n{\n\tu8 pwr = twl4030_usb_read(twl, PHY_PWR_CTRL);\n\n\tif (on)\n\t\tpwr &= ~PHY_PWR_PHYPWD;\n\telse\n\t\tpwr |= PHY_PWR_PHYPWD;\n\n\tWARN_ON(twl4030_usb_write_verify(twl, PHY_PWR_CTRL, pwr) < 0);\n}\n\nstatic int twl4030_usb_runtime_suspend(struct device *dev);\nstatic int twl4030_usb_runtime_resume(struct device *dev);\n\nstatic int __maybe_unused twl4030_usb_suspend(struct device *dev)\n{\n\tstruct twl4030_usb *twl = dev_get_drvdata(dev);\n\n\t \n\tdev_dbg(twl->dev, \"%s\\n\", __func__);\n\tdisable_irq(twl->irq);\n\tif (!twl->runtime_suspended && !atomic_read(&twl->connected)) {\n\t\ttwl4030_usb_runtime_suspend(dev);\n\t\ttwl->needs_resume = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused twl4030_usb_resume(struct device *dev)\n{\n\tstruct twl4030_usb *twl = dev_get_drvdata(dev);\n\n\tdev_dbg(twl->dev, \"%s\\n\", __func__);\n\tenable_irq(twl->irq);\n\tif (twl->needs_resume)\n\t\ttwl4030_usb_runtime_resume(dev);\n\t \n\ttwl4030_usb_irq(0, twl);\n\n\ttwl->runtime_suspended = 0;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused twl4030_usb_runtime_suspend(struct device *dev)\n{\n\tstruct twl4030_usb *twl = dev_get_drvdata(dev);\n\n\tdev_dbg(twl->dev, \"%s\\n\", __func__);\n\n\t__twl4030_phy_power(twl, 0);\n\tregulator_disable(twl->usb1v5);\n\tregulator_disable(twl->usb1v8);\n\tregulator_disable(twl->usb3v1);\n\n\ttwl->runtime_suspended = 1;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused twl4030_usb_runtime_resume(struct device *dev)\n{\n\tstruct twl4030_usb *twl = dev_get_drvdata(dev);\n\tint res;\n\n\tdev_dbg(twl->dev, \"%s\\n\", __func__);\n\n\tres = regulator_enable(twl->usb3v1);\n\tif (res)\n\t\tdev_err(twl->dev, \"Failed to enable usb3v1\\n\");\n\n\tres = regulator_enable(twl->usb1v8);\n\tif (res)\n\t\tdev_err(twl->dev, \"Failed to enable usb1v8\\n\");\n\n\t \n\ttwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB_DEDICATED2);\n\n\tres = regulator_enable(twl->usb1v5);\n\tif (res)\n\t\tdev_err(twl->dev, \"Failed to enable usb1v5\\n\");\n\n\t__twl4030_phy_power(twl, 1);\n\ttwl4030_usb_write(twl, PHY_CLK_CTRL,\n\t\t\t  twl4030_usb_read(twl, PHY_CLK_CTRL) |\n\t\t\t  (PHY_CLK_CTRL_CLOCKGATING_EN |\n\t\t\t   PHY_CLK_CTRL_CLK32K_EN));\n\n\ttwl4030_i2c_access(twl, 1);\n\ttwl4030_usb_set_mode(twl, twl->usb_mode);\n\tif (twl->usb_mode == T2_USB_MODE_ULPI)\n\t\ttwl4030_i2c_access(twl, 0);\n\t \n\tmsleep(50);\n\treturn 0;\n}\n\nstatic int twl4030_phy_power_off(struct phy *phy)\n{\n\tstruct twl4030_usb *twl = phy_get_drvdata(phy);\n\n\tdev_dbg(twl->dev, \"%s\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic int twl4030_phy_power_on(struct phy *phy)\n{\n\tstruct twl4030_usb *twl = phy_get_drvdata(phy);\n\n\tdev_dbg(twl->dev, \"%s\\n\", __func__);\n\tpm_runtime_get_sync(twl->dev);\n\tschedule_delayed_work(&twl->id_workaround_work, HZ);\n\tpm_runtime_mark_last_busy(twl->dev);\n\tpm_runtime_put_autosuspend(twl->dev);\n\n\treturn 0;\n}\n\nstatic int twl4030_usb_ldo_init(struct twl4030_usb *twl)\n{\n\t \n\ttwl_i2c_write_u8(TWL_MODULE_PM_MASTER, TWL4030_PM_MASTER_KEY_CFG1,\n\t\t\t TWL4030_PM_MASTER_PROTECT_KEY);\n\n\ttwl_i2c_write_u8(TWL_MODULE_PM_MASTER, TWL4030_PM_MASTER_KEY_CFG2,\n\t\t\t TWL4030_PM_MASTER_PROTECT_KEY);\n\n\t \n\t \n\n\t \n\ttwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0x14, VUSB_DEDICATED1);\n\n\t \n\ttwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB3V1_DEV_GRP);\n\n\ttwl->usb3v1 = devm_regulator_get(twl->dev, \"usb3v1\");\n\tif (IS_ERR(twl->usb3v1))\n\t\treturn -ENODEV;\n\n\ttwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB3V1_TYPE);\n\n\t \n\ttwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB1V5_DEV_GRP);\n\n\ttwl->usb1v5 = devm_regulator_get(twl->dev, \"usb1v5\");\n\tif (IS_ERR(twl->usb1v5))\n\t\treturn -ENODEV;\n\n\ttwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB1V5_TYPE);\n\n\t \n\ttwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB1V8_DEV_GRP);\n\n\ttwl->usb1v8 = devm_regulator_get(twl->dev, \"usb1v8\");\n\tif (IS_ERR(twl->usb1v8))\n\t\treturn -ENODEV;\n\n\ttwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, 0, VUSB1V8_TYPE);\n\n\t \n\ttwl_i2c_write_u8(TWL_MODULE_PM_MASTER, 0,\n\t\t\t TWL4030_PM_MASTER_PROTECT_KEY);\n\n\treturn 0;\n}\n\nstatic ssize_t vbus_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct twl4030_usb *twl = dev_get_drvdata(dev);\n\tint ret = -EINVAL;\n\n\tmutex_lock(&twl->lock);\n\tret = sprintf(buf, \"%s\\n\",\n\t\t\ttwl->vbus_supplied ? \"on\" : \"off\");\n\tmutex_unlock(&twl->lock);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(vbus);\n\nstatic irqreturn_t twl4030_usb_irq(int irq, void *_twl)\n{\n\tstruct twl4030_usb *twl = _twl;\n\tenum musb_vbus_id_status status;\n\tint err;\n\n\tstatus = twl4030_usb_linkstat(twl);\n\n\tmutex_lock(&twl->lock);\n\ttwl->linkstat = status;\n\tmutex_unlock(&twl->lock);\n\n\tif (cable_present(status)) {\n\t\tif (atomic_add_unless(&twl->connected, 1, 1)) {\n\t\t\tdev_dbg(twl->dev, \"%s: cable connected %i\\n\",\n\t\t\t\t__func__, status);\n\t\t\tpm_runtime_get_sync(twl->dev);\n\t\t\ttwl->musb_mailbox_pending = true;\n\t\t}\n\t} else {\n\t\tif (atomic_add_unless(&twl->connected, -1, 0)) {\n\t\t\tdev_dbg(twl->dev, \"%s: cable disconnected %i\\n\",\n\t\t\t\t__func__, status);\n\t\t\tpm_runtime_mark_last_busy(twl->dev);\n\t\t\tpm_runtime_put_autosuspend(twl->dev);\n\t\t\ttwl->musb_mailbox_pending = true;\n\t\t}\n\t}\n\tif (twl->musb_mailbox_pending) {\n\t\terr = musb_mailbox(status);\n\t\tif (!err)\n\t\t\ttwl->musb_mailbox_pending = false;\n\t}\n\n\t \n\tif (status == MUSB_ID_GROUND && pm_runtime_active(twl->dev)) {\n\t\tcancel_delayed_work(&twl->id_workaround_work);\n\t\tschedule_delayed_work(&twl->id_workaround_work, HZ);\n\t}\n\n\tif (irq)\n\t\tsysfs_notify(&twl->dev->kobj, NULL, \"vbus\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void twl4030_id_workaround_work(struct work_struct *work)\n{\n\tstruct twl4030_usb *twl = container_of(work, struct twl4030_usb,\n\t\tid_workaround_work.work);\n\n\ttwl4030_usb_irq(0, twl);\n}\n\nstatic int twl4030_phy_init(struct phy *phy)\n{\n\tstruct twl4030_usb *twl = phy_get_drvdata(phy);\n\n\tpm_runtime_get_sync(twl->dev);\n\ttwl->linkstat = MUSB_UNKNOWN;\n\tschedule_delayed_work(&twl->id_workaround_work, HZ);\n\tpm_runtime_mark_last_busy(twl->dev);\n\tpm_runtime_put_autosuspend(twl->dev);\n\n\treturn 0;\n}\n\nstatic int twl4030_set_peripheral(struct usb_otg *otg,\n\t\t\t\t\tstruct usb_gadget *gadget)\n{\n\tif (!otg)\n\t\treturn -ENODEV;\n\n\totg->gadget = gadget;\n\tif (!gadget)\n\t\totg->state = OTG_STATE_UNDEFINED;\n\n\treturn 0;\n}\n\nstatic int twl4030_set_host(struct usb_otg *otg, struct usb_bus *host)\n{\n\tif (!otg)\n\t\treturn -ENODEV;\n\n\totg->host = host;\n\tif (!host)\n\t\totg->state = OTG_STATE_UNDEFINED;\n\n\treturn 0;\n}\n\nstatic const struct phy_ops ops = {\n\t.init\t\t= twl4030_phy_init,\n\t.power_on\t= twl4030_phy_power_on,\n\t.power_off\t= twl4030_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct dev_pm_ops twl4030_usb_pm_ops = {\n\tSET_RUNTIME_PM_OPS(twl4030_usb_runtime_suspend,\n\t\t\t   twl4030_usb_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(twl4030_usb_suspend, twl4030_usb_resume)\n};\n\nstatic int twl4030_usb_probe(struct platform_device *pdev)\n{\n\tstruct twl4030_usb_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct twl4030_usb\t*twl;\n\tstruct phy\t\t*phy;\n\tint\t\t\tstatus, err;\n\tstruct usb_otg\t\t*otg;\n\tstruct device_node\t*np = pdev->dev.of_node;\n\tstruct phy_provider\t*phy_provider;\n\n\ttwl = devm_kzalloc(&pdev->dev, sizeof(*twl), GFP_KERNEL);\n\tif (!twl)\n\t\treturn -ENOMEM;\n\n\tif (np)\n\t\tof_property_read_u32(np, \"usb_mode\",\n\t\t\t\t(enum twl4030_usb_mode *)&twl->usb_mode);\n\telse if (pdata) {\n\t\ttwl->usb_mode = pdata->usb_mode;\n\t} else {\n\t\tdev_err(&pdev->dev, \"twl4030 initialized without pdata\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\totg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);\n\tif (!otg)\n\t\treturn -ENOMEM;\n\n\ttwl->dev\t\t= &pdev->dev;\n\ttwl->irq\t\t= platform_get_irq(pdev, 0);\n\ttwl->vbus_supplied\t= false;\n\ttwl->linkstat\t\t= MUSB_UNKNOWN;\n\ttwl->musb_mailbox_pending = false;\n\n\ttwl->phy.dev\t\t= twl->dev;\n\ttwl->phy.label\t\t= \"twl4030\";\n\ttwl->phy.otg\t\t= otg;\n\ttwl->phy.type\t\t= USB_PHY_TYPE_USB2;\n\n\totg->usb_phy\t\t= &twl->phy;\n\totg->set_host\t\t= twl4030_set_host;\n\totg->set_peripheral\t= twl4030_set_peripheral;\n\n\tphy = devm_phy_create(twl->dev, NULL, &ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_dbg(&pdev->dev, \"Failed to create PHY\\n\");\n\t\treturn PTR_ERR(phy);\n\t}\n\n\tphy_set_drvdata(phy, twl);\n\n\tphy_provider = devm_of_phy_provider_register(twl->dev,\n\t\tof_phy_simple_xlate);\n\tif (IS_ERR(phy_provider))\n\t\treturn PTR_ERR(phy_provider);\n\n\t \n\tmutex_init(&twl->lock);\n\n\tINIT_DELAYED_WORK(&twl->id_workaround_work, twl4030_id_workaround_work);\n\n\terr = twl4030_usb_ldo_init(twl);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"ldo init failed\\n\");\n\t\treturn err;\n\t}\n\tusb_add_phy_dev(&twl->phy);\n\n\tplatform_set_drvdata(pdev, twl);\n\tif (device_create_file(&pdev->dev, &dev_attr_vbus))\n\t\tdev_warn(&pdev->dev, \"could not create sysfs file\\n\");\n\n\tATOMIC_INIT_NOTIFIER_HEAD(&twl->phy.notifier);\n\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 2000);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\t \n\tstatus = devm_request_threaded_irq(twl->dev, twl->irq, NULL,\n\t\t\ttwl4030_usb_irq, IRQF_TRIGGER_FALLING |\n\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT, \"twl4030_usb\", twl);\n\tif (status < 0) {\n\t\tdev_dbg(&pdev->dev, \"can't get IRQ %d, err %d\\n\",\n\t\t\ttwl->irq, status);\n\t\treturn status;\n\t}\n\n\tif (pdata)\n\t\terr = phy_create_lookup(phy, \"usb\", \"musb-hdrc.0\");\n\tif (err)\n\t\treturn err;\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(twl->dev);\n\n\tdev_info(&pdev->dev, \"Initialized TWL4030 USB module\\n\");\n\treturn 0;\n}\n\nstatic void twl4030_usb_remove(struct platform_device *pdev)\n{\n\tstruct twl4030_usb *twl = platform_get_drvdata(pdev);\n\tint val;\n\n\tusb_remove_phy(&twl->phy);\n\tpm_runtime_get_sync(twl->dev);\n\tcancel_delayed_work_sync(&twl->id_workaround_work);\n\tdevice_remove_file(twl->dev, &dev_attr_vbus);\n\n\t \n\ttwl4030_usb_set_mode(twl, -1);\n\n\t \n\tif (cable_present(twl->linkstat))\n\t\tpm_runtime_put_noidle(twl->dev);\n\tpm_runtime_mark_last_busy(twl->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_put_sync(twl->dev);\n\tpm_runtime_disable(twl->dev);\n\n\t \n\tval = twl4030_usb_read(twl, PHY_CLK_CTRL);\n\tif (val >= 0) {\n\t\tval |= PHY_CLK_CTRL_CLOCKGATING_EN;\n\t\tval &= ~(PHY_CLK_CTRL_CLK32K_EN | REQ_PHY_DPLL_CLK);\n\t\ttwl4030_usb_write(twl, PHY_CLK_CTRL, (u8)val);\n\t}\n\n\t \n\ttwl4030_usb_clear_bits(twl, POWER_CTRL, POWER_CTRL_OTG_ENAB);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id twl4030_usb_id_table[] = {\n\t{ .compatible = \"ti,twl4030-usb\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, twl4030_usb_id_table);\n#endif\n\nstatic struct platform_driver twl4030_usb_driver = {\n\t.probe\t\t= twl4030_usb_probe,\n\t.remove_new\t= twl4030_usb_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"twl4030_usb\",\n\t\t.pm\t= &twl4030_usb_pm_ops,\n\t\t.of_match_table = of_match_ptr(twl4030_usb_id_table),\n\t},\n};\n\nstatic int __init twl4030_usb_init(void)\n{\n\treturn platform_driver_register(&twl4030_usb_driver);\n}\nsubsys_initcall(twl4030_usb_init);\n\nstatic void __exit twl4030_usb_exit(void)\n{\n\tplatform_driver_unregister(&twl4030_usb_driver);\n}\nmodule_exit(twl4030_usb_exit);\n\nMODULE_ALIAS(\"platform:twl4030_usb\");\nMODULE_AUTHOR(\"Texas Instruments, Inc, Nokia Corporation\");\nMODULE_DESCRIPTION(\"TWL4030 USB transceiver driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}