{
  "module_name": "phy-ti-pipe3.c",
  "hash_id": "3e3b17b77de014e8596d3c4ade50937bf1147a933d21ebd96ba7dc22778c1786",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/ti/phy-ti-pipe3.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/phy/phy.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/pm_runtime.h>\n#include <linux/delay.h>\n#include <linux/phy/omap_control_phy.h>\n#include <linux/of_platform.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#define\tPLL_STATUS\t\t0x00000004\n#define\tPLL_GO\t\t\t0x00000008\n#define\tPLL_CONFIGURATION1\t0x0000000C\n#define\tPLL_CONFIGURATION2\t0x00000010\n#define\tPLL_CONFIGURATION3\t0x00000014\n#define\tPLL_CONFIGURATION4\t0x00000020\n\n#define\tPLL_REGM_MASK\t\t0x001FFE00\n#define\tPLL_REGM_SHIFT\t\t0x9\n#define\tPLL_REGM_F_MASK\t\t0x0003FFFF\n#define\tPLL_REGM_F_SHIFT\t0x0\n#define\tPLL_REGN_MASK\t\t0x000001FE\n#define\tPLL_REGN_SHIFT\t\t0x1\n#define\tPLL_SELFREQDCO_MASK\t0x0000000E\n#define\tPLL_SELFREQDCO_SHIFT\t0x1\n#define\tPLL_SD_MASK\t\t0x0003FC00\n#define\tPLL_SD_SHIFT\t\t10\n#define\tSET_PLL_GO\t\t0x1\n#define PLL_LDOPWDN\t\tBIT(15)\n#define PLL_TICOPWDN\t\tBIT(16)\n#define\tPLL_LOCK\t\t0x2\n#define\tPLL_IDLE\t\t0x1\n\n#define SATA_PLL_SOFT_RESET\tBIT(18)\n\n#define PIPE3_PHY_PWRCTL_CLK_CMD_MASK\tGENMASK(21, 14)\n#define PIPE3_PHY_PWRCTL_CLK_CMD_SHIFT\t14\n\n#define PIPE3_PHY_PWRCTL_CLK_FREQ_MASK\tGENMASK(31, 22)\n#define PIPE3_PHY_PWRCTL_CLK_FREQ_SHIFT\t22\n\n#define PIPE3_PHY_RX_POWERON       (0x1 << PIPE3_PHY_PWRCTL_CLK_CMD_SHIFT)\n#define PIPE3_PHY_TX_POWERON       (0x2 << PIPE3_PHY_PWRCTL_CLK_CMD_SHIFT)\n\n#define PCIE_PCS_MASK\t\t\t0xFF0000\n#define PCIE_PCS_DELAY_COUNT_SHIFT\t0x10\n\n#define PIPE3_PHY_RX_ANA_PROGRAMMABILITY\t0x0000000C\n#define INTERFACE_MASK\t\t\tGENMASK(31, 27)\n#define INTERFACE_SHIFT\t\t\t27\n#define INTERFACE_MODE_USBSS\t\tBIT(4)\n#define INTERFACE_MODE_SATA_1P5\t\tBIT(3)\n#define INTERFACE_MODE_SATA_3P0\t\tBIT(2)\n#define INTERFACE_MODE_PCIE\t\tBIT(0)\n\n#define LOSD_MASK\t\t\tGENMASK(17, 14)\n#define LOSD_SHIFT\t\t\t14\n#define MEM_PLLDIV\t\t\tGENMASK(6, 5)\n\n#define PIPE3_PHY_RX_TRIM\t\t0x0000001C\n#define MEM_DLL_TRIM_SEL_MASK\t\tGENMASK(31, 30)\n#define MEM_DLL_TRIM_SHIFT\t\t30\n\n#define PIPE3_PHY_RX_DLL\t\t0x00000024\n#define MEM_DLL_PHINT_RATE_MASK\t\tGENMASK(31, 30)\n#define MEM_DLL_PHINT_RATE_SHIFT\t30\n\n#define PIPE3_PHY_RX_DIGITAL_MODES\t\t0x00000028\n#define MEM_HS_RATE_MASK\t\tGENMASK(28, 27)\n#define MEM_HS_RATE_SHIFT\t\t27\n#define MEM_OVRD_HS_RATE\t\tBIT(26)\n#define MEM_OVRD_HS_RATE_SHIFT\t\t26\n#define MEM_CDR_FASTLOCK\t\tBIT(23)\n#define MEM_CDR_FASTLOCK_SHIFT\t\t23\n#define MEM_CDR_LBW_MASK\t\tGENMASK(22, 21)\n#define MEM_CDR_LBW_SHIFT\t\t21\n#define MEM_CDR_STEPCNT_MASK\t\tGENMASK(20, 19)\n#define MEM_CDR_STEPCNT_SHIFT\t\t19\n#define MEM_CDR_STL_MASK\t\tGENMASK(18, 16)\n#define MEM_CDR_STL_SHIFT\t\t16\n#define MEM_CDR_THR_MASK\t\tGENMASK(15, 13)\n#define MEM_CDR_THR_SHIFT\t\t13\n#define MEM_CDR_THR_MODE\t\tBIT(12)\n#define MEM_CDR_THR_MODE_SHIFT\t\t12\n#define MEM_CDR_2NDO_SDM_MODE\t\tBIT(11)\n#define MEM_CDR_2NDO_SDM_MODE_SHIFT\t11\n\n#define PIPE3_PHY_RX_EQUALIZER\t\t0x00000038\n#define MEM_EQLEV_MASK\t\t\tGENMASK(31, 16)\n#define MEM_EQLEV_SHIFT\t\t\t16\n#define MEM_EQFTC_MASK\t\t\tGENMASK(15, 11)\n#define MEM_EQFTC_SHIFT\t\t\t11\n#define MEM_EQCTL_MASK\t\t\tGENMASK(10, 7)\n#define MEM_EQCTL_SHIFT\t\t\t7\n#define MEM_OVRD_EQLEV\t\t\tBIT(2)\n#define MEM_OVRD_EQLEV_SHIFT\t\t2\n#define MEM_OVRD_EQFTC\t\t\tBIT(1)\n#define MEM_OVRD_EQFTC_SHIFT\t\t1\n\n#define SATA_PHY_RX_IO_AND_A2D_OVERRIDES\t0x44\n#define MEM_CDR_LOS_SOURCE_MASK\t\tGENMASK(10, 9)\n#define MEM_CDR_LOS_SOURCE_SHIFT\t9\n\n \n#define PLL_IDLE_TIME\t100\t \n#define PLL_LOCK_TIME\t100\t \n\nenum pipe3_mode { PIPE3_MODE_PCIE = 1,\n\t\t  PIPE3_MODE_SATA,\n\t\t  PIPE3_MODE_USBSS };\n\nstruct pipe3_dpll_params {\n\tu16\tm;\n\tu8\tn;\n\tu8\tfreq:3;\n\tu8\tsd;\n\tu32\tmf;\n};\n\nstruct pipe3_dpll_map {\n\tunsigned long rate;\n\tstruct pipe3_dpll_params params;\n};\n\nstruct pipe3_settings {\n\tu8 ana_interface;\n\tu8 ana_losd;\n\tu8 dig_fastlock;\n\tu8 dig_lbw;\n\tu8 dig_stepcnt;\n\tu8 dig_stl;\n\tu8 dig_thr;\n\tu8 dig_thr_mode;\n\tu8 dig_2ndo_sdm_mode;\n\tu8 dig_hs_rate;\n\tu8 dig_ovrd_hs_rate;\n\tu8 dll_trim_sel;\n\tu8 dll_phint_rate;\n\tu8 eq_lev;\n\tu8 eq_ftc;\n\tu8 eq_ctl;\n\tu8 eq_ovrd_lev;\n\tu8 eq_ovrd_ftc;\n};\n\nstruct ti_pipe3 {\n\tvoid __iomem\t\t*pll_ctrl_base;\n\tvoid __iomem\t\t*phy_rx;\n\tvoid __iomem\t\t*phy_tx;\n\tstruct device\t\t*dev;\n\tstruct device\t\t*control_dev;\n\tstruct clk\t\t*wkupclk;\n\tstruct clk\t\t*sys_clk;\n\tstruct clk\t\t*refclk;\n\tstruct clk\t\t*div_clk;\n\tstruct pipe3_dpll_map\t*dpll_map;\n\tstruct regmap\t\t*phy_power_syscon;  \n\tstruct regmap\t\t*pcs_syscon;  \n\tstruct regmap\t\t*dpll_reset_syscon;  \n\tunsigned int\t\tdpll_reset_reg;  \n\tunsigned int\t\tpower_reg;  \n\tunsigned int\t\tpcie_pcs_reg;  \n\tbool\t\t\tsata_refclk_enabled;\n\tenum pipe3_mode\t\tmode;\n\tstruct pipe3_settings\tsettings;\n};\n\nstatic struct pipe3_dpll_map dpll_map_usb[] = {\n\t{12000000, {1250, 5, 4, 20, 0} },\t \n\t{16800000, {3125, 20, 4, 20, 0} },\t \n\t{19200000, {1172, 8, 4, 20, 65537} },\t \n\t{20000000, {1000, 7, 4, 10, 0} },\t \n\t{26000000, {1250, 12, 4, 20, 0} },\t \n\t{38400000, {3125, 47, 4, 20, 92843} },\t \n\t{ },\t\t\t\t\t \n};\n\nstatic struct pipe3_dpll_map dpll_map_sata[] = {\n\t{12000000, {625, 4, 4, 6, 0} },\t \n\t{16800000, {625, 6, 4, 7, 0} },\t\t \n\t{19200000, {625, 7, 4, 6, 0} },\t\t \n\t{20000000, {750, 9, 4, 6, 0} },\t\t \n\t{26000000, {750, 12, 4, 6, 0} },\t \n\t{38400000, {625, 15, 4, 6, 0} },\t \n\t{ },\t\t\t\t\t \n};\n\nstruct pipe3_data {\n\tenum pipe3_mode mode;\n\tstruct pipe3_dpll_map *dpll_map;\n\tstruct pipe3_settings settings;\n};\n\nstatic struct pipe3_data data_usb = {\n\t.mode = PIPE3_MODE_USBSS,\n\t.dpll_map = dpll_map_usb,\n\t.settings = {\n\t \n\t\t.ana_interface = INTERFACE_MODE_USBSS,\n\t\t.ana_losd = 0xa,\n\t\t.dig_fastlock = 1,\n\t\t.dig_lbw = 3,\n\t\t.dig_stepcnt = 0,\n\t\t.dig_stl = 0x3,\n\t\t.dig_thr = 1,\n\t\t.dig_thr_mode = 1,\n\t\t.dig_2ndo_sdm_mode = 0,\n\t\t.dig_hs_rate = 0,\n\t\t.dig_ovrd_hs_rate = 1,\n\t\t.dll_trim_sel = 0x2,\n\t\t.dll_phint_rate = 0x3,\n\t\t.eq_lev = 0,\n\t\t.eq_ftc = 0,\n\t\t.eq_ctl = 0x9,\n\t\t.eq_ovrd_lev = 0,\n\t\t.eq_ovrd_ftc = 0,\n\t},\n};\n\nstatic struct pipe3_data data_sata = {\n\t.mode = PIPE3_MODE_SATA,\n\t.dpll_map = dpll_map_sata,\n\t.settings = {\n\t \n\t\t.ana_interface = INTERFACE_MODE_SATA_3P0,\n\t\t.ana_losd = 0x5,\n\t\t.dig_fastlock = 1,\n\t\t.dig_lbw = 3,\n\t\t.dig_stepcnt = 0,\n\t\t.dig_stl = 0x3,\n\t\t.dig_thr = 1,\n\t\t.dig_thr_mode = 1,\n\t\t.dig_2ndo_sdm_mode = 0,\n\t\t.dig_hs_rate = 0,\t \n\t\t.dig_ovrd_hs_rate = 0,\t \n\t\t.dll_trim_sel = 0x1,\n\t\t.dll_phint_rate = 0x2,\t \n\t\t.eq_lev = 0,\n\t\t.eq_ftc = 0x1f,\n\t\t.eq_ctl = 0,\n\t\t.eq_ovrd_lev = 1,\n\t\t.eq_ovrd_ftc = 1,\n\t},\n};\n\nstatic struct pipe3_data data_pcie = {\n\t.mode = PIPE3_MODE_PCIE,\n\t.settings = {\n\t \n\t\t.ana_interface = INTERFACE_MODE_PCIE,\n\t\t.ana_losd = 0xa,\n\t\t.dig_fastlock = 1,\n\t\t.dig_lbw = 3,\n\t\t.dig_stepcnt = 0,\n\t\t.dig_stl = 0x3,\n\t\t.dig_thr = 1,\n\t\t.dig_thr_mode = 1,\n\t\t.dig_2ndo_sdm_mode = 0,\n\t\t.dig_hs_rate = 0,\n\t\t.dig_ovrd_hs_rate = 0,\n\t\t.dll_trim_sel = 0x2,\n\t\t.dll_phint_rate = 0x3,\n\t\t.eq_lev = 0,\n\t\t.eq_ftc = 0x1f,\n\t\t.eq_ctl = 1,\n\t\t.eq_ovrd_lev = 0,\n\t\t.eq_ovrd_ftc = 0,\n\t},\n};\n\nstatic inline u32 ti_pipe3_readl(void __iomem *addr, unsigned offset)\n{\n\treturn __raw_readl(addr + offset);\n}\n\nstatic inline void ti_pipe3_writel(void __iomem *addr, unsigned offset,\n\tu32 data)\n{\n\t__raw_writel(data, addr + offset);\n}\n\nstatic struct pipe3_dpll_params *ti_pipe3_get_dpll_params(struct ti_pipe3 *phy)\n{\n\tunsigned long rate;\n\tstruct pipe3_dpll_map *dpll_map = phy->dpll_map;\n\n\trate = clk_get_rate(phy->sys_clk);\n\n\tfor (; dpll_map->rate; dpll_map++) {\n\t\tif (rate == dpll_map->rate)\n\t\t\treturn &dpll_map->params;\n\t}\n\n\tdev_err(phy->dev, \"No DPLL configuration for %lu Hz SYS CLK\\n\", rate);\n\n\treturn NULL;\n}\n\nstatic int ti_pipe3_enable_clocks(struct ti_pipe3 *phy);\nstatic void ti_pipe3_disable_clocks(struct ti_pipe3 *phy);\n\nstatic int ti_pipe3_power_off(struct phy *x)\n{\n\tint ret;\n\tstruct ti_pipe3 *phy = phy_get_drvdata(x);\n\n\tif (!phy->phy_power_syscon) {\n\t\tomap_control_phy_power(phy->control_dev, 0);\n\t\treturn 0;\n\t}\n\n\tret = regmap_update_bits(phy->phy_power_syscon, phy->power_reg,\n\t\t\t\t PIPE3_PHY_PWRCTL_CLK_CMD_MASK, 0);\n\treturn ret;\n}\n\nstatic void ti_pipe3_calibrate(struct ti_pipe3 *phy);\n\nstatic int ti_pipe3_power_on(struct phy *x)\n{\n\tu32 val;\n\tu32 mask;\n\tunsigned long rate;\n\tstruct ti_pipe3 *phy = phy_get_drvdata(x);\n\tbool rx_pending = false;\n\n\tif (!phy->phy_power_syscon) {\n\t\tomap_control_phy_power(phy->control_dev, 1);\n\t\treturn 0;\n\t}\n\n\trate = clk_get_rate(phy->sys_clk);\n\tif (!rate) {\n\t\tdev_err(phy->dev, \"Invalid clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\trate = rate / 1000000;\n\tmask = OMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_FREQ_MASK;\n\tval = rate << OMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_FREQ_SHIFT;\n\tregmap_update_bits(phy->phy_power_syscon, phy->power_reg,\n\t\t\t   mask, val);\n\t \n\tmask = OMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_CMD_MASK;\n\tif (phy->mode == PIPE3_MODE_SATA || phy->mode == PIPE3_MODE_USBSS) {\n\t\tval = PIPE3_PHY_TX_POWERON;\n\t\trx_pending = true;\n\t} else {\n\t\tval = PIPE3_PHY_TX_POWERON | PIPE3_PHY_RX_POWERON;\n\t}\n\n\tregmap_update_bits(phy->phy_power_syscon, phy->power_reg,\n\t\t\t   mask, val);\n\n\tif (rx_pending) {\n\t\tval = PIPE3_PHY_TX_POWERON | PIPE3_PHY_RX_POWERON;\n\t\tregmap_update_bits(phy->phy_power_syscon, phy->power_reg,\n\t\t\t\t   mask, val);\n\t}\n\n\tif (phy->mode == PIPE3_MODE_PCIE)\n\t\tti_pipe3_calibrate(phy);\n\n\treturn 0;\n}\n\nstatic int ti_pipe3_dpll_wait_lock(struct ti_pipe3 *phy)\n{\n\tu32\t\tval;\n\tunsigned long\ttimeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(PLL_LOCK_TIME);\n\tdo {\n\t\tcpu_relax();\n\t\tval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);\n\t\tif (val & PLL_LOCK)\n\t\t\treturn 0;\n\t} while (!time_after(jiffies, timeout));\n\n\tdev_err(phy->dev, \"DPLL failed to lock\\n\");\n\treturn -EBUSY;\n}\n\nstatic int ti_pipe3_dpll_program(struct ti_pipe3 *phy)\n{\n\tu32\t\t\tval;\n\tstruct pipe3_dpll_params *dpll_params;\n\n\tdpll_params = ti_pipe3_get_dpll_params(phy);\n\tif (!dpll_params)\n\t\treturn -EINVAL;\n\n\tval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION1);\n\tval &= ~PLL_REGN_MASK;\n\tval |= dpll_params->n << PLL_REGN_SHIFT;\n\tti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION1, val);\n\n\tval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);\n\tval &= ~PLL_SELFREQDCO_MASK;\n\tval |= dpll_params->freq << PLL_SELFREQDCO_SHIFT;\n\tti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);\n\n\tval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION1);\n\tval &= ~PLL_REGM_MASK;\n\tval |= dpll_params->m << PLL_REGM_SHIFT;\n\tti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION1, val);\n\n\tval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION4);\n\tval &= ~PLL_REGM_F_MASK;\n\tval |= dpll_params->mf << PLL_REGM_F_SHIFT;\n\tti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION4, val);\n\n\tval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION3);\n\tval &= ~PLL_SD_MASK;\n\tval |= dpll_params->sd << PLL_SD_SHIFT;\n\tti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION3, val);\n\n\tti_pipe3_writel(phy->pll_ctrl_base, PLL_GO, SET_PLL_GO);\n\n\treturn ti_pipe3_dpll_wait_lock(phy);\n}\n\nstatic void ti_pipe3_calibrate(struct ti_pipe3 *phy)\n{\n\tu32 val;\n\tstruct pipe3_settings *s = &phy->settings;\n\n\tval = ti_pipe3_readl(phy->phy_rx, PIPE3_PHY_RX_ANA_PROGRAMMABILITY);\n\tval &= ~(INTERFACE_MASK | LOSD_MASK | MEM_PLLDIV);\n\tval |= (s->ana_interface << INTERFACE_SHIFT | s->ana_losd << LOSD_SHIFT);\n\tti_pipe3_writel(phy->phy_rx, PIPE3_PHY_RX_ANA_PROGRAMMABILITY, val);\n\n\tval = ti_pipe3_readl(phy->phy_rx, PIPE3_PHY_RX_DIGITAL_MODES);\n\tval &= ~(MEM_HS_RATE_MASK | MEM_OVRD_HS_RATE | MEM_CDR_FASTLOCK |\n\t\t MEM_CDR_LBW_MASK | MEM_CDR_STEPCNT_MASK | MEM_CDR_STL_MASK |\n\t\t MEM_CDR_THR_MASK | MEM_CDR_THR_MODE | MEM_CDR_2NDO_SDM_MODE);\n\tval |= s->dig_hs_rate << MEM_HS_RATE_SHIFT |\n\t\ts->dig_ovrd_hs_rate << MEM_OVRD_HS_RATE_SHIFT |\n\t\ts->dig_fastlock << MEM_CDR_FASTLOCK_SHIFT |\n\t\ts->dig_lbw << MEM_CDR_LBW_SHIFT |\n\t\ts->dig_stepcnt << MEM_CDR_STEPCNT_SHIFT |\n\t\ts->dig_stl << MEM_CDR_STL_SHIFT |\n\t\ts->dig_thr << MEM_CDR_THR_SHIFT |\n\t\ts->dig_thr_mode << MEM_CDR_THR_MODE_SHIFT |\n\t\ts->dig_2ndo_sdm_mode << MEM_CDR_2NDO_SDM_MODE_SHIFT;\n\tti_pipe3_writel(phy->phy_rx, PIPE3_PHY_RX_DIGITAL_MODES, val);\n\n\tval = ti_pipe3_readl(phy->phy_rx, PIPE3_PHY_RX_TRIM);\n\tval &= ~MEM_DLL_TRIM_SEL_MASK;\n\tval |= s->dll_trim_sel << MEM_DLL_TRIM_SHIFT;\n\tti_pipe3_writel(phy->phy_rx, PIPE3_PHY_RX_TRIM, val);\n\n\tval = ti_pipe3_readl(phy->phy_rx, PIPE3_PHY_RX_DLL);\n\tval &= ~MEM_DLL_PHINT_RATE_MASK;\n\tval |= s->dll_phint_rate << MEM_DLL_PHINT_RATE_SHIFT;\n\tti_pipe3_writel(phy->phy_rx, PIPE3_PHY_RX_DLL, val);\n\n\tval = ti_pipe3_readl(phy->phy_rx, PIPE3_PHY_RX_EQUALIZER);\n\tval &= ~(MEM_EQLEV_MASK | MEM_EQFTC_MASK | MEM_EQCTL_MASK |\n\t\t MEM_OVRD_EQLEV | MEM_OVRD_EQFTC);\n\tval |= s->eq_lev << MEM_EQLEV_SHIFT |\n\t\ts->eq_ftc << MEM_EQFTC_SHIFT |\n\t\ts->eq_ctl << MEM_EQCTL_SHIFT |\n\t\ts->eq_ovrd_lev << MEM_OVRD_EQLEV_SHIFT |\n\t\ts->eq_ovrd_ftc << MEM_OVRD_EQFTC_SHIFT;\n\tti_pipe3_writel(phy->phy_rx, PIPE3_PHY_RX_EQUALIZER, val);\n\n\tif (phy->mode == PIPE3_MODE_SATA) {\n\t\tval = ti_pipe3_readl(phy->phy_rx,\n\t\t\t\t     SATA_PHY_RX_IO_AND_A2D_OVERRIDES);\n\t\tval &= ~MEM_CDR_LOS_SOURCE_MASK;\n\t\tti_pipe3_writel(phy->phy_rx, SATA_PHY_RX_IO_AND_A2D_OVERRIDES,\n\t\t\t\tval);\n\t}\n}\n\nstatic int ti_pipe3_init(struct phy *x)\n{\n\tstruct ti_pipe3 *phy = phy_get_drvdata(x);\n\tu32 val;\n\tint ret = 0;\n\n\tti_pipe3_enable_clocks(phy);\n\t \n\tif (phy->mode == PIPE3_MODE_PCIE) {\n\t\tif (!phy->pcs_syscon) {\n\t\t\tomap_control_pcie_pcs(phy->control_dev, 0x96);\n\t\t\treturn 0;\n\t\t}\n\n\t\tval = 0x96 << OMAP_CTRL_PCIE_PCS_DELAY_COUNT_SHIFT;\n\t\tret = regmap_update_bits(phy->pcs_syscon, phy->pcie_pcs_reg,\n\t\t\t\t\t PCIE_PCS_MASK, val);\n\t\treturn ret;\n\t}\n\n\t \n\tval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);\n\tif (val & PLL_IDLE) {\n\t\tval &= ~PLL_IDLE;\n\t\tti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);\n\t\tret = ti_pipe3_dpll_wait_lock(phy);\n\t}\n\n\t \n\tval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);\n\tif ((val & PLL_LOCK) && phy->mode == PIPE3_MODE_SATA)\n\t\treturn ret;\n\n\t \n\tret = ti_pipe3_dpll_program(phy);\n\tif (ret) {\n\t\tti_pipe3_disable_clocks(phy);\n\t\treturn -EINVAL;\n\t}\n\n\tti_pipe3_calibrate(phy);\n\n\treturn ret;\n}\n\nstatic int ti_pipe3_exit(struct phy *x)\n{\n\tstruct ti_pipe3 *phy = phy_get_drvdata(x);\n\tu32 val;\n\tunsigned long timeout;\n\n\t \n\tif (phy->mode == PIPE3_MODE_SATA && !phy->dpll_reset_syscon)\n\t\treturn 0;\n\n\t \n\tif (phy->mode != PIPE3_MODE_PCIE) {\n\t\t \n\t\tval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);\n\t\tval |= PLL_IDLE;\n\t\tti_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);\n\n\t\t \n\t\ttimeout = jiffies + msecs_to_jiffies(PLL_IDLE_TIME);\n\t\tdo {\n\t\t\tcpu_relax();\n\t\t\tval = ti_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);\n\t\t\tif ((val & PLL_TICOPWDN) && (val & PLL_LDOPWDN))\n\t\t\t\tbreak;\n\t\t} while (!time_after(jiffies, timeout));\n\n\t\tif (!(val & PLL_TICOPWDN) || !(val & PLL_LDOPWDN)) {\n\t\t\tdev_err(phy->dev, \"Failed to power down: PLL_STATUS 0x%x\\n\",\n\t\t\t\tval);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t \n\tif (phy->mode == PIPE3_MODE_SATA) {\n\t\tregmap_update_bits(phy->dpll_reset_syscon, phy->dpll_reset_reg,\n\t\t\t\t   SATA_PLL_SOFT_RESET, SATA_PLL_SOFT_RESET);\n\t\tregmap_update_bits(phy->dpll_reset_syscon, phy->dpll_reset_reg,\n\t\t\t\t   SATA_PLL_SOFT_RESET, 0);\n\t}\n\n\tti_pipe3_disable_clocks(phy);\n\n\treturn 0;\n}\nstatic const struct phy_ops ops = {\n\t.init\t\t= ti_pipe3_init,\n\t.exit\t\t= ti_pipe3_exit,\n\t.power_on\t= ti_pipe3_power_on,\n\t.power_off\t= ti_pipe3_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id ti_pipe3_id_table[];\n\nstatic int ti_pipe3_get_clk(struct ti_pipe3 *phy)\n{\n\tstruct clk *clk;\n\tstruct device *dev = phy->dev;\n\n\tphy->refclk = devm_clk_get(dev, \"refclk\");\n\tif (IS_ERR(phy->refclk)) {\n\t\tdev_err(dev, \"unable to get refclk\\n\");\n\t\t \n\t\tif (phy->mode != PIPE3_MODE_SATA)\n\t\t\treturn PTR_ERR(phy->refclk);\n\t}\n\n\tif (phy->mode != PIPE3_MODE_SATA) {\n\t\tphy->wkupclk = devm_clk_get(dev, \"wkupclk\");\n\t\tif (IS_ERR(phy->wkupclk)) {\n\t\t\tdev_err(dev, \"unable to get wkupclk\\n\");\n\t\t\treturn PTR_ERR(phy->wkupclk);\n\t\t}\n\t} else {\n\t\tphy->wkupclk = ERR_PTR(-ENODEV);\n\t}\n\n\tif (phy->mode != PIPE3_MODE_PCIE || phy->phy_power_syscon) {\n\t\tphy->sys_clk = devm_clk_get(dev, \"sysclk\");\n\t\tif (IS_ERR(phy->sys_clk)) {\n\t\t\tdev_err(dev, \"unable to get sysclk\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (phy->mode == PIPE3_MODE_PCIE) {\n\t\tclk = devm_clk_get(dev, \"dpll_ref\");\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_err(dev, \"unable to get dpll ref clk\\n\");\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\t\tclk_set_rate(clk, 1500000000);\n\n\t\tclk = devm_clk_get(dev, \"dpll_ref_m2\");\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_err(dev, \"unable to get dpll ref m2 clk\\n\");\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\t\tclk_set_rate(clk, 100000000);\n\n\t\tclk = devm_clk_get(dev, \"phy-div\");\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_err(dev, \"unable to get phy-div clk\\n\");\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\t\tclk_set_rate(clk, 100000000);\n\n\t\tphy->div_clk = devm_clk_get(dev, \"div-clk\");\n\t\tif (IS_ERR(phy->div_clk)) {\n\t\t\tdev_err(dev, \"unable to get div-clk\\n\");\n\t\t\treturn PTR_ERR(phy->div_clk);\n\t\t}\n\t} else {\n\t\tphy->div_clk = ERR_PTR(-ENODEV);\n\t}\n\n\treturn 0;\n}\n\nstatic int ti_pipe3_get_sysctrl(struct ti_pipe3 *phy)\n{\n\tstruct device *dev = phy->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct device_node *control_node;\n\tstruct platform_device *control_pdev;\n\n\tphy->phy_power_syscon = syscon_regmap_lookup_by_phandle(node,\n\t\t\t\t\t\t\t\"syscon-phy-power\");\n\tif (IS_ERR(phy->phy_power_syscon)) {\n\t\tdev_dbg(dev,\n\t\t\t\"can't get syscon-phy-power, using control device\\n\");\n\t\tphy->phy_power_syscon = NULL;\n\t} else {\n\t\tif (of_property_read_u32_index(node,\n\t\t\t\t\t       \"syscon-phy-power\", 1,\n\t\t\t\t\t       &phy->power_reg)) {\n\t\t\tdev_err(dev, \"couldn't get power reg. offset\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!phy->phy_power_syscon) {\n\t\tcontrol_node = of_parse_phandle(node, \"ctrl-module\", 0);\n\t\tif (!control_node) {\n\t\t\tdev_err(dev, \"Failed to get control device phandle\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcontrol_pdev = of_find_device_by_node(control_node);\n\t\tof_node_put(control_node);\n\t\tif (!control_pdev) {\n\t\t\tdev_err(dev, \"Failed to get control device\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tphy->control_dev = &control_pdev->dev;\n\t}\n\n\tif (phy->mode == PIPE3_MODE_PCIE) {\n\t\tphy->pcs_syscon = syscon_regmap_lookup_by_phandle(node,\n\t\t\t\t\t\t\t\t  \"syscon-pcs\");\n\t\tif (IS_ERR(phy->pcs_syscon)) {\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"can't get syscon-pcs, using omap control\\n\");\n\t\t\tphy->pcs_syscon = NULL;\n\t\t} else {\n\t\t\tif (of_property_read_u32_index(node,\n\t\t\t\t\t\t       \"syscon-pcs\", 1,\n\t\t\t\t\t\t       &phy->pcie_pcs_reg)) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"couldn't get pcie pcs reg. offset\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (phy->mode == PIPE3_MODE_SATA) {\n\t\tphy->dpll_reset_syscon = syscon_regmap_lookup_by_phandle(node,\n\t\t\t\t\t\t\t\"syscon-pllreset\");\n\t\tif (IS_ERR(phy->dpll_reset_syscon)) {\n\t\t\tdev_info(dev,\n\t\t\t\t \"can't get syscon-pllreset, sata dpll won't idle\\n\");\n\t\t\tphy->dpll_reset_syscon = NULL;\n\t\t} else {\n\t\t\tif (of_property_read_u32_index(node,\n\t\t\t\t\t\t       \"syscon-pllreset\", 1,\n\t\t\t\t\t\t       &phy->dpll_reset_reg)) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"couldn't get pllreset reg. offset\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ti_pipe3_get_tx_rx_base(struct ti_pipe3 *phy)\n{\n\tstruct device *dev = phy->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tphy->phy_rx = devm_platform_ioremap_resource_byname(pdev, \"phy_rx\");\n\tif (IS_ERR(phy->phy_rx))\n\t\treturn PTR_ERR(phy->phy_rx);\n\n\tphy->phy_tx = devm_platform_ioremap_resource_byname(pdev, \"phy_tx\");\n\n\treturn PTR_ERR_OR_ZERO(phy->phy_tx);\n}\n\nstatic int ti_pipe3_get_pll_base(struct ti_pipe3 *phy)\n{\n\tstruct device *dev = phy->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tif (phy->mode == PIPE3_MODE_PCIE)\n\t\treturn 0;\n\n\tphy->pll_ctrl_base =\n\t\tdevm_platform_ioremap_resource_byname(pdev, \"pll_ctrl\");\n\treturn PTR_ERR_OR_ZERO(phy->pll_ctrl_base);\n}\n\nstatic int ti_pipe3_probe(struct platform_device *pdev)\n{\n\tstruct ti_pipe3 *phy;\n\tstruct phy *generic_phy;\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\tconst struct of_device_id *match;\n\tstruct pipe3_data *data;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_device(ti_pipe3_id_table, dev);\n\tif (!match)\n\t\treturn -EINVAL;\n\n\tdata = (struct pipe3_data *)match->data;\n\tif (!data) {\n\t\tdev_err(dev, \"no driver data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tphy->dev = dev;\n\tphy->mode = data->mode;\n\tphy->dpll_map = data->dpll_map;\n\tphy->settings = data->settings;\n\n\tret = ti_pipe3_get_pll_base(phy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ti_pipe3_get_tx_rx_base(phy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ti_pipe3_get_sysctrl(phy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ti_pipe3_get_clk(phy);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, phy);\n\tpm_runtime_enable(dev);\n\n\t \n\tif (phy->mode == PIPE3_MODE_SATA) {\n\t\tif (!IS_ERR(phy->refclk)) {\n\t\t\tclk_prepare_enable(phy->refclk);\n\t\t\tphy->sata_refclk_enabled = true;\n\t\t}\n\t}\n\n\tgeneric_phy = devm_phy_create(dev, NULL, &ops);\n\tif (IS_ERR(generic_phy))\n\t\treturn PTR_ERR(generic_phy);\n\n\tphy_set_drvdata(generic_phy, phy);\n\n\tti_pipe3_power_off(generic_phy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic void ti_pipe3_remove(struct platform_device *pdev)\n{\n\tstruct ti_pipe3 *phy = platform_get_drvdata(pdev);\n\n\tif (phy->mode == PIPE3_MODE_SATA) {\n\t\tclk_disable_unprepare(phy->refclk);\n\t\tphy->sata_refclk_enabled = false;\n\t}\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int ti_pipe3_enable_clocks(struct ti_pipe3 *phy)\n{\n\tint ret = 0;\n\n\tif (!IS_ERR(phy->refclk)) {\n\t\tret = clk_prepare_enable(phy->refclk);\n\t\tif (ret) {\n\t\t\tdev_err(phy->dev, \"Failed to enable refclk %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!IS_ERR(phy->wkupclk)) {\n\t\tret = clk_prepare_enable(phy->wkupclk);\n\t\tif (ret) {\n\t\t\tdev_err(phy->dev, \"Failed to enable wkupclk %d\\n\", ret);\n\t\t\tgoto disable_refclk;\n\t\t}\n\t}\n\n\tif (!IS_ERR(phy->div_clk)) {\n\t\tret = clk_prepare_enable(phy->div_clk);\n\t\tif (ret) {\n\t\t\tdev_err(phy->dev, \"Failed to enable div_clk %d\\n\", ret);\n\t\t\tgoto disable_wkupclk;\n\t\t}\n\t}\n\n\treturn 0;\n\ndisable_wkupclk:\n\tif (!IS_ERR(phy->wkupclk))\n\t\tclk_disable_unprepare(phy->wkupclk);\n\ndisable_refclk:\n\tif (!IS_ERR(phy->refclk))\n\t\tclk_disable_unprepare(phy->refclk);\n\n\treturn ret;\n}\n\nstatic void ti_pipe3_disable_clocks(struct ti_pipe3 *phy)\n{\n\tif (!IS_ERR(phy->wkupclk))\n\t\tclk_disable_unprepare(phy->wkupclk);\n\tif (!IS_ERR(phy->refclk))\n\t\tclk_disable_unprepare(phy->refclk);\n\tif (!IS_ERR(phy->div_clk))\n\t\tclk_disable_unprepare(phy->div_clk);\n}\n\nstatic const struct of_device_id ti_pipe3_id_table[] = {\n\t{\n\t\t.compatible = \"ti,phy-usb3\",\n\t\t.data = &data_usb,\n\t},\n\t{\n\t\t.compatible = \"ti,omap-usb3\",\n\t\t.data = &data_usb,\n\t},\n\t{\n\t\t.compatible = \"ti,phy-pipe3-sata\",\n\t\t.data = &data_sata,\n\t},\n\t{\n\t\t.compatible = \"ti,phy-pipe3-pcie\",\n\t\t.data = &data_pcie,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ti_pipe3_id_table);\n\nstatic struct platform_driver ti_pipe3_driver = {\n\t.probe\t\t= ti_pipe3_probe,\n\t.remove_new\t= ti_pipe3_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"ti-pipe3\",\n\t\t.of_match_table = ti_pipe3_id_table,\n\t},\n};\n\nmodule_platform_driver(ti_pipe3_driver);\n\nMODULE_ALIAS(\"platform:ti_pipe3\");\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\nMODULE_DESCRIPTION(\"TI PIPE3 phy driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}