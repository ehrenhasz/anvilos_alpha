{
  "module_name": "phy-omap-usb2.c",
  "hash_id": "337d7f8ca2c6a18fe4b9b5ec64df1536035b7784c2a57ec2d2a99fe553ca4c6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/ti/phy-omap-usb2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/phy/omap_control_phy.h>\n#include <linux/phy/omap_usb.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/sys_soc.h>\n#include <linux/usb/phy_companion.h>\n\n#define USB2PHY_ANA_CONFIG1\t\t0x4c\n#define USB2PHY_DISCON_BYP_LATCH\tBIT(31)\n\n#define USB2PHY_CHRG_DET\t\t\t0x14\n#define USB2PHY_CHRG_DET_USE_CHG_DET_REG\tBIT(29)\n#define USB2PHY_CHRG_DET_DIS_CHG_DET\t\tBIT(28)\n\n \n#define AM654_USB2_OTG_PD\t\tBIT(8)\n#define AM654_USB2_VBUS_DET_EN\t\tBIT(5)\n#define AM654_USB2_VBUSVALID_DET_EN\tBIT(4)\n\n#define OMAP_DEV_PHY_PD\t\tBIT(0)\n#define OMAP_USB2_PHY_PD\tBIT(28)\n\n#define AM437X_USB2_PHY_PD\t\tBIT(0)\n#define AM437X_USB2_OTG_PD\t\tBIT(1)\n#define AM437X_USB2_OTGVDET_EN\t\tBIT(19)\n#define AM437X_USB2_OTGSESSEND_EN\tBIT(20)\n\n \n#define OMAP_USB2_HAS_START_SRP\t\t\tBIT(0)\n#define OMAP_USB2_HAS_SET_VBUS\t\t\tBIT(1)\n#define OMAP_USB2_CALIBRATE_FALSE_DISCONNECT\tBIT(2)\n#define OMAP_USB2_DISABLE_CHRG_DET\t\tBIT(3)\n\nstruct omap_usb {\n\tstruct usb_phy\t\tphy;\n\tstruct phy_companion\t*comparator;\n\tvoid __iomem\t\t*pll_ctrl_base;\n\tvoid __iomem\t\t*phy_base;\n\tstruct device\t\t*dev;\n\tstruct device\t\t*control_dev;\n\tstruct clk\t\t*wkupclk;\n\tstruct clk\t\t*optclk;\n\tu8\t\t\tflags;\n\tstruct regmap\t\t*syscon_phy_power;  \n\tunsigned int\t\tpower_reg;  \n\tu32\t\t\tmask;\n\tu32\t\t\tpower_on;\n\tu32\t\t\tpower_off;\n};\n\n#define\tphy_to_omapusb(x)\tcontainer_of((x), struct omap_usb, phy)\n\nstruct usb_phy_data {\n\tconst char *label;\n\tu8 flags;\n\tu32 mask;\n\tu32 power_on;\n\tu32 power_off;\n};\n\nstatic inline u32 omap_usb_readl(void __iomem *addr, unsigned int offset)\n{\n\treturn __raw_readl(addr + offset);\n}\n\nstatic inline void omap_usb_writel(void __iomem *addr, unsigned int offset,\n\t\t\t\t   u32 data)\n{\n\t__raw_writel(data, addr + offset);\n}\n\n \nint omap_usb2_set_comparator(struct phy_companion *comparator)\n{\n\tstruct omap_usb\t*phy;\n\tstruct usb_phy\t*x = usb_get_phy(USB_PHY_TYPE_USB2);\n\n\tif (IS_ERR(x))\n\t\treturn -ENODEV;\n\n\tphy = phy_to_omapusb(x);\n\tphy->comparator = comparator;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(omap_usb2_set_comparator);\n\nstatic int omap_usb_set_vbus(struct usb_otg *otg, bool enabled)\n{\n\tstruct omap_usb *phy = phy_to_omapusb(otg->usb_phy);\n\n\tif (!phy->comparator)\n\t\treturn -ENODEV;\n\n\treturn phy->comparator->set_vbus(phy->comparator, enabled);\n}\n\nstatic int omap_usb_start_srp(struct usb_otg *otg)\n{\n\tstruct omap_usb *phy = phy_to_omapusb(otg->usb_phy);\n\n\tif (!phy->comparator)\n\t\treturn -ENODEV;\n\n\treturn phy->comparator->start_srp(phy->comparator);\n}\n\nstatic int omap_usb_set_host(struct usb_otg *otg, struct usb_bus *host)\n{\n\totg->host = host;\n\tif (!host)\n\t\totg->state = OTG_STATE_UNDEFINED;\n\n\treturn 0;\n}\n\nstatic int omap_usb_set_peripheral(struct usb_otg *otg,\n\t\t\t\t   struct usb_gadget *gadget)\n{\n\totg->gadget = gadget;\n\tif (!gadget)\n\t\totg->state = OTG_STATE_UNDEFINED;\n\n\treturn 0;\n}\n\nstatic int omap_usb_phy_power(struct omap_usb *phy, int on)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!phy->syscon_phy_power) {\n\t\tomap_control_phy_power(phy->control_dev, on);\n\t\treturn 0;\n\t}\n\n\tif (on)\n\t\tval = phy->power_on;\n\telse\n\t\tval = phy->power_off;\n\n\tret = regmap_update_bits(phy->syscon_phy_power, phy->power_reg,\n\t\t\t\t phy->mask, val);\n\treturn ret;\n}\n\nstatic int omap_usb_power_off(struct phy *x)\n{\n\tstruct omap_usb *phy = phy_get_drvdata(x);\n\n\treturn omap_usb_phy_power(phy, false);\n}\n\nstatic int omap_usb_power_on(struct phy *x)\n{\n\tstruct omap_usb *phy = phy_get_drvdata(x);\n\n\treturn omap_usb_phy_power(phy, true);\n}\n\nstatic int omap_usb2_disable_clocks(struct omap_usb *phy)\n{\n\tclk_disable_unprepare(phy->wkupclk);\n\tif (!IS_ERR(phy->optclk))\n\t\tclk_disable_unprepare(phy->optclk);\n\n\treturn 0;\n}\n\nstatic int omap_usb2_enable_clocks(struct omap_usb *phy)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(phy->wkupclk);\n\tif (ret < 0) {\n\t\tdev_err(phy->dev, \"Failed to enable wkupclk %d\\n\", ret);\n\t\tgoto err0;\n\t}\n\n\tif (!IS_ERR(phy->optclk)) {\n\t\tret = clk_prepare_enable(phy->optclk);\n\t\tif (ret < 0) {\n\t\t\tdev_err(phy->dev, \"Failed to enable optclk %d\\n\", ret);\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr1:\n\tclk_disable_unprepare(phy->wkupclk);\n\nerr0:\n\treturn ret;\n}\n\nstatic int omap_usb_init(struct phy *x)\n{\n\tstruct omap_usb *phy = phy_get_drvdata(x);\n\tu32 val;\n\n\tomap_usb2_enable_clocks(phy);\n\n\tif (phy->flags & OMAP_USB2_CALIBRATE_FALSE_DISCONNECT) {\n\t\t \n\t\tval = omap_usb_readl(phy->phy_base, USB2PHY_ANA_CONFIG1);\n\t\tval |= USB2PHY_DISCON_BYP_LATCH;\n\t\tomap_usb_writel(phy->phy_base, USB2PHY_ANA_CONFIG1, val);\n\t}\n\n\tif (phy->flags & OMAP_USB2_DISABLE_CHRG_DET) {\n\t\tval = omap_usb_readl(phy->phy_base, USB2PHY_CHRG_DET);\n\t\tval |= USB2PHY_CHRG_DET_USE_CHG_DET_REG |\n\t\t       USB2PHY_CHRG_DET_DIS_CHG_DET;\n\t\tomap_usb_writel(phy->phy_base, USB2PHY_CHRG_DET, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_usb_exit(struct phy *x)\n{\n\tstruct omap_usb *phy = phy_get_drvdata(x);\n\n\treturn omap_usb2_disable_clocks(phy);\n}\n\nstatic const struct phy_ops ops = {\n\t.init\t\t= omap_usb_init,\n\t.exit\t\t= omap_usb_exit,\n\t.power_on\t= omap_usb_power_on,\n\t.power_off\t= omap_usb_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct usb_phy_data omap_usb2_data = {\n\t.label = \"omap_usb2\",\n\t.flags = OMAP_USB2_HAS_START_SRP | OMAP_USB2_HAS_SET_VBUS,\n\t.mask = OMAP_DEV_PHY_PD,\n\t.power_off = OMAP_DEV_PHY_PD,\n};\n\nstatic const struct usb_phy_data omap5_usb2_data = {\n\t.label = \"omap5_usb2\",\n\t.flags = 0,\n\t.mask = OMAP_DEV_PHY_PD,\n\t.power_off = OMAP_DEV_PHY_PD,\n};\n\nstatic const struct usb_phy_data dra7x_usb2_data = {\n\t.label = \"dra7x_usb2\",\n\t.flags = OMAP_USB2_CALIBRATE_FALSE_DISCONNECT,\n\t.mask = OMAP_DEV_PHY_PD,\n\t.power_off = OMAP_DEV_PHY_PD,\n};\n\nstatic const struct usb_phy_data dra7x_usb2_phy2_data = {\n\t.label = \"dra7x_usb2_phy2\",\n\t.flags = OMAP_USB2_CALIBRATE_FALSE_DISCONNECT,\n\t.mask = OMAP_USB2_PHY_PD,\n\t.power_off = OMAP_USB2_PHY_PD,\n};\n\nstatic const struct usb_phy_data am437x_usb2_data = {\n\t.label = \"am437x_usb2\",\n\t.flags =  0,\n\t.mask = AM437X_USB2_PHY_PD | AM437X_USB2_OTG_PD |\n\t\tAM437X_USB2_OTGVDET_EN | AM437X_USB2_OTGSESSEND_EN,\n\t.power_on = AM437X_USB2_OTGVDET_EN | AM437X_USB2_OTGSESSEND_EN,\n\t.power_off = AM437X_USB2_PHY_PD | AM437X_USB2_OTG_PD,\n};\n\nstatic const struct usb_phy_data am654_usb2_data = {\n\t.label = \"am654_usb2\",\n\t.flags = OMAP_USB2_CALIBRATE_FALSE_DISCONNECT,\n\t.mask = AM654_USB2_OTG_PD | AM654_USB2_VBUS_DET_EN |\n\t\tAM654_USB2_VBUSVALID_DET_EN,\n\t.power_on = AM654_USB2_VBUS_DET_EN | AM654_USB2_VBUSVALID_DET_EN,\n\t.power_off = AM654_USB2_OTG_PD,\n};\n\nstatic const struct of_device_id omap_usb2_id_table[] = {\n\t{\n\t\t.compatible = \"ti,omap-usb2\",\n\t\t.data = &omap_usb2_data,\n\t},\n\t{\n\t\t.compatible = \"ti,omap5-usb2\",\n\t\t.data = &omap5_usb2_data,\n\t},\n\t{\n\t\t.compatible = \"ti,dra7x-usb2\",\n\t\t.data = &dra7x_usb2_data,\n\t},\n\t{\n\t\t.compatible = \"ti,dra7x-usb2-phy2\",\n\t\t.data = &dra7x_usb2_phy2_data,\n\t},\n\t{\n\t\t.compatible = \"ti,am437x-usb2\",\n\t\t.data = &am437x_usb2_data,\n\t},\n\t{\n\t\t.compatible = \"ti,am654-usb2\",\n\t\t.data = &am654_usb2_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_usb2_id_table);\n\nstatic void omap_usb2_init_errata(struct omap_usb *phy)\n{\n\tstatic const struct soc_device_attribute am65x_sr10_soc_devices[] = {\n\t\t{ .family = \"AM65X\", .revision = \"SR1.0\" },\n\t\t{   }\n\t};\n\n\t \n\tif (soc_device_match(am65x_sr10_soc_devices))\n\t\tphy->flags |= OMAP_USB2_DISABLE_CHRG_DET;\n}\n\nstatic int omap_usb2_probe(struct platform_device *pdev)\n{\n\tstruct omap_usb\t*phy;\n\tstruct phy *generic_phy;\n\tstruct phy_provider *phy_provider;\n\tstruct usb_otg *otg;\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device_node *control_node;\n\tstruct platform_device *control_pdev;\n\tconst struct of_device_id *of_id;\n\tstruct usb_phy_data *phy_data;\n\n\tof_id = of_match_device(omap_usb2_id_table, &pdev->dev);\n\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tphy_data = (struct usb_phy_data *)of_id->data;\n\n\tphy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\totg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);\n\tif (!otg)\n\t\treturn -ENOMEM;\n\n\tphy->dev\t\t= &pdev->dev;\n\n\tphy->phy.dev\t\t= phy->dev;\n\tphy->phy.label\t\t= phy_data->label;\n\tphy->phy.otg\t\t= otg;\n\tphy->phy.type\t\t= USB_PHY_TYPE_USB2;\n\tphy->mask\t\t= phy_data->mask;\n\tphy->power_on\t\t= phy_data->power_on;\n\tphy->power_off\t\t= phy_data->power_off;\n\tphy->flags\t\t= phy_data->flags;\n\n\tomap_usb2_init_errata(phy);\n\n\tphy->phy_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(phy->phy_base))\n\t\treturn PTR_ERR(phy->phy_base);\n\n\tphy->syscon_phy_power = syscon_regmap_lookup_by_phandle(node,\n\t\t\t\t\t\t\t\t\"syscon-phy-power\");\n\tif (IS_ERR(phy->syscon_phy_power)) {\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"can't get syscon-phy-power, using control device\\n\");\n\t\tphy->syscon_phy_power = NULL;\n\n\t\tcontrol_node = of_parse_phandle(node, \"ctrl-module\", 0);\n\t\tif (!control_node) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to get control device phandle\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcontrol_pdev = of_find_device_by_node(control_node);\n\t\tif (!control_pdev) {\n\t\t\tdev_err(&pdev->dev, \"Failed to get control device\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tphy->control_dev = &control_pdev->dev;\n\t} else {\n\t\tif (of_property_read_u32_index(node,\n\t\t\t\t\t       \"syscon-phy-power\", 1,\n\t\t\t\t\t       &phy->power_reg)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"couldn't get power reg. offset\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tphy->wkupclk = devm_clk_get(phy->dev, \"wkupclk\");\n\tif (IS_ERR(phy->wkupclk)) {\n\t\tif (PTR_ERR(phy->wkupclk) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tdev_warn(&pdev->dev, \"unable to get wkupclk %ld, trying old name\\n\",\n\t\t\t PTR_ERR(phy->wkupclk));\n\t\tphy->wkupclk = devm_clk_get(phy->dev, \"usb_phy_cm_clk32k\");\n\n\t\tif (IS_ERR(phy->wkupclk))\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(phy->wkupclk),\n\t\t\t\t\t     \"unable to get usb_phy_cm_clk32k\\n\");\n\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"found usb_phy_cm_clk32k, please fix DTS\\n\");\n\t}\n\n\tphy->optclk = devm_clk_get(phy->dev, \"refclk\");\n\tif (IS_ERR(phy->optclk)) {\n\t\tif (PTR_ERR(phy->optclk) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tdev_dbg(&pdev->dev, \"unable to get refclk, trying old name\\n\");\n\t\tphy->optclk = devm_clk_get(phy->dev, \"usb_otg_ss_refclk960m\");\n\n\t\tif (IS_ERR(phy->optclk)) {\n\t\t\tif (PTR_ERR(phy->optclk) != -EPROBE_DEFER) {\n\t\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\t\"unable to get usb_otg_ss_refclk960m\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"found usb_otg_ss_refclk960m, please fix DTS\\n\");\n\t\t}\n\t}\n\n\totg->set_host = omap_usb_set_host;\n\totg->set_peripheral = omap_usb_set_peripheral;\n\tif (phy_data->flags & OMAP_USB2_HAS_SET_VBUS)\n\t\totg->set_vbus = omap_usb_set_vbus;\n\tif (phy_data->flags & OMAP_USB2_HAS_START_SRP)\n\t\totg->start_srp = omap_usb_start_srp;\n\totg->usb_phy = &phy->phy;\n\n\tplatform_set_drvdata(pdev, phy);\n\tpm_runtime_enable(phy->dev);\n\n\tgeneric_phy = devm_phy_create(phy->dev, NULL, &ops);\n\tif (IS_ERR(generic_phy)) {\n\t\tpm_runtime_disable(phy->dev);\n\t\treturn PTR_ERR(generic_phy);\n\t}\n\n\tphy_set_drvdata(generic_phy, phy);\n\tomap_usb_power_off(generic_phy);\n\n\tphy_provider = devm_of_phy_provider_register(phy->dev,\n\t\t\t\t\t\t     of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tpm_runtime_disable(phy->dev);\n\t\treturn PTR_ERR(phy_provider);\n\t}\n\n\tusb_add_phy_dev(&phy->phy);\n\n\treturn 0;\n}\n\nstatic void omap_usb2_remove(struct platform_device *pdev)\n{\n\tstruct omap_usb\t*phy = platform_get_drvdata(pdev);\n\n\tusb_remove_phy(&phy->phy);\n\tpm_runtime_disable(phy->dev);\n}\n\nstatic struct platform_driver omap_usb2_driver = {\n\t.probe\t\t= omap_usb2_probe,\n\t.remove_new\t= omap_usb2_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"omap-usb2\",\n\t\t.of_match_table = omap_usb2_id_table,\n\t},\n};\n\nmodule_platform_driver(omap_usb2_driver);\n\nMODULE_ALIAS(\"platform:omap_usb2\");\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\nMODULE_DESCRIPTION(\"OMAP USB2 phy driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}