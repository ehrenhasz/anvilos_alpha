{
  "module_name": "phy-am654-serdes.c",
  "hash_id": "ee6a66ce8bb0fc5ccc56f989b7ef451758dbe78197d0fa2bd61ffbe9d21dc448",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/ti/phy-am654-serdes.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/phy/phy.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mux/consumer.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#define CMU_R004\t\t0x4\n#define CMU_R060\t\t0x60\n#define CMU_R07C\t\t0x7c\n#define CMU_R088\t\t0x88\n#define CMU_R0D0\t\t0xd0\n#define CMU_R0E8\t\t0xe8\n\n#define LANE_R048\t\t0x248\n#define LANE_R058\t\t0x258\n#define LANE_R06c\t\t0x26c\n#define LANE_R070\t\t0x270\n#define LANE_R070\t\t0x270\n#define LANE_R19C\t\t0x39c\n\n#define COMLANE_R004\t\t0xa04\n#define COMLANE_R138\t\t0xb38\n#define VERSION_VAL\t\t0x70\n\n#define COMLANE_R190\t\t0xb90\n#define COMLANE_R194\t\t0xb94\n\n#define COMRXEQ_R004\t\t0x1404\n#define COMRXEQ_R008\t\t0x1408\n#define COMRXEQ_R00C\t\t0x140c\n#define COMRXEQ_R014\t\t0x1414\n#define COMRXEQ_R018\t\t0x1418\n#define COMRXEQ_R01C\t\t0x141c\n#define COMRXEQ_R04C\t\t0x144c\n#define COMRXEQ_R088\t\t0x1488\n#define COMRXEQ_R094\t\t0x1494\n#define COMRXEQ_R098\t\t0x1498\n\n#define SERDES_CTRL\t\t0x1fd0\n\n#define WIZ_LANEXCTL_STS\t0x1fe0\n#define TX0_DISABLE_STATE\t0x4\n#define TX0_SLEEP_STATE\t\t0x5\n#define TX0_SNOOZE_STATE\t0x6\n#define TX0_ENABLE_STATE\t0x7\n\n#define RX0_DISABLE_STATE\t0x4\n#define RX0_SLEEP_STATE\t\t0x5\n#define RX0_SNOOZE_STATE\t0x6\n#define RX0_ENABLE_STATE\t0x7\n\n#define WIZ_PLL_CTRL\t\t0x1ff4\n#define PLL_DISABLE_STATE\t0x4\n#define PLL_SLEEP_STATE\t\t0x5\n#define PLL_SNOOZE_STATE\t0x6\n#define PLL_ENABLE_STATE\t0x7\n\n#define PLL_LOCK_TIME\t\t100000\t \n#define SLEEP_TIME\t\t100\t \n\n#define LANE_USB3\t\t0x0\n#define LANE_PCIE0_LANE0\t0x1\n\n#define LANE_PCIE1_LANE0\t0x0\n#define LANE_PCIE0_LANE1\t0x1\n\n#define SERDES_NUM_CLOCKS\t3\n\n#define AM654_SERDES_CTRL_CLKSEL_MASK\tGENMASK(7, 4)\n#define AM654_SERDES_CTRL_CLKSEL_SHIFT\t4\n\nstruct serdes_am654_clk_mux {\n\tstruct clk_hw\thw;\n\tstruct regmap\t*regmap;\n\tunsigned int\treg;\n\tint\t\tclk_id;\n\tstruct clk_init_data clk_data;\n};\n\n#define to_serdes_am654_clk_mux(_hw)\t\\\n\t\tcontainer_of(_hw, struct serdes_am654_clk_mux, hw)\n\nstatic const struct regmap_config serdes_am654_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.fast_io = true,\n\t.max_register = 0x1ffc,\n};\n\nenum serdes_am654_fields {\n\t \n\tCMU_PLL_CTRL,\n\n\tLANE_PLL_CTRL_RXEQ_RXIDLE,\n\n\t \n\tAHB_PMA_CM_VCO_VBIAS_VREG,\n\tAHB_PMA_CM_VCO_BIAS_VREG,\n\n\tAHB_PMA_CM_SR,\n\tAHB_SSC_GEN_Z_O_20_13,\n\n\t \n\tAHB_PMA_LN_AGC_THSEL_VREGH,\n\n\t \n\tAHB_PMA_LN_GEN3_AGC_SD_THSEL,\n\n\tAHB_PMA_LN_RX_SELR_GEN3,\n\tAHB_PMA_LN_TX_DRV,\n\n\t \n\tCMU_MASTER_CDN,\n\n\t \n\tP2S_RBUF_PTR_DIFF,\n\n\tCONFIG_VERSION,\n\n\t \n\tL1_MASTER_CDN,\n\n\t \n\tCMU_OK_I_0,\n\n\t \n\tCOMRXEQ_MS_INIT_CTRL_7_0,\n\n\t \n\tCOMRXEQ_HS_INIT_CAL_7_0,\n\n\t \n\tCOMRXEQ_MS_RECAL_CTRL_7_0,\n\n\t \n\tCOMRXEQ_HS_RECAL_CTRL_7_0,\n\n\t \n\tCOMRXEQ_CSR_ATT_CONFIG,\n\n\t \n\tCOMRXEQ_CSR_EBSTADAPT_WIN_LEN,\n\n\t \n\tCOMRXEQ_CTRL_3_4,\n\n\t \n\tCOMRXEQ_CTRL_14_15_16,\n\n\t \n\tCOMRXEQ_CSR_DLEV_ERR_THRESH,\n\n\t \n\tCOMRXEQ_CTRL_25,\n\n\t \n\tCSR_RXEQ_RATE_CHANGE_CAL_RUN_RATE2_O,\n\n\t \n\tCOMRXEQ_HS_RCHANGE_CTRL_7_0,\n\n\t \n\tPOR_EN,\n\n\t \n\tTX0_ENABLE,\n\n\t \n\tRX0_ENABLE,\n\n\t \n\tPLL_ENABLE,\n\n\t \n\tPLL_OK,\n\n\t \n\tMAX_FIELDS\n\n};\n\nstatic const struct reg_field serdes_am654_reg_fields[] = {\n\t[CMU_PLL_CTRL]\t\t\t= REG_FIELD(CMU_R004, 8, 15),\n\t[AHB_PMA_CM_VCO_VBIAS_VREG]\t= REG_FIELD(CMU_R060, 8, 15),\n\t[CMU_MASTER_CDN]\t\t= REG_FIELD(CMU_R07C, 24, 31),\n\t[AHB_PMA_CM_VCO_BIAS_VREG]\t= REG_FIELD(CMU_R088, 24, 31),\n\t[AHB_PMA_CM_SR]\t\t\t= REG_FIELD(CMU_R0D0, 24, 31),\n\t[AHB_SSC_GEN_Z_O_20_13]\t\t= REG_FIELD(CMU_R0E8, 8, 15),\n\t[LANE_PLL_CTRL_RXEQ_RXIDLE]\t= REG_FIELD(LANE_R048, 8, 15),\n\t[AHB_PMA_LN_AGC_THSEL_VREGH]\t= REG_FIELD(LANE_R058, 16, 23),\n\t[AHB_PMA_LN_GEN3_AGC_SD_THSEL]\t= REG_FIELD(LANE_R06c, 0, 7),\n\t[AHB_PMA_LN_RX_SELR_GEN3]\t= REG_FIELD(LANE_R070, 16, 23),\n\t[AHB_PMA_LN_TX_DRV]\t\t= REG_FIELD(LANE_R19C, 16, 23),\n\t[P2S_RBUF_PTR_DIFF]\t\t= REG_FIELD(COMLANE_R004, 0, 7),\n\t[CONFIG_VERSION]\t\t= REG_FIELD(COMLANE_R138, 16, 23),\n\t[L1_MASTER_CDN]\t\t\t= REG_FIELD(COMLANE_R190, 8, 15),\n\t[CMU_OK_I_0]\t\t\t= REG_FIELD(COMLANE_R194, 19, 19),\n\t[COMRXEQ_MS_INIT_CTRL_7_0]\t= REG_FIELD(COMRXEQ_R004, 24, 31),\n\t[COMRXEQ_HS_INIT_CAL_7_0]\t= REG_FIELD(COMRXEQ_R008, 0, 7),\n\t[COMRXEQ_MS_RECAL_CTRL_7_0]\t= REG_FIELD(COMRXEQ_R00C, 8, 15),\n\t[COMRXEQ_HS_RECAL_CTRL_7_0]\t= REG_FIELD(COMRXEQ_R00C, 16, 23),\n\t[COMRXEQ_CSR_ATT_CONFIG]\t= REG_FIELD(COMRXEQ_R014, 16, 23),\n\t[COMRXEQ_CSR_EBSTADAPT_WIN_LEN]\t= REG_FIELD(COMRXEQ_R018, 16, 23),\n\t[COMRXEQ_CTRL_3_4]\t\t= REG_FIELD(COMRXEQ_R01C, 8, 15),\n\t[COMRXEQ_CTRL_14_15_16]\t\t= REG_FIELD(COMRXEQ_R04C, 0, 7),\n\t[COMRXEQ_CSR_DLEV_ERR_THRESH]\t= REG_FIELD(COMRXEQ_R088, 16, 23),\n\t[COMRXEQ_CTRL_25]\t\t= REG_FIELD(COMRXEQ_R094, 24, 31),\n\t[CSR_RXEQ_RATE_CHANGE_CAL_RUN_RATE2_O] = REG_FIELD(COMRXEQ_R098, 8, 15),\n\t[COMRXEQ_HS_RCHANGE_CTRL_7_0]\t= REG_FIELD(COMRXEQ_R098, 16, 23),\n\t[POR_EN]\t\t\t= REG_FIELD(SERDES_CTRL, 29, 29),\n\t[TX0_ENABLE]\t\t\t= REG_FIELD(WIZ_LANEXCTL_STS, 29, 31),\n\t[RX0_ENABLE]\t\t\t= REG_FIELD(WIZ_LANEXCTL_STS, 13, 15),\n\t[PLL_ENABLE]\t\t\t= REG_FIELD(WIZ_PLL_CTRL, 29, 31),\n\t[PLL_OK]\t\t\t= REG_FIELD(WIZ_PLL_CTRL, 28, 28),\n};\n\nstruct serdes_am654 {\n\tstruct regmap\t\t*regmap;\n\tstruct regmap_field\t*fields[MAX_FIELDS];\n\n\tstruct device\t\t*dev;\n\tstruct mux_control\t*control;\n\tbool\t\t\tbusy;\n\tu32\t\t\ttype;\n\tstruct device_node\t*of_node;\n\tstruct clk_onecell_data\tclk_data;\n\tstruct clk\t\t*clks[SERDES_NUM_CLOCKS];\n};\n\nstatic int serdes_am654_enable_pll(struct serdes_am654 *phy)\n{\n\tint ret;\n\tu32 val;\n\n\tret = regmap_field_write(phy->fields[PLL_ENABLE], PLL_ENABLE_STATE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_field_read_poll_timeout(phy->fields[PLL_OK], val, val,\n\t\t\t\t\t      1000, PLL_LOCK_TIME);\n}\n\nstatic void serdes_am654_disable_pll(struct serdes_am654 *phy)\n{\n\tstruct device *dev = phy->dev;\n\tint ret;\n\n\tret = regmap_field_write(phy->fields[PLL_ENABLE], PLL_DISABLE_STATE);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to disable PLL\\n\");\n}\n\nstatic int serdes_am654_enable_txrx(struct serdes_am654 *phy)\n{\n\tint ret = 0;\n\n\t \n\tret |= regmap_field_write(phy->fields[TX0_ENABLE], TX0_ENABLE_STATE);\n\n\t \n\tret |= regmap_field_write(phy->fields[RX0_ENABLE], RX0_ENABLE_STATE);\n\n\tif (ret)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int serdes_am654_disable_txrx(struct serdes_am654 *phy)\n{\n\tint ret = 0;\n\n\t \n\tret |= regmap_field_write(phy->fields[TX0_ENABLE], TX0_DISABLE_STATE);\n\n\t \n\tret |= regmap_field_write(phy->fields[RX0_ENABLE], RX0_DISABLE_STATE);\n\n\tif (ret)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int serdes_am654_power_on(struct phy *x)\n{\n\tstruct serdes_am654 *phy = phy_get_drvdata(x);\n\tstruct device *dev = phy->dev;\n\tint ret;\n\tu32 val;\n\n\tret = serdes_am654_enable_pll(phy);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable PLL\\n\");\n\t\treturn ret;\n\t}\n\n\tret = serdes_am654_enable_txrx(phy);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable TX RX\\n\");\n\t\treturn ret;\n\t}\n\n\treturn regmap_field_read_poll_timeout(phy->fields[CMU_OK_I_0], val,\n\t\t\t\t\t      val, SLEEP_TIME, PLL_LOCK_TIME);\n}\n\nstatic int serdes_am654_power_off(struct phy *x)\n{\n\tstruct serdes_am654 *phy = phy_get_drvdata(x);\n\n\tserdes_am654_disable_txrx(phy);\n\tserdes_am654_disable_pll(phy);\n\n\treturn 0;\n}\n\n#define SERDES_AM654_CFG(offset, a, b, val) \\\n\tregmap_update_bits(phy->regmap, (offset),\\\n\t\t\t   GENMASK((a), (b)), (val) << (b))\n\nstatic int serdes_am654_usb3_init(struct serdes_am654 *phy)\n{\n\tSERDES_AM654_CFG(0x0000, 31, 24, 0x17);\n\tSERDES_AM654_CFG(0x0004, 15, 8, 0x02);\n\tSERDES_AM654_CFG(0x0004, 7, 0, 0x0e);\n\tSERDES_AM654_CFG(0x0008, 23, 16, 0x2e);\n\tSERDES_AM654_CFG(0x0008, 31, 24, 0x2e);\n\tSERDES_AM654_CFG(0x0060, 7, 0, 0x4b);\n\tSERDES_AM654_CFG(0x0060, 15, 8, 0x98);\n\tSERDES_AM654_CFG(0x0060, 23, 16, 0x60);\n\tSERDES_AM654_CFG(0x00d0, 31, 24, 0x45);\n\tSERDES_AM654_CFG(0x00e8, 15, 8, 0x0e);\n\tSERDES_AM654_CFG(0x0220, 7, 0, 0x34);\n\tSERDES_AM654_CFG(0x0220, 15, 8, 0x34);\n\tSERDES_AM654_CFG(0x0220, 31, 24, 0x37);\n\tSERDES_AM654_CFG(0x0224, 7, 0, 0x37);\n\tSERDES_AM654_CFG(0x0224, 15, 8, 0x37);\n\tSERDES_AM654_CFG(0x0228, 23, 16, 0x37);\n\tSERDES_AM654_CFG(0x0228, 31, 24, 0x37);\n\tSERDES_AM654_CFG(0x022c, 7, 0, 0x37);\n\tSERDES_AM654_CFG(0x022c, 15, 8, 0x37);\n\tSERDES_AM654_CFG(0x0230, 15, 8, 0x2a);\n\tSERDES_AM654_CFG(0x0230, 23, 16, 0x2a);\n\tSERDES_AM654_CFG(0x0240, 23, 16, 0x10);\n\tSERDES_AM654_CFG(0x0240, 31, 24, 0x34);\n\tSERDES_AM654_CFG(0x0244, 7, 0, 0x40);\n\tSERDES_AM654_CFG(0x0244, 23, 16, 0x34);\n\tSERDES_AM654_CFG(0x0248, 15, 8, 0x0d);\n\tSERDES_AM654_CFG(0x0258, 15, 8, 0x16);\n\tSERDES_AM654_CFG(0x0258, 23, 16, 0x84);\n\tSERDES_AM654_CFG(0x0258, 31, 24, 0xf2);\n\tSERDES_AM654_CFG(0x025c, 7, 0, 0x21);\n\tSERDES_AM654_CFG(0x0260, 7, 0, 0x27);\n\tSERDES_AM654_CFG(0x0260, 15, 8, 0x04);\n\tSERDES_AM654_CFG(0x0268, 15, 8, 0x04);\n\tSERDES_AM654_CFG(0x0288, 15, 8, 0x2c);\n\tSERDES_AM654_CFG(0x0330, 31, 24, 0xa0);\n\tSERDES_AM654_CFG(0x0338, 23, 16, 0x03);\n\tSERDES_AM654_CFG(0x0338, 31, 24, 0x00);\n\tSERDES_AM654_CFG(0x033c, 7, 0, 0x00);\n\tSERDES_AM654_CFG(0x0344, 31, 24, 0x18);\n\tSERDES_AM654_CFG(0x034c, 7, 0, 0x18);\n\tSERDES_AM654_CFG(0x039c, 23, 16, 0x3b);\n\tSERDES_AM654_CFG(0x0a04, 7, 0, 0x03);\n\tSERDES_AM654_CFG(0x0a14, 31, 24, 0x3c);\n\tSERDES_AM654_CFG(0x0a18, 15, 8, 0x3c);\n\tSERDES_AM654_CFG(0x0a38, 7, 0, 0x3e);\n\tSERDES_AM654_CFG(0x0a38, 15, 8, 0x3e);\n\tSERDES_AM654_CFG(0x0ae0, 7, 0, 0x07);\n\tSERDES_AM654_CFG(0x0b6c, 23, 16, 0xcd);\n\tSERDES_AM654_CFG(0x0b6c, 31, 24, 0x04);\n\tSERDES_AM654_CFG(0x0b98, 23, 16, 0x03);\n\tSERDES_AM654_CFG(0x1400, 7, 0, 0x3f);\n\tSERDES_AM654_CFG(0x1404, 23, 16, 0x6f);\n\tSERDES_AM654_CFG(0x1404, 31, 24, 0x6f);\n\tSERDES_AM654_CFG(0x140c, 7, 0, 0x6f);\n\tSERDES_AM654_CFG(0x140c, 15, 8, 0x6f);\n\tSERDES_AM654_CFG(0x1410, 15, 8, 0x27);\n\tSERDES_AM654_CFG(0x1414, 7, 0, 0x0c);\n\tSERDES_AM654_CFG(0x1414, 23, 16, 0x07);\n\tSERDES_AM654_CFG(0x1418, 23, 16, 0x40);\n\tSERDES_AM654_CFG(0x141c, 7, 0, 0x00);\n\tSERDES_AM654_CFG(0x141c, 15, 8, 0x1f);\n\tSERDES_AM654_CFG(0x1428, 31, 24, 0x08);\n\tSERDES_AM654_CFG(0x1434, 31, 24, 0x00);\n\tSERDES_AM654_CFG(0x1444, 7, 0, 0x94);\n\tSERDES_AM654_CFG(0x1460, 31, 24, 0x7f);\n\tSERDES_AM654_CFG(0x1464, 7, 0, 0x43);\n\tSERDES_AM654_CFG(0x1464, 23, 16, 0x6f);\n\tSERDES_AM654_CFG(0x1464, 31, 24, 0x43);\n\tSERDES_AM654_CFG(0x1484, 23, 16, 0x8f);\n\tSERDES_AM654_CFG(0x1498, 7, 0, 0x4f);\n\tSERDES_AM654_CFG(0x1498, 23, 16, 0x4f);\n\tSERDES_AM654_CFG(0x007c, 31, 24, 0x0d);\n\tSERDES_AM654_CFG(0x0b90, 15, 8, 0x0f);\n\n\treturn 0;\n}\n\nstatic int serdes_am654_pcie_init(struct serdes_am654 *phy)\n{\n\tint ret = 0;\n\n\tret |= regmap_field_write(phy->fields[CMU_PLL_CTRL], 0x2);\n\tret |= regmap_field_write(phy->fields[AHB_PMA_CM_VCO_VBIAS_VREG], 0x98);\n\tret |= regmap_field_write(phy->fields[AHB_PMA_CM_VCO_BIAS_VREG], 0x98);\n\tret |= regmap_field_write(phy->fields[AHB_PMA_CM_SR], 0x45);\n\tret |= regmap_field_write(phy->fields[AHB_SSC_GEN_Z_O_20_13], 0xe);\n\tret |= regmap_field_write(phy->fields[LANE_PLL_CTRL_RXEQ_RXIDLE], 0x5);\n\tret |= regmap_field_write(phy->fields[AHB_PMA_LN_AGC_THSEL_VREGH], 0x83);\n\tret |= regmap_field_write(phy->fields[AHB_PMA_LN_GEN3_AGC_SD_THSEL], 0x83);\n\tret |= regmap_field_write(phy->fields[AHB_PMA_LN_RX_SELR_GEN3],\t0x81);\n\tret |= regmap_field_write(phy->fields[AHB_PMA_LN_TX_DRV], 0x3b);\n\tret |= regmap_field_write(phy->fields[P2S_RBUF_PTR_DIFF], 0x3);\n\tret |= regmap_field_write(phy->fields[CONFIG_VERSION], VERSION_VAL);\n\tret |= regmap_field_write(phy->fields[COMRXEQ_MS_INIT_CTRL_7_0], 0xf);\n\tret |= regmap_field_write(phy->fields[COMRXEQ_HS_INIT_CAL_7_0], 0x4f);\n\tret |= regmap_field_write(phy->fields[COMRXEQ_MS_RECAL_CTRL_7_0], 0xf);\n\tret |= regmap_field_write(phy->fields[COMRXEQ_HS_RECAL_CTRL_7_0], 0x4f);\n\tret |= regmap_field_write(phy->fields[COMRXEQ_CSR_ATT_CONFIG], 0x7);\n\tret |= regmap_field_write(phy->fields[COMRXEQ_CSR_EBSTADAPT_WIN_LEN], 0x7f);\n\tret |= regmap_field_write(phy->fields[COMRXEQ_CTRL_3_4], 0xf);\n\tret |= regmap_field_write(phy->fields[COMRXEQ_CTRL_14_15_16], 0x9a);\n\tret |= regmap_field_write(phy->fields[COMRXEQ_CSR_DLEV_ERR_THRESH], 0x32);\n\tret |= regmap_field_write(phy->fields[COMRXEQ_CTRL_25], 0x80);\n\tret |= regmap_field_write(phy->fields[CSR_RXEQ_RATE_CHANGE_CAL_RUN_RATE2_O], 0xf);\n\tret |= regmap_field_write(phy->fields[COMRXEQ_HS_RCHANGE_CTRL_7_0], 0x4f);\n\tret |= regmap_field_write(phy->fields[CMU_MASTER_CDN], 0x1);\n\tret |= regmap_field_write(phy->fields[L1_MASTER_CDN], 0x2);\n\n\tif (ret)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int serdes_am654_init(struct phy *x)\n{\n\tstruct serdes_am654 *phy = phy_get_drvdata(x);\n\n\tswitch (phy->type) {\n\tcase PHY_TYPE_PCIE:\n\t\treturn serdes_am654_pcie_init(phy);\n\tcase PHY_TYPE_USB3:\n\t\treturn serdes_am654_usb3_init(phy);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int serdes_am654_reset(struct phy *x)\n{\n\tstruct serdes_am654 *phy = phy_get_drvdata(x);\n\tint ret = 0;\n\n\tserdes_am654_disable_pll(phy);\n\tserdes_am654_disable_txrx(phy);\n\n\tret |= regmap_field_write(phy->fields[POR_EN], 0x1);\n\n\tmdelay(1);\n\n\tret |= regmap_field_write(phy->fields[POR_EN], 0x0);\n\n\tif (ret)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void serdes_am654_release(struct phy *x)\n{\n\tstruct serdes_am654 *phy = phy_get_drvdata(x);\n\n\tphy->type = PHY_NONE;\n\tphy->busy = false;\n\tmux_control_deselect(phy->control);\n}\n\nstatic struct phy *serdes_am654_xlate(struct device *dev,\n\t\t\t\t      struct of_phandle_args *args)\n{\n\tstruct serdes_am654 *am654_phy;\n\tstruct phy *phy;\n\tint ret;\n\n\tphy = of_phy_simple_xlate(dev, args);\n\tif (IS_ERR(phy))\n\t\treturn phy;\n\n\tam654_phy = phy_get_drvdata(phy);\n\tif (am654_phy->busy)\n\t\treturn ERR_PTR(-EBUSY);\n\n\tret = mux_control_select(am654_phy->control, args->args[1]);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to select SERDES Lane Function\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tam654_phy->busy = true;\n\tam654_phy->type = args->args[0];\n\n\treturn phy;\n}\n\nstatic const struct phy_ops ops = {\n\t.reset\t\t= serdes_am654_reset,\n\t.init\t\t= serdes_am654_init,\n\t.power_on\t= serdes_am654_power_on,\n\t.power_off\t= serdes_am654_power_off,\n\t.release\t= serdes_am654_release,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#define SERDES_NUM_MUX_COMBINATIONS 16\n\n#define LICLK 0\n#define EXT_REFCLK 1\n#define RICLK 2\n\nstatic const int\nserdes_am654_mux_table[SERDES_NUM_MUX_COMBINATIONS][SERDES_NUM_CLOCKS] = {\n\t \n\t  \n\t{ EXT_REFCLK, EXT_REFCLK, EXT_REFCLK },\t \n\t{ RICLK, EXT_REFCLK, EXT_REFCLK },\t \n\t{ EXT_REFCLK, RICLK, LICLK },\t\t \n\t{ RICLK, RICLK, EXT_REFCLK },\t\t \n\t{ LICLK, EXT_REFCLK, EXT_REFCLK },\t \n\t{ EXT_REFCLK, EXT_REFCLK, EXT_REFCLK },\t \n\t{ LICLK, RICLK, LICLK },\t\t \n\t{ EXT_REFCLK, RICLK, LICLK },\t\t \n\t{ EXT_REFCLK, EXT_REFCLK, LICLK },\t \n\t{ RICLK, EXT_REFCLK, LICLK },\t\t \n\t{ EXT_REFCLK, RICLK, EXT_REFCLK },\t \n\t{ RICLK, RICLK, EXT_REFCLK },\t\t \n\t{ LICLK, EXT_REFCLK, LICLK },\t\t \n\t{ EXT_REFCLK, EXT_REFCLK, LICLK },\t \n\t{ LICLK, RICLK, EXT_REFCLK },\t\t \n\t{ EXT_REFCLK, RICLK, EXT_REFCLK },\t \n};\n\nstatic u8 serdes_am654_clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct serdes_am654_clk_mux *mux = to_serdes_am654_clk_mux(hw);\n\tstruct regmap *regmap = mux->regmap;\n\tunsigned int reg = mux->reg;\n\tunsigned int val;\n\n\tregmap_read(regmap, reg, &val);\n\tval &= AM654_SERDES_CTRL_CLKSEL_MASK;\n\tval >>= AM654_SERDES_CTRL_CLKSEL_SHIFT;\n\n\treturn serdes_am654_mux_table[val][mux->clk_id];\n}\n\nstatic int serdes_am654_clk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct serdes_am654_clk_mux *mux = to_serdes_am654_clk_mux(hw);\n\tstruct regmap *regmap = mux->regmap;\n\tconst char *name = clk_hw_get_name(hw);\n\tunsigned int reg = mux->reg;\n\tint clk_id = mux->clk_id;\n\tint parents[SERDES_NUM_CLOCKS];\n\tconst int *p;\n\tu32 val;\n\tint found, i;\n\tint ret;\n\n\t \n\tregmap_read(regmap, reg, &val);\n\tval &= AM654_SERDES_CTRL_CLKSEL_MASK;\n\tval >>= AM654_SERDES_CTRL_CLKSEL_SHIFT;\n\n\tfor (i = 0; i < SERDES_NUM_CLOCKS; i++)\n\t\tparents[i] = serdes_am654_mux_table[val][i];\n\n\t \n\tparents[clk_id] = index;\n\n\t \n\tfor (val = 0; val < SERDES_NUM_MUX_COMBINATIONS; val++) {\n\t\tp = serdes_am654_mux_table[val];\n\t\tfound = 1;\n\t\tfor (i = 0; i < SERDES_NUM_CLOCKS; i++) {\n\t\t\tif (parents[i] != p[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\tif (!found) {\n\t\t \n\t\tWARN(1, \"Failed to find the parent of %s clock\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\n\tval <<= AM654_SERDES_CTRL_CLKSEL_SHIFT;\n\tret = regmap_update_bits(regmap, reg, AM654_SERDES_CTRL_CLKSEL_MASK,\n\t\t\t\t val);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops serdes_am654_clk_mux_ops = {\n\t.determine_rate = __clk_mux_determine_rate,\n\t.set_parent = serdes_am654_clk_mux_set_parent,\n\t.get_parent = serdes_am654_clk_mux_get_parent,\n};\n\nstatic int serdes_am654_clk_register(struct serdes_am654 *am654_phy,\n\t\t\t\t     const char *clock_name, int clock_num)\n{\n\tstruct device_node *node = am654_phy->of_node;\n\tstruct device *dev = am654_phy->dev;\n\tstruct serdes_am654_clk_mux *mux;\n\tstruct device_node *regmap_node;\n\tconst char **parent_names;\n\tstruct clk_init_data *init;\n\tunsigned int num_parents;\n\tstruct regmap *regmap;\n\tconst __be32 *addr;\n\tunsigned int reg;\n\tstruct clk *clk;\n\tint ret = 0;\n\n\tmux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn -ENOMEM;\n\n\tinit = &mux->clk_data;\n\n\tregmap_node = of_parse_phandle(node, \"ti,serdes-clk\", 0);\n\tif (!regmap_node) {\n\t\tdev_err(dev, \"Fail to get serdes-clk node\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_put_node;\n\t}\n\n\tregmap = syscon_node_to_regmap(regmap_node->parent);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"Fail to get Syscon regmap\\n\");\n\t\tret = PTR_ERR(regmap);\n\t\tgoto out_put_node;\n\t}\n\n\tnum_parents = of_clk_get_parent_count(node);\n\tif (num_parents < 2) {\n\t\tdev_err(dev, \"SERDES clock must have parents\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_put_node;\n\t}\n\n\tparent_names = devm_kzalloc(dev, (sizeof(char *) * num_parents),\n\t\t\t\t    GFP_KERNEL);\n\tif (!parent_names) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_node;\n\t}\n\n\tof_clk_parent_fill(node, parent_names, num_parents);\n\n\taddr = of_get_address(regmap_node, 0, NULL, NULL);\n\tif (!addr) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_node;\n\t}\n\n\treg = be32_to_cpu(*addr);\n\n\tinit->ops = &serdes_am654_clk_mux_ops;\n\tinit->flags = CLK_SET_RATE_NO_REPARENT;\n\tinit->parent_names = parent_names;\n\tinit->num_parents = num_parents;\n\tinit->name = clock_name;\n\n\tmux->regmap = regmap;\n\tmux->reg = reg;\n\tmux->clk_id = clock_num;\n\tmux->hw.init = init;\n\n\tclk = devm_clk_register(dev, &mux->hw);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto out_put_node;\n\t}\n\n\tam654_phy->clks[clock_num] = clk;\n\nout_put_node:\n\tof_node_put(regmap_node);\n\treturn ret;\n}\n\nstatic const struct of_device_id serdes_am654_id_table[] = {\n\t{\n\t\t.compatible = \"ti,phy-am654-serdes\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, serdes_am654_id_table);\n\nstatic int serdes_am654_regfield_init(struct serdes_am654 *am654_phy)\n{\n\tstruct regmap *regmap = am654_phy->regmap;\n\tstruct device *dev = am654_phy->dev;\n\tint i;\n\n\tfor (i = 0; i < MAX_FIELDS; i++) {\n\t\tam654_phy->fields[i] = devm_regmap_field_alloc(dev,\n\t\t\t\t\t\t\t       regmap,\n\t\t\t\t\t\t\t       serdes_am654_reg_fields[i]);\n\t\tif (IS_ERR(am654_phy->fields[i])) {\n\t\t\tdev_err(dev, \"Unable to allocate regmap field %d\\n\", i);\n\t\t\treturn PTR_ERR(am654_phy->fields[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int serdes_am654_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct clk_onecell_data *clk_data;\n\tstruct serdes_am654 *am654_phy;\n\tstruct mux_control *control;\n\tconst char *clock_name;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tstruct phy *phy;\n\tint ret;\n\tint i;\n\n\tam654_phy = devm_kzalloc(dev, sizeof(*am654_phy), GFP_KERNEL);\n\tif (!am654_phy)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(dev, base, &serdes_am654_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"Failed to initialize regmap\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tcontrol = devm_mux_control_get(dev, NULL);\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tam654_phy->dev = dev;\n\tam654_phy->of_node = node;\n\tam654_phy->regmap = regmap;\n\tam654_phy->control = control;\n\tam654_phy->type = PHY_NONE;\n\n\tret = serdes_am654_regfield_init(am654_phy);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize regfields\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, am654_phy);\n\n\tfor (i = 0; i < SERDES_NUM_CLOCKS; i++) {\n\t\tret = of_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t    i, &clock_name);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to get clock name\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = serdes_am654_clk_register(am654_phy, clock_name, i);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to initialize clock %s\\n\",\n\t\t\t\tclock_name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tclk_data = &am654_phy->clk_data;\n\tclk_data->clks = am654_phy->clks;\n\tclk_data->clk_num = SERDES_NUM_CLOCKS;\n\tret = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(dev);\n\n\tphy = devm_phy_create(dev, NULL, &ops);\n\tif (IS_ERR(phy)) {\n\t\tret = PTR_ERR(phy);\n\t\tgoto clk_err;\n\t}\n\n\tphy_set_drvdata(phy, am654_phy);\n\tphy_provider = devm_of_phy_provider_register(dev, serdes_am654_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tret = PTR_ERR(phy_provider);\n\t\tgoto clk_err;\n\t}\n\n\treturn 0;\n\nclk_err:\n\tof_clk_del_provider(node);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void serdes_am654_remove(struct platform_device *pdev)\n{\n\tstruct serdes_am654 *am654_phy = platform_get_drvdata(pdev);\n\tstruct device_node *node = am654_phy->of_node;\n\n\tpm_runtime_disable(&pdev->dev);\n\tof_clk_del_provider(node);\n}\n\nstatic struct platform_driver serdes_am654_driver = {\n\t.probe\t\t= serdes_am654_probe,\n\t.remove_new\t= serdes_am654_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"phy-am654\",\n\t\t.of_match_table = serdes_am654_id_table,\n\t},\n};\nmodule_platform_driver(serdes_am654_driver);\n\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\nMODULE_DESCRIPTION(\"TI AM654x SERDES driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}