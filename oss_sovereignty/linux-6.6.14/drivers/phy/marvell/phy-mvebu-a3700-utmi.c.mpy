{
  "module_name": "phy-mvebu-a3700-utmi.c",
  "hash_id": "34c8a15afce94ceedd333723a9fd1fa42368281fa8ed5c196e4c7f6e02ece0d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/marvell/phy-mvebu-a3700-utmi.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define USB2_PHY_PLL_CTRL_REG0\t\t\t0x0\n#define   PLL_REF_DIV_OFF\t\t\t0\n#define   PLL_REF_DIV_MASK\t\t\tGENMASK(6, 0)\n#define   PLL_REF_DIV_5\t\t\t\t5\n#define   PLL_FB_DIV_OFF\t\t\t16\n#define   PLL_FB_DIV_MASK\t\t\tGENMASK(24, 16)\n#define   PLL_FB_DIV_96\t\t\t\t96\n#define   PLL_SEL_LPFR_OFF\t\t\t28\n#define   PLL_SEL_LPFR_MASK\t\t\tGENMASK(29, 28)\n#define   PLL_READY\t\t\t\tBIT(31)\n#define USB2_PHY_CAL_CTRL\t\t\t0x8\n#define   PHY_PLLCAL_DONE\t\t\tBIT(31)\n#define   PHY_IMPCAL_DONE\t\t\tBIT(23)\n#define USB2_RX_CHAN_CTRL1\t\t\t0x18\n#define   USB2PHY_SQCAL_DONE\t\t\tBIT(31)\n#define USB2_PHY_OTG_CTRL\t\t\t0x34\n#define   PHY_PU_OTG\t\t\t\tBIT(4)\n#define USB2_PHY_CHRGR_DETECT\t\t\t0x38\n#define   PHY_CDP_EN\t\t\t\tBIT(2)\n#define   PHY_DCP_EN\t\t\t\tBIT(3)\n#define   PHY_PD_EN\t\t\t\tBIT(4)\n#define   PHY_PU_CHRG_DTC\t\t\tBIT(5)\n#define   PHY_CDP_DM_AUTO\t\t\tBIT(7)\n#define   PHY_ENSWITCH_DP\t\t\tBIT(12)\n#define   PHY_ENSWITCH_DM\t\t\tBIT(13)\n\n \n#define USB2_PHY_CTRL(usb32)\t\t\t(usb32 ? 0x20 : 0x4)\n#define   RB_USB2PHY_PU\t\t\t\tBIT(0)\n#define   USB2_DP_PULLDN_DEV_MODE\t\tBIT(5)\n#define   USB2_DM_PULLDN_DEV_MODE\t\tBIT(6)\n#define   RB_USB2PHY_SUSPM(usb32)\t\t(usb32 ? BIT(14) : BIT(7))\n\n#define PLL_LOCK_DELAY_US\t\t\t10000\n#define PLL_LOCK_TIMEOUT_US\t\t\t1000000\n\n \nstruct mvebu_a3700_utmi_caps {\n\tint usb32;\n\tconst struct phy_ops *ops;\n};\n\n \nstruct mvebu_a3700_utmi {\n\tvoid __iomem *regs;\n\tstruct regmap *usb_misc;\n\tconst struct mvebu_a3700_utmi_caps *caps;\n\tstruct phy *phy;\n};\n\nstatic int mvebu_a3700_utmi_phy_power_on(struct phy *phy)\n{\n\tstruct mvebu_a3700_utmi *utmi = phy_get_drvdata(phy);\n\tstruct device *dev = &phy->dev;\n\tint usb32 = utmi->caps->usb32;\n\tint ret = 0;\n\tu32 reg;\n\n\t \n\treg = readl(utmi->regs + USB2_PHY_PLL_CTRL_REG0);\n\treg &= ~(PLL_REF_DIV_MASK | PLL_FB_DIV_MASK | PLL_SEL_LPFR_MASK);\n\treg |= (PLL_REF_DIV_5 << PLL_REF_DIV_OFF) |\n\t       (PLL_FB_DIV_96 << PLL_FB_DIV_OFF);\n\twritel(reg, utmi->regs + USB2_PHY_PLL_CTRL_REG0);\n\n\t \n\tregmap_update_bits(utmi->usb_misc, USB2_PHY_CTRL(usb32),\n\t\t\t   RB_USB2PHY_SUSPM(usb32) | RB_USB2PHY_PU,\n\t\t\t   RB_USB2PHY_SUSPM(usb32) | RB_USB2PHY_PU);\n\n\tif (usb32) {\n\t\t \n\t\treg = readl(utmi->regs + USB2_PHY_OTG_CTRL);\n\t\treg |= PHY_PU_OTG;\n\t\twritel(reg, utmi->regs + USB2_PHY_OTG_CTRL);\n\n\t\t \n\t\treg = readl(utmi->regs + USB2_PHY_CHRGR_DETECT);\n\t\treg &= ~(PHY_CDP_EN | PHY_DCP_EN | PHY_PD_EN | PHY_PU_CHRG_DTC |\n\t\t\t PHY_CDP_DM_AUTO | PHY_ENSWITCH_DP | PHY_ENSWITCH_DM);\n\t\twritel(reg, utmi->regs + USB2_PHY_CHRGR_DETECT);\n\n\t\t \n\t\tregmap_update_bits(utmi->usb_misc, USB2_PHY_CTRL(usb32),\n\t\t\t\t   USB2_DP_PULLDN_DEV_MODE |\n\t\t\t\t   USB2_DM_PULLDN_DEV_MODE, 0);\n\t}\n\n\t \n\tret = readl_poll_timeout(utmi->regs + USB2_PHY_CAL_CTRL, reg,\n\t\t\t\t reg & PHY_PLLCAL_DONE,\n\t\t\t\t PLL_LOCK_DELAY_US, PLL_LOCK_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to end USB2 PLL calibration\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = readl_poll_timeout(utmi->regs + USB2_PHY_CAL_CTRL, reg,\n\t\t\t\t reg & PHY_IMPCAL_DONE,\n\t\t\t\t PLL_LOCK_DELAY_US, PLL_LOCK_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to end USB2 impedance calibration\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = readl_poll_timeout(utmi->regs + USB2_RX_CHAN_CTRL1, reg,\n\t\t\t\t reg & USB2PHY_SQCAL_DONE,\n\t\t\t\t PLL_LOCK_DELAY_US, PLL_LOCK_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to end USB2 unknown calibration\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = readl_poll_timeout(utmi->regs + USB2_PHY_PLL_CTRL_REG0, reg,\n\t\t\t\t reg & PLL_READY,\n\t\t\t\t PLL_LOCK_DELAY_US, PLL_LOCK_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to lock USB2 PLL\\n\");\n\n\treturn ret;\n}\n\nstatic int mvebu_a3700_utmi_phy_power_off(struct phy *phy)\n{\n\tstruct mvebu_a3700_utmi *utmi = phy_get_drvdata(phy);\n\tint usb32 = utmi->caps->usb32;\n\tu32 reg;\n\n\t \n\treg = readl(utmi->regs + USB2_PHY_CTRL(usb32));\n\treg &= ~(RB_USB2PHY_PU | RB_USB2PHY_SUSPM(usb32));\n\twritel(reg, utmi->regs + USB2_PHY_CTRL(usb32));\n\n\t \n\tif (usb32) {\n\t\treg = readl(utmi->regs + USB2_PHY_OTG_CTRL);\n\t\treg &= ~PHY_PU_OTG;\n\t\twritel(reg, utmi->regs + USB2_PHY_OTG_CTRL);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct phy_ops mvebu_a3700_utmi_phy_ops = {\n\t.power_on = mvebu_a3700_utmi_phy_power_on,\n\t.power_off = mvebu_a3700_utmi_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct mvebu_a3700_utmi_caps mvebu_a3700_utmi_otg_phy_caps = {\n\t.usb32 = true,\n\t.ops = &mvebu_a3700_utmi_phy_ops,\n};\n\nstatic const struct mvebu_a3700_utmi_caps mvebu_a3700_utmi_host_phy_caps = {\n\t.usb32 = false,\n\t.ops = &mvebu_a3700_utmi_phy_ops,\n};\n\nstatic const struct of_device_id mvebu_a3700_utmi_of_match[] = {\n\t{\n\t\t.compatible = \"marvell,a3700-utmi-otg-phy\",\n\t\t.data = &mvebu_a3700_utmi_otg_phy_caps,\n\t},\n\t{\n\t\t.compatible = \"marvell,a3700-utmi-host-phy\",\n\t\t.data = &mvebu_a3700_utmi_host_phy_caps,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mvebu_a3700_utmi_of_match);\n\nstatic int mvebu_a3700_utmi_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mvebu_a3700_utmi *utmi;\n\tstruct phy_provider *provider;\n\n\tutmi = devm_kzalloc(dev, sizeof(*utmi), GFP_KERNEL);\n\tif (!utmi)\n\t\treturn -ENOMEM;\n\n\t \n\tutmi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(utmi->regs))\n\t\treturn PTR_ERR(utmi->regs);\n\n\t \n\tutmi->usb_misc = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t \"marvell,usb-misc-reg\");\n\tif (IS_ERR(utmi->usb_misc)) {\n\t\tdev_err(dev,\n\t\t\t\"Missing USB misc purpose system controller\\n\");\n\t\treturn PTR_ERR(utmi->usb_misc);\n\t}\n\n\t \n\tutmi->caps = of_device_get_match_data(dev);\n\n\t \n\tutmi->phy = devm_phy_create(dev, NULL, utmi->caps->ops);\n\tif (IS_ERR(utmi->phy)) {\n\t\tdev_err(dev, \"Failed to create the UTMI PHY\\n\");\n\t\treturn PTR_ERR(utmi->phy);\n\t}\n\n\tphy_set_drvdata(utmi->phy, utmi);\n\n\t \n\tutmi->caps->ops->power_off(utmi->phy);\n\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic struct platform_driver mvebu_a3700_utmi_driver = {\n\t.probe\t= mvebu_a3700_utmi_phy_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"mvebu-a3700-utmi-phy\",\n\t\t.of_match_table\t= mvebu_a3700_utmi_of_match,\n\t },\n};\nmodule_platform_driver(mvebu_a3700_utmi_driver);\n\nMODULE_AUTHOR(\"Igal Liberman <igall@marvell.com>\");\nMODULE_AUTHOR(\"Miquel Raynal <miquel.raynal@bootlin.com>\");\nMODULE_DESCRIPTION(\"Marvell EBU A3700 UTMI PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}