{
  "module_name": "phy-pxa-28nm-hsic.c",
  "hash_id": "22414dea54f4a4eda0cb666925f0f6abb1810af21f17ba9ad6a108f2be6b2e0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/marvell/phy-pxa-28nm-hsic.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n\n#define PHY_28NM_HSIC_CTRL\t\t\t0x08\n#define PHY_28NM_HSIC_IMPCAL_CAL\t\t0x18\n#define PHY_28NM_HSIC_PLL_CTRL01\t\t0x1c\n#define PHY_28NM_HSIC_PLL_CTRL2\t\t\t0x20\n#define PHY_28NM_HSIC_INT\t\t\t0x28\n\n#define PHY_28NM_HSIC_PLL_SELLPFR_SHIFT\t\t26\n#define PHY_28NM_HSIC_PLL_FBDIV_SHIFT\t\t0\n#define PHY_28NM_HSIC_PLL_REFDIV_SHIFT\t\t9\n\n#define PHY_28NM_HSIC_S2H_PU_PLL\t\tBIT(10)\n#define PHY_28NM_HSIC_H2S_PLL_LOCK\t\tBIT(15)\n#define PHY_28NM_HSIC_S2H_HSIC_EN\t\tBIT(7)\n#define S2H_DRV_SE0_4RESUME\t\t\tBIT(14)\n#define PHY_28NM_HSIC_H2S_IMPCAL_DONE\t\tBIT(27)\n\n#define PHY_28NM_HSIC_CONNECT_INT\t\tBIT(1)\n#define PHY_28NM_HSIC_HS_READY_INT\t\tBIT(2)\n\nstruct mv_hsic_phy {\n\tstruct phy\t\t*phy;\n\tstruct platform_device\t*pdev;\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n};\n\nstatic int wait_for_reg(void __iomem *reg, u32 mask, u32 ms)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(reg, val, ((val & mask) == mask),\n\t\t\t\t  1000, 1000 * ms);\n}\n\nstatic int mv_hsic_phy_init(struct phy *phy)\n{\n\tstruct mv_hsic_phy *mv_phy = phy_get_drvdata(phy);\n\tstruct platform_device *pdev = mv_phy->pdev;\n\tvoid __iomem *base = mv_phy->base;\n\tint ret;\n\n\tclk_prepare_enable(mv_phy->clk);\n\n\t \n\twritel(0x1 << PHY_28NM_HSIC_PLL_SELLPFR_SHIFT |\n\t\t0xf0 << PHY_28NM_HSIC_PLL_FBDIV_SHIFT |\n\t\t0xd << PHY_28NM_HSIC_PLL_REFDIV_SHIFT,\n\t\tbase + PHY_28NM_HSIC_PLL_CTRL01);\n\n\t \n\twritel(readl(base + PHY_28NM_HSIC_PLL_CTRL2) |\n\t\tPHY_28NM_HSIC_S2H_PU_PLL,\n\t\tbase + PHY_28NM_HSIC_PLL_CTRL2);\n\n\t \n\tret = wait_for_reg(base + PHY_28NM_HSIC_PLL_CTRL2,\n\t\t\t   PHY_28NM_HSIC_H2S_PLL_LOCK, 100);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"HSIC PHY PLL not locked after 100mS.\");\n\t\tclk_disable_unprepare(mv_phy->clk);\n\t}\n\n\treturn ret;\n}\n\nstatic int mv_hsic_phy_power_on(struct phy *phy)\n{\n\tstruct mv_hsic_phy *mv_phy = phy_get_drvdata(phy);\n\tstruct platform_device *pdev = mv_phy->pdev;\n\tvoid __iomem *base = mv_phy->base;\n\tu32 reg;\n\tint ret;\n\n\treg = readl(base + PHY_28NM_HSIC_CTRL);\n\t \n\treg &= ~S2H_DRV_SE0_4RESUME;\n\treg |= PHY_28NM_HSIC_S2H_HSIC_EN;\t \n\twritel(reg, base + PHY_28NM_HSIC_CTRL);\n\n\t \n\n\t \n\tret = wait_for_reg(base + PHY_28NM_HSIC_IMPCAL_CAL,\n\t\t\t   PHY_28NM_HSIC_H2S_IMPCAL_DONE, 100);\n\tif (ret) {\n\t\tdev_warn(&pdev->dev, \"HSIC PHY READY not set after 100mS.\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = wait_for_reg(base + PHY_28NM_HSIC_INT,\n\t\t\t   PHY_28NM_HSIC_CONNECT_INT, 200);\n\tif (ret)\n\t\tdev_warn(&pdev->dev, \"HSIC wait for connect interrupt timeout.\");\n\n\treturn ret;\n}\n\nstatic int mv_hsic_phy_power_off(struct phy *phy)\n{\n\tstruct mv_hsic_phy *mv_phy = phy_get_drvdata(phy);\n\tvoid __iomem *base = mv_phy->base;\n\n\twritel(readl(base + PHY_28NM_HSIC_CTRL) & ~PHY_28NM_HSIC_S2H_HSIC_EN,\n\t\tbase + PHY_28NM_HSIC_CTRL);\n\n\treturn 0;\n}\n\nstatic int mv_hsic_phy_exit(struct phy *phy)\n{\n\tstruct mv_hsic_phy *mv_phy = phy_get_drvdata(phy);\n\tvoid __iomem *base = mv_phy->base;\n\n\t \n\twritel(readl(base + PHY_28NM_HSIC_PLL_CTRL2) &\n\t\t~PHY_28NM_HSIC_S2H_PU_PLL,\n\t\tbase + PHY_28NM_HSIC_PLL_CTRL2);\n\n\tclk_disable_unprepare(mv_phy->clk);\n\treturn 0;\n}\n\n\nstatic const struct phy_ops hsic_ops = {\n\t.init\t\t= mv_hsic_phy_init,\n\t.power_on\t= mv_hsic_phy_power_on,\n\t.power_off\t= mv_hsic_phy_power_off,\n\t.exit\t\t= mv_hsic_phy_exit,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int mv_hsic_phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct mv_hsic_phy *mv_phy;\n\n\tmv_phy = devm_kzalloc(&pdev->dev, sizeof(*mv_phy), GFP_KERNEL);\n\tif (!mv_phy)\n\t\treturn -ENOMEM;\n\n\tmv_phy->pdev = pdev;\n\n\tmv_phy->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(mv_phy->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock.\\n\");\n\t\treturn PTR_ERR(mv_phy->clk);\n\t}\n\n\tmv_phy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mv_phy->base))\n\t\treturn PTR_ERR(mv_phy->base);\n\n\tmv_phy->phy = devm_phy_create(&pdev->dev, pdev->dev.of_node, &hsic_ops);\n\tif (IS_ERR(mv_phy->phy))\n\t\treturn PTR_ERR(mv_phy->phy);\n\n\tphy_set_drvdata(mv_phy->phy, mv_phy);\n\n\tphy_provider = devm_of_phy_provider_register(&pdev->dev, of_phy_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id mv_hsic_phy_dt_match[] = {\n\t{ .compatible = \"marvell,pxa1928-hsic-phy\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mv_hsic_phy_dt_match);\n\nstatic struct platform_driver mv_hsic_phy_driver = {\n\t.probe\t= mv_hsic_phy_probe,\n\t.driver = {\n\t\t.name   = \"mv-hsic-phy\",\n\t\t.of_match_table = mv_hsic_phy_dt_match,\n\t},\n};\nmodule_platform_driver(mv_hsic_phy_driver);\n\nMODULE_AUTHOR(\"Rob Herring <robh@kernel.org>\");\nMODULE_DESCRIPTION(\"Marvell HSIC phy driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}