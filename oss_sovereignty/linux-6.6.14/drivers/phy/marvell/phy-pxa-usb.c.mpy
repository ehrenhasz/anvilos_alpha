{
  "module_name": "phy-pxa-usb.c",
  "hash_id": "2b6c65cf46ce482fc8f46279c745b69b652769fcc65c5216397e81615e7839e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/marvell/phy-pxa-usb.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/phy/phy.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\n \n#define UTMI_REVISION\t\t0x0\n#define UTMI_CTRL\t\t0x4\n#define UTMI_PLL\t\t0x8\n#define UTMI_TX\t\t\t0xc\n#define UTMI_RX\t\t\t0x10\n#define UTMI_IVREF\t\t0x14\n#define UTMI_T0\t\t\t0x18\n#define UTMI_T1\t\t\t0x1c\n#define UTMI_T2\t\t\t0x20\n#define UTMI_T3\t\t\t0x24\n#define UTMI_T4\t\t\t0x28\n#define UTMI_T5\t\t\t0x2c\n#define UTMI_RESERVE\t\t0x30\n#define UTMI_USB_INT\t\t0x34\n#define UTMI_DBG_CTL\t\t0x38\n#define UTMI_OTG_ADDON\t\t0x3c\n\n \n#define UTMI_CTRL_USB_CLK_EN                    (1 << 31)\n \n#define UTMI_CTRL_SUSPEND_SET1                  (1 << 30)\n#define UTMI_CTRL_SUSPEND_SET2                  (1 << 29)\n#define UTMI_CTRL_RXBUF_PDWN                    (1 << 24)\n#define UTMI_CTRL_TXBUF_PDWN                    (1 << 11)\n\n#define UTMI_CTRL_INPKT_DELAY_SHIFT             30\n#define UTMI_CTRL_INPKT_DELAY_SOF_SHIFT\t\t28\n#define UTMI_CTRL_PU_REF_SHIFT\t\t\t20\n#define UTMI_CTRL_ARC_PULLDN_SHIFT              12\n#define UTMI_CTRL_PLL_PWR_UP_SHIFT              1\n#define UTMI_CTRL_PWR_UP_SHIFT                  0\n\n \n#define UTMI_PLL_PLLCALI12_SHIFT\t\t29\n#define UTMI_PLL_PLLCALI12_MASK\t\t\t(0x3 << 29)\n\n#define UTMI_PLL_PLLVDD18_SHIFT\t\t\t27\n#define UTMI_PLL_PLLVDD18_MASK\t\t\t(0x3 << 27)\n\n#define UTMI_PLL_PLLVDD12_SHIFT\t\t\t25\n#define UTMI_PLL_PLLVDD12_MASK\t\t\t(0x3 << 25)\n\n#define UTMI_PLL_CLK_BLK_EN_SHIFT               24\n#define CLK_BLK_EN                              (0x1 << 24)\n#define PLL_READY                               (0x1 << 23)\n#define KVCO_EXT                                (0x1 << 22)\n#define VCOCAL_START                            (0x1 << 21)\n\n#define UTMI_PLL_KVCO_SHIFT\t\t\t15\n#define UTMI_PLL_KVCO_MASK                      (0x7 << 15)\n\n#define UTMI_PLL_ICP_SHIFT\t\t\t12\n#define UTMI_PLL_ICP_MASK                       (0x7 << 12)\n\n#define UTMI_PLL_FBDIV_SHIFT                    4\n#define UTMI_PLL_FBDIV_MASK                     (0xFF << 4)\n\n#define UTMI_PLL_REFDIV_SHIFT                   0\n#define UTMI_PLL_REFDIV_MASK                    (0xF << 0)\n\n \n#define UTMI_TX_REG_EXT_FS_RCAL_SHIFT\t\t27\n#define UTMI_TX_REG_EXT_FS_RCAL_MASK\t\t(0xf << 27)\n\n#define UTMI_TX_REG_EXT_FS_RCAL_EN_SHIFT\t26\n#define UTMI_TX_REG_EXT_FS_RCAL_EN_MASK\t\t(0x1 << 26)\n\n#define UTMI_TX_TXVDD12_SHIFT                   22\n#define UTMI_TX_TXVDD12_MASK                    (0x3 << 22)\n\n#define UTMI_TX_CK60_PHSEL_SHIFT                17\n#define UTMI_TX_CK60_PHSEL_MASK                 (0xf << 17)\n\n#define UTMI_TX_IMPCAL_VTH_SHIFT                14\n#define UTMI_TX_IMPCAL_VTH_MASK                 (0x7 << 14)\n\n#define REG_RCAL_START                          (0x1 << 12)\n\n#define UTMI_TX_LOW_VDD_EN_SHIFT                11\n\n#define UTMI_TX_AMP_SHIFT\t\t\t0\n#define UTMI_TX_AMP_MASK\t\t\t(0x7 << 0)\n\n \n#define UTMI_REG_SQ_LENGTH_SHIFT                15\n#define UTMI_REG_SQ_LENGTH_MASK                 (0x3 << 15)\n\n#define UTMI_RX_SQ_THRESH_SHIFT                 4\n#define UTMI_RX_SQ_THRESH_MASK                  (0xf << 4)\n\n#define UTMI_OTG_ADDON_OTG_ON\t\t\t(1 << 0)\n\nenum pxa_usb_phy_version {\n\tPXA_USB_PHY_MMP2,\n\tPXA_USB_PHY_PXA910,\n\tPXA_USB_PHY_PXA168,\n};\n\nstruct pxa_usb_phy {\n\tstruct phy *phy;\n\tvoid __iomem *base;\n\tenum pxa_usb_phy_version version;\n};\n\n \n\nstatic unsigned int u2o_get(void __iomem *base, unsigned int offset)\n{\n\treturn readl_relaxed(base + offset);\n}\n\nstatic void u2o_set(void __iomem *base, unsigned int offset,\n\t\tunsigned int value)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(base + offset);\n\treg |= value;\n\twritel_relaxed(reg, base + offset);\n\treadl_relaxed(base + offset);\n}\n\nstatic void u2o_clear(void __iomem *base, unsigned int offset,\n\t\tunsigned int value)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(base + offset);\n\treg &= ~value;\n\twritel_relaxed(reg, base + offset);\n\treadl_relaxed(base + offset);\n}\n\nstatic void u2o_write(void __iomem *base, unsigned int offset,\n\t\tunsigned int value)\n{\n\twritel_relaxed(value, base + offset);\n\treadl_relaxed(base + offset);\n}\n\nstatic int pxa_usb_phy_init(struct phy *phy)\n{\n\tstruct pxa_usb_phy *pxa_usb_phy = phy_get_drvdata(phy);\n\tvoid __iomem *base = pxa_usb_phy->base;\n\tint loops;\n\n\tdev_info(&phy->dev, \"initializing Marvell PXA USB PHY\");\n\n\t \n\tif (pxa_usb_phy->version == PXA_USB_PHY_PXA910) {\n\t\tu2o_set(base, UTMI_CTRL, (1<<UTMI_CTRL_INPKT_DELAY_SOF_SHIFT)\n\t\t\t| (1<<UTMI_CTRL_PU_REF_SHIFT));\n\t}\n\n\tu2o_set(base, UTMI_CTRL, 1<<UTMI_CTRL_PLL_PWR_UP_SHIFT);\n\tu2o_set(base, UTMI_CTRL, 1<<UTMI_CTRL_PWR_UP_SHIFT);\n\n\t \n\tu2o_clear(base, UTMI_PLL, UTMI_PLL_PLLVDD18_MASK\n\t\t| UTMI_PLL_PLLVDD12_MASK | UTMI_PLL_PLLCALI12_MASK\n\t\t| UTMI_PLL_FBDIV_MASK | UTMI_PLL_REFDIV_MASK\n\t\t| UTMI_PLL_ICP_MASK | UTMI_PLL_KVCO_MASK);\n\n\tu2o_set(base, UTMI_PLL, 0xee<<UTMI_PLL_FBDIV_SHIFT\n\t\t| 0xb<<UTMI_PLL_REFDIV_SHIFT | 3<<UTMI_PLL_PLLVDD18_SHIFT\n\t\t| 3<<UTMI_PLL_PLLVDD12_SHIFT | 3<<UTMI_PLL_PLLCALI12_SHIFT\n\t\t| 1<<UTMI_PLL_ICP_SHIFT | 3<<UTMI_PLL_KVCO_SHIFT);\n\n\t \n\tu2o_clear(base, UTMI_TX, UTMI_TX_REG_EXT_FS_RCAL_EN_MASK\n\t\t| UTMI_TX_TXVDD12_MASK | UTMI_TX_CK60_PHSEL_MASK\n\t\t| UTMI_TX_IMPCAL_VTH_MASK | UTMI_TX_REG_EXT_FS_RCAL_MASK\n\t\t| UTMI_TX_AMP_MASK);\n\tu2o_set(base, UTMI_TX, 3<<UTMI_TX_TXVDD12_SHIFT\n\t\t| 4<<UTMI_TX_CK60_PHSEL_SHIFT | 4<<UTMI_TX_IMPCAL_VTH_SHIFT\n\t\t| 8<<UTMI_TX_REG_EXT_FS_RCAL_SHIFT | 3<<UTMI_TX_AMP_SHIFT);\n\n\t \n\tu2o_clear(base, UTMI_RX, UTMI_RX_SQ_THRESH_MASK\n\t\t| UTMI_REG_SQ_LENGTH_MASK);\n\tu2o_set(base, UTMI_RX, 7<<UTMI_RX_SQ_THRESH_SHIFT\n\t\t| 2<<UTMI_REG_SQ_LENGTH_SHIFT);\n\n\t \n\tif (pxa_usb_phy->version == PXA_USB_PHY_PXA168) {\n\t\t \n\t\tu2o_write(base, UTMI_IVREF, 0x4bf);\n\t}\n\n\t \n\tudelay(200);\n\tu2o_set(base, UTMI_PLL, VCOCAL_START);\n\tudelay(40);\n\tu2o_clear(base, UTMI_PLL, VCOCAL_START);\n\n\t \n\tudelay(400);\n\tu2o_set(base, UTMI_TX, REG_RCAL_START);\n\tudelay(40);\n\tu2o_clear(base, UTMI_TX, REG_RCAL_START);\n\tudelay(400);\n\n\t \n\tloops = 0;\n\twhile ((u2o_get(base, UTMI_PLL) & PLL_READY) == 0) {\n\t\tmdelay(1);\n\t\tloops++;\n\t\tif (loops > 100) {\n\t\t\tdev_warn(&phy->dev, \"calibrate timeout, UTMI_PLL %x\\n\",\n\t\t\t\t\t\tu2o_get(base, UTMI_PLL));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pxa_usb_phy->version == PXA_USB_PHY_PXA168) {\n\t\tu2o_set(base, UTMI_RESERVE, 1 << 5);\n\t\t \n\t\tu2o_write(base, UTMI_OTG_ADDON, 1);\n\t}\n\n\treturn 0;\n\n}\n\nstatic int pxa_usb_phy_exit(struct phy *phy)\n{\n\tstruct pxa_usb_phy *pxa_usb_phy = phy_get_drvdata(phy);\n\tvoid __iomem *base = pxa_usb_phy->base;\n\n\tdev_info(&phy->dev, \"deinitializing Marvell PXA USB PHY\");\n\n\tif (pxa_usb_phy->version == PXA_USB_PHY_PXA168)\n\t\tu2o_clear(base, UTMI_OTG_ADDON, UTMI_OTG_ADDON_OTG_ON);\n\n\tu2o_clear(base, UTMI_CTRL, UTMI_CTRL_RXBUF_PDWN);\n\tu2o_clear(base, UTMI_CTRL, UTMI_CTRL_TXBUF_PDWN);\n\tu2o_clear(base, UTMI_CTRL, UTMI_CTRL_USB_CLK_EN);\n\tu2o_clear(base, UTMI_CTRL, 1<<UTMI_CTRL_PWR_UP_SHIFT);\n\tu2o_clear(base, UTMI_CTRL, 1<<UTMI_CTRL_PLL_PWR_UP_SHIFT);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops pxa_usb_phy_ops = {\n\t.init\t= pxa_usb_phy_init,\n\t.exit\t= pxa_usb_phy_exit,\n\t.owner\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id pxa_usb_phy_of_match[] = {\n\t{\n\t\t.compatible = \"marvell,mmp2-usb-phy\",\n\t\t.data = (void *)PXA_USB_PHY_MMP2,\n\t}, {\n\t\t.compatible = \"marvell,pxa910-usb-phy\",\n\t\t.data = (void *)PXA_USB_PHY_PXA910,\n\t}, {\n\t\t.compatible = \"marvell,pxa168-usb-phy\",\n\t\t.data = (void *)PXA_USB_PHY_PXA168,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pxa_usb_phy_of_match);\n\nstatic int pxa_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pxa_usb_phy *pxa_usb_phy;\n\tstruct phy_provider *provider;\n\tconst struct of_device_id *of_id;\n\n\tpxa_usb_phy = devm_kzalloc(dev, sizeof(struct pxa_usb_phy), GFP_KERNEL);\n\tif (!pxa_usb_phy)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_node(pxa_usb_phy_of_match, dev->of_node);\n\tif (of_id)\n\t\tpxa_usb_phy->version = (uintptr_t)of_id->data;\n\telse\n\t\tpxa_usb_phy->version = PXA_USB_PHY_MMP2;\n\n\tpxa_usb_phy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pxa_usb_phy->base)) {\n\t\tdev_err(dev, \"failed to remap PHY regs\\n\");\n\t\treturn PTR_ERR(pxa_usb_phy->base);\n\t}\n\n\tpxa_usb_phy->phy = devm_phy_create(dev, NULL, &pxa_usb_phy_ops);\n\tif (IS_ERR(pxa_usb_phy->phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(pxa_usb_phy->phy);\n\t}\n\n\tphy_set_drvdata(pxa_usb_phy->phy, pxa_usb_phy);\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(provider)) {\n\t\tdev_err(dev, \"failed to register PHY provider\\n\");\n\t\treturn PTR_ERR(provider);\n\t}\n\n\tif (!dev->of_node) {\n\t\tphy_create_lookup(pxa_usb_phy->phy, \"usb\", \"mv-udc\");\n\t\tphy_create_lookup(pxa_usb_phy->phy, \"usb\", \"pxa-u2oehci\");\n\t\tphy_create_lookup(pxa_usb_phy->phy, \"usb\", \"mv-otg\");\n\t}\n\n\tdev_info(dev, \"Marvell PXA USB PHY\");\n\treturn 0;\n}\n\nstatic struct platform_driver pxa_usb_phy_driver = {\n\t.probe\t\t= pxa_usb_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"pxa-usb-phy\",\n\t\t.of_match_table = pxa_usb_phy_of_match,\n\t},\n};\nmodule_platform_driver(pxa_usb_phy_driver);\n\nMODULE_AUTHOR(\"Lubomir Rintel <lkundrak@v3.sk>\");\nMODULE_DESCRIPTION(\"Marvell PXA USB PHY Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}