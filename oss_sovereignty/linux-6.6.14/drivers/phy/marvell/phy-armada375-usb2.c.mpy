{
  "module_name": "phy-armada375-usb2.c",
  "hash_id": "96ab23b737eebd16ef1a5b6f55f9178ff49591157ce4292f6f0f964df959e46b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/marvell/phy-armada375-usb2.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/phy/phy.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\n#define USB2_PHY_CONFIG_DISABLE BIT(0)\n\nstruct armada375_cluster_phy {\n\tstruct phy *phy;\n\tvoid __iomem *reg;\n\tbool use_usb3;\n\tint phy_provided;\n};\n\nstatic int armada375_usb_phy_init(struct phy *phy)\n{\n\tstruct armada375_cluster_phy *cluster_phy;\n\tu32 reg;\n\n\tcluster_phy = phy_get_drvdata(phy);\n\tif (!cluster_phy)\n\t\treturn -ENODEV;\n\n\treg = readl(cluster_phy->reg);\n\tif (cluster_phy->use_usb3)\n\t\treg |= USB2_PHY_CONFIG_DISABLE;\n\telse\n\t\treg &= ~USB2_PHY_CONFIG_DISABLE;\n\twritel(reg, cluster_phy->reg);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops armada375_usb_phy_ops = {\n\t.init = armada375_usb_phy_init,\n\t.owner = THIS_MODULE,\n};\n\n \nstatic struct phy *armada375_usb_phy_xlate(struct device *dev,\n\t\t\t\t\tstruct of_phandle_args *args)\n{\n\tstruct armada375_cluster_phy *cluster_phy = dev_get_drvdata(dev);\n\n\tif (!cluster_phy)\n\t\treturn  ERR_PTR(-ENODEV);\n\n\t \n\tif (WARN_ON((cluster_phy->phy_provided != PHY_NONE) &&\n\t\t\t(cluster_phy->phy_provided != args->args[0]))) {\n\t\tdev_err(dev, \"This PHY has already been provided!\\n\");\n\t\tdev_err(dev, \"Check your device tree, only one controller can use it\\n.\");\n\t\tif (args->args[0] == PHY_TYPE_USB2)\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\telse\n\t\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tif (args->args[0] == PHY_TYPE_USB2)\n\t\tcluster_phy->use_usb3 = false;\n\telse if (args->args[0] == PHY_TYPE_USB3)\n\t\tcluster_phy->use_usb3 = true;\n\telse {\n\t\tdev_err(dev, \"Invalid PHY mode\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\t \n\tcluster_phy->phy_provided = args->args[0];\n\n\treturn cluster_phy->phy;\n}\n\nstatic int armada375_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy *phy;\n\tstruct phy_provider *phy_provider;\n\tvoid __iomem *usb_cluster_base;\n\tstruct armada375_cluster_phy *cluster_phy;\n\n\tcluster_phy = devm_kzalloc(dev, sizeof(*cluster_phy), GFP_KERNEL);\n\tif (!cluster_phy)\n\t\treturn  -ENOMEM;\n\n\tusb_cluster_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(usb_cluster_base))\n\t\treturn PTR_ERR(usb_cluster_base);\n\n\tphy = devm_phy_create(dev, NULL, &armada375_usb_phy_ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(phy);\n\t}\n\n\tcluster_phy->phy = phy;\n\tcluster_phy->reg = usb_cluster_base;\n\n\tdev_set_drvdata(dev, cluster_phy);\n\tphy_set_drvdata(phy, cluster_phy);\n\n\tphy_provider = devm_of_phy_provider_register(&pdev->dev,\n\t\t\t\t\t\t     armada375_usb_phy_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id of_usb_cluster_table[] = {\n\t{ .compatible = \"marvell,armada-375-usb-cluster\", },\n\t{   },\n};\n\nstatic struct platform_driver armada375_usb_phy_driver = {\n\t.probe\t= armada375_usb_phy_probe,\n\t.driver = {\n\t\t.of_match_table\t= of_usb_cluster_table,\n\t\t.name  = \"armada-375-usb-cluster\",\n\t}\n};\nbuiltin_platform_driver(armada375_usb_phy_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}