{
  "module_name": "phy-mvebu-cp110-utmi.c",
  "hash_id": "3acd46973d8f87f15492bbee277283e9a600eed0b5eab4bb25f8de167727f6ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/marvell/phy-mvebu-cp110-utmi.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/usb/of.h>\n#include <linux/usb/otg.h>\n\n#define UTMI_PHY_PORTS\t\t\t\t2\n\n \n#define SYSCON_USB_CFG_REG\t\t\t0x420\n#define   USB_CFG_DEVICE_EN_MASK\t\tBIT(0)\n#define   USB_CFG_DEVICE_MUX_OFFSET\t\t1\n#define   USB_CFG_DEVICE_MUX_MASK\t\tBIT(1)\n#define   USB_CFG_PLL_MASK\t\t\tBIT(25)\n\n#define SYSCON_UTMI_CFG_REG(id)\t\t\t(0x440 + (id) * 4)\n#define   UTMI_PHY_CFG_PU_MASK\t\t\tBIT(5)\n\n#define UTMI_PLL_CTRL_REG\t\t\t0x0\n#define   PLL_REFDIV_OFFSET\t\t\t0\n#define   PLL_REFDIV_MASK\t\t\tGENMASK(6, 0)\n#define   PLL_REFDIV_VAL\t\t\t0x5\n#define   PLL_FBDIV_OFFSET\t\t\t16\n#define   PLL_FBDIV_MASK\t\t\tGENMASK(24, 16)\n#define   PLL_FBDIV_VAL\t\t\t\t0x60\n#define   PLL_SEL_LPFR_MASK\t\t\tGENMASK(29, 28)\n#define   PLL_RDY\t\t\t\tBIT(31)\n#define UTMI_CAL_CTRL_REG\t\t\t0x8\n#define   IMPCAL_VTH_OFFSET\t\t\t8\n#define   IMPCAL_VTH_MASK\t\t\tGENMASK(10, 8)\n#define   IMPCAL_VTH_VAL\t\t\t0x7\n#define   IMPCAL_DONE\t\t\t\tBIT(23)\n#define   PLLCAL_DONE\t\t\t\tBIT(31)\n#define UTMI_TX_CH_CTRL_REG\t\t\t0xC\n#define   DRV_EN_LS_OFFSET\t\t\t12\n#define   DRV_EN_LS_MASK\t\t\tGENMASK(15, 12)\n#define   IMP_SEL_LS_OFFSET\t\t\t16\n#define   IMP_SEL_LS_MASK\t\t\tGENMASK(19, 16)\n#define   TX_AMP_OFFSET\t\t\t\t20\n#define   TX_AMP_MASK\t\t\t\tGENMASK(22, 20)\n#define   TX_AMP_VAL\t\t\t\t0x4\n#define UTMI_RX_CH_CTRL0_REG\t\t\t0x14\n#define   SQ_DET_EN\t\t\t\tBIT(15)\n#define   SQ_ANA_DTC_SEL\t\t\tBIT(28)\n#define UTMI_RX_CH_CTRL1_REG\t\t\t0x18\n#define   SQ_AMP_CAL_OFFSET\t\t\t0\n#define   SQ_AMP_CAL_MASK\t\t\tGENMASK(2, 0)\n#define   SQ_AMP_CAL_VAL\t\t\t1\n#define   SQ_AMP_CAL_EN\t\t\t\tBIT(3)\n#define UTMI_CTRL_STATUS0_REG\t\t\t0x24\n#define   SUSPENDM\t\t\t\tBIT(22)\n#define   TEST_SEL\t\t\t\tBIT(25)\n#define UTMI_CHGDTC_CTRL_REG\t\t\t0x38\n#define   VDAT_OFFSET\t\t\t\t8\n#define   VDAT_MASK\t\t\t\tGENMASK(9, 8)\n#define   VDAT_VAL\t\t\t\t1\n#define   VSRC_OFFSET\t\t\t\t10\n#define   VSRC_MASK\t\t\t\tGENMASK(11, 10)\n#define   VSRC_VAL\t\t\t\t1\n\n#define PLL_LOCK_DELAY_US\t\t\t10000\n#define PLL_LOCK_TIMEOUT_US\t\t\t1000000\n\n#define PORT_REGS(p)\t\t\t\t((p)->priv->regs + (p)->id * 0x1000)\n\n \nstruct mvebu_cp110_utmi {\n\tvoid __iomem *regs;\n\tstruct regmap *syscon;\n\tstruct device *dev;\n\tconst struct phy_ops *ops;\n};\n\n \nstruct mvebu_cp110_utmi_port {\n\tstruct mvebu_cp110_utmi *priv;\n\tu32 id;\n\tenum usb_dr_mode dr_mode;\n};\n\nstatic void mvebu_cp110_utmi_port_setup(struct mvebu_cp110_utmi_port *port)\n{\n\tu32 reg;\n\n\t \n\treg = readl(PORT_REGS(port) + UTMI_PLL_CTRL_REG);\n\treg &= ~(PLL_REFDIV_MASK | PLL_FBDIV_MASK | PLL_SEL_LPFR_MASK);\n\treg |= (PLL_REFDIV_VAL << PLL_REFDIV_OFFSET) |\n\t       (PLL_FBDIV_VAL << PLL_FBDIV_OFFSET);\n\twritel(reg, PORT_REGS(port) + UTMI_PLL_CTRL_REG);\n\n\t \n\treg = readl(PORT_REGS(port) + UTMI_CAL_CTRL_REG);\n\treg &= ~IMPCAL_VTH_MASK;\n\treg |= IMPCAL_VTH_VAL << IMPCAL_VTH_OFFSET;\n\twritel(reg, PORT_REGS(port) + UTMI_CAL_CTRL_REG);\n\n\t \n\treg = readl(PORT_REGS(port) + UTMI_TX_CH_CTRL_REG);\n\treg &= ~TX_AMP_MASK;\n\treg |= TX_AMP_VAL << TX_AMP_OFFSET;\n\twritel(reg, PORT_REGS(port) + UTMI_TX_CH_CTRL_REG);\n\n\t \n\treg = readl(PORT_REGS(port) + UTMI_RX_CH_CTRL0_REG);\n\treg &= ~SQ_DET_EN;\n\treg |= SQ_ANA_DTC_SEL;\n\twritel(reg, PORT_REGS(port) + UTMI_RX_CH_CTRL0_REG);\n\n\t \n\treg = readl(PORT_REGS(port) + UTMI_RX_CH_CTRL1_REG);\n\treg &= ~SQ_AMP_CAL_MASK;\n\treg |= (SQ_AMP_CAL_VAL << SQ_AMP_CAL_OFFSET) | SQ_AMP_CAL_EN;\n\twritel(reg, PORT_REGS(port) + UTMI_RX_CH_CTRL1_REG);\n\n\t \n\treg = readl(PORT_REGS(port) + UTMI_CHGDTC_CTRL_REG);\n\treg &= ~(VDAT_MASK | VSRC_MASK);\n\treg |= (VDAT_VAL << VDAT_OFFSET) | (VSRC_VAL << VSRC_OFFSET);\n\twritel(reg, PORT_REGS(port) + UTMI_CHGDTC_CTRL_REG);\n}\n\nstatic int mvebu_cp110_utmi_phy_power_off(struct phy *phy)\n{\n\tstruct mvebu_cp110_utmi_port *port = phy_get_drvdata(phy);\n\tstruct mvebu_cp110_utmi *utmi = port->priv;\n\tint i;\n\n\t \n\tregmap_clear_bits(utmi->syscon, SYSCON_UTMI_CFG_REG(port->id),\n\t\t\t  UTMI_PHY_CFG_PU_MASK);\n\n\tfor (i = 0; i < UTMI_PHY_PORTS; i++) {\n\t\tint test = regmap_test_bits(utmi->syscon,\n\t\t\t\t\t    SYSCON_UTMI_CFG_REG(i),\n\t\t\t\t\t    UTMI_PHY_CFG_PU_MASK);\n\t\t \n\t\tif (test != 0)\n\t\t\treturn 0;\n\t}\n\n\t \n\tregmap_clear_bits(utmi->syscon, SYSCON_USB_CFG_REG, USB_CFG_PLL_MASK);\n\n\treturn 0;\n}\n\nstatic int mvebu_cp110_utmi_phy_power_on(struct phy *phy)\n{\n\tstruct mvebu_cp110_utmi_port *port = phy_get_drvdata(phy);\n\tstruct mvebu_cp110_utmi *utmi = port->priv;\n\tstruct device *dev = &phy->dev;\n\tint ret;\n\tu32 reg;\n\n\t \n\tret = mvebu_cp110_utmi_phy_power_off(phy);\n\tif (ret) {\n\t\tdev_err(dev, \"UTMI power OFF before power ON failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (port->dr_mode == USB_DR_MODE_PERIPHERAL) {\n\t\tregmap_update_bits(utmi->syscon, SYSCON_USB_CFG_REG,\n\t\t\t\t   USB_CFG_DEVICE_EN_MASK | USB_CFG_DEVICE_MUX_MASK,\n\t\t\t\t   USB_CFG_DEVICE_EN_MASK |\n\t\t\t\t   (port->id << USB_CFG_DEVICE_MUX_OFFSET));\n\t}\n\n\t \n\treg = readl(PORT_REGS(port) + UTMI_CTRL_STATUS0_REG);\n\treg |= SUSPENDM | TEST_SEL;\n\twritel(reg, PORT_REGS(port) + UTMI_CTRL_STATUS0_REG);\n\n\t \n\tmdelay(1);\n\n\t \n\tmvebu_cp110_utmi_port_setup(port);\n\n\t \n\tregmap_set_bits(utmi->syscon, SYSCON_UTMI_CFG_REG(port->id),\n\t\t\tUTMI_PHY_CFG_PU_MASK);\n\n\t \n\treg = readl(PORT_REGS(port) + UTMI_CTRL_STATUS0_REG);\n\treg &= ~TEST_SEL;\n\twritel(reg, PORT_REGS(port) + UTMI_CTRL_STATUS0_REG);\n\n\t \n\tret = readl_poll_timeout(PORT_REGS(port) + UTMI_CAL_CTRL_REG, reg,\n\t\t\t\t reg & IMPCAL_DONE,\n\t\t\t\t PLL_LOCK_DELAY_US, PLL_LOCK_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to end UTMI impedance calibration\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = readl_poll_timeout(PORT_REGS(port) + UTMI_CAL_CTRL_REG, reg,\n\t\t\t\t reg & PLLCAL_DONE,\n\t\t\t\t PLL_LOCK_DELAY_US, PLL_LOCK_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to end UTMI PLL calibration\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = readl_poll_timeout(PORT_REGS(port) + UTMI_PLL_CTRL_REG, reg,\n\t\t\t\t reg & PLL_RDY,\n\t\t\t\t PLL_LOCK_DELAY_US, PLL_LOCK_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(dev, \"PLL is not ready\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_set_bits(utmi->syscon, SYSCON_USB_CFG_REG, USB_CFG_PLL_MASK);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops mvebu_cp110_utmi_phy_ops = {\n\t.power_on = mvebu_cp110_utmi_phy_power_on,\n\t.power_off = mvebu_cp110_utmi_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct of_device_id mvebu_cp110_utmi_of_match[] = {\n\t{ .compatible = \"marvell,cp110-utmi-phy\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mvebu_cp110_utmi_of_match);\n\nstatic int mvebu_cp110_utmi_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mvebu_cp110_utmi *utmi;\n\tstruct phy_provider *provider;\n\tstruct device_node *child;\n\tu32 usb_devices = 0;\n\n\tutmi = devm_kzalloc(dev, sizeof(*utmi), GFP_KERNEL);\n\tif (!utmi)\n\t\treturn -ENOMEM;\n\n\tutmi->dev = dev;\n\n\t \n\tutmi->syscon = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t       \"marvell,system-controller\");\n\tif (IS_ERR(utmi->syscon)) {\n\t\tdev_err(dev, \"Missing UTMI system controller\\n\");\n\t\treturn PTR_ERR(utmi->syscon);\n\t}\n\n\t \n\tutmi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(utmi->regs))\n\t\treturn PTR_ERR(utmi->regs);\n\n\tfor_each_available_child_of_node(dev->of_node, child) {\n\t\tstruct mvebu_cp110_utmi_port *port;\n\t\tstruct phy *phy;\n\t\tint ret;\n\t\tu32 port_id;\n\n\t\tret = of_property_read_u32(child, \"reg\", &port_id);\n\t\tif ((ret < 0) || (port_id >= UTMI_PHY_PORTS)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"invalid 'reg' property on child %pOF\\n\",\n\t\t\t\tchild);\n\t\t\tcontinue;\n\t\t}\n\n\t\tport = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);\n\t\tif (!port) {\n\t\t\tof_node_put(child);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tport->dr_mode = of_usb_get_dr_mode_by_phy(child, -1);\n\t\tif ((port->dr_mode != USB_DR_MODE_HOST) &&\n\t\t    (port->dr_mode != USB_DR_MODE_PERIPHERAL)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Missing dual role setting of the port%d, will use HOST mode\\n\",\n\t\t\t\tport_id);\n\t\t\tport->dr_mode = USB_DR_MODE_HOST;\n\t\t}\n\n\t\tif (port->dr_mode == USB_DR_MODE_PERIPHERAL) {\n\t\t\tusb_devices++;\n\t\t\tif (usb_devices > 1) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Single USB device allowed! Port%d will use HOST mode\\n\",\n\t\t\t\t\tport_id);\n\t\t\t\tport->dr_mode = USB_DR_MODE_HOST;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tutmi->ops = &mvebu_cp110_utmi_phy_ops;\n\n\t\t \n\t\tphy = devm_phy_create(dev, child, utmi->ops);\n\t\tif (IS_ERR(phy)) {\n\t\t\tdev_err(dev, \"Failed to create the UTMI PHY\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn PTR_ERR(phy);\n\t\t}\n\n\t\tport->priv = utmi;\n\t\tport->id = port_id;\n\t\tphy_set_drvdata(phy, port);\n\n\t\t \n\t\tmvebu_cp110_utmi_phy_power_off(phy);\n\t}\n\n\tdev_set_drvdata(dev, utmi);\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic struct platform_driver mvebu_cp110_utmi_driver = {\n\t.probe\t= mvebu_cp110_utmi_phy_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"mvebu-cp110-utmi-phy\",\n\t\t.of_match_table\t= mvebu_cp110_utmi_of_match,\n\t },\n};\nmodule_platform_driver(mvebu_cp110_utmi_driver);\n\nMODULE_AUTHOR(\"Konstatin Porotchkin <kostap@marvell.com>\");\nMODULE_DESCRIPTION(\"Marvell Armada CP110 UTMI PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}