{
  "module_name": "phy-berlin-usb.c",
  "hash_id": "7ba22fdfe51c252e6c5e04ed32c06cf6f4a9c706a54cc4b7adce62ebab517a57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/marvell/phy-berlin-usb.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#define USB_PHY_PLL\t\t0x04\n#define USB_PHY_PLL_CONTROL\t0x08\n#define USB_PHY_TX_CTRL0\t0x10\n#define USB_PHY_TX_CTRL1\t0x14\n#define USB_PHY_TX_CTRL2\t0x18\n#define USB_PHY_RX_CTRL\t\t0x20\n#define USB_PHY_ANALOG\t\t0x34\n\n \n#define CLK_REF_DIV(x)\t\t((x) << 4)\n#define FEEDBACK_CLK_DIV(x)\t((x) << 8)\n\n \n#define CLK_STABLE\t\tBIT(0)\n#define PLL_CTRL_PIN\t\tBIT(1)\n#define PLL_CTRL_REG\t\tBIT(2)\n#define PLL_ON\t\t\tBIT(3)\n#define PHASE_OFF_TOL_125\t(0x0 << 5)\n#define PHASE_OFF_TOL_250\tBIT(5)\n#define KVC0_CALIB\t\t(0x0 << 9)\n#define KVC0_REG_CTRL\t\tBIT(9)\n#define KVC0_HIGH\t\t(0x0 << 10)\n#define KVC0_LOW\t\t(0x3 << 10)\n#define CLK_BLK_EN\t\tBIT(13)\n\n \n#define EXT_HS_RCAL_EN\t\tBIT(3)\n#define EXT_FS_RCAL_EN\t\tBIT(4)\n#define IMPCAL_VTH_DIV(x)\t((x) << 5)\n#define EXT_RS_RCAL_DIV(x)\t((x) << 8)\n#define EXT_FS_RCAL_DIV(x)\t((x) << 12)\n\n \n#define TX_VDD15_14\t\t(0x0 << 4)\n#define TX_VDD15_15\t\tBIT(4)\n#define TX_VDD15_16\t\t(0x2 << 4)\n#define TX_VDD15_17\t\t(0x3 << 4)\n#define TX_VDD12_VDD\t\t(0x0 << 6)\n#define TX_VDD12_11\t\tBIT(6)\n#define TX_VDD12_12\t\t(0x2 << 6)\n#define TX_VDD12_13\t\t(0x3 << 6)\n#define LOW_VDD_EN\t\tBIT(8)\n#define TX_OUT_AMP(x)\t\t((x) << 9)\n\n \n#define TX_CHAN_CTRL_REG(x)\t((x) << 0)\n#define DRV_SLEWRATE(x)\t\t((x) << 4)\n#define IMP_CAL_FS_HS_DLY_0\t(0x0 << 6)\n#define IMP_CAL_FS_HS_DLY_1\tBIT(6)\n#define IMP_CAL_FS_HS_DLY_2\t(0x2 << 6)\n#define IMP_CAL_FS_HS_DLY_3\t(0x3 << 6)\n#define FS_DRV_EN_MASK(x)\t((x) << 8)\n#define HS_DRV_EN_MASK(x)\t((x) << 12)\n\n \n#define PHASE_FREEZE_DLY_2_CL\t(0x0 << 0)\n#define PHASE_FREEZE_DLY_4_CL\tBIT(0)\n#define ACK_LENGTH_8_CL\t\t(0x0 << 2)\n#define ACK_LENGTH_12_CL\tBIT(2)\n#define ACK_LENGTH_16_CL\t(0x2 << 2)\n#define ACK_LENGTH_20_CL\t(0x3 << 2)\n#define SQ_LENGTH_3\t\t(0x0 << 4)\n#define SQ_LENGTH_6\t\tBIT(4)\n#define SQ_LENGTH_9\t\t(0x2 << 4)\n#define SQ_LENGTH_12\t\t(0x3 << 4)\n#define DISCON_THRESHOLD_260\t(0x0 << 6)\n#define DISCON_THRESHOLD_270\tBIT(6)\n#define DISCON_THRESHOLD_280\t(0x2 << 6)\n#define DISCON_THRESHOLD_290\t(0x3 << 6)\n#define SQ_THRESHOLD(x)\t\t((x) << 8)\n#define LPF_COEF(x)\t\t((x) << 12)\n#define INTPL_CUR_10\t\t(0x0 << 14)\n#define INTPL_CUR_20\t\tBIT(14)\n#define INTPL_CUR_30\t\t(0x2 << 14)\n#define INTPL_CUR_40\t\t(0x3 << 14)\n\n \n#define ANA_PWR_UP\t\tBIT(1)\n#define ANA_PWR_DOWN\t\tBIT(2)\n#define V2I_VCO_RATIO(x)\t((x) << 7)\n#define R_ROTATE_90\t\t(0x0 << 10)\n#define R_ROTATE_0\t\tBIT(10)\n#define MODE_TEST_EN\t\tBIT(11)\n#define ANA_TEST_DC_CTRL(x)\t((x) << 12)\n\nstatic const u32 phy_berlin_pll_dividers[] = {\n\t \n\tCLK_REF_DIV(0x6) | FEEDBACK_CLK_DIV(0x55),\n\t \n\tCLK_REF_DIV(0xc) | FEEDBACK_CLK_DIV(0x54),\n};\n\nstruct phy_berlin_usb_priv {\n\tvoid __iomem\t\t*base;\n\tstruct reset_control\t*rst_ctrl;\n\tu32\t\t\tpll_divider;\n};\n\nstatic int phy_berlin_usb_power_on(struct phy *phy)\n{\n\tstruct phy_berlin_usb_priv *priv = phy_get_drvdata(phy);\n\n\treset_control_reset(priv->rst_ctrl);\n\n\twritel(priv->pll_divider,\n\t       priv->base + USB_PHY_PLL);\n\twritel(CLK_STABLE | PLL_CTRL_REG | PHASE_OFF_TOL_250 | KVC0_REG_CTRL |\n\t       CLK_BLK_EN, priv->base + USB_PHY_PLL_CONTROL);\n\twritel(V2I_VCO_RATIO(0x5) | R_ROTATE_0 | ANA_TEST_DC_CTRL(0x5),\n\t       priv->base + USB_PHY_ANALOG);\n\twritel(PHASE_FREEZE_DLY_4_CL | ACK_LENGTH_16_CL | SQ_LENGTH_12 |\n\t       DISCON_THRESHOLD_270 | SQ_THRESHOLD(0xa) | LPF_COEF(0x2) |\n\t       INTPL_CUR_30, priv->base + USB_PHY_RX_CTRL);\n\n\twritel(TX_VDD12_13 | TX_OUT_AMP(0x3), priv->base + USB_PHY_TX_CTRL1);\n\twritel(EXT_HS_RCAL_EN | IMPCAL_VTH_DIV(0x3) | EXT_RS_RCAL_DIV(0x4),\n\t       priv->base + USB_PHY_TX_CTRL0);\n\n\twritel(EXT_HS_RCAL_EN | IMPCAL_VTH_DIV(0x3) | EXT_RS_RCAL_DIV(0x4) |\n\t       EXT_FS_RCAL_DIV(0x2), priv->base + USB_PHY_TX_CTRL0);\n\n\twritel(EXT_HS_RCAL_EN | IMPCAL_VTH_DIV(0x3) | EXT_RS_RCAL_DIV(0x4),\n\t       priv->base + USB_PHY_TX_CTRL0);\n\twritel(TX_CHAN_CTRL_REG(0xf) | DRV_SLEWRATE(0x3) | IMP_CAL_FS_HS_DLY_3 |\n\t       FS_DRV_EN_MASK(0xd), priv->base + USB_PHY_TX_CTRL2);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops phy_berlin_usb_ops = {\n\t.power_on\t= phy_berlin_usb_power_on,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id phy_berlin_usb_of_match[] = {\n\t{\n\t\t.compatible = \"marvell,berlin2-usb-phy\",\n\t\t.data = &phy_berlin_pll_dividers[0],\n\t},\n\t{\n\t\t.compatible = \"marvell,berlin2cd-usb-phy\",\n\t\t.data = &phy_berlin_pll_dividers[1],\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, phy_berlin_usb_of_match);\n\nstatic int phy_berlin_usb_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match =\n\t\tof_match_device(phy_berlin_usb_of_match, &pdev->dev);\n\tstruct phy_berlin_usb_priv *priv;\n\tstruct phy *phy;\n\tstruct phy_provider *phy_provider;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->rst_ctrl = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->rst_ctrl))\n\t\treturn PTR_ERR(priv->rst_ctrl);\n\n\tpriv->pll_divider = *((u32 *)match->data);\n\n\tphy = devm_phy_create(&pdev->dev, NULL, &phy_berlin_usb_ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(&pdev->dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(phy);\n\t}\n\n\tphy_set_drvdata(phy, priv);\n\n\tphy_provider =\n\t\tdevm_of_phy_provider_register(&pdev->dev, of_phy_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver phy_berlin_usb_driver = {\n\t.probe\t= phy_berlin_usb_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"phy-berlin-usb\",\n\t\t.of_match_table\t= phy_berlin_usb_of_match,\n\t},\n};\nmodule_platform_driver(phy_berlin_usb_driver);\n\nMODULE_AUTHOR(\"Antoine Tenart <antoine.tenart@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Marvell Berlin PHY driver for USB\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}