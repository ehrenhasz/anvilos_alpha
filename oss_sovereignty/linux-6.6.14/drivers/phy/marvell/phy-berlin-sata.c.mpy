{
  "module_name": "phy-berlin-sata.c",
  "hash_id": "98b41dcb59ed1d14fed1da9e2e93001fd94e87f52faf4103bf278140b4ccfb79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/marvell/phy-berlin-sata.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n\n#define HOST_VSA_ADDR\t\t0x0\n#define HOST_VSA_DATA\t\t0x4\n#define PORT_SCR_CTL\t\t0x2c\n#define PORT_VSR_ADDR\t\t0x78\n#define PORT_VSR_DATA\t\t0x7c\n\n#define CONTROL_REGISTER\t0x0\n#define MBUS_SIZE_CONTROL\t0x4\n\n#define POWER_DOWN_PHY0\t\t\tBIT(6)\n#define POWER_DOWN_PHY1\t\t\tBIT(14)\n#define MBUS_WRITE_REQUEST_SIZE_128\t(BIT(2) << 16)\n#define MBUS_READ_REQUEST_SIZE_128\t(BIT(2) << 19)\n\n#define BG2_PHY_BASE\t\t0x080\n#define BG2Q_PHY_BASE\t\t0x200\n\n \n#define REF_FREF_SEL_25\t\tBIT(0)\n#define PHY_BERLIN_MODE_SATA\t(0x0 << 5)\n\n \n#define USE_MAX_PLL_RATE\tBIT(12)\n\n \n#define DATA_BIT_WIDTH_10\t(0x0 << 10)\n#define DATA_BIT_WIDTH_20\t(0x1 << 10)\n#define DATA_BIT_WIDTH_40\t(0x2 << 10)\n\n \n#define PHY_GEN_MAX_1_5\t\t(0x0 << 10)\n#define PHY_GEN_MAX_3_0\t\t(0x1 << 10)\n#define PHY_GEN_MAX_6_0\t\t(0x2 << 10)\n\nstruct phy_berlin_desc {\n\tstruct phy\t*phy;\n\tu32\t\tpower_bit;\n\tunsigned\tindex;\n};\n\nstruct phy_berlin_priv {\n\tvoid __iomem\t\t*base;\n\tspinlock_t\t\tlock;\n\tstruct clk\t\t*clk;\n\tstruct phy_berlin_desc\t**phys;\n\tunsigned\t\tnphys;\n\tu32\t\t\tphy_base;\n};\n\nstatic inline void phy_berlin_sata_reg_setbits(void __iomem *ctrl_reg,\n\t\t\t       u32 phy_base, u32 reg, u32 mask, u32 val)\n{\n\tu32 regval;\n\n\t \n\twritel(phy_base + reg, ctrl_reg + PORT_VSR_ADDR);\n\n\t \n\tregval = readl(ctrl_reg + PORT_VSR_DATA);\n\tregval &= ~mask;\n\tregval |= val;\n\twritel(regval, ctrl_reg + PORT_VSR_DATA);\n}\n\nstatic int phy_berlin_sata_power_on(struct phy *phy)\n{\n\tstruct phy_berlin_desc *desc = phy_get_drvdata(phy);\n\tstruct phy_berlin_priv *priv = dev_get_drvdata(phy->dev.parent);\n\tvoid __iomem *ctrl_reg = priv->base + 0x60 + (desc->index * 0x80);\n\tu32 regval;\n\n\tclk_prepare_enable(priv->clk);\n\n\tspin_lock(&priv->lock);\n\n\t \n\twritel(CONTROL_REGISTER, priv->base + HOST_VSA_ADDR);\n\tregval = readl(priv->base + HOST_VSA_DATA);\n\tregval &= ~desc->power_bit;\n\twritel(regval, priv->base + HOST_VSA_DATA);\n\n\t \n\twritel(MBUS_SIZE_CONTROL, priv->base + HOST_VSA_ADDR);\n\tregval = readl(priv->base + HOST_VSA_DATA);\n\tregval |= MBUS_WRITE_REQUEST_SIZE_128 | MBUS_READ_REQUEST_SIZE_128;\n\twritel(regval, priv->base + HOST_VSA_DATA);\n\n\t \n\tphy_berlin_sata_reg_setbits(ctrl_reg, priv->phy_base, 0x01,\n\t\t\t\t    0x00ff,\n\t\t\t\t    REF_FREF_SEL_25 | PHY_BERLIN_MODE_SATA);\n\n\t \n\tphy_berlin_sata_reg_setbits(ctrl_reg, priv->phy_base, 0x25,\n\t\t\t\t    0x0c00, PHY_GEN_MAX_6_0);\n\n\t \n\tphy_berlin_sata_reg_setbits(ctrl_reg, priv->phy_base, 0x23,\n\t\t\t\t    0x0c00, DATA_BIT_WIDTH_40);\n\n\t \n\tphy_berlin_sata_reg_setbits(ctrl_reg, priv->phy_base, 0x02,\n\t\t\t\t    0x0000, USE_MAX_PLL_RATE);\n\n\t \n\tregval = readl(ctrl_reg + PORT_SCR_CTL);\n\tregval &= ~GENMASK(7, 4);\n\tregval |= 0x30;\n\twritel(regval, ctrl_reg + PORT_SCR_CTL);\n\n\tspin_unlock(&priv->lock);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int phy_berlin_sata_power_off(struct phy *phy)\n{\n\tstruct phy_berlin_desc *desc = phy_get_drvdata(phy);\n\tstruct phy_berlin_priv *priv = dev_get_drvdata(phy->dev.parent);\n\tu32 regval;\n\n\tclk_prepare_enable(priv->clk);\n\n\tspin_lock(&priv->lock);\n\n\t \n\twritel(CONTROL_REGISTER, priv->base + HOST_VSA_ADDR);\n\tregval = readl(priv->base + HOST_VSA_DATA);\n\tregval |= desc->power_bit;\n\twritel(regval, priv->base + HOST_VSA_DATA);\n\n\tspin_unlock(&priv->lock);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic struct phy *phy_berlin_sata_phy_xlate(struct device *dev,\n\t\t\t\t\t     struct of_phandle_args *args)\n{\n\tstruct phy_berlin_priv *priv = dev_get_drvdata(dev);\n\tint i;\n\n\tif (WARN_ON(args->args[0] >= priv->nphys))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tfor (i = 0; i < priv->nphys; i++) {\n\t\tif (priv->phys[i]->index == args->args[0])\n\t\t\tbreak;\n\t}\n\n\tif (i == priv->nphys)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn priv->phys[i]->phy;\n}\n\nstatic const struct phy_ops phy_berlin_sata_ops = {\n\t.power_on\t= phy_berlin_sata_power_on,\n\t.power_off\t= phy_berlin_sata_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic u32 phy_berlin_power_down_bits[] = {\n\tPOWER_DOWN_PHY0,\n\tPOWER_DOWN_PHY1,\n};\n\nstatic int phy_berlin_sata_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *child;\n\tstruct phy *phy;\n\tstruct phy_provider *phy_provider;\n\tstruct phy_berlin_priv *priv;\n\tstruct resource *res;\n\tint ret, i = 0;\n\tu32 phy_id;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tpriv->base = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!priv->base)\n\t\treturn -ENOMEM;\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tpriv->nphys = of_get_child_count(dev->of_node);\n\tif (priv->nphys == 0)\n\t\treturn -ENODEV;\n\n\tpriv->phys = devm_kcalloc(dev, priv->nphys, sizeof(*priv->phys),\n\t\t\t\t  GFP_KERNEL);\n\tif (!priv->phys)\n\t\treturn -ENOMEM;\n\n\tif (of_device_is_compatible(dev->of_node, \"marvell,berlin2-sata-phy\"))\n\t\tpriv->phy_base = BG2_PHY_BASE;\n\telse\n\t\tpriv->phy_base = BG2Q_PHY_BASE;\n\n\tdev_set_drvdata(dev, priv);\n\tspin_lock_init(&priv->lock);\n\n\tfor_each_available_child_of_node(dev->of_node, child) {\n\t\tstruct phy_berlin_desc *phy_desc;\n\n\t\tif (of_property_read_u32(child, \"reg\", &phy_id)) {\n\t\t\tdev_err(dev, \"missing reg property in node %pOFn\\n\",\n\t\t\t\tchild);\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tif (phy_id >= ARRAY_SIZE(phy_berlin_power_down_bits)) {\n\t\t\tdev_err(dev, \"invalid reg in node %pOFn\\n\", child);\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tphy_desc = devm_kzalloc(dev, sizeof(*phy_desc), GFP_KERNEL);\n\t\tif (!phy_desc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tphy = devm_phy_create(dev, NULL, &phy_berlin_sata_ops);\n\t\tif (IS_ERR(phy)) {\n\t\t\tdev_err(dev, \"failed to create PHY %d\\n\", phy_id);\n\t\t\tret = PTR_ERR(phy);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tphy_desc->phy = phy;\n\t\tphy_desc->power_bit = phy_berlin_power_down_bits[phy_id];\n\t\tphy_desc->index = phy_id;\n\t\tphy_set_drvdata(phy, phy_desc);\n\n\t\tpriv->phys[i++] = phy_desc;\n\n\t\t \n\t\tphy_berlin_sata_power_off(phy);\n\t}\n\n\tphy_provider =\n\t\tdevm_of_phy_provider_register(dev, phy_berlin_sata_phy_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\nput_child:\n\tof_node_put(child);\n\treturn ret;\n}\n\nstatic const struct of_device_id phy_berlin_sata_of_match[] = {\n\t{ .compatible = \"marvell,berlin2-sata-phy\" },\n\t{ .compatible = \"marvell,berlin2q-sata-phy\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, phy_berlin_sata_of_match);\n\nstatic struct platform_driver phy_berlin_sata_driver = {\n\t.probe\t= phy_berlin_sata_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"phy-berlin-sata\",\n\t\t.of_match_table\t= phy_berlin_sata_of_match,\n\t},\n};\nmodule_platform_driver(phy_berlin_sata_driver);\n\nMODULE_DESCRIPTION(\"Marvell Berlin SATA PHY driver\");\nMODULE_AUTHOR(\"Antoine T\u00e9nart <antoine.tenart@free-electrons.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}