{
  "module_name": "phy-mvebu-a3700-comphy.c",
  "hash_id": "6e51e45975cda35fe902d4ed2443d6dae3499bbd93f54c77299e918a3b1cbc5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/marvell/phy-mvebu-a3700-comphy.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#define PLL_SET_DELAY_US\t\t600\n#define COMPHY_PLL_SLEEP\t\t1000\n#define COMPHY_PLL_TIMEOUT\t\t150000\n\n \n#define COMPHY_LANE2_INDIR_ADDR\t\t0x0\n#define COMPHY_LANE2_INDIR_DATA\t\t0x4\n\n \n#define COMPHY_LANE2_REGS_BASE\t\t0x200\n\n \n#define COMPHY_LANE_REG_DIRECT(reg)\t(((reg) & 0x7FF) << 1)\n\n \n#define COMPHY_POWER_PLL_CTRL\t\t0x01\n#define PU_IVREF_BIT\t\t\tBIT(15)\n#define PU_PLL_BIT\t\t\tBIT(14)\n#define PU_RX_BIT\t\t\tBIT(13)\n#define PU_TX_BIT\t\t\tBIT(12)\n#define PU_TX_INTP_BIT\t\t\tBIT(11)\n#define PU_DFE_BIT\t\t\tBIT(10)\n#define RESET_DTL_RX_BIT\t\tBIT(9)\n#define PLL_LOCK_BIT\t\t\tBIT(8)\n#define REF_FREF_SEL_MASK\t\tGENMASK(4, 0)\n#define REF_FREF_SEL_SERDES_25MHZ\tFIELD_PREP(REF_FREF_SEL_MASK, 0x1)\n#define REF_FREF_SEL_SERDES_40MHZ\tFIELD_PREP(REF_FREF_SEL_MASK, 0x3)\n#define REF_FREF_SEL_SERDES_50MHZ\tFIELD_PREP(REF_FREF_SEL_MASK, 0x4)\n#define REF_FREF_SEL_PCIE_USB3_25MHZ\tFIELD_PREP(REF_FREF_SEL_MASK, 0x2)\n#define REF_FREF_SEL_PCIE_USB3_40MHZ\tFIELD_PREP(REF_FREF_SEL_MASK, 0x3)\n#define COMPHY_MODE_MASK\t\tGENMASK(7, 5)\n#define COMPHY_MODE_SATA\t\tFIELD_PREP(COMPHY_MODE_MASK, 0x0)\n#define COMPHY_MODE_PCIE\t\tFIELD_PREP(COMPHY_MODE_MASK, 0x3)\n#define COMPHY_MODE_SERDES\t\tFIELD_PREP(COMPHY_MODE_MASK, 0x4)\n#define COMPHY_MODE_USB3\t\tFIELD_PREP(COMPHY_MODE_MASK, 0x5)\n\n#define COMPHY_KVCO_CAL_CTRL\t\t0x02\n#define USE_MAX_PLL_RATE_BIT\t\tBIT(12)\n#define SPEED_PLL_MASK\t\t\tGENMASK(7, 2)\n#define SPEED_PLL_VALUE_16\t\tFIELD_PREP(SPEED_PLL_MASK, 0x10)\n\n#define COMPHY_DIG_LOOPBACK_EN\t\t0x23\n#define SEL_DATA_WIDTH_MASK\t\tGENMASK(11, 10)\n#define DATA_WIDTH_10BIT\t\tFIELD_PREP(SEL_DATA_WIDTH_MASK, 0x0)\n#define DATA_WIDTH_20BIT\t\tFIELD_PREP(SEL_DATA_WIDTH_MASK, 0x1)\n#define DATA_WIDTH_40BIT\t\tFIELD_PREP(SEL_DATA_WIDTH_MASK, 0x2)\n#define PLL_READY_TX_BIT\t\tBIT(4)\n\n#define COMPHY_SYNC_PATTERN\t\t0x24\n#define TXD_INVERT_BIT\t\t\tBIT(10)\n#define RXD_INVERT_BIT\t\t\tBIT(11)\n\n#define COMPHY_SYNC_MASK_GEN\t\t0x25\n#define PHY_GEN_MAX_MASK\t\tGENMASK(11, 10)\n#define PHY_GEN_MAX_USB3_5G\t\tFIELD_PREP(PHY_GEN_MAX_MASK, 0x1)\n\n#define COMPHY_ISOLATION_CTRL\t\t0x26\n#define PHY_ISOLATE_MODE\t\tBIT(15)\n\n#define COMPHY_GEN2_SET2\t\t0x3e\n#define GS2_TX_SSC_AMP_MASK\t\tGENMASK(15, 9)\n#define GS2_TX_SSC_AMP_4128\t\tFIELD_PREP(GS2_TX_SSC_AMP_MASK, 0x20)\n#define GS2_VREG_RXTX_MAS_ISET_MASK\tGENMASK(8, 7)\n#define GS2_VREG_RXTX_MAS_ISET_60U\tFIELD_PREP(GS2_VREG_RXTX_MAS_ISET_MASK,\\\n\t\t\t\t\t\t   0x0)\n#define GS2_VREG_RXTX_MAS_ISET_80U\tFIELD_PREP(GS2_VREG_RXTX_MAS_ISET_MASK,\\\n\t\t\t\t\t\t   0x1)\n#define GS2_VREG_RXTX_MAS_ISET_100U\tFIELD_PREP(GS2_VREG_RXTX_MAS_ISET_MASK,\\\n\t\t\t\t\t\t   0x2)\n#define GS2_VREG_RXTX_MAS_ISET_120U\tFIELD_PREP(GS2_VREG_RXTX_MAS_ISET_MASK,\\\n\t\t\t\t\t\t   0x3)\n#define GS2_RSVD_6_0_MASK\t\tGENMASK(6, 0)\n\n#define COMPHY_GEN3_SET2\t\t0x3f\n\n#define COMPHY_IDLE_SYNC_EN\t\t0x48\n#define IDLE_SYNC_EN\t\t\tBIT(12)\n\n#define COMPHY_MISC_CTRL0\t\t0x4F\n#define CLK100M_125M_EN\t\t\tBIT(4)\n#define TXDCLK_2X_SEL\t\t\tBIT(6)\n#define CLK500M_EN\t\t\tBIT(7)\n#define PHY_REF_CLK_SEL\t\t\tBIT(10)\n\n#define COMPHY_SFT_RESET\t\t0x52\n#define SFT_RST\t\t\t\tBIT(9)\n#define SFT_RST_NO_REG\t\t\tBIT(10)\n\n#define COMPHY_MISC_CTRL1\t\t0x73\n#define SEL_BITS_PCIE_FORCE\t\tBIT(15)\n\n#define COMPHY_GEN2_SET3\t\t0x112\n#define GS3_FFE_CAP_SEL_MASK\t\tGENMASK(3, 0)\n#define GS3_FFE_CAP_SEL_VALUE\t\tFIELD_PREP(GS3_FFE_CAP_SEL_MASK, 0xF)\n\n \n#define COMPHY_PIPE_LANE_CFG0\t\t0x180\n#define PRD_TXDEEMPH0_MASK\t\tBIT(0)\n#define PRD_TXMARGIN_MASK\t\tGENMASK(3, 1)\n#define PRD_TXSWING_MASK\t\tBIT(4)\n#define CFG_TX_ALIGN_POS_MASK\t\tGENMASK(8, 5)\n\n#define COMPHY_PIPE_LANE_CFG1\t\t0x181\n#define PRD_TXDEEMPH1_MASK\t\tBIT(15)\n#define USE_MAX_PLL_RATE_EN\t\tBIT(9)\n#define TX_DET_RX_MODE\t\t\tBIT(6)\n#define GEN2_TX_DATA_DLY_MASK\t\tGENMASK(4, 3)\n#define GEN2_TX_DATA_DLY_DEFT\t\tFIELD_PREP(GEN2_TX_DATA_DLY_MASK, 2)\n#define TX_ELEC_IDLE_MODE_EN\t\tBIT(0)\n\n#define COMPHY_PIPE_LANE_STAT1\t\t0x183\n#define TXDCLK_PCLK_EN\t\t\tBIT(0)\n\n#define COMPHY_PIPE_LANE_CFG4\t\t0x188\n#define SPREAD_SPECTRUM_CLK_EN\t\tBIT(7)\n\n#define COMPHY_PIPE_RST_CLK_CTRL\t0x1C1\n#define PIPE_SOFT_RESET\t\t\tBIT(0)\n#define PIPE_REG_RESET\t\t\tBIT(1)\n#define MODE_CORE_CLK_FREQ_SEL\t\tBIT(9)\n#define MODE_PIPE_WIDTH_32\t\tBIT(3)\n#define MODE_REFDIV_MASK\t\tGENMASK(5, 4)\n#define MODE_REFDIV_BY_4\t\tFIELD_PREP(MODE_REFDIV_MASK, 0x2)\n\n#define COMPHY_PIPE_TEST_MODE_CTRL\t0x1C2\n#define MODE_MARGIN_OVERRIDE\t\tBIT(2)\n\n#define COMPHY_PIPE_CLK_SRC_LO\t\t0x1C3\n#define MODE_CLK_SRC\t\t\tBIT(0)\n#define BUNDLE_PERIOD_SEL\t\tBIT(1)\n#define BUNDLE_PERIOD_SCALE_MASK\tGENMASK(3, 2)\n#define BUNDLE_SAMPLE_CTRL\t\tBIT(4)\n#define PLL_READY_DLY_MASK\t\tGENMASK(7, 5)\n#define CFG_SEL_20B\t\t\tBIT(15)\n\n#define COMPHY_PIPE_PWR_MGM_TIM1\t0x1D0\n#define CFG_PM_OSCCLK_WAIT_MASK\t\tGENMASK(15, 12)\n#define CFG_PM_RXDEN_WAIT_MASK\t\tGENMASK(11, 8)\n#define CFG_PM_RXDEN_WAIT_1_UNIT\tFIELD_PREP(CFG_PM_RXDEN_WAIT_MASK, 0x1)\n#define CFG_PM_RXDLOZ_WAIT_MASK\t\tGENMASK(7, 0)\n#define CFG_PM_RXDLOZ_WAIT_7_UNIT\tFIELD_PREP(CFG_PM_RXDLOZ_WAIT_MASK, 0x7)\n#define CFG_PM_RXDLOZ_WAIT_12_UNIT\tFIELD_PREP(CFG_PM_RXDLOZ_WAIT_MASK, 0xC)\n\n \n#define COMPHY_RESERVED_REG\t\t0x0E\n#define PHYCTRL_FRM_PIN_BIT\t\tBIT(13)\n\n \n#define COMPHY_PHY_REG(lane, reg)\t(((1 - (lane)) * 0x28) + ((reg) & 0x3f))\n\n \n#define COMPHY_PHY_CFG1\t\t\t0x0\n#define PIN_PU_IVREF_BIT\t\tBIT(1)\n#define PIN_RESET_CORE_BIT\t\tBIT(11)\n#define PIN_RESET_COMPHY_BIT\t\tBIT(12)\n#define PIN_PU_PLL_BIT\t\t\tBIT(16)\n#define PIN_PU_RX_BIT\t\t\tBIT(17)\n#define PIN_PU_TX_BIT\t\t\tBIT(18)\n#define PIN_TX_IDLE_BIT\t\t\tBIT(19)\n#define GEN_RX_SEL_MASK\t\t\tGENMASK(25, 22)\n#define GEN_RX_SEL_VALUE(val)\t\tFIELD_PREP(GEN_RX_SEL_MASK, (val))\n#define GEN_TX_SEL_MASK\t\t\tGENMASK(29, 26)\n#define GEN_TX_SEL_VALUE(val)\t\tFIELD_PREP(GEN_TX_SEL_MASK, (val))\n#define SERDES_SPEED_1_25_G\t\t0x6\n#define SERDES_SPEED_3_125_G\t\t0x8\n#define PHY_RX_INIT_BIT\t\t\tBIT(30)\n\n \n#define COMPHY_PHY_STAT1\t\t0x18\n#define PHY_RX_INIT_DONE_BIT\t\tBIT(0)\n#define PHY_PLL_READY_RX_BIT\t\tBIT(2)\n#define PHY_PLL_READY_TX_BIT\t\tBIT(3)\n\n \n#define COMPHY_SELECTOR_PHY_REG\t\t\t0xFC\n \n#define COMPHY_SELECTOR_PCIE_GBE0_SEL_BIT\tBIT(0)\n \n#define COMPHY_SELECTOR_USB3_GBE1_SEL_BIT\tBIT(4)\n \n#define COMPHY_SELECTOR_USB3_PHY_SEL_BIT\tBIT(8)\n\nstruct mvebu_a3700_comphy_conf {\n\tunsigned int lane;\n\tenum phy_mode mode;\n\tint submode;\n};\n\n#define MVEBU_A3700_COMPHY_CONF(_lane, _mode, _smode)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.lane = _lane,\t\t\t\t\t\t\\\n\t\t.mode = _mode,\t\t\t\t\t\t\\\n\t\t.submode = _smode,\t\t\t\t\t\\\n\t}\n\n#define MVEBU_A3700_COMPHY_CONF_GEN(_lane, _mode) \\\n\tMVEBU_A3700_COMPHY_CONF(_lane, _mode, PHY_INTERFACE_MODE_NA)\n\n#define MVEBU_A3700_COMPHY_CONF_ETH(_lane, _smode) \\\n\tMVEBU_A3700_COMPHY_CONF(_lane, PHY_MODE_ETHERNET, _smode)\n\nstatic const struct mvebu_a3700_comphy_conf mvebu_a3700_comphy_modes[] = {\n\t \n\tMVEBU_A3700_COMPHY_CONF_GEN(0, PHY_MODE_USB_HOST_SS),\n\tMVEBU_A3700_COMPHY_CONF_ETH(0, PHY_INTERFACE_MODE_SGMII),\n\tMVEBU_A3700_COMPHY_CONF_ETH(0, PHY_INTERFACE_MODE_1000BASEX),\n\tMVEBU_A3700_COMPHY_CONF_ETH(0, PHY_INTERFACE_MODE_2500BASEX),\n\t \n\tMVEBU_A3700_COMPHY_CONF_GEN(1, PHY_MODE_PCIE),\n\tMVEBU_A3700_COMPHY_CONF_ETH(1, PHY_INTERFACE_MODE_SGMII),\n\tMVEBU_A3700_COMPHY_CONF_ETH(1, PHY_INTERFACE_MODE_1000BASEX),\n\tMVEBU_A3700_COMPHY_CONF_ETH(1, PHY_INTERFACE_MODE_2500BASEX),\n\t \n\tMVEBU_A3700_COMPHY_CONF_GEN(2, PHY_MODE_SATA),\n\tMVEBU_A3700_COMPHY_CONF_GEN(2, PHY_MODE_USB_HOST_SS),\n};\n\nstruct mvebu_a3700_comphy_priv {\n\tvoid __iomem *comphy_regs;\n\tvoid __iomem *lane0_phy_regs;  \n\tvoid __iomem *lane1_phy_regs;  \n\tvoid __iomem *lane2_phy_indirect;  \n\tspinlock_t lock;  \n\tbool xtal_is_40m;\n};\n\nstruct mvebu_a3700_comphy_lane {\n\tstruct mvebu_a3700_comphy_priv *priv;\n\tstruct device *dev;\n\tunsigned int id;\n\tenum phy_mode mode;\n\tint submode;\n\tbool invert_tx;\n\tbool invert_rx;\n};\n\nstruct gbe_phy_init_data_fix {\n\tu16 addr;\n\tu16 value;\n};\n\n \nstatic struct gbe_phy_init_data_fix gbe_phy_init_fix[] = {\n\t{ 0x005, 0x07CC }, { 0x015, 0x0000 }, { 0x01B, 0x0000 },\n\t{ 0x01D, 0x0000 }, { 0x01E, 0x0000 }, { 0x01F, 0x0000 },\n\t{ 0x020, 0x0000 }, { 0x021, 0x0030 }, { 0x026, 0x0888 },\n\t{ 0x04D, 0x0152 }, { 0x04F, 0xA020 }, { 0x050, 0x07CC },\n\t{ 0x053, 0xE9CA }, { 0x055, 0xBD97 }, { 0x071, 0x3015 },\n\t{ 0x076, 0x03AA }, { 0x07C, 0x0FDF }, { 0x0C2, 0x3030 },\n\t{ 0x0C3, 0x8000 }, { 0x0E2, 0x5550 }, { 0x0E3, 0x12A4 },\n\t{ 0x0E4, 0x7D00 }, { 0x0E6, 0x0C83 }, { 0x101, 0xFCC0 },\n\t{ 0x104, 0x0C10 }\n};\n\n \nstatic u16 gbe_phy_init[512] = {\n\t \n\t \n\t \n\t0x3110, 0xFD83, 0x6430, 0x412F, 0x82C0, 0x06FA, 0x4500, 0x6D26,\t \n\t0xAFC0, 0x8000, 0xC000, 0x0000, 0x2000, 0x49CC, 0x0BC9, 0x2A52,\t \n\t0x0BD2, 0x0CDE, 0x13D2, 0x0CE8, 0x1149, 0x10E0, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0001, 0x0000, 0x4134, 0x0D2D, 0xFFFF,\t \n\t0xFFE0, 0x4030, 0x1016, 0x0030, 0x0000, 0x0800, 0x0866, 0x0000,\t \n\t0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,\t \n\t0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x000F, 0x6A62, 0x1988, 0x3100, 0x3100, 0x3100,\t \n\t0x3100, 0xA708, 0x2430, 0x0830, 0x1030, 0x4610, 0xFF00, 0xFF00,\t \n\t0x0060, 0x1000, 0x0400, 0x0040, 0x00F0, 0x0155, 0x1100, 0xA02A,\t \n\t0x06FA, 0x0080, 0xB008, 0xE3ED, 0x5002, 0xB592, 0x7A80, 0x0001,\t \n\t0x020A, 0x8820, 0x6014, 0x8054, 0xACAA, 0xFC88, 0x2A02, 0x45CF,\t \n\t0x000F, 0x1817, 0x2860, 0x064F, 0x0000, 0x0204, 0x1800, 0x6000,\t \n\t0x810F, 0x4F23, 0x4000, 0x4498, 0x0850, 0x0000, 0x000E, 0x1002,\t \n\t0x9D3A, 0x3009, 0xD066, 0x0491, 0x0001, 0x6AB0, 0x0399, 0x3780,\t \n\t0x0040, 0x5AC0, 0x4A80, 0x0000, 0x01DF, 0x0000, 0x0007, 0x0000,\t \n\t0x2D54, 0x00A1, 0x4000, 0x0100, 0xA20A, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x7400, 0x0E81, 0x1000, 0x1242, 0x0210,\t \n\t0x80DF, 0x0F1F, 0x2F3F, 0x4F5F, 0x6F7F, 0x0F1F, 0x2F3F, 0x4F5F,\t \n\t0x6F7F, 0x4BAD, 0x0000, 0x0000, 0x0800, 0x0000, 0x2400, 0xB651,\t \n\t0xC9E0, 0x4247, 0x0A24, 0x0000, 0xAF19, 0x1004, 0x0000, 0x0000,\t \n\t0x0000, 0x0013, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0060, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x3010, 0xFA00, 0x0000, 0x0000, 0x0000, 0x0003,\t \n\t0x1618, 0x8200, 0x8000, 0x0400, 0x050F, 0x0000, 0x0000, 0x0000,\t \n\t0x4C93, 0x0000, 0x1000, 0x1120, 0x0010, 0x1242, 0x1242, 0x1E00,\t \n\t0x0000, 0x0000, 0x0000, 0x00F8, 0x0000, 0x0041, 0x0800, 0x0000,\t \n\t0x82A0, 0x572E, 0x2490, 0x14A9, 0x4E00, 0x0000, 0x0803, 0x0541,\t \n\t0x0C15, 0x0000, 0x0000, 0x0400, 0x2626, 0x0000, 0x0000, 0x4200,\t \n\t0x0000, 0xAA55, 0x1020, 0x0000, 0x0000, 0x5010, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x5000, 0x0000, 0x0000, 0x0000, 0x02F2, 0x0000,\t \n\t0x101F, 0xFDC0, 0x4000, 0x8010, 0x0110, 0x0006, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x04CF, 0x0000, 0x04CF, 0x0000, 0x04CF, 0x0000, 0x04C6, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x00F0, 0x08A2, 0x3112, 0x0A14, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\t \n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000\t \n};\n\nstatic inline void comphy_reg_set(void __iomem *addr, u32 data, u32 mask)\n{\n\tu32 val;\n\n\tval = readl(addr);\n\tval = (val & ~mask) | (data & mask);\n\twritel(val, addr);\n}\n\nstatic inline void comphy_reg_set16(void __iomem *addr, u16 data, u16 mask)\n{\n\tu16 val;\n\n\tval = readw(addr);\n\tval = (val & ~mask) | (data & mask);\n\twritew(val, addr);\n}\n\n \nstatic void comphy_set_indirect(struct mvebu_a3700_comphy_priv *priv,\n\t\t\t\tu32 offset, u16 data, u16 mask)\n{\n\twritel(offset,\n\t       priv->lane2_phy_indirect + COMPHY_LANE2_INDIR_ADDR);\n\tcomphy_reg_set(priv->lane2_phy_indirect + COMPHY_LANE2_INDIR_DATA,\n\t\t       data, mask);\n}\n\nstatic void comphy_lane_reg_set(struct mvebu_a3700_comphy_lane *lane,\n\t\t\t\tu16 reg, u16 data, u16 mask)\n{\n\tif (lane->id == 2) {\n\t\t \n\t\tcomphy_set_indirect(lane->priv,\n\t\t\t\t    reg + COMPHY_LANE2_REGS_BASE,\n\t\t\t\t    data, mask);\n\t} else {\n\t\tvoid __iomem *base = lane->id == 1 ?\n\t\t\t\t     lane->priv->lane1_phy_regs :\n\t\t\t\t     lane->priv->lane0_phy_regs;\n\n\t\tcomphy_reg_set16(base + COMPHY_LANE_REG_DIRECT(reg),\n\t\t\t\t data, mask);\n\t}\n}\n\nstatic int comphy_lane_reg_poll(struct mvebu_a3700_comphy_lane *lane,\n\t\t\t\tu16 reg, u16 bits,\n\t\t\t\tulong sleep_us, ulong timeout_us)\n{\n\tint ret;\n\n\tif (lane->id == 2) {\n\t\tu32 data;\n\n\t\t \n\t\twritel(reg + COMPHY_LANE2_REGS_BASE,\n\t\t       lane->priv->lane2_phy_indirect +\n\t\t       COMPHY_LANE2_INDIR_ADDR);\n\n\t\tret = readl_poll_timeout(lane->priv->lane2_phy_indirect +\n\t\t\t\t\t COMPHY_LANE2_INDIR_DATA,\n\t\t\t\t\t data, (data & bits) == bits,\n\t\t\t\t\t sleep_us, timeout_us);\n\t} else {\n\t\tvoid __iomem *base = lane->id == 1 ?\n\t\t\t\t     lane->priv->lane1_phy_regs :\n\t\t\t\t     lane->priv->lane0_phy_regs;\n\t\tu16 data;\n\n\t\tret = readw_poll_timeout(base + COMPHY_LANE_REG_DIRECT(reg),\n\t\t\t\t\t data, (data & bits) == bits,\n\t\t\t\t\t sleep_us, timeout_us);\n\t}\n\n\treturn ret;\n}\n\nstatic void comphy_periph_reg_set(struct mvebu_a3700_comphy_lane *lane,\n\t\t\t\t  u8 reg, u32 data, u32 mask)\n{\n\tcomphy_reg_set(lane->priv->comphy_regs + COMPHY_PHY_REG(lane->id, reg),\n\t\t       data, mask);\n}\n\nstatic int comphy_periph_reg_poll(struct mvebu_a3700_comphy_lane *lane,\n\t\t\t\t  u8 reg, u32 bits,\n\t\t\t\t  ulong sleep_us, ulong timeout_us)\n{\n\tu32 data;\n\n\treturn readl_poll_timeout(lane->priv->comphy_regs +\n\t\t\t\t  COMPHY_PHY_REG(lane->id, reg),\n\t\t\t\t  data, (data & bits) == bits,\n\t\t\t\t  sleep_us, timeout_us);\n}\n\n \nstatic int\nmvebu_a3700_comphy_set_phy_selector(struct mvebu_a3700_comphy_lane *lane)\n{\n\tu32 old, new, clr = 0, set = 0;\n\tunsigned long flags;\n\n\tswitch (lane->mode) {\n\tcase PHY_MODE_SATA:\n\t\t \n\t\tif (lane->id == 2)\n\t\t\tclr = COMPHY_SELECTOR_USB3_PHY_SEL_BIT;\n\t\telse\n\t\t\tgoto error;\n\t\tbreak;\n\n\tcase PHY_MODE_ETHERNET:\n\t\tif (lane->id == 0)\n\t\t\tclr = COMPHY_SELECTOR_USB3_GBE1_SEL_BIT;\n\t\telse if (lane->id == 1)\n\t\t\tclr = COMPHY_SELECTOR_PCIE_GBE0_SEL_BIT;\n\t\telse\n\t\t\tgoto error;\n\t\tbreak;\n\n\tcase PHY_MODE_USB_HOST_SS:\n\t\tif (lane->id == 2)\n\t\t\tset = COMPHY_SELECTOR_USB3_PHY_SEL_BIT;\n\t\telse if (lane->id == 0)\n\t\t\tset = COMPHY_SELECTOR_USB3_GBE1_SEL_BIT;\n\t\telse\n\t\t\tgoto error;\n\t\tbreak;\n\n\tcase PHY_MODE_PCIE:\n\t\t \n\t\tif (lane->id == 1)\n\t\t\tset = COMPHY_SELECTOR_PCIE_GBE0_SEL_BIT;\n\t\telse\n\t\t\tgoto error;\n\t\tbreak;\n\n\tdefault:\n\t\tgoto error;\n\t}\n\n\tspin_lock_irqsave(&lane->priv->lock, flags);\n\n\told = readl(lane->priv->comphy_regs + COMPHY_SELECTOR_PHY_REG);\n\tnew = (old & ~clr) | set;\n\twritel(new, lane->priv->comphy_regs + COMPHY_SELECTOR_PHY_REG);\n\n\tspin_unlock_irqrestore(&lane->priv->lock, flags);\n\n\tdev_dbg(lane->dev,\n\t\t\"COMPHY[%d] mode[%d] changed PHY selector 0x%08x -> 0x%08x\\n\",\n\t\tlane->id, lane->mode, old, new);\n\n\treturn 0;\nerror:\n\tdev_err(lane->dev, \"COMPHY[%d] mode[%d] is invalid\\n\", lane->id,\n\t\tlane->mode);\n\treturn -EINVAL;\n}\n\nstatic int\nmvebu_a3700_comphy_sata_power_on(struct mvebu_a3700_comphy_lane *lane)\n{\n\tu32 mask, data, ref_clk;\n\tint ret;\n\n\t \n\tret = mvebu_a3700_comphy_set_phy_selector(lane);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_ISOLATION_CTRL,\n\t\t\t    0x0, PHY_ISOLATE_MODE);\n\n\t \n\tdata = 0x0;\n\tif (lane->invert_tx)\n\t\tdata |= TXD_INVERT_BIT;\n\tif (lane->invert_rx)\n\t\tdata |= RXD_INVERT_BIT;\n\tmask = TXD_INVERT_BIT | RXD_INVERT_BIT;\n\tcomphy_lane_reg_set(lane, COMPHY_SYNC_PATTERN, data, mask);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_DIG_LOOPBACK_EN,\n\t\t\t    DATA_WIDTH_40BIT, SEL_DATA_WIDTH_MASK);\n\n\t \n\tif (lane->priv->xtal_is_40m)\n\t\tref_clk = REF_FREF_SEL_SERDES_40MHZ;\n\telse\n\t\tref_clk = REF_FREF_SEL_SERDES_25MHZ;\n\n\tdata = ref_clk | COMPHY_MODE_SATA;\n\tmask = REF_FREF_SEL_MASK | COMPHY_MODE_MASK;\n\tcomphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL, data, mask);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_KVCO_CAL_CTRL,\n\t\t\t    USE_MAX_PLL_RATE_BIT, USE_MAX_PLL_RATE_BIT);\n\n\t \n\tcomphy_set_indirect(lane->priv, COMPHY_RESERVED_REG,\n\t\t\t    0x0, PHYCTRL_FRM_PIN_BIT);\n\n\t \n\t \n\n\t \n\tudelay(PLL_SET_DELAY_US);\n\n\t \n\tret = comphy_lane_reg_poll(lane, COMPHY_DIG_LOOPBACK_EN,\n\t\t\t\t   PLL_READY_TX_BIT, COMPHY_PLL_SLEEP,\n\t\t\t\t   COMPHY_PLL_TIMEOUT);\n\tif (ret)\n\t\tdev_err(lane->dev, \"Failed to lock SATA PLL\\n\");\n\n\treturn ret;\n}\n\nstatic void comphy_gbe_phy_init(struct mvebu_a3700_comphy_lane *lane,\n\t\t\t\tbool is_1gbps)\n{\n\tint addr, fix_idx;\n\tu16 val;\n\n\tfix_idx = 0;\n\tfor (addr = 0; addr < 512; addr++) {\n\t\t \n\t\tif (!is_1gbps && gbe_phy_init_fix[fix_idx].addr == addr) {\n\t\t\t \n\t\t\tval = gbe_phy_init_fix[fix_idx].value;\n\t\t\tif (fix_idx < ARRAY_SIZE(gbe_phy_init_fix))\n\t\t\t\tfix_idx++;\n\t\t} else {\n\t\t\tval = gbe_phy_init[addr];\n\t\t}\n\n\t\tcomphy_lane_reg_set(lane, addr, val, 0xFFFF);\n\t}\n}\n\nstatic int\nmvebu_a3700_comphy_ethernet_power_on(struct mvebu_a3700_comphy_lane *lane)\n{\n\tu32 mask, data, speed_sel;\n\tint ret;\n\n\t \n\tret = mvebu_a3700_comphy_set_phy_selector(lane);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdata = PIN_PU_IVREF_BIT | PIN_TX_IDLE_BIT | PIN_RESET_COMPHY_BIT;\n\tmask = data | PIN_RESET_CORE_BIT | PIN_PU_PLL_BIT | PIN_PU_RX_BIT |\n\t       PIN_PU_TX_BIT | PHY_RX_INIT_BIT;\n\tcomphy_periph_reg_set(lane, COMPHY_PHY_CFG1, data, mask);\n\n\t \n\tdata = 0x0;\n\tmask = PIN_RESET_COMPHY_BIT;\n\tcomphy_periph_reg_set(lane, COMPHY_PHY_CFG1, data, mask);\n\n\t \n\tswitch (lane->submode) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\t \n\t\tspeed_sel = SERDES_SPEED_1_25_G;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\t \n\t\tspeed_sel = SERDES_SPEED_3_125_G;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(lane->dev,\n\t\t\t\"unsupported phy speed %d on comphy lane%d\\n\",\n\t\t\tlane->submode, lane->id);\n\t\treturn -EINVAL;\n\t}\n\tdata = GEN_RX_SEL_VALUE(speed_sel) | GEN_TX_SEL_VALUE(speed_sel);\n\tmask = GEN_RX_SEL_MASK | GEN_TX_SEL_MASK;\n\tcomphy_periph_reg_set(lane, COMPHY_PHY_CFG1, data, mask);\n\n\t \n\tmdelay(10);\n\n\t \n\tdata = COMPHY_MODE_SERDES;\n\tmask = COMPHY_MODE_MASK;\n\tcomphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL, data, mask);\n\n\t \n\tdata = 0x0;\n\tmask = PHY_REF_CLK_SEL;\n\tcomphy_lane_reg_set(lane, COMPHY_MISC_CTRL0, data, mask);\n\n\t \n\tif (lane->priv->xtal_is_40m)\n\t\tdata = REF_FREF_SEL_SERDES_50MHZ;\n\telse\n\t\tdata = REF_FREF_SEL_SERDES_25MHZ;\n\n\tmask = REF_FREF_SEL_MASK;\n\tcomphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL, data, mask);\n\n\t \n\n\t \n\tdata = DATA_WIDTH_10BIT;\n\tmask = SEL_DATA_WIDTH_MASK;\n\tcomphy_lane_reg_set(lane, COMPHY_DIG_LOOPBACK_EN, data, mask);\n\n\t \n\n\t \n\tdev_dbg(lane->dev, \"Running C-DPI phy init %s mode\\n\",\n\t\tlane->submode == PHY_INTERFACE_MODE_2500BASEX ? \"2G5\" : \"1G\");\n\tif (lane->priv->xtal_is_40m)\n\t\tcomphy_gbe_phy_init(lane,\n\t\t\t\t    lane->submode != PHY_INTERFACE_MODE_2500BASEX);\n\n\t \n\tdata = 0x0;\n\tif (lane->invert_tx)\n\t\tdata |= TXD_INVERT_BIT;\n\tif (lane->invert_rx)\n\t\tdata |= RXD_INVERT_BIT;\n\tmask = TXD_INVERT_BIT | RXD_INVERT_BIT;\n\tcomphy_lane_reg_set(lane, COMPHY_SYNC_PATTERN, data, mask);\n\n\t \n\tdata = PIN_PU_PLL_BIT | PIN_PU_RX_BIT | PIN_PU_TX_BIT;\n\tmask = data;\n\tcomphy_periph_reg_set(lane, COMPHY_PHY_CFG1, data, mask);\n\n\t \n\tret = comphy_periph_reg_poll(lane, COMPHY_PHY_STAT1,\n\t\t\t\t     PHY_PLL_READY_TX_BIT |\n\t\t\t\t     PHY_PLL_READY_RX_BIT,\n\t\t\t\t     COMPHY_PLL_SLEEP, COMPHY_PLL_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(lane->dev, \"Failed to lock PLL for SERDES PHY %d\\n\",\n\t\t\tlane->id);\n\t\treturn ret;\n\t}\n\n\t \n\tcomphy_periph_reg_set(lane, COMPHY_PHY_CFG1, 0x0, PIN_TX_IDLE_BIT);\n\n\t \n\tcomphy_periph_reg_set(lane, COMPHY_PHY_CFG1,\n\t\t\t      PHY_RX_INIT_BIT, PHY_RX_INIT_BIT);\n\n\tret = comphy_periph_reg_poll(lane, COMPHY_PHY_STAT1,\n\t\t\t\t     PHY_PLL_READY_TX_BIT |\n\t\t\t\t     PHY_PLL_READY_RX_BIT,\n\t\t\t\t     COMPHY_PLL_SLEEP, COMPHY_PLL_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(lane->dev, \"Failed to lock PLL for SERDES PHY %d\\n\",\n\t\t\tlane->id);\n\t\treturn ret;\n\t}\n\n\tret = comphy_periph_reg_poll(lane, COMPHY_PHY_STAT1,\n\t\t\t\t     PHY_RX_INIT_DONE_BIT,\n\t\t\t\t     COMPHY_PLL_SLEEP, COMPHY_PLL_TIMEOUT);\n\tif (ret)\n\t\tdev_err(lane->dev, \"Failed to init RX of SERDES PHY %d\\n\",\n\t\t\tlane->id);\n\n\treturn ret;\n}\n\nstatic int\nmvebu_a3700_comphy_usb3_power_on(struct mvebu_a3700_comphy_lane *lane)\n{\n\tu32 mask, data, cfg, ref_clk;\n\tint ret;\n\n\t \n\tret = mvebu_a3700_comphy_set_phy_selector(lane);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_SFT_RESET, SFT_RST, SFT_RST);\n\n\t \n\n\t \n\tdata = PRD_TXDEEMPH0_MASK;\n\tmask = PRD_TXDEEMPH0_MASK | PRD_TXMARGIN_MASK | PRD_TXSWING_MASK |\n\t       CFG_TX_ALIGN_POS_MASK;\n\tcomphy_lane_reg_set(lane, COMPHY_PIPE_LANE_CFG0, data, mask);\n\n\t \n\tdata = TX_DET_RX_MODE | GEN2_TX_DATA_DLY_DEFT | TX_ELEC_IDLE_MODE_EN;\n\tmask = PRD_TXDEEMPH1_MASK | TX_DET_RX_MODE | GEN2_TX_DATA_DLY_MASK |\n\t       TX_ELEC_IDLE_MODE_EN;\n\tcomphy_lane_reg_set(lane, COMPHY_PIPE_LANE_CFG1, data, mask);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_PIPE_LANE_CFG4,\n\t\t\t    SPREAD_SPECTRUM_CLK_EN, SPREAD_SPECTRUM_CLK_EN);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_PIPE_TEST_MODE_CTRL,\n\t\t\t    MODE_MARGIN_OVERRIDE, 0xFFFF);\n\n\t \n\tdata = 0x0;\n\tmask = MODE_CLK_SRC | BUNDLE_PERIOD_SEL | BUNDLE_PERIOD_SCALE_MASK |\n\t       BUNDLE_SAMPLE_CTRL | PLL_READY_DLY_MASK;\n\tcomphy_lane_reg_set(lane, COMPHY_PIPE_CLK_SRC_LO, data, mask);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_GEN2_SET2,\n\t\t\t    GS2_TX_SSC_AMP_4128, GS2_TX_SSC_AMP_MASK);\n\n\t \n\tdata = GS2_VREG_RXTX_MAS_ISET_60U;\n\tmask = GS2_TX_SSC_AMP_MASK | GS2_VREG_RXTX_MAS_ISET_MASK |\n\t       GS2_RSVD_6_0_MASK;\n\tcomphy_lane_reg_set(lane, COMPHY_GEN3_SET2, data, mask);\n\n\t \n\tif (lane->priv->xtal_is_40m) {\n\t\tref_clk = REF_FREF_SEL_PCIE_USB3_40MHZ;\n\t\tcfg = CFG_PM_RXDLOZ_WAIT_12_UNIT;\n\t} else {\n\t\tref_clk = REF_FREF_SEL_PCIE_USB3_25MHZ;\n\t\tcfg = CFG_PM_RXDLOZ_WAIT_7_UNIT;\n\t}\n\n\tdata = PU_IVREF_BIT | PU_PLL_BIT | PU_RX_BIT | PU_TX_BIT |\n\t       PU_TX_INTP_BIT | PU_DFE_BIT | COMPHY_MODE_USB3 | ref_clk;\n\tmask = PU_IVREF_BIT | PU_PLL_BIT | PU_RX_BIT | PU_TX_BIT |\n\t       PU_TX_INTP_BIT | PU_DFE_BIT | PLL_LOCK_BIT | COMPHY_MODE_MASK |\n\t       REF_FREF_SEL_MASK;\n\tcomphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL, data, mask);\n\n\tdata = CFG_PM_RXDEN_WAIT_1_UNIT | cfg;\n\tmask = CFG_PM_OSCCLK_WAIT_MASK | CFG_PM_RXDEN_WAIT_MASK |\n\t       CFG_PM_RXDLOZ_WAIT_MASK;\n\tcomphy_lane_reg_set(lane, COMPHY_PIPE_PWR_MGM_TIM1, data, mask);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_IDLE_SYNC_EN,\n\t\t\t    IDLE_SYNC_EN, IDLE_SYNC_EN);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_MISC_CTRL0, CLK500M_EN, CLK500M_EN);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_DIG_LOOPBACK_EN,\n\t\t\t    DATA_WIDTH_20BIT, 0xFFFF);\n\n\t \n\tdata = SPEED_PLL_VALUE_16 | USE_MAX_PLL_RATE_BIT;\n\tmask = 0xFFFF;\n\tcomphy_lane_reg_set(lane, COMPHY_KVCO_CAL_CTRL, data, mask);\n\n\t \n\tdata = 0x0;\n\tif (lane->invert_tx)\n\t\tdata |= TXD_INVERT_BIT;\n\tif (lane->invert_rx)\n\t\tdata |= RXD_INVERT_BIT;\n\tmask = TXD_INVERT_BIT | RXD_INVERT_BIT;\n\tcomphy_lane_reg_set(lane, COMPHY_SYNC_PATTERN, data, mask);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_SYNC_MASK_GEN,\n\t\t\t    PHY_GEN_MAX_USB3_5G, PHY_GEN_MAX_MASK);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_GEN2_SET3,\n\t\t\t    GS3_FFE_CAP_SEL_VALUE, GS3_FFE_CAP_SEL_MASK);\n\n\t \n\tdata = MODE_CORE_CLK_FREQ_SEL | MODE_PIPE_WIDTH_32 | MODE_REFDIV_BY_4;\n\tmask = 0xFFFF;\n\tcomphy_lane_reg_set(lane, COMPHY_PIPE_RST_CLK_CTRL, data, mask);\n\n\t \n\tudelay(PLL_SET_DELAY_US);\n\n\tret = comphy_lane_reg_poll(lane, COMPHY_PIPE_LANE_STAT1, TXDCLK_PCLK_EN,\n\t\t\t\t   COMPHY_PLL_SLEEP, COMPHY_PLL_TIMEOUT);\n\tif (ret)\n\t\tdev_err(lane->dev, \"Failed to lock USB3 PLL\\n\");\n\n\treturn ret;\n}\n\nstatic int\nmvebu_a3700_comphy_pcie_power_on(struct mvebu_a3700_comphy_lane *lane)\n{\n\tu32 mask, data, ref_clk;\n\tint ret;\n\n\t \n\tret = mvebu_a3700_comphy_set_phy_selector(lane);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_PIPE_LANE_CFG1,\n\t\t\t    USE_MAX_PLL_RATE_EN, USE_MAX_PLL_RATE_EN);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_PIPE_CLK_SRC_LO,\n\t\t\t    CFG_SEL_20B, CFG_SEL_20B);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_MISC_CTRL1,\n\t\t\t    SEL_BITS_PCIE_FORCE, SEL_BITS_PCIE_FORCE);\n\n\t \n\tdata = CFG_PM_RXDEN_WAIT_1_UNIT | CFG_PM_RXDLOZ_WAIT_12_UNIT;\n\tmask = CFG_PM_OSCCLK_WAIT_MASK | CFG_PM_RXDEN_WAIT_MASK |\n\t       CFG_PM_RXDLOZ_WAIT_MASK;\n\tcomphy_lane_reg_set(lane, COMPHY_PIPE_PWR_MGM_TIM1, data, mask);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_IDLE_SYNC_EN,\n\t\t\t    IDLE_SYNC_EN, IDLE_SYNC_EN);\n\n\t \n\tdata = CLK500M_EN | TXDCLK_2X_SEL | CLK100M_125M_EN;\n\tmask = data;\n\tcomphy_lane_reg_set(lane, COMPHY_MISC_CTRL0, data, mask);\n\n\t \n\n\t \n\n\tif (lane->priv->xtal_is_40m)\n\t\tref_clk = REF_FREF_SEL_PCIE_USB3_40MHZ;\n\telse\n\t\tref_clk = REF_FREF_SEL_PCIE_USB3_25MHZ;\n\n\tdata = PU_IVREF_BIT | PU_PLL_BIT | PU_RX_BIT | PU_TX_BIT |\n\t       PU_TX_INTP_BIT | PU_DFE_BIT | COMPHY_MODE_PCIE | ref_clk;\n\tmask = 0xFFFF;\n\tcomphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL, data, mask);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_KVCO_CAL_CTRL,\n\t\t\t    SPEED_PLL_VALUE_16 | USE_MAX_PLL_RATE_BIT,\n\t\t\t    0xFFFF);\n\n\t \n\tdata = 0x0;\n\tif (lane->invert_tx)\n\t\tdata |= TXD_INVERT_BIT;\n\tif (lane->invert_rx)\n\t\tdata |= RXD_INVERT_BIT;\n\tmask = TXD_INVERT_BIT | RXD_INVERT_BIT;\n\tcomphy_lane_reg_set(lane, COMPHY_SYNC_PATTERN, data, mask);\n\n\t \n\tdata = MODE_CORE_CLK_FREQ_SEL | MODE_PIPE_WIDTH_32;\n\tmask = data | PIPE_SOFT_RESET | MODE_REFDIV_MASK;\n\tcomphy_lane_reg_set(lane, COMPHY_PIPE_RST_CLK_CTRL, data, mask);\n\n\t \n\tudelay(PLL_SET_DELAY_US);\n\n\tret = comphy_lane_reg_poll(lane, COMPHY_PIPE_LANE_STAT1, TXDCLK_PCLK_EN,\n\t\t\t\t   COMPHY_PLL_SLEEP, COMPHY_PLL_TIMEOUT);\n\tif (ret)\n\t\tdev_err(lane->dev, \"Failed to lock PCIE PLL\\n\");\n\n\treturn ret;\n}\n\nstatic void\nmvebu_a3700_comphy_sata_power_off(struct mvebu_a3700_comphy_lane *lane)\n{\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_ISOLATION_CTRL,\n\t\t\t    PHY_ISOLATE_MODE, PHY_ISOLATE_MODE);\n\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL,\n\t\t\t    0x0, PU_PLL_BIT | PU_RX_BIT | PU_TX_BIT);\n}\n\nstatic void\nmvebu_a3700_comphy_ethernet_power_off(struct mvebu_a3700_comphy_lane *lane)\n{\n\tu32 mask, data;\n\n\tdata = PIN_RESET_CORE_BIT | PIN_RESET_COMPHY_BIT | PIN_PU_IVREF_BIT |\n\t       PHY_RX_INIT_BIT;\n\tmask = data;\n\tcomphy_periph_reg_set(lane, COMPHY_PHY_CFG1, data, mask);\n}\n\nstatic void\nmvebu_a3700_comphy_pcie_power_off(struct mvebu_a3700_comphy_lane *lane)\n{\n\t \n\tcomphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL,\n\t\t\t    0x0, PU_PLL_BIT | PU_RX_BIT | PU_TX_BIT);\n}\n\nstatic void mvebu_a3700_comphy_usb3_power_off(struct mvebu_a3700_comphy_lane *lane)\n{\n\t \n}\n\nstatic bool mvebu_a3700_comphy_check_mode(int lane,\n\t\t\t\t\t  enum phy_mode mode,\n\t\t\t\t\t  int submode)\n{\n\tint i, n = ARRAY_SIZE(mvebu_a3700_comphy_modes);\n\n\t \n\tif (mode == PHY_MODE_INVALID)\n\t\treturn false;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (mvebu_a3700_comphy_modes[i].lane == lane &&\n\t\t    mvebu_a3700_comphy_modes[i].mode == mode &&\n\t\t    mvebu_a3700_comphy_modes[i].submode == submode)\n\t\t\tbreak;\n\t}\n\n\tif (i == n)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int mvebu_a3700_comphy_set_mode(struct phy *phy, enum phy_mode mode,\n\t\t\t\t       int submode)\n{\n\tstruct mvebu_a3700_comphy_lane *lane = phy_get_drvdata(phy);\n\n\tif (!mvebu_a3700_comphy_check_mode(lane->id, mode, submode)) {\n\t\tdev_err(lane->dev, \"invalid COMPHY mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (phy->power_count &&\n\t    (lane->mode != mode || lane->submode != submode))\n\t\treturn -EBUSY;\n\n\t \n\tlane->mode = mode;\n\tlane->submode = submode;\n\n\treturn 0;\n}\n\nstatic int mvebu_a3700_comphy_power_on(struct phy *phy)\n{\n\tstruct mvebu_a3700_comphy_lane *lane = phy_get_drvdata(phy);\n\n\tif (!mvebu_a3700_comphy_check_mode(lane->id, lane->mode,\n\t\t\t\t\t   lane->submode)) {\n\t\tdev_err(lane->dev, \"invalid COMPHY mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (lane->mode) {\n\tcase PHY_MODE_USB_HOST_SS:\n\t\tdev_dbg(lane->dev, \"set lane %d to USB3 host mode\\n\", lane->id);\n\t\treturn mvebu_a3700_comphy_usb3_power_on(lane);\n\tcase PHY_MODE_SATA:\n\t\tdev_dbg(lane->dev, \"set lane %d to SATA mode\\n\", lane->id);\n\t\treturn mvebu_a3700_comphy_sata_power_on(lane);\n\tcase PHY_MODE_ETHERNET:\n\t\tdev_dbg(lane->dev, \"set lane %d to Ethernet mode\\n\", lane->id);\n\t\treturn mvebu_a3700_comphy_ethernet_power_on(lane);\n\tcase PHY_MODE_PCIE:\n\t\tdev_dbg(lane->dev, \"set lane %d to PCIe mode\\n\", lane->id);\n\t\treturn mvebu_a3700_comphy_pcie_power_on(lane);\n\tdefault:\n\t\tdev_err(lane->dev, \"unsupported PHY mode (%d)\\n\", lane->mode);\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mvebu_a3700_comphy_power_off(struct phy *phy)\n{\n\tstruct mvebu_a3700_comphy_lane *lane = phy_get_drvdata(phy);\n\n\tswitch (lane->id) {\n\tcase 0:\n\t\tmvebu_a3700_comphy_usb3_power_off(lane);\n\t\tmvebu_a3700_comphy_ethernet_power_off(lane);\n\t\treturn 0;\n\tcase 1:\n\t\tmvebu_a3700_comphy_pcie_power_off(lane);\n\t\tmvebu_a3700_comphy_ethernet_power_off(lane);\n\t\treturn 0;\n\tcase 2:\n\t\tmvebu_a3700_comphy_usb3_power_off(lane);\n\t\tmvebu_a3700_comphy_sata_power_off(lane);\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(lane->dev, \"invalid COMPHY mode\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct phy_ops mvebu_a3700_comphy_ops = {\n\t.power_on\t= mvebu_a3700_comphy_power_on,\n\t.power_off\t= mvebu_a3700_comphy_power_off,\n\t.set_mode\t= mvebu_a3700_comphy_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *mvebu_a3700_comphy_xlate(struct device *dev,\n\t\t\t\t\t    struct of_phandle_args *args)\n{\n\tstruct mvebu_a3700_comphy_lane *lane;\n\tunsigned int port;\n\tstruct phy *phy;\n\n\tphy = of_phy_simple_xlate(dev, args);\n\tif (IS_ERR(phy))\n\t\treturn phy;\n\n\tlane = phy_get_drvdata(phy);\n\n\tport = args->args[0];\n\tif (port != 0 && (port != 1 || lane->id != 0)) {\n\t\tdev_err(lane->dev, \"invalid port number %u\\n\", port);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlane->invert_tx = args->args[1] & BIT(0);\n\tlane->invert_rx = args->args[1] & BIT(1);\n\n\treturn phy;\n}\n\nstatic int mvebu_a3700_comphy_probe(struct platform_device *pdev)\n{\n\tstruct mvebu_a3700_comphy_priv *priv;\n\tstruct phy_provider *provider;\n\tstruct device_node *child;\n\tstruct resource *res;\n\tstruct clk *clk;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"comphy\");\n\tpriv->comphy_regs = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(priv->comphy_regs))\n\t\treturn PTR_ERR(priv->comphy_regs);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"lane1_pcie_gbe\");\n\tpriv->lane1_phy_regs = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(priv->lane1_phy_regs))\n\t\treturn PTR_ERR(priv->lane1_phy_regs);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"lane0_usb3_gbe\");\n\tpriv->lane0_phy_regs = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(priv->lane0_phy_regs))\n\t\treturn PTR_ERR(priv->lane0_phy_regs);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"lane2_sata_usb3\");\n\tpriv->lane2_phy_indirect = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(priv->lane2_phy_indirect))\n\t\treturn PTR_ERR(priv->lane2_phy_indirect);\n\n\t \n\tclk = clk_get(&pdev->dev, \"xtal\");\n\tif (IS_ERR(clk)) {\n\t\tif (PTR_ERR(clk) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_warn(&pdev->dev, \"missing 'xtal' clk (%ld)\\n\",\n\t\t\t PTR_ERR(clk));\n\t} else {\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret) {\n\t\t\tdev_warn(&pdev->dev, \"enabling xtal clk failed (%d)\\n\",\n\t\t\t\t ret);\n\t\t} else {\n\t\t\tif (clk_get_rate(clk) == 40000000)\n\t\t\t\tpriv->xtal_is_40m = true;\n\t\t\tclk_disable_unprepare(clk);\n\t\t}\n\t\tclk_put(clk);\n\t}\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\tfor_each_available_child_of_node(pdev->dev.of_node, child) {\n\t\tstruct mvebu_a3700_comphy_lane *lane;\n\t\tstruct phy *phy;\n\t\tint ret;\n\t\tu32 lane_id;\n\n\t\tret = of_property_read_u32(child, \"reg\", &lane_id);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"missing 'reg' property (%d)\\n\",\n\t\t\t\tret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (lane_id >= 3) {\n\t\t\tdev_err(&pdev->dev, \"invalid 'reg' property\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tlane = devm_kzalloc(&pdev->dev, sizeof(*lane), GFP_KERNEL);\n\t\tif (!lane) {\n\t\t\tof_node_put(child);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tphy = devm_phy_create(&pdev->dev, child,\n\t\t\t\t      &mvebu_a3700_comphy_ops);\n\t\tif (IS_ERR(phy)) {\n\t\t\tof_node_put(child);\n\t\t\treturn PTR_ERR(phy);\n\t\t}\n\n\t\tlane->priv = priv;\n\t\tlane->dev = &pdev->dev;\n\t\tlane->mode = PHY_MODE_INVALID;\n\t\tlane->submode = PHY_INTERFACE_MODE_NA;\n\t\tlane->id = lane_id;\n\t\tlane->invert_tx = false;\n\t\tlane->invert_rx = false;\n\t\tphy_set_drvdata(phy, lane);\n\n\t\t \n\t\tmvebu_a3700_comphy_power_off(phy);\n\t}\n\n\tprovider = devm_of_phy_provider_register(&pdev->dev,\n\t\t\t\t\t\t mvebu_a3700_comphy_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic const struct of_device_id mvebu_a3700_comphy_of_match_table[] = {\n\t{ .compatible = \"marvell,comphy-a3700\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mvebu_a3700_comphy_of_match_table);\n\nstatic struct platform_driver mvebu_a3700_comphy_driver = {\n\t.probe\t= mvebu_a3700_comphy_probe,\n\t.driver\t= {\n\t\t.name = \"mvebu-a3700-comphy\",\n\t\t.of_match_table = mvebu_a3700_comphy_of_match_table,\n\t},\n};\nmodule_platform_driver(mvebu_a3700_comphy_driver);\n\nMODULE_AUTHOR(\"Miqu\u00e8l Raynal <miquel.raynal@bootlin.com>\");\nMODULE_AUTHOR(\"Pali Roh\u00e1r <pali@kernel.org>\");\nMODULE_AUTHOR(\"Marek Beh\u00fan <kabel@kernel.org>\");\nMODULE_DESCRIPTION(\"Common PHY driver for A3700\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}