{
  "module_name": "phy-pxa-28nm-usb2.c",
  "hash_id": "a378fc95d699ecccd871e9ea235ddae9c249bffad4e036329ca522d39c83f3c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/marvell/phy-pxa-28nm-usb2.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n\n \n#define PHY_28NM_PLL_REG0\t\t\t0x0\n#define PHY_28NM_PLL_REG1\t\t\t0x4\n#define PHY_28NM_CAL_REG\t\t\t0x8\n#define PHY_28NM_TX_REG0\t\t\t0x0c\n#define PHY_28NM_TX_REG1\t\t\t0x10\n#define PHY_28NM_RX_REG0\t\t\t0x14\n#define PHY_28NM_RX_REG1\t\t\t0x18\n#define PHY_28NM_DIG_REG0\t\t\t0x1c\n#define PHY_28NM_DIG_REG1\t\t\t0x20\n#define PHY_28NM_TEST_REG0\t\t\t0x24\n#define PHY_28NM_TEST_REG1\t\t\t0x28\n#define PHY_28NM_MOC_REG\t\t\t0x2c\n#define PHY_28NM_PHY_RESERVE\t\t\t0x30\n#define PHY_28NM_OTG_REG\t\t\t0x34\n#define PHY_28NM_CHRG_DET\t\t\t0x38\n#define PHY_28NM_CTRL_REG0\t\t\t0xc4\n#define PHY_28NM_CTRL_REG1\t\t\t0xc8\n#define PHY_28NM_CTRL_REG2\t\t\t0xd4\n#define PHY_28NM_CTRL_REG3\t\t\t0xdc\n\n \n#define PHY_28NM_PLL_READY\t\t\tBIT(31)\n\n#define PHY_28NM_PLL_SELLPFR_SHIFT\t\t28\n#define PHY_28NM_PLL_SELLPFR_MASK\t\t(0x3 << 28)\n\n#define PHY_28NM_PLL_FBDIV_SHIFT\t\t16\n#define PHY_28NM_PLL_FBDIV_MASK\t\t\t(0x1ff << 16)\n\n#define PHY_28NM_PLL_ICP_SHIFT\t\t\t8\n#define PHY_28NM_PLL_ICP_MASK\t\t\t(0x7 << 8)\n\n#define PHY_28NM_PLL_REFDIV_SHIFT\t\t0\n#define PHY_28NM_PLL_REFDIV_MASK\t\t0x7f\n\n \n#define PHY_28NM_PLL_PU_BY_REG\t\t\tBIT(1)\n\n#define PHY_28NM_PLL_PU_PLL\t\t\tBIT(0)\n\n \n#define PHY_28NM_PLL_PLLCAL_DONE\t\tBIT(31)\n\n#define PHY_28NM_PLL_IMPCAL_DONE\t\tBIT(23)\n\n#define PHY_28NM_PLL_KVCO_SHIFT\t\t\t16\n#define PHY_28NM_PLL_KVCO_MASK\t\t\t(0x7 << 16)\n\n#define PHY_28NM_PLL_CAL12_SHIFT\t\t20\n#define PHY_28NM_PLL_CAL12_MASK\t\t\t(0x3 << 20)\n\n#define PHY_28NM_IMPCAL_VTH_SHIFT\t\t8\n#define PHY_28NM_IMPCAL_VTH_MASK\t\t(0x7 << 8)\n\n#define PHY_28NM_PLLCAL_START_SHIFT\t\t22\n#define PHY_28NM_IMPCAL_START_SHIFT\t\t13\n\n \n#define PHY_28NM_TX_PU_BY_REG\t\t\tBIT(25)\n\n#define PHY_28NM_TX_PU_ANA\t\t\tBIT(24)\n\n#define PHY_28NM_TX_AMP_SHIFT\t\t\t20\n#define PHY_28NM_TX_AMP_MASK\t\t\t(0x7 << 20)\n\n \n#define PHY_28NM_RX_SQ_THRESH_SHIFT\t\t0\n#define PHY_28NM_RX_SQ_THRESH_MASK\t\t(0xf << 0)\n\n \n#define PHY_28NM_RX_SQCAL_DONE\t\t\tBIT(31)\n\n \n#define PHY_28NM_DIG_BITSTAFFING_ERR\t\tBIT(31)\n#define PHY_28NM_DIG_SYNC_ERR\t\t\tBIT(30)\n\n#define PHY_28NM_DIG_SQ_FILT_SHIFT\t\t16\n#define PHY_28NM_DIG_SQ_FILT_MASK\t\t(0x7 << 16)\n\n#define PHY_28NM_DIG_SQ_BLK_SHIFT\t\t12\n#define PHY_28NM_DIG_SQ_BLK_MASK\t\t(0x7 << 12)\n\n#define PHY_28NM_DIG_SYNC_NUM_SHIFT\t\t0\n#define PHY_28NM_DIG_SYNC_NUM_MASK\t\t(0x3 << 0)\n\n#define PHY_28NM_PLL_LOCK_BYPASS\t\tBIT(7)\n\n \n#define PHY_28NM_OTG_CONTROL_BY_PIN\t\tBIT(5)\n#define PHY_28NM_OTG_PU_OTG\t\t\tBIT(4)\n\n#define PHY_28NM_CHGDTC_ENABLE_SWITCH_DM_SHIFT_28 13\n#define PHY_28NM_CHGDTC_ENABLE_SWITCH_DP_SHIFT_28 12\n#define PHY_28NM_CHGDTC_VSRC_CHARGE_SHIFT_28\t10\n#define PHY_28NM_CHGDTC_VDAT_CHARGE_SHIFT_28\t8\n#define PHY_28NM_CHGDTC_CDP_DM_AUTO_SWITCH_SHIFT_28 7\n#define PHY_28NM_CHGDTC_DP_DM_SWAP_SHIFT_28\t6\n#define PHY_28NM_CHGDTC_PU_CHRG_DTC_SHIFT_28\t5\n#define PHY_28NM_CHGDTC_PD_EN_SHIFT_28\t\t4\n#define PHY_28NM_CHGDTC_DCP_EN_SHIFT_28\t\t3\n#define PHY_28NM_CHGDTC_CDP_EN_SHIFT_28\t\t2\n#define PHY_28NM_CHGDTC_TESTMON_CHRGDTC_SHIFT_28 0\n\n#define PHY_28NM_CTRL1_CHRG_DTC_OUT_SHIFT_28\t4\n#define PHY_28NM_CTRL1_VBUSDTC_OUT_SHIFT_28\t2\n\n#define PHY_28NM_CTRL3_OVERWRITE\t\tBIT(0)\n#define PHY_28NM_CTRL3_VBUS_VALID\t\tBIT(4)\n#define PHY_28NM_CTRL3_AVALID\t\t\tBIT(5)\n#define PHY_28NM_CTRL3_BVALID\t\t\tBIT(6)\n\nstruct mv_usb2_phy {\n\tstruct phy\t\t*phy;\n\tstruct platform_device\t*pdev;\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n};\n\nstatic int wait_for_reg(void __iomem *reg, u32 mask, u32 ms)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(reg, val, ((val & mask) == mask),\n\t\t\t\t   1000, 1000 * ms);\n}\n\nstatic int mv_usb2_phy_28nm_init(struct phy *phy)\n{\n\tstruct mv_usb2_phy *mv_phy = phy_get_drvdata(phy);\n\tstruct platform_device *pdev = mv_phy->pdev;\n\tvoid __iomem *base = mv_phy->base;\n\tu32 reg;\n\tint ret;\n\n\tclk_prepare_enable(mv_phy->clk);\n\n\t \n\treg = readl(base + PHY_28NM_PLL_REG0) &\n\t\t~(PHY_28NM_PLL_SELLPFR_MASK | PHY_28NM_PLL_FBDIV_MASK\n\t\t| PHY_28NM_PLL_ICP_MASK\t| PHY_28NM_PLL_REFDIV_MASK);\n\twritel(reg | (0x1 << PHY_28NM_PLL_SELLPFR_SHIFT\n\t\t| 0xf0 << PHY_28NM_PLL_FBDIV_SHIFT\n\t\t| 0x3 << PHY_28NM_PLL_ICP_SHIFT\n\t\t| 0xd << PHY_28NM_PLL_REFDIV_SHIFT),\n\t\tbase + PHY_28NM_PLL_REG0);\n\n\t \n\treg = readl(base + PHY_28NM_PLL_REG1);\n\twritel(reg | PHY_28NM_PLL_PU_PLL | PHY_28NM_PLL_PU_BY_REG,\n\t\tbase + PHY_28NM_PLL_REG1);\n\n\t \n\treg = readl(base + PHY_28NM_TX_REG0) & ~PHY_28NM_TX_AMP_MASK;\n\twritel(reg | PHY_28NM_TX_PU_BY_REG | 0x3 << PHY_28NM_TX_AMP_SHIFT |\n\t\tPHY_28NM_TX_PU_ANA,\n\t\tbase + PHY_28NM_TX_REG0);\n\n\t \n\treg = readl(base + PHY_28NM_RX_REG0) & ~PHY_28NM_RX_SQ_THRESH_MASK;\n\twritel(reg | 0xa << PHY_28NM_RX_SQ_THRESH_SHIFT,\n\t\tbase + PHY_28NM_RX_REG0);\n\n\t \n\treg = readl(base + PHY_28NM_DIG_REG0) &\n\t\t~(PHY_28NM_DIG_BITSTAFFING_ERR | PHY_28NM_DIG_SYNC_ERR |\n\t\tPHY_28NM_DIG_SQ_FILT_MASK | PHY_28NM_DIG_SQ_BLK_MASK |\n\t\tPHY_28NM_DIG_SYNC_NUM_MASK);\n\twritel(reg | (0x1 << PHY_28NM_DIG_SYNC_NUM_SHIFT |\n\t\tPHY_28NM_PLL_LOCK_BYPASS),\n\t\tbase + PHY_28NM_DIG_REG0);\n\n\t \n\treg = readl(base + PHY_28NM_OTG_REG) | PHY_28NM_OTG_PU_OTG;\n\twritel(reg & ~PHY_28NM_OTG_CONTROL_BY_PIN, base + PHY_28NM_OTG_REG);\n\n\t \n\n\t \n\tret = wait_for_reg(base + PHY_28NM_CAL_REG,\n\t\t\t   PHY_28NM_PLL_PLLCAL_DONE | PHY_28NM_PLL_IMPCAL_DONE,\n\t\t\t   100);\n\tif (ret) {\n\t\tdev_warn(&pdev->dev, \"USB PHY PLL calibrate not done after 100mS.\");\n\t\tgoto err_clk;\n\t}\n\tret = wait_for_reg(base + PHY_28NM_RX_REG1,\n\t\t\t   PHY_28NM_RX_SQCAL_DONE, 100);\n\tif (ret) {\n\t\tdev_warn(&pdev->dev, \"USB PHY RX SQ calibrate not done after 100mS.\");\n\t\tgoto err_clk;\n\t}\n\t \n\tret = wait_for_reg(base + PHY_28NM_PLL_REG0, PHY_28NM_PLL_READY, 100);\n\tif (ret) {\n\t\tdev_warn(&pdev->dev, \"PLL_READY not set after 100mS.\");\n\t\tgoto err_clk;\n\t}\n\n\treturn 0;\nerr_clk:\n\tclk_disable_unprepare(mv_phy->clk);\n\treturn ret;\n}\n\nstatic int mv_usb2_phy_28nm_power_on(struct phy *phy)\n{\n\tstruct mv_usb2_phy *mv_phy = phy_get_drvdata(phy);\n\tvoid __iomem *base = mv_phy->base;\n\n\twritel(readl(base + PHY_28NM_CTRL_REG3) |\n\t\t(PHY_28NM_CTRL3_OVERWRITE | PHY_28NM_CTRL3_VBUS_VALID |\n\t\tPHY_28NM_CTRL3_AVALID | PHY_28NM_CTRL3_BVALID),\n\t\tbase + PHY_28NM_CTRL_REG3);\n\n\treturn 0;\n}\n\nstatic int mv_usb2_phy_28nm_power_off(struct phy *phy)\n{\n\tstruct mv_usb2_phy *mv_phy = phy_get_drvdata(phy);\n\tvoid __iomem *base = mv_phy->base;\n\n\twritel(readl(base + PHY_28NM_CTRL_REG3) |\n\t\t~(PHY_28NM_CTRL3_OVERWRITE | PHY_28NM_CTRL3_VBUS_VALID\n\t\t| PHY_28NM_CTRL3_AVALID\t| PHY_28NM_CTRL3_BVALID),\n\t\tbase + PHY_28NM_CTRL_REG3);\n\n\treturn 0;\n}\n\nstatic int mv_usb2_phy_28nm_exit(struct phy *phy)\n{\n\tstruct mv_usb2_phy *mv_phy = phy_get_drvdata(phy);\n\tvoid __iomem *base = mv_phy->base;\n\tunsigned int val;\n\n\tval = readw(base + PHY_28NM_PLL_REG1);\n\tval &= ~PHY_28NM_PLL_PU_PLL;\n\twritew(val, base + PHY_28NM_PLL_REG1);\n\n\t \n\tval = readw(base + PHY_28NM_TX_REG0);\n\tval &= ~PHY_28NM_TX_PU_ANA;\n\twritew(val, base + PHY_28NM_TX_REG0);\n\n\t \n\tval = readw(base + PHY_28NM_OTG_REG);\n\tval &= ~PHY_28NM_OTG_PU_OTG;\n\twritew(val, base + PHY_28NM_OTG_REG);\n\n\tclk_disable_unprepare(mv_phy->clk);\n\treturn 0;\n}\n\nstatic const struct phy_ops usb_ops = {\n\t.init\t\t= mv_usb2_phy_28nm_init,\n\t.power_on\t= mv_usb2_phy_28nm_power_on,\n\t.power_off\t= mv_usb2_phy_28nm_power_off,\n\t.exit\t\t= mv_usb2_phy_28nm_exit,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int mv_usb2_phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct mv_usb2_phy *mv_phy;\n\n\tmv_phy = devm_kzalloc(&pdev->dev, sizeof(*mv_phy), GFP_KERNEL);\n\tif (!mv_phy)\n\t\treturn -ENOMEM;\n\n\tmv_phy->pdev = pdev;\n\n\tmv_phy->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(mv_phy->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock.\\n\");\n\t\treturn PTR_ERR(mv_phy->clk);\n\t}\n\n\tmv_phy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mv_phy->base))\n\t\treturn PTR_ERR(mv_phy->base);\n\n\tmv_phy->phy = devm_phy_create(&pdev->dev, pdev->dev.of_node, &usb_ops);\n\tif (IS_ERR(mv_phy->phy))\n\t\treturn PTR_ERR(mv_phy->phy);\n\n\tphy_set_drvdata(mv_phy->phy, mv_phy);\n\n\tphy_provider = devm_of_phy_provider_register(&pdev->dev, of_phy_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id mv_usbphy_dt_match[] = {\n\t{ .compatible = \"marvell,pxa1928-usb-phy\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mv_usbphy_dt_match);\n\nstatic struct platform_driver mv_usb2_phy_driver = {\n\t.probe\t= mv_usb2_phy_probe,\n\t.driver = {\n\t\t.name   = \"mv-usb2-phy\",\n\t\t.of_match_table = mv_usbphy_dt_match,\n\t},\n};\nmodule_platform_driver(mv_usb2_phy_driver);\n\nMODULE_AUTHOR(\"Rob Herring <robh@kernel.org>\");\nMODULE_DESCRIPTION(\"Marvell USB2 phy driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}