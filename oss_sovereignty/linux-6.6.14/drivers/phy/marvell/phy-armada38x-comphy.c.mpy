{
  "module_name": "phy-armada38x-comphy.c",
  "hash_id": "bcda3029b8608ed720e60df2c9534d23ed1c6e634609bd255fb3181c9fcdc568",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/marvell/phy-armada38x-comphy.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n\n#define MAX_A38X_COMPHY\t6\n#define MAX_A38X_PORTS\t3\n\n#define COMPHY_CFG1\t\t0x00\n#define  COMPHY_CFG1_GEN_TX(x)\t\t((x) << 26)\n#define  COMPHY_CFG1_GEN_TX_MSK\t\tCOMPHY_CFG1_GEN_TX(15)\n#define  COMPHY_CFG1_GEN_RX(x)\t\t((x) << 22)\n#define  COMPHY_CFG1_GEN_RX_MSK\t\tCOMPHY_CFG1_GEN_RX(15)\n#define  GEN_SGMII_1_25GBPS\t\t6\n#define  GEN_SGMII_3_125GBPS\t\t8\n\n#define COMPHY_STAT1\t\t0x18\n#define  COMPHY_STAT1_PLL_RDY_TX\tBIT(3)\n#define  COMPHY_STAT1_PLL_RDY_RX\tBIT(2)\n\n#define COMPHY_SELECTOR\t\t0xfc\n\nstruct a38x_comphy;\n\nstruct a38x_comphy_lane {\n\tvoid __iomem *base;\n\tstruct a38x_comphy *priv;\n\tunsigned int n;\n\n\tint port;\n};\n\nstruct a38x_comphy {\n\tvoid __iomem *base;\n\tvoid __iomem *conf;\n\tstruct device *dev;\n\tstruct a38x_comphy_lane lane[MAX_A38X_COMPHY];\n};\n\nstatic const u8 gbe_mux[MAX_A38X_COMPHY][MAX_A38X_PORTS] = {\n\t{ 0, 0, 0 },\n\t{ 4, 5, 0 },\n\t{ 0, 4, 0 },\n\t{ 0, 0, 4 },\n\t{ 0, 3, 0 },\n\t{ 0, 0, 3 },\n};\n\nstatic void a38x_set_conf(struct a38x_comphy_lane *lane, bool enable)\n{\n\tstruct a38x_comphy *priv = lane->priv;\n\tu32 conf;\n\n\tif (priv->conf) {\n\t\tconf = readl_relaxed(priv->conf);\n\t\tif (enable)\n\t\t\tconf |= BIT(lane->port);\n\t\telse\n\t\t\tconf &= ~BIT(lane->port);\n\t\twritel(conf, priv->conf);\n\t}\n}\n\nstatic void a38x_comphy_set_reg(struct a38x_comphy_lane *lane,\n\t\t\t\tunsigned int offset, u32 mask, u32 value)\n{\n\tu32 val;\n\n\tval = readl_relaxed(lane->base + offset) & ~mask;\n\twritel(val | value, lane->base + offset);\n}\n\nstatic void a38x_comphy_set_speed(struct a38x_comphy_lane *lane,\n\t\t\t\t  unsigned int gen_tx, unsigned int gen_rx)\n{\n\ta38x_comphy_set_reg(lane, COMPHY_CFG1,\n\t\t\t    COMPHY_CFG1_GEN_TX_MSK | COMPHY_CFG1_GEN_RX_MSK,\n\t\t\t    COMPHY_CFG1_GEN_TX(gen_tx) |\n\t\t            COMPHY_CFG1_GEN_RX(gen_rx));\n}\n\nstatic int a38x_comphy_poll(struct a38x_comphy_lane *lane,\n\t\t\t    unsigned int offset, u32 mask, u32 value)\n{\n\tu32 val;\n\tint ret;\n\n\tret = readl_relaxed_poll_timeout_atomic(lane->base + offset, val,\n\t\t\t\t\t\t(val & mask) == value,\n\t\t\t\t\t\t1000, 150000);\n\n\tif (ret)\n\t\tdev_err(lane->priv->dev,\n\t\t\t\"comphy%u: timed out waiting for status\\n\", lane->n);\n\n\treturn ret;\n}\n\n \nstatic int a38x_comphy_set_mode(struct phy *phy, enum phy_mode mode, int sub)\n{\n\tstruct a38x_comphy_lane *lane = phy_get_drvdata(phy);\n\tunsigned int gen;\n\tint ret;\n\n\tif (mode != PHY_MODE_ETHERNET)\n\t\treturn -EINVAL;\n\n\tswitch (sub) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\tgen = GEN_SGMII_1_25GBPS;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tgen = GEN_SGMII_3_125GBPS;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ta38x_set_conf(lane, false);\n\n\ta38x_comphy_set_speed(lane, gen, gen);\n\n\tret = a38x_comphy_poll(lane, COMPHY_STAT1,\n\t\t\t       COMPHY_STAT1_PLL_RDY_TX |\n\t\t\t       COMPHY_STAT1_PLL_RDY_RX,\n\t\t\t       COMPHY_STAT1_PLL_RDY_TX |\n\t\t\t       COMPHY_STAT1_PLL_RDY_RX);\n\n\tif (ret == 0)\n\t\ta38x_set_conf(lane, true);\n\n\treturn ret;\n}\n\nstatic const struct phy_ops a38x_comphy_ops = {\n\t.set_mode\t= a38x_comphy_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *a38x_comphy_xlate(struct device *dev,\n\t\t\t\t     struct of_phandle_args *args)\n{\n\tstruct a38x_comphy_lane *lane;\n\tstruct phy *phy;\n\tu32 val;\n\n\tif (WARN_ON(args->args[0] >= MAX_A38X_PORTS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tphy = of_phy_simple_xlate(dev, args);\n\tif (IS_ERR(phy))\n\t\treturn phy;\n\n\tlane = phy_get_drvdata(phy);\n\tif (lane->port >= 0)\n\t\treturn ERR_PTR(-EBUSY);\n\n\tlane->port = args->args[0];\n\n\tval = readl_relaxed(lane->priv->base + COMPHY_SELECTOR);\n\tval = (val >> (4 * lane->n)) & 0xf;\n\n\tif (!gbe_mux[lane->n][lane->port] ||\n\t    val != gbe_mux[lane->n][lane->port]) {\n\t\tdev_warn(lane->priv->dev,\n\t\t\t \"comphy%u: not configured for GBE\\n\", lane->n);\n\t\tphy = ERR_PTR(-EINVAL);\n\t}\n\n\treturn phy;\n}\n\nstatic int a38x_comphy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct device_node *child;\n\tstruct a38x_comphy *priv;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->dev = &pdev->dev;\n\tpriv->base = base;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"conf\");\n\tif (res) {\n\t\tpriv->conf = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(priv->conf))\n\t\t\treturn PTR_ERR(priv->conf);\n\t}\n\n\tfor_each_available_child_of_node(pdev->dev.of_node, child) {\n\t\tstruct phy *phy;\n\t\tint ret;\n\t\tu32 val;\n\n\t\tret = of_property_read_u32(child, \"reg\", &val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"missing 'reg' property (%d)\\n\",\n\t\t\t\tret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (val >= MAX_A38X_COMPHY || priv->lane[val].base) {\n\t\t\tdev_err(&pdev->dev, \"invalid 'reg' property\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tphy = devm_phy_create(&pdev->dev, child, &a38x_comphy_ops);\n\t\tif (IS_ERR(phy)) {\n\t\t\tof_node_put(child);\n\t\t\treturn PTR_ERR(phy);\n\t\t}\n\n\t\tpriv->lane[val].base = base + 0x28 * val;\n\t\tpriv->lane[val].priv = priv;\n\t\tpriv->lane[val].n = val;\n\t\tpriv->lane[val].port = -1;\n\t\tphy_set_drvdata(phy, &priv->lane[val]);\n\t}\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\tprovider = devm_of_phy_provider_register(&pdev->dev, a38x_comphy_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic const struct of_device_id a38x_comphy_of_match_table[] = {\n\t{ .compatible = \"marvell,armada-380-comphy\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, a38x_comphy_of_match_table);\n\nstatic struct platform_driver a38x_comphy_driver = {\n\t.probe\t= a38x_comphy_probe,\n\t.driver\t= {\n\t\t.name = \"armada-38x-comphy\",\n\t\t.of_match_table = a38x_comphy_of_match_table,\n\t},\n};\nmodule_platform_driver(a38x_comphy_driver);\n\nMODULE_AUTHOR(\"Russell King <rmk+kernel@armlinux.org.uk>\");\nMODULE_DESCRIPTION(\"Common PHY driver for Armada 38x SoCs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}