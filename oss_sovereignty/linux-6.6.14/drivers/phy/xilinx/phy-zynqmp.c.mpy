{
  "module_name": "phy-zynqmp.c",
  "hash_id": "7f9227b70285dc577005c5ab53678310013b185ed580b14d2f0c0e325f087274",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/xilinx/phy-zynqmp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/phy/phy.h>\n\n \n\n \n#define L0_TX_ANA_TM_18\t\t\t0x0048\n#define L0_TX_ANA_TM_118\t\t0x01d8\n#define L0_TX_ANA_TM_118_FORCE_17_0\tBIT(0)\n\n \n#define L0_TXPMA_ST_3\t\t\t0x0b0c\n#define L0_DN_CALIB_CODE\t\t0x3f\n\n \n#define L0_TXPMD_TM_45\t\t\t0x0cb4\n#define L0_TXPMD_TM_48\t\t\t0x0cc0\n#define L0_TXPMD_TM_45_OVER_DP_MAIN\tBIT(0)\n#define L0_TXPMD_TM_45_ENABLE_DP_MAIN\tBIT(1)\n#define L0_TXPMD_TM_45_OVER_DP_POST1\tBIT(2)\n#define L0_TXPMD_TM_45_ENABLE_DP_POST1\tBIT(3)\n#define L0_TXPMD_TM_45_OVER_DP_POST2\tBIT(4)\n#define L0_TXPMD_TM_45_ENABLE_DP_POST2\tBIT(5)\n\n \n#define L0_TM_DIG_6\t\t\t0x106c\n#define L0_TM_DIS_DESCRAMBLE_DECODER\t0x0f\n#define L0_TX_DIG_61\t\t\t0x00f4\n#define L0_TM_DISABLE_SCRAMBLE_ENCODER\t0x0f\n\n \n#define L0_TM_PLL_DIG_37\t\t0x2094\n#define L0_TM_COARSE_CODE_LIMIT\t\t0x10\n\n \n#define L0_PLL_SS_STEPS_0_LSB\t\t0x2368\n#define L0_PLL_SS_STEPS_1_MSB\t\t0x236c\n#define L0_PLL_SS_STEP_SIZE_0_LSB\t0x2370\n#define L0_PLL_SS_STEP_SIZE_1\t\t0x2374\n#define L0_PLL_SS_STEP_SIZE_2\t\t0x2378\n#define L0_PLL_SS_STEP_SIZE_3_MSB\t0x237c\n#define L0_PLL_STATUS_READ_1\t\t0x23e4\n\n \n#define STEP_SIZE_0_MASK\t\t0xff\n#define STEP_SIZE_1_MASK\t\t0xff\n#define STEP_SIZE_2_MASK\t\t0xff\n#define STEP_SIZE_3_MASK\t\t0x3\n#define STEP_SIZE_SHIFT\t\t\t8\n#define FORCE_STEP_SIZE\t\t\t0x10\n#define FORCE_STEPS\t\t\t0x20\n#define STEPS_0_MASK\t\t\t0xff\n#define STEPS_1_MASK\t\t\t0x07\n\n \n#define L0_Ln_REF_CLK_SEL(n)\t\t(0x2860 + (n) * 4)\n#define L0_REF_CLK_SEL_MASK\t\t0x8f\n\n \n#define L3_TM_CALIB_DIG19\t\t0xec4c\n#define L3_CALIB_DONE_STATUS\t\t0xef14\n#define L3_TM_CALIB_DIG18\t\t0xec48\n#define L3_TM_CALIB_DIG19_NSW\t\t0x07\n#define L3_TM_CALIB_DIG18_NSW\t\t0xe0\n#define L3_TM_OVERRIDE_NSW_CODE         0x20\n#define L3_CALIB_DONE\t\t\t0x02\n#define L3_NSW_SHIFT\t\t\t5\n#define L3_NSW_PIPE_SHIFT\t\t4\n#define L3_NSW_CALIB_SHIFT\t\t3\n\n#define PHY_REG_OFFSET\t\t\t0x4000\n\n \n\n \n#define PLL_REF_SEL(n)\t\t\t(0x10000 + (n) * 4)\n#define PLL_FREQ_MASK\t\t\t0x1f\n#define PLL_STATUS_LOCKED\t\t0x10\n\n \n#define ICM_CFG0\t\t\t0x10010\n#define ICM_CFG1\t\t\t0x10014\n#define ICM_CFG0_L0_MASK\t\t0x07\n#define ICM_CFG0_L1_MASK\t\t0x70\n#define ICM_CFG1_L2_MASK\t\t0x07\n#define ICM_CFG2_L3_MASK\t\t0x70\n#define ICM_CFG_SHIFT\t\t\t4\n\n \n#define ICM_PROTOCOL_PD\t\t\t0x0\n#define ICM_PROTOCOL_PCIE\t\t0x1\n#define ICM_PROTOCOL_SATA\t\t0x2\n#define ICM_PROTOCOL_USB\t\t0x3\n#define ICM_PROTOCOL_DP\t\t\t0x4\n#define ICM_PROTOCOL_SGMII\t\t0x5\n\n \n#define TM_CMN_RST\t\t\t0x10018\n#define TM_CMN_RST_EN\t\t\t0x1\n#define TM_CMN_RST_SET\t\t\t0x2\n#define TM_CMN_RST_MASK\t\t\t0x3\n\n \n#define TX_PROT_BUS_WIDTH\t\t0x10040\n#define RX_PROT_BUS_WIDTH\t\t0x10044\n#define PROT_BUS_WIDTH_10\t\t0x0\n#define PROT_BUS_WIDTH_20\t\t0x1\n#define PROT_BUS_WIDTH_40\t\t0x2\n#define PROT_BUS_WIDTH_SHIFT(n)\t\t((n) * 2)\n#define PROT_BUS_WIDTH_MASK(n)\t\tGENMASK((n) * 2 + 1, (n) * 2)\n\n \n#define NUM_LANES\t\t\t4\n\n \n#define SATA_CONTROL_OFFSET\t\t0x0100\n\n \n#define CONTROLLERS_PER_LANE\t\t5\n\n \n#define XPSGTR_TYPE_USB0\t\t0   \n#define XPSGTR_TYPE_USB1\t\t1   \n#define XPSGTR_TYPE_SATA_0\t\t2   \n#define XPSGTR_TYPE_SATA_1\t\t3   \n#define XPSGTR_TYPE_PCIE_0\t\t4   \n#define XPSGTR_TYPE_PCIE_1\t\t5   \n#define XPSGTR_TYPE_PCIE_2\t\t6   \n#define XPSGTR_TYPE_PCIE_3\t\t7   \n#define XPSGTR_TYPE_DP_0\t\t8   \n#define XPSGTR_TYPE_DP_1\t\t9   \n#define XPSGTR_TYPE_SGMII0\t\t10  \n#define XPSGTR_TYPE_SGMII1\t\t11  \n#define XPSGTR_TYPE_SGMII2\t\t12  \n#define XPSGTR_TYPE_SGMII3\t\t13  \n\n \n#define TIMEOUT_US\t\t\t1000\n\nstruct xpsgtr_dev;\n\n \nstruct xpsgtr_ssc {\n\tu32 refclk_rate;\n\tu8  pll_ref_clk;\n\tu32 steps;\n\tu32 step_size;\n};\n\n \nstruct xpsgtr_phy {\n\tstruct phy *phy;\n\tu8 type;\n\tu8 lane;\n\tu8 protocol;\n\tbool skip_phy_init;\n\tstruct xpsgtr_dev *dev;\n\tunsigned int refclk;\n};\n\n \nstruct xpsgtr_dev {\n\tstruct device *dev;\n\tvoid __iomem *serdes;\n\tvoid __iomem *siou;\n\tstruct mutex gtr_mutex;  \n\tstruct xpsgtr_phy phys[NUM_LANES];\n\tconst struct xpsgtr_ssc *refclk_sscs[NUM_LANES];\n\tstruct clk *clk[NUM_LANES];\n\tbool tx_term_fix;\n\tunsigned int saved_icm_cfg0;\n\tunsigned int saved_icm_cfg1;\n};\n\n \n\n \nstatic const struct xpsgtr_ssc ssc_lookup[] = {\n\t{  19200000, 0x05,  608, 264020 },\n\t{  20000000, 0x06,  634, 243454 },\n\t{  24000000, 0x07,  760, 168973 },\n\t{  26000000, 0x08,  824, 143860 },\n\t{  27000000, 0x09,  856,  86551 },\n\t{  38400000, 0x0a, 1218,  65896 },\n\t{  40000000, 0x0b,  634, 243454 },\n\t{  52000000, 0x0c,  824, 143860 },\n\t{ 100000000, 0x0d, 1058,  87533 },\n\t{ 108000000, 0x0e,  856,  86551 },\n\t{ 125000000, 0x0f,  992, 119497 },\n\t{ 135000000, 0x10, 1070,  55393 },\n\t{ 150000000, 0x11,  792, 187091 }\n};\n\n \n\nstatic inline u32 xpsgtr_read(struct xpsgtr_dev *gtr_dev, u32 reg)\n{\n\treturn readl(gtr_dev->serdes + reg);\n}\n\nstatic inline void xpsgtr_write(struct xpsgtr_dev *gtr_dev, u32 reg, u32 value)\n{\n\twritel(value, gtr_dev->serdes + reg);\n}\n\nstatic inline void xpsgtr_clr_set(struct xpsgtr_dev *gtr_dev, u32 reg,\n\t\t\t\t  u32 clr, u32 set)\n{\n\tu32 value = xpsgtr_read(gtr_dev, reg);\n\n\tvalue &= ~clr;\n\tvalue |= set;\n\txpsgtr_write(gtr_dev, reg, value);\n}\n\nstatic inline u32 xpsgtr_read_phy(struct xpsgtr_phy *gtr_phy, u32 reg)\n{\n\tvoid __iomem *addr = gtr_phy->dev->serdes\n\t\t\t   + gtr_phy->lane * PHY_REG_OFFSET + reg;\n\n\treturn readl(addr);\n}\n\nstatic inline void xpsgtr_write_phy(struct xpsgtr_phy *gtr_phy,\n\t\t\t\t    u32 reg, u32 value)\n{\n\tvoid __iomem *addr = gtr_phy->dev->serdes\n\t\t\t   + gtr_phy->lane * PHY_REG_OFFSET + reg;\n\n\twritel(value, addr);\n}\n\nstatic inline void xpsgtr_clr_set_phy(struct xpsgtr_phy *gtr_phy,\n\t\t\t\t      u32 reg, u32 clr, u32 set)\n{\n\tvoid __iomem *addr = gtr_phy->dev->serdes\n\t\t\t   + gtr_phy->lane * PHY_REG_OFFSET + reg;\n\n\twritel((readl(addr) & ~clr) | set, addr);\n}\n\n \n\n \nstatic int xpsgtr_wait_pll_lock(struct phy *phy)\n{\n\tstruct xpsgtr_phy *gtr_phy = phy_get_drvdata(phy);\n\tstruct xpsgtr_dev *gtr_dev = gtr_phy->dev;\n\tunsigned int timeout = TIMEOUT_US;\n\tint ret;\n\n\tdev_dbg(gtr_dev->dev, \"Waiting for PLL lock\\n\");\n\n\twhile (1) {\n\t\tu32 reg = xpsgtr_read_phy(gtr_phy, L0_PLL_STATUS_READ_1);\n\n\t\tif ((reg & PLL_STATUS_LOCKED) == PLL_STATUS_LOCKED) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (--timeout == 0) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(1);\n\t}\n\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(gtr_dev->dev,\n\t\t\t\"lane %u (type %u, protocol %u): PLL lock timeout\\n\",\n\t\t\tgtr_phy->lane, gtr_phy->type, gtr_phy->protocol);\n\n\treturn ret;\n}\n\n \nstatic void xpsgtr_configure_pll(struct xpsgtr_phy *gtr_phy)\n{\n\tconst struct xpsgtr_ssc *ssc;\n\tu32 step_size;\n\n\tssc = gtr_phy->dev->refclk_sscs[gtr_phy->refclk];\n\tstep_size = ssc->step_size;\n\n\txpsgtr_clr_set(gtr_phy->dev, PLL_REF_SEL(gtr_phy->lane),\n\t\t       PLL_FREQ_MASK, ssc->pll_ref_clk);\n\n\t \n\tif (gtr_phy->refclk != gtr_phy->lane) {\n\t\t \n\t\txpsgtr_clr_set(gtr_phy->dev, L0_Ln_REF_CLK_SEL(gtr_phy->lane),\n\t\t\t       L0_REF_CLK_SEL_MASK, 1 << gtr_phy->refclk);\n\t}\n\n\t \n\txpsgtr_clr_set_phy(gtr_phy, L0_PLL_SS_STEP_SIZE_0_LSB,\n\t\t\t   STEP_SIZE_0_MASK, step_size & STEP_SIZE_0_MASK);\n\n\t \n\tstep_size >>= STEP_SIZE_SHIFT;\n\txpsgtr_clr_set_phy(gtr_phy, L0_PLL_SS_STEP_SIZE_1,\n\t\t\t   STEP_SIZE_1_MASK, step_size & STEP_SIZE_1_MASK);\n\n\t \n\tstep_size >>= STEP_SIZE_SHIFT;\n\txpsgtr_clr_set_phy(gtr_phy, L0_PLL_SS_STEP_SIZE_2,\n\t\t\t   STEP_SIZE_2_MASK, step_size & STEP_SIZE_2_MASK);\n\n\t \n\txpsgtr_clr_set_phy(gtr_phy, L0_PLL_SS_STEPS_0_LSB,\n\t\t\t   STEPS_0_MASK, ssc->steps & STEPS_0_MASK);\n\n\t \n\txpsgtr_clr_set_phy(gtr_phy, L0_PLL_SS_STEPS_1_MSB,\n\t\t\t   STEPS_1_MASK,\n\t\t\t   (ssc->steps >> STEP_SIZE_SHIFT) & STEPS_1_MASK);\n\n\t \n\tstep_size >>= STEP_SIZE_SHIFT;\n\txpsgtr_clr_set_phy(gtr_phy, L0_PLL_SS_STEP_SIZE_3_MSB,\n\t\t\t   STEP_SIZE_3_MASK, (step_size & STEP_SIZE_3_MASK) |\n\t\t\t   FORCE_STEP_SIZE | FORCE_STEPS);\n}\n\n \nstatic void xpsgtr_lane_set_protocol(struct xpsgtr_phy *gtr_phy)\n{\n\tstruct xpsgtr_dev *gtr_dev = gtr_phy->dev;\n\tu8 protocol = gtr_phy->protocol;\n\n\tswitch (gtr_phy->lane) {\n\tcase 0:\n\t\txpsgtr_clr_set(gtr_dev, ICM_CFG0, ICM_CFG0_L0_MASK, protocol);\n\t\tbreak;\n\tcase 1:\n\t\txpsgtr_clr_set(gtr_dev, ICM_CFG0, ICM_CFG0_L1_MASK,\n\t\t\t       protocol << ICM_CFG_SHIFT);\n\t\tbreak;\n\tcase 2:\n\t\txpsgtr_clr_set(gtr_dev, ICM_CFG1, ICM_CFG0_L0_MASK, protocol);\n\t\tbreak;\n\tcase 3:\n\t\txpsgtr_clr_set(gtr_dev, ICM_CFG1, ICM_CFG0_L1_MASK,\n\t\t\t       protocol << ICM_CFG_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\n \nstatic void xpsgtr_bypass_scrambler_8b10b(struct xpsgtr_phy *gtr_phy)\n{\n\txpsgtr_write_phy(gtr_phy, L0_TM_DIG_6, L0_TM_DIS_DESCRAMBLE_DECODER);\n\txpsgtr_write_phy(gtr_phy, L0_TX_DIG_61, L0_TM_DISABLE_SCRAMBLE_ENCODER);\n}\n\n \nstatic void xpsgtr_phy_init_dp(struct xpsgtr_phy *gtr_phy)\n{\n\txpsgtr_write_phy(gtr_phy, L0_TXPMD_TM_45,\n\t\t\t L0_TXPMD_TM_45_OVER_DP_MAIN |\n\t\t\t L0_TXPMD_TM_45_ENABLE_DP_MAIN |\n\t\t\t L0_TXPMD_TM_45_OVER_DP_POST1 |\n\t\t\t L0_TXPMD_TM_45_OVER_DP_POST2 |\n\t\t\t L0_TXPMD_TM_45_ENABLE_DP_POST2);\n\txpsgtr_write_phy(gtr_phy, L0_TX_ANA_TM_118,\n\t\t\t L0_TX_ANA_TM_118_FORCE_17_0);\n}\n\n \nstatic void xpsgtr_phy_init_sata(struct xpsgtr_phy *gtr_phy)\n{\n\tstruct xpsgtr_dev *gtr_dev = gtr_phy->dev;\n\n\txpsgtr_bypass_scrambler_8b10b(gtr_phy);\n\n\twritel(gtr_phy->lane, gtr_dev->siou + SATA_CONTROL_OFFSET);\n}\n\n \nstatic void xpsgtr_phy_init_sgmii(struct xpsgtr_phy *gtr_phy)\n{\n\tstruct xpsgtr_dev *gtr_dev = gtr_phy->dev;\n\tu32 mask = PROT_BUS_WIDTH_MASK(gtr_phy->lane);\n\tu32 val = PROT_BUS_WIDTH_10 << PROT_BUS_WIDTH_SHIFT(gtr_phy->lane);\n\n\t \n\txpsgtr_clr_set(gtr_dev, TX_PROT_BUS_WIDTH, mask, val);\n\txpsgtr_clr_set(gtr_dev, RX_PROT_BUS_WIDTH, mask, val);\n\n\txpsgtr_bypass_scrambler_8b10b(gtr_phy);\n}\n\n \nstatic void xpsgtr_phy_configure_dp(struct xpsgtr_phy *gtr_phy, unsigned int pre,\n\t\t\t\t    unsigned int voltage)\n{\n\tstatic const u8 voltage_swing[4][4] = {\n\t\t{ 0x2a, 0x27, 0x24, 0x20 },\n\t\t{ 0x27, 0x23, 0x20, 0xff },\n\t\t{ 0x24, 0x20, 0xff, 0xff },\n\t\t{ 0xff, 0xff, 0xff, 0xff }\n\t};\n\tstatic const u8 pre_emphasis[4][4] = {\n\t\t{ 0x02, 0x02, 0x02, 0x02 },\n\t\t{ 0x01, 0x01, 0x01, 0xff },\n\t\t{ 0x00, 0x00, 0xff, 0xff },\n\t\t{ 0xff, 0xff, 0xff, 0xff }\n\t};\n\n\txpsgtr_write_phy(gtr_phy, L0_TXPMD_TM_48, voltage_swing[pre][voltage]);\n\txpsgtr_write_phy(gtr_phy, L0_TX_ANA_TM_18, pre_emphasis[pre][voltage]);\n}\n\n \n\nstatic bool xpsgtr_phy_init_required(struct xpsgtr_phy *gtr_phy)\n{\n\t \n\tif (gtr_phy->protocol == ICM_PROTOCOL_USB && gtr_phy->skip_phy_init)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n \nstatic int xpsgtr_phy_tx_term_fix(struct xpsgtr_phy *gtr_phy)\n{\n\tstruct xpsgtr_dev *gtr_dev = gtr_phy->dev;\n\tu32 timeout = TIMEOUT_US;\n\tu32 nsw;\n\n\t \n\txpsgtr_clr_set(gtr_dev, TM_CMN_RST, TM_CMN_RST_MASK, TM_CMN_RST_SET);\n\n\t \n\txpsgtr_clr_set(gtr_dev, TM_CMN_RST, TM_CMN_RST_MASK, TM_CMN_RST_EN);\n\n\txpsgtr_write(gtr_dev, L3_TM_CALIB_DIG18, 0x00);\n\txpsgtr_write(gtr_dev, L3_TM_CALIB_DIG19, L3_TM_OVERRIDE_NSW_CODE);\n\n\t \n\txpsgtr_lane_set_protocol(gtr_phy);\n\n\t \n\txpsgtr_clr_set(gtr_dev, TM_CMN_RST, TM_CMN_RST_MASK, TM_CMN_RST_SET);\n\n\tdev_dbg(gtr_dev->dev, \"calibrating...\\n\");\n\n\tdo {\n\t\tu32 reg = xpsgtr_read(gtr_dev, L3_CALIB_DONE_STATUS);\n\n\t\tif ((reg & L3_CALIB_DONE) == L3_CALIB_DONE)\n\t\t\tbreak;\n\n\t\tif (!--timeout) {\n\t\t\tdev_err(gtr_dev->dev, \"calibration time out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tudelay(1);\n\t} while (timeout > 0);\n\n\tdev_dbg(gtr_dev->dev, \"calibration done\\n\");\n\n\t \n\tnsw = xpsgtr_read(gtr_dev, L0_TXPMA_ST_3) & L0_DN_CALIB_CODE;\n\n\t \n\txpsgtr_clr_set(gtr_dev, TM_CMN_RST, TM_CMN_RST_MASK, TM_CMN_RST_EN);\n\n\t \n\txpsgtr_write(gtr_dev, L3_TM_CALIB_DIG19, nsw >> L3_NSW_CALIB_SHIFT);\n\n\t \n\txpsgtr_write(gtr_dev, L3_TM_CALIB_DIG18,\n\t\t     ((nsw & L3_TM_CALIB_DIG19_NSW) << L3_NSW_SHIFT) |\n\t\t     (1 << L3_NSW_PIPE_SHIFT));\n\n\t \n\txpsgtr_clr_set(gtr_dev, TM_CMN_RST, TM_CMN_RST_MASK, TM_CMN_RST_SET);\n\n\treturn 0;\n}\n\nstatic int xpsgtr_phy_init(struct phy *phy)\n{\n\tstruct xpsgtr_phy *gtr_phy = phy_get_drvdata(phy);\n\tstruct xpsgtr_dev *gtr_dev = gtr_phy->dev;\n\tint ret = 0;\n\n\tmutex_lock(&gtr_dev->gtr_mutex);\n\n\t \n\tif (clk_prepare_enable(gtr_dev->clk[gtr_phy->lane]))\n\t\tgoto out;\n\n\t \n\tif (!xpsgtr_phy_init_required(gtr_phy))\n\t\tgoto out;\n\n\tif (gtr_dev->tx_term_fix) {\n\t\tret = xpsgtr_phy_tx_term_fix(gtr_phy);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tgtr_dev->tx_term_fix = false;\n\t}\n\n\t \n\txpsgtr_write_phy(gtr_phy, L0_TM_PLL_DIG_37, L0_TM_COARSE_CODE_LIMIT);\n\n\t \n\txpsgtr_configure_pll(gtr_phy);\n\txpsgtr_lane_set_protocol(gtr_phy);\n\n\tswitch (gtr_phy->protocol) {\n\tcase ICM_PROTOCOL_DP:\n\t\txpsgtr_phy_init_dp(gtr_phy);\n\t\tbreak;\n\n\tcase ICM_PROTOCOL_SATA:\n\t\txpsgtr_phy_init_sata(gtr_phy);\n\t\tbreak;\n\n\tcase ICM_PROTOCOL_SGMII:\n\t\txpsgtr_phy_init_sgmii(gtr_phy);\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&gtr_dev->gtr_mutex);\n\treturn ret;\n}\n\nstatic int xpsgtr_phy_exit(struct phy *phy)\n{\n\tstruct xpsgtr_phy *gtr_phy = phy_get_drvdata(phy);\n\tstruct xpsgtr_dev *gtr_dev = gtr_phy->dev;\n\n\tgtr_phy->skip_phy_init = false;\n\n\t \n\tclk_disable_unprepare(gtr_dev->clk[gtr_phy->lane]);\n\n\treturn 0;\n}\n\nstatic int xpsgtr_phy_power_on(struct phy *phy)\n{\n\tstruct xpsgtr_phy *gtr_phy = phy_get_drvdata(phy);\n\tint ret = 0;\n\n\t \n\tif (!xpsgtr_phy_init_required(gtr_phy))\n\t\treturn ret;\n\t \n\tif (gtr_phy->protocol != ICM_PROTOCOL_DP ||\n\t    gtr_phy->type == XPSGTR_TYPE_DP_0)\n\t\tret = xpsgtr_wait_pll_lock(phy);\n\n\treturn ret;\n}\n\nstatic int xpsgtr_phy_configure(struct phy *phy, union phy_configure_opts *opts)\n{\n\tstruct xpsgtr_phy *gtr_phy = phy_get_drvdata(phy);\n\n\tif (gtr_phy->protocol != ICM_PROTOCOL_DP)\n\t\treturn 0;\n\n\txpsgtr_phy_configure_dp(gtr_phy, opts->dp.pre[0], opts->dp.voltage[0]);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops xpsgtr_phyops = {\n\t.init\t\t= xpsgtr_phy_init,\n\t.exit\t\t= xpsgtr_phy_exit,\n\t.power_on\t= xpsgtr_phy_power_on,\n\t.configure\t= xpsgtr_phy_configure,\n\t.owner\t\t= THIS_MODULE,\n};\n\n \n\n \nstatic int xpsgtr_set_lane_type(struct xpsgtr_phy *gtr_phy, u8 phy_type,\n\t\t\t\tunsigned int phy_instance)\n{\n\tunsigned int num_phy_types;\n\tconst int *phy_types;\n\n\tswitch (phy_type) {\n\tcase PHY_TYPE_SATA: {\n\t\tstatic const int types[] = {\n\t\t\tXPSGTR_TYPE_SATA_0,\n\t\t\tXPSGTR_TYPE_SATA_1,\n\t\t};\n\n\t\tphy_types = types;\n\t\tnum_phy_types = ARRAY_SIZE(types);\n\t\tgtr_phy->protocol = ICM_PROTOCOL_SATA;\n\t\tbreak;\n\t}\n\tcase PHY_TYPE_USB3: {\n\t\tstatic const int types[] = {\n\t\t\tXPSGTR_TYPE_USB0,\n\t\t\tXPSGTR_TYPE_USB1,\n\t\t};\n\n\t\tphy_types = types;\n\t\tnum_phy_types = ARRAY_SIZE(types);\n\t\tgtr_phy->protocol = ICM_PROTOCOL_USB;\n\t\tbreak;\n\t}\n\tcase PHY_TYPE_DP: {\n\t\tstatic const int types[] = {\n\t\t\tXPSGTR_TYPE_DP_0,\n\t\t\tXPSGTR_TYPE_DP_1,\n\t\t};\n\n\t\tphy_types = types;\n\t\tnum_phy_types = ARRAY_SIZE(types);\n\t\tgtr_phy->protocol = ICM_PROTOCOL_DP;\n\t\tbreak;\n\t}\n\tcase PHY_TYPE_PCIE: {\n\t\tstatic const int types[] = {\n\t\t\tXPSGTR_TYPE_PCIE_0,\n\t\t\tXPSGTR_TYPE_PCIE_1,\n\t\t\tXPSGTR_TYPE_PCIE_2,\n\t\t\tXPSGTR_TYPE_PCIE_3,\n\t\t};\n\n\t\tphy_types = types;\n\t\tnum_phy_types = ARRAY_SIZE(types);\n\t\tgtr_phy->protocol = ICM_PROTOCOL_PCIE;\n\t\tbreak;\n\t}\n\tcase PHY_TYPE_SGMII: {\n\t\tstatic const int types[] = {\n\t\t\tXPSGTR_TYPE_SGMII0,\n\t\t\tXPSGTR_TYPE_SGMII1,\n\t\t\tXPSGTR_TYPE_SGMII2,\n\t\t\tXPSGTR_TYPE_SGMII3,\n\t\t};\n\n\t\tphy_types = types;\n\t\tnum_phy_types = ARRAY_SIZE(types);\n\t\tgtr_phy->protocol = ICM_PROTOCOL_SGMII;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (phy_instance >= num_phy_types)\n\t\treturn -EINVAL;\n\n\tgtr_phy->type = phy_types[phy_instance];\n\treturn 0;\n}\n\n \nstatic const unsigned int icm_matrix[NUM_LANES][CONTROLLERS_PER_LANE] = {\n\t{ XPSGTR_TYPE_PCIE_0, XPSGTR_TYPE_SATA_0, XPSGTR_TYPE_USB0,\n\t\tXPSGTR_TYPE_DP_1, XPSGTR_TYPE_SGMII0 },\n\t{ XPSGTR_TYPE_PCIE_1, XPSGTR_TYPE_SATA_1, XPSGTR_TYPE_USB0,\n\t\tXPSGTR_TYPE_DP_0, XPSGTR_TYPE_SGMII1 },\n\t{ XPSGTR_TYPE_PCIE_2, XPSGTR_TYPE_SATA_0, XPSGTR_TYPE_USB0,\n\t\tXPSGTR_TYPE_DP_1, XPSGTR_TYPE_SGMII2 },\n\t{ XPSGTR_TYPE_PCIE_3, XPSGTR_TYPE_SATA_1, XPSGTR_TYPE_USB1,\n\t\tXPSGTR_TYPE_DP_0, XPSGTR_TYPE_SGMII3 }\n};\n\n \nstatic struct phy *xpsgtr_xlate(struct device *dev,\n\t\t\t\tstruct of_phandle_args *args)\n{\n\tstruct xpsgtr_dev *gtr_dev = dev_get_drvdata(dev);\n\tstruct xpsgtr_phy *gtr_phy;\n\tunsigned int phy_instance;\n\tunsigned int phy_lane;\n\tunsigned int phy_type;\n\tunsigned int refclk;\n\tunsigned int i;\n\tint ret;\n\n\tif (args->args_count != 4) {\n\t\tdev_err(dev, \"Invalid number of cells in 'phy' property\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tphy_lane = args->args[0];\n\tif (phy_lane >= ARRAY_SIZE(gtr_dev->phys)) {\n\t\tdev_err(dev, \"Invalid lane number %u\\n\", phy_lane);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tgtr_phy = &gtr_dev->phys[phy_lane];\n\tphy_type = args->args[1];\n\tphy_instance = args->args[2];\n\n\tret = xpsgtr_set_lane_type(gtr_phy, phy_type, phy_instance);\n\tif (ret < 0) {\n\t\tdev_err(gtr_dev->dev, \"Invalid PHY type and/or instance\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trefclk = args->args[3];\n\tif (refclk >= ARRAY_SIZE(gtr_dev->refclk_sscs) ||\n\t    !gtr_dev->refclk_sscs[refclk]) {\n\t\tdev_err(dev, \"Invalid reference clock number %u\\n\", refclk);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tgtr_phy->refclk = refclk;\n\n\t \n\tfor (i = 0; i < CONTROLLERS_PER_LANE; i++) {\n\t\tif (icm_matrix[phy_lane][i] == gtr_phy->type)\n\t\t\treturn gtr_phy->phy;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\n \n\nstatic int xpsgtr_runtime_suspend(struct device *dev)\n{\n\tstruct xpsgtr_dev *gtr_dev = dev_get_drvdata(dev);\n\n\t \n\tgtr_dev->saved_icm_cfg0 = xpsgtr_read(gtr_dev, ICM_CFG0);\n\tgtr_dev->saved_icm_cfg1 = xpsgtr_read(gtr_dev, ICM_CFG1);\n\n\treturn 0;\n}\n\nstatic int xpsgtr_runtime_resume(struct device *dev)\n{\n\tstruct xpsgtr_dev *gtr_dev = dev_get_drvdata(dev);\n\tunsigned int icm_cfg0, icm_cfg1;\n\tunsigned int i;\n\tbool skip_phy_init;\n\n\ticm_cfg0 = xpsgtr_read(gtr_dev, ICM_CFG0);\n\ticm_cfg1 = xpsgtr_read(gtr_dev, ICM_CFG1);\n\n\t \n\tif (!gtr_dev->saved_icm_cfg0 && !gtr_dev->saved_icm_cfg1)\n\t\treturn 0;\n\n\t \n\tif (icm_cfg0 == gtr_dev->saved_icm_cfg0 &&\n\t    icm_cfg1 == gtr_dev->saved_icm_cfg1)\n\t\tskip_phy_init = true;\n\telse\n\t\tskip_phy_init = false;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(gtr_dev->phys); i++)\n\t\tgtr_dev->phys[i].skip_phy_init = skip_phy_init;\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(xpsgtr_pm_ops, xpsgtr_runtime_suspend,\n\t\t\t\t xpsgtr_runtime_resume, NULL);\n \n\nstatic int xpsgtr_get_ref_clocks(struct xpsgtr_dev *gtr_dev)\n{\n\tunsigned int refclk;\n\n\tfor (refclk = 0; refclk < ARRAY_SIZE(gtr_dev->refclk_sscs); ++refclk) {\n\t\tunsigned long rate;\n\t\tunsigned int i;\n\t\tstruct clk *clk;\n\t\tchar name[8];\n\n\t\tsnprintf(name, sizeof(name), \"ref%u\", refclk);\n\t\tclk = devm_clk_get_optional(gtr_dev->dev, name);\n\t\tif (IS_ERR(clk)) {\n\t\t\treturn dev_err_probe(gtr_dev->dev, PTR_ERR(clk),\n\t\t\t\t\t     \"Failed to get ref clock %u\\n\",\n\t\t\t\t\t     refclk);\n\t\t}\n\n\t\tif (!clk)\n\t\t\tcontinue;\n\n\t\tgtr_dev->clk[refclk] = clk;\n\n\t\t \n\t\trate = clk_get_rate(clk);\n\n\t\tfor (i = 0 ; i < ARRAY_SIZE(ssc_lookup); i++) {\n\t\t\t \n\t\t\tunsigned long error = ssc_lookup[i].refclk_rate / 10000;\n\n\t\t\tif (abs(rate - ssc_lookup[i].refclk_rate) < error) {\n\t\t\t\tgtr_dev->refclk_sscs[refclk] = &ssc_lookup[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(ssc_lookup)) {\n\t\t\tdev_err(gtr_dev->dev,\n\t\t\t\t\"Invalid rate %lu for reference clock %u\\n\",\n\t\t\t\trate, refclk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int xpsgtr_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct xpsgtr_dev *gtr_dev;\n\tstruct phy_provider *provider;\n\tunsigned int port;\n\tint ret;\n\n\tgtr_dev = devm_kzalloc(&pdev->dev, sizeof(*gtr_dev), GFP_KERNEL);\n\tif (!gtr_dev)\n\t\treturn -ENOMEM;\n\n\tgtr_dev->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, gtr_dev);\n\n\tmutex_init(&gtr_dev->gtr_mutex);\n\n\tif (of_device_is_compatible(np, \"xlnx,zynqmp-psgtr\"))\n\t\tgtr_dev->tx_term_fix =\n\t\t\tof_property_read_bool(np, \"xlnx,tx-termination-fix\");\n\n\t \n\tgtr_dev->serdes = devm_platform_ioremap_resource_byname(pdev, \"serdes\");\n\tif (IS_ERR(gtr_dev->serdes))\n\t\treturn PTR_ERR(gtr_dev->serdes);\n\n\tgtr_dev->siou = devm_platform_ioremap_resource_byname(pdev, \"siou\");\n\tif (IS_ERR(gtr_dev->siou))\n\t\treturn PTR_ERR(gtr_dev->siou);\n\n\tret = xpsgtr_get_ref_clocks(gtr_dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (port = 0; port < ARRAY_SIZE(gtr_dev->phys); ++port) {\n\t\tstruct xpsgtr_phy *gtr_phy = &gtr_dev->phys[port];\n\t\tstruct phy *phy;\n\n\t\tgtr_phy->lane = port;\n\t\tgtr_phy->dev = gtr_dev;\n\n\t\tphy = devm_phy_create(&pdev->dev, np, &xpsgtr_phyops);\n\t\tif (IS_ERR(phy)) {\n\t\t\tdev_err(&pdev->dev, \"failed to create PHY\\n\");\n\t\t\treturn PTR_ERR(phy);\n\t\t}\n\n\t\tgtr_phy->phy = phy;\n\t\tphy_set_drvdata(phy, gtr_phy);\n\t}\n\n\t \n\tprovider = devm_of_phy_provider_register(&pdev->dev, xpsgtr_xlate);\n\tif (IS_ERR(provider)) {\n\t\tdev_err(&pdev->dev, \"registering provider failed\\n\");\n\t\treturn PTR_ERR(provider);\n\t}\n\n\tpm_runtime_set_active(gtr_dev->dev);\n\tpm_runtime_enable(gtr_dev->dev);\n\n\tret = pm_runtime_resume_and_get(gtr_dev->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_disable(gtr_dev->dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int xpsgtr_remove(struct platform_device *pdev)\n{\n\tstruct xpsgtr_dev *gtr_dev = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(gtr_dev->dev);\n\tpm_runtime_put_noidle(gtr_dev->dev);\n\tpm_runtime_set_suspended(gtr_dev->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id xpsgtr_of_match[] = {\n\t{ .compatible = \"xlnx,zynqmp-psgtr\", },\n\t{ .compatible = \"xlnx,zynqmp-psgtr-v1.1\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xpsgtr_of_match);\n\nstatic struct platform_driver xpsgtr_driver = {\n\t.probe = xpsgtr_probe,\n\t.remove\t= xpsgtr_remove,\n\t.driver = {\n\t\t.name = \"xilinx-psgtr\",\n\t\t.of_match_table\t= xpsgtr_of_match,\n\t\t.pm =  pm_ptr(&xpsgtr_pm_ops),\n\t},\n};\n\nmodule_platform_driver(xpsgtr_driver);\n\nMODULE_AUTHOR(\"Xilinx Inc.\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Xilinx ZynqMP High speed Gigabit Transceiver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}