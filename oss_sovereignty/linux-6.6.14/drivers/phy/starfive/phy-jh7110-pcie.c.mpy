{
  "module_name": "phy-jh7110-pcie.c",
  "hash_id": "374b98f93663348512ad8f9a4d2bc42c1436fdc72c48ff1a14086ea1e2809a24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/starfive/phy-jh7110-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define PCIE_KVCO_LEVEL_OFF\t\t0x28\n#define PCIE_USB3_PHY_PLL_CTL_OFF\t0x7c\n#define PCIE_KVCO_TUNE_SIGNAL_OFF\t0x80\n#define PCIE_USB3_PHY_ENABLE\t\tBIT(4)\n#define PHY_KVCO_FINE_TUNE_LEVEL\t0x91\n#define PHY_KVCO_FINE_TUNE_SIGNALS\t0xc\n\n#define USB_PDRSTN_SPLIT\t\tBIT(17)\n\n#define PCIE_PHY_MODE\t\t\tBIT(20)\n#define PCIE_PHY_MODE_MASK\t\tGENMASK(21, 20)\n#define PCIE_USB3_BUS_WIDTH_MASK\tGENMASK(3, 2)\n#define PCIE_USB3_BUS_WIDTH\t\tBIT(3)\n#define PCIE_USB3_RATE_MASK\t\tGENMASK(6, 5)\n#define PCIE_USB3_RX_STANDBY_MASK\tBIT(7)\n#define PCIE_USB3_PHY_ENABLE\t\tBIT(4)\n\nstruct jh7110_pcie_phy {\n\tstruct phy *phy;\n\tstruct regmap *stg_syscon;\n\tstruct regmap *sys_syscon;\n\tvoid __iomem *regs;\n\tu32 sys_phy_connect;\n\tu32 stg_pcie_mode;\n\tu32 stg_pcie_usb;\n\tenum phy_mode mode;\n};\n\nstatic int phy_usb3_mode_set(struct jh7110_pcie_phy *data)\n{\n\tif (!data->stg_syscon || !data->sys_syscon) {\n\t\tdev_err(&data->phy->dev, \"doesn't support usb3 mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(data->stg_syscon, data->stg_pcie_mode,\n\t\t\t   PCIE_PHY_MODE_MASK, PCIE_PHY_MODE);\n\tregmap_update_bits(data->stg_syscon, data->stg_pcie_usb,\n\t\t\t   PCIE_USB3_BUS_WIDTH_MASK, 0);\n\tregmap_update_bits(data->stg_syscon, data->stg_pcie_usb,\n\t\t\t   PCIE_USB3_PHY_ENABLE, PCIE_USB3_PHY_ENABLE);\n\n\t \n\tregmap_update_bits(data->sys_syscon, data->sys_phy_connect,\n\t\t\t   USB_PDRSTN_SPLIT, 0);\n\n\t \n\twritel(PCIE_USB3_PHY_ENABLE, data->regs + PCIE_USB3_PHY_PLL_CTL_OFF);\n\n\treturn 0;\n}\n\nstatic void phy_pcie_mode_set(struct jh7110_pcie_phy *data)\n{\n\tu32 val;\n\n\t \n\tif (!data->stg_syscon || !data->sys_syscon)\n\t\treturn;\n\n\tregmap_update_bits(data->stg_syscon, data->stg_pcie_mode,\n\t\t\t   PCIE_PHY_MODE_MASK, 0);\n\tregmap_update_bits(data->stg_syscon, data->stg_pcie_usb,\n\t\t\t   PCIE_USB3_BUS_WIDTH_MASK,\n\t\t\t   PCIE_USB3_BUS_WIDTH);\n\tregmap_update_bits(data->stg_syscon, data->stg_pcie_usb,\n\t\t\t   PCIE_USB3_PHY_ENABLE, 0);\n\n\tregmap_update_bits(data->sys_syscon, data->sys_phy_connect,\n\t\t\t   USB_PDRSTN_SPLIT, 0);\n\n\tval = readl(data->regs + PCIE_USB3_PHY_PLL_CTL_OFF);\n\tval &= ~PCIE_USB3_PHY_ENABLE;\n\twritel(val, data->regs + PCIE_USB3_PHY_PLL_CTL_OFF);\n}\n\nstatic void phy_kvco_gain_set(struct jh7110_pcie_phy *phy)\n{\n\t \n\twritel(PHY_KVCO_FINE_TUNE_LEVEL, phy->regs + PCIE_KVCO_LEVEL_OFF);\n\twritel(PHY_KVCO_FINE_TUNE_SIGNALS, phy->regs + PCIE_KVCO_TUNE_SIGNAL_OFF);\n}\n\nstatic int jh7110_pcie_phy_set_mode(struct phy *_phy,\n\t\t\t\t    enum phy_mode mode, int submode)\n{\n\tstruct jh7110_pcie_phy *phy = phy_get_drvdata(_phy);\n\tint ret;\n\n\tif (mode == phy->mode)\n\t\treturn 0;\n\n\tswitch (mode) {\n\tcase PHY_MODE_USB_HOST:\n\tcase PHY_MODE_USB_DEVICE:\n\tcase PHY_MODE_USB_OTG:\n\t\tret = phy_usb3_mode_set(phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase PHY_MODE_PCIE:\n\t\tphy_pcie_mode_set(phy);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&_phy->dev, \"Changing phy mode to %d\\n\", mode);\n\tphy->mode = mode;\n\n\treturn 0;\n}\n\nstatic const struct phy_ops jh7110_pcie_phy_ops = {\n\t.set_mode\t= jh7110_pcie_phy_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int jh7110_pcie_phy_probe(struct platform_device *pdev)\n{\n\tstruct jh7110_pcie_phy *phy;\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *phy_provider;\n\tu32 args[2];\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(phy->regs))\n\t\treturn PTR_ERR(phy->regs);\n\n\tphy->phy = devm_phy_create(dev, NULL, &jh7110_pcie_phy_ops);\n\tif (IS_ERR(phy->phy))\n\t\treturn dev_err_probe(dev, PTR_ERR(phy->phy),\n\t\t\t\t     \"Failed to map phy base\\n\");\n\n\tphy->sys_syscon =\n\t\tsyscon_regmap_lookup_by_phandle_args(pdev->dev.of_node,\n\t\t\t\t\t\t     \"starfive,sys-syscon\",\n\t\t\t\t\t\t     1, args);\n\n\tif (!IS_ERR_OR_NULL(phy->sys_syscon))\n\t\tphy->sys_phy_connect = args[0];\n\telse\n\t\tphy->sys_syscon = NULL;\n\n\tphy->stg_syscon =\n\t\tsyscon_regmap_lookup_by_phandle_args(pdev->dev.of_node,\n\t\t\t\t\t\t     \"starfive,stg-syscon\",\n\t\t\t\t\t\t     2, args);\n\n\tif (!IS_ERR_OR_NULL(phy->stg_syscon)) {\n\t\tphy->stg_pcie_mode = args[0];\n\t\tphy->stg_pcie_usb = args[1];\n\t} else {\n\t\tphy->stg_syscon = NULL;\n\t}\n\n\tphy_kvco_gain_set(phy);\n\n\tphy_set_drvdata(phy->phy, phy);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id jh7110_pcie_phy_of_match[] = {\n\t{ .compatible = \"starfive,jh7110-pcie-phy\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, jh7110_pcie_phy_of_match);\n\nstatic struct platform_driver jh7110_pcie_phy_driver = {\n\t.probe\t= jh7110_pcie_phy_probe,\n\t.driver = {\n\t\t.of_match_table\t= jh7110_pcie_phy_of_match,\n\t\t.name  = \"jh7110-pcie-phy\",\n\t}\n};\nmodule_platform_driver(jh7110_pcie_phy_driver);\n\nMODULE_DESCRIPTION(\"StarFive JH7110 PCIe 2.0 PHY driver\");\nMODULE_AUTHOR(\"Minda Chen <minda.chen@starfivetech.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}