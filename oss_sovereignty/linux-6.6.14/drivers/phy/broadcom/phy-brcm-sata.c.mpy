{
  "module_name": "phy-brcm-sata.c",
  "hash_id": "0fafbe3412e4f8722599cf82f94c6fe086c8788b8cc0bbc46ec24729c6b7a62f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/broadcom/phy-brcm-sata.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\n#define SATA_PCB_BANK_OFFSET\t\t\t\t0x23c\n#define SATA_PCB_REG_OFFSET(ofs)\t\t\t((ofs) * 4)\n\n#define MAX_PORTS\t\t\t\t\t2\n\n \n#define SATA_PCB_REG_28NM_SPACE_SIZE\t\t\t0x1000\n\n \n#define SATA_PCB_REG_40NM_SPACE_SIZE\t\t\t0x10\n\n \n#define SATA_PHY_CTRL_REG_28NM_SPACE_SIZE\t\t0x8\n\nenum brcm_sata_phy_version {\n\tBRCM_SATA_PHY_STB_16NM,\n\tBRCM_SATA_PHY_STB_28NM,\n\tBRCM_SATA_PHY_STB_40NM,\n\tBRCM_SATA_PHY_IPROC_NS2,\n\tBRCM_SATA_PHY_IPROC_NSP,\n\tBRCM_SATA_PHY_IPROC_SR,\n\tBRCM_SATA_PHY_DSL_28NM,\n};\n\nenum brcm_sata_phy_rxaeq_mode {\n\tRXAEQ_MODE_OFF = 0,\n\tRXAEQ_MODE_AUTO,\n\tRXAEQ_MODE_MANUAL,\n};\n\nstatic enum brcm_sata_phy_rxaeq_mode rxaeq_to_val(const char *m)\n{\n\tif (!strcmp(m, \"auto\"))\n\t\treturn RXAEQ_MODE_AUTO;\n\telse if (!strcmp(m, \"manual\"))\n\t\treturn RXAEQ_MODE_MANUAL;\n\telse\n\t\treturn RXAEQ_MODE_OFF;\n}\n\nstruct brcm_sata_port {\n\tint portnum;\n\tstruct phy *phy;\n\tstruct brcm_sata_phy *phy_priv;\n\tbool ssc_en;\n\tenum brcm_sata_phy_rxaeq_mode rxaeq_mode;\n\tu32 rxaeq_val;\n\tu32 tx_amplitude_val;\n};\n\nstruct brcm_sata_phy {\n\tstruct device *dev;\n\tvoid __iomem *phy_base;\n\tvoid __iomem *ctrl_base;\n\tenum brcm_sata_phy_version version;\n\n\tstruct brcm_sata_port phys[MAX_PORTS];\n};\n\nenum sata_phy_regs {\n\tBLOCK0_REG_BANK\t\t\t\t= 0x000,\n\tBLOCK0_XGXSSTATUS\t\t\t= 0x81,\n\tBLOCK0_XGXSSTATUS_PLL_LOCK\t\t= BIT(12),\n\tBLOCK0_SPARE\t\t\t\t= 0x8d,\n\tBLOCK0_SPARE_OOB_CLK_SEL_MASK\t\t= 0x3,\n\tBLOCK0_SPARE_OOB_CLK_SEL_REFBY2\t\t= 0x1,\n\n\tBLOCK1_REG_BANK\t\t\t\t= 0x10,\n\tBLOCK1_TEST_TX\t\t\t\t= 0x83,\n\tBLOCK1_TEST_TX_AMP_SHIFT\t\t= 12,\n\n\tPLL_REG_BANK_0\t\t\t\t= 0x050,\n\tPLL_REG_BANK_0_PLLCONTROL_0\t\t= 0x81,\n\tPLLCONTROL_0_FREQ_DET_RESTART\t\t= BIT(13),\n\tPLLCONTROL_0_FREQ_MONITOR\t\t= BIT(12),\n\tPLLCONTROL_0_SEQ_START\t\t\t= BIT(15),\n\tPLL_CAP_CHARGE_TIME\t\t\t= 0x83,\n\tPLL_VCO_CAL_THRESH\t\t\t= 0x84,\n\tPLL_CAP_CONTROL\t\t\t\t= 0x85,\n\tPLL_FREQ_DET_TIME\t\t\t= 0x86,\n\tPLL_ACTRL2\t\t\t\t= 0x8b,\n\tPLL_ACTRL2_SELDIV_MASK\t\t\t= 0x1f,\n\tPLL_ACTRL2_SELDIV_SHIFT\t\t\t= 9,\n\tPLL_ACTRL6\t\t\t\t= 0x86,\n\n\tPLL1_REG_BANK\t\t\t\t= 0x060,\n\tPLL1_ACTRL2\t\t\t\t= 0x82,\n\tPLL1_ACTRL3\t\t\t\t= 0x83,\n\tPLL1_ACTRL4\t\t\t\t= 0x84,\n\tPLL1_ACTRL5\t\t\t\t= 0x85,\n\tPLL1_ACTRL6\t\t\t\t= 0x86,\n\tPLL1_ACTRL7\t\t\t\t= 0x87,\n\tPLL1_ACTRL8\t\t\t\t= 0x88,\n\n\tTX_REG_BANK\t\t\t\t= 0x070,\n\tTX_ACTRL0\t\t\t\t= 0x80,\n\tTX_ACTRL0_TXPOL_FLIP\t\t\t= BIT(6),\n\tTX_ACTRL5\t\t\t\t= 0x85,\n\tTX_ACTRL5_SSC_EN\t\t\t= BIT(11),\n\n\tAEQRX_REG_BANK_0\t\t\t= 0xd0,\n\tAEQ_CONTROL1\t\t\t\t= 0x81,\n\tAEQ_CONTROL1_ENABLE\t\t\t= BIT(2),\n\tAEQ_CONTROL1_FREEZE\t\t\t= BIT(3),\n\tAEQ_FRC_EQ\t\t\t\t= 0x83,\n\tAEQ_FRC_EQ_FORCE\t\t\t= BIT(0),\n\tAEQ_FRC_EQ_FORCE_VAL\t\t\t= BIT(1),\n\tAEQ_RFZ_FRC_VAL\t\t\t\t= BIT(8),\n\tAEQRX_REG_BANK_1\t\t\t= 0xe0,\n\tAEQRX_SLCAL0_CTRL0\t\t\t= 0x82,\n\tAEQRX_SLCAL1_CTRL0\t\t\t= 0x86,\n\n\tOOB_REG_BANK\t\t\t\t= 0x150,\n\tOOB1_REG_BANK\t\t\t\t= 0x160,\n\tOOB_CTRL1\t\t\t\t= 0x80,\n\tOOB_CTRL1_BURST_MAX_MASK\t\t= 0xf,\n\tOOB_CTRL1_BURST_MAX_SHIFT\t\t= 12,\n\tOOB_CTRL1_BURST_MIN_MASK\t\t= 0xf,\n\tOOB_CTRL1_BURST_MIN_SHIFT\t\t= 8,\n\tOOB_CTRL1_WAKE_IDLE_MAX_MASK\t\t= 0xf,\n\tOOB_CTRL1_WAKE_IDLE_MAX_SHIFT\t\t= 4,\n\tOOB_CTRL1_WAKE_IDLE_MIN_MASK\t\t= 0xf,\n\tOOB_CTRL1_WAKE_IDLE_MIN_SHIFT\t\t= 0,\n\tOOB_CTRL2\t\t\t\t= 0x81,\n\tOOB_CTRL2_SEL_ENA_SHIFT\t\t\t= 15,\n\tOOB_CTRL2_SEL_ENA_RC_SHIFT\t\t= 14,\n\tOOB_CTRL2_RESET_IDLE_MAX_MASK\t\t= 0x3f,\n\tOOB_CTRL2_RESET_IDLE_MAX_SHIFT\t\t= 8,\n\tOOB_CTRL2_BURST_CNT_MASK\t\t= 0x3,\n\tOOB_CTRL2_BURST_CNT_SHIFT\t\t= 6,\n\tOOB_CTRL2_RESET_IDLE_MIN_MASK\t\t= 0x3f,\n\tOOB_CTRL2_RESET_IDLE_MIN_SHIFT\t\t= 0,\n\n\tTXPMD_REG_BANK\t\t\t\t= 0x1a0,\n\tTXPMD_CONTROL1\t\t\t\t= 0x81,\n\tTXPMD_CONTROL1_TX_SSC_EN_FRC\t\t= BIT(0),\n\tTXPMD_CONTROL1_TX_SSC_EN_FRC_VAL\t= BIT(1),\n\tTXPMD_TX_FREQ_CTRL_CONTROL1\t\t= 0x82,\n\tTXPMD_TX_FREQ_CTRL_CONTROL2\t\t= 0x83,\n\tTXPMD_TX_FREQ_CTRL_CONTROL2_FMIN_MASK\t= 0x3ff,\n\tTXPMD_TX_FREQ_CTRL_CONTROL3\t\t= 0x84,\n\tTXPMD_TX_FREQ_CTRL_CONTROL3_FMAX_MASK\t= 0x3ff,\n\n\tRXPMD_REG_BANK\t\t\t\t= 0x1c0,\n\tRXPMD_RX_CDR_CONTROL1\t\t\t= 0x81,\n\tRXPMD_RX_PPM_VAL_MASK\t\t\t= 0x1ff,\n\tRXPMD_RXPMD_EN_FRC\t\t\t= BIT(12),\n\tRXPMD_RXPMD_EN_FRC_VAL\t\t\t= BIT(13),\n\tRXPMD_RX_CDR_CDR_PROP_BW\t\t= 0x82,\n\tRXPMD_G_CDR_PROP_BW_MASK\t\t= 0x7,\n\tRXPMD_G1_CDR_PROP_BW_SHIFT\t\t= 0,\n\tRXPMD_G2_CDR_PROP_BW_SHIFT\t\t= 3,\n\tRXPMD_G3_CDR_PROB_BW_SHIFT\t\t= 6,\n\tRXPMD_RX_CDR_CDR_ACQ_INTEG_BW\t\t= 0x83,\n\tRXPMD_G_CDR_ACQ_INT_BW_MASK\t\t= 0x7,\n\tRXPMD_G1_CDR_ACQ_INT_BW_SHIFT\t\t= 0,\n\tRXPMD_G2_CDR_ACQ_INT_BW_SHIFT\t\t= 3,\n\tRXPMD_G3_CDR_ACQ_INT_BW_SHIFT\t\t= 6,\n\tRXPMD_RX_CDR_CDR_LOCK_INTEG_BW\t\t= 0x84,\n\tRXPMD_G_CDR_LOCK_INT_BW_MASK\t\t= 0x7,\n\tRXPMD_G1_CDR_LOCK_INT_BW_SHIFT\t\t= 0,\n\tRXPMD_G2_CDR_LOCK_INT_BW_SHIFT\t\t= 3,\n\tRXPMD_G3_CDR_LOCK_INT_BW_SHIFT\t\t= 6,\n\tRXPMD_RX_FREQ_MON_CONTROL1\t\t= 0x87,\n\tRXPMD_MON_CORRECT_EN\t\t\t= BIT(8),\n\tRXPMD_MON_MARGIN_VAL_MASK\t\t= 0xff,\n};\n\nenum sata_phy_ctrl_regs {\n\tPHY_CTRL_1\t\t\t\t= 0x0,\n\tPHY_CTRL_1_RESET\t\t\t= BIT(0),\n};\n\nstatic inline void __iomem *brcm_sata_ctrl_base(struct brcm_sata_port *port)\n{\n\tstruct brcm_sata_phy *priv = port->phy_priv;\n\tu32 size = 0;\n\n\tswitch (priv->version) {\n\tcase BRCM_SATA_PHY_IPROC_NS2:\n\t\tsize = SATA_PHY_CTRL_REG_28NM_SPACE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"invalid phy version\\n\");\n\t\tbreak;\n\t}\n\n\treturn priv->ctrl_base + (port->portnum * size);\n}\n\nstatic void brcm_sata_phy_wr(struct brcm_sata_port *port, u32 bank,\n\t\t\t     u32 ofs, u32 msk, u32 value)\n{\n\tstruct brcm_sata_phy *priv = port->phy_priv;\n\tvoid __iomem *pcb_base = priv->phy_base;\n\tu32 tmp;\n\n\tif (priv->version == BRCM_SATA_PHY_STB_40NM)\n\t\tbank += (port->portnum * SATA_PCB_REG_40NM_SPACE_SIZE);\n\telse\n\t\tpcb_base += (port->portnum * SATA_PCB_REG_28NM_SPACE_SIZE);\n\n\twritel(bank, pcb_base + SATA_PCB_BANK_OFFSET);\n\ttmp = readl(pcb_base + SATA_PCB_REG_OFFSET(ofs));\n\ttmp = (tmp & msk) | value;\n\twritel(tmp, pcb_base + SATA_PCB_REG_OFFSET(ofs));\n}\n\nstatic u32 brcm_sata_phy_rd(struct brcm_sata_port *port, u32 bank, u32 ofs)\n{\n\tstruct brcm_sata_phy *priv = port->phy_priv;\n\tvoid __iomem *pcb_base = priv->phy_base;\n\n\tif (priv->version == BRCM_SATA_PHY_STB_40NM)\n\t\tbank += (port->portnum * SATA_PCB_REG_40NM_SPACE_SIZE);\n\telse\n\t\tpcb_base += (port->portnum * SATA_PCB_REG_28NM_SPACE_SIZE);\n\n\twritel(bank, pcb_base + SATA_PCB_BANK_OFFSET);\n\treturn readl(pcb_base + SATA_PCB_REG_OFFSET(ofs));\n}\n\n \n#define STB_FMIN_VAL_DEFAULT\t0x3df\n#define STB_FMAX_VAL_DEFAULT\t0x3df\n#define STB_FMAX_VAL_SSC\t0x83\n\nstatic void brcm_stb_sata_ssc_init(struct brcm_sata_port *port)\n{\n\tstruct brcm_sata_phy *priv = port->phy_priv;\n\tu32 tmp;\n\n\t \n\ttmp = TXPMD_CONTROL1_TX_SSC_EN_FRC_VAL | TXPMD_CONTROL1_TX_SSC_EN_FRC;\n\tbrcm_sata_phy_wr(port, TXPMD_REG_BANK, TXPMD_CONTROL1, ~tmp, tmp);\n\n\t \n\tbrcm_sata_phy_wr(port, TXPMD_REG_BANK, TXPMD_TX_FREQ_CTRL_CONTROL2,\n\t\t\t ~TXPMD_TX_FREQ_CTRL_CONTROL2_FMIN_MASK,\n\t\t\t STB_FMIN_VAL_DEFAULT);\n\n\t \n\tif (port->ssc_en) {\n\t\tdev_info(priv->dev, \"enabling SSC on port%d\\n\", port->portnum);\n\t\ttmp = STB_FMAX_VAL_SSC;\n\t} else {\n\t\ttmp = STB_FMAX_VAL_DEFAULT;\n\t}\n\n\tbrcm_sata_phy_wr(port, TXPMD_REG_BANK, TXPMD_TX_FREQ_CTRL_CONTROL3,\n\t\t\t  ~TXPMD_TX_FREQ_CTRL_CONTROL3_FMAX_MASK, tmp);\n}\n\n#define AEQ_FRC_EQ_VAL_SHIFT\t2\n#define AEQ_FRC_EQ_VAL_MASK\t0x3f\n\nstatic int brcm_stb_sata_rxaeq_init(struct brcm_sata_port *port)\n{\n\tu32 tmp = 0, reg = 0;\n\n\tswitch (port->rxaeq_mode) {\n\tcase RXAEQ_MODE_OFF:\n\t\treturn 0;\n\n\tcase RXAEQ_MODE_AUTO:\n\t\treg = AEQ_CONTROL1;\n\t\ttmp = AEQ_CONTROL1_ENABLE | AEQ_CONTROL1_FREEZE;\n\t\tbreak;\n\n\tcase RXAEQ_MODE_MANUAL:\n\t\treg = AEQ_FRC_EQ;\n\t\ttmp = AEQ_FRC_EQ_FORCE | AEQ_FRC_EQ_FORCE_VAL;\n\t\tif (port->rxaeq_val > AEQ_FRC_EQ_VAL_MASK)\n\t\t\treturn -EINVAL;\n\t\ttmp |= port->rxaeq_val << AEQ_FRC_EQ_VAL_SHIFT;\n\t\tbreak;\n\t}\n\n\tbrcm_sata_phy_wr(port, AEQRX_REG_BANK_0, reg, ~tmp, tmp);\n\tbrcm_sata_phy_wr(port, AEQRX_REG_BANK_1, reg, ~tmp, tmp);\n\n\treturn 0;\n}\n\nstatic int brcm_stb_sata_init(struct brcm_sata_port *port)\n{\n\tbrcm_stb_sata_ssc_init(port);\n\n\treturn brcm_stb_sata_rxaeq_init(port);\n}\n\nstatic int brcm_stb_sata_16nm_ssc_init(struct brcm_sata_port *port)\n{\n\tu32 tmp, value;\n\n\t \n\tbrcm_sata_phy_wr(port, PLL1_REG_BANK, PLL1_ACTRL6, 0, 0x141);\n\n\t \n\tbrcm_sata_phy_wr(port, PLL1_REG_BANK, PLL1_ACTRL8, 0, 0xc006);\n\n\t \n\ttmp = AEQ_FRC_EQ_FORCE_VAL | AEQ_FRC_EQ_FORCE;\n\tbrcm_sata_phy_wr(port, AEQRX_REG_BANK_0, AEQ_FRC_EQ,\n\t\t\t ~(tmp | AEQ_RFZ_FRC_VAL |\n\t\t\t   AEQ_FRC_EQ_VAL_MASK << AEQ_FRC_EQ_VAL_SHIFT),\n\t\t\t tmp | 32 << AEQ_FRC_EQ_VAL_SHIFT);\n\n\t \n\tif (port->ssc_en)\n\t\tvalue = 0x52;\n\telse\n\t\tvalue = 0;\n\tbrcm_sata_phy_wr(port, RXPMD_REG_BANK, RXPMD_RX_CDR_CONTROL1,\n\t\t\t ~RXPMD_RX_PPM_VAL_MASK, value);\n\n\t \n\ttmp = RXPMD_G_CDR_PROP_BW_MASK << RXPMD_G1_CDR_PROP_BW_SHIFT |\n\t      RXPMD_G_CDR_PROP_BW_MASK << RXPMD_G2_CDR_PROP_BW_SHIFT |\n\t      RXPMD_G_CDR_PROP_BW_MASK << RXPMD_G3_CDR_PROB_BW_SHIFT;\n\tif (port->ssc_en)\n\t\tvalue = 2 << RXPMD_G1_CDR_PROP_BW_SHIFT |\n\t\t\t2 << RXPMD_G2_CDR_PROP_BW_SHIFT |\n\t\t\t2 << RXPMD_G3_CDR_PROB_BW_SHIFT;\n\telse\n\t\tvalue = 1 << RXPMD_G1_CDR_PROP_BW_SHIFT |\n\t\t\t1 << RXPMD_G2_CDR_PROP_BW_SHIFT |\n\t\t\t1 << RXPMD_G3_CDR_PROB_BW_SHIFT;\n\tbrcm_sata_phy_wr(port, RXPMD_REG_BANK, RXPMD_RX_CDR_CDR_PROP_BW, ~tmp,\n\t\t\t value);\n\n\t \n\ttmp = RXPMD_G_CDR_ACQ_INT_BW_MASK << RXPMD_G1_CDR_ACQ_INT_BW_SHIFT |\n\t      RXPMD_G_CDR_ACQ_INT_BW_MASK << RXPMD_G2_CDR_ACQ_INT_BW_SHIFT |\n\t      RXPMD_G_CDR_ACQ_INT_BW_MASK << RXPMD_G3_CDR_ACQ_INT_BW_SHIFT;\n\tif (port->ssc_en)\n\t\tvalue = 1 << RXPMD_G1_CDR_ACQ_INT_BW_SHIFT |\n\t\t\t1 << RXPMD_G2_CDR_ACQ_INT_BW_SHIFT |\n\t\t\t1 << RXPMD_G3_CDR_ACQ_INT_BW_SHIFT;\n\telse\n\t\tvalue = 0;\n\tbrcm_sata_phy_wr(port, RXPMD_REG_BANK, RXPMD_RX_CDR_CDR_ACQ_INTEG_BW,\n\t\t\t ~tmp, value);\n\n\t \n\ttmp = RXPMD_G_CDR_LOCK_INT_BW_MASK << RXPMD_G1_CDR_LOCK_INT_BW_SHIFT |\n\t      RXPMD_G_CDR_LOCK_INT_BW_MASK << RXPMD_G2_CDR_LOCK_INT_BW_SHIFT |\n\t      RXPMD_G_CDR_LOCK_INT_BW_MASK << RXPMD_G3_CDR_LOCK_INT_BW_SHIFT;\n\tif (port->ssc_en)\n\t\tvalue = 1 << RXPMD_G1_CDR_LOCK_INT_BW_SHIFT |\n\t\t\t1 << RXPMD_G2_CDR_LOCK_INT_BW_SHIFT |\n\t\t\t1 << RXPMD_G3_CDR_LOCK_INT_BW_SHIFT;\n\telse\n\t\tvalue = 0;\n\tbrcm_sata_phy_wr(port, RXPMD_REG_BANK, RXPMD_RX_CDR_CDR_LOCK_INTEG_BW,\n\t\t\t ~tmp, value);\n\n\t \n\ttmp = RXPMD_MON_CORRECT_EN | RXPMD_MON_MARGIN_VAL_MASK;\n\tif (port->ssc_en)\n\t\tvalue = 0x51;\n\telse\n\t\tvalue = 0;\n\tbrcm_sata_phy_wr(port, RXPMD_REG_BANK, RXPMD_RX_FREQ_MON_CONTROL1,\n\t\t\t ~tmp, RXPMD_MON_CORRECT_EN | value);\n\n\ttmp = GENMASK(15, 12);\n\tswitch (port->tx_amplitude_val) {\n\tcase 400:\n\t\tvalue = BIT(12) | BIT(13);\n\t\tbreak;\n\tcase 500:\n\t\tvalue = BIT(13);\n\t\tbreak;\n\tcase 600:\n\t\tvalue = BIT(12);\n\t\tbreak;\n\tcase 800:\n\t\tvalue = 0;\n\t\tbreak;\n\tdefault:\n\t\tvalue = tmp;\n\t\tbreak;\n\t}\n\n\tif (value != tmp)\n\t\tbrcm_sata_phy_wr(port, BLOCK1_REG_BANK, BLOCK1_TEST_TX, ~tmp,\n\t\t\t\t value);\n\n\t \n\tbrcm_sata_phy_wr(port, TX_REG_BANK, TX_ACTRL5, ~TX_ACTRL5_SSC_EN,\n\t\t\t port->ssc_en ? TX_ACTRL5_SSC_EN : 0);\n\n\treturn 0;\n}\n\nstatic int brcm_stb_sata_16nm_init(struct brcm_sata_port *port)\n{\n\treturn brcm_stb_sata_16nm_ssc_init(port);\n}\n\n \n#define NS2_PLL1_ACTRL2_MAGIC\t0x1df8\n#define NS2_PLL1_ACTRL3_MAGIC\t0x2b00\n#define NS2_PLL1_ACTRL4_MAGIC\t0x8824\n\nstatic int brcm_ns2_sata_init(struct brcm_sata_port *port)\n{\n\tint try;\n\tunsigned int val;\n\tvoid __iomem *ctrl_base = brcm_sata_ctrl_base(port);\n\tstruct device *dev = port->phy_priv->dev;\n\n\t \n\tval = 0x0;\n\tval |= (0xc << OOB_CTRL1_BURST_MAX_SHIFT);\n\tval |= (0x4 << OOB_CTRL1_BURST_MIN_SHIFT);\n\tval |= (0x9 << OOB_CTRL1_WAKE_IDLE_MAX_SHIFT);\n\tval |= (0x3 << OOB_CTRL1_WAKE_IDLE_MIN_SHIFT);\n\tbrcm_sata_phy_wr(port, OOB_REG_BANK, OOB_CTRL1, 0x0, val);\n\tval = 0x0;\n\tval |= (0x1b << OOB_CTRL2_RESET_IDLE_MAX_SHIFT);\n\tval |= (0x2 << OOB_CTRL2_BURST_CNT_SHIFT);\n\tval |= (0x9 << OOB_CTRL2_RESET_IDLE_MIN_SHIFT);\n\tbrcm_sata_phy_wr(port, OOB_REG_BANK, OOB_CTRL2, 0x0, val);\n\n\t \n\tval = NS2_PLL1_ACTRL2_MAGIC;\n\tbrcm_sata_phy_wr(port, PLL1_REG_BANK, PLL1_ACTRL2, 0x0, val);\n\tval = NS2_PLL1_ACTRL3_MAGIC;\n\tbrcm_sata_phy_wr(port, PLL1_REG_BANK, PLL1_ACTRL3, 0x0, val);\n\tval = NS2_PLL1_ACTRL4_MAGIC;\n\tbrcm_sata_phy_wr(port, PLL1_REG_BANK, PLL1_ACTRL4, 0x0, val);\n\n\t \n\t \n\tbrcm_sata_phy_wr(port, BLOCK0_REG_BANK, BLOCK0_SPARE,\n\t\t\t ~BLOCK0_SPARE_OOB_CLK_SEL_MASK,\n\t\t\t BLOCK0_SPARE_OOB_CLK_SEL_REFBY2);\n\n\t \n\twritel(PHY_CTRL_1_RESET, ctrl_base + PHY_CTRL_1);\n\tmdelay(1);\n\twritel(0x0, ctrl_base + PHY_CTRL_1);\n\tmdelay(1);\n\n\t \n\ttry = 50;\n\twhile (try) {\n\t\tval = brcm_sata_phy_rd(port, BLOCK0_REG_BANK,\n\t\t\t\t\tBLOCK0_XGXSSTATUS);\n\t\tif (val & BLOCK0_XGXSSTATUS_PLL_LOCK)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t\ttry--;\n\t}\n\tif (!try) {\n\t\t \n\t\tdev_err(dev, \"port%d PLL did not lock\\n\", port->portnum);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_dbg(dev, \"port%d initialized\\n\", port->portnum);\n\n\treturn 0;\n}\n\nstatic int brcm_nsp_sata_init(struct brcm_sata_port *port)\n{\n\tstruct device *dev = port->phy_priv->dev;\n\tunsigned int oob_bank;\n\tunsigned int val, try;\n\n\t \n\tif (port->portnum == 0)\n\t\toob_bank = OOB_REG_BANK;\n\telse if (port->portnum == 1)\n\t\toob_bank = OOB1_REG_BANK;\n\telse\n\t\treturn -EINVAL;\n\n\tval = 0x0;\n\tval |= (0x0f << OOB_CTRL1_BURST_MAX_SHIFT);\n\tval |= (0x06 << OOB_CTRL1_BURST_MIN_SHIFT);\n\tval |= (0x0f << OOB_CTRL1_WAKE_IDLE_MAX_SHIFT);\n\tval |= (0x06 << OOB_CTRL1_WAKE_IDLE_MIN_SHIFT);\n\tbrcm_sata_phy_wr(port, oob_bank, OOB_CTRL1, 0x0, val);\n\n\tval = 0x0;\n\tval |= (0x2e << OOB_CTRL2_RESET_IDLE_MAX_SHIFT);\n\tval |= (0x02 << OOB_CTRL2_BURST_CNT_SHIFT);\n\tval |= (0x16 << OOB_CTRL2_RESET_IDLE_MIN_SHIFT);\n\tbrcm_sata_phy_wr(port, oob_bank, OOB_CTRL2, 0x0, val);\n\n\n\tbrcm_sata_phy_wr(port, PLL_REG_BANK_0, PLL_ACTRL2,\n\t\t~(PLL_ACTRL2_SELDIV_MASK << PLL_ACTRL2_SELDIV_SHIFT),\n\t\t0x0c << PLL_ACTRL2_SELDIV_SHIFT);\n\n\tbrcm_sata_phy_wr(port, PLL_REG_BANK_0, PLL_CAP_CONTROL,\n\t\t\t\t\t\t0xff0, 0x4f0);\n\n\tval = PLLCONTROL_0_FREQ_DET_RESTART | PLLCONTROL_0_FREQ_MONITOR;\n\tbrcm_sata_phy_wr(port, PLL_REG_BANK_0, PLL_REG_BANK_0_PLLCONTROL_0,\n\t\t\t\t\t\t\t\t~val, val);\n\tval = PLLCONTROL_0_SEQ_START;\n\tbrcm_sata_phy_wr(port, PLL_REG_BANK_0, PLL_REG_BANK_0_PLLCONTROL_0,\n\t\t\t\t\t\t\t\t~val, 0);\n\tmdelay(10);\n\tbrcm_sata_phy_wr(port, PLL_REG_BANK_0, PLL_REG_BANK_0_PLLCONTROL_0,\n\t\t\t\t\t\t\t\t~val, val);\n\n\t \n\ttry = 50;\n\twhile (--try) {\n\t\tval = brcm_sata_phy_rd(port, BLOCK0_REG_BANK,\n\t\t\t\t\tBLOCK0_XGXSSTATUS);\n\t\tif (val & BLOCK0_XGXSSTATUS_PLL_LOCK)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\tif (!try) {\n\t\t \n\t\tdev_err(dev, \"port%d PLL did not lock\\n\", port->portnum);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_dbg(dev, \"port%d initialized\\n\", port->portnum);\n\n\treturn 0;\n}\n\n \n#define SR_PLL0_ACTRL6_MAGIC\t\t\t0xa\n\n \n#define SR_PLL1_ACTRL2_MAGIC\t\t\t0x32\n#define SR_PLL1_ACTRL3_MAGIC\t\t\t0x2\n#define SR_PLL1_ACTRL4_MAGIC\t\t\t0x3e8\n\nstatic int brcm_sr_sata_init(struct brcm_sata_port *port)\n{\n\tstruct device *dev = port->phy_priv->dev;\n\tunsigned int val, try;\n\n\t \n\tval = SR_PLL1_ACTRL2_MAGIC;\n\tbrcm_sata_phy_wr(port, PLL1_REG_BANK, PLL1_ACTRL2, 0x0, val);\n\tval = SR_PLL1_ACTRL3_MAGIC;\n\tbrcm_sata_phy_wr(port, PLL1_REG_BANK, PLL1_ACTRL3, 0x0, val);\n\tval = SR_PLL1_ACTRL4_MAGIC;\n\tbrcm_sata_phy_wr(port, PLL1_REG_BANK, PLL1_ACTRL4, 0x0, val);\n\n\t \n\tval = SR_PLL0_ACTRL6_MAGIC;\n\tbrcm_sata_phy_wr(port, PLL_REG_BANK_0, PLL_ACTRL6, 0x0, val);\n\n\t \n\ttry = 50;\n\tdo {\n\t\tval = brcm_sata_phy_rd(port, BLOCK0_REG_BANK,\n\t\t\t\t\tBLOCK0_XGXSSTATUS);\n\t\tif (val & BLOCK0_XGXSSTATUS_PLL_LOCK)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t\ttry--;\n\t} while (try);\n\n\tif ((val & BLOCK0_XGXSSTATUS_PLL_LOCK) == 0) {\n\t\t \n\t\tdev_err(dev, \"port%d PLL did not lock\\n\", port->portnum);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tbrcm_sata_phy_wr(port, TX_REG_BANK, TX_ACTRL0,\n\t\t\t ~TX_ACTRL0_TXPOL_FLIP, TX_ACTRL0_TXPOL_FLIP);\n\n\t \n\tval = ((0xc << OOB_CTRL1_BURST_MAX_SHIFT) |\n\t\t(0x4 << OOB_CTRL1_BURST_MIN_SHIFT) |\n\t\t(0x8 << OOB_CTRL1_WAKE_IDLE_MAX_SHIFT) |\n\t\t(0x3 << OOB_CTRL1_WAKE_IDLE_MIN_SHIFT));\n\tbrcm_sata_phy_wr(port, OOB_REG_BANK, OOB_CTRL1, 0x0, val);\n\tval = ((0x1b << OOB_CTRL2_RESET_IDLE_MAX_SHIFT) |\n\t\t(0x2 << OOB_CTRL2_BURST_CNT_SHIFT) |\n\t\t(0x9 << OOB_CTRL2_RESET_IDLE_MIN_SHIFT));\n\tbrcm_sata_phy_wr(port, OOB_REG_BANK, OOB_CTRL2, 0x0, val);\n\n\treturn 0;\n}\n\nstatic int brcm_dsl_sata_init(struct brcm_sata_port *port)\n{\n\tstruct device *dev = port->phy_priv->dev;\n\tunsigned int try;\n\tu32 tmp;\n\n\tbrcm_sata_phy_wr(port, PLL1_REG_BANK, PLL1_ACTRL7, 0, 0x873);\n\n\tbrcm_sata_phy_wr(port, PLL1_REG_BANK, PLL1_ACTRL6, 0, 0xc000);\n\n\tbrcm_sata_phy_wr(port, PLL_REG_BANK_0, PLL_REG_BANK_0_PLLCONTROL_0,\n\t\t\t 0, 0x3089);\n\tusleep_range(1000, 2000);\n\n\tbrcm_sata_phy_wr(port, PLL_REG_BANK_0, PLL_REG_BANK_0_PLLCONTROL_0,\n\t\t\t 0, 0x3088);\n\tusleep_range(1000, 2000);\n\n\tbrcm_sata_phy_wr(port, AEQRX_REG_BANK_1, AEQRX_SLCAL0_CTRL0,\n\t\t\t 0, 0x3000);\n\n\tbrcm_sata_phy_wr(port, AEQRX_REG_BANK_1, AEQRX_SLCAL1_CTRL0,\n\t\t\t 0, 0x3000);\n\tusleep_range(1000, 2000);\n\n\tbrcm_sata_phy_wr(port, PLL_REG_BANK_0, PLL_CAP_CHARGE_TIME, 0, 0x32);\n\n\tbrcm_sata_phy_wr(port, PLL_REG_BANK_0, PLL_VCO_CAL_THRESH, 0, 0xa);\n\n\tbrcm_sata_phy_wr(port, PLL_REG_BANK_0, PLL_FREQ_DET_TIME, 0, 0x64);\n\tusleep_range(1000, 2000);\n\n\t \n\ttry = 50;\n\twhile (try) {\n\t\ttmp = brcm_sata_phy_rd(port, BLOCK0_REG_BANK,\n\t\t\t\t       BLOCK0_XGXSSTATUS);\n\t\tif (tmp & BLOCK0_XGXSSTATUS_PLL_LOCK)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t\ttry--;\n\t}\n\n\tif (!try) {\n\t\t \n\t\tdev_err(dev, \"port%d PLL did not lock\\n\", port->portnum);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_dbg(dev, \"port%d initialized\\n\", port->portnum);\n\n\treturn 0;\n}\n\nstatic int brcm_sata_phy_init(struct phy *phy)\n{\n\tint rc;\n\tstruct brcm_sata_port *port = phy_get_drvdata(phy);\n\n\tswitch (port->phy_priv->version) {\n\tcase BRCM_SATA_PHY_STB_16NM:\n\t\trc = brcm_stb_sata_16nm_init(port);\n\t\tbreak;\n\tcase BRCM_SATA_PHY_STB_28NM:\n\tcase BRCM_SATA_PHY_STB_40NM:\n\t\trc = brcm_stb_sata_init(port);\n\t\tbreak;\n\tcase BRCM_SATA_PHY_IPROC_NS2:\n\t\trc = brcm_ns2_sata_init(port);\n\t\tbreak;\n\tcase BRCM_SATA_PHY_IPROC_NSP:\n\t\trc = brcm_nsp_sata_init(port);\n\t\tbreak;\n\tcase BRCM_SATA_PHY_IPROC_SR:\n\t\trc = brcm_sr_sata_init(port);\n\t\tbreak;\n\tcase BRCM_SATA_PHY_DSL_28NM:\n\t\trc = brcm_dsl_sata_init(port);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENODEV;\n\t}\n\n\treturn rc;\n}\n\nstatic void brcm_stb_sata_calibrate(struct brcm_sata_port *port)\n{\n\tu32 tmp = BIT(8);\n\n\tbrcm_sata_phy_wr(port, RXPMD_REG_BANK, RXPMD_RX_FREQ_MON_CONTROL1,\n\t\t\t ~tmp, tmp);\n}\n\nstatic int brcm_sata_phy_calibrate(struct phy *phy)\n{\n\tstruct brcm_sata_port *port = phy_get_drvdata(phy);\n\tint rc = -EOPNOTSUPP;\n\n\tswitch (port->phy_priv->version) {\n\tcase BRCM_SATA_PHY_STB_28NM:\n\tcase BRCM_SATA_PHY_STB_40NM:\n\t\tbrcm_stb_sata_calibrate(port);\n\t\trc = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic const struct phy_ops phy_ops = {\n\t.init\t\t= brcm_sata_phy_init,\n\t.calibrate\t= brcm_sata_phy_calibrate,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id brcm_sata_phy_of_match[] = {\n\t{ .compatible\t= \"brcm,bcm7216-sata-phy\",\n\t  .data = (void *)BRCM_SATA_PHY_STB_16NM },\n\t{ .compatible\t= \"brcm,bcm7445-sata-phy\",\n\t  .data = (void *)BRCM_SATA_PHY_STB_28NM },\n\t{ .compatible\t= \"brcm,bcm7425-sata-phy\",\n\t  .data = (void *)BRCM_SATA_PHY_STB_40NM },\n\t{ .compatible\t= \"brcm,iproc-ns2-sata-phy\",\n\t  .data = (void *)BRCM_SATA_PHY_IPROC_NS2 },\n\t{ .compatible = \"brcm,iproc-nsp-sata-phy\",\n\t  .data = (void *)BRCM_SATA_PHY_IPROC_NSP },\n\t{ .compatible\t= \"brcm,iproc-sr-sata-phy\",\n\t  .data = (void *)BRCM_SATA_PHY_IPROC_SR },\n\t{ .compatible\t= \"brcm,bcm63138-sata-phy\",\n\t  .data = (void *)BRCM_SATA_PHY_DSL_28NM },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, brcm_sata_phy_of_match);\n\nstatic int brcm_sata_phy_probe(struct platform_device *pdev)\n{\n\tconst char *rxaeq_mode;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *dn = dev->of_node, *child;\n\tconst struct of_device_id *of_id;\n\tstruct brcm_sata_phy *priv;\n\tstruct phy_provider *provider;\n\tint ret, count = 0;\n\n\tif (of_get_child_count(dn) == 0)\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, priv);\n\tpriv->dev = dev;\n\n\tpriv->phy_base = devm_platform_ioremap_resource_byname(pdev, \"phy\");\n\tif (IS_ERR(priv->phy_base))\n\t\treturn PTR_ERR(priv->phy_base);\n\n\tof_id = of_match_node(brcm_sata_phy_of_match, dn);\n\tif (of_id)\n\t\tpriv->version = (uintptr_t)of_id->data;\n\telse\n\t\tpriv->version = BRCM_SATA_PHY_STB_28NM;\n\n\tif (priv->version == BRCM_SATA_PHY_IPROC_NS2) {\n\t\tpriv->ctrl_base = devm_platform_ioremap_resource_byname(pdev, \"phy-ctrl\");\n\t\tif (IS_ERR(priv->ctrl_base))\n\t\t\treturn PTR_ERR(priv->ctrl_base);\n\t}\n\n\tfor_each_available_child_of_node(dn, child) {\n\t\tunsigned int id;\n\t\tstruct brcm_sata_port *port;\n\n\t\tif (of_property_read_u32(child, \"reg\", &id)) {\n\t\t\tdev_err(dev, \"missing reg property in node %pOFn\\n\",\n\t\t\t\t\tchild);\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tif (id >= MAX_PORTS) {\n\t\t\tdev_err(dev, \"invalid reg: %u\\n\", id);\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\t\tif (priv->phys[id].phy) {\n\t\t\tdev_err(dev, \"already registered port %u\\n\", id);\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tport = &priv->phys[id];\n\t\tport->portnum = id;\n\t\tport->phy_priv = priv;\n\t\tport->phy = devm_phy_create(dev, child, &phy_ops);\n\t\tport->rxaeq_mode = RXAEQ_MODE_OFF;\n\t\tif (!of_property_read_string(child, \"brcm,rxaeq-mode\",\n\t\t\t\t\t     &rxaeq_mode))\n\t\t\tport->rxaeq_mode = rxaeq_to_val(rxaeq_mode);\n\t\tif (port->rxaeq_mode == RXAEQ_MODE_MANUAL)\n\t\t\tof_property_read_u32(child, \"brcm,rxaeq-value\",\n\t\t\t\t\t     &port->rxaeq_val);\n\n\t\tof_property_read_u32(child, \"brcm,tx-amplitude-millivolt\",\n\t\t\t\t     &port->tx_amplitude_val);\n\n\t\tport->ssc_en = of_property_read_bool(child, \"brcm,enable-ssc\");\n\t\tif (IS_ERR(port->phy)) {\n\t\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\t\tret = PTR_ERR(port->phy);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tphy_set_drvdata(port->phy, port);\n\t\tcount++;\n\t}\n\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(provider)) {\n\t\tdev_err(dev, \"could not register PHY provider\\n\");\n\t\treturn PTR_ERR(provider);\n\t}\n\n\tdev_info(dev, \"registered %d port(s)\\n\", count);\n\n\treturn 0;\nput_child:\n\tof_node_put(child);\n\treturn ret;\n}\n\nstatic struct platform_driver brcm_sata_phy_driver = {\n\t.probe\t= brcm_sata_phy_probe,\n\t.driver\t= {\n\t\t.of_match_table\t= brcm_sata_phy_of_match,\n\t\t.name\t\t= \"brcm-sata-phy\",\n\t}\n};\nmodule_platform_driver(brcm_sata_phy_driver);\n\nMODULE_DESCRIPTION(\"Broadcom SATA PHY driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Marc Carino\");\nMODULE_AUTHOR(\"Brian Norris\");\nMODULE_ALIAS(\"platform:phy-brcm-sata\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}