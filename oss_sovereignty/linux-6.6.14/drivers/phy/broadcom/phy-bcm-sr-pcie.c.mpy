{
  "module_name": "phy-bcm-sr-pcie.c",
  "hash_id": "bd4cfa7797de56576766c9773660ae912f3af0e7602250c711c34be5dca09043",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/broadcom/phy-bcm-sr-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define SR_NR_PCIE_PHYS               9\n#define SR_PAXC_PHY_IDX               (SR_NR_PCIE_PHYS - 1)\n\n#define PCIE_PIPEMUX_CFG_OFFSET       0x10c\n#define PCIE_PIPEMUX_SELECT_STRAP     0xf\n\n#define CDRU_STRAP_DATA_LSW_OFFSET    0x5c\n#define PCIE_PIPEMUX_SHIFT            19\n#define PCIE_PIPEMUX_MASK             0xf\n\n#define MHB_MEM_PW_PAXC_OFFSET        0x1c0\n#define MHB_PWR_ARR_POWERON           0x8\n#define MHB_PWR_ARR_POWEROK           0x4\n#define MHB_PWR_POWERON               0x2\n#define MHB_PWR_POWEROK               0x1\n#define MHB_PWR_STATUS_MASK           (MHB_PWR_ARR_POWERON | \\\n\t\t\t\t       MHB_PWR_ARR_POWEROK | \\\n\t\t\t\t       MHB_PWR_POWERON | \\\n\t\t\t\t       MHB_PWR_POWEROK)\n\nstruct sr_pcie_phy_core;\n\n \nstruct sr_pcie_phy {\n\tstruct sr_pcie_phy_core *core;\n\tunsigned int index;\n\tstruct phy *phy;\n};\n\n \nstruct sr_pcie_phy_core {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct regmap *cdru;\n\tstruct regmap *mhb;\n\tu32 pipemux;\n\tstruct sr_pcie_phy phys[SR_NR_PCIE_PHYS];\n};\n\n \nstatic const u8 pipemux_table[] = {\n\t \n\t0x00,\n\t \n\t0x80,\n\t \n\t0x00,\n\t \n\t0x81,\n\t \n\t0xc3,\n\t \n\t0xff,\n\t \n\t0xcd,\n\t \n\t0xfd,\n\t \n\t0xf0,\n\t \n\t0xc0,\n\t \n\t0x42,\n\t \n\t0x3c,\n\t \n\t0xfc,\n\t \n\t0x4c,\n};\n\n \nstatic bool pipemux_strap_is_valid(u32 pipemux)\n{\n\treturn !!(pipemux < ARRAY_SIZE(pipemux_table));\n}\n\n \nstatic u32 pipemux_strap_read(struct sr_pcie_phy_core *core)\n{\n\tu32 pipemux;\n\n\t \n\tpipemux = readl(core->base + PCIE_PIPEMUX_CFG_OFFSET);\n\tpipemux &= PCIE_PIPEMUX_MASK;\n\tif (pipemux == PCIE_PIPEMUX_SELECT_STRAP) {\n\t\tregmap_read(core->cdru, CDRU_STRAP_DATA_LSW_OFFSET, &pipemux);\n\t\tpipemux >>= PCIE_PIPEMUX_SHIFT;\n\t\tpipemux &= PCIE_PIPEMUX_MASK;\n\t}\n\n\treturn pipemux;\n}\n\n \nstatic bool pcie_core_is_for_rc(struct sr_pcie_phy *phy)\n{\n\tstruct sr_pcie_phy_core *core = phy->core;\n\tunsigned int core_idx = phy->index;\n\n\treturn !!((pipemux_table[core->pipemux] >> core_idx) & 0x1);\n}\n\nstatic int sr_pcie_phy_init(struct phy *p)\n{\n\tstruct sr_pcie_phy *phy = phy_get_drvdata(p);\n\n\t \n\tif (pcie_core_is_for_rc(phy))\n\t\treturn 0;\n\n\treturn -ENODEV;\n}\n\nstatic int sr_paxc_phy_init(struct phy *p)\n{\n\tstruct sr_pcie_phy *phy = phy_get_drvdata(p);\n\tstruct sr_pcie_phy_core *core = phy->core;\n\tunsigned int core_idx = phy->index;\n\tu32 val;\n\n\tif (core_idx != SR_PAXC_PHY_IDX)\n\t\treturn -EINVAL;\n\n\tregmap_read(core->mhb, MHB_MEM_PW_PAXC_OFFSET, &val);\n\tif ((val & MHB_PWR_STATUS_MASK) != MHB_PWR_STATUS_MASK) {\n\t\tdev_err(core->dev, \"PAXC is not powered up\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct phy_ops sr_pcie_phy_ops = {\n\t.init = sr_pcie_phy_init,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct phy_ops sr_paxc_phy_ops = {\n\t.init = sr_paxc_phy_init,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct phy *sr_pcie_phy_xlate(struct device *dev,\n\t\t\t\t     struct of_phandle_args *args)\n{\n\tstruct sr_pcie_phy_core *core;\n\tint phy_idx;\n\n\tcore = dev_get_drvdata(dev);\n\tif (!core)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tphy_idx = args->args[0];\n\n\tif (WARN_ON(phy_idx >= SR_NR_PCIE_PHYS))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn core->phys[phy_idx].phy;\n}\n\nstatic int sr_pcie_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct sr_pcie_phy_core *core;\n\tstruct phy_provider *provider;\n\tunsigned int phy_idx = 0;\n\n\tcore = devm_kzalloc(dev, sizeof(*core), GFP_KERNEL);\n\tif (!core)\n\t\treturn -ENOMEM;\n\n\tcore->dev = dev;\n\tcore->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(core->base))\n\t\treturn PTR_ERR(core->base);\n\n\tcore->cdru = syscon_regmap_lookup_by_phandle(node, \"brcm,sr-cdru\");\n\tif (IS_ERR(core->cdru)) {\n\t\tdev_err(core->dev, \"unable to find CDRU device\\n\");\n\t\treturn PTR_ERR(core->cdru);\n\t}\n\n\tcore->mhb = syscon_regmap_lookup_by_phandle(node, \"brcm,sr-mhb\");\n\tif (IS_ERR(core->mhb)) {\n\t\tdev_err(core->dev, \"unable to find MHB device\\n\");\n\t\treturn PTR_ERR(core->mhb);\n\t}\n\n\t \n\tcore->pipemux = pipemux_strap_read(core);\n\tif (!pipemux_strap_is_valid(core->pipemux)) {\n\t\tdev_err(core->dev, \"invalid PCIe PIPEMUX strap %u\\n\",\n\t\t\tcore->pipemux);\n\t\treturn -EIO;\n\t}\n\n\tfor (phy_idx = 0; phy_idx < SR_NR_PCIE_PHYS; phy_idx++) {\n\t\tstruct sr_pcie_phy *p = &core->phys[phy_idx];\n\t\tconst struct phy_ops *ops;\n\n\t\tif (phy_idx == SR_PAXC_PHY_IDX)\n\t\t\tops = &sr_paxc_phy_ops;\n\t\telse\n\t\t\tops = &sr_pcie_phy_ops;\n\n\t\tp->phy = devm_phy_create(dev, NULL, ops);\n\t\tif (IS_ERR(p->phy)) {\n\t\t\tdev_err(dev, \"failed to create PCIe PHY\\n\");\n\t\t\treturn PTR_ERR(p->phy);\n\t\t}\n\n\t\tp->core = core;\n\t\tp->index = phy_idx;\n\t\tphy_set_drvdata(p->phy, p);\n\t}\n\n\tdev_set_drvdata(dev, core);\n\n\tprovider = devm_of_phy_provider_register(dev, sr_pcie_phy_xlate);\n\tif (IS_ERR(provider)) {\n\t\tdev_err(dev, \"failed to register PHY provider\\n\");\n\t\treturn PTR_ERR(provider);\n\t}\n\n\tdev_info(dev, \"Stingray PCIe PHY driver initialized\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sr_pcie_phy_match_table[] = {\n\t{ .compatible = \"brcm,sr-pcie-phy\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sr_pcie_phy_match_table);\n\nstatic struct platform_driver sr_pcie_phy_driver = {\n\t.driver = {\n\t\t.name\t\t= \"sr-pcie-phy\",\n\t\t.of_match_table\t= sr_pcie_phy_match_table,\n\t},\n\t.probe\t= sr_pcie_phy_probe,\n};\nmodule_platform_driver(sr_pcie_phy_driver);\n\nMODULE_AUTHOR(\"Ray Jui <ray.jui@broadcom.com>\");\nMODULE_DESCRIPTION(\"Broadcom Stingray PCIe PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}