{
  "module_name": "phy-bcm-ns-usb3.c",
  "hash_id": "6ad7d340fe22610cda760ba3197928afea00aeae3c63733ac558ceb3b05fbb84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/broadcom/phy-bcm-ns-usb3.c",
  "human_readable_source": "\n \n\n#include <linux/bcma/bcma.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/iopoll.h>\n#include <linux/mdio.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n#include <linux/slab.h>\n\n#define BCM_NS_USB3_PHY_BASE_ADDR_REG\t0x1f\n#define BCM_NS_USB3_PHY_PLL30_BLOCK\t0x8000\n#define BCM_NS_USB3_PHY_TX_PMD_BLOCK\t0x8040\n#define BCM_NS_USB3_PHY_PIPE_BLOCK\t0x8060\n\n \n#define BCM_NS_USB3_PLL_CONTROL\t\t0x01\n#define BCM_NS_USB3_PLLA_CONTROL0\t0x0a\n#define BCM_NS_USB3_PLLA_CONTROL1\t0x0b\n\n \n#define BCM_NS_USB3_TX_PMD_CONTROL1\t0x01\n\n \n#define BCM_NS_USB3_LFPS_CMP\t\t0x02\n#define BCM_NS_USB3_LFPS_DEGLITCH\t0x03\n\nenum bcm_ns_family {\n\tBCM_NS_UNKNOWN,\n\tBCM_NS_AX,\n\tBCM_NS_BX,\n};\n\nstruct bcm_ns_usb3 {\n\tstruct device *dev;\n\tenum bcm_ns_family family;\n\tvoid __iomem *dmp;\n\tstruct mdio_device *mdiodev;\n\tstruct phy *phy;\n};\n\nstatic const struct of_device_id bcm_ns_usb3_id_table[] = {\n\t{\n\t\t.compatible = \"brcm,ns-ax-usb3-phy\",\n\t\t.data = (int *)BCM_NS_AX,\n\t},\n\t{\n\t\t.compatible = \"brcm,ns-bx-usb3-phy\",\n\t\t.data = (int *)BCM_NS_BX,\n\t},\n\t{},\n};\n\nstatic int bcm_ns_usb3_mdio_phy_write(struct bcm_ns_usb3 *usb3, u16 reg,\n\t\t\t\t      u16 value);\n\nstatic int bcm_ns_usb3_phy_init_ns_bx(struct bcm_ns_usb3 *usb3)\n{\n\tint err;\n\n\t \n\terr = bcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PHY_BASE_ADDR_REG,\n\t\t\t\t\t BCM_NS_USB3_PHY_PLL30_BLOCK);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PLL_CONTROL, 0x1000);\n\n\t \n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PLLA_CONTROL0, 0x6400);\n\n\t \n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PLLA_CONTROL1, 0xc000);\n\n\t \n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PLLA_CONTROL1, 0x8000);\n\n\t \n\twritel(0, usb3->dmp + BCMA_RESET_CTL);\n\n\t \n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PLL_CONTROL, 0x9000);\n\n\t \n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PHY_BASE_ADDR_REG,\n\t\t\t\t   BCM_NS_USB3_PHY_PIPE_BLOCK);\n\n\t \n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_LFPS_CMP, 0xf30d);\n\n\t \n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_LFPS_DEGLITCH, 0x6302);\n\n\t \n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PHY_BASE_ADDR_REG,\n\t\t\t\t   BCM_NS_USB3_PHY_TX_PMD_BLOCK);\n\n\t \n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_TX_PMD_CONTROL1, 0x1003);\n\n\treturn 0;\n}\n\nstatic int bcm_ns_usb3_phy_init_ns_ax(struct bcm_ns_usb3 *usb3)\n{\n\tint err;\n\n\t \n\terr = bcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PHY_BASE_ADDR_REG,\n\t\t\t\t\t BCM_NS_USB3_PHY_PLL30_BLOCK);\n\tif (err < 0)\n\t\treturn err;\n\n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PLLA_CONTROL0, 0x6400);\n\n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PHY_BASE_ADDR_REG, 0x80e0);\n\n\tbcm_ns_usb3_mdio_phy_write(usb3, 0x02, 0x009c);\n\n\t \n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PHY_BASE_ADDR_REG,\n\t\t\t\t   BCM_NS_USB3_PHY_TX_PMD_BLOCK);\n\n\tbcm_ns_usb3_mdio_phy_write(usb3, 0x02, 0x21d3);\n\n\tbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_TX_PMD_CONTROL1, 0x1003);\n\n\t \n\twritel(0, usb3->dmp + BCMA_RESET_CTL);\n\n\treturn 0;\n}\n\nstatic int bcm_ns_usb3_phy_init(struct phy *phy)\n{\n\tstruct bcm_ns_usb3 *usb3 = phy_get_drvdata(phy);\n\tint err;\n\n\t \n\twritel(BCMA_RESET_CTL_RESET, usb3->dmp + BCMA_RESET_CTL);\n\n\tswitch (usb3->family) {\n\tcase BCM_NS_AX:\n\t\terr = bcm_ns_usb3_phy_init_ns_ax(usb3);\n\t\tbreak;\n\tcase BCM_NS_BX:\n\t\terr = bcm_ns_usb3_phy_init_ns_bx(usb3);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\terr = -ENOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic const struct phy_ops ops = {\n\t.init\t\t= bcm_ns_usb3_phy_init,\n\t.owner\t\t= THIS_MODULE,\n};\n\n \n\nstatic int bcm_ns_usb3_mdio_phy_write(struct bcm_ns_usb3 *usb3, u16 reg,\n\t\t\t\t      u16 value)\n{\n\tstruct mdio_device *mdiodev = usb3->mdiodev;\n\n\treturn mdiodev_write(mdiodev, reg, value);\n}\n\nstatic int bcm_ns_usb3_mdio_probe(struct mdio_device *mdiodev)\n{\n\tstruct device *dev = &mdiodev->dev;\n\tconst struct of_device_id *of_id;\n\tstruct phy_provider *phy_provider;\n\tstruct device_node *syscon_np;\n\tstruct bcm_ns_usb3 *usb3;\n\tstruct resource res;\n\tint err;\n\n\tusb3 = devm_kzalloc(dev, sizeof(*usb3), GFP_KERNEL);\n\tif (!usb3)\n\t\treturn -ENOMEM;\n\n\tusb3->dev = dev;\n\tusb3->mdiodev = mdiodev;\n\n\tof_id = of_match_device(bcm_ns_usb3_id_table, dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\tusb3->family = (uintptr_t)of_id->data;\n\n\tsyscon_np = of_parse_phandle(dev->of_node, \"usb3-dmp-syscon\", 0);\n\terr = of_address_to_resource(syscon_np, 0, &res);\n\tof_node_put(syscon_np);\n\tif (err)\n\t\treturn err;\n\n\tusb3->dmp = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(usb3->dmp))\n\t\treturn PTR_ERR(usb3->dmp);\n\n\tusb3->phy = devm_phy_create(dev, NULL, &ops);\n\tif (IS_ERR(usb3->phy)) {\n\t\tdev_err(dev, \"Failed to create PHY\\n\");\n\t\treturn PTR_ERR(usb3->phy);\n\t}\n\n\tphy_set_drvdata(usb3->phy, usb3);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct mdio_driver bcm_ns_usb3_mdio_driver = {\n\t.mdiodrv = {\n\t\t.driver = {\n\t\t\t.name = \"bcm_ns_mdio_usb3\",\n\t\t\t.of_match_table = bcm_ns_usb3_id_table,\n\t\t},\n\t},\n\t.probe = bcm_ns_usb3_mdio_probe,\n};\n\nmdio_module_driver(bcm_ns_usb3_mdio_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(of, bcm_ns_usb3_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}