{
  "module_name": "phy-brcm-usb.c",
  "hash_id": "251a9e491d0abc898a5da240858cc939890cbf4d2f343cbd4c2e95c2500c4019",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/broadcom/phy-brcm-usb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/soc/brcmstb/brcmstb.h>\n#include <dt-bindings/phy/phy.h>\n#include <linux/mfd/syscon.h>\n#include <linux/suspend.h>\n\n#include \"phy-brcm-usb-init.h\"\n\nstatic DEFINE_MUTEX(sysfs_lock);\n\nenum brcm_usb_phy_id {\n\tBRCM_USB_PHY_2_0 = 0,\n\tBRCM_USB_PHY_3_0,\n\tBRCM_USB_PHY_ID_MAX\n};\n\nstruct value_to_name_map {\n\tint value;\n\tconst char *name;\n};\n\nstruct match_chip_info {\n\tvoid (*init_func)(struct brcm_usb_init_params *params);\n\tu8 required_regs[BRCM_REGS_MAX + 1];\n\tu8 optional_reg;\n};\n\nstatic const struct value_to_name_map brcm_dr_mode_to_name[] = {\n\t{ USB_CTLR_MODE_HOST, \"host\" },\n\t{ USB_CTLR_MODE_DEVICE, \"peripheral\" },\n\t{ USB_CTLR_MODE_DRD, \"drd\" },\n\t{ USB_CTLR_MODE_TYPEC_PD, \"typec-pd\" }\n};\n\nstatic const struct value_to_name_map brcm_dual_mode_to_name[] = {\n\t{ 0, \"host\" },\n\t{ 1, \"device\" },\n\t{ 2, \"auto\" },\n};\n\nstruct brcm_usb_phy {\n\tstruct phy *phy;\n\tunsigned int id;\n\tbool inited;\n};\n\nstruct brcm_usb_phy_data {\n\tstruct  brcm_usb_init_params ini;\n\tbool\t\t\thas_eohci;\n\tbool\t\t\thas_xhci;\n\tstruct clk\t\t*usb_20_clk;\n\tstruct clk\t\t*usb_30_clk;\n\tstruct clk\t\t*suspend_clk;\n\tstruct mutex\t\tmutex;\t \n\tint\t\t\tinit_count;\n\tint\t\t\twake_irq;\n\tstruct brcm_usb_phy\tphys[BRCM_USB_PHY_ID_MAX];\n\tstruct notifier_block\tpm_notifier;\n\tbool\t\t\tpm_active;\n};\n\nstatic s8 *node_reg_names[BRCM_REGS_MAX] = {\n\t\"crtl\", \"xhci_ec\", \"xhci_gbl\", \"usb_phy\", \"usb_mdio\", \"bdc_ec\"\n};\n\nstatic int brcm_pm_notifier(struct notifier_block *notifier,\n\t\t\t    unsigned long pm_event,\n\t\t\t    void *unused)\n{\n\tstruct brcm_usb_phy_data *priv =\n\t\tcontainer_of(notifier, struct brcm_usb_phy_data, pm_notifier);\n\n\tswitch (pm_event) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\tpriv->pm_active = true;\n\t\tbreak;\n\tcase PM_POST_RESTORE:\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\t\tpriv->pm_active = false;\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic irqreturn_t brcm_usb_phy_wake_isr(int irq, void *dev_id)\n{\n\tstruct device *dev = dev_id;\n\n\tpm_wakeup_event(dev, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int brcm_usb_phy_init(struct phy *gphy)\n{\n\tstruct brcm_usb_phy *phy = phy_get_drvdata(gphy);\n\tstruct brcm_usb_phy_data *priv =\n\t\tcontainer_of(phy, struct brcm_usb_phy_data, phys[phy->id]);\n\n\tif (priv->pm_active)\n\t\treturn 0;\n\n\t \n\tmutex_lock(&priv->mutex);\n\tif (priv->init_count++ == 0) {\n\t\tclk_prepare_enable(priv->usb_20_clk);\n\t\tclk_prepare_enable(priv->usb_30_clk);\n\t\tclk_prepare_enable(priv->suspend_clk);\n\t\tbrcm_usb_init_common(&priv->ini);\n\t}\n\tmutex_unlock(&priv->mutex);\n\tif (phy->id == BRCM_USB_PHY_2_0)\n\t\tbrcm_usb_init_eohci(&priv->ini);\n\telse if (phy->id == BRCM_USB_PHY_3_0)\n\t\tbrcm_usb_init_xhci(&priv->ini);\n\tphy->inited = true;\n\tdev_dbg(&gphy->dev, \"INIT, id: %d, total: %d\\n\", phy->id,\n\t\tpriv->init_count);\n\n\treturn 0;\n}\n\nstatic int brcm_usb_phy_exit(struct phy *gphy)\n{\n\tstruct brcm_usb_phy *phy = phy_get_drvdata(gphy);\n\tstruct brcm_usb_phy_data *priv =\n\t\tcontainer_of(phy, struct brcm_usb_phy_data, phys[phy->id]);\n\n\tif (priv->pm_active)\n\t\treturn 0;\n\n\tdev_dbg(&gphy->dev, \"EXIT\\n\");\n\tif (phy->id == BRCM_USB_PHY_2_0)\n\t\tbrcm_usb_uninit_eohci(&priv->ini);\n\tif (phy->id == BRCM_USB_PHY_3_0)\n\t\tbrcm_usb_uninit_xhci(&priv->ini);\n\n\t \n\tmutex_lock(&priv->mutex);\n\tif (--priv->init_count == 0) {\n\t\tbrcm_usb_uninit_common(&priv->ini);\n\t\tclk_disable_unprepare(priv->usb_20_clk);\n\t\tclk_disable_unprepare(priv->usb_30_clk);\n\t\tclk_disable_unprepare(priv->suspend_clk);\n\t}\n\tmutex_unlock(&priv->mutex);\n\tphy->inited = false;\n\treturn 0;\n}\n\nstatic const struct phy_ops brcm_usb_phy_ops = {\n\t.init\t\t= brcm_usb_phy_init,\n\t.exit\t\t= brcm_usb_phy_exit,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *brcm_usb_phy_xlate(struct device *dev,\n\t\t\t\t      struct of_phandle_args *args)\n{\n\tstruct brcm_usb_phy_data *data = dev_get_drvdata(dev);\n\n\t \n\tswitch (args->args[0]) {\n\tcase 0:\n\tcase PHY_TYPE_USB2:\n\t\tif (data->phys[BRCM_USB_PHY_2_0].phy)\n\t\t\treturn data->phys[BRCM_USB_PHY_2_0].phy;\n\t\tdev_warn(dev, \"Error, 2.0 Phy not found\\n\");\n\t\tbreak;\n\tcase 1:\n\tcase PHY_TYPE_USB3:\n\t\tif (data->phys[BRCM_USB_PHY_3_0].phy)\n\t\t\treturn data->phys[BRCM_USB_PHY_3_0].phy;\n\t\tdev_warn(dev, \"Error, 3.0 Phy not found\\n\");\n\t\tbreak;\n\t}\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic int name_to_value(const struct value_to_name_map *table, int count,\n\t\t\t const char *name, int *value)\n{\n\tint x;\n\n\t*value = 0;\n\tfor (x = 0; x < count; x++) {\n\t\tif (sysfs_streq(name, table[x].name)) {\n\t\t\t*value = x;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic const char *value_to_name(const struct value_to_name_map *table, int count,\n\t\t\t\t int value)\n{\n\tif (value >= count)\n\t\treturn \"unknown\";\n\treturn table[value].name;\n}\n\nstatic ssize_t dr_mode_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct brcm_usb_phy_data *priv = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\",\n\t\tvalue_to_name(&brcm_dr_mode_to_name[0],\n\t\t\t      ARRAY_SIZE(brcm_dr_mode_to_name),\n\t\t\t      priv->ini.supported_port_modes));\n}\nstatic DEVICE_ATTR_RO(dr_mode);\n\nstatic ssize_t dual_select_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t len)\n{\n\tstruct brcm_usb_phy_data *priv = dev_get_drvdata(dev);\n\tint value;\n\tint res;\n\n\tmutex_lock(&sysfs_lock);\n\tres = name_to_value(&brcm_dual_mode_to_name[0],\n\t\t\t    ARRAY_SIZE(brcm_dual_mode_to_name), buf, &value);\n\tif (!res) {\n\t\tpriv->ini.port_mode = value;\n\t\tbrcm_usb_set_dual_select(&priv->ini);\n\t\tres = len;\n\t}\n\tmutex_unlock(&sysfs_lock);\n\treturn res;\n}\n\nstatic ssize_t dual_select_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct brcm_usb_phy_data *priv = dev_get_drvdata(dev);\n\tint value;\n\n\tmutex_lock(&sysfs_lock);\n\tvalue = brcm_usb_get_dual_select(&priv->ini);\n\tmutex_unlock(&sysfs_lock);\n\treturn sprintf(buf, \"%s\\n\",\n\t\tvalue_to_name(&brcm_dual_mode_to_name[0],\n\t\t\t      ARRAY_SIZE(brcm_dual_mode_to_name),\n\t\t\t      value));\n}\nstatic DEVICE_ATTR_RW(dual_select);\n\nstatic struct attribute *brcm_usb_phy_attrs[] = {\n\t&dev_attr_dr_mode.attr,\n\t&dev_attr_dual_select.attr,\n\tNULL\n};\n\nstatic const struct attribute_group brcm_usb_phy_group = {\n\t.attrs = brcm_usb_phy_attrs,\n};\n\nstatic const struct match_chip_info chip_info_4908 = {\n\t.init_func = &brcm_usb_dvr_init_4908,\n\t.required_regs = {\n\t\tBRCM_REGS_CTRL,\n\t\tBRCM_REGS_XHCI_EC,\n\t\t-1,\n\t},\n};\n\nstatic const struct match_chip_info chip_info_7216 = {\n\t.init_func = &brcm_usb_dvr_init_7216,\n\t.required_regs = {\n\t\tBRCM_REGS_CTRL,\n\t\tBRCM_REGS_XHCI_EC,\n\t\tBRCM_REGS_XHCI_GBL,\n\t\t-1,\n\t},\n};\n\nstatic const struct match_chip_info chip_info_7211b0 = {\n\t.init_func = &brcm_usb_dvr_init_7211b0,\n\t.required_regs = {\n\t\tBRCM_REGS_CTRL,\n\t\tBRCM_REGS_XHCI_EC,\n\t\tBRCM_REGS_XHCI_GBL,\n\t\tBRCM_REGS_USB_PHY,\n\t\tBRCM_REGS_USB_MDIO,\n\t\t-1,\n\t},\n\t.optional_reg = BRCM_REGS_BDC_EC,\n};\n\nstatic const struct match_chip_info chip_info_7445 = {\n\t.init_func = &brcm_usb_dvr_init_7445,\n\t.required_regs = {\n\t\tBRCM_REGS_CTRL,\n\t\tBRCM_REGS_XHCI_EC,\n\t\t-1,\n\t},\n};\n\nstatic const struct of_device_id brcm_usb_dt_ids[] = {\n\t{\n\t\t.compatible = \"brcm,bcm4908-usb-phy\",\n\t\t.data = &chip_info_4908,\n\t},\n\t{\n\t\t.compatible = \"brcm,bcm7216-usb-phy\",\n\t\t.data = &chip_info_7216,\n\t},\n\t{\n\t\t.compatible = \"brcm,bcm7211-usb-phy\",\n\t\t.data = &chip_info_7211b0,\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-usb-phy\",\n\t\t.data = &chip_info_7445,\n\t},\n\t{   }\n};\n\nstatic int brcm_usb_get_regs(struct platform_device *pdev,\n\t\t\t     enum brcmusb_reg_sel regs,\n\t\t\t     struct  brcm_usb_init_params *ini,\n\t\t\t     bool optional)\n{\n\tstruct resource *res;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\tnode_reg_names[regs]);\n\tif (res == NULL) {\n\t\tif (regs == BRCM_REGS_CTRL) {\n\t\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\t} else if (regs == BRCM_REGS_XHCI_EC) {\n\t\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\t\t\t \n\t\t\tif (res == NULL)\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (res == NULL) {\n\t\t\tif (optional) {\n\t\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\t\"Optional reg %s not found\\n\",\n\t\t\t\t\tnode_reg_names[regs]);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdev_err(&pdev->dev, \"can't get %s base addr\\n\",\n\t\t\t\tnode_reg_names[regs]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tini->regs[regs] = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(ini->regs[regs])) {\n\t\tdev_err(&pdev->dev, \"can't map %s register space\\n\",\n\t\t\tnode_reg_names[regs]);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int brcm_usb_phy_dvr_init(struct platform_device *pdev,\n\t\t\t\t struct brcm_usb_phy_data *priv,\n\t\t\t\t struct device_node *dn)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy *gphy = NULL;\n\tint err;\n\n\tpriv->usb_20_clk = of_clk_get_by_name(dn, \"sw_usb\");\n\tif (IS_ERR(priv->usb_20_clk)) {\n\t\tif (PTR_ERR(priv->usb_20_clk) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_info(dev, \"Clock not found in Device Tree\\n\");\n\t\tpriv->usb_20_clk = NULL;\n\t}\n\terr = clk_prepare_enable(priv->usb_20_clk);\n\tif (err)\n\t\treturn err;\n\n\tif (priv->has_eohci) {\n\t\tgphy = devm_phy_create(dev, NULL, &brcm_usb_phy_ops);\n\t\tif (IS_ERR(gphy)) {\n\t\t\tdev_err(dev, \"failed to create EHCI/OHCI PHY\\n\");\n\t\t\treturn PTR_ERR(gphy);\n\t\t}\n\t\tpriv->phys[BRCM_USB_PHY_2_0].phy = gphy;\n\t\tpriv->phys[BRCM_USB_PHY_2_0].id = BRCM_USB_PHY_2_0;\n\t\tphy_set_drvdata(gphy, &priv->phys[BRCM_USB_PHY_2_0]);\n\t}\n\n\tif (priv->has_xhci) {\n\t\tgphy = devm_phy_create(dev, NULL, &brcm_usb_phy_ops);\n\t\tif (IS_ERR(gphy)) {\n\t\t\tdev_err(dev, \"failed to create XHCI PHY\\n\");\n\t\t\treturn PTR_ERR(gphy);\n\t\t}\n\t\tpriv->phys[BRCM_USB_PHY_3_0].phy = gphy;\n\t\tpriv->phys[BRCM_USB_PHY_3_0].id = BRCM_USB_PHY_3_0;\n\t\tphy_set_drvdata(gphy, &priv->phys[BRCM_USB_PHY_3_0]);\n\n\t\tpriv->usb_30_clk = of_clk_get_by_name(dn, \"sw_usb3\");\n\t\tif (IS_ERR(priv->usb_30_clk)) {\n\t\t\tif (PTR_ERR(priv->usb_30_clk) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\tdev_info(dev,\n\t\t\t\t \"USB3.0 clock not found in Device Tree\\n\");\n\t\t\tpriv->usb_30_clk = NULL;\n\t\t}\n\t\terr = clk_prepare_enable(priv->usb_30_clk);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tpriv->suspend_clk = clk_get(dev, \"usb0_freerun\");\n\tif (IS_ERR(priv->suspend_clk)) {\n\t\tif (PTR_ERR(priv->suspend_clk) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_err(dev, \"Suspend Clock not found in Device Tree\\n\");\n\t\tpriv->suspend_clk = NULL;\n\t}\n\n\tpriv->wake_irq = platform_get_irq_byname_optional(pdev, \"wake\");\n\tif (priv->wake_irq < 0)\n\t\tpriv->wake_irq = platform_get_irq_byname_optional(pdev, \"wakeup\");\n\tif (priv->wake_irq >= 0) {\n\t\terr = devm_request_irq(dev, priv->wake_irq,\n\t\t\t\t       brcm_usb_phy_wake_isr, 0,\n\t\t\t\t       dev_name(dev), dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdevice_set_wakeup_capable(dev, 1);\n\t} else {\n\t\tdev_info(dev,\n\t\t\t \"Wake interrupt missing, system wake not supported\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int brcm_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct brcm_usb_phy_data *priv;\n\tstruct phy_provider *phy_provider;\n\tstruct device_node *dn = pdev->dev.of_node;\n\tint err;\n\tconst char *mode;\n\tconst struct match_chip_info *info;\n\tstruct regmap *rmap;\n\tint x;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->ini.family_id = brcmstb_get_family_id();\n\tpriv->ini.product_id = brcmstb_get_product_id();\n\n\tinfo = of_device_get_match_data(&pdev->dev);\n\tif (!info)\n\t\treturn -ENOENT;\n\n\tinfo->init_func(&priv->ini);\n\n\tdev_dbg(dev, \"Best mapping table is for %s\\n\",\n\t\tpriv->ini.family_name);\n\n\tof_property_read_u32(dn, \"brcm,ipp\", &priv->ini.ipp);\n\tof_property_read_u32(dn, \"brcm,ioc\", &priv->ini.ioc);\n\n\tpriv->ini.supported_port_modes = USB_CTLR_MODE_HOST;\n\terr = of_property_read_string(dn, \"dr_mode\", &mode);\n\tif (err == 0) {\n\t\tname_to_value(&brcm_dr_mode_to_name[0],\n\t\t\t      ARRAY_SIZE(brcm_dr_mode_to_name),\n\t\t\tmode, &priv->ini.supported_port_modes);\n\t}\n\t \n\tpriv->ini.port_mode = priv->ini.supported_port_modes;\n\n\tif (of_property_read_bool(dn, \"brcm,has-xhci\"))\n\t\tpriv->has_xhci = true;\n\tif (of_property_read_bool(dn, \"brcm,has-eohci\"))\n\t\tpriv->has_eohci = true;\n\n\tfor (x = 0; x < BRCM_REGS_MAX; x++) {\n\t\tif (info->required_regs[x] >= BRCM_REGS_MAX)\n\t\t\tbreak;\n\n\t\terr = brcm_usb_get_regs(pdev, info->required_regs[x],\n\t\t\t\t\t&priv->ini, false);\n\t\tif (err)\n\t\t\treturn -EINVAL;\n\t}\n\tif (info->optional_reg) {\n\t\terr = brcm_usb_get_regs(pdev, info->optional_reg,\n\t\t\t\t\t&priv->ini, true);\n\t\tif (err)\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = brcm_usb_phy_dvr_init(pdev, priv, dn);\n\tif (err)\n\t\treturn err;\n\n\tpriv->pm_notifier.notifier_call = brcm_pm_notifier;\n\tregister_pm_notifier(&priv->pm_notifier);\n\n\tmutex_init(&priv->mutex);\n\n\t \n\tbrcm_usb_init_ipp(&priv->ini);\n\n\t \n\tif (priv->ini.supported_port_modes != USB_CTLR_MODE_DRD)\n\t\tbrcm_usb_phy_attrs[1] = NULL;\n\terr = sysfs_create_group(&dev->kobj, &brcm_usb_phy_group);\n\tif (err)\n\t\tdev_warn(dev, \"Error creating sysfs attributes\\n\");\n\n\t \n\trmap = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t \"syscon-piarbctl\");\n\tif (IS_ERR(rmap))\n\t\trmap = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t       \"brcm,syscon-piarbctl\");\n\tif (!IS_ERR(rmap))\n\t\tpriv->ini.syscon_piarbctl = rmap;\n\n\t \n\tif (priv->has_xhci)\n\t\tbrcm_usb_uninit_xhci(&priv->ini);\n\tif (priv->has_eohci)\n\t\tbrcm_usb_uninit_eohci(&priv->ini);\n\tbrcm_usb_uninit_common(&priv->ini);\n\tclk_disable_unprepare(priv->usb_20_clk);\n\tclk_disable_unprepare(priv->usb_30_clk);\n\n\tphy_provider = devm_of_phy_provider_register(dev, brcm_usb_phy_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic void brcm_usb_phy_remove(struct platform_device *pdev)\n{\n\tstruct brcm_usb_phy_data *priv = dev_get_drvdata(&pdev->dev);\n\n\tsysfs_remove_group(&pdev->dev.kobj, &brcm_usb_phy_group);\n\tunregister_pm_notifier(&priv->pm_notifier);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int brcm_usb_phy_suspend(struct device *dev)\n{\n\tstruct brcm_usb_phy_data *priv = dev_get_drvdata(dev);\n\n\tif (priv->init_count) {\n\t\tdev_dbg(dev, \"SUSPEND\\n\");\n\t\tpriv->ini.wake_enabled = device_may_wakeup(dev);\n\t\tif (priv->phys[BRCM_USB_PHY_3_0].inited)\n\t\t\tbrcm_usb_uninit_xhci(&priv->ini);\n\t\tif (priv->phys[BRCM_USB_PHY_2_0].inited)\n\t\t\tbrcm_usb_uninit_eohci(&priv->ini);\n\t\tbrcm_usb_uninit_common(&priv->ini);\n\n\t\t \n\n\t\tif (!priv->ini.wake_enabled) {\n\t\t\tif (priv->phys[BRCM_USB_PHY_3_0].inited)\n\t\t\t\tclk_disable_unprepare(priv->usb_30_clk);\n\t\t\tif (priv->phys[BRCM_USB_PHY_2_0].inited ||\n\t\t\t    !priv->has_eohci)\n\t\t\t\tclk_disable_unprepare(priv->usb_20_clk);\n\t\t}\n\t\tif (priv->wake_irq >= 0)\n\t\t\tenable_irq_wake(priv->wake_irq);\n\t}\n\treturn 0;\n}\n\nstatic int brcm_usb_phy_resume(struct device *dev)\n{\n\tstruct brcm_usb_phy_data *priv = dev_get_drvdata(dev);\n\n\tif (!priv->ini.wake_enabled) {\n\t\tclk_prepare_enable(priv->usb_20_clk);\n\t\tclk_prepare_enable(priv->usb_30_clk);\n\t}\n\tbrcm_usb_init_ipp(&priv->ini);\n\n\t \n\tif (priv->init_count) {\n\t\tdev_dbg(dev, \"RESUME\\n\");\n\t\tif (priv->wake_irq >= 0)\n\t\t\tdisable_irq_wake(priv->wake_irq);\n\t\tbrcm_usb_init_common(&priv->ini);\n\t\tif (priv->phys[BRCM_USB_PHY_2_0].inited) {\n\t\t\tbrcm_usb_init_eohci(&priv->ini);\n\t\t} else if (priv->has_eohci) {\n\t\t\tbrcm_usb_uninit_eohci(&priv->ini);\n\t\t\tclk_disable_unprepare(priv->usb_20_clk);\n\t\t}\n\t\tif (priv->phys[BRCM_USB_PHY_3_0].inited) {\n\t\t\tbrcm_usb_init_xhci(&priv->ini);\n\t\t} else if (priv->has_xhci) {\n\t\t\tbrcm_usb_uninit_xhci(&priv->ini);\n\t\t\tclk_disable_unprepare(priv->usb_30_clk);\n\t\t\tif (!priv->has_eohci)\n\t\t\t\tclk_disable_unprepare(priv->usb_20_clk);\n\t\t}\n\t} else {\n\t\tif (priv->has_xhci)\n\t\t\tbrcm_usb_uninit_xhci(&priv->ini);\n\t\tif (priv->has_eohci)\n\t\t\tbrcm_usb_uninit_eohci(&priv->ini);\n\t\tbrcm_usb_uninit_common(&priv->ini);\n\t\tclk_disable_unprepare(priv->usb_20_clk);\n\t\tclk_disable_unprepare(priv->usb_30_clk);\n\t}\n\tpriv->ini.wake_enabled = false;\n\treturn 0;\n}\n#endif  \n\nstatic const struct dev_pm_ops brcm_usb_phy_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(brcm_usb_phy_suspend, brcm_usb_phy_resume)\n};\n\nMODULE_DEVICE_TABLE(of, brcm_usb_dt_ids);\n\nstatic struct platform_driver brcm_usb_driver = {\n\t.probe\t\t= brcm_usb_phy_probe,\n\t.remove_new\t= brcm_usb_phy_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"brcmstb-usb-phy\",\n\t\t.pm = &brcm_usb_phy_pm_ops,\n\t\t.of_match_table = brcm_usb_dt_ids,\n\t},\n};\n\nmodule_platform_driver(brcm_usb_driver);\n\nMODULE_ALIAS(\"platform:brcmstb-usb-phy\");\nMODULE_AUTHOR(\"Al Cooper <acooper@broadcom.com>\");\nMODULE_DESCRIPTION(\"BRCM USB PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}