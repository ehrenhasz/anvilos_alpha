{
  "module_name": "phy-brcm-usb-init-synopsys.c",
  "hash_id": "c9bf59c544c770465ba98e708436851da09074b32b2dcac8c24c9c7000ea9325",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/broadcom/phy-brcm-usb-init-synopsys.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n\n#include <linux/soc/brcmstb/brcmstb.h>\n#include \"phy-brcm-usb-init.h\"\n\n#define PHY_LOCK_TIMEOUT_MS 200\n\n \n#define PIARBCTL_CAM\t\t\t0x00\n#define PIARBCTL_SPLITTER\t\t0x04\n#define PIARBCTL_MISC\t\t\t0x08\n#define   PIARBCTL_MISC_SATA_PRIORITY_MASK\t\tGENMASK(3, 0)\n#define   PIARBCTL_MISC_CAM0_MEM_PAGE_MASK\t\tGENMASK(7, 4)\n#define   PIARBCTL_MISC_CAM1_MEM_PAGE_MASK\t\tGENMASK(11, 8)\n#define   PIARBCTL_MISC_USB_MEM_PAGE_MASK\t\tGENMASK(15, 12)\n#define   PIARBCTL_MISC_USB_PRIORITY_MASK\t\tGENMASK(19, 16)\n#define   PIARBCTL_MISC_USB_4G_SDRAM_MASK\t\tBIT(29)\n#define   PIARBCTL_MISC_USB_SELECT_MASK\t\t\tBIT(30)\n#define   PIARBCTL_MISC_SECURE_MASK\t\t\tBIT(31)\n\n#define PIARBCTL_MISC_USB_ONLY_MASK\t\t\\\n\t(PIARBCTL_MISC_USB_SELECT_MASK |\t\\\n\t PIARBCTL_MISC_USB_4G_SDRAM_MASK |\t\\\n\t PIARBCTL_MISC_USB_PRIORITY_MASK |\t\\\n\t PIARBCTL_MISC_USB_MEM_PAGE_MASK)\n\n \n#define USB_CTRL_SETUP\t\t\t0x00\n#define   USB_CTRL_SETUP_IOC_MASK\t\t\tBIT(4)\n#define   USB_CTRL_SETUP_IPP_MASK\t\t\tBIT(5)\n#define   USB_CTRL_SETUP_SOFT_SHUTDOWN_MASK\t\tBIT(9)\n#define   USB_CTRL_SETUP_SCB1_EN_MASK\t\t\tBIT(14)\n#define   USB_CTRL_SETUP_SCB2_EN_MASK\t\t\tBIT(15)\n#define   USB_CTRL_SETUP_tca_drv_sel_MASK\t\tBIT(24)\n#define   USB_CTRL_SETUP_STRAP_IPP_SEL_MASK\t\tBIT(25)\n#define USB_CTRL_USB_PM\t\t\t0x04\n#define   USB_CTRL_USB_PM_XHC_S2_CLK_SWITCH_EN_MASK\tBIT(3)\n#define   USB_CTRL_USB_PM_XHC_PME_EN_MASK\t\tBIT(4)\n#define   USB_CTRL_USB_PM_XHC_SOFT_RESETB_MASK\t\tBIT(22)\n#define   USB_CTRL_USB_PM_BDC_SOFT_RESETB_MASK\t\tBIT(23)\n#define   USB_CTRL_USB_PM_SOFT_RESET_MASK\t\tBIT(30)\n#define   USB_CTRL_USB_PM_USB_PWRDN_MASK\t\tBIT(31)\n#define USB_CTRL_USB_PM_STATUS\t\t0x08\n#define USB_CTRL_USB_DEVICE_CTL1\t0x10\n#define   USB_CTRL_USB_DEVICE_CTL1_PORT_MODE_MASK\tGENMASK(1, 0)\n#define USB_CTRL_TEST_PORT_CTL\t\t0x30\n#define   USB_CTRL_TEST_PORT_CTL_TPOUT_SEL_MASK\t\tGENMASK(7, 0)\n#define   USB_CTRL_TEST_PORT_CTL_TPOUT_SEL_PME_GEN_MASK\t0x0000002e\n#define USB_CTRL_TP_DIAG1\t\t0x34\n#define   USB_CTLR_TP_DIAG1_wake_MASK\t\t\tBIT(1)\n#define USB_CTRL_CTLR_CSHCR\t\t0x50\n#define   USB_CTRL_CTLR_CSHCR_ctl_pme_en_MASK\t\tBIT(18)\n#define USB_CTRL_P0_U2PHY_CFG1\t\t0x68\n#define   USB_CTRL_P0_U2PHY_CFG1_COMMONONN_MASK\t\tBIT(10)\n\n \n#define USB_PHY_PLL_CTL\t\t\t0x00\n#define   USB_PHY_PLL_CTL_PLL_SUSPEND_MASK\t\tBIT(27)\n#define   USB_PHY_PLL_CTL_PLL_RESETB_MASK\t\tBIT(30)\n#define USB_PHY_PLL_LDO_CTL\t\t0x08\n#define   USB_PHY_PLL_LDO_CTL_AFE_BG_PWRDWNB_MASK\tBIT(0)\n#define   USB_PHY_PLL_LDO_CTL_AFE_LDO_PWRDWNB_MASK\tBIT(1)\n#define   USB_PHY_PLL_LDO_CTL_AFE_CORERDY_MASK\t\tBIT(2)\n#define USB_PHY_UTMI_CTL_1\t\t0x04\n#define   USB_PHY_UTMI_CTL_1_PHY_MODE_MASK\t\tGENMASK(3, 2)\n#define   USB_PHY_UTMI_CTL_1_PHY_MODE_SHIFT\t\t2\n#define   USB_PHY_UTMI_CTL_1_POWER_UP_FSM_EN_MASK\tBIT(11)\n#define USB_PHY_IDDQ\t\t\t0x1c\n#define   USB_PHY_IDDQ_phy_iddq_MASK\t\t\tBIT(0)\n#define USB_PHY_STATUS\t\t\t0x20\n#define   USB_PHY_STATUS_pll_lock_MASK\t\t\tBIT(0)\n\n \n#define USB_GMDIOCSR\t0\n#define USB_GMDIOGEN\t4\n\n \n#define BDC_EC_AXIRDA\t\t\t0x0c\n#define   BDC_EC_AXIRDA_RTS_MASK\t\t\tGENMASK(31, 28)\n#define   BDC_EC_AXIRDA_RTS_SHIFT\t\t\t28\n\n#define USB_XHCI_GBL_GUSB2PHYCFG\t0x100\n#define   USB_XHCI_GBL_GUSB2PHYCFG_U2_FREECLK_EXISTS_MASK\tBIT(30)\n\nstatic void usb_mdio_write_7211b0(struct brcm_usb_init_params *params,\n\t\t\t\t  uint8_t addr, uint16_t data)\n{\n\tvoid __iomem *usb_mdio = params->regs[BRCM_REGS_USB_MDIO];\n\n\taddr &= 0x1f;  \n\tbrcm_usb_writel(0xffffffff, usb_mdio + USB_GMDIOGEN);\n\twhile (brcm_usb_readl(usb_mdio + USB_GMDIOCSR) & (1<<31))\n\t\t;\n\tbrcm_usb_writel(0x59020000 | (addr << 18) | data,\n\t\t\tusb_mdio + USB_GMDIOGEN);\n\twhile (brcm_usb_readl(usb_mdio + USB_GMDIOCSR) & (1<<31))\n\t\t;\n\tbrcm_usb_writel(0x00000000, usb_mdio + USB_GMDIOGEN);\n\twhile (brcm_usb_readl(usb_mdio + USB_GMDIOCSR) & (1<<31))\n\t\t;\n}\n\nstatic uint16_t __maybe_unused usb_mdio_read_7211b0(\n\tstruct brcm_usb_init_params *params, uint8_t addr)\n{\n\tvoid __iomem *usb_mdio = params->regs[BRCM_REGS_USB_MDIO];\n\n\taddr &= 0x1f;  \n\tbrcm_usb_writel(0xffffffff, usb_mdio + USB_GMDIOGEN);\n\twhile (brcm_usb_readl(usb_mdio + USB_GMDIOCSR) & (1<<31))\n\t\t;\n\tbrcm_usb_writel(0x69020000 | (addr << 18), usb_mdio + USB_GMDIOGEN);\n\twhile (brcm_usb_readl(usb_mdio + USB_GMDIOCSR) & (1<<31))\n\t\t;\n\tbrcm_usb_writel(0x00000000, usb_mdio + USB_GMDIOGEN);\n\twhile (brcm_usb_readl(usb_mdio + USB_GMDIOCSR) & (1<<31))\n\t\t;\n\treturn brcm_usb_readl(usb_mdio + USB_GMDIOCSR) & 0xffff;\n}\n\nstatic void usb2_eye_fix_7211b0(struct brcm_usb_init_params *params)\n{\n\t \n\tusb_mdio_write_7211b0(params, 0x1f, 0x80a0);\n\n\t \n\tusb_mdio_write_7211b0(params, 0x0a, 0xc6a0);\n}\n\nstatic void xhci_soft_reset(struct brcm_usb_init_params *params,\n\t\t\tint on_off)\n{\n\tvoid __iomem *ctrl = params->regs[BRCM_REGS_CTRL];\n\tvoid __iomem *xhci_gbl = params->regs[BRCM_REGS_XHCI_GBL];\n\n\t \n\tif (on_off) {\n\t\tUSB_CTRL_UNSET(ctrl, USB_PM, XHC_SOFT_RESETB);\n\t \n\t} else {\n\t\tUSB_CTRL_SET(ctrl, USB_PM, XHC_SOFT_RESETB);\n\t\t \n\t\tUSB_XHCI_GBL_UNSET(xhci_gbl, GUSB2PHYCFG, U2_FREECLK_EXISTS);\n\t}\n}\n\nstatic void usb_init_ipp(struct brcm_usb_init_params *params)\n{\n\tvoid __iomem *ctrl = params->regs[BRCM_REGS_CTRL];\n\tu32 reg;\n\tu32 orig_reg;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\torig_reg = reg = brcm_usb_readl(USB_CTRL_REG(ctrl, SETUP));\n\tif (params->ipp != 2)\n\t\t \n\t\treg &= ~(USB_CTRL_MASK(SETUP, STRAP_IPP_SEL));\n\n\t \n\treg &= ~(USB_CTRL_MASK(SETUP, IPP) | USB_CTRL_MASK(SETUP, IOC));\n\tif (params->ioc)\n\t\treg |= USB_CTRL_MASK(SETUP, IOC);\n\tif (params->ipp == 1)\n\t\treg |= USB_CTRL_MASK(SETUP, IPP);\n\tbrcm_usb_writel(reg, USB_CTRL_REG(ctrl, SETUP));\n\n\t \n\tif ((reg ^ orig_reg) & USB_CTRL_MASK(SETUP, IPP))\n\t\tmsleep(50);\n}\n\nstatic void syscon_piarbctl_init(struct regmap *rmap)\n{\n\t \n\tregmap_update_bits(rmap, PIARBCTL_MISC, PIARBCTL_MISC_USB_ONLY_MASK,\n\t\t\t   PIARBCTL_MISC_USB_SELECT_MASK |\n\t\t\t   PIARBCTL_MISC_USB_4G_SDRAM_MASK);\n}\n\nstatic void usb_init_common(struct brcm_usb_init_params *params)\n{\n\tu32 reg;\n\tvoid __iomem *ctrl = params->regs[BRCM_REGS_CTRL];\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\tif (USB_CTRL_MASK(USB_DEVICE_CTL1, PORT_MODE)) {\n\t\treg = brcm_usb_readl(USB_CTRL_REG(ctrl, USB_DEVICE_CTL1));\n\t\treg &= ~USB_CTRL_MASK(USB_DEVICE_CTL1, PORT_MODE);\n\t\treg |= params->port_mode;\n\t\tbrcm_usb_writel(reg, USB_CTRL_REG(ctrl, USB_DEVICE_CTL1));\n\t}\n\tswitch (params->supported_port_modes) {\n\tcase USB_CTLR_MODE_HOST:\n\t\tUSB_CTRL_UNSET(ctrl, USB_PM, BDC_SOFT_RESETB);\n\t\tbreak;\n\tdefault:\n\t\tUSB_CTRL_UNSET(ctrl, USB_PM, BDC_SOFT_RESETB);\n\t\tUSB_CTRL_SET(ctrl, USB_PM, BDC_SOFT_RESETB);\n\t\tbreak;\n\t}\n}\n\nstatic void usb_wake_enable_7211b0(struct brcm_usb_init_params *params,\n\t\t\t\t   bool enable)\n{\n\tvoid __iomem *ctrl = params->regs[BRCM_REGS_CTRL];\n\n\tif (enable)\n\t\tUSB_CTRL_SET(ctrl, CTLR_CSHCR, ctl_pme_en);\n\telse\n\t\tUSB_CTRL_UNSET(ctrl, CTLR_CSHCR, ctl_pme_en);\n}\n\nstatic void usb_wake_enable_7216(struct brcm_usb_init_params *params,\n\t\t\t\t bool enable)\n{\n\tvoid __iomem *ctrl = params->regs[BRCM_REGS_CTRL];\n\n\tif (enable)\n\t\tUSB_CTRL_SET(ctrl, USB_PM, XHC_PME_EN);\n\telse\n\t\tUSB_CTRL_UNSET(ctrl, USB_PM, XHC_PME_EN);\n}\n\nstatic void usb_init_common_7211b0(struct brcm_usb_init_params *params)\n{\n\tvoid __iomem *ctrl = params->regs[BRCM_REGS_CTRL];\n\tvoid __iomem *usb_phy = params->regs[BRCM_REGS_USB_PHY];\n\tvoid __iomem *bdc_ec = params->regs[BRCM_REGS_BDC_EC];\n\tint timeout_ms = PHY_LOCK_TIMEOUT_MS;\n\tu32 reg;\n\n\tif (params->syscon_piarbctl)\n\t\tsyscon_piarbctl_init(params->syscon_piarbctl);\n\n\tUSB_CTRL_UNSET(ctrl, USB_PM, USB_PWRDN);\n\n\tusb_wake_enable_7211b0(params, false);\n\tif (!params->wake_enabled) {\n\n\t\t \n\t\tbrcm_usb_writel(0, usb_phy + USB_PHY_IDDQ);\n\t\treg = brcm_usb_readl(usb_phy + USB_PHY_PLL_CTL);\n\t\treg |= USB_PHY_PLL_CTL_PLL_RESETB_MASK;\n\t\tbrcm_usb_writel(reg, usb_phy + USB_PHY_PLL_CTL);\n\n\t\t \n\t\treg = brcm_usb_readl(usb_phy + USB_PHY_UTMI_CTL_1);\n\t\treg |= USB_PHY_UTMI_CTL_1_POWER_UP_FSM_EN_MASK;\n\t\tbrcm_usb_writel(reg, usb_phy + USB_PHY_UTMI_CTL_1);\n\t}\n\n\t \n\treg = brcm_usb_readl(usb_phy + USB_PHY_PLL_CTL);\n\treg |= USB_PHY_PLL_CTL_PLL_SUSPEND_MASK;\n\tbrcm_usb_writel(reg, usb_phy + USB_PHY_PLL_CTL);\n\n\t \n\treg = USB_PHY_PLL_LDO_CTL_AFE_CORERDY_MASK |\n\t\tUSB_PHY_PLL_LDO_CTL_AFE_LDO_PWRDWNB_MASK |\n\t\tUSB_PHY_PLL_LDO_CTL_AFE_BG_PWRDWNB_MASK;\n\tbrcm_usb_writel(reg, usb_phy + USB_PHY_PLL_LDO_CTL);\n\n\t \n\twhile (timeout_ms-- > 0) {\n\t\treg = brcm_usb_readl(usb_phy + USB_PHY_STATUS);\n\t\tif (reg & USB_PHY_STATUS_pll_lock_MASK)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\t \n\treg = brcm_usb_readl(usb_phy + USB_PHY_UTMI_CTL_1);\n\treg &= ~USB_PHY_UTMI_CTL_1_PHY_MODE_MASK;\n\treg |= params->supported_port_modes << USB_PHY_UTMI_CTL_1_PHY_MODE_SHIFT;\n\tbrcm_usb_writel(reg, usb_phy + USB_PHY_UTMI_CTL_1);\n\n\tusb_init_common(params);\n\n\t \n\tif ((params->supported_port_modes != USB_CTLR_MODE_HOST) && bdc_ec) {\n\t\treg = brcm_usb_readl(bdc_ec + BDC_EC_AXIRDA);\n\t\treg &= ~BDC_EC_AXIRDA_RTS_MASK;\n\t\treg |= (0x4 << BDC_EC_AXIRDA_RTS_SHIFT);\n\t\tbrcm_usb_writel(reg, bdc_ec + BDC_EC_AXIRDA);\n\t}\n\n\t \n\treg = brcm_usb_readl(usb_phy + USB_PHY_UTMI_CTL_1);\n\treg &= ~USB_PHY_UTMI_CTL_1_POWER_UP_FSM_EN_MASK;\n\tbrcm_usb_writel(reg, usb_phy + USB_PHY_UTMI_CTL_1);\n\n\tusb2_eye_fix_7211b0(params);\n}\n\nstatic void usb_init_common_7216(struct brcm_usb_init_params *params)\n{\n\tvoid __iomem *ctrl = params->regs[BRCM_REGS_CTRL];\n\n\tUSB_CTRL_UNSET(ctrl, USB_PM, XHC_S2_CLK_SWITCH_EN);\n\tUSB_CTRL_UNSET(ctrl, USB_PM, USB_PWRDN);\n\n\t \n\tusleep_range(1000, 2000);\n\n\t \n\tUSB_CTRL_SET(ctrl, P0_U2PHY_CFG1, COMMONONN);\n\n\tusb_wake_enable_7216(params, false);\n\tusb_init_common(params);\n}\n\nstatic void usb_init_xhci(struct brcm_usb_init_params *params)\n{\n\tpr_debug(\"%s\\n\", __func__);\n\n\txhci_soft_reset(params, 0);\n}\n\nstatic void usb_uninit_common_7216(struct brcm_usb_init_params *params)\n{\n\tvoid __iomem *ctrl = params->regs[BRCM_REGS_CTRL];\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\tif (params->wake_enabled) {\n\t\t \n\t\tUSB_CTRL_SET(ctrl, USB_PM, XHC_S2_CLK_SWITCH_EN);\n\t\tusb_wake_enable_7216(params, true);\n\t} else {\n\t\tUSB_CTRL_SET(ctrl, USB_PM, USB_PWRDN);\n\t}\n}\n\nstatic void usb_uninit_common_7211b0(struct brcm_usb_init_params *params)\n{\n\tvoid __iomem *ctrl = params->regs[BRCM_REGS_CTRL];\n\tvoid __iomem *usb_phy = params->regs[BRCM_REGS_USB_PHY];\n\tu32 reg;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\tif (params->wake_enabled) {\n\t\tUSB_CTRL_SET(ctrl, TEST_PORT_CTL, TPOUT_SEL_PME_GEN);\n\t\tusb_wake_enable_7211b0(params, true);\n\t} else {\n\t\tUSB_CTRL_SET(ctrl, USB_PM, USB_PWRDN);\n\t\tbrcm_usb_writel(0, usb_phy + USB_PHY_PLL_LDO_CTL);\n\t\treg = brcm_usb_readl(usb_phy + USB_PHY_PLL_CTL);\n\t\treg &= ~USB_PHY_PLL_CTL_PLL_RESETB_MASK;\n\t\tbrcm_usb_writel(reg, usb_phy + USB_PHY_PLL_CTL);\n\t\tbrcm_usb_writel(USB_PHY_IDDQ_phy_iddq_MASK,\n\t\t\t\tusb_phy + USB_PHY_IDDQ);\n\t}\n\n}\n\nstatic void usb_uninit_xhci(struct brcm_usb_init_params *params)\n{\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\tif (!params->wake_enabled)\n\t\txhci_soft_reset(params, 1);\n}\n\nstatic int usb_get_dual_select(struct brcm_usb_init_params *params)\n{\n\tvoid __iomem *ctrl = params->regs[BRCM_REGS_CTRL];\n\tu32 reg = 0;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\treg = brcm_usb_readl(USB_CTRL_REG(ctrl, USB_DEVICE_CTL1));\n\treg &= USB_CTRL_MASK(USB_DEVICE_CTL1, PORT_MODE);\n\treturn reg;\n}\n\nstatic void usb_set_dual_select(struct brcm_usb_init_params *params)\n{\n\tvoid __iomem *ctrl = params->regs[BRCM_REGS_CTRL];\n\tu32 reg;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\treg = brcm_usb_readl(USB_CTRL_REG(ctrl, USB_DEVICE_CTL1));\n\treg &= ~USB_CTRL_MASK(USB_DEVICE_CTL1, PORT_MODE);\n\treg |= params->port_mode;\n\tbrcm_usb_writel(reg, USB_CTRL_REG(ctrl, USB_DEVICE_CTL1));\n}\n\nstatic const struct brcm_usb_init_ops bcm7216_ops = {\n\t.init_ipp = usb_init_ipp,\n\t.init_common = usb_init_common_7216,\n\t.init_xhci = usb_init_xhci,\n\t.uninit_common = usb_uninit_common_7216,\n\t.uninit_xhci = usb_uninit_xhci,\n\t.get_dual_select = usb_get_dual_select,\n\t.set_dual_select = usb_set_dual_select,\n};\n\nstatic const struct brcm_usb_init_ops bcm7211b0_ops = {\n\t.init_ipp = usb_init_ipp,\n\t.init_common = usb_init_common_7211b0,\n\t.init_xhci = usb_init_xhci,\n\t.uninit_common = usb_uninit_common_7211b0,\n\t.uninit_xhci = usb_uninit_xhci,\n\t.get_dual_select = usb_get_dual_select,\n\t.set_dual_select = usb_set_dual_select,\n};\n\nvoid brcm_usb_dvr_init_7216(struct brcm_usb_init_params *params)\n{\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\tparams->family_name = \"7216\";\n\tparams->ops = &bcm7216_ops;\n}\n\nvoid brcm_usb_dvr_init_7211b0(struct brcm_usb_init_params *params)\n{\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\tparams->family_name = \"7211\";\n\tparams->ops = &bcm7211b0_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}