{
  "module_name": "phy-bcm-sr-usb.c",
  "hash_id": "76dd599ebb1df655eb597616eb347881f268e610eecdd02ef56c5cc54c42cc1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/broadcom/phy-bcm-sr-usb.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\nenum bcm_usb_phy_version {\n\tBCM_SR_USB_COMBO_PHY,\n\tBCM_SR_USB_HS_PHY,\n};\n\nenum bcm_usb_phy_reg {\n\tPLL_CTRL,\n\tPHY_CTRL,\n\tPHY_PLL_CTRL,\n};\n\n \n\nstatic const u8 bcm_usb_combo_phy_ss[] = {\n\t[PLL_CTRL]\t\t= 0x18,\n\t[PHY_CTRL]\t\t= 0x14,\n};\n\nstatic const u8 bcm_usb_combo_phy_hs[] = {\n\t[PLL_CTRL]\t= 0x0c,\n\t[PHY_CTRL]\t= 0x10,\n};\n\nstatic const u8 bcm_usb_hs_phy[] = {\n\t[PLL_CTRL]\t= 0x8,\n\t[PHY_CTRL]\t= 0xc,\n};\n\nenum pll_ctrl_bits {\n\tPLL_RESETB,\n\tSSPLL_SUSPEND_EN,\n\tPLL_SEQ_START,\n\tPLL_LOCK,\n};\n\nstatic const u8 u3pll_ctrl[] = {\n\t[PLL_RESETB]\t\t= 0,\n\t[SSPLL_SUSPEND_EN]\t= 1,\n\t[PLL_SEQ_START]\t\t= 2,\n\t[PLL_LOCK]\t\t= 3,\n};\n\n#define HSPLL_PDIV_MASK\t\t0xF\n#define HSPLL_PDIV_VAL\t\t0x1\n\nstatic const u8 u2pll_ctrl[] = {\n\t[PLL_RESETB]\t= 5,\n\t[PLL_LOCK]\t= 6,\n};\n\nenum bcm_usb_phy_ctrl_bits {\n\tCORERDY,\n\tPHY_RESETB,\n\tPHY_PCTL,\n};\n\n#define PHY_PCTL_MASK\t0xffff\n#define SSPHY_PCTL_VAL\t0x0006\n\nstatic const u8 u3phy_ctrl[] = {\n\t[PHY_RESETB]\t= 1,\n\t[PHY_PCTL]\t= 2,\n};\n\nstatic const u8 u2phy_ctrl[] = {\n\t[CORERDY]\t\t= 0,\n\t[PHY_RESETB]\t\t= 5,\n\t[PHY_PCTL]\t\t= 6,\n};\n\nstruct bcm_usb_phy_cfg {\n\tuint32_t type;\n\tuint32_t version;\n\tvoid __iomem *regs;\n\tstruct phy *phy;\n\tconst u8 *offset;\n};\n\n#define PLL_LOCK_RETRY_COUNT\t1000\n\nenum bcm_usb_phy_type {\n\tUSB_HS_PHY,\n\tUSB_SS_PHY,\n};\n\n#define NUM_BCM_SR_USB_COMBO_PHYS\t2\n\nstatic inline void bcm_usb_reg32_clrbits(void __iomem *addr, uint32_t clear)\n{\n\twritel(readl(addr) & ~clear, addr);\n}\n\nstatic inline void bcm_usb_reg32_setbits(void __iomem *addr, uint32_t set)\n{\n\twritel(readl(addr) | set, addr);\n}\n\nstatic int bcm_usb_pll_lock_check(void __iomem *addr, u32 bit)\n{\n\tu32 data;\n\tint ret;\n\n\tret = readl_poll_timeout_atomic(addr, data, (data & bit), 1,\n\t\t\t\t\tPLL_LOCK_RETRY_COUNT);\n\tif (ret)\n\t\tpr_err(\"%s: FAIL\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic int bcm_usb_ss_phy_init(struct bcm_usb_phy_cfg *phy_cfg)\n{\n\tint ret = 0;\n\tvoid __iomem *regs = phy_cfg->regs;\n\tconst u8 *offset;\n\tu32 rd_data;\n\n\toffset = phy_cfg->offset;\n\n\t \n\trd_data = readl(regs + offset[PHY_CTRL]);\n\trd_data &= ~(PHY_PCTL_MASK << u3phy_ctrl[PHY_PCTL]);\n\trd_data |= (SSPHY_PCTL_VAL << u3phy_ctrl[PHY_PCTL]);\n\twritel(rd_data, regs + offset[PHY_CTRL]);\n\n\tbcm_usb_reg32_clrbits(regs + offset[PLL_CTRL],\n\t\t\t      BIT(u3pll_ctrl[SSPLL_SUSPEND_EN]));\n\tbcm_usb_reg32_setbits(regs + offset[PLL_CTRL],\n\t\t\t      BIT(u3pll_ctrl[PLL_SEQ_START]));\n\tbcm_usb_reg32_setbits(regs + offset[PLL_CTRL],\n\t\t\t      BIT(u3pll_ctrl[PLL_RESETB]));\n\n\t \n\tmsleep(30);\n\n\tret = bcm_usb_pll_lock_check(regs + offset[PLL_CTRL],\n\t\t\t\t     BIT(u3pll_ctrl[PLL_LOCK]));\n\n\treturn ret;\n}\n\nstatic int bcm_usb_hs_phy_init(struct bcm_usb_phy_cfg *phy_cfg)\n{\n\tint ret = 0;\n\tvoid __iomem *regs = phy_cfg->regs;\n\tconst u8 *offset;\n\n\toffset = phy_cfg->offset;\n\n\tbcm_usb_reg32_clrbits(regs + offset[PLL_CTRL],\n\t\t\t      BIT(u2pll_ctrl[PLL_RESETB]));\n\tbcm_usb_reg32_setbits(regs + offset[PLL_CTRL],\n\t\t\t      BIT(u2pll_ctrl[PLL_RESETB]));\n\n\tret = bcm_usb_pll_lock_check(regs + offset[PLL_CTRL],\n\t\t\t\t     BIT(u2pll_ctrl[PLL_LOCK]));\n\n\treturn ret;\n}\n\nstatic int bcm_usb_phy_reset(struct phy *phy)\n{\n\tstruct bcm_usb_phy_cfg *phy_cfg = phy_get_drvdata(phy);\n\tvoid __iomem *regs = phy_cfg->regs;\n\tconst u8 *offset;\n\n\toffset = phy_cfg->offset;\n\n\tif (phy_cfg->type == USB_HS_PHY) {\n\t\tbcm_usb_reg32_clrbits(regs + offset[PHY_CTRL],\n\t\t\t\t      BIT(u2phy_ctrl[CORERDY]));\n\t\tbcm_usb_reg32_setbits(regs + offset[PHY_CTRL],\n\t\t\t\t      BIT(u2phy_ctrl[CORERDY]));\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm_usb_phy_init(struct phy *phy)\n{\n\tstruct bcm_usb_phy_cfg *phy_cfg = phy_get_drvdata(phy);\n\tint ret = -EINVAL;\n\n\tif (phy_cfg->type == USB_SS_PHY)\n\t\tret = bcm_usb_ss_phy_init(phy_cfg);\n\telse if (phy_cfg->type == USB_HS_PHY)\n\t\tret = bcm_usb_hs_phy_init(phy_cfg);\n\n\treturn ret;\n}\n\nstatic const struct phy_ops sr_phy_ops = {\n\t.init\t\t= bcm_usb_phy_init,\n\t.reset\t\t= bcm_usb_phy_reset,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *bcm_usb_phy_xlate(struct device *dev,\n\t\t\t\t     struct of_phandle_args *args)\n{\n\tstruct bcm_usb_phy_cfg *phy_cfg;\n\tint phy_idx;\n\n\tphy_cfg = dev_get_drvdata(dev);\n\tif (!phy_cfg)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (phy_cfg->version == BCM_SR_USB_COMBO_PHY) {\n\t\tphy_idx = args->args[0];\n\n\t\tif (WARN_ON(phy_idx > 1))\n\t\t\treturn ERR_PTR(-ENODEV);\n\n\t\treturn phy_cfg[phy_idx].phy;\n\t} else\n\t\treturn phy_cfg->phy;\n}\n\nstatic int bcm_usb_phy_create(struct device *dev, struct device_node *node,\n\t\t\t      void __iomem *regs, uint32_t version)\n{\n\tstruct bcm_usb_phy_cfg *phy_cfg;\n\tint idx;\n\n\tif (version == BCM_SR_USB_COMBO_PHY) {\n\t\tphy_cfg = devm_kzalloc(dev, NUM_BCM_SR_USB_COMBO_PHYS *\n\t\t\t\t       sizeof(struct bcm_usb_phy_cfg),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!phy_cfg)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (idx = 0; idx < NUM_BCM_SR_USB_COMBO_PHYS; idx++) {\n\t\t\tphy_cfg[idx].regs = regs;\n\t\t\tphy_cfg[idx].version = version;\n\t\t\tif (idx == 0) {\n\t\t\t\tphy_cfg[idx].offset = bcm_usb_combo_phy_hs;\n\t\t\t\tphy_cfg[idx].type = USB_HS_PHY;\n\t\t\t} else {\n\t\t\t\tphy_cfg[idx].offset = bcm_usb_combo_phy_ss;\n\t\t\t\tphy_cfg[idx].type = USB_SS_PHY;\n\t\t\t}\n\t\t\tphy_cfg[idx].phy = devm_phy_create(dev, node,\n\t\t\t\t\t\t\t   &sr_phy_ops);\n\t\t\tif (IS_ERR(phy_cfg[idx].phy))\n\t\t\t\treturn PTR_ERR(phy_cfg[idx].phy);\n\n\t\t\tphy_set_drvdata(phy_cfg[idx].phy, &phy_cfg[idx]);\n\t\t}\n\t} else if (version == BCM_SR_USB_HS_PHY) {\n\t\tphy_cfg = devm_kzalloc(dev, sizeof(struct bcm_usb_phy_cfg),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!phy_cfg)\n\t\t\treturn -ENOMEM;\n\n\t\tphy_cfg->regs = regs;\n\t\tphy_cfg->version = version;\n\t\tphy_cfg->offset = bcm_usb_hs_phy;\n\t\tphy_cfg->type = USB_HS_PHY;\n\t\tphy_cfg->phy = devm_phy_create(dev, node, &sr_phy_ops);\n\t\tif (IS_ERR(phy_cfg->phy))\n\t\t\treturn PTR_ERR(phy_cfg->phy);\n\n\t\tphy_set_drvdata(phy_cfg->phy, phy_cfg);\n\t} else\n\t\treturn -ENODEV;\n\n\tdev_set_drvdata(dev, phy_cfg);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm_usb_phy_of_match[] = {\n\t{\n\t\t.compatible = \"brcm,sr-usb-combo-phy\",\n\t\t.data = (void *)BCM_SR_USB_COMBO_PHY,\n\t},\n\t{\n\t\t.compatible = \"brcm,sr-usb-hs-phy\",\n\t\t.data = (void *)BCM_SR_USB_HS_PHY,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, bcm_usb_phy_of_match);\n\nstatic int bcm_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *dn = dev->of_node;\n\tconst struct of_device_id *of_id;\n\tvoid __iomem *regs;\n\tint ret;\n\tenum bcm_usb_phy_version version;\n\tstruct phy_provider *phy_provider;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tof_id = of_match_node(bcm_usb_phy_of_match, dn);\n\tif (of_id)\n\t\tversion = (uintptr_t)of_id->data;\n\telse\n\t\treturn -ENODEV;\n\n\tret = bcm_usb_phy_create(dev, dn, regs, version);\n\tif (ret)\n\t\treturn ret;\n\n\tphy_provider = devm_of_phy_provider_register(dev, bcm_usb_phy_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver bcm_usb_phy_driver = {\n\t.driver = {\n\t\t.name = \"phy-bcm-sr-usb\",\n\t\t.of_match_table = bcm_usb_phy_of_match,\n\t},\n\t.probe = bcm_usb_phy_probe,\n};\nmodule_platform_driver(bcm_usb_phy_driver);\n\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_DESCRIPTION(\"Broadcom stingray USB Phy driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}