{
  "module_name": "phy-bcm-ns2-usbdrd.c",
  "hash_id": "2fedf7fe0cd97b61da5ac7628756cb0c810a7b32550b849a18eb58d465443e41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c",
  "human_readable_source": "\n\n\n#include <linux/delay.h>\n#include <linux/extcon-provider.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#define ICFG_DRD_AFE\t\t0x0\n#define ICFG_MISC_STAT\t\t0x18\n#define ICFG_DRD_P0CTL\t\t0x1C\n#define ICFG_STRAP_CTRL\t\t0x20\n#define ICFG_FSM_CTRL\t\t0x24\n\n#define ICFG_DEV_BIT\t\tBIT(2)\n#define IDM_RST_BIT\t\tBIT(0)\n#define AFE_CORERDY_VDDC\tBIT(18)\n#define PHY_PLL_RESETB\t\tBIT(15)\n#define PHY_RESETB\t\tBIT(14)\n#define PHY_PLL_LOCK\t\tBIT(0)\n\n#define DRD_DEV_MODE\t\tBIT(20)\n#define OHCI_OVRCUR_POL\t\tBIT(11)\n#define ICFG_OFF_MODE\t\tBIT(6)\n#define PLL_LOCK_RETRY\t\t1000\n\n#define EVT_DEVICE\t\t0\n#define EVT_HOST\t\t1\n\n#define DRD_HOST_MODE\t\t(BIT(2) | BIT(3))\n#define DRD_DEVICE_MODE\t\t(BIT(4) | BIT(5))\n#define DRD_HOST_VAL\t\t0x803\n#define DRD_DEV_VAL\t\t0x807\n#define GPIO_DELAY\t\t20\n\nstruct ns2_phy_data;\nstruct ns2_phy_driver {\n\tvoid __iomem *icfgdrd_regs;\n\tvoid __iomem *idmdrd_rst_ctrl;\n\tvoid __iomem *crmu_usb2_ctrl;\n\tvoid __iomem *usb2h_strap_reg;\n\tstruct ns2_phy_data *data;\n\tstruct extcon_dev *edev;\n\tstruct gpio_desc *vbus_gpiod;\n\tstruct gpio_desc *id_gpiod;\n\tint id_irq;\n\tint vbus_irq;\n\tunsigned long debounce_jiffies;\n\tstruct delayed_work wq_extcon;\n};\n\nstruct ns2_phy_data {\n\tstruct ns2_phy_driver *driver;\n\tstruct phy *phy;\n\tint new_state;\n};\n\nstatic const unsigned int usb_extcon_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_NONE,\n};\n\nstatic inline int pll_lock_stat(u32 usb_reg, int reg_mask,\n\t\t\t\tstruct ns2_phy_driver *driver)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout_atomic(driver->icfgdrd_regs + usb_reg,\n\t\t\t\t\t val, (val & reg_mask), 1,\n\t\t\t\t\t PLL_LOCK_RETRY);\n}\n\nstatic int ns2_drd_phy_init(struct phy *phy)\n{\n\tstruct ns2_phy_data *data = phy_get_drvdata(phy);\n\tstruct ns2_phy_driver *driver = data->driver;\n\tu32 val;\n\n\tval = readl(driver->icfgdrd_regs + ICFG_FSM_CTRL);\n\n\tif (data->new_state == EVT_HOST) {\n\t\tval &= ~DRD_DEVICE_MODE;\n\t\tval |= DRD_HOST_MODE;\n\t} else {\n\t\tval &= ~DRD_HOST_MODE;\n\t\tval |= DRD_DEVICE_MODE;\n\t}\n\twritel(val, driver->icfgdrd_regs + ICFG_FSM_CTRL);\n\n\treturn 0;\n}\n\nstatic int ns2_drd_phy_poweroff(struct phy *phy)\n{\n\tstruct ns2_phy_data *data = phy_get_drvdata(phy);\n\tstruct ns2_phy_driver *driver = data->driver;\n\tu32 val;\n\n\tval = readl(driver->crmu_usb2_ctrl);\n\tval &= ~AFE_CORERDY_VDDC;\n\twritel(val, driver->crmu_usb2_ctrl);\n\n\tval = readl(driver->crmu_usb2_ctrl);\n\tval &= ~DRD_DEV_MODE;\n\twritel(val, driver->crmu_usb2_ctrl);\n\n\t \n\tval = readl(driver->icfgdrd_regs + ICFG_FSM_CTRL);\n\tval &= ~(DRD_HOST_MODE | DRD_DEVICE_MODE | ICFG_OFF_MODE);\n\twritel(val, driver->icfgdrd_regs + ICFG_FSM_CTRL);\n\n\treturn 0;\n}\n\nstatic int ns2_drd_phy_poweron(struct phy *phy)\n{\n\tstruct ns2_phy_data *data = phy_get_drvdata(phy);\n\tstruct ns2_phy_driver *driver = data->driver;\n\tu32 extcon_event = data->new_state;\n\tint ret;\n\tu32 val;\n\n\tif (extcon_event == EVT_DEVICE) {\n\t\twritel(DRD_DEV_VAL, driver->icfgdrd_regs + ICFG_DRD_P0CTL);\n\n\t\tval = readl(driver->idmdrd_rst_ctrl);\n\t\tval &= ~IDM_RST_BIT;\n\t\twritel(val, driver->idmdrd_rst_ctrl);\n\n\t\tval = readl(driver->crmu_usb2_ctrl);\n\t\tval |= (AFE_CORERDY_VDDC | DRD_DEV_MODE);\n\t\twritel(val, driver->crmu_usb2_ctrl);\n\n\t\t \n\t\tval = readl(driver->crmu_usb2_ctrl);\n\t\tval |= (PHY_PLL_RESETB | PHY_RESETB);\n\t\twritel(val, driver->crmu_usb2_ctrl);\n\n\t\tret = pll_lock_stat(ICFG_MISC_STAT, PHY_PLL_LOCK, driver);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&phy->dev, \"Phy PLL lock failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\twritel(DRD_HOST_VAL, driver->icfgdrd_regs + ICFG_DRD_P0CTL);\n\n\t\tval = readl(driver->crmu_usb2_ctrl);\n\t\tval |= AFE_CORERDY_VDDC;\n\t\twritel(val, driver->crmu_usb2_ctrl);\n\n\t\tret = pll_lock_stat(ICFG_MISC_STAT, PHY_PLL_LOCK, driver);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&phy->dev, \"Phy PLL lock failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tval = readl(driver->idmdrd_rst_ctrl);\n\t\tval &= ~IDM_RST_BIT;\n\t\twritel(val, driver->idmdrd_rst_ctrl);\n\n\t\t \n\t\tval = readl(driver->usb2h_strap_reg);\n\t\tval |= OHCI_OVRCUR_POL;\n\t\twritel(val, driver->usb2h_strap_reg);\n\t}\n\n\treturn 0;\n}\n\nstatic void connect_change(struct ns2_phy_driver *driver)\n{\n\tu32 extcon_event;\n\tu32 val;\n\n\textcon_event = driver->data->new_state;\n\tval = readl(driver->icfgdrd_regs + ICFG_FSM_CTRL);\n\n\tswitch (extcon_event) {\n\tcase EVT_DEVICE:\n\t\tval &= ~(DRD_HOST_MODE | DRD_DEVICE_MODE);\n\t\twritel(val, driver->icfgdrd_regs + ICFG_FSM_CTRL);\n\n\t\tval = (val & ~DRD_HOST_MODE) | DRD_DEVICE_MODE;\n\t\twritel(val, driver->icfgdrd_regs + ICFG_FSM_CTRL);\n\n\t\tval = readl(driver->icfgdrd_regs + ICFG_DRD_P0CTL);\n\t\tval |= ICFG_DEV_BIT;\n\t\twritel(val, driver->icfgdrd_regs + ICFG_DRD_P0CTL);\n\t\tbreak;\n\n\tcase EVT_HOST:\n\t\tval &= ~(DRD_HOST_MODE | DRD_DEVICE_MODE);\n\t\twritel(val, driver->icfgdrd_regs + ICFG_FSM_CTRL);\n\n\t\tval = (val & ~DRD_DEVICE_MODE) | DRD_HOST_MODE;\n\t\twritel(val, driver->icfgdrd_regs + ICFG_FSM_CTRL);\n\n\t\tval = readl(driver->usb2h_strap_reg);\n\t\tval |= OHCI_OVRCUR_POL;\n\t\twritel(val, driver->usb2h_strap_reg);\n\n\t\tval = readl(driver->icfgdrd_regs + ICFG_DRD_P0CTL);\n\t\tval &= ~ICFG_DEV_BIT;\n\t\twritel(val, driver->icfgdrd_regs + ICFG_DRD_P0CTL);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"Invalid extcon event\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void extcon_work(struct work_struct *work)\n{\n\tstruct ns2_phy_driver *driver;\n\tint vbus;\n\tint id;\n\n\tdriver  = container_of(to_delayed_work(work),\n\t\t\t       struct ns2_phy_driver, wq_extcon);\n\n\tid = gpiod_get_value_cansleep(driver->id_gpiod);\n\tvbus = gpiod_get_value_cansleep(driver->vbus_gpiod);\n\n\tif (!id && vbus) {  \n\t\textcon_set_state_sync(driver->edev, EXTCON_USB_HOST, true);\n\t\tpr_debug(\"Host cable connected\\n\");\n\t\tdriver->data->new_state = EVT_HOST;\n\t\tconnect_change(driver);\n\t} else if (id && !vbus) {  \n\t\textcon_set_state_sync(driver->edev, EXTCON_USB_HOST, false);\n\t\textcon_set_state_sync(driver->edev, EXTCON_USB, false);\n\t\tpr_debug(\"Cable disconnected\\n\");\n\t} else if (id && vbus) {  \n\t\textcon_set_state_sync(driver->edev, EXTCON_USB, true);\n\t\tpr_debug(\"Device cable connected\\n\");\n\t\tdriver->data->new_state = EVT_DEVICE;\n\t\tconnect_change(driver);\n\t}\n}\n\nstatic irqreturn_t gpio_irq_handler(int irq, void *dev_id)\n{\n\tstruct ns2_phy_driver *driver = dev_id;\n\n\tqueue_delayed_work(system_power_efficient_wq, &driver->wq_extcon,\n\t\t\t   driver->debounce_jiffies);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct phy_ops ops = {\n\t.init\t\t= ns2_drd_phy_init,\n\t.power_on\t= ns2_drd_phy_poweron,\n\t.power_off\t= ns2_drd_phy_poweroff,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id ns2_drd_phy_dt_ids[] = {\n\t{ .compatible = \"brcm,ns2-drd-phy\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ns2_drd_phy_dt_ids);\n\nstatic int ns2_drd_phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct ns2_phy_driver *driver;\n\tstruct ns2_phy_data *data;\n\tint ret;\n\tu32 val;\n\n\tdriver = devm_kzalloc(dev, sizeof(struct ns2_phy_driver),\n\t\t\t      GFP_KERNEL);\n\tif (!driver)\n\t\treturn -ENOMEM;\n\n\tdriver->data = devm_kzalloc(dev, sizeof(struct ns2_phy_data),\n\t\t\t\t  GFP_KERNEL);\n\tif (!driver->data)\n\t\treturn -ENOMEM;\n\n\tdriver->icfgdrd_regs = devm_platform_ioremap_resource_byname(pdev, \"icfg\");\n\tif (IS_ERR(driver->icfgdrd_regs))\n\t\treturn PTR_ERR(driver->icfgdrd_regs);\n\n\tdriver->idmdrd_rst_ctrl = devm_platform_ioremap_resource_byname(pdev, \"rst-ctrl\");\n\tif (IS_ERR(driver->idmdrd_rst_ctrl))\n\t\treturn PTR_ERR(driver->idmdrd_rst_ctrl);\n\n\tdriver->crmu_usb2_ctrl = devm_platform_ioremap_resource_byname(pdev, \"crmu-ctrl\");\n\tif (IS_ERR(driver->crmu_usb2_ctrl))\n\t\treturn PTR_ERR(driver->crmu_usb2_ctrl);\n\n\tdriver->usb2h_strap_reg = devm_platform_ioremap_resource_byname(pdev, \"usb2-strap\");\n\tif (IS_ERR(driver->usb2h_strap_reg))\n\t\treturn PTR_ERR(driver->usb2h_strap_reg);\n\n\t  \n\tdriver->id_gpiod = devm_gpiod_get(&pdev->dev, \"id\", GPIOD_IN);\n\tif (IS_ERR(driver->id_gpiod)) {\n\t\tdev_err(dev, \"failed to get ID GPIO\\n\");\n\t\treturn PTR_ERR(driver->id_gpiod);\n\t}\n\tdriver->vbus_gpiod = devm_gpiod_get(&pdev->dev, \"vbus\", GPIOD_IN);\n\tif (IS_ERR(driver->vbus_gpiod)) {\n\t\tdev_err(dev, \"failed to get VBUS GPIO\\n\");\n\t\treturn PTR_ERR(driver->vbus_gpiod);\n\t}\n\n\tdriver->edev = devm_extcon_dev_allocate(dev, usb_extcon_cable);\n\tif (IS_ERR(driver->edev)) {\n\t\tdev_err(dev, \"failed to allocate extcon device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = devm_extcon_dev_register(dev, driver->edev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register extcon device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = gpiod_set_debounce(driver->id_gpiod, GPIO_DELAY * 1000);\n\tif (ret < 0)\n\t\tdriver->debounce_jiffies = msecs_to_jiffies(GPIO_DELAY);\n\n\tINIT_DELAYED_WORK(&driver->wq_extcon, extcon_work);\n\n\tdriver->id_irq = gpiod_to_irq(driver->id_gpiod);\n\tif (driver->id_irq < 0) {\n\t\tdev_err(dev, \"failed to get ID IRQ\\n\");\n\t\treturn driver->id_irq;\n\t}\n\n\tdriver->vbus_irq = gpiod_to_irq(driver->vbus_gpiod);\n\tif (driver->vbus_irq < 0) {\n\t\tdev_err(dev, \"failed to get ID IRQ\\n\");\n\t\treturn driver->vbus_irq;\n\t}\n\n\tret = devm_request_irq(dev, driver->id_irq, gpio_irq_handler,\n\t\t\t       IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\t\t\t       \"usb_id\", driver);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to request handler for ID IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_irq(dev, driver->vbus_irq, gpio_irq_handler,\n\t\t\t       IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\t\t\t       \"usb_vbus\", driver);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to request handler for VBUS IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(dev, driver);\n\n\t \n\tval = readl(driver->crmu_usb2_ctrl);\n\tval &= ~(AFE_CORERDY_VDDC | PHY_RESETB);\n\twritel(val, driver->crmu_usb2_ctrl);\n\n\tdata = driver->data;\n\tdata->phy = devm_phy_create(dev, dev->of_node, &ops);\n\tif (IS_ERR(data->phy)) {\n\t\tdev_err(dev, \"Failed to create usb drd phy\\n\");\n\t\treturn PTR_ERR(data->phy);\n\t}\n\n\tdata->driver = driver;\n\tphy_set_drvdata(data->phy, data);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tdev_err(dev, \"Failed to register as phy provider\\n\");\n\t\treturn PTR_ERR(phy_provider);\n\t}\n\n\tplatform_set_drvdata(pdev, driver);\n\n\tdev_info(dev, \"Registered NS2 DRD Phy device\\n\");\n\tqueue_delayed_work(system_power_efficient_wq, &driver->wq_extcon,\n\t\t\t   driver->debounce_jiffies);\n\n\treturn 0;\n}\n\nstatic struct platform_driver ns2_drd_phy_driver = {\n\t.probe = ns2_drd_phy_probe,\n\t.driver = {\n\t\t.name = \"bcm-ns2-usbphy\",\n\t\t.of_match_table = of_match_ptr(ns2_drd_phy_dt_ids),\n\t},\n};\nmodule_platform_driver(ns2_drd_phy_driver);\n\nMODULE_ALIAS(\"platform:bcm-ns2-drd-phy\");\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_DESCRIPTION(\"Broadcom NS2 USB2 PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}