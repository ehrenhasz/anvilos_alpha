{
  "module_name": "phy-bcm63xx-usbh.c",
  "hash_id": "3f2deff013a7cf80a5c24b301bab2ff03d44c883938a515d16ef567c0f3ae482",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/broadcom/phy-bcm63xx-usbh.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n \nenum usbh_regs {\n\tUSBH_BRT_CONTROL1 = 0,\n\tUSBH_BRT_CONTROL2,\n\tUSBH_BRT_STATUS1,\n\tUSBH_BRT_STATUS2,\n\tUSBH_UTMI_CONTROL1,\n#define   USBH_UC1_DEV_MODE_SEL\t\tBIT(0)\n\tUSBH_TEST_PORT_CONTROL,\n\tUSBH_PLL_CONTROL1,\n#define   USBH_PLLC_REFCLKSEL_SHIFT\t0\n#define   USBH_PLLC_REFCLKSEL_MASK\t(0x3 << USBH_PLLC_REFCLKSEL_SHIFT)\n#define   USBH_PLLC_CLKSEL_SHIFT\t2\n#define   USBH_PLLC_CLKSEL_MASK\t\t(0x3 << USBH_PLLC_CLKSEL_MASK)\n#define   USBH_PLLC_XTAL_PWRDWNB\tBIT(4)\n#define   USBH_PLLC_PLL_PWRDWNB\t\tBIT(5)\n#define   USBH_PLLC_PLL_CALEN\t\tBIT(6)\n#define   USBH_PLLC_PHYPLL_BYP\t\tBIT(7)\n#define   USBH_PLLC_PLL_RESET\t\tBIT(8)\n#define   USBH_PLLC_PLL_IDDQ_PWRDN\tBIT(9)\n#define   USBH_PLLC_PLL_PWRDN_DELAY\tBIT(10)\n#define   USBH_6318_PLLC_PLL_SUSPEND_EN\tBIT(27)\n#define   USBH_6318_PLLC_PHYPLL_BYP\tBIT(29)\n#define   USBH_6318_PLLC_PLL_RESET\tBIT(30)\n#define   USBH_6318_PLLC_PLL_IDDQ_PWRDN\tBIT(31)\n\tUSBH_SWAP_CONTROL,\n#define   USBH_SC_OHCI_DATA_SWAP\tBIT(0)\n#define   USBH_SC_OHCI_ENDIAN_SWAP\tBIT(1)\n#define   USBH_SC_OHCI_LOGICAL_ADDR_EN\tBIT(2)\n#define   USBH_SC_EHCI_DATA_SWAP\tBIT(3)\n#define   USBH_SC_EHCI_ENDIAN_SWAP\tBIT(4)\n#define   USBH_SC_EHCI_LOGICAL_ADDR_EN\tBIT(5)\n#define   USBH_SC_USB_DEVICE_SEL\tBIT(6)\n\tUSBH_GENERIC_CONTROL,\n#define   USBH_GC_PLL_SUSPEND_EN\tBIT(1)\n\tUSBH_FRAME_ADJUST_VALUE,\n\tUSBH_SETUP,\n#define   USBH_S_IOC\t\t\tBIT(4)\n#define   USBH_S_IPP\t\t\tBIT(5)\n\tUSBH_MDIO,\n\tUSBH_MDIO32,\n\tUSBH_USB_SIM_CONTROL,\n#define   USBH_USC_LADDR_SEL\t\tBIT(5)\n\n\t__USBH_ENUM_SIZE\n};\n\nstruct bcm63xx_usbh_phy_variant {\n\t \n\tlong regs[__USBH_ENUM_SIZE];\n\n\t \n\tu32 power_pllc_clr;\n\tu32 power_pllc_set;\n\n\t \n\tu32 setup_clr;\n\tu32 setup_set;\n\n\t \n\tu32 swapctl_dev_set;\n\n\t \n\tu32 tpc_val;\n\n\t \n\tu32 usc_set;\n\n\t \n\tu32 utmictl1_dev_set;\n};\n\nstruct bcm63xx_usbh_phy {\n\tvoid __iomem *base;\n\tstruct clk *usbh_clk;\n\tstruct clk *usb_ref_clk;\n\tstruct reset_control *reset;\n\tconst struct bcm63xx_usbh_phy_variant *variant;\n\tbool device_mode;\n};\n\nstatic const struct bcm63xx_usbh_phy_variant usbh_bcm6318 = {\n\t.regs = {\n\t\t[USBH_BRT_CONTROL1] = -1,\n\t\t[USBH_BRT_CONTROL2] = -1,\n\t\t[USBH_BRT_STATUS1] = -1,\n\t\t[USBH_BRT_STATUS2] = -1,\n\t\t[USBH_UTMI_CONTROL1] = 0x2c,\n\t\t[USBH_TEST_PORT_CONTROL] = 0x1c,\n\t\t[USBH_PLL_CONTROL1] = 0x04,\n\t\t[USBH_SWAP_CONTROL] = 0x0c,\n\t\t[USBH_GENERIC_CONTROL] = -1,\n\t\t[USBH_FRAME_ADJUST_VALUE] = 0x08,\n\t\t[USBH_SETUP] = 0x00,\n\t\t[USBH_MDIO] = 0x14,\n\t\t[USBH_MDIO32] = 0x18,\n\t\t[USBH_USB_SIM_CONTROL] = 0x20,\n\t},\n\t.power_pllc_clr = USBH_6318_PLLC_PLL_IDDQ_PWRDN,\n\t.power_pllc_set = USBH_6318_PLLC_PLL_SUSPEND_EN,\n\t.setup_set = USBH_S_IOC,\n\t.swapctl_dev_set = USBH_SC_USB_DEVICE_SEL,\n\t.usc_set = USBH_USC_LADDR_SEL,\n\t.utmictl1_dev_set = USBH_UC1_DEV_MODE_SEL,\n};\n\nstatic const struct bcm63xx_usbh_phy_variant usbh_bcm6328 = {\n\t.regs = {\n\t\t[USBH_BRT_CONTROL1] = 0x00,\n\t\t[USBH_BRT_CONTROL2] = 0x04,\n\t\t[USBH_BRT_STATUS1] = 0x08,\n\t\t[USBH_BRT_STATUS2] = 0x0c,\n\t\t[USBH_UTMI_CONTROL1] = 0x10,\n\t\t[USBH_TEST_PORT_CONTROL] = 0x14,\n\t\t[USBH_PLL_CONTROL1] = 0x18,\n\t\t[USBH_SWAP_CONTROL] = 0x1c,\n\t\t[USBH_GENERIC_CONTROL] = 0x20,\n\t\t[USBH_FRAME_ADJUST_VALUE] = 0x24,\n\t\t[USBH_SETUP] = 0x28,\n\t\t[USBH_MDIO] = 0x2c,\n\t\t[USBH_MDIO32] = 0x30,\n\t\t[USBH_USB_SIM_CONTROL] = 0x34,\n\t},\n\t.setup_set = USBH_S_IOC,\n\t.swapctl_dev_set = USBH_SC_USB_DEVICE_SEL,\n\t.utmictl1_dev_set = USBH_UC1_DEV_MODE_SEL,\n};\n\nstatic const struct bcm63xx_usbh_phy_variant usbh_bcm6358 = {\n\t.regs = {\n\t\t[USBH_BRT_CONTROL1] = -1,\n\t\t[USBH_BRT_CONTROL2] = -1,\n\t\t[USBH_BRT_STATUS1] = -1,\n\t\t[USBH_BRT_STATUS2] = -1,\n\t\t[USBH_UTMI_CONTROL1] = -1,\n\t\t[USBH_TEST_PORT_CONTROL] = 0x24,\n\t\t[USBH_PLL_CONTROL1] = -1,\n\t\t[USBH_SWAP_CONTROL] = 0x00,\n\t\t[USBH_GENERIC_CONTROL] = -1,\n\t\t[USBH_FRAME_ADJUST_VALUE] = -1,\n\t\t[USBH_SETUP] = -1,\n\t\t[USBH_MDIO] = -1,\n\t\t[USBH_MDIO32] = -1,\n\t\t[USBH_USB_SIM_CONTROL] = -1,\n\t},\n\t \n\t.tpc_val = 0x1c0020,\n};\n\nstatic const struct bcm63xx_usbh_phy_variant usbh_bcm6368 = {\n\t.regs = {\n\t\t[USBH_BRT_CONTROL1] = 0x00,\n\t\t[USBH_BRT_CONTROL2] = 0x04,\n\t\t[USBH_BRT_STATUS1] = 0x08,\n\t\t[USBH_BRT_STATUS2] = 0x0c,\n\t\t[USBH_UTMI_CONTROL1] = 0x10,\n\t\t[USBH_TEST_PORT_CONTROL] = 0x14,\n\t\t[USBH_PLL_CONTROL1] = 0x18,\n\t\t[USBH_SWAP_CONTROL] = 0x1c,\n\t\t[USBH_GENERIC_CONTROL] = -1,\n\t\t[USBH_FRAME_ADJUST_VALUE] = 0x24,\n\t\t[USBH_SETUP] = 0x28,\n\t\t[USBH_MDIO] = 0x2c,\n\t\t[USBH_MDIO32] = 0x30,\n\t\t[USBH_USB_SIM_CONTROL] = 0x34,\n\t},\n\t.power_pllc_clr = USBH_PLLC_PLL_IDDQ_PWRDN | USBH_PLLC_PLL_PWRDN_DELAY,\n\t.setup_set = USBH_S_IOC,\n\t.swapctl_dev_set = USBH_SC_USB_DEVICE_SEL,\n\t.utmictl1_dev_set = USBH_UC1_DEV_MODE_SEL,\n};\n\nstatic const struct bcm63xx_usbh_phy_variant usbh_bcm63268 = {\n\t.regs = {\n\t\t[USBH_BRT_CONTROL1] = 0x00,\n\t\t[USBH_BRT_CONTROL2] = 0x04,\n\t\t[USBH_BRT_STATUS1] = 0x08,\n\t\t[USBH_BRT_STATUS2] = 0x0c,\n\t\t[USBH_UTMI_CONTROL1] = 0x10,\n\t\t[USBH_TEST_PORT_CONTROL] = 0x14,\n\t\t[USBH_PLL_CONTROL1] = 0x18,\n\t\t[USBH_SWAP_CONTROL] = 0x1c,\n\t\t[USBH_GENERIC_CONTROL] = 0x20,\n\t\t[USBH_FRAME_ADJUST_VALUE] = 0x24,\n\t\t[USBH_SETUP] = 0x28,\n\t\t[USBH_MDIO] = 0x2c,\n\t\t[USBH_MDIO32] = 0x30,\n\t\t[USBH_USB_SIM_CONTROL] = 0x34,\n\t},\n\t.power_pllc_clr = USBH_PLLC_PLL_IDDQ_PWRDN | USBH_PLLC_PLL_PWRDN_DELAY,\n\t.setup_clr = USBH_S_IPP,\n\t.setup_set = USBH_S_IOC,\n\t.swapctl_dev_set = USBH_SC_USB_DEVICE_SEL,\n\t.utmictl1_dev_set = USBH_UC1_DEV_MODE_SEL,\n};\n\nstatic inline bool usbh_has_reg(struct bcm63xx_usbh_phy *usbh, int reg)\n{\n\treturn (usbh->variant->regs[reg] >= 0);\n}\n\nstatic inline u32 usbh_readl(struct bcm63xx_usbh_phy *usbh, int reg)\n{\n\treturn __raw_readl(usbh->base + usbh->variant->regs[reg]);\n}\n\nstatic inline void usbh_writel(struct bcm63xx_usbh_phy *usbh, int reg,\n\t\t\t       u32 value)\n{\n\t__raw_writel(value, usbh->base + usbh->variant->regs[reg]);\n}\n\nstatic int bcm63xx_usbh_phy_init(struct phy *phy)\n{\n\tstruct bcm63xx_usbh_phy *usbh = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = clk_prepare_enable(usbh->usbh_clk);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"unable to enable usbh clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(usbh->usb_ref_clk);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"unable to enable usb_ref clock: %d\\n\", ret);\n\t\tclk_disable_unprepare(usbh->usbh_clk);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_reset(usbh->reset);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"unable to reset device: %d\\n\", ret);\n\t\tclk_disable_unprepare(usbh->usb_ref_clk);\n\t\tclk_disable_unprepare(usbh->usbh_clk);\n\t\treturn ret;\n\t}\n\n\t \n\tif (usbh_has_reg(usbh, USBH_SWAP_CONTROL)) {\n\t\tu32 val = usbh_readl(usbh, USBH_SWAP_CONTROL);\n\n\t\tval |= USBH_SC_EHCI_DATA_SWAP;\n\t\tval &= ~USBH_SC_EHCI_ENDIAN_SWAP;\n\n\t\tval |= USBH_SC_OHCI_DATA_SWAP;\n\t\tval &= ~USBH_SC_OHCI_ENDIAN_SWAP;\n\n\t\tif (usbh->device_mode && usbh->variant->swapctl_dev_set)\n\t\t\tval |= usbh->variant->swapctl_dev_set;\n\n\t\tusbh_writel(usbh, USBH_SWAP_CONTROL, val);\n\t}\n\n\tif (usbh_has_reg(usbh, USBH_SETUP)) {\n\t\tu32 val = usbh_readl(usbh, USBH_SETUP);\n\n\t\tval |= usbh->variant->setup_set;\n\t\tval &= ~usbh->variant->setup_clr;\n\n\t\tusbh_writel(usbh, USBH_SETUP, val);\n\t}\n\n\tif (usbh_has_reg(usbh, USBH_USB_SIM_CONTROL)) {\n\t\tu32 val = usbh_readl(usbh, USBH_USB_SIM_CONTROL);\n\n\t\tval |= usbh->variant->usc_set;\n\n\t\tusbh_writel(usbh, USBH_USB_SIM_CONTROL, val);\n\t}\n\n\tif (usbh->variant->tpc_val &&\n\t    usbh_has_reg(usbh, USBH_TEST_PORT_CONTROL))\n\t\tusbh_writel(usbh, USBH_TEST_PORT_CONTROL,\n\t\t\t    usbh->variant->tpc_val);\n\n\tif (usbh->device_mode &&\n\t    usbh_has_reg(usbh, USBH_UTMI_CONTROL1) &&\n\t    usbh->variant->utmictl1_dev_set) {\n\t\tu32 val = usbh_readl(usbh, USBH_UTMI_CONTROL1);\n\n\t\tval |= usbh->variant->utmictl1_dev_set;\n\n\t\tusbh_writel(usbh, USBH_UTMI_CONTROL1, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm63xx_usbh_phy_power_on(struct phy *phy)\n{\n\tstruct bcm63xx_usbh_phy *usbh = phy_get_drvdata(phy);\n\n\tif (usbh_has_reg(usbh, USBH_PLL_CONTROL1)) {\n\t\tu32 val = usbh_readl(usbh, USBH_PLL_CONTROL1);\n\n\t\tval |= usbh->variant->power_pllc_set;\n\t\tval &= ~usbh->variant->power_pllc_clr;\n\n\t\tusbh_writel(usbh, USBH_PLL_CONTROL1, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm63xx_usbh_phy_power_off(struct phy *phy)\n{\n\tstruct bcm63xx_usbh_phy *usbh = phy_get_drvdata(phy);\n\n\tif (usbh_has_reg(usbh, USBH_PLL_CONTROL1)) {\n\t\tu32 val = usbh_readl(usbh, USBH_PLL_CONTROL1);\n\n\t\tval &= ~usbh->variant->power_pllc_set;\n\t\tval |= usbh->variant->power_pllc_clr;\n\n\t\tusbh_writel(usbh, USBH_PLL_CONTROL1, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm63xx_usbh_phy_exit(struct phy *phy)\n{\n\tstruct bcm63xx_usbh_phy *usbh = phy_get_drvdata(phy);\n\n\tclk_disable_unprepare(usbh->usbh_clk);\n\tclk_disable_unprepare(usbh->usb_ref_clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops bcm63xx_usbh_phy_ops = {\n\t.exit = bcm63xx_usbh_phy_exit,\n\t.init = bcm63xx_usbh_phy_init,\n\t.power_off = bcm63xx_usbh_phy_power_off,\n\t.power_on = bcm63xx_usbh_phy_power_on,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct phy *bcm63xx_usbh_phy_xlate(struct device *dev,\n\t\t\t\t\t  struct of_phandle_args *args)\n{\n\tstruct bcm63xx_usbh_phy *usbh = dev_get_drvdata(dev);\n\n\tusbh->device_mode = !!args->args[0];\n\n\treturn of_phy_simple_xlate(dev, args);\n}\n\nstatic int __init bcm63xx_usbh_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm63xx_usbh_phy\t*usbh;\n\tconst struct bcm63xx_usbh_phy_variant *variant;\n\tstruct phy *phy;\n\tstruct phy_provider *phy_provider;\n\n\tusbh = devm_kzalloc(dev, sizeof(*usbh), GFP_KERNEL);\n\tif (!usbh)\n\t\treturn -ENOMEM;\n\n\tvariant = device_get_match_data(dev);\n\tif (!variant)\n\t\treturn -EINVAL;\n\tusbh->variant = variant;\n\n\tusbh->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(usbh->base))\n\t\treturn PTR_ERR(usbh->base);\n\n\tusbh->reset = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(usbh->reset)) {\n\t\tif (PTR_ERR(usbh->reset) != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"failed to get reset\\n\");\n\t\treturn PTR_ERR(usbh->reset);\n\t}\n\n\tusbh->usbh_clk = devm_clk_get_optional(dev, \"usbh\");\n\tif (IS_ERR(usbh->usbh_clk))\n\t\treturn PTR_ERR(usbh->usbh_clk);\n\n\tusbh->usb_ref_clk = devm_clk_get_optional(dev, \"usb_ref\");\n\tif (IS_ERR(usbh->usb_ref_clk))\n\t\treturn PTR_ERR(usbh->usb_ref_clk);\n\n\tphy = devm_phy_create(dev, NULL, &bcm63xx_usbh_phy_ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(phy);\n\t}\n\n\tplatform_set_drvdata(pdev, usbh);\n\tphy_set_drvdata(phy, usbh);\n\n\tphy_provider = devm_of_phy_provider_register(dev,\n\t\t\t\t\t\t     bcm63xx_usbh_phy_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tdev_err(dev, \"failed to register PHY provider\\n\");\n\t\treturn PTR_ERR(phy_provider);\n\t}\n\n\tdev_dbg(dev, \"Registered BCM63xx USB PHY driver\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm63xx_usbh_phy_ids[] __initconst = {\n\t{ .compatible = \"brcm,bcm6318-usbh-phy\", .data = &usbh_bcm6318 },\n\t{ .compatible = \"brcm,bcm6328-usbh-phy\", .data = &usbh_bcm6328 },\n\t{ .compatible = \"brcm,bcm6358-usbh-phy\", .data = &usbh_bcm6358 },\n\t{ .compatible = \"brcm,bcm6362-usbh-phy\", .data = &usbh_bcm6368 },\n\t{ .compatible = \"brcm,bcm6368-usbh-phy\", .data = &usbh_bcm6368 },\n\t{ .compatible = \"brcm,bcm63268-usbh-phy\", .data = &usbh_bcm63268 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, bcm63xx_usbh_phy_ids);\n\nstatic struct platform_driver bcm63xx_usbh_phy_driver __refdata = {\n\t.driver\t= {\n\t\t.name = \"bcm63xx-usbh-phy\",\n\t\t.of_match_table = bcm63xx_usbh_phy_ids,\n\t},\n\t.probe\t= bcm63xx_usbh_phy_probe,\n};\nmodule_platform_driver(bcm63xx_usbh_phy_driver);\n\nMODULE_DESCRIPTION(\"BCM63xx USBH PHY driver\");\nMODULE_AUTHOR(\"\u00c1lvaro Fern\u00e1ndez Rojas <noltari@gmail.com>\");\nMODULE_AUTHOR(\"Simon Arlott\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}