{
  "module_name": "phy-bcm-ns-usb2.c",
  "hash_id": "8f80fff3f35b6aed76cc057aaf5b258904a2e65620415a640be6ccfae53ddf45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/broadcom/phy-bcm-ns-usb2.c",
  "human_readable_source": "\n \n\n#include <linux/bcma/bcma.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\nstruct bcm_ns_usb2 {\n\tstruct device *dev;\n\tstruct clk *ref_clk;\n\tstruct phy *phy;\n\tstruct regmap *clkset;\n\tvoid __iomem *base;\n\n\t \n\tvoid __iomem *dmu;\n};\n\nstatic int bcm_ns_usb2_phy_init(struct phy *phy)\n{\n\tstruct bcm_ns_usb2 *usb2 = phy_get_drvdata(phy);\n\tstruct device *dev = usb2->dev;\n\tu32 ref_clk_rate, usb2ctl, usb_pll_ndiv, usb_pll_pdiv;\n\tint err = 0;\n\n\terr = clk_prepare_enable(usb2->ref_clk);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Failed to prepare ref clock: %d\\n\", err);\n\t\tgoto err_out;\n\t}\n\n\tref_clk_rate = clk_get_rate(usb2->ref_clk);\n\tif (!ref_clk_rate) {\n\t\tdev_err(dev, \"Failed to get ref clock rate\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_clk_off;\n\t}\n\n\tif (usb2->base)\n\t\tusb2ctl = readl(usb2->base);\n\telse\n\t\tusb2ctl = readl(usb2->dmu + BCMA_DMU_CRU_USB2_CONTROL);\n\n\tif (usb2ctl & BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_PDIV_MASK) {\n\t\tusb_pll_pdiv = usb2ctl;\n\t\tusb_pll_pdiv &= BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_PDIV_MASK;\n\t\tusb_pll_pdiv >>= BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_PDIV_SHIFT;\n\t} else {\n\t\tusb_pll_pdiv = 1 << 3;\n\t}\n\n\t \n\tusb_pll_ndiv = (1920000000 * usb_pll_pdiv) / ref_clk_rate;\n\n\t \n\tif (usb2->clkset)\n\t\tregmap_write(usb2->clkset, 0, 0x0000ea68);\n\telse\n\t\twritel(0x0000ea68, usb2->dmu + BCMA_DMU_CRU_CLKSET_KEY);\n\n\t \n\tusb2ctl &= ~BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_NDIV_MASK;\n\tusb2ctl |= usb_pll_ndiv << BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_NDIV_SHIFT;\n\tif (usb2->base)\n\t\twritel(usb2ctl, usb2->base);\n\telse\n\t\twritel(usb2ctl, usb2->dmu + BCMA_DMU_CRU_USB2_CONTROL);\n\n\t \n\tif (usb2->clkset)\n\t\tregmap_write(usb2->clkset, 0, 0x00000000);\n\telse\n\t\twritel(0x00000000, usb2->dmu + BCMA_DMU_CRU_CLKSET_KEY);\n\nerr_clk_off:\n\tclk_disable_unprepare(usb2->ref_clk);\nerr_out:\n\treturn err;\n}\n\nstatic const struct phy_ops ops = {\n\t.init\t\t= bcm_ns_usb2_phy_init,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int bcm_ns_usb2_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm_ns_usb2 *usb2;\n\tstruct phy_provider *phy_provider;\n\n\tusb2 = devm_kzalloc(&pdev->dev, sizeof(*usb2), GFP_KERNEL);\n\tif (!usb2)\n\t\treturn -ENOMEM;\n\tusb2->dev = dev;\n\n\tif (of_property_present(dev->of_node, \"brcm,syscon-clkset\")) {\n\t\tusb2->base = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(usb2->base)) {\n\t\t\tdev_err(dev, \"Failed to map control reg\\n\");\n\t\t\treturn PTR_ERR(usb2->base);\n\t\t}\n\n\t\tusb2->clkset = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t       \"brcm,syscon-clkset\");\n\t\tif (IS_ERR(usb2->clkset)) {\n\t\t\tdev_err(dev, \"Failed to lookup clkset regmap\\n\");\n\t\t\treturn PTR_ERR(usb2->clkset);\n\t\t}\n\t} else {\n\t\tusb2->dmu = devm_platform_ioremap_resource_byname(pdev, \"dmu\");\n\t\tif (IS_ERR(usb2->dmu)) {\n\t\t\tdev_err(dev, \"Failed to map DMU regs\\n\");\n\t\t\treturn PTR_ERR(usb2->dmu);\n\t\t}\n\n\t\tdev_warn(dev, \"using deprecated DT binding\\n\");\n\t}\n\n\tusb2->ref_clk = devm_clk_get(dev, \"phy-ref-clk\");\n\tif (IS_ERR(usb2->ref_clk)) {\n\t\tdev_err_probe(dev, PTR_ERR(usb2->ref_clk), \"failed to get ref clk\\n\");\n\t\treturn PTR_ERR(usb2->ref_clk);\n\t}\n\n\tusb2->phy = devm_phy_create(dev, NULL, &ops);\n\tif (IS_ERR(usb2->phy))\n\t\treturn PTR_ERR(usb2->phy);\n\n\tphy_set_drvdata(usb2->phy, usb2);\n\tplatform_set_drvdata(pdev, usb2);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id bcm_ns_usb2_id_table[] = {\n\t{ .compatible = \"brcm,ns-usb2-phy\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm_ns_usb2_id_table);\n\nstatic struct platform_driver bcm_ns_usb2_driver = {\n\t.probe\t\t= bcm_ns_usb2_probe,\n\t.driver = {\n\t\t.name = \"bcm_ns_usb2\",\n\t\t.of_match_table = bcm_ns_usb2_id_table,\n\t},\n};\nmodule_platform_driver(bcm_ns_usb2_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}