{
  "module_name": "phy-sun50i-usb3.c",
  "hash_id": "9d92119dcc5cfcd5961c3f1e7fa67e1eb99e6cfaf7105c8c820a3919b25524d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/allwinner/phy-sun50i-usb3.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n \n#define SUNXI_ISCR\t\t\t0x00\n#define SUNXI_PIPE_CLOCK_CONTROL\t0x14\n#define SUNXI_PHY_TUNE_LOW\t\t0x18\n#define SUNXI_PHY_TUNE_HIGH\t\t0x1c\n#define SUNXI_PHY_EXTERNAL_CONTROL\t0x20\n\n \n#define SUNXI_ISCR_FORCE_VBUS\t\t(3 << 12)\n\n \n#define SUNXI_PCC_PIPE_CLK_OPEN\t\t(1 << 6)\n\n \n#define SUNXI_PEC_EXTERN_VBUS\t\t(3 << 1)\n#define SUNXI_PEC_SSC_EN\t\t(1 << 24)\n#define SUNXI_PEC_REF_SSP_EN\t\t(1 << 26)\n\n \n#define SUNXI_TX_DEEMPH_3P5DB(n)\t((n) << 19)\n#define SUNXI_TX_DEEMPH_3P5DB_MASK\tGENMASK(24, 19)\n#define SUNXI_TX_DEEMPH_6DB(n)\t\t((n) << 13)\n#define SUNXI_TX_DEEMPH_6GB_MASK\tGENMASK(18, 13)\n#define SUNXI_TX_SWING_FULL(n)\t\t((n) << 6)\n#define SUNXI_TX_SWING_FULL_MASK\tGENMASK(12, 6)\n#define SUNXI_LOS_BIAS(n)\t\t((n) << 3)\n#define SUNXI_LOS_BIAS_MASK\t\tGENMASK(5, 3)\n#define SUNXI_TXVBOOSTLVL(n)\t\t((n) << 0)\n#define SUNXI_TXVBOOSTLVL_MASK\t\tGENMASK(2, 0)\n\nstruct sun50i_usb3_phy {\n\tstruct phy *phy;\n\tvoid __iomem *regs;\n\tstruct reset_control *reset;\n\tstruct clk *clk;\n};\n\nstatic void sun50i_usb3_phy_open(struct sun50i_usb3_phy *phy)\n{\n\tu32 val;\n\n\tval = readl(phy->regs + SUNXI_PHY_EXTERNAL_CONTROL);\n\tval |= SUNXI_PEC_EXTERN_VBUS;\n\tval |= SUNXI_PEC_SSC_EN | SUNXI_PEC_REF_SSP_EN;\n\twritel(val, phy->regs + SUNXI_PHY_EXTERNAL_CONTROL);\n\n\tval = readl(phy->regs + SUNXI_PIPE_CLOCK_CONTROL);\n\tval |= SUNXI_PCC_PIPE_CLK_OPEN;\n\twritel(val, phy->regs + SUNXI_PIPE_CLOCK_CONTROL);\n\n\tval = readl(phy->regs + SUNXI_ISCR);\n\tval |= SUNXI_ISCR_FORCE_VBUS;\n\twritel(val, phy->regs + SUNXI_ISCR);\n\n\t \n\twritel(0x0047fc87, phy->regs + SUNXI_PHY_TUNE_LOW);\n\n\tval = readl(phy->regs + SUNXI_PHY_TUNE_HIGH);\n\tval &= ~(SUNXI_TXVBOOSTLVL_MASK | SUNXI_LOS_BIAS_MASK |\n\t\t SUNXI_TX_SWING_FULL_MASK | SUNXI_TX_DEEMPH_6GB_MASK |\n\t\t SUNXI_TX_DEEMPH_3P5DB_MASK);\n\tval |= SUNXI_TXVBOOSTLVL(0x7);\n\tval |= SUNXI_LOS_BIAS(0x7);\n\tval |= SUNXI_TX_SWING_FULL(0x55);\n\tval |= SUNXI_TX_DEEMPH_6DB(0x20);\n\tval |= SUNXI_TX_DEEMPH_3P5DB(0x15);\n\twritel(val, phy->regs + SUNXI_PHY_TUNE_HIGH);\n}\n\nstatic int sun50i_usb3_phy_init(struct phy *_phy)\n{\n\tstruct sun50i_usb3_phy *phy = phy_get_drvdata(_phy);\n\tint ret;\n\n\tret = clk_prepare_enable(phy->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_deassert(phy->reset);\n\tif (ret) {\n\t\tclk_disable_unprepare(phy->clk);\n\t\treturn ret;\n\t}\n\n\tsun50i_usb3_phy_open(phy);\n\treturn 0;\n}\n\nstatic int sun50i_usb3_phy_exit(struct phy *_phy)\n{\n\tstruct sun50i_usb3_phy *phy = phy_get_drvdata(_phy);\n\n\treset_control_assert(phy->reset);\n\tclk_disable_unprepare(phy->clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops sun50i_usb3_phy_ops = {\n\t.init\t\t= sun50i_usb3_phy_init,\n\t.exit\t\t= sun50i_usb3_phy_exit,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int sun50i_usb3_phy_probe(struct platform_device *pdev)\n{\n\tstruct sun50i_usb3_phy *phy;\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *phy_provider;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(phy->clk)) {\n\t\tif (PTR_ERR(phy->clk) != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"failed to get phy clock\\n\");\n\t\treturn PTR_ERR(phy->clk);\n\t}\n\n\tphy->reset = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(phy->reset)) {\n\t\tdev_err(dev, \"failed to get reset control\\n\");\n\t\treturn PTR_ERR(phy->reset);\n\t}\n\n\tphy->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(phy->regs))\n\t\treturn PTR_ERR(phy->regs);\n\n\tphy->phy = devm_phy_create(dev, NULL, &sun50i_usb3_phy_ops);\n\tif (IS_ERR(phy->phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(phy->phy);\n\t}\n\n\tphy_set_drvdata(phy->phy, phy);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id sun50i_usb3_phy_of_match[] = {\n\t{ .compatible = \"allwinner,sun50i-h6-usb3-phy\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sun50i_usb3_phy_of_match);\n\nstatic struct platform_driver sun50i_usb3_phy_driver = {\n\t.probe\t= sun50i_usb3_phy_probe,\n\t.driver = {\n\t\t.of_match_table\t= sun50i_usb3_phy_of_match,\n\t\t.name  = \"sun50i-usb3-phy\",\n\t}\n};\nmodule_platform_driver(sun50i_usb3_phy_driver);\n\nMODULE_DESCRIPTION(\"Allwinner H6 USB 3.0 phy driver\");\nMODULE_AUTHOR(\"Icenowy Zheng <icenowy@aosc.io>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}