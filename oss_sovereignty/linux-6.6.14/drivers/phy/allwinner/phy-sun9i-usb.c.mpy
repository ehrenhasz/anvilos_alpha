{
  "module_name": "phy-sun9i-usb.c",
  "hash_id": "2e099dfc9a99866c9a225c9a2e6fdaa185e12d1d447829b4f746aed4455c79b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/allwinner/phy-sun9i-usb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <linux/usb/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#define SUNXI_AHB_INCR16_BURST_EN\tBIT(11)\n#define SUNXI_AHB_INCR8_BURST_EN\tBIT(10)\n#define SUNXI_AHB_INCR4_BURST_EN\tBIT(9)\n#define SUNXI_AHB_INCRX_ALIGN_EN\tBIT(8)\n#define SUNXI_ULPI_BYPASS_EN\t\tBIT(0)\n\n \n#define SUNXI_EHCI_HS_FORCE\t\tBIT(20)\n#define SUNXI_HSIC_CONNECT_DET\t\tBIT(17)\n#define SUNXI_HSIC_CONNECT_INT\t\tBIT(16)\n#define SUNXI_HSIC\t\t\tBIT(1)\n\nstruct sun9i_usb_phy {\n\tstruct phy *phy;\n\tvoid __iomem *pmu;\n\tstruct reset_control *reset;\n\tstruct clk *clk;\n\tstruct clk *hsic_clk;\n\tenum usb_phy_interface type;\n};\n\nstatic void sun9i_usb_phy_passby(struct sun9i_usb_phy *phy, int enable)\n{\n\tu32 bits, reg_value;\n\n\tbits = SUNXI_AHB_INCR16_BURST_EN | SUNXI_AHB_INCR8_BURST_EN |\n\t\tSUNXI_AHB_INCR4_BURST_EN | SUNXI_AHB_INCRX_ALIGN_EN |\n\t\tSUNXI_ULPI_BYPASS_EN;\n\n\tif (phy->type == USBPHY_INTERFACE_MODE_HSIC)\n\t\tbits |= SUNXI_HSIC | SUNXI_EHCI_HS_FORCE |\n\t\t\tSUNXI_HSIC_CONNECT_DET | SUNXI_HSIC_CONNECT_INT;\n\n\treg_value = readl(phy->pmu);\n\n\tif (enable)\n\t\treg_value |= bits;\n\telse\n\t\treg_value &= ~bits;\n\n\twritel(reg_value, phy->pmu);\n}\n\nstatic int sun9i_usb_phy_init(struct phy *_phy)\n{\n\tstruct sun9i_usb_phy *phy = phy_get_drvdata(_phy);\n\tint ret;\n\n\tret = clk_prepare_enable(phy->clk);\n\tif (ret)\n\t\tgoto err_clk;\n\n\tret = clk_prepare_enable(phy->hsic_clk);\n\tif (ret)\n\t\tgoto err_hsic_clk;\n\n\tret = reset_control_deassert(phy->reset);\n\tif (ret)\n\t\tgoto err_reset;\n\n\tsun9i_usb_phy_passby(phy, 1);\n\treturn 0;\n\nerr_reset:\n\tclk_disable_unprepare(phy->hsic_clk);\n\nerr_hsic_clk:\n\tclk_disable_unprepare(phy->clk);\n\nerr_clk:\n\treturn ret;\n}\n\nstatic int sun9i_usb_phy_exit(struct phy *_phy)\n{\n\tstruct sun9i_usb_phy *phy = phy_get_drvdata(_phy);\n\n\tsun9i_usb_phy_passby(phy, 0);\n\treset_control_assert(phy->reset);\n\tclk_disable_unprepare(phy->hsic_clk);\n\tclk_disable_unprepare(phy->clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops sun9i_usb_phy_ops = {\n\t.init\t\t= sun9i_usb_phy_init,\n\t.exit\t\t= sun9i_usb_phy_exit,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int sun9i_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct sun9i_usb_phy *phy;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct phy_provider *phy_provider;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->type = of_usb_get_phy_mode(np);\n\tif (phy->type == USBPHY_INTERFACE_MODE_HSIC) {\n\t\tphy->clk = devm_clk_get(dev, \"hsic_480M\");\n\t\tif (IS_ERR(phy->clk)) {\n\t\t\tdev_err(dev, \"failed to get hsic_480M clock\\n\");\n\t\t\treturn PTR_ERR(phy->clk);\n\t\t}\n\n\t\tphy->hsic_clk = devm_clk_get(dev, \"hsic_12M\");\n\t\tif (IS_ERR(phy->hsic_clk)) {\n\t\t\tdev_err(dev, \"failed to get hsic_12M clock\\n\");\n\t\t\treturn PTR_ERR(phy->hsic_clk);\n\t\t}\n\n\t\tphy->reset = devm_reset_control_get(dev, \"hsic\");\n\t\tif (IS_ERR(phy->reset)) {\n\t\t\tdev_err(dev, \"failed to get reset control\\n\");\n\t\t\treturn PTR_ERR(phy->reset);\n\t\t}\n\t} else {\n\t\tphy->clk = devm_clk_get(dev, \"phy\");\n\t\tif (IS_ERR(phy->clk)) {\n\t\t\tdev_err(dev, \"failed to get phy clock\\n\");\n\t\t\treturn PTR_ERR(phy->clk);\n\t\t}\n\n\t\tphy->reset = devm_reset_control_get(dev, \"phy\");\n\t\tif (IS_ERR(phy->reset)) {\n\t\t\tdev_err(dev, \"failed to get reset control\\n\");\n\t\t\treturn PTR_ERR(phy->reset);\n\t\t}\n\t}\n\n\tphy->pmu = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(phy->pmu))\n\t\treturn PTR_ERR(phy->pmu);\n\n\tphy->phy = devm_phy_create(dev, NULL, &sun9i_usb_phy_ops);\n\tif (IS_ERR(phy->phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(phy->phy);\n\t}\n\n\tphy_set_drvdata(phy->phy, phy);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id sun9i_usb_phy_of_match[] = {\n\t{ .compatible = \"allwinner,sun9i-a80-usb-phy\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sun9i_usb_phy_of_match);\n\nstatic struct platform_driver sun9i_usb_phy_driver = {\n\t.probe\t= sun9i_usb_phy_probe,\n\t.driver = {\n\t\t.of_match_table\t= sun9i_usb_phy_of_match,\n\t\t.name  = \"sun9i-usb-phy\",\n\t}\n};\nmodule_platform_driver(sun9i_usb_phy_driver);\n\nMODULE_DESCRIPTION(\"Allwinner sun9i USB phy driver\");\nMODULE_AUTHOR(\"Chen-Yu Tsai <wens@csie.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}