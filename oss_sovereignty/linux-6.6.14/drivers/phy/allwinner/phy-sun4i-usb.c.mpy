{
  "module_name": "phy-sun4i-usb.c",
  "hash_id": "7559524719142c47ad4c9a1e9e51635b2fb6bf415a98480ee784e9fb10948310",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/allwinner/phy-sun4i-usb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/extcon-provider.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/phy/phy.h>\n#include <linux/phy/phy-sun4i-usb.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n#include <linux/usb/of.h>\n#include <linux/workqueue.h>\n\n#define REG_ISCR\t\t\t0x00\n#define REG_PHYCTL_A10\t\t\t0x04\n#define REG_PHYBIST\t\t\t0x08\n#define REG_PHYTUNE\t\t\t0x0c\n#define REG_PHYCTL_A33\t\t\t0x10\n#define REG_PHY_OTGCTL\t\t\t0x20\n\n#define REG_HCI_PHY_CTL\t\t\t0x10\n\n#define PHYCTL_DATA\t\t\tBIT(7)\n\n#define OTGCTL_ROUTE_MUSB\t\tBIT(0)\n\n#define SUNXI_AHB_ICHR8_EN\t\tBIT(10)\n#define SUNXI_AHB_INCR4_BURST_EN\tBIT(9)\n#define SUNXI_AHB_INCRX_ALIGN_EN\tBIT(8)\n#define SUNXI_ULPI_BYPASS_EN\t\tBIT(0)\n\n \n#define ISCR_ID_PULLUP_EN\t\t(1 << 17)\n#define ISCR_DPDM_PULLUP_EN\t(1 << 16)\n \n#define ISCR_FORCE_ID_MASK\t(3 << 14)\n#define ISCR_FORCE_ID_LOW\t\t(2 << 14)\n#define ISCR_FORCE_ID_HIGH\t(3 << 14)\n#define ISCR_FORCE_VBUS_MASK\t(3 << 12)\n#define ISCR_FORCE_VBUS_LOW\t(2 << 12)\n#define ISCR_FORCE_VBUS_HIGH\t(3 << 12)\n\n \n#define PHY_PLL_BW\t\t\t0x03\n#define PHY_RES45_CAL_EN\t\t0x0c\n\n \n#define PHY_TX_AMPLITUDE_TUNE\t\t0x20\n#define PHY_TX_SLEWRATE_TUNE\t\t0x22\n#define PHY_VBUSVALID_TH_SEL\t\t0x25\n#define PHY_PULLUP_RES_SEL\t\t0x27\n#define PHY_OTG_FUNC_EN\t\t\t0x28\n#define PHY_VBUS_DET_EN\t\t\t0x29\n#define PHY_DISCON_TH_SEL\t\t0x2a\n#define PHY_SQUELCH_DETECT\t\t0x3c\n\n \n#define PHY_CTL_VBUSVLDEXT\t\tBIT(5)\n#define PHY_CTL_SIDDQ\t\t\tBIT(3)\n#define PHY_CTL_H3_SIDDQ\t\tBIT(1)\n\n \n#define SUNXI_EHCI_HS_FORCE\t\tBIT(20)\n#define SUNXI_HSIC_CONNECT_DET\t\tBIT(17)\n#define SUNXI_HSIC_CONNECT_INT\t\tBIT(16)\n#define SUNXI_HSIC\t\t\tBIT(1)\n\n#define MAX_PHYS\t\t\t4\n\n \n#define DEBOUNCE_TIME\t\t\tmsecs_to_jiffies(50)\n#define POLL_TIME\t\t\tmsecs_to_jiffies(250)\n\nstruct sun4i_usb_phy_cfg {\n\tint num_phys;\n\tint hsic_index;\n\tu32 disc_thresh;\n\tu32 hci_phy_ctl_clear;\n\tu8 phyctl_offset;\n\tbool dedicated_clocks;\n\tbool phy0_dual_route;\n\tbool needs_phy2_siddq;\n\tbool siddq_in_base;\n\tbool poll_vbusen;\n\tint missing_phys;\n};\n\nstruct sun4i_usb_phy_data {\n\tvoid __iomem *base;\n\tconst struct sun4i_usb_phy_cfg *cfg;\n\tenum usb_dr_mode dr_mode;\n\tspinlock_t reg_lock;  \n\tstruct sun4i_usb_phy {\n\t\tstruct phy *phy;\n\t\tvoid __iomem *pmu;\n\t\tstruct regulator *vbus;\n\t\tstruct reset_control *reset;\n\t\tstruct clk *clk;\n\t\tstruct clk *clk2;\n\t\tbool regulator_on;\n\t\tint index;\n\t} phys[MAX_PHYS];\n\t \n\tstruct extcon_dev *extcon;\n\tbool phy0_init;\n\tstruct gpio_desc *id_det_gpio;\n\tstruct gpio_desc *vbus_det_gpio;\n\tstruct power_supply *vbus_power_supply;\n\tstruct notifier_block vbus_power_nb;\n\tbool vbus_power_nb_registered;\n\tbool force_session_end;\n\tint id_det_irq;\n\tint vbus_det_irq;\n\tint id_det;\n\tint vbus_det;\n\tstruct delayed_work detect;\n};\n\n#define to_sun4i_usb_phy_data(phy) \\\n\tcontainer_of((phy), struct sun4i_usb_phy_data, phys[(phy)->index])\n\nstatic void sun4i_usb_phy0_update_iscr(struct phy *_phy, u32 clr, u32 set)\n{\n\tstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\n\tstruct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);\n\tu32 iscr;\n\n\tiscr = readl(data->base + REG_ISCR);\n\tiscr &= ~clr;\n\tiscr |= set;\n\twritel(iscr, data->base + REG_ISCR);\n}\n\nstatic void sun4i_usb_phy0_set_id_detect(struct phy *phy, u32 val)\n{\n\tif (val)\n\t\tval = ISCR_FORCE_ID_HIGH;\n\telse\n\t\tval = ISCR_FORCE_ID_LOW;\n\n\tsun4i_usb_phy0_update_iscr(phy, ISCR_FORCE_ID_MASK, val);\n}\n\nstatic void sun4i_usb_phy0_set_vbus_detect(struct phy *phy, u32 val)\n{\n\tif (val)\n\t\tval = ISCR_FORCE_VBUS_HIGH;\n\telse\n\t\tval = ISCR_FORCE_VBUS_LOW;\n\n\tsun4i_usb_phy0_update_iscr(phy, ISCR_FORCE_VBUS_MASK, val);\n}\n\nstatic void sun4i_usb_phy_write(struct sun4i_usb_phy *phy, u32 addr, u32 data,\n\t\t\t\tint len)\n{\n\tstruct sun4i_usb_phy_data *phy_data = to_sun4i_usb_phy_data(phy);\n\tu32 temp, usbc_bit = BIT(phy->index * 2);\n\tvoid __iomem *phyctl = phy_data->base + phy_data->cfg->phyctl_offset;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&phy_data->reg_lock, flags);\n\n\tif (phy_data->cfg->phyctl_offset == REG_PHYCTL_A33) {\n\t\t \n\t\twritel(0, phyctl);\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\ttemp = readl(phyctl);\n\n\t\t \n\t\ttemp &= ~(0xff << 8);\n\n\t\t \n\t\ttemp |= ((addr + i) << 8);\n\t\twritel(temp, phyctl);\n\n\t\t \n\t\ttemp = readb(phyctl);\n\t\tif (data & 0x1)\n\t\t\ttemp |= PHYCTL_DATA;\n\t\telse\n\t\t\ttemp &= ~PHYCTL_DATA;\n\t\ttemp &= ~usbc_bit;\n\t\twriteb(temp, phyctl);\n\n\t\t \n\t\ttemp = readb(phyctl);\n\t\ttemp |= usbc_bit;\n\t\twriteb(temp, phyctl);\n\n\t\ttemp = readb(phyctl);\n\t\ttemp &= ~usbc_bit;\n\t\twriteb(temp, phyctl);\n\n\t\tdata >>= 1;\n\t}\n\n\tspin_unlock_irqrestore(&phy_data->reg_lock, flags);\n}\n\nstatic void sun4i_usb_phy_passby(struct sun4i_usb_phy *phy, int enable)\n{\n\tstruct sun4i_usb_phy_data *phy_data = to_sun4i_usb_phy_data(phy);\n\tu32 bits, reg_value;\n\n\tif (!phy->pmu)\n\t\treturn;\n\n\tbits = SUNXI_AHB_ICHR8_EN | SUNXI_AHB_INCR4_BURST_EN |\n\t\tSUNXI_AHB_INCRX_ALIGN_EN | SUNXI_ULPI_BYPASS_EN;\n\n\t \n\tif (phy_data->cfg->hsic_index &&\n\t    phy->index == phy_data->cfg->hsic_index)\n\t\tbits |= SUNXI_EHCI_HS_FORCE | SUNXI_HSIC_CONNECT_INT |\n\t\t\tSUNXI_HSIC;\n\n\treg_value = readl(phy->pmu);\n\n\tif (enable)\n\t\treg_value |= bits;\n\telse\n\t\treg_value &= ~bits;\n\n\twritel(reg_value, phy->pmu);\n}\n\nstatic int sun4i_usb_phy_init(struct phy *_phy)\n{\n\tstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\n\tstruct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);\n\tint ret;\n\tu32 val;\n\n\tret = clk_prepare_enable(phy->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(phy->clk2);\n\tif (ret) {\n\t\tclk_disable_unprepare(phy->clk);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(phy->reset);\n\tif (ret) {\n\t\tclk_disable_unprepare(phy->clk2);\n\t\tclk_disable_unprepare(phy->clk);\n\t\treturn ret;\n\t}\n\n\t \n\tif (data->cfg->needs_phy2_siddq && phy->index != 2) {\n\t\tstruct sun4i_usb_phy *phy2 = &data->phys[2];\n\n\t\tret = clk_prepare_enable(phy2->clk);\n\t\tif (ret) {\n\t\t\treset_control_assert(phy->reset);\n\t\t\tclk_disable_unprepare(phy->clk2);\n\t\t\tclk_disable_unprepare(phy->clk);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = reset_control_deassert(phy2->reset);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(phy2->clk);\n\t\t\treset_control_assert(phy->reset);\n\t\t\tclk_disable_unprepare(phy->clk2);\n\t\t\tclk_disable_unprepare(phy->clk);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = clk_prepare_enable(phy2->clk2);\n\t\tif (ret) {\n\t\t\treset_control_assert(phy2->reset);\n\t\t\tclk_disable_unprepare(phy2->clk);\n\t\t\treset_control_assert(phy->reset);\n\t\t\tclk_disable_unprepare(phy->clk2);\n\t\t\tclk_disable_unprepare(phy->clk);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (phy2->pmu && data->cfg->hci_phy_ctl_clear) {\n\t\t\tval = readl(phy2->pmu + REG_HCI_PHY_CTL);\n\t\t\tval &= ~data->cfg->hci_phy_ctl_clear;\n\t\t\twritel(val, phy2->pmu + REG_HCI_PHY_CTL);\n\t\t}\n\n\t\tclk_disable_unprepare(phy->clk2);\n\t}\n\n\tif (phy->pmu && data->cfg->hci_phy_ctl_clear) {\n\t\tval = readl(phy->pmu + REG_HCI_PHY_CTL);\n\t\tval &= ~data->cfg->hci_phy_ctl_clear;\n\t\twritel(val, phy->pmu + REG_HCI_PHY_CTL);\n\t}\n\n\tif (data->cfg->siddq_in_base) {\n\t\tif (phy->index == 0) {\n\t\t\tval = readl(data->base + data->cfg->phyctl_offset);\n\t\t\tval |= PHY_CTL_VBUSVLDEXT;\n\t\t\tval &= ~PHY_CTL_SIDDQ;\n\t\t\twritel(val, data->base + data->cfg->phyctl_offset);\n\t\t}\n\t} else {\n\t\t \n\t\tif (phy->index == 0)\n\t\t\tsun4i_usb_phy_write(phy, PHY_RES45_CAL_EN, 0x01, 1);\n\n\t\t \n\t\tsun4i_usb_phy_write(phy, PHY_TX_AMPLITUDE_TUNE, 0x14, 5);\n\n\t\t \n\t\tsun4i_usb_phy_write(phy, PHY_DISCON_TH_SEL,\n\t\t\t\t    data->cfg->disc_thresh, 2);\n\t}\n\n\tsun4i_usb_phy_passby(phy, 1);\n\n\tif (phy->index == 0) {\n\t\tdata->phy0_init = true;\n\n\t\t \n\t\tsun4i_usb_phy0_update_iscr(_phy, 0, ISCR_DPDM_PULLUP_EN);\n\t\tsun4i_usb_phy0_update_iscr(_phy, 0, ISCR_ID_PULLUP_EN);\n\n\t\t \n\t\tdata->id_det = -1;\n\t\tdata->vbus_det = -1;\n\t\tqueue_delayed_work(system_wq, &data->detect, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int sun4i_usb_phy_exit(struct phy *_phy)\n{\n\tstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\n\tstruct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);\n\n\tif (phy->index == 0) {\n\t\tif (data->cfg->siddq_in_base) {\n\t\t\tvoid __iomem *phyctl = data->base +\n\t\t\t\tdata->cfg->phyctl_offset;\n\n\t\t\twritel(readl(phyctl) | PHY_CTL_SIDDQ, phyctl);\n\t\t}\n\n\t\t \n\t\tsun4i_usb_phy0_update_iscr(_phy, ISCR_DPDM_PULLUP_EN, 0);\n\t\tsun4i_usb_phy0_update_iscr(_phy, ISCR_ID_PULLUP_EN, 0);\n\t\tdata->phy0_init = false;\n\t}\n\n\tif (data->cfg->needs_phy2_siddq && phy->index != 2) {\n\t\tstruct sun4i_usb_phy *phy2 = &data->phys[2];\n\n\t\tclk_disable_unprepare(phy2->clk);\n\t\treset_control_assert(phy2->reset);\n\t}\n\n\tsun4i_usb_phy_passby(phy, 0);\n\treset_control_assert(phy->reset);\n\tclk_disable_unprepare(phy->clk2);\n\tclk_disable_unprepare(phy->clk);\n\n\treturn 0;\n}\n\nstatic int sun4i_usb_phy0_get_id_det(struct sun4i_usb_phy_data *data)\n{\n\tswitch (data->dr_mode) {\n\tcase USB_DR_MODE_OTG:\n\t\tif (data->id_det_gpio)\n\t\t\treturn gpiod_get_value_cansleep(data->id_det_gpio);\n\t\telse\n\t\t\treturn 1;  \n\tcase USB_DR_MODE_HOST:\n\t\treturn 0;\n\tcase USB_DR_MODE_PERIPHERAL:\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int sun4i_usb_phy0_get_vbus_det(struct sun4i_usb_phy_data *data)\n{\n\tif (data->vbus_det_gpio)\n\t\treturn gpiod_get_value_cansleep(data->vbus_det_gpio);\n\n\tif (data->vbus_power_supply) {\n\t\tunion power_supply_propval val;\n\t\tint r;\n\n\t\tr = power_supply_get_property(data->vbus_power_supply,\n\t\t\t\t\t      POWER_SUPPLY_PROP_PRESENT, &val);\n\t\tif (r == 0)\n\t\t\treturn val.intval;\n\t}\n\n\t \n\treturn 1;\n}\n\nstatic bool sun4i_usb_phy0_have_vbus_det(struct sun4i_usb_phy_data *data)\n{\n\treturn data->vbus_det_gpio || data->vbus_power_supply;\n}\n\nstatic bool sun4i_usb_phy0_poll(struct sun4i_usb_phy_data *data)\n{\n\tif ((data->id_det_gpio && data->id_det_irq <= 0) ||\n\t    (data->vbus_det_gpio && data->vbus_det_irq <= 0))\n\t\treturn true;\n\n\t \n\tif (data->cfg->poll_vbusen && data->vbus_power_supply &&\n\t    data->phys[0].regulator_on)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int sun4i_usb_phy_power_on(struct phy *_phy)\n{\n\tstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\n\tstruct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);\n\tint ret;\n\n\tif (!phy->vbus || phy->regulator_on)\n\t\treturn 0;\n\n\t \n\tif (phy->index == 0 && sun4i_usb_phy0_have_vbus_det(data) &&\n\t\t\t\tdata->vbus_det) {\n\t\tdev_warn(&_phy->dev, \"External vbus detected, not enabling our own vbus\\n\");\n\t\treturn 0;\n\t}\n\n\tret = regulator_enable(phy->vbus);\n\tif (ret)\n\t\treturn ret;\n\n\tphy->regulator_on = true;\n\n\t \n\tif (phy->index == 0 && sun4i_usb_phy0_poll(data))\n\t\tmod_delayed_work(system_wq, &data->detect, DEBOUNCE_TIME);\n\n\treturn 0;\n}\n\nstatic int sun4i_usb_phy_power_off(struct phy *_phy)\n{\n\tstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\n\tstruct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);\n\n\tif (!phy->vbus || !phy->regulator_on)\n\t\treturn 0;\n\n\tregulator_disable(phy->vbus);\n\tphy->regulator_on = false;\n\n\t \n\tif (phy->index == 0 && !sun4i_usb_phy0_poll(data))\n\t\tmod_delayed_work(system_wq, &data->detect, POLL_TIME);\n\n\treturn 0;\n}\n\nstatic int sun4i_usb_phy_set_mode(struct phy *_phy,\n\t\t\t\t  enum phy_mode mode, int submode)\n{\n\tstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\n\tstruct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);\n\tint new_mode;\n\n\tif (phy->index != 0) {\n\t\tif (mode == PHY_MODE_USB_HOST)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mode) {\n\tcase PHY_MODE_USB_HOST:\n\t\tnew_mode = USB_DR_MODE_HOST;\n\t\tbreak;\n\tcase PHY_MODE_USB_DEVICE:\n\t\tnew_mode = USB_DR_MODE_PERIPHERAL;\n\t\tbreak;\n\tcase PHY_MODE_USB_OTG:\n\t\tnew_mode = USB_DR_MODE_OTG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_mode != data->dr_mode) {\n\t\tdev_info(&_phy->dev, \"Changing dr_mode to %d\\n\", new_mode);\n\t\tdata->dr_mode = new_mode;\n\t}\n\n\tdata->id_det = -1;  \n\tdata->force_session_end = true;\n\tqueue_delayed_work(system_wq, &data->detect, 0);\n\n\treturn 0;\n}\n\nvoid sun4i_usb_phy_set_squelch_detect(struct phy *_phy, bool enabled)\n{\n\tstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\n\n\tsun4i_usb_phy_write(phy, PHY_SQUELCH_DETECT, enabled ? 0 : 2, 2);\n}\nEXPORT_SYMBOL_GPL(sun4i_usb_phy_set_squelch_detect);\n\nstatic const struct phy_ops sun4i_usb_phy_ops = {\n\t.init\t\t= sun4i_usb_phy_init,\n\t.exit\t\t= sun4i_usb_phy_exit,\n\t.power_on\t= sun4i_usb_phy_power_on,\n\t.power_off\t= sun4i_usb_phy_power_off,\n\t.set_mode\t= sun4i_usb_phy_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void sun4i_usb_phy0_reroute(struct sun4i_usb_phy_data *data, int id_det)\n{\n\tu32 regval;\n\n\tregval = readl(data->base + REG_PHY_OTGCTL);\n\tif (id_det == 0) {\n\t\t \n\t\tregval &= ~OTGCTL_ROUTE_MUSB;\n\t} else {\n\t\t \n\t\tregval |= OTGCTL_ROUTE_MUSB;\n\t}\n\twritel(regval, data->base + REG_PHY_OTGCTL);\n}\n\nstatic void sun4i_usb_phy0_id_vbus_det_scan(struct work_struct *work)\n{\n\tstruct sun4i_usb_phy_data *data =\n\t\tcontainer_of(work, struct sun4i_usb_phy_data, detect.work);\n\tstruct phy *phy0 = data->phys[0].phy;\n\tstruct sun4i_usb_phy *phy;\n\tbool force_session_end, id_notify = false, vbus_notify = false;\n\tint id_det, vbus_det;\n\n\tif (!phy0)\n\t\treturn;\n\n\tphy = phy_get_drvdata(phy0);\n\tid_det = sun4i_usb_phy0_get_id_det(data);\n\tvbus_det = sun4i_usb_phy0_get_vbus_det(data);\n\n\tmutex_lock(&phy0->mutex);\n\n\tif (!data->phy0_init) {\n\t\tmutex_unlock(&phy0->mutex);\n\t\treturn;\n\t}\n\n\tforce_session_end = data->force_session_end;\n\tdata->force_session_end = false;\n\n\tif (id_det != data->id_det) {\n\t\t \n\t\tif (data->dr_mode == USB_DR_MODE_OTG &&\n\t\t    !sun4i_usb_phy0_have_vbus_det(data))\n\t\t\tforce_session_end = true;\n\n\t\t \n\t\tif (force_session_end && id_det == 0) {\n\t\t\tsun4i_usb_phy0_set_vbus_detect(phy0, 0);\n\t\t\tmsleep(200);\n\t\t\tsun4i_usb_phy0_set_vbus_detect(phy0, 1);\n\t\t}\n\t\tsun4i_usb_phy0_set_id_detect(phy0, id_det);\n\t\tdata->id_det = id_det;\n\t\tid_notify = true;\n\t}\n\n\tif (vbus_det != data->vbus_det) {\n\t\tsun4i_usb_phy0_set_vbus_detect(phy0, vbus_det);\n\t\tdata->vbus_det = vbus_det;\n\t\tvbus_notify = true;\n\t}\n\n\tmutex_unlock(&phy0->mutex);\n\n\tif (id_notify) {\n\t\textcon_set_state_sync(data->extcon, EXTCON_USB_HOST,\n\t\t\t\t\t!id_det);\n\t\t \n\t\tif (force_session_end && id_det == 1) {\n\t\t\tmutex_lock(&phy0->mutex);\n\t\t\tsun4i_usb_phy0_set_vbus_detect(phy0, 0);\n\t\t\tmsleep(1000);\n\t\t\tsun4i_usb_phy0_set_vbus_detect(phy0, 1);\n\t\t\tmutex_unlock(&phy0->mutex);\n\t\t}\n\n\t\t \n\t\tsun4i_usb_phy_passby(phy, !id_det);\n\n\t\t \n\t\tif (data->cfg->phy0_dual_route)\n\t\t\tsun4i_usb_phy0_reroute(data, id_det);\n\t}\n\n\tif (vbus_notify)\n\t\textcon_set_state_sync(data->extcon, EXTCON_USB, vbus_det);\n\n\tif (sun4i_usb_phy0_poll(data))\n\t\tqueue_delayed_work(system_wq, &data->detect, POLL_TIME);\n}\n\nstatic irqreturn_t sun4i_usb_phy0_id_vbus_det_irq(int irq, void *dev_id)\n{\n\tstruct sun4i_usb_phy_data *data = dev_id;\n\n\t \n\tmod_delayed_work(system_wq, &data->detect, DEBOUNCE_TIME);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sun4i_usb_phy0_vbus_notify(struct notifier_block *nb,\n\t\t\t\t      unsigned long val, void *v)\n{\n\tstruct sun4i_usb_phy_data *data =\n\t\tcontainer_of(nb, struct sun4i_usb_phy_data, vbus_power_nb);\n\tstruct power_supply *psy = v;\n\n\t \n\tif (val == PSY_EVENT_PROP_CHANGED && psy == data->vbus_power_supply)\n\t\tmod_delayed_work(system_wq, &data->detect, DEBOUNCE_TIME);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct phy *sun4i_usb_phy_xlate(struct device *dev,\n\t\t\t\t\tstruct of_phandle_args *args)\n{\n\tstruct sun4i_usb_phy_data *data = dev_get_drvdata(dev);\n\n\tif (args->args[0] >= data->cfg->num_phys)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (data->cfg->missing_phys & BIT(args->args[0]))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn data->phys[args->args[0]].phy;\n}\n\nstatic void sun4i_usb_phy_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sun4i_usb_phy_data *data = dev_get_drvdata(dev);\n\n\tif (data->vbus_power_nb_registered)\n\t\tpower_supply_unreg_notifier(&data->vbus_power_nb);\n\tif (data->id_det_irq > 0)\n\t\tdevm_free_irq(dev, data->id_det_irq, data);\n\tif (data->vbus_det_irq > 0)\n\t\tdevm_free_irq(dev, data->vbus_det_irq, data);\n\n\tcancel_delayed_work_sync(&data->detect);\n}\n\nstatic const unsigned int sun4i_usb_phy0_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_NONE,\n};\n\nstatic int sun4i_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct sun4i_usb_phy_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct phy_provider *phy_provider;\n\tint i, ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&data->reg_lock);\n\tINIT_DELAYED_WORK(&data->detect, sun4i_usb_phy0_id_vbus_det_scan);\n\tdev_set_drvdata(dev, data);\n\tdata->cfg = of_device_get_match_data(dev);\n\tif (!data->cfg)\n\t\treturn -EINVAL;\n\n\tdata->base = devm_platform_ioremap_resource_byname(pdev, \"phy_ctrl\");\n\tif (IS_ERR(data->base))\n\t\treturn PTR_ERR(data->base);\n\n\tdata->id_det_gpio = devm_gpiod_get_optional(dev, \"usb0_id_det\",\n\t\t\t\t\t\t    GPIOD_IN);\n\tif (IS_ERR(data->id_det_gpio)) {\n\t\tdev_err(dev, \"Couldn't request ID GPIO\\n\");\n\t\treturn PTR_ERR(data->id_det_gpio);\n\t}\n\n\tdata->vbus_det_gpio = devm_gpiod_get_optional(dev, \"usb0_vbus_det\",\n\t\t\t\t\t\t      GPIOD_IN);\n\tif (IS_ERR(data->vbus_det_gpio)) {\n\t\tdev_err(dev, \"Couldn't request VBUS detect GPIO\\n\");\n\t\treturn PTR_ERR(data->vbus_det_gpio);\n\t}\n\n\tif (of_property_present(np, \"usb0_vbus_power-supply\")) {\n\t\tdata->vbus_power_supply = devm_power_supply_get_by_phandle(dev,\n\t\t\t\t\t\t     \"usb0_vbus_power-supply\");\n\t\tif (IS_ERR(data->vbus_power_supply)) {\n\t\t\tdev_err(dev, \"Couldn't get the VBUS power supply\\n\");\n\t\t\treturn PTR_ERR(data->vbus_power_supply);\n\t\t}\n\n\t\tif (!data->vbus_power_supply)\n\t\t\treturn -EPROBE_DEFER;\n\t}\n\n\tdata->dr_mode = of_usb_get_dr_mode_by_phy(np, 0);\n\n\tdata->extcon = devm_extcon_dev_allocate(dev, sun4i_usb_phy0_cable);\n\tif (IS_ERR(data->extcon)) {\n\t\tdev_err(dev, \"Couldn't allocate our extcon device\\n\");\n\t\treturn PTR_ERR(data->extcon);\n\t}\n\n\tret = devm_extcon_dev_register(dev, data->extcon);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register extcon: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < data->cfg->num_phys; i++) {\n\t\tstruct sun4i_usb_phy *phy = data->phys + i;\n\t\tchar name[16];\n\n\t\tif (data->cfg->missing_phys & BIT(i))\n\t\t\tcontinue;\n\n\t\tsnprintf(name, sizeof(name), \"usb%d_vbus\", i);\n\t\tphy->vbus = devm_regulator_get_optional(dev, name);\n\t\tif (IS_ERR(phy->vbus)) {\n\t\t\tif (PTR_ERR(phy->vbus) == -EPROBE_DEFER) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Couldn't get regulator %s... Deferring probe\\n\",\n\t\t\t\t\tname);\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\t}\n\n\t\t\tphy->vbus = NULL;\n\t\t}\n\n\t\tif (data->cfg->dedicated_clocks)\n\t\t\tsnprintf(name, sizeof(name), \"usb%d_phy\", i);\n\t\telse\n\t\t\tstrscpy(name, \"usb_phy\", sizeof(name));\n\n\t\tphy->clk = devm_clk_get(dev, name);\n\t\tif (IS_ERR(phy->clk)) {\n\t\t\tdev_err(dev, \"failed to get clock %s\\n\", name);\n\t\t\treturn PTR_ERR(phy->clk);\n\t\t}\n\n\t\t \n\t\tif (data->cfg->hsic_index && i == data->cfg->hsic_index) {\n\t\t\t \n\t\t\tsnprintf(name, sizeof(name), \"usb%d_hsic_12M\", i);\n\t\t\tphy->clk2 = devm_clk_get(dev, name);\n\t\t\tif (IS_ERR(phy->clk2)) {\n\t\t\t\tdev_err(dev, \"failed to get clock %s\\n\", name);\n\t\t\t\treturn PTR_ERR(phy->clk2);\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"pmu%d_clk\", i);\n\t\t\tphy->clk2 = devm_clk_get_optional(dev, name);\n\t\t\tif (IS_ERR(phy->clk2)) {\n\t\t\t\tdev_err(dev, \"failed to get clock %s\\n\", name);\n\t\t\t\treturn PTR_ERR(phy->clk2);\n\t\t\t}\n\t\t}\n\n\t\tsnprintf(name, sizeof(name), \"usb%d_reset\", i);\n\t\tphy->reset = devm_reset_control_get(dev, name);\n\t\tif (IS_ERR(phy->reset)) {\n\t\t\tdev_err(dev, \"failed to get reset %s\\n\", name);\n\t\t\treturn PTR_ERR(phy->reset);\n\t\t}\n\n\t\tif (i || data->cfg->phy0_dual_route) {  \n\t\t\tsnprintf(name, sizeof(name), \"pmu%d\", i);\n\t\t\tphy->pmu = devm_platform_ioremap_resource_byname(pdev, name);\n\t\t\tif (IS_ERR(phy->pmu))\n\t\t\t\treturn PTR_ERR(phy->pmu);\n\t\t}\n\n\t\tphy->phy = devm_phy_create(dev, NULL, &sun4i_usb_phy_ops);\n\t\tif (IS_ERR(phy->phy)) {\n\t\t\tdev_err(dev, \"failed to create PHY %d\\n\", i);\n\t\t\treturn PTR_ERR(phy->phy);\n\t\t}\n\n\t\tphy->index = i;\n\t\tphy_set_drvdata(phy->phy, &data->phys[i]);\n\t}\n\n\tdata->id_det_irq = gpiod_to_irq(data->id_det_gpio);\n\tif (data->id_det_irq > 0) {\n\t\tret = devm_request_irq(dev, data->id_det_irq,\n\t\t\t\tsun4i_usb_phy0_id_vbus_det_irq,\n\t\t\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\t\t\t\t\"usb0-id-det\", data);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Err requesting id-det-irq: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdata->vbus_det_irq = gpiod_to_irq(data->vbus_det_gpio);\n\tif (data->vbus_det_irq > 0) {\n\t\tret = devm_request_irq(dev, data->vbus_det_irq,\n\t\t\t\tsun4i_usb_phy0_id_vbus_det_irq,\n\t\t\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\t\t\t\t\"usb0-vbus-det\", data);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Err requesting vbus-det-irq: %d\\n\", ret);\n\t\t\tdata->vbus_det_irq = -1;\n\t\t\tsun4i_usb_phy_remove(pdev);  \n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (data->vbus_power_supply) {\n\t\tdata->vbus_power_nb.notifier_call = sun4i_usb_phy0_vbus_notify;\n\t\tdata->vbus_power_nb.priority = 0;\n\t\tret = power_supply_reg_notifier(&data->vbus_power_nb);\n\t\tif (ret) {\n\t\t\tsun4i_usb_phy_remove(pdev);  \n\t\t\treturn ret;\n\t\t}\n\t\tdata->vbus_power_nb_registered = true;\n\t}\n\n\tphy_provider = devm_of_phy_provider_register(dev, sun4i_usb_phy_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tsun4i_usb_phy_remove(pdev);  \n\t\treturn PTR_ERR(phy_provider);\n\t}\n\n\tdev_dbg(dev, \"successfully loaded\\n\");\n\n\treturn 0;\n}\n\nstatic const struct sun4i_usb_phy_cfg suniv_f1c100s_cfg = {\n\t.num_phys = 1,\n\t.disc_thresh = 3,\n\t.phyctl_offset = REG_PHYCTL_A10,\n\t.dedicated_clocks = true,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun4i_a10_cfg = {\n\t.num_phys = 3,\n\t.disc_thresh = 3,\n\t.phyctl_offset = REG_PHYCTL_A10,\n\t.dedicated_clocks = false,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun5i_a13_cfg = {\n\t.num_phys = 2,\n\t.disc_thresh = 2,\n\t.phyctl_offset = REG_PHYCTL_A10,\n\t.dedicated_clocks = false,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun6i_a31_cfg = {\n\t.num_phys = 3,\n\t.disc_thresh = 3,\n\t.phyctl_offset = REG_PHYCTL_A10,\n\t.dedicated_clocks = true,\n\t.poll_vbusen = true,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun7i_a20_cfg = {\n\t.num_phys = 3,\n\t.disc_thresh = 2,\n\t.phyctl_offset = REG_PHYCTL_A10,\n\t.dedicated_clocks = false,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun8i_a23_cfg = {\n\t.num_phys = 2,\n\t.disc_thresh = 3,\n\t.phyctl_offset = REG_PHYCTL_A10,\n\t.dedicated_clocks = true,\n\t.poll_vbusen = true,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun8i_a33_cfg = {\n\t.num_phys = 2,\n\t.disc_thresh = 3,\n\t.phyctl_offset = REG_PHYCTL_A33,\n\t.dedicated_clocks = true,\n\t.poll_vbusen = true,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun8i_a83t_cfg = {\n\t.num_phys = 3,\n\t.hsic_index = 2,\n\t.phyctl_offset = REG_PHYCTL_A33,\n\t.dedicated_clocks = true,\n\t.siddq_in_base = true,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun8i_h3_cfg = {\n\t.num_phys = 4,\n\t.disc_thresh = 3,\n\t.phyctl_offset = REG_PHYCTL_A33,\n\t.dedicated_clocks = true,\n\t.hci_phy_ctl_clear = PHY_CTL_H3_SIDDQ,\n\t.phy0_dual_route = true,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun8i_r40_cfg = {\n\t.num_phys = 3,\n\t.disc_thresh = 3,\n\t.phyctl_offset = REG_PHYCTL_A33,\n\t.dedicated_clocks = true,\n\t.hci_phy_ctl_clear = PHY_CTL_H3_SIDDQ,\n\t.phy0_dual_route = true,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun8i_v3s_cfg = {\n\t.num_phys = 1,\n\t.disc_thresh = 3,\n\t.phyctl_offset = REG_PHYCTL_A33,\n\t.dedicated_clocks = true,\n\t.hci_phy_ctl_clear = PHY_CTL_H3_SIDDQ,\n\t.phy0_dual_route = true,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun20i_d1_cfg = {\n\t.num_phys = 2,\n\t.phyctl_offset = REG_PHYCTL_A33,\n\t.dedicated_clocks = true,\n\t.hci_phy_ctl_clear = PHY_CTL_SIDDQ,\n\t.phy0_dual_route = true,\n\t.siddq_in_base = true,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun50i_a64_cfg = {\n\t.num_phys = 2,\n\t.disc_thresh = 3,\n\t.phyctl_offset = REG_PHYCTL_A33,\n\t.dedicated_clocks = true,\n\t.hci_phy_ctl_clear = PHY_CTL_H3_SIDDQ,\n\t.phy0_dual_route = true,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun50i_h6_cfg = {\n\t.num_phys = 4,\n\t.phyctl_offset = REG_PHYCTL_A33,\n\t.dedicated_clocks = true,\n\t.phy0_dual_route = true,\n\t.missing_phys = BIT(1) | BIT(2),\n\t.siddq_in_base = true,\n};\n\nstatic const struct sun4i_usb_phy_cfg sun50i_h616_cfg = {\n\t.num_phys = 4,\n\t.disc_thresh = 3,\n\t.phyctl_offset = REG_PHYCTL_A33,\n\t.dedicated_clocks = true,\n\t.phy0_dual_route = true,\n\t.hci_phy_ctl_clear = PHY_CTL_SIDDQ,\n\t.needs_phy2_siddq = true,\n\t.siddq_in_base = true,\n};\n\nstatic const struct of_device_id sun4i_usb_phy_of_match[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-usb-phy\", .data = &sun4i_a10_cfg },\n\t{ .compatible = \"allwinner,sun5i-a13-usb-phy\", .data = &sun5i_a13_cfg },\n\t{ .compatible = \"allwinner,sun6i-a31-usb-phy\", .data = &sun6i_a31_cfg },\n\t{ .compatible = \"allwinner,sun7i-a20-usb-phy\", .data = &sun7i_a20_cfg },\n\t{ .compatible = \"allwinner,sun8i-a23-usb-phy\", .data = &sun8i_a23_cfg },\n\t{ .compatible = \"allwinner,sun8i-a33-usb-phy\", .data = &sun8i_a33_cfg },\n\t{ .compatible = \"allwinner,sun8i-a83t-usb-phy\", .data = &sun8i_a83t_cfg },\n\t{ .compatible = \"allwinner,sun8i-h3-usb-phy\", .data = &sun8i_h3_cfg },\n\t{ .compatible = \"allwinner,sun8i-r40-usb-phy\", .data = &sun8i_r40_cfg },\n\t{ .compatible = \"allwinner,sun8i-v3s-usb-phy\", .data = &sun8i_v3s_cfg },\n\t{ .compatible = \"allwinner,sun20i-d1-usb-phy\", .data = &sun20i_d1_cfg },\n\t{ .compatible = \"allwinner,sun50i-a64-usb-phy\",\n\t  .data = &sun50i_a64_cfg},\n\t{ .compatible = \"allwinner,sun50i-h6-usb-phy\", .data = &sun50i_h6_cfg },\n\t{ .compatible = \"allwinner,sun50i-h616-usb-phy\", .data = &sun50i_h616_cfg },\n\t{ .compatible = \"allwinner,suniv-f1c100s-usb-phy\",\n\t  .data = &suniv_f1c100s_cfg },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sun4i_usb_phy_of_match);\n\nstatic struct platform_driver sun4i_usb_phy_driver = {\n\t.probe\t= sun4i_usb_phy_probe,\n\t.remove_new = sun4i_usb_phy_remove,\n\t.driver = {\n\t\t.of_match_table\t= sun4i_usb_phy_of_match,\n\t\t.name  = \"sun4i-usb-phy\",\n\t}\n};\nmodule_platform_driver(sun4i_usb_phy_driver);\n\nMODULE_DESCRIPTION(\"Allwinner sun4i USB phy driver\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}