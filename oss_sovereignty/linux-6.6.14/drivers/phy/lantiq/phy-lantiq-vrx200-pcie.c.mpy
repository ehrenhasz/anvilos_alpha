{
  "module_name": "phy-lantiq-vrx200-pcie.c",
  "hash_id": "d66831761bcbcbe75c72fee2fe4d89442d742cea7eb78e8f728883f6d876f80b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/lantiq/phy-lantiq-vrx200-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <dt-bindings/phy/phy-lantiq-vrx200-pcie.h>\n\n#define PCIE_PHY_PLL_CTRL1\t\t\t\t0x44\n\n#define PCIE_PHY_PLL_CTRL2\t\t\t\t0x46\n#define PCIE_PHY_PLL_CTRL2_CONST_SDM_MASK\t\tGENMASK(7, 0)\n#define PCIE_PHY_PLL_CTRL2_CONST_SDM_EN\t\t\tBIT(8)\n#define PCIE_PHY_PLL_CTRL2_PLL_SDM_EN\t\t\tBIT(9)\n\n#define PCIE_PHY_PLL_CTRL3\t\t\t\t0x48\n#define PCIE_PHY_PLL_CTRL3_EXT_MMD_DIV_RATIO_EN\t\tBIT(1)\n#define PCIE_PHY_PLL_CTRL3_EXT_MMD_DIV_RATIO_MASK\tGENMASK(6, 4)\n\n#define PCIE_PHY_PLL_CTRL4\t\t\t\t0x4a\n#define PCIE_PHY_PLL_CTRL5\t\t\t\t0x4c\n#define PCIE_PHY_PLL_CTRL6\t\t\t\t0x4e\n#define PCIE_PHY_PLL_CTRL7\t\t\t\t0x50\n#define PCIE_PHY_PLL_A_CTRL1\t\t\t\t0x52\n\n#define PCIE_PHY_PLL_A_CTRL2\t\t\t\t0x54\n#define PCIE_PHY_PLL_A_CTRL2_LF_MODE_EN\t\t\tBIT(14)\n\n#define PCIE_PHY_PLL_A_CTRL3\t\t\t\t0x56\n#define PCIE_PHY_PLL_A_CTRL3_MMD_MASK\t\t\tGENMASK(15, 13)\n\n#define PCIE_PHY_PLL_STATUS\t\t\t\t0x58\n\n#define PCIE_PHY_TX1_CTRL1\t\t\t\t0x60\n#define PCIE_PHY_TX1_CTRL1_FORCE_EN\t\t\tBIT(3)\n#define PCIE_PHY_TX1_CTRL1_LOAD_EN\t\t\tBIT(4)\n\n#define PCIE_PHY_TX1_CTRL2\t\t\t\t0x62\n#define PCIE_PHY_TX1_CTRL3\t\t\t\t0x64\n#define PCIE_PHY_TX1_A_CTRL1\t\t\t\t0x66\n#define PCIE_PHY_TX1_A_CTRL2\t\t\t\t0x68\n#define PCIE_PHY_TX1_MOD1\t\t\t\t0x6a\n#define PCIE_PHY_TX1_MOD2\t\t\t\t0x6c\n#define PCIE_PHY_TX1_MOD3\t\t\t\t0x6e\n\n#define PCIE_PHY_TX2_CTRL1\t\t\t\t0x70\n#define PCIE_PHY_TX2_CTRL1_LOAD_EN\t\t\tBIT(4)\n\n#define PCIE_PHY_TX2_CTRL2\t\t\t\t0x72\n#define PCIE_PHY_TX2_A_CTRL1\t\t\t\t0x76\n#define PCIE_PHY_TX2_A_CTRL2\t\t\t\t0x78\n#define PCIE_PHY_TX2_MOD1\t\t\t\t0x7a\n#define PCIE_PHY_TX2_MOD2\t\t\t\t0x7c\n#define PCIE_PHY_TX2_MOD3\t\t\t\t0x7e\n\n#define PCIE_PHY_RX1_CTRL1\t\t\t\t0xa0\n#define PCIE_PHY_RX1_CTRL1_LOAD_EN\t\t\tBIT(1)\n\n#define PCIE_PHY_RX1_CTRL2\t\t\t\t0xa2\n#define PCIE_PHY_RX1_CDR\t\t\t\t0xa4\n#define PCIE_PHY_RX1_EI\t\t\t\t\t0xa6\n#define PCIE_PHY_RX1_A_CTRL\t\t\t\t0xaa\n\nstruct ltq_vrx200_pcie_phy_priv {\n\tstruct phy\t\t\t*phy;\n\tunsigned int\t\t\tmode;\n\tstruct device\t\t\t*dev;\n\tstruct regmap\t\t\t*phy_regmap;\n\tstruct regmap\t\t\t*rcu_regmap;\n\tstruct clk\t\t\t*pdi_clk;\n\tstruct clk\t\t\t*phy_clk;\n\tstruct reset_control\t\t*phy_reset;\n\tstruct reset_control\t\t*pcie_reset;\n\tu32\t\t\t\trcu_ahb_endian_offset;\n\tu32\t\t\t\trcu_ahb_endian_big_endian_mask;\n};\n\nstatic void ltq_vrx200_pcie_phy_common_setup(struct phy *phy)\n{\n\tstruct ltq_vrx200_pcie_phy_priv *priv = phy_get_drvdata(phy);\n\n\t \n\tregmap_write(priv->phy_regmap, PCIE_PHY_PLL_A_CTRL1, 0x120e);\n\n\t \n\tregmap_write(priv->phy_regmap, PCIE_PHY_PLL_A_CTRL2, 0x39d7);\n\tregmap_write(priv->phy_regmap, PCIE_PHY_PLL_A_CTRL3, 0x0900);\n\n\t \n\tregmap_write(priv->phy_regmap, PCIE_PHY_RX1_EI, 0x0004);\n\tregmap_write(priv->phy_regmap, PCIE_PHY_RX1_A_CTRL, 0x6803);\n\n\tregmap_update_bits(priv->phy_regmap, PCIE_PHY_TX1_CTRL1,\n\t\t\t   PCIE_PHY_TX1_CTRL1_FORCE_EN,\n\t\t\t   PCIE_PHY_TX1_CTRL1_FORCE_EN);\n\n\t \n\tregmap_write(priv->phy_regmap, PCIE_PHY_TX1_A_CTRL2, 0x0706);\n\n\t \n\tregmap_write(priv->phy_regmap, PCIE_PHY_TX1_CTRL3, 0x1fff);\n\n\t \n\tregmap_write(priv->phy_regmap, PCIE_PHY_TX1_A_CTRL1, 0x0810);\n\n\t \n\tregmap_update_bits(priv->phy_regmap, PCIE_PHY_TX2_A_CTRL2, 0x7f00,\n\t\t\t   0x4700);\n\n\t \n\tregmap_write(priv->phy_regmap, PCIE_PHY_TX1_CTRL2, 0x2e00);\n\n\t \n\tregmap_write(priv->phy_regmap, PCIE_PHY_TX2_CTRL2, 0x3096);\n\tregmap_write(priv->phy_regmap, PCIE_PHY_TX2_A_CTRL2, 0x4707);\n\n\t \n\tregmap_write(priv->phy_regmap, PCIE_PHY_RX1_CDR, 0x0235);\n}\n\nstatic void pcie_phy_36mhz_mode_setup(struct phy *phy)\n{\n\tstruct ltq_vrx200_pcie_phy_priv *priv = phy_get_drvdata(phy);\n\n\tregmap_update_bits(priv->phy_regmap, PCIE_PHY_PLL_CTRL3,\n\t\t\t   PCIE_PHY_PLL_CTRL3_EXT_MMD_DIV_RATIO_EN, 0x0000);\n\n\tregmap_update_bits(priv->phy_regmap, PCIE_PHY_PLL_CTRL3,\n\t\t\t   PCIE_PHY_PLL_CTRL3_EXT_MMD_DIV_RATIO_MASK, 0x0000);\n\n\tregmap_update_bits(priv->phy_regmap, PCIE_PHY_PLL_CTRL2,\n\t\t\t   PCIE_PHY_PLL_CTRL2_PLL_SDM_EN,\n\t\t\t   PCIE_PHY_PLL_CTRL2_PLL_SDM_EN);\n\n\tregmap_update_bits(priv->phy_regmap, PCIE_PHY_PLL_CTRL2,\n\t\t\t   PCIE_PHY_PLL_CTRL2_CONST_SDM_EN,\n\t\t\t   PCIE_PHY_PLL_CTRL2_CONST_SDM_EN);\n\n\tregmap_update_bits(priv->phy_regmap, PCIE_PHY_PLL_A_CTRL3,\n\t\t\t   PCIE_PHY_PLL_A_CTRL3_MMD_MASK,\n\t\t\t   FIELD_PREP(PCIE_PHY_PLL_A_CTRL3_MMD_MASK, 0x1));\n\n\tregmap_update_bits(priv->phy_regmap, PCIE_PHY_PLL_A_CTRL2,\n\t\t\t   PCIE_PHY_PLL_A_CTRL2_LF_MODE_EN, 0x0000);\n\n\t \n\tregmap_write(priv->phy_regmap, PCIE_PHY_PLL_CTRL1, 0x38e4);\n\n\tregmap_update_bits(priv->phy_regmap, PCIE_PHY_PLL_CTRL2,\n\t\t\t   PCIE_PHY_PLL_CTRL2_CONST_SDM_MASK,\n\t\t\t   FIELD_PREP(PCIE_PHY_PLL_CTRL2_CONST_SDM_MASK,\n\t\t\t\t      0xee));\n\n\t \n\tregmap_write(priv->phy_regmap, PCIE_PHY_PLL_CTRL7, 0x0002);\n\tregmap_write(priv->phy_regmap, PCIE_PHY_PLL_CTRL6, 0x3a04);\n\tregmap_write(priv->phy_regmap, PCIE_PHY_PLL_CTRL5, 0xfae3);\n\tregmap_write(priv->phy_regmap, PCIE_PHY_PLL_CTRL4, 0x1b72);\n}\n\nstatic int ltq_vrx200_pcie_phy_wait_for_pll(struct phy *phy)\n{\n\tstruct ltq_vrx200_pcie_phy_priv *priv = phy_get_drvdata(phy);\n\tunsigned int tmp;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(priv->phy_regmap, PCIE_PHY_PLL_STATUS,\n\t\t\t\t       tmp, ((tmp & 0x0070) == 0x0070), 10,\n\t\t\t\t       10000);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"PLL Link timeout, PLL status = 0x%04x\\n\",\n\t\t\ttmp);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ltq_vrx200_pcie_phy_apply_workarounds(struct phy *phy)\n{\n\tstruct ltq_vrx200_pcie_phy_priv *priv = phy_get_drvdata(phy);\n\tstatic const struct reg_default slices[] =  {\n\t\t{\n\t\t\t.reg = PCIE_PHY_TX1_CTRL1,\n\t\t\t.def = PCIE_PHY_TX1_CTRL1_LOAD_EN,\n\t\t},\n\t\t{\n\t\t\t.reg = PCIE_PHY_TX2_CTRL1,\n\t\t\t.def = PCIE_PHY_TX2_CTRL1_LOAD_EN,\n\t\t},\n\t\t{\n\t\t\t.reg = PCIE_PHY_RX1_CTRL1,\n\t\t\t.def = PCIE_PHY_RX1_CTRL1_LOAD_EN,\n\t\t}\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(slices); i++) {\n\t\t \n\t\tregmap_update_bits(priv->phy_regmap, slices[i].reg,\n\t\t\t\t   slices[i].def, slices[i].def);\n\n\t\tudelay(1);\n\n\t\t \n\t\tregmap_update_bits(priv->phy_regmap, slices[i].reg,\n\t\t\t\t   slices[i].def, 0x0);\n\t}\n\n\tfor (i = 0; i < 5; i++) {\n\t\t \n\t\tregmap_write(priv->phy_regmap, PCIE_PHY_TX2_MOD1, 0x1ffe);\n\t\tregmap_write(priv->phy_regmap, PCIE_PHY_TX2_MOD2, 0xfffe);\n\t\tregmap_write(priv->phy_regmap, PCIE_PHY_TX2_MOD3, 0x0601);\n\t\tusleep_range(1000, 2000);\n\t\tregmap_write(priv->phy_regmap, PCIE_PHY_TX2_MOD3, 0x0001);\n\n\t\t \n\t\tregmap_write(priv->phy_regmap, PCIE_PHY_TX1_MOD1, 0x1ffe);\n\t\tregmap_write(priv->phy_regmap, PCIE_PHY_TX1_MOD2, 0xfffe);\n\t\tregmap_write(priv->phy_regmap, PCIE_PHY_TX1_MOD3, 0x0601);\n\t\tusleep_range(1000, 2000);\n\t\tregmap_write(priv->phy_regmap, PCIE_PHY_TX1_MOD3, 0x0001);\n\t}\n}\n\nstatic int ltq_vrx200_pcie_phy_init(struct phy *phy)\n{\n\tstruct ltq_vrx200_pcie_phy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tif (of_device_is_big_endian(priv->dev->of_node))\n\t\tregmap_update_bits(priv->rcu_regmap,\n\t\t\t\t   priv->rcu_ahb_endian_offset,\n\t\t\t\t   priv->rcu_ahb_endian_big_endian_mask,\n\t\t\t\t   priv->rcu_ahb_endian_big_endian_mask);\n\telse\n\t\tregmap_update_bits(priv->rcu_regmap,\n\t\t\t\t   priv->rcu_ahb_endian_offset,\n\t\t\t\t   priv->rcu_ahb_endian_big_endian_mask, 0x0);\n\n\tret = reset_control_assert(priv->phy_reset);\n\tif (ret)\n\t\tgoto err;\n\n\tudelay(1);\n\n\tret = reset_control_deassert(priv->phy_reset);\n\tif (ret)\n\t\tgoto err;\n\n\tudelay(1);\n\n\tret = reset_control_deassert(priv->pcie_reset);\n\tif (ret)\n\t\tgoto err_assert_phy_reset;\n\n\t \n\tusleep_range(20, 40);\n\n\treturn 0;\n\nerr_assert_phy_reset:\n\treset_control_assert(priv->phy_reset);\nerr:\n\treturn ret;\n}\n\nstatic int ltq_vrx200_pcie_phy_exit(struct phy *phy)\n{\n\tstruct ltq_vrx200_pcie_phy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = reset_control_assert(priv->pcie_reset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_assert(priv->phy_reset);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ltq_vrx200_pcie_phy_power_on(struct phy *phy)\n{\n\tstruct ltq_vrx200_pcie_phy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\t \n\tret = clk_prepare_enable(priv->pdi_clk);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tltq_vrx200_pcie_phy_common_setup(phy);\n\n\tpcie_phy_36mhz_mode_setup(phy);\n\n\t \n\tret = clk_prepare_enable(priv->phy_clk);\n\tif (ret)\n\t\tgoto err_disable_pdi_clk;\n\n\t \n\tret = ltq_vrx200_pcie_phy_wait_for_pll(phy);\n\tif (ret)\n\t\tgoto err_disable_phy_clk;\n\n\tltq_vrx200_pcie_phy_apply_workarounds(phy);\n\n\treturn 0;\n\nerr_disable_phy_clk:\n\tclk_disable_unprepare(priv->phy_clk);\nerr_disable_pdi_clk:\n\tclk_disable_unprepare(priv->pdi_clk);\nerr:\n\treturn ret;\n}\n\nstatic int ltq_vrx200_pcie_phy_power_off(struct phy *phy)\n{\n\tstruct ltq_vrx200_pcie_phy_priv *priv = phy_get_drvdata(phy);\n\n\tclk_disable_unprepare(priv->phy_clk);\n\tclk_disable_unprepare(priv->pdi_clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops ltq_vrx200_pcie_phy_ops = {\n\t.init\t\t= ltq_vrx200_pcie_phy_init,\n\t.exit\t\t= ltq_vrx200_pcie_phy_exit,\n\t.power_on\t= ltq_vrx200_pcie_phy_power_on,\n\t.power_off\t= ltq_vrx200_pcie_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *ltq_vrx200_pcie_phy_xlate(struct device *dev,\n\t\t\t\t\t     struct of_phandle_args *args)\n{\n\tstruct ltq_vrx200_pcie_phy_priv *priv = dev_get_drvdata(dev);\n\tunsigned int mode;\n\n\tif (args->args_count != 1) {\n\t\tdev_err(dev, \"invalid number of arguments\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmode = args->args[0];\n\n\tswitch (mode) {\n\tcase LANTIQ_PCIE_PHY_MODE_36MHZ:\n\t\tpriv->mode = mode;\n\t\tbreak;\n\n\tcase LANTIQ_PCIE_PHY_MODE_25MHZ:\n\tcase LANTIQ_PCIE_PHY_MODE_25MHZ_SSC:\n\tcase LANTIQ_PCIE_PHY_MODE_36MHZ_SSC:\n\tcase LANTIQ_PCIE_PHY_MODE_100MHZ:\n\tcase LANTIQ_PCIE_PHY_MODE_100MHZ_SSC:\n\t\tdev_err(dev, \"PHY mode not implemented yet: %u\\n\", mode);\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdefault:\n\t\tdev_err(dev, \"invalid PHY mode %u\\n\", mode);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn priv->phy;\n}\n\nstatic int ltq_vrx200_pcie_phy_probe(struct platform_device *pdev)\n{\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 16,\n\t\t.reg_stride = 2,\n\t\t.max_register = PCIE_PHY_RX1_A_CTRL,\n\t};\n\tstruct ltq_vrx200_pcie_phy_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *provider;\n\tvoid __iomem *base;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->phy_regmap = devm_regmap_init_mmio(dev, base, &regmap_config);\n\tif (IS_ERR(priv->phy_regmap))\n\t\treturn PTR_ERR(priv->phy_regmap);\n\n\tpriv->rcu_regmap = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t   \"lantiq,rcu\");\n\tif (IS_ERR(priv->rcu_regmap))\n\t\treturn PTR_ERR(priv->rcu_regmap);\n\n\tret = device_property_read_u32(dev, \"lantiq,rcu-endian-offset\",\n\t\t\t\t       &priv->rcu_ahb_endian_offset);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"failed to parse the 'lantiq,rcu-endian-offset' property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(dev, \"lantiq,rcu-big-endian-mask\",\n\t\t\t\t       &priv->rcu_ahb_endian_big_endian_mask);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"failed to parse the 'lantiq,rcu-big-endian-mask' property\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->pdi_clk = devm_clk_get(dev, \"pdi\");\n\tif (IS_ERR(priv->pdi_clk))\n\t\treturn PTR_ERR(priv->pdi_clk);\n\n\tpriv->phy_clk = devm_clk_get(dev, \"phy\");\n\tif (IS_ERR(priv->phy_clk))\n\t\treturn PTR_ERR(priv->phy_clk);\n\n\tpriv->phy_reset = devm_reset_control_get_exclusive(dev, \"phy\");\n\tif (IS_ERR(priv->phy_reset))\n\t\treturn PTR_ERR(priv->phy_reset);\n\n\tpriv->pcie_reset = devm_reset_control_get_shared(dev, \"pcie\");\n\tif (IS_ERR(priv->pcie_reset))\n\t\treturn PTR_ERR(priv->pcie_reset);\n\n\tpriv->dev = dev;\n\n\tpriv->phy = devm_phy_create(dev, dev->of_node,\n\t\t\t\t    &ltq_vrx200_pcie_phy_ops);\n\tif (IS_ERR(priv->phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(priv->phy);\n\t}\n\n\tphy_set_drvdata(priv->phy, priv);\n\tdev_set_drvdata(dev, priv);\n\n\tprovider = devm_of_phy_provider_register(dev,\n\t\t\t\t\t\t ltq_vrx200_pcie_phy_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic const struct of_device_id ltq_vrx200_pcie_phy_of_match[] = {\n\t{ .compatible = \"lantiq,vrx200-pcie-phy\", },\n\t{ .compatible = \"lantiq,arx300-pcie-phy\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ltq_vrx200_pcie_phy_of_match);\n\nstatic struct platform_driver ltq_vrx200_pcie_phy_driver = {\n\t.probe\t= ltq_vrx200_pcie_phy_probe,\n\t.driver = {\n\t\t.name\t= \"ltq-vrx200-pcie-phy\",\n\t\t.of_match_table\t= ltq_vrx200_pcie_phy_of_match,\n\t}\n};\nmodule_platform_driver(ltq_vrx200_pcie_phy_driver);\n\nMODULE_AUTHOR(\"Martin Blumenstingl <martin.blumenstingl@googlemail.com>\");\nMODULE_DESCRIPTION(\"Lantiq VRX200 and ARX300 PCIe PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}