{
  "module_name": "phy-lantiq-rcu-usb2.c",
  "hash_id": "bd3306fe81d8f1d41940df97153fd8aa94e598e8a433449525890b317d129270",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/lantiq/phy-lantiq-rcu-usb2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n \n#define RCU_CFG1_TX_PEE\t\tBIT(0)\n \n#define RCU_CFG1_DIS_THR_MASK\t0x00038000\n#define RCU_CFG1_DIS_THR_SHIFT\t15\n\nstruct ltq_rcu_usb2_bits {\n\tu8 hostmode;\n\tu8 slave_endianness;\n\tu8 host_endianness;\n\tbool have_ana_cfg;\n};\n\nstruct ltq_rcu_usb2_priv {\n\tstruct regmap\t\t\t*regmap;\n\tunsigned int\t\t\tphy_reg_offset;\n\tunsigned int\t\t\tana_cfg1_reg_offset;\n\tconst struct ltq_rcu_usb2_bits\t*reg_bits;\n\tstruct device\t\t\t*dev;\n\tstruct phy\t\t\t*phy;\n\tstruct clk\t\t\t*phy_gate_clk;\n\tstruct reset_control\t\t*ctrl_reset;\n\tstruct reset_control\t\t*phy_reset;\n};\n\nstatic const struct ltq_rcu_usb2_bits xway_rcu_usb2_reg_bits = {\n\t.hostmode = 11,\n\t.slave_endianness = 9,\n\t.host_endianness = 10,\n\t.have_ana_cfg = false,\n};\n\nstatic const struct ltq_rcu_usb2_bits xrx100_rcu_usb2_reg_bits = {\n\t.hostmode = 11,\n\t.slave_endianness = 17,\n\t.host_endianness = 10,\n\t.have_ana_cfg = false,\n};\n\nstatic const struct ltq_rcu_usb2_bits xrx200_rcu_usb2_reg_bits = {\n\t.hostmode = 11,\n\t.slave_endianness = 9,\n\t.host_endianness = 10,\n\t.have_ana_cfg = true,\n};\n\nstatic const struct of_device_id ltq_rcu_usb2_phy_of_match[] = {\n\t{\n\t\t.compatible = \"lantiq,ase-usb2-phy\",\n\t\t.data = &xway_rcu_usb2_reg_bits,\n\t},\n\t{\n\t\t.compatible = \"lantiq,danube-usb2-phy\",\n\t\t.data = &xway_rcu_usb2_reg_bits,\n\t},\n\t{\n\t\t.compatible = \"lantiq,xrx100-usb2-phy\",\n\t\t.data = &xrx100_rcu_usb2_reg_bits,\n\t},\n\t{\n\t\t.compatible = \"lantiq,xrx200-usb2-phy\",\n\t\t.data = &xrx200_rcu_usb2_reg_bits,\n\t},\n\t{\n\t\t.compatible = \"lantiq,xrx300-usb2-phy\",\n\t\t.data = &xrx200_rcu_usb2_reg_bits,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ltq_rcu_usb2_phy_of_match);\n\nstatic int ltq_rcu_usb2_phy_init(struct phy *phy)\n{\n\tstruct ltq_rcu_usb2_priv *priv = phy_get_drvdata(phy);\n\n\tif (priv->reg_bits->have_ana_cfg) {\n\t\tregmap_update_bits(priv->regmap, priv->ana_cfg1_reg_offset,\n\t\t\tRCU_CFG1_TX_PEE, RCU_CFG1_TX_PEE);\n\t\tregmap_update_bits(priv->regmap, priv->ana_cfg1_reg_offset,\n\t\t\tRCU_CFG1_DIS_THR_MASK, 7 << RCU_CFG1_DIS_THR_SHIFT);\n\t}\n\n\t \n\tregmap_update_bits(priv->regmap, priv->phy_reg_offset,\n\t\t\t   BIT(priv->reg_bits->hostmode), 0);\n\n\t \n\tregmap_update_bits(priv->regmap, priv->phy_reg_offset,\n\t\tBIT(priv->reg_bits->slave_endianness), 0);\n\tregmap_update_bits(priv->regmap, priv->phy_reg_offset,\n\t\tBIT(priv->reg_bits->host_endianness),\n\t\tBIT(priv->reg_bits->host_endianness));\n\n\treturn 0;\n}\n\nstatic int ltq_rcu_usb2_phy_power_on(struct phy *phy)\n{\n\tstruct ltq_rcu_usb2_priv *priv = phy_get_drvdata(phy);\n\tstruct device *dev = priv->dev;\n\tint ret;\n\n\treset_control_deassert(priv->phy_reset);\n\n\tret = clk_prepare_enable(priv->phy_gate_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable PHY gate\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tusleep_range(100, 200);\n\n\treturn ret;\n}\n\nstatic int ltq_rcu_usb2_phy_power_off(struct phy *phy)\n{\n\tstruct ltq_rcu_usb2_priv *priv = phy_get_drvdata(phy);\n\n\treset_control_assert(priv->phy_reset);\n\n\tclk_disable_unprepare(priv->phy_gate_clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops ltq_rcu_usb2_phy_ops = {\n\t.init\t\t= ltq_rcu_usb2_phy_init,\n\t.power_on\t= ltq_rcu_usb2_phy_power_on,\n\t.power_off\t= ltq_rcu_usb2_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int ltq_rcu_usb2_of_parse(struct ltq_rcu_usb2_priv *priv,\n\t\t\t\t struct platform_device *pdev)\n{\n\tstruct device *dev = priv->dev;\n\tconst __be32 *offset;\n\n\tpriv->reg_bits = of_device_get_match_data(dev);\n\n\tpriv->regmap = syscon_node_to_regmap(dev->of_node->parent);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(dev, \"Failed to lookup RCU regmap\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\toffset = of_get_address(dev->of_node, 0, NULL, NULL);\n\tif (!offset) {\n\t\tdev_err(dev, \"Failed to get RCU PHY reg offset\\n\");\n\t\treturn -ENOENT;\n\t}\n\tpriv->phy_reg_offset = __be32_to_cpu(*offset);\n\n\tif (priv->reg_bits->have_ana_cfg) {\n\t\toffset = of_get_address(dev->of_node, 1, NULL, NULL);\n\t\tif (!offset) {\n\t\t\tdev_err(dev, \"Failed to get RCU ANA CFG1 reg offset\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tpriv->ana_cfg1_reg_offset = __be32_to_cpu(*offset);\n\t}\n\n\tpriv->phy_gate_clk = devm_clk_get(dev, \"phy\");\n\tif (IS_ERR(priv->phy_gate_clk)) {\n\t\tdev_err(dev, \"Unable to get USB phy gate clk\\n\");\n\t\treturn PTR_ERR(priv->phy_gate_clk);\n\t}\n\n\tpriv->ctrl_reset = devm_reset_control_get_shared(dev, \"ctrl\");\n\tif (IS_ERR(priv->ctrl_reset)) {\n\t\tif (PTR_ERR(priv->ctrl_reset) != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"failed to get 'ctrl' reset\\n\");\n\t\treturn PTR_ERR(priv->ctrl_reset);\n\t}\n\n\tpriv->phy_reset = devm_reset_control_get_optional(dev, \"phy\");\n\n\treturn PTR_ERR_OR_ZERO(priv->phy_reset);\n}\n\nstatic int ltq_rcu_usb2_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ltq_rcu_usb2_priv *priv;\n\tstruct phy_provider *provider;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\n\tret = ltq_rcu_usb2_of_parse(priv, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treset_control_deassert(priv->ctrl_reset);\n\n\treset_control_assert(priv->phy_reset);\n\n\tpriv->phy = devm_phy_create(dev, dev->of_node, &ltq_rcu_usb2_phy_ops);\n\tif (IS_ERR(priv->phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(priv->phy);\n\t}\n\n\tphy_set_drvdata(priv->phy, priv);\n\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(provider))\n\t\treturn PTR_ERR(provider);\n\n\tdev_set_drvdata(priv->dev, priv);\n\treturn 0;\n}\n\nstatic struct platform_driver ltq_rcu_usb2_phy_driver = {\n\t.probe\t= ltq_rcu_usb2_phy_probe,\n\t.driver = {\n\t\t.name\t= \"lantiq-rcu-usb2-phy\",\n\t\t.of_match_table\t= ltq_rcu_usb2_phy_of_match,\n\t}\n};\nmodule_platform_driver(ltq_rcu_usb2_phy_driver);\n\nMODULE_AUTHOR(\"Martin Blumenstingl <martin.blumenstingl@googlemail.com>\");\nMODULE_DESCRIPTION(\"Lantiq XWAY USB2 PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}