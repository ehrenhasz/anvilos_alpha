{
  "module_name": "phy-exynos5250-sata.c",
  "hash_id": "79c4078ba3b08d11a775b14c178c73f2a06207f0a37c63d531ce43c93b37d857",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/samsung/phy-exynos5250-sata.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n#include <linux/mfd/syscon.h>\n\n#define SATAPHY_CONTROL_OFFSET\t\t0x0724\n#define EXYNOS5_SATAPHY_PMU_ENABLE\tBIT(0)\n#define EXYNOS5_SATA_RESET\t\t0x4\n#define RESET_GLOBAL_RST_N\t\tBIT(0)\n#define RESET_CMN_RST_N\t\t\tBIT(1)\n#define RESET_CMN_BLOCK_RST_N\t\tBIT(2)\n#define RESET_CMN_I2C_RST_N\t\tBIT(3)\n#define RESET_TX_RX_PIPE_RST_N\t\tBIT(4)\n#define RESET_TX_RX_BLOCK_RST_N\t\tBIT(5)\n#define RESET_TX_RX_I2C_RST_N\t\t(BIT(6) | BIT(7))\n#define LINK_RESET\t\t\t0xf0000\n#define EXYNOS5_SATA_MODE0\t\t0x10\n#define SATA_SPD_GEN3\t\t\tBIT(1)\n#define EXYNOS5_SATA_CTRL0\t\t0x14\n#define CTRL0_P0_PHY_CALIBRATED_SEL\tBIT(9)\n#define CTRL0_P0_PHY_CALIBRATED\t\tBIT(8)\n#define EXYNOS5_SATA_PHSATA_CTRLM\t0xe0\n#define PHCTRLM_REF_RATE\t\tBIT(1)\n#define PHCTRLM_HIGH_SPEED\t\tBIT(0)\n#define EXYNOS5_SATA_PHSATA_STATM\t0xf0\n#define PHSTATM_PLL_LOCKED\t\tBIT(0)\n\n#define PHY_PLL_TIMEOUT (usecs_to_jiffies(1000))\n\nstruct exynos_sata_phy {\n\tstruct phy *phy;\n\tstruct clk *phyclk;\n\tvoid __iomem *regs;\n\tstruct regmap *pmureg;\n\tstruct i2c_client *client;\n};\n\nstatic int wait_for_reg_status(void __iomem *base, u32 reg, u32 checkbit,\n\t\t\t\tu32 status)\n{\n\tunsigned long timeout = jiffies + PHY_PLL_TIMEOUT;\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tif ((readl(base + reg) & checkbit) == status)\n\t\t\treturn 0;\n\t}\n\n\treturn -EFAULT;\n}\n\nstatic int exynos_sata_phy_power_on(struct phy *phy)\n{\n\tstruct exynos_sata_phy *sata_phy = phy_get_drvdata(phy);\n\n\treturn regmap_update_bits(sata_phy->pmureg, SATAPHY_CONTROL_OFFSET,\n\t\t\tEXYNOS5_SATAPHY_PMU_ENABLE, true);\n\n}\n\nstatic int exynos_sata_phy_power_off(struct phy *phy)\n{\n\tstruct exynos_sata_phy *sata_phy = phy_get_drvdata(phy);\n\n\treturn regmap_update_bits(sata_phy->pmureg, SATAPHY_CONTROL_OFFSET,\n\t\t\tEXYNOS5_SATAPHY_PMU_ENABLE, false);\n\n}\n\nstatic int exynos_sata_phy_init(struct phy *phy)\n{\n\tu32 val = 0;\n\tint ret = 0;\n\tu8 buf[] = { 0x3a, 0x0b };\n\tstruct exynos_sata_phy *sata_phy = phy_get_drvdata(phy);\n\n\tret = regmap_update_bits(sata_phy->pmureg, SATAPHY_CONTROL_OFFSET,\n\t\t\tEXYNOS5_SATAPHY_PMU_ENABLE, true);\n\tif (ret != 0)\n\t\tdev_err(&sata_phy->phy->dev, \"phy init failed\\n\");\n\n\twritel(val, sata_phy->regs + EXYNOS5_SATA_RESET);\n\n\tval = readl(sata_phy->regs + EXYNOS5_SATA_RESET);\n\tval |= RESET_GLOBAL_RST_N | RESET_CMN_RST_N | RESET_CMN_BLOCK_RST_N\n\t\t| RESET_CMN_I2C_RST_N | RESET_TX_RX_PIPE_RST_N\n\t\t| RESET_TX_RX_BLOCK_RST_N | RESET_TX_RX_I2C_RST_N;\n\twritel(val, sata_phy->regs + EXYNOS5_SATA_RESET);\n\n\tval = readl(sata_phy->regs + EXYNOS5_SATA_RESET);\n\tval |= LINK_RESET;\n\twritel(val, sata_phy->regs + EXYNOS5_SATA_RESET);\n\n\tval = readl(sata_phy->regs + EXYNOS5_SATA_RESET);\n\tval |= RESET_CMN_RST_N;\n\twritel(val, sata_phy->regs + EXYNOS5_SATA_RESET);\n\n\tval = readl(sata_phy->regs + EXYNOS5_SATA_PHSATA_CTRLM);\n\tval &= ~PHCTRLM_REF_RATE;\n\twritel(val, sata_phy->regs + EXYNOS5_SATA_PHSATA_CTRLM);\n\n\t \n\tval = readl(sata_phy->regs + EXYNOS5_SATA_PHSATA_CTRLM);\n\tval |= PHCTRLM_HIGH_SPEED;\n\twritel(val, sata_phy->regs + EXYNOS5_SATA_PHSATA_CTRLM);\n\n\tval = readl(sata_phy->regs + EXYNOS5_SATA_CTRL0);\n\tval |= CTRL0_P0_PHY_CALIBRATED_SEL | CTRL0_P0_PHY_CALIBRATED;\n\twritel(val, sata_phy->regs + EXYNOS5_SATA_CTRL0);\n\n\tval = readl(sata_phy->regs + EXYNOS5_SATA_MODE0);\n\tval |= SATA_SPD_GEN3;\n\twritel(val, sata_phy->regs + EXYNOS5_SATA_MODE0);\n\n\tret = i2c_master_send(sata_phy->client, buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval = readl(sata_phy->regs + EXYNOS5_SATA_RESET);\n\tval &= ~RESET_CMN_RST_N;\n\twritel(val, sata_phy->regs + EXYNOS5_SATA_RESET);\n\n\tval = readl(sata_phy->regs + EXYNOS5_SATA_RESET);\n\tval |= RESET_CMN_RST_N;\n\twritel(val, sata_phy->regs + EXYNOS5_SATA_RESET);\n\n\tret = wait_for_reg_status(sata_phy->regs,\n\t\t\t\tEXYNOS5_SATA_PHSATA_STATM,\n\t\t\t\tPHSTATM_PLL_LOCKED, 1);\n\tif (ret < 0)\n\t\tdev_err(&sata_phy->phy->dev,\n\t\t\t\"PHY PLL locking failed\\n\");\n\treturn ret;\n}\n\nstatic const struct phy_ops exynos_sata_phy_ops = {\n\t.init\t\t= exynos_sata_phy_init,\n\t.power_on\t= exynos_sata_phy_power_on,\n\t.power_off\t= exynos_sata_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int exynos_sata_phy_probe(struct platform_device *pdev)\n{\n\tstruct exynos_sata_phy *sata_phy;\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *phy_provider;\n\tstruct device_node *node;\n\tint ret = 0;\n\n\tsata_phy = devm_kzalloc(dev, sizeof(*sata_phy), GFP_KERNEL);\n\tif (!sata_phy)\n\t\treturn -ENOMEM;\n\n\tsata_phy->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sata_phy->regs))\n\t\treturn PTR_ERR(sata_phy->regs);\n\n\tsata_phy->pmureg = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\"samsung,syscon-phandle\");\n\tif (IS_ERR(sata_phy->pmureg)) {\n\t\tdev_err(dev, \"syscon regmap lookup failed.\\n\");\n\t\treturn PTR_ERR(sata_phy->pmureg);\n\t}\n\n\tnode = of_parse_phandle(dev->of_node,\n\t\t\t\"samsung,exynos-sataphy-i2c-phandle\", 0);\n\tif (!node)\n\t\treturn -EINVAL;\n\n\tsata_phy->client = of_find_i2c_device_by_node(node);\n\tof_node_put(node);\n\tif (!sata_phy->client)\n\t\treturn -EPROBE_DEFER;\n\n\tdev_set_drvdata(dev, sata_phy);\n\n\tsata_phy->phyclk = devm_clk_get(dev, \"sata_phyctrl\");\n\tif (IS_ERR(sata_phy->phyclk)) {\n\t\tdev_err(dev, \"failed to get clk for PHY\\n\");\n\t\tret = PTR_ERR(sata_phy->phyclk);\n\t\tgoto put_dev;\n\t}\n\n\tret = clk_prepare_enable(sata_phy->phyclk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable source clk\\n\");\n\t\tgoto put_dev;\n\t}\n\n\tsata_phy->phy = devm_phy_create(dev, NULL, &exynos_sata_phy_ops);\n\tif (IS_ERR(sata_phy->phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\tret = PTR_ERR(sata_phy->phy);\n\t\tgoto clk_disable;\n\t}\n\n\tphy_set_drvdata(sata_phy->phy, sata_phy);\n\n\tphy_provider = devm_of_phy_provider_register(dev,\n\t\t\t\t\tof_phy_simple_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tret = PTR_ERR(phy_provider);\n\t\tgoto clk_disable;\n\t}\n\n\treturn 0;\n\nclk_disable:\n\tclk_disable_unprepare(sata_phy->phyclk);\nput_dev:\n\tput_device(&sata_phy->client->dev);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id exynos_sata_phy_of_match[] = {\n\t{ .compatible = \"samsung,exynos5250-sata-phy\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, exynos_sata_phy_of_match);\n\nstatic struct platform_driver exynos_sata_phy_driver = {\n\t.probe\t= exynos_sata_phy_probe,\n\t.driver = {\n\t\t.of_match_table\t= exynos_sata_phy_of_match,\n\t\t.name  = \"samsung,sata-phy\",\n\t\t.suppress_bind_attrs = true,\n\t}\n};\nmodule_platform_driver(exynos_sata_phy_driver);\n\nMODULE_DESCRIPTION(\"Samsung SerDes PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Girish K S <ks.giri@samsung.com>\");\nMODULE_AUTHOR(\"Yuvaraj C D <yuvaraj.cd@samsung.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}