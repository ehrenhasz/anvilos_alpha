{
  "module_name": "phy-samsung-usb2.c",
  "hash_id": "bf71f298de50dc9fc5eb5c0099281daab4511e3a267f2feb2d94a916a51eb5b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/samsung/phy-samsung-usb2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include \"phy-samsung-usb2.h\"\n\nstatic int samsung_usb2_phy_power_on(struct phy *phy)\n{\n\tstruct samsung_usb2_phy_instance *inst = phy_get_drvdata(phy);\n\tstruct samsung_usb2_phy_driver *drv = inst->drv;\n\tint ret;\n\n\tdev_dbg(drv->dev, \"Request to power_on \\\"%s\\\" usb phy\\n\",\n\t\tinst->cfg->label);\n\n\tif (drv->vbus) {\n\t\tret = regulator_enable(drv->vbus);\n\t\tif (ret)\n\t\t\tgoto err_regulator;\n\t}\n\n\tret = clk_prepare_enable(drv->clk);\n\tif (ret)\n\t\tgoto err_main_clk;\n\tret = clk_prepare_enable(drv->ref_clk);\n\tif (ret)\n\t\tgoto err_instance_clk;\n\tif (inst->cfg->power_on) {\n\t\tspin_lock(&drv->lock);\n\t\tret = inst->cfg->power_on(inst);\n\t\tspin_unlock(&drv->lock);\n\t\tif (ret)\n\t\t\tgoto err_power_on;\n\t}\n\n\treturn 0;\n\nerr_power_on:\n\tclk_disable_unprepare(drv->ref_clk);\nerr_instance_clk:\n\tclk_disable_unprepare(drv->clk);\nerr_main_clk:\n\tif (drv->vbus)\n\t\tregulator_disable(drv->vbus);\nerr_regulator:\n\treturn ret;\n}\n\nstatic int samsung_usb2_phy_power_off(struct phy *phy)\n{\n\tstruct samsung_usb2_phy_instance *inst = phy_get_drvdata(phy);\n\tstruct samsung_usb2_phy_driver *drv = inst->drv;\n\tint ret = 0;\n\n\tdev_dbg(drv->dev, \"Request to power_off \\\"%s\\\" usb phy\\n\",\n\t\tinst->cfg->label);\n\tif (inst->cfg->power_off) {\n\t\tspin_lock(&drv->lock);\n\t\tret = inst->cfg->power_off(inst);\n\t\tspin_unlock(&drv->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tclk_disable_unprepare(drv->ref_clk);\n\tclk_disable_unprepare(drv->clk);\n\tif (drv->vbus)\n\t\tret = regulator_disable(drv->vbus);\n\n\treturn ret;\n}\n\nstatic const struct phy_ops samsung_usb2_phy_ops = {\n\t.power_on\t= samsung_usb2_phy_power_on,\n\t.power_off\t= samsung_usb2_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *samsung_usb2_phy_xlate(struct device *dev,\n\t\t\t\t\tstruct of_phandle_args *args)\n{\n\tstruct samsung_usb2_phy_driver *drv;\n\n\tdrv = dev_get_drvdata(dev);\n\tif (!drv)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (WARN_ON(args->args[0] >= drv->cfg->num_phys))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn drv->instances[args->args[0]].phy;\n}\n\nstatic const struct of_device_id samsung_usb2_phy_of_match[] = {\n#ifdef CONFIG_PHY_EXYNOS4X12_USB2\n\t{\n\t\t.compatible = \"samsung,exynos3250-usb2-phy\",\n\t\t.data = &exynos3250_usb2_phy_config,\n\t},\n#endif\n#ifdef CONFIG_PHY_EXYNOS4210_USB2\n\t{\n\t\t.compatible = \"samsung,exynos4210-usb2-phy\",\n\t\t.data = &exynos4210_usb2_phy_config,\n\t},\n#endif\n#ifdef CONFIG_PHY_EXYNOS4X12_USB2\n\t{\n\t\t.compatible = \"samsung,exynos4x12-usb2-phy\",\n\t\t.data = &exynos4x12_usb2_phy_config,\n\t},\n#endif\n#ifdef CONFIG_PHY_EXYNOS5250_USB2\n\t{\n\t\t.compatible = \"samsung,exynos5250-usb2-phy\",\n\t\t.data = &exynos5250_usb2_phy_config,\n\t},\n\t{\n\t\t.compatible = \"samsung,exynos5420-usb2-phy\",\n\t\t.data = &exynos5420_usb2_phy_config,\n\t},\n#endif\n#ifdef CONFIG_PHY_S5PV210_USB2\n\t{\n\t\t.compatible = \"samsung,s5pv210-usb2-phy\",\n\t\t.data = &s5pv210_usb2_phy_config,\n\t},\n#endif\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, samsung_usb2_phy_of_match);\n\nstatic int samsung_usb2_phy_probe(struct platform_device *pdev)\n{\n\tconst struct samsung_usb2_phy_config *cfg;\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *phy_provider;\n\tstruct samsung_usb2_phy_driver *drv;\n\tint i, ret;\n\n\tif (!pdev->dev.of_node) {\n\t\tdev_err(dev, \"This driver is required to be instantiated from device tree\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcfg = of_device_get_match_data(dev);\n\tif (!cfg)\n\t\treturn -EINVAL;\n\n\tdrv = devm_kzalloc(dev, struct_size(drv, instances, cfg->num_phys),\n\t\t\t   GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, drv);\n\tspin_lock_init(&drv->lock);\n\n\tdrv->cfg = cfg;\n\tdrv->dev = dev;\n\n\tdrv->reg_phy = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(drv->reg_phy)) {\n\t\tdev_err(dev, \"Failed to map register memory (phy)\\n\");\n\t\treturn PTR_ERR(drv->reg_phy);\n\t}\n\n\tdrv->reg_pmu = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\"samsung,pmureg-phandle\");\n\tif (IS_ERR(drv->reg_pmu)) {\n\t\tdev_err(dev, \"Failed to map PMU registers (via syscon)\\n\");\n\t\treturn PTR_ERR(drv->reg_pmu);\n\t}\n\n\tif (drv->cfg->has_mode_switch) {\n\t\tdrv->reg_sys = syscon_regmap_lookup_by_phandle(\n\t\t\t\tpdev->dev.of_node, \"samsung,sysreg-phandle\");\n\t\tif (IS_ERR(drv->reg_sys)) {\n\t\t\tdev_err(dev, \"Failed to map system registers (via syscon)\\n\");\n\t\t\treturn PTR_ERR(drv->reg_sys);\n\t\t}\n\t}\n\n\tdrv->clk = devm_clk_get(dev, \"phy\");\n\tif (IS_ERR(drv->clk)) {\n\t\tdev_err(dev, \"Failed to get clock of phy controller\\n\");\n\t\treturn PTR_ERR(drv->clk);\n\t}\n\n\tdrv->ref_clk = devm_clk_get(dev, \"ref\");\n\tif (IS_ERR(drv->ref_clk)) {\n\t\tdev_err(dev, \"Failed to get reference clock for the phy controller\\n\");\n\t\treturn PTR_ERR(drv->ref_clk);\n\t}\n\n\tdrv->ref_rate = clk_get_rate(drv->ref_clk);\n\tif (drv->cfg->rate_to_clk) {\n\t\tret = drv->cfg->rate_to_clk(drv->ref_rate, &drv->ref_reg_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdrv->vbus = devm_regulator_get(dev, \"vbus\");\n\tif (IS_ERR(drv->vbus)) {\n\t\tret = PTR_ERR(drv->vbus);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t\tdrv->vbus = NULL;\n\t}\n\n\tfor (i = 0; i < drv->cfg->num_phys; i++) {\n\t\tchar *label = drv->cfg->phys[i].label;\n\t\tstruct samsung_usb2_phy_instance *p = &drv->instances[i];\n\n\t\tdev_dbg(dev, \"Creating phy \\\"%s\\\"\\n\", label);\n\t\tp->phy = devm_phy_create(dev, NULL, &samsung_usb2_phy_ops);\n\t\tif (IS_ERR(p->phy)) {\n\t\t\tdev_err(drv->dev, \"Failed to create usb2_phy \\\"%s\\\"\\n\",\n\t\t\t\tlabel);\n\t\t\treturn PTR_ERR(p->phy);\n\t\t}\n\n\t\tp->cfg = &drv->cfg->phys[i];\n\t\tp->drv = drv;\n\t\tphy_set_bus_width(p->phy, 8);\n\t\tphy_set_drvdata(p->phy, p);\n\t}\n\n\tphy_provider = devm_of_phy_provider_register(dev,\n\t\t\t\t\t\t\tsamsung_usb2_phy_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tdev_err(drv->dev, \"Failed to register phy provider\\n\");\n\t\treturn PTR_ERR(phy_provider);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver samsung_usb2_phy_driver = {\n\t.probe\t= samsung_usb2_phy_probe,\n\t.driver = {\n\t\t.of_match_table\t= samsung_usb2_phy_of_match,\n\t\t.name\t\t= \"samsung-usb2-phy\",\n\t\t.suppress_bind_attrs = true,\n\t}\n};\n\nmodule_platform_driver(samsung_usb2_phy_driver);\nMODULE_DESCRIPTION(\"Samsung S5P/Exynos SoC USB PHY driver\");\nMODULE_AUTHOR(\"Kamil Debski <k.debski@samsung.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:samsung-usb2-phy\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}