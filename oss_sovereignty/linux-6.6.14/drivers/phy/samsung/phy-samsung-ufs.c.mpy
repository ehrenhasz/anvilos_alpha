{
  "module_name": "phy-samsung-ufs.c",
  "hash_id": "2c7eb4bcf34a43997df2e96c0592fa66dc1fab83ec7c484aaa31ae3477a36df5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/samsung/phy-samsung-ufs.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include \"phy-samsung-ufs.h\"\n\n#define for_each_phy_lane(phy, i) \\\n\tfor (i = 0; i < (phy)->lane_cnt; i++)\n#define for_each_phy_cfg(cfg) \\\n\tfor (; (cfg)->id; (cfg)++)\n\n#define PHY_DEF_LANE_CNT\t1\n\nstatic void samsung_ufs_phy_config(struct samsung_ufs_phy *phy,\n\t\t\t\t   const struct samsung_ufs_phy_cfg *cfg,\n\t\t\t\t   u8 lane)\n{\n\tenum {LANE_0, LANE_1};  \n\n\tswitch (lane) {\n\tcase LANE_0:\n\t\twritel(cfg->val, (phy)->reg_pma + cfg->off_0);\n\t\tbreak;\n\tcase LANE_1:\n\t\tif (cfg->id == PHY_TRSV_BLK)\n\t\t\twritel(cfg->val, (phy)->reg_pma + cfg->off_1);\n\t\tbreak;\n\t}\n}\n\nstatic int samsung_ufs_phy_wait_for_lock_acq(struct phy *phy)\n{\n\tstruct samsung_ufs_phy *ufs_phy = get_samsung_ufs_phy(phy);\n\tconst unsigned int timeout_us = 100000;\n\tconst unsigned int sleep_us = 10;\n\tu32 val;\n\tint err;\n\n\terr = readl_poll_timeout(\n\t\t\tufs_phy->reg_pma + PHY_APB_ADDR(PHY_PLL_LOCK_STATUS),\n\t\t\tval, (val & PHY_PLL_LOCK_BIT), sleep_us, timeout_us);\n\tif (err) {\n\t\tdev_err(ufs_phy->dev,\n\t\t\t\"failed to get phy pll lock acquisition %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\terr = readl_poll_timeout(\n\t\t\tufs_phy->reg_pma +\n\t\t\tPHY_APB_ADDR(ufs_phy->drvdata->cdr_lock_status_offset),\n\t\t\tval, (val & PHY_CDR_LOCK_BIT), sleep_us, timeout_us);\n\tif (err)\n\t\tdev_err(ufs_phy->dev,\n\t\t\t\"failed to get phy cdr lock acquisition %d\\n\", err);\nout:\n\treturn err;\n}\n\nstatic int samsung_ufs_phy_calibrate(struct phy *phy)\n{\n\tstruct samsung_ufs_phy *ufs_phy = get_samsung_ufs_phy(phy);\n\tconst struct samsung_ufs_phy_cfg * const *cfgs = ufs_phy->cfgs;\n\tconst struct samsung_ufs_phy_cfg *cfg;\n\tint err = 0;\n\tint i;\n\n\tif (unlikely(ufs_phy->ufs_phy_state < CFG_PRE_INIT ||\n\t\t     ufs_phy->ufs_phy_state >= CFG_TAG_MAX)) {\n\t\tdev_err(ufs_phy->dev, \"invalid phy config index %d\\n\", ufs_phy->ufs_phy_state);\n\t\treturn -EINVAL;\n\t}\n\n\tcfg = cfgs[ufs_phy->ufs_phy_state];\n\tif (!cfg)\n\t\tgoto out;\n\n\tfor_each_phy_cfg(cfg) {\n\t\tfor_each_phy_lane(ufs_phy, i) {\n\t\t\tsamsung_ufs_phy_config(ufs_phy, cfg, i);\n\t\t}\n\t}\n\n\tif (ufs_phy->ufs_phy_state == CFG_POST_PWR_HS)\n\t\terr = samsung_ufs_phy_wait_for_lock_acq(phy);\n\n\t \nout:\n\tswitch (ufs_phy->ufs_phy_state) {\n\tcase CFG_PRE_INIT:\n\t\tufs_phy->ufs_phy_state = CFG_POST_INIT;\n\t\tbreak;\n\tcase CFG_POST_INIT:\n\t\tufs_phy->ufs_phy_state = CFG_PRE_PWR_HS;\n\t\tbreak;\n\tcase CFG_PRE_PWR_HS:\n\t\tufs_phy->ufs_phy_state = CFG_POST_PWR_HS;\n\t\tbreak;\n\tcase CFG_POST_PWR_HS:\n\t\t \n\t\tufs_phy->ufs_phy_state = CFG_PRE_INIT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ufs_phy->dev, \"wrong state for phy calibration\\n\");\n\t}\n\n\treturn err;\n}\n\nstatic int samsung_ufs_phy_clks_init(struct samsung_ufs_phy *phy)\n{\n\tint i;\n\tconst struct samsung_ufs_phy_drvdata *drvdata = phy->drvdata;\n\tint num_clks = drvdata->num_clks;\n\n\tphy->clks = devm_kcalloc(phy->dev, num_clks, sizeof(*phy->clks),\n\t\t\t\t GFP_KERNEL);\n\tif (!phy->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_clks; i++)\n\t\tphy->clks[i].id = drvdata->clk_list[i];\n\n\treturn devm_clk_bulk_get(phy->dev, num_clks, phy->clks);\n}\n\nstatic int samsung_ufs_phy_init(struct phy *phy)\n{\n\tstruct samsung_ufs_phy *ss_phy = get_samsung_ufs_phy(phy);\n\n\tss_phy->lane_cnt = phy->attrs.bus_width;\n\tss_phy->ufs_phy_state = CFG_PRE_INIT;\n\n\treturn 0;\n}\n\nstatic int samsung_ufs_phy_power_on(struct phy *phy)\n{\n\tstruct samsung_ufs_phy *ss_phy = get_samsung_ufs_phy(phy);\n\tint ret;\n\n\tsamsung_ufs_phy_ctrl_isol(ss_phy, false);\n\n\tret = clk_bulk_prepare_enable(ss_phy->drvdata->num_clks, ss_phy->clks);\n\tif (ret) {\n\t\tdev_err(ss_phy->dev, \"failed to enable ufs phy clocks\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ss_phy->ufs_phy_state == CFG_PRE_INIT) {\n\t\tret = samsung_ufs_phy_calibrate(phy);\n\t\tif (ret)\n\t\t\tdev_err(ss_phy->dev, \"ufs phy calibration failed\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int samsung_ufs_phy_power_off(struct phy *phy)\n{\n\tstruct samsung_ufs_phy *ss_phy = get_samsung_ufs_phy(phy);\n\n\tclk_bulk_disable_unprepare(ss_phy->drvdata->num_clks, ss_phy->clks);\n\n\tsamsung_ufs_phy_ctrl_isol(ss_phy, true);\n\n\treturn 0;\n}\n\nstatic int samsung_ufs_phy_set_mode(struct phy *generic_phy,\n\t\t\t\t    enum phy_mode mode, int submode)\n{\n\tstruct samsung_ufs_phy *ss_phy = get_samsung_ufs_phy(generic_phy);\n\n\tss_phy->mode = PHY_MODE_INVALID;\n\n\tif (mode > 0)\n\t\tss_phy->mode = mode;\n\n\treturn 0;\n}\n\nstatic int samsung_ufs_phy_exit(struct phy *phy)\n{\n\tstruct samsung_ufs_phy *ss_phy = get_samsung_ufs_phy(phy);\n\n\tss_phy->ufs_phy_state = CFG_TAG_MAX;\n\n\treturn 0;\n}\n\nstatic const struct phy_ops samsung_ufs_phy_ops = {\n\t.init\t\t= samsung_ufs_phy_init,\n\t.exit\t\t= samsung_ufs_phy_exit,\n\t.power_on\t= samsung_ufs_phy_power_on,\n\t.power_off\t= samsung_ufs_phy_power_off,\n\t.calibrate\t= samsung_ufs_phy_calibrate,\n\t.set_mode\t= samsung_ufs_phy_set_mode,\n\t.owner          = THIS_MODULE,\n};\n\nstatic const struct of_device_id samsung_ufs_phy_match[];\n\nstatic int samsung_ufs_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *match;\n\tstruct samsung_ufs_phy *phy;\n\tstruct phy *gen_phy;\n\tstruct phy_provider *phy_provider;\n\tconst struct samsung_ufs_phy_drvdata *drvdata;\n\tu32 isol_offset;\n\tint err = 0;\n\n\tmatch = of_match_node(samsung_ufs_phy_match, dev->of_node);\n\tif (!match) {\n\t\terr = -EINVAL;\n\t\tdev_err(dev, \"failed to get match_node\\n\");\n\t\tgoto out;\n\t}\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tphy->reg_pma = devm_platform_ioremap_resource_byname(pdev, \"phy-pma\");\n\tif (IS_ERR(phy->reg_pma)) {\n\t\terr = PTR_ERR(phy->reg_pma);\n\t\tgoto out;\n\t}\n\n\tphy->reg_pmu = syscon_regmap_lookup_by_phandle(\n\t\t\t\tdev->of_node, \"samsung,pmu-syscon\");\n\tif (IS_ERR(phy->reg_pmu)) {\n\t\terr = PTR_ERR(phy->reg_pmu);\n\t\tdev_err(dev, \"failed syscon remap for pmu\\n\");\n\t\tgoto out;\n\t}\n\n\tgen_phy = devm_phy_create(dev, NULL, &samsung_ufs_phy_ops);\n\tif (IS_ERR(gen_phy)) {\n\t\terr = PTR_ERR(gen_phy);\n\t\tdev_err(dev, \"failed to create PHY for ufs-phy\\n\");\n\t\tgoto out;\n\t}\n\n\tdrvdata = match->data;\n\tphy->dev = dev;\n\tphy->drvdata = drvdata;\n\tphy->cfgs = drvdata->cfgs;\n\tmemcpy(&phy->isol, &drvdata->isol, sizeof(phy->isol));\n\n\tif (!of_property_read_u32_index(dev->of_node, \"samsung,pmu-syscon\", 1,\n\t\t\t\t\t&isol_offset))\n\t\tphy->isol.offset = isol_offset;\n\n\tphy->lane_cnt = PHY_DEF_LANE_CNT;\n\n\terr = samsung_ufs_phy_clks_init(phy);\n\tif (err) {\n\t\tdev_err(dev, \"failed to get phy clocks\\n\");\n\t\tgoto out;\n\t}\n\n\tphy_set_drvdata(gen_phy, phy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\terr = PTR_ERR(phy_provider);\n\t\tdev_err(dev, \"failed to register phy-provider\\n\");\n\t\tgoto out;\n\t}\nout:\n\treturn err;\n}\n\nstatic const struct of_device_id samsung_ufs_phy_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos7-ufs-phy\",\n\t\t.data = &exynos7_ufs_phy,\n\t}, {\n\t\t.compatible = \"samsung,exynosautov9-ufs-phy\",\n\t\t.data = &exynosautov9_ufs_phy,\n\t}, {\n\t\t.compatible = \"tesla,fsd-ufs-phy\",\n\t\t.data = &fsd_ufs_phy,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, samsung_ufs_phy_match);\n\nstatic struct platform_driver samsung_ufs_phy_driver = {\n\t.probe  = samsung_ufs_phy_probe,\n\t.driver = {\n\t\t.name = \"samsung-ufs-phy\",\n\t\t.of_match_table = samsung_ufs_phy_match,\n\t},\n};\nmodule_platform_driver(samsung_ufs_phy_driver);\nMODULE_DESCRIPTION(\"Samsung SoC UFS PHY Driver\");\nMODULE_AUTHOR(\"Seungwon Jeon <essuuj@gmail.com>\");\nMODULE_AUTHOR(\"Alim Akhtar <alim.akhtar@samsung.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}