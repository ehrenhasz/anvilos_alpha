{
  "module_name": "phy-exynos-pcie.c",
  "hash_id": "227f12b8f965936288a1a1e577be19c310aa6b1512cbaf4378ea0fa890cb33f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/samsung/phy-exynos-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n#include <linux/regmap.h>\n\n#define PCIE_PHY_OFFSET(x)\t\t((x) * 0x4)\n\n \n#define PCIE_EXYNOS5433_PHY_MAC_RESET\t\t0x0208\n#define PCIE_MAC_RESET_MASK\t\t\t0xFF\n#define PCIE_MAC_RESET\t\t\t\tBIT(4)\n#define PCIE_EXYNOS5433_PHY_L1SUB_CM_CON\t0x1010\n#define PCIE_REFCLK_GATING_EN\t\t\tBIT(0)\n#define PCIE_EXYNOS5433_PHY_COMMON_RESET\t0x1020\n#define PCIE_PHY_RESET\t\t\t\tBIT(0)\n#define PCIE_EXYNOS5433_PHY_GLOBAL_RESET\t0x1040\n#define PCIE_GLOBAL_RESET\t\t\tBIT(0)\n#define PCIE_REFCLK\t\t\t\tBIT(1)\n#define PCIE_REFCLK_MASK\t\t\t0x16\n#define PCIE_APP_REQ_EXIT_L1_MODE\t\tBIT(5)\n\n \n#define EXYNOS5433_PMU_PCIE_PHY_OFFSET\t\t0x730\n\n \nstruct exynos_pcie_phy {\n\tvoid __iomem *base;\n\tstruct regmap *pmureg;\n\tstruct regmap *fsysreg;\n};\n\nstatic void exynos_pcie_phy_writel(void __iomem *base, u32 val, u32 offset)\n{\n\twritel(val, base + offset);\n}\n\n \nstatic int exynos5433_pcie_phy_init(struct phy *phy)\n{\n\tstruct exynos_pcie_phy *ep = phy_get_drvdata(phy);\n\n\tregmap_update_bits(ep->pmureg, EXYNOS5433_PMU_PCIE_PHY_OFFSET,\n\t\t\t   BIT(0), 1);\n\tregmap_update_bits(ep->fsysreg, PCIE_EXYNOS5433_PHY_GLOBAL_RESET,\n\t\t\t   PCIE_APP_REQ_EXIT_L1_MODE, 0);\n\tregmap_update_bits(ep->fsysreg, PCIE_EXYNOS5433_PHY_L1SUB_CM_CON,\n\t\t\t   PCIE_REFCLK_GATING_EN, 0);\n\n\tregmap_update_bits(ep->fsysreg,\tPCIE_EXYNOS5433_PHY_COMMON_RESET,\n\t\t\t   PCIE_PHY_RESET, 1);\n\tregmap_update_bits(ep->fsysreg, PCIE_EXYNOS5433_PHY_MAC_RESET,\n\t\t\t   PCIE_MAC_RESET, 0);\n\n\t \n\tregmap_update_bits(ep->fsysreg, PCIE_EXYNOS5433_PHY_GLOBAL_RESET,\n\t\t\t   PCIE_REFCLK_MASK, PCIE_REFCLK);\n\tregmap_update_bits(ep->fsysreg, PCIE_EXYNOS5433_PHY_GLOBAL_RESET,\n\t\t\t   PCIE_GLOBAL_RESET, 0);\n\n\n\texynos_pcie_phy_writel(ep->base, 0x11, PCIE_PHY_OFFSET(0x3));\n\n\t \n\texynos_pcie_phy_writel(ep->base, 0, PCIE_PHY_OFFSET(0x20));\n\texynos_pcie_phy_writel(ep->base, 0, PCIE_PHY_OFFSET(0x4b));\n\n\t \n\texynos_pcie_phy_writel(ep->base, 0x34, PCIE_PHY_OFFSET(0x4));\n\texynos_pcie_phy_writel(ep->base, 0x02, PCIE_PHY_OFFSET(0x7));\n\texynos_pcie_phy_writel(ep->base, 0x41, PCIE_PHY_OFFSET(0x21));\n\texynos_pcie_phy_writel(ep->base, 0x7F, PCIE_PHY_OFFSET(0x14));\n\texynos_pcie_phy_writel(ep->base, 0xC0, PCIE_PHY_OFFSET(0x15));\n\texynos_pcie_phy_writel(ep->base, 0x61, PCIE_PHY_OFFSET(0x36));\n\n\t \n\texynos_pcie_phy_writel(ep->base, 0x44, PCIE_PHY_OFFSET(0x3D));\n\n\t \n\texynos_pcie_phy_writel(ep->base, 0x94, PCIE_PHY_OFFSET(0x8));\n\texynos_pcie_phy_writel(ep->base, 0xA7, PCIE_PHY_OFFSET(0x9));\n\texynos_pcie_phy_writel(ep->base, 0x93, PCIE_PHY_OFFSET(0xA));\n\texynos_pcie_phy_writel(ep->base, 0x6B, PCIE_PHY_OFFSET(0xC));\n\texynos_pcie_phy_writel(ep->base, 0xA5, PCIE_PHY_OFFSET(0xF));\n\texynos_pcie_phy_writel(ep->base, 0x34, PCIE_PHY_OFFSET(0x16));\n\texynos_pcie_phy_writel(ep->base, 0xA3, PCIE_PHY_OFFSET(0x17));\n\texynos_pcie_phy_writel(ep->base, 0xA7, PCIE_PHY_OFFSET(0x1A));\n\texynos_pcie_phy_writel(ep->base, 0x71, PCIE_PHY_OFFSET(0x23));\n\texynos_pcie_phy_writel(ep->base, 0x4C, PCIE_PHY_OFFSET(0x24));\n\n\texynos_pcie_phy_writel(ep->base, 0x0E, PCIE_PHY_OFFSET(0x26));\n\texynos_pcie_phy_writel(ep->base, 0x14, PCIE_PHY_OFFSET(0x7));\n\texynos_pcie_phy_writel(ep->base, 0x48, PCIE_PHY_OFFSET(0x43));\n\texynos_pcie_phy_writel(ep->base, 0x44, PCIE_PHY_OFFSET(0x44));\n\texynos_pcie_phy_writel(ep->base, 0x03, PCIE_PHY_OFFSET(0x45));\n\texynos_pcie_phy_writel(ep->base, 0xA7, PCIE_PHY_OFFSET(0x48));\n\texynos_pcie_phy_writel(ep->base, 0x13, PCIE_PHY_OFFSET(0x54));\n\texynos_pcie_phy_writel(ep->base, 0x04, PCIE_PHY_OFFSET(0x31));\n\texynos_pcie_phy_writel(ep->base, 0, PCIE_PHY_OFFSET(0x32));\n\n\tregmap_update_bits(ep->fsysreg, PCIE_EXYNOS5433_PHY_COMMON_RESET,\n\t\t\t   PCIE_PHY_RESET, 0);\n\tregmap_update_bits(ep->fsysreg, PCIE_EXYNOS5433_PHY_MAC_RESET,\n\t\t\t   PCIE_MAC_RESET_MASK, PCIE_MAC_RESET);\n\treturn 0;\n}\n\nstatic int exynos5433_pcie_phy_exit(struct phy *phy)\n{\n\tstruct exynos_pcie_phy *ep = phy_get_drvdata(phy);\n\n\tregmap_update_bits(ep->fsysreg, PCIE_EXYNOS5433_PHY_L1SUB_CM_CON,\n\t\t\t   PCIE_REFCLK_GATING_EN, PCIE_REFCLK_GATING_EN);\n\tregmap_update_bits(ep->pmureg, EXYNOS5433_PMU_PCIE_PHY_OFFSET,\n\t\t\t   BIT(0), 0);\n\treturn 0;\n}\n\nstatic const struct phy_ops exynos5433_phy_ops = {\n\t.init\t\t= exynos5433_pcie_phy_init,\n\t.exit\t\t= exynos5433_pcie_phy_exit,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id exynos_pcie_phy_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos5433-pcie-phy\",\n\t},\n\t{},\n};\n\nstatic int exynos_pcie_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct exynos_pcie_phy *exynos_phy;\n\tstruct phy *generic_phy;\n\tstruct phy_provider *phy_provider;\n\n\texynos_phy = devm_kzalloc(dev, sizeof(*exynos_phy), GFP_KERNEL);\n\tif (!exynos_phy)\n\t\treturn -ENOMEM;\n\n\texynos_phy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(exynos_phy->base))\n\t\treturn PTR_ERR(exynos_phy->base);\n\n\texynos_phy->pmureg = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t\"samsung,pmu-syscon\");\n\tif (IS_ERR(exynos_phy->pmureg)) {\n\t\tdev_err(&pdev->dev, \"PMU regmap lookup failed.\\n\");\n\t\treturn PTR_ERR(exynos_phy->pmureg);\n\t}\n\n\texynos_phy->fsysreg = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t \"samsung,fsys-sysreg\");\n\tif (IS_ERR(exynos_phy->fsysreg)) {\n\t\tdev_err(&pdev->dev, \"FSYS sysreg regmap lookup failed.\\n\");\n\t\treturn PTR_ERR(exynos_phy->fsysreg);\n\t}\n\n\tgeneric_phy = devm_phy_create(dev, dev->of_node, &exynos5433_phy_ops);\n\tif (IS_ERR(generic_phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(generic_phy);\n\t}\n\n\tphy_set_drvdata(generic_phy, exynos_phy);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver exynos_pcie_phy_driver = {\n\t.probe\t= exynos_pcie_phy_probe,\n\t.driver = {\n\t\t.of_match_table\t= exynos_pcie_phy_match,\n\t\t.name\t\t= \"exynos_pcie_phy\",\n\t\t.suppress_bind_attrs = true,\n\t}\n};\nbuiltin_platform_driver(exynos_pcie_phy_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}