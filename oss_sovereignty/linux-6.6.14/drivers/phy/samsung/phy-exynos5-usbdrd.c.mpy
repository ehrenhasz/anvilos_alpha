{
  "module_name": "phy-exynos5-usbdrd.c",
  "hash_id": "45fd9edbc71655effbe823fe1c9a81a051dca06e6efff18fd12620546e767ed9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/samsung/phy-exynos5-usbdrd.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/iopoll.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/soc/samsung/exynos-regs-pmu.h>\n\n \n#define EXYNOS5_FSEL_9MHZ6\t\t0x0\n#define EXYNOS5_FSEL_10MHZ\t\t0x1\n#define EXYNOS5_FSEL_12MHZ\t\t0x2\n#define EXYNOS5_FSEL_19MHZ2\t\t0x3\n#define EXYNOS5_FSEL_20MHZ\t\t0x4\n#define EXYNOS5_FSEL_24MHZ\t\t0x5\n#define EXYNOS5_FSEL_26MHZ\t\t0x82\n#define EXYNOS5_FSEL_50MHZ\t\t0x7\n\n \n#define EXYNOS5_DRD_LINKSYSTEM\t\t\t0x04\n\n#define LINKSYSTEM_FLADJ_MASK\t\t\t(0x3f << 1)\n#define LINKSYSTEM_FLADJ(_x)\t\t\t((_x) << 1)\n#define LINKSYSTEM_XHCI_VERSION_CONTROL\t\tBIT(27)\n\n#define EXYNOS5_DRD_PHYUTMI\t\t\t0x08\n\n#define PHYUTMI_OTGDISABLE\t\t\tBIT(6)\n#define PHYUTMI_FORCESUSPEND\t\t\tBIT(1)\n#define PHYUTMI_FORCESLEEP\t\t\tBIT(0)\n\n#define EXYNOS5_DRD_PHYPIPE\t\t\t0x0c\n\n#define EXYNOS5_DRD_PHYCLKRST\t\t\t0x10\n\n#define PHYCLKRST_EN_UTMISUSPEND\t\tBIT(31)\n\n#define PHYCLKRST_SSC_REFCLKSEL_MASK\t\t(0xff << 23)\n#define PHYCLKRST_SSC_REFCLKSEL(_x)\t\t((_x) << 23)\n\n#define PHYCLKRST_SSC_RANGE_MASK\t\t(0x03 << 21)\n#define PHYCLKRST_SSC_RANGE(_x)\t\t\t((_x) << 21)\n\n#define PHYCLKRST_SSC_EN\t\t\tBIT(20)\n#define PHYCLKRST_REF_SSP_EN\t\t\tBIT(19)\n#define PHYCLKRST_REF_CLKDIV2\t\t\tBIT(18)\n\n#define PHYCLKRST_MPLL_MULTIPLIER_MASK\t\t(0x7f << 11)\n#define PHYCLKRST_MPLL_MULTIPLIER_100MHZ_REF\t(0x19 << 11)\n#define PHYCLKRST_MPLL_MULTIPLIER_50M_REF\t(0x32 << 11)\n#define PHYCLKRST_MPLL_MULTIPLIER_24MHZ_REF\t(0x68 << 11)\n#define PHYCLKRST_MPLL_MULTIPLIER_20MHZ_REF\t(0x7d << 11)\n#define PHYCLKRST_MPLL_MULTIPLIER_19200KHZ_REF\t(0x02 << 11)\n\n#define PHYCLKRST_FSEL_UTMI_MASK\t\t(0x7 << 5)\n#define PHYCLKRST_FSEL_PIPE_MASK\t\t(0x7 << 8)\n#define PHYCLKRST_FSEL(_x)\t\t\t((_x) << 5)\n#define PHYCLKRST_FSEL_PAD_100MHZ\t\t(0x27 << 5)\n#define PHYCLKRST_FSEL_PAD_24MHZ\t\t(0x2a << 5)\n#define PHYCLKRST_FSEL_PAD_20MHZ\t\t(0x31 << 5)\n#define PHYCLKRST_FSEL_PAD_19_2MHZ\t\t(0x38 << 5)\n\n#define PHYCLKRST_RETENABLEN\t\t\tBIT(4)\n\n#define PHYCLKRST_REFCLKSEL_MASK\t\t(0x03 << 2)\n#define PHYCLKRST_REFCLKSEL_PAD_REFCLK\t\t(0x2 << 2)\n#define PHYCLKRST_REFCLKSEL_EXT_REFCLK\t\t(0x3 << 2)\n\n#define PHYCLKRST_PORTRESET\t\t\tBIT(1)\n#define PHYCLKRST_COMMONONN\t\t\tBIT(0)\n\n#define EXYNOS5_DRD_PHYREG0\t\t\t0x14\n#define PHYREG0_SSC_REF_CLK_SEL\t\t\tBIT(21)\n#define PHYREG0_SSC_RANGE\t\t\tBIT(20)\n#define PHYREG0_CR_WRITE\t\t\tBIT(19)\n#define PHYREG0_CR_READ\t\t\t\tBIT(18)\n#define PHYREG0_CR_DATA_IN(_x)\t\t\t((_x) << 2)\n#define PHYREG0_CR_CAP_DATA\t\t\tBIT(1)\n#define PHYREG0_CR_CAP_ADDR\t\t\tBIT(0)\n\n#define EXYNOS5_DRD_PHYREG1\t\t\t0x18\n#define PHYREG1_CR_DATA_OUT(_x)\t\t\t((_x) << 1)\n#define PHYREG1_CR_ACK\t\t\t\tBIT(0)\n\n#define EXYNOS5_DRD_PHYPARAM0\t\t\t0x1c\n\n#define PHYPARAM0_REF_USE_PAD\t\t\tBIT(31)\n#define PHYPARAM0_REF_LOSLEVEL_MASK\t\t(0x1f << 26)\n#define PHYPARAM0_REF_LOSLEVEL\t\t\t(0x9 << 26)\n\n#define EXYNOS5_DRD_PHYPARAM1\t\t\t0x20\n\n#define PHYPARAM1_PCS_TXDEEMPH_MASK\t\t(0x1f << 0)\n#define PHYPARAM1_PCS_TXDEEMPH\t\t\t(0x1c)\n\n#define EXYNOS5_DRD_PHYTERM\t\t\t0x24\n\n#define EXYNOS5_DRD_PHYTEST\t\t\t0x28\n\n#define PHYTEST_POWERDOWN_SSP\t\t\tBIT(3)\n#define PHYTEST_POWERDOWN_HSP\t\t\tBIT(2)\n\n#define EXYNOS5_DRD_PHYADP\t\t\t0x2c\n\n#define EXYNOS5_DRD_PHYUTMICLKSEL\t\t0x30\n\n#define PHYUTMICLKSEL_UTMI_CLKSEL\t\tBIT(2)\n\n#define EXYNOS5_DRD_PHYRESUME\t\t\t0x34\n#define EXYNOS5_DRD_LINKPORT\t\t\t0x44\n\n \n#define EXYNOS5_DRD_PHYSS_LOSLEVEL_OVRD_IN\t\t(0x15)\n#define LOSLEVEL_OVRD_IN_LOS_BIAS_5420\t\t\t(0x5 << 13)\n#define LOSLEVEL_OVRD_IN_LOS_BIAS_DEFAULT\t\t(0x0 << 13)\n#define LOSLEVEL_OVRD_IN_EN\t\t\t\t(0x1 << 10)\n#define LOSLEVEL_OVRD_IN_LOS_LEVEL_DEFAULT\t\t(0x9 << 0)\n\n#define EXYNOS5_DRD_PHYSS_TX_VBOOSTLEVEL_OVRD_IN\t(0x12)\n#define TX_VBOOSTLEVEL_OVRD_IN_VBOOST_5420\t\t(0x5 << 13)\n#define TX_VBOOSTLEVEL_OVRD_IN_VBOOST_DEFAULT\t\t(0x4 << 13)\n\n#define EXYNOS5_DRD_PHYSS_LANE0_TX_DEBUG\t\t(0x1010)\n#define LANE0_TX_DEBUG_RXDET_MEAS_TIME_19M2_20M\t\t(0x4 << 4)\n#define LANE0_TX_DEBUG_RXDET_MEAS_TIME_24M\t\t(0x8 << 4)\n#define LANE0_TX_DEBUG_RXDET_MEAS_TIME_25M_26M\t\t(0x8 << 4)\n#define LANE0_TX_DEBUG_RXDET_MEAS_TIME_48M_50M_52M\t(0x20 << 4)\n#define LANE0_TX_DEBUG_RXDET_MEAS_TIME_62M5\t\t(0x20 << 4)\n#define LANE0_TX_DEBUG_RXDET_MEAS_TIME_96M_100M\t\t(0x40 << 4)\n\n \n#define EXYNOS850_DRD_LINKCTRL\t\t\t0x04\n#define LINKCTRL_BUS_FILTER_BYPASS(_x)\t\t((_x) << 4)\n#define LINKCTRL_FORCE_QACT\t\t\tBIT(8)\n\n#define EXYNOS850_DRD_CLKRST\t\t\t0x20\n#define CLKRST_LINK_SW_RST\t\t\tBIT(0)\n#define CLKRST_PORT_RST\t\t\t\tBIT(1)\n#define CLKRST_PHY_SW_RST\t\t\tBIT(3)\n\n#define EXYNOS850_DRD_UTMI\t\t\t0x50\n#define UTMI_FORCE_SLEEP\t\t\tBIT(0)\n#define UTMI_FORCE_SUSPEND\t\t\tBIT(1)\n#define UTMI_DM_PULLDOWN\t\t\tBIT(2)\n#define UTMI_DP_PULLDOWN\t\t\tBIT(3)\n#define UTMI_FORCE_BVALID\t\t\tBIT(4)\n#define UTMI_FORCE_VBUSVALID\t\t\tBIT(5)\n\n#define EXYNOS850_DRD_HSP\t\t\t0x54\n#define HSP_COMMONONN\t\t\t\tBIT(8)\n#define HSP_EN_UTMISUSPEND\t\t\tBIT(9)\n#define HSP_VBUSVLDEXT\t\t\t\tBIT(12)\n#define HSP_VBUSVLDEXTSEL\t\t\tBIT(13)\n#define HSP_FSV_OUT_EN\t\t\t\tBIT(24)\n\n#define EXYNOS850_DRD_HSP_TEST\t\t\t0x5c\n#define HSP_TEST_SIDDQ\t\t\t\tBIT(24)\n\n#define KHZ\t1000\n#define MHZ\t(KHZ * KHZ)\n\nenum exynos5_usbdrd_phy_id {\n\tEXYNOS5_DRDPHY_UTMI,\n\tEXYNOS5_DRDPHY_PIPE3,\n\tEXYNOS5_DRDPHYS_NUM,\n};\n\nstruct phy_usb_instance;\nstruct exynos5_usbdrd_phy;\n\nstruct exynos5_usbdrd_phy_config {\n\tu32 id;\n\tvoid (*phy_isol)(struct phy_usb_instance *inst, u32 on);\n\tvoid (*phy_init)(struct exynos5_usbdrd_phy *phy_drd);\n\tunsigned int (*set_refclk)(struct phy_usb_instance *inst);\n};\n\nstruct exynos5_usbdrd_phy_drvdata {\n\tconst struct exynos5_usbdrd_phy_config *phy_cfg;\n\tconst struct phy_ops *phy_ops;\n\tu32 pmu_offset_usbdrd0_phy;\n\tu32 pmu_offset_usbdrd1_phy;\n\tbool has_common_clk_gate;\n};\n\n \nstruct exynos5_usbdrd_phy {\n\tstruct device *dev;\n\tvoid __iomem *reg_phy;\n\tstruct clk *clk;\n\tstruct clk *pipeclk;\n\tstruct clk *utmiclk;\n\tstruct clk *itpclk;\n\tconst struct exynos5_usbdrd_phy_drvdata *drv_data;\n\tstruct phy_usb_instance {\n\t\tstruct phy *phy;\n\t\tu32 index;\n\t\tstruct regmap *reg_pmu;\n\t\tu32 pmu_offset;\n\t\tconst struct exynos5_usbdrd_phy_config *phy_cfg;\n\t} phys[EXYNOS5_DRDPHYS_NUM];\n\tu32 extrefclk;\n\tstruct clk *ref_clk;\n\tstruct regulator *vbus;\n\tstruct regulator *vbus_boost;\n};\n\nstatic inline\nstruct exynos5_usbdrd_phy *to_usbdrd_phy(struct phy_usb_instance *inst)\n{\n\treturn container_of((inst), struct exynos5_usbdrd_phy,\n\t\t\t    phys[(inst)->index]);\n}\n\n \nstatic unsigned int exynos5_rate_to_clk(unsigned long rate, u32 *reg)\n{\n\t \n\n\tswitch (rate) {\n\tcase 9600 * KHZ:\n\t\t*reg = EXYNOS5_FSEL_9MHZ6;\n\t\tbreak;\n\tcase 10 * MHZ:\n\t\t*reg = EXYNOS5_FSEL_10MHZ;\n\t\tbreak;\n\tcase 12 * MHZ:\n\t\t*reg = EXYNOS5_FSEL_12MHZ;\n\t\tbreak;\n\tcase 19200 * KHZ:\n\t\t*reg = EXYNOS5_FSEL_19MHZ2;\n\t\tbreak;\n\tcase 20 * MHZ:\n\t\t*reg = EXYNOS5_FSEL_20MHZ;\n\t\tbreak;\n\tcase 24 * MHZ:\n\t\t*reg = EXYNOS5_FSEL_24MHZ;\n\t\tbreak;\n\tcase 26 * MHZ:\n\t\t*reg = EXYNOS5_FSEL_26MHZ;\n\t\tbreak;\n\tcase 50 * MHZ:\n\t\t*reg = EXYNOS5_FSEL_50MHZ;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void exynos5_usbdrd_phy_isol(struct phy_usb_instance *inst,\n\t\t\t\t\t\tunsigned int on)\n{\n\tunsigned int val;\n\n\tif (!inst->reg_pmu)\n\t\treturn;\n\n\tval = on ? 0 : EXYNOS4_PHY_ENABLE;\n\n\tregmap_update_bits(inst->reg_pmu, inst->pmu_offset,\n\t\t\t   EXYNOS4_PHY_ENABLE, val);\n}\n\n \nstatic unsigned int\nexynos5_usbdrd_pipe3_set_refclk(struct phy_usb_instance *inst)\n{\n\tu32 reg;\n\tstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\n\n\t \n\treg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYCLKRST);\n\n\t \n\treg &= ~PHYCLKRST_REFCLKSEL_MASK;\n\treg |=\tPHYCLKRST_REFCLKSEL_EXT_REFCLK;\n\n\t \n\treg &= ~PHYCLKRST_FSEL_PIPE_MASK |\n\t\tPHYCLKRST_MPLL_MULTIPLIER_MASK |\n\t\tPHYCLKRST_SSC_REFCLKSEL_MASK;\n\tswitch (phy_drd->extrefclk) {\n\tcase EXYNOS5_FSEL_50MHZ:\n\t\treg |= (PHYCLKRST_MPLL_MULTIPLIER_50M_REF |\n\t\t\tPHYCLKRST_SSC_REFCLKSEL(0x00));\n\t\tbreak;\n\tcase EXYNOS5_FSEL_24MHZ:\n\t\treg |= (PHYCLKRST_MPLL_MULTIPLIER_24MHZ_REF |\n\t\t\tPHYCLKRST_SSC_REFCLKSEL(0x88));\n\t\tbreak;\n\tcase EXYNOS5_FSEL_20MHZ:\n\t\treg |= (PHYCLKRST_MPLL_MULTIPLIER_20MHZ_REF |\n\t\t\tPHYCLKRST_SSC_REFCLKSEL(0x00));\n\t\tbreak;\n\tcase EXYNOS5_FSEL_19MHZ2:\n\t\treg |= (PHYCLKRST_MPLL_MULTIPLIER_19200KHZ_REF |\n\t\t\tPHYCLKRST_SSC_REFCLKSEL(0x88));\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(phy_drd->dev, \"unsupported ref clk\\n\");\n\t\tbreak;\n\t}\n\n\treturn reg;\n}\n\n \nstatic unsigned int\nexynos5_usbdrd_utmi_set_refclk(struct phy_usb_instance *inst)\n{\n\tu32 reg;\n\tstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\n\n\t \n\treg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYCLKRST);\n\n\treg &= ~PHYCLKRST_REFCLKSEL_MASK;\n\treg |=\tPHYCLKRST_REFCLKSEL_EXT_REFCLK;\n\n\treg &= ~PHYCLKRST_FSEL_UTMI_MASK |\n\t\tPHYCLKRST_MPLL_MULTIPLIER_MASK |\n\t\tPHYCLKRST_SSC_REFCLKSEL_MASK;\n\treg |= PHYCLKRST_FSEL(phy_drd->extrefclk);\n\n\treturn reg;\n}\n\nstatic void exynos5_usbdrd_pipe3_init(struct exynos5_usbdrd_phy *phy_drd)\n{\n\tu32 reg;\n\n\treg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM1);\n\t \n\treg &= ~PHYPARAM1_PCS_TXDEEMPH_MASK;\n\treg |=\tPHYPARAM1_PCS_TXDEEMPH;\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM1);\n\n\treg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYTEST);\n\treg &= ~PHYTEST_POWERDOWN_SSP;\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYTEST);\n}\n\nstatic void exynos5_usbdrd_utmi_init(struct exynos5_usbdrd_phy *phy_drd)\n{\n\tu32 reg;\n\n\treg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM0);\n\t \n\treg &= ~PHYPARAM0_REF_LOSLEVEL_MASK;\n\treg |=\tPHYPARAM0_REF_LOSLEVEL;\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM0);\n\n\treg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM1);\n\t \n\treg &= ~PHYPARAM1_PCS_TXDEEMPH_MASK;\n\treg |=\tPHYPARAM1_PCS_TXDEEMPH;\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM1);\n\n\t \n\twritel(PHYUTMI_OTGDISABLE, phy_drd->reg_phy + EXYNOS5_DRD_PHYUTMI);\n\n\treg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYTEST);\n\treg &= ~PHYTEST_POWERDOWN_HSP;\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYTEST);\n}\n\nstatic int exynos5_usbdrd_phy_init(struct phy *phy)\n{\n\tint ret;\n\tu32 reg;\n\tstruct phy_usb_instance *inst = phy_get_drvdata(phy);\n\tstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\n\n\tret = clk_prepare_enable(phy_drd->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(0x0, phy_drd->reg_phy + EXYNOS5_DRD_PHYREG0);\n\twritel(0x0, phy_drd->reg_phy + EXYNOS5_DRD_PHYRESUME);\n\n\t \n\treg =\tLINKSYSTEM_XHCI_VERSION_CONTROL |\n\t\tLINKSYSTEM_FLADJ(0x20);\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_LINKSYSTEM);\n\n\treg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM0);\n\t \n\treg &= ~PHYPARAM0_REF_USE_PAD;\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM0);\n\n\t \n\treg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYUTMICLKSEL);\n\treg |= PHYUTMICLKSEL_UTMI_CLKSEL;\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYUTMICLKSEL);\n\n\t \n\tinst->phy_cfg->phy_init(phy_drd);\n\n\t \n\treg = inst->phy_cfg->set_refclk(inst);\n\n\t\t \n\treg |=\tPHYCLKRST_RETENABLEN |\n\t\t \n\t\tPHYCLKRST_REF_SSP_EN |\n\t\t \n\t\tPHYCLKRST_SSC_EN |\n\t\t \n\t\tPHYCLKRST_COMMONONN |\n\t\t \n\t\tPHYCLKRST_PORTRESET;\n\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYCLKRST);\n\n\tudelay(10);\n\n\treg &= ~PHYCLKRST_PORTRESET;\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYCLKRST);\n\n\tclk_disable_unprepare(phy_drd->clk);\n\n\treturn 0;\n}\n\nstatic int exynos5_usbdrd_phy_exit(struct phy *phy)\n{\n\tint ret;\n\tu32 reg;\n\tstruct phy_usb_instance *inst = phy_get_drvdata(phy);\n\tstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\n\n\tret = clk_prepare_enable(phy_drd->clk);\n\tif (ret)\n\t\treturn ret;\n\n\treg =\tPHYUTMI_OTGDISABLE |\n\t\tPHYUTMI_FORCESUSPEND |\n\t\tPHYUTMI_FORCESLEEP;\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYUTMI);\n\n\t \n\treg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYCLKRST);\n\treg &= ~(PHYCLKRST_REF_SSP_EN |\n\t\t PHYCLKRST_SSC_EN |\n\t\t PHYCLKRST_COMMONONN);\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYCLKRST);\n\n\t \n\treg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYTEST);\n\treg |=\tPHYTEST_POWERDOWN_SSP |\n\t\tPHYTEST_POWERDOWN_HSP;\n\twritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYTEST);\n\n\tclk_disable_unprepare(phy_drd->clk);\n\n\treturn 0;\n}\n\nstatic int exynos5_usbdrd_phy_power_on(struct phy *phy)\n{\n\tint ret;\n\tstruct phy_usb_instance *inst = phy_get_drvdata(phy);\n\tstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\n\n\tdev_dbg(phy_drd->dev, \"Request to power_on usbdrd_phy phy\\n\");\n\n\tclk_prepare_enable(phy_drd->ref_clk);\n\tif (!phy_drd->drv_data->has_common_clk_gate) {\n\t\tclk_prepare_enable(phy_drd->pipeclk);\n\t\tclk_prepare_enable(phy_drd->utmiclk);\n\t\tclk_prepare_enable(phy_drd->itpclk);\n\t}\n\n\t \n\tif (phy_drd->vbus_boost) {\n\t\tret = regulator_enable(phy_drd->vbus_boost);\n\t\tif (ret) {\n\t\t\tdev_err(phy_drd->dev,\n\t\t\t\t\"Failed to enable VBUS boost supply\\n\");\n\t\t\tgoto fail_vbus;\n\t\t}\n\t}\n\n\tif (phy_drd->vbus) {\n\t\tret = regulator_enable(phy_drd->vbus);\n\t\tif (ret) {\n\t\t\tdev_err(phy_drd->dev, \"Failed to enable VBUS supply\\n\");\n\t\t\tgoto fail_vbus_boost;\n\t\t}\n\t}\n\n\t \n\tinst->phy_cfg->phy_isol(inst, 0);\n\n\treturn 0;\n\nfail_vbus_boost:\n\tif (phy_drd->vbus_boost)\n\t\tregulator_disable(phy_drd->vbus_boost);\n\nfail_vbus:\n\tclk_disable_unprepare(phy_drd->ref_clk);\n\tif (!phy_drd->drv_data->has_common_clk_gate) {\n\t\tclk_disable_unprepare(phy_drd->itpclk);\n\t\tclk_disable_unprepare(phy_drd->utmiclk);\n\t\tclk_disable_unprepare(phy_drd->pipeclk);\n\t}\n\n\treturn ret;\n}\n\nstatic int exynos5_usbdrd_phy_power_off(struct phy *phy)\n{\n\tstruct phy_usb_instance *inst = phy_get_drvdata(phy);\n\tstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\n\n\tdev_dbg(phy_drd->dev, \"Request to power_off usbdrd_phy phy\\n\");\n\n\t \n\tinst->phy_cfg->phy_isol(inst, 1);\n\n\t \n\tif (phy_drd->vbus)\n\t\tregulator_disable(phy_drd->vbus);\n\tif (phy_drd->vbus_boost)\n\t\tregulator_disable(phy_drd->vbus_boost);\n\n\tclk_disable_unprepare(phy_drd->ref_clk);\n\tif (!phy_drd->drv_data->has_common_clk_gate) {\n\t\tclk_disable_unprepare(phy_drd->itpclk);\n\t\tclk_disable_unprepare(phy_drd->pipeclk);\n\t\tclk_disable_unprepare(phy_drd->utmiclk);\n\t}\n\n\treturn 0;\n}\n\nstatic int crport_handshake(struct exynos5_usbdrd_phy *phy_drd,\n\t\t\t    u32 val, u32 cmd)\n{\n\tunsigned int result;\n\tint err;\n\n\twritel(val | cmd, phy_drd->reg_phy + EXYNOS5_DRD_PHYREG0);\n\n\terr = readl_poll_timeout(phy_drd->reg_phy + EXYNOS5_DRD_PHYREG1,\n\t\t\t\t result, (result & PHYREG1_CR_ACK), 1, 100);\n\tif (err == -ETIMEDOUT) {\n\t\tdev_err(phy_drd->dev, \"CRPORT handshake timeout1 (0x%08x)\\n\", val);\n\t\treturn err;\n\t}\n\n\twritel(val, phy_drd->reg_phy + EXYNOS5_DRD_PHYREG0);\n\n\terr = readl_poll_timeout(phy_drd->reg_phy + EXYNOS5_DRD_PHYREG1,\n\t\t\t\t result, !(result & PHYREG1_CR_ACK), 1, 100);\n\tif (err == -ETIMEDOUT) {\n\t\tdev_err(phy_drd->dev, \"CRPORT handshake timeout2 (0x%08x)\\n\", val);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int crport_ctrl_write(struct exynos5_usbdrd_phy *phy_drd,\n\t\t\t     u32 addr, u32 data)\n{\n\tint ret;\n\n\t \n\twritel(PHYREG0_CR_DATA_IN(addr),\n\t       phy_drd->reg_phy + EXYNOS5_DRD_PHYREG0);\n\tret = crport_handshake(phy_drd, PHYREG0_CR_DATA_IN(addr),\n\t\t\t       PHYREG0_CR_CAP_ADDR);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(PHYREG0_CR_DATA_IN(data),\n\t       phy_drd->reg_phy + EXYNOS5_DRD_PHYREG0);\n\tret = crport_handshake(phy_drd, PHYREG0_CR_DATA_IN(data),\n\t\t\t       PHYREG0_CR_CAP_DATA);\n\tif (ret)\n\t\treturn ret;\n\n\tret = crport_handshake(phy_drd, PHYREG0_CR_DATA_IN(data),\n\t\t\t       PHYREG0_CR_WRITE);\n\n\treturn ret;\n}\n\n \nstatic int exynos5420_usbdrd_phy_calibrate(struct exynos5_usbdrd_phy *phy_drd)\n{\n\tunsigned int temp;\n\tint ret = 0;\n\n\t \n\ttemp = LOSLEVEL_OVRD_IN_LOS_BIAS_5420 |\n\t\tLOSLEVEL_OVRD_IN_EN |\n\t\tLOSLEVEL_OVRD_IN_LOS_LEVEL_DEFAULT;\n\tret = crport_ctrl_write(phy_drd,\n\t\t\t\tEXYNOS5_DRD_PHYSS_LOSLEVEL_OVRD_IN,\n\t\t\t\ttemp);\n\tif (ret) {\n\t\tdev_err(phy_drd->dev,\n\t\t\t\"Failed setting Loss-of-Signal level for SuperSpeed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\ttemp = TX_VBOOSTLEVEL_OVRD_IN_VBOOST_5420;\n\tret = crport_ctrl_write(phy_drd,\n\t\t\t\tEXYNOS5_DRD_PHYSS_TX_VBOOSTLEVEL_OVRD_IN,\n\t\t\t\ttemp);\n\tif (ret) {\n\t\tdev_err(phy_drd->dev,\n\t\t\t\"Failed setting Tx-Vboost-Level for SuperSpeed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tswitch (phy_drd->extrefclk) {\n\tcase EXYNOS5_FSEL_50MHZ:\n\t\ttemp = LANE0_TX_DEBUG_RXDET_MEAS_TIME_48M_50M_52M;\n\t\tbreak;\n\tcase EXYNOS5_FSEL_20MHZ:\n\tcase EXYNOS5_FSEL_19MHZ2:\n\t\ttemp = LANE0_TX_DEBUG_RXDET_MEAS_TIME_19M2_20M;\n\t\tbreak;\n\tcase EXYNOS5_FSEL_24MHZ:\n\tdefault:\n\t\ttemp = LANE0_TX_DEBUG_RXDET_MEAS_TIME_24M;\n\t\tbreak;\n\t}\n\n\tret = crport_ctrl_write(phy_drd,\n\t\t\t\tEXYNOS5_DRD_PHYSS_LANE0_TX_DEBUG,\n\t\t\t\ttemp);\n\tif (ret)\n\t\tdev_err(phy_drd->dev,\n\t\t\t\"Fail to set RxDet measurement time for SuperSpeed\\n\");\n\n\treturn ret;\n}\n\nstatic struct phy *exynos5_usbdrd_phy_xlate(struct device *dev,\n\t\t\t\t\tstruct of_phandle_args *args)\n{\n\tstruct exynos5_usbdrd_phy *phy_drd = dev_get_drvdata(dev);\n\n\tif (WARN_ON(args->args[0] >= EXYNOS5_DRDPHYS_NUM))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn phy_drd->phys[args->args[0]].phy;\n}\n\nstatic int exynos5_usbdrd_phy_calibrate(struct phy *phy)\n{\n\tstruct phy_usb_instance *inst = phy_get_drvdata(phy);\n\tstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\n\n\tif (inst->phy_cfg->id == EXYNOS5_DRDPHY_UTMI)\n\t\treturn exynos5420_usbdrd_phy_calibrate(phy_drd);\n\treturn 0;\n}\n\nstatic const struct phy_ops exynos5_usbdrd_phy_ops = {\n\t.init\t\t= exynos5_usbdrd_phy_init,\n\t.exit\t\t= exynos5_usbdrd_phy_exit,\n\t.power_on\t= exynos5_usbdrd_phy_power_on,\n\t.power_off\t= exynos5_usbdrd_phy_power_off,\n\t.calibrate\t= exynos5_usbdrd_phy_calibrate,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void exynos850_usbdrd_utmi_init(struct exynos5_usbdrd_phy *phy_drd)\n{\n\tvoid __iomem *regs_base = phy_drd->reg_phy;\n\tu32 reg;\n\n\t \n\treg = readl(regs_base + EXYNOS850_DRD_LINKCTRL);\n\treg |= LINKCTRL_FORCE_QACT;\n\twritel(reg, regs_base + EXYNOS850_DRD_LINKCTRL);\n\n\t \n\treg = readl(regs_base + EXYNOS850_DRD_CLKRST);\n\treg |= CLKRST_PHY_SW_RST;\n\twritel(reg, regs_base + EXYNOS850_DRD_CLKRST);\n\n\t \n\treg = readl(regs_base + EXYNOS850_DRD_UTMI);\n\treg &= ~(UTMI_FORCE_SUSPEND | UTMI_FORCE_SLEEP | UTMI_DP_PULLDOWN |\n\t\t UTMI_DM_PULLDOWN);\n\twritel(reg, regs_base + EXYNOS850_DRD_UTMI);\n\n\t \n\treg = readl(regs_base + EXYNOS850_DRD_HSP);\n\treg |= HSP_EN_UTMISUSPEND | HSP_COMMONONN;\n\twritel(reg, regs_base + EXYNOS850_DRD_HSP);\n\n\t \n\treg = readl(regs_base + EXYNOS850_DRD_LINKCTRL);\n\treg |= LINKCTRL_BUS_FILTER_BYPASS(0xf);\n\twritel(reg, regs_base + EXYNOS850_DRD_LINKCTRL);\n\n\treg = readl(regs_base + EXYNOS850_DRD_UTMI);\n\treg |= UTMI_FORCE_BVALID | UTMI_FORCE_VBUSVALID;\n\twritel(reg, regs_base + EXYNOS850_DRD_UTMI);\n\n\treg = readl(regs_base + EXYNOS850_DRD_HSP);\n\treg |= HSP_VBUSVLDEXT | HSP_VBUSVLDEXTSEL;\n\twritel(reg, regs_base + EXYNOS850_DRD_HSP);\n\n\t \n\treg = readl(regs_base + EXYNOS850_DRD_HSP_TEST);\n\treg &= ~HSP_TEST_SIDDQ;\n\twritel(reg, regs_base + EXYNOS850_DRD_HSP_TEST);\n\n\t \n\tudelay(10);  \n\treg = readl(regs_base + EXYNOS850_DRD_CLKRST);\n\treg &= ~(CLKRST_PHY_SW_RST | CLKRST_PORT_RST);\n\twritel(reg, regs_base + EXYNOS850_DRD_CLKRST);\n\tudelay(75);  \n\n\t \n\treg = readl(regs_base + EXYNOS850_DRD_HSP);\n\treg &= ~HSP_FSV_OUT_EN;\n\twritel(reg, regs_base + EXYNOS850_DRD_HSP);\n}\n\nstatic int exynos850_usbdrd_phy_init(struct phy *phy)\n{\n\tstruct phy_usb_instance *inst = phy_get_drvdata(phy);\n\tstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\n\tint ret;\n\n\tret = clk_prepare_enable(phy_drd->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tinst->phy_cfg->phy_init(phy_drd);\n\n\tclk_disable_unprepare(phy_drd->clk);\n\n\treturn 0;\n}\n\nstatic int exynos850_usbdrd_phy_exit(struct phy *phy)\n{\n\tstruct phy_usb_instance *inst = phy_get_drvdata(phy);\n\tstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\n\tvoid __iomem *regs_base = phy_drd->reg_phy;\n\tu32 reg;\n\tint ret;\n\n\tret = clk_prepare_enable(phy_drd->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treg = readl(regs_base + EXYNOS850_DRD_UTMI);\n\treg &= ~(UTMI_DP_PULLDOWN | UTMI_DM_PULLDOWN);\n\treg |= UTMI_FORCE_SUSPEND | UTMI_FORCE_SLEEP;\n\twritel(reg, regs_base + EXYNOS850_DRD_UTMI);\n\n\t \n\treg = readl(regs_base + EXYNOS850_DRD_HSP_TEST);\n\treg |= HSP_TEST_SIDDQ;\n\twritel(reg, regs_base + EXYNOS850_DRD_HSP_TEST);\n\n\t \n\treg = readl(regs_base + EXYNOS850_DRD_CLKRST);\n\treg |= CLKRST_LINK_SW_RST;\n\twritel(reg, regs_base + EXYNOS850_DRD_CLKRST);\n\tudelay(10);  \n\treg &= ~CLKRST_LINK_SW_RST;\n\twritel(reg, regs_base + EXYNOS850_DRD_CLKRST);\n\n\tclk_disable_unprepare(phy_drd->clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops exynos850_usbdrd_phy_ops = {\n\t.init\t\t= exynos850_usbdrd_phy_init,\n\t.exit\t\t= exynos850_usbdrd_phy_exit,\n\t.power_on\t= exynos5_usbdrd_phy_power_on,\n\t.power_off\t= exynos5_usbdrd_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int exynos5_usbdrd_phy_clk_handle(struct exynos5_usbdrd_phy *phy_drd)\n{\n\tunsigned long ref_rate;\n\tint ret;\n\n\tphy_drd->clk = devm_clk_get(phy_drd->dev, \"phy\");\n\tif (IS_ERR(phy_drd->clk)) {\n\t\tdev_err(phy_drd->dev, \"Failed to get phy clock\\n\");\n\t\treturn PTR_ERR(phy_drd->clk);\n\t}\n\n\tphy_drd->ref_clk = devm_clk_get(phy_drd->dev, \"ref\");\n\tif (IS_ERR(phy_drd->ref_clk)) {\n\t\tdev_err(phy_drd->dev, \"Failed to get phy reference clock\\n\");\n\t\treturn PTR_ERR(phy_drd->ref_clk);\n\t}\n\tref_rate = clk_get_rate(phy_drd->ref_clk);\n\n\tret = exynos5_rate_to_clk(ref_rate, &phy_drd->extrefclk);\n\tif (ret) {\n\t\tdev_err(phy_drd->dev, \"Clock rate (%ld) not supported\\n\",\n\t\t\tref_rate);\n\t\treturn ret;\n\t}\n\n\tif (!phy_drd->drv_data->has_common_clk_gate) {\n\t\tphy_drd->pipeclk = devm_clk_get(phy_drd->dev, \"phy_pipe\");\n\t\tif (IS_ERR(phy_drd->pipeclk)) {\n\t\t\tdev_info(phy_drd->dev,\n\t\t\t\t \"PIPE3 phy operational clock not specified\\n\");\n\t\t\tphy_drd->pipeclk = NULL;\n\t\t}\n\n\t\tphy_drd->utmiclk = devm_clk_get(phy_drd->dev, \"phy_utmi\");\n\t\tif (IS_ERR(phy_drd->utmiclk)) {\n\t\t\tdev_info(phy_drd->dev,\n\t\t\t\t \"UTMI phy operational clock not specified\\n\");\n\t\t\tphy_drd->utmiclk = NULL;\n\t\t}\n\n\t\tphy_drd->itpclk = devm_clk_get(phy_drd->dev, \"itp\");\n\t\tif (IS_ERR(phy_drd->itpclk)) {\n\t\t\tdev_info(phy_drd->dev,\n\t\t\t\t \"ITP clock from main OSC not specified\\n\");\n\t\t\tphy_drd->itpclk = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct exynos5_usbdrd_phy_config phy_cfg_exynos5[] = {\n\t{\n\t\t.id\t\t= EXYNOS5_DRDPHY_UTMI,\n\t\t.phy_isol\t= exynos5_usbdrd_phy_isol,\n\t\t.phy_init\t= exynos5_usbdrd_utmi_init,\n\t\t.set_refclk\t= exynos5_usbdrd_utmi_set_refclk,\n\t},\n\t{\n\t\t.id\t\t= EXYNOS5_DRDPHY_PIPE3,\n\t\t.phy_isol\t= exynos5_usbdrd_phy_isol,\n\t\t.phy_init\t= exynos5_usbdrd_pipe3_init,\n\t\t.set_refclk\t= exynos5_usbdrd_pipe3_set_refclk,\n\t},\n};\n\nstatic const struct exynos5_usbdrd_phy_config phy_cfg_exynos850[] = {\n\t{\n\t\t.id\t\t= EXYNOS5_DRDPHY_UTMI,\n\t\t.phy_isol\t= exynos5_usbdrd_phy_isol,\n\t\t.phy_init\t= exynos850_usbdrd_utmi_init,\n\t},\n};\n\nstatic const struct exynos5_usbdrd_phy_drvdata exynos5420_usbdrd_phy = {\n\t.phy_cfg\t\t= phy_cfg_exynos5,\n\t.phy_ops\t\t= &exynos5_usbdrd_phy_ops,\n\t.pmu_offset_usbdrd0_phy\t= EXYNOS5_USBDRD_PHY_CONTROL,\n\t.pmu_offset_usbdrd1_phy\t= EXYNOS5420_USBDRD1_PHY_CONTROL,\n\t.has_common_clk_gate\t= true,\n};\n\nstatic const struct exynos5_usbdrd_phy_drvdata exynos5250_usbdrd_phy = {\n\t.phy_cfg\t\t= phy_cfg_exynos5,\n\t.phy_ops\t\t= &exynos5_usbdrd_phy_ops,\n\t.pmu_offset_usbdrd0_phy\t= EXYNOS5_USBDRD_PHY_CONTROL,\n\t.has_common_clk_gate\t= true,\n};\n\nstatic const struct exynos5_usbdrd_phy_drvdata exynos5433_usbdrd_phy = {\n\t.phy_cfg\t\t= phy_cfg_exynos5,\n\t.phy_ops\t\t= &exynos5_usbdrd_phy_ops,\n\t.pmu_offset_usbdrd0_phy\t= EXYNOS5_USBDRD_PHY_CONTROL,\n\t.pmu_offset_usbdrd1_phy\t= EXYNOS5433_USBHOST30_PHY_CONTROL,\n\t.has_common_clk_gate\t= false,\n};\n\nstatic const struct exynos5_usbdrd_phy_drvdata exynos7_usbdrd_phy = {\n\t.phy_cfg\t\t= phy_cfg_exynos5,\n\t.phy_ops\t\t= &exynos5_usbdrd_phy_ops,\n\t.pmu_offset_usbdrd0_phy\t= EXYNOS5_USBDRD_PHY_CONTROL,\n\t.has_common_clk_gate\t= false,\n};\n\nstatic const struct exynos5_usbdrd_phy_drvdata exynos850_usbdrd_phy = {\n\t.phy_cfg\t\t= phy_cfg_exynos850,\n\t.phy_ops\t\t= &exynos850_usbdrd_phy_ops,\n\t.pmu_offset_usbdrd0_phy\t= EXYNOS5_USBDRD_PHY_CONTROL,\n\t.has_common_clk_gate\t= true,\n};\n\nstatic const struct of_device_id exynos5_usbdrd_phy_of_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos5250-usbdrd-phy\",\n\t\t.data = &exynos5250_usbdrd_phy\n\t}, {\n\t\t.compatible = \"samsung,exynos5420-usbdrd-phy\",\n\t\t.data = &exynos5420_usbdrd_phy\n\t}, {\n\t\t.compatible = \"samsung,exynos5433-usbdrd-phy\",\n\t\t.data = &exynos5433_usbdrd_phy\n\t}, {\n\t\t.compatible = \"samsung,exynos7-usbdrd-phy\",\n\t\t.data = &exynos7_usbdrd_phy\n\t}, {\n\t\t.compatible = \"samsung,exynos850-usbdrd-phy\",\n\t\t.data = &exynos850_usbdrd_phy\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, exynos5_usbdrd_phy_of_match);\n\nstatic int exynos5_usbdrd_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct exynos5_usbdrd_phy *phy_drd;\n\tstruct phy_provider *phy_provider;\n\tconst struct exynos5_usbdrd_phy_drvdata *drv_data;\n\tstruct regmap *reg_pmu;\n\tu32 pmu_offset;\n\tint i, ret;\n\tint channel;\n\n\tphy_drd = devm_kzalloc(dev, sizeof(*phy_drd), GFP_KERNEL);\n\tif (!phy_drd)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, phy_drd);\n\tphy_drd->dev = dev;\n\n\tphy_drd->reg_phy = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(phy_drd->reg_phy))\n\t\treturn PTR_ERR(phy_drd->reg_phy);\n\n\tdrv_data = of_device_get_match_data(dev);\n\tif (!drv_data)\n\t\treturn -EINVAL;\n\n\tphy_drd->drv_data = drv_data;\n\n\tret = exynos5_usbdrd_phy_clk_handle(phy_drd);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize clocks\\n\");\n\t\treturn ret;\n\t}\n\n\treg_pmu = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t   \"samsung,pmu-syscon\");\n\tif (IS_ERR(reg_pmu)) {\n\t\tdev_err(dev, \"Failed to lookup PMU regmap\\n\");\n\t\treturn PTR_ERR(reg_pmu);\n\t}\n\n\t \n\tchannel = of_alias_get_id(node, \"usbdrdphy\");\n\tif (channel < 0)\n\t\tdev_dbg(dev, \"Not a multi-controller usbdrd phy\\n\");\n\n\tswitch (channel) {\n\tcase 1:\n\t\tpmu_offset = phy_drd->drv_data->pmu_offset_usbdrd1_phy;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tpmu_offset = phy_drd->drv_data->pmu_offset_usbdrd0_phy;\n\t\tbreak;\n\t}\n\n\t \n\tphy_drd->vbus = devm_regulator_get(dev, \"vbus\");\n\tif (IS_ERR(phy_drd->vbus)) {\n\t\tret = PTR_ERR(phy_drd->vbus);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\n\t\tdev_warn(dev, \"Failed to get VBUS supply regulator\\n\");\n\t\tphy_drd->vbus = NULL;\n\t}\n\n\tphy_drd->vbus_boost = devm_regulator_get(dev, \"vbus-boost\");\n\tif (IS_ERR(phy_drd->vbus_boost)) {\n\t\tret = PTR_ERR(phy_drd->vbus_boost);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\n\t\tdev_warn(dev, \"Failed to get VBUS boost supply regulator\\n\");\n\t\tphy_drd->vbus_boost = NULL;\n\t}\n\n\tdev_vdbg(dev, \"Creating usbdrd_phy phy\\n\");\n\n\tfor (i = 0; i < EXYNOS5_DRDPHYS_NUM; i++) {\n\t\tstruct phy *phy = devm_phy_create(dev, NULL, drv_data->phy_ops);\n\n\t\tif (IS_ERR(phy)) {\n\t\t\tdev_err(dev, \"Failed to create usbdrd_phy phy\\n\");\n\t\t\treturn PTR_ERR(phy);\n\t\t}\n\n\t\tphy_drd->phys[i].phy = phy;\n\t\tphy_drd->phys[i].index = i;\n\t\tphy_drd->phys[i].reg_pmu = reg_pmu;\n\t\tphy_drd->phys[i].pmu_offset = pmu_offset;\n\t\tphy_drd->phys[i].phy_cfg = &drv_data->phy_cfg[i];\n\t\tphy_set_drvdata(phy, &phy_drd->phys[i]);\n\t}\n\n\tphy_provider = devm_of_phy_provider_register(dev,\n\t\t\t\t\t\t     exynos5_usbdrd_phy_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tdev_err(phy_drd->dev, \"Failed to register phy provider\\n\");\n\t\treturn PTR_ERR(phy_provider);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver exynos5_usb3drd_phy = {\n\t.probe\t= exynos5_usbdrd_phy_probe,\n\t.driver = {\n\t\t.of_match_table\t= exynos5_usbdrd_phy_of_match,\n\t\t.name\t\t= \"exynos5_usb3drd_phy\",\n\t\t.suppress_bind_attrs = true,\n\t}\n};\n\nmodule_platform_driver(exynos5_usb3drd_phy);\nMODULE_DESCRIPTION(\"Samsung Exynos5 SoCs USB 3.0 DRD controller PHY driver\");\nMODULE_AUTHOR(\"Vivek Gautam <gautam.vivek@samsung.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:exynos5_usb3drd_phy\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}