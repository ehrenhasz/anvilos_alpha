{
  "module_name": "ledtrig-gpio.c",
  "hash_id": "15ee91ca5db318297fc19bb98a6bdc163e1d3bd7a5dcf1cb5775b18d2022c5ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/trigger/ledtrig-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/interrupt.h>\n#include <linux/leds.h>\n#include <linux/slab.h>\n#include \"../leds.h\"\n\nstruct gpio_trig_data {\n\tstruct led_classdev *led;\n\n\tunsigned desired_brightness;\t \n\tunsigned inverted;\t\t \n\tunsigned gpio;\t\t\t \n};\n\nstatic irqreturn_t gpio_trig_irq(int irq, void *_led)\n{\n\tstruct led_classdev *led = _led;\n\tstruct gpio_trig_data *gpio_data = led_get_trigger_data(led);\n\tint tmp;\n\n\ttmp = gpio_get_value_cansleep(gpio_data->gpio);\n\tif (gpio_data->inverted)\n\t\ttmp = !tmp;\n\n\tif (tmp) {\n\t\tif (gpio_data->desired_brightness)\n\t\t\tled_set_brightness_nosleep(gpio_data->led,\n\t\t\t\t\t   gpio_data->desired_brightness);\n\t\telse\n\t\t\tled_set_brightness_nosleep(gpio_data->led, LED_FULL);\n\t} else {\n\t\tled_set_brightness_nosleep(gpio_data->led, LED_OFF);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t gpio_trig_brightness_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gpio_trig_data *gpio_data = led_trigger_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", gpio_data->desired_brightness);\n}\n\nstatic ssize_t gpio_trig_brightness_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t n)\n{\n\tstruct gpio_trig_data *gpio_data = led_trigger_get_drvdata(dev);\n\tunsigned desired_brightness;\n\tint ret;\n\n\tret = sscanf(buf, \"%u\", &desired_brightness);\n\tif (ret < 1 || desired_brightness > 255) {\n\t\tdev_err(dev, \"invalid value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_data->desired_brightness = desired_brightness;\n\n\treturn n;\n}\nstatic DEVICE_ATTR(desired_brightness, 0644, gpio_trig_brightness_show,\n\t\tgpio_trig_brightness_store);\n\nstatic ssize_t gpio_trig_inverted_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gpio_trig_data *gpio_data = led_trigger_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", gpio_data->inverted);\n}\n\nstatic ssize_t gpio_trig_inverted_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t n)\n{\n\tstruct led_classdev *led = led_trigger_get_led(dev);\n\tstruct gpio_trig_data *gpio_data = led_trigger_get_drvdata(dev);\n\tunsigned long inverted;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &inverted);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (inverted > 1)\n\t\treturn -EINVAL;\n\n\tgpio_data->inverted = inverted;\n\n\t \n\tif (gpio_is_valid(gpio_data->gpio))\n\t\tgpio_trig_irq(0, led);\n\n\treturn n;\n}\nstatic DEVICE_ATTR(inverted, 0644, gpio_trig_inverted_show,\n\t\tgpio_trig_inverted_store);\n\nstatic ssize_t gpio_trig_gpio_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gpio_trig_data *gpio_data = led_trigger_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", gpio_data->gpio);\n}\n\nstatic ssize_t gpio_trig_gpio_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t n)\n{\n\tstruct led_classdev *led = led_trigger_get_led(dev);\n\tstruct gpio_trig_data *gpio_data = led_trigger_get_drvdata(dev);\n\tunsigned gpio;\n\tint ret;\n\n\tret = sscanf(buf, \"%u\", &gpio);\n\tif (ret < 1) {\n\t\tdev_err(dev, \"couldn't read gpio number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (gpio_data->gpio == gpio)\n\t\treturn n;\n\n\tif (!gpio_is_valid(gpio)) {\n\t\tif (gpio_is_valid(gpio_data->gpio))\n\t\t\tfree_irq(gpio_to_irq(gpio_data->gpio), led);\n\t\tgpio_data->gpio = gpio;\n\t\treturn n;\n\t}\n\n\tret = request_threaded_irq(gpio_to_irq(gpio), NULL, gpio_trig_irq,\n\t\t\tIRQF_ONESHOT | IRQF_SHARED | IRQF_TRIGGER_RISING\n\t\t\t| IRQF_TRIGGER_FALLING, \"ledtrig-gpio\", led);\n\tif (ret) {\n\t\tdev_err(dev, \"request_irq failed with error %d\\n\", ret);\n\t} else {\n\t\tif (gpio_is_valid(gpio_data->gpio))\n\t\t\tfree_irq(gpio_to_irq(gpio_data->gpio), led);\n\t\tgpio_data->gpio = gpio;\n\t\t \n\t\tgpio_trig_irq(0, led);\n\t}\n\n\treturn ret ? ret : n;\n}\nstatic DEVICE_ATTR(gpio, 0644, gpio_trig_gpio_show, gpio_trig_gpio_store);\n\nstatic struct attribute *gpio_trig_attrs[] = {\n\t&dev_attr_desired_brightness.attr,\n\t&dev_attr_inverted.attr,\n\t&dev_attr_gpio.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(gpio_trig);\n\nstatic int gpio_trig_activate(struct led_classdev *led)\n{\n\tstruct gpio_trig_data *gpio_data;\n\n\tgpio_data = kzalloc(sizeof(*gpio_data), GFP_KERNEL);\n\tif (!gpio_data)\n\t\treturn -ENOMEM;\n\n\tgpio_data->led = led;\n\tgpio_data->gpio = -ENOENT;\n\n\tled_set_trigger_data(led, gpio_data);\n\n\treturn 0;\n}\n\nstatic void gpio_trig_deactivate(struct led_classdev *led)\n{\n\tstruct gpio_trig_data *gpio_data = led_get_trigger_data(led);\n\n\tif (gpio_is_valid(gpio_data->gpio))\n\t\tfree_irq(gpio_to_irq(gpio_data->gpio), led);\n\tkfree(gpio_data);\n}\n\nstatic struct led_trigger gpio_led_trigger = {\n\t.name\t\t= \"gpio\",\n\t.activate\t= gpio_trig_activate,\n\t.deactivate\t= gpio_trig_deactivate,\n\t.groups\t\t= gpio_trig_groups,\n};\nmodule_led_trigger(gpio_led_trigger);\n\nMODULE_AUTHOR(\"Felipe Balbi <me@felipebalbi.com>\");\nMODULE_DESCRIPTION(\"GPIO LED trigger\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}