{
  "module_name": "ledtrig-pattern.c",
  "hash_id": "2de954f7356d9ea348e42e5c568e991f473e150a0a73890662e0f7139f81f242",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/trigger/ledtrig-pattern.c",
  "human_readable_source": "\n\n \n\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n\n#define MAX_PATTERNS\t\t1024\n \n#define UPDATE_INTERVAL\t\t50\n\nstruct pattern_trig_data {\n\tstruct led_classdev *led_cdev;\n\tstruct led_pattern patterns[MAX_PATTERNS];\n\tstruct led_pattern *curr;\n\tstruct led_pattern *next;\n\tstruct mutex lock;\n\tu32 npatterns;\n\tint repeat;\n\tint last_repeat;\n\tint delta_t;\n\tbool is_indefinite;\n\tbool is_hw_pattern;\n\tstruct timer_list timer;\n};\n\nstatic void pattern_trig_update_patterns(struct pattern_trig_data *data)\n{\n\tdata->curr = data->next;\n\tif (!data->is_indefinite && data->curr == data->patterns)\n\t\tdata->repeat--;\n\n\tif (data->next == data->patterns + data->npatterns - 1)\n\t\tdata->next = data->patterns;\n\telse\n\t\tdata->next++;\n\n\tdata->delta_t = 0;\n}\n\nstatic int pattern_trig_compute_brightness(struct pattern_trig_data *data)\n{\n\tint step_brightness;\n\n\t \n\tif (data->delta_t == 0 || data->curr->delta_t < UPDATE_INTERVAL)\n\t\treturn data->curr->brightness;\n\n\tstep_brightness = abs(data->next->brightness - data->curr->brightness);\n\tstep_brightness = data->delta_t * step_brightness / data->curr->delta_t;\n\n\tif (data->next->brightness > data->curr->brightness)\n\t\treturn data->curr->brightness + step_brightness;\n\telse\n\t\treturn data->curr->brightness - step_brightness;\n}\n\nstatic void pattern_trig_timer_function(struct timer_list *t)\n{\n\tstruct pattern_trig_data *data = from_timer(data, t, timer);\n\n\tfor (;;) {\n\t\tif (!data->is_indefinite && !data->repeat)\n\t\t\tbreak;\n\n\t\tif (data->curr->brightness == data->next->brightness) {\n\t\t\t \n\t\t\tled_set_brightness(data->led_cdev,\n\t\t\t\t\t   data->curr->brightness);\n\t\t\tmod_timer(&data->timer,\n\t\t\t\t  jiffies + msecs_to_jiffies(data->curr->delta_t));\n\t\t\tif (!data->next->delta_t) {\n\t\t\t\t \n\t\t\t\tpattern_trig_update_patterns(data);\n\t\t\t}\n\t\t\t \n\t\t\tpattern_trig_update_patterns(data);\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\t\t\tif (data->delta_t > data->curr->delta_t) {\n\t\t\t\tpattern_trig_update_patterns(data);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tled_set_brightness(data->led_cdev,\n\t\t\t\t\t   pattern_trig_compute_brightness(data));\n\t\t\tmod_timer(&data->timer,\n\t\t\t\t  jiffies + msecs_to_jiffies(UPDATE_INTERVAL));\n\n\t\t\t \n\t\t\tdata->delta_t += UPDATE_INTERVAL;\n\t\t}\n\n\t\tbreak;\n\t}\n}\n\nstatic int pattern_trig_start_pattern(struct led_classdev *led_cdev)\n{\n\tstruct pattern_trig_data *data = led_cdev->trigger_data;\n\n\tif (!data->npatterns)\n\t\treturn 0;\n\n\tif (data->is_hw_pattern) {\n\t\treturn led_cdev->pattern_set(led_cdev, data->patterns,\n\t\t\t\t\t     data->npatterns, data->repeat);\n\t}\n\n\t \n\tif (data->npatterns < 2)\n\t\treturn -EINVAL;\n\n\tdata->delta_t = 0;\n\tdata->curr = data->patterns;\n\tdata->next = data->patterns + 1;\n\tdata->timer.expires = jiffies;\n\tadd_timer(&data->timer);\n\n\treturn 0;\n}\n\nstatic ssize_t repeat_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct pattern_trig_data *data = led_cdev->trigger_data;\n\tint repeat;\n\n\tmutex_lock(&data->lock);\n\n\trepeat = data->last_repeat;\n\n\tmutex_unlock(&data->lock);\n\n\treturn sysfs_emit(buf, \"%d\\n\", repeat);\n}\n\nstatic ssize_t repeat_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct pattern_trig_data *data = led_cdev->trigger_data;\n\tint err, res;\n\n\terr = kstrtos32(buf, 10, &res);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (res < -1 || res == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\n\tdel_timer_sync(&data->timer);\n\n\tif (data->is_hw_pattern)\n\t\tled_cdev->pattern_clear(led_cdev);\n\n\tdata->last_repeat = data->repeat = res;\n\t \n\tif (data->repeat == -1)\n\t\tdata->is_indefinite = true;\n\telse\n\t\tdata->is_indefinite = false;\n\n\terr = pattern_trig_start_pattern(led_cdev);\n\n\tmutex_unlock(&data->lock);\n\treturn err < 0 ? err : count;\n}\n\nstatic DEVICE_ATTR_RW(repeat);\n\nstatic ssize_t pattern_trig_show_patterns(struct pattern_trig_data *data,\n\t\t\t\t\t  char *buf, bool hw_pattern)\n{\n\tssize_t count = 0;\n\tint i;\n\n\tmutex_lock(&data->lock);\n\n\tif (!data->npatterns || (data->is_hw_pattern ^ hw_pattern))\n\t\tgoto out;\n\n\tfor (i = 0; i < data->npatterns; i++) {\n\t\tcount += scnprintf(buf + count, PAGE_SIZE - count,\n\t\t\t\t   \"%d %u \",\n\t\t\t\t   data->patterns[i].brightness,\n\t\t\t\t   data->patterns[i].delta_t);\n\t}\n\n\tbuf[count - 1] = '\\n';\n\nout:\n\tmutex_unlock(&data->lock);\n\treturn count;\n}\n\nstatic int pattern_trig_store_patterns_string(struct pattern_trig_data *data,\n\t\t\t\t\t      const char *buf, size_t count)\n{\n\tint ccount, cr, offset = 0;\n\n\twhile (offset < count - 1 && data->npatterns < MAX_PATTERNS) {\n\t\tcr = 0;\n\t\tccount = sscanf(buf + offset, \"%u %u %n\",\n\t\t\t\t&data->patterns[data->npatterns].brightness,\n\t\t\t\t&data->patterns[data->npatterns].delta_t, &cr);\n\n\t\tif (ccount != 2 ||\n\t\t    data->patterns[data->npatterns].brightness > data->led_cdev->max_brightness) {\n\t\t\tdata->npatterns = 0;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset += cr;\n\t\tdata->npatterns++;\n\t}\n\n\treturn 0;\n}\n\nstatic int pattern_trig_store_patterns_int(struct pattern_trig_data *data,\n\t\t\t\t\t   const u32 *buf, size_t count)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i += 2) {\n\t\tdata->patterns[data->npatterns].brightness = buf[i];\n\t\tdata->patterns[data->npatterns].delta_t = buf[i + 1];\n\t\tdata->npatterns++;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t pattern_trig_store_patterns(struct led_classdev *led_cdev,\n\t\t\t\t\t   const char *buf, const u32 *buf_int,\n\t\t\t\t\t   size_t count, bool hw_pattern)\n{\n\tstruct pattern_trig_data *data = led_cdev->trigger_data;\n\tint err = 0;\n\n\tmutex_lock(&data->lock);\n\n\tdel_timer_sync(&data->timer);\n\n\tif (data->is_hw_pattern)\n\t\tled_cdev->pattern_clear(led_cdev);\n\n\tdata->is_hw_pattern = hw_pattern;\n\tdata->npatterns = 0;\n\n\tif (buf)\n\t\terr = pattern_trig_store_patterns_string(data, buf, count);\n\telse\n\t\terr = pattern_trig_store_patterns_int(data, buf_int, count);\n\tif (err)\n\t\tgoto out;\n\n\terr = pattern_trig_start_pattern(led_cdev);\n\tif (err)\n\t\tdata->npatterns = 0;\n\nout:\n\tmutex_unlock(&data->lock);\n\treturn err < 0 ? err : count;\n}\n\nstatic ssize_t pattern_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct pattern_trig_data *data = led_cdev->trigger_data;\n\n\treturn pattern_trig_show_patterns(data, buf, false);\n}\n\nstatic ssize_t pattern_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\n\treturn pattern_trig_store_patterns(led_cdev, buf, NULL, count, false);\n}\n\nstatic DEVICE_ATTR_RW(pattern);\n\nstatic ssize_t hw_pattern_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct pattern_trig_data *data = led_cdev->trigger_data;\n\n\treturn pattern_trig_show_patterns(data, buf, true);\n}\n\nstatic ssize_t hw_pattern_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\n\treturn pattern_trig_store_patterns(led_cdev, buf, NULL, count, true);\n}\n\nstatic DEVICE_ATTR_RW(hw_pattern);\n\nstatic umode_t pattern_trig_attrs_mode(struct kobject *kobj,\n\t\t\t\t       struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\n\tif (attr == &dev_attr_repeat.attr || attr == &dev_attr_pattern.attr)\n\t\treturn attr->mode;\n\telse if (attr == &dev_attr_hw_pattern.attr && led_cdev->pattern_set)\n\t\treturn attr->mode;\n\n\treturn 0;\n}\n\nstatic struct attribute *pattern_trig_attrs[] = {\n\t&dev_attr_pattern.attr,\n\t&dev_attr_hw_pattern.attr,\n\t&dev_attr_repeat.attr,\n\tNULL\n};\n\nstatic const struct attribute_group pattern_trig_group = {\n\t.attrs = pattern_trig_attrs,\n\t.is_visible = pattern_trig_attrs_mode,\n};\n\nstatic const struct attribute_group *pattern_trig_groups[] = {\n\t&pattern_trig_group,\n\tNULL,\n};\n\nstatic void pattern_init(struct led_classdev *led_cdev)\n{\n\tunsigned int size = 0;\n\tu32 *pattern;\n\tint err;\n\n\tpattern = led_get_default_pattern(led_cdev, &size);\n\tif (!pattern)\n\t\treturn;\n\n\tif (size % 2) {\n\t\tdev_warn(led_cdev->dev, \"Expected pattern of tuples\\n\");\n\t\tgoto out;\n\t}\n\n\terr = pattern_trig_store_patterns(led_cdev, NULL, pattern, size, false);\n\tif (err < 0)\n\t\tdev_warn(led_cdev->dev,\n\t\t\t \"Pattern initialization failed with error %d\\n\", err);\n\nout:\n\tkfree(pattern);\n}\n\nstatic int pattern_trig_activate(struct led_classdev *led_cdev)\n{\n\tstruct pattern_trig_data *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (!!led_cdev->pattern_set ^ !!led_cdev->pattern_clear) {\n\t\tdev_warn(led_cdev->dev,\n\t\t\t \"Hardware pattern ops validation failed\\n\");\n\t\tled_cdev->pattern_set = NULL;\n\t\tled_cdev->pattern_clear = NULL;\n\t}\n\n\tdata->is_indefinite = true;\n\tdata->last_repeat = -1;\n\tmutex_init(&data->lock);\n\tdata->led_cdev = led_cdev;\n\tled_set_trigger_data(led_cdev, data);\n\ttimer_setup(&data->timer, pattern_trig_timer_function, 0);\n\tled_cdev->activated = true;\n\n\tif (led_cdev->flags & LED_INIT_DEFAULT_TRIGGER) {\n\t\tpattern_init(led_cdev);\n\t\t \n\t\tled_cdev->flags &= ~LED_INIT_DEFAULT_TRIGGER;\n\t}\n\n\treturn 0;\n}\n\nstatic void pattern_trig_deactivate(struct led_classdev *led_cdev)\n{\n\tstruct pattern_trig_data *data = led_cdev->trigger_data;\n\n\tif (!led_cdev->activated)\n\t\treturn;\n\n\tif (led_cdev->pattern_clear)\n\t\tled_cdev->pattern_clear(led_cdev);\n\n\ttimer_shutdown_sync(&data->timer);\n\n\tled_set_brightness(led_cdev, LED_OFF);\n\tkfree(data);\n\tled_cdev->activated = false;\n}\n\nstatic struct led_trigger pattern_led_trigger = {\n\t.name = \"pattern\",\n\t.activate = pattern_trig_activate,\n\t.deactivate = pattern_trig_deactivate,\n\t.groups = pattern_trig_groups,\n};\n\nstatic int __init pattern_trig_init(void)\n{\n\treturn led_trigger_register(&pattern_led_trigger);\n}\n\nstatic void __exit pattern_trig_exit(void)\n{\n\tled_trigger_unregister(&pattern_led_trigger);\n}\n\nmodule_init(pattern_trig_init);\nmodule_exit(pattern_trig_exit);\n\nMODULE_AUTHOR(\"Raphael Teysseyre <rteysseyre@gmail.com>\");\nMODULE_AUTHOR(\"Baolin Wang <baolin.wang@linaro.org>\");\nMODULE_DESCRIPTION(\"LED Pattern trigger\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}