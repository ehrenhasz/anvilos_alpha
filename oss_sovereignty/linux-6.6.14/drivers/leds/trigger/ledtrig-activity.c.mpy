{
  "module_name": "ledtrig-activity.c",
  "hash_id": "44ba8794acdbb8542c6de6133579f8b383bdde3d47f0737ad04d90ee9bc0049c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/trigger/ledtrig-activity.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/kernel_stat.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/panic_notifier.h>\n#include <linux/reboot.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include \"../leds.h\"\n\nstatic int panic_detected;\n\nstruct activity_data {\n\tstruct timer_list timer;\n\tstruct led_classdev *led_cdev;\n\tu64 last_used;\n\tu64 last_boot;\n\tint time_left;\n\tint state;\n\tint invert;\n};\n\nstatic void led_activity_function(struct timer_list *t)\n{\n\tstruct activity_data *activity_data = from_timer(activity_data, t,\n\t\t\t\t\t\t\t timer);\n\tstruct led_classdev *led_cdev = activity_data->led_cdev;\n\tunsigned int target;\n\tunsigned int usage;\n\tint delay;\n\tu64 curr_used;\n\tu64 curr_boot;\n\ts32 diff_used;\n\ts32 diff_boot;\n\tint cpus;\n\tint i;\n\n\tif (test_and_clear_bit(LED_BLINK_BRIGHTNESS_CHANGE, &led_cdev->work_flags))\n\t\tled_cdev->blink_brightness = led_cdev->new_blink_brightness;\n\n\tif (unlikely(panic_detected)) {\n\t\t \n\t\tled_set_brightness_nosleep(led_cdev, led_cdev->blink_brightness);\n\t\treturn;\n\t}\n\n\tcpus = 0;\n\tcurr_used = 0;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct kernel_cpustat kcpustat;\n\n\t\tkcpustat_cpu_fetch(&kcpustat, i);\n\n\t\tcurr_used += kcpustat.cpustat[CPUTIME_USER]\n\t\t\t  +  kcpustat.cpustat[CPUTIME_NICE]\n\t\t\t  +  kcpustat.cpustat[CPUTIME_SYSTEM]\n\t\t\t  +  kcpustat.cpustat[CPUTIME_SOFTIRQ]\n\t\t\t  +  kcpustat.cpustat[CPUTIME_IRQ];\n\t\tcpus++;\n\t}\n\n\t \n\tcurr_boot = ktime_get_boottime_ns() * cpus;\n\tdiff_boot = (curr_boot - activity_data->last_boot) >> 16;\n\tdiff_used = (curr_used - activity_data->last_used) >> 16;\n\tactivity_data->last_boot = curr_boot;\n\tactivity_data->last_used = curr_used;\n\n\tif (diff_boot <= 0 || diff_used < 0)\n\t\tusage = 0;\n\telse if (diff_used >= diff_boot)\n\t\tusage = 100;\n\telse\n\t\tusage = 100 * diff_used / diff_boot;\n\n\t \n\n\tactivity_data->time_left -= 100;\n\tif (activity_data->time_left <= 0) {\n\t\tactivity_data->time_left = 0;\n\t\tactivity_data->state = !activity_data->state;\n\t\tled_set_brightness_nosleep(led_cdev,\n\t\t\t(activity_data->state ^ activity_data->invert) ?\n\t\t\tled_cdev->blink_brightness : LED_OFF);\n\t}\n\n\ttarget = (cpus > 1) ? (100 / cpus) : 50;\n\n\tif (usage < target)\n\t\tdelay = activity_data->state ?\n\t\t\t10 :                         \n\t\t\t990 - 900 * usage / target;  \n\telse\n\t\tdelay = activity_data->state ?\n\t\t\t10 + 80 * (usage - target) / (100 - target) :  \n\t\t\t90 - 80 * (usage - target) / (100 - target);   \n\n\n\tif (!activity_data->time_left || delay <= activity_data->time_left)\n\t\tactivity_data->time_left = delay;\n\n\tdelay = min_t(int, activity_data->time_left, 100);\n\tmod_timer(&activity_data->timer, jiffies + msecs_to_jiffies(delay));\n}\n\nstatic ssize_t led_invert_show(struct device *dev,\n                               struct device_attribute *attr, char *buf)\n{\n\tstruct activity_data *activity_data = led_trigger_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", activity_data->invert);\n}\n\nstatic ssize_t led_invert_store(struct device *dev,\n                                struct device_attribute *attr,\n                                const char *buf, size_t size)\n{\n\tstruct activity_data *activity_data = led_trigger_get_drvdata(dev);\n\tunsigned long state;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tactivity_data->invert = !!state;\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR(invert, 0644, led_invert_show, led_invert_store);\n\nstatic struct attribute *activity_led_attrs[] = {\n\t&dev_attr_invert.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(activity_led);\n\nstatic int activity_activate(struct led_classdev *led_cdev)\n{\n\tstruct activity_data *activity_data;\n\n\tactivity_data = kzalloc(sizeof(*activity_data), GFP_KERNEL);\n\tif (!activity_data)\n\t\treturn -ENOMEM;\n\n\tled_set_trigger_data(led_cdev, activity_data);\n\n\tactivity_data->led_cdev = led_cdev;\n\ttimer_setup(&activity_data->timer, led_activity_function, 0);\n\tif (!led_cdev->blink_brightness)\n\t\tled_cdev->blink_brightness = led_cdev->max_brightness;\n\tled_activity_function(&activity_data->timer);\n\tset_bit(LED_BLINK_SW, &led_cdev->work_flags);\n\n\treturn 0;\n}\n\nstatic void activity_deactivate(struct led_classdev *led_cdev)\n{\n\tstruct activity_data *activity_data = led_get_trigger_data(led_cdev);\n\n\ttimer_shutdown_sync(&activity_data->timer);\n\tkfree(activity_data);\n\tclear_bit(LED_BLINK_SW, &led_cdev->work_flags);\n}\n\nstatic struct led_trigger activity_led_trigger = {\n\t.name       = \"activity\",\n\t.activate   = activity_activate,\n\t.deactivate = activity_deactivate,\n\t.groups     = activity_led_groups,\n};\n\nstatic int activity_reboot_notifier(struct notifier_block *nb,\n                                    unsigned long code, void *unused)\n{\n\tled_trigger_unregister(&activity_led_trigger);\n\treturn NOTIFY_DONE;\n}\n\nstatic int activity_panic_notifier(struct notifier_block *nb,\n                                   unsigned long code, void *unused)\n{\n\tpanic_detected = 1;\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block activity_reboot_nb = {\n\t.notifier_call = activity_reboot_notifier,\n};\n\nstatic struct notifier_block activity_panic_nb = {\n\t.notifier_call = activity_panic_notifier,\n};\n\nstatic int __init activity_init(void)\n{\n\tint rc = led_trigger_register(&activity_led_trigger);\n\n\tif (!rc) {\n\t\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t\t       &activity_panic_nb);\n\t\tregister_reboot_notifier(&activity_reboot_nb);\n\t}\n\treturn rc;\n}\n\nstatic void __exit activity_exit(void)\n{\n\tunregister_reboot_notifier(&activity_reboot_nb);\n\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t &activity_panic_nb);\n\tled_trigger_unregister(&activity_led_trigger);\n}\n\nmodule_init(activity_init);\nmodule_exit(activity_exit);\n\nMODULE_AUTHOR(\"Willy Tarreau <w@1wt.eu>\");\nMODULE_DESCRIPTION(\"Activity LED trigger\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}