{
  "module_name": "ledtrig-tty.c",
  "hash_id": "631c62a0019c2073618110feb094963d8d275710eb32f3263da352ef39e07423",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/trigger/ledtrig-tty.c",
  "human_readable_source": "\n\n#include <linux/delay.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <uapi/linux/serial.h>\n\n#define LEDTRIG_TTY_INTERVAL\t50\n\nstruct ledtrig_tty_data {\n\tstruct led_classdev *led_cdev;\n\tstruct delayed_work dwork;\n\tstruct mutex mutex;\n\tconst char *ttyname;\n\tstruct tty_struct *tty;\n\tint rx, tx;\n};\n\nstatic void ledtrig_tty_restart(struct ledtrig_tty_data *trigger_data)\n{\n\tschedule_delayed_work(&trigger_data->dwork, 0);\n}\n\nstatic ssize_t ttyname_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ledtrig_tty_data *trigger_data = led_trigger_get_drvdata(dev);\n\tssize_t len = 0;\n\n\tmutex_lock(&trigger_data->mutex);\n\n\tif (trigger_data->ttyname)\n\t\tlen = sprintf(buf, \"%s\\n\", trigger_data->ttyname);\n\n\tmutex_unlock(&trigger_data->mutex);\n\n\treturn len;\n}\n\nstatic ssize_t ttyname_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t size)\n{\n\tstruct ledtrig_tty_data *trigger_data = led_trigger_get_drvdata(dev);\n\tchar *ttyname;\n\tssize_t ret = size;\n\tbool running;\n\n\tif (size > 0 && buf[size - 1] == '\\n')\n\t\tsize -= 1;\n\n\tif (size) {\n\t\tttyname = kmemdup_nul(buf, size, GFP_KERNEL);\n\t\tif (!ttyname)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tttyname = NULL;\n\t}\n\n\tmutex_lock(&trigger_data->mutex);\n\n\trunning = trigger_data->ttyname != NULL;\n\n\tkfree(trigger_data->ttyname);\n\ttty_kref_put(trigger_data->tty);\n\ttrigger_data->tty = NULL;\n\n\ttrigger_data->ttyname = ttyname;\n\n\tmutex_unlock(&trigger_data->mutex);\n\n\tif (ttyname && !running)\n\t\tledtrig_tty_restart(trigger_data);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(ttyname);\n\nstatic void ledtrig_tty_work(struct work_struct *work)\n{\n\tstruct ledtrig_tty_data *trigger_data =\n\t\tcontainer_of(work, struct ledtrig_tty_data, dwork.work);\n\tstruct serial_icounter_struct icount;\n\tint ret;\n\n\tmutex_lock(&trigger_data->mutex);\n\n\tif (!trigger_data->ttyname) {\n\t\t \n\t\tmutex_unlock(&trigger_data->mutex);\n\t\treturn;\n\t}\n\n\t \n\tif (!trigger_data->tty) {\n\t\tdev_t devno;\n\t\tstruct tty_struct *tty;\n\t\tint ret;\n\n\t\tret = tty_dev_name_to_number(trigger_data->ttyname, &devno);\n\t\tif (ret < 0)\n\t\t\t \n\t\t\tgoto out;\n\n\t\ttty = tty_kopen_shared(devno);\n\t\tif (IS_ERR(tty) || !tty)\n\t\t\t \n\t\t\tgoto out;\n\n\t\ttrigger_data->tty = tty;\n\t}\n\n\tret = tty_get_icount(trigger_data->tty, &icount);\n\tif (ret) {\n\t\tdev_info(trigger_data->tty->dev, \"Failed to get icount, stopped polling\\n\");\n\t\tmutex_unlock(&trigger_data->mutex);\n\t\treturn;\n\t}\n\n\tif (icount.rx != trigger_data->rx ||\n\t    icount.tx != trigger_data->tx) {\n\t\tunsigned long interval = LEDTRIG_TTY_INTERVAL;\n\n\t\tled_blink_set_oneshot(trigger_data->led_cdev, &interval,\n\t\t\t\t      &interval, 0);\n\n\t\ttrigger_data->rx = icount.rx;\n\t\ttrigger_data->tx = icount.tx;\n\t}\n\nout:\n\tmutex_unlock(&trigger_data->mutex);\n\tschedule_delayed_work(&trigger_data->dwork,\n\t\t\t      msecs_to_jiffies(LEDTRIG_TTY_INTERVAL * 2));\n}\n\nstatic struct attribute *ledtrig_tty_attrs[] = {\n\t&dev_attr_ttyname.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(ledtrig_tty);\n\nstatic int ledtrig_tty_activate(struct led_classdev *led_cdev)\n{\n\tstruct ledtrig_tty_data *trigger_data;\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\treturn -ENOMEM;\n\n\tled_set_trigger_data(led_cdev, trigger_data);\n\n\tINIT_DELAYED_WORK(&trigger_data->dwork, ledtrig_tty_work);\n\ttrigger_data->led_cdev = led_cdev;\n\tmutex_init(&trigger_data->mutex);\n\n\treturn 0;\n}\n\nstatic void ledtrig_tty_deactivate(struct led_classdev *led_cdev)\n{\n\tstruct ledtrig_tty_data *trigger_data = led_get_trigger_data(led_cdev);\n\n\tcancel_delayed_work_sync(&trigger_data->dwork);\n\n\tkfree(trigger_data->ttyname);\n\ttty_kref_put(trigger_data->tty);\n\ttrigger_data->tty = NULL;\n\n\tkfree(trigger_data);\n}\n\nstatic struct led_trigger ledtrig_tty = {\n\t.name = \"tty\",\n\t.activate = ledtrig_tty_activate,\n\t.deactivate = ledtrig_tty_deactivate,\n\t.groups = ledtrig_tty_groups,\n};\nmodule_led_trigger(ledtrig_tty);\n\nMODULE_AUTHOR(\"Uwe Kleine-K\u00f6nig <u.kleine-koenig@pengutronix.de>\");\nMODULE_DESCRIPTION(\"UART LED trigger\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}