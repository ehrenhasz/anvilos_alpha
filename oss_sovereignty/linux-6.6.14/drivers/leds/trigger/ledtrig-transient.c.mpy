{
  "module_name": "ledtrig-transient.c",
  "hash_id": "aa8f72eb453207204b685fd73856ba364ec109c5f4a882233675a1f84ecf8b8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/trigger/ledtrig-transient.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/leds.h>\n#include \"../leds.h\"\n\nstruct transient_trig_data {\n\tint activate;\n\tint state;\n\tint restore_state;\n\tunsigned long duration;\n\tstruct timer_list timer;\n\tstruct led_classdev *led_cdev;\n};\n\nstatic void transient_timer_function(struct timer_list *t)\n{\n\tstruct transient_trig_data *transient_data =\n\t\tfrom_timer(transient_data, t, timer);\n\tstruct led_classdev *led_cdev = transient_data->led_cdev;\n\n\ttransient_data->activate = 0;\n\tled_set_brightness_nosleep(led_cdev, transient_data->restore_state);\n}\n\nstatic ssize_t transient_activate_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct transient_trig_data *transient_data =\n\t\tled_trigger_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", transient_data->activate);\n}\n\nstatic ssize_t transient_activate_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct led_classdev *led_cdev = led_trigger_get_led(dev);\n\tstruct transient_trig_data *transient_data =\n\t\tled_trigger_get_drvdata(dev);\n\tunsigned long state;\n\tssize_t ret;\n\n\tret = kstrtoul(buf, 10, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state != 1 && state != 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (state == 0 && transient_data->activate == 1) {\n\t\tdel_timer(&transient_data->timer);\n\t\ttransient_data->activate = state;\n\t\tled_set_brightness_nosleep(led_cdev,\n\t\t\t\t\ttransient_data->restore_state);\n\t\treturn size;\n\t}\n\n\t \n\tif (state == 1 && transient_data->activate == 0 &&\n\t    transient_data->duration != 0) {\n\t\ttransient_data->activate = state;\n\t\tled_set_brightness_nosleep(led_cdev, transient_data->state);\n\t\ttransient_data->restore_state =\n\t\t    (transient_data->state == LED_FULL) ? LED_OFF : LED_FULL;\n\t\tmod_timer(&transient_data->timer,\n\t\t\t  jiffies + msecs_to_jiffies(transient_data->duration));\n\t}\n\n\t \n\t \n\n\treturn size;\n}\n\nstatic ssize_t transient_duration_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct transient_trig_data *transient_data = led_trigger_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lu\\n\", transient_data->duration);\n}\n\nstatic ssize_t transient_duration_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct transient_trig_data *transient_data =\n\t\tled_trigger_get_drvdata(dev);\n\tunsigned long state;\n\tssize_t ret;\n\n\tret = kstrtoul(buf, 10, &state);\n\tif (ret)\n\t\treturn ret;\n\n\ttransient_data->duration = state;\n\treturn size;\n}\n\nstatic ssize_t transient_state_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct transient_trig_data *transient_data =\n\t\tled_trigger_get_drvdata(dev);\n\tint state;\n\n\tstate = (transient_data->state == LED_FULL) ? 1 : 0;\n\treturn sprintf(buf, \"%d\\n\", state);\n}\n\nstatic ssize_t transient_state_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct transient_trig_data *transient_data =\n\t\tled_trigger_get_drvdata(dev);\n\tunsigned long state;\n\tssize_t ret;\n\n\tret = kstrtoul(buf, 10, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state != 1 && state != 0)\n\t\treturn -EINVAL;\n\n\ttransient_data->state = (state == 1) ? LED_FULL : LED_OFF;\n\treturn size;\n}\n\nstatic DEVICE_ATTR(activate, 0644, transient_activate_show,\n\t\t   transient_activate_store);\nstatic DEVICE_ATTR(duration, 0644, transient_duration_show,\n\t\t   transient_duration_store);\nstatic DEVICE_ATTR(state, 0644, transient_state_show, transient_state_store);\n\nstatic struct attribute *transient_trig_attrs[] = {\n\t&dev_attr_activate.attr,\n\t&dev_attr_duration.attr,\n\t&dev_attr_state.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(transient_trig);\n\nstatic int transient_trig_activate(struct led_classdev *led_cdev)\n{\n\tstruct transient_trig_data *tdata;\n\n\ttdata = kzalloc(sizeof(struct transient_trig_data), GFP_KERNEL);\n\tif (!tdata)\n\t\treturn -ENOMEM;\n\n\tled_set_trigger_data(led_cdev, tdata);\n\ttdata->led_cdev = led_cdev;\n\n\ttimer_setup(&tdata->timer, transient_timer_function, 0);\n\n\treturn 0;\n}\n\nstatic void transient_trig_deactivate(struct led_classdev *led_cdev)\n{\n\tstruct transient_trig_data *transient_data = led_get_trigger_data(led_cdev);\n\n\ttimer_shutdown_sync(&transient_data->timer);\n\tled_set_brightness_nosleep(led_cdev, transient_data->restore_state);\n\tkfree(transient_data);\n}\n\nstatic struct led_trigger transient_trigger = {\n\t.name     = \"transient\",\n\t.activate = transient_trig_activate,\n\t.deactivate = transient_trig_deactivate,\n\t.groups = transient_trig_groups,\n};\nmodule_led_trigger(transient_trigger);\n\nMODULE_AUTHOR(\"Shuah Khan <shuahkhan@gmail.com>\");\nMODULE_DESCRIPTION(\"Transient LED trigger\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}