{
  "module_name": "ledtrig-netdev.c",
  "hash_id": "ae40db8e74fe790dc3fd1529ccab84582d43a62ea5558204e937d8c229c4842c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/trigger/ledtrig-netdev.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/atomic.h>\n#include <linux/ctype.h>\n#include <linux/device.h>\n#include <linux/ethtool.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/mutex.h>\n#include <linux/rtnetlink.h>\n#include <linux/timer.h>\n#include \"../leds.h\"\n\n#define NETDEV_LED_DEFAULT_INTERVAL\t50\n\n \n\nstruct led_netdev_data {\n\tstruct mutex lock;\n\n\tstruct delayed_work work;\n\tstruct notifier_block notifier;\n\n\tstruct led_classdev *led_cdev;\n\tstruct net_device *net_dev;\n\n\tchar device_name[IFNAMSIZ];\n\tatomic_t interval;\n\tunsigned int last_activity;\n\n\tunsigned long mode;\n\tint link_speed;\n\tu8 duplex;\n\n\tbool carrier_link_up;\n\tbool hw_control;\n};\n\nstatic void set_baseline_state(struct led_netdev_data *trigger_data)\n{\n\tint current_brightness;\n\tstruct led_classdev *led_cdev = trigger_data->led_cdev;\n\n\t \n\tif (trigger_data->hw_control) {\n\t\tled_cdev->hw_control_set(led_cdev, trigger_data->mode);\n\n\t\treturn;\n\t}\n\n\tcurrent_brightness = led_cdev->brightness;\n\tif (current_brightness)\n\t\tled_cdev->blink_brightness = current_brightness;\n\tif (!led_cdev->blink_brightness)\n\t\tled_cdev->blink_brightness = led_cdev->max_brightness;\n\n\tif (!trigger_data->carrier_link_up) {\n\t\tled_set_brightness(led_cdev, LED_OFF);\n\t} else {\n\t\tbool blink_on = false;\n\n\t\tif (test_bit(TRIGGER_NETDEV_LINK, &trigger_data->mode))\n\t\t\tblink_on = true;\n\n\t\tif (test_bit(TRIGGER_NETDEV_LINK_10, &trigger_data->mode) &&\n\t\t    trigger_data->link_speed == SPEED_10)\n\t\t\tblink_on = true;\n\n\t\tif (test_bit(TRIGGER_NETDEV_LINK_100, &trigger_data->mode) &&\n\t\t    trigger_data->link_speed == SPEED_100)\n\t\t\tblink_on = true;\n\n\t\tif (test_bit(TRIGGER_NETDEV_LINK_1000, &trigger_data->mode) &&\n\t\t    trigger_data->link_speed == SPEED_1000)\n\t\t\tblink_on = true;\n\n\t\tif (test_bit(TRIGGER_NETDEV_HALF_DUPLEX, &trigger_data->mode) &&\n\t\t    trigger_data->duplex == DUPLEX_HALF)\n\t\t\tblink_on = true;\n\n\t\tif (test_bit(TRIGGER_NETDEV_FULL_DUPLEX, &trigger_data->mode) &&\n\t\t    trigger_data->duplex == DUPLEX_FULL)\n\t\t\tblink_on = true;\n\n\t\tif (blink_on)\n\t\t\tled_set_brightness(led_cdev,\n\t\t\t\t\t   led_cdev->blink_brightness);\n\t\telse\n\t\t\tled_set_brightness(led_cdev, LED_OFF);\n\n\t\t \n\t\tif (test_bit(TRIGGER_NETDEV_TX, &trigger_data->mode) ||\n\t\t    test_bit(TRIGGER_NETDEV_RX, &trigger_data->mode))\n\t\t\tschedule_delayed_work(&trigger_data->work, 0);\n\t}\n}\n\nstatic bool supports_hw_control(struct led_classdev *led_cdev)\n{\n\tif (!led_cdev->hw_control_get || !led_cdev->hw_control_set ||\n\t    !led_cdev->hw_control_is_supported)\n\t\treturn false;\n\n\treturn !strcmp(led_cdev->hw_control_trigger, led_cdev->trigger->name);\n}\n\n \nstatic bool validate_net_dev(struct led_classdev *led_cdev,\n\t\t\t     struct net_device *net_dev)\n{\n\tstruct device *dev = led_cdev->hw_control_get_device(led_cdev);\n\tstruct net_device *ndev;\n\n\tif (!dev)\n\t\treturn false;\n\n\tndev = to_net_dev(dev);\n\n\treturn ndev == net_dev;\n}\n\nstatic bool can_hw_control(struct led_netdev_data *trigger_data)\n{\n\tunsigned long default_interval = msecs_to_jiffies(NETDEV_LED_DEFAULT_INTERVAL);\n\tunsigned int interval = atomic_read(&trigger_data->interval);\n\tstruct led_classdev *led_cdev = trigger_data->led_cdev;\n\tint ret;\n\n\tif (!supports_hw_control(led_cdev))\n\t\treturn false;\n\n\t \n\tif (interval != default_interval)\n\t\treturn false;\n\n\t \n\tif (!validate_net_dev(led_cdev, trigger_data->net_dev))\n\t\treturn false;\n\n\t \n\tret = led_cdev->hw_control_is_supported(led_cdev, trigger_data->mode);\n\t \n\tif (ret == -EOPNOTSUPP)\n\t\treturn false;\n\tif (ret) {\n\t\tdev_warn(led_cdev->dev,\n\t\t\t \"Current mode check failed with error %d\\n\", ret);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void get_device_state(struct led_netdev_data *trigger_data)\n{\n\tstruct ethtool_link_ksettings cmd;\n\n\ttrigger_data->carrier_link_up = netif_carrier_ok(trigger_data->net_dev);\n\tif (!trigger_data->carrier_link_up)\n\t\treturn;\n\n\tif (!__ethtool_get_link_ksettings(trigger_data->net_dev, &cmd)) {\n\t\ttrigger_data->link_speed = cmd.base.speed;\n\t\ttrigger_data->duplex = cmd.base.duplex;\n\t}\n}\n\nstatic ssize_t device_name_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_netdev_data *trigger_data = led_trigger_get_drvdata(dev);\n\tssize_t len;\n\n\tmutex_lock(&trigger_data->lock);\n\tlen = sprintf(buf, \"%s\\n\", trigger_data->device_name);\n\tmutex_unlock(&trigger_data->lock);\n\n\treturn len;\n}\n\nstatic int set_device_name(struct led_netdev_data *trigger_data,\n\t\t\t   const char *name, size_t size)\n{\n\tif (size >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tcancel_delayed_work_sync(&trigger_data->work);\n\n\t \n\trtnl_lock();\n\tmutex_lock(&trigger_data->lock);\n\n\tif (trigger_data->net_dev) {\n\t\tdev_put(trigger_data->net_dev);\n\t\ttrigger_data->net_dev = NULL;\n\t}\n\n\tmemcpy(trigger_data->device_name, name, size);\n\ttrigger_data->device_name[size] = 0;\n\tif (size > 0 && trigger_data->device_name[size - 1] == '\\n')\n\t\ttrigger_data->device_name[size - 1] = 0;\n\n\tif (trigger_data->device_name[0] != 0)\n\t\ttrigger_data->net_dev =\n\t\t    dev_get_by_name(&init_net, trigger_data->device_name);\n\n\ttrigger_data->carrier_link_up = false;\n\ttrigger_data->link_speed = SPEED_UNKNOWN;\n\ttrigger_data->duplex = DUPLEX_UNKNOWN;\n\tif (trigger_data->net_dev)\n\t\tget_device_state(trigger_data);\n\n\ttrigger_data->last_activity = 0;\n\n\tset_baseline_state(trigger_data);\n\tmutex_unlock(&trigger_data->lock);\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic ssize_t device_name_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t size)\n{\n\tstruct led_netdev_data *trigger_data = led_trigger_get_drvdata(dev);\n\tint ret;\n\n\tret = set_device_name(trigger_data, buf, size);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(device_name);\n\nstatic ssize_t netdev_led_attr_show(struct device *dev, char *buf,\n\t\t\t\t    enum led_trigger_netdev_modes attr)\n{\n\tstruct led_netdev_data *trigger_data = led_trigger_get_drvdata(dev);\n\tint bit;\n\n\tswitch (attr) {\n\tcase TRIGGER_NETDEV_LINK:\n\tcase TRIGGER_NETDEV_LINK_10:\n\tcase TRIGGER_NETDEV_LINK_100:\n\tcase TRIGGER_NETDEV_LINK_1000:\n\tcase TRIGGER_NETDEV_HALF_DUPLEX:\n\tcase TRIGGER_NETDEV_FULL_DUPLEX:\n\tcase TRIGGER_NETDEV_TX:\n\tcase TRIGGER_NETDEV_RX:\n\t\tbit = attr;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sprintf(buf, \"%u\\n\", test_bit(bit, &trigger_data->mode));\n}\n\nstatic ssize_t netdev_led_attr_store(struct device *dev, const char *buf,\n\t\t\t\t     size_t size, enum led_trigger_netdev_modes attr)\n{\n\tstruct led_netdev_data *trigger_data = led_trigger_get_drvdata(dev);\n\tunsigned long state, mode = trigger_data->mode;\n\tint ret;\n\tint bit;\n\n\tret = kstrtoul(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (attr) {\n\tcase TRIGGER_NETDEV_LINK:\n\tcase TRIGGER_NETDEV_LINK_10:\n\tcase TRIGGER_NETDEV_LINK_100:\n\tcase TRIGGER_NETDEV_LINK_1000:\n\tcase TRIGGER_NETDEV_HALF_DUPLEX:\n\tcase TRIGGER_NETDEV_FULL_DUPLEX:\n\tcase TRIGGER_NETDEV_TX:\n\tcase TRIGGER_NETDEV_RX:\n\t\tbit = attr;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (state)\n\t\tset_bit(bit, &mode);\n\telse\n\t\tclear_bit(bit, &mode);\n\n\tif (test_bit(TRIGGER_NETDEV_LINK, &mode) &&\n\t    (test_bit(TRIGGER_NETDEV_LINK_10, &mode) ||\n\t     test_bit(TRIGGER_NETDEV_LINK_100, &mode) ||\n\t     test_bit(TRIGGER_NETDEV_LINK_1000, &mode)))\n\t\treturn -EINVAL;\n\n\tcancel_delayed_work_sync(&trigger_data->work);\n\n\ttrigger_data->mode = mode;\n\ttrigger_data->hw_control = can_hw_control(trigger_data);\n\n\tset_baseline_state(trigger_data);\n\n\treturn size;\n}\n\n#define DEFINE_NETDEV_TRIGGER(trigger_name, trigger) \\\n\tstatic ssize_t trigger_name##_show(struct device *dev, \\\n\t\tstruct device_attribute *attr, char *buf) \\\n\t{ \\\n\t\treturn netdev_led_attr_show(dev, buf, trigger); \\\n\t} \\\n\tstatic ssize_t trigger_name##_store(struct device *dev, \\\n\t\tstruct device_attribute *attr, const char *buf, size_t size) \\\n\t{ \\\n\t\treturn netdev_led_attr_store(dev, buf, size, trigger); \\\n\t} \\\n\tstatic DEVICE_ATTR_RW(trigger_name)\n\nDEFINE_NETDEV_TRIGGER(link, TRIGGER_NETDEV_LINK);\nDEFINE_NETDEV_TRIGGER(link_10, TRIGGER_NETDEV_LINK_10);\nDEFINE_NETDEV_TRIGGER(link_100, TRIGGER_NETDEV_LINK_100);\nDEFINE_NETDEV_TRIGGER(link_1000, TRIGGER_NETDEV_LINK_1000);\nDEFINE_NETDEV_TRIGGER(half_duplex, TRIGGER_NETDEV_HALF_DUPLEX);\nDEFINE_NETDEV_TRIGGER(full_duplex, TRIGGER_NETDEV_FULL_DUPLEX);\nDEFINE_NETDEV_TRIGGER(tx, TRIGGER_NETDEV_TX);\nDEFINE_NETDEV_TRIGGER(rx, TRIGGER_NETDEV_RX);\n\nstatic ssize_t interval_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct led_netdev_data *trigger_data = led_trigger_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       jiffies_to_msecs(atomic_read(&trigger_data->interval)));\n}\n\nstatic ssize_t interval_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t size)\n{\n\tstruct led_netdev_data *trigger_data = led_trigger_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tif (trigger_data->hw_control)\n\t\treturn -EINVAL;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (value >= 5 && value <= 10000) {\n\t\tcancel_delayed_work_sync(&trigger_data->work);\n\n\t\tatomic_set(&trigger_data->interval, msecs_to_jiffies(value));\n\t\tset_baseline_state(trigger_data);\t \n\t}\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(interval);\n\nstatic ssize_t offloaded_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct led_netdev_data *trigger_data = led_trigger_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", trigger_data->hw_control);\n}\n\nstatic DEVICE_ATTR_RO(offloaded);\n\nstatic struct attribute *netdev_trig_attrs[] = {\n\t&dev_attr_device_name.attr,\n\t&dev_attr_link.attr,\n\t&dev_attr_link_10.attr,\n\t&dev_attr_link_100.attr,\n\t&dev_attr_link_1000.attr,\n\t&dev_attr_full_duplex.attr,\n\t&dev_attr_half_duplex.attr,\n\t&dev_attr_rx.attr,\n\t&dev_attr_tx.attr,\n\t&dev_attr_interval.attr,\n\t&dev_attr_offloaded.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(netdev_trig);\n\nstatic int netdev_trig_notify(struct notifier_block *nb,\n\t\t\t      unsigned long evt, void *dv)\n{\n\tstruct net_device *dev =\n\t\tnetdev_notifier_info_to_dev((struct netdev_notifier_info *)dv);\n\tstruct led_netdev_data *trigger_data =\n\t\tcontainer_of(nb, struct led_netdev_data, notifier);\n\n\tif (evt != NETDEV_UP && evt != NETDEV_DOWN && evt != NETDEV_CHANGE\n\t    && evt != NETDEV_REGISTER && evt != NETDEV_UNREGISTER\n\t    && evt != NETDEV_CHANGENAME)\n\t\treturn NOTIFY_DONE;\n\n\tif (!(dev == trigger_data->net_dev ||\n\t      (evt == NETDEV_CHANGENAME && !strcmp(dev->name, trigger_data->device_name)) ||\n\t      (evt == NETDEV_REGISTER && !strcmp(dev->name, trigger_data->device_name))))\n\t\treturn NOTIFY_DONE;\n\n\tcancel_delayed_work_sync(&trigger_data->work);\n\n\tmutex_lock(&trigger_data->lock);\n\n\ttrigger_data->carrier_link_up = false;\n\ttrigger_data->link_speed = SPEED_UNKNOWN;\n\ttrigger_data->duplex = DUPLEX_UNKNOWN;\n\tswitch (evt) {\n\tcase NETDEV_CHANGENAME:\n\t\tget_device_state(trigger_data);\n\t\tfallthrough;\n\tcase NETDEV_REGISTER:\n\t\tdev_put(trigger_data->net_dev);\n\t\tdev_hold(dev);\n\t\ttrigger_data->net_dev = dev;\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\tdev_put(trigger_data->net_dev);\n\t\ttrigger_data->net_dev = NULL;\n\t\tbreak;\n\tcase NETDEV_UP:\n\tcase NETDEV_CHANGE:\n\t\tget_device_state(trigger_data);\n\t\tbreak;\n\t}\n\n\tset_baseline_state(trigger_data);\n\n\tmutex_unlock(&trigger_data->lock);\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic void netdev_trig_work(struct work_struct *work)\n{\n\tstruct led_netdev_data *trigger_data =\n\t\tcontainer_of(work, struct led_netdev_data, work.work);\n\tstruct rtnl_link_stats64 *dev_stats;\n\tunsigned int new_activity;\n\tstruct rtnl_link_stats64 temp;\n\tunsigned long interval;\n\tint invert;\n\n\t \n\tif (!trigger_data->net_dev) {\n\t\tled_set_brightness(trigger_data->led_cdev, LED_OFF);\n\t\treturn;\n\t}\n\n\t \n\tif (!test_bit(TRIGGER_NETDEV_TX, &trigger_data->mode) &&\n\t    !test_bit(TRIGGER_NETDEV_RX, &trigger_data->mode))\n\t\treturn;\n\n\tdev_stats = dev_get_stats(trigger_data->net_dev, &temp);\n\tnew_activity =\n\t    (test_bit(TRIGGER_NETDEV_TX, &trigger_data->mode) ?\n\t\tdev_stats->tx_packets : 0) +\n\t    (test_bit(TRIGGER_NETDEV_RX, &trigger_data->mode) ?\n\t\tdev_stats->rx_packets : 0);\n\n\tif (trigger_data->last_activity != new_activity) {\n\t\tled_stop_software_blink(trigger_data->led_cdev);\n\n\t\tinvert = test_bit(TRIGGER_NETDEV_LINK, &trigger_data->mode) ||\n\t\t\t test_bit(TRIGGER_NETDEV_LINK_10, &trigger_data->mode) ||\n\t\t\t test_bit(TRIGGER_NETDEV_LINK_100, &trigger_data->mode) ||\n\t\t\t test_bit(TRIGGER_NETDEV_LINK_1000, &trigger_data->mode) ||\n\t\t\t test_bit(TRIGGER_NETDEV_HALF_DUPLEX, &trigger_data->mode) ||\n\t\t\t test_bit(TRIGGER_NETDEV_FULL_DUPLEX, &trigger_data->mode);\n\t\tinterval = jiffies_to_msecs(\n\t\t\t\tatomic_read(&trigger_data->interval));\n\t\t \n\t\tled_blink_set_oneshot(trigger_data->led_cdev,\n\t\t\t\t      &interval,\n\t\t\t\t      &interval,\n\t\t\t\t      invert);\n\t\ttrigger_data->last_activity = new_activity;\n\t}\n\n\tschedule_delayed_work(&trigger_data->work,\n\t\t\t(atomic_read(&trigger_data->interval)*2));\n}\n\nstatic int netdev_trig_activate(struct led_classdev *led_cdev)\n{\n\tstruct led_netdev_data *trigger_data;\n\tunsigned long mode = 0;\n\tstruct device *dev;\n\tint rc;\n\n\ttrigger_data = kzalloc(sizeof(struct led_netdev_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&trigger_data->lock);\n\n\ttrigger_data->notifier.notifier_call = netdev_trig_notify;\n\ttrigger_data->notifier.priority = 10;\n\n\tINIT_DELAYED_WORK(&trigger_data->work, netdev_trig_work);\n\n\ttrigger_data->led_cdev = led_cdev;\n\ttrigger_data->net_dev = NULL;\n\ttrigger_data->device_name[0] = 0;\n\n\ttrigger_data->mode = 0;\n\tatomic_set(&trigger_data->interval, msecs_to_jiffies(NETDEV_LED_DEFAULT_INTERVAL));\n\ttrigger_data->last_activity = 0;\n\n\t \n\tif (supports_hw_control(led_cdev)) {\n\t\tdev = led_cdev->hw_control_get_device(led_cdev);\n\t\tif (dev) {\n\t\t\tconst char *name = dev_name(dev);\n\n\t\t\tset_device_name(trigger_data, name, strlen(name));\n\t\t\ttrigger_data->hw_control = true;\n\n\t\t\trc = led_cdev->hw_control_get(led_cdev, &mode);\n\t\t\tif (!rc)\n\t\t\t\ttrigger_data->mode = mode;\n\t\t}\n\t}\n\n\tled_set_trigger_data(led_cdev, trigger_data);\n\n\trc = register_netdevice_notifier(&trigger_data->notifier);\n\tif (rc)\n\t\tkfree(trigger_data);\n\n\treturn rc;\n}\n\nstatic void netdev_trig_deactivate(struct led_classdev *led_cdev)\n{\n\tstruct led_netdev_data *trigger_data = led_get_trigger_data(led_cdev);\n\n\tunregister_netdevice_notifier(&trigger_data->notifier);\n\n\tcancel_delayed_work_sync(&trigger_data->work);\n\n\tled_set_brightness(led_cdev, LED_OFF);\n\n\tdev_put(trigger_data->net_dev);\n\n\tkfree(trigger_data);\n}\n\nstatic struct led_trigger netdev_led_trigger = {\n\t.name = \"netdev\",\n\t.activate = netdev_trig_activate,\n\t.deactivate = netdev_trig_deactivate,\n\t.groups = netdev_trig_groups,\n};\n\nmodule_led_trigger(netdev_led_trigger);\n\nMODULE_AUTHOR(\"Ben Whitten <ben.whitten@gmail.com>\");\nMODULE_AUTHOR(\"Oliver Jowett <oliver@opencloud.com>\");\nMODULE_DESCRIPTION(\"Netdev LED trigger\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}