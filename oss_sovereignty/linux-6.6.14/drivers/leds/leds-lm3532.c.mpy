{
  "module_name": "leds-lm3532.c",
  "hash_id": "03c9b85023fe41bbb6ae95556df5c974f204f6024ddbfab7f17112e36a318cb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lm3532.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n#include <linux/regulator/consumer.h>\n#include <linux/module.h>\n#include <uapi/linux/uleds.h>\n#include <linux/gpio/consumer.h>\n\n#define LM3532_NAME \"lm3532-led\"\n#define LM3532_BL_MODE_MANUAL\t0x00\n#define LM3532_BL_MODE_ALS\t0x01\n\n#define LM3532_REG_OUTPUT_CFG\t0x10\n#define LM3532_REG_STARTSHUT_RAMP\t0x11\n#define LM3532_REG_RT_RAMP\t0x12\n#define LM3532_REG_PWM_A_CFG\t0x13\n#define LM3532_REG_PWM_B_CFG\t0x14\n#define LM3532_REG_PWM_C_CFG\t0x15\n#define LM3532_REG_ZONE_CFG_A\t0x16\n#define LM3532_REG_CTRL_A_FS_CURR\t0x17\n#define LM3532_REG_ZONE_CFG_B\t0x18\n#define LM3532_REG_CTRL_B_FS_CURR\t0x19\n#define LM3532_REG_ZONE_CFG_C\t0x1a\n#define LM3532_REG_CTRL_C_FS_CURR\t0x1b\n#define LM3532_REG_ENABLE\t0x1d\n#define LM3532_ALS_CONFIG\t0x23\n#define LM3532_REG_ZN_0_HI\t0x60\n#define LM3532_REG_ZN_0_LO\t0x61\n#define LM3532_REG_ZN_1_HI\t0x62\n#define LM3532_REG_ZN_1_LO\t0x63\n#define LM3532_REG_ZN_2_HI\t0x64\n#define LM3532_REG_ZN_2_LO\t0x65\n#define LM3532_REG_ZN_3_HI\t0x66\n#define LM3532_REG_ZN_3_LO\t0x67\n#define LM3532_REG_ZONE_TRGT_A\t0x70\n#define LM3532_REG_ZONE_TRGT_B\t0x75\n#define LM3532_REG_ZONE_TRGT_C\t0x7a\n#define LM3532_REG_MAX\t\t0x7e\n\n \n#define LM3532_CTRL_A_ENABLE\tBIT(0)\n#define LM3532_CTRL_B_ENABLE\tBIT(1)\n#define LM3532_CTRL_C_ENABLE\tBIT(2)\n\n \n#define LM3532_PWM_ZONE_MASK\t0x7c\n#define LM3532_PWM_ZONE_0_EN\tBIT(2)\n#define LM3532_PWM_ZONE_1_EN\tBIT(3)\n#define LM3532_PWM_ZONE_2_EN\tBIT(4)\n#define LM3532_PWM_ZONE_3_EN\tBIT(5)\n#define LM3532_PWM_ZONE_4_EN\tBIT(6)\n\n \n#define LM3532_I2C_CTRL\t\tBIT(0)\n#define LM3532_ALS_CTRL\t\t0\n#define LM3532_LINEAR_MAP\tBIT(1)\n#define LM3532_ZONE_MASK\t(BIT(2) | BIT(3) | BIT(4))\n#define LM3532_ZONE_0\t\t0\n#define LM3532_ZONE_1\t\tBIT(2)\n#define LM3532_ZONE_2\t\tBIT(3)\n#define LM3532_ZONE_3\t\t(BIT(2) | BIT(3))\n#define LM3532_ZONE_4\t\tBIT(4)\n\n#define LM3532_ENABLE_ALS\tBIT(3)\n#define LM3532_ALS_SEL_SHIFT\t6\n\n \n#define LM3532_ALS_WINDOW_mV\t2000\n#define LM3532_ALS_ZB_MAX\t4\n#define LM3532_ALS_OFFSET_mV\t2\n\n#define LM3532_CONTROL_A\t0\n#define LM3532_CONTROL_B\t1\n#define LM3532_CONTROL_C\t2\n#define LM3532_MAX_CONTROL_BANKS 3\n#define LM3532_MAX_LED_STRINGS\t3\n\n#define LM3532_OUTPUT_CFG_MASK\t0x3\n#define LM3532_BRT_VAL_ADJUST\t8\n#define LM3532_RAMP_DOWN_SHIFT\t3\n\n#define LM3532_NUM_RAMP_VALS\t8\n#define LM3532_NUM_AVG_VALS\t8\n#define LM3532_NUM_IMP_VALS\t32\n\n#define LM3532_FS_CURR_MIN\t5000\n#define LM3532_FS_CURR_MAX\t29800\n#define LM3532_FS_CURR_STEP\t800\n\n \nstruct lm3532_als_data {\n\tu8 config;\n\tu8 als1_imp_sel;\n\tu8 als2_imp_sel;\n\tu8 als_avrg_time;\n\tu8 als_input_mode;\n\tu32 als_vmin;\n\tu32 als_vmax;\n\tu8 zones_lo[LM3532_ALS_ZB_MAX];\n\tu8 zones_hi[LM3532_ALS_ZB_MAX];\n};\n\n \nstruct lm3532_led {\n\tstruct led_classdev led_dev;\n\tstruct lm3532_data *priv;\n\n\tint control_bank;\n\tint mode;\n\tint ctrl_brt_pointer;\n\tint num_leds;\n\tint full_scale_current;\n\tunsigned int enabled:1;\n\tu32 led_strings[LM3532_MAX_CONTROL_BANKS];\n};\n\n \nstruct lm3532_data {\n\tstruct gpio_desc *enable_gpio;\n\tstruct regulator *regulator;\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct mutex lock;\n\n\tstruct lm3532_als_data *als_data;\n\n\tu32 runtime_ramp_up;\n\tu32 runtime_ramp_down;\n\n\tstruct lm3532_led leds[];\n};\n\nstatic const struct reg_default lm3532_reg_defs[] = {\n\t{LM3532_REG_OUTPUT_CFG, 0xe4},\n\t{LM3532_REG_STARTSHUT_RAMP, 0xc0},\n\t{LM3532_REG_RT_RAMP, 0xc0},\n\t{LM3532_REG_PWM_A_CFG, 0x82},\n\t{LM3532_REG_PWM_B_CFG, 0x82},\n\t{LM3532_REG_PWM_C_CFG, 0x82},\n\t{LM3532_REG_ZONE_CFG_A, 0xf1},\n\t{LM3532_REG_CTRL_A_FS_CURR, 0xf3},\n\t{LM3532_REG_ZONE_CFG_B, 0xf1},\n\t{LM3532_REG_CTRL_B_FS_CURR, 0xf3},\n\t{LM3532_REG_ZONE_CFG_C, 0xf1},\n\t{LM3532_REG_CTRL_C_FS_CURR, 0xf3},\n\t{LM3532_REG_ENABLE, 0xf8},\n\t{LM3532_ALS_CONFIG, 0x44},\n\t{LM3532_REG_ZN_0_HI, 0x35},\n\t{LM3532_REG_ZN_0_LO, 0x33},\n\t{LM3532_REG_ZN_1_HI, 0x6a},\n\t{LM3532_REG_ZN_1_LO, 0x66},\n\t{LM3532_REG_ZN_2_HI, 0xa1},\n\t{LM3532_REG_ZN_2_LO, 0x99},\n\t{LM3532_REG_ZN_3_HI, 0xdc},\n\t{LM3532_REG_ZN_3_LO, 0xcc},\n};\n\nstatic const struct regmap_config lm3532_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = LM3532_REG_MAX,\n\t.reg_defaults = lm3532_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(lm3532_reg_defs),\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const int als_imp_table[LM3532_NUM_IMP_VALS] = {37000, 18500, 12330,\n\t\t\t\t\t\t       92500, 7400, 6170, 5290,\n\t\t\t\t\t\t       4630, 4110, 3700, 3360,\n\t\t\t\t\t\t       3080, 2850, 2640, 2440,\n\t\t\t\t\t\t       2310, 2180, 2060, 1950,\n\t\t\t\t\t\t       1850, 1760, 1680, 1610,\n\t\t\t\t\t\t       1540, 1480, 1420, 1370,\n\t\t\t\t\t\t       1320, 1280, 1230, 1190};\nstatic int lm3532_get_als_imp_index(int als_imped)\n{\n\tint i;\n\n\tif (als_imped > als_imp_table[1])\n\t\treturn 0;\n\n\tif (als_imped < als_imp_table[LM3532_NUM_IMP_VALS - 1])\n\t\treturn LM3532_NUM_IMP_VALS - 1;\n\n\tfor (i = 1; i < LM3532_NUM_IMP_VALS; i++) {\n\t\tif (als_imped == als_imp_table[i])\n\t\t\treturn i;\n\n\t\t \n\t\tif (als_imped < als_imp_table[i - 1] &&\n\t\t    als_imped > als_imp_table[i]) {\n\t\t\tif (als_imped - als_imp_table[i - 1] <\n\t\t\t    als_imp_table[i] - als_imped)\n\t\t\t\treturn i + 1;\n\t\t\telse\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int lm3532_get_index(const int table[], int size, int value)\n{\n\tint i;\n\n\tfor (i = 1; i < size; i++) {\n\t\tif (value == table[i])\n\t\t\treturn i;\n\n\t\t \n\t\tif (value > table[i - 1] &&\n\t\t    value < table[i]) {\n\t\t\tif (value - table[i - 1] < table[i] - value)\n\t\t\t\treturn i - 1;\n\t\t\telse\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const int als_avrg_table[LM3532_NUM_AVG_VALS] = {17920, 35840, 71680,\n\t\t\t\t\t\t\t1433360, 286720, 573440,\n\t\t\t\t\t\t\t1146880, 2293760};\nstatic int lm3532_get_als_avg_index(int avg_time)\n{\n\tif (avg_time <= als_avrg_table[0])\n\t\treturn 0;\n\n\tif (avg_time > als_avrg_table[LM3532_NUM_AVG_VALS - 1])\n\t\treturn LM3532_NUM_AVG_VALS - 1;\n\n\treturn lm3532_get_index(&als_avrg_table[0], LM3532_NUM_AVG_VALS,\n\t\t\t\tavg_time);\n}\n\nstatic const int ramp_table[LM3532_NUM_RAMP_VALS] = { 8, 1024, 2048, 4096, 8192,\n\t\t\t\t\t\t     16384, 32768, 65536};\nstatic int lm3532_get_ramp_index(int ramp_time)\n{\n\tif (ramp_time <= ramp_table[0])\n\t\treturn 0;\n\n\tif (ramp_time > ramp_table[LM3532_NUM_RAMP_VALS - 1])\n\t\treturn LM3532_NUM_RAMP_VALS - 1;\n\n\treturn lm3532_get_index(&ramp_table[0], LM3532_NUM_RAMP_VALS,\n\t\t\t\tramp_time);\n}\n\n \nstatic int lm3532_led_enable(struct lm3532_led *led_data)\n{\n\tint ctrl_en_val = BIT(led_data->control_bank);\n\tint ret;\n\n\tif (led_data->enabled)\n\t\treturn 0;\n\n\tret = regmap_update_bits(led_data->priv->regmap, LM3532_REG_ENABLE,\n\t\t\t\t\t ctrl_en_val, ctrl_en_val);\n\tif (ret) {\n\t\tdev_err(led_data->priv->dev, \"Failed to set ctrl:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_enable(led_data->priv->regulator);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tled_data->enabled = 1;\n\n\treturn 0;\n}\n\n \nstatic int lm3532_led_disable(struct lm3532_led *led_data)\n{\n\tint ctrl_en_val = BIT(led_data->control_bank);\n\tint ret;\n\n\tif (!led_data->enabled)\n\t\treturn 0;\n\n\tret = regmap_update_bits(led_data->priv->regmap, LM3532_REG_ENABLE,\n\t\t\t\t\t ctrl_en_val, 0);\n\tif (ret) {\n\t\tdev_err(led_data->priv->dev, \"Failed to set ctrl:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_disable(led_data->priv->regulator);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tled_data->enabled = 0;\n\n\treturn 0;\n}\n\nstatic int lm3532_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t enum led_brightness brt_val)\n{\n\tstruct lm3532_led *led =\n\t\t\tcontainer_of(led_cdev, struct lm3532_led, led_dev);\n\tu8 brightness_reg;\n\tint ret;\n\n\tmutex_lock(&led->priv->lock);\n\n\tif (led->mode == LM3532_ALS_CTRL) {\n\t\tif (brt_val > LED_OFF)\n\t\t\tret = lm3532_led_enable(led);\n\t\telse\n\t\t\tret = lm3532_led_disable(led);\n\n\t\tgoto unlock;\n\t}\n\n\tif (brt_val == LED_OFF) {\n\t\tret = lm3532_led_disable(led);\n\t\tgoto unlock;\n\t}\n\n\tret = lm3532_led_enable(led);\n\tif (ret)\n\t\tgoto unlock;\n\n\tbrightness_reg = LM3532_REG_ZONE_TRGT_A + led->control_bank * 5 +\n\t\t\t (led->ctrl_brt_pointer >> 2);\n\n\tret = regmap_write(led->priv->regmap, brightness_reg, brt_val);\n\nunlock:\n\tmutex_unlock(&led->priv->lock);\n\treturn ret;\n}\n\nstatic int lm3532_init_registers(struct lm3532_led *led)\n{\n\tstruct lm3532_data *drvdata = led->priv;\n\tunsigned int runtime_ramp_val;\n\tunsigned int output_cfg_val = 0;\n\tunsigned int output_cfg_shift = 0;\n\tunsigned int output_cfg_mask = 0;\n\tunsigned int brightness_config_reg;\n\tunsigned int brightness_config_val;\n\tint fs_current_reg;\n\tint fs_current_val;\n\tint ret, i;\n\n\tif (drvdata->enable_gpio)\n\t\tgpiod_direction_output(drvdata->enable_gpio, 1);\n\n\tbrightness_config_reg = LM3532_REG_ZONE_CFG_A + led->control_bank * 2;\n\t \n\tret = regmap_read(drvdata->regmap, brightness_config_reg,\n\t\t\t  &led->ctrl_brt_pointer);\n\tif (ret)\n\t\treturn ret;\n\n\tled->ctrl_brt_pointer &= LM3532_ZONE_MASK;\n\tbrightness_config_val = led->ctrl_brt_pointer | led->mode;\n\tret = regmap_write(drvdata->regmap, brightness_config_reg,\n\t\t\t   brightness_config_val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (led->full_scale_current) {\n\t\tfs_current_reg = LM3532_REG_CTRL_A_FS_CURR + led->control_bank * 2;\n\t\tfs_current_val = (led->full_scale_current - LM3532_FS_CURR_MIN) /\n\t\t\t\t LM3532_FS_CURR_STEP;\n\n\t\tret = regmap_write(drvdata->regmap, fs_current_reg,\n\t\t\t\t   fs_current_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < led->num_leds; i++) {\n\t\toutput_cfg_shift = led->led_strings[i] * 2;\n\t\toutput_cfg_val |= (led->control_bank << output_cfg_shift);\n\t\toutput_cfg_mask |= LM3532_OUTPUT_CFG_MASK << output_cfg_shift;\n\t}\n\n\tret = regmap_update_bits(drvdata->regmap, LM3532_REG_OUTPUT_CFG,\n\t\t\t\t output_cfg_mask, output_cfg_val);\n\tif (ret)\n\t\treturn ret;\n\n\truntime_ramp_val = drvdata->runtime_ramp_up |\n\t\t\t (drvdata->runtime_ramp_down << LM3532_RAMP_DOWN_SHIFT);\n\n\treturn regmap_write(drvdata->regmap, LM3532_REG_RT_RAMP,\n\t\t\t    runtime_ramp_val);\n}\n\nstatic int lm3532_als_configure(struct lm3532_data *priv,\n\t\t\t\tstruct lm3532_led *led)\n{\n\tstruct lm3532_als_data *als = priv->als_data;\n\tu32 als_vmin, als_vmax, als_vstep;\n\tint zone_reg = LM3532_REG_ZN_0_HI;\n\tint ret;\n\tint i;\n\n\tals_vmin = als->als_vmin;\n\tals_vmax = als->als_vmax;\n\n\tals_vstep = (als_vmax - als_vmin) / ((LM3532_ALS_ZB_MAX + 1) * 2);\n\n\tfor (i = 0; i < LM3532_ALS_ZB_MAX; i++) {\n\t\tals->zones_lo[i] = ((als_vmin + als_vstep + (i * als_vstep)) *\n\t\t\t\tLED_FULL) / 1000;\n\t\tals->zones_hi[i] = ((als_vmin + LM3532_ALS_OFFSET_mV +\n\t\t\t\tals_vstep + (i * als_vstep)) * LED_FULL) / 1000;\n\n\t\tzone_reg = LM3532_REG_ZN_0_HI + i * 2;\n\t\tret = regmap_write(priv->regmap, zone_reg, als->zones_lo[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tzone_reg += 1;\n\t\tret = regmap_write(priv->regmap, zone_reg, als->zones_hi[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tals->config = (als->als_avrg_time | (LM3532_ENABLE_ALS) |\n\t\t(als->als_input_mode << LM3532_ALS_SEL_SHIFT));\n\n\treturn regmap_write(priv->regmap, LM3532_ALS_CONFIG, als->config);\n}\n\nstatic int lm3532_parse_als(struct lm3532_data *priv)\n{\n\tstruct lm3532_als_data *als;\n\tint als_avg_time;\n\tint als_impedance;\n\tint ret;\n\n\tals = devm_kzalloc(priv->dev, sizeof(*als), GFP_KERNEL);\n\tif (als == NULL)\n\t\treturn -ENOMEM;\n\n\tret = device_property_read_u32(&priv->client->dev, \"ti,als-vmin\",\n\t\t\t\t       &als->als_vmin);\n\tif (ret)\n\t\tals->als_vmin = 0;\n\n\tret = device_property_read_u32(&priv->client->dev, \"ti,als-vmax\",\n\t\t\t\t       &als->als_vmax);\n\tif (ret)\n\t\tals->als_vmax = LM3532_ALS_WINDOW_mV;\n\n\tif (als->als_vmax > LM3532_ALS_WINDOW_mV) {\n\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(&priv->client->dev, \"ti,als1-imp-sel\",\n\t\t\t\t      &als_impedance);\n\tif (ret)\n\t\tals->als1_imp_sel = 0;\n\telse\n\t\tals->als1_imp_sel = lm3532_get_als_imp_index(als_impedance);\n\n\tret = device_property_read_u32(&priv->client->dev, \"ti,als2-imp-sel\",\n\t\t\t\t      &als_impedance);\n\tif (ret)\n\t\tals->als2_imp_sel = 0;\n\telse\n\t\tals->als2_imp_sel = lm3532_get_als_imp_index(als_impedance);\n\n\tret = device_property_read_u32(&priv->client->dev, \"ti,als-avrg-time-us\",\n\t\t\t\t      &als_avg_time);\n\tif (ret)\n\t\tals->als_avrg_time = 0;\n\telse\n\t\tals->als_avrg_time = lm3532_get_als_avg_index(als_avg_time);\n\n\tret = device_property_read_u8(&priv->client->dev, \"ti,als-input-mode\",\n\t\t\t\t      &als->als_input_mode);\n\tif (ret)\n\t\tals->als_input_mode = 0;\n\n\tif (als->als_input_mode > LM3532_BL_MODE_ALS) {\n\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tpriv->als_data = als;\n\n\treturn ret;\n}\n\nstatic int lm3532_parse_node(struct lm3532_data *priv)\n{\n\tstruct fwnode_handle *child = NULL;\n\tstruct lm3532_led *led;\n\tint control_bank;\n\tu32 ramp_time;\n\tsize_t i = 0;\n\tint ret;\n\n\tpriv->enable_gpio = devm_gpiod_get_optional(&priv->client->dev,\n\t\t\t\t\t\t   \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->enable_gpio))\n\t\tpriv->enable_gpio = NULL;\n\n\tpriv->regulator = devm_regulator_get(&priv->client->dev, \"vin\");\n\tif (IS_ERR(priv->regulator))\n\t\tpriv->regulator = NULL;\n\n\tret = device_property_read_u32(&priv->client->dev, \"ramp-up-us\",\n\t\t\t\t       &ramp_time);\n\tif (ret)\n\t\tdev_info(&priv->client->dev, \"ramp-up-ms property missing\\n\");\n\telse\n\t\tpriv->runtime_ramp_up = lm3532_get_ramp_index(ramp_time);\n\n\tret = device_property_read_u32(&priv->client->dev, \"ramp-down-us\",\n\t\t\t\t       &ramp_time);\n\tif (ret)\n\t\tdev_info(&priv->client->dev, \"ramp-down-ms property missing\\n\");\n\telse\n\t\tpriv->runtime_ramp_down = lm3532_get_ramp_index(ramp_time);\n\n\tdevice_for_each_child_node(priv->dev, child) {\n\t\tstruct led_init_data idata = {\n\t\t\t.fwnode = child,\n\t\t\t.default_label = \":\",\n\t\t\t.devicename = priv->client->name,\n\t\t};\n\n\t\tled = &priv->leds[i];\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &control_bank);\n\t\tif (ret) {\n\t\t\tdev_err(&priv->client->dev, \"reg property missing\\n\");\n\t\t\tgoto child_out;\n\t\t}\n\n\t\tif (control_bank > LM3532_CONTROL_C) {\n\t\t\tdev_err(&priv->client->dev, \"Control bank invalid\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tled->control_bank = control_bank;\n\n\t\tret = fwnode_property_read_u32(child, \"ti,led-mode\",\n\t\t\t\t\t       &led->mode);\n\t\tif (ret) {\n\t\t\tdev_err(&priv->client->dev, \"ti,led-mode property missing\\n\");\n\t\t\tgoto child_out;\n\t\t}\n\n\t\tif (fwnode_property_present(child, \"led-max-microamp\") &&\n\t\t    fwnode_property_read_u32(child, \"led-max-microamp\",\n\t\t\t\t\t     &led->full_scale_current))\n\t\t\tdev_err(&priv->client->dev,\n\t\t\t\t\"Failed getting led-max-microamp\\n\");\n\t\telse\n\t\t\tled->full_scale_current = min(led->full_scale_current,\n\t\t\t\t\t\t      LM3532_FS_CURR_MAX);\n\n\t\tif (led->mode == LM3532_BL_MODE_ALS) {\n\t\t\tled->mode = LM3532_ALS_CTRL;\n\t\t\tret = lm3532_parse_als(priv);\n\t\t\tif (ret)\n\t\t\t\tdev_err(&priv->client->dev, \"Failed to parse als\\n\");\n\t\t\telse\n\t\t\t\tlm3532_als_configure(priv, led);\n\t\t} else {\n\t\t\tled->mode = LM3532_I2C_CTRL;\n\t\t}\n\n\t\tled->num_leds = fwnode_property_count_u32(child, \"led-sources\");\n\t\tif (led->num_leds > LM3532_MAX_LED_STRINGS) {\n\t\t\tdev_err(&priv->client->dev, \"Too many LED string defined\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = fwnode_property_read_u32_array(child, \"led-sources\",\n\t\t\t\t\t\t    led->led_strings,\n\t\t\t\t\t\t    led->num_leds);\n\t\tif (ret) {\n\t\t\tdev_err(&priv->client->dev, \"led-sources property missing\\n\");\n\t\t\tgoto child_out;\n\t\t}\n\n\t\tled->priv = priv;\n\t\tled->led_dev.brightness_set_blocking = lm3532_brightness_set;\n\n\t\tret = devm_led_classdev_register_ext(priv->dev, &led->led_dev, &idata);\n\t\tif (ret) {\n\t\t\tdev_err(&priv->client->dev, \"led register err: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto child_out;\n\t\t}\n\n\t\tret = lm3532_init_registers(led);\n\t\tif (ret) {\n\t\t\tdev_err(&priv->client->dev, \"register init err: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto child_out;\n\t\t}\n\n\t\ti++;\n\t}\n\treturn 0;\n\nchild_out:\n\tfwnode_handle_put(child);\n\treturn ret;\n}\n\nstatic int lm3532_probe(struct i2c_client *client)\n{\n\tstruct lm3532_data *drvdata;\n\tint ret = 0;\n\tint count;\n\n\tcount = device_get_child_node_count(&client->dev);\n\tif (!count) {\n\t\tdev_err(&client->dev, \"LEDs are not defined in device tree!\");\n\t\treturn -ENODEV;\n\t}\n\n\tdrvdata = devm_kzalloc(&client->dev, struct_size(drvdata, leds, count),\n\t\t\t   GFP_KERNEL);\n\tif (drvdata == NULL)\n\t\treturn -ENOMEM;\n\n\tdrvdata->client = client;\n\tdrvdata->dev = &client->dev;\n\n\tdrvdata->regmap = devm_regmap_init_i2c(client, &lm3532_regmap_config);\n\tif (IS_ERR(drvdata->regmap)) {\n\t\tret = PTR_ERR(drvdata->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&drvdata->lock);\n\ti2c_set_clientdata(client, drvdata);\n\n\tret = lm3532_parse_node(drvdata);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to parse node\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void lm3532_remove(struct i2c_client *client)\n{\n\tstruct lm3532_data *drvdata = i2c_get_clientdata(client);\n\n\tmutex_destroy(&drvdata->lock);\n\n\tif (drvdata->enable_gpio)\n\t\tgpiod_direction_output(drvdata->enable_gpio, 0);\n}\n\nstatic const struct of_device_id of_lm3532_leds_match[] = {\n\t{ .compatible = \"ti,lm3532\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_lm3532_leds_match);\n\nstatic const struct i2c_device_id lm3532_id[] = {\n\t{LM3532_NAME, 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, lm3532_id);\n\nstatic struct i2c_driver lm3532_i2c_driver = {\n\t.probe = lm3532_probe,\n\t.remove = lm3532_remove,\n\t.id_table = lm3532_id,\n\t.driver = {\n\t\t.name = LM3532_NAME,\n\t\t.of_match_table = of_lm3532_leds_match,\n\t},\n};\nmodule_i2c_driver(lm3532_i2c_driver);\n\nMODULE_DESCRIPTION(\"Back Light driver for LM3532\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}