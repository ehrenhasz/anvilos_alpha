{
  "module_name": "leds-mlxcpld.c",
  "hash_id": "6fdc406c1797a59dda67e0ce6ede10e313f8882f615e6289fa16f6f4e4b926a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-mlxcpld.c",
  "human_readable_source": " \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/io.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define MLXPLAT_CPLD_LPC_REG_BASE_ADRR     0x2500  \n\n \n#define MLXCPLD_LED_OFFSET_HALF\t\t0x01  \n#define MLXCPLD_LED_OFFSET_FULL\t\t0x02  \n#define MLXCPLD_LED_IS_OFF\t\t0x00  \n#define MLXCPLD_LED_RED_STATIC_ON\t0x05  \n#define MLXCPLD_LED_RED_BLINK_HALF\t(MLXCPLD_LED_RED_STATIC_ON + \\\n\t\t\t\t\t MLXCPLD_LED_OFFSET_HALF)\n#define MLXCPLD_LED_RED_BLINK_FULL\t(MLXCPLD_LED_RED_STATIC_ON + \\\n\t\t\t\t\t MLXCPLD_LED_OFFSET_FULL)\n#define MLXCPLD_LED_GREEN_STATIC_ON\t0x0D  \n#define MLXCPLD_LED_GREEN_BLINK_HALF\t(MLXCPLD_LED_GREEN_STATIC_ON + \\\n\t\t\t\t\t MLXCPLD_LED_OFFSET_HALF)\n#define MLXCPLD_LED_GREEN_BLINK_FULL\t(MLXCPLD_LED_GREEN_STATIC_ON + \\\n\t\t\t\t\t MLXCPLD_LED_OFFSET_FULL)\n#define MLXCPLD_LED_BLINK_3HZ\t\t167  \n#define MLXCPLD_LED_BLINK_6HZ\t\t83  \n\n \nstruct mlxcpld_param {\n\tu8 offset;\n\tu8 mask;\n\tu8 base_color;\n};\n\n \nstruct mlxcpld_led_priv {\n\tstruct led_classdev cdev;\n\tstruct mlxcpld_param param;\n};\n\n#define cdev_to_priv(c)\t\tcontainer_of(c, struct mlxcpld_led_priv, cdev)\n\n \nstruct mlxcpld_led_profile {\n\tu8 offset;\n\tu8 mask;\n\tu8 base_color;\n\tenum led_brightness brightness;\n\tconst char *name;\n};\n\n \nstruct mlxcpld_led_pdata {\n\tstruct platform_device *pdev;\n\tstruct mlxcpld_led_priv *pled;\n\tstruct mlxcpld_led_profile *profile;\n\tint num_led_instances;\n\tspinlock_t lock;\n};\n\nstatic struct mlxcpld_led_pdata *mlxcpld_led;\n\n \nstatic struct mlxcpld_led_profile mlxcpld_led_default_profile[] = {\n\t{\n\t\t0x21, 0xf0, MLXCPLD_LED_GREEN_STATIC_ON, 1,\n\t\t\"mlxcpld:fan1:green\",\n\t},\n\t{\n\t\t0x21, 0xf0, MLXCPLD_LED_RED_STATIC_ON, LED_OFF,\n\t\t\"mlxcpld:fan1:red\",\n\t},\n\t{\n\t\t0x21, 0x0f, MLXCPLD_LED_GREEN_STATIC_ON, 1,\n\t\t\"mlxcpld:fan2:green\",\n\t},\n\t{\n\t\t0x21, 0x0f, MLXCPLD_LED_RED_STATIC_ON, LED_OFF,\n\t\t\"mlxcpld:fan2:red\",\n\t},\n\t{\n\t\t0x22, 0xf0, MLXCPLD_LED_GREEN_STATIC_ON, 1,\n\t\t\"mlxcpld:fan3:green\",\n\t},\n\t{\n\t\t0x22, 0xf0, MLXCPLD_LED_RED_STATIC_ON, LED_OFF,\n\t\t\"mlxcpld:fan3:red\",\n\t},\n\t{\n\t\t0x22, 0x0f, MLXCPLD_LED_GREEN_STATIC_ON, 1,\n\t\t\"mlxcpld:fan4:green\",\n\t},\n\t{\n\t\t0x22, 0x0f, MLXCPLD_LED_RED_STATIC_ON, LED_OFF,\n\t\t\"mlxcpld:fan4:red\",\n\t},\n\t{\n\t\t0x20, 0x0f, MLXCPLD_LED_GREEN_STATIC_ON, 1,\n\t\t\"mlxcpld:psu:green\",\n\t},\n\t{\n\t\t0x20, 0x0f, MLXCPLD_LED_RED_STATIC_ON, LED_OFF,\n\t\t\"mlxcpld:psu:red\",\n\t},\n\t{\n\t\t0x20, 0xf0, MLXCPLD_LED_GREEN_STATIC_ON, 1,\n\t\t\"mlxcpld:status:green\",\n\t},\n\t{\n\t\t0x20, 0xf0, MLXCPLD_LED_RED_STATIC_ON, LED_OFF,\n\t\t\"mlxcpld:status:red\",\n\t},\n};\n\n \nstatic struct mlxcpld_led_profile mlxcpld_led_msn2100_profile[] = {\n\t{\n\t\t0x21, 0xf0, MLXCPLD_LED_GREEN_STATIC_ON, 1,\n\t\t\"mlxcpld:fan:green\",\n\t},\n\t{\n\t\t0x21, 0xf0, MLXCPLD_LED_RED_STATIC_ON, LED_OFF,\n\t\t\"mlxcpld:fan:red\",\n\t},\n\t{\n\t\t0x23, 0xf0, MLXCPLD_LED_GREEN_STATIC_ON, 1,\n\t\t\"mlxcpld:psu1:green\",\n\t},\n\t{\n\t\t0x23, 0xf0, MLXCPLD_LED_RED_STATIC_ON, LED_OFF,\n\t\t\"mlxcpld:psu1:red\",\n\t},\n\t{\n\t\t0x23, 0x0f, MLXCPLD_LED_GREEN_STATIC_ON, 1,\n\t\t\"mlxcpld:psu2:green\",\n\t},\n\t{\n\t\t0x23, 0x0f, MLXCPLD_LED_RED_STATIC_ON, LED_OFF,\n\t\t\"mlxcpld:psu2:red\",\n\t},\n\t{\n\t\t0x20, 0xf0, MLXCPLD_LED_GREEN_STATIC_ON, 1,\n\t\t\"mlxcpld:status:green\",\n\t},\n\t{\n\t\t0x20, 0xf0, MLXCPLD_LED_RED_STATIC_ON, LED_OFF,\n\t\t\"mlxcpld:status:red\",\n\t},\n\t{\n\t\t0x24, 0xf0, MLXCPLD_LED_GREEN_STATIC_ON, LED_OFF,\n\t\t\"mlxcpld:uid:blue\",\n\t},\n};\n\nenum mlxcpld_led_platform_types {\n\tMLXCPLD_LED_PLATFORM_DEFAULT,\n\tMLXCPLD_LED_PLATFORM_MSN2100,\n};\n\nstatic const char *mlx_product_names[] = {\n\t\"DEFAULT\",\n\t\"MSN2100\",\n};\n\nstatic enum\nmlxcpld_led_platform_types mlxcpld_led_platform_check_sys_type(void)\n{\n\tconst char *mlx_product_name;\n\tint i;\n\n\tmlx_product_name = dmi_get_system_info(DMI_PRODUCT_NAME);\n\tif (!mlx_product_name)\n\t\treturn MLXCPLD_LED_PLATFORM_DEFAULT;\n\n\tfor (i = 1;  i < ARRAY_SIZE(mlx_product_names); i++) {\n\t\tif (strstr(mlx_product_name, mlx_product_names[i]))\n\t\t\treturn i;\n\t}\n\n\treturn MLXCPLD_LED_PLATFORM_DEFAULT;\n}\n\nstatic void mlxcpld_led_bus_access_func(u16 base, u8 offset, u8 rw_flag,\n\t\t\t\t\tu8 *data)\n{\n\tu32 addr = base + offset;\n\n\tif (rw_flag == 0)\n\t\toutb(*data, addr);\n\telse\n\t\t*data = inb(addr);\n}\n\nstatic void mlxcpld_led_store_hw(u8 mask, u8 off, u8 vset)\n{\n\tu8 nib, val;\n\n\t \n\tspin_lock(&mlxcpld_led->lock);\n\tmlxcpld_led_bus_access_func(MLXPLAT_CPLD_LPC_REG_BASE_ADRR, off, 1,\n\t\t\t\t    &val);\n\tnib = (mask == 0xf0) ? vset : (vset << 4);\n\tval = (val & mask) | nib;\n\tmlxcpld_led_bus_access_func(MLXPLAT_CPLD_LPC_REG_BASE_ADRR, off, 0,\n\t\t\t\t    &val);\n\tspin_unlock(&mlxcpld_led->lock);\n}\n\nstatic void mlxcpld_led_brightness_set(struct led_classdev *led,\n\t\t\t\t       enum led_brightness value)\n{\n\tstruct mlxcpld_led_priv *pled = cdev_to_priv(led);\n\n\tif (value) {\n\t\tmlxcpld_led_store_hw(pled->param.mask, pled->param.offset,\n\t\t\t\t     pled->param.base_color);\n\t\treturn;\n\t}\n\n\tmlxcpld_led_store_hw(pled->param.mask, pled->param.offset,\n\t\t\t     MLXCPLD_LED_IS_OFF);\n}\n\nstatic int mlxcpld_led_blink_set(struct led_classdev *led,\n\t\t\t\t unsigned long *delay_on,\n\t\t\t\t unsigned long *delay_off)\n{\n\tstruct mlxcpld_led_priv *pled = cdev_to_priv(led);\n\n\t \n\tif (!(*delay_on == 0 && *delay_off == 0) &&\n\t    !(*delay_on == MLXCPLD_LED_BLINK_3HZ &&\n\t      *delay_off == MLXCPLD_LED_BLINK_3HZ) &&\n\t    !(*delay_on == MLXCPLD_LED_BLINK_6HZ &&\n\t      *delay_off == MLXCPLD_LED_BLINK_6HZ))\n\t\treturn -EINVAL;\n\n\tif (*delay_on == MLXCPLD_LED_BLINK_6HZ)\n\t\tmlxcpld_led_store_hw(pled->param.mask, pled->param.offset,\n\t\t\t\t     pled->param.base_color +\n\t\t\t\t     MLXCPLD_LED_OFFSET_FULL);\n\telse\n\t\tmlxcpld_led_store_hw(pled->param.mask, pled->param.offset,\n\t\t\t\t     pled->param.base_color +\n\t\t\t\t     MLXCPLD_LED_OFFSET_HALF);\n\n\treturn 0;\n}\n\nstatic int mlxcpld_led_config(struct device *dev,\n\t\t\t      struct mlxcpld_led_pdata *cpld)\n{\n\tint i;\n\tint err;\n\n\tcpld->pled = devm_kcalloc(dev,\n\t\t\t\t  cpld->num_led_instances,\n\t\t\t\t  sizeof(struct mlxcpld_led_priv),\n\t\t\t\t  GFP_KERNEL);\n\tif (!cpld->pled)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cpld->num_led_instances; i++) {\n\t\tcpld->pled[i].cdev.name = cpld->profile[i].name;\n\t\tcpld->pled[i].cdev.brightness = cpld->profile[i].brightness;\n\t\tcpld->pled[i].cdev.max_brightness = 1;\n\t\tcpld->pled[i].cdev.brightness_set = mlxcpld_led_brightness_set;\n\t\tcpld->pled[i].cdev.blink_set = mlxcpld_led_blink_set;\n\t\tcpld->pled[i].cdev.flags = LED_CORE_SUSPENDRESUME;\n\t\terr = devm_led_classdev_register(dev, &cpld->pled[i].cdev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcpld->pled[i].param.offset = mlxcpld_led->profile[i].offset;\n\t\tcpld->pled[i].param.mask = mlxcpld_led->profile[i].mask;\n\t\tcpld->pled[i].param.base_color =\n\t\t\t\t\tmlxcpld_led->profile[i].base_color;\n\n\t\tif (mlxcpld_led->profile[i].brightness)\n\t\t\tmlxcpld_led_brightness_set(&cpld->pled[i].cdev,\n\t\t\t\t\tmlxcpld_led->profile[i].brightness);\n\t}\n\n\treturn 0;\n}\n\nstatic int __init mlxcpld_led_probe(struct platform_device *pdev)\n{\n\tenum mlxcpld_led_platform_types mlxcpld_led_plat =\n\t\t\t\t\tmlxcpld_led_platform_check_sys_type();\n\n\tmlxcpld_led = devm_kzalloc(&pdev->dev, sizeof(*mlxcpld_led),\n\t\t\t\t   GFP_KERNEL);\n\tif (!mlxcpld_led)\n\t\treturn -ENOMEM;\n\n\tmlxcpld_led->pdev = pdev;\n\n\tswitch (mlxcpld_led_plat) {\n\tcase MLXCPLD_LED_PLATFORM_MSN2100:\n\t\tmlxcpld_led->profile = mlxcpld_led_msn2100_profile;\n\t\tmlxcpld_led->num_led_instances =\n\t\t\t\tARRAY_SIZE(mlxcpld_led_msn2100_profile);\n\t\tbreak;\n\n\tdefault:\n\t\tmlxcpld_led->profile = mlxcpld_led_default_profile;\n\t\tmlxcpld_led->num_led_instances =\n\t\t\t\tARRAY_SIZE(mlxcpld_led_default_profile);\n\t\tbreak;\n\t}\n\n\tspin_lock_init(&mlxcpld_led->lock);\n\n\treturn mlxcpld_led_config(&pdev->dev, mlxcpld_led);\n}\n\nstatic struct platform_driver mlxcpld_led_driver = {\n\t.driver = {\n\t\t.name\t= KBUILD_MODNAME,\n\t},\n};\n\nstatic int __init mlxcpld_led_init(void)\n{\n\tstruct platform_device *pdev;\n\tint err;\n\n\tif (!dmi_match(DMI_CHASSIS_VENDOR, \"Mellanox Technologies Ltd.\"))\n\t\treturn -ENODEV;\n\n\tpdev = platform_device_register_simple(KBUILD_MODNAME, -1, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\tpr_err(\"Device allocation failed\\n\");\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\terr = platform_driver_probe(&mlxcpld_led_driver, mlxcpld_led_probe);\n\tif (err) {\n\t\tpr_err(\"Probe platform driver failed\\n\");\n\t\tplatform_device_unregister(pdev);\n\t}\n\n\treturn err;\n}\n\nstatic void __exit mlxcpld_led_exit(void)\n{\n\tplatform_device_unregister(mlxcpld_led->pdev);\n\tplatform_driver_unregister(&mlxcpld_led_driver);\n}\n\nmodule_init(mlxcpld_led_init);\nmodule_exit(mlxcpld_led_exit);\n\nMODULE_AUTHOR(\"Vadim Pasternak <vadimp@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox board LED driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"platform:leds_mlxcpld\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}