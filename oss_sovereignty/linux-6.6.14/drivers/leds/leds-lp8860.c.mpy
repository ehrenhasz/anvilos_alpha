{
  "module_name": "leds-lp8860.c",
  "hash_id": "5e81b1722eb72c986c362a0c9e98272c0830dd606ddf7a9826719a1875db63da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lp8860.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/leds.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n\n#define LP8860_DISP_CL1_BRT_MSB\t\t0x00\n#define LP8860_DISP_CL1_BRT_LSB\t\t0x01\n#define LP8860_DISP_CL1_CURR_MSB\t0x02\n#define LP8860_DISP_CL1_CURR_LSB\t0x03\n#define LP8860_CL2_BRT_MSB\t\t0x04\n#define LP8860_CL2_BRT_LSB\t\t0x05\n#define LP8860_CL2_CURRENT\t\t0x06\n#define LP8860_CL3_BRT_MSB\t\t0x07\n#define LP8860_CL3_BRT_LSB\t\t0x08\n#define LP8860_CL3_CURRENT\t\t0x09\n#define LP8860_CL4_BRT_MSB\t\t0x0a\n#define LP8860_CL4_BRT_LSB\t\t0x0b\n#define LP8860_CL4_CURRENT\t\t0x0c\n#define LP8860_CONFIG\t\t\t0x0d\n#define LP8860_STATUS\t\t\t0x0e\n#define LP8860_FAULT\t\t\t0x0f\n#define LP8860_LED_FAULT\t\t0x10\n#define LP8860_FAULT_CLEAR\t\t0x11\n#define LP8860_ID\t\t\t0x12\n#define LP8860_TEMP_MSB\t\t\t0x13\n#define LP8860_TEMP_LSB\t\t\t0x14\n#define LP8860_DISP_LED_CURR_MSB\t0x15\n#define LP8860_DISP_LED_CURR_LSB\t0x16\n#define LP8860_DISP_LED_PWM_MSB\t\t0x17\n#define LP8860_DISP_LED_PWM_LSB\t\t0x18\n#define LP8860_EEPROM_CNTRL\t\t0x19\n#define LP8860_EEPROM_UNLOCK\t\t0x1a\n\n#define LP8860_EEPROM_REG_0\t\t0x60\n#define LP8860_EEPROM_REG_1\t\t0x61\n#define LP8860_EEPROM_REG_2\t\t0x62\n#define LP8860_EEPROM_REG_3\t\t0x63\n#define LP8860_EEPROM_REG_4\t\t0x64\n#define LP8860_EEPROM_REG_5\t\t0x65\n#define LP8860_EEPROM_REG_6\t\t0x66\n#define LP8860_EEPROM_REG_7\t\t0x67\n#define LP8860_EEPROM_REG_8\t\t0x68\n#define LP8860_EEPROM_REG_9\t\t0x69\n#define LP8860_EEPROM_REG_10\t\t0x6a\n#define LP8860_EEPROM_REG_11\t\t0x6b\n#define LP8860_EEPROM_REG_12\t\t0x6c\n#define LP8860_EEPROM_REG_13\t\t0x6d\n#define LP8860_EEPROM_REG_14\t\t0x6e\n#define LP8860_EEPROM_REG_15\t\t0x6f\n#define LP8860_EEPROM_REG_16\t\t0x70\n#define LP8860_EEPROM_REG_17\t\t0x71\n#define LP8860_EEPROM_REG_18\t\t0x72\n#define LP8860_EEPROM_REG_19\t\t0x73\n#define LP8860_EEPROM_REG_20\t\t0x74\n#define LP8860_EEPROM_REG_21\t\t0x75\n#define LP8860_EEPROM_REG_22\t\t0x76\n#define LP8860_EEPROM_REG_23\t\t0x77\n#define LP8860_EEPROM_REG_24\t\t0x78\n\n#define LP8860_LOCK_EEPROM\t\t0x00\n#define LP8860_UNLOCK_EEPROM\t\t0x01\n#define LP8860_PROGRAM_EEPROM\t\t0x02\n#define LP8860_EEPROM_CODE_1\t\t0x08\n#define LP8860_EEPROM_CODE_2\t\t0xba\n#define LP8860_EEPROM_CODE_3\t\t0xef\n\n#define LP8860_CLEAR_FAULTS\t\t0x01\n\n#define LP8860_NAME\t\t\t\"lp8860\"\n\n \nstruct lp8860_led {\n\tstruct mutex lock;\n\tstruct i2c_client *client;\n\tstruct led_classdev led_dev;\n\tstruct regmap *regmap;\n\tstruct regmap *eeprom_regmap;\n\tstruct gpio_desc *enable_gpio;\n\tstruct regulator *regulator;\n};\n\nstruct lp8860_eeprom_reg {\n\tuint8_t reg;\n\tuint8_t value;\n};\n\nstatic struct lp8860_eeprom_reg lp8860_eeprom_disp_regs[] = {\n\t{ LP8860_EEPROM_REG_0, 0xed },\n\t{ LP8860_EEPROM_REG_1, 0xdf },\n\t{ LP8860_EEPROM_REG_2, 0xdc },\n\t{ LP8860_EEPROM_REG_3, 0xf0 },\n\t{ LP8860_EEPROM_REG_4, 0xdf },\n\t{ LP8860_EEPROM_REG_5, 0xe5 },\n\t{ LP8860_EEPROM_REG_6, 0xf2 },\n\t{ LP8860_EEPROM_REG_7, 0x77 },\n\t{ LP8860_EEPROM_REG_8, 0x77 },\n\t{ LP8860_EEPROM_REG_9, 0x71 },\n\t{ LP8860_EEPROM_REG_10, 0x3f },\n\t{ LP8860_EEPROM_REG_11, 0xb7 },\n\t{ LP8860_EEPROM_REG_12, 0x17 },\n\t{ LP8860_EEPROM_REG_13, 0xef },\n\t{ LP8860_EEPROM_REG_14, 0xb0 },\n\t{ LP8860_EEPROM_REG_15, 0x87 },\n\t{ LP8860_EEPROM_REG_16, 0xce },\n\t{ LP8860_EEPROM_REG_17, 0x72 },\n\t{ LP8860_EEPROM_REG_18, 0xe5 },\n\t{ LP8860_EEPROM_REG_19, 0xdf },\n\t{ LP8860_EEPROM_REG_20, 0x35 },\n\t{ LP8860_EEPROM_REG_21, 0x06 },\n\t{ LP8860_EEPROM_REG_22, 0xdc },\n\t{ LP8860_EEPROM_REG_23, 0x88 },\n\t{ LP8860_EEPROM_REG_24, 0x3E },\n};\n\nstatic int lp8860_unlock_eeprom(struct lp8860_led *led, int lock)\n{\n\tint ret;\n\n\tmutex_lock(&led->lock);\n\n\tif (lock == LP8860_UNLOCK_EEPROM) {\n\t\tret = regmap_write(led->regmap,\n\t\t\tLP8860_EEPROM_UNLOCK,\n\t\t\tLP8860_EEPROM_CODE_1);\n\t\tif (ret) {\n\t\t\tdev_err(&led->client->dev, \"EEPROM Unlock failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = regmap_write(led->regmap,\n\t\t\tLP8860_EEPROM_UNLOCK,\n\t\t\tLP8860_EEPROM_CODE_2);\n\t\tif (ret) {\n\t\t\tdev_err(&led->client->dev, \"EEPROM Unlock failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tret = regmap_write(led->regmap,\n\t\t\tLP8860_EEPROM_UNLOCK,\n\t\t\tLP8860_EEPROM_CODE_3);\n\t\tif (ret) {\n\t\t\tdev_err(&led->client->dev, \"EEPROM Unlock failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = regmap_write(led->regmap,\n\t\t\tLP8860_EEPROM_UNLOCK,\n\t\t\tLP8860_LOCK_EEPROM);\n\t}\n\nout:\n\tmutex_unlock(&led->lock);\n\treturn ret;\n}\n\nstatic int lp8860_fault_check(struct lp8860_led *led)\n{\n\tint ret, fault;\n\tunsigned int read_buf;\n\n\tret = regmap_read(led->regmap, LP8860_LED_FAULT, &read_buf);\n\tif (ret)\n\t\tgoto out;\n\n\tfault = read_buf;\n\n\tret = regmap_read(led->regmap, LP8860_FAULT, &read_buf);\n\tif (ret)\n\t\tgoto out;\n\n\tfault |= read_buf;\n\n\t \n\tif (fault)\n\t\tret = regmap_write(led->regmap, LP8860_FAULT_CLEAR,\n\t\t\tLP8860_CLEAR_FAULTS);\nout:\n\treturn ret;\n}\n\nstatic int lp8860_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\tenum led_brightness brt_val)\n{\n\tstruct lp8860_led *led =\n\t\t\tcontainer_of(led_cdev, struct lp8860_led, led_dev);\n\tint disp_brightness = brt_val * 255;\n\tint ret;\n\n\tmutex_lock(&led->lock);\n\n\tret = lp8860_fault_check(led);\n\tif (ret) {\n\t\tdev_err(&led->client->dev, \"Cannot read/clear faults\\n\");\n\t\tgoto out;\n\t}\n\n\tret = regmap_write(led->regmap, LP8860_DISP_CL1_BRT_MSB,\n\t\t\t(disp_brightness & 0xff00) >> 8);\n\tif (ret) {\n\t\tdev_err(&led->client->dev, \"Cannot write CL1 MSB\\n\");\n\t\tgoto out;\n\t}\n\n\tret = regmap_write(led->regmap, LP8860_DISP_CL1_BRT_LSB,\n\t\t\tdisp_brightness & 0xff);\n\tif (ret) {\n\t\tdev_err(&led->client->dev, \"Cannot write CL1 LSB\\n\");\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&led->lock);\n\treturn ret;\n}\n\nstatic int lp8860_init(struct lp8860_led *led)\n{\n\tunsigned int read_buf;\n\tint ret, i, reg_count;\n\n\tif (led->regulator) {\n\t\tret = regulator_enable(led->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(&led->client->dev,\n\t\t\t\t\"Failed to enable regulator\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tgpiod_direction_output(led->enable_gpio, 1);\n\n\tret = lp8860_fault_check(led);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_read(led->regmap, LP8860_STATUS, &read_buf);\n\tif (ret)\n\t\tgoto out;\n\n\tret = lp8860_unlock_eeprom(led, LP8860_UNLOCK_EEPROM);\n\tif (ret) {\n\t\tdev_err(&led->client->dev, \"Failed unlocking EEPROM\\n\");\n\t\tgoto out;\n\t}\n\n\treg_count = ARRAY_SIZE(lp8860_eeprom_disp_regs) / sizeof(lp8860_eeprom_disp_regs[0]);\n\tfor (i = 0; i < reg_count; i++) {\n\t\tret = regmap_write(led->eeprom_regmap,\n\t\t\t\tlp8860_eeprom_disp_regs[i].reg,\n\t\t\t\tlp8860_eeprom_disp_regs[i].value);\n\t\tif (ret) {\n\t\t\tdev_err(&led->client->dev, \"Failed writing EEPROM\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lp8860_unlock_eeprom(led, LP8860_LOCK_EEPROM);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_write(led->regmap,\n\t\t\tLP8860_EEPROM_CNTRL,\n\t\t\tLP8860_PROGRAM_EEPROM);\n\tif (ret) {\n\t\tdev_err(&led->client->dev, \"Failed programming EEPROM\\n\");\n\t\tgoto out;\n\t}\n\n\treturn ret;\n\nout:\n\tif (ret)\n\t\tgpiod_direction_output(led->enable_gpio, 0);\n\n\tif (led->regulator) {\n\t\tret = regulator_disable(led->regulator);\n\t\tif (ret)\n\t\t\tdev_err(&led->client->dev,\n\t\t\t\t\"Failed to disable regulator\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic const struct reg_default lp8860_reg_defs[] = {\n\t{ LP8860_DISP_CL1_BRT_MSB, 0x00},\n\t{ LP8860_DISP_CL1_BRT_LSB, 0x00},\n\t{ LP8860_DISP_CL1_CURR_MSB, 0x00},\n\t{ LP8860_DISP_CL1_CURR_LSB, 0x00},\n\t{ LP8860_CL2_BRT_MSB, 0x00},\n\t{ LP8860_CL2_BRT_LSB, 0x00},\n\t{ LP8860_CL2_CURRENT, 0x00},\n\t{ LP8860_CL3_BRT_MSB, 0x00},\n\t{ LP8860_CL3_BRT_LSB, 0x00},\n\t{ LP8860_CL3_CURRENT, 0x00},\n\t{ LP8860_CL4_BRT_MSB, 0x00},\n\t{ LP8860_CL4_BRT_LSB, 0x00},\n\t{ LP8860_CL4_CURRENT, 0x00},\n\t{ LP8860_CONFIG, 0x00},\n\t{ LP8860_FAULT_CLEAR, 0x00},\n\t{ LP8860_EEPROM_CNTRL, 0x80},\n\t{ LP8860_EEPROM_UNLOCK, 0x00},\n};\n\nstatic const struct regmap_config lp8860_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = LP8860_EEPROM_UNLOCK,\n\t.reg_defaults = lp8860_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(lp8860_reg_defs),\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic const struct reg_default lp8860_eeprom_defs[] = {\n\t{ LP8860_EEPROM_REG_0, 0x00 },\n\t{ LP8860_EEPROM_REG_1, 0x00 },\n\t{ LP8860_EEPROM_REG_2, 0x00 },\n\t{ LP8860_EEPROM_REG_3, 0x00 },\n\t{ LP8860_EEPROM_REG_4, 0x00 },\n\t{ LP8860_EEPROM_REG_5, 0x00 },\n\t{ LP8860_EEPROM_REG_6, 0x00 },\n\t{ LP8860_EEPROM_REG_7, 0x00 },\n\t{ LP8860_EEPROM_REG_8, 0x00 },\n\t{ LP8860_EEPROM_REG_9, 0x00 },\n\t{ LP8860_EEPROM_REG_10, 0x00 },\n\t{ LP8860_EEPROM_REG_11, 0x00 },\n\t{ LP8860_EEPROM_REG_12, 0x00 },\n\t{ LP8860_EEPROM_REG_13, 0x00 },\n\t{ LP8860_EEPROM_REG_14, 0x00 },\n\t{ LP8860_EEPROM_REG_15, 0x00 },\n\t{ LP8860_EEPROM_REG_16, 0x00 },\n\t{ LP8860_EEPROM_REG_17, 0x00 },\n\t{ LP8860_EEPROM_REG_18, 0x00 },\n\t{ LP8860_EEPROM_REG_19, 0x00 },\n\t{ LP8860_EEPROM_REG_20, 0x00 },\n\t{ LP8860_EEPROM_REG_21, 0x00 },\n\t{ LP8860_EEPROM_REG_22, 0x00 },\n\t{ LP8860_EEPROM_REG_23, 0x00 },\n\t{ LP8860_EEPROM_REG_24, 0x00 },\n};\n\nstatic const struct regmap_config lp8860_eeprom_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = LP8860_EEPROM_REG_24,\n\t.reg_defaults = lp8860_eeprom_defs,\n\t.num_reg_defaults = ARRAY_SIZE(lp8860_eeprom_defs),\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic int lp8860_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct lp8860_led *led;\n\tstruct device_node *np = dev_of_node(&client->dev);\n\tstruct device_node *child_node;\n\tstruct led_init_data init_data = {};\n\n\tled = devm_kzalloc(&client->dev, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tchild_node = of_get_next_available_child(np, NULL);\n\tif (!child_node)\n\t\treturn -EINVAL;\n\n\tled->enable_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t   \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(led->enable_gpio)) {\n\t\tret = PTR_ERR(led->enable_gpio);\n\t\tdev_err(&client->dev, \"Failed to get enable gpio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tled->regulator = devm_regulator_get(&client->dev, \"vled\");\n\tif (IS_ERR(led->regulator))\n\t\tled->regulator = NULL;\n\n\tled->client = client;\n\tled->led_dev.brightness_set_blocking = lp8860_brightness_set;\n\n\tmutex_init(&led->lock);\n\n\ti2c_set_clientdata(client, led);\n\n\tled->regmap = devm_regmap_init_i2c(client, &lp8860_regmap_config);\n\tif (IS_ERR(led->regmap)) {\n\t\tret = PTR_ERR(led->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tled->eeprom_regmap = devm_regmap_init_i2c(client, &lp8860_eeprom_regmap_config);\n\tif (IS_ERR(led->eeprom_regmap)) {\n\t\tret = PTR_ERR(led->eeprom_regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = lp8860_init(led);\n\tif (ret)\n\t\treturn ret;\n\n\tinit_data.fwnode = of_fwnode_handle(child_node);\n\tinit_data.devicename = LP8860_NAME;\n\tinit_data.default_label = \":display_cluster\";\n\n\tret = devm_led_classdev_register_ext(&client->dev, &led->led_dev,\n\t\t\t\t\t     &init_data);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"led register err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void lp8860_remove(struct i2c_client *client)\n{\n\tstruct lp8860_led *led = i2c_get_clientdata(client);\n\tint ret;\n\n\tgpiod_direction_output(led->enable_gpio, 0);\n\n\tif (led->regulator) {\n\t\tret = regulator_disable(led->regulator);\n\t\tif (ret)\n\t\t\tdev_err(&led->client->dev,\n\t\t\t\t\"Failed to disable regulator\\n\");\n\t}\n\n\tmutex_destroy(&led->lock);\n}\n\nstatic const struct i2c_device_id lp8860_id[] = {\n\t{ \"lp8860\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lp8860_id);\n\nstatic const struct of_device_id of_lp8860_leds_match[] = {\n\t{ .compatible = \"ti,lp8860\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_lp8860_leds_match);\n\nstatic struct i2c_driver lp8860_driver = {\n\t.driver = {\n\t\t.name\t= \"lp8860\",\n\t\t.of_match_table = of_lp8860_leds_match,\n\t},\n\t.probe\t\t= lp8860_probe,\n\t.remove\t\t= lp8860_remove,\n\t.id_table\t= lp8860_id,\n};\nmodule_i2c_driver(lp8860_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments LP8860 LED driver\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}