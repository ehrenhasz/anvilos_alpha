{
  "module_name": "leds-powernv.c",
  "hash_id": "9962a7715c56cc7a9861c8aede7c030ee7a44b65e4cfb5fcc7897b23e54b4032",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-powernv.c",
  "human_readable_source": "\n \n\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <asm/opal.h>\n\n \nstruct led_type_map {\n\tconst int\ttype;\n\tconst char\t*desc;\n};\nstatic const struct led_type_map led_type_map[] = {\n\t{OPAL_SLOT_LED_TYPE_ID,\t\t\"identify\"},\n\t{OPAL_SLOT_LED_TYPE_FAULT,\t\"fault\"},\n\t{OPAL_SLOT_LED_TYPE_ATTN,\t\"attention\"},\n\t{-1,\t\t\t\tNULL},\n};\n\nstruct powernv_led_common {\n\t \n\tbool\t\tled_disabled;\n\n\t \n\t__be64\t\tmax_led_type;\n\n\t \n\tstruct mutex\tlock;\n};\n\n \nstruct powernv_led_data {\n\tstruct led_classdev\tcdev;\n\tchar\t\t\t*loc_code;\t \n\tint\t\t\tled_type;\t \n\n\tstruct powernv_led_common *common;\n};\n\n\n \nstatic int powernv_get_led_type(const char *led_type_desc)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(led_type_map); i++)\n\t\tif (!strcmp(led_type_map[i].desc, led_type_desc))\n\t\t\treturn led_type_map[i].type;\n\n\treturn -1;\n}\n\n \nstatic int powernv_led_set(struct powernv_led_data *powernv_led,\n\t\t\t    enum led_brightness value)\n{\n\tint rc, token;\n\tu64 led_mask, led_value = 0;\n\t__be64 max_type;\n\tstruct opal_msg msg;\n\tstruct device *dev = powernv_led->cdev.dev;\n\tstruct powernv_led_common *powernv_led_common = powernv_led->common;\n\n\t \n\tmax_type = powernv_led_common->max_led_type;\n\tled_mask = OPAL_SLOT_LED_STATE_ON << powernv_led->led_type;\n\tif (value)\n\t\tled_value = led_mask;\n\n\t \n\ttoken = opal_async_get_token_interruptible();\n\tif (token < 0) {\n\t\tif (token != -ERESTARTSYS)\n\t\t\tdev_err(dev, \"%s: Couldn't get OPAL async token\\n\",\n\t\t\t\t__func__);\n\t\treturn token;\n\t}\n\n\trc = opal_leds_set_ind(token, powernv_led->loc_code,\n\t\t\t       led_mask, led_value, &max_type);\n\tif (rc != OPAL_ASYNC_COMPLETION) {\n\t\tdev_err(dev, \"%s: OPAL set LED call failed for %s [rc=%d]\\n\",\n\t\t\t__func__, powernv_led->loc_code, rc);\n\t\tgoto out_token;\n\t}\n\n\trc = opal_async_wait_response(token, &msg);\n\tif (rc) {\n\t\tdev_err(dev,\n\t\t\t\"%s: Failed to wait for the async response [rc=%d]\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out_token;\n\t}\n\n\trc = opal_get_async_rc(msg);\n\tif (rc != OPAL_SUCCESS)\n\t\tdev_err(dev, \"%s : OAPL async call returned failed [rc=%d]\\n\",\n\t\t\t__func__, rc);\n\nout_token:\n\topal_async_release_token(token);\n\treturn rc;\n}\n\n \nstatic enum led_brightness powernv_led_get(struct powernv_led_data *powernv_led)\n{\n\tint rc;\n\t__be64 mask, value, max_type;\n\tu64 led_mask, led_value;\n\tstruct device *dev = powernv_led->cdev.dev;\n\tstruct powernv_led_common *powernv_led_common = powernv_led->common;\n\n\t \n\tmask = cpu_to_be64(0);\n\tvalue = cpu_to_be64(0);\n\tmax_type = powernv_led_common->max_led_type;\n\n\trc = opal_leds_get_ind(powernv_led->loc_code,\n\t\t\t       &mask, &value, &max_type);\n\tif (rc != OPAL_SUCCESS && rc != OPAL_PARTIAL) {\n\t\tdev_err(dev, \"%s: OPAL get led call failed [rc=%d]\\n\",\n\t\t\t__func__, rc);\n\t\treturn LED_OFF;\n\t}\n\n\tled_mask = be64_to_cpu(mask);\n\tled_value = be64_to_cpu(value);\n\n\t \n\tif (!((led_mask >> powernv_led->led_type) & OPAL_SLOT_LED_STATE_ON)) {\n\t\tdev_err(dev, \"%s: LED status not available for %s\\n\",\n\t\t\t__func__, powernv_led->cdev.name);\n\t\treturn LED_OFF;\n\t}\n\n\t \n\tif ((led_value >> powernv_led->led_type) & OPAL_SLOT_LED_STATE_ON)\n\t\treturn LED_FULL;\n\n\treturn LED_OFF;\n}\n\n \nstatic int powernv_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t   enum led_brightness value)\n{\n\tstruct powernv_led_data *powernv_led =\n\t\tcontainer_of(led_cdev, struct powernv_led_data, cdev);\n\tstruct powernv_led_common *powernv_led_common = powernv_led->common;\n\tint rc;\n\n\t \n\tif (powernv_led_common->led_disabled)\n\t\treturn 0;\n\n\tmutex_lock(&powernv_led_common->lock);\n\trc = powernv_led_set(powernv_led, value);\n\tmutex_unlock(&powernv_led_common->lock);\n\n\treturn rc;\n}\n\n \nstatic enum led_brightness powernv_brightness_get(struct led_classdev *led_cdev)\n{\n\tstruct powernv_led_data *powernv_led =\n\t\tcontainer_of(led_cdev, struct powernv_led_data, cdev);\n\n\treturn powernv_led_get(powernv_led);\n}\n\n \nstatic int powernv_led_create(struct device *dev,\n\t\t\t      struct powernv_led_data *powernv_led,\n\t\t\t      const char *led_type_desc)\n{\n\tint rc;\n\n\t \n\tpowernv_led->led_type = powernv_get_led_type(led_type_desc);\n\tif (powernv_led->led_type == -1) {\n\t\tdev_warn(dev, \"%s: No support for led type : %s\\n\",\n\t\t\t __func__, led_type_desc);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpowernv_led->cdev.name = devm_kasprintf(dev, GFP_KERNEL, \"%s:%s\",\n\t\t\t\t\t\tpowernv_led->loc_code,\n\t\t\t\t\t\tled_type_desc);\n\tif (!powernv_led->cdev.name)\n\t\treturn -ENOMEM;\n\n\tpowernv_led->cdev.brightness_set_blocking = powernv_brightness_set;\n\tpowernv_led->cdev.brightness_get = powernv_brightness_get;\n\tpowernv_led->cdev.brightness = LED_OFF;\n\tpowernv_led->cdev.max_brightness = LED_FULL;\n\n\t \n\trc = devm_led_classdev_register(dev, &powernv_led->cdev);\n\tif (rc) {\n\t\tdev_err(dev, \"%s: Classdev registration failed for %s\\n\",\n\t\t\t__func__, powernv_led->cdev.name);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int powernv_led_classdev(struct platform_device *pdev,\n\t\t\t\tstruct device_node *led_node,\n\t\t\t\tstruct powernv_led_common *powernv_led_common)\n{\n\tconst char *cur = NULL;\n\tint rc = -1;\n\tstruct property *p;\n\tstruct device_node *np;\n\tstruct powernv_led_data *powernv_led;\n\tstruct device *dev = &pdev->dev;\n\n\tfor_each_available_child_of_node(led_node, np) {\n\t\tp = of_find_property(np, \"led-types\", NULL);\n\n\t\twhile ((cur = of_prop_next_string(p, cur)) != NULL) {\n\t\t\tpowernv_led = devm_kzalloc(dev, sizeof(*powernv_led),\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!powernv_led) {\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tpowernv_led->common = powernv_led_common;\n\t\t\tpowernv_led->loc_code = (char *)np->name;\n\n\t\t\trc = powernv_led_create(dev, powernv_led, cur);\n\t\t\tif (rc) {\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}  \n\t}\n\n\treturn rc;\n}\n\n \nstatic int powernv_led_probe(struct platform_device *pdev)\n{\n\tstruct device_node *led_node;\n\tstruct powernv_led_common *powernv_led_common;\n\tstruct device *dev = &pdev->dev;\n\tint rc;\n\n\tled_node = of_find_node_by_path(\"/ibm,opal/leds\");\n\tif (!led_node) {\n\t\tdev_err(dev, \"%s: LED parent device node not found\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tpowernv_led_common = devm_kzalloc(dev, sizeof(*powernv_led_common),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!powernv_led_common) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_init(&powernv_led_common->lock);\n\tpowernv_led_common->max_led_type = cpu_to_be64(OPAL_SLOT_LED_TYPE_MAX);\n\n\tplatform_set_drvdata(pdev, powernv_led_common);\n\n\trc = powernv_led_classdev(pdev, led_node, powernv_led_common);\nout:\n\tof_node_put(led_node);\n\treturn rc;\n}\n\n \nstatic int powernv_led_remove(struct platform_device *pdev)\n{\n\tstruct powernv_led_common *powernv_led_common;\n\n\t \n\tpowernv_led_common = platform_get_drvdata(pdev);\n\tpowernv_led_common->led_disabled = true;\n\n\t \n\tmutex_destroy(&powernv_led_common->lock);\n\n\tdev_info(&pdev->dev, \"PowerNV led module unregistered\\n\");\n\treturn 0;\n}\n\n \nstatic const struct of_device_id powernv_led_match[] = {\n\t{\n\t\t.compatible\t= \"ibm,opal-v3-led\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, powernv_led_match);\n\nstatic struct platform_driver powernv_led_driver = {\n\t.probe\t= powernv_led_probe,\n\t.remove = powernv_led_remove,\n\t.driver = {\n\t\t.name = \"powernv-led-driver\",\n\t\t.of_match_table = powernv_led_match,\n\t},\n};\n\nmodule_platform_driver(powernv_led_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"PowerNV LED driver\");\nMODULE_AUTHOR(\"Vasant Hegde <hegdevasant@linux.vnet.ibm.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}