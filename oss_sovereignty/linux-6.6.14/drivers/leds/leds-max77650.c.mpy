{
  "module_name": "leds-max77650.c",
  "hash_id": "74781a8deb345e8d3a70df79bda9d1d2a43dff1d86bb7943f1615753612d4ec2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-max77650.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/mfd/max77650.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define MAX77650_LED_NUM_LEDS\t\t3\n\n#define MAX77650_LED_A_BASE\t\t0x40\n#define MAX77650_LED_B_BASE\t\t0x43\n\n#define MAX77650_LED_BR_MASK\t\tGENMASK(4, 0)\n#define MAX77650_LED_EN_MASK\t\tGENMASK(7, 6)\n\n#define MAX77650_LED_MAX_BRIGHTNESS\tMAX77650_LED_BR_MASK\n\n \n#define MAX77650_LED_TOP_DEFAULT\tBIT(0)\n\n#define MAX77650_LED_ENABLE\t\tGENMASK(7, 6)\n#define MAX77650_LED_DISABLE\t\t0x00\n\n#define MAX77650_LED_A_DEFAULT\t\tMAX77650_LED_DISABLE\n \n#define MAX77650_LED_B_DEFAULT\t\tGENMASK(3, 0)\n\nstruct max77650_led {\n\tstruct led_classdev cdev;\n\tstruct regmap *map;\n\tunsigned int regA;\n\tunsigned int regB;\n};\n\nstatic struct max77650_led *max77650_to_led(struct led_classdev *cdev)\n{\n\treturn container_of(cdev, struct max77650_led, cdev);\n}\n\nstatic int max77650_led_brightness_set(struct led_classdev *cdev,\n\t\t\t\t       enum led_brightness brightness)\n{\n\tstruct max77650_led *led = max77650_to_led(cdev);\n\tint val, mask;\n\n\tmask = MAX77650_LED_BR_MASK | MAX77650_LED_EN_MASK;\n\n\tif (brightness == LED_OFF)\n\t\tval = MAX77650_LED_DISABLE;\n\telse\n\t\tval = MAX77650_LED_ENABLE | brightness;\n\n\treturn regmap_update_bits(led->map, led->regA, mask, val);\n}\n\nstatic int max77650_led_probe(struct platform_device *pdev)\n{\n\tstruct fwnode_handle *child;\n\tstruct max77650_led *leds, *led;\n\tstruct device *dev;\n\tstruct regmap *map;\n\tint rv, num_leds;\n\tu32 reg;\n\n\tdev = &pdev->dev;\n\n\tleds = devm_kcalloc(dev, sizeof(*leds),\n\t\t\t    MAX77650_LED_NUM_LEDS, GFP_KERNEL);\n\tif (!leds)\n\t\treturn -ENOMEM;\n\n\tmap = dev_get_regmap(dev->parent, NULL);\n\tif (!map)\n\t\treturn -ENODEV;\n\n\tnum_leds = device_get_child_node_count(dev);\n\tif (!num_leds || num_leds > MAX77650_LED_NUM_LEDS)\n\t\treturn -ENODEV;\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tstruct led_init_data init_data = {};\n\n\t\trv = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (rv || reg >= MAX77650_LED_NUM_LEDS) {\n\t\t\trv = -EINVAL;\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tled = &leds[reg];\n\t\tled->map = map;\n\t\tled->regA = MAX77650_LED_A_BASE + reg;\n\t\tled->regB = MAX77650_LED_B_BASE + reg;\n\t\tled->cdev.brightness_set_blocking = max77650_led_brightness_set;\n\t\tled->cdev.max_brightness = MAX77650_LED_MAX_BRIGHTNESS;\n\n\t\tinit_data.fwnode = child;\n\t\tinit_data.devicename = \"max77650\";\n\t\t \n\t\tinit_data.default_label = \":\";\n\n\t\trv = devm_led_classdev_register_ext(dev, &led->cdev,\n\t\t\t\t\t\t    &init_data);\n\t\tif (rv)\n\t\t\tgoto err_node_put;\n\n\t\trv = regmap_write(map, led->regA, MAX77650_LED_A_DEFAULT);\n\t\tif (rv)\n\t\t\tgoto err_node_put;\n\n\t\trv = regmap_write(map, led->regB, MAX77650_LED_B_DEFAULT);\n\t\tif (rv)\n\t\t\tgoto err_node_put;\n\t}\n\n\treturn regmap_write(map,\n\t\t\t    MAX77650_REG_CNFG_LED_TOP,\n\t\t\t    MAX77650_LED_TOP_DEFAULT);\nerr_node_put:\n\tfwnode_handle_put(child);\n\treturn rv;\n}\n\nstatic const struct of_device_id max77650_led_of_match[] = {\n\t{ .compatible = \"maxim,max77650-led\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max77650_led_of_match);\n\nstatic struct platform_driver max77650_led_driver = {\n\t.driver = {\n\t\t.name = \"max77650-led\",\n\t\t.of_match_table = max77650_led_of_match,\n\t},\n\t.probe = max77650_led_probe,\n};\nmodule_platform_driver(max77650_led_driver);\n\nMODULE_DESCRIPTION(\"MAXIM 77650/77651 LED driver\");\nMODULE_AUTHOR(\"Bartosz Golaszewski <bgolaszewski@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:max77650-led\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}