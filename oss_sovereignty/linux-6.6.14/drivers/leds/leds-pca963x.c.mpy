{
  "module_name": "leds-pca963x.c",
  "hash_id": "256e062ce3d941dfd705d6a61b97d38a2275c53b6547ef04e6915b15bc9bc022",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-pca963x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/leds.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n \n#define PCA963X_LED_OFF\t\t0x0\t \n#define PCA963X_LED_ON\t\t0x1\t \n#define PCA963X_LED_PWM\t\t0x2\t \n#define PCA963X_LED_GRP_PWM\t0x3\t \n\n#define PCA963X_MODE2_OUTDRV\t0x04\t \n#define PCA963X_MODE2_INVRT\t0x10\t \n#define PCA963X_MODE2_DMBLNK\t0x20\t \n\n#define PCA963X_MODE1\t\t0x00\n#define PCA963X_MODE2\t\t0x01\n#define PCA963X_PWM_BASE\t0x02\n\nenum pca963x_type {\n\tpca9633,\n\tpca9634,\n\tpca9635,\n};\n\nstruct pca963x_chipdef {\n\tu8\t\t\tgrppwm;\n\tu8\t\t\tgrpfreq;\n\tu8\t\t\tledout_base;\n\tint\t\t\tn_leds;\n\tunsigned int\t\tscaling;\n};\n\nstatic struct pca963x_chipdef pca963x_chipdefs[] = {\n\t[pca9633] = {\n\t\t.grppwm\t\t= 0x6,\n\t\t.grpfreq\t= 0x7,\n\t\t.ledout_base\t= 0x8,\n\t\t.n_leds\t\t= 4,\n\t},\n\t[pca9634] = {\n\t\t.grppwm\t\t= 0xa,\n\t\t.grpfreq\t= 0xb,\n\t\t.ledout_base\t= 0xc,\n\t\t.n_leds\t\t= 8,\n\t},\n\t[pca9635] = {\n\t\t.grppwm\t\t= 0x12,\n\t\t.grpfreq\t= 0x13,\n\t\t.ledout_base\t= 0x14,\n\t\t.n_leds\t\t= 16,\n\t},\n};\n\n \n#define PCA963X_BLINK_PERIOD_MIN\t42\n#define PCA963X_BLINK_PERIOD_MAX\t10667\n\nstatic const struct i2c_device_id pca963x_id[] = {\n\t{ \"pca9632\", pca9633 },\n\t{ \"pca9633\", pca9633 },\n\t{ \"pca9634\", pca9634 },\n\t{ \"pca9635\", pca9635 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pca963x_id);\n\nstruct pca963x;\n\nstruct pca963x_led {\n\tstruct pca963x *chip;\n\tstruct led_classdev led_cdev;\n\tint led_num;  \n\tbool blinking;\n\tu8 gdc;\n\tu8 gfrq;\n};\n\nstruct pca963x {\n\tstruct pca963x_chipdef *chipdef;\n\tstruct mutex mutex;\n\tstruct i2c_client *client;\n\tunsigned long leds_on;\n\tstruct pca963x_led leds[];\n};\n\nstatic int pca963x_brightness(struct pca963x_led *led,\n\t\t\t      enum led_brightness brightness)\n{\n\tstruct i2c_client *client = led->chip->client;\n\tstruct pca963x_chipdef *chipdef = led->chip->chipdef;\n\tu8 ledout_addr, ledout, mask, val;\n\tint shift;\n\tint ret;\n\n\tledout_addr = chipdef->ledout_base + (led->led_num / 4);\n\tshift = 2 * (led->led_num % 4);\n\tmask = 0x3 << shift;\n\tledout = i2c_smbus_read_byte_data(client, ledout_addr);\n\n\tswitch (brightness) {\n\tcase LED_FULL:\n\t\tif (led->blinking) {\n\t\t\tval = (ledout & ~mask) | (PCA963X_LED_GRP_PWM << shift);\n\t\t\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\tPCA963X_PWM_BASE +\n\t\t\t\t\t\tled->led_num,\n\t\t\t\t\t\tLED_FULL);\n\t\t} else {\n\t\t\tval = (ledout & ~mask) | (PCA963X_LED_ON << shift);\n\t\t}\n\t\tret = i2c_smbus_write_byte_data(client, ledout_addr, val);\n\t\tbreak;\n\tcase LED_OFF:\n\t\tval = ledout & ~mask;\n\t\tret = i2c_smbus_write_byte_data(client, ledout_addr, val);\n\t\tled->blinking = false;\n\t\tbreak;\n\tdefault:\n\t\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\tPCA963X_PWM_BASE +\n\t\t\t\t\t\tled->led_num,\n\t\t\t\t\t\tbrightness);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (led->blinking)\n\t\t\tval = (ledout & ~mask) | (PCA963X_LED_GRP_PWM << shift);\n\t\telse\n\t\t\tval = (ledout & ~mask) | (PCA963X_LED_PWM << shift);\n\n\t\tret = i2c_smbus_write_byte_data(client, ledout_addr, val);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void pca963x_blink(struct pca963x_led *led)\n{\n\tstruct i2c_client *client = led->chip->client;\n\tstruct pca963x_chipdef *chipdef = led->chip->chipdef;\n\tu8 ledout_addr, ledout, mask, val, mode2;\n\tint shift;\n\n\tledout_addr = chipdef->ledout_base + (led->led_num / 4);\n\tshift = 2 * (led->led_num % 4);\n\tmask = 0x3 << shift;\n\tmode2 = i2c_smbus_read_byte_data(client, PCA963X_MODE2);\n\n\ti2c_smbus_write_byte_data(client, chipdef->grppwm, led->gdc);\n\n\ti2c_smbus_write_byte_data(client, chipdef->grpfreq, led->gfrq);\n\n\tif (!(mode2 & PCA963X_MODE2_DMBLNK))\n\t\ti2c_smbus_write_byte_data(client, PCA963X_MODE2,\n\t\t\t\t\t  mode2 | PCA963X_MODE2_DMBLNK);\n\n\tmutex_lock(&led->chip->mutex);\n\n\tledout = i2c_smbus_read_byte_data(client, ledout_addr);\n\tif ((ledout & mask) != (PCA963X_LED_GRP_PWM << shift)) {\n\t\tval = (ledout & ~mask) | (PCA963X_LED_GRP_PWM << shift);\n\t\ti2c_smbus_write_byte_data(client, ledout_addr, val);\n\t}\n\n\tmutex_unlock(&led->chip->mutex);\n\tled->blinking = true;\n}\n\nstatic int pca963x_power_state(struct pca963x_led *led)\n{\n\tstruct i2c_client *client = led->chip->client;\n\tunsigned long *leds_on = &led->chip->leds_on;\n\tunsigned long cached_leds = *leds_on;\n\n\tif (led->led_cdev.brightness)\n\t\tset_bit(led->led_num, leds_on);\n\telse\n\t\tclear_bit(led->led_num, leds_on);\n\n\tif (!(*leds_on) != !cached_leds)\n\t\treturn i2c_smbus_write_byte_data(client, PCA963X_MODE1,\n\t\t\t\t\t\t *leds_on ? 0 : BIT(4));\n\n\treturn 0;\n}\n\nstatic int pca963x_led_set(struct led_classdev *led_cdev,\n\t\t\t   enum led_brightness value)\n{\n\tstruct pca963x_led *led;\n\tint ret;\n\n\tled = container_of(led_cdev, struct pca963x_led, led_cdev);\n\n\tmutex_lock(&led->chip->mutex);\n\n\tret = pca963x_brightness(led, value);\n\tif (ret < 0)\n\t\tgoto unlock;\n\tret = pca963x_power_state(led);\n\nunlock:\n\tmutex_unlock(&led->chip->mutex);\n\treturn ret;\n}\n\nstatic unsigned int pca963x_period_scale(struct pca963x_led *led,\n\t\t\t\t\t unsigned int val)\n{\n\tunsigned int scaling = led->chip->chipdef->scaling;\n\n\treturn scaling ? DIV_ROUND_CLOSEST(val * scaling, 1000) : val;\n}\n\nstatic int pca963x_blink_set(struct led_classdev *led_cdev,\n\t\t\t     unsigned long *delay_on, unsigned long *delay_off)\n{\n\tunsigned long time_on, time_off, period;\n\tstruct pca963x_led *led;\n\tu8 gdc, gfrq;\n\n\tled = container_of(led_cdev, struct pca963x_led, led_cdev);\n\n\ttime_on = *delay_on;\n\ttime_off = *delay_off;\n\n\t \n\tif (!time_on && !time_off) {\n\t\ttime_on = 500;\n\t\ttime_off = 500;\n\t}\n\n\tperiod = pca963x_period_scale(led, time_on + time_off);\n\n\t \n\tif ((period < PCA963X_BLINK_PERIOD_MIN) ||\n\t    (period > PCA963X_BLINK_PERIOD_MAX)) {\n\t\ttime_on = 500;\n\t\ttime_off = 500;\n\t\tperiod = pca963x_period_scale(led, 1000);\n\t}\n\n\t \n\tgdc = (pca963x_period_scale(led, time_on) * 256) / period;\n\n\t \n\tgfrq = (period * 24 / 1000) - 1;\n\n\tled->gdc = gdc;\n\tled->gfrq = gfrq;\n\n\tpca963x_blink(led);\n\tled->led_cdev.brightness = LED_FULL;\n\tpca963x_led_set(led_cdev, LED_FULL);\n\n\t*delay_on = time_on;\n\t*delay_off = time_off;\n\n\treturn 0;\n}\n\nstatic int pca963x_register_leds(struct i2c_client *client,\n\t\t\t\t struct pca963x *chip)\n{\n\tstruct pca963x_chipdef *chipdef = chip->chipdef;\n\tstruct pca963x_led *led = chip->leds;\n\tstruct device *dev = &client->dev;\n\tstruct fwnode_handle *child;\n\tbool hw_blink;\n\ts32 mode2;\n\tu32 reg;\n\tint ret;\n\n\tif (device_property_read_u32(dev, \"nxp,period-scale\",\n\t\t\t\t     &chipdef->scaling))\n\t\tchipdef->scaling = 1000;\n\n\thw_blink = device_property_read_bool(dev, \"nxp,hw-blink\");\n\n\tmode2 = i2c_smbus_read_byte_data(client, PCA963X_MODE2);\n\tif (mode2 < 0)\n\t\treturn mode2;\n\n\t \n\tif (device_property_read_bool(dev, \"nxp,totem-pole\"))\n\t\tmode2 |= PCA963X_MODE2_OUTDRV;\n\telse\n\t\tmode2 &= ~PCA963X_MODE2_OUTDRV;\n\n\t \n\tif (device_property_read_bool(dev, \"nxp,inverted-out\"))\n\t\tmode2 |= PCA963X_MODE2_INVRT;\n\telse\n\t\tmode2 &= ~PCA963X_MODE2_INVRT;\n\n\tret = i2c_smbus_write_byte_data(client, PCA963X_MODE2, mode2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tstruct led_init_data init_data = {};\n\t\tchar default_label[32];\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret || reg >= chipdef->n_leds) {\n\t\t\tdev_err(dev, \"Invalid 'reg' property for node %pfw\\n\",\n\t\t\t\tchild);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tled->led_num = reg;\n\t\tled->chip = chip;\n\t\tled->led_cdev.brightness_set_blocking = pca963x_led_set;\n\t\tif (hw_blink)\n\t\t\tled->led_cdev.blink_set = pca963x_blink_set;\n\t\tled->blinking = false;\n\n\t\tinit_data.fwnode = child;\n\t\t \n\t\tinit_data.devicename = \"pca963x\";\n\t\tsnprintf(default_label, sizeof(default_label), \"%d:%.2x:%u\",\n\t\t\t client->adapter->nr, client->addr, reg);\n\t\tinit_data.default_label = default_label;\n\n\t\tret = devm_led_classdev_register_ext(dev, &led->led_cdev,\n\t\t\t\t\t\t     &init_data);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register LED for node %pfw\\n\",\n\t\t\t\tchild);\n\t\t\tgoto err;\n\t\t}\n\n\t\t++led;\n\t}\n\n\treturn 0;\nerr:\n\tfwnode_handle_put(child);\n\treturn ret;\n}\n\nstatic const struct of_device_id of_pca963x_match[] = {\n\t{ .compatible = \"nxp,pca9632\", },\n\t{ .compatible = \"nxp,pca9633\", },\n\t{ .compatible = \"nxp,pca9634\", },\n\t{ .compatible = \"nxp,pca9635\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_pca963x_match);\n\nstatic int pca963x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct pca963x_chipdef *chipdef;\n\tstruct pca963x *chip;\n\tint i, count;\n\n\tchipdef = &pca963x_chipdefs[id->driver_data];\n\n\tcount = device_get_child_node_count(dev);\n\tif (!count || count > chipdef->n_leds) {\n\t\tdev_err(dev, \"Node %pfw must define between 1 and %d LEDs\\n\",\n\t\t\tdev_fwnode(dev), chipdef->n_leds);\n\t\treturn -EINVAL;\n\t}\n\n\tchip = devm_kzalloc(dev, struct_size(chip, leds, count), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, chip);\n\n\tmutex_init(&chip->mutex);\n\tchip->chipdef = chipdef;\n\tchip->client = client;\n\n\t \n\tfor (i = 0; i < chipdef->n_leds / 4; i++)\n\t\ti2c_smbus_write_byte_data(client, chipdef->ledout_base + i, 0x00);\n\n\t \n\ti2c_smbus_write_byte_data(client, PCA963X_MODE1, BIT(4));\n\n\treturn pca963x_register_leds(client, chip);\n}\n\nstatic struct i2c_driver pca963x_driver = {\n\t.driver = {\n\t\t.name\t= \"leds-pca963x\",\n\t\t.of_match_table = of_pca963x_match,\n\t},\n\t.probe = pca963x_probe,\n\t.id_table = pca963x_id,\n};\n\nmodule_i2c_driver(pca963x_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <p.meerwald@bct-electronic.com>\");\nMODULE_DESCRIPTION(\"PCA963X LED driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}