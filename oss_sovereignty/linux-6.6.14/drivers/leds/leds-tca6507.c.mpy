{
  "module_name": "leds-tca6507.c",
  "hash_id": "32bbd9ff53f14ef3dd49ff1999f6926bfae8a1b87364b1fa1e53e276e19bc41d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-tca6507.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/leds.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/gpio/driver.h>\n#include <linux/property.h>\n#include <linux/workqueue.h>\n\n \n#define TCA6507_LS_LED_OFF\t0x0\t \n#define TCA6507_LS_LED_OFF1\t0x1\t \n#define TCA6507_LS_LED_PWM0\t0x2\t \n#define TCA6507_LS_LED_PWM1\t0x3\t \n#define TCA6507_LS_LED_ON\t0x4\t \n#define TCA6507_LS_LED_MIR\t0x5\t \n#define TCA6507_LS_BLINK0\t0x6\t \n#define TCA6507_LS_BLINK1\t0x7\t \n\nstruct tca6507_platform_data {\n\tstruct led_platform_data leds;\n#ifdef CONFIG_GPIOLIB\n\tint gpio_base;\n#endif\n};\n\n#define\tTCA6507_MAKE_GPIO 1\n\nenum {\n\tBANK0,\n\tBANK1,\n\tMASTER,\n};\nstatic int bank_source[3] = {\n\tTCA6507_LS_LED_PWM0,\n\tTCA6507_LS_LED_PWM1,\n\tTCA6507_LS_LED_MIR,\n};\nstatic int blink_source[2] = {\n\tTCA6507_LS_BLINK0,\n\tTCA6507_LS_BLINK1,\n};\n\n \n#define\tTCA6507_REG_CNT\t\t\t11\n\n \n#define\tTCA6507_FADE_ON\t\t\t0x03\n#define\tTCA6507_FULL_ON\t\t\t0x04\n#define\tTCA6507_FADE_OFF\t\t0x05\n#define\tTCA6507_FIRST_OFF\t\t0x06\n#define\tTCA6507_SECOND_OFF\t\t0x07\n#define\tTCA6507_MAX_INTENSITY\t\t0x08\n#define\tTCA6507_MASTER_INTENSITY\t0x09\n#define\tTCA6507_INITIALIZE\t\t0x0A\n\n#define\tINIT_CODE\t\t\t0x8\n\n#define TIMECODES 16\nstatic int time_codes[TIMECODES] = {\n\t0, 64, 128, 192, 256, 384, 512, 768,\n\t1024, 1536, 2048, 3072, 4096, 5760, 8128, 16320\n};\n\n \nstatic inline int TO_LEVEL(int brightness)\n{\n\treturn brightness >> 4;\n}\n\n \nstatic inline int TO_BRIGHT(int level)\n{\n\tif (level)\n\t\treturn (level << 4) | 0xf;\n\treturn 0;\n}\n\n#define NUM_LEDS 7\nstruct tca6507_chip {\n\tint\t\t\treg_set;\t \n\tu8\t\t\treg_file[TCA6507_REG_CNT];\n\t \n\tstruct bank {\n\t\tint level;\n\t\tint ontime, offtime;\n\t\tint on_dflt, off_dflt;\n\t\tint time_use, level_use;\n\t} bank[3];\n\tstruct i2c_client\t*client;\n\tstruct work_struct\twork;\n\tspinlock_t\t\tlock;\n\n\tstruct tca6507_led {\n\t\tstruct tca6507_chip\t*chip;\n\t\tstruct led_classdev\tled_cdev;\n\t\tint\t\t\tnum;\n\t\tint\t\t\tontime, offtime;\n\t\tint\t\t\ton_dflt, off_dflt;\n\t\tint\t\t\tbank;\t \n\t\tint\t\t\tblink;\t \n\t} leds[NUM_LEDS];\n#ifdef CONFIG_GPIOLIB\n\tstruct gpio_chip\t\tgpio;\n\tint\t\t\t\tgpio_map[NUM_LEDS];\n#endif\n};\n\nstatic const struct i2c_device_id tca6507_id[] = {\n\t{ \"tca6507\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tca6507_id);\n\nstatic int choose_times(int msec, int *c1p, int *c2p)\n{\n\t \n\tint c1, c2;\n\tint tmax = msec * 9 / 8;\n\tint tmin = msec * 7 / 8;\n\tint diff = 65536;\n\n\t \n\tfor (c1 = 1; c1 < TIMECODES; c1++) {\n\t\tint t = time_codes[c1];\n\t\tif (t*2 < tmin)\n\t\t\tcontinue;\n\t\tif (t > tmax)\n\t\t\tbreak;\n\t\tfor (c2 = 0; c2 <= c1; c2++) {\n\t\t\tint tt = t + time_codes[c2];\n\t\t\tint d;\n\t\t\tif (tt < tmin)\n\t\t\t\tcontinue;\n\t\t\tif (tt > tmax)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\td = abs(msec - tt);\n\t\t\tif (d >= diff)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\t*c1p = c1;\n\t\t\t*c2p = c2;\n\t\t\tdiff = d;\n\t\t\tif (d == 0)\n\t\t\t\treturn msec;\n\t\t}\n\t}\n\tif (diff < 65536) {\n\t\tint actual;\n\t\tif (msec & 1) {\n\t\t\tswap(*c2p, *c1p);\n\t\t}\n\t\tactual = time_codes[*c1p] + time_codes[*c2p];\n\t\tif (*c1p < *c2p)\n\t\t\treturn actual + 1;\n\t\telse\n\t\t\treturn actual;\n\t}\n\t \n\treturn -EINVAL;\n}\n\n \nstatic void set_select(struct tca6507_chip *tca, int led, int val)\n{\n\tint mask = (1 << led);\n\tint bit;\n\n\tfor (bit = 0; bit < 3; bit++) {\n\t\tint n = tca->reg_file[bit] & ~mask;\n\t\tif (val & (1 << bit))\n\t\t\tn |= mask;\n\t\tif (tca->reg_file[bit] != n) {\n\t\t\ttca->reg_file[bit] = n;\n\t\t\ttca->reg_set |= (1 << bit);\n\t\t}\n\t}\n}\n\n \nstatic void set_code(struct tca6507_chip *tca, int reg, int bank, int new)\n{\n\tint mask = 0xF;\n\tint n;\n\tif (bank) {\n\t\tmask <<= 4;\n\t\tnew <<= 4;\n\t}\n\tn = tca->reg_file[reg] & ~mask;\n\tn |= new;\n\tif (tca->reg_file[reg] != n) {\n\t\ttca->reg_file[reg] = n;\n\t\ttca->reg_set |= 1 << reg;\n\t}\n}\n\n \nstatic void set_level(struct tca6507_chip *tca, int bank, int level)\n{\n\tswitch (bank) {\n\tcase BANK0:\n\tcase BANK1:\n\t\tset_code(tca, TCA6507_MAX_INTENSITY, bank, level);\n\t\tbreak;\n\tcase MASTER:\n\t\tset_code(tca, TCA6507_MASTER_INTENSITY, 0, level);\n\t\tbreak;\n\t}\n\ttca->bank[bank].level = level;\n}\n\n \nstatic void set_times(struct tca6507_chip *tca, int bank)\n{\n\tint c1, c2;\n\tint result;\n\n\tresult = choose_times(tca->bank[bank].ontime, &c1, &c2);\n\tif (result < 0)\n\t\treturn;\n\tdev_dbg(&tca->client->dev,\n\t\t\"Chose on  times %d(%d) %d(%d) for %dms\\n\",\n\t\tc1, time_codes[c1],\n\t\tc2, time_codes[c2], tca->bank[bank].ontime);\n\tset_code(tca, TCA6507_FADE_ON, bank, c2);\n\tset_code(tca, TCA6507_FULL_ON, bank, c1);\n\ttca->bank[bank].ontime = result;\n\n\tresult = choose_times(tca->bank[bank].offtime, &c1, &c2);\n\tdev_dbg(&tca->client->dev,\n\t\t\"Chose off times %d(%d) %d(%d) for %dms\\n\",\n\t\tc1, time_codes[c1],\n\t\tc2, time_codes[c2], tca->bank[bank].offtime);\n\tset_code(tca, TCA6507_FADE_OFF, bank, c2);\n\tset_code(tca, TCA6507_FIRST_OFF, bank, c1);\n\tset_code(tca, TCA6507_SECOND_OFF, bank, c1);\n\ttca->bank[bank].offtime = result;\n\n\tset_code(tca, TCA6507_INITIALIZE, bank, INIT_CODE);\n}\n\n \n\nstatic void tca6507_work(struct work_struct *work)\n{\n\tstruct tca6507_chip *tca = container_of(work, struct tca6507_chip,\n\t\t\t\t\t\twork);\n\tstruct i2c_client *cl = tca->client;\n\tint set;\n\tu8 file[TCA6507_REG_CNT];\n\tint r;\n\n\tspin_lock_irq(&tca->lock);\n\tset = tca->reg_set;\n\tmemcpy(file, tca->reg_file, TCA6507_REG_CNT);\n\ttca->reg_set = 0;\n\tspin_unlock_irq(&tca->lock);\n\n\tfor (r = 0; r < TCA6507_REG_CNT; r++)\n\t\tif (set & (1<<r))\n\t\t\ti2c_smbus_write_byte_data(cl, r, file[r]);\n}\n\nstatic void led_release(struct tca6507_led *led)\n{\n\t \n\tstruct tca6507_chip *tca = led->chip;\n\tif (led->bank >= 0) {\n\t\tstruct bank *b = tca->bank + led->bank;\n\t\tif (led->blink)\n\t\t\tb->time_use--;\n\t\tb->level_use--;\n\t}\n\tled->blink = 0;\n\tled->bank = -1;\n}\n\nstatic int led_prepare(struct tca6507_led *led)\n{\n\t \n\tint level = TO_LEVEL(led->led_cdev.brightness);\n\tstruct tca6507_chip *tca = led->chip;\n\tint c1, c2;\n\tint i;\n\tstruct bank *b;\n\tint need_init = 0;\n\n\tled->led_cdev.brightness = TO_BRIGHT(level);\n\tif (level == 0) {\n\t\tset_select(tca, led->num, TCA6507_LS_LED_OFF);\n\t\treturn 0;\n\t}\n\n\tif (led->ontime == 0 || led->offtime == 0) {\n\t\t \n\t\tint best = -1; \n\t\tint diff = 15-level;\n\n\t\tif (level == 15) {\n\t\t\tset_select(tca, led->num, TCA6507_LS_LED_ON);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (i = MASTER; i >= BANK0; i--) {\n\t\t\tint d;\n\t\t\tif (tca->bank[i].level == level ||\n\t\t\t    tca->bank[i].level_use == 0) {\n\t\t\t\tbest = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = abs(level - tca->bank[i].level);\n\t\t\tif (d < diff) {\n\t\t\t\tdiff = d;\n\t\t\t\tbest = i;\n\t\t\t}\n\t\t}\n\t\tif (best == -1) {\n\t\t\t \n\t\t\tset_select(tca, led->num, TCA6507_LS_LED_ON);\n\t\t\tled->led_cdev.brightness = LED_FULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!tca->bank[best].level_use)\n\t\t\tset_level(tca, best, level);\n\n\t\ttca->bank[best].level_use++;\n\t\tled->bank = best;\n\t\tset_select(tca, led->num, bank_source[best]);\n\t\tled->led_cdev.brightness = TO_BRIGHT(tca->bank[best].level);\n\t\treturn 0;\n\t}\n\n\t \n\tif (choose_times(led->ontime, &c1, &c2) < 0)\n\t\treturn -EINVAL;\n\tif (choose_times(led->offtime, &c1, &c2) < 0)\n\t\treturn -EINVAL;\n\n\tfor (i = BANK0; i <= BANK1; i++) {\n\t\tif (tca->bank[i].level_use == 0)\n\t\t\t \n\t\t\tbreak;\n\t\tif (tca->bank[i].level != level)\n\t\t\t \n\t\t\t \n\t\t\tcontinue;\n\n\t\tif (tca->bank[i].time_use == 0)\n\t\t\t \n\t\t\tbreak;\n\n\t\tif (!(tca->bank[i].on_dflt ||\n\t\t      led->on_dflt ||\n\t\t      tca->bank[i].ontime == led->ontime))\n\t\t\t \n\t\t\tcontinue;\n\n\t\tif (!(tca->bank[i].off_dflt ||\n\t\t      led->off_dflt ||\n\t\t      tca->bank[i].offtime == led->offtime))\n\t\t\t \n\t\t\tcontinue;\n\n\t\t \n\t\tbreak;\n\t}\n\n\tif (i > BANK1)\n\t\t \n\t\treturn -EINVAL;\n\n\tb = &tca->bank[i];\n\tif (b->level_use == 0)\n\t\tset_level(tca, i, level);\n\tb->level_use++;\n\tled->bank = i;\n\n\tif (b->on_dflt ||\n\t    !led->on_dflt ||\n\t    b->time_use == 0) {\n\t\tb->ontime = led->ontime;\n\t\tb->on_dflt = led->on_dflt;\n\t\tneed_init = 1;\n\t}\n\n\tif (b->off_dflt ||\n\t    !led->off_dflt ||\n\t    b->time_use == 0) {\n\t\tb->offtime = led->offtime;\n\t\tb->off_dflt = led->off_dflt;\n\t\tneed_init = 1;\n\t}\n\n\tif (need_init)\n\t\tset_times(tca, i);\n\n\tled->ontime = b->ontime;\n\tled->offtime = b->offtime;\n\n\tb->time_use++;\n\tled->blink = 1;\n\tled->led_cdev.brightness = TO_BRIGHT(b->level);\n\tset_select(tca, led->num, blink_source[i]);\n\treturn 0;\n}\n\nstatic int led_assign(struct tca6507_led *led)\n{\n\tstruct tca6507_chip *tca = led->chip;\n\tint err;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tca->lock, flags);\n\tled_release(led);\n\terr = led_prepare(led);\n\tif (err) {\n\t\t \n\t\tled->ontime = 0;\n\t\tled->offtime = 0;\n\t\tled_prepare(led);\n\t}\n\tspin_unlock_irqrestore(&tca->lock, flags);\n\n\tif (tca->reg_set)\n\t\tschedule_work(&tca->work);\n\treturn err;\n}\n\nstatic void tca6507_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct tca6507_led *led = container_of(led_cdev, struct tca6507_led,\n\t\t\t\t\t       led_cdev);\n\tled->led_cdev.brightness = brightness;\n\tled->ontime = 0;\n\tled->offtime = 0;\n\tled_assign(led);\n}\n\nstatic int tca6507_blink_set(struct led_classdev *led_cdev,\n\t\t\t     unsigned long *delay_on,\n\t\t\t     unsigned long *delay_off)\n{\n\tstruct tca6507_led *led = container_of(led_cdev, struct tca6507_led,\n\t\t\t\t\t       led_cdev);\n\n\tif (*delay_on == 0)\n\t\tled->on_dflt = 1;\n\telse if (delay_on != &led_cdev->blink_delay_on)\n\t\tled->on_dflt = 0;\n\tled->ontime = *delay_on;\n\n\tif (*delay_off == 0)\n\t\tled->off_dflt = 1;\n\telse if (delay_off != &led_cdev->blink_delay_off)\n\t\tled->off_dflt = 0;\n\tled->offtime = *delay_off;\n\n\tif (led->ontime == 0)\n\t\tled->ontime = 512;\n\tif (led->offtime == 0)\n\t\tled->offtime = 512;\n\n\tif (led->led_cdev.brightness == LED_OFF)\n\t\tled->led_cdev.brightness = LED_FULL;\n\tif (led_assign(led) < 0) {\n\t\tled->ontime = 0;\n\t\tled->offtime = 0;\n\t\tled->led_cdev.brightness = LED_OFF;\n\t\treturn -EINVAL;\n\t}\n\t*delay_on = led->ontime;\n\t*delay_off = led->offtime;\n\treturn 0;\n}\n\n#ifdef CONFIG_GPIOLIB\nstatic void tca6507_gpio_set_value(struct gpio_chip *gc,\n\t\t\t\t   unsigned offset, int val)\n{\n\tstruct tca6507_chip *tca = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tca->lock, flags);\n\t \n\tset_select(tca, tca->gpio_map[offset],\n\t\t   val ? TCA6507_LS_LED_OFF : TCA6507_LS_LED_ON);\n\tspin_unlock_irqrestore(&tca->lock, flags);\n\tif (tca->reg_set)\n\t\tschedule_work(&tca->work);\n}\n\nstatic int tca6507_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\t  unsigned offset, int val)\n{\n\ttca6507_gpio_set_value(gc, offset, val);\n\treturn 0;\n}\n\nstatic int tca6507_probe_gpios(struct device *dev,\n\t\t\t       struct tca6507_chip *tca,\n\t\t\t       struct tca6507_platform_data *pdata)\n{\n\tint err;\n\tint i = 0;\n\tint gpios = 0;\n\n\tfor (i = 0; i < NUM_LEDS; i++)\n\t\tif (pdata->leds.leds[i].name && pdata->leds.leds[i].flags) {\n\t\t\t \n\t\t\ttca->gpio_map[gpios] = i;\n\t\t\tgpios++;\n\t\t}\n\n\tif (!gpios)\n\t\treturn 0;\n\n\ttca->gpio.label = \"gpio-tca6507\";\n\ttca->gpio.ngpio = gpios;\n\ttca->gpio.base = pdata->gpio_base;\n\ttca->gpio.owner = THIS_MODULE;\n\ttca->gpio.direction_output = tca6507_gpio_direction_output;\n\ttca->gpio.set = tca6507_gpio_set_value;\n\ttca->gpio.parent = dev;\n\terr = gpiochip_add_data(&tca->gpio, tca);\n\tif (err) {\n\t\ttca->gpio.ngpio = 0;\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void tca6507_remove_gpio(struct tca6507_chip *tca)\n{\n\tif (tca->gpio.ngpio)\n\t\tgpiochip_remove(&tca->gpio);\n}\n#else  \nstatic int tca6507_probe_gpios(struct device *dev,\n\t\t\t       struct tca6507_chip *tca,\n\t\t\t       struct tca6507_platform_data *pdata)\n{\n\treturn 0;\n}\nstatic void tca6507_remove_gpio(struct tca6507_chip *tca)\n{\n}\n#endif  \n\nstatic struct tca6507_platform_data *\ntca6507_led_dt_init(struct device *dev)\n{\n\tstruct tca6507_platform_data *pdata;\n\tstruct fwnode_handle *child;\n\tstruct led_info *tca_leds;\n\tint count;\n\n\tcount = device_get_child_node_count(dev);\n\tif (!count || count > NUM_LEDS)\n\t\treturn ERR_PTR(-ENODEV);\n\n\ttca_leds = devm_kcalloc(dev, NUM_LEDS, sizeof(struct led_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!tca_leds)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tstruct led_info led;\n\t\tu32 reg;\n\t\tint ret;\n\n\t\tif (fwnode_property_read_string(child, \"label\", &led.name))\n\t\t\tled.name = fwnode_get_name(child);\n\n\t\tif (fwnode_property_read_string(child, \"linux,default-trigger\",\n\t\t\t\t\t\t&led.default_trigger))\n\t\t\tled.default_trigger = NULL;\n\n\t\tled.flags = 0;\n\t\tif (fwnode_device_is_compatible(child, \"gpio\"))\n\t\t\tled.flags |= TCA6507_MAKE_GPIO;\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret || reg >= NUM_LEDS) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ERR_PTR(ret ? : -EINVAL);\n\t\t}\n\n\t\ttca_leds[reg] = led;\n\t}\n\n\tpdata = devm_kzalloc(dev, sizeof(struct tca6507_platform_data),\n\t\t\t     GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->leds.leds = tca_leds;\n\tpdata->leds.num_leds = NUM_LEDS;\n#ifdef CONFIG_GPIOLIB\n\tpdata->gpio_base = -1;\n#endif\n\n\treturn pdata;\n}\n\nstatic const struct of_device_id __maybe_unused of_tca6507_leds_match[] = {\n\t{ .compatible = \"ti,tca6507\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_tca6507_leds_match);\n\nstatic int tca6507_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct i2c_adapter *adapter;\n\tstruct tca6507_chip *tca;\n\tstruct tca6507_platform_data *pdata;\n\tint err;\n\tint i = 0;\n\n\tadapter = client->adapter;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_I2C))\n\t\treturn -EIO;\n\n\tpdata = tca6507_led_dt_init(dev);\n\tif (IS_ERR(pdata)) {\n\t\tdev_err(dev, \"Need %d entries in platform-data list\\n\", NUM_LEDS);\n\t\treturn PTR_ERR(pdata);\n\t}\n\ttca = devm_kzalloc(dev, sizeof(*tca), GFP_KERNEL);\n\tif (!tca)\n\t\treturn -ENOMEM;\n\n\ttca->client = client;\n\tINIT_WORK(&tca->work, tca6507_work);\n\tspin_lock_init(&tca->lock);\n\ti2c_set_clientdata(client, tca);\n\n\tfor (i = 0; i < NUM_LEDS; i++) {\n\t\tstruct tca6507_led *l = tca->leds + i;\n\n\t\tl->chip = tca;\n\t\tl->num = i;\n\t\tif (pdata->leds.leds[i].name && !pdata->leds.leds[i].flags) {\n\t\t\tl->led_cdev.name = pdata->leds.leds[i].name;\n\t\t\tl->led_cdev.default_trigger\n\t\t\t\t= pdata->leds.leds[i].default_trigger;\n\t\t\tl->led_cdev.brightness_set = tca6507_brightness_set;\n\t\t\tl->led_cdev.blink_set = tca6507_blink_set;\n\t\t\tl->bank = -1;\n\t\t\terr = led_classdev_register(dev, &l->led_cdev);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\terr = tca6507_probe_gpios(dev, tca, pdata);\n\tif (err)\n\t\tgoto exit;\n\t \n\ttca->reg_set = 0x7f;\n\tschedule_work(&tca->work);\n\n\treturn 0;\nexit:\n\twhile (i--) {\n\t\tif (tca->leds[i].led_cdev.name)\n\t\t\tled_classdev_unregister(&tca->leds[i].led_cdev);\n\t}\n\treturn err;\n}\n\nstatic void tca6507_remove(struct i2c_client *client)\n{\n\tint i;\n\tstruct tca6507_chip *tca = i2c_get_clientdata(client);\n\tstruct tca6507_led *tca_leds = tca->leds;\n\n\tfor (i = 0; i < NUM_LEDS; i++) {\n\t\tif (tca_leds[i].led_cdev.name)\n\t\t\tled_classdev_unregister(&tca_leds[i].led_cdev);\n\t}\n\ttca6507_remove_gpio(tca);\n\tcancel_work_sync(&tca->work);\n}\n\nstatic struct i2c_driver tca6507_driver = {\n\t.driver   = {\n\t\t.name    = \"leds-tca6507\",\n\t\t.of_match_table = of_match_ptr(of_tca6507_leds_match),\n\t},\n\t.probe    = tca6507_probe,\n\t.remove   = tca6507_remove,\n\t.id_table = tca6507_id,\n};\n\nmodule_i2c_driver(tca6507_driver);\n\nMODULE_AUTHOR(\"NeilBrown <neilb@suse.de>\");\nMODULE_DESCRIPTION(\"TCA6507 LED/GPO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}