{
  "module_name": "leds-lp3944.c",
  "hash_id": "5f7ab96b091782f41d030638646c818022e9935e7dc33a3d0e561920a177e915",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lp3944.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/leds.h>\n#include <linux/mutex.h>\n#include <linux/leds-lp3944.h>\n\n \n#define LP3944_REG_INPUT1     0x00  \n#define LP3944_REG_REGISTER1  0x01  \n\n#define LP3944_REG_PSC0       0x02  \n#define LP3944_REG_PWM0       0x03  \n#define LP3944_REG_PSC1       0x04  \n#define LP3944_REG_PWM1       0x05  \n#define LP3944_REG_LS0        0x06  \n#define LP3944_REG_LS1        0x07  \n\n \n#define LP3944_REG_REGISTER8  0x08\n#define LP3944_REG_REGISTER9  0x09\n\n#define LP3944_DIM0 0\n#define LP3944_DIM1 1\n\n \n#define LP3944_PERIOD_MIN 0\n#define LP3944_PERIOD_MAX 1600\n\n \n#define LP3944_DUTY_CYCLE_MIN 0\n#define LP3944_DUTY_CYCLE_MAX 100\n\n#define ldev_to_led(c)       container_of(c, struct lp3944_led_data, ldev)\n\n \nstruct lp3944_led_data {\n\tu8 id;\n\tenum lp3944_type type;\n\tstruct led_classdev ldev;\n\tstruct i2c_client *client;\n};\n\nstruct lp3944_data {\n\tstruct mutex lock;\n\tstruct i2c_client *client;\n\tstruct lp3944_led_data leds[LP3944_LEDS_MAX];\n};\n\nstatic int lp3944_reg_read(struct i2c_client *client, u8 reg, u8 *value)\n{\n\tint tmp;\n\n\ttmp = i2c_smbus_read_byte_data(client, reg);\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\t*value = tmp;\n\n\treturn 0;\n}\n\nstatic int lp3944_reg_write(struct i2c_client *client, u8 reg, u8 value)\n{\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\n \nstatic int lp3944_dim_set_period(struct i2c_client *client, u8 dim, u16 period)\n{\n\tu8 psc_reg;\n\tu8 psc_value;\n\tint err;\n\n\tif (dim == LP3944_DIM0)\n\t\tpsc_reg = LP3944_REG_PSC0;\n\telse if (dim == LP3944_DIM1)\n\t\tpsc_reg = LP3944_REG_PSC1;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tif (period > LP3944_PERIOD_MAX)\n\t\treturn -EINVAL;\n\n\tpsc_value = (period * 255) / LP3944_PERIOD_MAX;\n\n\terr = lp3944_reg_write(client, psc_reg, psc_value);\n\n\treturn err;\n}\n\n \nstatic int lp3944_dim_set_dutycycle(struct i2c_client *client, u8 dim,\n\t\t\t\t    u8 duty_cycle)\n{\n\tu8 pwm_reg;\n\tu8 pwm_value;\n\tint err;\n\n\tif (dim == LP3944_DIM0)\n\t\tpwm_reg = LP3944_REG_PWM0;\n\telse if (dim == LP3944_DIM1)\n\t\tpwm_reg = LP3944_REG_PWM1;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tif (duty_cycle > LP3944_DUTY_CYCLE_MAX)\n\t\treturn -EINVAL;\n\n\tpwm_value = (duty_cycle * 255) / LP3944_DUTY_CYCLE_MAX;\n\n\terr = lp3944_reg_write(client, pwm_reg, pwm_value);\n\n\treturn err;\n}\n\n \nstatic int lp3944_led_set(struct lp3944_led_data *led, u8 status)\n{\n\tstruct lp3944_data *data = i2c_get_clientdata(led->client);\n\tu8 id = led->id;\n\tu8 reg;\n\tu8 val = 0;\n\tint err;\n\n\tdev_dbg(&led->client->dev, \"%s: %s, status before normalization:%d\\n\",\n\t\t__func__, led->ldev.name, status);\n\n\tswitch (id) {\n\tcase LP3944_LED0:\n\tcase LP3944_LED1:\n\tcase LP3944_LED2:\n\tcase LP3944_LED3:\n\t\treg = LP3944_REG_LS0;\n\t\tbreak;\n\tcase LP3944_LED4:\n\tcase LP3944_LED5:\n\tcase LP3944_LED6:\n\tcase LP3944_LED7:\n\t\tid -= LP3944_LED4;\n\t\treg = LP3944_REG_LS1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (status > LP3944_LED_STATUS_DIM1)\n\t\treturn -EINVAL;\n\n\t \n\tif (led->type == LP3944_LED_TYPE_LED_INVERTED && status < 2)\n\t\tstatus = 1 - status;\n\n\tmutex_lock(&data->lock);\n\tlp3944_reg_read(led->client, reg, &val);\n\n\tval &= ~(LP3944_LED_STATUS_MASK << (id << 1));\n\tval |= (status << (id << 1));\n\n\tdev_dbg(&led->client->dev, \"%s: %s, reg:%d id:%d status:%d val:%#x\\n\",\n\t\t__func__, led->ldev.name, reg, id, status, val);\n\n\t \n\terr = lp3944_reg_write(led->client, reg, val);\n\tmutex_unlock(&data->lock);\n\n\treturn err;\n}\n\nstatic int lp3944_led_set_blink(struct led_classdev *led_cdev,\n\t\t\t\tunsigned long *delay_on,\n\t\t\t\tunsigned long *delay_off)\n{\n\tstruct lp3944_led_data *led = ldev_to_led(led_cdev);\n\tu16 period;\n\tu8 duty_cycle;\n\tint err;\n\n\t \n\tif (*delay_on + *delay_off > LP3944_PERIOD_MAX)\n\t\treturn -EINVAL;\n\n\tif (*delay_on == 0 && *delay_off == 0) {\n\t\t \n\t\t*delay_on = 500;\n\t\t*delay_off = 500;\n\t}\n\n\tperiod = (*delay_on) + (*delay_off);\n\n\t \n\tduty_cycle = 100 * (*delay_on) / period;\n\n\t \n\tif (led->type == LP3944_LED_TYPE_LED_INVERTED)\n\t\tduty_cycle = 100 - duty_cycle;\n\n\t \n\terr = lp3944_dim_set_period(led->client, LP3944_DIM0, period);\n\tif (err)\n\t\treturn err;\n\n\terr = lp3944_dim_set_dutycycle(led->client, LP3944_DIM0, duty_cycle);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(&led->client->dev, \"%s: OK hardware accelerated blink!\\n\",\n\t\t__func__);\n\n\tlp3944_led_set(led, LP3944_LED_STATUS_DIM0);\n\n\treturn 0;\n}\n\nstatic int lp3944_led_set_brightness(struct led_classdev *led_cdev,\n\t\t\t\t      enum led_brightness brightness)\n{\n\tstruct lp3944_led_data *led = ldev_to_led(led_cdev);\n\n\tdev_dbg(&led->client->dev, \"%s: %s, %d\\n\",\n\t\t__func__, led_cdev->name, brightness);\n\n\treturn lp3944_led_set(led, !!brightness);\n}\n\nstatic int lp3944_configure(struct i2c_client *client,\n\t\t\t    struct lp3944_data *data,\n\t\t\t    struct lp3944_platform_data *pdata)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < pdata->leds_size; i++) {\n\t\tstruct lp3944_led *pled = &pdata->leds[i];\n\t\tstruct lp3944_led_data *led = &data->leds[i];\n\t\tled->client = client;\n\t\tled->id = i;\n\n\t\tswitch (pled->type) {\n\n\t\tcase LP3944_LED_TYPE_LED:\n\t\tcase LP3944_LED_TYPE_LED_INVERTED:\n\t\t\tled->type = pled->type;\n\t\t\tled->ldev.name = pled->name;\n\t\t\tled->ldev.max_brightness = 1;\n\t\t\tled->ldev.brightness_set_blocking =\n\t\t\t\t\t\tlp3944_led_set_brightness;\n\t\t\tled->ldev.blink_set = lp3944_led_set_blink;\n\t\t\tled->ldev.flags = LED_CORE_SUSPENDRESUME;\n\n\t\t\terr = led_classdev_register(&client->dev, &led->ldev);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"couldn't register LED %s\\n\",\n\t\t\t\t\tled->ldev.name);\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\t \n\t\t\tled->ldev.brightness =\n\t\t\t\t\t(enum led_brightness) pled->status;\n\n\t\t\t \n\t\t\terr = lp3944_led_set(led, pled->status);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"%s couldn't set STATUS %d\\n\",\n\t\t\t\t\tled->ldev.name, pled->status);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LP3944_LED_TYPE_NONE:\n\t\tdefault:\n\t\t\tbreak;\n\n\t\t}\n\t}\n\treturn 0;\n\nexit:\n\tif (i > 0)\n\t\tfor (i = i - 1; i >= 0; i--)\n\t\t\tswitch (pdata->leds[i].type) {\n\n\t\t\tcase LP3944_LED_TYPE_LED:\n\t\t\tcase LP3944_LED_TYPE_LED_INVERTED:\n\t\t\t\tled_classdev_unregister(&data->leds[i].ldev);\n\t\t\t\tbreak;\n\n\t\t\tcase LP3944_LED_TYPE_NONE:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\treturn err;\n}\n\nstatic int lp3944_probe(struct i2c_client *client)\n{\n\tstruct lp3944_platform_data *lp3944_pdata =\n\t\t\tdev_get_platdata(&client->dev);\n\tstruct lp3944_data *data;\n\tint err;\n\n\tif (lp3944_pdata == NULL) {\n\t\tdev_err(&client->dev, \"no platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\tI2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&client->dev, \"insufficient functionality!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct lp3944_data),\n\t\t\tGFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\ti2c_set_clientdata(client, data);\n\n\tmutex_init(&data->lock);\n\n\terr = lp3944_configure(client, data, lp3944_pdata);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_info(&client->dev, \"lp3944 enabled\\n\");\n\treturn 0;\n}\n\nstatic void lp3944_remove(struct i2c_client *client)\n{\n\tstruct lp3944_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct lp3944_data *data = i2c_get_clientdata(client);\n\tint i;\n\n\tfor (i = 0; i < pdata->leds_size; i++)\n\t\tswitch (data->leds[i].type) {\n\t\tcase LP3944_LED_TYPE_LED:\n\t\tcase LP3944_LED_TYPE_LED_INVERTED:\n\t\t\tled_classdev_unregister(&data->leds[i].ldev);\n\t\t\tbreak;\n\n\t\tcase LP3944_LED_TYPE_NONE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n}\n\n \nstatic const struct i2c_device_id lp3944_id[] = {\n\t{\"lp3944\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, lp3944_id);\n\nstatic struct i2c_driver lp3944_driver = {\n\t.driver   = {\n\t\t   .name = \"lp3944\",\n\t},\n\t.probe    = lp3944_probe,\n\t.remove   = lp3944_remove,\n\t.id_table = lp3944_id,\n};\n\nmodule_i2c_driver(lp3944_driver);\n\nMODULE_AUTHOR(\"Antonio Ospite <ospite@studenti.unina.it>\");\nMODULE_DESCRIPTION(\"LP3944 Fun Light Chip\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}