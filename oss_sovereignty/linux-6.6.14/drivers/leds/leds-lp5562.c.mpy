{
  "module_name": "leds-lp5562.c",
  "hash_id": "762670542066fbac7e4df4d6ecfc5a1b647840de48366f191509e17c56b8d841",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lp5562.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_data/leds-lp55xx.h>\n#include <linux/slab.h>\n\n#include \"leds-lp55xx-common.h\"\n\n#define LP5562_PROGRAM_LENGTH\t\t32\n#define LP5562_MAX_LEDS\t\t\t4\n\n \n#define LP5562_REG_ENABLE\t\t0x00\n#define LP5562_EXEC_ENG1_M\t\t0x30\n#define LP5562_EXEC_ENG2_M\t\t0x0C\n#define LP5562_EXEC_ENG3_M\t\t0x03\n#define LP5562_EXEC_M\t\t\t0x3F\n#define LP5562_MASTER_ENABLE\t\t0x40\t \n#define LP5562_LOGARITHMIC_PWM\t\t0x80\t \n#define LP5562_EXEC_RUN\t\t\t0x2A\n#define LP5562_ENABLE_DEFAULT\t\\\n\t(LP5562_MASTER_ENABLE | LP5562_LOGARITHMIC_PWM)\n#define LP5562_ENABLE_RUN_PROGRAM\t\\\n\t(LP5562_ENABLE_DEFAULT | LP5562_EXEC_RUN)\n\n \n#define LP5562_REG_OP_MODE\t\t0x01\n#define LP5562_MODE_ENG1_M\t\t0x30\n#define LP5562_MODE_ENG2_M\t\t0x0C\n#define LP5562_MODE_ENG3_M\t\t0x03\n#define LP5562_LOAD_ENG1\t\t0x10\n#define LP5562_LOAD_ENG2\t\t0x04\n#define LP5562_LOAD_ENG3\t\t0x01\n#define LP5562_RUN_ENG1\t\t\t0x20\n#define LP5562_RUN_ENG2\t\t\t0x08\n#define LP5562_RUN_ENG3\t\t\t0x02\n#define LP5562_ENG1_IS_LOADING(mode)\t\\\n\t((mode & LP5562_MODE_ENG1_M) == LP5562_LOAD_ENG1)\n#define LP5562_ENG2_IS_LOADING(mode)\t\\\n\t((mode & LP5562_MODE_ENG2_M) == LP5562_LOAD_ENG2)\n#define LP5562_ENG3_IS_LOADING(mode)\t\\\n\t((mode & LP5562_MODE_ENG3_M) == LP5562_LOAD_ENG3)\n\n \n#define LP5562_REG_R_PWM\t\t0x04\n#define LP5562_REG_G_PWM\t\t0x03\n#define LP5562_REG_B_PWM\t\t0x02\n#define LP5562_REG_W_PWM\t\t0x0E\n\n \n#define LP5562_REG_R_CURRENT\t\t0x07\n#define LP5562_REG_G_CURRENT\t\t0x06\n#define LP5562_REG_B_CURRENT\t\t0x05\n#define LP5562_REG_W_CURRENT\t\t0x0F\n\n \n#define LP5562_REG_CONFIG\t\t0x08\n#define LP5562_PWM_HF\t\t\t0x40\n#define LP5562_PWRSAVE_EN\t\t0x20\n#define LP5562_CLK_INT\t\t\t0x01\t \n#define LP5562_DEFAULT_CFG\t\t(LP5562_PWM_HF | LP5562_PWRSAVE_EN)\n\n \n#define LP5562_REG_RESET\t\t0x0D\n#define LP5562_RESET\t\t\t0xFF\n\n \n#define LP5562_REG_PROG_MEM_ENG1\t0x10\n#define LP5562_REG_PROG_MEM_ENG2\t0x30\n#define LP5562_REG_PROG_MEM_ENG3\t0x50\n\n \n#define LP5562_REG_ENG_SEL\t\t0x70\n#define LP5562_ENG_SEL_PWM\t\t0\n#define LP5562_ENG_FOR_RGB_M\t\t0x3F\n#define LP5562_ENG_SEL_RGB\t\t0x1B\t \n#define LP5562_ENG_FOR_W_M\t\t0xC0\n#define LP5562_ENG1_FOR_W\t\t0x40\t \n#define LP5562_ENG2_FOR_W\t\t0x80\t \n#define LP5562_ENG3_FOR_W\t\t0xC0\t \n\n \n#define LP5562_CMD_DISABLE\t\t0x00\n#define LP5562_CMD_LOAD\t\t\t0x15\n#define LP5562_CMD_RUN\t\t\t0x2A\n#define LP5562_CMD_DIRECT\t\t0x3F\n#define LP5562_PATTERN_OFF\t\t0\n\nstatic inline void lp5562_wait_opmode_done(void)\n{\n\t \n\tusleep_range(200, 300);\n}\n\nstatic inline void lp5562_wait_enable_done(void)\n{\n\t \n\tusleep_range(500, 600);\n}\n\nstatic void lp5562_set_led_current(struct lp55xx_led *led, u8 led_current)\n{\n\tstatic const u8 addr[] = {\n\t\tLP5562_REG_R_CURRENT,\n\t\tLP5562_REG_G_CURRENT,\n\t\tLP5562_REG_B_CURRENT,\n\t\tLP5562_REG_W_CURRENT,\n\t};\n\n\tled->led_current = led_current;\n\tlp55xx_write(led->chip, addr[led->chan_nr], led_current);\n}\n\nstatic void lp5562_load_engine(struct lp55xx_chip *chip)\n{\n\tenum lp55xx_engine_index idx = chip->engine_idx;\n\tstatic const u8 mask[] = {\n\t\t[LP55XX_ENGINE_1] = LP5562_MODE_ENG1_M,\n\t\t[LP55XX_ENGINE_2] = LP5562_MODE_ENG2_M,\n\t\t[LP55XX_ENGINE_3] = LP5562_MODE_ENG3_M,\n\t};\n\n\tstatic const u8 val[] = {\n\t\t[LP55XX_ENGINE_1] = LP5562_LOAD_ENG1,\n\t\t[LP55XX_ENGINE_2] = LP5562_LOAD_ENG2,\n\t\t[LP55XX_ENGINE_3] = LP5562_LOAD_ENG3,\n\t};\n\n\tlp55xx_update_bits(chip, LP5562_REG_OP_MODE, mask[idx], val[idx]);\n\n\tlp5562_wait_opmode_done();\n}\n\nstatic void lp5562_stop_engine(struct lp55xx_chip *chip)\n{\n\tlp55xx_write(chip, LP5562_REG_OP_MODE, LP5562_CMD_DISABLE);\n\tlp5562_wait_opmode_done();\n}\n\nstatic void lp5562_run_engine(struct lp55xx_chip *chip, bool start)\n{\n\tint ret;\n\tu8 mode;\n\tu8 exec;\n\n\t \n\tif (!start) {\n\t\tlp55xx_write(chip, LP5562_REG_ENABLE, LP5562_ENABLE_DEFAULT);\n\t\tlp5562_wait_enable_done();\n\t\tlp5562_stop_engine(chip);\n\t\tlp55xx_write(chip, LP5562_REG_ENG_SEL, LP5562_ENG_SEL_PWM);\n\t\tlp55xx_write(chip, LP5562_REG_OP_MODE, LP5562_CMD_DIRECT);\n\t\tlp5562_wait_opmode_done();\n\t\treturn;\n\t}\n\n\t \n\n\tret = lp55xx_read(chip, LP5562_REG_OP_MODE, &mode);\n\tif (ret)\n\t\treturn;\n\n\tret = lp55xx_read(chip, LP5562_REG_ENABLE, &exec);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (LP5562_ENG1_IS_LOADING(mode)) {\n\t\tmode = (mode & ~LP5562_MODE_ENG1_M) | LP5562_RUN_ENG1;\n\t\texec = (exec & ~LP5562_EXEC_ENG1_M) | LP5562_RUN_ENG1;\n\t}\n\n\tif (LP5562_ENG2_IS_LOADING(mode)) {\n\t\tmode = (mode & ~LP5562_MODE_ENG2_M) | LP5562_RUN_ENG2;\n\t\texec = (exec & ~LP5562_EXEC_ENG2_M) | LP5562_RUN_ENG2;\n\t}\n\n\tif (LP5562_ENG3_IS_LOADING(mode)) {\n\t\tmode = (mode & ~LP5562_MODE_ENG3_M) | LP5562_RUN_ENG3;\n\t\texec = (exec & ~LP5562_EXEC_ENG3_M) | LP5562_RUN_ENG3;\n\t}\n\n\tlp55xx_write(chip, LP5562_REG_OP_MODE, mode);\n\tlp5562_wait_opmode_done();\n\n\tlp55xx_update_bits(chip, LP5562_REG_ENABLE, LP5562_EXEC_M, exec);\n\tlp5562_wait_enable_done();\n}\n\nstatic int lp5562_update_firmware(struct lp55xx_chip *chip,\n\t\t\t\t\tconst u8 *data, size_t size)\n{\n\tenum lp55xx_engine_index idx = chip->engine_idx;\n\tu8 pattern[LP5562_PROGRAM_LENGTH] = {0};\n\tstatic const u8 addr[] = {\n\t\t[LP55XX_ENGINE_1] = LP5562_REG_PROG_MEM_ENG1,\n\t\t[LP55XX_ENGINE_2] = LP5562_REG_PROG_MEM_ENG2,\n\t\t[LP55XX_ENGINE_3] = LP5562_REG_PROG_MEM_ENG3,\n\t};\n\tunsigned cmd;\n\tchar c[3];\n\tint program_size;\n\tint nrchars;\n\tint offset = 0;\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < LP5562_PROGRAM_LENGTH; i++)\n\t\tlp55xx_write(chip, addr[idx] + i, 0);\n\n\ti = 0;\n\twhile ((offset < size - 1) && (i < LP5562_PROGRAM_LENGTH)) {\n\t\t \n\t\tret = sscanf(data + offset, \"%2s%n \", c, &nrchars);\n\t\tif (ret != 1)\n\t\t\tgoto err;\n\n\t\tret = sscanf(c, \"%2x\", &cmd);\n\t\tif (ret != 1)\n\t\t\tgoto err;\n\n\t\tpattern[i] = (u8)cmd;\n\t\toffset += nrchars;\n\t\ti++;\n\t}\n\n\t \n\tif (i % 2)\n\t\tgoto err;\n\n\tprogram_size = i;\n\tfor (i = 0; i < program_size; i++)\n\t\tlp55xx_write(chip, addr[idx] + i, pattern[i]);\n\n\treturn 0;\n\nerr:\n\tdev_err(&chip->cl->dev, \"wrong pattern format\\n\");\n\treturn -EINVAL;\n}\n\nstatic void lp5562_firmware_loaded(struct lp55xx_chip *chip)\n{\n\tconst struct firmware *fw = chip->fw;\n\n\t \n\tif (fw->size > (LP5562_PROGRAM_LENGTH * 2)) {\n\t\tdev_err(&chip->cl->dev, \"firmware data size overflow: %zu\\n\",\n\t\t\tfw->size);\n\t\treturn;\n\t}\n\n\t \n\n\tlp5562_load_engine(chip);\n\tlp5562_update_firmware(chip, fw->data, fw->size);\n}\n\nstatic int lp5562_post_init_device(struct lp55xx_chip *chip)\n{\n\tint ret;\n\tu8 cfg = LP5562_DEFAULT_CFG;\n\n\t \n\tret = lp55xx_write(chip, LP5562_REG_OP_MODE, LP5562_CMD_DIRECT);\n\tif (ret)\n\t\treturn ret;\n\n\tlp5562_wait_opmode_done();\n\n\t \n\tif (!lp55xx_is_extclk_used(chip))\n\t\tcfg |= LP5562_CLK_INT;\n\n\tret = lp55xx_write(chip, LP5562_REG_CONFIG, cfg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlp55xx_write(chip, LP5562_REG_R_PWM, 0);\n\tlp55xx_write(chip, LP5562_REG_G_PWM, 0);\n\tlp55xx_write(chip, LP5562_REG_B_PWM, 0);\n\tlp55xx_write(chip, LP5562_REG_W_PWM, 0);\n\n\t \n\tlp55xx_write(chip, LP5562_REG_ENG_SEL, LP5562_ENG_SEL_PWM);\n\n\treturn 0;\n}\n\nstatic int lp5562_led_brightness(struct lp55xx_led *led)\n{\n\tstruct lp55xx_chip *chip = led->chip;\n\tstatic const u8 addr[] = {\n\t\tLP5562_REG_R_PWM,\n\t\tLP5562_REG_G_PWM,\n\t\tLP5562_REG_B_PWM,\n\t\tLP5562_REG_W_PWM,\n\t};\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\tret = lp55xx_write(chip, addr[led->chan_nr], led->brightness);\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic void lp5562_write_program_memory(struct lp55xx_chip *chip,\n\t\t\t\t\tu8 base, const u8 *rgb, int size)\n{\n\tint i;\n\n\tif (!rgb || size <= 0)\n\t\treturn;\n\n\tfor (i = 0; i < size; i++)\n\t\tlp55xx_write(chip, base + i, *(rgb + i));\n\n\tlp55xx_write(chip, base + i, 0);\n\tlp55xx_write(chip, base + i + 1, 0);\n}\n\n \nstatic inline bool _is_pc_overflow(struct lp55xx_predef_pattern *ptn)\n{\n\treturn ptn->size_r >= LP5562_PROGRAM_LENGTH ||\n\t       ptn->size_g >= LP5562_PROGRAM_LENGTH ||\n\t       ptn->size_b >= LP5562_PROGRAM_LENGTH;\n}\n\nstatic int lp5562_run_predef_led_pattern(struct lp55xx_chip *chip, int mode)\n{\n\tstruct lp55xx_predef_pattern *ptn;\n\tint i;\n\n\tif (mode == LP5562_PATTERN_OFF) {\n\t\tlp5562_run_engine(chip, false);\n\t\treturn 0;\n\t}\n\n\tptn = chip->pdata->patterns + (mode - 1);\n\tif (!ptn || _is_pc_overflow(ptn)) {\n\t\tdev_err(&chip->cl->dev, \"invalid pattern data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlp5562_stop_engine(chip);\n\n\t \n\tlp55xx_write(chip, LP5562_REG_ENG_SEL, LP5562_ENG_SEL_RGB);\n\n\t \n\tfor (i = LP55XX_ENGINE_1; i <= LP55XX_ENGINE_3; i++) {\n\t\tchip->engine_idx = i;\n\t\tlp5562_load_engine(chip);\n\t}\n\n\t \n\tlp55xx_write(chip, LP5562_REG_PROG_MEM_ENG1, 0);\n\tlp55xx_write(chip, LP5562_REG_PROG_MEM_ENG1 + 1, 0);\n\tlp55xx_write(chip, LP5562_REG_PROG_MEM_ENG2, 0);\n\tlp55xx_write(chip, LP5562_REG_PROG_MEM_ENG2 + 1, 0);\n\tlp55xx_write(chip, LP5562_REG_PROG_MEM_ENG3, 0);\n\tlp55xx_write(chip, LP5562_REG_PROG_MEM_ENG3 + 1, 0);\n\n\t \n\tlp5562_write_program_memory(chip, LP5562_REG_PROG_MEM_ENG1,\n\t\t\t\tptn->r, ptn->size_r);\n\tlp5562_write_program_memory(chip, LP5562_REG_PROG_MEM_ENG2,\n\t\t\t\tptn->g, ptn->size_g);\n\tlp5562_write_program_memory(chip, LP5562_REG_PROG_MEM_ENG3,\n\t\t\t\tptn->b, ptn->size_b);\n\n\t \n\tlp5562_run_engine(chip, true);\n\n\treturn 0;\n}\n\nstatic ssize_t lp5562_store_pattern(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tstruct lp55xx_predef_pattern *ptn = chip->pdata->patterns;\n\tint num_patterns = chip->pdata->num_patterns;\n\tunsigned long mode;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &mode);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mode > num_patterns || !ptn)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->lock);\n\tret = lp5562_run_predef_led_pattern(chip, mode);\n\tmutex_unlock(&chip->lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t lp5562_store_engine_mux(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tu8 mask;\n\tu8 val;\n\n\t \n\n\tif (sysfs_streq(buf, \"RGB\")) {\n\t\tmask = LP5562_ENG_FOR_RGB_M;\n\t\tval = LP5562_ENG_SEL_RGB;\n\t} else if (sysfs_streq(buf, \"W\")) {\n\t\tenum lp55xx_engine_index idx = chip->engine_idx;\n\n\t\tmask = LP5562_ENG_FOR_W_M;\n\t\tswitch (idx) {\n\t\tcase LP55XX_ENGINE_1:\n\t\t\tval = LP5562_ENG1_FOR_W;\n\t\t\tbreak;\n\t\tcase LP55XX_ENGINE_2:\n\t\t\tval = LP5562_ENG2_FOR_W;\n\t\t\tbreak;\n\t\tcase LP55XX_ENGINE_3:\n\t\t\tval = LP5562_ENG3_FOR_W;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t} else {\n\t\tdev_err(dev, \"choose RGB or W\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&chip->lock);\n\tlp55xx_update_bits(chip, LP5562_REG_ENG_SEL, mask, val);\n\tmutex_unlock(&chip->lock);\n\n\treturn len;\n}\n\nstatic LP55XX_DEV_ATTR_WO(led_pattern, lp5562_store_pattern);\nstatic LP55XX_DEV_ATTR_WO(engine_mux, lp5562_store_engine_mux);\n\nstatic struct attribute *lp5562_attributes[] = {\n\t&dev_attr_led_pattern.attr,\n\t&dev_attr_engine_mux.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group lp5562_group = {\n\t.attrs = lp5562_attributes,\n};\n\n \nstatic struct lp55xx_device_config lp5562_cfg = {\n\t.max_channel  = LP5562_MAX_LEDS,\n\t.reset = {\n\t\t.addr = LP5562_REG_RESET,\n\t\t.val  = LP5562_RESET,\n\t},\n\t.enable = {\n\t\t.addr = LP5562_REG_ENABLE,\n\t\t.val  = LP5562_ENABLE_DEFAULT,\n\t},\n\t.post_init_device   = lp5562_post_init_device,\n\t.set_led_current    = lp5562_set_led_current,\n\t.brightness_fn      = lp5562_led_brightness,\n\t.run_engine         = lp5562_run_engine,\n\t.firmware_cb        = lp5562_firmware_loaded,\n\t.dev_attr_group     = &lp5562_group,\n};\n\nstatic int lp5562_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct lp55xx_chip *chip;\n\tstruct lp55xx_led *led;\n\tstruct lp55xx_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct device_node *np = dev_of_node(&client->dev);\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->cfg = &lp5562_cfg;\n\n\tif (!pdata) {\n\t\tif (np) {\n\t\t\tpdata = lp55xx_of_populate_pdata(&client->dev, np,\n\t\t\t\t\t\t\t chip);\n\t\t\tif (IS_ERR(pdata))\n\t\t\t\treturn PTR_ERR(pdata);\n\t\t} else {\n\t\t\tdev_err(&client->dev, \"no platform data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\n\tled = devm_kcalloc(&client->dev,\n\t\t\tpdata->num_channels, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tchip->cl = client;\n\tchip->pdata = pdata;\n\n\tmutex_init(&chip->lock);\n\n\ti2c_set_clientdata(client, led);\n\n\tret = lp55xx_init_device(chip);\n\tif (ret)\n\t\tgoto err_init;\n\n\tret = lp55xx_register_leds(led, chip);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = lp55xx_register_sysfs(chip);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"registering sysfs failed\\n\");\n\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tlp55xx_deinit_device(chip);\nerr_init:\n\treturn ret;\n}\n\nstatic void lp5562_remove(struct i2c_client *client)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(client);\n\tstruct lp55xx_chip *chip = led->chip;\n\n\tlp5562_stop_engine(chip);\n\n\tlp55xx_unregister_sysfs(chip);\n\tlp55xx_deinit_device(chip);\n}\n\nstatic const struct i2c_device_id lp5562_id[] = {\n\t{ \"lp5562\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lp5562_id);\n\nstatic const struct of_device_id of_lp5562_leds_match[] = {\n\t{ .compatible = \"ti,lp5562\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, of_lp5562_leds_match);\n\nstatic struct i2c_driver lp5562_driver = {\n\t.driver = {\n\t\t.name\t= \"lp5562\",\n\t\t.of_match_table = of_lp5562_leds_match,\n\t},\n\t.probe\t\t= lp5562_probe,\n\t.remove\t\t= lp5562_remove,\n\t.id_table\t= lp5562_id,\n};\n\nmodule_i2c_driver(lp5562_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments LP5562 LED Driver\");\nMODULE_AUTHOR(\"Milo Kim\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}