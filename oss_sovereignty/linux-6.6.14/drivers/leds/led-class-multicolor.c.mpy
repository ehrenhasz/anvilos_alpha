{
  "module_name": "led-class-multicolor.c",
  "hash_id": "06f684128bccd3cf597a56871606254eb53284fe9dcc5dcc30da23f48a5eccc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/led-class-multicolor.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/led-class-multicolor.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include \"leds.h\"\n\nint led_mc_calc_color_components(struct led_classdev_mc *mcled_cdev,\n\t\t\t\t enum led_brightness brightness)\n{\n\tstruct led_classdev *led_cdev = &mcled_cdev->led_cdev;\n\tint i;\n\n\tfor (i = 0; i < mcled_cdev->num_colors; i++)\n\t\tmcled_cdev->subled_info[i].brightness =\n\t\t\tDIV_ROUND_CLOSEST(brightness *\n\t\t\t\t\t  mcled_cdev->subled_info[i].intensity,\n\t\t\t\t\t  led_cdev->max_brightness);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(led_mc_calc_color_components);\n\nstatic ssize_t multi_intensity_store(struct device *dev,\n\t\t\t\tstruct device_attribute *intensity_attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_classdev_mc *mcled_cdev = lcdev_to_mccdev(led_cdev);\n\tint nrchars, offset = 0;\n\tint intensity_value[LED_COLOR_ID_MAX];\n\tint i;\n\tssize_t ret;\n\n\tmutex_lock(&led_cdev->led_access);\n\n\tfor (i = 0; i < mcled_cdev->num_colors; i++) {\n\t\tret = sscanf(buf + offset, \"%i%n\",\n\t\t\t     &intensity_value[i], &nrchars);\n\t\tif (ret != 1) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t\toffset += nrchars;\n\t}\n\n\toffset++;\n\tif (offset < size) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tfor (i = 0; i < mcled_cdev->num_colors; i++)\n\t\tmcled_cdev->subled_info[i].intensity = intensity_value[i];\n\n\tled_set_brightness(led_cdev, led_cdev->brightness);\n\tret = size;\nerr_out:\n\tmutex_unlock(&led_cdev->led_access);\n\treturn ret;\n}\n\nstatic ssize_t multi_intensity_show(struct device *dev,\n\t\t\t      struct device_attribute *intensity_attr,\n\t\t\t      char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_classdev_mc *mcled_cdev = lcdev_to_mccdev(led_cdev);\n\tint len = 0;\n\tint i;\n\n\tfor (i = 0; i < mcled_cdev->num_colors; i++) {\n\t\tlen += sprintf(buf + len, \"%d\",\n\t\t\t       mcled_cdev->subled_info[i].intensity);\n\t\tif (i < mcled_cdev->num_colors - 1)\n\t\t\tlen += sprintf(buf + len, \" \");\n\t}\n\n\tbuf[len++] = '\\n';\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(multi_intensity);\n\nstatic ssize_t multi_index_show(struct device *dev,\n\t\t\t      struct device_attribute *multi_index_attr,\n\t\t\t      char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_classdev_mc *mcled_cdev = lcdev_to_mccdev(led_cdev);\n\tint len = 0;\n\tint index;\n\tint i;\n\n\tfor (i = 0; i < mcled_cdev->num_colors; i++) {\n\t\tindex = mcled_cdev->subled_info[i].color_index;\n\t\tlen += sprintf(buf + len, \"%s\", led_colors[index]);\n\t\tif (i < mcled_cdev->num_colors - 1)\n\t\t\tlen += sprintf(buf + len, \" \");\n\t}\n\n\tbuf[len++] = '\\n';\n\treturn len;\n}\nstatic DEVICE_ATTR_RO(multi_index);\n\nstatic struct attribute *led_multicolor_attrs[] = {\n\t&dev_attr_multi_intensity.attr,\n\t&dev_attr_multi_index.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(led_multicolor);\n\nint led_classdev_multicolor_register_ext(struct device *parent,\n\t\t\t\t     struct led_classdev_mc *mcled_cdev,\n\t\t\t\t     struct led_init_data *init_data)\n{\n\tstruct led_classdev *led_cdev;\n\n\tif (!mcled_cdev)\n\t\treturn -EINVAL;\n\n\tif (mcled_cdev->num_colors <= 0)\n\t\treturn -EINVAL;\n\n\tif (mcled_cdev->num_colors > LED_COLOR_ID_MAX)\n\t\treturn -EINVAL;\n\n\tled_cdev = &mcled_cdev->led_cdev;\n\tmcled_cdev->led_cdev.groups = led_multicolor_groups;\n\n\treturn led_classdev_register_ext(parent, led_cdev, init_data);\n}\nEXPORT_SYMBOL_GPL(led_classdev_multicolor_register_ext);\n\nvoid led_classdev_multicolor_unregister(struct led_classdev_mc *mcled_cdev)\n{\n\tif (!mcled_cdev)\n\t\treturn;\n\n\tled_classdev_unregister(&mcled_cdev->led_cdev);\n}\nEXPORT_SYMBOL_GPL(led_classdev_multicolor_unregister);\n\nstatic void devm_led_classdev_multicolor_release(struct device *dev, void *res)\n{\n\tled_classdev_multicolor_unregister(*(struct led_classdev_mc **)res);\n}\n\nint devm_led_classdev_multicolor_register_ext(struct device *parent,\n\t\t\t\t\t     struct led_classdev_mc *mcled_cdev,\n\t\t\t\t\t     struct led_init_data *init_data)\n{\n\tstruct led_classdev_mc **dr;\n\tint ret;\n\n\tdr = devres_alloc(devm_led_classdev_multicolor_release,\n\t\t\t  sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tret = led_classdev_multicolor_register_ext(parent, mcled_cdev,\n\t\t\t\t\t\t   init_data);\n\tif (ret) {\n\t\tdevres_free(dr);\n\t\treturn ret;\n\t}\n\n\t*dr = mcled_cdev;\n\tdevres_add(parent, dr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_led_classdev_multicolor_register_ext);\n\nstatic int devm_led_classdev_multicolor_match(struct device *dev,\n\t\t\t\t\t      void *res, void *data)\n{\n\tstruct led_classdev_mc **p = res;\n\n\tif (WARN_ON(!p || !*p))\n\t\treturn 0;\n\n\treturn *p == data;\n}\n\nvoid devm_led_classdev_multicolor_unregister(struct device *dev,\n\t\t\t\t\t     struct led_classdev_mc *mcled_cdev)\n{\n\tWARN_ON(devres_release(dev,\n\t\t\t       devm_led_classdev_multicolor_release,\n\t\t\t       devm_led_classdev_multicolor_match, mcled_cdev));\n}\nEXPORT_SYMBOL_GPL(devm_led_classdev_multicolor_unregister);\n\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_DESCRIPTION(\"Multicolor LED class interface\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}