{
  "module_name": "leds-sunfire.c",
  "hash_id": "0ee6e0cf822eee1c38d92910502e977f910fcbd2de621d7245957ff5b2d786c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-sunfire.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/leds.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <asm/fhc.h>\n#include <asm/upa.h>\n\nMODULE_AUTHOR(\"David S. Miller (davem@davemloft.net)\");\nMODULE_DESCRIPTION(\"Sun Fire LED driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct sunfire_led {\n\tstruct led_classdev\tled_cdev;\n\tvoid __iomem\t\t*reg;\n};\n#define\tto_sunfire_led(d) container_of(d, struct sunfire_led, led_cdev)\n\nstatic void __clockboard_set(struct led_classdev *led_cdev,\n\t\t\t     enum led_brightness led_val, u8 bit)\n{\n\tstruct sunfire_led *p = to_sunfire_led(led_cdev);\n\tu8 reg = upa_readb(p->reg);\n\n\tswitch (bit) {\n\tcase CLOCK_CTRL_LLED:\n\t\tif (led_val)\n\t\t\treg &= ~bit;\n\t\telse\n\t\t\treg |= bit;\n\t\tbreak;\n\n\tdefault:\n\t\tif (led_val)\n\t\t\treg |= bit;\n\t\telse\n\t\t\treg &= ~bit;\n\t\tbreak;\n\t}\n\tupa_writeb(reg, p->reg);\n}\n\nstatic void clockboard_left_set(struct led_classdev *led_cdev,\n\t\t\t\tenum led_brightness led_val)\n{\n\t__clockboard_set(led_cdev, led_val, CLOCK_CTRL_LLED);\n}\n\nstatic void clockboard_middle_set(struct led_classdev *led_cdev,\n\t\t\t\t  enum led_brightness led_val)\n{\n\t__clockboard_set(led_cdev, led_val, CLOCK_CTRL_MLED);\n}\n\nstatic void clockboard_right_set(struct led_classdev *led_cdev,\n\t\t\t\t enum led_brightness led_val)\n{\n\t__clockboard_set(led_cdev, led_val, CLOCK_CTRL_RLED);\n}\n\nstatic void __fhc_set(struct led_classdev *led_cdev,\n\t\t\t     enum led_brightness led_val, u32 bit)\n{\n\tstruct sunfire_led *p = to_sunfire_led(led_cdev);\n\tu32 reg = upa_readl(p->reg);\n\n\tswitch (bit) {\n\tcase FHC_CONTROL_LLED:\n\t\tif (led_val)\n\t\t\treg &= ~bit;\n\t\telse\n\t\t\treg |= bit;\n\t\tbreak;\n\n\tdefault:\n\t\tif (led_val)\n\t\t\treg |= bit;\n\t\telse\n\t\t\treg &= ~bit;\n\t\tbreak;\n\t}\n\tupa_writel(reg, p->reg);\n}\n\nstatic void fhc_left_set(struct led_classdev *led_cdev,\n\t\t\t enum led_brightness led_val)\n{\n\t__fhc_set(led_cdev, led_val, FHC_CONTROL_LLED);\n}\n\nstatic void fhc_middle_set(struct led_classdev *led_cdev,\n\t\t\t   enum led_brightness led_val)\n{\n\t__fhc_set(led_cdev, led_val, FHC_CONTROL_MLED);\n}\n\nstatic void fhc_right_set(struct led_classdev *led_cdev,\n\t\t\t  enum led_brightness led_val)\n{\n\t__fhc_set(led_cdev, led_val, FHC_CONTROL_RLED);\n}\n\ntypedef void (*set_handler)(struct led_classdev *, enum led_brightness);\nstruct led_type {\n\tconst char\t*name;\n\tset_handler\thandler;\n\tconst char\t*default_trigger;\n};\n\n#define NUM_LEDS_PER_BOARD\t3\nstruct sunfire_drvdata {\n\tstruct sunfire_led\tleds[NUM_LEDS_PER_BOARD];\n};\n\nstatic int sunfire_led_generic_probe(struct platform_device *pdev,\n\t\t\t\t\t       struct led_type *types)\n{\n\tstruct sunfire_drvdata *p;\n\tint i, err;\n\n\tif (pdev->num_resources != 1) {\n\t\tdev_err(&pdev->dev, \"Wrong number of resources %d, should be 1\\n\",\n\t\t       pdev->num_resources);\n\t\treturn -EINVAL;\n\t}\n\n\tp = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < NUM_LEDS_PER_BOARD; i++) {\n\t\tstruct led_classdev *lp = &p->leds[i].led_cdev;\n\n\t\tp->leds[i].reg = (void __iomem *) pdev->resource[0].start;\n\t\tlp->name = types[i].name;\n\t\tlp->brightness = LED_FULL;\n\t\tlp->brightness_set = types[i].handler;\n\t\tlp->default_trigger = types[i].default_trigger;\n\n\t\terr = led_classdev_register(&pdev->dev, lp);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Could not register %s LED\\n\",\n\t\t\t       lp->name);\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\tled_classdev_unregister(&p->leds[i].led_cdev);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, p);\n\n\treturn 0;\n}\n\nstatic int sunfire_led_generic_remove(struct platform_device *pdev)\n{\n\tstruct sunfire_drvdata *p = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < NUM_LEDS_PER_BOARD; i++)\n\t\tled_classdev_unregister(&p->leds[i].led_cdev);\n\n\treturn 0;\n}\n\nstatic struct led_type clockboard_led_types[NUM_LEDS_PER_BOARD] = {\n\t{\n\t\t.name\t\t= \"clockboard-left\",\n\t\t.handler\t= clockboard_left_set,\n\t},\n\t{\n\t\t.name\t\t= \"clockboard-middle\",\n\t\t.handler\t= clockboard_middle_set,\n\t},\n\t{\n\t\t.name\t\t= \"clockboard-right\",\n\t\t.handler\t= clockboard_right_set,\n\t\t.default_trigger = \"heartbeat\",\n\t},\n};\n\nstatic int sunfire_clockboard_led_probe(struct platform_device *pdev)\n{\n\treturn sunfire_led_generic_probe(pdev, clockboard_led_types);\n}\n\nstatic struct led_type fhc_led_types[NUM_LEDS_PER_BOARD] = {\n\t{\n\t\t.name\t\t= \"fhc-left\",\n\t\t.handler\t= fhc_left_set,\n\t},\n\t{\n\t\t.name\t\t= \"fhc-middle\",\n\t\t.handler\t= fhc_middle_set,\n\t},\n\t{\n\t\t.name\t\t= \"fhc-right\",\n\t\t.handler\t= fhc_right_set,\n\t\t.default_trigger = \"heartbeat\",\n\t},\n};\n\nstatic int sunfire_fhc_led_probe(struct platform_device *pdev)\n{\n\treturn sunfire_led_generic_probe(pdev, fhc_led_types);\n}\n\nMODULE_ALIAS(\"platform:sunfire-clockboard-leds\");\nMODULE_ALIAS(\"platform:sunfire-fhc-leds\");\n\nstatic struct platform_driver sunfire_clockboard_led_driver = {\n\t.probe\t\t= sunfire_clockboard_led_probe,\n\t.remove\t\t= sunfire_led_generic_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"sunfire-clockboard-leds\",\n\t},\n};\n\nstatic struct platform_driver sunfire_fhc_led_driver = {\n\t.probe\t\t= sunfire_fhc_led_probe,\n\t.remove\t\t= sunfire_led_generic_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"sunfire-fhc-leds\",\n\t},\n};\n\nstatic struct platform_driver * const drivers[] = {\n\t&sunfire_clockboard_led_driver,\n\t&sunfire_fhc_led_driver,\n};\n\nstatic int __init sunfire_leds_init(void)\n{\n\treturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n}\n\nstatic void __exit sunfire_leds_exit(void)\n{\n\tplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\n}\n\nmodule_init(sunfire_leds_init);\nmodule_exit(sunfire_leds_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}