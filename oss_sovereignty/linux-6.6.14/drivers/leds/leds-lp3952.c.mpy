{
  "module_name": "leds-lp3952.c",
  "hash_id": "2b29c6a1c757a7b916c928abafd5f28be167f1d9d9bcd6cea9315b7d0ddc72fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lp3952.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/leds-lp3952.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n\nstatic int lp3952_register_write(struct i2c_client *client, u8 reg, u8 val)\n{\n\tint ret;\n\tstruct lp3952_led_array *priv = i2c_get_clientdata(client);\n\n\tret = regmap_write(priv->regmap, reg, val);\n\n\tif (ret)\n\t\tdev_err(&client->dev, \"%s: reg 0x%x, val 0x%x, err %d\\n\",\n\t\t\t__func__, reg, val, ret);\n\treturn ret;\n}\n\nstatic void lp3952_on_off(struct lp3952_led_array *priv,\n\t\t\t  enum lp3952_leds led_id, bool on)\n{\n\tint ret, val;\n\n\tdev_dbg(&priv->client->dev, \"%s LED %d to %d\\n\", __func__, led_id, on);\n\n\tval = 1 << led_id;\n\tif (led_id == LP3952_LED_ALL)\n\t\tval = LP3952_LED_MASK_ALL;\n\n\tret = regmap_update_bits(priv->regmap, LP3952_REG_LED_CTRL, val,\n\t\t\t\t on ? val : 0);\n\tif (ret)\n\t\tdev_err(&priv->client->dev, \"%s, Error %d\\n\", __func__, ret);\n}\n\n \nstatic int lp3952_set_brightness(struct led_classdev *cdev,\n\t\t\t\t enum led_brightness value)\n{\n\tunsigned int reg, shift_val;\n\tstruct lp3952_ctrl_hdl *led = container_of(cdev,\n\t\t\t\t\t\t   struct lp3952_ctrl_hdl,\n\t\t\t\t\t\t   cdev);\n\tstruct lp3952_led_array *priv = (struct lp3952_led_array *)led->priv;\n\n\tdev_dbg(cdev->dev, \"Brightness request: %d on %d\\n\", value,\n\t\tled->channel);\n\n\tif (value == LED_OFF) {\n\t\tlp3952_on_off(priv, led->channel, false);\n\t\treturn 0;\n\t}\n\n\tif (led->channel > LP3952_RED_1) {\n\t\tdev_err(cdev->dev, \" %s Invalid LED requested\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (led->channel >= LP3952_BLUE_1) {\n\t\treg = LP3952_REG_RGB1_MAX_I_CTRL;\n\t\tshift_val = (led->channel - LP3952_BLUE_1) * 2;\n\t} else {\n\t\treg = LP3952_REG_RGB2_MAX_I_CTRL;\n\t\tshift_val = led->channel * 2;\n\t}\n\n\t \n\tlp3952_on_off(priv, led->channel, true);\n\n\treturn regmap_update_bits(priv->regmap, reg, 3 << shift_val,\n\t\t\t\t  --value << shift_val);\n}\n\nstatic int lp3952_get_label(struct device *dev, const char *label, char *dest)\n{\n\tint ret;\n\tconst char *str;\n\n\tret = device_property_read_string(dev, label, &str);\n\tif (ret)\n\t\treturn ret;\n\n\tstrncpy(dest, str, LP3952_LABEL_MAX_LEN);\n\treturn 0;\n}\n\nstatic int lp3952_register_led_classdev(struct lp3952_led_array *priv)\n{\n\tint i, acpi_ret, ret = -ENODEV;\n\tstatic const char *led_name_hdl[LP3952_LED_ALL] = {\n\t\t\"blue2\",\n\t\t\"green2\",\n\t\t\"red2\",\n\t\t\"blue1\",\n\t\t\"green1\",\n\t\t\"red1\"\n\t};\n\n\tfor (i = 0; i < LP3952_LED_ALL; i++) {\n\t\tacpi_ret = lp3952_get_label(&priv->client->dev, led_name_hdl[i],\n\t\t\t\t\t    priv->leds[i].name);\n\t\tif (acpi_ret)\n\t\t\tcontinue;\n\n\t\tpriv->leds[i].cdev.name = priv->leds[i].name;\n\t\tpriv->leds[i].cdev.brightness = LED_OFF;\n\t\tpriv->leds[i].cdev.max_brightness = LP3952_BRIGHT_MAX;\n\t\tpriv->leds[i].cdev.brightness_set_blocking =\n\t\t\t\tlp3952_set_brightness;\n\t\tpriv->leds[i].channel = i;\n\t\tpriv->leds[i].priv = priv;\n\n\t\tret = devm_led_classdev_register(&priv->client->dev,\n\t\t\t\t\t\t &priv->leds[i].cdev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&priv->client->dev,\n\t\t\t\t\"couldn't register LED %s\\n\",\n\t\t\t\tpriv->leds[i].cdev.name);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int lp3952_set_pattern_gen_cmd(struct lp3952_led_array *priv,\n\t\t\t\t      u8 cmd_index, u8 r, u8 g, u8 b,\n\t\t\t\t      enum lp3952_tt tt, enum lp3952_cet cet)\n{\n\tint ret;\n\tstruct ptrn_gen_cmd line = {\n\t\t{\n\t\t\t{\n\t\t\t\t.r = r,\n\t\t\t\t.g = g,\n\t\t\t\t.b = b,\n\t\t\t\t.cet = cet,\n\t\t\t\t.tt = tt\n\t\t\t}\n\t\t}\n\t};\n\n\tif (cmd_index >= LP3952_CMD_REG_COUNT)\n\t\treturn -EINVAL;\n\n\tret = lp3952_register_write(priv->client,\n\t\t\t\t    LP3952_REG_CMD_0 + cmd_index * 2,\n\t\t\t\t    line.bytes.msb);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lp3952_register_write(priv->client,\n\t\t\t\t      LP3952_REG_CMD_0 + cmd_index * 2 + 1,\n\t\t\t\t      line.bytes.lsb);\n}\n\nstatic int lp3952_configure(struct lp3952_led_array *priv)\n{\n\tint ret;\n\n\t \n\tret = lp3952_register_write(priv->client, LP3952_REG_LED_CTRL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = lp3952_register_write(priv->client, LP3952_REG_PAT_GEN_CTRL,\n\t\t\t\t    LP3952_PATRN_LOOP | LP3952_PATRN_GEN_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = lp3952_register_write(priv->client, LP3952_REG_ENABLES,\n\t\t\t\t    LP3952_ACTIVE_MODE | LP3952_INT_B00ST_LDR);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn lp3952_set_pattern_gen_cmd(priv, 0, I46, I71, I100, TT0,\n\t\t\t\t\t   CET197);\n}\n\nstatic const struct regmap_config lp3952_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = REG_MAX,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int lp3952_probe(struct i2c_client *client)\n{\n\tint status;\n\tstruct lp3952_led_array *priv;\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->client = client;\n\n\tpriv->enable_gpio = devm_gpiod_get(&client->dev, \"nrst\",\n\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->enable_gpio)) {\n\t\tstatus = PTR_ERR(priv->enable_gpio);\n\t\tdev_err(&client->dev, \"Failed to enable gpio: %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &lp3952_regmap);\n\tif (IS_ERR(priv->regmap)) {\n\t\tint err = PTR_ERR(priv->regmap);\n\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\ti2c_set_clientdata(client, priv);\n\n\tstatus = lp3952_configure(priv);\n\tif (status) {\n\t\tdev_err(&client->dev, \"Probe failed. Device not found (%d)\\n\",\n\t\t\tstatus);\n\t\treturn status;\n\t}\n\n\tstatus = lp3952_register_led_classdev(priv);\n\tif (status) {\n\t\tdev_err(&client->dev, \"Unable to register led_classdev: %d\\n\",\n\t\t\tstatus);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic void lp3952_remove(struct i2c_client *client)\n{\n\tstruct lp3952_led_array *priv;\n\n\tpriv = i2c_get_clientdata(client);\n\tlp3952_on_off(priv, LP3952_LED_ALL, false);\n\tgpiod_set_value(priv->enable_gpio, 0);\n}\n\nstatic const struct i2c_device_id lp3952_id[] = {\n\t{LP3952_NAME, 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, lp3952_id);\n\nstatic struct i2c_driver lp3952_i2c_driver = {\n\t.driver = {\n\t\t\t.name = LP3952_NAME,\n\t},\n\t.probe = lp3952_probe,\n\t.remove = lp3952_remove,\n\t.id_table = lp3952_id,\n};\n\nmodule_i2c_driver(lp3952_i2c_driver);\n\nMODULE_AUTHOR(\"Tony Makkiel <tony.makkiel@daqri.com>\");\nMODULE_DESCRIPTION(\"lp3952 I2C LED controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}