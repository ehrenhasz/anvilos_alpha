{
  "module_name": "leds-clevo-mail.c",
  "hash_id": "0ba84a3eea9dfa83bc9cad2d7c2a74b1cbee432befbde748ff9bdd32bd215b99",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-clevo-mail.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/leds.h>\n\n#include <linux/io.h>\n#include <linux/dmi.h>\n\n#include <linux/i8042.h>\n\n#define CLEVO_MAIL_LED_OFF\t\t0x0084\n#define CLEVO_MAIL_LED_BLINK_1HZ\t0x008A\n#define CLEVO_MAIL_LED_BLINK_0_5HZ\t0x0083\n\nMODULE_AUTHOR(\"M\u00e1rton N\u00e9meth <nm127@freemail.hu>\");\nMODULE_DESCRIPTION(\"Clevo mail LED driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool nodetect;\nmodule_param_named(nodetect, nodetect, bool, 0);\nMODULE_PARM_DESC(nodetect, \"Skip DMI hardware detection\");\n\nstatic struct platform_device *pdev;\n\nstatic int __init clevo_mail_led_dmi_callback(const struct dmi_system_id *id)\n{\n\tpr_info(\"'%s' found\\n\", id->ident);\n\treturn 1;\n}\n\n \nstatic const struct dmi_system_id clevo_mail_led_dmi_table[] __initconst = {\n\t{\n\t\t.callback = clevo_mail_led_dmi_callback,\n\t\t.ident = \"Clevo D410J\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"VIA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"K8N800\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"VT8204B\")\n\t\t}\n\t},\n\t{\n\t\t.callback = clevo_mail_led_dmi_callback,\n\t\t.ident = \"Clevo M5x0N\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"CLEVO Co.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"M5x0N\")\n\t\t}\n\t},\n\t{\n\t\t.callback = clevo_mail_led_dmi_callback,\n\t\t.ident = \"Clevo M5x0V\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"CLEVO Co. \"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"M5X0V \"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"VT6198\")\n\t\t}\n\t},\n\t{\n\t\t.callback = clevo_mail_led_dmi_callback,\n\t\t.ident = \"Clevo D400P\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Clevo\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"D400P\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"Rev.A\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"0106\")\n\t\t}\n\t},\n\t{\n\t\t.callback = clevo_mail_led_dmi_callback,\n\t\t.ident = \"Clevo D410V\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Clevo, Co.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"D400V/D470V\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"SS78B\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"Rev. A1\")\n\t\t}\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(dmi, clevo_mail_led_dmi_table);\n\nstatic void clevo_mail_led_set(struct led_classdev *led_cdev,\n\t\t\t\tenum led_brightness value)\n{\n\ti8042_lock_chip();\n\n\tif (value == LED_OFF)\n\t\ti8042_command(NULL, CLEVO_MAIL_LED_OFF);\n\telse if (value <= LED_HALF)\n\t\ti8042_command(NULL, CLEVO_MAIL_LED_BLINK_0_5HZ);\n\telse\n\t\ti8042_command(NULL, CLEVO_MAIL_LED_BLINK_1HZ);\n\n\ti8042_unlock_chip();\n\n}\n\nstatic int clevo_mail_led_blink(struct led_classdev *led_cdev,\n\t\t\t\tunsigned long *delay_on,\n\t\t\t\tunsigned long *delay_off)\n{\n\tint status = -EINVAL;\n\n\ti8042_lock_chip();\n\n\tif (*delay_on == 0   && *delay_off == 0  ) {\n\t\t \n\t\t*delay_on = 1000;  \n\t\t*delay_off = 1000;  \n\t\ti8042_command(NULL, CLEVO_MAIL_LED_BLINK_0_5HZ);\n\t\tstatus = 0;\n\n\t} else if (*delay_on == 500   && *delay_off == 500  ) {\n\t\t \n\t\ti8042_command(NULL, CLEVO_MAIL_LED_BLINK_1HZ);\n\t\tstatus = 0;\n\n\t} else if (*delay_on == 1000   && *delay_off == 1000  ) {\n\t\t \n\t\ti8042_command(NULL, CLEVO_MAIL_LED_BLINK_0_5HZ);\n\t\tstatus = 0;\n\n\t} else {\n\t\tpr_debug(\"clevo_mail_led_blink(..., %lu, %lu),\"\n\t\t       \" returning -EINVAL (unsupported)\\n\",\n\t\t       *delay_on, *delay_off);\n\t}\n\n\ti8042_unlock_chip();\n\n\treturn status;\n}\n\nstatic struct led_classdev clevo_mail_led = {\n\t.name\t\t\t= \"clevo::mail\",\n\t.brightness_set\t\t= clevo_mail_led_set,\n\t.blink_set\t\t= clevo_mail_led_blink,\n\t.flags\t\t\t= LED_CORE_SUSPENDRESUME,\n};\n\nstatic int __init clevo_mail_led_probe(struct platform_device *pdev)\n{\n\treturn led_classdev_register(&pdev->dev, &clevo_mail_led);\n}\n\nstatic int clevo_mail_led_remove(struct platform_device *pdev)\n{\n\tled_classdev_unregister(&clevo_mail_led);\n\treturn 0;\n}\n\nstatic struct platform_driver clevo_mail_led_driver = {\n\t.remove\t\t= clevo_mail_led_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t},\n};\n\nstatic int __init clevo_mail_led_init(void)\n{\n\tint error = 0;\n\tint count = 0;\n\n\t \n\tif (!nodetect) {\n\t\tcount = dmi_check_system(clevo_mail_led_dmi_table);\n\t} else {\n\t\tcount = 1;\n\t\tpr_err(\"Skipping DMI detection. \"\n\t\t       \"If the driver works on your hardware please \"\n\t\t       \"report model and the output of dmidecode in tracker \"\n\t\t       \"at http://sourceforge.net/projects/clevo-mailled/\\n\");\n\t}\n\n\tif (!count)\n\t\treturn -ENODEV;\n\n\tpdev = platform_device_register_simple(KBUILD_MODNAME, -1, NULL, 0);\n\tif (!IS_ERR(pdev)) {\n\t\terror = platform_driver_probe(&clevo_mail_led_driver,\n\t\t\t\t\t      clevo_mail_led_probe);\n\t\tif (error) {\n\t\t\tpr_err(\"Can't probe platform driver\\n\");\n\t\t\tplatform_device_unregister(pdev);\n\t\t}\n\t} else\n\t\terror = PTR_ERR(pdev);\n\n\treturn error;\n}\n\nstatic void __exit clevo_mail_led_exit(void)\n{\n\tplatform_device_unregister(pdev);\n\tplatform_driver_unregister(&clevo_mail_led_driver);\n\n\tclevo_mail_led_set(NULL, LED_OFF);\n}\n\nmodule_init(clevo_mail_led_init);\nmodule_exit(clevo_mail_led_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}