{
  "module_name": "leds-cht-wcove.c",
  "hash_id": "274441e1dfbc52f0573563617cb16fe9bd51c665ecda1756db2137805e5f77d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-cht-wcove.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/suspend.h>\n\n#define CHT_WC_LED1_CTRL\t\t0x5e1f\n#define CHT_WC_LED1_FSM\t\t\t0x5e20\n#define CHT_WC_LED1_PWM\t\t\t0x5e21\n\n#define CHT_WC_LED2_CTRL\t\t0x4fdf\n#define CHT_WC_LED2_FSM\t\t\t0x4fe0\n#define CHT_WC_LED2_PWM\t\t\t0x4fe1\n\n#define CHT_WC_LED1_SWCTL\t\tBIT(0)\t\t \n#define CHT_WC_LED1_ON\t\t\tBIT(1)\n\n#define CHT_WC_LED2_ON\t\t\tBIT(0)\n#define CHT_WC_LED_I_MA2_5\t\t(2 << 2)\t \n#define CHT_WC_LED_I_MASK\t\tGENMASK(3, 2)\t \n\n#define CHT_WC_LED_F_1_4_HZ\t\t(0 << 4)\n#define CHT_WC_LED_F_1_2_HZ\t\t(1 << 4)\n#define CHT_WC_LED_F_1_HZ\t\t(2 << 4)\n#define CHT_WC_LED_F_2_HZ\t\t(3 << 4)\n#define CHT_WC_LED_F_MASK\t\tGENMASK(5, 4)\n\n#define CHT_WC_LED_EFF_OFF\t\t(0 << 1)\n#define CHT_WC_LED_EFF_ON\t\t(1 << 1)\n#define CHT_WC_LED_EFF_BLINKING\t\t(2 << 1)\n#define CHT_WC_LED_EFF_BREATHING\t(3 << 1)\n#define CHT_WC_LED_EFF_MASK\t\tGENMASK(2, 1)\n\n#define CHT_WC_LED_COUNT\t\t2\n\nstruct cht_wc_led_regs {\n\t \n\tu16 ctrl;\n\tu16 fsm;\n\tu16 pwm;\n\t \n\tu8 on_off_mask;\n\tu8 on_val;\n\tu8 off_val;\n};\n\nstruct cht_wc_led_saved_regs {\n\tunsigned int ctrl;\n\tunsigned int fsm;\n\tunsigned int pwm;\n};\n\nstruct cht_wc_led {\n\tstruct led_classdev cdev;\n\tconst struct cht_wc_led_regs *regs;\n\tstruct regmap *regmap;\n\tstruct mutex mutex;\n\tstruct cht_wc_led_saved_regs saved_regs;\n};\n\nstruct cht_wc_leds {\n\tstruct cht_wc_led leds[CHT_WC_LED_COUNT];\n\t \n\tstruct cht_wc_led_saved_regs led1_initial_regs;\n};\n\nstatic const struct cht_wc_led_regs cht_wc_led_regs[CHT_WC_LED_COUNT] = {\n\t{\n\t\t.ctrl\t\t= CHT_WC_LED1_CTRL,\n\t\t.fsm\t\t= CHT_WC_LED1_FSM,\n\t\t.pwm\t\t= CHT_WC_LED1_PWM,\n\t\t.on_off_mask\t= CHT_WC_LED1_SWCTL | CHT_WC_LED1_ON,\n\t\t.on_val\t\t= CHT_WC_LED1_SWCTL | CHT_WC_LED1_ON,\n\t\t.off_val\t= CHT_WC_LED1_SWCTL,\n\t},\n\t{\n\t\t.ctrl\t\t= CHT_WC_LED2_CTRL,\n\t\t.fsm\t\t= CHT_WC_LED2_FSM,\n\t\t.pwm\t\t= CHT_WC_LED2_PWM,\n\t\t.on_off_mask\t= CHT_WC_LED2_ON,\n\t\t.on_val\t\t= CHT_WC_LED2_ON,\n\t\t.off_val\t= 0,\n\t},\n};\n\nstatic const char * const cht_wc_leds_names[CHT_WC_LED_COUNT] = {\n\t\"platform::\" LED_FUNCTION_CHARGING,\n\t\"platform::\" LED_FUNCTION_INDICATOR,\n};\n\nstatic int cht_wc_leds_brightness_set(struct led_classdev *cdev,\n\t\t\t\t      enum led_brightness value)\n{\n\tstruct cht_wc_led *led = container_of(cdev, struct cht_wc_led, cdev);\n\tint ret;\n\n\tmutex_lock(&led->mutex);\n\n\tif (!value) {\n\t\tret = regmap_update_bits(led->regmap, led->regs->ctrl,\n\t\t\t\t\t led->regs->on_off_mask, led->regs->off_val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cdev->dev, \"Failed to turn off: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = regmap_update_bits(led->regmap, led->regs->fsm,\n\t\t\t\t\t CHT_WC_LED_EFF_MASK, CHT_WC_LED_EFF_ON);\n\t\tif (ret < 0)\n\t\t\tdev_err(cdev->dev, \"Failed to update LED FSM reg: %d\\n\", ret);\n\t} else {\n\t\tret = regmap_write(led->regmap, led->regs->pwm, value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cdev->dev, \"Failed to set brightness: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = regmap_update_bits(led->regmap, led->regs->ctrl,\n\t\t\t\t\t led->regs->on_off_mask, led->regs->on_val);\n\t\tif (ret < 0)\n\t\t\tdev_err(cdev->dev, \"Failed to turn on: %d\\n\", ret);\n\t}\nout:\n\tmutex_unlock(&led->mutex);\n\treturn ret;\n}\n\nstatic enum led_brightness cht_wc_leds_brightness_get(struct led_classdev *cdev)\n{\n\tstruct cht_wc_led *led = container_of(cdev, struct cht_wc_led, cdev);\n\tunsigned int val;\n\tint ret;\n\n\tmutex_lock(&led->mutex);\n\n\tret = regmap_read(led->regmap, led->regs->ctrl, &val);\n\tif (ret < 0) {\n\t\tdev_err(cdev->dev, \"Failed to read LED CTRL reg: %d\\n\", ret);\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\tval &= led->regs->on_off_mask;\n\tif (val != led->regs->on_val) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\tret = regmap_read(led->regmap, led->regs->pwm, &val);\n\tif (ret < 0) {\n\t\tdev_err(cdev->dev, \"Failed to read LED PWM reg: %d\\n\", ret);\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\tret = val;\ndone:\n\tmutex_unlock(&led->mutex);\n\n\treturn ret;\n}\n\n \nstatic unsigned long cht_wc_leds_get_period(int ctrl)\n{\n\tctrl &= CHT_WC_LED_F_MASK;\n\n\tswitch (ctrl) {\n\tcase CHT_WC_LED_F_1_4_HZ:\n\t\treturn 1000 * 4;\n\tcase CHT_WC_LED_F_1_2_HZ:\n\t\treturn 1000 * 2;\n\tcase CHT_WC_LED_F_1_HZ:\n\t\treturn 1000;\n\tcase CHT_WC_LED_F_2_HZ:\n\t\treturn 1000 / 2;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cht_wc_leds_find_freq(unsigned long period)\n{\n\tif (period < 750)\n\t\treturn CHT_WC_LED_F_2_HZ;\n\telse if (period < 1500)\n\t\treturn CHT_WC_LED_F_1_HZ;\n\telse if (period < 3000)\n\t\treturn CHT_WC_LED_F_1_2_HZ;\n\telse if (period < 5000)\n\t\treturn CHT_WC_LED_F_1_4_HZ;\n\telse\n\t\treturn -1;\n}\n\nstatic int cht_wc_leds_set_effect(struct led_classdev *cdev,\n\t\t\t\t  unsigned long *delay_on,\n\t\t\t\t  unsigned long *delay_off,\n\t\t\t\t  u8 effect)\n{\n\tstruct cht_wc_led *led = container_of(cdev, struct cht_wc_led, cdev);\n\tint ctrl, ret;\n\n\tmutex_lock(&led->mutex);\n\n\t \n\tif (!*delay_on && !*delay_off)\n\t\t*delay_on = *delay_off = 500;\n\n\tctrl = cht_wc_leds_find_freq(*delay_on + *delay_off);\n\tif (ctrl < 0) {\n\t\t \n\t\tret = regmap_update_bits(led->regmap, led->regs->fsm,\n\t\t\t\t\t CHT_WC_LED_EFF_MASK, CHT_WC_LED_EFF_ON);\n\t\tif (ret < 0)\n\t\t\tdev_err(cdev->dev, \"Failed to update LED FSM reg: %d\\n\", ret);\n\n\t\t \n\t\t*delay_on = *delay_off = 0;\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tret = regmap_update_bits(led->regmap, led->regs->fsm,\n\t\t\t\t CHT_WC_LED_EFF_MASK, effect);\n\tif (ret < 0)\n\t\tdev_err(cdev->dev, \"Failed to update LED FSM reg: %d\\n\", ret);\n\n\t \n\tret = regmap_update_bits(led->regmap, led->regs->ctrl,\n\t\t\t\t CHT_WC_LED_F_MASK | led->regs->on_off_mask,\n\t\t\t\t ctrl | led->regs->on_val);\n\tif (ret < 0)\n\t\tdev_err(cdev->dev, \"Failed to update LED CTRL reg: %d\\n\", ret);\n\n\t*delay_off = *delay_on = cht_wc_leds_get_period(ctrl) / 2;\n\ndone:\n\tmutex_unlock(&led->mutex);\n\n\treturn ret;\n}\n\nstatic int cht_wc_leds_blink_set(struct led_classdev *cdev,\n\t\t\t\t unsigned long *delay_on,\n\t\t\t\t unsigned long *delay_off)\n{\n\tu8 effect = CHT_WC_LED_EFF_BLINKING;\n\n\t \n\tif (cdev->flags & LED_INIT_DEFAULT_TRIGGER) {\n\t\t*delay_on = *delay_off = 1000;\n\t\teffect = CHT_WC_LED_EFF_BREATHING;\n\t}\n\n\treturn cht_wc_leds_set_effect(cdev, delay_on, delay_off, effect);\n}\n\nstatic int cht_wc_leds_pattern_set(struct led_classdev *cdev,\n\t\t\t\t   struct led_pattern *pattern,\n\t\t\t\t   u32 len, int repeat)\n{\n\tunsigned long delay_off, delay_on;\n\n\tif (repeat > 0 || len != 2 ||\n\t    pattern[0].brightness != 0 || pattern[1].brightness != 1 ||\n\t    pattern[0].delta_t != pattern[1].delta_t ||\n\t    (pattern[0].delta_t != 250 && pattern[0].delta_t != 500 &&\n\t     pattern[0].delta_t != 1000 && pattern[0].delta_t != 2000))\n\t\treturn -EINVAL;\n\n\tdelay_off = pattern[0].delta_t;\n\tdelay_on  = pattern[1].delta_t;\n\n\treturn cht_wc_leds_set_effect(cdev, &delay_on, &delay_off, CHT_WC_LED_EFF_BREATHING);\n}\n\nstatic int cht_wc_leds_pattern_clear(struct led_classdev *cdev)\n{\n\treturn cht_wc_leds_brightness_set(cdev, 0);\n}\n\nstatic int cht_wc_led_save_regs(struct cht_wc_led *led,\n\t\t\t\tstruct cht_wc_led_saved_regs *saved_regs)\n{\n\tint ret;\n\n\tret = regmap_read(led->regmap, led->regs->ctrl, &saved_regs->ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(led->regmap, led->regs->fsm, &saved_regs->fsm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_read(led->regmap, led->regs->pwm, &saved_regs->pwm);\n}\n\nstatic void cht_wc_led_restore_regs(struct cht_wc_led *led,\n\t\t\t\t    const struct cht_wc_led_saved_regs *saved_regs)\n{\n\tregmap_write(led->regmap, led->regs->ctrl, saved_regs->ctrl);\n\tregmap_write(led->regmap, led->regs->fsm, saved_regs->fsm);\n\tregmap_write(led->regmap, led->regs->pwm, saved_regs->pwm);\n}\n\nstatic int cht_wc_leds_probe(struct platform_device *pdev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(pdev->dev.parent);\n\tstruct cht_wc_leds *leds;\n\tint ret;\n\tint i;\n\n\t \n\tif (pmic->cht_wc_model == INTEL_CHT_WC_LENOVO_YT3_X90)\n\t\treturn -ENODEV;\n\n\tleds = devm_kzalloc(&pdev->dev, sizeof(*leds), GFP_KERNEL);\n\tif (!leds)\n\t\treturn -ENOMEM;\n\n\t \n\tleds->leds[0].regs = &cht_wc_led_regs[0];\n\tleds->leds[0].regmap = pmic->regmap;\n\tret = cht_wc_led_save_regs(&leds->leds[0], &leds->led1_initial_regs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tswitch (pmic->cht_wc_model) {\n\tcase INTEL_CHT_WC_GPD_WIN_POCKET:\n\t\tleds->leds[0].cdev.default_trigger = \"max170xx_battery-charging-blink-full-solid\";\n\t\tbreak;\n\tcase INTEL_CHT_WC_XIAOMI_MIPAD2:\n\t\tleds->leds[0].cdev.default_trigger = \"bq27520-0-charging-blink-full-solid\";\n\t\tbreak;\n\tcase INTEL_CHT_WC_LENOVO_YOGABOOK1:\n\t\tleds->leds[0].cdev.default_trigger = \"bq27542-0-charging-blink-full-solid\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&pdev->dev, \"Unknown model, no default charging trigger\\n\");\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < CHT_WC_LED_COUNT; i++) {\n\t\tstruct cht_wc_led *led = &leds->leds[i];\n\n\t\tled->regs = &cht_wc_led_regs[i];\n\t\tled->regmap = pmic->regmap;\n\t\tmutex_init(&led->mutex);\n\t\tled->cdev.name = cht_wc_leds_names[i];\n\t\tled->cdev.brightness_set_blocking = cht_wc_leds_brightness_set;\n\t\tled->cdev.brightness_get = cht_wc_leds_brightness_get;\n\t\tled->cdev.blink_set = cht_wc_leds_blink_set;\n\t\tled->cdev.pattern_set = cht_wc_leds_pattern_set;\n\t\tled->cdev.pattern_clear = cht_wc_leds_pattern_clear;\n\t\tled->cdev.max_brightness = 255;\n\n\t\tret = led_classdev_register(&pdev->dev, &led->cdev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, leds);\n\treturn 0;\n}\n\nstatic void cht_wc_leds_remove(struct platform_device *pdev)\n{\n\tstruct cht_wc_leds *leds = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < CHT_WC_LED_COUNT; i++)\n\t\tled_classdev_unregister(&leds->leds[i].cdev);\n\n\t \n\tif (!(leds->led1_initial_regs.ctrl & CHT_WC_LED1_SWCTL))\n\t\tcht_wc_led_restore_regs(&leds->leds[0], &leds->led1_initial_regs);\n}\n\nstatic void cht_wc_leds_disable(struct platform_device *pdev)\n{\n\tstruct cht_wc_leds *leds = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < CHT_WC_LED_COUNT; i++)\n\t\tcht_wc_leds_brightness_set(&leds->leds[i].cdev, 0);\n\n\t \n\tif (!(leds->led1_initial_regs.ctrl & CHT_WC_LED1_SWCTL))\n\t\tcht_wc_led_restore_regs(&leds->leds[0], &leds->led1_initial_regs);\n}\n\n \nstatic int cht_wc_leds_suspend(struct device *dev)\n{\n\tstruct cht_wc_leds *leds = dev_get_drvdata(dev);\n\tint i, ret;\n\n\tfor (i = 0; i < CHT_WC_LED_COUNT; i++) {\n\t\tret = cht_wc_led_save_regs(&leds->leds[i], &leds->leds[i].saved_regs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tcht_wc_leds_disable(to_platform_device(dev));\n\treturn 0;\n}\n\n \nstatic int cht_wc_leds_resume(struct device *dev)\n{\n\tstruct cht_wc_leds *leds = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < CHT_WC_LED_COUNT; i++)\n\t\tcht_wc_led_restore_regs(&leds->leds[i], &leds->leds[i].saved_regs);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(cht_wc_leds_pm, cht_wc_leds_suspend, cht_wc_leds_resume);\n\nstatic struct platform_driver cht_wc_leds_driver = {\n\t.probe = cht_wc_leds_probe,\n\t.remove_new = cht_wc_leds_remove,\n\t.shutdown = cht_wc_leds_disable,\n\t.driver = {\n\t\t.name = \"cht_wcove_leds\",\n\t\t.pm = pm_sleep_ptr(&cht_wc_leds_pm),\n\t},\n};\nmodule_platform_driver(cht_wc_leds_driver);\n\nMODULE_ALIAS(\"platform:cht_wcove_leds\");\nMODULE_DESCRIPTION(\"Intel Cherry Trail Whiskey Cove PMIC LEDs driver\");\nMODULE_AUTHOR(\"Yauhen Kharuzhy <jekhor@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}