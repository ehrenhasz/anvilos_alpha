{
  "module_name": "leds-da9052.c",
  "hash_id": "d262695133c1b6bf2fc87de456cdc6537aed344a88c1daabb31403fdf7b7fb4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-da9052.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/leds.h>\n#include <linux/slab.h>\n\n#include <linux/mfd/da9052/reg.h>\n#include <linux/mfd/da9052/da9052.h>\n#include <linux/mfd/da9052/pdata.h>\n\n#define DA9052_OPENDRAIN_OUTPUT\t2\n#define DA9052_SET_HIGH_LVL_OUTPUT\t(1 << 3)\n#define DA9052_MASK_UPPER_NIBBLE\t0xF0\n#define DA9052_MASK_LOWER_NIBBLE\t0x0F\n#define DA9052_NIBBLE_SHIFT\t\t4\n#define DA9052_MAX_BRIGHTNESS\t\t0x5f\n\nstruct da9052_led {\n\tstruct led_classdev cdev;\n\tstruct da9052 *da9052;\n\tunsigned char led_index;\n\tunsigned char id;\n};\n\nstatic unsigned char led_reg[] = {\n\tDA9052_LED_CONT_4_REG,\n\tDA9052_LED_CONT_5_REG,\n};\n\nstatic int da9052_set_led_brightness(struct da9052_led *led,\n\t\t\t\t     enum led_brightness brightness)\n{\n\tu8 val;\n\tint error;\n\n\tval = (brightness & 0x7f) | DA9052_LED_CONT_DIM;\n\n\terror = da9052_reg_write(led->da9052, led_reg[led->led_index], val);\n\tif (error < 0)\n\t\tdev_err(led->da9052->dev, \"Failed to set led brightness, %d\\n\",\n\t\t\terror);\n\treturn error;\n}\n\nstatic int da9052_led_set(struct led_classdev *led_cdev,\n\t\t\t   enum led_brightness value)\n{\n\tstruct da9052_led *led =\n\t\t\tcontainer_of(led_cdev, struct da9052_led, cdev);\n\n\treturn da9052_set_led_brightness(led, value);\n}\n\nstatic int da9052_configure_leds(struct da9052 *da9052)\n{\n\tint error;\n\tunsigned char register_value = DA9052_OPENDRAIN_OUTPUT\n\t\t\t\t       | DA9052_SET_HIGH_LVL_OUTPUT;\n\n\terror = da9052_reg_update(da9052, DA9052_GPIO_14_15_REG,\n\t\t\t\t  DA9052_MASK_LOWER_NIBBLE,\n\t\t\t\t  register_value);\n\n\tif (error < 0) {\n\t\tdev_err(da9052->dev, \"Failed to write GPIO 14-15 reg, %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = da9052_reg_update(da9052, DA9052_GPIO_14_15_REG,\n\t\t\t\t  DA9052_MASK_UPPER_NIBBLE,\n\t\t\t\t  register_value << DA9052_NIBBLE_SHIFT);\n\tif (error < 0)\n\t\tdev_err(da9052->dev, \"Failed to write GPIO 14-15 reg, %d\\n\",\n\t\t\terror);\n\n\treturn error;\n}\n\nstatic int da9052_led_probe(struct platform_device *pdev)\n{\n\tstruct da9052_pdata *pdata;\n\tstruct da9052 *da9052;\n\tstruct led_platform_data *pled;\n\tstruct da9052_led *led = NULL;\n\tint error = -ENODEV;\n\tint i;\n\n\tda9052 = dev_get_drvdata(pdev->dev.parent);\n\tpdata = dev_get_platdata(da9052->dev);\n\tif (pdata == NULL) {\n\t\tdev_err(&pdev->dev, \"No platform data\\n\");\n\t\tgoto err;\n\t}\n\n\tpled = pdata->pled;\n\tif (pled == NULL) {\n\t\tdev_err(&pdev->dev, \"No platform data for LED\\n\");\n\t\tgoto err;\n\t}\n\n\tled = devm_kcalloc(&pdev->dev,\n\t\t\t   pled->num_leds, sizeof(struct da9052_led),\n\t\t\t   GFP_KERNEL);\n\tif (!led) {\n\t\terror = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < pled->num_leds; i++) {\n\t\tled[i].cdev.name = pled->leds[i].name;\n\t\tled[i].cdev.brightness_set_blocking = da9052_led_set;\n\t\tled[i].cdev.brightness = LED_OFF;\n\t\tled[i].cdev.max_brightness = DA9052_MAX_BRIGHTNESS;\n\t\tled[i].led_index = pled->leds[i].flags;\n\t\tled[i].da9052 = dev_get_drvdata(pdev->dev.parent);\n\n\t\terror = led_classdev_register(pdev->dev.parent, &led[i].cdev);\n\t\tif (error) {\n\t\t\tdev_err(&pdev->dev, \"Failed to register led %d\\n\",\n\t\t\t\tled[i].led_index);\n\t\t\tgoto err_register;\n\t\t}\n\n\t\terror = da9052_set_led_brightness(&led[i],\n\t\t\t\t\t\t  led[i].cdev.brightness);\n\t\tif (error) {\n\t\t\tdev_err(&pdev->dev, \"Unable to init led %d\\n\",\n\t\t\t\tled[i].led_index);\n\t\t\tcontinue;\n\t\t}\n\t}\n\terror = da9052_configure_leds(led->da9052);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to configure GPIO LED%d\\n\", error);\n\t\tgoto err_register;\n\t}\n\n\tplatform_set_drvdata(pdev, led);\n\n\treturn 0;\n\nerr_register:\n\tfor (i = i - 1; i >= 0; i--)\n\t\tled_classdev_unregister(&led[i].cdev);\nerr:\n\treturn error;\n}\n\nstatic int da9052_led_remove(struct platform_device *pdev)\n{\n\tstruct da9052_led *led = platform_get_drvdata(pdev);\n\tstruct da9052_pdata *pdata;\n\tstruct da9052 *da9052;\n\tstruct led_platform_data *pled;\n\tint i;\n\n\tda9052 = dev_get_drvdata(pdev->dev.parent);\n\tpdata = dev_get_platdata(da9052->dev);\n\tpled = pdata->pled;\n\n\tfor (i = 0; i < pled->num_leds; i++) {\n\t\tda9052_set_led_brightness(&led[i], LED_OFF);\n\t\tled_classdev_unregister(&led[i].cdev);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver da9052_led_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"da9052-leds\",\n\t},\n\t.probe\t\t= da9052_led_probe,\n\t.remove\t\t= da9052_led_remove,\n};\n\nmodule_platform_driver(da9052_led_driver);\n\nMODULE_AUTHOR(\"Dialog Semiconductor Ltd <dchen@diasemi.com>\");\nMODULE_DESCRIPTION(\"LED driver for Dialog DA9052 PMIC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}