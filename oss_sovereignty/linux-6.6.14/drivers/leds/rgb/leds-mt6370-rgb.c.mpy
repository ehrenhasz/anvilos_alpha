{
  "module_name": "leds-mt6370-rgb.c",
  "hash_id": "7e1c818da11686e3257796bcdc5af7a08ff530262657a292d7f81fe6b51e0e6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/rgb/leds-mt6370-rgb.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/led-class-multicolor.h>\n#include <linux/linear_range.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/util_macros.h>\n\n#include <asm/unaligned.h>\n\nenum {\n\tMT6370_LED_ISNK1 = 0,\n\tMT6370_LED_ISNK2,\n\tMT6370_LED_ISNK3,\n\tMT6370_LED_ISNK4,\n\tMT6370_MAX_LEDS\n};\n\nenum mt6370_led_mode {\n\tMT6370_LED_PWM_MODE = 0,\n\tMT6370_LED_BREATH_MODE,\n\tMT6370_LED_REG_MODE,\n\tMT6370_LED_MAX_MODE\n};\n\nenum mt6370_led_field {\n\tF_RGB_EN = 0,\n\tF_CHGIND_EN,\n\tF_LED1_CURR,\n\tF_LED2_CURR,\n\tF_LED3_CURR,\n\tF_LED4_CURR,\n\tF_LED1_MODE,\n\tF_LED2_MODE,\n\tF_LED3_MODE,\n\tF_LED4_MODE,\n\tF_LED1_DUTY,\n\tF_LED2_DUTY,\n\tF_LED3_DUTY,\n\tF_LED4_DUTY,\n\tF_LED1_FREQ,\n\tF_LED2_FREQ,\n\tF_LED3_FREQ,\n\tF_LED4_FREQ,\n\tF_MAX_FIELDS\n};\n\nenum mt6370_led_ranges {\n\tR_LED123_CURR = 0,\n\tR_LED4_CURR,\n\tR_LED_TRFON,\n\tR_LED_TOFF,\n\tR_MAX_RANGES\n};\n\nenum mt6370_pattern {\n\tP_LED_TR1 = 0,\n\tP_LED_TR2,\n\tP_LED_TF1,\n\tP_LED_TF2,\n\tP_LED_TON,\n\tP_LED_TOFF,\n\tP_MAX_PATTERNS\n};\n\n#define MT6370_REG_DEV_INFO\t\t\t0x100\n#define MT6370_REG_RGB1_DIM\t\t\t0x182\n#define MT6370_REG_RGB2_DIM\t\t\t0x183\n#define MT6370_REG_RGB3_DIM\t\t\t0x184\n#define MT6370_REG_RGB_EN\t\t\t0x185\n#define MT6370_REG_RGB1_ISNK\t\t\t0x186\n#define MT6370_REG_RGB2_ISNK\t\t\t0x187\n#define MT6370_REG_RGB3_ISNK\t\t\t0x188\n#define MT6370_REG_RGB1_TR\t\t\t0x189\n#define MT6370_REG_RGB_CHRIND_DIM\t\t0x192\n#define MT6370_REG_RGB_CHRIND_CTRL\t\t0x193\n#define MT6370_REG_RGB_CHRIND_TR\t\t0x194\n\n#define MT6372_REG_RGB_EN\t\t\t0x182\n#define MT6372_REG_RGB1_ISNK\t\t\t0x183\n#define MT6372_REG_RGB2_ISNK\t\t\t0x184\n#define MT6372_REG_RGB3_ISNK\t\t\t0x185\n#define MT6372_REG_RGB4_ISNK\t\t\t0x186\n#define MT6372_REG_RGB1_DIM\t\t\t0x187\n#define MT6372_REG_RGB2_DIM\t\t\t0x188\n#define MT6372_REG_RGB3_DIM\t\t\t0x189\n#define MT6372_REG_RGB4_DIM\t\t\t0x18A\n#define MT6372_REG_RGB12_FREQ\t\t\t0x18B\n#define MT6372_REG_RGB34_FREQ\t\t\t0x18C\n#define MT6372_REG_RGB1_TR\t\t\t0x18D\n\n#define MT6370_VENDOR_ID_MASK\t\t\tGENMASK(7, 4)\n#define MT6372_VENDOR_ID\t\t\t0x9\n#define MT6372C_VENDOR_ID\t\t\t0xb\n#define MT6370_CHEN_BIT(id)\t\t\tBIT(MT6370_LED_ISNK4 - id)\n#define MT6370_VIRTUAL_MULTICOLOR\t\t5\n#define MC_CHANNEL_NUM\t\t\t\t3\n#define MT6370_PWM_DUTY\t\t\t\t(BIT(5) - 1)\n#define MT6372_PWM_DUTY\t\t\t\t(BIT(8) - 1)\n\nstruct mt6370_led {\n\t \n\tunion {\n\t\tstruct led_classdev isink;\n\t\tstruct led_classdev_mc mc;\n\t};\n\tstruct mt6370_priv *priv;\n\tenum led_default_state default_state;\n\tu32 index;\n};\n\nstruct mt6370_pdata {\n\tconst unsigned int *tfreq;\n\tunsigned int tfreq_len;\n\tu16 reg_rgb1_tr;\n\ts16 reg_rgb_chrind_tr;\n\tu8 pwm_duty;\n};\n\nstruct mt6370_priv {\n\t \n\tstruct mutex lock;\n\tstruct regmap *regmap;\n\tstruct regmap_field *fields[F_MAX_FIELDS];\n\tconst struct reg_field *reg_fields;\n\tconst struct linear_range *ranges;\n\tstruct reg_cfg *reg_cfgs;\n\tconst struct mt6370_pdata *pdata;\n\tunsigned int leds_count;\n\tunsigned int leds_active;\n\tstruct mt6370_led leds[];\n};\n\nstatic const struct reg_field common_reg_fields[F_MAX_FIELDS] = {\n\t[F_RGB_EN]\t= REG_FIELD(MT6370_REG_RGB_EN, 4, 7),\n\t[F_CHGIND_EN]\t= REG_FIELD(MT6370_REG_RGB_CHRIND_DIM, 7, 7),\n\t[F_LED1_CURR]\t= REG_FIELD(MT6370_REG_RGB1_ISNK, 0, 2),\n\t[F_LED2_CURR]\t= REG_FIELD(MT6370_REG_RGB2_ISNK, 0, 2),\n\t[F_LED3_CURR]\t= REG_FIELD(MT6370_REG_RGB3_ISNK, 0, 2),\n\t[F_LED4_CURR]\t= REG_FIELD(MT6370_REG_RGB_CHRIND_CTRL, 0, 1),\n\t[F_LED1_MODE]\t= REG_FIELD(MT6370_REG_RGB1_DIM, 5, 6),\n\t[F_LED2_MODE]\t= REG_FIELD(MT6370_REG_RGB2_DIM, 5, 6),\n\t[F_LED3_MODE]\t= REG_FIELD(MT6370_REG_RGB3_DIM, 5, 6),\n\t[F_LED4_MODE]\t= REG_FIELD(MT6370_REG_RGB_CHRIND_DIM, 5, 6),\n\t[F_LED1_DUTY]\t= REG_FIELD(MT6370_REG_RGB1_DIM, 0, 4),\n\t[F_LED2_DUTY]\t= REG_FIELD(MT6370_REG_RGB2_DIM, 0, 4),\n\t[F_LED3_DUTY]\t= REG_FIELD(MT6370_REG_RGB3_DIM, 0, 4),\n\t[F_LED4_DUTY]\t= REG_FIELD(MT6370_REG_RGB_CHRIND_DIM, 0, 4),\n\t[F_LED1_FREQ]\t= REG_FIELD(MT6370_REG_RGB1_ISNK, 3, 5),\n\t[F_LED2_FREQ]\t= REG_FIELD(MT6370_REG_RGB2_ISNK, 3, 5),\n\t[F_LED3_FREQ]\t= REG_FIELD(MT6370_REG_RGB3_ISNK, 3, 5),\n\t[F_LED4_FREQ]\t= REG_FIELD(MT6370_REG_RGB_CHRIND_CTRL, 2, 4),\n};\n\nstatic const struct reg_field mt6372_reg_fields[F_MAX_FIELDS] = {\n\t[F_RGB_EN]\t= REG_FIELD(MT6372_REG_RGB_EN, 4, 7),\n\t[F_CHGIND_EN]\t= REG_FIELD(MT6372_REG_RGB_EN, 3, 3),\n\t[F_LED1_CURR]\t= REG_FIELD(MT6372_REG_RGB1_ISNK, 0, 3),\n\t[F_LED2_CURR]\t= REG_FIELD(MT6372_REG_RGB2_ISNK, 0, 3),\n\t[F_LED3_CURR]\t= REG_FIELD(MT6372_REG_RGB3_ISNK, 0, 3),\n\t[F_LED4_CURR]\t= REG_FIELD(MT6372_REG_RGB4_ISNK, 0, 3),\n\t[F_LED1_MODE]\t= REG_FIELD(MT6372_REG_RGB1_ISNK, 6, 7),\n\t[F_LED2_MODE]\t= REG_FIELD(MT6372_REG_RGB2_ISNK, 6, 7),\n\t[F_LED3_MODE]\t= REG_FIELD(MT6372_REG_RGB3_ISNK, 6, 7),\n\t[F_LED4_MODE]\t= REG_FIELD(MT6372_REG_RGB4_ISNK, 6, 7),\n\t[F_LED1_DUTY]\t= REG_FIELD(MT6372_REG_RGB1_DIM, 0, 7),\n\t[F_LED2_DUTY]\t= REG_FIELD(MT6372_REG_RGB2_DIM, 0, 7),\n\t[F_LED3_DUTY]\t= REG_FIELD(MT6372_REG_RGB3_DIM, 0, 7),\n\t[F_LED4_DUTY]\t= REG_FIELD(MT6372_REG_RGB4_DIM, 0, 7),\n\t[F_LED1_FREQ]\t= REG_FIELD(MT6372_REG_RGB12_FREQ, 5, 7),\n\t[F_LED2_FREQ]\t= REG_FIELD(MT6372_REG_RGB12_FREQ, 2, 4),\n\t[F_LED3_FREQ]\t= REG_FIELD(MT6372_REG_RGB34_FREQ, 5, 7),\n\t[F_LED4_FREQ]\t= REG_FIELD(MT6372_REG_RGB34_FREQ, 2, 4),\n};\n\n \nstatic const struct linear_range common_led_ranges[R_MAX_RANGES] = {\n\t[R_LED123_CURR]\t= { 4000, 1, 6, 4000 },\n\t[R_LED4_CURR]\t= { 2000, 1, 3, 2000 },\n\t[R_LED_TRFON]\t= { 125, 0, 15, 200 },\n\t[R_LED_TOFF]\t= { 250, 0, 15, 400 },\n};\n\nstatic const struct linear_range mt6372_led_ranges[R_MAX_RANGES] = {\n\t[R_LED123_CURR]\t= { 2000, 1, 14, 2000 },\n\t[R_LED4_CURR]\t= { 2000, 1, 14, 2000 },\n\t[R_LED_TRFON]\t= { 125, 0, 15, 250 },\n\t[R_LED_TOFF]\t= { 250, 0, 15, 500 },\n};\n\nstatic const unsigned int common_tfreqs[] = {\n\t10000, 5000, 2000, 1000, 500, 200, 5, 1,\n};\n\nstatic const unsigned int mt6372_tfreqs[] = {\n\t8000, 4000, 2000, 1000, 500, 250, 8, 4,\n};\n\nstatic const struct mt6370_pdata common_pdata = {\n\t.tfreq = common_tfreqs,\n\t.tfreq_len = ARRAY_SIZE(common_tfreqs),\n\t.pwm_duty = MT6370_PWM_DUTY,\n\t.reg_rgb1_tr = MT6370_REG_RGB1_TR,\n\t.reg_rgb_chrind_tr = MT6370_REG_RGB_CHRIND_TR,\n};\n\nstatic const struct mt6370_pdata mt6372_pdata = {\n\t.tfreq = mt6372_tfreqs,\n\t.tfreq_len = ARRAY_SIZE(mt6372_tfreqs),\n\t.pwm_duty = MT6372_PWM_DUTY,\n\t.reg_rgb1_tr = MT6372_REG_RGB1_TR,\n\t.reg_rgb_chrind_tr = -1,\n};\n\nstatic enum mt6370_led_field mt6370_get_led_current_field(unsigned int led_no)\n{\n\tswitch (led_no) {\n\tcase MT6370_LED_ISNK1:\n\t\treturn F_LED1_CURR;\n\tcase MT6370_LED_ISNK2:\n\t\treturn F_LED2_CURR;\n\tcase MT6370_LED_ISNK3:\n\t\treturn F_LED3_CURR;\n\tdefault:\n\t\treturn F_LED4_CURR;\n\t}\n}\n\nstatic int mt6370_set_led_brightness(struct mt6370_priv *priv, unsigned int led_no,\n\t\t\t\t     unsigned int level)\n{\n\tenum mt6370_led_field sel_field;\n\n\tsel_field = mt6370_get_led_current_field(led_no);\n\n\treturn regmap_field_write(priv->fields[sel_field], level);\n}\n\nstatic int mt6370_get_led_brightness(struct mt6370_priv *priv, unsigned int led_no,\n\t\t\t\t     unsigned int *level)\n{\n\tenum mt6370_led_field sel_field;\n\n\tsel_field = mt6370_get_led_current_field(led_no);\n\n\treturn regmap_field_read(priv->fields[sel_field], level);\n}\n\nstatic int mt6370_set_led_duty(struct mt6370_priv *priv, unsigned int led_no, unsigned int ton,\n\t\t\t       unsigned int toff)\n{\n\tconst struct mt6370_pdata *pdata = priv->pdata;\n\tenum mt6370_led_field sel_field;\n\tunsigned int divisor, ratio;\n\n\tdivisor = pdata->pwm_duty;\n\tratio = ton * divisor / (ton + toff);\n\n\tswitch (led_no) {\n\tcase MT6370_LED_ISNK1:\n\t\tsel_field = F_LED1_DUTY;\n\t\tbreak;\n\tcase MT6370_LED_ISNK2:\n\t\tsel_field = F_LED2_DUTY;\n\t\tbreak;\n\tcase MT6370_LED_ISNK3:\n\t\tsel_field = F_LED3_DUTY;\n\t\tbreak;\n\tdefault:\n\t\tsel_field = F_LED4_DUTY;\n\t\tbreak;\n\t}\n\n\treturn regmap_field_write(priv->fields[sel_field], ratio);\n}\n\nstatic int mt6370_set_led_freq(struct mt6370_priv *priv, unsigned int led_no, unsigned int ton,\n\t\t\t       unsigned int toff)\n{\n\tconst struct mt6370_pdata *pdata = priv->pdata;\n\tenum mt6370_led_field sel_field;\n\tunsigned int tfreq_len = pdata->tfreq_len;\n\tunsigned int tsum, sel;\n\n\ttsum = ton + toff;\n\n\tif (tsum > pdata->tfreq[0] || tsum < pdata->tfreq[tfreq_len - 1])\n\t\treturn -EOPNOTSUPP;\n\n\tsel = find_closest_descending(tsum, pdata->tfreq, tfreq_len);\n\n\tswitch (led_no) {\n\tcase MT6370_LED_ISNK1:\n\t\tsel_field = F_LED1_FREQ;\n\t\tbreak;\n\tcase MT6370_LED_ISNK2:\n\t\tsel_field = F_LED2_FREQ;\n\t\tbreak;\n\tcase MT6370_LED_ISNK3:\n\t\tsel_field = F_LED3_FREQ;\n\t\tbreak;\n\tdefault:\n\t\tsel_field = F_LED4_FREQ;\n\t\tbreak;\n\t}\n\n\treturn regmap_field_write(priv->fields[sel_field], sel);\n}\n\nstatic void mt6370_get_breath_reg_base(struct mt6370_priv *priv, unsigned int led_no,\n\t\t\t\t       unsigned int *base)\n{\n\tconst struct mt6370_pdata *pdata = priv->pdata;\n\n\tif (pdata->reg_rgb_chrind_tr < 0) {\n\t\t*base = pdata->reg_rgb1_tr + led_no * 3;\n\t\treturn;\n\t}\n\n\tswitch (led_no) {\n\tcase MT6370_LED_ISNK1:\n\tcase MT6370_LED_ISNK2:\n\tcase MT6370_LED_ISNK3:\n\t\t*base = pdata->reg_rgb1_tr + led_no * 3;\n\t\tbreak;\n\tdefault:\n\t\t*base = pdata->reg_rgb_chrind_tr;\n\t\tbreak;\n\t}\n}\n\nstatic int mt6370_gen_breath_pattern(struct mt6370_priv *priv, struct led_pattern *pattern, u32 len,\n\t\t\t\t     u8 *pattern_val, u32 val_len)\n{\n\tenum mt6370_led_ranges sel_range;\n\tstruct led_pattern *curr;\n\tunsigned int sel;\n\tu32 val = 0;\n\tint i;\n\n\tif (len < P_MAX_PATTERNS && val_len < P_MAX_PATTERNS / 2)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < P_MAX_PATTERNS; i++) {\n\t\tcurr = pattern + i;\n\n\t\tsel_range = i == P_LED_TOFF ? R_LED_TOFF : R_LED_TRFON;\n\n\t\tlinear_range_get_selector_within(priv->ranges + sel_range, curr->delta_t, &sel);\n\n\t\tif (i % 2) {\n\t\t\tval |= sel;\n\t\t} else {\n\t\t\tval <<= 8;\n\t\t\tval |= sel << 4;\n\t\t}\n\t}\n\n\tput_unaligned_be24(val, pattern_val);\n\n\treturn 0;\n}\n\nstatic int mt6370_set_led_mode(struct mt6370_priv *priv, unsigned int led_no,\n\t\t\t       enum mt6370_led_mode mode)\n{\n\tenum mt6370_led_field sel_field;\n\n\tswitch (led_no) {\n\tcase MT6370_LED_ISNK1:\n\t\tsel_field = F_LED1_MODE;\n\t\tbreak;\n\tcase MT6370_LED_ISNK2:\n\t\tsel_field = F_LED2_MODE;\n\t\tbreak;\n\tcase MT6370_LED_ISNK3:\n\t\tsel_field = F_LED3_MODE;\n\t\tbreak;\n\tdefault:\n\t\tsel_field = F_LED4_MODE;\n\t\tbreak;\n\t}\n\n\treturn regmap_field_write(priv->fields[sel_field], mode);\n}\n\nstatic int mt6370_mc_brightness_set(struct led_classdev *lcdev, enum led_brightness level)\n{\n\tstruct led_classdev_mc *mccdev = lcdev_to_mccdev(lcdev);\n\tstruct mt6370_led *led = container_of(mccdev, struct mt6370_led, mc);\n\tstruct mt6370_priv *priv = led->priv;\n\tstruct mc_subled *subled;\n\tunsigned int enable, disable;\n\tint i, ret;\n\n\tmutex_lock(&priv->lock);\n\n\tled_mc_calc_color_components(mccdev, level);\n\n\tret = regmap_field_read(priv->fields[F_RGB_EN], &enable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tdisable = enable;\n\n\tfor (i = 0; i < mccdev->num_colors; i++) {\n\t\tu32 brightness;\n\n\t\tsubled = mccdev->subled_info + i;\n\t\tbrightness = min(subled->brightness, lcdev->max_brightness);\n\t\tdisable &= ~MT6370_CHEN_BIT(subled->channel);\n\n\t\tif (level == 0) {\n\t\t\tenable &= ~MT6370_CHEN_BIT(subled->channel);\n\n\t\t\tret = mt6370_set_led_mode(priv, subled->channel, MT6370_LED_REG_MODE);\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (brightness == 0) {\n\t\t\tenable &= ~MT6370_CHEN_BIT(subled->channel);\n\t\t\tcontinue;\n\t\t}\n\n\t\tenable |= MT6370_CHEN_BIT(subled->channel);\n\n\t\tret = mt6370_set_led_brightness(priv, subled->channel, brightness);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_field_write(priv->fields[F_RGB_EN], disable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_field_write(priv->fields[F_RGB_EN], enable);\n\nout_unlock:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int mt6370_mc_blink_set(struct led_classdev *lcdev,\n\t\t\t       unsigned long *delay_on,\n\t\t\t       unsigned long *delay_off)\n{\n\tstruct led_classdev_mc *mccdev = lcdev_to_mccdev(lcdev);\n\tstruct mt6370_led *led = container_of(mccdev, struct mt6370_led, mc);\n\tstruct mt6370_priv *priv = led->priv;\n\tstruct mc_subled *subled;\n\tunsigned int enable, disable;\n\tint i, ret;\n\n\tmutex_lock(&priv->lock);\n\n\tif (!*delay_on && !*delay_off)\n\t\t*delay_on = *delay_off = 500;\n\n\tret = regmap_field_read(priv->fields[F_RGB_EN], &enable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tdisable = enable;\n\n\tfor (i = 0; i < mccdev->num_colors; i++) {\n\t\tsubled = mccdev->subled_info + i;\n\n\t\tdisable &= ~MT6370_CHEN_BIT(subled->channel);\n\n\t\tret = mt6370_set_led_duty(priv, subled->channel, *delay_on, *delay_off);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tret = mt6370_set_led_freq(priv, subled->channel, *delay_on, *delay_off);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tret = mt6370_set_led_mode(priv, subled->channel, MT6370_LED_PWM_MODE);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t \n\tret = regmap_field_write(priv->fields[F_RGB_EN], disable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_field_write(priv->fields[F_RGB_EN], enable);\n\nout_unlock:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int mt6370_mc_pattern_set(struct led_classdev *lcdev, struct led_pattern *pattern, u32 len,\n\t\t\t\t int repeat)\n{\n\tstruct led_classdev_mc *mccdev = lcdev_to_mccdev(lcdev);\n\tstruct mt6370_led *led = container_of(mccdev, struct mt6370_led, mc);\n\tstruct mt6370_priv *priv = led->priv;\n\tstruct mc_subled *subled;\n\tunsigned int reg_base, enable, disable;\n\tu8 params[P_MAX_PATTERNS / 2];\n\tint i, ret;\n\n\tmutex_lock(&priv->lock);\n\n\tret = mt6370_gen_breath_pattern(priv, pattern, len, params, sizeof(params));\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_field_read(priv->fields[F_RGB_EN], &enable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tdisable = enable;\n\n\tfor (i = 0; i < mccdev->num_colors; i++) {\n\t\tsubled = mccdev->subled_info + i;\n\n\t\tmt6370_get_breath_reg_base(priv, subled->channel, &reg_base);\n\t\tdisable &= ~MT6370_CHEN_BIT(subled->channel);\n\n\t\tret = regmap_raw_write(priv->regmap, reg_base, params, sizeof(params));\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tret = mt6370_set_led_mode(priv, subled->channel, MT6370_LED_BREATH_MODE);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t \n\tret = regmap_field_write(priv->fields[F_RGB_EN], disable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_field_write(priv->fields[F_RGB_EN], enable);\n\nout_unlock:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic inline int mt6370_mc_pattern_clear(struct led_classdev *lcdev)\n{\n\tstruct led_classdev_mc *mccdev = lcdev_to_mccdev(lcdev);\n\tstruct mt6370_led *led = container_of(mccdev, struct mt6370_led, mc);\n\tstruct mt6370_priv *priv = led->priv;\n\tstruct mc_subled *subled;\n\tint i, ret;\n\n\tmutex_lock(&led->priv->lock);\n\n\tfor (i = 0; i < mccdev->num_colors; i++) {\n\t\tsubled = mccdev->subled_info + i;\n\n\t\tret = mt6370_set_led_mode(priv, subled->channel, MT6370_LED_REG_MODE);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&led->priv->lock);\n\n\treturn ret;\n}\n\nstatic int mt6370_isnk_brightness_set(struct led_classdev *lcdev,\n\t\t\t\t      enum led_brightness level)\n{\n\tstruct mt6370_led *led = container_of(lcdev, struct mt6370_led, isink);\n\tstruct mt6370_priv *priv = led->priv;\n\tunsigned int enable;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\tret = regmap_field_read(priv->fields[F_RGB_EN], &enable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (level == 0) {\n\t\tenable &= ~MT6370_CHEN_BIT(led->index);\n\n\t\tret = mt6370_set_led_mode(priv, led->index, MT6370_LED_REG_MODE);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t} else {\n\t\tenable |= MT6370_CHEN_BIT(led->index);\n\n\t\tret = mt6370_set_led_brightness(priv, led->index, level);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_field_write(priv->fields[F_RGB_EN], enable);\n\nout_unlock:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int mt6370_isnk_blink_set(struct led_classdev *lcdev, unsigned long *delay_on,\n\t\t\t\t unsigned long *delay_off)\n{\n\tstruct mt6370_led *led = container_of(lcdev, struct mt6370_led, isink);\n\tstruct mt6370_priv *priv = led->priv;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\tif (!*delay_on && !*delay_off)\n\t\t*delay_on = *delay_off = 500;\n\n\tret = mt6370_set_led_duty(priv, led->index, *delay_on, *delay_off);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = mt6370_set_led_freq(priv, led->index, *delay_on, *delay_off);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = mt6370_set_led_mode(priv, led->index, MT6370_LED_PWM_MODE);\n\nout_unlock:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int mt6370_isnk_pattern_set(struct led_classdev *lcdev, struct led_pattern *pattern, u32 len,\n\t\t\t\t   int repeat)\n{\n\tstruct mt6370_led *led = container_of(lcdev, struct mt6370_led, isink);\n\tstruct mt6370_priv *priv = led->priv;\n\tunsigned int reg_base;\n\tu8 params[P_MAX_PATTERNS / 2];\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\tret = mt6370_gen_breath_pattern(priv, pattern, len, params, sizeof(params));\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tmt6370_get_breath_reg_base(priv, led->index, &reg_base);\n\n\tret = regmap_raw_write(priv->regmap, reg_base, params, sizeof(params));\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = mt6370_set_led_mode(priv, led->index, MT6370_LED_BREATH_MODE);\n\nout_unlock:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic inline int mt6370_isnk_pattern_clear(struct led_classdev *lcdev)\n{\n\tstruct mt6370_led *led = container_of(lcdev, struct mt6370_led, isink);\n\tstruct mt6370_priv *priv = led->priv;\n\tint ret;\n\n\tmutex_lock(&led->priv->lock);\n\tret = mt6370_set_led_mode(priv, led->index, MT6370_LED_REG_MODE);\n\tmutex_unlock(&led->priv->lock);\n\n\treturn ret;\n}\n\nstatic int mt6370_assign_multicolor_info(struct device *dev, struct mt6370_led *led,\n\t\t\t\t\t struct fwnode_handle *fwnode)\n{\n\tstruct mt6370_priv *priv = led->priv;\n\tstruct fwnode_handle *child;\n\tstruct mc_subled *sub_led;\n\tu32 num_color = 0;\n\tint ret;\n\n\tsub_led = devm_kcalloc(dev, MC_CHANNEL_NUM, sizeof(*sub_led), GFP_KERNEL);\n\tif (!sub_led)\n\t\treturn -ENOMEM;\n\n\tfwnode_for_each_child_node(fwnode, child) {\n\t\tu32 reg, color;\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret || reg > MT6370_LED_ISNK3 || priv->leds_active & BIT(reg)) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = fwnode_property_read_u32(child, \"color\", &color);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn dev_err_probe(dev, ret, \"LED %d, no color specified\\n\", led->index);\n\t\t}\n\n\t\tpriv->leds_active |= BIT(reg);\n\t\tsub_led[num_color].color_index = color;\n\t\tsub_led[num_color].channel = reg;\n\t\tsub_led[num_color].intensity = 0;\n\t\tnum_color++;\n\t}\n\n\tif (num_color < 2)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Multicolor must include 2 or more LED channels\\n\");\n\n\tled->mc.num_colors = num_color;\n\tled->mc.subled_info = sub_led;\n\n\treturn 0;\n}\n\nstatic int mt6370_init_led_properties(struct device *dev, struct mt6370_led *led,\n\t\t\t\t      struct led_init_data *init_data)\n{\n\tstruct mt6370_priv *priv = led->priv;\n\tstruct led_classdev *lcdev;\n\tenum mt6370_led_ranges sel_range;\n\tu32 max_uA, max_level;\n\tint ret;\n\n\tif (led->index == MT6370_VIRTUAL_MULTICOLOR) {\n\t\tret = mt6370_assign_multicolor_info(dev, led, init_data->fwnode);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlcdev = &led->mc.led_cdev;\n\t\tlcdev->brightness_set_blocking = mt6370_mc_brightness_set;\n\t\tlcdev->blink_set = mt6370_mc_blink_set;\n\t\tlcdev->pattern_set = mt6370_mc_pattern_set;\n\t\tlcdev->pattern_clear = mt6370_mc_pattern_clear;\n\t} else {\n\t\tlcdev = &led->isink;\n\t\tlcdev->brightness_set_blocking = mt6370_isnk_brightness_set;\n\t\tlcdev->blink_set = mt6370_isnk_blink_set;\n\t\tlcdev->pattern_set = mt6370_isnk_pattern_set;\n\t\tlcdev->pattern_clear = mt6370_isnk_pattern_clear;\n\t}\n\n\tret = fwnode_property_read_u32(init_data->fwnode, \"led-max-microamp\", &max_uA);\n\tif (ret) {\n\t\tdev_warn(dev, \"Not specified led-max-microamp, config to the minimum\\n\");\n\t\tmax_uA = 0;\n\t}\n\n\tif (led->index == MT6370_LED_ISNK4)\n\t\tsel_range = R_LED4_CURR;\n\telse\n\t\tsel_range = R_LED123_CURR;\n\n\tlinear_range_get_selector_within(priv->ranges + sel_range, max_uA, &max_level);\n\n\tlcdev->max_brightness = max_level;\n\n\tled->default_state = led_init_default_state_get(init_data->fwnode);\n\n\treturn 0;\n}\n\nstatic int mt6370_isnk_init_default_state(struct mt6370_led *led)\n{\n\tstruct mt6370_priv *priv = led->priv;\n\tunsigned int enable, level;\n\tint ret;\n\n\tret = mt6370_get_led_brightness(priv, led->index, &level);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_field_read(priv->fields[F_RGB_EN], &enable);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(enable & MT6370_CHEN_BIT(led->index)))\n\t\tlevel = 0;\n\n\tswitch (led->default_state) {\n\tcase LEDS_DEFSTATE_ON:\n\t\tled->isink.brightness = led->isink.max_brightness;\n\t\tbreak;\n\tcase LEDS_DEFSTATE_KEEP:\n\t\tled->isink.brightness = min(level, led->isink.max_brightness);\n\t\tbreak;\n\tdefault:\n\t\tled->isink.brightness = 0;\n\t\tbreak;\n\t}\n\n\treturn mt6370_isnk_brightness_set(&led->isink, led->isink.brightness);\n}\n\nstatic int mt6370_multicolor_led_register(struct device *dev, struct mt6370_led *led,\n\t\t\t\t\t  struct led_init_data *init_data)\n{\n\tint ret;\n\n\tret = mt6370_mc_brightness_set(&led->mc.led_cdev, 0);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Couldn't set multicolor brightness\\n\");\n\n\tret = devm_led_classdev_multicolor_register_ext(dev, &led->mc, init_data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Couldn't register multicolor\\n\");\n\n\treturn 0;\n}\n\nstatic int mt6370_led_register(struct device *dev, struct mt6370_led *led,\n\t\t\t       struct led_init_data *init_data)\n{\n\tstruct mt6370_priv *priv = led->priv;\n\tint ret;\n\n\tif (led->index == MT6370_VIRTUAL_MULTICOLOR)\n\t\treturn mt6370_multicolor_led_register(dev, led, init_data);\n\n\t \n\tif (led->index == MT6370_LED_ISNK4) {\n\t\tret = regmap_field_write(priv->fields[F_CHGIND_EN], 1);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"Failed to set CHRIND to SW\\n\");\n\t}\n\n\tret = mt6370_isnk_init_default_state(led);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init %d isnk state\\n\", led->index);\n\n\tret = devm_led_classdev_register_ext(dev, &led->isink, init_data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Couldn't register isink %d\\n\", led->index);\n\n\treturn 0;\n}\n\nstatic int mt6370_check_vendor_info(struct mt6370_priv *priv)\n{\n\tunsigned int devinfo, vid;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, MT6370_REG_DEV_INFO, &devinfo);\n\tif (ret)\n\t\treturn ret;\n\n\tvid = FIELD_GET(MT6370_VENDOR_ID_MASK, devinfo);\n\tif (vid == MT6372_VENDOR_ID || vid == MT6372C_VENDOR_ID) {\n\t\tpriv->reg_fields = mt6372_reg_fields;\n\t\tpriv->ranges = mt6372_led_ranges;\n\t\tpriv->pdata = &mt6372_pdata;\n\t} else {\n\t\t \n\t\tpriv->reg_fields = common_reg_fields;\n\t\tpriv->ranges = common_led_ranges;\n\t\tpriv->pdata = &common_pdata;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt6370_leds_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mt6370_priv *priv;\n\tstruct fwnode_handle *child;\n\tsize_t count;\n\tunsigned int i = 0;\n\tint ret;\n\n\tcount = device_get_child_node_count(dev);\n\tif (!count || count > MT6370_MAX_LEDS)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"No child node or node count over max LED number %zu\\n\",\n\t\t\t\t      count);\n\n\tpriv = devm_kzalloc(dev, struct_size(priv, leds, count), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->leds_count = count;\n\tmutex_init(&priv->lock);\n\n\tpriv->regmap = dev_get_regmap(dev->parent, NULL);\n\tif (!priv->regmap)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Failed to get parent regmap\\n\");\n\n\tret = mt6370_check_vendor_info(priv);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to check vendor info\\n\");\n\n\tret = devm_regmap_field_bulk_alloc(dev, priv->regmap, priv->fields, priv->reg_fields,\n\t\t\t\t\t   F_MAX_FIELDS);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to allocate regmap field\\n\");\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tstruct mt6370_led *led = priv->leds + i++;\n\t\tstruct led_init_data init_data = { .fwnode = child };\n\t\tu32 reg, color;\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to parse reg property\\n\");\n\t\t\tgoto fwnode_release;\n\t\t}\n\n\t\tif (reg >= MT6370_MAX_LEDS) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(dev, \"Error reg property number\\n\");\n\t\t\tgoto fwnode_release;\n\t\t}\n\n\t\tret = fwnode_property_read_u32(child, \"color\", &color);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to parse color property\\n\");\n\t\t\tgoto fwnode_release;\n\t\t}\n\n\t\tif (color == LED_COLOR_ID_RGB || color == LED_COLOR_ID_MULTI)\n\t\t\treg = MT6370_VIRTUAL_MULTICOLOR;\n\n\t\tif (priv->leds_active & BIT(reg)) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(dev, \"Duplicate reg property\\n\");\n\t\t\tgoto fwnode_release;\n\t\t}\n\n\t\tpriv->leds_active |= BIT(reg);\n\n\t\tled->index = reg;\n\t\tled->priv = priv;\n\n\t\tret = mt6370_init_led_properties(dev, led, &init_data);\n\t\tif (ret)\n\t\t\tgoto fwnode_release;\n\n\t\tret = mt6370_led_register(dev, led, &init_data);\n\t\tif (ret)\n\t\t\tgoto fwnode_release;\n\t}\n\n\treturn 0;\n\nfwnode_release:\n\tfwnode_handle_put(child);\n\treturn ret;\n}\n\nstatic const struct of_device_id mt6370_rgbled_device_table[] = {\n\t{ .compatible = \"mediatek,mt6370-indicator\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mt6370_rgbled_device_table);\n\nstatic struct platform_driver mt6370_rgbled_driver = {\n\t.driver = {\n\t\t.name = \"mt6370-indicator\",\n\t\t.of_match_table = mt6370_rgbled_device_table,\n\t},\n\t.probe = mt6370_leds_probe,\n};\nmodule_platform_driver(mt6370_rgbled_driver);\n\nMODULE_AUTHOR(\"Alice Chen <alice_chen@richtek.com>\");\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"MediaTek MT6370 RGB LED Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}