{
  "module_name": "leds-qcom-lpg.c",
  "hash_id": "5fd3aa950375ca0e50726bd9634f2f1845295529373cc2b4125b163bc58f13b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/rgb/leds-qcom-lpg.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/led-class-multicolor.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define LPG_SUBTYPE_REG\t\t0x05\n#define  LPG_SUBTYPE_LPG\t0x2\n#define  LPG_SUBTYPE_PWM\t0xb\n#define  LPG_SUBTYPE_HI_RES_PWM\t0xc\n#define  LPG_SUBTYPE_LPG_LITE\t0x11\n#define LPG_PATTERN_CONFIG_REG\t0x40\n#define LPG_SIZE_CLK_REG\t0x41\n#define  PWM_CLK_SELECT_MASK\tGENMASK(1, 0)\n#define  PWM_CLK_SELECT_HI_RES_MASK\tGENMASK(2, 0)\n#define  PWM_SIZE_HI_RES_MASK\tGENMASK(6, 4)\n#define LPG_PREDIV_CLK_REG\t0x42\n#define  PWM_FREQ_PRE_DIV_MASK\tGENMASK(6, 5)\n#define  PWM_FREQ_EXP_MASK\tGENMASK(2, 0)\n#define PWM_TYPE_CONFIG_REG\t0x43\n#define PWM_VALUE_REG\t\t0x44\n#define PWM_ENABLE_CONTROL_REG\t0x46\n#define PWM_SYNC_REG\t\t0x47\n#define LPG_RAMP_DURATION_REG\t0x50\n#define LPG_HI_PAUSE_REG\t0x52\n#define LPG_LO_PAUSE_REG\t0x54\n#define LPG_HI_IDX_REG\t\t0x56\n#define LPG_LO_IDX_REG\t\t0x57\n#define PWM_SEC_ACCESS_REG\t0xd0\n#define PWM_DTEST_REG(x)\t(0xe2 + (x) - 1)\n\n#define TRI_LED_SRC_SEL\t\t0x45\n#define TRI_LED_EN_CTL\t\t0x46\n#define TRI_LED_ATC_CTL\t\t0x47\n\n#define LPG_LUT_REG(x)\t\t(0x40 + (x) * 2)\n#define RAMP_CONTROL_REG\t0xc8\n\n#define LPG_RESOLUTION_9BIT\tBIT(9)\n#define LPG_RESOLUTION_15BIT\tBIT(15)\n#define LPG_MAX_M\t\t7\n#define LPG_MAX_PREDIV\t\t6\n\nstruct lpg_channel;\nstruct lpg_data;\n\n \nstruct lpg {\n\tstruct device *dev;\n\tstruct regmap *map;\n\n\tstruct mutex lock;\n\n\tstruct pwm_chip pwm;\n\n\tconst struct lpg_data *data;\n\n\tu32 lut_base;\n\tu32 lut_size;\n\tunsigned long *lut_bitmap;\n\n\tu32 triled_base;\n\tu32 triled_src;\n\tbool triled_has_atc_ctl;\n\tbool triled_has_src_sel;\n\n\tstruct lpg_channel *channels;\n\tunsigned int num_channels;\n};\n\n \nstruct lpg_channel {\n\tstruct lpg *lpg;\n\n\tu32 base;\n\tunsigned int triled_mask;\n\tunsigned int lut_mask;\n\tunsigned int subtype;\n\n\tbool in_use;\n\n\tint color;\n\n\tu32 dtest_line;\n\tu32 dtest_value;\n\n\tu16 pwm_value;\n\tbool enabled;\n\n\tu64 period;\n\tunsigned int clk_sel;\n\tunsigned int pre_div_sel;\n\tunsigned int pre_div_exp;\n\tunsigned int pwm_resolution_sel;\n\n\tbool ramp_enabled;\n\tbool ramp_ping_pong;\n\tbool ramp_oneshot;\n\tbool ramp_reverse;\n\tunsigned short ramp_tick_ms;\n\tunsigned long ramp_lo_pause_ms;\n\tunsigned long ramp_hi_pause_ms;\n\n\tunsigned int pattern_lo_idx;\n\tunsigned int pattern_hi_idx;\n};\n\n \nstruct lpg_led {\n\tstruct lpg *lpg;\n\n\tstruct led_classdev cdev;\n\tstruct led_classdev_mc mcdev;\n\n\tunsigned int num_channels;\n\tstruct lpg_channel *channels[];\n};\n\n \nstruct lpg_channel_data {\n\tunsigned int base;\n\tu8 triled_mask;\n};\n\n \nstruct lpg_data {\n\tunsigned int lut_base;\n\tunsigned int lut_size;\n\tunsigned int triled_base;\n\tbool triled_has_atc_ctl;\n\tbool triled_has_src_sel;\n\tint num_channels;\n\tconst struct lpg_channel_data *channels;\n};\n\nstatic int triled_set(struct lpg *lpg, unsigned int mask, unsigned int enable)\n{\n\t \n\tif (!lpg->triled_base)\n\t\treturn 0;\n\n\treturn regmap_update_bits(lpg->map, lpg->triled_base + TRI_LED_EN_CTL,\n\t\t\t\t  mask, enable);\n}\n\nstatic int lpg_lut_store(struct lpg *lpg, struct led_pattern *pattern,\n\t\t\t size_t len, unsigned int *lo_idx, unsigned int *hi_idx)\n{\n\tunsigned int idx;\n\tu16 val;\n\tint i;\n\n\tidx = bitmap_find_next_zero_area(lpg->lut_bitmap, lpg->lut_size,\n\t\t\t\t\t 0, len, 0);\n\tif (idx >= lpg->lut_size)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < len; i++) {\n\t\tval = pattern[i].brightness;\n\n\t\tregmap_bulk_write(lpg->map, lpg->lut_base + LPG_LUT_REG(idx + i),\n\t\t\t\t  &val, sizeof(val));\n\t}\n\n\tbitmap_set(lpg->lut_bitmap, idx, len);\n\n\t*lo_idx = idx;\n\t*hi_idx = idx + len - 1;\n\n\treturn 0;\n}\n\nstatic void lpg_lut_free(struct lpg *lpg, unsigned int lo_idx, unsigned int hi_idx)\n{\n\tint len;\n\n\tlen = hi_idx - lo_idx + 1;\n\tif (len == 1)\n\t\treturn;\n\n\tbitmap_clear(lpg->lut_bitmap, lo_idx, len);\n}\n\nstatic int lpg_lut_sync(struct lpg *lpg, unsigned int mask)\n{\n\treturn regmap_write(lpg->map, lpg->lut_base + RAMP_CONTROL_REG, mask);\n}\n\nstatic const unsigned int lpg_clk_rates[] = {0, 1024, 32768, 19200000};\nstatic const unsigned int lpg_clk_rates_hi_res[] = {0, 1024, 32768, 19200000, 76800000};\nstatic const unsigned int lpg_pre_divs[] = {1, 3, 5, 6};\nstatic const unsigned int lpg_pwm_resolution[] =  {9};\nstatic const unsigned int lpg_pwm_resolution_hi_res[] =  {8, 9, 10, 11, 12, 13, 14, 15};\n\nstatic int lpg_calc_freq(struct lpg_channel *chan, uint64_t period)\n{\n\tunsigned int i, pwm_resolution_count, best_pwm_resolution_sel = 0;\n\tconst unsigned int *clk_rate_arr, *pwm_resolution_arr;\n\tunsigned int clk_sel, clk_len, best_clk = 0;\n\tunsigned int div, best_div = 0;\n\tunsigned int m, best_m = 0;\n\tunsigned int resolution;\n\tunsigned int error;\n\tunsigned int best_err = UINT_MAX;\n\tu64 max_period, min_period;\n\tu64 best_period = 0;\n\tu64 max_res;\n\n\t \n\n\tif (chan->subtype == LPG_SUBTYPE_HI_RES_PWM) {\n\t\tclk_rate_arr = lpg_clk_rates_hi_res;\n\t\tclk_len = ARRAY_SIZE(lpg_clk_rates_hi_res);\n\t\tpwm_resolution_arr = lpg_pwm_resolution_hi_res;\n\t\tpwm_resolution_count = ARRAY_SIZE(lpg_pwm_resolution_hi_res);\n\t\tmax_res = LPG_RESOLUTION_15BIT;\n\t} else {\n\t\tclk_rate_arr = lpg_clk_rates;\n\t\tclk_len = ARRAY_SIZE(lpg_clk_rates);\n\t\tpwm_resolution_arr = lpg_pwm_resolution;\n\t\tpwm_resolution_count = ARRAY_SIZE(lpg_pwm_resolution);\n\t\tmax_res = LPG_RESOLUTION_9BIT;\n\t}\n\n\tmin_period = div64_u64((u64)NSEC_PER_SEC * (1 << pwm_resolution_arr[0]),\n\t\t\t       clk_rate_arr[clk_len - 1]);\n\tif (period <= min_period)\n\t\treturn -EINVAL;\n\n\t \n\tmax_period = div64_u64((u64)NSEC_PER_SEC * max_res * LPG_MAX_PREDIV * (1 << LPG_MAX_M),\n\t\t\t       1024);\n\tif (period > max_period)\n\t\tperiod = max_period;\n\n\t \n\n\tfor (i = 0; i < pwm_resolution_count; i++) {\n\t\tresolution = 1 << pwm_resolution_arr[i];\n\t\tfor (clk_sel = 1; clk_sel < clk_len; clk_sel++) {\n\t\t\tu64 numerator = period * clk_rate_arr[clk_sel];\n\n\t\t\tfor (div = 0; div < ARRAY_SIZE(lpg_pre_divs); div++) {\n\t\t\t\tu64 denominator = (u64)NSEC_PER_SEC * lpg_pre_divs[div] *\n\t\t\t\t\t\t  resolution;\n\t\t\t\tu64 actual;\n\t\t\t\tu64 ratio;\n\n\t\t\t\tif (numerator < denominator)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tratio = div64_u64(numerator, denominator);\n\t\t\t\tm = ilog2(ratio);\n\t\t\t\tif (m > LPG_MAX_M)\n\t\t\t\t\tm = LPG_MAX_M;\n\n\t\t\t\tactual = DIV_ROUND_UP_ULL(denominator * (1 << m),\n\t\t\t\t\t\t\t  clk_rate_arr[clk_sel]);\n\t\t\t\terror = period - actual;\n\t\t\t\tif (error < best_err) {\n\t\t\t\t\tbest_err = error;\n\t\t\t\t\tbest_div = div;\n\t\t\t\t\tbest_m = m;\n\t\t\t\t\tbest_clk = clk_sel;\n\t\t\t\t\tbest_period = actual;\n\t\t\t\t\tbest_pwm_resolution_sel = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tchan->clk_sel = best_clk;\n\tchan->pre_div_sel = best_div;\n\tchan->pre_div_exp = best_m;\n\tchan->period = best_period;\n\tchan->pwm_resolution_sel = best_pwm_resolution_sel;\n\treturn 0;\n}\n\nstatic void lpg_calc_duty(struct lpg_channel *chan, uint64_t duty)\n{\n\tunsigned int max;\n\tunsigned int val;\n\tunsigned int clk_rate;\n\n\tif (chan->subtype == LPG_SUBTYPE_HI_RES_PWM) {\n\t\tmax = LPG_RESOLUTION_15BIT - 1;\n\t\tclk_rate = lpg_clk_rates_hi_res[chan->clk_sel];\n\t} else {\n\t\tmax = LPG_RESOLUTION_9BIT - 1;\n\t\tclk_rate = lpg_clk_rates[chan->clk_sel];\n\t}\n\n\tval = div64_u64(duty * clk_rate,\n\t\t\t(u64)NSEC_PER_SEC * lpg_pre_divs[chan->pre_div_sel] * (1 << chan->pre_div_exp));\n\n\tchan->pwm_value = min(val, max);\n}\n\nstatic void lpg_apply_freq(struct lpg_channel *chan)\n{\n\tunsigned long val;\n\tstruct lpg *lpg = chan->lpg;\n\n\tif (!chan->enabled)\n\t\treturn;\n\n\tval = chan->clk_sel;\n\n\t \n\tswitch (chan->subtype) {\n\tcase LPG_SUBTYPE_LPG:\n\t\tval |= GENMASK(5, 4);\n\t\tbreak;\n\tcase LPG_SUBTYPE_PWM:\n\t\tval |= BIT(2);\n\t\tbreak;\n\tcase LPG_SUBTYPE_HI_RES_PWM:\n\t\tval |= FIELD_PREP(PWM_SIZE_HI_RES_MASK, chan->pwm_resolution_sel);\n\t\tbreak;\n\tcase LPG_SUBTYPE_LPG_LITE:\n\tdefault:\n\t\tval |= BIT(4);\n\t\tbreak;\n\t}\n\n\tregmap_write(lpg->map, chan->base + LPG_SIZE_CLK_REG, val);\n\n\tval = FIELD_PREP(PWM_FREQ_PRE_DIV_MASK, chan->pre_div_sel) |\n\t      FIELD_PREP(PWM_FREQ_EXP_MASK, chan->pre_div_exp);\n\tregmap_write(lpg->map, chan->base + LPG_PREDIV_CLK_REG, val);\n}\n\n#define LPG_ENABLE_GLITCH_REMOVAL\tBIT(5)\n\nstatic void lpg_enable_glitch(struct lpg_channel *chan)\n{\n\tstruct lpg *lpg = chan->lpg;\n\n\tregmap_update_bits(lpg->map, chan->base + PWM_TYPE_CONFIG_REG,\n\t\t\t   LPG_ENABLE_GLITCH_REMOVAL, 0);\n}\n\nstatic void lpg_disable_glitch(struct lpg_channel *chan)\n{\n\tstruct lpg *lpg = chan->lpg;\n\n\tregmap_update_bits(lpg->map, chan->base + PWM_TYPE_CONFIG_REG,\n\t\t\t   LPG_ENABLE_GLITCH_REMOVAL,\n\t\t\t   LPG_ENABLE_GLITCH_REMOVAL);\n}\n\nstatic void lpg_apply_pwm_value(struct lpg_channel *chan)\n{\n\tstruct lpg *lpg = chan->lpg;\n\tu16 val = chan->pwm_value;\n\n\tif (!chan->enabled)\n\t\treturn;\n\n\tregmap_bulk_write(lpg->map, chan->base + PWM_VALUE_REG, &val, sizeof(val));\n}\n\n#define LPG_PATTERN_CONFIG_LO_TO_HI\tBIT(4)\n#define LPG_PATTERN_CONFIG_REPEAT\tBIT(3)\n#define LPG_PATTERN_CONFIG_TOGGLE\tBIT(2)\n#define LPG_PATTERN_CONFIG_PAUSE_HI\tBIT(1)\n#define LPG_PATTERN_CONFIG_PAUSE_LO\tBIT(0)\n\nstatic void lpg_apply_lut_control(struct lpg_channel *chan)\n{\n\tstruct lpg *lpg = chan->lpg;\n\tunsigned int hi_pause;\n\tunsigned int lo_pause;\n\tunsigned int conf = 0;\n\tunsigned int lo_idx = chan->pattern_lo_idx;\n\tunsigned int hi_idx = chan->pattern_hi_idx;\n\tu16 step = chan->ramp_tick_ms;\n\n\tif (!chan->ramp_enabled || chan->pattern_lo_idx == chan->pattern_hi_idx)\n\t\treturn;\n\n\thi_pause = DIV_ROUND_UP(chan->ramp_hi_pause_ms, step);\n\tlo_pause = DIV_ROUND_UP(chan->ramp_lo_pause_ms, step);\n\n\tif (!chan->ramp_reverse)\n\t\tconf |= LPG_PATTERN_CONFIG_LO_TO_HI;\n\tif (!chan->ramp_oneshot)\n\t\tconf |= LPG_PATTERN_CONFIG_REPEAT;\n\tif (chan->ramp_ping_pong)\n\t\tconf |= LPG_PATTERN_CONFIG_TOGGLE;\n\tif (chan->ramp_hi_pause_ms)\n\t\tconf |= LPG_PATTERN_CONFIG_PAUSE_HI;\n\tif (chan->ramp_lo_pause_ms)\n\t\tconf |= LPG_PATTERN_CONFIG_PAUSE_LO;\n\n\tregmap_write(lpg->map, chan->base + LPG_PATTERN_CONFIG_REG, conf);\n\tregmap_write(lpg->map, chan->base + LPG_HI_IDX_REG, hi_idx);\n\tregmap_write(lpg->map, chan->base + LPG_LO_IDX_REG, lo_idx);\n\n\tregmap_bulk_write(lpg->map, chan->base + LPG_RAMP_DURATION_REG, &step, sizeof(step));\n\tregmap_write(lpg->map, chan->base + LPG_HI_PAUSE_REG, hi_pause);\n\tregmap_write(lpg->map, chan->base + LPG_LO_PAUSE_REG, lo_pause);\n}\n\n#define LPG_ENABLE_CONTROL_OUTPUT\t\tBIT(7)\n#define LPG_ENABLE_CONTROL_BUFFER_TRISTATE\tBIT(5)\n#define LPG_ENABLE_CONTROL_SRC_PWM\t\tBIT(2)\n#define LPG_ENABLE_CONTROL_RAMP_GEN\t\tBIT(1)\n\nstatic void lpg_apply_control(struct lpg_channel *chan)\n{\n\tunsigned int ctrl;\n\tstruct lpg *lpg = chan->lpg;\n\n\tctrl = LPG_ENABLE_CONTROL_BUFFER_TRISTATE;\n\n\tif (chan->enabled)\n\t\tctrl |= LPG_ENABLE_CONTROL_OUTPUT;\n\n\tif (chan->pattern_lo_idx != chan->pattern_hi_idx)\n\t\tctrl |= LPG_ENABLE_CONTROL_RAMP_GEN;\n\telse\n\t\tctrl |= LPG_ENABLE_CONTROL_SRC_PWM;\n\n\tregmap_write(lpg->map, chan->base + PWM_ENABLE_CONTROL_REG, ctrl);\n\n\t \n\tif (chan->enabled)\n\t\tlpg_apply_pwm_value(chan);\n}\n\n#define LPG_SYNC_PWM\tBIT(0)\n\nstatic void lpg_apply_sync(struct lpg_channel *chan)\n{\n\tstruct lpg *lpg = chan->lpg;\n\n\tregmap_write(lpg->map, chan->base + PWM_SYNC_REG, LPG_SYNC_PWM);\n}\n\nstatic int lpg_parse_dtest(struct lpg *lpg)\n{\n\tstruct lpg_channel *chan;\n\tstruct device_node *np = lpg->dev->of_node;\n\tint count;\n\tint ret;\n\tint i;\n\n\tcount = of_property_count_u32_elems(np, \"qcom,dtest\");\n\tif (count == -EINVAL) {\n\t\treturn 0;\n\t} else if (count < 0) {\n\t\tret = count;\n\t\tgoto err_malformed;\n\t} else if (count != lpg->data->num_channels * 2) {\n\t\tdev_err(lpg->dev, \"qcom,dtest needs to be %d items\\n\",\n\t\t\tlpg->data->num_channels * 2);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < lpg->data->num_channels; i++) {\n\t\tchan = &lpg->channels[i];\n\n\t\tret = of_property_read_u32_index(np, \"qcom,dtest\", i * 2,\n\t\t\t\t\t\t &chan->dtest_line);\n\t\tif (ret)\n\t\t\tgoto err_malformed;\n\n\t\tret = of_property_read_u32_index(np, \"qcom,dtest\", i * 2 + 1,\n\t\t\t\t\t\t &chan->dtest_value);\n\t\tif (ret)\n\t\t\tgoto err_malformed;\n\t}\n\n\treturn 0;\n\nerr_malformed:\n\tdev_err(lpg->dev, \"malformed qcom,dtest\\n\");\n\treturn ret;\n}\n\nstatic void lpg_apply_dtest(struct lpg_channel *chan)\n{\n\tstruct lpg *lpg = chan->lpg;\n\n\tif (!chan->dtest_line)\n\t\treturn;\n\n\tregmap_write(lpg->map, chan->base + PWM_SEC_ACCESS_REG, 0xa5);\n\tregmap_write(lpg->map, chan->base + PWM_DTEST_REG(chan->dtest_line),\n\t\t     chan->dtest_value);\n}\n\nstatic void lpg_apply(struct lpg_channel *chan)\n{\n\tlpg_disable_glitch(chan);\n\tlpg_apply_freq(chan);\n\tlpg_apply_pwm_value(chan);\n\tlpg_apply_control(chan);\n\tlpg_apply_sync(chan);\n\tlpg_apply_lut_control(chan);\n\tlpg_enable_glitch(chan);\n}\n\nstatic void lpg_brightness_set(struct lpg_led *led, struct led_classdev *cdev,\n\t\t\t       struct mc_subled *subleds)\n{\n\tenum led_brightness brightness;\n\tstruct lpg_channel *chan;\n\tunsigned int triled_enabled = 0;\n\tunsigned int triled_mask = 0;\n\tunsigned int lut_mask = 0;\n\tunsigned int duty;\n\tstruct lpg *lpg = led->lpg;\n\tint i;\n\n\tfor (i = 0; i < led->num_channels; i++) {\n\t\tchan = led->channels[i];\n\t\tbrightness = subleds[i].brightness;\n\n\t\tif (brightness == LED_OFF) {\n\t\t\tchan->enabled = false;\n\t\t\tchan->ramp_enabled = false;\n\t\t} else if (chan->pattern_lo_idx != chan->pattern_hi_idx) {\n\t\t\tlpg_calc_freq(chan, NSEC_PER_MSEC);\n\n\t\t\tchan->enabled = true;\n\t\t\tchan->ramp_enabled = true;\n\n\t\t\tlut_mask |= chan->lut_mask;\n\t\t\ttriled_enabled |= chan->triled_mask;\n\t\t} else {\n\t\t\tlpg_calc_freq(chan, NSEC_PER_MSEC);\n\n\t\t\tduty = div_u64(brightness * chan->period, cdev->max_brightness);\n\t\t\tlpg_calc_duty(chan, duty);\n\t\t\tchan->enabled = true;\n\t\t\tchan->ramp_enabled = false;\n\n\t\t\ttriled_enabled |= chan->triled_mask;\n\t\t}\n\n\t\ttriled_mask |= chan->triled_mask;\n\n\t\tlpg_apply(chan);\n\t}\n\n\t \n\tif (triled_mask)\n\t\ttriled_set(lpg, triled_mask, triled_enabled);\n\n\t \n\tif (lut_mask)\n\t\tlpg_lut_sync(lpg, lut_mask);\n}\n\nstatic int lpg_brightness_single_set(struct led_classdev *cdev,\n\t\t\t\t     enum led_brightness value)\n{\n\tstruct lpg_led *led = container_of(cdev, struct lpg_led, cdev);\n\tstruct mc_subled info;\n\n\tmutex_lock(&led->lpg->lock);\n\n\tinfo.brightness = value;\n\tlpg_brightness_set(led, cdev, &info);\n\n\tmutex_unlock(&led->lpg->lock);\n\n\treturn 0;\n}\n\nstatic int lpg_brightness_mc_set(struct led_classdev *cdev,\n\t\t\t\t enum led_brightness value)\n{\n\tstruct led_classdev_mc *mc = lcdev_to_mccdev(cdev);\n\tstruct lpg_led *led = container_of(mc, struct lpg_led, mcdev);\n\n\tmutex_lock(&led->lpg->lock);\n\n\tled_mc_calc_color_components(mc, value);\n\tlpg_brightness_set(led, cdev, mc->subled_info);\n\n\tmutex_unlock(&led->lpg->lock);\n\n\treturn 0;\n}\n\nstatic int lpg_blink_set(struct lpg_led *led,\n\t\t\t unsigned long *delay_on, unsigned long *delay_off)\n{\n\tstruct lpg_channel *chan;\n\tunsigned int period;\n\tunsigned int triled_mask = 0;\n\tstruct lpg *lpg = led->lpg;\n\tu64 duty;\n\tint i;\n\n\tif (!*delay_on && !*delay_off) {\n\t\t*delay_on = 500;\n\t\t*delay_off = 500;\n\t}\n\n\tduty = *delay_on * NSEC_PER_MSEC;\n\tperiod = (*delay_on + *delay_off) * NSEC_PER_MSEC;\n\n\tfor (i = 0; i < led->num_channels; i++) {\n\t\tchan = led->channels[i];\n\n\t\tlpg_calc_freq(chan, period);\n\t\tlpg_calc_duty(chan, duty);\n\n\t\tchan->enabled = true;\n\t\tchan->ramp_enabled = false;\n\n\t\ttriled_mask |= chan->triled_mask;\n\n\t\tlpg_apply(chan);\n\t}\n\n\t \n\ttriled_set(lpg, triled_mask, triled_mask);\n\n\tchan = led->channels[0];\n\tduty = div_u64(chan->pwm_value * chan->period, LPG_RESOLUTION_9BIT);\n\t*delay_on = div_u64(duty, NSEC_PER_MSEC);\n\t*delay_off = div_u64(chan->period - duty, NSEC_PER_MSEC);\n\n\treturn 0;\n}\n\nstatic int lpg_blink_single_set(struct led_classdev *cdev,\n\t\t\t\tunsigned long *delay_on, unsigned long *delay_off)\n{\n\tstruct lpg_led *led = container_of(cdev, struct lpg_led, cdev);\n\tint ret;\n\n\tmutex_lock(&led->lpg->lock);\n\n\tret = lpg_blink_set(led, delay_on, delay_off);\n\n\tmutex_unlock(&led->lpg->lock);\n\n\treturn ret;\n}\n\nstatic int lpg_blink_mc_set(struct led_classdev *cdev,\n\t\t\t    unsigned long *delay_on, unsigned long *delay_off)\n{\n\tstruct led_classdev_mc *mc = lcdev_to_mccdev(cdev);\n\tstruct lpg_led *led = container_of(mc, struct lpg_led, mcdev);\n\tint ret;\n\n\tmutex_lock(&led->lpg->lock);\n\n\tret = lpg_blink_set(led, delay_on, delay_off);\n\n\tmutex_unlock(&led->lpg->lock);\n\n\treturn ret;\n}\n\nstatic int lpg_pattern_set(struct lpg_led *led, struct led_pattern *led_pattern,\n\t\t\t   u32 len, int repeat)\n{\n\tstruct lpg_channel *chan;\n\tstruct lpg *lpg = led->lpg;\n\tstruct led_pattern *pattern;\n\tunsigned int brightness_a;\n\tunsigned int brightness_b;\n\tunsigned int actual_len;\n\tunsigned int hi_pause;\n\tunsigned int lo_pause;\n\tunsigned int delta_t;\n\tunsigned int lo_idx;\n\tunsigned int hi_idx;\n\tunsigned int i;\n\tbool ping_pong = true;\n\tint ret = -EINVAL;\n\n\t \n\tif (repeat != -1 && repeat != 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (len % 2)\n\t\treturn -EINVAL;\n\n\tpattern = kcalloc(len / 2, sizeof(*pattern), GFP_KERNEL);\n\tif (!pattern)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < len; i += 2) {\n\t\tif (led_pattern[i].brightness != led_pattern[i + 1].brightness)\n\t\t\tgoto out_free_pattern;\n\t\tif (led_pattern[i + 1].delta_t != 0)\n\t\t\tgoto out_free_pattern;\n\n\t\tpattern[i / 2].brightness = led_pattern[i].brightness;\n\t\tpattern[i / 2].delta_t = led_pattern[i].delta_t;\n\t}\n\n\tlen /= 2;\n\n\t \n\tif (len < 2)\n\t\tgoto out_free_pattern;\n\n\t \n\n\t \n\tfor (i = 0; i < len / 2; i++) {\n\t\tbrightness_a = pattern[i].brightness;\n\t\tbrightness_b = pattern[len - i - 1].brightness;\n\n\t\tif (brightness_a != brightness_b) {\n\t\t\tping_pong = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ping_pong)\n\t\tactual_len = (len + 1) / 2;\n\telse\n\t\tactual_len = len;\n\n\t \n\tdelta_t = pattern[1].delta_t;\n\tfor (i = 2; i < len; i++) {\n\t\tif (pattern[i].delta_t != delta_t) {\n\t\t\t \n\t\t\tif (i != actual_len - 1)\n\t\t\t\tgoto out_free_pattern;\n\t\t}\n\t}\n\n\t \n\tif (delta_t >= BIT(9))\n\t\tgoto out_free_pattern;\n\n\t \n\tlo_pause = pattern[0].delta_t;\n\thi_pause = pattern[actual_len - 1].delta_t;\n\n\tmutex_lock(&lpg->lock);\n\tret = lpg_lut_store(lpg, pattern, actual_len, &lo_idx, &hi_idx);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < led->num_channels; i++) {\n\t\tchan = led->channels[i];\n\n\t\tchan->ramp_tick_ms = delta_t;\n\t\tchan->ramp_ping_pong = ping_pong;\n\t\tchan->ramp_oneshot = repeat != -1;\n\n\t\tchan->ramp_lo_pause_ms = lo_pause;\n\t\tchan->ramp_hi_pause_ms = hi_pause;\n\n\t\tchan->pattern_lo_idx = lo_idx;\n\t\tchan->pattern_hi_idx = hi_idx;\n\t}\n\nout_unlock:\n\tmutex_unlock(&lpg->lock);\nout_free_pattern:\n\tkfree(pattern);\n\n\treturn ret;\n}\n\nstatic int lpg_pattern_single_set(struct led_classdev *cdev,\n\t\t\t\t  struct led_pattern *pattern, u32 len,\n\t\t\t\t  int repeat)\n{\n\tstruct lpg_led *led = container_of(cdev, struct lpg_led, cdev);\n\tint ret;\n\n\tret = lpg_pattern_set(led, pattern, len, repeat);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlpg_brightness_single_set(cdev, LED_FULL);\n\n\treturn 0;\n}\n\nstatic int lpg_pattern_mc_set(struct led_classdev *cdev,\n\t\t\t      struct led_pattern *pattern, u32 len,\n\t\t\t      int repeat)\n{\n\tstruct led_classdev_mc *mc = lcdev_to_mccdev(cdev);\n\tstruct lpg_led *led = container_of(mc, struct lpg_led, mcdev);\n\tint ret;\n\n\tret = lpg_pattern_set(led, pattern, len, repeat);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tled_mc_calc_color_components(mc, LED_FULL);\n\tlpg_brightness_set(led, cdev, mc->subled_info);\n\n\treturn 0;\n}\n\nstatic int lpg_pattern_clear(struct lpg_led *led)\n{\n\tstruct lpg_channel *chan;\n\tstruct lpg *lpg = led->lpg;\n\tint i;\n\n\tmutex_lock(&lpg->lock);\n\n\tchan = led->channels[0];\n\tlpg_lut_free(lpg, chan->pattern_lo_idx, chan->pattern_hi_idx);\n\n\tfor (i = 0; i < led->num_channels; i++) {\n\t\tchan = led->channels[i];\n\t\tchan->pattern_lo_idx = 0;\n\t\tchan->pattern_hi_idx = 0;\n\t}\n\n\tmutex_unlock(&lpg->lock);\n\n\treturn 0;\n}\n\nstatic int lpg_pattern_single_clear(struct led_classdev *cdev)\n{\n\tstruct lpg_led *led = container_of(cdev, struct lpg_led, cdev);\n\n\treturn lpg_pattern_clear(led);\n}\n\nstatic int lpg_pattern_mc_clear(struct led_classdev *cdev)\n{\n\tstruct led_classdev_mc *mc = lcdev_to_mccdev(cdev);\n\tstruct lpg_led *led = container_of(mc, struct lpg_led, mcdev);\n\n\treturn lpg_pattern_clear(led);\n}\n\nstatic int lpg_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct lpg *lpg = container_of(chip, struct lpg, pwm);\n\tstruct lpg_channel *chan = &lpg->channels[pwm->hwpwm];\n\n\treturn chan->in_use ? -EBUSY : 0;\n}\n\n \nstatic int lpg_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t const struct pwm_state *state)\n{\n\tstruct lpg *lpg = container_of(chip, struct lpg, pwm);\n\tstruct lpg_channel *chan = &lpg->channels[pwm->hwpwm];\n\tint ret = 0;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&lpg->lock);\n\n\tif (state->enabled) {\n\t\tret = lpg_calc_freq(chan, state->period);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\n\t\tlpg_calc_duty(chan, state->duty_cycle);\n\t}\n\tchan->enabled = state->enabled;\n\n\tlpg_apply(chan);\n\n\ttriled_set(lpg, chan->triled_mask, chan->enabled ? chan->triled_mask : 0);\n\nout_unlock:\n\tmutex_unlock(&lpg->lock);\n\n\treturn ret;\n}\n\nstatic int lpg_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     struct pwm_state *state)\n{\n\tstruct lpg *lpg = container_of(chip, struct lpg, pwm);\n\tstruct lpg_channel *chan = &lpg->channels[pwm->hwpwm];\n\tunsigned int resolution;\n\tunsigned int pre_div;\n\tunsigned int refclk;\n\tunsigned int val;\n\tunsigned int m;\n\tu16 pwm_value;\n\tint ret;\n\n\tret = regmap_read(lpg->map, chan->base + LPG_SIZE_CLK_REG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chan->subtype == LPG_SUBTYPE_HI_RES_PWM) {\n\t\trefclk = lpg_clk_rates_hi_res[FIELD_GET(PWM_CLK_SELECT_HI_RES_MASK, val)];\n\t\tresolution = lpg_pwm_resolution_hi_res[FIELD_GET(PWM_SIZE_HI_RES_MASK, val)];\n\t} else {\n\t\trefclk = lpg_clk_rates[FIELD_GET(PWM_CLK_SELECT_MASK, val)];\n\t\tresolution = 9;\n\t}\n\n\tif (refclk) {\n\t\tret = regmap_read(lpg->map, chan->base + LPG_PREDIV_CLK_REG, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpre_div = lpg_pre_divs[FIELD_GET(PWM_FREQ_PRE_DIV_MASK, val)];\n\t\tm = FIELD_GET(PWM_FREQ_EXP_MASK, val);\n\n\t\tret = regmap_bulk_read(lpg->map, chan->base + PWM_VALUE_REG, &pwm_value, sizeof(pwm_value));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstate->period = DIV_ROUND_UP_ULL((u64)NSEC_PER_SEC * (1 << resolution) *\n\t\t\t\t\t\t pre_div * (1 << m), refclk);\n\t\tstate->duty_cycle = DIV_ROUND_UP_ULL((u64)NSEC_PER_SEC * pwm_value * pre_div * (1 << m), refclk);\n\t} else {\n\t\tstate->period = 0;\n\t\tstate->duty_cycle = 0;\n\t}\n\n\tret = regmap_read(lpg->map, chan->base + PWM_ENABLE_CONTROL_REG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tstate->enabled = FIELD_GET(LPG_ENABLE_CONTROL_OUTPUT, val);\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\tif (state->duty_cycle > state->period)\n\t\tstate->duty_cycle = state->period;\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops lpg_pwm_ops = {\n\t.request = lpg_pwm_request,\n\t.apply = lpg_pwm_apply,\n\t.get_state = lpg_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic int lpg_add_pwm(struct lpg *lpg)\n{\n\tint ret;\n\n\tlpg->pwm.dev = lpg->dev;\n\tlpg->pwm.npwm = lpg->num_channels;\n\tlpg->pwm.ops = &lpg_pwm_ops;\n\n\tret = pwmchip_add(&lpg->pwm);\n\tif (ret)\n\t\tdev_err(lpg->dev, \"failed to add PWM chip: ret %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int lpg_parse_channel(struct lpg *lpg, struct device_node *np,\n\t\t\t     struct lpg_channel **channel)\n{\n\tstruct lpg_channel *chan;\n\tu32 color = LED_COLOR_ID_GREEN;\n\tu32 reg;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"reg\", &reg);\n\tif (ret || !reg || reg > lpg->num_channels) {\n\t\tdev_err(lpg->dev, \"invalid \\\"reg\\\" of %pOFn\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tchan = &lpg->channels[reg - 1];\n\tchan->in_use = true;\n\n\tret = of_property_read_u32(np, \"color\", &color);\n\tif (ret < 0 && ret != -EINVAL) {\n\t\tdev_err(lpg->dev, \"failed to parse \\\"color\\\" of %pOF\\n\", np);\n\t\treturn ret;\n\t}\n\n\tchan->color = color;\n\n\t*channel = chan;\n\n\treturn 0;\n}\n\nstatic int lpg_add_led(struct lpg *lpg, struct device_node *np)\n{\n\tstruct led_init_data init_data = {};\n\tstruct led_classdev *cdev;\n\tstruct device_node *child;\n\tstruct mc_subled *info;\n\tstruct lpg_led *led;\n\tconst char *state;\n\tint num_channels;\n\tu32 color = 0;\n\tint ret;\n\tint i;\n\n\tret = of_property_read_u32(np, \"color\", &color);\n\tif (ret < 0 && ret != -EINVAL) {\n\t\tdev_err(lpg->dev, \"failed to parse \\\"color\\\" of %pOF\\n\", np);\n\t\treturn ret;\n\t}\n\n\tif (color == LED_COLOR_ID_RGB)\n\t\tnum_channels = of_get_available_child_count(np);\n\telse\n\t\tnum_channels = 1;\n\n\tled = devm_kzalloc(lpg->dev, struct_size(led, channels, num_channels), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tled->lpg = lpg;\n\tled->num_channels = num_channels;\n\n\tif (color == LED_COLOR_ID_RGB) {\n\t\tinfo = devm_kcalloc(lpg->dev, num_channels, sizeof(*info), GFP_KERNEL);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\ti = 0;\n\t\tfor_each_available_child_of_node(np, child) {\n\t\t\tret = lpg_parse_channel(lpg, child, &led->channels[i]);\n\t\t\tif (ret < 0) {\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tinfo[i].color_index = led->channels[i]->color;\n\t\t\tinfo[i].intensity = 0;\n\t\t\ti++;\n\t\t}\n\n\t\tled->mcdev.subled_info = info;\n\t\tled->mcdev.num_colors = num_channels;\n\n\t\tcdev = &led->mcdev.led_cdev;\n\t\tcdev->brightness_set_blocking = lpg_brightness_mc_set;\n\t\tcdev->blink_set = lpg_blink_mc_set;\n\n\t\t \n\t\tif (lpg->lut_base) {\n\t\t\tcdev->pattern_set = lpg_pattern_mc_set;\n\t\t\tcdev->pattern_clear = lpg_pattern_mc_clear;\n\t\t}\n\t} else {\n\t\tret = lpg_parse_channel(lpg, np, &led->channels[0]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcdev = &led->cdev;\n\t\tcdev->brightness_set_blocking = lpg_brightness_single_set;\n\t\tcdev->blink_set = lpg_blink_single_set;\n\n\t\t \n\t\tif (lpg->lut_base) {\n\t\t\tcdev->pattern_set = lpg_pattern_single_set;\n\t\t\tcdev->pattern_clear = lpg_pattern_single_clear;\n\t\t}\n\t}\n\n\tcdev->default_trigger = of_get_property(np, \"linux,default-trigger\", NULL);\n\tcdev->max_brightness = LPG_RESOLUTION_9BIT - 1;\n\n\tif (!of_property_read_string(np, \"default-state\", &state) &&\n\t    !strcmp(state, \"on\"))\n\t\tcdev->brightness = cdev->max_brightness;\n\telse\n\t\tcdev->brightness = LED_OFF;\n\n\tcdev->brightness_set_blocking(cdev, cdev->brightness);\n\n\tinit_data.fwnode = of_fwnode_handle(np);\n\n\tif (color == LED_COLOR_ID_RGB)\n\t\tret = devm_led_classdev_multicolor_register_ext(lpg->dev, &led->mcdev, &init_data);\n\telse\n\t\tret = devm_led_classdev_register_ext(lpg->dev, &led->cdev, &init_data);\n\tif (ret)\n\t\tdev_err(lpg->dev, \"unable to register %s\\n\", cdev->name);\n\n\treturn ret;\n}\n\nstatic int lpg_init_channels(struct lpg *lpg)\n{\n\tconst struct lpg_data *data = lpg->data;\n\tstruct lpg_channel *chan;\n\tint i;\n\n\tlpg->num_channels = data->num_channels;\n\tlpg->channels = devm_kcalloc(lpg->dev, data->num_channels,\n\t\t\t\t     sizeof(struct lpg_channel), GFP_KERNEL);\n\tif (!lpg->channels)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < data->num_channels; i++) {\n\t\tchan = &lpg->channels[i];\n\n\t\tchan->lpg = lpg;\n\t\tchan->base = data->channels[i].base;\n\t\tchan->triled_mask = data->channels[i].triled_mask;\n\t\tchan->lut_mask = BIT(i);\n\n\t\tregmap_read(lpg->map, chan->base + LPG_SUBTYPE_REG, &chan->subtype);\n\t}\n\n\treturn 0;\n}\n\nstatic int lpg_init_triled(struct lpg *lpg)\n{\n\tstruct device_node *np = lpg->dev->of_node;\n\tint ret;\n\n\t \n\tif (!lpg->data->triled_base)\n\t\treturn 0;\n\n\tlpg->triled_base = lpg->data->triled_base;\n\tlpg->triled_has_atc_ctl = lpg->data->triled_has_atc_ctl;\n\tlpg->triled_has_src_sel = lpg->data->triled_has_src_sel;\n\n\tif (lpg->triled_has_src_sel) {\n\t\tret = of_property_read_u32(np, \"qcom,power-source\", &lpg->triled_src);\n\t\tif (ret || lpg->triled_src == 2 || lpg->triled_src > 3) {\n\t\t\tdev_err(lpg->dev, \"invalid power source\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (lpg->triled_has_atc_ctl)\n\t\tregmap_write(lpg->map, lpg->triled_base + TRI_LED_ATC_CTL, 0);\n\n\t \n\tif (lpg->triled_has_src_sel)\n\t\tregmap_write(lpg->map, lpg->triled_base + TRI_LED_SRC_SEL, lpg->triled_src);\n\n\t \n\tregmap_write(lpg->map, lpg->triled_base + TRI_LED_EN_CTL, 0);\n\n\treturn 0;\n}\n\nstatic int lpg_init_lut(struct lpg *lpg)\n{\n\tconst struct lpg_data *data = lpg->data;\n\n\tif (!data->lut_base)\n\t\treturn 0;\n\n\tlpg->lut_base = data->lut_base;\n\tlpg->lut_size = data->lut_size;\n\n\tlpg->lut_bitmap = devm_bitmap_zalloc(lpg->dev, lpg->lut_size, GFP_KERNEL);\n\tif (!lpg->lut_bitmap)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int lpg_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np;\n\tstruct lpg *lpg;\n\tint ret;\n\tint i;\n\n\tlpg = devm_kzalloc(&pdev->dev, sizeof(*lpg), GFP_KERNEL);\n\tif (!lpg)\n\t\treturn -ENOMEM;\n\n\tlpg->data = of_device_get_match_data(&pdev->dev);\n\tif (!lpg->data)\n\t\treturn -EINVAL;\n\n\tplatform_set_drvdata(pdev, lpg);\n\n\tlpg->dev = &pdev->dev;\n\tmutex_init(&lpg->lock);\n\n\tlpg->map = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!lpg->map)\n\t\treturn dev_err_probe(&pdev->dev, -ENXIO, \"parent regmap unavailable\\n\");\n\n\tret = lpg_init_channels(lpg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lpg_parse_dtest(lpg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lpg_init_triled(lpg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lpg_init_lut(lpg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor_each_available_child_of_node(pdev->dev.of_node, np) {\n\t\tret = lpg_add_led(lpg, np);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < lpg->num_channels; i++)\n\t\tlpg_apply_dtest(&lpg->channels[i]);\n\n\treturn lpg_add_pwm(lpg);\n}\n\nstatic int lpg_remove(struct platform_device *pdev)\n{\n\tstruct lpg *lpg = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&lpg->pwm);\n\n\treturn 0;\n}\n\nstatic const struct lpg_data pm8916_pwm_data = {\n\t.num_channels = 1,\n\t.channels = (const struct lpg_channel_data[]) {\n\t\t{ .base = 0xbc00 },\n\t},\n};\n\nstatic const struct lpg_data pm8941_lpg_data = {\n\t.lut_base = 0xb000,\n\t.lut_size = 64,\n\n\t.triled_base = 0xd000,\n\t.triled_has_atc_ctl = true,\n\t.triled_has_src_sel = true,\n\n\t.num_channels = 8,\n\t.channels = (const struct lpg_channel_data[]) {\n\t\t{ .base = 0xb100 },\n\t\t{ .base = 0xb200 },\n\t\t{ .base = 0xb300 },\n\t\t{ .base = 0xb400 },\n\t\t{ .base = 0xb500, .triled_mask = BIT(5) },\n\t\t{ .base = 0xb600, .triled_mask = BIT(6) },\n\t\t{ .base = 0xb700, .triled_mask = BIT(7) },\n\t\t{ .base = 0xb800 },\n\t},\n};\n\nstatic const struct lpg_data pm8994_lpg_data = {\n\t.lut_base = 0xb000,\n\t.lut_size = 64,\n\n\t.num_channels = 6,\n\t.channels = (const struct lpg_channel_data[]) {\n\t\t{ .base = 0xb100 },\n\t\t{ .base = 0xb200 },\n\t\t{ .base = 0xb300 },\n\t\t{ .base = 0xb400 },\n\t\t{ .base = 0xb500 },\n\t\t{ .base = 0xb600 },\n\t},\n};\n\n \nstatic const struct lpg_data pmi632_lpg_data = {\n\t.triled_base = 0xd000,\n\n\t.num_channels = 5,\n\t.channels = (const struct lpg_channel_data[]) {\n\t\t{ .base = 0xb300, .triled_mask = BIT(7) },\n\t\t{ .base = 0xb400, .triled_mask = BIT(6) },\n\t\t{ .base = 0xb500, .triled_mask = BIT(5) },\n\t\t{ .base = 0xb600 },\n\t\t{ .base = 0xb700 },\n\t},\n};\n\nstatic const struct lpg_data pmi8994_lpg_data = {\n\t.lut_base = 0xb000,\n\t.lut_size = 24,\n\n\t.triled_base = 0xd000,\n\t.triled_has_atc_ctl = true,\n\t.triled_has_src_sel = true,\n\n\t.num_channels = 4,\n\t.channels = (const struct lpg_channel_data[]) {\n\t\t{ .base = 0xb100, .triled_mask = BIT(5) },\n\t\t{ .base = 0xb200, .triled_mask = BIT(6) },\n\t\t{ .base = 0xb300, .triled_mask = BIT(7) },\n\t\t{ .base = 0xb400 },\n\t},\n};\n\nstatic const struct lpg_data pmi8998_lpg_data = {\n\t.lut_base = 0xb000,\n\t.lut_size = 49,\n\n\t.triled_base = 0xd000,\n\n\t.num_channels = 6,\n\t.channels = (const struct lpg_channel_data[]) {\n\t\t{ .base = 0xb100 },\n\t\t{ .base = 0xb200 },\n\t\t{ .base = 0xb300, .triled_mask = BIT(5) },\n\t\t{ .base = 0xb400, .triled_mask = BIT(6) },\n\t\t{ .base = 0xb500, .triled_mask = BIT(7) },\n\t\t{ .base = 0xb600 },\n\t},\n};\n\nstatic const struct lpg_data pm8150b_lpg_data = {\n\t.lut_base = 0xb000,\n\t.lut_size = 24,\n\n\t.triled_base = 0xd000,\n\n\t.num_channels = 2,\n\t.channels = (const struct lpg_channel_data[]) {\n\t\t{ .base = 0xb100, .triled_mask = BIT(7) },\n\t\t{ .base = 0xb200, .triled_mask = BIT(6) },\n\t},\n};\n\nstatic const struct lpg_data pm8150l_lpg_data = {\n\t.lut_base = 0xb000,\n\t.lut_size = 48,\n\n\t.triled_base = 0xd000,\n\n\t.num_channels = 5,\n\t.channels = (const struct lpg_channel_data[]) {\n\t\t{ .base = 0xb100, .triled_mask = BIT(7) },\n\t\t{ .base = 0xb200, .triled_mask = BIT(6) },\n\t\t{ .base = 0xb300, .triled_mask = BIT(5) },\n\t\t{ .base = 0xbc00 },\n\t\t{ .base = 0xbd00 },\n\n\t},\n};\n\nstatic const struct lpg_data pm8350c_pwm_data = {\n\t.triled_base = 0xef00,\n\n\t.num_channels = 4,\n\t.channels = (const struct lpg_channel_data[]) {\n\t\t{ .base = 0xe800, .triled_mask = BIT(7) },\n\t\t{ .base = 0xe900, .triled_mask = BIT(6) },\n\t\t{ .base = 0xea00, .triled_mask = BIT(5) },\n\t\t{ .base = 0xeb00 },\n\t},\n};\n\nstatic const struct lpg_data pmk8550_pwm_data = {\n\t.num_channels = 2,\n\t.channels = (const struct lpg_channel_data[]) {\n\t\t{ .base = 0xe800 },\n\t\t{ .base = 0xe900 },\n\t},\n};\n\nstatic const struct of_device_id lpg_of_table[] = {\n\t{ .compatible = \"qcom,pm8150b-lpg\", .data = &pm8150b_lpg_data },\n\t{ .compatible = \"qcom,pm8150l-lpg\", .data = &pm8150l_lpg_data },\n\t{ .compatible = \"qcom,pm8350c-pwm\", .data = &pm8350c_pwm_data },\n\t{ .compatible = \"qcom,pm8916-pwm\", .data = &pm8916_pwm_data },\n\t{ .compatible = \"qcom,pm8941-lpg\", .data = &pm8941_lpg_data },\n\t{ .compatible = \"qcom,pm8994-lpg\", .data = &pm8994_lpg_data },\n\t{ .compatible = \"qcom,pmi632-lpg\", .data = &pmi632_lpg_data },\n\t{ .compatible = \"qcom,pmi8994-lpg\", .data = &pmi8994_lpg_data },\n\t{ .compatible = \"qcom,pmi8998-lpg\", .data = &pmi8998_lpg_data },\n\t{ .compatible = \"qcom,pmc8180c-lpg\", .data = &pm8150l_lpg_data },\n\t{ .compatible = \"qcom,pmk8550-pwm\", .data = &pmk8550_pwm_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lpg_of_table);\n\nstatic struct platform_driver lpg_driver = {\n\t.probe = lpg_probe,\n\t.remove = lpg_remove,\n\t.driver = {\n\t\t.name = \"qcom-spmi-lpg\",\n\t\t.of_match_table = lpg_of_table,\n\t},\n};\nmodule_platform_driver(lpg_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm LPG LED driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}