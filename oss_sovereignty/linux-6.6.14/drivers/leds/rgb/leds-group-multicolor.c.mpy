{
  "module_name": "leds-group-multicolor.c",
  "hash_id": "25627fcc932a56665842f96b6f0365baf6662b80ea7effdff7fb5c8f2089c516",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/rgb/leds-group-multicolor.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/leds.h>\n#include <linux/led-class-multicolor.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\nstruct leds_multicolor {\n\tstruct led_classdev_mc mc_cdev;\n\tstruct led_classdev **monochromatics;\n};\n\nstatic int leds_gmc_set(struct led_classdev *cdev, enum led_brightness brightness)\n{\n\tstruct led_classdev_mc *mc_cdev = lcdev_to_mccdev(cdev);\n\tstruct leds_multicolor *priv = container_of(mc_cdev, struct leds_multicolor, mc_cdev);\n\tconst unsigned int group_max_brightness = mc_cdev->led_cdev.max_brightness;\n\tint i;\n\n\tfor (i = 0; i < mc_cdev->num_colors; i++) {\n\t\tstruct led_classdev *mono = priv->monochromatics[i];\n\t\tconst unsigned int mono_max_brightness = mono->max_brightness;\n\t\tunsigned int intensity = mc_cdev->subled_info[i].intensity;\n\t\tint mono_brightness;\n\n\t\t \n\t\tmono_brightness = DIV_ROUND_CLOSEST(brightness * intensity * mono_max_brightness,\n\t\t\t\t\t\t    group_max_brightness * group_max_brightness);\n\n\t\tled_set_brightness(mono, mono_brightness);\n\t}\n\n\treturn 0;\n}\n\nstatic void restore_sysfs_write_access(void *data)\n{\n\tstruct led_classdev *led_cdev = data;\n\n\t \n\tmutex_lock(&led_cdev->led_access);\n\tled_sysfs_enable(led_cdev);\n\tmutex_unlock(&led_cdev->led_access);\n}\n\nstatic int leds_gmc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct led_init_data init_data = {};\n\tstruct led_classdev *cdev;\n\tstruct mc_subled *subled;\n\tstruct leds_multicolor *priv;\n\tunsigned int max_brightness = 0;\n\tint i, ret, count = 0;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tfor (;;) {\n\t\tstruct led_classdev *led_cdev;\n\n\t\tled_cdev = devm_of_led_get_optional(dev, count);\n\t\tif (IS_ERR(led_cdev))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(led_cdev), \"Unable to get LED #%d\",\n\t\t\t\t\t     count);\n\t\tif (!led_cdev)\n\t\t\tbreak;\n\n\t\tpriv->monochromatics = devm_krealloc_array(dev, priv->monochromatics,\n\t\t\t\t\tcount + 1, sizeof(*priv->monochromatics),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!priv->monochromatics)\n\t\t\treturn -ENOMEM;\n\n\t\tpriv->monochromatics[count] = led_cdev;\n\n\t\tmax_brightness = max(max_brightness, led_cdev->max_brightness);\n\n\t\tcount++;\n\t}\n\n\tsubled = devm_kcalloc(dev, count, sizeof(*subled), GFP_KERNEL);\n\tif (!subled)\n\t\treturn -ENOMEM;\n\tpriv->mc_cdev.subled_info = subled;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct led_classdev *led_cdev = priv->monochromatics[i];\n\n\t\tsubled[i].color_index = led_cdev->color;\n\n\t\t \n\t\tsubled[i].intensity = max_brightness;\n\t}\n\n\t \n\tcdev = &priv->mc_cdev.led_cdev;\n\tcdev->flags = LED_CORE_SUSPENDRESUME;\n\tcdev->brightness_set_blocking = leds_gmc_set;\n\tcdev->max_brightness = max_brightness;\n\tcdev->color = LED_COLOR_ID_MULTI;\n\tpriv->mc_cdev.num_colors = count;\n\n\tinit_data.fwnode = dev_fwnode(dev);\n\tret = devm_led_classdev_multicolor_register_ext(dev, &priv->mc_cdev, &init_data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to register multicolor LED for %s.\\n\",\n\t\t\t\t     cdev->name);\n\n\tret = leds_gmc_set(cdev, cdev->brightness);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to set LED value for %s.\", cdev->name);\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct led_classdev *led_cdev = priv->monochromatics[i];\n\n\t\t \n\t\tmutex_lock(&led_cdev->led_access);\n\t\tled_sysfs_disable(led_cdev);\n\t\tmutex_unlock(&led_cdev->led_access);\n\n\t\t \n\t\tdevm_add_action_or_reset(dev, restore_sysfs_write_access, led_cdev);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_leds_group_multicolor_match[] = {\n\t{ .compatible = \"leds-group-multicolor\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_leds_group_multicolor_match);\n\nstatic struct platform_driver leds_group_multicolor_driver = {\n\t.probe\t\t= leds_gmc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"leds_group_multicolor\",\n\t\t.of_match_table = of_leds_group_multicolor_match,\n\t}\n};\nmodule_platform_driver(leds_group_multicolor_driver);\n\nMODULE_AUTHOR(\"Jean-Jacques Hiblot <jjhiblot@traphandler.com>\");\nMODULE_DESCRIPTION(\"LEDs group multicolor driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:leds-group-multicolor\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}