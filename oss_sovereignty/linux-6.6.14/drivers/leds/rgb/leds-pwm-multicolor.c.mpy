{
  "module_name": "leds-pwm-multicolor.c",
  "hash_id": "2847de81118ca3ca85fa34f7492a38829f9723c0e51de94b0bd3a0bd22a264b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/rgb/leds-pwm-multicolor.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/led-class-multicolor.h>\n#include <linux/leds.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/pwm.h>\n\nstruct pwm_led {\n\tstruct pwm_device *pwm;\n\tstruct pwm_state state;\n\tbool active_low;\n};\n\nstruct pwm_mc_led {\n\tstruct led_classdev_mc mc_cdev;\n\tstruct mutex lock;\n\tstruct pwm_led leds[];\n};\n\nstatic int led_pwm_mc_set(struct led_classdev *cdev,\n\t\t\t  enum led_brightness brightness)\n{\n\tstruct led_classdev_mc *mc_cdev = lcdev_to_mccdev(cdev);\n\tstruct pwm_mc_led *priv = container_of(mc_cdev, struct pwm_mc_led, mc_cdev);\n\tunsigned long long duty;\n\tint ret = 0;\n\tint i;\n\n\tled_mc_calc_color_components(mc_cdev, brightness);\n\n\tmutex_lock(&priv->lock);\n\n\tfor (i = 0; i < mc_cdev->num_colors; i++) {\n\t\tduty = priv->leds[i].state.period;\n\t\tduty *= mc_cdev->subled_info[i].brightness;\n\t\tdo_div(duty, cdev->max_brightness);\n\n\t\tif (priv->leds[i].active_low)\n\t\t\tduty = priv->leds[i].state.period - duty;\n\n\t\tpriv->leds[i].state.duty_cycle = duty;\n\t\tpriv->leds[i].state.enabled = duty > 0;\n\t\tret = pwm_apply_state(priv->leds[i].pwm,\n\t\t\t\t      &priv->leds[i].state);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int iterate_subleds(struct device *dev, struct pwm_mc_led *priv,\n\t\t\t   struct fwnode_handle *mcnode)\n{\n\tstruct mc_subled *subled = priv->mc_cdev.subled_info;\n\tstruct fwnode_handle *fwnode;\n\tstruct pwm_led *pwmled;\n\tu32 color;\n\tint ret;\n\n\t \n\tfwnode_for_each_child_node(mcnode, fwnode) {\n\t\tpwmled = &priv->leds[priv->mc_cdev.num_colors];\n\t\tpwmled->pwm = devm_fwnode_pwm_get(dev, fwnode, NULL);\n\t\tif (IS_ERR(pwmled->pwm)) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(pwmled->pwm), \"unable to request PWM\\n\");\n\t\t\tgoto release_fwnode;\n\t\t}\n\t\tpwm_init_state(pwmled->pwm, &pwmled->state);\n\t\tpwmled->active_low = fwnode_property_read_bool(fwnode, \"active-low\");\n\n\t\tret = fwnode_property_read_u32(fwnode, \"color\", &color);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"cannot read color: %d\\n\", ret);\n\t\t\tgoto release_fwnode;\n\t\t}\n\n\t\tsubled[priv->mc_cdev.num_colors].color_index = color;\n\t\tpriv->mc_cdev.num_colors++;\n\t}\n\n\treturn 0;\n\nrelease_fwnode:\n\tfwnode_handle_put(fwnode);\n\treturn ret;\n}\n\nstatic int led_pwm_mc_probe(struct platform_device *pdev)\n{\n\tstruct fwnode_handle *mcnode, *fwnode;\n\tstruct led_init_data init_data = {};\n\tstruct led_classdev *cdev;\n\tstruct mc_subled *subled;\n\tstruct pwm_mc_led *priv;\n\tint count = 0;\n\tint ret = 0;\n\n\tmcnode = device_get_named_child_node(&pdev->dev, \"multi-led\");\n\tif (!mcnode)\n\t\treturn dev_err_probe(&pdev->dev, -ENODEV,\n\t\t\t\t     \"expected multi-led node\\n\");\n\n\t \n\tfwnode_for_each_child_node(mcnode, fwnode)\n\t\tcount++;\n\n\tpriv = devm_kzalloc(&pdev->dev, struct_size(priv, leds, count),\n\t\t\t    GFP_KERNEL);\n\tif (!priv) {\n\t\tret = -ENOMEM;\n\t\tgoto release_mcnode;\n\t}\n\tmutex_init(&priv->lock);\n\n\tsubled = devm_kcalloc(&pdev->dev, count, sizeof(*subled), GFP_KERNEL);\n\tif (!subled) {\n\t\tret = -ENOMEM;\n\t\tgoto release_mcnode;\n\t}\n\tpriv->mc_cdev.subled_info = subled;\n\n\t \n\tcdev = &priv->mc_cdev.led_cdev;\n\tfwnode_property_read_u32(mcnode, \"max-brightness\",\n\t\t\t\t &cdev->max_brightness);\n\tcdev->flags = LED_CORE_SUSPENDRESUME;\n\tcdev->brightness_set_blocking = led_pwm_mc_set;\n\n\tret = iterate_subleds(&pdev->dev, priv, mcnode);\n\tif (ret)\n\t\tgoto release_mcnode;\n\n\tinit_data.fwnode = mcnode;\n\tret = devm_led_classdev_multicolor_register_ext(&pdev->dev,\n\t\t\t\t\t\t\t&priv->mc_cdev,\n\t\t\t\t\t\t\t&init_data);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to register multicolor PWM led for %s: %d\\n\",\n\t\t\tcdev->name, ret);\n\t\tgoto release_mcnode;\n\t}\n\n\tret = led_pwm_mc_set(cdev, cdev->brightness);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"failed to set led PWM value for %s\\n\",\n\t\t\t\t     cdev->name);\n\n\tplatform_set_drvdata(pdev, priv);\n\treturn 0;\n\nrelease_mcnode:\n\tfwnode_handle_put(mcnode);\n\treturn ret;\n}\n\nstatic const struct of_device_id of_pwm_leds_mc_match[] = {\n\t{ .compatible = \"pwm-leds-multicolor\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_pwm_leds_mc_match);\n\nstatic struct platform_driver led_pwm_mc_driver = {\n\t.probe\t\t= led_pwm_mc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"leds_pwm_multicolor\",\n\t\t.of_match_table = of_pwm_leds_mc_match,\n\t},\n};\nmodule_platform_driver(led_pwm_mc_driver);\n\nMODULE_AUTHOR(\"Sven Schwermer <sven.schwermer@disruptive-technologies.com>\");\nMODULE_DESCRIPTION(\"multi-color PWM LED driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:leds-pwm-multicolor\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}