{
  "module_name": "leds-netxbig.c",
  "hash_id": "47906a6812e1656bd7ab9ad927ea0466a9f7c0c438b55fd852ff7a30b46b3d7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-netxbig.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/leds.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n\nstruct netxbig_gpio_ext {\n\tstruct gpio_desc **addr;\n\tint\t\tnum_addr;\n\tstruct gpio_desc **data;\n\tint\t\tnum_data;\n\tstruct gpio_desc *enable;\n};\n\nenum netxbig_led_mode {\n\tNETXBIG_LED_OFF,\n\tNETXBIG_LED_ON,\n\tNETXBIG_LED_SATA,\n\tNETXBIG_LED_TIMER1,\n\tNETXBIG_LED_TIMER2,\n\tNETXBIG_LED_MODE_NUM,\n};\n\n#define NETXBIG_LED_INVALID_MODE NETXBIG_LED_MODE_NUM\n\nstruct netxbig_led_timer {\n\tunsigned long\t\tdelay_on;\n\tunsigned long\t\tdelay_off;\n\tenum netxbig_led_mode\tmode;\n};\n\nstruct netxbig_led {\n\tconst char\t*name;\n\tconst char\t*default_trigger;\n\tint\t\tmode_addr;\n\tint\t\t*mode_val;\n\tint\t\tbright_addr;\n\tint\t\tbright_max;\n};\n\nstruct netxbig_led_platform_data {\n\tstruct netxbig_gpio_ext\t*gpio_ext;\n\tstruct netxbig_led_timer *timer;\n\tint\t\t\tnum_timer;\n\tstruct netxbig_led\t*leds;\n\tint\t\t\tnum_leds;\n};\n\n \n\nstatic DEFINE_SPINLOCK(gpio_ext_lock);\n\nstatic void gpio_ext_set_addr(struct netxbig_gpio_ext *gpio_ext, int addr)\n{\n\tint pin;\n\n\tfor (pin = 0; pin < gpio_ext->num_addr; pin++)\n\t\tgpiod_set_value(gpio_ext->addr[pin], (addr >> pin) & 1);\n}\n\nstatic void gpio_ext_set_data(struct netxbig_gpio_ext *gpio_ext, int data)\n{\n\tint pin;\n\n\tfor (pin = 0; pin < gpio_ext->num_data; pin++)\n\t\tgpiod_set_value(gpio_ext->data[pin], (data >> pin) & 1);\n}\n\nstatic void gpio_ext_enable_select(struct netxbig_gpio_ext *gpio_ext)\n{\n\t \n\tgpiod_set_value(gpio_ext->enable, 0);\n\tgpiod_set_value(gpio_ext->enable, 1);\n}\n\nstatic void gpio_ext_set_value(struct netxbig_gpio_ext *gpio_ext,\n\t\t\t       int addr, int value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gpio_ext_lock, flags);\n\tgpio_ext_set_addr(gpio_ext, addr);\n\tgpio_ext_set_data(gpio_ext, value);\n\tgpio_ext_enable_select(gpio_ext);\n\tspin_unlock_irqrestore(&gpio_ext_lock, flags);\n}\n\n \n\nstruct netxbig_led_data {\n\tstruct netxbig_gpio_ext\t*gpio_ext;\n\tstruct led_classdev\tcdev;\n\tint\t\t\tmode_addr;\n\tint\t\t\t*mode_val;\n\tint\t\t\tbright_addr;\n\tstruct\t\t\tnetxbig_led_timer *timer;\n\tint\t\t\tnum_timer;\n\tenum netxbig_led_mode\tmode;\n\tint\t\t\tsata;\n\tspinlock_t\t\tlock;\n};\n\nstatic int netxbig_led_get_timer_mode(enum netxbig_led_mode *mode,\n\t\t\t\t      unsigned long delay_on,\n\t\t\t\t      unsigned long delay_off,\n\t\t\t\t      struct netxbig_led_timer *timer,\n\t\t\t\t      int num_timer)\n{\n\tint i;\n\n\tfor (i = 0; i < num_timer; i++) {\n\t\tif (timer[i].delay_on == delay_on &&\n\t\t    timer[i].delay_off == delay_off) {\n\t\t\t*mode = timer[i].mode;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int netxbig_led_blink_set(struct led_classdev *led_cdev,\n\t\t\t\t unsigned long *delay_on,\n\t\t\t\t unsigned long *delay_off)\n{\n\tstruct netxbig_led_data *led_dat =\n\t\tcontainer_of(led_cdev, struct netxbig_led_data, cdev);\n\tenum netxbig_led_mode mode;\n\tint mode_val;\n\tint ret;\n\n\t \n\tret = netxbig_led_get_timer_mode(&mode, *delay_on, *delay_off,\n\t\t\t\t\t led_dat->timer, led_dat->num_timer);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmode_val = led_dat->mode_val[mode];\n\tif (mode_val == NETXBIG_LED_INVALID_MODE)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&led_dat->lock);\n\n\tgpio_ext_set_value(led_dat->gpio_ext, led_dat->mode_addr, mode_val);\n\tled_dat->mode = mode;\n\n\tspin_unlock_irq(&led_dat->lock);\n\n\treturn 0;\n}\n\nstatic void netxbig_led_set(struct led_classdev *led_cdev,\n\t\t\t    enum led_brightness value)\n{\n\tstruct netxbig_led_data *led_dat =\n\t\tcontainer_of(led_cdev, struct netxbig_led_data, cdev);\n\tenum netxbig_led_mode mode;\n\tint mode_val;\n\tint set_brightness = 1;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&led_dat->lock, flags);\n\n\tif (value == LED_OFF) {\n\t\tmode = NETXBIG_LED_OFF;\n\t\tset_brightness = 0;\n\t} else {\n\t\tif (led_dat->sata)\n\t\t\tmode = NETXBIG_LED_SATA;\n\t\telse if (led_dat->mode == NETXBIG_LED_OFF)\n\t\t\tmode = NETXBIG_LED_ON;\n\t\telse  \n\t\t\tmode = led_dat->mode;\n\t}\n\tmode_val = led_dat->mode_val[mode];\n\n\tgpio_ext_set_value(led_dat->gpio_ext, led_dat->mode_addr, mode_val);\n\tled_dat->mode = mode;\n\t \n\tif (set_brightness)\n\t\tgpio_ext_set_value(led_dat->gpio_ext,\n\t\t\t\t   led_dat->bright_addr, value);\n\n\tspin_unlock_irqrestore(&led_dat->lock, flags);\n}\n\nstatic ssize_t sata_store(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buff, size_t count)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct netxbig_led_data *led_dat =\n\t\tcontainer_of(led_cdev, struct netxbig_led_data, cdev);\n\tunsigned long enable;\n\tenum netxbig_led_mode mode;\n\tint mode_val;\n\tint ret;\n\n\tret = kstrtoul(buff, 10, &enable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tenable = !!enable;\n\n\tspin_lock_irq(&led_dat->lock);\n\n\tif (led_dat->sata == enable) {\n\t\tret = count;\n\t\tgoto exit_unlock;\n\t}\n\n\tif (led_dat->mode != NETXBIG_LED_ON &&\n\t    led_dat->mode != NETXBIG_LED_SATA)\n\t\tmode = led_dat->mode;  \n\telse if (enable)\n\t\tmode = NETXBIG_LED_SATA;\n\telse\n\t\tmode = NETXBIG_LED_ON;\n\n\tmode_val = led_dat->mode_val[mode];\n\tif (mode_val == NETXBIG_LED_INVALID_MODE) {\n\t\tret = -EINVAL;\n\t\tgoto exit_unlock;\n\t}\n\n\tgpio_ext_set_value(led_dat->gpio_ext, led_dat->mode_addr, mode_val);\n\tled_dat->mode = mode;\n\tled_dat->sata = enable;\n\n\tret = count;\n\nexit_unlock:\n\tspin_unlock_irq(&led_dat->lock);\n\n\treturn ret;\n}\n\nstatic ssize_t sata_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct netxbig_led_data *led_dat =\n\t\tcontainer_of(led_cdev, struct netxbig_led_data, cdev);\n\n\treturn sprintf(buf, \"%d\\n\", led_dat->sata);\n}\n\nstatic DEVICE_ATTR_RW(sata);\n\nstatic struct attribute *netxbig_led_attrs[] = {\n\t&dev_attr_sata.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(netxbig_led);\n\nstatic int create_netxbig_led(struct platform_device *pdev,\n\t\t\t      struct netxbig_led_platform_data *pdata,\n\t\t\t      struct netxbig_led_data *led_dat,\n\t\t\t      const struct netxbig_led *template)\n{\n\tspin_lock_init(&led_dat->lock);\n\tled_dat->gpio_ext = pdata->gpio_ext;\n\tled_dat->cdev.name = template->name;\n\tled_dat->cdev.default_trigger = template->default_trigger;\n\tled_dat->cdev.blink_set = netxbig_led_blink_set;\n\tled_dat->cdev.brightness_set = netxbig_led_set;\n\t \n\tled_dat->sata = 0;\n\tled_dat->cdev.brightness = LED_OFF;\n\tled_dat->cdev.max_brightness = template->bright_max;\n\tled_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;\n\tled_dat->mode_addr = template->mode_addr;\n\tled_dat->mode_val = template->mode_val;\n\tled_dat->bright_addr = template->bright_addr;\n\tled_dat->timer = pdata->timer;\n\tled_dat->num_timer = pdata->num_timer;\n\t \n\tif (led_dat->mode_val[NETXBIG_LED_SATA] != NETXBIG_LED_INVALID_MODE)\n\t\tled_dat->cdev.groups = netxbig_led_groups;\n\n\treturn devm_led_classdev_register(&pdev->dev, &led_dat->cdev);\n}\n\n \nstatic void netxbig_gpio_ext_remove(void *data)\n{\n\tstruct netxbig_gpio_ext *gpio_ext = data;\n\tint i;\n\n\tfor (i = 0; i < gpio_ext->num_addr; i++)\n\t\tgpiod_put(gpio_ext->addr[i]);\n\tfor (i = 0; i < gpio_ext->num_data; i++)\n\t\tgpiod_put(gpio_ext->data[i]);\n\tgpiod_put(gpio_ext->enable);\n}\n\n \nstatic int netxbig_gpio_ext_get(struct device *dev,\n\t\t\t\tstruct device *gpio_ext_dev,\n\t\t\t\tstruct netxbig_gpio_ext *gpio_ext)\n{\n\tstruct gpio_desc **addr, **data;\n\tint num_addr, num_data;\n\tstruct gpio_desc *gpiod;\n\tint ret;\n\tint i;\n\n\tret = gpiod_count(gpio_ext_dev, \"addr\");\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to count GPIOs in DT property addr-gpios\\n\");\n\t\treturn ret;\n\t}\n\tnum_addr = ret;\n\taddr = devm_kcalloc(dev, num_addr, sizeof(*addr), GFP_KERNEL);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < num_addr; i++) {\n\t\tgpiod = gpiod_get_index(gpio_ext_dev, \"addr\", i,\n\t\t\t\t\tGPIOD_OUT_LOW);\n\t\tif (IS_ERR(gpiod))\n\t\t\treturn PTR_ERR(gpiod);\n\t\tgpiod_set_consumer_name(gpiod, \"GPIO extension addr\");\n\t\taddr[i] = gpiod;\n\t}\n\tgpio_ext->addr = addr;\n\tgpio_ext->num_addr = num_addr;\n\n\tret = gpiod_count(gpio_ext_dev, \"data\");\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to count GPIOs in DT property data-gpios\\n\");\n\t\treturn ret;\n\t}\n\tnum_data = ret;\n\tdata = devm_kcalloc(dev, num_data, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_data; i++) {\n\t\tgpiod = gpiod_get_index(gpio_ext_dev, \"data\", i,\n\t\t\t\t\tGPIOD_OUT_LOW);\n\t\tif (IS_ERR(gpiod))\n\t\t\treturn PTR_ERR(gpiod);\n\t\tgpiod_set_consumer_name(gpiod, \"GPIO extension data\");\n\t\tdata[i] = gpiod;\n\t}\n\tgpio_ext->data = data;\n\tgpio_ext->num_data = num_data;\n\n\tgpiod = gpiod_get(gpio_ext_dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to get GPIO from DT property enable-gpio\\n\");\n\t\treturn PTR_ERR(gpiod);\n\t}\n\tgpiod_set_consumer_name(gpiod, \"GPIO extension enable\");\n\tgpio_ext->enable = gpiod;\n\n\treturn devm_add_action_or_reset(dev, netxbig_gpio_ext_remove, gpio_ext);\n}\n\nstatic int netxbig_leds_get_of_pdata(struct device *dev,\n\t\t\t\t     struct netxbig_led_platform_data *pdata)\n{\n\tstruct device_node *np = dev_of_node(dev);\n\tstruct device_node *gpio_ext_np;\n\tstruct platform_device *gpio_ext_pdev;\n\tstruct device *gpio_ext_dev;\n\tstruct device_node *child;\n\tstruct netxbig_gpio_ext *gpio_ext;\n\tstruct netxbig_led_timer *timers;\n\tstruct netxbig_led *leds, *led;\n\tint num_timers;\n\tint num_leds = 0;\n\tint ret;\n\tint i;\n\n\t \n\tgpio_ext_np = of_parse_phandle(np, \"gpio-ext\", 0);\n\tif (!gpio_ext_np) {\n\t\tdev_err(dev, \"Failed to get DT handle gpio-ext\\n\");\n\t\treturn -EINVAL;\n\t}\n\tgpio_ext_pdev = of_find_device_by_node(gpio_ext_np);\n\tif (!gpio_ext_pdev) {\n\t\tdev_err(dev, \"Failed to find platform device for gpio-ext\\n\");\n\t\treturn -ENODEV;\n\t}\n\tgpio_ext_dev = &gpio_ext_pdev->dev;\n\n\tgpio_ext = devm_kzalloc(dev, sizeof(*gpio_ext), GFP_KERNEL);\n\tif (!gpio_ext) {\n\t\tof_node_put(gpio_ext_np);\n\t\tret = -ENOMEM;\n\t\tgoto put_device;\n\t}\n\tret = netxbig_gpio_ext_get(dev, gpio_ext_dev, gpio_ext);\n\tof_node_put(gpio_ext_np);\n\tif (ret)\n\t\tgoto put_device;\n\tpdata->gpio_ext = gpio_ext;\n\n\t \n\tret = of_property_count_u32_elems(np, \"timers\");\n\tif (ret > 0) {\n\t\tif (ret % 3) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_device;\n\t\t}\n\n\t\tnum_timers = ret / 3;\n\t\ttimers = devm_kcalloc(dev, num_timers, sizeof(*timers),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!timers) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto put_device;\n\t\t}\n\t\tfor (i = 0; i < num_timers; i++) {\n\t\t\tu32 tmp;\n\n\t\t\tof_property_read_u32_index(np, \"timers\", 3 * i,\n\t\t\t\t\t\t   &timers[i].mode);\n\t\t\tif (timers[i].mode >= NETXBIG_LED_MODE_NUM) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto put_device;\n\t\t\t}\n\t\t\tof_property_read_u32_index(np, \"timers\",\n\t\t\t\t\t\t   3 * i + 1, &tmp);\n\t\t\ttimers[i].delay_on = tmp;\n\t\t\tof_property_read_u32_index(np, \"timers\",\n\t\t\t\t\t\t   3 * i + 2, &tmp);\n\t\t\ttimers[i].delay_off = tmp;\n\t\t}\n\t\tpdata->timer = timers;\n\t\tpdata->num_timer = num_timers;\n\t}\n\n\t \n\tnum_leds = of_get_available_child_count(np);\n\tif (!num_leds) {\n\t\tdev_err(dev, \"No LED subnodes found in DT\\n\");\n\t\tret = -ENODEV;\n\t\tgoto put_device;\n\t}\n\n\tleds = devm_kcalloc(dev, num_leds, sizeof(*leds), GFP_KERNEL);\n\tif (!leds) {\n\t\tret = -ENOMEM;\n\t\tgoto put_device;\n\t}\n\n\tled = leds;\n\tfor_each_available_child_of_node(np, child) {\n\t\tconst char *string;\n\t\tint *mode_val;\n\t\tint num_modes;\n\n\t\tret = of_property_read_u32(child, \"mode-addr\",\n\t\t\t\t\t   &led->mode_addr);\n\t\tif (ret)\n\t\t\tgoto err_node_put;\n\n\t\tret = of_property_read_u32(child, \"bright-addr\",\n\t\t\t\t\t   &led->bright_addr);\n\t\tif (ret)\n\t\t\tgoto err_node_put;\n\n\t\tret = of_property_read_u32(child, \"max-brightness\",\n\t\t\t\t\t   &led->bright_max);\n\t\tif (ret)\n\t\t\tgoto err_node_put;\n\n\t\tmode_val =\n\t\t\tdevm_kcalloc(dev,\n\t\t\t\t     NETXBIG_LED_MODE_NUM, sizeof(*mode_val),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!mode_val) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tfor (i = 0; i < NETXBIG_LED_MODE_NUM; i++)\n\t\t\tmode_val[i] = NETXBIG_LED_INVALID_MODE;\n\n\t\tret = of_property_count_u32_elems(child, \"mode-val\");\n\t\tif (ret < 0 || ret % 2) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_node_put;\n\t\t}\n\t\tnum_modes = ret / 2;\n\t\tif (num_modes > NETXBIG_LED_MODE_NUM) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tfor (i = 0; i < num_modes; i++) {\n\t\t\tint mode;\n\t\t\tint val;\n\n\t\t\tof_property_read_u32_index(child,\n\t\t\t\t\t\t   \"mode-val\", 2 * i, &mode);\n\t\t\tof_property_read_u32_index(child,\n\t\t\t\t\t\t   \"mode-val\", 2 * i + 1, &val);\n\t\t\tif (mode >= NETXBIG_LED_MODE_NUM) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_node_put;\n\t\t\t}\n\t\t\tmode_val[mode] = val;\n\t\t}\n\t\tled->mode_val = mode_val;\n\n\t\tif (!of_property_read_string(child, \"label\", &string))\n\t\t\tled->name = string;\n\t\telse\n\t\t\tled->name = child->name;\n\n\t\tif (!of_property_read_string(child,\n\t\t\t\t\t     \"linux,default-trigger\", &string))\n\t\t\tled->default_trigger = string;\n\n\t\tled++;\n\t}\n\n\tpdata->leds = leds;\n\tpdata->num_leds = num_leds;\n\n\treturn 0;\n\nerr_node_put:\n\tof_node_put(child);\nput_device:\n\tput_device(gpio_ext_dev);\n\treturn ret;\n}\n\nstatic const struct of_device_id of_netxbig_leds_match[] = {\n\t{ .compatible = \"lacie,netxbig-leds\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_netxbig_leds_match);\n\nstatic int netxbig_led_probe(struct platform_device *pdev)\n{\n\tstruct netxbig_led_platform_data *pdata;\n\tstruct netxbig_led_data *leds_data;\n\tint i;\n\tint ret;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\tret = netxbig_leds_get_of_pdata(&pdev->dev, pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tleds_data = devm_kcalloc(&pdev->dev,\n\t\t\t\t pdata->num_leds, sizeof(*leds_data),\n\t\t\t\t GFP_KERNEL);\n\tif (!leds_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pdata->num_leds; i++) {\n\t\tret = create_netxbig_led(pdev, pdata,\n\t\t\t\t\t &leds_data[i], &pdata->leds[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver netxbig_led_driver = {\n\t.probe\t\t= netxbig_led_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"leds-netxbig\",\n\t\t.of_match_table\t= of_netxbig_leds_match,\n\t},\n};\n\nmodule_platform_driver(netxbig_led_driver);\n\nMODULE_AUTHOR(\"Simon Guinot <sguinot@lacie.com>\");\nMODULE_DESCRIPTION(\"LED driver for LaCie xBig Network boards\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:leds-netxbig\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}