{
  "module_name": "led-triggers.c",
  "hash_id": "7f19614a9266856708bb8adb62de1ad0a176d7f098e012fa5c5a78655aa05404",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/led-triggers.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/device.h>\n#include <linux/timer.h>\n#include <linux/rwsem.h>\n#include <linux/leds.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include \"leds.h\"\n\n \nstatic DECLARE_RWSEM(triggers_list_lock);\nLIST_HEAD(trigger_list);\n\n  \n\nstatic inline bool\ntrigger_relevant(struct led_classdev *led_cdev, struct led_trigger *trig)\n{\n\treturn !trig->trigger_type || trig->trigger_type == led_cdev->trigger_type;\n}\n\nssize_t led_trigger_write(struct file *filp, struct kobject *kobj,\n\t\t\t  struct bin_attribute *bin_attr, char *buf,\n\t\t\t  loff_t pos, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_trigger *trig;\n\tint ret = count;\n\n\tmutex_lock(&led_cdev->led_access);\n\n\tif (led_sysfs_is_disabled(led_cdev)) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (sysfs_streq(buf, \"none\")) {\n\t\tled_trigger_remove(led_cdev);\n\t\tgoto unlock;\n\t}\n\n\tdown_read(&triggers_list_lock);\n\tlist_for_each_entry(trig, &trigger_list, next_trig) {\n\t\tif (sysfs_streq(buf, trig->name) && trigger_relevant(led_cdev, trig)) {\n\t\t\tdown_write(&led_cdev->trigger_lock);\n\t\t\tled_trigger_set(led_cdev, trig);\n\t\t\tup_write(&led_cdev->trigger_lock);\n\n\t\t\tup_read(&triggers_list_lock);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\t \n\tret = -EINVAL;\n\tup_read(&triggers_list_lock);\n\nunlock:\n\tmutex_unlock(&led_cdev->led_access);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(led_trigger_write);\n\n__printf(3, 4)\nstatic int led_trigger_snprintf(char *buf, ssize_t size, const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\tif (size <= 0)\n\t\ti = vsnprintf(NULL, 0, fmt, args);\n\telse\n\t\ti = vscnprintf(buf, size, fmt, args);\n\tva_end(args);\n\n\treturn i;\n}\n\nstatic int led_trigger_format(char *buf, size_t size,\n\t\t\t      struct led_classdev *led_cdev)\n{\n\tstruct led_trigger *trig;\n\tint len = led_trigger_snprintf(buf, size, \"%s\",\n\t\t\t\t       led_cdev->trigger ? \"none\" : \"[none]\");\n\n\tlist_for_each_entry(trig, &trigger_list, next_trig) {\n\t\tbool hit;\n\n\t\tif (!trigger_relevant(led_cdev, trig))\n\t\t\tcontinue;\n\n\t\thit = led_cdev->trigger && !strcmp(led_cdev->trigger->name, trig->name);\n\n\t\tlen += led_trigger_snprintf(buf + len, size - len,\n\t\t\t\t\t    \" %s%s%s\", hit ? \"[\" : \"\",\n\t\t\t\t\t    trig->name, hit ? \"]\" : \"\");\n\t}\n\n\tlen += led_trigger_snprintf(buf + len, size - len, \"\\n\");\n\n\treturn len;\n}\n\n \nssize_t led_trigger_read(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *attr, char *buf,\n\t\t\tloff_t pos, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tvoid *data;\n\tint len;\n\n\tdown_read(&triggers_list_lock);\n\tdown_read(&led_cdev->trigger_lock);\n\n\tlen = led_trigger_format(NULL, 0, led_cdev);\n\tdata = kvmalloc(len + 1, GFP_KERNEL);\n\tif (!data) {\n\t\tup_read(&led_cdev->trigger_lock);\n\t\tup_read(&triggers_list_lock);\n\t\treturn -ENOMEM;\n\t}\n\tlen = led_trigger_format(data, len + 1, led_cdev);\n\n\tup_read(&led_cdev->trigger_lock);\n\tup_read(&triggers_list_lock);\n\n\tlen = memory_read_from_buffer(buf, count, &pos, data, len);\n\n\tkvfree(data);\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(led_trigger_read);\n\n \nint led_trigger_set(struct led_classdev *led_cdev, struct led_trigger *trig)\n{\n\tchar *event = NULL;\n\tchar *envp[2];\n\tconst char *name;\n\tint ret;\n\n\tif (!led_cdev->trigger && !trig)\n\t\treturn 0;\n\n\tname = trig ? trig->name : \"none\";\n\tevent = kasprintf(GFP_KERNEL, \"TRIGGER=%s\", name);\n\n\t \n\tif (led_cdev->trigger) {\n\t\tspin_lock(&led_cdev->trigger->leddev_list_lock);\n\t\tlist_del_rcu(&led_cdev->trig_list);\n\t\tspin_unlock(&led_cdev->trigger->leddev_list_lock);\n\n\t\t \n\t\tsynchronize_rcu();\n\n\t\tcancel_work_sync(&led_cdev->set_brightness_work);\n\t\tled_stop_software_blink(led_cdev);\n\t\tif (led_cdev->trigger->deactivate)\n\t\t\tled_cdev->trigger->deactivate(led_cdev);\n\t\tdevice_remove_groups(led_cdev->dev, led_cdev->trigger->groups);\n\t\tled_cdev->trigger = NULL;\n\t\tled_cdev->trigger_data = NULL;\n\t\tled_cdev->activated = false;\n\t\tled_cdev->flags &= ~LED_INIT_DEFAULT_TRIGGER;\n\t\tled_set_brightness(led_cdev, LED_OFF);\n\t}\n\tif (trig) {\n\t\tspin_lock(&trig->leddev_list_lock);\n\t\tlist_add_tail_rcu(&led_cdev->trig_list, &trig->led_cdevs);\n\t\tspin_unlock(&trig->leddev_list_lock);\n\t\tled_cdev->trigger = trig;\n\n\t\tif (trig->activate)\n\t\t\tret = trig->activate(led_cdev);\n\t\telse\n\t\t\tret = 0;\n\n\t\tif (ret)\n\t\t\tgoto err_activate;\n\n\t\tret = device_add_groups(led_cdev->dev, trig->groups);\n\t\tif (ret) {\n\t\t\tdev_err(led_cdev->dev, \"Failed to add trigger attributes\\n\");\n\t\t\tgoto err_add_groups;\n\t\t}\n\t}\n\n\tif (event) {\n\t\tenvp[0] = event;\n\t\tenvp[1] = NULL;\n\t\tif (kobject_uevent_env(&led_cdev->dev->kobj, KOBJ_CHANGE, envp))\n\t\t\tdev_err(led_cdev->dev,\n\t\t\t\t\"%s: Error sending uevent\\n\", __func__);\n\t\tkfree(event);\n\t}\n\n\treturn 0;\n\nerr_add_groups:\n\n\tif (trig->deactivate)\n\t\ttrig->deactivate(led_cdev);\nerr_activate:\n\n\tspin_lock(&led_cdev->trigger->leddev_list_lock);\n\tlist_del_rcu(&led_cdev->trig_list);\n\tspin_unlock(&led_cdev->trigger->leddev_list_lock);\n\tsynchronize_rcu();\n\tled_cdev->trigger = NULL;\n\tled_cdev->trigger_data = NULL;\n\tled_set_brightness(led_cdev, LED_OFF);\n\tkfree(event);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(led_trigger_set);\n\nvoid led_trigger_remove(struct led_classdev *led_cdev)\n{\n\tdown_write(&led_cdev->trigger_lock);\n\tled_trigger_set(led_cdev, NULL);\n\tup_write(&led_cdev->trigger_lock);\n}\nEXPORT_SYMBOL_GPL(led_trigger_remove);\n\nvoid led_trigger_set_default(struct led_classdev *led_cdev)\n{\n\tstruct led_trigger *trig;\n\n\tif (!led_cdev->default_trigger)\n\t\treturn;\n\n\tdown_read(&triggers_list_lock);\n\tdown_write(&led_cdev->trigger_lock);\n\tlist_for_each_entry(trig, &trigger_list, next_trig) {\n\t\tif (!strcmp(led_cdev->default_trigger, trig->name) &&\n\t\t    trigger_relevant(led_cdev, trig)) {\n\t\t\tled_cdev->flags |= LED_INIT_DEFAULT_TRIGGER;\n\t\t\tled_trigger_set(led_cdev, trig);\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&led_cdev->trigger_lock);\n\tup_read(&triggers_list_lock);\n}\nEXPORT_SYMBOL_GPL(led_trigger_set_default);\n\nvoid led_trigger_rename_static(const char *name, struct led_trigger *trig)\n{\n\t \n\tBUG_ON(name == trig->name);\n\n\tdown_write(&triggers_list_lock);\n\t \n\tstrcpy((char *)trig->name, name);\n\tup_write(&triggers_list_lock);\n}\nEXPORT_SYMBOL_GPL(led_trigger_rename_static);\n\n \n\nint led_trigger_register(struct led_trigger *trig)\n{\n\tstruct led_classdev *led_cdev;\n\tstruct led_trigger *_trig;\n\n\tspin_lock_init(&trig->leddev_list_lock);\n\tINIT_LIST_HEAD(&trig->led_cdevs);\n\n\tdown_write(&triggers_list_lock);\n\t \n\tlist_for_each_entry(_trig, &trigger_list, next_trig) {\n\t\tif (!strcmp(_trig->name, trig->name) &&\n\t\t    (trig->trigger_type == _trig->trigger_type ||\n\t\t     !trig->trigger_type || !_trig->trigger_type)) {\n\t\t\tup_write(&triggers_list_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\t \n\tlist_add_tail(&trig->next_trig, &trigger_list);\n\tup_write(&triggers_list_lock);\n\n\t \n\tdown_read(&leds_list_lock);\n\tlist_for_each_entry(led_cdev, &leds_list, node) {\n\t\tdown_write(&led_cdev->trigger_lock);\n\t\tif (!led_cdev->trigger && led_cdev->default_trigger &&\n\t\t    !strcmp(led_cdev->default_trigger, trig->name) &&\n\t\t    trigger_relevant(led_cdev, trig)) {\n\t\t\tled_cdev->flags |= LED_INIT_DEFAULT_TRIGGER;\n\t\t\tled_trigger_set(led_cdev, trig);\n\t\t}\n\t\tup_write(&led_cdev->trigger_lock);\n\t}\n\tup_read(&leds_list_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(led_trigger_register);\n\nvoid led_trigger_unregister(struct led_trigger *trig)\n{\n\tstruct led_classdev *led_cdev;\n\n\tif (list_empty_careful(&trig->next_trig))\n\t\treturn;\n\n\t \n\tdown_write(&triggers_list_lock);\n\tlist_del_init(&trig->next_trig);\n\tup_write(&triggers_list_lock);\n\n\t \n\tdown_read(&leds_list_lock);\n\tlist_for_each_entry(led_cdev, &leds_list, node) {\n\t\tdown_write(&led_cdev->trigger_lock);\n\t\tif (led_cdev->trigger == trig)\n\t\t\tled_trigger_set(led_cdev, NULL);\n\t\tup_write(&led_cdev->trigger_lock);\n\t}\n\tup_read(&leds_list_lock);\n}\nEXPORT_SYMBOL_GPL(led_trigger_unregister);\n\nstatic void devm_led_trigger_release(struct device *dev, void *res)\n{\n\tled_trigger_unregister(*(struct led_trigger **)res);\n}\n\nint devm_led_trigger_register(struct device *dev,\n\t\t\t      struct led_trigger *trig)\n{\n\tstruct led_trigger **dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_led_trigger_release, sizeof(*dr),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\t*dr = trig;\n\n\trc = led_trigger_register(trig);\n\tif (rc)\n\t\tdevres_free(dr);\n\telse\n\t\tdevres_add(dev, dr);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(devm_led_trigger_register);\n\n \n\nvoid led_trigger_event(struct led_trigger *trig,\n\t\t\tenum led_brightness brightness)\n{\n\tstruct led_classdev *led_cdev;\n\n\tif (!trig)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(led_cdev, &trig->led_cdevs, trig_list)\n\t\tled_set_brightness(led_cdev, brightness);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(led_trigger_event);\n\nstatic void led_trigger_blink_setup(struct led_trigger *trig,\n\t\t\t     unsigned long delay_on,\n\t\t\t     unsigned long delay_off,\n\t\t\t     int oneshot,\n\t\t\t     int invert)\n{\n\tstruct led_classdev *led_cdev;\n\n\tif (!trig)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(led_cdev, &trig->led_cdevs, trig_list) {\n\t\tif (oneshot)\n\t\t\tled_blink_set_oneshot(led_cdev, &delay_on, &delay_off,\n\t\t\t\t\t      invert);\n\t\telse\n\t\t\tled_blink_set_nosleep(led_cdev, delay_on, delay_off);\n\t}\n\trcu_read_unlock();\n}\n\nvoid led_trigger_blink(struct led_trigger *trig,\n\t\t       unsigned long delay_on,\n\t\t       unsigned long delay_off)\n{\n\tled_trigger_blink_setup(trig, delay_on, delay_off, 0, 0);\n}\nEXPORT_SYMBOL_GPL(led_trigger_blink);\n\nvoid led_trigger_blink_oneshot(struct led_trigger *trig,\n\t\t\t       unsigned long delay_on,\n\t\t\t       unsigned long delay_off,\n\t\t\t       int invert)\n{\n\tled_trigger_blink_setup(trig, delay_on, delay_off, 1, invert);\n}\nEXPORT_SYMBOL_GPL(led_trigger_blink_oneshot);\n\nvoid led_trigger_register_simple(const char *name, struct led_trigger **tp)\n{\n\tstruct led_trigger *trig;\n\tint err;\n\n\ttrig = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);\n\n\tif (trig) {\n\t\ttrig->name = name;\n\t\terr = led_trigger_register(trig);\n\t\tif (err < 0) {\n\t\t\tkfree(trig);\n\t\t\ttrig = NULL;\n\t\t\tpr_warn(\"LED trigger %s failed to register (%d)\\n\",\n\t\t\t\tname, err);\n\t\t}\n\t} else {\n\t\tpr_warn(\"LED trigger %s failed to register (no memory)\\n\",\n\t\t\tname);\n\t}\n\t*tp = trig;\n}\nEXPORT_SYMBOL_GPL(led_trigger_register_simple);\n\nvoid led_trigger_unregister_simple(struct led_trigger *trig)\n{\n\tif (trig)\n\t\tled_trigger_unregister(trig);\n\tkfree(trig);\n}\nEXPORT_SYMBOL_GPL(led_trigger_unregister_simple);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}