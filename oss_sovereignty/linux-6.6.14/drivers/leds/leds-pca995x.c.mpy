{
  "module_name": "leds-pca995x.c",
  "hash_id": "efbe3df3d3d6353eef03da6350b7867d6997613bdeb3bfc51e261240b93f97c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-pca995x.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n \n#define PCA995X_MODE1\t\t\t0x00\n#define PCA995X_MODE2\t\t\t0x01\n#define PCA995X_LEDOUT0\t\t\t0x02\n#define PCA9955B_PWM0\t\t\t0x08\n#define PCA9952_PWM0\t\t\t0x0A\n#define PCA9952_IREFALL\t\t\t0x43\n#define PCA9955B_IREFALL\t\t0x45\n\n \n#define PCA995X_MODE1_CFG\t\t0x00\n\n \n#define PCA995X_LED_OFF\t\t\t0x0\n#define PCA995X_LED_ON\t\t\t0x1\n#define PCA995X_LED_PWM_MODE\t\t0x2\n#define PCA995X_LDRX_MASK\t\t0x3\n#define PCA995X_LDRX_BITS\t\t2\n\n#define PCA995X_MAX_OUTPUTS\t\t16\n#define PCA995X_OUTPUTS_PER_REG\t\t4\n\n#define PCA995X_IREFALL_FULL_CFG\t0xFF\n#define PCA995X_IREFALL_HALF_CFG\t(PCA995X_IREFALL_FULL_CFG / 2)\n\n#define PCA995X_TYPE_NON_B\t\t0\n#define PCA995X_TYPE_B\t\t\t1\n\n#define ldev_to_led(c)\tcontainer_of(c, struct pca995x_led, ldev)\n\nstruct pca995x_led {\n\tunsigned int led_no;\n\tstruct led_classdev ldev;\n\tstruct pca995x_chip *chip;\n};\n\nstruct pca995x_chip {\n\tstruct regmap *regmap;\n\tstruct pca995x_led leds[PCA995X_MAX_OUTPUTS];\n\tint btype;\n};\n\nstatic int pca995x_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t  enum led_brightness brightness)\n{\n\tstruct pca995x_led *led = ldev_to_led(led_cdev);\n\tstruct pca995x_chip *chip = led->chip;\n\tu8 ledout_addr, pwmout_addr;\n\tint shift, ret;\n\n\tpwmout_addr = (chip->btype ? PCA9955B_PWM0 : PCA9952_PWM0) + led->led_no;\n\tledout_addr = PCA995X_LEDOUT0 + (led->led_no / PCA995X_OUTPUTS_PER_REG);\n\tshift = PCA995X_LDRX_BITS * (led->led_no % PCA995X_OUTPUTS_PER_REG);\n\n\tswitch (brightness) {\n\tcase LED_FULL:\n\t\treturn regmap_update_bits(chip->regmap, ledout_addr,\n\t\t\t\t\t  PCA995X_LDRX_MASK << shift,\n\t\t\t\t\t  PCA995X_LED_ON << shift);\n\tcase LED_OFF:\n\t\treturn regmap_update_bits(chip->regmap, ledout_addr,\n\t\t\t\t\t  PCA995X_LDRX_MASK << shift, 0);\n\tdefault:\n\t\t \n\t\tret = regmap_write(chip->regmap, pwmout_addr, brightness);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\treturn regmap_update_bits(chip->regmap, ledout_addr,\n\t\t\t\t\t  PCA995X_LDRX_MASK << shift,\n\t\t\t\t\t  PCA995X_LED_PWM_MODE << shift);\n\t}\n}\n\nstatic const struct regmap_config pca995x_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x49,\n};\n\nstatic int pca995x_probe(struct i2c_client *client)\n{\n\tstruct fwnode_handle *led_fwnodes[PCA995X_MAX_OUTPUTS] = { 0 };\n\tstruct fwnode_handle *np, *child;\n\tstruct device *dev = &client->dev;\n\tstruct pca995x_chip *chip;\n\tstruct pca995x_led *led;\n\tint i, btype, reg, ret;\n\n\tbtype = (unsigned long)device_get_match_data(&client->dev);\n\n\tnp = dev_fwnode(dev);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->btype = btype;\n\tchip->regmap = devm_regmap_init_i2c(client, &pca995x_regmap);\n\tif (IS_ERR(chip->regmap))\n\t\treturn PTR_ERR(chip->regmap);\n\n\ti2c_set_clientdata(client, chip);\n\n\tfwnode_for_each_available_child_node(np, child) {\n\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (reg < 0 || reg >= PCA995X_MAX_OUTPUTS || led_fwnodes[reg]) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tled = &chip->leds[reg];\n\t\tled_fwnodes[reg] = child;\n\t\tled->chip = chip;\n\t\tled->led_no = reg;\n\t\tled->ldev.brightness_set_blocking = pca995x_brightness_set;\n\t\tled->ldev.max_brightness = 255;\n\t}\n\n\tfor (i = 0; i < PCA995X_MAX_OUTPUTS; i++) {\n\t\tstruct led_init_data init_data = {};\n\n\t\tif (!led_fwnodes[i])\n\t\t\tcontinue;\n\n\t\tinit_data.fwnode = led_fwnodes[i];\n\n\t\tret = devm_led_classdev_register_ext(dev,\n\t\t\t\t\t\t     &chip->leds[i].ldev,\n\t\t\t\t\t\t     &init_data);\n\t\tif (ret < 0) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"Could not register LED %s\\n\",\n\t\t\t\t\t     chip->leds[i].ldev.name);\n\t\t}\n\t}\n\n\t \n\tret = regmap_write(chip->regmap, PCA995X_MODE1, PCA995X_MODE1_CFG);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_write(chip->regmap,\n\t\t\t    btype ? PCA9955B_IREFALL : PCA9952_IREFALL,\n\t\t\t    PCA995X_IREFALL_HALF_CFG);\n}\n\nstatic const struct i2c_device_id pca995x_id[] = {\n\t{ \"pca9952\", .driver_data = (kernel_ulong_t)PCA995X_TYPE_NON_B },\n\t{ \"pca9955b\", .driver_data = (kernel_ulong_t)PCA995X_TYPE_B },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, pca995x_id);\n\nstatic const struct of_device_id pca995x_of_match[] = {\n\t{ .compatible = \"nxp,pca9952\",  .data = (void *)PCA995X_TYPE_NON_B },\n\t{ .compatible = \"nxp,pca9955b\", .data = (void *)PCA995X_TYPE_B },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pca995x_of_match);\n\nstatic struct i2c_driver pca995x_driver = {\n\t.driver = {\n\t\t.name = \"leds-pca995x\",\n\t\t.of_match_table = pca995x_of_match,\n\t},\n\t.probe = pca995x_probe,\n\t.id_table = pca995x_id,\n};\nmodule_i2c_driver(pca995x_driver);\n\nMODULE_AUTHOR(\"Isai Gaspar <isaiezequiel.gaspar@nxp.com>\");\nMODULE_DESCRIPTION(\"PCA995x LED driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}