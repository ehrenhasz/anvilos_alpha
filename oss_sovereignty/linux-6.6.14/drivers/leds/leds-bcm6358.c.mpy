{
  "module_name": "leds-bcm6358.c",
  "hash_id": "0e217f9ef5b93835169bc71007f344f4c21c5314a80d82ce201a18a0de726c25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-bcm6358.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#define BCM6358_REG_MODE\t\t0x0\n#define BCM6358_REG_CTRL\t\t0x4\n\n#define BCM6358_SLED_CLKDIV_MASK\t3\n#define BCM6358_SLED_CLKDIV_1\t\t0\n#define BCM6358_SLED_CLKDIV_2\t\t1\n#define BCM6358_SLED_CLKDIV_4\t\t2\n#define BCM6358_SLED_CLKDIV_8\t\t3\n\n#define BCM6358_SLED_POLARITY\t\tBIT(2)\n#define BCM6358_SLED_BUSY\t\tBIT(3)\n\n#define BCM6358_SLED_MAX_COUNT\t\t32\n#define BCM6358_SLED_WAIT\t\t100\n\n \nstruct bcm6358_led {\n\tstruct led_classdev cdev;\n\tvoid __iomem *mem;\n\tspinlock_t *lock;\n\tunsigned long pin;\n\tbool active_low;\n};\n\nstatic void bcm6358_led_write(void __iomem *reg, unsigned long data)\n{\n#ifdef CONFIG_CPU_BIG_ENDIAN\n\tiowrite32be(data, reg);\n#else\n\twritel(data, reg);\n#endif\n}\n\nstatic unsigned long bcm6358_led_read(void __iomem *reg)\n{\n#ifdef CONFIG_CPU_BIG_ENDIAN\n\treturn ioread32be(reg);\n#else\n\treturn readl(reg);\n#endif\n}\n\nstatic unsigned long bcm6358_led_busy(void __iomem *mem)\n{\n\tunsigned long val;\n\n\twhile ((val = bcm6358_led_read(mem + BCM6358_REG_CTRL)) &\n\t\tBCM6358_SLED_BUSY)\n\t\tudelay(BCM6358_SLED_WAIT);\n\n\treturn val;\n}\n\nstatic void bcm6358_led_set(struct led_classdev *led_cdev,\n\t\t\t    enum led_brightness value)\n{\n\tstruct bcm6358_led *led =\n\t\tcontainer_of(led_cdev, struct bcm6358_led, cdev);\n\tunsigned long flags, val;\n\n\tspin_lock_irqsave(led->lock, flags);\n\tbcm6358_led_busy(led->mem);\n\tval = bcm6358_led_read(led->mem + BCM6358_REG_MODE);\n\tif ((led->active_low && value == LED_OFF) ||\n\t    (!led->active_low && value != LED_OFF))\n\t\tval |= BIT(led->pin);\n\telse\n\t\tval &= ~(BIT(led->pin));\n\tbcm6358_led_write(led->mem + BCM6358_REG_MODE, val);\n\tspin_unlock_irqrestore(led->lock, flags);\n}\n\nstatic int bcm6358_led(struct device *dev, struct device_node *nc, u32 reg,\n\t\t       void __iomem *mem, spinlock_t *lock)\n{\n\tstruct led_init_data init_data = {};\n\tstruct bcm6358_led *led;\n\tenum led_default_state state;\n\tunsigned long val;\n\tint rc;\n\n\tled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tled->pin = reg;\n\tled->mem = mem;\n\tled->lock = lock;\n\n\tif (of_property_read_bool(nc, \"active-low\"))\n\t\tled->active_low = true;\n\n\tinit_data.fwnode = of_fwnode_handle(nc);\n\n\tstate = led_init_default_state_get(init_data.fwnode);\n\tswitch (state) {\n\tcase LEDS_DEFSTATE_ON:\n\t\tled->cdev.brightness = LED_FULL;\n\t\tbreak;\n\tcase LEDS_DEFSTATE_KEEP:\n\t\tval = bcm6358_led_read(led->mem + BCM6358_REG_MODE);\n\t\tval &= BIT(led->pin);\n\t\tif ((led->active_low && !val) || (!led->active_low && val))\n\t\t\tled->cdev.brightness = LED_FULL;\n\t\telse\n\t\t\tled->cdev.brightness = LED_OFF;\n\t\tbreak;\n\tdefault:\n\t\tled->cdev.brightness = LED_OFF;\n\t}\n\n\tbcm6358_led_set(&led->cdev, led->cdev.brightness);\n\n\tled->cdev.brightness_set = bcm6358_led_set;\n\n\trc = devm_led_classdev_register_ext(dev, &led->cdev, &init_data);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tdev_dbg(dev, \"registered LED %s\\n\", led->cdev.name);\n\n\treturn 0;\n}\n\nstatic int bcm6358_leds_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev_of_node(&pdev->dev);\n\tstruct device_node *child;\n\tvoid __iomem *mem;\n\tspinlock_t *lock;  \n\tunsigned long val;\n\tu32 clk_div;\n\n\tmem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem);\n\n\tlock = devm_kzalloc(dev, sizeof(*lock), GFP_KERNEL);\n\tif (!lock)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(lock);\n\n\tval = bcm6358_led_busy(mem);\n\tval &= ~(BCM6358_SLED_POLARITY | BCM6358_SLED_CLKDIV_MASK);\n\tif (of_property_read_bool(np, \"brcm,clk-dat-low\"))\n\t\tval |= BCM6358_SLED_POLARITY;\n\tof_property_read_u32(np, \"brcm,clk-div\", &clk_div);\n\tswitch (clk_div) {\n\tcase 8:\n\t\tval |= BCM6358_SLED_CLKDIV_8;\n\t\tbreak;\n\tcase 4:\n\t\tval |= BCM6358_SLED_CLKDIV_4;\n\t\tbreak;\n\tcase 2:\n\t\tval |= BCM6358_SLED_CLKDIV_2;\n\t\tbreak;\n\tdefault:\n\t\tval |= BCM6358_SLED_CLKDIV_1;\n\t\tbreak;\n\t}\n\tbcm6358_led_write(mem + BCM6358_REG_CTRL, val);\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tint rc;\n\t\tu32 reg;\n\n\t\tif (of_property_read_u32(child, \"reg\", &reg))\n\t\t\tcontinue;\n\n\t\tif (reg >= BCM6358_SLED_MAX_COUNT) {\n\t\t\tdev_err(dev, \"invalid LED (%u >= %d)\\n\", reg,\n\t\t\t\tBCM6358_SLED_MAX_COUNT);\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = bcm6358_led(dev, child, reg, mem, lock);\n\t\tif (rc < 0) {\n\t\t\tof_node_put(child);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm6358_leds_of_match[] = {\n\t{ .compatible = \"brcm,bcm6358-leds\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bcm6358_leds_of_match);\n\nstatic struct platform_driver bcm6358_leds_driver = {\n\t.probe = bcm6358_leds_probe,\n\t.driver = {\n\t\t.name = \"leds-bcm6358\",\n\t\t.of_match_table = bcm6358_leds_of_match,\n\t},\n};\n\nmodule_platform_driver(bcm6358_leds_driver);\n\nMODULE_AUTHOR(\"\u00c1lvaro Fern\u00e1ndez Rojas <noltari@gmail.com>\");\nMODULE_DESCRIPTION(\"LED driver for BCM6358 controllers\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:leds-bcm6358\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}