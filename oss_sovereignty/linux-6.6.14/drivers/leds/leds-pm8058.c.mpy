{
  "module_name": "leds-pm8058.c",
  "hash_id": "57f797220bca8aee48331d981817f9ae847b494cab41875d70b2a02f1b1b3d2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-pm8058.c",
  "human_readable_source": "\n \n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n\n#define PM8058_LED_TYPE_COMMON\t0x00\n#define PM8058_LED_TYPE_KEYPAD\t0x01\n#define PM8058_LED_TYPE_FLASH\t0x02\n\n#define PM8058_LED_TYPE_COMMON_MASK\t0xf8\n#define PM8058_LED_TYPE_KEYPAD_MASK\t0xf0\n#define PM8058_LED_TYPE_COMMON_SHIFT\t3\n#define PM8058_LED_TYPE_KEYPAD_SHIFT\t4\n\nstruct pm8058_led {\n\tstruct regmap *map;\n\tu32 reg;\n\tu32 ledtype;\n\tstruct led_classdev cdev;\n};\n\nstatic void pm8058_led_set(struct led_classdev *cled,\n\tenum led_brightness value)\n{\n\tstruct pm8058_led *led;\n\tint ret = 0;\n\tunsigned int mask = 0;\n\tunsigned int val = 0;\n\n\tled = container_of(cled, struct pm8058_led, cdev);\n\tswitch (led->ledtype) {\n\tcase PM8058_LED_TYPE_COMMON:\n\t\tmask = PM8058_LED_TYPE_COMMON_MASK;\n\t\tval = value << PM8058_LED_TYPE_COMMON_SHIFT;\n\t\tbreak;\n\tcase PM8058_LED_TYPE_KEYPAD:\n\tcase PM8058_LED_TYPE_FLASH:\n\t\tmask = PM8058_LED_TYPE_KEYPAD_MASK;\n\t\tval = value << PM8058_LED_TYPE_KEYPAD_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = regmap_update_bits(led->map, led->reg, mask, val);\n\tif (ret)\n\t\tpr_err(\"Failed to set LED brightness\\n\");\n}\n\nstatic enum led_brightness pm8058_led_get(struct led_classdev *cled)\n{\n\tstruct pm8058_led *led;\n\tint ret;\n\tunsigned int val;\n\n\tled = container_of(cled, struct pm8058_led, cdev);\n\n\tret = regmap_read(led->map, led->reg, &val);\n\tif (ret) {\n\t\tpr_err(\"Failed to get LED brightness\\n\");\n\t\treturn LED_OFF;\n\t}\n\n\tswitch (led->ledtype) {\n\tcase PM8058_LED_TYPE_COMMON:\n\t\tval &= PM8058_LED_TYPE_COMMON_MASK;\n\t\tval >>= PM8058_LED_TYPE_COMMON_SHIFT;\n\t\tbreak;\n\tcase PM8058_LED_TYPE_KEYPAD:\n\tcase PM8058_LED_TYPE_FLASH:\n\t\tval &= PM8058_LED_TYPE_KEYPAD_MASK;\n\t\tval >>= PM8058_LED_TYPE_KEYPAD_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tval = LED_OFF;\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nstatic int pm8058_led_probe(struct platform_device *pdev)\n{\n\tstruct led_init_data init_data = {};\n\tstruct device *dev = &pdev->dev;\n\tstruct pm8058_led *led;\n\tstruct device_node *np;\n\tint ret;\n\tstruct regmap *map;\n\tenum led_brightness maxbright;\n\tenum led_default_state state;\n\n\tled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tled->ledtype = (u32)(unsigned long)of_device_get_match_data(dev);\n\n\tmap = dev_get_regmap(dev->parent, NULL);\n\tif (!map) {\n\t\tdev_err(dev, \"Parent regmap unavailable.\\n\");\n\t\treturn -ENXIO;\n\t}\n\tled->map = map;\n\n\tnp = dev_of_node(dev);\n\n\tret = of_property_read_u32(np, \"reg\", &led->reg);\n\tif (ret) {\n\t\tdev_err(dev, \"no register offset specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tled->cdev.brightness_set = pm8058_led_set;\n\tled->cdev.brightness_get = pm8058_led_get;\n\tif (led->ledtype == PM8058_LED_TYPE_COMMON)\n\t\tmaxbright = 31;  \n\telse\n\t\tmaxbright = 15;  \n\tled->cdev.max_brightness = maxbright;\n\n\tinit_data.fwnode = of_fwnode_handle(np);\n\n\tstate = led_init_default_state_get(init_data.fwnode);\n\tswitch (state) {\n\tcase LEDS_DEFSTATE_ON:\n\t\tled->cdev.brightness = maxbright;\n\t\tpm8058_led_set(&led->cdev, maxbright);\n\t\tbreak;\n\tcase LEDS_DEFSTATE_KEEP:\n\t\tled->cdev.brightness = pm8058_led_get(&led->cdev);\n\t\tbreak;\n\tdefault:\n\t\tled->cdev.brightness = LED_OFF;\n\t\tpm8058_led_set(&led->cdev, LED_OFF);\n\t}\n\n\tif (led->ledtype == PM8058_LED_TYPE_KEYPAD ||\n\t    led->ledtype == PM8058_LED_TYPE_FLASH)\n\t\tled->cdev.flags\t= LED_CORE_SUSPENDRESUME;\n\n\tret = devm_led_classdev_register_ext(dev, &led->cdev, &init_data);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to register LED for %pOF\\n\", np);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id pm8058_leds_id_table[] = {\n\t{\n\t\t.compatible = \"qcom,pm8058-led\",\n\t\t.data = (void *)PM8058_LED_TYPE_COMMON\n\t},\n\t{\n\t\t.compatible = \"qcom,pm8058-keypad-led\",\n\t\t.data = (void *)PM8058_LED_TYPE_KEYPAD\n\t},\n\t{\n\t\t.compatible = \"qcom,pm8058-flash-led\",\n\t\t.data = (void *)PM8058_LED_TYPE_FLASH\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pm8058_leds_id_table);\n\nstatic struct platform_driver pm8058_led_driver = {\n\t.probe\t\t= pm8058_led_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"pm8058-leds\",\n\t\t.of_match_table = pm8058_leds_id_table,\n\t},\n};\nmodule_platform_driver(pm8058_led_driver);\n\nMODULE_DESCRIPTION(\"PM8058 LEDs driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:pm8058-leds\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}