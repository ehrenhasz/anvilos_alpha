{
  "module_name": "leds-lp55xx-common.c",
  "hash_id": "be64db21cae8667613ab6075c0441a4fc61a42a6e68f4ad6e2a604c0bc59c1f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lp55xx-common.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/platform_data/leds-lp55xx.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n#include <dt-bindings/leds/leds-lp55xx.h>\n\n#include \"leds-lp55xx-common.h\"\n\n \n#define LP55XX_CLK_32K\t\t\t32768\n\nstatic struct lp55xx_led *cdev_to_lp55xx_led(struct led_classdev *cdev)\n{\n\treturn container_of(cdev, struct lp55xx_led, cdev);\n}\n\nstatic struct lp55xx_led *dev_to_lp55xx_led(struct device *dev)\n{\n\treturn cdev_to_lp55xx_led(dev_get_drvdata(dev));\n}\n\nstatic struct lp55xx_led *mcled_cdev_to_led(struct led_classdev_mc *mc_cdev)\n{\n\treturn container_of(mc_cdev, struct lp55xx_led, mc_cdev);\n}\n\nstatic void lp55xx_reset_device(struct lp55xx_chip *chip)\n{\n\tstruct lp55xx_device_config *cfg = chip->cfg;\n\tu8 addr = cfg->reset.addr;\n\tu8 val  = cfg->reset.val;\n\n\t \n\tlp55xx_write(chip, addr, val);\n}\n\nstatic int lp55xx_detect_device(struct lp55xx_chip *chip)\n{\n\tstruct lp55xx_device_config *cfg = chip->cfg;\n\tu8 addr = cfg->enable.addr;\n\tu8 val  = cfg->enable.val;\n\tint ret;\n\n\tret = lp55xx_write(chip, addr, val);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(1000, 2000);\n\n\tret = lp55xx_read(chip, addr, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != cfg->enable.val)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int lp55xx_post_init_device(struct lp55xx_chip *chip)\n{\n\tstruct lp55xx_device_config *cfg = chip->cfg;\n\n\tif (!cfg->post_init_device)\n\t\treturn 0;\n\n\treturn cfg->post_init_device(chip);\n}\n\nstatic ssize_t led_current_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct lp55xx_led *led = dev_to_lp55xx_led(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", led->led_current);\n}\n\nstatic ssize_t led_current_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t len)\n{\n\tstruct lp55xx_led *led = dev_to_lp55xx_led(dev);\n\tstruct lp55xx_chip *chip = led->chip;\n\tunsigned long curr;\n\n\tif (kstrtoul(buf, 0, &curr))\n\t\treturn -EINVAL;\n\n\tif (curr > led->max_current)\n\t\treturn -EINVAL;\n\n\tif (!chip->cfg->set_led_current)\n\t\treturn len;\n\n\tmutex_lock(&chip->lock);\n\tchip->cfg->set_led_current(led, (u8)curr);\n\tmutex_unlock(&chip->lock);\n\n\treturn len;\n}\n\nstatic ssize_t max_current_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct lp55xx_led *led = dev_to_lp55xx_led(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", led->max_current);\n}\n\nstatic DEVICE_ATTR_RW(led_current);\nstatic DEVICE_ATTR_RO(max_current);\n\nstatic struct attribute *lp55xx_led_attrs[] = {\n\t&dev_attr_led_current.attr,\n\t&dev_attr_max_current.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(lp55xx_led);\n\nstatic int lp55xx_set_mc_brightness(struct led_classdev *cdev,\n\t\t\t\t    enum led_brightness brightness)\n{\n\tstruct led_classdev_mc *mc_dev = lcdev_to_mccdev(cdev);\n\tstruct lp55xx_led *led = mcled_cdev_to_led(mc_dev);\n\tstruct lp55xx_device_config *cfg = led->chip->cfg;\n\n\tled_mc_calc_color_components(&led->mc_cdev, brightness);\n\treturn cfg->multicolor_brightness_fn(led);\n\n}\n\nstatic int lp55xx_set_brightness(struct led_classdev *cdev,\n\t\t\t     enum led_brightness brightness)\n{\n\tstruct lp55xx_led *led = cdev_to_lp55xx_led(cdev);\n\tstruct lp55xx_device_config *cfg = led->chip->cfg;\n\n\tled->brightness = (u8)brightness;\n\treturn cfg->brightness_fn(led);\n}\n\nstatic int lp55xx_init_led(struct lp55xx_led *led,\n\t\t\tstruct lp55xx_chip *chip, int chan)\n{\n\tstruct lp55xx_platform_data *pdata = chip->pdata;\n\tstruct lp55xx_device_config *cfg = chip->cfg;\n\tstruct device *dev = &chip->cl->dev;\n\tint max_channel = cfg->max_channel;\n\tstruct mc_subled *mc_led_info;\n\tstruct led_classdev *led_cdev;\n\tchar name[32];\n\tint i;\n\tint ret;\n\n\tif (chan >= max_channel) {\n\t\tdev_err(dev, \"invalid channel: %d / %d\\n\", chan, max_channel);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->led_config[chan].led_current == 0)\n\t\treturn 0;\n\n\tif (pdata->led_config[chan].name) {\n\t\tled->cdev.name = pdata->led_config[chan].name;\n\t} else {\n\t\tsnprintf(name, sizeof(name), \"%s:channel%d\",\n\t\t\tpdata->label ? : chip->cl->name, chan);\n\t\tled->cdev.name = name;\n\t}\n\n\tif (pdata->led_config[chan].num_colors > 1) {\n\t\tmc_led_info = devm_kcalloc(dev,\n\t\t\t\t\t   pdata->led_config[chan].num_colors,\n\t\t\t\t\t   sizeof(*mc_led_info), GFP_KERNEL);\n\t\tif (!mc_led_info)\n\t\t\treturn -ENOMEM;\n\n\t\tled_cdev = &led->mc_cdev.led_cdev;\n\t\tled_cdev->name = led->cdev.name;\n\t\tled_cdev->brightness_set_blocking = lp55xx_set_mc_brightness;\n\t\tled->mc_cdev.num_colors = pdata->led_config[chan].num_colors;\n\t\tfor (i = 0; i < led->mc_cdev.num_colors; i++) {\n\t\t\tmc_led_info[i].color_index =\n\t\t\t\tpdata->led_config[chan].color_id[i];\n\t\t\tmc_led_info[i].channel =\n\t\t\t\t\tpdata->led_config[chan].output_num[i];\n\t\t}\n\n\t\tled->mc_cdev.subled_info = mc_led_info;\n\t} else {\n\t\tled->cdev.brightness_set_blocking = lp55xx_set_brightness;\n\t}\n\n\tled->cdev.groups = lp55xx_led_groups;\n\tled->cdev.default_trigger = pdata->led_config[chan].default_trigger;\n\tled->led_current = pdata->led_config[chan].led_current;\n\tled->max_current = pdata->led_config[chan].max_current;\n\tled->chan_nr = pdata->led_config[chan].chan_nr;\n\n\tif (led->chan_nr >= max_channel) {\n\t\tdev_err(dev, \"Use channel numbers between 0 and %d\\n\",\n\t\t\tmax_channel - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->led_config[chan].num_colors > 1)\n\t\tret = devm_led_classdev_multicolor_register(dev, &led->mc_cdev);\n\telse\n\t\tret = devm_led_classdev_register(dev, &led->cdev);\n\n\tif (ret) {\n\t\tdev_err(dev, \"led register err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void lp55xx_firmware_loaded(const struct firmware *fw, void *context)\n{\n\tstruct lp55xx_chip *chip = context;\n\tstruct device *dev = &chip->cl->dev;\n\tenum lp55xx_engine_index idx = chip->engine_idx;\n\n\tif (!fw) {\n\t\tdev_err(dev, \"firmware request failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmutex_lock(&chip->lock);\n\n\tchip->engines[idx - 1].mode = LP55XX_ENGINE_LOAD;\n\tchip->fw = fw;\n\tif (chip->cfg->firmware_cb)\n\t\tchip->cfg->firmware_cb(chip);\n\n\tmutex_unlock(&chip->lock);\n\n\t \n\trelease_firmware(chip->fw);\n\tchip->fw = NULL;\n}\n\nstatic int lp55xx_request_firmware(struct lp55xx_chip *chip)\n{\n\tconst char *name = chip->cl->name;\n\tstruct device *dev = &chip->cl->dev;\n\n\treturn request_firmware_nowait(THIS_MODULE, false, name, dev,\n\t\t\t\tGFP_KERNEL, chip, lp55xx_firmware_loaded);\n}\n\nstatic ssize_t select_engine_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\n\treturn sprintf(buf, \"%d\\n\", chip->engine_idx);\n}\n\nstatic ssize_t select_engine_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t len)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\t \n\n\tswitch (val) {\n\tcase LP55XX_ENGINE_1:\n\tcase LP55XX_ENGINE_2:\n\tcase LP55XX_ENGINE_3:\n\t\tmutex_lock(&chip->lock);\n\t\tchip->engine_idx = val;\n\t\tret = lp55xx_request_firmware(chip);\n\t\tmutex_unlock(&chip->lock);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%lu: invalid engine index. (1, 2, 3)\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret) {\n\t\tdev_err(dev, \"request firmware err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn len;\n}\n\nstatic inline void lp55xx_run_engine(struct lp55xx_chip *chip, bool start)\n{\n\tif (chip->cfg->run_engine)\n\t\tchip->cfg->run_engine(chip, start);\n}\n\nstatic ssize_t run_engine_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t len)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\t \n\n\tif (val <= 0) {\n\t\tlp55xx_run_engine(chip, false);\n\t\treturn len;\n\t}\n\n\tmutex_lock(&chip->lock);\n\tlp55xx_run_engine(chip, true);\n\tmutex_unlock(&chip->lock);\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RW(select_engine);\nstatic DEVICE_ATTR_WO(run_engine);\n\nstatic struct attribute *lp55xx_engine_attributes[] = {\n\t&dev_attr_select_engine.attr,\n\t&dev_attr_run_engine.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group lp55xx_engine_attr_group = {\n\t.attrs = lp55xx_engine_attributes,\n};\n\nint lp55xx_write(struct lp55xx_chip *chip, u8 reg, u8 val)\n{\n\treturn i2c_smbus_write_byte_data(chip->cl, reg, val);\n}\nEXPORT_SYMBOL_GPL(lp55xx_write);\n\nint lp55xx_read(struct lp55xx_chip *chip, u8 reg, u8 *val)\n{\n\ts32 ret;\n\n\tret = i2c_smbus_read_byte_data(chip->cl, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lp55xx_read);\n\nint lp55xx_update_bits(struct lp55xx_chip *chip, u8 reg, u8 mask, u8 val)\n{\n\tint ret;\n\tu8 tmp;\n\n\tret = lp55xx_read(chip, reg, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp &= ~mask;\n\ttmp |= val & mask;\n\n\treturn lp55xx_write(chip, reg, tmp);\n}\nEXPORT_SYMBOL_GPL(lp55xx_update_bits);\n\nbool lp55xx_is_extclk_used(struct lp55xx_chip *chip)\n{\n\tstruct clk *clk;\n\tint err;\n\n\tclk = devm_clk_get(&chip->cl->dev, \"32k_clk\");\n\tif (IS_ERR(clk))\n\t\tgoto use_internal_clk;\n\n\terr = clk_prepare_enable(clk);\n\tif (err)\n\t\tgoto use_internal_clk;\n\n\tif (clk_get_rate(clk) != LP55XX_CLK_32K) {\n\t\tclk_disable_unprepare(clk);\n\t\tgoto use_internal_clk;\n\t}\n\n\tdev_info(&chip->cl->dev, \"%dHz external clock used\\n\",\tLP55XX_CLK_32K);\n\n\tchip->clk = clk;\n\treturn true;\n\nuse_internal_clk:\n\tdev_info(&chip->cl->dev, \"internal clock used\\n\");\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(lp55xx_is_extclk_used);\n\nint lp55xx_init_device(struct lp55xx_chip *chip)\n{\n\tstruct lp55xx_platform_data *pdata;\n\tstruct lp55xx_device_config *cfg;\n\tstruct device *dev = &chip->cl->dev;\n\tint ret = 0;\n\n\tWARN_ON(!chip);\n\n\tpdata = chip->pdata;\n\tcfg = chip->cfg;\n\n\tif (!pdata || !cfg)\n\t\treturn -EINVAL;\n\n\tif (pdata->enable_gpiod) {\n\t\tgpiod_direction_output(pdata->enable_gpiod, 0);\n\n\t\tgpiod_set_consumer_name(pdata->enable_gpiod, \"LP55xx enable\");\n\t\tgpiod_set_value(pdata->enable_gpiod, 0);\n\t\tusleep_range(1000, 2000);  \n\t\tgpiod_set_value(pdata->enable_gpiod, 1);\n\t\tusleep_range(1000, 2000);  \n\t}\n\n\tlp55xx_reset_device(chip);\n\n\t \n\tusleep_range(10000, 20000);\n\n\tret = lp55xx_detect_device(chip);\n\tif (ret) {\n\t\tdev_err(dev, \"device detection err: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t \n\tret = lp55xx_post_init_device(chip);\n\tif (ret) {\n\t\tdev_err(dev, \"post init device err: %d\\n\", ret);\n\t\tgoto err_post_init;\n\t}\n\n\treturn 0;\n\nerr_post_init:\n\tlp55xx_deinit_device(chip);\nerr:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lp55xx_init_device);\n\nvoid lp55xx_deinit_device(struct lp55xx_chip *chip)\n{\n\tstruct lp55xx_platform_data *pdata = chip->pdata;\n\n\tif (chip->clk)\n\t\tclk_disable_unprepare(chip->clk);\n\n\tif (pdata->enable_gpiod)\n\t\tgpiod_set_value(pdata->enable_gpiod, 0);\n}\nEXPORT_SYMBOL_GPL(lp55xx_deinit_device);\n\nint lp55xx_register_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)\n{\n\tstruct lp55xx_platform_data *pdata = chip->pdata;\n\tstruct lp55xx_device_config *cfg = chip->cfg;\n\tint num_channels = pdata->num_channels;\n\tstruct lp55xx_led *each;\n\tu8 led_current;\n\tint ret;\n\tint i;\n\n\tif (!cfg->brightness_fn) {\n\t\tdev_err(&chip->cl->dev, \"empty brightness configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_channels; i++) {\n\n\t\t \n\t\tif (pdata->led_config[i].led_current == 0)\n\t\t\tcontinue;\n\n\t\tled_current = pdata->led_config[i].led_current;\n\t\teach = led + i;\n\t\tret = lp55xx_init_led(each, chip, i);\n\t\tif (ret)\n\t\t\tgoto err_init_led;\n\n\t\tchip->num_leds++;\n\t\teach->chip = chip;\n\n\t\t \n\t\tif (cfg->set_led_current)\n\t\t\tcfg->set_led_current(each, led_current);\n\t}\n\n\treturn 0;\n\nerr_init_led:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lp55xx_register_leds);\n\nint lp55xx_register_sysfs(struct lp55xx_chip *chip)\n{\n\tstruct device *dev = &chip->cl->dev;\n\tstruct lp55xx_device_config *cfg = chip->cfg;\n\tint ret;\n\n\tif (!cfg->run_engine || !cfg->firmware_cb)\n\t\tgoto dev_specific_attrs;\n\n\tret = sysfs_create_group(&dev->kobj, &lp55xx_engine_attr_group);\n\tif (ret)\n\t\treturn ret;\n\ndev_specific_attrs:\n\treturn cfg->dev_attr_group ?\n\t\tsysfs_create_group(&dev->kobj, cfg->dev_attr_group) : 0;\n}\nEXPORT_SYMBOL_GPL(lp55xx_register_sysfs);\n\nvoid lp55xx_unregister_sysfs(struct lp55xx_chip *chip)\n{\n\tstruct device *dev = &chip->cl->dev;\n\tstruct lp55xx_device_config *cfg = chip->cfg;\n\n\tif (cfg->dev_attr_group)\n\t\tsysfs_remove_group(&dev->kobj, cfg->dev_attr_group);\n\n\tsysfs_remove_group(&dev->kobj, &lp55xx_engine_attr_group);\n}\nEXPORT_SYMBOL_GPL(lp55xx_unregister_sysfs);\n\nstatic int lp55xx_parse_common_child(struct device_node *np,\n\t\t\t\t     struct lp55xx_led_config *cfg,\n\t\t\t\t     int led_number, int *chan_nr)\n{\n\tint ret;\n\n\tof_property_read_string(np, \"chan-name\",\n\t\t\t\t&cfg[led_number].name);\n\tof_property_read_u8(np, \"led-cur\",\n\t\t\t    &cfg[led_number].led_current);\n\tof_property_read_u8(np, \"max-cur\",\n\t\t\t    &cfg[led_number].max_current);\n\n\tret = of_property_read_u32(np, \"reg\", chan_nr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (*chan_nr < 0 || *chan_nr > cfg->max_channel)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int lp55xx_parse_multi_led_child(struct device_node *child,\n\t\t\t\t\t struct lp55xx_led_config *cfg,\n\t\t\t\t\t int child_number, int color_number)\n{\n\tint chan_nr, color_id, ret;\n\n\tret = lp55xx_parse_common_child(child, cfg, child_number, &chan_nr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_u32(child, \"color\", &color_id);\n\tif (ret)\n\t\treturn ret;\n\n\tcfg[child_number].color_id[color_number] = color_id;\n\tcfg[child_number].output_num[color_number] = chan_nr;\n\n\treturn 0;\n}\n\nstatic int lp55xx_parse_multi_led(struct device_node *np,\n\t\t\t\t  struct lp55xx_led_config *cfg,\n\t\t\t\t  int child_number)\n{\n\tstruct device_node *child;\n\tint num_colors = 0, ret;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tret = lp55xx_parse_multi_led_child(child, cfg, child_number,\n\t\t\t\t\t\t   num_colors);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t\tnum_colors++;\n\t}\n\n\tcfg[child_number].num_colors = num_colors;\n\n\treturn 0;\n}\n\nstatic int lp55xx_parse_logical_led(struct device_node *np,\n\t\t\t\t   struct lp55xx_led_config *cfg,\n\t\t\t\t   int child_number)\n{\n\tint led_color, ret;\n\tint chan_nr = 0;\n\n\tcfg[child_number].default_trigger =\n\t\tof_get_property(np, \"linux,default-trigger\", NULL);\n\n\tret = of_property_read_u32(np, \"color\", &led_color);\n\tif (ret)\n\t\treturn ret;\n\n\tif (led_color == LED_COLOR_ID_RGB)\n\t\treturn lp55xx_parse_multi_led(np, cfg, child_number);\n\n\tret =  lp55xx_parse_common_child(np, cfg, child_number, &chan_nr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcfg[child_number].chan_nr = chan_nr;\n\n\treturn ret;\n}\n\nstruct lp55xx_platform_data *lp55xx_of_populate_pdata(struct device *dev,\n\t\t\t\t\t\t      struct device_node *np,\n\t\t\t\t\t\t      struct lp55xx_chip *chip)\n{\n\tstruct device_node *child;\n\tstruct lp55xx_platform_data *pdata;\n\tstruct lp55xx_led_config *cfg;\n\tint num_channels;\n\tint i = 0;\n\tint ret;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnum_channels = of_get_available_child_count(np);\n\tif (num_channels == 0) {\n\t\tdev_err(dev, \"no LED channels\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tcfg = devm_kcalloc(dev, num_channels, sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->led_config = &cfg[0];\n\tpdata->num_channels = num_channels;\n\tcfg->max_channel = chip->cfg->max_channel;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tret = lp55xx_parse_logical_led(child, cfg, i);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\ti++;\n\t}\n\n\tif (of_property_read_u32(np, \"ti,charge-pump-mode\", &pdata->charge_pump_mode))\n\t\tpdata->charge_pump_mode = LP55XX_CP_AUTO;\n\n\tif (pdata->charge_pump_mode > LP55XX_CP_AUTO) {\n\t\tdev_err(dev, \"invalid charge pump mode %d\\n\", pdata->charge_pump_mode);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tof_property_read_string(np, \"label\", &pdata->label);\n\tof_property_read_u8(np, \"clock-mode\", &pdata->clock_mode);\n\n\tpdata->enable_gpiod = devm_gpiod_get_optional(dev, \"enable\",\n\t\t\t\t\t\t      GPIOD_ASIS);\n\tif (IS_ERR(pdata->enable_gpiod))\n\t\treturn ERR_CAST(pdata->enable_gpiod);\n\n\t \n\tof_property_read_u8(np, \"pwr-sel\", (u8 *)&pdata->pwr_sel);\n\n\treturn pdata;\n}\nEXPORT_SYMBOL_GPL(lp55xx_of_populate_pdata);\n\nMODULE_AUTHOR(\"Milo Kim <milo.kim@ti.com>\");\nMODULE_DESCRIPTION(\"LP55xx Common Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}