{
  "module_name": "leds-el15203000.c",
  "hash_id": "1894aa752643860733aff9d2b22daf6bf2cf007a905794f656aa74286a26f54b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-el15203000.c",
  "human_readable_source": "\n\n\n\n#include <linux/delay.h>\n#include <linux/leds.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n\n \n\n \n#define EL_FW_DELAY_USEC\t20000ul\n#define EL_PATTERN_DELAY_MSEC\t800u\n#define EL_PATTERN_LEN\t\t10u\n#define EL_PATTERN_HALF_LEN\t(EL_PATTERN_LEN / 2)\n\nenum el15203000_command {\n\t \n\tEL_OFF\t\t\t= '0',\n\tEL_ON\t\t\t= '1',\n\n\t \n\tEL_SCREEN_BREATHING\t= '2',\n\n\t \n\tEL_PIPE_CASCADE\t\t= '2',\n\tEL_PIPE_INV_CASCADE\t= '3',\n\tEL_PIPE_BOUNCE\t\t= '4',\n\tEL_PIPE_INV_BOUNCE\t= '5',\n};\n\nstruct el15203000_led {\n\tstruct led_classdev\tldev;\n\tstruct el15203000\t*priv;\n\tu32\t\t\treg;\n};\n\nstruct el15203000 {\n\tstruct device\t\t*dev;\n\tstruct mutex\t\tlock;\n\tstruct spi_device\t*spi;\n\tunsigned long\t\tdelay;\n\tsize_t\t\t\tcount;\n\tstruct el15203000_led\tleds[];\n};\n\n#define to_el15203000_led(d)\tcontainer_of(d, struct el15203000_led, ldev)\n\nstatic int el15203000_cmd(struct el15203000_led *led, u8 brightness)\n{\n\tint\t\tret;\n\tu8\t\tcmd[2];\n\tsize_t\t\ti;\n\n\tmutex_lock(&led->priv->lock);\n\n\tdev_dbg(led->priv->dev, \"Set brightness of 0x%02x(%c) to 0x%02x(%c)\",\n\t\tled->reg, led->reg, brightness, brightness);\n\n\t \n\tif (time_after(led->priv->delay, jiffies)) {\n\t\tdev_dbg(led->priv->dev, \"Wait %luus to sync\",\n\t\t\tEL_FW_DELAY_USEC);\n\n\t\tusleep_range(EL_FW_DELAY_USEC,\n\t\t\t     EL_FW_DELAY_USEC + 1);\n\t}\n\n\tcmd[0] = led->reg;\n\tcmd[1] = brightness;\n\n\tfor (i = 0; i < ARRAY_SIZE(cmd); i++) {\n\t\tif (i)\n\t\t\tusleep_range(EL_FW_DELAY_USEC,\n\t\t\t\t     EL_FW_DELAY_USEC + 1);\n\n\t\tret = spi_write(led->priv->spi, &cmd[i], sizeof(cmd[i]));\n\t\tif (ret) {\n\t\t\tdev_err(led->priv->dev,\n\t\t\t\t\"spi_write() error %d\", ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tled->priv->delay = jiffies + usecs_to_jiffies(EL_FW_DELAY_USEC);\n\n\tmutex_unlock(&led->priv->lock);\n\n\treturn ret;\n}\n\nstatic int el15203000_set_blocking(struct led_classdev *ldev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct el15203000_led *led = to_el15203000_led(ldev);\n\n\treturn el15203000_cmd(led, brightness == LED_OFF ? EL_OFF : EL_ON);\n}\n\nstatic int el15203000_pattern_set_S(struct led_classdev *ldev,\n\t\t\t\t    struct led_pattern *pattern,\n\t\t\t\t    u32 len, int repeat)\n{\n\tstruct el15203000_led *led = to_el15203000_led(ldev);\n\n\tif (repeat > 0 || len != 2 ||\n\t    pattern[0].delta_t != 4000 || pattern[0].brightness != 0 ||\n\t    pattern[1].delta_t != 4000 || pattern[1].brightness != 1)\n\t\treturn -EINVAL;\n\n\tdev_dbg(led->priv->dev, \"Breathing mode for 0x%02x(%c)\",\n\t\tled->reg, led->reg);\n\n\treturn el15203000_cmd(led, EL_SCREEN_BREATHING);\n}\n\nstatic bool is_cascade(const struct led_pattern *pattern, u32 len,\n\t\t       bool inv, bool right)\n{\n\tint val, t;\n\tu32 i;\n\n\tif (len != EL_PATTERN_HALF_LEN)\n\t\treturn false;\n\n\tval = right ? BIT(4) : BIT(0);\n\n\tfor (i = 0; i < len; i++) {\n\t\tt = inv ? ~val & GENMASK(4, 0) : val;\n\n\t\tif (pattern[i].delta_t != EL_PATTERN_DELAY_MSEC ||\n\t\t    pattern[i].brightness != t)\n\t\t\treturn false;\n\n\t\tval = right ? val >> 1 : val << 1;\n\t}\n\n\treturn true;\n}\n\nstatic bool is_bounce(const struct led_pattern *pattern, u32 len, bool inv)\n{\n\tif (len != EL_PATTERN_LEN)\n\t\treturn false;\n\n\treturn is_cascade(pattern, EL_PATTERN_HALF_LEN, inv, false) &&\n\t       is_cascade(pattern + EL_PATTERN_HALF_LEN,\n\t\t\t  EL_PATTERN_HALF_LEN, inv, true);\n}\n\nstatic int el15203000_pattern_set_P(struct led_classdev *ldev,\n\t\t\t\t    struct led_pattern *pattern,\n\t\t\t\t    u32 len, int repeat)\n{\n\tstruct el15203000_led\t*led = to_el15203000_led(ldev);\n\tu8\t\t\tcmd;\n\n\tif (repeat > 0)\n\t\treturn -EINVAL;\n\n\tif (is_cascade(pattern, len, false, false)) {\n\t\tdev_dbg(led->priv->dev, \"Cascade mode for 0x%02x(%c)\",\n\t\t\tled->reg, led->reg);\n\n\t\tcmd = EL_PIPE_CASCADE;\n\t} else if (is_cascade(pattern, len, true, false)) {\n\t\tdev_dbg(led->priv->dev, \"Inverse cascade mode for 0x%02x(%c)\",\n\t\t\tled->reg, led->reg);\n\n\t\tcmd = EL_PIPE_INV_CASCADE;\n\t} else if (is_bounce(pattern, len, false)) {\n\t\tdev_dbg(led->priv->dev, \"Bounce mode for 0x%02x(%c)\",\n\t\t\tled->reg, led->reg);\n\n\t\tcmd = EL_PIPE_BOUNCE;\n\t} else if (is_bounce(pattern, len, true)) {\n\t\tdev_dbg(led->priv->dev, \"Inverse bounce mode for 0x%02x(%c)\",\n\t\t\tled->reg, led->reg);\n\n\t\tcmd = EL_PIPE_INV_BOUNCE;\n\t} else {\n\t\tdev_err(led->priv->dev, \"Invalid hw_pattern for 0x%02x(%c)!\",\n\t\t\tled->reg, led->reg);\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn el15203000_cmd(led, cmd);\n}\n\nstatic int el15203000_pattern_clear(struct led_classdev *ldev)\n{\n\tstruct el15203000_led *led = to_el15203000_led(ldev);\n\n\treturn el15203000_cmd(led, EL_OFF);\n}\n\nstatic int el15203000_probe_dt(struct el15203000 *priv)\n{\n\tstruct el15203000_led\t*led = priv->leds;\n\tstruct fwnode_handle\t*child;\n\tint\t\t\tret;\n\n\tdevice_for_each_child_node(priv->dev, child) {\n\t\tstruct led_init_data init_data = {};\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &led->reg);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"LED without ID number\");\n\t\t\tgoto err_child_out;\n\t\t}\n\n\t\tif (led->reg > U8_MAX) {\n\t\t\tdev_err(priv->dev, \"LED value %d is invalid\", led->reg);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_child_out;\n\t\t}\n\n\t\tled->priv\t\t\t  = priv;\n\t\tled->ldev.max_brightness\t  = LED_ON;\n\t\tled->ldev.brightness_set_blocking = el15203000_set_blocking;\n\n\t\tif (led->reg == 'S') {\n\t\t\tled->ldev.pattern_set\t= el15203000_pattern_set_S;\n\t\t\tled->ldev.pattern_clear\t= el15203000_pattern_clear;\n\t\t} else if (led->reg == 'P') {\n\t\t\tled->ldev.pattern_set\t= el15203000_pattern_set_P;\n\t\t\tled->ldev.pattern_clear\t= el15203000_pattern_clear;\n\t\t}\n\n\t\tinit_data.fwnode = child;\n\t\tret = devm_led_classdev_register_ext(priv->dev, &led->ldev,\n\t\t\t\t\t\t     &init_data);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"failed to register LED device %s, err %d\",\n\t\t\t\tled->ldev.name, ret);\n\t\t\tgoto err_child_out;\n\t\t}\n\n\t\tled++;\n\t}\n\n\treturn 0;\n\nerr_child_out:\n\tfwnode_handle_put(child);\n\treturn ret;\n}\n\nstatic int el15203000_probe(struct spi_device *spi)\n{\n\tstruct el15203000\t*priv;\n\tsize_t\t\t\tcount;\n\n\tcount = device_get_child_node_count(&spi->dev);\n\tif (!count) {\n\t\tdev_err(&spi->dev, \"LEDs are not defined in device tree!\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(&spi->dev, struct_size(priv, leds, count),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->lock);\n\tpriv->count\t= count;\n\tpriv->dev\t= &spi->dev;\n\tpriv->spi\t= spi;\n\tpriv->delay\t= jiffies -\n\t\t\t  usecs_to_jiffies(EL_FW_DELAY_USEC);\n\n\tspi_set_drvdata(spi, priv);\n\n\treturn el15203000_probe_dt(priv);\n}\n\nstatic void el15203000_remove(struct spi_device *spi)\n{\n\tstruct el15203000 *priv = spi_get_drvdata(spi);\n\n\tmutex_destroy(&priv->lock);\n}\n\nstatic const struct of_device_id el15203000_dt_ids[] = {\n\t{ .compatible = \"crane,el15203000\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, el15203000_dt_ids);\n\nstatic struct spi_driver el15203000_driver = {\n\t.probe\t\t= el15203000_probe,\n\t.remove\t\t= el15203000_remove,\n\t.driver = {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= el15203000_dt_ids,\n\t},\n};\n\nmodule_spi_driver(el15203000_driver);\n\nMODULE_AUTHOR(\"Oleh Kravchenko <oleg@kaa.org.ua>\");\nMODULE_DESCRIPTION(\"el15203000 LED driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"spi:el15203000\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}