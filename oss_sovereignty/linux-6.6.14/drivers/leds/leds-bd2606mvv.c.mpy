{
  "module_name": "leds-bd2606mvv.c",
  "hash_id": "758377bc7d0007f865181ac1e0acf6738ac8c1681536287dda1c51db27eff592",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-bd2606mvv.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define BD2606_MAX_LEDS 6\n#define BD2606_MAX_BRIGHTNESS 63\n#define BD2606_REG_PWRCNT 3\n#define ldev_to_led(c)\tcontainer_of(c, struct bd2606mvv_led, ldev)\n\nstruct bd2606mvv_led {\n\tunsigned int led_no;\n\tstruct led_classdev ldev;\n\tstruct bd2606mvv_priv *priv;\n};\n\nstruct bd2606mvv_priv {\n\tstruct bd2606mvv_led leds[BD2606_MAX_LEDS];\n\tstruct regmap *regmap;\n};\n\nstatic int\nbd2606mvv_brightness_set(struct led_classdev *led_cdev,\n\t\t      enum led_brightness brightness)\n{\n\tstruct bd2606mvv_led *led = ldev_to_led(led_cdev);\n\tstruct bd2606mvv_priv *priv = led->priv;\n\tint err;\n\n\tif (brightness == 0)\n\t\treturn regmap_update_bits(priv->regmap,\n\t\t\t\t\t  BD2606_REG_PWRCNT,\n\t\t\t\t\t  1 << led->led_no,\n\t\t\t\t\t  0);\n\n\t \n\terr = regmap_write(priv->regmap, led->led_no / 2,\n\t\t\t   led_cdev->max_brightness == 1 ?\n\t\t\t   BD2606_MAX_BRIGHTNESS : brightness);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_update_bits(priv->regmap,\n\t\t\t\t  BD2606_REG_PWRCNT,\n\t\t\t\t  1 << led->led_no,\n\t\t\t\t  1 << led->led_no);\n}\n\nstatic const struct regmap_config bd2606mvv_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x3,\n};\n\nstatic int bd2606mvv_probe(struct i2c_client *client)\n{\n\tstruct fwnode_handle *np, *child;\n\tstruct device *dev = &client->dev;\n\tstruct bd2606mvv_priv *priv;\n\tstruct fwnode_handle *led_fwnodes[BD2606_MAX_LEDS] = { 0 };\n\tint active_pairs[BD2606_MAX_LEDS / 2] = { 0 };\n\tint err, reg;\n\tint i;\n\n\tnp = dev_fwnode(dev);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &bd2606mvv_regmap);\n\tif (IS_ERR(priv->regmap)) {\n\t\terr = PTR_ERR(priv->regmap);\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ti2c_set_clientdata(client, priv);\n\n\tfwnode_for_each_available_child_node(np, child) {\n\t\tstruct bd2606mvv_led *led;\n\n\t\terr = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (err) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn err;\n\t\t}\n\t\tif (reg < 0 || reg >= BD2606_MAX_LEDS || led_fwnodes[reg]) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tled = &priv->leds[reg];\n\t\tled_fwnodes[reg] = child;\n\t\tactive_pairs[reg / 2]++;\n\t\tled->priv = priv;\n\t\tled->led_no = reg;\n\t\tled->ldev.brightness_set_blocking = bd2606mvv_brightness_set;\n\t\tled->ldev.max_brightness = BD2606_MAX_BRIGHTNESS;\n\t}\n\n\tfor (i = 0; i < BD2606_MAX_LEDS; i++) {\n\t\tstruct led_init_data init_data = {};\n\n\t\tif (!led_fwnodes[i])\n\t\t\tcontinue;\n\n\t\tinit_data.fwnode = led_fwnodes[i];\n\t\t \n\t\tif (active_pairs[i / 2] == 2)\n\t\t\tpriv->leds[i].ldev.max_brightness = 1;\n\n\t\terr = devm_led_classdev_register_ext(dev,\n\t\t\t\t\t\t     &priv->leds[i].ldev,\n\t\t\t\t\t\t     &init_data);\n\t\tif (err < 0) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn dev_err_probe(dev, err,\n\t\t\t\t\t     \"couldn't register LED %s\\n\",\n\t\t\t\t\t     priv->leds[i].ldev.name);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused of_bd2606mvv_leds_match[] = {\n\t{ .compatible = \"rohm,bd2606mvv\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_bd2606mvv_leds_match);\n\nstatic struct i2c_driver bd2606mvv_driver = {\n\t.driver   = {\n\t\t.name    = \"leds-bd2606mvv\",\n\t\t.of_match_table = of_match_ptr(of_bd2606mvv_leds_match),\n\t},\n\t.probe = bd2606mvv_probe,\n};\n\nmodule_i2c_driver(bd2606mvv_driver);\n\nMODULE_AUTHOR(\"Andreas Kemnade <andreas@kemnade.info>\");\nMODULE_DESCRIPTION(\"BD2606 LED driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}