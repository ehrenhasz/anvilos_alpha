{
  "module_name": "leds-pca955x.c",
  "hash_id": "5ab04a9c0f1d251cd0235e9e7745581f6b7f1372a3d67f5d4f96d39a4fb614e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-pca955x.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <dt-bindings/leds/leds-pca955x.h>\n\n \n#define PCA955X_LS_LED_ON\t0x0\t \n#define PCA955X_LS_LED_OFF\t0x1\t \n#define PCA955X_LS_BLINK0\t0x2\t \n#define PCA955X_LS_BLINK1\t0x3\t \n\n#define PCA955X_GPIO_INPUT\tLED_OFF\n#define PCA955X_GPIO_HIGH\tLED_OFF\n#define PCA955X_GPIO_LOW\tLED_FULL\n\nenum pca955x_type {\n\tpca9550,\n\tpca9551,\n\tpca9552,\n\tibm_pca9552,\n\tpca9553,\n};\n\nstruct pca955x_chipdef {\n\tint\t\t\tbits;\n\tu8\t\t\tslv_addr;\t \n\tint\t\t\tslv_addr_shift;\t \n};\n\nstatic struct pca955x_chipdef pca955x_chipdefs[] = {\n\t[pca9550] = {\n\t\t.bits\t\t= 2,\n\t\t.slv_addr\t=   0x60,\n\t\t.slv_addr_shift\t= 1,\n\t},\n\t[pca9551] = {\n\t\t.bits\t\t= 8,\n\t\t.slv_addr\t=   0x60,\n\t\t.slv_addr_shift\t= 3,\n\t},\n\t[pca9552] = {\n\t\t.bits\t\t= 16,\n\t\t.slv_addr\t=   0x60,\n\t\t.slv_addr_shift\t= 3,\n\t},\n\t[ibm_pca9552] = {\n\t\t.bits\t\t= 16,\n\t\t.slv_addr\t=   0x30,\n\t\t.slv_addr_shift\t= 3,\n\t},\n\t[pca9553] = {\n\t\t.bits\t\t= 4,\n\t\t.slv_addr\t=   0x62,\n\t\t.slv_addr_shift\t= 1,\n\t},\n};\n\nstatic const struct i2c_device_id pca955x_id[] = {\n\t{ \"pca9550\", pca9550 },\n\t{ \"pca9551\", pca9551 },\n\t{ \"pca9552\", pca9552 },\n\t{ \"ibm-pca9552\", ibm_pca9552 },\n\t{ \"pca9553\", pca9553 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pca955x_id);\n\nstruct pca955x {\n\tstruct mutex lock;\n\tstruct pca955x_led *leds;\n\tstruct pca955x_chipdef\t*chipdef;\n\tstruct i2c_client\t*client;\n\tunsigned long active_pins;\n#ifdef CONFIG_LEDS_PCA955X_GPIO\n\tstruct gpio_chip gpio;\n#endif\n};\n\nstruct pca955x_led {\n\tstruct pca955x\t*pca955x;\n\tstruct led_classdev\tled_cdev;\n\tint\t\t\tled_num;\t \n\tu32\t\t\ttype;\n\tenum led_default_state\tdefault_state;\n\tstruct fwnode_handle\t*fwnode;\n};\n\nstruct pca955x_platform_data {\n\tstruct pca955x_led\t*leds;\n\tint\t\t\tnum_leds;\n};\n\n \nstatic inline int pca95xx_num_input_regs(int bits)\n{\n\treturn (bits + 7) / 8;\n}\n\n \nstatic inline u8 pca955x_ledsel(u8 oldval, int led_num, int state)\n{\n\treturn (oldval & (~(0x3 << (led_num << 1)))) |\n\t\t((state & 0x3) << (led_num << 1));\n}\n\n \nstatic int pca955x_write_psc(struct i2c_client *client, int n, u8 val)\n{\n\tstruct pca955x *pca955x = i2c_get_clientdata(client);\n\tu8 cmd = pca95xx_num_input_regs(pca955x->chipdef->bits) + (2 * n);\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, cmd, val);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"%s: reg 0x%x, val 0x%x, err %d\\n\",\n\t\t\t__func__, n, val, ret);\n\treturn ret;\n}\n\n \nstatic int pca955x_write_pwm(struct i2c_client *client, int n, u8 val)\n{\n\tstruct pca955x *pca955x = i2c_get_clientdata(client);\n\tu8 cmd = pca95xx_num_input_regs(pca955x->chipdef->bits) + 1 + (2 * n);\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, cmd, val);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"%s: reg 0x%x, val 0x%x, err %d\\n\",\n\t\t\t__func__, n, val, ret);\n\treturn ret;\n}\n\n \nstatic int pca955x_write_ls(struct i2c_client *client, int n, u8 val)\n{\n\tstruct pca955x *pca955x = i2c_get_clientdata(client);\n\tu8 cmd = pca95xx_num_input_regs(pca955x->chipdef->bits) + 4 + n;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, cmd, val);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"%s: reg 0x%x, val 0x%x, err %d\\n\",\n\t\t\t__func__, n, val, ret);\n\treturn ret;\n}\n\n \nstatic int pca955x_read_ls(struct i2c_client *client, int n, u8 *val)\n{\n\tstruct pca955x *pca955x = i2c_get_clientdata(client);\n\tu8 cmd = pca95xx_num_input_regs(pca955x->chipdef->bits) + 4 + n;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, cmd);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"%s: reg 0x%x, err %d\\n\",\n\t\t\t__func__, n, ret);\n\t\treturn ret;\n\t}\n\t*val = (u8)ret;\n\treturn 0;\n}\n\nstatic int pca955x_read_pwm(struct i2c_client *client, int n, u8 *val)\n{\n\tstruct pca955x *pca955x = i2c_get_clientdata(client);\n\tu8 cmd = pca95xx_num_input_regs(pca955x->chipdef->bits) + 1 + (2 * n);\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, cmd);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"%s: reg 0x%x, err %d\\n\",\n\t\t\t__func__, n, ret);\n\t\treturn ret;\n\t}\n\t*val = (u8)ret;\n\treturn 0;\n}\n\nstatic enum led_brightness pca955x_led_get(struct led_classdev *led_cdev)\n{\n\tstruct pca955x_led *pca955x_led = container_of(led_cdev,\n\t\t\t\t\t\t       struct pca955x_led,\n\t\t\t\t\t\t       led_cdev);\n\tstruct pca955x *pca955x = pca955x_led->pca955x;\n\tu8 ls, pwm;\n\tint ret;\n\n\tret = pca955x_read_ls(pca955x->client, pca955x_led->led_num / 4, &ls);\n\tif (ret)\n\t\treturn ret;\n\n\tls = (ls >> ((pca955x_led->led_num % 4) << 1)) & 0x3;\n\tswitch (ls) {\n\tcase PCA955X_LS_LED_ON:\n\t\tret = LED_FULL;\n\t\tbreak;\n\tcase PCA955X_LS_LED_OFF:\n\t\tret = LED_OFF;\n\t\tbreak;\n\tcase PCA955X_LS_BLINK0:\n\t\tret = LED_HALF;\n\t\tbreak;\n\tcase PCA955X_LS_BLINK1:\n\t\tret = pca955x_read_pwm(pca955x->client, 1, &pwm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = 255 - pwm;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int pca955x_led_set(struct led_classdev *led_cdev,\n\t\t\t    enum led_brightness value)\n{\n\tstruct pca955x_led *pca955x_led;\n\tstruct pca955x *pca955x;\n\tu8 ls;\n\tint chip_ls;\t \n\tint ls_led;\t \n\tint ret;\n\n\tpca955x_led = container_of(led_cdev, struct pca955x_led, led_cdev);\n\tpca955x = pca955x_led->pca955x;\n\n\tchip_ls = pca955x_led->led_num / 4;\n\tls_led = pca955x_led->led_num % 4;\n\n\tmutex_lock(&pca955x->lock);\n\n\tret = pca955x_read_ls(pca955x->client, chip_ls, &ls);\n\tif (ret)\n\t\tgoto out;\n\n\tswitch (value) {\n\tcase LED_FULL:\n\t\tls = pca955x_ledsel(ls, ls_led, PCA955X_LS_LED_ON);\n\t\tbreak;\n\tcase LED_OFF:\n\t\tls = pca955x_ledsel(ls, ls_led, PCA955X_LS_LED_OFF);\n\t\tbreak;\n\tcase LED_HALF:\n\t\tls = pca955x_ledsel(ls, ls_led, PCA955X_LS_BLINK0);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret = pca955x_write_pwm(pca955x->client, 1, 255 - value);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tls = pca955x_ledsel(ls, ls_led, PCA955X_LS_BLINK1);\n\t\tbreak;\n\t}\n\n\tret = pca955x_write_ls(pca955x->client, chip_ls, ls);\n\nout:\n\tmutex_unlock(&pca955x->lock);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_LEDS_PCA955X_GPIO\n \nstatic int pca955x_read_input(struct i2c_client *client, int n, u8 *val)\n{\n\tint ret = i2c_smbus_read_byte_data(client, n);\n\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"%s: reg 0x%x, err %d\\n\",\n\t\t\t__func__, n, ret);\n\t\treturn ret;\n\t}\n\t*val = (u8)ret;\n\treturn 0;\n\n}\n\nstatic int pca955x_gpio_request_pin(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct pca955x *pca955x = gpiochip_get_data(gc);\n\n\treturn test_and_set_bit(offset, &pca955x->active_pins) ? -EBUSY : 0;\n}\n\nstatic void pca955x_gpio_free_pin(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct pca955x *pca955x = gpiochip_get_data(gc);\n\n\tclear_bit(offset, &pca955x->active_pins);\n}\n\nstatic int pca955x_set_value(struct gpio_chip *gc, unsigned int offset,\n\t\t\t     int val)\n{\n\tstruct pca955x *pca955x = gpiochip_get_data(gc);\n\tstruct pca955x_led *led = &pca955x->leds[offset];\n\n\tif (val)\n\t\treturn pca955x_led_set(&led->led_cdev, PCA955X_GPIO_HIGH);\n\n\treturn pca955x_led_set(&led->led_cdev, PCA955X_GPIO_LOW);\n}\n\nstatic void pca955x_gpio_set_value(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\t   int val)\n{\n\tpca955x_set_value(gc, offset, val);\n}\n\nstatic int pca955x_gpio_get_value(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct pca955x *pca955x = gpiochip_get_data(gc);\n\tstruct pca955x_led *led = &pca955x->leds[offset];\n\tu8 reg = 0;\n\n\t \n\tpca955x_read_input(pca955x->client, led->led_num / 8, &reg);\n\n\treturn !!(reg & (1 << (led->led_num % 8)));\n}\n\nstatic int pca955x_gpio_direction_input(struct gpio_chip *gc,\n\t\t\t\t\tunsigned int offset)\n{\n\tstruct pca955x *pca955x = gpiochip_get_data(gc);\n\tstruct pca955x_led *led = &pca955x->leds[offset];\n\n\t \n\treturn pca955x_led_set(&led->led_cdev, PCA955X_GPIO_INPUT);\n}\n\nstatic int pca955x_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\t unsigned int offset, int val)\n{\n\treturn pca955x_set_value(gc, offset, val);\n}\n#endif  \n\nstatic struct pca955x_platform_data *\npca955x_get_pdata(struct i2c_client *client, struct pca955x_chipdef *chip)\n{\n\tstruct pca955x_platform_data *pdata;\n\tstruct pca955x_led *led;\n\tstruct fwnode_handle *child;\n\tint count;\n\n\tcount = device_get_child_node_count(&client->dev);\n\tif (count > chip->bits)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->leds = devm_kcalloc(&client->dev,\n\t\t\t\t   chip->bits, sizeof(struct pca955x_led),\n\t\t\t\t   GFP_KERNEL);\n\tif (!pdata->leds)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdevice_for_each_child_node(&client->dev, child) {\n\t\tu32 reg;\n\t\tint res;\n\n\t\tres = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif ((res != 0) || (reg >= chip->bits))\n\t\t\tcontinue;\n\n\t\tled = &pdata->leds[reg];\n\t\tled->type = PCA955X_TYPE_LED;\n\t\tled->fwnode = child;\n\t\tled->default_state = led_init_default_state_get(child);\n\n\t\tfwnode_property_read_u32(child, \"type\", &led->type);\n\t}\n\n\tpdata->num_leds = chip->bits;\n\n\treturn pdata;\n}\n\nstatic const struct of_device_id of_pca955x_match[] = {\n\t{ .compatible = \"nxp,pca9550\", .data = (void *)pca9550 },\n\t{ .compatible = \"nxp,pca9551\", .data = (void *)pca9551 },\n\t{ .compatible = \"nxp,pca9552\", .data = (void *)pca9552 },\n\t{ .compatible = \"ibm,pca9552\", .data = (void *)ibm_pca9552 },\n\t{ .compatible = \"nxp,pca9553\", .data = (void *)pca9553 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_pca955x_match);\n\nstatic int pca955x_probe(struct i2c_client *client)\n{\n\tstruct pca955x *pca955x;\n\tstruct pca955x_led *pca955x_led;\n\tstruct pca955x_chipdef *chip;\n\tstruct led_classdev *led;\n\tstruct led_init_data init_data;\n\tstruct i2c_adapter *adapter;\n\tint i, err;\n\tstruct pca955x_platform_data *pdata;\n\tbool set_default_label = false;\n\tbool keep_pwm = false;\n\tchar default_label[8];\n\tenum pca955x_type chip_type;\n\tconst void *md = device_get_match_data(&client->dev);\n\n\tif (md) {\n\t\tchip_type = (enum pca955x_type)md;\n\t} else {\n\t\tconst struct i2c_device_id *id = i2c_match_id(pca955x_id,\n\t\t\t\t\t\t\t      client);\n\n\t\tif (id) {\n\t\t\tchip_type = (enum pca955x_type)id->driver_data;\n\t\t} else {\n\t\t\tdev_err(&client->dev, \"unknown chip\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tchip = &pca955x_chipdefs[chip_type];\n\tadapter = client->adapter;\n\tpdata = dev_get_platdata(&client->dev);\n\tif (!pdata) {\n\t\tpdata =\tpca955x_get_pdata(client, chip);\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\t}\n\n\t \n\tif ((client->addr & ~((1 << chip->slv_addr_shift) - 1)) !=\n\t    chip->slv_addr) {\n\t\tdev_err(&client->dev, \"invalid slave address %02x\\n\",\n\t\t\tclient->addr);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&client->dev, \"leds-pca955x: Using %s %d-bit LED driver at \"\n\t\t \"slave address 0x%02x\\n\", client->name, chip->bits,\n\t\t client->addr);\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tif (pdata->num_leds != chip->bits) {\n\t\tdev_err(&client->dev,\n\t\t\t\"board info claims %d LEDs on a %d-bit chip\\n\",\n\t\t\tpdata->num_leds, chip->bits);\n\t\treturn -ENODEV;\n\t}\n\n\tpca955x = devm_kzalloc(&client->dev, sizeof(*pca955x), GFP_KERNEL);\n\tif (!pca955x)\n\t\treturn -ENOMEM;\n\n\tpca955x->leds = devm_kcalloc(&client->dev, chip->bits,\n\t\t\t\t     sizeof(*pca955x_led), GFP_KERNEL);\n\tif (!pca955x->leds)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, pca955x);\n\n\tmutex_init(&pca955x->lock);\n\tpca955x->client = client;\n\tpca955x->chipdef = chip;\n\n\tinit_data.devname_mandatory = false;\n\tinit_data.devicename = \"pca955x\";\n\n\tfor (i = 0; i < chip->bits; i++) {\n\t\tpca955x_led = &pca955x->leds[i];\n\t\tpca955x_led->led_num = i;\n\t\tpca955x_led->pca955x = pca955x;\n\t\tpca955x_led->type = pdata->leds[i].type;\n\n\t\tswitch (pca955x_led->type) {\n\t\tcase PCA955X_TYPE_NONE:\n\t\tcase PCA955X_TYPE_GPIO:\n\t\t\tbreak;\n\t\tcase PCA955X_TYPE_LED:\n\t\t\tled = &pca955x_led->led_cdev;\n\t\t\tled->brightness_set_blocking = pca955x_led_set;\n\t\t\tled->brightness_get = pca955x_led_get;\n\n\t\t\tif (pdata->leds[i].default_state == LEDS_DEFSTATE_OFF) {\n\t\t\t\terr = pca955x_led_set(led, LED_OFF);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else if (pdata->leds[i].default_state == LEDS_DEFSTATE_ON) {\n\t\t\t\terr = pca955x_led_set(led, LED_FULL);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tinit_data.fwnode = pdata->leds[i].fwnode;\n\n\t\t\tif (is_of_node(init_data.fwnode)) {\n\t\t\t\tif (to_of_node(init_data.fwnode)->name[0] ==\n\t\t\t\t    '\\0')\n\t\t\t\t\tset_default_label = true;\n\t\t\t\telse\n\t\t\t\t\tset_default_label = false;\n\t\t\t} else {\n\t\t\t\tset_default_label = true;\n\t\t\t}\n\n\t\t\tif (set_default_label) {\n\t\t\t\tsnprintf(default_label, sizeof(default_label),\n\t\t\t\t\t \"%d\", i);\n\t\t\t\tinit_data.default_label = default_label;\n\t\t\t} else {\n\t\t\t\tinit_data.default_label = NULL;\n\t\t\t}\n\n\t\t\terr = devm_led_classdev_register_ext(&client->dev, led,\n\t\t\t\t\t\t\t     &init_data);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tset_bit(i, &pca955x->active_pins);\n\n\t\t\t \n\t\t\tif (pdata->leds[i].default_state == LEDS_DEFSTATE_KEEP) {\n\t\t\t\tif (led->brightness != LED_FULL &&\n\t\t\t\t    led->brightness != LED_OFF &&\n\t\t\t\t    led->brightness != LED_HALF)\n\t\t\t\t\tkeep_pwm = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\terr = pca955x_write_pwm(client, 0, 255 - LED_HALF);\n\tif (err)\n\t\treturn err;\n\n\tif (!keep_pwm) {\n\t\t \n\t\terr = pca955x_write_pwm(client, 1, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = pca955x_write_psc(client, 0, 0);\n\tif (err)\n\t\treturn err;\n\terr = pca955x_write_psc(client, 1, 0);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_LEDS_PCA955X_GPIO\n\tpca955x->gpio.label = \"gpio-pca955x\";\n\tpca955x->gpio.direction_input = pca955x_gpio_direction_input;\n\tpca955x->gpio.direction_output = pca955x_gpio_direction_output;\n\tpca955x->gpio.set = pca955x_gpio_set_value;\n\tpca955x->gpio.get = pca955x_gpio_get_value;\n\tpca955x->gpio.request = pca955x_gpio_request_pin;\n\tpca955x->gpio.free = pca955x_gpio_free_pin;\n\tpca955x->gpio.can_sleep = 1;\n\tpca955x->gpio.base = -1;\n\tpca955x->gpio.ngpio = chip->bits;\n\tpca955x->gpio.parent = &client->dev;\n\tpca955x->gpio.owner = THIS_MODULE;\n\n\terr = devm_gpiochip_add_data(&client->dev, &pca955x->gpio,\n\t\t\t\t     pca955x);\n\tif (err) {\n\t\t \n\t\tpca955x->gpio.parent = NULL;\n\t\tdev_warn(&client->dev, \"could not add gpiochip\\n\");\n\t\treturn err;\n\t}\n\tdev_info(&client->dev, \"gpios %i...%i\\n\",\n\t\t pca955x->gpio.base, pca955x->gpio.base +\n\t\t pca955x->gpio.ngpio - 1);\n#endif\n\n\treturn 0;\n}\n\nstatic struct i2c_driver pca955x_driver = {\n\t.driver = {\n\t\t.name\t= \"leds-pca955x\",\n\t\t.of_match_table = of_pca955x_match,\n\t},\n\t.probe = pca955x_probe,\n\t.id_table = pca955x_id,\n};\n\nmodule_i2c_driver(pca955x_driver);\n\nMODULE_AUTHOR(\"Nate Case <ncase@xes-inc.com>\");\nMODULE_DESCRIPTION(\"PCA955x LED driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}