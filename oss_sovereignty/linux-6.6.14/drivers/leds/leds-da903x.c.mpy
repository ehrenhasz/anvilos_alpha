{
  "module_name": "leds-da903x.c",
  "hash_id": "6212f37e0fd087df00dc986da773fb5cb5e62736ce51962ad86fb67b44671f8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-da903x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/leds.h>\n#include <linux/mfd/da903x.h>\n#include <linux/slab.h>\n\n#define DA9030_LED1_CONTROL\t0x20\n#define DA9030_LED2_CONTROL\t0x21\n#define DA9030_LED3_CONTROL\t0x22\n#define DA9030_LED4_CONTROL\t0x23\n#define DA9030_LEDPC_CONTROL\t0x24\n#define DA9030_MISC_CONTROL_A\t0x26\t \n\n#define DA9034_LED1_CONTROL\t0x35\n#define DA9034_LED2_CONTROL\t0x36\n#define DA9034_VIBRA\t\t0x40\n\nstruct da903x_led {\n\tstruct led_classdev\tcdev;\n\tstruct device\t\t*master;\n\tint\t\t\tid;\n\tint\t\t\tflags;\n};\n\n#define DA9030_LED_OFFSET(id)\t((id) - DA9030_ID_LED_1)\n#define DA9034_LED_OFFSET(id)\t((id) - DA9034_ID_LED_1)\n\nstatic int da903x_led_set(struct led_classdev *led_cdev,\n\t\t\t   enum led_brightness value)\n{\n\tstruct da903x_led *led =\n\t\t\tcontainer_of(led_cdev, struct da903x_led, cdev);\n\tuint8_t val;\n\tint offset, ret = -EINVAL;\n\n\tswitch (led->id) {\n\tcase DA9030_ID_LED_1:\n\tcase DA9030_ID_LED_2:\n\tcase DA9030_ID_LED_3:\n\tcase DA9030_ID_LED_4:\n\tcase DA9030_ID_LED_PC:\n\t\toffset = DA9030_LED_OFFSET(led->id);\n\t\tval = led->flags & ~0x87;\n\t\tval |= value ? 0x80 : 0;  \n\t\tval |= (0x7 - (value >> 5)) & 0x7;  \n\t\tret = da903x_write(led->master, DA9030_LED1_CONTROL + offset,\n\t\t\t\t   val);\n\t\tbreak;\n\tcase DA9030_ID_VIBRA:\n\t\tval = led->flags & ~0x80;\n\t\tval |= value ? 0x80 : 0;  \n\t\tret = da903x_write(led->master, DA9030_MISC_CONTROL_A, val);\n\t\tbreak;\n\tcase DA9034_ID_LED_1:\n\tcase DA9034_ID_LED_2:\n\t\toffset = DA9034_LED_OFFSET(led->id);\n\t\tval = (value * 0x5f / LED_FULL) & 0x7f;\n\t\tval |= (led->flags & DA9034_LED_RAMP) ? 0x80 : 0;\n\t\tret = da903x_write(led->master, DA9034_LED1_CONTROL + offset,\n\t\t\t\t   val);\n\t\tbreak;\n\tcase DA9034_ID_VIBRA:\n\t\tval = value & 0xfe;\n\t\tret = da903x_write(led->master, DA9034_VIBRA, val);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int da903x_led_probe(struct platform_device *pdev)\n{\n\tstruct led_info *pdata = dev_get_platdata(&pdev->dev);\n\tstruct da903x_led *led;\n\tint id, ret;\n\n\tif (pdata == NULL)\n\t\treturn 0;\n\n\tid = pdev->id;\n\n\tif (!((id >= DA9030_ID_LED_1 && id <= DA9030_ID_VIBRA) ||\n\t      (id >= DA9034_ID_LED_1 && id <= DA9034_ID_VIBRA))) {\n\t\tdev_err(&pdev->dev, \"invalid LED ID (%d) specified\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tled = devm_kzalloc(&pdev->dev, sizeof(struct da903x_led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tled->cdev.name = pdata->name;\n\tled->cdev.default_trigger = pdata->default_trigger;\n\tled->cdev.brightness_set_blocking = da903x_led_set;\n\tled->cdev.brightness = LED_OFF;\n\n\tled->id = id;\n\tled->flags = pdata->flags;\n\tled->master = pdev->dev.parent;\n\n\tret = led_classdev_register(led->master, &led->cdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register LED %d\\n\", id);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, led);\n\n\treturn 0;\n}\n\nstatic int da903x_led_remove(struct platform_device *pdev)\n{\n\tstruct da903x_led *led = platform_get_drvdata(pdev);\n\n\tled_classdev_unregister(&led->cdev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver da903x_led_driver = {\n\t.driver\t= {\n\t\t.name\t= \"da903x-led\",\n\t},\n\t.probe\t\t= da903x_led_probe,\n\t.remove\t\t= da903x_led_remove,\n};\n\nmodule_platform_driver(da903x_led_driver);\n\nMODULE_DESCRIPTION(\"LEDs driver for Dialog Semiconductor DA9030/DA9034\");\nMODULE_AUTHOR(\"Eric Miao <eric.miao@marvell.com>\");\nMODULE_AUTHOR(\"Mike Rapoport <mike@compulab.co.il>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da903x-led\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}