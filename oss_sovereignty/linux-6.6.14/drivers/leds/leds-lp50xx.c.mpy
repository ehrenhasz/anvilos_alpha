{
  "module_name": "leds-lp50xx.c",
  "hash_id": "0211d49e5075631dfc67fbedc30fec7bc7b505df10d5d55b54760f3cd5c416b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lp50xx.c",
  "human_readable_source": "\n\n\n\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/leds.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <uapi/linux/uleds.h>\n\n#include <linux/led-class-multicolor.h>\n\n#include \"leds.h\"\n\n#define LP50XX_DEV_CFG0\t\t0x00\n#define LP50XX_DEV_CFG1\t\t0x01\n#define LP50XX_LED_CFG0\t\t0x02\n\n \n#define LP5012_BNK_BRT\t\t0x03\n#define LP5012_BNKA_CLR\t\t0x04\n#define LP5012_BNKB_CLR\t\t0x05\n#define LP5012_BNKC_CLR\t\t0x06\n#define LP5012_LED0_BRT\t\t0x07\n#define LP5012_OUT0_CLR\t\t0x0b\n#define LP5012_RESET\t\t0x17\n\n \n#define LP5024_BNK_BRT\t\t0x03\n#define LP5024_BNKA_CLR\t\t0x04\n#define LP5024_BNKB_CLR\t\t0x05\n#define LP5024_BNKC_CLR\t\t0x06\n#define LP5024_LED0_BRT\t\t0x07\n#define LP5024_OUT0_CLR\t\t0x0f\n#define LP5024_RESET\t\t0x27\n\n \n#define LP5036_LED_CFG1\t\t0x03\n#define LP5036_BNK_BRT\t\t0x04\n#define LP5036_BNKA_CLR\t\t0x05\n#define LP5036_BNKB_CLR\t\t0x06\n#define LP5036_BNKC_CLR\t\t0x07\n#define LP5036_LED0_BRT\t\t0x08\n#define LP5036_OUT0_CLR\t\t0x14\n#define LP5036_RESET\t\t0x38\n\n#define LP50XX_SW_RESET\t\t0xff\n#define LP50XX_CHIP_EN\t\tBIT(6)\n\n \n#define LP50XX_LEDS_PER_MODULE\t3\n\n#define LP5009_MAX_LED_MODULES\t2\n#define LP5012_MAX_LED_MODULES\t4\n#define LP5018_MAX_LED_MODULES\t6\n#define LP5024_MAX_LED_MODULES\t8\n#define LP5030_MAX_LED_MODULES\t10\n#define LP5036_MAX_LED_MODULES\t12\n\nstatic const struct reg_default lp5012_reg_defs[] = {\n\t{LP50XX_DEV_CFG0, 0x0},\n\t{LP50XX_DEV_CFG1, 0x3c},\n\t{LP50XX_LED_CFG0, 0x0},\n\t{LP5012_BNK_BRT, 0xff},\n\t{LP5012_BNKA_CLR, 0x0f},\n\t{LP5012_BNKB_CLR, 0x0f},\n\t{LP5012_BNKC_CLR, 0x0f},\n\t{LP5012_LED0_BRT, 0x0f},\n\t \n\t{0x08, 0xff}, {0x09, 0xff}, {0x0a, 0xff},\n\t{LP5012_OUT0_CLR, 0x0f},\n\t \n\t{0x0c, 0x00}, {0x0d, 0x00}, {0x0e, 0x00}, {0x0f, 0x00}, {0x10, 0x00},\n\t{0x11, 0x00}, {0x12, 0x00}, {0x13, 0x00}, {0x14, 0x00},\t{0x15, 0x00},\n\t{0x16, 0x00},\n\t{LP5012_RESET, 0x00}\n};\n\nstatic const struct reg_default lp5024_reg_defs[] = {\n\t{LP50XX_DEV_CFG0, 0x0},\n\t{LP50XX_DEV_CFG1, 0x3c},\n\t{LP50XX_LED_CFG0, 0x0},\n\t{LP5024_BNK_BRT, 0xff},\n\t{LP5024_BNKA_CLR, 0x0f},\n\t{LP5024_BNKB_CLR, 0x0f},\n\t{LP5024_BNKC_CLR, 0x0f},\n\t{LP5024_LED0_BRT, 0x0f},\n\t \n\t{0x08, 0xff}, {0x09, 0xff}, {0x0a, 0xff}, {0x0b, 0xff}, {0x0c, 0xff},\n\t{0x0d, 0xff}, {0x0e, 0xff},\n\t{LP5024_OUT0_CLR, 0x0f},\n\t \n\t{0x10, 0x00}, {0x11, 0x00}, {0x12, 0x00}, {0x13, 0x00}, {0x14, 0x00},\n\t{0x15, 0x00}, {0x16, 0x00}, {0x17, 0x00}, {0x18, 0x00}, {0x19, 0x00},\n\t{0x1a, 0x00}, {0x1b, 0x00}, {0x1c, 0x00}, {0x1d, 0x00}, {0x1e, 0x00},\n\t{0x1f, 0x00}, {0x20, 0x00}, {0x21, 0x00}, {0x22, 0x00}, {0x23, 0x00},\n\t{0x24, 0x00}, {0x25, 0x00}, {0x26, 0x00},\n\t{LP5024_RESET, 0x00}\n};\n\nstatic const struct reg_default lp5036_reg_defs[] = {\n\t{LP50XX_DEV_CFG0, 0x0},\n\t{LP50XX_DEV_CFG1, 0x3c},\n\t{LP50XX_LED_CFG0, 0x0},\n\t{LP5036_LED_CFG1, 0x0},\n\t{LP5036_BNK_BRT, 0xff},\n\t{LP5036_BNKA_CLR, 0x0f},\n\t{LP5036_BNKB_CLR, 0x0f},\n\t{LP5036_BNKC_CLR, 0x0f},\n\t{LP5036_LED0_BRT, 0x0f},\n\t \n\t{0x08, 0xff}, {0x09, 0xff}, {0x0a, 0xff}, {0x0b, 0xff}, {0x0c, 0xff},\n\t{0x0d, 0xff}, {0x0e, 0xff}, {0x0f, 0xff}, {0x10, 0xff}, {0x11, 0xff},\n\t{0x12, 0xff}, {0x13, 0xff},\n\t{LP5036_OUT0_CLR, 0x0f},\n\t \n\t{0x15, 0x00}, {0x16, 0x00}, {0x17, 0x00}, {0x18, 0x00}, {0x19, 0x00},\n\t{0x1a, 0x00}, {0x1b, 0x00}, {0x1c, 0x00}, {0x1d, 0x00}, {0x1e, 0x00},\n\t{0x1f, 0x00}, {0x20, 0x00}, {0x21, 0x00}, {0x22, 0x00}, {0x23, 0x00},\n\t{0x24, 0x00}, {0x25, 0x00}, {0x26, 0x00}, {0x27, 0x00}, {0x28, 0x00},\n\t{0x29, 0x00}, {0x2a, 0x00}, {0x2b, 0x00}, {0x2c, 0x00}, {0x2d, 0x00},\n\t{0x2e, 0x00}, {0x2f, 0x00}, {0x30, 0x00}, {0x31, 0x00}, {0x32, 0x00},\n\t{0x33, 0x00}, {0x34, 0x00}, {0x35, 0x00}, {0x36, 0x00}, {0x37, 0x00},\n\t{LP5036_RESET, 0x00}\n};\n\nstatic const struct regmap_config lp5012_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = LP5012_RESET,\n\t.reg_defaults = lp5012_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(lp5012_reg_defs),\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config lp5024_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = LP5024_RESET,\n\t.reg_defaults = lp5024_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(lp5024_reg_defs),\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config lp5036_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = LP5036_RESET,\n\t.reg_defaults = lp5036_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(lp5036_reg_defs),\n\t.cache_type = REGCACHE_FLAT,\n};\n\nenum lp50xx_model {\n\tLP5009,\n\tLP5012,\n\tLP5018,\n\tLP5024,\n\tLP5030,\n\tLP5036,\n};\n\n \nstruct lp50xx_chip_info {\n\tconst struct regmap_config *lp50xx_regmap_config;\n\tint model_id;\n\tu8 max_modules;\n\tu8 num_leds;\n\tu8 led_brightness0_reg;\n\tu8 mix_out0_reg;\n\tu8 bank_brt_reg;\n\tu8 bank_mix_reg;\n\tu8 reset_reg;\n};\n\nstatic const struct lp50xx_chip_info lp50xx_chip_info_tbl[] = {\n\t[LP5009] = {\n\t\t.model_id = LP5009,\n\t\t.max_modules = LP5009_MAX_LED_MODULES,\n\t\t.num_leds = LP5009_MAX_LED_MODULES * LP50XX_LEDS_PER_MODULE,\n\t\t.led_brightness0_reg = LP5012_LED0_BRT,\n\t\t.mix_out0_reg = LP5012_OUT0_CLR,\n\t\t.bank_brt_reg = LP5012_BNK_BRT,\n\t\t.bank_mix_reg = LP5012_BNKA_CLR,\n\t\t.reset_reg = LP5012_RESET,\n\t\t.lp50xx_regmap_config = &lp5012_regmap_config,\n\t},\n\t[LP5012] = {\n\t\t.model_id = LP5012,\n\t\t.max_modules = LP5012_MAX_LED_MODULES,\n\t\t.num_leds = LP5012_MAX_LED_MODULES * LP50XX_LEDS_PER_MODULE,\n\t\t.led_brightness0_reg = LP5012_LED0_BRT,\n\t\t.mix_out0_reg = LP5012_OUT0_CLR,\n\t\t.bank_brt_reg = LP5012_BNK_BRT,\n\t\t.bank_mix_reg = LP5012_BNKA_CLR,\n\t\t.reset_reg = LP5012_RESET,\n\t\t.lp50xx_regmap_config = &lp5012_regmap_config,\n\t},\n\t[LP5018] = {\n\t\t.model_id = LP5018,\n\t\t.max_modules = LP5018_MAX_LED_MODULES,\n\t\t.num_leds = LP5018_MAX_LED_MODULES * LP50XX_LEDS_PER_MODULE,\n\t\t.led_brightness0_reg = LP5024_LED0_BRT,\n\t\t.mix_out0_reg = LP5024_OUT0_CLR,\n\t\t.bank_brt_reg = LP5024_BNK_BRT,\n\t\t.bank_mix_reg = LP5024_BNKA_CLR,\n\t\t.reset_reg = LP5024_RESET,\n\t\t.lp50xx_regmap_config = &lp5024_regmap_config,\n\t},\n\t[LP5024] = {\n\t\t.model_id = LP5024,\n\t\t.max_modules = LP5024_MAX_LED_MODULES,\n\t\t.num_leds = LP5024_MAX_LED_MODULES * LP50XX_LEDS_PER_MODULE,\n\t\t.led_brightness0_reg = LP5024_LED0_BRT,\n\t\t.mix_out0_reg = LP5024_OUT0_CLR,\n\t\t.bank_brt_reg = LP5024_BNK_BRT,\n\t\t.bank_mix_reg = LP5024_BNKA_CLR,\n\t\t.reset_reg = LP5024_RESET,\n\t\t.lp50xx_regmap_config = &lp5024_regmap_config,\n\t},\n\t[LP5030] = {\n\t\t.model_id = LP5030,\n\t\t.max_modules = LP5030_MAX_LED_MODULES,\n\t\t.num_leds = LP5030_MAX_LED_MODULES * LP50XX_LEDS_PER_MODULE,\n\t\t.led_brightness0_reg = LP5036_LED0_BRT,\n\t\t.mix_out0_reg = LP5036_OUT0_CLR,\n\t\t.bank_brt_reg = LP5036_BNK_BRT,\n\t\t.bank_mix_reg = LP5036_BNKA_CLR,\n\t\t.reset_reg = LP5036_RESET,\n\t\t.lp50xx_regmap_config = &lp5036_regmap_config,\n\t},\n\t[LP5036] = {\n\t\t.model_id = LP5036,\n\t\t.max_modules = LP5036_MAX_LED_MODULES,\n\t\t.num_leds = LP5036_MAX_LED_MODULES * LP50XX_LEDS_PER_MODULE,\n\t\t.led_brightness0_reg = LP5036_LED0_BRT,\n\t\t.mix_out0_reg = LP5036_OUT0_CLR,\n\t\t.bank_brt_reg = LP5036_BNK_BRT,\n\t\t.bank_mix_reg = LP5036_BNKA_CLR,\n\t\t.reset_reg = LP5036_RESET,\n\t\t.lp50xx_regmap_config = &lp5036_regmap_config,\n\t},\n};\n\nstruct lp50xx_led {\n\tstruct led_classdev_mc mc_cdev;\n\tstruct lp50xx *priv;\n\tunsigned long bank_modules;\n\tu8 ctrl_bank_enabled;\n\tint led_number;\n};\n\n \nstruct lp50xx {\n\tstruct gpio_desc *enable_gpio;\n\tstruct regulator *regulator;\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct mutex lock;\n\tconst struct lp50xx_chip_info *chip_info;\n\tint num_of_banked_leds;\n\n\t \n\tstruct lp50xx_led leds[];\n};\n\nstatic struct lp50xx_led *mcled_cdev_to_led(struct led_classdev_mc *mc_cdev)\n{\n\treturn container_of(mc_cdev, struct lp50xx_led, mc_cdev);\n}\n\nstatic int lp50xx_brightness_set(struct led_classdev *cdev,\n\t\t\t     enum led_brightness brightness)\n{\n\tstruct led_classdev_mc *mc_dev = lcdev_to_mccdev(cdev);\n\tstruct lp50xx_led *led = mcled_cdev_to_led(mc_dev);\n\tconst struct lp50xx_chip_info *led_chip = led->priv->chip_info;\n\tu8 led_offset, reg_val;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&led->priv->lock);\n\tif (led->ctrl_bank_enabled)\n\t\treg_val = led_chip->bank_brt_reg;\n\telse\n\t\treg_val = led_chip->led_brightness0_reg +\n\t\t\t  led->led_number;\n\n\tret = regmap_write(led->priv->regmap, reg_val, brightness);\n\tif (ret) {\n\t\tdev_err(led->priv->dev,\n\t\t\t\"Cannot write brightness value %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < led->mc_cdev.num_colors; i++) {\n\t\tif (led->ctrl_bank_enabled) {\n\t\t\treg_val = led_chip->bank_mix_reg + i;\n\t\t} else {\n\t\t\tled_offset = (led->led_number * 3) + i;\n\t\t\treg_val = led_chip->mix_out0_reg + led_offset;\n\t\t}\n\n\t\tret = regmap_write(led->priv->regmap, reg_val,\n\t\t\t\t   mc_dev->subled_info[i].intensity);\n\t\tif (ret) {\n\t\t\tdev_err(led->priv->dev,\n\t\t\t\t\"Cannot write intensity value %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&led->priv->lock);\n\treturn ret;\n}\n\nstatic int lp50xx_set_banks(struct lp50xx *priv, u32 led_banks[])\n{\n\tu8 led_config_lo, led_config_hi;\n\tu32 bank_enable_mask = 0;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < priv->chip_info->max_modules; i++) {\n\t\tif (led_banks[i])\n\t\t\tbank_enable_mask |= (1 << led_banks[i]);\n\t}\n\n\tled_config_lo = bank_enable_mask;\n\tled_config_hi = bank_enable_mask >> 8;\n\n\tret = regmap_write(priv->regmap, LP50XX_LED_CFG0, led_config_lo);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->chip_info->model_id >= LP5030)\n\t\tret = regmap_write(priv->regmap, LP5036_LED_CFG1, led_config_hi);\n\n\treturn ret;\n}\n\nstatic int lp50xx_reset(struct lp50xx *priv)\n{\n\treturn regmap_write(priv->regmap, priv->chip_info->reset_reg, LP50XX_SW_RESET);\n}\n\nstatic int lp50xx_enable_disable(struct lp50xx *priv, int enable_disable)\n{\n\tint ret;\n\n\tret = gpiod_direction_output(priv->enable_gpio, enable_disable);\n\tif (ret)\n\t\treturn ret;\n\n\tif (enable_disable)\n\t\treturn regmap_write(priv->regmap, LP50XX_DEV_CFG0, LP50XX_CHIP_EN);\n\telse\n\t\treturn regmap_write(priv->regmap, LP50XX_DEV_CFG0, 0);\n\n}\n\nstatic int lp50xx_probe_leds(struct fwnode_handle *child, struct lp50xx *priv,\n\t\t\t     struct lp50xx_led *led, int num_leds)\n{\n\tu32 led_banks[LP5036_MAX_LED_MODULES] = {0};\n\tint led_number;\n\tint ret;\n\n\tif (num_leds > 1) {\n\t\tif (num_leds > priv->chip_info->max_modules) {\n\t\t\tdev_err(priv->dev, \"reg property is invalid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpriv->num_of_banked_leds = num_leds;\n\n\t\tret = fwnode_property_read_u32_array(child, \"reg\", led_banks, num_leds);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"reg property is missing\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = lp50xx_set_banks(priv, led_banks);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"Cannot setup banked LEDs\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tled->ctrl_bank_enabled = 1;\n\t} else {\n\t\tret = fwnode_property_read_u32(child, \"reg\", &led_number);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"led reg property missing\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (led_number > priv->chip_info->num_leds) {\n\t\t\tdev_err(priv->dev, \"led-sources property is invalid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tled->led_number = led_number;\n\t}\n\n\treturn 0;\n}\n\nstatic int lp50xx_probe_dt(struct lp50xx *priv)\n{\n\tstruct fwnode_handle *child = NULL;\n\tstruct fwnode_handle *led_node = NULL;\n\tstruct led_init_data init_data = {};\n\tstruct led_classdev *led_cdev;\n\tstruct mc_subled *mc_led_info;\n\tstruct lp50xx_led *led;\n\tint ret = -EINVAL;\n\tint num_colors;\n\tu32 color_id;\n\tint i = 0;\n\n\tpriv->enable_gpio = devm_gpiod_get_optional(priv->dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->enable_gpio))\n\t\treturn dev_err_probe(priv->dev, PTR_ERR(priv->enable_gpio),\n\t\t\t\t     \"Failed to get enable GPIO\\n\");\n\n\tpriv->regulator = devm_regulator_get(priv->dev, \"vled\");\n\tif (IS_ERR(priv->regulator))\n\t\tpriv->regulator = NULL;\n\n\tdevice_for_each_child_node(priv->dev, child) {\n\t\tled = &priv->leds[i];\n\t\tret = fwnode_property_count_u32(child, \"reg\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(priv->dev, \"reg property is invalid\\n\");\n\t\t\tgoto child_out;\n\t\t}\n\n\t\tret = lp50xx_probe_leds(child, priv, led, ret);\n\t\tif (ret)\n\t\t\tgoto child_out;\n\n\t\tinit_data.fwnode = child;\n\t\tnum_colors = 0;\n\n\t\t \n\t\tmc_led_info = devm_kcalloc(priv->dev, LP50XX_LEDS_PER_MODULE,\n\t\t\t\t\t   sizeof(*mc_led_info), GFP_KERNEL);\n\t\tif (!mc_led_info) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto child_out;\n\t\t}\n\n\t\tfwnode_for_each_child_node(child, led_node) {\n\t\t\tret = fwnode_property_read_u32(led_node, \"color\",\n\t\t\t\t\t\t       &color_id);\n\t\t\tif (ret) {\n\t\t\t\tfwnode_handle_put(led_node);\n\t\t\t\tdev_err(priv->dev, \"Cannot read color\\n\");\n\t\t\t\tgoto child_out;\n\t\t\t}\n\n\t\t\tmc_led_info[num_colors].color_index = color_id;\n\t\t\tnum_colors++;\n\t\t}\n\n\t\tled->priv = priv;\n\t\tled->mc_cdev.num_colors = num_colors;\n\t\tled->mc_cdev.subled_info = mc_led_info;\n\t\tled_cdev = &led->mc_cdev.led_cdev;\n\t\tled_cdev->brightness_set_blocking = lp50xx_brightness_set;\n\n\t\tret = devm_led_classdev_multicolor_register_ext(priv->dev,\n\t\t\t\t\t\t       &led->mc_cdev,\n\t\t\t\t\t\t       &init_data);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"led register err: %d\\n\", ret);\n\t\t\tgoto child_out;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn 0;\n\nchild_out:\n\tfwnode_handle_put(child);\n\treturn ret;\n}\n\nstatic int lp50xx_probe(struct i2c_client *client)\n{\n\tstruct lp50xx *led;\n\tint count;\n\tint ret;\n\n\tcount = device_get_child_node_count(&client->dev);\n\tif (!count) {\n\t\tdev_err(&client->dev, \"LEDs are not defined in device tree!\");\n\t\treturn -ENODEV;\n\t}\n\n\tled = devm_kzalloc(&client->dev, struct_size(led, leds, count),\n\t\t\t   GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&led->lock);\n\tled->client = client;\n\tled->dev = &client->dev;\n\tled->chip_info = device_get_match_data(&client->dev);\n\ti2c_set_clientdata(client, led);\n\tled->regmap = devm_regmap_init_i2c(client,\n\t\t\t\t\tled->chip_info->lp50xx_regmap_config);\n\tif (IS_ERR(led->regmap)) {\n\t\tret = PTR_ERR(led->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = lp50xx_reset(led);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lp50xx_enable_disable(led, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lp50xx_probe_dt(led);\n}\n\nstatic void lp50xx_remove(struct i2c_client *client)\n{\n\tstruct lp50xx *led = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = lp50xx_enable_disable(led, 0);\n\tif (ret)\n\t\tdev_err(led->dev, \"Failed to disable chip\\n\");\n\n\tif (led->regulator) {\n\t\tret = regulator_disable(led->regulator);\n\t\tif (ret)\n\t\t\tdev_err(led->dev, \"Failed to disable regulator\\n\");\n\t}\n\n\tmutex_destroy(&led->lock);\n}\n\nstatic const struct i2c_device_id lp50xx_id[] = {\n\t{ \"lp5009\", (kernel_ulong_t)&lp50xx_chip_info_tbl[LP5009] },\n\t{ \"lp5012\", (kernel_ulong_t)&lp50xx_chip_info_tbl[LP5012] },\n\t{ \"lp5018\", (kernel_ulong_t)&lp50xx_chip_info_tbl[LP5018] },\n\t{ \"lp5024\", (kernel_ulong_t)&lp50xx_chip_info_tbl[LP5024] },\n\t{ \"lp5030\", (kernel_ulong_t)&lp50xx_chip_info_tbl[LP5030] },\n\t{ \"lp5036\", (kernel_ulong_t)&lp50xx_chip_info_tbl[LP5036] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lp50xx_id);\n\nstatic const struct of_device_id of_lp50xx_leds_match[] = {\n\t{ .compatible = \"ti,lp5009\", .data = &lp50xx_chip_info_tbl[LP5009] },\n\t{ .compatible = \"ti,lp5012\", .data = &lp50xx_chip_info_tbl[LP5012] },\n\t{ .compatible = \"ti,lp5018\", .data = &lp50xx_chip_info_tbl[LP5018] },\n\t{ .compatible = \"ti,lp5024\", .data = &lp50xx_chip_info_tbl[LP5024] },\n\t{ .compatible = \"ti,lp5030\", .data = &lp50xx_chip_info_tbl[LP5030] },\n\t{ .compatible = \"ti,lp5036\", .data = &lp50xx_chip_info_tbl[LP5036] },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_lp50xx_leds_match);\n\nstatic struct i2c_driver lp50xx_driver = {\n\t.driver = {\n\t\t.name\t= \"lp50xx\",\n\t\t.of_match_table = of_lp50xx_leds_match,\n\t},\n\t.probe\t\t= lp50xx_probe,\n\t.remove\t\t= lp50xx_remove,\n\t.id_table\t= lp50xx_id,\n};\nmodule_i2c_driver(lp50xx_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments LP50XX LED driver\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}