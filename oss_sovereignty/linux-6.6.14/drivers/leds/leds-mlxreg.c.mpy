{
  "module_name": "leds-mlxreg.c",
  "hash_id": "9da6ee0947b12eb32d394a8ac62114ab00d2fd15e15e4e3340c05437beca8c18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-mlxreg.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/platform_data/mlxreg.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define MLXREG_LED_OFFSET_BLINK_3HZ\t0x01  \n#define MLXREG_LED_OFFSET_BLINK_6HZ\t0x02  \n#define MLXREG_LED_IS_OFF\t\t0x00  \n#define MLXREG_LED_RED_SOLID\t\t0x05  \n#define MLXREG_LED_GREEN_SOLID\t\t0x0D  \n#define MLXREG_LED_AMBER_SOLID\t\t0x09  \n#define MLXREG_LED_BLINK_3HZ\t\t167  \n#define MLXREG_LED_BLINK_6HZ\t\t83  \n#define MLXREG_LED_CAPABILITY_CLEAR\tGENMASK(31, 8)  \n\n \nstruct mlxreg_led_data {\n\tstruct mlxreg_core_data *data;\n\tstruct led_classdev led_cdev;\n\tu8 base_color;\n\tvoid *data_parent;\n\tchar led_cdev_name[MLXREG_CORE_LABEL_MAX_SIZE];\n};\n\n#define cdev_to_priv(c) container_of(c, struct mlxreg_led_data, led_cdev)\n\n \nstruct mlxreg_led_priv_data {\n\tstruct platform_device *pdev;\n\tstruct mlxreg_core_platform_data *pdata;\n\tstruct mutex access_lock;  \n};\n\nstatic int\nmlxreg_led_store_hw(struct mlxreg_led_data *led_data, u8 vset)\n{\n\tstruct mlxreg_led_priv_data *priv = led_data->data_parent;\n\tstruct mlxreg_core_platform_data *led_pdata = priv->pdata;\n\tstruct mlxreg_core_data *data = led_data->data;\n\tu32 regval;\n\tu32 nib;\n\tint ret;\n\n\t \n\tmutex_lock(&priv->access_lock);\n\n\tret = regmap_read(led_pdata->regmap, data->reg, &regval);\n\tif (ret)\n\t\tgoto access_error;\n\n\tnib = (ror32(data->mask, data->bit) == 0xf0) ? rol32(vset, data->bit) :\n\t      rol32(vset, data->bit + 4);\n\tregval = (regval & data->mask) | nib;\n\n\tret = regmap_write(led_pdata->regmap, data->reg, regval);\n\naccess_error:\n\tmutex_unlock(&priv->access_lock);\n\n\treturn ret;\n}\n\nstatic enum led_brightness\nmlxreg_led_get_hw(struct mlxreg_led_data *led_data)\n{\n\tstruct mlxreg_led_priv_data *priv = led_data->data_parent;\n\tstruct mlxreg_core_platform_data *led_pdata = priv->pdata;\n\tstruct mlxreg_core_data *data = led_data->data;\n\tu32 regval;\n\tint err;\n\n\t \n\terr = regmap_read(led_pdata->regmap, data->reg, &regval);\n\tif (err < 0) {\n\t\tdev_warn(led_data->led_cdev.dev, \"Failed to get current brightness, error: %d\\n\",\n\t\t\t err);\n\t\t \n\t\treturn LED_OFF;\n\t}\n\n\tregval = regval & ~data->mask;\n\tregval = (ror32(data->mask, data->bit) == 0xf0) ? ror32(regval,\n\t\t data->bit) : ror32(regval, data->bit + 4);\n\tif (regval >= led_data->base_color &&\n\t    regval <= (led_data->base_color + MLXREG_LED_OFFSET_BLINK_6HZ))\n\t\treturn LED_FULL;\n\n\treturn LED_OFF;\n}\n\nstatic int\nmlxreg_led_brightness_set(struct led_classdev *cled, enum led_brightness value)\n{\n\tstruct mlxreg_led_data *led_data = cdev_to_priv(cled);\n\n\tif (value)\n\t\treturn mlxreg_led_store_hw(led_data, led_data->base_color);\n\telse\n\t\treturn mlxreg_led_store_hw(led_data, MLXREG_LED_IS_OFF);\n}\n\nstatic enum led_brightness\nmlxreg_led_brightness_get(struct led_classdev *cled)\n{\n\tstruct mlxreg_led_data *led_data = cdev_to_priv(cled);\n\n\treturn mlxreg_led_get_hw(led_data);\n}\n\nstatic int\nmlxreg_led_blink_set(struct led_classdev *cled, unsigned long *delay_on,\n\t\t     unsigned long *delay_off)\n{\n\tstruct mlxreg_led_data *led_data = cdev_to_priv(cled);\n\tint err;\n\n\t \n\tif (!(*delay_on == 0 && *delay_off == 0) &&\n\t    !(*delay_on == MLXREG_LED_BLINK_3HZ &&\n\t      *delay_off == MLXREG_LED_BLINK_3HZ) &&\n\t    !(*delay_on == MLXREG_LED_BLINK_6HZ &&\n\t      *delay_off == MLXREG_LED_BLINK_6HZ))\n\t\treturn -EINVAL;\n\n\tif (*delay_on == MLXREG_LED_BLINK_6HZ)\n\t\terr = mlxreg_led_store_hw(led_data, led_data->base_color +\n\t\t\t\t\t  MLXREG_LED_OFFSET_BLINK_6HZ);\n\telse if (*delay_on == MLXREG_LED_BLINK_3HZ)\n\t\terr = mlxreg_led_store_hw(led_data, led_data->base_color +\n\t\t\t\t\t  MLXREG_LED_OFFSET_BLINK_3HZ);\n\telse\n\t\terr = mlxreg_led_store_hw(led_data, led_data->base_color);\n\n\treturn err;\n}\n\nstatic int mlxreg_led_config(struct mlxreg_led_priv_data *priv)\n{\n\tstruct mlxreg_core_platform_data *led_pdata = priv->pdata;\n\tstruct mlxreg_core_data *data = led_pdata->data;\n\tstruct mlxreg_led_data *led_data;\n\tstruct led_classdev *led_cdev;\n\tenum led_brightness brightness;\n\tu32 regval;\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < led_pdata->counter; i++, data++) {\n\t\tled_data = devm_kzalloc(&priv->pdev->dev, sizeof(*led_data),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!led_data)\n\t\t\treturn -ENOMEM;\n\n\t\tif (data->capability) {\n\t\t\terr = regmap_read(led_pdata->regmap, data->capability,\n\t\t\t\t\t  &regval);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&priv->pdev->dev, \"Failed to query capability register\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (!(regval & data->bit))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tdata->bit &= MLXREG_LED_CAPABILITY_CLEAR;\n\t\t}\n\n\t\tled_cdev = &led_data->led_cdev;\n\t\tled_data->data_parent = priv;\n\t\tif (strstr(data->label, \"red\") ||\n\t\t    strstr(data->label, \"orange\")) {\n\t\t\tbrightness = LED_OFF;\n\t\t\tled_data->base_color = MLXREG_LED_RED_SOLID;\n\t\t} else if (strstr(data->label, \"amber\")) {\n\t\t\tbrightness = LED_OFF;\n\t\t\tled_data->base_color = MLXREG_LED_AMBER_SOLID;\n\t\t} else {\n\t\t\tbrightness = LED_OFF;\n\t\t\tled_data->base_color = MLXREG_LED_GREEN_SOLID;\n\t\t}\n\t\tsnprintf(led_data->led_cdev_name, sizeof(led_data->led_cdev_name),\n\t\t\t \"mlxreg:%s\", data->label);\n\t\tled_cdev->name = led_data->led_cdev_name;\n\t\tled_cdev->brightness = brightness;\n\t\tled_cdev->max_brightness = LED_ON;\n\t\tled_cdev->brightness_set_blocking =\n\t\t\t\t\t\tmlxreg_led_brightness_set;\n\t\tled_cdev->brightness_get = mlxreg_led_brightness_get;\n\t\tled_cdev->blink_set = mlxreg_led_blink_set;\n\t\tled_cdev->flags = LED_CORE_SUSPENDRESUME;\n\t\tled_data->data = data;\n\t\terr = devm_led_classdev_register(&priv->pdev->dev, led_cdev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (led_cdev->brightness)\n\t\t\tmlxreg_led_brightness_set(led_cdev,\n\t\t\t\t\t\t  led_cdev->brightness);\n\t\tdev_info(led_cdev->dev, \"label: %s, mask: 0x%02x, offset:0x%02x\\n\",\n\t\t\t data->label, data->mask, data->reg);\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxreg_led_probe(struct platform_device *pdev)\n{\n\tstruct mlxreg_core_platform_data *led_pdata;\n\tstruct mlxreg_led_priv_data *priv;\n\n\tled_pdata = dev_get_platdata(&pdev->dev);\n\tif (!led_pdata) {\n\t\tdev_err(&pdev->dev, \"Failed to get platform data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->access_lock);\n\tpriv->pdev = pdev;\n\tpriv->pdata = led_pdata;\n\n\treturn mlxreg_led_config(priv);\n}\n\nstatic int mlxreg_led_remove(struct platform_device *pdev)\n{\n\tstruct mlxreg_led_priv_data *priv = dev_get_drvdata(&pdev->dev);\n\n\tmutex_destroy(&priv->access_lock);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mlxreg_led_driver = {\n\t.driver = {\n\t    .name = \"leds-mlxreg\",\n\t},\n\t.probe = mlxreg_led_probe,\n\t.remove = mlxreg_led_remove,\n};\n\nmodule_platform_driver(mlxreg_led_driver);\n\nMODULE_AUTHOR(\"Vadim Pasternak <vadimp@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox LED regmap driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"platform:leds-mlxreg\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}