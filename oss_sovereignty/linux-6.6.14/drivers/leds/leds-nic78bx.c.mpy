{
  "module_name": "leds-nic78bx.c",
  "hash_id": "221e44770fd401eab66a25ebc245cf36b0fad2f6b1b838ee03945231f4b261b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-nic78bx.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#define NIC78BX_USER1_LED_MASK\t\t0x3\n#define NIC78BX_USER1_GREEN_LED\t\tBIT(0)\n#define NIC78BX_USER1_YELLOW_LED\tBIT(1)\n\n#define NIC78BX_USER2_LED_MASK\t\t0xC\n#define NIC78BX_USER2_GREEN_LED\t\tBIT(2)\n#define NIC78BX_USER2_YELLOW_LED\tBIT(3)\n\n#define NIC78BX_LOCK_REG_OFFSET\t\t1\n#define NIC78BX_LOCK_VALUE\t\t0xA5\n#define NIC78BX_UNLOCK_VALUE\t\t0x5A\n\n#define NIC78BX_USER_LED_IO_SIZE\t2\n\nstruct nic78bx_led_data {\n\tu16 io_base;\n\tspinlock_t lock;\n\tstruct platform_device *pdev;\n};\n\nstruct nic78bx_led {\n\tu8 bit;\n\tu8 mask;\n\tstruct nic78bx_led_data *data;\n\tstruct led_classdev cdev;\n};\n\nstatic inline struct nic78bx_led *to_nic78bx_led(struct led_classdev *cdev)\n{\n\treturn container_of(cdev, struct nic78bx_led, cdev);\n}\n\nstatic void nic78bx_brightness_set(struct led_classdev *cdev,\n\t\t\t\t  enum led_brightness brightness)\n{\n\tstruct nic78bx_led *nled = to_nic78bx_led(cdev);\n\tunsigned long flags;\n\tu8 value;\n\n\tspin_lock_irqsave(&nled->data->lock, flags);\n\tvalue = inb(nled->data->io_base);\n\n\tif (brightness) {\n\t\tvalue &= ~nled->mask;\n\t\tvalue |= nled->bit;\n\t} else {\n\t\tvalue &= ~nled->bit;\n\t}\n\n\toutb(value, nled->data->io_base);\n\tspin_unlock_irqrestore(&nled->data->lock, flags);\n}\n\nstatic enum led_brightness nic78bx_brightness_get(struct led_classdev *cdev)\n{\n\tstruct nic78bx_led *nled = to_nic78bx_led(cdev);\n\tunsigned long flags;\n\tu8 value;\n\n\tspin_lock_irqsave(&nled->data->lock, flags);\n\tvalue = inb(nled->data->io_base);\n\tspin_unlock_irqrestore(&nled->data->lock, flags);\n\n\treturn (value & nled->bit) ? 1 : LED_OFF;\n}\n\nstatic struct nic78bx_led nic78bx_leds[] = {\n\t{\n\t\t.bit = NIC78BX_USER1_GREEN_LED,\n\t\t.mask = NIC78BX_USER1_LED_MASK,\n\t\t.cdev = {\n\t\t\t.name = \"nilrt:green:user1\",\n\t\t\t.max_brightness = 1,\n\t\t\t.brightness_set = nic78bx_brightness_set,\n\t\t\t.brightness_get = nic78bx_brightness_get,\n\t\t}\n\t},\n\t{\n\t\t.bit = NIC78BX_USER1_YELLOW_LED,\n\t\t.mask = NIC78BX_USER1_LED_MASK,\n\t\t.cdev = {\n\t\t\t.name = \"nilrt:yellow:user1\",\n\t\t\t.max_brightness = 1,\n\t\t\t.brightness_set = nic78bx_brightness_set,\n\t\t\t.brightness_get = nic78bx_brightness_get,\n\t\t}\n\t},\n\t{\n\t\t.bit = NIC78BX_USER2_GREEN_LED,\n\t\t.mask = NIC78BX_USER2_LED_MASK,\n\t\t.cdev = {\n\t\t\t.name = \"nilrt:green:user2\",\n\t\t\t.max_brightness = 1,\n\t\t\t.brightness_set = nic78bx_brightness_set,\n\t\t\t.brightness_get = nic78bx_brightness_get,\n\t\t}\n\t},\n\t{\n\t\t.bit = NIC78BX_USER2_YELLOW_LED,\n\t\t.mask = NIC78BX_USER2_LED_MASK,\n\t\t.cdev = {\n\t\t\t.name = \"nilrt:yellow:user2\",\n\t\t\t.max_brightness = 1,\n\t\t\t.brightness_set = nic78bx_brightness_set,\n\t\t\t.brightness_get = nic78bx_brightness_get,\n\t\t}\n\t}\n};\n\nstatic int nic78bx_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct nic78bx_led_data *led_data;\n\tstruct resource *io_rc;\n\tint ret, i;\n\n\tled_data = devm_kzalloc(dev, sizeof(*led_data), GFP_KERNEL);\n\tif (!led_data)\n\t\treturn -ENOMEM;\n\n\tled_data->pdev = pdev;\n\tplatform_set_drvdata(pdev, led_data);\n\n\tio_rc = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!io_rc) {\n\t\tdev_err(dev, \"missing IO resources\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (resource_size(io_rc) < NIC78BX_USER_LED_IO_SIZE) {\n\t\tdev_err(dev, \"IO region too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!devm_request_region(dev, io_rc->start, resource_size(io_rc),\n\t\t\t\t KBUILD_MODNAME)) {\n\t\tdev_err(dev, \"failed to get IO region\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tled_data->io_base = io_rc->start;\n\tspin_lock_init(&led_data->lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(nic78bx_leds); i++) {\n\t\tnic78bx_leds[i].data = led_data;\n\n\t\tret = devm_led_classdev_register(dev, &nic78bx_leds[i].cdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\toutb(NIC78BX_UNLOCK_VALUE,\n\t     led_data->io_base + NIC78BX_LOCK_REG_OFFSET);\n\n\treturn ret;\n}\n\nstatic int nic78bx_remove(struct platform_device *pdev)\n{\n\tstruct nic78bx_led_data *led_data = platform_get_drvdata(pdev);\n\n\t \n\toutb(NIC78BX_LOCK_VALUE,\n\t     led_data->io_base + NIC78BX_LOCK_REG_OFFSET);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id led_device_ids[] = {\n\t{\"NIC78B3\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, led_device_ids);\n\nstatic struct platform_driver led_driver = {\n\t.probe = nic78bx_probe,\n\t.remove = nic78bx_remove,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.acpi_match_table = ACPI_PTR(led_device_ids),\n\t},\n};\n\nmodule_platform_driver(led_driver);\n\nMODULE_DESCRIPTION(\"National Instruments PXI User LEDs driver\");\nMODULE_AUTHOR(\"Hui Chun Ong <hui.chun.ong@ni.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}