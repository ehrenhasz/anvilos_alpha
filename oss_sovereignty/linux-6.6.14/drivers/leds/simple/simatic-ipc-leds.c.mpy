{
  "module_name": "simatic-ipc-leds.c",
  "hash_id": "de5f509121a7e9c55a5b4fa1b70f79528949e5a6cad2e8e0e860ae1a9e73238d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/simple/simatic-ipc-leds.c",
  "human_readable_source": "\n \n\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_data/x86/simatic-ipc-base.h>\n#include <linux/platform_device.h>\n#include <linux/sizes.h>\n#include <linux/spinlock.h>\n\n#define SIMATIC_IPC_LED_PORT_BASE\t0x404E\n\nstruct simatic_ipc_led {\n\tunsigned int value;  \n\tchar *name;\n\tstruct led_classdev cdev;\n};\n\nstatic struct simatic_ipc_led simatic_ipc_leds_io[] = {\n\t{1 << 15, \"green:\" LED_FUNCTION_STATUS \"-1\" },\n\t{1 << 7,  \"yellow:\" LED_FUNCTION_STATUS \"-1\" },\n\t{1 << 14, \"red:\" LED_FUNCTION_STATUS \"-2\" },\n\t{1 << 6,  \"yellow:\" LED_FUNCTION_STATUS \"-2\" },\n\t{1 << 13, \"red:\" LED_FUNCTION_STATUS \"-3\" },\n\t{1 << 5,  \"yellow:\" LED_FUNCTION_STATUS \"-3\" },\n\t{ }\n};\n\nstatic struct resource simatic_ipc_led_io_res =\n\tDEFINE_RES_IO_NAMED(SIMATIC_IPC_LED_PORT_BASE, SZ_2, KBUILD_MODNAME);\n\nstatic DEFINE_SPINLOCK(reg_lock);\n\nstatic inline struct simatic_ipc_led *cdev_to_led(struct led_classdev *led_cd)\n{\n\treturn container_of(led_cd, struct simatic_ipc_led, cdev);\n}\n\nstatic void simatic_ipc_led_set_io(struct led_classdev *led_cd,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct simatic_ipc_led *led = cdev_to_led(led_cd);\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(&reg_lock, flags);\n\n\tval = inw(SIMATIC_IPC_LED_PORT_BASE);\n\tif (brightness == LED_OFF)\n\t\toutw(val | led->value, SIMATIC_IPC_LED_PORT_BASE);\n\telse\n\t\toutw(val & ~led->value, SIMATIC_IPC_LED_PORT_BASE);\n\n\tspin_unlock_irqrestore(&reg_lock, flags);\n}\n\nstatic enum led_brightness simatic_ipc_led_get_io(struct led_classdev *led_cd)\n{\n\tstruct simatic_ipc_led *led = cdev_to_led(led_cd);\n\n\treturn inw(SIMATIC_IPC_LED_PORT_BASE) & led->value ? LED_OFF : led_cd->max_brightness;\n}\n\nstatic int simatic_ipc_leds_probe(struct platform_device *pdev)\n{\n\tconst struct simatic_ipc_platform *plat = pdev->dev.platform_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct simatic_ipc_led *ipcled;\n\tstruct led_classdev *cdev;\n\tstruct resource *res;\n\tint err;\n\n\tswitch (plat->devmode) {\n\tcase SIMATIC_IPC_DEVICE_227D:\n\tcase SIMATIC_IPC_DEVICE_427E:\n\t\tres = &simatic_ipc_led_io_res;\n\t\tipcled = simatic_ipc_leds_io;\n\t\t \n\t\tif (plat->devmode == SIMATIC_IPC_DEVICE_227D) {\n\t\t\twhile (ipcled->value) {\n\t\t\t\tipcled->value = swab16(ipcled->value);\n\t\t\t\tipcled++;\n\t\t\t}\n\t\t\tipcled = simatic_ipc_leds_io;\n\t\t}\n\t\tif (!devm_request_region(dev, res->start, resource_size(res), KBUILD_MODNAME)) {\n\t\t\tdev_err(dev, \"Unable to register IO resource at %pR\\n\", res);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\twhile (ipcled->value) {\n\t\tcdev = &ipcled->cdev;\n\t\tcdev->brightness_set = simatic_ipc_led_set_io;\n\t\tcdev->brightness_get = simatic_ipc_led_get_io;\n\t\tcdev->max_brightness = LED_ON;\n\t\tcdev->name = ipcled->name;\n\n\t\terr = devm_led_classdev_register(dev, cdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tipcled++;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver simatic_ipc_led_driver = {\n\t.probe = simatic_ipc_leds_probe,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t}\n};\nmodule_platform_driver(simatic_ipc_led_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" KBUILD_MODNAME);\nMODULE_AUTHOR(\"Henning Schild <henning.schild@siemens.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}