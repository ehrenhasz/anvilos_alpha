{
  "module_name": "leds-pwm.c",
  "hash_id": "4bfcc34c12b860ba1d5e43bc1eae91ec1824adbd0b4b2c49980ef3f7c461b762",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-pwm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/leds.h>\n#include <linux/err.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n#include \"leds.h\"\n\nstruct led_pwm {\n\tconst char\t*name;\n\tu8\t\tactive_low;\n\tu8\t\tdefault_state;\n\tunsigned int\tmax_brightness;\n};\n\nstruct led_pwm_data {\n\tstruct led_classdev\tcdev;\n\tstruct pwm_device\t*pwm;\n\tstruct pwm_state\tpwmstate;\n\tunsigned int\t\tactive_low;\n};\n\nstruct led_pwm_priv {\n\tint num_leds;\n\tstruct led_pwm_data leds[];\n};\n\nstatic int led_pwm_set(struct led_classdev *led_cdev,\n\t\t       enum led_brightness brightness)\n{\n\tstruct led_pwm_data *led_dat =\n\t\tcontainer_of(led_cdev, struct led_pwm_data, cdev);\n\tunsigned int max = led_dat->cdev.max_brightness;\n\tunsigned long long duty = led_dat->pwmstate.period;\n\n\tduty *= brightness;\n\tdo_div(duty, max);\n\n\tif (led_dat->active_low)\n\t\tduty = led_dat->pwmstate.period - duty;\n\n\tled_dat->pwmstate.duty_cycle = duty;\n\tled_dat->pwmstate.enabled = true;\n\treturn pwm_apply_state(led_dat->pwm, &led_dat->pwmstate);\n}\n\n__attribute__((nonnull))\nstatic int led_pwm_add(struct device *dev, struct led_pwm_priv *priv,\n\t\t       struct led_pwm *led, struct fwnode_handle *fwnode)\n{\n\tstruct led_pwm_data *led_data = &priv->leds[priv->num_leds];\n\tstruct led_init_data init_data = { .fwnode = fwnode };\n\tint ret;\n\n\tled_data->active_low = led->active_low;\n\tled_data->cdev.name = led->name;\n\tled_data->cdev.brightness = LED_OFF;\n\tled_data->cdev.max_brightness = led->max_brightness;\n\tled_data->cdev.flags = LED_CORE_SUSPENDRESUME;\n\n\tled_data->pwm = devm_fwnode_pwm_get(dev, fwnode, NULL);\n\tif (IS_ERR(led_data->pwm))\n\t\treturn dev_err_probe(dev, PTR_ERR(led_data->pwm),\n\t\t\t\t     \"unable to request PWM for %s\\n\",\n\t\t\t\t     led->name);\n\n\tled_data->cdev.brightness_set_blocking = led_pwm_set;\n\n\t \n\tswitch (led->default_state) {\n\tcase LEDS_DEFSTATE_KEEP:\n\t\tpwm_get_state(led_data->pwm, &led_data->pwmstate);\n\t\tif (led_data->pwmstate.period)\n\t\t\tbreak;\n\t\tled->default_state = LEDS_DEFSTATE_OFF;\n\t\tdev_warn(dev,\n\t\t\t\"failed to read period for %s, default to off\",\n\t\t\tled->name);\n\t\tfallthrough;\n\tdefault:\n\t\tpwm_init_state(led_data->pwm, &led_data->pwmstate);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (led->default_state) {\n\tcase LEDS_DEFSTATE_ON:\n\t\tled_data->cdev.brightness = led->max_brightness;\n\t\tbreak;\n\tcase LEDS_DEFSTATE_KEEP:\n\t\t{\n\t\tuint64_t brightness;\n\n\t\tbrightness = led->max_brightness;\n\t\tbrightness *= led_data->pwmstate.duty_cycle;\n\t\tdo_div(brightness, led_data->pwmstate.period);\n\t\tled_data->cdev.brightness = brightness;\n\t\t}\n\t\tbreak;\n\t}\n\n\tret = devm_led_classdev_register_ext(dev, &led_data->cdev, &init_data);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register PWM led for %s: %d\\n\",\n\t\t\tled->name, ret);\n\t\treturn ret;\n\t}\n\n\tif (led->default_state != LEDS_DEFSTATE_KEEP) {\n\t\tret = led_pwm_set(&led_data->cdev, led_data->cdev.brightness);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to set led PWM value for %s: %d\",\n\t\t\t\tled->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpriv->num_leds++;\n\treturn 0;\n}\n\nstatic int led_pwm_create_fwnode(struct device *dev, struct led_pwm_priv *priv)\n{\n\tstruct fwnode_handle *fwnode;\n\tstruct led_pwm led;\n\tint ret;\n\n\tdevice_for_each_child_node(dev, fwnode) {\n\t\tmemset(&led, 0, sizeof(led));\n\n\t\tret = fwnode_property_read_string(fwnode, \"label\", &led.name);\n\t\tif (ret && is_of_node(fwnode))\n\t\t\tled.name = to_of_node(fwnode)->name;\n\n\t\tif (!led.name) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_child_out;\n\t\t}\n\n\t\tled.active_low = fwnode_property_read_bool(fwnode,\n\t\t\t\t\t\t\t   \"active-low\");\n\t\tfwnode_property_read_u32(fwnode, \"max-brightness\",\n\t\t\t\t\t &led.max_brightness);\n\n\t\tled.default_state = led_init_default_state_get(fwnode);\n\n\t\tret = led_pwm_add(dev, priv, &led, fwnode);\n\t\tif (ret)\n\t\t\tgoto err_child_out;\n\t}\n\n\treturn 0;\n\nerr_child_out:\n\tfwnode_handle_put(fwnode);\n\treturn ret;\n}\n\nstatic int led_pwm_probe(struct platform_device *pdev)\n{\n\tstruct led_pwm_priv *priv;\n\tint ret = 0;\n\tint count;\n\n\tcount = device_get_child_node_count(&pdev->dev);\n\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(&pdev->dev, struct_size(priv, leds, count),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tret = led_pwm_create_fwnode(&pdev->dev, priv);\n\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_pwm_leds_match[] = {\n\t{ .compatible = \"pwm-leds\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_pwm_leds_match);\n\nstatic struct platform_driver led_pwm_driver = {\n\t.probe\t\t= led_pwm_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"leds_pwm\",\n\t\t.of_match_table = of_pwm_leds_match,\n\t},\n};\n\nmodule_platform_driver(led_pwm_driver);\n\nMODULE_AUTHOR(\"Luotao Fu <l.fu@pengutronix.de>\");\nMODULE_DESCRIPTION(\"generic PWM LED driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:leds-pwm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}