{
  "module_name": "leds-lm3601x.c",
  "hash_id": "55a3f9899d17a72fac64adb985af56ff9814b2bebd58df0dff36116845e38994",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/flash/leds-lm3601x.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/led-class-flash.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define LM3601X_LED_IR\t\t0x0\n#define LM3601X_LED_TORCH\t0x1\n\n \n#define LM3601X_ENABLE_REG\t0x01\n#define LM3601X_CFG_REG\t\t0x02\n#define LM3601X_LED_FLASH_REG\t0x03\n#define LM3601X_LED_TORCH_REG\t0x04\n#define LM3601X_FLAGS_REG\t0x05\n#define LM3601X_DEV_ID_REG\t0x06\n\n#define LM3601X_SW_RESET\tBIT(7)\n\n \n#define LM3601X_MODE_STANDBY\t0x00\n#define LM3601X_MODE_IR_DRV\tBIT(0)\n#define LM3601X_MODE_TORCH\tBIT(1)\n#define LM3601X_MODE_STROBE\t(BIT(0) | BIT(1))\n#define LM3601X_STRB_EN\t\tBIT(2)\n#define LM3601X_STRB_EDGE_TRIG\tBIT(3)\n#define LM3601X_IVFM_EN\t\tBIT(4)\n\n#define LM36010_BOOST_LIMIT_28\tBIT(5)\n#define LM36010_BOOST_FREQ_4MHZ\tBIT(6)\n#define LM36010_BOOST_MODE_PASS\tBIT(7)\n\n \n#define LM3601X_FLASH_TIME_OUT\tBIT(0)\n#define LM3601X_UVLO_FAULT\tBIT(1)\n#define LM3601X_THERM_SHUTDOWN\tBIT(2)\n#define LM3601X_THERM_CURR\tBIT(3)\n#define LM36010_CURR_LIMIT\tBIT(4)\n#define LM3601X_SHORT_FAULT\tBIT(5)\n#define LM3601X_IVFM_TRIP\tBIT(6)\n#define LM36010_OVP_FAULT\tBIT(7)\n\n#define LM3601X_MAX_TORCH_I_UA\t376000\n#define LM3601X_MIN_TORCH_I_UA\t2400\n#define LM3601X_TORCH_REG_DIV\t2965\n\n#define LM3601X_MAX_STROBE_I_UA\t1500000\n#define LM3601X_MIN_STROBE_I_UA\t11000\n#define LM3601X_STROBE_REG_DIV\t11800\n\n#define LM3601X_TIMEOUT_MASK\t0x1e\n#define LM3601X_ENABLE_MASK\t(LM3601X_MODE_IR_DRV | LM3601X_MODE_TORCH)\n\n#define LM3601X_LOWER_STEP_US\t40000\n#define LM3601X_UPPER_STEP_US\t200000\n#define LM3601X_MIN_TIMEOUT_US\t40000\n#define LM3601X_MAX_TIMEOUT_US\t1600000\n#define LM3601X_TIMEOUT_XOVER_US 400000\n\nenum lm3601x_type {\n\tCHIP_LM36010 = 0,\n\tCHIP_LM36011,\n};\n\n \nstruct lm3601x_led {\n\tstruct led_classdev_flash fled_cdev;\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct mutex lock;\n\n\tunsigned int flash_timeout;\n\tunsigned int last_flag;\n\n\tu32 torch_current_max;\n\tu32 flash_current_max;\n\tu32 max_flash_timeout;\n\n\tu32 led_mode;\n};\n\nstatic const struct reg_default lm3601x_regmap_defs[] = {\n\t{ LM3601X_ENABLE_REG, 0x20 },\n\t{ LM3601X_CFG_REG, 0x15 },\n\t{ LM3601X_LED_FLASH_REG, 0x00 },\n\t{ LM3601X_LED_TORCH_REG, 0x00 },\n};\n\nstatic bool lm3601x_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LM3601X_FLAGS_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config lm3601x_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = LM3601X_DEV_ID_REG,\n\t.reg_defaults = lm3601x_regmap_defs,\n\t.num_reg_defaults = ARRAY_SIZE(lm3601x_regmap_defs),\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = lm3601x_volatile_reg,\n};\n\nstatic struct lm3601x_led *fled_cdev_to_led(struct led_classdev_flash *fled_cdev)\n{\n\treturn container_of(fled_cdev, struct lm3601x_led, fled_cdev);\n}\n\nstatic int lm3601x_read_faults(struct lm3601x_led *led)\n{\n\tint flags_val;\n\tint ret;\n\n\tret = regmap_read(led->regmap, LM3601X_FLAGS_REG, &flags_val);\n\tif (ret < 0)\n\t\treturn -EIO;\n\n\tled->last_flag = 0;\n\n\tif (flags_val & LM36010_OVP_FAULT)\n\t\tled->last_flag |= LED_FAULT_OVER_VOLTAGE;\n\n\tif (flags_val & (LM3601X_THERM_SHUTDOWN | LM3601X_THERM_CURR))\n\t\tled->last_flag |= LED_FAULT_OVER_TEMPERATURE;\n\n\tif (flags_val & LM3601X_SHORT_FAULT)\n\t\tled->last_flag |= LED_FAULT_SHORT_CIRCUIT;\n\n\tif (flags_val & LM36010_CURR_LIMIT)\n\t\tled->last_flag |= LED_FAULT_OVER_CURRENT;\n\n\tif (flags_val & LM3601X_UVLO_FAULT)\n\t\tled->last_flag |= LED_FAULT_UNDER_VOLTAGE;\n\n\tif (flags_val & LM3601X_IVFM_TRIP)\n\t\tled->last_flag |= LED_FAULT_INPUT_VOLTAGE;\n\n\tif (flags_val & LM3601X_THERM_SHUTDOWN)\n\t\tled->last_flag |= LED_FAULT_LED_OVER_TEMPERATURE;\n\n\treturn led->last_flag;\n}\n\nstatic int lm3601x_brightness_set(struct led_classdev *cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(cdev);\n\tstruct lm3601x_led *led = fled_cdev_to_led(fled_cdev);\n\tint ret, led_mode_val;\n\n\tmutex_lock(&led->lock);\n\n\tret = lm3601x_read_faults(led);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (led->led_mode == LM3601X_LED_TORCH)\n\t\tled_mode_val = LM3601X_MODE_TORCH;\n\telse\n\t\tled_mode_val = LM3601X_MODE_IR_DRV;\n\n\tif (brightness == LED_OFF) {\n\t\tret = regmap_update_bits(led->regmap, LM3601X_ENABLE_REG,\n\t\t\t\t\tled_mode_val, LED_OFF);\n\t\tgoto out;\n\t}\n\n\tret = regmap_write(led->regmap, LM3601X_LED_TORCH_REG, brightness);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = regmap_update_bits(led->regmap, LM3601X_ENABLE_REG,\n\t\t\t\tLM3601X_MODE_TORCH | LM3601X_MODE_IR_DRV,\n\t\t\t\tled_mode_val);\nout:\n\tmutex_unlock(&led->lock);\n\treturn ret;\n}\n\nstatic int lm3601x_strobe_set(struct led_classdev_flash *fled_cdev,\n\t\t\t\tbool state)\n{\n\tstruct lm3601x_led *led = fled_cdev_to_led(fled_cdev);\n\tint timeout_reg_val;\n\tint current_timeout;\n\tint ret;\n\n\tmutex_lock(&led->lock);\n\n\tret = regmap_read(led->regmap, LM3601X_CFG_REG, &current_timeout);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (led->flash_timeout >= LM3601X_TIMEOUT_XOVER_US)\n\t\ttimeout_reg_val = led->flash_timeout / LM3601X_UPPER_STEP_US + 0x07;\n\telse\n\t\ttimeout_reg_val = led->flash_timeout / LM3601X_LOWER_STEP_US - 0x01;\n\n\tif (led->flash_timeout != current_timeout)\n\t\tret = regmap_update_bits(led->regmap, LM3601X_CFG_REG,\n\t\t\t\t\tLM3601X_TIMEOUT_MASK, timeout_reg_val);\n\n\tif (state)\n\t\tret = regmap_update_bits(led->regmap, LM3601X_ENABLE_REG,\n\t\t\t\t\tLM3601X_MODE_TORCH | LM3601X_MODE_IR_DRV,\n\t\t\t\t\tLM3601X_MODE_STROBE);\n\telse\n\t\tret = regmap_update_bits(led->regmap, LM3601X_ENABLE_REG,\n\t\t\t\t\tLM3601X_MODE_STROBE, LED_OFF);\n\n\tret = lm3601x_read_faults(led);\nout:\n\tmutex_unlock(&led->lock);\n\treturn ret;\n}\n\nstatic int lm3601x_flash_brightness_set(struct led_classdev_flash *fled_cdev,\n\t\t\t\t\tu32 brightness)\n{\n\tstruct lm3601x_led *led = fled_cdev_to_led(fled_cdev);\n\tu8 brightness_val;\n\tint ret;\n\n\tmutex_lock(&led->lock);\n\tret = lm3601x_read_faults(led);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (brightness == LED_OFF) {\n\t\tret = regmap_update_bits(led->regmap, LM3601X_ENABLE_REG,\n\t\t\t\t\tLM3601X_MODE_STROBE, LED_OFF);\n\t\tgoto out;\n\t}\n\n\tbrightness_val = brightness / LM3601X_STROBE_REG_DIV;\n\n\tret = regmap_write(led->regmap, LM3601X_LED_FLASH_REG, brightness_val);\nout:\n\tmutex_unlock(&led->lock);\n\treturn ret;\n}\n\nstatic int lm3601x_flash_timeout_set(struct led_classdev_flash *fled_cdev,\n\t\t\t\tu32 timeout)\n{\n\tstruct lm3601x_led *led = fled_cdev_to_led(fled_cdev);\n\n\tmutex_lock(&led->lock);\n\n\tled->flash_timeout = timeout;\n\n\tmutex_unlock(&led->lock);\n\n\treturn 0;\n}\n\nstatic int lm3601x_strobe_get(struct led_classdev_flash *fled_cdev, bool *state)\n{\n\tstruct lm3601x_led *led = fled_cdev_to_led(fled_cdev);\n\tint strobe_state;\n\tint ret;\n\n\tmutex_lock(&led->lock);\n\n\tret = regmap_read(led->regmap, LM3601X_ENABLE_REG, &strobe_state);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*state = strobe_state & LM3601X_MODE_STROBE;\n\nout:\n\tmutex_unlock(&led->lock);\n\treturn ret;\n}\n\nstatic int lm3601x_flash_fault_get(struct led_classdev_flash *fled_cdev,\n\t\t\t\tu32 *fault)\n{\n\tstruct lm3601x_led *led = fled_cdev_to_led(fled_cdev);\n\n\tlm3601x_read_faults(led);\n\n\t*fault = led->last_flag;\n\n\treturn 0;\n}\n\nstatic const struct led_flash_ops flash_ops = {\n\t.flash_brightness_set\t= lm3601x_flash_brightness_set,\n\t.strobe_set\t\t= lm3601x_strobe_set,\n\t.strobe_get\t\t= lm3601x_strobe_get,\n\t.timeout_set\t\t= lm3601x_flash_timeout_set,\n\t.fault_get\t\t= lm3601x_flash_fault_get,\n};\n\nstatic int lm3601x_register_leds(struct lm3601x_led *led,\n\t\t\t\t struct fwnode_handle *fwnode)\n{\n\tstruct led_classdev *led_cdev;\n\tstruct led_flash_setting *setting;\n\tstruct led_init_data init_data = {};\n\n\tled->fled_cdev.ops = &flash_ops;\n\n\tsetting = &led->fled_cdev.timeout;\n\tsetting->min = LM3601X_MIN_TIMEOUT_US;\n\tsetting->max = led->max_flash_timeout;\n\tsetting->step = LM3601X_LOWER_STEP_US;\n\tsetting->val = led->max_flash_timeout;\n\n\tsetting = &led->fled_cdev.brightness;\n\tsetting->min = LM3601X_MIN_STROBE_I_UA;\n\tsetting->max = led->flash_current_max;\n\tsetting->step = LM3601X_TORCH_REG_DIV;\n\tsetting->val = led->flash_current_max;\n\n\tled_cdev = &led->fled_cdev.led_cdev;\n\tled_cdev->brightness_set_blocking = lm3601x_brightness_set;\n\tled_cdev->max_brightness = DIV_ROUND_UP(led->torch_current_max,\n\t\t\t\t\t\tLM3601X_TORCH_REG_DIV);\n\tled_cdev->flags |= LED_DEV_CAP_FLASH;\n\n\tinit_data.fwnode = fwnode;\n\tinit_data.devicename = led->client->name;\n\tinit_data.default_label = (led->led_mode == LM3601X_LED_TORCH) ?\n\t\t\t\t\t\"torch\" : \"infrared\";\n\treturn devm_led_classdev_flash_register_ext(&led->client->dev,\n\t\t\t\t\t\t&led->fled_cdev, &init_data);\n}\n\nstatic int lm3601x_parse_node(struct lm3601x_led *led,\n\t\t\t      struct fwnode_handle **fwnode)\n{\n\tstruct fwnode_handle *child = NULL;\n\tint ret = -ENODEV;\n\n\tchild = device_get_next_child_node(&led->client->dev, child);\n\tif (!child) {\n\t\tdev_err(&led->client->dev, \"No LED Child node\\n\");\n\t\treturn ret;\n\t}\n\n\tret = fwnode_property_read_u32(child, \"reg\", &led->led_mode);\n\tif (ret) {\n\t\tdev_err(&led->client->dev, \"reg DT property missing\\n\");\n\t\tgoto out_err;\n\t}\n\n\tif (led->led_mode > LM3601X_LED_TORCH ||\n\t    led->led_mode < LM3601X_LED_IR) {\n\t\tdev_warn(&led->client->dev, \"Invalid led mode requested\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tret = fwnode_property_read_u32(child, \"led-max-microamp\",\n\t\t\t\t\t&led->torch_current_max);\n\tif (ret) {\n\t\tdev_warn(&led->client->dev,\n\t\t\t\"led-max-microamp DT property missing\\n\");\n\t\tgoto out_err;\n\t}\n\n\tret = fwnode_property_read_u32(child, \"flash-max-microamp\",\n\t\t\t\t&led->flash_current_max);\n\tif (ret) {\n\t\tdev_warn(&led->client->dev,\n\t\t\t \"flash-max-microamp DT property missing\\n\");\n\t\tgoto out_err;\n\t}\n\n\tret = fwnode_property_read_u32(child, \"flash-max-timeout-us\",\n\t\t\t\t&led->max_flash_timeout);\n\tif (ret) {\n\t\tdev_warn(&led->client->dev,\n\t\t\t \"flash-max-timeout-us DT property missing\\n\");\n\t\tgoto out_err;\n\t}\n\n\t*fwnode = child;\n\nout_err:\n\tfwnode_handle_put(child);\n\treturn ret;\n}\n\nstatic int lm3601x_probe(struct i2c_client *client)\n{\n\tstruct lm3601x_led *led;\n\tstruct fwnode_handle *fwnode;\n\tint ret;\n\n\tled = devm_kzalloc(&client->dev, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tled->client = client;\n\ti2c_set_clientdata(client, led);\n\n\tret = lm3601x_parse_node(led, &fwnode);\n\tif (ret)\n\t\treturn -ENODEV;\n\n\tled->regmap = devm_regmap_init_i2c(client, &lm3601x_regmap);\n\tif (IS_ERR(led->regmap)) {\n\t\tret = PTR_ERR(led->regmap);\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&led->lock);\n\n\treturn lm3601x_register_leds(led, fwnode);\n}\n\nstatic void lm3601x_remove(struct i2c_client *client)\n{\n\tstruct lm3601x_led *led = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = regmap_update_bits(led->regmap, LM3601X_ENABLE_REG,\n\t\t\t\t LM3601X_ENABLE_MASK, LM3601X_MODE_STANDBY);\n\tif (ret)\n\t\tdev_warn(&client->dev,\n\t\t\t \"Failed to put into standby (%pe)\\n\", ERR_PTR(ret));\n}\n\nstatic const struct i2c_device_id lm3601x_id[] = {\n\t{ \"LM36010\", CHIP_LM36010 },\n\t{ \"LM36011\", CHIP_LM36011 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm3601x_id);\n\nstatic const struct of_device_id of_lm3601x_leds_match[] = {\n\t{ .compatible = \"ti,lm36010\", },\n\t{ .compatible = \"ti,lm36011\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, of_lm3601x_leds_match);\n\nstatic struct i2c_driver lm3601x_i2c_driver = {\n\t.driver = {\n\t\t.name = \"lm3601x\",\n\t\t.of_match_table = of_lm3601x_leds_match,\n\t},\n\t.probe = lm3601x_probe,\n\t.remove = lm3601x_remove,\n\t.id_table = lm3601x_id,\n};\nmodule_i2c_driver(lm3601x_i2c_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments Flash Lighting driver for LM3601X\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}