{
  "module_name": "leds-rt4505.c",
  "hash_id": "95499bf1ef9784602980eef8e6769488f1d8f8be9389f49ee7458d396159d349",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/flash/leds-rt4505.c",
  "human_readable_source": "\n\n#include <linux/bitops.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/led-class-flash.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <media/v4l2-flash-led-class.h>\n\n#define RT4505_REG_RESET\t0x0\n#define RT4505_REG_CONFIG\t0x8\n#define RT4505_REG_ILED\t\t0x9\n#define RT4505_REG_ENABLE\t0xA\n#define RT4505_REG_FLAGS\t0xB\n\n#define RT4505_RESET_MASK\tBIT(7)\n#define RT4505_FLASHTO_MASK\tGENMASK(2, 0)\n#define RT4505_ITORCH_MASK\tGENMASK(7, 5)\n#define RT4505_ITORCH_SHIFT\t5\n#define RT4505_IFLASH_MASK\tGENMASK(4, 0)\n#define RT4505_ENABLE_MASK\tGENMASK(5, 0)\n#define RT4505_TORCH_SET\t(BIT(0) | BIT(4))\n#define RT4505_FLASH_SET\t(BIT(0) | BIT(1) | BIT(2) | BIT(4))\n#define RT4505_EXT_FLASH_SET\t(BIT(0) | BIT(1) | BIT(4) | BIT(5))\n#define RT4505_FLASH_GET\t(BIT(0) | BIT(1) | BIT(4))\n#define RT4505_OVP_MASK\t\tBIT(3)\n#define RT4505_SHORT_MASK\tBIT(2)\n#define RT4505_OTP_MASK\t\tBIT(1)\n#define RT4505_TIMEOUT_MASK\tBIT(0)\n\n#define RT4505_ITORCH_MINUA\t46000\n#define RT4505_ITORCH_MAXUA\t375000\n#define RT4505_ITORCH_STPUA\t47000\n#define RT4505_IFLASH_MINUA\t93750\n#define RT4505_IFLASH_MAXUA\t1500000\n#define RT4505_IFLASH_STPUA\t93750\n#define RT4505_FLASHTO_MINUS\t100000\n#define RT4505_FLASHTO_MAXUS\t800000\n#define RT4505_FLASHTO_STPUS\t100000\n\nstruct rt4505_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct mutex lock;\n\tstruct led_classdev_flash flash;\n\tstruct v4l2_flash *v4l2_flash;\n};\n\nstatic int rt4505_torch_brightness_set(struct led_classdev *lcdev,\n\t\t\t\t       enum led_brightness level)\n{\n\tstruct rt4505_priv *priv =\n\t\tcontainer_of(lcdev, struct rt4505_priv, flash.led_cdev);\n\tu32 val = 0;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\tif (level != LED_OFF) {\n\t\tret = regmap_update_bits(priv->regmap,\n\t\t\t\t\t RT4505_REG_ILED, RT4505_ITORCH_MASK,\n\t\t\t\t\t (level - 1) << RT4505_ITORCH_SHIFT);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tval = RT4505_TORCH_SET;\n\t}\n\n\tret = regmap_update_bits(priv->regmap, RT4505_REG_ENABLE,\n\t\t\t\t RT4505_ENABLE_MASK, val);\n\nunlock:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic enum led_brightness rt4505_torch_brightness_get(\n\t\t\t\t\t\tstruct led_classdev *lcdev)\n{\n\tstruct rt4505_priv *priv =\n\t\tcontainer_of(lcdev, struct rt4505_priv, flash.led_cdev);\n\tu32 val;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\tret = regmap_read(priv->regmap, RT4505_REG_ENABLE, &val);\n\tif (ret) {\n\t\tdev_err(lcdev->dev, \"Failed to get LED enable\\n\");\n\t\tret = LED_OFF;\n\t\tgoto unlock;\n\t}\n\n\tif ((val & RT4505_ENABLE_MASK) != RT4505_TORCH_SET) {\n\t\tret = LED_OFF;\n\t\tgoto unlock;\n\t}\n\n\tret = regmap_read(priv->regmap, RT4505_REG_ILED, &val);\n\tif (ret) {\n\t\tdev_err(lcdev->dev, \"Failed to get LED brightness\\n\");\n\t\tret = LED_OFF;\n\t\tgoto unlock;\n\t}\n\n\tret = ((val & RT4505_ITORCH_MASK) >> RT4505_ITORCH_SHIFT) + 1;\n\nunlock:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int rt4505_flash_brightness_set(struct led_classdev_flash *fled_cdev,\n\t\t\t\t       u32 brightness)\n{\n\tstruct rt4505_priv *priv =\n\t\tcontainer_of(fled_cdev, struct rt4505_priv, flash);\n\tstruct led_flash_setting *s = &fled_cdev->brightness;\n\tu32 val = (brightness - s->min) / s->step;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = regmap_update_bits(priv->regmap, RT4505_REG_ILED,\n\t\t\t\t RT4505_IFLASH_MASK, val);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int rt4505_flash_strobe_set(struct led_classdev_flash *fled_cdev,\n\t\t\t\t   bool state)\n{\n\tstruct rt4505_priv *priv =\n\t\tcontainer_of(fled_cdev, struct rt4505_priv, flash);\n\tu32 val = state ? RT4505_FLASH_SET : 0;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = regmap_update_bits(priv->regmap, RT4505_REG_ENABLE,\n\t\t\t\t RT4505_ENABLE_MASK, val);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int rt4505_flash_strobe_get(struct led_classdev_flash *fled_cdev,\n\t\t\t\t   bool *state)\n{\n\tstruct rt4505_priv *priv =\n\t\tcontainer_of(fled_cdev, struct rt4505_priv, flash);\n\tu32 val;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\tret = regmap_read(priv->regmap, RT4505_REG_ENABLE, &val);\n\tif (ret)\n\t\tgoto unlock;\n\n\t*state = (val & RT4505_FLASH_GET) == RT4505_FLASH_GET;\n\nunlock:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int rt4505_flash_timeout_set(struct led_classdev_flash *fled_cdev,\n\t\t\t\t    u32 timeout)\n{\n\tstruct rt4505_priv *priv =\n\t\tcontainer_of(fled_cdev, struct rt4505_priv, flash);\n\tstruct led_flash_setting *s = &fled_cdev->timeout;\n\tu32 val = (timeout - s->min) / s->step;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = regmap_update_bits(priv->regmap, RT4505_REG_CONFIG,\n\t\t\t\t RT4505_FLASHTO_MASK, val);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int rt4505_fault_get(struct led_classdev_flash *fled_cdev, u32 *fault)\n{\n\tstruct rt4505_priv *priv =\n\t\tcontainer_of(fled_cdev, struct rt4505_priv, flash);\n\tu32 val, led_faults = 0;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, RT4505_REG_FLAGS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & RT4505_OVP_MASK)\n\t\tled_faults |= LED_FAULT_OVER_VOLTAGE;\n\n\tif (val & RT4505_SHORT_MASK)\n\t\tled_faults |= LED_FAULT_SHORT_CIRCUIT;\n\n\tif (val & RT4505_OTP_MASK)\n\t\tled_faults |= LED_FAULT_OVER_TEMPERATURE;\n\n\tif (val & RT4505_TIMEOUT_MASK)\n\t\tled_faults |= LED_FAULT_TIMEOUT;\n\n\t*fault = led_faults;\n\treturn 0;\n}\n\nstatic const struct led_flash_ops rt4505_flash_ops = {\n\t.flash_brightness_set = rt4505_flash_brightness_set,\n\t.strobe_set = rt4505_flash_strobe_set,\n\t.strobe_get = rt4505_flash_strobe_get,\n\t.timeout_set = rt4505_flash_timeout_set,\n\t.fault_get = rt4505_fault_get,\n};\n\nstatic bool rt4505_is_accessible_reg(struct device *dev, unsigned int reg)\n{\n\tif (reg == RT4505_REG_RESET ||\n\t\t(reg >= RT4505_REG_CONFIG && reg <= RT4505_REG_FLAGS))\n\t\treturn true;\n\treturn false;\n}\n\nstatic const struct regmap_config rt4505_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RT4505_REG_FLAGS,\n\n\t.readable_reg = rt4505_is_accessible_reg,\n\t.writeable_reg = rt4505_is_accessible_reg,\n};\n\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\nstatic int rt4505_flash_external_strobe_set(struct v4l2_flash *v4l2_flash,\n\t\t\t\t\t    bool enable)\n{\n\tstruct led_classdev_flash *flash = v4l2_flash->fled_cdev;\n\tstruct rt4505_priv *priv =\n\t\tcontainer_of(flash, struct rt4505_priv, flash);\n\tu32 val = enable ? RT4505_EXT_FLASH_SET : 0;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = regmap_update_bits(priv->regmap, RT4505_REG_ENABLE,\n\t\t\t\t RT4505_ENABLE_MASK, val);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_flash_ops v4l2_flash_ops = {\n\t.external_strobe_set = rt4505_flash_external_strobe_set,\n};\n\nstatic void rt4505_init_v4l2_config(struct rt4505_priv *priv,\n\t\t\t\t    struct v4l2_flash_config *config)\n{\n\tstruct led_classdev_flash *flash = &priv->flash;\n\tstruct led_classdev *lcdev = &flash->led_cdev;\n\tstruct led_flash_setting *s;\n\n\tstrscpy(config->dev_name, lcdev->dev->kobj.name,\n\t\tsizeof(config->dev_name));\n\n\ts = &config->intensity;\n\ts->min = RT4505_ITORCH_MINUA;\n\ts->step = RT4505_ITORCH_STPUA;\n\ts->max = s->val = s->min + (lcdev->max_brightness - 1) * s->step;\n\n\tconfig->flash_faults = LED_FAULT_OVER_VOLTAGE |\n\t\t\t       LED_FAULT_SHORT_CIRCUIT |\n\t\t\t       LED_FAULT_LED_OVER_TEMPERATURE |\n\t\t\t       LED_FAULT_TIMEOUT;\n\tconfig->has_external_strobe = 1;\n}\n#else\nstatic const struct v4l2_flash_ops v4l2_flash_ops;\nstatic void rt4505_init_v4l2_config(struct rt4505_priv *priv,\n\t\t\t\t    struct v4l2_flash_config *config)\n{\n}\n#endif\n\nstatic void rt4505_init_flash_properties(struct rt4505_priv *priv,\n\t\t\t\t\t struct fwnode_handle *child)\n{\n\tstruct led_classdev_flash *flash = &priv->flash;\n\tstruct led_classdev *lcdev = &flash->led_cdev;\n\tstruct led_flash_setting *s;\n\tu32 val;\n\tint ret;\n\n\tret = fwnode_property_read_u32(child, \"led-max-microamp\", &val);\n\tif (ret) {\n\t\tdev_warn(priv->dev, \"led-max-microamp DT property missing\\n\");\n\t\tval = RT4505_ITORCH_MINUA;\n\t} else\n\t\tval = clamp_val(val, RT4505_ITORCH_MINUA, RT4505_ITORCH_MAXUA);\n\n\tlcdev->max_brightness =\n\t\t(val - RT4505_ITORCH_MINUA) / RT4505_ITORCH_STPUA + 1;\n\tlcdev->brightness_set_blocking = rt4505_torch_brightness_set;\n\tlcdev->brightness_get = rt4505_torch_brightness_get;\n\tlcdev->flags |= LED_DEV_CAP_FLASH;\n\n\tret = fwnode_property_read_u32(child, \"flash-max-microamp\", &val);\n\tif (ret) {\n\t\tdev_warn(priv->dev, \"flash-max-microamp DT property missing\\n\");\n\t\tval = RT4505_IFLASH_MINUA;\n\t} else\n\t\tval = clamp_val(val, RT4505_IFLASH_MINUA, RT4505_IFLASH_MAXUA);\n\n\ts = &flash->brightness;\n\ts->min = RT4505_IFLASH_MINUA;\n\ts->step = RT4505_IFLASH_STPUA;\n\ts->max = s->val = val;\n\n\tret = fwnode_property_read_u32(child, \"flash-max-timeout-us\", &val);\n\tif (ret) {\n\t\tdev_warn(priv->dev,\n\t\t\t \"flash-max-timeout-us DT property missing\\n\");\n\t\tval = RT4505_FLASHTO_MINUS;\n\t} else\n\t\tval = clamp_val(val, RT4505_FLASHTO_MINUS,\n\t\t\t\tRT4505_FLASHTO_MAXUS);\n\n\ts = &flash->timeout;\n\ts->min = RT4505_FLASHTO_MINUS;\n\ts->step = RT4505_FLASHTO_STPUS;\n\ts->max = s->val = val;\n\n\tflash->ops = &rt4505_flash_ops;\n}\n\nstatic int rt4505_probe(struct i2c_client *client)\n{\n\tstruct rt4505_priv *priv;\n\tstruct fwnode_handle *child;\n\tstruct led_init_data init_data = {};\n\tstruct v4l2_flash_config v4l2_config = {};\n\tint ret;\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &client->dev;\n\tmutex_init(&priv->lock);\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &rt4505_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(priv->dev, \"Failed to allocate register map\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\tret = regmap_write(priv->regmap, RT4505_REG_RESET, RT4505_RESET_MASK);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to reset registers\\n\");\n\t\treturn ret;\n\t}\n\n\tchild = fwnode_get_next_available_child_node(client->dev.fwnode, NULL);\n\tif (!child) {\n\t\tdev_err(priv->dev, \"Failed to get child node\\n\");\n\t\treturn -EINVAL;\n\t}\n\tinit_data.fwnode = child;\n\n\trt4505_init_flash_properties(priv, child);\n\tret = devm_led_classdev_flash_register_ext(priv->dev, &priv->flash,\n\t\t\t\t\t\t   &init_data);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to register flash\\n\");\n\t\treturn ret;\n\t}\n\n\trt4505_init_v4l2_config(priv, &v4l2_config);\n\tpriv->v4l2_flash = v4l2_flash_init(priv->dev, init_data.fwnode,\n\t\t\t\t\t   &priv->flash, &v4l2_flash_ops,\n\t\t\t\t\t   &v4l2_config);\n\tif (IS_ERR(priv->v4l2_flash)) {\n\t\tdev_err(priv->dev, \"Failed to register v4l2 flash\\n\");\n\t\treturn PTR_ERR(priv->v4l2_flash);\n\t}\n\n\ti2c_set_clientdata(client, priv);\n\treturn 0;\n}\n\nstatic void rt4505_remove(struct i2c_client *client)\n{\n\tstruct rt4505_priv *priv = i2c_get_clientdata(client);\n\n\tv4l2_flash_release(priv->v4l2_flash);\n}\n\nstatic void rt4505_shutdown(struct i2c_client *client)\n{\n\tstruct rt4505_priv *priv = i2c_get_clientdata(client);\n\n\t \n\tregmap_write(priv->regmap, RT4505_REG_RESET, RT4505_RESET_MASK);\n}\n\nstatic const struct of_device_id __maybe_unused rt4505_leds_match[] = {\n\t{ .compatible = \"richtek,rt4505\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rt4505_leds_match);\n\nstatic struct i2c_driver rt4505_driver = {\n\t.driver = {\n\t\t.name = \"rt4505\",\n\t\t.of_match_table = of_match_ptr(rt4505_leds_match),\n\t},\n\t.probe = rt4505_probe,\n\t.remove = rt4505_remove,\n\t.shutdown = rt4505_shutdown,\n};\nmodule_i2c_driver(rt4505_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}