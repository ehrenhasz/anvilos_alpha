{
  "module_name": "leds-qcom-flash.c",
  "hash_id": "c1f97264b8db5bac6c89519a48d555e806d4ad50ae11c659194a0de8bc9b5c44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/flash/leds-qcom-flash.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/leds.h>\n#include <linux/led-class-flash.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <media/v4l2-flash-led-class.h>\n\n \n#define FLASH_TYPE_REG\t\t\t0x04\n#define FLASH_TYPE_VAL\t\t\t0x18\n\n#define FLASH_SUBTYPE_REG\t\t0x05\n#define FLASH_SUBTYPE_3CH_PM8150_VAL\t0x04\n#define FLASH_SUBTYPE_3CH_PMI8998_VAL\t0x03\n#define FLASH_SUBTYPE_4CH_VAL\t\t0x07\n\n#define FLASH_STS_3CH_OTST1\t\tBIT(0)\n#define FLASH_STS_3CH_OTST2\t\tBIT(1)\n#define FLASH_STS_3CH_OTST3\t\tBIT(2)\n#define FLASH_STS_3CH_BOB_THM_OVERLOAD\tBIT(3)\n#define FLASH_STS_3CH_VPH_DROOP\t\tBIT(4)\n#define FLASH_STS_3CH_BOB_ILIM_S1\tBIT(5)\n#define FLASH_STS_3CH_BOB_ILIM_S2\tBIT(6)\n#define FLASH_STS_3CH_BCL_IBAT\t\tBIT(7)\n\n#define FLASH_STS_4CH_VPH_LOW\t\tBIT(0)\n#define FLASH_STS_4CH_BCL_IBAT\t\tBIT(1)\n#define FLASH_STS_4CH_BOB_ILIM_S1\tBIT(2)\n#define FLASH_STS_4CH_BOB_ILIM_S2\tBIT(3)\n#define FLASH_STS_4CH_OTST2\t\tBIT(4)\n#define FLASH_STS_4CH_OTST1\t\tBIT(5)\n#define FLASH_STS_4CHG_BOB_THM_OVERLOAD\tBIT(6)\n\n#define FLASH_TIMER_EN_BIT\t\tBIT(7)\n#define FLASH_TIMER_VAL_MASK\t\tGENMASK(6, 0)\n#define FLASH_TIMER_STEP_MS\t\t10\n\n#define FLASH_STROBE_HW_SW_SEL_BIT\tBIT(2)\n#define SW_STROBE_VAL\t\t\t0\n#define HW_STROBE_VAL\t\t\t1\n#define FLASH_HW_STROBE_TRIGGER_SEL_BIT\tBIT(1)\n#define STROBE_LEVEL_TRIGGER_VAL\t0\n#define STROBE_EDGE_TRIGGER_VAL\t\t1\n#define FLASH_STROBE_POLARITY_BIT\tBIT(0)\n#define STROBE_ACTIVE_HIGH_VAL\t\t1\n\n#define FLASH_IRES_MASK_4CH\t\tBIT(0)\n#define FLASH_IRES_MASK_3CH\t\tGENMASK(1, 0)\n#define FLASH_IRES_12P5MA_VAL\t\t0\n#define FLASH_IRES_5MA_VAL_4CH\t\t1\n#define FLASH_IRES_5MA_VAL_3CH\t\t3\n\n \n#define FLASH_CURRENT_MAX_UA\t\t1500000\n#define TORCH_CURRENT_MAX_UA\t\t500000\n#define FLASH_TOTAL_CURRENT_MAX_UA\t2000000\n#define FLASH_CURRENT_DEFAULT_UA\t1000000\n#define TORCH_CURRENT_DEFAULT_UA\t200000\n\n#define TORCH_IRES_UA\t\t\t5000\n#define FLASH_IRES_UA\t\t\t12500\n\n#define FLASH_TIMEOUT_MAX_US\t\t1280000\n#define FLASH_TIMEOUT_STEP_US\t\t10000\n\n#define UA_PER_MA\t\t\t1000\n\nenum hw_type {\n\tQCOM_MVFLASH_3CH,\n\tQCOM_MVFLASH_4CH,\n};\n\nenum led_mode {\n\tFLASH_MODE,\n\tTORCH_MODE,\n};\n\nenum led_strobe {\n\tSW_STROBE,\n\tHW_STROBE,\n};\n\nenum {\n\tREG_STATUS1,\n\tREG_STATUS2,\n\tREG_STATUS3,\n\tREG_CHAN_TIMER,\n\tREG_ITARGET,\n\tREG_MODULE_EN,\n\tREG_IRESOLUTION,\n\tREG_CHAN_STROBE,\n\tREG_CHAN_EN,\n\tREG_MAX_COUNT,\n};\n\nstatic struct reg_field mvflash_3ch_regs[REG_MAX_COUNT] = {\n\tREG_FIELD(0x08, 0, 7),\t\t\t \n\tREG_FIELD(0x09, 0, 7),                   \n\tREG_FIELD(0x0a, 0, 7),                   \n\tREG_FIELD_ID(0x40, 0, 7, 3, 1),          \n\tREG_FIELD_ID(0x43, 0, 6, 3, 1),          \n\tREG_FIELD(0x46, 7, 7),                   \n\tREG_FIELD(0x47, 0, 5),                   \n\tREG_FIELD_ID(0x49, 0, 2, 3, 1),          \n\tREG_FIELD(0x4c, 0, 2),                   \n};\n\nstatic struct reg_field mvflash_4ch_regs[REG_MAX_COUNT] = {\n\tREG_FIELD(0x06, 0, 7),\t\t\t \n\tREG_FIELD(0x07, 0, 6),\t\t\t \n\tREG_FIELD(0x09, 0, 7),\t\t\t \n\tREG_FIELD_ID(0x3e, 0, 7, 4, 1),\t\t \n\tREG_FIELD_ID(0x42, 0, 6, 4, 1),\t\t \n\tREG_FIELD(0x46, 7, 7),\t\t\t \n\tREG_FIELD(0x49, 0, 3),\t\t\t \n\tREG_FIELD_ID(0x4a, 0, 6, 4, 1),\t\t \n\tREG_FIELD(0x4e, 0, 3),\t\t\t \n};\n\nstruct qcom_flash_data {\n\tstruct v4l2_flash\t**v4l2_flash;\n\tstruct regmap_field     *r_fields[REG_MAX_COUNT];\n\tstruct mutex\t\tlock;\n\tenum hw_type\t\thw_type;\n\tu8\t\t\tleds_count;\n\tu8\t\t\tmax_channels;\n\tu8\t\t\tchan_en_bits;\n};\n\nstruct qcom_flash_led {\n\tstruct qcom_flash_data\t\t*flash_data;\n\tstruct led_classdev_flash\tflash;\n\tu32\t\t\t\tmax_flash_current_ma;\n\tu32\t\t\t\tmax_torch_current_ma;\n\tu32\t\t\t\tmax_timeout_ms;\n\tu32\t\t\t\tflash_current_ma;\n\tu32\t\t\t\tflash_timeout_ms;\n\tu8\t\t\t\t*chan_id;\n\tu8\t\t\t\tchan_count;\n\tbool\t\t\t\tenabled;\n};\n\nstatic int set_flash_module_en(struct qcom_flash_led *led, bool en)\n{\n\tstruct qcom_flash_data *flash_data = led->flash_data;\n\tu8 led_mask = 0, enable;\n\tint i, rc;\n\n\tfor (i = 0; i < led->chan_count; i++)\n\t\tled_mask |= BIT(led->chan_id[i]);\n\n\tmutex_lock(&flash_data->lock);\n\tif (en)\n\t\tflash_data->chan_en_bits |= led_mask;\n\telse\n\t\tflash_data->chan_en_bits &= ~led_mask;\n\n\tenable = !!flash_data->chan_en_bits;\n\trc = regmap_field_write(flash_data->r_fields[REG_MODULE_EN], enable);\n\tif (rc)\n\t\tdev_err(led->flash.led_cdev.dev, \"write module_en failed, rc=%d\\n\", rc);\n\tmutex_unlock(&flash_data->lock);\n\n\treturn rc;\n}\n\nstatic int set_flash_current(struct qcom_flash_led *led, u32 current_ma, enum led_mode mode)\n{\n\tstruct qcom_flash_data *flash_data = led->flash_data;\n\tu32 itarg_ua, ires_ua;\n\tu8 shift, ires_mask = 0, ires_val = 0, chan_id;\n\tint i, rc;\n\n\t \n\titarg_ua = (current_ma * UA_PER_MA) / led->chan_count + 1;\n\tires_ua = (mode == FLASH_MODE) ? FLASH_IRES_UA : TORCH_IRES_UA;\n\n\tfor (i = 0; i < led->chan_count; i++) {\n\t\tu8 itarget = 0;\n\n\t\tif (itarg_ua > ires_ua)\n\t\t\titarget = itarg_ua / ires_ua - 1;\n\n\t\tchan_id = led->chan_id[i];\n\n\t\trc = regmap_fields_write(flash_data->r_fields[REG_ITARGET], chan_id, itarget);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tif (flash_data->hw_type == QCOM_MVFLASH_3CH) {\n\t\t\tshift = chan_id * 2;\n\t\t\tires_mask |= FLASH_IRES_MASK_3CH << shift;\n\t\t\tires_val |= ((mode == FLASH_MODE) ?\n\t\t\t\t(FLASH_IRES_12P5MA_VAL << shift) :\n\t\t\t\t(FLASH_IRES_5MA_VAL_3CH << shift));\n\t\t} else if (flash_data->hw_type == QCOM_MVFLASH_4CH) {\n\t\t\tshift = chan_id;\n\t\t\tires_mask |= FLASH_IRES_MASK_4CH << shift;\n\t\t\tires_val |= ((mode == FLASH_MODE) ?\n\t\t\t\t(FLASH_IRES_12P5MA_VAL << shift) :\n\t\t\t\t(FLASH_IRES_5MA_VAL_4CH << shift));\n\t\t} else {\n\t\t\tdev_err(led->flash.led_cdev.dev,\n\t\t\t\t\t\"HW type %d is not supported\\n\", flash_data->hw_type);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn regmap_field_update_bits(flash_data->r_fields[REG_IRESOLUTION], ires_mask, ires_val);\n}\n\nstatic int set_flash_timeout(struct qcom_flash_led *led, u32 timeout_ms)\n{\n\tstruct qcom_flash_data *flash_data = led->flash_data;\n\tu8 timer, chan_id;\n\tint rc, i;\n\n\t \n\ttimeout_ms = min_t(u32, timeout_ms, led->max_timeout_ms);\n\n\tfor (i = 0; i < led->chan_count; i++) {\n\t\tchan_id = led->chan_id[i];\n\n\t\ttimer = timeout_ms / FLASH_TIMER_STEP_MS;\n\t\ttimer = clamp_t(u8, timer, 0, FLASH_TIMER_VAL_MASK);\n\n\t\tif (timeout_ms)\n\t\t\ttimer |= FLASH_TIMER_EN_BIT;\n\n\t\trc = regmap_fields_write(flash_data->r_fields[REG_CHAN_TIMER], chan_id, timer);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_flash_strobe(struct qcom_flash_led *led, enum led_strobe strobe, bool state)\n{\n\tstruct qcom_flash_data *flash_data = led->flash_data;\n\tu8 strobe_sel, chan_en, chan_id, chan_mask = 0;\n\tint rc, i;\n\n\t \n\tfor (i = 0; i < led->chan_count; i++) {\n\t\tchan_id = led->chan_id[i];\n\n\t\tif (strobe == SW_STROBE)\n\t\t\tstrobe_sel = FIELD_PREP(FLASH_STROBE_HW_SW_SEL_BIT, SW_STROBE_VAL);\n\t\telse\n\t\t\tstrobe_sel = FIELD_PREP(FLASH_STROBE_HW_SW_SEL_BIT, HW_STROBE_VAL);\n\n\t\tstrobe_sel |=\n\t\t\tFIELD_PREP(FLASH_HW_STROBE_TRIGGER_SEL_BIT, STROBE_LEVEL_TRIGGER_VAL) |\n\t\t\tFIELD_PREP(FLASH_STROBE_POLARITY_BIT, STROBE_ACTIVE_HIGH_VAL);\n\n\t\trc = regmap_fields_write(\n\t\t\t\tflash_data->r_fields[REG_CHAN_STROBE], chan_id, strobe_sel);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tchan_mask |= BIT(chan_id);\n\t}\n\n\t \n\tchan_en = state ? chan_mask : 0;\n\trc = regmap_field_update_bits(flash_data->r_fields[REG_CHAN_EN], chan_mask, chan_en);\n\tif (rc)\n\t\treturn rc;\n\n\tled->enabled = state;\n\treturn 0;\n}\n\nstatic inline struct qcom_flash_led *flcdev_to_qcom_fled(struct led_classdev_flash *flcdev)\n{\n\treturn container_of(flcdev, struct qcom_flash_led, flash);\n}\n\nstatic int qcom_flash_brightness_set(struct led_classdev_flash *fled_cdev, u32 brightness)\n{\n\tstruct qcom_flash_led *led = flcdev_to_qcom_fled(fled_cdev);\n\n\tled->flash_current_ma = min_t(u32, led->max_flash_current_ma, brightness / UA_PER_MA);\n\treturn 0;\n}\n\nstatic int qcom_flash_timeout_set(struct led_classdev_flash *fled_cdev, u32 timeout)\n{\n\tstruct qcom_flash_led *led = flcdev_to_qcom_fled(fled_cdev);\n\n\tled->flash_timeout_ms = timeout / USEC_PER_MSEC;\n\treturn 0;\n}\n\nstatic int qcom_flash_strobe_set(struct led_classdev_flash *fled_cdev, bool state)\n{\n\tstruct qcom_flash_led *led = flcdev_to_qcom_fled(fled_cdev);\n\tint rc;\n\n\trc = set_flash_strobe(led, SW_STROBE, false);\n\tif (rc)\n\t\treturn rc;\n\n\trc = set_flash_current(led, led->flash_current_ma, FLASH_MODE);\n\tif (rc)\n\t\treturn rc;\n\n\trc = set_flash_timeout(led, led->flash_timeout_ms);\n\tif (rc)\n\t\treturn rc;\n\n\trc = set_flash_module_en(led, state);\n\tif (rc)\n\t\treturn rc;\n\n\treturn set_flash_strobe(led, SW_STROBE, state);\n}\n\nstatic int qcom_flash_strobe_get(struct led_classdev_flash *fled_cdev, bool *state)\n{\n\tstruct qcom_flash_led *led = flcdev_to_qcom_fled(fled_cdev);\n\n\t*state = led->enabled;\n\treturn 0;\n}\n\nstatic int qcom_flash_fault_get(struct led_classdev_flash *fled_cdev, u32 *fault)\n{\n\tstruct qcom_flash_led *led = flcdev_to_qcom_fled(fled_cdev);\n\tstruct qcom_flash_data *flash_data = led->flash_data;\n\tu8 shift, chan_id, chan_mask = 0;\n\tu8 ot_mask = 0, oc_mask = 0, uv_mask = 0;\n\tu32 val, fault_sts = 0;\n\tint i, rc;\n\n\trc = regmap_field_read(flash_data->r_fields[REG_STATUS1], &val);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < led->chan_count; i++) {\n\t\tchan_id = led->chan_id[i];\n\t\tshift = chan_id * 2;\n\n\t\tif (val & BIT(shift))\n\t\t\tfault_sts |= LED_FAULT_SHORT_CIRCUIT;\n\n\t\tchan_mask |= BIT(chan_id);\n\t}\n\n\trc = regmap_field_read(flash_data->r_fields[REG_STATUS2], &val);\n\tif (rc)\n\t\treturn rc;\n\n\tif (flash_data->hw_type == QCOM_MVFLASH_3CH) {\n\t\tot_mask = FLASH_STS_3CH_OTST1 |\n\t\t\t  FLASH_STS_3CH_OTST2 |\n\t\t\t  FLASH_STS_3CH_OTST3 |\n\t\t\t  FLASH_STS_3CH_BOB_THM_OVERLOAD;\n\t\toc_mask = FLASH_STS_3CH_BOB_ILIM_S1 |\n\t\t\t  FLASH_STS_3CH_BOB_ILIM_S2 |\n\t\t\t  FLASH_STS_3CH_BCL_IBAT;\n\t\tuv_mask = FLASH_STS_3CH_VPH_DROOP;\n\t} else if (flash_data->hw_type == QCOM_MVFLASH_4CH) {\n\t\tot_mask = FLASH_STS_4CH_OTST2 |\n\t\t\t  FLASH_STS_4CH_OTST1 |\n\t\t\t  FLASH_STS_4CHG_BOB_THM_OVERLOAD;\n\t\toc_mask = FLASH_STS_4CH_BCL_IBAT |\n\t\t\t  FLASH_STS_4CH_BOB_ILIM_S1 |\n\t\t\t  FLASH_STS_4CH_BOB_ILIM_S2;\n\t\tuv_mask = FLASH_STS_4CH_VPH_LOW;\n\t}\n\n\tif (val & ot_mask)\n\t\tfault_sts |= LED_FAULT_OVER_TEMPERATURE;\n\n\tif (val & oc_mask)\n\t\tfault_sts |= LED_FAULT_OVER_CURRENT;\n\n\tif (val & uv_mask)\n\t\tfault_sts |= LED_FAULT_INPUT_VOLTAGE;\n\n\trc = regmap_field_read(flash_data->r_fields[REG_STATUS3], &val);\n\tif (rc)\n\t\treturn rc;\n\n\tif (flash_data->hw_type == QCOM_MVFLASH_3CH) {\n\t\tif (val & chan_mask)\n\t\t\tfault_sts |= LED_FAULT_TIMEOUT;\n\t} else if (flash_data->hw_type == QCOM_MVFLASH_4CH) {\n\t\tfor (i = 0; i < led->chan_count; i++) {\n\t\t\tchan_id = led->chan_id[i];\n\t\t\tshift = chan_id * 2;\n\n\t\t\tif (val & BIT(shift))\n\t\t\t\tfault_sts |= LED_FAULT_TIMEOUT;\n\t\t}\n\t}\n\n\t*fault = fault_sts;\n\treturn 0;\n}\n\nstatic int qcom_flash_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\tstruct qcom_flash_led *led = flcdev_to_qcom_fled(fled_cdev);\n\tu32 current_ma = brightness * led->max_torch_current_ma / LED_FULL;\n\tbool enable = !!brightness;\n\tint rc;\n\n\trc = set_flash_strobe(led, SW_STROBE, false);\n\tif (rc)\n\t\treturn rc;\n\n\trc = set_flash_module_en(led, false);\n\tif (rc)\n\t\treturn rc;\n\n\trc = set_flash_current(led, current_ma, TORCH_MODE);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = set_flash_timeout(led, 0);\n\tif (rc)\n\t\treturn rc;\n\n\trc = set_flash_module_en(led, enable);\n\tif (rc)\n\t\treturn rc;\n\n\treturn set_flash_strobe(led, SW_STROBE, enable);\n}\n\nstatic const struct led_flash_ops qcom_flash_ops = {\n\t.flash_brightness_set = qcom_flash_brightness_set,\n\t.strobe_set = qcom_flash_strobe_set,\n\t.strobe_get = qcom_flash_strobe_get,\n\t.timeout_set = qcom_flash_timeout_set,\n\t.fault_get = qcom_flash_fault_get,\n};\n\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\nstatic int qcom_flash_external_strobe_set(struct v4l2_flash *v4l2_flash, bool enable)\n{\n\tstruct led_classdev_flash *fled_cdev = v4l2_flash->fled_cdev;\n\tstruct qcom_flash_led *led = flcdev_to_qcom_fled(fled_cdev);\n\tint rc;\n\n\trc = set_flash_module_en(led, enable);\n\tif (rc)\n\t\treturn rc;\n\n\tif (enable)\n\t\treturn set_flash_strobe(led, HW_STROBE, true);\n\telse\n\t\treturn set_flash_strobe(led, SW_STROBE, false);\n}\n\nstatic enum led_brightness\nqcom_flash_intensity_to_led_brightness(struct v4l2_flash *v4l2_flash, s32 intensity)\n{\n\tstruct led_classdev_flash *fled_cdev = v4l2_flash->fled_cdev;\n\tstruct qcom_flash_led *led = flcdev_to_qcom_fled(fled_cdev);\n\tu32 current_ma = intensity / UA_PER_MA;\n\n\tcurrent_ma = min_t(u32, current_ma, led->max_torch_current_ma);\n\tif (!current_ma)\n\t\treturn LED_OFF;\n\n\treturn (current_ma * LED_FULL) / led->max_torch_current_ma;\n}\n\nstatic s32 qcom_flash_brightness_to_led_intensity(struct v4l2_flash *v4l2_flash,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct led_classdev_flash *fled_cdev = v4l2_flash->fled_cdev;\n\tstruct qcom_flash_led *led = flcdev_to_qcom_fled(fled_cdev);\n\n\treturn (brightness * led->max_torch_current_ma * UA_PER_MA) / LED_FULL;\n}\n\nstatic const struct v4l2_flash_ops qcom_v4l2_flash_ops = {\n\t.external_strobe_set = qcom_flash_external_strobe_set,\n\t.intensity_to_led_brightness = qcom_flash_intensity_to_led_brightness,\n\t.led_brightness_to_intensity = qcom_flash_brightness_to_led_intensity,\n};\n\nstatic int\nqcom_flash_v4l2_init(struct device *dev, struct qcom_flash_led *led, struct fwnode_handle *fwnode)\n{\n\tstruct qcom_flash_data *flash_data = led->flash_data;\n\tstruct v4l2_flash_config v4l2_cfg = { 0 };\n\tstruct led_flash_setting *intensity = &v4l2_cfg.intensity;\n\n\tif (!(led->flash.led_cdev.flags & LED_DEV_CAP_FLASH))\n\t\treturn 0;\n\n\tintensity->min = intensity->step = TORCH_IRES_UA * led->chan_count;\n\tintensity->max = led->max_torch_current_ma * UA_PER_MA;\n\tintensity->val = min_t(u32, intensity->max, TORCH_CURRENT_DEFAULT_UA);\n\n\tstrscpy(v4l2_cfg.dev_name, led->flash.led_cdev.dev->kobj.name,\n\t\t\t\t\tsizeof(v4l2_cfg.dev_name));\n\n\tv4l2_cfg.has_external_strobe = true;\n\tv4l2_cfg.flash_faults = LED_FAULT_INPUT_VOLTAGE |\n\t\t\t\tLED_FAULT_OVER_CURRENT |\n\t\t\t\tLED_FAULT_SHORT_CIRCUIT |\n\t\t\t\tLED_FAULT_OVER_TEMPERATURE |\n\t\t\t\tLED_FAULT_TIMEOUT;\n\n\tflash_data->v4l2_flash[flash_data->leds_count] =\n\t\tv4l2_flash_init(dev, fwnode, &led->flash, &qcom_v4l2_flash_ops, &v4l2_cfg);\n\treturn PTR_ERR_OR_ZERO(flash_data->v4l2_flash);\n}\n# else\nstatic int\nqcom_flash_v4l2_init(struct device *dev, struct qcom_flash_led *led, struct fwnode_handle *fwnode)\n{\n\treturn 0;\n}\n#endif\n\nstatic int qcom_flash_register_led_device(struct device *dev,\n\t\tstruct fwnode_handle *node, struct qcom_flash_led *led)\n{\n\tstruct qcom_flash_data *flash_data = led->flash_data;\n\tstruct led_init_data init_data;\n\tstruct led_classdev_flash *flash = &led->flash;\n\tstruct led_flash_setting *brightness, *timeout;\n\tu32 current_ua, timeout_us;\n\tu32 channels[4];\n\tint i, rc, count;\n\n\tcount = fwnode_property_count_u32(node, \"led-sources\");\n\tif (count <= 0) {\n\t\tdev_err(dev, \"No led-sources specified\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (count > flash_data->max_channels) {\n\t\tdev_err(dev, \"led-sources count %u exceeds maximum channel count %u\\n\",\n\t\t\t\tcount, flash_data->max_channels);\n\t\treturn -EINVAL;\n\t}\n\n\trc = fwnode_property_read_u32_array(node, \"led-sources\", channels, count);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Failed to read led-sources property, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tled->chan_count = count;\n\tled->chan_id = devm_kcalloc(dev, count, sizeof(u8), GFP_KERNEL);\n\tif (!led->chan_id)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif ((channels[i] == 0) || (channels[i] > flash_data->max_channels)) {\n\t\t\tdev_err(dev, \"led-source out of HW support range [1-%u]\\n\",\n\t\t\t\t\tflash_data->max_channels);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tled->chan_id[i] = channels[i] - 1;\n\t}\n\n\trc = fwnode_property_read_u32(node, \"led-max-microamp\", &current_ua);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Failed to read led-max-microamp property, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (current_ua == 0) {\n\t\tdev_err(dev, \"led-max-microamp shouldn't be 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcurrent_ua = min_t(u32, current_ua, TORCH_CURRENT_MAX_UA * led->chan_count);\n\tled->max_torch_current_ma = current_ua / UA_PER_MA;\n\n\tif (fwnode_property_present(node, \"flash-max-microamp\")) {\n\t\tflash->led_cdev.flags |= LED_DEV_CAP_FLASH;\n\n\t\trc = fwnode_property_read_u32(node, \"flash-max-microamp\", &current_ua);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"Failed to read flash-max-microamp property, rc=%d\\n\",\n\t\t\t\t\trc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tcurrent_ua = min_t(u32, current_ua, FLASH_CURRENT_MAX_UA * led->chan_count);\n\t\tcurrent_ua = min_t(u32, current_ua, FLASH_TOTAL_CURRENT_MAX_UA);\n\n\t\t \n\t\tbrightness = &flash->brightness;\n\t\tbrightness->min = brightness->step = FLASH_IRES_UA * led->chan_count;\n\t\tbrightness->max = current_ua;\n\t\tbrightness->val = min_t(u32, current_ua, FLASH_CURRENT_DEFAULT_UA);\n\n\t\tled->max_flash_current_ma = current_ua / UA_PER_MA;\n\t\tled->flash_current_ma = brightness->val / UA_PER_MA;\n\n\t\trc = fwnode_property_read_u32(node, \"flash-max-timeout-us\", &timeout_us);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"Failed to read flash-max-timeout-us property, rc=%d\\n\",\n\t\t\t\t\trc);\n\t\t\treturn rc;\n\t\t}\n\n\t\ttimeout_us = min_t(u32, timeout_us, FLASH_TIMEOUT_MAX_US);\n\n\t\t \n\t\ttimeout = &flash->timeout;\n\t\ttimeout->min = timeout->step = FLASH_TIMEOUT_STEP_US;\n\t\ttimeout->val = timeout->max = timeout_us;\n\n\t\tled->max_timeout_ms = led->flash_timeout_ms = timeout_us / USEC_PER_MSEC;\n\n\t\tflash->ops = &qcom_flash_ops;\n\t}\n\n\tflash->led_cdev.brightness_set_blocking = qcom_flash_led_brightness_set;\n\n\tinit_data.fwnode = node;\n\tinit_data.devicename = NULL;\n\tinit_data.default_label = NULL;\n\tinit_data.devname_mandatory = false;\n\n\trc = devm_led_classdev_flash_register_ext(dev, flash, &init_data);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Register flash LED classdev failed, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn qcom_flash_v4l2_init(dev, led, node);\n}\n\nstatic int qcom_flash_led_probe(struct platform_device *pdev)\n{\n\tstruct qcom_flash_data *flash_data;\n\tstruct qcom_flash_led *led;\n\tstruct fwnode_handle *child;\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap *regmap;\n\tstruct reg_field *regs;\n\tint count, i, rc;\n\tu32 val, reg_base;\n\n\tflash_data = devm_kzalloc(dev, sizeof(*flash_data), GFP_KERNEL);\n\tif (!flash_data)\n\t\treturn -ENOMEM;\n\n\tregmap = dev_get_regmap(dev->parent, NULL);\n\tif (!regmap) {\n\t\tdev_err(dev, \"Failed to get parent regmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = fwnode_property_read_u32(dev->fwnode, \"reg\", &reg_base);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Failed to get register base address, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = regmap_read(regmap, reg_base + FLASH_TYPE_REG, &val);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Read flash LED module type failed, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (val != FLASH_TYPE_VAL) {\n\t\tdev_err(dev, \"type %#x is not a flash LED module\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\trc = regmap_read(regmap, reg_base + FLASH_SUBTYPE_REG, &val);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Read flash LED module subtype failed, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (val == FLASH_SUBTYPE_3CH_PM8150_VAL || val == FLASH_SUBTYPE_3CH_PMI8998_VAL) {\n\t\tflash_data->hw_type = QCOM_MVFLASH_3CH;\n\t\tflash_data->max_channels = 3;\n\t\tregs = mvflash_3ch_regs;\n\t} else if (val == FLASH_SUBTYPE_4CH_VAL) {\n\t\tflash_data->hw_type = QCOM_MVFLASH_4CH;\n\t\tflash_data->max_channels = 4;\n\t\tregs = mvflash_4ch_regs;\n\t} else {\n\t\tdev_err(dev, \"flash LED subtype %#x is not yet supported\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < REG_MAX_COUNT; i++)\n\t\tregs[i].reg += reg_base;\n\n\trc = devm_regmap_field_bulk_alloc(dev, regmap, flash_data->r_fields, regs, REG_MAX_COUNT);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Failed to allocate regmap field, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tplatform_set_drvdata(pdev, flash_data);\n\tmutex_init(&flash_data->lock);\n\n\tcount = device_get_child_node_count(dev);\n\tif (count == 0 || count > flash_data->max_channels) {\n\t\tdev_err(dev, \"No child or child count exceeds %d\\n\", flash_data->max_channels);\n\t\treturn -EINVAL;\n\t}\n\n\tflash_data->v4l2_flash = devm_kcalloc(dev, count,\n\t\t\tsizeof(*flash_data->v4l2_flash), GFP_KERNEL);\n\tif (!flash_data->v4l2_flash)\n\t\treturn -ENOMEM;\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\n\t\tif (!led) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto release;\n\t\t}\n\n\t\tled->flash_data = flash_data;\n\t\trc = qcom_flash_register_led_device(dev, child, led);\n\t\tif (rc < 0)\n\t\t\tgoto release;\n\n\t\tflash_data->leds_count++;\n\t}\n\n\treturn 0;\n\nrelease:\n\tfwnode_handle_put(child);\n\twhile (flash_data->v4l2_flash[flash_data->leds_count] && flash_data->leds_count)\n\t\tv4l2_flash_release(flash_data->v4l2_flash[flash_data->leds_count--]);\n\treturn rc;\n}\n\nstatic int qcom_flash_led_remove(struct platform_device *pdev)\n{\n\tstruct qcom_flash_data *flash_data = platform_get_drvdata(pdev);\n\n\twhile (flash_data->v4l2_flash[flash_data->leds_count] && flash_data->leds_count)\n\t\tv4l2_flash_release(flash_data->v4l2_flash[flash_data->leds_count--]);\n\n\tmutex_destroy(&flash_data->lock);\n\treturn 0;\n}\n\nstatic const struct of_device_id qcom_flash_led_match_table[] = {\n\t{ .compatible = \"qcom,spmi-flash-led\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, qcom_flash_led_match_table);\nstatic struct platform_driver qcom_flash_led_driver = {\n\t.driver = {\n\t\t.name = \"leds-qcom-flash\",\n\t\t.of_match_table = qcom_flash_led_match_table,\n\t},\n\t.probe = qcom_flash_led_probe,\n\t.remove = qcom_flash_led_remove,\n};\n\nmodule_platform_driver(qcom_flash_led_driver);\n\nMODULE_DESCRIPTION(\"QCOM Flash LED driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}