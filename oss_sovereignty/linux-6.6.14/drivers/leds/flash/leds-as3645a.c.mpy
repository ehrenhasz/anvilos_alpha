{
  "module_name": "leds-as3645a.c",
  "hash_id": "15c9a14c42ff159a04370b97e443dbe98c2df1b5aa777571a0d50e5a8a5627fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/flash/leds-as3645a.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/led-class-flash.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-flash-led-class.h>\n\n#define AS_TIMER_US_TO_CODE(t)\t\t\t(((t) / 1000 - 100) / 50)\n#define AS_TIMER_CODE_TO_US(c)\t\t\t((50 * (c) + 100) * 1000)\n\n \n\n \n#define AS_DESIGN_INFO_REG\t\t\t0x00\n#define AS_DESIGN_INFO_FACTORY(x)\t\t(((x) >> 4))\n#define AS_DESIGN_INFO_MODEL(x)\t\t\t((x) & 0x0f)\n\n \n#define AS_VERSION_CONTROL_REG\t\t\t0x01\n#define AS_VERSION_CONTROL_RFU(x)\t\t(((x) >> 4))\n#define AS_VERSION_CONTROL_VERSION(x)\t\t((x) & 0x0f)\n\n \n#define AS_INDICATOR_AND_TIMER_REG\t\t0x02\n#define AS_INDICATOR_AND_TIMER_TIMEOUT_SHIFT\t0\n#define AS_INDICATOR_AND_TIMER_VREF_SHIFT\t4\n#define AS_INDICATOR_AND_TIMER_INDICATOR_SHIFT\t6\n\n \n#define AS_CURRENT_SET_REG\t\t\t0x03\n#define AS_CURRENT_ASSIST_LIGHT_SHIFT\t\t0\n#define AS_CURRENT_LED_DET_ON\t\t\t(1 << 3)\n#define AS_CURRENT_FLASH_CURRENT_SHIFT\t\t4\n\n \n#define AS_CONTROL_REG\t\t\t\t0x04\n#define AS_CONTROL_MODE_SETTING_SHIFT\t\t0\n#define AS_CONTROL_STROBE_ON\t\t\t(1 << 2)\n#define AS_CONTROL_OUT_ON\t\t\t(1 << 3)\n#define AS_CONTROL_EXT_TORCH_ON\t\t\t(1 << 4)\n#define AS_CONTROL_STROBE_TYPE_EDGE\t\t(0 << 5)\n#define AS_CONTROL_STROBE_TYPE_LEVEL\t\t(1 << 5)\n#define AS_CONTROL_COIL_PEAK_SHIFT\t\t6\n\n \n#define AS_FAULT_INFO_REG\t\t\t0x05\n#define AS_FAULT_INFO_INDUCTOR_PEAK_LIMIT\t(1 << 1)\n#define AS_FAULT_INFO_INDICATOR_LED\t\t(1 << 2)\n#define AS_FAULT_INFO_LED_AMOUNT\t\t(1 << 3)\n#define AS_FAULT_INFO_TIMEOUT\t\t\t(1 << 4)\n#define AS_FAULT_INFO_OVER_TEMPERATURE\t\t(1 << 5)\n#define AS_FAULT_INFO_SHORT_CIRCUIT\t\t(1 << 6)\n#define AS_FAULT_INFO_OVER_VOLTAGE\t\t(1 << 7)\n\n \n#define AS_BOOST_REG\t\t\t\t0x0d\n#define AS_BOOST_CURRENT_DISABLE\t\t(0 << 0)\n#define AS_BOOST_CURRENT_ENABLE\t\t\t(1 << 0)\n\n \n#define AS_PASSWORD_REG\t\t\t\t0x0f\n#define AS_PASSWORD_UNLOCK_VALUE\t\t0x55\n\n#define AS_NAME\t\t\t\t\t\"as3645a\"\n#define AS_I2C_ADDR\t\t\t\t(0x60 >> 1)  \n\n#define AS_FLASH_TIMEOUT_MIN\t\t\t100000\t \n#define AS_FLASH_TIMEOUT_MAX\t\t\t850000\n#define AS_FLASH_TIMEOUT_STEP\t\t\t50000\n\n#define AS_FLASH_INTENSITY_MIN\t\t\t200000\t \n#define AS_FLASH_INTENSITY_MAX_1LED\t\t500000\n#define AS_FLASH_INTENSITY_MAX_2LEDS\t\t400000\n#define AS_FLASH_INTENSITY_STEP\t\t\t20000\n\n#define AS_TORCH_INTENSITY_MIN\t\t\t20000\t \n#define AS_TORCH_INTENSITY_MAX\t\t\t160000\n#define AS_TORCH_INTENSITY_STEP\t\t\t20000\n\n#define AS_INDICATOR_INTENSITY_MIN\t\t0\t \n#define AS_INDICATOR_INTENSITY_MAX\t\t10000\n#define AS_INDICATOR_INTENSITY_STEP\t\t2500\n\n#define AS_PEAK_mA_MAX\t\t\t\t2000\n#define AS_PEAK_mA_TO_REG(a) \\\n\t((min_t(u32, AS_PEAK_mA_MAX, a) - 1250) / 250)\n\n \n#define AS_LED_FLASH\t\t\t\t0\n#define AS_LED_INDICATOR\t\t\t1\n\nenum as_mode {\n\tAS_MODE_EXT_TORCH = 0 << AS_CONTROL_MODE_SETTING_SHIFT,\n\tAS_MODE_INDICATOR = 1 << AS_CONTROL_MODE_SETTING_SHIFT,\n\tAS_MODE_ASSIST = 2 << AS_CONTROL_MODE_SETTING_SHIFT,\n\tAS_MODE_FLASH = 3 << AS_CONTROL_MODE_SETTING_SHIFT,\n};\n\nstruct as3645a_config {\n\tu32 flash_timeout_us;\n\tu32 flash_max_ua;\n\tu32 assist_max_ua;\n\tu32 indicator_max_ua;\n\tu32 voltage_reference;\n\tu32 peak;\n};\n\nstruct as3645a {\n\tstruct i2c_client *client;\n\n\tstruct mutex mutex;\n\n\tstruct led_classdev_flash fled;\n\tstruct led_classdev iled_cdev;\n\n\tstruct v4l2_flash *vf;\n\tstruct v4l2_flash *vfind;\n\n\tstruct fwnode_handle *flash_node;\n\tstruct fwnode_handle *indicator_node;\n\n\tstruct as3645a_config cfg;\n\n\tenum as_mode mode;\n\tunsigned int timeout;\n\tunsigned int flash_current;\n\tunsigned int assist_current;\n\tunsigned int indicator_current;\n\tenum v4l2_flash_strobe_source strobe_source;\n};\n\n#define fled_to_as3645a(__fled) container_of(__fled, struct as3645a, fled)\n#define iled_cdev_to_as3645a(__iled_cdev) \\\n\tcontainer_of(__iled_cdev, struct as3645a, iled_cdev)\n\n \nstatic int as3645a_write(struct as3645a *flash, u8 addr, u8 val)\n{\n\tstruct i2c_client *client = flash->client;\n\tint rval;\n\n\trval = i2c_smbus_write_byte_data(client, addr, val);\n\n\tdev_dbg(&client->dev, \"Write Addr:%02X Val:%02X %s\\n\", addr, val,\n\t\trval < 0 ? \"fail\" : \"ok\");\n\n\treturn rval;\n}\n\n \nstatic int as3645a_read(struct as3645a *flash, u8 addr)\n{\n\tstruct i2c_client *client = flash->client;\n\tint rval;\n\n\trval = i2c_smbus_read_byte_data(client, addr);\n\n\tdev_dbg(&client->dev, \"Read Addr:%02X Val:%02X %s\\n\", addr, rval,\n\t\trval < 0 ? \"fail\" : \"ok\");\n\n\treturn rval;\n}\n\n \n\n \nstatic int as3645a_set_current(struct as3645a *flash)\n{\n\tu8 val;\n\n\tval = (flash->flash_current << AS_CURRENT_FLASH_CURRENT_SHIFT)\n\t    | (flash->assist_current << AS_CURRENT_ASSIST_LIGHT_SHIFT)\n\t    | AS_CURRENT_LED_DET_ON;\n\n\treturn as3645a_write(flash, AS_CURRENT_SET_REG, val);\n}\n\nstatic int as3645a_set_timeout(struct as3645a *flash)\n{\n\tu8 val;\n\n\tval = flash->timeout << AS_INDICATOR_AND_TIMER_TIMEOUT_SHIFT;\n\n\tval |= (flash->cfg.voltage_reference\n\t\t<< AS_INDICATOR_AND_TIMER_VREF_SHIFT)\n\t    |  ((flash->indicator_current ? flash->indicator_current - 1 : 0)\n\t\t << AS_INDICATOR_AND_TIMER_INDICATOR_SHIFT);\n\n\treturn as3645a_write(flash, AS_INDICATOR_AND_TIMER_REG, val);\n}\n\n \nstatic int\nas3645a_set_control(struct as3645a *flash, enum as_mode mode, bool on)\n{\n\tu8 reg;\n\n\t \n\treg = (flash->cfg.peak << AS_CONTROL_COIL_PEAK_SHIFT)\n\t    | (on ? AS_CONTROL_OUT_ON : 0)\n\t    | mode;\n\n\tif (mode == AS_MODE_FLASH &&\n\t    flash->strobe_source == V4L2_FLASH_STROBE_SOURCE_EXTERNAL)\n\t\treg |= AS_CONTROL_STROBE_TYPE_LEVEL\n\t\t    |  AS_CONTROL_STROBE_ON;\n\n\treturn as3645a_write(flash, AS_CONTROL_REG, reg);\n}\n\nstatic int as3645a_get_fault(struct led_classdev_flash *fled, u32 *fault)\n{\n\tstruct as3645a *flash = fled_to_as3645a(fled);\n\tint rval;\n\n\t \n\trval = as3645a_read(flash, AS_FAULT_INFO_REG);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (rval & AS_FAULT_INFO_INDUCTOR_PEAK_LIMIT)\n\t\t*fault |= LED_FAULT_OVER_CURRENT;\n\n\tif (rval & AS_FAULT_INFO_INDICATOR_LED)\n\t\t*fault |= LED_FAULT_INDICATOR;\n\n\tdev_dbg(&flash->client->dev, \"%u connected LEDs\\n\",\n\t\trval & AS_FAULT_INFO_LED_AMOUNT ? 2 : 1);\n\n\tif (rval & AS_FAULT_INFO_TIMEOUT)\n\t\t*fault |= LED_FAULT_TIMEOUT;\n\n\tif (rval & AS_FAULT_INFO_OVER_TEMPERATURE)\n\t\t*fault |= LED_FAULT_OVER_TEMPERATURE;\n\n\tif (rval & AS_FAULT_INFO_SHORT_CIRCUIT)\n\t\t*fault |= LED_FAULT_OVER_CURRENT;\n\n\tif (rval & AS_FAULT_INFO_OVER_VOLTAGE)\n\t\t*fault |= LED_FAULT_INPUT_VOLTAGE;\n\n\treturn rval;\n}\n\nstatic unsigned int __as3645a_current_to_reg(unsigned int min, unsigned int max,\n\t\t\t\t\t     unsigned int step,\n\t\t\t\t\t     unsigned int val)\n{\n\tif (val < min)\n\t\tval = min;\n\n\tif (val > max)\n\t\tval = max;\n\n\treturn (val - min) / step;\n}\n\nstatic unsigned int as3645a_current_to_reg(struct as3645a *flash, bool is_flash,\n\t\t\t\t\t   unsigned int ua)\n{\n\tif (is_flash)\n\t\treturn __as3645a_current_to_reg(AS_TORCH_INTENSITY_MIN,\n\t\t\t\t\t\tflash->cfg.assist_max_ua,\n\t\t\t\t\t\tAS_TORCH_INTENSITY_STEP, ua);\n\telse\n\t\treturn __as3645a_current_to_reg(AS_FLASH_INTENSITY_MIN,\n\t\t\t\t\t\tflash->cfg.flash_max_ua,\n\t\t\t\t\t\tAS_FLASH_INTENSITY_STEP, ua);\n}\n\nstatic int as3645a_set_indicator_brightness(struct led_classdev *iled_cdev,\n\t\t\t\t\t    enum led_brightness brightness)\n{\n\tstruct as3645a *flash = iled_cdev_to_as3645a(iled_cdev);\n\tint rval;\n\n\tflash->indicator_current = brightness;\n\n\trval = as3645a_set_timeout(flash);\n\tif (rval)\n\t\treturn rval;\n\n\treturn as3645a_set_control(flash, AS_MODE_INDICATOR, brightness);\n}\n\nstatic int as3645a_set_assist_brightness(struct led_classdev *fled_cdev,\n\t\t\t\t\t enum led_brightness brightness)\n{\n\tstruct led_classdev_flash *fled = lcdev_to_flcdev(fled_cdev);\n\tstruct as3645a *flash = fled_to_as3645a(fled);\n\tint rval;\n\n\tif (brightness) {\n\t\t \n\t\tflash->assist_current = brightness - 1;\n\n\t\trval = as3645a_set_current(flash);\n\t\tif (rval)\n\t\t\treturn rval;\n\t}\n\n\treturn as3645a_set_control(flash, AS_MODE_ASSIST, brightness);\n}\n\nstatic int as3645a_set_flash_brightness(struct led_classdev_flash *fled,\n\t\t\t\t\tu32 brightness_ua)\n{\n\tstruct as3645a *flash = fled_to_as3645a(fled);\n\n\tflash->flash_current = as3645a_current_to_reg(flash, true,\n\t\t\t\t\t\t      brightness_ua);\n\n\treturn as3645a_set_current(flash);\n}\n\nstatic int as3645a_set_flash_timeout(struct led_classdev_flash *fled,\n\t\t\t\t     u32 timeout_us)\n{\n\tstruct as3645a *flash = fled_to_as3645a(fled);\n\n\tflash->timeout = AS_TIMER_US_TO_CODE(timeout_us);\n\n\treturn as3645a_set_timeout(flash);\n}\n\nstatic int as3645a_set_strobe(struct led_classdev_flash *fled, bool state)\n{\n\tstruct as3645a *flash = fled_to_as3645a(fled);\n\n\treturn as3645a_set_control(flash, AS_MODE_FLASH, state);\n}\n\nstatic const struct led_flash_ops as3645a_led_flash_ops = {\n\t.flash_brightness_set = as3645a_set_flash_brightness,\n\t.timeout_set = as3645a_set_flash_timeout,\n\t.strobe_set = as3645a_set_strobe,\n\t.fault_get = as3645a_get_fault,\n};\n\nstatic int as3645a_setup(struct as3645a *flash)\n{\n\tstruct device *dev = &flash->client->dev;\n\tu32 fault = 0;\n\tint rval;\n\n\t \n\trval = as3645a_read(flash, AS_FAULT_INFO_REG);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tdev_dbg(dev, \"Fault info: %02x\\n\", rval);\n\n\trval = as3645a_set_current(flash);\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = as3645a_set_timeout(flash);\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = as3645a_set_control(flash, AS_MODE_INDICATOR, false);\n\tif (rval < 0)\n\t\treturn rval;\n\n\t \n\trval = as3645a_get_fault(&flash->fled, &fault);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tdev_dbg(dev, \"AS_INDICATOR_AND_TIMER_REG: %02x\\n\",\n\t\tas3645a_read(flash, AS_INDICATOR_AND_TIMER_REG));\n\tdev_dbg(dev, \"AS_CURRENT_SET_REG: %02x\\n\",\n\t\tas3645a_read(flash, AS_CURRENT_SET_REG));\n\tdev_dbg(dev, \"AS_CONTROL_REG: %02x\\n\",\n\t\tas3645a_read(flash, AS_CONTROL_REG));\n\n\treturn rval & ~AS_FAULT_INFO_LED_AMOUNT ? -EIO : 0;\n}\n\nstatic int as3645a_detect(struct as3645a *flash)\n{\n\tstruct device *dev = &flash->client->dev;\n\tint rval, man, model, rfu, version;\n\tconst char *vendor;\n\n\trval = as3645a_read(flash, AS_DESIGN_INFO_REG);\n\tif (rval < 0) {\n\t\tdev_err(dev, \"can't read design info reg\\n\");\n\t\treturn rval;\n\t}\n\n\tman = AS_DESIGN_INFO_FACTORY(rval);\n\tmodel = AS_DESIGN_INFO_MODEL(rval);\n\n\trval = as3645a_read(flash, AS_VERSION_CONTROL_REG);\n\tif (rval < 0) {\n\t\tdev_err(dev, \"can't read version control reg\\n\");\n\t\treturn rval;\n\t}\n\n\trfu = AS_VERSION_CONTROL_RFU(rval);\n\tversion = AS_VERSION_CONTROL_VERSION(rval);\n\n\t \n\tif (model != 0x01 || rfu != 0x00) {\n\t\tdev_err(dev, \"AS3645A not detected (model %d rfu %d)\\n\",\n\t\t\tmodel, rfu);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (man) {\n\tcase 1:\n\t\tvendor = \"AMS, Austria Micro Systems\";\n\t\tbreak;\n\tcase 2:\n\t\tvendor = \"ADI, Analog Devices Inc.\";\n\t\tbreak;\n\tcase 3:\n\t\tvendor = \"NSC, National Semiconductor\";\n\t\tbreak;\n\tcase 4:\n\t\tvendor = \"NXP\";\n\t\tbreak;\n\tcase 5:\n\t\tvendor = \"TI, Texas Instrument\";\n\t\tbreak;\n\tdefault:\n\t\tvendor = \"Unknown\";\n\t}\n\n\tdev_info(dev, \"Chip vendor: %s (%d) Version: %d\\n\", vendor,\n\t\t man, version);\n\n\trval = as3645a_write(flash, AS_PASSWORD_REG, AS_PASSWORD_UNLOCK_VALUE);\n\tif (rval < 0)\n\t\treturn rval;\n\n\treturn as3645a_write(flash, AS_BOOST_REG, AS_BOOST_CURRENT_DISABLE);\n}\n\nstatic int as3645a_parse_node(struct as3645a *flash,\n\t\t\t      struct fwnode_handle *fwnode)\n{\n\tstruct as3645a_config *cfg = &flash->cfg;\n\tstruct fwnode_handle *child;\n\tint rval;\n\n\tfwnode_for_each_child_node(fwnode, child) {\n\t\tu32 id = 0;\n\n\t\tfwnode_property_read_u32(child, \"reg\", &id);\n\n\t\tswitch (id) {\n\t\tcase AS_LED_FLASH:\n\t\t\tflash->flash_node = child;\n\t\t\tfwnode_handle_get(child);\n\t\t\tbreak;\n\t\tcase AS_LED_INDICATOR:\n\t\t\tflash->indicator_node = child;\n\t\t\tfwnode_handle_get(child);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&flash->client->dev,\n\t\t\t\t \"unknown LED %u encountered, ignoring\\n\", id);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!flash->flash_node) {\n\t\tdev_err(&flash->client->dev, \"can't find flash node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trval = fwnode_property_read_u32(flash->flash_node, \"flash-timeout-us\",\n\t\t\t\t\t&cfg->flash_timeout_us);\n\tif (rval < 0) {\n\t\tdev_err(&flash->client->dev,\n\t\t\t\"can't read flash-timeout-us property for flash\\n\");\n\t\tgoto out_err;\n\t}\n\n\trval = fwnode_property_read_u32(flash->flash_node, \"flash-max-microamp\",\n\t\t\t\t\t&cfg->flash_max_ua);\n\tif (rval < 0) {\n\t\tdev_err(&flash->client->dev,\n\t\t\t\"can't read flash-max-microamp property for flash\\n\");\n\t\tgoto out_err;\n\t}\n\n\trval = fwnode_property_read_u32(flash->flash_node, \"led-max-microamp\",\n\t\t\t\t\t&cfg->assist_max_ua);\n\tif (rval < 0) {\n\t\tdev_err(&flash->client->dev,\n\t\t\t\"can't read led-max-microamp property for flash\\n\");\n\t\tgoto out_err;\n\t}\n\n\tfwnode_property_read_u32(flash->flash_node, \"voltage-reference\",\n\t\t\t\t &cfg->voltage_reference);\n\n\tfwnode_property_read_u32(flash->flash_node, \"ams,input-max-microamp\",\n\t\t\t\t &cfg->peak);\n\tcfg->peak = AS_PEAK_mA_TO_REG(cfg->peak);\n\n\tif (!flash->indicator_node) {\n\t\tdev_warn(&flash->client->dev,\n\t\t\t \"can't find indicator node\\n\");\n\t\trval = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\n\trval = fwnode_property_read_u32(flash->indicator_node,\n\t\t\t\t\t\"led-max-microamp\",\n\t\t\t\t\t&cfg->indicator_max_ua);\n\tif (rval < 0) {\n\t\tdev_err(&flash->client->dev,\n\t\t\t\"can't read led-max-microamp property for indicator\\n\");\n\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\tfwnode_handle_put(flash->flash_node);\n\tfwnode_handle_put(flash->indicator_node);\n\n\treturn rval;\n}\n\nstatic int as3645a_led_class_setup(struct as3645a *flash)\n{\n\tstruct led_classdev *fled_cdev = &flash->fled.led_cdev;\n\tstruct led_classdev *iled_cdev = &flash->iled_cdev;\n\tstruct led_init_data init_data = {};\n\tstruct led_flash_setting *cfg;\n\tint rval;\n\n\tiled_cdev->brightness_set_blocking = as3645a_set_indicator_brightness;\n\tiled_cdev->max_brightness =\n\t\tflash->cfg.indicator_max_ua / AS_INDICATOR_INTENSITY_STEP;\n\tiled_cdev->flags = LED_CORE_SUSPENDRESUME;\n\n\tinit_data.fwnode = flash->indicator_node;\n\tinit_data.devicename = AS_NAME;\n\tinit_data.default_label = \"indicator\";\n\n\trval = led_classdev_register_ext(&flash->client->dev, iled_cdev,\n\t\t\t\t\t &init_data);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tcfg = &flash->fled.brightness;\n\tcfg->min = AS_FLASH_INTENSITY_MIN;\n\tcfg->max = flash->cfg.flash_max_ua;\n\tcfg->step = AS_FLASH_INTENSITY_STEP;\n\tcfg->val = flash->cfg.flash_max_ua;\n\n\tcfg = &flash->fled.timeout;\n\tcfg->min = AS_FLASH_TIMEOUT_MIN;\n\tcfg->max = flash->cfg.flash_timeout_us;\n\tcfg->step = AS_FLASH_TIMEOUT_STEP;\n\tcfg->val = flash->cfg.flash_timeout_us;\n\n\tflash->fled.ops = &as3645a_led_flash_ops;\n\n\tfled_cdev->brightness_set_blocking = as3645a_set_assist_brightness;\n\t \n\tfled_cdev->max_brightness =\n\t\tas3645a_current_to_reg(flash, false,\n\t\t\t\t       flash->cfg.assist_max_ua) + 1;\n\tfled_cdev->flags = LED_DEV_CAP_FLASH | LED_CORE_SUSPENDRESUME;\n\n\tinit_data.fwnode = flash->flash_node;\n\tinit_data.devicename = AS_NAME;\n\tinit_data.default_label = \"flash\";\n\n\trval = led_classdev_flash_register_ext(&flash->client->dev,\n\t\t\t\t\t       &flash->fled, &init_data);\n\tif (rval)\n\t\tgoto out_err;\n\n\treturn rval;\n\nout_err:\n\tled_classdev_unregister(iled_cdev);\n\tdev_err(&flash->client->dev,\n\t\t\"led_classdev_flash_register() failed, error %d\\n\",\n\t\trval);\n\treturn rval;\n}\n\nstatic int as3645a_v4l2_setup(struct as3645a *flash)\n{\n\tstruct led_classdev_flash *fled = &flash->fled;\n\tstruct led_classdev *led = &fled->led_cdev;\n\tstruct v4l2_flash_config cfg = {\n\t\t.intensity = {\n\t\t\t.min = AS_TORCH_INTENSITY_MIN,\n\t\t\t.max = flash->cfg.assist_max_ua,\n\t\t\t.step = AS_TORCH_INTENSITY_STEP,\n\t\t\t.val = flash->cfg.assist_max_ua,\n\t\t},\n\t};\n\tstruct v4l2_flash_config cfgind = {\n\t\t.intensity = {\n\t\t\t.min = AS_INDICATOR_INTENSITY_MIN,\n\t\t\t.max = flash->cfg.indicator_max_ua,\n\t\t\t.step = AS_INDICATOR_INTENSITY_STEP,\n\t\t\t.val = flash->cfg.indicator_max_ua,\n\t\t},\n\t};\n\n\tstrscpy(cfg.dev_name, led->dev->kobj.name, sizeof(cfg.dev_name));\n\tstrscpy(cfgind.dev_name, flash->iled_cdev.dev->kobj.name,\n\t\tsizeof(cfgind.dev_name));\n\n\tflash->vf = v4l2_flash_init(\n\t\t&flash->client->dev, flash->flash_node, &flash->fled, NULL,\n\t\t&cfg);\n\tif (IS_ERR(flash->vf))\n\t\treturn PTR_ERR(flash->vf);\n\n\tflash->vfind = v4l2_flash_indicator_init(\n\t\t&flash->client->dev, flash->indicator_node, &flash->iled_cdev,\n\t\t&cfgind);\n\tif (IS_ERR(flash->vfind)) {\n\t\tv4l2_flash_release(flash->vf);\n\t\treturn PTR_ERR(flash->vfind);\n\t}\n\n\treturn 0;\n}\n\nstatic int as3645a_probe(struct i2c_client *client)\n{\n\tstruct as3645a *flash;\n\tint rval;\n\n\tif (!dev_fwnode(&client->dev))\n\t\treturn -ENODEV;\n\n\tflash = devm_kzalloc(&client->dev, sizeof(*flash), GFP_KERNEL);\n\tif (flash == NULL)\n\t\treturn -ENOMEM;\n\n\tflash->client = client;\n\n\trval = as3645a_parse_node(flash, dev_fwnode(&client->dev));\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = as3645a_detect(flash);\n\tif (rval < 0)\n\t\tgoto out_put_nodes;\n\n\tmutex_init(&flash->mutex);\n\ti2c_set_clientdata(client, flash);\n\n\trval = as3645a_setup(flash);\n\tif (rval)\n\t\tgoto out_mutex_destroy;\n\n\trval = as3645a_led_class_setup(flash);\n\tif (rval)\n\t\tgoto out_mutex_destroy;\n\n\trval = as3645a_v4l2_setup(flash);\n\tif (rval)\n\t\tgoto out_led_classdev_flash_unregister;\n\n\treturn 0;\n\nout_led_classdev_flash_unregister:\n\tled_classdev_flash_unregister(&flash->fled);\n\nout_mutex_destroy:\n\tmutex_destroy(&flash->mutex);\n\nout_put_nodes:\n\tfwnode_handle_put(flash->flash_node);\n\tfwnode_handle_put(flash->indicator_node);\n\n\treturn rval;\n}\n\nstatic void as3645a_remove(struct i2c_client *client)\n{\n\tstruct as3645a *flash = i2c_get_clientdata(client);\n\n\tas3645a_set_control(flash, AS_MODE_EXT_TORCH, false);\n\n\tv4l2_flash_release(flash->vf);\n\tv4l2_flash_release(flash->vfind);\n\n\tled_classdev_flash_unregister(&flash->fled);\n\tled_classdev_unregister(&flash->iled_cdev);\n\n\tmutex_destroy(&flash->mutex);\n\n\tfwnode_handle_put(flash->flash_node);\n\tfwnode_handle_put(flash->indicator_node);\n}\n\nstatic const struct i2c_device_id as3645a_id_table[] = {\n\t{ AS_NAME, 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, as3645a_id_table);\n\nstatic const struct of_device_id as3645a_of_table[] = {\n\t{ .compatible = \"ams,as3645a\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, as3645a_of_table);\n\nstatic struct i2c_driver as3645a_i2c_driver = {\n\t.driver\t= {\n\t\t.of_match_table = as3645a_of_table,\n\t\t.name = AS_NAME,\n\t},\n\t.probe = as3645a_probe,\n\t.remove\t= as3645a_remove,\n\t.id_table = as3645a_id_table,\n};\n\nmodule_i2c_driver(as3645a_i2c_driver);\n\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_AUTHOR(\"Sakari Ailus <sakari.ailus@iki.fi>\");\nMODULE_DESCRIPTION(\"LED flash driver for AS3645A, LM3555 and their clones\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}