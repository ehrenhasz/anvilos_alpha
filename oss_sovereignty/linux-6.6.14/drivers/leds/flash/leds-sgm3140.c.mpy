{
  "module_name": "leds-sgm3140.c",
  "hash_id": "3aaad6102e0c192c2e9fcfc761c7186af9746fa95ac68417944de86047623a06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/flash/leds-sgm3140.c",
  "human_readable_source": "\n\n\n#include <linux/gpio/consumer.h>\n#include <linux/led-class-flash.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/platform_device.h>\n\n#include <media/v4l2-flash-led-class.h>\n\n#define FLASH_TIMEOUT_DEFAULT\t\t250000U  \n#define FLASH_MAX_TIMEOUT_DEFAULT\t300000U  \n\nstruct sgm3140 {\n\tstruct led_classdev_flash fled_cdev;\n\tstruct v4l2_flash *v4l2_flash;\n\n\tstruct timer_list powerdown_timer;\n\n\tstruct gpio_desc *flash_gpio;\n\tstruct gpio_desc *enable_gpio;\n\tstruct regulator *vin_regulator;\n\n\tbool enabled;\n\n\t \n\tu32 timeout;\n\t \n\tu32 max_timeout;\n};\n\nstatic struct sgm3140 *flcdev_to_sgm3140(struct led_classdev_flash *flcdev)\n{\n\treturn container_of(flcdev, struct sgm3140, fled_cdev);\n}\n\nstatic int sgm3140_strobe_set(struct led_classdev_flash *fled_cdev, bool state)\n{\n\tstruct sgm3140 *priv = flcdev_to_sgm3140(fled_cdev);\n\tint ret;\n\n\tif (priv->enabled == state)\n\t\treturn 0;\n\n\tif (state) {\n\t\tret = regulator_enable(priv->vin_regulator);\n\t\tif (ret) {\n\t\t\tdev_err(fled_cdev->led_cdev.dev,\n\t\t\t\t\"failed to enable regulator: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tgpiod_set_value_cansleep(priv->flash_gpio, 1);\n\t\tgpiod_set_value_cansleep(priv->enable_gpio, 1);\n\t\tmod_timer(&priv->powerdown_timer,\n\t\t\t  jiffies + usecs_to_jiffies(priv->timeout));\n\t} else {\n\t\tdel_timer_sync(&priv->powerdown_timer);\n\t\tgpiod_set_value_cansleep(priv->enable_gpio, 0);\n\t\tgpiod_set_value_cansleep(priv->flash_gpio, 0);\n\t\tret = regulator_disable(priv->vin_regulator);\n\t\tif (ret) {\n\t\t\tdev_err(fled_cdev->led_cdev.dev,\n\t\t\t\t\"failed to disable regulator: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpriv->enabled = state;\n\n\treturn 0;\n}\n\nstatic int sgm3140_strobe_get(struct led_classdev_flash *fled_cdev, bool *state)\n{\n\tstruct sgm3140 *priv = flcdev_to_sgm3140(fled_cdev);\n\n\t*state = timer_pending(&priv->powerdown_timer);\n\n\treturn 0;\n}\n\nstatic int sgm3140_timeout_set(struct led_classdev_flash *fled_cdev,\n\t\t\t       u32 timeout)\n{\n\tstruct sgm3140 *priv = flcdev_to_sgm3140(fled_cdev);\n\n\tpriv->timeout = timeout;\n\n\treturn 0;\n}\n\nstatic const struct led_flash_ops sgm3140_flash_ops = {\n\t.strobe_set = sgm3140_strobe_set,\n\t.strobe_get = sgm3140_strobe_get,\n\t.timeout_set = sgm3140_timeout_set,\n};\n\nstatic int sgm3140_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t  enum led_brightness brightness)\n{\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\tstruct sgm3140 *priv = flcdev_to_sgm3140(fled_cdev);\n\tbool enable = brightness == LED_ON;\n\tint ret;\n\n\tif (priv->enabled == enable)\n\t\treturn 0;\n\n\tif (enable) {\n\t\tret = regulator_enable(priv->vin_regulator);\n\t\tif (ret) {\n\t\t\tdev_err(led_cdev->dev,\n\t\t\t\t\"failed to enable regulator: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tgpiod_set_value_cansleep(priv->enable_gpio, 1);\n\t} else {\n\t\tgpiod_set_value_cansleep(priv->enable_gpio, 0);\n\t\tret = regulator_disable(priv->vin_regulator);\n\t\tif (ret) {\n\t\t\tdev_err(led_cdev->dev,\n\t\t\t\t\"failed to disable regulator: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpriv->enabled = enable;\n\n\treturn 0;\n}\n\nstatic void sgm3140_powerdown_timer(struct timer_list *t)\n{\n\tstruct sgm3140 *priv = from_timer(priv, t, powerdown_timer);\n\n\tgpiod_set_value(priv->enable_gpio, 0);\n\tgpiod_set_value(priv->flash_gpio, 0);\n\tregulator_disable(priv->vin_regulator);\n\n\tpriv->enabled = false;\n}\n\nstatic void sgm3140_init_flash_timeout(struct sgm3140 *priv)\n{\n\tstruct led_classdev_flash *fled_cdev = &priv->fled_cdev;\n\tstruct led_flash_setting *s;\n\n\t \n\ts = &fled_cdev->timeout;\n\ts->min = 1;\n\ts->max = priv->max_timeout;\n\ts->step = 1;\n\ts->val = FLASH_TIMEOUT_DEFAULT;\n}\n\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\nstatic void sgm3140_init_v4l2_flash_config(struct sgm3140 *priv,\n\t\t\t\t\tstruct v4l2_flash_config *v4l2_sd_cfg)\n{\n\tstruct led_classdev *led_cdev = &priv->fled_cdev.led_cdev;\n\tstruct led_flash_setting *s;\n\n\tstrscpy(v4l2_sd_cfg->dev_name, led_cdev->dev->kobj.name,\n\t\tsizeof(v4l2_sd_cfg->dev_name));\n\n\t \n\ts = &v4l2_sd_cfg->intensity;\n\ts->min = 0;\n\ts->max = 1;\n\ts->step = 1;\n\ts->val = 1;\n}\n\n#else\nstatic void sgm3140_init_v4l2_flash_config(struct sgm3140 *priv,\n\t\t\t\t\tstruct v4l2_flash_config *v4l2_sd_cfg)\n{\n}\n#endif\n\nstatic int sgm3140_probe(struct platform_device *pdev)\n{\n\tstruct sgm3140 *priv;\n\tstruct led_classdev *led_cdev;\n\tstruct led_classdev_flash *fled_cdev;\n\tstruct led_init_data init_data = {};\n\tstruct fwnode_handle *child_node;\n\tstruct v4l2_flash_config v4l2_sd_cfg = {};\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->flash_gpio = devm_gpiod_get(&pdev->dev, \"flash\", GPIOD_OUT_LOW);\n\tret = PTR_ERR_OR_ZERO(priv->flash_gpio);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"Failed to request flash gpio\\n\");\n\n\tpriv->enable_gpio = devm_gpiod_get(&pdev->dev, \"enable\", GPIOD_OUT_LOW);\n\tret = PTR_ERR_OR_ZERO(priv->enable_gpio);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"Failed to request enable gpio\\n\");\n\n\tpriv->vin_regulator = devm_regulator_get(&pdev->dev, \"vin\");\n\tret = PTR_ERR_OR_ZERO(priv->vin_regulator);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"Failed to request regulator\\n\");\n\n\tchild_node = fwnode_get_next_available_child_node(pdev->dev.fwnode,\n\t\t\t\t\t\t\t  NULL);\n\tif (!child_node) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"No fwnode child node found for connected LED.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = fwnode_property_read_u32(child_node, \"flash-max-timeout-us\",\n\t\t\t\t       &priv->max_timeout);\n\tif (ret) {\n\t\tpriv->max_timeout = FLASH_MAX_TIMEOUT_DEFAULT;\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"flash-max-timeout-us property missing\\n\");\n\t}\n\n\t \n\tpriv->timeout = min(priv->max_timeout, FLASH_TIMEOUT_DEFAULT);\n\n\ttimer_setup(&priv->powerdown_timer, sgm3140_powerdown_timer, 0);\n\n\tfled_cdev = &priv->fled_cdev;\n\tled_cdev = &fled_cdev->led_cdev;\n\n\tfled_cdev->ops = &sgm3140_flash_ops;\n\n\tled_cdev->brightness_set_blocking = sgm3140_brightness_set;\n\tled_cdev->max_brightness = LED_ON;\n\tled_cdev->flags |= LED_DEV_CAP_FLASH;\n\n\tsgm3140_init_flash_timeout(priv);\n\n\tinit_data.fwnode = child_node;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\t \n\tret = devm_led_classdev_flash_register_ext(&pdev->dev,\n\t\t\t\t\t\t   fled_cdev, &init_data);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register flash device: %d\\n\",\n\t\t\tret);\n\t\tgoto err;\n\t}\n\n\tsgm3140_init_v4l2_flash_config(priv, &v4l2_sd_cfg);\n\n\t \n\tpriv->v4l2_flash = v4l2_flash_init(&pdev->dev,\n\t\t\t\t\t   child_node,\n\t\t\t\t\t   fled_cdev, NULL,\n\t\t\t\t\t   &v4l2_sd_cfg);\n\tif (IS_ERR(priv->v4l2_flash)) {\n\t\tret = PTR_ERR(priv->v4l2_flash);\n\t\tgoto err;\n\t}\n\n\treturn ret;\n\nerr:\n\tfwnode_handle_put(child_node);\n\treturn ret;\n}\n\nstatic int sgm3140_remove(struct platform_device *pdev)\n{\n\tstruct sgm3140 *priv = platform_get_drvdata(pdev);\n\n\tdel_timer_sync(&priv->powerdown_timer);\n\n\tv4l2_flash_release(priv->v4l2_flash);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sgm3140_dt_match[] = {\n\t{ .compatible = \"ocs,ocp8110\" },\n\t{ .compatible = \"richtek,rt5033-led\" },\n\t{ .compatible = \"sgmicro,sgm3140\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sgm3140_dt_match);\n\nstatic struct platform_driver sgm3140_driver = {\n\t.probe\t= sgm3140_probe,\n\t.remove\t= sgm3140_remove,\n\t.driver\t= {\n\t\t.name\t= \"sgm3140\",\n\t\t.of_match_table = sgm3140_dt_match,\n\t},\n};\n\nmodule_platform_driver(sgm3140_driver);\n\nMODULE_AUTHOR(\"Luca Weiss <luca@z3ntu.xyz>\");\nMODULE_DESCRIPTION(\"SG Micro SGM3140 charge pump LED driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}