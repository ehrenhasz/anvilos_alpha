{
  "module_name": "leds-rt8515.c",
  "hash_id": "6e2df1b4c6315c703df7b2feb560547bd6dc4f490849d1f4077d4a46535d458e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/flash/leds-rt8515.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/led-class-flash.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n\n#include <media/v4l2-flash-led-class.h>\n\n \n#define RT8515_MIN_IOUT_MA\t15\n#define RT8515_MAX_IOUT_MA\t700\n \n#define RT8515_FLASH_MAX\t16\n#define RT8515_TORCH_MAX\t100\n\n#define RT8515_TIMEOUT_US\t250000U\n#define RT8515_MAX_TIMEOUT_US\t300000U\n\nstruct rt8515 {\n\tstruct led_classdev_flash fled;\n\tstruct device *dev;\n\tstruct v4l2_flash *v4l2_flash;\n\tstruct mutex lock;\n\tstruct regulator *reg;\n\tstruct gpio_desc *enable_torch;\n\tstruct gpio_desc *enable_flash;\n\tstruct timer_list powerdown_timer;\n\tu32 max_timeout;  \n\tint flash_max_intensity;\n\tint torch_max_intensity;\n};\n\nstatic struct rt8515 *to_rt8515(struct led_classdev_flash *fled)\n{\n\treturn container_of(fled, struct rt8515, fled);\n}\n\nstatic void rt8515_gpio_led_off(struct rt8515 *rt)\n{\n\tgpiod_set_value(rt->enable_flash, 0);\n\tgpiod_set_value(rt->enable_torch, 0);\n}\n\nstatic void rt8515_gpio_brightness_commit(struct gpio_desc *gpiod,\n\t\t\t\t\t  int brightness)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < brightness; i++) {\n\t\tgpiod_set_value(gpiod, 0);\n\t\tudelay(1);\n\t\tgpiod_set_value(gpiod, 1);\n\t\tudelay(1);\n\t}\n}\n\n \nstatic int rt8515_led_brightness_set(struct led_classdev *led,\n\t\t\t\t     enum led_brightness brightness)\n{\n\tstruct led_classdev_flash *fled = lcdev_to_flcdev(led);\n\tstruct rt8515 *rt = to_rt8515(fled);\n\n\tmutex_lock(&rt->lock);\n\n\tif (brightness == LED_OFF) {\n\t\t \n\t\trt8515_gpio_led_off(rt);\n\t} else if (brightness < RT8515_TORCH_MAX) {\n\t\t \n\t\trt8515_gpio_brightness_commit(rt->enable_torch, brightness);\n\t} else {\n\t\t \n\t\tgpiod_set_value(rt->enable_torch, 1);\n\t}\n\n\tmutex_unlock(&rt->lock);\n\n\treturn 0;\n}\n\nstatic int rt8515_led_flash_strobe_set(struct led_classdev_flash *fled,\n\t\t\t\t       bool state)\n{\n\tstruct rt8515 *rt = to_rt8515(fled);\n\tstruct led_flash_setting *timeout = &fled->timeout;\n\tint brightness = rt->flash_max_intensity;\n\n\tmutex_lock(&rt->lock);\n\n\tif (state) {\n\t\t \n\t\trt8515_gpio_brightness_commit(rt->enable_flash, brightness);\n\t\t \n\t\tmod_timer(&rt->powerdown_timer,\n\t\t\t  jiffies + usecs_to_jiffies(timeout->val));\n\t} else {\n\t\tdel_timer_sync(&rt->powerdown_timer);\n\t\t \n\t\trt8515_gpio_led_off(rt);\n\t}\n\n\tfled->led_cdev.brightness = LED_OFF;\n\t \n\n\tmutex_unlock(&rt->lock);\n\n\treturn 0;\n}\n\nstatic int rt8515_led_flash_strobe_get(struct led_classdev_flash *fled,\n\t\t\t\t       bool *state)\n{\n\tstruct rt8515 *rt = to_rt8515(fled);\n\n\t*state = timer_pending(&rt->powerdown_timer);\n\n\treturn 0;\n}\n\nstatic int rt8515_led_flash_timeout_set(struct led_classdev_flash *fled,\n\t\t\t\t\tu32 timeout)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct led_flash_ops rt8515_flash_ops = {\n\t.strobe_set = rt8515_led_flash_strobe_set,\n\t.strobe_get = rt8515_led_flash_strobe_get,\n\t.timeout_set = rt8515_led_flash_timeout_set,\n};\n\nstatic void rt8515_powerdown_timer(struct timer_list *t)\n{\n\tstruct rt8515 *rt = from_timer(rt, t, powerdown_timer);\n\n\t \n\trt8515_gpio_led_off(rt);\n}\n\nstatic void rt8515_init_flash_timeout(struct rt8515 *rt)\n{\n\tstruct led_classdev_flash *fled = &rt->fled;\n\tstruct led_flash_setting *s;\n\n\t \n\ts = &fled->timeout;\n\ts->min = 1;\n\ts->max = rt->max_timeout;\n\ts->step = 1;\n\t \n\ts->val = min(rt->max_timeout, RT8515_TIMEOUT_US);\n}\n\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\n \nstatic void rt8515_init_v4l2_flash_config(struct rt8515 *rt,\n\t\t\t\t\t  struct v4l2_flash_config *v4l2_sd_cfg)\n{\n\tstruct led_classdev *led = &rt->fled.led_cdev;\n\tstruct led_flash_setting *s;\n\n\tstrscpy(v4l2_sd_cfg->dev_name, led->dev->kobj.name,\n\t\tsizeof(v4l2_sd_cfg->dev_name));\n\n\t \n\ts = &v4l2_sd_cfg->intensity;\n\ts->min = 1;\n\ts->max = rt->flash_max_intensity;\n\ts->step = 1;\n\ts->val = s->max;\n}\n\nstatic void rt8515_v4l2_flash_release(struct rt8515 *rt)\n{\n\tv4l2_flash_release(rt->v4l2_flash);\n}\n\n#else\nstatic void rt8515_init_v4l2_flash_config(struct rt8515 *rt,\n\t\t\t\t\t  struct v4l2_flash_config *v4l2_sd_cfg)\n{\n}\n\nstatic void rt8515_v4l2_flash_release(struct rt8515 *rt)\n{\n}\n#endif\n\nstatic void rt8515_determine_max_intensity(struct rt8515 *rt,\n\t\t\t\t\t   struct fwnode_handle *led,\n\t\t\t\t\t   const char *resistance,\n\t\t\t\t\t   const char *max_ua_prop, int hw_max,\n\t\t\t\t\t   int *max_intensity_setting)\n{\n\tu32 res = 0;  \n\tu32 ua;\n\tu32 max_ma;\n\tint max_intensity;\n\tint ret;\n\n\tfwnode_property_read_u32(rt->dev->fwnode, resistance, &res);\n\tret = fwnode_property_read_u32(led, max_ua_prop, &ua);\n\n\t \n\tif (ret || res == 0) {\n\t\tdev_err(rt->dev,\n\t\t\t\"either %s or %s missing from DT, using HW max\\n\",\n\t\t\tresistance, max_ua_prop);\n\t\tmax_ma = RT8515_MAX_IOUT_MA;\n\t\tmax_intensity = hw_max;\n\t\tgoto out_assign_max;\n\t}\n\n\t \n\tmax_ma = (5500 * 1000) / res;\n\t \n\tmax_intensity = (ua / 10) / max_ma;\n\n\tdev_info(rt->dev,\n\t\t \"current restricted from %u to %u mA, max intensity %d/100\\n\",\n\t\t max_ma, (ua / 1000), max_intensity);\n\nout_assign_max:\n\tdev_info(rt->dev, \"max intensity %d/%d = %d mA\\n\",\n\t\t max_intensity, hw_max, max_ma);\n\t*max_intensity_setting = max_intensity;\n}\n\nstatic int rt8515_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fwnode_handle *child;\n\tstruct rt8515 *rt;\n\tstruct led_classdev *led;\n\tstruct led_classdev_flash *fled;\n\tstruct led_init_data init_data = {};\n\tstruct v4l2_flash_config v4l2_sd_cfg = {};\n\tint ret;\n\n\trt = devm_kzalloc(dev, sizeof(*rt), GFP_KERNEL);\n\tif (!rt)\n\t\treturn -ENOMEM;\n\n\trt->dev = dev;\n\tfled = &rt->fled;\n\tled = &fled->led_cdev;\n\n\t \n\trt->enable_flash = devm_gpiod_get(dev, \"enf\", GPIOD_OUT_LOW);\n\tif (IS_ERR(rt->enable_flash))\n\t\treturn dev_err_probe(dev, PTR_ERR(rt->enable_flash),\n\t\t\t\t     \"cannot get ENF (enable flash) GPIO\\n\");\n\n\t \n\trt->enable_torch = devm_gpiod_get(dev, \"ent\", GPIOD_OUT_LOW);\n\tif (IS_ERR(rt->enable_torch))\n\t\treturn dev_err_probe(dev, PTR_ERR(rt->enable_torch),\n\t\t\t\t     \"cannot get ENT (enable torch) GPIO\\n\");\n\n\tchild = fwnode_get_next_available_child_node(dev->fwnode, NULL);\n\tif (!child) {\n\t\tdev_err(dev,\n\t\t\t\"No fwnode child node found for connected LED.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tinit_data.fwnode = child;\n\n\trt8515_determine_max_intensity(rt, child, \"richtek,rfs-ohms\",\n\t\t\t\t       \"flash-max-microamp\",\n\t\t\t\t       RT8515_FLASH_MAX,\n\t\t\t\t       &rt->flash_max_intensity);\n\trt8515_determine_max_intensity(rt, child, \"richtek,rts-ohms\",\n\t\t\t\t       \"led-max-microamp\",\n\t\t\t\t       RT8515_TORCH_MAX,\n\t\t\t\t       &rt->torch_max_intensity);\n\n\tret = fwnode_property_read_u32(child, \"flash-max-timeout-us\",\n\t\t\t\t       &rt->max_timeout);\n\tif (ret) {\n\t\trt->max_timeout = RT8515_MAX_TIMEOUT_US;\n\t\tdev_warn(dev,\n\t\t\t \"flash-max-timeout-us property missing\\n\");\n\t}\n\ttimer_setup(&rt->powerdown_timer, rt8515_powerdown_timer, 0);\n\trt8515_init_flash_timeout(rt);\n\n\tfled->ops = &rt8515_flash_ops;\n\n\tled->max_brightness = rt->torch_max_intensity;\n\tled->brightness_set_blocking = rt8515_led_brightness_set;\n\tled->flags |= LED_CORE_SUSPENDRESUME | LED_DEV_CAP_FLASH;\n\n\tmutex_init(&rt->lock);\n\n\tplatform_set_drvdata(pdev, rt);\n\n\tret = devm_led_classdev_flash_register_ext(dev, fled, &init_data);\n\tif (ret) {\n\t\tfwnode_handle_put(child);\n\t\tmutex_destroy(&rt->lock);\n\t\tdev_err(dev, \"can't register LED %s\\n\", led->name);\n\t\treturn ret;\n\t}\n\n\trt8515_init_v4l2_flash_config(rt, &v4l2_sd_cfg);\n\n\t \n\trt->v4l2_flash = v4l2_flash_init(dev, child, fled, NULL, &v4l2_sd_cfg);\n\tif (IS_ERR(rt->v4l2_flash)) {\n\t\tret = PTR_ERR(rt->v4l2_flash);\n\t\tdev_err(dev, \"failed to register V4L2 flash device (%d)\\n\",\n\t\t\tret);\n\t\t \n\t}\n\n\tfwnode_handle_put(child);\n\treturn 0;\n}\n\nstatic int rt8515_remove(struct platform_device *pdev)\n{\n\tstruct rt8515 *rt = platform_get_drvdata(pdev);\n\n\trt8515_v4l2_flash_release(rt);\n\tdel_timer_sync(&rt->powerdown_timer);\n\tmutex_destroy(&rt->lock);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rt8515_match[] = {\n\t{ .compatible = \"richtek,rt8515\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rt8515_match);\n\nstatic struct platform_driver rt8515_driver = {\n\t.driver = {\n\t\t.name  = \"rt8515\",\n\t\t.of_match_table = rt8515_match,\n\t},\n\t.probe  = rt8515_probe,\n\t.remove = rt8515_remove,\n};\nmodule_platform_driver(rt8515_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"Richtek RT8515 LED driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}