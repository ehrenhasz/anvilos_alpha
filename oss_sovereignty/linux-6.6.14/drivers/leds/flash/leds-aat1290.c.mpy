{
  "module_name": "leds-aat1290.c",
  "hash_id": "30ee62b6e70ba8612f281bc8227834d929541c537799468f203a198a96df1ba9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/flash/leds-aat1290.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/led-class-flash.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <media/v4l2-flash-led-class.h>\n\n#define AAT1290_MOVIE_MODE_CURRENT_ADDR\t17\n#define AAT1290_MAX_MM_CURR_PERCENT_0\t16\n#define AAT1290_MAX_MM_CURR_PERCENT_100\t1\n\n#define AAT1290_FLASH_SAFETY_TIMER_ADDR\t18\n\n#define AAT1290_MOVIE_MODE_CONFIG_ADDR\t19\n#define AAT1290_MOVIE_MODE_OFF\t\t1\n#define AAT1290_MOVIE_MODE_ON\t\t3\n\n#define AAT1290_MM_CURRENT_RATIO_ADDR\t20\n#define AAT1290_MM_TO_FL_1_92\t\t1\n\n#define AAT1290_MM_TO_FL_RATIO\t\t1000 / 1920\n#define AAT1290_MAX_MM_CURRENT(fl_max)\t(fl_max * AAT1290_MM_TO_FL_RATIO)\n\n#define AAT1290_LATCH_TIME_MIN_US\t500\n#define AAT1290_LATCH_TIME_MAX_US\t1000\n#define AAT1290_EN_SET_TICK_TIME_US\t1\n#define AAT1290_FLEN_OFF_DELAY_TIME_US\t10\n#define AAT1290_FLASH_TM_NUM_LEVELS\t16\n#define AAT1290_MM_CURRENT_SCALE_SIZE\t15\n\n#define AAT1290_NAME\t\t\t\"aat1290\"\n\n\nstruct aat1290_led_config_data {\n\t \n\tu32 max_mm_current;\n\t \n\tu32 max_flash_current;\n\t \n\tu32 max_flash_tm;\n\t \n\tbool has_external_strobe;\n\t \n\tenum led_brightness max_brightness;\n};\n\nstruct aat1290_led {\n\t \n\tstruct platform_device *pdev;\n\t \n\tstruct mutex lock;\n\n\t \n\tstruct led_classdev_flash fled_cdev;\n\t \n\tstruct v4l2_flash *v4l2_flash;\n\n\t \n\tstruct gpio_desc *gpio_fl_en;\n\t \n\tstruct gpio_desc *gpio_en_set;\n\t \n\tint *mm_current_scale;\n\t \n\tbool movie_mode;\n\t \n\tunsigned int torch_brightness;\n};\n\nstatic struct aat1290_led *fled_cdev_to_led(\n\t\t\t\tstruct led_classdev_flash *fled_cdev)\n{\n\treturn container_of(fled_cdev, struct aat1290_led, fled_cdev);\n}\n\nstatic struct led_classdev_flash *led_cdev_to_fled_cdev(\n\t\t\t\tstruct led_classdev *led_cdev)\n{\n\treturn container_of(led_cdev, struct led_classdev_flash, led_cdev);\n}\n\nstatic void aat1290_as2cwire_write(struct aat1290_led *led, int addr, int value)\n{\n\tint i;\n\n\tgpiod_direction_output(led->gpio_fl_en, 0);\n\tgpiod_direction_output(led->gpio_en_set, 0);\n\n\tudelay(AAT1290_FLEN_OFF_DELAY_TIME_US);\n\n\t \n\tfor (i = 0; i < addr; ++i) {\n\t\tudelay(AAT1290_EN_SET_TICK_TIME_US);\n\t\tgpiod_direction_output(led->gpio_en_set, 0);\n\t\tudelay(AAT1290_EN_SET_TICK_TIME_US);\n\t\tgpiod_direction_output(led->gpio_en_set, 1);\n\t}\n\n\tusleep_range(AAT1290_LATCH_TIME_MIN_US, AAT1290_LATCH_TIME_MAX_US);\n\n\t \n\tfor (i = 0; i < value; ++i) {\n\t\tudelay(AAT1290_EN_SET_TICK_TIME_US);\n\t\tgpiod_direction_output(led->gpio_en_set, 0);\n\t\tudelay(AAT1290_EN_SET_TICK_TIME_US);\n\t\tgpiod_direction_output(led->gpio_en_set, 1);\n\t}\n\n\tusleep_range(AAT1290_LATCH_TIME_MIN_US, AAT1290_LATCH_TIME_MAX_US);\n}\n\nstatic void aat1290_set_flash_safety_timer(struct aat1290_led *led,\n\t\t\t\t\tunsigned int micro_sec)\n{\n\tstruct led_classdev_flash *fled_cdev = &led->fled_cdev;\n\tstruct led_flash_setting *flash_tm = &fled_cdev->timeout;\n\tint flash_tm_reg = AAT1290_FLASH_TM_NUM_LEVELS -\n\t\t\t\t(micro_sec / flash_tm->step) + 1;\n\n\taat1290_as2cwire_write(led, AAT1290_FLASH_SAFETY_TIMER_ADDR,\n\t\t\t\t\t\t\tflash_tm_reg);\n}\n\n \n\nstatic int aat1290_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct led_classdev_flash *fled_cdev = led_cdev_to_fled_cdev(led_cdev);\n\tstruct aat1290_led *led = fled_cdev_to_led(fled_cdev);\n\n\tmutex_lock(&led->lock);\n\n\tif (brightness == 0) {\n\t\tgpiod_direction_output(led->gpio_fl_en, 0);\n\t\tgpiod_direction_output(led->gpio_en_set, 0);\n\t\tled->movie_mode = false;\n\t} else {\n\t\tif (!led->movie_mode) {\n\t\t\taat1290_as2cwire_write(led,\n\t\t\t\tAAT1290_MM_CURRENT_RATIO_ADDR,\n\t\t\t\tAAT1290_MM_TO_FL_1_92);\n\t\t\tled->movie_mode = true;\n\t\t}\n\n\t\taat1290_as2cwire_write(led, AAT1290_MOVIE_MODE_CURRENT_ADDR,\n\t\t\t\tAAT1290_MAX_MM_CURR_PERCENT_0 - brightness);\n\t\taat1290_as2cwire_write(led, AAT1290_MOVIE_MODE_CONFIG_ADDR,\n\t\t\t\tAAT1290_MOVIE_MODE_ON);\n\t}\n\n\tmutex_unlock(&led->lock);\n\n\treturn 0;\n}\n\nstatic int aat1290_led_flash_strobe_set(struct led_classdev_flash *fled_cdev,\n\t\t\t\t\t bool state)\n\n{\n\tstruct aat1290_led *led = fled_cdev_to_led(fled_cdev);\n\tstruct led_classdev *led_cdev = &fled_cdev->led_cdev;\n\tstruct led_flash_setting *timeout = &fled_cdev->timeout;\n\n\tmutex_lock(&led->lock);\n\n\tif (state) {\n\t\taat1290_set_flash_safety_timer(led, timeout->val);\n\t\tgpiod_direction_output(led->gpio_fl_en, 1);\n\t} else {\n\t\tgpiod_direction_output(led->gpio_fl_en, 0);\n\t\tgpiod_direction_output(led->gpio_en_set, 0);\n\t}\n\n\t \n\tled_cdev->brightness = 0;\n\tled->movie_mode = false;\n\n\tmutex_unlock(&led->lock);\n\n\treturn 0;\n}\n\nstatic int aat1290_led_flash_timeout_set(struct led_classdev_flash *fled_cdev,\n\t\t\t\t\t\tu32 timeout)\n{\n\t \n\n\treturn 0;\n}\n\nstatic int aat1290_led_parse_dt(struct aat1290_led *led,\n\t\t\tstruct aat1290_led_config_data *cfg,\n\t\t\tstruct device_node **sub_node)\n{\n\tstruct device *dev = &led->pdev->dev;\n\tstruct device_node *child_node;\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\n\tstruct pinctrl *pinctrl;\n#endif\n\tint ret = 0;\n\n\tled->gpio_fl_en = devm_gpiod_get(dev, \"flen\", GPIOD_ASIS);\n\tif (IS_ERR(led->gpio_fl_en)) {\n\t\tret = PTR_ERR(led->gpio_fl_en);\n\t\tdev_err(dev, \"Unable to claim gpio \\\"flen\\\".\\n\");\n\t\treturn ret;\n\t}\n\n\tled->gpio_en_set = devm_gpiod_get(dev, \"enset\", GPIOD_ASIS);\n\tif (IS_ERR(led->gpio_en_set)) {\n\t\tret = PTR_ERR(led->gpio_en_set);\n\t\tdev_err(dev, \"Unable to claim gpio \\\"enset\\\".\\n\");\n\t\treturn ret;\n\t}\n\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\n\tpinctrl = devm_pinctrl_get_select_default(&led->pdev->dev);\n\tif (IS_ERR(pinctrl)) {\n\t\tcfg->has_external_strobe = false;\n\t\tdev_info(dev,\n\t\t\t \"No support for external strobe detected.\\n\");\n\t} else {\n\t\tcfg->has_external_strobe = true;\n\t}\n#endif\n\n\tchild_node = of_get_next_available_child(dev_of_node(dev), NULL);\n\tif (!child_node) {\n\t\tdev_err(dev, \"No DT child node found for connected LED.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(child_node, \"led-max-microamp\",\n\t\t\t\t&cfg->max_mm_current);\n\t \n\tif (ret < 0)\n\t\tdev_warn(dev,\n\t\t\t\"led-max-microamp DT property missing\\n\");\n\n\tret = of_property_read_u32(child_node, \"flash-max-microamp\",\n\t\t\t\t&cfg->max_flash_current);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"flash-max-microamp DT property missing\\n\");\n\t\tgoto err_parse_dt;\n\t}\n\n\tret = of_property_read_u32(child_node, \"flash-max-timeout-us\",\n\t\t\t\t&cfg->max_flash_tm);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"flash-max-timeout-us DT property missing\\n\");\n\t\tgoto err_parse_dt;\n\t}\n\n\t*sub_node = child_node;\n\nerr_parse_dt:\n\tof_node_put(child_node);\n\n\treturn ret;\n}\n\nstatic void aat1290_led_validate_mm_current(struct aat1290_led *led,\n\t\t\t\t\tstruct aat1290_led_config_data *cfg)\n{\n\tint i, b = 0, e = AAT1290_MM_CURRENT_SCALE_SIZE;\n\n\twhile (e - b > 1) {\n\t\ti = b + (e - b) / 2;\n\t\tif (cfg->max_mm_current < led->mm_current_scale[i])\n\t\t\te = i;\n\t\telse\n\t\t\tb = i;\n\t}\n\n\tcfg->max_mm_current = led->mm_current_scale[b];\n\tcfg->max_brightness = b + 1;\n}\n\nstatic int init_mm_current_scale(struct aat1290_led *led,\n\t\t\tstruct aat1290_led_config_data *cfg)\n{\n\tstatic const int max_mm_current_percent[] = {\n\t\t20, 22, 25, 28, 32, 36, 40, 45, 50, 56,\n\t\t63, 71, 79, 89, 100\n\t};\n\tint i, max_mm_current =\n\t\t\tAAT1290_MAX_MM_CURRENT(cfg->max_flash_current);\n\n\tled->mm_current_scale = devm_kzalloc(&led->pdev->dev,\n\t\t\t\t\tsizeof(max_mm_current_percent),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!led->mm_current_scale)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < AAT1290_MM_CURRENT_SCALE_SIZE; ++i)\n\t\tled->mm_current_scale[i] = max_mm_current *\n\t\t\t\t\t  max_mm_current_percent[i] / 100;\n\n\treturn 0;\n}\n\nstatic int aat1290_led_get_configuration(struct aat1290_led *led,\n\t\t\t\t\tstruct aat1290_led_config_data *cfg,\n\t\t\t\t\tstruct device_node **sub_node)\n{\n\tint ret;\n\n\tret = aat1290_led_parse_dt(led, cfg, sub_node);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tret = init_mm_current_scale(led, cfg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\taat1290_led_validate_mm_current(led, cfg);\n\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\n#else\n\tdevm_kfree(&led->pdev->dev, led->mm_current_scale);\n#endif\n\n\treturn 0;\n}\n\nstatic void aat1290_init_flash_timeout(struct aat1290_led *led,\n\t\t\t\tstruct aat1290_led_config_data *cfg)\n{\n\tstruct led_classdev_flash *fled_cdev = &led->fled_cdev;\n\tstruct led_flash_setting *setting;\n\n\t \n\tsetting = &fled_cdev->timeout;\n\tsetting->min = cfg->max_flash_tm / AAT1290_FLASH_TM_NUM_LEVELS;\n\tsetting->max = cfg->max_flash_tm;\n\tsetting->step = setting->min;\n\tsetting->val = setting->max;\n}\n\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\nstatic enum led_brightness aat1290_intensity_to_brightness(\n\t\t\t\t\tstruct v4l2_flash *v4l2_flash,\n\t\t\t\t\ts32 intensity)\n{\n\tstruct led_classdev_flash *fled_cdev = v4l2_flash->fled_cdev;\n\tstruct aat1290_led *led = fled_cdev_to_led(fled_cdev);\n\tint i;\n\n\tfor (i = AAT1290_MM_CURRENT_SCALE_SIZE - 1; i >= 0; --i)\n\t\tif (intensity >= led->mm_current_scale[i])\n\t\t\treturn i + 1;\n\n\treturn 1;\n}\n\nstatic s32 aat1290_brightness_to_intensity(struct v4l2_flash *v4l2_flash,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct led_classdev_flash *fled_cdev = v4l2_flash->fled_cdev;\n\tstruct aat1290_led *led = fled_cdev_to_led(fled_cdev);\n\n\treturn led->mm_current_scale[brightness - 1];\n}\n\nstatic int aat1290_led_external_strobe_set(struct v4l2_flash *v4l2_flash,\n\t\t\t\t\t\tbool enable)\n{\n\tstruct aat1290_led *led = fled_cdev_to_led(v4l2_flash->fled_cdev);\n\tstruct led_classdev_flash *fled_cdev = v4l2_flash->fled_cdev;\n\tstruct led_classdev *led_cdev = &fled_cdev->led_cdev;\n\tstruct pinctrl *pinctrl;\n\n\tgpiod_direction_output(led->gpio_fl_en, 0);\n\tgpiod_direction_output(led->gpio_en_set, 0);\n\n\tled->movie_mode = false;\n\tled_cdev->brightness = 0;\n\n\tpinctrl = devm_pinctrl_get_select(&led->pdev->dev,\n\t\t\t\t\t\tenable ? \"isp\" : \"host\");\n\tif (IS_ERR(pinctrl)) {\n\t\tdev_warn(&led->pdev->dev, \"Unable to switch strobe source.\\n\");\n\t\treturn PTR_ERR(pinctrl);\n\t}\n\n\treturn 0;\n}\n\nstatic void aat1290_init_v4l2_flash_config(struct aat1290_led *led,\n\t\t\t\t\tstruct aat1290_led_config_data *led_cfg,\n\t\t\t\t\tstruct v4l2_flash_config *v4l2_sd_cfg)\n{\n\tstruct led_classdev *led_cdev = &led->fled_cdev.led_cdev;\n\tstruct led_flash_setting *s;\n\n\tstrscpy(v4l2_sd_cfg->dev_name, led_cdev->dev->kobj.name,\n\t\tsizeof(v4l2_sd_cfg->dev_name));\n\n\ts = &v4l2_sd_cfg->intensity;\n\ts->min = led->mm_current_scale[0];\n\ts->max = led_cfg->max_mm_current;\n\ts->step = 1;\n\ts->val = s->max;\n\n\tv4l2_sd_cfg->has_external_strobe = led_cfg->has_external_strobe;\n}\n\nstatic const struct v4l2_flash_ops v4l2_flash_ops = {\n\t.external_strobe_set = aat1290_led_external_strobe_set,\n\t.intensity_to_led_brightness = aat1290_intensity_to_brightness,\n\t.led_brightness_to_intensity = aat1290_brightness_to_intensity,\n};\n#else\nstatic inline void aat1290_init_v4l2_flash_config(struct aat1290_led *led,\n\t\t\t\tstruct aat1290_led_config_data *led_cfg,\n\t\t\t\tstruct v4l2_flash_config *v4l2_sd_cfg)\n{\n}\nstatic const struct v4l2_flash_ops v4l2_flash_ops;\n#endif\n\nstatic const struct led_flash_ops flash_ops = {\n\t.strobe_set = aat1290_led_flash_strobe_set,\n\t.timeout_set = aat1290_led_flash_timeout_set,\n};\n\nstatic int aat1290_led_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *sub_node = NULL;\n\tstruct aat1290_led *led;\n\tstruct led_classdev *led_cdev;\n\tstruct led_classdev_flash *fled_cdev;\n\tstruct led_init_data init_data = {};\n\tstruct aat1290_led_config_data led_cfg = {};\n\tstruct v4l2_flash_config v4l2_sd_cfg = {};\n\tint ret;\n\n\tled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tled->pdev = pdev;\n\tplatform_set_drvdata(pdev, led);\n\n\tfled_cdev = &led->fled_cdev;\n\tfled_cdev->ops = &flash_ops;\n\tled_cdev = &fled_cdev->led_cdev;\n\n\tret = aat1290_led_get_configuration(led, &led_cfg, &sub_node);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_init(&led->lock);\n\n\t \n\tled_cdev->brightness_set_blocking = aat1290_led_brightness_set;\n\tled_cdev->max_brightness = led_cfg.max_brightness;\n\tled_cdev->flags |= LED_DEV_CAP_FLASH;\n\n\taat1290_init_flash_timeout(led, &led_cfg);\n\n\tinit_data.fwnode = of_fwnode_handle(sub_node);\n\tinit_data.devicename = AAT1290_NAME;\n\n\t \n\tret = led_classdev_flash_register_ext(&pdev->dev, fled_cdev,\n\t\t\t\t\t      &init_data);\n\tif (ret < 0)\n\t\tgoto err_flash_register;\n\n\taat1290_init_v4l2_flash_config(led, &led_cfg, &v4l2_sd_cfg);\n\n\t \n\tled->v4l2_flash = v4l2_flash_init(dev, of_fwnode_handle(sub_node),\n\t\t\t\t\t  fled_cdev, &v4l2_flash_ops,\n\t\t\t\t\t  &v4l2_sd_cfg);\n\tif (IS_ERR(led->v4l2_flash)) {\n\t\tret = PTR_ERR(led->v4l2_flash);\n\t\tgoto error_v4l2_flash_init;\n\t}\n\n\treturn 0;\n\nerror_v4l2_flash_init:\n\tled_classdev_flash_unregister(fled_cdev);\nerr_flash_register:\n\tmutex_destroy(&led->lock);\n\n\treturn ret;\n}\n\nstatic int aat1290_led_remove(struct platform_device *pdev)\n{\n\tstruct aat1290_led *led = platform_get_drvdata(pdev);\n\n\tv4l2_flash_release(led->v4l2_flash);\n\tled_classdev_flash_unregister(&led->fled_cdev);\n\n\tmutex_destroy(&led->lock);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id aat1290_led_dt_match[] = {\n\t{ .compatible = \"skyworks,aat1290\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, aat1290_led_dt_match);\n\nstatic struct platform_driver aat1290_led_driver = {\n\t.probe\t\t= aat1290_led_probe,\n\t.remove\t\t= aat1290_led_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"aat1290\",\n\t\t.of_match_table = aat1290_led_dt_match,\n\t},\n};\n\nmodule_platform_driver(aat1290_led_driver);\n\nMODULE_AUTHOR(\"Jacek Anaszewski <j.anaszewski@samsung.com>\");\nMODULE_DESCRIPTION(\"Skyworks Current Regulator for Flash LEDs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}