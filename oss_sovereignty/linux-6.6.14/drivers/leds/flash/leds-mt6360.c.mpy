{
  "module_name": "leds-mt6360.c",
  "hash_id": "0088933b62ae2d2866fab967338e9a2a97bea771fcb866aa5f919f7d189b95a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/flash/leds-mt6360.c",
  "human_readable_source": "\n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/led-class-flash.h>\n#include <linux/led-class-multicolor.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <media/v4l2-flash-led-class.h>\n\nenum {\n\tMT6360_LED_ISNK1 = 0,\n\tMT6360_LED_ISNK2,\n\tMT6360_LED_ISNK3,\n\tMT6360_LED_ISNKML,\n\tMT6360_LED_FLASH1,\n\tMT6360_LED_FLASH2,\n\tMT6360_MAX_LEDS\n};\n\n#define MT6360_REG_RGBEN\t\t0x380\n#define MT6360_REG_ISNK(_led_no)\t(0x381 + (_led_no))\n#define MT6360_ISNK_ENMASK(_led_no)\tBIT(7 - (_led_no))\n#define MT6360_ISNK_MASK\t\tGENMASK(4, 0)\n#define MT6360_CHRINDSEL_MASK\t\tBIT(3)\n\n \n#define MT6360_VIRTUAL_MULTICOLOR\t(MT6360_MAX_LEDS + 1)\n#define MULTICOLOR_NUM_CHANNELS\t\t3\n\n#define MT6360_REG_FLEDEN\t\t0x37E\n#define MT6360_REG_STRBTO\t\t0x373\n#define MT6360_REG_FLEDBASE(_id)\t(0x372 + 4 * (_id - MT6360_LED_FLASH1))\n#define MT6360_REG_FLEDISTRB(_id)\t(MT6360_REG_FLEDBASE(_id) + 2)\n#define MT6360_REG_FLEDITOR(_id)\t(MT6360_REG_FLEDBASE(_id) + 3)\n#define MT6360_REG_CHGSTAT2\t\t0x3E1\n#define MT6360_REG_FLEDSTAT1\t\t0x3E9\n#define MT6360_ITORCH_MASK\t\tGENMASK(4, 0)\n#define MT6360_ISTROBE_MASK\t\tGENMASK(6, 0)\n#define MT6360_STRBTO_MASK\t\tGENMASK(6, 0)\n#define MT6360_TORCHEN_MASK\t\tBIT(3)\n#define MT6360_STROBEN_MASK\t\tBIT(2)\n#define MT6360_FLCSEN_MASK(_id)\t\tBIT(MT6360_LED_FLASH2 - _id)\n#define MT6360_FLEDCHGVINOVP_MASK\tBIT(3)\n#define MT6360_FLED1STRBTO_MASK\t\tBIT(11)\n#define MT6360_FLED2STRBTO_MASK\t\tBIT(10)\n#define MT6360_FLED1STRB_MASK\t\tBIT(9)\n#define MT6360_FLED2STRB_MASK\t\tBIT(8)\n#define MT6360_FLED1SHORT_MASK\t\tBIT(7)\n#define MT6360_FLED2SHORT_MASK\t\tBIT(6)\n#define MT6360_FLEDLVF_MASK\t\tBIT(3)\n\n#define MT6360_ISNKRGB_STEPUA\t\t2000\n#define MT6360_ISNKRGB_MAXUA\t\t24000\n#define MT6360_ISNKML_STEPUA\t\t5000\n#define MT6360_ISNKML_MAXUA\t\t150000\n\n#define MT6360_ITORCH_MINUA\t\t25000\n#define MT6360_ITORCH_STEPUA\t\t12500\n#define MT6360_ITORCH_MAXUA\t\t400000\n#define MT6360_ISTRB_MINUA\t\t50000\n#define MT6360_ISTRB_STEPUA\t\t12500\n#define MT6360_ISTRB_MAXUA\t\t1500000\n#define MT6360_STRBTO_MINUS\t\t64000\n#define MT6360_STRBTO_STEPUS\t\t32000\n#define MT6360_STRBTO_MAXUS\t\t2432000\n\nstruct mt6360_led {\n\tunion {\n\t\tstruct led_classdev isnk;\n\t\tstruct led_classdev_mc mc;\n\t\tstruct led_classdev_flash flash;\n\t};\n\tstruct v4l2_flash *v4l2_flash;\n\tstruct mt6360_priv *priv;\n\tu32 led_no;\n\tenum led_default_state default_state;\n};\n\nstruct mt6360_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct mutex lock;\n\tunsigned int fled_strobe_used;\n\tunsigned int fled_torch_used;\n\tunsigned int leds_active;\n\tunsigned int leds_count;\n\tstruct mt6360_led leds[];\n};\n\nstatic int mt6360_mc_brightness_set(struct led_classdev *lcdev,\n\t\t\t\t    enum led_brightness level)\n{\n\tstruct led_classdev_mc *mccdev = lcdev_to_mccdev(lcdev);\n\tstruct mt6360_led *led = container_of(mccdev, struct mt6360_led, mc);\n\tstruct mt6360_priv *priv = led->priv;\n\tu32 real_bright, enable_mask = 0, enable = 0;\n\tint i, ret;\n\n\tmutex_lock(&priv->lock);\n\n\tled_mc_calc_color_components(mccdev, level);\n\n\tfor (i = 0; i < mccdev->num_colors; i++) {\n\t\tstruct mc_subled *subled = mccdev->subled_info + i;\n\n\t\treal_bright = min(lcdev->max_brightness, subled->brightness);\n\t\tret = regmap_update_bits(priv->regmap, MT6360_REG_ISNK(i),\n\t\t\t\t\t MT6360_ISNK_MASK, real_bright);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tenable_mask |= MT6360_ISNK_ENMASK(subled->channel);\n\t\tif (real_bright)\n\t\t\tenable |= MT6360_ISNK_ENMASK(subled->channel);\n\t}\n\n\tret = regmap_update_bits(priv->regmap, MT6360_REG_RGBEN, enable_mask,\n\t\t\t\t enable);\n\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int mt6360_isnk_brightness_set(struct led_classdev *lcdev,\n\t\t\t\t      enum led_brightness level)\n{\n\tstruct mt6360_led *led = container_of(lcdev, struct mt6360_led, isnk);\n\tstruct mt6360_priv *priv = led->priv;\n\tu32 enable_mask = MT6360_ISNK_ENMASK(led->led_no);\n\tu32 val = level ? MT6360_ISNK_ENMASK(led->led_no) : 0;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\tret = regmap_update_bits(priv->regmap, MT6360_REG_ISNK(led->led_no),\n\t\t\t\t MT6360_ISNK_MASK, level);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_update_bits(priv->regmap, MT6360_REG_RGBEN, enable_mask,\n\t\t\t\t val);\n\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int mt6360_torch_brightness_set(struct led_classdev *lcdev,\n\t\t\t\t       enum led_brightness level)\n{\n\tstruct mt6360_led *led =\n\t\tcontainer_of(lcdev, struct mt6360_led, flash.led_cdev);\n\tstruct mt6360_priv *priv = led->priv;\n\tu32 enable_mask = MT6360_TORCHEN_MASK | MT6360_FLCSEN_MASK(led->led_no);\n\tu32 val = level ? MT6360_FLCSEN_MASK(led->led_no) : 0;\n\tu32 prev = priv->fled_torch_used, curr;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tif (priv->fled_strobe_used) {\n\t\tdev_warn(lcdev->dev, \"Please disable strobe first [%d]\\n\",\n\t\t\t priv->fled_strobe_used);\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (level)\n\t\tcurr = prev | BIT(led->led_no);\n\telse\n\t\tcurr = prev & ~BIT(led->led_no);\n\n\tif (curr)\n\t\tval |= MT6360_TORCHEN_MASK;\n\n\tif (level) {\n\t\tret = regmap_update_bits(priv->regmap,\n\t\t\t\t\t MT6360_REG_FLEDITOR(led->led_no),\n\t\t\t\t\t MT6360_ITORCH_MASK, level - 1);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tret = regmap_update_bits(priv->regmap, MT6360_REG_FLEDEN, enable_mask,\n\t\t\t\t val);\n\tif (ret)\n\t\tgoto unlock;\n\n\tpriv->fled_torch_used = curr;\n\nunlock:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int mt6360_flash_brightness_set(struct led_classdev_flash *fl_cdev,\n\t\t\t\t       u32 brightness)\n{\n\t \n\treturn 0;\n}\n\nstatic int _mt6360_flash_brightness_set(struct led_classdev_flash *fl_cdev,\n\t\t\t\t\tu32 brightness)\n{\n\tstruct mt6360_led *led =\n\t\tcontainer_of(fl_cdev, struct mt6360_led, flash);\n\tstruct mt6360_priv *priv = led->priv;\n\tstruct led_flash_setting *s = &fl_cdev->brightness;\n\tu32 val = (brightness - s->min) / s->step;\n\n\treturn regmap_update_bits(priv->regmap,\n\t\t\t\t  MT6360_REG_FLEDISTRB(led->led_no),\n\t\t\t\t  MT6360_ISTROBE_MASK, val);\n}\n\nstatic int mt6360_strobe_set(struct led_classdev_flash *fl_cdev, bool state)\n{\n\tstruct mt6360_led *led =\n\t\tcontainer_of(fl_cdev, struct mt6360_led, flash);\n\tstruct mt6360_priv *priv = led->priv;\n\tstruct led_classdev *lcdev = &fl_cdev->led_cdev;\n\tstruct led_flash_setting *s = &fl_cdev->brightness;\n\tu32 enable_mask = MT6360_STROBEN_MASK | MT6360_FLCSEN_MASK(led->led_no);\n\tu32 val = state ? MT6360_FLCSEN_MASK(led->led_no) : 0;\n\tu32 prev = priv->fled_strobe_used, curr;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tif (priv->fled_torch_used) {\n\t\tdev_warn(lcdev->dev, \"Please disable torch first [0x%x]\\n\",\n\t\t\t priv->fled_torch_used);\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (state)\n\t\tcurr = prev | BIT(led->led_no);\n\telse\n\t\tcurr = prev & ~BIT(led->led_no);\n\n\tif (curr)\n\t\tval |= MT6360_STROBEN_MASK;\n\n\tret = regmap_update_bits(priv->regmap, MT6360_REG_FLEDEN, enable_mask,\n\t\t\t\t val);\n\tif (ret) {\n\t\tdev_err(lcdev->dev, \"[%d] control current source %d fail\\n\",\n\t\t\tled->led_no, state);\n\t\tgoto unlock;\n\t}\n\n\t \n\tret = _mt6360_flash_brightness_set(fl_cdev, state ? s->val : s->min);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tif (!prev && curr)\n\t\tusleep_range(5000, 6000);\n\telse if (prev && !curr)\n\t\tudelay(500);\n\n\tpriv->fled_strobe_used = curr;\n\nunlock:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int mt6360_strobe_get(struct led_classdev_flash *fl_cdev, bool *state)\n{\n\tstruct mt6360_led *led =\n\t\tcontainer_of(fl_cdev, struct mt6360_led, flash);\n\tstruct mt6360_priv *priv = led->priv;\n\n\tmutex_lock(&priv->lock);\n\t*state = !!(priv->fled_strobe_used & BIT(led->led_no));\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int mt6360_timeout_set(struct led_classdev_flash *fl_cdev, u32 timeout)\n{\n\tstruct mt6360_led *led =\n\t\tcontainer_of(fl_cdev, struct mt6360_led, flash);\n\tstruct mt6360_priv *priv = led->priv;\n\tstruct led_flash_setting *s = &fl_cdev->timeout;\n\tu32 val = (timeout - s->min) / s->step;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = regmap_update_bits(priv->regmap, MT6360_REG_STRBTO,\n\t\t\t\t MT6360_STRBTO_MASK, val);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int mt6360_fault_get(struct led_classdev_flash *fl_cdev, u32 *fault)\n{\n\tstruct mt6360_led *led =\n\t\tcontainer_of(fl_cdev, struct mt6360_led, flash);\n\tstruct mt6360_priv *priv = led->priv;\n\tu16 fled_stat;\n\tunsigned int chg_stat, strobe_timeout_mask, fled_short_mask;\n\tu32 rfault = 0;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = regmap_read(priv->regmap, MT6360_REG_CHGSTAT2, &chg_stat);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = regmap_raw_read(priv->regmap, MT6360_REG_FLEDSTAT1, &fled_stat,\n\t\t\t      sizeof(fled_stat));\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (led->led_no == MT6360_LED_FLASH1) {\n\t\tstrobe_timeout_mask = MT6360_FLED1STRBTO_MASK;\n\t\tfled_short_mask = MT6360_FLED1SHORT_MASK;\n\t} else {\n\t\tstrobe_timeout_mask = MT6360_FLED2STRBTO_MASK;\n\t\tfled_short_mask = MT6360_FLED2SHORT_MASK;\n\t}\n\n\tif (chg_stat & MT6360_FLEDCHGVINOVP_MASK)\n\t\trfault |= LED_FAULT_INPUT_VOLTAGE;\n\n\tif (fled_stat & strobe_timeout_mask)\n\t\trfault |= LED_FAULT_TIMEOUT;\n\n\tif (fled_stat & fled_short_mask)\n\t\trfault |= LED_FAULT_SHORT_CIRCUIT;\n\n\tif (fled_stat & MT6360_FLEDLVF_MASK)\n\t\trfault |= LED_FAULT_UNDER_VOLTAGE;\n\n\t*fault = rfault;\nunlock:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic const struct led_flash_ops mt6360_flash_ops = {\n\t.flash_brightness_set = mt6360_flash_brightness_set,\n\t.strobe_set = mt6360_strobe_set,\n\t.strobe_get = mt6360_strobe_get,\n\t.timeout_set = mt6360_timeout_set,\n\t.fault_get = mt6360_fault_get,\n};\n\nstatic int mt6360_isnk_init_default_state(struct mt6360_led *led)\n{\n\tstruct mt6360_priv *priv = led->priv;\n\tunsigned int regval;\n\tu32 level;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, MT6360_REG_ISNK(led->led_no), &regval);\n\tif (ret)\n\t\treturn ret;\n\tlevel = regval & MT6360_ISNK_MASK;\n\n\tret = regmap_read(priv->regmap, MT6360_REG_RGBEN, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(regval & MT6360_ISNK_ENMASK(led->led_no)))\n\t\tlevel = LED_OFF;\n\n\tswitch (led->default_state) {\n\tcase LEDS_DEFSTATE_ON:\n\t\tled->isnk.brightness = led->isnk.max_brightness;\n\t\tbreak;\n\tcase LEDS_DEFSTATE_KEEP:\n\t\tled->isnk.brightness = min(level, led->isnk.max_brightness);\n\t\tbreak;\n\tdefault:\n\t\tled->isnk.brightness = LED_OFF;\n\t}\n\n\treturn mt6360_isnk_brightness_set(&led->isnk, led->isnk.brightness);\n}\n\nstatic int mt6360_flash_init_default_state(struct mt6360_led *led)\n{\n\tstruct led_classdev_flash *flash = &led->flash;\n\tstruct mt6360_priv *priv = led->priv;\n\tu32 enable_mask = MT6360_TORCHEN_MASK | MT6360_FLCSEN_MASK(led->led_no);\n\tu32 level;\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, MT6360_REG_FLEDITOR(led->led_no),\n\t\t\t  &regval);\n\tif (ret)\n\t\treturn ret;\n\tlevel = regval & MT6360_ITORCH_MASK;\n\n\tret = regmap_read(priv->regmap, MT6360_REG_FLEDEN, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((regval & enable_mask) == enable_mask)\n\t\tlevel += 1;\n\telse\n\t\tlevel = LED_OFF;\n\n\tswitch (led->default_state) {\n\tcase LEDS_DEFSTATE_ON:\n\t\tflash->led_cdev.brightness = flash->led_cdev.max_brightness;\n\t\tbreak;\n\tcase LEDS_DEFSTATE_KEEP:\n\t\tflash->led_cdev.brightness =\n\t\t\tmin(level, flash->led_cdev.max_brightness);\n\t\tbreak;\n\tdefault:\n\t\tflash->led_cdev.brightness = LED_OFF;\n\t}\n\n\treturn mt6360_torch_brightness_set(&flash->led_cdev,\n\t\t\t\t\t   flash->led_cdev.brightness);\n}\n\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\nstatic int mt6360_flash_external_strobe_set(struct v4l2_flash *v4l2_flash,\n\t\t\t\t\t    bool enable)\n{\n\tstruct led_classdev_flash *flash = v4l2_flash->fled_cdev;\n\tstruct mt6360_led *led = container_of(flash, struct mt6360_led, flash);\n\tstruct mt6360_priv *priv = led->priv;\n\tu32 mask = MT6360_FLCSEN_MASK(led->led_no);\n\tu32 val = enable ? mask : 0;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\tret = regmap_update_bits(priv->regmap, MT6360_REG_FLEDEN, mask, val);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (enable)\n\t\tpriv->fled_strobe_used |= BIT(led->led_no);\n\telse\n\t\tpriv->fled_strobe_used &= ~BIT(led->led_no);\n\nunlock:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_flash_ops v4l2_flash_ops = {\n\t.external_strobe_set = mt6360_flash_external_strobe_set,\n};\n\nstatic void mt6360_init_v4l2_flash_config(struct mt6360_led *led,\n\t\t\t\t\t  struct v4l2_flash_config *config)\n{\n\tstruct led_classdev *lcdev;\n\tstruct led_flash_setting *s = &config->intensity;\n\n\tlcdev = &led->flash.led_cdev;\n\n\ts->min = MT6360_ITORCH_MINUA;\n\ts->step = MT6360_ITORCH_STEPUA;\n\ts->val = s->max = s->min + (lcdev->max_brightness - 1) * s->step;\n\n\tconfig->has_external_strobe = 1;\n\tstrscpy(config->dev_name, lcdev->dev->kobj.name,\n\t\tsizeof(config->dev_name));\n\n\tconfig->flash_faults = LED_FAULT_SHORT_CIRCUIT | LED_FAULT_TIMEOUT |\n\t\t\t       LED_FAULT_INPUT_VOLTAGE |\n\t\t\t       LED_FAULT_UNDER_VOLTAGE;\n}\n#else\nstatic const struct v4l2_flash_ops v4l2_flash_ops;\nstatic void mt6360_init_v4l2_flash_config(struct mt6360_led *led,\n\t\t\t\t\t  struct v4l2_flash_config *config)\n{\n}\n#endif\n\nstatic int mt6360_led_register(struct device *parent, struct mt6360_led *led,\n\t\t\t\tstruct led_init_data *init_data)\n{\n\tstruct mt6360_priv *priv = led->priv;\n\tstruct v4l2_flash_config v4l2_config = {0};\n\tint ret;\n\n\tif ((led->led_no == MT6360_LED_ISNK1 ||\n\t     led->led_no == MT6360_VIRTUAL_MULTICOLOR) &&\n\t     (priv->leds_active & BIT(MT6360_LED_ISNK1))) {\n\t\t \n\t\tret = regmap_update_bits(priv->regmap, MT6360_REG_RGBEN,\n\t\t\t\t\t MT6360_CHRINDSEL_MASK,\n\t\t\t\t\t MT6360_CHRINDSEL_MASK);\n\t\tif (ret) {\n\t\t\tdev_err(parent, \"Failed to config ISNK1 to SW mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tswitch (led->led_no) {\n\tcase MT6360_VIRTUAL_MULTICOLOR:\n\t\tret = mt6360_mc_brightness_set(&led->mc.led_cdev, LED_OFF);\n\t\tif (ret) {\n\t\t\tdev_err(parent,\n\t\t\t\t\"Failed to init multicolor brightness\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_led_classdev_multicolor_register_ext(parent,\n\t\t\t\t\t\t\t   &led->mc, init_data);\n\t\tif (ret) {\n\t\t\tdev_err(parent, \"Couldn't register multicolor\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase MT6360_LED_ISNK1 ... MT6360_LED_ISNKML:\n\t\tret = mt6360_isnk_init_default_state(led);\n\t\tif (ret) {\n\t\t\tdev_err(parent, \"Failed to init %d isnk state\\n\",\n\t\t\t\tled->led_no);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_led_classdev_register_ext(parent, &led->isnk,\n\t\t\t\t\t\t     init_data);\n\t\tif (ret) {\n\t\t\tdev_err(parent, \"Couldn't register isink %d\\n\",\n\t\t\t\tled->led_no);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = mt6360_flash_init_default_state(led);\n\t\tif (ret) {\n\t\t\tdev_err(parent, \"Failed to init %d flash state\\n\",\n\t\t\t\tled->led_no);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_led_classdev_flash_register_ext(parent, &led->flash,\n\t\t\t\t\t\t\t   init_data);\n\t\tif (ret) {\n\t\t\tdev_err(parent, \"Couldn't register flash %d\\n\",\n\t\t\t\tled->led_no);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmt6360_init_v4l2_flash_config(led, &v4l2_config);\n\t\tled->v4l2_flash = v4l2_flash_init(parent, init_data->fwnode,\n\t\t\t\t\t\t  &led->flash,\n\t\t\t\t\t\t  &v4l2_flash_ops,\n\t\t\t\t\t\t  &v4l2_config);\n\t\tif (IS_ERR(led->v4l2_flash)) {\n\t\t\tdev_err(parent, \"Failed to register %d v4l2 sd\\n\",\n\t\t\t\tled->led_no);\n\t\t\treturn PTR_ERR(led->v4l2_flash);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic u32 clamp_align(u32 val, u32 min, u32 max, u32 step)\n{\n\tu32 retval;\n\n\tretval = clamp_val(val, min, max);\n\tif (step > 1)\n\t\tretval = rounddown(retval - min, step) + min;\n\n\treturn retval;\n}\n\nstatic int mt6360_init_isnk_properties(struct mt6360_led *led,\n\t\t\t\t       struct led_init_data *init_data)\n{\n\tstruct led_classdev *lcdev;\n\tstruct mt6360_priv *priv = led->priv;\n\tstruct fwnode_handle *child;\n\tu32 step_uA = MT6360_ISNKRGB_STEPUA, max_uA = MT6360_ISNKRGB_MAXUA;\n\tu32 val;\n\tint num_color = 0, ret;\n\n\tif (led->led_no == MT6360_VIRTUAL_MULTICOLOR) {\n\t\tstruct mc_subled *sub_led;\n\n\t\tsub_led = devm_kzalloc(priv->dev,\n\t\t\tsizeof(*sub_led) * MULTICOLOR_NUM_CHANNELS, GFP_KERNEL);\n\t\tif (!sub_led)\n\t\t\treturn -ENOMEM;\n\n\t\tfwnode_for_each_child_node(init_data->fwnode, child) {\n\t\t\tu32 reg, color;\n\n\t\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\t\tif (ret || reg > MT6360_LED_ISNK3 ||\n\t\t\t    priv->leds_active & BIT(reg))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tret = fwnode_property_read_u32(child, \"color\", &color);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(priv->dev,\n\t\t\t\t\t\"led %d, no color specified\\n\",\n\t\t\t\t\tled->led_no);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpriv->leds_active |= BIT(reg);\n\t\t\tsub_led[num_color].color_index = color;\n\t\t\tsub_led[num_color].channel = reg;\n\t\t\tnum_color++;\n\t\t}\n\n\t\tif (num_color < 2) {\n\t\t\tdev_err(priv->dev,\n\t\t\t     \"Multicolor must include 2 or more led channel\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tled->mc.num_colors = num_color;\n\t\tled->mc.subled_info = sub_led;\n\n\t\tlcdev = &led->mc.led_cdev;\n\t\tlcdev->brightness_set_blocking = mt6360_mc_brightness_set;\n\t} else {\n\t\tif (led->led_no == MT6360_LED_ISNKML) {\n\t\t\tstep_uA = MT6360_ISNKML_STEPUA;\n\t\t\tmax_uA = MT6360_ISNKML_MAXUA;\n\t\t}\n\n\t\tlcdev = &led->isnk;\n\t\tlcdev->brightness_set_blocking = mt6360_isnk_brightness_set;\n\t}\n\n\tret = fwnode_property_read_u32(init_data->fwnode, \"led-max-microamp\",\n\t\t\t\t       &val);\n\tif (ret) {\n\t\tdev_warn(priv->dev,\n\t\t     \"Not specified led-max-microamp, config to the minimum\\n\");\n\t\tval = step_uA;\n\t} else\n\t\tval = clamp_align(val, 0, max_uA, step_uA);\n\n\tlcdev->max_brightness = val / step_uA;\n\n\tfwnode_property_read_string(init_data->fwnode, \"linux,default-trigger\",\n\t\t\t\t    &lcdev->default_trigger);\n\n\treturn 0;\n}\n\nstatic int mt6360_init_flash_properties(struct mt6360_led *led,\n\t\t\t\t\tstruct led_init_data *init_data)\n{\n\tstruct led_classdev_flash *flash = &led->flash;\n\tstruct led_classdev *lcdev = &flash->led_cdev;\n\tstruct mt6360_priv *priv = led->priv;\n\tstruct led_flash_setting *s;\n\tu32 val;\n\tint ret;\n\n\tret = fwnode_property_read_u32(init_data->fwnode, \"led-max-microamp\",\n\t\t\t\t       &val);\n\tif (ret) {\n\t\tdev_warn(priv->dev,\n\t\t     \"Not specified led-max-microamp, config to the minimum\\n\");\n\t\tval = MT6360_ITORCH_MINUA;\n\t} else\n\t\tval = clamp_align(val, MT6360_ITORCH_MINUA, MT6360_ITORCH_MAXUA,\n\t\t\t\t  MT6360_ITORCH_STEPUA);\n\n\tlcdev->max_brightness =\n\t\t(val - MT6360_ITORCH_MINUA) / MT6360_ITORCH_STEPUA + 1;\n\tlcdev->brightness_set_blocking = mt6360_torch_brightness_set;\n\tlcdev->flags |= LED_DEV_CAP_FLASH;\n\n\tret = fwnode_property_read_u32(init_data->fwnode, \"flash-max-microamp\",\n\t\t\t\t       &val);\n\tif (ret) {\n\t\tdev_warn(priv->dev,\n\t\t   \"Not specified flash-max-microamp, config to the minimum\\n\");\n\t\tval = MT6360_ISTRB_MINUA;\n\t} else\n\t\tval = clamp_align(val, MT6360_ISTRB_MINUA, MT6360_ISTRB_MAXUA,\n\t\t\t\t  MT6360_ISTRB_STEPUA);\n\n\ts = &flash->brightness;\n\ts->min = MT6360_ISTRB_MINUA;\n\ts->step = MT6360_ISTRB_STEPUA;\n\ts->val = s->max = val;\n\n\t \n\tret = _mt6360_flash_brightness_set(flash, s->min);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fwnode_property_read_u32(init_data->fwnode,\n\t\t\t\t       \"flash-max-timeout-us\", &val);\n\tif (ret) {\n\t\tdev_warn(priv->dev,\n\t\t \"Not specified flash-max-timeout-us, config to the minimum\\n\");\n\t\tval = MT6360_STRBTO_MINUS;\n\t} else\n\t\tval = clamp_align(val, MT6360_STRBTO_MINUS, MT6360_STRBTO_MAXUS,\n\t\t\t\t  MT6360_STRBTO_STEPUS);\n\n\ts = &flash->timeout;\n\ts->min = MT6360_STRBTO_MINUS;\n\ts->step = MT6360_STRBTO_STEPUS;\n\ts->val = s->max = val;\n\n\tflash->ops = &mt6360_flash_ops;\n\n\treturn 0;\n}\n\nstatic void mt6360_v4l2_flash_release(struct mt6360_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->leds_count; i++) {\n\t\tstruct mt6360_led *led = priv->leds + i;\n\n\t\tif (led->v4l2_flash)\n\t\t\tv4l2_flash_release(led->v4l2_flash);\n\t}\n}\n\nstatic int mt6360_led_probe(struct platform_device *pdev)\n{\n\tstruct mt6360_priv *priv;\n\tstruct fwnode_handle *child;\n\tsize_t count;\n\tint i = 0, ret;\n\n\tcount = device_get_child_node_count(&pdev->dev);\n\tif (!count || count > MT6360_MAX_LEDS) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"No child node or node count over max led number %zu\\n\",\n\t\t\tcount);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev,\n\t\t\t    struct_size(priv, leds, count), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->leds_count = count;\n\tpriv->dev = &pdev->dev;\n\tmutex_init(&priv->lock);\n\n\tpriv->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!priv->regmap) {\n\t\tdev_err(&pdev->dev, \"Failed to get parent regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdevice_for_each_child_node(&pdev->dev, child) {\n\t\tstruct mt6360_led *led = priv->leds + i;\n\t\tstruct led_init_data init_data = { .fwnode = child, };\n\t\tu32 reg, led_color;\n\n\t\tret = fwnode_property_read_u32(child, \"color\", &led_color);\n\t\tif (ret)\n\t\t\tgoto out_flash_release;\n\n\t\tif (led_color == LED_COLOR_ID_RGB ||\n\t\t    led_color == LED_COLOR_ID_MULTI)\n\t\t\treg = MT6360_VIRTUAL_MULTICOLOR;\n\t\telse {\n\t\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\t\tif (ret)\n\t\t\t\tgoto out_flash_release;\n\n\t\t\tif (reg >= MT6360_MAX_LEDS) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_flash_release;\n\t\t\t}\n\t\t}\n\n\t\tif (priv->leds_active & BIT(reg)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_flash_release;\n\t\t}\n\t\tpriv->leds_active |= BIT(reg);\n\n\t\tled->led_no = reg;\n\t\tled->priv = priv;\n\t\tled->default_state = led_init_default_state_get(child);\n\n\t\tif (reg == MT6360_VIRTUAL_MULTICOLOR ||\n\t\t    reg <= MT6360_LED_ISNKML)\n\t\t\tret = mt6360_init_isnk_properties(led, &init_data);\n\t\telse\n\t\t\tret = mt6360_init_flash_properties(led, &init_data);\n\n\t\tif (ret)\n\t\t\tgoto out_flash_release;\n\n\t\tret = mt6360_led_register(&pdev->dev, led, &init_data);\n\t\tif (ret)\n\t\t\tgoto out_flash_release;\n\n\t\ti++;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\treturn 0;\n\nout_flash_release:\n\tmt6360_v4l2_flash_release(priv);\n\treturn ret;\n}\n\nstatic int mt6360_led_remove(struct platform_device *pdev)\n{\n\tstruct mt6360_priv *priv = platform_get_drvdata(pdev);\n\n\tmt6360_v4l2_flash_release(priv);\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused mt6360_led_of_id[] = {\n\t{ .compatible = \"mediatek,mt6360-led\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mt6360_led_of_id);\n\nstatic struct platform_driver mt6360_led_driver = {\n\t.driver = {\n\t\t.name = \"mt6360-led\",\n\t\t.of_match_table = mt6360_led_of_id,\n\t},\n\t.probe = mt6360_led_probe,\n\t.remove = mt6360_led_remove,\n};\nmodule_platform_driver(mt6360_led_driver);\n\nMODULE_AUTHOR(\"Gene Chen <gene_chen@richtek.com>\");\nMODULE_DESCRIPTION(\"MT6360 LED Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}