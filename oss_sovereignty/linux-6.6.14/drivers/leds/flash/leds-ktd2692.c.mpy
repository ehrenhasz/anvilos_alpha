{
  "module_name": "leds-ktd2692.c",
  "hash_id": "2e26ae02b91fa1d358d078a7e7ac7c0f2093457070149b4401d3bdaf3e542d33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/flash/leds-ktd2692.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/led-class-flash.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n \n#define KTD2692_MOVIE_MODE_CURRENT_LEVELS\t16\n#define KTD2692_MM_TO_FL_RATIO(x)\t\t((x) / 3)\n#define KTD2692_MM_MIN_CURR_THRESHOLD_SCALE\t8\n\n \n#define KTD2692_FLASH_MODE_TIMEOUT_LEVELS\t8\n#define KTD2692_FLASH_MODE_TIMEOUT_DISABLE\t0\n#define KTD2692_FLASH_MODE_CURR_PERCENT(x)\t(((x) * 16) / 100)\n\n \n#define GET_TIMEOUT_OFFSET(timeout, step)\t((timeout) / (step))\n\n \n#define KTD2692_REG_LVP_BASE\t\t\t0x00\n#define KTD2692_REG_FLASH_TIMEOUT_BASE\t\t0x20\n#define KTD2692_REG_MM_MIN_CURR_THRESHOLD_BASE\t0x40\n#define KTD2692_REG_MOVIE_CURRENT_BASE\t\t0x60\n#define KTD2692_REG_FLASH_CURRENT_BASE\t\t0x80\n#define KTD2692_REG_MODE_BASE\t\t\t0xA0\n\n \n#define KTD2692_TIME_RESET_US\t\t\t700\n#define KTD2692_TIME_DATA_START_TIME_US\t\t10\n#define KTD2692_TIME_HIGH_END_OF_DATA_US\t350\n#define KTD2692_TIME_LOW_END_OF_DATA_US\t\t10\n#define KTD2692_TIME_SHORT_BITSET_US\t\t4\n#define KTD2692_TIME_LONG_BITSET_US\t\t12\n\n \n#define KTD2692_NAME_LENGTH\t\t\t20\n\nenum ktd2692_bitset {\n\tKTD2692_LOW = 0,\n\tKTD2692_HIGH,\n};\n\n \nenum ktd2692_led_mode {\n\tKTD2692_MODE_DISABLE = 0,\t \n\tKTD2692_MODE_MOVIE,\n\tKTD2692_MODE_FLASH,\n};\n\nstruct ktd2692_led_config_data {\n\t \n\tu32 movie_max_microamp;\n\t \n\tu32 flash_max_microamp;\n\t \n\tu32 flash_max_timeout;\n\t \n\tenum led_brightness max_brightness;\n};\n\nstruct ktd2692_context {\n\t \n\tstruct led_classdev_flash fled_cdev;\n\n\t \n\tstruct mutex lock;\n\tstruct regulator *regulator;\n\n\tstruct gpio_desc *aux_gpio;\n\tstruct gpio_desc *ctrl_gpio;\n\n\tenum ktd2692_led_mode mode;\n\tenum led_brightness torch_brightness;\n};\n\nstatic struct ktd2692_context *fled_cdev_to_led(\n\t\t\t\tstruct led_classdev_flash *fled_cdev)\n{\n\treturn container_of(fled_cdev, struct ktd2692_context, fled_cdev);\n}\n\nstatic void ktd2692_expresswire_start(struct ktd2692_context *led)\n{\n\tgpiod_direction_output(led->ctrl_gpio, KTD2692_HIGH);\n\tudelay(KTD2692_TIME_DATA_START_TIME_US);\n}\n\nstatic void ktd2692_expresswire_reset(struct ktd2692_context *led)\n{\n\tgpiod_direction_output(led->ctrl_gpio, KTD2692_LOW);\n\tudelay(KTD2692_TIME_RESET_US);\n}\n\nstatic void ktd2692_expresswire_end(struct ktd2692_context *led)\n{\n\tgpiod_direction_output(led->ctrl_gpio, KTD2692_LOW);\n\tudelay(KTD2692_TIME_LOW_END_OF_DATA_US);\n\tgpiod_direction_output(led->ctrl_gpio, KTD2692_HIGH);\n\tudelay(KTD2692_TIME_HIGH_END_OF_DATA_US);\n}\n\nstatic void ktd2692_expresswire_set_bit(struct ktd2692_context *led, bool bit)\n{\n\t \n\tif (bit) {\n\t\tgpiod_direction_output(led->ctrl_gpio, KTD2692_LOW);\n\t\tudelay(KTD2692_TIME_SHORT_BITSET_US);\n\t\tgpiod_direction_output(led->ctrl_gpio, KTD2692_HIGH);\n\t\tudelay(KTD2692_TIME_LONG_BITSET_US);\n\t} else {\n\t\tgpiod_direction_output(led->ctrl_gpio, KTD2692_LOW);\n\t\tudelay(KTD2692_TIME_LONG_BITSET_US);\n\t\tgpiod_direction_output(led->ctrl_gpio, KTD2692_HIGH);\n\t\tudelay(KTD2692_TIME_SHORT_BITSET_US);\n\t}\n}\n\nstatic void ktd2692_expresswire_write(struct ktd2692_context *led, u8 value)\n{\n\tint i;\n\n\tktd2692_expresswire_start(led);\n\tfor (i = 7; i >= 0; i--)\n\t\tktd2692_expresswire_set_bit(led, value & BIT(i));\n\tktd2692_expresswire_end(led);\n}\n\nstatic int ktd2692_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t       enum led_brightness brightness)\n{\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\tstruct ktd2692_context *led = fled_cdev_to_led(fled_cdev);\n\n\tmutex_lock(&led->lock);\n\n\tif (brightness == LED_OFF) {\n\t\tled->mode = KTD2692_MODE_DISABLE;\n\t\tgpiod_direction_output(led->aux_gpio, KTD2692_LOW);\n\t} else {\n\t\tktd2692_expresswire_write(led, brightness |\n\t\t\t\t\tKTD2692_REG_MOVIE_CURRENT_BASE);\n\t\tled->mode = KTD2692_MODE_MOVIE;\n\t}\n\n\tktd2692_expresswire_write(led, led->mode | KTD2692_REG_MODE_BASE);\n\tmutex_unlock(&led->lock);\n\n\treturn 0;\n}\n\nstatic int ktd2692_led_flash_strobe_set(struct led_classdev_flash *fled_cdev,\n\t\t\t\t\tbool state)\n{\n\tstruct ktd2692_context *led = fled_cdev_to_led(fled_cdev);\n\tstruct led_flash_setting *timeout = &fled_cdev->timeout;\n\tu32 flash_tm_reg;\n\n\tmutex_lock(&led->lock);\n\n\tif (state) {\n\t\tflash_tm_reg = GET_TIMEOUT_OFFSET(timeout->val, timeout->step);\n\t\tktd2692_expresswire_write(led, flash_tm_reg\n\t\t\t\t| KTD2692_REG_FLASH_TIMEOUT_BASE);\n\n\t\tled->mode = KTD2692_MODE_FLASH;\n\t\tgpiod_direction_output(led->aux_gpio, KTD2692_HIGH);\n\t} else {\n\t\tled->mode = KTD2692_MODE_DISABLE;\n\t\tgpiod_direction_output(led->aux_gpio, KTD2692_LOW);\n\t}\n\n\tktd2692_expresswire_write(led, led->mode | KTD2692_REG_MODE_BASE);\n\n\tfled_cdev->led_cdev.brightness = LED_OFF;\n\tled->mode = KTD2692_MODE_DISABLE;\n\n\tmutex_unlock(&led->lock);\n\n\treturn 0;\n}\n\nstatic int ktd2692_led_flash_timeout_set(struct led_classdev_flash *fled_cdev,\n\t\t\t\t\t u32 timeout)\n{\n\treturn 0;\n}\n\nstatic void ktd2692_init_movie_current_max(struct ktd2692_led_config_data *cfg)\n{\n\tu32 offset, step;\n\tu32 movie_current_microamp;\n\n\toffset = KTD2692_MOVIE_MODE_CURRENT_LEVELS;\n\tstep = KTD2692_MM_TO_FL_RATIO(cfg->flash_max_microamp)\n\t\t/ KTD2692_MOVIE_MODE_CURRENT_LEVELS;\n\n\tdo {\n\t\tmovie_current_microamp = step * offset;\n\t\toffset--;\n\t} while ((movie_current_microamp > cfg->movie_max_microamp) &&\n\t\t(offset > 0));\n\n\tcfg->max_brightness = offset;\n}\n\nstatic void ktd2692_init_flash_timeout(struct led_classdev_flash *fled_cdev,\n\t\t\t\t       struct ktd2692_led_config_data *cfg)\n{\n\tstruct led_flash_setting *setting;\n\n\tsetting = &fled_cdev->timeout;\n\tsetting->min = KTD2692_FLASH_MODE_TIMEOUT_DISABLE;\n\tsetting->max = cfg->flash_max_timeout;\n\tsetting->step = cfg->flash_max_timeout\n\t\t\t/ (KTD2692_FLASH_MODE_TIMEOUT_LEVELS - 1);\n\tsetting->val = cfg->flash_max_timeout;\n}\n\nstatic void ktd2692_setup(struct ktd2692_context *led)\n{\n\tled->mode = KTD2692_MODE_DISABLE;\n\tktd2692_expresswire_reset(led);\n\tgpiod_direction_output(led->aux_gpio, KTD2692_LOW);\n\n\tktd2692_expresswire_write(led, (KTD2692_MM_MIN_CURR_THRESHOLD_SCALE - 1)\n\t\t\t\t | KTD2692_REG_MM_MIN_CURR_THRESHOLD_BASE);\n\tktd2692_expresswire_write(led, KTD2692_FLASH_MODE_CURR_PERCENT(45)\n\t\t\t\t | KTD2692_REG_FLASH_CURRENT_BASE);\n}\n\nstatic void regulator_disable_action(void *_data)\n{\n\tstruct device *dev = _data;\n\tstruct ktd2692_context *led = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_disable(led->regulator);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to disable supply: %d\\n\", ret);\n}\n\nstatic int ktd2692_parse_dt(struct ktd2692_context *led, struct device *dev,\n\t\t\t    struct ktd2692_led_config_data *cfg)\n{\n\tstruct device_node *np = dev_of_node(dev);\n\tstruct device_node *child_node;\n\tint ret;\n\n\tif (!np)\n\t\treturn -ENXIO;\n\n\tled->ctrl_gpio = devm_gpiod_get(dev, \"ctrl\", GPIOD_ASIS);\n\tret = PTR_ERR_OR_ZERO(led->ctrl_gpio);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"cannot get ctrl-gpios\\n\");\n\n\tled->aux_gpio = devm_gpiod_get_optional(dev, \"aux\", GPIOD_ASIS);\n\tif (IS_ERR(led->aux_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(led->aux_gpio), \"cannot get aux-gpios\\n\");\n\n\tled->regulator = devm_regulator_get(dev, \"vin\");\n\tif (IS_ERR(led->regulator))\n\t\tled->regulator = NULL;\n\n\tif (led->regulator) {\n\t\tret = regulator_enable(led->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable supply: %d\\n\", ret);\n\t\t} else {\n\t\t\tret = devm_add_action_or_reset(dev,\n\t\t\t\t\t\tregulator_disable_action, dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tchild_node = of_get_next_available_child(np, NULL);\n\tif (!child_node) {\n\t\tdev_err(dev, \"No DT child node found for connected LED.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tled->fled_cdev.led_cdev.name =\n\t\tof_get_property(child_node, \"label\", NULL) ? : child_node->name;\n\n\tret = of_property_read_u32(child_node, \"led-max-microamp\",\n\t\t\t\t   &cfg->movie_max_microamp);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse led-max-microamp\\n\");\n\t\tgoto err_parse_dt;\n\t}\n\n\tret = of_property_read_u32(child_node, \"flash-max-microamp\",\n\t\t\t\t   &cfg->flash_max_microamp);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse flash-max-microamp\\n\");\n\t\tgoto err_parse_dt;\n\t}\n\n\tret = of_property_read_u32(child_node, \"flash-max-timeout-us\",\n\t\t\t\t   &cfg->flash_max_timeout);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse flash-max-timeout-us\\n\");\n\t\tgoto err_parse_dt;\n\t}\n\nerr_parse_dt:\n\tof_node_put(child_node);\n\treturn ret;\n}\n\nstatic const struct led_flash_ops flash_ops = {\n\t.strobe_set = ktd2692_led_flash_strobe_set,\n\t.timeout_set = ktd2692_led_flash_timeout_set,\n};\n\nstatic int ktd2692_probe(struct platform_device *pdev)\n{\n\tstruct ktd2692_context *led;\n\tstruct led_classdev *led_cdev;\n\tstruct led_classdev_flash *fled_cdev;\n\tstruct ktd2692_led_config_data led_cfg;\n\tint ret;\n\n\tled = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tfled_cdev = &led->fled_cdev;\n\tled_cdev = &fled_cdev->led_cdev;\n\n\tret = ktd2692_parse_dt(led, &pdev->dev, &led_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tktd2692_init_flash_timeout(fled_cdev, &led_cfg);\n\tktd2692_init_movie_current_max(&led_cfg);\n\n\tfled_cdev->ops = &flash_ops;\n\n\tled_cdev->max_brightness = led_cfg.max_brightness;\n\tled_cdev->brightness_set_blocking = ktd2692_led_brightness_set;\n\tled_cdev->flags |= LED_CORE_SUSPENDRESUME | LED_DEV_CAP_FLASH;\n\n\tmutex_init(&led->lock);\n\n\tplatform_set_drvdata(pdev, led);\n\n\tret = led_classdev_flash_register(&pdev->dev, fled_cdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't register LED %s\\n\", led_cdev->name);\n\t\tmutex_destroy(&led->lock);\n\t\treturn ret;\n\t}\n\n\tktd2692_setup(led);\n\n\treturn 0;\n}\n\nstatic int ktd2692_remove(struct platform_device *pdev)\n{\n\tstruct ktd2692_context *led = platform_get_drvdata(pdev);\n\n\tled_classdev_flash_unregister(&led->fled_cdev);\n\n\tmutex_destroy(&led->lock);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ktd2692_match[] = {\n\t{ .compatible = \"kinetic,ktd2692\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ktd2692_match);\n\nstatic struct platform_driver ktd2692_driver = {\n\t.driver = {\n\t\t.name  = \"ktd2692\",\n\t\t.of_match_table = ktd2692_match,\n\t},\n\t.probe  = ktd2692_probe,\n\t.remove = ktd2692_remove,\n};\n\nmodule_platform_driver(ktd2692_driver);\n\nMODULE_AUTHOR(\"Ingi Kim <ingi2.kim@samsung.com>\");\nMODULE_DESCRIPTION(\"Kinetic KTD2692 LED driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}