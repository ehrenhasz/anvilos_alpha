{
  "module_name": "leds-mt6370-flash.c",
  "hash_id": "e475fb64a150ee55d09534472969c13c7e30d418479fb770c3a346a27753231b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/flash/leds-mt6370-flash.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/led-class-flash.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n#include <media/v4l2-flash-led-class.h>\n\nenum {\n\tMT6370_LED_FLASH1 = 0,\n\tMT6370_LED_FLASH2,\n\tMT6370_MAX_LEDS\n};\n\n \n\n#define MT6370_REG_FLEDEN\t\t0x17E\n#define MT6370_REG_STRBTO\t\t0x173\n#define MT6370_REG_CHGSTAT2\t\t0x1D1\n#define MT6370_REG_FLEDSTAT1\t\t0x1D9\n#define MT6370_REG_FLEDISTRB(_id)\t(0x174 + 4 * (_id))\n#define MT6370_REG_FLEDITOR(_id)\t(0x175 + 4 * (_id))\n#define MT6370_ITORCH_MASK\t\tGENMASK(4, 0)\n#define MT6370_ISTROBE_MASK\t\tGENMASK(6, 0)\n#define MT6370_STRBTO_MASK\t\tGENMASK(6, 0)\n#define MT6370_TORCHEN_MASK\t\tBIT(3)\n#define MT6370_STROBEN_MASK\t\tBIT(2)\n#define MT6370_FLCSEN_MASK(_id)\t\tBIT(MT6370_LED_FLASH2 - (_id))\n#define MT6370_FLCSEN_MASK_ALL\t\tGENMASK(1, 0)\n#define MT6370_FLEDCHGVINOVP_MASK\tBIT(3)\n#define MT6370_FLED1STRBTO_MASK\t\tBIT(11)\n#define MT6370_FLED2STRBTO_MASK\t\tBIT(10)\n#define MT6370_FLED1STRB_MASK\t\tBIT(9)\n#define MT6370_FLED2STRB_MASK\t\tBIT(8)\n#define MT6370_FLED1SHORT_MASK\t\tBIT(7)\n#define MT6370_FLED2SHORT_MASK\t\tBIT(6)\n#define MT6370_FLEDLVF_MASK\t\tBIT(3)\n\n#define MT6370_LED_JOINT\t\t2\n#define MT6370_RANGE_FLED_REG\t\t4\n#define MT6370_ITORCH_MIN_uA\t\t25000\n#define MT6370_ITORCH_STEP_uA\t\t12500\n#define MT6370_ITORCH_MAX_uA\t\t400000\n#define MT6370_ITORCH_DOUBLE_MAX_uA\t800000\n#define MT6370_ISTRB_MIN_uA\t\t50000\n#define MT6370_ISTRB_STEP_uA\t\t12500\n#define MT6370_ISTRB_MAX_uA\t\t1500000\n#define MT6370_ISTRB_DOUBLE_MAX_uA\t3000000\n#define MT6370_STRBTO_MIN_US\t\t64000\n#define MT6370_STRBTO_STEP_US\t\t32000\n#define MT6370_STRBTO_MAX_US\t\t2432000\n\n#define to_mt6370_led(ptr, member) container_of(ptr, struct mt6370_led, member)\n\nstruct mt6370_led {\n\tstruct led_classdev_flash flash;\n\tstruct v4l2_flash *v4l2_flash;\n\tstruct mt6370_priv *priv;\n\tu8 led_no;\n};\n\nstruct mt6370_priv {\n\tstruct regmap *regmap;\n\tstruct mutex lock;\n\tunsigned int fled_strobe_used;\n\tunsigned int fled_torch_used;\n\tunsigned int leds_active;\n\tunsigned int leds_count;\n\tstruct mt6370_led leds[];\n};\n\nstatic int mt6370_torch_brightness_set(struct led_classdev *lcdev, enum led_brightness level)\n{\n\tstruct mt6370_led *led = to_mt6370_led(lcdev, flash.led_cdev);\n\tstruct mt6370_priv *priv = led->priv;\n\tu32 led_enable_mask = led->led_no == MT6370_LED_JOINT ? MT6370_FLCSEN_MASK_ALL :\n\t\t\t      MT6370_FLCSEN_MASK(led->led_no);\n\tu32 enable_mask = MT6370_TORCHEN_MASK | led_enable_mask;\n\tu32 val = level ? led_enable_mask : 0;\n\tu32 curr;\n\tint ret, i;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tif (priv->fled_strobe_used) {\n\t\tdev_warn(lcdev->dev, \"Please disable strobe first [%d]\\n\", priv->fled_strobe_used);\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (level)\n\t\tcurr = priv->fled_torch_used | BIT(led->led_no);\n\telse\n\t\tcurr = priv->fled_torch_used & ~BIT(led->led_no);\n\n\tif (curr)\n\t\tval |= MT6370_TORCHEN_MASK;\n\n\tif (level) {\n\t\tlevel -= 1;\n\t\tif (led->led_no == MT6370_LED_JOINT) {\n\t\t\tu32 flevel[MT6370_MAX_LEDS];\n\n\t\t\t \n\t\t\tflevel[0] = level / 2;\n\t\t\tflevel[1] = level - flevel[0];\n\t\t\tfor (i = 0; i < MT6370_MAX_LEDS; i++) {\n\t\t\t\tret = regmap_update_bits(priv->regmap, MT6370_REG_FLEDITOR(i),\n\t\t\t\t\t\t\t MT6370_ITORCH_MASK, flevel[i]);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t} else {\n\t\t\tret = regmap_update_bits(priv->regmap, MT6370_REG_FLEDITOR(led->led_no),\n\t\t\t\t\t\t MT6370_ITORCH_MASK, level);\n\t\t\tif (ret)\n\t\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tret = regmap_update_bits(priv->regmap, MT6370_REG_FLEDEN, enable_mask, val);\n\tif (ret)\n\t\tgoto unlock;\n\n\tpriv->fled_torch_used = curr;\n\nunlock:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int mt6370_flash_brightness_set(struct led_classdev_flash *fl_cdev, u32 brightness)\n{\n\t \n\treturn 0;\n}\n\nstatic int _mt6370_flash_brightness_set(struct led_classdev_flash *fl_cdev, u32 brightness)\n{\n\tstruct mt6370_led *led = to_mt6370_led(fl_cdev, flash);\n\tstruct mt6370_priv *priv = led->priv;\n\tstruct led_flash_setting *setting = &fl_cdev->brightness;\n\tu32 val = (brightness - setting->min) / setting->step;\n\tint ret, i;\n\n\tif (led->led_no == MT6370_LED_JOINT) {\n\t\tu32 flevel[MT6370_MAX_LEDS];\n\n\t\t \n\t\tflevel[0] = val / 2;\n\t\tflevel[1] = val - flevel[0];\n\t\tfor (i = 0; i < MT6370_MAX_LEDS; i++) {\n\t\t\tret = regmap_update_bits(priv->regmap, MT6370_REG_FLEDISTRB(i),\n\t\t\t\t\t\t MT6370_ISTROBE_MASK, flevel[i]);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = regmap_update_bits(priv->regmap, MT6370_REG_FLEDISTRB(led->led_no),\n\t\t\t\t\t MT6370_ISTROBE_MASK, val);\n\t}\n\n\treturn ret;\n}\n\nstatic int mt6370_strobe_set(struct led_classdev_flash *fl_cdev, bool state)\n{\n\tstruct mt6370_led *led = to_mt6370_led(fl_cdev, flash);\n\tstruct mt6370_priv *priv = led->priv;\n\tstruct led_classdev *lcdev = &fl_cdev->led_cdev;\n\tstruct led_flash_setting *s = &fl_cdev->brightness;\n\tu32 led_enable_mask = led->led_no == MT6370_LED_JOINT ? MT6370_FLCSEN_MASK_ALL :\n\t\t\t      MT6370_FLCSEN_MASK(led->led_no);\n\tu32 enable_mask = MT6370_STROBEN_MASK | led_enable_mask;\n\tu32 val = state ? led_enable_mask : 0;\n\tu32 curr;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tif (priv->fled_torch_used) {\n\t\tdev_warn(lcdev->dev, \"Please disable torch first [0x%x]\\n\", priv->fled_torch_used);\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (state)\n\t\tcurr = priv->fled_strobe_used | BIT(led->led_no);\n\telse\n\t\tcurr = priv->fled_strobe_used & ~BIT(led->led_no);\n\n\tif (curr)\n\t\tval |= MT6370_STROBEN_MASK;\n\n\tret = regmap_update_bits(priv->regmap, MT6370_REG_FLEDEN, enable_mask, val);\n\tif (ret) {\n\t\tdev_err(lcdev->dev, \"[%d] control current source %d fail\\n\", led->led_no, state);\n\t\tgoto unlock;\n\t}\n\n\t \n\tret = _mt6370_flash_brightness_set(fl_cdev, state ? s->val : s->min);\n\tif (ret) {\n\t\tdev_err(lcdev->dev, \"[%d] Failed to set brightness\\n\", led->led_no);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (!priv->fled_strobe_used && curr)\n\t\tusleep_range(5000, 6000);\n\telse if (priv->fled_strobe_used && !curr)\n\t\tusleep_range(500, 600);\n\n\tpriv->fled_strobe_used = curr;\n\nunlock:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int mt6370_strobe_get(struct led_classdev_flash *fl_cdev, bool *state)\n{\n\tstruct mt6370_led *led = to_mt6370_led(fl_cdev, flash);\n\tstruct mt6370_priv *priv = led->priv;\n\n\tmutex_lock(&priv->lock);\n\t*state = !!(priv->fled_strobe_used & BIT(led->led_no));\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int mt6370_timeout_set(struct led_classdev_flash *fl_cdev, u32 timeout)\n{\n\tstruct mt6370_led *led = to_mt6370_led(fl_cdev, flash);\n\tstruct mt6370_priv *priv = led->priv;\n\tstruct led_flash_setting *s = &fl_cdev->timeout;\n\tu32 val = (timeout - s->min) / s->step;\n\n\treturn regmap_update_bits(priv->regmap, MT6370_REG_STRBTO, MT6370_STRBTO_MASK, val);\n}\n\nstatic int mt6370_fault_get(struct led_classdev_flash *fl_cdev, u32 *fault)\n{\n\tstruct mt6370_led *led = to_mt6370_led(fl_cdev, flash);\n\tstruct mt6370_priv *priv = led->priv;\n\tu16 fled_stat;\n\tunsigned int chg_stat, strobe_timeout_mask, fled_short_mask;\n\tu32 rfault = 0;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, MT6370_REG_CHGSTAT2, &chg_stat);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_raw_read(priv->regmap, MT6370_REG_FLEDSTAT1, &fled_stat, sizeof(fled_stat));\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (led->led_no) {\n\tcase MT6370_LED_FLASH1:\n\t\tstrobe_timeout_mask = MT6370_FLED1STRBTO_MASK;\n\t\tfled_short_mask = MT6370_FLED1SHORT_MASK;\n\t\tbreak;\n\n\tcase MT6370_LED_FLASH2:\n\t\tstrobe_timeout_mask = MT6370_FLED2STRBTO_MASK;\n\t\tfled_short_mask = MT6370_FLED2SHORT_MASK;\n\t\tbreak;\n\n\tcase MT6370_LED_JOINT:\n\t\tstrobe_timeout_mask = MT6370_FLED1STRBTO_MASK | MT6370_FLED2STRBTO_MASK;\n\t\tfled_short_mask = MT6370_FLED1SHORT_MASK | MT6370_FLED2SHORT_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (chg_stat & MT6370_FLEDCHGVINOVP_MASK)\n\t\trfault |= LED_FAULT_INPUT_VOLTAGE;\n\n\tif (fled_stat & strobe_timeout_mask)\n\t\trfault |= LED_FAULT_TIMEOUT;\n\n\tif (fled_stat & fled_short_mask)\n\t\trfault |= LED_FAULT_SHORT_CIRCUIT;\n\n\tif (fled_stat & MT6370_FLEDLVF_MASK)\n\t\trfault |= LED_FAULT_UNDER_VOLTAGE;\n\n\t*fault = rfault;\n\treturn ret;\n}\n\nstatic const struct led_flash_ops mt6370_flash_ops = {\n\t.flash_brightness_set = mt6370_flash_brightness_set,\n\t.strobe_set = mt6370_strobe_set,\n\t.strobe_get = mt6370_strobe_get,\n\t.timeout_set = mt6370_timeout_set,\n\t.fault_get = mt6370_fault_get,\n};\n\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\nstatic int mt6370_flash_external_strobe_set(struct v4l2_flash *v4l2_flash,\n\t\t\t\t\t    bool enable)\n{\n\tstruct led_classdev_flash *flash = v4l2_flash->fled_cdev;\n\tstruct mt6370_led *led = to_mt6370_led(flash, flash);\n\tstruct mt6370_priv *priv = led->priv;\n\tu32 mask = led->led_no == MT6370_LED_JOINT ? MT6370_FLCSEN_MASK_ALL :\n\t\t   MT6370_FLCSEN_MASK(led->led_no);\n\tu32 val = enable ? mask : 0;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\tret = regmap_update_bits(priv->regmap, MT6370_REG_FLEDEN, mask, val);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (enable)\n\t\tpriv->fled_strobe_used |= BIT(led->led_no);\n\telse\n\t\tpriv->fled_strobe_used &= ~BIT(led->led_no);\n\nunlock:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_flash_ops v4l2_flash_ops = {\n\t.external_strobe_set = mt6370_flash_external_strobe_set,\n};\n\nstatic void mt6370_init_v4l2_flash_config(struct mt6370_led *led, struct v4l2_flash_config *cfg)\n{\n\tstruct led_classdev *lcdev;\n\tstruct led_flash_setting *s = &cfg->intensity;\n\n\tlcdev = &led->flash.led_cdev;\n\n\ts->min = MT6370_ITORCH_MIN_uA;\n\ts->step = MT6370_ITORCH_STEP_uA;\n\ts->val = s->max = s->min + (lcdev->max_brightness - 1) * s->step;\n\n\tcfg->has_external_strobe = 1;\n\tstrscpy(cfg->dev_name, dev_name(lcdev->dev), sizeof(cfg->dev_name));\n\n\tcfg->flash_faults = LED_FAULT_SHORT_CIRCUIT | LED_FAULT_TIMEOUT |\n\t\t\t    LED_FAULT_INPUT_VOLTAGE | LED_FAULT_UNDER_VOLTAGE;\n}\n#else\nstatic const struct v4l2_flash_ops v4l2_flash_ops;\nstatic void mt6370_init_v4l2_flash_config(struct mt6370_led *led, struct v4l2_flash_config *cfg)\n{\n}\n#endif\n\nstatic void mt6370_v4l2_flash_release(void *v4l2_flash)\n{\n\tv4l2_flash_release(v4l2_flash);\n}\n\nstatic int mt6370_led_register(struct device *parent, struct mt6370_led *led,\n\t\t\t       struct fwnode_handle *fwnode)\n{\n\tstruct led_init_data init_data = { .fwnode = fwnode };\n\tstruct v4l2_flash_config v4l2_config = {};\n\tint ret;\n\n\tret = devm_led_classdev_flash_register_ext(parent, &led->flash, &init_data);\n\tif (ret)\n\t\treturn dev_err_probe(parent, ret, \"Couldn't register flash %d\\n\", led->led_no);\n\n\tmt6370_init_v4l2_flash_config(led, &v4l2_config);\n\tled->v4l2_flash = v4l2_flash_init(parent, fwnode, &led->flash, &v4l2_flash_ops,\n\t\t\t\t\t  &v4l2_config);\n\tif (IS_ERR(led->v4l2_flash))\n\t\treturn dev_err_probe(parent, PTR_ERR(led->v4l2_flash),\n\t\t\t\t     \"Failed to register %d v4l2 sd\\n\", led->led_no);\n\n\treturn devm_add_action_or_reset(parent, mt6370_v4l2_flash_release, led->v4l2_flash);\n}\n\nstatic u32 mt6370_clamp(u32 val, u32 min, u32 max, u32 step)\n{\n\tu32 retval;\n\n\tretval = clamp_val(val, min, max);\n\tif (step > 1)\n\t\tretval = rounddown(retval - min, step) + min;\n\n\treturn retval;\n}\n\nstatic int mt6370_init_flash_properties(struct device *dev, struct mt6370_led *led,\n\t\t\t\t\tstruct fwnode_handle *fwnode)\n{\n\tstruct led_classdev_flash *flash = &led->flash;\n\tstruct led_classdev *lcdev = &flash->led_cdev;\n\tstruct mt6370_priv *priv = led->priv;\n\tstruct led_flash_setting *s;\n\tu32 sources[MT6370_MAX_LEDS];\n\tu32 max_ua, val;\n\tint i, ret, num;\n\n\tnum = fwnode_property_count_u32(fwnode, \"led-sources\");\n\tif (num < 1)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Not specified or wrong number of led-sources\\n\");\n\n\tret = fwnode_property_read_u32_array(fwnode, \"led-sources\", sources, num);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (sources[i] >= MT6370_MAX_LEDS)\n\t\t\treturn -EINVAL;\n\t\tif (priv->leds_active & BIT(sources[i]))\n\t\t\treturn -EINVAL;\n\t\tpriv->leds_active |= BIT(sources[i]);\n\t}\n\n\t \n\tled->led_no = num == 2 ? MT6370_LED_JOINT : sources[0];\n\n\tmax_ua = num == 2 ? MT6370_ITORCH_DOUBLE_MAX_uA : MT6370_ITORCH_MAX_uA;\n\tval = MT6370_ITORCH_MIN_uA;\n\tret = fwnode_property_read_u32(fwnode, \"led-max-microamp\", &val);\n\tif (!ret)\n\t\tval = mt6370_clamp(val, MT6370_ITORCH_MIN_uA, max_ua, MT6370_ITORCH_STEP_uA);\n\n\tlcdev->max_brightness = (val - MT6370_ITORCH_MIN_uA) / MT6370_ITORCH_STEP_uA + 1;\n\tlcdev->brightness_set_blocking = mt6370_torch_brightness_set;\n\tlcdev->flags |= LED_DEV_CAP_FLASH;\n\n\tmax_ua = num == 2 ? MT6370_ISTRB_DOUBLE_MAX_uA : MT6370_ISTRB_MAX_uA;\n\tval = MT6370_ISTRB_MIN_uA;\n\tret = fwnode_property_read_u32(fwnode, \"flash-max-microamp\", &val);\n\tif (!ret)\n\t\tval = mt6370_clamp(val, MT6370_ISTRB_MIN_uA, max_ua, MT6370_ISTRB_STEP_uA);\n\n\ts = &flash->brightness;\n\ts->min = MT6370_ISTRB_MIN_uA;\n\ts->step = MT6370_ISTRB_STEP_uA;\n\ts->val = s->max = val;\n\n\t \n\tret = _mt6370_flash_brightness_set(flash, s->min);\n\tif (ret)\n\t\treturn ret;\n\n\tval = MT6370_STRBTO_MIN_US;\n\tret = fwnode_property_read_u32(fwnode, \"flash-max-timeout-us\", &val);\n\tif (!ret)\n\t\tval = mt6370_clamp(val, MT6370_STRBTO_MIN_US, MT6370_STRBTO_MAX_US,\n\t\t\t\t   MT6370_STRBTO_STEP_US);\n\n\ts = &flash->timeout;\n\ts->min = MT6370_STRBTO_MIN_US;\n\ts->step = MT6370_STRBTO_STEP_US;\n\ts->val = s->max = val;\n\n\tflash->ops = &mt6370_flash_ops;\n\n\treturn 0;\n}\n\nstatic int mt6370_led_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mt6370_priv *priv;\n\tstruct fwnode_handle *child;\n\tsize_t count;\n\tint i = 0, ret;\n\n\tcount = device_get_child_node_count(dev);\n\tif (!count || count > MT6370_MAX_LEDS)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t       \"No child node or node count over max led number %zu\\n\", count);\n\n\tpriv = devm_kzalloc(dev, struct_size(priv, leds, count), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->leds_count = count;\n\tmutex_init(&priv->lock);\n\n\tpriv->regmap = dev_get_regmap(dev->parent, NULL);\n\tif (!priv->regmap)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Failed to get parent regmap\\n\");\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tstruct mt6370_led *led = priv->leds + i;\n\n\t\tled->priv = priv;\n\n\t\tret = mt6370_init_flash_properties(dev, led, child);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = mt6370_led_register(dev, led, child);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mt6370_led_of_id[] = {\n\t{ .compatible = \"mediatek,mt6370-flashlight\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mt6370_led_of_id);\n\nstatic struct platform_driver mt6370_led_driver = {\n\t.driver = {\n\t\t.name = \"mt6370-flashlight\",\n\t\t.of_match_table = mt6370_led_of_id,\n\t},\n\t.probe = mt6370_led_probe,\n};\nmodule_platform_driver(mt6370_led_driver);\n\nMODULE_AUTHOR(\"Alice Chen <alice_chen@richtek.com>\");\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"MT6370 FLASH LED Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}