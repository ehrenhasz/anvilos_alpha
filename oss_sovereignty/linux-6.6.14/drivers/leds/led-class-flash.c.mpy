{
  "module_name": "led-class-flash.c",
  "hash_id": "7a073677f2a25cdff4935d6551125173d5e1e2bdd85e13b0b32ec3090813e233",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/led-class-flash.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/led-class-flash.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"leds.h\"\n\n#define has_flash_op(fled_cdev, op)\t\t\t\t\\\n\t(fled_cdev && fled_cdev->ops->op)\n\n#define call_flash_op(fled_cdev, op, args...)\t\t\\\n\t((has_flash_op(fled_cdev, op)) ?\t\t\t\\\n\t\t\t(fled_cdev->ops->op(fled_cdev, args)) :\t\\\n\t\t\t-EINVAL)\n\nstatic const char * const led_flash_fault_names[] = {\n\t\"led-over-voltage\",\n\t\"flash-timeout-exceeded\",\n\t\"controller-over-temperature\",\n\t\"controller-short-circuit\",\n\t\"led-power-supply-over-current\",\n\t\"indicator-led-fault\",\n\t\"led-under-voltage\",\n\t\"controller-under-voltage\",\n\t\"led-over-temperature\",\n};\n\nstatic ssize_t flash_brightness_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\tunsigned long state;\n\tssize_t ret;\n\n\tmutex_lock(&led_cdev->led_access);\n\n\tif (led_sysfs_is_disabled(led_cdev)) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tret = kstrtoul(buf, 10, &state);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = led_set_flash_brightness(fled_cdev, state);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = size;\nunlock:\n\tmutex_unlock(&led_cdev->led_access);\n\treturn ret;\n}\n\nstatic ssize_t flash_brightness_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\n\t \n\tled_update_flash_brightness(fled_cdev);\n\n\treturn sprintf(buf, \"%u\\n\", fled_cdev->brightness.val);\n}\nstatic DEVICE_ATTR_RW(flash_brightness);\n\nstatic ssize_t max_flash_brightness_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\n\treturn sprintf(buf, \"%u\\n\", fled_cdev->brightness.max);\n}\nstatic DEVICE_ATTR_RO(max_flash_brightness);\n\nstatic ssize_t flash_strobe_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\tunsigned long state;\n\tssize_t ret = -EBUSY;\n\n\tmutex_lock(&led_cdev->led_access);\n\n\tif (led_sysfs_is_disabled(led_cdev))\n\t\tgoto unlock;\n\n\tret = kstrtoul(buf, 10, &state);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (state > 1) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tret = led_set_flash_strobe(fled_cdev, state);\n\tif (ret < 0)\n\t\tgoto unlock;\n\tret = size;\nunlock:\n\tmutex_unlock(&led_cdev->led_access);\n\treturn ret;\n}\n\nstatic ssize_t flash_strobe_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\tbool state;\n\tint ret;\n\n\t \n\tret = led_get_flash_strobe(fled_cdev, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%u\\n\", state);\n}\nstatic DEVICE_ATTR_RW(flash_strobe);\n\nstatic ssize_t flash_timeout_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\tunsigned long flash_timeout;\n\tssize_t ret;\n\n\tmutex_lock(&led_cdev->led_access);\n\n\tif (led_sysfs_is_disabled(led_cdev)) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tret = kstrtoul(buf, 10, &flash_timeout);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = led_set_flash_timeout(fled_cdev, flash_timeout);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = size;\nunlock:\n\tmutex_unlock(&led_cdev->led_access);\n\treturn ret;\n}\n\nstatic ssize_t flash_timeout_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\n\treturn sprintf(buf, \"%u\\n\", fled_cdev->timeout.val);\n}\nstatic DEVICE_ATTR_RW(flash_timeout);\n\nstatic ssize_t max_flash_timeout_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\n\treturn sprintf(buf, \"%u\\n\", fled_cdev->timeout.max);\n}\nstatic DEVICE_ATTR_RO(max_flash_timeout);\n\nstatic ssize_t flash_fault_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\tu32 fault, mask = 0x1;\n\tchar *pbuf = buf;\n\tint i, ret, buf_len;\n\n\tret = led_get_flash_fault(fled_cdev, &fault);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\t*buf = '\\0';\n\n\tfor (i = 0; i < LED_NUM_FLASH_FAULTS; ++i) {\n\t\tif (fault & mask) {\n\t\t\tbuf_len = sprintf(pbuf, \"%s \",\n\t\t\t\t\t  led_flash_fault_names[i]);\n\t\t\tpbuf += buf_len;\n\t\t}\n\t\tmask <<= 1;\n\t}\n\n\treturn strlen(strcat(buf, \"\\n\"));\n}\nstatic DEVICE_ATTR_RO(flash_fault);\n\nstatic struct attribute *led_flash_strobe_attrs[] = {\n\t&dev_attr_flash_strobe.attr,\n\tNULL,\n};\n\nstatic struct attribute *led_flash_timeout_attrs[] = {\n\t&dev_attr_flash_timeout.attr,\n\t&dev_attr_max_flash_timeout.attr,\n\tNULL,\n};\n\nstatic struct attribute *led_flash_brightness_attrs[] = {\n\t&dev_attr_flash_brightness.attr,\n\t&dev_attr_max_flash_brightness.attr,\n\tNULL,\n};\n\nstatic struct attribute *led_flash_fault_attrs[] = {\n\t&dev_attr_flash_fault.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group led_flash_strobe_group = {\n\t.attrs = led_flash_strobe_attrs,\n};\n\nstatic const struct attribute_group led_flash_timeout_group = {\n\t.attrs = led_flash_timeout_attrs,\n};\n\nstatic const struct attribute_group led_flash_brightness_group = {\n\t.attrs = led_flash_brightness_attrs,\n};\n\nstatic const struct attribute_group led_flash_fault_group = {\n\t.attrs = led_flash_fault_attrs,\n};\n\nstatic void led_flash_resume(struct led_classdev *led_cdev)\n{\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(led_cdev);\n\n\tcall_flash_op(fled_cdev, flash_brightness_set,\n\t\t\t\t\tfled_cdev->brightness.val);\n\tcall_flash_op(fled_cdev, timeout_set, fled_cdev->timeout.val);\n}\n\nstatic void led_flash_init_sysfs_groups(struct led_classdev_flash *fled_cdev)\n{\n\tstruct led_classdev *led_cdev = &fled_cdev->led_cdev;\n\tconst struct led_flash_ops *ops = fled_cdev->ops;\n\tconst struct attribute_group **flash_groups = fled_cdev->sysfs_groups;\n\n\tint num_sysfs_groups = 0;\n\n\tflash_groups[num_sysfs_groups++] = &led_flash_strobe_group;\n\n\tif (ops->flash_brightness_set)\n\t\tflash_groups[num_sysfs_groups++] = &led_flash_brightness_group;\n\n\tif (ops->timeout_set)\n\t\tflash_groups[num_sysfs_groups++] = &led_flash_timeout_group;\n\n\tif (ops->fault_get)\n\t\tflash_groups[num_sysfs_groups++] = &led_flash_fault_group;\n\n\tled_cdev->groups = flash_groups;\n}\n\nint led_classdev_flash_register_ext(struct device *parent,\n\t\t\t\t    struct led_classdev_flash *fled_cdev,\n\t\t\t\t    struct led_init_data *init_data)\n{\n\tstruct led_classdev *led_cdev;\n\tconst struct led_flash_ops *ops;\n\tint ret;\n\n\tif (!fled_cdev)\n\t\treturn -EINVAL;\n\n\tled_cdev = &fled_cdev->led_cdev;\n\n\tif (led_cdev->flags & LED_DEV_CAP_FLASH) {\n\t\tif (!led_cdev->brightness_set_blocking)\n\t\t\treturn -EINVAL;\n\n\t\tops = fled_cdev->ops;\n\t\tif (!ops || !ops->strobe_set)\n\t\t\treturn -EINVAL;\n\n\t\tled_cdev->flash_resume = led_flash_resume;\n\n\t\t \n\t\tled_flash_init_sysfs_groups(fled_cdev);\n\t}\n\n\t \n\tret = led_classdev_register_ext(parent, led_cdev, init_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(led_classdev_flash_register_ext);\n\nvoid led_classdev_flash_unregister(struct led_classdev_flash *fled_cdev)\n{\n\tif (!fled_cdev)\n\t\treturn;\n\n\tled_classdev_unregister(&fled_cdev->led_cdev);\n}\nEXPORT_SYMBOL_GPL(led_classdev_flash_unregister);\n\nstatic void devm_led_classdev_flash_release(struct device *dev, void *res)\n{\n\tled_classdev_flash_unregister(*(struct led_classdev_flash **)res);\n}\n\nint devm_led_classdev_flash_register_ext(struct device *parent,\n\t\t\t\t     struct led_classdev_flash *fled_cdev,\n\t\t\t\t     struct led_init_data *init_data)\n{\n\tstruct led_classdev_flash **dr;\n\tint ret;\n\n\tdr = devres_alloc(devm_led_classdev_flash_release, sizeof(*dr),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tret = led_classdev_flash_register_ext(parent, fled_cdev, init_data);\n\tif (ret) {\n\t\tdevres_free(dr);\n\t\treturn ret;\n\t}\n\n\t*dr = fled_cdev;\n\tdevres_add(parent, dr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_led_classdev_flash_register_ext);\n\nstatic int devm_led_classdev_flash_match(struct device *dev,\n\t\t\t\t\t      void *res, void *data)\n{\n\tstruct led_classdev_flash **p = res;\n\n\tif (WARN_ON(!p || !*p))\n\t\treturn 0;\n\n\treturn *p == data;\n}\n\nvoid devm_led_classdev_flash_unregister(struct device *dev,\n\t\t\t\t\tstruct led_classdev_flash *fled_cdev)\n{\n\tWARN_ON(devres_release(dev,\n\t\t\t       devm_led_classdev_flash_release,\n\t\t\t       devm_led_classdev_flash_match, fled_cdev));\n}\nEXPORT_SYMBOL_GPL(devm_led_classdev_flash_unregister);\n\nstatic void led_clamp_align(struct led_flash_setting *s)\n{\n\tu32 v, offset;\n\n\tv = s->val + s->step / 2;\n\tv = clamp(v, s->min, s->max);\n\toffset = v - s->min;\n\toffset = s->step * (offset / s->step);\n\ts->val = s->min + offset;\n}\n\nint led_set_flash_timeout(struct led_classdev_flash *fled_cdev, u32 timeout)\n{\n\tstruct led_classdev *led_cdev = &fled_cdev->led_cdev;\n\tstruct led_flash_setting *s = &fled_cdev->timeout;\n\n\ts->val = timeout;\n\tled_clamp_align(s);\n\n\tif (!(led_cdev->flags & LED_SUSPENDED))\n\t\treturn call_flash_op(fled_cdev, timeout_set, s->val);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(led_set_flash_timeout);\n\nint led_get_flash_fault(struct led_classdev_flash *fled_cdev, u32 *fault)\n{\n\treturn call_flash_op(fled_cdev, fault_get, fault);\n}\nEXPORT_SYMBOL_GPL(led_get_flash_fault);\n\nint led_set_flash_brightness(struct led_classdev_flash *fled_cdev,\n\t\t\t\tu32 brightness)\n{\n\tstruct led_classdev *led_cdev = &fled_cdev->led_cdev;\n\tstruct led_flash_setting *s = &fled_cdev->brightness;\n\n\ts->val = brightness;\n\tled_clamp_align(s);\n\n\tif (!(led_cdev->flags & LED_SUSPENDED))\n\t\treturn call_flash_op(fled_cdev, flash_brightness_set, s->val);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(led_set_flash_brightness);\n\nint led_update_flash_brightness(struct led_classdev_flash *fled_cdev)\n{\n\tstruct led_flash_setting *s = &fled_cdev->brightness;\n\tu32 brightness;\n\n\tif (has_flash_op(fled_cdev, flash_brightness_get)) {\n\t\tint ret = call_flash_op(fled_cdev, flash_brightness_get,\n\t\t\t\t\t\t&brightness);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ts->val = brightness;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(led_update_flash_brightness);\n\nMODULE_AUTHOR(\"Jacek Anaszewski <j.anaszewski@samsung.com>\");\nMODULE_DESCRIPTION(\"LED Flash class interface\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}