{
  "module_name": "leds-is31fl32xx.c",
  "hash_id": "246d1128e31eba012fc3dc9c59fcdb8fd92916fb32f023a1cad4be57cd7021dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-is31fl32xx.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n \n#define IS31FL32XX_REG_NONE 0xFF\n\n \n#define IS31FL32XX_SHUTDOWN_SSD_ENABLE  0\n#define IS31FL32XX_SHUTDOWN_SSD_DISABLE BIT(0)\n\n \n#define IS31FL3216_CONFIG_REG 0x00\n#define IS31FL3216_LIGHTING_EFFECT_REG 0x03\n#define IS31FL3216_CHANNEL_CONFIG_REG 0x04\n\n \n#define IS31FL3216_CONFIG_SSD_ENABLE  BIT(7)\n#define IS31FL3216_CONFIG_SSD_DISABLE 0\n\nstruct is31fl32xx_priv;\nstruct is31fl32xx_led_data {\n\tstruct led_classdev cdev;\n\tu8 channel;  \n\tstruct is31fl32xx_priv *priv;\n};\n\nstruct is31fl32xx_priv {\n\tconst struct is31fl32xx_chipdef *cdef;\n\tstruct i2c_client *client;\n\tunsigned int num_leds;\n\tstruct is31fl32xx_led_data leds[];\n};\n\n \nstruct is31fl32xx_chipdef {\n\tu8\tchannels;\n\tu8\tshutdown_reg;\n\tu8\tpwm_update_reg;\n\tu8\tglobal_control_reg;\n\tu8\treset_reg;\n\tu8\tpwm_register_base;\n\tbool\tpwm_registers_reversed;\n\tu8\tled_control_register_base;\n\tu8\tenable_bits_per_led_control_register;\n\tint (*reset_func)(struct is31fl32xx_priv *priv);\n\tint (*sw_shutdown_func)(struct is31fl32xx_priv *priv, bool enable);\n};\n\nstatic const struct is31fl32xx_chipdef is31fl3236_cdef = {\n\t.channels\t\t\t\t= 36,\n\t.shutdown_reg\t\t\t\t= 0x00,\n\t.pwm_update_reg\t\t\t\t= 0x25,\n\t.global_control_reg\t\t\t= 0x4a,\n\t.reset_reg\t\t\t\t= 0x4f,\n\t.pwm_register_base\t\t\t= 0x01,\n\t.led_control_register_base\t\t= 0x26,\n\t.enable_bits_per_led_control_register\t= 1,\n};\n\nstatic const struct is31fl32xx_chipdef is31fl3235_cdef = {\n\t.channels\t\t\t\t= 28,\n\t.shutdown_reg\t\t\t\t= 0x00,\n\t.pwm_update_reg\t\t\t\t= 0x25,\n\t.global_control_reg\t\t\t= 0x4a,\n\t.reset_reg\t\t\t\t= 0x4f,\n\t.pwm_register_base\t\t\t= 0x05,\n\t.led_control_register_base\t\t= 0x2a,\n\t.enable_bits_per_led_control_register\t= 1,\n};\n\nstatic const struct is31fl32xx_chipdef is31fl3218_cdef = {\n\t.channels\t\t\t\t= 18,\n\t.shutdown_reg\t\t\t\t= 0x00,\n\t.pwm_update_reg\t\t\t\t= 0x16,\n\t.global_control_reg\t\t\t= IS31FL32XX_REG_NONE,\n\t.reset_reg\t\t\t\t= 0x17,\n\t.pwm_register_base\t\t\t= 0x01,\n\t.led_control_register_base\t\t= 0x13,\n\t.enable_bits_per_led_control_register\t= 6,\n};\n\nstatic int is31fl3216_reset(struct is31fl32xx_priv *priv);\nstatic int is31fl3216_software_shutdown(struct is31fl32xx_priv *priv,\n\t\t\t\t\tbool enable);\nstatic const struct is31fl32xx_chipdef is31fl3216_cdef = {\n\t.channels\t\t\t\t= 16,\n\t.shutdown_reg\t\t\t\t= IS31FL32XX_REG_NONE,\n\t.pwm_update_reg\t\t\t\t= 0xB0,\n\t.global_control_reg\t\t\t= IS31FL32XX_REG_NONE,\n\t.reset_reg\t\t\t\t= IS31FL32XX_REG_NONE,\n\t.pwm_register_base\t\t\t= 0x10,\n\t.pwm_registers_reversed\t\t\t= true,\n\t.led_control_register_base\t\t= 0x01,\n\t.enable_bits_per_led_control_register\t= 8,\n\t.reset_func\t\t\t\t= is31fl3216_reset,\n\t.sw_shutdown_func\t\t\t= is31fl3216_software_shutdown,\n};\n\nstatic int is31fl32xx_write(struct is31fl32xx_priv *priv, u8 reg, u8 val)\n{\n\tint ret;\n\n\tdev_dbg(&priv->client->dev, \"writing register 0x%02X=0x%02X\", reg, val);\n\n\tret =  i2c_smbus_write_byte_data(priv->client, reg, val);\n\tif (ret) {\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"register write to 0x%02X failed (error %d)\",\n\t\t\treg, ret);\n\t}\n\treturn ret;\n}\n\n \nstatic int is31fl3216_reset(struct is31fl32xx_priv *priv)\n{\n\tunsigned int i;\n\tint ret;\n\n\tret = is31fl32xx_write(priv, IS31FL3216_CONFIG_REG,\n\t\t\t       IS31FL3216_CONFIG_SSD_ENABLE);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < priv->cdef->channels; i++) {\n\t\tret = is31fl32xx_write(priv, priv->cdef->pwm_register_base+i,\n\t\t\t\t       0x00);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tret = is31fl32xx_write(priv, priv->cdef->pwm_update_reg, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = is31fl32xx_write(priv, IS31FL3216_LIGHTING_EFFECT_REG, 0x00);\n\tif (ret)\n\t\treturn ret;\n\tret = is31fl32xx_write(priv, IS31FL3216_CHANNEL_CONFIG_REG, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int is31fl3216_software_shutdown(struct is31fl32xx_priv *priv,\n\t\t\t\t\tbool enable)\n{\n\tu8 value = enable ? IS31FL3216_CONFIG_SSD_ENABLE :\n\t\t\t    IS31FL3216_CONFIG_SSD_DISABLE;\n\n\treturn is31fl32xx_write(priv, IS31FL3216_CONFIG_REG, value);\n}\n\n \nstatic int is31fl32xx_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t     enum led_brightness brightness)\n{\n\tconst struct is31fl32xx_led_data *led_data =\n\t\tcontainer_of(led_cdev, struct is31fl32xx_led_data, cdev);\n\tconst struct is31fl32xx_chipdef *cdef = led_data->priv->cdef;\n\tu8 pwm_register_offset;\n\tint ret;\n\n\tdev_dbg(led_cdev->dev, \"%s: %d\\n\", __func__, brightness);\n\n\t \n\tif (cdef->pwm_registers_reversed)\n\t\tpwm_register_offset = cdef->channels - led_data->channel;\n\telse\n\t\tpwm_register_offset = led_data->channel - 1;\n\n\tret = is31fl32xx_write(led_data->priv,\n\t\t\t       cdef->pwm_register_base + pwm_register_offset,\n\t\t\t       brightness);\n\tif (ret)\n\t\treturn ret;\n\n\treturn is31fl32xx_write(led_data->priv, cdef->pwm_update_reg, 0);\n}\n\nstatic int is31fl32xx_reset_regs(struct is31fl32xx_priv *priv)\n{\n\tconst struct is31fl32xx_chipdef *cdef = priv->cdef;\n\tint ret;\n\n\tif (cdef->reset_reg != IS31FL32XX_REG_NONE) {\n\t\tret = is31fl32xx_write(priv, cdef->reset_reg, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (cdef->reset_func)\n\t\treturn cdef->reset_func(priv);\n\n\treturn 0;\n}\n\nstatic int is31fl32xx_software_shutdown(struct is31fl32xx_priv *priv,\n\t\t\t\t\tbool enable)\n{\n\tconst struct is31fl32xx_chipdef *cdef = priv->cdef;\n\tint ret;\n\n\tif (cdef->shutdown_reg != IS31FL32XX_REG_NONE) {\n\t\tu8 value = enable ? IS31FL32XX_SHUTDOWN_SSD_ENABLE :\n\t\t\t\t    IS31FL32XX_SHUTDOWN_SSD_DISABLE;\n\t\tret = is31fl32xx_write(priv, cdef->shutdown_reg, value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (cdef->sw_shutdown_func)\n\t\treturn cdef->sw_shutdown_func(priv, enable);\n\n\treturn 0;\n}\n\nstatic int is31fl32xx_init_regs(struct is31fl32xx_priv *priv)\n{\n\tconst struct is31fl32xx_chipdef *cdef = priv->cdef;\n\tint ret;\n\n\tret = is31fl32xx_reset_regs(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (cdef->led_control_register_base != IS31FL32XX_REG_NONE) {\n\t\tu8 value =\n\t\t    GENMASK(cdef->enable_bits_per_led_control_register-1, 0);\n\t\tu8 num_regs = cdef->channels /\n\t\t\t\tcdef->enable_bits_per_led_control_register;\n\t\tint i;\n\n\t\tfor (i = 0; i < num_regs; i++) {\n\t\t\tret = is31fl32xx_write(priv,\n\t\t\t\t\t       cdef->led_control_register_base+i,\n\t\t\t\t\t       value);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = is31fl32xx_software_shutdown(priv, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cdef->global_control_reg != IS31FL32XX_REG_NONE) {\n\t\tret = is31fl32xx_write(priv, cdef->global_control_reg, 0x00);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int is31fl32xx_parse_child_dt(const struct device *dev,\n\t\t\t\t     const struct device_node *child,\n\t\t\t\t     struct is31fl32xx_led_data *led_data)\n{\n\tstruct led_classdev *cdev = &led_data->cdev;\n\tint ret = 0;\n\tu32 reg;\n\n\tret = of_property_read_u32(child, \"reg\", &reg);\n\tif (ret || reg < 1 || reg > led_data->priv->cdef->channels) {\n\t\tdev_err(dev,\n\t\t\t\"Child node %pOF does not have a valid reg property\\n\",\n\t\t\tchild);\n\t\treturn -EINVAL;\n\t}\n\tled_data->channel = reg;\n\n\tcdev->brightness_set_blocking = is31fl32xx_brightness_set;\n\n\treturn 0;\n}\n\nstatic struct is31fl32xx_led_data *is31fl32xx_find_led_data(\n\t\t\t\t\tstruct is31fl32xx_priv *priv,\n\t\t\t\t\tu8 channel)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < priv->num_leds; i++) {\n\t\tif (priv->leds[i].channel == channel)\n\t\t\treturn &priv->leds[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int is31fl32xx_parse_dt(struct device *dev,\n\t\t\t       struct is31fl32xx_priv *priv)\n{\n\tstruct device_node *child;\n\tint ret = 0;\n\n\tfor_each_available_child_of_node(dev_of_node(dev), child) {\n\t\tstruct led_init_data init_data = {};\n\t\tstruct is31fl32xx_led_data *led_data =\n\t\t\t&priv->leds[priv->num_leds];\n\t\tconst struct is31fl32xx_led_data *other_led_data;\n\n\t\tled_data->priv = priv;\n\n\t\tret = is31fl32xx_parse_child_dt(dev, child, led_data);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tother_led_data = is31fl32xx_find_led_data(priv,\n\t\t\t\t\t\t\t  led_data->channel);\n\t\tif (other_led_data) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Node %pOF 'reg' conflicts with another LED\\n\",\n\t\t\t\tchild);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tinit_data.fwnode = of_fwnode_handle(child);\n\n\t\tret = devm_led_classdev_register_ext(dev, &led_data->cdev,\n\t\t\t\t\t\t     &init_data);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register LED for %pOF: %d\\n\",\n\t\t\t\tchild, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tpriv->num_leds++;\n\t}\n\n\treturn 0;\n\nerr:\n\tof_node_put(child);\n\treturn ret;\n}\n\nstatic const struct of_device_id of_is31fl32xx_match[] = {\n\t{ .compatible = \"issi,is31fl3236\", .data = &is31fl3236_cdef, },\n\t{ .compatible = \"issi,is31fl3235\", .data = &is31fl3235_cdef, },\n\t{ .compatible = \"issi,is31fl3218\", .data = &is31fl3218_cdef, },\n\t{ .compatible = \"si-en,sn3218\",    .data = &is31fl3218_cdef, },\n\t{ .compatible = \"issi,is31fl3216\", .data = &is31fl3216_cdef, },\n\t{ .compatible = \"si-en,sn3216\",    .data = &is31fl3216_cdef, },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, of_is31fl32xx_match);\n\nstatic int is31fl32xx_probe(struct i2c_client *client)\n{\n\tconst struct is31fl32xx_chipdef *cdef;\n\tstruct device *dev = &client->dev;\n\tstruct is31fl32xx_priv *priv;\n\tint count;\n\tint ret = 0;\n\n\tcdef = device_get_match_data(dev);\n\n\tcount = of_get_available_child_count(dev_of_node(dev));\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(dev, struct_size(priv, leds, count),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->client = client;\n\tpriv->cdef = cdef;\n\ti2c_set_clientdata(client, priv);\n\n\tret = is31fl32xx_init_regs(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = is31fl32xx_parse_dt(dev, priv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void is31fl32xx_remove(struct i2c_client *client)\n{\n\tstruct is31fl32xx_priv *priv = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = is31fl32xx_reset_regs(priv);\n\tif (ret)\n\t\tdev_err(&client->dev, \"Failed to reset registers on removal (%pe)\\n\",\n\t\t\tERR_PTR(ret));\n}\n\n \nstatic const struct i2c_device_id is31fl32xx_id[] = {\n\t{ \"is31fl3236\" },\n\t{ \"is31fl3235\" },\n\t{ \"is31fl3218\" },\n\t{ \"sn3218\" },\n\t{ \"is31fl3216\" },\n\t{ \"sn3216\" },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, is31fl32xx_id);\n\nstatic struct i2c_driver is31fl32xx_driver = {\n\t.driver = {\n\t\t.name\t= \"is31fl32xx\",\n\t\t.of_match_table = of_is31fl32xx_match,\n\t},\n\t.probe\t\t= is31fl32xx_probe,\n\t.remove\t\t= is31fl32xx_remove,\n\t.id_table\t= is31fl32xx_id,\n};\n\nmodule_i2c_driver(is31fl32xx_driver);\n\nMODULE_AUTHOR(\"David Rivshin <drivshin@allworx.com>\");\nMODULE_DESCRIPTION(\"ISSI IS31FL32xx LED driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}