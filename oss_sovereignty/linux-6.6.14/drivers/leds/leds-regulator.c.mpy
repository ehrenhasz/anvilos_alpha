{
  "module_name": "leds-regulator.c",
  "hash_id": "21c504e04d5776d7582311de343be88beb28b5fd04f0adffac2ace9bb2778cf8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/leds.h>\n#include <linux/leds-regulator.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#define to_regulator_led(led_cdev) \\\n\tcontainer_of(led_cdev, struct regulator_led, cdev)\n\nstruct regulator_led {\n\tstruct led_classdev cdev;\n\tint enabled;\n\tstruct mutex mutex;\n\n\tstruct regulator *vcc;\n};\n\nstatic inline int led_regulator_get_max_brightness(struct regulator *supply)\n{\n\tint ret;\n\tint voltage = regulator_list_voltage(supply, 0);\n\n\tif (voltage <= 0)\n\t\treturn 1;\n\n\t \n\tret = regulator_set_voltage(supply, voltage, voltage);\n\tif (ret < 0)\n\t\treturn 1;\n\n\treturn regulator_count_voltages(supply);\n}\n\nstatic int led_regulator_get_voltage(struct regulator *supply,\n\t\tenum led_brightness brightness)\n{\n\tif (brightness == 0)\n\t\treturn -EINVAL;\n\n\treturn regulator_list_voltage(supply, brightness - 1);\n}\n\n\nstatic void regulator_led_enable(struct regulator_led *led)\n{\n\tint ret;\n\n\tif (led->enabled)\n\t\treturn;\n\n\tret = regulator_enable(led->vcc);\n\tif (ret != 0) {\n\t\tdev_err(led->cdev.dev, \"Failed to enable vcc: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tled->enabled = 1;\n}\n\nstatic void regulator_led_disable(struct regulator_led *led)\n{\n\tint ret;\n\n\tif (!led->enabled)\n\t\treturn;\n\n\tret = regulator_disable(led->vcc);\n\tif (ret != 0) {\n\t\tdev_err(led->cdev.dev, \"Failed to disable vcc: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tled->enabled = 0;\n}\n\nstatic int regulator_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\t enum led_brightness value)\n{\n\tstruct regulator_led *led = to_regulator_led(led_cdev);\n\tint voltage;\n\tint ret = 0;\n\n\tmutex_lock(&led->mutex);\n\n\tif (value == LED_OFF) {\n\t\tregulator_led_disable(led);\n\t\tgoto out;\n\t}\n\n\tif (led->cdev.max_brightness > 1) {\n\t\tvoltage = led_regulator_get_voltage(led->vcc, value);\n\t\tdev_dbg(led->cdev.dev, \"brightness: %d voltage: %d\\n\",\n\t\t\t\tvalue, voltage);\n\n\t\tret = regulator_set_voltage(led->vcc, voltage, voltage);\n\t\tif (ret != 0)\n\t\t\tdev_err(led->cdev.dev, \"Failed to set voltage %d: %d\\n\",\n\t\t\t\tvoltage, ret);\n\t}\n\n\tregulator_led_enable(led);\n\nout:\n\tmutex_unlock(&led->mutex);\n\treturn ret;\n}\n\nstatic int regulator_led_probe(struct platform_device *pdev)\n{\n\tstruct led_regulator_platform_data *pdata =\n\t\t\tdev_get_platdata(&pdev->dev);\n\tstruct device *dev = &pdev->dev;\n\tstruct led_init_data init_data = {};\n\tstruct regulator_led *led;\n\tstruct regulator *vcc;\n\tint ret = 0;\n\n\tvcc = devm_regulator_get_exclusive(dev, \"vled\");\n\tif (IS_ERR(vcc)) {\n\t\tdev_err(dev, \"Cannot get vcc\\n\");\n\t\treturn PTR_ERR(vcc);\n\t}\n\n\tled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\n\tif (led == NULL)\n\t\treturn -ENOMEM;\n\n\tinit_data.fwnode = dev->fwnode;\n\n\tled->cdev.max_brightness = led_regulator_get_max_brightness(vcc);\n\t \n\tif (pdata) {\n\t\tif (pdata->brightness > led->cdev.max_brightness) {\n\t\t\tdev_err(dev, \"Invalid default brightness %d\\n\",\n\t\t\t\tpdata->brightness);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tled->cdev.brightness = pdata->brightness;\n\t\tinit_data.default_label = pdata->name;\n\t}\n\n\tled->cdev.brightness_set_blocking = regulator_led_brightness_set;\n\tled->cdev.flags |= LED_CORE_SUSPENDRESUME;\n\tled->vcc = vcc;\n\n\t \n\tif (regulator_is_enabled(led->vcc))\n\t\tled->enabled = 1;\n\n\tmutex_init(&led->mutex);\n\n\tplatform_set_drvdata(pdev, led);\n\n\tret = led_classdev_register_ext(dev, &led->cdev, &init_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int regulator_led_remove(struct platform_device *pdev)\n{\n\tstruct regulator_led *led = platform_get_drvdata(pdev);\n\n\tled_classdev_unregister(&led->cdev);\n\tregulator_led_disable(led);\n\treturn 0;\n}\n\nstatic const struct of_device_id regulator_led_of_match[] = {\n\t{ .compatible = \"regulator-led\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, regulator_led_of_match);\n\nstatic struct platform_driver regulator_led_driver = {\n\t.driver = {\n\t\t.name  = \"leds-regulator\",\n\t\t.of_match_table = regulator_led_of_match,\n\t},\n\t.probe  = regulator_led_probe,\n\t.remove = regulator_led_remove,\n};\n\nmodule_platform_driver(regulator_led_driver);\n\nMODULE_AUTHOR(\"Antonio Ospite <ospite@studenti.unina.it>\");\nMODULE_DESCRIPTION(\"Regulator driven LED driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:leds-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}