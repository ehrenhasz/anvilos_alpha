{
  "module_name": "leds-apu.c",
  "hash_id": "15df20612f46457b7ea72dc5dfb8f59359963f8b5443b796c3548d846f2ed231",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-apu.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/dmi.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#define APU1_FCH_ACPI_MMIO_BASE 0xFED80000\n#define APU1_FCH_GPIO_BASE      (APU1_FCH_ACPI_MMIO_BASE + 0x01BD)\n#define APU1_LEDON              0x08\n#define APU1_LEDOFF             0xC8\n#define APU1_NUM_GPIO           3\n#define APU1_IOSIZE             sizeof(u8)\n\n \nstruct apu_param {\n\tvoid __iomem *addr;  \n};\n\n \nstruct apu_led_priv {\n\tstruct led_classdev cdev;\n\tstruct apu_param param;\n};\n#define cdev_to_priv(c) container_of(c, struct apu_led_priv, cdev)\n\n \nstruct apu_led_profile {\n\tconst char *name;\n\tenum led_brightness brightness;\n\tunsigned long offset;  \n};\n\nstruct apu_led_pdata {\n\tstruct platform_device *pdev;\n\tstruct apu_led_priv *pled;\n\tspinlock_t lock;\n};\n\nstatic struct apu_led_pdata *apu_led;\n\nstatic const struct apu_led_profile apu1_led_profile[] = {\n\t{ \"apu:green:1\", LED_ON,  APU1_FCH_GPIO_BASE + 0 * APU1_IOSIZE },\n\t{ \"apu:green:2\", LED_OFF, APU1_FCH_GPIO_BASE + 1 * APU1_IOSIZE },\n\t{ \"apu:green:3\", LED_OFF, APU1_FCH_GPIO_BASE + 2 * APU1_IOSIZE },\n};\n\nstatic const struct dmi_system_id apu_led_dmi_table[] __initconst = {\n\t \n\t{\n\t\t.ident = \"apu\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"PC Engines\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"APU\")\n\t\t}\n\t},\n\t \n\t{\n\t\t.ident = \"apu\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"PC Engines\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"apu1\")\n\t\t}\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(dmi, apu_led_dmi_table);\n\nstatic void apu1_led_brightness_set(struct led_classdev *led, enum led_brightness value)\n{\n\tstruct apu_led_priv *pled = cdev_to_priv(led);\n\n\tspin_lock(&apu_led->lock);\n\tiowrite8(value ? APU1_LEDON : APU1_LEDOFF, pled->param.addr);\n\tspin_unlock(&apu_led->lock);\n}\n\nstatic int apu_led_config(struct device *dev, struct apu_led_pdata *apuld)\n{\n\tint i;\n\tint err;\n\n\tapu_led->pled = devm_kcalloc(dev,\n\t\tARRAY_SIZE(apu1_led_profile), sizeof(struct apu_led_priv),\n\t\tGFP_KERNEL);\n\n\tif (!apu_led->pled)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(apu1_led_profile); i++) {\n\t\tstruct apu_led_priv *pled = &apu_led->pled[i];\n\t\tstruct led_classdev *led_cdev = &pled->cdev;\n\n\t\tled_cdev->name = apu1_led_profile[i].name;\n\t\tled_cdev->brightness = apu1_led_profile[i].brightness;\n\t\tled_cdev->max_brightness = 1;\n\t\tled_cdev->flags = LED_CORE_SUSPENDRESUME;\n\t\tled_cdev->brightness_set = apu1_led_brightness_set;\n\n\t\tpled->param.addr = devm_ioremap(dev,\n\t\t\t\tapu1_led_profile[i].offset, APU1_IOSIZE);\n\t\tif (!pled->param.addr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\terr = led_classdev_register(dev, led_cdev);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\tapu1_led_brightness_set(led_cdev, apu1_led_profile[i].brightness);\n\t}\n\n\treturn 0;\n\nerror:\n\twhile (i-- > 0)\n\t\tled_classdev_unregister(&apu_led->pled[i].cdev);\n\n\treturn err;\n}\n\nstatic int __init apu_led_probe(struct platform_device *pdev)\n{\n\tapu_led = devm_kzalloc(&pdev->dev, sizeof(*apu_led), GFP_KERNEL);\n\n\tif (!apu_led)\n\t\treturn -ENOMEM;\n\n\tapu_led->pdev = pdev;\n\n\tspin_lock_init(&apu_led->lock);\n\treturn apu_led_config(&pdev->dev, apu_led);\n}\n\nstatic struct platform_driver apu_led_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t},\n};\n\nstatic int __init apu_led_init(void)\n{\n\tstruct platform_device *pdev;\n\tint err;\n\n\tif (!(dmi_match(DMI_SYS_VENDOR, \"PC Engines\") &&\n\t      (dmi_match(DMI_PRODUCT_NAME, \"APU\") || dmi_match(DMI_PRODUCT_NAME, \"apu1\")))) {\n\t\tpr_err(\"No PC Engines APUv1 board detected. For APUv2,3 support, enable CONFIG_PCENGINES_APU2\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpdev = platform_device_register_simple(KBUILD_MODNAME, -1, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\tpr_err(\"Device allocation failed\\n\");\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\terr = platform_driver_probe(&apu_led_driver, apu_led_probe);\n\tif (err) {\n\t\tpr_err(\"Probe platform driver failed\\n\");\n\t\tplatform_device_unregister(pdev);\n\t}\n\n\treturn err;\n}\n\nstatic void __exit apu_led_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(apu1_led_profile); i++)\n\t\tled_classdev_unregister(&apu_led->pled[i].cdev);\n\n\tplatform_device_unregister(apu_led->pdev);\n\tplatform_driver_unregister(&apu_led_driver);\n}\n\nmodule_init(apu_led_init);\nmodule_exit(apu_led_exit);\n\nMODULE_AUTHOR(\"Alan Mizrahi\");\nMODULE_DESCRIPTION(\"PC Engines APU1 front LED driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:leds_apu\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}