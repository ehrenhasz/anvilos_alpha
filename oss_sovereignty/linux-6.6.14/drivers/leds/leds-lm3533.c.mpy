{
  "module_name": "leds-lm3533.c",
  "hash_id": "a1182fd8dcaab8decf8b3e3189e32978f26da1a7de10b20bfc29536bfb552153",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lm3533.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/leds.h>\n#include <linux/mfd/core.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <linux/mfd/lm3533.h>\n\n\n#define LM3533_LVCTRLBANK_MIN\t\t2\n#define LM3533_LVCTRLBANK_MAX\t\t5\n#define LM3533_LVCTRLBANK_COUNT\t\t4\n#define LM3533_RISEFALLTIME_MAX\t\t7\n#define LM3533_ALS_CHANNEL_LV_MIN\t1\n#define LM3533_ALS_CHANNEL_LV_MAX\t2\n\n#define LM3533_REG_CTRLBANK_BCONF_BASE\t\t0x1b\n#define LM3533_REG_PATTERN_ENABLE\t\t0x28\n#define LM3533_REG_PATTERN_LOW_TIME_BASE\t0x71\n#define LM3533_REG_PATTERN_HIGH_TIME_BASE\t0x72\n#define LM3533_REG_PATTERN_RISETIME_BASE\t0x74\n#define LM3533_REG_PATTERN_FALLTIME_BASE\t0x75\n\n#define LM3533_REG_PATTERN_STEP\t\t\t0x10\n\n#define LM3533_REG_CTRLBANK_BCONF_MAPPING_MASK\t\t0x04\n#define LM3533_REG_CTRLBANK_BCONF_ALS_EN_MASK\t\t0x02\n#define LM3533_REG_CTRLBANK_BCONF_ALS_CHANNEL_MASK\t0x01\n\n#define LM3533_LED_FLAG_PATTERN_ENABLE\t\t1\n\n\nstruct lm3533_led {\n\tstruct lm3533 *lm3533;\n\tstruct lm3533_ctrlbank cb;\n\tstruct led_classdev cdev;\n\tint id;\n\n\tstruct mutex mutex;\n\tunsigned long flags;\n};\n\n\nstatic inline struct lm3533_led *to_lm3533_led(struct led_classdev *cdev)\n{\n\treturn container_of(cdev, struct lm3533_led, cdev);\n}\n\nstatic inline int lm3533_led_get_ctrlbank_id(struct lm3533_led *led)\n{\n\treturn led->id + 2;\n}\n\nstatic inline u8 lm3533_led_get_lv_reg(struct lm3533_led *led, u8 base)\n{\n\treturn base + led->id;\n}\n\nstatic inline u8 lm3533_led_get_pattern(struct lm3533_led *led)\n{\n\treturn led->id;\n}\n\nstatic inline u8 lm3533_led_get_pattern_reg(struct lm3533_led *led,\n\t\t\t\t\t\t\t\tu8 base)\n{\n\treturn base + lm3533_led_get_pattern(led) * LM3533_REG_PATTERN_STEP;\n}\n\nstatic int lm3533_led_pattern_enable(struct lm3533_led *led, int enable)\n{\n\tu8 mask;\n\tu8 val;\n\tint pattern;\n\tint state;\n\tint ret = 0;\n\n\tdev_dbg(led->cdev.dev, \"%s - %d\\n\", __func__, enable);\n\n\tmutex_lock(&led->mutex);\n\n\tstate = test_bit(LM3533_LED_FLAG_PATTERN_ENABLE, &led->flags);\n\tif ((enable && state) || (!enable && !state))\n\t\tgoto out;\n\n\tpattern = lm3533_led_get_pattern(led);\n\tmask = 1 << (2 * pattern);\n\n\tif (enable)\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\tret = lm3533_update(led->lm3533, LM3533_REG_PATTERN_ENABLE, val, mask);\n\tif (ret) {\n\t\tdev_err(led->cdev.dev, \"failed to enable pattern %d (%d)\\n\",\n\t\t\t\t\t\t\tpattern, enable);\n\t\tgoto out;\n\t}\n\n\t__change_bit(LM3533_LED_FLAG_PATTERN_ENABLE, &led->flags);\nout:\n\tmutex_unlock(&led->mutex);\n\n\treturn ret;\n}\n\nstatic int lm3533_led_set(struct led_classdev *cdev,\n\t\t\t\t\t\tenum led_brightness value)\n{\n\tstruct lm3533_led *led = to_lm3533_led(cdev);\n\n\tdev_dbg(led->cdev.dev, \"%s - %d\\n\", __func__, value);\n\n\tif (value == 0)\n\t\tlm3533_led_pattern_enable(led, 0);\t \n\n\treturn lm3533_ctrlbank_set_brightness(&led->cb, value);\n}\n\nstatic enum led_brightness lm3533_led_get(struct led_classdev *cdev)\n{\n\tstruct lm3533_led *led = to_lm3533_led(cdev);\n\tu8 val;\n\tint ret;\n\n\tret = lm3533_ctrlbank_get_brightness(&led->cb, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(led->cdev.dev, \"%s - %u\\n\", __func__, val);\n\n\treturn val;\n}\n\n \n#define LM3533_LED_DELAY1_VMIN\t0x00\n#define LM3533_LED_DELAY2_VMIN\t0x3d\n#define LM3533_LED_DELAY3_VMIN\t0x80\n\n#define LM3533_LED_DELAY1_VMAX\t(LM3533_LED_DELAY2_VMIN - 1)\n#define LM3533_LED_DELAY2_VMAX\t(LM3533_LED_DELAY3_VMIN - 1)\n#define LM3533_LED_DELAY3_VMAX\t0xff\n\n#define LM3533_LED_DELAY1_TMIN\t16384U\n#define LM3533_LED_DELAY2_TMIN\t1130496U\n#define LM3533_LED_DELAY3_TMIN\t10305536U\n\n#define LM3533_LED_DELAY1_TMAX\t999424U\n#define LM3533_LED_DELAY2_TMAX\t9781248U\n#define LM3533_LED_DELAY3_TMAX\t76890112U\n\n \n#define LM3533_LED_DELAY1_TSTEP\t16384\n#define LM3533_LED_DELAY2_TSTEP\t131072\n#define LM3533_LED_DELAY3_TSTEP\t524288\n\n \n#define LM3533_LED_DELAY_ON_MAX \\\n\t((LM3533_LED_DELAY2_TMAX + LM3533_LED_DELAY2_TSTEP / 2) / 1000)\n#define LM3533_LED_DELAY_OFF_MAX \\\n\t((LM3533_LED_DELAY3_TMAX + LM3533_LED_DELAY3_TSTEP / 2) / 1000)\n\n \nstatic u8 time_to_val(unsigned *t, unsigned t_min, unsigned t_step,\n\t\t\t\t\t\t\tu8 v_min, u8 v_max)\n{\n\tunsigned val;\n\n\tval = (*t + t_step / 2 - t_min) / t_step + v_min;\n\n\t*t = t_step * (val - v_min) + t_min;\n\n\treturn (u8)val;\n}\n\n \nstatic u8 lm3533_led_get_hw_delay(unsigned *delay)\n{\n\tunsigned t;\n\tu8 val;\n\n\tt = *delay * 1000;\n\n\tif (t >= (LM3533_LED_DELAY2_TMAX + LM3533_LED_DELAY3_TMIN) / 2) {\n\t\tt = clamp(t, LM3533_LED_DELAY3_TMIN, LM3533_LED_DELAY3_TMAX);\n\t\tval = time_to_val(&t,\tLM3533_LED_DELAY3_TMIN,\n\t\t\t\t\tLM3533_LED_DELAY3_TSTEP,\n\t\t\t\t\tLM3533_LED_DELAY3_VMIN,\n\t\t\t\t\tLM3533_LED_DELAY3_VMAX);\n\t} else if (t >= (LM3533_LED_DELAY1_TMAX + LM3533_LED_DELAY2_TMIN) / 2) {\n\t\tt = clamp(t, LM3533_LED_DELAY2_TMIN, LM3533_LED_DELAY2_TMAX);\n\t\tval = time_to_val(&t,\tLM3533_LED_DELAY2_TMIN,\n\t\t\t\t\tLM3533_LED_DELAY2_TSTEP,\n\t\t\t\t\tLM3533_LED_DELAY2_VMIN,\n\t\t\t\t\tLM3533_LED_DELAY2_VMAX);\n\t} else {\n\t\tt = clamp(t, LM3533_LED_DELAY1_TMIN, LM3533_LED_DELAY1_TMAX);\n\t\tval = time_to_val(&t,\tLM3533_LED_DELAY1_TMIN,\n\t\t\t\t\tLM3533_LED_DELAY1_TSTEP,\n\t\t\t\t\tLM3533_LED_DELAY1_VMIN,\n\t\t\t\t\tLM3533_LED_DELAY1_VMAX);\n\t}\n\n\t*delay = (t + 500) / 1000;\n\n\treturn val;\n}\n\n \nstatic u8 lm3533_led_delay_set(struct lm3533_led *led, u8 base,\n\t\t\t\t\t\t\tunsigned long *delay)\n{\n\tunsigned t;\n\tu8 val;\n\tu8 reg;\n\tint ret;\n\n\tt = (unsigned)*delay;\n\n\t \n\tif (base != LM3533_REG_PATTERN_LOW_TIME_BASE)\n\t\tt = min(t, LM3533_LED_DELAY2_TMAX / 1000);\n\n\tval = lm3533_led_get_hw_delay(&t);\n\n\tdev_dbg(led->cdev.dev, \"%s - %lu: %u (0x%02x)\\n\", __func__,\n\t\t\t\t\t\t\t*delay, t, val);\n\treg = lm3533_led_get_pattern_reg(led, base);\n\tret = lm3533_write(led->lm3533, reg, val);\n\tif (ret)\n\t\tdev_err(led->cdev.dev, \"failed to set delay (%02x)\\n\", reg);\n\n\t*delay = t;\n\n\treturn ret;\n}\n\nstatic int lm3533_led_delay_on_set(struct lm3533_led *led, unsigned long *t)\n{\n\treturn lm3533_led_delay_set(led, LM3533_REG_PATTERN_HIGH_TIME_BASE, t);\n}\n\nstatic int lm3533_led_delay_off_set(struct lm3533_led *led, unsigned long *t)\n{\n\treturn lm3533_led_delay_set(led, LM3533_REG_PATTERN_LOW_TIME_BASE, t);\n}\n\nstatic int lm3533_led_blink_set(struct led_classdev *cdev,\n\t\t\t\tunsigned long *delay_on,\n\t\t\t\tunsigned long *delay_off)\n{\n\tstruct lm3533_led *led = to_lm3533_led(cdev);\n\tint ret;\n\n\tdev_dbg(led->cdev.dev, \"%s - on = %lu, off = %lu\\n\", __func__,\n\t\t\t\t\t\t\t*delay_on, *delay_off);\n\n\tif (*delay_on > LM3533_LED_DELAY_ON_MAX ||\n\t\t\t\t\t*delay_off > LM3533_LED_DELAY_OFF_MAX)\n\t\treturn -EINVAL;\n\n\tif (*delay_on == 0 && *delay_off == 0) {\n\t\t*delay_on = 500;\n\t\t*delay_off = 500;\n\t}\n\n\tret = lm3533_led_delay_on_set(led, delay_on);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lm3533_led_delay_off_set(led, delay_off);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lm3533_led_pattern_enable(led, 1);\n}\n\nstatic ssize_t show_id(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", led->id);\n}\n\n \nstatic ssize_t show_risefalltime(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf, u8 base)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tssize_t ret;\n\tu8 reg;\n\tu8 val;\n\n\treg = lm3533_led_get_pattern_reg(led, base);\n\tret = lm3533_read(led->lm3533, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%x\\n\", val);\n}\n\nstatic ssize_t show_risetime(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn show_risefalltime(dev, attr, buf,\n\t\t\t\t\tLM3533_REG_PATTERN_RISETIME_BASE);\n}\n\nstatic ssize_t show_falltime(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn show_risefalltime(dev, attr, buf,\n\t\t\t\t\tLM3533_REG_PATTERN_FALLTIME_BASE);\n}\n\nstatic ssize_t store_risefalltime(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len, u8 base)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tu8 val;\n\tu8 reg;\n\tint ret;\n\n\tif (kstrtou8(buf, 0, &val) || val > LM3533_RISEFALLTIME_MAX)\n\t\treturn -EINVAL;\n\n\treg = lm3533_led_get_pattern_reg(led, base);\n\tret = lm3533_write(led->lm3533, reg, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t store_risetime(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\treturn store_risefalltime(dev, attr, buf, len,\n\t\t\t\t\tLM3533_REG_PATTERN_RISETIME_BASE);\n}\n\nstatic ssize_t store_falltime(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\treturn store_risefalltime(dev, attr, buf, len,\n\t\t\t\t\tLM3533_REG_PATTERN_FALLTIME_BASE);\n}\n\nstatic ssize_t show_als_channel(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tunsigned channel;\n\tu8 reg;\n\tu8 val;\n\tint ret;\n\n\treg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\n\tret = lm3533_read(led->lm3533, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tchannel = (val & LM3533_REG_CTRLBANK_BCONF_ALS_CHANNEL_MASK) + 1;\n\n\treturn sysfs_emit(buf, \"%u\\n\", channel);\n}\n\nstatic ssize_t store_als_channel(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tunsigned channel;\n\tu8 reg;\n\tu8 val;\n\tu8 mask;\n\tint ret;\n\n\tif (kstrtouint(buf, 0, &channel))\n\t\treturn -EINVAL;\n\n\tif (channel < LM3533_ALS_CHANNEL_LV_MIN ||\n\t\t\t\t\tchannel > LM3533_ALS_CHANNEL_LV_MAX)\n\t\treturn -EINVAL;\n\n\treg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\n\tmask = LM3533_REG_CTRLBANK_BCONF_ALS_CHANNEL_MASK;\n\tval = channel - 1;\n\n\tret = lm3533_update(led->lm3533, reg, val, mask);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t show_als_en(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tbool enable;\n\tu8 reg;\n\tu8 val;\n\tint ret;\n\n\treg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\n\tret = lm3533_read(led->lm3533, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tenable = val & LM3533_REG_CTRLBANK_BCONF_ALS_EN_MASK;\n\n\treturn sysfs_emit(buf, \"%d\\n\", enable);\n}\n\nstatic ssize_t store_als_en(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tunsigned enable;\n\tu8 reg;\n\tu8 mask;\n\tu8 val;\n\tint ret;\n\n\tif (kstrtouint(buf, 0, &enable))\n\t\treturn -EINVAL;\n\n\treg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\n\tmask = LM3533_REG_CTRLBANK_BCONF_ALS_EN_MASK;\n\n\tif (enable)\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\tret = lm3533_update(led->lm3533, reg, val, mask);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t show_linear(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tu8 reg;\n\tu8 val;\n\tint linear;\n\tint ret;\n\n\treg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\n\tret = lm3533_read(led->lm3533, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & LM3533_REG_CTRLBANK_BCONF_MAPPING_MASK)\n\t\tlinear = 1;\n\telse\n\t\tlinear = 0;\n\n\treturn sysfs_emit(buf, \"%x\\n\", linear);\n}\n\nstatic ssize_t store_linear(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tunsigned long linear;\n\tu8 reg;\n\tu8 mask;\n\tu8 val;\n\tint ret;\n\n\tif (kstrtoul(buf, 0, &linear))\n\t\treturn -EINVAL;\n\n\treg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\n\tmask = LM3533_REG_CTRLBANK_BCONF_MAPPING_MASK;\n\n\tif (linear)\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\tret = lm3533_update(led->lm3533, reg, val, mask);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t show_pwm(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tu8 val;\n\tint ret;\n\n\tret = lm3533_ctrlbank_get_pwm(&led->cb, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t store_pwm(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tu8 val;\n\tint ret;\n\n\tif (kstrtou8(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tret = lm3533_ctrlbank_set_pwm(&led->cb, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic LM3533_ATTR_RW(als_channel);\nstatic LM3533_ATTR_RW(als_en);\nstatic LM3533_ATTR_RW(falltime);\nstatic LM3533_ATTR_RO(id);\nstatic LM3533_ATTR_RW(linear);\nstatic LM3533_ATTR_RW(pwm);\nstatic LM3533_ATTR_RW(risetime);\n\nstatic struct attribute *lm3533_led_attributes[] = {\n\t&dev_attr_als_channel.attr,\n\t&dev_attr_als_en.attr,\n\t&dev_attr_falltime.attr,\n\t&dev_attr_id.attr,\n\t&dev_attr_linear.attr,\n\t&dev_attr_pwm.attr,\n\t&dev_attr_risetime.attr,\n\tNULL,\n};\n\nstatic umode_t lm3533_led_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3533_led *led = to_lm3533_led(led_cdev);\n\tumode_t mode = attr->mode;\n\n\tif (attr == &dev_attr_als_channel.attr ||\n\t\t\t\t\tattr == &dev_attr_als_en.attr) {\n\t\tif (!led->lm3533->have_als)\n\t\t\tmode = 0;\n\t}\n\n\treturn mode;\n};\n\nstatic const struct attribute_group lm3533_led_attribute_group = {\n\t.is_visible\t= lm3533_led_attr_is_visible,\n\t.attrs\t\t= lm3533_led_attributes\n};\n\nstatic const struct attribute_group *lm3533_led_attribute_groups[] = {\n\t&lm3533_led_attribute_group,\n\tNULL\n};\n\nstatic int lm3533_led_setup(struct lm3533_led *led,\n\t\t\t\t\tstruct lm3533_led_platform_data *pdata)\n{\n\tint ret;\n\n\tret = lm3533_ctrlbank_set_max_current(&led->cb, pdata->max_current);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lm3533_ctrlbank_set_pwm(&led->cb, pdata->pwm);\n}\n\nstatic int lm3533_led_probe(struct platform_device *pdev)\n{\n\tstruct lm3533 *lm3533;\n\tstruct lm3533_led_platform_data *pdata;\n\tstruct lm3533_led *led;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\tlm3533 = dev_get_drvdata(pdev->dev.parent);\n\tif (!lm3533)\n\t\treturn -EINVAL;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdev->id < 0 || pdev->id >= LM3533_LVCTRLBANK_COUNT) {\n\t\tdev_err(&pdev->dev, \"illegal LED id %d\\n\", pdev->id);\n\t\treturn -EINVAL;\n\t}\n\n\tled = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tled->lm3533 = lm3533;\n\tled->cdev.name = pdata->name;\n\tled->cdev.default_trigger = pdata->default_trigger;\n\tled->cdev.brightness_set_blocking = lm3533_led_set;\n\tled->cdev.brightness_get = lm3533_led_get;\n\tled->cdev.blink_set = lm3533_led_blink_set;\n\tled->cdev.brightness = LED_OFF;\n\tled->cdev.groups = lm3533_led_attribute_groups;\n\tled->id = pdev->id;\n\n\tmutex_init(&led->mutex);\n\n\t \n\tled->cb.lm3533 = lm3533;\n\tled->cb.id = lm3533_led_get_ctrlbank_id(led);\n\tled->cb.dev = lm3533->dev;\n\n\tplatform_set_drvdata(pdev, led);\n\n\tret = led_classdev_register(pdev->dev.parent, &led->cdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register LED %d\\n\", pdev->id);\n\t\treturn ret;\n\t}\n\n\tled->cb.dev = led->cdev.dev;\n\n\tret = lm3533_led_setup(led, pdata);\n\tif (ret)\n\t\tgoto err_deregister;\n\n\tret = lm3533_ctrlbank_enable(&led->cb);\n\tif (ret)\n\t\tgoto err_deregister;\n\n\treturn 0;\n\nerr_deregister:\n\tled_classdev_unregister(&led->cdev);\n\n\treturn ret;\n}\n\nstatic int lm3533_led_remove(struct platform_device *pdev)\n{\n\tstruct lm3533_led *led = platform_get_drvdata(pdev);\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\tlm3533_ctrlbank_disable(&led->cb);\n\tled_classdev_unregister(&led->cdev);\n\n\treturn 0;\n}\n\nstatic void lm3533_led_shutdown(struct platform_device *pdev)\n{\n\n\tstruct lm3533_led *led = platform_get_drvdata(pdev);\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\tlm3533_ctrlbank_disable(&led->cb);\n\tlm3533_led_set(&led->cdev, LED_OFF);\t\t \n}\n\nstatic struct platform_driver lm3533_led_driver = {\n\t.driver = {\n\t\t.name = \"lm3533-leds\",\n\t},\n\t.probe\t\t= lm3533_led_probe,\n\t.remove\t\t= lm3533_led_remove,\n\t.shutdown\t= lm3533_led_shutdown,\n};\nmodule_platform_driver(lm3533_led_driver);\n\nMODULE_AUTHOR(\"Johan Hovold <jhovold@gmail.com>\");\nMODULE_DESCRIPTION(\"LM3533 LED driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:lm3533-leds\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}