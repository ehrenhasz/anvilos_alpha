{
  "module_name": "leds-cpcap.c",
  "hash_id": "9590fbde657c7ab5fe25cfe97d6477c435b15edd8a0485f119ab06189298605a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-cpcap.c",
  "human_readable_source": "\n \n\n#include <linux/leds.h>\n#include <linux/mfd/motorola-cpcap.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#define CPCAP_LED_NO_CURRENT 0x0001\n\nstruct cpcap_led_info {\n\tu16 reg;\n\tu16 mask;\n\tu16 limit;\n\tu16 init_mask;\n\tu16 init_val;\n};\n\nstatic const struct cpcap_led_info cpcap_led_red = {\n\t.reg\t= CPCAP_REG_REDC,\n\t.mask\t= 0x03FF,\n\t.limit\t= 31,\n};\n\nstatic const struct cpcap_led_info cpcap_led_green = {\n\t.reg\t= CPCAP_REG_GREENC,\n\t.mask\t= 0x03FF,\n\t.limit\t= 31,\n};\n\nstatic const struct cpcap_led_info cpcap_led_blue = {\n\t.reg\t= CPCAP_REG_BLUEC,\n\t.mask\t= 0x03FF,\n\t.limit\t= 31,\n};\n\n \nstatic const struct cpcap_led_info cpcap_led_adl = {\n\t.reg\t\t= CPCAP_REG_ADLC,\n\t.mask\t\t= 0x000F,\n\t.limit\t\t= 1,\n\t.init_mask\t= 0x7FFF,\n\t.init_val\t= 0x5FF0,\n};\n\n \nstatic const struct cpcap_led_info cpcap_led_cp = {\n\t.reg\t\t= CPCAP_REG_CLEDC,\n\t.mask\t\t= 0x0007,\n\t.limit\t\t= 1,\n\t.init_mask\t= 0x03FF,\n\t.init_val\t= 0x0008,\n};\n\nstruct cpcap_led {\n\tstruct led_classdev led;\n\tconst struct cpcap_led_info *info;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct mutex update_lock;\n\tstruct regulator *vdd;\n\tbool powered;\n\n\tu32 current_limit;\n};\n\nstatic u16 cpcap_led_val(u8 current_limit, u8 duty_cycle)\n{\n\tcurrent_limit &= 0x1f;  \n\tduty_cycle &= 0x0f;  \n\n\treturn current_limit << 4 | duty_cycle;\n}\n\nstatic int cpcap_led_set_power(struct cpcap_led *led, bool status)\n{\n\tint err;\n\n\tif (status == led->powered)\n\t\treturn 0;\n\n\tif (status)\n\t\terr = regulator_enable(led->vdd);\n\telse\n\t\terr = regulator_disable(led->vdd);\n\n\tif (err) {\n\t\tdev_err(led->dev, \"regulator failure: %d\", err);\n\t\treturn err;\n\t}\n\n\tled->powered = status;\n\n\treturn 0;\n}\n\nstatic int cpcap_led_set(struct led_classdev *ledc, enum led_brightness value)\n{\n\tstruct cpcap_led *led = container_of(ledc, struct cpcap_led, led);\n\tint brightness;\n\tint err;\n\n\tmutex_lock(&led->update_lock);\n\n\tif (value > LED_OFF) {\n\t\terr = cpcap_led_set_power(led, true);\n\t\tif (err)\n\t\t\tgoto exit;\n\t}\n\n\tif (value == LED_OFF) {\n\t\t \n\t\terr = regmap_update_bits(led->regmap,\n\t\t\tled->info->reg, led->info->mask, CPCAP_LED_NO_CURRENT);\n\t\tif (err) {\n\t\t\tdev_err(led->dev, \"regmap failed: %d\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbrightness = cpcap_led_val(value, LED_OFF);\n\t} else {\n\t\tbrightness = cpcap_led_val(value, LED_ON);\n\t}\n\n\terr = regmap_update_bits(led->regmap, led->info->reg, led->info->mask,\n\t\tbrightness);\n\tif (err) {\n\t\tdev_err(led->dev, \"regmap failed: %d\", err);\n\t\tgoto exit;\n\t}\n\n\tif (value == LED_OFF) {\n\t\terr = cpcap_led_set_power(led, false);\n\t\tif (err)\n\t\t\tgoto exit;\n\t}\n\nexit:\n\tmutex_unlock(&led->update_lock);\n\treturn err;\n}\n\nstatic const struct of_device_id cpcap_led_of_match[] = {\n\t{ .compatible = \"motorola,cpcap-led-red\", .data = &cpcap_led_red },\n\t{ .compatible = \"motorola,cpcap-led-green\", .data = &cpcap_led_green },\n\t{ .compatible = \"motorola,cpcap-led-blue\",  .data = &cpcap_led_blue },\n\t{ .compatible = \"motorola,cpcap-led-adl\", .data = &cpcap_led_adl },\n\t{ .compatible = \"motorola,cpcap-led-cp\", .data = &cpcap_led_cp },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cpcap_led_of_match);\n\nstatic int cpcap_led_probe(struct platform_device *pdev)\n{\n\tstruct cpcap_led *led;\n\tint err;\n\n\tled = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, led);\n\tled->info = device_get_match_data(&pdev->dev);\n\tled->dev = &pdev->dev;\n\n\tif (led->info->reg == 0x0000) {\n\t\tdev_err(led->dev, \"Unsupported LED\");\n\t\treturn -ENODEV;\n\t}\n\n\tled->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!led->regmap)\n\t\treturn -ENODEV;\n\n\tled->vdd = devm_regulator_get(&pdev->dev, \"vdd\");\n\tif (IS_ERR(led->vdd)) {\n\t\terr = PTR_ERR(led->vdd);\n\t\tdev_err(led->dev, \"Couldn't get regulator: %d\", err);\n\t\treturn err;\n\t}\n\n\terr = device_property_read_string(&pdev->dev, \"label\", &led->led.name);\n\tif (err) {\n\t\tdev_err(led->dev, \"Couldn't read LED label: %d\", err);\n\t\treturn err;\n\t}\n\n\tif (led->info->init_mask) {\n\t\terr = regmap_update_bits(led->regmap, led->info->reg,\n\t\t\tled->info->init_mask, led->info->init_val);\n\t\tif (err) {\n\t\t\tdev_err(led->dev, \"regmap failed: %d\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tmutex_init(&led->update_lock);\n\n\tled->led.max_brightness = led->info->limit;\n\tled->led.brightness_set_blocking = cpcap_led_set;\n\terr = devm_led_classdev_register(&pdev->dev, &led->led);\n\tif (err) {\n\t\tdev_err(led->dev, \"Couldn't register LED: %d\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver cpcap_led_driver = {\n\t.probe = cpcap_led_probe,\n\t.driver = {\n\t\t.name = \"cpcap-led\",\n\t\t.of_match_table = cpcap_led_of_match,\n\t},\n};\nmodule_platform_driver(cpcap_led_driver);\n\nMODULE_DESCRIPTION(\"CPCAP LED driver\");\nMODULE_AUTHOR(\"Sebastian Reichel <sre@kernel.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}