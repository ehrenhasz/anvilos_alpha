{
  "module_name": "leds-bcm6328.c",
  "hash_id": "496188a9254d07e1679e4833c55c531427eed73833e1f7d1d199cafe8116a615",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-bcm6328.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#define BCM6328_REG_INIT\t\t0x00\n#define BCM6328_REG_MODE_HI\t\t0x04\n#define BCM6328_REG_MODE_LO\t\t0x08\n#define BCM6328_REG_HWDIS\t\t0x0c\n#define BCM6328_REG_STROBE\t\t0x10\n#define BCM6328_REG_LNKACTSEL_HI\t0x14\n#define BCM6328_REG_LNKACTSEL_LO\t0x18\n#define BCM6328_REG_RBACK\t\t0x1c\n#define BCM6328_REG_SERMUX\t\t0x20\n\n#define BCM6328_LED_MAX_COUNT\t\t24\n#define BCM6328_LED_DEF_DELAY\t\t500\n\n#define BCM6328_LED_BLINK_DELAYS\t2\n#define BCM6328_LED_BLINK_MS\t\t20\n\n#define BCM6328_LED_BLINK_MASK\t\t0x3f\n#define BCM6328_LED_BLINK1_SHIFT\t0\n#define BCM6328_LED_BLINK1_MASK\t\t(BCM6328_LED_BLINK_MASK << \\\n\t\t\t\t\t BCM6328_LED_BLINK1_SHIFT)\n#define BCM6328_LED_BLINK2_SHIFT\t6\n#define BCM6328_LED_BLINK2_MASK\t\t(BCM6328_LED_BLINK_MASK << \\\n\t\t\t\t\t BCM6328_LED_BLINK2_SHIFT)\n#define BCM6328_SERIAL_LED_EN\t\tBIT(12)\n#define BCM6328_SERIAL_LED_MUX\t\tBIT(13)\n#define BCM6328_SERIAL_LED_CLK_NPOL\tBIT(14)\n#define BCM6328_SERIAL_LED_DATA_PPOL\tBIT(15)\n#define BCM6328_SERIAL_LED_SHIFT_DIR\tBIT(16)\n#define BCM6328_LED_SHIFT_TEST\t\tBIT(30)\n#define BCM6328_LED_TEST\t\tBIT(31)\n#define BCM6328_INIT_MASK\t\t(BCM6328_SERIAL_LED_EN | \\\n\t\t\t\t\t BCM6328_SERIAL_LED_MUX | \\\n\t\t\t\t\t BCM6328_SERIAL_LED_CLK_NPOL | \\\n\t\t\t\t\t BCM6328_SERIAL_LED_DATA_PPOL | \\\n\t\t\t\t\t BCM6328_SERIAL_LED_SHIFT_DIR)\n\n#define BCM6328_LED_MODE_MASK\t\t3\n#define BCM6328_LED_MODE_ON\t\t0\n#define BCM6328_LED_MODE_BLINK1\t\t1\n#define BCM6328_LED_MODE_BLINK2\t\t2\n#define BCM6328_LED_MODE_OFF\t\t3\n#define BCM6328_LED_SHIFT(X)\t\t((X) << 1)\n\n \nstruct bcm6328_led {\n\tstruct led_classdev cdev;\n\tvoid __iomem *mem;\n\tspinlock_t *lock;\n\tunsigned long pin;\n\tunsigned long *blink_leds;\n\tunsigned long *blink_delay;\n\tbool active_low;\n};\n\nstatic void bcm6328_led_write(void __iomem *reg, unsigned long data)\n{\n#ifdef CONFIG_CPU_BIG_ENDIAN\n\tiowrite32be(data, reg);\n#else\n\twritel(data, reg);\n#endif\n}\n\nstatic unsigned long bcm6328_led_read(void __iomem *reg)\n{\n#ifdef CONFIG_CPU_BIG_ENDIAN\n\treturn ioread32be(reg);\n#else\n\treturn readl(reg);\n#endif\n}\n\n \nstatic unsigned long bcm6328_pin2shift(unsigned long pin)\n{\n\tif (pin < 8)\n\t\treturn pin + 16;  \n\telse\n\t\treturn pin - 8;  \n}\n\nstatic void bcm6328_led_mode(struct bcm6328_led *led, unsigned long value)\n{\n\tvoid __iomem *mode;\n\tunsigned long val, shift;\n\n\tshift = bcm6328_pin2shift(led->pin);\n\tif (shift / 16)\n\t\tmode = led->mem + BCM6328_REG_MODE_HI;\n\telse\n\t\tmode = led->mem + BCM6328_REG_MODE_LO;\n\n\tval = bcm6328_led_read(mode);\n\tval &= ~(BCM6328_LED_MODE_MASK << BCM6328_LED_SHIFT(shift % 16));\n\tval |= (value << BCM6328_LED_SHIFT(shift % 16));\n\tbcm6328_led_write(mode, val);\n}\n\nstatic void bcm6328_led_set(struct led_classdev *led_cdev,\n\t\t\t    enum led_brightness value)\n{\n\tstruct bcm6328_led *led =\n\t\tcontainer_of(led_cdev, struct bcm6328_led, cdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(led->lock, flags);\n\n\t \n\tled->blink_leds[0] &= ~BIT(led->pin);\n\tled->blink_leds[1] &= ~BIT(led->pin);\n\n\t \n\tif ((led->active_low && value == LED_OFF) ||\n\t    (!led->active_low && value != LED_OFF))\n\t\tbcm6328_led_mode(led, BCM6328_LED_MODE_ON);\n\telse\n\t\tbcm6328_led_mode(led, BCM6328_LED_MODE_OFF);\n\n\tspin_unlock_irqrestore(led->lock, flags);\n}\n\nstatic unsigned long bcm6328_blink_delay(unsigned long delay)\n{\n\tunsigned long bcm6328_delay;\n\n\tbcm6328_delay = delay + BCM6328_LED_BLINK_MS / 2;\n\tbcm6328_delay = bcm6328_delay / BCM6328_LED_BLINK_MS;\n\tif (bcm6328_delay == 0)\n\t\tbcm6328_delay = 1;\n\n\treturn bcm6328_delay;\n}\n\nstatic int bcm6328_blink_set(struct led_classdev *led_cdev,\n\t\t\t     unsigned long *delay_on, unsigned long *delay_off)\n{\n\tstruct bcm6328_led *led =\n\t\tcontainer_of(led_cdev, struct bcm6328_led, cdev);\n\tunsigned long delay, flags;\n\tint rc;\n\n\tif (!*delay_on)\n\t\t*delay_on = BCM6328_LED_DEF_DELAY;\n\tif (!*delay_off)\n\t\t*delay_off = BCM6328_LED_DEF_DELAY;\n\n\tdelay = bcm6328_blink_delay(*delay_on);\n\tif (delay != bcm6328_blink_delay(*delay_off)) {\n\t\tdev_dbg(led_cdev->dev,\n\t\t\t\"fallback to soft blinking (delay_on != delay_off)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (delay > BCM6328_LED_BLINK_MASK) {\n\t\tdev_dbg(led_cdev->dev,\n\t\t\t\"fallback to soft blinking (delay > %ums)\\n\",\n\t\t\tBCM6328_LED_BLINK_MASK * BCM6328_LED_BLINK_MS);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(led->lock, flags);\n\t \n\tif (led->blink_leds[0] == 0 ||\n\t    led->blink_leds[0] == BIT(led->pin) ||\n\t    led->blink_delay[0] == delay) {\n\t\tunsigned long val;\n\n\t\t \n\t\tled->blink_leds[0] |= BIT(led->pin);\n\n\t\t \n\t\tled->blink_leds[1] &= ~BIT(led->pin);\n\n\t\t \n\t\tled->blink_delay[0] = delay;\n\n\t\t \n\t\tval = bcm6328_led_read(led->mem + BCM6328_REG_INIT);\n\t\tval &= ~BCM6328_LED_BLINK1_MASK;\n\t\tval |= (delay << BCM6328_LED_BLINK1_SHIFT);\n\t\tbcm6328_led_write(led->mem + BCM6328_REG_INIT, val);\n\n\t\t \n\t\tbcm6328_led_mode(led, BCM6328_LED_MODE_BLINK1);\n\n\t\trc = 0;\n\t} else if (led->blink_leds[1] == 0 ||\n\t\t   led->blink_leds[1] == BIT(led->pin) ||\n\t\t   led->blink_delay[1] == delay) {\n\t\tunsigned long val;\n\n\t\t \n\t\tled->blink_leds[0] &= ~BIT(led->pin);\n\n\t\t \n\t\tled->blink_leds[1] |= BIT(led->pin);\n\n\t\t \n\t\tled->blink_delay[1] = delay;\n\n\t\t \n\t\tval = bcm6328_led_read(led->mem + BCM6328_REG_INIT);\n\t\tval &= ~BCM6328_LED_BLINK2_MASK;\n\t\tval |= (delay << BCM6328_LED_BLINK2_SHIFT);\n\t\tbcm6328_led_write(led->mem + BCM6328_REG_INIT, val);\n\n\t\t \n\t\tbcm6328_led_mode(led, BCM6328_LED_MODE_BLINK2);\n\n\t\trc = 0;\n\t} else {\n\t\tdev_dbg(led_cdev->dev,\n\t\t\t\"fallback to soft blinking (delay already set)\\n\");\n\t\trc = -EINVAL;\n\t}\n\tspin_unlock_irqrestore(led->lock, flags);\n\n\treturn rc;\n}\n\nstatic int bcm6328_hwled(struct device *dev, struct device_node *nc, u32 reg,\n\t\t\t void __iomem *mem, spinlock_t *lock)\n{\n\tint i, cnt;\n\tunsigned long flags, val;\n\n\tspin_lock_irqsave(lock, flags);\n\tval = bcm6328_led_read(mem + BCM6328_REG_HWDIS);\n\tval &= ~BIT(reg);\n\tbcm6328_led_write(mem + BCM6328_REG_HWDIS, val);\n\tspin_unlock_irqrestore(lock, flags);\n\n\t \n\tif (reg >= 8)\n\t\treturn 0;\n\n\tcnt = of_property_count_elems_of_size(nc, \"brcm,link-signal-sources\",\n\t\t\t\t\t      sizeof(u32));\n\tfor (i = 0; i < cnt; i++) {\n\t\tu32 sel;\n\t\tvoid __iomem *addr;\n\n\t\tif (reg < 4)\n\t\t\taddr = mem + BCM6328_REG_LNKACTSEL_LO;\n\t\telse\n\t\t\taddr = mem + BCM6328_REG_LNKACTSEL_HI;\n\n\t\tof_property_read_u32_index(nc, \"brcm,link-signal-sources\", i,\n\t\t\t\t\t   &sel);\n\n\t\tif (reg / 4 != sel / 4) {\n\t\t\tdev_warn(dev, \"invalid link signal source\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_lock_irqsave(lock, flags);\n\t\tval = bcm6328_led_read(addr);\n\t\tval |= (BIT(reg % 4) << (((sel % 4) * 4) + 16));\n\t\tbcm6328_led_write(addr, val);\n\t\tspin_unlock_irqrestore(lock, flags);\n\t}\n\n\tcnt = of_property_count_elems_of_size(nc,\n\t\t\t\t\t      \"brcm,activity-signal-sources\",\n\t\t\t\t\t      sizeof(u32));\n\tfor (i = 0; i < cnt; i++) {\n\t\tu32 sel;\n\t\tvoid __iomem *addr;\n\n\t\tif (reg < 4)\n\t\t\taddr = mem + BCM6328_REG_LNKACTSEL_LO;\n\t\telse\n\t\t\taddr = mem + BCM6328_REG_LNKACTSEL_HI;\n\n\t\tof_property_read_u32_index(nc, \"brcm,activity-signal-sources\",\n\t\t\t\t\t   i, &sel);\n\n\t\tif (reg / 4 != sel / 4) {\n\t\t\tdev_warn(dev, \"invalid activity signal source\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_lock_irqsave(lock, flags);\n\t\tval = bcm6328_led_read(addr);\n\t\tval |= (BIT(reg % 4) << ((sel % 4) * 4));\n\t\tbcm6328_led_write(addr, val);\n\t\tspin_unlock_irqrestore(lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm6328_led(struct device *dev, struct device_node *nc, u32 reg,\n\t\t       void __iomem *mem, spinlock_t *lock,\n\t\t       unsigned long *blink_leds, unsigned long *blink_delay)\n{\n\tstruct led_init_data init_data = {};\n\tstruct bcm6328_led *led;\n\tenum led_default_state state;\n\tunsigned long val, shift;\n\tvoid __iomem *mode;\n\tint rc;\n\n\tled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tled->pin = reg;\n\tled->mem = mem;\n\tled->lock = lock;\n\tled->blink_leds = blink_leds;\n\tled->blink_delay = blink_delay;\n\n\tif (of_property_read_bool(nc, \"active-low\"))\n\t\tled->active_low = true;\n\n\tinit_data.fwnode = of_fwnode_handle(nc);\n\n\tstate = led_init_default_state_get(init_data.fwnode);\n\tswitch (state) {\n\tcase LEDS_DEFSTATE_ON:\n\t\tled->cdev.brightness = LED_FULL;\n\t\tbreak;\n\tcase LEDS_DEFSTATE_KEEP:\n\t\tshift = bcm6328_pin2shift(led->pin);\n\t\tif (shift / 16)\n\t\t\tmode = mem + BCM6328_REG_MODE_HI;\n\t\telse\n\t\t\tmode = mem + BCM6328_REG_MODE_LO;\n\n\t\tval = bcm6328_led_read(mode) >> BCM6328_LED_SHIFT(shift % 16);\n\t\tval &= BCM6328_LED_MODE_MASK;\n\t\tif ((led->active_low && val == BCM6328_LED_MODE_OFF) ||\n\t\t    (!led->active_low && val == BCM6328_LED_MODE_ON))\n\t\t\tled->cdev.brightness = LED_FULL;\n\t\telse\n\t\t\tled->cdev.brightness = LED_OFF;\n\t\tbreak;\n\tdefault:\n\t\tled->cdev.brightness = LED_OFF;\n\t}\n\n\tbcm6328_led_set(&led->cdev, led->cdev.brightness);\n\n\tled->cdev.brightness_set = bcm6328_led_set;\n\tled->cdev.blink_set = bcm6328_blink_set;\n\n\trc = devm_led_classdev_register_ext(dev, &led->cdev, &init_data);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tdev_dbg(dev, \"registered LED %s\\n\", led->cdev.name);\n\n\treturn 0;\n}\n\nstatic int bcm6328_leds_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev_of_node(&pdev->dev);\n\tstruct device_node *child;\n\tvoid __iomem *mem;\n\tspinlock_t *lock;  \n\tunsigned long val, *blink_leds, *blink_delay;\n\n\tmem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem);\n\n\tlock = devm_kzalloc(dev, sizeof(*lock), GFP_KERNEL);\n\tif (!lock)\n\t\treturn -ENOMEM;\n\n\tblink_leds = devm_kcalloc(dev, BCM6328_LED_BLINK_DELAYS,\n\t\t\t\t  sizeof(*blink_leds), GFP_KERNEL);\n\tif (!blink_leds)\n\t\treturn -ENOMEM;\n\n\tblink_delay = devm_kcalloc(dev, BCM6328_LED_BLINK_DELAYS,\n\t\t\t\t   sizeof(*blink_delay), GFP_KERNEL);\n\tif (!blink_delay)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(lock);\n\n\tbcm6328_led_write(mem + BCM6328_REG_HWDIS, ~0);\n\tbcm6328_led_write(mem + BCM6328_REG_LNKACTSEL_HI, 0);\n\tbcm6328_led_write(mem + BCM6328_REG_LNKACTSEL_LO, 0);\n\n\tval = bcm6328_led_read(mem + BCM6328_REG_INIT);\n\tval &= ~(BCM6328_INIT_MASK);\n\tif (of_property_read_bool(np, \"brcm,serial-leds\"))\n\t\tval |= BCM6328_SERIAL_LED_EN;\n\tif (of_property_read_bool(np, \"brcm,serial-mux\"))\n\t\tval |= BCM6328_SERIAL_LED_MUX;\n\tif (of_property_read_bool(np, \"brcm,serial-clk-low\"))\n\t\tval |= BCM6328_SERIAL_LED_CLK_NPOL;\n\tif (!of_property_read_bool(np, \"brcm,serial-dat-low\"))\n\t\tval |= BCM6328_SERIAL_LED_DATA_PPOL;\n\tif (!of_property_read_bool(np, \"brcm,serial-shift-inv\"))\n\t\tval |= BCM6328_SERIAL_LED_SHIFT_DIR;\n\tbcm6328_led_write(mem + BCM6328_REG_INIT, val);\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tint rc;\n\t\tu32 reg;\n\n\t\tif (of_property_read_u32(child, \"reg\", &reg))\n\t\t\tcontinue;\n\n\t\tif (reg >= BCM6328_LED_MAX_COUNT) {\n\t\t\tdev_err(dev, \"invalid LED (%u >= %d)\\n\", reg,\n\t\t\t\tBCM6328_LED_MAX_COUNT);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (of_property_read_bool(child, \"brcm,hardware-controlled\"))\n\t\t\trc = bcm6328_hwled(dev, child, reg, mem, lock);\n\t\telse\n\t\t\trc = bcm6328_led(dev, child, reg, mem, lock,\n\t\t\t\t\t blink_leds, blink_delay);\n\n\t\tif (rc < 0) {\n\t\t\tof_node_put(child);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm6328_leds_of_match[] = {\n\t{ .compatible = \"brcm,bcm6328-leds\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bcm6328_leds_of_match);\n\nstatic struct platform_driver bcm6328_leds_driver = {\n\t.probe = bcm6328_leds_probe,\n\t.driver = {\n\t\t.name = \"leds-bcm6328\",\n\t\t.of_match_table = bcm6328_leds_of_match,\n\t},\n};\n\nmodule_platform_driver(bcm6328_leds_driver);\n\nMODULE_AUTHOR(\"\u00c1lvaro Fern\u00e1ndez Rojas <noltari@gmail.com>\");\nMODULE_AUTHOR(\"Jonas Gorski <jogo@openwrt.org>\");\nMODULE_DESCRIPTION(\"LED driver for BCM6328 controllers\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:leds-bcm6328\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}