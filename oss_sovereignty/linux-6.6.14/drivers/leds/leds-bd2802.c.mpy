{
  "module_name": "leds-bd2802.c",
  "hash_id": "38372275177ade968ac3090cdb63ef79f1f348f03908d5e7de36d59f4a249e92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-bd2802.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/leds.h>\n#include <linux/leds-bd2802.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n\n#define LED_CTL(rgb2en, rgb1en) ((rgb2en) << 4 | ((rgb1en) << 0))\n\n#define BD2802_LED_OFFSET\t\t0xa\n#define BD2802_COLOR_OFFSET\t\t0x3\n\n#define BD2802_REG_CLKSETUP\t\t0x00\n#define BD2802_REG_CONTROL\t\t0x01\n#define BD2802_REG_HOURSETUP\t\t0x02\n#define BD2802_REG_CURRENT1SETUP\t0x03\n#define BD2802_REG_CURRENT2SETUP\t0x04\n#define BD2802_REG_WAVEPATTERN\t\t0x05\n\n#define BD2802_CURRENT_032\t\t0x10  \n#define BD2802_CURRENT_000\t\t0x00  \n\n#define BD2802_PATTERN_FULL\t\t0x07\n#define BD2802_PATTERN_HALF\t\t0x03\n\nenum led_ids {\n\tLED1,\n\tLED2,\n\tLED_NUM,\n};\n\nenum led_colors {\n\tRED,\n\tGREEN,\n\tBLUE,\n};\n\nenum led_bits {\n\tBD2802_OFF,\n\tBD2802_BLINK,\n\tBD2802_ON,\n};\n\n \nstruct led_state {\n\tunsigned r:2;\n\tunsigned g:2;\n\tunsigned b:2;\n};\n\nstruct bd2802_led {\n\tstruct bd2802_led_platform_data\t*pdata;\n\tstruct i2c_client\t\t*client;\n\tstruct gpio_desc\t\t*reset;\n\tstruct rw_semaphore\t\trwsem;\n\n\tstruct led_state\t\tled[2];\n\n\t \n\tstruct led_classdev\t\tcdev_led1r;\n\tstruct led_classdev\t\tcdev_led1g;\n\tstruct led_classdev\t\tcdev_led1b;\n\tstruct led_classdev\t\tcdev_led2r;\n\tstruct led_classdev\t\tcdev_led2g;\n\tstruct led_classdev\t\tcdev_led2b;\n\n\t \n\tint\t\t\t\tadf_on;\n\n\tenum led_ids\t\t\tled_id;\n\tenum led_colors\t\t\tcolor;\n\tenum led_bits\t\t\tstate;\n\n\t \n\tint\t\t\t\twave_pattern;\n\tint\t\t\t\trgb_current;\n};\n\n\n \n \n \n\nstatic inline int bd2802_is_rgb_off(struct bd2802_led *led, enum led_ids id,\n\t\t\t\t\t\t\tenum led_colors color)\n{\n\tswitch (color) {\n\tcase RED:\n\t\treturn !led->led[id].r;\n\tcase GREEN:\n\t\treturn !led->led[id].g;\n\tcase BLUE:\n\t\treturn !led->led[id].b;\n\tdefault:\n\t\tdev_err(&led->client->dev, \"%s: Invalid color\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline int bd2802_is_led_off(struct bd2802_led *led, enum led_ids id)\n{\n\tif (led->led[id].r || led->led[id].g || led->led[id].b)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline int bd2802_is_all_off(struct bd2802_led *led)\n{\n\tint i;\n\n\tfor (i = 0; i < LED_NUM; i++)\n\t\tif (!bd2802_is_led_off(led, i))\n\t\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline u8 bd2802_get_base_offset(enum led_ids id, enum led_colors color)\n{\n\treturn id * BD2802_LED_OFFSET + color * BD2802_COLOR_OFFSET;\n}\n\nstatic inline u8 bd2802_get_reg_addr(enum led_ids id, enum led_colors color,\n\t\t\t\t\t\t\t\tu8 reg_offset)\n{\n\treturn reg_offset + bd2802_get_base_offset(id, color);\n}\n\n\n \n \n \n\nstatic int bd2802_write_byte(struct i2c_client *client, u8 reg, u8 val)\n{\n\tint ret = i2c_smbus_write_byte_data(client, reg, val);\n\tif (ret >= 0)\n\t\treturn 0;\n\n\tdev_err(&client->dev, \"%s: reg 0x%x, val 0x%x, err %d\\n\",\n\t\t\t\t\t\t__func__, reg, val, ret);\n\n\treturn ret;\n}\n\nstatic void bd2802_update_state(struct bd2802_led *led, enum led_ids id,\n\t\t\t\tenum led_colors color, enum led_bits led_bit)\n{\n\tint i;\n\tu8 value;\n\n\tfor (i = 0; i < LED_NUM; i++) {\n\t\tif (i == id) {\n\t\t\tswitch (color) {\n\t\t\tcase RED:\n\t\t\t\tled->led[i].r = led_bit;\n\t\t\t\tbreak;\n\t\t\tcase GREEN:\n\t\t\t\tled->led[i].g = led_bit;\n\t\t\t\tbreak;\n\t\t\tcase BLUE:\n\t\t\t\tled->led[i].b = led_bit;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(&led->client->dev,\n\t\t\t\t\t\"%s: Invalid color\\n\", __func__);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (led_bit == BD2802_BLINK || led_bit == BD2802_ON)\n\t\treturn;\n\n\tif (!bd2802_is_led_off(led, id))\n\t\treturn;\n\n\tif (bd2802_is_all_off(led) && !led->adf_on) {\n\t\tgpiod_set_value(led->reset, 1);\n\t\treturn;\n\t}\n\n\t \n\tvalue = (id == LED1) ? LED_CTL(1, 0) : LED_CTL(0, 1);\n\tbd2802_write_byte(led->client, BD2802_REG_CONTROL, value);\n}\n\nstatic void bd2802_configure(struct bd2802_led *led)\n{\n\tstruct bd2802_led_platform_data *pdata = led->pdata;\n\tu8 reg;\n\n\treg = bd2802_get_reg_addr(LED1, RED, BD2802_REG_HOURSETUP);\n\tbd2802_write_byte(led->client, reg, pdata->rgb_time);\n\n\treg = bd2802_get_reg_addr(LED2, RED, BD2802_REG_HOURSETUP);\n\tbd2802_write_byte(led->client, reg, pdata->rgb_time);\n}\n\nstatic void bd2802_reset_cancel(struct bd2802_led *led)\n{\n\tgpiod_set_value(led->reset, 0);\n\tudelay(100);\n\tbd2802_configure(led);\n}\n\nstatic void bd2802_enable(struct bd2802_led *led, enum led_ids id)\n{\n\tenum led_ids other_led = (id == LED1) ? LED2 : LED1;\n\tu8 value, other_led_on;\n\n\tother_led_on = !bd2802_is_led_off(led, other_led);\n\tif (id == LED1)\n\t\tvalue = LED_CTL(other_led_on, 1);\n\telse\n\t\tvalue = LED_CTL(1 , other_led_on);\n\n\tbd2802_write_byte(led->client, BD2802_REG_CONTROL, value);\n}\n\nstatic void bd2802_set_on(struct bd2802_led *led, enum led_ids id,\n\t\t\t\t\t\t\tenum led_colors color)\n{\n\tu8 reg;\n\n\tif (bd2802_is_all_off(led) && !led->adf_on)\n\t\tbd2802_reset_cancel(led);\n\n\treg = bd2802_get_reg_addr(id, color, BD2802_REG_CURRENT1SETUP);\n\tbd2802_write_byte(led->client, reg, led->rgb_current);\n\treg = bd2802_get_reg_addr(id, color, BD2802_REG_CURRENT2SETUP);\n\tbd2802_write_byte(led->client, reg, BD2802_CURRENT_000);\n\treg = bd2802_get_reg_addr(id, color, BD2802_REG_WAVEPATTERN);\n\tbd2802_write_byte(led->client, reg, BD2802_PATTERN_FULL);\n\n\tbd2802_enable(led, id);\n\tbd2802_update_state(led, id, color, BD2802_ON);\n}\n\nstatic void bd2802_set_blink(struct bd2802_led *led, enum led_ids id,\n\t\t\t\t\t\t\tenum led_colors color)\n{\n\tu8 reg;\n\n\tif (bd2802_is_all_off(led) && !led->adf_on)\n\t\tbd2802_reset_cancel(led);\n\n\treg = bd2802_get_reg_addr(id, color, BD2802_REG_CURRENT1SETUP);\n\tbd2802_write_byte(led->client, reg, BD2802_CURRENT_000);\n\treg = bd2802_get_reg_addr(id, color, BD2802_REG_CURRENT2SETUP);\n\tbd2802_write_byte(led->client, reg, led->rgb_current);\n\treg = bd2802_get_reg_addr(id, color, BD2802_REG_WAVEPATTERN);\n\tbd2802_write_byte(led->client, reg, led->wave_pattern);\n\n\tbd2802_enable(led, id);\n\tbd2802_update_state(led, id, color, BD2802_BLINK);\n}\n\nstatic void bd2802_turn_on(struct bd2802_led *led, enum led_ids id,\n\t\t\t\tenum led_colors color, enum led_bits led_bit)\n{\n\tif (led_bit == BD2802_OFF) {\n\t\tdev_err(&led->client->dev,\n\t\t\t\t\t\"Only 'blink' and 'on' are allowed\\n\");\n\t\treturn;\n\t}\n\n\tif (led_bit == BD2802_BLINK)\n\t\tbd2802_set_blink(led, id, color);\n\telse\n\t\tbd2802_set_on(led, id, color);\n}\n\nstatic void bd2802_turn_off(struct bd2802_led *led, enum led_ids id,\n\t\t\t\t\t\t\tenum led_colors color)\n{\n\tu8 reg;\n\n\tif (bd2802_is_rgb_off(led, id, color))\n\t\treturn;\n\n\treg = bd2802_get_reg_addr(id, color, BD2802_REG_CURRENT1SETUP);\n\tbd2802_write_byte(led->client, reg, BD2802_CURRENT_000);\n\treg = bd2802_get_reg_addr(id, color, BD2802_REG_CURRENT2SETUP);\n\tbd2802_write_byte(led->client, reg, BD2802_CURRENT_000);\n\n\tbd2802_update_state(led, id, color, BD2802_OFF);\n}\n\n#define BD2802_SET_REGISTER(reg_addr, reg_name)\t\t\t\t\\\nstatic ssize_t bd2802_store_reg##reg_addr(struct device *dev,\t\t\\\n\tstruct device_attribute *attr, const char *buf, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bd2802_led *led = i2c_get_clientdata(to_i2c_client(dev));\\\n\tunsigned long val;\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tif (!count)\t\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tret = kstrtoul(buf, 16, &val);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tdown_write(&led->rwsem);\t\t\t\t\t\\\n\tbd2802_write_byte(led->client, reg_addr, (u8) val);\t\t\\\n\tup_write(&led->rwsem);\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic struct device_attribute bd2802_reg##reg_addr##_attr = {\t\t\\\n\t.attr = {.name = reg_name, .mode = 0644},\t\t\t\\\n\t.store = bd2802_store_reg##reg_addr,\t\t\t\t\\\n};\n\nBD2802_SET_REGISTER(0x00, \"0x00\");\nBD2802_SET_REGISTER(0x01, \"0x01\");\nBD2802_SET_REGISTER(0x02, \"0x02\");\nBD2802_SET_REGISTER(0x03, \"0x03\");\nBD2802_SET_REGISTER(0x04, \"0x04\");\nBD2802_SET_REGISTER(0x05, \"0x05\");\nBD2802_SET_REGISTER(0x06, \"0x06\");\nBD2802_SET_REGISTER(0x07, \"0x07\");\nBD2802_SET_REGISTER(0x08, \"0x08\");\nBD2802_SET_REGISTER(0x09, \"0x09\");\nBD2802_SET_REGISTER(0x0a, \"0x0a\");\nBD2802_SET_REGISTER(0x0b, \"0x0b\");\nBD2802_SET_REGISTER(0x0c, \"0x0c\");\nBD2802_SET_REGISTER(0x0d, \"0x0d\");\nBD2802_SET_REGISTER(0x0e, \"0x0e\");\nBD2802_SET_REGISTER(0x0f, \"0x0f\");\nBD2802_SET_REGISTER(0x10, \"0x10\");\nBD2802_SET_REGISTER(0x11, \"0x11\");\nBD2802_SET_REGISTER(0x12, \"0x12\");\nBD2802_SET_REGISTER(0x13, \"0x13\");\nBD2802_SET_REGISTER(0x14, \"0x14\");\nBD2802_SET_REGISTER(0x15, \"0x15\");\n\nstatic struct device_attribute *bd2802_addr_attributes[] = {\n\t&bd2802_reg0x00_attr,\n\t&bd2802_reg0x01_attr,\n\t&bd2802_reg0x02_attr,\n\t&bd2802_reg0x03_attr,\n\t&bd2802_reg0x04_attr,\n\t&bd2802_reg0x05_attr,\n\t&bd2802_reg0x06_attr,\n\t&bd2802_reg0x07_attr,\n\t&bd2802_reg0x08_attr,\n\t&bd2802_reg0x09_attr,\n\t&bd2802_reg0x0a_attr,\n\t&bd2802_reg0x0b_attr,\n\t&bd2802_reg0x0c_attr,\n\t&bd2802_reg0x0d_attr,\n\t&bd2802_reg0x0e_attr,\n\t&bd2802_reg0x0f_attr,\n\t&bd2802_reg0x10_attr,\n\t&bd2802_reg0x11_attr,\n\t&bd2802_reg0x12_attr,\n\t&bd2802_reg0x13_attr,\n\t&bd2802_reg0x14_attr,\n\t&bd2802_reg0x15_attr,\n};\n\nstatic void bd2802_enable_adv_conf(struct bd2802_led *led)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(bd2802_addr_attributes); i++) {\n\t\tret = device_create_file(&led->client->dev,\n\t\t\t\t\t\tbd2802_addr_attributes[i]);\n\t\tif (ret) {\n\t\t\tdev_err(&led->client->dev, \"failed: sysfs file %s\\n\",\n\t\t\t\t\tbd2802_addr_attributes[i]->attr.name);\n\t\t\tgoto failed_remove_files;\n\t\t}\n\t}\n\n\tif (bd2802_is_all_off(led))\n\t\tbd2802_reset_cancel(led);\n\n\tled->adf_on = 1;\n\n\treturn;\n\nfailed_remove_files:\n\tfor (i--; i >= 0; i--)\n\t\tdevice_remove_file(&led->client->dev,\n\t\t\t\t\t\tbd2802_addr_attributes[i]);\n}\n\nstatic void bd2802_disable_adv_conf(struct bd2802_led *led)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bd2802_addr_attributes); i++)\n\t\tdevice_remove_file(&led->client->dev,\n\t\t\t\t\t\tbd2802_addr_attributes[i]);\n\n\tif (bd2802_is_all_off(led))\n\t\tgpiod_set_value(led->reset, 1);\n\n\tled->adf_on = 0;\n}\n\nstatic ssize_t bd2802_show_adv_conf(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct bd2802_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tssize_t ret;\n\n\tdown_read(&led->rwsem);\n\tif (led->adf_on)\n\t\tret = sprintf(buf, \"on\\n\");\n\telse\n\t\tret = sprintf(buf, \"off\\n\");\n\tup_read(&led->rwsem);\n\n\treturn ret;\n}\n\nstatic ssize_t bd2802_store_adv_conf(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct bd2802_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tdown_write(&led->rwsem);\n\tif (!led->adf_on && !strncmp(buf, \"on\", 2))\n\t\tbd2802_enable_adv_conf(led);\n\telse if (led->adf_on && !strncmp(buf, \"off\", 3))\n\t\tbd2802_disable_adv_conf(led);\n\tup_write(&led->rwsem);\n\n\treturn count;\n}\n\nstatic struct device_attribute bd2802_adv_conf_attr = {\n\t.attr = {\n\t\t.name = \"advanced_configuration\",\n\t\t.mode = 0644,\n\t},\n\t.show = bd2802_show_adv_conf,\n\t.store = bd2802_store_adv_conf,\n};\n\n#define BD2802_CONTROL_ATTR(attr_name, name_str)\t\t\t\\\nstatic ssize_t bd2802_show_##attr_name(struct device *dev,\t\t\\\n\tstruct device_attribute *attr, char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bd2802_led *led = i2c_get_clientdata(to_i2c_client(dev));\\\n\tssize_t ret;\t\t\t\t\t\t\t\\\n\tdown_read(&led->rwsem);\t\t\t\t\t\t\\\n\tret = sprintf(buf, \"0x%02x\\n\", led->attr_name);\t\t\t\\\n\tup_read(&led->rwsem);\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t bd2802_store_##attr_name(struct device *dev,\t\t\\\n\tstruct device_attribute *attr, const char *buf, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bd2802_led *led = i2c_get_clientdata(to_i2c_client(dev));\\\n\tunsigned long val;\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tif (!count)\t\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tret = kstrtoul(buf, 16, &val);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tdown_write(&led->rwsem);\t\t\t\t\t\\\n\tled->attr_name = val;\t\t\t\t\t\t\\\n\tup_write(&led->rwsem);\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic struct device_attribute bd2802_##attr_name##_attr = {\t\t\\\n\t.attr = {\t\t\t\t\t\t\t\\\n\t\t.name = name_str,\t\t\t\t\t\\\n\t\t.mode = 0644,\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.show = bd2802_show_##attr_name,\t\t\t\t\\\n\t.store = bd2802_store_##attr_name,\t\t\t\t\\\n};\n\nBD2802_CONTROL_ATTR(wave_pattern, \"wave_pattern\");\nBD2802_CONTROL_ATTR(rgb_current, \"rgb_current\");\n\nstatic struct device_attribute *bd2802_attributes[] = {\n\t&bd2802_adv_conf_attr,\n\t&bd2802_wave_pattern_attr,\n\t&bd2802_rgb_current_attr,\n};\n\n#define BD2802_CONTROL_RGBS(name, id, clr)\t\t\t\t\\\nstatic int bd2802_set_##name##_brightness(struct led_classdev *led_cdev,\\\n\t\t\t\t\tenum led_brightness value)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bd2802_led *led =\t\t\t\t\t\\\n\t\tcontainer_of(led_cdev, struct bd2802_led, cdev_##name);\t\\\n\tled->led_id = id;\t\t\t\t\t\t\\\n\tled->color = clr;\t\t\t\t\t\t\\\n\tif (value == LED_OFF) {\t\t\t\t\t\t\\\n\t\tled->state = BD2802_OFF;\t\t\t\t\\\n\t\tbd2802_turn_off(led, led->led_id, led->color);\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tled->state = BD2802_ON;\t\t\t\t\t\\\n\t\tbd2802_turn_on(led, led->led_id, led->color, BD2802_ON);\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic int bd2802_set_##name##_blink(struct led_classdev *led_cdev,\t\\\n\t\tunsigned long *delay_on, unsigned long *delay_off)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bd2802_led *led =\t\t\t\t\t\\\n\t\tcontainer_of(led_cdev, struct bd2802_led, cdev_##name);\t\\\n\tif (*delay_on == 0 || *delay_off == 0)\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tled->led_id = id;\t\t\t\t\t\t\\\n\tled->color = clr;\t\t\t\t\t\t\\\n\tled->state = BD2802_BLINK;\t\t\t\t\t\\\n\tbd2802_turn_on(led, led->led_id, led->color, BD2802_BLINK);\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\nBD2802_CONTROL_RGBS(led1r, LED1, RED);\nBD2802_CONTROL_RGBS(led1g, LED1, GREEN);\nBD2802_CONTROL_RGBS(led1b, LED1, BLUE);\nBD2802_CONTROL_RGBS(led2r, LED2, RED);\nBD2802_CONTROL_RGBS(led2g, LED2, GREEN);\nBD2802_CONTROL_RGBS(led2b, LED2, BLUE);\n\nstatic int bd2802_register_led_classdev(struct bd2802_led *led)\n{\n\tint ret;\n\n\tled->cdev_led1r.name = \"led1_R\";\n\tled->cdev_led1r.brightness = LED_OFF;\n\tled->cdev_led1r.brightness_set_blocking = bd2802_set_led1r_brightness;\n\tled->cdev_led1r.blink_set = bd2802_set_led1r_blink;\n\n\tret = led_classdev_register(&led->client->dev, &led->cdev_led1r);\n\tif (ret < 0) {\n\t\tdev_err(&led->client->dev, \"couldn't register LED %s\\n\",\n\t\t\t\t\t\t\tled->cdev_led1r.name);\n\t\tgoto failed_unregister_led1_R;\n\t}\n\n\tled->cdev_led1g.name = \"led1_G\";\n\tled->cdev_led1g.brightness = LED_OFF;\n\tled->cdev_led1g.brightness_set_blocking = bd2802_set_led1g_brightness;\n\tled->cdev_led1g.blink_set = bd2802_set_led1g_blink;\n\n\tret = led_classdev_register(&led->client->dev, &led->cdev_led1g);\n\tif (ret < 0) {\n\t\tdev_err(&led->client->dev, \"couldn't register LED %s\\n\",\n\t\t\t\t\t\t\tled->cdev_led1g.name);\n\t\tgoto failed_unregister_led1_G;\n\t}\n\n\tled->cdev_led1b.name = \"led1_B\";\n\tled->cdev_led1b.brightness = LED_OFF;\n\tled->cdev_led1b.brightness_set_blocking = bd2802_set_led1b_brightness;\n\tled->cdev_led1b.blink_set = bd2802_set_led1b_blink;\n\n\tret = led_classdev_register(&led->client->dev, &led->cdev_led1b);\n\tif (ret < 0) {\n\t\tdev_err(&led->client->dev, \"couldn't register LED %s\\n\",\n\t\t\t\t\t\t\tled->cdev_led1b.name);\n\t\tgoto failed_unregister_led1_B;\n\t}\n\n\tled->cdev_led2r.name = \"led2_R\";\n\tled->cdev_led2r.brightness = LED_OFF;\n\tled->cdev_led2r.brightness_set_blocking = bd2802_set_led2r_brightness;\n\tled->cdev_led2r.blink_set = bd2802_set_led2r_blink;\n\n\tret = led_classdev_register(&led->client->dev, &led->cdev_led2r);\n\tif (ret < 0) {\n\t\tdev_err(&led->client->dev, \"couldn't register LED %s\\n\",\n\t\t\t\t\t\t\tled->cdev_led2r.name);\n\t\tgoto failed_unregister_led2_R;\n\t}\n\n\tled->cdev_led2g.name = \"led2_G\";\n\tled->cdev_led2g.brightness = LED_OFF;\n\tled->cdev_led2g.brightness_set_blocking = bd2802_set_led2g_brightness;\n\tled->cdev_led2g.blink_set = bd2802_set_led2g_blink;\n\n\tret = led_classdev_register(&led->client->dev, &led->cdev_led2g);\n\tif (ret < 0) {\n\t\tdev_err(&led->client->dev, \"couldn't register LED %s\\n\",\n\t\t\t\t\t\t\tled->cdev_led2g.name);\n\t\tgoto failed_unregister_led2_G;\n\t}\n\n\tled->cdev_led2b.name = \"led2_B\";\n\tled->cdev_led2b.brightness = LED_OFF;\n\tled->cdev_led2b.brightness_set_blocking = bd2802_set_led2b_brightness;\n\tled->cdev_led2b.blink_set = bd2802_set_led2b_blink;\n\tled->cdev_led2b.flags |= LED_CORE_SUSPENDRESUME;\n\n\tret = led_classdev_register(&led->client->dev, &led->cdev_led2b);\n\tif (ret < 0) {\n\t\tdev_err(&led->client->dev, \"couldn't register LED %s\\n\",\n\t\t\t\t\t\t\tled->cdev_led2b.name);\n\t\tgoto failed_unregister_led2_B;\n\t}\n\n\treturn 0;\n\nfailed_unregister_led2_B:\n\tled_classdev_unregister(&led->cdev_led2g);\nfailed_unregister_led2_G:\n\tled_classdev_unregister(&led->cdev_led2r);\nfailed_unregister_led2_R:\n\tled_classdev_unregister(&led->cdev_led1b);\nfailed_unregister_led1_B:\n\tled_classdev_unregister(&led->cdev_led1g);\nfailed_unregister_led1_G:\n\tled_classdev_unregister(&led->cdev_led1r);\nfailed_unregister_led1_R:\n\n\treturn ret;\n}\n\nstatic void bd2802_unregister_led_classdev(struct bd2802_led *led)\n{\n\tled_classdev_unregister(&led->cdev_led2b);\n\tled_classdev_unregister(&led->cdev_led2g);\n\tled_classdev_unregister(&led->cdev_led2r);\n\tled_classdev_unregister(&led->cdev_led1b);\n\tled_classdev_unregister(&led->cdev_led1g);\n\tled_classdev_unregister(&led->cdev_led1r);\n}\n\nstatic int bd2802_probe(struct i2c_client *client)\n{\n\tstruct bd2802_led *led;\n\tint ret, i;\n\n\tled = devm_kzalloc(&client->dev, sizeof(struct bd2802_led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tled->client = client;\n\ti2c_set_clientdata(client, led);\n\n\t \n\tled->reset = devm_gpiod_get(&client->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(led->reset))\n\t\treturn PTR_ERR(led->reset);\n\n\t \n\tudelay(100);\n\n\t \n\tret = bd2802_write_byte(client, BD2802_REG_CLKSETUP, 0x00);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to detect device\\n\");\n\t\treturn ret;\n\t} else\n\t\tdev_info(&client->dev, \"return 0x%02x\\n\", ret);\n\n\t \n\tgpiod_set_value(led->reset, 1);\n\n\t \n\tled->wave_pattern = BD2802_PATTERN_HALF;\n\tled->rgb_current = BD2802_CURRENT_032;\n\n\tinit_rwsem(&led->rwsem);\n\n\tfor (i = 0; i < ARRAY_SIZE(bd2802_attributes); i++) {\n\t\tret = device_create_file(&led->client->dev,\n\t\t\t\t\t\tbd2802_attributes[i]);\n\t\tif (ret) {\n\t\t\tdev_err(&led->client->dev, \"failed: sysfs file %s\\n\",\n\t\t\t\t\tbd2802_attributes[i]->attr.name);\n\t\t\tgoto failed_unregister_dev_file;\n\t\t}\n\t}\n\n\tret = bd2802_register_led_classdev(led);\n\tif (ret < 0)\n\t\tgoto failed_unregister_dev_file;\n\n\treturn 0;\n\nfailed_unregister_dev_file:\n\tfor (i--; i >= 0; i--)\n\t\tdevice_remove_file(&led->client->dev, bd2802_attributes[i]);\n\treturn ret;\n}\n\nstatic void bd2802_remove(struct i2c_client *client)\n{\n\tstruct bd2802_led *led = i2c_get_clientdata(client);\n\tint i;\n\n\tgpiod_set_value(led->reset, 1);\n\tbd2802_unregister_led_classdev(led);\n\tif (led->adf_on)\n\t\tbd2802_disable_adv_conf(led);\n\tfor (i = 0; i < ARRAY_SIZE(bd2802_attributes); i++)\n\t\tdevice_remove_file(&led->client->dev, bd2802_attributes[i]);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void bd2802_restore_state(struct bd2802_led *led)\n{\n\tint i;\n\n\tfor (i = 0; i < LED_NUM; i++) {\n\t\tif (led->led[i].r)\n\t\t\tbd2802_turn_on(led, i, RED, led->led[i].r);\n\t\tif (led->led[i].g)\n\t\t\tbd2802_turn_on(led, i, GREEN, led->led[i].g);\n\t\tif (led->led[i].b)\n\t\t\tbd2802_turn_on(led, i, BLUE, led->led[i].b);\n\t}\n}\n\nstatic int bd2802_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bd2802_led *led = i2c_get_clientdata(client);\n\n\tgpiod_set_value(led->reset, 1);\n\n\treturn 0;\n}\n\nstatic int bd2802_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bd2802_led *led = i2c_get_clientdata(client);\n\n\tif (!bd2802_is_all_off(led) || led->adf_on) {\n\t\tbd2802_reset_cancel(led);\n\t\tbd2802_restore_state(led);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(bd2802_pm, bd2802_suspend, bd2802_resume);\n\nstatic const struct i2c_device_id bd2802_id[] = {\n\t{ \"BD2802\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, bd2802_id);\n\nstatic struct i2c_driver bd2802_i2c_driver = {\n\t.driver\t= {\n\t\t.name\t= \"BD2802\",\n\t\t.pm\t= &bd2802_pm,\n\t},\n\t.probe\t\t= bd2802_probe,\n\t.remove\t\t= bd2802_remove,\n\t.id_table\t= bd2802_id,\n};\n\nmodule_i2c_driver(bd2802_i2c_driver);\n\nMODULE_AUTHOR(\"Kim Kyuwon <q1.kim@samsung.com>\");\nMODULE_DESCRIPTION(\"BD2802 LED driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}