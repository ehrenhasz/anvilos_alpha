{
  "module_name": "leds-lm3692x.c",
  "hash_id": "c720ec7ddedbf76540a502ac599f0bb69ac99dc16b90ae66960a0ae0313c1455",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lm3692x.c",
  "human_readable_source": "\n\n\n\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/leds.h>\n#include <linux/log2.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#define LM36922_MODEL\t0\n#define LM36923_MODEL\t1\n\n#define LM3692X_REV\t\t0x0\n#define LM3692X_RESET\t\t0x1\n#define LM3692X_EN\t\t0x10\n#define LM3692X_BRT_CTRL\t0x11\n#define LM3692X_PWM_CTRL\t0x12\n#define LM3692X_BOOST_CTRL\t0x13\n#define LM3692X_AUTO_FREQ_HI\t0x15\n#define LM3692X_AUTO_FREQ_LO\t0x16\n#define LM3692X_BL_ADJ_THRESH\t0x17\n#define LM3692X_BRT_LSB\t\t0x18\n#define LM3692X_BRT_MSB\t\t0x19\n#define LM3692X_FAULT_CTRL\t0x1e\n#define LM3692X_FAULT_FLAGS\t0x1f\n\n#define LM3692X_SW_RESET\tBIT(0)\n#define LM3692X_DEVICE_EN\tBIT(0)\n#define LM3692X_LED1_EN\t\tBIT(1)\n#define LM3692X_LED2_EN\t\tBIT(2)\n#define LM36923_LED3_EN\t\tBIT(3)\n#define LM3692X_ENABLE_MASK\t(LM3692X_DEVICE_EN | LM3692X_LED1_EN | \\\n\t\t\t\t LM3692X_LED2_EN | LM36923_LED3_EN)\n\n \n#define LM3692X_BL_ADJ_POL\tBIT(0)\n#define LM3692X_RAMP_RATE_125us\t0x00\n#define LM3692X_RAMP_RATE_250us\tBIT(1)\n#define LM3692X_RAMP_RATE_500us BIT(2)\n#define LM3692X_RAMP_RATE_1ms\t(BIT(1) | BIT(2))\n#define LM3692X_RAMP_RATE_2ms\tBIT(3)\n#define LM3692X_RAMP_RATE_4ms\t(BIT(3) | BIT(1))\n#define LM3692X_RAMP_RATE_8ms\t(BIT(2) | BIT(3))\n#define LM3692X_RAMP_RATE_16ms\t(BIT(1) | BIT(2) | BIT(3))\n#define LM3692X_RAMP_EN\t\tBIT(4)\n#define LM3692X_BRHT_MODE_REG\t0x00\n#define LM3692X_BRHT_MODE_PWM\tBIT(5)\n#define LM3692X_BRHT_MODE_MULTI_RAMP BIT(6)\n#define LM3692X_BRHT_MODE_RAMP_MULTI (BIT(5) | BIT(6))\n#define LM3692X_MAP_MODE_EXP\tBIT(7)\n\n \n#define LM3692X_PWM_FILTER_100\tBIT(0)\n#define LM3692X_PWM_FILTER_150\tBIT(1)\n#define LM3692X_PWM_FILTER_200\t(BIT(0) | BIT(1))\n#define LM3692X_PWM_HYSTER_1LSB BIT(2)\n#define LM3692X_PWM_HYSTER_2LSB\tBIT(3)\n#define LM3692X_PWM_HYSTER_3LSB (BIT(3) | BIT(2))\n#define LM3692X_PWM_HYSTER_4LSB BIT(4)\n#define LM3692X_PWM_HYSTER_5LSB (BIT(4) | BIT(2))\n#define LM3692X_PWM_HYSTER_6LSB (BIT(4) | BIT(3))\n#define LM3692X_PWM_POLARITY\tBIT(5)\n#define LM3692X_PWM_SAMP_4MHZ\tBIT(6)\n#define LM3692X_PWM_SAMP_24MHZ\tBIT(7)\n\n \n#define LM3692X_OCP_PROT_1A\tBIT(0)\n#define LM3692X_OCP_PROT_1_25A\tBIT(1)\n#define LM3692X_OCP_PROT_1_5A\t(BIT(0) | BIT(1))\n#define LM3692X_OVP_21V\t\tBIT(2)\n#define LM3692X_OVP_25V\t\tBIT(3)\n#define LM3692X_OVP_29V\t\t(BIT(2) | BIT(3))\n#define LM3692X_MIN_IND_22UH\tBIT(4)\n#define LM3692X_BOOST_SW_1MHZ\tBIT(5)\n#define LM3692X_BOOST_SW_NO_SHIFT\tBIT(6)\n\n \n#define LM3692X_FAULT_CTRL_OVP BIT(0)\n#define LM3692X_FAULT_CTRL_OCP BIT(1)\n#define LM3692X_FAULT_CTRL_TSD BIT(2)\n#define LM3692X_FAULT_CTRL_OPEN BIT(3)\n\n \n#define LM3692X_FAULT_FLAG_OVP BIT(0)\n#define LM3692X_FAULT_FLAG_OCP BIT(1)\n#define LM3692X_FAULT_FLAG_TSD BIT(2)\n#define LM3692X_FAULT_FLAG_SHRT BIT(3)\n#define LM3692X_FAULT_FLAG_OPEN BIT(4)\n\n \nstruct lm3692x_led {\n\tstruct mutex lock;\n\tstruct i2c_client *client;\n\tstruct led_classdev led_dev;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *enable_gpio;\n\tstruct regulator *regulator;\n\tint led_enable;\n\tint model_id;\n\n\tu8 boost_ctrl, brightness_ctrl;\n\tbool enabled;\n};\n\nstatic const struct reg_default lm3692x_reg_defs[] = {\n\t{LM3692X_EN, 0xf},\n\t{LM3692X_BRT_CTRL, 0x61},\n\t{LM3692X_PWM_CTRL, 0x73},\n\t{LM3692X_BOOST_CTRL, 0x6f},\n\t{LM3692X_AUTO_FREQ_HI, 0x0},\n\t{LM3692X_AUTO_FREQ_LO, 0x0},\n\t{LM3692X_BL_ADJ_THRESH, 0x0},\n\t{LM3692X_BRT_LSB, 0x7},\n\t{LM3692X_BRT_MSB, 0xff},\n\t{LM3692X_FAULT_CTRL, 0x7},\n};\n\nstatic const struct regmap_config lm3692x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = LM3692X_FAULT_FLAGS,\n\t.reg_defaults = lm3692x_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(lm3692x_reg_defs),\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int lm3692x_fault_check(struct lm3692x_led *led)\n{\n\tint ret;\n\tunsigned int read_buf;\n\n\tret = regmap_read(led->regmap, LM3692X_FAULT_FLAGS, &read_buf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (read_buf)\n\t\tdev_err(&led->client->dev, \"Detected a fault 0x%X\\n\", read_buf);\n\n\t \n\tregmap_read(led->regmap, LM3692X_FAULT_FLAGS, &read_buf);\n\tif (read_buf)\n\t\tdev_err(&led->client->dev, \"Second read of fault flags 0x%X\\n\",\n\t\t\tread_buf);\n\n\treturn read_buf;\n}\n\nstatic int lm3692x_leds_enable(struct lm3692x_led *led)\n{\n\tint enable_state;\n\tint ret, reg_ret;\n\n\tif (led->enabled)\n\t\treturn 0;\n\n\tif (led->regulator) {\n\t\tret = regulator_enable(led->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(&led->client->dev,\n\t\t\t\t\"Failed to enable regulator: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (led->enable_gpio)\n\t\tgpiod_direction_output(led->enable_gpio, 1);\n\n\tret = lm3692x_fault_check(led);\n\tif (ret) {\n\t\tdev_err(&led->client->dev, \"Cannot read/clear faults: %d\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tret = regmap_write(led->regmap, LM3692X_BRT_CTRL, 0x00);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = regmap_write(led->regmap, LM3692X_EN, LM3692X_DEVICE_EN);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = regmap_write(led->regmap, LM3692X_BRT_MSB, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_write(led->regmap, LM3692X_BRT_LSB, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_write(led->regmap, LM3692X_PWM_CTRL,\n\t\tLM3692X_PWM_FILTER_100 | LM3692X_PWM_SAMP_24MHZ);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_write(led->regmap, LM3692X_BOOST_CTRL, led->boost_ctrl);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_write(led->regmap, LM3692X_AUTO_FREQ_HI, 0x00);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_write(led->regmap, LM3692X_AUTO_FREQ_LO, 0x00);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_write(led->regmap, LM3692X_BL_ADJ_THRESH, 0x00);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_write(led->regmap, LM3692X_BRT_CTRL,\n\t\t\tLM3692X_BL_ADJ_POL | LM3692X_RAMP_EN);\n\tif (ret)\n\t\tgoto out;\n\n\tswitch (led->led_enable) {\n\tcase 0:\n\tdefault:\n\t\tif (led->model_id == LM36923_MODEL)\n\t\t\tenable_state = LM3692X_LED1_EN | LM3692X_LED2_EN |\n\t\t\t       LM36923_LED3_EN;\n\t\telse\n\t\t\tenable_state = LM3692X_LED1_EN | LM3692X_LED2_EN;\n\n\t\tbreak;\n\tcase 1:\n\t\tenable_state = LM3692X_LED1_EN;\n\t\tbreak;\n\tcase 2:\n\t\tenable_state = LM3692X_LED2_EN;\n\t\tbreak;\n\n\tcase 3:\n\t\tif (led->model_id == LM36923_MODEL) {\n\t\t\tenable_state = LM36923_LED3_EN;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = -EINVAL;\n\t\tdev_err(&led->client->dev,\n\t\t\t\"LED3 sync not available on this device\\n\");\n\t\tgoto out;\n\t}\n\n\tret = regmap_update_bits(led->regmap, LM3692X_EN, LM3692X_ENABLE_MASK,\n\t\t\t\t enable_state | LM3692X_DEVICE_EN);\n\n\tled->enabled = true;\n\treturn ret;\nout:\n\tdev_err(&led->client->dev, \"Fail writing initialization values\\n\");\n\n\tif (led->enable_gpio)\n\t\tgpiod_direction_output(led->enable_gpio, 0);\n\n\tif (led->regulator) {\n\t\treg_ret = regulator_disable(led->regulator);\n\t\tif (reg_ret)\n\t\t\tdev_err(&led->client->dev,\n\t\t\t\t\"Failed to disable regulator: %d\\n\", reg_ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int lm3692x_leds_disable(struct lm3692x_led *led)\n{\n\tint ret;\n\n\tif (!led->enabled)\n\t\treturn 0;\n\n\tret = regmap_update_bits(led->regmap, LM3692X_EN, LM3692X_DEVICE_EN, 0);\n\tif (ret) {\n\t\tdev_err(&led->client->dev, \"Failed to disable regulator: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (led->enable_gpio)\n\t\tgpiod_direction_output(led->enable_gpio, 0);\n\n\tif (led->regulator) {\n\t\tret = regulator_disable(led->regulator);\n\t\tif (ret)\n\t\t\tdev_err(&led->client->dev,\n\t\t\t\t\"Failed to disable regulator: %d\\n\", ret);\n\t}\n\n\tled->enabled = false;\n\treturn ret;\n}\n\nstatic int lm3692x_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\tenum led_brightness brt_val)\n{\n\tstruct lm3692x_led *led =\n\t\t\tcontainer_of(led_cdev, struct lm3692x_led, led_dev);\n\tint ret;\n\tint led_brightness_lsb = (brt_val >> 5);\n\n\tmutex_lock(&led->lock);\n\n\tif (brt_val == 0) {\n\t\tret = lm3692x_leds_disable(led);\n\t\tgoto out;\n\t} else {\n\t\tlm3692x_leds_enable(led);\n\t}\n\n\tret = lm3692x_fault_check(led);\n\tif (ret) {\n\t\tdev_err(&led->client->dev, \"Cannot read/clear faults: %d\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tret = regmap_write(led->regmap, LM3692X_BRT_MSB, brt_val);\n\tif (ret) {\n\t\tdev_err(&led->client->dev, \"Cannot write MSB: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = regmap_write(led->regmap, LM3692X_BRT_LSB, led_brightness_lsb);\n\tif (ret) {\n\t\tdev_err(&led->client->dev, \"Cannot write LSB: %d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&led->lock);\n\treturn ret;\n}\n\nstatic enum led_brightness lm3692x_max_brightness(struct lm3692x_led *led,\n\t\t\t\t\t\t  u32 max_cur)\n{\n\tu32 max_code;\n\n\t \n\tmax_code = ((max_cur * 1000) - 37806) / 12195;\n\tif (max_code > 0x7FF)\n\t\tmax_code = 0x7FF;\n\n\treturn max_code >> 3;\n}\n\nstatic int lm3692x_probe_dt(struct lm3692x_led *led)\n{\n\tstruct fwnode_handle *child = NULL;\n\tstruct led_init_data init_data = {};\n\tu32 ovp, max_cur;\n\tint ret;\n\n\tled->enable_gpio = devm_gpiod_get_optional(&led->client->dev,\n\t\t\t\t\t\t   \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(led->enable_gpio)) {\n\t\tret = PTR_ERR(led->enable_gpio);\n\t\tdev_err(&led->client->dev, \"Failed to get enable gpio: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tled->regulator = devm_regulator_get_optional(&led->client->dev, \"vled\");\n\tif (IS_ERR(led->regulator)) {\n\t\tret = PTR_ERR(led->regulator);\n\t\tif (ret != -ENODEV)\n\t\t\treturn dev_err_probe(&led->client->dev, ret,\n\t\t\t\t\t     \"Failed to get vled regulator\\n\");\n\n\t\tled->regulator = NULL;\n\t}\n\n\tled->boost_ctrl = LM3692X_BOOST_SW_1MHZ |\n\t\tLM3692X_BOOST_SW_NO_SHIFT |\n\t\tLM3692X_OCP_PROT_1_5A;\n\tret = device_property_read_u32(&led->client->dev,\n\t\t\t\t       \"ti,ovp-microvolt\", &ovp);\n\tif (ret) {\n\t\tled->boost_ctrl |= LM3692X_OVP_29V;\n\t} else {\n\t\tswitch (ovp) {\n\t\tcase 17000000:\n\t\t\tbreak;\n\t\tcase 21000000:\n\t\t\tled->boost_ctrl |= LM3692X_OVP_21V;\n\t\t\tbreak;\n\t\tcase 25000000:\n\t\t\tled->boost_ctrl |= LM3692X_OVP_25V;\n\t\t\tbreak;\n\t\tcase 29000000:\n\t\t\tled->boost_ctrl |= LM3692X_OVP_29V;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&led->client->dev, \"Invalid OVP %d\\n\", ovp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tchild = device_get_next_child_node(&led->client->dev, child);\n\tif (!child) {\n\t\tdev_err(&led->client->dev, \"No LED Child node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = fwnode_property_read_u32(child, \"reg\", &led->led_enable);\n\tif (ret) {\n\t\tfwnode_handle_put(child);\n\t\tdev_err(&led->client->dev, \"reg DT property missing\\n\");\n\t\treturn ret;\n\t}\n\n\tret = fwnode_property_read_u32(child, \"led-max-microamp\", &max_cur);\n\tled->led_dev.max_brightness = ret ? LED_FULL :\n\t\tlm3692x_max_brightness(led, max_cur);\n\n\tinit_data.fwnode = child;\n\tinit_data.devicename = led->client->name;\n\tinit_data.default_label = \":\";\n\n\tret = devm_led_classdev_register_ext(&led->client->dev, &led->led_dev,\n\t\t\t\t\t     &init_data);\n\tif (ret)\n\t\tdev_err(&led->client->dev, \"led register err: %d\\n\", ret);\n\n\tfwnode_handle_put(init_data.fwnode);\n\treturn ret;\n}\n\nstatic int lm3692x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct lm3692x_led *led;\n\tint ret;\n\n\tled = devm_kzalloc(&client->dev, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&led->lock);\n\tled->client = client;\n\tled->led_dev.brightness_set_blocking = lm3692x_brightness_set;\n\tled->model_id = id->driver_data;\n\ti2c_set_clientdata(client, led);\n\n\tled->regmap = devm_regmap_init_i2c(client, &lm3692x_regmap_config);\n\tif (IS_ERR(led->regmap)) {\n\t\tret = PTR_ERR(led->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = lm3692x_probe_dt(led);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lm3692x_leds_enable(led);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void lm3692x_remove(struct i2c_client *client)\n{\n\tstruct lm3692x_led *led = i2c_get_clientdata(client);\n\n\tlm3692x_leds_disable(led);\n\tmutex_destroy(&led->lock);\n}\n\nstatic const struct i2c_device_id lm3692x_id[] = {\n\t{ \"lm36922\", LM36922_MODEL },\n\t{ \"lm36923\", LM36923_MODEL },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm3692x_id);\n\nstatic const struct of_device_id of_lm3692x_leds_match[] = {\n\t{ .compatible = \"ti,lm36922\", },\n\t{ .compatible = \"ti,lm36923\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_lm3692x_leds_match);\n\nstatic struct i2c_driver lm3692x_driver = {\n\t.driver = {\n\t\t.name\t= \"lm3692x\",\n\t\t.of_match_table = of_lm3692x_leds_match,\n\t},\n\t.probe\t\t= lm3692x_probe,\n\t.remove\t\t= lm3692x_remove,\n\t.id_table\t= lm3692x_id,\n};\nmodule_i2c_driver(lm3692x_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments LM3692X LED driver\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}