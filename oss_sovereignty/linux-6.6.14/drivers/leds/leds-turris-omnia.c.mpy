{
  "module_name": "leds-turris-omnia.c",
  "hash_id": "a4571b59185c0bc26cc4dfc7da0cd134df82dc5c5b59b81e340c83c1265419f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-turris-omnia.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/led-class-multicolor.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include \"leds.h\"\n\n#define OMNIA_BOARD_LEDS\t12\n#define OMNIA_LED_NUM_CHANNELS\t3\n\n#define CMD_LED_MODE\t\t3\n#define CMD_LED_MODE_LED(l)\t((l) & 0x0f)\n#define CMD_LED_MODE_USER\t0x10\n\n#define CMD_LED_STATE\t\t4\n#define CMD_LED_STATE_LED(l)\t((l) & 0x0f)\n#define CMD_LED_STATE_ON\t0x10\n\n#define CMD_LED_COLOR\t\t5\n#define CMD_LED_SET_BRIGHTNESS\t7\n#define CMD_LED_GET_BRIGHTNESS\t8\n\nstruct omnia_led {\n\tstruct led_classdev_mc mc_cdev;\n\tstruct mc_subled subled_info[OMNIA_LED_NUM_CHANNELS];\n\tint reg;\n};\n\n#define to_omnia_led(l)\t\tcontainer_of(l, struct omnia_led, mc_cdev)\n\nstruct omnia_leds {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tstruct omnia_led leds[];\n};\n\nstatic int omnia_cmd_write_u8(const struct i2c_client *client, u8 cmd, u8 val)\n{\n\tu8 buf[2] = { cmd, val };\n\n\treturn i2c_master_send(client, buf, sizeof(buf));\n}\n\nstatic int omnia_cmd_read_u8(const struct i2c_client *client, u8 cmd)\n{\n\tstruct i2c_msg msgs[2];\n\tu8 reply;\n\tint ret;\n\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = 1;\n\tmsgs[0].buf = &cmd;\n\tmsgs[1].addr = client->addr;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].len = 1;\n\tmsgs[1].buf = &reply;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (likely(ret == ARRAY_SIZE(msgs)))\n\t\treturn reply;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int omnia_led_brightness_set_blocking(struct led_classdev *cdev,\n\t\t\t\t\t     enum led_brightness brightness)\n{\n\tstruct led_classdev_mc *mc_cdev = lcdev_to_mccdev(cdev);\n\tstruct omnia_leds *leds = dev_get_drvdata(cdev->dev->parent);\n\tstruct omnia_led *led = to_omnia_led(mc_cdev);\n\tu8 buf[5], state;\n\tint ret;\n\n\tmutex_lock(&leds->lock);\n\n\tled_mc_calc_color_components(&led->mc_cdev, brightness);\n\n\tbuf[0] = CMD_LED_COLOR;\n\tbuf[1] = led->reg;\n\tbuf[2] = mc_cdev->subled_info[0].brightness;\n\tbuf[3] = mc_cdev->subled_info[1].brightness;\n\tbuf[4] = mc_cdev->subled_info[2].brightness;\n\n\tstate = CMD_LED_STATE_LED(led->reg);\n\tif (buf[2] || buf[3] || buf[4])\n\t\tstate |= CMD_LED_STATE_ON;\n\n\tret = omnia_cmd_write_u8(leds->client, CMD_LED_STATE, state);\n\tif (ret >= 0 && (state & CMD_LED_STATE_ON))\n\t\tret = i2c_master_send(leds->client, buf, 5);\n\n\tmutex_unlock(&leds->lock);\n\n\treturn ret;\n}\n\nstatic int omnia_led_register(struct i2c_client *client, struct omnia_led *led,\n\t\t\t      struct device_node *np)\n{\n\tstruct led_init_data init_data = {};\n\tstruct device *dev = &client->dev;\n\tstruct led_classdev *cdev;\n\tint ret, color;\n\n\tret = of_property_read_u32(np, \"reg\", &led->reg);\n\tif (ret || led->reg >= OMNIA_BOARD_LEDS) {\n\t\tdev_warn(dev,\n\t\t\t \"Node %pOF: must contain 'reg' property with values between 0 and %i\\n\",\n\t\t\t np, OMNIA_BOARD_LEDS - 1);\n\t\treturn 0;\n\t}\n\n\tret = of_property_read_u32(np, \"color\", &color);\n\tif (ret || color != LED_COLOR_ID_RGB) {\n\t\tdev_warn(dev,\n\t\t\t \"Node %pOF: must contain 'color' property with value LED_COLOR_ID_RGB\\n\",\n\t\t\t np);\n\t\treturn 0;\n\t}\n\n\tled->subled_info[0].color_index = LED_COLOR_ID_RED;\n\tled->subled_info[0].channel = 0;\n\tled->subled_info[1].color_index = LED_COLOR_ID_GREEN;\n\tled->subled_info[1].channel = 1;\n\tled->subled_info[2].color_index = LED_COLOR_ID_BLUE;\n\tled->subled_info[2].channel = 2;\n\n\tled->mc_cdev.subled_info = led->subled_info;\n\tled->mc_cdev.num_colors = OMNIA_LED_NUM_CHANNELS;\n\n\tinit_data.fwnode = &np->fwnode;\n\n\tcdev = &led->mc_cdev.led_cdev;\n\tcdev->max_brightness = 255;\n\tcdev->brightness_set_blocking = omnia_led_brightness_set_blocking;\n\n\t \n\tret = omnia_cmd_write_u8(client, CMD_LED_MODE,\n\t\t\t\t CMD_LED_MODE_LED(led->reg) |\n\t\t\t\t CMD_LED_MODE_USER);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot set LED %pOF to software mode: %i\\n\", np,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = omnia_cmd_write_u8(client, CMD_LED_STATE,\n\t\t\t\t CMD_LED_STATE_LED(led->reg));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot set LED %pOF brightness: %i\\n\", np, ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_led_classdev_multicolor_register_ext(dev, &led->mc_cdev,\n\t\t\t\t\t\t\t&init_data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot register LED %pOF: %i\\n\", np, ret);\n\t\treturn ret;\n\t}\n\n\treturn 1;\n}\n\n \nstatic ssize_t brightness_show(struct device *dev, struct device_attribute *a,\n\t\t\t       char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint ret;\n\n\tret = omnia_cmd_read_u8(client, CMD_LED_GET_BRIGHTNESS);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", ret);\n}\n\nstatic ssize_t brightness_store(struct device *dev, struct device_attribute *a,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned long brightness;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &brightness))\n\t\treturn -EINVAL;\n\n\tif (brightness > 100)\n\t\treturn -EINVAL;\n\n\tret = omnia_cmd_write_u8(client, CMD_LED_SET_BRIGHTNESS, brightness);\n\n\treturn ret < 0 ? ret : count;\n}\nstatic DEVICE_ATTR_RW(brightness);\n\nstatic struct attribute *omnia_led_controller_attrs[] = {\n\t&dev_attr_brightness.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(omnia_led_controller);\n\nstatic int omnia_leds_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = dev_of_node(dev), *child;\n\tstruct omnia_leds *leds;\n\tstruct omnia_led *led;\n\tint ret, count;\n\n\tcount = of_get_available_child_count(np);\n\tif (!count) {\n\t\tdev_err(dev, \"LEDs are not defined in device tree!\\n\");\n\t\treturn -ENODEV;\n\t} else if (count > OMNIA_BOARD_LEDS) {\n\t\tdev_err(dev, \"Too many LEDs defined in device tree!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tleds = devm_kzalloc(dev, struct_size(leds, leds, count), GFP_KERNEL);\n\tif (!leds)\n\t\treturn -ENOMEM;\n\n\tleds->client = client;\n\ti2c_set_clientdata(client, leds);\n\n\tmutex_init(&leds->lock);\n\n\tled = &leds->leds[0];\n\tfor_each_available_child_of_node(np, child) {\n\t\tret = omnia_led_register(client, led, child);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tled += ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void omnia_leds_remove(struct i2c_client *client)\n{\n\tu8 buf[5];\n\n\t \n\tomnia_cmd_write_u8(client, CMD_LED_MODE,\n\t\t\t   CMD_LED_MODE_LED(OMNIA_BOARD_LEDS));\n\n\t \n\tbuf[0] = CMD_LED_COLOR;\n\tbuf[1] = OMNIA_BOARD_LEDS;\n\tbuf[2] = 255;\n\tbuf[3] = 255;\n\tbuf[4] = 255;\n\n\ti2c_master_send(client, buf, 5);\n}\n\nstatic const struct of_device_id of_omnia_leds_match[] = {\n\t{ .compatible = \"cznic,turris-omnia-leds\", },\n\t{},\n};\n\nstatic const struct i2c_device_id omnia_id[] = {\n\t{ \"omnia\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, omnia_id);\n\nstatic struct i2c_driver omnia_leds_driver = {\n\t.probe\t\t= omnia_leds_probe,\n\t.remove\t\t= omnia_leds_remove,\n\t.id_table\t= omnia_id,\n\t.driver\t\t= {\n\t\t.name\t= \"leds-turris-omnia\",\n\t\t.of_match_table = of_omnia_leds_match,\n\t\t.dev_groups = omnia_led_controller_groups,\n\t},\n};\n\nmodule_i2c_driver(omnia_leds_driver);\n\nMODULE_AUTHOR(\"Marek Behun <kabel@kernel.org>\");\nMODULE_DESCRIPTION(\"CZ.NIC's Turris Omnia LEDs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}