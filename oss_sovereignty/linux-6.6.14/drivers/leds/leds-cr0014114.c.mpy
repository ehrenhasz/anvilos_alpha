{
  "module_name": "leds-cr0014114.c",
  "hash_id": "9298740cb4b12dbe4eea98e6247d9be2fe53910c9ebe2d558d68010836e25d86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-cr0014114.c",
  "human_readable_source": "\n\n\n\n#include <linux/delay.h>\n#include <linux/leds.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/workqueue.h>\n\n \n\n \n#define CR_SET_BRIGHTNESS\t0x80\n#define CR_INIT_REENUMERATE\t0x81\n#define CR_NEXT_REENUMERATE\t0x82\n\n \n#define CR_MAX_BRIGHTNESS\tGENMASK(6, 0)\n#define CR_FW_DELAY_MSEC\t10\n#define CR_RECOUNT_DELAY\t(HZ * 3600)\n\n#define CR_DEV_NAME\t\t\"cr0014114\"\n\nstruct cr0014114_led {\n\tstruct cr0014114\t*priv;\n\tstruct led_classdev\tldev;\n\tu8\t\t\tbrightness;\n};\n\nstruct cr0014114 {\n\tbool\t\t\tdo_recount;\n\tsize_t\t\t\tcount;\n\tstruct delayed_work\twork;\n\tstruct device\t\t*dev;\n\tstruct mutex\t\tlock;\n\tstruct spi_device\t*spi;\n\tu8\t\t\t*buf;\n\tunsigned long\t\tdelay;\n\tstruct cr0014114_led\tleds[];\n};\n\nstatic void cr0014114_calc_crc(u8 *buf, const size_t len)\n{\n\tsize_t\ti;\n\tu8\tcrc;\n\n\tfor (i = 1, crc = 1; i < len - 1; i++)\n\t\tcrc += buf[i];\n\tcrc |= BIT(7);\n\n\t \n\tif (crc == CR_SET_BRIGHTNESS ||\n\t    crc == CR_INIT_REENUMERATE ||\n\t    crc == CR_NEXT_REENUMERATE)\n\t\tcrc = 0xfe;\n\n\tbuf[len - 1] = crc;\n}\n\nstatic int cr0014114_recount(struct cr0014114 *priv)\n{\n\tint\tret;\n\tsize_t\ti;\n\tu8\tcmd;\n\n\tdev_dbg(priv->dev, \"LEDs recount is started\\n\");\n\n\tcmd = CR_INIT_REENUMERATE;\n\tret = spi_write(priv->spi, &cmd, sizeof(cmd));\n\tif (ret)\n\t\tgoto err;\n\n\tcmd = CR_NEXT_REENUMERATE;\n\tfor (i = 0; i < priv->count; i++) {\n\t\tmsleep(CR_FW_DELAY_MSEC);\n\n\t\tret = spi_write(priv->spi, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\nerr:\n\tdev_dbg(priv->dev, \"LEDs recount is finished\\n\");\n\n\tif (ret)\n\t\tdev_err(priv->dev, \"with error %d\", ret);\n\n\treturn ret;\n}\n\nstatic int cr0014114_sync(struct cr0014114 *priv)\n{\n\tint\t\tret;\n\tsize_t\t\ti;\n\tunsigned long\tudelay, now = jiffies;\n\n\t \n\tif (time_after(priv->delay, now)) {\n\t\tudelay = jiffies_to_usecs(priv->delay - now);\n\t\tusleep_range(udelay, udelay + 1);\n\t}\n\n\tif (unlikely(priv->do_recount)) {\n\t\tret = cr0014114_recount(priv);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tpriv->do_recount = false;\n\t\tmsleep(CR_FW_DELAY_MSEC);\n\t}\n\n\tpriv->buf[0] = CR_SET_BRIGHTNESS;\n\tfor (i = 0; i < priv->count; i++)\n\t\tpriv->buf[i + 1] = priv->leds[i].brightness;\n\tcr0014114_calc_crc(priv->buf, priv->count + 2);\n\tret = spi_write(priv->spi, priv->buf, priv->count + 2);\n\nerr:\n\tpriv->delay = jiffies + msecs_to_jiffies(CR_FW_DELAY_MSEC);\n\n\treturn ret;\n}\n\nstatic void cr0014114_recount_work(struct work_struct *work)\n{\n\tint\t\t\tret;\n\tstruct cr0014114\t*priv = container_of(work,\n\t\t\t\t\t\t     struct cr0014114,\n\t\t\t\t\t\t     work.work);\n\n\tmutex_lock(&priv->lock);\n\tpriv->do_recount = true;\n\tret = cr0014114_sync(priv);\n\tmutex_unlock(&priv->lock);\n\n\tif (ret)\n\t\tdev_warn(priv->dev, \"sync of LEDs failed %d\\n\", ret);\n\n\tschedule_delayed_work(&priv->work, CR_RECOUNT_DELAY);\n}\n\nstatic int cr0014114_set_sync(struct led_classdev *ldev,\n\t\t\t      enum led_brightness brightness)\n{\n\tint\t\t\tret;\n\tstruct cr0014114_led    *led = container_of(ldev,\n\t\t\t\t\t\t    struct cr0014114_led,\n\t\t\t\t\t\t    ldev);\n\n\tdev_dbg(led->priv->dev, \"Set brightness to %d\\n\", brightness);\n\n\tmutex_lock(&led->priv->lock);\n\tled->brightness = (u8)brightness;\n\tret = cr0014114_sync(led->priv);\n\tmutex_unlock(&led->priv->lock);\n\n\treturn ret;\n}\n\nstatic int cr0014114_probe_dt(struct cr0014114 *priv)\n{\n\tsize_t\t\t\ti = 0;\n\tstruct cr0014114_led\t*led;\n\tstruct fwnode_handle\t*child;\n\tstruct led_init_data\tinit_data = {};\n\tint\t\t\tret;\n\n\tdevice_for_each_child_node(priv->dev, child) {\n\t\tled = &priv->leds[i];\n\n\t\tled->priv\t\t\t  = priv;\n\t\tled->ldev.max_brightness\t  = CR_MAX_BRIGHTNESS;\n\t\tled->ldev.brightness_set_blocking = cr0014114_set_sync;\n\n\t\tinit_data.fwnode = child;\n\t\tinit_data.devicename = CR_DEV_NAME;\n\t\tinit_data.default_label = \":\";\n\n\t\tret = devm_led_classdev_register_ext(priv->dev, &led->ldev,\n\t\t\t\t\t\t     &init_data);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"failed to register LED device, err %d\", ret);\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int cr0014114_probe(struct spi_device *spi)\n{\n\tstruct cr0014114\t*priv;\n\tsize_t\t\t\tcount;\n\tint\t\t\tret;\n\n\tcount = device_get_child_node_count(&spi->dev);\n\tif (!count) {\n\t\tdev_err(&spi->dev, \"LEDs are not defined in device tree!\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(&spi->dev, struct_size(priv, leds, count),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->buf = devm_kzalloc(&spi->dev, count + 2, GFP_KERNEL);\n\tif (!priv->buf)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->lock);\n\tINIT_DELAYED_WORK(&priv->work, cr0014114_recount_work);\n\tpriv->count\t= count;\n\tpriv->dev\t= &spi->dev;\n\tpriv->spi\t= spi;\n\tpriv->delay\t= jiffies -\n\t\t\t  msecs_to_jiffies(CR_FW_DELAY_MSEC);\n\n\tpriv->do_recount = true;\n\tret = cr0014114_sync(priv);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"first recount failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->do_recount = true;\n\tret = cr0014114_sync(priv);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"second recount failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cr0014114_probe_dt(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tschedule_delayed_work(&priv->work, CR_RECOUNT_DELAY);\n\n\tspi_set_drvdata(spi, priv);\n\n\treturn 0;\n}\n\nstatic void cr0014114_remove(struct spi_device *spi)\n{\n\tstruct cr0014114 *priv = spi_get_drvdata(spi);\n\n\tcancel_delayed_work_sync(&priv->work);\n\tmutex_destroy(&priv->lock);\n}\n\nstatic const struct of_device_id cr0014114_dt_ids[] = {\n\t{ .compatible = \"crane,cr0014114\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, cr0014114_dt_ids);\n\nstatic struct spi_driver cr0014114_driver = {\n\t.probe\t\t= cr0014114_probe,\n\t.remove\t\t= cr0014114_remove,\n\t.driver = {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= cr0014114_dt_ids,\n\t},\n};\n\nmodule_spi_driver(cr0014114_driver);\n\nMODULE_AUTHOR(\"Oleh Kravchenko <oleg@kaa.org.ua>\");\nMODULE_DESCRIPTION(\"cr0014114 LED driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"spi:cr0014114\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}