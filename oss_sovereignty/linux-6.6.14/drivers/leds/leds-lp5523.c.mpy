{
  "module_name": "leds-lp5523.c",
  "hash_id": "19e365ade0360ac1cee08df0cdb1bf15682c963ba893032f3860265dbec30e98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lp5523.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_data/leds-lp55xx.h>\n#include <linux/slab.h>\n\n#include \"leds-lp55xx-common.h\"\n\n#define LP5523_PROGRAM_LENGTH\t\t32\t \n \n#define LP5523_MAX_LEDS\t\t\t9\n\n \n#define LP5523_REG_ENABLE\t\t0x00\n#define LP5523_REG_OP_MODE\t\t0x01\n#define LP5523_REG_ENABLE_LEDS_MSB\t0x04\n#define LP5523_REG_ENABLE_LEDS_LSB\t0x05\n#define LP5523_REG_LED_CTRL_BASE\t0x06\n#define LP5523_REG_LED_PWM_BASE\t\t0x16\n#define LP5523_REG_LED_CURRENT_BASE\t0x26\n#define LP5523_REG_CONFIG\t\t0x36\n#define LP5523_REG_STATUS\t\t0x3A\n#define LP5523_REG_RESET\t\t0x3D\n#define LP5523_REG_LED_TEST_CTRL\t0x41\n#define LP5523_REG_LED_TEST_ADC\t\t0x42\n#define LP5523_REG_MASTER_FADER_BASE\t0x48\n#define LP5523_REG_CH1_PROG_START\t0x4C\n#define LP5523_REG_CH2_PROG_START\t0x4D\n#define LP5523_REG_CH3_PROG_START\t0x4E\n#define LP5523_REG_PROG_PAGE_SEL\t0x4F\n#define LP5523_REG_PROG_MEM\t\t0x50\n\n \n#define LP5523_ENABLE\t\t\t0x40\n#define LP5523_AUTO_INC\t\t\t0x40\n#define LP5523_PWR_SAVE\t\t\t0x20\n#define LP5523_PWM_PWR_SAVE\t\t0x04\n#define LP5523_CP_MODE_MASK\t\t0x18\n#define LP5523_CP_MODE_SHIFT\t\t3\n#define LP5523_AUTO_CLK\t\t\t0x02\n#define LP5523_DEFAULT_CONFIG \\\n\t(LP5523_AUTO_INC | LP5523_PWR_SAVE | LP5523_AUTO_CLK | LP5523_PWM_PWR_SAVE)\n\n#define LP5523_EN_LEDTEST\t\t0x80\n#define LP5523_LEDTEST_DONE\t\t0x80\n#define LP5523_RESET\t\t\t0xFF\n#define LP5523_ADC_SHORTCIRC_LIM\t80\n#define LP5523_EXT_CLK_USED\t\t0x08\n#define LP5523_ENG_STATUS_MASK\t\t0x07\n\n#define LP5523_FADER_MAPPING_MASK\t0xC0\n#define LP5523_FADER_MAPPING_SHIFT\t6\n\n \n#define LP5523_PAGE_ENG1\t\t0\n#define LP5523_PAGE_ENG2\t\t1\n#define LP5523_PAGE_ENG3\t\t2\n#define LP5523_PAGE_MUX1\t\t3\n#define LP5523_PAGE_MUX2\t\t4\n#define LP5523_PAGE_MUX3\t\t5\n\n \n#define LP5523_MODE_ENG1_M\t\t0x30\t \n#define LP5523_MODE_ENG2_M\t\t0x0C\n#define LP5523_MODE_ENG3_M\t\t0x03\n#define LP5523_LOAD_ENG1\t\t0x10\n#define LP5523_LOAD_ENG2\t\t0x04\n#define LP5523_LOAD_ENG3\t\t0x01\n\n#define LP5523_ENG1_IS_LOADING(mode)\t\\\n\t((mode & LP5523_MODE_ENG1_M) == LP5523_LOAD_ENG1)\n#define LP5523_ENG2_IS_LOADING(mode)\t\\\n\t((mode & LP5523_MODE_ENG2_M) == LP5523_LOAD_ENG2)\n#define LP5523_ENG3_IS_LOADING(mode)\t\\\n\t((mode & LP5523_MODE_ENG3_M) == LP5523_LOAD_ENG3)\n\n#define LP5523_EXEC_ENG1_M\t\t0x30\t \n#define LP5523_EXEC_ENG2_M\t\t0x0C\n#define LP5523_EXEC_ENG3_M\t\t0x03\n#define LP5523_EXEC_M\t\t\t0x3F\n#define LP5523_RUN_ENG1\t\t\t0x20\n#define LP5523_RUN_ENG2\t\t\t0x08\n#define LP5523_RUN_ENG3\t\t\t0x02\n\n#define LED_ACTIVE(mux, led)\t\t(!!(mux & (0x0001 << led)))\n\nenum lp5523_chip_id {\n\tLP5523,\n\tLP55231,\n};\n\nstatic int lp5523_init_program_engine(struct lp55xx_chip *chip);\n\nstatic inline void lp5523_wait_opmode_done(void)\n{\n\tusleep_range(1000, 2000);\n}\n\nstatic void lp5523_set_led_current(struct lp55xx_led *led, u8 led_current)\n{\n\tled->led_current = led_current;\n\tlp55xx_write(led->chip, LP5523_REG_LED_CURRENT_BASE + led->chan_nr,\n\t\tled_current);\n}\n\nstatic int lp5523_post_init_device(struct lp55xx_chip *chip)\n{\n\tint ret;\n\tint val;\n\n\tret = lp55xx_write(chip, LP5523_REG_ENABLE, LP5523_ENABLE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(1000, 2000);\n\n\tval = LP5523_DEFAULT_CONFIG;\n\tval |= (chip->pdata->charge_pump_mode << LP5523_CP_MODE_SHIFT) & LP5523_CP_MODE_MASK;\n\n\tret = lp55xx_write(chip, LP5523_REG_CONFIG, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = lp55xx_write(chip, LP5523_REG_ENABLE_LEDS_MSB, 0x01);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lp55xx_write(chip, LP5523_REG_ENABLE_LEDS_LSB, 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lp5523_init_program_engine(chip);\n}\n\nstatic void lp5523_load_engine(struct lp55xx_chip *chip)\n{\n\tenum lp55xx_engine_index idx = chip->engine_idx;\n\tstatic const u8 mask[] = {\n\t\t[LP55XX_ENGINE_1] = LP5523_MODE_ENG1_M,\n\t\t[LP55XX_ENGINE_2] = LP5523_MODE_ENG2_M,\n\t\t[LP55XX_ENGINE_3] = LP5523_MODE_ENG3_M,\n\t};\n\n\tstatic const u8 val[] = {\n\t\t[LP55XX_ENGINE_1] = LP5523_LOAD_ENG1,\n\t\t[LP55XX_ENGINE_2] = LP5523_LOAD_ENG2,\n\t\t[LP55XX_ENGINE_3] = LP5523_LOAD_ENG3,\n\t};\n\n\tlp55xx_update_bits(chip, LP5523_REG_OP_MODE, mask[idx], val[idx]);\n\n\tlp5523_wait_opmode_done();\n}\n\nstatic void lp5523_load_engine_and_select_page(struct lp55xx_chip *chip)\n{\n\tenum lp55xx_engine_index idx = chip->engine_idx;\n\tstatic const u8 page_sel[] = {\n\t\t[LP55XX_ENGINE_1] = LP5523_PAGE_ENG1,\n\t\t[LP55XX_ENGINE_2] = LP5523_PAGE_ENG2,\n\t\t[LP55XX_ENGINE_3] = LP5523_PAGE_ENG3,\n\t};\n\n\tlp5523_load_engine(chip);\n\n\tlp55xx_write(chip, LP5523_REG_PROG_PAGE_SEL, page_sel[idx]);\n}\n\nstatic void lp5523_stop_all_engines(struct lp55xx_chip *chip)\n{\n\tlp55xx_write(chip, LP5523_REG_OP_MODE, 0);\n\tlp5523_wait_opmode_done();\n}\n\nstatic void lp5523_stop_engine(struct lp55xx_chip *chip)\n{\n\tenum lp55xx_engine_index idx = chip->engine_idx;\n\tstatic const u8 mask[] = {\n\t\t[LP55XX_ENGINE_1] = LP5523_MODE_ENG1_M,\n\t\t[LP55XX_ENGINE_2] = LP5523_MODE_ENG2_M,\n\t\t[LP55XX_ENGINE_3] = LP5523_MODE_ENG3_M,\n\t};\n\n\tlp55xx_update_bits(chip, LP5523_REG_OP_MODE, mask[idx], 0);\n\n\tlp5523_wait_opmode_done();\n}\n\nstatic void lp5523_turn_off_channels(struct lp55xx_chip *chip)\n{\n\tint i;\n\n\tfor (i = 0; i < LP5523_MAX_LEDS; i++)\n\t\tlp55xx_write(chip, LP5523_REG_LED_PWM_BASE + i, 0);\n}\n\nstatic void lp5523_run_engine(struct lp55xx_chip *chip, bool start)\n{\n\tint ret;\n\tu8 mode;\n\tu8 exec;\n\n\t \n\tif (!start) {\n\t\tlp5523_stop_engine(chip);\n\t\tlp5523_turn_off_channels(chip);\n\t\treturn;\n\t}\n\n\t \n\n\tret = lp55xx_read(chip, LP5523_REG_OP_MODE, &mode);\n\tif (ret)\n\t\treturn;\n\n\tret = lp55xx_read(chip, LP5523_REG_ENABLE, &exec);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (LP5523_ENG1_IS_LOADING(mode)) {\n\t\tmode = (mode & ~LP5523_MODE_ENG1_M) | LP5523_RUN_ENG1;\n\t\texec = (exec & ~LP5523_EXEC_ENG1_M) | LP5523_RUN_ENG1;\n\t}\n\n\tif (LP5523_ENG2_IS_LOADING(mode)) {\n\t\tmode = (mode & ~LP5523_MODE_ENG2_M) | LP5523_RUN_ENG2;\n\t\texec = (exec & ~LP5523_EXEC_ENG2_M) | LP5523_RUN_ENG2;\n\t}\n\n\tif (LP5523_ENG3_IS_LOADING(mode)) {\n\t\tmode = (mode & ~LP5523_MODE_ENG3_M) | LP5523_RUN_ENG3;\n\t\texec = (exec & ~LP5523_EXEC_ENG3_M) | LP5523_RUN_ENG3;\n\t}\n\n\tlp55xx_write(chip, LP5523_REG_OP_MODE, mode);\n\tlp5523_wait_opmode_done();\n\n\tlp55xx_update_bits(chip, LP5523_REG_ENABLE, LP5523_EXEC_M, exec);\n}\n\nstatic int lp5523_init_program_engine(struct lp55xx_chip *chip)\n{\n\tint i;\n\tint j;\n\tint ret;\n\tu8 status;\n\t \n\tstatic const u8 pattern[][LP5523_PROGRAM_LENGTH] =  {\n\t\t{ 0x9c, 0x30, 0x9c, 0xb0, 0x9d, 0x80, 0xd8, 0x00, 0},\n\t\t{ 0x9c, 0x40, 0x9c, 0xc0, 0x9d, 0x80, 0xd8, 0x00, 0},\n\t\t{ 0x9c, 0x50, 0x9c, 0xd0, 0x9d, 0x80, 0xd8, 0x00, 0},\n\t};\n\n\t \n\tret = lp55xx_write(chip, LP5523_REG_CH1_PROG_START, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lp55xx_write(chip, LP5523_REG_CH2_PROG_START, 0x10);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lp55xx_write(chip, LP5523_REG_CH3_PROG_START, 0x20);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = LP55XX_ENGINE_1; i <= LP55XX_ENGINE_3; i++) {\n\t\tchip->engine_idx = i;\n\t\tlp5523_load_engine_and_select_page(chip);\n\n\t\tfor (j = 0; j < LP5523_PROGRAM_LENGTH; j++) {\n\t\t\tret = lp55xx_write(chip, LP5523_REG_PROG_MEM + j,\n\t\t\t\t\tpattern[i - 1][j]);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlp5523_run_engine(chip, true);\n\n\t \n\tusleep_range(3000, 6000);\n\tret = lp55xx_read(chip, LP5523_REG_STATUS, &status);\n\tif (ret)\n\t\tgoto out;\n\tstatus &= LP5523_ENG_STATUS_MASK;\n\n\tif (status != LP5523_ENG_STATUS_MASK) {\n\t\tdev_err(&chip->cl->dev,\n\t\t\t\"could not configure LED engine, status = 0x%.2x\\n\",\n\t\t\tstatus);\n\t\tret = -1;\n\t}\n\nout:\n\tlp5523_stop_all_engines(chip);\n\treturn ret;\n}\n\nstatic int lp5523_update_program_memory(struct lp55xx_chip *chip,\n\t\t\t\t\tconst u8 *data, size_t size)\n{\n\tu8 pattern[LP5523_PROGRAM_LENGTH] = {0};\n\tunsigned int cmd;\n\tchar c[3];\n\tint nrchars;\n\tint ret;\n\tint offset = 0;\n\tint i = 0;\n\n\twhile ((offset < size - 1) && (i < LP5523_PROGRAM_LENGTH)) {\n\t\t \n\t\tret = sscanf(data + offset, \"%2s%n \", c, &nrchars);\n\t\tif (ret != 1)\n\t\t\tgoto err;\n\n\t\tret = sscanf(c, \"%2x\", &cmd);\n\t\tif (ret != 1)\n\t\t\tgoto err;\n\n\t\tpattern[i] = (u8)cmd;\n\t\toffset += nrchars;\n\t\ti++;\n\t}\n\n\t \n\tif (i % 2)\n\t\tgoto err;\n\n\tfor (i = 0; i < LP5523_PROGRAM_LENGTH; i++) {\n\t\tret = lp55xx_write(chip, LP5523_REG_PROG_MEM + i, pattern[i]);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn size;\n\nerr:\n\tdev_err(&chip->cl->dev, \"wrong pattern format\\n\");\n\treturn -EINVAL;\n}\n\nstatic void lp5523_firmware_loaded(struct lp55xx_chip *chip)\n{\n\tconst struct firmware *fw = chip->fw;\n\n\tif (fw->size > LP5523_PROGRAM_LENGTH) {\n\t\tdev_err(&chip->cl->dev, \"firmware data size overflow: %zu\\n\",\n\t\t\tfw->size);\n\t\treturn;\n\t}\n\n\t \n\n\tlp5523_load_engine_and_select_page(chip);\n\tlp5523_update_program_memory(chip, fw->data, fw->size);\n}\n\nstatic ssize_t show_engine_mode(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf, int nr)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tenum lp55xx_engine_mode mode = chip->engines[nr - 1].mode;\n\n\tswitch (mode) {\n\tcase LP55XX_ENGINE_RUN:\n\t\treturn sprintf(buf, \"run\\n\");\n\tcase LP55XX_ENGINE_LOAD:\n\t\treturn sprintf(buf, \"load\\n\");\n\tcase LP55XX_ENGINE_DISABLED:\n\tdefault:\n\t\treturn sprintf(buf, \"disabled\\n\");\n\t}\n}\nshow_mode(1)\nshow_mode(2)\nshow_mode(3)\n\nstatic ssize_t store_engine_mode(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t len, int nr)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tstruct lp55xx_engine *engine = &chip->engines[nr - 1];\n\n\tmutex_lock(&chip->lock);\n\n\tchip->engine_idx = nr;\n\n\tif (!strncmp(buf, \"run\", 3)) {\n\t\tlp5523_run_engine(chip, true);\n\t\tengine->mode = LP55XX_ENGINE_RUN;\n\t} else if (!strncmp(buf, \"load\", 4)) {\n\t\tlp5523_stop_engine(chip);\n\t\tlp5523_load_engine(chip);\n\t\tengine->mode = LP55XX_ENGINE_LOAD;\n\t} else if (!strncmp(buf, \"disabled\", 8)) {\n\t\tlp5523_stop_engine(chip);\n\t\tengine->mode = LP55XX_ENGINE_DISABLED;\n\t}\n\n\tmutex_unlock(&chip->lock);\n\n\treturn len;\n}\nstore_mode(1)\nstore_mode(2)\nstore_mode(3)\n\nstatic int lp5523_mux_parse(const char *buf, u16 *mux, size_t len)\n{\n\tu16 tmp_mux = 0;\n\tint i;\n\n\tlen = min_t(int, len, LP5523_MAX_LEDS);\n\n\tfor (i = 0; i < len; i++) {\n\t\tswitch (buf[i]) {\n\t\tcase '1':\n\t\t\ttmp_mux |= (1 << i);\n\t\t\tbreak;\n\t\tcase '0':\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\ti = len;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\t*mux = tmp_mux;\n\n\treturn 0;\n}\n\nstatic void lp5523_mux_to_array(u16 led_mux, char *array)\n{\n\tint i, pos = 0;\n\n\tfor (i = 0; i < LP5523_MAX_LEDS; i++)\n\t\tpos += sprintf(array + pos, \"%x\", LED_ACTIVE(led_mux, i));\n\n\tarray[pos] = '\\0';\n}\n\nstatic ssize_t show_engine_leds(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf, int nr)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tchar mux[LP5523_MAX_LEDS + 1];\n\n\tlp5523_mux_to_array(chip->engines[nr - 1].led_mux, mux);\n\n\treturn sprintf(buf, \"%s\\n\", mux);\n}\nshow_leds(1)\nshow_leds(2)\nshow_leds(3)\n\nstatic int lp5523_load_mux(struct lp55xx_chip *chip, u16 mux, int nr)\n{\n\tstruct lp55xx_engine *engine = &chip->engines[nr - 1];\n\tint ret;\n\tstatic const u8 mux_page[] = {\n\t\t[LP55XX_ENGINE_1] = LP5523_PAGE_MUX1,\n\t\t[LP55XX_ENGINE_2] = LP5523_PAGE_MUX2,\n\t\t[LP55XX_ENGINE_3] = LP5523_PAGE_MUX3,\n\t};\n\n\tlp5523_load_engine(chip);\n\n\tret = lp55xx_write(chip, LP5523_REG_PROG_PAGE_SEL, mux_page[nr]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lp55xx_write(chip, LP5523_REG_PROG_MEM, (u8)(mux >> 8));\n\tif (ret)\n\t\treturn ret;\n\n\tret = lp55xx_write(chip, LP5523_REG_PROG_MEM + 1, (u8)(mux));\n\tif (ret)\n\t\treturn ret;\n\n\tengine->led_mux = mux;\n\treturn 0;\n}\n\nstatic ssize_t store_engine_leds(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t len, int nr)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tstruct lp55xx_engine *engine = &chip->engines[nr - 1];\n\tu16 mux = 0;\n\tssize_t ret;\n\n\tif (lp5523_mux_parse(buf, &mux, len))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->lock);\n\n\tchip->engine_idx = nr;\n\tret = -EINVAL;\n\n\tif (engine->mode != LP55XX_ENGINE_LOAD)\n\t\tgoto leave;\n\n\tif (lp5523_load_mux(chip, mux, nr))\n\t\tgoto leave;\n\n\tret = len;\nleave:\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\nstore_leds(1)\nstore_leds(2)\nstore_leds(3)\n\nstatic ssize_t store_engine_load(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t len, int nr)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\n\tchip->engine_idx = nr;\n\tlp5523_load_engine_and_select_page(chip);\n\tret = lp5523_update_program_memory(chip, buf, len);\n\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\nstore_load(1)\nstore_load(2)\nstore_load(3)\n\nstatic ssize_t lp5523_selftest(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tstruct lp55xx_platform_data *pdata = chip->pdata;\n\tint ret, pos = 0;\n\tu8 status, adc, vdd, i;\n\n\tmutex_lock(&chip->lock);\n\n\tret = lp55xx_read(chip, LP5523_REG_STATUS, &status);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t \n\tif (pdata->clock_mode == LP55XX_CLOCK_EXT) {\n\t\tif  ((status & LP5523_EXT_CLK_USED) == 0)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tlp55xx_write(chip, LP5523_REG_LED_TEST_CTRL, LP5523_EN_LEDTEST | 16);\n\tusleep_range(3000, 6000);  \n\tret = lp55xx_read(chip, LP5523_REG_STATUS, &status);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (!(status & LP5523_LEDTEST_DONE))\n\t\tusleep_range(3000, 6000);  \n\n\tret = lp55xx_read(chip, LP5523_REG_LED_TEST_ADC, &vdd);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tvdd--;\t \n\n\tfor (i = 0; i < pdata->num_channels; i++) {\n\t\t \n\t\tif (pdata->led_config[i].led_current == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tlp55xx_write(chip, LP5523_REG_LED_CURRENT_BASE + led->chan_nr,\n\t\t\tpdata->led_config[i].led_current);\n\n\t\tlp55xx_write(chip, LP5523_REG_LED_PWM_BASE + led->chan_nr,\n\t\t\t     0xff);\n\t\t \n\t\tusleep_range(2000, 4000);\n\t\tlp55xx_write(chip, LP5523_REG_LED_TEST_CTRL,\n\t\t\t     LP5523_EN_LEDTEST | led->chan_nr);\n\t\t \n\t\tusleep_range(3000, 6000);\n\t\tret = lp55xx_read(chip, LP5523_REG_STATUS, &status);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\n\t\tif (!(status & LP5523_LEDTEST_DONE))\n\t\t\tusleep_range(3000, 6000);  \n\n\t\tret = lp55xx_read(chip, LP5523_REG_LED_TEST_ADC, &adc);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\n\t\tif (adc >= vdd || adc < LP5523_ADC_SHORTCIRC_LIM)\n\t\t\tpos += sprintf(buf + pos, \"LED %d FAIL\\n\",\n\t\t\t\t       led->chan_nr);\n\n\t\tlp55xx_write(chip, LP5523_REG_LED_PWM_BASE + led->chan_nr,\n\t\t\t     0x00);\n\n\t\t \n\t\tlp55xx_write(chip, LP5523_REG_LED_CURRENT_BASE + led->chan_nr,\n\t\t\t     led->led_current);\n\t\tled++;\n\t}\n\tif (pos == 0)\n\t\tpos = sprintf(buf, \"OK\\n\");\n\tgoto release_lock;\nfail:\n\tpos = sprintf(buf, \"FAIL\\n\");\n\nrelease_lock:\n\tmutex_unlock(&chip->lock);\n\n\treturn pos;\n}\n\n#define show_fader(nr)\t\t\t\t\t\t\\\nstatic ssize_t show_master_fader##nr(struct device *dev,\t\\\n\t\t\t    struct device_attribute *attr,\t\\\n\t\t\t    char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn show_master_fader(dev, attr, buf, nr);\t\t\\\n}\n\n#define store_fader(nr)\t\t\t\t\t\t\\\nstatic ssize_t store_master_fader##nr(struct device *dev,\t\\\n\t\t\t     struct device_attribute *attr,\t\\\n\t\t\t     const char *buf, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn store_master_fader(dev, attr, buf, len, nr);\t\\\n}\n\nstatic ssize_t show_master_fader(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf, int nr)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tint ret;\n\tu8 val;\n\n\tmutex_lock(&chip->lock);\n\tret = lp55xx_read(chip, LP5523_REG_MASTER_FADER_BASE + nr - 1, &val);\n\tmutex_unlock(&chip->lock);\n\n\tif (ret == 0)\n\t\tret = sprintf(buf, \"%u\\n\", val);\n\n\treturn ret;\n}\nshow_fader(1)\nshow_fader(2)\nshow_fader(3)\n\nstatic ssize_t store_master_fader(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len, int nr)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tint ret;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 0xff)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->lock);\n\tret = lp55xx_write(chip, LP5523_REG_MASTER_FADER_BASE + nr - 1,\n\t\t\t   (u8)val);\n\tmutex_unlock(&chip->lock);\n\n\tif (ret == 0)\n\t\tret = len;\n\n\treturn ret;\n}\nstore_fader(1)\nstore_fader(2)\nstore_fader(3)\n\nstatic ssize_t show_master_fader_leds(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tint i, ret, pos = 0;\n\tu8 val;\n\n\tmutex_lock(&chip->lock);\n\n\tfor (i = 0; i < LP5523_MAX_LEDS; i++) {\n\t\tret = lp55xx_read(chip, LP5523_REG_LED_CTRL_BASE + i, &val);\n\t\tif (ret)\n\t\t\tgoto leave;\n\n\t\tval = (val & LP5523_FADER_MAPPING_MASK)\n\t\t\t>> LP5523_FADER_MAPPING_SHIFT;\n\t\tif (val > 3) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto leave;\n\t\t}\n\t\tbuf[pos++] = val + '0';\n\t}\n\tbuf[pos++] = '\\n';\n\tret = pos;\nleave:\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nstatic ssize_t store_master_fader_leds(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t len)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lp55xx_chip *chip = led->chip;\n\tint i, n, ret;\n\tu8 val;\n\n\tn = min_t(int, len, LP5523_MAX_LEDS);\n\n\tmutex_lock(&chip->lock);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (buf[i] >= '0' && buf[i] <= '3') {\n\t\t\tval = (buf[i] - '0') << LP5523_FADER_MAPPING_SHIFT;\n\t\t\tret = lp55xx_update_bits(chip,\n\t\t\t\t\t\t LP5523_REG_LED_CTRL_BASE + i,\n\t\t\t\t\t\t LP5523_FADER_MAPPING_MASK,\n\t\t\t\t\t\t val);\n\t\t\tif (ret)\n\t\t\t\tgoto leave;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tgoto leave;\n\t\t}\n\t}\n\tret = len;\nleave:\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nstatic int lp5523_multicolor_brightness(struct lp55xx_led *led)\n{\n\tstruct lp55xx_chip *chip = led->chip;\n\tint ret;\n\tint i;\n\n\tmutex_lock(&chip->lock);\n\tfor (i = 0; i < led->mc_cdev.num_colors; i++) {\n\t\tret = lp55xx_write(chip,\n\t\t\t\t   LP5523_REG_LED_PWM_BASE +\n\t\t\t\t   led->mc_cdev.subled_info[i].channel,\n\t\t\t\t   led->mc_cdev.subled_info[i].brightness);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nstatic int lp5523_led_brightness(struct lp55xx_led *led)\n{\n\tstruct lp55xx_chip *chip = led->chip;\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\tret = lp55xx_write(chip, LP5523_REG_LED_PWM_BASE + led->chan_nr,\n\t\t     led->brightness);\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nstatic LP55XX_DEV_ATTR_RW(engine1_mode, show_engine1_mode, store_engine1_mode);\nstatic LP55XX_DEV_ATTR_RW(engine2_mode, show_engine2_mode, store_engine2_mode);\nstatic LP55XX_DEV_ATTR_RW(engine3_mode, show_engine3_mode, store_engine3_mode);\nstatic LP55XX_DEV_ATTR_RW(engine1_leds, show_engine1_leds, store_engine1_leds);\nstatic LP55XX_DEV_ATTR_RW(engine2_leds, show_engine2_leds, store_engine2_leds);\nstatic LP55XX_DEV_ATTR_RW(engine3_leds, show_engine3_leds, store_engine3_leds);\nstatic LP55XX_DEV_ATTR_WO(engine1_load, store_engine1_load);\nstatic LP55XX_DEV_ATTR_WO(engine2_load, store_engine2_load);\nstatic LP55XX_DEV_ATTR_WO(engine3_load, store_engine3_load);\nstatic LP55XX_DEV_ATTR_RO(selftest, lp5523_selftest);\nstatic LP55XX_DEV_ATTR_RW(master_fader1, show_master_fader1,\n\t\t\t  store_master_fader1);\nstatic LP55XX_DEV_ATTR_RW(master_fader2, show_master_fader2,\n\t\t\t  store_master_fader2);\nstatic LP55XX_DEV_ATTR_RW(master_fader3, show_master_fader3,\n\t\t\t  store_master_fader3);\nstatic LP55XX_DEV_ATTR_RW(master_fader_leds, show_master_fader_leds,\n\t\t\t  store_master_fader_leds);\n\nstatic struct attribute *lp5523_attributes[] = {\n\t&dev_attr_engine1_mode.attr,\n\t&dev_attr_engine2_mode.attr,\n\t&dev_attr_engine3_mode.attr,\n\t&dev_attr_engine1_load.attr,\n\t&dev_attr_engine2_load.attr,\n\t&dev_attr_engine3_load.attr,\n\t&dev_attr_engine1_leds.attr,\n\t&dev_attr_engine2_leds.attr,\n\t&dev_attr_engine3_leds.attr,\n\t&dev_attr_selftest.attr,\n\t&dev_attr_master_fader1.attr,\n\t&dev_attr_master_fader2.attr,\n\t&dev_attr_master_fader3.attr,\n\t&dev_attr_master_fader_leds.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group lp5523_group = {\n\t.attrs = lp5523_attributes,\n};\n\n \nstatic struct lp55xx_device_config lp5523_cfg = {\n\t.reset = {\n\t\t.addr = LP5523_REG_RESET,\n\t\t.val  = LP5523_RESET,\n\t},\n\t.enable = {\n\t\t.addr = LP5523_REG_ENABLE,\n\t\t.val  = LP5523_ENABLE,\n\t},\n\t.max_channel  = LP5523_MAX_LEDS,\n\t.post_init_device   = lp5523_post_init_device,\n\t.brightness_fn      = lp5523_led_brightness,\n\t.multicolor_brightness_fn = lp5523_multicolor_brightness,\n\t.set_led_current    = lp5523_set_led_current,\n\t.firmware_cb        = lp5523_firmware_loaded,\n\t.run_engine         = lp5523_run_engine,\n\t.dev_attr_group     = &lp5523_group,\n};\n\nstatic int lp5523_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tint ret;\n\tstruct lp55xx_chip *chip;\n\tstruct lp55xx_led *led;\n\tstruct lp55xx_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct device_node *np = dev_of_node(&client->dev);\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->cfg = &lp5523_cfg;\n\n\tif (!pdata) {\n\t\tif (np) {\n\t\t\tpdata = lp55xx_of_populate_pdata(&client->dev, np,\n\t\t\t\t\t\t\t chip);\n\t\t\tif (IS_ERR(pdata))\n\t\t\t\treturn PTR_ERR(pdata);\n\t\t} else {\n\t\t\tdev_err(&client->dev, \"no platform data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tled = devm_kcalloc(&client->dev,\n\t\t\tpdata->num_channels, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tchip->cl = client;\n\tchip->pdata = pdata;\n\n\tmutex_init(&chip->lock);\n\n\ti2c_set_clientdata(client, led);\n\n\tret = lp55xx_init_device(chip);\n\tif (ret)\n\t\tgoto err_init;\n\n\tdev_info(&client->dev, \"%s Programmable led chip found\\n\", id->name);\n\n\tret = lp55xx_register_leds(led, chip);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = lp55xx_register_sysfs(chip);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"registering sysfs failed\\n\");\n\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tlp55xx_deinit_device(chip);\nerr_init:\n\treturn ret;\n}\n\nstatic void lp5523_remove(struct i2c_client *client)\n{\n\tstruct lp55xx_led *led = i2c_get_clientdata(client);\n\tstruct lp55xx_chip *chip = led->chip;\n\n\tlp5523_stop_all_engines(chip);\n\tlp55xx_unregister_sysfs(chip);\n\tlp55xx_deinit_device(chip);\n}\n\nstatic const struct i2c_device_id lp5523_id[] = {\n\t{ \"lp5523\",  LP5523 },\n\t{ \"lp55231\", LP55231 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, lp5523_id);\n\nstatic const struct of_device_id of_lp5523_leds_match[] = {\n\t{ .compatible = \"national,lp5523\", },\n\t{ .compatible = \"ti,lp55231\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, of_lp5523_leds_match);\n\nstatic struct i2c_driver lp5523_driver = {\n\t.driver = {\n\t\t.name\t= \"lp5523x\",\n\t\t.of_match_table = of_lp5523_leds_match,\n\t},\n\t.probe\t\t= lp5523_probe,\n\t.remove\t\t= lp5523_remove,\n\t.id_table\t= lp5523_id,\n};\n\nmodule_i2c_driver(lp5523_driver);\n\nMODULE_AUTHOR(\"Mathias Nyman <mathias.nyman@nokia.com>\");\nMODULE_AUTHOR(\"Milo Kim <milo.kim@ti.com>\");\nMODULE_DESCRIPTION(\"LP5523 LED engine\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}