{
  "module_name": "leds-blinkm.c",
  "hash_id": "ce25b02fd27c973cd09d8fe6d9dfe3154f54c12396fdf19ab4c954591f11830f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-blinkm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/printk.h>\n#include <linux/pm_runtime.h>\n#include <linux/leds.h>\n#include <linux/delay.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x09, I2C_CLIENT_END };\n\nstatic int blinkm_transfer_hw(struct i2c_client *client, int cmd);\nstatic int blinkm_test_run(struct i2c_client *client);\n\nstruct blinkm_led {\n\tstruct i2c_client *i2c_client;\n\tstruct led_classdev led_cdev;\n\tint id;\n};\n\n#define cdev_to_blmled(c)          container_of(c, struct blinkm_led, led_cdev)\n\nstruct blinkm_data {\n\tstruct i2c_client *i2c_client;\n\tstruct mutex update_lock;\n\t \n\tstruct blinkm_led blinkm_leds[3];\n\t \n\tu8 red;\t\t\t \n\tu8 green;\t\t \n\tu8 blue;\t\t \n\t \n\tu8 next_red;\t\t\t \n\tu8 next_green;\t\t \n\tu8 next_blue;\t\t \n\t \n\tu8 args[7];\t\t \n\tu8 i2c_addr;\t\t \n\tu8 fw_ver;\t\t \n\t \n\tu8 hue;\t\t\t \n\tu8 saturation;\t\t \n\tu8 brightness;\t\t \n\tu8 next_hue;\t\t\t \n\tu8 next_saturation;\t\t \n\tu8 next_brightness;\t\t \n\t \n\tu8 fade_speed;\t\t \n\ts8 time_adjust;\t\t \n\tu8 fade:1;\t\t \n\tu8 rand:1;\t\t \n\tu8 script_id;\t\t \n\tu8 script_repeats;\t \n\tu8 script_startline;\t \n};\n\n \n#define RED   0\n#define GREEN 1\n#define BLUE  2\n\n \n#define BLM_GO_RGB            0\n#define BLM_FADE_RGB          1\n#define BLM_FADE_HSB          2\n#define BLM_FADE_RAND_RGB     3\n#define BLM_FADE_RAND_HSB     4\n#define BLM_PLAY_SCRIPT       5\n#define BLM_STOP_SCRIPT       6\n#define BLM_SET_FADE_SPEED    7\n#define BLM_SET_TIME_ADJ      8\n#define BLM_GET_CUR_RGB       9\n#define BLM_WRITE_SCRIPT_LINE 10\n#define BLM_READ_SCRIPT_LINE  11\n#define BLM_SET_SCRIPT_LR     12\t \n#define BLM_SET_ADDR          13\n#define BLM_GET_ADDR          14\n#define BLM_GET_FW_VER        15\n#define BLM_SET_STARTUP_PARAM 16\n\n \nstatic const struct {\n\tchar cmdchar;\n\tu8 cmdbyte;\n\tu8 nr_args;\n\tu8 nr_ret;\n\tu8 dir:2;\n} blinkm_cmds[17] = {\n   \n\t{ 'n', 0x6e, 3, 0, 1},\n\t{ 'c', 0x63, 3, 0, 1},\n\t{ 'h', 0x68, 3, 0, 1},\n\t{ 'C', 0x43, 3, 0, 1},\n\t{ 'H', 0x48, 3, 0, 1},\n\t{ 'p', 0x70, 3, 0, 1},\n\t{ 'o', 0x6f, 0, 0, 1},\n\t{ 'f', 0x66, 1, 0, 1},\n\t{ 't', 0x74, 1, 0, 1},\n\t{ 'g', 0x67, 0, 3, 0},\n\t{ 'W', 0x57, 7, 0, 1},\n\t{ 'R', 0x52, 2, 5, 2},\n\t{ 'L', 0x4c, 3, 0, 1},\n\t{ 'A', 0x41, 4, 0, 1},\n\t{ 'a', 0x61, 0, 1, 0},\n\t{ 'Z', 0x5a, 0, 1, 0},\n\t{ 'B', 0x42, 5, 0, 1},\n};\n\nstatic ssize_t show_color_common(struct device *dev, char *buf, int color)\n{\n\tstruct i2c_client *client;\n\tstruct blinkm_data *data;\n\tint ret;\n\n\tclient = to_i2c_client(dev);\n\tdata = i2c_get_clientdata(client);\n\n\tret = blinkm_transfer_hw(client, BLM_GET_CUR_RGB);\n\tif (ret < 0)\n\t\treturn ret;\n\tswitch (color) {\n\tcase RED:\n\t\treturn sysfs_emit(buf, \"%02X\\n\", data->red);\n\tcase GREEN:\n\t\treturn sysfs_emit(buf, \"%02X\\n\", data->green);\n\tcase BLUE:\n\t\treturn sysfs_emit(buf, \"%02X\\n\", data->blue);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int store_color_common(struct device *dev, const char *buf, int color)\n{\n\tstruct i2c_client *client;\n\tstruct blinkm_data *data;\n\tint ret;\n\tu8 value;\n\n\tclient = to_i2c_client(dev);\n\tdata = i2c_get_clientdata(client);\n\n\tret = kstrtou8(buf, 10, &value);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"BlinkM: value too large!\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (color) {\n\tcase RED:\n\t\tdata->next_red = value;\n\t\tbreak;\n\tcase GREEN:\n\t\tdata->next_green = value;\n\t\tbreak;\n\tcase BLUE:\n\t\tdata->next_blue = value;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"next_red = %d, next_green = %d, next_blue = %d\\n\",\n\t\t\tdata->next_red, data->next_green, data->next_blue);\n\n\t \n\tret = blinkm_transfer_hw(client, BLM_GO_RGB);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"BlinkM: can't set RGB\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t red_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\treturn show_color_common(dev, buf, RED);\n}\n\nstatic ssize_t red_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tint ret;\n\n\tret = store_color_common(dev, buf, RED);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(red);\n\nstatic ssize_t green_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\treturn show_color_common(dev, buf, GREEN);\n}\n\nstatic ssize_t green_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\n\tint ret;\n\n\tret = store_color_common(dev, buf, GREEN);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(green);\n\nstatic ssize_t blue_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\treturn show_color_common(dev, buf, BLUE);\n}\n\nstatic ssize_t blue_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tint ret;\n\n\tret = store_color_common(dev, buf, BLUE);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(blue);\n\nstatic ssize_t test_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf,\n\t\t\t \"#Write into test to start test sequence!#\\n\");\n}\n\nstatic ssize_t test_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\n\tstruct i2c_client *client;\n\tint ret;\n\tclient = to_i2c_client(dev);\n\n\t \n\tret = blinkm_test_run(client);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(test);\n\n \n\nstatic struct attribute *blinkm_attrs[] = {\n\t&dev_attr_red.attr,\n\t&dev_attr_green.attr,\n\t&dev_attr_blue.attr,\n\t&dev_attr_test.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group blinkm_group = {\n\t.name = \"blinkm\",\n\t.attrs = blinkm_attrs,\n};\n\nstatic int blinkm_write(struct i2c_client *client, int cmd, u8 *arg)\n{\n\tint result;\n\tint i;\n\tint arglen = blinkm_cmds[cmd].nr_args;\n\t \n\tresult = i2c_smbus_write_byte(client, blinkm_cmds[cmd].cmdbyte);\n\tif (result < 0)\n\t\treturn result;\n\t \n\tif (arglen == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < arglen; i++) {\n\t\t \n\t\tresult = i2c_smbus_write_byte(client, arg[i]);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t}\n\treturn 0;\n}\n\nstatic int blinkm_read(struct i2c_client *client, int cmd, u8 *arg)\n{\n\tint result;\n\tint i;\n\tint retlen = blinkm_cmds[cmd].nr_ret;\n\tfor (i = 0; i < retlen; i++) {\n\t\t \n\t\tresult = i2c_smbus_read_byte(client);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\targ[i] = result;\n\t}\n\n\treturn 0;\n}\n\nstatic int blinkm_transfer_hw(struct i2c_client *client, int cmd)\n{\n\t \n\n\t \n\tstruct blinkm_data *data = i2c_get_clientdata(client);\n\n\t \n\tif (mutex_lock_interruptible(&data->update_lock) < 0)\n\t\treturn -EAGAIN;\n\n\t \n\tswitch (cmd) {\n\tcase BLM_FADE_RAND_RGB:\n\tcase BLM_GO_RGB:\n\tcase BLM_FADE_RGB:\n\t\tdata->args[0] = data->next_red;\n\t\tdata->args[1] = data->next_green;\n\t\tdata->args[2] = data->next_blue;\n\t\tblinkm_write(client, cmd, data->args);\n\t\tdata->red = data->args[0];\n\t\tdata->green = data->args[1];\n\t\tdata->blue = data->args[2];\n\t\tbreak;\n\tcase BLM_FADE_HSB:\n\tcase BLM_FADE_RAND_HSB:\n\t\tdata->args[0] = data->next_hue;\n\t\tdata->args[1] = data->next_saturation;\n\t\tdata->args[2] = data->next_brightness;\n\t\tblinkm_write(client, cmd, data->args);\n\t\tdata->hue = data->next_hue;\n\t\tdata->saturation = data->next_saturation;\n\t\tdata->brightness = data->next_brightness;\n\t\tbreak;\n\tcase BLM_PLAY_SCRIPT:\n\t\tdata->args[0] = data->script_id;\n\t\tdata->args[1] = data->script_repeats;\n\t\tdata->args[2] = data->script_startline;\n\t\tblinkm_write(client, cmd, data->args);\n\t\tbreak;\n\tcase BLM_STOP_SCRIPT:\n\t\tblinkm_write(client, cmd, NULL);\n\t\tbreak;\n\tcase BLM_GET_CUR_RGB:\n\t\tdata->args[0] = data->red;\n\t\tdata->args[1] = data->green;\n\t\tdata->args[2] = data->blue;\n\t\tblinkm_write(client, cmd, NULL);\n\t\tblinkm_read(client, cmd, data->args);\n\t\tdata->red = data->args[0];\n\t\tdata->green = data->args[1];\n\t\tdata->blue = data->args[2];\n\t\tbreak;\n\tcase BLM_GET_ADDR:\n\t\tdata->args[0] = data->i2c_addr;\n\t\tblinkm_write(client, cmd, NULL);\n\t\tblinkm_read(client, cmd, data->args);\n\t\tdata->i2c_addr = data->args[0];\n\t\tbreak;\n\tcase BLM_SET_TIME_ADJ:\n\tcase BLM_SET_FADE_SPEED:\n\tcase BLM_READ_SCRIPT_LINE:\n\tcase BLM_WRITE_SCRIPT_LINE:\n\tcase BLM_SET_SCRIPT_LR:\n\tcase BLM_SET_ADDR:\n\tcase BLM_GET_FW_VER:\n\tcase BLM_SET_STARTUP_PARAM:\n\t\tdev_err(&client->dev,\n\t\t\t\t\"BlinkM: cmd %d not implemented yet.\\n\", cmd);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"BlinkM: unknown command %d\\n\", cmd);\n\t\tmutex_unlock(&data->update_lock);\n\t\treturn -EINVAL;\n\t}\t\t\t \n\n\t \n\tmutex_unlock(&data->update_lock);\n\treturn 0;\n}\n\nstatic int blinkm_led_common_set(struct led_classdev *led_cdev,\n\t\t\t\t enum led_brightness value, int color)\n{\n\t \n\tstruct blinkm_led *led = cdev_to_blmled(led_cdev);\n\tstruct blinkm_data *data = i2c_get_clientdata(led->i2c_client);\n\n\tswitch (color) {\n\tcase RED:\n\t\t \n\t\tif (data->next_red == (u8) value)\n\t\t\treturn 0;\n\t\tdata->next_red = (u8) value;\n\t\tbreak;\n\tcase GREEN:\n\t\t \n\t\tif (data->next_green == (u8) value)\n\t\t\treturn 0;\n\t\tdata->next_green = (u8) value;\n\t\tbreak;\n\tcase BLUE:\n\t\t \n\t\tif (data->next_blue == (u8) value)\n\t\t\treturn 0;\n\t\tdata->next_blue = (u8) value;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&led->i2c_client->dev, \"BlinkM: unknown color.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tblinkm_transfer_hw(led->i2c_client, BLM_GO_RGB);\n\tdev_dbg(&led->i2c_client->dev,\n\t\t\t\"# DONE # next_red = %d, next_green = %d,\"\n\t\t\t\" next_blue = %d\\n\",\n\t\t\tdata->next_red, data->next_green,\n\t\t\tdata->next_blue);\n\treturn 0;\n}\n\nstatic int blinkm_led_red_set(struct led_classdev *led_cdev,\n\t\t\t       enum led_brightness value)\n{\n\treturn blinkm_led_common_set(led_cdev, value, RED);\n}\n\nstatic int blinkm_led_green_set(struct led_classdev *led_cdev,\n\t\t\t\t enum led_brightness value)\n{\n\treturn blinkm_led_common_set(led_cdev, value, GREEN);\n}\n\nstatic int blinkm_led_blue_set(struct led_classdev *led_cdev,\n\t\t\t\tenum led_brightness value)\n{\n\treturn blinkm_led_common_set(led_cdev, value, BLUE);\n}\n\nstatic void blinkm_init_hw(struct i2c_client *client)\n{\n\tblinkm_transfer_hw(client, BLM_STOP_SCRIPT);\n\tblinkm_transfer_hw(client, BLM_GO_RGB);\n}\n\nstatic int blinkm_test_run(struct i2c_client *client)\n{\n\tint ret;\n\tstruct blinkm_data *data = i2c_get_clientdata(client);\n\n\tdata->next_red = 0x01;\n\tdata->next_green = 0x05;\n\tdata->next_blue = 0x10;\n\tret = blinkm_transfer_hw(client, BLM_GO_RGB);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(2000);\n\n\tdata->next_red = 0x25;\n\tdata->next_green = 0x10;\n\tdata->next_blue = 0x31;\n\tret = blinkm_transfer_hw(client, BLM_FADE_RGB);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(2000);\n\n\tdata->next_hue = 0x50;\n\tdata->next_saturation = 0x10;\n\tdata->next_brightness = 0x20;\n\tret = blinkm_transfer_hw(client, BLM_FADE_HSB);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(2000);\n\n\treturn 0;\n}\n\n \nstatic int blinkm_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint ret;\n\tint count = 99;\n\tu8 tmpargs[7];\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_WORD_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_WRITE_BYTE))\n\t\treturn -ENODEV;\n\n\t \n\t \n\n\t \n\twhile (count > 0) {\n\t\tret = blinkm_write(client, BLM_GET_ADDR, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tusleep_range(5000, 10000);\n\t\tret = blinkm_read(client, BLM_GET_ADDR, tmpargs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tusleep_range(5000, 10000);\n\t\tif (tmpargs[0] == 0x09)\n\t\t\tcount = 0;\n\t\tcount--;\n\t}\n\n\t \n\tret = blinkm_write(client, BLM_GET_ADDR, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\tusleep_range(20000, 30000);\t \n\tret = blinkm_read(client, BLM_GET_ADDR, tmpargs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tmpargs[0] != 0x09) {\n\t\tdev_err(&client->dev, \"enodev DEV ADDR = 0x%02X\\n\", tmpargs[0]);\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, \"blinkm\", I2C_NAME_SIZE);\n\treturn 0;\n}\n\nstatic int blinkm_probe(struct i2c_client *client)\n{\n\tstruct blinkm_data *data;\n\tstruct blinkm_led *led[3];\n\tint err, i;\n\tchar blinkm_led_name[28];\n\n\tdata = devm_kzalloc(&client->dev,\n\t\t\tsizeof(struct blinkm_data), GFP_KERNEL);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tdata->i2c_addr = 0x08;\n\t \n\tdata->fw_ver = 0xfe;\n\t \n\tdata->script_id = 0x01;\n\tdata->i2c_client = client;\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\n\t \n\terr = sysfs_create_group(&client->dev.kobj, &blinkm_group);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"couldn't register sysfs group\\n\");\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\t \n\t\tled[i] = &data->blinkm_leds[i];\n\t\tled[i]->i2c_client = client;\n\t\tled[i]->id = i;\n\t\tled[i]->led_cdev.max_brightness = 255;\n\t\tled[i]->led_cdev.flags = LED_CORE_SUSPENDRESUME;\n\t\tswitch (i) {\n\t\tcase RED:\n\t\t\tsnprintf(blinkm_led_name, sizeof(blinkm_led_name),\n\t\t\t\t\t \"blinkm-%d-%d-red\",\n\t\t\t\t\t client->adapter->nr,\n\t\t\t\t\t client->addr);\n\t\t\tled[i]->led_cdev.name = blinkm_led_name;\n\t\t\tled[i]->led_cdev.brightness_set_blocking =\n\t\t\t\t\t\t\tblinkm_led_red_set;\n\t\t\terr = led_classdev_register(&client->dev,\n\t\t\t\t\t\t    &led[i]->led_cdev);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"couldn't register LED %s\\n\",\n\t\t\t\t\tled[i]->led_cdev.name);\n\t\t\t\tgoto failred;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GREEN:\n\t\t\tsnprintf(blinkm_led_name, sizeof(blinkm_led_name),\n\t\t\t\t\t \"blinkm-%d-%d-green\",\n\t\t\t\t\t client->adapter->nr,\n\t\t\t\t\t client->addr);\n\t\t\tled[i]->led_cdev.name = blinkm_led_name;\n\t\t\tled[i]->led_cdev.brightness_set_blocking =\n\t\t\t\t\t\t\tblinkm_led_green_set;\n\t\t\terr = led_classdev_register(&client->dev,\n\t\t\t\t\t\t    &led[i]->led_cdev);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"couldn't register LED %s\\n\",\n\t\t\t\t\tled[i]->led_cdev.name);\n\t\t\t\tgoto failgreen;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BLUE:\n\t\t\tsnprintf(blinkm_led_name, sizeof(blinkm_led_name),\n\t\t\t\t\t \"blinkm-%d-%d-blue\",\n\t\t\t\t\t client->adapter->nr,\n\t\t\t\t\t client->addr);\n\t\t\tled[i]->led_cdev.name = blinkm_led_name;\n\t\t\tled[i]->led_cdev.brightness_set_blocking =\n\t\t\t\t\t\t\tblinkm_led_blue_set;\n\t\t\terr = led_classdev_register(&client->dev,\n\t\t\t\t\t\t    &led[i]->led_cdev);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"couldn't register LED %s\\n\",\n\t\t\t\t\tled[i]->led_cdev.name);\n\t\t\t\tgoto failblue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\t\t \n\t}\t\t\t \n\n\t \n\tblinkm_init_hw(client);\n\n\treturn 0;\n\nfailblue:\n\tled_classdev_unregister(&led[GREEN]->led_cdev);\n\nfailgreen:\n\tled_classdev_unregister(&led[RED]->led_cdev);\n\nfailred:\n\tsysfs_remove_group(&client->dev.kobj, &blinkm_group);\nexit:\n\treturn err;\n}\n\nstatic void blinkm_remove(struct i2c_client *client)\n{\n\tstruct blinkm_data *data = i2c_get_clientdata(client);\n\tint ret = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tled_classdev_unregister(&data->blinkm_leds[i].led_cdev);\n\n\t \n\tdata->next_red = 0x00;\n\tdata->next_green = 0x00;\n\tdata->next_blue = 0x00;\n\tret = blinkm_transfer_hw(client, BLM_FADE_RGB);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Failure in blinkm_remove ignored. Continuing.\\n\");\n\n\t \n\tdata->next_hue = 0x00;\n\tdata->next_saturation = 0x00;\n\tdata->next_brightness = 0x00;\n\tret = blinkm_transfer_hw(client, BLM_FADE_HSB);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Failure in blinkm_remove ignored. Continuing.\\n\");\n\n\t \n\tdata->next_red = 0xff;\n\tret = blinkm_transfer_hw(client, BLM_GO_RGB);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Failure in blinkm_remove ignored. Continuing.\\n\");\n\n\t \n\tdata->next_red = 0x00;\n\tret = blinkm_transfer_hw(client, BLM_FADE_RGB);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Failure in blinkm_remove ignored. Continuing.\\n\");\n\n\tsysfs_remove_group(&client->dev.kobj, &blinkm_group);\n}\n\nstatic const struct i2c_device_id blinkm_id[] = {\n\t{\"blinkm\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, blinkm_id);\n\n   \nstatic struct i2c_driver blinkm_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t   .name = \"blinkm\",\n\t\t   },\n\t.probe = blinkm_probe,\n\t.remove = blinkm_remove,\n\t.id_table = blinkm_id,\n\t.detect = blinkm_detect,\n\t.address_list = normal_i2c,\n};\n\nmodule_i2c_driver(blinkm_driver);\n\nMODULE_AUTHOR(\"Jan-Simon Moeller <dl9pf@gmx.de>\");\nMODULE_DESCRIPTION(\"BlinkM RGB LED driver\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}