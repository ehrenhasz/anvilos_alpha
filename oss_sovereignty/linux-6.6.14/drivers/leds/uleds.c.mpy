{
  "module_name": "uleds.c",
  "hash_id": "7a98aa6e5fa58c36fa3cd9556d91b11cb83421f7d53d4d2cea18c4b3a2392b2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/uleds.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/leds.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <uapi/linux/uleds.h>\n\n#define ULEDS_NAME\t\"uleds\"\n\nenum uleds_state {\n\tULEDS_STATE_UNKNOWN,\n\tULEDS_STATE_REGISTERED,\n};\n\nstruct uleds_device {\n\tstruct uleds_user_dev\tuser_dev;\n\tstruct led_classdev\tled_cdev;\n\tstruct mutex\t\tmutex;\n\tenum uleds_state\tstate;\n\twait_queue_head_t\twaitq;\n\tint\t\t\tbrightness;\n\tbool\t\t\tnew_data;\n};\n\nstatic struct miscdevice uleds_misc;\n\nstatic void uleds_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t enum led_brightness brightness)\n{\n\tstruct uleds_device *udev = container_of(led_cdev, struct uleds_device,\n\t\t\t\t\t\t led_cdev);\n\n\tif (udev->brightness != brightness) {\n\t\tudev->brightness = brightness;\n\t\tudev->new_data = true;\n\t\twake_up_interruptible(&udev->waitq);\n\t}\n}\n\nstatic int uleds_open(struct inode *inode, struct file *file)\n{\n\tstruct uleds_device *udev;\n\n\tudev = kzalloc(sizeof(*udev), GFP_KERNEL);\n\tif (!udev)\n\t\treturn -ENOMEM;\n\n\tudev->led_cdev.name = udev->user_dev.name;\n\tudev->led_cdev.brightness_set = uleds_brightness_set;\n\n\tmutex_init(&udev->mutex);\n\tinit_waitqueue_head(&udev->waitq);\n\tudev->state = ULEDS_STATE_UNKNOWN;\n\n\tfile->private_data = udev;\n\tstream_open(inode, file);\n\n\treturn 0;\n}\n\nstatic ssize_t uleds_write(struct file *file, const char __user *buffer,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct uleds_device *udev = file->private_data;\n\tconst char *name;\n\tint ret;\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tret = mutex_lock_interruptible(&udev->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tif (udev->state == ULEDS_STATE_REGISTERED) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (count != sizeof(struct uleds_user_dev)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&udev->user_dev, buffer,\n\t\t\t   sizeof(struct uleds_user_dev))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tname = udev->user_dev.name;\n\tif (!name[0] || !strcmp(name, \".\") || !strcmp(name, \"..\") ||\n\t    strchr(name, '/')) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (udev->user_dev.max_brightness <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tudev->led_cdev.max_brightness = udev->user_dev.max_brightness;\n\n\tret = devm_led_classdev_register(uleds_misc.this_device,\n\t\t\t\t\t &udev->led_cdev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tudev->new_data = true;\n\tudev->state = ULEDS_STATE_REGISTERED;\n\tret = count;\n\nout:\n\tmutex_unlock(&udev->mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t uleds_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct uleds_device *udev = file->private_data;\n\tssize_t retval;\n\n\tif (count < sizeof(udev->brightness))\n\t\treturn 0;\n\n\tdo {\n\t\tretval = mutex_lock_interruptible(&udev->mutex);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tif (udev->state != ULEDS_STATE_REGISTERED) {\n\t\t\tretval = -ENODEV;\n\t\t} else if (!udev->new_data && (file->f_flags & O_NONBLOCK)) {\n\t\t\tretval = -EAGAIN;\n\t\t} else if (udev->new_data) {\n\t\t\tretval = copy_to_user(buffer, &udev->brightness,\n\t\t\t\t\t      sizeof(udev->brightness));\n\t\t\tudev->new_data = false;\n\t\t\tretval = sizeof(udev->brightness);\n\t\t}\n\n\t\tmutex_unlock(&udev->mutex);\n\n\t\tif (retval)\n\t\t\tbreak;\n\n\t\tif (!(file->f_flags & O_NONBLOCK))\n\t\t\tretval = wait_event_interruptible(udev->waitq,\n\t\t\t\t\tudev->new_data ||\n\t\t\t\t\tudev->state != ULEDS_STATE_REGISTERED);\n\t} while (retval == 0);\n\n\treturn retval;\n}\n\nstatic __poll_t uleds_poll(struct file *file, poll_table *wait)\n{\n\tstruct uleds_device *udev = file->private_data;\n\n\tpoll_wait(file, &udev->waitq, wait);\n\n\tif (udev->new_data)\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\n\treturn 0;\n}\n\nstatic int uleds_release(struct inode *inode, struct file *file)\n{\n\tstruct uleds_device *udev = file->private_data;\n\n\tif (udev->state == ULEDS_STATE_REGISTERED) {\n\t\tudev->state = ULEDS_STATE_UNKNOWN;\n\t\tdevm_led_classdev_unregister(uleds_misc.this_device,\n\t\t\t\t\t     &udev->led_cdev);\n\t}\n\tkfree(udev);\n\n\treturn 0;\n}\n\nstatic const struct file_operations uleds_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= uleds_open,\n\t.release\t= uleds_release,\n\t.read\t\t= uleds_read,\n\t.write\t\t= uleds_write,\n\t.poll\t\t= uleds_poll,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct miscdevice uleds_misc = {\n\t.fops\t\t= &uleds_fops,\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= ULEDS_NAME,\n};\n\nmodule_misc_device(uleds_misc);\n\nMODULE_AUTHOR(\"David Lechner <david@lechnology.com>\");\nMODULE_DESCRIPTION(\"Userspace driver for the LED subsystem\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}