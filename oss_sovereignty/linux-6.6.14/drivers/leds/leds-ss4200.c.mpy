{
  "module_name": "leds-ss4200.c",
  "hash_id": "d2349aad14c3f00ada7e837ccc263637e3adab23501b8dff9667de6c55e85239",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-ss4200.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/dmi.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\nMODULE_AUTHOR(\"Rodney Girod <rgirod@confocus.com>, Dave Hansen <dave@sr71.net>\");\nMODULE_DESCRIPTION(\"Intel NAS/Home Server ICH7 GPIO Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define PMBASE\t\t0x040\n#define GPIO_BASE\t0x048\n#define GPIO_CTRL\t0x04c\n#define GPIO_EN\t\t0x010\n\n \n#define ICH7_GPIO_SIZE\t64\n\n \n#define GPIO_USE_SEL\t0x000\n#define GP_IO_SEL\t0x004\n#define GP_LVL\t\t0x00c\n#define GPO_BLINK\t0x018\n#define GPI_INV\t\t0x030\n#define GPIO_USE_SEL2\t0x034\n#define GP_IO_SEL2\t0x038\n#define GP_LVL2\t\t0x03c\n\n \nstatic const struct pci_device_id ich7_lpc_pci_id[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH7_0) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH7_1) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH7_30) },\n\t{ }  \n};\n\nMODULE_DEVICE_TABLE(pci, ich7_lpc_pci_id);\n\nstatic int __init ss4200_led_dmi_callback(const struct dmi_system_id *id)\n{\n\tpr_info(\"detected '%s'\\n\", id->ident);\n\treturn 1;\n}\n\nstatic bool nodetect;\nmodule_param_named(nodetect, nodetect, bool, 0);\nMODULE_PARM_DESC(nodetect, \"Skip DMI-based hardware detection\");\n\n \nstatic const struct dmi_system_id nas_led_whitelist[] __initconst = {\n\t{\n\t\t.callback = ss4200_led_dmi_callback,\n\t\t.ident = \"Intel SS4200-E\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"SS4200-E\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"1.00.00\")\n\t\t}\n\t},\n\t{\n\t\t \n\t\t.callback = ss4200_led_dmi_callback,\n\t\t.ident = \"Fujitsu Siemens SCALEO Home Server\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"SCALEO Home Server\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"1.00.00\")\n\t\t}\n\t},\n\t{}\n};\n\n \nstatic u32 g_pm_io_base;\n\n \nstatic u32 nas_gpio_io_base;\n\n \nstatic struct resource *gp_gpio_resource;\n\nstruct nasgpio_led {\n\tchar *name;\n\tu32 gpio_bit;\n\tstruct led_classdev led_cdev;\n};\n\n \nstatic struct nasgpio_led nasgpio_leds[] = {\n\t{ .name = \"hdd1:blue:sata\",\t.gpio_bit = 0 },\n\t{ .name = \"hdd1:amber:sata\",\t.gpio_bit = 1 },\n\t{ .name = \"hdd2:blue:sata\",\t.gpio_bit = 2 },\n\t{ .name = \"hdd2:amber:sata\",\t.gpio_bit = 3 },\n\t{ .name = \"hdd3:blue:sata\",\t.gpio_bit = 4 },\n\t{ .name = \"hdd3:amber:sata\",\t.gpio_bit = 5 },\n\t{ .name = \"hdd4:blue:sata\",\t.gpio_bit = 6 },\n\t{ .name = \"hdd4:amber:sata\",\t.gpio_bit = 7 },\n\t{ .name = \"power:blue:power\",\t.gpio_bit = 27},\n\t{ .name = \"power:amber:power\",  .gpio_bit = 28},\n};\n\n#define NAS_RECOVERY\t0x00000400\t \n\nstatic struct nasgpio_led *\nled_classdev_to_nasgpio_led(struct led_classdev *led_cdev)\n{\n\treturn container_of(led_cdev, struct nasgpio_led, led_cdev);\n}\n\nstatic struct nasgpio_led *get_led_named(char *name)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(nasgpio_leds); i++) {\n\t\tif (strcmp(nasgpio_leds[i].name, name))\n\t\t\tcontinue;\n\t\treturn &nasgpio_leds[i];\n\t}\n\treturn NULL;\n}\n\n \nstatic DEFINE_SPINLOCK(nasgpio_gpio_lock);\n\n \nstatic void __nasgpio_led_set_attr(struct led_classdev *led_cdev,\n\t\t\t\t   u32 port, u32 value)\n{\n\tstruct nasgpio_led *led = led_classdev_to_nasgpio_led(led_cdev);\n\tu32 gpio_out;\n\n\tgpio_out = inl(nas_gpio_io_base + port);\n\tif (value)\n\t\tgpio_out |= (1<<led->gpio_bit);\n\telse\n\t\tgpio_out &= ~(1<<led->gpio_bit);\n\n\toutl(gpio_out, nas_gpio_io_base + port);\n}\n\nstatic void nasgpio_led_set_attr(struct led_classdev *led_cdev,\n\t\t\t\t u32 port, u32 value)\n{\n\tspin_lock(&nasgpio_gpio_lock);\n\t__nasgpio_led_set_attr(led_cdev, port, value);\n\tspin_unlock(&nasgpio_gpio_lock);\n}\n\nstatic u32 nasgpio_led_get_attr(struct led_classdev *led_cdev, u32 port)\n{\n\tstruct nasgpio_led *led = led_classdev_to_nasgpio_led(led_cdev);\n\tu32 gpio_in;\n\n\tspin_lock(&nasgpio_gpio_lock);\n\tgpio_in = inl(nas_gpio_io_base + port);\n\tspin_unlock(&nasgpio_gpio_lock);\n\tif (gpio_in & (1<<led->gpio_bit))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic void nasgpio_led_set_brightness(struct led_classdev *led_cdev,\n\t\t\t\t       enum led_brightness brightness)\n{\n\tu32 setting = 0;\n\tif (brightness >= LED_HALF)\n\t\tsetting = 1;\n\t \n\tspin_lock(&nasgpio_gpio_lock);\n\t \n\tif (brightness == 0)\n\t\t__nasgpio_led_set_attr(led_cdev, GPO_BLINK, 0);\n\t__nasgpio_led_set_attr(led_cdev, GP_LVL, setting);\n\tspin_unlock(&nasgpio_gpio_lock);\n}\n\nstatic int nasgpio_led_set_blink(struct led_classdev *led_cdev,\n\t\t\t\t unsigned long *delay_on,\n\t\t\t\t unsigned long *delay_off)\n{\n\tu32 setting = 1;\n\tif (!(*delay_on == 0 && *delay_off == 0) &&\n\t    !(*delay_on == 500 && *delay_off == 500))\n\t\treturn -EINVAL;\n\t \n\t*delay_on = 500;\n\t*delay_off = 500;\n\n\tnasgpio_led_set_attr(led_cdev, GPO_BLINK, setting);\n\n\treturn 0;\n}\n\n\n \nstatic int ich7_gpio_init(struct device *dev)\n{\n\tint i;\n\tu32 config_data = 0;\n\tu32 all_nas_led = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(nasgpio_leds); i++)\n\t\tall_nas_led |= (1<<nasgpio_leds[i].gpio_bit);\n\n\tspin_lock(&nasgpio_gpio_lock);\n\t \n\tconfig_data = inl(nas_gpio_io_base + GPIO_USE_SEL);\n\tdev_dbg(dev, \": Data read from GPIO_USE_SEL = 0x%08x\\n\", config_data);\n\tconfig_data |= all_nas_led + NAS_RECOVERY;\n\toutl(config_data, nas_gpio_io_base + GPIO_USE_SEL);\n\tconfig_data = inl(nas_gpio_io_base + GPIO_USE_SEL);\n\tdev_dbg(dev, \": GPIO_USE_SEL = 0x%08x\\n\\n\", config_data);\n\n\t \n\tconfig_data = inl(nas_gpio_io_base + GP_IO_SEL);\n\tdev_dbg(dev, \": Data read from GP_IO_SEL = 0x%08x\\n\",\n\t\t\t\t\tconfig_data);\n\tconfig_data &= ~all_nas_led;\n\tconfig_data |= NAS_RECOVERY;\n\toutl(config_data, nas_gpio_io_base + GP_IO_SEL);\n\tconfig_data = inl(nas_gpio_io_base + GP_IO_SEL);\n\tdev_dbg(dev, \": GP_IO_SEL = 0x%08x\\n\", config_data);\n\n\t \n\tconfig_data = inl(nas_gpio_io_base + GP_LVL);\n\tdev_dbg(dev, \": Data read from GP_LVL = 0x%08x\\n\", config_data);\n\t \n\tconfig_data = inl(nas_gpio_io_base + GPO_BLINK);\n\tdev_dbg(dev, \": Data read from GPO_BLINK = 0x%08x\\n\", config_data);\n\n\t \n\tconfig_data = inl(nas_gpio_io_base + GPI_INV);\n\tdev_dbg(dev, \": Data read from GPI_INV = 0x%08x\\n\", config_data);\n\n\tspin_unlock(&nasgpio_gpio_lock);\n\treturn 0;\n}\n\nstatic void ich7_lpc_cleanup(struct device *dev)\n{\n\t \n\tif (gp_gpio_resource) {\n\t\tdev_dbg(dev, \": Releasing GPIO I/O addresses\\n\");\n\t\trelease_region(nas_gpio_io_base, ICH7_GPIO_SIZE);\n\t\tgp_gpio_resource = NULL;\n\t}\n}\n\n \nstatic struct pci_dev *nas_gpio_pci_dev;\nstatic int ich7_lpc_probe(struct pci_dev *dev,\n\t\t\t\t    const struct pci_device_id *id)\n{\n\tint status;\n\tu32 gc = 0;\n\n\tstatus = pci_enable_device(dev);\n\tif (status) {\n\t\tdev_err(&dev->dev, \"pci_enable_device failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnas_gpio_pci_dev = dev;\n\tstatus = pci_read_config_dword(dev, PMBASE, &g_pm_io_base);\n\tif (status)\n\t\tgoto out;\n\tg_pm_io_base &= 0x00000ff80;\n\n\tstatus = pci_read_config_dword(dev, GPIO_CTRL, &gc);\n\tif (!(GPIO_EN & gc)) {\n\t\tstatus = -EEXIST;\n\t\tdev_info(&dev->dev,\n\t\t\t   \"ERROR: The LPC GPIO Block has not been enabled.\\n\");\n\t\tgoto out;\n\t}\n\n\tstatus = pci_read_config_dword(dev, GPIO_BASE, &nas_gpio_io_base);\n\tif (0 > status) {\n\t\tdev_info(&dev->dev, \"Unable to read GPIOBASE.\\n\");\n\t\tgoto out;\n\t}\n\tdev_dbg(&dev->dev, \": GPIOBASE = 0x%08x\\n\", nas_gpio_io_base);\n\tnas_gpio_io_base &= 0x00000ffc0;\n\n\t \n\tgp_gpio_resource = request_region(nas_gpio_io_base, ICH7_GPIO_SIZE,\n\t\t\t\t\t  KBUILD_MODNAME);\n\tif (NULL == gp_gpio_resource) {\n\t\tdev_info(&dev->dev,\n\t\t\t \"ERROR Unable to register GPIO I/O addresses.\\n\");\n\t\tstatus = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tich7_gpio_init(&dev->dev);\n\nout:\n\tif (status) {\n\t\tich7_lpc_cleanup(&dev->dev);\n\t\tpci_disable_device(dev);\n\t}\n\treturn status;\n}\n\nstatic void ich7_lpc_remove(struct pci_dev *dev)\n{\n\tich7_lpc_cleanup(&dev->dev);\n\tpci_disable_device(dev);\n}\n\n \nstatic struct pci_driver nas_gpio_pci_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = ich7_lpc_pci_id,\n\t.probe = ich7_lpc_probe,\n\t.remove = ich7_lpc_remove,\n};\n\nstatic struct led_classdev *get_classdev_for_led_nr(int nr)\n{\n\tstruct nasgpio_led *nas_led = &nasgpio_leds[nr];\n\tstruct led_classdev *led = &nas_led->led_cdev;\n\treturn led;\n}\n\n\nstatic void set_power_light_amber_noblink(void)\n{\n\tstruct nasgpio_led *amber = get_led_named(\"power:amber:power\");\n\tstruct nasgpio_led *blue = get_led_named(\"power:blue:power\");\n\n\tif (!amber || !blue)\n\t\treturn;\n\t \n\tpr_debug(\"setting blue off and amber on\\n\");\n\n\tnasgpio_led_set_brightness(&blue->led_cdev, LED_OFF);\n\tnasgpio_led_set_brightness(&amber->led_cdev, LED_FULL);\n}\n\nstatic ssize_t blink_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led = dev_get_drvdata(dev);\n\tint blinking = 0;\n\tif (nasgpio_led_get_attr(led, GPO_BLINK))\n\t\tblinking = 1;\n\treturn sprintf(buf, \"%u\\n\", blinking);\n}\n\nstatic ssize_t blink_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t size)\n{\n\tint ret;\n\tstruct led_classdev *led = dev_get_drvdata(dev);\n\tunsigned long blink_state;\n\n\tret = kstrtoul(buf, 10, &blink_state);\n\tif (ret)\n\t\treturn ret;\n\n\tnasgpio_led_set_attr(led, GPO_BLINK, blink_state);\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(blink);\n\nstatic struct attribute *nasgpio_led_attrs[] = {\n\t&dev_attr_blink.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(nasgpio_led);\n\nstatic int register_nasgpio_led(int led_nr)\n{\n\tstruct nasgpio_led *nas_led = &nasgpio_leds[led_nr];\n\tstruct led_classdev *led = get_classdev_for_led_nr(led_nr);\n\n\tled->name = nas_led->name;\n\tled->brightness = LED_OFF;\n\tif (nasgpio_led_get_attr(led, GP_LVL))\n\t\tled->brightness = LED_FULL;\n\tled->brightness_set = nasgpio_led_set_brightness;\n\tled->blink_set = nasgpio_led_set_blink;\n\tled->groups = nasgpio_led_groups;\n\n\treturn led_classdev_register(&nas_gpio_pci_dev->dev, led);\n}\n\nstatic void unregister_nasgpio_led(int led_nr)\n{\n\tstruct led_classdev *led = get_classdev_for_led_nr(led_nr);\n\tled_classdev_unregister(led);\n}\n \nstatic int __init nas_gpio_init(void)\n{\n\tint i;\n\tint ret = 0;\n\tint nr_devices = 0;\n\n\tnr_devices = dmi_check_system(nas_led_whitelist);\n\tif (nodetect) {\n\t\tpr_info(\"skipping hardware autodetection\\n\");\n\t\tpr_info(\"Please send 'dmidecode' output to dave@sr71.net\\n\");\n\t\tnr_devices++;\n\t}\n\n\tif (nr_devices <= 0) {\n\t\tpr_info(\"no LED devices found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpr_info(\"registering PCI driver\\n\");\n\tret = pci_register_driver(&nas_gpio_pci_driver);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < ARRAY_SIZE(nasgpio_leds); i++) {\n\t\tret = register_nasgpio_led(i);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\t \n\tset_power_light_amber_noblink();\n\treturn 0;\nout_err:\n\tfor (i--; i >= 0; i--)\n\t\tunregister_nasgpio_led(i);\n\tpci_unregister_driver(&nas_gpio_pci_driver);\n\treturn ret;\n}\n\n \nstatic void __exit nas_gpio_exit(void)\n{\n\tint i;\n\tpr_info(\"Unregistering driver\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(nasgpio_leds); i++)\n\t\tunregister_nasgpio_led(i);\n\tpci_unregister_driver(&nas_gpio_pci_driver);\n}\n\nmodule_init(nas_gpio_init);\nmodule_exit(nas_gpio_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}