{
  "module_name": "leds-adp5520.c",
  "hash_id": "ead26f727c04268c55c4db56f229e160b30fdc5a92a12b006834c5b8e9fbf130",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-adp5520.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/leds.h>\n#include <linux/mfd/adp5520.h>\n#include <linux/slab.h>\n\nstruct adp5520_led {\n\tstruct led_classdev\tcdev;\n\tstruct device\t\t*master;\n\tint\t\t\tid;\n\tint\t\t\tflags;\n};\n\nstatic int adp5520_led_set(struct led_classdev *led_cdev,\n\t\t\t   enum led_brightness value)\n{\n\tstruct adp5520_led *led;\n\n\tled = container_of(led_cdev, struct adp5520_led, cdev);\n\treturn adp5520_write(led->master, ADP5520_LED1_CURRENT + led->id - 1,\n\t\t\t value >> 2);\n}\n\nstatic int adp5520_led_setup(struct adp5520_led *led)\n{\n\tstruct device *dev = led->master;\n\tint flags = led->flags;\n\tint ret = 0;\n\n\tswitch (led->id) {\n\tcase FLAG_ID_ADP5520_LED1_ADP5501_LED0:\n\t\tret |= adp5520_set_bits(dev, ADP5520_LED_TIME,\n\t\t\t\t\t(flags >> ADP5520_FLAG_OFFT_SHIFT) &\n\t\t\t\t\tADP5520_FLAG_OFFT_MASK);\n\t\tret |= adp5520_set_bits(dev, ADP5520_LED_CONTROL,\n\t\t\t\t\tADP5520_LED1_EN);\n\t\tbreak;\n\tcase FLAG_ID_ADP5520_LED2_ADP5501_LED1:\n\t\tret |= adp5520_set_bits(dev,  ADP5520_LED_TIME,\n\t\t\t\t\t((flags >> ADP5520_FLAG_OFFT_SHIFT) &\n\t\t\t\t\tADP5520_FLAG_OFFT_MASK) << 2);\n\t\tret |= adp5520_clr_bits(dev, ADP5520_LED_CONTROL,\n\t\t\t\t\t ADP5520_R3_MODE);\n\t\tret |= adp5520_set_bits(dev, ADP5520_LED_CONTROL,\n\t\t\t\t\tADP5520_LED2_EN);\n\t\tbreak;\n\tcase FLAG_ID_ADP5520_LED3_ADP5501_LED2:\n\t\tret |= adp5520_set_bits(dev,  ADP5520_LED_TIME,\n\t\t\t\t\t((flags >> ADP5520_FLAG_OFFT_SHIFT) &\n\t\t\t\t\tADP5520_FLAG_OFFT_MASK) << 4);\n\t\tret |= adp5520_clr_bits(dev, ADP5520_LED_CONTROL,\n\t\t\t\t\tADP5520_C3_MODE);\n\t\tret |= adp5520_set_bits(dev, ADP5520_LED_CONTROL,\n\t\t\t\t\tADP5520_LED3_EN);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int adp5520_led_prepare(struct platform_device *pdev)\n{\n\tstruct adp5520_leds_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct device *dev = pdev->dev.parent;\n\tint ret = 0;\n\n\tret |= adp5520_write(dev, ADP5520_LED1_CURRENT, 0);\n\tret |= adp5520_write(dev, ADP5520_LED2_CURRENT, 0);\n\tret |= adp5520_write(dev, ADP5520_LED3_CURRENT, 0);\n\tret |= adp5520_write(dev, ADP5520_LED_TIME, pdata->led_on_time << 6);\n\tret |= adp5520_write(dev, ADP5520_LED_FADE, FADE_VAL(pdata->fade_in,\n\t\t pdata->fade_out));\n\n\treturn ret;\n}\n\nstatic int adp5520_led_probe(struct platform_device *pdev)\n{\n\tstruct adp5520_leds_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct adp5520_led *led, *led_dat;\n\tstruct led_info *cur_led;\n\tint ret, i;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&pdev->dev, \"missing platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pdata->num_leds > ADP5520_01_MAXLEDS) {\n\t\tdev_err(&pdev->dev, \"can't handle more than %d LEDS\\n\",\n\t\t\t\t ADP5520_01_MAXLEDS);\n\t\treturn -EFAULT;\n\t}\n\n\tled = devm_kcalloc(&pdev->dev, pdata->num_leds, sizeof(*led),\n\t\t\t\tGFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tret = adp5520_led_prepare(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to write\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < pdata->num_leds; ++i) {\n\t\tcur_led = &pdata->leds[i];\n\t\tled_dat = &led[i];\n\n\t\tled_dat->cdev.name = cur_led->name;\n\t\tled_dat->cdev.default_trigger = cur_led->default_trigger;\n\t\tled_dat->cdev.brightness_set_blocking = adp5520_led_set;\n\t\tled_dat->cdev.brightness = LED_OFF;\n\n\t\tif (cur_led->flags & ADP5520_FLAG_LED_MASK)\n\t\t\tled_dat->flags = cur_led->flags;\n\t\telse\n\t\t\tled_dat->flags = i + 1;\n\n\t\tled_dat->id = led_dat->flags & ADP5520_FLAG_LED_MASK;\n\n\t\tled_dat->master = pdev->dev.parent;\n\n\t\tret = led_classdev_register(led_dat->master, &led_dat->cdev);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to register LED %d\\n\",\n\t\t\t\tled_dat->id);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = adp5520_led_setup(led_dat);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to write\\n\");\n\t\t\ti++;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, led);\n\treturn 0;\n\nerr:\n\tif (i > 0) {\n\t\tfor (i = i - 1; i >= 0; i--)\n\t\t\tled_classdev_unregister(&led[i].cdev);\n\t}\n\n\treturn ret;\n}\n\nstatic int adp5520_led_remove(struct platform_device *pdev)\n{\n\tstruct adp5520_leds_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct adp5520_led *led;\n\tint i;\n\n\tled = platform_get_drvdata(pdev);\n\n\tadp5520_clr_bits(led->master, ADP5520_LED_CONTROL,\n\t\t ADP5520_LED1_EN | ADP5520_LED2_EN | ADP5520_LED3_EN);\n\n\tfor (i = 0; i < pdata->num_leds; i++) {\n\t\tled_classdev_unregister(&led[i].cdev);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver adp5520_led_driver = {\n\t.driver\t= {\n\t\t.name\t= \"adp5520-led\",\n\t},\n\t.probe\t\t= adp5520_led_probe,\n\t.remove\t\t= adp5520_led_remove,\n};\n\nmodule_platform_driver(adp5520_led_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <hennerich@blackfin.uclinux.org>\");\nMODULE_DESCRIPTION(\"LEDS ADP5520(01) Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:adp5520-led\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}