{
  "module_name": "leds-wm8350.c",
  "hash_id": "88a6c3614ea7200d80c58bce7eec9257032fa72b568b7c371d7af708bd928a92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-wm8350.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/leds.h>\n#include <linux/err.h>\n#include <linux/mfd/wm8350/pmic.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n \nstatic const int isink_cur[] = {\n\t4,\n\t5,\n\t6,\n\t7,\n\t8,\n\t10,\n\t11,\n\t14,\n\t16,\n\t19,\n\t23,\n\t27,\n\t32,\n\t39,\n\t46,\n\t54,\n\t65,\n\t77,\n\t92,\n\t109,\n\t130,\n\t154,\n\t183,\n\t218,\n\t259,\n\t308,\n\t367,\n\t436,\n\t518,\n\t616,\n\t733,\n\t872,\n\t1037,\n\t1233,\n\t1466,\n\t1744,\n\t2073,\n\t2466,\n\t2933,\n\t3487,\n\t4147,\n\t4932,\n\t5865,\n\t6975,\n\t8294,\n\t9864,\n\t11730,\n\t13949,\n\t16589,\n\t19728,\n\t23460,\n\t27899,\n\t33178,\n\t39455,\n\t46920,\n\t55798,\n\t66355,\n\t78910,\n\t93840,\n\t111596,\n\t132710,\n\t157820,\n\t187681,\n\t223191\n};\n\n#define to_wm8350_led(led_cdev) \\\n\tcontainer_of(led_cdev, struct wm8350_led, cdev)\n\nstatic int wm8350_led_enable(struct wm8350_led *led)\n{\n\tint ret = 0;\n\n\tif (led->enabled)\n\t\treturn ret;\n\n\tret = regulator_enable(led->isink);\n\tif (ret != 0) {\n\t\tdev_err(led->cdev.dev, \"Failed to enable ISINK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_enable(led->dcdc);\n\tif (ret != 0) {\n\t\tdev_err(led->cdev.dev, \"Failed to enable DCDC: %d\\n\", ret);\n\t\tregulator_disable(led->isink);\n\t\treturn ret;\n\t}\n\n\tled->enabled = 1;\n\n\treturn ret;\n}\n\nstatic int wm8350_led_disable(struct wm8350_led *led)\n{\n\tint ret = 0;\n\n\tif (!led->enabled)\n\t\treturn ret;\n\n\tret = regulator_disable(led->dcdc);\n\tif (ret != 0) {\n\t\tdev_err(led->cdev.dev, \"Failed to disable DCDC: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_disable(led->isink);\n\tif (ret != 0) {\n\t\tdev_err(led->cdev.dev, \"Failed to disable ISINK: %d\\n\", ret);\n\t\tret = regulator_enable(led->dcdc);\n\t\tif (ret != 0)\n\t\t\tdev_err(led->cdev.dev, \"Failed to reenable DCDC: %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tled->enabled = 0;\n\n\treturn ret;\n}\n\nstatic int wm8350_led_set(struct led_classdev *led_cdev,\n\t\t\t   enum led_brightness value)\n{\n\tstruct wm8350_led *led = to_wm8350_led(led_cdev);\n\tunsigned long flags;\n\tint ret;\n\tint uA;\n\n\tled->value = value;\n\n\tspin_lock_irqsave(&led->value_lock, flags);\n\n\tif (led->value == LED_OFF) {\n\t\tspin_unlock_irqrestore(&led->value_lock, flags);\n\t\treturn wm8350_led_disable(led);\n\t}\n\n\t \n\tuA = (led->max_uA_index * led->value) / LED_FULL;\n\tspin_unlock_irqrestore(&led->value_lock, flags);\n\tBUG_ON(uA >= ARRAY_SIZE(isink_cur));\n\n\tret = regulator_set_current_limit(led->isink, isink_cur[uA],\n\t\t\t\t\t  isink_cur[uA]);\n\tif (ret != 0) {\n\t\tdev_err(led->cdev.dev, \"Failed to set %duA: %d\\n\",\n\t\t\tisink_cur[uA], ret);\n\t\treturn ret;\n\t}\n\n\treturn wm8350_led_enable(led);\n}\n\nstatic void wm8350_led_shutdown(struct platform_device *pdev)\n{\n\tstruct wm8350_led *led = platform_get_drvdata(pdev);\n\n\tled->value = LED_OFF;\n\twm8350_led_disable(led);\n}\n\nstatic int wm8350_led_probe(struct platform_device *pdev)\n{\n\tstruct regulator *isink, *dcdc;\n\tstruct wm8350_led *led;\n\tstruct wm8350_led_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tint i;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pdata->max_uA < isink_cur[0]) {\n\t\tdev_err(&pdev->dev, \"Invalid maximum current %duA\\n\",\n\t\t\tpdata->max_uA);\n\t\treturn -EINVAL;\n\t}\n\n\tisink = devm_regulator_get(&pdev->dev, \"led_isink\");\n\tif (IS_ERR(isink)) {\n\t\tdev_err(&pdev->dev, \"%s: can't get ISINK\\n\", __func__);\n\t\treturn PTR_ERR(isink);\n\t}\n\n\tdcdc = devm_regulator_get(&pdev->dev, \"led_vcc\");\n\tif (IS_ERR(dcdc)) {\n\t\tdev_err(&pdev->dev, \"%s: can't get DCDC\\n\", __func__);\n\t\treturn PTR_ERR(dcdc);\n\t}\n\n\tled = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);\n\tif (led == NULL)\n\t\treturn -ENOMEM;\n\n\tled->cdev.brightness_set_blocking = wm8350_led_set;\n\tled->cdev.default_trigger = pdata->default_trigger;\n\tled->cdev.name = pdata->name;\n\tled->cdev.flags |= LED_CORE_SUSPENDRESUME;\n\tled->enabled = regulator_is_enabled(isink);\n\tled->isink = isink;\n\tled->dcdc = dcdc;\n\n\tfor (i = 0; i < ARRAY_SIZE(isink_cur) - 1; i++)\n\t\tif (isink_cur[i] >= pdata->max_uA)\n\t\t\tbreak;\n\tled->max_uA_index = i;\n\tif (pdata->max_uA != isink_cur[i])\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Maximum current %duA is not directly supported,\"\n\t\t\t \" check platform data\\n\",\n\t\t\t pdata->max_uA);\n\n\tspin_lock_init(&led->value_lock);\n\tled->value = LED_OFF;\n\tplatform_set_drvdata(pdev, led);\n\n\treturn led_classdev_register(&pdev->dev, &led->cdev);\n}\n\nstatic int wm8350_led_remove(struct platform_device *pdev)\n{\n\tstruct wm8350_led *led = platform_get_drvdata(pdev);\n\n\tled_classdev_unregister(&led->cdev);\n\twm8350_led_disable(led);\n\treturn 0;\n}\n\nstatic struct platform_driver wm8350_led_driver = {\n\t.driver = {\n\t\t   .name = \"wm8350-led\",\n\t\t   },\n\t.probe = wm8350_led_probe,\n\t.remove = wm8350_led_remove,\n\t.shutdown = wm8350_led_shutdown,\n};\n\nmodule_platform_driver(wm8350_led_driver);\n\nMODULE_AUTHOR(\"Mark Brown\");\nMODULE_DESCRIPTION(\"WM8350 LED driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm8350-led\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}