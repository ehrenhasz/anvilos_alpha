{
  "module_name": "leds-gpio.c",
  "hash_id": "23b37d05a4478393b174678b8cf2ca8d36a9a728dc622c97ae19a89ec99dc5bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-gpio.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include \"leds.h\"\n\nstruct gpio_led_data {\n\tstruct led_classdev cdev;\n\tstruct gpio_desc *gpiod;\n\tu8 can_sleep;\n\tu8 blinking;\n\tgpio_blink_set_t platform_gpio_blink_set;\n};\n\nstatic inline struct gpio_led_data *\n\t\t\tcdev_to_gpio_led_data(struct led_classdev *led_cdev)\n{\n\treturn container_of(led_cdev, struct gpio_led_data, cdev);\n}\n\nstatic void gpio_led_set(struct led_classdev *led_cdev,\n\tenum led_brightness value)\n{\n\tstruct gpio_led_data *led_dat = cdev_to_gpio_led_data(led_cdev);\n\tint level;\n\n\tif (value == LED_OFF)\n\t\tlevel = 0;\n\telse\n\t\tlevel = 1;\n\n\tif (led_dat->blinking) {\n\t\tled_dat->platform_gpio_blink_set(led_dat->gpiod, level,\n\t\t\t\t\t\t NULL, NULL);\n\t\tled_dat->blinking = 0;\n\t} else {\n\t\tif (led_dat->can_sleep)\n\t\t\tgpiod_set_value_cansleep(led_dat->gpiod, level);\n\t\telse\n\t\t\tgpiod_set_value(led_dat->gpiod, level);\n\t}\n}\n\nstatic int gpio_led_set_blocking(struct led_classdev *led_cdev,\n\tenum led_brightness value)\n{\n\tgpio_led_set(led_cdev, value);\n\treturn 0;\n}\n\nstatic int gpio_blink_set(struct led_classdev *led_cdev,\n\tunsigned long *delay_on, unsigned long *delay_off)\n{\n\tstruct gpio_led_data *led_dat = cdev_to_gpio_led_data(led_cdev);\n\n\tled_dat->blinking = 1;\n\treturn led_dat->platform_gpio_blink_set(led_dat->gpiod, GPIO_LED_BLINK,\n\t\t\t\t\t\tdelay_on, delay_off);\n}\n\nstatic int create_gpio_led(const struct gpio_led *template,\n\tstruct gpio_led_data *led_dat, struct device *parent,\n\tstruct fwnode_handle *fwnode, gpio_blink_set_t blink_set)\n{\n\tstruct led_init_data init_data = {};\n\tstruct pinctrl *pinctrl;\n\tint ret, state;\n\n\tled_dat->cdev.default_trigger = template->default_trigger;\n\tled_dat->can_sleep = gpiod_cansleep(led_dat->gpiod);\n\tif (!led_dat->can_sleep)\n\t\tled_dat->cdev.brightness_set = gpio_led_set;\n\telse\n\t\tled_dat->cdev.brightness_set_blocking = gpio_led_set_blocking;\n\tled_dat->blinking = 0;\n\tif (blink_set) {\n\t\tled_dat->platform_gpio_blink_set = blink_set;\n\t\tled_dat->cdev.blink_set = gpio_blink_set;\n\t}\n\tif (template->default_state == LEDS_GPIO_DEFSTATE_KEEP) {\n\t\tstate = gpiod_get_value_cansleep(led_dat->gpiod);\n\t\tif (state < 0)\n\t\t\treturn state;\n\t} else {\n\t\tstate = (template->default_state == LEDS_GPIO_DEFSTATE_ON);\n\t}\n\tled_dat->cdev.brightness = state;\n\tled_dat->cdev.max_brightness = 1;\n\tif (!template->retain_state_suspended)\n\t\tled_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;\n\tif (template->panic_indicator)\n\t\tled_dat->cdev.flags |= LED_PANIC_INDICATOR;\n\tif (template->retain_state_shutdown)\n\t\tled_dat->cdev.flags |= LED_RETAIN_AT_SHUTDOWN;\n\n\tret = gpiod_direction_output(led_dat->gpiod, state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (template->name) {\n\t\tled_dat->cdev.name = template->name;\n\t\tret = devm_led_classdev_register(parent, &led_dat->cdev);\n\t} else {\n\t\tinit_data.fwnode = fwnode;\n\t\tret = devm_led_classdev_register_ext(parent, &led_dat->cdev,\n\t\t\t\t\t\t     &init_data);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tpinctrl = devm_pinctrl_get_select_default(led_dat->cdev.dev);\n\tif (IS_ERR(pinctrl)) {\n\t\tret = PTR_ERR(pinctrl);\n\t\tif (ret != -ENODEV) {\n\t\t\tdev_warn(led_dat->cdev.dev,\n\t\t\t\t \"Failed to select %pOF pinctrl: %d\\n\",\n\t\t\t\t to_of_node(fwnode), ret);\n\t\t} else {\n\t\t\t \n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstruct gpio_leds_priv {\n\tint num_leds;\n\tstruct gpio_led_data leds[];\n};\n\nstatic struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fwnode_handle *child;\n\tstruct gpio_leds_priv *priv;\n\tint count, ret;\n\n\tcount = device_get_child_node_count(dev);\n\tif (!count)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpriv = devm_kzalloc(dev, struct_size(priv, leds, count), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tstruct gpio_led_data *led_dat = &priv->leds[priv->num_leds];\n\t\tstruct gpio_led led = {};\n\n\t\t \n\t\tled.gpiod = devm_fwnode_gpiod_get(dev, child, NULL, GPIOD_ASIS,\n\t\t\t\t\t\t  NULL);\n\t\tif (IS_ERR(led.gpiod)) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ERR_CAST(led.gpiod);\n\t\t}\n\n\t\tled_dat->gpiod = led.gpiod;\n\n\t\tled.default_state = led_init_default_state_get(child);\n\n\t\tif (fwnode_property_present(child, \"retain-state-suspended\"))\n\t\t\tled.retain_state_suspended = 1;\n\t\tif (fwnode_property_present(child, \"retain-state-shutdown\"))\n\t\t\tled.retain_state_shutdown = 1;\n\t\tif (fwnode_property_present(child, \"panic-indicator\"))\n\t\t\tled.panic_indicator = 1;\n\n\t\tret = create_gpio_led(&led, led_dat, dev, child, NULL);\n\t\tif (ret < 0) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t\t \n\t\tgpiod_set_consumer_name(led_dat->gpiod,\n\t\t\t\t\tled_dat->cdev.dev->kobj.name);\n\t\tpriv->num_leds++;\n\t}\n\n\treturn priv;\n}\n\nstatic const struct of_device_id of_gpio_leds_match[] = {\n\t{ .compatible = \"gpio-leds\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, of_gpio_leds_match);\n\nstatic struct gpio_desc *gpio_led_get_gpiod(struct device *dev, int idx,\n\t\t\t\t\t    const struct gpio_led *template)\n{\n\tstruct gpio_desc *gpiod;\n\tunsigned long flags = GPIOF_OUT_INIT_LOW;\n\tint ret;\n\n\t \n\tgpiod = devm_gpiod_get_index(dev, NULL, idx, GPIOD_OUT_LOW);\n\tif (!IS_ERR(gpiod)) {\n\t\tgpiod_set_consumer_name(gpiod, template->name);\n\t\treturn gpiod;\n\t}\n\tif (PTR_ERR(gpiod) != -ENOENT)\n\t\treturn gpiod;\n\n\t \n\n\t \n\tif (!gpio_is_valid(template->gpio))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (template->active_low)\n\t\tflags |= GPIOF_ACTIVE_LOW;\n\n\tret = devm_gpio_request_one(dev, template->gpio, flags,\n\t\t\t\t    template->name);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tgpiod = gpio_to_desc(template->gpio);\n\tif (!gpiod)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn gpiod;\n}\n\nstatic int gpio_led_probe(struct platform_device *pdev)\n{\n\tstruct gpio_led_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct gpio_leds_priv *priv;\n\tint i, ret = 0;\n\n\tif (pdata && pdata->num_leds) {\n\t\tpriv = devm_kzalloc(&pdev->dev, struct_size(priv, leds, pdata->num_leds),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!priv)\n\t\t\treturn -ENOMEM;\n\n\t\tpriv->num_leds = pdata->num_leds;\n\t\tfor (i = 0; i < priv->num_leds; i++) {\n\t\t\tconst struct gpio_led *template = &pdata->leds[i];\n\t\t\tstruct gpio_led_data *led_dat = &priv->leds[i];\n\n\t\t\tif (template->gpiod)\n\t\t\t\tled_dat->gpiod = template->gpiod;\n\t\t\telse\n\t\t\t\tled_dat->gpiod =\n\t\t\t\t\tgpio_led_get_gpiod(&pdev->dev,\n\t\t\t\t\t\t\t   i, template);\n\t\t\tif (IS_ERR(led_dat->gpiod)) {\n\t\t\t\tdev_info(&pdev->dev, \"Skipping unavailable LED gpio %d (%s)\\n\",\n\t\t\t\t\t template->gpio, template->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = create_gpio_led(template, led_dat,\n\t\t\t\t\t      &pdev->dev, NULL,\n\t\t\t\t\t      pdata->gpio_blink_set);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tpriv = gpio_leds_create(pdev);\n\t\tif (IS_ERR(priv))\n\t\t\treturn PTR_ERR(priv);\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn 0;\n}\n\nstatic void gpio_led_shutdown(struct platform_device *pdev)\n{\n\tstruct gpio_leds_priv *priv = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < priv->num_leds; i++) {\n\t\tstruct gpio_led_data *led = &priv->leds[i];\n\n\t\tif (!(led->cdev.flags & LED_RETAIN_AT_SHUTDOWN))\n\t\t\tgpio_led_set(&led->cdev, LED_OFF);\n\t}\n}\n\nstatic struct platform_driver gpio_led_driver = {\n\t.probe\t\t= gpio_led_probe,\n\t.shutdown\t= gpio_led_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"leds-gpio\",\n\t\t.of_match_table = of_gpio_leds_match,\n\t},\n};\n\nmodule_platform_driver(gpio_led_driver);\n\nMODULE_AUTHOR(\"Raphael Assenat <raph@8d.com>, Trent Piepho <tpiepho@freescale.com>\");\nMODULE_DESCRIPTION(\"GPIO LED driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:leds-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}