{
  "module_name": "leds-aw200xx.c",
  "hash_id": "c64d4261329ceb19cb3f1d68682525bf816e425a026f5d55279bab8bd12ede90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-aw200xx.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/container_of.h>\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/time.h>\n#include <linux/units.h>\n\n#define AW200XX_DIM_MAX                  (BIT(6) - 1)\n#define AW200XX_FADE_MAX                 (BIT(8) - 1)\n#define AW200XX_IMAX_DEFAULT_uA          60000\n#define AW200XX_IMAX_MAX_uA              160000\n#define AW200XX_IMAX_MIN_uA              3300\n\n \n#define AW200XX_REG_PAGE0_BASE 0xc000\n\n \n#define AW200XX_REG_PAGE       0xF0\n#define AW200XX_PAGE_MASK      (GENMASK(7, 6) | GENMASK(2, 0))\n#define AW200XX_PAGE_SHIFT     0\n#define AW200XX_NUM_PAGES      6\n#define AW200XX_PAGE_SIZE      256\n#define AW200XX_REG(page, reg) \\\n\t(AW200XX_REG_PAGE0_BASE + (page) * AW200XX_PAGE_SIZE + (reg))\n#define AW200XX_REG_MAX \\\n\tAW200XX_REG(AW200XX_NUM_PAGES - 1, AW200XX_PAGE_SIZE - 1)\n#define AW200XX_PAGE0 0\n#define AW200XX_PAGE1 1\n#define AW200XX_PAGE2 2\n#define AW200XX_PAGE3 3\n#define AW200XX_PAGE4 4\n#define AW200XX_PAGE5 5\n\n \n#define AW200XX_REG_IDR       AW200XX_REG(AW200XX_PAGE0, 0x00)\n#define AW200XX_IDR_CHIPID    0x18\n\n \n#define AW200XX_REG_SLPCR     AW200XX_REG(AW200XX_PAGE0, 0x01)\n#define AW200XX_SLPCR_ACTIVE  0x00\n\n \n#define AW200XX_REG_RSTR      AW200XX_REG(AW200XX_PAGE0, 0x02)\n#define AW200XX_RSTR_RESET    0x01\n\n \n#define AW200XX_REG_GCCR        AW200XX_REG(AW200XX_PAGE0, 0x03)\n#define AW200XX_GCCR_IMAX_MASK  GENMASK(7, 4)\n#define AW200XX_GCCR_IMAX(x)    ((x) << 4)\n#define AW200XX_GCCR_ALLON      BIT(3)\n\n \n#define AW200XX_REG_FCD       AW200XX_REG(AW200XX_PAGE0, 0x04)\n#define AW200XX_FCD_CLEAR     0x01\n\n \n#define AW200XX_REG_DSIZE          AW200XX_REG(AW200XX_PAGE0, 0x80)\n#define AW200XX_DSIZE_COLUMNS_MAX  12\n\n#define AW200XX_LED2REG(x, columns) \\\n\t((x) + (((x) / (columns)) * (AW200XX_DSIZE_COLUMNS_MAX - (columns))))\n\n \n#define AW200XX_REG_DIM_PAGE1(x, columns) \\\n\tAW200XX_REG(AW200XX_PAGE1, AW200XX_LED2REG(x, columns))\n\n \n#define AW200XX_REG_DIM(x, columns) \\\n\tAW200XX_REG(AW200XX_PAGE4, AW200XX_LED2REG(x, columns) * 2)\n#define AW200XX_REG_DIM2FADE(x) ((x) + 1)\n\n \n#define AW200XX_DUTY_RATIO(rows) \\\n\t(((592UL * USEC_PER_SEC) / 600500UL) * (MILLI / (rows)) / MILLI)\n\nstruct aw200xx_chipdef {\n\tu32 channels;\n\tu32 display_size_rows_max;\n\tu32 display_size_columns;\n};\n\nstruct aw200xx_led {\n\tstruct led_classdev cdev;\n\tstruct aw200xx *chip;\n\tint dim;\n\tu32 num;\n};\n\nstruct aw200xx {\n\tconst struct aw200xx_chipdef *cdef;\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct mutex mutex;\n\tu32 num_leds;\n\tu32 display_rows;\n\tstruct aw200xx_led leds[];\n};\n\nstatic ssize_t dim_show(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct led_classdev *cdev = dev_get_drvdata(dev);\n\tstruct aw200xx_led *led = container_of(cdev, struct aw200xx_led, cdev);\n\tint dim = led->dim;\n\n\tif (dim < 0)\n\t\treturn sysfs_emit(buf, \"auto\\n\");\n\n\treturn sysfs_emit(buf, \"%d\\n\", dim);\n}\n\nstatic ssize_t dim_store(struct device *dev, struct device_attribute *devattr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct led_classdev *cdev = dev_get_drvdata(dev);\n\tstruct aw200xx_led *led = container_of(cdev, struct aw200xx_led, cdev);\n\tstruct aw200xx *chip = led->chip;\n\tu32 columns = chip->cdef->display_size_columns;\n\tint dim;\n\tssize_t ret;\n\n\tif (sysfs_streq(buf, \"auto\")) {\n\t\tdim = -1;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &dim);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (dim > AW200XX_DIM_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&chip->mutex);\n\n\tif (dim >= 0) {\n\t\tret = regmap_write(chip->regmap,\n\t\t\t\t   AW200XX_REG_DIM_PAGE1(led->num, columns),\n\t\t\t\t   dim);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tled->dim = dim;\n\tret = count;\n\nout_unlock:\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(dim);\n\nstatic struct attribute *dim_attrs[] = {\n\t&dev_attr_dim.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(dim);\n\nstatic int aw200xx_brightness_set(struct led_classdev *cdev,\n\t\t\t\t  enum led_brightness brightness)\n{\n\tstruct aw200xx_led *led = container_of(cdev, struct aw200xx_led, cdev);\n\tstruct aw200xx *chip = led->chip;\n\tint dim;\n\tu32 reg;\n\tint ret;\n\n\tmutex_lock(&chip->mutex);\n\n\treg = AW200XX_REG_DIM(led->num, chip->cdef->display_size_columns);\n\n\tdim = led->dim;\n\tif (dim < 0)\n\t\tdim = max_t(int,\n\t\t\t    brightness / (AW200XX_FADE_MAX / AW200XX_DIM_MAX),\n\t\t\t    1);\n\n\tret = regmap_write(chip->regmap, reg, dim);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_write(chip->regmap,\n\t\t\t   AW200XX_REG_DIM2FADE(reg), brightness);\n\nout_unlock:\n\tmutex_unlock(&chip->mutex);\n\n\treturn ret;\n}\n\nstatic u32 aw200xx_imax_from_global(const struct aw200xx *const chip,\n\t\t\t\t    u32 global_imax_uA)\n{\n\tu64 led_imax_uA;\n\n\t \n\tled_imax_uA = global_imax_uA * AW200XX_DUTY_RATIO(chip->display_rows);\n\tdo_div(led_imax_uA, MILLI);\n\n\treturn led_imax_uA;\n}\n\nstatic u32 aw200xx_imax_to_global(const struct aw200xx *const chip,\n\t\t\t\t  u32 led_imax_uA)\n{\n\tu32 duty = AW200XX_DUTY_RATIO(chip->display_rows);\n\n\t \n\treturn (led_imax_uA * 1000U) / duty;\n}\n\n#define AW200XX_IMAX_MULTIPLIER1    10000\n#define AW200XX_IMAX_MULTIPLIER2    3333\n#define AW200XX_IMAX_BASE_VAL1      0\n#define AW200XX_IMAX_BASE_VAL2      8\n\n \nstatic int aw200xx_set_imax(const struct aw200xx *const chip,\n\t\t\t    u32 led_imax_uA)\n{\n\tu32 g_imax_uA = aw200xx_imax_to_global(chip, led_imax_uA);\n\tu32 coeff_table[] = {1, 2, 3, 4, 6, 8, 12, 16};\n\tu32 gccr_imax = UINT_MAX;\n\tu32 cur_imax = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(coeff_table); i++) {\n\t\tu32 imax;\n\n\t\t \n\t\timax = coeff_table[i] * AW200XX_IMAX_MULTIPLIER1;\n\t\tif (g_imax_uA >= imax && imax > cur_imax) {\n\t\t\tcur_imax = imax;\n\t\t\tgccr_imax = i + AW200XX_IMAX_BASE_VAL1;\n\t\t}\n\n\t\timax = coeff_table[i] * AW200XX_IMAX_MULTIPLIER2;\n\t\timax = DIV_ROUND_CLOSEST(imax, 100) * 100;\n\t\tif (g_imax_uA >= imax && imax > cur_imax) {\n\t\t\tcur_imax = imax;\n\t\t\tgccr_imax = i + AW200XX_IMAX_BASE_VAL2;\n\t\t}\n\t}\n\n\tif (gccr_imax == UINT_MAX)\n\t\treturn -EINVAL;\n\n\treturn regmap_update_bits(chip->regmap, AW200XX_REG_GCCR,\n\t\t\t\t  AW200XX_GCCR_IMAX_MASK,\n\t\t\t\t  AW200XX_GCCR_IMAX(gccr_imax));\n}\n\nstatic int aw200xx_chip_reset(const struct aw200xx *const chip)\n{\n\tint ret;\n\n\tret = regmap_write(chip->regmap, AW200XX_REG_RSTR, AW200XX_RSTR_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\tregcache_mark_dirty(chip->regmap);\n\treturn regmap_write(chip->regmap, AW200XX_REG_FCD, AW200XX_FCD_CLEAR);\n}\n\nstatic int aw200xx_chip_init(const struct aw200xx *const chip)\n{\n\tint ret;\n\n\tret = regmap_write(chip->regmap, AW200XX_REG_DSIZE,\n\t\t\t   chip->display_rows - 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(chip->regmap, AW200XX_REG_SLPCR,\n\t\t\t   AW200XX_SLPCR_ACTIVE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(chip->regmap, AW200XX_REG_GCCR,\n\t\t\t\t  AW200XX_GCCR_ALLON, AW200XX_GCCR_ALLON);\n}\n\nstatic int aw200xx_chip_check(const struct aw200xx *const chip)\n{\n\tstruct device *dev = &chip->client->dev;\n\tu32 chipid;\n\tint ret;\n\n\tret = regmap_read(chip->regmap, AW200XX_REG_IDR, &chipid);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to read chip ID\\n\");\n\n\tif (chipid != AW200XX_IDR_CHIPID)\n\t\treturn dev_err_probe(dev, -ENODEV,\n\t\t\t\t     \"Chip reported wrong ID: %x\\n\", chipid);\n\n\treturn 0;\n}\n\nstatic int aw200xx_probe_fw(struct device *dev, struct aw200xx *chip)\n{\n\tstruct fwnode_handle *child;\n\tu32 current_min, current_max, min_uA;\n\tint ret;\n\tint i;\n\n\tret = device_property_read_u32(dev, \"awinic,display-rows\",\n\t\t\t\t       &chip->display_rows);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to read 'display-rows' property\\n\");\n\n\tif (!chip->display_rows ||\n\t    chip->display_rows > chip->cdef->display_size_rows_max) {\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Invalid leds display size %u\\n\",\n\t\t\t\t     chip->display_rows);\n\t}\n\n\tcurrent_max = aw200xx_imax_from_global(chip, AW200XX_IMAX_MAX_uA);\n\tcurrent_min = aw200xx_imax_from_global(chip, AW200XX_IMAX_MIN_uA);\n\tmin_uA = UINT_MAX;\n\ti = 0;\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tstruct led_init_data init_data = {};\n\t\tstruct aw200xx_led *led;\n\t\tu32 source, imax;\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &source);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Missing reg property\\n\");\n\t\t\tchip->num_leds--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (source >= chip->cdef->channels) {\n\t\t\tdev_err(dev, \"LED reg %u out of range (max %u)\\n\",\n\t\t\t\tsource, chip->cdef->channels);\n\t\t\tchip->num_leds--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = fwnode_property_read_u32(child, \"led-max-microamp\",\n\t\t\t\t\t       &imax);\n\t\tif (ret) {\n\t\t\tdev_info(&chip->client->dev,\n\t\t\t\t \"DT property led-max-microamp is missing\\n\");\n\t\t} else if (imax < current_min || imax > current_max) {\n\t\t\tdev_err(dev, \"Invalid value %u for led-max-microamp\\n\",\n\t\t\t\timax);\n\t\t\tchip->num_leds--;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tmin_uA = min(min_uA, imax);\n\t\t}\n\n\t\tled = &chip->leds[i];\n\t\tled->dim = -1;\n\t\tled->num = source;\n\t\tled->chip = chip;\n\t\tled->cdev.brightness_set_blocking = aw200xx_brightness_set;\n\t\tled->cdev.groups = dim_groups;\n\t\tinit_data.fwnode = child;\n\n\t\tret = devm_led_classdev_register_ext(dev, &led->cdev,\n\t\t\t\t\t\t     &init_data);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\tbreak;\n\t\t}\n\n\t\ti++;\n\t}\n\n\tif (!chip->num_leds)\n\t\treturn -EINVAL;\n\n\tif (min_uA == UINT_MAX) {\n\t\tmin_uA = aw200xx_imax_from_global(chip,\n\t\t\t\t\t\t  AW200XX_IMAX_DEFAULT_uA);\n\t}\n\n\treturn aw200xx_set_imax(chip, min_uA);\n}\n\nstatic const struct regmap_range_cfg aw200xx_ranges[] = {\n\t{\n\t\t.name = \"aw200xx\",\n\t\t.range_min = 0,\n\t\t.range_max = AW200XX_REG_MAX,\n\t\t.selector_reg = AW200XX_REG_PAGE,\n\t\t.selector_mask = AW200XX_PAGE_MASK,\n\t\t.selector_shift = AW200XX_PAGE_SHIFT,\n\t\t.window_start = 0,\n\t\t.window_len = AW200XX_PAGE_SIZE,\n\t},\n};\n\nstatic const struct regmap_range aw200xx_writeonly_ranges[] = {\n\tregmap_reg_range(AW200XX_REG(AW200XX_PAGE1, 0x00), AW200XX_REG_MAX),\n};\n\nstatic const struct regmap_access_table aw200xx_readable_table = {\n\t.no_ranges = aw200xx_writeonly_ranges,\n\t.n_no_ranges = ARRAY_SIZE(aw200xx_writeonly_ranges),\n};\n\nstatic const struct regmap_range aw200xx_readonly_ranges[] = {\n\tregmap_reg_range(AW200XX_REG_IDR, AW200XX_REG_IDR),\n};\n\nstatic const struct regmap_access_table aw200xx_writeable_table = {\n\t.no_ranges = aw200xx_readonly_ranges,\n\t.n_no_ranges = ARRAY_SIZE(aw200xx_readonly_ranges),\n};\n\nstatic const struct regmap_config aw200xx_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = AW200XX_REG_MAX,\n\t.ranges = aw200xx_ranges,\n\t.num_ranges = ARRAY_SIZE(aw200xx_ranges),\n\t.rd_table = &aw200xx_readable_table,\n\t.wr_table = &aw200xx_writeable_table,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int aw200xx_probe(struct i2c_client *client)\n{\n\tconst struct aw200xx_chipdef *cdef;\n\tstruct aw200xx *chip;\n\tint count;\n\tint ret;\n\n\tcdef = device_get_match_data(&client->dev);\n\tif (!cdef)\n\t\treturn -ENODEV;\n\n\tcount = device_get_child_node_count(&client->dev);\n\tif (!count || count > cdef->channels)\n\t\treturn dev_err_probe(&client->dev, -EINVAL,\n\t\t\t\t     \"Incorrect number of leds (%d)\", count);\n\n\tchip = devm_kzalloc(&client->dev, struct_size(chip, leds, count),\n\t\t\t    GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->cdef = cdef;\n\tchip->num_leds = count;\n\tchip->client = client;\n\ti2c_set_clientdata(client, chip);\n\n\tchip->regmap = devm_regmap_init_i2c(client, &aw200xx_regmap_config);\n\tif (IS_ERR(chip->regmap))\n\t\treturn PTR_ERR(chip->regmap);\n\n\tret = aw200xx_chip_check(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&chip->mutex);\n\n\t \n\tmutex_lock(&chip->mutex);\n\n\tret = aw200xx_chip_reset(chip);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = aw200xx_probe_fw(&client->dev, chip);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = aw200xx_chip_init(chip);\n\nout_unlock:\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic void aw200xx_remove(struct i2c_client *client)\n{\n\tstruct aw200xx *chip = i2c_get_clientdata(client);\n\n\taw200xx_chip_reset(chip);\n\tmutex_destroy(&chip->mutex);\n}\n\nstatic const struct aw200xx_chipdef aw20036_cdef = {\n\t.channels = 36,\n\t.display_size_rows_max = 3,\n\t.display_size_columns = 12,\n};\n\nstatic const struct aw200xx_chipdef aw20054_cdef = {\n\t.channels = 54,\n\t.display_size_rows_max = 6,\n\t.display_size_columns = 9,\n};\n\nstatic const struct aw200xx_chipdef aw20072_cdef = {\n\t.channels = 72,\n\t.display_size_rows_max = 6,\n\t.display_size_columns = 12,\n};\n\nstatic const struct i2c_device_id aw200xx_id[] = {\n\t{ \"aw20036\" },\n\t{ \"aw20054\" },\n\t{ \"aw20072\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, aw200xx_id);\n\nstatic const struct of_device_id aw200xx_match_table[] = {\n\t{ .compatible = \"awinic,aw20036\", .data = &aw20036_cdef, },\n\t{ .compatible = \"awinic,aw20054\", .data = &aw20054_cdef, },\n\t{ .compatible = \"awinic,aw20072\", .data = &aw20072_cdef, },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, aw200xx_match_table);\n\nstatic struct i2c_driver aw200xx_driver = {\n\t.driver = {\n\t\t.name = \"aw200xx\",\n\t\t.of_match_table = aw200xx_match_table,\n\t},\n\t.probe = aw200xx_probe,\n\t.remove = aw200xx_remove,\n\t.id_table = aw200xx_id,\n};\nmodule_i2c_driver(aw200xx_driver);\n\nMODULE_AUTHOR(\"Martin Kurbanov <mmkurbanov@sberdevices.ru>\");\nMODULE_DESCRIPTION(\"AW200XX LED driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}