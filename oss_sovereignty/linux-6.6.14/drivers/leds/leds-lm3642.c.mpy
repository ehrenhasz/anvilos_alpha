{
  "module_name": "leds-lm3642.c",
  "hash_id": "0a6f08f54a7e9a2ce6b3e8b2e50c2931f8e0b89a3181507970803945398078cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lm3642.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/fs.h>\n#include <linux/regmap.h>\n#include <linux/platform_data/leds-lm3642.h>\n\n#define\tREG_FILT_TIME\t\t\t(0x0)\n#define\tREG_IVFM_MODE\t\t\t(0x1)\n#define\tREG_TORCH_TIME\t\t\t(0x6)\n#define\tREG_FLASH\t\t\t(0x8)\n#define\tREG_I_CTRL\t\t\t(0x9)\n#define\tREG_ENABLE\t\t\t(0xA)\n#define\tREG_FLAG\t\t\t(0xB)\n#define\tREG_MAX\t\t\t\t(0xB)\n\n#define\tUVLO_EN_SHIFT\t\t\t(7)\n#define\tIVM_D_TH_SHIFT\t\t\t(2)\n#define\tTORCH_RAMP_UP_TIME_SHIFT\t(3)\n#define\tTORCH_RAMP_DN_TIME_SHIFT\t(0)\n#define\tINDUCTOR_I_LIMIT_SHIFT\t\t(6)\n#define\tFLASH_RAMP_TIME_SHIFT\t\t(3)\n#define\tFLASH_TOUT_TIME_SHIFT\t\t(0)\n#define\tTORCH_I_SHIFT\t\t\t(4)\n#define\tFLASH_I_SHIFT\t\t\t(0)\n#define\tIVFM_SHIFT\t\t\t(7)\n#define\tTX_PIN_EN_SHIFT\t\t\t(6)\n#define\tSTROBE_PIN_EN_SHIFT\t\t(5)\n#define\tTORCH_PIN_EN_SHIFT\t\t(4)\n#define\tMODE_BITS_SHIFT\t\t\t(0)\n\n#define\tUVLO_EN_MASK\t\t\t(0x1)\n#define\tIVM_D_TH_MASK\t\t\t(0x7)\n#define\tTORCH_RAMP_UP_TIME_MASK\t\t(0x7)\n#define\tTORCH_RAMP_DN_TIME_MASK\t\t(0x7)\n#define\tINDUCTOR_I_LIMIT_MASK\t\t(0x1)\n#define\tFLASH_RAMP_TIME_MASK\t\t(0x7)\n#define\tFLASH_TOUT_TIME_MASK\t\t(0x7)\n#define\tTORCH_I_MASK\t\t\t(0x7)\n#define\tFLASH_I_MASK\t\t\t(0xF)\n#define\tIVFM_MASK\t\t\t(0x1)\n#define\tTX_PIN_EN_MASK\t\t\t(0x1)\n#define\tSTROBE_PIN_EN_MASK\t\t(0x1)\n#define\tTORCH_PIN_EN_MASK\t\t(0x1)\n#define\tMODE_BITS_MASK\t\t\t(0x73)\n#define EX_PIN_CONTROL_MASK\t\t(0x71)\n#define EX_PIN_ENABLE_MASK\t\t(0x70)\n\nenum lm3642_mode {\n\tMODES_STASNDBY = 0,\n\tMODES_INDIC,\n\tMODES_TORCH,\n\tMODES_FLASH\n};\n\nstruct lm3642_chip_data {\n\tstruct device *dev;\n\n\tstruct led_classdev cdev_flash;\n\tstruct led_classdev cdev_torch;\n\tstruct led_classdev cdev_indicator;\n\n\tu8 br_flash;\n\tu8 br_torch;\n\tu8 br_indicator;\n\n\tenum lm3642_torch_pin_enable torch_pin;\n\tenum lm3642_strobe_pin_enable strobe_pin;\n\tenum lm3642_tx_pin_enable tx_pin;\n\n\tstruct lm3642_platform_data *pdata;\n\tstruct regmap *regmap;\n\tstruct mutex lock;\n\n\tunsigned int last_flag;\n};\n\n \nstatic int lm3642_chip_init(struct lm3642_chip_data *chip)\n{\n\tint ret;\n\tstruct lm3642_platform_data *pdata = chip->pdata;\n\n\t \n\tret = regmap_update_bits(chip->regmap, REG_ENABLE, EX_PIN_ENABLE_MASK,\n\t\t\t\t pdata->tx_pin);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Failed to update REG_ENABLE Register\\n\");\n\treturn ret;\n}\n\n \nstatic int lm3642_control(struct lm3642_chip_data *chip,\n\t\t\t  u8 brightness, enum lm3642_mode opmode)\n{\n\tint ret;\n\n\tret = regmap_read(chip->regmap, REG_FLAG, &chip->last_flag);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to read REG_FLAG Register\\n\");\n\t\treturn ret;\n\t}\n\n\tif (chip->last_flag)\n\t\tdev_info(chip->dev, \"Last FLAG is 0x%x\\n\", chip->last_flag);\n\n\t \n\tif (!brightness)\n\t\topmode = MODES_STASNDBY;\n\n\tswitch (opmode) {\n\tcase MODES_TORCH:\n\t\tret = regmap_update_bits(chip->regmap, REG_I_CTRL,\n\t\t\t\t\t TORCH_I_MASK << TORCH_I_SHIFT,\n\t\t\t\t\t (brightness - 1) << TORCH_I_SHIFT);\n\n\t\tif (chip->torch_pin)\n\t\t\topmode |= (TORCH_PIN_EN_MASK << TORCH_PIN_EN_SHIFT);\n\t\tbreak;\n\n\tcase MODES_FLASH:\n\t\tret = regmap_update_bits(chip->regmap, REG_I_CTRL,\n\t\t\t\t\t FLASH_I_MASK << FLASH_I_SHIFT,\n\t\t\t\t\t (brightness - 1) << FLASH_I_SHIFT);\n\n\t\tif (chip->strobe_pin)\n\t\t\topmode |= (STROBE_PIN_EN_MASK << STROBE_PIN_EN_SHIFT);\n\t\tbreak;\n\n\tcase MODES_INDIC:\n\t\tret = regmap_update_bits(chip->regmap, REG_I_CTRL,\n\t\t\t\t\t TORCH_I_MASK << TORCH_I_SHIFT,\n\t\t\t\t\t (brightness - 1) << TORCH_I_SHIFT);\n\t\tbreak;\n\n\tcase MODES_STASNDBY:\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to write REG_I_CTRL Register\\n\");\n\t\treturn ret;\n\t}\n\n\tif (chip->tx_pin)\n\t\topmode |= (TX_PIN_EN_MASK << TX_PIN_EN_SHIFT);\n\n\tret = regmap_update_bits(chip->regmap, REG_ENABLE,\n\t\t\t\t MODE_BITS_MASK << MODE_BITS_SHIFT,\n\t\t\t\t opmode << MODE_BITS_SHIFT);\n\treturn ret;\n}\n\n \n\n \nstatic ssize_t torch_pin_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tssize_t ret;\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3642_chip_data *chip =\n\t    container_of(led_cdev, struct lm3642_chip_data, cdev_indicator);\n\tunsigned int state;\n\n\tret = kstrtouint(buf, 10, &state);\n\tif (ret)\n\t\treturn ret;\n\tif (state != 0)\n\t\tstate = 0x01 << TORCH_PIN_EN_SHIFT;\n\n\tchip->torch_pin = state;\n\tret = regmap_update_bits(chip->regmap, REG_ENABLE,\n\t\t\t\t TORCH_PIN_EN_MASK << TORCH_PIN_EN_SHIFT,\n\t\t\t\t state);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"%s:i2c access fail to register\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_WO(torch_pin);\n\nstatic int lm3642_torch_brightness_set(struct led_classdev *cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct lm3642_chip_data *chip =\n\t    container_of(cdev, struct lm3642_chip_data, cdev_torch);\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\tchip->br_torch = brightness;\n\tret = lm3642_control(chip, chip->br_torch, MODES_TORCH);\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\n \n\n \nstatic ssize_t strobe_pin_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tssize_t ret;\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3642_chip_data *chip =\n\t    container_of(led_cdev, struct lm3642_chip_data, cdev_indicator);\n\tunsigned int state;\n\n\tret = kstrtouint(buf, 10, &state);\n\tif (ret)\n\t\treturn ret;\n\tif (state != 0)\n\t\tstate = 0x01 << STROBE_PIN_EN_SHIFT;\n\n\tchip->strobe_pin = state;\n\tret = regmap_update_bits(chip->regmap, REG_ENABLE,\n\t\t\t\t STROBE_PIN_EN_MASK << STROBE_PIN_EN_SHIFT,\n\t\t\t\t state);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"%s:i2c access fail to register\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_WO(strobe_pin);\n\nstatic int lm3642_strobe_brightness_set(struct led_classdev *cdev,\n\t\t\t\t\t enum led_brightness brightness)\n{\n\tstruct lm3642_chip_data *chip =\n\t    container_of(cdev, struct lm3642_chip_data, cdev_flash);\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\tchip->br_flash = brightness;\n\tret = lm3642_control(chip, chip->br_flash, MODES_FLASH);\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\n \nstatic int lm3642_indicator_brightness_set(struct led_classdev *cdev,\n\t\t\t\t\t    enum led_brightness brightness)\n{\n\tstruct lm3642_chip_data *chip =\n\t    container_of(cdev, struct lm3642_chip_data, cdev_indicator);\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\tchip->br_indicator = brightness;\n\tret = lm3642_control(chip, chip->br_indicator, MODES_INDIC);\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nstatic const struct regmap_config lm3642_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = REG_MAX,\n};\n\nstatic struct attribute *lm3642_flash_attrs[] = {\n\t&dev_attr_strobe_pin.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(lm3642_flash);\n\nstatic struct attribute *lm3642_torch_attrs[] = {\n\t&dev_attr_torch_pin.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(lm3642_torch);\n\nstatic int lm3642_probe(struct i2c_client *client)\n{\n\tstruct lm3642_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct lm3642_chip_data *chip;\n\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"i2c functionality check fail.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (pdata == NULL) {\n\t\tdev_err(&client->dev, \"needs Platform Data.\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\tchip = devm_kzalloc(&client->dev,\n\t\t\t    sizeof(struct lm3642_chip_data), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = &client->dev;\n\tchip->pdata = pdata;\n\n\tchip->tx_pin = pdata->tx_pin;\n\tchip->torch_pin = pdata->torch_pin;\n\tchip->strobe_pin = pdata->strobe_pin;\n\n\tchip->regmap = devm_regmap_init_i2c(client, &lm3642_regmap);\n\tif (IS_ERR(chip->regmap)) {\n\t\terr = PTR_ERR(chip->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tmutex_init(&chip->lock);\n\ti2c_set_clientdata(client, chip);\n\n\terr = lm3642_chip_init(chip);\n\tif (err < 0)\n\t\tgoto err_out;\n\n\t \n\tchip->cdev_flash.name = \"flash\";\n\tchip->cdev_flash.max_brightness = 16;\n\tchip->cdev_flash.brightness_set_blocking = lm3642_strobe_brightness_set;\n\tchip->cdev_flash.default_trigger = \"flash\";\n\tchip->cdev_flash.groups = lm3642_flash_groups;\n\terr = led_classdev_register(&client->dev, &chip->cdev_flash);\n\tif (err < 0) {\n\t\tdev_err(chip->dev, \"failed to register flash\\n\");\n\t\tgoto err_out;\n\t}\n\n\t \n\tchip->cdev_torch.name = \"torch\";\n\tchip->cdev_torch.max_brightness = 8;\n\tchip->cdev_torch.brightness_set_blocking = lm3642_torch_brightness_set;\n\tchip->cdev_torch.default_trigger = \"torch\";\n\tchip->cdev_torch.groups = lm3642_torch_groups;\n\terr = led_classdev_register(&client->dev, &chip->cdev_torch);\n\tif (err < 0) {\n\t\tdev_err(chip->dev, \"failed to register torch\\n\");\n\t\tgoto err_create_torch_file;\n\t}\n\n\t \n\tchip->cdev_indicator.name = \"indicator\";\n\tchip->cdev_indicator.max_brightness = 8;\n\tchip->cdev_indicator.brightness_set_blocking =\n\t\t\t\t\t\tlm3642_indicator_brightness_set;\n\terr = led_classdev_register(&client->dev, &chip->cdev_indicator);\n\tif (err < 0) {\n\t\tdev_err(chip->dev, \"failed to register indicator\\n\");\n\t\tgoto err_create_indicator_file;\n\t}\n\n\tdev_info(&client->dev, \"LM3642 is initialized\\n\");\n\treturn 0;\n\nerr_create_indicator_file:\n\tled_classdev_unregister(&chip->cdev_torch);\nerr_create_torch_file:\n\tled_classdev_unregister(&chip->cdev_flash);\nerr_out:\n\treturn err;\n}\n\nstatic void lm3642_remove(struct i2c_client *client)\n{\n\tstruct lm3642_chip_data *chip = i2c_get_clientdata(client);\n\n\tled_classdev_unregister(&chip->cdev_indicator);\n\tled_classdev_unregister(&chip->cdev_torch);\n\tled_classdev_unregister(&chip->cdev_flash);\n\tregmap_write(chip->regmap, REG_ENABLE, 0);\n}\n\nstatic const struct i2c_device_id lm3642_id[] = {\n\t{LM3642_NAME, 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, lm3642_id);\n\nstatic struct i2c_driver lm3642_i2c_driver = {\n\t.driver = {\n\t\t   .name = LM3642_NAME,\n\t\t   .pm = NULL,\n\t\t   },\n\t.probe = lm3642_probe,\n\t.remove = lm3642_remove,\n\t.id_table = lm3642_id,\n};\n\nmodule_i2c_driver(lm3642_i2c_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments Flash Lighting driver for LM3642\");\nMODULE_AUTHOR(\"Daniel Jeong <daniel.jeong@ti.com>\");\nMODULE_AUTHOR(\"G.Shark Jeong <gshark.jeong@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}