{
  "module_name": "leds-spi-byte.c",
  "hash_id": "2cad57a75ffd4426f5b9b033b2618fb17a1a8ada13332dc9417369453d4e8db3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-spi-byte.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n#include <linux/mutex.h>\n#include <uapi/linux/uleds.h>\n\nstruct spi_byte_chipdef {\n\t \n\tu8\toff_value;\n\t \n\tu8\tmax_value;\n};\n\nstruct spi_byte_led {\n\tstruct led_classdev\t\tldev;\n\tstruct spi_device\t\t*spi;\n\tchar\t\t\t\tname[LED_MAX_NAME_SIZE];\n\tstruct mutex\t\t\tmutex;\n\tconst struct spi_byte_chipdef\t*cdef;\n};\n\nstatic const struct spi_byte_chipdef ubnt_acb_spi_led_cdef = {\n\t.off_value = 0x0,\n\t.max_value = 0x3F,\n};\n\nstatic const struct of_device_id spi_byte_dt_ids[] = {\n\t{ .compatible = \"ubnt,acb-spi-led\", .data = &ubnt_acb_spi_led_cdef },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, spi_byte_dt_ids);\n\nstatic int spi_byte_brightness_set_blocking(struct led_classdev *dev,\n\t\t\t\t\t    enum led_brightness brightness)\n{\n\tstruct spi_byte_led *led = container_of(dev, struct spi_byte_led, ldev);\n\tu8 value;\n\tint ret;\n\n\tvalue = (u8) brightness + led->cdef->off_value;\n\n\tmutex_lock(&led->mutex);\n\tret = spi_write(led->spi, &value, sizeof(value));\n\tmutex_unlock(&led->mutex);\n\n\treturn ret;\n}\n\nstatic int spi_byte_probe(struct spi_device *spi)\n{\n\tstruct device_node *child;\n\tstruct device *dev = &spi->dev;\n\tstruct spi_byte_led *led;\n\tconst char *name = \"leds-spi-byte::\";\n\tconst char *state;\n\tint ret;\n\n\tif (of_get_available_child_count(dev_of_node(dev)) != 1) {\n\t\tdev_err(dev, \"Device must have exactly one LED sub-node.\");\n\t\treturn -EINVAL;\n\t}\n\tchild = of_get_next_available_child(dev_of_node(dev), NULL);\n\n\tled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tof_property_read_string(child, \"label\", &name);\n\tstrscpy(led->name, name, sizeof(led->name));\n\tled->spi = spi;\n\tmutex_init(&led->mutex);\n\tled->cdef = device_get_match_data(dev);\n\tled->ldev.name = led->name;\n\tled->ldev.brightness = LED_OFF;\n\tled->ldev.max_brightness = led->cdef->max_value - led->cdef->off_value;\n\tled->ldev.brightness_set_blocking = spi_byte_brightness_set_blocking;\n\n\tstate = of_get_property(child, \"default-state\", NULL);\n\tif (state) {\n\t\tif (!strcmp(state, \"on\")) {\n\t\t\tled->ldev.brightness = led->ldev.max_brightness;\n\t\t} else if (strcmp(state, \"off\")) {\n\t\t\t \n\t\t\tdev_err(dev, \"default-state can only be 'on' or 'off'\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tspi_byte_brightness_set_blocking(&led->ldev,\n\t\t\t\t\t led->ldev.brightness);\n\n\tret = devm_led_classdev_register(&spi->dev, &led->ldev);\n\tif (ret) {\n\t\tmutex_destroy(&led->mutex);\n\t\treturn ret;\n\t}\n\tspi_set_drvdata(spi, led);\n\n\treturn 0;\n}\n\nstatic void spi_byte_remove(struct spi_device *spi)\n{\n\tstruct spi_byte_led\t*led = spi_get_drvdata(spi);\n\n\tmutex_destroy(&led->mutex);\n}\n\nstatic struct spi_driver spi_byte_driver = {\n\t.probe\t\t= spi_byte_probe,\n\t.remove\t\t= spi_byte_remove,\n\t.driver = {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= spi_byte_dt_ids,\n\t},\n};\n\nmodule_spi_driver(spi_byte_driver);\n\nMODULE_AUTHOR(\"Christian Mauderer <oss@c-mauderer.de>\");\nMODULE_DESCRIPTION(\"single byte SPI LED driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"spi:leds-spi-byte\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}