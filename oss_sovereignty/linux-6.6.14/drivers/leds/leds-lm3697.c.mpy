{
  "module_name": "leds-lm3697.c",
  "hash_id": "240908be13d49cd5e02c74fa62ad21b71a4f90a219413590c5a03d1e36d315b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lm3697.c",
  "human_readable_source": "\n\n\n\n#include <linux/bits.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/types.h>\n\n#include <linux/leds-ti-lmu-common.h>\n\n#define LM3697_REV\t\t\t0x0\n#define LM3697_RESET\t\t\t0x1\n#define LM3697_OUTPUT_CONFIG\t\t0x10\n#define LM3697_CTRL_A_RAMP\t\t0x11\n#define LM3697_CTRL_B_RAMP\t\t0x12\n#define LM3697_CTRL_A_B_RT_RAMP\t\t0x13\n#define LM3697_CTRL_A_B_RAMP_CFG\t0x14\n#define LM3697_CTRL_A_B_BRT_CFG\t\t0x16\n#define LM3697_CTRL_A_FS_CURR_CFG\t0x17\n#define LM3697_CTRL_B_FS_CURR_CFG\t0x18\n#define LM3697_PWM_CFG\t\t\t0x1c\n#define LM3697_CTRL_A_BRT_LSB\t\t0x20\n#define LM3697_CTRL_A_BRT_MSB\t\t0x21\n#define LM3697_CTRL_B_BRT_LSB\t\t0x22\n#define LM3697_CTRL_B_BRT_MSB\t\t0x23\n#define LM3697_CTRL_ENABLE\t\t0x24\n\n#define LM3697_SW_RESET\t\tBIT(0)\n\n#define LM3697_CTRL_A_EN\tBIT(0)\n#define LM3697_CTRL_B_EN\tBIT(1)\n#define LM3697_CTRL_A_B_EN\t(LM3697_CTRL_A_EN | LM3697_CTRL_B_EN)\n\n#define LM3697_MAX_LED_STRINGS\t3\n\n#define LM3697_CONTROL_A\t0\n#define LM3697_CONTROL_B\t1\n#define LM3697_MAX_CONTROL_BANKS 2\n\n \nstruct lm3697_led {\n\tu32 hvled_strings[LM3697_MAX_LED_STRINGS];\n\tchar label[LED_MAX_NAME_SIZE];\n\tstruct led_classdev led_dev;\n\tstruct lm3697 *priv;\n\tstruct ti_lmu_bank lmu_data;\n\tint control_bank;\n\tint enabled;\n\tint num_leds;\n};\n\n \nstruct lm3697 {\n\tstruct gpio_desc *enable_gpio;\n\tstruct regulator *regulator;\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct mutex lock;\n\n\tint bank_cfg;\n\tint num_banks;\n\n\tstruct lm3697_led leds[];\n};\n\nstatic const struct reg_default lm3697_reg_defs[] = {\n\t{LM3697_OUTPUT_CONFIG, 0x6},\n\t{LM3697_CTRL_A_RAMP, 0x0},\n\t{LM3697_CTRL_B_RAMP, 0x0},\n\t{LM3697_CTRL_A_B_RT_RAMP, 0x0},\n\t{LM3697_CTRL_A_B_RAMP_CFG, 0x0},\n\t{LM3697_CTRL_A_B_BRT_CFG, 0x0},\n\t{LM3697_CTRL_A_FS_CURR_CFG, 0x13},\n\t{LM3697_CTRL_B_FS_CURR_CFG, 0x13},\n\t{LM3697_PWM_CFG, 0xc},\n\t{LM3697_CTRL_A_BRT_LSB, 0x0},\n\t{LM3697_CTRL_A_BRT_MSB, 0x0},\n\t{LM3697_CTRL_B_BRT_LSB, 0x0},\n\t{LM3697_CTRL_B_BRT_MSB, 0x0},\n\t{LM3697_CTRL_ENABLE, 0x0},\n};\n\nstatic const struct regmap_config lm3697_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = LM3697_CTRL_ENABLE,\n\t.reg_defaults = lm3697_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(lm3697_reg_defs),\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int lm3697_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\tenum led_brightness brt_val)\n{\n\tstruct lm3697_led *led = container_of(led_cdev, struct lm3697_led,\n\t\t\t\t\t      led_dev);\n\tint ctrl_en_val = (1 << led->control_bank);\n\tstruct device *dev = led->priv->dev;\n\tint ret;\n\n\tmutex_lock(&led->priv->lock);\n\n\tif (brt_val == LED_OFF) {\n\t\tret = regmap_update_bits(led->priv->regmap, LM3697_CTRL_ENABLE,\n\t\t\t\t\t ctrl_en_val, ~ctrl_en_val);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Cannot write ctrl register\\n\");\n\t\t\tgoto brightness_out;\n\t\t}\n\n\t\tled->enabled = LED_OFF;\n\t} else {\n\t\tret = ti_lmu_common_set_brightness(&led->lmu_data, brt_val);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Cannot write brightness\\n\");\n\t\t\tgoto brightness_out;\n\t\t}\n\n\t\tif (!led->enabled) {\n\t\t\tret = regmap_update_bits(led->priv->regmap,\n\t\t\t\t\t\t LM3697_CTRL_ENABLE,\n\t\t\t\t\t\t ctrl_en_val, ctrl_en_val);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Cannot enable the device\\n\");\n\t\t\t\tgoto brightness_out;\n\t\t\t}\n\n\t\t\tled->enabled = brt_val;\n\t\t}\n\t}\n\nbrightness_out:\n\tmutex_unlock(&led->priv->lock);\n\treturn ret;\n}\n\nstatic int lm3697_init(struct lm3697 *priv)\n{\n\tstruct device *dev = priv->dev;\n\tstruct lm3697_led *led;\n\tint i, ret;\n\n\tif (priv->enable_gpio) {\n\t\tgpiod_direction_output(priv->enable_gpio, 1);\n\t} else {\n\t\tret = regmap_write(priv->regmap, LM3697_RESET, LM3697_SW_RESET);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Cannot reset the device\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = regmap_write(priv->regmap, LM3697_CTRL_ENABLE, 0x0);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot write ctrl enable\\n\");\n\t\tgoto out;\n\t}\n\n\tret = regmap_write(priv->regmap, LM3697_OUTPUT_CONFIG, priv->bank_cfg);\n\tif (ret)\n\t\tdev_err(dev, \"Cannot write OUTPUT config\\n\");\n\n\tfor (i = 0; i < priv->num_banks; i++) {\n\t\tled = &priv->leds[i];\n\t\tret = ti_lmu_common_set_ramp(&led->lmu_data);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Setting the ramp rate failed\\n\");\n\t}\nout:\n\treturn ret;\n}\n\nstatic int lm3697_probe_dt(struct lm3697 *priv)\n{\n\tstruct fwnode_handle *child = NULL;\n\tstruct device *dev = priv->dev;\n\tstruct lm3697_led *led;\n\tint ret = -EINVAL;\n\tint control_bank;\n\tsize_t i = 0;\n\tint j;\n\n\tpriv->enable_gpio = devm_gpiod_get_optional(dev, \"enable\",\n\t\t\t\t\t\t    GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->enable_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->enable_gpio),\n\t\t\t\t\t  \"Failed to get enable GPIO\\n\");\n\n\tpriv->regulator = devm_regulator_get(dev, \"vled\");\n\tif (IS_ERR(priv->regulator))\n\t\tpriv->regulator = NULL;\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tstruct led_init_data init_data = {};\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &control_bank);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"reg property missing\\n\");\n\t\t\tgoto child_out;\n\t\t}\n\n\t\tif (control_bank > LM3697_CONTROL_B) {\n\t\t\tdev_err(dev, \"reg property is invalid\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto child_out;\n\t\t}\n\n\t\tled = &priv->leds[i];\n\n\t\tret = ti_lmu_common_get_brt_res(dev, child, &led->lmu_data);\n\t\tif (ret)\n\t\t\tdev_warn(dev,\n\t\t\t\t \"brightness resolution property missing\\n\");\n\n\t\tled->control_bank = control_bank;\n\t\tled->lmu_data.regmap = priv->regmap;\n\t\tled->lmu_data.runtime_ramp_reg = LM3697_CTRL_A_RAMP +\n\t\t\t\t\t\t control_bank;\n\t\tled->lmu_data.msb_brightness_reg = LM3697_CTRL_A_BRT_MSB +\n\t\t\t\t\t\t   led->control_bank * 2;\n\t\tled->lmu_data.lsb_brightness_reg = LM3697_CTRL_A_BRT_LSB +\n\t\t\t\t\t\t   led->control_bank * 2;\n\n\t\tled->num_leds = fwnode_property_count_u32(child, \"led-sources\");\n\t\tif (led->num_leds > LM3697_MAX_LED_STRINGS) {\n\t\t\tdev_err(dev, \"Too many LED strings defined\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = fwnode_property_read_u32_array(child, \"led-sources\",\n\t\t\t\t\t\t    led->hvled_strings,\n\t\t\t\t\t\t    led->num_leds);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"led-sources property missing\\n\");\n\t\t\tgoto child_out;\n\t\t}\n\n\t\tfor (j = 0; j < led->num_leds; j++)\n\t\t\tpriv->bank_cfg |=\n\t\t\t\t(led->control_bank << led->hvled_strings[j]);\n\n\t\tret = ti_lmu_common_get_ramp_params(dev, child, &led->lmu_data);\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"runtime-ramp properties missing\\n\");\n\n\t\tinit_data.fwnode = child;\n\t\tinit_data.devicename = priv->client->name;\n\t\t \n\t\tinit_data.default_label = \":\";\n\n\t\tled->priv = priv;\n\t\tled->led_dev.max_brightness = led->lmu_data.max_brightness;\n\t\tled->led_dev.brightness_set_blocking = lm3697_brightness_set;\n\n\t\tret = devm_led_classdev_register_ext(dev, &led->led_dev,\n\t\t\t\t\t\t     &init_data);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"led register err: %d\\n\", ret);\n\t\t\tgoto child_out;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn ret;\n\nchild_out:\n\tfwnode_handle_put(child);\n\treturn ret;\n}\n\nstatic int lm3697_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct lm3697 *led;\n\tint count;\n\tint ret;\n\n\tcount = device_get_child_node_count(dev);\n\tif (!count || count > LM3697_MAX_CONTROL_BANKS) {\n\t\tdev_err(dev, \"Strange device tree!\");\n\t\treturn -ENODEV;\n\t}\n\n\tled = devm_kzalloc(dev, struct_size(led, leds, count), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&led->lock);\n\ti2c_set_clientdata(client, led);\n\n\tled->client = client;\n\tled->dev = dev;\n\tled->num_banks = count;\n\tled->regmap = devm_regmap_init_i2c(client, &lm3697_regmap_config);\n\tif (IS_ERR(led->regmap)) {\n\t\tret = PTR_ERR(led->regmap);\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = lm3697_probe_dt(led);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lm3697_init(led);\n}\n\nstatic void lm3697_remove(struct i2c_client *client)\n{\n\tstruct lm3697 *led = i2c_get_clientdata(client);\n\tstruct device *dev = &led->client->dev;\n\tint ret;\n\n\tret = regmap_update_bits(led->regmap, LM3697_CTRL_ENABLE,\n\t\t\t\t LM3697_CTRL_A_B_EN, 0);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to disable the device\\n\");\n\n\tif (led->enable_gpio)\n\t\tgpiod_direction_output(led->enable_gpio, 0);\n\n\tif (led->regulator) {\n\t\tret = regulator_disable(led->regulator);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Failed to disable regulator\\n\");\n\t}\n\n\tmutex_destroy(&led->lock);\n}\n\nstatic const struct i2c_device_id lm3697_id[] = {\n\t{ \"lm3697\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm3697_id);\n\nstatic const struct of_device_id of_lm3697_leds_match[] = {\n\t{ .compatible = \"ti,lm3697\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_lm3697_leds_match);\n\nstatic struct i2c_driver lm3697_driver = {\n\t.driver = {\n\t\t.name\t= \"lm3697\",\n\t\t.of_match_table = of_lm3697_leds_match,\n\t},\n\t.probe\t\t= lm3697_probe,\n\t.remove\t\t= lm3697_remove,\n\t.id_table\t= lm3697_id,\n};\nmodule_i2c_driver(lm3697_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments LM3697 LED driver\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}