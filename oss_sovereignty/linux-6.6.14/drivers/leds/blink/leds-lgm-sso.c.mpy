{
  "module_name": "leds-lgm-sso.c",
  "hash_id": "48701e4930ec40dcc3f3990a1d6625de44cfa5ac57169ce6e1f4ad6c54905868",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/blink/leds-lgm-sso.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/sizes.h>\n#include <linux/uaccess.h>\n\n#define SSO_DEV_NAME\t\t\t\"lgm-sso\"\n\n#define LED_BLINK_H8_0\t\t\t0x0\n#define LED_BLINK_H8_1\t\t\t0x4\n#define GET_FREQ_OFFSET(pin, src)\t(((pin) * 6) + ((src) * 2))\n#define GET_SRC_OFFSET(pinc)\t\t(((pin) * 6) + 4)\n\n#define DUTY_CYCLE(x)\t\t\t(0x8 + ((x) * 4))\n#define SSO_CON0\t\t\t0x2B0\n#define SSO_CON0_RZFL\t\t\tBIT(26)\n#define SSO_CON0_BLINK_R\t\tBIT(30)\n#define SSO_CON0_SWU\t\t\tBIT(31)\n\n#define SSO_CON1\t\t\t0x2B4\n#define SSO_CON1_FCDSC\t\t\tGENMASK(21, 20)  \n#define SSO_CON1_FPID\t\t\tGENMASK(24, 23)\n#define SSO_CON1_GPTD\t\t\tGENMASK(26, 25)\n#define SSO_CON1_US\t\t\tGENMASK(31, 30)\n\n#define SSO_CPU\t\t\t\t0x2B8\n#define SSO_CON2\t\t\t0x2C4\n#define SSO_CON3\t\t\t0x2C8\n\n \n#define MAX_PIN_NUM_PER_BANK\t\tSZ_32\n#define MAX_GROUP_NUM\t\t\tSZ_4\n#define PINS_PER_GROUP\t\t\tSZ_8\n#define FPID_FREQ_RANK_MAX\t\tSZ_4\n#define SSO_LED_MAX_NUM\t\t\tSZ_32\n#define MAX_FREQ_RANK\t\t\t10\n#define DEF_GPTC_CLK_RATE\t\t200000000\n#define SSO_DEF_BRIGHTNESS\t\tLED_HALF\n#define DATA_CLK_EDGE\t\t\t0  \n\nstatic const u32 freq_div_tbl[] = {4000, 2000, 1000, 800};\nstatic const int freq_tbl[] = {2, 4, 8, 10, 50000, 100000, 200000, 250000};\nstatic const int shift_clk_freq_tbl[] = {25000000, 12500000, 6250000, 3125000};\n\n \nenum {\n\tUS_SW = 0,\n\tUS_GPTC = 1,\n\tUS_FPID = 2\n};\n\nenum {\n\tMAX_FPID_FREQ_RANK = 5,  \n\tMAX_GPTC_FREQ_RANK = 9,  \n\tMAX_GPTC_HS_FREQ_RANK = 10,  \n};\n\nenum {\n\tLED_GRP0_PIN_MAX = 24,\n\tLED_GRP1_PIN_MAX = 29,\n\tLED_GRP2_PIN_MAX = 32,\n};\n\nenum {\n\tLED_GRP0_0_23,\n\tLED_GRP1_24_28,\n\tLED_GRP2_29_31,\n\tLED_GROUP_MAX,\n};\n\nenum {\n\tCLK_SRC_FPID = 0,\n\tCLK_SRC_GPTC = 1,\n\tCLK_SRC_GPTC_HS = 2,\n};\n\nstruct sso_led_priv;\n\nstruct sso_led_desc {\n\tconst char *name;\n\tconst char *default_trigger;\n\tunsigned int brightness;\n\tunsigned int blink_rate;\n\tunsigned int retain_state_suspended:1;\n\tunsigned int retain_state_shutdown:1;\n\tunsigned int panic_indicator:1;\n\tunsigned int hw_blink:1;\n\tunsigned int hw_trig:1;\n\tunsigned int blinking:1;\n\tint freq_idx;\n\tu32 pin;\n};\n\nstruct sso_led {\n\tstruct list_head list;\n\tstruct led_classdev cdev;\n\tstruct gpio_desc *gpiod;\n\tstruct sso_led_desc desc;\n\tstruct sso_led_priv *priv;\n};\n\nstruct sso_gpio {\n\tstruct gpio_chip chip;\n\tint shift_clk_freq;\n\tint edge;\n\tint freq;\n\tu32 pins;\n\tu32 alloc_bitmap;\n};\n\nstruct sso_led_priv {\n\tstruct regmap *mmap;\n\tstruct device *dev;\n\tstruct platform_device *pdev;\n\tstruct clk_bulk_data clocks[2];\n\tu32 fpid_clkrate;\n\tu32 gptc_clkrate;\n\tu32 freq[MAX_FREQ_RANK];\n\tstruct list_head led_list;\n\tstruct sso_gpio gpio;\n};\n\nstatic int sso_get_blink_rate_idx(struct sso_led_priv *priv, u32 rate)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_FREQ_RANK; i++) {\n\t\tif (rate <= priv->freq[i])\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nstatic unsigned int sso_led_pin_to_group(u32 pin)\n{\n\tif (pin < LED_GRP0_PIN_MAX)\n\t\treturn LED_GRP0_0_23;\n\telse if (pin < LED_GRP1_PIN_MAX)\n\t\treturn LED_GRP1_24_28;\n\telse\n\t\treturn LED_GRP2_29_31;\n}\n\nstatic u32 sso_led_get_freq_src(int freq_idx)\n{\n\tif (freq_idx < MAX_FPID_FREQ_RANK)\n\t\treturn CLK_SRC_FPID;\n\telse if (freq_idx < MAX_GPTC_FREQ_RANK)\n\t\treturn CLK_SRC_GPTC;\n\telse\n\t\treturn CLK_SRC_GPTC_HS;\n}\n\nstatic u32 sso_led_pin_blink_off(u32 pin, unsigned int group)\n{\n\tif (group == LED_GRP2_29_31)\n\t\treturn pin - LED_GRP1_PIN_MAX;\n\telse if (group == LED_GRP1_24_28)\n\t\treturn pin - LED_GRP0_PIN_MAX;\n\telse\t \n\t\treturn SSO_LED_MAX_NUM - LED_GRP1_PIN_MAX;\n}\n\nstatic struct sso_led\n*cdev_to_sso_led_data(struct led_classdev *led_cdev)\n{\n\treturn container_of(led_cdev, struct sso_led, cdev);\n}\n\nstatic void sso_led_freq_set(struct sso_led_priv *priv, u32 pin, int freq_idx)\n{\n\tu32 reg, off, freq_src, val_freq;\n\tu32 low, high, val;\n\tunsigned int group;\n\n\tif (!freq_idx)\n\t\treturn;\n\n\tgroup = sso_led_pin_to_group(pin);\n\tfreq_src = sso_led_get_freq_src(freq_idx);\n\toff = sso_led_pin_blink_off(pin, group);\n\n\tif (group == LED_GRP0_0_23)\n\t\treturn;\n\telse if (group == LED_GRP1_24_28)\n\t\treg = LED_BLINK_H8_0;\n\telse\n\t\treg = LED_BLINK_H8_1;\n\n\tif (freq_src == CLK_SRC_FPID)\n\t\tval_freq = freq_idx - 1;\n\telse if (freq_src == CLK_SRC_GPTC)\n\t\tval_freq = freq_idx - MAX_FPID_FREQ_RANK;\n\n\t \n\tif (freq_src != CLK_SRC_GPTC_HS) {\n\t\tlow = GET_FREQ_OFFSET(off, freq_src);\n\t\thigh = low + 2;\n\t\tval = val_freq << high;\n\t\tregmap_update_bits(priv->mmap, reg, GENMASK(high, low), val);\n\t}\n\n\t \n\tlow = GET_SRC_OFFSET(off);\n\thigh = low + 2;\n\tval = freq_src << high;\n\tregmap_update_bits(priv->mmap, reg, GENMASK(high, low), val);\n}\n\nstatic void sso_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct sso_led_priv *priv;\n\tstruct sso_led_desc *desc;\n\tstruct sso_led *led;\n\tint val;\n\n\tled = cdev_to_sso_led_data(led_cdev);\n\tpriv = led->priv;\n\tdesc = &led->desc;\n\n\tdesc->brightness = brightness;\n\tregmap_write(priv->mmap, DUTY_CYCLE(desc->pin), brightness);\n\n\tif (brightness == LED_OFF)\n\t\tval = 0;\n\telse\n\t\tval = 1;\n\n\t \n\tif (desc->hw_blink && !val && desc->blinking) {\n\t\tdesc->blinking = 0;\n\t\tregmap_update_bits(priv->mmap, SSO_CON2, BIT(desc->pin), 0);\n\t} else if (desc->hw_blink && val && !desc->blinking) {\n\t\tdesc->blinking = 1;\n\t\tregmap_update_bits(priv->mmap, SSO_CON2, BIT(desc->pin),\n\t\t\t\t   1 << desc->pin);\n\t}\n\n\tif (!desc->hw_trig)\n\t\tgpiod_set_value(led->gpiod, val);\n}\n\nstatic enum led_brightness sso_led_brightness_get(struct led_classdev *led_cdev)\n{\n\tstruct sso_led *led = cdev_to_sso_led_data(led_cdev);\n\n\treturn (enum led_brightness)led->desc.brightness;\n}\n\nstatic int\ndelay_to_freq_idx(struct sso_led *led, unsigned long *delay_on,\n\t\t  unsigned long *delay_off)\n{\n\tstruct sso_led_priv *priv = led->priv;\n\tunsigned long delay;\n\tint freq_idx;\n\tu32 freq;\n\n\tif (!*delay_on && !*delay_off) {\n\t\t*delay_on = *delay_off = (1000 / priv->freq[0]) / 2;\n\t\treturn 0;\n\t}\n\n\tdelay = *delay_on + *delay_off;\n\tfreq = 1000 / delay;\n\n\tfreq_idx = sso_get_blink_rate_idx(priv, freq);\n\tif (freq_idx == -1)\n\t\tfreq_idx = MAX_FREQ_RANK - 1;\n\n\tdelay = 1000 / priv->freq[freq_idx];\n\t*delay_on = *delay_off = delay / 2;\n\n\tif (!*delay_on)\n\t\t*delay_on = *delay_off = 1;\n\n\treturn freq_idx;\n}\n\nstatic int\nsso_led_blink_set(struct led_classdev *led_cdev, unsigned long *delay_on,\n\t\t  unsigned long *delay_off)\n{\n\tstruct sso_led_priv *priv;\n\tstruct sso_led *led;\n\tint freq_idx;\n\n\tled = cdev_to_sso_led_data(led_cdev);\n\tpriv = led->priv;\n\tfreq_idx = delay_to_freq_idx(led, delay_on, delay_off);\n\n\tsso_led_freq_set(priv, led->desc.pin, freq_idx);\n\tregmap_update_bits(priv->mmap, SSO_CON2, BIT(led->desc.pin),\n\t\t\t   1 << led->desc.pin);\n\tled->desc.freq_idx = freq_idx;\n\tled->desc.blink_rate = priv->freq[freq_idx];\n\tled->desc.blinking = 1;\n\n\treturn 1;\n}\n\nstatic void sso_led_hw_cfg(struct sso_led_priv *priv, struct sso_led *led)\n{\n\tstruct sso_led_desc *desc = &led->desc;\n\n\t \n\tif (desc->hw_blink) {\n\t\tsso_led_freq_set(priv, desc->pin, desc->freq_idx);\n\t\tregmap_update_bits(priv->mmap, SSO_CON2, BIT(desc->pin),\n\t\t\t\t   1 << desc->pin);\n\t}\n\n\tif (desc->hw_trig)\n\t\tregmap_update_bits(priv->mmap, SSO_CON3, BIT(desc->pin),\n\t\t\t\t   1 << desc->pin);\n\n\t \n\tregmap_write(priv->mmap, DUTY_CYCLE(desc->pin), desc->brightness);\n\n\t \n\tif (!desc->hw_trig && desc->brightness)\n\t\tgpiod_set_value(led->gpiod, 1);\n}\n\nstatic int sso_create_led(struct sso_led_priv *priv, struct sso_led *led,\n\t\t\t  struct fwnode_handle *child)\n{\n\tstruct sso_led_desc *desc = &led->desc;\n\tstruct led_init_data init_data;\n\tint err;\n\n\tinit_data.fwnode = child;\n\tinit_data.devicename = SSO_DEV_NAME;\n\tinit_data.default_label = \":\";\n\n\tled->cdev.default_trigger = desc->default_trigger;\n\tled->cdev.brightness_set = sso_led_brightness_set;\n\tled->cdev.brightness_get = sso_led_brightness_get;\n\tled->cdev.brightness = desc->brightness;\n\tled->cdev.max_brightness = LED_FULL;\n\n\tif (desc->retain_state_shutdown)\n\t\tled->cdev.flags |= LED_RETAIN_AT_SHUTDOWN;\n\tif (desc->retain_state_suspended)\n\t\tled->cdev.flags |= LED_CORE_SUSPENDRESUME;\n\tif (desc->panic_indicator)\n\t\tled->cdev.flags |= LED_PANIC_INDICATOR;\n\n\tif (desc->hw_blink)\n\t\tled->cdev.blink_set = sso_led_blink_set;\n\n\tsso_led_hw_cfg(priv, led);\n\n\terr = devm_led_classdev_register_ext(priv->dev, &led->cdev, &init_data);\n\tif (err)\n\t\treturn err;\n\n\tlist_add(&led->list, &priv->led_list);\n\n\treturn 0;\n}\n\nstatic void sso_init_freq(struct sso_led_priv *priv)\n{\n\tint i;\n\n\tpriv->freq[0] = 0;\n\tfor (i = 1; i < MAX_FREQ_RANK; i++) {\n\t\tif (i < MAX_FPID_FREQ_RANK) {\n\t\t\tpriv->freq[i] = priv->fpid_clkrate / freq_div_tbl[i - 1];\n\t\t} else if (i < MAX_GPTC_FREQ_RANK) {\n\t\t\tpriv->freq[i] = priv->gptc_clkrate /\n\t\t\t\tfreq_div_tbl[i - MAX_FPID_FREQ_RANK];\n\t\t} else if (i < MAX_GPTC_HS_FREQ_RANK) {\n\t\t\tpriv->freq[i] = priv->gptc_clkrate;\n\t\t}\n\t}\n}\n\nstatic int sso_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sso_led_priv *priv = gpiochip_get_data(chip);\n\n\tif (priv->gpio.alloc_bitmap & BIT(offset))\n\t\treturn -EINVAL;\n\n\tpriv->gpio.alloc_bitmap |= BIT(offset);\n\tregmap_write(priv->mmap, DUTY_CYCLE(offset), 0xFF);\n\n\treturn 0;\n}\n\nstatic void sso_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sso_led_priv *priv = gpiochip_get_data(chip);\n\n\tpriv->gpio.alloc_bitmap &= ~BIT(offset);\n\tregmap_write(priv->mmap, DUTY_CYCLE(offset), 0x0);\n}\n\nstatic int sso_gpio_get_dir(struct gpio_chip *chip, unsigned int offset)\n{\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int\nsso_gpio_dir_out(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct sso_led_priv *priv = gpiochip_get_data(chip);\n\tbool bit = !!value;\n\n\tregmap_update_bits(priv->mmap, SSO_CPU, BIT(offset), bit << offset);\n\tif (!priv->gpio.freq)\n\t\tregmap_update_bits(priv->mmap, SSO_CON0, SSO_CON0_SWU,\n\t\t\t\t   SSO_CON0_SWU);\n\n\treturn 0;\n}\n\nstatic int sso_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sso_led_priv *priv = gpiochip_get_data(chip);\n\tu32 reg_val;\n\n\tregmap_read(priv->mmap, SSO_CPU, &reg_val);\n\n\treturn !!(reg_val & BIT(offset));\n}\n\nstatic void sso_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct sso_led_priv *priv = gpiochip_get_data(chip);\n\n\tregmap_update_bits(priv->mmap, SSO_CPU, BIT(offset), value << offset);\n\tif (!priv->gpio.freq)\n\t\tregmap_update_bits(priv->mmap, SSO_CON0, SSO_CON0_SWU,\n\t\t\t\t   SSO_CON0_SWU);\n}\n\nstatic int sso_gpio_gc_init(struct device *dev, struct sso_led_priv *priv)\n{\n\tstruct gpio_chip *gc = &priv->gpio.chip;\n\n\tgc->request             = sso_gpio_request;\n\tgc->free                = sso_gpio_free;\n\tgc->get_direction       = sso_gpio_get_dir;\n\tgc->direction_output    = sso_gpio_dir_out;\n\tgc->get                 = sso_gpio_get;\n\tgc->set                 = sso_gpio_set;\n\n\tgc->label               = \"lgm-sso\";\n\tgc->base                = -1;\n\t \n\tgc->ngpio               = priv->gpio.pins;\n\tgc->parent              = dev;\n\tgc->owner               = THIS_MODULE;\n\n\treturn devm_gpiochip_add_data(dev, gc, priv);\n}\n\nstatic int sso_gpio_get_freq_idx(int freq)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(freq_tbl); idx++) {\n\t\tif (freq <= freq_tbl[idx])\n\t\t\treturn idx;\n\t}\n\n\treturn -1;\n}\n\nstatic void sso_register_shift_clk(struct sso_led_priv *priv)\n{\n\tint idx, size = ARRAY_SIZE(shift_clk_freq_tbl);\n\tu32 val = 0;\n\n\tfor (idx = 0; idx < size; idx++) {\n\t\tif (shift_clk_freq_tbl[idx] <= priv->gpio.shift_clk_freq) {\n\t\t\tval = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (idx == size)\n\t\tdev_warn(priv->dev, \"%s: Invalid freq %d\\n\",\n\t\t\t __func__, priv->gpio.shift_clk_freq);\n\n\tregmap_update_bits(priv->mmap, SSO_CON1, SSO_CON1_FCDSC,\n\t\t\t   FIELD_PREP(SSO_CON1_FCDSC, val));\n}\n\nstatic int sso_gpio_freq_set(struct sso_led_priv *priv)\n{\n\tint freq_idx;\n\tu32 val;\n\n\tfreq_idx = sso_gpio_get_freq_idx(priv->gpio.freq);\n\tif (freq_idx == -1)\n\t\tfreq_idx = ARRAY_SIZE(freq_tbl) - 1;\n\n\tval = freq_idx % FPID_FREQ_RANK_MAX;\n\n\tif (!priv->gpio.freq) {\n\t\tregmap_update_bits(priv->mmap, SSO_CON0, SSO_CON0_BLINK_R, 0);\n\t\tregmap_update_bits(priv->mmap, SSO_CON1, SSO_CON1_US,\n\t\t\t\t   FIELD_PREP(SSO_CON1_US, US_SW));\n\t} else if (freq_idx < FPID_FREQ_RANK_MAX) {\n\t\tregmap_update_bits(priv->mmap, SSO_CON0, SSO_CON0_BLINK_R,\n\t\t\t\t   SSO_CON0_BLINK_R);\n\t\tregmap_update_bits(priv->mmap, SSO_CON1, SSO_CON1_US,\n\t\t\t\t   FIELD_PREP(SSO_CON1_US, US_FPID));\n\t\tregmap_update_bits(priv->mmap, SSO_CON1, SSO_CON1_FPID,\n\t\t\t\t   FIELD_PREP(SSO_CON1_FPID, val));\n\t} else {\n\t\tregmap_update_bits(priv->mmap, SSO_CON0, SSO_CON0_BLINK_R,\n\t\t\t\t   SSO_CON0_BLINK_R);\n\t\tregmap_update_bits(priv->mmap, SSO_CON1, SSO_CON1_US,\n\t\t\t\t   FIELD_PREP(SSO_CON1_US, US_GPTC));\n\t\tregmap_update_bits(priv->mmap, SSO_CON1, SSO_CON1_GPTD,\n\t\t\t\t   FIELD_PREP(SSO_CON1_GPTD, val));\n\t}\n\n\treturn 0;\n}\n\nstatic int sso_gpio_hw_init(struct sso_led_priv *priv)\n{\n\tu32 activate;\n\tint i, err;\n\n\t \n\tfor (i = 0; i < priv->gpio.pins; i++) {\n\t\terr = regmap_write(priv->mmap, DUTY_CYCLE(i), 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 1; i <= MAX_GROUP_NUM; i++) {\n\t\tactivate = !!(i * PINS_PER_GROUP <= priv->gpio.pins ||\n\t\t\t      priv->gpio.pins > (i - 1) * PINS_PER_GROUP);\n\t\terr = regmap_update_bits(priv->mmap, SSO_CON1, BIT(i - 1),\n\t\t\t\t\t activate << (i - 1));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = regmap_write(priv->mmap, SSO_CON3, 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_write(priv->mmap, SSO_CON2, 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_write(priv->mmap, SSO_CPU, 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_update_bits(priv->mmap, SSO_CON0, SSO_CON0_RZFL,\n\t\t\t\t FIELD_PREP(SSO_CON0_RZFL, priv->gpio.edge));\n\tif (err)\n\t\treturn err;\n\n\t \n\tsso_gpio_freq_set(priv);\n\n\t \n\tsso_register_shift_clk(priv);\n\n\treturn 0;\n}\n\nstatic void sso_led_shutdown(struct sso_led *led)\n{\n\tstruct sso_led_priv *priv = led->priv;\n\n\t \n\tdevm_led_classdev_unregister(priv->dev, &led->cdev);\n\n\t \n\tif (led->desc.hw_trig)\n\t\tregmap_update_bits(priv->mmap, SSO_CON3, BIT(led->desc.pin), 0);\n\n\tled->priv = NULL;\n}\n\nstatic int\n__sso_led_dt_parse(struct sso_led_priv *priv, struct fwnode_handle *fw_ssoled)\n{\n\tstruct fwnode_handle *fwnode_child;\n\tstruct device *dev = priv->dev;\n\tstruct sso_led_desc *desc;\n\tstruct sso_led *led;\n\tconst char *tmp;\n\tu32 prop;\n\tint ret;\n\n\tfwnode_for_each_child_node(fw_ssoled, fwnode_child) {\n\t\tled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\n\t\tif (!led) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto __dt_err;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&led->list);\n\t\tled->priv = priv;\n\t\tdesc = &led->desc;\n\n\t\tled->gpiod = devm_fwnode_gpiod_get(dev, fwnode_child, NULL,\n\t\t\t\t\t\t   GPIOD_ASIS, NULL);\n\t\tif (IS_ERR(led->gpiod)) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(led->gpiod), \"led: get gpio fail!\\n\");\n\t\t\tgoto __dt_err;\n\t\t}\n\n\t\tfwnode_property_read_string(fwnode_child,\n\t\t\t\t\t    \"linux,default-trigger\",\n\t\t\t\t\t    &desc->default_trigger);\n\n\t\tif (fwnode_property_present(fwnode_child,\n\t\t\t\t\t    \"retain-state-suspended\"))\n\t\t\tdesc->retain_state_suspended = 1;\n\n\t\tif (fwnode_property_present(fwnode_child,\n\t\t\t\t\t    \"retain-state-shutdown\"))\n\t\t\tdesc->retain_state_shutdown = 1;\n\n\t\tif (fwnode_property_present(fwnode_child, \"panic-indicator\"))\n\t\t\tdesc->panic_indicator = 1;\n\n\t\tret = fwnode_property_read_u32(fwnode_child, \"reg\", &prop);\n\t\tif (ret)\n\t\t\tgoto __dt_err;\n\t\tif (prop >= SSO_LED_MAX_NUM) {\n\t\t\tdev_err(dev, \"invalid LED pin:%u\\n\", prop);\n\t\t\tret = -EINVAL;\n\t\t\tgoto __dt_err;\n\t\t}\n\t\tdesc->pin = prop;\n\n\t\tif (fwnode_property_present(fwnode_child, \"intel,sso-hw-blink\"))\n\t\t\tdesc->hw_blink = 1;\n\n\t\tdesc->hw_trig = fwnode_property_read_bool(fwnode_child,\n\t\t\t\t\t\t\t  \"intel,sso-hw-trigger\");\n\t\tif (desc->hw_trig) {\n\t\t\tdesc->default_trigger = NULL;\n\t\t\tdesc->retain_state_shutdown = 0;\n\t\t\tdesc->retain_state_suspended = 0;\n\t\t\tdesc->panic_indicator = 0;\n\t\t\tdesc->hw_blink = 0;\n\t\t}\n\n\t\tif (fwnode_property_read_u32(fwnode_child,\n\t\t\t\t\t     \"intel,sso-blink-rate-hz\", &prop)) {\n\t\t\t \n\t\t\tdesc->freq_idx = 0;\n\t\t\tdesc->blink_rate = priv->freq[desc->freq_idx];\n\t\t} else {\n\t\t\tdesc->freq_idx = sso_get_blink_rate_idx(priv, prop);\n\t\t\tif (desc->freq_idx == -1)\n\t\t\t\tdesc->freq_idx = MAX_FREQ_RANK - 1;\n\n\t\t\tdesc->blink_rate = priv->freq[desc->freq_idx];\n\t\t}\n\n\t\tif (!fwnode_property_read_string(fwnode_child, \"default-state\", &tmp)) {\n\t\t\tif (!strcmp(tmp, \"on\"))\n\t\t\t\tdesc->brightness = LED_FULL;\n\t\t}\n\n\t\tret = sso_create_led(priv, led, fwnode_child);\n\t\tif (ret)\n\t\t\tgoto __dt_err;\n\t}\n\n\treturn 0;\n\n__dt_err:\n\tfwnode_handle_put(fwnode_child);\n\t \n\tlist_for_each_entry(led, &priv->led_list, list)\n\t\tsso_led_shutdown(led);\n\n\treturn ret;\n}\n\nstatic int sso_led_dt_parse(struct sso_led_priv *priv)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(priv->dev);\n\tstruct fwnode_handle *fw_ssoled;\n\tstruct device *dev = priv->dev;\n\tint count;\n\tint ret;\n\n\tcount = device_get_child_node_count(dev);\n\tif (!count)\n\t\treturn 0;\n\n\tfw_ssoled = fwnode_get_named_child_node(fwnode, \"ssoled\");\n\tif (fw_ssoled) {\n\t\tret = __sso_led_dt_parse(priv, fw_ssoled);\n\t\tfwnode_handle_put(fw_ssoled);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sso_probe_gpios(struct sso_led_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tint ret;\n\n\tif (device_property_read_u32(dev, \"ngpios\", &priv->gpio.pins))\n\t\tpriv->gpio.pins = MAX_PIN_NUM_PER_BANK;\n\n\tif (priv->gpio.pins > MAX_PIN_NUM_PER_BANK)\n\t\treturn -EINVAL;\n\n\tif (device_property_read_u32(dev, \"intel,sso-update-rate-hz\",\n\t\t\t\t     &priv->gpio.freq))\n\t\tpriv->gpio.freq = 0;\n\n\tpriv->gpio.edge = DATA_CLK_EDGE;\n\tpriv->gpio.shift_clk_freq = -1;\n\n\tret = sso_gpio_hw_init(priv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sso_gpio_gc_init(dev, priv);\n}\n\nstatic void sso_clock_disable_unprepare(void *data)\n{\n\tstruct sso_led_priv *priv = data;\n\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(priv->clocks), priv->clocks);\n}\n\nstatic int intel_sso_led_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sso_led_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->pdev = pdev;\n\tpriv->dev = dev;\n\n\t \n\tpriv->clocks[0].id = \"sso\";\n\n\t \n\tpriv->clocks[1].id = \"fpid\";\n\n\tret = devm_clk_bulk_get(dev, ARRAY_SIZE(priv->clocks), priv->clocks);\n\tif (ret) {\n\t\tdev_err(dev, \"Getting clocks failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_bulk_prepare_enable(ARRAY_SIZE(priv->clocks), priv->clocks);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to prepare and enable clocks!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, sso_clock_disable_unprepare, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->fpid_clkrate = clk_get_rate(priv->clocks[1].clk);\n\n\tpriv->mmap = syscon_node_to_regmap(dev->of_node);\n\n\tpriv->mmap = syscon_node_to_regmap(dev->of_node);\n\tif (IS_ERR(priv->mmap)) {\n\t\tdev_err(dev, \"Failed to map iomem!\\n\");\n\t\treturn PTR_ERR(priv->mmap);\n\t}\n\n\tret = sso_probe_gpios(priv);\n\tif (ret) {\n\t\tregmap_exit(priv->mmap);\n\t\treturn ret;\n\t}\n\n\tINIT_LIST_HEAD(&priv->led_list);\n\n\tplatform_set_drvdata(pdev, priv);\n\tsso_init_freq(priv);\n\n\tpriv->gptc_clkrate = DEF_GPTC_CLK_RATE;\n\n\tret = sso_led_dt_parse(priv);\n\tif (ret) {\n\t\tregmap_exit(priv->mmap);\n\t\treturn ret;\n\t}\n\tdev_info(priv->dev, \"sso LED init success!\\n\");\n\n\treturn 0;\n}\n\nstatic int intel_sso_led_remove(struct platform_device *pdev)\n{\n\tstruct sso_led_priv *priv;\n\tstruct sso_led *led, *n;\n\n\tpriv = platform_get_drvdata(pdev);\n\n\tlist_for_each_entry_safe(led, n, &priv->led_list, list) {\n\t\tlist_del(&led->list);\n\t\tsso_led_shutdown(led);\n\t}\n\n\tregmap_exit(priv->mmap);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_sso_led_match[] = {\n\t{ .compatible = \"intel,lgm-ssoled\" },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, of_sso_led_match);\n\nstatic struct platform_driver intel_sso_led_driver = {\n\t.probe\t\t= intel_sso_led_probe,\n\t.remove\t\t= intel_sso_led_remove,\n\t.driver\t\t= {\n\t\t\t.name = \"lgm-ssoled\",\n\t\t\t.of_match_table = of_sso_led_match,\n\t},\n};\n\nmodule_platform_driver(intel_sso_led_driver);\n\nMODULE_DESCRIPTION(\"Intel SSO LED/GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}