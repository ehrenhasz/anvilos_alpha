{
  "module_name": "leds-bcm63138.c",
  "hash_id": "040911f5d6999e3a67db4e193edbbf7dd46b55cc993b51cf1070c2976830aa1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/blink/leds-bcm63138.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#define BCM63138_MAX_LEDS\t\t\t\t32\n#define BCM63138_MAX_BRIGHTNESS\t\t\t\t9\n\n#define BCM63138_LED_BITS\t\t\t\t4\t\t\t\t \n#define BCM63138_LED_MASK\t\t\t\t((1 << BCM63138_LED_BITS) - 1)\t \n#define BCM63138_LEDS_PER_REG\t\t\t\t(32 / BCM63138_LED_BITS)\t \n\n#define BCM63138_GLB_CTRL\t\t\t\t0x00\n#define  BCM63138_GLB_CTRL_SERIAL_LED_DATA_PPOL\t\t0x00000002\n#define  BCM63138_GLB_CTRL_SERIAL_LED_EN_POL\t\t0x00000008\n#define BCM63138_MASK\t\t\t\t\t0x04\n#define BCM63138_HW_LED_EN\t\t\t\t0x08\n#define BCM63138_SERIAL_LED_SHIFT_SEL\t\t\t0x0c\n#define BCM63138_FLASH_RATE_CTRL1\t\t\t0x10\n#define BCM63138_FLASH_RATE_CTRL2\t\t\t0x14\n#define BCM63138_FLASH_RATE_CTRL3\t\t\t0x18\n#define BCM63138_FLASH_RATE_CTRL4\t\t\t0x1c\n#define BCM63138_BRIGHT_CTRL1\t\t\t\t0x20\n#define BCM63138_BRIGHT_CTRL2\t\t\t\t0x24\n#define BCM63138_BRIGHT_CTRL3\t\t\t\t0x28\n#define BCM63138_BRIGHT_CTRL4\t\t\t\t0x2c\n#define BCM63138_POWER_LED_CFG\t\t\t\t0x30\n#define BCM63138_HW_POLARITY\t\t\t\t0xb4\n#define BCM63138_SW_DATA\t\t\t\t0xb8\n#define BCM63138_SW_POLARITY\t\t\t\t0xbc\n#define BCM63138_PARALLEL_LED_POLARITY\t\t\t0xc0\n#define BCM63138_SERIAL_LED_POLARITY\t\t\t0xc4\n#define BCM63138_HW_LED_STATUS\t\t\t\t0xc8\n#define BCM63138_FLASH_CTRL_STATUS\t\t\t0xcc\n#define BCM63138_FLASH_BRT_CTRL\t\t\t\t0xd0\n#define BCM63138_FLASH_P_LED_OUT_STATUS\t\t\t0xd4\n#define BCM63138_FLASH_S_LED_OUT_STATUS\t\t\t0xd8\n\nstruct bcm63138_leds {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tspinlock_t lock;\n};\n\nstruct bcm63138_led {\n\tstruct bcm63138_leds *leds;\n\tstruct led_classdev cdev;\n\tu32 pin;\n\tbool active_low;\n};\n\n \n\nstatic void bcm63138_leds_write(struct bcm63138_leds *leds, unsigned int reg,\n\t\t\t\tu32 data)\n{\n\twritel(data, leds->base + reg);\n}\n\nstatic unsigned long bcm63138_leds_read(struct bcm63138_leds *leds,\n\t\t\t\t\tunsigned int reg)\n{\n\treturn readl(leds->base + reg);\n}\n\nstatic void bcm63138_leds_update_bits(struct bcm63138_leds *leds,\n\t\t\t\t      unsigned int reg, u32 mask, u32 val)\n{\n\tWARN_ON(val & ~mask);\n\n\tbcm63138_leds_write(leds, reg, (bcm63138_leds_read(leds, reg) & ~mask) | (val & mask));\n}\n\n \n\nstatic void bcm63138_leds_set_flash_rate(struct bcm63138_leds *leds,\n\t\t\t\t\t struct bcm63138_led *led,\n\t\t\t\t\t u8 value)\n{\n\tint reg_offset = (led->pin >> fls((BCM63138_LEDS_PER_REG - 1))) * 4;\n\tint shift = (led->pin & (BCM63138_LEDS_PER_REG - 1)) * BCM63138_LED_BITS;\n\n\tbcm63138_leds_update_bits(leds, BCM63138_FLASH_RATE_CTRL1 + reg_offset,\n\t\t\t\t  BCM63138_LED_MASK << shift, value << shift);\n}\n\nstatic void bcm63138_leds_set_bright(struct bcm63138_leds *leds,\n\t\t\t\t     struct bcm63138_led *led,\n\t\t\t\t     u8 value)\n{\n\tint reg_offset = (led->pin >> fls((BCM63138_LEDS_PER_REG - 1))) * 4;\n\tint shift = (led->pin & (BCM63138_LEDS_PER_REG - 1)) * BCM63138_LED_BITS;\n\n\tbcm63138_leds_update_bits(leds, BCM63138_BRIGHT_CTRL1 + reg_offset,\n\t\t\t\t  BCM63138_LED_MASK << shift, value << shift);\n}\n\nstatic void bcm63138_leds_enable_led(struct bcm63138_leds *leds,\n\t\t\t\t     struct bcm63138_led *led,\n\t\t\t\t     enum led_brightness value)\n{\n\tu32 bit = BIT(led->pin);\n\n\tbcm63138_leds_update_bits(leds, BCM63138_SW_DATA, bit, value ? bit : 0);\n}\n\n \n\nstatic void bcm63138_leds_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\t enum led_brightness value)\n{\n\tstruct bcm63138_led *led = container_of(led_cdev, struct bcm63138_led, cdev);\n\tstruct bcm63138_leds *leds = led->leds;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leds->lock, flags);\n\n\tbcm63138_leds_enable_led(leds, led, value);\n\tif (!value)\n\t\tbcm63138_leds_set_flash_rate(leds, led, 0);\n\telse\n\t\tbcm63138_leds_set_bright(leds, led, value);\n\n\tspin_unlock_irqrestore(&leds->lock, flags);\n}\n\nstatic int bcm63138_leds_blink_set(struct led_classdev *led_cdev,\n\t\t\t\t   unsigned long *delay_on,\n\t\t\t\t   unsigned long *delay_off)\n{\n\tstruct bcm63138_led *led = container_of(led_cdev, struct bcm63138_led, cdev);\n\tstruct bcm63138_leds *leds = led->leds;\n\tunsigned long flags;\n\tu8 value;\n\n\tif (!*delay_on && !*delay_off) {\n\t\t*delay_on = 640;\n\t\t*delay_off = 640;\n\t}\n\n\tif (*delay_on != *delay_off) {\n\t\tdev_dbg(led_cdev->dev, \"Blinking at unequal delays is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (*delay_on) {\n\tcase 1152 ... 1408:  \n\t\tvalue = 0x7;\n\t\tbreak;\n\tcase 576 ... 704:  \n\t\tvalue = 0x6;\n\t\tbreak;\n\tcase 288 ... 352:  \n\t\tvalue = 0x5;\n\t\tbreak;\n\tcase 126 ... 154:  \n\t\tvalue = 0x4;\n\t\tbreak;\n\tcase 59 ... 72:  \n\t\tvalue = 0x3;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(led_cdev->dev, \"Blinking delay value %lu is unsupported\\n\",\n\t\t\t*delay_on);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&leds->lock, flags);\n\n\tbcm63138_leds_enable_led(leds, led, BCM63138_MAX_BRIGHTNESS);\n\tbcm63138_leds_set_flash_rate(leds, led, value);\n\n\tspin_unlock_irqrestore(&leds->lock, flags);\n\n\treturn 0;\n}\n\n \n\nstatic void bcm63138_leds_create_led(struct bcm63138_leds *leds,\n\t\t\t\t     struct device_node *np)\n{\n\tstruct led_init_data init_data = {\n\t\t.fwnode = of_fwnode_handle(np),\n\t};\n\tstruct device *dev = leds->dev;\n\tstruct bcm63138_led *led;\n\tstruct pinctrl *pinctrl;\n\tu32 bit;\n\tint err;\n\n\tled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\n\tif (!led) {\n\t\tdev_err(dev, \"Failed to alloc LED\\n\");\n\t\treturn;\n\t}\n\n\tled->leds = leds;\n\n\tif (of_property_read_u32(np, \"reg\", &led->pin)) {\n\t\tdev_err(dev, \"Missing \\\"reg\\\" property in %pOF\\n\", np);\n\t\tgoto err_free;\n\t}\n\n\tif (led->pin >= BCM63138_MAX_LEDS) {\n\t\tdev_err(dev, \"Invalid \\\"reg\\\" value %d\\n\", led->pin);\n\t\tgoto err_free;\n\t}\n\n\tled->active_low = of_property_read_bool(np, \"active-low\");\n\n\tled->cdev.max_brightness = BCM63138_MAX_BRIGHTNESS;\n\tled->cdev.brightness_set = bcm63138_leds_brightness_set;\n\tled->cdev.blink_set = bcm63138_leds_blink_set;\n\n\terr = devm_led_classdev_register_ext(dev, &led->cdev, &init_data);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register LED %pOF: %d\\n\", np, err);\n\t\tgoto err_free;\n\t}\n\n\tpinctrl = devm_pinctrl_get_select_default(led->cdev.dev);\n\tif (IS_ERR(pinctrl) && PTR_ERR(pinctrl) != -ENODEV) {\n\t\tdev_warn(led->cdev.dev, \"Failed to select %pOF pinctrl: %ld\\n\",\n\t\t\t np, PTR_ERR(pinctrl));\n\t}\n\n\tbit = BIT(led->pin);\n\tbcm63138_leds_update_bits(leds, BCM63138_PARALLEL_LED_POLARITY, bit,\n\t\t\t\t  led->active_low ? 0 : bit);\n\tbcm63138_leds_update_bits(leds, BCM63138_HW_LED_EN, bit, 0);\n\tbcm63138_leds_set_flash_rate(leds, led, 0);\n\tbcm63138_leds_enable_led(leds, led, led->cdev.brightness);\n\n\treturn;\n\nerr_free:\n\tdevm_kfree(dev, led);\n}\n\nstatic int bcm63138_leds_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = dev_of_node(&pdev->dev);\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm63138_leds *leds;\n\tstruct device_node *child;\n\n\tleds = devm_kzalloc(dev, sizeof(*leds), GFP_KERNEL);\n\tif (!leds)\n\t\treturn -ENOMEM;\n\n\tleds->dev = dev;\n\n\tleds->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(leds->base))\n\t\treturn PTR_ERR(leds->base);\n\n\tspin_lock_init(&leds->lock);\n\n\tbcm63138_leds_write(leds, BCM63138_GLB_CTRL,\n\t\t\t    BCM63138_GLB_CTRL_SERIAL_LED_DATA_PPOL |\n\t\t\t    BCM63138_GLB_CTRL_SERIAL_LED_EN_POL);\n\tbcm63138_leds_write(leds, BCM63138_HW_LED_EN, 0);\n\tbcm63138_leds_write(leds, BCM63138_SERIAL_LED_POLARITY, 0);\n\tbcm63138_leds_write(leds, BCM63138_PARALLEL_LED_POLARITY, 0);\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tbcm63138_leds_create_led(leds, child);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm63138_leds_of_match_table[] = {\n\t{ .compatible = \"brcm,bcm63138-leds\", },\n\t{ },\n};\n\nstatic struct platform_driver bcm63138_leds_driver = {\n\t.probe = bcm63138_leds_probe,\n\t.driver = {\n\t\t.name = \"leds-bcm63xxx\",\n\t\t.of_match_table = bcm63138_leds_of_match_table,\n\t},\n};\n\nmodule_platform_driver(bcm63138_leds_driver);\n\nMODULE_AUTHOR(\"Rafa\u0142 Mi\u0142ecki\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(of, bcm63138_leds_of_match_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}