{
  "module_name": "leds-aw2013.c",
  "hash_id": "5afed83d79f1b97826f9bbbb2b59ec10be043a160d99fdc2585e4c92d3bafb5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-aw2013.c",
  "human_readable_source": "\n\n\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#define AW2013_MAX_LEDS 3\n\n \n#define AW2013_RSTR 0x00\n#define AW2013_RSTR_RESET 0x55\n#define AW2013_RSTR_CHIP_ID 0x33\n\n \n#define AW2013_GCR 0x01\n#define AW2013_GCR_ENABLE BIT(0)\n\n \n#define AW2013_LCTR 0x30\n#define AW2013_LCTR_LE(x) BIT((x))\n\n \n#define AW2013_LCFG(x) (0x31 + (x))\n#define AW2013_LCFG_IMAX_MASK (BIT(0) | BIT(1)) \n#define AW2013_LCFG_MD BIT(4)\n#define AW2013_LCFG_FI BIT(5)\n#define AW2013_LCFG_FO BIT(6)\n\n \n#define AW2013_REG_PWM(x) (0x34 + (x))\n\n \n#define AW2013_LEDT0(x) (0x37 + (x) * 3)\n#define AW2013_LEDT0_T1(x) ((x) << 4) \n#define AW2013_LEDT0_T2(x) (x) \n\n#define AW2013_LEDT1(x) (0x38 + (x) * 3)\n#define AW2013_LEDT1_T3(x) ((x) << 4) \n#define AW2013_LEDT1_T4(x) (x) \n\n#define AW2013_LEDT2(x) (0x39 + (x) * 3)\n#define AW2013_LEDT2_T0(x) ((x) << 4) \n#define AW2013_LEDT2_REPEAT(x) (x) \n\n#define AW2013_REG_MAX 0x77\n\n#define AW2013_TIME_STEP 130  \n\nstruct aw2013;\n\nstruct aw2013_led {\n\tstruct aw2013 *chip;\n\tstruct led_classdev cdev;\n\tu32 num;\n\tunsigned int imax;\n};\n\nstruct aw2013 {\n\tstruct mutex mutex;  \n\tstruct regulator_bulk_data regulators[2];\n\tstruct i2c_client *client;\n\tstruct aw2013_led leds[AW2013_MAX_LEDS];\n\tstruct regmap *regmap;\n\tint num_leds;\n\tbool enabled;\n};\n\nstatic int aw2013_chip_init(struct aw2013 *chip)\n{\n\tint i, ret;\n\n\tret = regmap_write(chip->regmap, AW2013_GCR, AW2013_GCR_ENABLE);\n\tif (ret) {\n\t\tdev_err(&chip->client->dev, \"Failed to enable the chip: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < chip->num_leds; i++) {\n\t\tret = regmap_update_bits(chip->regmap,\n\t\t\t\t\t AW2013_LCFG(chip->leds[i].num),\n\t\t\t\t\t AW2013_LCFG_IMAX_MASK,\n\t\t\t\t\t chip->leds[i].imax);\n\t\tif (ret) {\n\t\t\tdev_err(&chip->client->dev,\n\t\t\t\t\"Failed to set maximum current for led %d: %d\\n\",\n\t\t\t\tchip->leds[i].num, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void aw2013_chip_disable(struct aw2013 *chip)\n{\n\tint ret;\n\n\tif (!chip->enabled)\n\t\treturn;\n\n\tregmap_write(chip->regmap, AW2013_GCR, 0);\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(chip->regulators),\n\t\t\t\t     chip->regulators);\n\tif (ret) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"Failed to disable regulators: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tchip->enabled = false;\n}\n\nstatic int aw2013_chip_enable(struct aw2013 *chip)\n{\n\tint ret;\n\n\tif (chip->enabled)\n\t\treturn 0;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(chip->regulators),\n\t\t\t\t    chip->regulators);\n\tif (ret) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"Failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tchip->enabled = true;\n\n\tret = aw2013_chip_init(chip);\n\tif (ret)\n\t\taw2013_chip_disable(chip);\n\n\treturn ret;\n}\n\nstatic bool aw2013_chip_in_use(struct aw2013 *chip)\n{\n\tint i;\n\n\tfor (i = 0; i < chip->num_leds; i++)\n\t\tif (chip->leds[i].cdev.brightness)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int aw2013_brightness_set(struct led_classdev *cdev,\n\t\t\t\t enum led_brightness brightness)\n{\n\tstruct aw2013_led *led = container_of(cdev, struct aw2013_led, cdev);\n\tint ret, num;\n\n\tmutex_lock(&led->chip->mutex);\n\n\tif (aw2013_chip_in_use(led->chip)) {\n\t\tret = aw2013_chip_enable(led->chip);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tnum = led->num;\n\n\tret = regmap_write(led->chip->regmap, AW2013_REG_PWM(num), brightness);\n\tif (ret)\n\t\tgoto error;\n\n\tif (brightness) {\n\t\tret = regmap_update_bits(led->chip->regmap, AW2013_LCTR,\n\t\t\t\t\t AW2013_LCTR_LE(num), 0xFF);\n\t} else {\n\t\tret = regmap_update_bits(led->chip->regmap, AW2013_LCTR,\n\t\t\t\t\t AW2013_LCTR_LE(num), 0);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tret = regmap_update_bits(led->chip->regmap, AW2013_LCFG(num),\n\t\t\t\t\t AW2013_LCFG_MD, 0);\n\t}\n\tif (ret)\n\t\tgoto error;\n\n\tif (!aw2013_chip_in_use(led->chip))\n\t\taw2013_chip_disable(led->chip);\n\nerror:\n\tmutex_unlock(&led->chip->mutex);\n\n\treturn ret;\n}\n\nstatic int aw2013_blink_set(struct led_classdev *cdev,\n\t\t\t    unsigned long *delay_on, unsigned long *delay_off)\n{\n\tstruct aw2013_led *led = container_of(cdev, struct aw2013_led, cdev);\n\tint ret, num = led->num;\n\tunsigned long off = 0, on = 0;\n\n\t \n\tif (!*delay_off && !*delay_on) {\n\t\t*delay_off = 500;\n\t\t*delay_on = 500;\n\t}\n\n\tif (!led->cdev.brightness) {\n\t\tled->cdev.brightness = LED_FULL;\n\t\tret = aw2013_brightness_set(&led->cdev, led->cdev.brightness);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!*delay_on) {\n\t\tled->cdev.brightness = LED_OFF;\n\t\treturn aw2013_brightness_set(&led->cdev, LED_OFF);\n\t}\n\n\tmutex_lock(&led->chip->mutex);\n\n\t \n\tif (!*delay_off) {\n\t\tret = regmap_update_bits(led->chip->regmap, AW2013_LCFG(num),\n\t\t\t\t\t AW2013_LCFG_MD, 0);\n\t\tgoto out;\n\t}\n\n\t \n\toff = min(5, ilog2((*delay_off - 1) / AW2013_TIME_STEP) + 1);\n\ton = min(7, ilog2((*delay_on - 1) / AW2013_TIME_STEP) + 1);\n\n\t*delay_off = BIT(off) * AW2013_TIME_STEP;\n\t*delay_on = BIT(on) * AW2013_TIME_STEP;\n\n\t \n\tret = regmap_write(led->chip->regmap,\n\t\t\t   AW2013_LEDT0(num), AW2013_LEDT0_T2(on));\n\tif (ret)\n\t\tgoto out;\n\tret = regmap_write(led->chip->regmap,\n\t\t\t   AW2013_LEDT1(num), AW2013_LEDT1_T4(off));\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = regmap_update_bits(led->chip->regmap, AW2013_LCFG(num),\n\t\t\t\t AW2013_LCFG_MD, 0xFF);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_update_bits(led->chip->regmap, AW2013_LCTR,\n\t\t\t\t AW2013_LCTR_LE(num), 0xFF);\n\nout:\n\tmutex_unlock(&led->chip->mutex);\n\n\treturn ret;\n}\n\nstatic int aw2013_probe_dt(struct aw2013 *chip)\n{\n\tstruct device_node *np = dev_of_node(&chip->client->dev), *child;\n\tint count, ret = 0, i = 0;\n\tstruct aw2013_led *led;\n\n\tcount = of_get_available_child_count(np);\n\tif (!count || count > AW2013_MAX_LEDS)\n\t\treturn -EINVAL;\n\n\tregmap_write(chip->regmap, AW2013_RSTR, AW2013_RSTR_RESET);\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tstruct led_init_data init_data = {};\n\t\tu32 source;\n\t\tu32 imax;\n\n\t\tret = of_property_read_u32(child, \"reg\", &source);\n\t\tif (ret != 0 || source >= AW2013_MAX_LEDS) {\n\t\t\tdev_err(&chip->client->dev,\n\t\t\t\t\"Couldn't read LED address: %d\\n\", ret);\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tled = &chip->leds[i];\n\t\tled->num = source;\n\t\tled->chip = chip;\n\t\tinit_data.fwnode = of_fwnode_handle(child);\n\n\t\tif (!of_property_read_u32(child, \"led-max-microamp\", &imax)) {\n\t\t\tled->imax = min_t(u32, imax / 5000, 3);\n\t\t} else {\n\t\t\tled->imax = 1; \n\t\t\tdev_info(&chip->client->dev,\n\t\t\t\t \"DT property led-max-microamp is missing\\n\");\n\t\t}\n\n\t\tled->cdev.brightness_set_blocking = aw2013_brightness_set;\n\t\tled->cdev.blink_set = aw2013_blink_set;\n\n\t\tret = devm_led_classdev_register_ext(&chip->client->dev,\n\t\t\t\t\t\t     &led->cdev, &init_data);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\ti++;\n\t}\n\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tchip->num_leds = i;\n\n\treturn 0;\n}\n\nstatic const struct regmap_config aw2013_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = AW2013_REG_MAX,\n};\n\nstatic int aw2013_probe(struct i2c_client *client)\n{\n\tstruct aw2013 *chip;\n\tint ret;\n\tunsigned int chipid;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&chip->mutex);\n\tmutex_lock(&chip->mutex);\n\n\tchip->client = client;\n\ti2c_set_clientdata(client, chip);\n\n\tchip->regmap = devm_regmap_init_i2c(client, &aw2013_regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\tret = PTR_ERR(chip->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\tgoto error;\n\t}\n\n\tchip->regulators[0].supply = \"vcc\";\n\tchip->regulators[1].supply = \"vio\";\n\tret = devm_regulator_bulk_get(&client->dev,\n\t\t\t\t      ARRAY_SIZE(chip->regulators),\n\t\t\t\t      chip->regulators);\n\tif (ret < 0) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to request regulators: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(chip->regulators),\n\t\t\t\t    chip->regulators);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to enable regulators: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = regmap_read(chip->regmap, AW2013_RSTR, &chipid);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to read chip ID: %d\\n\",\n\t\t\tret);\n\t\tgoto error_reg;\n\t}\n\n\tif (chipid != AW2013_RSTR_CHIP_ID) {\n\t\tdev_err(&client->dev, \"Chip reported wrong ID: %x\\n\",\n\t\t\tchipid);\n\t\tret = -ENODEV;\n\t\tgoto error_reg;\n\t}\n\n\tret = aw2013_probe_dt(chip);\n\tif (ret < 0)\n\t\tgoto error_reg;\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(chip->regulators),\n\t\t\t\t     chip->regulators);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to disable regulators: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tmutex_unlock(&chip->mutex);\n\n\treturn 0;\n\nerror_reg:\n\tregulator_bulk_disable(ARRAY_SIZE(chip->regulators),\n\t\t\t       chip->regulators);\n\nerror:\n\tmutex_destroy(&chip->mutex);\n\treturn ret;\n}\n\nstatic void aw2013_remove(struct i2c_client *client)\n{\n\tstruct aw2013 *chip = i2c_get_clientdata(client);\n\n\taw2013_chip_disable(chip);\n\n\tmutex_destroy(&chip->mutex);\n}\n\nstatic const struct of_device_id aw2013_match_table[] = {\n\t{ .compatible = \"awinic,aw2013\", },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, aw2013_match_table);\n\nstatic struct i2c_driver aw2013_driver = {\n\t.driver = {\n\t\t.name = \"leds-aw2013\",\n\t\t.of_match_table = aw2013_match_table,\n\t},\n\t.probe = aw2013_probe,\n\t.remove = aw2013_remove,\n};\n\nmodule_i2c_driver(aw2013_driver);\n\nMODULE_AUTHOR(\"Nikita Travkin <nikitos.tr@gmail.com>\");\nMODULE_DESCRIPTION(\"AW2013 LED driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}