{
  "module_name": "leds-an30259a.c",
  "hash_id": "845f51cb0aae06aebcb41e455e81872af78ce878c623036ce006295d9aacddd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-an30259a.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#define AN30259A_MAX_LEDS 3\n\n#define AN30259A_REG_SRESET 0x00\n#define AN30259A_LED_SRESET BIT(0)\n\n \n#define AN30259A_REG_LED_ON 0x01\n#define AN30259A_LED_EN(x) BIT((x) - 1)\n#define AN30259A_LED_SLOPE(x) BIT(((x) - 1) + 4)\n\n#define AN30259A_REG_LEDCC(x) (0x03 + ((x) - 1))\n\n \n#define AN30259A_REG_SLOPE(x) (0x06 + ((x) - 1))\n#define AN30259A_LED_SLOPETIME1(x) (x)\n#define AN30259A_LED_SLOPETIME2(x) ((x) << 4)\n\n#define AN30259A_REG_LEDCNT1(x) (0x09 + (4 * ((x) - 1)))\n#define AN30259A_LED_DUTYMAX(x) ((x) << 4)\n#define AN30259A_LED_DUTYMID(x) (x)\n\n#define AN30259A_REG_LEDCNT2(x) (0x0A + (4 * ((x) - 1)))\n#define AN30259A_LED_DELAY(x) ((x) << 4)\n#define AN30259A_LED_DUTYMIN(x) (x)\n\n \n#define AN30259A_REG_LEDCNT3(x) (0x0B + (4 * ((x) - 1)))\n#define AN30259A_LED_DT1(x) (x)\n#define AN30259A_LED_DT2(x) ((x) << 4)\n\n#define AN30259A_REG_LEDCNT4(x) (0x0C + (4 * ((x) - 1)))\n#define AN30259A_LED_DT3(x) (x)\n#define AN30259A_LED_DT4(x) ((x) << 4)\n\n#define AN30259A_REG_MAX 0x14\n\n#define AN30259A_BLINK_MAX_TIME 7500  \n#define AN30259A_SLOPE_RESOLUTION 500  \n\n#define AN30259A_NAME \"an30259a\"\n\nstruct an30259a;\n\nstruct an30259a_led {\n\tstruct an30259a *chip;\n\tstruct fwnode_handle *fwnode;\n\tstruct led_classdev cdev;\n\tu32 num;\n\tenum led_default_state default_state;\n\tbool sloping;\n};\n\nstruct an30259a {\n\tstruct mutex mutex;  \n\tstruct i2c_client *client;\n\tstruct an30259a_led leds[AN30259A_MAX_LEDS];\n\tstruct regmap *regmap;\n\tint num_leds;\n};\n\nstatic int an30259a_brightness_set(struct led_classdev *cdev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct an30259a_led *led;\n\tint ret;\n\tunsigned int led_on;\n\n\tled = container_of(cdev, struct an30259a_led, cdev);\n\tmutex_lock(&led->chip->mutex);\n\n\tret = regmap_read(led->chip->regmap, AN30259A_REG_LED_ON, &led_on);\n\tif (ret)\n\t\tgoto error;\n\n\tswitch (brightness) {\n\tcase LED_OFF:\n\t\tled_on &= ~AN30259A_LED_EN(led->num);\n\t\tled_on &= ~AN30259A_LED_SLOPE(led->num);\n\t\tled->sloping = false;\n\t\tbreak;\n\tdefault:\n\t\tled_on |= AN30259A_LED_EN(led->num);\n\t\tif (led->sloping)\n\t\t\tled_on |= AN30259A_LED_SLOPE(led->num);\n\t\tret = regmap_write(led->chip->regmap,\n\t\t\t\t   AN30259A_REG_LEDCNT1(led->num),\n\t\t\t\t   AN30259A_LED_DUTYMAX(0xf) |\n\t\t\t\t   AN30259A_LED_DUTYMID(0xf));\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tbreak;\n\t}\n\n\tret = regmap_write(led->chip->regmap, AN30259A_REG_LED_ON, led_on);\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_write(led->chip->regmap, AN30259A_REG_LEDCC(led->num),\n\t\t\t   brightness);\n\nerror:\n\tmutex_unlock(&led->chip->mutex);\n\n\treturn ret;\n}\n\nstatic int an30259a_blink_set(struct led_classdev *cdev,\n\t\t\t      unsigned long *delay_off, unsigned long *delay_on)\n{\n\tstruct an30259a_led *led;\n\tint ret, num;\n\tunsigned int led_on;\n\tunsigned long off = *delay_off, on = *delay_on;\n\n\tled = container_of(cdev, struct an30259a_led, cdev);\n\n\tmutex_lock(&led->chip->mutex);\n\tnum = led->num;\n\n\t \n\tif (off % AN30259A_SLOPE_RESOLUTION || on % AN30259A_SLOPE_RESOLUTION) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tif (off > AN30259A_BLINK_MAX_TIME || on > AN30259A_BLINK_MAX_TIME) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tif (!off && !on) {\n\t\t*delay_off = off = 500;\n\t\t*delay_on = on = 500;\n\t}\n\n\t \n\toff /= AN30259A_SLOPE_RESOLUTION;\n\ton /= AN30259A_SLOPE_RESOLUTION;\n\n\t \n\tret = regmap_write(led->chip->regmap, AN30259A_REG_LEDCNT2(num),\n\t\t\t   AN30259A_LED_DELAY(0) | AN30259A_LED_DUTYMIN(0));\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = regmap_write(led->chip->regmap, AN30259A_REG_LEDCNT3(num),\n\t\t\t   AN30259A_LED_DT1(0) | AN30259A_LED_DT2(0));\n\tif (ret)\n\t\tgoto error;\n\tret = regmap_write(led->chip->regmap, AN30259A_REG_LEDCNT4(num),\n\t\t\t   AN30259A_LED_DT3(0) | AN30259A_LED_DT4(0));\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = regmap_write(led->chip->regmap, AN30259A_REG_SLOPE(num),\n\t\t\t   AN30259A_LED_SLOPETIME1(off) |\n\t\t\t   AN30259A_LED_SLOPETIME2(on));\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = regmap_read(led->chip->regmap, AN30259A_REG_LED_ON, &led_on);\n\tif (ret)\n\t\tgoto error;\n\n\tled_on |= AN30259A_LED_SLOPE(num) | AN30259A_LED_EN(led->num);\n\n\tret = regmap_write(led->chip->regmap, AN30259A_REG_LED_ON, led_on);\n\n\tif (!ret)\n\t\tled->sloping = true;\nerror:\n\tmutex_unlock(&led->chip->mutex);\n\n\treturn ret;\n}\n\nstatic int an30259a_dt_init(struct i2c_client *client,\n\t\t\t    struct an30259a *chip)\n{\n\tstruct device_node *np = dev_of_node(&client->dev), *child;\n\tint count, ret;\n\tint i = 0;\n\tstruct an30259a_led *led;\n\n\tcount = of_get_available_child_count(np);\n\tif (!count || count > AN30259A_MAX_LEDS)\n\t\treturn -EINVAL;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tu32 source;\n\n\t\tret = of_property_read_u32(child, \"reg\", &source);\n\t\tif (ret != 0 || !source || source > AN30259A_MAX_LEDS) {\n\t\t\tdev_err(&client->dev, \"Couldn't read LED address: %d\\n\",\n\t\t\t\tret);\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tled = &chip->leds[i];\n\n\t\tled->num = source;\n\t\tled->chip = chip;\n\t\tled->fwnode = of_fwnode_handle(child);\n\t\tled->default_state = led_init_default_state_get(led->fwnode);\n\n\t\ti++;\n\t}\n\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tchip->num_leds = i;\n\n\treturn 0;\n}\n\nstatic const struct regmap_config an30259a_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = AN30259A_REG_MAX,\n};\n\nstatic void an30259a_init_default_state(struct an30259a_led *led)\n{\n\tstruct an30259a *chip = led->chip;\n\tint led_on, err;\n\n\tswitch (led->default_state) {\n\tcase LEDS_DEFSTATE_ON:\n\t\tled->cdev.brightness = LED_FULL;\n\t\tbreak;\n\tcase LEDS_DEFSTATE_KEEP:\n\t\terr = regmap_read(chip->regmap, AN30259A_REG_LED_ON, &led_on);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (!(led_on & AN30259A_LED_EN(led->num))) {\n\t\t\tled->cdev.brightness = LED_OFF;\n\t\t\tbreak;\n\t\t}\n\t\tregmap_read(chip->regmap, AN30259A_REG_LEDCC(led->num),\n\t\t\t    &led->cdev.brightness);\n\t\tbreak;\n\tdefault:\n\t\tled->cdev.brightness = LED_OFF;\n\t}\n\n\tan30259a_brightness_set(&led->cdev, led->cdev.brightness);\n}\n\nstatic int an30259a_probe(struct i2c_client *client)\n{\n\tstruct an30259a *chip;\n\tint i, err;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\terr = an30259a_dt_init(client, chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_init(&chip->mutex);\n\tchip->client = client;\n\ti2c_set_clientdata(client, chip);\n\n\tchip->regmap = devm_regmap_init_i2c(client, &an30259a_regmap_config);\n\n\tif (IS_ERR(chip->regmap)) {\n\t\terr = PTR_ERR(chip->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\terr);\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < chip->num_leds; i++) {\n\t\tstruct led_init_data init_data = {};\n\n\t\tan30259a_init_default_state(&chip->leds[i]);\n\t\tchip->leds[i].cdev.brightness_set_blocking =\n\t\t\tan30259a_brightness_set;\n\t\tchip->leds[i].cdev.blink_set = an30259a_blink_set;\n\n\t\tinit_data.fwnode = chip->leds[i].fwnode;\n\t\tinit_data.devicename = AN30259A_NAME;\n\t\tinit_data.default_label = \":\";\n\n\t\terr = devm_led_classdev_register_ext(&client->dev,\n\t\t\t\t\t\t &chip->leds[i].cdev,\n\t\t\t\t\t\t &init_data);\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\t}\n\treturn 0;\n\nexit:\n\tmutex_destroy(&chip->mutex);\n\treturn err;\n}\n\nstatic void an30259a_remove(struct i2c_client *client)\n{\n\tstruct an30259a *chip = i2c_get_clientdata(client);\n\n\tmutex_destroy(&chip->mutex);\n}\n\nstatic const struct of_device_id an30259a_match_table[] = {\n\t{ .compatible = \"panasonic,an30259a\", },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, an30259a_match_table);\n\nstatic const struct i2c_device_id an30259a_id[] = {\n\t{ \"an30259a\", 0 },\n\t{   },\n};\nMODULE_DEVICE_TABLE(i2c, an30259a_id);\n\nstatic struct i2c_driver an30259a_driver = {\n\t.driver = {\n\t\t.name = \"leds-an30259a\",\n\t\t.of_match_table = an30259a_match_table,\n\t},\n\t.probe = an30259a_probe,\n\t.remove = an30259a_remove,\n\t.id_table = an30259a_id,\n};\n\nmodule_i2c_driver(an30259a_driver);\n\nMODULE_AUTHOR(\"Simon Shields <simon@lineageos.org>\");\nMODULE_DESCRIPTION(\"AN30259A LED driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}