{
  "module_name": "led-class.c",
  "hash_id": "439fd84f6b53db91c4e83eb261258e264d155335d318a1a5d7c400d354f92b65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/led-class.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <uapi/linux/uleds.h>\n#include <linux/of.h>\n#include \"leds.h\"\n\nstatic DEFINE_MUTEX(leds_lookup_lock);\nstatic LIST_HEAD(leds_lookup_list);\n\nstatic ssize_t brightness_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\n\t \n\tled_update_brightness(led_cdev);\n\n\treturn sprintf(buf, \"%u\\n\", led_cdev->brightness);\n}\n\nstatic ssize_t brightness_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tunsigned long state;\n\tssize_t ret;\n\n\tmutex_lock(&led_cdev->led_access);\n\n\tif (led_sysfs_is_disabled(led_cdev)) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tret = kstrtoul(buf, 10, &state);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (state == LED_OFF)\n\t\tled_trigger_remove(led_cdev);\n\tled_set_brightness(led_cdev, state);\n\tflush_work(&led_cdev->set_brightness_work);\n\n\tret = size;\nunlock:\n\tmutex_unlock(&led_cdev->led_access);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(brightness);\n\nstatic ssize_t max_brightness_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", led_cdev->max_brightness);\n}\nstatic DEVICE_ATTR_RO(max_brightness);\n\n#ifdef CONFIG_LEDS_TRIGGERS\nstatic BIN_ATTR(trigger, 0644, led_trigger_read, led_trigger_write, 0);\nstatic struct bin_attribute *led_trigger_bin_attrs[] = {\n\t&bin_attr_trigger,\n\tNULL,\n};\nstatic const struct attribute_group led_trigger_group = {\n\t.bin_attrs = led_trigger_bin_attrs,\n};\n#endif\n\nstatic struct attribute *led_class_attrs[] = {\n\t&dev_attr_brightness.attr,\n\t&dev_attr_max_brightness.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group led_group = {\n\t.attrs = led_class_attrs,\n};\n\nstatic const struct attribute_group *led_groups[] = {\n\t&led_group,\n#ifdef CONFIG_LEDS_TRIGGERS\n\t&led_trigger_group,\n#endif\n\tNULL,\n};\n\n#ifdef CONFIG_LEDS_BRIGHTNESS_HW_CHANGED\nstatic ssize_t brightness_hw_changed_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\n\tif (led_cdev->brightness_hw_changed == -1)\n\t\treturn -ENODATA;\n\n\treturn sprintf(buf, \"%u\\n\", led_cdev->brightness_hw_changed);\n}\n\nstatic DEVICE_ATTR_RO(brightness_hw_changed);\n\nstatic int led_add_brightness_hw_changed(struct led_classdev *led_cdev)\n{\n\tstruct device *dev = led_cdev->dev;\n\tint ret;\n\n\tret = device_create_file(dev, &dev_attr_brightness_hw_changed);\n\tif (ret) {\n\t\tdev_err(dev, \"Error creating brightness_hw_changed\\n\");\n\t\treturn ret;\n\t}\n\n\tled_cdev->brightness_hw_changed_kn =\n\t\tsysfs_get_dirent(dev->kobj.sd, \"brightness_hw_changed\");\n\tif (!led_cdev->brightness_hw_changed_kn) {\n\t\tdev_err(dev, \"Error getting brightness_hw_changed kn\\n\");\n\t\tdevice_remove_file(dev, &dev_attr_brightness_hw_changed);\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void led_remove_brightness_hw_changed(struct led_classdev *led_cdev)\n{\n\tsysfs_put(led_cdev->brightness_hw_changed_kn);\n\tdevice_remove_file(led_cdev->dev, &dev_attr_brightness_hw_changed);\n}\n\nvoid led_classdev_notify_brightness_hw_changed(struct led_classdev *led_cdev, unsigned int brightness)\n{\n\tif (WARN_ON(!led_cdev->brightness_hw_changed_kn))\n\t\treturn;\n\n\tled_cdev->brightness_hw_changed = brightness;\n\tsysfs_notify_dirent(led_cdev->brightness_hw_changed_kn);\n}\nEXPORT_SYMBOL_GPL(led_classdev_notify_brightness_hw_changed);\n#else\nstatic int led_add_brightness_hw_changed(struct led_classdev *led_cdev)\n{\n\treturn 0;\n}\nstatic void led_remove_brightness_hw_changed(struct led_classdev *led_cdev)\n{\n}\n#endif\n\n \nvoid led_classdev_suspend(struct led_classdev *led_cdev)\n{\n\tled_cdev->flags |= LED_SUSPENDED;\n\tled_set_brightness_nopm(led_cdev, 0);\n\tflush_work(&led_cdev->set_brightness_work);\n}\nEXPORT_SYMBOL_GPL(led_classdev_suspend);\n\n \nvoid led_classdev_resume(struct led_classdev *led_cdev)\n{\n\tled_set_brightness_nopm(led_cdev, led_cdev->brightness);\n\n\tif (led_cdev->flash_resume)\n\t\tled_cdev->flash_resume(led_cdev);\n\n\tled_cdev->flags &= ~LED_SUSPENDED;\n}\nEXPORT_SYMBOL_GPL(led_classdev_resume);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int led_suspend(struct device *dev)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\n\tif (led_cdev->flags & LED_CORE_SUSPENDRESUME)\n\t\tled_classdev_suspend(led_cdev);\n\n\treturn 0;\n}\n\nstatic int led_resume(struct device *dev)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\n\tif (led_cdev->flags & LED_CORE_SUSPENDRESUME)\n\t\tled_classdev_resume(led_cdev);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(leds_class_dev_pm_ops, led_suspend, led_resume);\n\nstatic struct led_classdev *led_module_get(struct device *led_dev)\n{\n\tstruct led_classdev *led_cdev;\n\n\tif (!led_dev)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tled_cdev = dev_get_drvdata(led_dev);\n\n\tif (!try_module_get(led_cdev->dev->parent->driver->owner)) {\n\t\tput_device(led_cdev->dev);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\treturn led_cdev;\n}\n\nstatic const struct class leds_class = {\n\t.name = \"leds\",\n\t.dev_groups = led_groups,\n\t.pm = &leds_class_dev_pm_ops,\n};\n\n \nstruct led_classdev *of_led_get(struct device_node *np, int index)\n{\n\tstruct device *led_dev;\n\tstruct device_node *led_node;\n\n\tled_node = of_parse_phandle(np, \"leds\", index);\n\tif (!led_node)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tled_dev = class_find_device_by_of_node(&leds_class, led_node);\n\tof_node_put(led_node);\n\tput_device(led_dev);\n\n\treturn led_module_get(led_dev);\n}\nEXPORT_SYMBOL_GPL(of_led_get);\n\n \nvoid led_put(struct led_classdev *led_cdev)\n{\n\tmodule_put(led_cdev->dev->parent->driver->owner);\n\tput_device(led_cdev->dev);\n}\nEXPORT_SYMBOL_GPL(led_put);\n\nstatic void devm_led_release(struct device *dev, void *res)\n{\n\tstruct led_classdev **p = res;\n\n\tled_put(*p);\n}\n\nstatic struct led_classdev *__devm_led_get(struct device *dev, struct led_classdev *led)\n{\n\tstruct led_classdev **dr;\n\n\tdr = devres_alloc(devm_led_release, sizeof(struct led_classdev *), GFP_KERNEL);\n\tif (!dr) {\n\t\tled_put(led);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t*dr = led;\n\tdevres_add(dev, dr);\n\n\treturn led;\n}\n\n \nstruct led_classdev *__must_check devm_of_led_get(struct device *dev,\n\t\t\t\t\t\t  int index)\n{\n\tstruct led_classdev *led;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tled = of_led_get(dev->of_node, index);\n\tif (IS_ERR(led))\n\t\treturn led;\n\n\treturn __devm_led_get(dev, led);\n}\nEXPORT_SYMBOL_GPL(devm_of_led_get);\n\n \nstruct led_classdev *led_get(struct device *dev, char *con_id)\n{\n\tstruct led_lookup_data *lookup;\n\tconst char *provider = NULL;\n\tstruct device *led_dev;\n\n\tmutex_lock(&leds_lookup_lock);\n\tlist_for_each_entry(lookup, &leds_lookup_list, list) {\n\t\tif (!strcmp(lookup->dev_id, dev_name(dev)) &&\n\t\t    !strcmp(lookup->con_id, con_id)) {\n\t\t\tprovider = kstrdup_const(lookup->provider, GFP_KERNEL);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&leds_lookup_lock);\n\n\tif (!provider)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tled_dev = class_find_device_by_name(&leds_class, provider);\n\tkfree_const(provider);\n\n\treturn led_module_get(led_dev);\n}\nEXPORT_SYMBOL_GPL(led_get);\n\n \nstruct led_classdev *devm_led_get(struct device *dev, char *con_id)\n{\n\tstruct led_classdev *led;\n\n\tled = led_get(dev, con_id);\n\tif (IS_ERR(led))\n\t\treturn led;\n\n\treturn __devm_led_get(dev, led);\n}\nEXPORT_SYMBOL_GPL(devm_led_get);\n\n \nvoid led_add_lookup(struct led_lookup_data *led_lookup)\n{\n\tmutex_lock(&leds_lookup_lock);\n\tlist_add_tail(&led_lookup->list, &leds_lookup_list);\n\tmutex_unlock(&leds_lookup_lock);\n}\nEXPORT_SYMBOL_GPL(led_add_lookup);\n\n \nvoid led_remove_lookup(struct led_lookup_data *led_lookup)\n{\n\tmutex_lock(&leds_lookup_lock);\n\tlist_del(&led_lookup->list);\n\tmutex_unlock(&leds_lookup_lock);\n}\nEXPORT_SYMBOL_GPL(led_remove_lookup);\n\n \nstruct led_classdev *__must_check devm_of_led_get_optional(struct device *dev,\n\t\t\t\t\t\t\tint index)\n{\n\tstruct led_classdev *led;\n\n\tled = devm_of_led_get(dev, index);\n\tif (IS_ERR(led) && PTR_ERR(led) == -ENOENT)\n\t\treturn NULL;\n\n\treturn led;\n}\nEXPORT_SYMBOL_GPL(devm_of_led_get_optional);\n\nstatic int led_classdev_next_name(const char *init_name, char *name,\n\t\t\t\t  size_t len)\n{\n\tunsigned int i = 0;\n\tint ret = 0;\n\tstruct device *dev;\n\n\tstrscpy(name, init_name, len);\n\n\twhile ((ret < len) &&\n\t       (dev = class_find_device_by_name(&leds_class, name))) {\n\t\tput_device(dev);\n\t\tret = snprintf(name, len, \"%s_%u\", init_name, ++i);\n\t}\n\n\tif (ret >= len)\n\t\treturn -ENOMEM;\n\n\treturn i;\n}\n\n \nint led_classdev_register_ext(struct device *parent,\n\t\t\t      struct led_classdev *led_cdev,\n\t\t\t      struct led_init_data *init_data)\n{\n\tchar composed_name[LED_MAX_NAME_SIZE];\n\tchar final_name[LED_MAX_NAME_SIZE];\n\tconst char *proposed_name = composed_name;\n\tint ret;\n\n\tif (init_data) {\n\t\tif (init_data->devname_mandatory && !init_data->devicename) {\n\t\t\tdev_err(parent, \"Mandatory device name is missing\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = led_compose_name(parent, init_data, composed_name);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (init_data->fwnode) {\n\t\t\tfwnode_property_read_string(init_data->fwnode,\n\t\t\t\t\"linux,default-trigger\",\n\t\t\t\t&led_cdev->default_trigger);\n\n\t\t\tif (fwnode_property_present(init_data->fwnode,\n\t\t\t\t\t\t    \"retain-state-shutdown\"))\n\t\t\t\tled_cdev->flags |= LED_RETAIN_AT_SHUTDOWN;\n\n\t\t\tfwnode_property_read_u32(init_data->fwnode,\n\t\t\t\t\"max-brightness\",\n\t\t\t\t&led_cdev->max_brightness);\n\n\t\t\tif (fwnode_property_present(init_data->fwnode, \"color\"))\n\t\t\t\tfwnode_property_read_u32(init_data->fwnode, \"color\",\n\t\t\t\t\t\t\t &led_cdev->color);\n\t\t}\n\t} else {\n\t\tproposed_name = led_cdev->name;\n\t}\n\n\tret = led_classdev_next_name(proposed_name, final_name, sizeof(final_name));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (led_cdev->color >= LED_COLOR_ID_MAX)\n\t\tdev_warn(parent, \"LED %s color identifier out of range\\n\", final_name);\n\n\tmutex_init(&led_cdev->led_access);\n\tmutex_lock(&led_cdev->led_access);\n\tled_cdev->dev = device_create_with_groups(&leds_class, parent, 0,\n\t\t\t\t\t\t  led_cdev, led_cdev->groups, \"%s\", final_name);\n\tif (IS_ERR(led_cdev->dev)) {\n\t\tmutex_unlock(&led_cdev->led_access);\n\t\treturn PTR_ERR(led_cdev->dev);\n\t}\n\tif (init_data && init_data->fwnode)\n\t\tdevice_set_node(led_cdev->dev, init_data->fwnode);\n\n\tif (ret)\n\t\tdev_warn(parent, \"Led %s renamed to %s due to name collision\",\n\t\t\t\tproposed_name, dev_name(led_cdev->dev));\n\n\tif (led_cdev->flags & LED_BRIGHT_HW_CHANGED) {\n\t\tret = led_add_brightness_hw_changed(led_cdev);\n\t\tif (ret) {\n\t\t\tdevice_unregister(led_cdev->dev);\n\t\t\tled_cdev->dev = NULL;\n\t\t\tmutex_unlock(&led_cdev->led_access);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tled_cdev->work_flags = 0;\n#ifdef CONFIG_LEDS_TRIGGERS\n\tinit_rwsem(&led_cdev->trigger_lock);\n#endif\n#ifdef CONFIG_LEDS_BRIGHTNESS_HW_CHANGED\n\tled_cdev->brightness_hw_changed = -1;\n#endif\n\t \n\tdown_write(&leds_list_lock);\n\tlist_add_tail(&led_cdev->node, &leds_list);\n\tup_write(&leds_list_lock);\n\n\tif (!led_cdev->max_brightness)\n\t\tled_cdev->max_brightness = LED_FULL;\n\n\tled_update_brightness(led_cdev);\n\n\tled_init_core(led_cdev);\n\n#ifdef CONFIG_LEDS_TRIGGERS\n\tled_trigger_set_default(led_cdev);\n#endif\n\n\tmutex_unlock(&led_cdev->led_access);\n\n\tdev_dbg(parent, \"Registered led device: %s\\n\",\n\t\t\tled_cdev->name);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(led_classdev_register_ext);\n\n \nvoid led_classdev_unregister(struct led_classdev *led_cdev)\n{\n\tif (IS_ERR_OR_NULL(led_cdev->dev))\n\t\treturn;\n\n#ifdef CONFIG_LEDS_TRIGGERS\n\tdown_write(&led_cdev->trigger_lock);\n\tif (led_cdev->trigger)\n\t\tled_trigger_set(led_cdev, NULL);\n\tup_write(&led_cdev->trigger_lock);\n#endif\n\n\tled_cdev->flags |= LED_UNREGISTERING;\n\n\t \n\tled_stop_software_blink(led_cdev);\n\n\tif (!(led_cdev->flags & LED_RETAIN_AT_SHUTDOWN))\n\t\tled_set_brightness(led_cdev, LED_OFF);\n\n\tflush_work(&led_cdev->set_brightness_work);\n\n\tif (led_cdev->flags & LED_BRIGHT_HW_CHANGED)\n\t\tled_remove_brightness_hw_changed(led_cdev);\n\n\tdevice_unregister(led_cdev->dev);\n\n\tdown_write(&leds_list_lock);\n\tlist_del(&led_cdev->node);\n\tup_write(&leds_list_lock);\n\n\tmutex_destroy(&led_cdev->led_access);\n}\nEXPORT_SYMBOL_GPL(led_classdev_unregister);\n\nstatic void devm_led_classdev_release(struct device *dev, void *res)\n{\n\tled_classdev_unregister(*(struct led_classdev **)res);\n}\n\n \nint devm_led_classdev_register_ext(struct device *parent,\n\t\t\t\t   struct led_classdev *led_cdev,\n\t\t\t\t   struct led_init_data *init_data)\n{\n\tstruct led_classdev **dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_led_classdev_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\trc = led_classdev_register_ext(parent, led_cdev, init_data);\n\tif (rc) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\t*dr = led_cdev;\n\tdevres_add(parent, dr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_led_classdev_register_ext);\n\nstatic int devm_led_classdev_match(struct device *dev, void *res, void *data)\n{\n\tstruct led_classdev **p = res;\n\n\tif (WARN_ON(!p || !*p))\n\t\treturn 0;\n\n\treturn *p == data;\n}\n\n \nvoid devm_led_classdev_unregister(struct device *dev,\n\t\t\t\t  struct led_classdev *led_cdev)\n{\n\tWARN_ON(devres_release(dev,\n\t\t\t       devm_led_classdev_release,\n\t\t\t       devm_led_classdev_match, led_cdev));\n}\nEXPORT_SYMBOL_GPL(devm_led_classdev_unregister);\n\nstatic int __init leds_init(void)\n{\n\treturn class_register(&leds_class);\n}\n\nstatic void __exit leds_exit(void)\n{\n\tclass_unregister(&leds_class);\n}\n\nsubsys_initcall(leds_init);\nmodule_exit(leds_exit);\n\nMODULE_AUTHOR(\"John Lenz, Richard Purdie\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"LED Class Interface\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}