{
  "module_name": "leds-is31fl319x.c",
  "hash_id": "513c086fe244df2ac1c889bb1718774e63d48b71434f987c66babfcb2c17715b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-is31fl319x.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n\n \n#define IS31FL319X_SHUTDOWN\t\t0x00\n\n \n#define IS31FL3190_BREATHING\t\t0x01\n#define IS31FL3190_LEDMODE\t\t0x02\n#define IS31FL3190_CURRENT\t\t0x03\n#define IS31FL3190_PWM(channel)\t\t(0x04 + channel)\n#define IS31FL3190_DATA_UPDATE\t\t0x07\n#define IS31FL3190_T0(channel)\t\t(0x0a + channel)\n#define IS31FL3190_T1T2(channel)\t(0x10 + channel)\n#define IS31FL3190_T3T4(channel)\t(0x16 + channel)\n#define IS31FL3190_TIME_UPDATE\t\t0x1c\n#define IS31FL3190_LEDCONTROL\t\t0x1d\n#define IS31FL3190_RESET\t\t0x2f\n\n#define IS31FL3190_CURRENT_uA_MIN\t5000\n#define IS31FL3190_CURRENT_uA_DEFAULT\t42000\n#define IS31FL3190_CURRENT_uA_MAX\t42000\n#define IS31FL3190_CURRENT_SHIFT\t2\n#define IS31FL3190_CURRENT_MASK\t\tGENMASK(4, 2)\n#define IS31FL3190_CURRENT_5_mA\t\t0x02\n#define IS31FL3190_CURRENT_10_mA\t0x01\n#define IS31FL3190_CURRENT_17dot5_mA\t0x04\n#define IS31FL3190_CURRENT_30_mA\t0x03\n#define IS31FL3190_CURRENT_42_mA\t0x00\n\n \n#define IS31FL3196_CTRL1\t\t0x01\n#define IS31FL3196_CTRL2\t\t0x02\n#define IS31FL3196_CONFIG1\t\t0x03\n#define IS31FL3196_CONFIG2\t\t0x04\n#define IS31FL3196_RAMP_MODE\t\t0x05\n#define IS31FL3196_BREATH_MARK\t\t0x06\n#define IS31FL3196_PWM(channel)\t\t(0x07 + channel)\n#define IS31FL3196_DATA_UPDATE\t\t0x10\n#define IS31FL3196_T0(channel)\t\t(0x11 + channel)\n#define IS31FL3196_T123_1\t\t0x1a\n#define IS31FL3196_T123_2\t\t0x1b\n#define IS31FL3196_T123_3\t\t0x1c\n#define IS31FL3196_T4(channel)\t\t(0x1d + channel)\n#define IS31FL3196_TIME_UPDATE\t\t0x26\n#define IS31FL3196_RESET\t\t0xff\n\n#define IS31FL3196_REG_CNT\t\t(IS31FL3196_RESET + 1)\n\n#define IS31FL319X_MAX_LEDS\t\t9\n\n \n#define IS31FL3196_CONFIG2_CS_SHIFT\t4\n#define IS31FL3196_CONFIG2_CS_MASK\tGENMASK(2, 0)\n#define IS31FL3196_CONFIG2_CS_STEP_REF\t12\n\n#define IS31FL3196_CURRENT_uA_MIN\t5000\n#define IS31FL3196_CURRENT_uA_MAX\t40000\n#define IS31FL3196_CURRENT_uA_STEP\t5000\n#define IS31FL3196_CURRENT_uA_DEFAULT\t20000\n\n \n#define IS31FL3196_AUDIO_GAIN_DB_MAX\t((u32)21)\n#define IS31FL3196_AUDIO_GAIN_DB_STEP\t3\n\n \nstruct is31fl319x_chip {\n\tconst struct is31fl319x_chipdef *cdef;\n\tstruct i2c_client               *client;\n\tstruct gpio_desc\t\t*shutdown_gpio;\n\tstruct regmap                   *regmap;\n\tstruct mutex                    lock;\n\tu32                             audio_gain_db;\n\n\tstruct is31fl319x_led {\n\t\tstruct is31fl319x_chip  *chip;\n\t\tstruct led_classdev     cdev;\n\t\tu32                     max_microamp;\n\t\tbool                    configured;\n\t} leds[IS31FL319X_MAX_LEDS];\n};\n\nstruct is31fl319x_chipdef {\n\tint num_leds;\n\tu8 reset_reg;\n\tconst struct regmap_config *is31fl319x_regmap_config;\n\tint (*brightness_set)(struct led_classdev *cdev, enum led_brightness brightness);\n\tu32 current_default;\n\tu32 current_min;\n\tu32 current_max;\n\tbool is_3196or3199;\n};\n\nstatic bool is31fl319x_readable_reg(struct device *dev, unsigned int reg)\n{\n\t \n\treturn false;\n}\n\nstatic bool is31fl3190_volatile_reg(struct device *dev, unsigned int reg)\n{\n\t \n\tswitch (reg) {\n\tcase IS31FL3190_DATA_UPDATE:\n\tcase IS31FL3190_TIME_UPDATE:\n\tcase IS31FL3190_RESET:\n\t\treturn true;  \n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct reg_default is31fl3190_reg_defaults[] = {\n\t{ IS31FL3190_LEDMODE, 0x00 },\n\t{ IS31FL3190_CURRENT, 0x00 },\n\t{ IS31FL3190_PWM(0), 0x00 },\n\t{ IS31FL3190_PWM(1), 0x00 },\n\t{ IS31FL3190_PWM(2), 0x00 },\n};\n\nstatic struct regmap_config is31fl3190_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = IS31FL3190_RESET,\n\t.cache_type = REGCACHE_FLAT,\n\t.readable_reg = is31fl319x_readable_reg,\n\t.volatile_reg = is31fl3190_volatile_reg,\n\t.reg_defaults = is31fl3190_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(is31fl3190_reg_defaults),\n};\n\nstatic bool is31fl3196_volatile_reg(struct device *dev, unsigned int reg)\n{\n\t \n\tswitch (reg) {\n\tcase IS31FL3196_DATA_UPDATE:\n\tcase IS31FL3196_TIME_UPDATE:\n\tcase IS31FL3196_RESET:\n\t\treturn true;  \n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct reg_default is31fl3196_reg_defaults[] = {\n\t{ IS31FL3196_CONFIG1, 0x00 },\n\t{ IS31FL3196_CONFIG2, 0x00 },\n\t{ IS31FL3196_PWM(0), 0x00 },\n\t{ IS31FL3196_PWM(1), 0x00 },\n\t{ IS31FL3196_PWM(2), 0x00 },\n\t{ IS31FL3196_PWM(3), 0x00 },\n\t{ IS31FL3196_PWM(4), 0x00 },\n\t{ IS31FL3196_PWM(5), 0x00 },\n\t{ IS31FL3196_PWM(6), 0x00 },\n\t{ IS31FL3196_PWM(7), 0x00 },\n\t{ IS31FL3196_PWM(8), 0x00 },\n};\n\nstatic struct regmap_config is31fl3196_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = IS31FL3196_REG_CNT,\n\t.cache_type = REGCACHE_FLAT,\n\t.readable_reg = is31fl319x_readable_reg,\n\t.volatile_reg = is31fl3196_volatile_reg,\n\t.reg_defaults = is31fl3196_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(is31fl3196_reg_defaults),\n};\n\nstatic int is31fl3190_brightness_set(struct led_classdev *cdev,\n\t\t\t\t     enum led_brightness brightness)\n{\n\tstruct is31fl319x_led *led = container_of(cdev, struct is31fl319x_led, cdev);\n\tstruct is31fl319x_chip *is31 = led->chip;\n\tint chan = led - is31->leds;\n\tint ret;\n\tint i;\n\tu8 ctrl = 0;\n\n\tdev_dbg(&is31->client->dev, \"channel %d: %d\\n\", chan, brightness);\n\n\tmutex_lock(&is31->lock);\n\n\t \n\tret = regmap_write(is31->regmap, IS31FL3190_PWM(chan), brightness);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < is31->cdef->num_leds; i++) {\n\t\tunsigned int pwm_value;\n\t\tbool on;\n\n\t\t \n\n\t\tret = regmap_read(is31->regmap, IS31FL3190_PWM(i), &pwm_value);\n\t\ton = ret >= 0 && pwm_value > LED_OFF;\n\n\t\tctrl |= on << i;\n\t}\n\n\tif (ctrl > 0) {\n\t\tdev_dbg(&is31->client->dev, \"power up %02x\\n\", ctrl);\n\t\tregmap_write(is31->regmap, IS31FL3190_LEDCONTROL, ctrl);\n\t\t \n\t\tregmap_write(is31->regmap, IS31FL3190_DATA_UPDATE, 0x00);\n\t\t \n\t\tret = regmap_write(is31->regmap, IS31FL319X_SHUTDOWN, 0x20);\n\t} else {\n\t\tdev_dbg(&is31->client->dev, \"power down\\n\");\n\t\t \n\t\tret = regmap_write(is31->regmap, IS31FL319X_SHUTDOWN, 0x01);\n\t}\n\nout:\n\tmutex_unlock(&is31->lock);\n\n\treturn ret;\n}\n\nstatic int is31fl3196_brightness_set(struct led_classdev *cdev,\n\t\t\t\t     enum led_brightness brightness)\n{\n\tstruct is31fl319x_led *led = container_of(cdev, struct is31fl319x_led, cdev);\n\tstruct is31fl319x_chip *is31 = led->chip;\n\tint chan = led - is31->leds;\n\tint ret;\n\tint i;\n\tu8 ctrl1 = 0, ctrl2 = 0;\n\n\tdev_dbg(&is31->client->dev, \"channel %d: %d\\n\", chan, brightness);\n\n\tmutex_lock(&is31->lock);\n\n\t \n\tret = regmap_write(is31->regmap, IS31FL3196_PWM(chan), brightness);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < is31->cdef->num_leds; i++) {\n\t\tunsigned int pwm_value;\n\t\tbool on;\n\n\t\t \n\n\t\tret = regmap_read(is31->regmap, IS31FL3196_PWM(i), &pwm_value);\n\t\ton = ret >= 0 && pwm_value > LED_OFF;\n\n\t\tif (i < 3)\n\t\t\tctrl1 |= on << i;        \n\t\telse if (i < 6)\n\t\t\tctrl1 |= on << (i + 1);  \n\t\telse\n\t\t\tctrl2 |= on << (i - 6);  \n\t}\n\n\tif (ctrl1 > 0 || ctrl2 > 0) {\n\t\tdev_dbg(&is31->client->dev, \"power up %02x %02x\\n\",\n\t\t\tctrl1, ctrl2);\n\t\tregmap_write(is31->regmap, IS31FL3196_CTRL1, ctrl1);\n\t\tregmap_write(is31->regmap, IS31FL3196_CTRL2, ctrl2);\n\t\t \n\t\tregmap_write(is31->regmap, IS31FL3196_DATA_UPDATE, 0x00);\n\t\t \n\t\tret = regmap_write(is31->regmap, IS31FL319X_SHUTDOWN, 0x01);\n\t} else {\n\t\tdev_dbg(&is31->client->dev, \"power down\\n\");\n\t\t \n\t\tret = regmap_write(is31->regmap, IS31FL319X_SHUTDOWN, 0x00);\n\t}\n\nout:\n\tmutex_unlock(&is31->lock);\n\n\treturn ret;\n}\n\nstatic const struct is31fl319x_chipdef is31fl3190_cdef = {\n\t.num_leds = 1,\n\t.reset_reg = IS31FL3190_RESET,\n\t.is31fl319x_regmap_config = &is31fl3190_regmap_config,\n\t.brightness_set = is31fl3190_brightness_set,\n\t.current_default = IS31FL3190_CURRENT_uA_DEFAULT,\n\t.current_min = IS31FL3190_CURRENT_uA_MIN,\n\t.current_max = IS31FL3190_CURRENT_uA_MAX,\n\t.is_3196or3199 = false,\n};\n\nstatic const struct is31fl319x_chipdef is31fl3193_cdef = {\n\t.num_leds = 3,\n\t.reset_reg = IS31FL3190_RESET,\n\t.is31fl319x_regmap_config = &is31fl3190_regmap_config,\n\t.brightness_set = is31fl3190_brightness_set,\n\t.current_default = IS31FL3190_CURRENT_uA_DEFAULT,\n\t.current_min = IS31FL3190_CURRENT_uA_MIN,\n\t.current_max = IS31FL3190_CURRENT_uA_MAX,\n\t.is_3196or3199 = false,\n};\n\nstatic const struct is31fl319x_chipdef is31fl3196_cdef = {\n\t.num_leds = 6,\n\t.reset_reg = IS31FL3196_RESET,\n\t.is31fl319x_regmap_config = &is31fl3196_regmap_config,\n\t.brightness_set = is31fl3196_brightness_set,\n\t.current_default = IS31FL3196_CURRENT_uA_DEFAULT,\n\t.current_min = IS31FL3196_CURRENT_uA_MIN,\n\t.current_max = IS31FL3196_CURRENT_uA_MAX,\n\t.is_3196or3199 = true,\n};\n\nstatic const struct is31fl319x_chipdef is31fl3199_cdef = {\n\t.num_leds = 9,\n\t.reset_reg = IS31FL3196_RESET,\n\t.is31fl319x_regmap_config = &is31fl3196_regmap_config,\n\t.brightness_set = is31fl3196_brightness_set,\n\t.current_default = IS31FL3196_CURRENT_uA_DEFAULT,\n\t.current_min = IS31FL3196_CURRENT_uA_MIN,\n\t.current_max = IS31FL3196_CURRENT_uA_MAX,\n\t.is_3196or3199 = true,\n};\n\nstatic const struct of_device_id of_is31fl319x_match[] = {\n\t{ .compatible = \"issi,is31fl3190\", .data = &is31fl3190_cdef, },\n\t{ .compatible = \"issi,is31fl3191\", .data = &is31fl3190_cdef, },\n\t{ .compatible = \"issi,is31fl3193\", .data = &is31fl3193_cdef, },\n\t{ .compatible = \"issi,is31fl3196\", .data = &is31fl3196_cdef, },\n\t{ .compatible = \"issi,is31fl3199\", .data = &is31fl3199_cdef, },\n\t{ .compatible = \"si-en,sn3190\",    .data = &is31fl3190_cdef, },\n\t{ .compatible = \"si-en,sn3191\",    .data = &is31fl3190_cdef, },\n\t{ .compatible = \"si-en,sn3193\",    .data = &is31fl3193_cdef, },\n\t{ .compatible = \"si-en,sn3196\",    .data = &is31fl3196_cdef, },\n\t{ .compatible = \"si-en,sn3199\",    .data = &is31fl3199_cdef, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, of_is31fl319x_match);\n\nstatic int is31fl319x_parse_child_fw(const struct device *dev,\n\t\t\t\t     const struct fwnode_handle *child,\n\t\t\t\t     struct is31fl319x_led *led,\n\t\t\t\t     struct is31fl319x_chip *is31)\n{\n\tstruct led_classdev *cdev = &led->cdev;\n\tint ret;\n\n\tif (fwnode_property_read_string(child, \"label\", &cdev->name))\n\t\tcdev->name = fwnode_get_name(child);\n\n\tret = fwnode_property_read_string(child, \"linux,default-trigger\", &cdev->default_trigger);\n\tif (ret < 0 && ret != -EINVAL)  \n\t\treturn ret;\n\n\tled->max_microamp = is31->cdef->current_default;\n\tret = fwnode_property_read_u32(child, \"led-max-microamp\", &led->max_microamp);\n\tif (!ret) {\n\t\tif (led->max_microamp < is31->cdef->current_min)\n\t\t\treturn -EINVAL;\t \n\t\tled->max_microamp = min(led->max_microamp,\n\t\t\t\t\tis31->cdef->current_max);\n\t}\n\n\treturn 0;\n}\n\nstatic int is31fl319x_parse_fw(struct device *dev, struct is31fl319x_chip *is31)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev), *child;\n\tint count;\n\tint ret;\n\n\tis31->shutdown_gpio = devm_gpiod_get_optional(dev, \"shutdown\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(is31->shutdown_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(is31->shutdown_gpio),\n\t\t\t\t     \"Failed to get shutdown gpio\\n\");\n\n\tis31->cdef = device_get_match_data(dev);\n\n\tcount = 0;\n\tfwnode_for_each_available_child_node(fwnode, child)\n\t\tcount++;\n\n\tdev_dbg(dev, \"probing with %d leds defined in DT\\n\", count);\n\n\tif (!count || count > is31->cdef->num_leds)\n\t\treturn dev_err_probe(dev, -ENODEV,\n\t\t\t\t     \"Number of leds defined must be between 1 and %u\\n\",\n\t\t\t\t     is31->cdef->num_leds);\n\n\tfwnode_for_each_available_child_node(fwnode, child) {\n\t\tstruct is31fl319x_led *led;\n\t\tu32 reg;\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret) {\n\t\t\tret = dev_err_probe(dev, ret, \"Failed to read led 'reg' property\\n\");\n\t\t\tgoto put_child_node;\n\t\t}\n\n\t\tif (reg < 1 || reg > is31->cdef->num_leds) {\n\t\t\tret = dev_err_probe(dev, -EINVAL, \"invalid led reg %u\\n\", reg);\n\t\t\tgoto put_child_node;\n\t\t}\n\n\t\tled = &is31->leds[reg - 1];\n\n\t\tif (led->configured) {\n\t\t\tret = dev_err_probe(dev, -EINVAL, \"led %u is already configured\\n\", reg);\n\t\t\tgoto put_child_node;\n\t\t}\n\n\t\tret = is31fl319x_parse_child_fw(dev, child, led, is31);\n\t\tif (ret) {\n\t\t\tret = dev_err_probe(dev, ret, \"led %u DT parsing failed\\n\", reg);\n\t\t\tgoto put_child_node;\n\t\t}\n\n\t\tled->configured = true;\n\t}\n\n\tis31->audio_gain_db = 0;\n\tif (is31->cdef->is_3196or3199) {\n\t\tret = fwnode_property_read_u32(fwnode, \"audio-gain-db\", &is31->audio_gain_db);\n\t\tif (!ret)\n\t\t\tis31->audio_gain_db = min(is31->audio_gain_db,\n\t\t\t\t\t\t  IS31FL3196_AUDIO_GAIN_DB_MAX);\n\t}\n\n\treturn 0;\n\nput_child_node:\n\tfwnode_handle_put(child);\n\treturn ret;\n}\n\nstatic inline int is31fl3190_microamp_to_cs(struct device *dev, u32 microamp)\n{\n\tswitch (microamp) {\n\tcase 5000:\n\t\treturn IS31FL3190_CURRENT_5_mA;\n\tcase 10000:\n\t\treturn IS31FL3190_CURRENT_10_mA;\n\tcase 17500:\n\t\treturn IS31FL3190_CURRENT_17dot5_mA;\n\tcase 30000:\n\t\treturn IS31FL3190_CURRENT_30_mA;\n\tcase 42000:\n\t\treturn IS31FL3190_CURRENT_42_mA;\n\tdefault:\n\t\tdev_warn(dev, \"Unsupported current value: %d, using 5000 \u00b5A!\\n\", microamp);\n\t\treturn IS31FL3190_CURRENT_5_mA;\n\t}\n}\n\nstatic inline int is31fl3196_microamp_to_cs(struct device *dev, u32 microamp)\n{\n\t \n\tu32 step = microamp / IS31FL3196_CURRENT_uA_STEP;\n\n\treturn ((IS31FL3196_CONFIG2_CS_STEP_REF - step) &\n\t\tIS31FL3196_CONFIG2_CS_MASK) <<\n\t\tIS31FL3196_CONFIG2_CS_SHIFT;  \n}\n\nstatic inline int is31fl3196_db_to_gain(u32 dezibel)\n{\n\t \n\treturn dezibel / IS31FL3196_AUDIO_GAIN_DB_STEP;\n}\n\nstatic void is31f1319x_mutex_destroy(void *lock)\n{\n\tmutex_destroy(lock);\n}\n\nstatic int is31fl319x_probe(struct i2c_client *client)\n{\n\tstruct is31fl319x_chip *is31;\n\tstruct device *dev = &client->dev;\n\tint err;\n\tint i = 0;\n\tu32 aggregated_led_microamp;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -EIO;\n\n\tis31 = devm_kzalloc(&client->dev, sizeof(*is31), GFP_KERNEL);\n\tif (!is31)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&is31->lock);\n\terr = devm_add_action_or_reset(dev, is31f1319x_mutex_destroy, &is31->lock);\n\tif (err)\n\t\treturn err;\n\n\terr = is31fl319x_parse_fw(&client->dev, is31);\n\tif (err)\n\t\treturn err;\n\n\tif (is31->shutdown_gpio) {\n\t\tgpiod_direction_output(is31->shutdown_gpio, 0);\n\t\tmdelay(5);\n\t\tgpiod_direction_output(is31->shutdown_gpio, 1);\n\t}\n\n\tis31->client = client;\n\tis31->regmap = devm_regmap_init_i2c(client, is31->cdef->is31fl319x_regmap_config);\n\tif (IS_ERR(is31->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(is31->regmap), \"failed to allocate register map\\n\");\n\n\ti2c_set_clientdata(client, is31);\n\n\t \n\terr = regmap_write(is31->regmap, is31->cdef->reset_reg, 0x00);\n\tif (err < 0)\n\t\treturn dev_err_probe(dev, err, \"no response from chip write\\n\");\n\n\t \n\taggregated_led_microamp = is31->cdef->current_max;\n\tfor (i = 0; i < is31->cdef->num_leds; i++)\n\t\tif (is31->leds[i].configured &&\n\t\t    is31->leds[i].max_microamp < aggregated_led_microamp)\n\t\t\taggregated_led_microamp = is31->leds[i].max_microamp;\n\n\tif (is31->cdef->is_3196or3199)\n\t\tregmap_write(is31->regmap, IS31FL3196_CONFIG2,\n\t\t\t     is31fl3196_microamp_to_cs(dev, aggregated_led_microamp) |\n\t\t\t     is31fl3196_db_to_gain(is31->audio_gain_db));\n\telse\n\t\tregmap_update_bits(is31->regmap, IS31FL3190_CURRENT, IS31FL3190_CURRENT_MASK,\n\t\t\t\t   is31fl3190_microamp_to_cs(dev, aggregated_led_microamp) << IS31FL3190_CURRENT_SHIFT);\n\n\tfor (i = 0; i < is31->cdef->num_leds; i++) {\n\t\tstruct is31fl319x_led *led = &is31->leds[i];\n\n\t\tif (!led->configured)\n\t\t\tcontinue;\n\n\t\tled->chip = is31;\n\t\tled->cdev.brightness_set_blocking = is31->cdef->brightness_set;\n\n\t\terr = devm_led_classdev_register(&client->dev, &led->cdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct i2c_device_id is31fl319x_id[] = {\n\t{ \"is31fl3190\" },\n\t{ \"is31fl3191\" },\n\t{ \"is31fl3193\" },\n\t{ \"is31fl3196\" },\n\t{ \"is31fl3199\" },\n\t{ \"sn3190\" },\n\t{ \"sn3191\" },\n\t{ \"sn3193\" },\n\t{ \"sn3196\" },\n\t{ \"sn3199\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, is31fl319x_id);\n\nstatic struct i2c_driver is31fl319x_driver = {\n\t.driver   = {\n\t\t.name           = \"leds-is31fl319x\",\n\t\t.of_match_table = of_is31fl319x_match,\n\t},\n\t.probe = is31fl319x_probe,\n\t.id_table = is31fl319x_id,\n};\n\nmodule_i2c_driver(is31fl319x_driver);\n\nMODULE_AUTHOR(\"H. Nikolaus Schaller <hns@goldelico.com>\");\nMODULE_AUTHOR(\"Andrey Utkin <andrey_utkin@fastmail.com>\");\nMODULE_DESCRIPTION(\"IS31FL319X LED driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}