{
  "module_name": "leds-ns2.c",
  "hash_id": "24402d70c033088ebfe7f7f72d45f084c2774c23ad8b976f25cde9b78958f368",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-ns2.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include \"leds.h\"\n\nenum ns2_led_modes {\n\tNS_V2_LED_OFF,\n\tNS_V2_LED_ON,\n\tNS_V2_LED_SATA,\n};\n\n \nstruct ns2_led_modval {\n\tu32\t\t\tmode;\n\tu32\t\t\tcmd_level;\n\tu32\t\t\tslow_level;\n} __packed;\n\n \n\nstruct ns2_led {\n\tstruct led_classdev\tcdev;\n\tstruct gpio_desc\t*cmd;\n\tstruct gpio_desc\t*slow;\n\tbool\t\t\tcan_sleep;\n\tunsigned char\t\tsata;  \n\trwlock_t\t\trw_lock;  \n\tint\t\t\tnum_modes;\n\tstruct ns2_led_modval\t*modval;\n};\n\nstatic int ns2_led_get_mode(struct ns2_led *led, enum ns2_led_modes *mode)\n{\n\tint i;\n\tint cmd_level;\n\tint slow_level;\n\n\tcmd_level = gpiod_get_value_cansleep(led->cmd);\n\tslow_level = gpiod_get_value_cansleep(led->slow);\n\n\tfor (i = 0; i < led->num_modes; i++) {\n\t\tif (cmd_level == led->modval[i].cmd_level &&\n\t\t    slow_level == led->modval[i].slow_level) {\n\t\t\t*mode = led->modval[i].mode;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void ns2_led_set_mode(struct ns2_led *led, enum ns2_led_modes mode)\n{\n\tint i;\n\tunsigned long flags;\n\n\tfor (i = 0; i < led->num_modes; i++)\n\t\tif (mode == led->modval[i].mode)\n\t\t\tbreak;\n\n\tif (i == led->num_modes)\n\t\treturn;\n\n\twrite_lock_irqsave(&led->rw_lock, flags);\n\n\tif (!led->can_sleep) {\n\t\tgpiod_set_value(led->cmd, led->modval[i].cmd_level);\n\t\tgpiod_set_value(led->slow, led->modval[i].slow_level);\n\t\tgoto exit_unlock;\n\t}\n\n\tgpiod_set_value_cansleep(led->cmd, led->modval[i].cmd_level);\n\tgpiod_set_value_cansleep(led->slow, led->modval[i].slow_level);\n\nexit_unlock:\n\twrite_unlock_irqrestore(&led->rw_lock, flags);\n}\n\nstatic void ns2_led_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness value)\n{\n\tstruct ns2_led *led = container_of(led_cdev, struct ns2_led, cdev);\n\tenum ns2_led_modes mode;\n\n\tif (value == LED_OFF)\n\t\tmode = NS_V2_LED_OFF;\n\telse if (led->sata)\n\t\tmode = NS_V2_LED_SATA;\n\telse\n\t\tmode = NS_V2_LED_ON;\n\n\tns2_led_set_mode(led, mode);\n}\n\nstatic int ns2_led_set_blocking(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness value)\n{\n\tns2_led_set(led_cdev, value);\n\treturn 0;\n}\n\nstatic ssize_t ns2_led_sata_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buff, size_t count)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct ns2_led *led = container_of(led_cdev, struct ns2_led, cdev);\n\tint ret;\n\tunsigned long enable;\n\n\tret = kstrtoul(buff, 10, &enable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tenable = !!enable;\n\n\tif (led->sata == enable)\n\t\tgoto exit;\n\n\tled->sata = enable;\n\n\tif (!led_get_brightness(led_cdev))\n\t\tgoto exit;\n\n\tif (enable)\n\t\tns2_led_set_mode(led, NS_V2_LED_SATA);\n\telse\n\t\tns2_led_set_mode(led, NS_V2_LED_ON);\n\nexit:\n\treturn count;\n}\n\nstatic ssize_t ns2_led_sata_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct ns2_led *led = container_of(led_cdev, struct ns2_led, cdev);\n\n\treturn sprintf(buf, \"%d\\n\", led->sata);\n}\n\nstatic DEVICE_ATTR(sata, 0644, ns2_led_sata_show, ns2_led_sata_store);\n\nstatic struct attribute *ns2_led_attrs[] = {\n\t&dev_attr_sata.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(ns2_led);\n\nstatic int ns2_led_register(struct device *dev, struct fwnode_handle *node,\n\t\t\t    struct ns2_led *led)\n{\n\tstruct led_init_data init_data = {};\n\tstruct ns2_led_modval *modval;\n\tenum ns2_led_modes mode;\n\tint nmodes, ret;\n\n\tled->cmd = devm_fwnode_gpiod_get_index(dev, node, \"cmd\", 0, GPIOD_ASIS,\n\t\t\t\t\t       fwnode_get_name(node));\n\tif (IS_ERR(led->cmd))\n\t\treturn PTR_ERR(led->cmd);\n\n\tled->slow = devm_fwnode_gpiod_get_index(dev, node, \"slow\", 0,\n\t\t\t\t\t\tGPIOD_ASIS,\n\t\t\t\t\t\tfwnode_get_name(node));\n\tif (IS_ERR(led->slow))\n\t\treturn PTR_ERR(led->slow);\n\n\tret = fwnode_property_count_u32(node, \"modes-map\");\n\tif (ret < 0 || ret % 3) {\n\t\tdev_err(dev, \"Missing or malformed modes-map for %pfw\\n\", node);\n\t\treturn -EINVAL;\n\t}\n\n\tnmodes = ret / 3;\n\tmodval = devm_kcalloc(dev, nmodes, sizeof(*modval), GFP_KERNEL);\n\tif (!modval)\n\t\treturn -ENOMEM;\n\n\tfwnode_property_read_u32_array(node, \"modes-map\", (void *)modval,\n\t\t\t\t       nmodes * 3);\n\n\trwlock_init(&led->rw_lock);\n\n\tled->cdev.blink_set = NULL;\n\tled->cdev.flags |= LED_CORE_SUSPENDRESUME;\n\tled->cdev.groups = ns2_led_groups;\n\tled->can_sleep = gpiod_cansleep(led->cmd) || gpiod_cansleep(led->slow);\n\tif (led->can_sleep)\n\t\tled->cdev.brightness_set_blocking = ns2_led_set_blocking;\n\telse\n\t\tled->cdev.brightness_set = ns2_led_set;\n\tled->num_modes = nmodes;\n\tled->modval = modval;\n\n\tret = ns2_led_get_mode(led, &mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tled->sata = (mode == NS_V2_LED_SATA) ? 1 : 0;\n\tled->cdev.brightness = (mode == NS_V2_LED_OFF) ? LED_OFF : LED_FULL;\n\n\tinit_data.fwnode = node;\n\n\tret = devm_led_classdev_register_ext(dev, &led->cdev, &init_data);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to register LED for node %pfw\\n\", node);\n\n\treturn ret;\n}\n\nstatic int ns2_led_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fwnode_handle *child;\n\tstruct ns2_led *leds;\n\tint count;\n\tint ret;\n\n\tcount = device_get_child_node_count(dev);\n\tif (!count)\n\t\treturn -ENODEV;\n\n\tleds = devm_kcalloc(dev, count, sizeof(*leds), GFP_KERNEL);\n\tif (!leds)\n\t\treturn -ENOMEM;\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tret = ns2_led_register(dev, child, leds++);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_ns2_leds_match[] = {\n\t{ .compatible = \"lacie,ns2-leds\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_ns2_leds_match);\n\nstatic struct platform_driver ns2_led_driver = {\n\t.probe\t\t= ns2_led_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"leds-ns2\",\n\t\t.of_match_table\t= of_ns2_leds_match,\n\t},\n};\n\nmodule_platform_driver(ns2_led_driver);\n\nMODULE_AUTHOR(\"Simon Guinot <sguinot@lacie.com>\");\nMODULE_DESCRIPTION(\"Network Space v2 LED driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:leds-ns2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}