{
  "module_name": "leds-mt6323.c",
  "hash_id": "1c797b0007690dc1e41254552928550fdd9f392c8adad9a8b7b6486213d6138f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-mt6323.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/mfd/mt6323/registers.h>\n#include <linux/mfd/mt6397/core.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define RG_DRV_32K_CK_PDN\t\tBIT(11)\n#define RG_DRV_32K_CK_PDN_MASK\t\tBIT(11)\n\n \n#define RG_VWLED_1M_CK_PDN\t\tBIT(0)\n#define RG_VWLED_32K_CK_PDN\t\tBIT(12)\n#define RG_VWLED_6M_CK_PDN\t\tBIT(13)\n\n \n#define RG_ISINK_CK_PDN(i)\tBIT(i)\n#define RG_ISINK_CK_PDN_MASK(i)\tBIT(i)\n\n \n#define RG_ISINK_CK_SEL_MASK(i)\t(BIT(10) << (i))\n\n#define ISINK_CON(r, i)\t\t(r + 0x8 * (i))\n\n \n#define ISINK_DIM_DUTY_MASK\t(0x1f << 8)\n#define ISINK_DIM_DUTY(i)\t(((i) << 8) & ISINK_DIM_DUTY_MASK)\n\n \n#define ISINK_DIM_FSEL_MASK\t(0xffff)\n#define ISINK_DIM_FSEL(i)\t((i) & ISINK_DIM_FSEL_MASK)\n\n \n#define ISINK_CH_STEP_SHIFT\t12\n#define ISINK_CH_STEP_MASK\t(0x7 << 12)\n#define ISINK_CH_STEP(i)\t(((i) << 12) & ISINK_CH_STEP_MASK)\n#define ISINK_SFSTR0_TC_MASK\t(0x3 << 1)\n#define ISINK_SFSTR0_TC(i)\t(((i) << 1) & ISINK_SFSTR0_TC_MASK)\n#define ISINK_SFSTR0_EN_MASK\tBIT(0)\n#define ISINK_SFSTR0_EN\t\tBIT(0)\n\n \n#define ISINK_CH_EN_MASK(i)\tBIT(i)\n#define ISINK_CH_EN(i)\t\tBIT(i)\n\n#define MAX_SUPPORTED_LEDS\t\t8\n\nstruct mt6323_leds;\n\n \nstruct mt6323_led {\n\tint\t\t\tid;\n\tstruct mt6323_leds\t*parent;\n\tstruct led_classdev\tcdev;\n\tenum led_brightness\tcurrent_brightness;\n};\n\n \nstruct mt6323_regs {\n\tconst u16 *top_ckpdn;\n\tu8 num_top_ckpdn;\n\tconst u16 *top_ckcon;\n\tu8 num_top_ckcon;\n\tconst u16 *isink_con;\n\tu8 num_isink_con;\n\tu8 isink_max_regs;\n\tu16 isink_en_ctrl;\n\tu16 iwled_en_ctrl;\n};\n\n \nstruct mt6323_hwspec {\n\tu16 max_period;\n\tu8 max_leds;\n\tu8 max_wleds;\n\tu16 max_brightness;\n\tu16 unit_duty;\n};\n\n \nstruct mt6323_data {\n\tconst struct mt6323_regs *regs;\n\tconst struct mt6323_hwspec *spec;\n};\n\n \nstruct mt6323_leds {\n\tstruct device\t\t*dev;\n\tstruct mt6397_chip\t*hw;\n\tconst struct mt6323_data *pdata;\n\t \n\tstruct mutex\t\tlock;\n\tstruct mt6323_led\t*led[MAX_SUPPORTED_LEDS];\n};\n\nstatic int mt6323_led_hw_brightness(struct led_classdev *cdev,\n\t\t\t\t    enum led_brightness brightness)\n{\n\tstruct mt6323_led *led = container_of(cdev, struct mt6323_led, cdev);\n\tstruct mt6323_leds *leds = led->parent;\n\tconst struct mt6323_regs *regs = leds->pdata->regs;\n\tstruct regmap *regmap = leds->hw->regmap;\n\tu32 con2_mask = 0, con2_val = 0;\n\tint ret;\n\n\t \n\tcon2_mask |= ISINK_CH_STEP_MASK |\n\t\t     ISINK_SFSTR0_TC_MASK |\n\t\t     ISINK_SFSTR0_EN_MASK;\n\tcon2_val |=  ISINK_CH_STEP(brightness - 1) |\n\t\t     ISINK_SFSTR0_TC(2) |\n\t\t     ISINK_SFSTR0_EN;\n\n\tret = regmap_update_bits(regmap, ISINK_CON(regs->isink_con[2], led->id),\n\t\t\t\t con2_mask, con2_val);\n\treturn ret;\n}\n\nstatic int mt6323_led_hw_off(struct led_classdev *cdev)\n{\n\tstruct mt6323_led *led = container_of(cdev, struct mt6323_led, cdev);\n\tstruct mt6323_leds *leds = led->parent;\n\tconst struct mt6323_regs *regs = leds->pdata->regs;\n\tstruct regmap *regmap = leds->hw->regmap;\n\tunsigned int status;\n\tint ret;\n\n\tstatus = ISINK_CH_EN(led->id);\n\tret = regmap_update_bits(regmap, regs->isink_en_ctrl,\n\t\t\t\t ISINK_CH_EN_MASK(led->id), ~status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(100, 300);\n\tret = regmap_update_bits(regmap, regs->top_ckpdn[2],\n\t\t\t\t RG_ISINK_CK_PDN_MASK(led->id),\n\t\t\t\t RG_ISINK_CK_PDN(led->id));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic enum led_brightness\nmt6323_get_led_hw_brightness(struct led_classdev *cdev)\n{\n\tstruct mt6323_led *led = container_of(cdev, struct mt6323_led, cdev);\n\tstruct mt6323_leds *leds = led->parent;\n\tconst struct mt6323_regs *regs = leds->pdata->regs;\n\tstruct regmap *regmap = leds->hw->regmap;\n\tunsigned int status;\n\tint ret;\n\n\tret = regmap_read(regmap, regs->top_ckpdn[2], &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (status & RG_ISINK_CK_PDN_MASK(led->id))\n\t\treturn 0;\n\n\tret = regmap_read(regmap, regs->isink_en_ctrl, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(status & ISINK_CH_EN(led->id)))\n\t\treturn 0;\n\n\tret = regmap_read(regmap, ISINK_CON(regs->isink_con[2], led->id), &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn  ((status & ISINK_CH_STEP_MASK)\n\t\t  >> ISINK_CH_STEP_SHIFT) + 1;\n}\n\nstatic int mt6323_led_hw_on(struct led_classdev *cdev,\n\t\t\t    enum led_brightness brightness)\n{\n\tstruct mt6323_led *led = container_of(cdev, struct mt6323_led, cdev);\n\tstruct mt6323_leds *leds = led->parent;\n\tconst struct mt6323_regs *regs = leds->pdata->regs;\n\tstruct regmap *regmap = leds->hw->regmap;\n\tunsigned int status;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(regmap, regs->top_ckcon[1],\n\t\t\t\t RG_ISINK_CK_SEL_MASK(led->id), 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstatus = RG_ISINK_CK_PDN(led->id);\n\tret = regmap_update_bits(regmap, regs->top_ckpdn[2],\n\t\t\t\t RG_ISINK_CK_PDN_MASK(led->id),\n\t\t\t\t ~status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(100, 300);\n\n\tret = regmap_update_bits(regmap, regs->isink_en_ctrl,\n\t\t\t\t ISINK_CH_EN_MASK(led->id),\n\t\t\t\t ISINK_CH_EN(led->id));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt6323_led_hw_brightness(cdev, brightness);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, ISINK_CON(regs->isink_con[0], led->id),\n\t\t\t\t ISINK_DIM_DUTY_MASK,\n\t\t\t\t ISINK_DIM_DUTY(31));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, ISINK_CON(regs->isink_con[1], led->id),\n\t\t\t\t ISINK_DIM_FSEL_MASK,\n\t\t\t\t ISINK_DIM_FSEL(1000));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mt6323_led_set_blink(struct led_classdev *cdev,\n\t\t\t\tunsigned long *delay_on,\n\t\t\t\tunsigned long *delay_off)\n{\n\tstruct mt6323_led *led = container_of(cdev, struct mt6323_led, cdev);\n\tstruct mt6323_leds *leds = led->parent;\n\tconst struct mt6323_regs *regs = leds->pdata->regs;\n\tconst struct mt6323_hwspec *spec = leds->pdata->spec;\n\tstruct regmap *regmap = leds->hw->regmap;\n\tunsigned long period;\n\tu8 duty_hw;\n\tint ret;\n\n\t \n\tif (!*delay_on && !*delay_off) {\n\t\t*delay_on = 500;\n\t\t*delay_off = 500;\n\t}\n\n\t \n\tperiod = *delay_on + *delay_off;\n\n\tif (period > spec->max_period)\n\t\treturn -EINVAL;\n\n\t \n\tduty_hw = DIV_ROUND_CLOSEST(*delay_on * 100000ul, period * spec->unit_duty);\n\n\t \n\tif (!duty_hw)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&leds->lock);\n\t \n\tif (!led->current_brightness) {\n\t\tret = mt6323_led_hw_on(cdev, cdev->max_brightness);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tled->current_brightness = cdev->max_brightness;\n\t}\n\n\tret = regmap_update_bits(regmap, ISINK_CON(regs->isink_con[0], led->id),\n\t\t\t\t ISINK_DIM_DUTY_MASK,\n\t\t\t\t ISINK_DIM_DUTY(duty_hw - 1));\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = regmap_update_bits(regmap, ISINK_CON(regs->isink_con[1], led->id),\n\t\t\t\t ISINK_DIM_FSEL_MASK,\n\t\t\t\t ISINK_DIM_FSEL(period - 1));\nout:\n\tmutex_unlock(&leds->lock);\n\n\treturn ret;\n}\n\nstatic int mt6323_led_set_brightness(struct led_classdev *cdev,\n\t\t\t\t     enum led_brightness brightness)\n{\n\tstruct mt6323_led *led = container_of(cdev, struct mt6323_led, cdev);\n\tstruct mt6323_leds *leds = led->parent;\n\tint ret;\n\n\tmutex_lock(&leds->lock);\n\n\tif (!led->current_brightness && brightness) {\n\t\tret = mt6323_led_hw_on(cdev, brightness);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else if (brightness) {\n\t\tret = mt6323_led_hw_brightness(cdev, brightness);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = mt6323_led_hw_off(cdev);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tled->current_brightness = brightness;\nout:\n\tmutex_unlock(&leds->lock);\n\n\treturn ret;\n}\n\nstatic int mtk_wled_hw_on(struct led_classdev *cdev)\n{\n\tstruct mt6323_led *led = container_of(cdev, struct mt6323_led, cdev);\n\tstruct mt6323_leds *leds = led->parent;\n\tconst struct mt6323_regs *regs = leds->pdata->regs;\n\tstruct regmap *regmap = leds->hw->regmap;\n\tint ret;\n\n\tret = regmap_clear_bits(regmap, regs->top_ckpdn[0], RG_VWLED_32K_CK_PDN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_clear_bits(regmap, regs->top_ckpdn[0], RG_VWLED_6M_CK_PDN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_clear_bits(regmap, regs->top_ckpdn[0], RG_VWLED_1M_CK_PDN);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(5000, 6000);\n\n\t \n\tret = regmap_set_bits(regmap, regs->iwled_en_ctrl, BIT(led->id));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_set_bits(regmap, regs->iwled_en_ctrl, BIT(led->id + 1));\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mtk_wled_hw_off(struct led_classdev *cdev)\n{\n\tstruct mt6323_led *led = container_of(cdev, struct mt6323_led, cdev);\n\tstruct mt6323_leds *leds = led->parent;\n\tconst struct mt6323_regs *regs = leds->pdata->regs;\n\tstruct regmap *regmap = leds->hw->regmap;\n\tint ret;\n\n\tret = regmap_clear_bits(regmap, regs->iwled_en_ctrl, BIT(led->id + 1));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_clear_bits(regmap, regs->iwled_en_ctrl, BIT(led->id));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_set_bits(regmap, regs->top_ckpdn[0], RG_VWLED_32K_CK_PDN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_set_bits(regmap, regs->top_ckpdn[0], RG_VWLED_6M_CK_PDN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_set_bits(regmap, regs->top_ckpdn[0], RG_VWLED_1M_CK_PDN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic enum led_brightness mt6323_get_wled_brightness(struct led_classdev *cdev)\n{\n\tstruct mt6323_led *led = container_of(cdev, struct mt6323_led, cdev);\n\tstruct mt6323_leds *leds = led->parent;\n\tconst struct mt6323_regs *regs = leds->pdata->regs;\n\tstruct regmap *regmap = leds->hw->regmap;\n\tunsigned int status;\n\tint ret;\n\n\tret = regmap_read(regmap, regs->iwled_en_ctrl, &status);\n\tif (ret)\n\t\treturn 0;\n\n\t \n\tstatus &= BIT(led->id) | BIT(led->id + 1);\n\n\treturn status ? led->current_brightness : 0;\n}\n\nstatic int mt6323_wled_set_brightness(struct led_classdev *cdev,\n\t\t\t\t      enum led_brightness brightness)\n{\n\tstruct mt6323_led *led = container_of(cdev, struct mt6323_led, cdev);\n\tstruct mt6323_leds *leds = led->parent;\n\tint ret = 0;\n\n\tmutex_lock(&leds->lock);\n\n\tif (brightness) {\n\t\tif (!led->current_brightness)\n\t\t\tret = mtk_wled_hw_on(cdev);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tret = mtk_wled_hw_off(cdev);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tled->current_brightness = brightness;\nout:\n\tmutex_unlock(&leds->lock);\n\n\treturn ret;\n}\n\nstatic int mt6323_led_set_dt_default(struct led_classdev *cdev,\n\t\t\t\t     struct device_node *np)\n{\n\tstruct mt6323_led *led = container_of(cdev, struct mt6323_led, cdev);\n\tenum led_default_state state;\n\tint ret = 0;\n\n\tstate = led_init_default_state_get(of_fwnode_handle(np));\n\tswitch (state) {\n\tcase LEDS_DEFSTATE_ON:\n\t\tret = mt6323_led_set_brightness(cdev, cdev->max_brightness);\n\t\tbreak;\n\tcase LEDS_DEFSTATE_KEEP:\n\t\tret = mt6323_get_led_hw_brightness(cdev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tled->current_brightness = ret;\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = mt6323_led_set_brightness(cdev, LED_OFF);\n\t}\n\n\treturn ret;\n}\n\nstatic int mt6323_led_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev_of_node(dev);\n\tstruct device_node *child;\n\tstruct mt6397_chip *hw = dev_get_drvdata(dev->parent);\n\tstruct mt6323_leds *leds;\n\tstruct mt6323_led *led;\n\tconst struct mt6323_regs *regs;\n\tconst struct mt6323_hwspec *spec;\n\tint ret;\n\tunsigned int status;\n\tu32 reg;\n\tu8 max_leds;\n\n\tleds = devm_kzalloc(dev, sizeof(*leds), GFP_KERNEL);\n\tif (!leds)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, leds);\n\tleds->dev = dev;\n\tleds->pdata = device_get_match_data(dev);\n\tregs = leds->pdata->regs;\n\tspec = leds->pdata->spec;\n\tmax_leds = spec->max_leds + spec->max_wleds;\n\n\t \n\tleds->hw = hw;\n\tmutex_init(&leds->lock);\n\n\tstatus = RG_DRV_32K_CK_PDN;\n\tret = regmap_update_bits(leds->hw->regmap, regs->top_ckpdn[0],\n\t\t\t\t RG_DRV_32K_CK_PDN_MASK, ~status);\n\tif (ret < 0) {\n\t\tdev_err(leds->dev,\n\t\t\t\"Failed to update TOP_CKPDN0 Register\\n\");\n\t\treturn ret;\n\t}\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tstruct led_init_data init_data = {};\n\t\tbool is_wled;\n\n\t\tret = of_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to read led 'reg' property\\n\");\n\t\t\tgoto put_child_node;\n\t\t}\n\n\t\tif (reg >= max_leds || reg >= MAX_SUPPORTED_LEDS ||\n\t\t    leds->led[reg]) {\n\t\t\tdev_err(dev, \"Invalid led reg %u\\n\", reg);\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_child_node;\n\t\t}\n\n\t\tled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\n\t\tif (!led) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto put_child_node;\n\t\t}\n\n\t\tis_wled = of_property_read_bool(child, \"mediatek,is-wled\");\n\n\t\tleds->led[reg] = led;\n\t\tleds->led[reg]->id = reg;\n\t\tleds->led[reg]->cdev.max_brightness = spec->max_brightness;\n\n\t\tif (is_wled) {\n\t\t\tleds->led[reg]->cdev.brightness_set_blocking =\n\t\t\t\t\t\tmt6323_wled_set_brightness;\n\t\t\tleds->led[reg]->cdev.brightness_get =\n\t\t\t\t\t\tmt6323_get_wled_brightness;\n\t\t} else {\n\t\t\tleds->led[reg]->cdev.brightness_set_blocking =\n\t\t\t\t\t\tmt6323_led_set_brightness;\n\t\t\tleds->led[reg]->cdev.blink_set = mt6323_led_set_blink;\n\t\t\tleds->led[reg]->cdev.brightness_get =\n\t\t\t\t\t\tmt6323_get_led_hw_brightness;\n\t\t}\n\t\tleds->led[reg]->parent = leds;\n\n\t\tret = mt6323_led_set_dt_default(&leds->led[reg]->cdev, child);\n\t\tif (ret < 0) {\n\t\t\tdev_err(leds->dev,\n\t\t\t\t\"Failed to LED set default from devicetree\\n\");\n\t\t\tgoto put_child_node;\n\t\t}\n\n\t\tinit_data.fwnode = of_fwnode_handle(child);\n\n\t\tret = devm_led_classdev_register_ext(dev, &leds->led[reg]->cdev,\n\t\t\t\t\t\t     &init_data);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register LED: %d\\n\", ret);\n\t\t\tgoto put_child_node;\n\t\t}\n\t}\n\n\treturn 0;\n\nput_child_node:\n\tof_node_put(child);\n\treturn ret;\n}\n\nstatic int mt6323_led_remove(struct platform_device *pdev)\n{\n\tstruct mt6323_leds *leds = platform_get_drvdata(pdev);\n\tconst struct mt6323_regs *regs = leds->pdata->regs;\n\tint i;\n\n\t \n\tfor (i = 0 ; leds->led[i] ; i++)\n\t\tmt6323_led_hw_off(&leds->led[i]->cdev);\n\n\tregmap_update_bits(leds->hw->regmap, regs->top_ckpdn[0],\n\t\t\t   RG_DRV_32K_CK_PDN_MASK,\n\t\t\t   RG_DRV_32K_CK_PDN);\n\n\tmutex_destroy(&leds->lock);\n\n\treturn 0;\n}\n\nstatic const struct mt6323_regs mt6323_registers = {\n\t.top_ckpdn = (const u16[]){ 0x102, 0x106, 0x10e },\n\t.num_top_ckpdn = 3,\n\t.top_ckcon = (const u16[]){ 0x120, 0x126 },\n\t.num_top_ckcon = 2,\n\t.isink_con = (const u16[]){ 0x330, 0x332, 0x334 },\n\t.num_isink_con = 3,\n\t.isink_max_regs = 4,  \n\t.isink_en_ctrl = 0x356,\n};\n\nstatic const struct mt6323_regs mt6331_registers = {\n\t.top_ckpdn = (const u16[]){ 0x138, 0x13e, 0x144 },\n\t.num_top_ckpdn = 3,\n\t.top_ckcon = (const u16[]){ 0x14c, 0x14a },\n\t.num_top_ckcon = 2,\n\t.isink_con = (const u16[]){ 0x40c, 0x40e, 0x410, 0x412, 0x414 },\n\t.num_isink_con = 5,\n\t.isink_max_regs = 4,  \n\t.isink_en_ctrl = 0x43a,\n};\n\nstatic const struct mt6323_regs mt6332_registers = {\n\t.top_ckpdn = (const u16[]){ 0x8094, 0x809a, 0x80a0 },\n\t.num_top_ckpdn = 3,\n\t.top_ckcon = (const u16[]){ 0x80a6, 0x80ac },\n\t.num_top_ckcon = 2,\n\t.isink_con = (const u16[]){ 0x8cd4 },\n\t.num_isink_con = 1,\n\t.isink_max_regs = 12,  \n\t.iwled_en_ctrl = 0x8cda,\n};\n\nstatic const struct mt6323_hwspec mt6323_spec = {\n\t.max_period = 10000,\n\t.max_leds = 4,\n\t.max_brightness = 6,\n\t.unit_duty = 3125,\n};\n\nstatic const struct mt6323_hwspec mt6332_spec = {\n\t \n\t.max_leds = 0,\n\t.max_wleds = 1,\n\t.max_brightness = 1024,\n};\n\nstatic const struct mt6323_data mt6323_pdata = {\n\t.regs = &mt6323_registers,\n\t.spec = &mt6323_spec,\n};\n\nstatic const struct mt6323_data mt6331_pdata = {\n\t.regs = &mt6331_registers,\n\t.spec = &mt6323_spec,\n};\n\nstatic const struct mt6323_data mt6332_pdata = {\n\t.regs = &mt6332_registers,\n\t.spec = &mt6332_spec,\n};\n\nstatic const struct of_device_id mt6323_led_dt_match[] = {\n\t{ .compatible = \"mediatek,mt6323-led\", .data = &mt6323_pdata},\n\t{ .compatible = \"mediatek,mt6331-led\", .data = &mt6331_pdata },\n\t{ .compatible = \"mediatek,mt6332-led\", .data = &mt6332_pdata },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mt6323_led_dt_match);\n\nstatic struct platform_driver mt6323_led_driver = {\n\t.probe\t\t= mt6323_led_probe,\n\t.remove\t\t= mt6323_led_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"mt6323-led\",\n\t\t.of_match_table = mt6323_led_dt_match,\n\t},\n};\n\nmodule_platform_driver(mt6323_led_driver);\n\nMODULE_DESCRIPTION(\"LED driver for Mediatek MT6323 PMIC\");\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}