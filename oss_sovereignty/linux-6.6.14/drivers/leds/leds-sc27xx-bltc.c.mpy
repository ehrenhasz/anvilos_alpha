{
  "module_name": "leds-sc27xx-bltc.c",
  "hash_id": "31bcdde37cbb49e9f37743d3eeafde507da228aed42a105ac43c9b809b998a3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-sc27xx-bltc.c",
  "human_readable_source": "\n\n\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define SC27XX_MODULE_EN0\t0xc08\n#define SC27XX_CLK_EN0\t\t0xc18\n#define SC27XX_RGB_CTRL\t\t0xebc\n\n#define SC27XX_BLTC_EN\t\tBIT(9)\n#define SC27XX_RTC_EN\t\tBIT(7)\n#define SC27XX_RGB_PD\t\tBIT(0)\n\n \n#define SC27XX_LEDS_CTRL\t0x00\n#define SC27XX_LEDS_PRESCALE\t0x04\n#define SC27XX_LEDS_DUTY\t0x08\n#define SC27XX_LEDS_CURVE0\t0x0c\n#define SC27XX_LEDS_CURVE1\t0x10\n\n#define SC27XX_CTRL_SHIFT\t4\n#define SC27XX_LED_RUN\t\tBIT(0)\n#define SC27XX_LED_TYPE\t\tBIT(1)\n\n#define SC27XX_DUTY_SHIFT\t8\n#define SC27XX_DUTY_MASK\tGENMASK(15, 0)\n#define SC27XX_MOD_MASK\t\tGENMASK(7, 0)\n\n#define SC27XX_CURVE_SHIFT\t8\n#define SC27XX_CURVE_L_MASK\tGENMASK(7, 0)\n#define SC27XX_CURVE_H_MASK\tGENMASK(15, 8)\n\n#define SC27XX_LEDS_OFFSET\t0x10\n#define SC27XX_LEDS_MAX\t\t3\n#define SC27XX_LEDS_PATTERN_CNT\t4\n \n#define SC27XX_LEDS_STEP\t125\n \n#define SC27XX_DELTA_T_MIN\tSC27XX_LEDS_STEP\n#define SC27XX_DELTA_T_MAX\t(SC27XX_LEDS_STEP * 255)\n\nstruct sc27xx_led {\n\tstruct fwnode_handle *fwnode;\n\tstruct led_classdev ldev;\n\tstruct sc27xx_led_priv *priv;\n\tu8 line;\n\tbool active;\n};\n\nstruct sc27xx_led_priv {\n\tstruct sc27xx_led leds[SC27XX_LEDS_MAX];\n\tstruct regmap *regmap;\n\tstruct mutex lock;\n\tu32 base;\n};\n\n#define to_sc27xx_led(ldev) \\\n\tcontainer_of(ldev, struct sc27xx_led, ldev)\n\nstatic int sc27xx_led_init(struct regmap *regmap)\n{\n\tint err;\n\n\terr = regmap_update_bits(regmap, SC27XX_MODULE_EN0, SC27XX_BLTC_EN,\n\t\t\t\t SC27XX_BLTC_EN);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_update_bits(regmap, SC27XX_CLK_EN0, SC27XX_RTC_EN,\n\t\t\t\t SC27XX_RTC_EN);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_update_bits(regmap, SC27XX_RGB_CTRL, SC27XX_RGB_PD, 0);\n}\n\nstatic u32 sc27xx_led_get_offset(struct sc27xx_led *leds)\n{\n\treturn leds->priv->base + SC27XX_LEDS_OFFSET * leds->line;\n}\n\nstatic int sc27xx_led_enable(struct sc27xx_led *leds, enum led_brightness value)\n{\n\tu32 base = sc27xx_led_get_offset(leds);\n\tu32 ctrl_base = leds->priv->base + SC27XX_LEDS_CTRL;\n\tu8 ctrl_shift = SC27XX_CTRL_SHIFT * leds->line;\n\tstruct regmap *regmap = leds->priv->regmap;\n\tint err;\n\n\terr = regmap_update_bits(regmap, base + SC27XX_LEDS_DUTY,\n\t\t\t\t SC27XX_DUTY_MASK,\n\t\t\t\t (value << SC27XX_DUTY_SHIFT) |\n\t\t\t\t SC27XX_MOD_MASK);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_update_bits(regmap, ctrl_base,\n\t\t\t(SC27XX_LED_RUN | SC27XX_LED_TYPE) << ctrl_shift,\n\t\t\t(SC27XX_LED_RUN | SC27XX_LED_TYPE) << ctrl_shift);\n}\n\nstatic int sc27xx_led_disable(struct sc27xx_led *leds)\n{\n\tstruct regmap *regmap = leds->priv->regmap;\n\tu32 ctrl_base = leds->priv->base + SC27XX_LEDS_CTRL;\n\tu8 ctrl_shift = SC27XX_CTRL_SHIFT * leds->line;\n\n\treturn regmap_update_bits(regmap, ctrl_base,\n\t\t\t(SC27XX_LED_RUN | SC27XX_LED_TYPE) << ctrl_shift, 0);\n}\n\nstatic int sc27xx_led_set(struct led_classdev *ldev, enum led_brightness value)\n{\n\tstruct sc27xx_led *leds = to_sc27xx_led(ldev);\n\tint err;\n\n\tmutex_lock(&leds->priv->lock);\n\n\tif (value == LED_OFF)\n\t\terr = sc27xx_led_disable(leds);\n\telse\n\t\terr = sc27xx_led_enable(leds, value);\n\n\tmutex_unlock(&leds->priv->lock);\n\n\treturn err;\n}\n\nstatic void sc27xx_led_clamp_align_delta_t(u32 *delta_t)\n{\n\tu32 v, offset, t = *delta_t;\n\n\tv = t + SC27XX_LEDS_STEP / 2;\n\tv = clamp_t(u32, v, SC27XX_DELTA_T_MIN, SC27XX_DELTA_T_MAX);\n\toffset = v - SC27XX_DELTA_T_MIN;\n\toffset = SC27XX_LEDS_STEP * (offset / SC27XX_LEDS_STEP);\n\n\t*delta_t = SC27XX_DELTA_T_MIN + offset;\n}\n\nstatic int sc27xx_led_pattern_clear(struct led_classdev *ldev)\n{\n\tstruct sc27xx_led *leds = to_sc27xx_led(ldev);\n\tstruct regmap *regmap = leds->priv->regmap;\n\tu32 base = sc27xx_led_get_offset(leds);\n\tu32 ctrl_base = leds->priv->base + SC27XX_LEDS_CTRL;\n\tu8 ctrl_shift = SC27XX_CTRL_SHIFT * leds->line;\n\tint err;\n\n\tmutex_lock(&leds->priv->lock);\n\n\t \n\tregmap_write(regmap, base + SC27XX_LEDS_CURVE0, 0);\n\tregmap_write(regmap, base + SC27XX_LEDS_CURVE1, 0);\n\n\terr = regmap_update_bits(regmap, ctrl_base,\n\t\t\t(SC27XX_LED_RUN | SC27XX_LED_TYPE) << ctrl_shift, 0);\n\n\tldev->brightness = LED_OFF;\n\n\tmutex_unlock(&leds->priv->lock);\n\n\treturn err;\n}\n\nstatic int sc27xx_led_pattern_set(struct led_classdev *ldev,\n\t\t\t\t  struct led_pattern *pattern,\n\t\t\t\t  u32 len, int repeat)\n{\n\tstruct sc27xx_led *leds = to_sc27xx_led(ldev);\n\tu32 base = sc27xx_led_get_offset(leds);\n\tu32 ctrl_base = leds->priv->base + SC27XX_LEDS_CTRL;\n\tu8 ctrl_shift = SC27XX_CTRL_SHIFT * leds->line;\n\tstruct regmap *regmap = leds->priv->regmap;\n\tint err;\n\n\t \n\tif (len != SC27XX_LEDS_PATTERN_CNT)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&leds->priv->lock);\n\n\tsc27xx_led_clamp_align_delta_t(&pattern[0].delta_t);\n\terr = regmap_update_bits(regmap, base + SC27XX_LEDS_CURVE0,\n\t\t\t\t SC27XX_CURVE_L_MASK,\n\t\t\t\t pattern[0].delta_t / SC27XX_LEDS_STEP);\n\tif (err)\n\t\tgoto out;\n\n\tsc27xx_led_clamp_align_delta_t(&pattern[1].delta_t);\n\terr = regmap_update_bits(regmap, base + SC27XX_LEDS_CURVE1,\n\t\t\t\t SC27XX_CURVE_L_MASK,\n\t\t\t\t pattern[1].delta_t / SC27XX_LEDS_STEP);\n\tif (err)\n\t\tgoto out;\n\n\tsc27xx_led_clamp_align_delta_t(&pattern[2].delta_t);\n\terr = regmap_update_bits(regmap, base + SC27XX_LEDS_CURVE0,\n\t\t\t\t SC27XX_CURVE_H_MASK,\n\t\t\t\t (pattern[2].delta_t / SC27XX_LEDS_STEP) <<\n\t\t\t\t SC27XX_CURVE_SHIFT);\n\tif (err)\n\t\tgoto out;\n\n\tsc27xx_led_clamp_align_delta_t(&pattern[3].delta_t);\n\terr = regmap_update_bits(regmap, base + SC27XX_LEDS_CURVE1,\n\t\t\t\t SC27XX_CURVE_H_MASK,\n\t\t\t\t (pattern[3].delta_t / SC27XX_LEDS_STEP) <<\n\t\t\t\t SC27XX_CURVE_SHIFT);\n\tif (err)\n\t\tgoto out;\n\n\terr = regmap_update_bits(regmap, base + SC27XX_LEDS_DUTY,\n\t\t\t\t SC27XX_DUTY_MASK,\n\t\t\t\t (pattern[1].brightness << SC27XX_DUTY_SHIFT) |\n\t\t\t\t SC27XX_MOD_MASK);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = regmap_update_bits(regmap, ctrl_base,\n\t\t\t\t SC27XX_LED_RUN << ctrl_shift,\n\t\t\t\t SC27XX_LED_RUN << ctrl_shift);\n\tif (!err)\n\t\tldev->brightness = pattern[1].brightness;\n\nout:\n\tmutex_unlock(&leds->priv->lock);\n\n\treturn err;\n}\n\nstatic int sc27xx_led_register(struct device *dev, struct sc27xx_led_priv *priv)\n{\n\tint i, err;\n\n\terr = sc27xx_led_init(priv->regmap);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < SC27XX_LEDS_MAX; i++) {\n\t\tstruct sc27xx_led *led = &priv->leds[i];\n\t\tstruct led_init_data init_data = {};\n\n\t\tif (!led->active)\n\t\t\tcontinue;\n\n\t\tled->line = i;\n\t\tled->priv = priv;\n\t\tled->ldev.brightness_set_blocking = sc27xx_led_set;\n\t\tled->ldev.pattern_set = sc27xx_led_pattern_set;\n\t\tled->ldev.pattern_clear = sc27xx_led_pattern_clear;\n\t\tled->ldev.default_trigger = \"pattern\";\n\n\t\tinit_data.fwnode = led->fwnode;\n\t\tinit_data.devicename = \"sc27xx\";\n\t\tinit_data.default_label = \":\";\n\n\t\terr = devm_led_classdev_register_ext(dev, &led->ldev,\n\t\t\t\t\t\t     &init_data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int sc27xx_led_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev_of_node(dev), *child;\n\tstruct sc27xx_led_priv *priv;\n\tu32 base, count, reg;\n\tint err;\n\n\tcount = of_get_available_child_count(np);\n\tif (!count || count > SC27XX_LEDS_MAX)\n\t\treturn -EINVAL;\n\n\terr = of_property_read_u32(np, \"reg\", &base);\n\tif (err) {\n\t\tdev_err(dev, \"fail to get reg of property\\n\");\n\t\treturn err;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\tmutex_init(&priv->lock);\n\tpriv->base = base;\n\tpriv->regmap = dev_get_regmap(dev->parent, NULL);\n\tif (!priv->regmap) {\n\t\terr = -ENODEV;\n\t\tdev_err(dev, \"failed to get regmap: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tfor_each_available_child_of_node(np, child) {\n\t\terr = of_property_read_u32(child, \"reg\", &reg);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\tmutex_destroy(&priv->lock);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (reg >= SC27XX_LEDS_MAX || priv->leds[reg].active) {\n\t\t\tof_node_put(child);\n\t\t\tmutex_destroy(&priv->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpriv->leds[reg].fwnode = of_fwnode_handle(child);\n\t\tpriv->leds[reg].active = true;\n\t}\n\n\terr = sc27xx_led_register(dev, priv);\n\tif (err)\n\t\tmutex_destroy(&priv->lock);\n\n\treturn err;\n}\n\nstatic int sc27xx_led_remove(struct platform_device *pdev)\n{\n\tstruct sc27xx_led_priv *priv = platform_get_drvdata(pdev);\n\n\tmutex_destroy(&priv->lock);\n\treturn 0;\n}\n\nstatic const struct of_device_id sc27xx_led_of_match[] = {\n\t{ .compatible = \"sprd,sc2731-bltc\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sc27xx_led_of_match);\n\nstatic struct platform_driver sc27xx_led_driver = {\n\t.driver = {\n\t\t.name = \"sprd-bltc\",\n\t\t.of_match_table = sc27xx_led_of_match,\n\t},\n\t.probe = sc27xx_led_probe,\n\t.remove = sc27xx_led_remove,\n};\n\nmodule_platform_driver(sc27xx_led_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum SC27xx breathing light controller driver\");\nMODULE_AUTHOR(\"Xiaotong Lu <xiaotong.lu@spreadtrum.com>\");\nMODULE_AUTHOR(\"Baolin Wang <baolin.wang@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}