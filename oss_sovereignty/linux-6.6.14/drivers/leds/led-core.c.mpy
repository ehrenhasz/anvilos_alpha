{
  "module_name": "led-core.c",
  "hash_id": "6b562aed0c19b31699b1e9d2c598321ad665695da9d85055875a0d3c4cfd977a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/led-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <uapi/linux/uleds.h>\n#include \"leds.h\"\n\nDECLARE_RWSEM(leds_list_lock);\nEXPORT_SYMBOL_GPL(leds_list_lock);\n\nLIST_HEAD(leds_list);\nEXPORT_SYMBOL_GPL(leds_list);\n\nconst char * const led_colors[LED_COLOR_ID_MAX] = {\n\t[LED_COLOR_ID_WHITE] = \"white\",\n\t[LED_COLOR_ID_RED] = \"red\",\n\t[LED_COLOR_ID_GREEN] = \"green\",\n\t[LED_COLOR_ID_BLUE] = \"blue\",\n\t[LED_COLOR_ID_AMBER] = \"amber\",\n\t[LED_COLOR_ID_VIOLET] = \"violet\",\n\t[LED_COLOR_ID_YELLOW] = \"yellow\",\n\t[LED_COLOR_ID_IR] = \"ir\",\n\t[LED_COLOR_ID_MULTI] = \"multicolor\",\n\t[LED_COLOR_ID_RGB] = \"rgb\",\n};\nEXPORT_SYMBOL_GPL(led_colors);\n\nstatic int __led_set_brightness(struct led_classdev *led_cdev, unsigned int value)\n{\n\tif (!led_cdev->brightness_set)\n\t\treturn -ENOTSUPP;\n\n\tled_cdev->brightness_set(led_cdev, value);\n\n\treturn 0;\n}\n\nstatic int __led_set_brightness_blocking(struct led_classdev *led_cdev, unsigned int value)\n{\n\tif (!led_cdev->brightness_set_blocking)\n\t\treturn -ENOTSUPP;\n\n\treturn led_cdev->brightness_set_blocking(led_cdev, value);\n}\n\nstatic void led_timer_function(struct timer_list *t)\n{\n\tstruct led_classdev *led_cdev = from_timer(led_cdev, t, blink_timer);\n\tunsigned long brightness;\n\tunsigned long delay;\n\n\tif (!led_cdev->blink_delay_on || !led_cdev->blink_delay_off) {\n\t\tled_set_brightness_nosleep(led_cdev, LED_OFF);\n\t\tclear_bit(LED_BLINK_SW, &led_cdev->work_flags);\n\t\treturn;\n\t}\n\n\tif (test_and_clear_bit(LED_BLINK_ONESHOT_STOP,\n\t\t\t       &led_cdev->work_flags)) {\n\t\tclear_bit(LED_BLINK_SW, &led_cdev->work_flags);\n\t\treturn;\n\t}\n\n\tbrightness = led_get_brightness(led_cdev);\n\tif (!brightness) {\n\t\t \n\t\tif (test_and_clear_bit(LED_BLINK_BRIGHTNESS_CHANGE,\n\t\t\t\t\t&led_cdev->work_flags))\n\t\t\tbrightness = led_cdev->new_blink_brightness;\n\t\telse\n\t\t\tbrightness = led_cdev->blink_brightness;\n\t\tdelay = led_cdev->blink_delay_on;\n\t} else {\n\t\t \n\t\tled_cdev->blink_brightness = brightness;\n\t\tbrightness = LED_OFF;\n\t\tdelay = led_cdev->blink_delay_off;\n\t}\n\n\tled_set_brightness_nosleep(led_cdev, brightness);\n\n\t \n\tif (test_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags)) {\n\t\tif (test_bit(LED_BLINK_INVERT, &led_cdev->work_flags)) {\n\t\t\tif (brightness)\n\t\t\t\tset_bit(LED_BLINK_ONESHOT_STOP,\n\t\t\t\t\t&led_cdev->work_flags);\n\t\t} else {\n\t\t\tif (!brightness)\n\t\t\t\tset_bit(LED_BLINK_ONESHOT_STOP,\n\t\t\t\t\t&led_cdev->work_flags);\n\t\t}\n\t}\n\n\tmod_timer(&led_cdev->blink_timer, jiffies + msecs_to_jiffies(delay));\n}\n\nstatic void set_brightness_delayed_set_brightness(struct led_classdev *led_cdev,\n\t\t\t\t\t\t  unsigned int value)\n{\n\tint ret = 0;\n\n\tret = __led_set_brightness(led_cdev, value);\n\tif (ret == -ENOTSUPP)\n\t\tret = __led_set_brightness_blocking(led_cdev, value);\n\tif (ret < 0 &&\n\t     \n\t    !(ret == -ENODEV && (led_cdev->flags & LED_UNREGISTERING) &&\n\t    (led_cdev->flags & LED_HW_PLUGGABLE)))\n\t\tdev_err(led_cdev->dev,\n\t\t\t\"Setting an LED's brightness failed (%d)\\n\", ret);\n}\n\nstatic void set_brightness_delayed(struct work_struct *ws)\n{\n\tstruct led_classdev *led_cdev =\n\t\tcontainer_of(ws, struct led_classdev, set_brightness_work);\n\n\tif (test_and_clear_bit(LED_BLINK_DISABLE, &led_cdev->work_flags)) {\n\t\tled_stop_software_blink(led_cdev);\n\t\tset_bit(LED_SET_BRIGHTNESS_OFF, &led_cdev->work_flags);\n\t}\n\n\t \n\tif (test_and_clear_bit(LED_SET_BRIGHTNESS_OFF, &led_cdev->work_flags))\n\t\tset_brightness_delayed_set_brightness(led_cdev, LED_OFF);\n\n\tif (test_and_clear_bit(LED_SET_BRIGHTNESS, &led_cdev->work_flags))\n\t\tset_brightness_delayed_set_brightness(led_cdev, led_cdev->delayed_set_value);\n\n\tif (test_and_clear_bit(LED_SET_BLINK, &led_cdev->work_flags)) {\n\t\tunsigned long delay_on = led_cdev->delayed_delay_on;\n\t\tunsigned long delay_off = led_cdev->delayed_delay_off;\n\n\t\tled_blink_set(led_cdev, &delay_on, &delay_off);\n\t}\n}\n\nstatic void led_set_software_blink(struct led_classdev *led_cdev,\n\t\t\t\t   unsigned long delay_on,\n\t\t\t\t   unsigned long delay_off)\n{\n\tint current_brightness;\n\n\tcurrent_brightness = led_get_brightness(led_cdev);\n\tif (current_brightness)\n\t\tled_cdev->blink_brightness = current_brightness;\n\tif (!led_cdev->blink_brightness)\n\t\tled_cdev->blink_brightness = led_cdev->max_brightness;\n\n\tled_cdev->blink_delay_on = delay_on;\n\tled_cdev->blink_delay_off = delay_off;\n\n\t \n\tif (!delay_on) {\n\t\tled_set_brightness_nosleep(led_cdev, LED_OFF);\n\t\treturn;\n\t}\n\n\t \n\tif (!delay_off) {\n\t\tled_set_brightness_nosleep(led_cdev,\n\t\t\t\t\t   led_cdev->blink_brightness);\n\t\treturn;\n\t}\n\n\tset_bit(LED_BLINK_SW, &led_cdev->work_flags);\n\tmod_timer(&led_cdev->blink_timer, jiffies + 1);\n}\n\n\nstatic void led_blink_setup(struct led_classdev *led_cdev,\n\t\t     unsigned long *delay_on,\n\t\t     unsigned long *delay_off)\n{\n\tif (!test_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags) &&\n\t    led_cdev->blink_set &&\n\t    !led_cdev->blink_set(led_cdev, delay_on, delay_off))\n\t\treturn;\n\n\t \n\tif (!*delay_on && !*delay_off)\n\t\t*delay_on = *delay_off = 500;\n\n\tled_set_software_blink(led_cdev, *delay_on, *delay_off);\n}\n\nvoid led_init_core(struct led_classdev *led_cdev)\n{\n\tINIT_WORK(&led_cdev->set_brightness_work, set_brightness_delayed);\n\n\ttimer_setup(&led_cdev->blink_timer, led_timer_function, 0);\n}\nEXPORT_SYMBOL_GPL(led_init_core);\n\nvoid led_blink_set(struct led_classdev *led_cdev,\n\t\t   unsigned long *delay_on,\n\t\t   unsigned long *delay_off)\n{\n\tdel_timer_sync(&led_cdev->blink_timer);\n\n\tclear_bit(LED_BLINK_SW, &led_cdev->work_flags);\n\tclear_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags);\n\tclear_bit(LED_BLINK_ONESHOT_STOP, &led_cdev->work_flags);\n\n\tled_blink_setup(led_cdev, delay_on, delay_off);\n}\nEXPORT_SYMBOL_GPL(led_blink_set);\n\nvoid led_blink_set_oneshot(struct led_classdev *led_cdev,\n\t\t\t   unsigned long *delay_on,\n\t\t\t   unsigned long *delay_off,\n\t\t\t   int invert)\n{\n\tif (test_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags) &&\n\t     timer_pending(&led_cdev->blink_timer))\n\t\treturn;\n\n\tset_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags);\n\tclear_bit(LED_BLINK_ONESHOT_STOP, &led_cdev->work_flags);\n\n\tif (invert)\n\t\tset_bit(LED_BLINK_INVERT, &led_cdev->work_flags);\n\telse\n\t\tclear_bit(LED_BLINK_INVERT, &led_cdev->work_flags);\n\n\tled_blink_setup(led_cdev, delay_on, delay_off);\n}\nEXPORT_SYMBOL_GPL(led_blink_set_oneshot);\n\nvoid led_blink_set_nosleep(struct led_classdev *led_cdev, unsigned long delay_on,\n\t\t\t   unsigned long delay_off)\n{\n\t \n\tif (led_cdev->blink_set && led_cdev->brightness_set_blocking) {\n\t\tled_cdev->delayed_delay_on = delay_on;\n\t\tled_cdev->delayed_delay_off = delay_off;\n\t\tset_bit(LED_SET_BLINK, &led_cdev->work_flags);\n\t\tschedule_work(&led_cdev->set_brightness_work);\n\t\treturn;\n\t}\n\n\tled_blink_set(led_cdev, &delay_on, &delay_off);\n}\nEXPORT_SYMBOL_GPL(led_blink_set_nosleep);\n\nvoid led_stop_software_blink(struct led_classdev *led_cdev)\n{\n\tdel_timer_sync(&led_cdev->blink_timer);\n\tled_cdev->blink_delay_on = 0;\n\tled_cdev->blink_delay_off = 0;\n\tclear_bit(LED_BLINK_SW, &led_cdev->work_flags);\n}\nEXPORT_SYMBOL_GPL(led_stop_software_blink);\n\nvoid led_set_brightness(struct led_classdev *led_cdev, unsigned int brightness)\n{\n\t \n\tif (test_bit(LED_BLINK_SW, &led_cdev->work_flags)) {\n\t\t \n\t\tif (!brightness) {\n\t\t\tset_bit(LED_BLINK_DISABLE, &led_cdev->work_flags);\n\t\t\tschedule_work(&led_cdev->set_brightness_work);\n\t\t} else {\n\t\t\tset_bit(LED_BLINK_BRIGHTNESS_CHANGE,\n\t\t\t\t&led_cdev->work_flags);\n\t\t\tled_cdev->new_blink_brightness = brightness;\n\t\t}\n\t\treturn;\n\t}\n\n\tled_set_brightness_nosleep(led_cdev, brightness);\n}\nEXPORT_SYMBOL_GPL(led_set_brightness);\n\nvoid led_set_brightness_nopm(struct led_classdev *led_cdev, unsigned int value)\n{\n\t \n\tif (!__led_set_brightness(led_cdev, value))\n\t\treturn;\n\n\t \n\tif (value) {\n\t\tled_cdev->delayed_set_value = value;\n\t\tset_bit(LED_SET_BRIGHTNESS, &led_cdev->work_flags);\n\t} else {\n\t\tclear_bit(LED_SET_BRIGHTNESS, &led_cdev->work_flags);\n\t\tclear_bit(LED_SET_BLINK, &led_cdev->work_flags);\n\t\tset_bit(LED_SET_BRIGHTNESS_OFF, &led_cdev->work_flags);\n\t}\n\n\tschedule_work(&led_cdev->set_brightness_work);\n}\nEXPORT_SYMBOL_GPL(led_set_brightness_nopm);\n\nvoid led_set_brightness_nosleep(struct led_classdev *led_cdev, unsigned int value)\n{\n\tled_cdev->brightness = min(value, led_cdev->max_brightness);\n\n\tif (led_cdev->flags & LED_SUSPENDED)\n\t\treturn;\n\n\tled_set_brightness_nopm(led_cdev, led_cdev->brightness);\n}\nEXPORT_SYMBOL_GPL(led_set_brightness_nosleep);\n\nint led_set_brightness_sync(struct led_classdev *led_cdev, unsigned int value)\n{\n\tif (led_cdev->blink_delay_on || led_cdev->blink_delay_off)\n\t\treturn -EBUSY;\n\n\tled_cdev->brightness = min(value, led_cdev->max_brightness);\n\n\tif (led_cdev->flags & LED_SUSPENDED)\n\t\treturn 0;\n\n\treturn __led_set_brightness_blocking(led_cdev, led_cdev->brightness);\n}\nEXPORT_SYMBOL_GPL(led_set_brightness_sync);\n\nint led_update_brightness(struct led_classdev *led_cdev)\n{\n\tint ret = 0;\n\n\tif (led_cdev->brightness_get) {\n\t\tret = led_cdev->brightness_get(led_cdev);\n\t\tif (ret >= 0) {\n\t\t\tled_cdev->brightness = ret;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(led_update_brightness);\n\nu32 *led_get_default_pattern(struct led_classdev *led_cdev, unsigned int *size)\n{\n\tstruct fwnode_handle *fwnode = led_cdev->dev->fwnode;\n\tu32 *pattern;\n\tint count;\n\n\tcount = fwnode_property_count_u32(fwnode, \"led-pattern\");\n\tif (count < 0)\n\t\treturn NULL;\n\n\tpattern = kcalloc(count, sizeof(*pattern), GFP_KERNEL);\n\tif (!pattern)\n\t\treturn NULL;\n\n\tif (fwnode_property_read_u32_array(fwnode, \"led-pattern\", pattern, count)) {\n\t\tkfree(pattern);\n\t\treturn NULL;\n\t}\n\n\t*size = count;\n\n\treturn pattern;\n}\nEXPORT_SYMBOL_GPL(led_get_default_pattern);\n\n \nvoid led_sysfs_disable(struct led_classdev *led_cdev)\n{\n\tlockdep_assert_held(&led_cdev->led_access);\n\n\tled_cdev->flags |= LED_SYSFS_DISABLE;\n}\nEXPORT_SYMBOL_GPL(led_sysfs_disable);\n\n \nvoid led_sysfs_enable(struct led_classdev *led_cdev)\n{\n\tlockdep_assert_held(&led_cdev->led_access);\n\n\tled_cdev->flags &= ~LED_SYSFS_DISABLE;\n}\nEXPORT_SYMBOL_GPL(led_sysfs_enable);\n\nstatic void led_parse_fwnode_props(struct device *dev,\n\t\t\t\t   struct fwnode_handle *fwnode,\n\t\t\t\t   struct led_properties *props)\n{\n\tint ret;\n\n\tif (!fwnode)\n\t\treturn;\n\n\tif (fwnode_property_present(fwnode, \"label\")) {\n\t\tret = fwnode_property_read_string(fwnode, \"label\", &props->label);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Error parsing 'label' property (%d)\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (fwnode_property_present(fwnode, \"color\")) {\n\t\tret = fwnode_property_read_u32(fwnode, \"color\", &props->color);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Error parsing 'color' property (%d)\\n\", ret);\n\t\telse if (props->color >= LED_COLOR_ID_MAX)\n\t\t\tdev_err(dev, \"LED color identifier out of range\\n\");\n\t\telse\n\t\t\tprops->color_present = true;\n\t}\n\n\n\tif (!fwnode_property_present(fwnode, \"function\"))\n\t\treturn;\n\n\tret = fwnode_property_read_string(fwnode, \"function\", &props->function);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Error parsing 'function' property (%d)\\n\",\n\t\t\tret);\n\t}\n\n\tif (!fwnode_property_present(fwnode, \"function-enumerator\"))\n\t\treturn;\n\n\tret = fwnode_property_read_u32(fwnode, \"function-enumerator\",\n\t\t\t\t       &props->func_enum);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Error parsing 'function-enumerator' property (%d)\\n\",\n\t\t\tret);\n\t} else {\n\t\tprops->func_enum_present = true;\n\t}\n}\n\nint led_compose_name(struct device *dev, struct led_init_data *init_data,\n\t\t     char *led_classdev_name)\n{\n\tstruct led_properties props = {};\n\tstruct fwnode_handle *fwnode = init_data->fwnode;\n\tconst char *devicename = init_data->devicename;\n\n\tif (!led_classdev_name)\n\t\treturn -EINVAL;\n\n\tled_parse_fwnode_props(dev, fwnode, &props);\n\n\tif (props.label) {\n\t\t \n\t\tif (!devicename) {\n\t\t\tstrscpy(led_classdev_name, props.label,\n\t\t\t\tLED_MAX_NAME_SIZE);\n\t\t} else {\n\t\t\tsnprintf(led_classdev_name, LED_MAX_NAME_SIZE, \"%s:%s\",\n\t\t\t\t devicename, props.label);\n\t\t}\n\t} else if (props.function || props.color_present) {\n\t\tchar tmp_buf[LED_MAX_NAME_SIZE];\n\n\t\tif (props.func_enum_present) {\n\t\t\tsnprintf(tmp_buf, LED_MAX_NAME_SIZE, \"%s:%s-%d\",\n\t\t\t\t props.color_present ? led_colors[props.color] : \"\",\n\t\t\t\t props.function ?: \"\", props.func_enum);\n\t\t} else {\n\t\t\tsnprintf(tmp_buf, LED_MAX_NAME_SIZE, \"%s:%s\",\n\t\t\t\t props.color_present ? led_colors[props.color] : \"\",\n\t\t\t\t props.function ?: \"\");\n\t\t}\n\t\tif (init_data->devname_mandatory) {\n\t\t\tsnprintf(led_classdev_name, LED_MAX_NAME_SIZE, \"%s:%s\",\n\t\t\t\t devicename, tmp_buf);\n\t\t} else {\n\t\t\tstrscpy(led_classdev_name, tmp_buf, LED_MAX_NAME_SIZE);\n\n\t\t}\n\t} else if (init_data->default_label) {\n\t\tif (!devicename) {\n\t\t\tdev_err(dev, \"Legacy LED naming requires devicename segment\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsnprintf(led_classdev_name, LED_MAX_NAME_SIZE, \"%s:%s\",\n\t\t\t devicename, init_data->default_label);\n\t} else if (is_of_node(fwnode)) {\n\t\tstrscpy(led_classdev_name, to_of_node(fwnode)->name,\n\t\t\tLED_MAX_NAME_SIZE);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(led_compose_name);\n\nenum led_default_state led_init_default_state_get(struct fwnode_handle *fwnode)\n{\n\tconst char *state = NULL;\n\n\tif (!fwnode_property_read_string(fwnode, \"default-state\", &state)) {\n\t\tif (!strcmp(state, \"keep\"))\n\t\t\treturn LEDS_DEFSTATE_KEEP;\n\t\tif (!strcmp(state, \"on\"))\n\t\t\treturn LEDS_DEFSTATE_ON;\n\t}\n\n\treturn LEDS_DEFSTATE_OFF;\n}\nEXPORT_SYMBOL_GPL(led_init_default_state_get);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}