{
  "module_name": "leds-lm3530.c",
  "hash_id": "7556f23cb00be7f16a7bde209b0f9ec09842cb8dd76bbc52de7d420308ff1035",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lm3530.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/led-lm3530.h>\n#include <linux/types.h>\n#include <linux/regulator/consumer.h>\n#include <linux/module.h>\n\n#define LM3530_LED_DEV \"lcd-backlight\"\n#define LM3530_NAME \"lm3530-led\"\n\n#define LM3530_GEN_CONFIG\t\t0x10\n#define LM3530_ALS_CONFIG\t\t0x20\n#define LM3530_BRT_RAMP_RATE\t\t0x30\n#define LM3530_ALS_IMP_SELECT\t\t0x41\n#define LM3530_BRT_CTRL_REG\t\t0xA0\n#define LM3530_ALS_ZB0_REG\t\t0x60\n#define LM3530_ALS_ZB1_REG\t\t0x61\n#define LM3530_ALS_ZB2_REG\t\t0x62\n#define LM3530_ALS_ZB3_REG\t\t0x63\n#define LM3530_ALS_Z0T_REG\t\t0x70\n#define LM3530_ALS_Z1T_REG\t\t0x71\n#define LM3530_ALS_Z2T_REG\t\t0x72\n#define LM3530_ALS_Z3T_REG\t\t0x73\n#define LM3530_ALS_Z4T_REG\t\t0x74\n#define LM3530_REG_MAX\t\t\t14\n\n \n#define LM3530_EN_I2C_SHIFT\t\t(0)\n#define LM3530_RAMP_LAW_SHIFT\t\t(1)\n#define LM3530_MAX_CURR_SHIFT\t\t(2)\n#define LM3530_EN_PWM_SHIFT\t\t(5)\n#define LM3530_PWM_POL_SHIFT\t\t(6)\n#define LM3530_EN_PWM_SIMPLE_SHIFT\t(7)\n\n#define LM3530_ENABLE_I2C\t\t(1 << LM3530_EN_I2C_SHIFT)\n#define LM3530_ENABLE_PWM\t\t(1 << LM3530_EN_PWM_SHIFT)\n#define LM3530_POL_LOW\t\t\t(1 << LM3530_PWM_POL_SHIFT)\n#define LM3530_ENABLE_PWM_SIMPLE\t(1 << LM3530_EN_PWM_SIMPLE_SHIFT)\n\n \n#define LM3530_ALS_AVG_TIME_SHIFT\t(0)\n#define LM3530_EN_ALS_SHIFT\t\t(3)\n#define LM3530_ALS_SEL_SHIFT\t\t(5)\n\n#define LM3530_ENABLE_ALS\t\t(3 << LM3530_EN_ALS_SHIFT)\n\n \n#define LM3530_BRT_RAMP_FALL_SHIFT\t(0)\n#define LM3530_BRT_RAMP_RISE_SHIFT\t(3)\n\n \n#define LM3530_ALS1_IMP_SHIFT\t\t(0)\n#define LM3530_ALS2_IMP_SHIFT\t\t(4)\n\n \n#define LM3530_ALS_ZB_MAX\t\t(4)\n#define LM3530_ALS_WINDOW_mV\t\t(1000)\n#define LM3530_ALS_OFFSET_mV\t\t(4)\n\n \n#define LM3530_DEF_ZT_0\t\t\t(0x7F)\n#define LM3530_DEF_ZT_1\t\t\t(0x66)\n#define LM3530_DEF_ZT_2\t\t\t(0x4C)\n#define LM3530_DEF_ZT_3\t\t\t(0x33)\n#define LM3530_DEF_ZT_4\t\t\t(0x19)\n\n \n#define MAX_BRIGHTNESS\t\t\t(127)\n\nstruct lm3530_mode_map {\n\tconst char *mode;\n\tenum lm3530_mode mode_val;\n};\n\nstatic struct lm3530_mode_map mode_map[] = {\n\t{ \"man\", LM3530_BL_MODE_MANUAL },\n\t{ \"als\", LM3530_BL_MODE_ALS },\n\t{ \"pwm\", LM3530_BL_MODE_PWM },\n};\n\n \nstruct lm3530_data {\n\tstruct led_classdev led_dev;\n\tstruct i2c_client *client;\n\tstruct lm3530_platform_data *pdata;\n\tenum lm3530_mode mode;\n\tstruct regulator *regulator;\n\tenum led_brightness brightness;\n\tbool enable;\n};\n\n \nstruct lm3530_als_data {\n\tu8 config;\n\tu8 imp_sel;\n\tu8 zones[LM3530_ALS_ZB_MAX];\n};\n\nstatic const u8 lm3530_reg[LM3530_REG_MAX] = {\n\tLM3530_GEN_CONFIG,\n\tLM3530_ALS_CONFIG,\n\tLM3530_BRT_RAMP_RATE,\n\tLM3530_ALS_IMP_SELECT,\n\tLM3530_BRT_CTRL_REG,\n\tLM3530_ALS_ZB0_REG,\n\tLM3530_ALS_ZB1_REG,\n\tLM3530_ALS_ZB2_REG,\n\tLM3530_ALS_ZB3_REG,\n\tLM3530_ALS_Z0T_REG,\n\tLM3530_ALS_Z1T_REG,\n\tLM3530_ALS_Z2T_REG,\n\tLM3530_ALS_Z3T_REG,\n\tLM3530_ALS_Z4T_REG,\n};\n\nstatic int lm3530_get_mode_from_str(const char *str)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mode_map); i++)\n\t\tif (sysfs_streq(str, mode_map[i].mode))\n\t\t\treturn mode_map[i].mode_val;\n\n\treturn -EINVAL;\n}\n\nstatic void lm3530_als_configure(struct lm3530_platform_data *pdata,\n\t\t\t\tstruct lm3530_als_data *als)\n{\n\tint i;\n\tu32 als_vmin, als_vmax, als_vstep;\n\n\tif (pdata->als_vmax == 0) {\n\t\tpdata->als_vmin = 0;\n\t\tpdata->als_vmax = LM3530_ALS_WINDOW_mV;\n\t}\n\n\tals_vmin = pdata->als_vmin;\n\tals_vmax = pdata->als_vmax;\n\n\tif ((als_vmax - als_vmin) > LM3530_ALS_WINDOW_mV)\n\t\tpdata->als_vmax = als_vmax = als_vmin + LM3530_ALS_WINDOW_mV;\n\n\t \n\tals_vstep = (als_vmax - als_vmin) / (LM3530_ALS_ZB_MAX + 1);\n\n\tfor (i = 0; i < LM3530_ALS_ZB_MAX; i++)\n\t\tals->zones[i] = (((als_vmin + LM3530_ALS_OFFSET_mV) +\n\t\t\tals_vstep + (i * als_vstep)) * LED_FULL) / 1000;\n\n\tals->config =\n\t\t(pdata->als_avrg_time << LM3530_ALS_AVG_TIME_SHIFT) |\n\t\t(LM3530_ENABLE_ALS) |\n\t\t(pdata->als_input_mode << LM3530_ALS_SEL_SHIFT);\n\n\tals->imp_sel =\n\t\t(pdata->als1_resistor_sel << LM3530_ALS1_IMP_SHIFT) |\n\t\t(pdata->als2_resistor_sel << LM3530_ALS2_IMP_SHIFT);\n}\n\nstatic int lm3530_led_enable(struct lm3530_data *drvdata)\n{\n\tint ret;\n\n\tif (drvdata->enable)\n\t\treturn 0;\n\n\tret = regulator_enable(drvdata->regulator);\n\tif (ret) {\n\t\tdev_err(drvdata->led_dev.dev, \"Failed to enable vin:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrvdata->enable = true;\n\treturn 0;\n}\n\nstatic void lm3530_led_disable(struct lm3530_data *drvdata)\n{\n\tint ret;\n\n\tif (!drvdata->enable)\n\t\treturn;\n\n\tret = regulator_disable(drvdata->regulator);\n\tif (ret) {\n\t\tdev_err(drvdata->led_dev.dev, \"Failed to disable vin:%d\\n\",\n\t\t\tret);\n\t\treturn;\n\t}\n\n\tdrvdata->enable = false;\n}\n\nstatic int lm3530_init_registers(struct lm3530_data *drvdata)\n{\n\tint ret = 0;\n\tint i;\n\tu8 gen_config;\n\tu8 brt_ramp;\n\tu8 brightness;\n\tu8 reg_val[LM3530_REG_MAX];\n\tstruct lm3530_platform_data *pdata = drvdata->pdata;\n\tstruct i2c_client *client = drvdata->client;\n\tstruct lm3530_pwm_data *pwm = &pdata->pwm_data;\n\tstruct lm3530_als_data als;\n\n\tmemset(&als, 0, sizeof(struct lm3530_als_data));\n\n\tgen_config = (pdata->brt_ramp_law << LM3530_RAMP_LAW_SHIFT) |\n\t\t\t((pdata->max_current & 7) << LM3530_MAX_CURR_SHIFT);\n\n\tswitch (drvdata->mode) {\n\tcase LM3530_BL_MODE_MANUAL:\n\t\tgen_config |= LM3530_ENABLE_I2C;\n\t\tbreak;\n\tcase LM3530_BL_MODE_ALS:\n\t\tgen_config |= LM3530_ENABLE_I2C;\n\t\tlm3530_als_configure(pdata, &als);\n\t\tbreak;\n\tcase LM3530_BL_MODE_PWM:\n\t\tgen_config |= LM3530_ENABLE_PWM | LM3530_ENABLE_PWM_SIMPLE |\n\t\t\t      (pdata->pwm_pol_hi << LM3530_PWM_POL_SHIFT);\n\t\tbreak;\n\t}\n\n\tbrt_ramp = (pdata->brt_ramp_fall << LM3530_BRT_RAMP_FALL_SHIFT) |\n\t\t\t(pdata->brt_ramp_rise << LM3530_BRT_RAMP_RISE_SHIFT);\n\n\tif (drvdata->brightness)\n\t\tbrightness = drvdata->brightness;\n\telse\n\t\tbrightness = drvdata->brightness = pdata->brt_val;\n\n\tif (brightness > drvdata->led_dev.max_brightness)\n\t\tbrightness = drvdata->led_dev.max_brightness;\n\n\treg_val[0] = gen_config;\t \n\treg_val[1] = als.config;\t \n\treg_val[2] = brt_ramp;\t\t \n\treg_val[3] = als.imp_sel;\t \n\treg_val[4] = brightness;\t \n\treg_val[5] = als.zones[0];\t \n\treg_val[6] = als.zones[1];\t \n\treg_val[7] = als.zones[2];\t \n\treg_val[8] = als.zones[3];\t \n\treg_val[9] = LM3530_DEF_ZT_0;\t \n\treg_val[10] = LM3530_DEF_ZT_1;\t \n\treg_val[11] = LM3530_DEF_ZT_2;\t \n\treg_val[12] = LM3530_DEF_ZT_3;\t \n\treg_val[13] = LM3530_DEF_ZT_4;\t \n\n\tret = lm3530_led_enable(drvdata);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < LM3530_REG_MAX; i++) {\n\t\t \n\t\tif (lm3530_reg[i] == LM3530_BRT_CTRL_REG &&\n\t\t    drvdata->mode == LM3530_BL_MODE_PWM) {\n\t\t\tif (pwm->pwm_set_intensity)\n\t\t\t\tpwm->pwm_set_intensity(reg_val[i],\n\t\t\t\t\tdrvdata->led_dev.max_brightness);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\tlm3530_reg[i], reg_val[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void lm3530_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t     enum led_brightness brt_val)\n{\n\tint err;\n\tstruct lm3530_data *drvdata =\n\t    container_of(led_cdev, struct lm3530_data, led_dev);\n\tstruct lm3530_platform_data *pdata = drvdata->pdata;\n\tstruct lm3530_pwm_data *pwm = &pdata->pwm_data;\n\tu8 max_brightness = led_cdev->max_brightness;\n\n\tswitch (drvdata->mode) {\n\tcase LM3530_BL_MODE_MANUAL:\n\n\t\tif (!drvdata->enable) {\n\t\t\terr = lm3530_init_registers(drvdata);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&drvdata->client->dev,\n\t\t\t\t\t\"Register Init failed: %d\\n\", err);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\terr = i2c_smbus_write_byte_data(drvdata->client,\n\t\t\t\tLM3530_BRT_CTRL_REG, brt_val);\n\t\tif (err)\n\t\t\tdev_err(&drvdata->client->dev,\n\t\t\t\t\"Unable to set brightness: %d\\n\", err);\n\t\telse\n\t\t\tdrvdata->brightness = brt_val;\n\n\t\tif (brt_val == 0)\n\t\t\tlm3530_led_disable(drvdata);\n\t\tbreak;\n\tcase LM3530_BL_MODE_ALS:\n\t\tbreak;\n\tcase LM3530_BL_MODE_PWM:\n\t\tif (pwm->pwm_set_intensity)\n\t\t\tpwm->pwm_set_intensity(brt_val, max_brightness);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic ssize_t mode_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3530_data *drvdata;\n\tint i, len = 0;\n\n\tdrvdata = container_of(led_cdev, struct lm3530_data, led_dev);\n\tfor (i = 0; i < ARRAY_SIZE(mode_map); i++)\n\t\tif (drvdata->mode == mode_map[i].mode_val)\n\t\t\tlen += sprintf(buf + len, \"[%s] \", mode_map[i].mode);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"%s \", mode_map[i].mode);\n\n\tlen += sprintf(buf + len, \"\\n\");\n\n\treturn len;\n}\n\nstatic ssize_t mode_store(struct device *dev, struct device_attribute\n\t\t\t  *attr, const char *buf, size_t size)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm3530_data *drvdata;\n\tstruct lm3530_pwm_data *pwm;\n\tu8 max_brightness;\n\tint mode, err;\n\n\tdrvdata = container_of(led_cdev, struct lm3530_data, led_dev);\n\tpwm = &drvdata->pdata->pwm_data;\n\tmax_brightness = led_cdev->max_brightness;\n\tmode = lm3530_get_mode_from_str(buf);\n\tif (mode < 0) {\n\t\tdev_err(dev, \"Invalid mode\\n\");\n\t\treturn mode;\n\t}\n\n\tdrvdata->mode = mode;\n\n\t \n\tif (mode != LM3530_BL_MODE_PWM && pwm->pwm_set_intensity)\n\t\tpwm->pwm_set_intensity(0, max_brightness);\n\n\terr = lm3530_init_registers(drvdata);\n\tif (err) {\n\t\tdev_err(dev, \"Setting %s Mode failed :%d\\n\", buf, err);\n\t\treturn err;\n\t}\n\n\treturn sizeof(drvdata->mode);\n}\nstatic DEVICE_ATTR_RW(mode);\n\nstatic struct attribute *lm3530_attrs[] = {\n\t&dev_attr_mode.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(lm3530);\n\nstatic int lm3530_probe(struct i2c_client *client)\n{\n\tstruct lm3530_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct lm3530_data *drvdata;\n\tint err = 0;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&client->dev, \"platform data required\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (pdata->mode > LM3530_BL_MODE_PWM) {\n\t\tdev_err(&client->dev, \"Illegal Mode request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"I2C_FUNC_I2C not supported\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdrvdata = devm_kzalloc(&client->dev, sizeof(struct lm3530_data),\n\t\t\t\tGFP_KERNEL);\n\tif (drvdata == NULL)\n\t\treturn -ENOMEM;\n\n\tdrvdata->mode = pdata->mode;\n\tdrvdata->client = client;\n\tdrvdata->pdata = pdata;\n\tdrvdata->brightness = LED_OFF;\n\tdrvdata->enable = false;\n\tdrvdata->led_dev.name = LM3530_LED_DEV;\n\tdrvdata->led_dev.brightness_set = lm3530_brightness_set;\n\tdrvdata->led_dev.max_brightness = MAX_BRIGHTNESS;\n\tdrvdata->led_dev.groups = lm3530_groups;\n\n\ti2c_set_clientdata(client, drvdata);\n\n\tdrvdata->regulator = devm_regulator_get(&client->dev, \"vin\");\n\tif (IS_ERR(drvdata->regulator)) {\n\t\tdev_err(&client->dev, \"regulator get failed\\n\");\n\t\terr = PTR_ERR(drvdata->regulator);\n\t\tdrvdata->regulator = NULL;\n\t\treturn err;\n\t}\n\n\tif (drvdata->pdata->brt_val) {\n\t\terr = lm3530_init_registers(drvdata);\n\t\tif (err < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Register Init failed: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = led_classdev_register(&client->dev, &drvdata->led_dev);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Register led class failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void lm3530_remove(struct i2c_client *client)\n{\n\tstruct lm3530_data *drvdata = i2c_get_clientdata(client);\n\n\tlm3530_led_disable(drvdata);\n\tled_classdev_unregister(&drvdata->led_dev);\n}\n\nstatic const struct i2c_device_id lm3530_id[] = {\n\t{LM3530_NAME, 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, lm3530_id);\n\nstatic struct i2c_driver lm3530_i2c_driver = {\n\t.probe = lm3530_probe,\n\t.remove = lm3530_remove,\n\t.id_table = lm3530_id,\n\t.driver = {\n\t\t.name = LM3530_NAME,\n\t},\n};\n\nmodule_i2c_driver(lm3530_i2c_driver);\n\nMODULE_DESCRIPTION(\"Back Light driver for LM3530\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Shreshtha Kumar SAHU <shreshthakumar.sahu@stericsson.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}