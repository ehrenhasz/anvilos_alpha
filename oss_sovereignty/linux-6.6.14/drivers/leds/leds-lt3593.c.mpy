{
  "module_name": "leds-lt3593.c",
  "hash_id": "cb681bc5cefd7f4998571e7be289e14576f3e644b5d3dd6b84bb4c8116c8b6b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lt3593.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/leds.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n\n#define LED_LT3593_NAME \"lt3593\"\n\nstruct lt3593_led_data {\n\tstruct led_classdev cdev;\n\tstruct gpio_desc *gpiod;\n};\n\nstatic int lt3593_led_set(struct led_classdev *led_cdev,\n\t\t\t   enum led_brightness value)\n{\n\tstruct lt3593_led_data *led_dat =\n\t\tcontainer_of(led_cdev, struct lt3593_led_data, cdev);\n\tint pulses;\n\n\t \n\n\tif (value == 0) {\n\t\tgpiod_set_value_cansleep(led_dat->gpiod, 0);\n\t\treturn 0;\n\t}\n\n\tpulses = 32 - (value * 32) / 255;\n\n\tif (pulses == 0) {\n\t\tgpiod_set_value_cansleep(led_dat->gpiod, 0);\n\t\tmdelay(1);\n\t\tgpiod_set_value_cansleep(led_dat->gpiod, 1);\n\t\treturn 0;\n\t}\n\n\tgpiod_set_value_cansleep(led_dat->gpiod, 1);\n\n\twhile (pulses--) {\n\t\tgpiod_set_value_cansleep(led_dat->gpiod, 0);\n\t\tudelay(1);\n\t\tgpiod_set_value_cansleep(led_dat->gpiod, 1);\n\t\tudelay(1);\n\t}\n\n\treturn 0;\n}\n\nstatic int lt3593_led_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct lt3593_led_data *led_data;\n\tstruct fwnode_handle *child;\n\tint ret, state = LEDS_GPIO_DEFSTATE_OFF;\n\tstruct led_init_data init_data = {};\n\tconst char *tmp;\n\n\tled_data = devm_kzalloc(dev, sizeof(*led_data), GFP_KERNEL);\n\tif (!led_data)\n\t\treturn -ENOMEM;\n\n\tif (device_get_child_node_count(dev) != 1) {\n\t\tdev_err(dev, \"Device must have exactly one LED sub-node.\");\n\t\treturn -EINVAL;\n\t}\n\n\tled_data->gpiod = devm_gpiod_get(dev, \"lltc,ctrl\", 0);\n\tif (IS_ERR(led_data->gpiod))\n\t\treturn PTR_ERR(led_data->gpiod);\n\n\tchild = device_get_next_child_node(dev, NULL);\n\n\tif (!fwnode_property_read_string(child, \"default-state\", &tmp)) {\n\t\tif (!strcmp(tmp, \"on\"))\n\t\t\tstate = LEDS_GPIO_DEFSTATE_ON;\n\t}\n\n\tled_data->cdev.brightness_set_blocking = lt3593_led_set;\n\tled_data->cdev.brightness = state ? LED_FULL : LED_OFF;\n\n\tinit_data.fwnode = child;\n\tinit_data.devicename = LED_LT3593_NAME;\n\tinit_data.default_label = \":\";\n\n\tret = devm_led_classdev_register_ext(dev, &led_data->cdev, &init_data);\n\tfwnode_handle_put(child);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, led_data);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_lt3593_leds_match[] = {\n\t{ .compatible = \"lltc,lt3593\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_lt3593_leds_match);\n\nstatic struct platform_driver lt3593_led_driver = {\n\t.probe\t\t= lt3593_led_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"leds-lt3593\",\n\t\t.of_match_table = of_lt3593_leds_match,\n\t},\n};\n\nmodule_platform_driver(lt3593_led_driver);\n\nMODULE_AUTHOR(\"Daniel Mack <daniel@zonque.org>\");\nMODULE_DESCRIPTION(\"LED driver for LT3593 controllers\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:leds-lt3593\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}