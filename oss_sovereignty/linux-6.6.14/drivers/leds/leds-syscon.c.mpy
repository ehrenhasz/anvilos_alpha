{
  "module_name": "leds-syscon.c",
  "hash_id": "f53ce9ea8fb953540fb1fc29a0aca93eaf53dad60139884363b2a12eb6d7e76a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-syscon.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/leds.h>\n\n \nstruct syscon_led {\n\tstruct led_classdev cdev;\n\tstruct regmap *map;\n\tu32 offset;\n\tu32 mask;\n\tbool state;\n};\n\nstatic void syscon_led_set(struct led_classdev *led_cdev,\n\tenum led_brightness value)\n{\n\tstruct syscon_led *sled =\n\t\tcontainer_of(led_cdev, struct syscon_led, cdev);\n\tu32 val;\n\tint ret;\n\n\tif (value == LED_OFF) {\n\t\tval = 0;\n\t\tsled->state = false;\n\t} else {\n\t\tval = sled->mask;\n\t\tsled->state = true;\n\t}\n\n\tret = regmap_update_bits(sled->map, sled->offset, sled->mask, val);\n\tif (ret < 0)\n\t\tdev_err(sled->cdev.dev, \"error updating LED status\\n\");\n}\n\nstatic int syscon_led_probe(struct platform_device *pdev)\n{\n\tstruct led_init_data init_data = {};\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev_of_node(dev);\n\tstruct device *parent;\n\tstruct regmap *map;\n\tstruct syscon_led *sled;\n\tenum led_default_state state;\n\tu32 value;\n\tint ret;\n\n\tparent = dev->parent;\n\tif (!parent) {\n\t\tdev_err(dev, \"no parent for syscon LED\\n\");\n\t\treturn -ENODEV;\n\t}\n\tmap = syscon_node_to_regmap(dev_of_node(parent));\n\tif (IS_ERR(map)) {\n\t\tdev_err(dev, \"no regmap for syscon LED parent\\n\");\n\t\treturn PTR_ERR(map);\n\t}\n\n\tsled = devm_kzalloc(dev, sizeof(*sled), GFP_KERNEL);\n\tif (!sled)\n\t\treturn -ENOMEM;\n\n\tsled->map = map;\n\n\tif (of_property_read_u32(np, \"offset\", &sled->offset))\n\t\treturn -EINVAL;\n\tif (of_property_read_u32(np, \"mask\", &sled->mask))\n\t\treturn -EINVAL;\n\n\tinit_data.fwnode = of_fwnode_handle(np);\n\n\tstate = led_init_default_state_get(init_data.fwnode);\n\tswitch (state) {\n\tcase LEDS_DEFSTATE_ON:\n\t\tret = regmap_update_bits(map, sled->offset, sled->mask, sled->mask);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsled->state = true;\n\t\tbreak;\n\tcase LEDS_DEFSTATE_KEEP:\n\t\tret = regmap_read(map, sled->offset, &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsled->state = !!(value & sled->mask);\n\t\tbreak;\n\tdefault:\n\t\tret = regmap_update_bits(map, sled->offset, sled->mask, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsled->state = false;\n\t}\n\tsled->cdev.brightness_set = syscon_led_set;\n\n\tret = devm_led_classdev_register_ext(dev, &sled->cdev, &init_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, sled);\n\tdev_info(dev, \"registered LED %s\\n\", sled->cdev.name);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_syscon_leds_match[] = {\n\t{ .compatible = \"register-bit-led\", },\n\t{},\n};\n\nstatic struct platform_driver syscon_led_driver = {\n\t.probe\t\t= syscon_led_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"leds-syscon\",\n\t\t.of_match_table = of_syscon_leds_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(syscon_led_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}