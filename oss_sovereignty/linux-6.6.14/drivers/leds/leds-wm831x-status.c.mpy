{
  "module_name": "leds-wm831x-status.c",
  "hash_id": "8c2db571f30cae0d9456271d36e6354cba1a49ff5180b95b7ade12098e51c6a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-wm831x-status.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/leds.h>\n#include <linux/err.h>\n#include <linux/mfd/wm831x/core.h>\n#include <linux/mfd/wm831x/pdata.h>\n#include <linux/mfd/wm831x/status.h>\n#include <linux/module.h>\n\n\nstruct wm831x_status {\n\tstruct led_classdev cdev;\n\tstruct wm831x *wm831x;\n\tstruct mutex mutex;\n\n\tspinlock_t value_lock;\n\tint reg;      \n\tint reg_val;  \n\n\tint blink;\n\tint blink_time;\n\tint blink_cyc;\n\tint src;\n\tenum led_brightness brightness;\n};\n\n#define to_wm831x_status(led_cdev) \\\n\tcontainer_of(led_cdev, struct wm831x_status, cdev)\n\nstatic void wm831x_status_set(struct wm831x_status *led)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&led->mutex);\n\n\tled->reg_val &= ~(WM831X_LED_SRC_MASK | WM831X_LED_MODE_MASK |\n\t\t\t  WM831X_LED_DUTY_CYC_MASK | WM831X_LED_DUR_MASK);\n\n\tspin_lock_irqsave(&led->value_lock, flags);\n\n\tled->reg_val |= led->src << WM831X_LED_SRC_SHIFT;\n\tif (led->blink) {\n\t\tled->reg_val |= 2 << WM831X_LED_MODE_SHIFT;\n\t\tled->reg_val |= led->blink_time << WM831X_LED_DUR_SHIFT;\n\t\tled->reg_val |= led->blink_cyc;\n\t} else {\n\t\tif (led->brightness != LED_OFF)\n\t\t\tled->reg_val |= 1 << WM831X_LED_MODE_SHIFT;\n\t}\n\n\tspin_unlock_irqrestore(&led->value_lock, flags);\n\n\twm831x_reg_write(led->wm831x, led->reg, led->reg_val);\n\n\tmutex_unlock(&led->mutex);\n}\n\nstatic int wm831x_status_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\t enum led_brightness value)\n{\n\tstruct wm831x_status *led = to_wm831x_status(led_cdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&led->value_lock, flags);\n\tled->brightness = value;\n\tif (value == LED_OFF)\n\t\tled->blink = 0;\n\tspin_unlock_irqrestore(&led->value_lock, flags);\n\twm831x_status_set(led);\n\n\treturn 0;\n}\n\nstatic int wm831x_status_blink_set(struct led_classdev *led_cdev,\n\t\t\t\t   unsigned long *delay_on,\n\t\t\t\t   unsigned long *delay_off)\n{\n\tstruct wm831x_status *led = to_wm831x_status(led_cdev);\n\tunsigned long flags;\n\tint ret = 0;\n\n\t \n\tif (*delay_on == 0 && *delay_off == 0) {\n\t\t*delay_on = 250;\n\t\t*delay_off = 250;\n\t}\n\n\tspin_lock_irqsave(&led->value_lock, flags);\n\n\t \n\tswitch (*delay_on) {\n\tcase 1000:\n\t\tled->blink_time = 0;\n\t\tbreak;\n\tcase 250:\n\t\tled->blink_time = 1;\n\t\tbreak;\n\tcase 125:\n\t\tled->blink_time = 2;\n\t\tbreak;\n\tcase 62:\n\tcase 63:\n\t\t \n\t\tled->blink_time = 3;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret == 0) {\n\t\tswitch (*delay_off / *delay_on) {\n\t\tcase 1:\n\t\t\tled->blink_cyc = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tled->blink_cyc = 1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tled->blink_cyc = 2;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tled->blink_cyc = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret == 0)\n\t\tled->blink = 1;\n\telse\n\t\tled->blink = 0;\n\n\tspin_unlock_irqrestore(&led->value_lock, flags);\n\twm831x_status_set(led);\n\n\treturn ret;\n}\n\nstatic const char * const led_src_texts[] = {\n\t\"otp\",\n\t\"power\",\n\t\"charger\",\n\t\"soft\",\n};\n\nstatic ssize_t src_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct wm831x_status *led = to_wm831x_status(led_cdev);\n\tint i;\n\tssize_t ret = 0;\n\n\tmutex_lock(&led->mutex);\n\n\tfor (i = 0; i < ARRAY_SIZE(led_src_texts); i++)\n\t\tif (i == led->src)\n\t\t\tret += sprintf(&buf[ret], \"[%s] \", led_src_texts[i]);\n\t\telse\n\t\t\tret += sprintf(&buf[ret], \"%s \", led_src_texts[i]);\n\n\tmutex_unlock(&led->mutex);\n\n\tret += sprintf(&buf[ret], \"\\n\");\n\n\treturn ret;\n}\n\nstatic ssize_t src_store(struct device *dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t size)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct wm831x_status *led = to_wm831x_status(led_cdev);\n\tint i;\n\n\ti = sysfs_match_string(led_src_texts, buf);\n\tif (i >= 0) {\n\t\tmutex_lock(&led->mutex);\n\t\tled->src = i;\n\t\tmutex_unlock(&led->mutex);\n\t\twm831x_status_set(led);\n\t}\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(src);\n\nstatic struct attribute *wm831x_status_attrs[] = {\n\t&dev_attr_src.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(wm831x_status);\n\nstatic int wm831x_status_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_pdata *chip_pdata;\n\tstruct wm831x_status_pdata pdata;\n\tstruct wm831x_status *drvdata;\n\tstruct resource *res;\n\tint id = pdev->id % ARRAY_SIZE(chip_pdata->status);\n\tint ret;\n\n\tres = platform_get_resource(pdev, IORESOURCE_REG, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"No register resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdrvdata = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_status),\n\t\t\t       GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->wm831x = wm831x;\n\tdrvdata->reg = res->start;\n\n\tif (dev_get_platdata(wm831x->dev))\n\t\tchip_pdata = dev_get_platdata(wm831x->dev);\n\telse\n\t\tchip_pdata = NULL;\n\n\tmemset(&pdata, 0, sizeof(pdata));\n\tif (chip_pdata && chip_pdata->status[id])\n\t\tmemcpy(&pdata, chip_pdata->status[id], sizeof(pdata));\n\telse\n\t\tpdata.name = dev_name(&pdev->dev);\n\n\tmutex_init(&drvdata->mutex);\n\tspin_lock_init(&drvdata->value_lock);\n\n\t \n\tdrvdata->reg_val = wm831x_reg_read(wm831x, drvdata->reg);\n\n\tif (drvdata->reg_val & WM831X_LED_MODE_MASK)\n\t\tdrvdata->brightness = LED_FULL;\n\telse\n\t\tdrvdata->brightness = LED_OFF;\n\n\t \n\tif (pdata.default_src == WM831X_STATUS_PRESERVE) {\n\t\tdrvdata->src = drvdata->reg_val;\n\t\tdrvdata->src &= WM831X_LED_SRC_MASK;\n\t\tdrvdata->src >>= WM831X_LED_SRC_SHIFT;\n\t} else {\n\t\tdrvdata->src = pdata.default_src - 1;\n\t}\n\n\tdrvdata->cdev.name = pdata.name;\n\tdrvdata->cdev.default_trigger = pdata.default_trigger;\n\tdrvdata->cdev.brightness_set_blocking = wm831x_status_brightness_set;\n\tdrvdata->cdev.blink_set = wm831x_status_blink_set;\n\tdrvdata->cdev.groups = wm831x_status_groups;\n\n\tret = led_classdev_register(wm831x->dev, &drvdata->cdev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to register LED: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, drvdata);\n\n\treturn 0;\n}\n\nstatic int wm831x_status_remove(struct platform_device *pdev)\n{\n\tstruct wm831x_status *drvdata = platform_get_drvdata(pdev);\n\n\tled_classdev_unregister(&drvdata->cdev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver wm831x_status_driver = {\n\t.driver = {\n\t\t   .name = \"wm831x-status\",\n\t\t   },\n\t.probe = wm831x_status_probe,\n\t.remove = wm831x_status_remove,\n};\n\nmodule_platform_driver(wm831x_status_driver);\n\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"WM831x status LED driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm831x-status\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}