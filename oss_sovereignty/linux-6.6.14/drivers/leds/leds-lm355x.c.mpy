{
  "module_name": "leds-lm355x.c",
  "hash_id": "056c0250261be4aaeb3030949e820c9eb774c802263ea25c89dff48bc772c220",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-lm355x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/fs.h>\n#include <linux/regmap.h>\n#include <linux/platform_data/leds-lm355x.h>\n\nenum lm355x_type {\n\tCHIP_LM3554 = 0,\n\tCHIP_LM3556,\n};\n\nenum lm355x_regs {\n\tREG_FLAG = 0,\n\tREG_TORCH_CFG,\n\tREG_TORCH_CTRL,\n\tREG_STROBE_CFG,\n\tREG_FLASH_CTRL,\n\tREG_INDI_CFG,\n\tREG_INDI_CTRL,\n\tREG_OPMODE,\n\tREG_MAX,\n};\n\n \nenum lm355x_mode {\n\tMODE_SHDN = 0,\n\tMODE_INDIC,\n\tMODE_TORCH,\n\tMODE_FLASH\n};\n\n \nstruct lm355x_reg_data {\n\tu8 regno;\n\tu8 mask;\n\tu8 shift;\n};\n\nstruct lm355x_chip_data {\n\tstruct device *dev;\n\tenum lm355x_type type;\n\n\tstruct led_classdev cdev_flash;\n\tstruct led_classdev cdev_torch;\n\tstruct led_classdev cdev_indicator;\n\n\tstruct lm355x_platform_data *pdata;\n\tstruct regmap *regmap;\n\tstruct mutex lock;\n\n\tunsigned int last_flag;\n\tstruct lm355x_reg_data *regs;\n};\n\n \nenum lm3556_indic_pulse_time {\n\tPULSE_TIME_0_MS = 0,\n\tPULSE_TIME_32_MS,\n\tPULSE_TIME_64_MS,\n\tPULSE_TIME_92_MS,\n\tPULSE_TIME_128_MS,\n\tPULSE_TIME_160_MS,\n\tPULSE_TIME_196_MS,\n\tPULSE_TIME_224_MS,\n\tPULSE_TIME_256_MS,\n\tPULSE_TIME_288_MS,\n\tPULSE_TIME_320_MS,\n\tPULSE_TIME_352_MS,\n\tPULSE_TIME_384_MS,\n\tPULSE_TIME_416_MS,\n\tPULSE_TIME_448_MS,\n\tPULSE_TIME_480_MS,\n};\n\nenum lm3556_indic_n_blank {\n\tINDIC_N_BLANK_0 = 0,\n\tINDIC_N_BLANK_1,\n\tINDIC_N_BLANK_2,\n\tINDIC_N_BLANK_3,\n\tINDIC_N_BLANK_4,\n\tINDIC_N_BLANK_5,\n\tINDIC_N_BLANK_6,\n\tINDIC_N_BLANK_7,\n\tINDIC_N_BLANK_8,\n\tINDIC_N_BLANK_9,\n\tINDIC_N_BLANK_10,\n\tINDIC_N_BLANK_11,\n\tINDIC_N_BLANK_12,\n\tINDIC_N_BLANK_13,\n\tINDIC_N_BLANK_14,\n\tINDIC_N_BLANK_15,\n};\n\nenum lm3556_indic_period {\n\tINDIC_PERIOD_0 = 0,\n\tINDIC_PERIOD_1,\n\tINDIC_PERIOD_2,\n\tINDIC_PERIOD_3,\n\tINDIC_PERIOD_4,\n\tINDIC_PERIOD_5,\n\tINDIC_PERIOD_6,\n\tINDIC_PERIOD_7,\n};\n\n#define INDIC_PATTERN_SIZE 4\n\nstruct indicator {\n\tu8 blinking;\n\tu8 period_cnt;\n};\n\n \nstatic struct indicator indicator_pattern[INDIC_PATTERN_SIZE] = {\n\t[0] = {(INDIC_N_BLANK_1 << 4) | PULSE_TIME_32_MS, INDIC_PERIOD_1},\n\t[1] = {(INDIC_N_BLANK_15 << 4) | PULSE_TIME_32_MS, INDIC_PERIOD_2},\n\t[2] = {(INDIC_N_BLANK_10 << 4) | PULSE_TIME_32_MS, INDIC_PERIOD_4},\n\t[3] = {(INDIC_N_BLANK_5 << 4) | PULSE_TIME_32_MS, INDIC_PERIOD_7},\n};\n\nstatic struct lm355x_reg_data lm3554_regs[REG_MAX] = {\n\t[REG_FLAG] = {0xD0, 0xBF, 0},\n\t[REG_TORCH_CFG] = {0xE0, 0x80, 7},\n\t[REG_TORCH_CTRL] = {0xA0, 0x38, 3},\n\t[REG_STROBE_CFG] = {0xE0, 0x04, 2},\n\t[REG_FLASH_CTRL] = {0xB0, 0x78, 3},\n\t[REG_INDI_CFG] = {0xE0, 0x08, 3},\n\t[REG_INDI_CTRL] = {0xA0, 0xC0, 6},\n\t[REG_OPMODE] = {0xA0, 0x03, 0},\n};\n\nstatic struct lm355x_reg_data lm3556_regs[REG_MAX] = {\n\t[REG_FLAG] = {0x0B, 0xFF, 0},\n\t[REG_TORCH_CFG] = {0x0A, 0x10, 4},\n\t[REG_TORCH_CTRL] = {0x09, 0x70, 4},\n\t[REG_STROBE_CFG] = {0x0A, 0x20, 5},\n\t[REG_FLASH_CTRL] = {0x09, 0x0F, 0},\n\t[REG_INDI_CFG] = {0xFF, 0xFF, 0},\n\t[REG_INDI_CTRL] = {0x09, 0x70, 4},\n\t[REG_OPMODE] = {0x0A, 0x03, 0},\n};\n\nstatic char lm355x_name[][I2C_NAME_SIZE] = {\n\t[CHIP_LM3554] = LM3554_NAME,\n\t[CHIP_LM3556] = LM3556_NAME,\n};\n\n \nstatic int lm355x_chip_init(struct lm355x_chip_data *chip)\n{\n\tint ret;\n\tunsigned int reg_val;\n\tstruct lm355x_platform_data *pdata = chip->pdata;\n\n\t \n\tswitch (chip->type) {\n\tcase CHIP_LM3554:\n\t\treg_val = (u32)pdata->pin_tx2 | (u32)pdata->ntc_pin;\n\t\tret = regmap_update_bits(chip->regmap, 0xE0, 0x28, reg_val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\treg_val = (u32)pdata->pass_mode;\n\t\tret = regmap_update_bits(chip->regmap, 0xA0, 0x04, reg_val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase CHIP_LM3556:\n\t\treg_val = (u32)pdata->pin_tx2 | (u32)pdata->ntc_pin |\n\t\t          (u32)pdata->pass_mode;\n\t\tret = regmap_update_bits(chip->regmap, 0x0A, 0xC4, reg_val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n\n\treturn ret;\nout:\n\tdev_err(chip->dev, \"%s:i2c access fail to register\\n\", __func__);\n\treturn ret;\n}\n\n \nstatic int lm355x_control(struct lm355x_chip_data *chip,\n\t\t\t   u8 brightness, enum lm355x_mode opmode)\n{\n\tint ret;\n\tunsigned int reg_val;\n\tstruct lm355x_platform_data *pdata = chip->pdata;\n\tstruct lm355x_reg_data *preg = chip->regs;\n\n\tret = regmap_read(chip->regmap, preg[REG_FLAG].regno, &chip->last_flag);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (chip->last_flag & preg[REG_FLAG].mask)\n\t\tdev_info(chip->dev, \"%s Last FLAG is 0x%x\\n\",\n\t\t\t lm355x_name[chip->type],\n\t\t\t chip->last_flag & preg[REG_FLAG].mask);\n\t \n\tif (!brightness)\n\t\topmode = MODE_SHDN;\n\n\tswitch (opmode) {\n\tcase MODE_TORCH:\n\t\tret =\n\t\t    regmap_update_bits(chip->regmap, preg[REG_TORCH_CTRL].regno,\n\t\t\t\t       preg[REG_TORCH_CTRL].mask,\n\t\t\t\t       (brightness - 1)\n\t\t\t\t       << preg[REG_TORCH_CTRL].shift);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (pdata->pin_tx1 != LM355x_PIN_TORCH_DISABLE) {\n\t\t\tret =\n\t\t\t    regmap_update_bits(chip->regmap,\n\t\t\t\t\t       preg[REG_TORCH_CFG].regno,\n\t\t\t\t\t       preg[REG_TORCH_CFG].mask,\n\t\t\t\t\t       0x01 <<\n\t\t\t\t\t       preg[REG_TORCH_CFG].shift);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\topmode = MODE_SHDN;\n\t\t\tdev_info(chip->dev,\n\t\t\t\t \"torch brt is set - ext. torch pin mode\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase MODE_FLASH:\n\n\t\tret =\n\t\t    regmap_update_bits(chip->regmap, preg[REG_FLASH_CTRL].regno,\n\t\t\t\t       preg[REG_FLASH_CTRL].mask,\n\t\t\t\t       (brightness - 1)\n\t\t\t\t       << preg[REG_FLASH_CTRL].shift);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (pdata->pin_strobe != LM355x_PIN_STROBE_DISABLE) {\n\t\t\tif (chip->type == CHIP_LM3554)\n\t\t\t\treg_val = 0x00;\n\t\t\telse\n\t\t\t\treg_val = 0x01;\n\t\t\tret =\n\t\t\t    regmap_update_bits(chip->regmap,\n\t\t\t\t\t       preg[REG_STROBE_CFG].regno,\n\t\t\t\t\t       preg[REG_STROBE_CFG].mask,\n\t\t\t\t\t       reg_val <<\n\t\t\t\t\t       preg[REG_STROBE_CFG].shift);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\topmode = MODE_SHDN;\n\t\t\tdev_info(chip->dev,\n\t\t\t\t \"flash brt is set - ext. strobe pin mode\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase MODE_INDIC:\n\t\tret =\n\t\t    regmap_update_bits(chip->regmap, preg[REG_INDI_CTRL].regno,\n\t\t\t\t       preg[REG_INDI_CTRL].mask,\n\t\t\t\t       (brightness - 1)\n\t\t\t\t       << preg[REG_INDI_CTRL].shift);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (pdata->pin_tx2 != LM355x_PIN_TX_DISABLE) {\n\t\t\tret =\n\t\t\t    regmap_update_bits(chip->regmap,\n\t\t\t\t\t       preg[REG_INDI_CFG].regno,\n\t\t\t\t\t       preg[REG_INDI_CFG].mask,\n\t\t\t\t\t       0x01 <<\n\t\t\t\t\t       preg[REG_INDI_CFG].shift);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\topmode = MODE_SHDN;\n\t\t}\n\t\tbreak;\n\tcase MODE_SHDN:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t \n\tret = regmap_update_bits(chip->regmap, preg[REG_OPMODE].regno,\n\t\t\t\t preg[REG_OPMODE].mask,\n\t\t\t\t opmode << preg[REG_OPMODE].shift);\n\tif (ret < 0)\n\t\tgoto out;\n\treturn ret;\nout:\n\tdev_err(chip->dev, \"%s:i2c access fail to register\\n\", __func__);\n\treturn ret;\n}\n\n \n\nstatic int lm355x_torch_brightness_set(struct led_classdev *cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct lm355x_chip_data *chip =\n\t    container_of(cdev, struct lm355x_chip_data, cdev_torch);\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\tret = lm355x_control(chip, brightness, MODE_TORCH);\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\n \n\nstatic int lm355x_strobe_brightness_set(struct led_classdev *cdev,\n\t\t\t\t\t enum led_brightness brightness)\n{\n\tstruct lm355x_chip_data *chip =\n\t    container_of(cdev, struct lm355x_chip_data, cdev_flash);\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\tret = lm355x_control(chip, brightness, MODE_FLASH);\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\n \n\nstatic int lm355x_indicator_brightness_set(struct led_classdev *cdev,\n\t\t\t\t\t    enum led_brightness brightness)\n{\n\tstruct lm355x_chip_data *chip =\n\t    container_of(cdev, struct lm355x_chip_data, cdev_indicator);\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\tret = lm355x_control(chip, brightness, MODE_INDIC);\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\n \nstatic ssize_t pattern_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t size)\n{\n\tssize_t ret;\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm355x_chip_data *chip =\n\t    container_of(led_cdev, struct lm355x_chip_data, cdev_indicator);\n\tunsigned int state;\n\n\tret = kstrtouint(buf, 10, &state);\n\tif (ret)\n\t\tgoto out;\n\tif (state > INDIC_PATTERN_SIZE - 1)\n\t\tstate = INDIC_PATTERN_SIZE - 1;\n\n\tret = regmap_write(chip->regmap, 0x04,\n\t\t\t   indicator_pattern[state].blinking);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = regmap_write(chip->regmap, 0x05,\n\t\t\t   indicator_pattern[state].period_cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treturn size;\nout:\n\tdev_err(chip->dev, \"%s:i2c access fail to register\\n\", __func__);\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_WO(pattern);\n\nstatic struct attribute *lm355x_indicator_attrs[] = {\n\t&dev_attr_pattern.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(lm355x_indicator);\n\nstatic const struct regmap_config lm355x_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xFF,\n};\n\n \nstatic int lm355x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct lm355x_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct lm355x_chip_data *chip;\n\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"i2c functionality check fail.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (pdata == NULL) {\n\t\tdev_err(&client->dev, \"needs Platform Data.\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\tchip = devm_kzalloc(&client->dev,\n\t\t\t    sizeof(struct lm355x_chip_data), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = &client->dev;\n\tchip->type = id->driver_data;\n\tswitch (id->driver_data) {\n\tcase CHIP_LM3554:\n\t\tchip->regs = lm3554_regs;\n\t\tbreak;\n\tcase CHIP_LM3556:\n\t\tchip->regs = lm3556_regs;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\tchip->pdata = pdata;\n\n\tchip->regmap = devm_regmap_init_i2c(client, &lm355x_regmap);\n\tif (IS_ERR(chip->regmap)) {\n\t\terr = PTR_ERR(chip->regmap);\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to allocate register map: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tmutex_init(&chip->lock);\n\ti2c_set_clientdata(client, chip);\n\n\terr = lm355x_chip_init(chip);\n\tif (err < 0)\n\t\tgoto err_out;\n\n\t \n\tchip->cdev_flash.name = \"flash\";\n\tchip->cdev_flash.max_brightness = 16;\n\tchip->cdev_flash.brightness_set_blocking = lm355x_strobe_brightness_set;\n\tchip->cdev_flash.default_trigger = \"flash\";\n\terr = led_classdev_register(&client->dev, &chip->cdev_flash);\n\tif (err < 0)\n\t\tgoto err_out;\n\t \n\tchip->cdev_torch.name = \"torch\";\n\tchip->cdev_torch.max_brightness = 8;\n\tchip->cdev_torch.brightness_set_blocking = lm355x_torch_brightness_set;\n\tchip->cdev_torch.default_trigger = \"torch\";\n\terr = led_classdev_register(&client->dev, &chip->cdev_torch);\n\tif (err < 0)\n\t\tgoto err_create_torch_file;\n\t \n\tchip->cdev_indicator.name = \"indicator\";\n\tif (id->driver_data == CHIP_LM3554)\n\t\tchip->cdev_indicator.max_brightness = 4;\n\telse\n\t\tchip->cdev_indicator.max_brightness = 8;\n\tchip->cdev_indicator.brightness_set_blocking =\n\t\t\t\t\tlm355x_indicator_brightness_set;\n\t \n\tif (id->driver_data == CHIP_LM3556)\n\t\tchip->cdev_indicator.groups = lm355x_indicator_groups;\n\terr = led_classdev_register(&client->dev, &chip->cdev_indicator);\n\tif (err < 0)\n\t\tgoto err_create_indicator_file;\n\n\tdev_info(&client->dev, \"%s is initialized\\n\",\n\t\t lm355x_name[id->driver_data]);\n\treturn 0;\n\nerr_create_indicator_file:\n\tled_classdev_unregister(&chip->cdev_torch);\nerr_create_torch_file:\n\tled_classdev_unregister(&chip->cdev_flash);\nerr_out:\n\treturn err;\n}\n\nstatic void lm355x_remove(struct i2c_client *client)\n{\n\tstruct lm355x_chip_data *chip = i2c_get_clientdata(client);\n\tstruct lm355x_reg_data *preg = chip->regs;\n\n\tregmap_write(chip->regmap, preg[REG_OPMODE].regno, 0);\n\tled_classdev_unregister(&chip->cdev_indicator);\n\tled_classdev_unregister(&chip->cdev_torch);\n\tled_classdev_unregister(&chip->cdev_flash);\n\tdev_info(&client->dev, \"%s is removed\\n\", lm355x_name[chip->type]);\n}\n\nstatic const struct i2c_device_id lm355x_id[] = {\n\t{LM3554_NAME, CHIP_LM3554},\n\t{LM3556_NAME, CHIP_LM3556},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, lm355x_id);\n\nstatic struct i2c_driver lm355x_i2c_driver = {\n\t.driver = {\n\t\t   .name = LM355x_NAME,\n\t\t   .pm = NULL,\n\t\t   },\n\t.probe = lm355x_probe,\n\t.remove = lm355x_remove,\n\t.id_table = lm355x_id,\n};\n\nmodule_i2c_driver(lm355x_i2c_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments Flash Lighting driver for LM355x\");\nMODULE_AUTHOR(\"Daniel Jeong <daniel.jeong@ti.com>\");\nMODULE_AUTHOR(\"G.Shark Jeong <gshark.jeong@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}