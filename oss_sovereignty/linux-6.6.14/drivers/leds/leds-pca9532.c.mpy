{
  "module_name": "leds-pca9532.c",
  "hash_id": "9839947896ceb4090e70a967b72aaf96376f42ebaee6e1ee9649d02558ef5605",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-pca9532.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/leds.h>\n#include <linux/input.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/leds-pca9532.h>\n#include <linux/gpio/driver.h>\n#include <linux/of.h>\n\n \n#define PCA9532_REG_INPUT(i)\t((i) >> 3)\n#define PCA9532_REG_OFFSET(m)\t((m) >> 4)\n#define PCA9532_REG_PSC(m, i)\t(PCA9532_REG_OFFSET(m) + 0x1 + (i) * 2)\n#define PCA9532_REG_PWM(m, i)\t(PCA9532_REG_OFFSET(m) + 0x2 + (i) * 2)\n#define LED_REG(m, led)\t\t(PCA9532_REG_OFFSET(m) + 0x5 + (led >> 2))\n#define LED_NUM(led)\t\t(led & 0x3)\n#define LED_SHIFT(led)\t\t(LED_NUM(led) * 2)\n#define LED_MASK(led)\t\t(0x3 << LED_SHIFT(led))\n\n#define ldev_to_led(c)       container_of(c, struct pca9532_led, ldev)\n\nstruct pca9532_chip_info {\n\tu8\tnum_leds;\n};\n\nstruct pca9532_data {\n\tstruct i2c_client *client;\n\tstruct pca9532_led leds[16];\n\tstruct mutex update_lock;\n\tstruct input_dev *idev;\n\tstruct work_struct work;\n#ifdef CONFIG_LEDS_PCA9532_GPIO\n\tstruct gpio_chip gpio;\n#endif\n\tconst struct pca9532_chip_info *chip_info;\n\tu8 pwm[2];\n\tu8 psc[2];\n};\n\nstatic int pca9532_probe(struct i2c_client *client);\nstatic void pca9532_remove(struct i2c_client *client);\n\nenum {\n\tpca9530,\n\tpca9531,\n\tpca9532,\n\tpca9533,\n};\n\nstatic const struct i2c_device_id pca9532_id[] = {\n\t{ \"pca9530\", pca9530 },\n\t{ \"pca9531\", pca9531 },\n\t{ \"pca9532\", pca9532 },\n\t{ \"pca9533\", pca9533 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, pca9532_id);\n\nstatic const struct pca9532_chip_info pca9532_chip_info_tbl[] = {\n\t[pca9530] = {\n\t\t.num_leds = 2,\n\t},\n\t[pca9531] = {\n\t\t.num_leds = 8,\n\t},\n\t[pca9532] = {\n\t\t.num_leds = 16,\n\t},\n\t[pca9533] = {\n\t\t.num_leds = 4,\n\t},\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_pca9532_leds_match[] = {\n\t{ .compatible = \"nxp,pca9530\", .data = (void *)pca9530 },\n\t{ .compatible = \"nxp,pca9531\", .data = (void *)pca9531 },\n\t{ .compatible = \"nxp,pca9532\", .data = (void *)pca9532 },\n\t{ .compatible = \"nxp,pca9533\", .data = (void *)pca9533 },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, of_pca9532_leds_match);\n#endif\n\nstatic struct i2c_driver pca9532_driver = {\n\t.driver = {\n\t\t.name = \"leds-pca953x\",\n\t\t.of_match_table = of_match_ptr(of_pca9532_leds_match),\n\t},\n\t.probe = pca9532_probe,\n\t.remove = pca9532_remove,\n\t.id_table = pca9532_id,\n};\n\n \nstatic int pca9532_calcpwm(struct i2c_client *client, int pwm, int blink,\n\tenum led_brightness value)\n{\n\tint a = 0, b = 0, i = 0;\n\tstruct pca9532_data *data = i2c_get_clientdata(client);\n\tfor (i = 0; i < data->chip_info->num_leds; i++) {\n\t\tif (data->leds[i].type == PCA9532_TYPE_LED &&\n\t\t\tdata->leds[i].state == PCA9532_PWM0+pwm) {\n\t\t\t\ta++;\n\t\t\t\tb += data->leds[i].ldev.brightness;\n\t\t}\n\t}\n\tif (a == 0) {\n\t\tdev_err(&client->dev,\n\t\t\"fear of division by zero %d/%d, wanted %d\\n\",\n\t\t\tb, a, value);\n\t\treturn -EINVAL;\n\t}\n\tb = b/a;\n\tif (b > 0xFF)\n\t\treturn -EINVAL;\n\tdata->pwm[pwm] = b;\n\tdata->psc[pwm] = blink;\n\treturn 0;\n}\n\nstatic int pca9532_setpwm(struct i2c_client *client, int pwm)\n{\n\tstruct pca9532_data *data = i2c_get_clientdata(client);\n\tu8 maxleds = data->chip_info->num_leds;\n\n\tmutex_lock(&data->update_lock);\n\ti2c_smbus_write_byte_data(client, PCA9532_REG_PWM(maxleds, pwm),\n\t\tdata->pwm[pwm]);\n\ti2c_smbus_write_byte_data(client, PCA9532_REG_PSC(maxleds, pwm),\n\t\tdata->psc[pwm]);\n\tmutex_unlock(&data->update_lock);\n\treturn 0;\n}\n\n \nstatic void pca9532_setled(struct pca9532_led *led)\n{\n\tstruct i2c_client *client = led->client;\n\tstruct pca9532_data *data = i2c_get_clientdata(client);\n\tu8 maxleds = data->chip_info->num_leds;\n\tchar reg;\n\n\tmutex_lock(&data->update_lock);\n\treg = i2c_smbus_read_byte_data(client, LED_REG(maxleds, led->id));\n\t \n\treg = reg & ~LED_MASK(led->id);\n\t \n\treg = reg | (led->state << LED_SHIFT(led->id));\n\ti2c_smbus_write_byte_data(client, LED_REG(maxleds, led->id), reg);\n\tmutex_unlock(&data->update_lock);\n}\n\nstatic int pca9532_set_brightness(struct led_classdev *led_cdev,\n\tenum led_brightness value)\n{\n\tint err = 0;\n\tstruct pca9532_led *led = ldev_to_led(led_cdev);\n\n\tif (value == LED_OFF)\n\t\tled->state = PCA9532_OFF;\n\telse if (value == LED_FULL)\n\t\tled->state = PCA9532_ON;\n\telse {\n\t\tled->state = PCA9532_PWM0;  \n\t\terr = pca9532_calcpwm(led->client, 0, 0, value);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (led->state == PCA9532_PWM0)\n\t\tpca9532_setpwm(led->client, 0);\n\tpca9532_setled(led);\n\treturn err;\n}\n\nstatic int pca9532_set_blink(struct led_classdev *led_cdev,\n\tunsigned long *delay_on, unsigned long *delay_off)\n{\n\tstruct pca9532_led *led = ldev_to_led(led_cdev);\n\tstruct i2c_client *client = led->client;\n\tint psc;\n\tint err = 0;\n\n\tif (*delay_on == 0 && *delay_off == 0) {\n\t\t \n\t\t*delay_on = 1000;\n\t\t*delay_off = 1000;\n\t}\n\tif (*delay_on != *delay_off || *delay_on > 1690 || *delay_on < 6)\n\t\treturn -EINVAL;\n\n\t \n\tpsc = (*delay_on * 152-1)/1000;\n\terr = pca9532_calcpwm(client, 0, psc, led_cdev->brightness);\n\tif (err)\n\t\treturn err;\n\tif (led->state == PCA9532_PWM0)\n\t\tpca9532_setpwm(led->client, 0);\n\tpca9532_setled(led);\n\n\treturn 0;\n}\n\nstatic int pca9532_event(struct input_dev *dev, unsigned int type,\n\tunsigned int code, int value)\n{\n\tstruct pca9532_data *data = input_get_drvdata(dev);\n\n\tif (!(type == EV_SND && (code == SND_BELL || code == SND_TONE)))\n\t\treturn -1;\n\n\t \n\tif (value > 1 && value < 32767)\n\t\tdata->pwm[1] = 127;\n\telse\n\t\tdata->pwm[1] = 0;\n\n\tschedule_work(&data->work);\n\n\treturn 0;\n}\n\nstatic void pca9532_input_work(struct work_struct *work)\n{\n\tstruct pca9532_data *data =\n\t\tcontainer_of(work, struct pca9532_data, work);\n\tu8 maxleds = data->chip_info->num_leds;\n\n\tmutex_lock(&data->update_lock);\n\ti2c_smbus_write_byte_data(data->client, PCA9532_REG_PWM(maxleds, 1),\n\t\tdata->pwm[1]);\n\tmutex_unlock(&data->update_lock);\n}\n\nstatic enum pca9532_state pca9532_getled(struct pca9532_led *led)\n{\n\tstruct i2c_client *client = led->client;\n\tstruct pca9532_data *data = i2c_get_clientdata(client);\n\tu8 maxleds = data->chip_info->num_leds;\n\tchar reg;\n\tenum pca9532_state ret;\n\n\tmutex_lock(&data->update_lock);\n\treg = i2c_smbus_read_byte_data(client, LED_REG(maxleds, led->id));\n\tret = (reg & LED_MASK(led->id)) >> LED_SHIFT(led->id);\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\n#ifdef CONFIG_LEDS_PCA9532_GPIO\nstatic int pca9532_gpio_request_pin(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct pca9532_data *data = gpiochip_get_data(gc);\n\tstruct pca9532_led *led = &data->leds[offset];\n\n\tif (led->type == PCA9532_TYPE_GPIO)\n\t\treturn 0;\n\n\treturn -EBUSY;\n}\n\nstatic void pca9532_gpio_set_value(struct gpio_chip *gc, unsigned offset, int val)\n{\n\tstruct pca9532_data *data = gpiochip_get_data(gc);\n\tstruct pca9532_led *led = &data->leds[offset];\n\n\tif (val)\n\t\tled->state = PCA9532_ON;\n\telse\n\t\tled->state = PCA9532_OFF;\n\n\tpca9532_setled(led);\n}\n\nstatic int pca9532_gpio_get_value(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct pca9532_data *data = gpiochip_get_data(gc);\n\tunsigned char reg;\n\n\treg = i2c_smbus_read_byte_data(data->client, PCA9532_REG_INPUT(offset));\n\n\treturn !!(reg & (1 << (offset % 8)));\n}\n\nstatic int pca9532_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\n{\n\t \n\tpca9532_gpio_set_value(gc, offset, 0);\n\n\treturn 0;\n}\n\nstatic int pca9532_gpio_direction_output(struct gpio_chip *gc, unsigned offset, int val)\n{\n\tpca9532_gpio_set_value(gc, offset, val);\n\n\treturn 0;\n}\n#endif  \n\nstatic void pca9532_destroy_devices(struct pca9532_data *data, int n_devs)\n{\n\tint i = n_devs;\n\n\twhile (--i >= 0) {\n\t\tswitch (data->leds[i].type) {\n\t\tcase PCA9532_TYPE_NONE:\n\t\tcase PCA9532_TYPE_GPIO:\n\t\t\tbreak;\n\t\tcase PCA9532_TYPE_LED:\n\t\t\tled_classdev_unregister(&data->leds[i].ldev);\n\t\t\tbreak;\n\t\tcase PCA9532_TYPE_N2100_BEEP:\n\t\t\tif (data->idev != NULL) {\n\t\t\t\tcancel_work_sync(&data->work);\n\t\t\t\tdata->idev = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef CONFIG_LEDS_PCA9532_GPIO\n\tif (data->gpio.parent)\n\t\tgpiochip_remove(&data->gpio);\n#endif\n}\n\nstatic int pca9532_configure(struct i2c_client *client,\n\tstruct pca9532_data *data, struct pca9532_platform_data *pdata)\n{\n\tint i, err = 0;\n\tint gpios = 0;\n\tu8 maxleds = data->chip_info->num_leds;\n\n\tfor (i = 0; i < 2; i++)\t{\n\t\tdata->pwm[i] = pdata->pwm[i];\n\t\tdata->psc[i] = pdata->psc[i];\n\t\ti2c_smbus_write_byte_data(client, PCA9532_REG_PWM(maxleds, i),\n\t\t\tdata->pwm[i]);\n\t\ti2c_smbus_write_byte_data(client, PCA9532_REG_PSC(maxleds, i),\n\t\t\tdata->psc[i]);\n\t}\n\n\tfor (i = 0; i < data->chip_info->num_leds; i++) {\n\t\tstruct pca9532_led *led = &data->leds[i];\n\t\tstruct pca9532_led *pled = &pdata->leds[i];\n\t\tled->client = client;\n\t\tled->id = i;\n\t\tled->type = pled->type;\n\t\tswitch (led->type) {\n\t\tcase PCA9532_TYPE_NONE:\n\t\t\tbreak;\n\t\tcase PCA9532_TYPE_GPIO:\n\t\t\tgpios++;\n\t\t\tbreak;\n\t\tcase PCA9532_TYPE_LED:\n\t\t\tif (pled->state == PCA9532_KEEP)\n\t\t\t\tled->state = pca9532_getled(led);\n\t\t\telse\n\t\t\t\tled->state = pled->state;\n\t\t\tled->name = pled->name;\n\t\t\tled->ldev.name = led->name;\n\t\t\tled->ldev.default_trigger = pled->default_trigger;\n\t\t\tled->ldev.brightness = LED_OFF;\n\t\t\tled->ldev.brightness_set_blocking =\n\t\t\t\t\t\tpca9532_set_brightness;\n\t\t\tled->ldev.blink_set = pca9532_set_blink;\n\t\t\terr = led_classdev_register(&client->dev, &led->ldev);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"couldn't register LED %s\\n\",\n\t\t\t\t\tled->name);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tpca9532_setled(led);\n\t\t\tbreak;\n\t\tcase PCA9532_TYPE_N2100_BEEP:\n\t\t\tBUG_ON(data->idev);\n\t\t\tled->state = PCA9532_PWM1;\n\t\t\tpca9532_setled(led);\n\t\t\tdata->idev = devm_input_allocate_device(&client->dev);\n\t\t\tif (data->idev == NULL) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tdata->idev->name = pled->name;\n\t\t\tdata->idev->phys = \"i2c/pca9532\";\n\t\t\tdata->idev->id.bustype = BUS_HOST;\n\t\t\tdata->idev->id.vendor = 0x001f;\n\t\t\tdata->idev->id.product = 0x0001;\n\t\t\tdata->idev->id.version = 0x0100;\n\t\t\tdata->idev->evbit[0] = BIT_MASK(EV_SND);\n\t\t\tdata->idev->sndbit[0] = BIT_MASK(SND_BELL) |\n\t\t\t\t\t\tBIT_MASK(SND_TONE);\n\t\t\tdata->idev->event = pca9532_event;\n\t\t\tinput_set_drvdata(data->idev, data);\n\t\t\tINIT_WORK(&data->work, pca9532_input_work);\n\t\t\terr = input_register_device(data->idev);\n\t\t\tif (err) {\n\t\t\t\tcancel_work_sync(&data->work);\n\t\t\t\tdata->idev = NULL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef CONFIG_LEDS_PCA9532_GPIO\n\tif (gpios) {\n\t\tdata->gpio.label = \"gpio-pca9532\";\n\t\tdata->gpio.direction_input = pca9532_gpio_direction_input;\n\t\tdata->gpio.direction_output = pca9532_gpio_direction_output;\n\t\tdata->gpio.set = pca9532_gpio_set_value;\n\t\tdata->gpio.get = pca9532_gpio_get_value;\n\t\tdata->gpio.request = pca9532_gpio_request_pin;\n\t\tdata->gpio.can_sleep = 1;\n\t\tdata->gpio.base = pdata->gpio_base;\n\t\tdata->gpio.ngpio = data->chip_info->num_leds;\n\t\tdata->gpio.parent = &client->dev;\n\t\tdata->gpio.owner = THIS_MODULE;\n\n\t\terr = gpiochip_add_data(&data->gpio, data);\n\t\tif (err) {\n\t\t\t \n\t\t\tdata->gpio.parent = NULL;\n\t\t\tdev_warn(&client->dev, \"could not add gpiochip\\n\");\n\t\t} else {\n\t\t\tdev_info(&client->dev, \"gpios %i...%i\\n\",\n\t\t\t\tdata->gpio.base, data->gpio.base +\n\t\t\t\tdata->gpio.ngpio - 1);\n\t\t}\n\t}\n#endif\n\n\treturn 0;\n\nexit:\n\tpca9532_destroy_devices(data, i);\n\treturn err;\n}\n\nstatic struct pca9532_platform_data *\npca9532_of_populate_pdata(struct device *dev, struct device_node *np)\n{\n\tstruct pca9532_platform_data *pdata;\n\tstruct device_node *child;\n\tint devid, maxleds;\n\tint i = 0;\n\tconst char *state;\n\n\tdevid = (int)(uintptr_t)of_device_get_match_data(dev);\n\tmaxleds = pca9532_chip_info_tbl[devid].num_leds;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->gpio_base = -1;\n\n\tof_property_read_u8_array(np, \"nxp,pwm\", &pdata->pwm[0],\n\t\t\t\t  ARRAY_SIZE(pdata->pwm));\n\tof_property_read_u8_array(np, \"nxp,psc\", &pdata->psc[0],\n\t\t\t\t  ARRAY_SIZE(pdata->psc));\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tif (of_property_read_string(child, \"label\",\n\t\t\t\t\t    &pdata->leds[i].name))\n\t\t\tpdata->leds[i].name = child->name;\n\t\tof_property_read_u32(child, \"type\", &pdata->leds[i].type);\n\t\tof_property_read_string(child, \"linux,default-trigger\",\n\t\t\t\t\t&pdata->leds[i].default_trigger);\n\t\tif (!of_property_read_string(child, \"default-state\", &state)) {\n\t\t\tif (!strcmp(state, \"on\"))\n\t\t\t\tpdata->leds[i].state = PCA9532_ON;\n\t\t\telse if (!strcmp(state, \"keep\"))\n\t\t\t\tpdata->leds[i].state = PCA9532_KEEP;\n\t\t}\n\t\tif (++i >= maxleds) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pdata;\n}\n\nstatic int pca9532_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tint devid;\n\tstruct pca9532_data *data = i2c_get_clientdata(client);\n\tstruct pca9532_platform_data *pca9532_pdata =\n\t\t\tdev_get_platdata(&client->dev);\n\tstruct device_node *np = dev_of_node(&client->dev);\n\n\tif (!pca9532_pdata) {\n\t\tif (np) {\n\t\t\tpca9532_pdata =\n\t\t\t\tpca9532_of_populate_pdata(&client->dev, np);\n\t\t\tif (IS_ERR(pca9532_pdata))\n\t\t\t\treturn PTR_ERR(pca9532_pdata);\n\t\t} else {\n\t\t\tdev_err(&client->dev, \"no platform data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdevid = (int)(uintptr_t)of_device_get_match_data(&client->dev);\n\t} else {\n\t\tdevid = id->driver_data;\n\t}\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\tI2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->chip_info = &pca9532_chip_info_tbl[devid];\n\n\tdev_info(&client->dev, \"setting platform data\\n\");\n\ti2c_set_clientdata(client, data);\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\treturn pca9532_configure(client, data, pca9532_pdata);\n}\n\nstatic void pca9532_remove(struct i2c_client *client)\n{\n\tstruct pca9532_data *data = i2c_get_clientdata(client);\n\n\tpca9532_destroy_devices(data, data->chip_info->num_leds);\n}\n\nmodule_i2c_driver(pca9532_driver);\n\nMODULE_AUTHOR(\"Riku Voipio\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"PCA 9532 LED dimmer\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}