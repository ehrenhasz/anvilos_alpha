{
  "module_name": "leds-tlc591xx.c",
  "hash_id": "fb8a49cf827d3c3589142e2958e1e1ce6d45cbbf67acae20b9c936b73c8ce62a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/leds/leds-tlc591xx.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define TLC591XX_MAX_LEDS\t16\n#define TLC591XX_MAX_BRIGHTNESS\t256\n\n#define TLC591XX_REG_MODE1\t0x00\n#define MODE1_RESPON_ADDR_MASK\t0xF0\n#define MODE1_NORMAL_MODE\t(0 << 4)\n#define MODE1_SPEED_MODE\t(1 << 4)\n\n#define TLC591XX_REG_MODE2\t0x01\n#define MODE2_DIM\t\t(0 << 5)\n#define MODE2_BLINK\t\t(1 << 5)\n#define MODE2_OCH_STOP\t\t(0 << 3)\n#define MODE2_OCH_ACK\t\t(1 << 3)\n\n#define TLC591XX_REG_PWM(x)\t(0x02 + (x))\n\n#define TLC591XX_REG_GRPPWM\t0x12\n#define TLC591XX_REG_GRPFREQ\t0x13\n\n \n#define LEDOUT_OFF\t\t0x0\t \n#define LEDOUT_ON\t\t0x1\t \n#define LEDOUT_DIM\t\t0x2\t \n#define LEDOUT_BLINK\t\t0x3\t \n#define LEDOUT_MASK\t\t0x3\n\n#define ldev_to_led(c)\t\tcontainer_of(c, struct tlc591xx_led, ldev)\n\nstruct tlc591xx_led {\n\tbool active;\n\tunsigned int led_no;\n\tstruct led_classdev ldev;\n\tstruct tlc591xx_priv *priv;\n};\n\nstruct tlc591xx_priv {\n\tstruct tlc591xx_led leds[TLC591XX_MAX_LEDS];\n\tstruct regmap *regmap;\n\tunsigned int reg_ledout_offset;\n};\n\nstruct tlc591xx {\n\tunsigned int max_leds;\n\tunsigned int reg_ledout_offset;\n};\n\nstatic const struct tlc591xx tlc59116 = {\n\t.max_leds = 16,\n\t.reg_ledout_offset = 0x14,\n};\n\nstatic const struct tlc591xx tlc59108 = {\n\t.max_leds = 8,\n\t.reg_ledout_offset = 0x0c,\n};\n\nstatic int\ntlc591xx_set_mode(struct regmap *regmap, u8 mode)\n{\n\tint err;\n\tu8 val;\n\n\terr = regmap_write(regmap, TLC591XX_REG_MODE1, MODE1_NORMAL_MODE);\n\tif (err)\n\t\treturn err;\n\n\tval = MODE2_OCH_STOP | mode;\n\n\treturn regmap_write(regmap, TLC591XX_REG_MODE2, val);\n}\n\nstatic int\ntlc591xx_set_ledout(struct tlc591xx_priv *priv, struct tlc591xx_led *led,\n\t\t    u8 val)\n{\n\tunsigned int i = (led->led_no % 4) * 2;\n\tunsigned int mask = LEDOUT_MASK << i;\n\tunsigned int addr = priv->reg_ledout_offset + (led->led_no >> 2);\n\n\tval = val << i;\n\n\treturn regmap_update_bits(priv->regmap, addr, mask, val);\n}\n\nstatic int\ntlc591xx_set_pwm(struct tlc591xx_priv *priv, struct tlc591xx_led *led,\n\t\t u8 brightness)\n{\n\tu8 pwm = TLC591XX_REG_PWM(led->led_no);\n\n\treturn regmap_write(priv->regmap, pwm, brightness);\n}\n\nstatic int\ntlc591xx_brightness_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness brightness)\n{\n\tstruct tlc591xx_led *led = ldev_to_led(led_cdev);\n\tstruct tlc591xx_priv *priv = led->priv;\n\tint err;\n\n\tswitch ((int)brightness) {\n\tcase 0:\n\t\terr = tlc591xx_set_ledout(priv, led, LEDOUT_OFF);\n\t\tbreak;\n\tcase TLC591XX_MAX_BRIGHTNESS:\n\t\terr = tlc591xx_set_ledout(priv, led, LEDOUT_ON);\n\t\tbreak;\n\tdefault:\n\t\terr = tlc591xx_set_ledout(priv, led, LEDOUT_DIM);\n\t\tif (!err)\n\t\t\terr = tlc591xx_set_pwm(priv, led, brightness);\n\t}\n\n\treturn err;\n}\n\nstatic const struct regmap_config tlc591xx_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x1e,\n};\n\nstatic const struct of_device_id of_tlc591xx_leds_match[] __maybe_unused = {\n\t{ .compatible = \"ti,tlc59116\",\n\t  .data = &tlc59116 },\n\t{ .compatible = \"ti,tlc59108\",\n\t  .data = &tlc59108 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_tlc591xx_leds_match);\n\nstatic int\ntlc591xx_probe(struct i2c_client *client)\n{\n\tstruct device_node *np, *child;\n\tstruct device *dev = &client->dev;\n\tconst struct tlc591xx *tlc591xx;\n\tstruct tlc591xx_priv *priv;\n\tint err, count, reg;\n\n\tnp = dev_of_node(dev);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\ttlc591xx = device_get_match_data(dev);\n\tif (!tlc591xx)\n\t\treturn -ENODEV;\n\n\tcount = of_get_available_child_count(np);\n\tif (!count || count > tlc591xx->max_leds)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &tlc591xx_regmap);\n\tif (IS_ERR(priv->regmap)) {\n\t\terr = PTR_ERR(priv->regmap);\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\", err);\n\t\treturn err;\n\t}\n\tpriv->reg_ledout_offset = tlc591xx->reg_ledout_offset;\n\n\ti2c_set_clientdata(client, priv);\n\n\terr = tlc591xx_set_mode(priv->regmap, MODE2_DIM);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tstruct tlc591xx_led *led;\n\t\tstruct led_init_data init_data = {};\n\n\t\tinit_data.fwnode = of_fwnode_handle(child);\n\n\t\terr = of_property_read_u32(child, \"reg\", &reg);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\t\tif (reg < 0 || reg >= tlc591xx->max_leds ||\n\t\t    priv->leds[reg].active) {\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tled = &priv->leds[reg];\n\n\t\tled->active = true;\n\t\tled->priv = priv;\n\t\tled->led_no = reg;\n\t\tled->ldev.brightness_set_blocking = tlc591xx_brightness_set;\n\t\tled->ldev.max_brightness = TLC591XX_MAX_BRIGHTNESS;\n\t\terr = devm_led_classdev_register_ext(dev, &led->ldev,\n\t\t\t\t\t\t     &init_data);\n\t\tif (err < 0) {\n\t\t\tof_node_put(child);\n\t\t\treturn dev_err_probe(dev, err,\n\t\t\t\t\t     \"couldn't register LED %s\\n\",\n\t\t\t\t\t     led->ldev.name);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct i2c_device_id tlc591xx_id[] = {\n\t{ \"tlc59116\" },\n\t{ \"tlc59108\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, tlc591xx_id);\n\nstatic struct i2c_driver tlc591xx_driver = {\n\t.driver = {\n\t\t.name = \"tlc591xx\",\n\t\t.of_match_table = of_match_ptr(of_tlc591xx_leds_match),\n\t},\n\t.probe = tlc591xx_probe,\n\t.id_table = tlc591xx_id,\n};\n\nmodule_i2c_driver(tlc591xx_driver);\n\nMODULE_AUTHOR(\"Andrew Lunn <andrew@lunn.ch>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TLC591XX LED driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}