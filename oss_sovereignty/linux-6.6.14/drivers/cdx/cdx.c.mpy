{
  "module_name": "cdx.c",
  "hash_id": "4c9851985f873aa1f779467b688199dd9fed92d772aaa7785bb2434d3d815702",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cdx/cdx.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/of_device.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/xarray.h>\n#include <linux/cdx/cdx_bus.h>\n#include <linux/iommu.h>\n#include <linux/dma-map-ops.h>\n#include \"cdx.h\"\n\n \n#define CDX_DEFAULT_DMA_MASK\t(~0ULL)\n#define MAX_CDX_CONTROLLERS 16\n\n \nstatic DEFINE_XARRAY_ALLOC(cdx_controllers);\n\n \nint cdx_dev_reset(struct device *dev)\n{\n\tstruct cdx_device *cdx_dev = to_cdx_device(dev);\n\tstruct cdx_controller *cdx = cdx_dev->cdx;\n\tstruct cdx_device_config dev_config = {0};\n\tstruct cdx_driver *cdx_drv;\n\tint ret;\n\n\tcdx_drv = to_cdx_driver(dev->driver);\n\t \n\tif (cdx_drv && cdx_drv->reset_prepare)\n\t\tcdx_drv->reset_prepare(cdx_dev);\n\n\tdev_config.type = CDX_DEV_RESET_CONF;\n\tret = cdx->ops->dev_configure(cdx, cdx_dev->bus_num,\n\t\t\t\t      cdx_dev->dev_num, &dev_config);\n\tif (ret)\n\t\tdev_err(dev, \"cdx device reset failed\\n\");\n\n\t \n\tif (cdx_drv && cdx_drv->reset_done)\n\t\tcdx_drv->reset_done(cdx_dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cdx_dev_reset);\n\n \nstatic int cdx_unregister_device(struct device *dev,\n\t\t\t\t void *data)\n{\n\tstruct cdx_device *cdx_dev = to_cdx_device(dev);\n\n\tkfree(cdx_dev->driver_override);\n\tcdx_dev->driver_override = NULL;\n\t \n\tdevice_del(&cdx_dev->dev);\n\tput_device(&cdx_dev->dev);\n\n\treturn 0;\n}\n\nstatic void cdx_unregister_devices(struct bus_type *bus)\n{\n\t \n\tbus_for_each_dev(bus, NULL, NULL, cdx_unregister_device);\n}\n\n \nstatic inline const struct cdx_device_id *\ncdx_match_one_device(const struct cdx_device_id *id,\n\t\t     const struct cdx_device *dev)\n{\n\t \n\tif ((id->vendor == CDX_ANY_ID || id->vendor == dev->vendor) &&\n\t    (id->device == CDX_ANY_ID || id->device == dev->device))\n\t\treturn id;\n\treturn NULL;\n}\n\n \nstatic inline const struct cdx_device_id *\ncdx_match_id(const struct cdx_device_id *ids, struct cdx_device *dev)\n{\n\tif (ids) {\n\t\twhile (ids->vendor || ids->device) {\n\t\t\tif (cdx_match_one_device(ids, dev))\n\t\t\t\treturn ids;\n\t\t\tids++;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic int cdx_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct cdx_device *cdx_dev = to_cdx_device(dev);\n\tstruct cdx_driver *cdx_drv = to_cdx_driver(drv);\n\tconst struct cdx_device_id *found_id = NULL;\n\tconst struct cdx_device_id *ids;\n\n\tids = cdx_drv->match_id_table;\n\n\t \n\tif (cdx_dev->driver_override && strcmp(cdx_dev->driver_override, drv->name))\n\t\treturn false;\n\n\tfound_id = cdx_match_id(ids, cdx_dev);\n\tif (!found_id)\n\t\treturn false;\n\n\tdo {\n\t\t \n\t\tif (!found_id->override_only)\n\t\t\treturn true;\n\t\tif (cdx_dev->driver_override)\n\t\t\treturn true;\n\n\t\tids = found_id + 1;\n\t\tfound_id = cdx_match_id(ids, cdx_dev);\n\t} while (found_id);\n\n\treturn false;\n}\n\nstatic int cdx_probe(struct device *dev)\n{\n\tstruct cdx_driver *cdx_drv = to_cdx_driver(dev->driver);\n\tstruct cdx_device *cdx_dev = to_cdx_device(dev);\n\tint error;\n\n\terror = cdx_drv->probe(cdx_dev);\n\tif (error) {\n\t\tdev_err_probe(dev, error, \"%s failed\\n\", __func__);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void cdx_remove(struct device *dev)\n{\n\tstruct cdx_driver *cdx_drv = to_cdx_driver(dev->driver);\n\tstruct cdx_device *cdx_dev = to_cdx_device(dev);\n\n\tif (cdx_drv && cdx_drv->remove)\n\t\tcdx_drv->remove(cdx_dev);\n}\n\nstatic void cdx_shutdown(struct device *dev)\n{\n\tstruct cdx_driver *cdx_drv = to_cdx_driver(dev->driver);\n\tstruct cdx_device *cdx_dev = to_cdx_device(dev);\n\n\tif (cdx_drv && cdx_drv->shutdown)\n\t\tcdx_drv->shutdown(cdx_dev);\n}\n\nstatic int cdx_dma_configure(struct device *dev)\n{\n\tstruct cdx_driver *cdx_drv = to_cdx_driver(dev->driver);\n\tstruct cdx_device *cdx_dev = to_cdx_device(dev);\n\tu32 input_id = cdx_dev->req_id;\n\tint ret;\n\n\tret = of_dma_configure_id(dev, dev->parent->of_node, 0, &input_id);\n\tif (ret && ret != -EPROBE_DEFER) {\n\t\tdev_err(dev, \"of_dma_configure_id() failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!ret && !cdx_drv->driver_managed_dma) {\n\t\tret = iommu_device_use_default_domain(dev);\n\t\tif (ret)\n\t\t\tarch_teardown_dma_ops(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void cdx_dma_cleanup(struct device *dev)\n{\n\tstruct cdx_driver *cdx_drv = to_cdx_driver(dev->driver);\n\n\tif (!cdx_drv->driver_managed_dma)\n\t\tiommu_device_unuse_default_domain(dev);\n}\n\n \n#define cdx_config_attr(field, format_string)\t\\\nstatic ssize_t\t\\\nfield##_show(struct device *dev, struct device_attribute *attr, char *buf)\t\\\n{\t\\\n\tstruct cdx_device *cdx_dev = to_cdx_device(dev);\t\\\n\treturn sysfs_emit(buf, format_string, cdx_dev->field);\t\\\n}\t\\\nstatic DEVICE_ATTR_RO(field)\n\ncdx_config_attr(vendor, \"0x%04x\\n\");\ncdx_config_attr(device, \"0x%04x\\n\");\n\nstatic ssize_t remove_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tbool val;\n\n\tif (kstrtobool(buf, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tif (device_remove_file_self(dev, attr)) {\n\t\tint ret;\n\n\t\tret = cdx_unregister_device(dev, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(remove);\n\nstatic ssize_t reset_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tbool val;\n\tint ret;\n\n\tif (kstrtobool(buf, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tret = cdx_dev_reset(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(reset);\n\nstatic ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct cdx_device *cdx_dev = to_cdx_device(dev);\n\tint ret;\n\n\tif (WARN_ON(dev->bus != &cdx_bus_type))\n\t\treturn -EINVAL;\n\n\tret = driver_set_override(dev, &cdx_dev->driver_override, buf, count);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct cdx_device *cdx_dev = to_cdx_device(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", cdx_dev->driver_override);\n}\nstatic DEVICE_ATTR_RW(driver_override);\n\nstatic struct attribute *cdx_dev_attrs[] = {\n\t&dev_attr_remove.attr,\n\t&dev_attr_reset.attr,\n\t&dev_attr_vendor.attr,\n\t&dev_attr_device.attr,\n\t&dev_attr_driver_override.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(cdx_dev);\n\nstatic ssize_t rescan_store(const struct bus_type *bus,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct cdx_controller *cdx;\n\tunsigned long index;\n\tbool val;\n\n\tif (kstrtobool(buf, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\t \n\tcdx_unregister_devices(&cdx_bus_type);\n\n\t \n\txa_for_each(&cdx_controllers, index, cdx) {\n\t\tint ret;\n\n\t\tret = cdx->ops->scan(cdx);\n\t\tif (ret)\n\t\t\tdev_err(cdx->dev, \"cdx bus scanning failed\\n\");\n\t}\n\n\treturn count;\n}\nstatic BUS_ATTR_WO(rescan);\n\nstatic struct attribute *cdx_bus_attrs[] = {\n\t&bus_attr_rescan.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(cdx_bus);\n\nstruct bus_type cdx_bus_type = {\n\t.name\t\t= \"cdx\",\n\t.match\t\t= cdx_bus_match,\n\t.probe\t\t= cdx_probe,\n\t.remove\t\t= cdx_remove,\n\t.shutdown\t= cdx_shutdown,\n\t.dma_configure\t= cdx_dma_configure,\n\t.dma_cleanup\t= cdx_dma_cleanup,\n\t.bus_groups\t= cdx_bus_groups,\n\t.dev_groups\t= cdx_dev_groups,\n};\nEXPORT_SYMBOL_GPL(cdx_bus_type);\n\nint __cdx_driver_register(struct cdx_driver *cdx_driver,\n\t\t\t  struct module *owner)\n{\n\tint error;\n\n\tcdx_driver->driver.owner = owner;\n\tcdx_driver->driver.bus = &cdx_bus_type;\n\n\terror = driver_register(&cdx_driver->driver);\n\tif (error) {\n\t\tpr_err(\"driver_register() failed for %s: %d\\n\",\n\t\t       cdx_driver->driver.name, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__cdx_driver_register);\n\nvoid cdx_driver_unregister(struct cdx_driver *cdx_driver)\n{\n\tdriver_unregister(&cdx_driver->driver);\n}\nEXPORT_SYMBOL_GPL(cdx_driver_unregister);\n\nstatic void cdx_device_release(struct device *dev)\n{\n\tstruct cdx_device *cdx_dev = to_cdx_device(dev);\n\n\tkfree(cdx_dev);\n}\n\nint cdx_device_add(struct cdx_dev_params *dev_params)\n{\n\tstruct cdx_controller *cdx = dev_params->cdx;\n\tstruct device *parent = cdx->dev;\n\tstruct cdx_device *cdx_dev;\n\tint ret;\n\n\tcdx_dev = kzalloc(sizeof(*cdx_dev), GFP_KERNEL);\n\tif (!cdx_dev)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(cdx_dev->res, dev_params->res, sizeof(struct resource) *\n\t\tdev_params->res_count);\n\tcdx_dev->res_count = dev_params->res_count;\n\n\t \n\tcdx_dev->req_id = dev_params->req_id;\n\tcdx_dev->vendor = dev_params->vendor;\n\tcdx_dev->device = dev_params->device;\n\tcdx_dev->bus_num = dev_params->bus_num;\n\tcdx_dev->dev_num = dev_params->dev_num;\n\tcdx_dev->cdx = dev_params->cdx;\n\tcdx_dev->dma_mask = CDX_DEFAULT_DMA_MASK;\n\n\t \n\tdevice_initialize(&cdx_dev->dev);\n\tcdx_dev->dev.parent = parent;\n\tcdx_dev->dev.bus = &cdx_bus_type;\n\tcdx_dev->dev.dma_mask = &cdx_dev->dma_mask;\n\tcdx_dev->dev.release = cdx_device_release;\n\n\t \n\tdev_set_name(&cdx_dev->dev, \"cdx-%02x:%02x\",\n\t\t     ((cdx->id << CDX_CONTROLLER_ID_SHIFT) | (cdx_dev->bus_num & CDX_BUS_NUM_MASK)),\n\t\t     cdx_dev->dev_num);\n\n\tret = device_add(&cdx_dev->dev);\n\tif (ret) {\n\t\tdev_err(&cdx_dev->dev,\n\t\t\t\"cdx device add failed: %d\", ret);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\t \n\tput_device(&cdx_dev->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cdx_device_add);\n\nint cdx_register_controller(struct cdx_controller *cdx)\n{\n\tint ret;\n\n\tret = xa_alloc(&cdx_controllers, &cdx->id, cdx,\n\t\t       XA_LIMIT(0, MAX_CDX_CONTROLLERS - 1), GFP_KERNEL);\n\tif (ret) {\n\t\tdev_err(cdx->dev,\n\t\t\t\"No free index available. Maximum controllers already registered\\n\");\n\t\tcdx->id = (u8)MAX_CDX_CONTROLLERS;\n\t\treturn ret;\n\t}\n\n\t \n\tcdx->ops->scan(cdx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cdx_register_controller);\n\nvoid cdx_unregister_controller(struct cdx_controller *cdx)\n{\n\tif (cdx->id >= MAX_CDX_CONTROLLERS)\n\t\treturn;\n\n\tdevice_for_each_child(cdx->dev, NULL, cdx_unregister_device);\n\txa_erase(&cdx_controllers, cdx->id);\n}\nEXPORT_SYMBOL_GPL(cdx_unregister_controller);\n\nstatic int __init cdx_bus_init(void)\n{\n\treturn bus_register(&cdx_bus_type);\n}\npostcore_initcall(cdx_bus_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}