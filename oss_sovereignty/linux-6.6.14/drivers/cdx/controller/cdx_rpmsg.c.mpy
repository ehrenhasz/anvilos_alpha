{
  "module_name": "cdx_rpmsg.c",
  "hash_id": "fb978c3081303686d73a3510b22fd39bbf43e1c4b8a8c713644a4a56c980b67b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cdx/controller/cdx_rpmsg.c",
  "human_readable_source": "\n \n\n#include <linux/rpmsg.h>\n#include <linux/remoteproc.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/cdx/cdx_bus.h>\n#include <linux/module.h>\n\n#include \"../cdx.h\"\n#include \"cdx_controller.h\"\n#include \"mcdi_functions.h\"\n#include \"mcdi.h\"\n\nstatic struct rpmsg_device_id cdx_rpmsg_id_table[] = {\n\t{ .name = \"mcdi_ipc\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(rpmsg, cdx_rpmsg_id_table);\n\nint cdx_rpmsg_send(struct cdx_mcdi *cdx_mcdi,\n\t\t   const struct cdx_dword *hdr, size_t hdr_len,\n\t\t   const struct cdx_dword *sdu, size_t sdu_len)\n{\n\tunsigned char *send_buf;\n\tint ret;\n\n\tsend_buf = kzalloc(hdr_len + sdu_len, GFP_KERNEL);\n\tif (!send_buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(send_buf, hdr, hdr_len);\n\tmemcpy(send_buf + hdr_len, sdu, sdu_len);\n\n\tret = rpmsg_send(cdx_mcdi->ept, send_buf, hdr_len + sdu_len);\n\tkfree(send_buf);\n\n\treturn ret;\n}\n\nstatic int cdx_attach_to_rproc(struct platform_device *pdev)\n{\n\tstruct device_node *r5_core_node;\n\tstruct cdx_controller *cdx_c;\n\tstruct cdx_mcdi *cdx_mcdi;\n\tstruct device *dev;\n\tstruct rproc *rp;\n\tint ret;\n\n\tdev = &pdev->dev;\n\tcdx_c = platform_get_drvdata(pdev);\n\tcdx_mcdi = cdx_c->priv;\n\n\tr5_core_node = of_parse_phandle(dev->of_node, \"xlnx,rproc\", 0);\n\tif (!r5_core_node) {\n\t\tdev_err(&pdev->dev, \"xlnx,rproc: invalid phandle\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trp = rproc_get_by_phandle(r5_core_node->phandle);\n\tif (!rp) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto pdev_err;\n\t}\n\n\t \n\tret = rproc_boot(rp);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to attach to remote processor\\n\");\n\t\trproc_put(rp);\n\t\tgoto pdev_err;\n\t}\n\n\tcdx_mcdi->r5_rproc = rp;\npdev_err:\n\tof_node_put(r5_core_node);\n\treturn ret;\n}\n\nstatic void cdx_detach_to_r5(struct platform_device *pdev)\n{\n\tstruct cdx_controller *cdx_c;\n\tstruct cdx_mcdi *cdx_mcdi;\n\n\tcdx_c = platform_get_drvdata(pdev);\n\tcdx_mcdi = cdx_c->priv;\n\n\trproc_detach(cdx_mcdi->r5_rproc);\n\trproc_put(cdx_mcdi->r5_rproc);\n}\n\nstatic int cdx_rpmsg_cb(struct rpmsg_device *rpdev, void *data,\n\t\t\tint len, void *priv, u32 src)\n{\n\tstruct cdx_controller *cdx_c = dev_get_drvdata(&rpdev->dev);\n\tstruct cdx_mcdi *cdx_mcdi = cdx_c->priv;\n\n\tif (len > MCDI_BUF_LEN)\n\t\treturn -EINVAL;\n\n\tcdx_mcdi_process_cmd(cdx_mcdi, (struct cdx_dword *)data, len);\n\n\treturn 0;\n}\n\nstatic void cdx_rpmsg_post_probe_work(struct work_struct *work)\n{\n\tstruct cdx_controller *cdx_c;\n\tstruct cdx_mcdi *cdx_mcdi;\n\n\tcdx_mcdi = container_of(work, struct cdx_mcdi, work);\n\tcdx_c = dev_get_drvdata(&cdx_mcdi->rpdev->dev);\n\tcdx_rpmsg_post_probe(cdx_c);\n}\n\nstatic int cdx_rpmsg_probe(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_channel_info chinfo = {0};\n\tstruct cdx_controller *cdx_c;\n\tstruct cdx_mcdi *cdx_mcdi;\n\n\tcdx_c = (struct cdx_controller *)cdx_rpmsg_id_table[0].driver_data;\n\tcdx_mcdi = cdx_c->priv;\n\n\tchinfo.src = RPMSG_ADDR_ANY;\n\tchinfo.dst = rpdev->dst;\n\tstrscpy(chinfo.name, cdx_rpmsg_id_table[0].name,\n\t\tstrlen(cdx_rpmsg_id_table[0].name));\n\n\tcdx_mcdi->ept = rpmsg_create_ept(rpdev, cdx_rpmsg_cb, NULL, chinfo);\n\tif (!cdx_mcdi->ept) {\n\t\tdev_err_probe(&rpdev->dev, -ENXIO,\n\t\t\t      \"Failed to create ept for channel %s\\n\",\n\t\t\t      chinfo.name);\n\t\treturn -EINVAL;\n\t}\n\n\tcdx_mcdi->rpdev = rpdev;\n\tdev_set_drvdata(&rpdev->dev, cdx_c);\n\n\tschedule_work(&cdx_mcdi->work);\n\treturn 0;\n}\n\nstatic void cdx_rpmsg_remove(struct rpmsg_device *rpdev)\n{\n\tstruct cdx_controller *cdx_c = dev_get_drvdata(&rpdev->dev);\n\tstruct cdx_mcdi *cdx_mcdi = cdx_c->priv;\n\n\tflush_work(&cdx_mcdi->work);\n\tcdx_rpmsg_pre_remove(cdx_c);\n\n\trpmsg_destroy_ept(cdx_mcdi->ept);\n\tdev_set_drvdata(&rpdev->dev, NULL);\n}\n\nstatic struct rpmsg_driver cdx_rpmsg_driver = {\n\t.drv.name = KBUILD_MODNAME,\n\t.id_table = cdx_rpmsg_id_table,\n\t.probe = cdx_rpmsg_probe,\n\t.remove = cdx_rpmsg_remove,\n\t.callback = cdx_rpmsg_cb,\n};\n\nint cdx_setup_rpmsg(struct platform_device *pdev)\n{\n\tstruct cdx_controller *cdx_c;\n\tstruct cdx_mcdi *cdx_mcdi;\n\tint ret;\n\n\t \n\tret = cdx_attach_to_rproc(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tcdx_c = platform_get_drvdata(pdev);\n\tcdx_mcdi = cdx_c->priv;\n\n\t \n\tcdx_rpmsg_id_table[0].driver_data = (kernel_ulong_t)cdx_c;\n\n\tINIT_WORK(&cdx_mcdi->work, cdx_rpmsg_post_probe_work);\n\tret = register_rpmsg_driver(&cdx_rpmsg_driver);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register cdx RPMsg driver: %d\\n\", ret);\n\t\tcdx_detach_to_r5(pdev);\n\t}\n\n\treturn ret;\n}\n\nvoid cdx_destroy_rpmsg(struct platform_device *pdev)\n{\n\tunregister_rpmsg_driver(&cdx_rpmsg_driver);\n\n\tcdx_detach_to_r5(pdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}