{
  "module_name": "mcdi.c",
  "hash_id": "8bc367b882d7261c98e36c489416a5d04ef72776bd78c3c0d0870d6724411416",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cdx/controller/mcdi.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/spinlock.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/rwsem.h>\n#include <linux/vmalloc.h>\n#include <net/netevent.h>\n#include <linux/log2.h>\n#include <linux/net_tstamp.h>\n#include <linux/wait.h>\n\n#include \"bitfield.h\"\n#include \"mcdi.h\"\n\nstruct cdx_mcdi_copy_buffer {\n\tstruct cdx_dword buffer[DIV_ROUND_UP(MCDI_CTL_SDU_LEN_MAX, 4)];\n};\n\nstatic void cdx_mcdi_cancel_cmd(struct cdx_mcdi *cdx, struct cdx_mcdi_cmd *cmd);\nstatic void cdx_mcdi_wait_for_cleanup(struct cdx_mcdi *cdx);\nstatic int cdx_mcdi_rpc_async_internal(struct cdx_mcdi *cdx,\n\t\t\t\t       struct cdx_mcdi_cmd *cmd,\n\t\t\t\t       unsigned int *handle);\nstatic void cdx_mcdi_start_or_queue(struct cdx_mcdi_iface *mcdi,\n\t\t\t\t    bool allow_retry);\nstatic void cdx_mcdi_cmd_start_or_queue(struct cdx_mcdi_iface *mcdi,\n\t\t\t\t\tstruct cdx_mcdi_cmd *cmd);\nstatic bool cdx_mcdi_complete_cmd(struct cdx_mcdi_iface *mcdi,\n\t\t\t\t  struct cdx_mcdi_cmd *cmd,\n\t\t\t\t  struct cdx_dword *outbuf,\n\t\t\t\t  int len,\n\t\t\t\t  struct list_head *cleanup_list);\nstatic void cdx_mcdi_timeout_cmd(struct cdx_mcdi_iface *mcdi,\n\t\t\t\t struct cdx_mcdi_cmd *cmd,\n\t\t\t\t struct list_head *cleanup_list);\nstatic void cdx_mcdi_cmd_work(struct work_struct *context);\nstatic void cdx_mcdi_mode_fail(struct cdx_mcdi *cdx, struct list_head *cleanup_list);\nstatic void _cdx_mcdi_display_error(struct cdx_mcdi *cdx, unsigned int cmd,\n\t\t\t\t    size_t inlen, int raw, int arg, int err_no);\n\nstatic bool cdx_cmd_cancelled(struct cdx_mcdi_cmd *cmd)\n{\n\treturn cmd->state == MCDI_STATE_RUNNING_CANCELLED;\n}\n\nstatic void cdx_mcdi_cmd_release(struct kref *ref)\n{\n\tkfree(container_of(ref, struct cdx_mcdi_cmd, ref));\n}\n\nstatic unsigned int cdx_mcdi_cmd_handle(struct cdx_mcdi_cmd *cmd)\n{\n\treturn cmd->handle;\n}\n\nstatic void _cdx_mcdi_remove_cmd(struct cdx_mcdi_iface *mcdi,\n\t\t\t\t struct cdx_mcdi_cmd *cmd,\n\t\t\t\t struct list_head *cleanup_list)\n{\n\t \n\tif (cdx_cmd_cancelled(cmd))\n\t\treturn;\n\n\tif (cmd->completer) {\n\t\tlist_add_tail(&cmd->cleanup_list, cleanup_list);\n\t\t++mcdi->outstanding_cleanups;\n\t\tkref_get(&cmd->ref);\n\t}\n}\n\nstatic void cdx_mcdi_remove_cmd(struct cdx_mcdi_iface *mcdi,\n\t\t\t\tstruct cdx_mcdi_cmd *cmd,\n\t\t\t\tstruct list_head *cleanup_list)\n{\n\tlist_del(&cmd->list);\n\t_cdx_mcdi_remove_cmd(mcdi, cmd, cleanup_list);\n\tcmd->state = MCDI_STATE_FINISHED;\n\tkref_put(&cmd->ref, cdx_mcdi_cmd_release);\n\tif (list_empty(&mcdi->cmd_list))\n\t\twake_up(&mcdi->cmd_complete_wq);\n}\n\nstatic unsigned long cdx_mcdi_rpc_timeout(struct cdx_mcdi *cdx, unsigned int cmd)\n{\n\tif (!cdx->mcdi_ops->mcdi_rpc_timeout)\n\t\treturn MCDI_RPC_TIMEOUT;\n\telse\n\t\treturn cdx->mcdi_ops->mcdi_rpc_timeout(cdx, cmd);\n}\n\nint cdx_mcdi_init(struct cdx_mcdi *cdx)\n{\n\tstruct cdx_mcdi_iface *mcdi;\n\tint rc = -ENOMEM;\n\n\tcdx->mcdi = kzalloc(sizeof(*cdx->mcdi), GFP_KERNEL);\n\tif (!cdx->mcdi)\n\t\tgoto fail;\n\n\tmcdi = cdx_mcdi_if(cdx);\n\tmcdi->cdx = cdx;\n\n\tmcdi->workqueue = alloc_ordered_workqueue(\"mcdi_wq\", 0);\n\tif (!mcdi->workqueue)\n\t\tgoto fail2;\n\tmutex_init(&mcdi->iface_lock);\n\tmcdi->mode = MCDI_MODE_EVENTS;\n\tINIT_LIST_HEAD(&mcdi->cmd_list);\n\tinit_waitqueue_head(&mcdi->cmd_complete_wq);\n\n\tmcdi->new_epoch = true;\n\n\treturn 0;\nfail2:\n\tkfree(cdx->mcdi);\n\tcdx->mcdi = NULL;\nfail:\n\treturn rc;\n}\n\nvoid cdx_mcdi_finish(struct cdx_mcdi *cdx)\n{\n\tstruct cdx_mcdi_iface *mcdi;\n\n\tmcdi = cdx_mcdi_if(cdx);\n\tif (!mcdi)\n\t\treturn;\n\n\tcdx_mcdi_wait_for_cleanup(cdx);\n\n\tdestroy_workqueue(mcdi->workqueue);\n\tkfree(cdx->mcdi);\n\tcdx->mcdi = NULL;\n}\n\nstatic bool cdx_mcdi_flushed(struct cdx_mcdi_iface *mcdi, bool ignore_cleanups)\n{\n\tbool flushed;\n\n\tmutex_lock(&mcdi->iface_lock);\n\tflushed = list_empty(&mcdi->cmd_list) &&\n\t\t  (ignore_cleanups || !mcdi->outstanding_cleanups);\n\tmutex_unlock(&mcdi->iface_lock);\n\treturn flushed;\n}\n\n \nstatic void cdx_mcdi_wait_for_cleanup(struct cdx_mcdi *cdx)\n{\n\tstruct cdx_mcdi_iface *mcdi = cdx_mcdi_if(cdx);\n\n\tif (!mcdi)\n\t\treturn;\n\n\twait_event(mcdi->cmd_complete_wq,\n\t\t   cdx_mcdi_flushed(mcdi, false));\n}\n\nint cdx_mcdi_wait_for_quiescence(struct cdx_mcdi *cdx,\n\t\t\t\t unsigned int timeout_jiffies)\n{\n\tstruct cdx_mcdi_iface *mcdi = cdx_mcdi_if(cdx);\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint rc = 0;\n\n\tif (!mcdi)\n\t\treturn -EINVAL;\n\n\tflush_workqueue(mcdi->workqueue);\n\n\tadd_wait_queue(&mcdi->cmd_complete_wq, &wait);\n\n\twhile (!cdx_mcdi_flushed(mcdi, true)) {\n\t\trc = wait_woken(&wait, TASK_IDLE, timeout_jiffies);\n\t\tif (rc)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tremove_wait_queue(&mcdi->cmd_complete_wq, &wait);\n\n\tif (rc > 0)\n\t\trc = 0;\n\telse if (rc == 0)\n\t\trc = -ETIMEDOUT;\n\n\treturn rc;\n}\n\nstatic u8 cdx_mcdi_payload_csum(const struct cdx_dword *hdr, size_t hdr_len,\n\t\t\t\tconst struct cdx_dword *sdu, size_t sdu_len)\n{\n\tu8 *p = (u8 *)hdr;\n\tu8 csum = 0;\n\tint i;\n\n\tfor (i = 0; i < hdr_len; i++)\n\t\tcsum += p[i];\n\n\tp = (u8 *)sdu;\n\tfor (i = 0; i < sdu_len; i++)\n\t\tcsum += p[i];\n\n\treturn ~csum & 0xff;\n}\n\nstatic void cdx_mcdi_send_request(struct cdx_mcdi *cdx,\n\t\t\t\t  struct cdx_mcdi_cmd *cmd)\n{\n\tstruct cdx_mcdi_iface *mcdi = cdx_mcdi_if(cdx);\n\tconst struct cdx_dword *inbuf = cmd->inbuf;\n\tsize_t inlen = cmd->inlen;\n\tstruct cdx_dword hdr[2];\n\tsize_t hdr_len;\n\tbool not_epoch;\n\tu32 xflags;\n\n\tif (!mcdi)\n\t\treturn;\n\n\tmcdi->prev_seq = cmd->seq;\n\tmcdi->seq_held_by[cmd->seq] = cmd;\n\tmcdi->db_held_by = cmd;\n\tcmd->started = jiffies;\n\n\tnot_epoch = !mcdi->new_epoch;\n\txflags = 0;\n\n\t \n\tWARN_ON(inlen > MCDI_CTL_SDU_LEN_MAX_V2);\n\tCDX_POPULATE_DWORD_7(hdr[0],\n\t\t\t     MCDI_HEADER_RESPONSE, 0,\n\t\t\t     MCDI_HEADER_RESYNC, 1,\n\t\t\t     MCDI_HEADER_CODE, MC_CMD_V2_EXTN,\n\t\t\t     MCDI_HEADER_DATALEN, 0,\n\t\t\t     MCDI_HEADER_SEQ, cmd->seq,\n\t\t\t     MCDI_HEADER_XFLAGS, xflags,\n\t\t\t     MCDI_HEADER_NOT_EPOCH, not_epoch);\n\tCDX_POPULATE_DWORD_3(hdr[1],\n\t\t\t     MC_CMD_V2_EXTN_IN_EXTENDED_CMD, cmd->cmd,\n\t\t\t     MC_CMD_V2_EXTN_IN_ACTUAL_LEN, inlen,\n\t\t\t     MC_CMD_V2_EXTN_IN_MESSAGE_TYPE,\n\t\t\t     MC_CMD_V2_EXTN_IN_MCDI_MESSAGE_TYPE_PLATFORM);\n\thdr_len = 8;\n\n\thdr[0].cdx_u32 |= (__force __le32)(cdx_mcdi_payload_csum(hdr, hdr_len, inbuf, inlen) <<\n\t\t\t MCDI_HEADER_XFLAGS_LBN);\n\n\tprint_hex_dump_debug(\"MCDI REQ HEADER: \", DUMP_PREFIX_NONE, 32, 4, hdr, hdr_len, false);\n\tprint_hex_dump_debug(\"MCDI REQ PAYLOAD: \", DUMP_PREFIX_NONE, 32, 4, inbuf, inlen, false);\n\n\tcdx->mcdi_ops->mcdi_request(cdx, hdr, hdr_len, inbuf, inlen);\n\n\tmcdi->new_epoch = false;\n}\n\nstatic int cdx_mcdi_errno(struct cdx_mcdi *cdx, unsigned int mcdi_err)\n{\n\tswitch (mcdi_err) {\n\tcase 0:\n\tcase MC_CMD_ERR_QUEUE_FULL:\n\t\treturn mcdi_err;\n\tcase MC_CMD_ERR_EPERM:\n\t\treturn -EPERM;\n\tcase MC_CMD_ERR_ENOENT:\n\t\treturn -ENOENT;\n\tcase MC_CMD_ERR_EINTR:\n\t\treturn -EINTR;\n\tcase MC_CMD_ERR_EAGAIN:\n\t\treturn -EAGAIN;\n\tcase MC_CMD_ERR_EACCES:\n\t\treturn -EACCES;\n\tcase MC_CMD_ERR_EBUSY:\n\t\treturn -EBUSY;\n\tcase MC_CMD_ERR_EINVAL:\n\t\treturn -EINVAL;\n\tcase MC_CMD_ERR_ERANGE:\n\t\treturn -ERANGE;\n\tcase MC_CMD_ERR_EDEADLK:\n\t\treturn -EDEADLK;\n\tcase MC_CMD_ERR_ENOSYS:\n\t\treturn -EOPNOTSUPP;\n\tcase MC_CMD_ERR_ETIME:\n\t\treturn -ETIME;\n\tcase MC_CMD_ERR_EALREADY:\n\t\treturn -EALREADY;\n\tcase MC_CMD_ERR_ENOSPC:\n\t\treturn -ENOSPC;\n\tcase MC_CMD_ERR_ENOMEM:\n\t\treturn -ENOMEM;\n\tcase MC_CMD_ERR_ENOTSUP:\n\t\treturn -EOPNOTSUPP;\n\tcase MC_CMD_ERR_ALLOC_FAIL:\n\t\treturn -ENOBUFS;\n\tcase MC_CMD_ERR_MAC_EXIST:\n\t\treturn -EADDRINUSE;\n\tcase MC_CMD_ERR_NO_EVB_PORT:\n\t\treturn -EAGAIN;\n\tdefault:\n\t\treturn -EPROTO;\n\t}\n}\n\nstatic void cdx_mcdi_process_cleanup_list(struct cdx_mcdi *cdx,\n\t\t\t\t\t  struct list_head *cleanup_list)\n{\n\tstruct cdx_mcdi_iface *mcdi = cdx_mcdi_if(cdx);\n\tunsigned int cleanups = 0;\n\n\tif (!mcdi)\n\t\treturn;\n\n\twhile (!list_empty(cleanup_list)) {\n\t\tstruct cdx_mcdi_cmd *cmd =\n\t\t\tlist_first_entry(cleanup_list,\n\t\t\t\t\t struct cdx_mcdi_cmd, cleanup_list);\n\t\tcmd->completer(cdx, cmd->cookie, cmd->rc,\n\t\t\t       cmd->outbuf, cmd->outlen);\n\t\tlist_del(&cmd->cleanup_list);\n\t\tkref_put(&cmd->ref, cdx_mcdi_cmd_release);\n\t\t++cleanups;\n\t}\n\n\tif (cleanups) {\n\t\tbool all_done;\n\n\t\tmutex_lock(&mcdi->iface_lock);\n\t\tCDX_WARN_ON_PARANOID(cleanups > mcdi->outstanding_cleanups);\n\t\tall_done = (mcdi->outstanding_cleanups -= cleanups) == 0;\n\t\tmutex_unlock(&mcdi->iface_lock);\n\t\tif (all_done)\n\t\t\twake_up(&mcdi->cmd_complete_wq);\n\t}\n}\n\nstatic void _cdx_mcdi_cancel_cmd(struct cdx_mcdi_iface *mcdi,\n\t\t\t\t unsigned int handle,\n\t\t\t\t struct list_head *cleanup_list)\n{\n\tstruct cdx_mcdi_cmd *cmd;\n\n\tlist_for_each_entry(cmd, &mcdi->cmd_list, list)\n\t\tif (cdx_mcdi_cmd_handle(cmd) == handle) {\n\t\t\tswitch (cmd->state) {\n\t\t\tcase MCDI_STATE_QUEUED:\n\t\t\tcase MCDI_STATE_RETRY:\n\t\t\t\tpr_debug(\"command %#x inlen %zu cancelled in queue\\n\",\n\t\t\t\t\t cmd->cmd, cmd->inlen);\n\t\t\t\t \n\t\t\t\tcmd->rc = -EPIPE;\n\t\t\t\tcdx_mcdi_remove_cmd(mcdi, cmd, cleanup_list);\n\t\t\t\tbreak;\n\t\t\tcase MCDI_STATE_RUNNING:\n\t\t\tcase MCDI_STATE_RUNNING_CANCELLED:\n\t\t\tcase MCDI_STATE_FINISHED:\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n}\n\nstatic void cdx_mcdi_cancel_cmd(struct cdx_mcdi *cdx, struct cdx_mcdi_cmd *cmd)\n{\n\tstruct cdx_mcdi_iface *mcdi = cdx_mcdi_if(cdx);\n\tLIST_HEAD(cleanup_list);\n\n\tif (!mcdi)\n\t\treturn;\n\n\tmutex_lock(&mcdi->iface_lock);\n\tcdx_mcdi_timeout_cmd(mcdi, cmd, &cleanup_list);\n\tmutex_unlock(&mcdi->iface_lock);\n\tcdx_mcdi_process_cleanup_list(cdx, &cleanup_list);\n}\n\nstruct cdx_mcdi_blocking_data {\n\tstruct kref ref;\n\tbool done;\n\twait_queue_head_t wq;\n\tint rc;\n\tstruct cdx_dword *outbuf;\n\tsize_t outlen;\n\tsize_t outlen_actual;\n};\n\nstatic void cdx_mcdi_blocking_data_release(struct kref *ref)\n{\n\tkfree(container_of(ref, struct cdx_mcdi_blocking_data, ref));\n}\n\nstatic void cdx_mcdi_rpc_completer(struct cdx_mcdi *cdx, unsigned long cookie,\n\t\t\t\t   int rc, struct cdx_dword *outbuf,\n\t\t\t\t   size_t outlen_actual)\n{\n\tstruct cdx_mcdi_blocking_data *wait_data =\n\t\t(struct cdx_mcdi_blocking_data *)cookie;\n\n\twait_data->rc = rc;\n\tmemcpy(wait_data->outbuf, outbuf,\n\t       min(outlen_actual, wait_data->outlen));\n\twait_data->outlen_actual = outlen_actual;\n\t \n\tsmp_wmb();\n\twait_data->done = true;\n\twake_up(&wait_data->wq);\n\tkref_put(&wait_data->ref, cdx_mcdi_blocking_data_release);\n}\n\nstatic int cdx_mcdi_rpc_sync(struct cdx_mcdi *cdx, unsigned int cmd,\n\t\t\t     const struct cdx_dword *inbuf, size_t inlen,\n\t\t\t     struct cdx_dword *outbuf, size_t outlen,\n\t\t\t     size_t *outlen_actual, bool quiet)\n{\n\tstruct cdx_mcdi_blocking_data *wait_data;\n\tstruct cdx_mcdi_cmd *cmd_item;\n\tunsigned int handle;\n\tint rc;\n\n\tif (outlen_actual)\n\t\t*outlen_actual = 0;\n\n\twait_data = kmalloc(sizeof(*wait_data), GFP_KERNEL);\n\tif (!wait_data)\n\t\treturn -ENOMEM;\n\n\tcmd_item = kmalloc(sizeof(*cmd_item), GFP_KERNEL);\n\tif (!cmd_item) {\n\t\tkfree(wait_data);\n\t\treturn -ENOMEM;\n\t}\n\n\tkref_init(&wait_data->ref);\n\twait_data->done = false;\n\tinit_waitqueue_head(&wait_data->wq);\n\twait_data->outbuf = outbuf;\n\twait_data->outlen = outlen;\n\n\tkref_init(&cmd_item->ref);\n\tcmd_item->quiet = quiet;\n\tcmd_item->cookie = (unsigned long)wait_data;\n\tcmd_item->completer = &cdx_mcdi_rpc_completer;\n\tcmd_item->cmd = cmd;\n\tcmd_item->inlen = inlen;\n\tcmd_item->inbuf = inbuf;\n\n\t \n\tkref_get(&wait_data->ref);\n\trc = cdx_mcdi_rpc_async_internal(cdx, cmd_item, &handle);\n\tif (rc) {\n\t\tkref_put(&wait_data->ref, cdx_mcdi_blocking_data_release);\n\t\tgoto out;\n\t}\n\n\tif (!wait_event_timeout(wait_data->wq, wait_data->done,\n\t\t\t\tcdx_mcdi_rpc_timeout(cdx, cmd)) &&\n\t    !wait_data->done) {\n\t\tpr_err(\"MC command 0x%x inlen %zu timed out (sync)\\n\",\n\t\t       cmd, inlen);\n\n\t\tcdx_mcdi_cancel_cmd(cdx, cmd_item);\n\n\t\twait_data->rc = -ETIMEDOUT;\n\t\twait_data->outlen_actual = 0;\n\t}\n\n\tif (outlen_actual)\n\t\t*outlen_actual = wait_data->outlen_actual;\n\trc = wait_data->rc;\n\nout:\n\tkref_put(&wait_data->ref, cdx_mcdi_blocking_data_release);\n\n\treturn rc;\n}\n\nstatic bool cdx_mcdi_get_seq(struct cdx_mcdi_iface *mcdi, unsigned char *seq)\n{\n\t*seq = mcdi->prev_seq;\n\tdo {\n\t\t*seq = (*seq + 1) % ARRAY_SIZE(mcdi->seq_held_by);\n\t} while (mcdi->seq_held_by[*seq] && *seq != mcdi->prev_seq);\n\treturn !mcdi->seq_held_by[*seq];\n}\n\nstatic int cdx_mcdi_rpc_async_internal(struct cdx_mcdi *cdx,\n\t\t\t\t       struct cdx_mcdi_cmd *cmd,\n\t\t\t\t       unsigned int *handle)\n{\n\tstruct cdx_mcdi_iface *mcdi = cdx_mcdi_if(cdx);\n\tLIST_HEAD(cleanup_list);\n\n\tif (!mcdi) {\n\t\tkref_put(&cmd->ref, cdx_mcdi_cmd_release);\n\t\treturn -ENETDOWN;\n\t}\n\n\tif (mcdi->mode == MCDI_MODE_FAIL) {\n\t\tkref_put(&cmd->ref, cdx_mcdi_cmd_release);\n\t\treturn -ENETDOWN;\n\t}\n\n\tcmd->mcdi = mcdi;\n\tINIT_WORK(&cmd->work, cdx_mcdi_cmd_work);\n\tINIT_LIST_HEAD(&cmd->list);\n\tINIT_LIST_HEAD(&cmd->cleanup_list);\n\tcmd->rc = 0;\n\tcmd->outbuf = NULL;\n\tcmd->outlen = 0;\n\n\tqueue_work(mcdi->workqueue, &cmd->work);\n\treturn 0;\n}\n\nstatic void cdx_mcdi_cmd_start_or_queue(struct cdx_mcdi_iface *mcdi,\n\t\t\t\t\tstruct cdx_mcdi_cmd *cmd)\n{\n\tstruct cdx_mcdi *cdx = mcdi->cdx;\n\tu8 seq;\n\n\tif (!mcdi->db_held_by &&\n\t    cdx_mcdi_get_seq(mcdi, &seq)) {\n\t\tcmd->seq = seq;\n\t\tcmd->reboot_seen = false;\n\t\tcdx_mcdi_send_request(cdx, cmd);\n\t\tcmd->state = MCDI_STATE_RUNNING;\n\t} else {\n\t\tcmd->state = MCDI_STATE_QUEUED;\n\t}\n}\n\n \nstatic void cdx_mcdi_start_or_queue(struct cdx_mcdi_iface *mcdi,\n\t\t\t\t    bool allow_retry)\n{\n\tstruct cdx_mcdi_cmd *cmd, *tmp;\n\n\tlist_for_each_entry_safe(cmd, tmp, &mcdi->cmd_list, list)\n\t\tif (cmd->state == MCDI_STATE_QUEUED ||\n\t\t    (cmd->state == MCDI_STATE_RETRY && allow_retry))\n\t\t\tcdx_mcdi_cmd_start_or_queue(mcdi, cmd);\n}\n\nvoid cdx_mcdi_process_cmd(struct cdx_mcdi *cdx, struct cdx_dword *outbuf, int len)\n{\n\tstruct cdx_mcdi_iface *mcdi;\n\tstruct cdx_mcdi_cmd *cmd;\n\tLIST_HEAD(cleanup_list);\n\tunsigned int respseq;\n\n\tif (!len || !outbuf) {\n\t\tpr_err(\"Got empty MC response\\n\");\n\t\treturn;\n\t}\n\n\tmcdi = cdx_mcdi_if(cdx);\n\tif (!mcdi)\n\t\treturn;\n\n\trespseq = CDX_DWORD_FIELD(outbuf[0], MCDI_HEADER_SEQ);\n\n\tmutex_lock(&mcdi->iface_lock);\n\tcmd = mcdi->seq_held_by[respseq];\n\n\tif (cmd) {\n\t\tif (cmd->state == MCDI_STATE_FINISHED) {\n\t\t\tmutex_unlock(&mcdi->iface_lock);\n\t\t\tkref_put(&cmd->ref, cdx_mcdi_cmd_release);\n\t\t\treturn;\n\t\t}\n\n\t\tcdx_mcdi_complete_cmd(mcdi, cmd, outbuf, len, &cleanup_list);\n\t} else {\n\t\tpr_err(\"MC response unexpected for seq : %0X\\n\", respseq);\n\t}\n\n\tmutex_unlock(&mcdi->iface_lock);\n\n\tcdx_mcdi_process_cleanup_list(mcdi->cdx, &cleanup_list);\n}\n\nstatic void cdx_mcdi_cmd_work(struct work_struct *context)\n{\n\tstruct cdx_mcdi_cmd *cmd =\n\t\tcontainer_of(context, struct cdx_mcdi_cmd, work);\n\tstruct cdx_mcdi_iface *mcdi = cmd->mcdi;\n\n\tmutex_lock(&mcdi->iface_lock);\n\n\tcmd->handle = mcdi->prev_handle++;\n\tlist_add_tail(&cmd->list, &mcdi->cmd_list);\n\tcdx_mcdi_cmd_start_or_queue(mcdi, cmd);\n\n\tmutex_unlock(&mcdi->iface_lock);\n}\n\n \nstatic bool cdx_mcdi_complete_cmd(struct cdx_mcdi_iface *mcdi,\n\t\t\t\t  struct cdx_mcdi_cmd *cmd,\n\t\t\t\t  struct cdx_dword *outbuf,\n\t\t\t\t  int len,\n\t\t\t\t  struct list_head *cleanup_list)\n{\n\tsize_t resp_hdr_len, resp_data_len;\n\tstruct cdx_mcdi *cdx = mcdi->cdx;\n\tunsigned int respcmd, error;\n\tbool completed = false;\n\tint rc;\n\n\t \n\tkref_get(&cmd->ref);\n\n\trespcmd = CDX_DWORD_FIELD(outbuf[0], MCDI_HEADER_CODE);\n\terror = CDX_DWORD_FIELD(outbuf[0], MCDI_HEADER_ERROR);\n\n\tif (respcmd != MC_CMD_V2_EXTN) {\n\t\tresp_hdr_len = 4;\n\t\tresp_data_len = CDX_DWORD_FIELD(outbuf[0], MCDI_HEADER_DATALEN);\n\t} else {\n\t\tresp_data_len = 0;\n\t\tresp_hdr_len = 8;\n\t\tif (len >= 8)\n\t\t\tresp_data_len =\n\t\t\t\tCDX_DWORD_FIELD(outbuf[1], MC_CMD_V2_EXTN_IN_ACTUAL_LEN);\n\t}\n\n\tif ((resp_hdr_len + resp_data_len) > len) {\n\t\tpr_warn(\"Incomplete MCDI response received %d. Expected %zu\\n\",\n\t\t\tlen, (resp_hdr_len + resp_data_len));\n\t\tresp_data_len = 0;\n\t}\n\n\tprint_hex_dump_debug(\"MCDI RESP HEADER: \", DUMP_PREFIX_NONE, 32, 4,\n\t\t\t     outbuf, resp_hdr_len, false);\n\tprint_hex_dump_debug(\"MCDI RESP PAYLOAD: \", DUMP_PREFIX_NONE, 32, 4,\n\t\t\t     outbuf + (resp_hdr_len / 4), resp_data_len, false);\n\n\tif (error && resp_data_len == 0) {\n\t\t \n\t\trc = -EIO;\n\t} else {\n\t\tif (WARN_ON_ONCE(error && resp_data_len < 4))\n\t\t\tresp_data_len = 4;\n\t\tif (error) {\n\t\t\trc = CDX_DWORD_FIELD(outbuf[resp_hdr_len / 4], CDX_DWORD);\n\t\t\tif (!cmd->quiet) {\n\t\t\t\tint err_arg = 0;\n\n\t\t\t\tif (resp_data_len >= MC_CMD_ERR_ARG_OFST + 4) {\n\t\t\t\t\tint offset = (resp_hdr_len + MC_CMD_ERR_ARG_OFST) / 4;\n\n\t\t\t\t\terr_arg = CDX_DWORD_VAL(outbuf[offset]);\n\t\t\t\t}\n\n\t\t\t\t_cdx_mcdi_display_error(cdx, cmd->cmd,\n\t\t\t\t\t\t\tcmd->inlen, rc, err_arg,\n\t\t\t\t\t\t\tcdx_mcdi_errno(cdx, rc));\n\t\t\t}\n\t\t\trc = cdx_mcdi_errno(cdx, rc);\n\t\t} else {\n\t\t\trc = 0;\n\t\t}\n\t}\n\n\t \n\tif (mcdi->db_held_by == cmd)\n\t\tmcdi->db_held_by = NULL;\n\n\tif (cdx_cmd_cancelled(cmd)) {\n\t\tlist_del(&cmd->list);\n\t\tkref_put(&cmd->ref, cdx_mcdi_cmd_release);\n\t\tcompleted = true;\n\t} else if (rc == MC_CMD_ERR_QUEUE_FULL) {\n\t\tcmd->state = MCDI_STATE_RETRY;\n\t} else {\n\t\tcmd->rc = rc;\n\t\tcmd->outbuf = outbuf + DIV_ROUND_UP(resp_hdr_len, 4);\n\t\tcmd->outlen = resp_data_len;\n\t\tcdx_mcdi_remove_cmd(mcdi, cmd, cleanup_list);\n\t\tcompleted = true;\n\t}\n\n\t \n\tmcdi->seq_held_by[cmd->seq] = NULL;\n\n\tcdx_mcdi_start_or_queue(mcdi, rc != MC_CMD_ERR_QUEUE_FULL);\n\n\t \n\twake_up(&mcdi->cmd_complete_wq);\n\n\tkref_put(&cmd->ref, cdx_mcdi_cmd_release);\n\n\treturn completed;\n}\n\nstatic void cdx_mcdi_timeout_cmd(struct cdx_mcdi_iface *mcdi,\n\t\t\t\t struct cdx_mcdi_cmd *cmd,\n\t\t\t\t struct list_head *cleanup_list)\n{\n\tstruct cdx_mcdi *cdx = mcdi->cdx;\n\n\tpr_err(\"MC command 0x%x inlen %zu state %d timed out after %u ms\\n\",\n\t       cmd->cmd, cmd->inlen, cmd->state,\n\t       jiffies_to_msecs(jiffies - cmd->started));\n\n\tcmd->rc = -ETIMEDOUT;\n\tcdx_mcdi_remove_cmd(mcdi, cmd, cleanup_list);\n\n\tcdx_mcdi_mode_fail(cdx, cleanup_list);\n}\n\n \nint cdx_mcdi_rpc(struct cdx_mcdi *cdx, unsigned int cmd,\n\t\t const struct cdx_dword *inbuf, size_t inlen,\n\t\t struct cdx_dword *outbuf, size_t outlen,\n\t\t size_t *outlen_actual)\n{\n\treturn cdx_mcdi_rpc_sync(cdx, cmd, inbuf, inlen, outbuf, outlen,\n\t\t\t\t outlen_actual, false);\n}\n\n \nint\ncdx_mcdi_rpc_async(struct cdx_mcdi *cdx, unsigned int cmd,\n\t\t   const struct cdx_dword *inbuf, size_t inlen,\n\t\t   cdx_mcdi_async_completer *complete, unsigned long cookie)\n{\n\tstruct cdx_mcdi_cmd *cmd_item =\n\t\tkmalloc(sizeof(struct cdx_mcdi_cmd) + inlen, GFP_ATOMIC);\n\n\tif (!cmd_item)\n\t\treturn -ENOMEM;\n\n\tkref_init(&cmd_item->ref);\n\tcmd_item->quiet = true;\n\tcmd_item->cookie = cookie;\n\tcmd_item->completer = complete;\n\tcmd_item->cmd = cmd;\n\tcmd_item->inlen = inlen;\n\t \n\tcmd_item->inbuf = (struct cdx_dword *)(cmd_item + 1);\n\tmemcpy(cmd_item + 1, inbuf, inlen);\n\n\treturn cdx_mcdi_rpc_async_internal(cdx, cmd_item, NULL);\n}\n\nstatic void _cdx_mcdi_display_error(struct cdx_mcdi *cdx, unsigned int cmd,\n\t\t\t\t    size_t inlen, int raw, int arg, int err_no)\n{\n\tpr_err(\"MC command 0x%x inlen %d failed err_no=%d (raw=%d) arg=%d\\n\",\n\t       cmd, (int)inlen, err_no, raw, arg);\n}\n\n \nstatic void cdx_mcdi_mode_fail(struct cdx_mcdi *cdx, struct list_head *cleanup_list)\n{\n\tstruct cdx_mcdi_iface *mcdi = cdx_mcdi_if(cdx);\n\n\tif (!mcdi)\n\t\treturn;\n\n\tmcdi->mode = MCDI_MODE_FAIL;\n\n\twhile (!list_empty(&mcdi->cmd_list)) {\n\t\tstruct cdx_mcdi_cmd *cmd;\n\n\t\tcmd = list_first_entry(&mcdi->cmd_list, struct cdx_mcdi_cmd,\n\t\t\t\t       list);\n\t\t_cdx_mcdi_cancel_cmd(mcdi, cdx_mcdi_cmd_handle(cmd), cleanup_list);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}