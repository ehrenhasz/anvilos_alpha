{
  "module_name": "cdx_controller.c",
  "hash_id": "aaa25674c891160b4a53433baee8f37d250c6a29ea0b98964b4fbe22d6b7d215",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cdx/controller/cdx_controller.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/cdx/cdx_bus.h>\n\n#include \"cdx_controller.h\"\n#include \"../cdx.h\"\n#include \"mcdi_functions.h\"\n#include \"mcdi.h\"\n\nstatic unsigned int cdx_mcdi_rpc_timeout(struct cdx_mcdi *cdx, unsigned int cmd)\n{\n\treturn MCDI_RPC_TIMEOUT;\n}\n\nstatic void cdx_mcdi_request(struct cdx_mcdi *cdx,\n\t\t\t     const struct cdx_dword *hdr, size_t hdr_len,\n\t\t\t     const struct cdx_dword *sdu, size_t sdu_len)\n{\n\tif (cdx_rpmsg_send(cdx, hdr, hdr_len, sdu, sdu_len))\n\t\tdev_err(&cdx->rpdev->dev, \"Failed to send rpmsg data\\n\");\n}\n\nstatic const struct cdx_mcdi_ops mcdi_ops = {\n\t.mcdi_rpc_timeout = cdx_mcdi_rpc_timeout,\n\t.mcdi_request = cdx_mcdi_request,\n};\n\nvoid cdx_rpmsg_post_probe(struct cdx_controller *cdx)\n{\n\t \n\tif (cdx_register_controller(cdx))\n\t\tdev_err(cdx->dev, \"Failed to register CDX controller\\n\");\n}\n\nvoid cdx_rpmsg_pre_remove(struct cdx_controller *cdx)\n{\n\tcdx_unregister_controller(cdx);\n\tcdx_mcdi_wait_for_quiescence(cdx->priv, MCDI_RPC_TIMEOUT);\n}\n\nstatic int cdx_configure_device(struct cdx_controller *cdx,\n\t\t\t\tu8 bus_num, u8 dev_num,\n\t\t\t\tstruct cdx_device_config *dev_config)\n{\n\tint ret = 0;\n\n\tswitch (dev_config->type) {\n\tcase CDX_DEV_RESET_CONF:\n\t\tret = cdx_mcdi_reset_device(cdx->priv, bus_num, dev_num);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int cdx_scan_devices(struct cdx_controller *cdx)\n{\n\tstruct cdx_mcdi *cdx_mcdi = cdx->priv;\n\tu8 bus_num, dev_num, num_cdx_bus;\n\tint ret;\n\n\t \n\tret = cdx_mcdi_get_num_buses(cdx_mcdi);\n\tif (ret < 0) {\n\t\tdev_err(cdx->dev,\n\t\t\t\"Get number of CDX buses failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tnum_cdx_bus = (u8)ret;\n\n\tfor (bus_num = 0; bus_num < num_cdx_bus; bus_num++) {\n\t\tu8 num_cdx_dev;\n\n\t\t \n\t\tret = cdx_mcdi_get_num_devs(cdx_mcdi, bus_num);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cdx->dev,\n\t\t\t\t\"Get devices on CDX bus %d failed: %d\\n\", bus_num, ret);\n\t\t\tcontinue;\n\t\t}\n\t\tnum_cdx_dev = (u8)ret;\n\n\t\tfor (dev_num = 0; dev_num < num_cdx_dev; dev_num++) {\n\t\t\tstruct cdx_dev_params dev_params;\n\n\t\t\t \n\t\t\tret = cdx_mcdi_get_dev_config(cdx_mcdi, bus_num,\n\t\t\t\t\t\t      dev_num, &dev_params);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(cdx->dev,\n\t\t\t\t\t\"CDX device config get failed for %d(bus):%d(dev), %d\\n\",\n\t\t\t\t\tbus_num, dev_num, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdev_params.cdx = cdx;\n\n\t\t\t \n\t\t\tret = cdx_device_add(&dev_params);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(cdx->dev, \"registering cdx dev: %d failed: %d\\n\",\n\t\t\t\t\tdev_num, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdev_dbg(cdx->dev, \"CDX dev: %d on cdx bus: %d created\\n\",\n\t\t\t\tdev_num, bus_num);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct cdx_ops cdx_ops = {\n\t.scan\t\t= cdx_scan_devices,\n\t.dev_configure\t= cdx_configure_device,\n};\n\nstatic int xlnx_cdx_probe(struct platform_device *pdev)\n{\n\tstruct cdx_controller *cdx;\n\tstruct cdx_mcdi *cdx_mcdi;\n\tint ret;\n\n\tcdx_mcdi = kzalloc(sizeof(*cdx_mcdi), GFP_KERNEL);\n\tif (!cdx_mcdi)\n\t\treturn -ENOMEM;\n\n\t \n\tcdx_mcdi->mcdi_ops = &mcdi_ops;\n\t \n\tret = cdx_mcdi_init(cdx_mcdi);\n\tif (ret) {\n\t\tdev_err_probe(&pdev->dev, ret, \"MCDI Initialization failed\\n\");\n\t\tgoto mcdi_init_fail;\n\t}\n\n\tcdx = kzalloc(sizeof(*cdx), GFP_KERNEL);\n\tif (!cdx) {\n\t\tret = -ENOMEM;\n\t\tgoto cdx_alloc_fail;\n\t}\n\tplatform_set_drvdata(pdev, cdx);\n\n\tcdx->dev = &pdev->dev;\n\tcdx->priv = cdx_mcdi;\n\tcdx->ops = &cdx_ops;\n\n\tret = cdx_setup_rpmsg(pdev);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"Failed to register CDX RPMsg transport\\n\");\n\t\tgoto cdx_rpmsg_fail;\n\t}\n\n\tdev_info(&pdev->dev, \"Successfully registered CDX controller with RPMsg as transport\\n\");\n\treturn 0;\n\ncdx_rpmsg_fail:\n\tkfree(cdx);\ncdx_alloc_fail:\n\tcdx_mcdi_finish(cdx_mcdi);\nmcdi_init_fail:\n\tkfree(cdx_mcdi);\n\n\treturn ret;\n}\n\nstatic int xlnx_cdx_remove(struct platform_device *pdev)\n{\n\tstruct cdx_controller *cdx = platform_get_drvdata(pdev);\n\tstruct cdx_mcdi *cdx_mcdi = cdx->priv;\n\n\tcdx_destroy_rpmsg(pdev);\n\n\tkfree(cdx);\n\n\tcdx_mcdi_finish(cdx_mcdi);\n\tkfree(cdx_mcdi);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id cdx_match_table[] = {\n\t{.compatible = \"xlnx,versal-net-cdx\",},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, cdx_match_table);\n\nstatic struct platform_driver cdx_pdriver = {\n\t.driver = {\n\t\t   .name = \"cdx-controller\",\n\t\t   .pm = NULL,\n\t\t   .of_match_table = cdx_match_table,\n\t\t   },\n\t.probe = xlnx_cdx_probe,\n\t.remove = xlnx_cdx_remove,\n};\n\nstatic int __init cdx_controller_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&cdx_pdriver);\n\tif (ret)\n\t\tpr_err(\"platform_driver_register() failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void __exit cdx_controller_exit(void)\n{\n\tplatform_driver_unregister(&cdx_pdriver);\n}\n\nmodule_init(cdx_controller_init);\nmodule_exit(cdx_controller_exit);\n\nMODULE_AUTHOR(\"AMD Inc.\");\nMODULE_DESCRIPTION(\"CDX controller for AMD devices\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}