{
  "module_name": "core.c",
  "hash_id": "c92b5790be57353e3982df96a2e8757333e6f3f67e59c6327f58accf0066c649",
  "original_prompt": "Ingested from linux-6.6.14/drivers/opp/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/pm_domain.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/xarray.h>\n\n#include \"opp.h\"\n\n \nLIST_HEAD(opp_tables);\n\n \nDEFINE_MUTEX(opp_table_lock);\n \nstatic bool opp_tables_busy;\n\n \nstatic DEFINE_XARRAY_ALLOC1(opp_configs);\n\nstatic bool _find_opp_dev(const struct device *dev, struct opp_table *opp_table)\n{\n\tstruct opp_device *opp_dev;\n\tbool found = false;\n\n\tmutex_lock(&opp_table->lock);\n\tlist_for_each_entry(opp_dev, &opp_table->dev_list, node)\n\t\tif (opp_dev->dev == dev) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\tmutex_unlock(&opp_table->lock);\n\treturn found;\n}\n\nstatic struct opp_table *_find_opp_table_unlocked(struct device *dev)\n{\n\tstruct opp_table *opp_table;\n\n\tlist_for_each_entry(opp_table, &opp_tables, node) {\n\t\tif (_find_opp_dev(dev, opp_table)) {\n\t\t\t_get_opp_table_kref(opp_table);\n\t\t\treturn opp_table;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n\n \nstruct opp_table *_find_opp_table(struct device *dev)\n{\n\tstruct opp_table *opp_table;\n\n\tif (IS_ERR_OR_NULL(dev)) {\n\t\tpr_err(\"%s: Invalid parameters\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmutex_lock(&opp_table_lock);\n\topp_table = _find_opp_table_unlocked(dev);\n\tmutex_unlock(&opp_table_lock);\n\n\treturn opp_table;\n}\n\n \nstatic bool assert_single_clk(struct opp_table *opp_table)\n{\n\treturn !WARN_ON(opp_table->clk_count > 1);\n}\n\n \nunsigned long dev_pm_opp_get_voltage(struct dev_pm_opp *opp)\n{\n\tif (IS_ERR_OR_NULL(opp)) {\n\t\tpr_err(\"%s: Invalid parameters\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn opp->supplies[0].u_volt;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_voltage);\n\n \nint dev_pm_opp_get_supplies(struct dev_pm_opp *opp,\n\t\t\t    struct dev_pm_opp_supply *supplies)\n{\n\tif (IS_ERR_OR_NULL(opp) || !supplies) {\n\t\tpr_err(\"%s: Invalid parameters\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(supplies, opp->supplies,\n\t       sizeof(*supplies) * opp->opp_table->regulator_count);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_supplies);\n\n \nunsigned long dev_pm_opp_get_power(struct dev_pm_opp *opp)\n{\n\tunsigned long opp_power = 0;\n\tint i;\n\n\tif (IS_ERR_OR_NULL(opp)) {\n\t\tpr_err(\"%s: Invalid parameters\\n\", __func__);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < opp->opp_table->regulator_count; i++)\n\t\topp_power += opp->supplies[i].u_watt;\n\n\treturn opp_power;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_power);\n\n \nunsigned long dev_pm_opp_get_freq_indexed(struct dev_pm_opp *opp, u32 index)\n{\n\tif (IS_ERR_OR_NULL(opp) || index >= opp->opp_table->clk_count) {\n\t\tpr_err(\"%s: Invalid parameters\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn opp->rates[index];\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_freq_indexed);\n\n \nunsigned int dev_pm_opp_get_level(struct dev_pm_opp *opp)\n{\n\tif (IS_ERR_OR_NULL(opp) || !opp->available) {\n\t\tpr_err(\"%s: Invalid parameters\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn opp->level;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_level);\n\n \nunsigned int dev_pm_opp_get_required_pstate(struct dev_pm_opp *opp,\n\t\t\t\t\t    unsigned int index)\n{\n\tif (IS_ERR_OR_NULL(opp) || !opp->available ||\n\t    index >= opp->opp_table->required_opp_count) {\n\t\tpr_err(\"%s: Invalid parameters\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t \n\tif (lazy_linking_pending(opp->opp_table))\n\t\treturn 0;\n\n\t \n\tif (unlikely(!opp->opp_table->required_opp_tables[index]->is_genpd)) {\n\t\tpr_err(\"%s: Performance state is only valid for genpds.\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn opp->required_opps[index]->level;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_required_pstate);\n\n \nbool dev_pm_opp_is_turbo(struct dev_pm_opp *opp)\n{\n\tif (IS_ERR_OR_NULL(opp) || !opp->available) {\n\t\tpr_err(\"%s: Invalid parameters\\n\", __func__);\n\t\treturn false;\n\t}\n\n\treturn opp->turbo;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_is_turbo);\n\n \nunsigned long dev_pm_opp_get_max_clock_latency(struct device *dev)\n{\n\tstruct opp_table *opp_table;\n\tunsigned long clock_latency_ns;\n\n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table))\n\t\treturn 0;\n\n\tclock_latency_ns = opp_table->clock_latency_ns_max;\n\n\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn clock_latency_ns;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_max_clock_latency);\n\n \nunsigned long dev_pm_opp_get_max_volt_latency(struct device *dev)\n{\n\tstruct opp_table *opp_table;\n\tstruct dev_pm_opp *opp;\n\tstruct regulator *reg;\n\tunsigned long latency_ns = 0;\n\tint ret, i, count;\n\tstruct {\n\t\tunsigned long min;\n\t\tunsigned long max;\n\t} *uV;\n\n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table))\n\t\treturn 0;\n\n\t \n\tif (!opp_table->regulators)\n\t\tgoto put_opp_table;\n\n\tcount = opp_table->regulator_count;\n\n\tuV = kmalloc_array(count, sizeof(*uV), GFP_KERNEL);\n\tif (!uV)\n\t\tgoto put_opp_table;\n\n\tmutex_lock(&opp_table->lock);\n\n\tfor (i = 0; i < count; i++) {\n\t\tuV[i].min = ~0;\n\t\tuV[i].max = 0;\n\n\t\tlist_for_each_entry(opp, &opp_table->opp_list, node) {\n\t\t\tif (!opp->available)\n\t\t\t\tcontinue;\n\n\t\t\tif (opp->supplies[i].u_volt_min < uV[i].min)\n\t\t\t\tuV[i].min = opp->supplies[i].u_volt_min;\n\t\t\tif (opp->supplies[i].u_volt_max > uV[i].max)\n\t\t\t\tuV[i].max = opp->supplies[i].u_volt_max;\n\t\t}\n\t}\n\n\tmutex_unlock(&opp_table->lock);\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\treg = opp_table->regulators[i];\n\t\tret = regulator_set_voltage_time(reg, uV[i].min, uV[i].max);\n\t\tif (ret > 0)\n\t\t\tlatency_ns += ret * 1000;\n\t}\n\n\tkfree(uV);\nput_opp_table:\n\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn latency_ns;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_max_volt_latency);\n\n \nunsigned long dev_pm_opp_get_max_transition_latency(struct device *dev)\n{\n\treturn dev_pm_opp_get_max_volt_latency(dev) +\n\t\tdev_pm_opp_get_max_clock_latency(dev);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_max_transition_latency);\n\n \nunsigned long dev_pm_opp_get_suspend_opp_freq(struct device *dev)\n{\n\tstruct opp_table *opp_table;\n\tunsigned long freq = 0;\n\n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table))\n\t\treturn 0;\n\n\tif (opp_table->suspend_opp && opp_table->suspend_opp->available)\n\t\tfreq = dev_pm_opp_get_freq(opp_table->suspend_opp);\n\n\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn freq;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_suspend_opp_freq);\n\nint _get_opp_count(struct opp_table *opp_table)\n{\n\tstruct dev_pm_opp *opp;\n\tint count = 0;\n\n\tmutex_lock(&opp_table->lock);\n\n\tlist_for_each_entry(opp, &opp_table->opp_list, node) {\n\t\tif (opp->available)\n\t\t\tcount++;\n\t}\n\n\tmutex_unlock(&opp_table->lock);\n\n\treturn count;\n}\n\n \nint dev_pm_opp_get_opp_count(struct device *dev)\n{\n\tstruct opp_table *opp_table;\n\tint count;\n\n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table)) {\n\t\tcount = PTR_ERR(opp_table);\n\t\tdev_dbg(dev, \"%s: OPP table not found (%d)\\n\",\n\t\t\t__func__, count);\n\t\treturn count;\n\t}\n\n\tcount = _get_opp_count(opp_table);\n\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_opp_count);\n\n \nstatic unsigned long _read_freq(struct dev_pm_opp *opp, int index)\n{\n\treturn opp->rates[index];\n}\n\nstatic unsigned long _read_level(struct dev_pm_opp *opp, int index)\n{\n\treturn opp->level;\n}\n\nstatic unsigned long _read_bw(struct dev_pm_opp *opp, int index)\n{\n\treturn opp->bandwidth[index].peak;\n}\n\n \nstatic bool _compare_exact(struct dev_pm_opp **opp, struct dev_pm_opp *temp_opp,\n\t\t\t   unsigned long opp_key, unsigned long key)\n{\n\tif (opp_key == key) {\n\t\t*opp = temp_opp;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool _compare_ceil(struct dev_pm_opp **opp, struct dev_pm_opp *temp_opp,\n\t\t\t  unsigned long opp_key, unsigned long key)\n{\n\tif (opp_key >= key) {\n\t\t*opp = temp_opp;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool _compare_floor(struct dev_pm_opp **opp, struct dev_pm_opp *temp_opp,\n\t\t\t   unsigned long opp_key, unsigned long key)\n{\n\tif (opp_key > key)\n\t\treturn true;\n\n\t*opp = temp_opp;\n\treturn false;\n}\n\n \nstatic struct dev_pm_opp *_opp_table_find_key(struct opp_table *opp_table,\n\t\tunsigned long *key, int index, bool available,\n\t\tunsigned long (*read)(struct dev_pm_opp *opp, int index),\n\t\tbool (*compare)(struct dev_pm_opp **opp, struct dev_pm_opp *temp_opp,\n\t\t\t\tunsigned long opp_key, unsigned long key),\n\t\tbool (*assert)(struct opp_table *opp_table))\n{\n\tstruct dev_pm_opp *temp_opp, *opp = ERR_PTR(-ERANGE);\n\n\t \n\tif (assert && !assert(opp_table))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmutex_lock(&opp_table->lock);\n\n\tlist_for_each_entry(temp_opp, &opp_table->opp_list, node) {\n\t\tif (temp_opp->available == available) {\n\t\t\tif (compare(&opp, temp_opp, read(temp_opp, index), *key))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!IS_ERR(opp)) {\n\t\t*key = read(opp, index);\n\t\tdev_pm_opp_get(opp);\n\t}\n\n\tmutex_unlock(&opp_table->lock);\n\n\treturn opp;\n}\n\nstatic struct dev_pm_opp *\n_find_key(struct device *dev, unsigned long *key, int index, bool available,\n\t  unsigned long (*read)(struct dev_pm_opp *opp, int index),\n\t  bool (*compare)(struct dev_pm_opp **opp, struct dev_pm_opp *temp_opp,\n\t\t\t  unsigned long opp_key, unsigned long key),\n\t  bool (*assert)(struct opp_table *opp_table))\n{\n\tstruct opp_table *opp_table;\n\tstruct dev_pm_opp *opp;\n\n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table)) {\n\t\tdev_err(dev, \"%s: OPP table not found (%ld)\\n\", __func__,\n\t\t\tPTR_ERR(opp_table));\n\t\treturn ERR_CAST(opp_table);\n\t}\n\n\topp = _opp_table_find_key(opp_table, key, index, available, read,\n\t\t\t\t  compare, assert);\n\n\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn opp;\n}\n\nstatic struct dev_pm_opp *_find_key_exact(struct device *dev,\n\t\tunsigned long key, int index, bool available,\n\t\tunsigned long (*read)(struct dev_pm_opp *opp, int index),\n\t\tbool (*assert)(struct opp_table *opp_table))\n{\n\t \n\treturn _find_key(dev, &key, index, available, read, _compare_exact,\n\t\t\t assert);\n}\n\nstatic struct dev_pm_opp *_opp_table_find_key_ceil(struct opp_table *opp_table,\n\t\tunsigned long *key, int index, bool available,\n\t\tunsigned long (*read)(struct dev_pm_opp *opp, int index),\n\t\tbool (*assert)(struct opp_table *opp_table))\n{\n\treturn _opp_table_find_key(opp_table, key, index, available, read,\n\t\t\t\t   _compare_ceil, assert);\n}\n\nstatic struct dev_pm_opp *_find_key_ceil(struct device *dev, unsigned long *key,\n\t\tint index, bool available,\n\t\tunsigned long (*read)(struct dev_pm_opp *opp, int index),\n\t\tbool (*assert)(struct opp_table *opp_table))\n{\n\treturn _find_key(dev, key, index, available, read, _compare_ceil,\n\t\t\t assert);\n}\n\nstatic struct dev_pm_opp *_find_key_floor(struct device *dev,\n\t\tunsigned long *key, int index, bool available,\n\t\tunsigned long (*read)(struct dev_pm_opp *opp, int index),\n\t\tbool (*assert)(struct opp_table *opp_table))\n{\n\treturn _find_key(dev, key, index, available, read, _compare_floor,\n\t\t\t assert);\n}\n\n \nstruct dev_pm_opp *dev_pm_opp_find_freq_exact(struct device *dev,\n\t\tunsigned long freq, bool available)\n{\n\treturn _find_key_exact(dev, freq, 0, available, _read_freq,\n\t\t\t       assert_single_clk);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_find_freq_exact);\n\n \nstruct dev_pm_opp *\ndev_pm_opp_find_freq_exact_indexed(struct device *dev, unsigned long freq,\n\t\t\t\t   u32 index, bool available)\n{\n\treturn _find_key_exact(dev, freq, index, available, _read_freq, NULL);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_find_freq_exact_indexed);\n\nstatic noinline struct dev_pm_opp *_find_freq_ceil(struct opp_table *opp_table,\n\t\t\t\t\t\t   unsigned long *freq)\n{\n\treturn _opp_table_find_key_ceil(opp_table, freq, 0, true, _read_freq,\n\t\t\t\t\tassert_single_clk);\n}\n\n \nstruct dev_pm_opp *dev_pm_opp_find_freq_ceil(struct device *dev,\n\t\t\t\t\t     unsigned long *freq)\n{\n\treturn _find_key_ceil(dev, freq, 0, true, _read_freq, assert_single_clk);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_find_freq_ceil);\n\n \nstruct dev_pm_opp *\ndev_pm_opp_find_freq_ceil_indexed(struct device *dev, unsigned long *freq,\n\t\t\t\t  u32 index)\n{\n\treturn _find_key_ceil(dev, freq, index, true, _read_freq, NULL);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_find_freq_ceil_indexed);\n\n \nstruct dev_pm_opp *dev_pm_opp_find_freq_floor(struct device *dev,\n\t\t\t\t\t      unsigned long *freq)\n{\n\treturn _find_key_floor(dev, freq, 0, true, _read_freq, assert_single_clk);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_find_freq_floor);\n\n \nstruct dev_pm_opp *\ndev_pm_opp_find_freq_floor_indexed(struct device *dev, unsigned long *freq,\n\t\t\t\t   u32 index)\n{\n\treturn _find_key_floor(dev, freq, index, true, _read_freq, NULL);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_find_freq_floor_indexed);\n\n \nstruct dev_pm_opp *dev_pm_opp_find_level_exact(struct device *dev,\n\t\t\t\t\t       unsigned int level)\n{\n\treturn _find_key_exact(dev, level, 0, true, _read_level, NULL);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_find_level_exact);\n\n \nstruct dev_pm_opp *dev_pm_opp_find_level_ceil(struct device *dev,\n\t\t\t\t\t      unsigned int *level)\n{\n\tunsigned long temp = *level;\n\tstruct dev_pm_opp *opp;\n\n\topp = _find_key_ceil(dev, &temp, 0, true, _read_level, NULL);\n\t*level = temp;\n\treturn opp;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_find_level_ceil);\n\n \nstruct dev_pm_opp *dev_pm_opp_find_bw_ceil(struct device *dev, unsigned int *bw,\n\t\t\t\t\t   int index)\n{\n\tunsigned long temp = *bw;\n\tstruct dev_pm_opp *opp;\n\n\topp = _find_key_ceil(dev, &temp, index, true, _read_bw, NULL);\n\t*bw = temp;\n\treturn opp;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_find_bw_ceil);\n\n \nstruct dev_pm_opp *dev_pm_opp_find_bw_floor(struct device *dev,\n\t\t\t\t\t    unsigned int *bw, int index)\n{\n\tunsigned long temp = *bw;\n\tstruct dev_pm_opp *opp;\n\n\topp = _find_key_floor(dev, &temp, index, true, _read_bw, NULL);\n\t*bw = temp;\n\treturn opp;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_find_bw_floor);\n\nstatic int _set_opp_voltage(struct device *dev, struct regulator *reg,\n\t\t\t    struct dev_pm_opp_supply *supply)\n{\n\tint ret;\n\n\t \n\tif (IS_ERR(reg)) {\n\t\tdev_dbg(dev, \"%s: regulator not available: %ld\\n\", __func__,\n\t\t\tPTR_ERR(reg));\n\t\treturn 0;\n\t}\n\n\tdev_dbg(dev, \"%s: voltages (mV): %lu %lu %lu\\n\", __func__,\n\t\tsupply->u_volt_min, supply->u_volt, supply->u_volt_max);\n\n\tret = regulator_set_voltage_triplet(reg, supply->u_volt_min,\n\t\t\t\t\t    supply->u_volt, supply->u_volt_max);\n\tif (ret)\n\t\tdev_err(dev, \"%s: failed to set voltage (%lu %lu %lu mV): %d\\n\",\n\t\t\t__func__, supply->u_volt_min, supply->u_volt,\n\t\t\tsupply->u_volt_max, ret);\n\n\treturn ret;\n}\n\nstatic int\n_opp_config_clk_single(struct device *dev, struct opp_table *opp_table,\n\t\t       struct dev_pm_opp *opp, void *data, bool scaling_down)\n{\n\tunsigned long *target = data;\n\tunsigned long freq;\n\tint ret;\n\n\t \n\tif (target) {\n\t\tfreq = *target;\n\t} else if (opp) {\n\t\tfreq = opp->rates[0];\n\t} else {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = clk_set_rate(opp_table->clk, freq);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: failed to set clock rate: %d\\n\", __func__,\n\t\t\tret);\n\t} else {\n\t\topp_table->rate_clk_single = freq;\n\t}\n\n\treturn ret;\n}\n\n \nint dev_pm_opp_config_clks_simple(struct device *dev,\n\t\tstruct opp_table *opp_table, struct dev_pm_opp *opp, void *data,\n\t\tbool scaling_down)\n{\n\tint ret, i;\n\n\tif (scaling_down) {\n\t\tfor (i = opp_table->clk_count - 1; i >= 0; i--) {\n\t\t\tret = clk_set_rate(opp_table->clks[i], opp->rates[i]);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"%s: failed to set clock rate: %d\\n\", __func__,\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < opp_table->clk_count; i++) {\n\t\t\tret = clk_set_rate(opp_table->clks[i], opp->rates[i]);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"%s: failed to set clock rate: %d\\n\", __func__,\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_config_clks_simple);\n\nstatic int _opp_config_regulator_single(struct device *dev,\n\t\t\tstruct dev_pm_opp *old_opp, struct dev_pm_opp *new_opp,\n\t\t\tstruct regulator **regulators, unsigned int count)\n{\n\tstruct regulator *reg = regulators[0];\n\tint ret;\n\n\t \n\tif (WARN_ON(count > 1)) {\n\t\tdev_err(dev, \"multiple regulators are not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = _set_opp_voltage(dev, reg, new_opp->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (unlikely(!new_opp->opp_table->enabled)) {\n\t\tret = regulator_enable(reg);\n\t\tif (ret < 0)\n\t\t\tdev_warn(dev, \"Failed to enable regulator: %d\", ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int _set_opp_bw(const struct opp_table *opp_table,\n\t\t       struct dev_pm_opp *opp, struct device *dev)\n{\n\tu32 avg, peak;\n\tint i, ret;\n\n\tif (!opp_table->paths)\n\t\treturn 0;\n\n\tfor (i = 0; i < opp_table->path_count; i++) {\n\t\tif (!opp) {\n\t\t\tavg = 0;\n\t\t\tpeak = 0;\n\t\t} else {\n\t\t\tavg = opp->bandwidth[i].avg;\n\t\t\tpeak = opp->bandwidth[i].peak;\n\t\t}\n\t\tret = icc_set_bw(opp_table->paths[i], avg, peak);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to %s bandwidth[%d]: %d\\n\",\n\t\t\t\topp ? \"set\" : \"remove\", i, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int _set_performance_state(struct device *dev, struct device *pd_dev,\n\t\t\t\t  struct dev_pm_opp *opp, int i)\n{\n\tunsigned int pstate = likely(opp) ? opp->required_opps[i]->level: 0;\n\tint ret;\n\n\tif (!pd_dev)\n\t\treturn 0;\n\n\tret = dev_pm_genpd_set_performance_state(pd_dev, pstate);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set performance state of %s: %d (%d)\\n\",\n\t\t\tdev_name(pd_dev), pstate, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int _opp_set_required_opps_generic(struct device *dev,\n\tstruct opp_table *opp_table, struct dev_pm_opp *opp, bool scaling_down)\n{\n\tdev_err(dev, \"setting required-opps isn't supported for non-genpd devices\\n\");\n\treturn -ENOENT;\n}\n\nstatic int _opp_set_required_opps_genpd(struct device *dev,\n\tstruct opp_table *opp_table, struct dev_pm_opp *opp, bool scaling_down)\n{\n\tstruct device **genpd_virt_devs =\n\t\topp_table->genpd_virt_devs ? opp_table->genpd_virt_devs : &dev;\n\tint i, ret = 0;\n\n\t \n\tmutex_lock(&opp_table->genpd_virt_dev_lock);\n\n\t \n\tif (!scaling_down) {\n\t\tfor (i = 0; i < opp_table->required_opp_count; i++) {\n\t\t\tret = _set_performance_state(dev, genpd_virt_devs[i], opp, i);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tfor (i = opp_table->required_opp_count - 1; i >= 0; i--) {\n\t\t\tret = _set_performance_state(dev, genpd_virt_devs[i], opp, i);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&opp_table->genpd_virt_dev_lock);\n\n\treturn ret;\n}\n\n \nstatic int _set_required_opps(struct device *dev, struct opp_table *opp_table,\n\t\t\t      struct dev_pm_opp *opp, bool up)\n{\n\t \n\tif (lazy_linking_pending(opp_table))\n\t\treturn -EBUSY;\n\n\tif (opp_table->set_required_opps)\n\t\treturn opp_table->set_required_opps(dev, opp_table, opp, up);\n\n\treturn 0;\n}\n\n \nvoid _update_set_required_opps(struct opp_table *opp_table)\n{\n\t \n\tif (opp_table->set_required_opps)\n\t\treturn;\n\n\t \n\tif (opp_table->required_opp_tables[0]->is_genpd)\n\t\topp_table->set_required_opps = _opp_set_required_opps_genpd;\n\telse\n\t\topp_table->set_required_opps = _opp_set_required_opps_generic;\n}\n\nstatic void _find_current_opp(struct device *dev, struct opp_table *opp_table)\n{\n\tstruct dev_pm_opp *opp = ERR_PTR(-ENODEV);\n\tunsigned long freq;\n\n\tif (!IS_ERR(opp_table->clk)) {\n\t\tfreq = clk_get_rate(opp_table->clk);\n\t\topp = _find_freq_ceil(opp_table, &freq);\n\t}\n\n\t \n\tif (IS_ERR(opp)) {\n\t\tmutex_lock(&opp_table->lock);\n\t\topp = list_first_entry(&opp_table->opp_list, struct dev_pm_opp, node);\n\t\tdev_pm_opp_get(opp);\n\t\tmutex_unlock(&opp_table->lock);\n\t}\n\n\topp_table->current_opp = opp;\n}\n\nstatic int _disable_opp_table(struct device *dev, struct opp_table *opp_table)\n{\n\tint ret;\n\n\tif (!opp_table->enabled)\n\t\treturn 0;\n\n\t \n\tif (!_get_opp_count(opp_table))\n\t\treturn 0;\n\n\tret = _set_opp_bw(opp_table, NULL, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (opp_table->regulators)\n\t\tregulator_disable(opp_table->regulators[0]);\n\n\tret = _set_required_opps(dev, opp_table, NULL, false);\n\n\topp_table->enabled = false;\n\treturn ret;\n}\n\nstatic int _set_opp(struct device *dev, struct opp_table *opp_table,\n\t\t    struct dev_pm_opp *opp, void *clk_data, bool forced)\n{\n\tstruct dev_pm_opp *old_opp;\n\tint scaling_down, ret;\n\n\tif (unlikely(!opp))\n\t\treturn _disable_opp_table(dev, opp_table);\n\n\t \n\tif (unlikely(!opp_table->current_opp))\n\t\t_find_current_opp(dev, opp_table);\n\n\told_opp = opp_table->current_opp;\n\n\t \n\tif (!forced && old_opp == opp && opp_table->enabled) {\n\t\tdev_dbg_ratelimited(dev, \"%s: OPPs are same, nothing to do\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tdev_dbg(dev, \"%s: switching OPP: Freq %lu -> %lu Hz, Level %u -> %u, Bw %u -> %u\\n\",\n\t\t__func__, old_opp->rates[0], opp->rates[0], old_opp->level,\n\t\topp->level, old_opp->bandwidth ? old_opp->bandwidth[0].peak : 0,\n\t\topp->bandwidth ? opp->bandwidth[0].peak : 0);\n\n\tscaling_down = _opp_compare_key(opp_table, old_opp, opp);\n\tif (scaling_down == -1)\n\t\tscaling_down = 0;\n\n\t \n\tif (!scaling_down) {\n\t\tret = _set_required_opps(dev, opp_table, opp, true);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to set required opps: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = _set_opp_bw(opp_table, opp, dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to set bw: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (opp_table->config_regulators) {\n\t\t\tret = opp_table->config_regulators(dev, old_opp, opp,\n\t\t\t\t\t\t\t   opp_table->regulators,\n\t\t\t\t\t\t\t   opp_table->regulator_count);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Failed to set regulator voltages: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (opp_table->config_clks) {\n\t\tret = opp_table->config_clks(dev, opp_table, opp, clk_data, scaling_down);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (scaling_down) {\n\t\tif (opp_table->config_regulators) {\n\t\t\tret = opp_table->config_regulators(dev, old_opp, opp,\n\t\t\t\t\t\t\t   opp_table->regulators,\n\t\t\t\t\t\t\t   opp_table->regulator_count);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Failed to set regulator voltages: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = _set_opp_bw(opp_table, opp, dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to set bw: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = _set_required_opps(dev, opp_table, opp, false);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to set required opps: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\topp_table->enabled = true;\n\tdev_pm_opp_put(old_opp);\n\n\t \n\tdev_pm_opp_get(opp);\n\topp_table->current_opp = opp;\n\n\treturn ret;\n}\n\n \nint dev_pm_opp_set_rate(struct device *dev, unsigned long target_freq)\n{\n\tstruct opp_table *opp_table;\n\tunsigned long freq = 0, temp_freq;\n\tstruct dev_pm_opp *opp = NULL;\n\tbool forced = false;\n\tint ret;\n\n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table)) {\n\t\tdev_err(dev, \"%s: device's opp table doesn't exist\\n\", __func__);\n\t\treturn PTR_ERR(opp_table);\n\t}\n\n\tif (target_freq) {\n\t\t \n\t\tif (!_get_opp_count(opp_table)) {\n\t\t\tret = opp_table->config_clks(dev, opp_table, NULL,\n\t\t\t\t\t\t     &target_freq, false);\n\t\t\tgoto put_opp_table;\n\t\t}\n\n\t\tfreq = clk_round_rate(opp_table->clk, target_freq);\n\t\tif ((long)freq <= 0)\n\t\t\tfreq = target_freq;\n\n\t\t \n\t\ttemp_freq = freq;\n\t\topp = _find_freq_ceil(opp_table, &temp_freq);\n\t\tif (IS_ERR(opp)) {\n\t\t\tret = PTR_ERR(opp);\n\t\t\tdev_err(dev, \"%s: failed to find OPP for freq %lu (%d)\\n\",\n\t\t\t\t__func__, freq, ret);\n\t\t\tgoto put_opp_table;\n\t\t}\n\n\t\t \n\t\tforced = opp_table->rate_clk_single != target_freq;\n\t}\n\n\tret = _set_opp(dev, opp_table, opp, &target_freq, forced);\n\n\tif (target_freq)\n\t\tdev_pm_opp_put(opp);\n\nput_opp_table:\n\tdev_pm_opp_put_opp_table(opp_table);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_set_rate);\n\n \nint dev_pm_opp_set_opp(struct device *dev, struct dev_pm_opp *opp)\n{\n\tstruct opp_table *opp_table;\n\tint ret;\n\n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table)) {\n\t\tdev_err(dev, \"%s: device opp doesn't exist\\n\", __func__);\n\t\treturn PTR_ERR(opp_table);\n\t}\n\n\tret = _set_opp(dev, opp_table, opp, NULL, false);\n\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_set_opp);\n\n \nstatic void _remove_opp_dev(struct opp_device *opp_dev,\n\t\t\t    struct opp_table *opp_table)\n{\n\topp_debug_unregister(opp_dev, opp_table);\n\tlist_del(&opp_dev->node);\n\tkfree(opp_dev);\n}\n\nstruct opp_device *_add_opp_dev(const struct device *dev,\n\t\t\t\tstruct opp_table *opp_table)\n{\n\tstruct opp_device *opp_dev;\n\n\topp_dev = kzalloc(sizeof(*opp_dev), GFP_KERNEL);\n\tif (!opp_dev)\n\t\treturn NULL;\n\n\t \n\topp_dev->dev = dev;\n\n\tmutex_lock(&opp_table->lock);\n\tlist_add(&opp_dev->node, &opp_table->dev_list);\n\tmutex_unlock(&opp_table->lock);\n\n\t \n\topp_debug_register(opp_dev, opp_table);\n\n\treturn opp_dev;\n}\n\nstatic struct opp_table *_allocate_opp_table(struct device *dev, int index)\n{\n\tstruct opp_table *opp_table;\n\tstruct opp_device *opp_dev;\n\tint ret;\n\n\t \n\topp_table = kzalloc(sizeof(*opp_table), GFP_KERNEL);\n\tif (!opp_table)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&opp_table->lock);\n\tmutex_init(&opp_table->genpd_virt_dev_lock);\n\tINIT_LIST_HEAD(&opp_table->dev_list);\n\tINIT_LIST_HEAD(&opp_table->lazy);\n\n\topp_table->clk = ERR_PTR(-ENODEV);\n\n\t \n\topp_table->regulator_count = -1;\n\n\topp_dev = _add_opp_dev(dev, opp_table);\n\tif (!opp_dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t_of_init_opp_table(opp_table, dev, index);\n\n\t \n\tret = dev_pm_opp_of_find_icc_paths(dev, opp_table);\n\tif (ret) {\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto remove_opp_dev;\n\n\t\tdev_warn(dev, \"%s: Error finding interconnect paths: %d\\n\",\n\t\t\t __func__, ret);\n\t}\n\n\tBLOCKING_INIT_NOTIFIER_HEAD(&opp_table->head);\n\tINIT_LIST_HEAD(&opp_table->opp_list);\n\tkref_init(&opp_table->kref);\n\n\treturn opp_table;\n\nremove_opp_dev:\n\t_of_clear_opp_table(opp_table);\n\t_remove_opp_dev(opp_dev, opp_table);\n\tmutex_destroy(&opp_table->genpd_virt_dev_lock);\n\tmutex_destroy(&opp_table->lock);\nerr:\n\tkfree(opp_table);\n\treturn ERR_PTR(ret);\n}\n\nvoid _get_opp_table_kref(struct opp_table *opp_table)\n{\n\tkref_get(&opp_table->kref);\n}\n\nstatic struct opp_table *_update_opp_table_clk(struct device *dev,\n\t\t\t\t\t       struct opp_table *opp_table,\n\t\t\t\t\t       bool getclk)\n{\n\tint ret;\n\n\t \n\tif (!getclk || IS_ERR(opp_table) || !IS_ERR(opp_table->clk) ||\n\t    opp_table->clks)\n\t\treturn opp_table;\n\n\t \n\topp_table->clk = clk_get(dev, NULL);\n\n\tret = PTR_ERR_OR_ZERO(opp_table->clk);\n\tif (!ret) {\n\t\topp_table->config_clks = _opp_config_clk_single;\n\t\topp_table->clk_count = 1;\n\t\treturn opp_table;\n\t}\n\n\tif (ret == -ENOENT) {\n\t\t \n\t\topp_table->clk_count = 1;\n\n\t\tdev_dbg(dev, \"%s: Couldn't find clock: %d\\n\", __func__, ret);\n\t\treturn opp_table;\n\t}\n\n\tdev_pm_opp_put_opp_table(opp_table);\n\tdev_err_probe(dev, ret, \"Couldn't find clock\\n\");\n\n\treturn ERR_PTR(ret);\n}\n\n \nstruct opp_table *_add_opp_table_indexed(struct device *dev, int index,\n\t\t\t\t\t bool getclk)\n{\n\tstruct opp_table *opp_table;\n\nagain:\n\tmutex_lock(&opp_table_lock);\n\n\topp_table = _find_opp_table_unlocked(dev);\n\tif (!IS_ERR(opp_table))\n\t\tgoto unlock;\n\n\t \n\tif (unlikely(opp_tables_busy)) {\n\t\tmutex_unlock(&opp_table_lock);\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\n\topp_tables_busy = true;\n\topp_table = _managed_opp(dev, index);\n\n\t \n\tmutex_unlock(&opp_table_lock);\n\n\tif (opp_table) {\n\t\tif (!_add_opp_dev(dev, opp_table)) {\n\t\t\tdev_pm_opp_put_opp_table(opp_table);\n\t\t\topp_table = ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tmutex_lock(&opp_table_lock);\n\t} else {\n\t\topp_table = _allocate_opp_table(dev, index);\n\n\t\tmutex_lock(&opp_table_lock);\n\t\tif (!IS_ERR(opp_table))\n\t\t\tlist_add(&opp_table->node, &opp_tables);\n\t}\n\n\topp_tables_busy = false;\n\nunlock:\n\tmutex_unlock(&opp_table_lock);\n\n\treturn _update_opp_table_clk(dev, opp_table, getclk);\n}\n\nstatic struct opp_table *_add_opp_table(struct device *dev, bool getclk)\n{\n\treturn _add_opp_table_indexed(dev, 0, getclk);\n}\n\nstruct opp_table *dev_pm_opp_get_opp_table(struct device *dev)\n{\n\treturn _find_opp_table(dev);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_opp_table);\n\nstatic void _opp_table_kref_release(struct kref *kref)\n{\n\tstruct opp_table *opp_table = container_of(kref, struct opp_table, kref);\n\tstruct opp_device *opp_dev, *temp;\n\tint i;\n\n\t \n\tlist_del(&opp_table->node);\n\tmutex_unlock(&opp_table_lock);\n\n\tif (opp_table->current_opp)\n\t\tdev_pm_opp_put(opp_table->current_opp);\n\n\t_of_clear_opp_table(opp_table);\n\n\t \n\tif (!IS_ERR(opp_table->clk))\n\t\tclk_put(opp_table->clk);\n\n\tif (opp_table->paths) {\n\t\tfor (i = 0; i < opp_table->path_count; i++)\n\t\t\ticc_put(opp_table->paths[i]);\n\t\tkfree(opp_table->paths);\n\t}\n\n\tWARN_ON(!list_empty(&opp_table->opp_list));\n\n\tlist_for_each_entry_safe(opp_dev, temp, &opp_table->dev_list, node)\n\t\t_remove_opp_dev(opp_dev, opp_table);\n\n\tmutex_destroy(&opp_table->genpd_virt_dev_lock);\n\tmutex_destroy(&opp_table->lock);\n\tkfree(opp_table);\n}\n\nvoid dev_pm_opp_put_opp_table(struct opp_table *opp_table)\n{\n\tkref_put_mutex(&opp_table->kref, _opp_table_kref_release,\n\t\t       &opp_table_lock);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_put_opp_table);\n\nvoid _opp_free(struct dev_pm_opp *opp)\n{\n\tkfree(opp);\n}\n\nstatic void _opp_kref_release(struct kref *kref)\n{\n\tstruct dev_pm_opp *opp = container_of(kref, struct dev_pm_opp, kref);\n\tstruct opp_table *opp_table = opp->opp_table;\n\n\tlist_del(&opp->node);\n\tmutex_unlock(&opp_table->lock);\n\n\t \n\tblocking_notifier_call_chain(&opp_table->head, OPP_EVENT_REMOVE, opp);\n\t_of_clear_opp(opp_table, opp);\n\topp_debug_remove_one(opp);\n\tkfree(opp);\n}\n\nvoid dev_pm_opp_get(struct dev_pm_opp *opp)\n{\n\tkref_get(&opp->kref);\n}\n\nvoid dev_pm_opp_put(struct dev_pm_opp *opp)\n{\n\tkref_put_mutex(&opp->kref, _opp_kref_release, &opp->opp_table->lock);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_put);\n\n \nvoid dev_pm_opp_remove(struct device *dev, unsigned long freq)\n{\n\tstruct dev_pm_opp *opp = NULL, *iter;\n\tstruct opp_table *opp_table;\n\n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table))\n\t\treturn;\n\n\tif (!assert_single_clk(opp_table))\n\t\tgoto put_table;\n\n\tmutex_lock(&opp_table->lock);\n\n\tlist_for_each_entry(iter, &opp_table->opp_list, node) {\n\t\tif (iter->rates[0] == freq) {\n\t\t\topp = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&opp_table->lock);\n\n\tif (opp) {\n\t\tdev_pm_opp_put(opp);\n\n\t\t \n\t\tdev_pm_opp_put_opp_table(opp_table);\n\t} else {\n\t\tdev_warn(dev, \"%s: Couldn't find OPP with freq: %lu\\n\",\n\t\t\t __func__, freq);\n\t}\n\nput_table:\n\t \n\tdev_pm_opp_put_opp_table(opp_table);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_remove);\n\nstatic struct dev_pm_opp *_opp_get_next(struct opp_table *opp_table,\n\t\t\t\t\tbool dynamic)\n{\n\tstruct dev_pm_opp *opp = NULL, *temp;\n\n\tmutex_lock(&opp_table->lock);\n\tlist_for_each_entry(temp, &opp_table->opp_list, node) {\n\t\t \n\t\tif (!temp->removed && dynamic == temp->dynamic) {\n\t\t\topp = temp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&opp_table->lock);\n\treturn opp;\n}\n\n \nstatic void _opp_remove_all(struct opp_table *opp_table, bool dynamic)\n{\n\tstruct dev_pm_opp *opp;\n\n\twhile ((opp = _opp_get_next(opp_table, dynamic))) {\n\t\topp->removed = true;\n\t\tdev_pm_opp_put(opp);\n\n\t\t \n\t\tif (dynamic)\n\t\t\tdev_pm_opp_put_opp_table(opp_table);\n\t}\n}\n\nbool _opp_remove_all_static(struct opp_table *opp_table)\n{\n\tmutex_lock(&opp_table->lock);\n\n\tif (!opp_table->parsed_static_opps) {\n\t\tmutex_unlock(&opp_table->lock);\n\t\treturn false;\n\t}\n\n\tif (--opp_table->parsed_static_opps) {\n\t\tmutex_unlock(&opp_table->lock);\n\t\treturn true;\n\t}\n\n\tmutex_unlock(&opp_table->lock);\n\n\t_opp_remove_all(opp_table, false);\n\treturn true;\n}\n\n \nvoid dev_pm_opp_remove_all_dynamic(struct device *dev)\n{\n\tstruct opp_table *opp_table;\n\n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table))\n\t\treturn;\n\n\t_opp_remove_all(opp_table, true);\n\n\t \n\tdev_pm_opp_put_opp_table(opp_table);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_remove_all_dynamic);\n\nstruct dev_pm_opp *_opp_allocate(struct opp_table *opp_table)\n{\n\tstruct dev_pm_opp *opp;\n\tint supply_count, supply_size, icc_size, clk_size;\n\n\t \n\tsupply_count = opp_table->regulator_count > 0 ?\n\t\t\topp_table->regulator_count : 1;\n\tsupply_size = sizeof(*opp->supplies) * supply_count;\n\tclk_size = sizeof(*opp->rates) * opp_table->clk_count;\n\ticc_size = sizeof(*opp->bandwidth) * opp_table->path_count;\n\n\t \n\topp = kzalloc(sizeof(*opp) + supply_size + clk_size + icc_size, GFP_KERNEL);\n\tif (!opp)\n\t\treturn NULL;\n\n\t \n\topp->supplies = (struct dev_pm_opp_supply *)(opp + 1);\n\n\topp->rates = (unsigned long *)(opp->supplies + supply_count);\n\n\tif (icc_size)\n\t\topp->bandwidth = (struct dev_pm_opp_icc_bw *)(opp->rates + opp_table->clk_count);\n\n\tINIT_LIST_HEAD(&opp->node);\n\n\treturn opp;\n}\n\nstatic bool _opp_supported_by_regulators(struct dev_pm_opp *opp,\n\t\t\t\t\t struct opp_table *opp_table)\n{\n\tstruct regulator *reg;\n\tint i;\n\n\tif (!opp_table->regulators)\n\t\treturn true;\n\n\tfor (i = 0; i < opp_table->regulator_count; i++) {\n\t\treg = opp_table->regulators[i];\n\n\t\tif (!regulator_is_supported_voltage(reg,\n\t\t\t\t\topp->supplies[i].u_volt_min,\n\t\t\t\t\topp->supplies[i].u_volt_max)) {\n\t\t\tpr_warn(\"%s: OPP minuV: %lu maxuV: %lu, not supported by regulator\\n\",\n\t\t\t\t__func__, opp->supplies[i].u_volt_min,\n\t\t\t\topp->supplies[i].u_volt_max);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic int _opp_compare_rate(struct opp_table *opp_table,\n\t\t\t     struct dev_pm_opp *opp1, struct dev_pm_opp *opp2)\n{\n\tint i;\n\n\tfor (i = 0; i < opp_table->clk_count; i++) {\n\t\tif (opp1->rates[i] != opp2->rates[i])\n\t\t\treturn opp1->rates[i] < opp2->rates[i] ? -1 : 1;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int _opp_compare_bw(struct opp_table *opp_table, struct dev_pm_opp *opp1,\n\t\t\t   struct dev_pm_opp *opp2)\n{\n\tint i;\n\n\tfor (i = 0; i < opp_table->path_count; i++) {\n\t\tif (opp1->bandwidth[i].peak != opp2->bandwidth[i].peak)\n\t\t\treturn opp1->bandwidth[i].peak < opp2->bandwidth[i].peak ? -1 : 1;\n\t}\n\n\t \n\treturn 0;\n}\n\n \nint _opp_compare_key(struct opp_table *opp_table, struct dev_pm_opp *opp1,\n\t\t     struct dev_pm_opp *opp2)\n{\n\tint ret;\n\n\tret = _opp_compare_rate(opp_table, opp1, opp2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = _opp_compare_bw(opp_table, opp1, opp2);\n\tif (ret)\n\t\treturn ret;\n\n\tif (opp1->level != opp2->level)\n\t\treturn opp1->level < opp2->level ? -1 : 1;\n\n\t \n\treturn 0;\n}\n\nstatic int _opp_is_duplicate(struct device *dev, struct dev_pm_opp *new_opp,\n\t\t\t     struct opp_table *opp_table,\n\t\t\t     struct list_head **head)\n{\n\tstruct dev_pm_opp *opp;\n\tint opp_cmp;\n\n\t \n\tlist_for_each_entry(opp, &opp_table->opp_list, node) {\n\t\topp_cmp = _opp_compare_key(opp_table, new_opp, opp);\n\t\tif (opp_cmp > 0) {\n\t\t\t*head = &opp->node;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (opp_cmp < 0)\n\t\t\treturn 0;\n\n\t\t \n\t\tdev_warn(dev, \"%s: duplicate OPPs detected. Existing: freq: %lu, volt: %lu, enabled: %d. New: freq: %lu, volt: %lu, enabled: %d\\n\",\n\t\t\t __func__, opp->rates[0], opp->supplies[0].u_volt,\n\t\t\t opp->available, new_opp->rates[0],\n\t\t\t new_opp->supplies[0].u_volt, new_opp->available);\n\n\t\t \n\t\treturn opp->available &&\n\t\t       new_opp->supplies[0].u_volt == opp->supplies[0].u_volt ? -EBUSY : -EEXIST;\n\t}\n\n\treturn 0;\n}\n\nvoid _required_opps_available(struct dev_pm_opp *opp, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (opp->required_opps[i]->available)\n\t\t\tcontinue;\n\n\t\topp->available = false;\n\t\tpr_warn(\"%s: OPP not supported by required OPP %pOF (%lu)\\n\",\n\t\t\t __func__, opp->required_opps[i]->np, opp->rates[0]);\n\t\treturn;\n\t}\n}\n\n \nint _opp_add(struct device *dev, struct dev_pm_opp *new_opp,\n\t     struct opp_table *opp_table)\n{\n\tstruct list_head *head;\n\tint ret;\n\n\tmutex_lock(&opp_table->lock);\n\thead = &opp_table->opp_list;\n\n\tret = _opp_is_duplicate(dev, new_opp, opp_table, &head);\n\tif (ret) {\n\t\tmutex_unlock(&opp_table->lock);\n\t\treturn ret;\n\t}\n\n\tlist_add(&new_opp->node, head);\n\tmutex_unlock(&opp_table->lock);\n\n\tnew_opp->opp_table = opp_table;\n\tkref_init(&new_opp->kref);\n\n\topp_debug_create_one(new_opp, opp_table);\n\n\tif (!_opp_supported_by_regulators(new_opp, opp_table)) {\n\t\tnew_opp->available = false;\n\t\tdev_warn(dev, \"%s: OPP not supported by regulators (%lu)\\n\",\n\t\t\t __func__, new_opp->rates[0]);\n\t}\n\n\t \n\tif (lazy_linking_pending(opp_table))\n\t\treturn 0;\n\n\t_required_opps_available(new_opp, opp_table->required_opp_count);\n\n\treturn 0;\n}\n\n \nint _opp_add_v1(struct opp_table *opp_table, struct device *dev,\n\t\tunsigned long freq, long u_volt, bool dynamic)\n{\n\tstruct dev_pm_opp *new_opp;\n\tunsigned long tol;\n\tint ret;\n\n\tif (!assert_single_clk(opp_table))\n\t\treturn -EINVAL;\n\n\tnew_opp = _opp_allocate(opp_table);\n\tif (!new_opp)\n\t\treturn -ENOMEM;\n\n\t \n\tnew_opp->rates[0] = freq;\n\ttol = u_volt * opp_table->voltage_tolerance_v1 / 100;\n\tnew_opp->supplies[0].u_volt = u_volt;\n\tnew_opp->supplies[0].u_volt_min = u_volt - tol;\n\tnew_opp->supplies[0].u_volt_max = u_volt + tol;\n\tnew_opp->available = true;\n\tnew_opp->dynamic = dynamic;\n\n\tret = _opp_add(dev, new_opp, opp_table);\n\tif (ret) {\n\t\t \n\t\tif (ret == -EBUSY)\n\t\t\tret = 0;\n\t\tgoto free_opp;\n\t}\n\n\t \n\tblocking_notifier_call_chain(&opp_table->head, OPP_EVENT_ADD, new_opp);\n\treturn 0;\n\nfree_opp:\n\t_opp_free(new_opp);\n\n\treturn ret;\n}\n\n \nstatic int _opp_set_supported_hw(struct opp_table *opp_table,\n\t\t\t\t const u32 *versions, unsigned int count)\n{\n\t \n\tif (opp_table->supported_hw)\n\t\treturn 0;\n\n\topp_table->supported_hw = kmemdup(versions, count * sizeof(*versions),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!opp_table->supported_hw)\n\t\treturn -ENOMEM;\n\n\topp_table->supported_hw_count = count;\n\n\treturn 0;\n}\n\n \nstatic void _opp_put_supported_hw(struct opp_table *opp_table)\n{\n\tif (opp_table->supported_hw) {\n\t\tkfree(opp_table->supported_hw);\n\t\topp_table->supported_hw = NULL;\n\t\topp_table->supported_hw_count = 0;\n\t}\n}\n\n \nstatic int _opp_set_prop_name(struct opp_table *opp_table, const char *name)\n{\n\t \n\tif (!opp_table->prop_name) {\n\t\topp_table->prop_name = kstrdup(name, GFP_KERNEL);\n\t\tif (!opp_table->prop_name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void _opp_put_prop_name(struct opp_table *opp_table)\n{\n\tif (opp_table->prop_name) {\n\t\tkfree(opp_table->prop_name);\n\t\topp_table->prop_name = NULL;\n\t}\n}\n\n \nstatic int _opp_set_regulators(struct opp_table *opp_table, struct device *dev,\n\t\t\t       const char * const names[])\n{\n\tconst char * const *temp = names;\n\tstruct regulator *reg;\n\tint count = 0, ret, i;\n\n\t \n\twhile (*temp++)\n\t\tcount++;\n\n\tif (!count)\n\t\treturn -EINVAL;\n\n\t \n\tif (opp_table->regulators)\n\t\treturn 0;\n\n\topp_table->regulators = kmalloc_array(count,\n\t\t\t\t\t      sizeof(*opp_table->regulators),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!opp_table->regulators)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; i++) {\n\t\treg = regulator_get_optional(dev, names[i]);\n\t\tif (IS_ERR(reg)) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(reg),\n\t\t\t\t\t    \"%s: no regulator (%s) found\\n\",\n\t\t\t\t\t    __func__, names[i]);\n\t\t\tgoto free_regulators;\n\t\t}\n\n\t\topp_table->regulators[i] = reg;\n\t}\n\n\topp_table->regulator_count = count;\n\n\t \n\tif (count == 1)\n\t\topp_table->config_regulators = _opp_config_regulator_single;\n\n\treturn 0;\n\nfree_regulators:\n\twhile (i != 0)\n\t\tregulator_put(opp_table->regulators[--i]);\n\n\tkfree(opp_table->regulators);\n\topp_table->regulators = NULL;\n\topp_table->regulator_count = -1;\n\n\treturn ret;\n}\n\n \nstatic void _opp_put_regulators(struct opp_table *opp_table)\n{\n\tint i;\n\n\tif (!opp_table->regulators)\n\t\treturn;\n\n\tif (opp_table->enabled) {\n\t\tfor (i = opp_table->regulator_count - 1; i >= 0; i--)\n\t\t\tregulator_disable(opp_table->regulators[i]);\n\t}\n\n\tfor (i = opp_table->regulator_count - 1; i >= 0; i--)\n\t\tregulator_put(opp_table->regulators[i]);\n\n\tkfree(opp_table->regulators);\n\topp_table->regulators = NULL;\n\topp_table->regulator_count = -1;\n}\n\nstatic void _put_clks(struct opp_table *opp_table, int count)\n{\n\tint i;\n\n\tfor (i = count - 1; i >= 0; i--)\n\t\tclk_put(opp_table->clks[i]);\n\n\tkfree(opp_table->clks);\n\topp_table->clks = NULL;\n}\n\n \nstatic int _opp_set_clknames(struct opp_table *opp_table, struct device *dev,\n\t\t\t     const char * const names[],\n\t\t\t     config_clks_t config_clks)\n{\n\tconst char * const *temp = names;\n\tint count = 0, ret, i;\n\tstruct clk *clk;\n\n\t \n\twhile (*temp++)\n\t\tcount++;\n\n\t \n\tif (!count && !names[1])\n\t\tcount = 1;\n\n\t \n\tif (!count || (!config_clks && count > 1))\n\t\treturn -EINVAL;\n\n\t \n\tif (opp_table->clks)\n\t\treturn 0;\n\n\topp_table->clks = kmalloc_array(count, sizeof(*opp_table->clks),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!opp_table->clks)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tclk = clk_get(dev, names[i]);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(clk),\n\t\t\t\t\t    \"%s: Couldn't find clock with name: %s\\n\",\n\t\t\t\t\t    __func__, names[i]);\n\t\t\tgoto free_clks;\n\t\t}\n\n\t\topp_table->clks[i] = clk;\n\t}\n\n\topp_table->clk_count = count;\n\topp_table->config_clks = config_clks;\n\n\t \n\tif (count == 1) {\n\t\tif (!opp_table->config_clks)\n\t\t\topp_table->config_clks = _opp_config_clk_single;\n\n\t\t \n\t\topp_table->clk = opp_table->clks[0];\n\t}\n\n\treturn 0;\n\nfree_clks:\n\t_put_clks(opp_table, i);\n\treturn ret;\n}\n\n \nstatic void _opp_put_clknames(struct opp_table *opp_table)\n{\n\tif (!opp_table->clks)\n\t\treturn;\n\n\topp_table->config_clks = NULL;\n\topp_table->clk = ERR_PTR(-ENODEV);\n\n\t_put_clks(opp_table, opp_table->clk_count);\n}\n\n \nstatic int _opp_set_config_regulators_helper(struct opp_table *opp_table,\n\t\tstruct device *dev, config_regulators_t config_regulators)\n{\n\t \n\tif (!opp_table->config_regulators)\n\t\topp_table->config_regulators = config_regulators;\n\n\treturn 0;\n}\n\n \nstatic void _opp_put_config_regulators_helper(struct opp_table *opp_table)\n{\n\tif (opp_table->config_regulators)\n\t\topp_table->config_regulators = NULL;\n}\n\nstatic void _detach_genpd(struct opp_table *opp_table)\n{\n\tint index;\n\n\tif (!opp_table->genpd_virt_devs)\n\t\treturn;\n\n\tfor (index = 0; index < opp_table->required_opp_count; index++) {\n\t\tif (!opp_table->genpd_virt_devs[index])\n\t\t\tcontinue;\n\n\t\tdev_pm_domain_detach(opp_table->genpd_virt_devs[index], false);\n\t\topp_table->genpd_virt_devs[index] = NULL;\n\t}\n\n\tkfree(opp_table->genpd_virt_devs);\n\topp_table->genpd_virt_devs = NULL;\n}\n\n \nstatic int _opp_attach_genpd(struct opp_table *opp_table, struct device *dev,\n\t\t\tconst char * const *names, struct device ***virt_devs)\n{\n\tstruct device *virt_dev;\n\tint index = 0, ret = -EINVAL;\n\tconst char * const *name = names;\n\n\tif (opp_table->genpd_virt_devs)\n\t\treturn 0;\n\n\t \n\tif (!opp_table->required_opp_count)\n\t\treturn -EPROBE_DEFER;\n\n\tmutex_lock(&opp_table->genpd_virt_dev_lock);\n\n\topp_table->genpd_virt_devs = kcalloc(opp_table->required_opp_count,\n\t\t\t\t\t     sizeof(*opp_table->genpd_virt_devs),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!opp_table->genpd_virt_devs)\n\t\tgoto unlock;\n\n\twhile (*name) {\n\t\tif (index >= opp_table->required_opp_count) {\n\t\t\tdev_err(dev, \"Index can't be greater than required-opp-count - 1, %s (%d : %d)\\n\",\n\t\t\t\t*name, opp_table->required_opp_count, index);\n\t\t\tgoto err;\n\t\t}\n\n\t\tvirt_dev = dev_pm_domain_attach_by_name(dev, *name);\n\t\tif (IS_ERR_OR_NULL(virt_dev)) {\n\t\t\tret = virt_dev ? PTR_ERR(virt_dev) : -ENODEV;\n\t\t\tdev_err(dev, \"Couldn't attach to pm_domain: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\topp_table->genpd_virt_devs[index] = virt_dev;\n\t\tindex++;\n\t\tname++;\n\t}\n\n\tif (virt_devs)\n\t\t*virt_devs = opp_table->genpd_virt_devs;\n\tmutex_unlock(&opp_table->genpd_virt_dev_lock);\n\n\treturn 0;\n\nerr:\n\t_detach_genpd(opp_table);\nunlock:\n\tmutex_unlock(&opp_table->genpd_virt_dev_lock);\n\treturn ret;\n\n}\n\n \nstatic void _opp_detach_genpd(struct opp_table *opp_table)\n{\n\t \n\tmutex_lock(&opp_table->genpd_virt_dev_lock);\n\t_detach_genpd(opp_table);\n\tmutex_unlock(&opp_table->genpd_virt_dev_lock);\n}\n\nstatic void _opp_clear_config(struct opp_config_data *data)\n{\n\tif (data->flags & OPP_CONFIG_GENPD)\n\t\t_opp_detach_genpd(data->opp_table);\n\tif (data->flags & OPP_CONFIG_REGULATOR)\n\t\t_opp_put_regulators(data->opp_table);\n\tif (data->flags & OPP_CONFIG_SUPPORTED_HW)\n\t\t_opp_put_supported_hw(data->opp_table);\n\tif (data->flags & OPP_CONFIG_REGULATOR_HELPER)\n\t\t_opp_put_config_regulators_helper(data->opp_table);\n\tif (data->flags & OPP_CONFIG_PROP_NAME)\n\t\t_opp_put_prop_name(data->opp_table);\n\tif (data->flags & OPP_CONFIG_CLK)\n\t\t_opp_put_clknames(data->opp_table);\n\n\tdev_pm_opp_put_opp_table(data->opp_table);\n\tkfree(data);\n}\n\n \nint dev_pm_opp_set_config(struct device *dev, struct dev_pm_opp_config *config)\n{\n\tstruct opp_table *opp_table;\n\tstruct opp_config_data *data;\n\tunsigned int id;\n\tint ret;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\topp_table = _add_opp_table(dev, false);\n\tif (IS_ERR(opp_table)) {\n\t\tkfree(data);\n\t\treturn PTR_ERR(opp_table);\n\t}\n\n\tdata->opp_table = opp_table;\n\tdata->flags = 0;\n\n\t \n\tif (WARN_ON(!list_empty(&opp_table->opp_list))) {\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\t \n\tif (config->clk_names) {\n\t\tret = _opp_set_clknames(opp_table, dev, config->clk_names,\n\t\t\t\t\tconfig->config_clks);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdata->flags |= OPP_CONFIG_CLK;\n\t} else if (config->config_clks) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif (config->prop_name) {\n\t\tret = _opp_set_prop_name(opp_table, config->prop_name);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdata->flags |= OPP_CONFIG_PROP_NAME;\n\t}\n\n\t \n\tif (config->config_regulators) {\n\t\tret = _opp_set_config_regulators_helper(opp_table, dev,\n\t\t\t\t\t\tconfig->config_regulators);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdata->flags |= OPP_CONFIG_REGULATOR_HELPER;\n\t}\n\n\t \n\tif (config->supported_hw) {\n\t\tret = _opp_set_supported_hw(opp_table, config->supported_hw,\n\t\t\t\t\t    config->supported_hw_count);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdata->flags |= OPP_CONFIG_SUPPORTED_HW;\n\t}\n\n\t \n\tif (config->regulator_names) {\n\t\tret = _opp_set_regulators(opp_table, dev,\n\t\t\t\t\t  config->regulator_names);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdata->flags |= OPP_CONFIG_REGULATOR;\n\t}\n\n\t \n\tif (config->genpd_names) {\n\t\tret = _opp_attach_genpd(opp_table, dev, config->genpd_names,\n\t\t\t\t\tconfig->virt_devs);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdata->flags |= OPP_CONFIG_GENPD;\n\t}\n\n\tret = xa_alloc(&opp_configs, &id, data, XA_LIMIT(1, INT_MAX),\n\t\t       GFP_KERNEL);\n\tif (ret)\n\t\tgoto err;\n\n\treturn id;\n\nerr:\n\t_opp_clear_config(data);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_set_config);\n\n \nvoid dev_pm_opp_clear_config(int token)\n{\n\tstruct opp_config_data *data;\n\n\t \n\tif (unlikely(token <= 0))\n\t\treturn;\n\n\tdata = xa_erase(&opp_configs, token);\n\tif (WARN_ON(!data))\n\t\treturn;\n\n\t_opp_clear_config(data);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_clear_config);\n\nstatic void devm_pm_opp_config_release(void *token)\n{\n\tdev_pm_opp_clear_config((unsigned long)token);\n}\n\n \nint devm_pm_opp_set_config(struct device *dev, struct dev_pm_opp_config *config)\n{\n\tint token = dev_pm_opp_set_config(dev, config);\n\n\tif (token < 0)\n\t\treturn token;\n\n\treturn devm_add_action_or_reset(dev, devm_pm_opp_config_release,\n\t\t\t\t\t(void *) ((unsigned long) token));\n}\nEXPORT_SYMBOL_GPL(devm_pm_opp_set_config);\n\n \nstruct dev_pm_opp *dev_pm_opp_xlate_required_opp(struct opp_table *src_table,\n\t\t\t\t\t\t struct opp_table *dst_table,\n\t\t\t\t\t\t struct dev_pm_opp *src_opp)\n{\n\tstruct dev_pm_opp *opp, *dest_opp = ERR_PTR(-ENODEV);\n\tint i;\n\n\tif (!src_table || !dst_table || !src_opp ||\n\t    !src_table->required_opp_tables)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (lazy_linking_pending(src_table))\n\t\treturn ERR_PTR(-EBUSY);\n\n\tfor (i = 0; i < src_table->required_opp_count; i++) {\n\t\tif (src_table->required_opp_tables[i] == dst_table) {\n\t\t\tmutex_lock(&src_table->lock);\n\n\t\t\tlist_for_each_entry(opp, &src_table->opp_list, node) {\n\t\t\t\tif (opp == src_opp) {\n\t\t\t\t\tdest_opp = opp->required_opps[i];\n\t\t\t\t\tdev_pm_opp_get(dest_opp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmutex_unlock(&src_table->lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_ERR(dest_opp)) {\n\t\tpr_err(\"%s: Couldn't find matching OPP (%p: %p)\\n\", __func__,\n\t\t       src_table, dst_table);\n\t}\n\n\treturn dest_opp;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_xlate_required_opp);\n\n \nint dev_pm_opp_xlate_performance_state(struct opp_table *src_table,\n\t\t\t\t       struct opp_table *dst_table,\n\t\t\t\t       unsigned int pstate)\n{\n\tstruct dev_pm_opp *opp;\n\tint dest_pstate = -EINVAL;\n\tint i;\n\n\t \n\tif (!src_table || !src_table->required_opp_count)\n\t\treturn pstate;\n\n\t \n\tif (unlikely(!src_table->is_genpd || !dst_table->is_genpd)) {\n\t\tpr_err(\"%s: Performance state is only valid for genpds.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (lazy_linking_pending(src_table))\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < src_table->required_opp_count; i++) {\n\t\tif (src_table->required_opp_tables[i]->np == dst_table->np)\n\t\t\tbreak;\n\t}\n\n\tif (unlikely(i == src_table->required_opp_count)) {\n\t\tpr_err(\"%s: Couldn't find matching OPP table (%p: %p)\\n\",\n\t\t       __func__, src_table, dst_table);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&src_table->lock);\n\n\tlist_for_each_entry(opp, &src_table->opp_list, node) {\n\t\tif (opp->level == pstate) {\n\t\t\tdest_pstate = opp->required_opps[i]->level;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tpr_err(\"%s: Couldn't find matching OPP (%p: %p)\\n\", __func__, src_table,\n\t       dst_table);\n\nunlock:\n\tmutex_unlock(&src_table->lock);\n\n\treturn dest_pstate;\n}\n\n \nint dev_pm_opp_add(struct device *dev, unsigned long freq, unsigned long u_volt)\n{\n\tstruct opp_table *opp_table;\n\tint ret;\n\n\topp_table = _add_opp_table(dev, true);\n\tif (IS_ERR(opp_table))\n\t\treturn PTR_ERR(opp_table);\n\n\t \n\topp_table->regulator_count = 1;\n\n\tret = _opp_add_v1(opp_table, dev, freq, u_volt, true);\n\tif (ret)\n\t\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_add);\n\n \nstatic int _opp_set_availability(struct device *dev, unsigned long freq,\n\t\t\t\t bool availability_req)\n{\n\tstruct opp_table *opp_table;\n\tstruct dev_pm_opp *tmp_opp, *opp = ERR_PTR(-ENODEV);\n\tint r = 0;\n\n\t \n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table)) {\n\t\tr = PTR_ERR(opp_table);\n\t\tdev_warn(dev, \"%s: Device OPP not found (%d)\\n\", __func__, r);\n\t\treturn r;\n\t}\n\n\tif (!assert_single_clk(opp_table)) {\n\t\tr = -EINVAL;\n\t\tgoto put_table;\n\t}\n\n\tmutex_lock(&opp_table->lock);\n\n\t \n\tlist_for_each_entry(tmp_opp, &opp_table->opp_list, node) {\n\t\tif (tmp_opp->rates[0] == freq) {\n\t\t\topp = tmp_opp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_ERR(opp)) {\n\t\tr = PTR_ERR(opp);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (opp->available == availability_req)\n\t\tgoto unlock;\n\n\topp->available = availability_req;\n\n\tdev_pm_opp_get(opp);\n\tmutex_unlock(&opp_table->lock);\n\n\t \n\tif (availability_req)\n\t\tblocking_notifier_call_chain(&opp_table->head, OPP_EVENT_ENABLE,\n\t\t\t\t\t     opp);\n\telse\n\t\tblocking_notifier_call_chain(&opp_table->head,\n\t\t\t\t\t     OPP_EVENT_DISABLE, opp);\n\n\tdev_pm_opp_put(opp);\n\tgoto put_table;\n\nunlock:\n\tmutex_unlock(&opp_table->lock);\nput_table:\n\tdev_pm_opp_put_opp_table(opp_table);\n\treturn r;\n}\n\n \nint dev_pm_opp_adjust_voltage(struct device *dev, unsigned long freq,\n\t\t\t      unsigned long u_volt, unsigned long u_volt_min,\n\t\t\t      unsigned long u_volt_max)\n\n{\n\tstruct opp_table *opp_table;\n\tstruct dev_pm_opp *tmp_opp, *opp = ERR_PTR(-ENODEV);\n\tint r = 0;\n\n\t \n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table)) {\n\t\tr = PTR_ERR(opp_table);\n\t\tdev_warn(dev, \"%s: Device OPP not found (%d)\\n\", __func__, r);\n\t\treturn r;\n\t}\n\n\tif (!assert_single_clk(opp_table)) {\n\t\tr = -EINVAL;\n\t\tgoto put_table;\n\t}\n\n\tmutex_lock(&opp_table->lock);\n\n\t \n\tlist_for_each_entry(tmp_opp, &opp_table->opp_list, node) {\n\t\tif (tmp_opp->rates[0] == freq) {\n\t\t\topp = tmp_opp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_ERR(opp)) {\n\t\tr = PTR_ERR(opp);\n\t\tgoto adjust_unlock;\n\t}\n\n\t \n\tif (opp->supplies->u_volt == u_volt)\n\t\tgoto adjust_unlock;\n\n\topp->supplies->u_volt = u_volt;\n\topp->supplies->u_volt_min = u_volt_min;\n\topp->supplies->u_volt_max = u_volt_max;\n\n\tdev_pm_opp_get(opp);\n\tmutex_unlock(&opp_table->lock);\n\n\t \n\tblocking_notifier_call_chain(&opp_table->head, OPP_EVENT_ADJUST_VOLTAGE,\n\t\t\t\t     opp);\n\n\tdev_pm_opp_put(opp);\n\tgoto put_table;\n\nadjust_unlock:\n\tmutex_unlock(&opp_table->lock);\nput_table:\n\tdev_pm_opp_put_opp_table(opp_table);\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_adjust_voltage);\n\n \nint dev_pm_opp_enable(struct device *dev, unsigned long freq)\n{\n\treturn _opp_set_availability(dev, freq, true);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_enable);\n\n \nint dev_pm_opp_disable(struct device *dev, unsigned long freq)\n{\n\treturn _opp_set_availability(dev, freq, false);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_disable);\n\n \nint dev_pm_opp_register_notifier(struct device *dev, struct notifier_block *nb)\n{\n\tstruct opp_table *opp_table;\n\tint ret;\n\n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table))\n\t\treturn PTR_ERR(opp_table);\n\n\tret = blocking_notifier_chain_register(&opp_table->head, nb);\n\n\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dev_pm_opp_register_notifier);\n\n \nint dev_pm_opp_unregister_notifier(struct device *dev,\n\t\t\t\t   struct notifier_block *nb)\n{\n\tstruct opp_table *opp_table;\n\tint ret;\n\n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table))\n\t\treturn PTR_ERR(opp_table);\n\n\tret = blocking_notifier_chain_unregister(&opp_table->head, nb);\n\n\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dev_pm_opp_unregister_notifier);\n\n \nvoid dev_pm_opp_remove_table(struct device *dev)\n{\n\tstruct opp_table *opp_table;\n\n\t \n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table)) {\n\t\tint error = PTR_ERR(opp_table);\n\n\t\tif (error != -ENODEV)\n\t\t\tWARN(1, \"%s: opp_table: %d\\n\",\n\t\t\t     IS_ERR_OR_NULL(dev) ?\n\t\t\t\t\t\"Invalid device\" : dev_name(dev),\n\t\t\t     error);\n\t\treturn;\n\t}\n\n\t \n\tif (_opp_remove_all_static(opp_table))\n\t\tdev_pm_opp_put_opp_table(opp_table);\n\n\t \n\tdev_pm_opp_put_opp_table(opp_table);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_remove_table);\n\n \nint dev_pm_opp_sync_regulators(struct device *dev)\n{\n\tstruct opp_table *opp_table;\n\tstruct regulator *reg;\n\tint i, ret = 0;\n\n\t \n\topp_table = _find_opp_table(dev);\n\tif (IS_ERR(opp_table))\n\t\treturn 0;\n\n\t \n\tif (unlikely(!opp_table->regulators))\n\t\tgoto put_table;\n\n\t \n\tif (!opp_table->enabled)\n\t\tgoto put_table;\n\n\tfor (i = 0; i < opp_table->regulator_count; i++) {\n\t\treg = opp_table->regulators[i];\n\t\tret = regulator_sync_voltage(reg);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nput_table:\n\t \n\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_sync_regulators);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}