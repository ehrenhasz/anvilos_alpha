{
  "module_name": "ti-opp-supply.c",
  "hash_id": "95d4f233a7fa17425a8d5639b9722b5604cf7f8d36945c4b67dd14cf75ba8d39",
  "original_prompt": "Ingested from linux-6.6.14/drivers/opp/ti-opp-supply.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/cpufreq.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n \nstruct ti_opp_supply_optimum_voltage_table {\n\tunsigned int reference_uv;\n\tunsigned int optimized_uv;\n};\n\n \nstruct ti_opp_supply_data {\n\tstruct ti_opp_supply_optimum_voltage_table *vdd_table;\n\tu32 num_vdd_table;\n\tu32 vdd_absolute_max_voltage_uv;\n\tstruct dev_pm_opp_supply old_supplies[2];\n\tstruct dev_pm_opp_supply new_supplies[2];\n};\n\nstatic struct ti_opp_supply_data opp_data;\n\n \nstruct ti_opp_supply_of_data {\n#define OPPDM_EFUSE_CLASS0_OPTIMIZED_VOLTAGE\tBIT(1)\n#define OPPDM_HAS_NO_ABB\t\t\tBIT(2)\n\tconst u8 flags;\n\tconst u32 efuse_voltage_mask;\n\tconst bool efuse_voltage_uv;\n};\n\n \nstatic int _store_optimized_voltages(struct device *dev,\n\t\t\t\t     struct ti_opp_supply_data *data)\n{\n\tvoid __iomem *base;\n\tstruct property *prop;\n\tstruct resource *res;\n\tconst __be32 *val;\n\tint proplen, i;\n\tint ret = 0;\n\tstruct ti_opp_supply_optimum_voltage_table *table;\n\tconst struct ti_opp_supply_of_data *of_data = dev_get_drvdata(dev);\n\n\t \n\tres = platform_get_resource(to_platform_device(dev), IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"Unable to get IO resource\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_map;\n\t}\n\n\tbase = ioremap(res->start, resource_size(res));\n\tif (!base) {\n\t\tdev_err(dev, \"Unable to map Efuse registers\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_map;\n\t}\n\n\t \n\tprop = of_find_property(dev->of_node, \"ti,efuse-settings\", NULL);\n\tif (!prop) {\n\t\tdev_err(dev, \"No 'ti,efuse-settings' property found\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tproplen = prop->length / sizeof(int);\n\tdata->num_vdd_table = proplen / 2;\n\t \n\tif (data->num_vdd_table * 2 * sizeof(int) != prop->length) {\n\t\tdev_err(dev, \"Invalid 'ti,efuse-settings'\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"ti,absolute-max-voltage-uv\",\n\t\t\t\t   &data->vdd_absolute_max_voltage_uv);\n\tif (ret) {\n\t\tdev_err(dev, \"ti,absolute-max-voltage-uv is missing\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttable = kcalloc(data->num_vdd_table, sizeof(*data->vdd_table),\n\t\t\tGFP_KERNEL);\n\tif (!table) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdata->vdd_table = table;\n\n\tval = prop->value;\n\tfor (i = 0; i < data->num_vdd_table; i++, table++) {\n\t\tu32 efuse_offset;\n\t\tu32 tmp;\n\n\t\ttable->reference_uv = be32_to_cpup(val++);\n\t\tefuse_offset = be32_to_cpup(val++);\n\n\t\ttmp = readl(base + efuse_offset);\n\t\ttmp &= of_data->efuse_voltage_mask;\n\t\ttmp >>= __ffs(of_data->efuse_voltage_mask);\n\n\t\ttable->optimized_uv = of_data->efuse_voltage_uv ? tmp :\n\t\t\t\t\ttmp * 1000;\n\n\t\tdev_dbg(dev, \"[%d] efuse=0x%08x volt_table=%d vset=%d\\n\",\n\t\t\ti, efuse_offset, table->reference_uv,\n\t\t\ttable->optimized_uv);\n\n\t\t \n\t\tif (!table->optimized_uv) {\n\t\t\tdev_dbg(dev, \"[%d] efuse=0x%08x volt_table=%d:vset0\\n\",\n\t\t\t\ti, efuse_offset, table->reference_uv);\n\t\t\ttable->optimized_uv = table->reference_uv;\n\t\t}\n\t}\nout:\n\tiounmap(base);\nout_map:\n\treturn ret;\n}\n\n \nstatic void _free_optimized_voltages(struct device *dev,\n\t\t\t\t     struct ti_opp_supply_data *data)\n{\n\tkfree(data->vdd_table);\n\tdata->vdd_table = NULL;\n\tdata->num_vdd_table = 0;\n}\n\n \nstatic int _get_optimal_vdd_voltage(struct device *dev,\n\t\t\t\t    struct ti_opp_supply_data *data,\n\t\t\t\t    int reference_uv)\n{\n\tint i;\n\tstruct ti_opp_supply_optimum_voltage_table *table;\n\n\tif (!data->num_vdd_table)\n\t\treturn reference_uv;\n\n\ttable = data->vdd_table;\n\tif (!table)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < data->num_vdd_table; i++, table++)\n\t\tif (table->reference_uv == reference_uv)\n\t\t\treturn table->optimized_uv;\n\n\t \n\tdev_err_ratelimited(dev, \"%s: Failed optimized voltage match for %d\\n\",\n\t\t\t    __func__, reference_uv);\n\treturn reference_uv;\n}\n\nstatic int _opp_set_voltage(struct device *dev,\n\t\t\t    struct dev_pm_opp_supply *supply,\n\t\t\t    int new_target_uv, struct regulator *reg,\n\t\t\t    char *reg_name)\n{\n\tint ret;\n\tunsigned long vdd_uv, uv_max;\n\n\tif (new_target_uv)\n\t\tvdd_uv = new_target_uv;\n\telse\n\t\tvdd_uv = supply->u_volt;\n\n\t \n\tif (opp_data.vdd_absolute_max_voltage_uv)\n\t\tuv_max = opp_data.vdd_absolute_max_voltage_uv;\n\telse\n\t\tuv_max = supply->u_volt_max;\n\n\tif (vdd_uv > uv_max ||\n\t    vdd_uv < supply->u_volt_min ||\n\t    supply->u_volt_min > uv_max) {\n\t\tdev_warn(dev,\n\t\t\t \"Invalid range voltages [Min:%lu target:%lu Max:%lu]\\n\",\n\t\t\t supply->u_volt_min, vdd_uv, uv_max);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"%s scaling to %luuV[min %luuV max %luuV]\\n\", reg_name,\n\t\tvdd_uv, supply->u_volt_min,\n\t\tuv_max);\n\n\tret = regulator_set_voltage_triplet(reg,\n\t\t\t\t\t    supply->u_volt_min,\n\t\t\t\t\t    vdd_uv,\n\t\t\t\t\t    uv_max);\n\tif (ret) {\n\t\tdev_err(dev, \"%s failed for %luuV[min %luuV max %luuV]\\n\",\n\t\t\treg_name, vdd_uv, supply->u_volt_min,\n\t\t\tuv_max);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ti_opp_config_regulators(struct device *dev,\n\t\t\tstruct dev_pm_opp *old_opp, struct dev_pm_opp *new_opp,\n\t\t\tstruct regulator **regulators, unsigned int count)\n{\n\tstruct dev_pm_opp_supply *old_supply_vdd = &opp_data.old_supplies[0];\n\tstruct dev_pm_opp_supply *old_supply_vbb = &opp_data.old_supplies[1];\n\tstruct dev_pm_opp_supply *new_supply_vdd = &opp_data.new_supplies[0];\n\tstruct dev_pm_opp_supply *new_supply_vbb = &opp_data.new_supplies[1];\n\tstruct regulator *vdd_reg = regulators[0];\n\tstruct regulator *vbb_reg = regulators[1];\n\tunsigned long old_freq, freq;\n\tint vdd_uv;\n\tint ret;\n\n\t \n\tWARN_ON(count != 2);\n\n\t \n\tret = dev_pm_opp_get_supplies(new_opp, opp_data.new_supplies);\n\tWARN_ON(ret);\n\n\told_freq = dev_pm_opp_get_freq(old_opp);\n\tfreq = dev_pm_opp_get_freq(new_opp);\n\tWARN_ON(!old_freq || !freq);\n\n\tvdd_uv = _get_optimal_vdd_voltage(dev, &opp_data,\n\t\t\t\t\t  new_supply_vdd->u_volt);\n\n\tif (new_supply_vdd->u_volt_min < vdd_uv)\n\t\tnew_supply_vdd->u_volt_min = vdd_uv;\n\n\t \n\tif (freq > old_freq) {\n\t\tret = _opp_set_voltage(dev, new_supply_vdd, vdd_uv, vdd_reg,\n\t\t\t\t       \"vdd\");\n\t\tif (ret)\n\t\t\tgoto restore_voltage;\n\n\t\tret = _opp_set_voltage(dev, new_supply_vbb, 0, vbb_reg, \"vbb\");\n\t\tif (ret)\n\t\t\tgoto restore_voltage;\n\t} else {\n\t\tret = _opp_set_voltage(dev, new_supply_vbb, 0, vbb_reg, \"vbb\");\n\t\tif (ret)\n\t\t\tgoto restore_voltage;\n\n\t\tret = _opp_set_voltage(dev, new_supply_vdd, vdd_uv, vdd_reg,\n\t\t\t\t       \"vdd\");\n\t\tif (ret)\n\t\t\tgoto restore_voltage;\n\t}\n\n\treturn 0;\n\nrestore_voltage:\n\t \n\tret = dev_pm_opp_get_supplies(old_opp, opp_data.old_supplies);\n\tWARN_ON(ret);\n\n\t \n\tif (old_supply_vdd->u_volt) {\n\t\tret = _opp_set_voltage(dev, old_supply_vbb, 0, vbb_reg, \"vbb\");\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = _opp_set_voltage(dev, old_supply_vdd, 0, vdd_reg,\n\t\t\t\t       \"vdd\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct ti_opp_supply_of_data omap_generic_of_data = {\n};\n\nstatic const struct ti_opp_supply_of_data omap_omap5_of_data = {\n\t.flags = OPPDM_EFUSE_CLASS0_OPTIMIZED_VOLTAGE,\n\t.efuse_voltage_mask = 0xFFF,\n\t.efuse_voltage_uv = false,\n};\n\nstatic const struct ti_opp_supply_of_data omap_omap5core_of_data = {\n\t.flags = OPPDM_EFUSE_CLASS0_OPTIMIZED_VOLTAGE | OPPDM_HAS_NO_ABB,\n\t.efuse_voltage_mask = 0xFFF,\n\t.efuse_voltage_uv = false,\n};\n\nstatic const struct of_device_id ti_opp_supply_of_match[] = {\n\t{.compatible = \"ti,omap-opp-supply\", .data = &omap_generic_of_data},\n\t{.compatible = \"ti,omap5-opp-supply\", .data = &omap_omap5_of_data},\n\t{.compatible = \"ti,omap5-core-opp-supply\",\n\t .data = &omap_omap5core_of_data},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ti_opp_supply_of_match);\n\nstatic int ti_opp_supply_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *cpu_dev = get_cpu_device(0);\n\tconst struct of_device_id *match;\n\tconst struct ti_opp_supply_of_data *of_data;\n\tint ret = 0;\n\n\tmatch = of_match_device(ti_opp_supply_of_match, dev);\n\tif (!match) {\n\t\t \n\t\tdev_err(dev, \"%s: Unable to match device\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\tif (!match->data) {\n\t\t \n\t\tdev_err(dev, \"%s: Bad data in match\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tof_data = match->data;\n\n\tdev_set_drvdata(dev, (void *)of_data);\n\n\t \n\tif (of_data->flags & OPPDM_EFUSE_CLASS0_OPTIMIZED_VOLTAGE) {\n\t\tret = _store_optimized_voltages(dev, &opp_data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = dev_pm_opp_set_config_regulators(cpu_dev, ti_opp_config_regulators);\n\tif (ret < 0)\n\t\t_free_optimized_voltages(dev, &opp_data);\n\n\treturn ret;\n}\n\nstatic struct platform_driver ti_opp_supply_driver = {\n\t.probe = ti_opp_supply_probe,\n\t.driver = {\n\t\t   .name = \"ti_opp_supply\",\n\t\t   .of_match_table = of_match_ptr(ti_opp_supply_of_match),\n\t\t   },\n};\nmodule_platform_driver(ti_opp_supply_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments OMAP OPP Supply driver\");\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}