{
  "module_name": "of.c",
  "hash_id": "2b1592c94b05553c7d6fa2428c2c59a8a9bc41479e88d9be672b2ec12eba24ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/opp/of.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cpu.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/pm_domain.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/energy_model.h>\n\n#include \"opp.h\"\n\n \nstatic LIST_HEAD(lazy_opp_tables);\n\n \nstatic struct device_node *_opp_of_get_opp_desc_node(struct device_node *np,\n\t\t\t\t\t\t     int index)\n{\n\t \n\treturn of_parse_phandle(np, \"operating-points-v2\", index);\n}\n\n \nstruct device_node *dev_pm_opp_of_get_opp_desc_node(struct device *dev)\n{\n\treturn _opp_of_get_opp_desc_node(dev->of_node, 0);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_of_get_opp_desc_node);\n\nstruct opp_table *_managed_opp(struct device *dev, int index)\n{\n\tstruct opp_table *opp_table, *managed_table = NULL;\n\tstruct device_node *np;\n\n\tnp = _opp_of_get_opp_desc_node(dev->of_node, index);\n\tif (!np)\n\t\treturn NULL;\n\n\tlist_for_each_entry(opp_table, &opp_tables, node) {\n\t\tif (opp_table->np == np) {\n\t\t\t \n\t\t\tif (opp_table->shared_opp == OPP_TABLE_ACCESS_SHARED) {\n\t\t\t\t_get_opp_table_kref(opp_table);\n\t\t\t\tmanaged_table = opp_table;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tof_node_put(np);\n\n\treturn managed_table;\n}\n\n \nstatic struct dev_pm_opp *_find_opp_of_np(struct opp_table *opp_table,\n\t\t\t\t\t  struct device_node *opp_np)\n{\n\tstruct dev_pm_opp *opp;\n\n\tmutex_lock(&opp_table->lock);\n\n\tlist_for_each_entry(opp, &opp_table->opp_list, node) {\n\t\tif (opp->np == opp_np) {\n\t\t\tdev_pm_opp_get(opp);\n\t\t\tmutex_unlock(&opp_table->lock);\n\t\t\treturn opp;\n\t\t}\n\t}\n\n\tmutex_unlock(&opp_table->lock);\n\n\treturn NULL;\n}\n\nstatic struct device_node *of_parse_required_opp(struct device_node *np,\n\t\t\t\t\t\t int index)\n{\n\treturn of_parse_phandle(np, \"required-opps\", index);\n}\n\n \nstatic struct opp_table *_find_table_of_opp_np(struct device_node *opp_np)\n{\n\tstruct opp_table *opp_table;\n\tstruct device_node *opp_table_np;\n\n\topp_table_np = of_get_parent(opp_np);\n\tif (!opp_table_np)\n\t\tgoto err;\n\n\t \n\tof_node_put(opp_table_np);\n\n\tmutex_lock(&opp_table_lock);\n\tlist_for_each_entry(opp_table, &opp_tables, node) {\n\t\tif (opp_table_np == opp_table->np) {\n\t\t\t_get_opp_table_kref(opp_table);\n\t\t\tmutex_unlock(&opp_table_lock);\n\t\t\treturn opp_table;\n\t\t}\n\t}\n\tmutex_unlock(&opp_table_lock);\n\nerr:\n\treturn ERR_PTR(-ENODEV);\n}\n\n \nstatic void _opp_table_free_required_tables(struct opp_table *opp_table)\n{\n\tstruct opp_table **required_opp_tables = opp_table->required_opp_tables;\n\tint i;\n\n\tif (!required_opp_tables)\n\t\treturn;\n\n\tfor (i = 0; i < opp_table->required_opp_count; i++) {\n\t\tif (IS_ERR_OR_NULL(required_opp_tables[i]))\n\t\t\tcontinue;\n\n\t\tdev_pm_opp_put_opp_table(required_opp_tables[i]);\n\t}\n\n\tkfree(required_opp_tables);\n\n\topp_table->required_opp_count = 0;\n\topp_table->required_opp_tables = NULL;\n\n\tmutex_lock(&opp_table_lock);\n\tlist_del(&opp_table->lazy);\n\tmutex_unlock(&opp_table_lock);\n}\n\n \nstatic void _opp_table_alloc_required_tables(struct opp_table *opp_table,\n\t\t\t\t\t     struct device *dev,\n\t\t\t\t\t     struct device_node *opp_np)\n{\n\tstruct opp_table **required_opp_tables;\n\tstruct device_node *required_np, *np;\n\tbool lazy = false;\n\tint count, i;\n\n\t \n\tnp = of_get_next_available_child(opp_np, NULL);\n\tif (!np) {\n\t\tdev_warn(dev, \"Empty OPP table\\n\");\n\n\t\treturn;\n\t}\n\n\tcount = of_count_phandle_with_args(np, \"required-opps\", NULL);\n\tif (count <= 0)\n\t\tgoto put_np;\n\n\trequired_opp_tables = kcalloc(count, sizeof(*required_opp_tables),\n\t\t\t\t      GFP_KERNEL);\n\tif (!required_opp_tables)\n\t\tgoto put_np;\n\n\topp_table->required_opp_tables = required_opp_tables;\n\topp_table->required_opp_count = count;\n\n\tfor (i = 0; i < count; i++) {\n\t\trequired_np = of_parse_required_opp(np, i);\n\t\tif (!required_np)\n\t\t\tgoto free_required_tables;\n\n\t\trequired_opp_tables[i] = _find_table_of_opp_np(required_np);\n\t\tof_node_put(required_np);\n\n\t\tif (IS_ERR(required_opp_tables[i]))\n\t\t\tlazy = true;\n\t}\n\n\t \n\tif (lazy) {\n\t\t \n\t\tmutex_lock(&opp_table_lock);\n\t\tlist_add(&opp_table->lazy, &lazy_opp_tables);\n\t\tmutex_unlock(&opp_table_lock);\n\t}\n\telse\n\t\t_update_set_required_opps(opp_table);\n\n\tgoto put_np;\n\nfree_required_tables:\n\t_opp_table_free_required_tables(opp_table);\nput_np:\n\tof_node_put(np);\n}\n\nvoid _of_init_opp_table(struct opp_table *opp_table, struct device *dev,\n\t\t\tint index)\n{\n\tstruct device_node *np, *opp_np;\n\tu32 val;\n\n\t \n\tnp = of_node_get(dev->of_node);\n\tif (!np)\n\t\treturn;\n\n\tif (!of_property_read_u32(np, \"clock-latency\", &val))\n\t\topp_table->clock_latency_ns_max = val;\n\tof_property_read_u32(np, \"voltage-tolerance\",\n\t\t\t     &opp_table->voltage_tolerance_v1);\n\n\tif (of_property_present(np, \"#power-domain-cells\"))\n\t\topp_table->is_genpd = true;\n\n\t \n\topp_np = _opp_of_get_opp_desc_node(np, index);\n\tof_node_put(np);\n\n\tif (!opp_np)\n\t\treturn;\n\n\tif (of_property_read_bool(opp_np, \"opp-shared\"))\n\t\topp_table->shared_opp = OPP_TABLE_ACCESS_SHARED;\n\telse\n\t\topp_table->shared_opp = OPP_TABLE_ACCESS_EXCLUSIVE;\n\n\topp_table->np = opp_np;\n\n\t_opp_table_alloc_required_tables(opp_table, dev, opp_np);\n}\n\nvoid _of_clear_opp_table(struct opp_table *opp_table)\n{\n\t_opp_table_free_required_tables(opp_table);\n\tof_node_put(opp_table->np);\n}\n\n \nstatic void _of_opp_free_required_opps(struct opp_table *opp_table,\n\t\t\t\t       struct dev_pm_opp *opp)\n{\n\tstruct dev_pm_opp **required_opps = opp->required_opps;\n\tint i;\n\n\tif (!required_opps)\n\t\treturn;\n\n\tfor (i = 0; i < opp_table->required_opp_count; i++) {\n\t\tif (!required_opps[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tdev_pm_opp_put(required_opps[i]);\n\t}\n\n\topp->required_opps = NULL;\n\tkfree(required_opps);\n}\n\nvoid _of_clear_opp(struct opp_table *opp_table, struct dev_pm_opp *opp)\n{\n\t_of_opp_free_required_opps(opp_table, opp);\n\tof_node_put(opp->np);\n}\n\n \nstatic int _of_opp_alloc_required_opps(struct opp_table *opp_table,\n\t\t\t\t       struct dev_pm_opp *opp)\n{\n\tstruct dev_pm_opp **required_opps;\n\tstruct opp_table *required_table;\n\tstruct device_node *np;\n\tint i, ret, count = opp_table->required_opp_count;\n\n\tif (!count)\n\t\treturn 0;\n\n\trequired_opps = kcalloc(count, sizeof(*required_opps), GFP_KERNEL);\n\tif (!required_opps)\n\t\treturn -ENOMEM;\n\n\topp->required_opps = required_opps;\n\n\tfor (i = 0; i < count; i++) {\n\t\trequired_table = opp_table->required_opp_tables[i];\n\n\t\t \n\t\tif (IS_ERR_OR_NULL(required_table))\n\t\t\tcontinue;\n\n\t\tnp = of_parse_required_opp(opp->np, i);\n\t\tif (unlikely(!np)) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto free_required_opps;\n\t\t}\n\n\t\trequired_opps[i] = _find_opp_of_np(required_table, np);\n\t\tof_node_put(np);\n\n\t\tif (!required_opps[i]) {\n\t\t\tpr_err(\"%s: Unable to find required OPP node: %pOF (%d)\\n\",\n\t\t\t       __func__, opp->np, i);\n\t\t\tret = -ENODEV;\n\t\t\tgoto free_required_opps;\n\t\t}\n\t}\n\n\treturn 0;\n\nfree_required_opps:\n\t_of_opp_free_required_opps(opp_table, opp);\n\n\treturn ret;\n}\n\n \nstatic int lazy_link_required_opps(struct opp_table *opp_table,\n\t\t\t\t   struct opp_table *new_table, int index)\n{\n\tstruct device_node *required_np;\n\tstruct dev_pm_opp *opp;\n\n\tlist_for_each_entry(opp, &opp_table->opp_list, node) {\n\t\trequired_np = of_parse_required_opp(opp->np, index);\n\t\tif (unlikely(!required_np))\n\t\t\treturn -ENODEV;\n\n\t\topp->required_opps[index] = _find_opp_of_np(new_table, required_np);\n\t\tof_node_put(required_np);\n\n\t\tif (!opp->required_opps[index]) {\n\t\t\tpr_err(\"%s: Unable to find required OPP node: %pOF (%d)\\n\",\n\t\t\t       __func__, opp->np, index);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void lazy_link_required_opp_table(struct opp_table *new_table)\n{\n\tstruct opp_table *opp_table, *temp, **required_opp_tables;\n\tstruct device_node *required_np, *opp_np, *required_table_np;\n\tstruct dev_pm_opp *opp;\n\tint i, ret;\n\n\tmutex_lock(&opp_table_lock);\n\n\tlist_for_each_entry_safe(opp_table, temp, &lazy_opp_tables, lazy) {\n\t\tbool lazy = false;\n\n\t\t \n\t\topp_np = of_get_next_available_child(opp_table->np, NULL);\n\n\t\tfor (i = 0; i < opp_table->required_opp_count; i++) {\n\t\t\trequired_opp_tables = opp_table->required_opp_tables;\n\n\t\t\t \n\t\t\tif (!IS_ERR(required_opp_tables[i]))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\trequired_np = of_parse_required_opp(opp_np, i);\n\t\t\trequired_table_np = of_get_parent(required_np);\n\n\t\t\tof_node_put(required_table_np);\n\t\t\tof_node_put(required_np);\n\n\t\t\t \n\t\t\tif (required_table_np != new_table->np) {\n\t\t\t\tlazy = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trequired_opp_tables[i] = new_table;\n\t\t\t_get_opp_table_kref(new_table);\n\n\t\t\t \n\t\t\tret = lazy_link_required_opps(opp_table, new_table, i);\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\tlazy = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tof_node_put(opp_np);\n\n\t\t \n\t\tif (!lazy) {\n\t\t\t_update_set_required_opps(opp_table);\n\t\t\tlist_del_init(&opp_table->lazy);\n\n\t\t\tlist_for_each_entry(opp, &opp_table->opp_list, node)\n\t\t\t\t_required_opps_available(opp, opp_table->required_opp_count);\n\t\t}\n\t}\n\n\tmutex_unlock(&opp_table_lock);\n}\n\nstatic int _bandwidth_supported(struct device *dev, struct opp_table *opp_table)\n{\n\tstruct device_node *np, *opp_np;\n\tstruct property *prop;\n\n\tif (!opp_table) {\n\t\tnp = of_node_get(dev->of_node);\n\t\tif (!np)\n\t\t\treturn -ENODEV;\n\n\t\topp_np = _opp_of_get_opp_desc_node(np, 0);\n\t\tof_node_put(np);\n\t} else {\n\t\topp_np = of_node_get(opp_table->np);\n\t}\n\n\t \n\tif (!opp_np)\n\t\treturn 0;\n\n\t \n\tnp = of_get_next_available_child(opp_np, NULL);\n\tof_node_put(opp_np);\n\tif (!np) {\n\t\tdev_err(dev, \"OPP table empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprop = of_find_property(np, \"opp-peak-kBps\", NULL);\n\tof_node_put(np);\n\n\tif (!prop || !prop->length)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint dev_pm_opp_of_find_icc_paths(struct device *dev,\n\t\t\t\t struct opp_table *opp_table)\n{\n\tstruct device_node *np;\n\tint ret, i, count, num_paths;\n\tstruct icc_path **paths;\n\n\tret = _bandwidth_supported(dev, opp_table);\n\tif (ret == -EINVAL)\n\t\treturn 0;  \n\telse if (ret <= 0)\n\t\treturn ret;\n\n\tret = 0;\n\n\tnp = of_node_get(dev->of_node);\n\tif (!np)\n\t\treturn 0;\n\n\tcount = of_count_phandle_with_args(np, \"interconnects\",\n\t\t\t\t\t   \"#interconnect-cells\");\n\tof_node_put(np);\n\tif (count < 0)\n\t\treturn 0;\n\n\t \n\tif (count % 2) {\n\t\tdev_err(dev, \"%s: Invalid interconnects values\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_paths = count / 2;\n\tpaths = kcalloc(num_paths, sizeof(*paths), GFP_KERNEL);\n\tif (!paths)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_paths; i++) {\n\t\tpaths[i] = of_icc_get_by_index(dev, i);\n\t\tif (IS_ERR(paths[i])) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(paths[i]), \"%s: Unable to get path%d\\n\", __func__, i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (opp_table) {\n\t\topp_table->paths = paths;\n\t\topp_table->path_count = num_paths;\n\t\treturn 0;\n\t}\n\nerr:\n\twhile (i--)\n\t\ticc_put(paths[i]);\n\n\tkfree(paths);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_of_find_icc_paths);\n\nstatic bool _opp_is_supported(struct device *dev, struct opp_table *opp_table,\n\t\t\t      struct device_node *np)\n{\n\tunsigned int levels = opp_table->supported_hw_count;\n\tint count, versions, ret, i, j;\n\tu32 val;\n\n\tif (!opp_table->supported_hw) {\n\t\t \n\t\tif (of_property_present(np, \"opp-supported-hw\"))\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tcount = of_property_count_u32_elems(np, \"opp-supported-hw\");\n\tif (count <= 0 || count % levels) {\n\t\tdev_err(dev, \"%s: Invalid opp-supported-hw property (%d)\\n\",\n\t\t\t__func__, count);\n\t\treturn false;\n\t}\n\n\tversions = count / levels;\n\n\t \n\tfor (i = 0; i < versions; i++) {\n\t\tbool supported = true;\n\n\t\tfor (j = 0; j < levels; j++) {\n\t\t\tret = of_property_read_u32_index(np, \"opp-supported-hw\",\n\t\t\t\t\t\t\t i * levels + j, &val);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(dev, \"%s: failed to read opp-supported-hw property at index %d: %d\\n\",\n\t\t\t\t\t __func__, i * levels + j, ret);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!(val & opp_table->supported_hw[j])) {\n\t\t\t\tsupported = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (supported)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u32 *_parse_named_prop(struct dev_pm_opp *opp, struct device *dev,\n\t\t\t      struct opp_table *opp_table,\n\t\t\t      const char *prop_type, bool *triplet)\n{\n\tstruct property *prop = NULL;\n\tchar name[NAME_MAX];\n\tint count, ret;\n\tu32 *out;\n\n\t \n\tif (opp_table->prop_name) {\n\t\tsnprintf(name, sizeof(name), \"opp-%s-%s\", prop_type,\n\t\t\t opp_table->prop_name);\n\t\tprop = of_find_property(opp->np, name, NULL);\n\t}\n\n\tif (!prop) {\n\t\t \n\t\tsnprintf(name, sizeof(name), \"opp-%s\", prop_type);\n\t\tprop = of_find_property(opp->np, name, NULL);\n\t\tif (!prop)\n\t\t\treturn NULL;\n\t}\n\n\tcount = of_property_count_u32_elems(opp->np, name);\n\tif (count < 0) {\n\t\tdev_err(dev, \"%s: Invalid %s property (%d)\\n\", __func__, name,\n\t\t\tcount);\n\t\treturn ERR_PTR(count);\n\t}\n\n\t \n\tif (unlikely(opp_table->regulator_count == -1))\n\t\topp_table->regulator_count = 1;\n\n\tif (count != opp_table->regulator_count &&\n\t    (!triplet || count != opp_table->regulator_count * 3)) {\n\t\tdev_err(dev, \"%s: Invalid number of elements in %s property (%u) with supplies (%d)\\n\",\n\t\t\t__func__, prop_type, count, opp_table->regulator_count);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tout = kmalloc_array(count, sizeof(*out), GFP_KERNEL);\n\tif (!out)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tret = of_property_read_u32_array(opp->np, name, out, count);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: error parsing %s: %d\\n\", __func__, name, ret);\n\t\tkfree(out);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (triplet)\n\t\t*triplet = count != opp_table->regulator_count;\n\n\treturn out;\n}\n\nstatic u32 *opp_parse_microvolt(struct dev_pm_opp *opp, struct device *dev,\n\t\t\t\tstruct opp_table *opp_table, bool *triplet)\n{\n\tu32 *microvolt;\n\n\tmicrovolt = _parse_named_prop(opp, dev, opp_table, \"microvolt\", triplet);\n\tif (IS_ERR(microvolt))\n\t\treturn microvolt;\n\n\tif (!microvolt) {\n\t\t \n\t\tif (list_empty(&opp_table->opp_list) &&\n\t\t    opp_table->regulator_count > 0) {\n\t\t\tdev_err(dev, \"%s: opp-microvolt missing although OPP managing regulators\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\treturn microvolt;\n}\n\nstatic int opp_parse_supplies(struct dev_pm_opp *opp, struct device *dev,\n\t\t\t      struct opp_table *opp_table)\n{\n\tu32 *microvolt, *microamp, *microwatt;\n\tint ret = 0, i, j;\n\tbool triplet;\n\n\tmicrovolt = opp_parse_microvolt(opp, dev, opp_table, &triplet);\n\tif (IS_ERR(microvolt))\n\t\treturn PTR_ERR(microvolt);\n\n\tmicroamp = _parse_named_prop(opp, dev, opp_table, \"microamp\", NULL);\n\tif (IS_ERR(microamp)) {\n\t\tret = PTR_ERR(microamp);\n\t\tgoto free_microvolt;\n\t}\n\n\tmicrowatt = _parse_named_prop(opp, dev, opp_table, \"microwatt\", NULL);\n\tif (IS_ERR(microwatt)) {\n\t\tret = PTR_ERR(microwatt);\n\t\tgoto free_microamp;\n\t}\n\n\t \n\tif (unlikely(opp_table->regulator_count == -1)) {\n\t\topp_table->regulator_count = 0;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0, j = 0; i < opp_table->regulator_count; i++) {\n\t\tif (microvolt) {\n\t\t\topp->supplies[i].u_volt = microvolt[j++];\n\n\t\t\tif (triplet) {\n\t\t\t\topp->supplies[i].u_volt_min = microvolt[j++];\n\t\t\t\topp->supplies[i].u_volt_max = microvolt[j++];\n\t\t\t} else {\n\t\t\t\topp->supplies[i].u_volt_min = opp->supplies[i].u_volt;\n\t\t\t\topp->supplies[i].u_volt_max = opp->supplies[i].u_volt;\n\t\t\t}\n\t\t}\n\n\t\tif (microamp)\n\t\t\topp->supplies[i].u_amp = microamp[i];\n\n\t\tif (microwatt)\n\t\t\topp->supplies[i].u_watt = microwatt[i];\n\t}\n\n\tkfree(microwatt);\nfree_microamp:\n\tkfree(microamp);\nfree_microvolt:\n\tkfree(microvolt);\n\n\treturn ret;\n}\n\n \nvoid dev_pm_opp_of_remove_table(struct device *dev)\n{\n\tdev_pm_opp_remove_table(dev);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_of_remove_table);\n\nstatic int _read_rate(struct dev_pm_opp *new_opp, struct opp_table *opp_table,\n\t\t      struct device_node *np)\n{\n\tstruct property *prop;\n\tint i, count, ret;\n\tu64 *rates;\n\n\tprop = of_find_property(np, \"opp-hz\", NULL);\n\tif (!prop)\n\t\treturn -ENODEV;\n\n\tcount = prop->length / sizeof(u64);\n\tif (opp_table->clk_count != count) {\n\t\tpr_err(\"%s: Count mismatch between opp-hz and clk_count (%d %d)\\n\",\n\t\t       __func__, count, opp_table->clk_count);\n\t\treturn -EINVAL;\n\t}\n\n\trates = kmalloc_array(count, sizeof(*rates), GFP_KERNEL);\n\tif (!rates)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u64_array(np, \"opp-hz\", rates, count);\n\tif (ret) {\n\t\tpr_err(\"%s: Error parsing opp-hz: %d\\n\", __func__, ret);\n\t} else {\n\t\t \n\t\tfor (i = 0; i < count; i++) {\n\t\t\tnew_opp->rates[i] = (unsigned long)rates[i];\n\n\t\t\t \n\t\t\tWARN_ON(new_opp->rates[i] != rates[i]);\n\t\t}\n\t}\n\n\tkfree(rates);\n\n\treturn ret;\n}\n\nstatic int _read_bw(struct dev_pm_opp *new_opp, struct opp_table *opp_table,\n\t\t    struct device_node *np, bool peak)\n{\n\tconst char *name = peak ? \"opp-peak-kBps\" : \"opp-avg-kBps\";\n\tstruct property *prop;\n\tint i, count, ret;\n\tu32 *bw;\n\n\tprop = of_find_property(np, name, NULL);\n\tif (!prop)\n\t\treturn -ENODEV;\n\n\tcount = prop->length / sizeof(u32);\n\tif (opp_table->path_count != count) {\n\t\tpr_err(\"%s: Mismatch between %s and paths (%d %d)\\n\",\n\t\t\t\t__func__, name, count, opp_table->path_count);\n\t\treturn -EINVAL;\n\t}\n\n\tbw = kmalloc_array(count, sizeof(*bw), GFP_KERNEL);\n\tif (!bw)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32_array(np, name, bw, count);\n\tif (ret) {\n\t\tpr_err(\"%s: Error parsing %s: %d\\n\", __func__, name, ret);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (peak)\n\t\t\tnew_opp->bandwidth[i].peak = kBps_to_icc(bw[i]);\n\t\telse\n\t\t\tnew_opp->bandwidth[i].avg = kBps_to_icc(bw[i]);\n\t}\n\nout:\n\tkfree(bw);\n\treturn ret;\n}\n\nstatic int _read_opp_key(struct dev_pm_opp *new_opp,\n\t\t\t struct opp_table *opp_table, struct device_node *np)\n{\n\tbool found = false;\n\tint ret;\n\n\tret = _read_rate(new_opp, opp_table, np);\n\tif (!ret)\n\t\tfound = true;\n\telse if (ret != -ENODEV)\n\t\treturn ret;\n\n\t \n\tret = _read_bw(new_opp, opp_table, np, true);\n\tif (!ret) {\n\t\tfound = true;\n\t\tret = _read_bw(new_opp, opp_table, np, false);\n\t}\n\n\t \n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\n\tif (!of_property_read_u32(np, \"opp-level\", &new_opp->level))\n\t\tfound = true;\n\n\tif (found)\n\t\treturn 0;\n\n\treturn ret;\n}\n\n \nstatic struct dev_pm_opp *_opp_add_static_v2(struct opp_table *opp_table,\n\t\tstruct device *dev, struct device_node *np)\n{\n\tstruct dev_pm_opp *new_opp;\n\tu32 val;\n\tint ret;\n\n\tnew_opp = _opp_allocate(opp_table);\n\tif (!new_opp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = _read_opp_key(new_opp, opp_table, np);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: opp key field not found\\n\", __func__);\n\t\tgoto free_opp;\n\t}\n\n\t \n\tif (!_opp_is_supported(dev, opp_table, np)) {\n\t\tdev_dbg(dev, \"OPP not supported by hardware: %s\\n\",\n\t\t\tof_node_full_name(np));\n\t\tgoto free_opp;\n\t}\n\n\tnew_opp->turbo = of_property_read_bool(np, \"turbo-mode\");\n\n\tnew_opp->np = of_node_get(np);\n\tnew_opp->dynamic = false;\n\tnew_opp->available = true;\n\n\tret = _of_opp_alloc_required_opps(opp_table, new_opp);\n\tif (ret)\n\t\tgoto free_opp;\n\n\tif (!of_property_read_u32(np, \"clock-latency-ns\", &val))\n\t\tnew_opp->clock_latency_ns = val;\n\n\tret = opp_parse_supplies(new_opp, dev, opp_table);\n\tif (ret)\n\t\tgoto free_required_opps;\n\n\tret = _opp_add(dev, new_opp, opp_table);\n\tif (ret) {\n\t\t \n\t\tif (ret == -EBUSY)\n\t\t\tret = 0;\n\t\tgoto free_required_opps;\n\t}\n\n\t \n\tif (of_property_read_bool(np, \"opp-suspend\")) {\n\t\tif (opp_table->suspend_opp) {\n\t\t\t \n\t\t\tif (_opp_compare_key(opp_table, new_opp, opp_table->suspend_opp) == 1) {\n\t\t\t\topp_table->suspend_opp->suspend = false;\n\t\t\t\tnew_opp->suspend = true;\n\t\t\t\topp_table->suspend_opp = new_opp;\n\t\t\t}\n\t\t} else {\n\t\t\tnew_opp->suspend = true;\n\t\t\topp_table->suspend_opp = new_opp;\n\t\t}\n\t}\n\n\tif (new_opp->clock_latency_ns > opp_table->clock_latency_ns_max)\n\t\topp_table->clock_latency_ns_max = new_opp->clock_latency_ns;\n\n\tpr_debug(\"%s: turbo:%d rate:%lu uv:%lu uvmin:%lu uvmax:%lu latency:%lu level:%u\\n\",\n\t\t __func__, new_opp->turbo, new_opp->rates[0],\n\t\t new_opp->supplies[0].u_volt, new_opp->supplies[0].u_volt_min,\n\t\t new_opp->supplies[0].u_volt_max, new_opp->clock_latency_ns,\n\t\t new_opp->level);\n\n\t \n\tblocking_notifier_call_chain(&opp_table->head, OPP_EVENT_ADD, new_opp);\n\treturn new_opp;\n\nfree_required_opps:\n\t_of_opp_free_required_opps(opp_table, new_opp);\nfree_opp:\n\t_opp_free(new_opp);\n\n\treturn ret ? ERR_PTR(ret) : NULL;\n}\n\n \nstatic int _of_add_opp_table_v2(struct device *dev, struct opp_table *opp_table)\n{\n\tstruct device_node *np;\n\tint ret, count = 0;\n\tstruct dev_pm_opp *opp;\n\n\t \n\tmutex_lock(&opp_table->lock);\n\tif (opp_table->parsed_static_opps) {\n\t\topp_table->parsed_static_opps++;\n\t\tmutex_unlock(&opp_table->lock);\n\t\treturn 0;\n\t}\n\n\topp_table->parsed_static_opps = 1;\n\tmutex_unlock(&opp_table->lock);\n\n\t \n\tfor_each_available_child_of_node(opp_table->np, np) {\n\t\topp = _opp_add_static_v2(opp_table, dev, np);\n\t\tif (IS_ERR(opp)) {\n\t\t\tret = PTR_ERR(opp);\n\t\t\tdev_err(dev, \"%s: Failed to add OPP, %d\\n\", __func__,\n\t\t\t\tret);\n\t\t\tof_node_put(np);\n\t\t\tgoto remove_static_opp;\n\t\t} else if (opp) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\t \n\tif (!count) {\n\t\tdev_err(dev, \"%s: no supported OPPs\", __func__);\n\t\tret = -ENOENT;\n\t\tgoto remove_static_opp;\n\t}\n\n\tlazy_link_required_opp_table(opp_table);\n\n\treturn 0;\n\nremove_static_opp:\n\t_opp_remove_all_static(opp_table);\n\n\treturn ret;\n}\n\n \nstatic int _of_add_opp_table_v1(struct device *dev, struct opp_table *opp_table)\n{\n\tconst struct property *prop;\n\tconst __be32 *val;\n\tint nr, ret = 0;\n\n\tmutex_lock(&opp_table->lock);\n\tif (opp_table->parsed_static_opps) {\n\t\topp_table->parsed_static_opps++;\n\t\tmutex_unlock(&opp_table->lock);\n\t\treturn 0;\n\t}\n\n\topp_table->parsed_static_opps = 1;\n\tmutex_unlock(&opp_table->lock);\n\n\tprop = of_find_property(dev->of_node, \"operating-points\", NULL);\n\tif (!prop) {\n\t\tret = -ENODEV;\n\t\tgoto remove_static_opp;\n\t}\n\tif (!prop->value) {\n\t\tret = -ENODATA;\n\t\tgoto remove_static_opp;\n\t}\n\n\t \n\tnr = prop->length / sizeof(u32);\n\tif (nr % 2) {\n\t\tdev_err(dev, \"%s: Invalid OPP table\\n\", __func__);\n\t\tret = -EINVAL;\n\t\tgoto remove_static_opp;\n\t}\n\n\tval = prop->value;\n\twhile (nr) {\n\t\tunsigned long freq = be32_to_cpup(val++) * 1000;\n\t\tunsigned long volt = be32_to_cpup(val++);\n\n\t\tret = _opp_add_v1(opp_table, dev, freq, volt, false);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s: Failed to add OPP %ld (%d)\\n\",\n\t\t\t\t__func__, freq, ret);\n\t\t\tgoto remove_static_opp;\n\t\t}\n\t\tnr -= 2;\n\t}\n\n\treturn 0;\n\nremove_static_opp:\n\t_opp_remove_all_static(opp_table);\n\n\treturn ret;\n}\n\nstatic int _of_add_table_indexed(struct device *dev, int index)\n{\n\tstruct opp_table *opp_table;\n\tint ret, count;\n\n\tif (index) {\n\t\t \n\t\tcount = of_count_phandle_with_args(dev->of_node,\n\t\t\t\t\t\t   \"operating-points-v2\", NULL);\n\t\tif (count == 1)\n\t\t\tindex = 0;\n\t}\n\n\topp_table = _add_opp_table_indexed(dev, index, true);\n\tif (IS_ERR(opp_table))\n\t\treturn PTR_ERR(opp_table);\n\n\t \n\tif (opp_table->np)\n\t\tret = _of_add_opp_table_v2(dev, opp_table);\n\telse\n\t\tret = _of_add_opp_table_v1(dev, opp_table);\n\n\tif (ret)\n\t\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn ret;\n}\n\nstatic void devm_pm_opp_of_table_release(void *data)\n{\n\tdev_pm_opp_of_remove_table(data);\n}\n\nstatic int _devm_of_add_table_indexed(struct device *dev, int index)\n{\n\tint ret;\n\n\tret = _of_add_table_indexed(dev, index);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, devm_pm_opp_of_table_release, dev);\n}\n\n \nint devm_pm_opp_of_add_table(struct device *dev)\n{\n\treturn _devm_of_add_table_indexed(dev, 0);\n}\nEXPORT_SYMBOL_GPL(devm_pm_opp_of_add_table);\n\n \nint dev_pm_opp_of_add_table(struct device *dev)\n{\n\treturn _of_add_table_indexed(dev, 0);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_of_add_table);\n\n \nint dev_pm_opp_of_add_table_indexed(struct device *dev, int index)\n{\n\treturn _of_add_table_indexed(dev, index);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_of_add_table_indexed);\n\n \nint devm_pm_opp_of_add_table_indexed(struct device *dev, int index)\n{\n\treturn _devm_of_add_table_indexed(dev, index);\n}\nEXPORT_SYMBOL_GPL(devm_pm_opp_of_add_table_indexed);\n\n \n\n \nvoid dev_pm_opp_of_cpumask_remove_table(const struct cpumask *cpumask)\n{\n\t_dev_pm_opp_cpumask_remove_table(cpumask, -1);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_of_cpumask_remove_table);\n\n \nint dev_pm_opp_of_cpumask_add_table(const struct cpumask *cpumask)\n{\n\tstruct device *cpu_dev;\n\tint cpu, ret;\n\n\tif (WARN_ON(cpumask_empty(cpumask)))\n\t\treturn -ENODEV;\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tcpu_dev = get_cpu_device(cpu);\n\t\tif (!cpu_dev) {\n\t\t\tpr_err(\"%s: failed to get cpu%d device\\n\", __func__,\n\t\t\t       cpu);\n\t\t\tret = -ENODEV;\n\t\t\tgoto remove_table;\n\t\t}\n\n\t\tret = dev_pm_opp_of_add_table(cpu_dev);\n\t\tif (ret) {\n\t\t\t \n\t\t\tpr_debug(\"%s: couldn't find opp table for cpu:%d, %d\\n\",\n\t\t\t\t __func__, cpu, ret);\n\n\t\t\tgoto remove_table;\n\t\t}\n\t}\n\n\treturn 0;\n\nremove_table:\n\t \n\t_dev_pm_opp_cpumask_remove_table(cpumask, cpu);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_of_cpumask_add_table);\n\n \n \nint dev_pm_opp_of_get_sharing_cpus(struct device *cpu_dev,\n\t\t\t\t   struct cpumask *cpumask)\n{\n\tstruct device_node *np, *tmp_np, *cpu_np;\n\tint cpu, ret = 0;\n\n\t \n\tnp = dev_pm_opp_of_get_opp_desc_node(cpu_dev);\n\tif (!np) {\n\t\tdev_dbg(cpu_dev, \"%s: Couldn't find opp node.\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\tcpumask_set_cpu(cpu_dev->id, cpumask);\n\n\t \n\tif (!of_property_read_bool(np, \"opp-shared\"))\n\t\tgoto put_cpu_node;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == cpu_dev->id)\n\t\t\tcontinue;\n\n\t\tcpu_np = of_cpu_device_node_get(cpu);\n\t\tif (!cpu_np) {\n\t\t\tdev_err(cpu_dev, \"%s: failed to get cpu%d node\\n\",\n\t\t\t\t__func__, cpu);\n\t\t\tret = -ENOENT;\n\t\t\tgoto put_cpu_node;\n\t\t}\n\n\t\t \n\t\ttmp_np = _opp_of_get_opp_desc_node(cpu_np, 0);\n\t\tof_node_put(cpu_np);\n\t\tif (!tmp_np) {\n\t\t\tpr_err(\"%pOF: Couldn't find opp node\\n\", cpu_np);\n\t\t\tret = -ENOENT;\n\t\t\tgoto put_cpu_node;\n\t\t}\n\n\t\t \n\t\tif (np == tmp_np)\n\t\t\tcpumask_set_cpu(cpu, cpumask);\n\n\t\tof_node_put(tmp_np);\n\t}\n\nput_cpu_node:\n\tof_node_put(np);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_of_get_sharing_cpus);\n\n \nint of_get_required_opp_performance_state(struct device_node *np, int index)\n{\n\tstruct dev_pm_opp *opp;\n\tstruct device_node *required_np;\n\tstruct opp_table *opp_table;\n\tint pstate = -EINVAL;\n\n\trequired_np = of_parse_required_opp(np, index);\n\tif (!required_np)\n\t\treturn -ENODEV;\n\n\topp_table = _find_table_of_opp_np(required_np);\n\tif (IS_ERR(opp_table)) {\n\t\tpr_err(\"%s: Failed to find required OPP table %pOF: %ld\\n\",\n\t\t       __func__, np, PTR_ERR(opp_table));\n\t\tgoto put_required_np;\n\t}\n\n\t \n\tif (unlikely(!opp_table->is_genpd)) {\n\t\tpr_err(\"%s: Performance state is only valid for genpds.\\n\", __func__);\n\t\tgoto put_required_np;\n\t}\n\n\topp = _find_opp_of_np(opp_table, required_np);\n\tif (opp) {\n\t\tpstate = opp->level;\n\t\tdev_pm_opp_put(opp);\n\t}\n\n\tdev_pm_opp_put_opp_table(opp_table);\n\nput_required_np:\n\tof_node_put(required_np);\n\n\treturn pstate;\n}\nEXPORT_SYMBOL_GPL(of_get_required_opp_performance_state);\n\n \nstruct device_node *dev_pm_opp_get_of_node(struct dev_pm_opp *opp)\n{\n\tif (IS_ERR_OR_NULL(opp)) {\n\t\tpr_err(\"%s: Invalid parameters\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\treturn of_node_get(opp->np);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_of_node);\n\n \nstatic int __maybe_unused\n_get_dt_power(struct device *dev, unsigned long *uW, unsigned long *kHz)\n{\n\tstruct dev_pm_opp *opp;\n\tunsigned long opp_freq, opp_power;\n\n\t \n\topp_freq = *kHz * 1000;\n\topp = dev_pm_opp_find_freq_ceil(dev, &opp_freq);\n\tif (IS_ERR(opp))\n\t\treturn -EINVAL;\n\n\topp_power = dev_pm_opp_get_power(opp);\n\tdev_pm_opp_put(opp);\n\tif (!opp_power)\n\t\treturn -EINVAL;\n\n\t*kHz = opp_freq / 1000;\n\t*uW = opp_power;\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused _get_power(struct device *dev, unsigned long *uW,\n\t\t\t\t     unsigned long *kHz)\n{\n\tstruct dev_pm_opp *opp;\n\tstruct device_node *np;\n\tunsigned long mV, Hz;\n\tu32 cap;\n\tu64 tmp;\n\tint ret;\n\n\tnp = of_node_get(dev->of_node);\n\tif (!np)\n\t\treturn -EINVAL;\n\n\tret = of_property_read_u32(np, \"dynamic-power-coefficient\", &cap);\n\tof_node_put(np);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tHz = *kHz * 1000;\n\topp = dev_pm_opp_find_freq_ceil(dev, &Hz);\n\tif (IS_ERR(opp))\n\t\treturn -EINVAL;\n\n\tmV = dev_pm_opp_get_voltage(opp) / 1000;\n\tdev_pm_opp_put(opp);\n\tif (!mV)\n\t\treturn -EINVAL;\n\n\ttmp = (u64)cap * mV * mV * (Hz / 1000000);\n\t \n\tdo_div(tmp, 1000000);\n\n\t*uW = (unsigned long)tmp;\n\t*kHz = Hz / 1000;\n\n\treturn 0;\n}\n\nstatic bool _of_has_opp_microwatt_property(struct device *dev)\n{\n\tunsigned long power, freq = 0;\n\tstruct dev_pm_opp *opp;\n\n\t \n\topp = dev_pm_opp_find_freq_ceil(dev, &freq);\n\tif (IS_ERR(opp))\n\t\treturn false;\n\n\tpower = dev_pm_opp_get_power(opp);\n\tdev_pm_opp_put(opp);\n\tif (!power)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nint dev_pm_opp_of_register_em(struct device *dev, struct cpumask *cpus)\n{\n\tstruct em_data_callback em_cb;\n\tstruct device_node *np;\n\tint ret, nr_opp;\n\tu32 cap;\n\n\tif (IS_ERR_OR_NULL(dev)) {\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\tnr_opp = dev_pm_opp_get_opp_count(dev);\n\tif (nr_opp <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\t \n\tif (_of_has_opp_microwatt_property(dev)) {\n\t\tEM_SET_ACTIVE_POWER_CB(em_cb, _get_dt_power);\n\t\tgoto register_em;\n\t}\n\n\tnp = of_node_get(dev->of_node);\n\tif (!np) {\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\t \n\tret = of_property_read_u32(np, \"dynamic-power-coefficient\", &cap);\n\tof_node_put(np);\n\tif (ret || !cap) {\n\t\tdev_dbg(dev, \"Couldn't find proper 'dynamic-power-coefficient' in DT\\n\");\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\tEM_SET_ACTIVE_POWER_CB(em_cb, _get_power);\n\nregister_em:\n\tret = em_dev_register_perf_domain(dev, nr_opp, &em_cb, cpus, true);\n\tif (ret)\n\t\tgoto failed;\n\n\treturn 0;\n\nfailed:\n\tdev_dbg(dev, \"Couldn't register Energy Model %d\\n\", ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_of_register_em);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}