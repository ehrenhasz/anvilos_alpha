{
  "module_name": "debugfs.c",
  "hash_id": "9aaec26ee5f6bf342b862f84a17f574c550c72c769d2d6875df0ba6d115ba44b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/opp/debugfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/init.h>\n#include <linux/limits.h>\n#include <linux/slab.h>\n\n#include \"opp.h\"\n\nstatic struct dentry *rootdir;\n\nstatic void opp_set_dev_name(const struct device *dev, char *name)\n{\n\tif (dev->parent)\n\t\tsnprintf(name, NAME_MAX, \"%s-%s\", dev_name(dev->parent),\n\t\t\t dev_name(dev));\n\telse\n\t\tsnprintf(name, NAME_MAX, \"%s\", dev_name(dev));\n}\n\nvoid opp_debug_remove_one(struct dev_pm_opp *opp)\n{\n\tdebugfs_remove_recursive(opp->dentry);\n}\n\nstatic ssize_t bw_name_read(struct file *fp, char __user *userbuf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct icc_path *path = fp->private_data;\n\tchar buf[64];\n\tint i;\n\n\ti = scnprintf(buf, sizeof(buf), \"%.62s\\n\", icc_get_name(path));\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, i);\n}\n\nstatic const struct file_operations bw_name_fops = {\n\t.open = simple_open,\n\t.read = bw_name_read,\n\t.llseek = default_llseek,\n};\n\nstatic void opp_debug_create_bw(struct dev_pm_opp *opp,\n\t\t\t\tstruct opp_table *opp_table,\n\t\t\t\tstruct dentry *pdentry)\n{\n\tstruct dentry *d;\n\tchar name[11];\n\tint i;\n\n\tfor (i = 0; i < opp_table->path_count; i++) {\n\t\tsnprintf(name, sizeof(name), \"icc-path-%.1d\", i);\n\n\t\t \n\t\td = debugfs_create_dir(name, pdentry);\n\n\t\tdebugfs_create_file(\"name\", S_IRUGO, d, opp_table->paths[i],\n\t\t\t\t    &bw_name_fops);\n\t\tdebugfs_create_u32(\"peak_bw\", S_IRUGO, d,\n\t\t\t\t   &opp->bandwidth[i].peak);\n\t\tdebugfs_create_u32(\"avg_bw\", S_IRUGO, d,\n\t\t\t\t   &opp->bandwidth[i].avg);\n\t}\n}\n\nstatic void opp_debug_create_clks(struct dev_pm_opp *opp,\n\t\t\t\t  struct opp_table *opp_table,\n\t\t\t\t  struct dentry *pdentry)\n{\n\tchar name[12];\n\tint i;\n\n\tif (opp_table->clk_count == 1) {\n\t\tdebugfs_create_ulong(\"rate_hz\", S_IRUGO, pdentry, &opp->rates[0]);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < opp_table->clk_count; i++) {\n\t\tsnprintf(name, sizeof(name), \"rate_hz_%d\", i);\n\t\tdebugfs_create_ulong(name, S_IRUGO, pdentry, &opp->rates[i]);\n\t}\n}\n\nstatic void opp_debug_create_supplies(struct dev_pm_opp *opp,\n\t\t\t\t      struct opp_table *opp_table,\n\t\t\t\t      struct dentry *pdentry)\n{\n\tstruct dentry *d;\n\tint i;\n\n\tfor (i = 0; i < opp_table->regulator_count; i++) {\n\t\tchar name[15];\n\n\t\tsnprintf(name, sizeof(name), \"supply-%d\", i);\n\n\t\t \n\t\td = debugfs_create_dir(name, pdentry);\n\n\t\tdebugfs_create_ulong(\"u_volt_target\", S_IRUGO, d,\n\t\t\t\t     &opp->supplies[i].u_volt);\n\n\t\tdebugfs_create_ulong(\"u_volt_min\", S_IRUGO, d,\n\t\t\t\t     &opp->supplies[i].u_volt_min);\n\n\t\tdebugfs_create_ulong(\"u_volt_max\", S_IRUGO, d,\n\t\t\t\t     &opp->supplies[i].u_volt_max);\n\n\t\tdebugfs_create_ulong(\"u_amp\", S_IRUGO, d,\n\t\t\t\t     &opp->supplies[i].u_amp);\n\n\t\tdebugfs_create_ulong(\"u_watt\", S_IRUGO, d,\n\t\t\t\t     &opp->supplies[i].u_watt);\n\t}\n}\n\nvoid opp_debug_create_one(struct dev_pm_opp *opp, struct opp_table *opp_table)\n{\n\tstruct dentry *pdentry = opp_table->dentry;\n\tstruct dentry *d;\n\tunsigned long id;\n\tchar name[25];\t \n\n\t \n\tif (likely(opp_table->clk_count == 1 && opp->rates[0]))\n\t\tid = opp->rates[0];\n\telse\n\t\tid = _get_opp_count(opp_table);\n\n\tsnprintf(name, sizeof(name), \"opp:%lu\", id);\n\n\t \n\td = debugfs_create_dir(name, pdentry);\n\n\tdebugfs_create_bool(\"available\", S_IRUGO, d, &opp->available);\n\tdebugfs_create_bool(\"dynamic\", S_IRUGO, d, &opp->dynamic);\n\tdebugfs_create_bool(\"turbo\", S_IRUGO, d, &opp->turbo);\n\tdebugfs_create_bool(\"suspend\", S_IRUGO, d, &opp->suspend);\n\tdebugfs_create_u32(\"level\", S_IRUGO, d, &opp->level);\n\tdebugfs_create_ulong(\"clock_latency_ns\", S_IRUGO, d,\n\t\t\t     &opp->clock_latency_ns);\n\n\topp->of_name = of_node_full_name(opp->np);\n\tdebugfs_create_str(\"of_name\", S_IRUGO, d, (char **)&opp->of_name);\n\n\topp_debug_create_clks(opp, opp_table, d);\n\topp_debug_create_supplies(opp, opp_table, d);\n\topp_debug_create_bw(opp, opp_table, d);\n\n\topp->dentry = d;\n}\n\nstatic void opp_list_debug_create_dir(struct opp_device *opp_dev,\n\t\t\t\t      struct opp_table *opp_table)\n{\n\tconst struct device *dev = opp_dev->dev;\n\tstruct dentry *d;\n\n\topp_set_dev_name(dev, opp_table->dentry_name);\n\n\t \n\td = debugfs_create_dir(opp_table->dentry_name, rootdir);\n\n\topp_dev->dentry = d;\n\topp_table->dentry = d;\n}\n\nstatic void opp_list_debug_create_link(struct opp_device *opp_dev,\n\t\t\t\t       struct opp_table *opp_table)\n{\n\tchar name[NAME_MAX];\n\n\topp_set_dev_name(opp_dev->dev, name);\n\n\t \n\topp_dev->dentry = debugfs_create_symlink(name, rootdir,\n\t\t\t\t\t\t opp_table->dentry_name);\n}\n\n \nvoid opp_debug_register(struct opp_device *opp_dev, struct opp_table *opp_table)\n{\n\tif (opp_table->dentry)\n\t\topp_list_debug_create_link(opp_dev, opp_table);\n\telse\n\t\topp_list_debug_create_dir(opp_dev, opp_table);\n}\n\nstatic void opp_migrate_dentry(struct opp_device *opp_dev,\n\t\t\t       struct opp_table *opp_table)\n{\n\tstruct opp_device *new_dev = NULL, *iter;\n\tconst struct device *dev;\n\tstruct dentry *dentry;\n\n\t \n\tlist_for_each_entry(iter, &opp_table->dev_list, node)\n\t\tif (iter != opp_dev) {\n\t\t\tnew_dev = iter;\n\t\t\tbreak;\n\t\t}\n\n\tBUG_ON(!new_dev);\n\n\t \n\tdev = new_dev->dev;\n\tdebugfs_remove_recursive(new_dev->dentry);\n\n\topp_set_dev_name(dev, opp_table->dentry_name);\n\n\tdentry = debugfs_rename(rootdir, opp_dev->dentry, rootdir,\n\t\t\t\topp_table->dentry_name);\n\tif (IS_ERR(dentry)) {\n\t\tdev_err(dev, \"%s: Failed to rename link from: %s to %s\\n\",\n\t\t\t__func__, dev_name(opp_dev->dev), dev_name(dev));\n\t\treturn;\n\t}\n\n\tnew_dev->dentry = dentry;\n\topp_table->dentry = dentry;\n}\n\n \nvoid opp_debug_unregister(struct opp_device *opp_dev,\n\t\t\t  struct opp_table *opp_table)\n{\n\tif (opp_dev->dentry == opp_table->dentry) {\n\t\t \n\t\tif (!list_is_singular(&opp_table->dev_list)) {\n\t\t\topp_migrate_dentry(opp_dev, opp_table);\n\t\t\tgoto out;\n\t\t}\n\t\topp_table->dentry = NULL;\n\t}\n\n\tdebugfs_remove_recursive(opp_dev->dentry);\n\nout:\n\topp_dev->dentry = NULL;\n}\n\nstatic int __init opp_debug_init(void)\n{\n\t \n\trootdir = debugfs_create_dir(\"opp\", NULL);\n\n\treturn 0;\n}\ncore_initcall(opp_debug_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}