{
  "module_name": "cpu.c",
  "hash_id": "778a3fe3c2d8d91c6fcbdccc1dd52c24120950bb8a21657e97caccb779288290",
  "original_prompt": "Ingested from linux-6.6.14/drivers/opp/cpu.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\n#include \"opp.h\"\n\n#ifdef CONFIG_CPU_FREQ\n\n \nint dev_pm_opp_init_cpufreq_table(struct device *dev,\n\t\t\t\t  struct cpufreq_frequency_table **opp_table)\n{\n\tstruct dev_pm_opp *opp;\n\tstruct cpufreq_frequency_table *freq_table = NULL;\n\tint i, max_opps, ret = 0;\n\tunsigned long rate;\n\n\tmax_opps = dev_pm_opp_get_opp_count(dev);\n\tif (max_opps <= 0)\n\t\treturn max_opps ? max_opps : -ENODATA;\n\n\tfreq_table = kcalloc((max_opps + 1), sizeof(*freq_table), GFP_KERNEL);\n\tif (!freq_table)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, rate = 0; i < max_opps; i++, rate++) {\n\t\t \n\t\topp = dev_pm_opp_find_freq_ceil(dev, &rate);\n\t\tif (IS_ERR(opp)) {\n\t\t\tret = PTR_ERR(opp);\n\t\t\tgoto out;\n\t\t}\n\t\tfreq_table[i].driver_data = i;\n\t\tfreq_table[i].frequency = rate / 1000;\n\n\t\t \n\t\tif (dev_pm_opp_is_turbo(opp))\n\t\t\tfreq_table[i].flags = CPUFREQ_BOOST_FREQ;\n\n\t\tdev_pm_opp_put(opp);\n\t}\n\n\tfreq_table[i].driver_data = i;\n\tfreq_table[i].frequency = CPUFREQ_TABLE_END;\n\n\t*opp_table = &freq_table[0];\n\nout:\n\tif (ret)\n\t\tkfree(freq_table);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_init_cpufreq_table);\n\n \nvoid dev_pm_opp_free_cpufreq_table(struct device *dev,\n\t\t\t\t   struct cpufreq_frequency_table **opp_table)\n{\n\tif (!opp_table)\n\t\treturn;\n\n\tkfree(*opp_table);\n\t*opp_table = NULL;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_free_cpufreq_table);\n#endif\t \n\nvoid _dev_pm_opp_cpumask_remove_table(const struct cpumask *cpumask,\n\t\t\t\t      int last_cpu)\n{\n\tstruct device *cpu_dev;\n\tint cpu;\n\n\tWARN_ON(cpumask_empty(cpumask));\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tif (cpu == last_cpu)\n\t\t\tbreak;\n\n\t\tcpu_dev = get_cpu_device(cpu);\n\t\tif (!cpu_dev) {\n\t\t\tpr_err(\"%s: failed to get cpu%d device\\n\", __func__,\n\t\t\t       cpu);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_pm_opp_remove_table(cpu_dev);\n\t}\n}\n\n \nvoid dev_pm_opp_cpumask_remove_table(const struct cpumask *cpumask)\n{\n\t_dev_pm_opp_cpumask_remove_table(cpumask, -1);\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_cpumask_remove_table);\n\n \nint dev_pm_opp_set_sharing_cpus(struct device *cpu_dev,\n\t\t\t\tconst struct cpumask *cpumask)\n{\n\tstruct opp_device *opp_dev;\n\tstruct opp_table *opp_table;\n\tstruct device *dev;\n\tint cpu, ret = 0;\n\n\topp_table = _find_opp_table(cpu_dev);\n\tif (IS_ERR(opp_table))\n\t\treturn PTR_ERR(opp_table);\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tif (cpu == cpu_dev->id)\n\t\t\tcontinue;\n\n\t\tdev = get_cpu_device(cpu);\n\t\tif (!dev) {\n\t\t\tdev_err(cpu_dev, \"%s: failed to get cpu%d device\\n\",\n\t\t\t\t__func__, cpu);\n\t\t\tcontinue;\n\t\t}\n\n\t\topp_dev = _add_opp_dev(dev, opp_table);\n\t\tif (!opp_dev) {\n\t\t\tdev_err(dev, \"%s: failed to add opp-dev for cpu%d device\\n\",\n\t\t\t\t__func__, cpu);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\topp_table->shared_opp = OPP_TABLE_ACCESS_SHARED;\n\t}\n\n\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_set_sharing_cpus);\n\n \nint dev_pm_opp_get_sharing_cpus(struct device *cpu_dev, struct cpumask *cpumask)\n{\n\tstruct opp_device *opp_dev;\n\tstruct opp_table *opp_table;\n\tint ret = 0;\n\n\topp_table = _find_opp_table(cpu_dev);\n\tif (IS_ERR(opp_table))\n\t\treturn PTR_ERR(opp_table);\n\n\tif (opp_table->shared_opp == OPP_TABLE_ACCESS_UNKNOWN) {\n\t\tret = -EINVAL;\n\t\tgoto put_opp_table;\n\t}\n\n\tcpumask_clear(cpumask);\n\n\tif (opp_table->shared_opp == OPP_TABLE_ACCESS_SHARED) {\n\t\tmutex_lock(&opp_table->lock);\n\t\tlist_for_each_entry(opp_dev, &opp_table->dev_list, node)\n\t\t\tcpumask_set_cpu(opp_dev->dev->id, cpumask);\n\t\tmutex_unlock(&opp_table->lock);\n\t} else {\n\t\tcpumask_set_cpu(cpu_dev->id, cpumask);\n\t}\n\nput_opp_table:\n\tdev_pm_opp_put_opp_table(opp_table);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dev_pm_opp_get_sharing_cpus);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}