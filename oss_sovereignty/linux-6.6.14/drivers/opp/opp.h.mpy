{
  "module_name": "opp.h",
  "hash_id": "533f2410c6a2875c5bfb59d4a213e574ce190fc55a74e40a0ba0c6f20378aa0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/opp/opp.h",
  "human_readable_source": " \n \n\n#ifndef __DRIVER_OPP_H__\n#define __DRIVER_OPP_H__\n\n#include <linux/device.h>\n#include <linux/interconnect.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/limits.h>\n#include <linux/pm_opp.h>\n#include <linux/notifier.h>\n\nstruct clk;\nstruct regulator;\n\n \nextern struct mutex opp_table_lock;\n\nextern struct list_head opp_tables;\n\n \n#define OPP_CONFIG_CLK\t\t\tBIT(0)\n#define OPP_CONFIG_REGULATOR\t\tBIT(1)\n#define OPP_CONFIG_REGULATOR_HELPER\tBIT(2)\n#define OPP_CONFIG_PROP_NAME\t\tBIT(3)\n#define OPP_CONFIG_SUPPORTED_HW\t\tBIT(4)\n#define OPP_CONFIG_GENPD\t\tBIT(5)\n\n \nstruct opp_config_data {\n\tstruct opp_table *opp_table;\n\tunsigned int flags;\n};\n\n \n\n \nstruct dev_pm_opp {\n\tstruct list_head node;\n\tstruct kref kref;\n\n\tbool available;\n\tbool dynamic;\n\tbool turbo;\n\tbool suspend;\n\tbool removed;\n\tunsigned long *rates;\n\tunsigned int level;\n\n\tstruct dev_pm_opp_supply *supplies;\n\tstruct dev_pm_opp_icc_bw *bandwidth;\n\n\tunsigned long clock_latency_ns;\n\n\tstruct dev_pm_opp **required_opps;\n\tstruct opp_table *opp_table;\n\n\tstruct device_node *np;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *dentry;\n\tconst char *of_name;\n#endif\n};\n\n \nstruct opp_device {\n\tstruct list_head node;\n\tconst struct device *dev;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *dentry;\n#endif\n};\n\nenum opp_table_access {\n\tOPP_TABLE_ACCESS_UNKNOWN = 0,\n\tOPP_TABLE_ACCESS_EXCLUSIVE = 1,\n\tOPP_TABLE_ACCESS_SHARED = 2,\n};\n\n \nstruct opp_table {\n\tstruct list_head node, lazy;\n\n\tstruct blocking_notifier_head head;\n\tstruct list_head dev_list;\n\tstruct list_head opp_list;\n\tstruct kref kref;\n\tstruct mutex lock;\n\n\tstruct device_node *np;\n\tunsigned long clock_latency_ns_max;\n\n\t \n\tunsigned int voltage_tolerance_v1;\n\n\tunsigned int parsed_static_opps;\n\tenum opp_table_access shared_opp;\n\tunsigned long rate_clk_single;\n\tstruct dev_pm_opp *current_opp;\n\tstruct dev_pm_opp *suspend_opp;\n\n\tstruct mutex genpd_virt_dev_lock;\n\tstruct device **genpd_virt_devs;\n\tstruct opp_table **required_opp_tables;\n\tunsigned int required_opp_count;\n\n\tunsigned int *supported_hw;\n\tunsigned int supported_hw_count;\n\tconst char *prop_name;\n\tconfig_clks_t config_clks;\n\tstruct clk **clks;\n\tstruct clk *clk;\n\tint clk_count;\n\tconfig_regulators_t config_regulators;\n\tstruct regulator **regulators;\n\tint regulator_count;\n\tstruct icc_path **paths;\n\tunsigned int path_count;\n\tbool enabled;\n\tbool is_genpd;\n\tint (*set_required_opps)(struct device *dev,\n\t\tstruct opp_table *opp_table, struct dev_pm_opp *opp, bool scaling_down);\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *dentry;\n\tchar dentry_name[NAME_MAX];\n#endif\n};\n\n \nvoid dev_pm_opp_get(struct dev_pm_opp *opp);\nbool _opp_remove_all_static(struct opp_table *opp_table);\nvoid _get_opp_table_kref(struct opp_table *opp_table);\nint _get_opp_count(struct opp_table *opp_table);\nstruct opp_table *_find_opp_table(struct device *dev);\nstruct opp_device *_add_opp_dev(const struct device *dev, struct opp_table *opp_table);\nstruct dev_pm_opp *_opp_allocate(struct opp_table *opp_table);\nvoid _opp_free(struct dev_pm_opp *opp);\nint _opp_compare_key(struct opp_table *opp_table, struct dev_pm_opp *opp1, struct dev_pm_opp *opp2);\nint _opp_add(struct device *dev, struct dev_pm_opp *new_opp, struct opp_table *opp_table);\nint _opp_add_v1(struct opp_table *opp_table, struct device *dev, unsigned long freq, long u_volt, bool dynamic);\nvoid _dev_pm_opp_cpumask_remove_table(const struct cpumask *cpumask, int last_cpu);\nstruct opp_table *_add_opp_table_indexed(struct device *dev, int index, bool getclk);\nvoid _put_opp_list_kref(struct opp_table *opp_table);\nvoid _required_opps_available(struct dev_pm_opp *opp, int count);\nvoid _update_set_required_opps(struct opp_table *opp_table);\n\nstatic inline bool lazy_linking_pending(struct opp_table *opp_table)\n{\n\treturn unlikely(!list_empty(&opp_table->lazy));\n}\n\n#ifdef CONFIG_OF\nvoid _of_init_opp_table(struct opp_table *opp_table, struct device *dev, int index);\nvoid _of_clear_opp_table(struct opp_table *opp_table);\nstruct opp_table *_managed_opp(struct device *dev, int index);\nvoid _of_clear_opp(struct opp_table *opp_table, struct dev_pm_opp *opp);\n#else\nstatic inline void _of_init_opp_table(struct opp_table *opp_table, struct device *dev, int index) {}\nstatic inline void _of_clear_opp_table(struct opp_table *opp_table) {}\nstatic inline struct opp_table *_managed_opp(struct device *dev, int index) { return NULL; }\nstatic inline void _of_clear_opp(struct opp_table *opp_table, struct dev_pm_opp *opp) {}\n#endif\n\n#ifdef CONFIG_DEBUG_FS\nvoid opp_debug_remove_one(struct dev_pm_opp *opp);\nvoid opp_debug_create_one(struct dev_pm_opp *opp, struct opp_table *opp_table);\nvoid opp_debug_register(struct opp_device *opp_dev, struct opp_table *opp_table);\nvoid opp_debug_unregister(struct opp_device *opp_dev, struct opp_table *opp_table);\n#else\nstatic inline void opp_debug_remove_one(struct dev_pm_opp *opp) {}\n\nstatic inline void opp_debug_create_one(struct dev_pm_opp *opp,\n\t\t\t\t\tstruct opp_table *opp_table) { }\n\nstatic inline void opp_debug_register(struct opp_device *opp_dev,\n\t\t\t\t      struct opp_table *opp_table) { }\n\nstatic inline void opp_debug_unregister(struct opp_device *opp_dev,\n\t\t\t\t\tstruct opp_table *opp_table)\n{ }\n#endif\t\t \n\n#endif\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}