{
  "module_name": "uctrl.c",
  "hash_id": "f4adb33d1bca50b9f9a4763ba9e83bfcb13cc10bd850bd64be7e69b3c72dbcc5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sbus/char/uctrl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ioport.h>\n#include <linux/miscdevice.h>\n#include <linux/mm.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <asm/openprom.h>\n#include <asm/oplib.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n\n#define DEBUG 1\n#ifdef DEBUG\n#define dprintk(x) printk x\n#else\n#define dprintk(x)\n#endif\n\nstruct uctrl_regs {\n\tu32 uctrl_intr;\n\tu32 uctrl_data;\n\tu32 uctrl_stat;\n\tu32 uctrl_xxx[5];\n};\n\nstruct ts102_regs {\n\tu32 card_a_intr;\n\tu32 card_a_stat;\n\tu32 card_a_ctrl;\n\tu32 card_a_xxx;\n\tu32 card_b_intr;\n\tu32 card_b_stat;\n\tu32 card_b_ctrl;\n\tu32 card_b_xxx;\n\tu32 uctrl_intr;\n\tu32 uctrl_data;\n\tu32 uctrl_stat;\n\tu32 uctrl_xxx;\n\tu32 ts102_xxx[4];\n};\n\n \n#define UCTRL_INTR_TXE_REQ         0x01     \n#define UCTRL_INTR_TXNF_REQ        0x02     \n#define UCTRL_INTR_RXNE_REQ        0x04     \n#define UCTRL_INTR_RXO_REQ         0x08     \n#define UCTRL_INTR_TXE_MSK         0x10     \n#define UCTRL_INTR_TXNF_MSK        0x20     \n#define UCTRL_INTR_RXNE_MSK        0x40     \n#define UCTRL_INTR_RXO_MSK         0x80     \n\n \n#define UCTRL_STAT_TXE_STA         0x01     \n#define UCTRL_STAT_TXNF_STA        0x02     \n#define UCTRL_STAT_RXNE_STA        0x04     \n#define UCTRL_STAT_RXO_STA         0x08     \n\nstatic DEFINE_MUTEX(uctrl_mutex);\nstatic const char *uctrl_extstatus[16] = {\n        \"main power available\",\n        \"internal battery attached\",\n        \"external battery attached\",\n        \"external VGA attached\",\n        \"external keyboard attached\",\n        \"external mouse attached\",\n        \"lid down\",\n        \"internal battery currently charging\",\n        \"external battery currently charging\",\n        \"internal battery currently discharging\",\n        \"external battery currently discharging\",\n};\n\n \nstruct uctrl_txn {\n\tu8 opcode;\n\tu8 inbits;\n\tu8 outbits;\n\tu8 *inbuf;\n\tu8 *outbuf;\n};\n\nstruct uctrl_status {\n\tu8 current_temp;  \n\tu8 reset_status;  \n\tu16 event_status;  \n\tu16 error_status;  \n\tu16 external_status;  \n\tu8 internal_charge;  \n\tu8 external_charge;  \n\tu16 control_lcd;  \n\tu8 control_bitport;  \n\tu8 speaker_volume;  \n\tu8 control_tft_brightness;  \n\tu8 control_kbd_repeat_delay;  \n\tu8 control_kbd_repeat_period;  \n\tu8 control_screen_contrast;  \n};\n\nenum uctrl_opcode {\n  READ_SERIAL_NUMBER=0x1,\n  READ_ETHERNET_ADDRESS=0x2,\n  READ_HARDWARE_VERSION=0x3,\n  READ_MICROCONTROLLER_VERSION=0x4,\n  READ_MAX_TEMPERATURE=0x5,\n  READ_MIN_TEMPERATURE=0x6,\n  READ_CURRENT_TEMPERATURE=0x7,\n  READ_SYSTEM_VARIANT=0x8,\n  READ_POWERON_CYCLES=0x9,\n  READ_POWERON_SECONDS=0xA,\n  READ_RESET_STATUS=0xB,\n  READ_EVENT_STATUS=0xC,\n  READ_REAL_TIME_CLOCK=0xD,\n  READ_EXTERNAL_VGA_PORT=0xE,\n  READ_MICROCONTROLLER_ROM_CHECKSUM=0xF,\n  READ_ERROR_STATUS=0x10,\n  READ_EXTERNAL_STATUS=0x11,\n  READ_USER_CONFIGURATION_AREA=0x12,\n  READ_MICROCONTROLLER_VOLTAGE=0x13,\n  READ_INTERNAL_BATTERY_VOLTAGE=0x14,\n  READ_DCIN_VOLTAGE=0x15,\n  READ_HORIZONTAL_POINTER_VOLTAGE=0x16,\n  READ_VERTICAL_POINTER_VOLTAGE=0x17,\n  READ_INTERNAL_BATTERY_CHARGE_LEVEL=0x18,\n  READ_EXTERNAL_BATTERY_CHARGE_LEVEL=0x19,\n  READ_REAL_TIME_CLOCK_ALARM=0x1A,\n  READ_EVENT_STATUS_NO_RESET=0x1B,\n  READ_INTERNAL_KEYBOARD_LAYOUT=0x1C,\n  READ_EXTERNAL_KEYBOARD_LAYOUT=0x1D,\n  READ_EEPROM_STATUS=0x1E,\n  CONTROL_LCD=0x20,\n  CONTROL_BITPORT=0x21,\n  SPEAKER_VOLUME=0x23,\n  CONTROL_TFT_BRIGHTNESS=0x24,\n  CONTROL_WATCHDOG=0x25,\n  CONTROL_FACTORY_EEPROM_AREA=0x26,\n  CONTROL_KBD_TIME_UNTIL_REPEAT=0x28,\n  CONTROL_KBD_TIME_BETWEEN_REPEATS=0x29,\n  CONTROL_TIMEZONE=0x2A,\n  CONTROL_MARK_SPACE_RATIO=0x2B,\n  CONTROL_DIAGNOSTIC_MODE=0x2E,\n  CONTROL_SCREEN_CONTRAST=0x2F,\n  RING_BELL=0x30,\n  SET_DIAGNOSTIC_STATUS=0x32,\n  CLEAR_KEY_COMBINATION_TABLE=0x33,\n  PERFORM_SOFTWARE_RESET=0x34,\n  SET_REAL_TIME_CLOCK=0x35,\n  RECALIBRATE_POINTING_STICK=0x36,\n  SET_BELL_FREQUENCY=0x37,\n  SET_INTERNAL_BATTERY_CHARGE_RATE=0x39,\n  SET_EXTERNAL_BATTERY_CHARGE_RATE=0x3A,\n  SET_REAL_TIME_CLOCK_ALARM=0x3B,\n  READ_EEPROM=0x40,\n  WRITE_EEPROM=0x41,\n  WRITE_TO_STATUS_DISPLAY=0x42,\n  DEFINE_SPECIAL_CHARACTER=0x43,\n  DEFINE_KEY_COMBINATION_ENTRY=0x50,\n  DEFINE_STRING_TABLE_ENTRY=0x51,\n  DEFINE_STATUS_SCREEN_DISPLAY=0x52,\n  PERFORM_EMU_COMMANDS=0x64,\n  READ_EMU_REGISTER=0x65,\n  WRITE_EMU_REGISTER=0x66,\n  READ_EMU_RAM=0x67,\n  WRITE_EMU_RAM=0x68,\n  READ_BQ_REGISTER=0x69,\n  WRITE_BQ_REGISTER=0x6A,\n  SET_USER_PASSWORD=0x70,\n  VERIFY_USER_PASSWORD=0x71,\n  GET_SYSTEM_PASSWORD_KEY=0x72,\n  VERIFY_SYSTEM_PASSWORD=0x73,\n  POWER_OFF=0x82,\n  POWER_RESTART=0x83,\n};\n\nstatic struct uctrl_driver {\n\tstruct uctrl_regs __iomem *regs;\n\tint irq;\n\tint pending;\n\tstruct uctrl_status status;\n} *global_driver;\n\nstatic void uctrl_get_event_status(struct uctrl_driver *);\nstatic void uctrl_get_external_status(struct uctrl_driver *);\n\nstatic long\nuctrl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int\nuctrl_open(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&uctrl_mutex);\n\tuctrl_get_event_status(global_driver);\n\tuctrl_get_external_status(global_driver);\n\tmutex_unlock(&uctrl_mutex);\n\treturn 0;\n}\n\nstatic irqreturn_t uctrl_interrupt(int irq, void *dev_id)\n{\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct file_operations uctrl_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.unlocked_ioctl =\tuctrl_ioctl,\n\t.open =\t\tuctrl_open,\n};\n\nstatic struct miscdevice uctrl_dev = {\n\tUCTRL_MINOR,\n\t\"uctrl\",\n\t&uctrl_fops\n};\n\n \n#define WRITEUCTLDATA(value) \\\n{ \\\n  unsigned int i; \\\n  for (i = 0; i < 10000; i++) { \\\n      if (UCTRL_STAT_TXNF_STA & sbus_readl(&driver->regs->uctrl_stat)) \\\n      break; \\\n  } \\\n  dprintk((\"write data 0x%02x\\n\", value)); \\\n  sbus_writel(value, &driver->regs->uctrl_data); \\\n}\n\n \n#define READUCTLDATA(value) \\\n{ \\\n  unsigned int i; \\\n  value = 0; \\\n  for (i = 0; i < 10000; i++) { \\\n      if ((UCTRL_STAT_RXNE_STA & sbus_readl(&driver->regs->uctrl_stat)) == 0) \\\n      break; \\\n    udelay(1); \\\n  } \\\n  value = sbus_readl(&driver->regs->uctrl_data); \\\n  dprintk((\"read data 0x%02x\\n\", value)); \\\n  sbus_writel(UCTRL_STAT_RXNE_STA, &driver->regs->uctrl_stat); \\\n}\n\nstatic void uctrl_do_txn(struct uctrl_driver *driver, struct uctrl_txn *txn)\n{\n\tint stat, incnt, outcnt, bytecnt, intr;\n\tu32 byte;\n\n\tstat = sbus_readl(&driver->regs->uctrl_stat);\n\tintr = sbus_readl(&driver->regs->uctrl_intr);\n\tsbus_writel(stat, &driver->regs->uctrl_stat);\n\n\tdprintk((\"interrupt stat 0x%x int 0x%x\\n\", stat, intr));\n\n\tincnt = txn->inbits;\n\toutcnt = txn->outbits;\n\tbyte = (txn->opcode << 8);\n\tWRITEUCTLDATA(byte);\n\n\tbytecnt = 0;\n\twhile (incnt > 0) {\n\t\tbyte = (txn->inbuf[bytecnt] << 8);\n\t\tWRITEUCTLDATA(byte);\n\t\tincnt--;\n\t\tbytecnt++;\n\t}\n\n\t \n\tREADUCTLDATA(byte);\n\tdprintk((\"ack was %x\\n\", (byte >> 8)));\n\n\tbytecnt = 0;\n\twhile (outcnt > 0) {\n\t\tREADUCTLDATA(byte);\n\t\ttxn->outbuf[bytecnt] = (byte >> 8);\n\t\tdprintk((\"set byte to %02x\\n\", byte));\n\t\toutcnt--;\n\t\tbytecnt++;\n\t}\n}\n\nstatic void uctrl_get_event_status(struct uctrl_driver *driver)\n{\n\tstruct uctrl_txn txn;\n\tu8 outbits[2];\n\n\ttxn.opcode = READ_EVENT_STATUS;\n\ttxn.inbits = 0;\n\ttxn.outbits = 2;\n\ttxn.inbuf = NULL;\n\ttxn.outbuf = outbits;\n\n\tuctrl_do_txn(driver, &txn);\n\n\tdprintk((\"bytes %x %x\\n\", (outbits[0] & 0xff), (outbits[1] & 0xff)));\n\tdriver->status.event_status = \n\t\t((outbits[0] & 0xff) << 8) | (outbits[1] & 0xff);\n\tdprintk((\"ev is %x\\n\", driver->status.event_status));\n}\n\nstatic void uctrl_get_external_status(struct uctrl_driver *driver)\n{\n\tstruct uctrl_txn txn;\n\tu8 outbits[2];\n\tint i, v;\n\n\ttxn.opcode = READ_EXTERNAL_STATUS;\n\ttxn.inbits = 0;\n\ttxn.outbits = 2;\n\ttxn.inbuf = NULL;\n\ttxn.outbuf = outbits;\n\n\tuctrl_do_txn(driver, &txn);\n\n\tdprintk((\"bytes %x %x\\n\", (outbits[0] & 0xff), (outbits[1] & 0xff)));\n\tdriver->status.external_status = \n\t\t((outbits[0] * 256) + (outbits[1]));\n\tdprintk((\"ex is %x\\n\", driver->status.external_status));\n\tv = driver->status.external_status;\n\tfor (i = 0; v != 0; i++, v >>= 1) {\n\t\tif (v & 1) {\n\t\t\tdprintk((\"%s%s\", \" \", uctrl_extstatus[i]));\n\t\t}\n\t}\n\tdprintk((\"\\n\"));\n\t\n}\n\nstatic int uctrl_probe(struct platform_device *op)\n{\n\tstruct uctrl_driver *p;\n\tint err = -ENOMEM;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p) {\n\t\tprintk(KERN_ERR \"uctrl: Unable to allocate device struct.\\n\");\n\t\tgoto out;\n\t}\n\n\tp->regs = of_ioremap(&op->resource[0], 0,\n\t\t\t     resource_size(&op->resource[0]),\n\t\t\t     \"uctrl\");\n\tif (!p->regs) {\n\t\tprintk(KERN_ERR \"uctrl: Unable to map registers.\\n\");\n\t\tgoto out_free;\n\t}\n\n\tp->irq = op->archdata.irqs[0];\n\terr = request_irq(p->irq, uctrl_interrupt, 0, \"uctrl\", p);\n\tif (err) {\n\t\tprintk(KERN_ERR \"uctrl: Unable to register irq.\\n\");\n\t\tgoto out_iounmap;\n\t}\n\n\terr = misc_register(&uctrl_dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"uctrl: Unable to register misc device.\\n\");\n\t\tgoto out_free_irq;\n\t}\n\n\tsbus_writel(UCTRL_INTR_RXNE_REQ|UCTRL_INTR_RXNE_MSK, &p->regs->uctrl_intr);\n\tprintk(KERN_INFO \"%pOF: uctrl regs[0x%p] (irq %d)\\n\",\n\t       op->dev.of_node, p->regs, p->irq);\n\tuctrl_get_event_status(p);\n\tuctrl_get_external_status(p);\n\n\tdev_set_drvdata(&op->dev, p);\n\tglobal_driver = p;\n\nout:\n\treturn err;\n\nout_free_irq:\n\tfree_irq(p->irq, p);\n\nout_iounmap:\n\tof_iounmap(&op->resource[0], p->regs, resource_size(&op->resource[0]));\n\nout_free:\n\tkfree(p);\n\tgoto out;\n}\n\nstatic int uctrl_remove(struct platform_device *op)\n{\n\tstruct uctrl_driver *p = dev_get_drvdata(&op->dev);\n\n\tif (p) {\n\t\tmisc_deregister(&uctrl_dev);\n\t\tfree_irq(p->irq, p);\n\t\tof_iounmap(&op->resource[0], p->regs, resource_size(&op->resource[0]));\n\t\tkfree(p);\n\t}\n\treturn 0;\n}\n\nstatic const struct of_device_id uctrl_match[] = {\n\t{\n\t\t.name = \"uctrl\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, uctrl_match);\n\nstatic struct platform_driver uctrl_driver = {\n\t.driver = {\n\t\t.name = \"uctrl\",\n\t\t.of_match_table = uctrl_match,\n\t},\n\t.probe\t\t= uctrl_probe,\n\t.remove\t\t= uctrl_remove,\n};\n\n\nmodule_platform_driver(uctrl_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}