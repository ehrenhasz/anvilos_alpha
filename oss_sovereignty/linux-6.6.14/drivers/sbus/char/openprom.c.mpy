{
  "module_name": "openprom.c",
  "hash_id": "cb815a43719e150f6622790f721fff45a2e631b37123c7ef1362abc9c51ecd8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sbus/char/openprom.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/miscdevice.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <asm/oplib.h>\n#include <asm/prom.h>\n#include <linux/uaccess.h>\n#include <asm/openpromio.h>\n#ifdef CONFIG_PCI\n#include <linux/pci.h>\n#endif\n\nMODULE_AUTHOR(\"Thomas K. Dyas (tdyas@noc.rutgers.edu) and Eddie C. Dost  (ecd@skynet.be)\");\nMODULE_DESCRIPTION(\"OPENPROM Configuration Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.0\");\nMODULE_ALIAS_MISCDEV(SUN_OPENPROM_MINOR);\n\n \ntypedef struct openprom_private_data\n{\n\tstruct device_node *current_node;  \n\tstruct device_node *lastnode;  \n} DATA;\n\n \nstatic DEFINE_MUTEX(openprom_mutex);\nstatic struct device_node *options_node;\n\n \nstatic int copyin(struct openpromio __user *info, struct openpromio **opp_p)\n{\n\tunsigned int bufsize;\n\n\tif (!info || !opp_p)\n\t\treturn -EFAULT;\n\n\tif (get_user(bufsize, &info->oprom_size))\n\t\treturn -EFAULT;\n\n\tif (bufsize == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (bufsize > OPROMMAXPARAM)\n\t\tbufsize = OPROMMAXPARAM;\n\n\tif (!(*opp_p = kzalloc(sizeof(int) + bufsize + 1, GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(&(*opp_p)->oprom_array,\n\t\t\t   &info->oprom_array, bufsize)) {\n\t\tkfree(*opp_p);\n\t\treturn -EFAULT;\n\t}\n\treturn bufsize;\n}\n\nstatic int getstrings(struct openpromio __user *info, struct openpromio **opp_p)\n{\n\tint n, bufsize;\n\tchar c;\n\n\tif (!info || !opp_p)\n\t\treturn -EFAULT;\n\n\tif (!(*opp_p = kzalloc(sizeof(int) + OPROMMAXPARAM + 1, GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\t(*opp_p)->oprom_size = 0;\n\n\tn = bufsize = 0;\n\twhile ((n < 2) && (bufsize < OPROMMAXPARAM)) {\n\t\tif (get_user(c, &info->oprom_array[bufsize])) {\n\t\t\tkfree(*opp_p);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (c == '\\0')\n\t\t\tn++;\n\t\t(*opp_p)->oprom_array[bufsize++] = c;\n\t}\n\tif (!n) {\n\t\tkfree(*opp_p);\n\t\treturn -EINVAL;\n\t}\n\treturn bufsize;\n}\n\n \nstatic int copyout(void __user *info, struct openpromio *opp, int len)\n{\n\tif (copy_to_user(info, opp, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int opromgetprop(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize)\n{\n\tconst void *pval;\n\tint len;\n\n\tif (!dp ||\n\t    !(pval = of_get_property(dp, op->oprom_array, &len)) ||\n\t    len <= 0 || len > bufsize)\n\t\treturn copyout(argp, op, sizeof(int));\n\n\tmemcpy(op->oprom_array, pval, len);\n\top->oprom_array[len] = '\\0';\n\top->oprom_size = len;\n\n\treturn copyout(argp, op, sizeof(int) + bufsize);\n}\n\nstatic int opromnxtprop(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize)\n{\n\tstruct property *prop;\n\tint len;\n\n\tif (!dp)\n\t\treturn copyout(argp, op, sizeof(int));\n\tif (op->oprom_array[0] == '\\0') {\n\t\tprop = dp->properties;\n\t\tif (!prop)\n\t\t\treturn copyout(argp, op, sizeof(int));\n\t\tlen = strlen(prop->name);\n\t} else {\n\t\tprop = of_find_property(dp, op->oprom_array, NULL);\n\n\t\tif (!prop ||\n\t\t    !prop->next ||\n\t\t    (len = strlen(prop->next->name)) + 1 > bufsize)\n\t\t\treturn copyout(argp, op, sizeof(int));\n\n\t\tprop = prop->next;\n\t}\n\n\tmemcpy(op->oprom_array, prop->name, len);\n\top->oprom_array[len] = '\\0';\n\top->oprom_size = ++len;\n\n\treturn copyout(argp, op, sizeof(int) + bufsize);\n}\n\nstatic int opromsetopt(struct device_node *dp, struct openpromio *op, int bufsize)\n{\n\tchar *buf = op->oprom_array + strlen(op->oprom_array) + 1;\n\tint len = op->oprom_array + bufsize - buf;\n\n\treturn of_set_property(options_node, op->oprom_array, buf, len);\n}\n\nstatic int opromnext(void __user *argp, unsigned int cmd, struct device_node *dp, struct openpromio *op, int bufsize, DATA *data)\n{\n\tphandle ph;\n\n\tBUILD_BUG_ON(sizeof(phandle) != sizeof(int));\n\n\tif (bufsize < sizeof(phandle))\n\t\treturn -EINVAL;\n\n\tph = *((int *) op->oprom_array);\n\tif (ph) {\n\t\tdp = of_find_node_by_phandle(ph);\n\t\tif (!dp)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (cmd) {\n\t\tcase OPROMNEXT:\n\t\t\tdp = dp->sibling;\n\t\t\tbreak;\n\n\t\tcase OPROMCHILD:\n\t\t\tdp = dp->child;\n\t\t\tbreak;\n\n\t\tcase OPROMSETCUR:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tif (cmd != OPROMNEXT)\n\t\t\treturn -EINVAL;\n\n\t\tdp = of_find_node_by_path(\"/\");\n\t}\n\n\tph = 0;\n\tif (dp)\n\t\tph = dp->phandle;\n\n\tdata->current_node = dp;\n\t*((int *) op->oprom_array) = ph;\n\top->oprom_size = sizeof(phandle);\n\n\treturn copyout(argp, op, bufsize + sizeof(int));\n}\n\nstatic int oprompci2node(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize, DATA *data)\n{\n\tint err = -EINVAL;\n\n\tif (bufsize >= 2*sizeof(int)) {\n#ifdef CONFIG_PCI\n\t\tstruct pci_dev *pdev;\n\t\tstruct device_node *dp;\n\n\t\tpdev = pci_get_domain_bus_and_slot(0,\n\t\t\t\t\t\t((int *) op->oprom_array)[0],\n\t\t\t\t\t\t((int *) op->oprom_array)[1]);\n\n\t\tdp = pci_device_to_OF_node(pdev);\n\t\tdata->current_node = dp;\n\t\t*((int *)op->oprom_array) = dp->phandle;\n\t\top->oprom_size = sizeof(int);\n\t\terr = copyout(argp, op, bufsize + sizeof(int));\n\n\t\tpci_dev_put(pdev);\n#endif\n\t}\n\n\treturn err;\n}\n\nstatic int oprompath2node(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize, DATA *data)\n{\n\tphandle ph = 0;\n\n\tdp = of_find_node_by_path(op->oprom_array);\n\tif (dp)\n\t\tph = dp->phandle;\n\tdata->current_node = dp;\n\t*((int *)op->oprom_array) = ph;\n\top->oprom_size = sizeof(int);\n\n\treturn copyout(argp, op, bufsize + sizeof(int));\n}\n\nstatic int opromgetbootargs(void __user *argp, struct openpromio *op, int bufsize)\n{\n\tchar *buf = saved_command_line;\n\tint len = strlen(buf);\n\n\tif (len > bufsize)\n\t\treturn -EINVAL;\n\n\tstrcpy(op->oprom_array, buf);\n\top->oprom_size = len;\n\n\treturn copyout(argp, op, bufsize + sizeof(int));\n}\n\n \nstatic long openprom_sunos_ioctl(struct file * file,\n\t\t\t\t unsigned int cmd, unsigned long arg,\n\t\t\t\t struct device_node *dp)\n{\n\tDATA *data = file->private_data;\n\tstruct openpromio *opp = NULL;\n\tint bufsize, error = 0;\n\tstatic int cnt;\n\tvoid __user *argp = (void __user *)arg;\n\n\tif (cmd == OPROMSETOPT)\n\t\tbufsize = getstrings(argp, &opp);\n\telse\n\t\tbufsize = copyin(argp, &opp);\n\n\tif (bufsize < 0)\n\t\treturn bufsize;\n\n\tmutex_lock(&openprom_mutex);\n\n\tswitch (cmd) {\n\tcase OPROMGETOPT:\n\tcase OPROMGETPROP:\n\t\terror = opromgetprop(argp, dp, opp, bufsize);\n\t\tbreak;\n\n\tcase OPROMNXTOPT:\n\tcase OPROMNXTPROP:\n\t\terror = opromnxtprop(argp, dp, opp, bufsize);\n\t\tbreak;\n\n\tcase OPROMSETOPT:\n\tcase OPROMSETOPT2:\n\t\terror = opromsetopt(dp, opp, bufsize);\n\t\tbreak;\n\n\tcase OPROMNEXT:\n\tcase OPROMCHILD:\n\tcase OPROMSETCUR:\n\t\terror = opromnext(argp, cmd, dp, opp, bufsize, data);\n\t\tbreak;\n\n\tcase OPROMPCI2NODE:\n\t\terror = oprompci2node(argp, dp, opp, bufsize, data);\n\t\tbreak;\n\n\tcase OPROMPATH2NODE:\n\t\terror = oprompath2node(argp, dp, opp, bufsize, data);\n\t\tbreak;\n\n\tcase OPROMGETBOOTARGS:\n\t\terror = opromgetbootargs(argp, opp, bufsize);\n\t\tbreak;\n\n\tcase OPROMU2P:\n\tcase OPROMGETCONS:\n\tcase OPROMGETFBNAME:\n\t\tif (cnt++ < 10)\n\t\t\tprintk(KERN_INFO \"openprom_sunos_ioctl: unimplemented ioctl\\n\");\n\t\terror = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tif (cnt++ < 10)\n\t\t\tprintk(KERN_INFO \"openprom_sunos_ioctl: cmd 0x%X, arg 0x%lX\\n\", cmd, arg);\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\n\n\tkfree(opp);\n\tmutex_unlock(&openprom_mutex);\n\n\treturn error;\n}\n\nstatic struct device_node *get_node(phandle n, DATA *data)\n{\n\tstruct device_node *dp = of_find_node_by_phandle(n);\n\n\tif (dp)\n\t\tdata->lastnode = dp;\n\n\treturn dp;\n}\n\n \nstatic char * copyin_string(char __user *user, size_t len)\n{\n\tif ((ssize_t)len < 0 || (ssize_t)(len + 1) < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn memdup_user_nul(user, len);\n}\n\n \nstatic int opiocget(void __user *argp, DATA *data)\n{\n\tstruct opiocdesc op;\n\tstruct device_node *dp;\n\tchar *str;\n\tconst void *pval;\n\tint err, len;\n\n\tif (copy_from_user(&op, argp, sizeof(op)))\n\t\treturn -EFAULT;\n\n\tdp = get_node(op.op_nodeid, data);\n\n\tstr = copyin_string(op.op_name, op.op_namelen);\n\tif (IS_ERR(str))\n\t\treturn PTR_ERR(str);\n\n\tpval = of_get_property(dp, str, &len);\n\terr = 0;\n\tif (!pval || len > op.op_buflen) {\n\t\terr = -EINVAL;\n\t} else {\n\t\top.op_buflen = len;\n\t\tif (copy_to_user(argp, &op, sizeof(op)) ||\n\t\t    copy_to_user(op.op_buf, pval, len))\n\t\t\terr = -EFAULT;\n\t}\n\tkfree(str);\n\n\treturn err;\n}\n\nstatic int opiocnextprop(void __user *argp, DATA *data)\n{\n\tstruct opiocdesc op;\n\tstruct device_node *dp;\n\tstruct property *prop;\n\tchar *str;\n\tint len;\n\n\tif (copy_from_user(&op, argp, sizeof(op)))\n\t\treturn -EFAULT;\n\n\tdp = get_node(op.op_nodeid, data);\n\tif (!dp)\n\t\treturn -EINVAL;\n\n\tstr = copyin_string(op.op_name, op.op_namelen);\n\tif (IS_ERR(str))\n\t\treturn PTR_ERR(str);\n\n\tif (str[0] == '\\0') {\n\t\tprop = dp->properties;\n\t} else {\n\t\tprop = of_find_property(dp, str, NULL);\n\t\tif (prop)\n\t\t\tprop = prop->next;\n\t}\n\tkfree(str);\n\n\tif (!prop)\n\t\tlen = 0;\n\telse\n\t\tlen = prop->length;\n\n\tif (len > op.op_buflen)\n\t\tlen = op.op_buflen;\n\n\tif (copy_to_user(argp, &op, sizeof(op)))\n\t\treturn -EFAULT;\n\n\tif (len &&\n\t    copy_to_user(op.op_buf, prop->value, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int opiocset(void __user *argp, DATA *data)\n{\n\tstruct opiocdesc op;\n\tstruct device_node *dp;\n\tchar *str, *tmp;\n\tint err;\n\n\tif (copy_from_user(&op, argp, sizeof(op)))\n\t\treturn -EFAULT;\n\n\tdp = get_node(op.op_nodeid, data);\n\tif (!dp)\n\t\treturn -EINVAL;\n\n\tstr = copyin_string(op.op_name, op.op_namelen);\n\tif (IS_ERR(str))\n\t\treturn PTR_ERR(str);\n\n\ttmp = copyin_string(op.op_buf, op.op_buflen);\n\tif (IS_ERR(tmp)) {\n\t\tkfree(str);\n\t\treturn PTR_ERR(tmp);\n\t}\n\n\terr = of_set_property(dp, str, tmp, op.op_buflen);\n\n\tkfree(str);\n\tkfree(tmp);\n\n\treturn err;\n}\n\nstatic int opiocgetnext(unsigned int cmd, void __user *argp)\n{\n\tstruct device_node *dp;\n\tphandle nd;\n\n\tBUILD_BUG_ON(sizeof(phandle) != sizeof(int));\n\n\tif (copy_from_user(&nd, argp, sizeof(phandle)))\n\t\treturn -EFAULT;\n\n\tif (nd == 0) {\n\t\tif (cmd != OPIOCGETNEXT)\n\t\t\treturn -EINVAL;\n\t\tdp = of_find_node_by_path(\"/\");\n\t} else {\n\t\tdp = of_find_node_by_phandle(nd);\n\t\tnd = 0;\n\t\tif (dp) {\n\t\t\tif (cmd == OPIOCGETNEXT)\n\t\t\t\tdp = dp->sibling;\n\t\t\telse\n\t\t\t\tdp = dp->child;\n\t\t}\n\t}\n\tif (dp)\n\t\tnd = dp->phandle;\n\tif (copy_to_user(argp, &nd, sizeof(phandle)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int openprom_bsd_ioctl(struct file * file,\n\t\t\t      unsigned int cmd, unsigned long arg)\n{\n\tDATA *data = file->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\n\tmutex_lock(&openprom_mutex);\n\tswitch (cmd) {\n\tcase OPIOCGET:\n\t\terr = opiocget(argp, data);\n\t\tbreak;\n\n\tcase OPIOCNEXTPROP:\n\t\terr = opiocnextprop(argp, data);\n\t\tbreak;\n\n\tcase OPIOCSET:\n\t\terr = opiocset(argp, data);\n\t\tbreak;\n\n\tcase OPIOCGETOPTNODE:\n\t\tBUILD_BUG_ON(sizeof(phandle) != sizeof(int));\n\n\t\terr = 0;\n\t\tif (copy_to_user(argp, &options_node->phandle, sizeof(phandle)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase OPIOCGETNEXT:\n\tcase OPIOCGETCHILD:\n\t\terr = opiocgetnext(cmd, argp);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&openprom_mutex);\n\n\treturn err;\n}\n\n\n \nstatic long openprom_ioctl(struct file * file,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tDATA *data = file->private_data;\n\n\tswitch (cmd) {\n\tcase OPROMGETOPT:\n\tcase OPROMNXTOPT:\n\t\tif ((file->f_mode & FMODE_READ) == 0)\n\t\t\treturn -EPERM;\n\t\treturn openprom_sunos_ioctl(file, cmd, arg,\n\t\t\t\t\t    options_node);\n\n\tcase OPROMSETOPT:\n\tcase OPROMSETOPT2:\n\t\tif ((file->f_mode & FMODE_WRITE) == 0)\n\t\t\treturn -EPERM;\n\t\treturn openprom_sunos_ioctl(file, cmd, arg,\n\t\t\t\t\t    options_node);\n\n\tcase OPROMNEXT:\n\tcase OPROMCHILD:\n\tcase OPROMGETPROP:\n\tcase OPROMNXTPROP:\n\t\tif ((file->f_mode & FMODE_READ) == 0)\n\t\t\treturn -EPERM;\n\t\treturn openprom_sunos_ioctl(file, cmd, arg,\n\t\t\t\t\t    data->current_node);\n\n\tcase OPROMU2P:\n\tcase OPROMGETCONS:\n\tcase OPROMGETFBNAME:\n\tcase OPROMGETBOOTARGS:\n\tcase OPROMSETCUR:\n\tcase OPROMPCI2NODE:\n\tcase OPROMPATH2NODE:\n\t\tif ((file->f_mode & FMODE_READ) == 0)\n\t\t\treturn -EPERM;\n\t\treturn openprom_sunos_ioctl(file, cmd, arg, NULL);\n\n\tcase OPIOCGET:\n\tcase OPIOCNEXTPROP:\n\tcase OPIOCGETOPTNODE:\n\tcase OPIOCGETNEXT:\n\tcase OPIOCGETCHILD:\n\t\tif ((file->f_mode & FMODE_READ) == 0)\n\t\t\treturn -EBADF;\n\t\treturn openprom_bsd_ioctl(file,cmd,arg);\n\n\tcase OPIOCSET:\n\t\tif ((file->f_mode & FMODE_WRITE) == 0)\n\t\t\treturn -EBADF;\n\t\treturn openprom_bsd_ioctl(file,cmd,arg);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t};\n}\n\nstatic long openprom_compat_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tlong rval = -ENOTTY;\n\n\t \n\tswitch (cmd) {\n\tcase OPROMGETOPT:\n\tcase OPROMSETOPT:\n\tcase OPROMNXTOPT:\n\tcase OPROMSETOPT2:\n\tcase OPROMNEXT:\n\tcase OPROMCHILD:\n\tcase OPROMGETPROP:\n\tcase OPROMNXTPROP:\n\tcase OPROMU2P:\n\tcase OPROMGETCONS:\n\tcase OPROMGETFBNAME:\n\tcase OPROMGETBOOTARGS:\n\tcase OPROMSETCUR:\n\tcase OPROMPCI2NODE:\n\tcase OPROMPATH2NODE:\n\t\trval = openprom_ioctl(file, cmd, arg);\n\t\tbreak;\n\t}\n\n\treturn rval;\n}\n\nstatic int openprom_open(struct inode * inode, struct file * file)\n{\n\tDATA *data;\n\n\tdata = kmalloc(sizeof(DATA), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&openprom_mutex);\n\tdata->current_node = of_find_node_by_path(\"/\");\n\tdata->lastnode = data->current_node;\n\tfile->private_data = (void *) data;\n\tmutex_unlock(&openprom_mutex);\n\n\treturn 0;\n}\n\nstatic int openprom_release(struct inode * inode, struct file * file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}\n\nstatic const struct file_operations openprom_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.unlocked_ioctl = openprom_ioctl,\n\t.compat_ioctl =\topenprom_compat_ioctl,\n\t.open =\t\topenprom_open,\n\t.release =\topenprom_release,\n};\n\nstatic struct miscdevice openprom_dev = {\n\t.minor\t\t= SUN_OPENPROM_MINOR,\n\t.name\t\t= \"openprom\",\n\t.fops\t\t= &openprom_fops,\n};\n\nstatic int __init openprom_init(void)\n{\n\tint err;\n\n\terr = misc_register(&openprom_dev);\n\tif (err)\n\t\treturn err;\n\n\toptions_node = of_get_child_by_name(of_find_node_by_path(\"/\"), \"options\");\n\tif (!options_node) {\n\t\tmisc_deregister(&openprom_dev);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit openprom_cleanup(void)\n{\n\tmisc_deregister(&openprom_dev);\n}\n\nmodule_init(openprom_init);\nmodule_exit(openprom_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}