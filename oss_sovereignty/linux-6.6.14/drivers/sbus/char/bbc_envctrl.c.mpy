{
  "module_name": "bbc_envctrl.c",
  "hash_id": "c23c1d1a17d0e4123064498a9c4f83f9d4ad81a26fecaabacfd9e93f80b5f3e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sbus/char/bbc_envctrl.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/kmod.h>\n#include <linux/reboot.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <asm/oplib.h>\n\n#include \"bbc_i2c.h\"\n#include \"max1617.h\"\n\n#undef ENVCTRL_TRACE\n\n \n\n \n\n \nstruct temp_limits {\n\ts8 high_pwroff, high_shutdown, high_warn;\n\ts8 low_warn, low_shutdown, low_pwroff;\n};\n\nstatic struct temp_limits cpu_temp_limits[2] = {\n\t{ 100, 85, 80, 5, -5, -10 },\n\t{ 100, 85, 80, 5, -5, -10 },\n};\n\nstatic struct temp_limits amb_temp_limits[2] = {\n\t{ 65, 55, 40, 5, -5, -10 },\n\t{ 65, 55, 40, 5, -5, -10 },\n};\n\nstatic LIST_HEAD(all_temps);\nstatic LIST_HEAD(all_fans);\n\n#define CPU_FAN_REG\t0xf0\n#define SYS_FAN_REG\t0xf2\n#define PSUPPLY_FAN_REG\t0xf4\n\n#define FAN_SPEED_MIN\t0x0c\n#define FAN_SPEED_MAX\t0x3f\n\n#define PSUPPLY_FAN_ON\t0x1f\n#define PSUPPLY_FAN_OFF\t0x00\n\nstatic void set_fan_speeds(struct bbc_fan_control *fp)\n{\n\t \n\tif (fp->cpu_fan_speed < FAN_SPEED_MIN)\n\t\tfp->cpu_fan_speed = FAN_SPEED_MIN;\n\tif (fp->cpu_fan_speed > FAN_SPEED_MAX)\n\t\tfp->cpu_fan_speed = FAN_SPEED_MAX;\n\tif (fp->system_fan_speed < FAN_SPEED_MIN)\n\t\tfp->system_fan_speed = FAN_SPEED_MIN;\n\tif (fp->system_fan_speed > FAN_SPEED_MAX)\n\t\tfp->system_fan_speed = FAN_SPEED_MAX;\n#ifdef ENVCTRL_TRACE\n\tprintk(\"fan%d: Changed fan speed to cpu(%02x) sys(%02x)\\n\",\n\t       fp->index,\n\t       fp->cpu_fan_speed, fp->system_fan_speed);\n#endif\n\n\tbbc_i2c_writeb(fp->client, fp->cpu_fan_speed, CPU_FAN_REG);\n\tbbc_i2c_writeb(fp->client, fp->system_fan_speed, SYS_FAN_REG);\n\tbbc_i2c_writeb(fp->client,\n\t\t       (fp->psupply_fan_on ?\n\t\t\tPSUPPLY_FAN_ON : PSUPPLY_FAN_OFF),\n\t\t       PSUPPLY_FAN_REG);\n}\n\nstatic void get_current_temps(struct bbc_cpu_temperature *tp)\n{\n\ttp->prev_amb_temp = tp->curr_amb_temp;\n\tbbc_i2c_readb(tp->client,\n\t\t      (unsigned char *) &tp->curr_amb_temp,\n\t\t      MAX1617_AMB_TEMP);\n\ttp->prev_cpu_temp = tp->curr_cpu_temp;\n\tbbc_i2c_readb(tp->client,\n\t\t      (unsigned char *) &tp->curr_cpu_temp,\n\t\t      MAX1617_CPU_TEMP);\n#ifdef ENVCTRL_TRACE\n\tprintk(\"temp%d: cpu(%d C) amb(%d C)\\n\",\n\t       tp->index,\n\t       (int) tp->curr_cpu_temp, (int) tp->curr_amb_temp);\n#endif\n}\n\n\nstatic void do_envctrl_shutdown(struct bbc_cpu_temperature *tp)\n{\n\tstatic int shutting_down = 0;\n\tchar *type = \"???\";\n\ts8 val = -1;\n\n\tif (shutting_down != 0)\n\t\treturn;\n\n\tif (tp->curr_amb_temp >= amb_temp_limits[tp->index].high_shutdown ||\n\t    tp->curr_amb_temp < amb_temp_limits[tp->index].low_shutdown) {\n\t\ttype = \"ambient\";\n\t\tval = tp->curr_amb_temp;\n\t} else if (tp->curr_cpu_temp >= cpu_temp_limits[tp->index].high_shutdown ||\n\t\t   tp->curr_cpu_temp < cpu_temp_limits[tp->index].low_shutdown) {\n\t\ttype = \"CPU\";\n\t\tval = tp->curr_cpu_temp;\n\t}\n\n\tprintk(KERN_CRIT \"temp%d: Outside of safe %s \"\n\t       \"operating temperature, %d C.\\n\",\n\t       tp->index, type, val);\n\n\tprintk(KERN_CRIT \"kenvctrld: Shutting down the system now.\\n\");\n\n\tshutting_down = 1;\n\torderly_poweroff(true);\n}\n\n#define WARN_INTERVAL\t(30 * HZ)\n\nstatic void analyze_ambient_temp(struct bbc_cpu_temperature *tp, unsigned long *last_warn, int tick)\n{\n\tint ret = 0;\n\n\tif (time_after(jiffies, (*last_warn + WARN_INTERVAL))) {\n\t\tif (tp->curr_amb_temp >=\n\t\t    amb_temp_limits[tp->index].high_warn) {\n\t\t\tprintk(KERN_WARNING \"temp%d: \"\n\t\t\t       \"Above safe ambient operating temperature, %d C.\\n\",\n\t\t\t       tp->index, (int) tp->curr_amb_temp);\n\t\t\tret = 1;\n\t\t} else if (tp->curr_amb_temp <\n\t\t\t   amb_temp_limits[tp->index].low_warn) {\n\t\t\tprintk(KERN_WARNING \"temp%d: \"\n\t\t\t       \"Below safe ambient operating temperature, %d C.\\n\",\n\t\t\t       tp->index, (int) tp->curr_amb_temp);\n\t\t\tret = 1;\n\t\t}\n\t\tif (ret)\n\t\t\t*last_warn = jiffies;\n\t} else if (tp->curr_amb_temp >= amb_temp_limits[tp->index].high_warn ||\n\t\t   tp->curr_amb_temp < amb_temp_limits[tp->index].low_warn)\n\t\tret = 1;\n\n\t \n\tif (tp->curr_amb_temp >= amb_temp_limits[tp->index].high_shutdown ||\n\t    tp->curr_amb_temp < amb_temp_limits[tp->index].low_shutdown) {\n\t\tdo_envctrl_shutdown(tp);\n\t\tret = 1;\n\t}\n\n\tif (ret) {\n\t\ttp->fan_todo[FAN_AMBIENT] = FAN_FULLBLAST;\n\t} else if ((tick & (8 - 1)) == 0) {\n\t\ts8 amb_goal_hi = amb_temp_limits[tp->index].high_warn - 10;\n\t\ts8 amb_goal_lo;\n\n\t\tamb_goal_lo = amb_goal_hi - 3;\n\n\t\t \n\t\tif (tp->avg_amb_temp < amb_goal_hi) {\n\t\t\tif (tp->avg_amb_temp >= amb_goal_lo)\n\t\t\t\ttp->fan_todo[FAN_AMBIENT] = FAN_SAME;\n\t\t\telse\n\t\t\t\ttp->fan_todo[FAN_AMBIENT] = FAN_SLOWER;\n\t\t} else {\n\t\t\ttp->fan_todo[FAN_AMBIENT] = FAN_FASTER;\n\t\t}\n\t} else {\n\t\ttp->fan_todo[FAN_AMBIENT] = FAN_SAME;\n\t}\n}\n\nstatic void analyze_cpu_temp(struct bbc_cpu_temperature *tp, unsigned long *last_warn, int tick)\n{\n\tint ret = 0;\n\n\tif (time_after(jiffies, (*last_warn + WARN_INTERVAL))) {\n\t\tif (tp->curr_cpu_temp >=\n\t\t    cpu_temp_limits[tp->index].high_warn) {\n\t\t\tprintk(KERN_WARNING \"temp%d: \"\n\t\t\t       \"Above safe CPU operating temperature, %d C.\\n\",\n\t\t\t       tp->index, (int) tp->curr_cpu_temp);\n\t\t\tret = 1;\n\t\t} else if (tp->curr_cpu_temp <\n\t\t\t   cpu_temp_limits[tp->index].low_warn) {\n\t\t\tprintk(KERN_WARNING \"temp%d: \"\n\t\t\t       \"Below safe CPU operating temperature, %d C.\\n\",\n\t\t\t       tp->index, (int) tp->curr_cpu_temp);\n\t\t\tret = 1;\n\t\t}\n\t\tif (ret)\n\t\t\t*last_warn = jiffies;\n\t} else if (tp->curr_cpu_temp >= cpu_temp_limits[tp->index].high_warn ||\n\t\t   tp->curr_cpu_temp < cpu_temp_limits[tp->index].low_warn)\n\t\tret = 1;\n\n\t \n\tif (tp->curr_cpu_temp >= cpu_temp_limits[tp->index].high_shutdown ||\n\t    tp->curr_cpu_temp < cpu_temp_limits[tp->index].low_shutdown) {\n\t\tdo_envctrl_shutdown(tp);\n\t\tret = 1;\n\t}\n\n\tif (ret) {\n\t\ttp->fan_todo[FAN_CPU] = FAN_FULLBLAST;\n\t} else if ((tick & (8 - 1)) == 0) {\n\t\ts8 cpu_goal_hi = cpu_temp_limits[tp->index].high_warn - 10;\n\t\ts8 cpu_goal_lo;\n\n\t\tcpu_goal_lo = cpu_goal_hi - 3;\n\n\t\t \n\t\tif (tp->avg_cpu_temp < cpu_goal_hi) {\n\t\t\tif (tp->avg_cpu_temp >= cpu_goal_lo)\n\t\t\t\ttp->fan_todo[FAN_CPU] = FAN_SAME;\n\t\t\telse\n\t\t\t\ttp->fan_todo[FAN_CPU] = FAN_SLOWER;\n\t\t} else {\n\t\t\ttp->fan_todo[FAN_CPU] = FAN_FASTER;\n\t\t}\n\t} else {\n\t\ttp->fan_todo[FAN_CPU] = FAN_SAME;\n\t}\n}\n\nstatic void analyze_temps(struct bbc_cpu_temperature *tp, unsigned long *last_warn)\n{\n\ttp->avg_amb_temp = (s8)((int)((int)tp->avg_amb_temp + (int)tp->curr_amb_temp) / 2);\n\ttp->avg_cpu_temp = (s8)((int)((int)tp->avg_cpu_temp + (int)tp->curr_cpu_temp) / 2);\n\n\tanalyze_ambient_temp(tp, last_warn, tp->sample_tick);\n\tanalyze_cpu_temp(tp, last_warn, tp->sample_tick);\n\n\ttp->sample_tick++;\n}\n\nstatic enum fan_action prioritize_fan_action(int which_fan)\n{\n\tstruct bbc_cpu_temperature *tp;\n\tenum fan_action decision = FAN_STATE_MAX;\n\n\t \n\tlist_for_each_entry(tp, &all_temps, glob_list) {\n\t\tif (tp->fan_todo[which_fan] == FAN_FULLBLAST) {\n\t\t\tdecision = FAN_FULLBLAST;\n\t\t\tbreak;\n\t\t}\n\t\tif (tp->fan_todo[which_fan] == FAN_SAME &&\n\t\t    decision != FAN_FASTER)\n\t\t\tdecision = FAN_SAME;\n\t\telse if (tp->fan_todo[which_fan] == FAN_FASTER)\n\t\t\tdecision = FAN_FASTER;\n\t\telse if (decision != FAN_FASTER &&\n\t\t\t decision != FAN_SAME &&\n\t\t\t tp->fan_todo[which_fan] == FAN_SLOWER)\n\t\t\tdecision = FAN_SLOWER;\n\t}\n\tif (decision == FAN_STATE_MAX)\n\t\tdecision = FAN_SAME;\n\n\treturn decision;\n}\n\nstatic int maybe_new_ambient_fan_speed(struct bbc_fan_control *fp)\n{\n\tenum fan_action decision = prioritize_fan_action(FAN_AMBIENT);\n\tint ret;\n\n\tif (decision == FAN_SAME)\n\t\treturn 0;\n\n\tret = 1;\n\tif (decision == FAN_FULLBLAST) {\n\t\tif (fp->system_fan_speed >= FAN_SPEED_MAX)\n\t\t\tret = 0;\n\t\telse\n\t\t\tfp->system_fan_speed = FAN_SPEED_MAX;\n\t} else {\n\t\tif (decision == FAN_FASTER) {\n\t\t\tif (fp->system_fan_speed >= FAN_SPEED_MAX)\n\t\t\t\tret = 0;\n\t\t\telse\n\t\t\t\tfp->system_fan_speed += 2;\n\t\t} else {\n\t\t\tint orig_speed = fp->system_fan_speed;\n\n\t\t\tif (orig_speed <= FAN_SPEED_MIN ||\n\t\t\t    orig_speed <= (fp->cpu_fan_speed - 3))\n\t\t\t\tret = 0;\n\t\t\telse\n\t\t\t\tfp->system_fan_speed -= 1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int maybe_new_cpu_fan_speed(struct bbc_fan_control *fp)\n{\n\tenum fan_action decision = prioritize_fan_action(FAN_CPU);\n\tint ret;\n\n\tif (decision == FAN_SAME)\n\t\treturn 0;\n\n\tret = 1;\n\tif (decision == FAN_FULLBLAST) {\n\t\tif (fp->cpu_fan_speed >= FAN_SPEED_MAX)\n\t\t\tret = 0;\n\t\telse\n\t\t\tfp->cpu_fan_speed = FAN_SPEED_MAX;\n\t} else {\n\t\tif (decision == FAN_FASTER) {\n\t\t\tif (fp->cpu_fan_speed >= FAN_SPEED_MAX)\n\t\t\t\tret = 0;\n\t\t\telse {\n\t\t\t\tfp->cpu_fan_speed += 2;\n\t\t\t\tif (fp->system_fan_speed <\n\t\t\t\t    (fp->cpu_fan_speed - 3))\n\t\t\t\t\tfp->system_fan_speed =\n\t\t\t\t\t\tfp->cpu_fan_speed - 3;\n\t\t\t}\n\t\t} else {\n\t\t\tif (fp->cpu_fan_speed <= FAN_SPEED_MIN)\n\t\t\t\tret = 0;\n\t\t\telse\n\t\t\t\tfp->cpu_fan_speed -= 1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void maybe_new_fan_speeds(struct bbc_fan_control *fp)\n{\n\tint new;\n\n\tnew  = maybe_new_ambient_fan_speed(fp);\n\tnew |= maybe_new_cpu_fan_speed(fp);\n\n\tif (new)\n\t\tset_fan_speeds(fp);\n}\n\nstatic void fans_full_blast(void)\n{\n\tstruct bbc_fan_control *fp;\n\n\t \n\tlist_for_each_entry(fp, &all_fans, glob_list) {\n\t\tfp->cpu_fan_speed = FAN_SPEED_MAX;\n\t\tfp->system_fan_speed = FAN_SPEED_MAX;\n\t\tfp->psupply_fan_on = 1;\n\t\tset_fan_speeds(fp);\n\t}\n}\n\n#define POLL_INTERVAL\t(5 * 1000)\nstatic unsigned long last_warning_jiffies;\nstatic struct task_struct *kenvctrld_task;\n\nstatic int kenvctrld(void *__unused)\n{\n\tprintk(KERN_INFO \"bbc_envctrl: kenvctrld starting...\\n\");\n\tlast_warning_jiffies = jiffies - WARN_INTERVAL;\n\tfor (;;) {\n\t\tstruct bbc_cpu_temperature *tp;\n\t\tstruct bbc_fan_control *fp;\n\n\t\tmsleep_interruptible(POLL_INTERVAL);\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tlist_for_each_entry(tp, &all_temps, glob_list) {\n\t\t\tget_current_temps(tp);\n\t\t\tanalyze_temps(tp, &last_warning_jiffies);\n\t\t}\n\t\tlist_for_each_entry(fp, &all_fans, glob_list)\n\t\t\tmaybe_new_fan_speeds(fp);\n\t}\n\tprintk(KERN_INFO \"bbc_envctrl: kenvctrld exiting...\\n\");\n\n\tfans_full_blast();\n\n\treturn 0;\n}\n\nstatic void attach_one_temp(struct bbc_i2c_bus *bp, struct platform_device *op,\n\t\t\t    int temp_idx)\n{\n\tstruct bbc_cpu_temperature *tp;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&tp->bp_list);\n\tINIT_LIST_HEAD(&tp->glob_list);\n\n\ttp->client = bbc_i2c_attach(bp, op);\n\tif (!tp->client) {\n\t\tkfree(tp);\n\t\treturn;\n\t}\n\n\n\ttp->index = temp_idx;\n\n\tlist_add(&tp->glob_list, &all_temps);\n\tlist_add(&tp->bp_list, &bp->temps);\n\n\t \n\tbbc_i2c_writeb(tp->client, 0x00, MAX1617_WR_CFG_BYTE);\n\tbbc_i2c_writeb(tp->client, 0x02, MAX1617_WR_CVRATE_BYTE);\n\n\t \n\tbbc_i2c_writeb(tp->client, amb_temp_limits[tp->index].high_pwroff,\n\t\t       MAX1617_WR_AMB_HIGHLIM);\n\tbbc_i2c_writeb(tp->client, amb_temp_limits[tp->index].low_pwroff,\n\t\t       MAX1617_WR_AMB_LOWLIM);\n\tbbc_i2c_writeb(tp->client, cpu_temp_limits[tp->index].high_pwroff,\n\t\t       MAX1617_WR_CPU_HIGHLIM);\n\tbbc_i2c_writeb(tp->client, cpu_temp_limits[tp->index].low_pwroff,\n\t\t       MAX1617_WR_CPU_LOWLIM);\n\n\tget_current_temps(tp);\n\ttp->prev_cpu_temp = tp->avg_cpu_temp = tp->curr_cpu_temp;\n\ttp->prev_amb_temp = tp->avg_amb_temp = tp->curr_amb_temp;\n\n\ttp->fan_todo[FAN_AMBIENT] = FAN_SAME;\n\ttp->fan_todo[FAN_CPU] = FAN_SAME;\n}\n\nstatic void attach_one_fan(struct bbc_i2c_bus *bp, struct platform_device *op,\n\t\t\t   int fan_idx)\n{\n\tstruct bbc_fan_control *fp;\n\n\tfp = kzalloc(sizeof(*fp), GFP_KERNEL);\n\tif (!fp)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&fp->bp_list);\n\tINIT_LIST_HEAD(&fp->glob_list);\n\n\tfp->client = bbc_i2c_attach(bp, op);\n\tif (!fp->client) {\n\t\tkfree(fp);\n\t\treturn;\n\t}\n\n\tfp->index = fan_idx;\n\n\tlist_add(&fp->glob_list, &all_fans);\n\tlist_add(&fp->bp_list, &bp->fans);\n\n\t \n\tfp->psupply_fan_on = 1;\n\tfp->cpu_fan_speed = (FAN_SPEED_MAX - FAN_SPEED_MIN) / 2;\n\tfp->cpu_fan_speed += FAN_SPEED_MIN;\n\tfp->system_fan_speed = (FAN_SPEED_MAX - FAN_SPEED_MIN) / 2;\n\tfp->system_fan_speed += FAN_SPEED_MIN;\n\n\tset_fan_speeds(fp);\n}\n\nstatic void destroy_one_temp(struct bbc_cpu_temperature *tp)\n{\n\tbbc_i2c_detach(tp->client);\n\tkfree(tp);\n}\n\nstatic void destroy_all_temps(struct bbc_i2c_bus *bp)\n{\n\tstruct bbc_cpu_temperature *tp, *tpos;\n\n\tlist_for_each_entry_safe(tp, tpos, &bp->temps, bp_list) {\n\t\tlist_del(&tp->bp_list);\n\t\tlist_del(&tp->glob_list);\n\t\tdestroy_one_temp(tp);\n\t}\n}\n\nstatic void destroy_one_fan(struct bbc_fan_control *fp)\n{\n\tbbc_i2c_detach(fp->client);\n\tkfree(fp);\n}\n\nstatic void destroy_all_fans(struct bbc_i2c_bus *bp)\n{\n\tstruct bbc_fan_control *fp, *fpos;\n\n\tlist_for_each_entry_safe(fp, fpos, &bp->fans, bp_list) {\n\t\tlist_del(&fp->bp_list);\n\t\tlist_del(&fp->glob_list);\n\t\tdestroy_one_fan(fp);\n\t}\n}\n\nint bbc_envctrl_init(struct bbc_i2c_bus *bp)\n{\n\tstruct platform_device *op;\n\tint temp_index = 0;\n\tint fan_index = 0;\n\tint devidx = 0;\n\n\twhile ((op = bbc_i2c_getdev(bp, devidx++)) != NULL) {\n\t\tif (of_node_name_eq(op->dev.of_node, \"temperature\"))\n\t\t\tattach_one_temp(bp, op, temp_index++);\n\t\tif (of_node_name_eq(op->dev.of_node, \"fan-control\"))\n\t\t\tattach_one_fan(bp, op, fan_index++);\n\t}\n\tif (temp_index != 0 && fan_index != 0) {\n\t\tkenvctrld_task = kthread_run(kenvctrld, NULL, \"kenvctrld\");\n\t\tif (IS_ERR(kenvctrld_task)) {\n\t\t\tint err = PTR_ERR(kenvctrld_task);\n\n\t\t\tkenvctrld_task = NULL;\n\t\t\tdestroy_all_temps(bp);\n\t\t\tdestroy_all_fans(bp);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid bbc_envctrl_cleanup(struct bbc_i2c_bus *bp)\n{\n\tif (kenvctrld_task)\n\t\tkthread_stop(kenvctrld_task);\n\n\tdestroy_all_temps(bp);\n\tdestroy_all_fans(bp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}