{
  "module_name": "display7seg.c",
  "hash_id": "90378f2f4fd43b553e6509d107621206d34837b756fb69c53de6d83a060ab75f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sbus/char/display7seg.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/miscdevice.h>\n#include <linux/ioport.h>\t\t \n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\t\t \n#include <asm/io.h>\n\n#include <asm/display7seg.h>\n\n#define DRIVER_NAME\t\"d7s\"\n#define PFX\t\tDRIVER_NAME \": \"\n\nstatic DEFINE_MUTEX(d7s_mutex);\nstatic int sol_compat = 0;\t\t \n\n \nmodule_param(sol_compat, int, 0);\nMODULE_PARM_DESC(sol_compat, \n\t\t \"Disables documented functionality omitted from Solaris driver\");\n\nMODULE_AUTHOR(\"Eric Brower <ebrower@usa.net>\");\nMODULE_DESCRIPTION(\"7-Segment Display driver for Sun Microsystems CP1400/1500\");\nMODULE_LICENSE(\"GPL\");\n\nstruct d7s {\n\tvoid __iomem\t*regs;\n\tbool\t\tflipped;\n};\nstruct d7s *d7s_device;\n\n \nstatic atomic_t d7s_users = ATOMIC_INIT(0);\n\nstatic int d7s_open(struct inode *inode, struct file *f)\n{\n\tif (D7S_MINOR != iminor(inode))\n\t\treturn -ENODEV;\n\tatomic_inc(&d7s_users);\n\treturn 0;\n}\n\nstatic int d7s_release(struct inode *inode, struct file *f)\n{\n\t \n\tif (atomic_dec_and_test(&d7s_users) && !sol_compat) {\n\t\tstruct d7s *p = d7s_device;\n\t\tu8 regval = 0;\n\n\t\tregval = readb(p->regs);\n\t\tif (p->flipped)\n\t\t\tregval |= D7S_FLIP;\n\t\telse\n\t\t\tregval &= ~D7S_FLIP;\n\t\twriteb(regval, p->regs);\n\t}\n\n\treturn 0;\n}\n\nstatic long d7s_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct d7s *p = d7s_device;\n\tu8 regs = readb(p->regs);\n\tint error = 0;\n\tu8 ireg = 0;\n\n\tif (D7S_MINOR != iminor(file_inode(file)))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&d7s_mutex);\n\tswitch (cmd) {\n\tcase D7SIOCWR:\n\t\t \n\t\tif (get_user(ireg, (int __user *) arg)) {\n\t\t\terror = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (sol_compat) {\n\t\t\tif (regs & D7S_FLIP)\n\t\t\t\tireg |= D7S_FLIP;\n\t\t\telse\n\t\t\t\tireg &= ~D7S_FLIP;\n\t\t}\n\t\twriteb(ireg, p->regs);\n\t\tbreak;\n\n\tcase D7SIOCRD:\n\t\t \n\t\tif (put_user(regs, (int __user *) arg)) {\n\t\t\terror = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase D7SIOCTM:\n\t\t \n\t\tregs ^= D7S_FLIP;\n\t\twriteb(regs, p->regs);\n\t\tbreak;\n\t}\n\tmutex_unlock(&d7s_mutex);\n\n\treturn error;\n}\n\nstatic const struct file_operations d7s_fops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.unlocked_ioctl =\td7s_ioctl,\n\t.compat_ioctl =\t\tcompat_ptr_ioctl,\n\t.open =\t\t\td7s_open,\n\t.release =\t\td7s_release,\n\t.llseek = noop_llseek,\n};\n\nstatic struct miscdevice d7s_miscdev = {\n\t.minor\t\t= D7S_MINOR,\n\t.name\t\t= DRIVER_NAME,\n\t.fops\t\t= &d7s_fops\n};\n\nstatic int d7s_probe(struct platform_device *op)\n{\n\tstruct device_node *opts;\n\tint err = -EINVAL;\n\tstruct d7s *p;\n\tu8 regs;\n\n\tif (d7s_device)\n\t\tgoto out;\n\n\tp = devm_kzalloc(&op->dev, sizeof(*p), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!p)\n\t\tgoto out;\n\n\tp->regs = of_ioremap(&op->resource[0], 0, sizeof(u8), \"d7s\");\n\tif (!p->regs) {\n\t\tprintk(KERN_ERR PFX \"Cannot map chip registers\\n\");\n\t\tgoto out;\n\t}\n\n\terr = misc_register(&d7s_miscdev);\n\tif (err) {\n\t\tprintk(KERN_ERR PFX \"Unable to acquire miscdevice minor %i\\n\",\n\t\t       D7S_MINOR);\n\t\tgoto out_iounmap;\n\t}\n\n\t \n\tregs = readb(p->regs);\n\topts = of_find_node_by_path(\"/options\");\n\tif (opts)\n\t    p->flipped = of_property_read_bool(opts, \"d7s-flipped?\");\n\n\tif (p->flipped)\n\t\tregs |= D7S_FLIP;\n\telse\n\t\tregs &= ~D7S_FLIP;\n\n\twriteb(regs,  p->regs);\n\n\tprintk(KERN_INFO PFX \"7-Segment Display%pOF at [%s:0x%llx] %s\\n\",\n\t       op->dev.of_node,\n\t       (regs & D7S_FLIP) ? \" (FLIPPED)\" : \"\",\n\t       op->resource[0].start,\n\t       sol_compat ? \"in sol_compat mode\" : \"\");\n\n\tdev_set_drvdata(&op->dev, p);\n\td7s_device = p;\n\terr = 0;\n\tof_node_put(opts);\n\nout:\n\treturn err;\n\nout_iounmap:\n\tof_iounmap(&op->resource[0], p->regs, sizeof(u8));\n\tgoto out;\n}\n\nstatic int d7s_remove(struct platform_device *op)\n{\n\tstruct d7s *p = dev_get_drvdata(&op->dev);\n\tu8 regs = readb(p->regs);\n\n\t \n\tif (sol_compat) {\n\t\tif (p->flipped)\n\t\t\tregs |= D7S_FLIP;\n\t\telse\n\t\t\tregs &= ~D7S_FLIP;\n\t\twriteb(regs, p->regs);\n\t}\n\n\tmisc_deregister(&d7s_miscdev);\n\tof_iounmap(&op->resource[0], p->regs, sizeof(u8));\n\n\treturn 0;\n}\n\nstatic const struct of_device_id d7s_match[] = {\n\t{\n\t\t.name = \"display7seg\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, d7s_match);\n\nstatic struct platform_driver d7s_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = d7s_match,\n\t},\n\t.probe\t\t= d7s_probe,\n\t.remove\t\t= d7s_remove,\n};\n\nmodule_platform_driver(d7s_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}