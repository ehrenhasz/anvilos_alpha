{
  "module_name": "bbc_i2c.c",
  "hash_id": "a302c38c172810d6e1b31f22e3b4e6ab6222c6872a9b8166f466fdc97f62ed45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sbus/char/bbc_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <asm/bbc.h>\n#include <asm/io.h>\n\n#include \"bbc_i2c.h\"\n\n \n#define I2C_PCF_PIN\t0x80\n#define I2C_PCF_ESO\t0x40\n#define I2C_PCF_ES1\t0x20\n#define I2C_PCF_ES2\t0x10\n#define I2C_PCF_ENI\t0x08\n#define I2C_PCF_STA\t0x04\n#define I2C_PCF_STO\t0x02\n#define I2C_PCF_ACK\t0x01\n\n#define I2C_PCF_START    (I2C_PCF_PIN | I2C_PCF_ESO | I2C_PCF_ENI | I2C_PCF_STA | I2C_PCF_ACK)\n#define I2C_PCF_STOP     (I2C_PCF_PIN | I2C_PCF_ESO | I2C_PCF_STO | I2C_PCF_ACK)\n#define I2C_PCF_REPSTART (              I2C_PCF_ESO | I2C_PCF_STA | I2C_PCF_ACK)\n#define I2C_PCF_IDLE     (I2C_PCF_PIN | I2C_PCF_ESO               | I2C_PCF_ACK)\n\n#define I2C_PCF_INI 0x40    \n#define I2C_PCF_STS 0x20\n#define I2C_PCF_BER 0x10\n#define I2C_PCF_AD0 0x08\n#define I2C_PCF_LRB 0x08\n#define I2C_PCF_AAS 0x04\n#define I2C_PCF_LAB 0x02\n#define I2C_PCF_BB  0x01\n\n \n\nstatic void set_device_claimage(struct bbc_i2c_bus *bp, struct platform_device *op, int val)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_CHILDREN; i++) {\n\t\tif (bp->devs[i].device == op) {\n\t\t\tbp->devs[i].client_claimed = val;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#define claim_device(BP,ECHILD)\t\tset_device_claimage(BP,ECHILD,1)\n#define release_device(BP,ECHILD)\tset_device_claimage(BP,ECHILD,0)\n\nstruct platform_device *bbc_i2c_getdev(struct bbc_i2c_bus *bp, int index)\n{\n\tstruct platform_device *op = NULL;\n\tint curidx = 0, i;\n\n\tfor (i = 0; i < NUM_CHILDREN; i++) {\n\t\tif (!(op = bp->devs[i].device))\n\t\t\tbreak;\n\t\tif (curidx == index)\n\t\t\tgoto out;\n\t\top = NULL;\n\t\tcuridx++;\n\t}\n\nout:\n\tif (curidx == index)\n\t\treturn op;\n\treturn NULL;\n}\n\nstruct bbc_i2c_client *bbc_i2c_attach(struct bbc_i2c_bus *bp, struct platform_device *op)\n{\n\tstruct bbc_i2c_client *client;\n\tconst u32 *reg;\n\n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (!client)\n\t\treturn NULL;\n\tclient->bp = bp;\n\tclient->op = op;\n\n\treg = of_get_property(op->dev.of_node, \"reg\", NULL);\n\tif (!reg) {\n\t\tkfree(client);\n\t\treturn NULL;\n\t}\n\n\tclient->bus = reg[0];\n\tclient->address = reg[1];\n\n\tclaim_device(bp, op);\n\n\treturn client;\n}\n\nvoid bbc_i2c_detach(struct bbc_i2c_client *client)\n{\n\tstruct bbc_i2c_bus *bp = client->bp;\n\tstruct platform_device *op = client->op;\n\n\trelease_device(bp, op);\n\tkfree(client);\n}\n\nstatic int wait_for_pin(struct bbc_i2c_bus *bp, u8 *status)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint limit = 32;\n\tint ret = 1;\n\n\tbp->waiting = 1;\n\tadd_wait_queue(&bp->wq, &wait);\n\twhile (limit-- > 0) {\n\t\tlong val;\n\n\t\tval = wait_event_interruptible_timeout(\n\t\t\t\tbp->wq,\n\t\t\t\t(((*status = readb(bp->i2c_control_regs + 0))\n\t\t\t\t  & I2C_PCF_PIN) == 0),\n\t\t\t\tmsecs_to_jiffies(250));\n\t\tif (val > 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_wait_queue(&bp->wq, &wait);\n\tbp->waiting = 0;\n\n\treturn ret;\n}\n\nint bbc_i2c_writeb(struct bbc_i2c_client *client, unsigned char val, int off)\n{\n\tstruct bbc_i2c_bus *bp = client->bp;\n\tint address = client->address;\n\tu8 status;\n\tint ret = -1;\n\n\tif (bp->i2c_bussel_reg != NULL)\n\t\twriteb(client->bus, bp->i2c_bussel_reg);\n\n\twriteb(address, bp->i2c_control_regs + 0x1);\n\twriteb(I2C_PCF_START, bp->i2c_control_regs + 0x0);\n\tif (wait_for_pin(bp, &status))\n\t\tgoto out;\n\n\twriteb(off, bp->i2c_control_regs + 0x1);\n\tif (wait_for_pin(bp, &status) ||\n\t    (status & I2C_PCF_LRB) != 0)\n\t\tgoto out;\n\n\twriteb(val, bp->i2c_control_regs + 0x1);\n\tif (wait_for_pin(bp, &status))\n\t\tgoto out;\n\n\tret = 0;\n\nout:\n\twriteb(I2C_PCF_STOP, bp->i2c_control_regs + 0x0);\n\treturn ret;\n}\n\nint bbc_i2c_readb(struct bbc_i2c_client *client, unsigned char *byte, int off)\n{\n\tstruct bbc_i2c_bus *bp = client->bp;\n\tunsigned char address = client->address, status;\n\tint ret = -1;\n\n\tif (bp->i2c_bussel_reg != NULL)\n\t\twriteb(client->bus, bp->i2c_bussel_reg);\n\n\twriteb(address, bp->i2c_control_regs + 0x1);\n\twriteb(I2C_PCF_START, bp->i2c_control_regs + 0x0);\n\tif (wait_for_pin(bp, &status))\n\t\tgoto out;\n\n\twriteb(off, bp->i2c_control_regs + 0x1);\n\tif (wait_for_pin(bp, &status) ||\n\t    (status & I2C_PCF_LRB) != 0)\n\t\tgoto out;\n\n\twriteb(I2C_PCF_STOP, bp->i2c_control_regs + 0x0);\n\n\taddress |= 0x1;  \n\n\twriteb(address, bp->i2c_control_regs + 0x1);\n\twriteb(I2C_PCF_START, bp->i2c_control_regs + 0x0);\n\tif (wait_for_pin(bp, &status))\n\t\tgoto out;\n\n\t \n\t(void) readb(bp->i2c_control_regs + 0x1);\n\tif (wait_for_pin(bp, &status))\n\t\tgoto out;\n\n\twriteb(I2C_PCF_ESO | I2C_PCF_ENI, bp->i2c_control_regs + 0x0);\n\t*byte = readb(bp->i2c_control_regs + 0x1);\n\tif (wait_for_pin(bp, &status))\n\t\tgoto out;\n\n\tret = 0;\n\nout:\n\twriteb(I2C_PCF_STOP, bp->i2c_control_regs + 0x0);\n\t(void) readb(bp->i2c_control_regs + 0x1);\n\n\treturn ret;\n}\n\nint bbc_i2c_write_buf(struct bbc_i2c_client *client,\n\t\t      char *buf, int len, int off)\n{\n\tint ret = 0;\n\n\twhile (len > 0) {\n\t\tret = bbc_i2c_writeb(client, *buf, off);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tlen--;\n\t\tbuf++;\n\t\toff++;\n\t}\n\treturn ret;\n}\n\nint bbc_i2c_read_buf(struct bbc_i2c_client *client,\n\t\t     char *buf, int len, int off)\n{\n\tint ret = 0;\n\n\twhile (len > 0) {\n\t\tret = bbc_i2c_readb(client, buf, off);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tlen--;\n\t\tbuf++;\n\t\toff++;\n\t}\n\n\treturn ret;\n}\n\nEXPORT_SYMBOL(bbc_i2c_getdev);\nEXPORT_SYMBOL(bbc_i2c_attach);\nEXPORT_SYMBOL(bbc_i2c_detach);\nEXPORT_SYMBOL(bbc_i2c_writeb);\nEXPORT_SYMBOL(bbc_i2c_readb);\nEXPORT_SYMBOL(bbc_i2c_write_buf);\nEXPORT_SYMBOL(bbc_i2c_read_buf);\n\nstatic irqreturn_t bbc_i2c_interrupt(int irq, void *dev_id)\n{\n\tstruct bbc_i2c_bus *bp = dev_id;\n\n\t \n\tif (bp->waiting &&\n\t    !(readb(bp->i2c_control_regs + 0x0) & I2C_PCF_PIN))\n\t\twake_up_interruptible(&bp->wq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void reset_one_i2c(struct bbc_i2c_bus *bp)\n{\n\twriteb(I2C_PCF_PIN, bp->i2c_control_regs + 0x0);\n\twriteb(bp->own, bp->i2c_control_regs + 0x1);\n\twriteb(I2C_PCF_PIN | I2C_PCF_ES1, bp->i2c_control_regs + 0x0);\n\twriteb(bp->clock, bp->i2c_control_regs + 0x1);\n\twriteb(I2C_PCF_IDLE, bp->i2c_control_regs + 0x0);\n}\n\nstatic struct bbc_i2c_bus * attach_one_i2c(struct platform_device *op, int index)\n{\n\tstruct bbc_i2c_bus *bp;\n\tstruct device_node *dp;\n\tint entry;\n\n\tbp = kzalloc(sizeof(*bp), GFP_KERNEL);\n\tif (!bp)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&bp->temps);\n\tINIT_LIST_HEAD(&bp->fans);\n\n\tbp->i2c_control_regs = of_ioremap(&op->resource[0], 0, 0x2, \"bbc_i2c_regs\");\n\tif (!bp->i2c_control_regs)\n\t\tgoto fail;\n\n\tif (op->num_resources == 2) {\n\t\tbp->i2c_bussel_reg = of_ioremap(&op->resource[1], 0, 0x1, \"bbc_i2c_bussel\");\n\t\tif (!bp->i2c_bussel_reg)\n\t\t\tgoto fail;\n\t}\n\n\tbp->waiting = 0;\n\tinit_waitqueue_head(&bp->wq);\n\tif (request_irq(op->archdata.irqs[0], bbc_i2c_interrupt,\n\t\t\tIRQF_SHARED, \"bbc_i2c\", bp))\n\t\tgoto fail;\n\n\tbp->index = index;\n\tbp->op = op;\n\n\tspin_lock_init(&bp->lock);\n\n\tentry = 0;\n\tfor (dp = op->dev.of_node->child;\n\t     dp && entry < 8;\n\t     dp = dp->sibling, entry++) {\n\t\tstruct platform_device *child_op;\n\n\t\tchild_op = of_find_device_by_node(dp);\n\t\tbp->devs[entry].device = child_op;\n\t\tbp->devs[entry].client_claimed = 0;\n\t}\n\n\twriteb(I2C_PCF_PIN, bp->i2c_control_regs + 0x0);\n\tbp->own = readb(bp->i2c_control_regs + 0x01);\n\twriteb(I2C_PCF_PIN | I2C_PCF_ES1, bp->i2c_control_regs + 0x0);\n\tbp->clock = readb(bp->i2c_control_regs + 0x01);\n\n\tprintk(KERN_INFO \"i2c-%d: Regs at %p, %d devices, own %02x, clock %02x.\\n\",\n\t       bp->index, bp->i2c_control_regs, entry, bp->own, bp->clock);\n\n\treset_one_i2c(bp);\n\n\treturn bp;\n\nfail:\n\tif (bp->i2c_bussel_reg)\n\t\tof_iounmap(&op->resource[1], bp->i2c_bussel_reg, 1);\n\tif (bp->i2c_control_regs)\n\t\tof_iounmap(&op->resource[0], bp->i2c_control_regs, 2);\n\tkfree(bp);\n\treturn NULL;\n}\n\nextern int bbc_envctrl_init(struct bbc_i2c_bus *bp);\nextern void bbc_envctrl_cleanup(struct bbc_i2c_bus *bp);\n\nstatic int bbc_i2c_probe(struct platform_device *op)\n{\n\tstruct bbc_i2c_bus *bp;\n\tint err, index = 0;\n\n\tbp = attach_one_i2c(op, index);\n\tif (!bp)\n\t\treturn -EINVAL;\n\n\terr = bbc_envctrl_init(bp);\n\tif (err) {\n\t\tfree_irq(op->archdata.irqs[0], bp);\n\t\tif (bp->i2c_bussel_reg)\n\t\t\tof_iounmap(&op->resource[0], bp->i2c_bussel_reg, 1);\n\t\tif (bp->i2c_control_regs)\n\t\t\tof_iounmap(&op->resource[1], bp->i2c_control_regs, 2);\n\t\tkfree(bp);\n\t} else {\n\t\tdev_set_drvdata(&op->dev, bp);\n\t}\n\n\treturn err;\n}\n\nstatic int bbc_i2c_remove(struct platform_device *op)\n{\n\tstruct bbc_i2c_bus *bp = dev_get_drvdata(&op->dev);\n\n\tbbc_envctrl_cleanup(bp);\n\n\tfree_irq(op->archdata.irqs[0], bp);\n\n\tif (bp->i2c_bussel_reg)\n\t\tof_iounmap(&op->resource[0], bp->i2c_bussel_reg, 1);\n\tif (bp->i2c_control_regs)\n\t\tof_iounmap(&op->resource[1], bp->i2c_control_regs, 2);\n\n\tkfree(bp);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bbc_i2c_match[] = {\n\t{\n\t\t.name = \"i2c\",\n\t\t.compatible = \"SUNW,bbc-i2c\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bbc_i2c_match);\n\nstatic struct platform_driver bbc_i2c_driver = {\n\t.driver = {\n\t\t.name = \"bbc_i2c\",\n\t\t.of_match_table = bbc_i2c_match,\n\t},\n\t.probe\t\t= bbc_i2c_probe,\n\t.remove\t\t= bbc_i2c_remove,\n};\n\nmodule_platform_driver(bbc_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}