{
  "module_name": "oradax.c",
  "hash_id": "dcd45344a8085bf0ae969e3fe9f922f5da0c003e06e95cb9256f53330dfda9b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sbus/char/oradax.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/cdev.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n#include <asm/hypervisor.h>\n#include <asm/mdesc.h>\n#include <asm/oradax.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Driver for Oracle Data Analytics Accelerator\");\n\n#define\tDAX_DBG_FLG_BASIC\t0x01\n#define\tDAX_DBG_FLG_STAT\t0x02\n#define\tDAX_DBG_FLG_INFO\t0x04\n#define\tDAX_DBG_FLG_ALL\t\t0xff\n\n#define\tdax_err(fmt, ...)      pr_err(\"%s: \" fmt \"\\n\", __func__, ##__VA_ARGS__)\n#define\tdax_info(fmt, ...)     pr_info(\"%s: \" fmt \"\\n\", __func__, ##__VA_ARGS__)\n\n#define\tdax_dbg(fmt, ...)\tdo {\t\t\t\t\t\\\n\t\t\t\t\tif (dax_debug & DAX_DBG_FLG_BASIC)\\\n\t\t\t\t\t\tdax_info(fmt, ##__VA_ARGS__); \\\n\t\t\t\t} while (0)\n#define\tdax_stat_dbg(fmt, ...)\tdo {\t\t\t\t\t\\\n\t\t\t\t\tif (dax_debug & DAX_DBG_FLG_STAT) \\\n\t\t\t\t\t\tdax_info(fmt, ##__VA_ARGS__); \\\n\t\t\t\t} while (0)\n#define\tdax_info_dbg(fmt, ...)\tdo { \\\n\t\t\t\t\tif (dax_debug & DAX_DBG_FLG_INFO) \\\n\t\t\t\t\t\tdax_info(fmt, ##__VA_ARGS__); \\\n\t\t\t\t} while (0)\n\n#define\tDAX1_MINOR\t\t1\n#define\tDAX1_MAJOR\t\t1\n#define\tDAX2_MINOR\t\t0\n#define\tDAX2_MAJOR\t\t2\n\n#define\tDAX1_STR    \"ORCL,sun4v-dax\"\n#define\tDAX2_STR    \"ORCL,sun4v-dax2\"\n\n#define\tDAX_CA_ELEMS\t\t(DAX_MMAP_LEN / sizeof(struct dax_cca))\n\n#define\tDAX_CCB_USEC\t\t100\n#define\tDAX_CCB_RETRIES\t\t10000\n\n \nenum {\n\tOUT,\n\tPRI,\n\tSEC,\n\tTBL,\n\tNUM_STREAM_TYPES\n};\n\n \n#define\tCCA_STAT_NOT_COMPLETED\t0\n#define\tCCA_STAT_COMPLETED\t1\n#define\tCCA_STAT_FAILED\t\t2\n#define\tCCA_STAT_KILLED\t\t3\n#define\tCCA_STAT_NOT_RUN\t4\n#define\tCCA_STAT_PIPE_OUT\t5\n#define\tCCA_STAT_PIPE_SRC\t6\n#define\tCCA_STAT_PIPE_DST\t7\n\n \n#define\tCCA_ERR_SUCCESS\t\t0x0\t \n#define\tCCA_ERR_OVERFLOW\t0x1\t \n#define\tCCA_ERR_DECODE\t\t0x2\t \n#define\tCCA_ERR_PAGE_OVERFLOW\t0x3\t \n#define\tCCA_ERR_KILLED\t\t0x7\t \n#define\tCCA_ERR_TIMEOUT\t\t0x8\t \n#define\tCCA_ERR_ADI\t\t0x9\t \n#define\tCCA_ERR_DATA_FMT\t0xA\t \n#define\tCCA_ERR_OTHER_NO_RETRY\t0xE\t \n#define\tCCA_ERR_OTHER_RETRY\t0xF\t \n#define\tCCA_ERR_PARTIAL_SYMBOL\t0x80\t \n\n \n#define\tDAX_ADDR_TYPE_NONE\t0\n#define\tDAX_ADDR_TYPE_VA_ALT\t1\t \n#define\tDAX_ADDR_TYPE_RA\t2\t \n#define\tDAX_ADDR_TYPE_VA\t3\t \n\n \n#define\tDAX_OP_SYNC_NOP\t\t0x0\n#define\tDAX_OP_EXTRACT\t\t0x1\n#define\tDAX_OP_SCAN_VALUE\t0x2\n#define\tDAX_OP_SCAN_RANGE\t0x3\n#define\tDAX_OP_TRANSLATE\t0x4\n#define\tDAX_OP_SELECT\t\t0x5\n#define\tDAX_OP_INVERT\t\t0x10\t \n\nstruct dax_header {\n\tu32 ccb_version:4;\t \n\t\t\t\t \n\tu32 pipe:1;\t\t \n\tu32 longccb:1;\t\t \n\tu32 cond:1;\t\t \n\tu32 serial:1;\t\t \n\tu32 opcode:8;\t\t \n\t\t\t\t \n\tu32 reserved:3;\t\t \n\tu32 table_addr_type:2;\t \n\tu32 out_addr_type:3;\t \n\tu32 sec_addr_type:3;\t \n\tu32 pri_addr_type:3;\t \n\tu32 cca_addr_type:2;\t \n};\n\nstruct dax_control {\n\tu32 pri_fmt:4;\t\t \n\tu32 pri_elem_size:5;\t \n\tu32 pri_offset:3;\t \n\tu32 sec_encoding:1;\t \n\t\t\t\t \n\tu32 sec_offset:3;\t \n\tu32 sec_elem_size:2;\t \n\t\t\t\t \n\tu32 out_fmt:2;\t\t \n\tu32 out_elem_size:2;\t \n\tu32 misc:10;\t\t \n};\n\nstruct dax_data_access {\n\tu64 flow_ctrl:2;\t \n\tu64 pipe_target:2;\t \n\tu64 out_buf_size:20;\t \n\t\t\t\t \n\tu64 unused1:8;\t\t \n\tu64 out_alloc:5;\t \n\tu64 unused2:1;\t\t \n\tu64 pri_len_fmt:2;\t \n\tu64 pri_len:24;\t\t \n\t\t\t\t \n};\n\nstruct dax_ccb {\n\tstruct dax_header hdr;\t \n\tstruct dax_control ctrl; \n\tvoid *ca;\t\t \n\tvoid *pri;\t\t \n\tstruct dax_data_access dac;  \n\tvoid *sec;\t\t \n\tu64 dword5;\t\t \n\tvoid *out;\t\t \n\tvoid *tbl;\t\t \n};\n\nstruct dax_cca {\n\tu8\tstatus;\t\t \n\tu8\terr;\t\t \n\tu8\trsvd[2];\t \n\tu32\tn_remaining;\t \n\tu32\toutput_sz;\t \n\tu32\trsvd2;\t\t \n\tu64\trun_cycles;\t \n\tu64\trun_stats;\t \n\tu32\tn_processed;\t \n\tu32\trsvd3[5];\t \n\tu64\tretval;\t\t \n\tu64\trsvd4[8];\t \n};\n\n \nstruct dax_ctx {\n\tstruct dax_ccb\t\t*ccb_buf;\n\tu64\t\t\tccb_buf_ra;\t \n\tstruct dax_cca\t\t*ca_buf;\n\tu64\t\t\tca_buf_ra;\t \n\tstruct page\t\t*pages[DAX_CA_ELEMS][NUM_STREAM_TYPES];\n\t\t\t\t\t\t \n\tstruct task_struct\t*owner;\t\t \n\tstruct task_struct\t*client;\t \n\tunion ccb_result\tresult;\n\tu32\t\t\tccb_count;\n\tu32\t\t\tfail_count;\n};\n\n \nstatic int dax_open(struct inode *inode, struct file *file);\nstatic ssize_t dax_read(struct file *filp, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos);\nstatic ssize_t dax_write(struct file *filp, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos);\nstatic int dax_devmap(struct file *f, struct vm_area_struct *vma);\nstatic int dax_close(struct inode *i, struct file *f);\n\nstatic const struct file_operations dax_fops = {\n\t.owner\t=\tTHIS_MODULE,\n\t.open\t=\tdax_open,\n\t.read\t=\tdax_read,\n\t.write\t=\tdax_write,\n\t.mmap\t=\tdax_devmap,\n\t.release =\tdax_close,\n};\n\nstatic int dax_ccb_exec(struct dax_ctx *ctx, const char __user *buf,\n\t\t\tsize_t count, loff_t *ppos);\nstatic int dax_ccb_info(u64 ca, struct ccb_info_result *info);\nstatic int dax_ccb_kill(u64 ca, u16 *kill_res);\n\nstatic struct cdev c_dev;\nstatic dev_t first;\nstatic const struct class cl = {\n\t.name = DAX_NAME,\n};\n\nstatic int max_ccb_version;\nstatic int dax_debug;\nmodule_param(dax_debug, int, 0644);\nMODULE_PARM_DESC(dax_debug, \"Debug flags\");\n\nstatic int __init dax_attach(void)\n{\n\tunsigned long dummy, hv_rv, major, minor, minor_requested, max_ccbs;\n\tstruct mdesc_handle *hp = mdesc_grab();\n\tchar *prop, *dax_name;\n\tbool found = false;\n\tint len, ret = 0;\n\tu64 pn;\n\n\tif (hp == NULL) {\n\t\tdax_err(\"Unable to grab mdesc\");\n\t\treturn -ENODEV;\n\t}\n\n\tmdesc_for_each_node_by_name(hp, pn, \"virtual-device\") {\n\t\tprop = (char *)mdesc_get_property(hp, pn, \"name\", &len);\n\t\tif (prop == NULL)\n\t\t\tcontinue;\n\t\tif (strncmp(prop, \"dax\", strlen(\"dax\")))\n\t\t\tcontinue;\n\t\tdax_dbg(\"Found node 0x%llx = %s\", pn, prop);\n\n\t\tprop = (char *)mdesc_get_property(hp, pn, \"compatible\", &len);\n\t\tif (prop == NULL)\n\t\t\tcontinue;\n\t\tdax_dbg(\"Found node 0x%llx = %s\", pn, prop);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\n\tif (!found) {\n\t\tdax_err(\"No DAX device found\");\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (strncmp(prop, DAX2_STR, strlen(DAX2_STR)) == 0) {\n\t\tdax_name = DAX_NAME \"2\";\n\t\tmajor = DAX2_MAJOR;\n\t\tminor_requested = DAX2_MINOR;\n\t\tmax_ccb_version = 1;\n\t\tdax_dbg(\"MD indicates DAX2 coprocessor\");\n\t} else if (strncmp(prop, DAX1_STR, strlen(DAX1_STR)) == 0) {\n\t\tdax_name = DAX_NAME \"1\";\n\t\tmajor = DAX1_MAJOR;\n\t\tminor_requested = DAX1_MINOR;\n\t\tmax_ccb_version = 0;\n\t\tdax_dbg(\"MD indicates DAX1 coprocessor\");\n\t} else {\n\t\tdax_err(\"Unknown dax type: %s\", prop);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tminor = minor_requested;\n\tdax_dbg(\"Registering DAX HV api with major %ld minor %ld\", major,\n\t\tminor);\n\tif (sun4v_hvapi_register(HV_GRP_DAX, major, &minor)) {\n\t\tdax_err(\"hvapi_register failed\");\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t} else {\n\t\tdax_dbg(\"Max minor supported by HV = %ld (major %ld)\", minor,\n\t\t\tmajor);\n\t\tminor = min(minor, minor_requested);\n\t\tdax_dbg(\"registered DAX major %ld minor %ld\", major, minor);\n\t}\n\n\t \n\thv_rv = sun4v_ccb_submit(0, 0, HV_CCB_QUERY_CMD, 0, &max_ccbs, &dummy);\n\tif (hv_rv != 0) {\n\t\tdax_err(\"get_hwqueue_size failed with status=%ld and max_ccbs=%ld\",\n\t\t\thv_rv, max_ccbs);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (max_ccbs != DAX_MAX_CCBS) {\n\t\tdax_err(\"HV reports unsupported max_ccbs=%ld\", max_ccbs);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (alloc_chrdev_region(&first, 0, 1, DAX_NAME) < 0) {\n\t\tdax_err(\"alloc_chrdev_region failed\");\n\t\tret = -ENXIO;\n\t\tgoto done;\n\t}\n\n\tret = class_register(&cl);\n\tif (ret)\n\t\tgoto class_error;\n\n\tif (device_create(&cl, NULL, first, NULL, dax_name) == NULL) {\n\t\tdax_err(\"device_create failed\");\n\t\tret = -ENXIO;\n\t\tgoto device_error;\n\t}\n\n\tcdev_init(&c_dev, &dax_fops);\n\tif (cdev_add(&c_dev, first, 1) == -1) {\n\t\tdax_err(\"cdev_add failed\");\n\t\tret = -ENXIO;\n\t\tgoto cdev_error;\n\t}\n\n\tpr_info(\"Attached DAX module\\n\");\n\tgoto done;\n\ncdev_error:\n\tdevice_destroy(&cl, first);\ndevice_error:\n\tclass_unregister(&cl);\nclass_error:\n\tunregister_chrdev_region(first, 1);\ndone:\n\tmdesc_release(hp);\n\treturn ret;\n}\nmodule_init(dax_attach);\n\nstatic void __exit dax_detach(void)\n{\n\tpr_info(\"Cleaning up DAX module\\n\");\n\tcdev_del(&c_dev);\n\tdevice_destroy(&cl, first);\n\tclass_unregister(&cl);\n\tunregister_chrdev_region(first, 1);\n}\nmodule_exit(dax_detach);\n\n \nstatic int dax_devmap(struct file *f, struct vm_area_struct *vma)\n{\n\tstruct dax_ctx *ctx = (struct dax_ctx *)f->private_data;\n\tsize_t len = vma->vm_end - vma->vm_start;\n\n\tdax_dbg(\"len=0x%lx, flags=0x%lx\", len, vma->vm_flags);\n\n\tif (ctx->owner != current) {\n\t\tdax_dbg(\"devmap called from wrong thread\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (len != DAX_MMAP_LEN) {\n\t\tdax_dbg(\"len(%lu) != DAX_MMAP_LEN(%d)\", len, DAX_MMAP_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (vma->vm_flags & VM_WRITE)\n\t\treturn -EPERM;\n\tvm_flags_clear(vma, VM_MAYWRITE);\n\n\tif (remap_pfn_range(vma, vma->vm_start, ctx->ca_buf_ra >> PAGE_SHIFT,\n\t\t\t    len, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\n\tdax_dbg(\"mmapped completion area at uva 0x%lx\", vma->vm_start);\n\treturn 0;\n}\n\n \nstatic void dax_unlock_pages(struct dax_ctx *ctx, int ccb_index, int nelem)\n{\n\tint i, j;\n\n\tfor (i = ccb_index; i < ccb_index + nelem; i++) {\n\t\tfor (j = 0; j < NUM_STREAM_TYPES; j++) {\n\t\t\tstruct page *p = ctx->pages[i][j];\n\n\t\t\tif (p) {\n\t\t\t\tdax_dbg(\"freeing page %p\", p);\n\t\t\t\tunpin_user_pages_dirty_lock(&p, 1, j == OUT);\n\t\t\t\tctx->pages[i][j] = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int dax_lock_page(void *va, struct page **p)\n{\n\tint ret;\n\n\tdax_dbg(\"uva %p\", va);\n\n\tret = pin_user_pages_fast((unsigned long)va, 1, FOLL_WRITE, p);\n\tif (ret == 1) {\n\t\tdax_dbg(\"locked page %p, for VA %p\", *p, va);\n\t\treturn 0;\n\t}\n\n\tdax_dbg(\"pin_user_pages failed, va=%p, ret=%d\", va, ret);\n\treturn -1;\n}\n\nstatic int dax_lock_pages(struct dax_ctx *ctx, int idx,\n\t\t\t  int nelem, u64 *err_va)\n{\n\tint i;\n\n\tfor (i = 0; i < nelem; i++) {\n\t\tstruct dax_ccb *ccbp = &ctx->ccb_buf[i];\n\n\t\t \n\t\tif (ccbp->hdr.out_addr_type == DAX_ADDR_TYPE_VA) {\n\t\t\tdax_dbg(\"output\");\n\t\t\tif (dax_lock_page(ccbp->out,\n\t\t\t\t\t  &ctx->pages[i + idx][OUT]) != 0) {\n\t\t\t\t*err_va = (u64)ccbp->out;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tccbp->hdr.out_addr_type = DAX_ADDR_TYPE_VA_ALT;\n\t\t}\n\n\t\tif (ccbp->hdr.pri_addr_type == DAX_ADDR_TYPE_VA) {\n\t\t\tdax_dbg(\"input\");\n\t\t\tif (dax_lock_page(ccbp->pri,\n\t\t\t\t\t  &ctx->pages[i + idx][PRI]) != 0) {\n\t\t\t\t*err_va = (u64)ccbp->pri;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tccbp->hdr.pri_addr_type = DAX_ADDR_TYPE_VA_ALT;\n\t\t}\n\n\t\tif (ccbp->hdr.sec_addr_type == DAX_ADDR_TYPE_VA) {\n\t\t\tdax_dbg(\"sec input\");\n\t\t\tif (dax_lock_page(ccbp->sec,\n\t\t\t\t\t  &ctx->pages[i + idx][SEC]) != 0) {\n\t\t\t\t*err_va = (u64)ccbp->sec;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tccbp->hdr.sec_addr_type = DAX_ADDR_TYPE_VA_ALT;\n\t\t}\n\n\t\tif (ccbp->hdr.table_addr_type == DAX_ADDR_TYPE_VA) {\n\t\t\tdax_dbg(\"tbl\");\n\t\t\tif (dax_lock_page(ccbp->tbl,\n\t\t\t\t\t  &ctx->pages[i + idx][TBL]) != 0) {\n\t\t\t\t*err_va = (u64)ccbp->tbl;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tccbp->hdr.table_addr_type = DAX_ADDR_TYPE_VA_ALT;\n\t\t}\n\n\t\t \n\t\tif (ccbp->hdr.longccb)\n\t\t\ti++;\n\t}\n\treturn DAX_SUBMIT_OK;\n\nerror:\n\tdax_unlock_pages(ctx, idx, nelem);\n\treturn DAX_SUBMIT_ERR_NOACCESS;\n}\n\nstatic void dax_ccb_wait(struct dax_ctx *ctx, int idx)\n{\n\tint ret, nretries;\n\tu16 kill_res;\n\n\tdax_dbg(\"idx=%d\", idx);\n\n\tfor (nretries = 0; nretries < DAX_CCB_RETRIES; nretries++) {\n\t\tif (ctx->ca_buf[idx].status == CCA_STAT_NOT_COMPLETED)\n\t\t\tudelay(DAX_CCB_USEC);\n\t\telse\n\t\t\treturn;\n\t}\n\tdax_dbg(\"ctx (%p): CCB[%d] timed out, wait usec=%d, retries=%d. Killing ccb\",\n\t\t(void *)ctx, idx, DAX_CCB_USEC, DAX_CCB_RETRIES);\n\n\tret = dax_ccb_kill(ctx->ca_buf_ra + idx * sizeof(struct dax_cca),\n\t\t\t   &kill_res);\n\tdax_dbg(\"Kill CCB[%d] %s\", idx, ret ? \"failed\" : \"succeeded\");\n}\n\nstatic int dax_close(struct inode *ino, struct file *f)\n{\n\tstruct dax_ctx *ctx = (struct dax_ctx *)f->private_data;\n\tint i;\n\n\tf->private_data = NULL;\n\n\tfor (i = 0; i < DAX_CA_ELEMS; i++) {\n\t\tif (ctx->ca_buf[i].status == CCA_STAT_NOT_COMPLETED) {\n\t\t\tdax_dbg(\"CCB[%d] not completed\", i);\n\t\t\tdax_ccb_wait(ctx, i);\n\t\t}\n\t\tdax_unlock_pages(ctx, i, 1);\n\t}\n\n\tkfree(ctx->ccb_buf);\n\tkfree(ctx->ca_buf);\n\tdax_stat_dbg(\"CCBs: %d good, %d bad\", ctx->ccb_count, ctx->fail_count);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic ssize_t dax_read(struct file *f, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct dax_ctx *ctx = f->private_data;\n\n\tif (ctx->client != current)\n\t\treturn -EUSERS;\n\n\tctx->client = NULL;\n\n\tif (count != sizeof(union ccb_result))\n\t\treturn -EINVAL;\n\tif (copy_to_user(buf, &ctx->result, sizeof(union ccb_result)))\n\t\treturn -EFAULT;\n\treturn count;\n}\n\nstatic ssize_t dax_write(struct file *f, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct dax_ctx *ctx = f->private_data;\n\tstruct dax_command hdr;\n\tunsigned long ca;\n\tint i, idx, ret;\n\n\tif (ctx->client != NULL)\n\t\treturn -EINVAL;\n\n\tif (count == 0 || count > DAX_MAX_CCBS * sizeof(struct dax_ccb))\n\t\treturn -EINVAL;\n\n\tif (count % sizeof(struct dax_ccb) == 0)\n\t\treturn dax_ccb_exec(ctx, buf, count, ppos);  \n\n\tif (count != sizeof(struct dax_command))\n\t\treturn -EINVAL;\n\n\t \n\tif (ctx->owner != current)\n\t\treturn -EUSERS;\n\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tca = ctx->ca_buf_ra + hdr.ca_offset;\n\n\tswitch (hdr.command) {\n\tcase CCB_KILL:\n\t\tif (hdr.ca_offset >= DAX_MMAP_LEN) {\n\t\t\tdax_dbg(\"invalid ca_offset (%d) >= ca_buflen (%d)\",\n\t\t\t\thdr.ca_offset, DAX_MMAP_LEN);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = dax_ccb_kill(ca, &ctx->result.kill.action);\n\t\tif (ret != 0) {\n\t\t\tdax_dbg(\"dax_ccb_kill failed (ret=%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdax_info_dbg(\"killed (ca_offset %d)\", hdr.ca_offset);\n\t\tidx = hdr.ca_offset / sizeof(struct dax_cca);\n\t\tctx->ca_buf[idx].status = CCA_STAT_KILLED;\n\t\tctx->ca_buf[idx].err = CCA_ERR_KILLED;\n\t\tctx->client = current;\n\t\treturn count;\n\n\tcase CCB_INFO:\n\t\tif (hdr.ca_offset >= DAX_MMAP_LEN) {\n\t\t\tdax_dbg(\"invalid ca_offset (%d) >= ca_buflen (%d)\",\n\t\t\t\thdr.ca_offset, DAX_MMAP_LEN);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = dax_ccb_info(ca, &ctx->result.info);\n\t\tif (ret != 0) {\n\t\t\tdax_dbg(\"dax_ccb_info failed (ret=%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdax_info_dbg(\"info succeeded on ca_offset %d\", hdr.ca_offset);\n\t\tctx->client = current;\n\t\treturn count;\n\n\tcase CCB_DEQUEUE:\n\t\tfor (i = 0; i < DAX_CA_ELEMS; i++) {\n\t\t\tif (ctx->ca_buf[i].status !=\n\t\t\t    CCA_STAT_NOT_COMPLETED)\n\t\t\t\tdax_unlock_pages(ctx, i, 1);\n\t\t}\n\t\treturn count;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int dax_open(struct inode *inode, struct file *f)\n{\n\tstruct dax_ctx *ctx = NULL;\n\tint i;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (ctx == NULL)\n\t\tgoto done;\n\n\tctx->ccb_buf = kcalloc(DAX_MAX_CCBS, sizeof(struct dax_ccb),\n\t\t\t       GFP_KERNEL);\n\tif (ctx->ccb_buf == NULL)\n\t\tgoto done;\n\n\tctx->ccb_buf_ra = virt_to_phys(ctx->ccb_buf);\n\tdax_dbg(\"ctx->ccb_buf=0x%p, ccb_buf_ra=0x%llx\",\n\t\t(void *)ctx->ccb_buf, ctx->ccb_buf_ra);\n\n\t \n\tctx->ca_buf = kzalloc(DAX_MMAP_LEN, GFP_KERNEL);\n\tif (ctx->ca_buf == NULL)\n\t\tgoto alloc_error;\n\tfor (i = 0; i < DAX_CA_ELEMS; i++)\n\t\tctx->ca_buf[i].status = CCA_STAT_COMPLETED;\n\n\tctx->ca_buf_ra = virt_to_phys(ctx->ca_buf);\n\tdax_dbg(\"ctx=0x%p, ctx->ca_buf=0x%p, ca_buf_ra=0x%llx\",\n\t\t(void *)ctx, (void *)ctx->ca_buf, ctx->ca_buf_ra);\n\n\tctx->owner = current;\n\tf->private_data = ctx;\n\treturn 0;\n\nalloc_error:\n\tkfree(ctx->ccb_buf);\ndone:\n\tkfree(ctx);\n\treturn -ENOMEM;\n}\n\nstatic char *dax_hv_errno(unsigned long hv_ret, int *ret)\n{\n\tswitch (hv_ret) {\n\tcase HV_EBADALIGN:\n\t\t*ret = -EFAULT;\n\t\treturn \"HV_EBADALIGN\";\n\tcase HV_ENORADDR:\n\t\t*ret = -EFAULT;\n\t\treturn \"HV_ENORADDR\";\n\tcase HV_EINVAL:\n\t\t*ret = -EINVAL;\n\t\treturn \"HV_EINVAL\";\n\tcase HV_EWOULDBLOCK:\n\t\t*ret = -EAGAIN;\n\t\treturn \"HV_EWOULDBLOCK\";\n\tcase HV_ENOACCESS:\n\t\t*ret = -EPERM;\n\t\treturn \"HV_ENOACCESS\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\t*ret = -EIO;\n\treturn \"UNKNOWN\";\n}\n\nstatic int dax_ccb_kill(u64 ca, u16 *kill_res)\n{\n\tunsigned long hv_ret;\n\tint count, ret = 0;\n\tchar *err_str;\n\n\tfor (count = 0; count < DAX_CCB_RETRIES; count++) {\n\t\tdax_dbg(\"attempting kill on ca_ra 0x%llx\", ca);\n\t\thv_ret = sun4v_ccb_kill(ca, kill_res);\n\n\t\tif (hv_ret == HV_EOK) {\n\t\t\tdax_info_dbg(\"HV_EOK (ca_ra 0x%llx): %d\", ca,\n\t\t\t\t     *kill_res);\n\t\t} else {\n\t\t\terr_str = dax_hv_errno(hv_ret, &ret);\n\t\t\tdax_dbg(\"%s (ca_ra 0x%llx)\", err_str, ca);\n\t\t}\n\n\t\tif (ret != -EAGAIN)\n\t\t\treturn ret;\n\t\tdax_info_dbg(\"ccb_kill count = %d\", count);\n\t\tudelay(DAX_CCB_USEC);\n\t}\n\n\treturn -EAGAIN;\n}\n\nstatic int dax_ccb_info(u64 ca, struct ccb_info_result *info)\n{\n\tunsigned long hv_ret;\n\tchar *err_str;\n\tint ret = 0;\n\n\tdax_dbg(\"attempting info on ca_ra 0x%llx\", ca);\n\thv_ret = sun4v_ccb_info(ca, info);\n\n\tif (hv_ret == HV_EOK) {\n\t\tdax_info_dbg(\"HV_EOK (ca_ra 0x%llx): %d\", ca, info->state);\n\t\tif (info->state == DAX_CCB_ENQUEUED) {\n\t\t\tdax_info_dbg(\"dax_unit %d, queue_num %d, queue_pos %d\",\n\t\t\t\t     info->inst_num, info->q_num, info->q_pos);\n\t\t}\n\t} else {\n\t\terr_str = dax_hv_errno(hv_ret, &ret);\n\t\tdax_dbg(\"%s (ca_ra 0x%llx)\", err_str, ca);\n\t}\n\n\treturn ret;\n}\n\nstatic void dax_prt_ccbs(struct dax_ccb *ccb, int nelem)\n{\n\tint i, j;\n\tu64 *ccbp;\n\n\tdax_dbg(\"ccb buffer:\");\n\tfor (i = 0; i < nelem; i++) {\n\t\tccbp = (u64 *)&ccb[i];\n\t\tdax_dbg(\" %sccb[%d]\", ccb[i].hdr.longccb ? \"long \" : \"\",  i);\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tdax_dbg(\"\\tccb[%d].dwords[%d]=0x%llx\",\n\t\t\t\ti, j, *(ccbp + j));\n\t}\n}\n\n \nstatic int dax_preprocess_usr_ccbs(struct dax_ctx *ctx, int idx, int nelem)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < nelem; i++) {\n\t\tstruct dax_ccb *ccbp = &ctx->ccb_buf[i];\n\t\tunsigned long ca_offset;\n\n\t\tif (ccbp->hdr.ccb_version > max_ccb_version)\n\t\t\treturn DAX_SUBMIT_ERR_CCB_INVAL;\n\n\t\tswitch (ccbp->hdr.opcode) {\n\t\tcase DAX_OP_SYNC_NOP:\n\t\tcase DAX_OP_EXTRACT:\n\t\tcase DAX_OP_SCAN_VALUE:\n\t\tcase DAX_OP_SCAN_RANGE:\n\t\tcase DAX_OP_TRANSLATE:\n\t\tcase DAX_OP_SCAN_VALUE | DAX_OP_INVERT:\n\t\tcase DAX_OP_SCAN_RANGE | DAX_OP_INVERT:\n\t\tcase DAX_OP_TRANSLATE | DAX_OP_INVERT:\n\t\tcase DAX_OP_SELECT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn DAX_SUBMIT_ERR_CCB_INVAL;\n\t\t}\n\n\t\tif (ccbp->hdr.out_addr_type != DAX_ADDR_TYPE_VA &&\n\t\t    ccbp->hdr.out_addr_type != DAX_ADDR_TYPE_NONE) {\n\t\t\tdax_dbg(\"invalid out_addr_type in user CCB[%d]\", i);\n\t\t\treturn DAX_SUBMIT_ERR_CCB_INVAL;\n\t\t}\n\n\t\tif (ccbp->hdr.pri_addr_type != DAX_ADDR_TYPE_VA &&\n\t\t    ccbp->hdr.pri_addr_type != DAX_ADDR_TYPE_NONE) {\n\t\t\tdax_dbg(\"invalid pri_addr_type in user CCB[%d]\", i);\n\t\t\treturn DAX_SUBMIT_ERR_CCB_INVAL;\n\t\t}\n\n\t\tif (ccbp->hdr.sec_addr_type != DAX_ADDR_TYPE_VA &&\n\t\t    ccbp->hdr.sec_addr_type != DAX_ADDR_TYPE_NONE) {\n\t\t\tdax_dbg(\"invalid sec_addr_type in user CCB[%d]\", i);\n\t\t\treturn DAX_SUBMIT_ERR_CCB_INVAL;\n\t\t}\n\n\t\tif (ccbp->hdr.table_addr_type != DAX_ADDR_TYPE_VA &&\n\t\t    ccbp->hdr.table_addr_type != DAX_ADDR_TYPE_NONE) {\n\t\t\tdax_dbg(\"invalid table_addr_type in user CCB[%d]\", i);\n\t\t\treturn DAX_SUBMIT_ERR_CCB_INVAL;\n\t\t}\n\n\t\t \n\t\tccbp->hdr.cca_addr_type = DAX_ADDR_TYPE_RA;\n\t\tca_offset = (idx + i) * sizeof(struct dax_cca);\n\t\tccbp->ca = (void *)ctx->ca_buf_ra + ca_offset;\n\t\tmemset(&ctx->ca_buf[idx + i], 0, sizeof(struct dax_cca));\n\n\t\tdax_dbg(\"ccb[%d]=%p, ca_offset=0x%lx, compl RA=0x%llx\",\n\t\t\ti, ccbp, ca_offset, ctx->ca_buf_ra + ca_offset);\n\n\t\t \n\t\tif (ccbp->hdr.longccb)\n\t\t\ti++;\n\t}\n\n\treturn DAX_SUBMIT_OK;\n}\n\nstatic int dax_ccb_exec(struct dax_ctx *ctx, const char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tunsigned long accepted_len, hv_rv;\n\tint i, idx, nccbs, naccepted;\n\n\tctx->client = current;\n\tidx = *ppos;\n\tnccbs = count / sizeof(struct dax_ccb);\n\n\tif (ctx->owner != current) {\n\t\tdax_dbg(\"wrong thread\");\n\t\tctx->result.exec.status = DAX_SUBMIT_ERR_THR_INIT;\n\t\treturn 0;\n\t}\n\tdax_dbg(\"args: ccb_buf_len=%ld, idx=%d\", count, idx);\n\n\t \n\tif (idx < 0 || idx > (DAX_CA_ELEMS - nccbs)) {\n\t\tctx->result.exec.status = DAX_SUBMIT_ERR_NO_CA_AVAIL;\n\t\treturn 0;\n\t}\n\n\t \n\tif (copy_from_user(ctx->ccb_buf, buf, count)) {\n\t\tdax_dbg(\"copyin of user CCB buffer failed\");\n\t\tctx->result.exec.status = DAX_SUBMIT_ERR_CCB_ARR_MMU_MISS;\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = idx; i < idx + nccbs; i++) {\n\t\tif (ctx->ca_buf[i].status == CCA_STAT_NOT_COMPLETED) {\n\t\t\tdax_dbg(\"CA range not available, dequeue needed\");\n\t\t\tctx->result.exec.status = DAX_SUBMIT_ERR_NO_CA_AVAIL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdax_unlock_pages(ctx, idx, nccbs);\n\n\tctx->result.exec.status = dax_preprocess_usr_ccbs(ctx, idx, nccbs);\n\tif (ctx->result.exec.status != DAX_SUBMIT_OK)\n\t\treturn 0;\n\n\tctx->result.exec.status = dax_lock_pages(ctx, idx, nccbs,\n\t\t\t\t\t\t &ctx->result.exec.status_data);\n\tif (ctx->result.exec.status != DAX_SUBMIT_OK)\n\t\treturn 0;\n\n\tif (dax_debug & DAX_DBG_FLG_BASIC)\n\t\tdax_prt_ccbs(ctx->ccb_buf, nccbs);\n\n\thv_rv = sun4v_ccb_submit(ctx->ccb_buf_ra, count,\n\t\t\t\t HV_CCB_QUERY_CMD | HV_CCB_VA_SECONDARY, 0,\n\t\t\t\t &accepted_len, &ctx->result.exec.status_data);\n\n\tswitch (hv_rv) {\n\tcase HV_EOK:\n\t\t \n\t\tctx->result.exec.status = DAX_SUBMIT_OK;\n\t\tbreak;\n\tcase HV_EWOULDBLOCK:\n\t\t \n\t\tdax_dbg(\"hcall returned HV_EWOULDBLOCK\");\n\t\tctx->result.exec.status = DAX_SUBMIT_ERR_WOULDBLOCK;\n\t\tbreak;\n\tcase HV_ENOMAP:\n\t\t \n\t\tdax_dbg(\"hcall returned HV_ENOMAP\");\n\t\tctx->result.exec.status = DAX_SUBMIT_ERR_NOMAP;\n\t\tbreak;\n\tcase HV_EINVAL:\n\t\t \n\t\tdax_dbg(\"hcall returned HV_EINVAL\");\n\t\tctx->result.exec.status = DAX_SUBMIT_ERR_CCB_INVAL;\n\t\tbreak;\n\tcase HV_ENOACCESS:\n\t\t \n\t\tdax_dbg(\"hcall returned HV_ENOACCESS\");\n\t\tctx->result.exec.status = DAX_SUBMIT_ERR_NOACCESS;\n\t\tbreak;\n\tcase HV_EUNAVAILABLE:\n\t\t \n\t\tdax_dbg(\"hcall returned HV_EUNAVAILABLE\");\n\t\tctx->result.exec.status = DAX_SUBMIT_ERR_UNAVAIL;\n\t\tbreak;\n\tdefault:\n\t\tctx->result.exec.status = DAX_SUBMIT_ERR_INTERNAL;\n\t\tdax_dbg(\"unknown hcall return value (%ld)\", hv_rv);\n\t\tbreak;\n\t}\n\n\t \n\tnaccepted = accepted_len / sizeof(struct dax_ccb);\n\tdax_unlock_pages(ctx, idx + naccepted, nccbs - naccepted);\n\n\t \n\tfor (i = idx + naccepted; i < idx + nccbs; i++)\n\t\tctx->ca_buf[i].status = CCA_STAT_COMPLETED;\n\n\tctx->ccb_count += naccepted;\n\tctx->fail_count += nccbs - naccepted;\n\n\tdax_dbg(\"hcall rv=%ld, accepted_len=%ld, status_data=0x%llx, ret status=%d\",\n\t\thv_rv, accepted_len, ctx->result.exec.status_data,\n\t\tctx->result.exec.status);\n\n\tif (count == accepted_len)\n\t\tctx->client = NULL;  \n\treturn accepted_len;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}