{
  "module_name": "envctrl.c",
  "hash_id": "ab9b706c1fa890809b5dbd8fd3cde9ee5edcc0476d813569a604d441d7839924",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sbus/char/envctrl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/miscdevice.h>\n#include <linux/kmod.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <linux/uaccess.h>\n#include <asm/envctrl.h>\n#include <asm/io.h>\n\n#define DRIVER_NAME\t\"envctrl\"\n#define PFX\t\tDRIVER_NAME \": \"\n\n#define PCF8584_ADDRESS\t0x55\n\n#define CONTROL_PIN\t0x80\n#define CONTROL_ES0\t0x40\n#define CONTROL_ES1\t0x20\n#define CONTROL_ES2\t0x10\n#define CONTROL_ENI\t0x08\n#define CONTROL_STA\t0x04\n#define CONTROL_STO\t0x02\n#define CONTROL_ACK\t0x01\n\n#define STATUS_PIN\t0x80\n#define STATUS_STS\t0x20\n#define STATUS_BER\t0x10\n#define STATUS_LRB\t0x08\n#define STATUS_AD0\t0x08\n#define STATUS_AAB\t0x04\n#define STATUS_LAB\t0x02\n#define STATUS_BB\t0x01\n\n \n#define BUS_CLK_90\t0x00\n#define BUS_CLK_45\t0x01\n#define BUS_CLK_11\t0x02\n#define BUS_CLK_1_5\t0x03\n\n#define CLK_3\t\t0x00\n#define CLK_4_43\t0x10\n#define CLK_6\t\t0x14\n#define CLK_8\t\t0x18\n#define CLK_12\t\t0x1c\n\n#define OBD_SEND_START\t0xc5     \n#define OBD_SEND_STOP \t0xc3     \n\n \n#define PCF8584_MAX_CHANNELS            8\n#define PCF8584_GLOBALADDR_TYPE\t\t\t6   \n#define PCF8584_FANSTAT_TYPE            3   \n#define PCF8584_VOLTAGE_TYPE            2   \n#define PCF8584_TEMP_TYPE\t        \t1   \n\n \n#define ENVCTRL_NOMON\t\t\t\t0\n#define ENVCTRL_CPUTEMP_MON\t\t\t1     \n#define ENVCTRL_CPUVOLTAGE_MON\t  \t2     \n#define ENVCTRL_FANSTAT_MON  \t\t3     \n#define ENVCTRL_ETHERTEMP_MON\t\t4     \n\t\t\t\t\t      \n#define ENVCTRL_VOLTAGESTAT_MON\t  \t5     \n#define ENVCTRL_MTHRBDTEMP_MON\t\t6     \n#define ENVCTRL_SCSITEMP_MON\t\t7     \n#define ENVCTRL_GLOBALADDR_MON\t\t8     \n\n \n#define I2C_ADC\t\t\t\t0     \n#define I2C_GPIO\t\t\t1     \n\n \n#define ENVCTRL_TRANSLATE_NO\t\t0\n#define ENVCTRL_TRANSLATE_PARTIAL\t1\n#define ENVCTRL_TRANSLATE_COMBINED\t2\n#define ENVCTRL_TRANSLATE_FULL\t\t3      \n#define ENVCTRL_TRANSLATE_SCALE\t\t4      \n\n \n#define ENVCTRL_MAX_CPU\t\t\t4\n#define CHANNEL_DESC_SZ\t\t\t256\n\n \n#define ENVCTRL_GLOBALADDR_ADDR_MASK \t0x1F\n#define ENVCTRL_GLOBALADDR_PSTAT_MASK\t0x60\n\n \n#define ENVCTRL_CPCI_IGNORED_NODE\t\t0x70\n\n#define PCF8584_DATA\t0x00\n#define PCF8584_CSR\t0x01\n\n \nstruct pcf8584_channel {\n        unsigned char chnl_no;\n        unsigned char io_direction;\n        unsigned char type;\n        unsigned char last;\n};\n\n  \nstruct pcf8584_tblprop {\n        unsigned int type;\n        unsigned int scale;  \n        unsigned int offset;  \n        unsigned int size;\n};\n\n \nstruct i2c_child_t {\n\t \n\tunsigned char i2ctype;\n        unsigned long addr;    \n        struct pcf8584_channel chnl_array[PCF8584_MAX_CHANNELS];\n\n\t  \n\tunsigned int total_chnls;\t \n\tunsigned char fan_mask;\t\t \n\tunsigned char voltage_mask;\t \n        struct pcf8584_tblprop tblprop_array[PCF8584_MAX_CHANNELS];\n\n\t \n\tunsigned int total_tbls;\t \n        char *tables;\t\t\t \n\tchar chnls_desc[CHANNEL_DESC_SZ];  \n\tchar mon_type[PCF8584_MAX_CHANNELS];\n};\n\nstatic void __iomem *i2c;\nstatic struct i2c_child_t i2c_childlist[ENVCTRL_MAX_CPU*2];\nstatic unsigned char chnls_mask[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };\nstatic unsigned int warning_temperature = 0;\nstatic unsigned int shutdown_temperature = 0;\nstatic char read_cpu;\n\n \nstatic struct i2c_child_t *envctrl_get_i2c_child(unsigned char);\n\n \nstatic void envtrl_i2c_test_pin(void)\n{\n\tint limit = 1000000;\n\n\twhile (--limit > 0) {\n\t\tif (!(readb(i2c + PCF8584_CSR) & STATUS_PIN)) \n\t\t\tbreak;\n\t\tudelay(1);\n\t} \n\n\tif (limit <= 0)\n\t\tprintk(KERN_INFO PFX \"Pin status will not clear.\\n\");\n}\n\n \nstatic void envctrl_i2c_test_bb(void)\n{\n\tint limit = 1000000;\n\n\twhile (--limit > 0) {\n\t\t \n\t\tif (readb(i2c + PCF8584_CSR) & STATUS_BB)\n\t\t\tbreak;\n\t\tudelay(1);\n\t} \n\n\tif (limit <= 0)\n\t\tprintk(KERN_INFO PFX \"Busy bit will not clear.\\n\");\n}\n\n \nstatic int envctrl_i2c_read_addr(unsigned char addr)\n{\n\tenvctrl_i2c_test_bb();\n\n\t \n\twriteb(addr + 1, i2c + PCF8584_DATA);\n\n\tenvctrl_i2c_test_bb();\n\n\twriteb(OBD_SEND_START, i2c + PCF8584_CSR);\n\n\t \n\tenvtrl_i2c_test_pin();\n\n\t \n\tif (!(readb(i2c + PCF8584_CSR) & STATUS_LRB)) {\n\t\treturn readb(i2c + PCF8584_DATA);\n\t} else {\n\t\twriteb(OBD_SEND_STOP, i2c + PCF8584_CSR);\n\t\treturn 0;\n\t}\n}\n\n \nstatic void envctrl_i2c_write_addr(unsigned char addr)\n{\n\tenvctrl_i2c_test_bb();\n\twriteb(addr, i2c + PCF8584_DATA);\n\n\t \n\twriteb(OBD_SEND_START, i2c + PCF8584_CSR);\n}\n\n \nstatic unsigned char envctrl_i2c_read_data(void)\n{\n\tenvtrl_i2c_test_pin();\n\twriteb(CONTROL_ES0, i2c + PCF8584_CSR);   \n\treturn readb(i2c + PCF8584_DATA);\n}\n\n \nstatic void envctrl_i2c_write_data(unsigned char port)\n{\n\tenvtrl_i2c_test_pin();\n\twriteb(port, i2c + PCF8584_DATA);\n}\n\n \nstatic void envctrl_i2c_stop(void)\n{\n\tenvtrl_i2c_test_pin();\n\twriteb(OBD_SEND_STOP, i2c + PCF8584_CSR);\n}\n\n \nstatic unsigned char envctrl_i2c_read_8591(unsigned char addr, unsigned char port)\n{\n\t \n\tenvctrl_i2c_write_addr(addr);\n\n\t \n\tenvctrl_i2c_write_data(port);\n\tenvctrl_i2c_stop();\n\n\t \n\tenvctrl_i2c_read_addr(addr);\n\n\t \n\tenvctrl_i2c_read_data();\n\tenvctrl_i2c_stop();\n\n\treturn readb(i2c + PCF8584_DATA);\n}\n\n \nstatic unsigned char envctrl_i2c_read_8574(unsigned char addr)\n{\n\tunsigned char rd;\n\n\tenvctrl_i2c_read_addr(addr);\n\n\t \n\trd = envctrl_i2c_read_data();\n\tenvctrl_i2c_stop();\n\treturn rd;\n}\n\n \nstatic int envctrl_i2c_data_translate(unsigned char data, int translate_type,\n\t\t\t\t      int scale, char *tbl, char *bufdata)\n{\n\tint len = 0;\n\n\tswitch (translate_type) {\n\tcase ENVCTRL_TRANSLATE_NO:\n\t\t \n\t\tlen = 1;\n\t\tbufdata[0] = data;\n\t\tbreak;\n\n\tcase ENVCTRL_TRANSLATE_FULL:\n\t\t \n\t\tlen = 1;\n\t\tbufdata[0] = tbl[data];\n\t\tbreak;\n\n\tcase ENVCTRL_TRANSLATE_SCALE:\n\t\t \n\t\tsprintf(bufdata,\"%d \", (tbl[data] * 10) / (scale));\n\t\tlen = strlen(bufdata);\n\t\tbufdata[len - 1] = bufdata[len - 2];\n\t\tbufdata[len - 2] = '.';\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn len;\n}\n\n \nstatic int envctrl_read_cpu_info(int cpu, struct i2c_child_t *pchild,\n\t\t\t\t char mon_type, unsigned char *bufdata)\n{\n\tunsigned char data;\n\tint i, j = -1;\n\tchar *tbl;\n\n\t \n\tfor (i = 0; i < PCF8584_MAX_CHANNELS; i++) {\n\t\tif (pchild->mon_type[i] == mon_type) {\n\t\t\tif (++j == cpu) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j != cpu)\n\t\treturn 0;\n\n         \n\tdata = envctrl_i2c_read_8591((unsigned char)pchild->addr,\n\t\t\t\t     (unsigned char)pchild->chnl_array[i].chnl_no);\n\n\t \n\ttbl = pchild->tables + pchild->tblprop_array[i].offset;\n\n\treturn envctrl_i2c_data_translate(data, pchild->tblprop_array[i].type,\n\t\t\t\t\t  pchild->tblprop_array[i].scale,\n\t\t\t\t\t  tbl, bufdata);\n}\n\n \nstatic int envctrl_read_noncpu_info(struct i2c_child_t *pchild,\n\t\t\t\t    char mon_type, unsigned char *bufdata)\n{\n\tunsigned char data;\n\tint i;\n\tchar *tbl = NULL;\n\n\tfor (i = 0; i < PCF8584_MAX_CHANNELS; i++) {\n\t\tif (pchild->mon_type[i] == mon_type)\n\t\t\tbreak;\n\t}\n\n\tif (i >= PCF8584_MAX_CHANNELS)\n\t\treturn 0;\n\n         \n\tdata = envctrl_i2c_read_8591((unsigned char)pchild->addr,\n\t\t\t\t     (unsigned char)pchild->chnl_array[i].chnl_no);\n\n\t \n\ttbl = pchild->tables + pchild->tblprop_array[i].offset;\n\n\treturn envctrl_i2c_data_translate(data, pchild->tblprop_array[i].type,\n\t\t\t\t\t  pchild->tblprop_array[i].scale,\n\t\t\t\t\t  tbl, bufdata);\n}\n\n \nstatic int envctrl_i2c_fan_status(struct i2c_child_t *pchild,\n\t\t\t\t  unsigned char data,\n\t\t\t\t  char *bufdata)\n{\n\tunsigned char tmp, ret = 0;\n\tint i, j = 0;\n\n\ttmp = data & pchild->fan_mask;\n\n\tif (tmp == pchild->fan_mask) {\n\t\t \n\t\tret = ENVCTRL_ALL_FANS_GOOD;\n\t} else if (tmp == 0) {\n\t\t \n\t\tret = ENVCTRL_ALL_FANS_BAD;\n\t} else {\n\t\t \n\t\tfor (i = 0; i < PCF8584_MAX_CHANNELS;i++) {\n\t\t\tif (pchild->fan_mask & chnls_mask[i]) {\n\t\t\t\tif (!(chnls_mask[i] & tmp))\n\t\t\t\t\tret |= chnls_mask[j];\n\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbufdata[0] = ret;\n\treturn 1;\n}\n\n \nstatic int envctrl_i2c_globaladdr(struct i2c_child_t *pchild,\n\t\t\t\t  unsigned char data,\n\t\t\t\t  char *bufdata)\n{\n\t \n\tbufdata[0] = (data & ENVCTRL_GLOBALADDR_ADDR_MASK);\n\treturn 1;\n}\n\n \nstatic unsigned char envctrl_i2c_voltage_status(struct i2c_child_t *pchild,\n\t\t\t\t\t\tunsigned char data,\n\t\t\t\t\t\tchar *bufdata)\n{\n\tunsigned char tmp, ret = 0;\n\tint i, j = 0;\n\n\ttmp = data & pchild->voltage_mask;\n\n\t \n\tif (tmp == pchild->voltage_mask) {\n\t\t \n\t\tret = ENVCTRL_VOLTAGE_POWERSUPPLY_GOOD;\n\t} else if (tmp == 0) {\n\t\t \n\t\tret = ENVCTRL_VOLTAGE_POWERSUPPLY_BAD;\n\t} else {\n\t\t \n\t\tfor (i = 0; i < PCF8584_MAX_CHANNELS; i++) {\n\t\t\tif (pchild->voltage_mask & chnls_mask[i]) {\n\t\t\t\tj++;\n\n\t\t\t\t \n\t\t\t\tif (!(chnls_mask[i] & tmp))\n\t\t\t\t\tbreak; \n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (j == 1)\n\t\t\tret = ENVCTRL_VOLTAGE_BAD;\n\t\telse\n\t\t\tret = ENVCTRL_POWERSUPPLY_BAD;\n\t}\n\n\tbufdata[0] = ret;\n\treturn 1;\n}\n\n \nstatic ssize_t\nenvctrl_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct i2c_child_t *pchild;\n\tunsigned char data[10];\n\tint ret = 0;\n\n\t \n\n\tswitch ((int)(long)file->private_data) {\n\tcase ENVCTRL_RD_WARNING_TEMPERATURE:\n\t\tif (warning_temperature == 0)\n\t\t\treturn 0;\n\n\t\tdata[0] = (unsigned char)(warning_temperature);\n\t\tret = 1;\n\t\tif (copy_to_user(buf, data, ret))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase ENVCTRL_RD_SHUTDOWN_TEMPERATURE:\n\t\tif (shutdown_temperature == 0)\n\t\t\treturn 0;\n\n\t\tdata[0] = (unsigned char)(shutdown_temperature);\n\t\tret = 1;\n\t\tif (copy_to_user(buf, data, ret))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase ENVCTRL_RD_MTHRBD_TEMPERATURE:\n\t\tif (!(pchild = envctrl_get_i2c_child(ENVCTRL_MTHRBDTEMP_MON)))\n\t\t\treturn 0;\n\t\tret = envctrl_read_noncpu_info(pchild, ENVCTRL_MTHRBDTEMP_MON, data);\n\t\tif (copy_to_user(buf, data, ret))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase ENVCTRL_RD_CPU_TEMPERATURE:\n\t\tif (!(pchild = envctrl_get_i2c_child(ENVCTRL_CPUTEMP_MON)))\n\t\t\treturn 0;\n\t\tret = envctrl_read_cpu_info(read_cpu, pchild, ENVCTRL_CPUTEMP_MON, data);\n\n\t\t \n\t\tif (copy_to_user(buf, data, ret))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase ENVCTRL_RD_CPU_VOLTAGE:\n\t\tif (!(pchild = envctrl_get_i2c_child(ENVCTRL_CPUVOLTAGE_MON)))\n\t\t\treturn 0;\n\t\tret = envctrl_read_cpu_info(read_cpu, pchild, ENVCTRL_CPUVOLTAGE_MON, data);\n\n\t\t \n\t\tif (copy_to_user(buf, data, ret))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase ENVCTRL_RD_SCSI_TEMPERATURE:\n\t\tif (!(pchild = envctrl_get_i2c_child(ENVCTRL_SCSITEMP_MON)))\n\t\t\treturn 0;\n\t\tret = envctrl_read_noncpu_info(pchild, ENVCTRL_SCSITEMP_MON, data);\n\t\tif (copy_to_user(buf, data, ret))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase ENVCTRL_RD_ETHERNET_TEMPERATURE:\n\t\tif (!(pchild = envctrl_get_i2c_child(ENVCTRL_ETHERTEMP_MON)))\n\t\t\treturn 0;\n\t\tret = envctrl_read_noncpu_info(pchild, ENVCTRL_ETHERTEMP_MON, data);\n\t\tif (copy_to_user(buf, data, ret))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase ENVCTRL_RD_FAN_STATUS:\n\t\tif (!(pchild = envctrl_get_i2c_child(ENVCTRL_FANSTAT_MON)))\n\t\t\treturn 0;\n\t\tdata[0] = envctrl_i2c_read_8574(pchild->addr);\n\t\tret = envctrl_i2c_fan_status(pchild,data[0], data);\n\t\tif (copy_to_user(buf, data, ret))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\t\n\tcase ENVCTRL_RD_GLOBALADDRESS:\n\t\tif (!(pchild = envctrl_get_i2c_child(ENVCTRL_GLOBALADDR_MON)))\n\t\t\treturn 0;\n\t\tdata[0] = envctrl_i2c_read_8574(pchild->addr);\n\t\tret = envctrl_i2c_globaladdr(pchild, data[0], data);\n\t\tif (copy_to_user(buf, data, ret))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase ENVCTRL_RD_VOLTAGE_STATUS:\n\t\tif (!(pchild = envctrl_get_i2c_child(ENVCTRL_VOLTAGESTAT_MON)))\n\t\t\t \n\t\t\tif (!(pchild = envctrl_get_i2c_child(ENVCTRL_GLOBALADDR_MON)))\n\t\t\t\treturn 0;\n\t\tdata[0] = envctrl_i2c_read_8574(pchild->addr);\n\t\tret = envctrl_i2c_voltage_status(pchild, data[0], data);\n\t\tif (copy_to_user(buf, data, ret))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\n\t}\n\n\treturn ret;\n}\n\n \nstatic long\nenvctrl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tchar __user *infobuf;\n\n\tswitch (cmd) {\n\tcase ENVCTRL_RD_WARNING_TEMPERATURE:\n\tcase ENVCTRL_RD_SHUTDOWN_TEMPERATURE:\n\tcase ENVCTRL_RD_MTHRBD_TEMPERATURE:\n\tcase ENVCTRL_RD_FAN_STATUS:\n\tcase ENVCTRL_RD_VOLTAGE_STATUS:\n\tcase ENVCTRL_RD_ETHERNET_TEMPERATURE:\n\tcase ENVCTRL_RD_SCSI_TEMPERATURE:\n\tcase ENVCTRL_RD_GLOBALADDRESS:\n\t\tfile->private_data = (void *)(long)cmd;\n\t\tbreak;\n\n\tcase ENVCTRL_RD_CPU_TEMPERATURE:\n\tcase ENVCTRL_RD_CPU_VOLTAGE:\n\t\t \n\t\tinfobuf = (char __user *) arg;\n\t\tif (infobuf == NULL) {\n\t\t\tread_cpu = 0;\n\t\t}else {\n\t\t\tget_user(read_cpu, infobuf);\n\t\t}\n\n\t\t \n\t\tfile->private_data = (void *)(long)cmd;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nenvctrl_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = NULL;\n\treturn 0;\n}\n\n \nstatic int\nenvctrl_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\nstatic const struct file_operations envctrl_fops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.read =\t\t\tenvctrl_read,\n\t.unlocked_ioctl =\tenvctrl_ioctl,\n\t.compat_ioctl =\t\tcompat_ptr_ioctl,\n\t.open =\t\t\tenvctrl_open,\n\t.release =\t\tenvctrl_release,\n\t.llseek =\t\tnoop_llseek,\n};\t\n\nstatic struct miscdevice envctrl_dev = {\n\tENVCTRL_MINOR,\n\t\"envctrl\",\n\t&envctrl_fops\n};\n\n \nstatic void envctrl_set_mon(struct i2c_child_t *pchild,\n\t\t\t    const char *chnl_desc,\n\t\t\t    int chnl_no)\n{\n\t \n\tif (!(strcmp(chnl_desc,\"temp,cpu\")) ||\n\t    !(strcmp(chnl_desc,\"temp,cpu0\")) ||\n\t    !(strcmp(chnl_desc,\"temp,cpu1\")) ||\n\t    !(strcmp(chnl_desc,\"temp,cpu2\")) ||\n\t    !(strcmp(chnl_desc,\"temp,cpu3\")))\n\t\tpchild->mon_type[chnl_no] = ENVCTRL_CPUTEMP_MON;\n\n\tif (!(strcmp(chnl_desc,\"vddcore,cpu0\")) ||\n\t    !(strcmp(chnl_desc,\"vddcore,cpu1\")) ||\n\t    !(strcmp(chnl_desc,\"vddcore,cpu2\")) ||\n\t    !(strcmp(chnl_desc,\"vddcore,cpu3\")))\n\t\tpchild->mon_type[chnl_no] = ENVCTRL_CPUVOLTAGE_MON;\n\n\tif (!(strcmp(chnl_desc,\"temp,motherboard\")))\n\t\tpchild->mon_type[chnl_no] = ENVCTRL_MTHRBDTEMP_MON;\n\n\tif (!(strcmp(chnl_desc,\"temp,scsi\")))\n\t\tpchild->mon_type[chnl_no] = ENVCTRL_SCSITEMP_MON;\n\n\tif (!(strcmp(chnl_desc,\"temp,ethernet\")))\n\t\tpchild->mon_type[chnl_no] = ENVCTRL_ETHERTEMP_MON;\n}\n\n \nstatic void envctrl_init_adc(struct i2c_child_t *pchild, struct device_node *dp)\n{\n\tint i = 0, len;\n\tconst char *pos;\n\tconst unsigned int *pval;\n\n\t \n\tpos = of_get_property(dp, \"channels-description\", &len);\n\n\twhile (len > 0) {\n\t\tint l = strlen(pos) + 1;\n\t\tenvctrl_set_mon(pchild, pos, i++);\n\t\tlen -= l;\n\t\tpos += l;\n\t}\n\n\t \n\tpval = of_get_property(dp, \"warning-temp\", NULL);\n\tif (pval)\n\t\twarning_temperature = *pval;\n\n\tpval = of_get_property(dp, \"shutdown-temp\", NULL);\n\tif (pval)\n\t\tshutdown_temperature = *pval;\n}\n\n \nstatic void envctrl_init_fanstat(struct i2c_child_t *pchild)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < pchild->total_chnls; i++)\n\t\tpchild->fan_mask |= chnls_mask[(pchild->chnl_array[i]).chnl_no];\n\n\t \n\tpchild->mon_type[0] = ENVCTRL_FANSTAT_MON;\n}\n\n \nstatic void envctrl_init_globaladdr(struct i2c_child_t *pchild)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < pchild->total_chnls; i++) {\n\t\tif (PCF8584_VOLTAGE_TYPE == pchild->chnl_array[i].type) {\n\t\t\tpchild->voltage_mask |= chnls_mask[i];\n\t\t}\n\t}\n\n\t \n\tpchild->mon_type[0] = ENVCTRL_GLOBALADDR_MON;\n}\n\n \nstatic void envctrl_init_voltage_status(struct i2c_child_t *pchild)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < pchild->total_chnls; i++)\n\t\tpchild->voltage_mask |= chnls_mask[(pchild->chnl_array[i]).chnl_no];\n\n\t \n\tpchild->mon_type[0] = ENVCTRL_VOLTAGESTAT_MON;\n}\n\n \nstatic void envctrl_init_i2c_child(struct device_node *dp,\n\t\t\t\t   struct i2c_child_t *pchild)\n{\n\tint len, i, tbls_size = 0;\n\tconst void *pval;\n\n\t \n\tpval = of_get_property(dp, \"reg\", &len);\n\tmemcpy(&pchild->addr, pval, len);\n\n\t \n\tpval = of_get_property(dp, \"translation\", &len);\n\tif (pval && len > 0) {\n\t\tmemcpy(pchild->tblprop_array, pval, len);\n                pchild->total_tbls = len / sizeof(struct pcf8584_tblprop);\n\t\tfor (i = 0; i < pchild->total_tbls; i++) {\n\t\t\tif ((pchild->tblprop_array[i].size + pchild->tblprop_array[i].offset) > tbls_size) {\n\t\t\t\ttbls_size = pchild->tblprop_array[i].size + pchild->tblprop_array[i].offset;\n\t\t\t}\n\t\t}\n\n                pchild->tables = kmalloc(tbls_size, GFP_KERNEL);\n\t\tif (pchild->tables == NULL){\n\t\t\tprintk(KERN_ERR PFX \"Failed to allocate table.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tpval = of_get_property(dp, \"tables\", &len);\n                if (!pval || len <= 0) {\n\t\t\tprintk(KERN_ERR PFX \"Failed to get table.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(pchild->tables, pval, len);\n\t}\n\n\t \n\tif (ENVCTRL_CPCI_IGNORED_NODE == pchild->addr) {\n\t\tstruct device_node *root_node;\n\t\tint len;\n\n\t\troot_node = of_find_node_by_path(\"/\");\n\t\tif (of_node_name_eq(root_node, \"SUNW,UltraSPARC-IIi-cEngine\")) {\n\t\t\tfor (len = 0; len < PCF8584_MAX_CHANNELS; ++len) {\n\t\t\t\tpchild->mon_type[len] = ENVCTRL_NOMON;\n\t\t\t}\n\t\t\tof_node_put(root_node);\n\t\t\treturn;\n\t\t}\n\t\tof_node_put(root_node);\n\t}\n\n\t \n\tpval = of_get_property(dp, \"channels-in-use\", &len);\n\tmemcpy(pchild->chnl_array, pval, len);\n\tpchild->total_chnls = len / sizeof(struct pcf8584_channel);\n\n\tfor (i = 0; i < pchild->total_chnls; i++) {\n\t\tswitch (pchild->chnl_array[i].type) {\n\t\tcase PCF8584_TEMP_TYPE:\n\t\t\tenvctrl_init_adc(pchild, dp);\n\t\t\tbreak;\n\n\t\tcase PCF8584_GLOBALADDR_TYPE:\n\t\t\tenvctrl_init_globaladdr(pchild);\n\t\t\ti = pchild->total_chnls;\n\t\t\tbreak;\n\n\t\tcase PCF8584_FANSTAT_TYPE:\n\t\t\tenvctrl_init_fanstat(pchild);\n\t\t\ti = pchild->total_chnls;\n\t\t\tbreak;\n\n\t\tcase PCF8584_VOLTAGE_TYPE:\n\t\t\tif (pchild->i2ctype == I2C_ADC) {\n\t\t\t\tenvctrl_init_adc(pchild,dp);\n\t\t\t} else {\n\t\t\t\tenvctrl_init_voltage_status(pchild);\n\t\t\t}\n\t\t\ti = pchild->total_chnls;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic struct i2c_child_t *envctrl_get_i2c_child(unsigned char mon_type)\n{\n\tint i, j;\n\n\tfor (i = 0; i < ENVCTRL_MAX_CPU*2; i++) {\n\t\tfor (j = 0; j < PCF8584_MAX_CHANNELS; j++) {\n\t\t\tif (i2c_childlist[i].mon_type[j] == mon_type) {\n\t\t\t\treturn (struct i2c_child_t *)(&(i2c_childlist[i]));\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void envctrl_do_shutdown(void)\n{\n\tstatic int inprog = 0;\n\n\tif (inprog != 0)\n\t\treturn;\n\n\tinprog = 1;\n\tprintk(KERN_CRIT \"kenvctrld: WARNING: Shutting down the system now.\\n\");\n\torderly_poweroff(true);\n}\n\nstatic struct task_struct *kenvctrld_task;\n\nstatic int kenvctrld(void *__unused)\n{\n\tint poll_interval;\n\tint whichcpu;\n\tchar tempbuf[10];\n\tstruct i2c_child_t *cputemp;\n\n\tif (NULL == (cputemp = envctrl_get_i2c_child(ENVCTRL_CPUTEMP_MON))) {\n\t\tprintk(KERN_ERR  PFX\n\t\t       \"kenvctrld unable to monitor CPU temp-- exiting\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpoll_interval = 5000;  \n\n\tprintk(KERN_INFO PFX \"%s starting...\\n\", current->comm);\n\tfor (;;) {\n\t\tmsleep_interruptible(poll_interval);\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\t\n\t\tfor (whichcpu = 0; whichcpu < ENVCTRL_MAX_CPU; ++whichcpu) {\n\t\t\tif (0 < envctrl_read_cpu_info(whichcpu, cputemp,\n\t\t\t\t\t\t      ENVCTRL_CPUTEMP_MON,\n\t\t\t\t\t\t      tempbuf)) {\n\t\t\t\tif (tempbuf[0] >= shutdown_temperature) {\n\t\t\t\t\tprintk(KERN_CRIT \n\t\t\t\t\t\t\"%s: WARNING: CPU%i temperature %i C meets or exceeds \"\\\n\t\t\t\t\t\t\"shutdown threshold %i C\\n\", \n\t\t\t\t\t\tcurrent->comm, whichcpu, \n\t\t\t\t\t\ttempbuf[0], shutdown_temperature);\n\t\t\t\t\tenvctrl_do_shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintk(KERN_INFO PFX \"%s exiting...\\n\", current->comm);\n\treturn 0;\n}\n\nstatic int envctrl_probe(struct platform_device *op)\n{\n\tstruct device_node *dp;\n\tint index, err;\n\n\tif (i2c)\n\t\treturn -EINVAL;\n\n\ti2c = of_ioremap(&op->resource[0], 0, 0x2, DRIVER_NAME);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\tindex = 0;\n\tdp = op->dev.of_node->child;\n\twhile (dp) {\n\t\tif (of_node_name_eq(dp, \"gpio\")) {\n\t\t\ti2c_childlist[index].i2ctype = I2C_GPIO;\n\t\t\tenvctrl_init_i2c_child(dp, &(i2c_childlist[index++]));\n\t\t} else if (of_node_name_eq(dp, \"adc\")) {\n\t\t\ti2c_childlist[index].i2ctype = I2C_ADC;\n\t\t\tenvctrl_init_i2c_child(dp, &(i2c_childlist[index++]));\n\t\t}\n\n\t\tdp = dp->sibling;\n\t}\n\n\t \n\twriteb(CONTROL_PIN, i2c + PCF8584_CSR);\n\twriteb(PCF8584_ADDRESS, i2c + PCF8584_DATA);\n\n\t  \n\twriteb(CONTROL_PIN | CONTROL_ES1, i2c + PCF8584_CSR);\n\twriteb(CLK_4_43 | BUS_CLK_90, i2c + PCF8584_DATA);\n\n\t \n\twriteb(CONTROL_PIN | CONTROL_ES0 | CONTROL_ACK, i2c + PCF8584_CSR);\n\tudelay(200);\n\n\t \n\terr = misc_register(&envctrl_dev);\n\tif (err) {\n\t\tprintk(KERN_ERR PFX \"Unable to get misc minor %d\\n\",\n\t\t       envctrl_dev.minor);\n\t\tgoto out_iounmap;\n\t}\n\n\t \n\tprintk(KERN_INFO PFX \"Initialized \");\n\tfor (--index; index >= 0; --index) {\n\t\tprintk(\"[%s 0x%lx]%s\", \n\t\t\t(I2C_ADC == i2c_childlist[index].i2ctype) ? \"adc\" : \n\t\t\t((I2C_GPIO == i2c_childlist[index].i2ctype) ? \"gpio\" : \"unknown\"), \n\t\t\ti2c_childlist[index].addr, (0 == index) ? \"\\n\" : \" \");\n\t}\n\n\tkenvctrld_task = kthread_run(kenvctrld, NULL, \"kenvctrld\");\n\tif (IS_ERR(kenvctrld_task)) {\n\t\terr = PTR_ERR(kenvctrld_task);\n\t\tgoto out_deregister;\n\t}\n\n\treturn 0;\n\nout_deregister:\n\tmisc_deregister(&envctrl_dev);\nout_iounmap:\n\tof_iounmap(&op->resource[0], i2c, 0x2);\n\tfor (index = 0; index < ENVCTRL_MAX_CPU * 2; index++)\n\t\tkfree(i2c_childlist[index].tables);\n\n\treturn err;\n}\n\nstatic int envctrl_remove(struct platform_device *op)\n{\n\tint index;\n\n\tkthread_stop(kenvctrld_task);\n\n\tof_iounmap(&op->resource[0], i2c, 0x2);\n\tmisc_deregister(&envctrl_dev);\n\n\tfor (index = 0; index < ENVCTRL_MAX_CPU * 2; index++)\n\t\tkfree(i2c_childlist[index].tables);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id envctrl_match[] = {\n\t{\n\t\t.name = \"i2c\",\n\t\t.compatible = \"i2cpcf,8584\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, envctrl_match);\n\nstatic struct platform_driver envctrl_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = envctrl_match,\n\t},\n\t.probe\t\t= envctrl_probe,\n\t.remove\t\t= envctrl_remove,\n};\n\nmodule_platform_driver(envctrl_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}