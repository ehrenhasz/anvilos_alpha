{
  "module_name": "flash.c",
  "hash_id": "ffe6ce12b510183f56fc716e2b988069a3643ad079c9fda9c4dbe660facfb209",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sbus/char/flash.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/miscdevice.h>\n#include <linux/fcntl.h>\n#include <linux/poll.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <asm/upa.h>\n\nstatic DEFINE_MUTEX(flash_mutex);\nstatic DEFINE_SPINLOCK(flash_lock);\nstatic struct {\n\tunsigned long read_base;\t \n\tunsigned long write_base;\t \n\tunsigned long read_size;\t \n\tunsigned long write_size;\t \n\tunsigned long busy;\t\t \n} flash;\n\nstatic int\nflash_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tunsigned long addr;\n\tunsigned long size;\n\n\tspin_lock(&flash_lock);\n\tif (flash.read_base == flash.write_base) {\n\t\taddr = flash.read_base;\n\t\tsize = flash.read_size;\n\t} else {\n\t\tif ((vma->vm_flags & VM_READ) &&\n\t\t    (vma->vm_flags & VM_WRITE)) {\n\t\t\tspin_unlock(&flash_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (vma->vm_flags & VM_READ) {\n\t\t\taddr = flash.read_base;\n\t\t\tsize = flash.read_size;\n\t\t} else if (vma->vm_flags & VM_WRITE) {\n\t\t\taddr = flash.write_base;\n\t\t\tsize = flash.write_size;\n\t\t} else {\n\t\t\tspin_unlock(&flash_lock);\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\tspin_unlock(&flash_lock);\n\n\tif ((vma->vm_pgoff << PAGE_SHIFT) > size)\n\t\treturn -ENXIO;\n\taddr = vma->vm_pgoff + (addr >> PAGE_SHIFT);\n\n\tif (vma->vm_end - (vma->vm_start + (vma->vm_pgoff << PAGE_SHIFT)) > size)\n\t\tsize = vma->vm_end - (vma->vm_start + (vma->vm_pgoff << PAGE_SHIFT));\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\tif (io_remap_pfn_range(vma, vma->vm_start, addr, size, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\t\t\n\treturn 0;\n}\n\nstatic long long\nflash_llseek(struct file *file, long long offset, int origin)\n{\n\tmutex_lock(&flash_mutex);\n\tswitch (origin) {\n\t\tcase 0:\n\t\t\tfile->f_pos = offset;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfile->f_pos += offset;\n\t\t\tif (file->f_pos > flash.read_size)\n\t\t\t\tfile->f_pos = flash.read_size;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfile->f_pos = flash.read_size;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmutex_unlock(&flash_mutex);\n\t\t\treturn -EINVAL;\n\t}\n\tmutex_unlock(&flash_mutex);\n\treturn file->f_pos;\n}\n\nstatic ssize_t\nflash_read(struct file * file, char __user * buf,\n\t   size_t count, loff_t *ppos)\n{\n\tloff_t p = *ppos;\n\tint i;\n\n\tif (count > flash.read_size - p)\n\t\tcount = flash.read_size - p;\n\n\tfor (i = 0; i < count; i++) {\n\t\tu8 data = upa_readb(flash.read_base + p + i);\n\t\tif (put_user(data, buf))\n\t\t\treturn -EFAULT;\n\t\tbuf++;\n\t}\n\n\t*ppos += count;\n\treturn count;\n}\n\nstatic int\nflash_open(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&flash_mutex);\n\tif (test_and_set_bit(0, (void *)&flash.busy) != 0) {\n\t\tmutex_unlock(&flash_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tmutex_unlock(&flash_mutex);\n\treturn 0;\n}\n\nstatic int\nflash_release(struct inode *inode, struct file *file)\n{\n\tspin_lock(&flash_lock);\n\tflash.busy = 0;\n\tspin_unlock(&flash_lock);\n\n\treturn 0;\n}\n\nstatic const struct file_operations flash_fops = {\n\t \n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tflash_llseek,\n\t.read =\t\tflash_read,\n\t.mmap =\t\tflash_mmap,\n\t.open =\t\tflash_open,\n\t.release =\tflash_release,\n};\n\nstatic struct miscdevice flash_dev = { SBUS_FLASH_MINOR, \"flash\", &flash_fops };\n\nstatic int flash_probe(struct platform_device *op)\n{\n\tstruct device_node *dp = op->dev.of_node;\n\tstruct device_node *parent;\n\n\tparent = dp->parent;\n\n\tif (!of_node_name_eq(parent, \"sbus\") &&\n\t    !of_node_name_eq(parent, \"sbi\") &&\n\t    !of_node_name_eq(parent, \"ebus\"))\n\t\treturn -ENODEV;\n\n\tflash.read_base = op->resource[0].start;\n\tflash.read_size = resource_size(&op->resource[0]);\n\tif (op->resource[1].flags) {\n\t\tflash.write_base = op->resource[1].start;\n\t\tflash.write_size = resource_size(&op->resource[1]);\n\t} else {\n\t\tflash.write_base = op->resource[0].start;\n\t\tflash.write_size = resource_size(&op->resource[0]);\n\t}\n\tflash.busy = 0;\n\n\tprintk(KERN_INFO \"%pOF: OBP Flash, RD %lx[%lx] WR %lx[%lx]\\n\",\n\t       op->dev.of_node,\n\t       flash.read_base, flash.read_size,\n\t       flash.write_base, flash.write_size);\n\n\treturn misc_register(&flash_dev);\n}\n\nstatic int flash_remove(struct platform_device *op)\n{\n\tmisc_deregister(&flash_dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id flash_match[] = {\n\t{\n\t\t.name = \"flashprom\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, flash_match);\n\nstatic struct platform_driver flash_driver = {\n\t.driver = {\n\t\t.name = \"flash\",\n\t\t.of_match_table = flash_match,\n\t},\n\t.probe\t\t= flash_probe,\n\t.remove\t\t= flash_remove,\n};\n\nmodule_platform_driver(flash_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}