{
  "module_name": "irq-mips-gic.c",
  "hash_id": "dd59635c65118e5da50328ab99e9dd0ed4f19b154849bab9ed3c77363ba1ee45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mips-gic.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"irq-mips-gic: \" fmt\n\n#include <linux/bitfield.h>\n#include <linux/bitmap.h>\n#include <linux/clocksource.h>\n#include <linux/cpuhotplug.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of_address.h>\n#include <linux/percpu.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n\n#include <asm/mips-cps.h>\n#include <asm/setup.h>\n#include <asm/traps.h>\n\n#include <dt-bindings/interrupt-controller/mips-gic.h>\n\n#define GIC_MAX_INTRS\t\t256\n#define GIC_MAX_LONGS\t\tBITS_TO_LONGS(GIC_MAX_INTRS)\n\n \n#define GIC_CPU_PIN_OFFSET\t2\n\n \n#define GIC_PIN_TO_VEC_OFFSET\t1\n\n \n#define GIC_LOCAL_HWIRQ_BASE\t0\n#define GIC_LOCAL_TO_HWIRQ(x)\t(GIC_LOCAL_HWIRQ_BASE + (x))\n#define GIC_HWIRQ_TO_LOCAL(x)\t((x) - GIC_LOCAL_HWIRQ_BASE)\n#define GIC_SHARED_HWIRQ_BASE\tGIC_NUM_LOCAL_INTRS\n#define GIC_SHARED_TO_HWIRQ(x)\t(GIC_SHARED_HWIRQ_BASE + (x))\n#define GIC_HWIRQ_TO_SHARED(x)\t((x) - GIC_SHARED_HWIRQ_BASE)\n\nvoid __iomem *mips_gic_base;\n\nstatic DEFINE_PER_CPU_READ_MOSTLY(unsigned long[GIC_MAX_LONGS], pcpu_masks);\n\nstatic DEFINE_RAW_SPINLOCK(gic_lock);\nstatic struct irq_domain *gic_irq_domain;\nstatic int gic_shared_intrs;\nstatic unsigned int gic_cpu_pin;\nstatic struct irq_chip gic_level_irq_controller, gic_edge_irq_controller;\n\n#ifdef CONFIG_GENERIC_IRQ_IPI\nstatic DECLARE_BITMAP(ipi_resrv, GIC_MAX_INTRS);\nstatic DECLARE_BITMAP(ipi_available, GIC_MAX_INTRS);\n#endif  \n\nstatic struct gic_all_vpes_chip_data {\n\tu32\tmap;\n\tbool\tmask;\n} gic_all_vpes_chip_data[GIC_NUM_LOCAL_INTRS];\n\nstatic void gic_clear_pcpu_masks(unsigned int intr)\n{\n\tunsigned int i;\n\n\t \n\tfor_each_possible_cpu(i)\n\t\tclear_bit(intr, per_cpu_ptr(pcpu_masks, i));\n}\n\nstatic bool gic_local_irq_is_routable(int intr)\n{\n\tu32 vpe_ctl;\n\n\t \n\tif (cpu_has_veic)\n\t\treturn true;\n\n\tvpe_ctl = read_gic_vl_ctl();\n\tswitch (intr) {\n\tcase GIC_LOCAL_INT_TIMER:\n\t\treturn vpe_ctl & GIC_VX_CTL_TIMER_ROUTABLE;\n\tcase GIC_LOCAL_INT_PERFCTR:\n\t\treturn vpe_ctl & GIC_VX_CTL_PERFCNT_ROUTABLE;\n\tcase GIC_LOCAL_INT_FDC:\n\t\treturn vpe_ctl & GIC_VX_CTL_FDC_ROUTABLE;\n\tcase GIC_LOCAL_INT_SWINT0:\n\tcase GIC_LOCAL_INT_SWINT1:\n\t\treturn vpe_ctl & GIC_VX_CTL_SWINT_ROUTABLE;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic void gic_bind_eic_interrupt(int irq, int set)\n{\n\t \n\tirq -= GIC_PIN_TO_VEC_OFFSET;\n\n\t \n\twrite_gic_vl_eic_shadow_set(irq, set);\n}\n\nstatic void gic_send_ipi(struct irq_data *d, unsigned int cpu)\n{\n\tirq_hw_number_t hwirq = GIC_HWIRQ_TO_SHARED(irqd_to_hwirq(d));\n\n\twrite_gic_wedge(GIC_WEDGE_RW | hwirq);\n}\n\nint gic_get_c0_compare_int(void)\n{\n\tif (!gic_local_irq_is_routable(GIC_LOCAL_INT_TIMER))\n\t\treturn MIPS_CPU_IRQ_BASE + cp0_compare_irq;\n\treturn irq_create_mapping(gic_irq_domain,\n\t\t\t\t  GIC_LOCAL_TO_HWIRQ(GIC_LOCAL_INT_TIMER));\n}\n\nint gic_get_c0_perfcount_int(void)\n{\n\tif (!gic_local_irq_is_routable(GIC_LOCAL_INT_PERFCTR)) {\n\t\t \n\t\tif (cp0_perfcount_irq < 0)\n\t\t\treturn -1;\n\t\treturn MIPS_CPU_IRQ_BASE + cp0_perfcount_irq;\n\t}\n\treturn irq_create_mapping(gic_irq_domain,\n\t\t\t\t  GIC_LOCAL_TO_HWIRQ(GIC_LOCAL_INT_PERFCTR));\n}\n\nint gic_get_c0_fdc_int(void)\n{\n\tif (!gic_local_irq_is_routable(GIC_LOCAL_INT_FDC)) {\n\t\t \n\t\tif (cp0_fdc_irq < 0)\n\t\t\treturn -1;\n\t\treturn MIPS_CPU_IRQ_BASE + cp0_fdc_irq;\n\t}\n\n\treturn irq_create_mapping(gic_irq_domain,\n\t\t\t\t  GIC_LOCAL_TO_HWIRQ(GIC_LOCAL_INT_FDC));\n}\n\nstatic void gic_handle_shared_int(bool chained)\n{\n\tunsigned int intr;\n\tunsigned long *pcpu_mask;\n\tDECLARE_BITMAP(pending, GIC_MAX_INTRS);\n\n\t \n\tpcpu_mask = this_cpu_ptr(pcpu_masks);\n\n\tif (mips_cm_is64)\n\t\t__ioread64_copy(pending, addr_gic_pend(),\n\t\t\t\tDIV_ROUND_UP(gic_shared_intrs, 64));\n\telse\n\t\t__ioread32_copy(pending, addr_gic_pend(),\n\t\t\t\tDIV_ROUND_UP(gic_shared_intrs, 32));\n\n\tbitmap_and(pending, pending, pcpu_mask, gic_shared_intrs);\n\n\tfor_each_set_bit(intr, pending, gic_shared_intrs) {\n\t\tif (chained)\n\t\t\tgeneric_handle_domain_irq(gic_irq_domain,\n\t\t\t\t\t\t  GIC_SHARED_TO_HWIRQ(intr));\n\t\telse\n\t\t\tdo_domain_IRQ(gic_irq_domain,\n\t\t\t\t      GIC_SHARED_TO_HWIRQ(intr));\n\t}\n}\n\nstatic void gic_mask_irq(struct irq_data *d)\n{\n\tunsigned int intr = GIC_HWIRQ_TO_SHARED(d->hwirq);\n\n\twrite_gic_rmask(intr);\n\tgic_clear_pcpu_masks(intr);\n}\n\nstatic void gic_unmask_irq(struct irq_data *d)\n{\n\tunsigned int intr = GIC_HWIRQ_TO_SHARED(d->hwirq);\n\tunsigned int cpu;\n\n\twrite_gic_smask(intr);\n\n\tgic_clear_pcpu_masks(intr);\n\tcpu = cpumask_first(irq_data_get_effective_affinity_mask(d));\n\tset_bit(intr, per_cpu_ptr(pcpu_masks, cpu));\n}\n\nstatic void gic_ack_irq(struct irq_data *d)\n{\n\tunsigned int irq = GIC_HWIRQ_TO_SHARED(d->hwirq);\n\n\twrite_gic_wedge(irq);\n}\n\nstatic int gic_set_type(struct irq_data *d, unsigned int type)\n{\n\tunsigned int irq, pol, trig, dual;\n\tunsigned long flags;\n\n\tirq = GIC_HWIRQ_TO_SHARED(d->hwirq);\n\n\traw_spin_lock_irqsave(&gic_lock, flags);\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tpol = GIC_POL_FALLING_EDGE;\n\t\ttrig = GIC_TRIG_EDGE;\n\t\tdual = GIC_DUAL_SINGLE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tpol = GIC_POL_RISING_EDGE;\n\t\ttrig = GIC_TRIG_EDGE;\n\t\tdual = GIC_DUAL_SINGLE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tpol = 0;  \n\t\ttrig = GIC_TRIG_EDGE;\n\t\tdual = GIC_DUAL_DUAL;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tpol = GIC_POL_ACTIVE_LOW;\n\t\ttrig = GIC_TRIG_LEVEL;\n\t\tdual = GIC_DUAL_SINGLE;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\tdefault:\n\t\tpol = GIC_POL_ACTIVE_HIGH;\n\t\ttrig = GIC_TRIG_LEVEL;\n\t\tdual = GIC_DUAL_SINGLE;\n\t\tbreak;\n\t}\n\n\tchange_gic_pol(irq, pol);\n\tchange_gic_trig(irq, trig);\n\tchange_gic_dual(irq, dual);\n\n\tif (trig == GIC_TRIG_EDGE)\n\t\tirq_set_chip_handler_name_locked(d, &gic_edge_irq_controller,\n\t\t\t\t\t\t handle_edge_irq, NULL);\n\telse\n\t\tirq_set_chip_handler_name_locked(d, &gic_level_irq_controller,\n\t\t\t\t\t\t handle_level_irq, NULL);\n\traw_spin_unlock_irqrestore(&gic_lock, flags);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SMP\nstatic int gic_set_affinity(struct irq_data *d, const struct cpumask *cpumask,\n\t\t\t    bool force)\n{\n\tunsigned int irq = GIC_HWIRQ_TO_SHARED(d->hwirq);\n\tunsigned long flags;\n\tunsigned int cpu;\n\n\tcpu = cpumask_first_and(cpumask, cpu_online_mask);\n\tif (cpu >= NR_CPUS)\n\t\treturn -EINVAL;\n\n\t \n\traw_spin_lock_irqsave(&gic_lock, flags);\n\n\t \n\twrite_gic_map_vp(irq, BIT(mips_cm_vp_id(cpu)));\n\n\t \n\tgic_clear_pcpu_masks(irq);\n\tif (read_gic_mask(irq))\n\t\tset_bit(irq, per_cpu_ptr(pcpu_masks, cpu));\n\n\tirq_data_update_effective_affinity(d, cpumask_of(cpu));\n\traw_spin_unlock_irqrestore(&gic_lock, flags);\n\n\treturn IRQ_SET_MASK_OK;\n}\n#endif\n\nstatic struct irq_chip gic_level_irq_controller = {\n\t.name\t\t\t=\t\"MIPS GIC\",\n\t.irq_mask\t\t=\tgic_mask_irq,\n\t.irq_unmask\t\t=\tgic_unmask_irq,\n\t.irq_set_type\t\t=\tgic_set_type,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity\t=\tgic_set_affinity,\n#endif\n};\n\nstatic struct irq_chip gic_edge_irq_controller = {\n\t.name\t\t\t=\t\"MIPS GIC\",\n\t.irq_ack\t\t=\tgic_ack_irq,\n\t.irq_mask\t\t=\tgic_mask_irq,\n\t.irq_unmask\t\t=\tgic_unmask_irq,\n\t.irq_set_type\t\t=\tgic_set_type,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity\t=\tgic_set_affinity,\n#endif\n\t.ipi_send_single\t=\tgic_send_ipi,\n};\n\nstatic void gic_handle_local_int(bool chained)\n{\n\tunsigned long pending, masked;\n\tunsigned int intr;\n\n\tpending = read_gic_vl_pend();\n\tmasked = read_gic_vl_mask();\n\n\tbitmap_and(&pending, &pending, &masked, GIC_NUM_LOCAL_INTRS);\n\n\tfor_each_set_bit(intr, &pending, GIC_NUM_LOCAL_INTRS) {\n\t\tif (chained)\n\t\t\tgeneric_handle_domain_irq(gic_irq_domain,\n\t\t\t\t\t\t  GIC_LOCAL_TO_HWIRQ(intr));\n\t\telse\n\t\t\tdo_domain_IRQ(gic_irq_domain,\n\t\t\t\t      GIC_LOCAL_TO_HWIRQ(intr));\n\t}\n}\n\nstatic void gic_mask_local_irq(struct irq_data *d)\n{\n\tint intr = GIC_HWIRQ_TO_LOCAL(d->hwirq);\n\n\twrite_gic_vl_rmask(BIT(intr));\n}\n\nstatic void gic_unmask_local_irq(struct irq_data *d)\n{\n\tint intr = GIC_HWIRQ_TO_LOCAL(d->hwirq);\n\n\twrite_gic_vl_smask(BIT(intr));\n}\n\nstatic struct irq_chip gic_local_irq_controller = {\n\t.name\t\t\t=\t\"MIPS GIC Local\",\n\t.irq_mask\t\t=\tgic_mask_local_irq,\n\t.irq_unmask\t\t=\tgic_unmask_local_irq,\n};\n\nstatic void gic_mask_local_irq_all_vpes(struct irq_data *d)\n{\n\tstruct gic_all_vpes_chip_data *cd;\n\tunsigned long flags;\n\tint intr, cpu;\n\n\tintr = GIC_HWIRQ_TO_LOCAL(d->hwirq);\n\tcd = irq_data_get_irq_chip_data(d);\n\tcd->mask = false;\n\n\traw_spin_lock_irqsave(&gic_lock, flags);\n\tfor_each_online_cpu(cpu) {\n\t\twrite_gic_vl_other(mips_cm_vp_id(cpu));\n\t\twrite_gic_vo_rmask(BIT(intr));\n\t}\n\traw_spin_unlock_irqrestore(&gic_lock, flags);\n}\n\nstatic void gic_unmask_local_irq_all_vpes(struct irq_data *d)\n{\n\tstruct gic_all_vpes_chip_data *cd;\n\tunsigned long flags;\n\tint intr, cpu;\n\n\tintr = GIC_HWIRQ_TO_LOCAL(d->hwirq);\n\tcd = irq_data_get_irq_chip_data(d);\n\tcd->mask = true;\n\n\traw_spin_lock_irqsave(&gic_lock, flags);\n\tfor_each_online_cpu(cpu) {\n\t\twrite_gic_vl_other(mips_cm_vp_id(cpu));\n\t\twrite_gic_vo_smask(BIT(intr));\n\t}\n\traw_spin_unlock_irqrestore(&gic_lock, flags);\n}\n\nstatic void gic_all_vpes_irq_cpu_online(void)\n{\n\tstatic const unsigned int local_intrs[] = {\n\t\tGIC_LOCAL_INT_TIMER,\n\t\tGIC_LOCAL_INT_PERFCTR,\n\t\tGIC_LOCAL_INT_FDC,\n\t};\n\tunsigned long flags;\n\tint i;\n\n\traw_spin_lock_irqsave(&gic_lock, flags);\n\n\tfor (i = 0; i < ARRAY_SIZE(local_intrs); i++) {\n\t\tunsigned int intr = local_intrs[i];\n\t\tstruct gic_all_vpes_chip_data *cd;\n\n\t\tif (!gic_local_irq_is_routable(intr))\n\t\t\tcontinue;\n\t\tcd = &gic_all_vpes_chip_data[intr];\n\t\twrite_gic_vl_map(mips_gic_vx_map_reg(intr), cd->map);\n\t\tif (cd->mask)\n\t\t\twrite_gic_vl_smask(BIT(intr));\n\t}\n\n\traw_spin_unlock_irqrestore(&gic_lock, flags);\n}\n\nstatic struct irq_chip gic_all_vpes_local_irq_controller = {\n\t.name\t\t\t= \"MIPS GIC Local\",\n\t.irq_mask\t\t= gic_mask_local_irq_all_vpes,\n\t.irq_unmask\t\t= gic_unmask_local_irq_all_vpes,\n};\n\nstatic void __gic_irq_dispatch(void)\n{\n\tgic_handle_local_int(false);\n\tgic_handle_shared_int(false);\n}\n\nstatic void gic_irq_dispatch(struct irq_desc *desc)\n{\n\tgic_handle_local_int(true);\n\tgic_handle_shared_int(true);\n}\n\nstatic int gic_shared_irq_domain_map(struct irq_domain *d, unsigned int virq,\n\t\t\t\t     irq_hw_number_t hw, unsigned int cpu)\n{\n\tint intr = GIC_HWIRQ_TO_SHARED(hw);\n\tstruct irq_data *data;\n\tunsigned long flags;\n\n\tdata = irq_get_irq_data(virq);\n\n\traw_spin_lock_irqsave(&gic_lock, flags);\n\twrite_gic_map_pin(intr, GIC_MAP_PIN_MAP_TO_PIN | gic_cpu_pin);\n\twrite_gic_map_vp(intr, BIT(mips_cm_vp_id(cpu)));\n\tirq_data_update_effective_affinity(data, cpumask_of(cpu));\n\traw_spin_unlock_irqrestore(&gic_lock, flags);\n\n\treturn 0;\n}\n\nstatic int gic_irq_domain_xlate(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\t\tirq_hw_number_t *out_hwirq,\n\t\t\t\tunsigned int *out_type)\n{\n\tif (intsize != 3)\n\t\treturn -EINVAL;\n\n\tif (intspec[0] == GIC_SHARED)\n\t\t*out_hwirq = GIC_SHARED_TO_HWIRQ(intspec[1]);\n\telse if (intspec[0] == GIC_LOCAL)\n\t\t*out_hwirq = GIC_LOCAL_TO_HWIRQ(intspec[1]);\n\telse\n\t\treturn -EINVAL;\n\t*out_type = intspec[2] & IRQ_TYPE_SENSE_MASK;\n\n\treturn 0;\n}\n\nstatic int gic_irq_domain_map(struct irq_domain *d, unsigned int virq,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct gic_all_vpes_chip_data *cd;\n\tunsigned long flags;\n\tunsigned int intr;\n\tint err, cpu;\n\tu32 map;\n\n\tif (hwirq >= GIC_SHARED_HWIRQ_BASE) {\n#ifdef CONFIG_GENERIC_IRQ_IPI\n\t\t \n\t\tif (test_bit(GIC_HWIRQ_TO_SHARED(hwirq), ipi_resrv))\n\t\t\treturn -EBUSY;\n#endif  \n\n\t\terr = irq_domain_set_hwirq_and_chip(d, virq, hwirq,\n\t\t\t\t\t\t    &gic_level_irq_controller,\n\t\t\t\t\t\t    NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tirqd_set_single_target(irq_desc_get_irq_data(irq_to_desc(virq)));\n\t\treturn gic_shared_irq_domain_map(d, virq, hwirq, 0);\n\t}\n\n\tintr = GIC_HWIRQ_TO_LOCAL(hwirq);\n\tmap = GIC_MAP_PIN_MAP_TO_PIN | gic_cpu_pin;\n\n\t \n\tswitch (intr) {\n\tcase GIC_LOCAL_INT_TIMER:\n\tcase GIC_LOCAL_INT_PERFCTR:\n\tcase GIC_LOCAL_INT_FDC:\n\t\t \n\t\tcd = &gic_all_vpes_chip_data[intr];\n\t\tcd->map = map;\n\t\terr = irq_domain_set_hwirq_and_chip(d, virq, hwirq,\n\t\t\t\t\t\t    &gic_all_vpes_local_irq_controller,\n\t\t\t\t\t\t    cd);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tirq_set_handler(virq, handle_percpu_irq);\n\t\tbreak;\n\n\tdefault:\n\t\terr = irq_domain_set_hwirq_and_chip(d, virq, hwirq,\n\t\t\t\t\t\t    &gic_local_irq_controller,\n\t\t\t\t\t\t    NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tirq_set_handler(virq, handle_percpu_devid_irq);\n\t\tirq_set_percpu_devid(virq);\n\t\tbreak;\n\t}\n\n\tif (!gic_local_irq_is_routable(intr))\n\t\treturn -EPERM;\n\n\traw_spin_lock_irqsave(&gic_lock, flags);\n\tfor_each_online_cpu(cpu) {\n\t\twrite_gic_vl_other(mips_cm_vp_id(cpu));\n\t\twrite_gic_vo_map(mips_gic_vx_map_reg(intr), map);\n\t}\n\traw_spin_unlock_irqrestore(&gic_lock, flags);\n\n\treturn 0;\n}\n\nstatic int gic_irq_domain_alloc(struct irq_domain *d, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs, void *arg)\n{\n\tstruct irq_fwspec *fwspec = arg;\n\tirq_hw_number_t hwirq;\n\n\tif (fwspec->param[0] == GIC_SHARED)\n\t\thwirq = GIC_SHARED_TO_HWIRQ(fwspec->param[1]);\n\telse\n\t\thwirq = GIC_LOCAL_TO_HWIRQ(fwspec->param[1]);\n\n\treturn gic_irq_domain_map(d, virq, hwirq);\n}\n\nstatic void gic_irq_domain_free(struct irq_domain *d, unsigned int virq,\n\t\t\t unsigned int nr_irqs)\n{\n}\n\nstatic const struct irq_domain_ops gic_irq_domain_ops = {\n\t.xlate = gic_irq_domain_xlate,\n\t.alloc = gic_irq_domain_alloc,\n\t.free = gic_irq_domain_free,\n\t.map = gic_irq_domain_map,\n};\n\n#ifdef CONFIG_GENERIC_IRQ_IPI\n\nstatic int gic_ipi_domain_xlate(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\t\tirq_hw_number_t *out_hwirq,\n\t\t\t\tunsigned int *out_type)\n{\n\t \n\t*out_hwirq = 0;\n\t*out_type = IRQ_TYPE_EDGE_RISING;\n\n\treturn 0;\n}\n\nstatic int gic_ipi_domain_alloc(struct irq_domain *d, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs, void *arg)\n{\n\tstruct cpumask *ipimask = arg;\n\tirq_hw_number_t hwirq, base_hwirq;\n\tint cpu, ret, i;\n\n\tbase_hwirq = find_first_bit(ipi_available, gic_shared_intrs);\n\tif (base_hwirq == gic_shared_intrs)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = base_hwirq; i < nr_irqs; i++) {\n\t\tif (!test_bit(i, ipi_available))\n\t\t\treturn -EBUSY;\n\t}\n\tbitmap_clear(ipi_available, base_hwirq, nr_irqs);\n\n\t \n\ti = 0;\n\tfor_each_cpu(cpu, ipimask) {\n\t\thwirq = GIC_SHARED_TO_HWIRQ(base_hwirq + i);\n\n\t\tret = irq_domain_set_hwirq_and_chip(d, virq + i, hwirq,\n\t\t\t\t\t\t    &gic_edge_irq_controller,\n\t\t\t\t\t\t    NULL);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tret = irq_domain_set_hwirq_and_chip(d->parent, virq + i, hwirq,\n\t\t\t\t\t\t    &gic_edge_irq_controller,\n\t\t\t\t\t\t    NULL);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tret = irq_set_irq_type(virq + i, IRQ_TYPE_EDGE_RISING);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tret = gic_shared_irq_domain_map(d, virq + i, hwirq, cpu);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\ti++;\n\t}\n\n\treturn 0;\nerror:\n\tbitmap_set(ipi_available, base_hwirq, nr_irqs);\n\treturn ret;\n}\n\nstatic void gic_ipi_domain_free(struct irq_domain *d, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs)\n{\n\tirq_hw_number_t base_hwirq;\n\tstruct irq_data *data;\n\n\tdata = irq_get_irq_data(virq);\n\tif (!data)\n\t\treturn;\n\n\tbase_hwirq = GIC_HWIRQ_TO_SHARED(irqd_to_hwirq(data));\n\tbitmap_set(ipi_available, base_hwirq, nr_irqs);\n}\n\nstatic int gic_ipi_domain_match(struct irq_domain *d, struct device_node *node,\n\t\t\t\tenum irq_domain_bus_token bus_token)\n{\n\tbool is_ipi;\n\n\tswitch (bus_token) {\n\tcase DOMAIN_BUS_IPI:\n\t\tis_ipi = d->bus_token == bus_token;\n\t\treturn (!node || to_of_node(d->fwnode) == node) && is_ipi;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct irq_domain_ops gic_ipi_domain_ops = {\n\t.xlate = gic_ipi_domain_xlate,\n\t.alloc = gic_ipi_domain_alloc,\n\t.free = gic_ipi_domain_free,\n\t.match = gic_ipi_domain_match,\n};\n\nstatic int gic_register_ipi_domain(struct device_node *node)\n{\n\tstruct irq_domain *gic_ipi_domain;\n\tunsigned int v[2], num_ipis;\n\n\tgic_ipi_domain = irq_domain_add_hierarchy(gic_irq_domain,\n\t\t\t\t\t\t  IRQ_DOMAIN_FLAG_IPI_PER_CPU,\n\t\t\t\t\t\t  GIC_NUM_LOCAL_INTRS + gic_shared_intrs,\n\t\t\t\t\t\t  node, &gic_ipi_domain_ops, NULL);\n\tif (!gic_ipi_domain) {\n\t\tpr_err(\"Failed to add IPI domain\");\n\t\treturn -ENXIO;\n\t}\n\n\tirq_domain_update_bus_token(gic_ipi_domain, DOMAIN_BUS_IPI);\n\n\tif (node &&\n\t    !of_property_read_u32_array(node, \"mti,reserved-ipi-vectors\", v, 2)) {\n\t\tbitmap_set(ipi_resrv, v[0], v[1]);\n\t} else {\n\t\t \n\t\tnum_ipis = 2 * num_possible_cpus();\n\t\tbitmap_set(ipi_resrv, gic_shared_intrs - num_ipis, num_ipis);\n\t}\n\n\tbitmap_copy(ipi_available, ipi_resrv, GIC_MAX_INTRS);\n\n\treturn 0;\n}\n\n#else  \n\nstatic inline int gic_register_ipi_domain(struct device_node *node)\n{\n\treturn 0;\n}\n\n#endif  \n\nstatic int gic_cpu_startup(unsigned int cpu)\n{\n\t \n\tchange_gic_vl_ctl(GIC_VX_CTL_EIC,\n\t\t\t  cpu_has_veic ? GIC_VX_CTL_EIC : 0);\n\n\t \n\twrite_gic_vl_rmask(~0);\n\n\t \n\tgic_all_vpes_irq_cpu_online();\n\n\treturn 0;\n}\n\nstatic int __init gic_of_init(struct device_node *node,\n\t\t\t      struct device_node *parent)\n{\n\tunsigned int cpu_vec, i, gicconfig;\n\tunsigned long reserved;\n\tphys_addr_t gic_base;\n\tstruct resource res;\n\tsize_t gic_len;\n\tint ret;\n\n\t \n\ti = 0;\n\treserved = (C_SW0 | C_SW1) >> __ffs(C_SW0);\n\twhile (!of_property_read_u32_index(node, \"mti,reserved-cpu-vectors\",\n\t\t\t\t\t   i++, &cpu_vec))\n\t\treserved |= BIT(cpu_vec);\n\n\tcpu_vec = find_first_zero_bit(&reserved, hweight_long(ST0_IM));\n\tif (cpu_vec == hweight_long(ST0_IM)) {\n\t\tpr_err(\"No CPU vectors available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (of_address_to_resource(node, 0, &res)) {\n\t\t \n\t\tif (mips_cm_present()) {\n\t\t\tgic_base = read_gcr_gic_base() &\n\t\t\t\t~CM_GCR_GIC_BASE_GICEN;\n\t\t\tgic_len = 0x20000;\n\t\t\tpr_warn(\"Using inherited base address %pa\\n\",\n\t\t\t\t&gic_base);\n\t\t} else {\n\t\t\tpr_err(\"Failed to get memory range\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tgic_base = res.start;\n\t\tgic_len = resource_size(&res);\n\t}\n\n\tif (mips_cm_present()) {\n\t\twrite_gcr_gic_base(gic_base | CM_GCR_GIC_BASE_GICEN);\n\t\t \n\t\t__sync();\n\t}\n\n\tmips_gic_base = ioremap(gic_base, gic_len);\n\tif (!mips_gic_base) {\n\t\tpr_err(\"Failed to ioremap gic_base\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgicconfig = read_gic_config();\n\tgic_shared_intrs = FIELD_GET(GIC_CONFIG_NUMINTERRUPTS, gicconfig);\n\tgic_shared_intrs = (gic_shared_intrs + 1) * 8;\n\n\tif (cpu_has_veic) {\n\t\t \n\t\tgic_cpu_pin = 0;\n\t\tset_vi_handler(gic_cpu_pin + GIC_PIN_TO_VEC_OFFSET,\n\t\t\t       __gic_irq_dispatch);\n\t} else {\n\t\tgic_cpu_pin = cpu_vec - GIC_CPU_PIN_OFFSET;\n\t\tirq_set_chained_handler(MIPS_CPU_IRQ_BASE + cpu_vec,\n\t\t\t\t\tgic_irq_dispatch);\n\t}\n\n\tgic_irq_domain = irq_domain_add_simple(node, GIC_NUM_LOCAL_INTRS +\n\t\t\t\t\t       gic_shared_intrs, 0,\n\t\t\t\t\t       &gic_irq_domain_ops, NULL);\n\tif (!gic_irq_domain) {\n\t\tpr_err(\"Failed to add IRQ domain\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = gic_register_ipi_domain(node);\n\tif (ret)\n\t\treturn ret;\n\n\tboard_bind_eic_interrupt = &gic_bind_eic_interrupt;\n\n\t \n\tfor (i = 0; i < gic_shared_intrs; i++) {\n\t\tchange_gic_pol(i, GIC_POL_ACTIVE_HIGH);\n\t\tchange_gic_trig(i, GIC_TRIG_LEVEL);\n\t\twrite_gic_rmask(i);\n\t}\n\n\treturn cpuhp_setup_state(CPUHP_AP_IRQ_MIPS_GIC_STARTING,\n\t\t\t\t \"irqchip/mips/gic:starting\",\n\t\t\t\t gic_cpu_startup, NULL);\n}\nIRQCHIP_DECLARE(mips_gic, \"mti,gic\", gic_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}