{
  "module_name": "irq-loongson-pch-msi.c",
  "hash_id": "91d442642ba9cf6d0854886318d669b3350e7db56da5525a802e81a14290b371",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-loongson-pch-msi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"pch-msi: \" fmt\n\n#include <linux/irqchip.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\nstatic int nr_pics;\n\nstruct pch_msi_data {\n\tstruct mutex\tmsi_map_lock;\n\tphys_addr_t\tdoorbell;\n\tu32\t\tirq_first;\t \n\tu32\t\tnum_irqs;\t \n\tunsigned long\t*msi_map;\n};\n\nstatic struct fwnode_handle *pch_msi_handle[MAX_IO_PICS];\n\nstatic void pch_msi_mask_msi_irq(struct irq_data *d)\n{\n\tpci_msi_mask_irq(d);\n\tirq_chip_mask_parent(d);\n}\n\nstatic void pch_msi_unmask_msi_irq(struct irq_data *d)\n{\n\tirq_chip_unmask_parent(d);\n\tpci_msi_unmask_irq(d);\n}\n\nstatic struct irq_chip pch_msi_irq_chip = {\n\t.name\t\t\t= \"PCH PCI MSI\",\n\t.irq_mask\t\t= pch_msi_mask_msi_irq,\n\t.irq_unmask\t\t= pch_msi_unmask_msi_irq,\n\t.irq_ack\t\t= irq_chip_ack_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n};\n\nstatic int pch_msi_allocate_hwirq(struct pch_msi_data *priv, int num_req)\n{\n\tint first;\n\n\tmutex_lock(&priv->msi_map_lock);\n\n\tfirst = bitmap_find_free_region(priv->msi_map, priv->num_irqs,\n\t\t\t\t\tget_count_order(num_req));\n\tif (first < 0) {\n\t\tmutex_unlock(&priv->msi_map_lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tmutex_unlock(&priv->msi_map_lock);\n\n\treturn priv->irq_first + first;\n}\n\nstatic void pch_msi_free_hwirq(struct pch_msi_data *priv,\n\t\t\t\tint hwirq, int num_req)\n{\n\tint first = hwirq - priv->irq_first;\n\n\tmutex_lock(&priv->msi_map_lock);\n\tbitmap_release_region(priv->msi_map, first, get_count_order(num_req));\n\tmutex_unlock(&priv->msi_map_lock);\n}\n\nstatic void pch_msi_compose_msi_msg(struct irq_data *data,\n\t\t\t\t\tstruct msi_msg *msg)\n{\n\tstruct pch_msi_data *priv = irq_data_get_irq_chip_data(data);\n\n\tmsg->address_hi = upper_32_bits(priv->doorbell);\n\tmsg->address_lo = lower_32_bits(priv->doorbell);\n\tmsg->data = data->hwirq;\n}\n\nstatic struct msi_domain_info pch_msi_domain_info = {\n\t.flags\t= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t  MSI_FLAG_MULTI_PCI_MSI | MSI_FLAG_PCI_MSIX,\n\t.chip\t= &pch_msi_irq_chip,\n};\n\nstatic struct irq_chip middle_irq_chip = {\n\t.name\t\t\t= \"PCH MSI\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_ack\t\t= irq_chip_ack_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.irq_compose_msi_msg\t= pch_msi_compose_msi_msg,\n};\n\nstatic int pch_msi_parent_domain_alloc(struct irq_domain *domain,\n\t\t\t\t\tunsigned int virq, int hwirq)\n{\n\tstruct irq_fwspec fwspec;\n\n\tfwspec.fwnode = domain->parent->fwnode;\n\tfwspec.param_count = 1;\n\tfwspec.param[0] = hwirq;\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\n}\n\nstatic int pch_msi_middle_domain_alloc(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int virq,\n\t\t\t\t\t   unsigned int nr_irqs, void *args)\n{\n\tstruct pch_msi_data *priv = domain->host_data;\n\tint hwirq, err, i;\n\n\thwirq = pch_msi_allocate_hwirq(priv, nr_irqs);\n\tif (hwirq < 0)\n\t\treturn hwirq;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\terr = pch_msi_parent_domain_alloc(domain, virq + i, hwirq + i);\n\t\tif (err)\n\t\t\tgoto err_hwirq;\n\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\n\t\t\t\t\t      &middle_irq_chip, priv);\n\t}\n\n\treturn 0;\n\nerr_hwirq:\n\tpch_msi_free_hwirq(priv, hwirq, nr_irqs);\n\tirq_domain_free_irqs_parent(domain, virq, i - 1);\n\n\treturn err;\n}\n\nstatic void pch_msi_middle_domain_free(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int virq,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct pch_msi_data *priv = irq_data_get_irq_chip_data(d);\n\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n\tpch_msi_free_hwirq(priv, d->hwirq, nr_irqs);\n}\n\nstatic const struct irq_domain_ops pch_msi_middle_domain_ops = {\n\t.alloc\t= pch_msi_middle_domain_alloc,\n\t.free\t= pch_msi_middle_domain_free,\n};\n\nstatic int pch_msi_init_domains(struct pch_msi_data *priv,\n\t\t\t\tstruct irq_domain *parent,\n\t\t\t\tstruct fwnode_handle *domain_handle)\n{\n\tstruct irq_domain *middle_domain, *msi_domain;\n\n\tmiddle_domain = irq_domain_create_hierarchy(parent, 0, priv->num_irqs,\n\t\t\t\t\t\t    domain_handle,\n\t\t\t\t\t\t    &pch_msi_middle_domain_ops,\n\t\t\t\t\t\t    priv);\n\tif (!middle_domain) {\n\t\tpr_err(\"Failed to create the MSI middle domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tirq_domain_update_bus_token(middle_domain, DOMAIN_BUS_NEXUS);\n\n\tmsi_domain = pci_msi_create_irq_domain(domain_handle,\n\t\t\t\t\t       &pch_msi_domain_info,\n\t\t\t\t\t       middle_domain);\n\tif (!msi_domain) {\n\t\tpr_err(\"Failed to create PCI MSI domain\\n\");\n\t\tirq_domain_remove(middle_domain);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int pch_msi_init(phys_addr_t msg_address, int irq_base, int irq_count,\n\t\t\tstruct irq_domain *parent_domain, struct fwnode_handle *domain_handle)\n{\n\tint ret;\n\tstruct pch_msi_data *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->msi_map_lock);\n\n\tpriv->doorbell = msg_address;\n\tpriv->irq_first = irq_base;\n\tpriv->num_irqs = irq_count;\n\n\tpriv->msi_map = bitmap_zalloc(priv->num_irqs, GFP_KERNEL);\n\tif (!priv->msi_map)\n\t\tgoto err_priv;\n\n\tpr_debug(\"Registering %d MSIs, starting at %d\\n\",\n\t\t priv->num_irqs, priv->irq_first);\n\n\tret = pch_msi_init_domains(priv, parent_domain, domain_handle);\n\tif (ret)\n\t\tgoto err_map;\n\n\tpch_msi_handle[nr_pics++] = domain_handle;\n\treturn 0;\n\nerr_map:\n\tbitmap_free(priv->msi_map);\nerr_priv:\n\tkfree(priv);\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_OF\nstatic int pch_msi_of_init(struct device_node *node, struct device_node *parent)\n{\n\tint err;\n\tint irq_base, irq_count;\n\tstruct resource res;\n\tstruct irq_domain *parent_domain;\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tpr_err(\"Failed to find the parent domain\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_address_to_resource(node, 0, &res)) {\n\t\tpr_err(\"Failed to allocate resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(node, \"loongson,msi-base-vec\", &irq_base)) {\n\t\tpr_err(\"Unable to parse MSI vec base\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(node, \"loongson,msi-num-vecs\", &irq_count)) {\n\t\tpr_err(\"Unable to parse MSI vec number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = pch_msi_init(res.start, irq_base, irq_count, parent_domain, of_node_to_fwnode(node));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(pch_msi, \"loongson,pch-msi-1.0\", pch_msi_of_init);\n#endif\n\n#ifdef CONFIG_ACPI\nstruct fwnode_handle *get_pch_msi_handle(int pci_segment)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_IO_PICS; i++) {\n\t\tif (msi_group[i].pci_segment == pci_segment)\n\t\t\treturn pch_msi_handle[i];\n\t}\n\treturn NULL;\n}\n\nint __init pch_msi_acpi_init(struct irq_domain *parent,\n\t\t\t\t\tstruct acpi_madt_msi_pic *acpi_pchmsi)\n{\n\tint ret;\n\tstruct fwnode_handle *domain_handle;\n\n\tdomain_handle = irq_domain_alloc_fwnode(&acpi_pchmsi->msg_address);\n\tret = pch_msi_init(acpi_pchmsi->msg_address, acpi_pchmsi->start,\n\t\t\t\tacpi_pchmsi->count, parent, domain_handle);\n\tif (ret < 0)\n\t\tirq_domain_free_fwnode(domain_handle);\n\n\treturn ret;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}