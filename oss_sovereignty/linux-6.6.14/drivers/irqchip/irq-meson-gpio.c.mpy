{
  "module_name": "irq-meson-gpio.c",
  "hash_id": "6b2233f844300387e0a9c8394588db20ddac51efae13cafa37f973f13edd5b90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-meson-gpio.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#define MAX_NUM_CHANNEL 64\n#define MAX_INPUT_MUX 256\n\n#define REG_EDGE_POL\t0x00\n#define REG_PIN_03_SEL\t0x04\n#define REG_PIN_47_SEL\t0x08\n#define REG_FILTER_SEL\t0x0c\n\n \n#define REG_PIN_A1_SEL\t0x04\n \n#define REG_EDGE_POL_S4\t0x1c\n\n \n#define REG_EDGE_POL_EDGE(params, x)\tBIT((params)->edge_single_offset + (x))\n#define REG_EDGE_POL_LOW(params, x)\tBIT((params)->pol_low_offset + (x))\n#define REG_BOTH_EDGE(params, x)\tBIT((params)->edge_both_offset + (x))\n#define REG_EDGE_POL_MASK(params, x)    (\t\\\n\t\tREG_EDGE_POL_EDGE(params, x) |\t\\\n\t\tREG_EDGE_POL_LOW(params, x)  |\t\\\n\t\tREG_BOTH_EDGE(params, x))\n#define REG_PIN_SEL_SHIFT(x)\t(((x) % 4) * 8)\n#define REG_FILTER_SEL_SHIFT(x)\t((x) * 4)\n\nstruct meson_gpio_irq_controller;\nstatic void meson8_gpio_irq_sel_pin(struct meson_gpio_irq_controller *ctl,\n\t\t\t\t    unsigned int channel, unsigned long hwirq);\nstatic void meson_gpio_irq_init_dummy(struct meson_gpio_irq_controller *ctl);\nstatic void meson_a1_gpio_irq_sel_pin(struct meson_gpio_irq_controller *ctl,\n\t\t\t\t      unsigned int channel,\n\t\t\t\t      unsigned long hwirq);\nstatic void meson_a1_gpio_irq_init(struct meson_gpio_irq_controller *ctl);\nstatic int meson8_gpio_irq_set_type(struct meson_gpio_irq_controller *ctl,\n\t\t\t\t    unsigned int type, u32 *channel_hwirq);\nstatic int meson_s4_gpio_irq_set_type(struct meson_gpio_irq_controller *ctl,\n\t\t\t\t      unsigned int type, u32 *channel_hwirq);\n\nstruct irq_ctl_ops {\n\tvoid (*gpio_irq_sel_pin)(struct meson_gpio_irq_controller *ctl,\n\t\t\t\t unsigned int channel, unsigned long hwirq);\n\tvoid (*gpio_irq_init)(struct meson_gpio_irq_controller *ctl);\n\tint (*gpio_irq_set_type)(struct meson_gpio_irq_controller *ctl,\n\t\t\t\t unsigned int type, u32 *channel_hwirq);\n};\n\nstruct meson_gpio_irq_params {\n\tunsigned int nr_hwirq;\n\tunsigned int nr_channels;\n\tbool support_edge_both;\n\tunsigned int edge_both_offset;\n\tunsigned int edge_single_offset;\n\tunsigned int pol_low_offset;\n\tunsigned int pin_sel_mask;\n\tstruct irq_ctl_ops ops;\n};\n\n#define INIT_MESON_COMMON(irqs, init, sel, type)\t\t\\\n\t.nr_hwirq = irqs,\t\t\t\t\t\\\n\t.ops = {\t\t\t\t\t\t\\\n\t\t.gpio_irq_init = init,\t\t\t\t\\\n\t\t.gpio_irq_sel_pin = sel,\t\t\t\\\n\t\t.gpio_irq_set_type = type,\t\t\t\\\n\t},\n\n#define INIT_MESON8_COMMON_DATA(irqs)\t\t\t\t\\\n\tINIT_MESON_COMMON(irqs, meson_gpio_irq_init_dummy,\t\\\n\t\t\t  meson8_gpio_irq_sel_pin,\t\t\\\n\t\t\t  meson8_gpio_irq_set_type)\t\t\\\n\t.edge_single_offset = 0,\t\t\t\t\\\n\t.pol_low_offset = 16,\t\t\t\t\t\\\n\t.pin_sel_mask = 0xff,\t\t\t\t\t\\\n\t.nr_channels = 8,\t\t\t\t\t\\\n\n#define INIT_MESON_A1_COMMON_DATA(irqs)\t\t\t\t\\\n\tINIT_MESON_COMMON(irqs, meson_a1_gpio_irq_init,\t\t\\\n\t\t\t  meson_a1_gpio_irq_sel_pin,\t\t\\\n\t\t\t  meson8_gpio_irq_set_type)\t\t\\\n\t.support_edge_both = true,\t\t\t\t\\\n\t.edge_both_offset = 16,\t\t\t\t\t\\\n\t.edge_single_offset = 8,\t\t\t\t\\\n\t.pol_low_offset = 0,\t\t\t\t\t\\\n\t.pin_sel_mask = 0x7f,\t\t\t\t\t\\\n\t.nr_channels = 8,\t\t\t\t\t\\\n\n#define INIT_MESON_S4_COMMON_DATA(irqs)\t\t\t\t\\\n\tINIT_MESON_COMMON(irqs, meson_a1_gpio_irq_init,\t\t\\\n\t\t\t  meson_a1_gpio_irq_sel_pin,\t\t\\\n\t\t\t  meson_s4_gpio_irq_set_type)\t\t\\\n\t.support_edge_both = true,\t\t\t\t\\\n\t.edge_both_offset = 0,\t\t\t\t\t\\\n\t.edge_single_offset = 12,\t\t\t\t\\\n\t.pol_low_offset = 0,\t\t\t\t\t\\\n\t.pin_sel_mask = 0xff,\t\t\t\t\t\\\n\t.nr_channels = 12,\t\t\t\t\t\\\n\nstatic const struct meson_gpio_irq_params meson8_params = {\n\tINIT_MESON8_COMMON_DATA(134)\n};\n\nstatic const struct meson_gpio_irq_params meson8b_params = {\n\tINIT_MESON8_COMMON_DATA(119)\n};\n\nstatic const struct meson_gpio_irq_params gxbb_params = {\n\tINIT_MESON8_COMMON_DATA(133)\n};\n\nstatic const struct meson_gpio_irq_params gxl_params = {\n\tINIT_MESON8_COMMON_DATA(110)\n};\n\nstatic const struct meson_gpio_irq_params axg_params = {\n\tINIT_MESON8_COMMON_DATA(100)\n};\n\nstatic const struct meson_gpio_irq_params sm1_params = {\n\tINIT_MESON8_COMMON_DATA(100)\n\t.support_edge_both = true,\n\t.edge_both_offset = 8,\n};\n\nstatic const struct meson_gpio_irq_params a1_params = {\n\tINIT_MESON_A1_COMMON_DATA(62)\n};\n\nstatic const struct meson_gpio_irq_params s4_params = {\n\tINIT_MESON_S4_COMMON_DATA(82)\n};\n\nstatic const struct meson_gpio_irq_params c3_params = {\n\tINIT_MESON_S4_COMMON_DATA(55)\n};\n\nstatic const struct of_device_id meson_irq_gpio_matches[] __maybe_unused = {\n\t{ .compatible = \"amlogic,meson8-gpio-intc\", .data = &meson8_params },\n\t{ .compatible = \"amlogic,meson8b-gpio-intc\", .data = &meson8b_params },\n\t{ .compatible = \"amlogic,meson-gxbb-gpio-intc\", .data = &gxbb_params },\n\t{ .compatible = \"amlogic,meson-gxl-gpio-intc\", .data = &gxl_params },\n\t{ .compatible = \"amlogic,meson-axg-gpio-intc\", .data = &axg_params },\n\t{ .compatible = \"amlogic,meson-g12a-gpio-intc\", .data = &axg_params },\n\t{ .compatible = \"amlogic,meson-sm1-gpio-intc\", .data = &sm1_params },\n\t{ .compatible = \"amlogic,meson-a1-gpio-intc\", .data = &a1_params },\n\t{ .compatible = \"amlogic,meson-s4-gpio-intc\", .data = &s4_params },\n\t{ .compatible = \"amlogic,c3-gpio-intc\", .data = &c3_params },\n\t{ }\n};\n\nstruct meson_gpio_irq_controller {\n\tconst struct meson_gpio_irq_params *params;\n\tvoid __iomem *base;\n\tu32 channel_irqs[MAX_NUM_CHANNEL];\n\tDECLARE_BITMAP(channel_map, MAX_NUM_CHANNEL);\n\tspinlock_t lock;\n};\n\nstatic void meson_gpio_irq_update_bits(struct meson_gpio_irq_controller *ctl,\n\t\t\t\t       unsigned int reg, u32 mask, u32 val)\n{\n\tunsigned long flags;\n\tu32 tmp;\n\n\tspin_lock_irqsave(&ctl->lock, flags);\n\n\ttmp = readl_relaxed(ctl->base + reg);\n\ttmp &= ~mask;\n\ttmp |= val;\n\twritel_relaxed(tmp, ctl->base + reg);\n\n\tspin_unlock_irqrestore(&ctl->lock, flags);\n}\n\nstatic void meson_gpio_irq_init_dummy(struct meson_gpio_irq_controller *ctl)\n{\n}\n\nstatic void meson8_gpio_irq_sel_pin(struct meson_gpio_irq_controller *ctl,\n\t\t\t\t    unsigned int channel, unsigned long hwirq)\n{\n\tunsigned int reg_offset;\n\tunsigned int bit_offset;\n\n\treg_offset = (channel < 4) ? REG_PIN_03_SEL : REG_PIN_47_SEL;\n\tbit_offset = REG_PIN_SEL_SHIFT(channel);\n\n\tmeson_gpio_irq_update_bits(ctl, reg_offset,\n\t\t\t\t   ctl->params->pin_sel_mask << bit_offset,\n\t\t\t\t   hwirq << bit_offset);\n}\n\nstatic void meson_a1_gpio_irq_sel_pin(struct meson_gpio_irq_controller *ctl,\n\t\t\t\t      unsigned int channel,\n\t\t\t\t      unsigned long hwirq)\n{\n\tunsigned int reg_offset;\n\tunsigned int bit_offset;\n\n\tbit_offset = ((channel % 2) == 0) ? 0 : 16;\n\treg_offset = REG_PIN_A1_SEL + ((channel / 2) << 2);\n\n\tmeson_gpio_irq_update_bits(ctl, reg_offset,\n\t\t\t\t   ctl->params->pin_sel_mask << bit_offset,\n\t\t\t\t   hwirq << bit_offset);\n}\n\n \nstatic void meson_a1_gpio_irq_init(struct meson_gpio_irq_controller *ctl)\n{\n\tmeson_gpio_irq_update_bits(ctl, REG_EDGE_POL, BIT(31), BIT(31));\n}\n\nstatic int\nmeson_gpio_irq_request_channel(struct meson_gpio_irq_controller *ctl,\n\t\t\t       unsigned long  hwirq,\n\t\t\t       u32 **channel_hwirq)\n{\n\tunsigned long flags;\n\tunsigned int idx;\n\n\tspin_lock_irqsave(&ctl->lock, flags);\n\n\t \n\tidx = find_first_zero_bit(ctl->channel_map, ctl->params->nr_channels);\n\tif (idx >= ctl->params->nr_channels) {\n\t\tspin_unlock_irqrestore(&ctl->lock, flags);\n\t\tpr_err(\"No channel available\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\tset_bit(idx, ctl->channel_map);\n\n\tspin_unlock_irqrestore(&ctl->lock, flags);\n\n\t \n\tctl->params->ops.gpio_irq_sel_pin(ctl, idx, hwirq);\n\n\t \n\t*channel_hwirq = &(ctl->channel_irqs[idx]);\n\n\tpr_debug(\"hwirq %lu assigned to channel %d - irq %u\\n\",\n\t\t hwirq, idx, **channel_hwirq);\n\n\treturn 0;\n}\n\nstatic unsigned int\nmeson_gpio_irq_get_channel_idx(struct meson_gpio_irq_controller *ctl,\n\t\t\t       u32 *channel_hwirq)\n{\n\treturn channel_hwirq - ctl->channel_irqs;\n}\n\nstatic void\nmeson_gpio_irq_release_channel(struct meson_gpio_irq_controller *ctl,\n\t\t\t       u32 *channel_hwirq)\n{\n\tunsigned int idx;\n\n\tidx = meson_gpio_irq_get_channel_idx(ctl, channel_hwirq);\n\tclear_bit(idx, ctl->channel_map);\n}\n\nstatic int meson8_gpio_irq_set_type(struct meson_gpio_irq_controller *ctl,\n\t\t\t\t    unsigned int type, u32 *channel_hwirq)\n{\n\tu32 val = 0;\n\tunsigned int idx;\n\tconst struct meson_gpio_irq_params *params;\n\n\tparams = ctl->params;\n\tidx = meson_gpio_irq_get_channel_idx(ctl, channel_hwirq);\n\n\t \n\ttype &= IRQ_TYPE_SENSE_MASK;\n\n\t \n\tif (type == IRQ_TYPE_EDGE_BOTH) {\n\t\tif (!params->support_edge_both)\n\t\t\treturn -EINVAL;\n\n\t\tval |= REG_BOTH_EDGE(params, idx);\n\t} else {\n\t\tif (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))\n\t\t\tval |= REG_EDGE_POL_EDGE(params, idx);\n\n\t\tif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_EDGE_FALLING))\n\t\t\tval |= REG_EDGE_POL_LOW(params, idx);\n\t}\n\n\tmeson_gpio_irq_update_bits(ctl, REG_EDGE_POL,\n\t\t\t\t   REG_EDGE_POL_MASK(params, idx), val);\n\n\treturn 0;\n}\n\n \nstatic int meson_s4_gpio_irq_set_type(struct meson_gpio_irq_controller *ctl,\n\t\t\t\t      unsigned int type, u32 *channel_hwirq)\n{\n\tu32 val = 0;\n\tunsigned int idx;\n\n\tidx = meson_gpio_irq_get_channel_idx(ctl, channel_hwirq);\n\n\ttype &= IRQ_TYPE_SENSE_MASK;\n\n\tmeson_gpio_irq_update_bits(ctl, REG_EDGE_POL_S4, BIT(idx), 0);\n\n\tif (type == IRQ_TYPE_EDGE_BOTH) {\n\t\tval |= BIT(ctl->params->edge_both_offset + idx);\n\t\tmeson_gpio_irq_update_bits(ctl, REG_EDGE_POL_S4,\n\t\t\t\t\t   BIT(ctl->params->edge_both_offset + idx), val);\n\t\treturn 0;\n\t}\n\n\tif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_EDGE_FALLING))\n\t\tval |= BIT(ctl->params->pol_low_offset + idx);\n\n\tif (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))\n\t\tval |= BIT(ctl->params->edge_single_offset + idx);\n\n\tmeson_gpio_irq_update_bits(ctl, REG_EDGE_POL,\n\t\t\t\t   BIT(idx) | BIT(12 + idx), val);\n\treturn 0;\n};\n\nstatic unsigned int meson_gpio_irq_type_output(unsigned int type)\n{\n\tunsigned int sense = type & IRQ_TYPE_SENSE_MASK;\n\n\ttype &= ~IRQ_TYPE_SENSE_MASK;\n\n\t \n\tif (sense & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW))\n\t\ttype |= IRQ_TYPE_LEVEL_HIGH;\n\telse\n\t\ttype |= IRQ_TYPE_EDGE_RISING;\n\n\treturn type;\n}\n\nstatic int meson_gpio_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct meson_gpio_irq_controller *ctl = data->domain->host_data;\n\tu32 *channel_hwirq = irq_data_get_irq_chip_data(data);\n\tint ret;\n\n\tret = ctl->params->ops.gpio_irq_set_type(ctl, type, channel_hwirq);\n\tif (ret)\n\t\treturn ret;\n\n\treturn irq_chip_set_type_parent(data,\n\t\t\t\t\tmeson_gpio_irq_type_output(type));\n}\n\nstatic struct irq_chip meson_gpio_irq_chip = {\n\t.name\t\t\t= \"meson-gpio-irqchip\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_type\t\t= meson_gpio_irq_set_type,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n#endif\n\t.flags\t\t\t= IRQCHIP_SET_TYPE_MASKED,\n};\n\nstatic int meson_gpio_irq_domain_translate(struct irq_domain *domain,\n\t\t\t\t\t   struct irq_fwspec *fwspec,\n\t\t\t\t\t   unsigned long *hwirq,\n\t\t\t\t\t   unsigned int *type)\n{\n\tif (is_of_node(fwspec->fwnode) && fwspec->param_count == 2) {\n\t\t*hwirq\t= fwspec->param[0];\n\t\t*type\t= fwspec->param[1];\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int meson_gpio_irq_allocate_gic_irq(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int virq,\n\t\t\t\t\t   u32 hwirq,\n\t\t\t\t\t   unsigned int type)\n{\n\tstruct irq_fwspec fwspec;\n\n\tfwspec.fwnode = domain->parent->fwnode;\n\tfwspec.param_count = 3;\n\tfwspec.param[0] = 0;\t \n\tfwspec.param[1] = hwirq;\n\tfwspec.param[2] = meson_gpio_irq_type_output(type);\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\n}\n\nstatic int meson_gpio_irq_domain_alloc(struct irq_domain *domain,\n\t\t\t\t       unsigned int virq,\n\t\t\t\t       unsigned int nr_irqs,\n\t\t\t\t       void *data)\n{\n\tstruct irq_fwspec *fwspec = data;\n\tstruct meson_gpio_irq_controller *ctl = domain->host_data;\n\tunsigned long hwirq;\n\tu32 *channel_hwirq;\n\tunsigned int type;\n\tint ret;\n\n\tif (WARN_ON(nr_irqs != 1))\n\t\treturn -EINVAL;\n\n\tret = meson_gpio_irq_domain_translate(domain, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = meson_gpio_irq_request_channel(ctl, hwirq, &channel_hwirq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = meson_gpio_irq_allocate_gic_irq(domain, virq,\n\t\t\t\t\t      *channel_hwirq, type);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to allocate gic irq %u\\n\", *channel_hwirq);\n\t\tmeson_gpio_irq_release_channel(ctl, channel_hwirq);\n\t\treturn ret;\n\t}\n\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t      &meson_gpio_irq_chip, channel_hwirq);\n\n\treturn 0;\n}\n\nstatic void meson_gpio_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t       unsigned int virq,\n\t\t\t\t       unsigned int nr_irqs)\n{\n\tstruct meson_gpio_irq_controller *ctl = domain->host_data;\n\tstruct irq_data *irq_data;\n\tu32 *channel_hwirq;\n\n\tif (WARN_ON(nr_irqs != 1))\n\t\treturn;\n\n\tirq_domain_free_irqs_parent(domain, virq, 1);\n\n\tirq_data = irq_domain_get_irq_data(domain, virq);\n\tchannel_hwirq = irq_data_get_irq_chip_data(irq_data);\n\n\tmeson_gpio_irq_release_channel(ctl, channel_hwirq);\n}\n\nstatic const struct irq_domain_ops meson_gpio_irq_domain_ops = {\n\t.alloc\t\t= meson_gpio_irq_domain_alloc,\n\t.free\t\t= meson_gpio_irq_domain_free,\n\t.translate\t= meson_gpio_irq_domain_translate,\n};\n\nstatic int meson_gpio_irq_parse_dt(struct device_node *node, struct meson_gpio_irq_controller *ctl)\n{\n\tconst struct of_device_id *match;\n\tint ret;\n\n\tmatch = of_match_node(meson_irq_gpio_matches, node);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tctl->params = match->data;\n\n\tret = of_property_read_variable_u32_array(node,\n\t\t\t\t\t\t  \"amlogic,channel-interrupts\",\n\t\t\t\t\t\t  ctl->channel_irqs,\n\t\t\t\t\t\t  ctl->params->nr_channels,\n\t\t\t\t\t\t  ctl->params->nr_channels);\n\tif (ret < 0) {\n\t\tpr_err(\"can't get %d channel interrupts\\n\", ctl->params->nr_channels);\n\t\treturn ret;\n\t}\n\n\tctl->params->ops.gpio_irq_init(ctl);\n\n\treturn 0;\n}\n\nstatic int meson_gpio_irq_of_init(struct device_node *node, struct device_node *parent)\n{\n\tstruct irq_domain *domain, *parent_domain;\n\tstruct meson_gpio_irq_controller *ctl;\n\tint ret;\n\n\tif (!parent) {\n\t\tpr_err(\"missing parent interrupt node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tpr_err(\"unable to obtain parent domain\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\n\tif (!ctl)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ctl->lock);\n\n\tctl->base = of_iomap(node, 0);\n\tif (!ctl->base) {\n\t\tret = -ENOMEM;\n\t\tgoto free_ctl;\n\t}\n\n\tret = meson_gpio_irq_parse_dt(node, ctl);\n\tif (ret)\n\t\tgoto free_channel_irqs;\n\n\tdomain = irq_domain_create_hierarchy(parent_domain, 0,\n\t\t\t\t\t     ctl->params->nr_hwirq,\n\t\t\t\t\t     of_node_to_fwnode(node),\n\t\t\t\t\t     &meson_gpio_irq_domain_ops,\n\t\t\t\t\t     ctl);\n\tif (!domain) {\n\t\tpr_err(\"failed to add domain\\n\");\n\t\tret = -ENODEV;\n\t\tgoto free_channel_irqs;\n\t}\n\n\tpr_info(\"%d to %d gpio interrupt mux initialized\\n\",\n\t\tctl->params->nr_hwirq, ctl->params->nr_channels);\n\n\treturn 0;\n\nfree_channel_irqs:\n\tiounmap(ctl->base);\nfree_ctl:\n\tkfree(ctl);\n\n\treturn ret;\n}\n\nIRQCHIP_PLATFORM_DRIVER_BEGIN(meson_gpio_intc)\nIRQCHIP_MATCH(\"amlogic,meson-gpio-intc\", meson_gpio_irq_of_init)\nIRQCHIP_PLATFORM_DRIVER_END(meson_gpio_intc)\n\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:meson-gpio-intc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}