{
  "module_name": "irq-mvebu-icu.c",
  "hash_id": "0e897ad3d91f140fc7c0e09bc0dfe29c6f31ed86375dfad6f56694abc4cb0f3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mvebu-icu.c",
  "human_readable_source": " \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/jump_label.h>\n#include <linux/kernel.h>\n#include <linux/msi.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include <dt-bindings/interrupt-controller/mvebu-icu.h>\n\n \n#define ICU_SETSPI_NSR_AL\t0x10\n#define ICU_SETSPI_NSR_AH\t0x14\n#define ICU_CLRSPI_NSR_AL\t0x18\n#define ICU_CLRSPI_NSR_AH\t0x1c\n#define ICU_SET_SEI_AL\t\t0x50\n#define ICU_SET_SEI_AH\t\t0x54\n#define ICU_CLR_SEI_AL\t\t0x58\n#define ICU_CLR_SEI_AH\t\t0x5C\n#define ICU_INT_CFG(x)          (0x100 + 4 * (x))\n#define   ICU_INT_ENABLE\tBIT(24)\n#define   ICU_IS_EDGE\t\tBIT(28)\n#define   ICU_GROUP_SHIFT\t29\n\n \n#define ICU_MAX_IRQS\t\t207\n#define ICU_SATA0_ICU_ID\t109\n#define ICU_SATA1_ICU_ID\t107\n\nstruct mvebu_icu_subset_data {\n\tunsigned int icu_group;\n\tunsigned int offset_set_ah;\n\tunsigned int offset_set_al;\n\tunsigned int offset_clr_ah;\n\tunsigned int offset_clr_al;\n};\n\nstruct mvebu_icu {\n\tvoid __iomem *base;\n\tstruct device *dev;\n};\n\nstruct mvebu_icu_msi_data {\n\tstruct mvebu_icu *icu;\n\tatomic_t initialized;\n\tconst struct mvebu_icu_subset_data *subset_data;\n};\n\nstruct mvebu_icu_irq_data {\n\tstruct mvebu_icu *icu;\n\tunsigned int icu_group;\n\tunsigned int type;\n};\n\nstatic DEFINE_STATIC_KEY_FALSE(legacy_bindings);\n\nstatic void mvebu_icu_init(struct mvebu_icu *icu,\n\t\t\t   struct mvebu_icu_msi_data *msi_data,\n\t\t\t   struct msi_msg *msg)\n{\n\tconst struct mvebu_icu_subset_data *subset = msi_data->subset_data;\n\n\tif (atomic_cmpxchg(&msi_data->initialized, false, true))\n\t\treturn;\n\n\t \n\twritel_relaxed(msg[0].address_hi, icu->base + subset->offset_set_ah);\n\twritel_relaxed(msg[0].address_lo, icu->base + subset->offset_set_al);\n\n\tif (subset->icu_group != ICU_GRP_NSR)\n\t\treturn;\n\n\t \n\twritel_relaxed(msg[1].address_hi, icu->base + subset->offset_clr_ah);\n\twritel_relaxed(msg[1].address_lo, icu->base + subset->offset_clr_al);\n}\n\nstatic void mvebu_icu_write_msg(struct msi_desc *desc, struct msi_msg *msg)\n{\n\tstruct irq_data *d = irq_get_irq_data(desc->irq);\n\tstruct mvebu_icu_msi_data *msi_data = platform_msi_get_host_data(d->domain);\n\tstruct mvebu_icu_irq_data *icu_irqd = d->chip_data;\n\tstruct mvebu_icu *icu = icu_irqd->icu;\n\tunsigned int icu_int;\n\n\tif (msg->address_lo || msg->address_hi) {\n\t\t \n\t\tmvebu_icu_init(icu, msi_data, msg);\n\t\t \n\t\ticu_int = msg->data | ICU_INT_ENABLE;\n\t\tif (icu_irqd->type & IRQ_TYPE_EDGE_RISING)\n\t\t\ticu_int |= ICU_IS_EDGE;\n\t\ticu_int |= icu_irqd->icu_group << ICU_GROUP_SHIFT;\n\t} else {\n\t\t \n\t\ticu_int = 0;\n\t}\n\n\twritel_relaxed(icu_int, icu->base + ICU_INT_CFG(d->hwirq));\n\n\t \n\tif (d->hwirq == ICU_SATA0_ICU_ID || d->hwirq == ICU_SATA1_ICU_ID) {\n\t\twritel_relaxed(icu_int,\n\t\t\t       icu->base + ICU_INT_CFG(ICU_SATA0_ICU_ID));\n\t\twritel_relaxed(icu_int,\n\t\t\t       icu->base + ICU_INT_CFG(ICU_SATA1_ICU_ID));\n\t}\n}\n\nstatic struct irq_chip mvebu_icu_nsr_chip = {\n\t.name\t\t\t= \"ICU-NSR\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n};\n\nstatic struct irq_chip mvebu_icu_sei_chip = {\n\t.name\t\t\t= \"ICU-SEI\",\n\t.irq_ack\t\t= irq_chip_ack_parent,\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n};\n\nstatic int\nmvebu_icu_irq_domain_translate(struct irq_domain *d, struct irq_fwspec *fwspec,\n\t\t\t       unsigned long *hwirq, unsigned int *type)\n{\n\tunsigned int param_count = static_branch_unlikely(&legacy_bindings) ? 3 : 2;\n\tstruct mvebu_icu_msi_data *msi_data = platform_msi_get_host_data(d);\n\tstruct mvebu_icu *icu = msi_data->icu;\n\n\t \n\tif (WARN_ON(fwspec->param_count != param_count)) {\n\t\tdev_err(icu->dev, \"wrong ICU parameter count %d\\n\",\n\t\t\tfwspec->param_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (static_branch_unlikely(&legacy_bindings)) {\n\t\t*hwirq = fwspec->param[1];\n\t\t*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;\n\t\tif (fwspec->param[0] != ICU_GRP_NSR) {\n\t\t\tdev_err(icu->dev, \"wrong ICU group type %x\\n\",\n\t\t\t\tfwspec->param[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t*hwirq = fwspec->param[0];\n\t\t*type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\n\t\t \n\t\tif (msi_data->subset_data->icu_group == ICU_GRP_SEI)\n\t\t\t*type = IRQ_TYPE_EDGE_RISING;\n\t}\n\n\tif (*hwirq >= ICU_MAX_IRQS) {\n\t\tdev_err(icu->dev, \"invalid interrupt number %ld\\n\", *hwirq);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmvebu_icu_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t   unsigned int nr_irqs, void *args)\n{\n\tint err;\n\tunsigned long hwirq;\n\tstruct irq_fwspec *fwspec = args;\n\tstruct mvebu_icu_msi_data *msi_data = platform_msi_get_host_data(domain);\n\tstruct mvebu_icu *icu = msi_data->icu;\n\tstruct mvebu_icu_irq_data *icu_irqd;\n\tstruct irq_chip *chip = &mvebu_icu_nsr_chip;\n\n\ticu_irqd = kmalloc(sizeof(*icu_irqd), GFP_KERNEL);\n\tif (!icu_irqd)\n\t\treturn -ENOMEM;\n\n\terr = mvebu_icu_irq_domain_translate(domain, fwspec, &hwirq,\n\t\t\t\t\t     &icu_irqd->type);\n\tif (err) {\n\t\tdev_err(icu->dev, \"failed to translate ICU parameters\\n\");\n\t\tgoto free_irqd;\n\t}\n\n\tif (static_branch_unlikely(&legacy_bindings))\n\t\ticu_irqd->icu_group = fwspec->param[0];\n\telse\n\t\ticu_irqd->icu_group = msi_data->subset_data->icu_group;\n\ticu_irqd->icu = icu;\n\n\terr = platform_msi_device_domain_alloc(domain, virq, nr_irqs);\n\tif (err) {\n\t\tdev_err(icu->dev, \"failed to allocate ICU interrupt in parent domain\\n\");\n\t\tgoto free_irqd;\n\t}\n\n\t \n\terr = irq_set_irqchip_state(virq, IRQCHIP_STATE_PENDING, false);\n\tif (err)\n\t\tgoto free_msi;\n\n\tif (icu_irqd->icu_group == ICU_GRP_SEI)\n\t\tchip = &mvebu_icu_sei_chip;\n\n\terr = irq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t\t    chip, icu_irqd);\n\tif (err) {\n\t\tdev_err(icu->dev, \"failed to set the data to IRQ domain\\n\");\n\t\tgoto free_msi;\n\t}\n\n\treturn 0;\n\nfree_msi:\n\tplatform_msi_device_domain_free(domain, virq, nr_irqs);\nfree_irqd:\n\tkfree(icu_irqd);\n\treturn err;\n}\n\nstatic void\nmvebu_icu_irq_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t  unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_get_irq_data(virq);\n\tstruct mvebu_icu_irq_data *icu_irqd = d->chip_data;\n\n\tkfree(icu_irqd);\n\n\tplatform_msi_device_domain_free(domain, virq, nr_irqs);\n}\n\nstatic const struct irq_domain_ops mvebu_icu_domain_ops = {\n\t.translate = mvebu_icu_irq_domain_translate,\n\t.alloc     = mvebu_icu_irq_domain_alloc,\n\t.free      = mvebu_icu_irq_domain_free,\n};\n\nstatic const struct mvebu_icu_subset_data mvebu_icu_nsr_subset_data = {\n\t.icu_group = ICU_GRP_NSR,\n\t.offset_set_ah = ICU_SETSPI_NSR_AH,\n\t.offset_set_al = ICU_SETSPI_NSR_AL,\n\t.offset_clr_ah = ICU_CLRSPI_NSR_AH,\n\t.offset_clr_al = ICU_CLRSPI_NSR_AL,\n};\n\nstatic const struct mvebu_icu_subset_data mvebu_icu_sei_subset_data = {\n\t.icu_group = ICU_GRP_SEI,\n\t.offset_set_ah = ICU_SET_SEI_AH,\n\t.offset_set_al = ICU_SET_SEI_AL,\n};\n\nstatic const struct of_device_id mvebu_icu_subset_of_match[] = {\n\t{\n\t\t.compatible = \"marvell,cp110-icu-nsr\",\n\t\t.data = &mvebu_icu_nsr_subset_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,cp110-icu-sei\",\n\t\t.data = &mvebu_icu_sei_subset_data,\n\t},\n\t{},\n};\n\nstatic int mvebu_icu_subset_probe(struct platform_device *pdev)\n{\n\tstruct mvebu_icu_msi_data *msi_data;\n\tstruct device_node *msi_parent_dn;\n\tstruct device *dev = &pdev->dev;\n\tstruct irq_domain *irq_domain;\n\n\tmsi_data = devm_kzalloc(dev, sizeof(*msi_data), GFP_KERNEL);\n\tif (!msi_data)\n\t\treturn -ENOMEM;\n\n\tif (static_branch_unlikely(&legacy_bindings)) {\n\t\tmsi_data->icu = dev_get_drvdata(dev);\n\t\tmsi_data->subset_data = &mvebu_icu_nsr_subset_data;\n\t} else {\n\t\tmsi_data->icu = dev_get_drvdata(dev->parent);\n\t\tmsi_data->subset_data = of_device_get_match_data(dev);\n\t}\n\n\tdev->msi.domain = of_msi_get_domain(dev, dev->of_node,\n\t\t\t\t\t    DOMAIN_BUS_PLATFORM_MSI);\n\tif (!dev->msi.domain)\n\t\treturn -EPROBE_DEFER;\n\n\tmsi_parent_dn = irq_domain_get_of_node(dev->msi.domain);\n\tif (!msi_parent_dn)\n\t\treturn -ENODEV;\n\n\tirq_domain = platform_msi_create_device_tree_domain(dev, ICU_MAX_IRQS,\n\t\t\t\t\t\t\t    mvebu_icu_write_msg,\n\t\t\t\t\t\t\t    &mvebu_icu_domain_ops,\n\t\t\t\t\t\t\t    msi_data);\n\tif (!irq_domain) {\n\t\tdev_err(dev, \"Failed to create ICU MSI domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver mvebu_icu_subset_driver = {\n\t.probe  = mvebu_icu_subset_probe,\n\t.driver = {\n\t\t.name = \"mvebu-icu-subset\",\n\t\t.of_match_table = mvebu_icu_subset_of_match,\n\t},\n};\nbuiltin_platform_driver(mvebu_icu_subset_driver);\n\nstatic int mvebu_icu_probe(struct platform_device *pdev)\n{\n\tstruct mvebu_icu *icu;\n\tint i;\n\n\ticu = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_icu),\n\t\t\t   GFP_KERNEL);\n\tif (!icu)\n\t\treturn -ENOMEM;\n\n\ticu->dev = &pdev->dev;\n\n\ticu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(icu->base))\n\t\treturn PTR_ERR(icu->base);\n\n\t \n\tif (!of_get_child_count(pdev->dev.of_node))\n\t\tstatic_branch_enable(&legacy_bindings);\n\n\t \n\tfor (i = 0 ; i < ICU_MAX_IRQS ; i++) {\n\t\tu32 icu_int, icu_grp;\n\n\t\ticu_int = readl_relaxed(icu->base + ICU_INT_CFG(i));\n\t\ticu_grp = icu_int >> ICU_GROUP_SHIFT;\n\n\t\tif (icu_grp == ICU_GRP_NSR ||\n\t\t    (icu_grp == ICU_GRP_SEI &&\n\t\t     !static_branch_unlikely(&legacy_bindings)))\n\t\t\twritel_relaxed(0x0, icu->base + ICU_INT_CFG(i));\n\t}\n\n\tplatform_set_drvdata(pdev, icu);\n\n\tif (static_branch_unlikely(&legacy_bindings))\n\t\treturn mvebu_icu_subset_probe(pdev);\n\telse\n\t\treturn devm_of_platform_populate(&pdev->dev);\n}\n\nstatic const struct of_device_id mvebu_icu_of_match[] = {\n\t{ .compatible = \"marvell,cp110-icu\", },\n\t{},\n};\n\nstatic struct platform_driver mvebu_icu_driver = {\n\t.probe  = mvebu_icu_probe,\n\t.driver = {\n\t\t.name = \"mvebu-icu\",\n\t\t.of_match_table = mvebu_icu_of_match,\n\t},\n};\nbuiltin_platform_driver(mvebu_icu_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}