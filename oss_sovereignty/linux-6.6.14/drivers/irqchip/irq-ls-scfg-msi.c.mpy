{
  "module_name": "irq-ls-scfg-msi.c",
  "hash_id": "6ed65e843c1a40129835e84dcf973c8c8507d3a4378f0113e39e8df8321b8e10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-ls-scfg-msi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/interrupt.h>\n#include <linux/iommu.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of_irq.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n#include <linux/spinlock.h>\n\n#define MSI_IRQS_PER_MSIR\t32\n#define MSI_MSIR_OFFSET\t\t4\n\n#define MSI_LS1043V1_1_IRQS_PER_MSIR\t8\n#define MSI_LS1043V1_1_MSIR_OFFSET\t0x10\n\nstruct ls_scfg_msi_cfg {\n\tu32 ibs_shift;  \n\tu32 msir_irqs;  \n\tu32 msir_base;  \n};\n\nstruct ls_scfg_msir {\n\tstruct ls_scfg_msi *msi_data;\n\tunsigned int index;\n\tunsigned int gic_irq;\n\tunsigned int bit_start;\n\tunsigned int bit_end;\n\tunsigned int srs;  \n\tvoid __iomem *reg;\n};\n\nstruct ls_scfg_msi {\n\tspinlock_t\t\tlock;\n\tstruct platform_device\t*pdev;\n\tstruct irq_domain\t*parent;\n\tstruct irq_domain\t*msi_domain;\n\tvoid __iomem\t\t*regs;\n\tphys_addr_t\t\tmsiir_addr;\n\tstruct ls_scfg_msi_cfg\t*cfg;\n\tu32\t\t\tmsir_num;\n\tstruct ls_scfg_msir\t*msir;\n\tu32\t\t\tirqs_num;\n\tunsigned long\t\t*used;\n};\n\nstatic struct irq_chip ls_scfg_msi_irq_chip = {\n\t.name = \"MSI\",\n\t.irq_mask\t= pci_msi_mask_irq,\n\t.irq_unmask\t= pci_msi_unmask_irq,\n};\n\nstatic struct msi_domain_info ls_scfg_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS |\n\t\t   MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_PCI_MSIX),\n\t.chip\t= &ls_scfg_msi_irq_chip,\n};\n\nstatic int msi_affinity_flag = 1;\n\nstatic int __init early_parse_ls_scfg_msi(char *p)\n{\n\tif (p && strncmp(p, \"no-affinity\", 11) == 0)\n\t\tmsi_affinity_flag = 0;\n\telse\n\t\tmsi_affinity_flag = 1;\n\n\treturn 0;\n}\nearly_param(\"lsmsi\", early_parse_ls_scfg_msi);\n\nstatic void ls_scfg_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct ls_scfg_msi *msi_data = irq_data_get_irq_chip_data(data);\n\n\tmsg->address_hi = upper_32_bits(msi_data->msiir_addr);\n\tmsg->address_lo = lower_32_bits(msi_data->msiir_addr);\n\tmsg->data = data->hwirq;\n\n\tif (msi_affinity_flag) {\n\t\tconst struct cpumask *mask;\n\n\t\tmask = irq_data_get_effective_affinity_mask(data);\n\t\tmsg->data |= cpumask_first(mask);\n\t}\n\n\tiommu_dma_compose_msi_msg(irq_data_get_msi_desc(data), msg);\n}\n\nstatic int ls_scfg_msi_set_affinity(struct irq_data *irq_data,\n\t\t\t\t    const struct cpumask *mask, bool force)\n{\n\tstruct ls_scfg_msi *msi_data = irq_data_get_irq_chip_data(irq_data);\n\tu32 cpu;\n\n\tif (!msi_affinity_flag)\n\t\treturn -EINVAL;\n\n\tif (!force)\n\t\tcpu = cpumask_any_and(mask, cpu_online_mask);\n\telse\n\t\tcpu = cpumask_first(mask);\n\n\tif (cpu >= msi_data->msir_num)\n\t\treturn -EINVAL;\n\n\tif (msi_data->msir[cpu].gic_irq <= 0) {\n\t\tpr_warn(\"cannot bind the irq to cpu%d\\n\", cpu);\n\t\treturn -EINVAL;\n\t}\n\n\tirq_data_update_effective_affinity(irq_data, cpumask_of(cpu));\n\n\treturn IRQ_SET_MASK_OK;\n}\n\nstatic struct irq_chip ls_scfg_msi_parent_chip = {\n\t.name\t\t\t= \"SCFG\",\n\t.irq_compose_msi_msg\t= ls_scfg_msi_compose_msg,\n\t.irq_set_affinity\t= ls_scfg_msi_set_affinity,\n};\n\nstatic int ls_scfg_msi_domain_irq_alloc(struct irq_domain *domain,\n\t\t\t\t\tunsigned int virq,\n\t\t\t\t\tunsigned int nr_irqs,\n\t\t\t\t\tvoid *args)\n{\n\tmsi_alloc_info_t *info = args;\n\tstruct ls_scfg_msi *msi_data = domain->host_data;\n\tint pos, err = 0;\n\n\tWARN_ON(nr_irqs != 1);\n\n\tspin_lock(&msi_data->lock);\n\tpos = find_first_zero_bit(msi_data->used, msi_data->irqs_num);\n\tif (pos < msi_data->irqs_num)\n\t\t__set_bit(pos, msi_data->used);\n\telse\n\t\terr = -ENOSPC;\n\tspin_unlock(&msi_data->lock);\n\n\tif (err)\n\t\treturn err;\n\n\terr = iommu_dma_prepare_msi(info->desc, msi_data->msiir_addr);\n\tif (err)\n\t\treturn err;\n\n\tirq_domain_set_info(domain, virq, pos,\n\t\t\t    &ls_scfg_msi_parent_chip, msi_data,\n\t\t\t    handle_simple_irq, NULL, NULL);\n\n\treturn 0;\n}\n\nstatic void ls_scfg_msi_domain_irq_free(struct irq_domain *domain,\n\t\t\t\t   unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct ls_scfg_msi *msi_data = irq_data_get_irq_chip_data(d);\n\tint pos;\n\n\tpos = d->hwirq;\n\tif (pos < 0 || pos >= msi_data->irqs_num) {\n\t\tpr_err(\"failed to teardown msi. Invalid hwirq %d\\n\", pos);\n\t\treturn;\n\t}\n\n\tspin_lock(&msi_data->lock);\n\t__clear_bit(pos, msi_data->used);\n\tspin_unlock(&msi_data->lock);\n}\n\nstatic const struct irq_domain_ops ls_scfg_msi_domain_ops = {\n\t.alloc\t= ls_scfg_msi_domain_irq_alloc,\n\t.free\t= ls_scfg_msi_domain_irq_free,\n};\n\nstatic void ls_scfg_msi_irq_handler(struct irq_desc *desc)\n{\n\tstruct ls_scfg_msir *msir = irq_desc_get_handler_data(desc);\n\tstruct ls_scfg_msi *msi_data = msir->msi_data;\n\tunsigned long val;\n\tint pos, size, hwirq;\n\n\tchained_irq_enter(irq_desc_get_chip(desc), desc);\n\n\tval = ioread32be(msir->reg);\n\n\tpos = msir->bit_start;\n\tsize = msir->bit_end + 1;\n\n\tfor_each_set_bit_from(pos, &val, size) {\n\t\thwirq = ((msir->bit_end - pos) << msi_data->cfg->ibs_shift) |\n\t\t\tmsir->srs;\n\t\tgeneric_handle_domain_irq(msi_data->parent, hwirq);\n\t}\n\n\tchained_irq_exit(irq_desc_get_chip(desc), desc);\n}\n\nstatic int ls_scfg_msi_domains_init(struct ls_scfg_msi *msi_data)\n{\n\t \n\tmsi_data->parent = irq_domain_add_linear(NULL,\n\t\t\t\t\t\t msi_data->irqs_num,\n\t\t\t\t\t\t &ls_scfg_msi_domain_ops,\n\t\t\t\t\t\t msi_data);\n\tif (!msi_data->parent) {\n\t\tdev_err(&msi_data->pdev->dev, \"failed to create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmsi_data->msi_domain = pci_msi_create_irq_domain(\n\t\t\t\tof_node_to_fwnode(msi_data->pdev->dev.of_node),\n\t\t\t\t&ls_scfg_msi_domain_info,\n\t\t\t\tmsi_data->parent);\n\tif (!msi_data->msi_domain) {\n\t\tdev_err(&msi_data->pdev->dev, \"failed to create MSI domain\\n\");\n\t\tirq_domain_remove(msi_data->parent);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int ls_scfg_msi_setup_hwirq(struct ls_scfg_msi *msi_data, int index)\n{\n\tstruct ls_scfg_msir *msir;\n\tint virq, i, hwirq;\n\n\tvirq = platform_get_irq(msi_data->pdev, index);\n\tif (virq <= 0)\n\t\treturn -ENODEV;\n\n\tmsir = &msi_data->msir[index];\n\tmsir->index = index;\n\tmsir->msi_data = msi_data;\n\tmsir->gic_irq = virq;\n\tmsir->reg = msi_data->regs + msi_data->cfg->msir_base + 4 * index;\n\n\tif (msi_data->cfg->msir_irqs == MSI_LS1043V1_1_IRQS_PER_MSIR) {\n\t\tmsir->bit_start = 32 - ((msir->index + 1) *\n\t\t\t\t  MSI_LS1043V1_1_IRQS_PER_MSIR);\n\t\tmsir->bit_end = msir->bit_start +\n\t\t\t\tMSI_LS1043V1_1_IRQS_PER_MSIR - 1;\n\t} else {\n\t\tmsir->bit_start = 0;\n\t\tmsir->bit_end = msi_data->cfg->msir_irqs - 1;\n\t}\n\n\tirq_set_chained_handler_and_data(msir->gic_irq,\n\t\t\t\t\t ls_scfg_msi_irq_handler,\n\t\t\t\t\t msir);\n\n\tif (msi_affinity_flag) {\n\t\t \n\t\tirq_set_affinity(msir->gic_irq, get_cpu_mask(index));\n\t\tmsir->srs = 0;  \n\t} else\n\t\tmsir->srs = index;\n\n\t \n\tif (!msi_affinity_flag || msir->index == 0) {\n\t\tfor (i = 0; i < msi_data->cfg->msir_irqs; i++) {\n\t\t\thwirq = i << msi_data->cfg->ibs_shift | msir->index;\n\t\t\tbitmap_clear(msi_data->used, hwirq, 1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ls_scfg_msi_teardown_hwirq(struct ls_scfg_msir *msir)\n{\n\tstruct ls_scfg_msi *msi_data = msir->msi_data;\n\tint i, hwirq;\n\n\tif (msir->gic_irq > 0)\n\t\tirq_set_chained_handler_and_data(msir->gic_irq, NULL, NULL);\n\n\tfor (i = 0; i < msi_data->cfg->msir_irqs; i++) {\n\t\thwirq = i << msi_data->cfg->ibs_shift | msir->index;\n\t\tbitmap_set(msi_data->used, hwirq, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic struct ls_scfg_msi_cfg ls1021_msi_cfg = {\n\t.ibs_shift = 3,\n\t.msir_irqs = MSI_IRQS_PER_MSIR,\n\t.msir_base = MSI_MSIR_OFFSET,\n};\n\nstatic struct ls_scfg_msi_cfg ls1046_msi_cfg = {\n\t.ibs_shift = 2,\n\t.msir_irqs = MSI_IRQS_PER_MSIR,\n\t.msir_base = MSI_MSIR_OFFSET,\n};\n\nstatic struct ls_scfg_msi_cfg ls1043_v1_1_msi_cfg = {\n\t.ibs_shift = 2,\n\t.msir_irqs = MSI_LS1043V1_1_IRQS_PER_MSIR,\n\t.msir_base = MSI_LS1043V1_1_MSIR_OFFSET,\n};\n\nstatic const struct of_device_id ls_scfg_msi_id[] = {\n\t \n\t{ .compatible = \"fsl,1s1021a-msi\", .data = &ls1021_msi_cfg},\n\t{ .compatible = \"fsl,1s1043a-msi\", .data = &ls1021_msi_cfg},\n\n\t{ .compatible = \"fsl,ls1012a-msi\", .data = &ls1021_msi_cfg },\n\t{ .compatible = \"fsl,ls1021a-msi\", .data = &ls1021_msi_cfg },\n\t{ .compatible = \"fsl,ls1043a-msi\", .data = &ls1021_msi_cfg },\n\t{ .compatible = \"fsl,ls1043a-v1.1-msi\", .data = &ls1043_v1_1_msi_cfg },\n\t{ .compatible = \"fsl,ls1046a-msi\", .data = &ls1046_msi_cfg },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ls_scfg_msi_id);\n\nstatic int ls_scfg_msi_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct ls_scfg_msi *msi_data;\n\tstruct resource *res;\n\tint i, ret;\n\n\tmatch = of_match_device(ls_scfg_msi_id, &pdev->dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tmsi_data = devm_kzalloc(&pdev->dev, sizeof(*msi_data), GFP_KERNEL);\n\tif (!msi_data)\n\t\treturn -ENOMEM;\n\n\tmsi_data->cfg = (struct ls_scfg_msi_cfg *) match->data;\n\n\tmsi_data->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(msi_data->regs)) {\n\t\tdev_err(&pdev->dev, \"failed to initialize 'regs'\\n\");\n\t\treturn PTR_ERR(msi_data->regs);\n\t}\n\tmsi_data->msiir_addr = res->start;\n\n\tmsi_data->pdev = pdev;\n\tspin_lock_init(&msi_data->lock);\n\n\tmsi_data->irqs_num = MSI_IRQS_PER_MSIR *\n\t\t\t     (1 << msi_data->cfg->ibs_shift);\n\tmsi_data->used = devm_bitmap_zalloc(&pdev->dev, msi_data->irqs_num, GFP_KERNEL);\n\tif (!msi_data->used)\n\t\treturn -ENOMEM;\n\t \n\tbitmap_set(msi_data->used, 0, msi_data->irqs_num);\n\n\tmsi_data->msir_num = of_irq_count(pdev->dev.of_node);\n\n\tif (msi_affinity_flag) {\n\t\tu32 cpu_num;\n\n\t\tcpu_num = num_possible_cpus();\n\t\tif (msi_data->msir_num >= cpu_num)\n\t\t\tmsi_data->msir_num = cpu_num;\n\t\telse\n\t\t\tmsi_affinity_flag = 0;\n\t}\n\n\tmsi_data->msir = devm_kcalloc(&pdev->dev, msi_data->msir_num,\n\t\t\t\t      sizeof(*msi_data->msir),\n\t\t\t\t      GFP_KERNEL);\n\tif (!msi_data->msir)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < msi_data->msir_num; i++)\n\t\tls_scfg_msi_setup_hwirq(msi_data, i);\n\n\tret = ls_scfg_msi_domains_init(msi_data);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, msi_data);\n\n\treturn 0;\n}\n\nstatic int ls_scfg_msi_remove(struct platform_device *pdev)\n{\n\tstruct ls_scfg_msi *msi_data = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < msi_data->msir_num; i++)\n\t\tls_scfg_msi_teardown_hwirq(&msi_data->msir[i]);\n\n\tirq_domain_remove(msi_data->msi_domain);\n\tirq_domain_remove(msi_data->parent);\n\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn 0;\n}\n\nstatic struct platform_driver ls_scfg_msi_driver = {\n\t.driver = {\n\t\t.name = \"ls-scfg-msi\",\n\t\t.of_match_table = ls_scfg_msi_id,\n\t},\n\t.probe = ls_scfg_msi_probe,\n\t.remove = ls_scfg_msi_remove,\n};\n\nmodule_platform_driver(ls_scfg_msi_driver);\n\nMODULE_AUTHOR(\"Minghuan Lian <Minghuan.Lian@nxp.com>\");\nMODULE_DESCRIPTION(\"Freescale Layerscape SCFG MSI controller driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}