{
  "module_name": "irq-ingenic-tcu.c",
  "hash_id": "43ea3c7d4dabef8f79a2e445d789de74dc26a59cc5f14b022e68c390aa781e05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-ingenic-tcu.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/mfd/ingenic-tcu.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of_irq.h>\n#include <linux/regmap.h>\n\nstruct ingenic_tcu {\n\tstruct regmap *map;\n\tstruct clk *clk;\n\tstruct irq_domain *domain;\n\tunsigned int nb_parent_irqs;\n\tu32 parent_irqs[3];\n};\n\nstatic void ingenic_tcu_intc_cascade(struct irq_desc *desc)\n{\n\tstruct irq_chip *irq_chip = irq_data_get_irq_chip(&desc->irq_data);\n\tstruct irq_domain *domain = irq_desc_get_handler_data(desc);\n\tstruct irq_chip_generic *gc = irq_get_domain_generic_chip(domain, 0);\n\tstruct regmap *map = gc->private;\n\tuint32_t irq_reg, irq_mask;\n\tunsigned long bits;\n\tunsigned int i;\n\n\tregmap_read(map, TCU_REG_TFR, &irq_reg);\n\tregmap_read(map, TCU_REG_TMR, &irq_mask);\n\n\tchained_irq_enter(irq_chip, desc);\n\n\tirq_reg &= ~irq_mask;\n\tbits = irq_reg;\n\n\tfor_each_set_bit(i, &bits, 32)\n\t\tgeneric_handle_domain_irq(domain, i);\n\n\tchained_irq_exit(irq_chip, desc);\n}\n\nstatic void ingenic_tcu_gc_unmask_enable_reg(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tstruct regmap *map = gc->private;\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tregmap_write(map, ct->regs.ack, mask);\n\tregmap_write(map, ct->regs.enable, mask);\n\t*ct->mask_cache |= mask;\n\tirq_gc_unlock(gc);\n}\n\nstatic void ingenic_tcu_gc_mask_disable_reg(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tstruct regmap *map = gc->private;\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tregmap_write(map, ct->regs.disable, mask);\n\t*ct->mask_cache &= ~mask;\n\tirq_gc_unlock(gc);\n}\n\nstatic void ingenic_tcu_gc_mask_disable_reg_and_ack(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tstruct regmap *map = gc->private;\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tregmap_write(map, ct->regs.ack, mask);\n\tregmap_write(map, ct->regs.disable, mask);\n\tirq_gc_unlock(gc);\n}\n\nstatic int __init ingenic_tcu_irq_init(struct device_node *np,\n\t\t\t\t       struct device_node *parent)\n{\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\tstruct ingenic_tcu *tcu;\n\tstruct regmap *map;\n\tunsigned int i;\n\tint ret, irqs;\n\n\tmap = device_node_to_regmap(np);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\ttcu = kzalloc(sizeof(*tcu), GFP_KERNEL);\n\tif (!tcu)\n\t\treturn -ENOMEM;\n\n\ttcu->map = map;\n\n\tirqs = of_property_count_elems_of_size(np, \"interrupts\", sizeof(u32));\n\tif (irqs < 0 || irqs > ARRAY_SIZE(tcu->parent_irqs)) {\n\t\tpr_crit(\"%s: Invalid 'interrupts' property\\n\", __func__);\n\t\tret = -EINVAL;\n\t\tgoto err_free_tcu;\n\t}\n\n\ttcu->nb_parent_irqs = irqs;\n\n\ttcu->domain = irq_domain_add_linear(np, 32, &irq_generic_chip_ops,\n\t\t\t\t\t    NULL);\n\tif (!tcu->domain) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_tcu;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(tcu->domain, 32, 1, \"TCU\",\n\t\t\t\t\t     handle_level_irq, 0,\n\t\t\t\t\t     IRQ_NOPROBE | IRQ_LEVEL, 0);\n\tif (ret) {\n\t\tpr_crit(\"%s: Invalid 'interrupts' property\\n\", __func__);\n\t\tgoto out_domain_remove;\n\t}\n\n\tgc = irq_get_domain_generic_chip(tcu->domain, 0);\n\tct = gc->chip_types;\n\n\tgc->wake_enabled = IRQ_MSK(32);\n\tgc->private = tcu->map;\n\n\tct->regs.disable = TCU_REG_TMSR;\n\tct->regs.enable = TCU_REG_TMCR;\n\tct->regs.ack = TCU_REG_TFCR;\n\tct->chip.irq_unmask = ingenic_tcu_gc_unmask_enable_reg;\n\tct->chip.irq_mask = ingenic_tcu_gc_mask_disable_reg;\n\tct->chip.irq_mask_ack = ingenic_tcu_gc_mask_disable_reg_and_ack;\n\tct->chip.flags = IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_SKIP_SET_WAKE;\n\n\t \n\tregmap_write(tcu->map, TCU_REG_TMSR, IRQ_MSK(32));\n\n\t \n\tfor (i = 0; i < irqs; i++) {\n\t\ttcu->parent_irqs[i] = irq_of_parse_and_map(np, i);\n\t\tif (!tcu->parent_irqs[i]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unmap_irqs;\n\t\t}\n\n\t\tirq_set_chained_handler_and_data(tcu->parent_irqs[i],\n\t\t\t\t\t\t ingenic_tcu_intc_cascade,\n\t\t\t\t\t\t tcu->domain);\n\t}\n\n\treturn 0;\n\nout_unmap_irqs:\n\tfor (; i > 0; i--)\n\t\tirq_dispose_mapping(tcu->parent_irqs[i - 1]);\nout_domain_remove:\n\tirq_domain_remove(tcu->domain);\nerr_free_tcu:\n\tkfree(tcu);\n\treturn ret;\n}\nIRQCHIP_DECLARE(jz4740_tcu_irq, \"ingenic,jz4740-tcu\", ingenic_tcu_irq_init);\nIRQCHIP_DECLARE(jz4725b_tcu_irq, \"ingenic,jz4725b-tcu\", ingenic_tcu_irq_init);\nIRQCHIP_DECLARE(jz4760_tcu_irq, \"ingenic,jz4760-tcu\", ingenic_tcu_irq_init);\nIRQCHIP_DECLARE(jz4770_tcu_irq, \"ingenic,jz4770-tcu\", ingenic_tcu_irq_init);\nIRQCHIP_DECLARE(x1000_tcu_irq, \"ingenic,x1000-tcu\", ingenic_tcu_irq_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}