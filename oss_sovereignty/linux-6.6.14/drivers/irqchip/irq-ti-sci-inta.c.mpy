{
  "module_name": "irq-ti-sci-inta.c",
  "hash_id": "ab7a534555091d2d7bd0dee3057935a87359c2f7d6ad88d3e2d43a1ee3e7847a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-ti-sci-inta.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/msi.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/soc/ti/ti_sci_inta_msi.h>\n#include <linux/soc/ti/ti_sci_protocol.h>\n#include <asm-generic/msi.h>\n\n#define TI_SCI_DEV_ID_MASK\t0xffff\n#define TI_SCI_DEV_ID_SHIFT\t16\n#define TI_SCI_IRQ_ID_MASK\t0xffff\n#define TI_SCI_IRQ_ID_SHIFT\t0\n#define HWIRQ_TO_DEVID(hwirq)\t(((hwirq) >> (TI_SCI_DEV_ID_SHIFT)) & \\\n\t\t\t\t (TI_SCI_DEV_ID_MASK))\n#define HWIRQ_TO_IRQID(hwirq)\t((hwirq) & (TI_SCI_IRQ_ID_MASK))\n#define TO_HWIRQ(dev, index)\t((((dev) & TI_SCI_DEV_ID_MASK) << \\\n\t\t\t\t TI_SCI_DEV_ID_SHIFT) | \\\n\t\t\t\t((index) & TI_SCI_IRQ_ID_MASK))\n\n#define MAX_EVENTS_PER_VINT\t64\n#define VINT_ENABLE_SET_OFFSET\t0x0\n#define VINT_ENABLE_CLR_OFFSET\t0x8\n#define VINT_STATUS_OFFSET\t0x18\n#define VINT_STATUS_MASKED_OFFSET\t0x20\n\n \nstruct ti_sci_inta_event_desc {\n\tu16 global_event;\n\tu32 hwirq;\n\tu8 vint_bit;\n};\n\n \nstruct ti_sci_inta_vint_desc {\n\tstruct irq_domain *domain;\n\tstruct list_head list;\n\tDECLARE_BITMAP(event_map, MAX_EVENTS_PER_VINT);\n\tstruct ti_sci_inta_event_desc events[MAX_EVENTS_PER_VINT];\n\tunsigned int parent_virq;\n\tu16 vint_id;\n};\n\n \nstruct ti_sci_inta_irq_domain {\n\tconst struct ti_sci_handle *sci;\n\tstruct ti_sci_resource *vint;\n\tstruct ti_sci_resource *global_event;\n\tstruct list_head vint_list;\n\t \n\tstruct mutex vint_mutex;\n\tvoid __iomem *base;\n\tstruct platform_device *pdev;\n\tu32 ti_sci_id;\n\n\tint unmapped_cnt;\n\tu16 *unmapped_dev_ids;\n};\n\n#define to_vint_desc(e, i) container_of(e, struct ti_sci_inta_vint_desc, \\\n\t\t\t\t\tevents[i])\n\nstatic u16 ti_sci_inta_get_dev_id(struct ti_sci_inta_irq_domain *inta, u32 hwirq)\n{\n\tu16 dev_id = HWIRQ_TO_DEVID(hwirq);\n\tint i;\n\n\tif (inta->unmapped_cnt == 0)\n\t\treturn dev_id;\n\n\t \n\tfor (i = 0; i < inta->unmapped_cnt; i++) {\n\t\tif (dev_id == inta->unmapped_dev_ids[i]) {\n\t\t\tdev_id = inta->ti_sci_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn dev_id;\n}\n\n \nstatic void ti_sci_inta_irq_handler(struct irq_desc *desc)\n{\n\tstruct ti_sci_inta_vint_desc *vint_desc;\n\tstruct ti_sci_inta_irq_domain *inta;\n\tstruct irq_domain *domain;\n\tunsigned int bit;\n\tunsigned long val;\n\n\tvint_desc = irq_desc_get_handler_data(desc);\n\tdomain = vint_desc->domain;\n\tinta = domain->host_data;\n\n\tchained_irq_enter(irq_desc_get_chip(desc), desc);\n\n\tval = readq_relaxed(inta->base + vint_desc->vint_id * 0x1000 +\n\t\t\t    VINT_STATUS_MASKED_OFFSET);\n\n\tfor_each_set_bit(bit, &val, MAX_EVENTS_PER_VINT)\n\t\tgeneric_handle_domain_irq(domain, vint_desc->events[bit].hwirq);\n\n\tchained_irq_exit(irq_desc_get_chip(desc), desc);\n}\n\n \nstatic int ti_sci_inta_xlate_irq(struct ti_sci_inta_irq_domain *inta,\n\t\t\t\t u16 vint_id)\n{\n\tstruct device_node *np = dev_of_node(&inta->pdev->dev);\n\tu32 base, parent_base, size;\n\tconst __be32 *range;\n\tint len;\n\n\trange = of_get_property(np, \"ti,interrupt-ranges\", &len);\n\tif (!range)\n\t\treturn vint_id;\n\n\tfor (len /= sizeof(*range); len >= 3; len -= 3) {\n\t\tbase = be32_to_cpu(*range++);\n\t\tparent_base = be32_to_cpu(*range++);\n\t\tsize = be32_to_cpu(*range++);\n\n\t\tif (base <= vint_id && vint_id < base + size)\n\t\t\treturn vint_id - base + parent_base;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic struct ti_sci_inta_vint_desc *ti_sci_inta_alloc_parent_irq(struct irq_domain *domain)\n{\n\tstruct ti_sci_inta_irq_domain *inta = domain->host_data;\n\tstruct ti_sci_inta_vint_desc *vint_desc;\n\tstruct irq_fwspec parent_fwspec;\n\tstruct device_node *parent_node;\n\tunsigned int parent_virq;\n\tint p_hwirq, ret;\n\tu16 vint_id;\n\n\tvint_id = ti_sci_get_free_resource(inta->vint);\n\tif (vint_id == TI_SCI_RESOURCE_NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tp_hwirq = ti_sci_inta_xlate_irq(inta, vint_id);\n\tif (p_hwirq < 0) {\n\t\tret = p_hwirq;\n\t\tgoto free_vint;\n\t}\n\n\tvint_desc = kzalloc(sizeof(*vint_desc), GFP_KERNEL);\n\tif (!vint_desc) {\n\t\tret = -ENOMEM;\n\t\tgoto free_vint;\n\t}\n\n\tvint_desc->domain = domain;\n\tvint_desc->vint_id = vint_id;\n\tINIT_LIST_HEAD(&vint_desc->list);\n\n\tparent_node = of_irq_find_parent(dev_of_node(&inta->pdev->dev));\n\tparent_fwspec.fwnode = of_node_to_fwnode(parent_node);\n\n\tif (of_device_is_compatible(parent_node, \"arm,gic-v3\")) {\n\t\t \n\t\tparent_fwspec.param_count = 3;\n\t\tparent_fwspec.param[0] = 0;\n\t\tparent_fwspec.param[1] = p_hwirq - 32;\n\t\tparent_fwspec.param[2] = IRQ_TYPE_LEVEL_HIGH;\n\t} else {\n\t\t \n\t\tparent_fwspec.param_count = 1;\n\t\tparent_fwspec.param[0] = p_hwirq;\n\t}\n\n\tparent_virq = irq_create_fwspec_mapping(&parent_fwspec);\n\tif (parent_virq == 0) {\n\t\tdev_err(&inta->pdev->dev, \"Parent IRQ allocation failed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_vint_desc;\n\n\t}\n\tvint_desc->parent_virq = parent_virq;\n\n\tlist_add_tail(&vint_desc->list, &inta->vint_list);\n\tirq_set_chained_handler_and_data(vint_desc->parent_virq,\n\t\t\t\t\t ti_sci_inta_irq_handler, vint_desc);\n\n\treturn vint_desc;\nfree_vint_desc:\n\tkfree(vint_desc);\nfree_vint:\n\tti_sci_release_resource(inta->vint, vint_id);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic struct ti_sci_inta_event_desc *ti_sci_inta_alloc_event(struct ti_sci_inta_vint_desc *vint_desc,\n\t\t\t\t\t\t\t      u16 free_bit,\n\t\t\t\t\t\t\t      u32 hwirq)\n{\n\tstruct ti_sci_inta_irq_domain *inta = vint_desc->domain->host_data;\n\tstruct ti_sci_inta_event_desc *event_desc;\n\tu16 dev_id, dev_index;\n\tint err;\n\n\tdev_id = ti_sci_inta_get_dev_id(inta, hwirq);\n\tdev_index = HWIRQ_TO_IRQID(hwirq);\n\n\tevent_desc = &vint_desc->events[free_bit];\n\tevent_desc->hwirq = hwirq;\n\tevent_desc->vint_bit = free_bit;\n\tevent_desc->global_event = ti_sci_get_free_resource(inta->global_event);\n\tif (event_desc->global_event == TI_SCI_RESOURCE_NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terr = inta->sci->ops.rm_irq_ops.set_event_map(inta->sci,\n\t\t\t\t\t\t      dev_id, dev_index,\n\t\t\t\t\t\t      inta->ti_sci_id,\n\t\t\t\t\t\t      vint_desc->vint_id,\n\t\t\t\t\t\t      event_desc->global_event,\n\t\t\t\t\t\t      free_bit);\n\tif (err)\n\t\tgoto free_global_event;\n\n\treturn event_desc;\nfree_global_event:\n\tti_sci_release_resource(inta->global_event, event_desc->global_event);\n\treturn ERR_PTR(err);\n}\n\n \nstatic struct ti_sci_inta_event_desc *ti_sci_inta_alloc_irq(struct irq_domain *domain,\n\t\t\t\t\t\t\t    u32 hwirq)\n{\n\tstruct ti_sci_inta_irq_domain *inta = domain->host_data;\n\tstruct ti_sci_inta_vint_desc *vint_desc = NULL;\n\tstruct ti_sci_inta_event_desc *event_desc;\n\tu16 free_bit;\n\n\tmutex_lock(&inta->vint_mutex);\n\tlist_for_each_entry(vint_desc, &inta->vint_list, list) {\n\t\tfree_bit = find_first_zero_bit(vint_desc->event_map,\n\t\t\t\t\t       MAX_EVENTS_PER_VINT);\n\t\tif (free_bit != MAX_EVENTS_PER_VINT) {\n\t\t\tset_bit(free_bit, vint_desc->event_map);\n\t\t\tgoto alloc_event;\n\t\t}\n\t}\n\n\t \n\tvint_desc = ti_sci_inta_alloc_parent_irq(domain);\n\tif (IS_ERR(vint_desc)) {\n\t\tevent_desc = ERR_CAST(vint_desc);\n\t\tgoto unlock;\n\t}\n\n\tfree_bit = find_first_zero_bit(vint_desc->event_map,\n\t\t\t\t       MAX_EVENTS_PER_VINT);\n\tset_bit(free_bit, vint_desc->event_map);\n\nalloc_event:\n\tevent_desc = ti_sci_inta_alloc_event(vint_desc, free_bit, hwirq);\n\tif (IS_ERR(event_desc))\n\t\tclear_bit(free_bit, vint_desc->event_map);\n\nunlock:\n\tmutex_unlock(&inta->vint_mutex);\n\treturn event_desc;\n}\n\n \nstatic void ti_sci_inta_free_parent_irq(struct ti_sci_inta_irq_domain *inta,\n\t\t\t\t\tstruct ti_sci_inta_vint_desc *vint_desc)\n{\n\tif (find_first_bit(vint_desc->event_map, MAX_EVENTS_PER_VINT) == MAX_EVENTS_PER_VINT) {\n\t\tlist_del(&vint_desc->list);\n\t\tti_sci_release_resource(inta->vint, vint_desc->vint_id);\n\t\tirq_dispose_mapping(vint_desc->parent_virq);\n\t\tkfree(vint_desc);\n\t}\n}\n\n \nstatic void ti_sci_inta_free_irq(struct ti_sci_inta_event_desc *event_desc,\n\t\t\t\t u32 hwirq)\n{\n\tstruct ti_sci_inta_vint_desc *vint_desc;\n\tstruct ti_sci_inta_irq_domain *inta;\n\tu16 dev_id;\n\n\tvint_desc = to_vint_desc(event_desc, event_desc->vint_bit);\n\tinta = vint_desc->domain->host_data;\n\tdev_id = ti_sci_inta_get_dev_id(inta, hwirq);\n\t \n\tmutex_lock(&inta->vint_mutex);\n\tinta->sci->ops.rm_irq_ops.free_event_map(inta->sci,\n\t\t\t\t\t\t dev_id, HWIRQ_TO_IRQID(hwirq),\n\t\t\t\t\t\t inta->ti_sci_id,\n\t\t\t\t\t\t vint_desc->vint_id,\n\t\t\t\t\t\t event_desc->global_event,\n\t\t\t\t\t\t event_desc->vint_bit);\n\n\tclear_bit(event_desc->vint_bit, vint_desc->event_map);\n\tti_sci_release_resource(inta->global_event, event_desc->global_event);\n\tevent_desc->global_event = TI_SCI_RESOURCE_NULL;\n\tevent_desc->hwirq = 0;\n\n\tti_sci_inta_free_parent_irq(inta, vint_desc);\n\tmutex_unlock(&inta->vint_mutex);\n}\n\n \nstatic int ti_sci_inta_request_resources(struct irq_data *data)\n{\n\tstruct ti_sci_inta_event_desc *event_desc;\n\n\tevent_desc = ti_sci_inta_alloc_irq(data->domain, data->hwirq);\n\tif (IS_ERR(event_desc))\n\t\treturn PTR_ERR(event_desc);\n\n\tdata->chip_data = event_desc;\n\n\treturn 0;\n}\n\n \nstatic void ti_sci_inta_release_resources(struct irq_data *data)\n{\n\tstruct ti_sci_inta_event_desc *event_desc;\n\n\tevent_desc = irq_data_get_irq_chip_data(data);\n\tti_sci_inta_free_irq(event_desc, data->hwirq);\n}\n\n \nstatic void ti_sci_inta_manage_event(struct irq_data *data, u32 offset)\n{\n\tstruct ti_sci_inta_event_desc *event_desc;\n\tstruct ti_sci_inta_vint_desc *vint_desc;\n\tstruct ti_sci_inta_irq_domain *inta;\n\n\tevent_desc = irq_data_get_irq_chip_data(data);\n\tvint_desc = to_vint_desc(event_desc, event_desc->vint_bit);\n\tinta = data->domain->host_data;\n\n\twriteq_relaxed(BIT(event_desc->vint_bit),\n\t\t       inta->base + vint_desc->vint_id * 0x1000 + offset);\n}\n\n \nstatic void ti_sci_inta_mask_irq(struct irq_data *data)\n{\n\tti_sci_inta_manage_event(data, VINT_ENABLE_CLR_OFFSET);\n}\n\n \nstatic void ti_sci_inta_unmask_irq(struct irq_data *data)\n{\n\tti_sci_inta_manage_event(data, VINT_ENABLE_SET_OFFSET);\n}\n\n \nstatic void ti_sci_inta_ack_irq(struct irq_data *data)\n{\n\t \n\tif (irqd_get_trigger_type(data) != IRQF_TRIGGER_HIGH)\n\t\tti_sci_inta_manage_event(data, VINT_STATUS_OFFSET);\n}\n\nstatic int ti_sci_inta_set_affinity(struct irq_data *d,\n\t\t\t\t    const struct cpumask *mask_val, bool force)\n{\n\treturn -EINVAL;\n}\n\n \nstatic int ti_sci_inta_set_type(struct irq_data *data, unsigned int type)\n{\n\t \n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQF_TRIGGER_HIGH:\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\t\treturn 0;\n\tcase IRQF_TRIGGER_RISING:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic struct irq_chip ti_sci_inta_irq_chip = {\n\t.name\t\t\t= \"INTA\",\n\t.irq_ack\t\t= ti_sci_inta_ack_irq,\n\t.irq_mask\t\t= ti_sci_inta_mask_irq,\n\t.irq_set_type\t\t= ti_sci_inta_set_type,\n\t.irq_unmask\t\t= ti_sci_inta_unmask_irq,\n\t.irq_set_affinity\t= ti_sci_inta_set_affinity,\n\t.irq_request_resources\t= ti_sci_inta_request_resources,\n\t.irq_release_resources\t= ti_sci_inta_release_resources,\n};\n\n \nstatic void ti_sci_inta_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t\tunsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_domain_get_irq_data(domain, virq);\n\n\tirq_domain_reset_irq_data(data);\n}\n\n \nstatic int ti_sci_inta_irq_domain_alloc(struct irq_domain *domain,\n\t\t\t\t\tunsigned int virq, unsigned int nr_irqs,\n\t\t\t\t\tvoid *data)\n{\n\tmsi_alloc_info_t *arg = data;\n\n\tirq_domain_set_info(domain, virq, arg->hwirq, &ti_sci_inta_irq_chip,\n\t\t\t    NULL, handle_edge_irq, NULL, NULL);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops ti_sci_inta_irq_domain_ops = {\n\t.free\t\t= ti_sci_inta_irq_domain_free,\n\t.alloc\t\t= ti_sci_inta_irq_domain_alloc,\n};\n\nstatic struct irq_chip ti_sci_inta_msi_irq_chip = {\n\t.name\t\t\t= \"MSI-INTA\",\n\t.flags\t\t\t= IRQCHIP_SUPPORTS_LEVEL_MSI,\n};\n\nstatic void ti_sci_inta_msi_set_desc(msi_alloc_info_t *arg,\n\t\t\t\t     struct msi_desc *desc)\n{\n\tstruct platform_device *pdev = to_platform_device(desc->dev);\n\n\targ->desc = desc;\n\targ->hwirq = TO_HWIRQ(pdev->id, desc->msi_index);\n}\n\nstatic struct msi_domain_ops ti_sci_inta_msi_ops = {\n\t.set_desc\t= ti_sci_inta_msi_set_desc,\n};\n\nstatic struct msi_domain_info ti_sci_inta_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_LEVEL_CAPABLE),\n\t.ops\t= &ti_sci_inta_msi_ops,\n\t.chip\t= &ti_sci_inta_msi_irq_chip,\n};\n\nstatic int ti_sci_inta_get_unmapped_sources(struct ti_sci_inta_irq_domain *inta)\n{\n\tstruct device *dev = &inta->pdev->dev;\n\tstruct device_node *node = dev_of_node(dev);\n\tstruct of_phandle_iterator it;\n\tint count, err, ret, i;\n\n\tcount = of_count_phandle_with_args(node, \"ti,unmapped-event-sources\", NULL);\n\tif (count <= 0)\n\t\treturn 0;\n\n\tinta->unmapped_dev_ids = devm_kcalloc(dev, count,\n\t\t\t\t\t      sizeof(*inta->unmapped_dev_ids),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!inta->unmapped_dev_ids)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tof_for_each_phandle(&it, err, node, \"ti,unmapped-event-sources\", NULL, 0) {\n\t\tu32 dev_id;\n\n\t\tret = of_property_read_u32(it.node, \"ti,sci-dev-id\", &dev_id);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"ti,sci-dev-id read failure for %pOFf\\n\", it.node);\n\t\t\tof_node_put(it.node);\n\t\t\treturn ret;\n\t\t}\n\t\tinta->unmapped_dev_ids[i++] = dev_id;\n\t}\n\n\tinta->unmapped_cnt = count;\n\n\treturn 0;\n}\n\nstatic int ti_sci_inta_irq_domain_probe(struct platform_device *pdev)\n{\n\tstruct irq_domain *parent_domain, *domain, *msi_domain;\n\tstruct device_node *parent_node, *node;\n\tstruct ti_sci_inta_irq_domain *inta;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tnode = dev_of_node(dev);\n\tparent_node = of_irq_find_parent(node);\n\tif (!parent_node) {\n\t\tdev_err(dev, \"Failed to get IRQ parent node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tparent_domain = irq_find_host(parent_node);\n\tif (!parent_domain)\n\t\treturn -EPROBE_DEFER;\n\n\tinta = devm_kzalloc(dev, sizeof(*inta), GFP_KERNEL);\n\tif (!inta)\n\t\treturn -ENOMEM;\n\n\tinta->pdev = pdev;\n\tinta->sci = devm_ti_sci_get_by_phandle(dev, \"ti,sci\");\n\tif (IS_ERR(inta->sci))\n\t\treturn dev_err_probe(dev, PTR_ERR(inta->sci),\n\t\t\t\t     \"ti,sci read fail\\n\");\n\n\tret = of_property_read_u32(dev->of_node, \"ti,sci-dev-id\", &inta->ti_sci_id);\n\tif (ret) {\n\t\tdev_err(dev, \"missing 'ti,sci-dev-id' property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinta->vint = devm_ti_sci_get_resource(inta->sci, dev, inta->ti_sci_id,\n\t\t\t\t\t      TI_SCI_RESASG_SUBTYPE_IA_VINT);\n\tif (IS_ERR(inta->vint)) {\n\t\tdev_err(dev, \"VINT resource allocation failed\\n\");\n\t\treturn PTR_ERR(inta->vint);\n\t}\n\n\tinta->global_event = devm_ti_sci_get_resource(inta->sci, dev, inta->ti_sci_id,\n\t\t\t\t\t\t      TI_SCI_RESASG_SUBTYPE_GLOBAL_EVENT_SEVT);\n\tif (IS_ERR(inta->global_event)) {\n\t\tdev_err(dev, \"Global event resource allocation failed\\n\");\n\t\treturn PTR_ERR(inta->global_event);\n\t}\n\n\tinta->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(inta->base))\n\t\treturn PTR_ERR(inta->base);\n\n\tret = ti_sci_inta_get_unmapped_sources(inta);\n\tif (ret)\n\t\treturn ret;\n\n\tdomain = irq_domain_add_linear(dev_of_node(dev),\n\t\t\t\t       ti_sci_get_num_resources(inta->vint),\n\t\t\t\t       &ti_sci_inta_irq_domain_ops, inta);\n\tif (!domain) {\n\t\tdev_err(dev, \"Failed to allocate IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmsi_domain = ti_sci_inta_msi_create_irq_domain(of_node_to_fwnode(node),\n\t\t\t\t\t\t&ti_sci_inta_msi_domain_info,\n\t\t\t\t\t\tdomain);\n\tif (!msi_domain) {\n\t\tirq_domain_remove(domain);\n\t\tdev_err(dev, \"Failed to allocate msi domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&inta->vint_list);\n\tmutex_init(&inta->vint_mutex);\n\n\tdev_info(dev, \"Interrupt Aggregator domain %d created\\n\", inta->ti_sci_id);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ti_sci_inta_irq_domain_of_match[] = {\n\t{ .compatible = \"ti,sci-inta\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ti_sci_inta_irq_domain_of_match);\n\nstatic struct platform_driver ti_sci_inta_irq_domain_driver = {\n\t.probe = ti_sci_inta_irq_domain_probe,\n\t.driver = {\n\t\t.name = \"ti-sci-inta\",\n\t\t.of_match_table = ti_sci_inta_irq_domain_of_match,\n\t},\n};\nmodule_platform_driver(ti_sci_inta_irq_domain_driver);\n\nMODULE_AUTHOR(\"Lokesh Vutla <lokeshvutla@ti.com>\");\nMODULE_DESCRIPTION(\"K3 Interrupt Aggregator driver over TI SCI protocol\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}