{
  "module_name": "irq-mips-cpu.c",
  "hash_id": "294afba73ec1dd23e7a7a6e40d5230ec4193cea074153cf00e4ca6d8b5f28b54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mips-cpu.c",
  "human_readable_source": "\n \n\n \n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n\n#include <asm/irq_cpu.h>\n#include <asm/mipsregs.h>\n#include <asm/mipsmtregs.h>\n#include <asm/setup.h>\n\nstatic struct irq_domain *irq_domain;\nstatic struct irq_domain *ipi_domain;\n\nstatic inline void unmask_mips_irq(struct irq_data *d)\n{\n\tset_c0_status(IE_SW0 << d->hwirq);\n\tirq_enable_hazard();\n}\n\nstatic inline void mask_mips_irq(struct irq_data *d)\n{\n\tclear_c0_status(IE_SW0 << d->hwirq);\n\tirq_disable_hazard();\n}\n\nstatic struct irq_chip mips_cpu_irq_controller = {\n\t.name\t\t= \"MIPS\",\n\t.irq_ack\t= mask_mips_irq,\n\t.irq_mask\t= mask_mips_irq,\n\t.irq_mask_ack\t= mask_mips_irq,\n\t.irq_unmask\t= unmask_mips_irq,\n\t.irq_eoi\t= unmask_mips_irq,\n\t.irq_disable\t= mask_mips_irq,\n\t.irq_enable\t= unmask_mips_irq,\n};\n\n \n\nstatic unsigned int mips_mt_cpu_irq_startup(struct irq_data *d)\n{\n\tunsigned int vpflags = dvpe();\n\n\tclear_c0_cause(C_SW0 << d->hwirq);\n\tevpe(vpflags);\n\tunmask_mips_irq(d);\n\treturn 0;\n}\n\n \nstatic void mips_mt_cpu_irq_ack(struct irq_data *d)\n{\n\tunsigned int vpflags = dvpe();\n\tclear_c0_cause(C_SW0 << d->hwirq);\n\tevpe(vpflags);\n\tmask_mips_irq(d);\n}\n\n#ifdef CONFIG_GENERIC_IRQ_IPI\n\nstatic void mips_mt_send_ipi(struct irq_data *d, unsigned int cpu)\n{\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tint vpflags;\n\n\tlocal_irq_save(flags);\n\n\t \n\tWARN_ON(!cpus_are_siblings(smp_processor_id(), cpu));\n\n\tvpflags = dvpe();\n\tsettc(cpu_vpe_id(&cpu_data[cpu]));\n\twrite_vpe_c0_cause(read_vpe_c0_cause() | (C_SW0 << hwirq));\n\tevpe(vpflags);\n\n\tlocal_irq_restore(flags);\n}\n\n#endif  \n\nstatic struct irq_chip mips_mt_cpu_irq_controller = {\n\t.name\t\t= \"MIPS\",\n\t.irq_startup\t= mips_mt_cpu_irq_startup,\n\t.irq_ack\t= mips_mt_cpu_irq_ack,\n\t.irq_mask\t= mask_mips_irq,\n\t.irq_mask_ack\t= mips_mt_cpu_irq_ack,\n\t.irq_unmask\t= unmask_mips_irq,\n\t.irq_eoi\t= unmask_mips_irq,\n\t.irq_disable\t= mask_mips_irq,\n\t.irq_enable\t= unmask_mips_irq,\n#ifdef CONFIG_GENERIC_IRQ_IPI\n\t.ipi_send_single = mips_mt_send_ipi,\n#endif\n};\n\nasmlinkage void __weak plat_irq_dispatch(void)\n{\n\tunsigned long pending = read_c0_cause() & read_c0_status() & ST0_IM;\n\tint irq;\n\n\tif (!pending) {\n\t\tspurious_interrupt();\n\t\treturn;\n\t}\n\n\tpending >>= CAUSEB_IP;\n\twhile (pending) {\n\t\tstruct irq_domain *d;\n\n\t\tirq = fls(pending) - 1;\n\t\tif (IS_ENABLED(CONFIG_GENERIC_IRQ_IPI) && irq < 2)\n\t\t\td = ipi_domain;\n\t\telse\n\t\t\td = irq_domain;\n\n\t\tdo_domain_IRQ(d, irq);\n\t\tpending &= ~BIT(irq);\n\t}\n}\n\nstatic int mips_cpu_intc_map(struct irq_domain *d, unsigned int irq,\n\t\t\t     irq_hw_number_t hw)\n{\n\tstruct irq_chip *chip;\n\n\tif (hw < 2 && cpu_has_mipsmt) {\n\t\t \n\t\tchip = &mips_mt_cpu_irq_controller;\n\t} else {\n\t\tchip = &mips_cpu_irq_controller;\n\t}\n\n\tif (cpu_has_vint)\n\t\tset_vi_handler(hw, plat_irq_dispatch);\n\n\tirq_set_chip_and_handler(irq, chip, handle_percpu_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mips_cpu_intc_irq_domain_ops = {\n\t.map = mips_cpu_intc_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\n#ifdef CONFIG_GENERIC_IRQ_IPI\n\nstruct cpu_ipi_domain_state {\n\tDECLARE_BITMAP(allocated, 2);\n};\n\nstatic int mips_cpu_ipi_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs, void *arg)\n{\n\tstruct cpu_ipi_domain_state *state = domain->host_data;\n\tunsigned int i, hwirq;\n\tint ret;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\thwirq = find_first_zero_bit(state->allocated, 2);\n\t\tif (hwirq == 2)\n\t\t\treturn -EBUSY;\n\t\tbitmap_set(state->allocated, hwirq, 1);\n\n\t\tret = irq_domain_set_hwirq_and_chip(domain, virq + i, hwirq,\n\t\t\t\t\t\t    &mips_mt_cpu_irq_controller,\n\t\t\t\t\t\t    NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = irq_domain_set_hwirq_and_chip(domain->parent, virq + i, hwirq,\n\t\t\t\t\t\t    &mips_mt_cpu_irq_controller,\n\t\t\t\t\t\t    NULL);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = irq_set_irq_type(virq + i, IRQ_TYPE_LEVEL_HIGH);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mips_cpu_ipi_match(struct irq_domain *d, struct device_node *node,\n\t\t\t      enum irq_domain_bus_token bus_token)\n{\n\tbool is_ipi;\n\n\tswitch (bus_token) {\n\tcase DOMAIN_BUS_IPI:\n\t\tis_ipi = d->bus_token == bus_token;\n\t\treturn (!node || (to_of_node(d->fwnode) == node)) && is_ipi;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct irq_domain_ops mips_cpu_ipi_chip_ops = {\n\t.alloc\t= mips_cpu_ipi_alloc,\n\t.match\t= mips_cpu_ipi_match,\n};\n\nstatic void mips_cpu_register_ipi_domain(struct device_node *of_node)\n{\n\tstruct cpu_ipi_domain_state *ipi_domain_state;\n\n\tipi_domain_state = kzalloc(sizeof(*ipi_domain_state), GFP_KERNEL);\n\tipi_domain = irq_domain_add_hierarchy(irq_domain,\n\t\t\t\t\t      IRQ_DOMAIN_FLAG_IPI_SINGLE,\n\t\t\t\t\t      2, of_node,\n\t\t\t\t\t      &mips_cpu_ipi_chip_ops,\n\t\t\t\t\t      ipi_domain_state);\n\tif (!ipi_domain)\n\t\tpanic(\"Failed to add MIPS CPU IPI domain\");\n\tirq_domain_update_bus_token(ipi_domain, DOMAIN_BUS_IPI);\n}\n\n#else  \n\nstatic inline void mips_cpu_register_ipi_domain(struct device_node *of_node) {}\n\n#endif  \n\nstatic void __init __mips_cpu_irq_init(struct device_node *of_node)\n{\n\t \n\tclear_c0_status(ST0_IM);\n\tclear_c0_cause(CAUSEF_IP);\n\n\tirq_domain = irq_domain_add_legacy(of_node, 8, MIPS_CPU_IRQ_BASE, 0,\n\t\t\t\t\t   &mips_cpu_intc_irq_domain_ops,\n\t\t\t\t\t   NULL);\n\tif (!irq_domain)\n\t\tpanic(\"Failed to add irqdomain for MIPS CPU\");\n\n\t \n\tif (cpu_has_mipsmt)\n\t\tmips_cpu_register_ipi_domain(of_node);\n}\n\nvoid __init mips_cpu_irq_init(void)\n{\n\t__mips_cpu_irq_init(NULL);\n}\n\nint __init mips_cpu_irq_of_init(struct device_node *of_node,\n\t\t\t\tstruct device_node *parent)\n{\n\t__mips_cpu_irq_init(of_node);\n\treturn 0;\n}\nIRQCHIP_DECLARE(cpu_intc, \"mti,cpu-interrupt-controller\", mips_cpu_irq_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}