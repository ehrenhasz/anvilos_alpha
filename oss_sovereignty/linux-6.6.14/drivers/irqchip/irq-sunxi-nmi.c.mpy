{
  "module_name": "irq-sunxi-nmi.c",
  "hash_id": "0000a6e73386a2a82250bd7f1a567af9716f3cad28add4d31f80f53f49d82b0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-sunxi-nmi.c",
  "human_readable_source": " \n\n#define DRV_NAME\t\"sunxi-nmi\"\n#define pr_fmt(fmt)\tDRV_NAME \": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n\n#define SUNXI_NMI_SRC_TYPE_MASK\t0x00000003\n\n#define SUNXI_NMI_IRQ_BIT\tBIT(0)\n\n \n#define SUN6I_NMI_CTRL\t\t0x00\n#define SUN6I_NMI_PENDING\t0x04\n#define SUN6I_NMI_ENABLE\t0x34\n\n#define SUN7I_NMI_CTRL\t\t0x00\n#define SUN7I_NMI_PENDING\t0x04\n#define SUN7I_NMI_ENABLE\t0x08\n\n#define SUN9I_NMI_CTRL\t\t0x00\n#define SUN9I_NMI_ENABLE\t0x04\n#define SUN9I_NMI_PENDING\t0x08\n\nenum {\n\tSUNXI_SRC_TYPE_LEVEL_LOW = 0,\n\tSUNXI_SRC_TYPE_EDGE_FALLING,\n\tSUNXI_SRC_TYPE_LEVEL_HIGH,\n\tSUNXI_SRC_TYPE_EDGE_RISING,\n};\n\nstruct sunxi_sc_nmi_reg_offs {\n\tu32 ctrl;\n\tu32 pend;\n\tu32 enable;\n};\n\nstatic const struct sunxi_sc_nmi_reg_offs sun6i_reg_offs __initconst = {\n\t.ctrl\t= SUN6I_NMI_CTRL,\n\t.pend\t= SUN6I_NMI_PENDING,\n\t.enable\t= SUN6I_NMI_ENABLE,\n};\n\nstatic const struct sunxi_sc_nmi_reg_offs sun7i_reg_offs __initconst = {\n\t.ctrl\t= SUN7I_NMI_CTRL,\n\t.pend\t= SUN7I_NMI_PENDING,\n\t.enable\t= SUN7I_NMI_ENABLE,\n};\n\nstatic const struct sunxi_sc_nmi_reg_offs sun9i_reg_offs __initconst = {\n\t.ctrl\t= SUN9I_NMI_CTRL,\n\t.pend\t= SUN9I_NMI_PENDING,\n\t.enable\t= SUN9I_NMI_ENABLE,\n};\n\nstatic inline void sunxi_sc_nmi_write(struct irq_chip_generic *gc, u32 off,\n\t\t\t\t      u32 val)\n{\n\tirq_reg_writel(gc, val, off);\n}\n\nstatic inline u32 sunxi_sc_nmi_read(struct irq_chip_generic *gc, u32 off)\n{\n\treturn irq_reg_readl(gc, off);\n}\n\nstatic void sunxi_sc_nmi_handle_irq(struct irq_desc *desc)\n{\n\tstruct irq_domain *domain = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\tchained_irq_enter(chip, desc);\n\tgeneric_handle_domain_irq(domain, 0);\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int sunxi_sc_nmi_set_type(struct irq_data *data, unsigned int flow_type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\n\tstruct irq_chip_type *ct = gc->chip_types;\n\tu32 src_type_reg;\n\tu32 ctrl_off = ct->regs.type;\n\tunsigned int src_type;\n\tunsigned int i;\n\n\tirq_gc_lock(gc);\n\n\tswitch (flow_type & IRQF_TRIGGER_MASK) {\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tsrc_type = SUNXI_SRC_TYPE_EDGE_FALLING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tsrc_type = SUNXI_SRC_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tsrc_type = SUNXI_SRC_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_NONE:\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tsrc_type = SUNXI_SRC_TYPE_LEVEL_LOW;\n\t\tbreak;\n\tdefault:\n\t\tirq_gc_unlock(gc);\n\t\tpr_err(\"Cannot assign multiple trigger modes to IRQ %d.\\n\",\n\t\t\tdata->irq);\n\t\treturn -EBADR;\n\t}\n\n\tirqd_set_trigger_type(data, flow_type);\n\tirq_setup_alt_chip(data, flow_type);\n\n\tfor (i = 0; i < gc->num_ct; i++, ct++)\n\t\tif (ct->type & flow_type)\n\t\t\tctrl_off = ct->regs.type;\n\n\tsrc_type_reg = sunxi_sc_nmi_read(gc, ctrl_off);\n\tsrc_type_reg &= ~SUNXI_NMI_SRC_TYPE_MASK;\n\tsrc_type_reg |= src_type;\n\tsunxi_sc_nmi_write(gc, ctrl_off, src_type_reg);\n\n\tirq_gc_unlock(gc);\n\n\treturn IRQ_SET_MASK_OK;\n}\n\nstatic int __init sunxi_sc_nmi_irq_init(struct device_node *node,\n\t\t\t\t\tconst struct sunxi_sc_nmi_reg_offs *reg_offs)\n{\n\tstruct irq_domain *domain;\n\tstruct irq_chip_generic *gc;\n\tunsigned int irq;\n\tunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\n\tint ret;\n\n\n\tdomain = irq_domain_add_linear(node, 1, &irq_generic_chip_ops, NULL);\n\tif (!domain) {\n\t\tpr_err(\"Could not register interrupt domain.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(domain, 1, 2, DRV_NAME,\n\t\t\t\t\t     handle_fasteoi_irq, clr, 0,\n\t\t\t\t\t     IRQ_GC_INIT_MASK_CACHE);\n\tif (ret) {\n\t\tpr_err(\"Could not allocate generic interrupt chip.\\n\");\n\t\tgoto fail_irqd_remove;\n\t}\n\n\tirq = irq_of_parse_and_map(node, 0);\n\tif (irq <= 0) {\n\t\tpr_err(\"unable to parse irq\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail_irqd_remove;\n\t}\n\n\tgc = irq_get_domain_generic_chip(domain, 0);\n\tgc->reg_base = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(gc->reg_base)) {\n\t\tpr_err(\"unable to map resource\\n\");\n\t\tret = PTR_ERR(gc->reg_base);\n\t\tgoto fail_irqd_remove;\n\t}\n\n\tgc->chip_types[0].type\t\t\t= IRQ_TYPE_LEVEL_MASK;\n\tgc->chip_types[0].chip.irq_mask\t\t= irq_gc_mask_clr_bit;\n\tgc->chip_types[0].chip.irq_unmask\t= irq_gc_mask_set_bit;\n\tgc->chip_types[0].chip.irq_eoi\t\t= irq_gc_ack_set_bit;\n\tgc->chip_types[0].chip.irq_set_type\t= sunxi_sc_nmi_set_type;\n\tgc->chip_types[0].chip.flags\t\t= IRQCHIP_EOI_THREADED | IRQCHIP_EOI_IF_HANDLED;\n\tgc->chip_types[0].regs.ack\t\t= reg_offs->pend;\n\tgc->chip_types[0].regs.mask\t\t= reg_offs->enable;\n\tgc->chip_types[0].regs.type\t\t= reg_offs->ctrl;\n\n\tgc->chip_types[1].type\t\t\t= IRQ_TYPE_EDGE_BOTH;\n\tgc->chip_types[1].chip.name\t\t= gc->chip_types[0].chip.name;\n\tgc->chip_types[1].chip.irq_ack\t\t= irq_gc_ack_set_bit;\n\tgc->chip_types[1].chip.irq_mask\t\t= irq_gc_mask_clr_bit;\n\tgc->chip_types[1].chip.irq_unmask\t= irq_gc_mask_set_bit;\n\tgc->chip_types[1].chip.irq_set_type\t= sunxi_sc_nmi_set_type;\n\tgc->chip_types[1].regs.ack\t\t= reg_offs->pend;\n\tgc->chip_types[1].regs.mask\t\t= reg_offs->enable;\n\tgc->chip_types[1].regs.type\t\t= reg_offs->ctrl;\n\tgc->chip_types[1].handler\t\t= handle_edge_irq;\n\n\t \n\tsunxi_sc_nmi_write(gc, reg_offs->enable, 0);\n\n\t \n\tsunxi_sc_nmi_write(gc, reg_offs->pend, SUNXI_NMI_IRQ_BIT);\n\n\tirq_set_chained_handler_and_data(irq, sunxi_sc_nmi_handle_irq, domain);\n\n\treturn 0;\n\nfail_irqd_remove:\n\tirq_domain_remove(domain);\n\n\treturn ret;\n}\n\nstatic int __init sun6i_sc_nmi_irq_init(struct device_node *node,\n\t\t\t\t\tstruct device_node *parent)\n{\n\treturn sunxi_sc_nmi_irq_init(node, &sun6i_reg_offs);\n}\nIRQCHIP_DECLARE(sun6i_sc_nmi, \"allwinner,sun6i-a31-sc-nmi\", sun6i_sc_nmi_irq_init);\n\nstatic int __init sun7i_sc_nmi_irq_init(struct device_node *node,\n\t\t\t\t\tstruct device_node *parent)\n{\n\treturn sunxi_sc_nmi_irq_init(node, &sun7i_reg_offs);\n}\nIRQCHIP_DECLARE(sun7i_sc_nmi, \"allwinner,sun7i-a20-sc-nmi\", sun7i_sc_nmi_irq_init);\n\nstatic int __init sun9i_nmi_irq_init(struct device_node *node,\n\t\t\t\t     struct device_node *parent)\n{\n\treturn sunxi_sc_nmi_irq_init(node, &sun9i_reg_offs);\n}\nIRQCHIP_DECLARE(sun9i_nmi, \"allwinner,sun9i-a80-nmi\", sun9i_nmi_irq_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}