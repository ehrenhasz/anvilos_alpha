{
  "module_name": "irq-ftintc010.c",
  "hash_id": "93472741d4851dd35d9baa51731eb2ecef592023f19c83b4c3c04de63a849c49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-ftintc010.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/cpu.h>\n\n#include <asm/exception.h>\n#include <asm/mach/irq.h>\n\n#define FT010_NUM_IRQS 32\n\n#define FT010_IRQ_SOURCE(base_addr)\t(base_addr + 0x00)\n#define FT010_IRQ_MASK(base_addr)\t(base_addr + 0x04)\n#define FT010_IRQ_CLEAR(base_addr)\t(base_addr + 0x08)\n \n#define FT010_IRQ_MODE(base_addr)\t(base_addr + 0x0C)\n \n#define FT010_IRQ_POLARITY(base_addr)\t(base_addr + 0x10)\n#define FT010_IRQ_STATUS(base_addr)\t(base_addr + 0x14)\n#define FT010_FIQ_SOURCE(base_addr)\t(base_addr + 0x20)\n#define FT010_FIQ_MASK(base_addr)\t(base_addr + 0x24)\n#define FT010_FIQ_CLEAR(base_addr)\t(base_addr + 0x28)\n#define FT010_FIQ_MODE(base_addr)\t(base_addr + 0x2C)\n#define FT010_FIQ_POLARITY(base_addr)\t(base_addr + 0x30)\n#define FT010_FIQ_STATUS(base_addr)\t(base_addr + 0x34)\n\n \nstruct ft010_irq_data {\n\tvoid __iomem *base;\n\tstruct irq_chip chip;\n\tstruct irq_domain *domain;\n};\n\nstatic void ft010_irq_mask(struct irq_data *d)\n{\n\tstruct ft010_irq_data *f = irq_data_get_irq_chip_data(d);\n\tunsigned int mask;\n\n\tmask = readl(FT010_IRQ_MASK(f->base));\n\tmask &= ~BIT(irqd_to_hwirq(d));\n\twritel(mask, FT010_IRQ_MASK(f->base));\n}\n\nstatic void ft010_irq_unmask(struct irq_data *d)\n{\n\tstruct ft010_irq_data *f = irq_data_get_irq_chip_data(d);\n\tunsigned int mask;\n\n\tmask = readl(FT010_IRQ_MASK(f->base));\n\tmask |= BIT(irqd_to_hwirq(d));\n\twritel(mask, FT010_IRQ_MASK(f->base));\n}\n\nstatic void ft010_irq_ack(struct irq_data *d)\n{\n\tstruct ft010_irq_data *f = irq_data_get_irq_chip_data(d);\n\n\twritel(BIT(irqd_to_hwirq(d)), FT010_IRQ_CLEAR(f->base));\n}\n\nstatic int ft010_irq_set_type(struct irq_data *d, unsigned int trigger)\n{\n\tstruct ft010_irq_data *f = irq_data_get_irq_chip_data(d);\n\tint offset = irqd_to_hwirq(d);\n\tu32 mode, polarity;\n\n\tmode = readl(FT010_IRQ_MODE(f->base));\n\tpolarity = readl(FT010_IRQ_POLARITY(f->base));\n\n\tif (trigger & (IRQ_TYPE_LEVEL_LOW)) {\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tmode &= ~BIT(offset);\n\t\tpolarity |= BIT(offset);\n\t} else if (trigger & (IRQ_TYPE_LEVEL_HIGH)) {\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tmode &= ~BIT(offset);\n\t\tpolarity &= ~BIT(offset);\n\t} else if (trigger & IRQ_TYPE_EDGE_FALLING) {\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tmode |= BIT(offset);\n\t\tpolarity |= BIT(offset);\n\t} else if (trigger & IRQ_TYPE_EDGE_RISING) {\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tmode |= BIT(offset);\n\t\tpolarity &= ~BIT(offset);\n\t} else {\n\t\tirq_set_handler_locked(d, handle_bad_irq);\n\t\tpr_warn(\"Faraday IRQ: no supported trigger selected for line %d\\n\",\n\t\t\toffset);\n\t}\n\n\twritel(mode, FT010_IRQ_MODE(f->base));\n\twritel(polarity, FT010_IRQ_POLARITY(f->base));\n\n\treturn 0;\n}\n\nstatic struct irq_chip ft010_irq_chip = {\n\t.name\t\t= \"FTINTC010\",\n\t.irq_ack\t= ft010_irq_ack,\n\t.irq_mask\t= ft010_irq_mask,\n\t.irq_unmask\t= ft010_irq_unmask,\n\t.irq_set_type\t= ft010_irq_set_type,\n};\n\n \nstatic struct ft010_irq_data firq;\n\nstatic asmlinkage void __exception_irq_entry ft010_irqchip_handle_irq(struct pt_regs *regs)\n{\n\tstruct ft010_irq_data *f = &firq;\n\tint irq;\n\tu32 status;\n\n\twhile ((status = readl(FT010_IRQ_STATUS(f->base)))) {\n\t\tirq = ffs(status) - 1;\n\t\tgeneric_handle_domain_irq(f->domain, irq);\n\t}\n}\n\nstatic int ft010_irqdomain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tstruct ft010_irq_data *f = d->host_data;\n\n\tirq_set_chip_data(irq, f);\n\t \n\tirq_set_chip_and_handler(irq, &ft010_irq_chip, handle_bad_irq);\n\tirq_set_probe(irq);\n\n\treturn 0;\n}\n\nstatic void ft010_irqdomain_unmap(struct irq_domain *d, unsigned int irq)\n{\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\tirq_set_chip_data(irq, NULL);\n}\n\nstatic const struct irq_domain_ops ft010_irqdomain_ops = {\n\t.map = ft010_irqdomain_map,\n\t.unmap = ft010_irqdomain_unmap,\n\t.xlate = irq_domain_xlate_onetwocell,\n};\n\nstatic int __init ft010_of_init_irq(struct device_node *node,\n\t\t\t      struct device_node *parent)\n{\n\tstruct ft010_irq_data *f = &firq;\n\n\t \n\tcpu_idle_poll_ctrl(true);\n\n\tf->base = of_iomap(node, 0);\n\tWARN(!f->base, \"unable to map gemini irq registers\\n\");\n\n\t \n\twritel(0, FT010_IRQ_MASK(f->base));\n\twritel(0, FT010_FIQ_MASK(f->base));\n\n\tf->domain = irq_domain_add_simple(node, FT010_NUM_IRQS, 0,\n\t\t\t\t\t  &ft010_irqdomain_ops, f);\n\tset_handle_irq(ft010_irqchip_handle_irq);\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(faraday, \"faraday,ftintc010\",\n\t\tft010_of_init_irq);\nIRQCHIP_DECLARE(gemini, \"cortina,gemini-interrupt-controller\",\n\t\tft010_of_init_irq);\nIRQCHIP_DECLARE(moxa, \"moxa,moxart-ic\",\n\t\tft010_of_init_irq);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}