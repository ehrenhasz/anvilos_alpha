{
  "module_name": "irq-digicolor.c",
  "hash_id": "dbbc917819ec3256a1f6baec76a8af817efce65d56e8629dc43657df0cf3603a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-digicolor.c",
  "human_readable_source": " \n\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include <asm/exception.h>\n\n#define UC_IRQ_CONTROL\t\t0x04\n\n#define IC_FLAG_CLEAR_LO\t0x00\n#define IC_FLAG_CLEAR_XLO\t0x04\n#define IC_INT0ENABLE_LO\t0x10\n#define IC_INT0ENABLE_XLO\t0x14\n#define IC_INT0STATUS_LO\t0x18\n#define IC_INT0STATUS_XLO\t0x1c\n\nstatic struct irq_domain *digicolor_irq_domain;\n\nstatic void __exception_irq_entry digicolor_handle_irq(struct pt_regs *regs)\n{\n\tstruct irq_domain_chip_generic *dgc = digicolor_irq_domain->gc;\n\tstruct irq_chip_generic *gc = dgc->gc[0];\n\tu32 status, hwirq;\n\n\tdo {\n\t\tstatus = irq_reg_readl(gc, IC_INT0STATUS_LO);\n\t\tif (status) {\n\t\t\thwirq = ffs(status) - 1;\n\t\t} else {\n\t\t\tstatus = irq_reg_readl(gc, IC_INT0STATUS_XLO);\n\t\t\tif (status)\n\t\t\t\thwirq = ffs(status) - 1 + 32;\n\t\t\telse\n\t\t\t\treturn;\n\t\t}\n\n\t\tgeneric_handle_domain_irq(digicolor_irq_domain, hwirq);\n\t} while (1);\n}\n\nstatic void __init digicolor_set_gc(void __iomem *reg_base, unsigned irq_base,\n\t\t\t\t    unsigned en_reg, unsigned ack_reg)\n{\n\tstruct irq_chip_generic *gc;\n\n\tgc = irq_get_domain_generic_chip(digicolor_irq_domain, irq_base);\n\tgc->reg_base = reg_base;\n\tgc->chip_types[0].regs.ack = ack_reg;\n\tgc->chip_types[0].regs.mask = en_reg;\n\tgc->chip_types[0].chip.irq_ack = irq_gc_ack_set_bit;\n\tgc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit;\n\tgc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit;\n}\n\nstatic int __init digicolor_of_init(struct device_node *node,\n\t\t\t\tstruct device_node *parent)\n{\n\tvoid __iomem *reg_base;\n\tunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\n\tstruct regmap *ucregs;\n\tint ret;\n\n\treg_base = of_iomap(node, 0);\n\tif (!reg_base) {\n\t\tpr_err(\"%pOF: unable to map IC registers\\n\", node);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\twritel(0, reg_base + IC_INT0ENABLE_LO);\n\twritel(0, reg_base + IC_INT0ENABLE_XLO);\n\n\tucregs = syscon_regmap_lookup_by_phandle(node, \"syscon\");\n\tif (IS_ERR(ucregs)) {\n\t\tpr_err(\"%pOF: unable to map UC registers\\n\", node);\n\t\treturn PTR_ERR(ucregs);\n\t}\n\t \n\tregmap_write(ucregs, UC_IRQ_CONTROL, 1);\n\n\tdigicolor_irq_domain =\n\t\tirq_domain_add_linear(node, 64, &irq_generic_chip_ops, NULL);\n\tif (!digicolor_irq_domain) {\n\t\tpr_err(\"%pOF: unable to create IRQ domain\\n\", node);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(digicolor_irq_domain, 32, 1,\n\t\t\t\t\t     \"digicolor_irq\", handle_level_irq,\n\t\t\t\t\t     clr, 0, 0);\n\tif (ret) {\n\t\tpr_err(\"%pOF: unable to allocate IRQ gc\\n\", node);\n\t\treturn ret;\n\t}\n\n\tdigicolor_set_gc(reg_base, 0, IC_INT0ENABLE_LO, IC_FLAG_CLEAR_LO);\n\tdigicolor_set_gc(reg_base, 32, IC_INT0ENABLE_XLO, IC_FLAG_CLEAR_XLO);\n\n\tset_handle_irq(digicolor_handle_irq);\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(conexant_digicolor_ic, \"cnxt,cx92755-ic\", digicolor_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}