{
  "module_name": "irq-al-fic.c",
  "hash_id": "cb726c01b70af744b6d1d439de2307bd48ccb735dadb483e71099330d680e832",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-al-fic.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n \n#define AL_FIC_CAUSE\t\t0x00\n#define AL_FIC_SET_CAUSE\t0x08\n#define AL_FIC_MASK\t\t0x10\n#define AL_FIC_CONTROL\t\t0x28\n\n#define CONTROL_TRIGGER_RISING\tBIT(3)\n#define CONTROL_MASK_MSI_X\tBIT(5)\n\n#define NR_FIC_IRQS 32\n\nMODULE_AUTHOR(\"Talel Shenhar\");\nMODULE_DESCRIPTION(\"Amazon's Annapurna Labs Interrupt Controller Driver\");\n\nenum al_fic_state {\n\tAL_FIC_UNCONFIGURED = 0,\n\tAL_FIC_CONFIGURED_LEVEL,\n\tAL_FIC_CONFIGURED_RISING_EDGE,\n};\n\nstruct al_fic {\n\tvoid __iomem *base;\n\tstruct irq_domain *domain;\n\tconst char *name;\n\tunsigned int parent_irq;\n\tenum al_fic_state state;\n};\n\nstatic void al_fic_set_trigger(struct al_fic *fic,\n\t\t\t       struct irq_chip_generic *gc,\n\t\t\t       enum al_fic_state new_state)\n{\n\tirq_flow_handler_t handler;\n\tu32 control = readl_relaxed(fic->base + AL_FIC_CONTROL);\n\n\tif (new_state == AL_FIC_CONFIGURED_LEVEL) {\n\t\thandler = handle_level_irq;\n\t\tcontrol &= ~CONTROL_TRIGGER_RISING;\n\t} else {\n\t\thandler = handle_edge_irq;\n\t\tcontrol |= CONTROL_TRIGGER_RISING;\n\t}\n\tgc->chip_types->handler = handler;\n\tfic->state = new_state;\n\twritel_relaxed(control, fic->base + AL_FIC_CONTROL);\n}\n\nstatic int al_fic_irq_set_type(struct irq_data *data, unsigned int flow_type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\n\tstruct al_fic *fic = gc->private;\n\tenum al_fic_state new_state;\n\tint ret = 0;\n\n\tirq_gc_lock(gc);\n\n\tif (((flow_type & IRQ_TYPE_SENSE_MASK) != IRQ_TYPE_LEVEL_HIGH) &&\n\t    ((flow_type & IRQ_TYPE_SENSE_MASK) != IRQ_TYPE_EDGE_RISING)) {\n\t\tpr_debug(\"fic doesn't support flow type %d\\n\", flow_type);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tnew_state = (flow_type & IRQ_TYPE_LEVEL_HIGH) ?\n\t\tAL_FIC_CONFIGURED_LEVEL : AL_FIC_CONFIGURED_RISING_EDGE;\n\n\t \n\tif (fic->state == AL_FIC_UNCONFIGURED) {\n\t\tal_fic_set_trigger(fic, gc, new_state);\n\t} else if (fic->state != new_state) {\n\t\tpr_debug(\"fic %s state already configured to %d\\n\",\n\t\t\t fic->name, fic->state);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\nerr:\n\tirq_gc_unlock(gc);\n\n\treturn ret;\n}\n\nstatic void al_fic_irq_handler(struct irq_desc *desc)\n{\n\tstruct al_fic *fic = irq_desc_get_handler_data(desc);\n\tstruct irq_domain *domain = fic->domain;\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\tstruct irq_chip_generic *gc = irq_get_domain_generic_chip(domain, 0);\n\tunsigned long pending;\n\tu32 hwirq;\n\n\tchained_irq_enter(irqchip, desc);\n\n\tpending = readl_relaxed(fic->base + AL_FIC_CAUSE);\n\tpending &= ~gc->mask_cache;\n\n\tfor_each_set_bit(hwirq, &pending, NR_FIC_IRQS)\n\t\tgeneric_handle_domain_irq(domain, hwirq);\n\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic int al_fic_irq_retrigger(struct irq_data *data)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\n\tstruct al_fic *fic = gc->private;\n\n\twritel_relaxed(BIT(data->hwirq), fic->base + AL_FIC_SET_CAUSE);\n\n\treturn 1;\n}\n\nstatic int al_fic_register(struct device_node *node,\n\t\t\t   struct al_fic *fic)\n{\n\tstruct irq_chip_generic *gc;\n\tint ret;\n\n\tfic->domain = irq_domain_add_linear(node,\n\t\t\t\t\t    NR_FIC_IRQS,\n\t\t\t\t\t    &irq_generic_chip_ops,\n\t\t\t\t\t    fic);\n\tif (!fic->domain) {\n\t\tpr_err(\"fail to add irq domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(fic->domain,\n\t\t\t\t\t     NR_FIC_IRQS,\n\t\t\t\t\t     1, fic->name,\n\t\t\t\t\t     handle_level_irq,\n\t\t\t\t\t     0, 0, IRQ_GC_INIT_MASK_CACHE);\n\tif (ret) {\n\t\tpr_err(\"fail to allocate generic chip (%d)\\n\", ret);\n\t\tgoto err_domain_remove;\n\t}\n\n\tgc = irq_get_domain_generic_chip(fic->domain, 0);\n\tgc->reg_base = fic->base;\n\tgc->chip_types->regs.mask = AL_FIC_MASK;\n\tgc->chip_types->regs.ack = AL_FIC_CAUSE;\n\tgc->chip_types->chip.irq_mask = irq_gc_mask_set_bit;\n\tgc->chip_types->chip.irq_unmask = irq_gc_mask_clr_bit;\n\tgc->chip_types->chip.irq_ack = irq_gc_ack_clr_bit;\n\tgc->chip_types->chip.irq_set_type = al_fic_irq_set_type;\n\tgc->chip_types->chip.irq_retrigger = al_fic_irq_retrigger;\n\tgc->chip_types->chip.flags = IRQCHIP_SKIP_SET_WAKE;\n\tgc->private = fic;\n\n\tirq_set_chained_handler_and_data(fic->parent_irq,\n\t\t\t\t\t al_fic_irq_handler,\n\t\t\t\t\t fic);\n\treturn 0;\n\nerr_domain_remove:\n\tirq_domain_remove(fic->domain);\n\n\treturn ret;\n}\n\n \nstatic struct al_fic *al_fic_wire_init(struct device_node *node,\n\t\t\t\t       void __iomem *base,\n\t\t\t\t       const char *name,\n\t\t\t\t       unsigned int parent_irq)\n{\n\tstruct al_fic *fic;\n\tint ret;\n\tu32 control = CONTROL_MASK_MSI_X;\n\n\tfic = kzalloc(sizeof(*fic), GFP_KERNEL);\n\tif (!fic)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfic->base = base;\n\tfic->parent_irq = parent_irq;\n\tfic->name = name;\n\n\t \n\twritel_relaxed(0xFFFFFFFF, fic->base + AL_FIC_MASK);\n\n\t \n\twritel_relaxed(0, fic->base + AL_FIC_CAUSE);\n\n\twritel_relaxed(control, fic->base + AL_FIC_CONTROL);\n\n\tret = al_fic_register(node, fic);\n\tif (ret) {\n\t\tpr_err(\"fail to register irqchip\\n\");\n\t\tgoto err_free;\n\t}\n\n\tpr_debug(\"%s initialized successfully in Legacy mode (parent-irq=%u)\\n\",\n\t\t fic->name, parent_irq);\n\n\treturn fic;\n\nerr_free:\n\tkfree(fic);\n\treturn ERR_PTR(ret);\n}\n\nstatic int __init al_fic_init_dt(struct device_node *node,\n\t\t\t\t struct device_node *parent)\n{\n\tint ret;\n\tvoid __iomem *base;\n\tunsigned int parent_irq;\n\tstruct al_fic *fic;\n\n\tif (!parent) {\n\t\tpr_err(\"%s: unsupported - device require a parent\\n\",\n\t\t       node->name);\n\t\treturn -EINVAL;\n\t}\n\n\tbase = of_iomap(node, 0);\n\tif (!base) {\n\t\tpr_err(\"%s: fail to map memory\\n\", node->name);\n\t\treturn -ENOMEM;\n\t}\n\n\tparent_irq = irq_of_parse_and_map(node, 0);\n\tif (!parent_irq) {\n\t\tpr_err(\"%s: fail to map irq\\n\", node->name);\n\t\tret = -EINVAL;\n\t\tgoto err_unmap;\n\t}\n\n\tfic = al_fic_wire_init(node,\n\t\t\t       base,\n\t\t\t       node->name,\n\t\t\t       parent_irq);\n\tif (IS_ERR(fic)) {\n\t\tpr_err(\"%s: fail to initialize irqchip (%lu)\\n\",\n\t\t       node->name,\n\t\t       PTR_ERR(fic));\n\t\tret = PTR_ERR(fic);\n\t\tgoto err_irq_dispose;\n\t}\n\n\treturn 0;\n\nerr_irq_dispose:\n\tirq_dispose_mapping(parent_irq);\nerr_unmap:\n\tiounmap(base);\n\n\treturn ret;\n}\n\nIRQCHIP_DECLARE(al_fic, \"amazon,al-fic\", al_fic_init_dt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}