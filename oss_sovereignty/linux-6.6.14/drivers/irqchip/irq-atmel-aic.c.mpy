{
  "module_name": "irq-atmel-aic.c",
  "hash_id": "e7029d18cfc855fa9b35a28d21d1ec1a0cf7a11b2116e891d652cee01207b73b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-atmel-aic.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/bitmap.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#include <asm/exception.h>\n#include <asm/mach/irq.h>\n\n#include \"irq-atmel-aic-common.h\"\n\n \n#define NR_AIC_IRQS\t32\n\n#define AT91_AIC_SMR(n)\t\t\t((n) * 4)\n\n#define AT91_AIC_SVR(n)\t\t\t(0x80 + ((n) * 4))\n#define AT91_AIC_IVR\t\t\t0x100\n#define AT91_AIC_FVR\t\t\t0x104\n#define AT91_AIC_ISR\t\t\t0x108\n\n#define AT91_AIC_IPR\t\t\t0x10c\n#define AT91_AIC_IMR\t\t\t0x110\n#define AT91_AIC_CISR\t\t\t0x114\n\n#define AT91_AIC_IECR\t\t\t0x120\n#define AT91_AIC_IDCR\t\t\t0x124\n#define AT91_AIC_ICCR\t\t\t0x128\n#define AT91_AIC_ISCR\t\t\t0x12c\n#define AT91_AIC_EOICR\t\t\t0x130\n#define AT91_AIC_SPU\t\t\t0x134\n#define AT91_AIC_DCR\t\t\t0x138\n\nstatic struct irq_domain *aic_domain;\n\nstatic asmlinkage void __exception_irq_entry\naic_handle(struct pt_regs *regs)\n{\n\tstruct irq_domain_chip_generic *dgc = aic_domain->gc;\n\tstruct irq_chip_generic *gc = dgc->gc[0];\n\tu32 irqnr;\n\tu32 irqstat;\n\n\tirqnr = irq_reg_readl(gc, AT91_AIC_IVR);\n\tirqstat = irq_reg_readl(gc, AT91_AIC_ISR);\n\n\tif (!irqstat)\n\t\tirq_reg_writel(gc, 0, AT91_AIC_EOICR);\n\telse\n\t\tgeneric_handle_domain_irq(aic_domain, irqnr);\n}\n\nstatic int aic_retrigger(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\n\t \n\tirq_gc_lock(gc);\n\tirq_reg_writel(gc, d->mask, AT91_AIC_ISCR);\n\tirq_gc_unlock(gc);\n\n\treturn 1;\n}\n\nstatic int aic_set_type(struct irq_data *d, unsigned type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tunsigned int smr;\n\tint ret;\n\n\tsmr = irq_reg_readl(gc, AT91_AIC_SMR(d->hwirq));\n\tret = aic_common_set_type(d, type, &smr);\n\tif (ret)\n\t\treturn ret;\n\n\tirq_reg_writel(gc, smr, AT91_AIC_SMR(d->hwirq));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic void aic_suspend(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\n\tirq_gc_lock(gc);\n\tirq_reg_writel(gc, gc->mask_cache, AT91_AIC_IDCR);\n\tirq_reg_writel(gc, gc->wake_active, AT91_AIC_IECR);\n\tirq_gc_unlock(gc);\n}\n\nstatic void aic_resume(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\n\tirq_gc_lock(gc);\n\tirq_reg_writel(gc, gc->wake_active, AT91_AIC_IDCR);\n\tirq_reg_writel(gc, gc->mask_cache, AT91_AIC_IECR);\n\tirq_gc_unlock(gc);\n}\n\nstatic void aic_pm_shutdown(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\n\tirq_gc_lock(gc);\n\tirq_reg_writel(gc, 0xffffffff, AT91_AIC_IDCR);\n\tirq_reg_writel(gc, 0xffffffff, AT91_AIC_ICCR);\n\tirq_gc_unlock(gc);\n}\n#else\n#define aic_suspend\t\tNULL\n#define aic_resume\t\tNULL\n#define aic_pm_shutdown\t\tNULL\n#endif  \n\nstatic void __init aic_hw_init(struct irq_domain *domain)\n{\n\tstruct irq_chip_generic *gc = irq_get_domain_generic_chip(domain, 0);\n\tint i;\n\n\t \n\tfor (i = 0; i < 8; i++)\n\t\tirq_reg_writel(gc, 0, AT91_AIC_EOICR);\n\n\t \n\tirq_reg_writel(gc, 0xffffffff, AT91_AIC_SPU);\n\n\t \n\tirq_reg_writel(gc, 0, AT91_AIC_DCR);\n\n\t \n\tirq_reg_writel(gc, 0xffffffff, AT91_AIC_IDCR);\n\tirq_reg_writel(gc, 0xffffffff, AT91_AIC_ICCR);\n\n\tfor (i = 0; i < 32; i++)\n\t\tirq_reg_writel(gc, i, AT91_AIC_SVR(i));\n}\n\nstatic int aic_irq_domain_xlate(struct irq_domain *d,\n\t\t\t\tstruct device_node *ctrlr,\n\t\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\t\tirq_hw_number_t *out_hwirq,\n\t\t\t\tunsigned int *out_type)\n{\n\tstruct irq_domain_chip_generic *dgc = d->gc;\n\tstruct irq_chip_generic *gc;\n\tunsigned long flags;\n\tunsigned smr;\n\tint idx;\n\tint ret;\n\n\tif (!dgc)\n\t\treturn -EINVAL;\n\n\tret = aic_common_irq_domain_xlate(d, ctrlr, intspec, intsize,\n\t\t\t\t\t  out_hwirq, out_type);\n\tif (ret)\n\t\treturn ret;\n\n\tidx = intspec[0] / dgc->irqs_per_chip;\n\tif (idx >= dgc->num_chips)\n\t\treturn -EINVAL;\n\n\tgc = dgc->gc[idx];\n\n\tirq_gc_lock_irqsave(gc, flags);\n\tsmr = irq_reg_readl(gc, AT91_AIC_SMR(*out_hwirq));\n\taic_common_set_priority(intspec[2], &smr);\n\tirq_reg_writel(gc, smr, AT91_AIC_SMR(*out_hwirq));\n\tirq_gc_unlock_irqrestore(gc, flags);\n\n\treturn ret;\n}\n\nstatic const struct irq_domain_ops aic_irq_ops = {\n\t.map\t= irq_map_generic_chip,\n\t.xlate\t= aic_irq_domain_xlate,\n};\n\nstatic void __init at91rm9200_aic_irq_fixup(void)\n{\n\taic_common_rtc_irq_fixup();\n}\n\nstatic void __init at91sam9260_aic_irq_fixup(void)\n{\n\taic_common_rtt_irq_fixup();\n}\n\nstatic void __init at91sam9g45_aic_irq_fixup(void)\n{\n\taic_common_rtc_irq_fixup();\n\taic_common_rtt_irq_fixup();\n}\n\nstatic const struct of_device_id aic_irq_fixups[] __initconst = {\n\t{ .compatible = \"atmel,at91rm9200\", .data = at91rm9200_aic_irq_fixup },\n\t{ .compatible = \"atmel,at91sam9g45\", .data = at91sam9g45_aic_irq_fixup },\n\t{ .compatible = \"atmel,at91sam9n12\", .data = at91rm9200_aic_irq_fixup },\n\t{ .compatible = \"atmel,at91sam9rl\", .data = at91sam9g45_aic_irq_fixup },\n\t{ .compatible = \"atmel,at91sam9x5\", .data = at91rm9200_aic_irq_fixup },\n\t{ .compatible = \"atmel,at91sam9260\", .data = at91sam9260_aic_irq_fixup },\n\t{ .compatible = \"atmel,at91sam9261\", .data = at91sam9260_aic_irq_fixup },\n\t{ .compatible = \"atmel,at91sam9263\", .data = at91sam9260_aic_irq_fixup },\n\t{ .compatible = \"atmel,at91sam9g20\", .data = at91sam9260_aic_irq_fixup },\n\t{   },\n};\n\nstatic int __init aic_of_init(struct device_node *node,\n\t\t\t      struct device_node *parent)\n{\n\tstruct irq_chip_generic *gc;\n\tstruct irq_domain *domain;\n\n\tif (aic_domain)\n\t\treturn -EEXIST;\n\n\tdomain = aic_common_of_init(node, &aic_irq_ops, \"atmel-aic\",\n\t\t\t\t    NR_AIC_IRQS, aic_irq_fixups);\n\tif (IS_ERR(domain))\n\t\treturn PTR_ERR(domain);\n\n\taic_domain = domain;\n\tgc = irq_get_domain_generic_chip(domain, 0);\n\n\tgc->chip_types[0].regs.eoi = AT91_AIC_EOICR;\n\tgc->chip_types[0].regs.enable = AT91_AIC_IECR;\n\tgc->chip_types[0].regs.disable = AT91_AIC_IDCR;\n\tgc->chip_types[0].chip.irq_mask = irq_gc_mask_disable_reg;\n\tgc->chip_types[0].chip.irq_unmask = irq_gc_unmask_enable_reg;\n\tgc->chip_types[0].chip.irq_retrigger = aic_retrigger;\n\tgc->chip_types[0].chip.irq_set_type = aic_set_type;\n\tgc->chip_types[0].chip.irq_suspend = aic_suspend;\n\tgc->chip_types[0].chip.irq_resume = aic_resume;\n\tgc->chip_types[0].chip.irq_pm_shutdown = aic_pm_shutdown;\n\n\taic_hw_init(domain);\n\tset_handle_irq(aic_handle);\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(at91rm9200_aic, \"atmel,at91rm9200-aic\", aic_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}