{
  "module_name": "irq-imx-irqsteer.c",
  "hash_id": "d832377666dc6c6aa5d68c0c93d7c1c4f8d66363a1ab7d3aeea967eb38afdcbc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-imx-irqsteer.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spinlock.h>\n\n#define CTRL_STRIDE_OFF(_t, _r)\t(_t * 4 * _r)\n#define CHANCTRL\t\t0x0\n#define CHANMASK(n, t)\t\t(CTRL_STRIDE_OFF(t, 0) + 0x4 * (n) + 0x4)\n#define CHANSET(n, t)\t\t(CTRL_STRIDE_OFF(t, 1) + 0x4 * (n) + 0x4)\n#define CHANSTATUS(n, t)\t(CTRL_STRIDE_OFF(t, 2) + 0x4 * (n) + 0x4)\n#define CHAN_MINTDIS(t)\t\t(CTRL_STRIDE_OFF(t, 3) + 0x4)\n#define CHAN_MASTRSTAT(t)\t(CTRL_STRIDE_OFF(t, 3) + 0x8)\n\n#define CHAN_MAX_OUTPUT_INT\t0x8\n\nstruct irqsteer_data {\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*ipg_clk;\n\tint\t\t\tirq[CHAN_MAX_OUTPUT_INT];\n\tint\t\t\tirq_count;\n\traw_spinlock_t\t\tlock;\n\tint\t\t\treg_num;\n\tint\t\t\tchannel;\n\tstruct irq_domain\t*domain;\n\tu32\t\t\t*saved_reg;\n};\n\nstatic int imx_irqsteer_get_reg_index(struct irqsteer_data *data,\n\t\t\t\t      unsigned long irqnum)\n{\n\treturn (data->reg_num - irqnum / 32 - 1);\n}\n\nstatic void imx_irqsteer_irq_unmask(struct irq_data *d)\n{\n\tstruct irqsteer_data *data = d->chip_data;\n\tint idx = imx_irqsteer_get_reg_index(data, d->hwirq);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&data->lock, flags);\n\tval = readl_relaxed(data->regs + CHANMASK(idx, data->reg_num));\n\tval |= BIT(d->hwirq % 32);\n\twritel_relaxed(val, data->regs + CHANMASK(idx, data->reg_num));\n\traw_spin_unlock_irqrestore(&data->lock, flags);\n}\n\nstatic void imx_irqsteer_irq_mask(struct irq_data *d)\n{\n\tstruct irqsteer_data *data = d->chip_data;\n\tint idx = imx_irqsteer_get_reg_index(data, d->hwirq);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&data->lock, flags);\n\tval = readl_relaxed(data->regs + CHANMASK(idx, data->reg_num));\n\tval &= ~BIT(d->hwirq % 32);\n\twritel_relaxed(val, data->regs + CHANMASK(idx, data->reg_num));\n\traw_spin_unlock_irqrestore(&data->lock, flags);\n}\n\nstatic const struct irq_chip imx_irqsteer_irq_chip = {\n\t.name\t\t= \"irqsteer\",\n\t.irq_mask\t= imx_irqsteer_irq_mask,\n\t.irq_unmask\t= imx_irqsteer_irq_unmask,\n};\n\nstatic int imx_irqsteer_irq_map(struct irq_domain *h, unsigned int irq,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tirq_set_status_flags(irq, IRQ_LEVEL);\n\tirq_set_chip_data(irq, h->host_data);\n\tirq_set_chip_and_handler(irq, &imx_irqsteer_irq_chip, handle_level_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops imx_irqsteer_domain_ops = {\n\t.map\t\t= imx_irqsteer_irq_map,\n\t.xlate\t\t= irq_domain_xlate_onecell,\n};\n\nstatic int imx_irqsteer_get_hwirq_base(struct irqsteer_data *data, u32 irq)\n{\n\tint i;\n\n\tfor (i = 0; i < data->irq_count; i++) {\n\t\tif (data->irq[i] == irq)\n\t\t\treturn i * 64;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void imx_irqsteer_irq_handler(struct irq_desc *desc)\n{\n\tstruct irqsteer_data *data = irq_desc_get_handler_data(desc);\n\tint hwirq;\n\tint irq, i;\n\n\tchained_irq_enter(irq_desc_get_chip(desc), desc);\n\n\tirq = irq_desc_get_irq(desc);\n\thwirq = imx_irqsteer_get_hwirq_base(data, irq);\n\tif (hwirq < 0) {\n\t\tpr_warn(\"%s: unable to get hwirq base for irq %d\\n\",\n\t\t\t__func__, irq);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 2; i++, hwirq += 32) {\n\t\tint idx = imx_irqsteer_get_reg_index(data, hwirq);\n\t\tunsigned long irqmap;\n\t\tint pos;\n\n\t\tif (hwirq >= data->reg_num * 32)\n\t\t\tbreak;\n\n\t\tirqmap = readl_relaxed(data->regs +\n\t\t\t\t       CHANSTATUS(idx, data->reg_num));\n\n\t\tfor_each_set_bit(pos, &irqmap, 32)\n\t\t\tgeneric_handle_domain_irq(data->domain, pos + hwirq);\n\t}\n\n\tchained_irq_exit(irq_desc_get_chip(desc), desc);\n}\n\nstatic int imx_irqsteer_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct irqsteer_data *data;\n\tu32 irqs_num;\n\tint i, ret;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->regs)) {\n\t\tdev_err(&pdev->dev, \"failed to initialize reg\\n\");\n\t\treturn PTR_ERR(data->regs);\n\t}\n\n\tdata->ipg_clk = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(data->ipg_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->ipg_clk),\n\t\t\t\t     \"failed to get ipg clk\\n\");\n\n\traw_spin_lock_init(&data->lock);\n\n\tret = of_property_read_u32(np, \"fsl,num-irqs\", &irqs_num);\n\tif (ret)\n\t\treturn ret;\n\tret = of_property_read_u32(np, \"fsl,channel\", &data->channel);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdata->irq_count = DIV_ROUND_UP(irqs_num, 64);\n\tdata->reg_num = irqs_num / 32;\n\n\tif (IS_ENABLED(CONFIG_PM)) {\n\t\tdata->saved_reg = devm_kzalloc(&pdev->dev,\n\t\t\t\t\tsizeof(u32) * data->reg_num,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!data->saved_reg)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = clk_prepare_enable(data->ipg_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable ipg clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\twritel_relaxed(BIT(data->channel), data->regs + CHANCTRL);\n\n\tdata->domain = irq_domain_add_linear(np, data->reg_num * 32,\n\t\t\t\t\t     &imx_irqsteer_domain_ops, data);\n\tif (!data->domain) {\n\t\tdev_err(&pdev->dev, \"failed to create IRQ domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tirq_domain_set_pm_device(data->domain, &pdev->dev);\n\n\tif (!data->irq_count || data->irq_count > CHAN_MAX_OUTPUT_INT) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < data->irq_count; i++) {\n\t\tdata->irq[i] = irq_of_parse_and_map(np, i);\n\t\tif (!data->irq[i]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tirq_set_chained_handler_and_data(data->irq[i],\n\t\t\t\t\t\t imx_irqsteer_irq_handler,\n\t\t\t\t\t\t data);\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\nout:\n\tclk_disable_unprepare(data->ipg_clk);\n\treturn ret;\n}\n\nstatic int imx_irqsteer_remove(struct platform_device *pdev)\n{\n\tstruct irqsteer_data *irqsteer_data = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < irqsteer_data->irq_count; i++)\n\t\tirq_set_chained_handler_and_data(irqsteer_data->irq[i],\n\t\t\t\t\t\t NULL, NULL);\n\n\tirq_domain_remove(irqsteer_data->domain);\n\n\tclk_disable_unprepare(irqsteer_data->ipg_clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic void imx_irqsteer_save_regs(struct irqsteer_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < data->reg_num; i++)\n\t\tdata->saved_reg[i] = readl_relaxed(data->regs +\n\t\t\t\t\t\tCHANMASK(i, data->reg_num));\n}\n\nstatic void imx_irqsteer_restore_regs(struct irqsteer_data *data)\n{\n\tint i;\n\n\twritel_relaxed(BIT(data->channel), data->regs + CHANCTRL);\n\tfor (i = 0; i < data->reg_num; i++)\n\t\twritel_relaxed(data->saved_reg[i],\n\t\t\t       data->regs + CHANMASK(i, data->reg_num));\n}\n\nstatic int imx_irqsteer_suspend(struct device *dev)\n{\n\tstruct irqsteer_data *irqsteer_data = dev_get_drvdata(dev);\n\n\timx_irqsteer_save_regs(irqsteer_data);\n\tclk_disable_unprepare(irqsteer_data->ipg_clk);\n\n\treturn 0;\n}\n\nstatic int imx_irqsteer_resume(struct device *dev)\n{\n\tstruct irqsteer_data *irqsteer_data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(irqsteer_data->ipg_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable ipg clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\timx_irqsteer_restore_regs(irqsteer_data);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops imx_irqsteer_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t      pm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(imx_irqsteer_suspend,\n\t\t\t   imx_irqsteer_resume, NULL)\n};\n\nstatic const struct of_device_id imx_irqsteer_dt_ids[] = {\n\t{ .compatible = \"fsl,imx-irqsteer\", },\n\t{},\n};\n\nstatic struct platform_driver imx_irqsteer_driver = {\n\t.driver = {\n\t\t.name = \"imx-irqsteer\",\n\t\t.of_match_table = imx_irqsteer_dt_ids,\n\t\t.pm = &imx_irqsteer_pm_ops,\n\t},\n\t.probe = imx_irqsteer_probe,\n\t.remove = imx_irqsteer_remove,\n};\nbuiltin_platform_driver(imx_irqsteer_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}