{
  "module_name": "irq-stm32-exti.c",
  "hash_id": "7611056912aaf82dabc7b3949d5a02c71479e4dd072425dfb1c4729f3c1a2374",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-stm32-exti.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/hwspinlock.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/syscore_ops.h>\n\n#include <dt-bindings/interrupt-controller/arm-gic.h>\n\n#define IRQS_PER_BANK 32\n\n#define HWSPNLCK_TIMEOUT\t1000  \n\nstruct stm32_exti_bank {\n\tu32 imr_ofst;\n\tu32 emr_ofst;\n\tu32 rtsr_ofst;\n\tu32 ftsr_ofst;\n\tu32 swier_ofst;\n\tu32 rpr_ofst;\n\tu32 fpr_ofst;\n\tu32 trg_ofst;\n};\n\n#define UNDEF_REG ~0\n\nstruct stm32_exti_drv_data {\n\tconst struct stm32_exti_bank **exti_banks;\n\tconst u8 *desc_irqs;\n\tu32 bank_nr;\n};\n\nstruct stm32_exti_chip_data {\n\tstruct stm32_exti_host_data *host_data;\n\tconst struct stm32_exti_bank *reg_bank;\n\tstruct raw_spinlock rlock;\n\tu32 wake_active;\n\tu32 mask_cache;\n\tu32 rtsr_cache;\n\tu32 ftsr_cache;\n};\n\nstruct stm32_exti_host_data {\n\tvoid __iomem *base;\n\tstruct stm32_exti_chip_data *chips_data;\n\tconst struct stm32_exti_drv_data *drv_data;\n\tstruct hwspinlock *hwlock;\n};\n\nstatic struct stm32_exti_host_data *stm32_host_data;\n\nstatic const struct stm32_exti_bank stm32f4xx_exti_b1 = {\n\t.imr_ofst\t= 0x00,\n\t.emr_ofst\t= 0x04,\n\t.rtsr_ofst\t= 0x08,\n\t.ftsr_ofst\t= 0x0C,\n\t.swier_ofst\t= 0x10,\n\t.rpr_ofst\t= 0x14,\n\t.fpr_ofst\t= UNDEF_REG,\n\t.trg_ofst\t= UNDEF_REG,\n};\n\nstatic const struct stm32_exti_bank *stm32f4xx_exti_banks[] = {\n\t&stm32f4xx_exti_b1,\n};\n\nstatic const struct stm32_exti_drv_data stm32f4xx_drv_data = {\n\t.exti_banks = stm32f4xx_exti_banks,\n\t.bank_nr = ARRAY_SIZE(stm32f4xx_exti_banks),\n};\n\nstatic const struct stm32_exti_bank stm32h7xx_exti_b1 = {\n\t.imr_ofst\t= 0x80,\n\t.emr_ofst\t= 0x84,\n\t.rtsr_ofst\t= 0x00,\n\t.ftsr_ofst\t= 0x04,\n\t.swier_ofst\t= 0x08,\n\t.rpr_ofst\t= 0x88,\n\t.fpr_ofst\t= UNDEF_REG,\n\t.trg_ofst\t= UNDEF_REG,\n};\n\nstatic const struct stm32_exti_bank stm32h7xx_exti_b2 = {\n\t.imr_ofst\t= 0x90,\n\t.emr_ofst\t= 0x94,\n\t.rtsr_ofst\t= 0x20,\n\t.ftsr_ofst\t= 0x24,\n\t.swier_ofst\t= 0x28,\n\t.rpr_ofst\t= 0x98,\n\t.fpr_ofst\t= UNDEF_REG,\n\t.trg_ofst\t= UNDEF_REG,\n};\n\nstatic const struct stm32_exti_bank stm32h7xx_exti_b3 = {\n\t.imr_ofst\t= 0xA0,\n\t.emr_ofst\t= 0xA4,\n\t.rtsr_ofst\t= 0x40,\n\t.ftsr_ofst\t= 0x44,\n\t.swier_ofst\t= 0x48,\n\t.rpr_ofst\t= 0xA8,\n\t.fpr_ofst\t= UNDEF_REG,\n\t.trg_ofst\t= UNDEF_REG,\n};\n\nstatic const struct stm32_exti_bank *stm32h7xx_exti_banks[] = {\n\t&stm32h7xx_exti_b1,\n\t&stm32h7xx_exti_b2,\n\t&stm32h7xx_exti_b3,\n};\n\nstatic const struct stm32_exti_drv_data stm32h7xx_drv_data = {\n\t.exti_banks = stm32h7xx_exti_banks,\n\t.bank_nr = ARRAY_SIZE(stm32h7xx_exti_banks),\n};\n\nstatic const struct stm32_exti_bank stm32mp1_exti_b1 = {\n\t.imr_ofst\t= 0x80,\n\t.emr_ofst\t= UNDEF_REG,\n\t.rtsr_ofst\t= 0x00,\n\t.ftsr_ofst\t= 0x04,\n\t.swier_ofst\t= 0x08,\n\t.rpr_ofst\t= 0x0C,\n\t.fpr_ofst\t= 0x10,\n\t.trg_ofst\t= 0x3EC,\n};\n\nstatic const struct stm32_exti_bank stm32mp1_exti_b2 = {\n\t.imr_ofst\t= 0x90,\n\t.emr_ofst\t= UNDEF_REG,\n\t.rtsr_ofst\t= 0x20,\n\t.ftsr_ofst\t= 0x24,\n\t.swier_ofst\t= 0x28,\n\t.rpr_ofst\t= 0x2C,\n\t.fpr_ofst\t= 0x30,\n\t.trg_ofst\t= 0x3E8,\n};\n\nstatic const struct stm32_exti_bank stm32mp1_exti_b3 = {\n\t.imr_ofst\t= 0xA0,\n\t.emr_ofst\t= UNDEF_REG,\n\t.rtsr_ofst\t= 0x40,\n\t.ftsr_ofst\t= 0x44,\n\t.swier_ofst\t= 0x48,\n\t.rpr_ofst\t= 0x4C,\n\t.fpr_ofst\t= 0x50,\n\t.trg_ofst\t= 0x3E4,\n};\n\nstatic const struct stm32_exti_bank *stm32mp1_exti_banks[] = {\n\t&stm32mp1_exti_b1,\n\t&stm32mp1_exti_b2,\n\t&stm32mp1_exti_b3,\n};\n\nstatic struct irq_chip stm32_exti_h_chip;\nstatic struct irq_chip stm32_exti_h_chip_direct;\n\n#define EXTI_INVALID_IRQ       U8_MAX\n#define STM32MP1_DESC_IRQ_SIZE (ARRAY_SIZE(stm32mp1_exti_banks) * IRQS_PER_BANK)\n\n \n__diag_push();\n__diag_ignore_all(\"-Woverride-init\",\n\t\t  \"logic to initialize all and then override some is OK\");\n\nstatic const u8 stm32mp1_desc_irq[] = {\n\t \n\t[0 ... (STM32MP1_DESC_IRQ_SIZE - 1)] = EXTI_INVALID_IRQ,\n\n\t[0] = 6,\n\t[1] = 7,\n\t[2] = 8,\n\t[3] = 9,\n\t[4] = 10,\n\t[5] = 23,\n\t[6] = 64,\n\t[7] = 65,\n\t[8] = 66,\n\t[9] = 67,\n\t[10] = 40,\n\t[11] = 42,\n\t[12] = 76,\n\t[13] = 77,\n\t[14] = 121,\n\t[15] = 127,\n\t[16] = 1,\n\t[19] = 3,\n\t[21] = 31,\n\t[22] = 33,\n\t[23] = 72,\n\t[24] = 95,\n\t[25] = 107,\n\t[26] = 37,\n\t[27] = 38,\n\t[28] = 39,\n\t[29] = 71,\n\t[30] = 52,\n\t[31] = 53,\n\t[32] = 82,\n\t[33] = 83,\n\t[46] = 151,\n\t[47] = 93,\n\t[48] = 138,\n\t[50] = 139,\n\t[52] = 140,\n\t[53] = 141,\n\t[54] = 135,\n\t[61] = 100,\n\t[65] = 144,\n\t[68] = 143,\n\t[70] = 62,\n\t[73] = 129,\n};\n\nstatic const u8 stm32mp13_desc_irq[] = {\n\t \n\t[0 ... (STM32MP1_DESC_IRQ_SIZE - 1)] = EXTI_INVALID_IRQ,\n\n\t[0] = 6,\n\t[1] = 7,\n\t[2] = 8,\n\t[3] = 9,\n\t[4] = 10,\n\t[5] = 24,\n\t[6] = 65,\n\t[7] = 66,\n\t[8] = 67,\n\t[9] = 68,\n\t[10] = 41,\n\t[11] = 43,\n\t[12] = 77,\n\t[13] = 78,\n\t[14] = 106,\n\t[15] = 109,\n\t[16] = 1,\n\t[19] = 3,\n\t[21] = 32,\n\t[22] = 34,\n\t[23] = 73,\n\t[24] = 93,\n\t[25] = 114,\n\t[26] = 38,\n\t[27] = 39,\n\t[28] = 40,\n\t[29] = 72,\n\t[30] = 53,\n\t[31] = 54,\n\t[32] = 83,\n\t[33] = 84,\n\t[44] = 96,\n\t[47] = 92,\n\t[48] = 116,\n\t[50] = 117,\n\t[52] = 118,\n\t[53] = 119,\n\t[68] = 63,\n\t[70] = 98,\n};\n\n__diag_pop();\n\nstatic const struct stm32_exti_drv_data stm32mp1_drv_data = {\n\t.exti_banks = stm32mp1_exti_banks,\n\t.bank_nr = ARRAY_SIZE(stm32mp1_exti_banks),\n\t.desc_irqs = stm32mp1_desc_irq,\n};\n\nstatic const struct stm32_exti_drv_data stm32mp13_drv_data = {\n\t.exti_banks = stm32mp1_exti_banks,\n\t.bank_nr = ARRAY_SIZE(stm32mp1_exti_banks),\n\t.desc_irqs = stm32mp13_desc_irq,\n};\n\nstatic unsigned long stm32_exti_pending(struct irq_chip_generic *gc)\n{\n\tstruct stm32_exti_chip_data *chip_data = gc->private;\n\tconst struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;\n\tunsigned long pending;\n\n\tpending = irq_reg_readl(gc, stm32_bank->rpr_ofst);\n\tif (stm32_bank->fpr_ofst != UNDEF_REG)\n\t\tpending |= irq_reg_readl(gc, stm32_bank->fpr_ofst);\n\n\treturn pending;\n}\n\nstatic void stm32_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_domain *domain = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned int nbanks = domain->gc->num_chips;\n\tstruct irq_chip_generic *gc;\n\tunsigned long pending;\n\tint n, i, irq_base = 0;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (i = 0; i < nbanks; i++, irq_base += IRQS_PER_BANK) {\n\t\tgc = irq_get_domain_generic_chip(domain, irq_base);\n\n\t\twhile ((pending = stm32_exti_pending(gc))) {\n\t\t\tfor_each_set_bit(n, &pending, IRQS_PER_BANK)\n\t\t\t\tgeneric_handle_domain_irq(domain, irq_base + n);\n \t\t}\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int stm32_exti_set_type(struct irq_data *d,\n\t\t\t       unsigned int type, u32 *rtsr, u32 *ftsr)\n{\n\tu32 mask = BIT(d->hwirq % IRQS_PER_BANK);\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\t*rtsr |= mask;\n\t\t*ftsr &= ~mask;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\t*rtsr &= ~mask;\n\t\t*ftsr |= mask;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t*rtsr |= mask;\n\t\t*ftsr |= mask;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct stm32_exti_chip_data *chip_data = gc->private;\n\tconst struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;\n\tstruct hwspinlock *hwlock = chip_data->host_data->hwlock;\n\tu32 rtsr, ftsr;\n\tint err;\n\n\tirq_gc_lock(gc);\n\n\tif (hwlock) {\n\t\terr = hwspin_lock_timeout_in_atomic(hwlock, HWSPNLCK_TIMEOUT);\n\t\tif (err) {\n\t\t\tpr_err(\"%s can't get hwspinlock (%d)\\n\", __func__, err);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\trtsr = irq_reg_readl(gc, stm32_bank->rtsr_ofst);\n\tftsr = irq_reg_readl(gc, stm32_bank->ftsr_ofst);\n\n\terr = stm32_exti_set_type(d, type, &rtsr, &ftsr);\n\tif (err)\n\t\tgoto unspinlock;\n\n\tirq_reg_writel(gc, rtsr, stm32_bank->rtsr_ofst);\n\tirq_reg_writel(gc, ftsr, stm32_bank->ftsr_ofst);\n\nunspinlock:\n\tif (hwlock)\n\t\thwspin_unlock_in_atomic(hwlock);\nunlock:\n\tirq_gc_unlock(gc);\n\n\treturn err;\n}\n\nstatic void stm32_chip_suspend(struct stm32_exti_chip_data *chip_data,\n\t\t\t       u32 wake_active)\n{\n\tconst struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;\n\tvoid __iomem *base = chip_data->host_data->base;\n\n\t \n\tchip_data->rtsr_cache = readl_relaxed(base + stm32_bank->rtsr_ofst);\n\tchip_data->ftsr_cache = readl_relaxed(base + stm32_bank->ftsr_ofst);\n\n\twritel_relaxed(wake_active, base + stm32_bank->imr_ofst);\n}\n\nstatic void stm32_chip_resume(struct stm32_exti_chip_data *chip_data,\n\t\t\t      u32 mask_cache)\n{\n\tconst struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;\n\tvoid __iomem *base = chip_data->host_data->base;\n\n\t \n\twritel_relaxed(chip_data->rtsr_cache, base + stm32_bank->rtsr_ofst);\n\twritel_relaxed(chip_data->ftsr_cache, base + stm32_bank->ftsr_ofst);\n\n\twritel_relaxed(mask_cache, base + stm32_bank->imr_ofst);\n}\n\nstatic void stm32_irq_suspend(struct irq_chip_generic *gc)\n{\n\tstruct stm32_exti_chip_data *chip_data = gc->private;\n\n\tirq_gc_lock(gc);\n\tstm32_chip_suspend(chip_data, gc->wake_active);\n\tirq_gc_unlock(gc);\n}\n\nstatic void stm32_irq_resume(struct irq_chip_generic *gc)\n{\n\tstruct stm32_exti_chip_data *chip_data = gc->private;\n\n\tirq_gc_lock(gc);\n\tstm32_chip_resume(chip_data, gc->mask_cache);\n\tirq_gc_unlock(gc);\n}\n\nstatic int stm32_exti_alloc(struct irq_domain *d, unsigned int virq,\n\t\t\t    unsigned int nr_irqs, void *data)\n{\n\tstruct irq_fwspec *fwspec = data;\n\tirq_hw_number_t hwirq;\n\n\thwirq = fwspec->param[0];\n\n\tirq_map_generic_chip(d, virq, hwirq);\n\n\treturn 0;\n}\n\nstatic void stm32_exti_free(struct irq_domain *d, unsigned int virq,\n\t\t\t    unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_domain_get_irq_data(d, virq);\n\n\tirq_domain_reset_irq_data(data);\n}\n\nstatic const struct irq_domain_ops irq_exti_domain_ops = {\n\t.map\t= irq_map_generic_chip,\n\t.alloc  = stm32_exti_alloc,\n\t.free\t= stm32_exti_free,\n\t.xlate\t= irq_domain_xlate_twocell,\n};\n\nstatic void stm32_irq_ack(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct stm32_exti_chip_data *chip_data = gc->private;\n\tconst struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;\n\n\tirq_gc_lock(gc);\n\n\tirq_reg_writel(gc, d->mask, stm32_bank->rpr_ofst);\n\tif (stm32_bank->fpr_ofst != UNDEF_REG)\n\t\tirq_reg_writel(gc, d->mask, stm32_bank->fpr_ofst);\n\n\tirq_gc_unlock(gc);\n}\n\n \nstatic inline void stm32_exti_write_bit(struct irq_data *d, u32 reg)\n{\n\tstruct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);\n\tvoid __iomem *base = chip_data->host_data->base;\n\tu32 val = BIT(d->hwirq % IRQS_PER_BANK);\n\n\twritel_relaxed(val, base + reg);\n}\n\nstatic inline u32 stm32_exti_set_bit(struct irq_data *d, u32 reg)\n{\n\tstruct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);\n\tvoid __iomem *base = chip_data->host_data->base;\n\tu32 val;\n\n\tval = readl_relaxed(base + reg);\n\tval |= BIT(d->hwirq % IRQS_PER_BANK);\n\twritel_relaxed(val, base + reg);\n\n\treturn val;\n}\n\nstatic inline u32 stm32_exti_clr_bit(struct irq_data *d, u32 reg)\n{\n\tstruct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);\n\tvoid __iomem *base = chip_data->host_data->base;\n\tu32 val;\n\n\tval = readl_relaxed(base + reg);\n\tval &= ~BIT(d->hwirq % IRQS_PER_BANK);\n\twritel_relaxed(val, base + reg);\n\n\treturn val;\n}\n\nstatic void stm32_exti_h_eoi(struct irq_data *d)\n{\n\tstruct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);\n\tconst struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;\n\n\traw_spin_lock(&chip_data->rlock);\n\n\tstm32_exti_write_bit(d, stm32_bank->rpr_ofst);\n\tif (stm32_bank->fpr_ofst != UNDEF_REG)\n\t\tstm32_exti_write_bit(d, stm32_bank->fpr_ofst);\n\n\traw_spin_unlock(&chip_data->rlock);\n\n\tif (d->parent_data->chip)\n\t\tirq_chip_eoi_parent(d);\n}\n\nstatic void stm32_exti_h_mask(struct irq_data *d)\n{\n\tstruct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);\n\tconst struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;\n\n\traw_spin_lock(&chip_data->rlock);\n\tchip_data->mask_cache = stm32_exti_clr_bit(d, stm32_bank->imr_ofst);\n\traw_spin_unlock(&chip_data->rlock);\n\n\tif (d->parent_data->chip)\n\t\tirq_chip_mask_parent(d);\n}\n\nstatic void stm32_exti_h_unmask(struct irq_data *d)\n{\n\tstruct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);\n\tconst struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;\n\n\traw_spin_lock(&chip_data->rlock);\n\tchip_data->mask_cache = stm32_exti_set_bit(d, stm32_bank->imr_ofst);\n\traw_spin_unlock(&chip_data->rlock);\n\n\tif (d->parent_data->chip)\n\t\tirq_chip_unmask_parent(d);\n}\n\nstatic int stm32_exti_h_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);\n\tconst struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;\n\tstruct hwspinlock *hwlock = chip_data->host_data->hwlock;\n\tvoid __iomem *base = chip_data->host_data->base;\n\tu32 rtsr, ftsr;\n\tint err;\n\n\traw_spin_lock(&chip_data->rlock);\n\n\tif (hwlock) {\n\t\terr = hwspin_lock_timeout_in_atomic(hwlock, HWSPNLCK_TIMEOUT);\n\t\tif (err) {\n\t\t\tpr_err(\"%s can't get hwspinlock (%d)\\n\", __func__, err);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\trtsr = readl_relaxed(base + stm32_bank->rtsr_ofst);\n\tftsr = readl_relaxed(base + stm32_bank->ftsr_ofst);\n\n\terr = stm32_exti_set_type(d, type, &rtsr, &ftsr);\n\tif (err)\n\t\tgoto unspinlock;\n\n\twritel_relaxed(rtsr, base + stm32_bank->rtsr_ofst);\n\twritel_relaxed(ftsr, base + stm32_bank->ftsr_ofst);\n\nunspinlock:\n\tif (hwlock)\n\t\thwspin_unlock_in_atomic(hwlock);\nunlock:\n\traw_spin_unlock(&chip_data->rlock);\n\n\treturn err;\n}\n\nstatic int stm32_exti_h_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);\n\tu32 mask = BIT(d->hwirq % IRQS_PER_BANK);\n\n\traw_spin_lock(&chip_data->rlock);\n\n\tif (on)\n\t\tchip_data->wake_active |= mask;\n\telse\n\t\tchip_data->wake_active &= ~mask;\n\n\traw_spin_unlock(&chip_data->rlock);\n\n\treturn 0;\n}\n\nstatic int stm32_exti_h_set_affinity(struct irq_data *d,\n\t\t\t\t     const struct cpumask *dest, bool force)\n{\n\tif (d->parent_data->chip)\n\t\treturn irq_chip_set_affinity_parent(d, dest, force);\n\n\treturn IRQ_SET_MASK_OK_DONE;\n}\n\nstatic int __maybe_unused stm32_exti_h_suspend(void)\n{\n\tstruct stm32_exti_chip_data *chip_data;\n\tint i;\n\n\tfor (i = 0; i < stm32_host_data->drv_data->bank_nr; i++) {\n\t\tchip_data = &stm32_host_data->chips_data[i];\n\t\traw_spin_lock(&chip_data->rlock);\n\t\tstm32_chip_suspend(chip_data, chip_data->wake_active);\n\t\traw_spin_unlock(&chip_data->rlock);\n\t}\n\n\treturn 0;\n}\n\nstatic void __maybe_unused stm32_exti_h_resume(void)\n{\n\tstruct stm32_exti_chip_data *chip_data;\n\tint i;\n\n\tfor (i = 0; i < stm32_host_data->drv_data->bank_nr; i++) {\n\t\tchip_data = &stm32_host_data->chips_data[i];\n\t\traw_spin_lock(&chip_data->rlock);\n\t\tstm32_chip_resume(chip_data, chip_data->mask_cache);\n\t\traw_spin_unlock(&chip_data->rlock);\n\t}\n}\n\nstatic struct syscore_ops stm32_exti_h_syscore_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= stm32_exti_h_suspend,\n\t.resume\t\t= stm32_exti_h_resume,\n#endif\n};\n\nstatic void stm32_exti_h_syscore_init(struct stm32_exti_host_data *host_data)\n{\n\tstm32_host_data = host_data;\n\tregister_syscore_ops(&stm32_exti_h_syscore_ops);\n}\n\nstatic void stm32_exti_h_syscore_deinit(void)\n{\n\tunregister_syscore_ops(&stm32_exti_h_syscore_ops);\n}\n\nstatic int stm32_exti_h_retrigger(struct irq_data *d)\n{\n\tstruct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);\n\tconst struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;\n\tvoid __iomem *base = chip_data->host_data->base;\n\tu32 mask = BIT(d->hwirq % IRQS_PER_BANK);\n\n\twritel_relaxed(mask, base + stm32_bank->swier_ofst);\n\n\treturn 0;\n}\n\nstatic struct irq_chip stm32_exti_h_chip = {\n\t.name\t\t\t= \"stm32-exti-h\",\n\t.irq_eoi\t\t= stm32_exti_h_eoi,\n\t.irq_mask\t\t= stm32_exti_h_mask,\n\t.irq_unmask\t\t= stm32_exti_h_unmask,\n\t.irq_retrigger\t\t= stm32_exti_h_retrigger,\n\t.irq_set_type\t\t= stm32_exti_h_set_type,\n\t.irq_set_wake\t\t= stm32_exti_h_set_wake,\n\t.flags\t\t\t= IRQCHIP_MASK_ON_SUSPEND,\n\t.irq_set_affinity\t= IS_ENABLED(CONFIG_SMP) ? stm32_exti_h_set_affinity : NULL,\n};\n\nstatic struct irq_chip stm32_exti_h_chip_direct = {\n\t.name\t\t\t= \"stm32-exti-h-direct\",\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_ack\t\t= irq_chip_ack_parent,\n\t.irq_mask\t\t= stm32_exti_h_mask,\n\t.irq_unmask\t\t= stm32_exti_h_unmask,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n\t.irq_set_wake\t\t= stm32_exti_h_set_wake,\n\t.flags\t\t\t= IRQCHIP_MASK_ON_SUSPEND,\n\t.irq_set_affinity\t= IS_ENABLED(CONFIG_SMP) ? irq_chip_set_affinity_parent : NULL,\n};\n\nstatic int stm32_exti_h_domain_alloc(struct irq_domain *dm,\n\t\t\t\t     unsigned int virq,\n\t\t\t\t     unsigned int nr_irqs, void *data)\n{\n\tstruct stm32_exti_host_data *host_data = dm->host_data;\n\tstruct stm32_exti_chip_data *chip_data;\n\tu8 desc_irq;\n\tstruct irq_fwspec *fwspec = data;\n\tstruct irq_fwspec p_fwspec;\n\tirq_hw_number_t hwirq;\n\tint bank;\n\tu32 event_trg;\n\tstruct irq_chip *chip;\n\n\thwirq = fwspec->param[0];\n\tif (hwirq >= host_data->drv_data->bank_nr * IRQS_PER_BANK)\n\t\treturn -EINVAL;\n\n\tbank  = hwirq / IRQS_PER_BANK;\n\tchip_data = &host_data->chips_data[bank];\n\n\tevent_trg = readl_relaxed(host_data->base + chip_data->reg_bank->trg_ofst);\n\tchip = (event_trg & BIT(hwirq % IRQS_PER_BANK)) ?\n\t       &stm32_exti_h_chip : &stm32_exti_h_chip_direct;\n\n\tirq_domain_set_hwirq_and_chip(dm, virq, hwirq, chip, chip_data);\n\n\tif (!host_data->drv_data->desc_irqs)\n\t\treturn -EINVAL;\n\n\tdesc_irq = host_data->drv_data->desc_irqs[hwirq];\n\tif (desc_irq != EXTI_INVALID_IRQ) {\n\t\tp_fwspec.fwnode = dm->parent->fwnode;\n\t\tp_fwspec.param_count = 3;\n\t\tp_fwspec.param[0] = GIC_SPI;\n\t\tp_fwspec.param[1] = desc_irq;\n\t\tp_fwspec.param[2] = IRQ_TYPE_LEVEL_HIGH;\n\n\t\treturn irq_domain_alloc_irqs_parent(dm, virq, 1, &p_fwspec);\n\t}\n\n\treturn 0;\n}\n\nstatic struct\nstm32_exti_host_data *stm32_exti_host_init(const struct stm32_exti_drv_data *dd,\n\t\t\t\t\t   struct device_node *node)\n{\n\tstruct stm32_exti_host_data *host_data;\n\n\thost_data = kzalloc(sizeof(*host_data), GFP_KERNEL);\n\tif (!host_data)\n\t\treturn NULL;\n\n\thost_data->drv_data = dd;\n\thost_data->chips_data = kcalloc(dd->bank_nr,\n\t\t\t\t\tsizeof(struct stm32_exti_chip_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!host_data->chips_data)\n\t\tgoto free_host_data;\n\n\thost_data->base = of_iomap(node, 0);\n\tif (!host_data->base) {\n\t\tpr_err(\"%pOF: Unable to map registers\\n\", node);\n\t\tgoto free_chips_data;\n\t}\n\n\tstm32_host_data = host_data;\n\n\treturn host_data;\n\nfree_chips_data:\n\tkfree(host_data->chips_data);\nfree_host_data:\n\tkfree(host_data);\n\n\treturn NULL;\n}\n\nstatic struct\nstm32_exti_chip_data *stm32_exti_chip_init(struct stm32_exti_host_data *h_data,\n\t\t\t\t\t   u32 bank_idx,\n\t\t\t\t\t   struct device_node *node)\n{\n\tconst struct stm32_exti_bank *stm32_bank;\n\tstruct stm32_exti_chip_data *chip_data;\n\tvoid __iomem *base = h_data->base;\n\n\tstm32_bank = h_data->drv_data->exti_banks[bank_idx];\n\tchip_data = &h_data->chips_data[bank_idx];\n\tchip_data->host_data = h_data;\n\tchip_data->reg_bank = stm32_bank;\n\n\traw_spin_lock_init(&chip_data->rlock);\n\n\t \n\twritel_relaxed(0, base + stm32_bank->imr_ofst);\n\tif (stm32_bank->emr_ofst != UNDEF_REG)\n\t\twritel_relaxed(0, base + stm32_bank->emr_ofst);\n\n\tpr_info(\"%pOF: bank%d\\n\", node, bank_idx);\n\n\treturn chip_data;\n}\n\nstatic int __init stm32_exti_init(const struct stm32_exti_drv_data *drv_data,\n\t\t\t\t  struct device_node *node)\n{\n\tstruct stm32_exti_host_data *host_data;\n\tunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\n\tint nr_irqs, ret, i;\n\tstruct irq_chip_generic *gc;\n\tstruct irq_domain *domain;\n\n\thost_data = stm32_exti_host_init(drv_data, node);\n\tif (!host_data)\n\t\treturn -ENOMEM;\n\n\tdomain = irq_domain_add_linear(node, drv_data->bank_nr * IRQS_PER_BANK,\n\t\t\t\t       &irq_exti_domain_ops, NULL);\n\tif (!domain) {\n\t\tpr_err(\"%pOFn: Could not register interrupt domain.\\n\",\n\t\t       node);\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(domain, IRQS_PER_BANK, 1, \"exti\",\n\t\t\t\t\t     handle_edge_irq, clr, 0, 0);\n\tif (ret) {\n\t\tpr_err(\"%pOF: Could not allocate generic interrupt chip.\\n\",\n\t\t       node);\n\t\tgoto out_free_domain;\n\t}\n\n\tfor (i = 0; i < drv_data->bank_nr; i++) {\n\t\tconst struct stm32_exti_bank *stm32_bank;\n\t\tstruct stm32_exti_chip_data *chip_data;\n\n\t\tstm32_bank = drv_data->exti_banks[i];\n\t\tchip_data = stm32_exti_chip_init(host_data, i, node);\n\n\t\tgc = irq_get_domain_generic_chip(domain, i * IRQS_PER_BANK);\n\n\t\tgc->reg_base = host_data->base;\n\t\tgc->chip_types->type = IRQ_TYPE_EDGE_BOTH;\n\t\tgc->chip_types->chip.irq_ack = stm32_irq_ack;\n\t\tgc->chip_types->chip.irq_mask = irq_gc_mask_clr_bit;\n\t\tgc->chip_types->chip.irq_unmask = irq_gc_mask_set_bit;\n\t\tgc->chip_types->chip.irq_set_type = stm32_irq_set_type;\n\t\tgc->chip_types->chip.irq_set_wake = irq_gc_set_wake;\n\t\tgc->suspend = stm32_irq_suspend;\n\t\tgc->resume = stm32_irq_resume;\n\t\tgc->wake_enabled = IRQ_MSK(IRQS_PER_BANK);\n\n\t\tgc->chip_types->regs.mask = stm32_bank->imr_ofst;\n\t\tgc->private = (void *)chip_data;\n\t}\n\n\tnr_irqs = of_irq_count(node);\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tunsigned int irq = irq_of_parse_and_map(node, i);\n\n\t\tirq_set_handler_data(irq, domain);\n\t\tirq_set_chained_handler(irq, stm32_irq_handler);\n\t}\n\n\treturn 0;\n\nout_free_domain:\n\tirq_domain_remove(domain);\nout_unmap:\n\tiounmap(host_data->base);\n\tkfree(host_data->chips_data);\n\tkfree(host_data);\n\treturn ret;\n}\n\nstatic const struct irq_domain_ops stm32_exti_h_domain_ops = {\n\t.alloc\t= stm32_exti_h_domain_alloc,\n\t.free\t= irq_domain_free_irqs_common,\n\t.xlate = irq_domain_xlate_twocell,\n};\n\nstatic void stm32_exti_remove_irq(void *data)\n{\n\tstruct irq_domain *domain = data;\n\n\tirq_domain_remove(domain);\n}\n\nstatic int stm32_exti_remove(struct platform_device *pdev)\n{\n\tstm32_exti_h_syscore_deinit();\n\treturn 0;\n}\n\nstatic int stm32_exti_probe(struct platform_device *pdev)\n{\n\tint ret, i;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct irq_domain *parent_domain, *domain;\n\tstruct stm32_exti_host_data *host_data;\n\tconst struct stm32_exti_drv_data *drv_data;\n\n\thost_data = devm_kzalloc(dev, sizeof(*host_data), GFP_KERNEL);\n\tif (!host_data)\n\t\treturn -ENOMEM;\n\n\t \n\tret = of_hwspin_lock_get_id(np, 0);\n\tif (ret == -EPROBE_DEFER)\n\t\t \n\t\treturn ret;\n\n\tif (ret >= 0) {\n\t\thost_data->hwlock = devm_hwspin_lock_request_specific(dev, ret);\n\t\tif (!host_data->hwlock) {\n\t\t\tdev_err(dev, \"Failed to request hwspinlock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (ret != -ENOENT) {\n\t\t \n\t\tdev_err(dev, \"Failed to get hwspinlock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tdrv_data = of_device_get_match_data(dev);\n\tif (!drv_data) {\n\t\tdev_err(dev, \"no of match data\\n\");\n\t\treturn -ENODEV;\n\t}\n\thost_data->drv_data = drv_data;\n\n\thost_data->chips_data = devm_kcalloc(dev, drv_data->bank_nr,\n\t\t\t\t\t     sizeof(*host_data->chips_data),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!host_data->chips_data)\n\t\treturn -ENOMEM;\n\n\thost_data->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(host_data->base))\n\t\treturn PTR_ERR(host_data->base);\n\n\tfor (i = 0; i < drv_data->bank_nr; i++)\n\t\tstm32_exti_chip_init(host_data, i, np);\n\n\tparent_domain = irq_find_host(of_irq_find_parent(np));\n\tif (!parent_domain) {\n\t\tdev_err(dev, \"GIC interrupt-parent not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdomain = irq_domain_add_hierarchy(parent_domain, 0,\n\t\t\t\t\t  drv_data->bank_nr * IRQS_PER_BANK,\n\t\t\t\t\t  np, &stm32_exti_h_domain_ops,\n\t\t\t\t\t  host_data);\n\n\tif (!domain) {\n\t\tdev_err(dev, \"Could not register exti domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = devm_add_action_or_reset(dev, stm32_exti_remove_irq, domain);\n\tif (ret)\n\t\treturn ret;\n\n\tstm32_exti_h_syscore_init(host_data);\n\n\treturn 0;\n}\n\n \nstatic const struct of_device_id stm32_exti_ids[] = {\n\t{ .compatible = \"st,stm32mp1-exti\", .data = &stm32mp1_drv_data},\n\t{ .compatible = \"st,stm32mp13-exti\", .data = &stm32mp13_drv_data},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_exti_ids);\n\nstatic struct platform_driver stm32_exti_driver = {\n\t.probe\t\t= stm32_exti_probe,\n\t.remove\t\t= stm32_exti_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"stm32_exti\",\n\t\t.of_match_table = stm32_exti_ids,\n\t},\n};\n\nstatic int __init stm32_exti_arch_init(void)\n{\n\treturn platform_driver_register(&stm32_exti_driver);\n}\n\nstatic void __exit stm32_exti_arch_exit(void)\n{\n\treturn platform_driver_unregister(&stm32_exti_driver);\n}\n\narch_initcall(stm32_exti_arch_init);\nmodule_exit(stm32_exti_arch_exit);\n\n \nstatic int __init stm32f4_exti_of_init(struct device_node *np,\n\t\t\t\t       struct device_node *parent)\n{\n\treturn stm32_exti_init(&stm32f4xx_drv_data, np);\n}\n\nIRQCHIP_DECLARE(stm32f4_exti, \"st,stm32-exti\", stm32f4_exti_of_init);\n\nstatic int __init stm32h7_exti_of_init(struct device_node *np,\n\t\t\t\t       struct device_node *parent)\n{\n\treturn stm32_exti_init(&stm32h7xx_drv_data, np);\n}\n\nIRQCHIP_DECLARE(stm32h7_exti, \"st,stm32h7-exti\", stm32h7_exti_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}