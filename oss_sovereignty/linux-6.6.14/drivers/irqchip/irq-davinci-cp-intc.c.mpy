{
  "module_name": "irq-davinci-cp-intc.c",
  "hash_id": "643c67ff493416972bc0ecb270d51e1bc82514e203d30c80ee71158ffe54c3c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-davinci-cp-intc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/irq-davinci-cp-intc.h>\n#include <linux/irqdomain.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <asm/exception.h>\n\n#define DAVINCI_CP_INTC_CTRL\t\t\t0x04\n#define DAVINCI_CP_INTC_HOST_CTRL\t\t0x0c\n#define DAVINCI_CP_INTC_GLOBAL_ENABLE\t\t0x10\n#define DAVINCI_CP_INTC_SYS_STAT_IDX_CLR\t0x24\n#define DAVINCI_CP_INTC_SYS_ENABLE_IDX_SET\t0x28\n#define DAVINCI_CP_INTC_SYS_ENABLE_IDX_CLR\t0x2c\n#define DAVINCI_CP_INTC_HOST_ENABLE_IDX_SET\t0x34\n#define DAVINCI_CP_INTC_HOST_ENABLE_IDX_CLR\t0x38\n#define DAVINCI_CP_INTC_PRIO_IDX\t\t0x80\n#define DAVINCI_CP_INTC_SYS_STAT_CLR(n)\t\t(0x0280 + (n << 2))\n#define DAVINCI_CP_INTC_SYS_ENABLE_CLR(n)\t(0x0380 + (n << 2))\n#define DAVINCI_CP_INTC_CHAN_MAP(n)\t\t(0x0400 + (n << 2))\n#define DAVINCI_CP_INTC_SYS_POLARITY(n)\t\t(0x0d00 + (n << 2))\n#define DAVINCI_CP_INTC_SYS_TYPE(n)\t\t(0x0d80 + (n << 2))\n#define DAVINCI_CP_INTC_HOST_ENABLE(n)\t\t(0x1500 + (n << 2))\n#define DAVINCI_CP_INTC_PRI_INDX_MASK\t\tGENMASK(9, 0)\n#define DAVINCI_CP_INTC_GPIR_NONE\t\tBIT(31)\n\nstatic void __iomem *davinci_cp_intc_base;\nstatic struct irq_domain *davinci_cp_intc_irq_domain;\n\nstatic inline unsigned int davinci_cp_intc_read(unsigned int offset)\n{\n\treturn readl_relaxed(davinci_cp_intc_base + offset);\n}\n\nstatic inline void davinci_cp_intc_write(unsigned long value,\n\t\t\t\t\t unsigned int offset)\n{\n\twritel_relaxed(value, davinci_cp_intc_base + offset);\n}\n\nstatic void davinci_cp_intc_ack_irq(struct irq_data *d)\n{\n\tdavinci_cp_intc_write(d->hwirq, DAVINCI_CP_INTC_SYS_STAT_IDX_CLR);\n}\n\nstatic void davinci_cp_intc_mask_irq(struct irq_data *d)\n{\n\t \n\tdavinci_cp_intc_write(1, DAVINCI_CP_INTC_HOST_ENABLE_IDX_CLR);\n\tdavinci_cp_intc_write(d->hwirq, DAVINCI_CP_INTC_SYS_ENABLE_IDX_CLR);\n\tdavinci_cp_intc_write(1, DAVINCI_CP_INTC_HOST_ENABLE_IDX_SET);\n}\n\nstatic void davinci_cp_intc_unmask_irq(struct irq_data *d)\n{\n\tdavinci_cp_intc_write(d->hwirq, DAVINCI_CP_INTC_SYS_ENABLE_IDX_SET);\n}\n\nstatic int davinci_cp_intc_set_irq_type(struct irq_data *d,\n\t\t\t\t\tunsigned int flow_type)\n{\n\tunsigned int reg, mask, polarity, type;\n\n\treg = BIT_WORD(d->hwirq);\n\tmask = BIT_MASK(d->hwirq);\n\tpolarity = davinci_cp_intc_read(DAVINCI_CP_INTC_SYS_POLARITY(reg));\n\ttype = davinci_cp_intc_read(DAVINCI_CP_INTC_SYS_TYPE(reg));\n\n\tswitch (flow_type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tpolarity |= mask;\n\t\ttype |= mask;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tpolarity &= ~mask;\n\t\ttype |= mask;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tpolarity |= mask;\n\t\ttype &= ~mask;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tpolarity &= ~mask;\n\t\ttype &= ~mask;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdavinci_cp_intc_write(polarity, DAVINCI_CP_INTC_SYS_POLARITY(reg));\n\tdavinci_cp_intc_write(type, DAVINCI_CP_INTC_SYS_TYPE(reg));\n\n\treturn 0;\n}\n\nstatic struct irq_chip davinci_cp_intc_irq_chip = {\n\t.name\t\t= \"cp_intc\",\n\t.irq_ack\t= davinci_cp_intc_ack_irq,\n\t.irq_mask\t= davinci_cp_intc_mask_irq,\n\t.irq_unmask\t= davinci_cp_intc_unmask_irq,\n\t.irq_set_type\t= davinci_cp_intc_set_irq_type,\n\t.flags\t\t= IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic asmlinkage void __exception_irq_entry\ndavinci_cp_intc_handle_irq(struct pt_regs *regs)\n{\n\tint gpir, irqnr, none;\n\n\t \n\n\tgpir = davinci_cp_intc_read(DAVINCI_CP_INTC_PRIO_IDX);\n\tirqnr = gpir & DAVINCI_CP_INTC_PRI_INDX_MASK;\n\tnone = gpir & DAVINCI_CP_INTC_GPIR_NONE;\n\n\tif (unlikely(none)) {\n\t\tpr_err_once(\"%s: spurious irq!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tgeneric_handle_domain_irq(davinci_cp_intc_irq_domain, irqnr);\n}\n\nstatic int davinci_cp_intc_host_map(struct irq_domain *h, unsigned int virq,\n\t\t\t  irq_hw_number_t hw)\n{\n\tpr_debug(\"cp_intc_host_map(%d, 0x%lx)\\n\", virq, hw);\n\n\tirq_set_chip(virq, &davinci_cp_intc_irq_chip);\n\tirq_set_probe(virq);\n\tirq_set_handler(virq, handle_edge_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops davinci_cp_intc_irq_domain_ops = {\n\t.map = davinci_cp_intc_host_map,\n\t.xlate = irq_domain_xlate_onetwocell,\n};\n\nstatic int __init\ndavinci_cp_intc_do_init(const struct davinci_cp_intc_config *config,\n\t\t\tstruct device_node *node)\n{\n\tunsigned int num_regs = BITS_TO_LONGS(config->num_irqs);\n\tint offset, irq_base;\n\tvoid __iomem *req;\n\n\treq = request_mem_region(config->reg.start,\n\t\t\t\t resource_size(&config->reg),\n\t\t\t\t \"davinci-cp-intc\");\n\tif (!req) {\n\t\tpr_err(\"%s: register range busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tdavinci_cp_intc_base = ioremap(config->reg.start,\n\t\t\t\t       resource_size(&config->reg));\n\tif (!davinci_cp_intc_base) {\n\t\tpr_err(\"%s: unable to ioremap register range\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdavinci_cp_intc_write(0, DAVINCI_CP_INTC_GLOBAL_ENABLE);\n\n\t \n\tdavinci_cp_intc_write(0, DAVINCI_CP_INTC_HOST_ENABLE(0));\n\n\t \n\tfor (offset = 0; offset < num_regs; offset++)\n\t\tdavinci_cp_intc_write(~0,\n\t\t\tDAVINCI_CP_INTC_SYS_ENABLE_CLR(offset));\n\n\t \n\tdavinci_cp_intc_write(0, DAVINCI_CP_INTC_CTRL);\n\tdavinci_cp_intc_write(0, DAVINCI_CP_INTC_HOST_CTRL);\n\n\t \n\tfor (offset = 0; offset < num_regs; offset++)\n\t\tdavinci_cp_intc_write(~0,\n\t\t\tDAVINCI_CP_INTC_SYS_STAT_CLR(offset));\n\n\t \n\tdavinci_cp_intc_write(1, DAVINCI_CP_INTC_HOST_ENABLE_IDX_SET);\n\n\t \n\tnum_regs = (config->num_irqs + 3) >> 2;\t \n\tfor (offset = 0; offset < num_regs; offset++)\n\t\tdavinci_cp_intc_write(0x07070707,\n\t\t\tDAVINCI_CP_INTC_CHAN_MAP(offset));\n\n\tirq_base = irq_alloc_descs(-1, 0, config->num_irqs, 0);\n\tif (irq_base < 0) {\n\t\tpr_err(\"%s: unable to allocate interrupt descriptors: %d\\n\",\n\t\t       __func__, irq_base);\n\t\treturn irq_base;\n\t}\n\n\tdavinci_cp_intc_irq_domain = irq_domain_add_legacy(\n\t\t\t\t\tnode, config->num_irqs, irq_base, 0,\n\t\t\t\t\t&davinci_cp_intc_irq_domain_ops, NULL);\n\n\tif (!davinci_cp_intc_irq_domain) {\n\t\tpr_err(\"%s: unable to create an interrupt domain\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tset_handle_irq(davinci_cp_intc_handle_irq);\n\n\t \n\tdavinci_cp_intc_write(1, DAVINCI_CP_INTC_GLOBAL_ENABLE);\n\n\treturn 0;\n}\n\nint __init davinci_cp_intc_init(const struct davinci_cp_intc_config *config)\n{\n\treturn davinci_cp_intc_do_init(config, NULL);\n}\n\nstatic int __init davinci_cp_intc_of_init(struct device_node *node,\n\t\t\t\t\t  struct device_node *parent)\n{\n\tstruct davinci_cp_intc_config config = { };\n\tint ret;\n\n\tret = of_address_to_resource(node, 0, &config.reg);\n\tif (ret) {\n\t\tpr_err(\"%s: unable to get the register range from device-tree\\n\",\n\t\t       __func__);\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(node, \"ti,intc-size\", &config.num_irqs);\n\tif (ret) {\n\t\tpr_err(\"%s: unable to read the 'ti,intc-size' property\\n\",\n\t\t       __func__);\n\t\treturn ret;\n\t}\n\n\treturn davinci_cp_intc_do_init(&config, node);\n}\nIRQCHIP_DECLARE(cp_intc, \"ti,cp-intc\", davinci_cp_intc_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}