{
  "module_name": "irq-armada-370-xp.c",
  "hash_id": "22e49990453115423196d6a30fac265ae6e44d712e16452acc1e69df9f138a09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-armada-370-xp.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/cpu.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_pci.h>\n#include <linux/irqdomain.h>\n#include <linux/slab.h>\n#include <linux/syscore_ops.h>\n#include <linux/msi.h>\n#include <asm/mach/arch.h>\n#include <asm/exception.h>\n#include <asm/smp_plat.h>\n#include <asm/mach/irq.h>\n\n \n\n \n#define ARMADA_370_XP_INT_CONTROL\t\t(0x00)\n#define ARMADA_370_XP_SW_TRIG_INT_OFFS\t\t(0x04)\n#define ARMADA_370_XP_INT_SET_ENABLE_OFFS\t(0x30)\n#define ARMADA_370_XP_INT_CLEAR_ENABLE_OFFS\t(0x34)\n#define ARMADA_370_XP_INT_SOURCE_CTL(irq)\t(0x100 + irq*4)\n#define ARMADA_370_XP_INT_SOURCE_CPU_MASK\t0xF\n#define ARMADA_370_XP_INT_IRQ_FIQ_MASK(cpuid)\t((BIT(0) | BIT(8)) << cpuid)\n\n \n#define ARMADA_370_XP_IN_DRBEL_CAUSE_OFFS\t(0x08)\n#define ARMADA_370_XP_IN_DRBEL_MSK_OFFS\t\t(0x0c)\n#define ARMADA_375_PPI_CAUSE\t\t\t(0x10)\n#define ARMADA_370_XP_CPU_INTACK_OFFS\t\t(0x44)\n#define ARMADA_370_XP_INT_SET_MASK_OFFS\t\t(0x48)\n#define ARMADA_370_XP_INT_CLEAR_MASK_OFFS\t(0x4C)\n#define ARMADA_370_XP_INT_FABRIC_MASK_OFFS\t(0x54)\n#define ARMADA_370_XP_INT_CAUSE_PERF(cpu)\t(1 << cpu)\n\n#define ARMADA_370_XP_MAX_PER_CPU_IRQS\t\t(28)\n\n#define IPI_DOORBELL_START                      (0)\n#define IPI_DOORBELL_END                        (8)\n#define IPI_DOORBELL_MASK                       0xFF\n#define PCI_MSI_DOORBELL_START                  (16)\n#define PCI_MSI_DOORBELL_NR                     (16)\n#define PCI_MSI_DOORBELL_END                    (32)\n#define PCI_MSI_DOORBELL_MASK                   0xFFFF0000\n\nstatic void __iomem *per_cpu_int_base;\nstatic void __iomem *main_int_base;\nstatic struct irq_domain *armada_370_xp_mpic_domain;\nstatic u32 doorbell_mask_reg;\nstatic int parent_irq;\n#ifdef CONFIG_PCI_MSI\nstatic struct irq_domain *armada_370_xp_msi_domain;\nstatic struct irq_domain *armada_370_xp_msi_inner_domain;\nstatic DECLARE_BITMAP(msi_used, PCI_MSI_DOORBELL_NR);\nstatic DEFINE_MUTEX(msi_used_lock);\nstatic phys_addr_t msi_doorbell_addr;\n#endif\n\nstatic inline bool is_percpu_irq(irq_hw_number_t irq)\n{\n\tif (irq <= ARMADA_370_XP_MAX_PER_CPU_IRQS)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void armada_370_xp_irq_mask(struct irq_data *d)\n{\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tif (!is_percpu_irq(hwirq))\n\t\twritel(hwirq, main_int_base +\n\t\t\t\tARMADA_370_XP_INT_CLEAR_ENABLE_OFFS);\n\telse\n\t\twritel(hwirq, per_cpu_int_base +\n\t\t\t\tARMADA_370_XP_INT_SET_MASK_OFFS);\n}\n\nstatic void armada_370_xp_irq_unmask(struct irq_data *d)\n{\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tif (!is_percpu_irq(hwirq))\n\t\twritel(hwirq, main_int_base +\n\t\t\t\tARMADA_370_XP_INT_SET_ENABLE_OFFS);\n\telse\n\t\twritel(hwirq, per_cpu_int_base +\n\t\t\t\tARMADA_370_XP_INT_CLEAR_MASK_OFFS);\n}\n\n#ifdef CONFIG_PCI_MSI\n\nstatic struct irq_chip armada_370_xp_msi_irq_chip = {\n\t.name = \"MPIC MSI\",\n\t.irq_mask = pci_msi_mask_irq,\n\t.irq_unmask = pci_msi_unmask_irq,\n};\n\nstatic struct msi_domain_info armada_370_xp_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_MULTI_PCI_MSI | MSI_FLAG_PCI_MSIX),\n\t.chip\t= &armada_370_xp_msi_irq_chip,\n};\n\nstatic void armada_370_xp_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tunsigned int cpu = cpumask_first(irq_data_get_effective_affinity_mask(data));\n\n\tmsg->address_lo = lower_32_bits(msi_doorbell_addr);\n\tmsg->address_hi = upper_32_bits(msi_doorbell_addr);\n\tmsg->data = BIT(cpu + 8) | (data->hwirq + PCI_MSI_DOORBELL_START);\n}\n\nstatic int armada_370_xp_msi_set_affinity(struct irq_data *irq_data,\n\t\t\t\t\t  const struct cpumask *mask, bool force)\n{\n\tunsigned int cpu;\n\n\tif (!force)\n\t\tcpu = cpumask_any_and(mask, cpu_online_mask);\n\telse\n\t\tcpu = cpumask_first(mask);\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tirq_data_update_effective_affinity(irq_data, cpumask_of(cpu));\n\n\treturn IRQ_SET_MASK_OK;\n}\n\nstatic struct irq_chip armada_370_xp_msi_bottom_irq_chip = {\n\t.name\t\t\t= \"MPIC MSI\",\n\t.irq_compose_msi_msg\t= armada_370_xp_compose_msi_msg,\n\t.irq_set_affinity\t= armada_370_xp_msi_set_affinity,\n};\n\nstatic int armada_370_xp_msi_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t   unsigned int nr_irqs, void *args)\n{\n\tint hwirq, i;\n\n\tmutex_lock(&msi_used_lock);\n\thwirq = bitmap_find_free_region(msi_used, PCI_MSI_DOORBELL_NR,\n\t\t\t\t\torder_base_2(nr_irqs));\n\tmutex_unlock(&msi_used_lock);\n\n\tif (hwirq < 0)\n\t\treturn -ENOSPC;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_domain_set_info(domain, virq + i, hwirq + i,\n\t\t\t\t    &armada_370_xp_msi_bottom_irq_chip,\n\t\t\t\t    domain->host_data, handle_simple_irq,\n\t\t\t\t    NULL, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic void armada_370_xp_msi_free(struct irq_domain *domain,\n\t\t\t\t   unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\n\tmutex_lock(&msi_used_lock);\n\tbitmap_release_region(msi_used, d->hwirq, order_base_2(nr_irqs));\n\tmutex_unlock(&msi_used_lock);\n}\n\nstatic const struct irq_domain_ops armada_370_xp_msi_domain_ops = {\n\t.alloc\t= armada_370_xp_msi_alloc,\n\t.free\t= armada_370_xp_msi_free,\n};\n\nstatic void armada_370_xp_msi_reenable_percpu(void)\n{\n\tu32 reg;\n\n\t \n\treg = readl(per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS)\n\t\t| PCI_MSI_DOORBELL_MASK;\n\twritel(reg, per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);\n\t \n\twritel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\n}\n\nstatic int armada_370_xp_msi_init(struct device_node *node,\n\t\t\t\t  phys_addr_t main_int_phys_base)\n{\n\tmsi_doorbell_addr = main_int_phys_base +\n\t\tARMADA_370_XP_SW_TRIG_INT_OFFS;\n\n\tarmada_370_xp_msi_inner_domain =\n\t\tirq_domain_add_linear(NULL, PCI_MSI_DOORBELL_NR,\n\t\t\t\t      &armada_370_xp_msi_domain_ops, NULL);\n\tif (!armada_370_xp_msi_inner_domain)\n\t\treturn -ENOMEM;\n\n\tarmada_370_xp_msi_domain =\n\t\tpci_msi_create_irq_domain(of_node_to_fwnode(node),\n\t\t\t\t\t  &armada_370_xp_msi_domain_info,\n\t\t\t\t\t  armada_370_xp_msi_inner_domain);\n\tif (!armada_370_xp_msi_domain) {\n\t\tirq_domain_remove(armada_370_xp_msi_inner_domain);\n\t\treturn -ENOMEM;\n\t}\n\n\tarmada_370_xp_msi_reenable_percpu();\n\n\treturn 0;\n}\n#else\nstatic void armada_370_xp_msi_reenable_percpu(void) {}\n\nstatic inline int armada_370_xp_msi_init(struct device_node *node,\n\t\t\t\t\t phys_addr_t main_int_phys_base)\n{\n\treturn 0;\n}\n#endif\n\nstatic void armada_xp_mpic_perf_init(void)\n{\n\tunsigned long cpuid;\n\n\t \n\tif (!of_machine_is_compatible(\"marvell,armada-370-xp\"))\n\t\treturn;\n\n\tcpuid = cpu_logical_map(smp_processor_id());\n\n\t \n\twritel(ARMADA_370_XP_INT_CAUSE_PERF(cpuid),\n\t       per_cpu_int_base + ARMADA_370_XP_INT_FABRIC_MASK_OFFS);\n}\n\n#ifdef CONFIG_SMP\nstatic struct irq_domain *ipi_domain;\n\nstatic void armada_370_xp_ipi_mask(struct irq_data *d)\n{\n\tu32 reg;\n\treg = readl(per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);\n\treg &= ~BIT(d->hwirq);\n\twritel(reg, per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);\n}\n\nstatic void armada_370_xp_ipi_unmask(struct irq_data *d)\n{\n\tu32 reg;\n\treg = readl(per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);\n\treg |= BIT(d->hwirq);\n\twritel(reg, per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);\n}\n\nstatic void armada_370_xp_ipi_send_mask(struct irq_data *d,\n\t\t\t\t\tconst struct cpumask *mask)\n{\n\tunsigned long map = 0;\n\tint cpu;\n\n\t \n\tfor_each_cpu(cpu, mask)\n\t\tmap |= 1 << cpu_logical_map(cpu);\n\n\t \n\tdsb();\n\n\t \n\twritel((map << 8) | d->hwirq, main_int_base +\n\t\tARMADA_370_XP_SW_TRIG_INT_OFFS);\n}\n\nstatic void armada_370_xp_ipi_ack(struct irq_data *d)\n{\n\twritel(~BIT(d->hwirq), per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);\n}\n\nstatic struct irq_chip ipi_irqchip = {\n\t.name\t\t= \"IPI\",\n\t.irq_ack\t= armada_370_xp_ipi_ack,\n\t.irq_mask\t= armada_370_xp_ipi_mask,\n\t.irq_unmask\t= armada_370_xp_ipi_unmask,\n\t.ipi_send_mask\t= armada_370_xp_ipi_send_mask,\n};\n\nstatic int armada_370_xp_ipi_alloc(struct irq_domain *d,\n\t\t\t\t\t unsigned int virq,\n\t\t\t\t\t unsigned int nr_irqs, void *args)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_percpu_devid(virq + i);\n\t\tirq_domain_set_info(d, virq + i, i, &ipi_irqchip,\n\t\t\t\t    d->host_data,\n\t\t\t\t    handle_percpu_devid_irq,\n\t\t\t\t    NULL, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic void armada_370_xp_ipi_free(struct irq_domain *d,\n\t\t\t\t\t unsigned int virq,\n\t\t\t\t\t unsigned int nr_irqs)\n{\n\t \n}\n\nstatic const struct irq_domain_ops ipi_domain_ops = {\n\t.alloc\t= armada_370_xp_ipi_alloc,\n\t.free\t= armada_370_xp_ipi_free,\n};\n\nstatic void ipi_resume(void)\n{\n\tint i;\n\n\tfor (i = 0; i < IPI_DOORBELL_END; i++) {\n\t\tint irq;\n\n\t\tirq = irq_find_mapping(ipi_domain, i);\n\t\tif (irq <= 0)\n\t\t\tcontinue;\n\t\tif (irq_percpu_is_enabled(irq)) {\n\t\t\tstruct irq_data *d;\n\t\t\td = irq_domain_get_irq_data(ipi_domain, irq);\n\t\t\tarmada_370_xp_ipi_unmask(d);\n\t\t}\n\t}\n}\n\nstatic __init void armada_xp_ipi_init(struct device_node *node)\n{\n\tint base_ipi;\n\n\tipi_domain = irq_domain_create_linear(of_node_to_fwnode(node),\n\t\t\t\t\t      IPI_DOORBELL_END,\n\t\t\t\t\t      &ipi_domain_ops, NULL);\n\tif (WARN_ON(!ipi_domain))\n\t\treturn;\n\n\tirq_domain_update_bus_token(ipi_domain, DOMAIN_BUS_IPI);\n\tbase_ipi = irq_domain_alloc_irqs(ipi_domain, IPI_DOORBELL_END, NUMA_NO_NODE, NULL);\n\tif (WARN_ON(!base_ipi))\n\t\treturn;\n\n\tset_smp_ipi_range(base_ipi, IPI_DOORBELL_END);\n}\n\nstatic DEFINE_RAW_SPINLOCK(irq_controller_lock);\n\nstatic int armada_xp_set_affinity(struct irq_data *d,\n\t\t\t\t  const struct cpumask *mask_val, bool force)\n{\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long reg, mask;\n\tint cpu;\n\n\t \n\tcpu = cpumask_any_and(mask_val, cpu_online_mask);\n\tmask = 1UL << cpu_logical_map(cpu);\n\n\traw_spin_lock(&irq_controller_lock);\n\treg = readl(main_int_base + ARMADA_370_XP_INT_SOURCE_CTL(hwirq));\n\treg = (reg & (~ARMADA_370_XP_INT_SOURCE_CPU_MASK)) | mask;\n\twritel(reg, main_int_base + ARMADA_370_XP_INT_SOURCE_CTL(hwirq));\n\traw_spin_unlock(&irq_controller_lock);\n\n\tirq_data_update_effective_affinity(d, cpumask_of(cpu));\n\n\treturn IRQ_SET_MASK_OK;\n}\n\nstatic void armada_xp_mpic_smp_cpu_init(void)\n{\n\tu32 control;\n\tint nr_irqs, i;\n\n\tcontrol = readl(main_int_base + ARMADA_370_XP_INT_CONTROL);\n\tnr_irqs = (control >> 2) & 0x3ff;\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\twritel(i, per_cpu_int_base + ARMADA_370_XP_INT_SET_MASK_OFFS);\n\n\t \n\twritel(0, per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);\n\n\t \n\twritel(0, per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);\n\n\t \n\twritel(0, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\n}\n\nstatic void armada_xp_mpic_reenable_percpu(void)\n{\n\tunsigned int irq;\n\n\t \n\tfor (irq = 0; irq < ARMADA_370_XP_MAX_PER_CPU_IRQS; irq++) {\n\t\tstruct irq_data *data;\n\t\tint virq;\n\n\t\tvirq = irq_linear_revmap(armada_370_xp_mpic_domain, irq);\n\t\tif (virq == 0)\n\t\t\tcontinue;\n\n\t\tdata = irq_get_irq_data(virq);\n\n\t\tif (!irq_percpu_is_enabled(virq))\n\t\t\tcontinue;\n\n\t\tarmada_370_xp_irq_unmask(data);\n\t}\n\n\tipi_resume();\n\n\tarmada_370_xp_msi_reenable_percpu();\n}\n\nstatic int armada_xp_mpic_starting_cpu(unsigned int cpu)\n{\n\tarmada_xp_mpic_perf_init();\n\tarmada_xp_mpic_smp_cpu_init();\n\tarmada_xp_mpic_reenable_percpu();\n\treturn 0;\n}\n\nstatic int mpic_cascaded_starting_cpu(unsigned int cpu)\n{\n\tarmada_xp_mpic_perf_init();\n\tarmada_xp_mpic_reenable_percpu();\n\tenable_percpu_irq(parent_irq, IRQ_TYPE_NONE);\n\treturn 0;\n}\n#else\nstatic void armada_xp_mpic_smp_cpu_init(void) {}\nstatic void ipi_resume(void) {}\n#endif\n\nstatic struct irq_chip armada_370_xp_irq_chip = {\n\t.name\t\t= \"MPIC\",\n\t.irq_mask       = armada_370_xp_irq_mask,\n\t.irq_mask_ack   = armada_370_xp_irq_mask,\n\t.irq_unmask     = armada_370_xp_irq_unmask,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity = armada_xp_set_affinity,\n#endif\n\t.flags\t\t= IRQCHIP_SKIP_SET_WAKE | IRQCHIP_MASK_ON_SUSPEND,\n};\n\nstatic int armada_370_xp_mpic_irq_map(struct irq_domain *h,\n\t\t\t\t      unsigned int virq, irq_hw_number_t hw)\n{\n\tarmada_370_xp_irq_mask(irq_get_irq_data(virq));\n\tif (!is_percpu_irq(hw))\n\t\twritel(hw, per_cpu_int_base +\n\t\t\tARMADA_370_XP_INT_CLEAR_MASK_OFFS);\n\telse\n\t\twritel(hw, main_int_base + ARMADA_370_XP_INT_SET_ENABLE_OFFS);\n\tirq_set_status_flags(virq, IRQ_LEVEL);\n\n\tif (is_percpu_irq(hw)) {\n\t\tirq_set_percpu_devid(virq);\n\t\tirq_set_chip_and_handler(virq, &armada_370_xp_irq_chip,\n\t\t\t\t\thandle_percpu_devid_irq);\n\t} else {\n\t\tirq_set_chip_and_handler(virq, &armada_370_xp_irq_chip,\n\t\t\t\t\thandle_level_irq);\n\t\tirqd_set_single_target(irq_desc_get_irq_data(irq_to_desc(virq)));\n\t}\n\tirq_set_probe(virq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops armada_370_xp_mpic_irq_ops = {\n\t.map = armada_370_xp_mpic_irq_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\n#ifdef CONFIG_PCI_MSI\nstatic void armada_370_xp_handle_msi_irq(struct pt_regs *regs, bool is_chained)\n{\n\tu32 msimask, msinr;\n\n\tmsimask = readl_relaxed(per_cpu_int_base +\n\t\t\t\tARMADA_370_XP_IN_DRBEL_CAUSE_OFFS)\n\t\t& PCI_MSI_DOORBELL_MASK;\n\n\twritel(~msimask, per_cpu_int_base +\n\t       ARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);\n\n\tfor (msinr = PCI_MSI_DOORBELL_START;\n\t     msinr < PCI_MSI_DOORBELL_END; msinr++) {\n\t\tunsigned int irq;\n\n\t\tif (!(msimask & BIT(msinr)))\n\t\t\tcontinue;\n\n\t\tirq = msinr - PCI_MSI_DOORBELL_START;\n\n\t\tgeneric_handle_domain_irq(armada_370_xp_msi_inner_domain, irq);\n\t}\n}\n#else\nstatic void armada_370_xp_handle_msi_irq(struct pt_regs *r, bool b) {}\n#endif\n\nstatic void armada_370_xp_mpic_handle_cascade_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned long irqmap, irqn, irqsrc, cpuid;\n\n\tchained_irq_enter(chip, desc);\n\n\tirqmap = readl_relaxed(per_cpu_int_base + ARMADA_375_PPI_CAUSE);\n\tcpuid = cpu_logical_map(smp_processor_id());\n\n\tfor_each_set_bit(irqn, &irqmap, BITS_PER_LONG) {\n\t\tirqsrc = readl_relaxed(main_int_base +\n\t\t\t\t       ARMADA_370_XP_INT_SOURCE_CTL(irqn));\n\n\t\t \n\t\tif (!(irqsrc & ARMADA_370_XP_INT_IRQ_FIQ_MASK(cpuid)))\n\t\t\tcontinue;\n\n\t\tif (irqn == 1) {\n\t\t\tarmada_370_xp_handle_msi_irq(NULL, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgeneric_handle_domain_irq(armada_370_xp_mpic_domain, irqn);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void __exception_irq_entry\narmada_370_xp_handle_irq(struct pt_regs *regs)\n{\n\tu32 irqstat, irqnr;\n\n\tdo {\n\t\tirqstat = readl_relaxed(per_cpu_int_base +\n\t\t\t\t\tARMADA_370_XP_CPU_INTACK_OFFS);\n\t\tirqnr = irqstat & 0x3FF;\n\n\t\tif (irqnr > 1022)\n\t\t\tbreak;\n\n\t\tif (irqnr > 1) {\n\t\t\tgeneric_handle_domain_irq(armada_370_xp_mpic_domain,\n\t\t\t\t\t\t  irqnr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (irqnr == 1)\n\t\t\tarmada_370_xp_handle_msi_irq(regs, false);\n\n#ifdef CONFIG_SMP\n\t\t \n\t\tif (irqnr == 0) {\n\t\t\tunsigned long ipimask;\n\t\t\tint ipi;\n\n\t\t\tipimask = readl_relaxed(per_cpu_int_base +\n\t\t\t\t\t\tARMADA_370_XP_IN_DRBEL_CAUSE_OFFS)\n\t\t\t\t& IPI_DOORBELL_MASK;\n\n\t\t\tfor_each_set_bit(ipi, &ipimask, IPI_DOORBELL_END)\n\t\t\t\tgeneric_handle_domain_irq(ipi_domain, ipi);\n\t\t}\n#endif\n\n\t} while (1);\n}\n\nstatic int armada_370_xp_mpic_suspend(void)\n{\n\tdoorbell_mask_reg = readl(per_cpu_int_base +\n\t\t\t\t  ARMADA_370_XP_IN_DRBEL_MSK_OFFS);\n\treturn 0;\n}\n\nstatic void armada_370_xp_mpic_resume(void)\n{\n\tint nirqs;\n\tirq_hw_number_t irq;\n\n\t \n\tnirqs = (readl(main_int_base + ARMADA_370_XP_INT_CONTROL) >> 2) & 0x3ff;\n\tfor (irq = 0; irq < nirqs; irq++) {\n\t\tstruct irq_data *data;\n\t\tint virq;\n\n\t\tvirq = irq_linear_revmap(armada_370_xp_mpic_domain, irq);\n\t\tif (virq == 0)\n\t\t\tcontinue;\n\n\t\tdata = irq_get_irq_data(virq);\n\n\t\tif (!is_percpu_irq(irq)) {\n\t\t\t \n\t\t\twritel(irq, per_cpu_int_base +\n\t\t\t       ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\n\t\t\tif (!irqd_irq_disabled(data))\n\t\t\t\tarmada_370_xp_irq_unmask(data);\n\t\t} else {\n\t\t\t \n\t\t\twritel(irq, main_int_base +\n\t\t\t       ARMADA_370_XP_INT_SET_ENABLE_OFFS);\n\n\t\t\t \n\t\t\tif (irq_percpu_is_enabled(virq))\n\t\t\t\tarmada_370_xp_irq_unmask(data);\n\t\t}\n\t}\n\n\t \n\twritel(doorbell_mask_reg,\n\t       per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);\n\tif (doorbell_mask_reg & IPI_DOORBELL_MASK)\n\t\twritel(0, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\n\tif (doorbell_mask_reg & PCI_MSI_DOORBELL_MASK)\n\t\twritel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\n\n\tipi_resume();\n}\n\nstatic struct syscore_ops armada_370_xp_mpic_syscore_ops = {\n\t.suspend\t= armada_370_xp_mpic_suspend,\n\t.resume\t\t= armada_370_xp_mpic_resume,\n};\n\nstatic int __init armada_370_xp_mpic_of_init(struct device_node *node,\n\t\t\t\t\t     struct device_node *parent)\n{\n\tstruct resource main_int_res, per_cpu_int_res;\n\tint nr_irqs, i;\n\tu32 control;\n\n\tBUG_ON(of_address_to_resource(node, 0, &main_int_res));\n\tBUG_ON(of_address_to_resource(node, 1, &per_cpu_int_res));\n\n\tBUG_ON(!request_mem_region(main_int_res.start,\n\t\t\t\t   resource_size(&main_int_res),\n\t\t\t\t   node->full_name));\n\tBUG_ON(!request_mem_region(per_cpu_int_res.start,\n\t\t\t\t   resource_size(&per_cpu_int_res),\n\t\t\t\t   node->full_name));\n\n\tmain_int_base = ioremap(main_int_res.start,\n\t\t\t\tresource_size(&main_int_res));\n\tBUG_ON(!main_int_base);\n\n\tper_cpu_int_base = ioremap(per_cpu_int_res.start,\n\t\t\t\t   resource_size(&per_cpu_int_res));\n\tBUG_ON(!per_cpu_int_base);\n\n\tcontrol = readl(main_int_base + ARMADA_370_XP_INT_CONTROL);\n\tnr_irqs = (control >> 2) & 0x3ff;\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\twritel(i, main_int_base + ARMADA_370_XP_INT_CLEAR_ENABLE_OFFS);\n\n\tarmada_370_xp_mpic_domain =\n\t\tirq_domain_add_linear(node, nr_irqs,\n\t\t\t\t&armada_370_xp_mpic_irq_ops, NULL);\n\tBUG_ON(!armada_370_xp_mpic_domain);\n\tirq_domain_update_bus_token(armada_370_xp_mpic_domain, DOMAIN_BUS_WIRED);\n\n\t \n\tarmada_xp_mpic_perf_init();\n\tarmada_xp_mpic_smp_cpu_init();\n\n\tarmada_370_xp_msi_init(node, main_int_res.start);\n\n\tparent_irq = irq_of_parse_and_map(node, 0);\n\tif (parent_irq <= 0) {\n\t\tirq_set_default_host(armada_370_xp_mpic_domain);\n\t\tset_handle_irq(armada_370_xp_handle_irq);\n#ifdef CONFIG_SMP\n\t\tarmada_xp_ipi_init(node);\n\t\tcpuhp_setup_state_nocalls(CPUHP_AP_IRQ_ARMADA_XP_STARTING,\n\t\t\t\t\t  \"irqchip/armada/ipi:starting\",\n\t\t\t\t\t  armada_xp_mpic_starting_cpu, NULL);\n#endif\n\t} else {\n#ifdef CONFIG_SMP\n\t\tcpuhp_setup_state_nocalls(CPUHP_AP_IRQ_ARMADA_XP_STARTING,\n\t\t\t\t\t  \"irqchip/armada/cascade:starting\",\n\t\t\t\t\t  mpic_cascaded_starting_cpu, NULL);\n#endif\n\t\tirq_set_chained_handler(parent_irq,\n\t\t\t\t\tarmada_370_xp_mpic_handle_cascade_irq);\n\t}\n\n\tregister_syscore_ops(&armada_370_xp_mpic_syscore_ops);\n\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(armada_370_xp_mpic, \"marvell,mpic\", armada_370_xp_mpic_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}