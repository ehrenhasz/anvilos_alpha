{
  "module_name": "irq-imgpdc.c",
  "hash_id": "dc15c3ea0945a75caaabfbc57dc6996b3154519089b282e20b77932d07292661",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-imgpdc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n \n\n#define PDC_IRQ_STATUS\t\t\t0x310\n#define PDC_IRQ_ENABLE\t\t\t0x314\n#define PDC_IRQ_CLEAR\t\t\t0x318\n#define PDC_IRQ_ROUTE\t\t\t0x31c\n#define PDC_SYS_WAKE_BASE\t\t0x330\n#define PDC_SYS_WAKE_STRIDE\t\t0x8\n#define PDC_SYS_WAKE_CONFIG_BASE\t0x334\n#define PDC_SYS_WAKE_CONFIG_STRIDE\t0x8\n\n \n\n#define PDC_IRQ_SYS3\t\t\t0x08\n#define PDC_IRQ_SYS2\t\t\t0x04\n#define PDC_IRQ_SYS1\t\t\t0x02\n#define PDC_IRQ_SYS0\t\t\t0x01\n#define PDC_IRQ_ROUTE_WU_EN_SYS3\t0x08000000\n#define PDC_IRQ_ROUTE_WU_EN_SYS2\t0x04000000\n#define PDC_IRQ_ROUTE_WU_EN_SYS1\t0x02000000\n#define PDC_IRQ_ROUTE_WU_EN_SYS0\t0x01000000\n#define PDC_IRQ_ROUTE_WU_EN_WD\t\t0x00040000\n#define PDC_IRQ_ROUTE_WU_EN_IR\t\t0x00020000\n#define PDC_IRQ_ROUTE_WU_EN_RTC\t\t0x00010000\n#define PDC_IRQ_ROUTE_EXT_EN_SYS3\t0x00000800\n#define PDC_IRQ_ROUTE_EXT_EN_SYS2\t0x00000400\n#define PDC_IRQ_ROUTE_EXT_EN_SYS1\t0x00000200\n#define PDC_IRQ_ROUTE_EXT_EN_SYS0\t0x00000100\n#define PDC_IRQ_ROUTE_EXT_EN_WD\t\t0x00000004\n#define PDC_IRQ_ROUTE_EXT_EN_IR\t\t0x00000002\n#define PDC_IRQ_ROUTE_EXT_EN_RTC\t0x00000001\n#define PDC_SYS_WAKE_RESET\t\t0x00000010\n#define PDC_SYS_WAKE_INT_MODE\t\t0x0000000e\n#define PDC_SYS_WAKE_INT_MODE_SHIFT\t1\n#define PDC_SYS_WAKE_PIN_VAL\t\t0x00000001\n\n \n\n#define PDC_SYS_WAKE_INT_LOW\t\t0x0\n#define PDC_SYS_WAKE_INT_HIGH\t\t0x1\n#define PDC_SYS_WAKE_INT_DOWN\t\t0x2\n#define PDC_SYS_WAKE_INT_UP\t\t0x3\n#define PDC_SYS_WAKE_INT_CHANGE\t\t0x6\n#define PDC_SYS_WAKE_INT_NONE\t\t0x4\n\n \nstruct pdc_intc_priv {\n\tunsigned int\t\tnr_perips;\n\tunsigned int\t\tnr_syswakes;\n\tunsigned int\t\t*perip_irqs;\n\tunsigned int\t\tsyswake_irq;\n\tstruct irq_domain\t*domain;\n\tvoid __iomem\t\t*pdc_base;\n\n\tu32\t\t\tirq_route;\n\traw_spinlock_t\t\tlock;\n};\n\nstatic void pdc_write(struct pdc_intc_priv *priv, unsigned int reg_offs,\n\t\t      unsigned int data)\n{\n\tiowrite32(data, priv->pdc_base + reg_offs);\n}\n\nstatic unsigned int pdc_read(struct pdc_intc_priv *priv,\n\t\t\t     unsigned int reg_offs)\n{\n\treturn ioread32(priv->pdc_base + reg_offs);\n}\n\n \n\n#define SYS0_HWIRQ\t8\n\nstatic unsigned int hwirq_is_syswake(irq_hw_number_t hw)\n{\n\treturn hw >= SYS0_HWIRQ;\n}\n\nstatic unsigned int hwirq_to_syswake(irq_hw_number_t hw)\n{\n\treturn hw - SYS0_HWIRQ;\n}\n\nstatic irq_hw_number_t syswake_to_hwirq(unsigned int syswake)\n{\n\treturn SYS0_HWIRQ + syswake;\n}\n\nstatic struct pdc_intc_priv *irqd_to_priv(struct irq_data *data)\n{\n\treturn (struct pdc_intc_priv *)data->domain->host_data;\n}\n\n \n\nstatic void perip_irq_mask(struct irq_data *data)\n{\n\tstruct pdc_intc_priv *priv = irqd_to_priv(data);\n\n\traw_spin_lock(&priv->lock);\n\tpriv->irq_route &= ~data->mask;\n\tpdc_write(priv, PDC_IRQ_ROUTE, priv->irq_route);\n\traw_spin_unlock(&priv->lock);\n}\n\nstatic void perip_irq_unmask(struct irq_data *data)\n{\n\tstruct pdc_intc_priv *priv = irqd_to_priv(data);\n\n\traw_spin_lock(&priv->lock);\n\tpriv->irq_route |= data->mask;\n\tpdc_write(priv, PDC_IRQ_ROUTE, priv->irq_route);\n\traw_spin_unlock(&priv->lock);\n}\n\nstatic int syswake_irq_set_type(struct irq_data *data, unsigned int flow_type)\n{\n\tstruct pdc_intc_priv *priv = irqd_to_priv(data);\n\tunsigned int syswake = hwirq_to_syswake(data->hwirq);\n\tunsigned int irq_mode;\n\tunsigned int soc_sys_wake_regoff, soc_sys_wake;\n\n\t \n\tswitch (flow_type) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tirq_mode = PDC_SYS_WAKE_INT_CHANGE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tirq_mode = PDC_SYS_WAKE_INT_UP;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tirq_mode = PDC_SYS_WAKE_INT_DOWN;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tirq_mode = PDC_SYS_WAKE_INT_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tirq_mode = PDC_SYS_WAKE_INT_LOW;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock(&priv->lock);\n\n\t \n\tsoc_sys_wake_regoff = PDC_SYS_WAKE_BASE + syswake*PDC_SYS_WAKE_STRIDE;\n\tsoc_sys_wake = pdc_read(priv, soc_sys_wake_regoff);\n\tsoc_sys_wake &= ~PDC_SYS_WAKE_INT_MODE;\n\tsoc_sys_wake |= irq_mode << PDC_SYS_WAKE_INT_MODE_SHIFT;\n\tpdc_write(priv, soc_sys_wake_regoff, soc_sys_wake);\n\n\t \n\tirq_setup_alt_chip(data, flow_type);\n\n\traw_spin_unlock(&priv->lock);\n\n\treturn 0;\n}\n\n \nstatic int pdc_irq_set_wake(struct irq_data *data, unsigned int on)\n{\n\tstruct pdc_intc_priv *priv = irqd_to_priv(data);\n\tirq_hw_number_t hw = data->hwirq;\n\tunsigned int mask = (1 << 16) << hw;\n\tunsigned int dst_irq;\n\n\traw_spin_lock(&priv->lock);\n\tif (on)\n\t\tpriv->irq_route |= mask;\n\telse\n\t\tpriv->irq_route &= ~mask;\n\tpdc_write(priv, PDC_IRQ_ROUTE, priv->irq_route);\n\traw_spin_unlock(&priv->lock);\n\n\t \n\tif (hwirq_is_syswake(hw))\n\t\tdst_irq = priv->syswake_irq;\n\telse\n\t\tdst_irq = priv->perip_irqs[hw];\n\tirq_set_irq_wake(dst_irq, on);\n\n\treturn 0;\n}\n\nstatic void pdc_intc_perip_isr(struct irq_desc *desc)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct pdc_intc_priv *priv;\n\tunsigned int i;\n\n\tpriv = (struct pdc_intc_priv *)irq_desc_get_handler_data(desc);\n\n\t \n\tfor (i = 0; i < priv->nr_perips; ++i)\n\t\tif (irq == priv->perip_irqs[i])\n\t\t\tgoto found;\n\n\t \n\treturn;\nfound:\n\n\t \n\tgeneric_handle_domain_irq(priv->domain, i);\n}\n\nstatic void pdc_intc_syswake_isr(struct irq_desc *desc)\n{\n\tstruct pdc_intc_priv *priv;\n\tunsigned int syswake;\n\tunsigned int status;\n\n\tpriv = (struct pdc_intc_priv *)irq_desc_get_handler_data(desc);\n\n\tstatus = pdc_read(priv, PDC_IRQ_STATUS) &\n\t\t pdc_read(priv, PDC_IRQ_ENABLE);\n\tstatus &= (1 << priv->nr_syswakes) - 1;\n\n\tfor (syswake = 0; status; status >>= 1, ++syswake) {\n\t\t \n\t\tif (!(status & 1))\n\t\t\tcontinue;\n\n\t\tgeneric_handle_domain_irq(priv->domain, syswake_to_hwirq(syswake));\n\t}\n}\n\nstatic void pdc_intc_setup(struct pdc_intc_priv *priv)\n{\n\tint i;\n\tunsigned int soc_sys_wake_regoff;\n\tunsigned int soc_sys_wake;\n\n\t \n\tpdc_write(priv, PDC_IRQ_ENABLE, 0);\n\n\t \n\tpriv->irq_route = ((PDC_IRQ_ROUTE_EXT_EN_SYS0 << priv->nr_syswakes) -\n\t\t\t\tPDC_IRQ_ROUTE_EXT_EN_SYS0);\n\tpdc_write(priv, PDC_IRQ_ROUTE, priv->irq_route);\n\n\t \n\tfor (i = 0; i < priv->nr_syswakes; ++i) {\n\t\t \n\t\tsoc_sys_wake_regoff = PDC_SYS_WAKE_BASE + i*PDC_SYS_WAKE_STRIDE;\n\t\tsoc_sys_wake = PDC_SYS_WAKE_INT_NONE\n\t\t\t\t<< PDC_SYS_WAKE_INT_MODE_SHIFT;\n\t\tpdc_write(priv, soc_sys_wake_regoff, soc_sys_wake);\n\t}\n}\n\nstatic int pdc_intc_probe(struct platform_device *pdev)\n{\n\tstruct pdc_intc_priv *priv;\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct resource *res_regs;\n\tstruct irq_chip_generic *gc;\n\tunsigned int i;\n\tint irq, ret;\n\tu32 val;\n\n\tif (!node)\n\t\treturn -ENOENT;\n\n\t \n\tres_regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res_regs == NULL) {\n\t\tdev_err(&pdev->dev, \"cannot find registers resource\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\traw_spin_lock_init(&priv->lock);\n\tplatform_set_drvdata(pdev, priv);\n\n\t \n\tpriv->pdc_base = devm_ioremap(&pdev->dev, res_regs->start,\n\t\t\t\t      resource_size(res_regs));\n\tif (!priv->pdc_base)\n\t\treturn -EIO;\n\n\t \n\tret = of_property_read_u32(node, \"num-perips\", &val);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"No num-perips node property found\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (val > SYS0_HWIRQ) {\n\t\tdev_err(&pdev->dev, \"num-perips (%u) out of range\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\tpriv->nr_perips = val;\n\n\t \n\tret = of_property_read_u32(node, \"num-syswakes\", &val);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"No num-syswakes node property found\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (val > SYS0_HWIRQ) {\n\t\tdev_err(&pdev->dev, \"num-syswakes (%u) out of range\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\tpriv->nr_syswakes = val;\n\n\t \n\tpriv->perip_irqs = devm_kcalloc(&pdev->dev, 4, priv->nr_perips,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!priv->perip_irqs)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < priv->nr_perips; ++i) {\n\t\tirq = platform_get_irq(pdev, 1 + i);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t\tpriv->perip_irqs[i] = irq;\n\t}\n\t \n\tif (platform_get_irq(pdev, 1 + i) >= 0) {\n\t\tdev_err(&pdev->dev, \"surplus perip IRQs detected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tpriv->syswake_irq = irq;\n\n\t \n\tpriv->domain = irq_domain_add_linear(node, 16, &irq_generic_chip_ops,\n\t\t\t\t\t     priv);\n\tif (unlikely(!priv->domain)) {\n\t\tdev_err(&pdev->dev, \"cannot add IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = irq_alloc_domain_generic_chips(priv->domain, 8, 2, \"pdc\",\n\t\t\t\t\t     handle_level_irq, 0, 0,\n\t\t\t\t\t     IRQ_GC_INIT_NESTED_LOCK);\n\tif (ret)\n\t\tgoto err_generic;\n\n\t \n\n\tgc = irq_get_domain_generic_chip(priv->domain, 0);\n\tgc->unused\t= ~(BIT(priv->nr_perips) - 1);\n\tgc->reg_base\t= priv->pdc_base;\n\t \n\tgc->chip_types[0].regs.mask\t\t= PDC_IRQ_ROUTE;\n\tgc->chip_types[0].chip.irq_mask\t\t= perip_irq_mask;\n\tgc->chip_types[0].chip.irq_unmask\t= perip_irq_unmask;\n\tgc->chip_types[0].chip.irq_set_wake\t= pdc_irq_set_wake;\n\n\t \n\n\tgc = irq_get_domain_generic_chip(priv->domain, 8);\n\tgc->unused\t= ~(BIT(priv->nr_syswakes) - 1);\n\tgc->reg_base\t= priv->pdc_base;\n\n\t \n\tgc->chip_types[0].type\t\t\t= IRQ_TYPE_EDGE_BOTH;\n\tgc->chip_types[0].handler\t\t= handle_edge_irq;\n\tgc->chip_types[0].regs.ack\t\t= PDC_IRQ_CLEAR;\n\tgc->chip_types[0].regs.mask\t\t= PDC_IRQ_ENABLE;\n\tgc->chip_types[0].chip.irq_ack\t\t= irq_gc_ack_set_bit;\n\tgc->chip_types[0].chip.irq_mask\t\t= irq_gc_mask_clr_bit;\n\tgc->chip_types[0].chip.irq_unmask\t= irq_gc_mask_set_bit;\n\tgc->chip_types[0].chip.irq_set_type\t= syswake_irq_set_type;\n\tgc->chip_types[0].chip.irq_set_wake\t= pdc_irq_set_wake;\n\t \n\tgc->chip_types[0].chip.flags\t\t= IRQCHIP_MASK_ON_SUSPEND;\n\n\t \n\tgc->chip_types[1].type\t\t\t= IRQ_TYPE_LEVEL_MASK;\n\tgc->chip_types[1].handler\t\t= handle_level_irq;\n\tgc->chip_types[1].regs.ack\t\t= PDC_IRQ_CLEAR;\n\tgc->chip_types[1].regs.mask\t\t= PDC_IRQ_ENABLE;\n\tgc->chip_types[1].chip.irq_ack\t\t= irq_gc_ack_set_bit;\n\tgc->chip_types[1].chip.irq_mask\t\t= irq_gc_mask_clr_bit;\n\tgc->chip_types[1].chip.irq_unmask\t= irq_gc_mask_set_bit;\n\tgc->chip_types[1].chip.irq_set_type\t= syswake_irq_set_type;\n\tgc->chip_types[1].chip.irq_set_wake\t= pdc_irq_set_wake;\n\t \n\tgc->chip_types[1].chip.flags\t\t= IRQCHIP_MASK_ON_SUSPEND;\n\n\t \n\tpdc_intc_setup(priv);\n\n\t \n\tfor (i = 0; i < priv->nr_perips; ++i) {\n\t\tirq = priv->perip_irqs[i];\n\t\tirq_set_chained_handler_and_data(irq, pdc_intc_perip_isr,\n\t\t\t\t\t\t priv);\n\t}\n\n\t \n\tirq_set_chained_handler_and_data(priv->syswake_irq,\n\t\t\t\t\t pdc_intc_syswake_isr, priv);\n\n\tdev_info(&pdev->dev,\n\t\t \"PDC IRQ controller initialised (%u perip IRQs, %u syswake IRQs)\\n\",\n\t\t priv->nr_perips,\n\t\t priv->nr_syswakes);\n\n\treturn 0;\nerr_generic:\n\tirq_domain_remove(priv->domain);\n\treturn ret;\n}\n\nstatic int pdc_intc_remove(struct platform_device *pdev)\n{\n\tstruct pdc_intc_priv *priv = platform_get_drvdata(pdev);\n\n\tirq_domain_remove(priv->domain);\n\treturn 0;\n}\n\nstatic const struct of_device_id pdc_intc_match[] = {\n\t{ .compatible = \"img,pdc-intc\" },\n\t{}\n};\n\nstatic struct platform_driver pdc_intc_driver = {\n\t.driver = {\n\t\t.name\t\t= \"pdc-intc\",\n\t\t.of_match_table\t= pdc_intc_match,\n\t},\n\t.probe = pdc_intc_probe,\n\t.remove = pdc_intc_remove,\n};\n\nstatic int __init pdc_intc_init(void)\n{\n\treturn platform_driver_register(&pdc_intc_driver);\n}\ncore_initcall(pdc_intc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}