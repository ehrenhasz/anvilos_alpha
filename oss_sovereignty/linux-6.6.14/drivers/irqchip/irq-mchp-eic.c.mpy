{
  "module_name": "irq-mchp-eic.c",
  "hash_id": "25d73ac44cc167c0df692c5fb407fb3934afea6d32598ce7dc04194bcc2703ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mchp-eic.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/syscore_ops.h>\n\n#include <dt-bindings/interrupt-controller/arm-gic.h>\n\n#define MCHP_EIC_GFCS\t\t\t(0x0)\n#define MCHP_EIC_SCFG(x)\t\t(0x4 + (x) * 0x4)\n#define MCHP_EIC_SCFG_EN\t\tBIT(16)\n#define MCHP_EIC_SCFG_LVL\t\tBIT(9)\n#define MCHP_EIC_SCFG_POL\t\tBIT(8)\n\n#define MCHP_EIC_NIRQ\t\t\t(2)\n\n \nstruct mchp_eic {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct irq_domain *domain;\n\tu32 irqs[MCHP_EIC_NIRQ];\n\tu32 scfg[MCHP_EIC_NIRQ];\n\tu32 wakeup_source;\n};\n\nstatic struct mchp_eic *eic;\n\nstatic void mchp_eic_irq_mask(struct irq_data *d)\n{\n\tunsigned int tmp;\n\n\ttmp = readl_relaxed(eic->base + MCHP_EIC_SCFG(d->hwirq));\n\ttmp &= ~MCHP_EIC_SCFG_EN;\n\twritel_relaxed(tmp, eic->base + MCHP_EIC_SCFG(d->hwirq));\n\n\tirq_chip_mask_parent(d);\n}\n\nstatic void mchp_eic_irq_unmask(struct irq_data *d)\n{\n\tunsigned int tmp;\n\n\ttmp = readl_relaxed(eic->base + MCHP_EIC_SCFG(d->hwirq));\n\ttmp |= MCHP_EIC_SCFG_EN;\n\twritel_relaxed(tmp, eic->base + MCHP_EIC_SCFG(d->hwirq));\n\n\tirq_chip_unmask_parent(d);\n}\n\nstatic int mchp_eic_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tunsigned int parent_irq_type;\n\tunsigned int tmp;\n\n\ttmp = readl_relaxed(eic->base + MCHP_EIC_SCFG(d->hwirq));\n\ttmp &= ~(MCHP_EIC_SCFG_POL | MCHP_EIC_SCFG_LVL);\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\ttmp |= MCHP_EIC_SCFG_POL | MCHP_EIC_SCFG_LVL;\n\t\tparent_irq_type = IRQ_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\ttmp |= MCHP_EIC_SCFG_LVL;\n\t\tparent_irq_type = IRQ_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tparent_irq_type = IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\ttmp |= MCHP_EIC_SCFG_POL;\n\t\tparent_irq_type = IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twritel_relaxed(tmp, eic->base + MCHP_EIC_SCFG(d->hwirq));\n\n\treturn irq_chip_set_type_parent(d, parent_irq_type);\n}\n\nstatic int mchp_eic_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tirq_set_irq_wake(eic->irqs[d->hwirq], on);\n\tif (on)\n\t\teic->wakeup_source |= BIT(d->hwirq);\n\telse\n\t\teic->wakeup_source &= ~BIT(d->hwirq);\n\n\treturn 0;\n}\n\nstatic int mchp_eic_irq_suspend(void)\n{\n\tunsigned int hwirq;\n\n\tfor (hwirq = 0; hwirq < MCHP_EIC_NIRQ; hwirq++)\n\t\teic->scfg[hwirq] = readl_relaxed(eic->base +\n\t\t\t\t\t\t MCHP_EIC_SCFG(hwirq));\n\n\tif (!eic->wakeup_source)\n\t\tclk_disable_unprepare(eic->clk);\n\n\treturn 0;\n}\n\nstatic void mchp_eic_irq_resume(void)\n{\n\tunsigned int hwirq;\n\n\tif (!eic->wakeup_source)\n\t\tclk_prepare_enable(eic->clk);\n\n\tfor (hwirq = 0; hwirq < MCHP_EIC_NIRQ; hwirq++)\n\t\twritel_relaxed(eic->scfg[hwirq], eic->base +\n\t\t\t       MCHP_EIC_SCFG(hwirq));\n}\n\nstatic struct syscore_ops mchp_eic_syscore_ops = {\n\t.suspend = mchp_eic_irq_suspend,\n\t.resume = mchp_eic_irq_resume,\n};\n\nstatic struct irq_chip mchp_eic_chip = {\n\t.name\t\t= \"eic\",\n\t.flags\t\t= IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_SET_TYPE_MASKED,\n\t.irq_mask\t= mchp_eic_irq_mask,\n\t.irq_unmask\t= mchp_eic_irq_unmask,\n\t.irq_set_type\t= mchp_eic_irq_set_type,\n\t.irq_ack\t= irq_chip_ack_parent,\n\t.irq_eoi\t= irq_chip_eoi_parent,\n\t.irq_retrigger\t= irq_chip_retrigger_hierarchy,\n\t.irq_set_wake\t= mchp_eic_irq_set_wake,\n};\n\nstatic int mchp_eic_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs, void *data)\n{\n\tstruct irq_fwspec *fwspec = data;\n\tstruct irq_fwspec parent_fwspec;\n\tirq_hw_number_t hwirq;\n\tunsigned int type;\n\tint ret;\n\n\tif (WARN_ON(nr_irqs != 1))\n\t\treturn -EINVAL;\n\n\tret = irq_domain_translate_twocell(domain, fwspec, &hwirq, &type);\n\tif (ret || hwirq >= MCHP_EIC_NIRQ)\n\t\treturn ret;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\ttype = IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\ttype = IRQ_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, &mchp_eic_chip, eic);\n\n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\tparent_fwspec.param_count = 3;\n\tparent_fwspec.param[0] = GIC_SPI;\n\tparent_fwspec.param[1] = eic->irqs[hwirq];\n\tparent_fwspec.param[2] = type;\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, 1, &parent_fwspec);\n}\n\nstatic const struct irq_domain_ops mchp_eic_domain_ops = {\n\t.translate\t= irq_domain_translate_twocell,\n\t.alloc\t\t= mchp_eic_domain_alloc,\n\t.free\t\t= irq_domain_free_irqs_common,\n};\n\nstatic int mchp_eic_init(struct device_node *node, struct device_node *parent)\n{\n\tstruct irq_domain *parent_domain = NULL;\n\tint ret, i;\n\n\teic = kzalloc(sizeof(*eic), GFP_KERNEL);\n\tif (!eic)\n\t\treturn -ENOMEM;\n\n\teic->base = of_iomap(node, 0);\n\tif (!eic->base) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tret = -ENODEV;\n\t\tgoto unmap;\n\t}\n\n\teic->clk = of_clk_get_by_name(node, \"pclk\");\n\tif (IS_ERR(eic->clk)) {\n\t\tret = PTR_ERR(eic->clk);\n\t\tgoto unmap;\n\t}\n\n\tret = clk_prepare_enable(eic->clk);\n\tif (ret)\n\t\tgoto unmap;\n\n\tfor (i = 0; i < MCHP_EIC_NIRQ; i++) {\n\t\tstruct of_phandle_args irq;\n\n\t\t \n\t\twritel_relaxed(0UL, eic->base + MCHP_EIC_SCFG(i));\n\n\t\tret = of_irq_parse_one(node, i, &irq);\n\t\tif (ret)\n\t\t\tgoto clk_unprepare;\n\n\t\tif (WARN_ON(irq.args_count != 3)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto clk_unprepare;\n\t\t}\n\n\t\teic->irqs[i] = irq.args[1];\n\t}\n\n\teic->domain = irq_domain_add_hierarchy(parent_domain, 0, MCHP_EIC_NIRQ,\n\t\t\t\t\t       node, &mchp_eic_domain_ops, eic);\n\tif (!eic->domain) {\n\t\tpr_err(\"%pOF: Failed to add domain\\n\", node);\n\t\tret = -ENODEV;\n\t\tgoto clk_unprepare;\n\t}\n\n\tregister_syscore_ops(&mchp_eic_syscore_ops);\n\n\tpr_info(\"%pOF: EIC registered, nr_irqs %u\\n\", node, MCHP_EIC_NIRQ);\n\n\treturn 0;\n\nclk_unprepare:\n\tclk_disable_unprepare(eic->clk);\nunmap:\n\tiounmap(eic->base);\nfree:\n\tkfree(eic);\n\treturn ret;\n}\n\nIRQCHIP_PLATFORM_DRIVER_BEGIN(mchp_eic)\nIRQCHIP_MATCH(\"microchip,sama7g5-eic\", mchp_eic_init)\nIRQCHIP_PLATFORM_DRIVER_END(mchp_eic)\n\nMODULE_DESCRIPTION(\"Microchip External Interrupt Controller\");\nMODULE_AUTHOR(\"Claudiu Beznea <claudiu.beznea@microchip.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}