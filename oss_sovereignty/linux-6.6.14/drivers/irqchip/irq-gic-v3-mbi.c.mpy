{
  "module_name": "irq-gic-v3-mbi.c",
  "hash_id": "dd88bce9fa613829685da1af38357b6f55de4c887109fca8ee4fddda54ac292b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-gic-v3-mbi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"GICv3: \" fmt\n\n#include <linux/iommu.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/msi.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <linux/irqchip/arm-gic-v3.h>\n\nstruct mbi_range {\n\tu32\t\t\tspi_start;\n\tu32\t\t\tnr_spis;\n\tunsigned long\t\t*bm;\n};\n\nstatic DEFINE_MUTEX(mbi_lock);\nstatic phys_addr_t\t\tmbi_phys_base;\nstatic struct mbi_range\t\t*mbi_ranges;\nstatic unsigned int\t\tmbi_range_nr;\n\nstatic struct irq_chip mbi_irq_chip = {\n\t.name\t\t\t= \"MBI\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n};\n\nstatic int mbi_irq_gic_domain_alloc(struct irq_domain *domain,\n\t\t\t\t       unsigned int virq,\n\t\t\t\t       irq_hw_number_t hwirq)\n{\n\tstruct irq_fwspec fwspec;\n\tstruct irq_data *d;\n\tint err;\n\n\t \n\tif (!is_of_node(domain->parent->fwnode))\n\t\treturn -EINVAL;\n\n\t \n\tfwspec.fwnode = domain->parent->fwnode;\n\tfwspec.param_count = 3;\n\tfwspec.param[0] = 0;\n\tfwspec.param[1] = hwirq - 32;\n\tfwspec.param[2] = IRQ_TYPE_EDGE_RISING;\n\n\terr = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\n\tif (err)\n\t\treturn err;\n\n\td = irq_domain_get_irq_data(domain->parent, virq);\n\treturn d->chip->irq_set_type(d, IRQ_TYPE_EDGE_RISING);\n}\n\nstatic void mbi_free_msi(struct mbi_range *mbi, unsigned int hwirq,\n\t\t\t int nr_irqs)\n{\n\tmutex_lock(&mbi_lock);\n\tbitmap_release_region(mbi->bm, hwirq - mbi->spi_start,\n\t\t\t      get_count_order(nr_irqs));\n\tmutex_unlock(&mbi_lock);\n}\n\nstatic int mbi_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t   unsigned int nr_irqs, void *args)\n{\n\tmsi_alloc_info_t *info = args;\n\tstruct mbi_range *mbi = NULL;\n\tint hwirq, offset, i, err = 0;\n\n\tmutex_lock(&mbi_lock);\n\tfor (i = 0; i < mbi_range_nr; i++) {\n\t\toffset = bitmap_find_free_region(mbi_ranges[i].bm,\n\t\t\t\t\t\t mbi_ranges[i].nr_spis,\n\t\t\t\t\t\t get_count_order(nr_irqs));\n\t\tif (offset >= 0) {\n\t\t\tmbi = &mbi_ranges[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&mbi_lock);\n\n\tif (!mbi)\n\t\treturn -ENOSPC;\n\n\thwirq = mbi->spi_start + offset;\n\n\terr = iommu_dma_prepare_msi(info->desc,\n\t\t\t\t    mbi_phys_base + GICD_SETSPI_NSR);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\terr = mbi_irq_gic_domain_alloc(domain, virq + i, hwirq + i);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\n\t\t\t\t\t      &mbi_irq_chip, mbi);\n\t}\n\n\treturn 0;\n\nfail:\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n\tmbi_free_msi(mbi, hwirq, nr_irqs);\n\treturn err;\n}\n\nstatic void mbi_irq_domain_free(struct irq_domain *domain,\n\t\t\t\tunsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct mbi_range *mbi = irq_data_get_irq_chip_data(d);\n\n\tmbi_free_msi(mbi, d->hwirq, nr_irqs);\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}\n\nstatic const struct irq_domain_ops mbi_domain_ops = {\n\t.alloc\t\t\t= mbi_irq_domain_alloc,\n\t.free\t\t\t= mbi_irq_domain_free,\n};\n\nstatic void mbi_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tmsg[0].address_hi = upper_32_bits(mbi_phys_base + GICD_SETSPI_NSR);\n\tmsg[0].address_lo = lower_32_bits(mbi_phys_base + GICD_SETSPI_NSR);\n\tmsg[0].data = data->parent_data->hwirq;\n\n\tiommu_dma_compose_msi_msg(irq_data_get_msi_desc(data), msg);\n}\n\n#ifdef CONFIG_PCI_MSI\n \nstatic void mbi_mask_msi_irq(struct irq_data *d)\n{\n\tpci_msi_mask_irq(d);\n\tirq_chip_mask_parent(d);\n}\n\nstatic void mbi_unmask_msi_irq(struct irq_data *d)\n{\n\tpci_msi_unmask_irq(d);\n\tirq_chip_unmask_parent(d);\n}\n\nstatic struct irq_chip mbi_msi_irq_chip = {\n\t.name\t\t\t= \"MSI\",\n\t.irq_mask\t\t= mbi_mask_msi_irq,\n\t.irq_unmask\t\t= mbi_unmask_msi_irq,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_compose_msi_msg\t= mbi_compose_msi_msg,\n};\n\nstatic struct msi_domain_info mbi_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_PCI_MSIX | MSI_FLAG_MULTI_PCI_MSI),\n\t.chip\t= &mbi_msi_irq_chip,\n};\n\nstatic int mbi_allocate_pci_domain(struct irq_domain *nexus_domain,\n\t\t\t\t   struct irq_domain **pci_domain)\n{\n\t*pci_domain = pci_msi_create_irq_domain(nexus_domain->parent->fwnode,\n\t\t\t\t\t\t&mbi_msi_domain_info,\n\t\t\t\t\t\tnexus_domain);\n\tif (!*pci_domain)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n#else\nstatic int mbi_allocate_pci_domain(struct irq_domain *nexus_domain,\n\t\t\t\t   struct irq_domain **pci_domain)\n{\n\t*pci_domain = NULL;\n\treturn 0;\n}\n#endif\n\nstatic void mbi_compose_mbi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tmbi_compose_msi_msg(data, msg);\n\n\tmsg[1].address_hi = upper_32_bits(mbi_phys_base + GICD_CLRSPI_NSR);\n\tmsg[1].address_lo = lower_32_bits(mbi_phys_base + GICD_CLRSPI_NSR);\n\tmsg[1].data = data->parent_data->hwirq;\n\n\tiommu_dma_compose_msi_msg(irq_data_get_msi_desc(data), &msg[1]);\n}\n\n \nstatic struct irq_chip mbi_pmsi_irq_chip = {\n\t.name\t\t\t= \"pMSI\",\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n\t.irq_compose_msi_msg\t= mbi_compose_mbi_msg,\n\t.flags\t\t\t= IRQCHIP_SUPPORTS_LEVEL_MSI,\n};\n\nstatic struct msi_domain_ops mbi_pmsi_ops = {\n};\n\nstatic struct msi_domain_info mbi_pmsi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_LEVEL_CAPABLE),\n\t.ops\t= &mbi_pmsi_ops,\n\t.chip\t= &mbi_pmsi_irq_chip,\n};\n\nstatic int mbi_allocate_domains(struct irq_domain *parent)\n{\n\tstruct irq_domain *nexus_domain, *pci_domain, *plat_domain;\n\tint err;\n\n\tnexus_domain = irq_domain_create_hierarchy(parent, 0, 0, parent->fwnode,\n\t\t\t\t\t\t   &mbi_domain_ops, NULL);\n\tif (!nexus_domain)\n\t\treturn -ENOMEM;\n\n\tirq_domain_update_bus_token(nexus_domain, DOMAIN_BUS_NEXUS);\n\n\terr = mbi_allocate_pci_domain(nexus_domain, &pci_domain);\n\n\tplat_domain = platform_msi_create_irq_domain(parent->fwnode,\n\t\t\t\t\t\t     &mbi_pmsi_domain_info,\n\t\t\t\t\t\t     nexus_domain);\n\n\tif (err || !plat_domain) {\n\t\tif (plat_domain)\n\t\t\tirq_domain_remove(plat_domain);\n\t\tif (pci_domain)\n\t\t\tirq_domain_remove(pci_domain);\n\t\tirq_domain_remove(nexus_domain);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nint __init mbi_init(struct fwnode_handle *fwnode, struct irq_domain *parent)\n{\n\tstruct device_node *np;\n\tconst __be32 *reg;\n\tint ret, n;\n\n\tnp = to_of_node(fwnode);\n\n\tif (!of_property_read_bool(np, \"msi-controller\"))\n\t\treturn 0;\n\n\tn = of_property_count_elems_of_size(np, \"mbi-ranges\", sizeof(u32));\n\tif (n <= 0 || n % 2)\n\t\treturn -EINVAL;\n\n\tmbi_range_nr = n / 2;\n\tmbi_ranges = kcalloc(mbi_range_nr, sizeof(*mbi_ranges), GFP_KERNEL);\n\tif (!mbi_ranges)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < mbi_range_nr; n++) {\n\t\tret = of_property_read_u32_index(np, \"mbi-ranges\", n * 2,\n\t\t\t\t\t\t &mbi_ranges[n].spi_start);\n\t\tif (ret)\n\t\t\tgoto err_free_mbi;\n\t\tret = of_property_read_u32_index(np, \"mbi-ranges\", n * 2 + 1,\n\t\t\t\t\t\t &mbi_ranges[n].nr_spis);\n\t\tif (ret)\n\t\t\tgoto err_free_mbi;\n\n\t\tmbi_ranges[n].bm = bitmap_zalloc(mbi_ranges[n].nr_spis, GFP_KERNEL);\n\t\tif (!mbi_ranges[n].bm) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_mbi;\n\t\t}\n\t\tpr_info(\"MBI range [%d:%d]\\n\", mbi_ranges[n].spi_start,\n\t\t\tmbi_ranges[n].spi_start + mbi_ranges[n].nr_spis - 1);\n\t}\n\n\treg = of_get_property(np, \"mbi-alias\", NULL);\n\tif (reg) {\n\t\tmbi_phys_base = of_translate_address(np, reg);\n\t\tif (mbi_phys_base == (phys_addr_t)OF_BAD_ADDR) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_free_mbi;\n\t\t}\n\t} else {\n\t\tstruct resource res;\n\n\t\tif (of_address_to_resource(np, 0, &res)) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_free_mbi;\n\t\t}\n\n\t\tmbi_phys_base = res.start;\n\t}\n\n\tpr_info(\"Using MBI frame %pa\\n\", &mbi_phys_base);\n\n\tret = mbi_allocate_domains(parent);\n\tif (ret)\n\t\tgoto err_free_mbi;\n\n\treturn 0;\n\nerr_free_mbi:\n\tif (mbi_ranges) {\n\t\tfor (n = 0; n < mbi_range_nr; n++)\n\t\t\tbitmap_free(mbi_ranges[n].bm);\n\t\tkfree(mbi_ranges);\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}