{
  "module_name": "irq-versatile-fpga.c",
  "hash_id": "b722f70d2f9c1c6d78c744ad14205593b61bf097a682a5de9fd28c9d93472a5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-versatile-fpga.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/seq_file.h>\n\n#include <asm/exception.h>\n#include <asm/mach/irq.h>\n\n#define IRQ_STATUS\t\t0x00\n#define IRQ_RAW_STATUS\t\t0x04\n#define IRQ_ENABLE_SET\t\t0x08\n#define IRQ_ENABLE_CLEAR\t0x0c\n#define INT_SOFT_SET\t\t0x10\n#define INT_SOFT_CLEAR\t\t0x14\n#define FIQ_STATUS\t\t0x20\n#define FIQ_RAW_STATUS\t\t0x24\n#define FIQ_ENABLE\t\t0x28\n#define FIQ_ENABLE_SET\t\t0x28\n#define FIQ_ENABLE_CLEAR\t0x2C\n\n#define PIC_ENABLES             0x20\t \n\n \nstruct fpga_irq_data {\n\tvoid __iomem *base;\n\tu32 valid;\n\tstruct irq_domain *domain;\n\tu8 used_irqs;\n};\n\n \nstatic struct fpga_irq_data fpga_irq_devices[CONFIG_VERSATILE_FPGA_IRQ_NR];\nstatic int fpga_irq_id;\n\nstatic void fpga_irq_mask(struct irq_data *d)\n{\n\tstruct fpga_irq_data *f = irq_data_get_irq_chip_data(d);\n\tu32 mask = 1 << d->hwirq;\n\n\twritel(mask, f->base + IRQ_ENABLE_CLEAR);\n}\n\nstatic void fpga_irq_unmask(struct irq_data *d)\n{\n\tstruct fpga_irq_data *f = irq_data_get_irq_chip_data(d);\n\tu32 mask = 1 << d->hwirq;\n\n\twritel(mask, f->base + IRQ_ENABLE_SET);\n}\n\nstatic void fpga_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct fpga_irq_data *f = irq_data_get_irq_chip_data(d);\n\n\tseq_printf(p, irq_domain_get_of_node(f->domain)->name);\n}\n\nstatic const struct irq_chip fpga_chip = {\n\t.irq_ack\t= fpga_irq_mask,\n\t.irq_mask\t= fpga_irq_mask,\n\t.irq_unmask\t= fpga_irq_unmask,\n\t.irq_print_chip\t= fpga_irq_print_chip,\n};\n\nstatic void fpga_irq_handle(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct fpga_irq_data *f = irq_desc_get_handler_data(desc);\n\tu32 status;\n\n\tchained_irq_enter(chip, desc);\n\n\tstatus = readl(f->base + IRQ_STATUS);\n\tif (status == 0) {\n\t\tdo_bad_IRQ(desc);\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tunsigned int irq = ffs(status) - 1;\n\n\t\tstatus &= ~(1 << irq);\n\t\tgeneric_handle_domain_irq(f->domain, irq);\n\t} while (status);\n\nout:\n\tchained_irq_exit(chip, desc);\n}\n\n \nstatic int handle_one_fpga(struct fpga_irq_data *f, struct pt_regs *regs)\n{\n\tint handled = 0;\n\tint irq;\n\tu32 status;\n\n\twhile ((status  = readl(f->base + IRQ_STATUS))) {\n\t\tirq = ffs(status) - 1;\n\t\tgeneric_handle_domain_irq(f->domain, irq);\n\t\thandled = 1;\n\t}\n\n\treturn handled;\n}\n\n \nstatic asmlinkage void __exception_irq_entry fpga_handle_irq(struct pt_regs *regs)\n{\n\tint i, handled;\n\n\tdo {\n\t\tfor (i = 0, handled = 0; i < fpga_irq_id; ++i)\n\t\t\thandled |= handle_one_fpga(&fpga_irq_devices[i], regs);\n\t} while (handled);\n}\n\nstatic int fpga_irqdomain_map(struct irq_domain *d, unsigned int irq,\n\t\tirq_hw_number_t hwirq)\n{\n\tstruct fpga_irq_data *f = d->host_data;\n\n\t \n\tif (!(f->valid & BIT(hwirq)))\n\t\treturn -EPERM;\n\tirq_set_chip_data(irq, f);\n\tirq_set_chip_and_handler(irq, &fpga_chip, handle_level_irq);\n\tirq_set_probe(irq);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops fpga_irqdomain_ops = {\n\t.map = fpga_irqdomain_map,\n\t.xlate = irq_domain_xlate_onetwocell,\n};\n\nstatic void __init fpga_irq_init(void __iomem *base, int parent_irq,\n\t\t\t\t u32 valid, struct device_node *node)\n{\n\tstruct fpga_irq_data *f;\n\tint i;\n\n\tif (fpga_irq_id >= ARRAY_SIZE(fpga_irq_devices)) {\n\t\tpr_err(\"%s: too few FPGA IRQ controllers, increase CONFIG_VERSATILE_FPGA_IRQ_NR\\n\", __func__);\n\t\treturn;\n\t}\n\tf = &fpga_irq_devices[fpga_irq_id];\n\tf->base = base;\n\tf->valid = valid;\n\n\tif (parent_irq != -1) {\n\t\tirq_set_chained_handler_and_data(parent_irq, fpga_irq_handle,\n\t\t\t\t\t\t f);\n\t}\n\n\tf->domain = irq_domain_add_linear(node, fls(valid),\n\t\t\t\t\t  &fpga_irqdomain_ops, f);\n\n\t \n\tfor (i = 0; i < fls(valid); i++)\n\t\tif (valid & BIT(i)) {\n\t\t\t \n\t\t\tirq_create_mapping(f->domain, i);\n\t\t\tf->used_irqs++;\n\t\t}\n\n\tpr_info(\"FPGA IRQ chip %d \\\"%s\\\" @ %p, %u irqs\",\n\t\tfpga_irq_id, node->name, base, f->used_irqs);\n\tif (parent_irq != -1)\n\t\tpr_cont(\", parent IRQ: %d\\n\", parent_irq);\n\telse\n\t\tpr_cont(\"\\n\");\n\n\tfpga_irq_id++;\n}\n\n#ifdef CONFIG_OF\nstatic int __init fpga_irq_of_init(struct device_node *node,\n\t\t\t\t   struct device_node *parent)\n{\n\tvoid __iomem *base;\n\tu32 clear_mask;\n\tu32 valid_mask;\n\tint parent_irq;\n\n\tif (WARN_ON(!node))\n\t\treturn -ENODEV;\n\n\tbase = of_iomap(node, 0);\n\tWARN(!base, \"unable to map fpga irq registers\\n\");\n\n\tif (of_property_read_u32(node, \"clear-mask\", &clear_mask))\n\t\tclear_mask = 0;\n\n\tif (of_property_read_u32(node, \"valid-mask\", &valid_mask))\n\t\tvalid_mask = 0;\n\n\twritel(clear_mask, base + IRQ_ENABLE_CLEAR);\n\twritel(clear_mask, base + FIQ_ENABLE_CLEAR);\n\n\t \n\tparent_irq = irq_of_parse_and_map(node, 0);\n\tif (!parent_irq) {\n\t\tset_handle_irq(fpga_handle_irq);\n\t\tparent_irq = -1;\n\t}\n\n\tfpga_irq_init(base, parent_irq, valid_mask, node);\n\n\t \n\tif (of_device_is_compatible(node, \"arm,versatile-sic\"))\n\t\twritel(0xffd00000, base + PIC_ENABLES);\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(arm_fpga, \"arm,versatile-fpga-irq\", fpga_irq_of_init);\nIRQCHIP_DECLARE(arm_fpga_sic, \"arm,versatile-sic\", fpga_irq_of_init);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}