{
  "module_name": "irq-gic.c",
  "hash_id": "6d09a9221bdc9d2a7b23a7ae0e070d0746f0e95f6d862c8bd06c479d157f29af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-gic.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/cpu_pm.h>\n#include <linux/cpumask.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/acpi.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqchip/arm-gic.h>\n\n#include <asm/cputype.h>\n#include <asm/irq.h>\n#include <asm/exception.h>\n#include <asm/smp_plat.h>\n#include <asm/virt.h>\n\n#include \"irq-gic-common.h\"\n\n#ifdef CONFIG_ARM64\n#include <asm/cpufeature.h>\n\nstatic void gic_check_cpu_features(void)\n{\n\tWARN_TAINT_ONCE(this_cpu_has_cap(ARM64_HAS_GIC_CPUIF_SYSREGS),\n\t\t\tTAINT_CPU_OUT_OF_SPEC,\n\t\t\t\"GICv3 system registers enabled, broken firmware!\\n\");\n}\n#else\n#define gic_check_cpu_features()\tdo { } while(0)\n#endif\n\nunion gic_base {\n\tvoid __iomem *common_base;\n\tvoid __percpu * __iomem *percpu_base;\n};\n\nstruct gic_chip_data {\n\tunion gic_base dist_base;\n\tunion gic_base cpu_base;\n\tvoid __iomem *raw_dist_base;\n\tvoid __iomem *raw_cpu_base;\n\tu32 percpu_offset;\n#if defined(CONFIG_CPU_PM) || defined(CONFIG_ARM_GIC_PM)\n\tu32 saved_spi_enable[DIV_ROUND_UP(1020, 32)];\n\tu32 saved_spi_active[DIV_ROUND_UP(1020, 32)];\n\tu32 saved_spi_conf[DIV_ROUND_UP(1020, 16)];\n\tu32 saved_spi_target[DIV_ROUND_UP(1020, 4)];\n\tu32 __percpu *saved_ppi_enable;\n\tu32 __percpu *saved_ppi_active;\n\tu32 __percpu *saved_ppi_conf;\n#endif\n\tstruct irq_domain *domain;\n\tunsigned int gic_irqs;\n};\n\n#ifdef CONFIG_BL_SWITCHER\n\nstatic DEFINE_RAW_SPINLOCK(cpu_map_lock);\n\n#define gic_lock_irqsave(f)\t\t\\\n\traw_spin_lock_irqsave(&cpu_map_lock, (f))\n#define gic_unlock_irqrestore(f)\t\\\n\traw_spin_unlock_irqrestore(&cpu_map_lock, (f))\n\n#define gic_lock()\t\t\traw_spin_lock(&cpu_map_lock)\n#define gic_unlock()\t\t\traw_spin_unlock(&cpu_map_lock)\n\n#else\n\n#define gic_lock_irqsave(f)\t\tdo { (void)(f); } while(0)\n#define gic_unlock_irqrestore(f)\tdo { (void)(f); } while(0)\n\n#define gic_lock()\t\t\tdo { } while(0)\n#define gic_unlock()\t\t\tdo { } while(0)\n\n#endif\n\nstatic DEFINE_STATIC_KEY_FALSE(needs_rmw_access);\n\n \n#define NR_GIC_CPU_IF 8\nstatic u8 gic_cpu_map[NR_GIC_CPU_IF] __read_mostly;\n\nstatic DEFINE_STATIC_KEY_TRUE(supports_deactivate_key);\n\nstatic struct gic_chip_data gic_data[CONFIG_ARM_GIC_MAX_NR] __read_mostly;\n\nstatic struct gic_kvm_info gic_v2_kvm_info __initdata;\n\nstatic DEFINE_PER_CPU(u32, sgi_intid);\n\n#ifdef CONFIG_GIC_NON_BANKED\nstatic DEFINE_STATIC_KEY_FALSE(frankengic_key);\n\nstatic void enable_frankengic(void)\n{\n\tstatic_branch_enable(&frankengic_key);\n}\n\nstatic inline void __iomem *__get_base(union gic_base *base)\n{\n\tif (static_branch_unlikely(&frankengic_key))\n\t\treturn raw_cpu_read(*base->percpu_base);\n\n\treturn base->common_base;\n}\n\n#define gic_data_dist_base(d)\t__get_base(&(d)->dist_base)\n#define gic_data_cpu_base(d)\t__get_base(&(d)->cpu_base)\n#else\n#define gic_data_dist_base(d)\t((d)->dist_base.common_base)\n#define gic_data_cpu_base(d)\t((d)->cpu_base.common_base)\n#define enable_frankengic()\tdo { } while(0)\n#endif\n\nstatic inline void __iomem *gic_dist_base(struct irq_data *d)\n{\n\tstruct gic_chip_data *gic_data = irq_data_get_irq_chip_data(d);\n\treturn gic_data_dist_base(gic_data);\n}\n\nstatic inline void __iomem *gic_cpu_base(struct irq_data *d)\n{\n\tstruct gic_chip_data *gic_data = irq_data_get_irq_chip_data(d);\n\treturn gic_data_cpu_base(gic_data);\n}\n\nstatic inline unsigned int gic_irq(struct irq_data *d)\n{\n\treturn d->hwirq;\n}\n\nstatic inline bool cascading_gic_irq(struct irq_data *d)\n{\n\tvoid *data = irq_data_get_irq_handler_data(d);\n\n\t \n\treturn data != NULL;\n}\n\n \nstatic void gic_poke_irq(struct irq_data *d, u32 offset)\n{\n\tu32 mask = 1 << (gic_irq(d) % 32);\n\twritel_relaxed(mask, gic_dist_base(d) + offset + (gic_irq(d) / 32) * 4);\n}\n\nstatic int gic_peek_irq(struct irq_data *d, u32 offset)\n{\n\tu32 mask = 1 << (gic_irq(d) % 32);\n\treturn !!(readl_relaxed(gic_dist_base(d) + offset + (gic_irq(d) / 32) * 4) & mask);\n}\n\nstatic void gic_mask_irq(struct irq_data *d)\n{\n\tgic_poke_irq(d, GIC_DIST_ENABLE_CLEAR);\n}\n\nstatic void gic_eoimode1_mask_irq(struct irq_data *d)\n{\n\tgic_mask_irq(d);\n\t \n\tif (irqd_is_forwarded_to_vcpu(d))\n\t\tgic_poke_irq(d, GIC_DIST_ACTIVE_CLEAR);\n}\n\nstatic void gic_unmask_irq(struct irq_data *d)\n{\n\tgic_poke_irq(d, GIC_DIST_ENABLE_SET);\n}\n\nstatic void gic_eoi_irq(struct irq_data *d)\n{\n\tu32 hwirq = gic_irq(d);\n\n\tif (hwirq < 16)\n\t\thwirq = this_cpu_read(sgi_intid);\n\n\twritel_relaxed(hwirq, gic_cpu_base(d) + GIC_CPU_EOI);\n}\n\nstatic void gic_eoimode1_eoi_irq(struct irq_data *d)\n{\n\tu32 hwirq = gic_irq(d);\n\n\t \n\tif (irqd_is_forwarded_to_vcpu(d))\n\t\treturn;\n\n\tif (hwirq < 16)\n\t\thwirq = this_cpu_read(sgi_intid);\n\n\twritel_relaxed(hwirq, gic_cpu_base(d) + GIC_CPU_DEACTIVATE);\n}\n\nstatic int gic_irq_set_irqchip_state(struct irq_data *d,\n\t\t\t\t     enum irqchip_irq_state which, bool val)\n{\n\tu32 reg;\n\n\tswitch (which) {\n\tcase IRQCHIP_STATE_PENDING:\n\t\treg = val ? GIC_DIST_PENDING_SET : GIC_DIST_PENDING_CLEAR;\n\t\tbreak;\n\n\tcase IRQCHIP_STATE_ACTIVE:\n\t\treg = val ? GIC_DIST_ACTIVE_SET : GIC_DIST_ACTIVE_CLEAR;\n\t\tbreak;\n\n\tcase IRQCHIP_STATE_MASKED:\n\t\treg = val ? GIC_DIST_ENABLE_CLEAR : GIC_DIST_ENABLE_SET;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tgic_poke_irq(d, reg);\n\treturn 0;\n}\n\nstatic int gic_irq_get_irqchip_state(struct irq_data *d,\n\t\t\t\t      enum irqchip_irq_state which, bool *val)\n{\n\tswitch (which) {\n\tcase IRQCHIP_STATE_PENDING:\n\t\t*val = gic_peek_irq(d, GIC_DIST_PENDING_SET);\n\t\tbreak;\n\n\tcase IRQCHIP_STATE_ACTIVE:\n\t\t*val = gic_peek_irq(d, GIC_DIST_ACTIVE_SET);\n\t\tbreak;\n\n\tcase IRQCHIP_STATE_MASKED:\n\t\t*val = !gic_peek_irq(d, GIC_DIST_ENABLE_SET);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int gic_set_type(struct irq_data *d, unsigned int type)\n{\n\tvoid __iomem *base = gic_dist_base(d);\n\tunsigned int gicirq = gic_irq(d);\n\tint ret;\n\n\t \n\tif (gicirq < 16)\n\t\treturn type != IRQ_TYPE_EDGE_RISING ? -EINVAL : 0;\n\n\t \n\tif (gicirq >= 32 && type != IRQ_TYPE_LEVEL_HIGH &&\n\t\t\t    type != IRQ_TYPE_EDGE_RISING)\n\t\treturn -EINVAL;\n\n\tret = gic_configure_irq(gicirq, type, base + GIC_DIST_CONFIG, NULL);\n\tif (ret && gicirq < 32) {\n\t\t \n\t\tpr_warn(\"GIC: PPI%d is secure or misconfigured\\n\", gicirq - 16);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int gic_irq_set_vcpu_affinity(struct irq_data *d, void *vcpu)\n{\n\t \n\tif (cascading_gic_irq(d) || gic_irq(d) < 16)\n\t\treturn -EINVAL;\n\n\tif (vcpu)\n\t\tirqd_set_forwarded_to_vcpu(d);\n\telse\n\t\tirqd_clr_forwarded_to_vcpu(d);\n\treturn 0;\n}\n\nstatic int gic_retrigger(struct irq_data *data)\n{\n\treturn !gic_irq_set_irqchip_state(data, IRQCHIP_STATE_PENDING, true);\n}\n\nstatic void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)\n{\n\tu32 irqstat, irqnr;\n\tstruct gic_chip_data *gic = &gic_data[0];\n\tvoid __iomem *cpu_base = gic_data_cpu_base(gic);\n\n\tdo {\n\t\tirqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK);\n\t\tirqnr = irqstat & GICC_IAR_INT_ID_MASK;\n\n\t\tif (unlikely(irqnr >= 1020))\n\t\t\tbreak;\n\n\t\tif (static_branch_likely(&supports_deactivate_key))\n\t\t\twritel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);\n\t\tisb();\n\n\t\t \n\t\tif (irqnr <= 15) {\n\t\t\tsmp_rmb();\n\n\t\t\t \n\t\t\tthis_cpu_write(sgi_intid, irqstat);\n\t\t}\n\n\t\tgeneric_handle_domain_irq(gic->domain, irqnr);\n\t} while (1);\n}\n\nstatic void gic_handle_cascade_irq(struct irq_desc *desc)\n{\n\tstruct gic_chip_data *chip_data = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned int gic_irq;\n\tunsigned long status;\n\tint ret;\n\n\tchained_irq_enter(chip, desc);\n\n\tstatus = readl_relaxed(gic_data_cpu_base(chip_data) + GIC_CPU_INTACK);\n\n\tgic_irq = (status & GICC_IAR_INT_ID_MASK);\n\tif (gic_irq == GICC_INT_SPURIOUS)\n\t\tgoto out;\n\n\tisb();\n\tret = generic_handle_domain_irq(chip_data->domain, gic_irq);\n\tif (unlikely(ret))\n\t\thandle_bad_irq(desc);\n out:\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void gic_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct gic_chip_data *gic = irq_data_get_irq_chip_data(d);\n\n\tif (gic->domain->pm_dev)\n\t\tseq_printf(p, gic->domain->pm_dev->of_node->name);\n\telse\n\t\tseq_printf(p, \"GIC-%d\", (int)(gic - &gic_data[0]));\n}\n\nvoid __init gic_cascade_irq(unsigned int gic_nr, unsigned int irq)\n{\n\tBUG_ON(gic_nr >= CONFIG_ARM_GIC_MAX_NR);\n\tirq_set_chained_handler_and_data(irq, gic_handle_cascade_irq,\n\t\t\t\t\t &gic_data[gic_nr]);\n}\n\nstatic u8 gic_get_cpumask(struct gic_chip_data *gic)\n{\n\tvoid __iomem *base = gic_data_dist_base(gic);\n\tu32 mask, i;\n\n\tfor (i = mask = 0; i < 32; i += 4) {\n\t\tmask = readl_relaxed(base + GIC_DIST_TARGET + i);\n\t\tmask |= mask >> 16;\n\t\tmask |= mask >> 8;\n\t\tif (mask)\n\t\t\tbreak;\n\t}\n\n\tif (!mask && num_possible_cpus() > 1)\n\t\tpr_crit(\"GIC CPU mask not found - kernel will fail to boot.\\n\");\n\n\treturn mask;\n}\n\nstatic bool gic_check_gicv2(void __iomem *base)\n{\n\tu32 val = readl_relaxed(base + GIC_CPU_IDENT);\n\treturn (val & 0xff0fff) == 0x02043B;\n}\n\nstatic void gic_cpu_if_up(struct gic_chip_data *gic)\n{\n\tvoid __iomem *cpu_base = gic_data_cpu_base(gic);\n\tu32 bypass = 0;\n\tu32 mode = 0;\n\tint i;\n\n\tif (gic == &gic_data[0] && static_branch_likely(&supports_deactivate_key))\n\t\tmode = GIC_CPU_CTRL_EOImodeNS;\n\n\tif (gic_check_gicv2(cpu_base))\n\t\tfor (i = 0; i < 4; i++)\n\t\t\twritel_relaxed(0, cpu_base + GIC_CPU_ACTIVEPRIO + i * 4);\n\n\t \n\tbypass = readl(cpu_base + GIC_CPU_CTRL);\n\tbypass &= GICC_DIS_BYPASS_MASK;\n\n\twritel_relaxed(bypass | mode | GICC_ENABLE, cpu_base + GIC_CPU_CTRL);\n}\n\n\nstatic void gic_dist_init(struct gic_chip_data *gic)\n{\n\tunsigned int i;\n\tu32 cpumask;\n\tunsigned int gic_irqs = gic->gic_irqs;\n\tvoid __iomem *base = gic_data_dist_base(gic);\n\n\twritel_relaxed(GICD_DISABLE, base + GIC_DIST_CTRL);\n\n\t \n\tcpumask = gic_get_cpumask(gic);\n\tcpumask |= cpumask << 8;\n\tcpumask |= cpumask << 16;\n\tfor (i = 32; i < gic_irqs; i += 4)\n\t\twritel_relaxed(cpumask, base + GIC_DIST_TARGET + i * 4 / 4);\n\n\tgic_dist_config(base, gic_irqs, NULL);\n\n\twritel_relaxed(GICD_ENABLE, base + GIC_DIST_CTRL);\n}\n\nstatic int gic_cpu_init(struct gic_chip_data *gic)\n{\n\tvoid __iomem *dist_base = gic_data_dist_base(gic);\n\tvoid __iomem *base = gic_data_cpu_base(gic);\n\tunsigned int cpu_mask, cpu = smp_processor_id();\n\tint i;\n\n\t \n\tif (gic == &gic_data[0]) {\n\t\t \n\t\tif (WARN_ON(cpu >= NR_GIC_CPU_IF))\n\t\t\treturn -EINVAL;\n\n\t\tgic_check_cpu_features();\n\t\tcpu_mask = gic_get_cpumask(gic);\n\t\tgic_cpu_map[cpu] = cpu_mask;\n\n\t\t \n\t\tfor (i = 0; i < NR_GIC_CPU_IF; i++)\n\t\t\tif (i != cpu)\n\t\t\t\tgic_cpu_map[i] &= ~cpu_mask;\n\t}\n\n\tgic_cpu_config(dist_base, 32, NULL);\n\n\twritel_relaxed(GICC_INT_PRI_THRESHOLD, base + GIC_CPU_PRIMASK);\n\tgic_cpu_if_up(gic);\n\n\treturn 0;\n}\n\nint gic_cpu_if_down(unsigned int gic_nr)\n{\n\tvoid __iomem *cpu_base;\n\tu32 val = 0;\n\n\tif (gic_nr >= CONFIG_ARM_GIC_MAX_NR)\n\t\treturn -EINVAL;\n\n\tcpu_base = gic_data_cpu_base(&gic_data[gic_nr]);\n\tval = readl(cpu_base + GIC_CPU_CTRL);\n\tval &= ~GICC_ENABLE;\n\twritel_relaxed(val, cpu_base + GIC_CPU_CTRL);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_CPU_PM) || defined(CONFIG_ARM_GIC_PM)\n \nvoid gic_dist_save(struct gic_chip_data *gic)\n{\n\tunsigned int gic_irqs;\n\tvoid __iomem *dist_base;\n\tint i;\n\n\tif (WARN_ON(!gic))\n\t\treturn;\n\n\tgic_irqs = gic->gic_irqs;\n\tdist_base = gic_data_dist_base(gic);\n\n\tif (!dist_base)\n\t\treturn;\n\n\tfor (i = 0; i < DIV_ROUND_UP(gic_irqs, 16); i++)\n\t\tgic->saved_spi_conf[i] =\n\t\t\treadl_relaxed(dist_base + GIC_DIST_CONFIG + i * 4);\n\n\tfor (i = 0; i < DIV_ROUND_UP(gic_irqs, 4); i++)\n\t\tgic->saved_spi_target[i] =\n\t\t\treadl_relaxed(dist_base + GIC_DIST_TARGET + i * 4);\n\n\tfor (i = 0; i < DIV_ROUND_UP(gic_irqs, 32); i++)\n\t\tgic->saved_spi_enable[i] =\n\t\t\treadl_relaxed(dist_base + GIC_DIST_ENABLE_SET + i * 4);\n\n\tfor (i = 0; i < DIV_ROUND_UP(gic_irqs, 32); i++)\n\t\tgic->saved_spi_active[i] =\n\t\t\treadl_relaxed(dist_base + GIC_DIST_ACTIVE_SET + i * 4);\n}\n\n \nvoid gic_dist_restore(struct gic_chip_data *gic)\n{\n\tunsigned int gic_irqs;\n\tunsigned int i;\n\tvoid __iomem *dist_base;\n\n\tif (WARN_ON(!gic))\n\t\treturn;\n\n\tgic_irqs = gic->gic_irqs;\n\tdist_base = gic_data_dist_base(gic);\n\n\tif (!dist_base)\n\t\treturn;\n\n\twritel_relaxed(GICD_DISABLE, dist_base + GIC_DIST_CTRL);\n\n\tfor (i = 0; i < DIV_ROUND_UP(gic_irqs, 16); i++)\n\t\twritel_relaxed(gic->saved_spi_conf[i],\n\t\t\tdist_base + GIC_DIST_CONFIG + i * 4);\n\n\tfor (i = 0; i < DIV_ROUND_UP(gic_irqs, 4); i++)\n\t\twritel_relaxed(GICD_INT_DEF_PRI_X4,\n\t\t\tdist_base + GIC_DIST_PRI + i * 4);\n\n\tfor (i = 0; i < DIV_ROUND_UP(gic_irqs, 4); i++)\n\t\twritel_relaxed(gic->saved_spi_target[i],\n\t\t\tdist_base + GIC_DIST_TARGET + i * 4);\n\n\tfor (i = 0; i < DIV_ROUND_UP(gic_irqs, 32); i++) {\n\t\twritel_relaxed(GICD_INT_EN_CLR_X32,\n\t\t\tdist_base + GIC_DIST_ENABLE_CLEAR + i * 4);\n\t\twritel_relaxed(gic->saved_spi_enable[i],\n\t\t\tdist_base + GIC_DIST_ENABLE_SET + i * 4);\n\t}\n\n\tfor (i = 0; i < DIV_ROUND_UP(gic_irqs, 32); i++) {\n\t\twritel_relaxed(GICD_INT_EN_CLR_X32,\n\t\t\tdist_base + GIC_DIST_ACTIVE_CLEAR + i * 4);\n\t\twritel_relaxed(gic->saved_spi_active[i],\n\t\t\tdist_base + GIC_DIST_ACTIVE_SET + i * 4);\n\t}\n\n\twritel_relaxed(GICD_ENABLE, dist_base + GIC_DIST_CTRL);\n}\n\nvoid gic_cpu_save(struct gic_chip_data *gic)\n{\n\tint i;\n\tu32 *ptr;\n\tvoid __iomem *dist_base;\n\tvoid __iomem *cpu_base;\n\n\tif (WARN_ON(!gic))\n\t\treturn;\n\n\tdist_base = gic_data_dist_base(gic);\n\tcpu_base = gic_data_cpu_base(gic);\n\n\tif (!dist_base || !cpu_base)\n\t\treturn;\n\n\tptr = raw_cpu_ptr(gic->saved_ppi_enable);\n\tfor (i = 0; i < DIV_ROUND_UP(32, 32); i++)\n\t\tptr[i] = readl_relaxed(dist_base + GIC_DIST_ENABLE_SET + i * 4);\n\n\tptr = raw_cpu_ptr(gic->saved_ppi_active);\n\tfor (i = 0; i < DIV_ROUND_UP(32, 32); i++)\n\t\tptr[i] = readl_relaxed(dist_base + GIC_DIST_ACTIVE_SET + i * 4);\n\n\tptr = raw_cpu_ptr(gic->saved_ppi_conf);\n\tfor (i = 0; i < DIV_ROUND_UP(32, 16); i++)\n\t\tptr[i] = readl_relaxed(dist_base + GIC_DIST_CONFIG + i * 4);\n\n}\n\nvoid gic_cpu_restore(struct gic_chip_data *gic)\n{\n\tint i;\n\tu32 *ptr;\n\tvoid __iomem *dist_base;\n\tvoid __iomem *cpu_base;\n\n\tif (WARN_ON(!gic))\n\t\treturn;\n\n\tdist_base = gic_data_dist_base(gic);\n\tcpu_base = gic_data_cpu_base(gic);\n\n\tif (!dist_base || !cpu_base)\n\t\treturn;\n\n\tptr = raw_cpu_ptr(gic->saved_ppi_enable);\n\tfor (i = 0; i < DIV_ROUND_UP(32, 32); i++) {\n\t\twritel_relaxed(GICD_INT_EN_CLR_X32,\n\t\t\t       dist_base + GIC_DIST_ENABLE_CLEAR + i * 4);\n\t\twritel_relaxed(ptr[i], dist_base + GIC_DIST_ENABLE_SET + i * 4);\n\t}\n\n\tptr = raw_cpu_ptr(gic->saved_ppi_active);\n\tfor (i = 0; i < DIV_ROUND_UP(32, 32); i++) {\n\t\twritel_relaxed(GICD_INT_EN_CLR_X32,\n\t\t\t       dist_base + GIC_DIST_ACTIVE_CLEAR + i * 4);\n\t\twritel_relaxed(ptr[i], dist_base + GIC_DIST_ACTIVE_SET + i * 4);\n\t}\n\n\tptr = raw_cpu_ptr(gic->saved_ppi_conf);\n\tfor (i = 0; i < DIV_ROUND_UP(32, 16); i++)\n\t\twritel_relaxed(ptr[i], dist_base + GIC_DIST_CONFIG + i * 4);\n\n\tfor (i = 0; i < DIV_ROUND_UP(32, 4); i++)\n\t\twritel_relaxed(GICD_INT_DEF_PRI_X4,\n\t\t\t\t\tdist_base + GIC_DIST_PRI + i * 4);\n\n\twritel_relaxed(GICC_INT_PRI_THRESHOLD, cpu_base + GIC_CPU_PRIMASK);\n\tgic_cpu_if_up(gic);\n}\n\nstatic int gic_notifier(struct notifier_block *self, unsigned long cmd,\tvoid *v)\n{\n\tint i;\n\n\tfor (i = 0; i < CONFIG_ARM_GIC_MAX_NR; i++) {\n\t\tswitch (cmd) {\n\t\tcase CPU_PM_ENTER:\n\t\t\tgic_cpu_save(&gic_data[i]);\n\t\t\tbreak;\n\t\tcase CPU_PM_ENTER_FAILED:\n\t\tcase CPU_PM_EXIT:\n\t\t\tgic_cpu_restore(&gic_data[i]);\n\t\t\tbreak;\n\t\tcase CPU_CLUSTER_PM_ENTER:\n\t\t\tgic_dist_save(&gic_data[i]);\n\t\t\tbreak;\n\t\tcase CPU_CLUSTER_PM_ENTER_FAILED:\n\t\tcase CPU_CLUSTER_PM_EXIT:\n\t\t\tgic_dist_restore(&gic_data[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block gic_notifier_block = {\n\t.notifier_call = gic_notifier,\n};\n\nstatic int gic_pm_init(struct gic_chip_data *gic)\n{\n\tgic->saved_ppi_enable = __alloc_percpu(DIV_ROUND_UP(32, 32) * 4,\n\t\tsizeof(u32));\n\tif (WARN_ON(!gic->saved_ppi_enable))\n\t\treturn -ENOMEM;\n\n\tgic->saved_ppi_active = __alloc_percpu(DIV_ROUND_UP(32, 32) * 4,\n\t\tsizeof(u32));\n\tif (WARN_ON(!gic->saved_ppi_active))\n\t\tgoto free_ppi_enable;\n\n\tgic->saved_ppi_conf = __alloc_percpu(DIV_ROUND_UP(32, 16) * 4,\n\t\tsizeof(u32));\n\tif (WARN_ON(!gic->saved_ppi_conf))\n\t\tgoto free_ppi_active;\n\n\tif (gic == &gic_data[0])\n\t\tcpu_pm_register_notifier(&gic_notifier_block);\n\n\treturn 0;\n\nfree_ppi_active:\n\tfree_percpu(gic->saved_ppi_active);\nfree_ppi_enable:\n\tfree_percpu(gic->saved_ppi_enable);\n\n\treturn -ENOMEM;\n}\n#else\nstatic int gic_pm_init(struct gic_chip_data *gic)\n{\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_SMP\nstatic void rmw_writeb(u8 bval, void __iomem *addr)\n{\n\tstatic DEFINE_RAW_SPINLOCK(rmw_lock);\n\tunsigned long offset = (unsigned long)addr & 3UL;\n\tunsigned long shift = offset * 8;\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&rmw_lock, flags);\n\n\taddr -= offset;\n\tval = readl_relaxed(addr);\n\tval &= ~GENMASK(shift + 7, shift);\n\tval |= bval << shift;\n\twritel_relaxed(val, addr);\n\n\traw_spin_unlock_irqrestore(&rmw_lock, flags);\n}\n\nstatic int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,\n\t\t\t    bool force)\n{\n\tvoid __iomem *reg = gic_dist_base(d) + GIC_DIST_TARGET + gic_irq(d);\n\tstruct gic_chip_data *gic = irq_data_get_irq_chip_data(d);\n\tunsigned int cpu;\n\n\tif (unlikely(gic != &gic_data[0]))\n\t\treturn -EINVAL;\n\n\tif (!force)\n\t\tcpu = cpumask_any_and(mask_val, cpu_online_mask);\n\telse\n\t\tcpu = cpumask_first(mask_val);\n\n\tif (cpu >= NR_GIC_CPU_IF || cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (static_branch_unlikely(&needs_rmw_access))\n\t\trmw_writeb(gic_cpu_map[cpu], reg);\n\telse\n\t\twriteb_relaxed(gic_cpu_map[cpu], reg);\n\tirq_data_update_effective_affinity(d, cpumask_of(cpu));\n\n\treturn IRQ_SET_MASK_OK_DONE;\n}\n\nstatic void gic_ipi_send_mask(struct irq_data *d, const struct cpumask *mask)\n{\n\tint cpu;\n\tunsigned long flags, map = 0;\n\n\tif (unlikely(nr_cpu_ids == 1)) {\n\t\t \n\t\twritel_relaxed(2 << 24 | d->hwirq,\n\t\t\t       gic_data_dist_base(&gic_data[0]) + GIC_DIST_SOFTINT);\n\t\treturn;\n\t}\n\n\tgic_lock_irqsave(flags);\n\n\t \n\tfor_each_cpu(cpu, mask)\n\t\tmap |= gic_cpu_map[cpu];\n\n\t \n\tdmb(ishst);\n\n\t \n\twritel_relaxed(map << 16 | d->hwirq, gic_data_dist_base(&gic_data[0]) + GIC_DIST_SOFTINT);\n\n\tgic_unlock_irqrestore(flags);\n}\n\nstatic int gic_starting_cpu(unsigned int cpu)\n{\n\tgic_cpu_init(&gic_data[0]);\n\treturn 0;\n}\n\nstatic __init void gic_smp_init(void)\n{\n\tstruct irq_fwspec sgi_fwspec = {\n\t\t.fwnode\t\t= gic_data[0].domain->fwnode,\n\t\t.param_count\t= 1,\n\t};\n\tint base_sgi;\n\n\tcpuhp_setup_state_nocalls(CPUHP_AP_IRQ_GIC_STARTING,\n\t\t\t\t  \"irqchip/arm/gic:starting\",\n\t\t\t\t  gic_starting_cpu, NULL);\n\n\tbase_sgi = irq_domain_alloc_irqs(gic_data[0].domain, 8, NUMA_NO_NODE, &sgi_fwspec);\n\tif (WARN_ON(base_sgi <= 0))\n\t\treturn;\n\n\tset_smp_ipi_range(base_sgi, 8);\n}\n#else\n#define gic_smp_init()\t\tdo { } while(0)\n#define gic_set_affinity\tNULL\n#define gic_ipi_send_mask\tNULL\n#endif\n\nstatic const struct irq_chip gic_chip = {\n\t.irq_mask\t\t= gic_mask_irq,\n\t.irq_unmask\t\t= gic_unmask_irq,\n\t.irq_eoi\t\t= gic_eoi_irq,\n\t.irq_set_type\t\t= gic_set_type,\n\t.irq_retrigger          = gic_retrigger,\n\t.irq_set_affinity\t= gic_set_affinity,\n\t.ipi_send_mask\t\t= gic_ipi_send_mask,\n\t.irq_get_irqchip_state\t= gic_irq_get_irqchip_state,\n\t.irq_set_irqchip_state\t= gic_irq_set_irqchip_state,\n\t.irq_print_chip\t\t= gic_irq_print_chip,\n\t.flags\t\t\t= IRQCHIP_SET_TYPE_MASKED |\n\t\t\t\t  IRQCHIP_SKIP_SET_WAKE |\n\t\t\t\t  IRQCHIP_MASK_ON_SUSPEND,\n};\n\nstatic const struct irq_chip gic_chip_mode1 = {\n\t.name\t\t\t= \"GICv2\",\n\t.irq_mask\t\t= gic_eoimode1_mask_irq,\n\t.irq_unmask\t\t= gic_unmask_irq,\n\t.irq_eoi\t\t= gic_eoimode1_eoi_irq,\n\t.irq_set_type\t\t= gic_set_type,\n\t.irq_retrigger          = gic_retrigger,\n\t.irq_set_affinity\t= gic_set_affinity,\n\t.ipi_send_mask\t\t= gic_ipi_send_mask,\n\t.irq_get_irqchip_state\t= gic_irq_get_irqchip_state,\n\t.irq_set_irqchip_state\t= gic_irq_set_irqchip_state,\n\t.irq_set_vcpu_affinity\t= gic_irq_set_vcpu_affinity,\n\t.flags\t\t\t= IRQCHIP_SET_TYPE_MASKED |\n\t\t\t\t  IRQCHIP_SKIP_SET_WAKE |\n\t\t\t\t  IRQCHIP_MASK_ON_SUSPEND,\n};\n\n#ifdef CONFIG_BL_SWITCHER\n \nvoid gic_send_sgi(unsigned int cpu_id, unsigned int irq)\n{\n\tBUG_ON(cpu_id >= NR_GIC_CPU_IF);\n\tcpu_id = 1 << cpu_id;\n\t \n\twritel_relaxed((cpu_id << 16) | irq, gic_data_dist_base(&gic_data[0]) + GIC_DIST_SOFTINT);\n}\n\n \nint gic_get_cpu_id(unsigned int cpu)\n{\n\tunsigned int cpu_bit;\n\n\tif (cpu >= NR_GIC_CPU_IF)\n\t\treturn -1;\n\tcpu_bit = gic_cpu_map[cpu];\n\tif (cpu_bit & (cpu_bit - 1))\n\t\treturn -1;\n\treturn __ffs(cpu_bit);\n}\n\n \nvoid gic_migrate_target(unsigned int new_cpu_id)\n{\n\tunsigned int cur_cpu_id, gic_irqs, gic_nr = 0;\n\tvoid __iomem *dist_base;\n\tint i, ror_val, cpu = smp_processor_id();\n\tu32 val, cur_target_mask, active_mask;\n\n\tBUG_ON(gic_nr >= CONFIG_ARM_GIC_MAX_NR);\n\n\tdist_base = gic_data_dist_base(&gic_data[gic_nr]);\n\tif (!dist_base)\n\t\treturn;\n\tgic_irqs = gic_data[gic_nr].gic_irqs;\n\n\tcur_cpu_id = __ffs(gic_cpu_map[cpu]);\n\tcur_target_mask = 0x01010101 << cur_cpu_id;\n\tror_val = (cur_cpu_id - new_cpu_id) & 31;\n\n\tgic_lock();\n\n\t \n\tgic_cpu_map[cpu] = 1 << new_cpu_id;\n\n\t \n\tfor (i = 8; i < DIV_ROUND_UP(gic_irqs, 4); i++) {\n\t\tval = readl_relaxed(dist_base + GIC_DIST_TARGET + i * 4);\n\t\tactive_mask = val & cur_target_mask;\n\t\tif (active_mask) {\n\t\t\tval &= ~active_mask;\n\t\t\tval |= ror32(active_mask, ror_val);\n\t\t\twritel_relaxed(val, dist_base + GIC_DIST_TARGET + i*4);\n\t\t}\n\t}\n\n\tgic_unlock();\n\n\t \n\tfor (i = 0; i < 16; i += 4) {\n\t\tint j;\n\t\tval = readl_relaxed(dist_base + GIC_DIST_SGI_PENDING_SET + i);\n\t\tif (!val)\n\t\t\tcontinue;\n\t\twritel_relaxed(val, dist_base + GIC_DIST_SGI_PENDING_CLEAR + i);\n\t\tfor (j = i; j < i + 4; j++) {\n\t\t\tif (val & 0xff)\n\t\t\t\twritel_relaxed((1 << (new_cpu_id + 16)) | j,\n\t\t\t\t\t\tdist_base + GIC_DIST_SOFTINT);\n\t\t\tval >>= 8;\n\t\t}\n\t}\n}\n\n \nstatic unsigned long gic_dist_physaddr;\n\nunsigned long gic_get_sgir_physaddr(void)\n{\n\tif (!gic_dist_physaddr)\n\t\treturn 0;\n\treturn gic_dist_physaddr + GIC_DIST_SOFTINT;\n}\n\nstatic void __init gic_init_physaddr(struct device_node *node)\n{\n\tstruct resource res;\n\tif (of_address_to_resource(node, 0, &res) == 0) {\n\t\tgic_dist_physaddr = res.start;\n\t\tpr_info(\"GIC physical location is %#lx\\n\", gic_dist_physaddr);\n\t}\n}\n\n#else\n#define gic_init_physaddr(node)  do { } while (0)\n#endif\n\nstatic int gic_irq_domain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t\tirq_hw_number_t hw)\n{\n\tstruct gic_chip_data *gic = d->host_data;\n\tstruct irq_data *irqd = irq_desc_get_irq_data(irq_to_desc(irq));\n\tconst struct irq_chip *chip;\n\n\tchip = (static_branch_likely(&supports_deactivate_key) &&\n\t\tgic == &gic_data[0]) ? &gic_chip_mode1 : &gic_chip;\n\n\tswitch (hw) {\n\tcase 0 ... 31:\n\t\tirq_set_percpu_devid(irq);\n\t\tirq_domain_set_info(d, irq, hw, chip, d->host_data,\n\t\t\t\t    handle_percpu_devid_irq, NULL, NULL);\n\t\tbreak;\n\tdefault:\n\t\tirq_domain_set_info(d, irq, hw, chip, d->host_data,\n\t\t\t\t    handle_fasteoi_irq, NULL, NULL);\n\t\tirq_set_probe(irq);\n\t\tirqd_set_single_target(irqd);\n\t\tbreak;\n\t}\n\n\t \n\tirqd_set_handle_enforce_irqctx(irqd);\n\treturn 0;\n}\n\nstatic int gic_irq_domain_translate(struct irq_domain *d,\n\t\t\t\t    struct irq_fwspec *fwspec,\n\t\t\t\t    unsigned long *hwirq,\n\t\t\t\t    unsigned int *type)\n{\n\tif (fwspec->param_count == 1 && fwspec->param[0] < 16) {\n\t\t*hwirq = fwspec->param[0];\n\t\t*type = IRQ_TYPE_EDGE_RISING;\n\t\treturn 0;\n\t}\n\n\tif (is_of_node(fwspec->fwnode)) {\n\t\tif (fwspec->param_count < 3)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (fwspec->param[0]) {\n\t\tcase 0:\t\t\t \n\t\t\t*hwirq = fwspec->param[1] + 32;\n\t\t\tbreak;\n\t\tcase 1:\t\t\t \n\t\t\t*hwirq = fwspec->param[1] + 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;\n\n\t\t \n\t\tWARN(*type == IRQ_TYPE_NONE,\n\t\t     \"HW irq %ld has invalid type\\n\", *hwirq);\n\t\treturn 0;\n\t}\n\n\tif (is_fwnode_irqchip(fwspec->fwnode)) {\n\t\tif(fwspec->param_count != 2)\n\t\t\treturn -EINVAL;\n\n\t\tif (fwspec->param[0] < 16) {\n\t\t\tpr_err(FW_BUG \"Illegal GSI%d translation request\\n\",\n\t\t\t       fwspec->param[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*hwirq = fwspec->param[0];\n\t\t*type = fwspec->param[1];\n\n\t\tWARN(*type == IRQ_TYPE_NONE,\n\t\t     \"HW irq %ld has invalid type\\n\", *hwirq);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int gic_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs, void *arg)\n{\n\tint i, ret;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tstruct irq_fwspec *fwspec = arg;\n\n\tret = gic_irq_domain_translate(domain, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tret = gic_irq_domain_map(domain, virq + i, hwirq + i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops gic_irq_domain_hierarchy_ops = {\n\t.translate = gic_irq_domain_translate,\n\t.alloc = gic_irq_domain_alloc,\n\t.free = irq_domain_free_irqs_top,\n};\n\nstatic int gic_init_bases(struct gic_chip_data *gic,\n\t\t\t  struct fwnode_handle *handle)\n{\n\tint gic_irqs, ret;\n\n\tif (IS_ENABLED(CONFIG_GIC_NON_BANKED) && gic->percpu_offset) {\n\t\t \n\t\tunsigned int cpu;\n\n\t\tgic->dist_base.percpu_base = alloc_percpu(void __iomem *);\n\t\tgic->cpu_base.percpu_base = alloc_percpu(void __iomem *);\n\t\tif (WARN_ON(!gic->dist_base.percpu_base ||\n\t\t\t    !gic->cpu_base.percpu_base)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tu32 mpidr = cpu_logical_map(cpu);\n\t\t\tu32 core_id = MPIDR_AFFINITY_LEVEL(mpidr, 0);\n\t\t\tunsigned long offset = gic->percpu_offset * core_id;\n\t\t\t*per_cpu_ptr(gic->dist_base.percpu_base, cpu) =\n\t\t\t\tgic->raw_dist_base + offset;\n\t\t\t*per_cpu_ptr(gic->cpu_base.percpu_base, cpu) =\n\t\t\t\tgic->raw_cpu_base + offset;\n\t\t}\n\n\t\tenable_frankengic();\n\t} else {\n\t\t \n\t\tWARN(gic->percpu_offset,\n\t\t     \"GIC_NON_BANKED not enabled, ignoring %08x offset!\",\n\t\t     gic->percpu_offset);\n\t\tgic->dist_base.common_base = gic->raw_dist_base;\n\t\tgic->cpu_base.common_base = gic->raw_cpu_base;\n\t}\n\n\t \n\tgic_irqs = readl_relaxed(gic_data_dist_base(gic) + GIC_DIST_CTR) & 0x1f;\n\tgic_irqs = (gic_irqs + 1) * 32;\n\tif (gic_irqs > 1020)\n\t\tgic_irqs = 1020;\n\tgic->gic_irqs = gic_irqs;\n\n\tgic->domain = irq_domain_create_linear(handle, gic_irqs,\n\t\t\t\t\t       &gic_irq_domain_hierarchy_ops,\n\t\t\t\t\t       gic);\n\tif (WARN_ON(!gic->domain)) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tgic_dist_init(gic);\n\tret = gic_cpu_init(gic);\n\tif (ret)\n\t\tgoto error;\n\n\tret = gic_pm_init(gic);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tif (IS_ENABLED(CONFIG_GIC_NON_BANKED) && gic->percpu_offset) {\n\t\tfree_percpu(gic->dist_base.percpu_base);\n\t\tfree_percpu(gic->cpu_base.percpu_base);\n\t}\n\n\treturn ret;\n}\n\nstatic int __init __gic_init_bases(struct gic_chip_data *gic,\n\t\t\t\t   struct fwnode_handle *handle)\n{\n\tint i, ret;\n\n\tif (WARN_ON(!gic || gic->domain))\n\t\treturn -EINVAL;\n\n\tif (gic == &gic_data[0]) {\n\t\t \n\t\tfor (i = 0; i < NR_GIC_CPU_IF; i++)\n\t\t\tgic_cpu_map[i] = 0xff;\n\n\t\tset_handle_irq(gic_handle_irq);\n\t\tif (static_branch_likely(&supports_deactivate_key))\n\t\t\tpr_info(\"GIC: Using split EOI/Deactivate mode\\n\");\n\t}\n\n\tret = gic_init_bases(gic, handle);\n\tif (gic == &gic_data[0])\n\t\tgic_smp_init();\n\n\treturn ret;\n}\n\nstatic void gic_teardown(struct gic_chip_data *gic)\n{\n\tif (WARN_ON(!gic))\n\t\treturn;\n\n\tif (gic->raw_dist_base)\n\t\tiounmap(gic->raw_dist_base);\n\tif (gic->raw_cpu_base)\n\t\tiounmap(gic->raw_cpu_base);\n}\n\nstatic int gic_cnt __initdata;\nstatic bool gicv2_force_probe;\n\nstatic int __init gicv2_force_probe_cfg(char *buf)\n{\n\treturn kstrtobool(buf, &gicv2_force_probe);\n}\nearly_param(\"irqchip.gicv2_force_probe\", gicv2_force_probe_cfg);\n\nstatic bool gic_check_eoimode(struct device_node *node, void __iomem **base)\n{\n\tstruct resource cpuif_res;\n\n\tof_address_to_resource(node, 1, &cpuif_res);\n\n\tif (!is_hyp_mode_available())\n\t\treturn false;\n\tif (resource_size(&cpuif_res) < SZ_8K) {\n\t\tvoid __iomem *alt;\n\t\t \n\t\tif (!gic_check_gicv2(*base))\n\t\t\treturn false;\n\n\t\tif (!gicv2_force_probe) {\n\t\t\tpr_warn(\"GIC: GICv2 detected, but range too small and irqchip.gicv2_force_probe not set\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\talt = ioremap(cpuif_res.start, SZ_8K);\n\t\tif (!alt)\n\t\t\treturn false;\n\t\tif (!gic_check_gicv2(alt + SZ_4K)) {\n\t\t\t \n\t\t\tpr_warn(\"GIC: GICv2 at %pa, but range is too small (broken DT?), assuming 8kB\\n\",\n\t\t\t\t&cpuif_res.start);\n\t\t\tiounmap(*base);\n\t\t\t*base = alt;\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\tiounmap(alt);\n\t\talt = ioremap(cpuif_res.start, SZ_128K);\n\t\tif (!alt)\n\t\t\treturn false;\n\t\tpr_warn(\"GIC: Aliased GICv2 at %pa, trying to find the canonical range over 128kB\\n\",\n\t\t\t&cpuif_res.start);\n\t\tcpuif_res.end = cpuif_res.start + SZ_128K -1;\n\t\tiounmap(*base);\n\t\t*base = alt;\n\t}\n\tif (resource_size(&cpuif_res) == SZ_128K) {\n\t\t \n\t\tif (!gic_check_gicv2(*base) ||\n\t\t    !gic_check_gicv2(*base + 0xf000))\n\t\t\treturn false;\n\n\t\t \n\t\t*base += 0xf000;\n\t\tcpuif_res.start += 0xf000;\n\t\tpr_warn(\"GIC: Adjusting CPU interface base to %pa\\n\",\n\t\t\t&cpuif_res.start);\n\t}\n\n\treturn true;\n}\n\nstatic bool gic_enable_rmw_access(void *data)\n{\n\t \n\tif (of_machine_is_compatible(\"renesas,emev2\")) {\n\t\tstatic_branch_enable(&needs_rmw_access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct gic_quirk gic_quirks[] = {\n\t{\n\t\t.desc\t\t= \"broken byte access\",\n\t\t.compatible\t= \"arm,pl390\",\n\t\t.init\t\t= gic_enable_rmw_access,\n\t},\n\t{ },\n};\n\nstatic int gic_of_setup(struct gic_chip_data *gic, struct device_node *node)\n{\n\tif (!gic || !node)\n\t\treturn -EINVAL;\n\n\tgic->raw_dist_base = of_iomap(node, 0);\n\tif (WARN(!gic->raw_dist_base, \"unable to map gic dist registers\\n\"))\n\t\tgoto error;\n\n\tgic->raw_cpu_base = of_iomap(node, 1);\n\tif (WARN(!gic->raw_cpu_base, \"unable to map gic cpu registers\\n\"))\n\t\tgoto error;\n\n\tif (of_property_read_u32(node, \"cpu-offset\", &gic->percpu_offset))\n\t\tgic->percpu_offset = 0;\n\n\tgic_enable_of_quirks(node, gic_quirks, gic);\n\n\treturn 0;\n\nerror:\n\tgic_teardown(gic);\n\n\treturn -ENOMEM;\n}\n\nint gic_of_init_child(struct device *dev, struct gic_chip_data **gic, int irq)\n{\n\tint ret;\n\n\tif (!dev || !dev->of_node || !gic || !irq)\n\t\treturn -EINVAL;\n\n\t*gic = devm_kzalloc(dev, sizeof(**gic), GFP_KERNEL);\n\tif (!*gic)\n\t\treturn -ENOMEM;\n\n\tret = gic_of_setup(*gic, dev->of_node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gic_init_bases(*gic, &dev->of_node->fwnode);\n\tif (ret) {\n\t\tgic_teardown(*gic);\n\t\treturn ret;\n\t}\n\n\tirq_domain_set_pm_device((*gic)->domain, dev);\n\tirq_set_chained_handler_and_data(irq, gic_handle_cascade_irq, *gic);\n\n\treturn 0;\n}\n\nstatic void __init gic_of_setup_kvm_info(struct device_node *node)\n{\n\tint ret;\n\tstruct resource *vctrl_res = &gic_v2_kvm_info.vctrl;\n\tstruct resource *vcpu_res = &gic_v2_kvm_info.vcpu;\n\n\tgic_v2_kvm_info.type = GIC_V2;\n\n\tgic_v2_kvm_info.maint_irq = irq_of_parse_and_map(node, 0);\n\tif (!gic_v2_kvm_info.maint_irq)\n\t\treturn;\n\n\tret = of_address_to_resource(node, 2, vctrl_res);\n\tif (ret)\n\t\treturn;\n\n\tret = of_address_to_resource(node, 3, vcpu_res);\n\tif (ret)\n\t\treturn;\n\n\tif (static_branch_likely(&supports_deactivate_key))\n\t\tvgic_set_kvm_info(&gic_v2_kvm_info);\n}\n\nint __init\ngic_of_init(struct device_node *node, struct device_node *parent)\n{\n\tstruct gic_chip_data *gic;\n\tint irq, ret;\n\n\tif (WARN_ON(!node))\n\t\treturn -ENODEV;\n\n\tif (WARN_ON(gic_cnt >= CONFIG_ARM_GIC_MAX_NR))\n\t\treturn -EINVAL;\n\n\tgic = &gic_data[gic_cnt];\n\n\tret = gic_of_setup(gic, node);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (gic_cnt == 0 && !gic_check_eoimode(node, &gic->raw_cpu_base))\n\t\tstatic_branch_disable(&supports_deactivate_key);\n\n\tret = __gic_init_bases(gic, &node->fwnode);\n\tif (ret) {\n\t\tgic_teardown(gic);\n\t\treturn ret;\n\t}\n\n\tif (!gic_cnt) {\n\t\tgic_init_physaddr(node);\n\t\tgic_of_setup_kvm_info(node);\n\t}\n\n\tif (parent) {\n\t\tirq = irq_of_parse_and_map(node, 0);\n\t\tgic_cascade_irq(gic_cnt, irq);\n\t}\n\n\tif (IS_ENABLED(CONFIG_ARM_GIC_V2M))\n\t\tgicv2m_init(&node->fwnode, gic_data[gic_cnt].domain);\n\n\tgic_cnt++;\n\treturn 0;\n}\nIRQCHIP_DECLARE(gic_400, \"arm,gic-400\", gic_of_init);\nIRQCHIP_DECLARE(arm11mp_gic, \"arm,arm11mp-gic\", gic_of_init);\nIRQCHIP_DECLARE(arm1176jzf_dc_gic, \"arm,arm1176jzf-devchip-gic\", gic_of_init);\nIRQCHIP_DECLARE(cortex_a15_gic, \"arm,cortex-a15-gic\", gic_of_init);\nIRQCHIP_DECLARE(cortex_a9_gic, \"arm,cortex-a9-gic\", gic_of_init);\nIRQCHIP_DECLARE(cortex_a7_gic, \"arm,cortex-a7-gic\", gic_of_init);\nIRQCHIP_DECLARE(msm_8660_qgic, \"qcom,msm-8660-qgic\", gic_of_init);\nIRQCHIP_DECLARE(msm_qgic2, \"qcom,msm-qgic2\", gic_of_init);\nIRQCHIP_DECLARE(pl390, \"arm,pl390\", gic_of_init);\n\n#ifdef CONFIG_ACPI\nstatic struct\n{\n\tphys_addr_t cpu_phys_base;\n\tu32 maint_irq;\n\tint maint_irq_mode;\n\tphys_addr_t vctrl_base;\n\tphys_addr_t vcpu_base;\n} acpi_data __initdata;\n\nstatic int __init\ngic_acpi_parse_madt_cpu(union acpi_subtable_headers *header,\n\t\t\tconst unsigned long end)\n{\n\tstruct acpi_madt_generic_interrupt *processor;\n\tphys_addr_t gic_cpu_base;\n\tstatic int cpu_base_assigned;\n\n\tprocessor = (struct acpi_madt_generic_interrupt *)header;\n\n\tif (BAD_MADT_GICC_ENTRY(processor, end))\n\t\treturn -EINVAL;\n\n\t \n\tgic_cpu_base = processor->base_address;\n\tif (cpu_base_assigned && gic_cpu_base != acpi_data.cpu_phys_base)\n\t\treturn -EINVAL;\n\n\tacpi_data.cpu_phys_base = gic_cpu_base;\n\tacpi_data.maint_irq = processor->vgic_interrupt;\n\tacpi_data.maint_irq_mode = (processor->flags & ACPI_MADT_VGIC_IRQ_MODE) ?\n\t\t\t\t    ACPI_EDGE_SENSITIVE : ACPI_LEVEL_SENSITIVE;\n\tacpi_data.vctrl_base = processor->gich_base_address;\n\tacpi_data.vcpu_base = processor->gicv_base_address;\n\n\tcpu_base_assigned = 1;\n\treturn 0;\n}\n\n \nstatic int __init acpi_dummy_func(union acpi_subtable_headers *header,\n\t\t\t\t  const unsigned long end)\n{\n\treturn 0;\n}\n\nstatic bool __init acpi_gic_redist_is_present(void)\n{\n\treturn acpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR,\n\t\t\t\t     acpi_dummy_func, 0) > 0;\n}\n\nstatic bool __init gic_validate_dist(struct acpi_subtable_header *header,\n\t\t\t\t     struct acpi_probe_entry *ape)\n{\n\tstruct acpi_madt_generic_distributor *dist;\n\tdist = (struct acpi_madt_generic_distributor *)header;\n\n\treturn (dist->version == ape->driver_data &&\n\t\t(dist->version != ACPI_MADT_GIC_VERSION_NONE ||\n\t\t !acpi_gic_redist_is_present()));\n}\n\n#define ACPI_GICV2_DIST_MEM_SIZE\t(SZ_4K)\n#define ACPI_GIC_CPU_IF_MEM_SIZE\t(SZ_8K)\n#define ACPI_GICV2_VCTRL_MEM_SIZE\t(SZ_4K)\n#define ACPI_GICV2_VCPU_MEM_SIZE\t(SZ_8K)\n\nstatic void __init gic_acpi_setup_kvm_info(void)\n{\n\tint irq;\n\tstruct resource *vctrl_res = &gic_v2_kvm_info.vctrl;\n\tstruct resource *vcpu_res = &gic_v2_kvm_info.vcpu;\n\n\tgic_v2_kvm_info.type = GIC_V2;\n\n\tif (!acpi_data.vctrl_base)\n\t\treturn;\n\n\tvctrl_res->flags = IORESOURCE_MEM;\n\tvctrl_res->start = acpi_data.vctrl_base;\n\tvctrl_res->end = vctrl_res->start + ACPI_GICV2_VCTRL_MEM_SIZE - 1;\n\n\tif (!acpi_data.vcpu_base)\n\t\treturn;\n\n\tvcpu_res->flags = IORESOURCE_MEM;\n\tvcpu_res->start = acpi_data.vcpu_base;\n\tvcpu_res->end = vcpu_res->start + ACPI_GICV2_VCPU_MEM_SIZE - 1;\n\n\tirq = acpi_register_gsi(NULL, acpi_data.maint_irq,\n\t\t\t\tacpi_data.maint_irq_mode,\n\t\t\t\tACPI_ACTIVE_HIGH);\n\tif (irq <= 0)\n\t\treturn;\n\n\tgic_v2_kvm_info.maint_irq = irq;\n\n\tvgic_set_kvm_info(&gic_v2_kvm_info);\n}\n\nstatic struct fwnode_handle *gsi_domain_handle;\n\nstatic struct fwnode_handle *gic_v2_get_gsi_domain_id(u32 gsi)\n{\n\treturn gsi_domain_handle;\n}\n\nstatic int __init gic_v2_acpi_init(union acpi_subtable_headers *header,\n\t\t\t\t   const unsigned long end)\n{\n\tstruct acpi_madt_generic_distributor *dist;\n\tstruct gic_chip_data *gic = &gic_data[0];\n\tint count, ret;\n\n\t \n\tcount = acpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_INTERRUPT,\n\t\t\t\t      gic_acpi_parse_madt_cpu, 0);\n\tif (count <= 0) {\n\t\tpr_err(\"No valid GICC entries exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgic->raw_cpu_base = ioremap(acpi_data.cpu_phys_base, ACPI_GIC_CPU_IF_MEM_SIZE);\n\tif (!gic->raw_cpu_base) {\n\t\tpr_err(\"Unable to map GICC registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdist = (struct acpi_madt_generic_distributor *)header;\n\tgic->raw_dist_base = ioremap(dist->base_address,\n\t\t\t\t     ACPI_GICV2_DIST_MEM_SIZE);\n\tif (!gic->raw_dist_base) {\n\t\tpr_err(\"Unable to map GICD registers\\n\");\n\t\tgic_teardown(gic);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (!is_hyp_mode_available())\n\t\tstatic_branch_disable(&supports_deactivate_key);\n\n\t \n\tgsi_domain_handle = irq_domain_alloc_fwnode(&dist->base_address);\n\tif (!gsi_domain_handle) {\n\t\tpr_err(\"Unable to allocate domain handle\\n\");\n\t\tgic_teardown(gic);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = __gic_init_bases(gic, gsi_domain_handle);\n\tif (ret) {\n\t\tpr_err(\"Failed to initialise GIC\\n\");\n\t\tirq_domain_free_fwnode(gsi_domain_handle);\n\t\tgic_teardown(gic);\n\t\treturn ret;\n\t}\n\n\tacpi_set_irq_model(ACPI_IRQ_MODEL_GIC, gic_v2_get_gsi_domain_id);\n\n\tif (IS_ENABLED(CONFIG_ARM_GIC_V2M))\n\t\tgicv2m_init(NULL, gic_data[0].domain);\n\n\tif (static_branch_likely(&supports_deactivate_key))\n\t\tgic_acpi_setup_kvm_info();\n\n\treturn 0;\n}\nIRQCHIP_ACPI_DECLARE(gic_v2, ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR,\n\t\t     gic_validate_dist, ACPI_MADT_GIC_VERSION_V2,\n\t\t     gic_v2_acpi_init);\nIRQCHIP_ACPI_DECLARE(gic_v2_maybe, ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR,\n\t\t     gic_validate_dist, ACPI_MADT_GIC_VERSION_NONE,\n\t\t     gic_v2_acpi_init);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}