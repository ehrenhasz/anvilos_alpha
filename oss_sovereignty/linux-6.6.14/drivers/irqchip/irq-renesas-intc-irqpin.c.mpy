{
  "module_name": "irq-renesas-intc-irqpin.c",
  "hash_id": "663ae6f9c89d662d49426c39e39c6672c83ea56ab3cf0aa39e3b3c3141191b07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-renesas-intc-irqpin.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n\n#define INTC_IRQPIN_MAX 8  \n\n#define INTC_IRQPIN_REG_SENSE 0  \n#define INTC_IRQPIN_REG_PRIO 1  \n#define INTC_IRQPIN_REG_SOURCE 2  \n#define INTC_IRQPIN_REG_MASK 3  \n#define INTC_IRQPIN_REG_CLEAR 4  \n#define INTC_IRQPIN_REG_NR_MANDATORY 5\n#define INTC_IRQPIN_REG_IRLM 5  \n#define INTC_IRQPIN_REG_NR 6\n\n \n\nstruct intc_irqpin_iomem {\n\tvoid __iomem *iomem;\n\tunsigned long (*read)(void __iomem *iomem);\n\tvoid (*write)(void __iomem *iomem, unsigned long data);\n\tint width;\n};\n\nstruct intc_irqpin_irq {\n\tint hw_irq;\n\tint requested_irq;\n\tint domain_irq;\n\tstruct intc_irqpin_priv *p;\n};\n\nstruct intc_irqpin_priv {\n\tstruct intc_irqpin_iomem iomem[INTC_IRQPIN_REG_NR];\n\tstruct intc_irqpin_irq irq[INTC_IRQPIN_MAX];\n\tunsigned int sense_bitfield_width;\n\tstruct platform_device *pdev;\n\tstruct irq_chip irq_chip;\n\tstruct irq_domain *irq_domain;\n\tatomic_t wakeup_path;\n\tunsigned shared_irqs:1;\n\tu8 shared_irq_mask;\n};\n\nstruct intc_irqpin_config {\n\tint irlm_bit;\t\t \n};\n\nstatic unsigned long intc_irqpin_read32(void __iomem *iomem)\n{\n\treturn ioread32(iomem);\n}\n\nstatic unsigned long intc_irqpin_read8(void __iomem *iomem)\n{\n\treturn ioread8(iomem);\n}\n\nstatic void intc_irqpin_write32(void __iomem *iomem, unsigned long data)\n{\n\tiowrite32(data, iomem);\n}\n\nstatic void intc_irqpin_write8(void __iomem *iomem, unsigned long data)\n{\n\tiowrite8(data, iomem);\n}\n\nstatic inline unsigned long intc_irqpin_read(struct intc_irqpin_priv *p,\n\t\t\t\t\t     int reg)\n{\n\tstruct intc_irqpin_iomem *i = &p->iomem[reg];\n\n\treturn i->read(i->iomem);\n}\n\nstatic inline void intc_irqpin_write(struct intc_irqpin_priv *p,\n\t\t\t\t     int reg, unsigned long data)\n{\n\tstruct intc_irqpin_iomem *i = &p->iomem[reg];\n\n\ti->write(i->iomem, data);\n}\n\nstatic inline unsigned long intc_irqpin_hwirq_mask(struct intc_irqpin_priv *p,\n\t\t\t\t\t\t   int reg, int hw_irq)\n{\n\treturn BIT((p->iomem[reg].width - 1) - hw_irq);\n}\n\nstatic inline void intc_irqpin_irq_write_hwirq(struct intc_irqpin_priv *p,\n\t\t\t\t\t       int reg, int hw_irq)\n{\n\tintc_irqpin_write(p, reg, intc_irqpin_hwirq_mask(p, reg, hw_irq));\n}\n\nstatic DEFINE_RAW_SPINLOCK(intc_irqpin_lock);  \n\nstatic void intc_irqpin_read_modify_write(struct intc_irqpin_priv *p,\n\t\t\t\t\t  int reg, int shift,\n\t\t\t\t\t  int width, int value)\n{\n\tunsigned long flags;\n\tunsigned long tmp;\n\n\traw_spin_lock_irqsave(&intc_irqpin_lock, flags);\n\n\ttmp = intc_irqpin_read(p, reg);\n\ttmp &= ~(((1 << width) - 1) << shift);\n\ttmp |= value << shift;\n\tintc_irqpin_write(p, reg, tmp);\n\n\traw_spin_unlock_irqrestore(&intc_irqpin_lock, flags);\n}\n\nstatic void intc_irqpin_mask_unmask_prio(struct intc_irqpin_priv *p,\n\t\t\t\t\t int irq, int do_mask)\n{\n\t \n\tint bitfield_width = 4;\n\tint shift = 32 - (irq + 1) * bitfield_width;\n\n\tintc_irqpin_read_modify_write(p, INTC_IRQPIN_REG_PRIO,\n\t\t\t\t      shift, bitfield_width,\n\t\t\t\t      do_mask ? 0 : (1 << bitfield_width) - 1);\n}\n\nstatic int intc_irqpin_set_sense(struct intc_irqpin_priv *p, int irq, int value)\n{\n\t \n\tint bitfield_width = p->sense_bitfield_width;\n\tint shift = 32 - (irq + 1) * bitfield_width;\n\n\tdev_dbg(&p->pdev->dev, \"sense irq = %d, mode = %d\\n\", irq, value);\n\n\tif (value >= (1 << bitfield_width))\n\t\treturn -EINVAL;\n\n\tintc_irqpin_read_modify_write(p, INTC_IRQPIN_REG_SENSE, shift,\n\t\t\t\t      bitfield_width, value);\n\treturn 0;\n}\n\nstatic void intc_irqpin_dbg(struct intc_irqpin_irq *i, char *str)\n{\n\tdev_dbg(&i->p->pdev->dev, \"%s (%d:%d:%d)\\n\",\n\t\tstr, i->requested_irq, i->hw_irq, i->domain_irq);\n}\n\nstatic void intc_irqpin_irq_enable(struct irq_data *d)\n{\n\tstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\n\tint hw_irq = irqd_to_hwirq(d);\n\n\tintc_irqpin_dbg(&p->irq[hw_irq], \"enable\");\n\tintc_irqpin_irq_write_hwirq(p, INTC_IRQPIN_REG_CLEAR, hw_irq);\n}\n\nstatic void intc_irqpin_irq_disable(struct irq_data *d)\n{\n\tstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\n\tint hw_irq = irqd_to_hwirq(d);\n\n\tintc_irqpin_dbg(&p->irq[hw_irq], \"disable\");\n\tintc_irqpin_irq_write_hwirq(p, INTC_IRQPIN_REG_MASK, hw_irq);\n}\n\nstatic void intc_irqpin_shared_irq_enable(struct irq_data *d)\n{\n\tstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\n\tint hw_irq = irqd_to_hwirq(d);\n\n\tintc_irqpin_dbg(&p->irq[hw_irq], \"shared enable\");\n\tintc_irqpin_irq_write_hwirq(p, INTC_IRQPIN_REG_CLEAR, hw_irq);\n\n\tp->shared_irq_mask &= ~BIT(hw_irq);\n}\n\nstatic void intc_irqpin_shared_irq_disable(struct irq_data *d)\n{\n\tstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\n\tint hw_irq = irqd_to_hwirq(d);\n\n\tintc_irqpin_dbg(&p->irq[hw_irq], \"shared disable\");\n\tintc_irqpin_irq_write_hwirq(p, INTC_IRQPIN_REG_MASK, hw_irq);\n\n\tp->shared_irq_mask |= BIT(hw_irq);\n}\n\nstatic void intc_irqpin_irq_enable_force(struct irq_data *d)\n{\n\tstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\n\tint irq = p->irq[irqd_to_hwirq(d)].requested_irq;\n\n\tintc_irqpin_irq_enable(d);\n\n\t \n\tirq_get_chip(irq)->irq_unmask(irq_get_irq_data(irq));\n}\n\nstatic void intc_irqpin_irq_disable_force(struct irq_data *d)\n{\n\tstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\n\tint irq = p->irq[irqd_to_hwirq(d)].requested_irq;\n\n\t \n\tirq_get_chip(irq)->irq_mask(irq_get_irq_data(irq));\n\tintc_irqpin_irq_disable(d);\n}\n\n#define INTC_IRQ_SENSE_VALID 0x10\n#define INTC_IRQ_SENSE(x) (x + INTC_IRQ_SENSE_VALID)\n\nstatic unsigned char intc_irqpin_sense[IRQ_TYPE_SENSE_MASK + 1] = {\n\t[IRQ_TYPE_EDGE_FALLING] = INTC_IRQ_SENSE(0x00),\n\t[IRQ_TYPE_EDGE_RISING] = INTC_IRQ_SENSE(0x01),\n\t[IRQ_TYPE_LEVEL_LOW] = INTC_IRQ_SENSE(0x02),\n\t[IRQ_TYPE_LEVEL_HIGH] = INTC_IRQ_SENSE(0x03),\n\t[IRQ_TYPE_EDGE_BOTH] = INTC_IRQ_SENSE(0x04),\n};\n\nstatic int intc_irqpin_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tunsigned char value = intc_irqpin_sense[type & IRQ_TYPE_SENSE_MASK];\n\tstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\n\n\tif (!(value & INTC_IRQ_SENSE_VALID))\n\t\treturn -EINVAL;\n\n\treturn intc_irqpin_set_sense(p, irqd_to_hwirq(d),\n\t\t\t\t     value ^ INTC_IRQ_SENSE_VALID);\n}\n\nstatic int intc_irqpin_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct intc_irqpin_priv *p = irq_data_get_irq_chip_data(d);\n\tint hw_irq = irqd_to_hwirq(d);\n\n\tirq_set_irq_wake(p->irq[hw_irq].requested_irq, on);\n\tif (on)\n\t\tatomic_inc(&p->wakeup_path);\n\telse\n\t\tatomic_dec(&p->wakeup_path);\n\n\treturn 0;\n}\n\nstatic irqreturn_t intc_irqpin_irq_handler(int irq, void *dev_id)\n{\n\tstruct intc_irqpin_irq *i = dev_id;\n\tstruct intc_irqpin_priv *p = i->p;\n\tunsigned long bit;\n\n\tintc_irqpin_dbg(i, \"demux1\");\n\tbit = intc_irqpin_hwirq_mask(p, INTC_IRQPIN_REG_SOURCE, i->hw_irq);\n\n\tif (intc_irqpin_read(p, INTC_IRQPIN_REG_SOURCE) & bit) {\n\t\tintc_irqpin_write(p, INTC_IRQPIN_REG_SOURCE, ~bit);\n\t\tintc_irqpin_dbg(i, \"demux2\");\n\t\tgeneric_handle_irq(i->domain_irq);\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t intc_irqpin_shared_irq_handler(int irq, void *dev_id)\n{\n\tstruct intc_irqpin_priv *p = dev_id;\n\tunsigned int reg_source = intc_irqpin_read(p, INTC_IRQPIN_REG_SOURCE);\n\tirqreturn_t status = IRQ_NONE;\n\tint k;\n\n\tfor (k = 0; k < 8; k++) {\n\t\tif (reg_source & BIT(7 - k)) {\n\t\t\tif (BIT(k) & p->shared_irq_mask)\n\t\t\t\tcontinue;\n\n\t\t\tstatus |= intc_irqpin_irq_handler(irq, &p->irq[k]);\n\t\t}\n\t}\n\n\treturn status;\n}\n\n \nstatic struct lock_class_key intc_irqpin_irq_lock_class;\n\n \nstatic struct lock_class_key intc_irqpin_irq_request_class;\n\nstatic int intc_irqpin_irq_domain_map(struct irq_domain *h, unsigned int virq,\n\t\t\t\t      irq_hw_number_t hw)\n{\n\tstruct intc_irqpin_priv *p = h->host_data;\n\n\tp->irq[hw].domain_irq = virq;\n\tp->irq[hw].hw_irq = hw;\n\n\tintc_irqpin_dbg(&p->irq[hw], \"map\");\n\tirq_set_chip_data(virq, h->host_data);\n\tirq_set_lockdep_class(virq, &intc_irqpin_irq_lock_class,\n\t\t\t      &intc_irqpin_irq_request_class);\n\tirq_set_chip_and_handler(virq, &p->irq_chip, handle_level_irq);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops intc_irqpin_irq_domain_ops = {\n\t.map\t= intc_irqpin_irq_domain_map,\n\t.xlate  = irq_domain_xlate_twocell,\n};\n\nstatic const struct intc_irqpin_config intc_irqpin_irlm_r8a777x = {\n\t.irlm_bit = 23,  \n};\n\nstatic const struct intc_irqpin_config intc_irqpin_rmobile = {\n\t.irlm_bit = -1,\n};\n\nstatic const struct of_device_id intc_irqpin_dt_ids[] = {\n\t{ .compatible = \"renesas,intc-irqpin\", },\n\t{ .compatible = \"renesas,intc-irqpin-r8a7778\",\n\t  .data = &intc_irqpin_irlm_r8a777x },\n\t{ .compatible = \"renesas,intc-irqpin-r8a7779\",\n\t  .data = &intc_irqpin_irlm_r8a777x },\n\t{ .compatible = \"renesas,intc-irqpin-r8a7740\",\n\t  .data = &intc_irqpin_rmobile },\n\t{ .compatible = \"renesas,intc-irqpin-sh73a0\",\n\t  .data = &intc_irqpin_rmobile },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, intc_irqpin_dt_ids);\n\nstatic int intc_irqpin_probe(struct platform_device *pdev)\n{\n\tconst struct intc_irqpin_config *config;\n\tstruct device *dev = &pdev->dev;\n\tstruct intc_irqpin_priv *p;\n\tstruct intc_irqpin_iomem *i;\n\tstruct resource *io[INTC_IRQPIN_REG_NR];\n\tstruct irq_chip *irq_chip;\n\tvoid (*enable_fn)(struct irq_data *d);\n\tvoid (*disable_fn)(struct irq_data *d);\n\tconst char *name = dev_name(dev);\n\tbool control_parent;\n\tunsigned int nirqs;\n\tint ref_irq;\n\tint ret;\n\tint k;\n\n\tp = devm_kzalloc(dev, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\t \n\tof_property_read_u32(dev->of_node, \"sense-bitfield-width\",\n\t\t\t     &p->sense_bitfield_width);\n\tcontrol_parent = of_property_read_bool(dev->of_node, \"control-parent\");\n\tif (!p->sense_bitfield_width)\n\t\tp->sense_bitfield_width = 4;  \n\n\tp->pdev = pdev;\n\tplatform_set_drvdata(pdev, p);\n\n\tconfig = of_device_get_match_data(dev);\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\t \n\tmemset(io, 0, sizeof(io));\n\tfor (k = 0; k < INTC_IRQPIN_REG_NR; k++) {\n\t\tio[k] = platform_get_resource(pdev, IORESOURCE_MEM, k);\n\t\tif (!io[k] && k < INTC_IRQPIN_REG_NR_MANDATORY) {\n\t\t\tdev_err(dev, \"not enough IOMEM resources\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err0;\n\t\t}\n\t}\n\n\t \n\tfor (k = 0; k < INTC_IRQPIN_MAX; k++) {\n\t\tret = platform_get_irq_optional(pdev, k);\n\t\tif (ret == -ENXIO)\n\t\t\tbreak;\n\t\tif (ret < 0)\n\t\t\tgoto err0;\n\n\t\tp->irq[k].p = p;\n\t\tp->irq[k].requested_irq = ret;\n\t}\n\n\tnirqs = k;\n\tif (nirqs < 1) {\n\t\tdev_err(dev, \"not enough IRQ resources\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err0;\n\t}\n\n\t \n\tfor (k = 0; k < INTC_IRQPIN_REG_NR; k++) {\n\t\ti = &p->iomem[k];\n\n\t\t \n\t\tif (!io[k])\n\t\t\tcontinue;\n\n\t\tswitch (resource_size(io[k])) {\n\t\tcase 1:\n\t\t\ti->width = 8;\n\t\t\ti->read = intc_irqpin_read8;\n\t\t\ti->write = intc_irqpin_write8;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ti->width = 32;\n\t\t\ti->read = intc_irqpin_read32;\n\t\t\ti->write = intc_irqpin_write32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"IOMEM size mismatch\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err0;\n\t\t}\n\n\t\ti->iomem = devm_ioremap(dev, io[k]->start,\n\t\t\t\t\tresource_size(io[k]));\n\t\tif (!i->iomem) {\n\t\t\tdev_err(dev, \"failed to remap IOMEM\\n\");\n\t\t\tret = -ENXIO;\n\t\t\tgoto err0;\n\t\t}\n\t}\n\n\t \n\tif (config && config->irlm_bit >= 0) {\n\t\tif (io[INTC_IRQPIN_REG_IRLM])\n\t\t\tintc_irqpin_read_modify_write(p, INTC_IRQPIN_REG_IRLM,\n\t\t\t\t\t\t      config->irlm_bit, 1, 1);\n\t\telse\n\t\t\tdev_warn(dev, \"unable to select IRLM mode\\n\");\n\t}\n\n\t \n\tfor (k = 0; k < nirqs; k++)\n\t\tintc_irqpin_mask_unmask_prio(p, k, 1);\n\n\t \n\tintc_irqpin_write(p, INTC_IRQPIN_REG_SOURCE, 0x0);\n\n\t \n\tref_irq = p->irq[0].requested_irq;\n\tp->shared_irqs = 1;\n\tfor (k = 1; k < nirqs; k++) {\n\t\tif (ref_irq != p->irq[k].requested_irq) {\n\t\t\tp->shared_irqs = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (control_parent) {\n\t\tenable_fn = intc_irqpin_irq_enable_force;\n\t\tdisable_fn = intc_irqpin_irq_disable_force;\n\t} else if (!p->shared_irqs) {\n\t\tenable_fn = intc_irqpin_irq_enable;\n\t\tdisable_fn = intc_irqpin_irq_disable;\n\t} else {\n\t\tenable_fn = intc_irqpin_shared_irq_enable;\n\t\tdisable_fn = intc_irqpin_shared_irq_disable;\n\t}\n\n\tirq_chip = &p->irq_chip;\n\tirq_chip->name = \"intc-irqpin\";\n\tirq_chip->irq_mask = disable_fn;\n\tirq_chip->irq_unmask = enable_fn;\n\tirq_chip->irq_set_type = intc_irqpin_irq_set_type;\n\tirq_chip->irq_set_wake = intc_irqpin_irq_set_wake;\n\tirq_chip->flags\t= IRQCHIP_MASK_ON_SUSPEND;\n\n\tp->irq_domain = irq_domain_add_simple(dev->of_node, nirqs, 0,\n\t\t\t\t\t      &intc_irqpin_irq_domain_ops, p);\n\tif (!p->irq_domain) {\n\t\tret = -ENXIO;\n\t\tdev_err(dev, \"cannot initialize irq domain\\n\");\n\t\tgoto err0;\n\t}\n\n\tirq_domain_set_pm_device(p->irq_domain, dev);\n\n\tif (p->shared_irqs) {\n\t\t \n\t\tif (devm_request_irq(dev, p->irq[0].requested_irq,\n\t\t\t\tintc_irqpin_shared_irq_handler,\n\t\t\t\tIRQF_SHARED, name, p)) {\n\t\t\tdev_err(dev, \"failed to request low IRQ\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto err1;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (k = 0; k < nirqs; k++) {\n\t\t\tif (devm_request_irq(dev, p->irq[k].requested_irq,\n\t\t\t\t\t     intc_irqpin_irq_handler, 0, name,\n\t\t\t\t\t     &p->irq[k])) {\n\t\t\t\tdev_err(dev, \"failed to request low IRQ\\n\");\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto err1;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (k = 0; k < nirqs; k++)\n\t\tintc_irqpin_mask_unmask_prio(p, k, 0);\n\n\tdev_info(dev, \"driving %d irqs\\n\", nirqs);\n\n\treturn 0;\n\nerr1:\n\tirq_domain_remove(p->irq_domain);\nerr0:\n\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic int intc_irqpin_remove(struct platform_device *pdev)\n{\n\tstruct intc_irqpin_priv *p = platform_get_drvdata(pdev);\n\n\tirq_domain_remove(p->irq_domain);\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\treturn 0;\n}\n\nstatic int __maybe_unused intc_irqpin_suspend(struct device *dev)\n{\n\tstruct intc_irqpin_priv *p = dev_get_drvdata(dev);\n\n\tif (atomic_read(&p->wakeup_path))\n\t\tdevice_set_wakeup_path(dev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(intc_irqpin_pm_ops, intc_irqpin_suspend, NULL);\n\nstatic struct platform_driver intc_irqpin_device_driver = {\n\t.probe\t\t= intc_irqpin_probe,\n\t.remove\t\t= intc_irqpin_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"renesas_intc_irqpin\",\n\t\t.of_match_table = intc_irqpin_dt_ids,\n\t\t.pm\t= &intc_irqpin_pm_ops,\n\t}\n};\n\nstatic int __init intc_irqpin_init(void)\n{\n\treturn platform_driver_register(&intc_irqpin_device_driver);\n}\npostcore_initcall(intc_irqpin_init);\n\nstatic void __exit intc_irqpin_exit(void)\n{\n\tplatform_driver_unregister(&intc_irqpin_device_driver);\n}\nmodule_exit(intc_irqpin_exit);\n\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_DESCRIPTION(\"Renesas INTC External IRQ Pin Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}