{
  "module_name": "irq-qcom-mpm.c",
  "hash_id": "d997a29d9b8b29d8447a77ae874555a1d728757efedbfeaeb9fc6281e46fd209",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-qcom-mpm.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/irq.h>\n#include <linux/spinlock.h>\n\n \n\n#define MPM_REG_ENABLE\t\t0\n#define MPM_REG_FALLING_EDGE\t1\n#define MPM_REG_RISING_EDGE\t2\n#define MPM_REG_POLARITY\t3\n#define MPM_REG_STATUS\t\t4\n\n \nstruct mpm_gic_map {\n\tint pin;\n\tirq_hw_number_t hwirq;\n};\n\nstruct qcom_mpm_priv {\n\tvoid __iomem *base;\n\traw_spinlock_t lock;\n\tstruct mbox_client mbox_client;\n\tstruct mbox_chan *mbox_chan;\n\tstruct mpm_gic_map *maps;\n\tunsigned int map_cnt;\n\tunsigned int reg_stride;\n\tstruct irq_domain *domain;\n\tstruct generic_pm_domain genpd;\n};\n\nstatic u32 qcom_mpm_read(struct qcom_mpm_priv *priv, unsigned int reg,\n\t\t\t unsigned int index)\n{\n\tunsigned int offset = (reg * priv->reg_stride + index + 2) * 4;\n\n\treturn readl_relaxed(priv->base + offset);\n}\n\nstatic void qcom_mpm_write(struct qcom_mpm_priv *priv, unsigned int reg,\n\t\t\t   unsigned int index, u32 val)\n{\n\tunsigned int offset = (reg * priv->reg_stride + index + 2) * 4;\n\n\twritel_relaxed(val, priv->base + offset);\n\n\t \n\twmb();\n}\n\nstatic void qcom_mpm_enable_irq(struct irq_data *d, bool en)\n{\n\tstruct qcom_mpm_priv *priv = d->chip_data;\n\tint pin = d->hwirq;\n\tunsigned int index = pin / 32;\n\tunsigned int shift = pin % 32;\n\tunsigned long flags, val;\n\n\traw_spin_lock_irqsave(&priv->lock, flags);\n\n\tval = qcom_mpm_read(priv, MPM_REG_ENABLE, index);\n\t__assign_bit(shift, &val, en);\n\tqcom_mpm_write(priv, MPM_REG_ENABLE, index, val);\n\n\traw_spin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void qcom_mpm_mask(struct irq_data *d)\n{\n\tqcom_mpm_enable_irq(d, false);\n\n\tif (d->parent_data)\n\t\tirq_chip_mask_parent(d);\n}\n\nstatic void qcom_mpm_unmask(struct irq_data *d)\n{\n\tqcom_mpm_enable_irq(d, true);\n\n\tif (d->parent_data)\n\t\tirq_chip_unmask_parent(d);\n}\n\nstatic void mpm_set_type(struct qcom_mpm_priv *priv, bool set, unsigned int reg,\n\t\t\t unsigned int index, unsigned int shift)\n{\n\tunsigned long flags, val;\n\n\traw_spin_lock_irqsave(&priv->lock, flags);\n\n\tval = qcom_mpm_read(priv, reg, index);\n\t__assign_bit(shift, &val, set);\n\tqcom_mpm_write(priv, reg, index, val);\n\n\traw_spin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int qcom_mpm_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct qcom_mpm_priv *priv = d->chip_data;\n\tint pin = d->hwirq;\n\tunsigned int index = pin / 32;\n\tunsigned int shift = pin % 32;\n\n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tmpm_set_type(priv, true, MPM_REG_RISING_EDGE, index, shift);\n\telse\n\t\tmpm_set_type(priv, false, MPM_REG_RISING_EDGE, index, shift);\n\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tmpm_set_type(priv, true, MPM_REG_FALLING_EDGE, index, shift);\n\telse\n\t\tmpm_set_type(priv, false, MPM_REG_FALLING_EDGE, index, shift);\n\n\tif (type & IRQ_TYPE_LEVEL_HIGH)\n\t\tmpm_set_type(priv, true, MPM_REG_POLARITY, index, shift);\n\telse\n\t\tmpm_set_type(priv, false, MPM_REG_POLARITY, index, shift);\n\n\tif (!d->parent_data)\n\t\treturn 0;\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\ttype = IRQ_TYPE_EDGE_RISING;\n\n\tif (type & IRQ_TYPE_LEVEL_MASK)\n\t\ttype = IRQ_TYPE_LEVEL_HIGH;\n\n\treturn irq_chip_set_type_parent(d, type);\n}\n\nstatic struct irq_chip qcom_mpm_chip = {\n\t.name\t\t\t= \"mpm\",\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_mask\t\t= qcom_mpm_mask,\n\t.irq_unmask\t\t= qcom_mpm_unmask,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_set_type\t\t= qcom_mpm_set_type,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.flags\t\t\t= IRQCHIP_MASK_ON_SUSPEND |\n\t\t\t\t  IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic struct mpm_gic_map *get_mpm_gic_map(struct qcom_mpm_priv *priv, int pin)\n{\n\tstruct mpm_gic_map *maps = priv->maps;\n\tint i;\n\n\tfor (i = 0; i < priv->map_cnt; i++) {\n\t\tif (maps[i].pin == pin)\n\t\t\treturn &maps[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int qcom_mpm_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t  unsigned int nr_irqs, void *data)\n{\n\tstruct qcom_mpm_priv *priv = domain->host_data;\n\tstruct irq_fwspec *fwspec = data;\n\tstruct irq_fwspec parent_fwspec;\n\tstruct mpm_gic_map *map;\n\tirq_hw_number_t pin;\n\tunsigned int type;\n\tint  ret;\n\n\tret = irq_domain_translate_twocell(domain, fwspec, &pin, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = irq_domain_set_hwirq_and_chip(domain, virq, pin,\n\t\t\t\t\t    &qcom_mpm_chip, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tmap = get_mpm_gic_map(priv, pin);\n\tif (map == NULL)\n\t\treturn irq_domain_disconnect_hierarchy(domain->parent, virq);\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\ttype = IRQ_TYPE_EDGE_RISING;\n\n\tif (type & IRQ_TYPE_LEVEL_MASK)\n\t\ttype = IRQ_TYPE_LEVEL_HIGH;\n\n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\tparent_fwspec.param_count = 3;\n\tparent_fwspec.param[0] = 0;\n\tparent_fwspec.param[1] = map->hwirq;\n\tparent_fwspec.param[2] = type;\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs,\n\t\t\t\t\t    &parent_fwspec);\n}\n\nstatic const struct irq_domain_ops qcom_mpm_ops = {\n\t.alloc\t\t= qcom_mpm_alloc,\n\t.free\t\t= irq_domain_free_irqs_common,\n\t.translate\t= irq_domain_translate_twocell,\n};\n\n \nstatic irqreturn_t qcom_mpm_handler(int irq, void *dev_id)\n{\n\tstruct qcom_mpm_priv *priv = dev_id;\n\tunsigned long enable, pending;\n\tirqreturn_t ret = IRQ_NONE;\n\tunsigned long flags;\n\tint i, j;\n\n\tfor (i = 0; i < priv->reg_stride; i++) {\n\t\traw_spin_lock_irqsave(&priv->lock, flags);\n\t\tenable = qcom_mpm_read(priv, MPM_REG_ENABLE, i);\n\t\tpending = qcom_mpm_read(priv, MPM_REG_STATUS, i);\n\t\tpending &= enable;\n\t\traw_spin_unlock_irqrestore(&priv->lock, flags);\n\n\t\tfor_each_set_bit(j, &pending, 32) {\n\t\t\tunsigned int pin = 32 * i + j;\n\t\t\tstruct irq_desc *desc = irq_resolve_mapping(priv->domain, pin);\n\t\t\tstruct irq_data *d = &desc->irq_data;\n\n\t\t\tif (!irqd_is_level_type(d))\n\t\t\t\tirq_set_irqchip_state(d->irq,\n\t\t\t\t\t\tIRQCHIP_STATE_PENDING, true);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int mpm_pd_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct qcom_mpm_priv *priv = container_of(genpd, struct qcom_mpm_priv,\n\t\t\t\t\t\t  genpd);\n\tint i, ret;\n\n\tfor (i = 0; i < priv->reg_stride; i++)\n\t\tqcom_mpm_write(priv, MPM_REG_STATUS, i, 0);\n\n\t \n\tret = mbox_send_message(priv->mbox_chan, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic bool gic_hwirq_is_mapped(struct mpm_gic_map *maps, int cnt, u32 hwirq)\n{\n\tint i;\n\n\tfor (i = 0; i < cnt; i++)\n\t\tif (maps[i].hwirq == hwirq)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int qcom_mpm_init(struct device_node *np, struct device_node *parent)\n{\n\tstruct platform_device *pdev = of_find_device_by_node(np);\n\tstruct device *dev = &pdev->dev;\n\tstruct irq_domain *parent_domain;\n\tstruct generic_pm_domain *genpd;\n\tstruct qcom_mpm_priv *priv;\n\tunsigned int pin_cnt;\n\tint i, irq;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(np, \"qcom,mpm-pin-count\", &pin_cnt);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read qcom,mpm-pin-count: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->reg_stride = DIV_ROUND_UP(pin_cnt, 32);\n\n\tret = of_property_count_u32_elems(np, \"qcom,mpm-pin-map\");\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read qcom,mpm-pin-map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ret % 2) {\n\t\tdev_err(dev, \"invalid qcom,mpm-pin-map\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->map_cnt = ret / 2;\n\tpriv->maps = devm_kcalloc(dev, priv->map_cnt, sizeof(*priv->maps),\n\t\t\t\t  GFP_KERNEL);\n\tif (!priv->maps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < priv->map_cnt; i++) {\n\t\tu32 pin, hwirq;\n\n\t\tof_property_read_u32_index(np, \"qcom,mpm-pin-map\", i * 2, &pin);\n\t\tof_property_read_u32_index(np, \"qcom,mpm-pin-map\", i * 2 + 1, &hwirq);\n\n\t\tif (gic_hwirq_is_mapped(priv->maps, i, hwirq)) {\n\t\t\tdev_warn(dev, \"failed to map pin %d as GIC hwirq %d is already mapped\\n\",\n\t\t\t\t pin, hwirq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpriv->maps[i].pin = pin;\n\t\tpriv->maps[i].hwirq = hwirq;\n\t}\n\n\traw_spin_lock_init(&priv->lock);\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tfor (i = 0; i < priv->reg_stride; i++) {\n\t\tqcom_mpm_write(priv, MPM_REG_ENABLE, i, 0);\n\t\tqcom_mpm_write(priv, MPM_REG_FALLING_EDGE, i, 0);\n\t\tqcom_mpm_write(priv, MPM_REG_RISING_EDGE, i, 0);\n\t\tqcom_mpm_write(priv, MPM_REG_POLARITY, i, 0);\n\t\tqcom_mpm_write(priv, MPM_REG_STATUS, i, 0);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tgenpd = &priv->genpd;\n\tgenpd->flags = GENPD_FLAG_IRQ_SAFE;\n\tgenpd->power_off = mpm_pd_power_off;\n\n\tgenpd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s\", dev_name(dev));\n\tif (!genpd->name)\n\t\treturn -ENOMEM;\n\n\tret = pm_genpd_init(genpd, NULL, false);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init genpd: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_genpd_add_provider_simple(np, genpd);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add genpd provider: %d\\n\", ret);\n\t\tgoto remove_genpd;\n\t}\n\n\tpriv->mbox_client.dev = dev;\n\tpriv->mbox_chan = mbox_request_channel(&priv->mbox_client, 0);\n\tif (IS_ERR(priv->mbox_chan)) {\n\t\tret = PTR_ERR(priv->mbox_chan);\n\t\tdev_err(dev, \"failed to acquire IPC channel: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tdev_err(dev, \"failed to find MPM parent domain\\n\");\n\t\tret = -ENXIO;\n\t\tgoto free_mbox;\n\t}\n\n\tpriv->domain = irq_domain_create_hierarchy(parent_domain,\n\t\t\t\tIRQ_DOMAIN_FLAG_QCOM_MPM_WAKEUP, pin_cnt,\n\t\t\t\tof_node_to_fwnode(np), &qcom_mpm_ops, priv);\n\tif (!priv->domain) {\n\t\tdev_err(dev, \"failed to create MPM domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_mbox;\n\t}\n\n\tirq_domain_update_bus_token(priv->domain, DOMAIN_BUS_WAKEUP);\n\n\tret = devm_request_irq(dev, irq, qcom_mpm_handler, IRQF_NO_SUSPEND,\n\t\t\t       \"qcom_mpm\", priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq: %d\\n\", ret);\n\t\tgoto remove_domain;\n\t}\n\n\treturn 0;\n\nremove_domain:\n\tirq_domain_remove(priv->domain);\nfree_mbox:\n\tmbox_free_channel(priv->mbox_chan);\nremove_genpd:\n\tpm_genpd_remove(genpd);\n\treturn ret;\n}\n\nIRQCHIP_PLATFORM_DRIVER_BEGIN(qcom_mpm)\nIRQCHIP_MATCH(\"qcom,mpm\", qcom_mpm_init)\nIRQCHIP_PLATFORM_DRIVER_END(qcom_mpm)\nMODULE_DESCRIPTION(\"Qualcomm Technologies, Inc. MSM Power Manager\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}