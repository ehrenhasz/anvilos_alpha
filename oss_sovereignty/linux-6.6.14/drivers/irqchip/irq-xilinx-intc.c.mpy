{
  "module_name": "irq-xilinx-intc.c",
  "hash_id": "8232e39e43d1c2f7af20c007a1377b769804b46ac0ea4c3f51348ce68a8f266d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-xilinx-intc.c",
  "human_readable_source": " \n\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/of_address.h>\n#include <linux/io.h>\n#include <linux/jump_label.h>\n#include <linux/bug.h>\n#include <linux/of_irq.h>\n\n \n#define ISR 0x00\t\t\t \n#define IPR 0x04\t\t\t \n#define IER 0x08\t\t\t \n#define IAR 0x0c\t\t\t \n#define SIE 0x10\t\t\t \n#define CIE 0x14\t\t\t \n#define IVR 0x18\t\t\t \n#define MER 0x1c\t\t\t \n\n#define MER_ME (1<<0)\n#define MER_HIE (1<<1)\n\n#define SPURIOUS_IRQ\t(-1U)\n\nstatic DEFINE_STATIC_KEY_FALSE(xintc_is_be);\n\nstruct xintc_irq_chip {\n\tvoid\t\t__iomem *base;\n\tstruct\t\tirq_domain *root_domain;\n\tu32\t\tintr_mask;\n\tu32\t\tnr_irq;\n};\n\nstatic struct xintc_irq_chip *primary_intc;\n\nstatic void xintc_write(struct xintc_irq_chip *irqc, int reg, u32 data)\n{\n\tif (static_branch_unlikely(&xintc_is_be))\n\t\tiowrite32be(data, irqc->base + reg);\n\telse\n\t\tiowrite32(data, irqc->base + reg);\n}\n\nstatic u32 xintc_read(struct xintc_irq_chip *irqc, int reg)\n{\n\tif (static_branch_unlikely(&xintc_is_be))\n\t\treturn ioread32be(irqc->base + reg);\n\telse\n\t\treturn ioread32(irqc->base + reg);\n}\n\nstatic void intc_enable_or_unmask(struct irq_data *d)\n{\n\tstruct xintc_irq_chip *irqc = irq_data_get_irq_chip_data(d);\n\tunsigned long mask = BIT(d->hwirq);\n\n\tpr_debug(\"irq-xilinx: enable_or_unmask: %ld\\n\", d->hwirq);\n\n\t \n\tif (irqd_is_level_type(d))\n\t\txintc_write(irqc, IAR, mask);\n\n\txintc_write(irqc, SIE, mask);\n}\n\nstatic void intc_disable_or_mask(struct irq_data *d)\n{\n\tstruct xintc_irq_chip *irqc = irq_data_get_irq_chip_data(d);\n\n\tpr_debug(\"irq-xilinx: disable: %ld\\n\", d->hwirq);\n\txintc_write(irqc, CIE, BIT(d->hwirq));\n}\n\nstatic void intc_ack(struct irq_data *d)\n{\n\tstruct xintc_irq_chip *irqc = irq_data_get_irq_chip_data(d);\n\n\tpr_debug(\"irq-xilinx: ack: %ld\\n\", d->hwirq);\n\txintc_write(irqc, IAR, BIT(d->hwirq));\n}\n\nstatic void intc_mask_ack(struct irq_data *d)\n{\n\tstruct xintc_irq_chip *irqc = irq_data_get_irq_chip_data(d);\n\tunsigned long mask = BIT(d->hwirq);\n\n\tpr_debug(\"irq-xilinx: disable_and_ack: %ld\\n\", d->hwirq);\n\txintc_write(irqc, CIE, mask);\n\txintc_write(irqc, IAR, mask);\n}\n\nstatic struct irq_chip intc_dev = {\n\t.name = \"Xilinx INTC\",\n\t.irq_unmask = intc_enable_or_unmask,\n\t.irq_mask = intc_disable_or_mask,\n\t.irq_ack = intc_ack,\n\t.irq_mask_ack = intc_mask_ack,\n};\n\nstatic int xintc_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)\n{\n\tstruct xintc_irq_chip *irqc = d->host_data;\n\n\tif (irqc->intr_mask & BIT(hw)) {\n\t\tirq_set_chip_and_handler_name(irq, &intc_dev,\n\t\t\t\t\t      handle_edge_irq, \"edge\");\n\t\tirq_clear_status_flags(irq, IRQ_LEVEL);\n\t} else {\n\t\tirq_set_chip_and_handler_name(irq, &intc_dev,\n\t\t\t\t\t      handle_level_irq, \"level\");\n\t\tirq_set_status_flags(irq, IRQ_LEVEL);\n\t}\n\tirq_set_chip_data(irq, irqc);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops xintc_irq_domain_ops = {\n\t.xlate = irq_domain_xlate_onetwocell,\n\t.map = xintc_map,\n};\n\nstatic void xil_intc_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct xintc_irq_chip *irqc;\n\n\tirqc = irq_data_get_irq_handler_data(&desc->irq_data);\n\tchained_irq_enter(chip, desc);\n\tdo {\n\t\tu32 hwirq = xintc_read(irqc, IVR);\n\n\t\tif (hwirq == -1U)\n\t\t\tbreak;\n\n\t\tgeneric_handle_domain_irq(irqc->root_domain, hwirq);\n\t} while (true);\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void xil_intc_handle_irq(struct pt_regs *regs)\n{\n\tu32 hwirq;\n\n\tdo {\n\t\thwirq = xintc_read(primary_intc, IVR);\n\t\tif (unlikely(hwirq == SPURIOUS_IRQ))\n\t\t\tbreak;\n\n\t\tgeneric_handle_domain_irq(primary_intc->root_domain, hwirq);\n\t} while (true);\n}\n\nstatic int __init xilinx_intc_of_init(struct device_node *intc,\n\t\t\t\t\t     struct device_node *parent)\n{\n\tstruct xintc_irq_chip *irqc;\n\tint ret, irq;\n\n\tirqc = kzalloc(sizeof(*irqc), GFP_KERNEL);\n\tif (!irqc)\n\t\treturn -ENOMEM;\n\tirqc->base = of_iomap(intc, 0);\n\tBUG_ON(!irqc->base);\n\n\tret = of_property_read_u32(intc, \"xlnx,num-intr-inputs\", &irqc->nr_irq);\n\tif (ret < 0) {\n\t\tpr_err(\"irq-xilinx: unable to read xlnx,num-intr-inputs\\n\");\n\t\tgoto error;\n\t}\n\n\tret = of_property_read_u32(intc, \"xlnx,kind-of-intr\", &irqc->intr_mask);\n\tif (ret < 0) {\n\t\tpr_warn(\"irq-xilinx: unable to read xlnx,kind-of-intr\\n\");\n\t\tirqc->intr_mask = 0;\n\t}\n\n\tif (irqc->intr_mask >> irqc->nr_irq)\n\t\tpr_warn(\"irq-xilinx: mismatch in kind-of-intr param\\n\");\n\n\tpr_info(\"irq-xilinx: %pOF: num_irq=%d, edge=0x%x\\n\",\n\t\tintc, irqc->nr_irq, irqc->intr_mask);\n\n\n\t \n\txintc_write(irqc, IER, 0);\n\n\t \n\txintc_write(irqc, IAR, 0xffffffff);\n\n\t \n\txintc_write(irqc, MER, MER_HIE | MER_ME);\n\tif (xintc_read(irqc, MER) != (MER_HIE | MER_ME)) {\n\t\tstatic_branch_enable(&xintc_is_be);\n\t\txintc_write(irqc, MER, MER_HIE | MER_ME);\n\t}\n\n\tirqc->root_domain = irq_domain_add_linear(intc, irqc->nr_irq,\n\t\t\t\t\t\t  &xintc_irq_domain_ops, irqc);\n\tif (!irqc->root_domain) {\n\t\tpr_err(\"irq-xilinx: Unable to create IRQ domain\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (parent) {\n\t\tirq = irq_of_parse_and_map(intc, 0);\n\t\tif (irq) {\n\t\t\tirq_set_chained_handler_and_data(irq,\n\t\t\t\t\t\t\t xil_intc_irq_handler,\n\t\t\t\t\t\t\t irqc);\n\t\t} else {\n\t\t\tpr_err(\"irq-xilinx: interrupts property not in DT\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tprimary_intc = irqc;\n\t\tirq_set_default_host(primary_intc->root_domain);\n\t\tset_handle_irq(xil_intc_handle_irq);\n\t}\n\n\treturn 0;\n\nerror:\n\tiounmap(irqc->base);\n\tkfree(irqc);\n\treturn ret;\n\n}\n\nIRQCHIP_DECLARE(xilinx_intc_xps, \"xlnx,xps-intc-1.00.a\", xilinx_intc_of_init);\nIRQCHIP_DECLARE(xilinx_intc_opb, \"xlnx,opb-intc-1.00.c\", xilinx_intc_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}