{
  "module_name": "irq-tb10x.c",
  "hash_id": "d8f546aa9c7aef2801b1b85c73d56ce6b249ce8f07706924b04c30e10a863879",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-tb10x.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\n#define AB_IRQCTL_INT_ENABLE   0x00\n#define AB_IRQCTL_INT_STATUS   0x04\n#define AB_IRQCTL_SRC_MODE     0x08\n#define AB_IRQCTL_SRC_POLARITY 0x0C\n#define AB_IRQCTL_INT_MODE     0x10\n#define AB_IRQCTL_INT_POLARITY 0x14\n#define AB_IRQCTL_INT_FORCE    0x18\n\n#define AB_IRQCTL_MAXIRQ       32\n\nstatic inline void ab_irqctl_writereg(struct irq_chip_generic *gc, u32 reg,\n\tu32 val)\n{\n\tirq_reg_writel(gc, val, reg);\n}\n\nstatic inline u32 ab_irqctl_readreg(struct irq_chip_generic *gc, u32 reg)\n{\n\treturn irq_reg_readl(gc, reg);\n}\n\nstatic int tb10x_irq_set_type(struct irq_data *data, unsigned int flow_type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\n\tuint32_t im, mod, pol;\n\n\tim = data->mask;\n\n\tirq_gc_lock(gc);\n\n\tmod = ab_irqctl_readreg(gc, AB_IRQCTL_SRC_MODE) | im;\n\tpol = ab_irqctl_readreg(gc, AB_IRQCTL_SRC_POLARITY) | im;\n\n\tswitch (flow_type & IRQF_TRIGGER_MASK) {\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tpol ^= im;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tmod ^= im;\n\t\tbreak;\n\tcase IRQ_TYPE_NONE:\n\t\tflow_type = IRQ_TYPE_LEVEL_LOW;\n\t\tfallthrough;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tmod ^= im;\n\t\tpol ^= im;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tbreak;\n\tdefault:\n\t\tirq_gc_unlock(gc);\n\t\tpr_err(\"%s: Cannot assign multiple trigger modes to IRQ %d.\\n\",\n\t\t\t__func__, data->irq);\n\t\treturn -EBADR;\n\t}\n\n\tirqd_set_trigger_type(data, flow_type);\n\tirq_setup_alt_chip(data, flow_type);\n\n\tab_irqctl_writereg(gc, AB_IRQCTL_SRC_MODE, mod);\n\tab_irqctl_writereg(gc, AB_IRQCTL_SRC_POLARITY, pol);\n\tab_irqctl_writereg(gc, AB_IRQCTL_INT_STATUS, im);\n\n\tirq_gc_unlock(gc);\n\n\treturn IRQ_SET_MASK_OK;\n}\n\nstatic void tb10x_irq_cascade(struct irq_desc *desc)\n{\n\tstruct irq_domain *domain = irq_desc_get_handler_data(desc);\n\tunsigned int irq = irq_desc_get_irq(desc);\n\n\tgeneric_handle_domain_irq(domain, irq);\n}\n\nstatic int __init of_tb10x_init_irq(struct device_node *ictl,\n\t\t\t\t\tstruct device_node *parent)\n{\n\tint i, ret, nrirqs = of_irq_count(ictl);\n\tstruct resource mem;\n\tstruct irq_chip_generic *gc;\n\tstruct irq_domain *domain;\n\tvoid __iomem *reg_base;\n\n\tif (of_address_to_resource(ictl, 0, &mem)) {\n\t\tpr_err(\"%pOFn: No registers declared in DeviceTree.\\n\",\n\t\t\tictl);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!request_mem_region(mem.start, resource_size(&mem),\n\t\tictl->full_name)) {\n\t\tpr_err(\"%pOFn: Request mem region failed.\\n\", ictl);\n\t\treturn -EBUSY;\n\t}\n\n\treg_base = ioremap(mem.start, resource_size(&mem));\n\tif (!reg_base) {\n\t\tret = -EBUSY;\n\t\tpr_err(\"%pOFn: ioremap failed.\\n\", ictl);\n\t\tgoto ioremap_fail;\n\t}\n\n\tdomain = irq_domain_add_linear(ictl, AB_IRQCTL_MAXIRQ,\n\t\t\t\t\t&irq_generic_chip_ops, NULL);\n\tif (!domain) {\n\t\tret = -ENOMEM;\n\t\tpr_err(\"%pOFn: Could not register interrupt domain.\\n\",\n\t\t\tictl);\n\t\tgoto irq_domain_add_fail;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(domain, AB_IRQCTL_MAXIRQ,\n\t\t\t\t2, ictl->name, handle_level_irq,\n\t\t\t\tIRQ_NOREQUEST, IRQ_NOPROBE,\n\t\t\t\tIRQ_GC_INIT_MASK_CACHE);\n\tif (ret) {\n\t\tpr_err(\"%pOFn: Could not allocate generic interrupt chip.\\n\",\n\t\t\tictl);\n\t\tgoto gc_alloc_fail;\n\t}\n\n\tgc = domain->gc->gc[0];\n\tgc->reg_base                         = reg_base;\n\n\tgc->chip_types[0].type               = IRQ_TYPE_LEVEL_MASK;\n\tgc->chip_types[0].chip.irq_mask      = irq_gc_mask_clr_bit;\n\tgc->chip_types[0].chip.irq_unmask    = irq_gc_mask_set_bit;\n\tgc->chip_types[0].chip.irq_set_type  = tb10x_irq_set_type;\n\tgc->chip_types[0].regs.mask          = AB_IRQCTL_INT_ENABLE;\n\n\tgc->chip_types[1].type               = IRQ_TYPE_EDGE_BOTH;\n\tgc->chip_types[1].chip.name          = gc->chip_types[0].chip.name;\n\tgc->chip_types[1].chip.irq_ack       = irq_gc_ack_set_bit;\n\tgc->chip_types[1].chip.irq_mask      = irq_gc_mask_clr_bit;\n\tgc->chip_types[1].chip.irq_unmask    = irq_gc_mask_set_bit;\n\tgc->chip_types[1].chip.irq_set_type  = tb10x_irq_set_type;\n\tgc->chip_types[1].regs.ack           = AB_IRQCTL_INT_STATUS;\n\tgc->chip_types[1].regs.mask          = AB_IRQCTL_INT_ENABLE;\n\tgc->chip_types[1].handler            = handle_edge_irq;\n\n\tfor (i = 0; i < nrirqs; i++) {\n\t\tunsigned int irq = irq_of_parse_and_map(ictl, i);\n\n\t\tirq_set_chained_handler_and_data(irq, tb10x_irq_cascade,\n\t\t\t\t\t\t domain);\n\t}\n\n\tab_irqctl_writereg(gc, AB_IRQCTL_INT_ENABLE, 0);\n\tab_irqctl_writereg(gc, AB_IRQCTL_INT_MODE, 0);\n\tab_irqctl_writereg(gc, AB_IRQCTL_INT_POLARITY, 0);\n\tab_irqctl_writereg(gc, AB_IRQCTL_INT_STATUS, ~0UL);\n\n\treturn 0;\n\ngc_alloc_fail:\n\tirq_domain_remove(domain);\nirq_domain_add_fail:\n\tiounmap(reg_base);\nioremap_fail:\n\trelease_mem_region(mem.start, resource_size(&mem));\n\treturn ret;\n}\nIRQCHIP_DECLARE(tb10x_intc, \"abilis,tb10x-ictl\", of_tb10x_init_irq);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}