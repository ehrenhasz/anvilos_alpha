{
  "module_name": "irq-tegra.c",
  "hash_id": "f24a7c0079a24706b40c263da657cb496815360c5eef2059ebf63edb39bd5242",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-tegra.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/syscore_ops.h>\n\n#include <dt-bindings/interrupt-controller/arm-gic.h>\n\n#define ICTLR_CPU_IEP_VFIQ\t0x08\n#define ICTLR_CPU_IEP_FIR\t0x14\n#define ICTLR_CPU_IEP_FIR_SET\t0x18\n#define ICTLR_CPU_IEP_FIR_CLR\t0x1c\n\n#define ICTLR_CPU_IER\t\t0x20\n#define ICTLR_CPU_IER_SET\t0x24\n#define ICTLR_CPU_IER_CLR\t0x28\n#define ICTLR_CPU_IEP_CLASS\t0x2C\n\n#define ICTLR_COP_IER\t\t0x30\n#define ICTLR_COP_IER_SET\t0x34\n#define ICTLR_COP_IER_CLR\t0x38\n#define ICTLR_COP_IEP_CLASS\t0x3c\n\n#define TEGRA_MAX_NUM_ICTLRS\t6\n\nstatic unsigned int num_ictlrs;\n\nstruct tegra_ictlr_soc {\n\tunsigned int num_ictlrs;\n};\n\nstatic const struct tegra_ictlr_soc tegra20_ictlr_soc = {\n\t.num_ictlrs = 4,\n};\n\nstatic const struct tegra_ictlr_soc tegra30_ictlr_soc = {\n\t.num_ictlrs = 5,\n};\n\nstatic const struct tegra_ictlr_soc tegra210_ictlr_soc = {\n\t.num_ictlrs = 6,\n};\n\nstatic const struct of_device_id ictlr_matches[] = {\n\t{ .compatible = \"nvidia,tegra210-ictlr\", .data = &tegra210_ictlr_soc },\n\t{ .compatible = \"nvidia,tegra30-ictlr\", .data = &tegra30_ictlr_soc },\n\t{ .compatible = \"nvidia,tegra20-ictlr\", .data = &tegra20_ictlr_soc },\n\t{ }\n};\n\nstruct tegra_ictlr_info {\n\tvoid __iomem *base[TEGRA_MAX_NUM_ICTLRS];\n#ifdef CONFIG_PM_SLEEP\n\tu32 cop_ier[TEGRA_MAX_NUM_ICTLRS];\n\tu32 cop_iep[TEGRA_MAX_NUM_ICTLRS];\n\tu32 cpu_ier[TEGRA_MAX_NUM_ICTLRS];\n\tu32 cpu_iep[TEGRA_MAX_NUM_ICTLRS];\n\n\tu32 ictlr_wake_mask[TEGRA_MAX_NUM_ICTLRS];\n#endif\n};\n\nstatic struct tegra_ictlr_info *lic;\n\nstatic inline void tegra_ictlr_write_mask(struct irq_data *d, unsigned long reg)\n{\n\tvoid __iomem *base = (void __iomem __force *)d->chip_data;\n\tu32 mask;\n\n\tmask = BIT(d->hwirq % 32);\n\twritel_relaxed(mask, base + reg);\n}\n\nstatic void tegra_mask(struct irq_data *d)\n{\n\ttegra_ictlr_write_mask(d, ICTLR_CPU_IER_CLR);\n\tirq_chip_mask_parent(d);\n}\n\nstatic void tegra_unmask(struct irq_data *d)\n{\n\ttegra_ictlr_write_mask(d, ICTLR_CPU_IER_SET);\n\tirq_chip_unmask_parent(d);\n}\n\nstatic void tegra_eoi(struct irq_data *d)\n{\n\ttegra_ictlr_write_mask(d, ICTLR_CPU_IEP_FIR_CLR);\n\tirq_chip_eoi_parent(d);\n}\n\nstatic int tegra_retrigger(struct irq_data *d)\n{\n\ttegra_ictlr_write_mask(d, ICTLR_CPU_IEP_FIR_SET);\n\treturn irq_chip_retrigger_hierarchy(d);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tegra_set_wake(struct irq_data *d, unsigned int enable)\n{\n\tu32 irq = d->hwirq;\n\tu32 index, mask;\n\n\tindex = (irq / 32);\n\tmask = BIT(irq % 32);\n\tif (enable)\n\t\tlic->ictlr_wake_mask[index] |= mask;\n\telse\n\t\tlic->ictlr_wake_mask[index] &= ~mask;\n\n\t \n\treturn 0;\n}\n\nstatic int tegra_ictlr_suspend(void)\n{\n\tunsigned long flags;\n\tunsigned int i;\n\n\tlocal_irq_save(flags);\n\tfor (i = 0; i < num_ictlrs; i++) {\n\t\tvoid __iomem *ictlr = lic->base[i];\n\n\t\t \n\t\tlic->cpu_ier[i] = readl_relaxed(ictlr + ICTLR_CPU_IER);\n\t\tlic->cpu_iep[i] = readl_relaxed(ictlr + ICTLR_CPU_IEP_CLASS);\n\t\tlic->cop_ier[i] = readl_relaxed(ictlr + ICTLR_COP_IER);\n\t\tlic->cop_iep[i] = readl_relaxed(ictlr + ICTLR_COP_IEP_CLASS);\n\n\t\t \n\t\twritel_relaxed(GENMASK(31, 0), ictlr + ICTLR_COP_IER_CLR);\n\n\t\t \n\t\twritel_relaxed(GENMASK(31, 0), ictlr + ICTLR_CPU_IER_CLR);\n\n\t\t \n\t\twritel_relaxed(lic->ictlr_wake_mask[i], ictlr + ICTLR_CPU_IER_SET);\n\t}\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\nstatic void tegra_ictlr_resume(void)\n{\n\tunsigned long flags;\n\tunsigned int i;\n\n\tlocal_irq_save(flags);\n\tfor (i = 0; i < num_ictlrs; i++) {\n\t\tvoid __iomem *ictlr = lic->base[i];\n\n\t\twritel_relaxed(lic->cpu_iep[i],\n\t\t\t       ictlr + ICTLR_CPU_IEP_CLASS);\n\t\twritel_relaxed(GENMASK(31, 0), ictlr + ICTLR_CPU_IER_CLR);\n\t\twritel_relaxed(lic->cpu_ier[i],\n\t\t\t       ictlr + ICTLR_CPU_IER_SET);\n\t\twritel_relaxed(lic->cop_iep[i],\n\t\t\t       ictlr + ICTLR_COP_IEP_CLASS);\n\t\twritel_relaxed(GENMASK(31, 0), ictlr + ICTLR_COP_IER_CLR);\n\t\twritel_relaxed(lic->cop_ier[i],\n\t\t\t       ictlr + ICTLR_COP_IER_SET);\n\t}\n\tlocal_irq_restore(flags);\n}\n\nstatic struct syscore_ops tegra_ictlr_syscore_ops = {\n\t.suspend\t= tegra_ictlr_suspend,\n\t.resume\t\t= tegra_ictlr_resume,\n};\n\nstatic void tegra_ictlr_syscore_init(void)\n{\n\tregister_syscore_ops(&tegra_ictlr_syscore_ops);\n}\n#else\n#define tegra_set_wake\tNULL\nstatic inline void tegra_ictlr_syscore_init(void) {}\n#endif\n\nstatic struct irq_chip tegra_ictlr_chip = {\n\t.name\t\t\t= \"LIC\",\n\t.irq_eoi\t\t= tegra_eoi,\n\t.irq_mask\t\t= tegra_mask,\n\t.irq_unmask\t\t= tegra_unmask,\n\t.irq_retrigger\t\t= tegra_retrigger,\n\t.irq_set_wake\t\t= tegra_set_wake,\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n\t.flags\t\t\t= IRQCHIP_MASK_ON_SUSPEND,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n#endif\n};\n\nstatic int tegra_ictlr_domain_translate(struct irq_domain *d,\n\t\t\t\t\tstruct irq_fwspec *fwspec,\n\t\t\t\t\tunsigned long *hwirq,\n\t\t\t\t\tunsigned int *type)\n{\n\tif (is_of_node(fwspec->fwnode)) {\n\t\tif (fwspec->param_count != 3)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (fwspec->param[0] != 0)\n\t\t\treturn -EINVAL;\n\n\t\t*hwirq = fwspec->param[1];\n\t\t*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tegra_ictlr_domain_alloc(struct irq_domain *domain,\n\t\t\t\t    unsigned int virq,\n\t\t\t\t    unsigned int nr_irqs, void *data)\n{\n\tstruct irq_fwspec *fwspec = data;\n\tstruct irq_fwspec parent_fwspec;\n\tstruct tegra_ictlr_info *info = domain->host_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int i;\n\n\tif (fwspec->param_count != 3)\n\t\treturn -EINVAL;\t \n\tif (fwspec->param[0] != GIC_SPI)\n\t\treturn -EINVAL;\t \n\n\thwirq = fwspec->param[1];\n\tif (hwirq >= (num_ictlrs * 32))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tint ictlr = (hwirq + i) / 32;\n\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\n\t\t\t\t\t      &tegra_ictlr_chip,\n\t\t\t\t\t      (void __force *)info->base[ictlr]);\n\t}\n\n\tparent_fwspec = *fwspec;\n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\treturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs,\n\t\t\t\t\t    &parent_fwspec);\n}\n\nstatic const struct irq_domain_ops tegra_ictlr_domain_ops = {\n\t.translate\t= tegra_ictlr_domain_translate,\n\t.alloc\t\t= tegra_ictlr_domain_alloc,\n\t.free\t\t= irq_domain_free_irqs_common,\n};\n\nstatic int __init tegra_ictlr_init(struct device_node *node,\n\t\t\t\t   struct device_node *parent)\n{\n\tstruct irq_domain *parent_domain, *domain;\n\tconst struct of_device_id *match;\n\tconst struct tegra_ictlr_soc *soc;\n\tunsigned int i;\n\tint err;\n\n\tif (!parent) {\n\t\tpr_err(\"%pOF: no parent, giving up\\n\", node);\n\t\treturn -ENODEV;\n\t}\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tpr_err(\"%pOF: unable to obtain parent domain\\n\", node);\n\t\treturn -ENXIO;\n\t}\n\n\tmatch = of_match_node(ictlr_matches, node);\n\tif (!match)\t\t \n\t\treturn -ENODEV;\n\n\tsoc = match->data;\n\n\tlic = kzalloc(sizeof(*lic), GFP_KERNEL);\n\tif (!lic)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < TEGRA_MAX_NUM_ICTLRS; i++) {\n\t\tvoid __iomem *base;\n\n\t\tbase = of_iomap(node, i);\n\t\tif (!base)\n\t\t\tbreak;\n\n\t\tlic->base[i] = base;\n\n\t\t \n\t\twritel_relaxed(GENMASK(31, 0), base + ICTLR_CPU_IER_CLR);\n\t\t \n\t\twritel_relaxed(0, base + ICTLR_CPU_IEP_CLASS);\n\n\t\tnum_ictlrs++;\n\t}\n\n\tif (!num_ictlrs) {\n\t\tpr_err(\"%pOF: no valid regions, giving up\\n\", node);\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tWARN(num_ictlrs != soc->num_ictlrs,\n\t     \"%pOF: Found %u interrupt controllers in DT; expected %u.\\n\",\n\t     node, num_ictlrs, soc->num_ictlrs);\n\n\n\tdomain = irq_domain_add_hierarchy(parent_domain, 0, num_ictlrs * 32,\n\t\t\t\t\t  node, &tegra_ictlr_domain_ops,\n\t\t\t\t\t  lic);\n\tif (!domain) {\n\t\tpr_err(\"%pOF: failed to allocated domain\\n\", node);\n\t\terr = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n\ttegra_ictlr_syscore_init();\n\n\tpr_info(\"%pOF: %d interrupts forwarded to %pOF\\n\",\n\t\tnode, num_ictlrs * 32, parent);\n\n\treturn 0;\n\nout_unmap:\n\tfor (i = 0; i < num_ictlrs; i++)\n\t\tiounmap(lic->base[i]);\nout_free:\n\tkfree(lic);\n\treturn err;\n}\n\nIRQCHIP_DECLARE(tegra20_ictlr, \"nvidia,tegra20-ictlr\", tegra_ictlr_init);\nIRQCHIP_DECLARE(tegra30_ictlr, \"nvidia,tegra30-ictlr\", tegra_ictlr_init);\nIRQCHIP_DECLARE(tegra210_ictlr, \"nvidia,tegra210-ictlr\", tegra_ictlr_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}