{
  "module_name": "irq-loongson-eiointc.c",
  "hash_id": "f68e997d9ee3b5e01e41291b22d5ce88e471c9b40328f11ebee06ab7fae4e704",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-loongson-eiointc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"eiointc: \" fmt\n\n#include <linux/cpuhotplug.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/kernel.h>\n#include <linux/syscore_ops.h>\n\n#define EIOINTC_REG_NODEMAP\t0x14a0\n#define EIOINTC_REG_IPMAP\t0x14c0\n#define EIOINTC_REG_ENABLE\t0x1600\n#define EIOINTC_REG_BOUNCE\t0x1680\n#define EIOINTC_REG_ISR\t\t0x1800\n#define EIOINTC_REG_ROUTE\t0x1c00\n\n#define VEC_REG_COUNT\t\t4\n#define VEC_COUNT_PER_REG\t64\n#define VEC_COUNT\t\t(VEC_REG_COUNT * VEC_COUNT_PER_REG)\n#define VEC_REG_IDX(irq_id)\t((irq_id) / VEC_COUNT_PER_REG)\n#define VEC_REG_BIT(irq_id)     ((irq_id) % VEC_COUNT_PER_REG)\n#define EIOINTC_ALL_ENABLE\t0xffffffff\n\n#define MAX_EIO_NODES\t\t(NR_CPUS / CORES_PER_EIO_NODE)\n\nstatic int nr_pics;\n\nstruct eiointc_priv {\n\tu32\t\t\tnode;\n\tu32\t\t\tvec_count;\n\tnodemask_t\t\tnode_map;\n\tcpumask_t\t\tcpuspan_map;\n\tstruct fwnode_handle\t*domain_handle;\n\tstruct irq_domain\t*eiointc_domain;\n};\n\nstatic struct eiointc_priv *eiointc_priv[MAX_IO_PICS];\n\nstatic void eiointc_enable(void)\n{\n\tuint64_t misc;\n\n\tmisc = iocsr_read64(LOONGARCH_IOCSR_MISC_FUNC);\n\tmisc |= IOCSR_MISC_FUNC_EXT_IOI_EN;\n\tiocsr_write64(misc, LOONGARCH_IOCSR_MISC_FUNC);\n}\n\nstatic int cpu_to_eio_node(int cpu)\n{\n\treturn cpu_logical_map(cpu) / CORES_PER_EIO_NODE;\n}\n\nstatic void eiointc_set_irq_route(int pos, unsigned int cpu, unsigned int mnode, nodemask_t *node_map)\n{\n\tint i, node, cpu_node, route_node;\n\tunsigned char coremap;\n\tuint32_t pos_off, data, data_byte, data_mask;\n\n\tpos_off = pos & ~3;\n\tdata_byte = pos & 3;\n\tdata_mask = ~BIT_MASK(data_byte) & 0xf;\n\n\t \n\tcpu_node = cpu_logical_map(cpu) / CORES_PER_EIO_NODE;\n\tcoremap = BIT(cpu_logical_map(cpu) % CORES_PER_EIO_NODE);\n\n\tfor_each_online_cpu(i) {\n\t\tnode = cpu_to_eio_node(i);\n\t\tif (!node_isset(node, *node_map))\n\t\t\tcontinue;\n\n\t\t \n\t\troute_node = (node == mnode) ? cpu_node : node;\n\t\tdata = ((coremap | (route_node << 4)) << (data_byte * 8));\n\t\tcsr_any_send(EIOINTC_REG_ROUTE + pos_off, data, data_mask, node * CORES_PER_EIO_NODE);\n\t}\n}\n\nstatic DEFINE_RAW_SPINLOCK(affinity_lock);\n\nstatic int eiointc_set_irq_affinity(struct irq_data *d, const struct cpumask *affinity, bool force)\n{\n\tunsigned int cpu;\n\tunsigned long flags;\n\tuint32_t vector, regaddr;\n\tstruct cpumask intersect_affinity;\n\tstruct eiointc_priv *priv = d->domain->host_data;\n\n\traw_spin_lock_irqsave(&affinity_lock, flags);\n\n\tcpumask_and(&intersect_affinity, affinity, cpu_online_mask);\n\tcpumask_and(&intersect_affinity, &intersect_affinity, &priv->cpuspan_map);\n\n\tif (cpumask_empty(&intersect_affinity)) {\n\t\traw_spin_unlock_irqrestore(&affinity_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tcpu = cpumask_first(&intersect_affinity);\n\n\tvector = d->hwirq;\n\tregaddr = EIOINTC_REG_ENABLE + ((vector >> 5) << 2);\n\n\t \n\tcsr_any_send(regaddr, EIOINTC_ALL_ENABLE & (~BIT(vector & 0x1F)),\n\t\t\t0x0, priv->node * CORES_PER_EIO_NODE);\n\n\t \n\teiointc_set_irq_route(vector, cpu, priv->node, &priv->node_map);\n\n\t \n\tcsr_any_send(regaddr, EIOINTC_ALL_ENABLE,\n\t\t\t0x0, priv->node * CORES_PER_EIO_NODE);\n\n\tirq_data_update_effective_affinity(d, cpumask_of(cpu));\n\n\traw_spin_unlock_irqrestore(&affinity_lock, flags);\n\n\treturn IRQ_SET_MASK_OK;\n}\n\nstatic int eiointc_index(int node)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_pics; i++) {\n\t\tif (node_isset(node, eiointc_priv[i]->node_map))\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nstatic int eiointc_router_init(unsigned int cpu)\n{\n\tint i, bit;\n\tuint32_t data;\n\tuint32_t node = cpu_to_eio_node(cpu);\n\tint index = eiointc_index(node);\n\n\tif (index < 0) {\n\t\tpr_err(\"Error: invalid nodemap!\\n\");\n\t\treturn -1;\n\t}\n\n\tif ((cpu_logical_map(cpu) % CORES_PER_EIO_NODE) == 0) {\n\t\teiointc_enable();\n\n\t\tfor (i = 0; i < eiointc_priv[0]->vec_count / 32; i++) {\n\t\t\tdata = (((1 << (i * 2 + 1)) << 16) | (1 << (i * 2)));\n\t\t\tiocsr_write32(data, EIOINTC_REG_NODEMAP + i * 4);\n\t\t}\n\n\t\tfor (i = 0; i < eiointc_priv[0]->vec_count / 32 / 4; i++) {\n\t\t\tbit = BIT(1 + index);  \n\t\t\tdata = bit | (bit << 8) | (bit << 16) | (bit << 24);\n\t\t\tiocsr_write32(data, EIOINTC_REG_IPMAP + i * 4);\n\t\t}\n\n\t\tfor (i = 0; i < eiointc_priv[0]->vec_count / 4; i++) {\n\t\t\t \n\t\t\tif (index == 0)\n\t\t\t\tbit = BIT(cpu_logical_map(0));\n\t\t\telse\n\t\t\t\tbit = (eiointc_priv[index]->node << 4) | 1;\n\n\t\t\tdata = bit | (bit << 8) | (bit << 16) | (bit << 24);\n\t\t\tiocsr_write32(data, EIOINTC_REG_ROUTE + i * 4);\n\t\t}\n\n\t\tfor (i = 0; i < eiointc_priv[0]->vec_count / 32; i++) {\n\t\t\tdata = 0xffffffff;\n\t\t\tiocsr_write32(data, EIOINTC_REG_ENABLE + i * 4);\n\t\t\tiocsr_write32(data, EIOINTC_REG_BOUNCE + i * 4);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void eiointc_irq_dispatch(struct irq_desc *desc)\n{\n\tint i;\n\tu64 pending;\n\tbool handled = false;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct eiointc_priv *priv = irq_desc_get_handler_data(desc);\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (i = 0; i < eiointc_priv[0]->vec_count / VEC_COUNT_PER_REG; i++) {\n\t\tpending = iocsr_read64(EIOINTC_REG_ISR + (i << 3));\n\t\tiocsr_write64(pending, EIOINTC_REG_ISR + (i << 3));\n\t\twhile (pending) {\n\t\t\tint bit = __ffs(pending);\n\t\t\tint irq = bit + VEC_COUNT_PER_REG * i;\n\n\t\t\tgeneric_handle_domain_irq(priv->eiointc_domain, irq);\n\t\t\tpending &= ~BIT(bit);\n\t\t\thandled = true;\n\t\t}\n\t}\n\n\tif (!handled)\n\t\tspurious_interrupt();\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void eiointc_ack_irq(struct irq_data *d)\n{\n}\n\nstatic void eiointc_mask_irq(struct irq_data *d)\n{\n}\n\nstatic void eiointc_unmask_irq(struct irq_data *d)\n{\n}\n\nstatic struct irq_chip eiointc_irq_chip = {\n\t.name\t\t\t= \"EIOINTC\",\n\t.irq_ack\t\t= eiointc_ack_irq,\n\t.irq_mask\t\t= eiointc_mask_irq,\n\t.irq_unmask\t\t= eiointc_unmask_irq,\n\t.irq_set_affinity\t= eiointc_set_irq_affinity,\n};\n\nstatic int eiointc_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs, void *arg)\n{\n\tint ret;\n\tunsigned int i, type;\n\tunsigned long hwirq = 0;\n\tstruct eiointc *priv = domain->host_data;\n\n\tret = irq_domain_translate_onecell(domain, arg, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_domain_set_info(domain, virq + i, hwirq + i, &eiointc_irq_chip,\n\t\t\t\t\tpriv, handle_edge_irq, NULL, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic void eiointc_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq + i);\n\n\t\tirq_set_handler(virq + i, NULL);\n\t\tirq_domain_reset_irq_data(d);\n\t}\n}\n\nstatic const struct irq_domain_ops eiointc_domain_ops = {\n\t.translate\t= irq_domain_translate_onecell,\n\t.alloc\t\t= eiointc_domain_alloc,\n\t.free\t\t= eiointc_domain_free,\n};\n\nstatic void acpi_set_vec_parent(int node, struct irq_domain *parent, struct acpi_vector_group *vec_group)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_IO_PICS; i++) {\n\t\tif (node == vec_group[i].node) {\n\t\t\tvec_group[i].parent = parent;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic struct irq_domain *acpi_get_vec_parent(int node, struct acpi_vector_group *vec_group)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_IO_PICS; i++) {\n\t\tif (node == vec_group[i].node)\n\t\t\treturn vec_group[i].parent;\n\t}\n\treturn NULL;\n}\n\nstatic int eiointc_suspend(void)\n{\n\treturn 0;\n}\n\nstatic void eiointc_resume(void)\n{\n\tint i, j;\n\tstruct irq_desc *desc;\n\tstruct irq_data *irq_data;\n\n\teiointc_router_init(0);\n\n\tfor (i = 0; i < nr_pics; i++) {\n\t\tfor (j = 0; j < eiointc_priv[0]->vec_count; j++) {\n\t\t\tdesc = irq_resolve_mapping(eiointc_priv[i]->eiointc_domain, j);\n\t\t\tif (desc && desc->handle_irq && desc->handle_irq != handle_bad_irq) {\n\t\t\t\traw_spin_lock(&desc->lock);\n\t\t\t\tirq_data = irq_domain_get_irq_data(eiointc_priv[i]->eiointc_domain, irq_desc_get_irq(desc));\n\t\t\t\teiointc_set_irq_affinity(irq_data, irq_data->common->affinity, 0);\n\t\t\t\traw_spin_unlock(&desc->lock);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic struct syscore_ops eiointc_syscore_ops = {\n\t.suspend = eiointc_suspend,\n\t.resume = eiointc_resume,\n};\n\nstatic int __init pch_pic_parse_madt(union acpi_subtable_headers *header,\n\t\t\t\t\tconst unsigned long end)\n{\n\tstruct acpi_madt_bio_pic *pchpic_entry = (struct acpi_madt_bio_pic *)header;\n\tunsigned int node = (pchpic_entry->address >> 44) & 0xf;\n\tstruct irq_domain *parent = acpi_get_vec_parent(node, pch_group);\n\n\tif (parent)\n\t\treturn pch_pic_acpi_init(parent, pchpic_entry);\n\n\treturn 0;\n}\n\nstatic int __init pch_msi_parse_madt(union acpi_subtable_headers *header,\n\t\t\t\t\tconst unsigned long end)\n{\n\tstruct irq_domain *parent;\n\tstruct acpi_madt_msi_pic *pchmsi_entry = (struct acpi_madt_msi_pic *)header;\n\tint node;\n\n\tif (cpu_has_flatmode)\n\t\tnode = cpu_to_node(eiointc_priv[nr_pics - 1]->node * CORES_PER_EIO_NODE);\n\telse\n\t\tnode = eiointc_priv[nr_pics - 1]->node;\n\n\tparent = acpi_get_vec_parent(node, msi_group);\n\n\tif (parent)\n\t\treturn pch_msi_acpi_init(parent, pchmsi_entry);\n\n\treturn 0;\n}\n\nstatic int __init acpi_cascade_irqdomain_init(void)\n{\n\tint r;\n\n\tr = acpi_table_parse_madt(ACPI_MADT_TYPE_BIO_PIC, pch_pic_parse_madt, 0);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = acpi_table_parse_madt(ACPI_MADT_TYPE_MSI_PIC, pch_msi_parse_madt, 1);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int __init eiointc_init(struct eiointc_priv *priv, int parent_irq,\n\t\t\t       u64 node_map)\n{\n\tint i;\n\n\tnode_map = node_map ? node_map : -1ULL;\n\tfor_each_possible_cpu(i) {\n\t\tif (node_map & (1ULL << (cpu_to_eio_node(i)))) {\n\t\t\tnode_set(cpu_to_eio_node(i), priv->node_map);\n\t\t\tcpumask_or(&priv->cpuspan_map, &priv->cpuspan_map,\n\t\t\t\t   cpumask_of(i));\n\t\t}\n\t}\n\n\tpriv->eiointc_domain = irq_domain_create_linear(priv->domain_handle,\n\t\t\t\t\t\t\tpriv->vec_count,\n\t\t\t\t\t\t\t&eiointc_domain_ops,\n\t\t\t\t\t\t\tpriv);\n\tif (!priv->eiointc_domain) {\n\t\tpr_err(\"loongson-extioi: cannot add IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\teiointc_priv[nr_pics++] = priv;\n\teiointc_router_init(0);\n\tirq_set_chained_handler_and_data(parent_irq, eiointc_irq_dispatch, priv);\n\n\tif (nr_pics == 1) {\n\t\tregister_syscore_ops(&eiointc_syscore_ops);\n\t\tcpuhp_setup_state_nocalls(CPUHP_AP_IRQ_LOONGARCH_STARTING,\n\t\t\t\t\t  \"irqchip/loongarch/intc:starting\",\n\t\t\t\t\t  eiointc_router_init, NULL);\n\t}\n\n\treturn 0;\n}\n\nint __init eiointc_acpi_init(struct irq_domain *parent,\n\t\t\t\t     struct acpi_madt_eio_pic *acpi_eiointc)\n{\n\tint parent_irq, ret;\n\tstruct eiointc_priv *priv;\n\tint node;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->domain_handle = irq_domain_alloc_named_id_fwnode(\"EIOPIC\",\n\t\t\t\t\t\t\t       acpi_eiointc->node);\n\tif (!priv->domain_handle) {\n\t\tpr_err(\"Unable to allocate domain handle\\n\");\n\t\tgoto out_free_priv;\n\t}\n\n\tpriv->vec_count = VEC_COUNT;\n\tpriv->node = acpi_eiointc->node;\n\n\tparent_irq = irq_create_mapping(parent, acpi_eiointc->cascade);\n\n\tret = eiointc_init(priv, parent_irq, acpi_eiointc->node_map);\n\tif (ret < 0)\n\t\tgoto out_free_handle;\n\n\tif (cpu_has_flatmode)\n\t\tnode = cpu_to_node(acpi_eiointc->node * CORES_PER_EIO_NODE);\n\telse\n\t\tnode = acpi_eiointc->node;\n\tacpi_set_vec_parent(node, priv->eiointc_domain, pch_group);\n\tacpi_set_vec_parent(node, priv->eiointc_domain, msi_group);\n\n\tret = acpi_cascade_irqdomain_init();\n\tif (ret < 0)\n\t\tgoto out_free_handle;\n\n\treturn ret;\n\nout_free_handle:\n\tirq_domain_free_fwnode(priv->domain_handle);\n\tpriv->domain_handle = NULL;\nout_free_priv:\n\tkfree(priv);\n\n\treturn -ENOMEM;\n}\n\nstatic int __init eiointc_of_init(struct device_node *of_node,\n\t\t\t\t  struct device_node *parent)\n{\n\tint parent_irq, ret;\n\tstruct eiointc_priv *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tparent_irq = irq_of_parse_and_map(of_node, 0);\n\tif (parent_irq <= 0) {\n\t\tret = -ENODEV;\n\t\tgoto out_free_priv;\n\t}\n\n\tret = irq_set_handler_data(parent_irq, priv);\n\tif (ret < 0)\n\t\tgoto out_free_priv;\n\n\t \n\tif (of_device_is_compatible(of_node, \"loongson,ls2k0500-eiointc\"))\n\t\tpriv->vec_count = 128;\n\telse\n\t\tpriv->vec_count = VEC_COUNT;\n\n\tpriv->node = 0;\n\tpriv->domain_handle = of_node_to_fwnode(of_node);\n\n\tret = eiointc_init(priv, parent_irq, 0);\n\tif (ret < 0)\n\t\tgoto out_free_priv;\n\n\treturn 0;\n\nout_free_priv:\n\tkfree(priv);\n\treturn ret;\n}\n\nIRQCHIP_DECLARE(loongson_ls2k0500_eiointc, \"loongson,ls2k0500-eiointc\", eiointc_of_init);\nIRQCHIP_DECLARE(loongson_ls2k2000_eiointc, \"loongson,ls2k2000-eiointc\", eiointc_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}