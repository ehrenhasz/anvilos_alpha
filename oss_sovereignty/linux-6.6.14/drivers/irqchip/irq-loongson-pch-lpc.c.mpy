{
  "module_name": "irq-loongson-pch-lpc.c",
  "hash_id": "0fa382a7bbf2c8d2162c3ec2782e5fef1224e01ab6d2b1d77ad14b662734d623",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-loongson-pch-lpc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"lpc: \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/syscore_ops.h>\n\n \n#define LPC_INT_CTL\t\t0x00\n#define LPC_INT_ENA\t\t0x04\n#define LPC_INT_STS\t\t0x08\n#define LPC_INT_CLR\t\t0x0c\n#define LPC_INT_POL\t\t0x10\n#define LPC_COUNT\t\t16\n\n \n#define LPC_INT_CTL_EN\t\tBIT(31)\n\nstruct pch_lpc {\n\tvoid __iomem\t\t*base;\n\tstruct irq_domain\t*lpc_domain;\n\traw_spinlock_t\t\tlpc_lock;\n\tu32\t\t\tsaved_reg_ctl;\n\tu32\t\t\tsaved_reg_ena;\n\tu32\t\t\tsaved_reg_pol;\n};\n\nstatic struct pch_lpc *pch_lpc_priv;\nstruct fwnode_handle *pch_lpc_handle;\n\nstatic void lpc_irq_ack(struct irq_data *d)\n{\n\tunsigned long flags;\n\tstruct pch_lpc *priv = d->domain->host_data;\n\n\traw_spin_lock_irqsave(&priv->lpc_lock, flags);\n\twritel(0x1 << d->hwirq, priv->base + LPC_INT_CLR);\n\traw_spin_unlock_irqrestore(&priv->lpc_lock, flags);\n}\n\nstatic void lpc_irq_mask(struct irq_data *d)\n{\n\tunsigned long flags;\n\tstruct pch_lpc *priv = d->domain->host_data;\n\n\traw_spin_lock_irqsave(&priv->lpc_lock, flags);\n\twritel(readl(priv->base + LPC_INT_ENA) & (~(0x1 << (d->hwirq))),\n\t\t\tpriv->base + LPC_INT_ENA);\n\traw_spin_unlock_irqrestore(&priv->lpc_lock, flags);\n}\n\nstatic void lpc_irq_unmask(struct irq_data *d)\n{\n\tunsigned long flags;\n\tstruct pch_lpc *priv = d->domain->host_data;\n\n\traw_spin_lock_irqsave(&priv->lpc_lock, flags);\n\twritel(readl(priv->base + LPC_INT_ENA) | (0x1 << (d->hwirq)),\n\t\t\tpriv->base + LPC_INT_ENA);\n\traw_spin_unlock_irqrestore(&priv->lpc_lock, flags);\n}\n\nstatic int lpc_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tu32 val;\n\tu32 mask = 0x1 << (d->hwirq);\n\tstruct pch_lpc *priv = d->domain->host_data;\n\n\tif (!(type & IRQ_TYPE_LEVEL_MASK))\n\t\treturn 0;\n\n\tval = readl(priv->base + LPC_INT_POL);\n\n\tif (type == IRQ_TYPE_LEVEL_HIGH)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\n\twritel(val, priv->base + LPC_INT_POL);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip pch_lpc_irq_chip = {\n\t.name\t\t\t= \"PCH LPC\",\n\t.irq_mask\t\t= lpc_irq_mask,\n\t.irq_unmask\t\t= lpc_irq_unmask,\n\t.irq_ack\t\t= lpc_irq_ack,\n\t.irq_set_type\t\t= lpc_irq_set_type,\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic void lpc_irq_dispatch(struct irq_desc *desc)\n{\n\tu32 pending, bit;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct pch_lpc *priv = irq_desc_get_handler_data(desc);\n\n\tchained_irq_enter(chip, desc);\n\n\tpending = readl(priv->base + LPC_INT_ENA);\n\tpending &= readl(priv->base + LPC_INT_STS);\n\tif (!pending)\n\t\tspurious_interrupt();\n\n\twhile (pending) {\n\t\tbit = __ffs(pending);\n\n\t\tgeneric_handle_domain_irq(priv->lpc_domain, bit);\n\t\tpending &= ~BIT(bit);\n\t}\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int pch_lpc_map(struct irq_domain *d, unsigned int irq,\n\t\t\tirq_hw_number_t hw)\n{\n\tirq_set_chip_and_handler(irq, &pch_lpc_irq_chip, handle_level_irq);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops pch_lpc_domain_ops = {\n\t.map \t\t= pch_lpc_map,\n\t.translate\t= irq_domain_translate_twocell,\n};\n\nstatic void pch_lpc_reset(struct pch_lpc *priv)\n{\n\t \n\twritel(LPC_INT_CTL_EN, priv->base + LPC_INT_CTL);\n\twritel(0, priv->base + LPC_INT_ENA);\n\t \n\twritel(GENMASK(17, 0), priv->base + LPC_INT_CLR);\n}\n\nstatic int pch_lpc_disabled(struct pch_lpc *priv)\n{\n\treturn (readl(priv->base + LPC_INT_ENA) == 0xffffffff) &&\n\t\t\t(readl(priv->base + LPC_INT_STS) == 0xffffffff);\n}\n\nstatic int pch_lpc_suspend(void)\n{\n\tpch_lpc_priv->saved_reg_ctl = readl(pch_lpc_priv->base + LPC_INT_CTL);\n\tpch_lpc_priv->saved_reg_ena = readl(pch_lpc_priv->base + LPC_INT_ENA);\n\tpch_lpc_priv->saved_reg_pol = readl(pch_lpc_priv->base + LPC_INT_POL);\n\treturn 0;\n}\n\nstatic void pch_lpc_resume(void)\n{\n\twritel(pch_lpc_priv->saved_reg_ctl, pch_lpc_priv->base + LPC_INT_CTL);\n\twritel(pch_lpc_priv->saved_reg_ena, pch_lpc_priv->base + LPC_INT_ENA);\n\twritel(pch_lpc_priv->saved_reg_pol, pch_lpc_priv->base + LPC_INT_POL);\n}\n\nstatic struct syscore_ops pch_lpc_syscore_ops = {\n\t.suspend = pch_lpc_suspend,\n\t.resume = pch_lpc_resume,\n};\n\nint __init pch_lpc_acpi_init(struct irq_domain *parent,\n\t\t\t\t\tstruct acpi_madt_lpc_pic *acpi_pchlpc)\n{\n\tint parent_irq;\n\tstruct pch_lpc *priv;\n\tstruct irq_fwspec fwspec;\n\tstruct fwnode_handle *irq_handle;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_init(&priv->lpc_lock);\n\n\tpriv->base = ioremap(acpi_pchlpc->address, acpi_pchlpc->size);\n\tif (!priv->base)\n\t\tgoto free_priv;\n\n\tif (pch_lpc_disabled(priv)) {\n\t\tpr_err(\"Failed to get LPC status\\n\");\n\t\tgoto iounmap_base;\n\t}\n\n\tirq_handle = irq_domain_alloc_named_fwnode(\"lpcintc\");\n\tif (!irq_handle) {\n\t\tpr_err(\"Unable to allocate domain handle\\n\");\n\t\tgoto iounmap_base;\n\t}\n\n\tpriv->lpc_domain = irq_domain_create_linear(irq_handle, LPC_COUNT,\n\t\t\t\t\t&pch_lpc_domain_ops, priv);\n\tif (!priv->lpc_domain) {\n\t\tpr_err(\"Failed to create IRQ domain\\n\");\n\t\tgoto free_irq_handle;\n\t}\n\tpch_lpc_reset(priv);\n\n\tfwspec.fwnode = parent->fwnode;\n\tfwspec.param[0] = acpi_pchlpc->cascade + GSI_MIN_PCH_IRQ;\n\tfwspec.param[1] = IRQ_TYPE_LEVEL_HIGH;\n\tfwspec.param_count = 2;\n\tparent_irq = irq_create_fwspec_mapping(&fwspec);\n\tirq_set_chained_handler_and_data(parent_irq, lpc_irq_dispatch, priv);\n\n\tpch_lpc_priv = priv;\n\tpch_lpc_handle = irq_handle;\n\tregister_syscore_ops(&pch_lpc_syscore_ops);\n\n\treturn 0;\n\nfree_irq_handle:\n\tirq_domain_free_fwnode(irq_handle);\niounmap_base:\n\tiounmap(priv->base);\nfree_priv:\n\tkfree(priv);\n\n\treturn -ENOMEM;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}