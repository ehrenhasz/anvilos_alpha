{
  "module_name": "irq-bcm7038-l1.c",
  "hash_id": "a56fa3efc6126c79155367cf191db39403a79870a3c56ad1b5a02c30c0e123c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-bcm7038-l1.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME\t\": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <linux/types.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/syscore_ops.h>\n\n#define IRQS_PER_WORD\t\t32\n#define REG_BYTES_PER_IRQ_WORD\t(sizeof(u32) * 4)\n#define MAX_WORDS\t\t8\n\nstruct bcm7038_l1_cpu;\n\nstruct bcm7038_l1_chip {\n\traw_spinlock_t\t\tlock;\n\tunsigned int\t\tn_words;\n\tstruct irq_domain\t*domain;\n\tstruct bcm7038_l1_cpu\t*cpus[NR_CPUS];\n#ifdef CONFIG_PM_SLEEP\n\tstruct list_head\tlist;\n\tu32\t\t\twake_mask[MAX_WORDS];\n#endif\n\tu32\t\t\tirq_fwd_mask[MAX_WORDS];\n\tu8\t\t\taffinity[MAX_WORDS * IRQS_PER_WORD];\n};\n\nstruct bcm7038_l1_cpu {\n\tvoid __iomem\t\t*map_base;\n\tu32\t\t\tmask_cache[];\n};\n\n \n\nstatic inline unsigned int reg_status(struct bcm7038_l1_chip *intc,\n\t\t\t\t      unsigned int word)\n{\n\treturn (0 * intc->n_words + word) * sizeof(u32);\n}\n\nstatic inline unsigned int reg_mask_status(struct bcm7038_l1_chip *intc,\n\t\t\t\t\t   unsigned int word)\n{\n\treturn (1 * intc->n_words + word) * sizeof(u32);\n}\n\nstatic inline unsigned int reg_mask_set(struct bcm7038_l1_chip *intc,\n\t\t\t\t\tunsigned int word)\n{\n\treturn (2 * intc->n_words + word) * sizeof(u32);\n}\n\nstatic inline unsigned int reg_mask_clr(struct bcm7038_l1_chip *intc,\n\t\t\t\t\tunsigned int word)\n{\n\treturn (3 * intc->n_words + word) * sizeof(u32);\n}\n\nstatic inline u32 l1_readl(void __iomem *reg)\n{\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\treturn ioread32be(reg);\n\telse\n\t\treturn readl(reg);\n}\n\nstatic inline void l1_writel(u32 val, void __iomem *reg)\n{\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\tiowrite32be(val, reg);\n\telse\n\t\twritel(val, reg);\n}\n\nstatic void bcm7038_l1_irq_handle(struct irq_desc *desc)\n{\n\tstruct bcm7038_l1_chip *intc = irq_desc_get_handler_data(desc);\n\tstruct bcm7038_l1_cpu *cpu;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned int idx;\n\n#if defined(CONFIG_SMP) && defined(CONFIG_MIPS)\n\tcpu = intc->cpus[cpu_logical_map(smp_processor_id())];\n#else\n\tcpu = intc->cpus[0];\n#endif\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (idx = 0; idx < intc->n_words; idx++) {\n\t\tint base = idx * IRQS_PER_WORD;\n\t\tunsigned long pending, flags;\n\t\tint hwirq;\n\n\t\traw_spin_lock_irqsave(&intc->lock, flags);\n\t\tpending = l1_readl(cpu->map_base + reg_status(intc, idx)) &\n\t\t\t  ~cpu->mask_cache[idx];\n\t\traw_spin_unlock_irqrestore(&intc->lock, flags);\n\n\t\tfor_each_set_bit(hwirq, &pending, IRQS_PER_WORD)\n\t\t\tgeneric_handle_domain_irq(intc->domain, base + hwirq);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void __bcm7038_l1_unmask(struct irq_data *d, unsigned int cpu_idx)\n{\n\tstruct bcm7038_l1_chip *intc = irq_data_get_irq_chip_data(d);\n\tu32 word = d->hwirq / IRQS_PER_WORD;\n\tu32 mask = BIT(d->hwirq % IRQS_PER_WORD);\n\n\tintc->cpus[cpu_idx]->mask_cache[word] &= ~mask;\n\tl1_writel(mask, intc->cpus[cpu_idx]->map_base +\n\t\t\treg_mask_clr(intc, word));\n}\n\nstatic void __bcm7038_l1_mask(struct irq_data *d, unsigned int cpu_idx)\n{\n\tstruct bcm7038_l1_chip *intc = irq_data_get_irq_chip_data(d);\n\tu32 word = d->hwirq / IRQS_PER_WORD;\n\tu32 mask = BIT(d->hwirq % IRQS_PER_WORD);\n\n\tintc->cpus[cpu_idx]->mask_cache[word] |= mask;\n\tl1_writel(mask, intc->cpus[cpu_idx]->map_base +\n\t\t\treg_mask_set(intc, word));\n}\n\nstatic void bcm7038_l1_unmask(struct irq_data *d)\n{\n\tstruct bcm7038_l1_chip *intc = irq_data_get_irq_chip_data(d);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&intc->lock, flags);\n\t__bcm7038_l1_unmask(d, intc->affinity[d->hwirq]);\n\traw_spin_unlock_irqrestore(&intc->lock, flags);\n}\n\nstatic void bcm7038_l1_mask(struct irq_data *d)\n{\n\tstruct bcm7038_l1_chip *intc = irq_data_get_irq_chip_data(d);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&intc->lock, flags);\n\t__bcm7038_l1_mask(d, intc->affinity[d->hwirq]);\n\traw_spin_unlock_irqrestore(&intc->lock, flags);\n}\n\n#if defined(CONFIG_MIPS) && defined(CONFIG_SMP)\nstatic int bcm7038_l1_set_affinity(struct irq_data *d,\n\t\t\t\t   const struct cpumask *dest,\n\t\t\t\t   bool force)\n{\n\tstruct bcm7038_l1_chip *intc = irq_data_get_irq_chip_data(d);\n\tunsigned long flags;\n\tirq_hw_number_t hw = d->hwirq;\n\tu32 word = hw / IRQS_PER_WORD;\n\tu32 mask = BIT(hw % IRQS_PER_WORD);\n\tunsigned int first_cpu = cpumask_any_and(dest, cpu_online_mask);\n\tbool was_disabled;\n\n\traw_spin_lock_irqsave(&intc->lock, flags);\n\n\twas_disabled = !!(intc->cpus[intc->affinity[hw]]->mask_cache[word] &\n\t\t\t  mask);\n\t__bcm7038_l1_mask(d, intc->affinity[hw]);\n\tintc->affinity[hw] = first_cpu;\n\tif (!was_disabled)\n\t\t__bcm7038_l1_unmask(d, first_cpu);\n\n\traw_spin_unlock_irqrestore(&intc->lock, flags);\n\tirq_data_update_effective_affinity(d, cpumask_of(first_cpu));\n\n\treturn 0;\n}\n#endif\n\nstatic int __init bcm7038_l1_init_one(struct device_node *dn,\n\t\t\t\t      unsigned int idx,\n\t\t\t\t      struct bcm7038_l1_chip *intc)\n{\n\tstruct resource res;\n\tresource_size_t sz;\n\tstruct bcm7038_l1_cpu *cpu;\n\tunsigned int i, n_words, parent_irq;\n\tint ret;\n\n\tif (of_address_to_resource(dn, idx, &res))\n\t\treturn -EINVAL;\n\tsz = resource_size(&res);\n\tn_words = sz / REG_BYTES_PER_IRQ_WORD;\n\n\tif (n_words > MAX_WORDS)\n\t\treturn -EINVAL;\n\telse if (!intc->n_words)\n\t\tintc->n_words = n_words;\n\telse if (intc->n_words != n_words)\n\t\treturn -EINVAL;\n\n\tret = of_property_read_u32_array(dn , \"brcm,int-fwd-mask\",\n\t\t\t\t\t intc->irq_fwd_mask, n_words);\n\tif (ret != 0 && ret != -EINVAL) {\n\t\t \n\t\tpr_err(\"invalid brcm,int-fwd-mask property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcpu = intc->cpus[idx] = kzalloc(sizeof(*cpu) + n_words * sizeof(u32),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!cpu)\n\t\treturn -ENOMEM;\n\n\tcpu->map_base = ioremap(res.start, sz);\n\tif (!cpu->map_base)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < n_words; i++) {\n\t\tl1_writel(~intc->irq_fwd_mask[i],\n\t\t\t  cpu->map_base + reg_mask_set(intc, i));\n\t\tl1_writel(intc->irq_fwd_mask[i],\n\t\t\t  cpu->map_base + reg_mask_clr(intc, i));\n\t\tcpu->mask_cache[i] = ~intc->irq_fwd_mask[i];\n\t}\n\n\tparent_irq = irq_of_parse_and_map(dn, idx);\n\tif (!parent_irq) {\n\t\tpr_err(\"failed to map parent interrupt %d\\n\", parent_irq);\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_bool(dn, \"brcm,irq-can-wake\"))\n\t\tenable_irq_wake(parent_irq);\n\n\tirq_set_chained_handler_and_data(parent_irq, bcm7038_l1_irq_handle,\n\t\t\t\t\t intc);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic LIST_HEAD(bcm7038_l1_intcs_list);\nstatic DEFINE_RAW_SPINLOCK(bcm7038_l1_intcs_lock);\n\nstatic int bcm7038_l1_suspend(void)\n{\n\tstruct bcm7038_l1_chip *intc;\n\tint boot_cpu, word;\n\tu32 val;\n\n\t \n#if defined(CONFIG_SMP) && defined(CONFIG_MIPS)\n\tboot_cpu = cpu_logical_map(0);\n#else\n\tboot_cpu = 0;\n#endif\n\n\tlist_for_each_entry(intc, &bcm7038_l1_intcs_list, list) {\n\t\tfor (word = 0; word < intc->n_words; word++) {\n\t\t\tval = intc->wake_mask[word] | intc->irq_fwd_mask[word];\n\t\t\tl1_writel(~val,\n\t\t\t\tintc->cpus[boot_cpu]->map_base + reg_mask_set(intc, word));\n\t\t\tl1_writel(val,\n\t\t\t\tintc->cpus[boot_cpu]->map_base + reg_mask_clr(intc, word));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void bcm7038_l1_resume(void)\n{\n\tstruct bcm7038_l1_chip *intc;\n\tint boot_cpu, word;\n\n#if defined(CONFIG_SMP) && defined(CONFIG_MIPS)\n\tboot_cpu = cpu_logical_map(0);\n#else\n\tboot_cpu = 0;\n#endif\n\n\tlist_for_each_entry(intc, &bcm7038_l1_intcs_list, list) {\n\t\tfor (word = 0; word < intc->n_words; word++) {\n\t\t\tl1_writel(intc->cpus[boot_cpu]->mask_cache[word],\n\t\t\t\tintc->cpus[boot_cpu]->map_base + reg_mask_set(intc, word));\n\t\t\tl1_writel(~intc->cpus[boot_cpu]->mask_cache[word],\n\t\t\t\tintc->cpus[boot_cpu]->map_base + reg_mask_clr(intc, word));\n\t\t}\n\t}\n}\n\nstatic struct syscore_ops bcm7038_l1_syscore_ops = {\n\t.suspend\t= bcm7038_l1_suspend,\n\t.resume\t\t= bcm7038_l1_resume,\n};\n\nstatic int bcm7038_l1_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct bcm7038_l1_chip *intc = irq_data_get_irq_chip_data(d);\n\tunsigned long flags;\n\tu32 word = d->hwirq / IRQS_PER_WORD;\n\tu32 mask = BIT(d->hwirq % IRQS_PER_WORD);\n\n\traw_spin_lock_irqsave(&intc->lock, flags);\n\tif (on)\n\t\tintc->wake_mask[word] |= mask;\n\telse\n\t\tintc->wake_mask[word] &= ~mask;\n\traw_spin_unlock_irqrestore(&intc->lock, flags);\n\n\treturn 0;\n}\n#endif\n\nstatic struct irq_chip bcm7038_l1_irq_chip = {\n\t.name\t\t\t= \"bcm7038-l1\",\n\t.irq_mask\t\t= bcm7038_l1_mask,\n\t.irq_unmask\t\t= bcm7038_l1_unmask,\n#if defined(CONFIG_SMP) && defined(CONFIG_MIPS)\n\t.irq_set_affinity\t= bcm7038_l1_set_affinity,\n#endif\n#ifdef CONFIG_PM_SLEEP\n\t.irq_set_wake\t\t= bcm7038_l1_set_wake,\n#endif\n};\n\nstatic int bcm7038_l1_map(struct irq_domain *d, unsigned int virq,\n\t\t\t  irq_hw_number_t hw_irq)\n{\n\tstruct bcm7038_l1_chip *intc = d->host_data;\n\tu32 mask = BIT(hw_irq % IRQS_PER_WORD);\n\tu32 word = hw_irq / IRQS_PER_WORD;\n\n\tif (intc->irq_fwd_mask[word] & mask)\n\t\treturn -EPERM;\n\n\tirq_set_chip_and_handler(virq, &bcm7038_l1_irq_chip, handle_level_irq);\n\tirq_set_chip_data(virq, d->host_data);\n\tirqd_set_single_target(irq_get_irq_data(virq));\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops bcm7038_l1_domain_ops = {\n\t.xlate\t\t\t= irq_domain_xlate_onecell,\n\t.map\t\t\t= bcm7038_l1_map,\n};\n\nstatic int __init bcm7038_l1_of_init(struct device_node *dn,\n\t\t\t      struct device_node *parent)\n{\n\tstruct bcm7038_l1_chip *intc;\n\tint idx, ret;\n\n\tintc = kzalloc(sizeof(*intc), GFP_KERNEL);\n\tif (!intc)\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_init(&intc->lock);\n\tfor_each_possible_cpu(idx) {\n\t\tret = bcm7038_l1_init_one(dn, idx, intc);\n\t\tif (ret < 0) {\n\t\t\tif (idx)\n\t\t\t\tbreak;\n\t\t\tpr_err(\"failed to remap intc L1 registers\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tintc->domain = irq_domain_add_linear(dn, IRQS_PER_WORD * intc->n_words,\n\t\t\t\t\t     &bcm7038_l1_domain_ops,\n\t\t\t\t\t     intc);\n\tif (!intc->domain) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n#ifdef CONFIG_PM_SLEEP\n\t \n\traw_spin_lock(&bcm7038_l1_intcs_lock);\n\tlist_add_tail(&intc->list, &bcm7038_l1_intcs_list);\n\traw_spin_unlock(&bcm7038_l1_intcs_lock);\n\n\tif (list_is_singular(&bcm7038_l1_intcs_list))\n\t\tregister_syscore_ops(&bcm7038_l1_syscore_ops);\n#endif\n\n\tpr_info(\"registered BCM7038 L1 intc (%pOF, IRQs: %d)\\n\",\n\t\tdn, IRQS_PER_WORD * intc->n_words);\n\n\treturn 0;\n\nout_unmap:\n\tfor_each_possible_cpu(idx) {\n\t\tstruct bcm7038_l1_cpu *cpu = intc->cpus[idx];\n\n\t\tif (cpu) {\n\t\t\tif (cpu->map_base)\n\t\t\t\tiounmap(cpu->map_base);\n\t\t\tkfree(cpu);\n\t\t}\n\t}\nout_free:\n\tkfree(intc);\n\treturn ret;\n}\n\nIRQCHIP_PLATFORM_DRIVER_BEGIN(bcm7038_l1)\nIRQCHIP_MATCH(\"brcm,bcm7038-l1-intc\", bcm7038_l1_of_init)\nIRQCHIP_PLATFORM_DRIVER_END(bcm7038_l1)\nMODULE_DESCRIPTION(\"Broadcom STB 7038-style L1/L2 interrupt controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}