{
  "module_name": "irq-vic.c",
  "hash_id": "5baefa9de646027746866645b2b9c5082e76011e7d53aaf4a25f2ee06816dbed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-vic.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/syscore_ops.h>\n#include <linux/device.h>\n#include <linux/amba/bus.h>\n#include <linux/irqchip/arm-vic.h>\n\n#include <asm/exception.h>\n#include <asm/irq.h>\n\n#define VIC_IRQ_STATUS\t\t\t0x00\n#define VIC_FIQ_STATUS\t\t\t0x04\n#define VIC_RAW_STATUS\t\t\t0x08\n#define VIC_INT_SELECT\t\t\t0x0c\t \n#define VIC_INT_ENABLE\t\t\t0x10\t \n#define VIC_INT_ENABLE_CLEAR\t\t0x14\n#define VIC_INT_SOFT\t\t\t0x18\n#define VIC_INT_SOFT_CLEAR\t\t0x1c\n#define VIC_PROTECT\t\t\t0x20\n#define VIC_PL190_VECT_ADDR\t\t0x30\t \n#define VIC_PL190_DEF_VECT_ADDR\t\t0x34\t \n\n#define VIC_VECT_ADDR0\t\t\t0x100\t \n#define VIC_VECT_CNTL0\t\t\t0x200\t \n#define VIC_ITCR\t\t\t0x300\t \n\n#define VIC_VECT_CNTL_ENABLE\t\t(1 << 5)\n\n#define VIC_PL192_VECT_ADDR\t\t0xF00\n\n \nstruct vic_device {\n\tvoid __iomem\t*base;\n\tint\t\tirq;\n\tu32\t\tvalid_sources;\n\tu32\t\tresume_sources;\n\tu32\t\tresume_irqs;\n\tu32\t\tint_select;\n\tu32\t\tint_enable;\n\tu32\t\tsoft_int;\n\tu32\t\tprotect;\n\tstruct irq_domain *domain;\n};\n\n \nstatic struct vic_device vic_devices[CONFIG_ARM_VIC_NR];\n\nstatic int vic_id;\n\nstatic void vic_handle_irq(struct pt_regs *regs);\n\n \nstatic void vic_init2(void __iomem *base)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tvoid __iomem *reg = base + VIC_VECT_CNTL0 + (i * 4);\n\t\twritel(VIC_VECT_CNTL_ENABLE | i, reg);\n\t}\n\n\twritel(32, base + VIC_PL190_DEF_VECT_ADDR);\n}\n\n#ifdef CONFIG_PM\nstatic void resume_one_vic(struct vic_device *vic)\n{\n\tvoid __iomem *base = vic->base;\n\n\tprintk(KERN_DEBUG \"%s: resuming vic at %p\\n\", __func__, base);\n\n\t \n\tvic_init2(base);\n\n\twritel(vic->int_select, base + VIC_INT_SELECT);\n\twritel(vic->protect, base + VIC_PROTECT);\n\n\t \n\twritel(vic->int_enable, base + VIC_INT_ENABLE);\n\twritel(~vic->int_enable, base + VIC_INT_ENABLE_CLEAR);\n\n\t \n\n\twritel(vic->soft_int, base + VIC_INT_SOFT);\n\twritel(~vic->soft_int, base + VIC_INT_SOFT_CLEAR);\n}\n\nstatic void vic_resume(void)\n{\n\tint id;\n\n\tfor (id = vic_id - 1; id >= 0; id--)\n\t\tresume_one_vic(vic_devices + id);\n}\n\nstatic void suspend_one_vic(struct vic_device *vic)\n{\n\tvoid __iomem *base = vic->base;\n\n\tprintk(KERN_DEBUG \"%s: suspending vic at %p\\n\", __func__, base);\n\n\tvic->int_select = readl(base + VIC_INT_SELECT);\n\tvic->int_enable = readl(base + VIC_INT_ENABLE);\n\tvic->soft_int = readl(base + VIC_INT_SOFT);\n\tvic->protect = readl(base + VIC_PROTECT);\n\n\t \n\n\twritel(vic->resume_irqs, base + VIC_INT_ENABLE);\n\twritel(~vic->resume_irqs, base + VIC_INT_ENABLE_CLEAR);\n}\n\nstatic int vic_suspend(void)\n{\n\tint id;\n\n\tfor (id = 0; id < vic_id; id++)\n\t\tsuspend_one_vic(vic_devices + id);\n\n\treturn 0;\n}\n\nstatic struct syscore_ops vic_syscore_ops = {\n\t.suspend\t= vic_suspend,\n\t.resume\t\t= vic_resume,\n};\n\n \nstatic int __init vic_pm_init(void)\n{\n\tif (vic_id > 0)\n\t\tregister_syscore_ops(&vic_syscore_ops);\n\n\treturn 0;\n}\nlate_initcall(vic_pm_init);\n#endif  \n\nstatic struct irq_chip vic_chip;\n\nstatic int vic_irqdomain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t     irq_hw_number_t hwirq)\n{\n\tstruct vic_device *v = d->host_data;\n\n\t \n\tif (!(v->valid_sources & (1 << hwirq)))\n\t\treturn -EPERM;\n\tirq_set_chip_and_handler(irq, &vic_chip, handle_level_irq);\n\tirq_set_chip_data(irq, v->base);\n\tirq_set_probe(irq);\n\treturn 0;\n}\n\n \nstatic int handle_one_vic(struct vic_device *vic, struct pt_regs *regs)\n{\n\tu32 stat, irq;\n\tint handled = 0;\n\n\twhile ((stat = readl_relaxed(vic->base + VIC_IRQ_STATUS))) {\n\t\tirq = ffs(stat) - 1;\n\t\tgeneric_handle_domain_irq(vic->domain, irq);\n\t\thandled = 1;\n\t}\n\n\treturn handled;\n}\n\nstatic void vic_handle_irq_cascaded(struct irq_desc *desc)\n{\n\tu32 stat, hwirq;\n\tstruct irq_chip *host_chip = irq_desc_get_chip(desc);\n\tstruct vic_device *vic = irq_desc_get_handler_data(desc);\n\n\tchained_irq_enter(host_chip, desc);\n\n\twhile ((stat = readl_relaxed(vic->base + VIC_IRQ_STATUS))) {\n\t\thwirq = ffs(stat) - 1;\n\t\tgeneric_handle_domain_irq(vic->domain, hwirq);\n\t}\n\n\tchained_irq_exit(host_chip, desc);\n}\n\n \nstatic void __exception_irq_entry vic_handle_irq(struct pt_regs *regs)\n{\n\tint i, handled;\n\n\tdo {\n\t\tfor (i = 0, handled = 0; i < vic_id; ++i)\n\t\t\thandled |= handle_one_vic(&vic_devices[i], regs);\n\t} while (handled);\n}\n\nstatic const struct irq_domain_ops vic_irqdomain_ops = {\n\t.map = vic_irqdomain_map,\n\t.xlate = irq_domain_xlate_onetwocell,\n};\n\n \nstatic void __init vic_register(void __iomem *base, unsigned int parent_irq,\n\t\t\t\tunsigned int irq,\n\t\t\t\tu32 valid_sources, u32 resume_sources,\n\t\t\t\tstruct device_node *node)\n{\n\tstruct vic_device *v;\n\tint i;\n\n\tif (vic_id >= ARRAY_SIZE(vic_devices)) {\n\t\tprintk(KERN_ERR \"%s: too few VICs, increase CONFIG_ARM_VIC_NR\\n\", __func__);\n\t\treturn;\n\t}\n\n\tv = &vic_devices[vic_id];\n\tv->base = base;\n\tv->valid_sources = valid_sources;\n\tv->resume_sources = resume_sources;\n\tset_handle_irq(vic_handle_irq);\n\tvic_id++;\n\n\tif (parent_irq) {\n\t\tirq_set_chained_handler_and_data(parent_irq,\n\t\t\t\t\t\t vic_handle_irq_cascaded, v);\n\t}\n\n\tv->domain = irq_domain_add_simple(node, fls(valid_sources), irq,\n\t\t\t\t\t  &vic_irqdomain_ops, v);\n\t \n\tfor (i = 0; i < fls(valid_sources); i++)\n\t\tif (valid_sources & (1 << i))\n\t\t\tirq_create_mapping(v->domain, i);\n\t \n\tif (irq)\n\t\tv->irq = irq;\n\telse\n\t\tv->irq = irq_find_mapping(v->domain, 0);\n}\n\nstatic void vic_ack_irq(struct irq_data *d)\n{\n\tvoid __iomem *base = irq_data_get_irq_chip_data(d);\n\tunsigned int irq = d->hwirq;\n\twritel(1 << irq, base + VIC_INT_ENABLE_CLEAR);\n\t \n\twritel(1 << irq, base + VIC_INT_SOFT_CLEAR);\n}\n\nstatic void vic_mask_irq(struct irq_data *d)\n{\n\tvoid __iomem *base = irq_data_get_irq_chip_data(d);\n\tunsigned int irq = d->hwirq;\n\twritel(1 << irq, base + VIC_INT_ENABLE_CLEAR);\n}\n\nstatic void vic_unmask_irq(struct irq_data *d)\n{\n\tvoid __iomem *base = irq_data_get_irq_chip_data(d);\n\tunsigned int irq = d->hwirq;\n\twritel(1 << irq, base + VIC_INT_ENABLE);\n}\n\n#if defined(CONFIG_PM)\nstatic struct vic_device *vic_from_irq(unsigned int irq)\n{\n        struct vic_device *v = vic_devices;\n\tunsigned int base_irq = irq & ~31;\n\tint id;\n\n\tfor (id = 0; id < vic_id; id++, v++) {\n\t\tif (v->irq == base_irq)\n\t\t\treturn v;\n\t}\n\n\treturn NULL;\n}\n\nstatic int vic_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct vic_device *v = vic_from_irq(d->irq);\n\tunsigned int off = d->hwirq;\n\tu32 bit = 1 << off;\n\n\tif (!v)\n\t\treturn -EINVAL;\n\n\tif (!(bit & v->resume_sources))\n\t\treturn -EINVAL;\n\n\tif (on)\n\t\tv->resume_irqs |= bit;\n\telse\n\t\tv->resume_irqs &= ~bit;\n\n\treturn 0;\n}\n#else\n#define vic_set_wake NULL\n#endif  \n\nstatic struct irq_chip vic_chip = {\n\t.name\t\t= \"VIC\",\n\t.irq_ack\t= vic_ack_irq,\n\t.irq_mask\t= vic_mask_irq,\n\t.irq_unmask\t= vic_unmask_irq,\n\t.irq_set_wake\t= vic_set_wake,\n};\n\nstatic void __init vic_disable(void __iomem *base)\n{\n\twritel(0, base + VIC_INT_SELECT);\n\twritel(0, base + VIC_INT_ENABLE);\n\twritel(~0, base + VIC_INT_ENABLE_CLEAR);\n\twritel(0, base + VIC_ITCR);\n\twritel(~0, base + VIC_INT_SOFT_CLEAR);\n}\n\nstatic void __init vic_clear_interrupts(void __iomem *base)\n{\n\tunsigned int i;\n\n\twritel(0, base + VIC_PL190_VECT_ADDR);\n\tfor (i = 0; i < 19; i++) {\n\t\tunsigned int value;\n\n\t\tvalue = readl(base + VIC_PL190_VECT_ADDR);\n\t\twritel(value, base + VIC_PL190_VECT_ADDR);\n\t}\n}\n\n \nstatic void __init vic_init_st(void __iomem *base, unsigned int irq_start,\n\t\t\t       u32 vic_sources, struct device_node *node)\n{\n\tunsigned int i;\n\tint vic_2nd_block = ((unsigned long)base & ~PAGE_MASK) != 0;\n\n\t \n\tvic_disable(base);\n\n\t \n\tif (vic_2nd_block) {\n\t\tvic_clear_interrupts(base);\n\n\t\t \n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tvoid __iomem *reg = base + VIC_VECT_CNTL0 + (i * 4);\n\t\t\twritel(0, reg);\n\t\t}\n\n\t\twritel(32, base + VIC_PL190_DEF_VECT_ADDR);\n\t}\n\n\tvic_register(base, 0, irq_start, vic_sources, 0, node);\n}\n\nstatic void __init __vic_init(void __iomem *base, int parent_irq, int irq_start,\n\t\t\t      u32 vic_sources, u32 resume_sources,\n\t\t\t      struct device_node *node)\n{\n\tunsigned int i;\n\tu32 cellid = 0;\n\tenum amba_vendor vendor;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tvoid __iomem *addr;\n\t\taddr = (void __iomem *)((u32)base & PAGE_MASK) + 0xfe0 + (i * 4);\n\t\tcellid |= (readl(addr) & 0xff) << (8 * i);\n\t}\n\tvendor = (cellid >> 12) & 0xff;\n\tprintk(KERN_INFO \"VIC @%p: id 0x%08x, vendor 0x%02x\\n\",\n\t       base, cellid, vendor);\n\n\tswitch(vendor) {\n\tcase AMBA_VENDOR_ST:\n\t\tvic_init_st(base, irq_start, vic_sources, node);\n\t\treturn;\n\tdefault:\n\t\tprintk(KERN_WARNING \"VIC: unknown vendor, continuing anyways\\n\");\n\t\tfallthrough;\n\tcase AMBA_VENDOR_ARM:\n\t\tbreak;\n\t}\n\n\t \n\tvic_disable(base);\n\n\t \n\tvic_clear_interrupts(base);\n\n\tvic_init2(base);\n\n\tvic_register(base, parent_irq, irq_start, vic_sources, resume_sources, node);\n}\n\n \nvoid __init vic_init(void __iomem *base, unsigned int irq_start,\n\t\t     u32 vic_sources, u32 resume_sources)\n{\n\t__vic_init(base, 0, irq_start, vic_sources, resume_sources, NULL);\n}\n\n#ifdef CONFIG_OF\nstatic int __init vic_of_init(struct device_node *node,\n\t\t\t      struct device_node *parent)\n{\n\tvoid __iomem *regs;\n\tu32 interrupt_mask = ~0;\n\tu32 wakeup_mask = ~0;\n\tint parent_irq;\n\n\tregs = of_iomap(node, 0);\n\tif (WARN_ON(!regs))\n\t\treturn -EIO;\n\n\tof_property_read_u32(node, \"valid-mask\", &interrupt_mask);\n\tof_property_read_u32(node, \"valid-wakeup-mask\", &wakeup_mask);\n\tparent_irq = of_irq_get(node, 0);\n\tif (parent_irq < 0)\n\t\tparent_irq = 0;\n\n\t \n\t__vic_init(regs, parent_irq, 0, interrupt_mask, wakeup_mask, node);\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(arm_pl190_vic, \"arm,pl190-vic\", vic_of_init);\nIRQCHIP_DECLARE(arm_pl192_vic, \"arm,pl192-vic\", vic_of_init);\nIRQCHIP_DECLARE(arm_versatile_vic, \"arm,versatile-vic\", vic_of_init);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}