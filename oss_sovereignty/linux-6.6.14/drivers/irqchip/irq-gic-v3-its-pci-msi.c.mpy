{
  "module_name": "irq-gic-v3-its-pci-msi.c",
  "hash_id": "9ebcbea9b30f224b1cd7b98b724f35c241392a48ad24118b7f6a0720a47267c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-gic-v3-its-pci-msi.c",
  "human_readable_source": "\n \n\n#include <linux/acpi_iort.h>\n#include <linux/pci.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_pci.h>\n\nstatic void its_mask_msi_irq(struct irq_data *d)\n{\n\tpci_msi_mask_irq(d);\n\tirq_chip_mask_parent(d);\n}\n\nstatic void its_unmask_msi_irq(struct irq_data *d)\n{\n\tpci_msi_unmask_irq(d);\n\tirq_chip_unmask_parent(d);\n}\n\nstatic struct irq_chip its_msi_irq_chip = {\n\t.name\t\t\t= \"ITS-MSI\",\n\t.irq_unmask\t\t= its_unmask_msi_irq,\n\t.irq_mask\t\t= its_mask_msi_irq,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n};\n\nstatic int its_pci_msi_vec_count(struct pci_dev *pdev, void *data)\n{\n\tint msi, msix, *count = data;\n\n\tmsi = max(pci_msi_vec_count(pdev), 0);\n\tmsix = max(pci_msix_vec_count(pdev), 0);\n\t*count += max(msi, msix);\n\n\treturn 0;\n}\n\nstatic int its_get_pci_alias(struct pci_dev *pdev, u16 alias, void *data)\n{\n\tstruct pci_dev **alias_dev = data;\n\n\t*alias_dev = pdev;\n\n\treturn 0;\n}\n\nstatic int its_pci_msi_prepare(struct irq_domain *domain, struct device *dev,\n\t\t\t       int nvec, msi_alloc_info_t *info)\n{\n\tstruct pci_dev *pdev, *alias_dev;\n\tstruct msi_domain_info *msi_info;\n\tint alias_count = 0, minnvec = 1;\n\n\tif (!dev_is_pci(dev))\n\t\treturn -EINVAL;\n\n\tmsi_info = msi_get_domain_info(domain->parent);\n\n\tpdev = to_pci_dev(dev);\n\t \n\tpci_for_each_dma_alias(pdev, its_get_pci_alias, &alias_dev);\n\tif (alias_dev != pdev) {\n\t\tif (alias_dev->subordinate)\n\t\t\tpci_walk_bus(alias_dev->subordinate,\n\t\t\t\t     its_pci_msi_vec_count, &alias_count);\n\t\tinfo->flags |= MSI_ALLOC_FLAGS_PROXY_DEVICE;\n\t}\n\n\t \n\tinfo->scratchpad[0].ul = pci_msi_domain_get_msi_rid(domain, pdev);\n\n\t \n\tnvec = max(nvec, alias_count);\n\tif (!info->scratchpad[0].ul)\n\t\tminnvec = 32;\n\tnvec = max_t(int, minnvec, roundup_pow_of_two(nvec));\n\treturn msi_info->ops->msi_prepare(domain->parent, dev, nvec, info);\n}\n\nstatic struct msi_domain_ops its_pci_msi_ops = {\n\t.msi_prepare\t= its_pci_msi_prepare,\n};\n\nstatic struct msi_domain_info its_pci_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_MULTI_PCI_MSI | MSI_FLAG_PCI_MSIX),\n\t.ops\t= &its_pci_msi_ops,\n\t.chip\t= &its_msi_irq_chip,\n};\n\nstatic struct of_device_id its_device_id[] = {\n\t{\t.compatible\t= \"arm,gic-v3-its\",\t},\n\t{},\n};\n\nstatic int __init its_pci_msi_init_one(struct fwnode_handle *handle,\n\t\t\t\t       const char *name)\n{\n\tstruct irq_domain *parent;\n\n\tparent = irq_find_matching_fwnode(handle, DOMAIN_BUS_NEXUS);\n\tif (!parent || !msi_get_domain_info(parent)) {\n\t\tpr_err(\"%s: Unable to locate ITS domain\\n\", name);\n\t\treturn -ENXIO;\n\t}\n\n\tif (!pci_msi_create_irq_domain(handle, &its_pci_msi_domain_info,\n\t\t\t\t       parent)) {\n\t\tpr_err(\"%s: Unable to create PCI domain\\n\", name);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init its_pci_of_msi_init(void)\n{\n\tstruct device_node *np;\n\n\tfor (np = of_find_matching_node(NULL, its_device_id); np;\n\t     np = of_find_matching_node(np, its_device_id)) {\n\t\tif (!of_device_is_available(np))\n\t\t\tcontinue;\n\t\tif (!of_property_read_bool(np, \"msi-controller\"))\n\t\t\tcontinue;\n\n\t\tif (its_pci_msi_init_one(of_node_to_fwnode(np), np->full_name))\n\t\t\tcontinue;\n\n\t\tpr_info(\"PCI/MSI: %pOF domain created\\n\", np);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\n\nstatic int __init\nits_pci_msi_parse_madt(union acpi_subtable_headers *header,\n\t\t       const unsigned long end)\n{\n\tstruct acpi_madt_generic_translator *its_entry;\n\tstruct fwnode_handle *dom_handle;\n\tconst char *node_name;\n\tint err = -ENXIO;\n\n\tits_entry = (struct acpi_madt_generic_translator *)header;\n\tnode_name = kasprintf(GFP_KERNEL, \"ITS@0x%lx\",\n\t\t\t      (long)its_entry->base_address);\n\tdom_handle = iort_find_domain_token(its_entry->translation_id);\n\tif (!dom_handle) {\n\t\tpr_err(\"%s: Unable to locate ITS domain handle\\n\", node_name);\n\t\tgoto out;\n\t}\n\n\terr = its_pci_msi_init_one(dom_handle, node_name);\n\tif (!err)\n\t\tpr_info(\"PCI/MSI: %s domain created\\n\", node_name);\n\nout:\n\tkfree(node_name);\n\treturn err;\n}\n\nstatic int __init its_pci_acpi_msi_init(void)\n{\n\tacpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_TRANSLATOR,\n\t\t\t      its_pci_msi_parse_madt, 0);\n\treturn 0;\n}\n#else\nstatic int __init its_pci_acpi_msi_init(void)\n{\n\treturn 0;\n}\n#endif\n\nstatic int __init its_pci_msi_init(void)\n{\n\tits_pci_of_msi_init();\n\tits_pci_acpi_msi_init();\n\n\treturn 0;\n}\nearly_initcall(its_pci_msi_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}