{
  "module_name": "irq-vf610-mscm-ir.c",
  "hash_id": "cd45702b06a619f4cbdb848a3011274e72145851d64835ac0eae29dd193daf98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-vf610-mscm-ir.c",
  "human_readable_source": "\n \n\n#include <linux/cpu_pm.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/syscon.h>\n#include <dt-bindings/interrupt-controller/arm-gic.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n\n#define MSCM_CPxNUM\t\t0x4\n\n#define MSCM_IRSPRC(n)\t\t(0x80 + 2 * (n))\n#define MSCM_IRSPRC_CPEN_MASK\t0x3\n\n#define MSCM_IRSPRC_NUM\t\t112\n\nstruct vf610_mscm_ir_chip_data {\n\tvoid __iomem *mscm_ir_base;\n\tu16 cpu_mask;\n\tu16 saved_irsprc[MSCM_IRSPRC_NUM];\n\tbool is_nvic;\n};\n\nstatic struct vf610_mscm_ir_chip_data *mscm_ir_data;\n\nstatic inline void vf610_mscm_ir_save(struct vf610_mscm_ir_chip_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < MSCM_IRSPRC_NUM; i++)\n\t\tdata->saved_irsprc[i] = readw_relaxed(data->mscm_ir_base + MSCM_IRSPRC(i));\n}\n\nstatic inline void vf610_mscm_ir_restore(struct vf610_mscm_ir_chip_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < MSCM_IRSPRC_NUM; i++)\n\t\twritew_relaxed(data->saved_irsprc[i], data->mscm_ir_base + MSCM_IRSPRC(i));\n}\n\nstatic int vf610_mscm_ir_notifier(struct notifier_block *self,\n\t\t\t\t  unsigned long cmd, void *v)\n{\n\tswitch (cmd) {\n\tcase CPU_CLUSTER_PM_ENTER:\n\t\tvf610_mscm_ir_save(mscm_ir_data);\n\t\tbreak;\n\tcase CPU_CLUSTER_PM_ENTER_FAILED:\n\tcase CPU_CLUSTER_PM_EXIT:\n\t\tvf610_mscm_ir_restore(mscm_ir_data);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block mscm_ir_notifier_block = {\n\t.notifier_call = vf610_mscm_ir_notifier,\n};\n\nstatic void vf610_mscm_ir_enable(struct irq_data *data)\n{\n\tirq_hw_number_t hwirq = data->hwirq;\n\tstruct vf610_mscm_ir_chip_data *chip_data = data->chip_data;\n\tu16 irsprc;\n\n\tirsprc = readw_relaxed(chip_data->mscm_ir_base + MSCM_IRSPRC(hwirq));\n\tirsprc &= MSCM_IRSPRC_CPEN_MASK;\n\n\tWARN_ON(irsprc & ~chip_data->cpu_mask);\n\n\twritew_relaxed(chip_data->cpu_mask,\n\t\t       chip_data->mscm_ir_base + MSCM_IRSPRC(hwirq));\n\n\tirq_chip_enable_parent(data);\n}\n\nstatic void vf610_mscm_ir_disable(struct irq_data *data)\n{\n\tirq_hw_number_t hwirq = data->hwirq;\n\tstruct vf610_mscm_ir_chip_data *chip_data = data->chip_data;\n\n\twritew_relaxed(0x0, chip_data->mscm_ir_base + MSCM_IRSPRC(hwirq));\n\n\tirq_chip_disable_parent(data);\n}\n\nstatic struct irq_chip vf610_mscm_ir_irq_chip = {\n\t.name\t\t\t= \"mscm-ir\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_enable\t\t= vf610_mscm_ir_enable,\n\t.irq_disable\t\t= vf610_mscm_ir_disable,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n};\n\nstatic int vf610_mscm_ir_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t      unsigned int nr_irqs, void *arg)\n{\n\tint i;\n\tirq_hw_number_t hwirq;\n\tstruct irq_fwspec *fwspec = arg;\n\tstruct irq_fwspec parent_fwspec;\n\n\tif (!irq_domain_get_of_node(domain->parent))\n\t\treturn -EINVAL;\n\n\tif (fwspec->param_count != 2)\n\t\treturn -EINVAL;\n\n\thwirq = fwspec->param[0];\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\n\t\t\t\t\t      &vf610_mscm_ir_irq_chip,\n\t\t\t\t\t      domain->host_data);\n\n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\n\tif (mscm_ir_data->is_nvic) {\n\t\tparent_fwspec.param_count = 1;\n\t\tparent_fwspec.param[0] = fwspec->param[0];\n\t} else {\n\t\tparent_fwspec.param_count = 3;\n\t\tparent_fwspec.param[0] = GIC_SPI;\n\t\tparent_fwspec.param[1] = fwspec->param[0];\n\t\tparent_fwspec.param[2] = fwspec->param[1];\n\t}\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs,\n\t\t\t\t\t    &parent_fwspec);\n}\n\nstatic int vf610_mscm_ir_domain_translate(struct irq_domain *d,\n\t\t\t\t\t  struct irq_fwspec *fwspec,\n\t\t\t\t\t  unsigned long *hwirq,\n\t\t\t\t\t  unsigned int *type)\n{\n\tif (WARN_ON(fwspec->param_count < 2))\n\t\treturn -EINVAL;\n\t*hwirq = fwspec->param[0];\n\t*type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mscm_irq_domain_ops = {\n\t.translate = vf610_mscm_ir_domain_translate,\n\t.alloc = vf610_mscm_ir_domain_alloc,\n\t.free = irq_domain_free_irqs_common,\n};\n\nstatic int __init vf610_mscm_ir_of_init(struct device_node *node,\n\t\t\t       struct device_node *parent)\n{\n\tstruct irq_domain *domain, *domain_parent;\n\tstruct regmap *mscm_cp_regmap;\n\tint ret, cpuid;\n\n\tdomain_parent = irq_find_host(parent);\n\tif (!domain_parent) {\n\t\tpr_err(\"vf610_mscm_ir: interrupt-parent not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmscm_ir_data = kzalloc(sizeof(*mscm_ir_data), GFP_KERNEL);\n\tif (!mscm_ir_data)\n\t\treturn -ENOMEM;\n\n\tmscm_ir_data->mscm_ir_base = of_io_request_and_map(node, 0, \"mscm-ir\");\n\tif (IS_ERR(mscm_ir_data->mscm_ir_base)) {\n\t\tpr_err(\"vf610_mscm_ir: unable to map mscm register\\n\");\n\t\tret = PTR_ERR(mscm_ir_data->mscm_ir_base);\n\t\tgoto out_free;\n\t}\n\n\tmscm_cp_regmap = syscon_regmap_lookup_by_phandle(node, \"fsl,cpucfg\");\n\tif (IS_ERR(mscm_cp_regmap)) {\n\t\tret = PTR_ERR(mscm_cp_regmap);\n\t\tpr_err(\"vf610_mscm_ir: regmap lookup for cpucfg failed\\n\");\n\t\tgoto out_unmap;\n\t}\n\n\tregmap_read(mscm_cp_regmap, MSCM_CPxNUM, &cpuid);\n\tmscm_ir_data->cpu_mask = 0x1 << cpuid;\n\n\tdomain = irq_domain_add_hierarchy(domain_parent, 0,\n\t\t\t\t\t  MSCM_IRSPRC_NUM, node,\n\t\t\t\t\t  &mscm_irq_domain_ops, mscm_ir_data);\n\tif (!domain) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n\tif (of_device_is_compatible(irq_domain_get_of_node(domain->parent),\n\t\t\t\t    \"arm,armv7m-nvic\"))\n\t\tmscm_ir_data->is_nvic = true;\n\n\tcpu_pm_register_notifier(&mscm_ir_notifier_block);\n\n\treturn 0;\n\nout_unmap:\n\tiounmap(mscm_ir_data->mscm_ir_base);\nout_free:\n\tkfree(mscm_ir_data);\n\treturn ret;\n}\nIRQCHIP_DECLARE(vf610_mscm_ir, \"fsl,vf610-mscm-ir\", vf610_mscm_ir_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}