{
  "module_name": "irq-atmel-aic5.c",
  "hash_id": "80eb026f5fd50bbc9df0d1b4f091245b79f165634fee7b44acfb325946182c83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-atmel-aic5.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/bitmap.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#include <asm/exception.h>\n#include <asm/mach/irq.h>\n\n#include \"irq-atmel-aic-common.h\"\n\n \n#define NR_AIC5_IRQS\t128\n\n#define AT91_AIC5_SSR\t\t0x0\n#define AT91_AIC5_INTSEL_MSK\t(0x7f << 0)\n\n#define AT91_AIC5_SMR\t\t\t0x4\n\n#define AT91_AIC5_SVR\t\t\t0x8\n#define AT91_AIC5_IVR\t\t\t0x10\n#define AT91_AIC5_FVR\t\t\t0x14\n#define AT91_AIC5_ISR\t\t\t0x18\n\n#define AT91_AIC5_IPR0\t\t\t0x20\n#define AT91_AIC5_IPR1\t\t\t0x24\n#define AT91_AIC5_IPR2\t\t\t0x28\n#define AT91_AIC5_IPR3\t\t\t0x2c\n#define AT91_AIC5_IMR\t\t\t0x30\n#define AT91_AIC5_CISR\t\t\t0x34\n\n#define AT91_AIC5_IECR\t\t\t0x40\n#define AT91_AIC5_IDCR\t\t\t0x44\n#define AT91_AIC5_ICCR\t\t\t0x48\n#define AT91_AIC5_ISCR\t\t\t0x4c\n#define AT91_AIC5_EOICR\t\t\t0x38\n#define AT91_AIC5_SPU\t\t\t0x3c\n#define AT91_AIC5_DCR\t\t\t0x6c\n\n#define AT91_AIC5_FFER\t\t\t0x50\n#define AT91_AIC5_FFDR\t\t\t0x54\n#define AT91_AIC5_FFSR\t\t\t0x58\n\nstatic struct irq_domain *aic5_domain;\n\nstatic asmlinkage void __exception_irq_entry\naic5_handle(struct pt_regs *regs)\n{\n\tstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(aic5_domain, 0);\n\tu32 irqnr;\n\tu32 irqstat;\n\n\tirqnr = irq_reg_readl(bgc, AT91_AIC5_IVR);\n\tirqstat = irq_reg_readl(bgc, AT91_AIC5_ISR);\n\n\tif (!irqstat)\n\t\tirq_reg_writel(bgc, 0, AT91_AIC5_EOICR);\n\telse\n\t\tgeneric_handle_domain_irq(aic5_domain, irqnr);\n}\n\nstatic void aic5_mask(struct irq_data *d)\n{\n\tstruct irq_domain *domain = d->domain;\n\tstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\n\t \n\tirq_gc_lock(bgc);\n\tirq_reg_writel(gc, d->hwirq, AT91_AIC5_SSR);\n\tirq_reg_writel(gc, 1, AT91_AIC5_IDCR);\n\tgc->mask_cache &= ~d->mask;\n\tirq_gc_unlock(bgc);\n}\n\nstatic void aic5_unmask(struct irq_data *d)\n{\n\tstruct irq_domain *domain = d->domain;\n\tstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\n\t \n\tirq_gc_lock(bgc);\n\tirq_reg_writel(gc, d->hwirq, AT91_AIC5_SSR);\n\tirq_reg_writel(gc, 1, AT91_AIC5_IECR);\n\tgc->mask_cache |= d->mask;\n\tirq_gc_unlock(bgc);\n}\n\nstatic int aic5_retrigger(struct irq_data *d)\n{\n\tstruct irq_domain *domain = d->domain;\n\tstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\n\n\t \n\tirq_gc_lock(bgc);\n\tirq_reg_writel(bgc, d->hwirq, AT91_AIC5_SSR);\n\tirq_reg_writel(bgc, 1, AT91_AIC5_ISCR);\n\tirq_gc_unlock(bgc);\n\n\treturn 1;\n}\n\nstatic int aic5_set_type(struct irq_data *d, unsigned type)\n{\n\tstruct irq_domain *domain = d->domain;\n\tstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\n\tunsigned int smr;\n\tint ret;\n\n\tirq_gc_lock(bgc);\n\tirq_reg_writel(bgc, d->hwirq, AT91_AIC5_SSR);\n\tsmr = irq_reg_readl(bgc, AT91_AIC5_SMR);\n\tret = aic_common_set_type(d, type, &smr);\n\tif (!ret)\n\t\tirq_reg_writel(bgc, smr, AT91_AIC5_SMR);\n\tirq_gc_unlock(bgc);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic u32 *smr_cache;\n\nstatic void aic5_suspend(struct irq_data *d)\n{\n\tstruct irq_domain *domain = d->domain;\n\tstruct irq_domain_chip_generic *dgc = domain->gc;\n\tstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tint i;\n\tu32 mask;\n\n\tif (smr_cache)\n\t\tfor (i = 0; i < domain->revmap_size; i++) {\n\t\t\tirq_reg_writel(bgc, i, AT91_AIC5_SSR);\n\t\t\tsmr_cache[i] = irq_reg_readl(bgc, AT91_AIC5_SMR);\n\t\t}\n\n\tirq_gc_lock(bgc);\n\tfor (i = 0; i < dgc->irqs_per_chip; i++) {\n\t\tmask = 1 << i;\n\t\tif ((mask & gc->mask_cache) == (mask & gc->wake_active))\n\t\t\tcontinue;\n\n\t\tirq_reg_writel(bgc, i + gc->irq_base, AT91_AIC5_SSR);\n\t\tif (mask & gc->wake_active)\n\t\t\tirq_reg_writel(bgc, 1, AT91_AIC5_IECR);\n\t\telse\n\t\t\tirq_reg_writel(bgc, 1, AT91_AIC5_IDCR);\n\t}\n\tirq_gc_unlock(bgc);\n}\n\nstatic void aic5_resume(struct irq_data *d)\n{\n\tstruct irq_domain *domain = d->domain;\n\tstruct irq_domain_chip_generic *dgc = domain->gc;\n\tstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tint i;\n\tu32 mask;\n\n\tirq_gc_lock(bgc);\n\n\tif (smr_cache) {\n\t\tirq_reg_writel(bgc, 0xffffffff, AT91_AIC5_SPU);\n\t\tfor (i = 0; i < domain->revmap_size; i++) {\n\t\t\tirq_reg_writel(bgc, i, AT91_AIC5_SSR);\n\t\t\tirq_reg_writel(bgc, i, AT91_AIC5_SVR);\n\t\t\tirq_reg_writel(bgc, smr_cache[i], AT91_AIC5_SMR);\n\t\t}\n\t}\n\n\tfor (i = 0; i < dgc->irqs_per_chip; i++) {\n\t\tmask = 1 << i;\n\n\t\tif (!smr_cache &&\n\t\t    ((mask & gc->mask_cache) == (mask & gc->wake_active)))\n\t\t\tcontinue;\n\n\t\tirq_reg_writel(bgc, i + gc->irq_base, AT91_AIC5_SSR);\n\t\tif (mask & gc->mask_cache)\n\t\t\tirq_reg_writel(bgc, 1, AT91_AIC5_IECR);\n\t\telse\n\t\t\tirq_reg_writel(bgc, 1, AT91_AIC5_IDCR);\n\t}\n\tirq_gc_unlock(bgc);\n}\n\nstatic void aic5_pm_shutdown(struct irq_data *d)\n{\n\tstruct irq_domain *domain = d->domain;\n\tstruct irq_domain_chip_generic *dgc = domain->gc;\n\tstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tint i;\n\n\tirq_gc_lock(bgc);\n\tfor (i = 0; i < dgc->irqs_per_chip; i++) {\n\t\tirq_reg_writel(bgc, i + gc->irq_base, AT91_AIC5_SSR);\n\t\tirq_reg_writel(bgc, 1, AT91_AIC5_IDCR);\n\t\tirq_reg_writel(bgc, 1, AT91_AIC5_ICCR);\n\t}\n\tirq_gc_unlock(bgc);\n}\n#else\n#define aic5_suspend\t\tNULL\n#define aic5_resume\t\tNULL\n#define aic5_pm_shutdown\tNULL\n#endif  \n\nstatic void __init aic5_hw_init(struct irq_domain *domain)\n{\n\tstruct irq_chip_generic *gc = irq_get_domain_generic_chip(domain, 0);\n\tint i;\n\n\t \n\tfor (i = 0; i < 8; i++)\n\t\tirq_reg_writel(gc, 0, AT91_AIC5_EOICR);\n\n\t \n\tirq_reg_writel(gc, 0xffffffff, AT91_AIC5_SPU);\n\n\t \n\tirq_reg_writel(gc, 0, AT91_AIC5_DCR);\n\n\t \n\tfor (i = 0; i < domain->revmap_size; i++) {\n\t\tirq_reg_writel(gc, i, AT91_AIC5_SSR);\n\t\tirq_reg_writel(gc, i, AT91_AIC5_SVR);\n\t\tirq_reg_writel(gc, 1, AT91_AIC5_IDCR);\n\t\tirq_reg_writel(gc, 1, AT91_AIC5_ICCR);\n\t}\n}\n\nstatic int aic5_irq_domain_xlate(struct irq_domain *d,\n\t\t\t\t struct device_node *ctrlr,\n\t\t\t\t const u32 *intspec, unsigned int intsize,\n\t\t\t\t irq_hw_number_t *out_hwirq,\n\t\t\t\t unsigned int *out_type)\n{\n\tstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(d, 0);\n\tunsigned long flags;\n\tunsigned smr;\n\tint ret;\n\n\tif (!bgc)\n\t\treturn -EINVAL;\n\n\tret = aic_common_irq_domain_xlate(d, ctrlr, intspec, intsize,\n\t\t\t\t\t  out_hwirq, out_type);\n\tif (ret)\n\t\treturn ret;\n\n\tirq_gc_lock_irqsave(bgc, flags);\n\tirq_reg_writel(bgc, *out_hwirq, AT91_AIC5_SSR);\n\tsmr = irq_reg_readl(bgc, AT91_AIC5_SMR);\n\taic_common_set_priority(intspec[2], &smr);\n\tirq_reg_writel(bgc, smr, AT91_AIC5_SMR);\n\tirq_gc_unlock_irqrestore(bgc, flags);\n\n\treturn ret;\n}\n\nstatic const struct irq_domain_ops aic5_irq_ops = {\n\t.map\t= irq_map_generic_chip,\n\t.xlate\t= aic5_irq_domain_xlate,\n};\n\nstatic void __init sama5d3_aic_irq_fixup(void)\n{\n\taic_common_rtc_irq_fixup();\n}\n\nstatic void __init sam9x60_aic_irq_fixup(void)\n{\n\taic_common_rtc_irq_fixup();\n\taic_common_rtt_irq_fixup();\n}\n\nstatic const struct of_device_id aic5_irq_fixups[] __initconst = {\n\t{ .compatible = \"atmel,sama5d3\", .data = sama5d3_aic_irq_fixup },\n\t{ .compatible = \"atmel,sama5d4\", .data = sama5d3_aic_irq_fixup },\n\t{ .compatible = \"microchip,sam9x60\", .data = sam9x60_aic_irq_fixup },\n\t{   },\n};\n\nstatic int __init aic5_of_init(struct device_node *node,\n\t\t\t       struct device_node *parent,\n\t\t\t       int nirqs)\n{\n\tstruct irq_chip_generic *gc;\n\tstruct irq_domain *domain;\n\tint nchips;\n\tint i;\n\n\tif (nirqs > NR_AIC5_IRQS)\n\t\treturn -EINVAL;\n\n\tif (aic5_domain)\n\t\treturn -EEXIST;\n\n\tdomain = aic_common_of_init(node, &aic5_irq_ops, \"atmel-aic5\",\n\t\t\t\t    nirqs, aic5_irq_fixups);\n\tif (IS_ERR(domain))\n\t\treturn PTR_ERR(domain);\n\n\taic5_domain = domain;\n\tnchips = aic5_domain->revmap_size / 32;\n\tfor (i = 0; i < nchips; i++) {\n\t\tgc = irq_get_domain_generic_chip(domain, i * 32);\n\n\t\tgc->chip_types[0].regs.eoi = AT91_AIC5_EOICR;\n\t\tgc->chip_types[0].chip.irq_mask = aic5_mask;\n\t\tgc->chip_types[0].chip.irq_unmask = aic5_unmask;\n\t\tgc->chip_types[0].chip.irq_retrigger = aic5_retrigger;\n\t\tgc->chip_types[0].chip.irq_set_type = aic5_set_type;\n\t\tgc->chip_types[0].chip.irq_suspend = aic5_suspend;\n\t\tgc->chip_types[0].chip.irq_resume = aic5_resume;\n\t\tgc->chip_types[0].chip.irq_pm_shutdown = aic5_pm_shutdown;\n\t}\n\n\taic5_hw_init(domain);\n\tset_handle_irq(aic5_handle);\n\n\treturn 0;\n}\n\n#define NR_SAMA5D2_IRQS\t\t77\n\nstatic int __init sama5d2_aic5_of_init(struct device_node *node,\n\t\t\t\t       struct device_node *parent)\n{\n#ifdef CONFIG_PM\n\tsmr_cache = kcalloc(DIV_ROUND_UP(NR_SAMA5D2_IRQS, 32) * 32,\n\t\t\t    sizeof(*smr_cache), GFP_KERNEL);\n\tif (!smr_cache)\n\t\treturn -ENOMEM;\n#endif\n\n\treturn aic5_of_init(node, parent, NR_SAMA5D2_IRQS);\n}\nIRQCHIP_DECLARE(sama5d2_aic5, \"atmel,sama5d2-aic\", sama5d2_aic5_of_init);\n\n#define NR_SAMA5D3_IRQS\t\t48\n\nstatic int __init sama5d3_aic5_of_init(struct device_node *node,\n\t\t\t\t       struct device_node *parent)\n{\n\treturn aic5_of_init(node, parent, NR_SAMA5D3_IRQS);\n}\nIRQCHIP_DECLARE(sama5d3_aic5, \"atmel,sama5d3-aic\", sama5d3_aic5_of_init);\n\n#define NR_SAMA5D4_IRQS\t\t68\n\nstatic int __init sama5d4_aic5_of_init(struct device_node *node,\n\t\t\t\t       struct device_node *parent)\n{\n\treturn aic5_of_init(node, parent, NR_SAMA5D4_IRQS);\n}\nIRQCHIP_DECLARE(sama5d4_aic5, \"atmel,sama5d4-aic\", sama5d4_aic5_of_init);\n\n#define NR_SAM9X60_IRQS\t\t50\n\nstatic int __init sam9x60_aic5_of_init(struct device_node *node,\n\t\t\t\t       struct device_node *parent)\n{\n\treturn aic5_of_init(node, parent, NR_SAM9X60_IRQS);\n}\nIRQCHIP_DECLARE(sam9x60_aic5, \"microchip,sam9x60-aic\", sam9x60_aic5_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}