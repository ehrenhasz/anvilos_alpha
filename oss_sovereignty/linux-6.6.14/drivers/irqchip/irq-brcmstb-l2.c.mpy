{
  "module_name": "irq-brcmstb-l2.c",
  "hash_id": "447b68fadce75a70fcab6e73b0d96a703e481040bcfe1241d976fd903d5ebede",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-brcmstb-l2.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME\t\": \" fmt\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n\nstruct brcmstb_intc_init_params {\n\tirq_flow_handler_t handler;\n\tint cpu_status;\n\tint cpu_clear;\n\tint cpu_mask_status;\n\tint cpu_mask_set;\n\tint cpu_mask_clear;\n};\n\n \nstatic const struct brcmstb_intc_init_params l2_edge_intc_init = {\n\t.handler\t\t= handle_edge_irq,\n\t.cpu_status\t\t= 0x00,\n\t.cpu_clear\t\t= 0x08,\n\t.cpu_mask_status\t= 0x0c,\n\t.cpu_mask_set\t\t= 0x10,\n\t.cpu_mask_clear\t\t= 0x14\n};\n\n \nstatic const struct brcmstb_intc_init_params l2_lvl_intc_init = {\n\t.handler\t\t= handle_level_irq,\n\t.cpu_status\t\t= 0x00,\n\t.cpu_clear\t\t= -1,  \n\t.cpu_mask_status\t= 0x04,\n\t.cpu_mask_set\t\t= 0x08,\n\t.cpu_mask_clear\t\t= 0x0C\n};\n\n \nstruct brcmstb_l2_intc_data {\n\tstruct irq_domain *domain;\n\tstruct irq_chip_generic *gc;\n\tint status_offset;\n\tint mask_offset;\n\tbool can_wake;\n\tu32 saved_mask;  \n};\n\n \nstatic void brcmstb_l2_mask_and_ack(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tirq_reg_writel(gc, mask, ct->regs.disable);\n\t*ct->mask_cache &= ~mask;\n\tirq_reg_writel(gc, mask, ct->regs.ack);\n\tirq_gc_unlock(gc);\n}\n\nstatic void brcmstb_l2_intc_irq_handle(struct irq_desc *desc)\n{\n\tstruct brcmstb_l2_intc_data *b = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned int irq;\n\tu32 status;\n\n\tchained_irq_enter(chip, desc);\n\n\tstatus = irq_reg_readl(b->gc, b->status_offset) &\n\t\t~(irq_reg_readl(b->gc, b->mask_offset));\n\n\tif (status == 0) {\n\t\traw_spin_lock(&desc->lock);\n\t\thandle_bad_irq(desc);\n\t\traw_spin_unlock(&desc->lock);\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tirq = ffs(status) - 1;\n\t\tstatus &= ~(1 << irq);\n\t\tgeneric_handle_domain_irq(b->domain, irq);\n\t} while (status);\nout:\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void brcmstb_l2_intc_suspend(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tstruct brcmstb_l2_intc_data *b = gc->private;\n\tunsigned long flags;\n\n\tirq_gc_lock_irqsave(gc, flags);\n\t \n\tb->saved_mask = irq_reg_readl(gc, ct->regs.mask);\n\n\tif (b->can_wake) {\n\t\t \n\t\tirq_reg_writel(gc, ~gc->wake_active, ct->regs.disable);\n\t\tirq_reg_writel(gc, gc->wake_active, ct->regs.enable);\n\t}\n\tirq_gc_unlock_irqrestore(gc, flags);\n}\n\nstatic void brcmstb_l2_intc_resume(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tstruct brcmstb_l2_intc_data *b = gc->private;\n\tunsigned long flags;\n\n\tirq_gc_lock_irqsave(gc, flags);\n\tif (ct->chip.irq_ack) {\n\t\t \n\t\tirq_reg_writel(gc, ~b->saved_mask & ~gc->wake_active,\n\t\t\t\tct->regs.ack);\n\t}\n\n\t \n\tirq_reg_writel(gc, b->saved_mask, ct->regs.disable);\n\tirq_reg_writel(gc, ~b->saved_mask, ct->regs.enable);\n\tirq_gc_unlock_irqrestore(gc, flags);\n}\n\nstatic int __init brcmstb_l2_intc_of_init(struct device_node *np,\n\t\t\t\t\t  struct device_node *parent,\n\t\t\t\t\t  const struct brcmstb_intc_init_params\n\t\t\t\t\t  *init_params)\n{\n\tunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\n\tunsigned int set = 0;\n\tstruct brcmstb_l2_intc_data *data;\n\tstruct irq_chip_type *ct;\n\tint ret;\n\tunsigned int flags;\n\tint parent_irq;\n\tvoid __iomem *base;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_err(\"failed to remap intc L2 registers\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t \n\twritel(0xffffffff, base + init_params->cpu_mask_set);\n\n\t \n\tdata->can_wake = of_property_read_bool(np, \"brcm,irq-can-wake\");\n\tif (!data->can_wake && (init_params->cpu_clear >= 0))\n\t\twritel(0xffffffff, base + init_params->cpu_clear);\n\n\tparent_irq = irq_of_parse_and_map(np, 0);\n\tif (!parent_irq) {\n\t\tpr_err(\"failed to find parent interrupt\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unmap;\n\t}\n\n\tdata->domain = irq_domain_add_linear(np, 32,\n\t\t\t\t&irq_generic_chip_ops, NULL);\n\tif (!data->domain) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n\t \n\tflags = 0;\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\tflags |= IRQ_GC_BE_IO;\n\n\tif (init_params->handler == handle_level_irq)\n\t\tset |= IRQ_LEVEL;\n\n\t \n\tret = irq_alloc_domain_generic_chips(data->domain, 32, 1,\n\t\t\tnp->full_name, init_params->handler, clr, set, flags);\n\tif (ret) {\n\t\tpr_err(\"failed to allocate generic irq chip\\n\");\n\t\tgoto out_free_domain;\n\t}\n\n\t \n\tirq_set_chained_handler_and_data(parent_irq,\n\t\t\t\t\t brcmstb_l2_intc_irq_handle, data);\n\n\tdata->gc = irq_get_domain_generic_chip(data->domain, 0);\n\tdata->gc->reg_base = base;\n\tdata->gc->private = data;\n\tdata->status_offset = init_params->cpu_status;\n\tdata->mask_offset = init_params->cpu_mask_status;\n\n\tct = data->gc->chip_types;\n\n\tif (init_params->cpu_clear >= 0) {\n\t\tct->regs.ack = init_params->cpu_clear;\n\t\tct->chip.irq_ack = irq_gc_ack_set_bit;\n\t\tct->chip.irq_mask_ack = brcmstb_l2_mask_and_ack;\n\t} else {\n\t\t \n\t\tct->chip.irq_mask_ack = irq_gc_mask_disable_reg;\n\t}\n\n\tct->chip.irq_mask = irq_gc_mask_disable_reg;\n\tct->regs.disable = init_params->cpu_mask_set;\n\tct->regs.mask = init_params->cpu_mask_status;\n\n\tct->chip.irq_unmask = irq_gc_unmask_enable_reg;\n\tct->regs.enable = init_params->cpu_mask_clear;\n\n\tct->chip.irq_suspend = brcmstb_l2_intc_suspend;\n\tct->chip.irq_resume = brcmstb_l2_intc_resume;\n\tct->chip.irq_pm_shutdown = brcmstb_l2_intc_suspend;\n\n\tif (data->can_wake) {\n\t\t \n\t\tdata->gc->wake_enabled = 0xffffffff;\n\t\tct->chip.irq_set_wake = irq_gc_set_wake;\n\t\tenable_irq_wake(parent_irq);\n\t}\n\n\tpr_info(\"registered L2 intc (%pOF, parent irq: %d)\\n\", np, parent_irq);\n\n\treturn 0;\n\nout_free_domain:\n\tirq_domain_remove(data->domain);\nout_unmap:\n\tiounmap(base);\nout_free:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int __init brcmstb_l2_edge_intc_of_init(struct device_node *np,\n\tstruct device_node *parent)\n{\n\treturn brcmstb_l2_intc_of_init(np, parent, &l2_edge_intc_init);\n}\n\nstatic int __init brcmstb_l2_lvl_intc_of_init(struct device_node *np,\n\tstruct device_node *parent)\n{\n\treturn brcmstb_l2_intc_of_init(np, parent, &l2_lvl_intc_init);\n}\n\nIRQCHIP_PLATFORM_DRIVER_BEGIN(brcmstb_l2)\nIRQCHIP_MATCH(\"brcm,l2-intc\", brcmstb_l2_edge_intc_of_init)\nIRQCHIP_MATCH(\"brcm,hif-spi-l2-intc\", brcmstb_l2_edge_intc_of_init)\nIRQCHIP_MATCH(\"brcm,upg-aux-aon-l2-intc\", brcmstb_l2_edge_intc_of_init)\nIRQCHIP_MATCH(\"brcm,bcm7271-l2-intc\", brcmstb_l2_lvl_intc_of_init)\nIRQCHIP_PLATFORM_DRIVER_END(brcmstb_l2)\nMODULE_DESCRIPTION(\"Broadcom STB generic L2 interrupt controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}