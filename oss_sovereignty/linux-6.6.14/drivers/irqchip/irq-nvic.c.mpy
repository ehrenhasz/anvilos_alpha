{
  "module_name": "irq-nvic.c",
  "hash_id": "93e25a64f9fbd5988ae1d5bdc6b486a64efd142e673e4f15a3ebc47250798ed3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-nvic.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n\n#include <asm/v7m.h>\n#include <asm/exception.h>\n\n#define NVIC_ISER\t\t0x000\n#define NVIC_ICER\t\t0x080\n#define NVIC_IPR\t\t0x400\n\n#define NVIC_MAX_BANKS\t\t16\n \n#define NVIC_MAX_IRQ\t\t((NVIC_MAX_BANKS - 1) * 32 + 16)\n\nstatic struct irq_domain *nvic_irq_domain;\n\nstatic void __irq_entry nvic_handle_irq(struct pt_regs *regs)\n{\n\tunsigned long icsr = readl_relaxed(BASEADDR_V7M_SCB + V7M_SCB_ICSR);\n\tirq_hw_number_t hwirq = (icsr & V7M_SCB_ICSR_VECTACTIVE) - 16;\n\n\tgeneric_handle_domain_irq(nvic_irq_domain, hwirq);\n}\n\nstatic int nvic_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs, void *arg)\n{\n\tint i, ret;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tstruct irq_fwspec *fwspec = arg;\n\n\tret = irq_domain_translate_onecell(domain, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_map_generic_chip(domain, virq + i, hwirq + i);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops nvic_irq_domain_ops = {\n\t.translate = irq_domain_translate_onecell,\n\t.alloc = nvic_irq_domain_alloc,\n\t.free = irq_domain_free_irqs_top,\n};\n\nstatic int __init nvic_of_init(struct device_node *node,\n\t\t\t       struct device_node *parent)\n{\n\tunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\n\tunsigned int irqs, i, ret, numbanks;\n\tvoid __iomem *nvic_base;\n\n\tnumbanks = (readl_relaxed(V7M_SCS_ICTR) &\n\t\t    V7M_SCS_ICTR_INTLINESNUM_MASK) + 1;\n\n\tnvic_base = of_iomap(node, 0);\n\tif (!nvic_base) {\n\t\tpr_warn(\"unable to map nvic registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tirqs = numbanks * 32;\n\tif (irqs > NVIC_MAX_IRQ)\n\t\tirqs = NVIC_MAX_IRQ;\n\n\tnvic_irq_domain =\n\t\tirq_domain_add_linear(node, irqs, &nvic_irq_domain_ops, NULL);\n\n\tif (!nvic_irq_domain) {\n\t\tpr_warn(\"Failed to allocate irq domain\\n\");\n\t\tiounmap(nvic_base);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(nvic_irq_domain, 32, 1,\n\t\t\t\t\t     \"nvic_irq\", handle_fasteoi_irq,\n\t\t\t\t\t     clr, 0, IRQ_GC_INIT_MASK_CACHE);\n\tif (ret) {\n\t\tpr_warn(\"Failed to allocate irq chips\\n\");\n\t\tirq_domain_remove(nvic_irq_domain);\n\t\tiounmap(nvic_base);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < numbanks; ++i) {\n\t\tstruct irq_chip_generic *gc;\n\n\t\tgc = irq_get_domain_generic_chip(nvic_irq_domain, 32 * i);\n\t\tgc->reg_base = nvic_base + 4 * i;\n\t\tgc->chip_types[0].regs.enable = NVIC_ISER;\n\t\tgc->chip_types[0].regs.disable = NVIC_ICER;\n\t\tgc->chip_types[0].chip.irq_mask = irq_gc_mask_disable_reg;\n\t\tgc->chip_types[0].chip.irq_unmask = irq_gc_unmask_enable_reg;\n\t\t \n\t\tgc->chip_types[0].chip.irq_eoi = irq_gc_noop;\n\n\t\t \n\t\twritel_relaxed(~0, gc->reg_base + NVIC_ICER);\n\t}\n\n\t \n\tfor (i = 0; i < irqs; i += 4)\n\t\twritel_relaxed(0, nvic_base + NVIC_IPR + i);\n\n\tset_handle_irq(nvic_handle_irq);\n\treturn 0;\n}\nIRQCHIP_DECLARE(armv7m_nvic, \"arm,armv7m-nvic\", nvic_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}