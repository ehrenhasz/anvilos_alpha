{
  "module_name": "irq-gic-v3-its-platform-msi.c",
  "hash_id": "aecc06ee169f9e0949e682566d907814c6f02f73931e55f6797ea53618397a88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-gic-v3-its-platform-msi.c",
  "human_readable_source": "\n \n\n#include <linux/acpi_iort.h>\n#include <linux/device.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n\nstatic struct irq_chip its_pmsi_irq_chip = {\n\t.name\t\t\t= \"ITS-pMSI\",\n};\n\nstatic int of_pmsi_get_dev_id(struct irq_domain *domain, struct device *dev,\n\t\t\t\t  u32 *dev_id)\n{\n\tint ret, index = 0;\n\n\t \n\tdo {\n\t\tstruct of_phandle_args args;\n\n\t\tret = of_parse_phandle_with_args(dev->of_node,\n\t\t\t\t\t\t \"msi-parent\", \"#msi-cells\",\n\t\t\t\t\t\t index, &args);\n\t\tif (args.np == irq_domain_get_of_node(domain)) {\n\t\t\tif (WARN_ON(args.args_count != 1))\n\t\t\t\treturn -EINVAL;\n\t\t\t*dev_id = args.args[0];\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t} while (!ret);\n\n\treturn ret;\n}\n\nint __weak iort_pmsi_get_dev_id(struct device *dev, u32 *dev_id)\n{\n\treturn -1;\n}\n\nstatic int its_pmsi_prepare(struct irq_domain *domain, struct device *dev,\n\t\t\t    int nvec, msi_alloc_info_t *info)\n{\n\tstruct msi_domain_info *msi_info;\n\tu32 dev_id;\n\tint ret;\n\n\tmsi_info = msi_get_domain_info(domain->parent);\n\n\tif (dev->of_node)\n\t\tret = of_pmsi_get_dev_id(domain, dev, &dev_id);\n\telse\n\t\tret = iort_pmsi_get_dev_id(dev, &dev_id);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tinfo->scratchpad[0].ul = dev_id;\n\n\t \n\tnvec = max_t(int, 32, roundup_pow_of_two(nvec));\n\treturn msi_info->ops->msi_prepare(domain->parent,\n\t\t\t\t\t  dev, nvec, info);\n}\n\nstatic struct msi_domain_ops its_pmsi_ops = {\n\t.msi_prepare\t= its_pmsi_prepare,\n};\n\nstatic struct msi_domain_info its_pmsi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS),\n\t.ops\t= &its_pmsi_ops,\n\t.chip\t= &its_pmsi_irq_chip,\n};\n\nstatic const struct of_device_id its_device_id[] = {\n\t{\t.compatible\t= \"arm,gic-v3-its\",\t},\n\t{},\n};\n\nstatic int __init its_pmsi_init_one(struct fwnode_handle *fwnode,\n\t\t\t\tconst char *name)\n{\n\tstruct irq_domain *parent;\n\n\tparent = irq_find_matching_fwnode(fwnode, DOMAIN_BUS_NEXUS);\n\tif (!parent || !msi_get_domain_info(parent)) {\n\t\tpr_err(\"%s: unable to locate ITS domain\\n\", name);\n\t\treturn -ENXIO;\n\t}\n\n\tif (!platform_msi_create_irq_domain(fwnode, &its_pmsi_domain_info,\n\t\t\t\t\t    parent)) {\n\t\tpr_err(\"%s: unable to create platform domain\\n\", name);\n\t\treturn -ENXIO;\n\t}\n\n\tpr_info(\"Platform MSI: %s domain created\\n\", name);\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic int __init\nits_pmsi_parse_madt(union acpi_subtable_headers *header,\n\t\t\tconst unsigned long end)\n{\n\tstruct acpi_madt_generic_translator *its_entry;\n\tstruct fwnode_handle *domain_handle;\n\tconst char *node_name;\n\tint err = -ENXIO;\n\n\tits_entry = (struct acpi_madt_generic_translator *)header;\n\tnode_name = kasprintf(GFP_KERNEL, \"ITS@0x%lx\",\n\t\t\t      (long)its_entry->base_address);\n\tdomain_handle = iort_find_domain_token(its_entry->translation_id);\n\tif (!domain_handle) {\n\t\tpr_err(\"%s: Unable to locate ITS domain handle\\n\", node_name);\n\t\tgoto out;\n\t}\n\n\terr = its_pmsi_init_one(domain_handle, node_name);\n\nout:\n\tkfree(node_name);\n\treturn err;\n}\n\nstatic void __init its_pmsi_acpi_init(void)\n{\n\tacpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_TRANSLATOR,\n\t\t\t      its_pmsi_parse_madt, 0);\n}\n#else\nstatic inline void its_pmsi_acpi_init(void) { }\n#endif\n\nstatic void __init its_pmsi_of_init(void)\n{\n\tstruct device_node *np;\n\n\tfor (np = of_find_matching_node(NULL, its_device_id); np;\n\t     np = of_find_matching_node(np, its_device_id)) {\n\t\tif (!of_device_is_available(np))\n\t\t\tcontinue;\n\t\tif (!of_property_read_bool(np, \"msi-controller\"))\n\t\t\tcontinue;\n\n\t\tits_pmsi_init_one(of_node_to_fwnode(np), np->full_name);\n\t}\n}\n\nstatic int __init its_pmsi_init(void)\n{\n\tits_pmsi_of_init();\n\tits_pmsi_acpi_init();\n\treturn 0;\n}\nearly_initcall(its_pmsi_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}