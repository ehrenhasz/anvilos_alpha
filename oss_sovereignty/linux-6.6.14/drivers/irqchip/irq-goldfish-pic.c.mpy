{
  "module_name": "irq-goldfish-pic.c",
  "hash_id": "87efaf12931baad1c3aa2754f076d84d532c1fd1bfc84f15ad42e3c820539ae1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-goldfish-pic.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#define GFPIC_NR_IRQS\t\t\t32\n\n \n#define GFPIC_IRQ_BASE\t\t\t8\n\n#define GFPIC_REG_IRQ_PENDING\t\t0x04\n#define GFPIC_REG_IRQ_DISABLE_ALL\t0x08\n#define GFPIC_REG_IRQ_DISABLE\t\t0x0c\n#define GFPIC_REG_IRQ_ENABLE\t\t0x10\n\nstruct goldfish_pic_data {\n\tvoid __iomem *base;\n\tstruct irq_domain *irq_domain;\n};\n\nstatic void goldfish_pic_cascade(struct irq_desc *desc)\n{\n\tstruct goldfish_pic_data *gfpic = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *host_chip = irq_desc_get_chip(desc);\n\tu32 pending, hwirq;\n\n\tchained_irq_enter(host_chip, desc);\n\n\tpending = readl(gfpic->base + GFPIC_REG_IRQ_PENDING);\n\twhile (pending) {\n\t\thwirq = __fls(pending);\n\t\tgeneric_handle_domain_irq(gfpic->irq_domain, hwirq);\n\t\tpending &= ~(1 << hwirq);\n\t}\n\n\tchained_irq_exit(host_chip, desc);\n}\n\nstatic const struct irq_domain_ops goldfish_irq_domain_ops = {\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic int __init goldfish_pic_of_init(struct device_node *of_node,\n\t\t\t\t       struct device_node *parent)\n{\n\tstruct goldfish_pic_data *gfpic;\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\tunsigned int parent_irq;\n\tint ret = 0;\n\n\tgfpic = kzalloc(sizeof(*gfpic), GFP_KERNEL);\n\tif (!gfpic) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tparent_irq = irq_of_parse_and_map(of_node, 0);\n\tif (!parent_irq) {\n\t\tpr_err(\"Failed to map parent IRQ!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tgfpic->base = of_iomap(of_node, 0);\n\tif (!gfpic->base) {\n\t\tpr_err(\"Failed to map base address!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap_irq;\n\t}\n\n\t \n\twritel(1, gfpic->base + GFPIC_REG_IRQ_DISABLE_ALL);\n\n\tgc = irq_alloc_generic_chip(\"GFPIC\", 1, GFPIC_IRQ_BASE, gfpic->base,\n\t\t\t\t    handle_level_irq);\n\tif (!gc) {\n\t\tpr_err(\"Failed to allocate chip structures!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_iounmap;\n\t}\n\n\tct = gc->chip_types;\n\tct->regs.enable = GFPIC_REG_IRQ_ENABLE;\n\tct->regs.disable = GFPIC_REG_IRQ_DISABLE;\n\tct->chip.irq_unmask = irq_gc_unmask_enable_reg;\n\tct->chip.irq_mask = irq_gc_mask_disable_reg;\n\n\tirq_setup_generic_chip(gc, IRQ_MSK(GFPIC_NR_IRQS), 0,\n\t\t\t       IRQ_NOPROBE | IRQ_LEVEL, 0);\n\n\tgfpic->irq_domain = irq_domain_add_legacy(of_node, GFPIC_NR_IRQS,\n\t\t\t\t\t\t  GFPIC_IRQ_BASE, 0,\n\t\t\t\t\t\t  &goldfish_irq_domain_ops,\n\t\t\t\t\t\t  NULL);\n\tif (!gfpic->irq_domain) {\n\t\tpr_err(\"Failed to add irqdomain!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_destroy_generic_chip;\n\t}\n\n\tirq_set_chained_handler_and_data(parent_irq,\n\t\t\t\t\t goldfish_pic_cascade, gfpic);\n\n\tpr_info(\"Successfully registered.\\n\");\n\treturn 0;\n\nout_destroy_generic_chip:\n\tirq_destroy_generic_chip(gc, IRQ_MSK(GFPIC_NR_IRQS),\n\t\t\t\t IRQ_NOPROBE | IRQ_LEVEL, 0);\nout_iounmap:\n\tiounmap(gfpic->base);\nout_unmap_irq:\n\tirq_dispose_mapping(parent_irq);\nout_free:\n\tkfree(gfpic);\nout_err:\n\tpr_err(\"Failed to initialize! (errno = %d)\\n\", ret);\n\treturn ret;\n}\n\nIRQCHIP_DECLARE(google_gf_pic, \"google,goldfish-pic\", goldfish_pic_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}