{
  "module_name": "irq-aspeed-vic.c",
  "hash_id": "c95252a23bbbdb2785f7fbc1109964399a5496895e228245a575fb9b7ddd0a02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-aspeed-vic.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/syscore_ops.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n\n#include <asm/exception.h>\n#include <asm/irq.h>\n\n \n#define AVIC_IRQ_STATUS\t\t0x00\n#define AVIC_FIQ_STATUS\t\t0x08\n#define AVIC_RAW_STATUS\t\t0x10\n#define AVIC_INT_SELECT\t\t0x18\n#define AVIC_INT_ENABLE\t\t0x20\n#define AVIC_INT_ENABLE_CLR\t0x28\n#define AVIC_INT_TRIGGER\t0x30\n#define AVIC_INT_TRIGGER_CLR\t0x38\n#define AVIC_INT_SENSE\t\t0x40\n#define AVIC_INT_DUAL_EDGE\t0x48\n#define AVIC_INT_EVENT\t\t0x50\n#define AVIC_EDGE_CLR\t\t0x58\n#define AVIC_EDGE_STATUS\t0x60\n\n#define NUM_IRQS\t\t64\n\nstruct aspeed_vic {\n\tvoid __iomem\t\t*base;\n\tu32\t\t\tedge_sources[2];\n\tstruct irq_domain\t*dom;\n};\nstatic struct aspeed_vic *system_avic;\n\nstatic void vic_init_hw(struct aspeed_vic *vic)\n{\n\tu32 sense;\n\n\t \n\twritel(0xffffffff, vic->base + AVIC_INT_ENABLE_CLR);\n\twritel(0xffffffff, vic->base + AVIC_INT_ENABLE_CLR + 4);\n\n\t \n\twritel(0xffffffff, vic->base + AVIC_INT_TRIGGER_CLR);\n\twritel(0xffffffff, vic->base + AVIC_INT_TRIGGER_CLR + 4);\n\n\t \n\twritel(0, vic->base + AVIC_INT_SELECT);\n\twritel(0, vic->base + AVIC_INT_SELECT + 4);\n\n\t \n\tsense = readl(vic->base + AVIC_INT_SENSE);\n\tvic->edge_sources[0] = ~sense;\n\tsense = readl(vic->base + AVIC_INT_SENSE + 4);\n\tvic->edge_sources[1] = ~sense;\n\n\t \n\twritel(0xffffffff, vic->base + AVIC_EDGE_CLR);\n\twritel(0xffffffff, vic->base + AVIC_EDGE_CLR + 4);\n}\n\nstatic void __exception_irq_entry avic_handle_irq(struct pt_regs *regs)\n{\n\tstruct aspeed_vic *vic = system_avic;\n\tu32 stat, irq;\n\n\tfor (;;) {\n\t\tirq = 0;\n\t\tstat = readl_relaxed(vic->base + AVIC_IRQ_STATUS);\n\t\tif (!stat) {\n\t\t\tstat = readl_relaxed(vic->base + AVIC_IRQ_STATUS + 4);\n\t\t\tirq = 32;\n\t\t}\n\t\tif (stat == 0)\n\t\t\tbreak;\n\t\tirq += ffs(stat) - 1;\n\t\tgeneric_handle_domain_irq(vic->dom, irq);\n\t}\n}\n\nstatic void avic_ack_irq(struct irq_data *d)\n{\n\tstruct aspeed_vic *vic = irq_data_get_irq_chip_data(d);\n\tunsigned int sidx = d->hwirq >> 5;\n\tunsigned int sbit = 1u << (d->hwirq & 0x1f);\n\n\t \n\tif (vic->edge_sources[sidx] & sbit)\n\t\twritel(sbit, vic->base + AVIC_EDGE_CLR + sidx * 4);\n}\n\nstatic void avic_mask_irq(struct irq_data *d)\n{\n\tstruct aspeed_vic *vic = irq_data_get_irq_chip_data(d);\n\tunsigned int sidx = d->hwirq >> 5;\n\tunsigned int sbit = 1u << (d->hwirq & 0x1f);\n\n\twritel(sbit, vic->base + AVIC_INT_ENABLE_CLR + sidx * 4);\n}\n\nstatic void avic_unmask_irq(struct irq_data *d)\n{\n\tstruct aspeed_vic *vic = irq_data_get_irq_chip_data(d);\n\tunsigned int sidx = d->hwirq >> 5;\n\tunsigned int sbit = 1u << (d->hwirq & 0x1f);\n\n\twritel(sbit, vic->base + AVIC_INT_ENABLE + sidx * 4);\n}\n\n \nstatic void avic_mask_ack_irq(struct irq_data *d)\n{\n\tstruct aspeed_vic *vic = irq_data_get_irq_chip_data(d);\n\tunsigned int sidx = d->hwirq >> 5;\n\tunsigned int sbit = 1u << (d->hwirq & 0x1f);\n\n\t \n\twritel(sbit, vic->base + AVIC_INT_ENABLE_CLR + sidx * 4);\n\n\t \n\tif (vic->edge_sources[sidx] & sbit)\n\t\twritel(sbit, vic->base + AVIC_EDGE_CLR + sidx * 4);\n}\n\nstatic struct irq_chip avic_chip = {\n\t.name\t\t= \"AVIC\",\n\t.irq_ack\t= avic_ack_irq,\n\t.irq_mask\t= avic_mask_irq,\n\t.irq_unmask\t= avic_unmask_irq,\n\t.irq_mask_ack\t= avic_mask_ack_irq,\n};\n\nstatic int avic_map(struct irq_domain *d, unsigned int irq,\n\t\t    irq_hw_number_t hwirq)\n{\n\tstruct aspeed_vic *vic = d->host_data;\n\tunsigned int sidx = hwirq >> 5;\n\tunsigned int sbit = 1u << (hwirq & 0x1f);\n\n\t \n\tif (sidx > 1)\n\t\treturn -EPERM;\n\n\tif (vic->edge_sources[sidx] & sbit)\n\t\tirq_set_chip_and_handler(irq, &avic_chip, handle_edge_irq);\n\telse\n\t\tirq_set_chip_and_handler(irq, &avic_chip, handle_level_irq);\n\tirq_set_chip_data(irq, vic);\n\tirq_set_probe(irq);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops avic_dom_ops = {\n\t.map = avic_map,\n\t.xlate = irq_domain_xlate_onetwocell,\n};\n\nstatic int __init avic_of_init(struct device_node *node,\n\t\t\t       struct device_node *parent)\n{\n\tvoid __iomem *regs;\n\tstruct aspeed_vic *vic;\n\n\tif (WARN(parent, \"non-root Aspeed VIC not supported\"))\n\t\treturn -EINVAL;\n\tif (WARN(system_avic, \"duplicate Aspeed VIC not supported\"))\n\t\treturn -EINVAL;\n\n\tregs = of_iomap(node, 0);\n\tif (WARN_ON(!regs))\n\t\treturn -EIO;\n\n\tvic = kzalloc(sizeof(struct aspeed_vic), GFP_KERNEL);\n\tif (WARN_ON(!vic)) {\n\t\tiounmap(regs);\n\t\treturn -ENOMEM;\n\t}\n\tvic->base = regs;\n\n\t \n\tvic_init_hw(vic);\n\n\t \n\tsystem_avic = vic;\n\tset_handle_irq(avic_handle_irq);\n\n\t \n\tvic->dom = irq_domain_add_simple(node, NUM_IRQS, 0,\n\t\t\t\t\t &avic_dom_ops, vic);\n\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(ast2400_vic, \"aspeed,ast2400-vic\", avic_of_init);\nIRQCHIP_DECLARE(ast2500_vic, \"aspeed,ast2500-vic\", avic_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}