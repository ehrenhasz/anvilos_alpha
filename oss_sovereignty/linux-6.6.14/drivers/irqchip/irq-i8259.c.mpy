{
  "module_name": "irq-i8259.c",
  "hash_id": "2d0797a2db61555b03ea26bef3b858cf9ee06d0d9b12ed1721f8bf83ed9ee493",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-i8259.c",
  "human_readable_source": " \n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/of_irq.h>\n#include <linux/spinlock.h>\n#include <linux/syscore_ops.h>\n#include <linux/irq.h>\n\n#include <asm/i8259.h>\n#include <asm/io.h>\n\n \n\nstatic int i8259A_auto_eoi = -1;\nDEFINE_RAW_SPINLOCK(i8259A_lock);\nstatic void disable_8259A_irq(struct irq_data *d);\nstatic void enable_8259A_irq(struct irq_data *d);\nstatic void mask_and_ack_8259A(struct irq_data *d);\nstatic void init_8259A(int auto_eoi);\nstatic int (*i8259_poll)(void) = i8259_irq;\n\nstatic struct irq_chip i8259A_chip = {\n\t.name\t\t\t= \"XT-PIC\",\n\t.irq_mask\t\t= disable_8259A_irq,\n\t.irq_disable\t\t= disable_8259A_irq,\n\t.irq_unmask\t\t= enable_8259A_irq,\n\t.irq_mask_ack\t\t= mask_and_ack_8259A,\n};\n\n \n\nvoid i8259_set_poll(int (*poll)(void))\n{\n\ti8259_poll = poll;\n}\n\n \nstatic unsigned int cached_irq_mask = 0xffff;\n\n#define cached_master_mask\t(cached_irq_mask)\n#define cached_slave_mask\t(cached_irq_mask >> 8)\n\nstatic void disable_8259A_irq(struct irq_data *d)\n{\n\tunsigned int mask, irq = d->irq - I8259A_IRQ_BASE;\n\tunsigned long flags;\n\n\tmask = 1 << irq;\n\traw_spin_lock_irqsave(&i8259A_lock, flags);\n\tcached_irq_mask |= mask;\n\tif (irq & 8)\n\t\toutb(cached_slave_mask, PIC_SLAVE_IMR);\n\telse\n\t\toutb(cached_master_mask, PIC_MASTER_IMR);\n\traw_spin_unlock_irqrestore(&i8259A_lock, flags);\n}\n\nstatic void enable_8259A_irq(struct irq_data *d)\n{\n\tunsigned int mask, irq = d->irq - I8259A_IRQ_BASE;\n\tunsigned long flags;\n\n\tmask = ~(1 << irq);\n\traw_spin_lock_irqsave(&i8259A_lock, flags);\n\tcached_irq_mask &= mask;\n\tif (irq & 8)\n\t\toutb(cached_slave_mask, PIC_SLAVE_IMR);\n\telse\n\t\toutb(cached_master_mask, PIC_MASTER_IMR);\n\traw_spin_unlock_irqrestore(&i8259A_lock, flags);\n}\n\nvoid make_8259A_irq(unsigned int irq)\n{\n\tdisable_irq_nosync(irq);\n\tirq_set_chip_and_handler(irq, &i8259A_chip, handle_level_irq);\n\tenable_irq(irq);\n}\n\n \nstatic inline int i8259A_irq_real(unsigned int irq)\n{\n\tint value;\n\tint irqmask = 1 << irq;\n\n\tif (irq < 8) {\n\t\toutb(0x0B, PIC_MASTER_CMD);\t \n\t\tvalue = inb(PIC_MASTER_CMD) & irqmask;\n\t\toutb(0x0A, PIC_MASTER_CMD);\t \n\t\treturn value;\n\t}\n\toutb(0x0B, PIC_SLAVE_CMD);\t \n\tvalue = inb(PIC_SLAVE_CMD) & (irqmask >> 8);\n\toutb(0x0A, PIC_SLAVE_CMD);\t \n\treturn value;\n}\n\n \nstatic void mask_and_ack_8259A(struct irq_data *d)\n{\n\tunsigned int irqmask, irq = d->irq - I8259A_IRQ_BASE;\n\tunsigned long flags;\n\n\tirqmask = 1 << irq;\n\traw_spin_lock_irqsave(&i8259A_lock, flags);\n\t \n\tif (cached_irq_mask & irqmask)\n\t\tgoto spurious_8259A_irq;\n\tcached_irq_mask |= irqmask;\n\nhandle_real_irq:\n\tif (irq & 8) {\n\t\tinb(PIC_SLAVE_IMR);\t \n\t\toutb(cached_slave_mask, PIC_SLAVE_IMR);\n\t\toutb(0x60+(irq&7), PIC_SLAVE_CMD); \n\t\toutb(0x60+PIC_CASCADE_IR, PIC_MASTER_CMD);  \n\t} else {\n\t\tinb(PIC_MASTER_IMR);\t \n\t\toutb(cached_master_mask, PIC_MASTER_IMR);\n\t\toutb(0x60+irq, PIC_MASTER_CMD);  \n\t}\n\traw_spin_unlock_irqrestore(&i8259A_lock, flags);\n\treturn;\n\nspurious_8259A_irq:\n\t \n\tif (i8259A_irq_real(irq))\n\t\t \n\t\tgoto handle_real_irq;\n\n\t{\n\t\tstatic int spurious_irq_mask;\n\t\t \n\t\tif (!(spurious_irq_mask & irqmask)) {\n\t\t\tprintk(KERN_DEBUG \"spurious 8259A interrupt: IRQ%d.\\n\", irq);\n\t\t\tspurious_irq_mask |= irqmask;\n\t\t}\n\t\tatomic_inc(&irq_err_count);\n\t\t \n\t\tgoto handle_real_irq;\n\t}\n}\n\nstatic void i8259A_resume(void)\n{\n\tif (i8259A_auto_eoi >= 0)\n\t\tinit_8259A(i8259A_auto_eoi);\n}\n\nstatic void i8259A_shutdown(void)\n{\n\t \n\tif (i8259A_auto_eoi >= 0) {\n\t\toutb(0xff, PIC_MASTER_IMR);\t \n\t\toutb(0xff, PIC_SLAVE_IMR);\t \n\t}\n}\n\nstatic struct syscore_ops i8259_syscore_ops = {\n\t.resume = i8259A_resume,\n\t.shutdown = i8259A_shutdown,\n};\n\nstatic void init_8259A(int auto_eoi)\n{\n\tunsigned long flags;\n\n\ti8259A_auto_eoi = auto_eoi;\n\n\traw_spin_lock_irqsave(&i8259A_lock, flags);\n\n\toutb(0xff, PIC_MASTER_IMR);\t \n\toutb(0xff, PIC_SLAVE_IMR);\t \n\n\t \n\toutb_p(0x11, PIC_MASTER_CMD);\t \n\toutb_p(I8259A_IRQ_BASE + 0, PIC_MASTER_IMR);\t \n\toutb_p(1U << PIC_CASCADE_IR, PIC_MASTER_IMR);\t \n\tif (auto_eoi)\t \n\t\toutb_p(MASTER_ICW4_DEFAULT | PIC_ICW4_AEOI, PIC_MASTER_IMR);\n\telse\t\t \n\t\toutb_p(MASTER_ICW4_DEFAULT, PIC_MASTER_IMR);\n\n\toutb_p(0x11, PIC_SLAVE_CMD);\t \n\toutb_p(I8259A_IRQ_BASE + 8, PIC_SLAVE_IMR);\t \n\toutb_p(PIC_CASCADE_IR, PIC_SLAVE_IMR);\t \n\toutb_p(SLAVE_ICW4_DEFAULT, PIC_SLAVE_IMR);  \n\tif (auto_eoi)\n\t\t \n\t\ti8259A_chip.irq_mask_ack = disable_8259A_irq;\n\telse\n\t\ti8259A_chip.irq_mask_ack = mask_and_ack_8259A;\n\n\tudelay(100);\t\t \n\n\toutb(cached_master_mask, PIC_MASTER_IMR);  \n\toutb(cached_slave_mask, PIC_SLAVE_IMR);\t   \n\n\traw_spin_unlock_irqrestore(&i8259A_lock, flags);\n}\n\nstatic struct resource pic1_io_resource = {\n\t.name = \"pic1\",\n\t.start = PIC_MASTER_CMD,\n\t.end = PIC_MASTER_IMR,\n\t.flags = IORESOURCE_IO | IORESOURCE_BUSY\n};\n\nstatic struct resource pic2_io_resource = {\n\t.name = \"pic2\",\n\t.start = PIC_SLAVE_CMD,\n\t.end = PIC_SLAVE_IMR,\n\t.flags = IORESOURCE_IO | IORESOURCE_BUSY\n};\n\nstatic int i8259A_irq_domain_map(struct irq_domain *d, unsigned int virq,\n\t\t\t\t irq_hw_number_t hw)\n{\n\tirq_set_chip_and_handler(virq, &i8259A_chip, handle_level_irq);\n\tirq_set_probe(virq);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops i8259A_ops = {\n\t.map = i8259A_irq_domain_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\n \nstruct irq_domain * __init __init_i8259_irqs(struct device_node *node)\n{\n\t \n\tint irq = I8259A_IRQ_BASE + PIC_CASCADE_IR;\n\tstruct irq_domain *domain;\n\n\tinsert_resource(&ioport_resource, &pic1_io_resource);\n\tinsert_resource(&ioport_resource, &pic2_io_resource);\n\n\tinit_8259A(0);\n\n\tdomain = irq_domain_add_legacy(node, 16, I8259A_IRQ_BASE, 0,\n\t\t\t\t       &i8259A_ops, NULL);\n\tif (!domain)\n\t\tpanic(\"Failed to add i8259 IRQ domain\");\n\n\tif (request_irq(irq, no_action, IRQF_NO_THREAD, \"cascade\", NULL))\n\t\tpr_err(\"Failed to register cascade interrupt\\n\");\n\tregister_syscore_ops(&i8259_syscore_ops);\n\treturn domain;\n}\n\nvoid __init init_i8259_irqs(void)\n{\n\t__init_i8259_irqs(NULL);\n}\n\nstatic void i8259_irq_dispatch(struct irq_desc *desc)\n{\n\tstruct irq_domain *domain = irq_desc_get_handler_data(desc);\n\tint hwirq = i8259_poll();\n\n\tif (hwirq < 0)\n\t\treturn;\n\n\tgeneric_handle_domain_irq(domain, hwirq);\n}\n\nstatic int __init i8259_of_init(struct device_node *node, struct device_node *parent)\n{\n\tstruct irq_domain *domain;\n\tunsigned int parent_irq;\n\n\tdomain = __init_i8259_irqs(node);\n\n\tparent_irq = irq_of_parse_and_map(node, 0);\n\tif (!parent_irq) {\n\t\tpr_err(\"Failed to map i8259 parent IRQ\\n\");\n\t\tirq_domain_remove(domain);\n\t\treturn -ENODEV;\n\t}\n\n\tirq_set_chained_handler_and_data(parent_irq, i8259_irq_dispatch,\n\t\t\t\t\t domain);\n\treturn 0;\n}\nIRQCHIP_DECLARE(i8259, \"intel,i8259\", i8259_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}