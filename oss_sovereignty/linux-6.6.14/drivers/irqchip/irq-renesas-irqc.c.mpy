{
  "module_name": "irq-renesas-irqc.c",
  "hash_id": "71052938427789b3de824e7eab4fedbdcff955285a50545149095afeb066f462",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-renesas-irqc.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n\n#define IRQC_IRQ_MAX\t32\t \n\n#define IRQC_REQ_STS\t0x00\t \n#define IRQC_EN_STS\t0x04\t \n#define IRQC_EN_SET\t0x08\t \n#define IRQC_INT_CPU_BASE(n) (0x000 + ((n) * 0x10))\n\t\t\t\t \n#define DETECT_STATUS\t0x100\t \n#define MONITOR\t\t0x104\t \n#define HLVL_STS\t0x108\t \n#define LLVL_STS\t0x10c\t \n#define S_R_EDGE_STS\t0x110\t \n#define S_F_EDGE_STS\t0x114\t \n#define A_R_EDGE_STS\t0x118\t \n#define A_F_EDGE_STS\t0x11c\t \n#define CHTEN_STS\t0x120\t \n#define IRQC_CONFIG(n) (0x180 + ((n) * 0x04))\n\t\t\t\t \n\nstruct irqc_irq {\n\tint hw_irq;\n\tint requested_irq;\n\tstruct irqc_priv *p;\n};\n\nstruct irqc_priv {\n\tvoid __iomem *iomem;\n\tvoid __iomem *cpu_int_base;\n\tstruct irqc_irq irq[IRQC_IRQ_MAX];\n\tunsigned int number_of_irqs;\n\tstruct device *dev;\n\tstruct irq_chip_generic *gc;\n\tstruct irq_domain *irq_domain;\n\tatomic_t wakeup_path;\n};\n\nstatic struct irqc_priv *irq_data_to_priv(struct irq_data *data)\n{\n\treturn data->domain->host_data;\n}\n\nstatic void irqc_dbg(struct irqc_irq *i, char *str)\n{\n\tdev_dbg(i->p->dev, \"%s (%d:%d)\\n\", str, i->requested_irq, i->hw_irq);\n}\n\nstatic unsigned char irqc_sense[IRQ_TYPE_SENSE_MASK + 1] = {\n\t[IRQ_TYPE_LEVEL_LOW]\t= 0x01,\n\t[IRQ_TYPE_LEVEL_HIGH]\t= 0x02,\n\t[IRQ_TYPE_EDGE_FALLING]\t= 0x04,\t \n\t[IRQ_TYPE_EDGE_RISING]\t= 0x08,\t \n\t[IRQ_TYPE_EDGE_BOTH]\t= 0x0c,\t \n};\n\nstatic int irqc_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct irqc_priv *p = irq_data_to_priv(d);\n\tint hw_irq = irqd_to_hwirq(d);\n\tunsigned char value = irqc_sense[type & IRQ_TYPE_SENSE_MASK];\n\tu32 tmp;\n\n\tirqc_dbg(&p->irq[hw_irq], \"sense\");\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\ttmp = ioread32(p->iomem + IRQC_CONFIG(hw_irq));\n\ttmp &= ~0x3f;\n\ttmp |= value;\n\tiowrite32(tmp, p->iomem + IRQC_CONFIG(hw_irq));\n\treturn 0;\n}\n\nstatic int irqc_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct irqc_priv *p = irq_data_to_priv(d);\n\tint hw_irq = irqd_to_hwirq(d);\n\n\tirq_set_irq_wake(p->irq[hw_irq].requested_irq, on);\n\tif (on)\n\t\tatomic_inc(&p->wakeup_path);\n\telse\n\t\tatomic_dec(&p->wakeup_path);\n\n\treturn 0;\n}\n\nstatic irqreturn_t irqc_irq_handler(int irq, void *dev_id)\n{\n\tstruct irqc_irq *i = dev_id;\n\tstruct irqc_priv *p = i->p;\n\tu32 bit = BIT(i->hw_irq);\n\n\tirqc_dbg(i, \"demux1\");\n\n\tif (ioread32(p->iomem + DETECT_STATUS) & bit) {\n\t\tiowrite32(bit, p->iomem + DETECT_STATUS);\n\t\tirqc_dbg(i, \"demux2\");\n\t\tgeneric_handle_domain_irq(p->irq_domain, i->hw_irq);\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic int irqc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst char *name = dev_name(dev);\n\tstruct irqc_priv *p;\n\tint ret;\n\tint k;\n\n\tp = devm_kzalloc(dev, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->dev = dev;\n\tplatform_set_drvdata(pdev, p);\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\t \n\tfor (k = 0; k < IRQC_IRQ_MAX; k++) {\n\t\tret = platform_get_irq_optional(pdev, k);\n\t\tif (ret == -ENXIO)\n\t\t\tbreak;\n\t\tif (ret < 0)\n\t\t\tgoto err_runtime_pm_disable;\n\n\t\tp->irq[k].p = p;\n\t\tp->irq[k].hw_irq = k;\n\t\tp->irq[k].requested_irq = ret;\n\t}\n\n\tp->number_of_irqs = k;\n\tif (p->number_of_irqs < 1) {\n\t\tdev_err(dev, \"not enough IRQ resources\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_runtime_pm_disable;\n\t}\n\n\t \n\tp->iomem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(p->iomem)) {\n\t\tret = PTR_ERR(p->iomem);\n\t\tgoto err_runtime_pm_disable;\n\t}\n\n\tp->cpu_int_base = p->iomem + IRQC_INT_CPU_BASE(0);  \n\n\tp->irq_domain = irq_domain_add_linear(dev->of_node, p->number_of_irqs,\n\t\t\t\t\t      &irq_generic_chip_ops, p);\n\tif (!p->irq_domain) {\n\t\tret = -ENXIO;\n\t\tdev_err(dev, \"cannot initialize irq domain\\n\");\n\t\tgoto err_runtime_pm_disable;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(p->irq_domain, p->number_of_irqs,\n\t\t\t\t\t     1, \"irqc\", handle_level_irq,\n\t\t\t\t\t     0, 0, IRQ_GC_INIT_NESTED_LOCK);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot allocate generic chip\\n\");\n\t\tgoto err_remove_domain;\n\t}\n\n\tp->gc = irq_get_domain_generic_chip(p->irq_domain, 0);\n\tp->gc->reg_base = p->cpu_int_base;\n\tp->gc->chip_types[0].regs.enable = IRQC_EN_SET;\n\tp->gc->chip_types[0].regs.disable = IRQC_EN_STS;\n\tp->gc->chip_types[0].chip.irq_mask = irq_gc_mask_disable_reg;\n\tp->gc->chip_types[0].chip.irq_unmask = irq_gc_unmask_enable_reg;\n\tp->gc->chip_types[0].chip.irq_set_type\t= irqc_irq_set_type;\n\tp->gc->chip_types[0].chip.irq_set_wake\t= irqc_irq_set_wake;\n\tp->gc->chip_types[0].chip.flags\t= IRQCHIP_MASK_ON_SUSPEND;\n\n\tirq_domain_set_pm_device(p->irq_domain, dev);\n\n\t \n\tfor (k = 0; k < p->number_of_irqs; k++) {\n\t\tif (devm_request_irq(dev, p->irq[k].requested_irq,\n\t\t\t\t     irqc_irq_handler, 0, name, &p->irq[k])) {\n\t\t\tdev_err(dev, \"failed to request IRQ\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto err_remove_domain;\n\t\t}\n\t}\n\n\tdev_info(dev, \"driving %d irqs\\n\", p->number_of_irqs);\n\n\treturn 0;\n\nerr_remove_domain:\n\tirq_domain_remove(p->irq_domain);\nerr_runtime_pm_disable:\n\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic int irqc_remove(struct platform_device *pdev)\n{\n\tstruct irqc_priv *p = platform_get_drvdata(pdev);\n\n\tirq_domain_remove(p->irq_domain);\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\treturn 0;\n}\n\nstatic int __maybe_unused irqc_suspend(struct device *dev)\n{\n\tstruct irqc_priv *p = dev_get_drvdata(dev);\n\n\tif (atomic_read(&p->wakeup_path))\n\t\tdevice_set_wakeup_path(dev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(irqc_pm_ops, irqc_suspend, NULL);\n\nstatic const struct of_device_id irqc_dt_ids[] = {\n\t{ .compatible = \"renesas,irqc\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, irqc_dt_ids);\n\nstatic struct platform_driver irqc_device_driver = {\n\t.probe\t\t= irqc_probe,\n\t.remove\t\t= irqc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"renesas_irqc\",\n\t\t.of_match_table\t= irqc_dt_ids,\n\t\t.pm\t= &irqc_pm_ops,\n\t}\n};\n\nstatic int __init irqc_init(void)\n{\n\treturn platform_driver_register(&irqc_device_driver);\n}\npostcore_initcall(irqc_init);\n\nstatic void __exit irqc_exit(void)\n{\n\tplatform_driver_unregister(&irqc_device_driver);\n}\nmodule_exit(irqc_exit);\n\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_DESCRIPTION(\"Renesas IRQC Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}