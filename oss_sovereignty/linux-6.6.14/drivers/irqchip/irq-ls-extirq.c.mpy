{
  "module_name": "irq-ls-extirq.c",
  "hash_id": "3e1016163c0f15ce937aabbe04bc3eff583fddc8f4d25e9385760cf86b90a357",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-ls-extirq.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt) \"irq-ls-extirq: \" fmt\n\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/interrupt-controller/arm-gic.h>\n\n#define MAXIRQ 12\n#define LS1021A_SCFGREVCR 0x200\n\nstruct ls_extirq_data {\n\tvoid __iomem\t\t*intpcr;\n\traw_spinlock_t\t\tlock;\n\tbool\t\t\tbig_endian;\n\tbool\t\t\tis_ls1021a_or_ls1043a;\n\tu32\t\t\tnirq;\n\tstruct irq_fwspec\tmap[MAXIRQ];\n};\n\nstatic void ls_extirq_intpcr_rmw(struct ls_extirq_data *priv, u32 mask,\n\t\t\t\t u32 value)\n{\n\tu32 intpcr;\n\n\t \n\traw_spin_lock(&priv->lock);\n\n\tif (priv->big_endian)\n\t\tintpcr = ioread32be(priv->intpcr);\n\telse\n\t\tintpcr = ioread32(priv->intpcr);\n\n\tintpcr &= ~mask;\n\tintpcr |= value;\n\n\tif (priv->big_endian)\n\t\tiowrite32be(intpcr, priv->intpcr);\n\telse\n\t\tiowrite32(intpcr, priv->intpcr);\n\n\traw_spin_unlock(&priv->lock);\n}\n\nstatic int\nls_extirq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct ls_extirq_data *priv = data->chip_data;\n\tirq_hw_number_t hwirq = data->hwirq;\n\tu32 value, mask;\n\n\tif (priv->is_ls1021a_or_ls1043a)\n\t\tmask = 1U << (31 - hwirq);\n\telse\n\t\tmask = 1U << hwirq;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\ttype = IRQ_TYPE_LEVEL_HIGH;\n\t\tvalue = mask;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\ttype = IRQ_TYPE_EDGE_RISING;\n\t\tvalue = mask;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tvalue = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tls_extirq_intpcr_rmw(priv, mask, value);\n\n\treturn irq_chip_set_type_parent(data, type);\n}\n\nstatic struct irq_chip ls_extirq_chip = {\n\t.name\t\t\t= \"ls-extirq\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_type\t\t= ls_extirq_set_type,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.flags                  = IRQCHIP_SET_TYPE_MASKED | IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic int\nls_extirq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t       unsigned int nr_irqs, void *arg)\n{\n\tstruct ls_extirq_data *priv = domain->host_data;\n\tstruct irq_fwspec *fwspec = arg;\n\tirq_hw_number_t hwirq;\n\n\tif (fwspec->param_count != 2)\n\t\treturn -EINVAL;\n\n\thwirq = fwspec->param[0];\n\tif (hwirq >= priv->nirq)\n\t\treturn -EINVAL;\n\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, &ls_extirq_chip,\n\t\t\t\t      priv);\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, 1, &priv->map[hwirq]);\n}\n\nstatic const struct irq_domain_ops extirq_domain_ops = {\n\t.xlate\t\t= irq_domain_xlate_twocell,\n\t.alloc\t\t= ls_extirq_domain_alloc,\n\t.free\t\t= irq_domain_free_irqs_common,\n};\n\nstatic int\nls_extirq_parse_map(struct ls_extirq_data *priv, struct device_node *node)\n{\n\tconst __be32 *map;\n\tu32 mapsize;\n\tint ret;\n\n\tmap = of_get_property(node, \"interrupt-map\", &mapsize);\n\tif (!map)\n\t\treturn -ENOENT;\n\tif (mapsize % sizeof(*map))\n\t\treturn -EINVAL;\n\tmapsize /= sizeof(*map);\n\n\twhile (mapsize) {\n\t\tstruct device_node *ipar;\n\t\tu32 hwirq, intsize, j;\n\n\t\tif (mapsize < 3)\n\t\t\treturn -EINVAL;\n\t\thwirq = be32_to_cpup(map);\n\t\tif (hwirq >= MAXIRQ)\n\t\t\treturn -EINVAL;\n\t\tpriv->nirq = max(priv->nirq, hwirq + 1);\n\n\t\tipar = of_find_node_by_phandle(be32_to_cpup(map + 2));\n\t\tmap += 3;\n\t\tmapsize -= 3;\n\t\tif (!ipar)\n\t\t\treturn -EINVAL;\n\t\tpriv->map[hwirq].fwnode = &ipar->fwnode;\n\t\tret = of_property_read_u32(ipar, \"#interrupt-cells\", &intsize);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (intsize > mapsize)\n\t\t\treturn -EINVAL;\n\n\t\tpriv->map[hwirq].param_count = intsize;\n\t\tfor (j = 0; j < intsize; ++j)\n\t\t\tpriv->map[hwirq].param[j] = be32_to_cpup(map++);\n\t\tmapsize -= intsize;\n\t}\n\treturn 0;\n}\n\nstatic int __init\nls_extirq_of_init(struct device_node *node, struct device_node *parent)\n{\n\tstruct irq_domain *domain, *parent_domain;\n\tstruct ls_extirq_data *priv;\n\tint ret;\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tpr_err(\"Cannot find parent domain\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_irq_find_host;\n\t}\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_priv;\n\t}\n\n\t \n\tpriv->intpcr = of_iomap(node, 0);\n\tif (!priv->intpcr) {\n\t\tpr_err(\"Cannot ioremap OF node %pOF\\n\", node);\n\t\tret = -ENOMEM;\n\t\tgoto err_iomap;\n\t}\n\n\tret = ls_extirq_parse_map(priv, node);\n\tif (ret)\n\t\tgoto err_parse_map;\n\n\tpriv->big_endian = of_device_is_big_endian(node->parent);\n\tpriv->is_ls1021a_or_ls1043a = of_device_is_compatible(node, \"fsl,ls1021a-extirq\") ||\n\t\t\t\t      of_device_is_compatible(node, \"fsl,ls1043a-extirq\");\n\traw_spin_lock_init(&priv->lock);\n\n\tdomain = irq_domain_add_hierarchy(parent_domain, 0, priv->nirq, node,\n\t\t\t\t\t  &extirq_domain_ops, priv);\n\tif (!domain) {\n\t\tret = -ENOMEM;\n\t\tgoto err_add_hierarchy;\n\t}\n\n\treturn 0;\n\nerr_add_hierarchy:\nerr_parse_map:\n\tiounmap(priv->intpcr);\nerr_iomap:\n\tkfree(priv);\nerr_alloc_priv:\nerr_irq_find_host:\n\treturn ret;\n}\n\nIRQCHIP_DECLARE(ls1021a_extirq, \"fsl,ls1021a-extirq\", ls_extirq_of_init);\nIRQCHIP_DECLARE(ls1043a_extirq, \"fsl,ls1043a-extirq\", ls_extirq_of_init);\nIRQCHIP_DECLARE(ls1088a_extirq, \"fsl,ls1088a-extirq\", ls_extirq_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}