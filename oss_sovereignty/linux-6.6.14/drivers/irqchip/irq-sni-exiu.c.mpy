{
  "module_name": "irq-sni-exiu.c",
  "hash_id": "02940d91e847fdfa1c6f380ca5107a2de0b52272062b0f34be91afaf647a9fba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-sni-exiu.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\n#include <dt-bindings/interrupt-controller/arm-gic.h>\n\n#define NUM_IRQS\t32\n\n#define EIMASK\t\t0x00\n#define EISRCSEL\t0x04\n#define EIREQSTA\t0x08\n#define EIRAWREQSTA\t0x0C\n#define EIREQCLR\t0x10\n#define EILVL\t\t0x14\n#define EIEDG\t\t0x18\n#define EISIR\t\t0x1C\n\nstruct exiu_irq_data {\n\tvoid __iomem\t*base;\n\tu32\t\tspi_base;\n};\n\nstatic void exiu_irq_ack(struct irq_data *d)\n{\n\tstruct exiu_irq_data *data = irq_data_get_irq_chip_data(d);\n\n\twritel(BIT(d->hwirq), data->base + EIREQCLR);\n}\n\nstatic void exiu_irq_eoi(struct irq_data *d)\n{\n\tstruct exiu_irq_data *data = irq_data_get_irq_chip_data(d);\n\n\t \n\tif (irqd_is_level_type(d))\n\t\twritel(BIT(d->hwirq), data->base + EIREQCLR);\n\n\tirq_chip_eoi_parent(d);\n}\n\nstatic void exiu_irq_mask(struct irq_data *d)\n{\n\tstruct exiu_irq_data *data = irq_data_get_irq_chip_data(d);\n\tu32 val;\n\n\tval = readl_relaxed(data->base + EIMASK) | BIT(d->hwirq);\n\twritel_relaxed(val, data->base + EIMASK);\n\tirq_chip_mask_parent(d);\n}\n\nstatic void exiu_irq_unmask(struct irq_data *d)\n{\n\tstruct exiu_irq_data *data = irq_data_get_irq_chip_data(d);\n\tu32 val;\n\n\tval = readl_relaxed(data->base + EIMASK) & ~BIT(d->hwirq);\n\twritel_relaxed(val, data->base + EIMASK);\n\tirq_chip_unmask_parent(d);\n}\n\nstatic void exiu_irq_enable(struct irq_data *d)\n{\n\tstruct exiu_irq_data *data = irq_data_get_irq_chip_data(d);\n\tu32 val;\n\n\t \n\twritel_relaxed(BIT(d->hwirq), data->base + EIREQCLR);\n\n\tval = readl_relaxed(data->base + EIMASK) & ~BIT(d->hwirq);\n\twritel_relaxed(val, data->base + EIMASK);\n\tirq_chip_enable_parent(d);\n}\n\nstatic int exiu_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct exiu_irq_data *data = irq_data_get_irq_chip_data(d);\n\tu32 val;\n\n\tval = readl_relaxed(data->base + EILVL);\n\tif (type == IRQ_TYPE_EDGE_RISING || type == IRQ_TYPE_LEVEL_HIGH)\n\t\tval |= BIT(d->hwirq);\n\telse\n\t\tval &= ~BIT(d->hwirq);\n\twritel_relaxed(val, data->base + EILVL);\n\n\tval = readl_relaxed(data->base + EIEDG);\n\tif (type == IRQ_TYPE_LEVEL_LOW || type == IRQ_TYPE_LEVEL_HIGH) {\n\t\tval &= ~BIT(d->hwirq);\n\t\tirq_set_handler_locked(d, handle_fasteoi_irq);\n\t} else {\n\t\tval |= BIT(d->hwirq);\n\t\tirq_set_handler_locked(d, handle_fasteoi_ack_irq);\n\t}\n\twritel_relaxed(val, data->base + EIEDG);\n\n\twritel_relaxed(BIT(d->hwirq), data->base + EIREQCLR);\n\n\treturn irq_chip_set_type_parent(d, IRQ_TYPE_LEVEL_HIGH);\n}\n\nstatic struct irq_chip exiu_irq_chip = {\n\t.name\t\t\t= \"EXIU\",\n\t.irq_ack\t\t= exiu_irq_ack,\n\t.irq_eoi\t\t= exiu_irq_eoi,\n\t.irq_enable\t\t= exiu_irq_enable,\n\t.irq_mask\t\t= exiu_irq_mask,\n\t.irq_unmask\t\t= exiu_irq_unmask,\n\t.irq_set_type\t\t= exiu_irq_set_type,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.flags\t\t\t= IRQCHIP_SET_TYPE_MASKED |\n\t\t\t\t  IRQCHIP_SKIP_SET_WAKE |\n\t\t\t\t  IRQCHIP_EOI_THREADED |\n\t\t\t\t  IRQCHIP_MASK_ON_SUSPEND,\n};\n\nstatic int exiu_domain_translate(struct irq_domain *domain,\n\t\t\t\t struct irq_fwspec *fwspec,\n\t\t\t\t unsigned long *hwirq,\n\t\t\t\t unsigned int *type)\n{\n\tstruct exiu_irq_data *info = domain->host_data;\n\n\tif (is_of_node(fwspec->fwnode)) {\n\t\tif (fwspec->param_count != 3)\n\t\t\treturn -EINVAL;\n\n\t\tif (fwspec->param[0] != GIC_SPI)\n\t\t\treturn -EINVAL;  \n\n\t\t*hwirq = fwspec->param[1] - info->spi_base;\n\t\t*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;\n\t} else {\n\t\tif (fwspec->param_count != 2)\n\t\t\treturn -EINVAL;\n\t\t*hwirq = fwspec->param[0];\n\t\t*type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\t}\n\treturn 0;\n}\n\nstatic int exiu_domain_alloc(struct irq_domain *dom, unsigned int virq,\n\t\t\t     unsigned int nr_irqs, void *data)\n{\n\tstruct irq_fwspec *fwspec = data;\n\tstruct irq_fwspec parent_fwspec;\n\tstruct exiu_irq_data *info = dom->host_data;\n\tirq_hw_number_t hwirq;\n\n\tparent_fwspec = *fwspec;\n\tif (is_of_node(dom->parent->fwnode)) {\n\t\tif (fwspec->param_count != 3)\n\t\t\treturn -EINVAL;\t \n\t\tif (fwspec->param[0] != GIC_SPI)\n\t\t\treturn -EINVAL;\t \n\n\t\thwirq = fwspec->param[1] - info->spi_base;\n\t} else {\n\t\thwirq = fwspec->param[0];\n\t\tparent_fwspec.param[0] = hwirq + info->spi_base + 32;\n\t}\n\tWARN_ON(nr_irqs != 1);\n\tirq_domain_set_hwirq_and_chip(dom, virq, hwirq, &exiu_irq_chip, info);\n\n\tparent_fwspec.fwnode = dom->parent->fwnode;\n\treturn irq_domain_alloc_irqs_parent(dom, virq, nr_irqs, &parent_fwspec);\n}\n\nstatic const struct irq_domain_ops exiu_domain_ops = {\n\t.translate\t= exiu_domain_translate,\n\t.alloc\t\t= exiu_domain_alloc,\n\t.free\t\t= irq_domain_free_irqs_common,\n};\n\nstatic struct exiu_irq_data *exiu_init(const struct fwnode_handle *fwnode,\n\t\t\t\t       struct resource *res)\n{\n\tstruct exiu_irq_data *data;\n\tint err;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (fwnode_property_read_u32_array(fwnode, \"socionext,spi-base\",\n\t\t\t\t\t   &data->spi_base, 1)) {\n\t\terr = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tdata->base = ioremap(res->start, resource_size(res));\n\tif (!data->base) {\n\t\terr = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\t \n\twritel_relaxed(0xFFFFFFFF, data->base + EIREQCLR);\n\twritel_relaxed(0xFFFFFFFF, data->base + EIMASK);\n\n\treturn data;\n\nout_free:\n\tkfree(data);\n\treturn ERR_PTR(err);\n}\n\nstatic int __init exiu_dt_init(struct device_node *node,\n\t\t\t       struct device_node *parent)\n{\n\tstruct irq_domain *parent_domain, *domain;\n\tstruct exiu_irq_data *data;\n\tstruct resource res;\n\n\tif (!parent) {\n\t\tpr_err(\"%pOF: no parent, giving up\\n\", node);\n\t\treturn -ENODEV;\n\t}\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tpr_err(\"%pOF: unable to obtain parent domain\\n\", node);\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_address_to_resource(node, 0, &res)) {\n\t\tpr_err(\"%pOF: failed to parse memory resource\\n\", node);\n\t\treturn -ENXIO;\n\t}\n\n\tdata = exiu_init(of_node_to_fwnode(node), &res);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tdomain = irq_domain_add_hierarchy(parent_domain, 0, NUM_IRQS, node,\n\t\t\t\t\t  &exiu_domain_ops, data);\n\tif (!domain) {\n\t\tpr_err(\"%pOF: failed to allocate domain\\n\", node);\n\t\tgoto out_unmap;\n\t}\n\n\tpr_info(\"%pOF: %d interrupts forwarded to %pOF\\n\", node, NUM_IRQS,\n\t\tparent);\n\n\treturn 0;\n\nout_unmap:\n\tiounmap(data->base);\n\tkfree(data);\n\treturn -ENOMEM;\n}\nIRQCHIP_DECLARE(exiu, \"socionext,synquacer-exiu\", exiu_dt_init);\n\n#ifdef CONFIG_ACPI\nstatic int exiu_acpi_probe(struct platform_device *pdev)\n{\n\tstruct irq_domain *domain;\n\tstruct exiu_irq_data *data;\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"failed to parse memory resource\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tdata = exiu_init(dev_fwnode(&pdev->dev), res);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tdomain = acpi_irq_create_hierarchy(0, NUM_IRQS, dev_fwnode(&pdev->dev),\n\t\t\t\t\t   &exiu_domain_ops, data);\n\tif (!domain) {\n\t\tdev_err(&pdev->dev, \"failed to create IRQ domain\\n\");\n\t\tgoto out_unmap;\n\t}\n\n\tdev_info(&pdev->dev, \"%d interrupts forwarded\\n\", NUM_IRQS);\n\n\treturn 0;\n\nout_unmap:\n\tiounmap(data->base);\n\tkfree(data);\n\treturn -ENOMEM;\n}\n\nstatic const struct acpi_device_id exiu_acpi_ids[] = {\n\t{ \"SCX0008\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(acpi, exiu_acpi_ids);\n\nstatic struct platform_driver exiu_driver = {\n\t.driver = {\n\t\t.name = \"exiu\",\n\t\t.acpi_match_table = exiu_acpi_ids,\n\t},\n\t.probe = exiu_acpi_probe,\n};\nbuiltin_platform_driver(exiu_driver);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}