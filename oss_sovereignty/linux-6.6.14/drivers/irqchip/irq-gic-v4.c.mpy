{
  "module_name": "irq-gic-v4.c",
  "hash_id": "78e416887bcb42babca0758074c211a74195aa2b0410b1fd0d5a9058e9b67111",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-gic-v4.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/msi.h>\n#include <linux/sched.h>\n\n#include <linux/irqchip/arm-gic-v4.h>\n\n \n\nstatic struct irq_domain *gic_domain;\nstatic const struct irq_domain_ops *vpe_domain_ops;\nstatic const struct irq_domain_ops *sgi_domain_ops;\n\n#ifdef CONFIG_ARM64\n#include <asm/cpufeature.h>\n\nbool gic_cpuif_has_vsgi(void)\n{\n\tunsigned long fld, reg = read_sanitised_ftr_reg(SYS_ID_AA64PFR0_EL1);\n\n\tfld = cpuid_feature_extract_unsigned_field(reg, ID_AA64PFR0_EL1_GIC_SHIFT);\n\n\treturn fld >= 0x3;\n}\n#else\nbool gic_cpuif_has_vsgi(void)\n{\n\treturn false;\n}\n#endif\n\nstatic bool has_v4_1(void)\n{\n\treturn !!sgi_domain_ops;\n}\n\nstatic bool has_v4_1_sgi(void)\n{\n\treturn has_v4_1() && gic_cpuif_has_vsgi();\n}\n\nstatic int its_alloc_vcpu_sgis(struct its_vpe *vpe, int idx)\n{\n\tchar *name;\n\tint sgi_base;\n\n\tif (!has_v4_1_sgi())\n\t\treturn 0;\n\n\tname = kasprintf(GFP_KERNEL, \"GICv4-sgi-%d\", task_pid_nr(current));\n\tif (!name)\n\t\tgoto err;\n\n\tvpe->fwnode = irq_domain_alloc_named_id_fwnode(name, idx);\n\tif (!vpe->fwnode)\n\t\tgoto err;\n\n\tkfree(name);\n\tname = NULL;\n\n\tvpe->sgi_domain = irq_domain_create_linear(vpe->fwnode, 16,\n\t\t\t\t\t\t   sgi_domain_ops, vpe);\n\tif (!vpe->sgi_domain)\n\t\tgoto err;\n\n\tsgi_base = irq_domain_alloc_irqs(vpe->sgi_domain, 16, NUMA_NO_NODE, vpe);\n\tif (sgi_base <= 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (vpe->sgi_domain)\n\t\tirq_domain_remove(vpe->sgi_domain);\n\tif (vpe->fwnode)\n\t\tirq_domain_free_fwnode(vpe->fwnode);\n\tkfree(name);\n\treturn -ENOMEM;\n}\n\nint its_alloc_vcpu_irqs(struct its_vm *vm)\n{\n\tint vpe_base_irq, i;\n\n\tvm->fwnode = irq_domain_alloc_named_id_fwnode(\"GICv4-vpe\",\n\t\t\t\t\t\t      task_pid_nr(current));\n\tif (!vm->fwnode)\n\t\tgoto err;\n\n\tvm->domain = irq_domain_create_hierarchy(gic_domain, 0, vm->nr_vpes,\n\t\t\t\t\t\t vm->fwnode, vpe_domain_ops,\n\t\t\t\t\t\t vm);\n\tif (!vm->domain)\n\t\tgoto err;\n\n\tfor (i = 0; i < vm->nr_vpes; i++) {\n\t\tvm->vpes[i]->its_vm = vm;\n\t\tvm->vpes[i]->idai = true;\n\t}\n\n\tvpe_base_irq = irq_domain_alloc_irqs(vm->domain, vm->nr_vpes,\n\t\t\t\t\t     NUMA_NO_NODE, vm);\n\tif (vpe_base_irq <= 0)\n\t\tgoto err;\n\n\tfor (i = 0; i < vm->nr_vpes; i++) {\n\t\tint ret;\n\t\tvm->vpes[i]->irq = vpe_base_irq + i;\n\t\tret = its_alloc_vcpu_sgis(vm->vpes[i], i);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tif (vm->domain)\n\t\tirq_domain_remove(vm->domain);\n\tif (vm->fwnode)\n\t\tirq_domain_free_fwnode(vm->fwnode);\n\n\treturn -ENOMEM;\n}\n\nstatic void its_free_sgi_irqs(struct its_vm *vm)\n{\n\tint i;\n\n\tif (!has_v4_1_sgi())\n\t\treturn;\n\n\tfor (i = 0; i < vm->nr_vpes; i++) {\n\t\tunsigned int irq = irq_find_mapping(vm->vpes[i]->sgi_domain, 0);\n\n\t\tif (WARN_ON(!irq))\n\t\t\tcontinue;\n\n\t\tirq_domain_free_irqs(irq, 16);\n\t\tirq_domain_remove(vm->vpes[i]->sgi_domain);\n\t\tirq_domain_free_fwnode(vm->vpes[i]->fwnode);\n\t}\n}\n\nvoid its_free_vcpu_irqs(struct its_vm *vm)\n{\n\tits_free_sgi_irqs(vm);\n\tirq_domain_free_irqs(vm->vpes[0]->irq, vm->nr_vpes);\n\tirq_domain_remove(vm->domain);\n\tirq_domain_free_fwnode(vm->fwnode);\n}\n\nstatic int its_send_vpe_cmd(struct its_vpe *vpe, struct its_cmd_info *info)\n{\n\treturn irq_set_vcpu_affinity(vpe->irq, info);\n}\n\nint its_make_vpe_non_resident(struct its_vpe *vpe, bool db)\n{\n\tstruct irq_desc *desc = irq_to_desc(vpe->irq);\n\tstruct its_cmd_info info = { };\n\tint ret;\n\n\tWARN_ON(preemptible());\n\n\tinfo.cmd_type = DESCHEDULE_VPE;\n\tif (has_v4_1()) {\n\t\t \n\t\tinfo.req_db = db;\n\t} else {\n\t\t \n\t\twhile (db && irqd_irq_disabled(&desc->irq_data))\n\t\t\tenable_irq(vpe->irq);\n\t}\n\n\tret = its_send_vpe_cmd(vpe, &info);\n\tif (!ret)\n\t\tvpe->resident = false;\n\n\tvpe->ready = false;\n\n\treturn ret;\n}\n\nint its_make_vpe_resident(struct its_vpe *vpe, bool g0en, bool g1en)\n{\n\tstruct its_cmd_info info = { };\n\tint ret;\n\n\tWARN_ON(preemptible());\n\n\tinfo.cmd_type = SCHEDULE_VPE;\n\tif (has_v4_1()) {\n\t\tinfo.g0en = g0en;\n\t\tinfo.g1en = g1en;\n\t} else {\n\t\t \n\t\tdisable_irq_nosync(vpe->irq);\n\t}\n\n\tret = its_send_vpe_cmd(vpe, &info);\n\tif (!ret)\n\t\tvpe->resident = true;\n\n\treturn ret;\n}\n\nint its_commit_vpe(struct its_vpe *vpe)\n{\n\tstruct its_cmd_info info = {\n\t\t.cmd_type = COMMIT_VPE,\n\t};\n\tint ret;\n\n\tWARN_ON(preemptible());\n\n\tret = its_send_vpe_cmd(vpe, &info);\n\tif (!ret)\n\t\tvpe->ready = true;\n\n\treturn ret;\n}\n\n\nint its_invall_vpe(struct its_vpe *vpe)\n{\n\tstruct its_cmd_info info = {\n\t\t.cmd_type = INVALL_VPE,\n\t};\n\n\treturn its_send_vpe_cmd(vpe, &info);\n}\n\nint its_map_vlpi(int irq, struct its_vlpi_map *map)\n{\n\tstruct its_cmd_info info = {\n\t\t.cmd_type = MAP_VLPI,\n\t\t{\n\t\t\t.map      = map,\n\t\t},\n\t};\n\tint ret;\n\n\t \n\tirq_set_status_flags(irq, IRQ_DISABLE_UNLAZY);\n\n\tret = irq_set_vcpu_affinity(irq, &info);\n\tif (ret)\n\t\tirq_clear_status_flags(irq, IRQ_DISABLE_UNLAZY);\n\n\treturn ret;\n}\n\nint its_get_vlpi(int irq, struct its_vlpi_map *map)\n{\n\tstruct its_cmd_info info = {\n\t\t.cmd_type = GET_VLPI,\n\t\t{\n\t\t\t.map      = map,\n\t\t},\n\t};\n\n\treturn irq_set_vcpu_affinity(irq, &info);\n}\n\nint its_unmap_vlpi(int irq)\n{\n\tirq_clear_status_flags(irq, IRQ_DISABLE_UNLAZY);\n\treturn irq_set_vcpu_affinity(irq, NULL);\n}\n\nint its_prop_update_vlpi(int irq, u8 config, bool inv)\n{\n\tstruct its_cmd_info info = {\n\t\t.cmd_type = inv ? PROP_UPDATE_AND_INV_VLPI : PROP_UPDATE_VLPI,\n\t\t{\n\t\t\t.config   = config,\n\t\t},\n\t};\n\n\treturn irq_set_vcpu_affinity(irq, &info);\n}\n\nint its_prop_update_vsgi(int irq, u8 priority, bool group)\n{\n\tstruct its_cmd_info info = {\n\t\t.cmd_type = PROP_UPDATE_VSGI,\n\t\t{\n\t\t\t.priority\t= priority,\n\t\t\t.group\t\t= group,\n\t\t},\n\t};\n\n\treturn irq_set_vcpu_affinity(irq, &info);\n}\n\nint its_init_v4(struct irq_domain *domain,\n\t\tconst struct irq_domain_ops *vpe_ops,\n\t\tconst struct irq_domain_ops *sgi_ops)\n{\n\tif (domain) {\n\t\tpr_info(\"ITS: Enabling GICv4 support\\n\");\n\t\tgic_domain = domain;\n\t\tvpe_domain_ops = vpe_ops;\n\t\tsgi_domain_ops = sgi_ops;\n\t\treturn 0;\n\t}\n\n\tpr_err(\"ITS: No GICv4 VPE domain allocated\\n\");\n\treturn -ENODEV;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}