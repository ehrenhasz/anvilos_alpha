{
  "module_name": "irq-ath79-misc.c",
  "hash_id": "219d7d0dd25fcc05b8f38348cb66e28e4cb30fbe98a0bac9007d6ddfb40af420",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-ath79-misc.c",
  "human_readable_source": "\n \n\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#define AR71XX_RESET_REG_MISC_INT_STATUS\t0\n#define AR71XX_RESET_REG_MISC_INT_ENABLE\t4\n\n#define ATH79_MISC_IRQ_COUNT\t\t\t32\n#define ATH79_MISC_PERF_IRQ\t\t\t5\n\nstatic int ath79_perfcount_irq;\n\nint get_c0_perfcount_int(void)\n{\n\treturn ath79_perfcount_irq;\n}\nEXPORT_SYMBOL_GPL(get_c0_perfcount_int);\n\nstatic void ath79_misc_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_domain *domain = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tvoid __iomem *base = domain->host_data;\n\tu32 pending;\n\n\tchained_irq_enter(chip, desc);\n\n\tpending = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_STATUS) &\n\t\t  __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);\n\n\tif (!pending) {\n\t\tspurious_interrupt();\n\t\tchained_irq_exit(chip, desc);\n\t\treturn;\n\t}\n\n\twhile (pending) {\n\t\tint bit = __ffs(pending);\n\n\t\tgeneric_handle_domain_irq(domain, bit);\n\t\tpending &= ~BIT(bit);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void ar71xx_misc_irq_unmask(struct irq_data *d)\n{\n\tvoid __iomem *base = irq_data_get_irq_chip_data(d);\n\tunsigned int irq = d->hwirq;\n\tu32 t;\n\n\tt = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);\n\t__raw_writel(t | BIT(irq), base + AR71XX_RESET_REG_MISC_INT_ENABLE);\n\n\t \n\t__raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);\n}\n\nstatic void ar71xx_misc_irq_mask(struct irq_data *d)\n{\n\tvoid __iomem *base = irq_data_get_irq_chip_data(d);\n\tunsigned int irq = d->hwirq;\n\tu32 t;\n\n\tt = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);\n\t__raw_writel(t & ~BIT(irq), base + AR71XX_RESET_REG_MISC_INT_ENABLE);\n\n\t \n\t__raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);\n}\n\nstatic void ar724x_misc_irq_ack(struct irq_data *d)\n{\n\tvoid __iomem *base = irq_data_get_irq_chip_data(d);\n\tunsigned int irq = d->hwirq;\n\tu32 t;\n\n\tt = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_STATUS);\n\t__raw_writel(t & ~BIT(irq), base + AR71XX_RESET_REG_MISC_INT_STATUS);\n\n\t \n\t__raw_readl(base + AR71XX_RESET_REG_MISC_INT_STATUS);\n}\n\nstatic struct irq_chip ath79_misc_irq_chip = {\n\t.name\t\t= \"MISC\",\n\t.irq_unmask\t= ar71xx_misc_irq_unmask,\n\t.irq_mask\t= ar71xx_misc_irq_mask,\n};\n\nstatic int misc_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)\n{\n\tirq_set_chip_and_handler(irq, &ath79_misc_irq_chip, handle_level_irq);\n\tirq_set_chip_data(irq, d->host_data);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops misc_irq_domain_ops = {\n\t.xlate = irq_domain_xlate_onecell,\n\t.map = misc_map,\n};\n\nstatic void __init ath79_misc_intc_domain_init(\n\tstruct irq_domain *domain, int irq)\n{\n\tvoid __iomem *base = domain->host_data;\n\n\tath79_perfcount_irq = irq_create_mapping(domain, ATH79_MISC_PERF_IRQ);\n\n\t \n\t__raw_writel(0, base + AR71XX_RESET_REG_MISC_INT_ENABLE);\n\t__raw_writel(0, base + AR71XX_RESET_REG_MISC_INT_STATUS);\n\n\tirq_set_chained_handler_and_data(irq, ath79_misc_irq_handler, domain);\n}\n\nstatic int __init ath79_misc_intc_of_init(\n\tstruct device_node *node, struct device_node *parent)\n{\n\tstruct irq_domain *domain;\n\tvoid __iomem *base;\n\tint irq;\n\n\tirq = irq_of_parse_and_map(node, 0);\n\tif (!irq) {\n\t\tpr_err(\"Failed to get MISC IRQ\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbase = of_iomap(node, 0);\n\tif (!base) {\n\t\tpr_err(\"Failed to get MISC IRQ registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdomain = irq_domain_add_linear(node, ATH79_MISC_IRQ_COUNT,\n\t\t\t\t&misc_irq_domain_ops, base);\n\tif (!domain) {\n\t\tpr_err(\"Failed to add MISC irqdomain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tath79_misc_intc_domain_init(domain, irq);\n\treturn 0;\n}\n\nstatic int __init ar7100_misc_intc_of_init(\n\tstruct device_node *node, struct device_node *parent)\n{\n\tath79_misc_irq_chip.irq_mask_ack = ar71xx_misc_irq_mask;\n\treturn ath79_misc_intc_of_init(node, parent);\n}\n\nIRQCHIP_DECLARE(ar7100_misc_intc, \"qca,ar7100-misc-intc\",\n\t\tar7100_misc_intc_of_init);\n\nstatic int __init ar7240_misc_intc_of_init(\n\tstruct device_node *node, struct device_node *parent)\n{\n\tath79_misc_irq_chip.irq_ack = ar724x_misc_irq_ack;\n\treturn ath79_misc_intc_of_init(node, parent);\n}\n\nIRQCHIP_DECLARE(ar7240_misc_intc, \"qca,ar7240-misc-intc\",\n\t\tar7240_misc_intc_of_init);\n\nvoid __init ath79_misc_irq_init(void __iomem *regs, int irq,\n\t\t\t\tint irq_base, bool is_ar71xx)\n{\n\tstruct irq_domain *domain;\n\n\tif (is_ar71xx)\n\t\tath79_misc_irq_chip.irq_mask_ack = ar71xx_misc_irq_mask;\n\telse\n\t\tath79_misc_irq_chip.irq_ack = ar724x_misc_irq_ack;\n\n\tdomain = irq_domain_add_legacy(NULL, ATH79_MISC_IRQ_COUNT,\n\t\t\tirq_base, 0, &misc_irq_domain_ops, regs);\n\tif (!domain)\n\t\tpanic(\"Failed to create MISC irqdomain\");\n\n\tath79_misc_intc_domain_init(domain, irq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}