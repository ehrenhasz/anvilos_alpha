{
  "module_name": "irq-or1k-pic.c",
  "hash_id": "d3df4d90f249560c6e87cfd72eb9f4aadda9256dac0fc1bc677a17f1231c21f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-or1k-pic.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n\n \n\nstruct or1k_pic_dev {\n\tstruct irq_chip chip;\n\tirq_flow_handler_t handle;\n\tunsigned long flags;\n};\n\n \n\nstatic void or1k_pic_mask(struct irq_data *data)\n{\n\tmtspr(SPR_PICMR, mfspr(SPR_PICMR) & ~(1UL << data->hwirq));\n}\n\nstatic void or1k_pic_unmask(struct irq_data *data)\n{\n\tmtspr(SPR_PICMR, mfspr(SPR_PICMR) | (1UL << data->hwirq));\n}\n\nstatic void or1k_pic_ack(struct irq_data *data)\n{\n\tmtspr(SPR_PICSR, (1UL << data->hwirq));\n}\n\nstatic void or1k_pic_mask_ack(struct irq_data *data)\n{\n\tmtspr(SPR_PICMR, mfspr(SPR_PICMR) & ~(1UL << data->hwirq));\n\tmtspr(SPR_PICSR, (1UL << data->hwirq));\n}\n\n \nstatic void or1k_pic_or1200_ack(struct irq_data *data)\n{\n\tmtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->hwirq));\n}\n\nstatic void or1k_pic_or1200_mask_ack(struct irq_data *data)\n{\n\tmtspr(SPR_PICMR, mfspr(SPR_PICMR) & ~(1UL << data->hwirq));\n\tmtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->hwirq));\n}\n\nstatic struct or1k_pic_dev or1k_pic_level = {\n\t.chip = {\n\t\t.name = \"or1k-PIC-level\",\n\t\t.irq_unmask = or1k_pic_unmask,\n\t\t.irq_mask = or1k_pic_mask,\n\t},\n\t.handle = handle_level_irq,\n\t.flags = IRQ_LEVEL | IRQ_NOPROBE,\n};\n\nstatic struct or1k_pic_dev or1k_pic_edge = {\n\t.chip = {\n\t\t.name = \"or1k-PIC-edge\",\n\t\t.irq_unmask = or1k_pic_unmask,\n\t\t.irq_mask = or1k_pic_mask,\n\t\t.irq_ack = or1k_pic_ack,\n\t\t.irq_mask_ack = or1k_pic_mask_ack,\n\t},\n\t.handle = handle_edge_irq,\n\t.flags = IRQ_LEVEL | IRQ_NOPROBE,\n};\n\nstatic struct or1k_pic_dev or1k_pic_or1200 = {\n\t.chip = {\n\t\t.name = \"or1200-PIC\",\n\t\t.irq_unmask = or1k_pic_unmask,\n\t\t.irq_mask = or1k_pic_mask,\n\t\t.irq_ack = or1k_pic_or1200_ack,\n\t\t.irq_mask_ack = or1k_pic_or1200_mask_ack,\n\t},\n\t.handle = handle_level_irq,\n\t.flags = IRQ_LEVEL | IRQ_NOPROBE,\n};\n\nstatic struct irq_domain *root_domain;\n\nstatic inline int pic_get_irq(int first)\n{\n\tint hwirq;\n\n\thwirq = ffs(mfspr(SPR_PICSR) >> first);\n\tif (!hwirq)\n\t\treturn NO_IRQ;\n\telse\n\t\thwirq = hwirq + first - 1;\n\n\treturn hwirq;\n}\n\nstatic void or1k_pic_handle_irq(struct pt_regs *regs)\n{\n\tint irq = -1;\n\n\twhile ((irq = pic_get_irq(irq + 1)) != NO_IRQ)\n\t\tgeneric_handle_domain_irq(root_domain, irq);\n}\n\nstatic int or1k_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)\n{\n\tstruct or1k_pic_dev *pic = d->host_data;\n\n\tirq_set_chip_and_handler(irq, &pic->chip, pic->handle);\n\tirq_set_status_flags(irq, pic->flags);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops or1k_irq_domain_ops = {\n\t.xlate = irq_domain_xlate_onecell,\n\t.map = or1k_map,\n};\n\n \nstatic int __init or1k_pic_init(struct device_node *node,\n\t\t\t\t struct or1k_pic_dev *pic)\n{\n\t \n\tmtspr(SPR_PICMR, (0UL));\n\n\troot_domain = irq_domain_add_linear(node, 32, &or1k_irq_domain_ops,\n\t\t\t\t\t    pic);\n\n\tset_handle_irq(or1k_pic_handle_irq);\n\n\treturn 0;\n}\n\nstatic int __init or1k_pic_or1200_init(struct device_node *node,\n\t\t\t\t       struct device_node *parent)\n{\n\treturn or1k_pic_init(node, &or1k_pic_or1200);\n}\nIRQCHIP_DECLARE(or1k_pic_or1200, \"opencores,or1200-pic\", or1k_pic_or1200_init);\nIRQCHIP_DECLARE(or1k_pic, \"opencores,or1k-pic\", or1k_pic_or1200_init);\n\nstatic int __init or1k_pic_level_init(struct device_node *node,\n\t\t\t\t      struct device_node *parent)\n{\n\treturn or1k_pic_init(node, &or1k_pic_level);\n}\nIRQCHIP_DECLARE(or1k_pic_level, \"opencores,or1k-pic-level\",\n\t\tor1k_pic_level_init);\n\nstatic int __init or1k_pic_edge_init(struct device_node *node,\n\t\t\t\t     struct device_node *parent)\n{\n\treturn or1k_pic_init(node, &or1k_pic_edge);\n}\nIRQCHIP_DECLARE(or1k_pic_edge, \"opencores,or1k-pic-edge\", or1k_pic_edge_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}