{
  "module_name": "irq-vt8500.c",
  "hash_id": "e30d9559064a01b1e89db4d7b8e743b7c4c2c69611eca7ad59d545fc81ca104b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-vt8500.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n\n#include <asm/irq.h>\n#include <asm/exception.h>\n#include <asm/mach/irq.h>\n\n#define VT8500_ICPC_IRQ\t\t0x20\n#define VT8500_ICPC_FIQ\t\t0x24\n#define VT8500_ICDC\t\t0x40\t\t \n#define VT8500_ICIS\t\t0x80\t\t \n\n \n#define ICPC_MASK\t\t0x3F\n#define ICPC_ROTATE\t\tBIT(6)\n\n \n#define ICDC_IRQ\t\t0x00\n#define ICDC_FIQ\t\t0x01\n#define ICDC_DSS0\t\t0x02\n#define ICDC_DSS1\t\t0x03\n#define ICDC_DSS2\t\t0x04\n#define ICDC_DSS3\t\t0x05\n#define ICDC_DSS4\t\t0x06\n#define ICDC_DSS5\t\t0x07\n\n#define VT8500_INT_DISABLE\t0\n#define VT8500_INT_ENABLE\tBIT(3)\n\n#define VT8500_TRIGGER_HIGH\t0\n#define VT8500_TRIGGER_RISING\tBIT(5)\n#define VT8500_TRIGGER_FALLING\tBIT(6)\n#define VT8500_EDGE\t\t( VT8500_TRIGGER_RISING \\\n\t\t\t\t| VT8500_TRIGGER_FALLING)\n\n \n#define VT8500_INTC_MAX\t\t2\n\nstruct vt8500_irq_data {\n\tvoid __iomem \t\t*base;\t\t \n\tstruct irq_domain\t*domain;\t \n};\n\n \nstatic struct vt8500_irq_data intc[VT8500_INTC_MAX];\nstatic u32 active_cnt = 0;\n\nstatic void vt8500_irq_mask(struct irq_data *d)\n{\n\tstruct vt8500_irq_data *priv = d->domain->host_data;\n\tvoid __iomem *base = priv->base;\n\tvoid __iomem *stat_reg = base + VT8500_ICIS + (d->hwirq < 32 ? 0 : 4);\n\tu8 edge, dctr;\n\tu32 status;\n\n\tedge = readb(base + VT8500_ICDC + d->hwirq) & VT8500_EDGE;\n\tif (edge) {\n\t\tstatus = readl(stat_reg);\n\n\t\tstatus |= (1 << (d->hwirq & 0x1f));\n\t\twritel(status, stat_reg);\n\t} else {\n\t\tdctr = readb(base + VT8500_ICDC + d->hwirq);\n\t\tdctr &= ~VT8500_INT_ENABLE;\n\t\twriteb(dctr, base + VT8500_ICDC + d->hwirq);\n\t}\n}\n\nstatic void vt8500_irq_unmask(struct irq_data *d)\n{\n\tstruct vt8500_irq_data *priv = d->domain->host_data;\n\tvoid __iomem *base = priv->base;\n\tu8 dctr;\n\n\tdctr = readb(base + VT8500_ICDC + d->hwirq);\n\tdctr |= VT8500_INT_ENABLE;\n\twriteb(dctr, base + VT8500_ICDC + d->hwirq);\n}\n\nstatic int vt8500_irq_set_type(struct irq_data *d, unsigned int flow_type)\n{\n\tstruct vt8500_irq_data *priv = d->domain->host_data;\n\tvoid __iomem *base = priv->base;\n\tu8 dctr;\n\n\tdctr = readb(base + VT8500_ICDC + d->hwirq);\n\tdctr &= ~VT8500_EDGE;\n\n\tswitch (flow_type) {\n\tcase IRQF_TRIGGER_LOW:\n\t\treturn -EINVAL;\n\tcase IRQF_TRIGGER_HIGH:\n\t\tdctr |= VT8500_TRIGGER_HIGH;\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tbreak;\n\tcase IRQF_TRIGGER_FALLING:\n\t\tdctr |= VT8500_TRIGGER_FALLING;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\tcase IRQF_TRIGGER_RISING:\n\t\tdctr |= VT8500_TRIGGER_RISING;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\t}\n\twriteb(dctr, base + VT8500_ICDC + d->hwirq);\n\n\treturn 0;\n}\n\nstatic struct irq_chip vt8500_irq_chip = {\n\t.name = \"vt8500\",\n\t.irq_ack = vt8500_irq_mask,\n\t.irq_mask = vt8500_irq_mask,\n\t.irq_unmask = vt8500_irq_unmask,\n\t.irq_set_type = vt8500_irq_set_type,\n};\n\nstatic void __init vt8500_init_irq_hw(void __iomem *base)\n{\n\tu32 i;\n\n\t \n\twritel(ICPC_ROTATE, base + VT8500_ICPC_IRQ);\n\twritel(0x00, base + VT8500_ICPC_FIQ);\n\n\t \n\tfor (i = 0; i < 64; i++)\n\t\twriteb(VT8500_INT_DISABLE | ICDC_IRQ, base + VT8500_ICDC + i);\n}\n\nstatic int vt8500_irq_map(struct irq_domain *h, unsigned int virq,\n\t\t\t\t\t\t\tirq_hw_number_t hw)\n{\n\tirq_set_chip_and_handler(virq, &vt8500_irq_chip, handle_level_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops vt8500_irq_domain_ops = {\n\t.map = vt8500_irq_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic void __exception_irq_entry vt8500_handle_irq(struct pt_regs *regs)\n{\n\tu32 stat, i;\n\tint irqnr;\n\tvoid __iomem *base;\n\n\t \n\tfor (i=0; i<active_cnt; i++) {\n\t\tbase = intc[i].base;\n\t\tirqnr = readl_relaxed(base) & 0x3F;\n\t\t \n\t\tif (irqnr == 63) {\n\t\t\tstat = readl_relaxed(base + VT8500_ICIS + 4);\n\t\t\tif (!(stat & BIT(31)))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tgeneric_handle_domain_irq(intc[i].domain, irqnr);\n\t}\n}\n\nstatic int __init vt8500_irq_init(struct device_node *node,\n\t\t\t\t  struct device_node *parent)\n{\n\tint irq, i;\n\tstruct device_node *np = node;\n\n\tif (active_cnt == VT8500_INTC_MAX) {\n\t\tpr_err(\"%s: Interrupt controllers > VT8500_INTC_MAX\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tintc[active_cnt].base = of_iomap(np, 0);\n\tintc[active_cnt].domain = irq_domain_add_linear(node, 64,\n\t\t\t&vt8500_irq_domain_ops,\t&intc[active_cnt]);\n\n\tif (!intc[active_cnt].base) {\n\t\tpr_err(\"%s: Unable to map IO memory\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tif (!intc[active_cnt].domain) {\n\t\tpr_err(\"%s: Unable to add irq domain!\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tset_handle_irq(vt8500_handle_irq);\n\n\tvt8500_init_irq_hw(intc[active_cnt].base);\n\n\tpr_info(\"vt8500-irq: Added interrupt controller\\n\");\n\n\tactive_cnt++;\n\n\t \n\tif (of_irq_count(np) != 0) {\n\t\t \n\t\tif (of_irq_count(np) != 8) {\n\t\t\tpr_err(\"%s: Incorrect IRQ map for slaved controller\\n\",\n\t\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tirq = irq_of_parse_and_map(np, i);\n\t\t\tenable_irq(irq);\n\t\t}\n\n\t\tpr_info(\"vt8500-irq: Enabled slave->parent interrupts\\n\");\n\t}\nout:\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(vt8500_irq, \"via,vt8500-intc\", vt8500_irq_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}