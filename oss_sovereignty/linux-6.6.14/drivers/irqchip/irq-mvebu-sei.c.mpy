{
  "module_name": "irq-mvebu-sei.c",
  "hash_id": "dc3d212f1a79de056539092a2cea965b19392f94119453f24c2d7385b02ee17e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mvebu-sei.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt) \"mvebu-sei: \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/msi.h>\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n\n \n#define GICP_SECR(idx)\t\t(0x0  + ((idx) * 0x4))\n \n#define GICP_SEMR(idx)\t\t(0x20 + ((idx) * 0x4))\n#define GICP_SET_SEI_OFFSET\t0x30\n\n#define SEI_IRQ_COUNT_PER_REG\t32\n#define SEI_IRQ_REG_COUNT\t2\n#define SEI_IRQ_COUNT\t\t(SEI_IRQ_COUNT_PER_REG * SEI_IRQ_REG_COUNT)\n#define SEI_IRQ_REG_IDX(irq_id)\t((irq_id) / SEI_IRQ_COUNT_PER_REG)\n#define SEI_IRQ_REG_BIT(irq_id)\t((irq_id) % SEI_IRQ_COUNT_PER_REG)\n\nstruct mvebu_sei_interrupt_range {\n\tu32 first;\n\tu32 size;\n};\n\nstruct mvebu_sei_caps {\n\tstruct mvebu_sei_interrupt_range ap_range;\n\tstruct mvebu_sei_interrupt_range cp_range;\n};\n\nstruct mvebu_sei {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct resource *res;\n\tstruct irq_domain *sei_domain;\n\tstruct irq_domain *ap_domain;\n\tstruct irq_domain *cp_domain;\n\tconst struct mvebu_sei_caps *caps;\n\n\t \n\tstruct mutex cp_msi_lock;\n\tDECLARE_BITMAP(cp_msi_bitmap, SEI_IRQ_COUNT);\n\n\t \n\traw_spinlock_t mask_lock;\n};\n\nstatic void mvebu_sei_ack_irq(struct irq_data *d)\n{\n\tstruct mvebu_sei *sei = irq_data_get_irq_chip_data(d);\n\tu32 reg_idx = SEI_IRQ_REG_IDX(d->hwirq);\n\n\twritel_relaxed(BIT(SEI_IRQ_REG_BIT(d->hwirq)),\n\t\t       sei->base + GICP_SECR(reg_idx));\n}\n\nstatic void mvebu_sei_mask_irq(struct irq_data *d)\n{\n\tstruct mvebu_sei *sei = irq_data_get_irq_chip_data(d);\n\tu32 reg, reg_idx = SEI_IRQ_REG_IDX(d->hwirq);\n\tunsigned long flags;\n\n\t \n\traw_spin_lock_irqsave(&sei->mask_lock, flags);\n\treg = readl_relaxed(sei->base + GICP_SEMR(reg_idx));\n\treg |= BIT(SEI_IRQ_REG_BIT(d->hwirq));\n\twritel_relaxed(reg, sei->base + GICP_SEMR(reg_idx));\n\traw_spin_unlock_irqrestore(&sei->mask_lock, flags);\n}\n\nstatic void mvebu_sei_unmask_irq(struct irq_data *d)\n{\n\tstruct mvebu_sei *sei = irq_data_get_irq_chip_data(d);\n\tu32 reg, reg_idx = SEI_IRQ_REG_IDX(d->hwirq);\n\tunsigned long flags;\n\n\t \n\traw_spin_lock_irqsave(&sei->mask_lock, flags);\n\treg = readl_relaxed(sei->base + GICP_SEMR(reg_idx));\n\treg &= ~BIT(SEI_IRQ_REG_BIT(d->hwirq));\n\twritel_relaxed(reg, sei->base + GICP_SEMR(reg_idx));\n\traw_spin_unlock_irqrestore(&sei->mask_lock, flags);\n}\n\nstatic int mvebu_sei_set_affinity(struct irq_data *d,\n\t\t\t\t  const struct cpumask *mask_val,\n\t\t\t\t  bool force)\n{\n\treturn -EINVAL;\n}\n\nstatic int mvebu_sei_set_irqchip_state(struct irq_data *d,\n\t\t\t\t       enum irqchip_irq_state which,\n\t\t\t\t       bool state)\n{\n\t \n\tif (which != IRQCHIP_STATE_PENDING || state)\n\t\treturn -EINVAL;\n\n\tmvebu_sei_ack_irq(d);\n\treturn 0;\n}\n\nstatic struct irq_chip mvebu_sei_irq_chip = {\n\t.name\t\t\t= \"SEI\",\n\t.irq_ack\t\t= mvebu_sei_ack_irq,\n\t.irq_mask\t\t= mvebu_sei_mask_irq,\n\t.irq_unmask\t\t= mvebu_sei_unmask_irq,\n\t.irq_set_affinity       = mvebu_sei_set_affinity,\n\t.irq_set_irqchip_state\t= mvebu_sei_set_irqchip_state,\n};\n\nstatic int mvebu_sei_ap_set_type(struct irq_data *data, unsigned int type)\n{\n\tif ((type & IRQ_TYPE_SENSE_MASK) != IRQ_TYPE_LEVEL_HIGH)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct irq_chip mvebu_sei_ap_irq_chip = {\n\t.name\t\t\t= \"AP SEI\",\n\t.irq_ack\t\t= irq_chip_ack_parent,\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_set_affinity       = irq_chip_set_affinity_parent,\n\t.irq_set_type\t\t= mvebu_sei_ap_set_type,\n};\n\nstatic void mvebu_sei_cp_compose_msi_msg(struct irq_data *data,\n\t\t\t\t\t struct msi_msg *msg)\n{\n\tstruct mvebu_sei *sei = data->chip_data;\n\tphys_addr_t set = sei->res->start + GICP_SET_SEI_OFFSET;\n\n\tmsg->data = data->hwirq + sei->caps->cp_range.first;\n\tmsg->address_lo = lower_32_bits(set);\n\tmsg->address_hi = upper_32_bits(set);\n}\n\nstatic int mvebu_sei_cp_set_type(struct irq_data *data, unsigned int type)\n{\n\tif ((type & IRQ_TYPE_SENSE_MASK) != IRQ_TYPE_EDGE_RISING)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct irq_chip mvebu_sei_cp_irq_chip = {\n\t.name\t\t\t= \"CP SEI\",\n\t.irq_ack\t\t= irq_chip_ack_parent,\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_set_affinity       = irq_chip_set_affinity_parent,\n\t.irq_set_type\t\t= mvebu_sei_cp_set_type,\n\t.irq_compose_msi_msg\t= mvebu_sei_cp_compose_msi_msg,\n};\n\nstatic int mvebu_sei_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  unsigned int nr_irqs, void *arg)\n{\n\tstruct mvebu_sei *sei = domain->host_data;\n\tstruct irq_fwspec *fwspec = arg;\n\n\t \n\tirq_domain_set_hwirq_and_chip(domain, virq, fwspec->param[0],\n\t\t\t\t      &mvebu_sei_irq_chip, sei);\n\n\treturn 0;\n}\n\nstatic void mvebu_sei_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq + i);\n\t\tirq_set_handler(virq + i, NULL);\n\t\tirq_domain_reset_irq_data(d);\n\t}\n}\n\nstatic const struct irq_domain_ops mvebu_sei_domain_ops = {\n\t.alloc\t= mvebu_sei_domain_alloc,\n\t.free\t= mvebu_sei_domain_free,\n};\n\nstatic int mvebu_sei_ap_translate(struct irq_domain *domain,\n\t\t\t\t  struct irq_fwspec *fwspec,\n\t\t\t\t  unsigned long *hwirq,\n\t\t\t\t  unsigned int *type)\n{\n\t*hwirq = fwspec->param[0];\n\t*type  = IRQ_TYPE_LEVEL_HIGH;\n\n\treturn 0;\n}\n\nstatic int mvebu_sei_ap_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs, void *arg)\n{\n\tstruct mvebu_sei *sei = domain->host_data;\n\tstruct irq_fwspec fwspec;\n\tunsigned long hwirq;\n\tunsigned int type;\n\tint err;\n\n\tmvebu_sei_ap_translate(domain, arg, &hwirq, &type);\n\n\tfwspec.fwnode = domain->parent->fwnode;\n\tfwspec.param_count = 1;\n\tfwspec.param[0] = hwirq + sei->caps->ap_range.first;\n\n\terr = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\n\tif (err)\n\t\treturn err;\n\n\tirq_domain_set_info(domain, virq, hwirq,\n\t\t\t    &mvebu_sei_ap_irq_chip, sei,\n\t\t\t    handle_level_irq, NULL, NULL);\n\tirq_set_probe(virq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mvebu_sei_ap_domain_ops = {\n\t.translate\t= mvebu_sei_ap_translate,\n\t.alloc\t\t= mvebu_sei_ap_alloc,\n\t.free\t\t= irq_domain_free_irqs_parent,\n};\n\nstatic void mvebu_sei_cp_release_irq(struct mvebu_sei *sei, unsigned long hwirq)\n{\n\tmutex_lock(&sei->cp_msi_lock);\n\tclear_bit(hwirq, sei->cp_msi_bitmap);\n\tmutex_unlock(&sei->cp_msi_lock);\n}\n\nstatic int mvebu_sei_cp_domain_alloc(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs,\n\t\t\t\t     void *args)\n{\n\tstruct mvebu_sei *sei = domain->host_data;\n\tstruct irq_fwspec fwspec;\n\tunsigned long hwirq;\n\tint ret;\n\n\t \n\tif (nr_irqs != 1)\n\t\treturn -ENOTSUPP;\n\n\tmutex_lock(&sei->cp_msi_lock);\n\thwirq = find_first_zero_bit(sei->cp_msi_bitmap,\n\t\t\t\t    sei->caps->cp_range.size);\n\tif (hwirq < sei->caps->cp_range.size)\n\t\tset_bit(hwirq, sei->cp_msi_bitmap);\n\tmutex_unlock(&sei->cp_msi_lock);\n\n\tif (hwirq == sei->caps->cp_range.size)\n\t\treturn -ENOSPC;\n\n\tfwspec.fwnode = domain->parent->fwnode;\n\tfwspec.param_count = 1;\n\tfwspec.param[0] = hwirq + sei->caps->cp_range.first;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\n\tif (ret)\n\t\tgoto free_irq;\n\n\tirq_domain_set_info(domain, virq, hwirq,\n\t\t\t    &mvebu_sei_cp_irq_chip, sei,\n\t\t\t    handle_edge_irq, NULL, NULL);\n\n\treturn 0;\n\nfree_irq:\n\tmvebu_sei_cp_release_irq(sei, hwirq);\n\treturn ret;\n}\n\nstatic void mvebu_sei_cp_domain_free(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct mvebu_sei *sei = domain->host_data;\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\n\tif (nr_irqs != 1 || d->hwirq >= sei->caps->cp_range.size) {\n\t\tdev_err(sei->dev, \"Invalid hwirq %lu\\n\", d->hwirq);\n\t\treturn;\n\t}\n\n\tmvebu_sei_cp_release_irq(sei, d->hwirq);\n\tirq_domain_free_irqs_parent(domain, virq, 1);\n}\n\nstatic const struct irq_domain_ops mvebu_sei_cp_domain_ops = {\n\t.alloc\t= mvebu_sei_cp_domain_alloc,\n\t.free\t= mvebu_sei_cp_domain_free,\n};\n\nstatic struct irq_chip mvebu_sei_msi_irq_chip = {\n\t.name\t\t= \"SEI pMSI\",\n\t.irq_ack\t= irq_chip_ack_parent,\n\t.irq_set_type\t= irq_chip_set_type_parent,\n};\n\nstatic struct msi_domain_ops mvebu_sei_msi_ops = {\n};\n\nstatic struct msi_domain_info mvebu_sei_msi_domain_info = {\n\t.flags\t= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS,\n\t.ops\t= &mvebu_sei_msi_ops,\n\t.chip\t= &mvebu_sei_msi_irq_chip,\n};\n\nstatic void mvebu_sei_handle_cascade_irq(struct irq_desc *desc)\n{\n\tstruct mvebu_sei *sei = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tu32 idx;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (idx = 0; idx < SEI_IRQ_REG_COUNT; idx++) {\n\t\tunsigned long irqmap;\n\t\tint bit;\n\n\t\tirqmap = readl_relaxed(sei->base + GICP_SECR(idx));\n\t\tfor_each_set_bit(bit, &irqmap, SEI_IRQ_COUNT_PER_REG) {\n\t\t\tunsigned long hwirq;\n\t\t\tint err;\n\n\t\t\thwirq = idx * SEI_IRQ_COUNT_PER_REG + bit;\n\t\t\terr = generic_handle_domain_irq(sei->sei_domain, hwirq);\n\t\t\tif (unlikely(err))\n\t\t\t\tdev_warn(sei->dev, \"Spurious IRQ detected (hwirq %lu)\\n\", hwirq);\n\t\t}\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void mvebu_sei_reset(struct mvebu_sei *sei)\n{\n\tu32 reg_idx;\n\n\t \n\tfor (reg_idx = 0; reg_idx < SEI_IRQ_REG_COUNT; reg_idx++) {\n\t\twritel_relaxed(0xFFFFFFFF, sei->base + GICP_SECR(reg_idx));\n\t\twritel_relaxed(0xFFFFFFFF, sei->base + GICP_SEMR(reg_idx));\n\t}\n}\n\nstatic int mvebu_sei_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct irq_domain *plat_domain;\n\tstruct mvebu_sei *sei;\n\tu32 parent_irq;\n\tint ret;\n\n\tsei = devm_kzalloc(&pdev->dev, sizeof(*sei), GFP_KERNEL);\n\tif (!sei)\n\t\treturn -ENOMEM;\n\n\tsei->dev = &pdev->dev;\n\n\tmutex_init(&sei->cp_msi_lock);\n\traw_spin_lock_init(&sei->mask_lock);\n\n\tsei->base = devm_platform_get_and_ioremap_resource(pdev, 0, &sei->res);\n\tif (IS_ERR(sei->base))\n\t\treturn PTR_ERR(sei->base);\n\n\t \n\tsei->caps = of_device_get_match_data(&pdev->dev);\n\tif (!sei->caps) {\n\t\tdev_err(sei->dev,\n\t\t\t\"Could not retrieve controller capabilities\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tparent_irq = irq_of_parse_and_map(node, 0);\n\tif (parent_irq <= 0) {\n\t\tdev_err(sei->dev, \"Failed to retrieve top-level SPI IRQ\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsei->sei_domain = irq_domain_create_linear(of_node_to_fwnode(node),\n\t\t\t\t\t\t   (sei->caps->ap_range.size +\n\t\t\t\t\t\t    sei->caps->cp_range.size),\n\t\t\t\t\t\t   &mvebu_sei_domain_ops,\n\t\t\t\t\t\t   sei);\n\tif (!sei->sei_domain) {\n\t\tdev_err(sei->dev, \"Failed to create SEI IRQ domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto dispose_irq;\n\t}\n\n\tirq_domain_update_bus_token(sei->sei_domain, DOMAIN_BUS_NEXUS);\n\n\t \n\tsei->ap_domain = irq_domain_create_hierarchy(sei->sei_domain, 0,\n\t\t\t\t\t\t     sei->caps->ap_range.size,\n\t\t\t\t\t\t     of_node_to_fwnode(node),\n\t\t\t\t\t\t     &mvebu_sei_ap_domain_ops,\n\t\t\t\t\t\t     sei);\n\tif (!sei->ap_domain) {\n\t\tdev_err(sei->dev, \"Failed to create AP IRQ domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto remove_sei_domain;\n\t}\n\n\tirq_domain_update_bus_token(sei->ap_domain, DOMAIN_BUS_WIRED);\n\n\t \n\tsei->cp_domain = irq_domain_create_hierarchy(sei->sei_domain, 0,\n\t\t\t\t\t\t     sei->caps->cp_range.size,\n\t\t\t\t\t\t     of_node_to_fwnode(node),\n\t\t\t\t\t\t     &mvebu_sei_cp_domain_ops,\n\t\t\t\t\t\t     sei);\n\tif (!sei->cp_domain) {\n\t\tpr_err(\"Failed to create CPs IRQ domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto remove_ap_domain;\n\t}\n\n\tirq_domain_update_bus_token(sei->cp_domain, DOMAIN_BUS_GENERIC_MSI);\n\n\tplat_domain = platform_msi_create_irq_domain(of_node_to_fwnode(node),\n\t\t\t\t\t\t     &mvebu_sei_msi_domain_info,\n\t\t\t\t\t\t     sei->cp_domain);\n\tif (!plat_domain) {\n\t\tpr_err(\"Failed to create CPs MSI domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto remove_cp_domain;\n\t}\n\n\tmvebu_sei_reset(sei);\n\n\tirq_set_chained_handler_and_data(parent_irq,\n\t\t\t\t\t mvebu_sei_handle_cascade_irq,\n\t\t\t\t\t sei);\n\n\treturn 0;\n\nremove_cp_domain:\n\tirq_domain_remove(sei->cp_domain);\nremove_ap_domain:\n\tirq_domain_remove(sei->ap_domain);\nremove_sei_domain:\n\tirq_domain_remove(sei->sei_domain);\ndispose_irq:\n\tirq_dispose_mapping(parent_irq);\n\n\treturn ret;\n}\n\nstatic struct mvebu_sei_caps mvebu_sei_ap806_caps = {\n\t.ap_range = {\n\t\t.first = 0,\n\t\t.size = 21,\n\t},\n\t.cp_range = {\n\t\t.first = 21,\n\t\t.size = 43,\n\t},\n};\n\nstatic const struct of_device_id mvebu_sei_of_match[] = {\n\t{\n\t\t.compatible = \"marvell,ap806-sei\",\n\t\t.data = &mvebu_sei_ap806_caps,\n\t},\n\t{},\n};\n\nstatic struct platform_driver mvebu_sei_driver = {\n\t.probe  = mvebu_sei_probe,\n\t.driver = {\n\t\t.name = \"mvebu-sei\",\n\t\t.of_match_table = mvebu_sei_of_match,\n\t},\n};\nbuiltin_platform_driver(mvebu_sei_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}