{
  "module_name": "irq-gic-v2m.c",
  "hash_id": "41ab15e524261eea542ce924af0017de8702207e5f876ddbe3bb4b2547267046",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-gic-v2m.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"GICv2m: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/iommu.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/msi.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/irqchip/arm-gic.h>\n#include <linux/irqchip/arm-gic-common.h>\n\n \n#define V2M_MSI_TYPER\t\t       0x008\n#define V2M_MSI_TYPER_BASE_SHIFT       16\n#define V2M_MSI_TYPER_BASE_MASK\t       0x3FF\n#define V2M_MSI_TYPER_NUM_MASK\t       0x3FF\n#define V2M_MSI_SETSPI_NS\t       0x040\n#define V2M_MIN_SPI\t\t       32\n#define V2M_MAX_SPI\t\t       1019\n#define V2M_MSI_IIDR\t\t       0xFCC\n\n#define V2M_MSI_TYPER_BASE_SPI(x)      \\\n\t       (((x) >> V2M_MSI_TYPER_BASE_SHIFT) & V2M_MSI_TYPER_BASE_MASK)\n\n#define V2M_MSI_TYPER_NUM_SPI(x)       ((x) & V2M_MSI_TYPER_NUM_MASK)\n\n \n#define XGENE_GICV2M_MSI_IIDR\t\t0x06000170\n\n \n#define BCM_NS2_GICV2M_MSI_IIDR\t\t0x0000013f\n\n \n#define GICV2M_NEEDS_SPI_OFFSET\t\t0x00000001\n#define GICV2M_GRAVITON_ADDRESS_ONLY\t0x00000002\n\nstatic LIST_HEAD(v2m_nodes);\nstatic DEFINE_SPINLOCK(v2m_lock);\n\nstruct v2m_data {\n\tstruct list_head entry;\n\tstruct fwnode_handle *fwnode;\n\tstruct resource res;\t \n\tvoid __iomem *base;\t \n\tu32 spi_start;\t\t \n\tu32 nr_spis;\t\t \n\tu32 spi_offset;\t\t \n\tunsigned long *bm;\t \n\tu32 flags;\t\t \n};\n\nstatic void gicv2m_mask_msi_irq(struct irq_data *d)\n{\n\tpci_msi_mask_irq(d);\n\tirq_chip_mask_parent(d);\n}\n\nstatic void gicv2m_unmask_msi_irq(struct irq_data *d)\n{\n\tpci_msi_unmask_irq(d);\n\tirq_chip_unmask_parent(d);\n}\n\nstatic struct irq_chip gicv2m_msi_irq_chip = {\n\t.name\t\t\t= \"MSI\",\n\t.irq_mask\t\t= gicv2m_mask_msi_irq,\n\t.irq_unmask\t\t= gicv2m_unmask_msi_irq,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n};\n\nstatic struct msi_domain_info gicv2m_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_PCI_MSIX | MSI_FLAG_MULTI_PCI_MSI),\n\t.chip\t= &gicv2m_msi_irq_chip,\n};\n\nstatic phys_addr_t gicv2m_get_msi_addr(struct v2m_data *v2m, int hwirq)\n{\n\tif (v2m->flags & GICV2M_GRAVITON_ADDRESS_ONLY)\n\t\treturn v2m->res.start | ((hwirq - 32) << 3);\n\telse\n\t\treturn v2m->res.start + V2M_MSI_SETSPI_NS;\n}\n\nstatic void gicv2m_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct v2m_data *v2m = irq_data_get_irq_chip_data(data);\n\tphys_addr_t addr = gicv2m_get_msi_addr(v2m, data->hwirq);\n\n\tmsg->address_hi = upper_32_bits(addr);\n\tmsg->address_lo = lower_32_bits(addr);\n\n\tif (v2m->flags & GICV2M_GRAVITON_ADDRESS_ONLY)\n\t\tmsg->data = 0;\n\telse\n\t\tmsg->data = data->hwirq;\n\tif (v2m->flags & GICV2M_NEEDS_SPI_OFFSET)\n\t\tmsg->data -= v2m->spi_offset;\n\n\tiommu_dma_compose_msi_msg(irq_data_get_msi_desc(data), msg);\n}\n\nstatic struct irq_chip gicv2m_irq_chip = {\n\t.name\t\t\t= \"GICv2m\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.irq_compose_msi_msg\t= gicv2m_compose_msi_msg,\n};\n\nstatic int gicv2m_irq_gic_domain_alloc(struct irq_domain *domain,\n\t\t\t\t       unsigned int virq,\n\t\t\t\t       irq_hw_number_t hwirq)\n{\n\tstruct irq_fwspec fwspec;\n\tstruct irq_data *d;\n\tint err;\n\n\tif (is_of_node(domain->parent->fwnode)) {\n\t\tfwspec.fwnode = domain->parent->fwnode;\n\t\tfwspec.param_count = 3;\n\t\tfwspec.param[0] = 0;\n\t\tfwspec.param[1] = hwirq - 32;\n\t\tfwspec.param[2] = IRQ_TYPE_EDGE_RISING;\n\t} else if (is_fwnode_irqchip(domain->parent->fwnode)) {\n\t\tfwspec.fwnode = domain->parent->fwnode;\n\t\tfwspec.param_count = 2;\n\t\tfwspec.param[0] = hwirq;\n\t\tfwspec.param[1] = IRQ_TYPE_EDGE_RISING;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\terr = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\n\tif (err)\n\t\treturn err;\n\n\t \n\td = irq_domain_get_irq_data(domain->parent, virq);\n\td->chip->irq_set_type(d, IRQ_TYPE_EDGE_RISING);\n\treturn 0;\n}\n\nstatic void gicv2m_unalloc_msi(struct v2m_data *v2m, unsigned int hwirq,\n\t\t\t       int nr_irqs)\n{\n\tspin_lock(&v2m_lock);\n\tbitmap_release_region(v2m->bm, hwirq - v2m->spi_start,\n\t\t\t      get_count_order(nr_irqs));\n\tspin_unlock(&v2m_lock);\n}\n\nstatic int gicv2m_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t   unsigned int nr_irqs, void *args)\n{\n\tmsi_alloc_info_t *info = args;\n\tstruct v2m_data *v2m = NULL, *tmp;\n\tint hwirq, offset, i, err = 0;\n\n\tspin_lock(&v2m_lock);\n\tlist_for_each_entry(tmp, &v2m_nodes, entry) {\n\t\toffset = bitmap_find_free_region(tmp->bm, tmp->nr_spis,\n\t\t\t\t\t\t get_count_order(nr_irqs));\n\t\tif (offset >= 0) {\n\t\t\tv2m = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&v2m_lock);\n\n\tif (!v2m)\n\t\treturn -ENOSPC;\n\n\thwirq = v2m->spi_start + offset;\n\n\terr = iommu_dma_prepare_msi(info->desc,\n\t\t\t\t    gicv2m_get_msi_addr(v2m, hwirq));\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\terr = gicv2m_irq_gic_domain_alloc(domain, virq + i, hwirq + i);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\n\t\t\t\t\t      &gicv2m_irq_chip, v2m);\n\t}\n\n\treturn 0;\n\nfail:\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n\tgicv2m_unalloc_msi(v2m, hwirq, nr_irqs);\n\treturn err;\n}\n\nstatic void gicv2m_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t   unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct v2m_data *v2m = irq_data_get_irq_chip_data(d);\n\n\tgicv2m_unalloc_msi(v2m, d->hwirq, nr_irqs);\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}\n\nstatic const struct irq_domain_ops gicv2m_domain_ops = {\n\t.alloc\t\t\t= gicv2m_irq_domain_alloc,\n\t.free\t\t\t= gicv2m_irq_domain_free,\n};\n\nstatic bool is_msi_spi_valid(u32 base, u32 num)\n{\n\tif (base < V2M_MIN_SPI) {\n\t\tpr_err(\"Invalid MSI base SPI (base:%u)\\n\", base);\n\t\treturn false;\n\t}\n\n\tif ((num == 0) || (base + num > V2M_MAX_SPI)) {\n\t\tpr_err(\"Number of SPIs (%u) exceed maximum (%u)\\n\",\n\t\t       num, V2M_MAX_SPI - V2M_MIN_SPI + 1);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic struct irq_chip gicv2m_pmsi_irq_chip = {\n\t.name\t\t\t= \"pMSI\",\n};\n\nstatic struct msi_domain_ops gicv2m_pmsi_ops = {\n};\n\nstatic struct msi_domain_info gicv2m_pmsi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS),\n\t.ops\t= &gicv2m_pmsi_ops,\n\t.chip\t= &gicv2m_pmsi_irq_chip,\n};\n\nstatic void __init gicv2m_teardown(void)\n{\n\tstruct v2m_data *v2m, *tmp;\n\n\tlist_for_each_entry_safe(v2m, tmp, &v2m_nodes, entry) {\n\t\tlist_del(&v2m->entry);\n\t\tbitmap_free(v2m->bm);\n\t\tiounmap(v2m->base);\n\t\tof_node_put(to_of_node(v2m->fwnode));\n\t\tif (is_fwnode_irqchip(v2m->fwnode))\n\t\t\tirq_domain_free_fwnode(v2m->fwnode);\n\t\tkfree(v2m);\n\t}\n}\n\nstatic __init int gicv2m_allocate_domains(struct irq_domain *parent)\n{\n\tstruct irq_domain *inner_domain, *pci_domain, *plat_domain;\n\tstruct v2m_data *v2m;\n\n\tv2m = list_first_entry_or_null(&v2m_nodes, struct v2m_data, entry);\n\tif (!v2m)\n\t\treturn 0;\n\n\tinner_domain = irq_domain_create_hierarchy(parent, 0, 0, v2m->fwnode,\n\t\t\t\t\t\t   &gicv2m_domain_ops, v2m);\n\tif (!inner_domain) {\n\t\tpr_err(\"Failed to create GICv2m domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tirq_domain_update_bus_token(inner_domain, DOMAIN_BUS_NEXUS);\n\tpci_domain = pci_msi_create_irq_domain(v2m->fwnode,\n\t\t\t\t\t       &gicv2m_msi_domain_info,\n\t\t\t\t\t       inner_domain);\n\tplat_domain = platform_msi_create_irq_domain(v2m->fwnode,\n\t\t\t\t\t\t     &gicv2m_pmsi_domain_info,\n\t\t\t\t\t\t     inner_domain);\n\tif (!pci_domain || !plat_domain) {\n\t\tpr_err(\"Failed to create MSI domains\\n\");\n\t\tif (plat_domain)\n\t\t\tirq_domain_remove(plat_domain);\n\t\tif (pci_domain)\n\t\t\tirq_domain_remove(pci_domain);\n\t\tirq_domain_remove(inner_domain);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init gicv2m_init_one(struct fwnode_handle *fwnode,\n\t\t\t\t  u32 spi_start, u32 nr_spis,\n\t\t\t\t  struct resource *res, u32 flags)\n{\n\tint ret;\n\tstruct v2m_data *v2m;\n\n\tv2m = kzalloc(sizeof(struct v2m_data), GFP_KERNEL);\n\tif (!v2m)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&v2m->entry);\n\tv2m->fwnode = fwnode;\n\tv2m->flags = flags;\n\n\tmemcpy(&v2m->res, res, sizeof(struct resource));\n\n\tv2m->base = ioremap(v2m->res.start, resource_size(&v2m->res));\n\tif (!v2m->base) {\n\t\tpr_err(\"Failed to map GICv2m resource\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_v2m;\n\t}\n\n\tif (spi_start && nr_spis) {\n\t\tv2m->spi_start = spi_start;\n\t\tv2m->nr_spis = nr_spis;\n\t} else {\n\t\tu32 typer;\n\n\t\t \n\t\tif (v2m->flags & GICV2M_GRAVITON_ADDRESS_ONLY) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_iounmap;\n\t\t}\n\t\ttyper = readl_relaxed(v2m->base + V2M_MSI_TYPER);\n\n\t\tv2m->spi_start = V2M_MSI_TYPER_BASE_SPI(typer);\n\t\tv2m->nr_spis = V2M_MSI_TYPER_NUM_SPI(typer);\n\t}\n\n\tif (!is_msi_spi_valid(v2m->spi_start, v2m->nr_spis)) {\n\t\tret = -EINVAL;\n\t\tgoto err_iounmap;\n\t}\n\n\t \n\tif (!(v2m->flags & GICV2M_GRAVITON_ADDRESS_ONLY)) {\n\t\tswitch (readl_relaxed(v2m->base + V2M_MSI_IIDR)) {\n\t\tcase XGENE_GICV2M_MSI_IIDR:\n\t\t\tv2m->flags |= GICV2M_NEEDS_SPI_OFFSET;\n\t\t\tv2m->spi_offset = v2m->spi_start;\n\t\t\tbreak;\n\t\tcase BCM_NS2_GICV2M_MSI_IIDR:\n\t\t\tv2m->flags |= GICV2M_NEEDS_SPI_OFFSET;\n\t\t\tv2m->spi_offset = 32;\n\t\t\tbreak;\n\t\t}\n\t}\n\tv2m->bm = bitmap_zalloc(v2m->nr_spis, GFP_KERNEL);\n\tif (!v2m->bm) {\n\t\tret = -ENOMEM;\n\t\tgoto err_iounmap;\n\t}\n\n\tlist_add_tail(&v2m->entry, &v2m_nodes);\n\n\tpr_info(\"range%pR, SPI[%d:%d]\\n\", res,\n\t\tv2m->spi_start, (v2m->spi_start + v2m->nr_spis - 1));\n\treturn 0;\n\nerr_iounmap:\n\tiounmap(v2m->base);\nerr_free_v2m:\n\tkfree(v2m);\n\treturn ret;\n}\n\nstatic __initconst struct of_device_id gicv2m_device_id[] = {\n\t{\t.compatible\t= \"arm,gic-v2m-frame\",\t},\n\t{},\n};\n\nstatic int __init gicv2m_of_init(struct fwnode_handle *parent_handle,\n\t\t\t\t struct irq_domain *parent)\n{\n\tint ret = 0;\n\tstruct device_node *node = to_of_node(parent_handle);\n\tstruct device_node *child;\n\n\tfor (child = of_find_matching_node(node, gicv2m_device_id); child;\n\t     child = of_find_matching_node(child, gicv2m_device_id)) {\n\t\tu32 spi_start = 0, nr_spis = 0;\n\t\tstruct resource res;\n\n\t\tif (!of_property_read_bool(child, \"msi-controller\"))\n\t\t\tcontinue;\n\n\t\tret = of_address_to_resource(child, 0, &res);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to allocate v2m resource.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!of_property_read_u32(child, \"arm,msi-base-spi\",\n\t\t\t\t\t  &spi_start) &&\n\t\t    !of_property_read_u32(child, \"arm,msi-num-spis\", &nr_spis))\n\t\t\tpr_info(\"DT overriding V2M MSI_TYPER (base:%u, num:%u)\\n\",\n\t\t\t\tspi_start, nr_spis);\n\n\t\tret = gicv2m_init_one(&child->fwnode, spi_start, nr_spis,\n\t\t\t\t      &res, 0);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tret = gicv2m_allocate_domains(parent);\n\tif (ret)\n\t\tgicv2m_teardown();\n\treturn ret;\n}\n\n#ifdef CONFIG_ACPI\nstatic int acpi_num_msi;\n\nstatic __init struct fwnode_handle *gicv2m_get_fwnode(struct device *dev)\n{\n\tstruct v2m_data *data;\n\n\tif (WARN_ON(acpi_num_msi <= 0))\n\t\treturn NULL;\n\n\t \n\tdata = list_first_entry_or_null(&v2m_nodes, struct v2m_data, entry);\n\tif (!data)\n\t\treturn NULL;\n\n\treturn data->fwnode;\n}\n\nstatic __init bool acpi_check_amazon_graviton_quirks(void)\n{\n\tstatic struct acpi_table_madt *madt;\n\tacpi_status status;\n\tbool rc = false;\n\n#define ACPI_AMZN_OEM_ID\t\t\"AMAZON\"\n\n\tstatus = acpi_get_table(ACPI_SIG_MADT, 0,\n\t\t\t\t(struct acpi_table_header **)&madt);\n\n\tif (ACPI_FAILURE(status) || !madt)\n\t\treturn rc;\n\trc = !memcmp(madt->header.oem_id, ACPI_AMZN_OEM_ID, ACPI_OEM_ID_SIZE);\n\tacpi_put_table((struct acpi_table_header *)madt);\n\n\treturn rc;\n}\n\nstatic int __init\nacpi_parse_madt_msi(union acpi_subtable_headers *header,\n\t\t    const unsigned long end)\n{\n\tint ret;\n\tstruct resource res;\n\tu32 spi_start = 0, nr_spis = 0;\n\tstruct acpi_madt_generic_msi_frame *m;\n\tstruct fwnode_handle *fwnode;\n\tu32 flags = 0;\n\n\tm = (struct acpi_madt_generic_msi_frame *)header;\n\tif (BAD_MADT_ENTRY(m, end))\n\t\treturn -EINVAL;\n\n\tres.start = m->base_address;\n\tres.end = m->base_address + SZ_4K - 1;\n\tres.flags = IORESOURCE_MEM;\n\n\tif (acpi_check_amazon_graviton_quirks()) {\n\t\tpr_info(\"applying Amazon Graviton quirk\\n\");\n\t\tres.end = res.start + SZ_8K - 1;\n\t\tflags |= GICV2M_GRAVITON_ADDRESS_ONLY;\n\t\tgicv2m_msi_domain_info.flags &= ~MSI_FLAG_MULTI_PCI_MSI;\n\t}\n\n\tif (m->flags & ACPI_MADT_OVERRIDE_SPI_VALUES) {\n\t\tspi_start = m->spi_base;\n\t\tnr_spis = m->spi_count;\n\n\t\tpr_info(\"ACPI overriding V2M MSI_TYPER (base:%u, num:%u)\\n\",\n\t\t\tspi_start, nr_spis);\n\t}\n\n\tfwnode = irq_domain_alloc_fwnode(&res.start);\n\tif (!fwnode) {\n\t\tpr_err(\"Unable to allocate GICv2m domain token\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = gicv2m_init_one(fwnode, spi_start, nr_spis, &res, flags);\n\tif (ret)\n\t\tirq_domain_free_fwnode(fwnode);\n\n\treturn ret;\n}\n\nstatic int __init gicv2m_acpi_init(struct irq_domain *parent)\n{\n\tint ret;\n\n\tif (acpi_num_msi > 0)\n\t\treturn 0;\n\n\tacpi_num_msi = acpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_MSI_FRAME,\n\t\t\t\t      acpi_parse_madt_msi, 0);\n\n\tif (acpi_num_msi <= 0)\n\t\tgoto err_out;\n\n\tret = gicv2m_allocate_domains(parent);\n\tif (ret)\n\t\tgoto err_out;\n\n\tpci_msi_register_fwnode_provider(&gicv2m_get_fwnode);\n\n\treturn 0;\n\nerr_out:\n\tgicv2m_teardown();\n\treturn -EINVAL;\n}\n#else  \nstatic int __init gicv2m_acpi_init(struct irq_domain *parent)\n{\n\treturn -EINVAL;\n}\n#endif  \n\nint __init gicv2m_init(struct fwnode_handle *parent_handle,\n\t\t       struct irq_domain *parent)\n{\n\tif (is_of_node(parent_handle))\n\t\treturn gicv2m_of_init(parent_handle, parent);\n\n\treturn gicv2m_acpi_init(parent);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}