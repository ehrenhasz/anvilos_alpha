{
  "module_name": "irq-loongson-htvec.c",
  "hash_id": "d7ab0c32140b0fe174b97930e1571fe0305afd5313cc8c570ab6e749e1a712e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-loongson-htvec.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"htvec: \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/syscore_ops.h>\n\n \n#define HTVEC_EN_OFF\t\t0x20\n#define HTVEC_MAX_PARENT_IRQ\t8\n#define VEC_COUNT_PER_REG\t32\n#define VEC_REG_IDX(irq_id)\t((irq_id) / VEC_COUNT_PER_REG)\n#define VEC_REG_BIT(irq_id)\t((irq_id) % VEC_COUNT_PER_REG)\n\nstruct htvec {\n\tint\t\t\tnum_parents;\n\tvoid __iomem\t\t*base;\n\tstruct irq_domain\t*htvec_domain;\n\traw_spinlock_t\t\thtvec_lock;\n\tu32\t\t\tsaved_vec_en[HTVEC_MAX_PARENT_IRQ];\n};\n\nstatic struct htvec *htvec_priv;\n\nstatic void htvec_irq_dispatch(struct irq_desc *desc)\n{\n\tint i;\n\tu32 pending;\n\tbool handled = false;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct htvec *priv = irq_desc_get_handler_data(desc);\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (i = 0; i < priv->num_parents; i++) {\n\t\tpending = readl(priv->base + 4 * i);\n\t\twhile (pending) {\n\t\t\tint bit = __ffs(pending);\n\n\t\t\tgeneric_handle_domain_irq(priv->htvec_domain,\n\t\t\t\t\t\t  bit + VEC_COUNT_PER_REG * i);\n\t\t\tpending &= ~BIT(bit);\n\t\t\thandled = true;\n\t\t}\n\t}\n\n\tif (!handled)\n\t\tspurious_interrupt();\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void htvec_ack_irq(struct irq_data *d)\n{\n\tstruct htvec *priv = irq_data_get_irq_chip_data(d);\n\n\twritel(BIT(VEC_REG_BIT(d->hwirq)),\n\t       priv->base + VEC_REG_IDX(d->hwirq) * 4);\n}\n\nstatic void htvec_mask_irq(struct irq_data *d)\n{\n\tu32 reg;\n\tvoid __iomem *addr;\n\tstruct htvec *priv = irq_data_get_irq_chip_data(d);\n\n\traw_spin_lock(&priv->htvec_lock);\n\taddr = priv->base + HTVEC_EN_OFF;\n\taddr += VEC_REG_IDX(d->hwirq) * 4;\n\treg = readl(addr);\n\treg &= ~BIT(VEC_REG_BIT(d->hwirq));\n\twritel(reg, addr);\n\traw_spin_unlock(&priv->htvec_lock);\n}\n\nstatic void htvec_unmask_irq(struct irq_data *d)\n{\n\tu32 reg;\n\tvoid __iomem *addr;\n\tstruct htvec *priv = irq_data_get_irq_chip_data(d);\n\n\traw_spin_lock(&priv->htvec_lock);\n\taddr = priv->base + HTVEC_EN_OFF;\n\taddr += VEC_REG_IDX(d->hwirq) * 4;\n\treg = readl(addr);\n\treg |= BIT(VEC_REG_BIT(d->hwirq));\n\twritel(reg, addr);\n\traw_spin_unlock(&priv->htvec_lock);\n}\n\nstatic struct irq_chip htvec_irq_chip = {\n\t.name\t\t\t= \"LOONGSON_HTVEC\",\n\t.irq_mask\t\t= htvec_mask_irq,\n\t.irq_unmask\t\t= htvec_unmask_irq,\n\t.irq_ack\t\t= htvec_ack_irq,\n};\n\nstatic int htvec_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs, void *arg)\n{\n\tint ret;\n\tunsigned long hwirq;\n\tunsigned int type, i;\n\tstruct htvec *priv = domain->host_data;\n\n\tret = irq_domain_translate_onecell(domain, arg, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_domain_set_info(domain, virq + i, hwirq + i, &htvec_irq_chip,\n\t\t\t\t    priv, handle_edge_irq, NULL, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic void htvec_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq + i);\n\n\t\tirq_set_handler(virq + i, NULL);\n\t\tirq_domain_reset_irq_data(d);\n\t}\n}\n\nstatic const struct irq_domain_ops htvec_domain_ops = {\n\t.translate\t= irq_domain_translate_onecell,\n\t.alloc\t\t= htvec_domain_alloc,\n\t.free\t\t= htvec_domain_free,\n};\n\nstatic void htvec_reset(struct htvec *priv)\n{\n\tu32 idx;\n\n\t \n\tfor (idx = 0; idx < priv->num_parents; idx++) {\n\t\twritel_relaxed(0x0, priv->base + HTVEC_EN_OFF + 4 * idx);\n\t\twritel_relaxed(0xFFFFFFFF, priv->base + 4 * idx);\n\t}\n}\n\nstatic int htvec_suspend(void)\n{\n\tint i;\n\n\tfor (i = 0; i < htvec_priv->num_parents; i++)\n\t\thtvec_priv->saved_vec_en[i] = readl(htvec_priv->base + HTVEC_EN_OFF + 4 * i);\n\n\treturn 0;\n}\n\nstatic void htvec_resume(void)\n{\n\tint i;\n\n\tfor (i = 0; i < htvec_priv->num_parents; i++)\n\t\twritel(htvec_priv->saved_vec_en[i], htvec_priv->base + HTVEC_EN_OFF + 4 * i);\n}\n\nstatic struct syscore_ops htvec_syscore_ops = {\n\t.suspend = htvec_suspend,\n\t.resume = htvec_resume,\n};\n\nstatic int htvec_init(phys_addr_t addr, unsigned long size,\n\t\tint num_parents, int parent_irq[], struct fwnode_handle *domain_handle)\n{\n\tint i;\n\tstruct htvec *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->num_parents = num_parents;\n\tpriv->base = ioremap(addr, size);\n\traw_spin_lock_init(&priv->htvec_lock);\n\n\t \n\tpriv->htvec_domain = irq_domain_create_linear(domain_handle,\n\t\t\t\t\t(VEC_COUNT_PER_REG * priv->num_parents),\n\t\t\t\t\t&htvec_domain_ops, priv);\n\tif (!priv->htvec_domain) {\n\t\tpr_err(\"loongson-htvec: cannot add IRQ domain\\n\");\n\t\tgoto iounmap_base;\n\t}\n\n\thtvec_reset(priv);\n\n\tfor (i = 0; i < priv->num_parents; i++) {\n\t\tirq_set_chained_handler_and_data(parent_irq[i],\n\t\t\t\t\t\t htvec_irq_dispatch, priv);\n\t}\n\n\thtvec_priv = priv;\n\n\tregister_syscore_ops(&htvec_syscore_ops);\n\n\treturn 0;\n\niounmap_base:\n\tiounmap(priv->base);\n\tkfree(priv);\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_OF\n\nstatic int htvec_of_init(struct device_node *node,\n\t\t\t\tstruct device_node *parent)\n{\n\tint i, err;\n\tint parent_irq[8];\n\tint num_parents = 0;\n\tstruct resource res;\n\n\tif (of_address_to_resource(node, 0, &res))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < HTVEC_MAX_PARENT_IRQ; i++) {\n\t\tparent_irq[i] = irq_of_parse_and_map(node, i);\n\t\tif (parent_irq[i] <= 0)\n\t\t\tbreak;\n\n\t\tnum_parents++;\n\t}\n\n\terr = htvec_init(res.start, resource_size(&res),\n\t\t\tnum_parents, parent_irq, of_node_to_fwnode(node));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(htvec, \"loongson,htvec-1.0\", htvec_of_init);\n\n#endif\n\n#ifdef CONFIG_ACPI\nstatic int __init pch_pic_parse_madt(union acpi_subtable_headers *header,\n\t\t\t\t\tconst unsigned long end)\n{\n\tstruct acpi_madt_bio_pic *pchpic_entry = (struct acpi_madt_bio_pic *)header;\n\n\treturn pch_pic_acpi_init(htvec_priv->htvec_domain, pchpic_entry);\n}\n\nstatic int __init pch_msi_parse_madt(union acpi_subtable_headers *header,\n\t\t\t\t\tconst unsigned long end)\n{\n\tstruct acpi_madt_msi_pic *pchmsi_entry = (struct acpi_madt_msi_pic *)header;\n\n\treturn pch_msi_acpi_init(htvec_priv->htvec_domain, pchmsi_entry);\n}\n\nstatic int __init acpi_cascade_irqdomain_init(void)\n{\n\tint r;\n\n\tr = acpi_table_parse_madt(ACPI_MADT_TYPE_BIO_PIC, pch_pic_parse_madt, 0);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = acpi_table_parse_madt(ACPI_MADT_TYPE_MSI_PIC, pch_msi_parse_madt, 0);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nint __init htvec_acpi_init(struct irq_domain *parent,\n\t\t\t\t   struct acpi_madt_ht_pic *acpi_htvec)\n{\n\tint i, ret;\n\tint num_parents, parent_irq[8];\n\tstruct fwnode_handle *domain_handle;\n\n\tif (!acpi_htvec)\n\t\treturn -EINVAL;\n\n\tnum_parents = HTVEC_MAX_PARENT_IRQ;\n\n\tdomain_handle = irq_domain_alloc_fwnode(&acpi_htvec->address);\n\tif (!domain_handle) {\n\t\tpr_err(\"Unable to allocate domain handle\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < HTVEC_MAX_PARENT_IRQ; i++)\n\t\tparent_irq[i] = irq_create_mapping(parent, acpi_htvec->cascade[i]);\n\n\tret = htvec_init(acpi_htvec->address, acpi_htvec->size,\n\t\t\tnum_parents, parent_irq, domain_handle);\n\n\tif (ret == 0)\n\t\tret = acpi_cascade_irqdomain_init();\n\telse\n\t\tirq_domain_free_fwnode(domain_handle);\n\n\treturn ret;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}