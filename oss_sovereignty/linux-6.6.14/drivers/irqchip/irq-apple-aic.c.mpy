{
  "module_name": "irq-apple-aic.c",
  "hash_id": "860ecd8085bc3571c1415804dfea182f21cae079d9e47a787a74a6c7b7a3d2ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-apple-aic.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/cpuhotplug.h>\n#include <linux/io.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/arm-vgic-info.h>\n#include <linux/irqdomain.h>\n#include <linux/jump_label.h>\n#include <linux/limits.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <asm/apple_m1_pmu.h>\n#include <asm/cputype.h>\n#include <asm/exception.h>\n#include <asm/sysreg.h>\n#include <asm/virt.h>\n\n#include <dt-bindings/interrupt-controller/apple-aic.h>\n\n \n\n#define AIC_INFO\t\t0x0004\n#define AIC_INFO_NR_IRQ\t\tGENMASK(15, 0)\n\n#define AIC_CONFIG\t\t0x0010\n\n#define AIC_WHOAMI\t\t0x2000\n#define AIC_EVENT\t\t0x2004\n#define AIC_EVENT_DIE\t\tGENMASK(31, 24)\n#define AIC_EVENT_TYPE\t\tGENMASK(23, 16)\n#define AIC_EVENT_NUM\t\tGENMASK(15, 0)\n\n#define AIC_EVENT_TYPE_FIQ\t0  \n#define AIC_EVENT_TYPE_IRQ\t1\n#define AIC_EVENT_TYPE_IPI\t4\n#define AIC_EVENT_IPI_OTHER\t1\n#define AIC_EVENT_IPI_SELF\t2\n\n#define AIC_IPI_SEND\t\t0x2008\n#define AIC_IPI_ACK\t\t0x200c\n#define AIC_IPI_MASK_SET\t0x2024\n#define AIC_IPI_MASK_CLR\t0x2028\n\n#define AIC_IPI_SEND_CPU(cpu)\tBIT(cpu)\n\n#define AIC_IPI_OTHER\t\tBIT(0)\n#define AIC_IPI_SELF\t\tBIT(31)\n\n#define AIC_TARGET_CPU\t\t0x3000\n\n#define AIC_CPU_IPI_SET(cpu)\t(0x5008 + ((cpu) << 7))\n#define AIC_CPU_IPI_CLR(cpu)\t(0x500c + ((cpu) << 7))\n#define AIC_CPU_IPI_MASK_SET(cpu) (0x5024 + ((cpu) << 7))\n#define AIC_CPU_IPI_MASK_CLR(cpu) (0x5028 + ((cpu) << 7))\n\n#define AIC_MAX_IRQ\t\t0x400\n\n \n\n#define AIC2_VERSION\t\t0x0000\n#define AIC2_VERSION_VER\tGENMASK(7, 0)\n\n#define AIC2_INFO1\t\t0x0004\n#define AIC2_INFO1_NR_IRQ\tGENMASK(15, 0)\n#define AIC2_INFO1_LAST_DIE\tGENMASK(27, 24)\n\n#define AIC2_INFO2\t\t0x0008\n\n#define AIC2_INFO3\t\t0x000c\n#define AIC2_INFO3_MAX_IRQ\tGENMASK(15, 0)\n#define AIC2_INFO3_MAX_DIE\tGENMASK(27, 24)\n\n#define AIC2_RESET\t\t0x0010\n#define AIC2_RESET_RESET\tBIT(0)\n\n#define AIC2_CONFIG\t\t0x0014\n#define AIC2_CONFIG_ENABLE\tBIT(0)\n#define AIC2_CONFIG_PREFER_PCPU\tBIT(28)\n\n#define AIC2_TIMEOUT\t\t0x0028\n#define AIC2_CLUSTER_PRIO\t0x0030\n#define AIC2_DELAY_GROUPS\t0x0100\n\n#define AIC2_IRQ_CFG\t\t0x2000\n\n \n\n#define AIC2_IRQ_CFG_TARGET\tGENMASK(3, 0)\n#define AIC2_IRQ_CFG_DELAY_IDX\tGENMASK(7, 5)\n\n#define MASK_REG(x)\t\t(4 * ((x) >> 5))\n#define MASK_BIT(x)\t\tBIT((x) & GENMASK(4, 0))\n\n \n\n \n#define SYS_IMP_APL_IPI_RR_LOCAL_EL1\tsys_reg(3, 5, 15, 0, 0)\n#define SYS_IMP_APL_IPI_RR_GLOBAL_EL1\tsys_reg(3, 5, 15, 0, 1)\n#define IPI_RR_CPU\t\t\tGENMASK(7, 0)\n \n#define IPI_RR_CLUSTER\t\t\tGENMASK(23, 16)\n#define IPI_RR_TYPE\t\t\tGENMASK(29, 28)\n#define IPI_RR_IMMEDIATE\t\t0\n#define IPI_RR_RETRACT\t\t\t1\n#define IPI_RR_DEFERRED\t\t\t2\n#define IPI_RR_NOWAKE\t\t\t3\n\n \n#define SYS_IMP_APL_IPI_SR_EL1\t\tsys_reg(3, 5, 15, 1, 1)\n#define IPI_SR_PENDING\t\t\tBIT(0)\n\n \n#define SYS_IMP_APL_VM_TMR_FIQ_ENA_EL2\tsys_reg(3, 5, 15, 1, 3)\n#define VM_TMR_FIQ_ENABLE_V\t\tBIT(0)\n#define VM_TMR_FIQ_ENABLE_P\t\tBIT(1)\n\n \n#define SYS_IMP_APL_IPI_CR_EL1\t\tsys_reg(3, 5, 15, 3, 1)\n\n \n#define SYS_IMP_APL_UPMCR0_EL1\t\tsys_reg(3, 7, 15, 0, 4)\n#define UPMCR0_IMODE\t\t\tGENMASK(18, 16)\n#define UPMCR0_IMODE_OFF\t\t0\n#define UPMCR0_IMODE_AIC\t\t2\n#define UPMCR0_IMODE_HALT\t\t3\n#define UPMCR0_IMODE_FIQ\t\t4\n\n \n#define SYS_IMP_APL_UPMSR_EL1\t\tsys_reg(3, 7, 15, 6, 4)\n#define UPMSR_IACT\t\t\tBIT(0)\n\n \n#define MPIDR_CPU(x)\t\t\tMPIDR_AFFINITY_LEVEL(x, 0)\n#define MPIDR_CLUSTER(x)\t\tMPIDR_AFFINITY_LEVEL(x, 1)\n\n#define AIC_IRQ_HWIRQ(die, irq)\t(FIELD_PREP(AIC_EVENT_DIE, die) | \\\n\t\t\t\t FIELD_PREP(AIC_EVENT_TYPE, AIC_EVENT_TYPE_IRQ) | \\\n\t\t\t\t FIELD_PREP(AIC_EVENT_NUM, irq))\n#define AIC_FIQ_HWIRQ(x)\t(FIELD_PREP(AIC_EVENT_TYPE, AIC_EVENT_TYPE_FIQ) | \\\n\t\t\t\t FIELD_PREP(AIC_EVENT_NUM, x))\n#define AIC_HWIRQ_IRQ(x)\tFIELD_GET(AIC_EVENT_NUM, x)\n#define AIC_HWIRQ_DIE(x)\tFIELD_GET(AIC_EVENT_DIE, x)\n#define AIC_NR_SWIPI\t\t32\n\n \nenum fiq_hwirq {\n\t \n\tAIC_TMR_EL0_PHYS\t= AIC_TMR_HV_PHYS,\n\tAIC_TMR_EL0_VIRT\t= AIC_TMR_HV_VIRT,\n\tAIC_TMR_EL02_PHYS\t= AIC_TMR_GUEST_PHYS,\n\tAIC_TMR_EL02_VIRT\t= AIC_TMR_GUEST_VIRT,\n\tAIC_CPU_PMU_Effi\t= AIC_CPU_PMU_E,\n\tAIC_CPU_PMU_Perf\t= AIC_CPU_PMU_P,\n\t \n\tAIC_VGIC_MI,\n\tAIC_NR_FIQ\n};\n\nstatic DEFINE_STATIC_KEY_TRUE(use_fast_ipi);\n\nstruct aic_info {\n\tint version;\n\n\t \n\tu32 event;\n\tu32 target_cpu;\n\tu32 irq_cfg;\n\tu32 sw_set;\n\tu32 sw_clr;\n\tu32 mask_set;\n\tu32 mask_clr;\n\n\tu32 die_stride;\n\n\t \n\tbool fast_ipi;\n};\n\nstatic const struct aic_info aic1_info __initconst = {\n\t.version\t= 1,\n\n\t.event\t\t= AIC_EVENT,\n\t.target_cpu\t= AIC_TARGET_CPU,\n};\n\nstatic const struct aic_info aic1_fipi_info __initconst = {\n\t.version\t= 1,\n\n\t.event\t\t= AIC_EVENT,\n\t.target_cpu\t= AIC_TARGET_CPU,\n\n\t.fast_ipi\t= true,\n};\n\nstatic const struct aic_info aic2_info __initconst = {\n\t.version\t= 2,\n\n\t.irq_cfg\t= AIC2_IRQ_CFG,\n\n\t.fast_ipi\t= true,\n};\n\nstatic const struct of_device_id aic_info_match[] = {\n\t{\n\t\t.compatible = \"apple,t8103-aic\",\n\t\t.data = &aic1_fipi_info,\n\t},\n\t{\n\t\t.compatible = \"apple,aic\",\n\t\t.data = &aic1_info,\n\t},\n\t{\n\t\t.compatible = \"apple,aic2\",\n\t\t.data = &aic2_info,\n\t},\n\t{}\n};\n\nstruct aic_irq_chip {\n\tvoid __iomem *base;\n\tvoid __iomem *event;\n\tstruct irq_domain *hw_domain;\n\tstruct {\n\t\tcpumask_t aff;\n\t} *fiq_aff[AIC_NR_FIQ];\n\n\tint nr_irq;\n\tint max_irq;\n\tint nr_die;\n\tint max_die;\n\n\tstruct aic_info info;\n};\n\nstatic DEFINE_PER_CPU(uint32_t, aic_fiq_unmasked);\n\nstatic struct aic_irq_chip *aic_irqc;\n\nstatic void aic_handle_ipi(struct pt_regs *regs);\n\nstatic u32 aic_ic_read(struct aic_irq_chip *ic, u32 reg)\n{\n\treturn readl_relaxed(ic->base + reg);\n}\n\nstatic void aic_ic_write(struct aic_irq_chip *ic, u32 reg, u32 val)\n{\n\twritel_relaxed(val, ic->base + reg);\n}\n\n \n\nstatic void aic_irq_mask(struct irq_data *d)\n{\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tstruct aic_irq_chip *ic = irq_data_get_irq_chip_data(d);\n\n\tu32 off = AIC_HWIRQ_DIE(hwirq) * ic->info.die_stride;\n\tu32 irq = AIC_HWIRQ_IRQ(hwirq);\n\n\taic_ic_write(ic, ic->info.mask_set + off + MASK_REG(irq), MASK_BIT(irq));\n}\n\nstatic void aic_irq_unmask(struct irq_data *d)\n{\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tstruct aic_irq_chip *ic = irq_data_get_irq_chip_data(d);\n\n\tu32 off = AIC_HWIRQ_DIE(hwirq) * ic->info.die_stride;\n\tu32 irq = AIC_HWIRQ_IRQ(hwirq);\n\n\taic_ic_write(ic, ic->info.mask_clr + off + MASK_REG(irq), MASK_BIT(irq));\n}\n\nstatic void aic_irq_eoi(struct irq_data *d)\n{\n\t \n\tif (!irqd_irq_masked(d))\n\t\taic_irq_unmask(d);\n}\n\nstatic void __exception_irq_entry aic_handle_irq(struct pt_regs *regs)\n{\n\tstruct aic_irq_chip *ic = aic_irqc;\n\tu32 event, type, irq;\n\n\tdo {\n\t\t \n\t\tevent = readl(ic->event + ic->info.event);\n\t\ttype = FIELD_GET(AIC_EVENT_TYPE, event);\n\t\tirq = FIELD_GET(AIC_EVENT_NUM, event);\n\n\t\tif (type == AIC_EVENT_TYPE_IRQ)\n\t\t\tgeneric_handle_domain_irq(aic_irqc->hw_domain, event);\n\t\telse if (type == AIC_EVENT_TYPE_IPI && irq == 1)\n\t\t\taic_handle_ipi(regs);\n\t\telse if (event != 0)\n\t\t\tpr_err_ratelimited(\"Unknown IRQ event %d, %d\\n\", type, irq);\n\t} while (event);\n\n\t \n\tif (is_kernel_in_hyp_mode() &&\n\t    (read_sysreg_s(SYS_ICH_HCR_EL2) & ICH_HCR_EN) &&\n\t    read_sysreg_s(SYS_ICH_MISR_EL2) != 0) {\n\t\tgeneric_handle_domain_irq(aic_irqc->hw_domain,\n\t\t\t\t\t  AIC_FIQ_HWIRQ(AIC_VGIC_MI));\n\n\t\tif (unlikely((read_sysreg_s(SYS_ICH_HCR_EL2) & ICH_HCR_EN) &&\n\t\t\t     read_sysreg_s(SYS_ICH_MISR_EL2))) {\n\t\t\tpr_err_ratelimited(\"vGIC IRQ fired and not handled by KVM, disabling.\\n\");\n\t\t\tsysreg_clear_set_s(SYS_ICH_HCR_EL2, ICH_HCR_EN, 0);\n\t\t}\n\t}\n}\n\nstatic int aic_irq_set_affinity(struct irq_data *d,\n\t\t\t\tconst struct cpumask *mask_val, bool force)\n{\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tstruct aic_irq_chip *ic = irq_data_get_irq_chip_data(d);\n\tint cpu;\n\n\tBUG_ON(!ic->info.target_cpu);\n\n\tif (force)\n\t\tcpu = cpumask_first(mask_val);\n\telse\n\t\tcpu = cpumask_any_and(mask_val, cpu_online_mask);\n\n\taic_ic_write(ic, ic->info.target_cpu + AIC_HWIRQ_IRQ(hwirq) * 4, BIT(cpu));\n\tirq_data_update_effective_affinity(d, cpumask_of(cpu));\n\n\treturn IRQ_SET_MASK_OK;\n}\n\nstatic int aic_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\t \n\treturn (type == IRQ_TYPE_LEVEL_HIGH || type == IRQ_TYPE_EDGE_RISING) ? 0 : -EINVAL;\n}\n\nstatic struct irq_chip aic_chip = {\n\t.name = \"AIC\",\n\t.irq_mask = aic_irq_mask,\n\t.irq_unmask = aic_irq_unmask,\n\t.irq_eoi = aic_irq_eoi,\n\t.irq_set_affinity = aic_irq_set_affinity,\n\t.irq_set_type = aic_irq_set_type,\n};\n\nstatic struct irq_chip aic2_chip = {\n\t.name = \"AIC2\",\n\t.irq_mask = aic_irq_mask,\n\t.irq_unmask = aic_irq_unmask,\n\t.irq_eoi = aic_irq_eoi,\n\t.irq_set_type = aic_irq_set_type,\n};\n\n \n\nstatic unsigned long aic_fiq_get_idx(struct irq_data *d)\n{\n\treturn AIC_HWIRQ_IRQ(irqd_to_hwirq(d));\n}\n\nstatic void aic_fiq_set_mask(struct irq_data *d)\n{\n\t \n\tswitch (aic_fiq_get_idx(d)) {\n\tcase AIC_TMR_EL02_PHYS:\n\t\tsysreg_clear_set_s(SYS_IMP_APL_VM_TMR_FIQ_ENA_EL2, VM_TMR_FIQ_ENABLE_P, 0);\n\t\tisb();\n\t\tbreak;\n\tcase AIC_TMR_EL02_VIRT:\n\t\tsysreg_clear_set_s(SYS_IMP_APL_VM_TMR_FIQ_ENA_EL2, VM_TMR_FIQ_ENABLE_V, 0);\n\t\tisb();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void aic_fiq_clear_mask(struct irq_data *d)\n{\n\tswitch (aic_fiq_get_idx(d)) {\n\tcase AIC_TMR_EL02_PHYS:\n\t\tsysreg_clear_set_s(SYS_IMP_APL_VM_TMR_FIQ_ENA_EL2, 0, VM_TMR_FIQ_ENABLE_P);\n\t\tisb();\n\t\tbreak;\n\tcase AIC_TMR_EL02_VIRT:\n\t\tsysreg_clear_set_s(SYS_IMP_APL_VM_TMR_FIQ_ENA_EL2, 0, VM_TMR_FIQ_ENABLE_V);\n\t\tisb();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void aic_fiq_mask(struct irq_data *d)\n{\n\taic_fiq_set_mask(d);\n\t__this_cpu_and(aic_fiq_unmasked, ~BIT(aic_fiq_get_idx(d)));\n}\n\nstatic void aic_fiq_unmask(struct irq_data *d)\n{\n\taic_fiq_clear_mask(d);\n\t__this_cpu_or(aic_fiq_unmasked, BIT(aic_fiq_get_idx(d)));\n}\n\nstatic void aic_fiq_eoi(struct irq_data *d)\n{\n\t \n\tif (__this_cpu_read(aic_fiq_unmasked) & BIT(aic_fiq_get_idx(d)))\n\t\taic_fiq_clear_mask(d);\n}\n\n#define TIMER_FIRING(x)                                                        \\\n\t(((x) & (ARCH_TIMER_CTRL_ENABLE | ARCH_TIMER_CTRL_IT_MASK |            \\\n\t\t ARCH_TIMER_CTRL_IT_STAT)) ==                                  \\\n\t (ARCH_TIMER_CTRL_ENABLE | ARCH_TIMER_CTRL_IT_STAT))\n\nstatic void __exception_irq_entry aic_handle_fiq(struct pt_regs *regs)\n{\n\t \n\n\tif (read_sysreg_s(SYS_IMP_APL_IPI_SR_EL1) & IPI_SR_PENDING) {\n\t\tif (static_branch_likely(&use_fast_ipi)) {\n\t\t\taic_handle_ipi(regs);\n\t\t} else {\n\t\t\tpr_err_ratelimited(\"Fast IPI fired. Acking.\\n\");\n\t\t\twrite_sysreg_s(IPI_SR_PENDING, SYS_IMP_APL_IPI_SR_EL1);\n\t\t}\n\t}\n\n\tif (TIMER_FIRING(read_sysreg(cntp_ctl_el0)))\n\t\tgeneric_handle_domain_irq(aic_irqc->hw_domain,\n\t\t\t\t\t  AIC_FIQ_HWIRQ(AIC_TMR_EL0_PHYS));\n\n\tif (TIMER_FIRING(read_sysreg(cntv_ctl_el0)))\n\t\tgeneric_handle_domain_irq(aic_irqc->hw_domain,\n\t\t\t\t\t  AIC_FIQ_HWIRQ(AIC_TMR_EL0_VIRT));\n\n\tif (is_kernel_in_hyp_mode()) {\n\t\tuint64_t enabled = read_sysreg_s(SYS_IMP_APL_VM_TMR_FIQ_ENA_EL2);\n\n\t\tif ((enabled & VM_TMR_FIQ_ENABLE_P) &&\n\t\t    TIMER_FIRING(read_sysreg_s(SYS_CNTP_CTL_EL02)))\n\t\t\tgeneric_handle_domain_irq(aic_irqc->hw_domain,\n\t\t\t\t\t\t  AIC_FIQ_HWIRQ(AIC_TMR_EL02_PHYS));\n\n\t\tif ((enabled & VM_TMR_FIQ_ENABLE_V) &&\n\t\t    TIMER_FIRING(read_sysreg_s(SYS_CNTV_CTL_EL02)))\n\t\t\tgeneric_handle_domain_irq(aic_irqc->hw_domain,\n\t\t\t\t\t\t  AIC_FIQ_HWIRQ(AIC_TMR_EL02_VIRT));\n\t}\n\n\tif (read_sysreg_s(SYS_IMP_APL_PMCR0_EL1) & PMCR0_IACT) {\n\t\tint irq;\n\t\tif (cpumask_test_cpu(smp_processor_id(),\n\t\t\t\t     &aic_irqc->fiq_aff[AIC_CPU_PMU_P]->aff))\n\t\t\tirq = AIC_CPU_PMU_P;\n\t\telse\n\t\t\tirq = AIC_CPU_PMU_E;\n\t\tgeneric_handle_domain_irq(aic_irqc->hw_domain,\n\t\t\t\t\t  AIC_FIQ_HWIRQ(irq));\n\t}\n\n\tif (FIELD_GET(UPMCR0_IMODE, read_sysreg_s(SYS_IMP_APL_UPMCR0_EL1)) == UPMCR0_IMODE_FIQ &&\n\t\t\t(read_sysreg_s(SYS_IMP_APL_UPMSR_EL1) & UPMSR_IACT)) {\n\t\t \n\t\tpr_err_ratelimited(\"Uncore PMC FIQ fired. Masking.\\n\");\n\t\tsysreg_clear_set_s(SYS_IMP_APL_UPMCR0_EL1, UPMCR0_IMODE,\n\t\t\t\t   FIELD_PREP(UPMCR0_IMODE, UPMCR0_IMODE_OFF));\n\t}\n}\n\nstatic int aic_fiq_set_type(struct irq_data *d, unsigned int type)\n{\n\treturn (type == IRQ_TYPE_LEVEL_HIGH) ? 0 : -EINVAL;\n}\n\nstatic struct irq_chip fiq_chip = {\n\t.name = \"AIC-FIQ\",\n\t.irq_mask = aic_fiq_mask,\n\t.irq_unmask = aic_fiq_unmask,\n\t.irq_ack = aic_fiq_set_mask,\n\t.irq_eoi = aic_fiq_eoi,\n\t.irq_set_type = aic_fiq_set_type,\n};\n\n \n\nstatic int aic_irq_domain_map(struct irq_domain *id, unsigned int irq,\n\t\t\t      irq_hw_number_t hw)\n{\n\tstruct aic_irq_chip *ic = id->host_data;\n\tu32 type = FIELD_GET(AIC_EVENT_TYPE, hw);\n\tstruct irq_chip *chip = &aic_chip;\n\n\tif (ic->info.version == 2)\n\t\tchip = &aic2_chip;\n\n\tif (type == AIC_EVENT_TYPE_IRQ) {\n\t\tirq_domain_set_info(id, irq, hw, chip, id->host_data,\n\t\t\t\t    handle_fasteoi_irq, NULL, NULL);\n\t\tirqd_set_single_target(irq_desc_get_irq_data(irq_to_desc(irq)));\n\t} else {\n\t\tint fiq = FIELD_GET(AIC_EVENT_NUM, hw);\n\n\t\tswitch (fiq) {\n\t\tcase AIC_CPU_PMU_P:\n\t\tcase AIC_CPU_PMU_E:\n\t\t\tirq_set_percpu_devid_partition(irq, &ic->fiq_aff[fiq]->aff);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tirq_set_percpu_devid(irq);\n\t\t\tbreak;\n\t\t}\n\n\t\tirq_domain_set_info(id, irq, hw, &fiq_chip, id->host_data,\n\t\t\t\t    handle_percpu_devid_irq, NULL, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int aic_irq_domain_translate(struct irq_domain *id,\n\t\t\t\t    struct irq_fwspec *fwspec,\n\t\t\t\t    unsigned long *hwirq,\n\t\t\t\t    unsigned int *type)\n{\n\tstruct aic_irq_chip *ic = id->host_data;\n\tu32 *args;\n\tu32 die = 0;\n\n\tif (fwspec->param_count < 3 || fwspec->param_count > 4 ||\n\t    !is_of_node(fwspec->fwnode))\n\t\treturn -EINVAL;\n\n\targs = &fwspec->param[1];\n\n\tif (fwspec->param_count == 4) {\n\t\tdie = args[0];\n\t\targs++;\n\t}\n\n\tswitch (fwspec->param[0]) {\n\tcase AIC_IRQ:\n\t\tif (die >= ic->nr_die)\n\t\t\treturn -EINVAL;\n\t\tif (args[0] >= ic->nr_irq)\n\t\t\treturn -EINVAL;\n\t\t*hwirq = AIC_IRQ_HWIRQ(die, args[0]);\n\t\tbreak;\n\tcase AIC_FIQ:\n\t\tif (die != 0)\n\t\t\treturn -EINVAL;\n\t\tif (args[0] >= AIC_NR_FIQ)\n\t\t\treturn -EINVAL;\n\t\t*hwirq = AIC_FIQ_HWIRQ(args[0]);\n\n\t\t \n\t\tif (!is_kernel_in_hyp_mode()) {\n\t\t\tswitch (args[0]) {\n\t\t\tcase AIC_TMR_GUEST_PHYS:\n\t\t\t\t*hwirq = AIC_FIQ_HWIRQ(AIC_TMR_EL0_PHYS);\n\t\t\t\tbreak;\n\t\t\tcase AIC_TMR_GUEST_VIRT:\n\t\t\t\t*hwirq = AIC_FIQ_HWIRQ(AIC_TMR_EL0_VIRT);\n\t\t\t\tbreak;\n\t\t\tcase AIC_TMR_HV_PHYS:\n\t\t\tcase AIC_TMR_HV_VIRT:\n\t\t\t\treturn -ENOENT;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*type = args[1] & IRQ_TYPE_SENSE_MASK;\n\n\treturn 0;\n}\n\nstatic int aic_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs, void *arg)\n{\n\tunsigned int type = IRQ_TYPE_NONE;\n\tstruct irq_fwspec *fwspec = arg;\n\tirq_hw_number_t hwirq;\n\tint i, ret;\n\n\tret = aic_irq_domain_translate(domain, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tret = aic_irq_domain_map(domain, virq + i, hwirq + i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void aic_irq_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq + i);\n\n\t\tirq_set_handler(virq + i, NULL);\n\t\tirq_domain_reset_irq_data(d);\n\t}\n}\n\nstatic const struct irq_domain_ops aic_irq_domain_ops = {\n\t.translate\t= aic_irq_domain_translate,\n\t.alloc\t\t= aic_irq_domain_alloc,\n\t.free\t\t= aic_irq_domain_free,\n};\n\n \n\nstatic void aic_ipi_send_fast(int cpu)\n{\n\tu64 mpidr = cpu_logical_map(cpu);\n\tu64 my_mpidr = read_cpuid_mpidr();\n\tu64 cluster = MPIDR_CLUSTER(mpidr);\n\tu64 idx = MPIDR_CPU(mpidr);\n\n\tif (MPIDR_CLUSTER(my_mpidr) == cluster)\n\t\twrite_sysreg_s(FIELD_PREP(IPI_RR_CPU, idx),\n\t\t\t       SYS_IMP_APL_IPI_RR_LOCAL_EL1);\n\telse\n\t\twrite_sysreg_s(FIELD_PREP(IPI_RR_CPU, idx) | FIELD_PREP(IPI_RR_CLUSTER, cluster),\n\t\t\t       SYS_IMP_APL_IPI_RR_GLOBAL_EL1);\n\tisb();\n}\n\nstatic void aic_handle_ipi(struct pt_regs *regs)\n{\n\t \n\tif (static_branch_likely(&use_fast_ipi)) {\n\t\twrite_sysreg_s(IPI_SR_PENDING, SYS_IMP_APL_IPI_SR_EL1);\n\t\tisb();\n\t} else {\n\t\taic_ic_write(aic_irqc, AIC_IPI_ACK, AIC_IPI_OTHER);\n\t}\n\n\tipi_mux_process();\n\n\t \n\tif (!static_branch_likely(&use_fast_ipi))\n\t\taic_ic_write(aic_irqc, AIC_IPI_MASK_CLR, AIC_IPI_OTHER);\n}\n\nstatic void aic_ipi_send_single(unsigned int cpu)\n{\n\tif (static_branch_likely(&use_fast_ipi))\n\t\taic_ipi_send_fast(cpu);\n\telse\n\t\taic_ic_write(aic_irqc, AIC_IPI_SEND, AIC_IPI_SEND_CPU(cpu));\n}\n\nstatic int __init aic_init_smp(struct aic_irq_chip *irqc, struct device_node *node)\n{\n\tint base_ipi;\n\n\tbase_ipi = ipi_mux_create(AIC_NR_SWIPI, aic_ipi_send_single);\n\tif (WARN_ON(base_ipi <= 0))\n\t\treturn -ENODEV;\n\n\tset_smp_ipi_range(base_ipi, AIC_NR_SWIPI);\n\n\treturn 0;\n}\n\nstatic int aic_init_cpu(unsigned int cpu)\n{\n\t \n\n\t \n\twrite_sysreg_s(IPI_SR_PENDING, SYS_IMP_APL_IPI_SR_EL1);\n\n\t \n\tsysreg_clear_set(cntp_ctl_el0, 0, ARCH_TIMER_CTRL_IT_MASK);\n\tsysreg_clear_set(cntv_ctl_el0, 0, ARCH_TIMER_CTRL_IT_MASK);\n\n\t \n\tif (is_kernel_in_hyp_mode()) {\n\t\t \n\t\tsysreg_clear_set_s(SYS_IMP_APL_VM_TMR_FIQ_ENA_EL2,\n\t\t\t\t   VM_TMR_FIQ_ENABLE_V | VM_TMR_FIQ_ENABLE_P, 0);\n\n\t\t \n\t\tsysreg_clear_set_s(SYS_ICH_HCR_EL2, ICH_HCR_EN, 0);\n\t}\n\n\t \n\tsysreg_clear_set_s(SYS_IMP_APL_PMCR0_EL1, PMCR0_IMODE | PMCR0_IACT,\n\t\t\t   FIELD_PREP(PMCR0_IMODE, PMCR0_IMODE_OFF));\n\n\t \n\tsysreg_clear_set_s(SYS_IMP_APL_UPMCR0_EL1, UPMCR0_IMODE,\n\t\t\t   FIELD_PREP(UPMCR0_IMODE, UPMCR0_IMODE_OFF));\n\n\t \n\tisb();\n\n\tif (aic_irqc->info.version == 1) {\n\t\t \n\t\tWARN_ON(aic_ic_read(aic_irqc, AIC_WHOAMI) != smp_processor_id());\n\n\t\t \n\t\taic_ic_write(aic_irqc, AIC_IPI_ACK, AIC_IPI_SELF | AIC_IPI_OTHER);\n\t\tif (static_branch_likely(&use_fast_ipi)) {\n\t\t\taic_ic_write(aic_irqc, AIC_IPI_MASK_SET, AIC_IPI_SELF | AIC_IPI_OTHER);\n\t\t} else {\n\t\t\taic_ic_write(aic_irqc, AIC_IPI_MASK_SET, AIC_IPI_SELF);\n\t\t\taic_ic_write(aic_irqc, AIC_IPI_MASK_CLR, AIC_IPI_OTHER);\n\t\t}\n\t}\n\n\t \n\t__this_cpu_write(aic_fiq_unmasked, 0);\n\n\treturn 0;\n}\n\nstatic struct gic_kvm_info vgic_info __initdata = {\n\t.type\t\t\t= GIC_V3,\n\t.no_maint_irq_mask\t= true,\n\t.no_hw_deactivation\t= true,\n};\n\nstatic void build_fiq_affinity(struct aic_irq_chip *ic, struct device_node *aff)\n{\n\tint i, n;\n\tu32 fiq;\n\n\tif (of_property_read_u32(aff, \"apple,fiq-index\", &fiq) ||\n\t    WARN_ON(fiq >= AIC_NR_FIQ) || ic->fiq_aff[fiq])\n\t\treturn;\n\n\tn = of_property_count_elems_of_size(aff, \"cpus\", sizeof(u32));\n\tif (WARN_ON(n < 0))\n\t\treturn;\n\n\tic->fiq_aff[fiq] = kzalloc(sizeof(*ic->fiq_aff[fiq]), GFP_KERNEL);\n\tif (!ic->fiq_aff[fiq])\n\t\treturn;\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct device_node *cpu_node;\n\t\tu32 cpu_phandle;\n\t\tint cpu;\n\n\t\tif (of_property_read_u32_index(aff, \"cpus\", i, &cpu_phandle))\n\t\t\tcontinue;\n\n\t\tcpu_node = of_find_node_by_phandle(cpu_phandle);\n\t\tif (WARN_ON(!cpu_node))\n\t\t\tcontinue;\n\n\t\tcpu = of_cpu_node_to_id(cpu_node);\n\t\tof_node_put(cpu_node);\n\t\tif (WARN_ON(cpu < 0))\n\t\t\tcontinue;\n\n\t\tcpumask_set_cpu(cpu, &ic->fiq_aff[fiq]->aff);\n\t}\n}\n\nstatic int __init aic_of_ic_init(struct device_node *node, struct device_node *parent)\n{\n\tint i, die;\n\tu32 off, start_off;\n\tvoid __iomem *regs;\n\tstruct aic_irq_chip *irqc;\n\tstruct device_node *affs;\n\tconst struct of_device_id *match;\n\n\tregs = of_iomap(node, 0);\n\tif (WARN_ON(!regs))\n\t\treturn -EIO;\n\n\tirqc = kzalloc(sizeof(*irqc), GFP_KERNEL);\n\tif (!irqc) {\n\t\tiounmap(regs);\n\t\treturn -ENOMEM;\n\t}\n\n\tirqc->base = regs;\n\n\tmatch = of_match_node(aic_info_match, node);\n\tif (!match)\n\t\tgoto err_unmap;\n\n\tirqc->info = *(struct aic_info *)match->data;\n\n\taic_irqc = irqc;\n\n\tswitch (irqc->info.version) {\n\tcase 1: {\n\t\tu32 info;\n\n\t\tinfo = aic_ic_read(irqc, AIC_INFO);\n\t\tirqc->nr_irq = FIELD_GET(AIC_INFO_NR_IRQ, info);\n\t\tirqc->max_irq = AIC_MAX_IRQ;\n\t\tirqc->nr_die = irqc->max_die = 1;\n\n\t\toff = start_off = irqc->info.target_cpu;\n\t\toff += sizeof(u32) * irqc->max_irq;  \n\n\t\tirqc->event = irqc->base;\n\n\t\tbreak;\n\t}\n\tcase 2: {\n\t\tu32 info1, info3;\n\n\t\tinfo1 = aic_ic_read(irqc, AIC2_INFO1);\n\t\tinfo3 = aic_ic_read(irqc, AIC2_INFO3);\n\n\t\tirqc->nr_irq = FIELD_GET(AIC2_INFO1_NR_IRQ, info1);\n\t\tirqc->max_irq = FIELD_GET(AIC2_INFO3_MAX_IRQ, info3);\n\t\tirqc->nr_die = FIELD_GET(AIC2_INFO1_LAST_DIE, info1) + 1;\n\t\tirqc->max_die = FIELD_GET(AIC2_INFO3_MAX_DIE, info3);\n\n\t\toff = start_off = irqc->info.irq_cfg;\n\t\toff += sizeof(u32) * irqc->max_irq;  \n\n\t\tirqc->event = of_iomap(node, 1);\n\t\tif (WARN_ON(!irqc->event))\n\t\t\tgoto err_unmap;\n\n\t\tbreak;\n\t}\n\t}\n\n\tirqc->info.sw_set = off;\n\toff += sizeof(u32) * (irqc->max_irq >> 5);  \n\tirqc->info.sw_clr = off;\n\toff += sizeof(u32) * (irqc->max_irq >> 5);  \n\tirqc->info.mask_set = off;\n\toff += sizeof(u32) * (irqc->max_irq >> 5);  \n\tirqc->info.mask_clr = off;\n\toff += sizeof(u32) * (irqc->max_irq >> 5);  \n\toff += sizeof(u32) * (irqc->max_irq >> 5);  \n\n\tif (irqc->info.fast_ipi)\n\t\tstatic_branch_enable(&use_fast_ipi);\n\telse\n\t\tstatic_branch_disable(&use_fast_ipi);\n\n\tirqc->info.die_stride = off - start_off;\n\n\tirqc->hw_domain = irq_domain_create_tree(of_node_to_fwnode(node),\n\t\t\t\t\t\t &aic_irq_domain_ops, irqc);\n\tif (WARN_ON(!irqc->hw_domain))\n\t\tgoto err_unmap;\n\n\tirq_domain_update_bus_token(irqc->hw_domain, DOMAIN_BUS_WIRED);\n\n\tif (aic_init_smp(irqc, node))\n\t\tgoto err_remove_domain;\n\n\taffs = of_get_child_by_name(node, \"affinities\");\n\tif (affs) {\n\t\tstruct device_node *chld;\n\n\t\tfor_each_child_of_node(affs, chld)\n\t\t\tbuild_fiq_affinity(irqc, chld);\n\t}\n\tof_node_put(affs);\n\n\tset_handle_irq(aic_handle_irq);\n\tset_handle_fiq(aic_handle_fiq);\n\n\toff = 0;\n\tfor (die = 0; die < irqc->nr_die; die++) {\n\t\tfor (i = 0; i < BITS_TO_U32(irqc->nr_irq); i++)\n\t\t\taic_ic_write(irqc, irqc->info.mask_set + off + i * 4, U32_MAX);\n\t\tfor (i = 0; i < BITS_TO_U32(irqc->nr_irq); i++)\n\t\t\taic_ic_write(irqc, irqc->info.sw_clr + off + i * 4, U32_MAX);\n\t\tif (irqc->info.target_cpu)\n\t\t\tfor (i = 0; i < irqc->nr_irq; i++)\n\t\t\t\taic_ic_write(irqc, irqc->info.target_cpu + off + i * 4, 1);\n\t\toff += irqc->info.die_stride;\n\t}\n\n\tif (irqc->info.version == 2) {\n\t\tu32 config = aic_ic_read(irqc, AIC2_CONFIG);\n\n\t\tconfig |= AIC2_CONFIG_ENABLE;\n\t\taic_ic_write(irqc, AIC2_CONFIG, config);\n\t}\n\n\tif (!is_kernel_in_hyp_mode())\n\t\tpr_info(\"Kernel running in EL1, mapping interrupts\");\n\n\tif (static_branch_likely(&use_fast_ipi))\n\t\tpr_info(\"Using Fast IPIs\");\n\n\tcpuhp_setup_state(CPUHP_AP_IRQ_APPLE_AIC_STARTING,\n\t\t\t  \"irqchip/apple-aic/ipi:starting\",\n\t\t\t  aic_init_cpu, NULL);\n\n\tif (is_kernel_in_hyp_mode()) {\n\t\tstruct irq_fwspec mi = {\n\t\t\t.fwnode\t\t= of_node_to_fwnode(node),\n\t\t\t.param_count\t= 3,\n\t\t\t.param\t\t= {\n\t\t\t\t[0]\t= AIC_FIQ,  \n\t\t\t\t[1]\t= AIC_VGIC_MI,\n\t\t\t\t[2]\t= IRQ_TYPE_LEVEL_HIGH,\n\t\t\t},\n\t\t};\n\n\t\tvgic_info.maint_irq = irq_create_fwspec_mapping(&mi);\n\t\tWARN_ON(!vgic_info.maint_irq);\n\t}\n\n\tvgic_set_kvm_info(&vgic_info);\n\n\tpr_info(\"Initialized with %d/%d IRQs * %d/%d die(s), %d FIQs, %d vIPIs\",\n\t\tirqc->nr_irq, irqc->max_irq, irqc->nr_die, irqc->max_die, AIC_NR_FIQ, AIC_NR_SWIPI);\n\n\treturn 0;\n\nerr_remove_domain:\n\tirq_domain_remove(irqc->hw_domain);\nerr_unmap:\n\tif (irqc->event && irqc->event != irqc->base)\n\t\tiounmap(irqc->event);\n\tiounmap(irqc->base);\n\tkfree(irqc);\n\treturn -ENODEV;\n}\n\nIRQCHIP_DECLARE(apple_aic, \"apple,aic\", aic_of_ic_init);\nIRQCHIP_DECLARE(apple_aic2, \"apple,aic2\", aic_of_ic_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}