{
  "module_name": "irq-sa11x0.c",
  "hash_id": "1fd30869ca0e7b87a7b28f3f9369d092e1239c51894fe4312643551eff2b7099",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-sa11x0.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/syscore_ops.h>\n#include <linux/irqchip/irq-sa11x0.h>\n\n#include <soc/sa1100/pwer.h>\n\n#include <asm/exception.h>\n\n#define ICIP\t0x00   \n#define ICMR\t0x04   \n#define ICLR\t0x08   \n#define ICCR\t0x0C   \n#define ICFP\t0x10   \n#define ICPR\t0x20   \n\nstatic void __iomem *iobase;\n\n \nstatic void sa1100_mask_irq(struct irq_data *d)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(iobase + ICMR);\n\treg &= ~BIT(d->hwirq);\n\twritel_relaxed(reg, iobase + ICMR);\n}\n\nstatic void sa1100_unmask_irq(struct irq_data *d)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(iobase + ICMR);\n\treg |= BIT(d->hwirq);\n\twritel_relaxed(reg, iobase + ICMR);\n}\n\nstatic int sa1100_set_wake(struct irq_data *d, unsigned int on)\n{\n\treturn sa11x0_sc_set_wake(d->hwirq, on);\n}\n\nstatic struct irq_chip sa1100_normal_chip = {\n\t.name\t\t= \"SC\",\n\t.irq_ack\t= sa1100_mask_irq,\n\t.irq_mask\t= sa1100_mask_irq,\n\t.irq_unmask\t= sa1100_unmask_irq,\n\t.irq_set_wake\t= sa1100_set_wake,\n};\n\nstatic int sa1100_normal_irqdomain_map(struct irq_domain *d,\n\t\tunsigned int irq, irq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(irq, &sa1100_normal_chip,\n\t\t\t\t handle_level_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops sa1100_normal_irqdomain_ops = {\n\t.map = sa1100_normal_irqdomain_map,\n\t.xlate = irq_domain_xlate_onetwocell,\n};\n\nstatic struct irq_domain *sa1100_normal_irqdomain;\n\nstatic struct sa1100irq_state {\n\tunsigned int\tsaved;\n\tunsigned int\ticmr;\n\tunsigned int\ticlr;\n\tunsigned int\ticcr;\n} sa1100irq_state;\n\nstatic int sa1100irq_suspend(void)\n{\n\tstruct sa1100irq_state *st = &sa1100irq_state;\n\n\tst->saved = 1;\n\tst->icmr = readl_relaxed(iobase + ICMR);\n\tst->iclr = readl_relaxed(iobase + ICLR);\n\tst->iccr = readl_relaxed(iobase + ICCR);\n\n\t \n\twritel_relaxed(st->icmr & 0xfffff000, iobase + ICMR);\n\n\treturn 0;\n}\n\nstatic void sa1100irq_resume(void)\n{\n\tstruct sa1100irq_state *st = &sa1100irq_state;\n\n\tif (st->saved) {\n\t\twritel_relaxed(st->iccr, iobase + ICCR);\n\t\twritel_relaxed(st->iclr, iobase + ICLR);\n\n\t\twritel_relaxed(st->icmr, iobase + ICMR);\n\t}\n}\n\nstatic struct syscore_ops sa1100irq_syscore_ops = {\n\t.suspend\t= sa1100irq_suspend,\n\t.resume\t\t= sa1100irq_resume,\n};\n\nstatic int __init sa1100irq_init_devicefs(void)\n{\n\tregister_syscore_ops(&sa1100irq_syscore_ops);\n\treturn 0;\n}\n\ndevice_initcall(sa1100irq_init_devicefs);\n\nstatic asmlinkage void __exception_irq_entry\nsa1100_handle_irq(struct pt_regs *regs)\n{\n\tuint32_t icip, icmr, mask;\n\n\tdo {\n\t\ticip = readl_relaxed(iobase + ICIP);\n\t\ticmr = readl_relaxed(iobase + ICMR);\n\t\tmask = icip & icmr;\n\n\t\tif (mask == 0)\n\t\t\tbreak;\n\n\t\tgeneric_handle_domain_irq(sa1100_normal_irqdomain,\n\t\t\t\t\t  ffs(mask) - 1);\n\t} while (1);\n}\n\nvoid __init sa11x0_init_irq_nodt(int irq_start, resource_size_t io_start)\n{\n\tiobase = ioremap(io_start, SZ_64K);\n\tif (WARN_ON(!iobase))\n\t\treturn;\n\n\t \n\twritel_relaxed(0, iobase + ICMR);\n\n\t \n\twritel_relaxed(0, iobase + ICLR);\n\n\t \n\twritel_relaxed(1, iobase + ICCR);\n\n\tsa1100_normal_irqdomain = irq_domain_add_simple(NULL,\n\t\t\t32, irq_start,\n\t\t\t&sa1100_normal_irqdomain_ops, NULL);\n\n\tset_handle_irq(sa1100_handle_irq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}