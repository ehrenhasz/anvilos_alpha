{
  "module_name": "irq-gic-pm.c",
  "hash_id": "184bf09329464868b915c53d72c5db67a729465239a8811997f4cdacf72ef03c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-gic-pm.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/irqchip/arm-gic.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\nstruct gic_clk_data {\n\tunsigned int num_clocks;\n\tconst char *const *clocks;\n};\n\nstruct gic_chip_pm {\n\tstruct gic_chip_data *chip_data;\n\tconst struct gic_clk_data *clk_data;\n\tstruct clk_bulk_data *clks;\n};\n\nstatic int gic_runtime_resume(struct device *dev)\n{\n\tstruct gic_chip_pm *chip_pm = dev_get_drvdata(dev);\n\tstruct gic_chip_data *gic = chip_pm->chip_data;\n\tconst struct gic_clk_data *data = chip_pm->clk_data;\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(data->num_clocks, chip_pm->clks);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!gic)\n\t\treturn 0;\n\n\tgic_dist_restore(gic);\n\tgic_cpu_restore(gic);\n\n\treturn 0;\n}\n\nstatic int gic_runtime_suspend(struct device *dev)\n{\n\tstruct gic_chip_pm *chip_pm = dev_get_drvdata(dev);\n\tstruct gic_chip_data *gic = chip_pm->chip_data;\n\tconst struct gic_clk_data *data = chip_pm->clk_data;\n\n\tgic_dist_save(gic);\n\tgic_cpu_save(gic);\n\n\tclk_bulk_disable_unprepare(data->num_clocks, chip_pm->clks);\n\n\treturn 0;\n}\n\nstatic int gic_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct gic_clk_data *data;\n\tstruct gic_chip_pm *chip_pm;\n\tint ret, irq, i;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data) {\n\t\tdev_err(&pdev->dev, \"no device match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tchip_pm = devm_kzalloc(dev, sizeof(*chip_pm), GFP_KERNEL);\n\tif (!chip_pm)\n\t\treturn -ENOMEM;\n\n\tirq = irq_of_parse_and_map(dev->of_node, 0);\n\tif (!irq) {\n\t\tdev_err(dev, \"no parent interrupt found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip_pm->clks = devm_kcalloc(dev, data->num_clocks,\n\t\t\t\t     sizeof(*chip_pm->clks), GFP_KERNEL);\n\tif (!chip_pm->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < data->num_clocks; i++)\n\t\tchip_pm->clks[i].id = data->clocks[i];\n\n\tret = devm_clk_bulk_get(dev, data->num_clocks, chip_pm->clks);\n\tif (ret)\n\t\tgoto irq_dispose;\n\n\tchip_pm->clk_data = data;\n\tdev_set_drvdata(dev, chip_pm);\n\n\tpm_runtime_enable(dev);\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\tgoto rpm_disable;\n\n\tret = gic_of_init_child(dev, &chip_pm->chip_data, irq);\n\tif (ret)\n\t\tgoto rpm_put;\n\n\tpm_runtime_put(dev);\n\n\tdev_info(dev, \"GIC IRQ controller registered\\n\");\n\n\treturn 0;\n\nrpm_put:\n\tpm_runtime_put_sync(dev);\nrpm_disable:\n\tpm_runtime_disable(dev);\nirq_dispose:\n\tirq_dispose_mapping(irq);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops gic_pm_ops = {\n\tSET_RUNTIME_PM_OPS(gic_runtime_suspend,\n\t\t\t   gic_runtime_resume, NULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t     pm_runtime_force_resume)\n};\n\nstatic const char * const gic400_clocks[] = {\n\t\"clk\",\n};\n\nstatic const struct gic_clk_data gic400_data = {\n\t.num_clocks = ARRAY_SIZE(gic400_clocks),\n\t.clocks = gic400_clocks,\n};\n\nstatic const struct of_device_id gic_match[] = {\n\t{ .compatible = \"nvidia,tegra210-agic\",\t.data = &gic400_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, gic_match);\n\nstatic struct platform_driver gic_driver = {\n\t.probe\t\t= gic_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"gic\",\n\t\t.of_match_table\t= gic_match,\n\t\t.pm\t= &gic_pm_ops,\n\t}\n};\n\nbuiltin_platform_driver(gic_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}