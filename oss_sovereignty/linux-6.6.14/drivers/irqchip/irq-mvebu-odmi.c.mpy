{
  "module_name": "irq-mvebu-odmi.c",
  "hash_id": "4252e4160d5bcd8fc867e8de869b41d1ea42ac824fb3ca16811f7a4c2dfd7b32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mvebu-odmi.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"GIC-ODMI: \" fmt\n\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/msi.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <dt-bindings/interrupt-controller/arm-gic.h>\n\n#define GICP_ODMIN_SET\t\t\t0x40\n#define   GICP_ODMI_INT_NUM_SHIFT\t12\n#define GICP_ODMIN_GM_EP_R0\t\t0x110\n#define GICP_ODMIN_GM_EP_R1\t\t0x114\n#define GICP_ODMIN_GM_EA_R0\t\t0x108\n#define GICP_ODMIN_GM_EA_R1\t\t0x118\n\n \n#define NODMIS_SHIFT\t\t3\n#define NODMIS_PER_FRAME\t(1 << NODMIS_SHIFT)\n#define NODMIS_MASK\t\t(NODMIS_PER_FRAME - 1)\n\nstruct odmi_data {\n\tstruct resource res;\n\tvoid __iomem *base;\n\tunsigned int spi_base;\n};\n\nstatic struct odmi_data *odmis;\nstatic unsigned long *odmis_bm;\nstatic unsigned int odmis_count;\n\n \nstatic DEFINE_SPINLOCK(odmis_bm_lock);\n\nstatic void odmi_compose_msi_msg(struct irq_data *d, struct msi_msg *msg)\n{\n\tstruct odmi_data *odmi;\n\tphys_addr_t addr;\n\tunsigned int odmin;\n\n\tif (WARN_ON(d->hwirq >= odmis_count * NODMIS_PER_FRAME))\n\t\treturn;\n\n\todmi = &odmis[d->hwirq >> NODMIS_SHIFT];\n\todmin = d->hwirq & NODMIS_MASK;\n\n\taddr = odmi->res.start + GICP_ODMIN_SET;\n\n\tmsg->address_hi = upper_32_bits(addr);\n\tmsg->address_lo = lower_32_bits(addr);\n\tmsg->data = odmin << GICP_ODMI_INT_NUM_SHIFT;\n}\n\nstatic struct irq_chip odmi_irq_chip = {\n\t.name\t\t\t= \"ODMI\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.irq_compose_msi_msg\t= odmi_compose_msi_msg,\n};\n\nstatic int odmi_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs, void *args)\n{\n\tstruct odmi_data *odmi = NULL;\n\tstruct irq_fwspec fwspec;\n\tstruct irq_data *d;\n\tunsigned int hwirq, odmin;\n\tint ret;\n\n\tspin_lock(&odmis_bm_lock);\n\thwirq = find_first_zero_bit(odmis_bm, NODMIS_PER_FRAME * odmis_count);\n\tif (hwirq >= NODMIS_PER_FRAME * odmis_count) {\n\t\tspin_unlock(&odmis_bm_lock);\n\t\treturn -ENOSPC;\n\t}\n\n\t__set_bit(hwirq, odmis_bm);\n\tspin_unlock(&odmis_bm_lock);\n\n\todmi = &odmis[hwirq >> NODMIS_SHIFT];\n\todmin = hwirq & NODMIS_MASK;\n\n\tfwspec.fwnode = domain->parent->fwnode;\n\tfwspec.param_count = 3;\n\tfwspec.param[0] = GIC_SPI;\n\tfwspec.param[1] = odmi->spi_base - 32 + odmin;\n\tfwspec.param[2] = IRQ_TYPE_EDGE_RISING;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\n\tif (ret) {\n\t\tpr_err(\"Cannot allocate parent IRQ\\n\");\n\t\tspin_lock(&odmis_bm_lock);\n\t\t__clear_bit(odmin, odmis_bm);\n\t\tspin_unlock(&odmis_bm_lock);\n\t\treturn ret;\n\t}\n\n\t \n\td = irq_domain_get_irq_data(domain->parent, virq);\n\td->chip->irq_set_type(d, IRQ_TYPE_EDGE_RISING);\n\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t      &odmi_irq_chip, NULL);\n\n\treturn 0;\n}\n\nstatic void odmi_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\n\tif (d->hwirq >= odmis_count * NODMIS_PER_FRAME) {\n\t\tpr_err(\"Failed to teardown msi. Invalid hwirq %lu\\n\", d->hwirq);\n\t\treturn;\n\t}\n\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n\n\t \n\tspin_lock(&odmis_bm_lock);\n\t__clear_bit(d->hwirq, odmis_bm);\n\tspin_unlock(&odmis_bm_lock);\n}\n\nstatic const struct irq_domain_ops odmi_domain_ops = {\n\t.alloc\t= odmi_irq_domain_alloc,\n\t.free\t= odmi_irq_domain_free,\n};\n\nstatic struct irq_chip odmi_msi_irq_chip = {\n\t.name\t= \"ODMI\",\n};\n\nstatic struct msi_domain_ops odmi_msi_ops = {\n};\n\nstatic struct msi_domain_info odmi_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS),\n\t.ops\t= &odmi_msi_ops,\n\t.chip\t= &odmi_msi_irq_chip,\n};\n\nstatic int __init mvebu_odmi_init(struct device_node *node,\n\t\t\t\t  struct device_node *parent)\n{\n\tstruct irq_domain *parent_domain, *inner_domain, *plat_domain;\n\tint ret, i;\n\n\tif (of_property_read_u32(node, \"marvell,odmi-frames\", &odmis_count))\n\t\treturn -EINVAL;\n\n\todmis = kcalloc(odmis_count, sizeof(struct odmi_data), GFP_KERNEL);\n\tif (!odmis)\n\t\treturn -ENOMEM;\n\n\todmis_bm = bitmap_zalloc(odmis_count * NODMIS_PER_FRAME, GFP_KERNEL);\n\tif (!odmis_bm) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tfor (i = 0; i < odmis_count; i++) {\n\t\tstruct odmi_data *odmi = &odmis[i];\n\n\t\tret = of_address_to_resource(node, i, &odmi->res);\n\t\tif (ret)\n\t\t\tgoto err_unmap;\n\n\t\todmi->base = of_io_request_and_map(node, i, \"odmi\");\n\t\tif (IS_ERR(odmi->base)) {\n\t\t\tret = PTR_ERR(odmi->base);\n\t\t\tgoto err_unmap;\n\t\t}\n\n\t\tif (of_property_read_u32_index(node, \"marvell,spi-base\",\n\t\t\t\t\t       i, &odmi->spi_base)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unmap;\n\t\t}\n\t}\n\n\tparent_domain = irq_find_host(parent);\n\n\tinner_domain = irq_domain_create_hierarchy(parent_domain, 0,\n\t\t\t\t\t\t   odmis_count * NODMIS_PER_FRAME,\n\t\t\t\t\t\t   of_node_to_fwnode(node),\n\t\t\t\t\t\t   &odmi_domain_ops, NULL);\n\tif (!inner_domain) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unmap;\n\t}\n\n\tplat_domain = platform_msi_create_irq_domain(of_node_to_fwnode(node),\n\t\t\t\t\t\t     &odmi_msi_domain_info,\n\t\t\t\t\t\t     inner_domain);\n\tif (!plat_domain) {\n\t\tret = -ENOMEM;\n\t\tgoto err_remove_inner;\n\t}\n\n\treturn 0;\n\nerr_remove_inner:\n\tirq_domain_remove(inner_domain);\nerr_unmap:\n\tfor (i = 0; i < odmis_count; i++) {\n\t\tstruct odmi_data *odmi = &odmis[i];\n\n\t\tif (odmi->base && !IS_ERR(odmi->base))\n\t\t\tiounmap(odmis[i].base);\n\t}\n\tbitmap_free(odmis_bm);\nerr_alloc:\n\tkfree(odmis);\n\treturn ret;\n}\n\nIRQCHIP_DECLARE(mvebu_odmi, \"marvell,odmi-controller\", mvebu_odmi_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}