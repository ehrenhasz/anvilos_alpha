{
  "module_name": "irq-ompic.c",
  "hash_id": "d7ee3b6fcf7871d2430340b913aa8eaf3dd0361f6cf13bbf17e2b6e19cf22a6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-ompic.c",
  "human_readable_source": " \n\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n\n#include <linux/irqchip.h>\n\n#define OMPIC_CPUBYTES\t\t8\n#define OMPIC_CTRL(cpu)\t\t(0x0 + (cpu * OMPIC_CPUBYTES))\n#define OMPIC_STAT(cpu)\t\t(0x4 + (cpu * OMPIC_CPUBYTES))\n\n#define OMPIC_CTRL_IRQ_ACK\t(1 << 31)\n#define OMPIC_CTRL_IRQ_GEN\t(1 << 30)\n#define OMPIC_CTRL_DST(cpu)\t(((cpu) & 0x3fff) << 16)\n\n#define OMPIC_STAT_IRQ_PENDING\t(1 << 30)\n\n#define OMPIC_DATA(x)\t\t((x) & 0xffff)\n\nDEFINE_PER_CPU(unsigned long, ops);\n\nstatic void __iomem *ompic_base;\n\nstatic inline u32 ompic_readreg(void __iomem *base, loff_t offset)\n{\n\treturn ioread32be(base + offset);\n}\n\nstatic void ompic_writereg(void __iomem *base, loff_t offset, u32 data)\n{\n\tiowrite32be(data, base + offset);\n}\n\nstatic void ompic_raise_softirq(const struct cpumask *mask,\n\t\t\t\tunsigned int ipi_msg)\n{\n\tunsigned int dst_cpu;\n\tunsigned int src_cpu = smp_processor_id();\n\n\tfor_each_cpu(dst_cpu, mask) {\n\t\tset_bit(ipi_msg, &per_cpu(ops, dst_cpu));\n\n\t\t \n\n\t\tompic_writereg(ompic_base, OMPIC_CTRL(src_cpu),\n\t\t\t       OMPIC_CTRL_IRQ_GEN |\n\t\t\t       OMPIC_CTRL_DST(dst_cpu) |\n\t\t\t       OMPIC_DATA(1));\n\t}\n}\n\nstatic irqreturn_t ompic_ipi_handler(int irq, void *dev_id)\n{\n\tunsigned int cpu = smp_processor_id();\n\tunsigned long *pending_ops = &per_cpu(ops, cpu);\n\tunsigned long ops;\n\n\tompic_writereg(ompic_base, OMPIC_CTRL(cpu), OMPIC_CTRL_IRQ_ACK);\n\twhile ((ops = xchg(pending_ops, 0)) != 0) {\n\n\t\t \n\n\t\tdo {\n\t\t\tunsigned long ipi_msg;\n\n\t\t\tipi_msg = __ffs(ops);\n\t\t\tops &= ~(1UL << ipi_msg);\n\n\t\t\thandle_IPI(ipi_msg);\n\t\t} while (ops);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init ompic_of_init(struct device_node *node,\n\t\t\t\tstruct device_node *parent)\n{\n\tstruct resource res;\n\tint irq;\n\tint ret;\n\n\t \n\tif (ompic_base) {\n\t\tpr_err(\"ompic: duplicate ompic's are not supported\");\n\t\treturn -EEXIST;\n\t}\n\n\tif (of_address_to_resource(node, 0, &res)) {\n\t\tpr_err(\"ompic: reg property requires an address and size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (resource_size(&res) < (num_possible_cpus() * OMPIC_CPUBYTES)) {\n\t\tpr_err(\"ompic: reg size, currently %d must be at least %d\",\n\t\t\tresource_size(&res),\n\t\t\t(num_possible_cpus() * OMPIC_CPUBYTES));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tompic_base = ioremap(res.start, resource_size(&res));\n\tif (!ompic_base) {\n\t\tpr_err(\"ompic: unable to map registers\");\n\t\treturn -ENOMEM;\n\t}\n\n\tirq = irq_of_parse_and_map(node, 0);\n\tif (irq <= 0) {\n\t\tpr_err(\"ompic: unable to parse device irq\");\n\t\tret = -EINVAL;\n\t\tgoto out_unmap;\n\t}\n\n\tret = request_irq(irq, ompic_ipi_handler, IRQF_PERCPU,\n\t\t\t\t\"ompic_ipi\", NULL);\n\tif (ret)\n\t\tgoto out_irq_disp;\n\n\tset_smp_cross_call(ompic_raise_softirq);\n\n\treturn 0;\n\nout_irq_disp:\n\tirq_dispose_mapping(irq);\nout_unmap:\n\tiounmap(ompic_base);\n\tompic_base = NULL;\n\treturn ret;\n}\nIRQCHIP_DECLARE(ompic, \"openrisc,ompic\", ompic_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}