{
  "module_name": "irq-alpine-msi.c",
  "hash_id": "9cd11d7a35d31efb048a081010f324c8d2830febb9df186d89f200c0d306e892",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-alpine-msi.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/irqchip.h>\n#include <linux/irqchip/arm-gic.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <asm/irq.h>\n#include <asm/msi.h>\n\n \n#define ALPINE_MSIX_SPI_TARGET_CLUSTER0\t\tBIT(16)\n\nstruct alpine_msix_data {\n\tspinlock_t msi_map_lock;\n\tphys_addr_t addr;\n\tu32 spi_first;\t\t \n\tu32 num_spis;\t\t \n\tunsigned long *msi_map;\n};\n\nstatic void alpine_msix_mask_msi_irq(struct irq_data *d)\n{\n\tpci_msi_mask_irq(d);\n\tirq_chip_mask_parent(d);\n}\n\nstatic void alpine_msix_unmask_msi_irq(struct irq_data *d)\n{\n\tpci_msi_unmask_irq(d);\n\tirq_chip_unmask_parent(d);\n}\n\nstatic struct irq_chip alpine_msix_irq_chip = {\n\t.name\t\t\t= \"MSIx\",\n\t.irq_mask\t\t= alpine_msix_mask_msi_irq,\n\t.irq_unmask\t\t= alpine_msix_unmask_msi_irq,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n};\n\nstatic int alpine_msix_allocate_sgi(struct alpine_msix_data *priv, int num_req)\n{\n\tint first;\n\n\tspin_lock(&priv->msi_map_lock);\n\n\tfirst = bitmap_find_next_zero_area(priv->msi_map, priv->num_spis, 0,\n\t\t\t\t\t   num_req, 0);\n\tif (first >= priv->num_spis) {\n\t\tspin_unlock(&priv->msi_map_lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tbitmap_set(priv->msi_map, first, num_req);\n\n\tspin_unlock(&priv->msi_map_lock);\n\n\treturn priv->spi_first + first;\n}\n\nstatic void alpine_msix_free_sgi(struct alpine_msix_data *priv, unsigned sgi,\n\t\t\t\t int num_req)\n{\n\tint first = sgi - priv->spi_first;\n\n\tspin_lock(&priv->msi_map_lock);\n\n\tbitmap_clear(priv->msi_map, first, num_req);\n\n\tspin_unlock(&priv->msi_map_lock);\n}\n\nstatic void alpine_msix_compose_msi_msg(struct irq_data *data,\n\t\t\t\t\tstruct msi_msg *msg)\n{\n\tstruct alpine_msix_data *priv = irq_data_get_irq_chip_data(data);\n\tphys_addr_t msg_addr = priv->addr;\n\n\tmsg_addr |= (data->hwirq << 3);\n\n\tmsg->address_hi = upper_32_bits(msg_addr);\n\tmsg->address_lo = lower_32_bits(msg_addr);\n\tmsg->data = 0;\n}\n\nstatic struct msi_domain_info alpine_msix_domain_info = {\n\t.flags\t= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t  MSI_FLAG_PCI_MSIX,\n\t.chip\t= &alpine_msix_irq_chip,\n};\n\nstatic struct irq_chip middle_irq_chip = {\n\t.name\t\t\t= \"alpine_msix_middle\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.irq_compose_msi_msg\t= alpine_msix_compose_msi_msg,\n};\n\nstatic int alpine_msix_gic_domain_alloc(struct irq_domain *domain,\n\t\t\t\t\tunsigned int virq, int sgi)\n{\n\tstruct irq_fwspec fwspec;\n\tstruct irq_data *d;\n\tint ret;\n\n\tif (!is_of_node(domain->parent->fwnode))\n\t\treturn -EINVAL;\n\n\tfwspec.fwnode = domain->parent->fwnode;\n\tfwspec.param_count = 3;\n\tfwspec.param[0] = 0;\n\tfwspec.param[1] = sgi;\n\tfwspec.param[2] = IRQ_TYPE_EDGE_RISING;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\n\tif (ret)\n\t\treturn ret;\n\n\td = irq_domain_get_irq_data(domain->parent, virq);\n\td->chip->irq_set_type(d, IRQ_TYPE_EDGE_RISING);\n\n\treturn 0;\n}\n\nstatic int alpine_msix_middle_domain_alloc(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int virq,\n\t\t\t\t\t   unsigned int nr_irqs, void *args)\n{\n\tstruct alpine_msix_data *priv = domain->host_data;\n\tint sgi, err, i;\n\n\tsgi = alpine_msix_allocate_sgi(priv, nr_irqs);\n\tif (sgi < 0)\n\t\treturn sgi;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\terr = alpine_msix_gic_domain_alloc(domain, virq + i, sgi + i);\n\t\tif (err)\n\t\t\tgoto err_sgi;\n\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, sgi + i,\n\t\t\t\t\t      &middle_irq_chip, priv);\n\t}\n\n\treturn 0;\n\nerr_sgi:\n\tirq_domain_free_irqs_parent(domain, virq, i - 1);\n\talpine_msix_free_sgi(priv, sgi, nr_irqs);\n\treturn err;\n}\n\nstatic void alpine_msix_middle_domain_free(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int virq,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct alpine_msix_data *priv = irq_data_get_irq_chip_data(d);\n\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n\talpine_msix_free_sgi(priv, d->hwirq, nr_irqs);\n}\n\nstatic const struct irq_domain_ops alpine_msix_middle_domain_ops = {\n\t.alloc\t= alpine_msix_middle_domain_alloc,\n\t.free\t= alpine_msix_middle_domain_free,\n};\n\nstatic int alpine_msix_init_domains(struct alpine_msix_data *priv,\n\t\t\t\t    struct device_node *node)\n{\n\tstruct irq_domain *middle_domain, *msi_domain, *gic_domain;\n\tstruct device_node *gic_node;\n\n\tgic_node = of_irq_find_parent(node);\n\tif (!gic_node) {\n\t\tpr_err(\"Failed to find the GIC node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tgic_domain = irq_find_host(gic_node);\n\tof_node_put(gic_node);\n\tif (!gic_domain) {\n\t\tpr_err(\"Failed to find the GIC domain\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tmiddle_domain = irq_domain_add_hierarchy(gic_domain, 0, 0, NULL,\n\t\t\t\t\t\t &alpine_msix_middle_domain_ops,\n\t\t\t\t\t\t priv);\n\tif (!middle_domain) {\n\t\tpr_err(\"Failed to create the MSIX middle domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmsi_domain = pci_msi_create_irq_domain(of_node_to_fwnode(node),\n\t\t\t\t\t       &alpine_msix_domain_info,\n\t\t\t\t\t       middle_domain);\n\tif (!msi_domain) {\n\t\tpr_err(\"Failed to create MSI domain\\n\");\n\t\tirq_domain_remove(middle_domain);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int alpine_msix_init(struct device_node *node,\n\t\t\t    struct device_node *parent)\n{\n\tstruct alpine_msix_data *priv;\n\tstruct resource res;\n\tint ret;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->msi_map_lock);\n\n\tret = of_address_to_resource(node, 0, &res);\n\tif (ret) {\n\t\tpr_err(\"Failed to allocate resource\\n\");\n\t\tgoto err_priv;\n\t}\n\n\t \n\tpriv->addr = res.start & GENMASK_ULL(63,20);\n\tpriv->addr |= ALPINE_MSIX_SPI_TARGET_CLUSTER0;\n\n\tif (of_property_read_u32(node, \"al,msi-base-spi\", &priv->spi_first)) {\n\t\tpr_err(\"Unable to parse MSI base\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_priv;\n\t}\n\n\tif (of_property_read_u32(node, \"al,msi-num-spis\", &priv->num_spis)) {\n\t\tpr_err(\"Unable to parse MSI numbers\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_priv;\n\t}\n\n\tpriv->msi_map = bitmap_zalloc(priv->num_spis, GFP_KERNEL);\n\tif (!priv->msi_map) {\n\t\tret = -ENOMEM;\n\t\tgoto err_priv;\n\t}\n\n\tpr_debug(\"Registering %d msixs, starting at %d\\n\",\n\t\t priv->num_spis, priv->spi_first);\n\n\tret = alpine_msix_init_domains(priv, node);\n\tif (ret)\n\t\tgoto err_map;\n\n\treturn 0;\n\nerr_map:\n\tbitmap_free(priv->msi_map);\nerr_priv:\n\tkfree(priv);\n\treturn ret;\n}\nIRQCHIP_DECLARE(alpine_msix, \"al,alpine-msix\", alpine_msix_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}