{
  "module_name": "irq-bcm7120-l2.c",
  "hash_id": "7dad4b203ea937c3b83a0c12183c981ff13d699e60a95fc5946949325c0d1090",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-bcm7120-l2.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME\t\": \" fmt\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/irqdomain.h>\n#include <linux/reboot.h>\n#include <linux/bitops.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n\n \n#define IRQEN\t\t0x00\n#define IRQSTAT\t\t0x04\n\n#define MAX_WORDS\t4\n#define MAX_MAPPINGS\t(MAX_WORDS * 2)\n#define IRQS_PER_WORD\t32\n\nstruct bcm7120_l1_intc_data {\n\tstruct bcm7120_l2_intc_data *b;\n\tu32 irq_map_mask[MAX_WORDS];\n};\n\nstruct bcm7120_l2_intc_data {\n\tunsigned int n_words;\n\tvoid __iomem *map_base[MAX_MAPPINGS];\n\tvoid __iomem *pair_base[MAX_WORDS];\n\tint en_offset[MAX_WORDS];\n\tint stat_offset[MAX_WORDS];\n\tstruct irq_domain *domain;\n\tbool can_wake;\n\tu32 irq_fwd_mask[MAX_WORDS];\n\tstruct bcm7120_l1_intc_data *l1_data;\n\tint num_parent_irqs;\n\tconst __be32 *map_mask_prop;\n};\n\nstatic void bcm7120_l2_intc_irq_handle(struct irq_desc *desc)\n{\n\tstruct bcm7120_l1_intc_data *data = irq_desc_get_handler_data(desc);\n\tstruct bcm7120_l2_intc_data *b = data->b;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned int idx;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (idx = 0; idx < b->n_words; idx++) {\n\t\tint base = idx * IRQS_PER_WORD;\n\t\tstruct irq_chip_generic *gc =\n\t\t\tirq_get_domain_generic_chip(b->domain, base);\n\t\tunsigned long pending;\n\t\tint hwirq;\n\n\t\tirq_gc_lock(gc);\n\t\tpending = irq_reg_readl(gc, b->stat_offset[idx]) &\n\t\t\t\t\t    gc->mask_cache &\n\t\t\t\t\t    data->irq_map_mask[idx];\n\t\tirq_gc_unlock(gc);\n\n\t\tfor_each_set_bit(hwirq, &pending, IRQS_PER_WORD)\n\t\t\tgeneric_handle_domain_irq(b->domain, base + hwirq);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void bcm7120_l2_intc_suspend(struct irq_chip_generic *gc)\n{\n\tstruct bcm7120_l2_intc_data *b = gc->private;\n\tstruct irq_chip_type *ct = gc->chip_types;\n\n\tirq_gc_lock(gc);\n\tif (b->can_wake)\n\t\tirq_reg_writel(gc, gc->mask_cache | gc->wake_active,\n\t\t\t       ct->regs.mask);\n\tirq_gc_unlock(gc);\n}\n\nstatic void bcm7120_l2_intc_resume(struct irq_chip_generic *gc)\n{\n\tstruct irq_chip_type *ct = gc->chip_types;\n\n\t \n\tirq_gc_lock(gc);\n\tirq_reg_writel(gc, gc->mask_cache, ct->regs.mask);\n\tirq_gc_unlock(gc);\n}\n\nstatic int bcm7120_l2_intc_init_one(struct device_node *dn,\n\t\t\t\t\tstruct bcm7120_l2_intc_data *data,\n\t\t\t\t\tint irq, u32 *valid_mask)\n{\n\tstruct bcm7120_l1_intc_data *l1_data = &data->l1_data[irq];\n\tint parent_irq;\n\tunsigned int idx;\n\n\tparent_irq = irq_of_parse_and_map(dn, irq);\n\tif (!parent_irq) {\n\t\tpr_err(\"failed to map interrupt %d\\n\", irq);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (idx = 0; idx < data->n_words; idx++) {\n\t\tif (data->map_mask_prop) {\n\t\t\tl1_data->irq_map_mask[idx] |=\n\t\t\t\tbe32_to_cpup(data->map_mask_prop +\n\t\t\t\t\t     irq * data->n_words + idx);\n\t\t} else {\n\t\t\tl1_data->irq_map_mask[idx] = 0xffffffff;\n\t\t}\n\t\tvalid_mask[idx] |= l1_data->irq_map_mask[idx];\n\t}\n\n\tl1_data->b = data;\n\n\tirq_set_chained_handler_and_data(parent_irq,\n\t\t\t\t\t bcm7120_l2_intc_irq_handle, l1_data);\n\tif (data->can_wake)\n\t\tenable_irq_wake(parent_irq);\n\n\treturn 0;\n}\n\nstatic int __init bcm7120_l2_intc_iomap_7120(struct device_node *dn,\n\t\t\t\t\t     struct bcm7120_l2_intc_data *data)\n{\n\tint ret;\n\n\tdata->map_base[0] = of_iomap(dn, 0);\n\tif (!data->map_base[0]) {\n\t\tpr_err(\"unable to map registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->pair_base[0] = data->map_base[0];\n\tdata->en_offset[0] = IRQEN;\n\tdata->stat_offset[0] = IRQSTAT;\n\tdata->n_words = 1;\n\n\tret = of_property_read_u32_array(dn, \"brcm,int-fwd-mask\",\n\t\t\t\t\t data->irq_fwd_mask, data->n_words);\n\tif (ret != 0 && ret != -EINVAL) {\n\t\t \n\t\tpr_err(\"invalid brcm,int-fwd-mask property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->map_mask_prop = of_get_property(dn, \"brcm,int-map-mask\", &ret);\n\tif (!data->map_mask_prop ||\n\t    (ret != (sizeof(__be32) * data->num_parent_irqs * data->n_words))) {\n\t\tpr_err(\"invalid brcm,int-map-mask property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init bcm7120_l2_intc_iomap_3380(struct device_node *dn,\n\t\t\t\t\t     struct bcm7120_l2_intc_data *data)\n{\n\tunsigned int gc_idx;\n\n\tfor (gc_idx = 0; gc_idx < MAX_WORDS; gc_idx++) {\n\t\tunsigned int map_idx = gc_idx * 2;\n\t\tvoid __iomem *en = of_iomap(dn, map_idx + 0);\n\t\tvoid __iomem *stat = of_iomap(dn, map_idx + 1);\n\t\tvoid __iomem *base = min(en, stat);\n\n\t\tdata->map_base[map_idx + 0] = en;\n\t\tdata->map_base[map_idx + 1] = stat;\n\n\t\tif (!base)\n\t\t\tbreak;\n\n\t\tdata->pair_base[gc_idx] = base;\n\t\tdata->en_offset[gc_idx] = en - base;\n\t\tdata->stat_offset[gc_idx] = stat - base;\n\t}\n\n\tif (!gc_idx) {\n\t\tpr_err(\"unable to map registers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->n_words = gc_idx;\n\treturn 0;\n}\n\nstatic int __init bcm7120_l2_intc_probe(struct device_node *dn,\n\t\t\t\t struct device_node *parent,\n\t\t\t\t int (*iomap_regs_fn)(struct device_node *,\n\t\t\t\t\tstruct bcm7120_l2_intc_data *),\n\t\t\t\t const char *intc_name)\n{\n\tunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\n\tstruct bcm7120_l2_intc_data *data;\n\tstruct platform_device *pdev;\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\tint ret = 0;\n\tunsigned int idx, irq, flags;\n\tu32 valid_mask[MAX_WORDS] = { };\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tpdev = of_find_device_by_node(dn);\n\tif (!pdev) {\n\t\tret = -ENODEV;\n\t\tgoto out_free_data;\n\t}\n\n\tdata->num_parent_irqs = platform_irq_count(pdev);\n\tput_device(&pdev->dev);\n\tif (data->num_parent_irqs <= 0) {\n\t\tpr_err(\"invalid number of parent interrupts\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n\tdata->l1_data = kcalloc(data->num_parent_irqs, sizeof(*data->l1_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!data->l1_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_l1_data;\n\t}\n\n\tret = iomap_regs_fn(dn, data);\n\tif (ret < 0)\n\t\tgoto out_free_l1_data;\n\n\tdata->can_wake = of_property_read_bool(dn, \"brcm,irq-can-wake\");\n\n\tfor (irq = 0; irq < data->num_parent_irqs; irq++) {\n\t\tret = bcm7120_l2_intc_init_one(dn, data, irq, valid_mask);\n\t\tif (ret)\n\t\t\tgoto out_free_l1_data;\n\t}\n\n\tdata->domain = irq_domain_add_linear(dn, IRQS_PER_WORD * data->n_words,\n\t\t\t\t\t     &irq_generic_chip_ops, NULL);\n\tif (!data->domain) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_l1_data;\n\t}\n\n\t \n\tflags = IRQ_GC_INIT_MASK_CACHE;\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\tflags |= IRQ_GC_BE_IO;\n\n\tret = irq_alloc_domain_generic_chips(data->domain, IRQS_PER_WORD, 1,\n\t\t\t\tdn->full_name, handle_level_irq, clr,\n\t\t\t\tIRQ_LEVEL, flags);\n\tif (ret) {\n\t\tpr_err(\"failed to allocate generic irq chip\\n\");\n\t\tgoto out_free_domain;\n\t}\n\n\tfor (idx = 0; idx < data->n_words; idx++) {\n\t\tirq = idx * IRQS_PER_WORD;\n\t\tgc = irq_get_domain_generic_chip(data->domain, irq);\n\n\t\tgc->unused = 0xffffffff & ~valid_mask[idx];\n\t\tgc->private = data;\n\t\tct = gc->chip_types;\n\n\t\tgc->reg_base = data->pair_base[idx];\n\t\tct->regs.mask = data->en_offset[idx];\n\n\t\t \n\t\tirq_reg_writel(gc, data->irq_fwd_mask[idx],\n\t\t\t       data->en_offset[idx]);\n\n\t\tct->chip.irq_mask = irq_gc_mask_clr_bit;\n\t\tct->chip.irq_unmask = irq_gc_mask_set_bit;\n\t\tct->chip.irq_ack = irq_gc_noop;\n\t\tgc->suspend = bcm7120_l2_intc_suspend;\n\t\tgc->resume = bcm7120_l2_intc_resume;\n\n\t\t \n\t\tgc->mask_cache = irq_reg_readl(gc, ct->regs.mask);\n\n\t\tif (data->can_wake) {\n\t\t\t \n\t\t\tgc->wake_enabled = 0xffffffff;\n\t\t\tgc->wake_enabled &= ~gc->unused;\n\t\t\tct->chip.irq_set_wake = irq_gc_set_wake;\n\t\t}\n\t}\n\n\tpr_info(\"registered %s intc (%pOF, parent IRQ(s): %d)\\n\",\n\t\tintc_name, dn, data->num_parent_irqs);\n\n\treturn 0;\n\nout_free_domain:\n\tirq_domain_remove(data->domain);\nout_free_l1_data:\n\tkfree(data->l1_data);\nout_unmap:\n\tfor (idx = 0; idx < MAX_MAPPINGS; idx++) {\n\t\tif (data->map_base[idx])\n\t\t\tiounmap(data->map_base[idx]);\n\t}\nout_free_data:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int __init bcm7120_l2_intc_probe_7120(struct device_node *dn,\n\t\t\t\t\t     struct device_node *parent)\n{\n\treturn bcm7120_l2_intc_probe(dn, parent, bcm7120_l2_intc_iomap_7120,\n\t\t\t\t     \"BCM7120 L2\");\n}\n\nstatic int __init bcm7120_l2_intc_probe_3380(struct device_node *dn,\n\t\t\t\t\t     struct device_node *parent)\n{\n\treturn bcm7120_l2_intc_probe(dn, parent, bcm7120_l2_intc_iomap_3380,\n\t\t\t\t     \"BCM3380 L2\");\n}\n\nIRQCHIP_PLATFORM_DRIVER_BEGIN(bcm7120_l2)\nIRQCHIP_MATCH(\"brcm,bcm7120-l2-intc\", bcm7120_l2_intc_probe_7120)\nIRQCHIP_MATCH(\"brcm,bcm3380-l2-intc\", bcm7120_l2_intc_probe_3380)\nIRQCHIP_PLATFORM_DRIVER_END(bcm7120_l2)\nMODULE_DESCRIPTION(\"Broadcom STB 7120-style L2 interrupt controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}