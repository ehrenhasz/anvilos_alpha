{
  "module_name": "exynos-combiner.c",
  "hash_id": "faae5d1e9bd865765b0d35158288cdc7329563eefd95de3b39f1f8a73498f726",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/exynos-combiner.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/syscore_ops.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/interrupt.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#define COMBINER_ENABLE_SET\t0x0\n#define COMBINER_ENABLE_CLEAR\t0x4\n#define COMBINER_INT_STATUS\t0xC\n\n#define IRQ_IN_COMBINER\t\t8\n\nstatic DEFINE_SPINLOCK(irq_controller_lock);\n\nstruct combiner_chip_data {\n\tunsigned int hwirq_offset;\n\tunsigned int irq_mask;\n\tvoid __iomem *base;\n\tunsigned int parent_irq;\n#ifdef CONFIG_PM\n\tu32 pm_save;\n#endif\n};\n\nstatic struct combiner_chip_data *combiner_data;\nstatic struct irq_domain *combiner_irq_domain;\nstatic unsigned int max_nr = 20;\n\nstatic inline void __iomem *combiner_base(struct irq_data *data)\n{\n\tstruct combiner_chip_data *combiner_data =\n\t\tirq_data_get_irq_chip_data(data);\n\n\treturn combiner_data->base;\n}\n\nstatic void combiner_mask_irq(struct irq_data *data)\n{\n\tu32 mask = 1 << (data->hwirq % 32);\n\n\twritel_relaxed(mask, combiner_base(data) + COMBINER_ENABLE_CLEAR);\n}\n\nstatic void combiner_unmask_irq(struct irq_data *data)\n{\n\tu32 mask = 1 << (data->hwirq % 32);\n\n\twritel_relaxed(mask, combiner_base(data) + COMBINER_ENABLE_SET);\n}\n\nstatic void combiner_handle_cascade_irq(struct irq_desc *desc)\n{\n\tstruct combiner_chip_data *chip_data = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned int combiner_irq;\n\tunsigned long status;\n\tint ret;\n\n\tchained_irq_enter(chip, desc);\n\n\tspin_lock(&irq_controller_lock);\n\tstatus = readl_relaxed(chip_data->base + COMBINER_INT_STATUS);\n\tspin_unlock(&irq_controller_lock);\n\tstatus &= chip_data->irq_mask;\n\n\tif (status == 0)\n\t\tgoto out;\n\n\tcombiner_irq = chip_data->hwirq_offset + __ffs(status);\n\tret = generic_handle_domain_irq(combiner_irq_domain, combiner_irq);\n\tif (unlikely(ret))\n\t\thandle_bad_irq(desc);\n\n out:\n\tchained_irq_exit(chip, desc);\n}\n\n#ifdef CONFIG_SMP\nstatic int combiner_set_affinity(struct irq_data *d,\n\t\t\t\t const struct cpumask *mask_val, bool force)\n{\n\tstruct combiner_chip_data *chip_data = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip *chip = irq_get_chip(chip_data->parent_irq);\n\tstruct irq_data *data = irq_get_irq_data(chip_data->parent_irq);\n\n\tif (chip && chip->irq_set_affinity)\n\t\treturn chip->irq_set_affinity(data, mask_val, force);\n\telse\n\t\treturn -EINVAL;\n}\n#endif\n\nstatic struct irq_chip combiner_chip = {\n\t.name\t\t\t= \"COMBINER\",\n\t.irq_mask\t\t= combiner_mask_irq,\n\t.irq_unmask\t\t= combiner_unmask_irq,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity\t= combiner_set_affinity,\n#endif\n};\n\nstatic void __init combiner_cascade_irq(struct combiner_chip_data *combiner_data,\n\t\t\t\t\tunsigned int irq)\n{\n\tirq_set_chained_handler_and_data(irq, combiner_handle_cascade_irq,\n\t\t\t\t\t combiner_data);\n}\n\nstatic void __init combiner_init_one(struct combiner_chip_data *combiner_data,\n\t\t\t\t     unsigned int combiner_nr,\n\t\t\t\t     void __iomem *base, unsigned int irq)\n{\n\tcombiner_data->base = base;\n\tcombiner_data->hwirq_offset = (combiner_nr & ~3) * IRQ_IN_COMBINER;\n\tcombiner_data->irq_mask = 0xff << ((combiner_nr % 4) << 3);\n\tcombiner_data->parent_irq = irq;\n\n\t \n\twritel_relaxed(combiner_data->irq_mask, base + COMBINER_ENABLE_CLEAR);\n}\n\nstatic int combiner_irq_domain_xlate(struct irq_domain *d,\n\t\t\t\t     struct device_node *controller,\n\t\t\t\t     const u32 *intspec, unsigned int intsize,\n\t\t\t\t     unsigned long *out_hwirq,\n\t\t\t\t     unsigned int *out_type)\n{\n\tif (irq_domain_get_of_node(d) != controller)\n\t\treturn -EINVAL;\n\n\tif (intsize < 2)\n\t\treturn -EINVAL;\n\n\t*out_hwirq = intspec[0] * IRQ_IN_COMBINER + intspec[1];\n\t*out_type = 0;\n\n\treturn 0;\n}\n\nstatic int combiner_irq_domain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t\t   irq_hw_number_t hw)\n{\n\tstruct combiner_chip_data *combiner_data = d->host_data;\n\n\tirq_set_chip_and_handler(irq, &combiner_chip, handle_level_irq);\n\tirq_set_chip_data(irq, &combiner_data[hw >> 3]);\n\tirq_set_probe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops combiner_irq_domain_ops = {\n\t.xlate\t= combiner_irq_domain_xlate,\n\t.map\t= combiner_irq_domain_map,\n};\n\nstatic void __init combiner_init(void __iomem *combiner_base,\n\t\t\t\t struct device_node *np)\n{\n\tint i, irq;\n\tunsigned int nr_irq;\n\n\tnr_irq = max_nr * IRQ_IN_COMBINER;\n\n\tcombiner_data = kcalloc(max_nr, sizeof (*combiner_data), GFP_KERNEL);\n\tif (!combiner_data)\n\t\treturn;\n\n\tcombiner_irq_domain = irq_domain_add_linear(np, nr_irq,\n\t\t\t\t&combiner_irq_domain_ops, combiner_data);\n\tif (WARN_ON(!combiner_irq_domain)) {\n\t\tpr_warn(\"%s: irq domain init failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < max_nr; i++) {\n\t\tirq = irq_of_parse_and_map(np, i);\n\n\t\tcombiner_init_one(&combiner_data[i], i,\n\t\t\t\t  combiner_base + (i >> 2) * 0x10, irq);\n\t\tcombiner_cascade_irq(&combiner_data[i], irq);\n\t}\n}\n\n#ifdef CONFIG_PM\n\n \nstatic int combiner_suspend(void)\n{\n\tint i;\n\n\tfor (i = 0; i < max_nr; i++)\n\t\tcombiner_data[i].pm_save =\n\t\t\treadl_relaxed(combiner_data[i].base + COMBINER_ENABLE_SET);\n\n\treturn 0;\n}\n\n \nstatic void combiner_resume(void)\n{\n\tint i;\n\n\tfor (i = 0; i < max_nr; i++) {\n\t\twritel_relaxed(combiner_data[i].irq_mask,\n\t\t\t     combiner_data[i].base + COMBINER_ENABLE_CLEAR);\n\t\twritel_relaxed(combiner_data[i].pm_save,\n\t\t\t     combiner_data[i].base + COMBINER_ENABLE_SET);\n\t}\n}\n\n#else\n#define combiner_suspend\tNULL\n#define combiner_resume\t\tNULL\n#endif\n\nstatic struct syscore_ops combiner_syscore_ops = {\n\t.suspend\t= combiner_suspend,\n\t.resume\t\t= combiner_resume,\n};\n\nstatic int __init combiner_of_init(struct device_node *np,\n\t\t\t\t   struct device_node *parent)\n{\n\tvoid __iomem *combiner_base;\n\n\tcombiner_base = of_iomap(np, 0);\n\tif (!combiner_base) {\n\t\tpr_err(\"%s: failed to map combiner registers\\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"samsung,combiner-nr\", &max_nr)) {\n\t\tpr_info(\"%s: number of combiners not specified, \"\n\t\t\t\"setting default as %d.\\n\",\n\t\t\t__func__, max_nr);\n\t}\n\n\tcombiner_init(combiner_base, np);\n\n\tregister_syscore_ops(&combiner_syscore_ops);\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(exynos4210_combiner, \"samsung,exynos4210-combiner\",\n\t\tcombiner_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}