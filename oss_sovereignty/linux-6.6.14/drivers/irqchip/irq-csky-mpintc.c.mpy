{
  "module_name": "irq-csky-mpintc.c",
  "hash_id": "51524232cca4d274508dd1e3af3f5ce4ac8b293dcb4285db5efa0a58e161a528",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-csky-mpintc.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <asm/traps.h>\n#include <asm/reg_ops.h>\n\nstatic struct irq_domain *root_domain;\nstatic void __iomem *INTCG_base;\nstatic void __iomem *INTCL_base;\n\n#define IPI_IRQ\t\t15\n#define INTC_IRQS\t256\n#define COMM_IRQ_BASE\t32\n\n#define INTCG_SIZE\t0x8000\n#define INTCL_SIZE\t0x1000\n\n#define INTCG_ICTLR\t0x0\n#define INTCG_CICFGR\t0x100\n#define INTCG_CIDSTR\t0x1000\n\n#define INTCL_PICTLR\t0x0\n#define INTCL_CFGR\t0x14\n#define INTCL_SIGR\t0x60\n#define INTCL_RDYIR\t0x6c\n#define INTCL_SENR\t0xa0\n#define INTCL_CENR\t0xa4\n#define INTCL_CACR\t0xb4\n\nstatic DEFINE_PER_CPU(void __iomem *, intcl_reg);\n\nstatic unsigned long *__trigger;\n\n#define IRQ_OFFSET(irq) ((irq < COMM_IRQ_BASE) ? irq : (irq - COMM_IRQ_BASE))\n\n#define TRIG_BYTE_OFFSET(i)\t((((i) * 2) / 32) * 4)\n#define TRIG_BIT_OFFSET(i)\t (((i) * 2) % 32)\n\n#define TRIG_VAL(trigger, irq)\t(trigger << TRIG_BIT_OFFSET(IRQ_OFFSET(irq)))\n#define TRIG_VAL_MSK(irq)\t    (~(3 << TRIG_BIT_OFFSET(IRQ_OFFSET(irq))))\n\n#define TRIG_BASE(irq) \\\n\t(TRIG_BYTE_OFFSET(IRQ_OFFSET(irq)) + ((irq < COMM_IRQ_BASE) ? \\\n\t(this_cpu_read(intcl_reg) + INTCL_CFGR) : (INTCG_base + INTCG_CICFGR)))\n\nstatic DEFINE_SPINLOCK(setup_lock);\nstatic void setup_trigger(unsigned long irq, unsigned long trigger)\n{\n\tunsigned int tmp;\n\n\tspin_lock(&setup_lock);\n\n\t \n\ttmp = readl_relaxed(TRIG_BASE(irq)) & TRIG_VAL_MSK(irq);\n\n\twritel_relaxed(tmp | TRIG_VAL(trigger, irq), TRIG_BASE(irq));\n\n\tspin_unlock(&setup_lock);\n}\n\nstatic void csky_mpintc_handler(struct pt_regs *regs)\n{\n\tvoid __iomem *reg_base = this_cpu_read(intcl_reg);\n\n\tgeneric_handle_domain_irq(root_domain,\n\t\treadl_relaxed(reg_base + INTCL_RDYIR));\n}\n\nstatic void csky_mpintc_unmask(struct irq_data *d)\n{\n\tvoid __iomem *reg_base = this_cpu_read(intcl_reg);\n\n\tsetup_trigger(d->hwirq, __trigger[d->hwirq]);\n\n\twritel_relaxed(d->hwirq, reg_base + INTCL_SENR);\n}\n\nstatic void csky_mpintc_mask(struct irq_data *d)\n{\n\tvoid __iomem *reg_base = this_cpu_read(intcl_reg);\n\n\twritel_relaxed(d->hwirq, reg_base + INTCL_CENR);\n}\n\nstatic void csky_mpintc_eoi(struct irq_data *d)\n{\n\tvoid __iomem *reg_base = this_cpu_read(intcl_reg);\n\n\twritel_relaxed(d->hwirq, reg_base + INTCL_CACR);\n}\n\nstatic int csky_mpintc_set_type(struct irq_data *d, unsigned int type)\n{\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\t__trigger[d->hwirq] = 0;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\t__trigger[d->hwirq] = 1;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\t__trigger[d->hwirq] = 2;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\t__trigger[d->hwirq] = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SMP\nstatic int csky_irq_set_affinity(struct irq_data *d,\n\t\t\t\t const struct cpumask *mask_val,\n\t\t\t\t bool force)\n{\n\tunsigned int cpu;\n\tunsigned int offset = 4 * (d->hwirq - COMM_IRQ_BASE);\n\n\tif (!force)\n\t\tcpu = cpumask_any_and(mask_val, cpu_online_mask);\n\telse\n\t\tcpu = cpumask_first(mask_val);\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\t \n\tif (cpumask_equal(mask_val, cpu_present_mask))\n\t\tcpu = 0;\n\telse\n\t\tcpu |= BIT(31);\n\n\twritel_relaxed(cpu, INTCG_base + INTCG_CIDSTR + offset);\n\n\tirq_data_update_effective_affinity(d, cpumask_of(cpu));\n\n\treturn IRQ_SET_MASK_OK_DONE;\n}\n#endif\n\nstatic struct irq_chip csky_irq_chip = {\n\t.name           = \"C-SKY SMP Intc\",\n\t.irq_eoi\t= csky_mpintc_eoi,\n\t.irq_unmask\t= csky_mpintc_unmask,\n\t.irq_mask\t= csky_mpintc_mask,\n\t.irq_set_type\t= csky_mpintc_set_type,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity = csky_irq_set_affinity,\n#endif\n};\n\nstatic int csky_irqdomain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tif (hwirq < COMM_IRQ_BASE) {\n\t\tirq_set_percpu_devid(irq);\n\t\tirq_set_chip_and_handler(irq, &csky_irq_chip,\n\t\t\t\t\t handle_percpu_irq);\n\t} else {\n\t\tirq_set_chip_and_handler(irq, &csky_irq_chip,\n\t\t\t\t\t handle_fasteoi_irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int csky_irq_domain_xlate_cells(struct irq_domain *d,\n\t\tstruct device_node *ctrlr, const u32 *intspec,\n\t\tunsigned int intsize, unsigned long *out_hwirq,\n\t\tunsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\n\t*out_hwirq = intspec[0];\n\tif (intsize > 1)\n\t\t*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\telse\n\t\t*out_type = IRQ_TYPE_LEVEL_HIGH;\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops csky_irqdomain_ops = {\n\t.map\t= csky_irqdomain_map,\n\t.xlate\t= csky_irq_domain_xlate_cells,\n};\n\n#ifdef CONFIG_SMP\nstatic void csky_mpintc_send_ipi(const struct cpumask *mask)\n{\n\tvoid __iomem *reg_base = this_cpu_read(intcl_reg);\n\n\t \n\twritel_relaxed((*cpumask_bits(mask)) << 8 | IPI_IRQ,\n\t\t\t\t\treg_base + INTCL_SIGR);\n}\n#endif\n\n \nstatic int __init\ncsky_mpintc_init(struct device_node *node, struct device_node *parent)\n{\n\tint ret;\n\tunsigned int cpu, nr_irq;\n#ifdef CONFIG_SMP\n\tunsigned int ipi_irq;\n#endif\n\n\tif (parent)\n\t\treturn 0;\n\n\tret = of_property_read_u32(node, \"csky,num-irqs\", &nr_irq);\n\tif (ret < 0)\n\t\tnr_irq = INTC_IRQS;\n\n\t__trigger  = kcalloc(nr_irq, sizeof(unsigned long), GFP_KERNEL);\n\tif (__trigger == NULL)\n\t\treturn -ENXIO;\n\n\tif (INTCG_base == NULL) {\n\t\tINTCG_base = ioremap(mfcr(\"cr<31, 14>\"),\n\t\t\t\t     INTCL_SIZE*nr_cpu_ids + INTCG_SIZE);\n\t\tif (INTCG_base == NULL)\n\t\t\treturn -EIO;\n\n\t\tINTCL_base = INTCG_base + INTCG_SIZE;\n\n\t\twritel_relaxed(BIT(0), INTCG_base + INTCG_ICTLR);\n\t}\n\n\troot_domain = irq_domain_add_linear(node, nr_irq, &csky_irqdomain_ops,\n\t\t\t\t\t    NULL);\n\tif (!root_domain)\n\t\treturn -ENXIO;\n\n\t \n\tfor_each_present_cpu(cpu) {\n\t\tper_cpu(intcl_reg, cpu) = INTCL_base + (INTCL_SIZE * cpu);\n\t\twritel_relaxed(BIT(0), per_cpu(intcl_reg, cpu) + INTCL_PICTLR);\n\t}\n\n\tset_handle_irq(&csky_mpintc_handler);\n\n#ifdef CONFIG_SMP\n\tipi_irq = irq_create_mapping(root_domain, IPI_IRQ);\n\tif (!ipi_irq)\n\t\treturn -EIO;\n\n\tset_send_ipi(&csky_mpintc_send_ipi, ipi_irq);\n#endif\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(csky_mpintc, \"csky,mpintc\", csky_mpintc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}