{
  "module_name": "irq-mtk-sysirq.c",
  "hash_id": "a64b32968f62ab317664281fe776a5053feb8b8af987687601d539c92e1a2042",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mtk-sysirq.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\nstruct mtk_sysirq_chip_data {\n\traw_spinlock_t lock;\n\tu32 nr_intpol_bases;\n\tvoid __iomem **intpol_bases;\n\tu32 *intpol_words;\n\tu8 *intpol_idx;\n\tu16 *which_word;\n};\n\nstatic int mtk_sysirq_set_type(struct irq_data *data, unsigned int type)\n{\n\tirq_hw_number_t hwirq = data->hwirq;\n\tstruct mtk_sysirq_chip_data *chip_data = data->chip_data;\n\tu8 intpol_idx = chip_data->intpol_idx[hwirq];\n\tvoid __iomem *base;\n\tu32 offset, reg_index, value;\n\tunsigned long flags;\n\tint ret;\n\n\tbase = chip_data->intpol_bases[intpol_idx];\n\treg_index = chip_data->which_word[hwirq];\n\toffset = hwirq & 0x1f;\n\n\traw_spin_lock_irqsave(&chip_data->lock, flags);\n\tvalue = readl_relaxed(base + reg_index * 4);\n\tif (type == IRQ_TYPE_LEVEL_LOW || type == IRQ_TYPE_EDGE_FALLING) {\n\t\tif (type == IRQ_TYPE_LEVEL_LOW)\n\t\t\ttype = IRQ_TYPE_LEVEL_HIGH;\n\t\telse\n\t\t\ttype = IRQ_TYPE_EDGE_RISING;\n\t\tvalue |= (1 << offset);\n\t} else {\n\t\tvalue &= ~(1 << offset);\n\t}\n\n\twritel_relaxed(value, base + reg_index * 4);\n\n\tdata = data->parent_data;\n\tret = data->chip->irq_set_type(data, type);\n\traw_spin_unlock_irqrestore(&chip_data->lock, flags);\n\treturn ret;\n}\n\nstatic struct irq_chip mtk_sysirq_chip = {\n\t.name\t\t\t= \"MT_SYSIRQ\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_type\t\t= mtk_sysirq_set_type,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic int mtk_sysirq_domain_translate(struct irq_domain *d,\n\t\t\t\t       struct irq_fwspec *fwspec,\n\t\t\t\t       unsigned long *hwirq,\n\t\t\t\t       unsigned int *type)\n{\n\tif (is_of_node(fwspec->fwnode)) {\n\t\tif (fwspec->param_count != 3)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (fwspec->param[0] != 0)\n\t\t\treturn -EINVAL;\n\n\t\t*hwirq = fwspec->param[1];\n\t\t*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mtk_sysirq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t   unsigned int nr_irqs, void *arg)\n{\n\tint i;\n\tirq_hw_number_t hwirq;\n\tstruct irq_fwspec *fwspec = arg;\n\tstruct irq_fwspec gic_fwspec = *fwspec;\n\n\tif (fwspec->param_count != 3)\n\t\treturn -EINVAL;\n\n\t \n\tif (fwspec->param[0])\n\t\treturn -EINVAL;\n\n\thwirq = fwspec->param[1];\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\n\t\t\t\t\t      &mtk_sysirq_chip,\n\t\t\t\t\t      domain->host_data);\n\n\tgic_fwspec.fwnode = domain->parent->fwnode;\n\treturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &gic_fwspec);\n}\n\nstatic const struct irq_domain_ops sysirq_domain_ops = {\n\t.translate\t= mtk_sysirq_domain_translate,\n\t.alloc\t\t= mtk_sysirq_domain_alloc,\n\t.free\t\t= irq_domain_free_irqs_common,\n};\n\nstatic int __init mtk_sysirq_of_init(struct device_node *node,\n\t\t\t\t     struct device_node *parent)\n{\n\tstruct irq_domain *domain, *domain_parent;\n\tstruct mtk_sysirq_chip_data *chip_data;\n\tint ret, size, intpol_num = 0, nr_intpol_bases = 0, i = 0;\n\n\tdomain_parent = irq_find_host(parent);\n\tif (!domain_parent) {\n\t\tpr_err(\"mtk_sysirq: interrupt-parent not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip_data = kzalloc(sizeof(*chip_data), GFP_KERNEL);\n\tif (!chip_data)\n\t\treturn -ENOMEM;\n\n\twhile (of_get_address(node, i++, NULL, NULL))\n\t\tnr_intpol_bases++;\n\n\tif (nr_intpol_bases == 0) {\n\t\tpr_err(\"mtk_sysirq: base address not specified\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_free_chip;\n\t}\n\n\tchip_data->intpol_words = kcalloc(nr_intpol_bases,\n\t\t\t\t\t  sizeof(*chip_data->intpol_words),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!chip_data->intpol_words) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_chip;\n\t}\n\n\tchip_data->intpol_bases = kcalloc(nr_intpol_bases,\n\t\t\t\t\t  sizeof(*chip_data->intpol_bases),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!chip_data->intpol_bases) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_intpol_words;\n\t}\n\n\tfor (i = 0; i < nr_intpol_bases; i++) {\n\t\tstruct resource res;\n\n\t\tret = of_address_to_resource(node, i, &res);\n\t\tsize = resource_size(&res);\n\t\tintpol_num += size * 8;\n\t\tchip_data->intpol_words[i] = size / 4;\n\t\tchip_data->intpol_bases[i] = of_iomap(node, i);\n\t\tif (ret || !chip_data->intpol_bases[i]) {\n\t\t\tpr_err(\"%pOF: couldn't map region %d\\n\", node, i);\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_free_intpol;\n\t\t}\n\t}\n\n\tchip_data->intpol_idx = kcalloc(intpol_num,\n\t\t\t\t\tsizeof(*chip_data->intpol_idx),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!chip_data->intpol_idx) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_intpol;\n\t}\n\n\tchip_data->which_word = kcalloc(intpol_num,\n\t\t\t\t\tsizeof(*chip_data->which_word),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!chip_data->which_word) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_intpol_idx;\n\t}\n\n\t \n\tfor (i = 0; i < intpol_num ; i++) {\n\t\tu32 word = i / 32, j;\n\n\t\tfor (j = 0; word >= chip_data->intpol_words[j] ; j++)\n\t\t\tword -= chip_data->intpol_words[j];\n\n\t\tchip_data->intpol_idx[i] = j;\n\t\tchip_data->which_word[i] = word;\n\t}\n\n\tdomain = irq_domain_add_hierarchy(domain_parent, 0, intpol_num, node,\n\t\t\t\t\t  &sysirq_domain_ops, chip_data);\n\tif (!domain) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_which_word;\n\t}\n\traw_spin_lock_init(&chip_data->lock);\n\n\treturn 0;\n\nout_free_which_word:\n\tkfree(chip_data->which_word);\nout_free_intpol_idx:\n\tkfree(chip_data->intpol_idx);\nout_free_intpol:\n\tfor (i = 0; i < nr_intpol_bases; i++)\n\t\tif (chip_data->intpol_bases[i])\n\t\t\tiounmap(chip_data->intpol_bases[i]);\n\tkfree(chip_data->intpol_bases);\nout_free_intpol_words:\n\tkfree(chip_data->intpol_words);\nout_free_chip:\n\tkfree(chip_data);\n\treturn ret;\n}\nIRQCHIP_DECLARE(mtk_sysirq, \"mediatek,mt6577-sysirq\", mtk_sysirq_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}