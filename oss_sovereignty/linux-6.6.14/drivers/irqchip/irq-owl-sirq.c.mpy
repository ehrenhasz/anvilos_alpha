{
  "module_name": "irq-owl-sirq.c",
  "hash_id": "961a62c17d373c284d05fa64d56c81acdf4d7d92cb07566adccb78c5164b4283",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-owl-sirq.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <dt-bindings/interrupt-controller/arm-gic.h>\n\n#define NUM_SIRQ\t\t\t3\n\n#define INTC_EXTCTL_PENDING\t\tBIT(0)\n#define INTC_EXTCTL_CLK_SEL\t\tBIT(4)\n#define INTC_EXTCTL_EN\t\t\tBIT(5)\n#define INTC_EXTCTL_TYPE_MASK\t\tGENMASK(7, 6)\n#define INTC_EXTCTL_TYPE_HIGH\t\t0\n#define INTC_EXTCTL_TYPE_LOW\t\tBIT(6)\n#define INTC_EXTCTL_TYPE_RISING\t\tBIT(7)\n#define INTC_EXTCTL_TYPE_FALLING\t(BIT(6) | BIT(7))\n\n \n#define INTC_EXTCTL_SIRQ0_MASK\t\tGENMASK(23, 16)\n#define INTC_EXTCTL_SIRQ1_MASK\t\tGENMASK(15, 8)\n#define INTC_EXTCTL_SIRQ2_MASK\t\tGENMASK(7, 0)\n\n \n#define INTC_EXTCTL0\t\t\t0x0000\n#define INTC_EXTCTL1\t\t\t0x0328\n#define INTC_EXTCTL2\t\t\t0x032c\n\nstruct owl_sirq_params {\n\t \n\tbool reg_shared;\n\t \n\tu16 reg_offset[NUM_SIRQ];\n};\n\nstruct owl_sirq_chip_data {\n\tconst struct owl_sirq_params\t*params;\n\tvoid __iomem\t\t\t*base;\n\traw_spinlock_t\t\t\tlock;\n\tu32\t\t\t\text_irqs[NUM_SIRQ];\n};\n\n \nstatic const struct owl_sirq_params owl_sirq_s500_params = {\n\t.reg_shared = true,\n\t.reg_offset = { 0, 0, 0 },\n};\n\n \nstatic const struct owl_sirq_params owl_sirq_s900_params = {\n\t.reg_shared = false,\n\t.reg_offset = { INTC_EXTCTL0, INTC_EXTCTL1, INTC_EXTCTL2 },\n};\n\nstatic u32 owl_field_get(u32 val, u32 index)\n{\n\tswitch (index) {\n\tcase 0:\n\t\treturn FIELD_GET(INTC_EXTCTL_SIRQ0_MASK, val);\n\tcase 1:\n\t\treturn FIELD_GET(INTC_EXTCTL_SIRQ1_MASK, val);\n\tcase 2:\n\tdefault:\n\t\treturn FIELD_GET(INTC_EXTCTL_SIRQ2_MASK, val);\n\t}\n}\n\nstatic u32 owl_field_prep(u32 val, u32 index)\n{\n\tswitch (index) {\n\tcase 0:\n\t\treturn FIELD_PREP(INTC_EXTCTL_SIRQ0_MASK, val);\n\tcase 1:\n\t\treturn FIELD_PREP(INTC_EXTCTL_SIRQ1_MASK, val);\n\tcase 2:\n\tdefault:\n\t\treturn FIELD_PREP(INTC_EXTCTL_SIRQ2_MASK, val);\n\t}\n}\n\nstatic u32 owl_sirq_read_extctl(struct owl_sirq_chip_data *data, u32 index)\n{\n\tu32 val;\n\n\tval = readl_relaxed(data->base + data->params->reg_offset[index]);\n\tif (data->params->reg_shared)\n\t\tval = owl_field_get(val, index);\n\n\treturn val;\n}\n\nstatic void owl_sirq_write_extctl(struct owl_sirq_chip_data *data,\n\t\t\t\t  u32 extctl, u32 index)\n{\n\tu32 val;\n\n\tif (data->params->reg_shared) {\n\t\tval = readl_relaxed(data->base + data->params->reg_offset[index]);\n\t\tval &= ~owl_field_prep(0xff, index);\n\t\textctl = owl_field_prep(extctl, index) | val;\n\t}\n\n\twritel_relaxed(extctl, data->base + data->params->reg_offset[index]);\n}\n\nstatic void owl_sirq_clear_set_extctl(struct owl_sirq_chip_data *d,\n\t\t\t\t      u32 clear, u32 set, u32 index)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&d->lock, flags);\n\tval = owl_sirq_read_extctl(d, index);\n\tval &= ~clear;\n\tval |= set;\n\towl_sirq_write_extctl(d, val, index);\n\traw_spin_unlock_irqrestore(&d->lock, flags);\n}\n\nstatic void owl_sirq_eoi(struct irq_data *data)\n{\n\tstruct owl_sirq_chip_data *chip_data = irq_data_get_irq_chip_data(data);\n\n\t \n\tif (!irqd_is_level_type(data))\n\t\towl_sirq_clear_set_extctl(chip_data, 0, INTC_EXTCTL_PENDING,\n\t\t\t\t\t  data->hwirq);\n\n\tirq_chip_eoi_parent(data);\n}\n\nstatic void owl_sirq_mask(struct irq_data *data)\n{\n\tstruct owl_sirq_chip_data *chip_data = irq_data_get_irq_chip_data(data);\n\n\towl_sirq_clear_set_extctl(chip_data, INTC_EXTCTL_EN, 0, data->hwirq);\n\tirq_chip_mask_parent(data);\n}\n\nstatic void owl_sirq_unmask(struct irq_data *data)\n{\n\tstruct owl_sirq_chip_data *chip_data = irq_data_get_irq_chip_data(data);\n\n\towl_sirq_clear_set_extctl(chip_data, 0, INTC_EXTCTL_EN, data->hwirq);\n\tirq_chip_unmask_parent(data);\n}\n\n \nstatic int owl_sirq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct owl_sirq_chip_data *chip_data = irq_data_get_irq_chip_data(data);\n\tu32 sirq_type;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tsirq_type = INTC_EXTCTL_TYPE_LOW;\n\t\ttype = IRQ_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tsirq_type = INTC_EXTCTL_TYPE_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tsirq_type = INTC_EXTCTL_TYPE_FALLING;\n\t\ttype = IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tsirq_type = INTC_EXTCTL_TYPE_RISING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\towl_sirq_clear_set_extctl(chip_data, INTC_EXTCTL_TYPE_MASK, sirq_type,\n\t\t\t\t  data->hwirq);\n\n\treturn irq_chip_set_type_parent(data, type);\n}\n\nstatic struct irq_chip owl_sirq_chip = {\n\t.name\t\t= \"owl-sirq\",\n\t.irq_mask\t= owl_sirq_mask,\n\t.irq_unmask\t= owl_sirq_unmask,\n\t.irq_eoi\t= owl_sirq_eoi,\n\t.irq_set_type\t= owl_sirq_set_type,\n\t.irq_retrigger\t= irq_chip_retrigger_hierarchy,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity = irq_chip_set_affinity_parent,\n#endif\n};\n\nstatic int owl_sirq_domain_translate(struct irq_domain *d,\n\t\t\t\t     struct irq_fwspec *fwspec,\n\t\t\t\t     unsigned long *hwirq,\n\t\t\t\t     unsigned int *type)\n{\n\tif (!is_of_node(fwspec->fwnode))\n\t\treturn -EINVAL;\n\n\tif (fwspec->param_count != 2 || fwspec->param[0] >= NUM_SIRQ)\n\t\treturn -EINVAL;\n\n\t*hwirq = fwspec->param[0];\n\t*type = fwspec->param[1];\n\n\treturn 0;\n}\n\nstatic int owl_sirq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs, void *data)\n{\n\tstruct owl_sirq_chip_data *chip_data = domain->host_data;\n\tstruct irq_fwspec *fwspec = data;\n\tstruct irq_fwspec parent_fwspec;\n\tirq_hw_number_t hwirq;\n\tunsigned int type;\n\tint ret;\n\n\tif (WARN_ON(nr_irqs != 1))\n\t\treturn -EINVAL;\n\n\tret = owl_sirq_domain_translate(domain, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\ttype = IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\ttype = IRQ_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, &owl_sirq_chip,\n\t\t\t\t      chip_data);\n\n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\tparent_fwspec.param_count = 3;\n\tparent_fwspec.param[0] = GIC_SPI;\n\tparent_fwspec.param[1] = chip_data->ext_irqs[hwirq];\n\tparent_fwspec.param[2] = type;\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, 1, &parent_fwspec);\n}\n\nstatic const struct irq_domain_ops owl_sirq_domain_ops = {\n\t.translate\t= owl_sirq_domain_translate,\n\t.alloc\t\t= owl_sirq_domain_alloc,\n\t.free\t\t= irq_domain_free_irqs_common,\n};\n\nstatic int __init owl_sirq_init(const struct owl_sirq_params *params,\n\t\t\t\tstruct device_node *node,\n\t\t\t\tstruct device_node *parent)\n{\n\tstruct irq_domain *domain, *parent_domain;\n\tstruct owl_sirq_chip_data *chip_data;\n\tint ret, i;\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tpr_err(\"%pOF: failed to find sirq parent domain\\n\", node);\n\t\treturn -ENXIO;\n\t}\n\n\tchip_data = kzalloc(sizeof(*chip_data), GFP_KERNEL);\n\tif (!chip_data)\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_init(&chip_data->lock);\n\n\tchip_data->params = params;\n\n\tchip_data->base = of_iomap(node, 0);\n\tif (!chip_data->base) {\n\t\tpr_err(\"%pOF: failed to map sirq registers\\n\", node);\n\t\tret = -ENXIO;\n\t\tgoto out_free;\n\t}\n\n\tfor (i = 0; i < NUM_SIRQ; i++) {\n\t\tstruct of_phandle_args irq;\n\n\t\tret = of_irq_parse_one(node, i, &irq);\n\t\tif (ret) {\n\t\t\tpr_err(\"%pOF: failed to parse interrupt %d\\n\", node, i);\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\tif (WARN_ON(irq.args_count != 3)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\tchip_data->ext_irqs[i] = irq.args[1];\n\n\t\t \n\t\towl_sirq_clear_set_extctl(chip_data, 0, INTC_EXTCTL_CLK_SEL, i);\n\t}\n\n\tdomain = irq_domain_add_hierarchy(parent_domain, 0, NUM_SIRQ, node,\n\t\t\t\t\t  &owl_sirq_domain_ops, chip_data);\n\tif (!domain) {\n\t\tpr_err(\"%pOF: failed to add domain\\n\", node);\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n\treturn 0;\n\nout_unmap:\n\tiounmap(chip_data->base);\nout_free:\n\tkfree(chip_data);\n\n\treturn ret;\n}\n\nstatic int __init owl_sirq_s500_of_init(struct device_node *node,\n\t\t\t\t\tstruct device_node *parent)\n{\n\treturn owl_sirq_init(&owl_sirq_s500_params, node, parent);\n}\n\nIRQCHIP_DECLARE(owl_sirq_s500, \"actions,s500-sirq\", owl_sirq_s500_of_init);\nIRQCHIP_DECLARE(owl_sirq_s700, \"actions,s700-sirq\", owl_sirq_s500_of_init);\n\nstatic int __init owl_sirq_s900_of_init(struct device_node *node,\n\t\t\t\t\tstruct device_node *parent)\n{\n\treturn owl_sirq_init(&owl_sirq_s900_params, node, parent);\n}\n\nIRQCHIP_DECLARE(owl_sirq_s900, \"actions,s900-sirq\", owl_sirq_s900_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}