{
  "module_name": "irq-orion.c",
  "hash_id": "d887ea7b43bc1f8d9d7f2d47e705b001f9322e32c5291dc6c9c3faddc0c61c43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-orion.c",
  "human_readable_source": " \n\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <asm/exception.h>\n#include <asm/mach/irq.h>\n\n \n#define ORION_IRQS_PER_CHIP\t\t32\n\n#define ORION_IRQ_CAUSE\t\t\t0x00\n#define ORION_IRQ_MASK\t\t\t0x04\n#define ORION_IRQ_FIQ_MASK\t\t0x08\n#define ORION_IRQ_ENDP_MASK\t\t0x0c\n\nstatic struct irq_domain *orion_irq_domain;\n\nstatic void\n__exception_irq_entry orion_handle_irq(struct pt_regs *regs)\n{\n\tstruct irq_domain_chip_generic *dgc = orion_irq_domain->gc;\n\tint n, base = 0;\n\n\tfor (n = 0; n < dgc->num_chips; n++, base += ORION_IRQS_PER_CHIP) {\n\t\tstruct irq_chip_generic *gc =\n\t\t\tirq_get_domain_generic_chip(orion_irq_domain, base);\n\t\tu32 stat = readl_relaxed(gc->reg_base + ORION_IRQ_CAUSE) &\n\t\t\tgc->mask_cache;\n\t\twhile (stat) {\n\t\t\tu32 hwirq = __fls(stat);\n\t\t\tgeneric_handle_domain_irq(orion_irq_domain,\n\t\t\t\t\t\t  gc->irq_base + hwirq);\n\t\t\tstat &= ~(1 << hwirq);\n\t\t}\n\t}\n}\n\nstatic int __init orion_irq_init(struct device_node *np,\n\t\t\t\t struct device_node *parent)\n{\n\tunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\n\tint n, ret, base, num_chips = 0;\n\tstruct resource r;\n\n\t \n\tnum_chips = of_address_count(np);\n\n\torion_irq_domain = irq_domain_add_linear(np,\n\t\t\t\tnum_chips * ORION_IRQS_PER_CHIP,\n\t\t\t\t&irq_generic_chip_ops, NULL);\n\tif (!orion_irq_domain)\n\t\tpanic(\"%pOFn: unable to add irq domain\\n\", np);\n\n\tret = irq_alloc_domain_generic_chips(orion_irq_domain,\n\t\t\t\tORION_IRQS_PER_CHIP, 1, np->full_name,\n\t\t\t\thandle_level_irq, clr, 0,\n\t\t\t\tIRQ_GC_INIT_MASK_CACHE);\n\tif (ret)\n\t\tpanic(\"%pOFn: unable to alloc irq domain gc\\n\", np);\n\n\tfor (n = 0, base = 0; n < num_chips; n++, base += ORION_IRQS_PER_CHIP) {\n\t\tstruct irq_chip_generic *gc =\n\t\t\tirq_get_domain_generic_chip(orion_irq_domain, base);\n\n\t\tof_address_to_resource(np, n, &r);\n\n\t\tif (!request_mem_region(r.start, resource_size(&r), np->name))\n\t\t\tpanic(\"%pOFn: unable to request mem region %d\",\n\t\t\t      np, n);\n\n\t\tgc->reg_base = ioremap(r.start, resource_size(&r));\n\t\tif (!gc->reg_base)\n\t\t\tpanic(\"%pOFn: unable to map resource %d\", np, n);\n\n\t\tgc->chip_types[0].regs.mask = ORION_IRQ_MASK;\n\t\tgc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit;\n\t\tgc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit;\n\n\t\t \n\t\twritel(0, gc->reg_base + ORION_IRQ_MASK);\n\t}\n\n\tset_handle_irq(orion_handle_irq);\n\treturn 0;\n}\nIRQCHIP_DECLARE(orion_intc, \"marvell,orion-intc\", orion_irq_init);\n\n \n#define ORION_BRIDGE_IRQ_CAUSE\t0x00\n#define ORION_BRIDGE_IRQ_MASK\t0x04\n\nstatic void orion_bridge_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_domain *d = irq_desc_get_handler_data(desc);\n\n\tstruct irq_chip_generic *gc = irq_get_domain_generic_chip(d, 0);\n\tu32 stat = readl_relaxed(gc->reg_base + ORION_BRIDGE_IRQ_CAUSE) &\n\t\t   gc->mask_cache;\n\n\twhile (stat) {\n\t\tu32 hwirq = __fls(stat);\n\n\t\tgeneric_handle_domain_irq(d, gc->irq_base + hwirq);\n\t\tstat &= ~(1 << hwirq);\n\t}\n}\n\n \nstatic unsigned int orion_bridge_irq_startup(struct irq_data *d)\n{\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\n\tct->chip.irq_ack(d);\n\tct->chip.irq_unmask(d);\n\treturn 0;\n}\n\nstatic int __init orion_bridge_irq_init(struct device_node *np,\n\t\t\t\t\tstruct device_node *parent)\n{\n\tunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\n\tstruct resource r;\n\tstruct irq_domain *domain;\n\tstruct irq_chip_generic *gc;\n\tint ret, irq, nrirqs = 32;\n\n\t \n\tof_property_read_u32(np, \"marvell,#interrupts\", &nrirqs);\n\n\tdomain = irq_domain_add_linear(np, nrirqs,\n\t\t\t\t       &irq_generic_chip_ops, NULL);\n\tif (!domain) {\n\t\tpr_err(\"%pOFn: unable to add irq domain\\n\", np);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(domain, nrirqs, 1, np->name,\n\t\t\t     handle_edge_irq, clr, 0, IRQ_GC_INIT_MASK_CACHE);\n\tif (ret) {\n\t\tpr_err(\"%pOFn: unable to alloc irq domain gc\\n\", np);\n\t\treturn ret;\n\t}\n\n\tret = of_address_to_resource(np, 0, &r);\n\tif (ret) {\n\t\tpr_err(\"%pOFn: unable to get resource\\n\", np);\n\t\treturn ret;\n\t}\n\n\tif (!request_mem_region(r.start, resource_size(&r), np->name)) {\n\t\tpr_err(\"%s: unable to request mem region\\n\", np->name);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tirq = irq_of_parse_and_map(np, 0);\n\tif (irq <= 0) {\n\t\tpr_err(\"%pOFn: unable to parse irq\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tgc = irq_get_domain_generic_chip(domain, 0);\n\tgc->reg_base = ioremap(r.start, resource_size(&r));\n\tif (!gc->reg_base) {\n\t\tpr_err(\"%pOFn: unable to map resource\\n\", np);\n\t\treturn -ENOMEM;\n\t}\n\n\tgc->chip_types[0].regs.ack = ORION_BRIDGE_IRQ_CAUSE;\n\tgc->chip_types[0].regs.mask = ORION_BRIDGE_IRQ_MASK;\n\tgc->chip_types[0].chip.irq_startup = orion_bridge_irq_startup;\n\tgc->chip_types[0].chip.irq_ack = irq_gc_ack_clr_bit;\n\tgc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit;\n\tgc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit;\n\n\t \n\twritel(0, gc->reg_base + ORION_BRIDGE_IRQ_MASK);\n\twritel(0, gc->reg_base + ORION_BRIDGE_IRQ_CAUSE);\n\n\tirq_set_chained_handler_and_data(irq, orion_bridge_irq_handler,\n\t\t\t\t\t domain);\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(orion_bridge_intc,\n\t\t\"marvell,orion-bridge-intc\", orion_bridge_irq_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}