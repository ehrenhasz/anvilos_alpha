{
  "module_name": "irq-mscc-ocelot.c",
  "hash_id": "0d095c5b4270bb501a6d88d8c32fd6f545e6d261adb37874b13eab820e88a843",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mscc-ocelot.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/irq.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/interrupt.h>\n\n#define ICPU_CFG_INTR_DST_INTR_IDENT(_p, x) ((_p)->reg_off_ident + 0x4 * (x))\n#define ICPU_CFG_INTR_INTR_TRIGGER(_p, x)   ((_p)->reg_off_trigger + 0x4 * (x))\n\n#define FLAGS_HAS_TRIGGER\tBIT(0)\n#define FLAGS_NEED_INIT_ENABLE\tBIT(1)\n\nstruct chip_props {\n\tu8 flags;\n\tu8 reg_off_sticky;\n\tu8 reg_off_ena;\n\tu8 reg_off_ena_clr;\n\tu8 reg_off_ena_set;\n\tu8 reg_off_ident;\n\tu8 reg_off_trigger;\n\tu8 reg_off_ena_irq0;\n\tu8 n_irq;\n};\n\nstatic struct chip_props ocelot_props = {\n\t.flags\t\t\t= FLAGS_HAS_TRIGGER,\n\t.reg_off_sticky\t\t= 0x10,\n\t.reg_off_ena\t\t= 0x18,\n\t.reg_off_ena_clr\t= 0x1c,\n\t.reg_off_ena_set\t= 0x20,\n\t.reg_off_ident\t\t= 0x38,\n\t.reg_off_trigger\t= 0x5c,\n\t.n_irq\t\t\t= 24,\n};\n\nstatic struct chip_props serval_props = {\n\t.flags\t\t\t= FLAGS_HAS_TRIGGER,\n\t.reg_off_sticky\t\t= 0xc,\n\t.reg_off_ena\t\t= 0x14,\n\t.reg_off_ena_clr\t= 0x18,\n\t.reg_off_ena_set\t= 0x1c,\n\t.reg_off_ident\t\t= 0x20,\n\t.reg_off_trigger\t= 0x4,\n\t.n_irq\t\t\t= 24,\n};\n\nstatic struct chip_props luton_props = {\n\t.flags\t\t\t= FLAGS_NEED_INIT_ENABLE,\n\t.reg_off_sticky\t\t= 0,\n\t.reg_off_ena\t\t= 0x4,\n\t.reg_off_ena_clr\t= 0x8,\n\t.reg_off_ena_set\t= 0xc,\n\t.reg_off_ident\t\t= 0x18,\n\t.reg_off_ena_irq0\t= 0x14,\n\t.n_irq\t\t\t= 28,\n};\n\nstatic struct chip_props jaguar2_props = {\n\t.flags\t\t\t= FLAGS_HAS_TRIGGER,\n\t.reg_off_sticky\t\t= 0x10,\n\t.reg_off_ena\t\t= 0x18,\n\t.reg_off_ena_clr\t= 0x1c,\n\t.reg_off_ena_set\t= 0x20,\n\t.reg_off_ident\t\t= 0x38,\n\t.reg_off_trigger\t= 0x5c,\n\t.n_irq\t\t\t= 29,\n};\n\nstatic void ocelot_irq_unmask(struct irq_data *data)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\n\tstruct irq_domain *d = data->domain;\n\tstruct chip_props *p = d->host_data;\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(data);\n\tunsigned int mask = data->mask;\n\tu32 val;\n\n\tirq_gc_lock(gc);\n\tval = irq_reg_readl(gc, ICPU_CFG_INTR_INTR_TRIGGER(p, 0)) |\n\t\tirq_reg_readl(gc, ICPU_CFG_INTR_INTR_TRIGGER(p, 1));\n\tif (!(val & mask))\n\t\tirq_reg_writel(gc, mask, p->reg_off_sticky);\n\n\t*ct->mask_cache &= ~mask;\n\tirq_reg_writel(gc, mask, p->reg_off_ena_set);\n\tirq_gc_unlock(gc);\n}\n\nstatic void ocelot_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irq_domain *d = irq_desc_get_handler_data(desc);\n\tstruct chip_props *p = d->host_data;\n\tstruct irq_chip_generic *gc = irq_get_domain_generic_chip(d, 0);\n\tu32 reg = irq_reg_readl(gc, ICPU_CFG_INTR_DST_INTR_IDENT(p, 0));\n\n\tchained_irq_enter(chip, desc);\n\n\twhile (reg) {\n\t\tu32 hwirq = __fls(reg);\n\n\t\tgeneric_handle_domain_irq(d, hwirq);\n\t\treg &= ~(BIT(hwirq));\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int __init vcoreiii_irq_init(struct device_node *node,\n\t\t\t\t    struct device_node *parent,\n\t\t\t\t    struct chip_props *p)\n{\n\tstruct irq_domain *domain;\n\tstruct irq_chip_generic *gc;\n\tint parent_irq, ret;\n\n\tparent_irq = irq_of_parse_and_map(node, 0);\n\tif (!parent_irq)\n\t\treturn -EINVAL;\n\n\tdomain = irq_domain_add_linear(node, p->n_irq,\n\t\t\t\t       &irq_generic_chip_ops, NULL);\n\tif (!domain) {\n\t\tpr_err(\"%pOFn: unable to add irq domain\\n\", node);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(domain, p->n_irq, 1,\n\t\t\t\t\t     \"icpu\", handle_level_irq,\n\t\t\t\t\t     0, 0, 0);\n\tif (ret) {\n\t\tpr_err(\"%pOFn: unable to alloc irq domain gc\\n\", node);\n\t\tgoto err_domain_remove;\n\t}\n\n\tgc = irq_get_domain_generic_chip(domain, 0);\n\tgc->reg_base = of_iomap(node, 0);\n\tif (!gc->reg_base) {\n\t\tpr_err(\"%pOFn: unable to map resource\\n\", node);\n\t\tret = -ENOMEM;\n\t\tgoto err_gc_free;\n\t}\n\n\tgc->chip_types[0].chip.irq_ack = irq_gc_ack_set_bit;\n\tgc->chip_types[0].regs.ack = p->reg_off_sticky;\n\tif (p->flags & FLAGS_HAS_TRIGGER) {\n\t\tgc->chip_types[0].regs.mask = p->reg_off_ena_clr;\n\t\tgc->chip_types[0].chip.irq_unmask = ocelot_irq_unmask;\n\t\tgc->chip_types[0].chip.irq_mask = irq_gc_mask_set_bit;\n\t} else {\n\t\tgc->chip_types[0].regs.enable = p->reg_off_ena_set;\n\t\tgc->chip_types[0].regs.disable = p->reg_off_ena_clr;\n\t\tgc->chip_types[0].chip.irq_mask = irq_gc_mask_disable_reg;\n\t\tgc->chip_types[0].chip.irq_unmask = irq_gc_unmask_enable_reg;\n\t}\n\n\t \n\tirq_reg_writel(gc, 0, p->reg_off_ena);\n\tirq_reg_writel(gc, 0xffffffff, p->reg_off_sticky);\n\n\t \n\tif (p->flags & FLAGS_NEED_INIT_ENABLE)\n\t\tirq_reg_writel(gc, BIT(0), p->reg_off_ena_irq0);\n\n\tdomain->host_data = p;\n\tirq_set_chained_handler_and_data(parent_irq, ocelot_irq_handler,\n\t\t\t\t\t domain);\n\n\treturn 0;\n\nerr_gc_free:\n\tirq_free_generic_chip(gc);\n\nerr_domain_remove:\n\tirq_domain_remove(domain);\n\n\treturn ret;\n}\n\nstatic int __init ocelot_irq_init(struct device_node *node,\n\t\t\t\t  struct device_node *parent)\n{\n\treturn vcoreiii_irq_init(node, parent, &ocelot_props);\n}\n\nIRQCHIP_DECLARE(ocelot_icpu, \"mscc,ocelot-icpu-intr\", ocelot_irq_init);\n\nstatic int __init serval_irq_init(struct device_node *node,\n\t\t\t\t  struct device_node *parent)\n{\n\treturn vcoreiii_irq_init(node, parent, &serval_props);\n}\n\nIRQCHIP_DECLARE(serval_icpu, \"mscc,serval-icpu-intr\", serval_irq_init);\n\nstatic int __init luton_irq_init(struct device_node *node,\n\t\t\t\t struct device_node *parent)\n{\n\treturn vcoreiii_irq_init(node, parent, &luton_props);\n}\n\nIRQCHIP_DECLARE(luton_icpu, \"mscc,luton-icpu-intr\", luton_irq_init);\n\nstatic int __init jaguar2_irq_init(struct device_node *node,\n\t\t\t\t   struct device_node *parent)\n{\n\treturn vcoreiii_irq_init(node, parent, &jaguar2_props);\n}\n\nIRQCHIP_DECLARE(jaguar2_icpu, \"mscc,jaguar2-icpu-intr\", jaguar2_irq_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}