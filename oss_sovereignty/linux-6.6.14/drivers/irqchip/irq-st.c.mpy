{
  "module_name": "irq-st.c",
  "hash_id": "0c93132854cc099d76b308ef59353d18c75a4664e8d2a6d3190927d1be24c60c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-st.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/interrupt-controller/irq-st.h>\n#include <linux/err.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define STIH407_SYSCFG_5102\t\t0x198\n\n#define ST_A9_IRQ_MASK\t\t\t0x001FFFFF\n#define ST_A9_IRQ_MAX_CHANS\t\t2\n\n#define ST_A9_IRQ_EN_CTI_0\t\tBIT(0)\n#define ST_A9_IRQ_EN_CTI_1\t\tBIT(1)\n#define ST_A9_IRQ_EN_PMU_0\t\tBIT(2)\n#define ST_A9_IRQ_EN_PMU_1\t\tBIT(3)\n#define ST_A9_IRQ_EN_PL310_L2\t\tBIT(4)\n#define ST_A9_IRQ_EN_EXT_0\t\tBIT(5)\n#define ST_A9_IRQ_EN_EXT_1\t\tBIT(6)\n#define ST_A9_IRQ_EN_EXT_2\t\tBIT(7)\n\n#define ST_A9_FIQ_N_SEL(dev, chan)\t(dev << (8  + (chan * 3)))\n#define ST_A9_IRQ_N_SEL(dev, chan)\t(dev << (14 + (chan * 3)))\n#define ST_A9_EXTIRQ_INV_SEL(dev)\t(dev << 20)\n\nstruct st_irq_syscfg {\n\tstruct regmap *regmap;\n\tunsigned int syscfg;\n\tunsigned int config;\n\tbool ext_inverted;\n};\n\nstatic const struct of_device_id st_irq_syscfg_match[] = {\n\t{\n\t\t.compatible = \"st,stih407-irq-syscfg\",\n\t\t.data = (void *)STIH407_SYSCFG_5102,\n\t},\n\t{}\n};\n\nstatic int st_irq_xlate(struct platform_device *pdev,\n\t\t\tint device, int channel, bool irq)\n{\n\tstruct st_irq_syscfg *ddata = dev_get_drvdata(&pdev->dev);\n\n\t \n\tswitch (device) {\n\tcase ST_IRQ_SYSCFG_EXT_0:\n\t\tddata->config |= ST_A9_IRQ_EN_EXT_0;\n\t\tbreak;\n\tcase ST_IRQ_SYSCFG_EXT_1:\n\t\tddata->config |= ST_A9_IRQ_EN_EXT_1;\n\t\tbreak;\n\tcase ST_IRQ_SYSCFG_EXT_2:\n\t\tddata->config |= ST_A9_IRQ_EN_EXT_2;\n\t\tbreak;\n\tcase ST_IRQ_SYSCFG_CTI_0:\n\t\tddata->config |= ST_A9_IRQ_EN_CTI_0;\n\t\tbreak;\n\tcase ST_IRQ_SYSCFG_CTI_1:\n\t\tddata->config |= ST_A9_IRQ_EN_CTI_1;\n\t\tbreak;\n\tcase ST_IRQ_SYSCFG_PMU_0:\n\t\tddata->config |= ST_A9_IRQ_EN_PMU_0;\n\t\tbreak;\n\tcase ST_IRQ_SYSCFG_PMU_1:\n\t\tddata->config |= ST_A9_IRQ_EN_PMU_1;\n\t\tbreak;\n\tcase ST_IRQ_SYSCFG_pl310_L2:\n\t\tddata->config |= ST_A9_IRQ_EN_PL310_L2;\n\t\tbreak;\n\tcase ST_IRQ_SYSCFG_DISABLED:\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unrecognised device %d\\n\", device);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tddata->config |= irq ?\n\t\tST_A9_IRQ_N_SEL(device, channel) :\n\t\tST_A9_FIQ_N_SEL(device, channel);\n\n\treturn 0;\n}\n\nstatic int st_irq_syscfg_enable(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct st_irq_syscfg *ddata = dev_get_drvdata(&pdev->dev);\n\tint channels, ret, i;\n\tu32 device, invert;\n\n\tchannels = of_property_count_u32_elems(np, \"st,irq-device\");\n\tif (channels != ST_A9_IRQ_MAX_CHANS) {\n\t\tdev_err(&pdev->dev, \"st,enable-irq-device must have 2 elems\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = of_property_count_u32_elems(np, \"st,fiq-device\");\n\tif (channels != ST_A9_IRQ_MAX_CHANS) {\n\t\tdev_err(&pdev->dev, \"st,enable-fiq-device must have 2 elems\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ST_A9_IRQ_MAX_CHANS; i++) {\n\t\tof_property_read_u32_index(np, \"st,irq-device\", i, &device);\n\n\t\tret = st_irq_xlate(pdev, device, i, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tof_property_read_u32_index(np, \"st,fiq-device\", i, &device);\n\n\t\tret = st_irq_xlate(pdev, device, i, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tof_property_read_u32(np, \"st,invert-ext\", &invert);\n\tddata->config |= ST_A9_EXTIRQ_INV_SEL(invert);\n\n\treturn regmap_update_bits(ddata->regmap, ddata->syscfg,\n\t\t\t\t  ST_A9_IRQ_MASK, ddata->config);\n}\n\nstatic int st_irq_syscfg_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct st_irq_syscfg *ddata;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tddata->syscfg = (unsigned int) device_get_match_data(&pdev->dev);\n\n\tddata->regmap = syscon_regmap_lookup_by_phandle(np, \"st,syscfg\");\n\tif (IS_ERR(ddata->regmap)) {\n\t\tdev_err(&pdev->dev, \"syscfg phandle missing\\n\");\n\t\treturn PTR_ERR(ddata->regmap);\n\t}\n\n\tdev_set_drvdata(&pdev->dev, ddata);\n\n\treturn st_irq_syscfg_enable(pdev);\n}\n\nstatic int __maybe_unused st_irq_syscfg_resume(struct device *dev)\n{\n\tstruct st_irq_syscfg *ddata = dev_get_drvdata(dev);\n\n\treturn regmap_update_bits(ddata->regmap, ddata->syscfg,\n\t\t\t\t  ST_A9_IRQ_MASK, ddata->config);\n}\n\nstatic SIMPLE_DEV_PM_OPS(st_irq_syscfg_pm_ops, NULL, st_irq_syscfg_resume);\n\nstatic struct platform_driver st_irq_syscfg_driver = {\n\t.driver = {\n\t\t.name = \"st_irq_syscfg\",\n\t\t.pm = &st_irq_syscfg_pm_ops,\n\t\t.of_match_table = st_irq_syscfg_match,\n\t},\n\t.probe = st_irq_syscfg_probe,\n};\n\nstatic int __init st_irq_syscfg_init(void)\n{\n\treturn platform_driver_register(&st_irq_syscfg_driver);\n}\ncore_initcall(st_irq_syscfg_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}