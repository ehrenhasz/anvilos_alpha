{
  "module_name": "irq-sun4i.c",
  "hash_id": "1c9c911ee0bb63b8b1a8b7f7d8b7f812629181dd84fce80dc6ba016d60a33c91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-sun4i.c",
  "human_readable_source": " \n\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <asm/exception.h>\n\n#define SUN4I_IRQ_VECTOR_REG\t\t0x00\n#define SUN4I_IRQ_PROTECTION_REG\t0x08\n#define SUN4I_IRQ_NMI_CTRL_REG\t\t0x0c\n#define SUN4I_IRQ_PENDING_REG(x)\t(0x10 + 0x4 * x)\n#define SUN4I_IRQ_FIQ_PENDING_REG(x)\t(0x20 + 0x4 * x)\n#define SUN4I_IRQ_ENABLE_REG(data, x)\t((data)->enable_reg_offset + 0x4 * x)\n#define SUN4I_IRQ_MASK_REG(data, x)\t((data)->mask_reg_offset + 0x4 * x)\n#define SUN4I_IRQ_ENABLE_REG_OFFSET\t0x40\n#define SUN4I_IRQ_MASK_REG_OFFSET\t0x50\n#define SUNIV_IRQ_ENABLE_REG_OFFSET\t0x20\n#define SUNIV_IRQ_MASK_REG_OFFSET\t0x30\n\nstruct sun4i_irq_chip_data {\n\tvoid __iomem *irq_base;\n\tstruct irq_domain *irq_domain;\n\tu32 enable_reg_offset;\n\tu32 mask_reg_offset;\n};\n\nstatic struct sun4i_irq_chip_data *irq_ic_data;\n\nstatic void __exception_irq_entry sun4i_handle_irq(struct pt_regs *regs);\n\nstatic void sun4i_irq_ack(struct irq_data *irqd)\n{\n\tunsigned int irq = irqd_to_hwirq(irqd);\n\n\tif (irq != 0)\n\t\treturn;  \n\n\twritel(BIT(0), irq_ic_data->irq_base + SUN4I_IRQ_PENDING_REG(0));\n}\n\nstatic void sun4i_irq_mask(struct irq_data *irqd)\n{\n\tunsigned int irq = irqd_to_hwirq(irqd);\n\tunsigned int irq_off = irq % 32;\n\tint reg = irq / 32;\n\tu32 val;\n\n\tval = readl(irq_ic_data->irq_base +\n\t\t\tSUN4I_IRQ_ENABLE_REG(irq_ic_data, reg));\n\twritel(val & ~(1 << irq_off),\n\t       irq_ic_data->irq_base + SUN4I_IRQ_ENABLE_REG(irq_ic_data, reg));\n}\n\nstatic void sun4i_irq_unmask(struct irq_data *irqd)\n{\n\tunsigned int irq = irqd_to_hwirq(irqd);\n\tunsigned int irq_off = irq % 32;\n\tint reg = irq / 32;\n\tu32 val;\n\n\tval = readl(irq_ic_data->irq_base +\n\t\t\tSUN4I_IRQ_ENABLE_REG(irq_ic_data, reg));\n\twritel(val | (1 << irq_off),\n\t       irq_ic_data->irq_base + SUN4I_IRQ_ENABLE_REG(irq_ic_data, reg));\n}\n\nstatic struct irq_chip sun4i_irq_chip = {\n\t.name\t\t= \"sun4i_irq\",\n\t.irq_eoi\t= sun4i_irq_ack,\n\t.irq_mask\t= sun4i_irq_mask,\n\t.irq_unmask\t= sun4i_irq_unmask,\n\t.flags\t\t= IRQCHIP_EOI_THREADED | IRQCHIP_EOI_IF_HANDLED,\n};\n\nstatic int sun4i_irq_map(struct irq_domain *d, unsigned int virq,\n\t\t\t irq_hw_number_t hw)\n{\n\tirq_set_chip_and_handler(virq, &sun4i_irq_chip, handle_fasteoi_irq);\n\tirq_set_probe(virq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops sun4i_irq_ops = {\n\t.map = sun4i_irq_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic int __init sun4i_of_init(struct device_node *node,\n\t\t\t\tstruct device_node *parent)\n{\n\tirq_ic_data->irq_base = of_iomap(node, 0);\n\tif (!irq_ic_data->irq_base)\n\t\tpanic(\"%pOF: unable to map IC registers\\n\",\n\t\t\tnode);\n\n\t \n\twritel(0, irq_ic_data->irq_base + SUN4I_IRQ_ENABLE_REG(irq_ic_data, 0));\n\twritel(0, irq_ic_data->irq_base + SUN4I_IRQ_ENABLE_REG(irq_ic_data, 1));\n\twritel(0, irq_ic_data->irq_base + SUN4I_IRQ_ENABLE_REG(irq_ic_data, 2));\n\n\t \n\twritel(0, irq_ic_data->irq_base + SUN4I_IRQ_MASK_REG(irq_ic_data, 0));\n\twritel(0, irq_ic_data->irq_base + SUN4I_IRQ_MASK_REG(irq_ic_data, 1));\n\twritel(0, irq_ic_data->irq_base + SUN4I_IRQ_MASK_REG(irq_ic_data, 2));\n\n\t \n\twritel(0xffffffff, irq_ic_data->irq_base + SUN4I_IRQ_PENDING_REG(0));\n\twritel(0xffffffff, irq_ic_data->irq_base + SUN4I_IRQ_PENDING_REG(1));\n\twritel(0xffffffff, irq_ic_data->irq_base + SUN4I_IRQ_PENDING_REG(2));\n\n\t \n\twritel(0x01, irq_ic_data->irq_base + SUN4I_IRQ_PROTECTION_REG);\n\n\t \n\twritel(0x00, irq_ic_data->irq_base + SUN4I_IRQ_NMI_CTRL_REG);\n\n\tirq_ic_data->irq_domain = irq_domain_add_linear(node, 3 * 32,\n\t\t\t\t\t\t &sun4i_irq_ops, NULL);\n\tif (!irq_ic_data->irq_domain)\n\t\tpanic(\"%pOF: unable to create IRQ domain\\n\", node);\n\n\tset_handle_irq(sun4i_handle_irq);\n\n\treturn 0;\n}\n\nstatic int __init sun4i_ic_of_init(struct device_node *node,\n\t\t\t\t   struct device_node *parent)\n{\n\tirq_ic_data = kzalloc(sizeof(struct sun4i_irq_chip_data), GFP_KERNEL);\n\tif (!irq_ic_data)\n\t\treturn -ENOMEM;\n\n\tirq_ic_data->enable_reg_offset = SUN4I_IRQ_ENABLE_REG_OFFSET;\n\tirq_ic_data->mask_reg_offset = SUN4I_IRQ_MASK_REG_OFFSET;\n\n\treturn sun4i_of_init(node, parent);\n}\n\nIRQCHIP_DECLARE(allwinner_sun4i_ic, \"allwinner,sun4i-a10-ic\", sun4i_ic_of_init);\n\nstatic int __init suniv_ic_of_init(struct device_node *node,\n\t\t\t\t   struct device_node *parent)\n{\n\tirq_ic_data = kzalloc(sizeof(struct sun4i_irq_chip_data), GFP_KERNEL);\n\tif (!irq_ic_data)\n\t\treturn -ENOMEM;\n\n\tirq_ic_data->enable_reg_offset = SUNIV_IRQ_ENABLE_REG_OFFSET;\n\tirq_ic_data->mask_reg_offset = SUNIV_IRQ_MASK_REG_OFFSET;\n\n\treturn sun4i_of_init(node, parent);\n}\n\nIRQCHIP_DECLARE(allwinner_sunvi_ic, \"allwinner,suniv-f1c100s-ic\",\n\t\tsuniv_ic_of_init);\n\nstatic void __exception_irq_entry sun4i_handle_irq(struct pt_regs *regs)\n{\n\tu32 hwirq;\n\n\t \n\thwirq = readl(irq_ic_data->irq_base + SUN4I_IRQ_VECTOR_REG) >> 2;\n\tif (hwirq == 0 &&\n\t\t  !(readl(irq_ic_data->irq_base + SUN4I_IRQ_PENDING_REG(0)) &\n\t\t\t  BIT(0)))\n\t\treturn;\n\n\tdo {\n\t\tgeneric_handle_domain_irq(irq_ic_data->irq_domain, hwirq);\n\t\thwirq = readl(irq_ic_data->irq_base +\n\t\t\t\tSUN4I_IRQ_VECTOR_REG) >> 2;\n\t} while (hwirq != 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}