{
  "module_name": "irq-uniphier-aidet.c",
  "hash_id": "17527ff50e7213516458890de932d59f713f42361718bfd86a89e4399e090a95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-uniphier-aidet.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#define UNIPHIER_AIDET_NR_IRQS\t\t256\n\n#define UNIPHIER_AIDET_DETCONF\t\t0x04\t \n\nstruct uniphier_aidet_priv {\n\tstruct irq_domain *domain;\n\tvoid __iomem *reg_base;\n\tspinlock_t lock;\n\tu32 saved_vals[UNIPHIER_AIDET_NR_IRQS / 32];\n};\n\nstatic void uniphier_aidet_reg_update(struct uniphier_aidet_priv *priv,\n\t\t\t\t      unsigned int reg, u32 mask, u32 val)\n{\n\tunsigned long flags;\n\tu32 tmp;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\ttmp = readl_relaxed(priv->reg_base + reg);\n\ttmp &= ~mask;\n\ttmp |= mask & val;\n\twritel_relaxed(tmp, priv->reg_base + reg);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void uniphier_aidet_detconf_update(struct uniphier_aidet_priv *priv,\n\t\t\t\t\t  unsigned long index, unsigned int val)\n{\n\tunsigned int reg;\n\tu32 mask;\n\n\treg = UNIPHIER_AIDET_DETCONF + index / 32 * 4;\n\tmask = BIT(index % 32);\n\n\tuniphier_aidet_reg_update(priv, reg, mask, val ? mask : 0);\n}\n\nstatic int uniphier_aidet_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct uniphier_aidet_priv *priv = data->chip_data;\n\tunsigned int val;\n\n\t \n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tval = 0;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tval = 1;\n\t\ttype = IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tval = 1;\n\t\ttype = IRQ_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tuniphier_aidet_detconf_update(priv, data->hwirq, val);\n\n\treturn irq_chip_set_type_parent(data, type);\n}\n\nstatic struct irq_chip uniphier_aidet_irq_chip = {\n\t.name = \"AIDET\",\n\t.irq_mask = irq_chip_mask_parent,\n\t.irq_unmask = irq_chip_unmask_parent,\n\t.irq_eoi = irq_chip_eoi_parent,\n\t.irq_set_affinity = irq_chip_set_affinity_parent,\n\t.irq_set_type = uniphier_aidet_irq_set_type,\n};\n\nstatic int uniphier_aidet_domain_translate(struct irq_domain *domain,\n\t\t\t\t\t   struct irq_fwspec *fwspec,\n\t\t\t\t\t   unsigned long *out_hwirq,\n\t\t\t\t\t   unsigned int *out_type)\n{\n\tif (WARN_ON(fwspec->param_count < 2))\n\t\treturn -EINVAL;\n\n\t*out_hwirq = fwspec->param[0];\n\t*out_type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\n\treturn 0;\n}\n\nstatic int uniphier_aidet_domain_alloc(struct irq_domain *domain,\n\t\t\t\t       unsigned int virq, unsigned int nr_irqs,\n\t\t\t\t       void *arg)\n{\n\tstruct irq_fwspec parent_fwspec;\n\tirq_hw_number_t hwirq;\n\tunsigned int type;\n\tint ret;\n\n\tif (nr_irqs != 1)\n\t\treturn -EINVAL;\n\n\tret = uniphier_aidet_domain_translate(domain, arg, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\ttype = IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\ttype = IRQ_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (hwirq >= UNIPHIER_AIDET_NR_IRQS)\n\t\treturn -ENXIO;\n\n\tret = irq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t\t    &uniphier_aidet_irq_chip,\n\t\t\t\t\t    domain->host_data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\tparent_fwspec.param_count = 3;\n\tparent_fwspec.param[0] = 0;\t\t \n\tparent_fwspec.param[1] = hwirq;\n\tparent_fwspec.param[2] = type;\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, 1, &parent_fwspec);\n}\n\nstatic const struct irq_domain_ops uniphier_aidet_domain_ops = {\n\t.alloc = uniphier_aidet_domain_alloc,\n\t.free = irq_domain_free_irqs_common,\n\t.translate = uniphier_aidet_domain_translate,\n};\n\nstatic int uniphier_aidet_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *parent_np;\n\tstruct irq_domain *parent_domain;\n\tstruct uniphier_aidet_priv *priv;\n\n\tparent_np = of_irq_find_parent(dev->of_node);\n\tif (!parent_np)\n\t\treturn -ENXIO;\n\n\tparent_domain = irq_find_host(parent_np);\n\tof_node_put(parent_np);\n\tif (!parent_domain)\n\t\treturn -EPROBE_DEFER;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->reg_base))\n\t\treturn PTR_ERR(priv->reg_base);\n\n\tspin_lock_init(&priv->lock);\n\n\tpriv->domain = irq_domain_create_hierarchy(\n\t\t\t\t\tparent_domain, 0,\n\t\t\t\t\tUNIPHIER_AIDET_NR_IRQS,\n\t\t\t\t\tof_node_to_fwnode(dev->of_node),\n\t\t\t\t\t&uniphier_aidet_domain_ops, priv);\n\tif (!priv->domain)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused uniphier_aidet_suspend(struct device *dev)\n{\n\tstruct uniphier_aidet_priv *priv = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->saved_vals); i++)\n\t\tpriv->saved_vals[i] = readl_relaxed(\n\t\t\tpriv->reg_base + UNIPHIER_AIDET_DETCONF + i * 4);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused uniphier_aidet_resume(struct device *dev)\n{\n\tstruct uniphier_aidet_priv *priv = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->saved_vals); i++)\n\t\twritel_relaxed(priv->saved_vals[i],\n\t\t\t       priv->reg_base + UNIPHIER_AIDET_DETCONF + i * 4);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops uniphier_aidet_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(uniphier_aidet_suspend,\n\t\t\t\t      uniphier_aidet_resume)\n};\n\nstatic const struct of_device_id uniphier_aidet_match[] = {\n\t{ .compatible = \"socionext,uniphier-ld4-aidet\" },\n\t{ .compatible = \"socionext,uniphier-pro4-aidet\" },\n\t{ .compatible = \"socionext,uniphier-sld8-aidet\" },\n\t{ .compatible = \"socionext,uniphier-pro5-aidet\" },\n\t{ .compatible = \"socionext,uniphier-pxs2-aidet\" },\n\t{ .compatible = \"socionext,uniphier-ld11-aidet\" },\n\t{ .compatible = \"socionext,uniphier-ld20-aidet\" },\n\t{ .compatible = \"socionext,uniphier-pxs3-aidet\" },\n\t{ .compatible = \"socionext,uniphier-nx1-aidet\" },\n\t{   }\n};\n\nstatic struct platform_driver uniphier_aidet_driver = {\n\t.probe = uniphier_aidet_probe,\n\t.driver = {\n\t\t.name = \"uniphier-aidet\",\n\t\t.of_match_table = uniphier_aidet_match,\n\t\t.pm = &uniphier_aidet_pm_ops,\n\t},\n};\nbuiltin_platform_driver(uniphier_aidet_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}