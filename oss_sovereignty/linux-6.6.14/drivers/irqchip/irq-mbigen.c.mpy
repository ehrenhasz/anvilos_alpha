{
  "module_name": "irq-mbigen.c",
  "hash_id": "5ab55f519dcc2d71faf41d4fb1630197caa67dbf86d85627804551249cff265d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mbigen.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n \n#define IRQS_PER_MBIGEN_NODE\t\t128\n\n \n#define RESERVED_IRQ_PER_MBIGEN_CHIP\t64\n\n \n#define MAXIMUM_IRQ_PIN_NUM\t\t1407\n\n \n#define IRQ_EVENT_ID_SHIFT\t\t12\n#define IRQ_EVENT_ID_MASK\t\t0x3ff\n\n \n#define MBIGEN_NODE_OFFSET\t\t0x1000\n\n \n#define REG_MBIGEN_VEC_OFFSET\t\t0x200\n\n \n#define REG_MBIGEN_CLEAR_OFFSET\t\t0xa000\n\n \n#define REG_MBIGEN_TYPE_OFFSET\t\t0x0\n\n \nstruct mbigen_device {\n\tstruct platform_device\t*pdev;\n\tvoid __iomem\t\t*base;\n};\n\nstatic inline unsigned int get_mbigen_vec_reg(irq_hw_number_t hwirq)\n{\n\tunsigned int nid, pin;\n\n\thwirq -= RESERVED_IRQ_PER_MBIGEN_CHIP;\n\tnid = hwirq / IRQS_PER_MBIGEN_NODE + 1;\n\tpin = hwirq % IRQS_PER_MBIGEN_NODE;\n\n\treturn pin * 4 + nid * MBIGEN_NODE_OFFSET\n\t\t\t+ REG_MBIGEN_VEC_OFFSET;\n}\n\nstatic inline void get_mbigen_type_reg(irq_hw_number_t hwirq,\n\t\t\t\t\tu32 *mask, u32 *addr)\n{\n\tunsigned int nid, irq_ofst, ofst;\n\n\thwirq -= RESERVED_IRQ_PER_MBIGEN_CHIP;\n\tnid = hwirq / IRQS_PER_MBIGEN_NODE + 1;\n\tirq_ofst = hwirq % IRQS_PER_MBIGEN_NODE;\n\n\t*mask = 1 << (irq_ofst % 32);\n\tofst = irq_ofst / 32 * 4;\n\n\t*addr = ofst + nid * MBIGEN_NODE_OFFSET\n\t\t+ REG_MBIGEN_TYPE_OFFSET;\n}\n\nstatic inline void get_mbigen_clear_reg(irq_hw_number_t hwirq,\n\t\t\t\t\tu32 *mask, u32 *addr)\n{\n\tunsigned int ofst = (hwirq / 32) * 4;\n\n\t*mask = 1 << (hwirq % 32);\n\t*addr = ofst + REG_MBIGEN_CLEAR_OFFSET;\n}\n\nstatic void mbigen_eoi_irq(struct irq_data *data)\n{\n\tvoid __iomem *base = data->chip_data;\n\tu32 mask, addr;\n\n\tget_mbigen_clear_reg(data->hwirq, &mask, &addr);\n\n\twritel_relaxed(mask, base + addr);\n\n\tirq_chip_eoi_parent(data);\n}\n\nstatic int mbigen_set_type(struct irq_data *data, unsigned int type)\n{\n\tvoid __iomem *base = data->chip_data;\n\tu32 mask, addr, val;\n\n\tif (type != IRQ_TYPE_LEVEL_HIGH && type != IRQ_TYPE_EDGE_RISING)\n\t\treturn -EINVAL;\n\n\tget_mbigen_type_reg(data->hwirq, &mask, &addr);\n\n\tval = readl_relaxed(base + addr);\n\n\tif (type == IRQ_TYPE_LEVEL_HIGH)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\n\twritel_relaxed(val, base + addr);\n\n\treturn 0;\n}\n\nstatic struct irq_chip mbigen_irq_chip = {\n\t.name =\t\t\t\"mbigen-v2\",\n\t.irq_mask =\t\tirq_chip_mask_parent,\n\t.irq_unmask =\t\tirq_chip_unmask_parent,\n\t.irq_eoi =\t\tmbigen_eoi_irq,\n\t.irq_set_type =\t\tmbigen_set_type,\n\t.irq_set_affinity =\tirq_chip_set_affinity_parent,\n};\n\nstatic void mbigen_write_msg(struct msi_desc *desc, struct msi_msg *msg)\n{\n\tstruct irq_data *d = irq_get_irq_data(desc->irq);\n\tvoid __iomem *base = d->chip_data;\n\tu32 val;\n\n\tif (!msg->address_lo && !msg->address_hi)\n\t\treturn;\n \n\tbase += get_mbigen_vec_reg(d->hwirq);\n\tval = readl_relaxed(base);\n\n\tval &= ~(IRQ_EVENT_ID_MASK << IRQ_EVENT_ID_SHIFT);\n\tval |= (msg->data << IRQ_EVENT_ID_SHIFT);\n\n\t \n\twritel_relaxed(val, base);\n}\n\nstatic int mbigen_domain_translate(struct irq_domain *d,\n\t\t\t\t    struct irq_fwspec *fwspec,\n\t\t\t\t    unsigned long *hwirq,\n\t\t\t\t    unsigned int *type)\n{\n\tif (is_of_node(fwspec->fwnode) || is_acpi_device_node(fwspec->fwnode)) {\n\t\tif (fwspec->param_count != 2)\n\t\t\treturn -EINVAL;\n\n\t\tif ((fwspec->param[0] > MAXIMUM_IRQ_PIN_NUM) ||\n\t\t\t(fwspec->param[0] < RESERVED_IRQ_PER_MBIGEN_CHIP))\n\t\t\treturn -EINVAL;\n\t\telse\n\t\t\t*hwirq = fwspec->param[0];\n\n\t\t \n\t\tif ((fwspec->param[1] == IRQ_TYPE_EDGE_RISING) ||\n\t\t\t(fwspec->param[1] == IRQ_TYPE_LEVEL_HIGH))\n\t\t\t*type = fwspec->param[1];\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int mbigen_irq_domain_alloc(struct irq_domain *domain,\n\t\t\t\t\tunsigned int virq,\n\t\t\t\t\tunsigned int nr_irqs,\n\t\t\t\t\tvoid *args)\n{\n\tstruct irq_fwspec *fwspec = args;\n\tirq_hw_number_t hwirq;\n\tunsigned int type;\n\tstruct mbigen_device *mgn_chip;\n\tint i, err;\n\n\terr = mbigen_domain_translate(domain, fwspec, &hwirq, &type);\n\tif (err)\n\t\treturn err;\n\n\terr = platform_msi_device_domain_alloc(domain, virq, nr_irqs);\n\tif (err)\n\t\treturn err;\n\n\tmgn_chip = platform_msi_get_host_data(domain);\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\n\t\t\t\t      &mbigen_irq_chip, mgn_chip->base);\n\n\treturn 0;\n}\n\nstatic void mbigen_irq_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t   unsigned int nr_irqs)\n{\n\tplatform_msi_device_domain_free(domain, virq, nr_irqs);\n}\n\nstatic const struct irq_domain_ops mbigen_domain_ops = {\n\t.translate\t= mbigen_domain_translate,\n\t.alloc\t\t= mbigen_irq_domain_alloc,\n\t.free\t\t= mbigen_irq_domain_free,\n};\n\nstatic int mbigen_of_create_domain(struct platform_device *pdev,\n\t\t\t\t   struct mbigen_device *mgn_chip)\n{\n\tstruct device *parent;\n\tstruct platform_device *child;\n\tstruct irq_domain *domain;\n\tstruct device_node *np;\n\tu32 num_pins;\n\tint ret = 0;\n\n\tparent = bus_get_dev_root(&platform_bus_type);\n\tif (!parent)\n\t\treturn -ENODEV;\n\n\tfor_each_child_of_node(pdev->dev.of_node, np) {\n\t\tif (!of_property_read_bool(np, \"interrupt-controller\"))\n\t\t\tcontinue;\n\n\t\tchild = of_platform_device_create(np, NULL, parent);\n\t\tif (!child) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (of_property_read_u32(child->dev.of_node, \"num-pins\",\n\t\t\t\t\t &num_pins) < 0) {\n\t\t\tdev_err(&pdev->dev, \"No num-pins property\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdomain = platform_msi_create_device_domain(&child->dev, num_pins,\n\t\t\t\t\t\t\t   mbigen_write_msg,\n\t\t\t\t\t\t\t   &mbigen_domain_ops,\n\t\t\t\t\t\t\t   mgn_chip);\n\t\tif (!domain) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_device(parent);\n\tif (ret)\n\t\tof_node_put(np);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id mbigen_acpi_match[] = {\n\t{ \"HISI0152\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, mbigen_acpi_match);\n\nstatic int mbigen_acpi_create_domain(struct platform_device *pdev,\n\t\t\t\t     struct mbigen_device *mgn_chip)\n{\n\tstruct irq_domain *domain;\n\tu32 num_pins = 0;\n\tint ret;\n\n\t \n\tret = device_property_read_u32(&pdev->dev, \"num-pins\", &num_pins);\n\tif (ret || num_pins == 0)\n\t\treturn -EINVAL;\n\n\tdomain = platform_msi_create_device_domain(&pdev->dev, num_pins,\n\t\t\t\t\t\t   mbigen_write_msg,\n\t\t\t\t\t\t   &mbigen_domain_ops,\n\t\t\t\t\t\t   mgn_chip);\n\tif (!domain)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n#else\nstatic inline int mbigen_acpi_create_domain(struct platform_device *pdev,\n\t\t\t\t\t    struct mbigen_device *mgn_chip)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic int mbigen_device_probe(struct platform_device *pdev)\n{\n\tstruct mbigen_device *mgn_chip;\n\tstruct resource *res;\n\tint err;\n\n\tmgn_chip = devm_kzalloc(&pdev->dev, sizeof(*mgn_chip), GFP_KERNEL);\n\tif (!mgn_chip)\n\t\treturn -ENOMEM;\n\n\tmgn_chip->pdev = pdev;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tmgn_chip->base = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t      resource_size(res));\n\tif (!mgn_chip->base) {\n\t\tdev_err(&pdev->dev, \"failed to ioremap %pR\\n\", res);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node)\n\t\terr = mbigen_of_create_domain(pdev, mgn_chip);\n\telse if (ACPI_COMPANION(&pdev->dev))\n\t\terr = mbigen_acpi_create_domain(pdev, mgn_chip);\n\telse\n\t\terr = -EINVAL;\n\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to create mbi-gen irqdomain\\n\");\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, mgn_chip);\n\treturn 0;\n}\n\nstatic const struct of_device_id mbigen_of_match[] = {\n\t{ .compatible = \"hisilicon,mbigen-v2\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mbigen_of_match);\n\nstatic struct platform_driver mbigen_platform_driver = {\n\t.driver = {\n\t\t.name\t\t= \"Hisilicon MBIGEN-V2\",\n\t\t.of_match_table\t= mbigen_of_match,\n\t\t.acpi_match_table = ACPI_PTR(mbigen_acpi_match),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t\t= mbigen_device_probe,\n};\n\nmodule_platform_driver(mbigen_platform_driver);\n\nMODULE_AUTHOR(\"Jun Ma <majun258@huawei.com>\");\nMODULE_AUTHOR(\"Yun Wu <wuyun.wu@huawei.com>\");\nMODULE_DESCRIPTION(\"HiSilicon MBI Generator driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}