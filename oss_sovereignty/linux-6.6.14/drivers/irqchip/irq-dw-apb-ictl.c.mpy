{
  "module_name": "irq-dw-apb-ictl.c",
  "hash_id": "5cb3e4f57d212ff4b6c356ab0bca23db1b0608306ecec783a5a5391a559192d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-dw-apb-ictl.c",
  "human_readable_source": " \n\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/interrupt.h>\n\n#define APB_INT_ENABLE_L\t0x00\n#define APB_INT_ENABLE_H\t0x04\n#define APB_INT_MASK_L\t\t0x08\n#define APB_INT_MASK_H\t\t0x0c\n#define APB_INT_FINALSTATUS_L\t0x30\n#define APB_INT_FINALSTATUS_H\t0x34\n#define APB_INT_BASE_OFFSET\t0x04\n\n \nstatic struct irq_domain *dw_apb_ictl_irq_domain;\n\nstatic void __irq_entry dw_apb_ictl_handle_irq(struct pt_regs *regs)\n{\n\tstruct irq_domain *d = dw_apb_ictl_irq_domain;\n\tint n;\n\n\tfor (n = 0; n < d->revmap_size; n += 32) {\n\t\tstruct irq_chip_generic *gc = irq_get_domain_generic_chip(d, n);\n\t\tu32 stat = readl_relaxed(gc->reg_base + APB_INT_FINALSTATUS_L);\n\n\t\twhile (stat) {\n\t\t\tu32 hwirq = ffs(stat) - 1;\n\n\t\t\tgeneric_handle_domain_irq(d, hwirq);\n\t\t\tstat &= ~BIT(hwirq);\n\t\t}\n\t}\n}\n\nstatic void dw_apb_ictl_handle_irq_cascaded(struct irq_desc *desc)\n{\n\tstruct irq_domain *d = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tint n;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (n = 0; n < d->revmap_size; n += 32) {\n\t\tstruct irq_chip_generic *gc = irq_get_domain_generic_chip(d, n);\n\t\tu32 stat = readl_relaxed(gc->reg_base + APB_INT_FINALSTATUS_L);\n\n\t\twhile (stat) {\n\t\t\tu32 hwirq = ffs(stat) - 1;\n\t\t\tgeneric_handle_domain_irq(d, gc->irq_base + hwirq);\n\n\t\t\tstat &= ~BIT(hwirq);\n\t\t}\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int dw_apb_ictl_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs, void *arg)\n{\n\tint i, ret;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tstruct irq_fwspec *fwspec = arg;\n\n\tret = irq_domain_translate_onecell(domain, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_map_generic_chip(domain, virq + i, hwirq + i);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops dw_apb_ictl_irq_domain_ops = {\n\t.translate = irq_domain_translate_onecell,\n\t.alloc = dw_apb_ictl_irq_domain_alloc,\n\t.free = irq_domain_free_irqs_top,\n};\n\n#ifdef CONFIG_PM\nstatic void dw_apb_ictl_resume(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\n\tirq_gc_lock(gc);\n\twritel_relaxed(~0, gc->reg_base + ct->regs.enable);\n\twritel_relaxed(*ct->mask_cache, gc->reg_base + ct->regs.mask);\n\tirq_gc_unlock(gc);\n}\n#else\n#define dw_apb_ictl_resume\tNULL\n#endif  \n\nstatic int __init dw_apb_ictl_init(struct device_node *np,\n\t\t\t\t   struct device_node *parent)\n{\n\tconst struct irq_domain_ops *domain_ops;\n\tunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\n\tstruct resource r;\n\tstruct irq_domain *domain;\n\tstruct irq_chip_generic *gc;\n\tvoid __iomem *iobase;\n\tint ret, nrirqs, parent_irq, i;\n\tu32 reg;\n\n\tif (!parent) {\n\t\t \n\t\tparent_irq = 0;\n\t\tdomain_ops = &dw_apb_ictl_irq_domain_ops;\n\t} else {\n\t\t \n\t\tparent_irq = irq_of_parse_and_map(np, 0);\n\t\tif (parent_irq <= 0) {\n\t\t\tpr_err(\"%pOF: unable to parse irq\\n\", np);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdomain_ops = &irq_generic_chip_ops;\n\t}\n\n\tret = of_address_to_resource(np, 0, &r);\n\tif (ret) {\n\t\tpr_err(\"%pOF: unable to get resource\\n\", np);\n\t\treturn ret;\n\t}\n\n\tif (!request_mem_region(r.start, resource_size(&r), np->full_name)) {\n\t\tpr_err(\"%pOF: unable to request mem region\\n\", np);\n\t\treturn -ENOMEM;\n\t}\n\n\tiobase = ioremap(r.start, resource_size(&r));\n\tif (!iobase) {\n\t\tpr_err(\"%pOF: unable to map resource\\n\", np);\n\t\tret = -ENOMEM;\n\t\tgoto err_release;\n\t}\n\n\t \n\n\t \n\twritel_relaxed(~0, iobase + APB_INT_MASK_L);\n\twritel_relaxed(~0, iobase + APB_INT_MASK_H);\n\twritel_relaxed(~0, iobase + APB_INT_ENABLE_L);\n\twritel_relaxed(~0, iobase + APB_INT_ENABLE_H);\n\n\treg = readl_relaxed(iobase + APB_INT_ENABLE_H);\n\tif (reg)\n\t\tnrirqs = 32 + fls(reg);\n\telse\n\t\tnrirqs = fls(readl_relaxed(iobase + APB_INT_ENABLE_L));\n\n\tdomain = irq_domain_add_linear(np, nrirqs, domain_ops, NULL);\n\tif (!domain) {\n\t\tpr_err(\"%pOF: unable to add irq domain\\n\", np);\n\t\tret = -ENOMEM;\n\t\tgoto err_unmap;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(domain, 32, 1, np->name,\n\t\t\t\t\t     handle_level_irq, clr, 0,\n\t\t\t\t\t     IRQ_GC_INIT_MASK_CACHE);\n\tif (ret) {\n\t\tpr_err(\"%pOF: unable to alloc irq domain gc\\n\", np);\n\t\tgoto err_unmap;\n\t}\n\n\tfor (i = 0; i < DIV_ROUND_UP(nrirqs, 32); i++) {\n\t\tgc = irq_get_domain_generic_chip(domain, i * 32);\n\t\tgc->reg_base = iobase + i * APB_INT_BASE_OFFSET;\n\t\tgc->chip_types[0].regs.mask = APB_INT_MASK_L;\n\t\tgc->chip_types[0].regs.enable = APB_INT_ENABLE_L;\n\t\tgc->chip_types[0].chip.irq_mask = irq_gc_mask_set_bit;\n\t\tgc->chip_types[0].chip.irq_unmask = irq_gc_mask_clr_bit;\n\t\tgc->chip_types[0].chip.irq_resume = dw_apb_ictl_resume;\n\t}\n\n\tif (parent_irq) {\n\t\tirq_set_chained_handler_and_data(parent_irq,\n\t\t\t\tdw_apb_ictl_handle_irq_cascaded, domain);\n\t} else {\n\t\tdw_apb_ictl_irq_domain = domain;\n\t\tset_handle_irq(dw_apb_ictl_handle_irq);\n\t}\n\n\treturn 0;\n\nerr_unmap:\n\tiounmap(iobase);\nerr_release:\n\trelease_mem_region(r.start, resource_size(&r));\n\treturn ret;\n}\nIRQCHIP_DECLARE(dw_apb_ictl,\n\t\t\"snps,dw-apb-ictl\", dw_apb_ictl_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}