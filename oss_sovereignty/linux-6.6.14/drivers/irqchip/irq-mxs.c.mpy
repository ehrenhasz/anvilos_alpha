{
  "module_name": "irq-mxs.c",
  "hash_id": "2f6dc6db70071dde1c51d945c46dd0aecfe64a74eb27312af1193cb29fcc7422",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mxs.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/stmp_device.h>\n#include <asm/exception.h>\n\n#include \"alphascale_asm9260-icoll.h\"\n\n \n#define SET_REG 4\n#define CLR_REG 8\n\n#define HW_ICOLL_VECTOR\t\t\t\t0x0000\n#define HW_ICOLL_LEVELACK\t\t\t0x0010\n#define HW_ICOLL_CTRL\t\t\t\t0x0020\n#define HW_ICOLL_STAT_OFFSET\t\t\t0x0070\n#define HW_ICOLL_INTERRUPT0\t\t\t0x0120\n#define HW_ICOLL_INTERRUPTn(n)\t\t\t((n) * 0x10)\n#define BM_ICOLL_INTR_ENABLE\t\t\tBIT(2)\n#define BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL0\t0x1\n\n#define ICOLL_NUM_IRQS\t\t128\n\nenum icoll_type {\n\tICOLL,\n\tASM9260_ICOLL,\n};\n\nstruct icoll_priv {\n\tvoid __iomem *vector;\n\tvoid __iomem *levelack;\n\tvoid __iomem *ctrl;\n\tvoid __iomem *stat;\n\tvoid __iomem *intr;\n\tvoid __iomem *clear;\n\tenum icoll_type type;\n};\n\nstatic struct icoll_priv icoll_priv;\nstatic struct irq_domain *icoll_domain;\n\n \nstatic u32 icoll_intr_bitshift(struct irq_data *d, u32 bit)\n{\n\t \n\treturn bit << ((d->hwirq & 3) << 3);\n}\n\n \nstatic void __iomem *icoll_intr_reg(struct irq_data *d)\n{\n\t \n\treturn icoll_priv.intr + ((d->hwirq >> 2) * 0x10);\n}\n\nstatic void icoll_ack_irq(struct irq_data *d)\n{\n\t \n\t__raw_writel(BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL0,\n\t\t\ticoll_priv.levelack);\n}\n\nstatic void icoll_mask_irq(struct irq_data *d)\n{\n\t__raw_writel(BM_ICOLL_INTR_ENABLE,\n\t\t\ticoll_priv.intr + CLR_REG + HW_ICOLL_INTERRUPTn(d->hwirq));\n}\n\nstatic void icoll_unmask_irq(struct irq_data *d)\n{\n\t__raw_writel(BM_ICOLL_INTR_ENABLE,\n\t\t\ticoll_priv.intr + SET_REG + HW_ICOLL_INTERRUPTn(d->hwirq));\n}\n\nstatic void asm9260_mask_irq(struct irq_data *d)\n{\n\t__raw_writel(icoll_intr_bitshift(d, BM_ICOLL_INTR_ENABLE),\n\t\t\ticoll_intr_reg(d) + CLR_REG);\n}\n\nstatic void asm9260_unmask_irq(struct irq_data *d)\n{\n\t__raw_writel(ASM9260_BM_CLEAR_BIT(d->hwirq),\n\t\t     icoll_priv.clear +\n\t\t     ASM9260_HW_ICOLL_CLEARn(d->hwirq));\n\n\t__raw_writel(icoll_intr_bitshift(d, BM_ICOLL_INTR_ENABLE),\n\t\t\ticoll_intr_reg(d) + SET_REG);\n}\n\nstatic struct irq_chip mxs_icoll_chip = {\n\t.irq_ack = icoll_ack_irq,\n\t.irq_mask = icoll_mask_irq,\n\t.irq_unmask = icoll_unmask_irq,\n\t.flags = IRQCHIP_MASK_ON_SUSPEND |\n\t\t IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic struct irq_chip asm9260_icoll_chip = {\n\t.irq_ack = icoll_ack_irq,\n\t.irq_mask = asm9260_mask_irq,\n\t.irq_unmask = asm9260_unmask_irq,\n\t.flags = IRQCHIP_MASK_ON_SUSPEND |\n\t\t IRQCHIP_SKIP_SET_WAKE,\n};\n\nasmlinkage void __exception_irq_entry icoll_handle_irq(struct pt_regs *regs)\n{\n\tu32 irqnr;\n\n\tirqnr = __raw_readl(icoll_priv.stat);\n\t__raw_writel(irqnr, icoll_priv.vector);\n\tgeneric_handle_domain_irq(icoll_domain, irqnr);\n}\n\nstatic int icoll_irq_domain_map(struct irq_domain *d, unsigned int virq,\n\t\t\t\tirq_hw_number_t hw)\n{\n\tstruct irq_chip *chip;\n\n\tif (icoll_priv.type == ICOLL)\n\t\tchip = &mxs_icoll_chip;\n\telse\n\t\tchip = &asm9260_icoll_chip;\n\n\tirq_set_chip_and_handler(virq, chip, handle_level_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops icoll_irq_domain_ops = {\n\t.map = icoll_irq_domain_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic void __init icoll_add_domain(struct device_node *np,\n\t\t\t  int num)\n{\n\ticoll_domain = irq_domain_add_linear(np, num,\n\t\t\t\t\t     &icoll_irq_domain_ops, NULL);\n\n\tif (!icoll_domain)\n\t\tpanic(\"%pOF: unable to create irq domain\", np);\n}\n\nstatic void __iomem * __init icoll_init_iobase(struct device_node *np)\n{\n\tvoid __iomem *icoll_base;\n\n\ticoll_base = of_io_request_and_map(np, 0, np->name);\n\tif (IS_ERR(icoll_base))\n\t\tpanic(\"%pOF: unable to map resource\", np);\n\treturn icoll_base;\n}\n\nstatic int __init icoll_of_init(struct device_node *np,\n\t\t\t  struct device_node *interrupt_parent)\n{\n\tvoid __iomem *icoll_base;\n\n\ticoll_priv.type = ICOLL;\n\n\ticoll_base\t\t= icoll_init_iobase(np);\n\ticoll_priv.vector\t= icoll_base + HW_ICOLL_VECTOR;\n\ticoll_priv.levelack\t= icoll_base + HW_ICOLL_LEVELACK;\n\ticoll_priv.ctrl\t\t= icoll_base + HW_ICOLL_CTRL;\n\ticoll_priv.stat\t\t= icoll_base + HW_ICOLL_STAT_OFFSET;\n\ticoll_priv.intr\t\t= icoll_base + HW_ICOLL_INTERRUPT0;\n\ticoll_priv.clear\t= NULL;\n\n\t \n\tstmp_reset_block(icoll_priv.ctrl);\n\n\ticoll_add_domain(np, ICOLL_NUM_IRQS);\n\tset_handle_irq(icoll_handle_irq);\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(mxs, \"fsl,icoll\", icoll_of_init);\n\nstatic int __init asm9260_of_init(struct device_node *np,\n\t\t\t  struct device_node *interrupt_parent)\n{\n\tvoid __iomem *icoll_base;\n\tint i;\n\n\ticoll_priv.type = ASM9260_ICOLL;\n\n\ticoll_base = icoll_init_iobase(np);\n\ticoll_priv.vector\t= icoll_base + ASM9260_HW_ICOLL_VECTOR;\n\ticoll_priv.levelack\t= icoll_base + ASM9260_HW_ICOLL_LEVELACK;\n\ticoll_priv.ctrl\t\t= icoll_base + ASM9260_HW_ICOLL_CTRL;\n\ticoll_priv.stat\t\t= icoll_base + ASM9260_HW_ICOLL_STAT_OFFSET;\n\ticoll_priv.intr\t\t= icoll_base + ASM9260_HW_ICOLL_INTERRUPT0;\n\ticoll_priv.clear\t= icoll_base + ASM9260_HW_ICOLL_CLEAR0;\n\n\twritel_relaxed(ASM9260_BM_CTRL_IRQ_ENABLE,\n\t\t\ticoll_priv.ctrl);\n\t \n\tfor (i = 0; i < 16 * 0x10; i += 0x10)\n\t\twritel(0, icoll_priv.intr + i);\n\n\ticoll_add_domain(np, ASM9260_NUM_IRQS);\n\tset_handle_irq(icoll_handle_irq);\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(asm9260, \"alphascale,asm9260-icoll\", asm9260_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}