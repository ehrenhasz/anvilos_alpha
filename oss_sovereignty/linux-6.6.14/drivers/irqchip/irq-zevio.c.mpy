{
  "module_name": "irq-zevio.c",
  "hash_id": "b4a6a20dc4f4bd65e2872d382dd4d9e096877c6eaa34567b28c15c9aeb7f4e15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-zevio.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <asm/mach/irq.h>\n#include <asm/exception.h>\n\n#define IO_STATUS\t0x000\n#define IO_RAW_STATUS\t0x004\n#define IO_ENABLE\t0x008\n#define IO_DISABLE\t0x00C\n#define IO_CURRENT\t0x020\n#define IO_RESET\t0x028\n#define IO_MAX_PRIOTY\t0x02C\n\n#define IO_IRQ_BASE\t0x000\n#define IO_FIQ_BASE\t0x100\n\n#define IO_INVERT_SEL\t0x200\n#define IO_STICKY_SEL\t0x204\n#define IO_PRIORITY_SEL\t0x300\n\n#define MAX_INTRS\t32\n#define FIQ_START\tMAX_INTRS\n\nstatic struct irq_domain *zevio_irq_domain;\nstatic void __iomem *zevio_irq_io;\n\nstatic void zevio_irq_ack(struct irq_data *irqd)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct irq_chip_regs *regs = &irq_data_get_chip_type(irqd)->regs;\n\n\treadl(gc->reg_base + regs->ack);\n}\n\nstatic void __exception_irq_entry zevio_handle_irq(struct pt_regs *regs)\n{\n\tint irqnr;\n\n\twhile (readl(zevio_irq_io + IO_STATUS)) {\n\t\tirqnr = readl(zevio_irq_io + IO_CURRENT);\n\t\tgeneric_handle_domain_irq(zevio_irq_domain, irqnr);\n\t}\n}\n\nstatic void __init zevio_init_irq_base(void __iomem *base)\n{\n\t \n\twritel(~0, base + IO_DISABLE);\n\n\t \n\twritel(0xF, base + IO_MAX_PRIOTY);\n\n\t \n\treadl(base + IO_RESET);\n}\n\nstatic int __init zevio_of_init(struct device_node *node,\n\t\t\t\tstruct device_node *parent)\n{\n\tunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\n\tstruct irq_chip_generic *gc;\n\tint ret;\n\n\tif (WARN_ON(zevio_irq_io || zevio_irq_domain))\n\t\treturn -EBUSY;\n\n\tzevio_irq_io = of_iomap(node, 0);\n\tBUG_ON(!zevio_irq_io);\n\n\t \n\twritel(~0, zevio_irq_io + IO_INVERT_SEL);\n\n\t \n\twritel(0, zevio_irq_io + IO_STICKY_SEL);\n\n\t \n\tmemset_io(zevio_irq_io + IO_PRIORITY_SEL, 0, MAX_INTRS * sizeof(u32));\n\n\t \n\tzevio_init_irq_base(zevio_irq_io + IO_IRQ_BASE);\n\tzevio_init_irq_base(zevio_irq_io + IO_FIQ_BASE);\n\n\tzevio_irq_domain = irq_domain_add_linear(node, MAX_INTRS,\n\t\t\t\t\t\t &irq_generic_chip_ops, NULL);\n\tBUG_ON(!zevio_irq_domain);\n\n\tret = irq_alloc_domain_generic_chips(zevio_irq_domain, MAX_INTRS, 1,\n\t\t\t\t\t     \"zevio_intc\", handle_level_irq,\n\t\t\t\t\t     clr, 0, IRQ_GC_INIT_MASK_CACHE);\n\tBUG_ON(ret);\n\n\tgc = irq_get_domain_generic_chip(zevio_irq_domain, 0);\n\tgc->reg_base\t\t\t\t= zevio_irq_io;\n\tgc->chip_types[0].chip.irq_ack\t\t= zevio_irq_ack;\n\tgc->chip_types[0].chip.irq_mask\t\t= irq_gc_mask_disable_reg;\n\tgc->chip_types[0].chip.irq_unmask\t= irq_gc_unmask_enable_reg;\n\tgc->chip_types[0].regs.mask\t\t= IO_IRQ_BASE + IO_ENABLE;\n\tgc->chip_types[0].regs.enable\t\t= IO_IRQ_BASE + IO_ENABLE;\n\tgc->chip_types[0].regs.disable\t\t= IO_IRQ_BASE + IO_DISABLE;\n\tgc->chip_types[0].regs.ack\t\t= IO_IRQ_BASE + IO_RESET;\n\n\tset_handle_irq(zevio_handle_irq);\n\n\tpr_info(\"TI-NSPIRE classic IRQ controller\\n\");\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(zevio_irq, \"lsi,zevio-intc\", zevio_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}