{
  "module_name": "irq-renesas-rzg2l.c",
  "hash_id": "a8cf3518ff065c3bed4b089214a93faa29327940d17ae559a71e142b020434ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-renesas-rzg2l.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n\n#define IRQC_IRQ_START\t\t\t1\n#define IRQC_IRQ_COUNT\t\t\t8\n#define IRQC_TINT_START\t\t\t(IRQC_IRQ_START + IRQC_IRQ_COUNT)\n#define IRQC_TINT_COUNT\t\t\t32\n#define IRQC_NUM_IRQ\t\t\t(IRQC_TINT_START + IRQC_TINT_COUNT)\n\n#define ISCR\t\t\t\t0x10\n#define IITSR\t\t\t\t0x14\n#define TSCR\t\t\t\t0x20\n#define TITSR0\t\t\t\t0x24\n#define TITSR1\t\t\t\t0x28\n#define TITSR0_MAX_INT\t\t\t16\n#define TITSEL_WIDTH\t\t\t0x2\n#define TSSR(n)\t\t\t\t(0x30 + ((n) * 4))\n#define TIEN\t\t\t\tBIT(7)\n#define TSSEL_SHIFT(n)\t\t\t(8 * (n))\n#define TSSEL_MASK\t\t\tGENMASK(7, 0)\n#define IRQ_MASK\t\t\t0x3\n\n#define TSSR_OFFSET(n)\t\t\t((n) % 4)\n#define TSSR_INDEX(n)\t\t\t((n) / 4)\n\n#define TITSR_TITSEL_EDGE_RISING\t0\n#define TITSR_TITSEL_EDGE_FALLING\t1\n#define TITSR_TITSEL_LEVEL_HIGH\t\t2\n#define TITSR_TITSEL_LEVEL_LOW\t\t3\n\n#define IITSR_IITSEL(n, sense)\t\t((sense) << ((n) * 2))\n#define IITSR_IITSEL_LEVEL_LOW\t\t0\n#define IITSR_IITSEL_EDGE_FALLING\t1\n#define IITSR_IITSEL_EDGE_RISING\t2\n#define IITSR_IITSEL_EDGE_BOTH\t\t3\n#define IITSR_IITSEL_MASK(n)\t\tIITSR_IITSEL((n), 3)\n\n#define TINT_EXTRACT_HWIRQ(x)           FIELD_GET(GENMASK(15, 0), (x))\n#define TINT_EXTRACT_GPIOINT(x)         FIELD_GET(GENMASK(31, 16), (x))\n\nstruct rzg2l_irqc_priv {\n\tvoid __iomem *base;\n\tstruct irq_fwspec fwspec[IRQC_NUM_IRQ];\n\traw_spinlock_t lock;\n};\n\nstatic struct rzg2l_irqc_priv *irq_data_to_priv(struct irq_data *data)\n{\n\treturn data->domain->host_data;\n}\n\nstatic void rzg2l_irq_eoi(struct irq_data *d)\n{\n\tunsigned int hw_irq = irqd_to_hwirq(d) - IRQC_IRQ_START;\n\tstruct rzg2l_irqc_priv *priv = irq_data_to_priv(d);\n\tu32 bit = BIT(hw_irq);\n\tu32 reg;\n\n\treg = readl_relaxed(priv->base + ISCR);\n\tif (reg & bit)\n\t\twritel_relaxed(reg & ~bit, priv->base + ISCR);\n}\n\nstatic void rzg2l_tint_eoi(struct irq_data *d)\n{\n\tunsigned int hw_irq = irqd_to_hwirq(d) - IRQC_TINT_START;\n\tstruct rzg2l_irqc_priv *priv = irq_data_to_priv(d);\n\tu32 bit = BIT(hw_irq);\n\tu32 reg;\n\n\treg = readl_relaxed(priv->base + TSCR);\n\tif (reg & bit)\n\t\twritel_relaxed(reg & ~bit, priv->base + TSCR);\n}\n\nstatic void rzg2l_irqc_eoi(struct irq_data *d)\n{\n\tstruct rzg2l_irqc_priv *priv = irq_data_to_priv(d);\n\tunsigned int hw_irq = irqd_to_hwirq(d);\n\n\traw_spin_lock(&priv->lock);\n\tif (hw_irq >= IRQC_IRQ_START && hw_irq <= IRQC_IRQ_COUNT)\n\t\trzg2l_irq_eoi(d);\n\telse if (hw_irq >= IRQC_TINT_START && hw_irq < IRQC_NUM_IRQ)\n\t\trzg2l_tint_eoi(d);\n\traw_spin_unlock(&priv->lock);\n\tirq_chip_eoi_parent(d);\n}\n\nstatic void rzg2l_irqc_irq_disable(struct irq_data *d)\n{\n\tunsigned int hw_irq = irqd_to_hwirq(d);\n\n\tif (hw_irq >= IRQC_TINT_START && hw_irq < IRQC_NUM_IRQ) {\n\t\tstruct rzg2l_irqc_priv *priv = irq_data_to_priv(d);\n\t\tu32 offset = hw_irq - IRQC_TINT_START;\n\t\tu32 tssr_offset = TSSR_OFFSET(offset);\n\t\tu8 tssr_index = TSSR_INDEX(offset);\n\t\tu32 reg;\n\n\t\traw_spin_lock(&priv->lock);\n\t\treg = readl_relaxed(priv->base + TSSR(tssr_index));\n\t\treg &= ~(TSSEL_MASK << TSSEL_SHIFT(tssr_offset));\n\t\twritel_relaxed(reg, priv->base + TSSR(tssr_index));\n\t\traw_spin_unlock(&priv->lock);\n\t}\n\tirq_chip_disable_parent(d);\n}\n\nstatic void rzg2l_irqc_irq_enable(struct irq_data *d)\n{\n\tunsigned int hw_irq = irqd_to_hwirq(d);\n\n\tif (hw_irq >= IRQC_TINT_START && hw_irq < IRQC_NUM_IRQ) {\n\t\tunsigned long tint = (uintptr_t)irq_data_get_irq_chip_data(d);\n\t\tstruct rzg2l_irqc_priv *priv = irq_data_to_priv(d);\n\t\tu32 offset = hw_irq - IRQC_TINT_START;\n\t\tu32 tssr_offset = TSSR_OFFSET(offset);\n\t\tu8 tssr_index = TSSR_INDEX(offset);\n\t\tu32 reg;\n\n\t\traw_spin_lock(&priv->lock);\n\t\treg = readl_relaxed(priv->base + TSSR(tssr_index));\n\t\treg |= (TIEN | tint) << TSSEL_SHIFT(tssr_offset);\n\t\twritel_relaxed(reg, priv->base + TSSR(tssr_index));\n\t\traw_spin_unlock(&priv->lock);\n\t}\n\tirq_chip_enable_parent(d);\n}\n\nstatic int rzg2l_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tunsigned int hw_irq = irqd_to_hwirq(d) - IRQC_IRQ_START;\n\tstruct rzg2l_irqc_priv *priv = irq_data_to_priv(d);\n\tu16 sense, tmp;\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tsense = IITSR_IITSEL_LEVEL_LOW;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tsense = IITSR_IITSEL_EDGE_FALLING;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tsense = IITSR_IITSEL_EDGE_RISING;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tsense = IITSR_IITSEL_EDGE_BOTH;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock(&priv->lock);\n\ttmp = readl_relaxed(priv->base + IITSR);\n\ttmp &= ~IITSR_IITSEL_MASK(hw_irq);\n\ttmp |= IITSR_IITSEL(hw_irq, sense);\n\twritel_relaxed(tmp, priv->base + IITSR);\n\traw_spin_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int rzg2l_tint_set_edge(struct irq_data *d, unsigned int type)\n{\n\tstruct rzg2l_irqc_priv *priv = irq_data_to_priv(d);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\tu32 titseln = hwirq - IRQC_TINT_START;\n\tu32 offset;\n\tu8 sense;\n\tu32 reg;\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tsense = TITSR_TITSEL_EDGE_RISING;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tsense = TITSR_TITSEL_EDGE_FALLING;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\toffset = TITSR0;\n\tif (titseln >= TITSR0_MAX_INT) {\n\t\ttitseln -= TITSR0_MAX_INT;\n\t\toffset = TITSR1;\n\t}\n\n\traw_spin_lock(&priv->lock);\n\treg = readl_relaxed(priv->base + offset);\n\treg &= ~(IRQ_MASK << (titseln * TITSEL_WIDTH));\n\treg |= sense << (titseln * TITSEL_WIDTH);\n\twritel_relaxed(reg, priv->base + offset);\n\traw_spin_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int rzg2l_irqc_set_type(struct irq_data *d, unsigned int type)\n{\n\tunsigned int hw_irq = irqd_to_hwirq(d);\n\tint ret = -EINVAL;\n\n\tif (hw_irq >= IRQC_IRQ_START && hw_irq <= IRQC_IRQ_COUNT)\n\t\tret = rzg2l_irq_set_type(d, type);\n\telse if (hw_irq >= IRQC_TINT_START && hw_irq < IRQC_NUM_IRQ)\n\t\tret = rzg2l_tint_set_edge(d, type);\n\tif (ret)\n\t\treturn ret;\n\n\treturn irq_chip_set_type_parent(d, IRQ_TYPE_LEVEL_HIGH);\n}\n\nstatic const struct irq_chip irqc_chip = {\n\t.name\t\t\t= \"rzg2l-irqc\",\n\t.irq_eoi\t\t= rzg2l_irqc_eoi,\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_disable\t\t= rzg2l_irqc_irq_disable,\n\t.irq_enable\t\t= rzg2l_irqc_irq_enable,\n\t.irq_get_irqchip_state\t= irq_chip_get_parent_state,\n\t.irq_set_irqchip_state\t= irq_chip_set_parent_state,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_set_type\t\t= rzg2l_irqc_set_type,\n\t.flags\t\t\t= IRQCHIP_MASK_ON_SUSPEND |\n\t\t\t\t  IRQCHIP_SET_TYPE_MASKED |\n\t\t\t\t  IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic int rzg2l_irqc_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tstruct rzg2l_irqc_priv *priv = domain->host_data;\n\tunsigned long tint = 0;\n\tirq_hw_number_t hwirq;\n\tunsigned int type;\n\tint ret;\n\n\tret = irq_domain_translate_twocell(domain, arg, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (hwirq > IRQC_IRQ_COUNT) {\n\t\ttint = TINT_EXTRACT_GPIOINT(hwirq);\n\t\thwirq = TINT_EXTRACT_HWIRQ(hwirq);\n\n\t\tif (hwirq < IRQC_TINT_START)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (hwirq > (IRQC_NUM_IRQ - 1))\n\t\treturn -EINVAL;\n\n\tret = irq_domain_set_hwirq_and_chip(domain, virq, hwirq, &irqc_chip,\n\t\t\t\t\t    (void *)(uintptr_t)tint);\n\tif (ret)\n\t\treturn ret;\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &priv->fwspec[hwirq]);\n}\n\nstatic const struct irq_domain_ops rzg2l_irqc_domain_ops = {\n\t.alloc = rzg2l_irqc_alloc,\n\t.free = irq_domain_free_irqs_common,\n\t.translate = irq_domain_translate_twocell,\n};\n\nstatic int rzg2l_irqc_parse_interrupts(struct rzg2l_irqc_priv *priv,\n\t\t\t\t       struct device_node *np)\n{\n\tstruct of_phandle_args map;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < IRQC_NUM_IRQ; i++) {\n\t\tret = of_irq_parse_one(np, i, &map);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tof_phandle_args_to_fwspec(np, map.args, map.args_count,\n\t\t\t\t\t  &priv->fwspec[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int rzg2l_irqc_init(struct device_node *node, struct device_node *parent)\n{\n\tstruct irq_domain *irq_domain, *parent_domain;\n\tstruct platform_device *pdev;\n\tstruct reset_control *resetn;\n\tstruct rzg2l_irqc_priv *priv;\n\tint ret;\n\n\tpdev = of_find_device_by_node(node);\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tdev_err(&pdev->dev, \"cannot find parent domain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_of_iomap(&pdev->dev, pdev->dev.of_node, 0, NULL);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tret = rzg2l_irqc_parse_interrupts(priv, node);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot parse interrupts: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tresetn = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(resetn))\n\t\treturn PTR_ERR(resetn);\n\n\tret = reset_control_deassert(resetn);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to deassert resetn pin, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"pm_runtime_resume_and_get failed: %d\\n\", ret);\n\t\tgoto pm_disable;\n\t}\n\n\traw_spin_lock_init(&priv->lock);\n\n\tirq_domain = irq_domain_add_hierarchy(parent_domain, 0, IRQC_NUM_IRQ,\n\t\t\t\t\t      node, &rzg2l_irqc_domain_ops,\n\t\t\t\t\t      priv);\n\tif (!irq_domain) {\n\t\tdev_err(&pdev->dev, \"failed to add irq domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto pm_put;\n\t}\n\n\treturn 0;\n\npm_put:\n\tpm_runtime_put(&pdev->dev);\npm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\treset_control_assert(resetn);\n\treturn ret;\n}\n\nIRQCHIP_PLATFORM_DRIVER_BEGIN(rzg2l_irqc)\nIRQCHIP_MATCH(\"renesas,rzg2l-irqc\", rzg2l_irqc_init)\nIRQCHIP_PLATFORM_DRIVER_END(rzg2l_irqc)\nMODULE_AUTHOR(\"Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>\");\nMODULE_DESCRIPTION(\"Renesas RZ/G2L IRQC Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}