{
  "module_name": "irq-ti-sci-intr.c",
  "hash_id": "90106f0eff6e61e94be342bdf9bd653522ef660c327028732062340d2ae94dca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-ti-sci-intr.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/io.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/soc/ti/ti_sci_protocol.h>\n\n \nstruct ti_sci_intr_irq_domain {\n\tconst struct ti_sci_handle *sci;\n\tstruct ti_sci_resource *out_irqs;\n\tstruct device *dev;\n\tu32 ti_sci_id;\n\tu32 type;\n};\n\nstatic struct irq_chip ti_sci_intr_irq_chip = {\n\t.name\t\t\t= \"INTR\",\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n};\n\n \nstatic int ti_sci_intr_irq_domain_translate(struct irq_domain *domain,\n\t\t\t\t\t    struct irq_fwspec *fwspec,\n\t\t\t\t\t    unsigned long *hwirq,\n\t\t\t\t\t    unsigned int *type)\n{\n\tstruct ti_sci_intr_irq_domain *intr = domain->host_data;\n\n\tif (fwspec->param_count != 1)\n\t\treturn -EINVAL;\n\n\t*hwirq = fwspec->param[0];\n\t*type = intr->type;\n\n\treturn 0;\n}\n\n \nstatic int ti_sci_intr_xlate_irq(struct ti_sci_intr_irq_domain *intr, u32 irq)\n{\n\tstruct device_node *np = dev_of_node(intr->dev);\n\tu32 base, pbase, size, len;\n\tconst __be32 *range;\n\n\trange = of_get_property(np, \"ti,interrupt-ranges\", &len);\n\tif (!range)\n\t\treturn irq;\n\n\tfor (len /= sizeof(*range); len >= 3; len -= 3) {\n\t\tbase = be32_to_cpu(*range++);\n\t\tpbase = be32_to_cpu(*range++);\n\t\tsize = be32_to_cpu(*range++);\n\n\t\tif (base <= irq && irq < base + size)\n\t\t\treturn irq - base + pbase;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic void ti_sci_intr_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t\tunsigned int virq, unsigned int nr_irqs)\n{\n\tstruct ti_sci_intr_irq_domain *intr = domain->host_data;\n\tstruct irq_data *data;\n\tint out_irq;\n\n\tdata = irq_domain_get_irq_data(domain, virq);\n\tout_irq = (uintptr_t)data->chip_data;\n\n\tintr->sci->ops.rm_irq_ops.free_irq(intr->sci,\n\t\t\t\t\t   intr->ti_sci_id, data->hwirq,\n\t\t\t\t\t   intr->ti_sci_id, out_irq);\n\tti_sci_release_resource(intr->out_irqs, out_irq);\n\tirq_domain_free_irqs_parent(domain, virq, 1);\n\tirq_domain_reset_irq_data(data);\n}\n\n \nstatic int ti_sci_intr_alloc_parent_irq(struct irq_domain *domain,\n\t\t\t\t\tunsigned int virq, u32 hwirq)\n{\n\tstruct ti_sci_intr_irq_domain *intr = domain->host_data;\n\tstruct device_node *parent_node;\n\tstruct irq_fwspec fwspec;\n\tint p_hwirq, err = 0;\n\tu16 out_irq;\n\n\tout_irq = ti_sci_get_free_resource(intr->out_irqs);\n\tif (out_irq == TI_SCI_RESOURCE_NULL)\n\t\treturn -EINVAL;\n\n\tp_hwirq = ti_sci_intr_xlate_irq(intr, out_irq);\n\tif (p_hwirq < 0)\n\t\tgoto err_irqs;\n\n\tparent_node = of_irq_find_parent(dev_of_node(intr->dev));\n\tfwspec.fwnode = of_node_to_fwnode(parent_node);\n\n\tif (of_device_is_compatible(parent_node, \"arm,gic-v3\")) {\n\t\t \n\t\tfwspec.param_count = 3;\n\t\tfwspec.param[0] = 0;\t \n\t\tfwspec.param[1] = p_hwirq - 32;  \n\t\tfwspec.param[2] = intr->type;\n\t} else {\n\t\t \n\t\tfwspec.param_count = 1;\n\t\tfwspec.param[0] = p_hwirq;\n\t}\n\n\terr = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\n\tif (err)\n\t\tgoto err_irqs;\n\n\terr = intr->sci->ops.rm_irq_ops.set_irq(intr->sci,\n\t\t\t\t\t\tintr->ti_sci_id, hwirq,\n\t\t\t\t\t\tintr->ti_sci_id, out_irq);\n\tif (err)\n\t\tgoto err_msg;\n\n\treturn out_irq;\n\nerr_msg:\n\tirq_domain_free_irqs_parent(domain, virq, 1);\nerr_irqs:\n\tti_sci_release_resource(intr->out_irqs, out_irq);\n\treturn err;\n}\n\n \nstatic int ti_sci_intr_irq_domain_alloc(struct irq_domain *domain,\n\t\t\t\t\tunsigned int virq, unsigned int nr_irqs,\n\t\t\t\t\tvoid *data)\n{\n\tstruct irq_fwspec *fwspec = data;\n\tunsigned long hwirq;\n\tunsigned int flags;\n\tint err, out_irq;\n\n\terr = ti_sci_intr_irq_domain_translate(domain, fwspec, &hwirq, &flags);\n\tif (err)\n\t\treturn err;\n\n\tout_irq = ti_sci_intr_alloc_parent_irq(domain, virq, hwirq);\n\tif (out_irq < 0)\n\t\treturn out_irq;\n\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t      &ti_sci_intr_irq_chip,\n\t\t\t\t      (void *)(uintptr_t)out_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops ti_sci_intr_irq_domain_ops = {\n\t.free\t\t= ti_sci_intr_irq_domain_free,\n\t.alloc\t\t= ti_sci_intr_irq_domain_alloc,\n\t.translate\t= ti_sci_intr_irq_domain_translate,\n};\n\nstatic int ti_sci_intr_irq_domain_probe(struct platform_device *pdev)\n{\n\tstruct irq_domain *parent_domain, *domain;\n\tstruct ti_sci_intr_irq_domain *intr;\n\tstruct device_node *parent_node;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tparent_node = of_irq_find_parent(dev_of_node(dev));\n\tif (!parent_node) {\n\t\tdev_err(dev, \"Failed to get IRQ parent node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tparent_domain = irq_find_host(parent_node);\n\tof_node_put(parent_node);\n\tif (!parent_domain) {\n\t\tdev_err(dev, \"Failed to find IRQ parent domain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tintr = devm_kzalloc(dev, sizeof(*intr), GFP_KERNEL);\n\tif (!intr)\n\t\treturn -ENOMEM;\n\n\tintr->dev = dev;\n\tret = of_property_read_u32(dev_of_node(dev), \"ti,intr-trigger-type\",\n\t\t\t\t   &intr->type);\n\tif (ret) {\n\t\tdev_err(dev, \"missing ti,intr-trigger-type property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tintr->sci = devm_ti_sci_get_by_phandle(dev, \"ti,sci\");\n\tif (IS_ERR(intr->sci))\n\t\treturn dev_err_probe(dev, PTR_ERR(intr->sci),\n\t\t\t\t     \"ti,sci read fail\\n\");\n\n\tret = of_property_read_u32(dev_of_node(dev), \"ti,sci-dev-id\",\n\t\t\t\t   &intr->ti_sci_id);\n\tif (ret) {\n\t\tdev_err(dev, \"missing 'ti,sci-dev-id' property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tintr->out_irqs = devm_ti_sci_get_resource(intr->sci, dev,\n\t\t\t\t\t\t  intr->ti_sci_id,\n\t\t\t\t\t\t  TI_SCI_RESASG_SUBTYPE_IR_OUTPUT);\n\tif (IS_ERR(intr->out_irqs)) {\n\t\tdev_err(dev, \"Destination irq resource allocation failed\\n\");\n\t\treturn PTR_ERR(intr->out_irqs);\n\t}\n\n\tdomain = irq_domain_add_hierarchy(parent_domain, 0, 0, dev_of_node(dev),\n\t\t\t\t\t  &ti_sci_intr_irq_domain_ops, intr);\n\tif (!domain) {\n\t\tdev_err(dev, \"Failed to allocate IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_info(dev, \"Interrupt Router %d domain created\\n\", intr->ti_sci_id);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ti_sci_intr_irq_domain_of_match[] = {\n\t{ .compatible = \"ti,sci-intr\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ti_sci_intr_irq_domain_of_match);\n\nstatic struct platform_driver ti_sci_intr_irq_domain_driver = {\n\t.probe = ti_sci_intr_irq_domain_probe,\n\t.driver = {\n\t\t.name = \"ti-sci-intr\",\n\t\t.of_match_table = ti_sci_intr_irq_domain_of_match,\n\t},\n};\nmodule_platform_driver(ti_sci_intr_irq_domain_driver);\n\nMODULE_AUTHOR(\"Lokesh Vutla <lokeshvutla@ticom>\");\nMODULE_DESCRIPTION(\"K3 Interrupt Router driver over TI SCI protocol\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}