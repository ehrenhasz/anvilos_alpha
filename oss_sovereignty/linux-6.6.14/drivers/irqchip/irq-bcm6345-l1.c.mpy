{
  "module_name": "irq-bcm6345-l1.c",
  "hash_id": "e4c1cfe73e37cf05ffac195b76c11412652a041e8c6992d12b1dc2e1ebab0cec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-bcm6345-l1.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME\t\": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/cpumask.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <linux/types.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n\n#define IRQS_PER_WORD\t\t32\n#define REG_BYTES_PER_IRQ_WORD\t(sizeof(u32) * 2)\n\nstruct bcm6345_l1_cpu;\n\nstruct bcm6345_l1_chip {\n\traw_spinlock_t\t\tlock;\n\tunsigned int\t\tn_words;\n\tstruct irq_domain\t*domain;\n\tstruct cpumask\t\tcpumask;\n\tstruct bcm6345_l1_cpu\t*cpus[NR_CPUS];\n};\n\nstruct bcm6345_l1_cpu {\n\tstruct bcm6345_l1_chip\t*intc;\n\tvoid __iomem\t\t*map_base;\n\tunsigned int\t\tparent_irq;\n\tu32\t\t\tenable_cache[];\n};\n\nstatic inline unsigned int reg_enable(struct bcm6345_l1_chip *intc,\n\t\t\t\t\t   unsigned int word)\n{\n#ifdef __BIG_ENDIAN\n\treturn (1 * intc->n_words - word - 1) * sizeof(u32);\n#else\n\treturn (0 * intc->n_words + word) * sizeof(u32);\n#endif\n}\n\nstatic inline unsigned int reg_status(struct bcm6345_l1_chip *intc,\n\t\t\t\t      unsigned int word)\n{\n#ifdef __BIG_ENDIAN\n\treturn (2 * intc->n_words - word - 1) * sizeof(u32);\n#else\n\treturn (1 * intc->n_words + word) * sizeof(u32);\n#endif\n}\n\nstatic inline unsigned int cpu_for_irq(struct bcm6345_l1_chip *intc,\n\t\t\t\t\tstruct irq_data *d)\n{\n\treturn cpumask_first_and(&intc->cpumask, irq_data_get_affinity_mask(d));\n}\n\nstatic void bcm6345_l1_irq_handle(struct irq_desc *desc)\n{\n\tstruct bcm6345_l1_cpu *cpu = irq_desc_get_handler_data(desc);\n\tstruct bcm6345_l1_chip *intc = cpu->intc;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned int idx;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (idx = 0; idx < intc->n_words; idx++) {\n\t\tint base = idx * IRQS_PER_WORD;\n\t\tunsigned long pending;\n\t\tirq_hw_number_t hwirq;\n\n\t\tpending = __raw_readl(cpu->map_base + reg_status(intc, idx));\n\t\tpending &= __raw_readl(cpu->map_base + reg_enable(intc, idx));\n\n\t\tfor_each_set_bit(hwirq, &pending, IRQS_PER_WORD) {\n\t\t\tif (generic_handle_domain_irq(intc->domain, base + hwirq))\n\t\t\t\tspurious_interrupt();\n\t\t}\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic inline void __bcm6345_l1_unmask(struct irq_data *d)\n{\n\tstruct bcm6345_l1_chip *intc = irq_data_get_irq_chip_data(d);\n\tu32 word = d->hwirq / IRQS_PER_WORD;\n\tu32 mask = BIT(d->hwirq % IRQS_PER_WORD);\n\tunsigned int cpu_idx = cpu_for_irq(intc, d);\n\n\tintc->cpus[cpu_idx]->enable_cache[word] |= mask;\n\t__raw_writel(intc->cpus[cpu_idx]->enable_cache[word],\n\t\tintc->cpus[cpu_idx]->map_base + reg_enable(intc, word));\n}\n\nstatic inline void __bcm6345_l1_mask(struct irq_data *d)\n{\n\tstruct bcm6345_l1_chip *intc = irq_data_get_irq_chip_data(d);\n\tu32 word = d->hwirq / IRQS_PER_WORD;\n\tu32 mask = BIT(d->hwirq % IRQS_PER_WORD);\n\tunsigned int cpu_idx = cpu_for_irq(intc, d);\n\n\tintc->cpus[cpu_idx]->enable_cache[word] &= ~mask;\n\t__raw_writel(intc->cpus[cpu_idx]->enable_cache[word],\n\t\tintc->cpus[cpu_idx]->map_base + reg_enable(intc, word));\n}\n\nstatic void bcm6345_l1_unmask(struct irq_data *d)\n{\n\tstruct bcm6345_l1_chip *intc = irq_data_get_irq_chip_data(d);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&intc->lock, flags);\n\t__bcm6345_l1_unmask(d);\n\traw_spin_unlock_irqrestore(&intc->lock, flags);\n}\n\nstatic void bcm6345_l1_mask(struct irq_data *d)\n{\n\tstruct bcm6345_l1_chip *intc = irq_data_get_irq_chip_data(d);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&intc->lock, flags);\n\t__bcm6345_l1_mask(d);\n\traw_spin_unlock_irqrestore(&intc->lock, flags);\n}\n\nstatic int bcm6345_l1_set_affinity(struct irq_data *d,\n\t\t\t\t   const struct cpumask *dest,\n\t\t\t\t   bool force)\n{\n\tstruct bcm6345_l1_chip *intc = irq_data_get_irq_chip_data(d);\n\tu32 word = d->hwirq / IRQS_PER_WORD;\n\tu32 mask = BIT(d->hwirq % IRQS_PER_WORD);\n\tunsigned int old_cpu = cpu_for_irq(intc, d);\n\tunsigned int new_cpu;\n\tstruct cpumask valid;\n\tunsigned long flags;\n\tbool enabled;\n\n\tif (!cpumask_and(&valid, &intc->cpumask, dest))\n\t\treturn -EINVAL;\n\n\tnew_cpu = cpumask_any_and(&valid, cpu_online_mask);\n\tif (new_cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tdest = cpumask_of(new_cpu);\n\n\traw_spin_lock_irqsave(&intc->lock, flags);\n\tif (old_cpu != new_cpu) {\n\t\tenabled = intc->cpus[old_cpu]->enable_cache[word] & mask;\n\t\tif (enabled)\n\t\t\t__bcm6345_l1_mask(d);\n\t\tirq_data_update_affinity(d, dest);\n\t\tif (enabled)\n\t\t\t__bcm6345_l1_unmask(d);\n\t} else {\n\t\tirq_data_update_affinity(d, dest);\n\t}\n\traw_spin_unlock_irqrestore(&intc->lock, flags);\n\n\tirq_data_update_effective_affinity(d, cpumask_of(new_cpu));\n\n\treturn IRQ_SET_MASK_OK_NOCOPY;\n}\n\nstatic int __init bcm6345_l1_init_one(struct device_node *dn,\n\t\t\t\t      unsigned int idx,\n\t\t\t\t      struct bcm6345_l1_chip *intc)\n{\n\tstruct resource res;\n\tresource_size_t sz;\n\tstruct bcm6345_l1_cpu *cpu;\n\tunsigned int i, n_words;\n\n\tif (of_address_to_resource(dn, idx, &res))\n\t\treturn -EINVAL;\n\tsz = resource_size(&res);\n\tn_words = sz / REG_BYTES_PER_IRQ_WORD;\n\n\tif (!intc->n_words)\n\t\tintc->n_words = n_words;\n\telse if (intc->n_words != n_words)\n\t\treturn -EINVAL;\n\n\tcpu = intc->cpus[idx] = kzalloc(sizeof(*cpu) + n_words * sizeof(u32),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!cpu)\n\t\treturn -ENOMEM;\n\n\tcpu->intc = intc;\n\tcpu->map_base = ioremap(res.start, sz);\n\tif (!cpu->map_base)\n\t\treturn -ENOMEM;\n\n\tif (!request_mem_region(res.start, sz, res.name))\n\t\tpr_err(\"failed to request intc memory\");\n\n\tfor (i = 0; i < n_words; i++) {\n\t\tcpu->enable_cache[i] = 0;\n\t\t__raw_writel(0, cpu->map_base + reg_enable(intc, i));\n\t}\n\n\tcpu->parent_irq = irq_of_parse_and_map(dn, idx);\n\tif (!cpu->parent_irq) {\n\t\tpr_err(\"failed to map parent interrupt %d\\n\", cpu->parent_irq);\n\t\treturn -EINVAL;\n\t}\n\tirq_set_chained_handler_and_data(cpu->parent_irq,\n\t\t\t\t\t\tbcm6345_l1_irq_handle, cpu);\n\n\treturn 0;\n}\n\nstatic struct irq_chip bcm6345_l1_irq_chip = {\n\t.name\t\t\t= \"bcm6345-l1\",\n\t.irq_mask\t\t= bcm6345_l1_mask,\n\t.irq_unmask\t\t= bcm6345_l1_unmask,\n\t.irq_set_affinity\t= bcm6345_l1_set_affinity,\n};\n\nstatic int bcm6345_l1_map(struct irq_domain *d, unsigned int virq,\n\t\t\t  irq_hw_number_t hw_irq)\n{\n\tirq_set_chip_and_handler(virq,\n\t\t&bcm6345_l1_irq_chip, handle_percpu_irq);\n\tirq_set_chip_data(virq, d->host_data);\n\tirqd_set_single_target(irq_desc_get_irq_data(irq_to_desc(virq)));\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops bcm6345_l1_domain_ops = {\n\t.xlate\t\t\t= irq_domain_xlate_onecell,\n\t.map\t\t\t= bcm6345_l1_map,\n};\n\nstatic int __init bcm6345_l1_of_init(struct device_node *dn,\n\t\t\t      struct device_node *parent)\n{\n\tstruct bcm6345_l1_chip *intc;\n\tunsigned int idx;\n\tint ret;\n\n\tintc = kzalloc(sizeof(*intc), GFP_KERNEL);\n\tif (!intc)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(idx) {\n\t\tret = bcm6345_l1_init_one(dn, idx, intc);\n\t\tif (ret)\n\t\t\tpr_err(\"failed to init intc L1 for cpu %d: %d\\n\",\n\t\t\t\tidx, ret);\n\t\telse\n\t\t\tcpumask_set_cpu(idx, &intc->cpumask);\n\t}\n\n\tif (cpumask_empty(&intc->cpumask)) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\traw_spin_lock_init(&intc->lock);\n\n\tintc->domain = irq_domain_add_linear(dn, IRQS_PER_WORD * intc->n_words,\n\t\t\t\t\t     &bcm6345_l1_domain_ops,\n\t\t\t\t\t     intc);\n\tif (!intc->domain) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n\tpr_info(\"registered BCM6345 L1 intc (IRQs: %d)\\n\",\n\t\t\tIRQS_PER_WORD * intc->n_words);\n\tfor_each_cpu(idx, &intc->cpumask) {\n\t\tstruct bcm6345_l1_cpu *cpu = intc->cpus[idx];\n\n\t\tpr_info(\"  CPU%u (irq = %d)\\n\", idx, cpu->parent_irq);\n\t}\n\n\treturn 0;\n\nout_unmap:\n\tfor_each_possible_cpu(idx) {\n\t\tstruct bcm6345_l1_cpu *cpu = intc->cpus[idx];\n\n\t\tif (cpu) {\n\t\t\tif (cpu->map_base)\n\t\t\t\tiounmap(cpu->map_base);\n\t\t\tkfree(cpu);\n\t\t}\n\t}\nout_free:\n\tkfree(intc);\n\treturn ret;\n}\n\nIRQCHIP_DECLARE(bcm6345_l1, \"brcm,bcm6345-l1-intc\", bcm6345_l1_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}