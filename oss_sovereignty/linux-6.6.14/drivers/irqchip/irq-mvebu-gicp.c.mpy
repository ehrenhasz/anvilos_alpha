{
  "module_name": "irq-mvebu-gicp.c",
  "hash_id": "0f517a14c58cbc04a0325c134d4d2245aa0f9af461543558ba76198f81c83e44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mvebu-gicp.c",
  "human_readable_source": " \n\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include <dt-bindings/interrupt-controller/arm-gic.h>\n\n#define GICP_SETSPI_NSR_OFFSET\t0x0\n#define GICP_CLRSPI_NSR_OFFSET\t0x8\n\nstruct mvebu_gicp_spi_range {\n\tunsigned int start;\n\tunsigned int count;\n};\n\nstruct mvebu_gicp {\n\tstruct mvebu_gicp_spi_range *spi_ranges;\n\tunsigned int spi_ranges_cnt;\n\tunsigned int spi_cnt;\n\tunsigned long *spi_bitmap;\n\tspinlock_t spi_lock;\n\tstruct resource *res;\n\tstruct device *dev;\n};\n\nstatic int gicp_idx_to_spi(struct mvebu_gicp *gicp, int idx)\n{\n\tint i;\n\n\tfor (i = 0; i < gicp->spi_ranges_cnt; i++) {\n\t\tstruct mvebu_gicp_spi_range *r = &gicp->spi_ranges[i];\n\n\t\tif (idx < r->count)\n\t\t\treturn r->start + idx;\n\n\t\tidx -= r->count;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void gicp_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct mvebu_gicp *gicp = data->chip_data;\n\tphys_addr_t setspi = gicp->res->start + GICP_SETSPI_NSR_OFFSET;\n\tphys_addr_t clrspi = gicp->res->start + GICP_CLRSPI_NSR_OFFSET;\n\n\tmsg[0].data = data->hwirq;\n\tmsg[0].address_lo = lower_32_bits(setspi);\n\tmsg[0].address_hi = upper_32_bits(setspi);\n\tmsg[1].data = data->hwirq;\n\tmsg[1].address_lo = lower_32_bits(clrspi);\n\tmsg[1].address_hi = upper_32_bits(clrspi);\n}\n\nstatic struct irq_chip gicp_irq_chip = {\n\t.name\t\t\t= \"GICP\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n\t.irq_compose_msi_msg\t= gicp_compose_msi_msg,\n};\n\nstatic int gicp_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs, void *args)\n{\n\tstruct mvebu_gicp *gicp = domain->host_data;\n\tstruct irq_fwspec fwspec;\n\tunsigned int hwirq;\n\tint ret;\n\n\tspin_lock(&gicp->spi_lock);\n\thwirq = find_first_zero_bit(gicp->spi_bitmap, gicp->spi_cnt);\n\tif (hwirq == gicp->spi_cnt) {\n\t\tspin_unlock(&gicp->spi_lock);\n\t\treturn -ENOSPC;\n\t}\n\t__set_bit(hwirq, gicp->spi_bitmap);\n\tspin_unlock(&gicp->spi_lock);\n\n\tfwspec.fwnode = domain->parent->fwnode;\n\tfwspec.param_count = 3;\n\tfwspec.param[0] = GIC_SPI;\n\tfwspec.param[1] = gicp_idx_to_spi(gicp, hwirq) - 32;\n\t \n\tfwspec.param[2] = IRQ_TYPE_EDGE_RISING;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\n\tif (ret) {\n\t\tdev_err(gicp->dev, \"Cannot allocate parent IRQ\\n\");\n\t\tgoto free_hwirq;\n\t}\n\n\tret = irq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t\t    &gicp_irq_chip, gicp);\n\tif (ret)\n\t\tgoto free_irqs_parent;\n\n\treturn 0;\n\nfree_irqs_parent:\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\nfree_hwirq:\n\tspin_lock(&gicp->spi_lock);\n\t__clear_bit(hwirq, gicp->spi_bitmap);\n\tspin_unlock(&gicp->spi_lock);\n\treturn ret;\n}\n\nstatic void gicp_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct mvebu_gicp *gicp = domain->host_data;\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\n\tif (d->hwirq >= gicp->spi_cnt) {\n\t\tdev_err(gicp->dev, \"Invalid hwirq %lu\\n\", d->hwirq);\n\t\treturn;\n\t}\n\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n\n\tspin_lock(&gicp->spi_lock);\n\t__clear_bit(d->hwirq, gicp->spi_bitmap);\n\tspin_unlock(&gicp->spi_lock);\n}\n\nstatic const struct irq_domain_ops gicp_domain_ops = {\n\t.alloc\t= gicp_irq_domain_alloc,\n\t.free\t= gicp_irq_domain_free,\n};\n\nstatic struct irq_chip gicp_msi_irq_chip = {\n\t.name\t\t= \"GICP\",\n\t.irq_set_type\t= irq_chip_set_type_parent,\n\t.flags\t\t= IRQCHIP_SUPPORTS_LEVEL_MSI,\n};\n\nstatic struct msi_domain_ops gicp_msi_ops = {\n};\n\nstatic struct msi_domain_info gicp_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_LEVEL_CAPABLE),\n\t.ops\t= &gicp_msi_ops,\n\t.chip\t= &gicp_msi_irq_chip,\n};\n\nstatic int mvebu_gicp_probe(struct platform_device *pdev)\n{\n\tstruct mvebu_gicp *gicp;\n\tstruct irq_domain *inner_domain, *plat_domain, *parent_domain;\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device_node *irq_parent_dn;\n\tint ret, i;\n\n\tgicp = devm_kzalloc(&pdev->dev, sizeof(*gicp), GFP_KERNEL);\n\tif (!gicp)\n\t\treturn -ENOMEM;\n\n\tgicp->dev = &pdev->dev;\n\tspin_lock_init(&gicp->spi_lock);\n\n\tgicp->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!gicp->res)\n\t\treturn -ENODEV;\n\n\tret = of_property_count_u32_elems(node, \"marvell,spi-ranges\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgicp->spi_ranges_cnt = ret / 2;\n\n\tgicp->spi_ranges =\n\t\tdevm_kcalloc(&pdev->dev,\n\t\t\t     gicp->spi_ranges_cnt,\n\t\t\t     sizeof(struct mvebu_gicp_spi_range),\n\t\t\t     GFP_KERNEL);\n\tif (!gicp->spi_ranges)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < gicp->spi_ranges_cnt; i++) {\n\t\tof_property_read_u32_index(node, \"marvell,spi-ranges\",\n\t\t\t\t\t   i * 2,\n\t\t\t\t\t   &gicp->spi_ranges[i].start);\n\n\t\tof_property_read_u32_index(node, \"marvell,spi-ranges\",\n\t\t\t\t\t   i * 2 + 1,\n\t\t\t\t\t   &gicp->spi_ranges[i].count);\n\n\t\tgicp->spi_cnt += gicp->spi_ranges[i].count;\n\t}\n\n\tgicp->spi_bitmap = devm_bitmap_zalloc(&pdev->dev, gicp->spi_cnt, GFP_KERNEL);\n\tif (!gicp->spi_bitmap)\n\t\treturn -ENOMEM;\n\n\tirq_parent_dn = of_irq_find_parent(node);\n\tif (!irq_parent_dn) {\n\t\tdev_err(&pdev->dev, \"failed to find parent IRQ node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tparent_domain = irq_find_host(irq_parent_dn);\n\tof_node_put(irq_parent_dn);\n\tif (!parent_domain) {\n\t\tdev_err(&pdev->dev, \"failed to find parent IRQ domain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tinner_domain = irq_domain_create_hierarchy(parent_domain, 0,\n\t\t\t\t\t\t   gicp->spi_cnt,\n\t\t\t\t\t\t   of_node_to_fwnode(node),\n\t\t\t\t\t\t   &gicp_domain_ops, gicp);\n\tif (!inner_domain)\n\t\treturn -ENOMEM;\n\n\n\tplat_domain = platform_msi_create_irq_domain(of_node_to_fwnode(node),\n\t\t\t\t\t\t     &gicp_msi_domain_info,\n\t\t\t\t\t\t     inner_domain);\n\tif (!plat_domain) {\n\t\tirq_domain_remove(inner_domain);\n\t\treturn -ENOMEM;\n\t}\n\n\tplatform_set_drvdata(pdev, gicp);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mvebu_gicp_of_match[] = {\n\t{ .compatible = \"marvell,ap806-gicp\", },\n\t{},\n};\n\nstatic struct platform_driver mvebu_gicp_driver = {\n\t.probe  = mvebu_gicp_probe,\n\t.driver = {\n\t\t.name = \"mvebu-gicp\",\n\t\t.of_match_table = mvebu_gicp_of_match,\n\t},\n};\nbuiltin_platform_driver(mvebu_gicp_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}