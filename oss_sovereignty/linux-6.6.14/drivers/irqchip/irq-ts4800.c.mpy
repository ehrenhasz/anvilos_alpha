{
  "module_name": "irq-ts4800.c",
  "hash_id": "ea2259dc8728e85d649a67f88d3720c55079c49706480bcc52691354e1efd6ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-ts4800.c",
  "human_readable_source": " \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n\n#define IRQ_MASK        0x4\n#define IRQ_STATUS      0x8\n\nstruct ts4800_irq_data {\n\tvoid __iomem            *base;\n\tstruct platform_device\t*pdev;\n\tstruct irq_domain       *domain;\n};\n\nstatic void ts4800_irq_mask(struct irq_data *d)\n{\n\tstruct ts4800_irq_data *data = irq_data_get_irq_chip_data(d);\n\tu16 reg = readw(data->base + IRQ_MASK);\n\tu16 mask = 1 << d->hwirq;\n\n\twritew(reg | mask, data->base + IRQ_MASK);\n}\n\nstatic void ts4800_irq_unmask(struct irq_data *d)\n{\n\tstruct ts4800_irq_data *data = irq_data_get_irq_chip_data(d);\n\tu16 reg = readw(data->base + IRQ_MASK);\n\tu16 mask = 1 << d->hwirq;\n\n\twritew(reg & ~mask, data->base + IRQ_MASK);\n}\n\nstatic void ts4800_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct ts4800_irq_data *data = irq_data_get_irq_chip_data(d);\n\n\tseq_printf(p, \"%s\", dev_name(&data->pdev->dev));\n}\n\nstatic const struct irq_chip ts4800_chip = {\n\t.irq_mask\t= ts4800_irq_mask,\n\t.irq_unmask\t= ts4800_irq_unmask,\n\t.irq_print_chip\t= ts4800_irq_print_chip,\n};\n\nstatic int ts4800_irqdomain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tstruct ts4800_irq_data *data = d->host_data;\n\n\tirq_set_chip_and_handler(irq, &ts4800_chip, handle_simple_irq);\n\tirq_set_chip_data(irq, data);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops ts4800_ic_ops = {\n\t.map = ts4800_irqdomain_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic void ts4800_ic_chained_handle_irq(struct irq_desc *desc)\n{\n\tstruct ts4800_irq_data *data = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tu16 status = readw(data->base + IRQ_STATUS);\n\n\tchained_irq_enter(chip, desc);\n\n\tif (unlikely(status == 0)) {\n\t\thandle_bad_irq(desc);\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tunsigned int bit = __ffs(status);\n\n\t\tgeneric_handle_domain_irq(data->domain, bit);\n\t\tstatus &= ~(1 << bit);\n\t} while (status);\n\nout:\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int ts4800_ic_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct ts4800_irq_data *data;\n\tint parent_irq;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->pdev = pdev;\n\tdata->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->base))\n\t\treturn PTR_ERR(data->base);\n\n\twritew(0xFFFF, data->base + IRQ_MASK);\n\n\tparent_irq = irq_of_parse_and_map(node, 0);\n\tif (!parent_irq) {\n\t\tdev_err(&pdev->dev, \"failed to get parent IRQ\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->domain = irq_domain_add_linear(node, 8, &ts4800_ic_ops, data);\n\tif (!data->domain) {\n\t\tdev_err(&pdev->dev, \"cannot add IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tirq_set_chained_handler_and_data(parent_irq,\n\t\t\t\t\t ts4800_ic_chained_handle_irq, data);\n\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n}\n\nstatic int ts4800_ic_remove(struct platform_device *pdev)\n{\n\tstruct ts4800_irq_data *data = platform_get_drvdata(pdev);\n\n\tirq_domain_remove(data->domain);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ts4800_ic_of_match[] = {\n\t{ .compatible = \"technologic,ts4800-irqc\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ts4800_ic_of_match);\n\nstatic struct platform_driver ts4800_ic_driver = {\n\t.probe  = ts4800_ic_probe,\n\t.remove = ts4800_ic_remove,\n\t.driver = {\n\t\t.name = \"ts4800-irqc\",\n\t\t.of_match_table = ts4800_ic_of_match,\n\t},\n};\nmodule_platform_driver(ts4800_ic_driver);\n\nMODULE_AUTHOR(\"Damien Riegel <damien.riegel@savoirfairelinux.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:ts4800_irqc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}