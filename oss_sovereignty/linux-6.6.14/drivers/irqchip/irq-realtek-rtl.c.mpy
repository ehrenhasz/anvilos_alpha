{
  "module_name": "irq-realtek-rtl.c",
  "hash_id": "eefcea30c113aaf69ddc566fec13184dee27c24dfb15231d02f9f144929539ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-realtek-rtl.c",
  "human_readable_source": "\n \n\n#include <linux/of_irq.h>\n#include <linux/irqchip.h>\n#include <linux/spinlock.h>\n#include <linux/of_address.h>\n#include <linux/irqchip/chained_irq.h>\n\n \n#define RTL_ICTL_GIMR\t\t0x00\n \n#define RTL_ICTL_GISR\t\t0x04\n \n#define RTL_ICTL_IRR0\t\t0x08\n#define RTL_ICTL_IRR1\t\t0x0c\n#define RTL_ICTL_IRR2\t\t0x10\n#define RTL_ICTL_IRR3\t\t0x14\n\n#define RTL_ICTL_NUM_INPUTS\t32\n\n#define REG(x)\t\t(realtek_ictl_base + x)\n\nstatic DEFINE_RAW_SPINLOCK(irq_lock);\nstatic void __iomem *realtek_ictl_base;\n\n \n#define IRR_OFFSET(idx)\t\t(4 * (3 - (idx * 4) / 32))\n#define IRR_SHIFT(idx)\t\t((idx * 4) % 32)\n\nstatic void write_irr(void __iomem *irr0, int idx, u32 value)\n{\n\tunsigned int offset = IRR_OFFSET(idx);\n\tunsigned int shift = IRR_SHIFT(idx);\n\tu32 irr;\n\n\tirr = readl(irr0 + offset) & ~(0xf << shift);\n\tirr |= (value & 0xf) << shift;\n\twritel(irr, irr0 + offset);\n}\n\nstatic void realtek_ictl_unmask_irq(struct irq_data *i)\n{\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&irq_lock, flags);\n\n\tvalue = readl(REG(RTL_ICTL_GIMR));\n\tvalue |= BIT(i->hwirq);\n\twritel(value, REG(RTL_ICTL_GIMR));\n\n\traw_spin_unlock_irqrestore(&irq_lock, flags);\n}\n\nstatic void realtek_ictl_mask_irq(struct irq_data *i)\n{\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&irq_lock, flags);\n\n\tvalue = readl(REG(RTL_ICTL_GIMR));\n\tvalue &= ~BIT(i->hwirq);\n\twritel(value, REG(RTL_ICTL_GIMR));\n\n\traw_spin_unlock_irqrestore(&irq_lock, flags);\n}\n\nstatic struct irq_chip realtek_ictl_irq = {\n\t.name = \"realtek-rtl-intc\",\n\t.irq_mask = realtek_ictl_mask_irq,\n\t.irq_unmask = realtek_ictl_unmask_irq,\n};\n\nstatic int intc_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)\n{\n\tunsigned long flags;\n\n\tirq_set_chip_and_handler(irq, &realtek_ictl_irq, handle_level_irq);\n\n\traw_spin_lock_irqsave(&irq_lock, flags);\n\twrite_irr(REG(RTL_ICTL_IRR0), hw, 1);\n\traw_spin_unlock_irqrestore(&irq_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops irq_domain_ops = {\n\t.map = intc_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic void realtek_irq_dispatch(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irq_domain *domain;\n\tunsigned long pending;\n\tunsigned int soc_int;\n\n\tchained_irq_enter(chip, desc);\n\tpending = readl(REG(RTL_ICTL_GIMR)) & readl(REG(RTL_ICTL_GISR));\n\n\tif (unlikely(!pending)) {\n\t\tspurious_interrupt();\n\t\tgoto out;\n\t}\n\n\tdomain = irq_desc_get_handler_data(desc);\n\tfor_each_set_bit(soc_int, &pending, 32)\n\t\tgeneric_handle_domain_irq(domain, soc_int);\n\nout:\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int __init realtek_rtl_of_init(struct device_node *node, struct device_node *parent)\n{\n\tstruct of_phandle_args oirq;\n\tstruct irq_domain *domain;\n\tunsigned int soc_irq;\n\tint parent_irq;\n\n\trealtek_ictl_base = of_iomap(node, 0);\n\tif (!realtek_ictl_base)\n\t\treturn -ENXIO;\n\n\t \n\twritel(0, REG(RTL_ICTL_GIMR));\n\tfor (soc_irq = 0; soc_irq < RTL_ICTL_NUM_INPUTS; soc_irq++)\n\t\twrite_irr(REG(RTL_ICTL_IRR0), soc_irq, 0);\n\n\tif (WARN_ON(!of_irq_count(node))) {\n\t\t \n\t\toirq.np = of_find_compatible_node(NULL, NULL, \"mti,cpu-interrupt-controller\");\n\t\toirq.args_count = 1;\n\t\toirq.args[0] = 2;\n\n\t\tparent_irq = irq_create_of_mapping(&oirq);\n\n\t\tof_node_put(oirq.np);\n\t} else {\n\t\tparent_irq = of_irq_get(node, 0);\n\t}\n\n\tif (parent_irq < 0)\n\t\treturn parent_irq;\n\telse if (!parent_irq)\n\t\treturn -ENODEV;\n\n\tdomain = irq_domain_add_linear(node, RTL_ICTL_NUM_INPUTS, &irq_domain_ops, NULL);\n\tif (!domain)\n\t\treturn -ENOMEM;\n\n\tirq_set_chained_handler_and_data(parent_irq, realtek_irq_dispatch, domain);\n\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(realtek_rtl_intc, \"realtek,rtl-intc\", realtek_rtl_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}