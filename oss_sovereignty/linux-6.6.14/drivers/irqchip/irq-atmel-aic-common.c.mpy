{
  "module_name": "irq-atmel-aic-common.c",
  "hash_id": "d104f4258c0404557fa39727c4e78c2e03e5547594d7d566585c8607edbffc3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-atmel-aic-common.c",
  "human_readable_source": " \n\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n\n#include \"irq-atmel-aic-common.h\"\n\n#define AT91_AIC_PRIOR\t\t\tGENMASK(2, 0)\n#define AT91_AIC_IRQ_MIN_PRIORITY\t0\n#define AT91_AIC_IRQ_MAX_PRIORITY\t7\n\n#define AT91_AIC_SRCTYPE\t\tGENMASK(6, 5)\n#define AT91_AIC_SRCTYPE_LOW\t\t(0 << 5)\n#define AT91_AIC_SRCTYPE_FALLING\t(1 << 5)\n#define AT91_AIC_SRCTYPE_HIGH\t\t(2 << 5)\n#define AT91_AIC_SRCTYPE_RISING\t\t(3 << 5)\n\nstruct aic_chip_data {\n\tu32 ext_irqs;\n};\n\nstatic void aic_common_shutdown(struct irq_data *d)\n{\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\n\tct->chip.irq_mask(d);\n}\n\nint aic_common_set_type(struct irq_data *d, unsigned type, unsigned *val)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct aic_chip_data *aic = gc->private;\n\tunsigned aic_type;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\taic_type = AT91_AIC_SRCTYPE_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\taic_type = AT91_AIC_SRCTYPE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tif (!(d->mask & aic->ext_irqs))\n\t\t\treturn -EINVAL;\n\n\t\taic_type = AT91_AIC_SRCTYPE_LOW;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tif (!(d->mask & aic->ext_irqs))\n\t\t\treturn -EINVAL;\n\n\t\taic_type = AT91_AIC_SRCTYPE_FALLING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*val &= ~AT91_AIC_SRCTYPE;\n\t*val |= aic_type;\n\n\treturn 0;\n}\n\nvoid aic_common_set_priority(int priority, unsigned *val)\n{\n\t*val &= ~AT91_AIC_PRIOR;\n\t*val |= priority;\n}\n\nint aic_common_irq_domain_xlate(struct irq_domain *d,\n\t\t\t\tstruct device_node *ctrlr,\n\t\t\t\tconst u32 *intspec,\n\t\t\t\tunsigned int intsize,\n\t\t\t\tirq_hw_number_t *out_hwirq,\n\t\t\t\tunsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 3))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON((intspec[2] < AT91_AIC_IRQ_MIN_PRIORITY) ||\n\t\t    (intspec[2] > AT91_AIC_IRQ_MAX_PRIORITY)))\n\t\treturn -EINVAL;\n\n\t*out_hwirq = intspec[0];\n\t*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\n\treturn 0;\n}\n\nstatic void __init aic_common_ext_irq_of_init(struct irq_domain *domain)\n{\n\tstruct device_node *node = irq_domain_get_of_node(domain);\n\tstruct irq_chip_generic *gc;\n\tstruct aic_chip_data *aic;\n\tstruct property *prop;\n\tconst __be32 *p;\n\tu32 hwirq;\n\n\tgc = irq_get_domain_generic_chip(domain, 0);\n\n\taic = gc->private;\n\taic->ext_irqs |= 1;\n\n\tof_property_for_each_u32(node, \"atmel,external-irqs\", prop, p, hwirq) {\n\t\tgc = irq_get_domain_generic_chip(domain, hwirq);\n\t\tif (!gc) {\n\t\t\tpr_warn(\"AIC: external irq %d >= %d skip it\\n\",\n\t\t\t\thwirq, domain->revmap_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\taic = gc->private;\n\t\taic->ext_irqs |= (1 << (hwirq % 32));\n\t}\n}\n\n#define AT91_RTC_IDR           0x24\n#define AT91_RTC_IMR           0x28\n#define AT91_RTC_IRQ_MASK      0x1f\n\nvoid __init aic_common_rtc_irq_fixup(void)\n{\n\tstruct device_node *np;\n\tvoid __iomem *regs;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"atmel,at91rm9200-rtc\");\n\tif (!np)\n\t\tnp = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t     \"atmel,at91sam9x5-rtc\");\n\n\tif (!np)\n\t\treturn;\n\n\tregs = of_iomap(np, 0);\n\tof_node_put(np);\n\n\tif (!regs)\n\t\treturn;\n\n\twritel(AT91_RTC_IRQ_MASK, regs + AT91_RTC_IDR);\n\n\tiounmap(regs);\n}\n\n#define AT91_RTT_MR\t\t0x00\t\t\t \n#define AT91_RTT_ALMIEN\t\t(1 << 16)\t\t \n#define AT91_RTT_RTTINCIEN\t(1 << 17)\t\t \n\nvoid __init aic_common_rtt_irq_fixup(void)\n{\n\tstruct device_node *np;\n\tvoid __iomem *regs;\n\n\t \n\tfor_each_compatible_node(np, NULL, \"atmel,at91sam9260-rtt\") {\n\t\tregs = of_iomap(np, 0);\n\t\tif (!regs)\n\t\t\tcontinue;\n\n\t\twritel(readl(regs + AT91_RTT_MR) &\n\t\t       ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN),\n\t\t       regs + AT91_RTT_MR);\n\n\t\tiounmap(regs);\n\t}\n}\n\nstatic void __init aic_common_irq_fixup(const struct of_device_id *matches)\n{\n\tstruct device_node *root = of_find_node_by_path(\"/\");\n\tconst struct of_device_id *match;\n\n\tif (!root)\n\t\treturn;\n\n\tmatch = of_match_node(matches, root);\n\n\tif (match) {\n\t\tvoid (*fixup)(void) = match->data;\n\t\tfixup();\n\t}\n\n\tof_node_put(root);\n}\n\nstruct irq_domain *__init aic_common_of_init(struct device_node *node,\n\t\t\t\t\t     const struct irq_domain_ops *ops,\n\t\t\t\t\t     const char *name, int nirqs,\n\t\t\t\t\t     const struct of_device_id *matches)\n{\n\tstruct irq_chip_generic *gc;\n\tstruct irq_domain *domain;\n\tstruct aic_chip_data *aic;\n\tvoid __iomem *reg_base;\n\tint nchips;\n\tint ret;\n\tint i;\n\n\tnchips = DIV_ROUND_UP(nirqs, 32);\n\n\treg_base = of_iomap(node, 0);\n\tif (!reg_base)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\taic = kcalloc(nchips, sizeof(*aic), GFP_KERNEL);\n\tif (!aic) {\n\t\tret = -ENOMEM;\n\t\tgoto err_iounmap;\n\t}\n\n\tdomain = irq_domain_add_linear(node, nchips * 32, ops, aic);\n\tif (!domain) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_aic;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(domain, 32, 1, name,\n\t\t\t\t\t     handle_fasteoi_irq,\n\t\t\t\t\t     IRQ_NOREQUEST | IRQ_NOPROBE |\n\t\t\t\t\t     IRQ_NOAUTOEN, 0, 0);\n\tif (ret)\n\t\tgoto err_domain_remove;\n\n\tfor (i = 0; i < nchips; i++) {\n\t\tgc = irq_get_domain_generic_chip(domain, i * 32);\n\n\t\tgc->reg_base = reg_base;\n\n\t\tgc->unused = 0;\n\t\tgc->wake_enabled = ~0;\n\t\tgc->chip_types[0].type = IRQ_TYPE_SENSE_MASK;\n\t\tgc->chip_types[0].chip.irq_eoi = irq_gc_eoi;\n\t\tgc->chip_types[0].chip.irq_set_wake = irq_gc_set_wake;\n\t\tgc->chip_types[0].chip.irq_shutdown = aic_common_shutdown;\n\t\tgc->private = &aic[i];\n\t}\n\n\taic_common_ext_irq_of_init(domain);\n\taic_common_irq_fixup(matches);\n\n\treturn domain;\n\nerr_domain_remove:\n\tirq_domain_remove(domain);\n\nerr_free_aic:\n\tkfree(aic);\n\nerr_iounmap:\n\tiounmap(reg_base);\n\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}