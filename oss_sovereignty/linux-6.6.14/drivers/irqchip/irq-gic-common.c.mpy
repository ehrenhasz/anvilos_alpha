{
  "module_name": "irq-gic-common.c",
  "hash_id": "9b04df56f4e164185cde5a8e76188d2a906ff2e76b7a75d2326e3ccf118b05c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-gic-common.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip/arm-gic.h>\n\n#include \"irq-gic-common.h\"\n\nstatic DEFINE_RAW_SPINLOCK(irq_controller_lock);\n\nvoid gic_enable_of_quirks(const struct device_node *np,\n\t\t\t  const struct gic_quirk *quirks, void *data)\n{\n\tfor (; quirks->desc; quirks++) {\n\t\tif (!quirks->compatible && !quirks->property)\n\t\t\tcontinue;\n\t\tif (quirks->compatible &&\n\t\t    !of_device_is_compatible(np, quirks->compatible))\n\t\t\tcontinue;\n\t\tif (quirks->property &&\n\t\t    !of_property_read_bool(np, quirks->property))\n\t\t\tcontinue;\n\t\tif (quirks->init(data))\n\t\t\tpr_info(\"GIC: enabling workaround for %s\\n\",\n\t\t\t\tquirks->desc);\n\t}\n}\n\nvoid gic_enable_quirks(u32 iidr, const struct gic_quirk *quirks,\n\t\tvoid *data)\n{\n\tfor (; quirks->desc; quirks++) {\n\t\tif (quirks->compatible || quirks->property)\n\t\t\tcontinue;\n\t\tif (quirks->iidr != (quirks->mask & iidr))\n\t\t\tcontinue;\n\t\tif (quirks->init(data))\n\t\t\tpr_info(\"GIC: enabling workaround for %s\\n\",\n\t\t\t\tquirks->desc);\n\t}\n}\n\nint gic_configure_irq(unsigned int irq, unsigned int type,\n\t\t       void __iomem *base, void (*sync_access)(void))\n{\n\tu32 confmask = 0x2 << ((irq % 16) * 2);\n\tu32 confoff = (irq / 16) * 4;\n\tu32 val, oldval;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t \n\traw_spin_lock_irqsave(&irq_controller_lock, flags);\n\tval = oldval = readl_relaxed(base + confoff);\n\tif (type & IRQ_TYPE_LEVEL_MASK)\n\t\tval &= ~confmask;\n\telse if (type & IRQ_TYPE_EDGE_BOTH)\n\t\tval |= confmask;\n\n\t \n\tif (val == oldval) {\n\t\traw_spin_unlock_irqrestore(&irq_controller_lock, flags);\n\t\treturn 0;\n\t}\n\n\t \n\twritel_relaxed(val, base + confoff);\n\tif (readl_relaxed(base + confoff) != val)\n\t\tret = -EINVAL;\n\n\traw_spin_unlock_irqrestore(&irq_controller_lock, flags);\n\n\tif (sync_access)\n\t\tsync_access();\n\n\treturn ret;\n}\n\nvoid gic_dist_config(void __iomem *base, int gic_irqs,\n\t\t     void (*sync_access)(void))\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 32; i < gic_irqs; i += 16)\n\t\twritel_relaxed(GICD_INT_ACTLOW_LVLTRIG,\n\t\t\t\t\tbase + GIC_DIST_CONFIG + i / 4);\n\n\t \n\tfor (i = 32; i < gic_irqs; i += 4)\n\t\twritel_relaxed(GICD_INT_DEF_PRI_X4, base + GIC_DIST_PRI + i);\n\n\t \n\tfor (i = 32; i < gic_irqs; i += 32) {\n\t\twritel_relaxed(GICD_INT_EN_CLR_X32,\n\t\t\t       base + GIC_DIST_ACTIVE_CLEAR + i / 8);\n\t\twritel_relaxed(GICD_INT_EN_CLR_X32,\n\t\t\t       base + GIC_DIST_ENABLE_CLEAR + i / 8);\n\t}\n\n\tif (sync_access)\n\t\tsync_access();\n}\n\nvoid gic_cpu_config(void __iomem *base, int nr, void (*sync_access)(void))\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < nr; i += 32) {\n\t\twritel_relaxed(GICD_INT_EN_CLR_X32,\n\t\t\t       base + GIC_DIST_ACTIVE_CLEAR + i / 8);\n\t\twritel_relaxed(GICD_INT_EN_CLR_X32,\n\t\t\t       base + GIC_DIST_ENABLE_CLEAR + i / 8);\n\t}\n\n\t \n\tfor (i = 0; i < nr; i += 4)\n\t\twritel_relaxed(GICD_INT_DEF_PRI_X4,\n\t\t\t\t\tbase + GIC_DIST_PRI + i * 4 / 4);\n\n\tif (sync_access)\n\t\tsync_access();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}