{
  "module_name": "irq-bcm2836.c",
  "hash_id": "7b96b824d60a1e689c99f8b5ed534c158c19341d5432699b46a428957618ddb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-bcm2836.c",
  "human_readable_source": "\n \n\n#include <linux/cpu.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqchip/irq-bcm2836.h>\n\n#include <asm/exception.h>\n\nstruct bcm2836_arm_irqchip_intc {\n\tstruct irq_domain *domain;\n\tvoid __iomem *base;\n};\n\nstatic struct bcm2836_arm_irqchip_intc intc  __read_mostly;\n\nstatic void bcm2836_arm_irqchip_mask_per_cpu_irq(unsigned int reg_offset,\n\t\t\t\t\t\t unsigned int bit,\n\t\t\t\t\t\t int cpu)\n{\n\tvoid __iomem *reg = intc.base + reg_offset + 4 * cpu;\n\n\twritel(readl(reg) & ~BIT(bit), reg);\n}\n\nstatic void bcm2836_arm_irqchip_unmask_per_cpu_irq(unsigned int reg_offset,\n\t\t\t\t\t\t   unsigned int bit,\n\t\t\t\t\t\t int cpu)\n{\n\tvoid __iomem *reg = intc.base + reg_offset + 4 * cpu;\n\n\twritel(readl(reg) | BIT(bit), reg);\n}\n\nstatic void bcm2836_arm_irqchip_mask_timer_irq(struct irq_data *d)\n{\n\tbcm2836_arm_irqchip_mask_per_cpu_irq(LOCAL_TIMER_INT_CONTROL0,\n\t\t\t\t\t     d->hwirq - LOCAL_IRQ_CNTPSIRQ,\n\t\t\t\t\t     smp_processor_id());\n}\n\nstatic void bcm2836_arm_irqchip_unmask_timer_irq(struct irq_data *d)\n{\n\tbcm2836_arm_irqchip_unmask_per_cpu_irq(LOCAL_TIMER_INT_CONTROL0,\n\t\t\t\t\t       d->hwirq - LOCAL_IRQ_CNTPSIRQ,\n\t\t\t\t\t       smp_processor_id());\n}\n\nstatic struct irq_chip bcm2836_arm_irqchip_timer = {\n\t.name\t\t= \"bcm2836-timer\",\n\t.irq_mask\t= bcm2836_arm_irqchip_mask_timer_irq,\n\t.irq_unmask\t= bcm2836_arm_irqchip_unmask_timer_irq,\n};\n\nstatic void bcm2836_arm_irqchip_mask_pmu_irq(struct irq_data *d)\n{\n\twritel(1 << smp_processor_id(), intc.base + LOCAL_PM_ROUTING_CLR);\n}\n\nstatic void bcm2836_arm_irqchip_unmask_pmu_irq(struct irq_data *d)\n{\n\twritel(1 << smp_processor_id(), intc.base + LOCAL_PM_ROUTING_SET);\n}\n\nstatic struct irq_chip bcm2836_arm_irqchip_pmu = {\n\t.name\t\t= \"bcm2836-pmu\",\n\t.irq_mask\t= bcm2836_arm_irqchip_mask_pmu_irq,\n\t.irq_unmask\t= bcm2836_arm_irqchip_unmask_pmu_irq,\n};\n\nstatic void bcm2836_arm_irqchip_mask_gpu_irq(struct irq_data *d)\n{\n}\n\nstatic void bcm2836_arm_irqchip_unmask_gpu_irq(struct irq_data *d)\n{\n}\n\nstatic struct irq_chip bcm2836_arm_irqchip_gpu = {\n\t.name\t\t= \"bcm2836-gpu\",\n\t.irq_mask\t= bcm2836_arm_irqchip_mask_gpu_irq,\n\t.irq_unmask\t= bcm2836_arm_irqchip_unmask_gpu_irq,\n};\n\nstatic void bcm2836_arm_irqchip_dummy_op(struct irq_data *d)\n{\n}\n\nstatic struct irq_chip bcm2836_arm_irqchip_dummy = {\n\t.name\t\t= \"bcm2836-dummy\",\n\t.irq_eoi\t= bcm2836_arm_irqchip_dummy_op,\n};\n\nstatic int bcm2836_map(struct irq_domain *d, unsigned int irq,\n\t\t       irq_hw_number_t hw)\n{\n\tstruct irq_chip *chip;\n\n\tswitch (hw) {\n\tcase LOCAL_IRQ_MAILBOX0:\n\t\tchip = &bcm2836_arm_irqchip_dummy;\n\t\tbreak;\n\tcase LOCAL_IRQ_CNTPSIRQ:\n\tcase LOCAL_IRQ_CNTPNSIRQ:\n\tcase LOCAL_IRQ_CNTHPIRQ:\n\tcase LOCAL_IRQ_CNTVIRQ:\n\t\tchip = &bcm2836_arm_irqchip_timer;\n\t\tbreak;\n\tcase LOCAL_IRQ_GPU_FAST:\n\t\tchip = &bcm2836_arm_irqchip_gpu;\n\t\tbreak;\n\tcase LOCAL_IRQ_PMU_FAST:\n\t\tchip = &bcm2836_arm_irqchip_pmu;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn_once(\"Unexpected hw irq: %lu\\n\", hw);\n\t\treturn -EINVAL;\n\t}\n\n\tirq_set_percpu_devid(irq);\n\tirq_domain_set_info(d, irq, hw, chip, d->host_data,\n\t\t\t    handle_percpu_devid_irq, NULL, NULL);\n\tirq_set_status_flags(irq, IRQ_NOAUTOEN);\n\n\treturn 0;\n}\n\nstatic void\n__exception_irq_entry bcm2836_arm_irqchip_handle_irq(struct pt_regs *regs)\n{\n\tint cpu = smp_processor_id();\n\tu32 stat;\n\n\tstat = readl_relaxed(intc.base + LOCAL_IRQ_PENDING0 + 4 * cpu);\n\tif (stat) {\n\t\tu32 hwirq = ffs(stat) - 1;\n\n\t\tgeneric_handle_domain_irq(intc.domain, hwirq);\n\t}\n}\n\n#ifdef CONFIG_SMP\nstatic struct irq_domain *ipi_domain;\n\nstatic void bcm2836_arm_irqchip_handle_ipi(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tint cpu = smp_processor_id();\n\tu32 mbox_val;\n\n\tchained_irq_enter(chip, desc);\n\n\tmbox_val = readl_relaxed(intc.base + LOCAL_MAILBOX0_CLR0 + 16 * cpu);\n\tif (mbox_val) {\n\t\tint hwirq = ffs(mbox_val) - 1;\n\t\tgeneric_handle_domain_irq(ipi_domain, hwirq);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void bcm2836_arm_irqchip_ipi_ack(struct irq_data *d)\n{\n\tint cpu = smp_processor_id();\n\n\twritel_relaxed(BIT(d->hwirq),\n\t\t       intc.base + LOCAL_MAILBOX0_CLR0 + 16 * cpu);\n}\n\nstatic void bcm2836_arm_irqchip_ipi_send_mask(struct irq_data *d,\n\t\t\t\t\t      const struct cpumask *mask)\n{\n\tint cpu;\n\tvoid __iomem *mailbox0_base = intc.base + LOCAL_MAILBOX0_SET0;\n\n\t \n\tsmp_wmb();\n\n\tfor_each_cpu(cpu, mask)\n\t\twritel_relaxed(BIT(d->hwirq), mailbox0_base + 16 * cpu);\n}\n\nstatic struct irq_chip bcm2836_arm_irqchip_ipi = {\n\t.name\t\t= \"IPI\",\n\t.irq_mask\t= bcm2836_arm_irqchip_dummy_op,\n\t.irq_unmask\t= bcm2836_arm_irqchip_dummy_op,\n\t.irq_ack\t= bcm2836_arm_irqchip_ipi_ack,\n\t.ipi_send_mask\t= bcm2836_arm_irqchip_ipi_send_mask,\n};\n\nstatic int bcm2836_arm_irqchip_ipi_alloc(struct irq_domain *d,\n\t\t\t\t\t unsigned int virq,\n\t\t\t\t\t unsigned int nr_irqs, void *args)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_percpu_devid(virq + i);\n\t\tirq_domain_set_info(d, virq + i, i, &bcm2836_arm_irqchip_ipi,\n\t\t\t\t    d->host_data,\n\t\t\t\t    handle_percpu_devid_irq,\n\t\t\t\t    NULL, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic void bcm2836_arm_irqchip_ipi_free(struct irq_domain *d,\n\t\t\t\t\t unsigned int virq,\n\t\t\t\t\t unsigned int nr_irqs)\n{\n\t \n}\n\nstatic const struct irq_domain_ops ipi_domain_ops = {\n\t.alloc\t= bcm2836_arm_irqchip_ipi_alloc,\n\t.free\t= bcm2836_arm_irqchip_ipi_free,\n};\n\nstatic int bcm2836_cpu_starting(unsigned int cpu)\n{\n\tbcm2836_arm_irqchip_unmask_per_cpu_irq(LOCAL_MAILBOX_INT_CONTROL0, 0,\n\t\t\t\t\t       cpu);\n\treturn 0;\n}\n\nstatic int bcm2836_cpu_dying(unsigned int cpu)\n{\n\tbcm2836_arm_irqchip_mask_per_cpu_irq(LOCAL_MAILBOX_INT_CONTROL0, 0,\n\t\t\t\t\t     cpu);\n\treturn 0;\n}\n\n#define BITS_PER_MBOX\t32\n\nstatic void __init bcm2836_arm_irqchip_smp_init(void)\n{\n\tstruct irq_fwspec ipi_fwspec = {\n\t\t.fwnode\t\t= intc.domain->fwnode,\n\t\t.param_count\t= 1,\n\t\t.param\t\t= {\n\t\t\t[0]\t= LOCAL_IRQ_MAILBOX0,\n\t\t},\n\t};\n\tint base_ipi, mux_irq;\n\n\tmux_irq = irq_create_fwspec_mapping(&ipi_fwspec);\n\tif (WARN_ON(mux_irq <= 0))\n\t\treturn;\n\n\tipi_domain = irq_domain_create_linear(intc.domain->fwnode,\n\t\t\t\t\t      BITS_PER_MBOX, &ipi_domain_ops,\n\t\t\t\t\t      NULL);\n\tif (WARN_ON(!ipi_domain))\n\t\treturn;\n\n\tipi_domain->flags |= IRQ_DOMAIN_FLAG_IPI_SINGLE;\n\tirq_domain_update_bus_token(ipi_domain, DOMAIN_BUS_IPI);\n\n\tbase_ipi = irq_domain_alloc_irqs(ipi_domain, BITS_PER_MBOX, NUMA_NO_NODE, NULL);\n\tif (WARN_ON(!base_ipi))\n\t\treturn;\n\n\tset_smp_ipi_range(base_ipi, BITS_PER_MBOX);\n\n\tirq_set_chained_handler_and_data(mux_irq,\n\t\t\t\t\t bcm2836_arm_irqchip_handle_ipi, NULL);\n\n\t \n\tcpuhp_setup_state(CPUHP_AP_IRQ_BCM2836_STARTING,\n\t\t\t  \"irqchip/bcm2836:starting\", bcm2836_cpu_starting,\n\t\t\t  bcm2836_cpu_dying);\n}\n#else\n#define bcm2836_arm_irqchip_smp_init()\tdo { } while(0)\n#endif\n\nstatic const struct irq_domain_ops bcm2836_arm_irqchip_intc_ops = {\n\t.xlate = irq_domain_xlate_onetwocell,\n\t.map = bcm2836_map,\n};\n\n \nstatic void bcm2835_init_local_timer_frequency(void)\n{\n\t \n\twritel(0, intc.base + LOCAL_CONTROL);\n\n\t \n\twritel(0x80000000, intc.base + LOCAL_PRESCALER);\n}\n\nstatic int __init bcm2836_arm_irqchip_l1_intc_of_init(struct device_node *node,\n\t\t\t\t\t\t      struct device_node *parent)\n{\n\tintc.base = of_iomap(node, 0);\n\tif (!intc.base) {\n\t\tpanic(\"%pOF: unable to map local interrupt registers\\n\", node);\n\t}\n\n\tbcm2835_init_local_timer_frequency();\n\n\tintc.domain = irq_domain_add_linear(node, LAST_IRQ + 1,\n\t\t\t\t\t    &bcm2836_arm_irqchip_intc_ops,\n\t\t\t\t\t    NULL);\n\tif (!intc.domain)\n\t\tpanic(\"%pOF: unable to create IRQ domain\\n\", node);\n\n\tirq_domain_update_bus_token(intc.domain, DOMAIN_BUS_WIRED);\n\n\tbcm2836_arm_irqchip_smp_init();\n\n\tset_handle_irq(bcm2836_arm_irqchip_handle_irq);\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(bcm2836_arm_irqchip_l1_intc, \"brcm,bcm2836-l1-intc\",\n\t\tbcm2836_arm_irqchip_l1_intc_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}