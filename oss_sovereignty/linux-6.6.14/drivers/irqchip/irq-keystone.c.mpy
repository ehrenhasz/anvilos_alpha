{
  "module_name": "irq-keystone.c",
  "hash_id": "9bc92c5c3760baf5d984b0094ddcec41433f5a4237c5a33581a814520bd3b597",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-keystone.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n \n#define BIT_OFS\t\t\t4\n#define KEYSTONE_N_IRQ\t\t(32 - BIT_OFS)\n\nstruct keystone_irq_device {\n\tstruct device\t\t*dev;\n\tstruct irq_chip\t\t chip;\n\tu32\t\t\t mask;\n\tint\t\t\t irq;\n\tstruct irq_domain\t*irqd;\n\tstruct regmap\t\t*devctrl_regs;\n\tu32\t\t\tdevctrl_offset;\n\traw_spinlock_t\t\twa_lock;\n};\n\nstatic inline u32 keystone_irq_readl(struct keystone_irq_device *kirq)\n{\n\tint ret;\n\tu32 val = 0;\n\n\tret = regmap_read(kirq->devctrl_regs, kirq->devctrl_offset, &val);\n\tif (ret < 0)\n\t\tdev_dbg(kirq->dev, \"irq read failed ret(%d)\\n\", ret);\n\treturn val;\n}\n\nstatic inline void\nkeystone_irq_writel(struct keystone_irq_device *kirq, u32 value)\n{\n\tint ret;\n\n\tret = regmap_write(kirq->devctrl_regs, kirq->devctrl_offset, value);\n\tif (ret < 0)\n\t\tdev_dbg(kirq->dev, \"irq write failed ret(%d)\\n\", ret);\n}\n\nstatic void keystone_irq_setmask(struct irq_data *d)\n{\n\tstruct keystone_irq_device *kirq = irq_data_get_irq_chip_data(d);\n\n\tkirq->mask |= BIT(d->hwirq);\n\tdev_dbg(kirq->dev, \"mask %lu [%x]\\n\", d->hwirq, kirq->mask);\n}\n\nstatic void keystone_irq_unmask(struct irq_data *d)\n{\n\tstruct keystone_irq_device *kirq = irq_data_get_irq_chip_data(d);\n\n\tkirq->mask &= ~BIT(d->hwirq);\n\tdev_dbg(kirq->dev, \"unmask %lu [%x]\\n\", d->hwirq, kirq->mask);\n}\n\nstatic void keystone_irq_ack(struct irq_data *d)\n{\n\t \n}\n\nstatic irqreturn_t keystone_irq_handler(int irq, void *keystone_irq)\n{\n\tstruct keystone_irq_device *kirq = keystone_irq;\n\tunsigned long wa_lock_flags;\n\tunsigned long pending;\n\tint src, err;\n\n\tdev_dbg(kirq->dev, \"start irq %d\\n\", irq);\n\n\tpending = keystone_irq_readl(kirq);\n\tkeystone_irq_writel(kirq, pending);\n\n\tdev_dbg(kirq->dev, \"pending 0x%lx, mask 0x%x\\n\", pending, kirq->mask);\n\n\tpending = (pending >> BIT_OFS) & ~kirq->mask;\n\n\tdev_dbg(kirq->dev, \"pending after mask 0x%lx\\n\", pending);\n\n\tfor (src = 0; src < KEYSTONE_N_IRQ; src++) {\n\t\tif (BIT(src) & pending) {\n\t\t\traw_spin_lock_irqsave(&kirq->wa_lock, wa_lock_flags);\n\t\t\terr = generic_handle_domain_irq(kirq->irqd, src);\n\t\t\traw_spin_unlock_irqrestore(&kirq->wa_lock,\n\t\t\t\t\t\t   wa_lock_flags);\n\n\t\t\tif (err)\n\t\t\t\tdev_warn_ratelimited(kirq->dev, \"spurious irq detected hwirq %d\\n\",\n\t\t\t\t\t\t     src);\n\t\t}\n\t}\n\n\tdev_dbg(kirq->dev, \"end irq %d\\n\", irq);\n\treturn IRQ_HANDLED;\n}\n\nstatic int keystone_irq_map(struct irq_domain *h, unsigned int virq,\n\t\t\t\tirq_hw_number_t hw)\n{\n\tstruct keystone_irq_device *kirq = h->host_data;\n\n\tirq_set_chip_data(virq, kirq);\n\tirq_set_chip_and_handler(virq, &kirq->chip, handle_level_irq);\n\tirq_set_probe(virq);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops keystone_irq_ops = {\n\t.map\t= keystone_irq_map,\n\t.xlate\t= irq_domain_xlate_onecell,\n};\n\nstatic int keystone_irq_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct keystone_irq_device *kirq;\n\tint ret;\n\n\tif (np == NULL)\n\t\treturn -EINVAL;\n\n\tkirq = devm_kzalloc(dev, sizeof(*kirq), GFP_KERNEL);\n\tif (!kirq)\n\t\treturn -ENOMEM;\n\n\tkirq->devctrl_regs =\n\t\tsyscon_regmap_lookup_by_phandle(np, \"ti,syscon-dev\");\n\tif (IS_ERR(kirq->devctrl_regs))\n\t\treturn PTR_ERR(kirq->devctrl_regs);\n\n\tret = of_property_read_u32_index(np, \"ti,syscon-dev\", 1,\n\t\t\t\t\t &kirq->devctrl_offset);\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't read the devctrl_offset offset!\\n\");\n\t\treturn ret;\n\t}\n\n\tkirq->irq = platform_get_irq(pdev, 0);\n\tif (kirq->irq < 0)\n\t\treturn kirq->irq;\n\n\tkirq->dev = dev;\n\tkirq->mask = ~0x0;\n\tkirq->chip.name\t\t= \"keystone-irq\";\n\tkirq->chip.irq_ack\t= keystone_irq_ack;\n\tkirq->chip.irq_mask\t= keystone_irq_setmask;\n\tkirq->chip.irq_unmask\t= keystone_irq_unmask;\n\n\tkirq->irqd = irq_domain_add_linear(np, KEYSTONE_N_IRQ,\n\t\t\t\t\t   &keystone_irq_ops, kirq);\n\tif (!kirq->irqd) {\n\t\tdev_err(dev, \"IRQ domain registration failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\traw_spin_lock_init(&kirq->wa_lock);\n\n\tplatform_set_drvdata(pdev, kirq);\n\n\tret = request_irq(kirq->irq, keystone_irq_handler,\n\t\t\t  0, dev_name(dev), kirq);\n\tif (ret) {\n\t\tirq_domain_remove(kirq->irqd);\n\t\treturn ret;\n\t}\n\n\t \n\tkeystone_irq_writel(kirq, ~0x0);\n\n\tdev_info(dev, \"irqchip registered, nr_irqs %u\\n\", KEYSTONE_N_IRQ);\n\n\treturn 0;\n}\n\nstatic int keystone_irq_remove(struct platform_device *pdev)\n{\n\tstruct keystone_irq_device *kirq = platform_get_drvdata(pdev);\n\tint hwirq;\n\n\tfree_irq(kirq->irq, kirq);\n\n\tfor (hwirq = 0; hwirq < KEYSTONE_N_IRQ; hwirq++)\n\t\tirq_dispose_mapping(irq_find_mapping(kirq->irqd, hwirq));\n\n\tirq_domain_remove(kirq->irqd);\n\treturn 0;\n}\n\nstatic const struct of_device_id keystone_irq_dt_ids[] = {\n\t{ .compatible = \"ti,keystone-irq\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, keystone_irq_dt_ids);\n\nstatic struct platform_driver keystone_irq_device_driver = {\n\t.probe\t\t= keystone_irq_probe,\n\t.remove\t\t= keystone_irq_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"keystone_irq\",\n\t\t.of_match_table\t= of_match_ptr(keystone_irq_dt_ids),\n\t}\n};\n\nmodule_platform_driver(keystone_irq_device_driver);\n\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_AUTHOR(\"Sajesh Kumar Saran\");\nMODULE_AUTHOR(\"Grygorii Strashko\");\nMODULE_DESCRIPTION(\"Keystone IRQ chip\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}