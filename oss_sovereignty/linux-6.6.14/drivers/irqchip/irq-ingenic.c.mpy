{
  "module_name": "irq-ingenic.c",
  "hash_id": "c1078db8a1e88b95066207bfaa48eba45882491902cee10d465bdf86d2ef8f0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-ingenic.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/irqchip.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/timex.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n\n#include <asm/io.h>\n\nstruct ingenic_intc_data {\n\tvoid __iomem *base;\n\tstruct irq_domain *domain;\n\tunsigned num_chips;\n};\n\n#define JZ_REG_INTC_STATUS\t0x00\n#define JZ_REG_INTC_MASK\t0x04\n#define JZ_REG_INTC_SET_MASK\t0x08\n#define JZ_REG_INTC_CLEAR_MASK\t0x0c\n#define JZ_REG_INTC_PENDING\t0x10\n#define CHIP_SIZE\t\t0x20\n\nstatic irqreturn_t intc_cascade(int irq, void *data)\n{\n\tstruct ingenic_intc_data *intc = irq_get_handler_data(irq);\n\tstruct irq_domain *domain = intc->domain;\n\tstruct irq_chip_generic *gc;\n\tuint32_t pending;\n\tunsigned i;\n\n\tfor (i = 0; i < intc->num_chips; i++) {\n\t\tgc = irq_get_domain_generic_chip(domain, i * 32);\n\n\t\tpending = irq_reg_readl(gc, JZ_REG_INTC_PENDING);\n\t\tif (!pending)\n\t\t\tcontinue;\n\n\t\twhile (pending) {\n\t\t\tint bit = __fls(pending);\n\n\t\t\tgeneric_handle_domain_irq(domain, bit + (i * 32));\n\t\t\tpending &= ~BIT(bit);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init ingenic_intc_of_init(struct device_node *node,\n\t\t\t\t       unsigned num_chips)\n{\n\tstruct ingenic_intc_data *intc;\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\tstruct irq_domain *domain;\n\tint parent_irq, err = 0;\n\tunsigned i;\n\n\tintc = kzalloc(sizeof(*intc), GFP_KERNEL);\n\tif (!intc) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tparent_irq = irq_of_parse_and_map(node, 0);\n\tif (!parent_irq) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\terr = irq_set_handler_data(parent_irq, intc);\n\tif (err)\n\t\tgoto out_unmap_irq;\n\n\tintc->num_chips = num_chips;\n\tintc->base = of_iomap(node, 0);\n\tif (!intc->base) {\n\t\terr = -ENODEV;\n\t\tgoto out_unmap_irq;\n\t}\n\n\tdomain = irq_domain_add_linear(node, num_chips * 32,\n\t\t\t\t       &irq_generic_chip_ops, NULL);\n\tif (!domain) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unmap_base;\n\t}\n\n\tintc->domain = domain;\n\n\terr = irq_alloc_domain_generic_chips(domain, 32, 1, \"INTC\",\n\t\t\t\t\t     handle_level_irq, 0,\n\t\t\t\t\t     IRQ_NOPROBE | IRQ_LEVEL, 0);\n\tif (err)\n\t\tgoto out_domain_remove;\n\n\tfor (i = 0; i < num_chips; i++) {\n\t\tgc = irq_get_domain_generic_chip(domain, i * 32);\n\n\t\tgc->wake_enabled = IRQ_MSK(32);\n\t\tgc->reg_base = intc->base + (i * CHIP_SIZE);\n\n\t\tct = gc->chip_types;\n\t\tct->regs.enable = JZ_REG_INTC_CLEAR_MASK;\n\t\tct->regs.disable = JZ_REG_INTC_SET_MASK;\n\t\tct->chip.irq_unmask = irq_gc_unmask_enable_reg;\n\t\tct->chip.irq_mask = irq_gc_mask_disable_reg;\n\t\tct->chip.irq_mask_ack = irq_gc_mask_disable_reg;\n\t\tct->chip.irq_set_wake = irq_gc_set_wake;\n\t\tct->chip.flags = IRQCHIP_MASK_ON_SUSPEND;\n\n\t\t \n\t\tirq_reg_writel(gc, IRQ_MSK(32), JZ_REG_INTC_SET_MASK);\n\t}\n\n\tif (request_irq(parent_irq, intc_cascade, IRQF_NO_SUSPEND,\n\t\t\t\"SoC intc cascade interrupt\", NULL))\n\t\tpr_err(\"Failed to register SoC intc cascade interrupt\\n\");\n\treturn 0;\n\nout_domain_remove:\n\tirq_domain_remove(domain);\nout_unmap_base:\n\tiounmap(intc->base);\nout_unmap_irq:\n\tirq_dispose_mapping(parent_irq);\nout_free:\n\tkfree(intc);\nout_err:\n\treturn err;\n}\n\nstatic int __init intc_1chip_of_init(struct device_node *node,\n\t\t\t\t     struct device_node *parent)\n{\n\treturn ingenic_intc_of_init(node, 1);\n}\nIRQCHIP_DECLARE(jz4740_intc, \"ingenic,jz4740-intc\", intc_1chip_of_init);\nIRQCHIP_DECLARE(jz4725b_intc, \"ingenic,jz4725b-intc\", intc_1chip_of_init);\n\nstatic int __init intc_2chip_of_init(struct device_node *node,\n\tstruct device_node *parent)\n{\n\treturn ingenic_intc_of_init(node, 2);\n}\nIRQCHIP_DECLARE(jz4760_intc, \"ingenic,jz4760-intc\", intc_2chip_of_init);\nIRQCHIP_DECLARE(jz4770_intc, \"ingenic,jz4770-intc\", intc_2chip_of_init);\nIRQCHIP_DECLARE(jz4775_intc, \"ingenic,jz4775-intc\", intc_2chip_of_init);\nIRQCHIP_DECLARE(jz4780_intc, \"ingenic,jz4780-intc\", intc_2chip_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}