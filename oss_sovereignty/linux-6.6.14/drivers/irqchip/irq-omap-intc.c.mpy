{
  "module_name": "irq-omap-intc.c",
  "hash_id": "6eb45b2588a5db16f3082eac67a26baeb2369ea2e076feff747b35880ab0e39c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-omap-intc.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n\n#include <asm/exception.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <linux/irqchip/irq-omap-intc.h>\n\n \n\n#define INTC_REVISION\t\t0x0000\n#define INTC_SYSCONFIG\t\t0x0010\n#define INTC_SYSSTATUS\t\t0x0014\n#define INTC_SIR\t\t0x0040\n#define INTC_CONTROL\t\t0x0048\n#define INTC_PROTECTION\t\t0x004C\n#define INTC_IDLE\t\t0x0050\n#define INTC_THRESHOLD\t\t0x0068\n#define INTC_MIR0\t\t0x0084\n#define INTC_MIR_CLEAR0\t\t0x0088\n#define INTC_MIR_SET0\t\t0x008c\n#define INTC_PENDING_IRQ0\t0x0098\n#define INTC_PENDING_IRQ1\t0x00b8\n#define INTC_PENDING_IRQ2\t0x00d8\n#define INTC_PENDING_IRQ3\t0x00f8\n#define INTC_ILR0\t\t0x0100\n\n#define ACTIVEIRQ_MASK\t\t0x7f\t \n#define SPURIOUSIRQ_MASK\t(0x1ffffff << 7)\n#define INTCPS_NR_ILR_REGS\t128\n#define INTCPS_NR_MIR_REGS\t4\n\n#define INTC_IDLE_FUNCIDLE\t(1 << 0)\n#define INTC_IDLE_TURBO\t\t(1 << 1)\n\n#define INTC_PROTECTION_ENABLE\t(1 << 0)\n\nstruct omap_intc_regs {\n\tu32 sysconfig;\n\tu32 protection;\n\tu32 idle;\n\tu32 threshold;\n\tu32 ilr[INTCPS_NR_ILR_REGS];\n\tu32 mir[INTCPS_NR_MIR_REGS];\n};\nstatic struct omap_intc_regs intc_context;\n\nstatic struct irq_domain *domain;\nstatic void __iomem *omap_irq_base;\nstatic int omap_nr_pending;\nstatic int omap_nr_irqs;\n\nstatic void intc_writel(u32 reg, u32 val)\n{\n\twritel_relaxed(val, omap_irq_base + reg);\n}\n\nstatic u32 intc_readl(u32 reg)\n{\n\treturn readl_relaxed(omap_irq_base + reg);\n}\n\nvoid omap_intc_save_context(void)\n{\n\tint i;\n\n\tintc_context.sysconfig =\n\t\tintc_readl(INTC_SYSCONFIG);\n\tintc_context.protection =\n\t\tintc_readl(INTC_PROTECTION);\n\tintc_context.idle =\n\t\tintc_readl(INTC_IDLE);\n\tintc_context.threshold =\n\t\tintc_readl(INTC_THRESHOLD);\n\n\tfor (i = 0; i < omap_nr_irqs; i++)\n\t\tintc_context.ilr[i] =\n\t\t\tintc_readl((INTC_ILR0 + 0x4 * i));\n\tfor (i = 0; i < INTCPS_NR_MIR_REGS; i++)\n\t\tintc_context.mir[i] =\n\t\t\tintc_readl(INTC_MIR0 + (0x20 * i));\n}\n\nvoid omap_intc_restore_context(void)\n{\n\tint i;\n\n\tintc_writel(INTC_SYSCONFIG, intc_context.sysconfig);\n\tintc_writel(INTC_PROTECTION, intc_context.protection);\n\tintc_writel(INTC_IDLE, intc_context.idle);\n\tintc_writel(INTC_THRESHOLD, intc_context.threshold);\n\n\tfor (i = 0; i < omap_nr_irqs; i++)\n\t\tintc_writel(INTC_ILR0 + 0x4 * i,\n\t\t\t\tintc_context.ilr[i]);\n\n\tfor (i = 0; i < INTCPS_NR_MIR_REGS; i++)\n\t\tintc_writel(INTC_MIR0 + 0x20 * i,\n\t\t\tintc_context.mir[i]);\n\t \n}\n\nvoid omap3_intc_prepare_idle(void)\n{\n\t \n\tintc_writel(INTC_SYSCONFIG, 0);\n\tintc_writel(INTC_IDLE, INTC_IDLE_TURBO);\n}\n\nvoid omap3_intc_resume_idle(void)\n{\n\t \n\tintc_writel(INTC_SYSCONFIG, 1);\n\tintc_writel(INTC_IDLE, 0);\n}\n\n \nstatic void omap_ack_irq(struct irq_data *d)\n{\n\tintc_writel(INTC_CONTROL, 0x1);\n}\n\nstatic void omap_mask_ack_irq(struct irq_data *d)\n{\n\tirq_gc_mask_disable_reg(d);\n\tomap_ack_irq(d);\n}\n\nstatic void __init omap_irq_soft_reset(void)\n{\n\tunsigned long tmp;\n\n\ttmp = intc_readl(INTC_REVISION) & 0xff;\n\n\tpr_info(\"IRQ: Found an INTC at 0x%p (revision %ld.%ld) with %d interrupts\\n\",\n\t\tomap_irq_base, tmp >> 4, tmp & 0xf, omap_nr_irqs);\n\n\ttmp = intc_readl(INTC_SYSCONFIG);\n\ttmp |= 1 << 1;\t \n\tintc_writel(INTC_SYSCONFIG, tmp);\n\n\twhile (!(intc_readl(INTC_SYSSTATUS) & 0x1))\n\t\t ;\n\n\t \n\tintc_writel(INTC_SYSCONFIG, 1 << 0);\n}\n\nint omap_irq_pending(void)\n{\n\tint i;\n\n\tfor (i = 0; i < omap_nr_pending; i++)\n\t\tif (intc_readl(INTC_PENDING_IRQ0 + (0x20 * i)))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nvoid omap3_intc_suspend(void)\n{\n\t \n\tomap_ack_irq(NULL);\n}\n\nstatic int __init omap_alloc_gc_of(struct irq_domain *d, void __iomem *base)\n{\n\tint ret;\n\tint i;\n\n\tret = irq_alloc_domain_generic_chips(d, 32, 1, \"INTC\",\n\t\t\thandle_level_irq, IRQ_NOREQUEST | IRQ_NOPROBE,\n\t\t\tIRQ_LEVEL, 0);\n\tif (ret) {\n\t\tpr_warn(\"Failed to allocate irq chips\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < omap_nr_pending; i++) {\n\t\tstruct irq_chip_generic *gc;\n\t\tstruct irq_chip_type *ct;\n\n\t\tgc = irq_get_domain_generic_chip(d, 32 * i);\n\t\tgc->reg_base = base;\n\t\tct = gc->chip_types;\n\n\t\tct->type = IRQ_TYPE_LEVEL_MASK;\n\n\t\tct->chip.irq_ack = omap_mask_ack_irq;\n\t\tct->chip.irq_mask = irq_gc_mask_disable_reg;\n\t\tct->chip.irq_unmask = irq_gc_unmask_enable_reg;\n\n\t\tct->chip.flags |= IRQCHIP_SKIP_SET_WAKE;\n\n\t\tct->regs.enable = INTC_MIR_CLEAR0 + 32 * i;\n\t\tct->regs.disable = INTC_MIR_SET0 + 32 * i;\n\t}\n\n\treturn 0;\n}\n\nstatic void __init omap_alloc_gc_legacy(void __iomem *base,\n\t\tunsigned int irq_start, unsigned int num)\n{\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\n\tgc = irq_alloc_generic_chip(\"INTC\", 1, irq_start, base,\n\t\t\thandle_level_irq);\n\tct = gc->chip_types;\n\tct->chip.irq_ack = omap_mask_ack_irq;\n\tct->chip.irq_mask = irq_gc_mask_disable_reg;\n\tct->chip.irq_unmask = irq_gc_unmask_enable_reg;\n\tct->chip.flags |= IRQCHIP_SKIP_SET_WAKE;\n\n\tct->regs.enable = INTC_MIR_CLEAR0;\n\tct->regs.disable = INTC_MIR_SET0;\n\tirq_setup_generic_chip(gc, IRQ_MSK(num), IRQ_GC_INIT_MASK_CACHE,\n\t\t\tIRQ_NOREQUEST | IRQ_NOPROBE, 0);\n}\n\nstatic int __init omap_init_irq_of(struct device_node *node)\n{\n\tint ret;\n\n\tomap_irq_base = of_iomap(node, 0);\n\tif (WARN_ON(!omap_irq_base))\n\t\treturn -ENOMEM;\n\n\tdomain = irq_domain_add_linear(node, omap_nr_irqs,\n\t\t\t&irq_generic_chip_ops, NULL);\n\n\tomap_irq_soft_reset();\n\n\tret = omap_alloc_gc_of(domain, omap_irq_base);\n\tif (ret < 0)\n\t\tirq_domain_remove(domain);\n\n\treturn ret;\n}\n\nstatic int __init omap_init_irq_legacy(u32 base, struct device_node *node)\n{\n\tint j, irq_base;\n\n\tomap_irq_base = ioremap(base, SZ_4K);\n\tif (WARN_ON(!omap_irq_base))\n\t\treturn -ENOMEM;\n\n\tirq_base = irq_alloc_descs(-1, 0, omap_nr_irqs, 0);\n\tif (irq_base < 0) {\n\t\tpr_warn(\"Couldn't allocate IRQ numbers\\n\");\n\t\tirq_base = 0;\n\t}\n\n\tdomain = irq_domain_add_legacy(node, omap_nr_irqs, irq_base, 0,\n\t\t\t&irq_domain_simple_ops, NULL);\n\n\tomap_irq_soft_reset();\n\n\tfor (j = 0; j < omap_nr_irqs; j += 32)\n\t\tomap_alloc_gc_legacy(omap_irq_base + j, j + irq_base, 32);\n\n\treturn 0;\n}\n\nstatic void __init omap_irq_enable_protection(void)\n{\n\tu32 reg;\n\n\treg = intc_readl(INTC_PROTECTION);\n\treg |= INTC_PROTECTION_ENABLE;\n\tintc_writel(INTC_PROTECTION, reg);\n}\n\nstatic int __init omap_init_irq(u32 base, struct device_node *node)\n{\n\tint ret;\n\n\t \n\tif (of_device_is_compatible(node, \"ti,omap2-intc\") ||\n\t\t\tof_device_is_compatible(node, \"ti,omap3-intc\")) {\n\t\tstruct resource res;\n\n\t\tif (of_address_to_resource(node, 0, &res))\n\t\t\treturn -ENOMEM;\n\n\t\tbase = res.start;\n\t\tret = omap_init_irq_legacy(base, node);\n\t} else if (node) {\n\t\tret = omap_init_irq_of(node);\n\t} else {\n\t\tret = omap_init_irq_legacy(base, NULL);\n\t}\n\n\tif (ret == 0)\n\t\tomap_irq_enable_protection();\n\n\treturn ret;\n}\n\nstatic asmlinkage void __exception_irq_entry\nomap_intc_handle_irq(struct pt_regs *regs)\n{\n\textern unsigned long irq_err_count;\n\tu32 irqnr;\n\n\tirqnr = intc_readl(INTC_SIR);\n\n\t \n\tif (unlikely((irqnr & SPURIOUSIRQ_MASK) == SPURIOUSIRQ_MASK)) {\n\t\tpr_err_once(\"%s: spurious irq!\\n\", __func__);\n\t\tirq_err_count++;\n\t\tomap_ack_irq(NULL);\n\t\treturn;\n\t}\n\n\tirqnr &= ACTIVEIRQ_MASK;\n\tgeneric_handle_domain_irq(domain, irqnr);\n}\n\nstatic int __init intc_of_init(struct device_node *node,\n\t\t\t     struct device_node *parent)\n{\n\tint ret;\n\n\tomap_nr_pending = 3;\n\tomap_nr_irqs = 96;\n\n\tif (WARN_ON(!node))\n\t\treturn -ENODEV;\n\n\tif (of_device_is_compatible(node, \"ti,dm814-intc\") ||\n\t    of_device_is_compatible(node, \"ti,dm816-intc\") ||\n\t    of_device_is_compatible(node, \"ti,am33xx-intc\")) {\n\t\tomap_nr_irqs = 128;\n\t\tomap_nr_pending = 4;\n\t}\n\n\tret = omap_init_irq(-1, of_node_get(node));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tset_handle_irq(omap_intc_handle_irq);\n\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(omap2_intc, \"ti,omap2-intc\", intc_of_init);\nIRQCHIP_DECLARE(omap3_intc, \"ti,omap3-intc\", intc_of_init);\nIRQCHIP_DECLARE(dm814x_intc, \"ti,dm814-intc\", intc_of_init);\nIRQCHIP_DECLARE(dm816x_intc, \"ti,dm816-intc\", intc_of_init);\nIRQCHIP_DECLARE(am33xx_intc, \"ti,am33xx-intc\", intc_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}