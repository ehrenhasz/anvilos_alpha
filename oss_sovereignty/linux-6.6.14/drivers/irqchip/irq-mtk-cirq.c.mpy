{
  "module_name": "irq-mtk-cirq.c",
  "hash_id": "4b7f8e600609db96dfba3399b78fe1a110b6740d55001800afe0a2dd853cc05e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mtk-cirq.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/syscore_ops.h>\n\nenum mtk_cirq_regoffs_index {\n\tCIRQ_STA,\n\tCIRQ_ACK,\n\tCIRQ_MASK_SET,\n\tCIRQ_MASK_CLR,\n\tCIRQ_SENS_SET,\n\tCIRQ_SENS_CLR,\n\tCIRQ_POL_SET,\n\tCIRQ_POL_CLR,\n\tCIRQ_CONTROL\n};\n\nstatic const u32 mtk_cirq_regoffs_v1[] = {\n\t[CIRQ_STA]\t= 0x0,\n\t[CIRQ_ACK]\t= 0x40,\n\t[CIRQ_MASK_SET]\t= 0xc0,\n\t[CIRQ_MASK_CLR]\t= 0x100,\n\t[CIRQ_SENS_SET]\t= 0x180,\n\t[CIRQ_SENS_CLR]\t= 0x1c0,\n\t[CIRQ_POL_SET]\t= 0x240,\n\t[CIRQ_POL_CLR]\t= 0x280,\n\t[CIRQ_CONTROL]\t= 0x300,\n};\n\nstatic const u32 mtk_cirq_regoffs_v2[] = {\n\t[CIRQ_STA]\t= 0x0,\n\t[CIRQ_ACK]\t= 0x80,\n\t[CIRQ_MASK_SET]\t= 0x180,\n\t[CIRQ_MASK_CLR]\t= 0x200,\n\t[CIRQ_SENS_SET]\t= 0x300,\n\t[CIRQ_SENS_CLR]\t= 0x380,\n\t[CIRQ_POL_SET]\t= 0x480,\n\t[CIRQ_POL_CLR]\t= 0x500,\n\t[CIRQ_CONTROL]\t= 0x600,\n};\n\n#define CIRQ_EN\t0x1\n#define CIRQ_EDGE\t0x2\n#define CIRQ_FLUSH\t0x4\n\nstruct mtk_cirq_chip_data {\n\tvoid __iomem *base;\n\tunsigned int ext_irq_start;\n\tunsigned int ext_irq_end;\n\tconst u32 *offsets;\n\tstruct irq_domain *domain;\n};\n\nstatic struct mtk_cirq_chip_data *cirq_data;\n\nstatic void __iomem *mtk_cirq_reg(struct mtk_cirq_chip_data *chip_data,\n\t\t\t\t  enum mtk_cirq_regoffs_index idx)\n{\n\treturn chip_data->base + chip_data->offsets[idx];\n}\n\nstatic void __iomem *mtk_cirq_irq_reg(struct mtk_cirq_chip_data *chip_data,\n\t\t\t\t      enum mtk_cirq_regoffs_index idx,\n\t\t\t\t      unsigned int cirq_num)\n{\n\treturn mtk_cirq_reg(chip_data, idx) + (cirq_num / 32) * 4;\n}\n\nstatic void mtk_cirq_write_mask(struct irq_data *data, enum mtk_cirq_regoffs_index idx)\n{\n\tstruct mtk_cirq_chip_data *chip_data = data->chip_data;\n\tunsigned int cirq_num = data->hwirq;\n\tu32 mask = 1 << (cirq_num % 32);\n\n\twritel_relaxed(mask, mtk_cirq_irq_reg(chip_data, idx, cirq_num));\n}\n\nstatic void mtk_cirq_mask(struct irq_data *data)\n{\n\tmtk_cirq_write_mask(data, CIRQ_MASK_SET);\n\tirq_chip_mask_parent(data);\n}\n\nstatic void mtk_cirq_unmask(struct irq_data *data)\n{\n\tmtk_cirq_write_mask(data, CIRQ_MASK_CLR);\n\tirq_chip_unmask_parent(data);\n}\n\nstatic int mtk_cirq_set_type(struct irq_data *data, unsigned int type)\n{\n\tint ret;\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tmtk_cirq_write_mask(data, CIRQ_POL_CLR);\n\t\tmtk_cirq_write_mask(data, CIRQ_SENS_CLR);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tmtk_cirq_write_mask(data, CIRQ_POL_SET);\n\t\tmtk_cirq_write_mask(data, CIRQ_SENS_CLR);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tmtk_cirq_write_mask(data, CIRQ_POL_CLR);\n\t\tmtk_cirq_write_mask(data, CIRQ_SENS_SET);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tmtk_cirq_write_mask(data, CIRQ_POL_SET);\n\t\tmtk_cirq_write_mask(data, CIRQ_SENS_SET);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdata = data->parent_data;\n\tret = data->chip->irq_set_type(data, type);\n\treturn ret;\n}\n\nstatic struct irq_chip mtk_cirq_chip = {\n\t.name\t\t\t= \"MT_CIRQ\",\n\t.irq_mask\t\t= mtk_cirq_mask,\n\t.irq_unmask\t\t= mtk_cirq_unmask,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_type\t\t= mtk_cirq_set_type,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n#endif\n};\n\nstatic int mtk_cirq_domain_translate(struct irq_domain *d,\n\t\t\t\t     struct irq_fwspec *fwspec,\n\t\t\t\t     unsigned long *hwirq,\n\t\t\t\t     unsigned int *type)\n{\n\tif (is_of_node(fwspec->fwnode)) {\n\t\tif (fwspec->param_count != 3)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (fwspec->param[0] != 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (fwspec->param[1] < cirq_data->ext_irq_start ||\n\t\t    fwspec->param[1] > cirq_data->ext_irq_end)\n\t\t\treturn -EINVAL;\n\n\t\t*hwirq = fwspec->param[1] - cirq_data->ext_irq_start;\n\t\t*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mtk_cirq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs, void *arg)\n{\n\tint ret;\n\tirq_hw_number_t hwirq;\n\tunsigned int type;\n\tstruct irq_fwspec *fwspec = arg;\n\tstruct irq_fwspec parent_fwspec = *fwspec;\n\n\tret = mtk_cirq_domain_translate(domain, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tif (WARN_ON(nr_irqs != 1))\n\t\treturn -EINVAL;\n\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t      &mtk_cirq_chip,\n\t\t\t\t      domain->host_data);\n\n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\treturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs,\n\t\t\t\t\t    &parent_fwspec);\n}\n\nstatic const struct irq_domain_ops cirq_domain_ops = {\n\t.translate\t= mtk_cirq_domain_translate,\n\t.alloc\t\t= mtk_cirq_domain_alloc,\n\t.free\t\t= irq_domain_free_irqs_common,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mtk_cirq_suspend(void)\n{\n\tvoid __iomem *reg;\n\tu32 value, mask;\n\tunsigned int irq, hwirq_num;\n\tbool pending, masked;\n\tint i, pendret, maskret;\n\n\t \n\thwirq_num = cirq_data->ext_irq_end - cirq_data->ext_irq_start + 1;\n\tfor (i = 0; i < hwirq_num; i++) {\n\t\tirq = irq_find_mapping(cirq_data->domain, i);\n\t\tif (irq) {\n\t\t\tpendret = irq_get_irqchip_state(irq,\n\t\t\t\t\t\t\tIRQCHIP_STATE_PENDING,\n\t\t\t\t\t\t\t&pending);\n\n\t\t\tmaskret = irq_get_irqchip_state(irq,\n\t\t\t\t\t\t\tIRQCHIP_STATE_MASKED,\n\t\t\t\t\t\t\t&masked);\n\n\t\t\tif (pendret == 0 && maskret == 0 &&\n\t\t\t    (pending && !masked))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\treg = mtk_cirq_irq_reg(cirq_data, CIRQ_ACK, i);\n\t\tmask = 1 << (i % 32);\n\t\twritel_relaxed(mask, reg);\n\t}\n\n\t \n\t \n\treg = mtk_cirq_reg(cirq_data, CIRQ_CONTROL);\n\tvalue = readl_relaxed(reg);\n\tvalue |= (CIRQ_EDGE | CIRQ_EN);\n\twritel_relaxed(value, reg);\n\n\treturn 0;\n}\n\nstatic void mtk_cirq_resume(void)\n{\n\tvoid __iomem *reg = mtk_cirq_reg(cirq_data, CIRQ_CONTROL);\n\tu32 value;\n\n\t \n\tvalue = readl_relaxed(reg);\n\twritel_relaxed(value | CIRQ_FLUSH, reg);\n\n\t \n\tvalue = readl_relaxed(reg);\n\tvalue &= ~(CIRQ_EDGE | CIRQ_EN);\n\twritel_relaxed(value, reg);\n}\n\nstatic struct syscore_ops mtk_cirq_syscore_ops = {\n\t.suspend\t= mtk_cirq_suspend,\n\t.resume\t\t= mtk_cirq_resume,\n};\n\nstatic void mtk_cirq_syscore_init(void)\n{\n\tregister_syscore_ops(&mtk_cirq_syscore_ops);\n}\n#else\nstatic inline void mtk_cirq_syscore_init(void) {}\n#endif\n\nstatic const struct of_device_id mtk_cirq_of_match[] = {\n\t{ .compatible = \"mediatek,mt2701-cirq\", .data = &mtk_cirq_regoffs_v1 },\n\t{ .compatible = \"mediatek,mt8135-cirq\", .data = &mtk_cirq_regoffs_v1 },\n\t{ .compatible = \"mediatek,mt8173-cirq\", .data = &mtk_cirq_regoffs_v1 },\n\t{ .compatible = \"mediatek,mt8192-cirq\", .data = &mtk_cirq_regoffs_v2 },\n\t{   }\n};\n\nstatic int __init mtk_cirq_of_init(struct device_node *node,\n\t\t\t\t   struct device_node *parent)\n{\n\tstruct irq_domain *domain, *domain_parent;\n\tconst struct of_device_id *match;\n\tunsigned int irq_num;\n\tint ret;\n\n\tdomain_parent = irq_find_host(parent);\n\tif (!domain_parent) {\n\t\tpr_err(\"mtk_cirq: interrupt-parent not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcirq_data = kzalloc(sizeof(*cirq_data), GFP_KERNEL);\n\tif (!cirq_data)\n\t\treturn -ENOMEM;\n\n\tcirq_data->base = of_iomap(node, 0);\n\tif (!cirq_data->base) {\n\t\tpr_err(\"mtk_cirq: unable to map cirq register\\n\");\n\t\tret = -ENXIO;\n\t\tgoto out_free;\n\t}\n\n\tret = of_property_read_u32_index(node, \"mediatek,ext-irq-range\", 0,\n\t\t\t\t\t &cirq_data->ext_irq_start);\n\tif (ret)\n\t\tgoto out_unmap;\n\n\tret = of_property_read_u32_index(node, \"mediatek,ext-irq-range\", 1,\n\t\t\t\t\t &cirq_data->ext_irq_end);\n\tif (ret)\n\t\tgoto out_unmap;\n\n\tmatch = of_match_node(mtk_cirq_of_match, node);\n\tif (!match) {\n\t\tret = -ENODEV;\n\t\tgoto out_unmap;\n\t}\n\tcirq_data->offsets = match->data;\n\n\tirq_num = cirq_data->ext_irq_end - cirq_data->ext_irq_start + 1;\n\tdomain = irq_domain_add_hierarchy(domain_parent, 0,\n\t\t\t\t\t  irq_num, node,\n\t\t\t\t\t  &cirq_domain_ops, cirq_data);\n\tif (!domain) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\tcirq_data->domain = domain;\n\n\tmtk_cirq_syscore_init();\n\n\treturn 0;\n\nout_unmap:\n\tiounmap(cirq_data->base);\nout_free:\n\tkfree(cirq_data);\n\treturn ret;\n}\n\nIRQCHIP_DECLARE(mtk_cirq, \"mediatek,mtk-cirq\", mtk_cirq_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}