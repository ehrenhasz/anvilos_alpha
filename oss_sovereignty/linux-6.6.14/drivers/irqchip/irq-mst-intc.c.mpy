{
  "module_name": "irq-mst-intc.c",
  "hash_id": "7ee3ec25944c11396f9468f2d8bbcad0beeb9d891147b55abc41b712fd2864c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mst-intc.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/syscore_ops.h>\n\n#define MST_INTC_MAX_IRQS\t64\n\n#define INTC_MASK\t\t0x0\n#define INTC_REV_POLARITY\t0x10\n#define INTC_EOI\t\t0x20\n\n#ifdef CONFIG_PM_SLEEP\nstatic LIST_HEAD(mst_intc_list);\n#endif\n\nstruct mst_intc_chip_data {\n\traw_spinlock_t\tlock;\n\tunsigned int\tirq_start, nr_irqs;\n\tvoid __iomem\t*base;\n\tbool\t\tno_eoi;\n#ifdef CONFIG_PM_SLEEP\n\tstruct list_head entry;\n\tu16 saved_polarity_conf[DIV_ROUND_UP(MST_INTC_MAX_IRQS, 16)];\n#endif\n};\n\nstatic void mst_set_irq(struct irq_data *d, u32 offset)\n{\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tstruct mst_intc_chip_data *cd = irq_data_get_irq_chip_data(d);\n\tu16 val, mask;\n\tunsigned long flags;\n\n\tmask = 1 << (hwirq % 16);\n\toffset += (hwirq / 16) * 4;\n\n\traw_spin_lock_irqsave(&cd->lock, flags);\n\tval = readw_relaxed(cd->base + offset) | mask;\n\twritew_relaxed(val, cd->base + offset);\n\traw_spin_unlock_irqrestore(&cd->lock, flags);\n}\n\nstatic void mst_clear_irq(struct irq_data *d, u32 offset)\n{\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tstruct mst_intc_chip_data *cd = irq_data_get_irq_chip_data(d);\n\tu16 val, mask;\n\tunsigned long flags;\n\n\tmask = 1 << (hwirq % 16);\n\toffset += (hwirq / 16) * 4;\n\n\traw_spin_lock_irqsave(&cd->lock, flags);\n\tval = readw_relaxed(cd->base + offset) & ~mask;\n\twritew_relaxed(val, cd->base + offset);\n\traw_spin_unlock_irqrestore(&cd->lock, flags);\n}\n\nstatic void mst_intc_mask_irq(struct irq_data *d)\n{\n\tmst_set_irq(d, INTC_MASK);\n\tirq_chip_mask_parent(d);\n}\n\nstatic void mst_intc_unmask_irq(struct irq_data *d)\n{\n\tmst_clear_irq(d, INTC_MASK);\n\tirq_chip_unmask_parent(d);\n}\n\nstatic void mst_intc_eoi_irq(struct irq_data *d)\n{\n\tstruct mst_intc_chip_data *cd = irq_data_get_irq_chip_data(d);\n\n\tif (!cd->no_eoi)\n\t\tmst_set_irq(d, INTC_EOI);\n\n\tirq_chip_eoi_parent(d);\n}\n\nstatic int mst_irq_chip_set_type(struct irq_data *data, unsigned int type)\n{\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_LOW:\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tmst_set_irq(data, INTC_REV_POLARITY);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tmst_clear_irq(data, INTC_REV_POLARITY);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn irq_chip_set_type_parent(data, IRQ_TYPE_LEVEL_HIGH);\n}\n\nstatic struct irq_chip mst_intc_chip = {\n\t.name\t\t\t= \"mst-intc\",\n\t.irq_mask\t\t= mst_intc_mask_irq,\n\t.irq_unmask\t\t= mst_intc_unmask_irq,\n\t.irq_eoi\t\t= mst_intc_eoi_irq,\n\t.irq_get_irqchip_state\t= irq_chip_get_parent_state,\n\t.irq_set_irqchip_state\t= irq_chip_set_parent_state,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.irq_set_vcpu_affinity\t= irq_chip_set_vcpu_affinity_parent,\n\t.irq_set_type\t\t= mst_irq_chip_set_type,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.flags\t\t\t= IRQCHIP_SET_TYPE_MASKED |\n\t\t\t\t  IRQCHIP_SKIP_SET_WAKE |\n\t\t\t\t  IRQCHIP_MASK_ON_SUSPEND,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic void mst_intc_polarity_save(struct mst_intc_chip_data *cd)\n{\n\tint i;\n\tvoid __iomem *addr = cd->base + INTC_REV_POLARITY;\n\n\tfor (i = 0; i < DIV_ROUND_UP(cd->nr_irqs, 16); i++)\n\t\tcd->saved_polarity_conf[i] = readw_relaxed(addr + i * 4);\n}\n\nstatic void mst_intc_polarity_restore(struct mst_intc_chip_data *cd)\n{\n\tint i;\n\tvoid __iomem *addr = cd->base + INTC_REV_POLARITY;\n\n\tfor (i = 0; i < DIV_ROUND_UP(cd->nr_irqs, 16); i++)\n\t\twritew_relaxed(cd->saved_polarity_conf[i], addr + i * 4);\n}\n\nstatic void mst_irq_resume(void)\n{\n\tstruct mst_intc_chip_data *cd;\n\n\tlist_for_each_entry(cd, &mst_intc_list, entry)\n\t\tmst_intc_polarity_restore(cd);\n}\n\nstatic int mst_irq_suspend(void)\n{\n\tstruct mst_intc_chip_data *cd;\n\n\tlist_for_each_entry(cd, &mst_intc_list, entry)\n\t\tmst_intc_polarity_save(cd);\n\treturn 0;\n}\n\nstatic struct syscore_ops mst_irq_syscore_ops = {\n\t.suspend\t= mst_irq_suspend,\n\t.resume\t\t= mst_irq_resume,\n};\n\nstatic int __init mst_irq_pm_init(void)\n{\n\tregister_syscore_ops(&mst_irq_syscore_ops);\n\treturn 0;\n}\nlate_initcall(mst_irq_pm_init);\n#endif\n\nstatic int mst_intc_domain_translate(struct irq_domain *d,\n\t\t\t\t     struct irq_fwspec *fwspec,\n\t\t\t\t     unsigned long *hwirq,\n\t\t\t\t     unsigned int *type)\n{\n\tstruct mst_intc_chip_data *cd = d->host_data;\n\n\tif (is_of_node(fwspec->fwnode)) {\n\t\tif (fwspec->param_count != 3)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (fwspec->param[0] != 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (fwspec->param[1] >= cd->nr_irqs)\n\t\t\treturn -EINVAL;\n\n\t\t*hwirq = fwspec->param[1];\n\t\t*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mst_intc_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs, void *data)\n{\n\tint i;\n\tirq_hw_number_t hwirq;\n\tstruct irq_fwspec parent_fwspec, *fwspec = data;\n\tstruct mst_intc_chip_data *cd = domain->host_data;\n\n\t \n\tif (fwspec->param_count != 3)\n\t\treturn -EINVAL;\n\n\t \n\tif (fwspec->param[0])\n\t\treturn -EINVAL;\n\n\thwirq = fwspec->param[1];\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\n\t\t\t\t\t      &mst_intc_chip,\n\t\t\t\t\t      domain->host_data);\n\n\tparent_fwspec = *fwspec;\n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\tparent_fwspec.param[1] = cd->irq_start + hwirq;\n\n\t \n\tparent_fwspec.param[2] = IRQ_TYPE_LEVEL_HIGH;\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &parent_fwspec);\n}\n\nstatic const struct irq_domain_ops mst_intc_domain_ops = {\n\t.translate\t= mst_intc_domain_translate,\n\t.alloc\t\t= mst_intc_domain_alloc,\n\t.free\t\t= irq_domain_free_irqs_common,\n};\n\nstatic int __init mst_intc_of_init(struct device_node *dn,\n\t\t\t\t   struct device_node *parent)\n{\n\tstruct irq_domain *domain, *domain_parent;\n\tstruct mst_intc_chip_data *cd;\n\tu32 irq_start, irq_end;\n\n\tdomain_parent = irq_find_host(parent);\n\tif (!domain_parent) {\n\t\tpr_err(\"mst-intc: interrupt-parent not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32_index(dn, \"mstar,irqs-map-range\", 0, &irq_start) ||\n\t    of_property_read_u32_index(dn, \"mstar,irqs-map-range\", 1, &irq_end))\n\t\treturn -EINVAL;\n\n\tcd = kzalloc(sizeof(*cd), GFP_KERNEL);\n\tif (!cd)\n\t\treturn -ENOMEM;\n\n\tcd->base = of_iomap(dn, 0);\n\tif (!cd->base) {\n\t\tkfree(cd);\n\t\treturn -ENOMEM;\n\t}\n\n\tcd->no_eoi = of_property_read_bool(dn, \"mstar,intc-no-eoi\");\n\traw_spin_lock_init(&cd->lock);\n\tcd->irq_start = irq_start;\n\tcd->nr_irqs = irq_end - irq_start + 1;\n\tdomain = irq_domain_add_hierarchy(domain_parent, 0, cd->nr_irqs, dn,\n\t\t\t\t\t  &mst_intc_domain_ops, cd);\n\tif (!domain) {\n\t\tiounmap(cd->base);\n\t\tkfree(cd);\n\t\treturn -ENOMEM;\n\t}\n\n#ifdef CONFIG_PM_SLEEP\n\tINIT_LIST_HEAD(&cd->entry);\n\tlist_add_tail(&cd->entry, &mst_intc_list);\n#endif\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(mst_intc, \"mstar,mst-intc\", mst_intc_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}