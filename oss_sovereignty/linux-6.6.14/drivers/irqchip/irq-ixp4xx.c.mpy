{
  "module_name": "irq-ixp4xx.c",
  "hash_id": "f371b879dca9089f5dab389f6b935996c514b19e10da1e5aeae495cb8c998dd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-ixp4xx.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/cpu.h>\n\n#include <asm/exception.h>\n#include <asm/mach/irq.h>\n\n#define IXP4XX_ICPR\t0x00  \n#define IXP4XX_ICMR\t0x04  \n#define IXP4XX_ICLR\t0x08  \n#define IXP4XX_ICIP\t0x0C  \n#define IXP4XX_ICFP\t0x10  \n#define IXP4XX_ICHR\t0x14  \n#define IXP4XX_ICIH\t0x18  \n#define IXP4XX_ICFH\t0x1C  \n\n \n#define\tIXP4XX_ICPR2\t0x20  \n#define\tIXP4XX_ICMR2\t0x24  \n#define\tIXP4XX_ICLR2\t0x28  \n#define IXP4XX_ICIP2\t0x2C  \n#define IXP4XX_ICFP2\t0x30  \n#define IXP4XX_ICEEN\t0x34  \n\n \nstruct ixp4xx_irq {\n\tvoid __iomem *irqbase;\n\tbool is_356;\n\tstruct irq_chip irqchip;\n\tstruct irq_domain *domain;\n};\n\n \nstatic struct ixp4xx_irq ixirq;\n\n \n#define IXP4XX_GPIO_CLK_0\t\t14\n#define IXP4XX_GPIO_CLK_1\t\t15\n\nstatic int ixp4xx_set_irq_type(struct irq_data *d, unsigned int type)\n{\n\t \n\tif (type != IRQ_TYPE_LEVEL_HIGH)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void ixp4xx_irq_mask(struct irq_data *d)\n{\n\tstruct ixp4xx_irq *ixi = irq_data_get_irq_chip_data(d);\n\tu32 val;\n\n\tif (ixi->is_356 && d->hwirq >= 32) {\n\t\tval = __raw_readl(ixi->irqbase + IXP4XX_ICMR2);\n\t\tval &= ~BIT(d->hwirq - 32);\n\t\t__raw_writel(val, ixi->irqbase + IXP4XX_ICMR2);\n\t} else {\n\t\tval = __raw_readl(ixi->irqbase + IXP4XX_ICMR);\n\t\tval &= ~BIT(d->hwirq);\n\t\t__raw_writel(val, ixi->irqbase + IXP4XX_ICMR);\n\t}\n}\n\n \nstatic void ixp4xx_irq_unmask(struct irq_data *d)\n{\n\tstruct ixp4xx_irq *ixi = irq_data_get_irq_chip_data(d);\n\tu32 val;\n\n\tif (ixi->is_356 && d->hwirq >= 32) {\n\t\tval = __raw_readl(ixi->irqbase + IXP4XX_ICMR2);\n\t\tval |= BIT(d->hwirq - 32);\n\t\t__raw_writel(val, ixi->irqbase + IXP4XX_ICMR2);\n\t} else {\n\t\tval = __raw_readl(ixi->irqbase + IXP4XX_ICMR);\n\t\tval |= BIT(d->hwirq);\n\t\t__raw_writel(val, ixi->irqbase + IXP4XX_ICMR);\n\t}\n}\n\nstatic asmlinkage void __exception_irq_entry\nixp4xx_handle_irq(struct pt_regs *regs)\n{\n\tstruct ixp4xx_irq *ixi = &ixirq;\n\tunsigned long status;\n\tint i;\n\n\tstatus = __raw_readl(ixi->irqbase + IXP4XX_ICIP);\n\tfor_each_set_bit(i, &status, 32)\n\t\tgeneric_handle_domain_irq(ixi->domain, i);\n\n\t \n\tif (ixi->is_356) {\n\t\tstatus = __raw_readl(ixi->irqbase + IXP4XX_ICIP2);\n\t\tfor_each_set_bit(i, &status, 32)\n\t\t\tgeneric_handle_domain_irq(ixi->domain, i + 32);\n\t}\n}\n\nstatic int ixp4xx_irq_domain_translate(struct irq_domain *domain,\n\t\t\t\t       struct irq_fwspec *fwspec,\n\t\t\t\t       unsigned long *hwirq,\n\t\t\t\t       unsigned int *type)\n{\n\t \n\tif (is_of_node(fwspec->fwnode) && fwspec->param_count == 2) {\n\t\t*hwirq = fwspec->param[0];\n\t\t*type = fwspec->param[1];\n\t\treturn 0;\n\t}\n\n\tif (is_fwnode_irqchip(fwspec->fwnode)) {\n\t\tif (fwspec->param_count != 2)\n\t\t\treturn -EINVAL;\n\t\t*hwirq = fwspec->param[0];\n\t\t*type = fwspec->param[1];\n\t\tWARN_ON(*type == IRQ_TYPE_NONE);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ixp4xx_irq_domain_alloc(struct irq_domain *d,\n\t\t\t\t   unsigned int irq, unsigned int nr_irqs,\n\t\t\t\t   void *data)\n{\n\tstruct ixp4xx_irq *ixi = d->host_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tstruct irq_fwspec *fwspec = data;\n\tint ret;\n\tint i;\n\n\tret = ixp4xx_irq_domain_translate(d, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\t \n\t\tirq_domain_set_info(d,\n\t\t\t\t    irq + i,\n\t\t\t\t    hwirq + i,\n\t\t\t\t    &ixi->irqchip,\n\t\t\t\t    ixi,\n\t\t\t\t    handle_level_irq,\n\t\t\t\t    NULL, NULL);\n\t\tirq_set_probe(irq + i);\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct irq_domain_ops ixp4xx_irqdomain_ops = {\n\t.translate = ixp4xx_irq_domain_translate,\n\t.alloc = ixp4xx_irq_domain_alloc,\n\t.free = irq_domain_free_irqs_common,\n};\n\n \nstatic int __init ixp4xx_irq_setup(struct ixp4xx_irq *ixi,\n\t\t\t\t   void __iomem *irqbase,\n\t\t\t\t   struct fwnode_handle *fwnode,\n\t\t\t\t   bool is_356)\n{\n\tint nr_irqs;\n\n\tixi->irqbase = irqbase;\n\tixi->is_356 = is_356;\n\n\t \n\t__raw_writel(0x0, ixi->irqbase + IXP4XX_ICLR);\n\n\t \n\t__raw_writel(0x0, ixi->irqbase + IXP4XX_ICMR);\n\n\tif (is_356) {\n\t\t \n\t\t__raw_writel(0x0, ixi->irqbase + IXP4XX_ICLR2);\n\n\t\t \n\t\t__raw_writel(0x0, ixi->irqbase + IXP4XX_ICMR2);\n\n\t\tnr_irqs = 64;\n\t} else {\n\t\tnr_irqs = 32;\n\t}\n\n\tixi->irqchip.name = \"IXP4xx\";\n\tixi->irqchip.irq_mask = ixp4xx_irq_mask;\n\tixi->irqchip.irq_unmask\t= ixp4xx_irq_unmask;\n\tixi->irqchip.irq_set_type = ixp4xx_set_irq_type;\n\n\tixi->domain = irq_domain_create_linear(fwnode, nr_irqs,\n\t\t\t\t\t       &ixp4xx_irqdomain_ops,\n\t\t\t\t\t       ixi);\n\tif (!ixi->domain) {\n\t\tpr_crit(\"IXP4XX: can not add primary irqdomain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tset_handle_irq(ixp4xx_handle_irq);\n\n\treturn 0;\n}\n\nstatic int __init ixp4xx_of_init_irq(struct device_node *np,\n\t\t\t\t     struct device_node *parent)\n{\n\tstruct ixp4xx_irq *ixi = &ixirq;\n\tvoid __iomem *base;\n\tstruct fwnode_handle *fwnode;\n\tbool is_356;\n\tint ret;\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_crit(\"IXP4XX: could not ioremap interrupt controller\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfwnode = of_node_to_fwnode(np);\n\n\t \n\tis_356 = of_device_is_compatible(np, \"intel,ixp43x-interrupt\") ||\n\t\tof_device_is_compatible(np, \"intel,ixp45x-interrupt\") ||\n\t\tof_device_is_compatible(np, \"intel,ixp46x-interrupt\");\n\n\tret = ixp4xx_irq_setup(ixi, base, fwnode, is_356);\n\tif (ret)\n\t\tpr_crit(\"IXP4XX: failed to set up irqchip\\n\");\n\n\treturn ret;\n}\nIRQCHIP_DECLARE(ixp42x, \"intel,ixp42x-interrupt\",\n\t\tixp4xx_of_init_irq);\nIRQCHIP_DECLARE(ixp43x, \"intel,ixp43x-interrupt\",\n\t\tixp4xx_of_init_irq);\nIRQCHIP_DECLARE(ixp45x, \"intel,ixp45x-interrupt\",\n\t\tixp4xx_of_init_irq);\nIRQCHIP_DECLARE(ixp46x, \"intel,ixp46x-interrupt\",\n\t\tixp4xx_of_init_irq);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}