{
  "module_name": "qcom-pdc.c",
  "hash_id": "509c2c15b3d8be09ce9f4b0061867f2297b94812489bd15ce1ad35f8437f4de5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/qcom-pdc.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/soc/qcom/irq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define PDC_MAX_GPIO_IRQS\t256\n\n \n#define IRQ_ENABLE_BANK\t\t0x10\n#define IRQ_i_CFG\t\t0x110\n\n \n#define IRQ_i_CFG_IRQ_ENABLE\t3\n\n#define IRQ_i_CFG_TYPE_MASK\tGENMASK(2, 0)\n\n#define PDC_VERSION_REG\t\t0x1000\n\n \n#define PDC_VERSION_3_2\t\t0x30200\n\nstruct pdc_pin_region {\n\tu32 pin_base;\n\tu32 parent_base;\n\tu32 cnt;\n};\n\n#define pin_to_hwirq(r, p)\t((r)->parent_base + (p) - (r)->pin_base)\n\nstatic DEFINE_RAW_SPINLOCK(pdc_lock);\nstatic void __iomem *pdc_base;\nstatic struct pdc_pin_region *pdc_region;\nstatic int pdc_region_cnt;\nstatic unsigned int pdc_version;\n\nstatic void pdc_reg_write(int reg, u32 i, u32 val)\n{\n\twritel_relaxed(val, pdc_base + reg + i * sizeof(u32));\n}\n\nstatic u32 pdc_reg_read(int reg, u32 i)\n{\n\treturn readl_relaxed(pdc_base + reg + i * sizeof(u32));\n}\n\nstatic void __pdc_enable_intr(int pin_out, bool on)\n{\n\tunsigned long enable;\n\n\tif (pdc_version < PDC_VERSION_3_2) {\n\t\tu32 index, mask;\n\n\t\tindex = pin_out / 32;\n\t\tmask = pin_out % 32;\n\n\t\tenable = pdc_reg_read(IRQ_ENABLE_BANK, index);\n\t\t__assign_bit(mask, &enable, on);\n\t\tpdc_reg_write(IRQ_ENABLE_BANK, index, enable);\n\t} else {\n\t\tenable = pdc_reg_read(IRQ_i_CFG, pin_out);\n\t\t__assign_bit(IRQ_i_CFG_IRQ_ENABLE, &enable, on);\n\t\tpdc_reg_write(IRQ_i_CFG, pin_out, enable);\n\t}\n}\n\nstatic void pdc_enable_intr(struct irq_data *d, bool on)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pdc_lock, flags);\n\t__pdc_enable_intr(d->hwirq, on);\n\traw_spin_unlock_irqrestore(&pdc_lock, flags);\n}\n\nstatic void qcom_pdc_gic_disable(struct irq_data *d)\n{\n\tpdc_enable_intr(d, false);\n\tirq_chip_disable_parent(d);\n}\n\nstatic void qcom_pdc_gic_enable(struct irq_data *d)\n{\n\tpdc_enable_intr(d, true);\n\tirq_chip_enable_parent(d);\n}\n\n \nenum pdc_irq_config_bits {\n\tPDC_LEVEL_LOW\t\t= 0b000,\n\tPDC_EDGE_FALLING\t= 0b010,\n\tPDC_LEVEL_HIGH\t\t= 0b100,\n\tPDC_EDGE_RISING\t\t= 0b110,\n\tPDC_EDGE_DUAL\t\t= 0b111,\n};\n\n \nstatic int qcom_pdc_gic_set_type(struct irq_data *d, unsigned int type)\n{\n\tenum pdc_irq_config_bits pdc_type;\n\tenum pdc_irq_config_bits old_pdc_type;\n\tint ret;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tpdc_type = PDC_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tpdc_type = PDC_EDGE_FALLING;\n\t\ttype = IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tpdc_type = PDC_EDGE_DUAL;\n\t\ttype = IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tpdc_type = PDC_LEVEL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tpdc_type = PDC_LEVEL_LOW;\n\t\ttype = IRQ_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\told_pdc_type = pdc_reg_read(IRQ_i_CFG, d->hwirq);\n\tpdc_type |= (old_pdc_type & ~IRQ_i_CFG_TYPE_MASK);\n\tpdc_reg_write(IRQ_i_CFG, d->hwirq, pdc_type);\n\n\tret = irq_chip_set_type_parent(d, type);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (old_pdc_type != pdc_type)\n\t\tirq_chip_set_parent_state(d, IRQCHIP_STATE_PENDING, false);\n\n\treturn 0;\n}\n\nstatic struct irq_chip qcom_pdc_gic_chip = {\n\t.name\t\t\t= \"PDC\",\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_disable\t\t= qcom_pdc_gic_disable,\n\t.irq_enable\t\t= qcom_pdc_gic_enable,\n\t.irq_get_irqchip_state\t= irq_chip_get_parent_state,\n\t.irq_set_irqchip_state\t= irq_chip_set_parent_state,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_set_type\t\t= qcom_pdc_gic_set_type,\n\t.flags\t\t\t= IRQCHIP_MASK_ON_SUSPEND |\n\t\t\t\t  IRQCHIP_SET_TYPE_MASKED |\n\t\t\t\t  IRQCHIP_SKIP_SET_WAKE |\n\t\t\t\t  IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND,\n\t.irq_set_vcpu_affinity\t= irq_chip_set_vcpu_affinity_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n};\n\nstatic struct pdc_pin_region *get_pin_region(int pin)\n{\n\tint i;\n\n\tfor (i = 0; i < pdc_region_cnt; i++) {\n\t\tif (pin >= pdc_region[i].pin_base &&\n\t\t    pin < pdc_region[i].pin_base + pdc_region[i].cnt)\n\t\t\treturn &pdc_region[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int qcom_pdc_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t  unsigned int nr_irqs, void *data)\n{\n\tstruct irq_fwspec *fwspec = data;\n\tstruct irq_fwspec parent_fwspec;\n\tstruct pdc_pin_region *region;\n\tirq_hw_number_t hwirq;\n\tunsigned int type;\n\tint ret;\n\n\tret = irq_domain_translate_twocell(domain, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hwirq == GPIO_NO_WAKE_IRQ)\n\t\treturn irq_domain_disconnect_hierarchy(domain, virq);\n\n\tret = irq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t\t    &qcom_pdc_gic_chip, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tregion = get_pin_region(hwirq);\n\tif (!region)\n\t\treturn irq_domain_disconnect_hierarchy(domain->parent, virq);\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\ttype = IRQ_TYPE_EDGE_RISING;\n\n\tif (type & IRQ_TYPE_LEVEL_MASK)\n\t\ttype = IRQ_TYPE_LEVEL_HIGH;\n\n\tparent_fwspec.fwnode      = domain->parent->fwnode;\n\tparent_fwspec.param_count = 3;\n\tparent_fwspec.param[0]    = 0;\n\tparent_fwspec.param[1]    = pin_to_hwirq(region, hwirq);\n\tparent_fwspec.param[2]    = type;\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs,\n\t\t\t\t\t    &parent_fwspec);\n}\n\nstatic const struct irq_domain_ops qcom_pdc_ops = {\n\t.translate\t= irq_domain_translate_twocell,\n\t.alloc\t\t= qcom_pdc_alloc,\n\t.free\t\t= irq_domain_free_irqs_common,\n};\n\nstatic int pdc_setup_pin_mapping(struct device_node *np)\n{\n\tint ret, n, i;\n\n\tn = of_property_count_elems_of_size(np, \"qcom,pdc-ranges\", sizeof(u32));\n\tif (n <= 0 || n % 3)\n\t\treturn -EINVAL;\n\n\tpdc_region_cnt = n / 3;\n\tpdc_region = kcalloc(pdc_region_cnt, sizeof(*pdc_region), GFP_KERNEL);\n\tif (!pdc_region) {\n\t\tpdc_region_cnt = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (n = 0; n < pdc_region_cnt; n++) {\n\t\tret = of_property_read_u32_index(np, \"qcom,pdc-ranges\",\n\t\t\t\t\t\t n * 3 + 0,\n\t\t\t\t\t\t &pdc_region[n].pin_base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = of_property_read_u32_index(np, \"qcom,pdc-ranges\",\n\t\t\t\t\t\t n * 3 + 1,\n\t\t\t\t\t\t &pdc_region[n].parent_base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = of_property_read_u32_index(np, \"qcom,pdc-ranges\",\n\t\t\t\t\t\t n * 3 + 2,\n\t\t\t\t\t\t &pdc_region[n].cnt);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < pdc_region[n].cnt; i++)\n\t\t\t__pdc_enable_intr(i + pdc_region[n].pin_base, 0);\n\t}\n\n\treturn 0;\n}\n\n#define QCOM_PDC_SIZE 0x30000\n\nstatic int qcom_pdc_init(struct device_node *node, struct device_node *parent)\n{\n\tstruct irq_domain *parent_domain, *pdc_domain;\n\tresource_size_t res_size;\n\tstruct resource res;\n\tint ret;\n\n\t \n\tif (of_address_to_resource(node, 0, &res))\n\t\treturn -EINVAL;\n\n\tres_size = max_t(resource_size_t, resource_size(&res), QCOM_PDC_SIZE);\n\tif (res_size > resource_size(&res))\n\t\tpr_warn(\"%pOF: invalid reg size, please fix DT\\n\", node);\n\n\tpdc_base = ioremap(res.start, res_size);\n\tif (!pdc_base) {\n\t\tpr_err(\"%pOF: unable to map PDC registers\\n\", node);\n\t\treturn -ENXIO;\n\t}\n\n\tpdc_version = pdc_reg_read(PDC_VERSION_REG, 0);\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tpr_err(\"%pOF: unable to find PDC's parent domain\\n\", node);\n\t\tret = -ENXIO;\n\t\tgoto fail;\n\t}\n\n\tret = pdc_setup_pin_mapping(node);\n\tif (ret) {\n\t\tpr_err(\"%pOF: failed to init PDC pin-hwirq mapping\\n\", node);\n\t\tgoto fail;\n\t}\n\n\tpdc_domain = irq_domain_create_hierarchy(parent_domain,\n\t\t\t\t\tIRQ_DOMAIN_FLAG_QCOM_PDC_WAKEUP,\n\t\t\t\t\tPDC_MAX_GPIO_IRQS,\n\t\t\t\t\tof_fwnode_handle(node),\n\t\t\t\t\t&qcom_pdc_ops, NULL);\n\tif (!pdc_domain) {\n\t\tpr_err(\"%pOF: PDC domain add failed\\n\", node);\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tirq_domain_update_bus_token(pdc_domain, DOMAIN_BUS_WAKEUP);\n\n\treturn 0;\n\nfail:\n\tkfree(pdc_region);\n\tiounmap(pdc_base);\n\treturn ret;\n}\n\nIRQCHIP_PLATFORM_DRIVER_BEGIN(qcom_pdc)\nIRQCHIP_MATCH(\"qcom,pdc\", qcom_pdc_init)\nIRQCHIP_PLATFORM_DRIVER_END(qcom_pdc)\nMODULE_DESCRIPTION(\"Qualcomm Technologies, Inc. Power Domain Controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}