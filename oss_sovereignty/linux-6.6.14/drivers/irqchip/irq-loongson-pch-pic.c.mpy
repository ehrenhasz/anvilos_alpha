{
  "module_name": "irq-loongson-pch-pic.c",
  "hash_id": "3606145ac0015973fdcbc1ef80b2a803225e02f5675d490bfb9b1d0785eb77fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-loongson-pch-pic.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"pch-pic: \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/syscore_ops.h>\n\n \n#define PCH_PIC_MASK\t\t0x20\n#define PCH_PIC_HTMSI_EN\t0x40\n#define PCH_PIC_EDGE\t\t0x60\n#define PCH_PIC_CLR\t\t0x80\n#define PCH_PIC_AUTO0\t\t0xc0\n#define PCH_PIC_AUTO1\t\t0xe0\n#define PCH_INT_ROUTE(irq)\t(0x100 + irq)\n#define PCH_INT_HTVEC(irq)\t(0x200 + irq)\n#define PCH_PIC_POL\t\t0x3e0\n\n#define PIC_COUNT_PER_REG\t32\n#define PIC_REG_COUNT\t\t2\n#define PIC_COUNT\t\t(PIC_COUNT_PER_REG * PIC_REG_COUNT)\n#define PIC_REG_IDX(irq_id)\t((irq_id) / PIC_COUNT_PER_REG)\n#define PIC_REG_BIT(irq_id)\t((irq_id) % PIC_COUNT_PER_REG)\n\nstatic int nr_pics;\n\nstruct pch_pic {\n\tvoid __iomem\t\t*base;\n\tstruct irq_domain\t*pic_domain;\n\tu32\t\t\tht_vec_base;\n\traw_spinlock_t\t\tpic_lock;\n\tu32\t\t\tvec_count;\n\tu32\t\t\tgsi_base;\n\tu32\t\t\tsaved_vec_en[PIC_REG_COUNT];\n\tu32\t\t\tsaved_vec_pol[PIC_REG_COUNT];\n\tu32\t\t\tsaved_vec_edge[PIC_REG_COUNT];\n};\n\nstatic struct pch_pic *pch_pic_priv[MAX_IO_PICS];\n\nstruct fwnode_handle *pch_pic_handle[MAX_IO_PICS];\n\nstatic void pch_pic_bitset(struct pch_pic *priv, int offset, int bit)\n{\n\tu32 reg;\n\tvoid __iomem *addr = priv->base + offset + PIC_REG_IDX(bit) * 4;\n\n\traw_spin_lock(&priv->pic_lock);\n\treg = readl(addr);\n\treg |= BIT(PIC_REG_BIT(bit));\n\twritel(reg, addr);\n\traw_spin_unlock(&priv->pic_lock);\n}\n\nstatic void pch_pic_bitclr(struct pch_pic *priv, int offset, int bit)\n{\n\tu32 reg;\n\tvoid __iomem *addr = priv->base + offset + PIC_REG_IDX(bit) * 4;\n\n\traw_spin_lock(&priv->pic_lock);\n\treg = readl(addr);\n\treg &= ~BIT(PIC_REG_BIT(bit));\n\twritel(reg, addr);\n\traw_spin_unlock(&priv->pic_lock);\n}\n\nstatic void pch_pic_mask_irq(struct irq_data *d)\n{\n\tstruct pch_pic *priv = irq_data_get_irq_chip_data(d);\n\n\tpch_pic_bitset(priv, PCH_PIC_MASK, d->hwirq);\n\tirq_chip_mask_parent(d);\n}\n\nstatic void pch_pic_unmask_irq(struct irq_data *d)\n{\n\tstruct pch_pic *priv = irq_data_get_irq_chip_data(d);\n\n\twritel(BIT(PIC_REG_BIT(d->hwirq)),\n\t\t\tpriv->base + PCH_PIC_CLR + PIC_REG_IDX(d->hwirq) * 4);\n\n\tirq_chip_unmask_parent(d);\n\tpch_pic_bitclr(priv, PCH_PIC_MASK, d->hwirq);\n}\n\nstatic int pch_pic_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct pch_pic *priv = irq_data_get_irq_chip_data(d);\n\tint ret = 0;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tpch_pic_bitset(priv, PCH_PIC_EDGE, d->hwirq);\n\t\tpch_pic_bitclr(priv, PCH_PIC_POL, d->hwirq);\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tpch_pic_bitset(priv, PCH_PIC_EDGE, d->hwirq);\n\t\tpch_pic_bitset(priv, PCH_PIC_POL, d->hwirq);\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tpch_pic_bitclr(priv, PCH_PIC_EDGE, d->hwirq);\n\t\tpch_pic_bitclr(priv, PCH_PIC_POL, d->hwirq);\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tpch_pic_bitclr(priv, PCH_PIC_EDGE, d->hwirq);\n\t\tpch_pic_bitset(priv, PCH_PIC_POL, d->hwirq);\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void pch_pic_ack_irq(struct irq_data *d)\n{\n\tunsigned int reg;\n\tstruct pch_pic *priv = irq_data_get_irq_chip_data(d);\n\n\treg = readl(priv->base + PCH_PIC_EDGE + PIC_REG_IDX(d->hwirq) * 4);\n\tif (reg & BIT(PIC_REG_BIT(d->hwirq))) {\n\t\twritel(BIT(PIC_REG_BIT(d->hwirq)),\n\t\t\tpriv->base + PCH_PIC_CLR + PIC_REG_IDX(d->hwirq) * 4);\n\t}\n\tirq_chip_ack_parent(d);\n}\n\nstatic struct irq_chip pch_pic_irq_chip = {\n\t.name\t\t\t= \"PCH PIC\",\n\t.irq_mask\t\t= pch_pic_mask_irq,\n\t.irq_unmask\t\t= pch_pic_unmask_irq,\n\t.irq_ack\t\t= pch_pic_ack_irq,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.irq_set_type\t\t= pch_pic_set_type,\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic int pch_pic_domain_translate(struct irq_domain *d,\n\t\t\t\t\tstruct irq_fwspec *fwspec,\n\t\t\t\t\tunsigned long *hwirq,\n\t\t\t\t\tunsigned int *type)\n{\n\tstruct pch_pic *priv = d->host_data;\n\tstruct device_node *of_node = to_of_node(fwspec->fwnode);\n\n\tif (of_node) {\n\t\tif (fwspec->param_count < 2)\n\t\t\treturn -EINVAL;\n\n\t\t*hwirq = fwspec->param[0];\n\t\t*type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\t} else {\n\t\tif (fwspec->param_count < 1)\n\t\t\treturn -EINVAL;\n\n\t\t*hwirq = fwspec->param[0] - priv->gsi_base;\n\t\tif (fwspec->param_count > 1)\n\t\t\t*type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\t\telse\n\t\t\t*type = IRQ_TYPE_NONE;\n\t}\n\n\treturn 0;\n}\n\nstatic int pch_pic_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs, void *arg)\n{\n\tint err;\n\tunsigned int type;\n\tunsigned long hwirq;\n\tstruct irq_fwspec *fwspec = arg;\n\tstruct irq_fwspec parent_fwspec;\n\tstruct pch_pic *priv = domain->host_data;\n\n\terr = pch_pic_domain_translate(domain, fwspec, &hwirq, &type);\n\tif (err)\n\t\treturn err;\n\n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\tparent_fwspec.param_count = 1;\n\tparent_fwspec.param[0] = hwirq + priv->ht_vec_base;\n\n\terr = irq_domain_alloc_irqs_parent(domain, virq, 1, &parent_fwspec);\n\tif (err)\n\t\treturn err;\n\n\tirq_domain_set_info(domain, virq, hwirq,\n\t\t\t    &pch_pic_irq_chip, priv,\n\t\t\t    handle_level_irq, NULL, NULL);\n\tirq_set_probe(virq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops pch_pic_domain_ops = {\n\t.translate\t= pch_pic_domain_translate,\n\t.alloc\t\t= pch_pic_alloc,\n\t.free\t\t= irq_domain_free_irqs_parent,\n};\n\nstatic void pch_pic_reset(struct pch_pic *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < PIC_COUNT; i++) {\n\t\t \n\t\twriteb(priv->ht_vec_base + i, priv->base + PCH_INT_HTVEC(i));\n\t\t \n\t\twriteb(1, priv->base + PCH_INT_ROUTE(i));\n\t}\n\n\tfor (i = 0; i < PIC_REG_COUNT; i++) {\n\t\t \n\t\twritel_relaxed(0xFFFFFFFF, priv->base + PCH_PIC_MASK + 4 * i);\n\t\twritel_relaxed(0xFFFFFFFF, priv->base + PCH_PIC_CLR + 4 * i);\n\t\t \n\t\twritel_relaxed(0, priv->base + PCH_PIC_AUTO0 + 4 * i);\n\t\twritel_relaxed(0, priv->base + PCH_PIC_AUTO1 + 4 * i);\n\t\t \n\t\twritel_relaxed(0xFFFFFFFF, priv->base + PCH_PIC_HTMSI_EN + 4 * i);\n\t}\n}\n\nstatic int pch_pic_suspend(void)\n{\n\tint i, j;\n\n\tfor (i = 0; i < nr_pics; i++) {\n\t\tfor (j = 0; j < PIC_REG_COUNT; j++) {\n\t\t\tpch_pic_priv[i]->saved_vec_pol[j] =\n\t\t\t\treadl(pch_pic_priv[i]->base + PCH_PIC_POL + 4 * j);\n\t\t\tpch_pic_priv[i]->saved_vec_edge[j] =\n\t\t\t\treadl(pch_pic_priv[i]->base + PCH_PIC_EDGE + 4 * j);\n\t\t\tpch_pic_priv[i]->saved_vec_en[j] =\n\t\t\t\treadl(pch_pic_priv[i]->base + PCH_PIC_MASK + 4 * j);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void pch_pic_resume(void)\n{\n\tint i, j;\n\n\tfor (i = 0; i < nr_pics; i++) {\n\t\tpch_pic_reset(pch_pic_priv[i]);\n\t\tfor (j = 0; j < PIC_REG_COUNT; j++) {\n\t\t\twritel(pch_pic_priv[i]->saved_vec_pol[j],\n\t\t\t\t\tpch_pic_priv[i]->base + PCH_PIC_POL + 4 * j);\n\t\t\twritel(pch_pic_priv[i]->saved_vec_edge[j],\n\t\t\t\t\tpch_pic_priv[i]->base + PCH_PIC_EDGE + 4 * j);\n\t\t\twritel(pch_pic_priv[i]->saved_vec_en[j],\n\t\t\t\t\tpch_pic_priv[i]->base + PCH_PIC_MASK + 4 * j);\n\t\t}\n\t}\n}\n\nstatic struct syscore_ops pch_pic_syscore_ops = {\n\t.suspend =  pch_pic_suspend,\n\t.resume =  pch_pic_resume,\n};\n\nstatic int pch_pic_init(phys_addr_t addr, unsigned long size, int vec_base,\n\t\t\tstruct irq_domain *parent_domain, struct fwnode_handle *domain_handle,\n\t\t\tu32 gsi_base)\n{\n\tstruct pch_pic *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_init(&priv->pic_lock);\n\tpriv->base = ioremap(addr, size);\n\tif (!priv->base)\n\t\tgoto free_priv;\n\n\tpriv->ht_vec_base = vec_base;\n\tpriv->vec_count = ((readq(priv->base) >> 48) & 0xff) + 1;\n\tpriv->gsi_base = gsi_base;\n\n\tpriv->pic_domain = irq_domain_create_hierarchy(parent_domain, 0,\n\t\t\t\t\t\tpriv->vec_count, domain_handle,\n\t\t\t\t\t\t&pch_pic_domain_ops, priv);\n\n\tif (!priv->pic_domain) {\n\t\tpr_err(\"Failed to create IRQ domain\\n\");\n\t\tgoto iounmap_base;\n\t}\n\n\tpch_pic_reset(priv);\n\tpch_pic_handle[nr_pics] = domain_handle;\n\tpch_pic_priv[nr_pics++] = priv;\n\n\tif (nr_pics == 1)\n\t\tregister_syscore_ops(&pch_pic_syscore_ops);\n\n\treturn 0;\n\niounmap_base:\n\tiounmap(priv->base);\nfree_priv:\n\tkfree(priv);\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_OF\n\nstatic int pch_pic_of_init(struct device_node *node,\n\t\t\t\tstruct device_node *parent)\n{\n\tint err, vec_base;\n\tstruct resource res;\n\tstruct irq_domain *parent_domain;\n\n\tif (of_address_to_resource(node, 0, &res))\n\t\treturn -EINVAL;\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tpr_err(\"Failed to find the parent domain\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(node, \"loongson,pic-base-vec\", &vec_base)) {\n\t\tpr_err(\"Failed to determine pic-base-vec\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = pch_pic_init(res.start, resource_size(&res), vec_base,\n\t\t\t\tparent_domain, of_node_to_fwnode(node), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(pch_pic, \"loongson,pch-pic-1.0\", pch_pic_of_init);\n\n#endif\n\n#ifdef CONFIG_ACPI\nint find_pch_pic(u32 gsi)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < MAX_IO_PICS; i++) {\n\t\tstruct pch_pic *priv = pch_pic_priv[i];\n\n\t\tif (!priv)\n\t\t\treturn -1;\n\n\t\tif (gsi >= priv->gsi_base && gsi < (priv->gsi_base + priv->vec_count))\n\t\t\treturn i;\n\t}\n\n\tpr_err(\"ERROR: Unable to locate PCH_PIC for GSI %d\\n\", gsi);\n\treturn -1;\n}\n\nstatic int __init pch_lpc_parse_madt(union acpi_subtable_headers *header,\n\t\t\t\t\tconst unsigned long end)\n{\n\tstruct acpi_madt_lpc_pic *pchlpc_entry = (struct acpi_madt_lpc_pic *)header;\n\n\treturn pch_lpc_acpi_init(pch_pic_priv[0]->pic_domain, pchlpc_entry);\n}\n\nstatic int __init acpi_cascade_irqdomain_init(void)\n{\n\tint r;\n\n\tr = acpi_table_parse_madt(ACPI_MADT_TYPE_LPC_PIC, pch_lpc_parse_madt, 0);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nint __init pch_pic_acpi_init(struct irq_domain *parent,\n\t\t\t\t\tstruct acpi_madt_bio_pic *acpi_pchpic)\n{\n\tint ret;\n\tstruct fwnode_handle *domain_handle;\n\n\tif (find_pch_pic(acpi_pchpic->gsi_base) >= 0)\n\t\treturn 0;\n\n\tdomain_handle = irq_domain_alloc_fwnode(&acpi_pchpic->address);\n\tif (!domain_handle) {\n\t\tpr_err(\"Unable to allocate domain handle\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = pch_pic_init(acpi_pchpic->address, acpi_pchpic->size,\n\t\t\t\t0, parent, domain_handle, acpi_pchpic->gsi_base);\n\n\tif (ret < 0) {\n\t\tirq_domain_free_fwnode(domain_handle);\n\t\treturn ret;\n\t}\n\n\tif (acpi_pchpic->id == 0)\n\t\tret = acpi_cascade_irqdomain_init();\n\n\treturn ret;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}