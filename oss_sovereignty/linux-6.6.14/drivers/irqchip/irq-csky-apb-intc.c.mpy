{
  "module_name": "irq-csky-apb-intc.c",
  "hash_id": "8f3c14732c47c0d4c16402551101162eac3f6baae0716a6f66bed2c7e93e192c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-csky-apb-intc.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <asm/irq.h>\n\n#define INTC_IRQS\t\t64\n\n#define CK_INTC_ICR\t\t0x00\n#define CK_INTC_PEN31_00\t0x14\n#define CK_INTC_PEN63_32\t0x2c\n#define CK_INTC_NEN31_00\t0x10\n#define CK_INTC_NEN63_32\t0x28\n#define CK_INTC_SOURCE\t\t0x40\n#define CK_INTC_DUAL_BASE\t0x100\n\n#define GX_INTC_PEN31_00\t0x00\n#define GX_INTC_PEN63_32\t0x04\n#define GX_INTC_NEN31_00\t0x40\n#define GX_INTC_NEN63_32\t0x44\n#define GX_INTC_NMASK31_00\t0x50\n#define GX_INTC_NMASK63_32\t0x54\n#define GX_INTC_SOURCE\t\t0x60\n\nstatic void __iomem *reg_base;\nstatic struct irq_domain *root_domain;\n\nstatic int nr_irq = INTC_IRQS;\n\n \nstatic void irq_ck_mask_set_bit(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tunsigned long ifr = ct->regs.mask - 8;\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\t*ct->mask_cache |= mask;\n\tirq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);\n\tirq_reg_writel(gc, irq_reg_readl(gc, ifr) & ~mask, ifr);\n\tirq_gc_unlock(gc);\n}\n\nstatic void __init ck_set_gc(struct device_node *node, void __iomem *reg_base,\n\t\t\t     u32 mask_reg, u32 irq_base)\n{\n\tstruct irq_chip_generic *gc;\n\n\tgc = irq_get_domain_generic_chip(root_domain, irq_base);\n\tgc->reg_base = reg_base;\n\tgc->chip_types[0].regs.mask = mask_reg;\n\tgc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit;\n\tgc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit;\n\n\tif (of_property_read_bool(node, \"csky,support-pulse-signal\"))\n\t\tgc->chip_types[0].chip.irq_unmask = irq_ck_mask_set_bit;\n}\n\nstatic inline u32 build_channel_val(u32 idx, u32 magic)\n{\n\tu32 res;\n\n\t \n\tres = idx | (idx << 8) | (idx << 16) | (idx << 24);\n\n\t \n\treturn res | magic;\n}\n\nstatic inline void setup_irq_channel(u32 magic, void __iomem *reg_addr)\n{\n\tu32 i;\n\n\t \n\tfor (i = 0; i < INTC_IRQS; i += 4)\n\t\twritel(build_channel_val(i, magic), reg_addr + i);\n}\n\nstatic int __init\nck_intc_init_comm(struct device_node *node, struct device_node *parent)\n{\n\tint ret;\n\n\tif (parent) {\n\t\tpr_err(\"C-SKY Intc not a root irq controller\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg_base = of_iomap(node, 0);\n\tif (!reg_base) {\n\t\tpr_err(\"C-SKY Intc unable to map: %p.\\n\", node);\n\t\treturn -EINVAL;\n\t}\n\n\troot_domain = irq_domain_add_linear(node, nr_irq,\n\t\t\t\t\t    &irq_generic_chip_ops, NULL);\n\tif (!root_domain) {\n\t\tpr_err(\"C-SKY Intc irq_domain_add failed.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(root_domain, 32, 1,\n\t\t\t\"csky_intc\", handle_level_irq,\n\t\t\tIRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN, 0, 0);\n\tif (ret) {\n\t\tpr_err(\"C-SKY Intc irq_alloc_gc failed.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool handle_irq_perbit(struct pt_regs *regs, u32 hwirq,\n\t\t\t\t     u32 irq_base)\n{\n\tif (hwirq == 0)\n\t\treturn false;\n\n\tgeneric_handle_domain_irq(root_domain, irq_base + __fls(hwirq));\n\n\treturn true;\n}\n\n \nstatic void gx_irq_handler(struct pt_regs *regs)\n{\n\tbool ret;\n\nretry:\n\tret = handle_irq_perbit(regs,\n\t\t\treadl(reg_base + GX_INTC_PEN63_32), 32);\n\tif (ret)\n\t\tgoto retry;\n\n\tret = handle_irq_perbit(regs,\n\t\t\treadl(reg_base + GX_INTC_PEN31_00), 0);\n\tif (ret)\n\t\tgoto retry;\n}\n\nstatic int __init\ngx_intc_init(struct device_node *node, struct device_node *parent)\n{\n\tint ret;\n\n\tret = ck_intc_init_comm(node, parent);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(0x0, reg_base + GX_INTC_NEN31_00);\n\twritel(0x0, reg_base + GX_INTC_NEN63_32);\n\n\t \n\twritel(0x0, reg_base + GX_INTC_NMASK31_00);\n\twritel(0x0, reg_base + GX_INTC_NMASK63_32);\n\n\tsetup_irq_channel(0x03020100, reg_base + GX_INTC_SOURCE);\n\n\tck_set_gc(node, reg_base, GX_INTC_NEN31_00, 0);\n\tck_set_gc(node, reg_base, GX_INTC_NEN63_32, 32);\n\n\tset_handle_irq(gx_irq_handler);\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(csky_gx6605s_intc, \"csky,gx6605s-intc\", gx_intc_init);\n\n \nstatic void ck_irq_handler(struct pt_regs *regs)\n{\n\tbool ret;\n\tvoid __iomem *reg_pen_lo = reg_base + CK_INTC_PEN31_00;\n\tvoid __iomem *reg_pen_hi = reg_base + CK_INTC_PEN63_32;\n\nretry:\n\t \n\tret = handle_irq_perbit(regs, readl(reg_pen_hi), 32);\n\tif (ret)\n\t\tgoto retry;\n\n\tret = handle_irq_perbit(regs, readl(reg_pen_lo), 0);\n\tif (ret)\n\t\tgoto retry;\n\n\tif (nr_irq == INTC_IRQS)\n\t\treturn;\n\n\t \n\tret = handle_irq_perbit(regs,\n\t\t\treadl(reg_pen_hi + CK_INTC_DUAL_BASE), 96);\n\tif (ret)\n\t\tgoto retry;\n\n\tret = handle_irq_perbit(regs,\n\t\t\treadl(reg_pen_lo + CK_INTC_DUAL_BASE), 64);\n\tif (ret)\n\t\tgoto retry;\n}\n\nstatic int __init\nck_intc_init(struct device_node *node, struct device_node *parent)\n{\n\tint ret;\n\n\tret = ck_intc_init_comm(node, parent);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(0, reg_base + CK_INTC_NEN31_00);\n\twritel(0, reg_base + CK_INTC_NEN63_32);\n\n\t \n\twritel(BIT(31), reg_base + CK_INTC_ICR);\n\n\tck_set_gc(node, reg_base, CK_INTC_NEN31_00, 0);\n\tck_set_gc(node, reg_base, CK_INTC_NEN63_32, 32);\n\n\tsetup_irq_channel(0x00010203, reg_base + CK_INTC_SOURCE);\n\n\tset_handle_irq(ck_irq_handler);\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(ck_intc, \"csky,apb-intc\", ck_intc_init);\n\nstatic int __init\nck_dual_intc_init(struct device_node *node, struct device_node *parent)\n{\n\tint ret;\n\n\t \n\tnr_irq = INTC_IRQS * 2;\n\n\tret = ck_intc_init(node, parent);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(0, reg_base + CK_INTC_NEN31_00 + CK_INTC_DUAL_BASE);\n\twritel(0, reg_base + CK_INTC_NEN63_32 + CK_INTC_DUAL_BASE);\n\n\tck_set_gc(node, reg_base + CK_INTC_DUAL_BASE, CK_INTC_NEN31_00, 64);\n\tck_set_gc(node, reg_base + CK_INTC_DUAL_BASE, CK_INTC_NEN63_32, 96);\n\n\tsetup_irq_channel(0x00010203,\n\t\t\t  reg_base + CK_INTC_SOURCE + CK_INTC_DUAL_BASE);\n\n\treturn 0;\n}\nIRQCHIP_DECLARE(ck_dual_intc, \"csky,dual-apb-intc\", ck_dual_intc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}