{
  "module_name": "irq-crossbar.c",
  "hash_id": "ce99879d2ff69b362f5e916ed0a5bb3da158a8f441b8e81311cf0b5f03f693ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-crossbar.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/slab.h>\n\n#define IRQ_FREE\t-1\n#define IRQ_RESERVED\t-2\n#define IRQ_SKIP\t-3\n#define GIC_IRQ_START\t32\n\n \nstruct crossbar_device {\n\traw_spinlock_t lock;\n\tuint int_max;\n\tuint safe_map;\n\tuint max_crossbar_sources;\n\tuint *irq_map;\n\tvoid __iomem *crossbar_base;\n\tint *register_offsets;\n\tvoid (*write)(int, int);\n};\n\nstatic struct crossbar_device *cb;\n\nstatic void crossbar_writel(int irq_no, int cb_no)\n{\n\twritel(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);\n}\n\nstatic void crossbar_writew(int irq_no, int cb_no)\n{\n\twritew(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);\n}\n\nstatic void crossbar_writeb(int irq_no, int cb_no)\n{\n\twriteb(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);\n}\n\nstatic struct irq_chip crossbar_chip = {\n\t.name\t\t\t= \"CBAR\",\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n\t.flags\t\t\t= IRQCHIP_MASK_ON_SUSPEND |\n\t\t\t\t  IRQCHIP_SKIP_SET_WAKE,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n#endif\n};\n\nstatic int allocate_gic_irq(struct irq_domain *domain, unsigned virq,\n\t\t\t    irq_hw_number_t hwirq)\n{\n\tstruct irq_fwspec fwspec;\n\tint i;\n\tint err;\n\n\tif (!irq_domain_get_of_node(domain->parent))\n\t\treturn -EINVAL;\n\n\traw_spin_lock(&cb->lock);\n\tfor (i = cb->int_max - 1; i >= 0; i--) {\n\t\tif (cb->irq_map[i] == IRQ_FREE) {\n\t\t\tcb->irq_map[i] = hwirq;\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock(&cb->lock);\n\n\tif (i < 0)\n\t\treturn -ENODEV;\n\n\tfwspec.fwnode = domain->parent->fwnode;\n\tfwspec.param_count = 3;\n\tfwspec.param[0] = 0;\t \n\tfwspec.param[1] = i;\n\tfwspec.param[2] = IRQ_TYPE_LEVEL_HIGH;\n\n\terr = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\n\tif (err)\n\t\tcb->irq_map[i] = IRQ_FREE;\n\telse\n\t\tcb->write(i, hwirq);\n\n\treturn err;\n}\n\nstatic int crossbar_domain_alloc(struct irq_domain *d, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs, void *data)\n{\n\tstruct irq_fwspec *fwspec = data;\n\tirq_hw_number_t hwirq;\n\tint i;\n\n\tif (fwspec->param_count != 3)\n\t\treturn -EINVAL;\t \n\tif (fwspec->param[0] != 0)\n\t\treturn -EINVAL;\t \n\n\thwirq = fwspec->param[1];\n\tif ((hwirq + nr_irqs) > cb->max_crossbar_sources)\n\t\treturn -EINVAL;\t \n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tint err = allocate_gic_irq(d, virq + i, hwirq + i);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tirq_domain_set_hwirq_and_chip(d, virq + i, hwirq + i,\n\t\t\t\t\t      &crossbar_chip, NULL);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void crossbar_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tint i;\n\n\traw_spin_lock(&cb->lock);\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq + i);\n\n\t\tirq_domain_reset_irq_data(d);\n\t\tcb->irq_map[d->hwirq] = IRQ_FREE;\n\t\tcb->write(d->hwirq, cb->safe_map);\n\t}\n\traw_spin_unlock(&cb->lock);\n}\n\nstatic int crossbar_domain_translate(struct irq_domain *d,\n\t\t\t\t     struct irq_fwspec *fwspec,\n\t\t\t\t     unsigned long *hwirq,\n\t\t\t\t     unsigned int *type)\n{\n\tif (is_of_node(fwspec->fwnode)) {\n\t\tif (fwspec->param_count != 3)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (fwspec->param[0] != 0)\n\t\t\treturn -EINVAL;\n\n\t\t*hwirq = fwspec->param[1];\n\t\t*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct irq_domain_ops crossbar_domain_ops = {\n\t.alloc\t\t= crossbar_domain_alloc,\n\t.free\t\t= crossbar_domain_free,\n\t.translate\t= crossbar_domain_translate,\n};\n\nstatic int __init crossbar_of_init(struct device_node *node)\n{\n\tu32 max = 0, entry, reg_size;\n\tint i, size, reserved = 0;\n\tconst __be32 *irqsr;\n\tint ret = -ENOMEM;\n\n\tcb = kzalloc(sizeof(*cb), GFP_KERNEL);\n\n\tif (!cb)\n\t\treturn ret;\n\n\tcb->crossbar_base = of_iomap(node, 0);\n\tif (!cb->crossbar_base)\n\t\tgoto err_cb;\n\n\tof_property_read_u32(node, \"ti,max-crossbar-sources\",\n\t\t\t     &cb->max_crossbar_sources);\n\tif (!cb->max_crossbar_sources) {\n\t\tpr_err(\"missing 'ti,max-crossbar-sources' property\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_base;\n\t}\n\n\tof_property_read_u32(node, \"ti,max-irqs\", &max);\n\tif (!max) {\n\t\tpr_err(\"missing 'ti,max-irqs' property\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_base;\n\t}\n\tcb->irq_map = kcalloc(max, sizeof(int), GFP_KERNEL);\n\tif (!cb->irq_map)\n\t\tgoto err_base;\n\n\tcb->int_max = max;\n\n\tfor (i = 0; i < max; i++)\n\t\tcb->irq_map[i] = IRQ_FREE;\n\n\t \n\tirqsr = of_get_property(node, \"ti,irqs-reserved\", &size);\n\tif (irqsr) {\n\t\tsize /= sizeof(__be32);\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tof_property_read_u32_index(node,\n\t\t\t\t\t\t   \"ti,irqs-reserved\",\n\t\t\t\t\t\t   i, &entry);\n\t\t\tif (entry >= max) {\n\t\t\t\tpr_err(\"Invalid reserved entry\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_irq_map;\n\t\t\t}\n\t\t\tcb->irq_map[entry] = IRQ_RESERVED;\n\t\t}\n\t}\n\n\t \n\tirqsr = of_get_property(node, \"ti,irqs-skip\", &size);\n\tif (irqsr) {\n\t\tsize /= sizeof(__be32);\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tof_property_read_u32_index(node,\n\t\t\t\t\t\t   \"ti,irqs-skip\",\n\t\t\t\t\t\t   i, &entry);\n\t\t\tif (entry >= max) {\n\t\t\t\tpr_err(\"Invalid skip entry\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_irq_map;\n\t\t\t}\n\t\t\tcb->irq_map[entry] = IRQ_SKIP;\n\t\t}\n\t}\n\n\n\tcb->register_offsets = kcalloc(max, sizeof(int), GFP_KERNEL);\n\tif (!cb->register_offsets)\n\t\tgoto err_irq_map;\n\n\tof_property_read_u32(node, \"ti,reg-size\", &reg_size);\n\n\tswitch (reg_size) {\n\tcase 1:\n\t\tcb->write = crossbar_writeb;\n\t\tbreak;\n\tcase 2:\n\t\tcb->write = crossbar_writew;\n\t\tbreak;\n\tcase 4:\n\t\tcb->write = crossbar_writel;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid reg-size property\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_reg_offset;\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0; i < max; i++) {\n\t\tif (cb->irq_map[i] == IRQ_RESERVED)\n\t\t\tcontinue;\n\n\t\tcb->register_offsets[i] = reserved;\n\t\treserved += reg_size;\n\t}\n\n\tof_property_read_u32(node, \"ti,irqs-safe-map\", &cb->safe_map);\n\t \n\tfor (i = 0; i < max; i++) {\n\t\tif (cb->irq_map[i] == IRQ_RESERVED ||\n\t\t    cb->irq_map[i] == IRQ_SKIP)\n\t\t\tcontinue;\n\n\t\tcb->write(i, cb->safe_map);\n\t}\n\n\traw_spin_lock_init(&cb->lock);\n\n\treturn 0;\n\nerr_reg_offset:\n\tkfree(cb->register_offsets);\nerr_irq_map:\n\tkfree(cb->irq_map);\nerr_base:\n\tiounmap(cb->crossbar_base);\nerr_cb:\n\tkfree(cb);\n\n\tcb = NULL;\n\treturn ret;\n}\n\nstatic int __init irqcrossbar_init(struct device_node *node,\n\t\t\t\t   struct device_node *parent)\n{\n\tstruct irq_domain *parent_domain, *domain;\n\tint err;\n\n\tif (!parent) {\n\t\tpr_err(\"%pOF: no parent, giving up\\n\", node);\n\t\treturn -ENODEV;\n\t}\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tpr_err(\"%pOF: unable to obtain parent domain\\n\", node);\n\t\treturn -ENXIO;\n\t}\n\n\terr = crossbar_of_init(node);\n\tif (err)\n\t\treturn err;\n\n\tdomain = irq_domain_add_hierarchy(parent_domain, 0,\n\t\t\t\t\t  cb->max_crossbar_sources,\n\t\t\t\t\t  node, &crossbar_domain_ops,\n\t\t\t\t\t  NULL);\n\tif (!domain) {\n\t\tpr_err(\"%pOF: failed to allocated domain\\n\", node);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(ti_irqcrossbar, \"ti,irq-crossbar\", irqcrossbar_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}