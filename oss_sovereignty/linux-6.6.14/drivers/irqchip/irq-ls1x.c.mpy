{
  "module_name": "irq-ls1x.c",
  "hash_id": "091f9e125c75e4fbe6bc0d2b4a8dcd050aa5c069d6a5e7a3fee5ae08943421b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-ls1x.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/irqchip.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/io.h>\n#include <linux/irqchip/chained_irq.h>\n\n#define LS_REG_INTC_STATUS\t0x00\n#define LS_REG_INTC_EN\t0x04\n#define LS_REG_INTC_SET\t0x08\n#define LS_REG_INTC_CLR\t0x0c\n#define LS_REG_INTC_POL\t0x10\n#define LS_REG_INTC_EDGE\t0x14\n\n \n\nstruct ls1x_intc_priv {\n\tstruct irq_domain\t*domain;\n\tvoid __iomem\t\t*intc_base;\n};\n\n\nstatic void ls1x_chained_handle_irq(struct irq_desc *desc)\n{\n\tstruct ls1x_intc_priv *priv = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tu32 pending;\n\n\tchained_irq_enter(chip, desc);\n\tpending = readl(priv->intc_base + LS_REG_INTC_STATUS) &\n\t\t\treadl(priv->intc_base + LS_REG_INTC_EN);\n\n\tif (!pending)\n\t\tspurious_interrupt();\n\n\twhile (pending) {\n\t\tint bit = __ffs(pending);\n\n\t\tgeneric_handle_domain_irq(priv->domain, bit);\n\t\tpending &= ~BIT(bit);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void ls_intc_set_bit(struct irq_chip_generic *gc,\n\t\t\t\t\t\t\tunsigned int offset,\n\t\t\t\t\t\t\tu32 mask, bool set)\n{\n\tif (set)\n\t\twritel(readl(gc->reg_base + offset) | mask,\n\t\tgc->reg_base + offset);\n\telse\n\t\twritel(readl(gc->reg_base + offset) & ~mask,\n\t\tgc->reg_base + offset);\n}\n\nstatic int ls_intc_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\n\tu32 mask = data->mask;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tls_intc_set_bit(gc, LS_REG_INTC_EDGE, mask, false);\n\t\tls_intc_set_bit(gc, LS_REG_INTC_POL, mask, true);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tls_intc_set_bit(gc, LS_REG_INTC_EDGE, mask, false);\n\t\tls_intc_set_bit(gc, LS_REG_INTC_POL, mask, false);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tls_intc_set_bit(gc, LS_REG_INTC_EDGE, mask, true);\n\t\tls_intc_set_bit(gc, LS_REG_INTC_POL, mask, true);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tls_intc_set_bit(gc, LS_REG_INTC_EDGE, mask, true);\n\t\tls_intc_set_bit(gc, LS_REG_INTC_POL, mask, false);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tirqd_set_trigger_type(data, type);\n\treturn irq_setup_alt_chip(data, type);\n}\n\n\nstatic int __init ls1x_intc_of_init(struct device_node *node,\n\t\t\t\t       struct device_node *parent)\n{\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\tstruct ls1x_intc_priv *priv;\n\tint parent_irq, err = 0;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->intc_base = of_iomap(node, 0);\n\tif (!priv->intc_base) {\n\t\terr = -ENODEV;\n\t\tgoto out_free_priv;\n\t}\n\n\tparent_irq = irq_of_parse_and_map(node, 0);\n\tif (!parent_irq) {\n\t\tpr_err(\"ls1x-irq: unable to get parent irq\\n\");\n\t\terr =  -ENODEV;\n\t\tgoto out_iounmap;\n\t}\n\n\t \n\tpriv->domain = irq_domain_add_linear(node, 32, &irq_generic_chip_ops,\n\t\t\t\t\t     NULL);\n\tif (!priv->domain) {\n\t\tpr_err(\"ls1x-irq: cannot add IRQ domain\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_iounmap;\n\t}\n\n\terr = irq_alloc_domain_generic_chips(priv->domain, 32, 2,\n\t\tnode->full_name, handle_level_irq,\n\t\tIRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN, 0,\n\t\tIRQ_GC_INIT_MASK_CACHE);\n\tif (err) {\n\t\tpr_err(\"ls1x-irq: unable to register IRQ domain\\n\");\n\t\tgoto out_free_domain;\n\t}\n\n\t \n\twritel(0x0, priv->intc_base + LS_REG_INTC_EN);\n\n\t \n\twritel(0xffffffff, priv->intc_base + LS_REG_INTC_CLR);\n\n\t \n\twritel(0xffffffff, priv->intc_base + LS_REG_INTC_POL);\n\n\tgc = irq_get_domain_generic_chip(priv->domain, 0);\n\n\tgc->reg_base = priv->intc_base;\n\n\tct = gc->chip_types;\n\tct[0].type = IRQ_TYPE_LEVEL_MASK;\n\tct[0].regs.mask = LS_REG_INTC_EN;\n\tct[0].regs.ack = LS_REG_INTC_CLR;\n\tct[0].chip.irq_unmask = irq_gc_mask_set_bit;\n\tct[0].chip.irq_mask = irq_gc_mask_clr_bit;\n\tct[0].chip.irq_ack = irq_gc_ack_set_bit;\n\tct[0].chip.irq_set_type = ls_intc_set_type;\n\tct[0].handler = handle_level_irq;\n\n\tct[1].type = IRQ_TYPE_EDGE_BOTH;\n\tct[1].regs.mask = LS_REG_INTC_EN;\n\tct[1].regs.ack = LS_REG_INTC_CLR;\n\tct[1].chip.irq_unmask = irq_gc_mask_set_bit;\n\tct[1].chip.irq_mask = irq_gc_mask_clr_bit;\n\tct[1].chip.irq_ack = irq_gc_ack_set_bit;\n\tct[1].chip.irq_set_type = ls_intc_set_type;\n\tct[1].handler = handle_edge_irq;\n\n\tirq_set_chained_handler_and_data(parent_irq,\n\t\tls1x_chained_handle_irq, priv);\n\n\treturn 0;\n\nout_free_domain:\n\tirq_domain_remove(priv->domain);\nout_iounmap:\n\tiounmap(priv->intc_base);\nout_free_priv:\n\tkfree(priv);\n\n\treturn err;\n}\n\nIRQCHIP_DECLARE(ls1x_intc, \"loongson,ls1x-intc\", ls1x_intc_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}