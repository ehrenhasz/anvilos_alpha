{
  "module_name": "irq-partition-percpu.c",
  "hash_id": "37ee47d620d9ccaedfbed8b52179bb6bed35d32573bc0c8c72406c3d353f2b7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-partition-percpu.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqchip/irq-partition-percpu.h>\n#include <linux/irqdomain.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\nstruct partition_desc {\n\tint\t\t\t\tnr_parts;\n\tstruct partition_affinity\t*parts;\n\tstruct irq_domain\t\t*domain;\n\tstruct irq_desc\t\t\t*chained_desc;\n\tunsigned long\t\t\t*bitmap;\n\tstruct irq_domain_ops\t\tops;\n};\n\nstatic bool partition_check_cpu(struct partition_desc *part,\n\t\t\t\tunsigned int cpu, unsigned int hwirq)\n{\n\treturn cpumask_test_cpu(cpu, &part->parts[hwirq].mask);\n}\n\nstatic void partition_irq_mask(struct irq_data *d)\n{\n\tstruct partition_desc *part = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip *chip = irq_desc_get_chip(part->chained_desc);\n\tstruct irq_data *data = irq_desc_get_irq_data(part->chained_desc);\n\n\tif (partition_check_cpu(part, smp_processor_id(), d->hwirq) &&\n\t    chip->irq_mask)\n\t\tchip->irq_mask(data);\n}\n\nstatic void partition_irq_unmask(struct irq_data *d)\n{\n\tstruct partition_desc *part = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip *chip = irq_desc_get_chip(part->chained_desc);\n\tstruct irq_data *data = irq_desc_get_irq_data(part->chained_desc);\n\n\tif (partition_check_cpu(part, smp_processor_id(), d->hwirq) &&\n\t    chip->irq_unmask)\n\t\tchip->irq_unmask(data);\n}\n\nstatic int partition_irq_set_irqchip_state(struct irq_data *d,\n\t\t\t\t\t   enum irqchip_irq_state which,\n\t\t\t\t\t   bool val)\n{\n\tstruct partition_desc *part = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip *chip = irq_desc_get_chip(part->chained_desc);\n\tstruct irq_data *data = irq_desc_get_irq_data(part->chained_desc);\n\n\tif (partition_check_cpu(part, smp_processor_id(), d->hwirq) &&\n\t    chip->irq_set_irqchip_state)\n\t\treturn chip->irq_set_irqchip_state(data, which, val);\n\n\treturn -EINVAL;\n}\n\nstatic int partition_irq_get_irqchip_state(struct irq_data *d,\n\t\t\t\t\t   enum irqchip_irq_state which,\n\t\t\t\t\t   bool *val)\n{\n\tstruct partition_desc *part = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip *chip = irq_desc_get_chip(part->chained_desc);\n\tstruct irq_data *data = irq_desc_get_irq_data(part->chained_desc);\n\n\tif (partition_check_cpu(part, smp_processor_id(), d->hwirq) &&\n\t    chip->irq_get_irqchip_state)\n\t\treturn chip->irq_get_irqchip_state(data, which, val);\n\n\treturn -EINVAL;\n}\n\nstatic int partition_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct partition_desc *part = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip *chip = irq_desc_get_chip(part->chained_desc);\n\tstruct irq_data *data = irq_desc_get_irq_data(part->chained_desc);\n\n\tif (chip->irq_set_type)\n\t\treturn chip->irq_set_type(data, type);\n\n\treturn -EINVAL;\n}\n\nstatic void partition_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct partition_desc *part = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip *chip = irq_desc_get_chip(part->chained_desc);\n\tstruct irq_data *data = irq_desc_get_irq_data(part->chained_desc);\n\n\tseq_printf(p, \" %5s-%lu\", chip->name, data->hwirq);\n}\n\nstatic struct irq_chip partition_irq_chip = {\n\t.irq_mask\t\t= partition_irq_mask,\n\t.irq_unmask\t\t= partition_irq_unmask,\n\t.irq_set_type\t\t= partition_irq_set_type,\n\t.irq_get_irqchip_state\t= partition_irq_get_irqchip_state,\n\t.irq_set_irqchip_state\t= partition_irq_set_irqchip_state,\n\t.irq_print_chip\t\t= partition_irq_print_chip,\n};\n\nstatic void partition_handle_irq(struct irq_desc *desc)\n{\n\tstruct partition_desc *part = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tint cpu = smp_processor_id();\n\tint hwirq;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor_each_set_bit(hwirq, part->bitmap, part->nr_parts) {\n\t\tif (partition_check_cpu(part, cpu, hwirq))\n\t\t\tbreak;\n\t}\n\n\tif (unlikely(hwirq == part->nr_parts))\n\t\thandle_bad_irq(desc);\n\telse\n\t\tgeneric_handle_domain_irq(part->domain, hwirq);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int partition_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  unsigned int nr_irqs, void *arg)\n{\n\tint ret;\n\tirq_hw_number_t hwirq;\n\tunsigned int type;\n\tstruct irq_fwspec *fwspec = arg;\n\tstruct partition_desc *part;\n\n\tBUG_ON(nr_irqs != 1);\n\tret = domain->ops->translate(domain, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tpart = domain->host_data;\n\n\tset_bit(hwirq, part->bitmap);\n\tirq_set_chained_handler_and_data(irq_desc_get_irq(part->chained_desc),\n\t\t\t\t\t partition_handle_irq, part);\n\tirq_set_percpu_devid_partition(virq, &part->parts[hwirq].mask);\n\tirq_domain_set_info(domain, virq, hwirq, &partition_irq_chip, part,\n\t\t\t    handle_percpu_devid_irq, NULL, NULL);\n\tirq_set_status_flags(virq, IRQ_NOAUTOEN);\n\n\treturn 0;\n}\n\nstatic void partition_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  unsigned int nr_irqs)\n{\n\tstruct irq_data *d;\n\n\tBUG_ON(nr_irqs != 1);\n\n\td = irq_domain_get_irq_data(domain, virq);\n\tirq_set_handler(virq, NULL);\n\tirq_domain_reset_irq_data(d);\n}\n\nint partition_translate_id(struct partition_desc *desc, void *partition_id)\n{\n\tstruct partition_affinity *part = NULL;\n\tint i;\n\n\tfor (i = 0; i < desc->nr_parts; i++) {\n\t\tif (desc->parts[i].partition_id == partition_id) {\n\t\t\tpart = &desc->parts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ON(!part)) {\n\t\tpr_err(\"Failed to find partition\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn i;\n}\n\nstruct partition_desc *partition_create_desc(struct fwnode_handle *fwnode,\n\t\t\t\t\t     struct partition_affinity *parts,\n\t\t\t\t\t     int nr_parts,\n\t\t\t\t\t     int chained_irq,\n\t\t\t\t\t     const struct irq_domain_ops *ops)\n{\n\tstruct partition_desc *desc;\n\tstruct irq_domain *d;\n\n\tBUG_ON(!ops->select || !ops->translate);\n\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->ops = *ops;\n\tdesc->ops.free = partition_domain_free;\n\tdesc->ops.alloc = partition_domain_alloc;\n\n\td = irq_domain_create_linear(fwnode, nr_parts, &desc->ops, desc);\n\tif (!d)\n\t\tgoto out;\n\tdesc->domain = d;\n\n\tdesc->bitmap = bitmap_zalloc(nr_parts, GFP_KERNEL);\n\tif (WARN_ON(!desc->bitmap))\n\t\tgoto out;\n\n\tdesc->chained_desc = irq_to_desc(chained_irq);\n\tdesc->nr_parts = nr_parts;\n\tdesc->parts = parts;\n\n\treturn desc;\nout:\n\tif (d)\n\t\tirq_domain_remove(d);\n\tkfree(desc);\n\n\treturn NULL;\n}\n\nstruct irq_domain *partition_get_domain(struct partition_desc *dsc)\n{\n\tif (dsc)\n\t\treturn dsc->domain;\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}