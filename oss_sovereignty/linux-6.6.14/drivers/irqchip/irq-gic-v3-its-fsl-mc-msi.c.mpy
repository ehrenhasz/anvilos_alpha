{
  "module_name": "irq-gic-v3-its-fsl-mc-msi.c",
  "hash_id": "db2fa60baa5260bc38b6d37edf3bbfffc69e67697d2a0fd0b7b7dbf3af2eee34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-gic-v3-its-fsl-mc-msi.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/acpi_iort.h>\n#include <linux/irq.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/fsl/mc.h>\n\nstatic struct irq_chip its_msi_irq_chip = {\n\t.name = \"ITS-fMSI\",\n\t.irq_mask = irq_chip_mask_parent,\n\t.irq_unmask = irq_chip_unmask_parent,\n\t.irq_eoi = irq_chip_eoi_parent,\n\t.irq_set_affinity = msi_domain_set_affinity\n};\n\nstatic u32 fsl_mc_msi_domain_get_msi_id(struct irq_domain *domain,\n\t\t\t\t\tstruct fsl_mc_device *mc_dev)\n{\n\tstruct device_node *of_node;\n\tu32 out_id;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tout_id = of_node ? of_msi_map_id(&mc_dev->dev, of_node, mc_dev->icid) :\n\t\t\tiort_msi_map_id(&mc_dev->dev, mc_dev->icid);\n\n\treturn out_id;\n}\n\nstatic int its_fsl_mc_msi_prepare(struct irq_domain *msi_domain,\n\t\t\t\t  struct device *dev,\n\t\t\t\t  int nvec, msi_alloc_info_t *info)\n{\n\tstruct fsl_mc_device *mc_bus_dev;\n\tstruct msi_domain_info *msi_info;\n\n\tif (!dev_is_fsl_mc(dev))\n\t\treturn -EINVAL;\n\n\tmc_bus_dev = to_fsl_mc_device(dev);\n\tif (!(mc_bus_dev->flags & FSL_MC_IS_DPRC))\n\t\treturn -EINVAL;\n\n\t \n\tinfo->scratchpad[0].ul = fsl_mc_msi_domain_get_msi_id(msi_domain,\n\t\t\t\t\t\t\t      mc_bus_dev);\n\tmsi_info = msi_get_domain_info(msi_domain->parent);\n\n\t \n\tnvec = max_t(int, 32, roundup_pow_of_two(nvec));\n\treturn msi_info->ops->msi_prepare(msi_domain->parent, dev, nvec, info);\n}\n\nstatic struct msi_domain_ops its_fsl_mc_msi_ops __ro_after_init = {\n\t.msi_prepare = its_fsl_mc_msi_prepare,\n};\n\nstatic struct msi_domain_info its_fsl_mc_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS),\n\t.ops\t= &its_fsl_mc_msi_ops,\n\t.chip\t= &its_msi_irq_chip,\n};\n\nstatic const struct of_device_id its_device_id[] = {\n\t{\t.compatible\t= \"arm,gic-v3-its\",\t},\n\t{},\n};\n\nstatic void __init its_fsl_mc_msi_init_one(struct fwnode_handle *handle,\n\t\t\t\t\t  const char *name)\n{\n\tstruct irq_domain *parent;\n\tstruct irq_domain *mc_msi_domain;\n\n\tparent = irq_find_matching_fwnode(handle, DOMAIN_BUS_NEXUS);\n\tif (!parent || !msi_get_domain_info(parent)) {\n\t\tpr_err(\"%s: unable to locate ITS domain\\n\", name);\n\t\treturn;\n\t}\n\n\tmc_msi_domain = fsl_mc_msi_create_irq_domain(handle,\n\t\t\t\t\t\t&its_fsl_mc_msi_domain_info,\n\t\t\t\t\t\tparent);\n\tif (!mc_msi_domain) {\n\t\tpr_err(\"%s: unable to create fsl-mc domain\\n\", name);\n\t\treturn;\n\t}\n\n\tpr_info(\"fsl-mc MSI: %s domain created\\n\", name);\n}\n\n#ifdef CONFIG_ACPI\nstatic int __init\nits_fsl_mc_msi_parse_madt(union acpi_subtable_headers *header,\n\t\t\t  const unsigned long end)\n{\n\tstruct acpi_madt_generic_translator *its_entry;\n\tstruct fwnode_handle *dom_handle;\n\tconst char *node_name;\n\tint err = 0;\n\n\tits_entry = (struct acpi_madt_generic_translator *)header;\n\tnode_name = kasprintf(GFP_KERNEL, \"ITS@0x%lx\",\n\t\t\t      (long)its_entry->base_address);\n\n\tdom_handle = iort_find_domain_token(its_entry->translation_id);\n\tif (!dom_handle) {\n\t\tpr_err(\"%s: Unable to locate ITS domain handle\\n\", node_name);\n\t\terr = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tits_fsl_mc_msi_init_one(dom_handle, node_name);\n\nout:\n\tkfree(node_name);\n\treturn err;\n}\n\n\nstatic void __init its_fsl_mc_acpi_msi_init(void)\n{\n\tacpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_TRANSLATOR,\n\t\t\t      its_fsl_mc_msi_parse_madt, 0);\n}\n#else\nstatic inline void its_fsl_mc_acpi_msi_init(void) { }\n#endif\n\nstatic void __init its_fsl_mc_of_msi_init(void)\n{\n\tstruct device_node *np;\n\n\tfor (np = of_find_matching_node(NULL, its_device_id); np;\n\t     np = of_find_matching_node(np, its_device_id)) {\n\t\tif (!of_device_is_available(np))\n\t\t\tcontinue;\n\t\tif (!of_property_read_bool(np, \"msi-controller\"))\n\t\t\tcontinue;\n\n\t\tits_fsl_mc_msi_init_one(of_node_to_fwnode(np),\n\t\t\t\t\tnp->full_name);\n\t}\n}\n\nstatic int __init its_fsl_mc_msi_init(void)\n{\n\tits_fsl_mc_of_msi_init();\n\tits_fsl_mc_acpi_msi_init();\n\n\treturn 0;\n}\n\nearly_initcall(its_fsl_mc_msi_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}