{
  "module_name": "irq-sun6i-r.c",
  "hash_id": "a6c3e00809ba9177bf842ff730105f79bee33ae89f169a1d7f6568d06e2c170f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-sun6i-r.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/syscore_ops.h>\n\n#include <dt-bindings/interrupt-controller/arm-gic.h>\n\n#define SUN6I_NMI_CTRL\t\t\t(0x0c)\n#define SUN6I_IRQ_PENDING(n)\t\t(0x10 + 4 * (n))\n#define SUN6I_IRQ_ENABLE(n)\t\t(0x40 + 4 * (n))\n#define SUN6I_MUX_ENABLE(n)\t\t(0xc0 + 4 * (n))\n\n#define SUN6I_NMI_SRC_TYPE_LEVEL_LOW\t0\n#define SUN6I_NMI_SRC_TYPE_EDGE_FALLING\t1\n#define SUN6I_NMI_SRC_TYPE_LEVEL_HIGH\t2\n#define SUN6I_NMI_SRC_TYPE_EDGE_RISING\t3\n\n#define SUN6I_NMI_BIT\t\t\tBIT(0)\n\n#define SUN6I_NMI_NEEDS_ACK\t\t((void *)1)\n\n#define SUN6I_NR_TOP_LEVEL_IRQS\t\t64\n#define SUN6I_NR_DIRECT_IRQS\t\t16\n#define SUN6I_NR_MUX_BITS\t\t128\n\nstruct sun6i_r_intc_variant {\n\tu32\t\tfirst_mux_irq;\n\tu32\t\tnr_mux_irqs;\n\tu32\t\tmux_valid[BITS_TO_U32(SUN6I_NR_MUX_BITS)];\n};\n\nstatic void __iomem *base;\nstatic irq_hw_number_t nmi_hwirq;\nstatic DECLARE_BITMAP(wake_irq_enabled, SUN6I_NR_TOP_LEVEL_IRQS);\nstatic DECLARE_BITMAP(wake_mux_enabled, SUN6I_NR_MUX_BITS);\nstatic DECLARE_BITMAP(wake_mux_valid, SUN6I_NR_MUX_BITS);\n\nstatic void sun6i_r_intc_ack_nmi(void)\n{\n\twritel_relaxed(SUN6I_NMI_BIT, base + SUN6I_IRQ_PENDING(0));\n}\n\nstatic void sun6i_r_intc_nmi_ack(struct irq_data *data)\n{\n\tif (irqd_get_trigger_type(data) & IRQ_TYPE_EDGE_BOTH)\n\t\tsun6i_r_intc_ack_nmi();\n\telse\n\t\tdata->chip_data = SUN6I_NMI_NEEDS_ACK;\n}\n\nstatic void sun6i_r_intc_nmi_eoi(struct irq_data *data)\n{\n\t \n\tif (data->chip_data == SUN6I_NMI_NEEDS_ACK && !irqd_irq_masked(data)) {\n\t\tdata->chip_data = NULL;\n\t\tsun6i_r_intc_ack_nmi();\n\t}\n\n\tirq_chip_eoi_parent(data);\n}\n\nstatic void sun6i_r_intc_nmi_unmask(struct irq_data *data)\n{\n\tif (data->chip_data == SUN6I_NMI_NEEDS_ACK) {\n\t\tdata->chip_data = NULL;\n\t\tsun6i_r_intc_ack_nmi();\n\t}\n\n\tirq_chip_unmask_parent(data);\n}\n\nstatic int sun6i_r_intc_nmi_set_type(struct irq_data *data, unsigned int type)\n{\n\tu32 nmi_src_type;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tnmi_src_type = SUN6I_NMI_SRC_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tnmi_src_type = SUN6I_NMI_SRC_TYPE_EDGE_FALLING;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tnmi_src_type = SUN6I_NMI_SRC_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tnmi_src_type = SUN6I_NMI_SRC_TYPE_LEVEL_LOW;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twritel_relaxed(nmi_src_type, base + SUN6I_NMI_CTRL);\n\n\t \n\treturn irq_chip_set_type_parent(data, IRQ_TYPE_LEVEL_HIGH);\n}\n\nstatic int sun6i_r_intc_nmi_set_irqchip_state(struct irq_data *data,\n\t\t\t\t\t      enum irqchip_irq_state which,\n\t\t\t\t\t      bool state)\n{\n\tif (which == IRQCHIP_STATE_PENDING && !state)\n\t\tsun6i_r_intc_ack_nmi();\n\n\treturn irq_chip_set_parent_state(data, which, state);\n}\n\nstatic int sun6i_r_intc_irq_set_wake(struct irq_data *data, unsigned int on)\n{\n\tunsigned long offset_from_nmi = data->hwirq - nmi_hwirq;\n\n\tif (offset_from_nmi < SUN6I_NR_DIRECT_IRQS)\n\t\tassign_bit(offset_from_nmi, wake_irq_enabled, on);\n\telse if (test_bit(data->hwirq, wake_mux_valid))\n\t\tassign_bit(data->hwirq, wake_mux_enabled, on);\n\telse\n\t\t \n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic struct irq_chip sun6i_r_intc_nmi_chip = {\n\t.name\t\t\t= \"sun6i-r-intc\",\n\t.irq_ack\t\t= sun6i_r_intc_nmi_ack,\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= sun6i_r_intc_nmi_unmask,\n\t.irq_eoi\t\t= sun6i_r_intc_nmi_eoi,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.irq_set_type\t\t= sun6i_r_intc_nmi_set_type,\n\t.irq_set_irqchip_state\t= sun6i_r_intc_nmi_set_irqchip_state,\n\t.irq_set_wake\t\t= sun6i_r_intc_irq_set_wake,\n\t.flags\t\t\t= IRQCHIP_SET_TYPE_MASKED,\n};\n\nstatic struct irq_chip sun6i_r_intc_wakeup_chip = {\n\t.name\t\t\t= \"sun6i-r-intc\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n\t.irq_set_wake\t\t= sun6i_r_intc_irq_set_wake,\n\t.flags\t\t\t= IRQCHIP_SET_TYPE_MASKED,\n};\n\nstatic int sun6i_r_intc_domain_translate(struct irq_domain *domain,\n\t\t\t\t\t struct irq_fwspec *fwspec,\n\t\t\t\t\t unsigned long *hwirq,\n\t\t\t\t\t unsigned int *type)\n{\n\t \n\tif (fwspec->param_count == 2 && fwspec->param[0] == 0) {\n\t\t*hwirq = nmi_hwirq;\n\t\t*type  = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\t\treturn 0;\n\t}\n\n\t \n\tif (fwspec->param_count < 3)\n\t\treturn -EINVAL;\n\tif (fwspec->param[0] != GIC_SPI)\n\t\treturn -EINVAL;\n\n\t*hwirq = fwspec->param[1];\n\t*type  = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;\n\n\treturn 0;\n}\n\nstatic int sun6i_r_intc_domain_alloc(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq,\n\t\t\t\t     unsigned int nr_irqs, void *arg)\n{\n\tstruct irq_fwspec *fwspec = arg;\n\tstruct irq_fwspec gic_fwspec;\n\tunsigned long hwirq;\n\tunsigned int type;\n\tint i, ret;\n\n\tret = sun6i_r_intc_domain_translate(domain, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\tif (hwirq + nr_irqs > SUN6I_NR_MUX_BITS)\n\t\treturn -EINVAL;\n\n\t \n\tgic_fwspec = (struct irq_fwspec) {\n\t\t.fwnode      = domain->parent->fwnode,\n\t\t.param_count = 3,\n\t\t.param       = { GIC_SPI, hwirq, type },\n\t};\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &gic_fwspec);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; ++i, ++hwirq, ++virq) {\n\t\tif (hwirq == nmi_hwirq) {\n\t\t\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t\t\t      &sun6i_r_intc_nmi_chip,\n\t\t\t\t\t\t      NULL);\n\t\t\tirq_set_handler(virq, handle_fasteoi_ack_irq);\n\t\t} else {\n\t\t\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t\t\t      &sun6i_r_intc_wakeup_chip,\n\t\t\t\t\t\t      NULL);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops sun6i_r_intc_domain_ops = {\n\t.translate\t= sun6i_r_intc_domain_translate,\n\t.alloc\t\t= sun6i_r_intc_domain_alloc,\n\t.free\t\t= irq_domain_free_irqs_common,\n};\n\nstatic int sun6i_r_intc_suspend(void)\n{\n\tu32 buf[BITS_TO_U32(max(SUN6I_NR_TOP_LEVEL_IRQS, SUN6I_NR_MUX_BITS))];\n\tint i;\n\n\t \n\tbitmap_to_arr32(buf, wake_irq_enabled, SUN6I_NR_TOP_LEVEL_IRQS);\n\tfor (i = 0; i < BITS_TO_U32(SUN6I_NR_TOP_LEVEL_IRQS); ++i)\n\t\twritel_relaxed(buf[i], base + SUN6I_IRQ_ENABLE(i));\n\tbitmap_to_arr32(buf, wake_mux_enabled, SUN6I_NR_MUX_BITS);\n\tfor (i = 0; i < BITS_TO_U32(SUN6I_NR_MUX_BITS); ++i)\n\t\twritel_relaxed(buf[i], base + SUN6I_MUX_ENABLE(i));\n\n\treturn 0;\n}\n\nstatic void sun6i_r_intc_resume(void)\n{\n\tint i;\n\n\t \n\twritel_relaxed(SUN6I_NMI_BIT, base + SUN6I_IRQ_ENABLE(0));\n\tfor (i = 1; i < BITS_TO_U32(SUN6I_NR_TOP_LEVEL_IRQS); ++i)\n\t\twritel_relaxed(0, base + SUN6I_IRQ_ENABLE(i));\n}\n\nstatic void sun6i_r_intc_shutdown(void)\n{\n\tsun6i_r_intc_suspend();\n}\n\nstatic struct syscore_ops sun6i_r_intc_syscore_ops = {\n\t.suspend\t= sun6i_r_intc_suspend,\n\t.resume\t\t= sun6i_r_intc_resume,\n\t.shutdown\t= sun6i_r_intc_shutdown,\n};\n\nstatic int __init sun6i_r_intc_init(struct device_node *node,\n\t\t\t\t    struct device_node *parent,\n\t\t\t\t    const struct sun6i_r_intc_variant *v)\n{\n\tstruct irq_domain *domain, *parent_domain;\n\tstruct of_phandle_args nmi_parent;\n\tint ret;\n\n\t \n\tret = of_irq_parse_one(node, 0, &nmi_parent);\n\tif (ret)\n\t\treturn ret;\n\tif (nmi_parent.args_count < 3 ||\n\t    nmi_parent.args[0] != GIC_SPI ||\n\t    nmi_parent.args[2] != IRQ_TYPE_LEVEL_HIGH)\n\t\treturn -EINVAL;\n\tnmi_hwirq = nmi_parent.args[1];\n\n\tbitmap_set(wake_irq_enabled, v->first_mux_irq, v->nr_mux_irqs);\n\tbitmap_from_arr32(wake_mux_valid, v->mux_valid, SUN6I_NR_MUX_BITS);\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tpr_err(\"%pOF: Failed to obtain parent domain\\n\", node);\n\t\treturn -ENXIO;\n\t}\n\n\tbase = of_io_request_and_map(node, 0, NULL);\n\tif (IS_ERR(base)) {\n\t\tpr_err(\"%pOF: Failed to map MMIO region\\n\", node);\n\t\treturn PTR_ERR(base);\n\t}\n\n\tdomain = irq_domain_add_hierarchy(parent_domain, 0, 0, node,\n\t\t\t\t\t  &sun6i_r_intc_domain_ops, NULL);\n\tif (!domain) {\n\t\tpr_err(\"%pOF: Failed to allocate domain\\n\", node);\n\t\tiounmap(base);\n\t\treturn -ENOMEM;\n\t}\n\n\tregister_syscore_ops(&sun6i_r_intc_syscore_ops);\n\n\tsun6i_r_intc_ack_nmi();\n\tsun6i_r_intc_resume();\n\n\treturn 0;\n}\n\nstatic const struct sun6i_r_intc_variant sun6i_a31_r_intc_variant __initconst = {\n\t.first_mux_irq\t= 19,\n\t.nr_mux_irqs\t= 13,\n\t.mux_valid\t= { 0xffffffff, 0xfff80000, 0xffffffff, 0x0000000f },\n};\n\nstatic int __init sun6i_a31_r_intc_init(struct device_node *node,\n\t\t\t\t\tstruct device_node *parent)\n{\n\treturn sun6i_r_intc_init(node, parent, &sun6i_a31_r_intc_variant);\n}\nIRQCHIP_DECLARE(sun6i_a31_r_intc, \"allwinner,sun6i-a31-r-intc\", sun6i_a31_r_intc_init);\n\nstatic const struct sun6i_r_intc_variant sun50i_h6_r_intc_variant __initconst = {\n\t.first_mux_irq\t= 21,\n\t.nr_mux_irqs\t= 16,\n\t.mux_valid\t= { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff },\n};\n\nstatic int __init sun50i_h6_r_intc_init(struct device_node *node,\n\t\t\t\t\tstruct device_node *parent)\n{\n\treturn sun6i_r_intc_init(node, parent, &sun50i_h6_r_intc_variant);\n}\nIRQCHIP_DECLARE(sun50i_h6_r_intc, \"allwinner,sun50i-h6-r-intc\", sun50i_h6_r_intc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}