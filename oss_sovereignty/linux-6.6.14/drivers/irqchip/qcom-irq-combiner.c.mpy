{
  "module_name": "qcom-irq-combiner.c",
  "hash_id": "d8ec34c5b8b137655ceb5796c1d18647c1cd19414d4075e5264039e6cf935f01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/qcom-irq-combiner.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) \"QCOM80B1:\" fmt\n\n#include <linux/acpi.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/platform_device.h>\n\n#define REG_SIZE 32\n\nstruct combiner_reg {\n\tvoid __iomem *addr;\n\tunsigned long enabled;\n};\n\nstruct combiner {\n\tstruct irq_domain   *domain;\n\tint                 parent_irq;\n\tu32                 nirqs;\n\tu32                 nregs;\n\tstruct combiner_reg regs[];\n};\n\nstatic inline int irq_nr(u32 reg, u32 bit)\n{\n\treturn reg * REG_SIZE + bit;\n}\n\n \nstatic void combiner_handle_irq(struct irq_desc *desc)\n{\n\tstruct combiner *combiner = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tu32 reg;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (reg = 0; reg < combiner->nregs; reg++) {\n\t\tint hwirq;\n\t\tu32 bit;\n\t\tu32 status;\n\n\t\tbit = readl_relaxed(combiner->regs[reg].addr);\n\t\tstatus = bit & combiner->regs[reg].enabled;\n\t\tif (bit && !status)\n\t\t\tpr_warn_ratelimited(\"Unexpected IRQ on CPU%d: (%08x %08lx %p)\\n\",\n\t\t\t\t\t    smp_processor_id(), bit,\n\t\t\t\t\t    combiner->regs[reg].enabled,\n\t\t\t\t\t    combiner->regs[reg].addr);\n\n\t\twhile (status) {\n\t\t\tbit = __ffs(status);\n\t\t\tstatus &= ~(1 << bit);\n\t\t\thwirq = irq_nr(reg, bit);\n\t\t\tgeneric_handle_domain_irq(combiner->domain, hwirq);\n\t\t}\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void combiner_irq_chip_mask_irq(struct irq_data *data)\n{\n\tstruct combiner *combiner = irq_data_get_irq_chip_data(data);\n\tstruct combiner_reg *reg = combiner->regs + data->hwirq / REG_SIZE;\n\n\tclear_bit(data->hwirq % REG_SIZE, &reg->enabled);\n}\n\nstatic void combiner_irq_chip_unmask_irq(struct irq_data *data)\n{\n\tstruct combiner *combiner = irq_data_get_irq_chip_data(data);\n\tstruct combiner_reg *reg = combiner->regs + data->hwirq / REG_SIZE;\n\n\tset_bit(data->hwirq % REG_SIZE, &reg->enabled);\n}\n\nstatic struct irq_chip irq_chip = {\n\t.irq_mask = combiner_irq_chip_mask_irq,\n\t.irq_unmask = combiner_irq_chip_unmask_irq,\n\t.name = \"qcom-irq-combiner\"\n};\n\nstatic int combiner_irq_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t\t   irq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(irq, &irq_chip, handle_level_irq);\n\tirq_set_chip_data(irq, domain->host_data);\n\tirq_set_noprobe(irq);\n\treturn 0;\n}\n\nstatic void combiner_irq_unmap(struct irq_domain *domain, unsigned int irq)\n{\n\tirq_domain_reset_irq_data(irq_get_irq_data(irq));\n}\n\nstatic int combiner_irq_translate(struct irq_domain *d, struct irq_fwspec *fws,\n\t\t\t\t  unsigned long *hwirq, unsigned int *type)\n{\n\tstruct combiner *combiner = d->host_data;\n\n\tif (is_acpi_node(fws->fwnode)) {\n\t\tif (WARN_ON((fws->param_count != 2) ||\n\t\t\t    (fws->param[0] >= combiner->nirqs) ||\n\t\t\t    (fws->param[1] & IORESOURCE_IRQ_LOWEDGE) ||\n\t\t\t    (fws->param[1] & IORESOURCE_IRQ_HIGHEDGE)))\n\t\t\treturn -EINVAL;\n\n\t\t*hwirq = fws->param[0];\n\t\t*type = fws->param[1];\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct irq_domain_ops domain_ops = {\n\t.map = combiner_irq_map,\n\t.unmap = combiner_irq_unmap,\n\t.translate = combiner_irq_translate\n};\n\nstatic acpi_status count_registers_cb(struct acpi_resource *ares, void *context)\n{\n\tint *count = context;\n\n\tif (ares->type == ACPI_RESOURCE_TYPE_GENERIC_REGISTER)\n\t\t++(*count);\n\treturn AE_OK;\n}\n\nstatic int count_registers(struct platform_device *pdev)\n{\n\tacpi_handle ahandle = ACPI_HANDLE(&pdev->dev);\n\tacpi_status status;\n\tint count = 0;\n\n\tif (!acpi_has_method(ahandle, METHOD_NAME__CRS))\n\t\treturn -EINVAL;\n\n\tstatus = acpi_walk_resources(ahandle, METHOD_NAME__CRS,\n\t\t\t\t     count_registers_cb, &count);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EINVAL;\n\treturn count;\n}\n\nstruct get_registers_context {\n\tstruct device *dev;\n\tstruct combiner *combiner;\n\tint err;\n};\n\nstatic acpi_status get_registers_cb(struct acpi_resource *ares, void *context)\n{\n\tstruct get_registers_context *ctx = context;\n\tstruct acpi_resource_generic_register *reg;\n\tphys_addr_t paddr;\n\tvoid __iomem *vaddr;\n\n\tif (ares->type != ACPI_RESOURCE_TYPE_GENERIC_REGISTER)\n\t\treturn AE_OK;\n\n\treg = &ares->data.generic_reg;\n\tpaddr = reg->address;\n\tif ((reg->space_id != ACPI_SPACE_MEM) ||\n\t    (reg->bit_offset != 0) ||\n\t    (reg->bit_width > REG_SIZE)) {\n\t\tdev_err(ctx->dev, \"Bad register resource @%pa\\n\", &paddr);\n\t\tctx->err = -EINVAL;\n\t\treturn AE_ERROR;\n\t}\n\n\tvaddr = devm_ioremap(ctx->dev, reg->address, REG_SIZE);\n\tif (!vaddr) {\n\t\tdev_err(ctx->dev, \"Can't map register @%pa\\n\", &paddr);\n\t\tctx->err = -ENOMEM;\n\t\treturn AE_ERROR;\n\t}\n\n\tctx->combiner->regs[ctx->combiner->nregs].addr = vaddr;\n\tctx->combiner->nirqs += reg->bit_width;\n\tctx->combiner->nregs++;\n\treturn AE_OK;\n}\n\nstatic int get_registers(struct platform_device *pdev, struct combiner *comb)\n{\n\tacpi_handle ahandle = ACPI_HANDLE(&pdev->dev);\n\tacpi_status status;\n\tstruct get_registers_context ctx;\n\n\tif (!acpi_has_method(ahandle, METHOD_NAME__CRS))\n\t\treturn -EINVAL;\n\n\tctx.dev = &pdev->dev;\n\tctx.combiner = comb;\n\tctx.err = 0;\n\n\tstatus = acpi_walk_resources(ahandle, METHOD_NAME__CRS,\n\t\t\t\t     get_registers_cb, &ctx);\n\tif (ACPI_FAILURE(status))\n\t\treturn ctx.err;\n\treturn 0;\n}\n\nstatic int __init combiner_probe(struct platform_device *pdev)\n{\n\tstruct combiner *combiner;\n\tint nregs;\n\tint err;\n\n\tnregs = count_registers(pdev);\n\tif (nregs <= 0) {\n\t\tdev_err(&pdev->dev, \"Error reading register resources\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcombiner = devm_kzalloc(&pdev->dev, struct_size(combiner, regs, nregs),\n\t\t\t\tGFP_KERNEL);\n\tif (!combiner)\n\t\treturn -ENOMEM;\n\n\terr = get_registers(pdev, combiner);\n\tif (err < 0)\n\t\treturn err;\n\n\tcombiner->parent_irq = platform_get_irq(pdev, 0);\n\tif (combiner->parent_irq <= 0)\n\t\treturn -EPROBE_DEFER;\n\n\tcombiner->domain = irq_domain_create_linear(pdev->dev.fwnode, combiner->nirqs,\n\t\t\t\t\t\t    &domain_ops, combiner);\n\tif (!combiner->domain)\n\t\t \n\t\treturn -ENODEV;\n\n\tirq_set_chained_handler_and_data(combiner->parent_irq,\n\t\t\t\t\t combiner_handle_irq, combiner);\n\n\tdev_info(&pdev->dev, \"Initialized with [p=%d,n=%d,r=%p]\\n\",\n\t\t combiner->parent_irq, combiner->nirqs, combiner->regs[0].addr);\n\treturn 0;\n}\n\nstatic const struct acpi_device_id qcom_irq_combiner_ids[] = {\n\t{ \"QCOM80B1\", },\n\t{ }\n};\n\nstatic struct platform_driver qcom_irq_combiner_probe = {\n\t.driver = {\n\t\t.name = \"qcom-irq-combiner\",\n\t\t.acpi_match_table = ACPI_PTR(qcom_irq_combiner_ids),\n\t},\n\t.probe = combiner_probe,\n};\nbuiltin_platform_driver(qcom_irq_combiner_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}