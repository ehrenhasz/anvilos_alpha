{
  "module_name": "irq-imx-mu-msi.c",
  "hash_id": "eb354828edc69a731a64868bed50d54e83d94393b6a42c13cf22d129a693faf9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-imx-mu-msi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_domain.h>\n#include <linux/spinlock.h>\n\n#define IMX_MU_CHANS            4\n\nenum imx_mu_xcr {\n\tIMX_MU_GIER,\n\tIMX_MU_GCR,\n\tIMX_MU_TCR,\n\tIMX_MU_RCR,\n\tIMX_MU_xCR_MAX,\n};\n\nenum imx_mu_xsr {\n\tIMX_MU_SR,\n\tIMX_MU_GSR,\n\tIMX_MU_TSR,\n\tIMX_MU_RSR,\n\tIMX_MU_xSR_MAX\n};\n\nenum imx_mu_type {\n\tIMX_MU_V2 = BIT(1),\n};\n\n \n#define IMX_MU_xCR_RIEn(data, x) ((data->cfg->type) & IMX_MU_V2 ? BIT(x) : BIT(24 + (3 - (x))))\n#define IMX_MU_xSR_RFn(data, x) ((data->cfg->type) & IMX_MU_V2 ? BIT(x) : BIT(24 + (3 - (x))))\n\nstruct imx_mu_dcfg {\n\tenum imx_mu_type type;\n\tu32     xTR;             \n\tu32     xRR;             \n\tu32     xSR[IMX_MU_xSR_MAX];          \n\tu32     xCR[IMX_MU_xCR_MAX];          \n};\n\nstruct imx_mu_msi {\n\traw_spinlock_t\t\t\tlock;\n\tstruct irq_domain\t\t*msi_domain;\n\tvoid __iomem\t\t\t*regs;\n\tphys_addr_t\t\t\tmsiir_addr;\n\tconst struct imx_mu_dcfg\t*cfg;\n\tunsigned long\t\t\tused;\n\tstruct clk\t\t\t*clk;\n};\n\nstatic void imx_mu_write(struct imx_mu_msi *msi_data, u32 val, u32 offs)\n{\n\tiowrite32(val, msi_data->regs + offs);\n}\n\nstatic u32 imx_mu_read(struct imx_mu_msi *msi_data, u32 offs)\n{\n\treturn ioread32(msi_data->regs + offs);\n}\n\nstatic u32 imx_mu_xcr_rmw(struct imx_mu_msi *msi_data, enum imx_mu_xcr type, u32 set, u32 clr)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&msi_data->lock, flags);\n\tval = imx_mu_read(msi_data, msi_data->cfg->xCR[type]);\n\tval &= ~clr;\n\tval |= set;\n\timx_mu_write(msi_data, val, msi_data->cfg->xCR[type]);\n\traw_spin_unlock_irqrestore(&msi_data->lock, flags);\n\n\treturn val;\n}\n\nstatic void imx_mu_msi_parent_mask_irq(struct irq_data *data)\n{\n\tstruct imx_mu_msi *msi_data = irq_data_get_irq_chip_data(data);\n\n\timx_mu_xcr_rmw(msi_data, IMX_MU_RCR, 0, IMX_MU_xCR_RIEn(msi_data, data->hwirq));\n}\n\nstatic void imx_mu_msi_parent_unmask_irq(struct irq_data *data)\n{\n\tstruct imx_mu_msi *msi_data = irq_data_get_irq_chip_data(data);\n\n\timx_mu_xcr_rmw(msi_data, IMX_MU_RCR, IMX_MU_xCR_RIEn(msi_data, data->hwirq), 0);\n}\n\nstatic void imx_mu_msi_parent_ack_irq(struct irq_data *data)\n{\n\tstruct imx_mu_msi *msi_data = irq_data_get_irq_chip_data(data);\n\n\timx_mu_read(msi_data, msi_data->cfg->xRR + data->hwirq * 4);\n}\n\nstatic struct irq_chip imx_mu_msi_irq_chip = {\n\t.name = \"MU-MSI\",\n\t.irq_ack = irq_chip_ack_parent,\n};\n\nstatic struct msi_domain_ops imx_mu_msi_irq_ops = {\n};\n\nstatic struct msi_domain_info imx_mu_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS),\n\t.ops\t= &imx_mu_msi_irq_ops,\n\t.chip\t= &imx_mu_msi_irq_chip,\n};\n\nstatic void imx_mu_msi_parent_compose_msg(struct irq_data *data,\n\t\t\t\t\t  struct msi_msg *msg)\n{\n\tstruct imx_mu_msi *msi_data = irq_data_get_irq_chip_data(data);\n\tu64 addr = msi_data->msiir_addr + 4 * data->hwirq;\n\n\tmsg->address_hi = upper_32_bits(addr);\n\tmsg->address_lo = lower_32_bits(addr);\n\tmsg->data = data->hwirq;\n}\n\nstatic int imx_mu_msi_parent_set_affinity(struct irq_data *irq_data,\n\t\t\t\t   const struct cpumask *mask, bool force)\n{\n\treturn -EINVAL;\n}\n\nstatic struct irq_chip imx_mu_msi_parent_chip = {\n\t.name\t\t= \"MU\",\n\t.irq_mask\t= imx_mu_msi_parent_mask_irq,\n\t.irq_unmask\t= imx_mu_msi_parent_unmask_irq,\n\t.irq_ack\t= imx_mu_msi_parent_ack_irq,\n\t.irq_compose_msi_msg\t= imx_mu_msi_parent_compose_msg,\n\t.irq_set_affinity = imx_mu_msi_parent_set_affinity,\n};\n\nstatic int imx_mu_msi_domain_irq_alloc(struct irq_domain *domain,\n\t\t\t\t\tunsigned int virq,\n\t\t\t\t\tunsigned int nr_irqs,\n\t\t\t\t\tvoid *args)\n{\n\tstruct imx_mu_msi *msi_data = domain->host_data;\n\tunsigned long flags;\n\tint pos, err = 0;\n\n\tWARN_ON(nr_irqs != 1);\n\n\traw_spin_lock_irqsave(&msi_data->lock, flags);\n\tpos = find_first_zero_bit(&msi_data->used, IMX_MU_CHANS);\n\tif (pos < IMX_MU_CHANS)\n\t\t__set_bit(pos, &msi_data->used);\n\telse\n\t\terr = -ENOSPC;\n\traw_spin_unlock_irqrestore(&msi_data->lock, flags);\n\n\tif (err)\n\t\treturn err;\n\n\tirq_domain_set_info(domain, virq, pos,\n\t\t\t    &imx_mu_msi_parent_chip, msi_data,\n\t\t\t    handle_edge_irq, NULL, NULL);\n\treturn 0;\n}\n\nstatic void imx_mu_msi_domain_irq_free(struct irq_domain *domain,\n\t\t\t\t       unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct imx_mu_msi *msi_data = irq_data_get_irq_chip_data(d);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&msi_data->lock, flags);\n\t__clear_bit(d->hwirq, &msi_data->used);\n\traw_spin_unlock_irqrestore(&msi_data->lock, flags);\n}\n\nstatic const struct irq_domain_ops imx_mu_msi_domain_ops = {\n\t.alloc\t= imx_mu_msi_domain_irq_alloc,\n\t.free\t= imx_mu_msi_domain_irq_free,\n};\n\nstatic void imx_mu_msi_irq_handler(struct irq_desc *desc)\n{\n\tstruct imx_mu_msi *msi_data = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tu32 status;\n\tint i;\n\n\tstatus = imx_mu_read(msi_data, msi_data->cfg->xSR[IMX_MU_RSR]);\n\n\tchained_irq_enter(chip, desc);\n\tfor (i = 0; i < IMX_MU_CHANS; i++) {\n\t\tif (status & IMX_MU_xSR_RFn(msi_data, i))\n\t\t\tgeneric_handle_domain_irq(msi_data->msi_domain, i);\n\t}\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int imx_mu_msi_domains_init(struct imx_mu_msi *msi_data, struct device *dev)\n{\n\tstruct fwnode_handle *fwnodes = dev_fwnode(dev);\n\tstruct irq_domain *parent;\n\n\t \n\tparent = irq_domain_create_linear(fwnodes,\n\t\t\t\t\t    IMX_MU_CHANS,\n\t\t\t\t\t    &imx_mu_msi_domain_ops,\n\t\t\t\t\t    msi_data);\n\tif (!parent) {\n\t\tdev_err(dev, \"failed to create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tirq_domain_update_bus_token(parent, DOMAIN_BUS_NEXUS);\n\n\tmsi_data->msi_domain = platform_msi_create_irq_domain(fwnodes,\n\t\t\t\t\t&imx_mu_msi_domain_info,\n\t\t\t\t\tparent);\n\n\tif (!msi_data->msi_domain) {\n\t\tdev_err(dev, \"failed to create MSI domain\\n\");\n\t\tirq_domain_remove(parent);\n\t\treturn -ENOMEM;\n\t}\n\n\tirq_domain_set_pm_device(msi_data->msi_domain, dev);\n\n\treturn 0;\n}\n\n \nstatic const struct imx_mu_dcfg imx_mu_cfg_imx6sx = {\n\t.type\t= 0,\n\t.xTR    = 0x0,\n\t.xRR    = 0x10,\n\t.xSR    = {\n\t\t\t[IMX_MU_SR]  = 0x20,\n\t\t\t[IMX_MU_GSR] = 0x20,\n\t\t\t[IMX_MU_TSR] = 0x20,\n\t\t\t[IMX_MU_RSR] = 0x20,\n\t\t  },\n\t.xCR    = {\n\t\t\t[IMX_MU_GIER] = 0x24,\n\t\t\t[IMX_MU_GCR]  = 0x24,\n\t\t\t[IMX_MU_TCR]  = 0x24,\n\t\t\t[IMX_MU_RCR]  = 0x24,\n\t\t  },\n};\n\nstatic const struct imx_mu_dcfg imx_mu_cfg_imx7ulp = {\n\t.type\t= 0,\n\t.xTR    = 0x20,\n\t.xRR    = 0x40,\n\t.xSR    = {\n\t\t\t[IMX_MU_SR]  = 0x60,\n\t\t\t[IMX_MU_GSR] = 0x60,\n\t\t\t[IMX_MU_TSR] = 0x60,\n\t\t\t[IMX_MU_RSR] = 0x60,\n\t\t  },\n\t.xCR    = {\n\t\t\t[IMX_MU_GIER] = 0x64,\n\t\t\t[IMX_MU_GCR]  = 0x64,\n\t\t\t[IMX_MU_TCR]  = 0x64,\n\t\t\t[IMX_MU_RCR]  = 0x64,\n\t\t  },\n};\n\nstatic const struct imx_mu_dcfg imx_mu_cfg_imx8ulp = {\n\t.type   = IMX_MU_V2,\n\t.xTR    = 0x200,\n\t.xRR    = 0x280,\n\t.xSR    = {\n\t\t\t[IMX_MU_SR]  = 0xC,\n\t\t\t[IMX_MU_GSR] = 0x118,\n\t\t\t[IMX_MU_TSR] = 0x124,\n\t\t\t[IMX_MU_RSR] = 0x12C,\n\t\t  },\n\t.xCR    = {\n\t\t\t[IMX_MU_GIER] = 0x110,\n\t\t\t[IMX_MU_GCR]  = 0x114,\n\t\t\t[IMX_MU_TCR]  = 0x120,\n\t\t\t[IMX_MU_RCR]  = 0x128\n\t\t  },\n};\n\nstatic int __init imx_mu_of_init(struct device_node *dn,\n\t\t\t\t struct device_node *parent,\n\t\t\t\t const struct imx_mu_dcfg *cfg)\n{\n\tstruct platform_device *pdev = of_find_device_by_node(dn);\n\tstruct device_link *pd_link_a;\n\tstruct device_link *pd_link_b;\n\tstruct imx_mu_msi *msi_data;\n\tstruct resource *res;\n\tstruct device *pd_a;\n\tstruct device *pd_b;\n\tstruct device *dev;\n\tint ret;\n\tint irq;\n\n\tdev = &pdev->dev;\n\n\tmsi_data = devm_kzalloc(&pdev->dev, sizeof(*msi_data), GFP_KERNEL);\n\tif (!msi_data)\n\t\treturn -ENOMEM;\n\n\tmsi_data->cfg = cfg;\n\n\tmsi_data->regs = devm_platform_ioremap_resource_byname(pdev, \"processor-a-side\");\n\tif (IS_ERR(msi_data->regs)) {\n\t\tdev_err(&pdev->dev, \"failed to initialize 'regs'\\n\");\n\t\treturn PTR_ERR(msi_data->regs);\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"processor-b-side\");\n\tif (!res)\n\t\treturn -EIO;\n\n\tmsi_data->msiir_addr = res->start + msi_data->cfg->xTR;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tplatform_set_drvdata(pdev, msi_data);\n\n\tmsi_data->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(msi_data->clk))\n\t\treturn PTR_ERR(msi_data->clk);\n\n\tpd_a = dev_pm_domain_attach_by_name(dev, \"processor-a-side\");\n\tif (IS_ERR(pd_a))\n\t\treturn PTR_ERR(pd_a);\n\n\tpd_b = dev_pm_domain_attach_by_name(dev, \"processor-b-side\");\n\tif (IS_ERR(pd_b))\n\t\treturn PTR_ERR(pd_b);\n\n\tpd_link_a = device_link_add(dev, pd_a,\n\t\t\tDL_FLAG_STATELESS |\n\t\t\tDL_FLAG_PM_RUNTIME |\n\t\t\tDL_FLAG_RPM_ACTIVE);\n\n\tif (!pd_link_a) {\n\t\tdev_err(dev, \"Failed to add device_link to mu a.\\n\");\n\t\tgoto err_pd_a;\n\t}\n\n\tpd_link_b = device_link_add(dev, pd_b,\n\t\t\tDL_FLAG_STATELESS |\n\t\t\tDL_FLAG_PM_RUNTIME |\n\t\t\tDL_FLAG_RPM_ACTIVE);\n\n\n\tif (!pd_link_b) {\n\t\tdev_err(dev, \"Failed to add device_link to mu a.\\n\");\n\t\tgoto err_pd_b;\n\t}\n\n\tret = imx_mu_msi_domains_init(msi_data, dev);\n\tif (ret)\n\t\tgoto err_dm_init;\n\n\tpm_runtime_enable(dev);\n\n\tirq_set_chained_handler_and_data(irq,\n\t\t\t\t\t imx_mu_msi_irq_handler,\n\t\t\t\t\t msi_data);\n\n\treturn 0;\n\nerr_dm_init:\n\tdevice_link_remove(dev,\tpd_b);\nerr_pd_b:\n\tdevice_link_remove(dev, pd_a);\nerr_pd_a:\n\treturn -EINVAL;\n}\n\nstatic int __maybe_unused imx_mu_runtime_suspend(struct device *dev)\n{\n\tstruct imx_mu_msi *priv = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_mu_runtime_resume(struct device *dev)\n{\n\tstruct imx_mu_msi *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\tdev_err(dev, \"failed to enable clock\\n\");\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops imx_mu_pm_ops = {\n\tSET_RUNTIME_PM_OPS(imx_mu_runtime_suspend,\n\t\t\t   imx_mu_runtime_resume, NULL)\n};\n\nstatic int __init imx_mu_imx7ulp_of_init(struct device_node *dn,\n\t\t\t\t\t struct device_node *parent)\n{\n\treturn imx_mu_of_init(dn, parent, &imx_mu_cfg_imx7ulp);\n}\n\nstatic int __init imx_mu_imx6sx_of_init(struct device_node *dn,\n\t\t\t\t\tstruct device_node *parent)\n{\n\treturn imx_mu_of_init(dn, parent, &imx_mu_cfg_imx6sx);\n}\n\nstatic int __init imx_mu_imx8ulp_of_init(struct device_node *dn,\n\t\t\t\t\t struct device_node *parent)\n{\n\treturn imx_mu_of_init(dn, parent, &imx_mu_cfg_imx8ulp);\n}\n\nIRQCHIP_PLATFORM_DRIVER_BEGIN(imx_mu_msi)\nIRQCHIP_MATCH(\"fsl,imx7ulp-mu-msi\", imx_mu_imx7ulp_of_init)\nIRQCHIP_MATCH(\"fsl,imx6sx-mu-msi\", imx_mu_imx6sx_of_init)\nIRQCHIP_MATCH(\"fsl,imx8ulp-mu-msi\", imx_mu_imx8ulp_of_init)\nIRQCHIP_PLATFORM_DRIVER_END(imx_mu_msi, .pm = &imx_mu_pm_ops)\n\n\nMODULE_AUTHOR(\"Frank Li <Frank.Li@nxp.com>\");\nMODULE_DESCRIPTION(\"Freescale MU MSI controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}