{
  "module_name": "irq-pruss-intc.c",
  "hash_id": "38b9d377048ed78b38b67fd473aa0666689262608dcb8d32e4940f3480915e27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-pruss-intc.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n \n#define MAX_NUM_HOST_IRQS\t8\n\n \n#define FIRST_PRU_HOST_INT\t2\n\n \n#define PRU_INTC_REVID\t\t0x0000\n#define PRU_INTC_CR\t\t0x0004\n#define PRU_INTC_GER\t\t0x0010\n#define PRU_INTC_GNLR\t\t0x001c\n#define PRU_INTC_SISR\t\t0x0020\n#define PRU_INTC_SICR\t\t0x0024\n#define PRU_INTC_EISR\t\t0x0028\n#define PRU_INTC_EICR\t\t0x002c\n#define PRU_INTC_HIEISR\t\t0x0034\n#define PRU_INTC_HIDISR\t\t0x0038\n#define PRU_INTC_GPIR\t\t0x0080\n#define PRU_INTC_SRSR(x)\t(0x0200 + (x) * 4)\n#define PRU_INTC_SECR(x)\t(0x0280 + (x) * 4)\n#define PRU_INTC_ESR(x)\t\t(0x0300 + (x) * 4)\n#define PRU_INTC_ECR(x)\t\t(0x0380 + (x) * 4)\n#define PRU_INTC_CMR(x)\t\t(0x0400 + (x) * 4)\n#define PRU_INTC_HMR(x)\t\t(0x0800 + (x) * 4)\n#define PRU_INTC_HIPIR(x)\t(0x0900 + (x) * 4)\n#define PRU_INTC_SIPR(x)\t(0x0d00 + (x) * 4)\n#define PRU_INTC_SITR(x)\t(0x0d80 + (x) * 4)\n#define PRU_INTC_HINLR(x)\t(0x1100 + (x) * 4)\n#define PRU_INTC_HIER\t\t0x1500\n\n \n#define CMR_EVT_MAP_MASK\t0xf\n#define CMR_EVT_MAP_BITS\t8\n#define CMR_EVT_PER_REG\t\t4\n\n \n#define HMR_CH_MAP_MASK\t\t0xf\n#define HMR_CH_MAP_BITS\t\t8\n#define HMR_CH_PER_REG\t\t4\n\n \n#define INTC_HIPIR_NONE_HINT\t0x80000000\n\n#define MAX_PRU_SYS_EVENTS 160\n#define MAX_PRU_CHANNELS 20\n\n \nstruct pruss_intc_map_record {\n\tu8 value;\n\tu8 ref_count;\n};\n\n \nstruct pruss_intc_match_data {\n\tu8 num_system_events;\n\tu8 num_host_events;\n};\n\n \nstruct pruss_intc {\n\tstruct pruss_intc_map_record event_channel[MAX_PRU_SYS_EVENTS];\n\tstruct pruss_intc_map_record channel_host[MAX_PRU_CHANNELS];\n\tunsigned int irqs[MAX_NUM_HOST_IRQS];\n\tvoid __iomem *base;\n\tstruct irq_domain *domain;\n\tconst struct pruss_intc_match_data *soc_config;\n\tstruct device *dev;\n\tstruct mutex lock;  \n};\n\n \nstruct pruss_host_irq_data {\n\tstruct pruss_intc *intc;\n\tu8 host_irq;\n};\n\nstatic inline u32 pruss_intc_read_reg(struct pruss_intc *intc, unsigned int reg)\n{\n\treturn readl_relaxed(intc->base + reg);\n}\n\nstatic inline void pruss_intc_write_reg(struct pruss_intc *intc,\n\t\t\t\t\tunsigned int reg, u32 val)\n{\n\twritel_relaxed(val, intc->base + reg);\n}\n\nstatic void pruss_intc_update_cmr(struct pruss_intc *intc, unsigned int evt,\n\t\t\t\t  u8 ch)\n{\n\tu32 idx, offset, val;\n\n\tidx = evt / CMR_EVT_PER_REG;\n\toffset = (evt % CMR_EVT_PER_REG) * CMR_EVT_MAP_BITS;\n\n\tval = pruss_intc_read_reg(intc, PRU_INTC_CMR(idx));\n\tval &= ~(CMR_EVT_MAP_MASK << offset);\n\tval |= ch << offset;\n\tpruss_intc_write_reg(intc, PRU_INTC_CMR(idx), val);\n\n\tdev_dbg(intc->dev, \"SYSEV%u -> CH%d (CMR%d 0x%08x)\\n\", evt, ch,\n\t\tidx, pruss_intc_read_reg(intc, PRU_INTC_CMR(idx)));\n}\n\nstatic void pruss_intc_update_hmr(struct pruss_intc *intc, u8 ch, u8 host)\n{\n\tu32 idx, offset, val;\n\n\tidx = ch / HMR_CH_PER_REG;\n\toffset = (ch % HMR_CH_PER_REG) * HMR_CH_MAP_BITS;\n\n\tval = pruss_intc_read_reg(intc, PRU_INTC_HMR(idx));\n\tval &= ~(HMR_CH_MAP_MASK << offset);\n\tval |= host << offset;\n\tpruss_intc_write_reg(intc, PRU_INTC_HMR(idx), val);\n\n\tdev_dbg(intc->dev, \"CH%d -> HOST%d (HMR%d 0x%08x)\\n\", ch, host, idx,\n\t\tpruss_intc_read_reg(intc, PRU_INTC_HMR(idx)));\n}\n\n \nstatic void pruss_intc_map(struct pruss_intc *intc, unsigned long hwirq)\n{\n\tstruct device *dev = intc->dev;\n\tu8 ch, host, reg_idx;\n\tu32 val;\n\n\tmutex_lock(&intc->lock);\n\n\tintc->event_channel[hwirq].ref_count++;\n\n\tch = intc->event_channel[hwirq].value;\n\thost = intc->channel_host[ch].value;\n\n\tpruss_intc_update_cmr(intc, hwirq, ch);\n\n\treg_idx = hwirq / 32;\n\tval = BIT(hwirq  % 32);\n\n\t \n\tpruss_intc_write_reg(intc, PRU_INTC_ESR(reg_idx), val);\n\tpruss_intc_write_reg(intc, PRU_INTC_SECR(reg_idx), val);\n\n\tif (++intc->channel_host[ch].ref_count == 1) {\n\t\tpruss_intc_update_hmr(intc, ch, host);\n\n\t\t \n\t\tpruss_intc_write_reg(intc, PRU_INTC_HIEISR, host);\n\t}\n\n\tdev_dbg(dev, \"mapped system_event = %lu channel = %d host = %d\",\n\t\thwirq, ch, host);\n\n\tmutex_unlock(&intc->lock);\n}\n\n \nstatic void pruss_intc_unmap(struct pruss_intc *intc, unsigned long hwirq)\n{\n\tu8 ch, host, reg_idx;\n\tu32 val;\n\n\tmutex_lock(&intc->lock);\n\n\tch = intc->event_channel[hwirq].value;\n\thost = intc->channel_host[ch].value;\n\n\tif (--intc->channel_host[ch].ref_count == 0) {\n\t\t \n\t\tpruss_intc_write_reg(intc, PRU_INTC_HIDISR, host);\n\n\t\t \n\t\tpruss_intc_update_hmr(intc, ch, 0);\n\t}\n\n\tintc->event_channel[hwirq].ref_count--;\n\treg_idx = hwirq / 32;\n\tval = BIT(hwirq  % 32);\n\n\t \n\tpruss_intc_write_reg(intc, PRU_INTC_ECR(reg_idx), val);\n\t \n\tpruss_intc_write_reg(intc, PRU_INTC_SECR(reg_idx), val);\n\n\t \n\tpruss_intc_update_cmr(intc, hwirq, 0);\n\n\tdev_dbg(intc->dev, \"unmapped system_event = %lu channel = %d host = %d\\n\",\n\t\thwirq, ch, host);\n\n\tmutex_unlock(&intc->lock);\n}\n\nstatic void pruss_intc_init(struct pruss_intc *intc)\n{\n\tconst struct pruss_intc_match_data *soc_config = intc->soc_config;\n\tint num_chnl_map_regs, num_host_intr_regs, num_event_type_regs, i;\n\n\tnum_chnl_map_regs = DIV_ROUND_UP(soc_config->num_system_events,\n\t\t\t\t\t CMR_EVT_PER_REG);\n\tnum_host_intr_regs = DIV_ROUND_UP(soc_config->num_host_events,\n\t\t\t\t\t  HMR_CH_PER_REG);\n\tnum_event_type_regs = DIV_ROUND_UP(soc_config->num_system_events, 32);\n\n\t \n\tfor (i = 0; i < num_event_type_regs; i++) {\n\t\tpruss_intc_write_reg(intc, PRU_INTC_SIPR(i), 0xffffffff);\n\t\tpruss_intc_write_reg(intc, PRU_INTC_SITR(i), 0);\n\t}\n\n\t \n\tfor (i = 0; i < num_chnl_map_regs; i++)\n\t\tpruss_intc_write_reg(intc, PRU_INTC_CMR(i), 0);\n\n\t \n\tfor (i = 0; i < num_host_intr_regs; i++)\n\t\tpruss_intc_write_reg(intc, PRU_INTC_HMR(i), 0);\n\n\t \n\tpruss_intc_write_reg(intc, PRU_INTC_GER, 1);\n}\n\nstatic void pruss_intc_irq_ack(struct irq_data *data)\n{\n\tstruct pruss_intc *intc = irq_data_get_irq_chip_data(data);\n\tunsigned int hwirq = data->hwirq;\n\n\tpruss_intc_write_reg(intc, PRU_INTC_SICR, hwirq);\n}\n\nstatic void pruss_intc_irq_mask(struct irq_data *data)\n{\n\tstruct pruss_intc *intc = irq_data_get_irq_chip_data(data);\n\tunsigned int hwirq = data->hwirq;\n\n\tpruss_intc_write_reg(intc, PRU_INTC_EICR, hwirq);\n}\n\nstatic void pruss_intc_irq_unmask(struct irq_data *data)\n{\n\tstruct pruss_intc *intc = irq_data_get_irq_chip_data(data);\n\tunsigned int hwirq = data->hwirq;\n\n\tpruss_intc_write_reg(intc, PRU_INTC_EISR, hwirq);\n}\n\nstatic int pruss_intc_irq_reqres(struct irq_data *data)\n{\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void pruss_intc_irq_relres(struct irq_data *data)\n{\n\tmodule_put(THIS_MODULE);\n}\n\nstatic int pruss_intc_irq_get_irqchip_state(struct irq_data *data,\n\t\t\t\t\t    enum irqchip_irq_state which,\n\t\t\t\t\t    bool *state)\n{\n\tstruct pruss_intc *intc = irq_data_get_irq_chip_data(data);\n\tu32 reg, mask, srsr;\n\n\tif (which != IRQCHIP_STATE_PENDING)\n\t\treturn -EINVAL;\n\n\treg = PRU_INTC_SRSR(data->hwirq / 32);\n\tmask = BIT(data->hwirq % 32);\n\n\tsrsr = pruss_intc_read_reg(intc, reg);\n\n\t*state = !!(srsr & mask);\n\n\treturn 0;\n}\n\nstatic int pruss_intc_irq_set_irqchip_state(struct irq_data *data,\n\t\t\t\t\t    enum irqchip_irq_state which,\n\t\t\t\t\t    bool state)\n{\n\tstruct pruss_intc *intc = irq_data_get_irq_chip_data(data);\n\n\tif (which != IRQCHIP_STATE_PENDING)\n\t\treturn -EINVAL;\n\n\tif (state)\n\t\tpruss_intc_write_reg(intc, PRU_INTC_SISR, data->hwirq);\n\telse\n\t\tpruss_intc_write_reg(intc, PRU_INTC_SICR, data->hwirq);\n\n\treturn 0;\n}\n\nstatic struct irq_chip pruss_irqchip = {\n\t.name\t\t\t= \"pruss-intc\",\n\t.irq_ack\t\t= pruss_intc_irq_ack,\n\t.irq_mask\t\t= pruss_intc_irq_mask,\n\t.irq_unmask\t\t= pruss_intc_irq_unmask,\n\t.irq_request_resources\t= pruss_intc_irq_reqres,\n\t.irq_release_resources\t= pruss_intc_irq_relres,\n\t.irq_get_irqchip_state\t= pruss_intc_irq_get_irqchip_state,\n\t.irq_set_irqchip_state\t= pruss_intc_irq_set_irqchip_state,\n};\n\nstatic int pruss_intc_validate_mapping(struct pruss_intc *intc, int event,\n\t\t\t\t       int channel, int host)\n{\n\tstruct device *dev = intc->dev;\n\tint ret = 0;\n\n\tmutex_lock(&intc->lock);\n\n\t \n\tif (intc->event_channel[event].ref_count > 0 &&\n\t    intc->event_channel[event].value != channel) {\n\t\tdev_err(dev, \"event %d (req. ch %d) already assigned to channel %d\\n\",\n\t\t\tevent, channel, intc->event_channel[event].value);\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (intc->channel_host[channel].ref_count > 0 &&\n\t    intc->channel_host[channel].value != host) {\n\t\tdev_err(dev, \"channel %d (req. host %d) already assigned to host %d\\n\",\n\t\t\tchannel, host, intc->channel_host[channel].value);\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tintc->event_channel[event].value = channel;\n\tintc->channel_host[channel].value = host;\n\nunlock:\n\tmutex_unlock(&intc->lock);\n\treturn ret;\n}\n\nstatic int\npruss_intc_irq_domain_xlate(struct irq_domain *d, struct device_node *node,\n\t\t\t    const u32 *intspec, unsigned int intsize,\n\t\t\t    unsigned long *out_hwirq, unsigned int *out_type)\n{\n\tstruct pruss_intc *intc = d->host_data;\n\tstruct device *dev = intc->dev;\n\tint ret, sys_event, channel, host;\n\n\tif (intsize < 3)\n\t\treturn -EINVAL;\n\n\tsys_event = intspec[0];\n\tif (sys_event < 0 || sys_event >= intc->soc_config->num_system_events) {\n\t\tdev_err(dev, \"%d is not valid event number\\n\", sys_event);\n\t\treturn -EINVAL;\n\t}\n\n\tchannel = intspec[1];\n\tif (channel < 0 || channel >= intc->soc_config->num_host_events) {\n\t\tdev_err(dev, \"%d is not valid channel number\", channel);\n\t\treturn -EINVAL;\n\t}\n\n\thost = intspec[2];\n\tif (host < 0 || host >= intc->soc_config->num_host_events) {\n\t\tdev_err(dev, \"%d is not valid host irq number\\n\", host);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = pruss_intc_validate_mapping(intc, sys_event, channel, host);\n\tif (ret)\n\t\treturn ret;\n\n\t*out_hwirq = sys_event;\n\t*out_type = IRQ_TYPE_LEVEL_HIGH;\n\n\treturn 0;\n}\n\nstatic int pruss_intc_irq_domain_map(struct irq_domain *d, unsigned int virq,\n\t\t\t\t     irq_hw_number_t hw)\n{\n\tstruct pruss_intc *intc = d->host_data;\n\n\tpruss_intc_map(intc, hw);\n\n\tirq_set_chip_data(virq, intc);\n\tirq_set_chip_and_handler(virq, &pruss_irqchip, handle_level_irq);\n\n\treturn 0;\n}\n\nstatic void pruss_intc_irq_domain_unmap(struct irq_domain *d, unsigned int virq)\n{\n\tstruct pruss_intc *intc = d->host_data;\n\tunsigned long hwirq = irqd_to_hwirq(irq_get_irq_data(virq));\n\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tirq_set_chip_data(virq, NULL);\n\tpruss_intc_unmap(intc, hwirq);\n}\n\nstatic const struct irq_domain_ops pruss_intc_irq_domain_ops = {\n\t.xlate\t= pruss_intc_irq_domain_xlate,\n\t.map\t= pruss_intc_irq_domain_map,\n\t.unmap\t= pruss_intc_irq_domain_unmap,\n};\n\nstatic void pruss_intc_irq_handler(struct irq_desc *desc)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct pruss_host_irq_data *host_irq_data = irq_get_handler_data(irq);\n\tstruct pruss_intc *intc = host_irq_data->intc;\n\tu8 host_irq = host_irq_data->host_irq + FIRST_PRU_HOST_INT;\n\n\tchained_irq_enter(chip, desc);\n\n\twhile (true) {\n\t\tu32 hipir;\n\t\tint hwirq, err;\n\n\t\t \n\t\thipir = pruss_intc_read_reg(intc, PRU_INTC_HIPIR(host_irq));\n\t\tif (hipir & INTC_HIPIR_NONE_HINT)\n\t\t\tbreak;\n\n\t\thwirq = hipir & GENMASK(9, 0);\n\t\terr = generic_handle_domain_irq(intc->domain, hwirq);\n\n\t\t \n\t\tif (WARN_ON_ONCE(err))\n\t\t\tpruss_intc_write_reg(intc, PRU_INTC_SICR, hwirq);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic const char * const irq_names[MAX_NUM_HOST_IRQS] = {\n\t\"host_intr0\", \"host_intr1\", \"host_intr2\", \"host_intr3\",\n\t\"host_intr4\", \"host_intr5\", \"host_intr6\", \"host_intr7\",\n};\n\nstatic int pruss_intc_probe(struct platform_device *pdev)\n{\n\tconst struct pruss_intc_match_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct pruss_intc *intc;\n\tstruct pruss_host_irq_data *host_data;\n\tint i, irq, ret;\n\tu8 max_system_events, irqs_reserved = 0;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tmax_system_events = data->num_system_events;\n\n\tintc = devm_kzalloc(dev, sizeof(*intc), GFP_KERNEL);\n\tif (!intc)\n\t\treturn -ENOMEM;\n\n\tintc->soc_config = data;\n\tintc->dev = dev;\n\tplatform_set_drvdata(pdev, intc);\n\n\tintc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(intc->base))\n\t\treturn PTR_ERR(intc->base);\n\n\tret = of_property_read_u8(dev->of_node, \"ti,irqs-reserved\",\n\t\t\t\t  &irqs_reserved);\n\n\t \n\tif (ret < 0 && ret != -EINVAL)\n\t\treturn ret;\n\n\tpruss_intc_init(intc);\n\n\tmutex_init(&intc->lock);\n\n\tintc->domain = irq_domain_add_linear(dev->of_node, max_system_events,\n\t\t\t\t\t     &pruss_intc_irq_domain_ops, intc);\n\tif (!intc->domain)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < MAX_NUM_HOST_IRQS; i++) {\n\t\tif (irqs_reserved & BIT(i))\n\t\t\tcontinue;\n\n\t\tirq = platform_get_irq_byname(pdev, irq_names[i]);\n\t\tif (irq < 0) {\n\t\t\tret = irq;\n\t\t\tgoto fail_irq;\n\t\t}\n\n\t\tintc->irqs[i] = irq;\n\n\t\thost_data = devm_kzalloc(dev, sizeof(*host_data), GFP_KERNEL);\n\t\tif (!host_data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_irq;\n\t\t}\n\n\t\thost_data->intc = intc;\n\t\thost_data->host_irq = i;\n\n\t\tirq_set_handler_data(irq, host_data);\n\t\tirq_set_chained_handler(irq, pruss_intc_irq_handler);\n\t}\n\n\treturn 0;\n\nfail_irq:\n\twhile (--i >= 0) {\n\t\tif (intc->irqs[i])\n\t\t\tirq_set_chained_handler_and_data(intc->irqs[i], NULL,\n\t\t\t\t\t\t\t NULL);\n\t}\n\n\tirq_domain_remove(intc->domain);\n\n\treturn ret;\n}\n\nstatic int pruss_intc_remove(struct platform_device *pdev)\n{\n\tstruct pruss_intc *intc = platform_get_drvdata(pdev);\n\tu8 max_system_events = intc->soc_config->num_system_events;\n\tunsigned int hwirq;\n\tint i;\n\n\tfor (i = 0; i < MAX_NUM_HOST_IRQS; i++) {\n\t\tif (intc->irqs[i])\n\t\t\tirq_set_chained_handler_and_data(intc->irqs[i], NULL,\n\t\t\t\t\t\t\t NULL);\n\t}\n\n\tfor (hwirq = 0; hwirq < max_system_events; hwirq++)\n\t\tirq_dispose_mapping(irq_find_mapping(intc->domain, hwirq));\n\n\tirq_domain_remove(intc->domain);\n\n\treturn 0;\n}\n\nstatic const struct pruss_intc_match_data pruss_intc_data = {\n\t.num_system_events = 64,\n\t.num_host_events = 10,\n};\n\nstatic const struct pruss_intc_match_data icssg_intc_data = {\n\t.num_system_events = 160,\n\t.num_host_events = 20,\n};\n\nstatic const struct of_device_id pruss_intc_of_match[] = {\n\t{\n\t\t.compatible = \"ti,pruss-intc\",\n\t\t.data = &pruss_intc_data,\n\t},\n\t{\n\t\t.compatible = \"ti,icssg-intc\",\n\t\t.data = &icssg_intc_data,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, pruss_intc_of_match);\n\nstatic struct platform_driver pruss_intc_driver = {\n\t.driver = {\n\t\t.name = \"pruss-intc\",\n\t\t.of_match_table = pruss_intc_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe  = pruss_intc_probe,\n\t.remove = pruss_intc_remove,\n};\nmodule_platform_driver(pruss_intc_driver);\n\nMODULE_AUTHOR(\"Andrew F. Davis <afd@ti.com>\");\nMODULE_AUTHOR(\"Suman Anna <s-anna@ti.com>\");\nMODULE_AUTHOR(\"Grzegorz Jaszczyk <grzegorz.jaszczyk@linaro.org>\");\nMODULE_DESCRIPTION(\"TI PRU-ICSS INTC Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}