{
  "module_name": "irq-hip04.c",
  "hash_id": "046587d0f93873656fff669a0f31c136823e2944902c538df0d3ca9c29d6b9d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-hip04.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/cpu_pm.h>\n#include <linux/cpumask.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/arm-gic.h>\n\n#include <asm/irq.h>\n#include <asm/exception.h>\n#include <asm/smp_plat.h>\n\n#include \"irq-gic-common.h\"\n\n#define HIP04_MAX_IRQS\t\t510\n\nstruct hip04_irq_data {\n\tvoid __iomem *dist_base;\n\tvoid __iomem *cpu_base;\n\tstruct irq_domain *domain;\n\tunsigned int nr_irqs;\n};\n\nstatic DEFINE_RAW_SPINLOCK(irq_controller_lock);\n\n \n#define NR_HIP04_CPU_IF 16\nstatic u16 hip04_cpu_map[NR_HIP04_CPU_IF] __read_mostly;\n\nstatic struct hip04_irq_data hip04_data __read_mostly;\n\nstatic inline void __iomem *hip04_dist_base(struct irq_data *d)\n{\n\tstruct hip04_irq_data *hip04_data = irq_data_get_irq_chip_data(d);\n\treturn hip04_data->dist_base;\n}\n\nstatic inline void __iomem *hip04_cpu_base(struct irq_data *d)\n{\n\tstruct hip04_irq_data *hip04_data = irq_data_get_irq_chip_data(d);\n\treturn hip04_data->cpu_base;\n}\n\nstatic inline unsigned int hip04_irq(struct irq_data *d)\n{\n\treturn d->hwirq;\n}\n\n \nstatic void hip04_mask_irq(struct irq_data *d)\n{\n\tu32 mask = 1 << (hip04_irq(d) % 32);\n\n\traw_spin_lock(&irq_controller_lock);\n\twritel_relaxed(mask, hip04_dist_base(d) + GIC_DIST_ENABLE_CLEAR +\n\t\t       (hip04_irq(d) / 32) * 4);\n\traw_spin_unlock(&irq_controller_lock);\n}\n\nstatic void hip04_unmask_irq(struct irq_data *d)\n{\n\tu32 mask = 1 << (hip04_irq(d) % 32);\n\n\traw_spin_lock(&irq_controller_lock);\n\twritel_relaxed(mask, hip04_dist_base(d) + GIC_DIST_ENABLE_SET +\n\t\t       (hip04_irq(d) / 32) * 4);\n\traw_spin_unlock(&irq_controller_lock);\n}\n\nstatic void hip04_eoi_irq(struct irq_data *d)\n{\n\twritel_relaxed(hip04_irq(d), hip04_cpu_base(d) + GIC_CPU_EOI);\n}\n\nstatic int hip04_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tvoid __iomem *base = hip04_dist_base(d);\n\tunsigned int irq = hip04_irq(d);\n\tint ret;\n\n\t \n\tif (irq < 16)\n\t\treturn -EINVAL;\n\n\t \n\tif (irq >= 32 && type != IRQ_TYPE_LEVEL_HIGH &&\n\t\t\t type != IRQ_TYPE_EDGE_RISING)\n\t\treturn -EINVAL;\n\n\traw_spin_lock(&irq_controller_lock);\n\n\tret = gic_configure_irq(irq, type, base + GIC_DIST_CONFIG, NULL);\n\tif (ret && irq < 32) {\n\t\t \n\t\tpr_warn(\"GIC: PPI%d is secure or misconfigured\\n\", irq - 16);\n\t\tret = 0;\n\t}\n\n\traw_spin_unlock(&irq_controller_lock);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_SMP\nstatic int hip04_irq_set_affinity(struct irq_data *d,\n\t\t\t\t  const struct cpumask *mask_val,\n\t\t\t\t  bool force)\n{\n\tvoid __iomem *reg;\n\tunsigned int cpu, shift = (hip04_irq(d) % 2) * 16;\n\tu32 val, mask, bit;\n\n\tif (!force)\n\t\tcpu = cpumask_any_and(mask_val, cpu_online_mask);\n\telse\n\t\tcpu = cpumask_first(mask_val);\n\n\tif (cpu >= NR_HIP04_CPU_IF || cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\traw_spin_lock(&irq_controller_lock);\n\treg = hip04_dist_base(d) + GIC_DIST_TARGET + ((hip04_irq(d) * 2) & ~3);\n\tmask = 0xffff << shift;\n\tbit = hip04_cpu_map[cpu] << shift;\n\tval = readl_relaxed(reg) & ~mask;\n\twritel_relaxed(val | bit, reg);\n\traw_spin_unlock(&irq_controller_lock);\n\n\tirq_data_update_effective_affinity(d, cpumask_of(cpu));\n\n\treturn IRQ_SET_MASK_OK;\n}\n\nstatic void hip04_ipi_send_mask(struct irq_data *d, const struct cpumask *mask)\n{\n\tint cpu;\n\tunsigned long flags, map = 0;\n\n\traw_spin_lock_irqsave(&irq_controller_lock, flags);\n\n\t \n\tfor_each_cpu(cpu, mask)\n\t\tmap |= hip04_cpu_map[cpu];\n\n\t \n\tdmb(ishst);\n\n\t \n\twritel_relaxed(map << 8 | d->hwirq, hip04_data.dist_base + GIC_DIST_SOFTINT);\n\n\traw_spin_unlock_irqrestore(&irq_controller_lock, flags);\n}\n#endif\n\nstatic void __exception_irq_entry hip04_handle_irq(struct pt_regs *regs)\n{\n\tu32 irqstat, irqnr;\n\tvoid __iomem *cpu_base = hip04_data.cpu_base;\n\n\tdo {\n\t\tirqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK);\n\t\tirqnr = irqstat & GICC_IAR_INT_ID_MASK;\n\n\t\tif (irqnr <= HIP04_MAX_IRQS)\n\t\t\tgeneric_handle_domain_irq(hip04_data.domain, irqnr);\n\t} while (irqnr > HIP04_MAX_IRQS);\n}\n\nstatic struct irq_chip hip04_irq_chip = {\n\t.name\t\t\t= \"HIP04 INTC\",\n\t.irq_mask\t\t= hip04_mask_irq,\n\t.irq_unmask\t\t= hip04_unmask_irq,\n\t.irq_eoi\t\t= hip04_eoi_irq,\n\t.irq_set_type\t\t= hip04_irq_set_type,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity\t= hip04_irq_set_affinity,\n\t.ipi_send_mask\t\t= hip04_ipi_send_mask,\n#endif\n\t.flags\t\t\t= IRQCHIP_SET_TYPE_MASKED |\n\t\t\t\t  IRQCHIP_SKIP_SET_WAKE |\n\t\t\t\t  IRQCHIP_MASK_ON_SUSPEND,\n};\n\nstatic u16 hip04_get_cpumask(struct hip04_irq_data *intc)\n{\n\tvoid __iomem *base = intc->dist_base;\n\tu32 mask, i;\n\n\tfor (i = mask = 0; i < 32; i += 2) {\n\t\tmask = readl_relaxed(base + GIC_DIST_TARGET + i * 2);\n\t\tmask |= mask >> 16;\n\t\tif (mask)\n\t\t\tbreak;\n\t}\n\n\tif (!mask)\n\t\tpr_crit(\"GIC CPU mask not found - kernel will fail to boot.\\n\");\n\n\treturn mask;\n}\n\nstatic void __init hip04_irq_dist_init(struct hip04_irq_data *intc)\n{\n\tunsigned int i;\n\tu32 cpumask;\n\tunsigned int nr_irqs = intc->nr_irqs;\n\tvoid __iomem *base = intc->dist_base;\n\n\twritel_relaxed(0, base + GIC_DIST_CTRL);\n\n\t \n\tcpumask = hip04_get_cpumask(intc);\n\tcpumask |= cpumask << 16;\n\tfor (i = 32; i < nr_irqs; i += 2)\n\t\twritel_relaxed(cpumask, base + GIC_DIST_TARGET + ((i * 2) & ~3));\n\n\tgic_dist_config(base, nr_irqs, NULL);\n\n\twritel_relaxed(1, base + GIC_DIST_CTRL);\n}\n\nstatic void hip04_irq_cpu_init(struct hip04_irq_data *intc)\n{\n\tvoid __iomem *dist_base = intc->dist_base;\n\tvoid __iomem *base = intc->cpu_base;\n\tunsigned int cpu_mask, cpu = smp_processor_id();\n\tint i;\n\n\t \n\tBUG_ON(cpu >= NR_HIP04_CPU_IF);\n\tcpu_mask = hip04_get_cpumask(intc);\n\thip04_cpu_map[cpu] = cpu_mask;\n\n\t \n\tfor (i = 0; i < NR_HIP04_CPU_IF; i++)\n\t\tif (i != cpu)\n\t\t\thip04_cpu_map[i] &= ~cpu_mask;\n\n\tgic_cpu_config(dist_base, 32, NULL);\n\n\twritel_relaxed(0xf0, base + GIC_CPU_PRIMASK);\n\twritel_relaxed(1, base + GIC_CPU_CTRL);\n}\n\nstatic int hip04_irq_domain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t\tirq_hw_number_t hw)\n{\n\tif (hw < 32) {\n\t\tirq_set_percpu_devid(irq);\n\t\tirq_set_chip_and_handler(irq, &hip04_irq_chip,\n\t\t\t\t\t handle_percpu_devid_irq);\n\t} else {\n\t\tirq_set_chip_and_handler(irq, &hip04_irq_chip,\n\t\t\t\t\t handle_fasteoi_irq);\n\t\tirq_set_probe(irq);\n\t\tirqd_set_single_target(irq_desc_get_irq_data(irq_to_desc(irq)));\n\t}\n\tirq_set_chip_data(irq, d->host_data);\n\treturn 0;\n}\n\nstatic int hip04_irq_domain_xlate(struct irq_domain *d,\n\t\t\t\t  struct device_node *controller,\n\t\t\t\t  const u32 *intspec, unsigned int intsize,\n\t\t\t\t  unsigned long *out_hwirq,\n\t\t\t\t  unsigned int *out_type)\n{\n\tif (irq_domain_get_of_node(d) != controller)\n\t\treturn -EINVAL;\n\tif (intsize == 1 && intspec[0] < 16) {\n\t\t*out_hwirq = intspec[0];\n\t\t*out_type = IRQ_TYPE_EDGE_RISING;\n\t\treturn 0;\n\t}\n\tif (intsize < 3)\n\t\treturn -EINVAL;\n\n\t \n\t*out_hwirq = intspec[1] + 16;\n\n\t \n\tif (!intspec[0])\n\t\t*out_hwirq += 16;\n\n\t*out_type = intspec[2] & IRQ_TYPE_SENSE_MASK;\n\n\treturn 0;\n}\n\nstatic int hip04_irq_starting_cpu(unsigned int cpu)\n{\n\thip04_irq_cpu_init(&hip04_data);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops hip04_irq_domain_ops = {\n\t.map\t= hip04_irq_domain_map,\n\t.xlate\t= hip04_irq_domain_xlate,\n};\n\nstatic int __init\nhip04_of_init(struct device_node *node, struct device_node *parent)\n{\n\tint nr_irqs, irq_base, i;\n\n\tif (WARN_ON(!node))\n\t\treturn -ENODEV;\n\n\thip04_data.dist_base = of_iomap(node, 0);\n\tWARN(!hip04_data.dist_base, \"fail to map hip04 intc dist registers\\n\");\n\n\thip04_data.cpu_base = of_iomap(node, 1);\n\tWARN(!hip04_data.cpu_base, \"unable to map hip04 intc cpu registers\\n\");\n\n\t \n\tfor (i = 0; i < NR_HIP04_CPU_IF; i++)\n\t\thip04_cpu_map[i] = 0xffff;\n\n\t \n\tnr_irqs = readl_relaxed(hip04_data.dist_base + GIC_DIST_CTR) & 0x1f;\n\tnr_irqs = (nr_irqs + 1) * 32;\n\tif (nr_irqs > HIP04_MAX_IRQS)\n\t\tnr_irqs = HIP04_MAX_IRQS;\n\thip04_data.nr_irqs = nr_irqs;\n\n\tirq_base = irq_alloc_descs(-1, 0, nr_irqs, numa_node_id());\n\tif (irq_base < 0) {\n\t\tpr_err(\"failed to allocate IRQ numbers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thip04_data.domain = irq_domain_add_legacy(node, nr_irqs, irq_base,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  &hip04_irq_domain_ops,\n\t\t\t\t\t\t  &hip04_data);\n\tif (WARN_ON(!hip04_data.domain))\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_SMP\n\tset_smp_ipi_range(irq_base, 16);\n#endif\n\tset_handle_irq(hip04_handle_irq);\n\n\thip04_irq_dist_init(&hip04_data);\n\tcpuhp_setup_state(CPUHP_AP_IRQ_HIP04_STARTING, \"irqchip/hip04:starting\",\n\t\t\t  hip04_irq_starting_cpu, NULL);\n\treturn 0;\n}\nIRQCHIP_DECLARE(hip04_intc, \"hisilicon,hip04-intc\", hip04_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}