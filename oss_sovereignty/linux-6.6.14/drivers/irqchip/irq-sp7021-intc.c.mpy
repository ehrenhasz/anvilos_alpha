{
  "module_name": "irq-sp7021-intc.c",
  "hash_id": "08eeef469e65ffc14c233278df930e565d4904053a223fa816c2dd9c6d869b94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-sp7021-intc.c",
  "human_readable_source": "\n \n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/io.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#define SP_INTC_HWIRQ_MIN\t0\n#define SP_INTC_HWIRQ_MAX\t223\n\n#define SP_INTC_NR_IRQS\t\t(SP_INTC_HWIRQ_MAX - SP_INTC_HWIRQ_MIN + 1)\n#define SP_INTC_NR_GROUPS\tDIV_ROUND_UP(SP_INTC_NR_IRQS, 32)\n#define SP_INTC_REG_SIZE\t(SP_INTC_NR_GROUPS * 4)\n\n \n#define REG_INTR_TYPE\t\t(sp_intc.g0)\n#define REG_INTR_POLARITY\t(REG_INTR_TYPE     + SP_INTC_REG_SIZE)\n#define REG_INTR_PRIORITY\t(REG_INTR_POLARITY + SP_INTC_REG_SIZE)\n#define REG_INTR_MASK\t\t(REG_INTR_PRIORITY + SP_INTC_REG_SIZE)\n\n \n#define REG_INTR_CLEAR\t\t(sp_intc.g1)\n#define REG_MASKED_EXT1\t\t(REG_INTR_CLEAR    + SP_INTC_REG_SIZE)\n#define REG_MASKED_EXT0\t\t(REG_MASKED_EXT1   + SP_INTC_REG_SIZE)\n#define REG_INTR_GROUP\t\t(REG_INTR_CLEAR    + 31 * 4)\n\n#define GROUP_MASK\t\t(BIT(SP_INTC_NR_GROUPS) - 1)\n#define GROUP_SHIFT_EXT1\t(0)\n#define GROUP_SHIFT_EXT0\t(8)\n\n \n#define GPIO_INT0_HWIRQ\t\t120\n#define GPIO_INT7_HWIRQ\t\t127\n#define IS_GPIO_INT(irq)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tu32 i = irq;\t\t\t\t\t\t\\\n\t(i >= GPIO_INT0_HWIRQ) && (i <= GPIO_INT7_HWIRQ);\t\\\n})\n\n \nenum {\n\t_IS_EDGE = 0,\n\t_IS_LOW,\n\t_IS_ACTIVE\n};\n\n#define STATE_BIT(irq, idx)\t\t(((irq) - GPIO_INT0_HWIRQ) * 3 + (idx))\n#define ASSIGN_STATE(irq, idx, v)\tassign_bit(STATE_BIT(irq, idx), sp_intc.states, v)\n#define TEST_STATE(irq, idx)\t\ttest_bit(STATE_BIT(irq, idx), sp_intc.states)\n\nstatic struct sp_intctl {\n\t \n\tvoid __iomem *g0; \n\tvoid __iomem *g1; \n\n\tstruct irq_domain *domain;\n\traw_spinlock_t lock;\n\n\t \n\tDECLARE_BITMAP(states, (GPIO_INT7_HWIRQ - GPIO_INT0_HWIRQ + 1) * 3);\n} sp_intc;\n\nstatic struct irq_chip sp_intc_chip;\n\nstatic void sp_intc_assign_bit(u32 hwirq, void __iomem *base, bool value)\n{\n\tu32 offset, mask;\n\tunsigned long flags;\n\tvoid __iomem *reg;\n\n\toffset = (hwirq / 32) * 4;\n\treg = base + offset;\n\n\traw_spin_lock_irqsave(&sp_intc.lock, flags);\n\tmask = readl_relaxed(reg);\n\tif (value)\n\t\tmask |= BIT(hwirq % 32);\n\telse\n\t\tmask &= ~BIT(hwirq % 32);\n\twritel_relaxed(mask, reg);\n\traw_spin_unlock_irqrestore(&sp_intc.lock, flags);\n}\n\nstatic void sp_intc_ack_irq(struct irq_data *d)\n{\n\tu32 hwirq = d->hwirq;\n\n\tif (unlikely(IS_GPIO_INT(hwirq) && TEST_STATE(hwirq, _IS_EDGE))) { \n\t\tsp_intc_assign_bit(hwirq, REG_INTR_POLARITY, !TEST_STATE(hwirq, _IS_LOW));\n\t\tASSIGN_STATE(hwirq, _IS_ACTIVE, true);\n\t}\n\n\tsp_intc_assign_bit(hwirq, REG_INTR_CLEAR, 1);\n}\n\nstatic void sp_intc_mask_irq(struct irq_data *d)\n{\n\tsp_intc_assign_bit(d->hwirq, REG_INTR_MASK, 0);\n}\n\nstatic void sp_intc_unmask_irq(struct irq_data *d)\n{\n\tsp_intc_assign_bit(d->hwirq, REG_INTR_MASK, 1);\n}\n\nstatic int sp_intc_set_type(struct irq_data *d, unsigned int type)\n{\n\tu32 hwirq = d->hwirq;\n\tbool is_edge = !(type & IRQ_TYPE_LEVEL_MASK);\n\tbool is_low = (type == IRQ_TYPE_LEVEL_LOW || type == IRQ_TYPE_EDGE_FALLING);\n\n\tirq_set_handler_locked(d, is_edge ? handle_edge_irq : handle_level_irq);\n\n\tif (unlikely(IS_GPIO_INT(hwirq) && is_edge)) { \n\t\t \n\t\tASSIGN_STATE(hwirq, _IS_EDGE, is_edge);\n\t\tASSIGN_STATE(hwirq, _IS_LOW, is_low);\n\t\tASSIGN_STATE(hwirq, _IS_ACTIVE, false);\n\t\t \n\t\tis_edge = false;\n\t}\n\n\tsp_intc_assign_bit(hwirq, REG_INTR_TYPE, is_edge);\n\tsp_intc_assign_bit(hwirq, REG_INTR_POLARITY, is_low);\n\n\treturn 0;\n}\n\nstatic int sp_intc_get_ext_irq(int ext_num)\n{\n\tvoid __iomem *base = ext_num ? REG_MASKED_EXT1 : REG_MASKED_EXT0;\n\tu32 shift = ext_num ? GROUP_SHIFT_EXT1 : GROUP_SHIFT_EXT0;\n\tu32 groups;\n\tu32 pending_group;\n\tu32 group;\n\tu32 pending_irq;\n\n\tgroups = readl_relaxed(REG_INTR_GROUP);\n\tpending_group = (groups >> shift) & GROUP_MASK;\n\tif (!pending_group)\n\t\treturn -1;\n\n\tgroup = fls(pending_group) - 1;\n\tpending_irq = readl_relaxed(base + group * 4);\n\tif (!pending_irq)\n\t\treturn -1;\n\n\treturn (group * 32) + fls(pending_irq) - 1;\n}\n\nstatic void sp_intc_handle_ext_cascaded(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tint ext_num = (uintptr_t)irq_desc_get_handler_data(desc);\n\tint hwirq;\n\n\tchained_irq_enter(chip, desc);\n\n\twhile ((hwirq = sp_intc_get_ext_irq(ext_num)) >= 0) {\n\t\tif (unlikely(IS_GPIO_INT(hwirq) && TEST_STATE(hwirq, _IS_ACTIVE))) { \n\t\t\tASSIGN_STATE(hwirq, _IS_ACTIVE, false);\n\t\t\tsp_intc_assign_bit(hwirq, REG_INTR_POLARITY, TEST_STATE(hwirq, _IS_LOW));\n\t\t} else {\n\t\t\tgeneric_handle_domain_irq(sp_intc.domain, hwirq);\n\t\t}\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic struct irq_chip sp_intc_chip = {\n\t.name = \"sp_intc\",\n\t.irq_ack = sp_intc_ack_irq,\n\t.irq_mask = sp_intc_mask_irq,\n\t.irq_unmask = sp_intc_unmask_irq,\n\t.irq_set_type = sp_intc_set_type,\n};\n\nstatic int sp_intc_irq_domain_map(struct irq_domain *domain,\n\t\t\t\t  unsigned int irq, irq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(irq, &sp_intc_chip, handle_level_irq);\n\tirq_set_chip_data(irq, &sp_intc_chip);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops sp_intc_dm_ops = {\n\t.xlate = irq_domain_xlate_twocell,\n\t.map = sp_intc_irq_domain_map,\n};\n\nstatic int sp_intc_irq_map(struct device_node *node, int i)\n{\n\tunsigned int irq;\n\n\tirq = irq_of_parse_and_map(node, i);\n\tif (!irq)\n\t\treturn -ENOENT;\n\n\tirq_set_chained_handler_and_data(irq, sp_intc_handle_ext_cascaded, (void *)(uintptr_t)i);\n\n\treturn 0;\n}\n\nstatic int __init sp_intc_init_dt(struct device_node *node, struct device_node *parent)\n{\n\tint i, ret;\n\n\tsp_intc.g0 = of_iomap(node, 0);\n\tif (!sp_intc.g0)\n\t\treturn -ENXIO;\n\n\tsp_intc.g1 = of_iomap(node, 1);\n\tif (!sp_intc.g1) {\n\t\tret = -ENXIO;\n\t\tgoto out_unmap0;\n\t}\n\n\tret = sp_intc_irq_map(node, 0); \n\tif (ret)\n\t\tgoto out_unmap1;\n\n\tret = sp_intc_irq_map(node, 1); \n\tif (ret)\n\t\tgoto out_unmap1;\n\n\t \n\tfor (i = 0; i < SP_INTC_NR_GROUPS; i++) {\n\t\t \n\t\twritel_relaxed(0, REG_INTR_MASK + i * 4);\n\t\t \n\t\twritel_relaxed(~0, REG_INTR_TYPE + i * 4);\n\t\t \n\t\twritel_relaxed(0, REG_INTR_POLARITY + i * 4);\n\t\t \n\t\twritel_relaxed(~0, REG_INTR_PRIORITY + i * 4);\n\t\t \n\t\twritel_relaxed(~0, REG_INTR_CLEAR + i * 4);\n\t}\n\n\tsp_intc.domain = irq_domain_add_linear(node, SP_INTC_NR_IRQS,\n\t\t\t\t\t       &sp_intc_dm_ops, &sp_intc);\n\tif (!sp_intc.domain) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap1;\n\t}\n\n\traw_spin_lock_init(&sp_intc.lock);\n\n\treturn 0;\n\nout_unmap1:\n\tiounmap(sp_intc.g1);\nout_unmap0:\n\tiounmap(sp_intc.g0);\n\n\treturn ret;\n}\n\nIRQCHIP_DECLARE(sp_intc, \"sunplus,sp7021-intc\", sp_intc_init_dt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}