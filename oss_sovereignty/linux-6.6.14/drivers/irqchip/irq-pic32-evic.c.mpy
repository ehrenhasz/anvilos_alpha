{
  "module_name": "irq-pic32-evic.c",
  "hash_id": "ce2bea24bf9c165857b6035289c79aff6220f9c805ec6906a848c79dfa487f97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-pic32-evic.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/irqchip.h>\n#include <linux/irq.h>\n\n#include <asm/irq.h>\n#include <asm/traps.h>\n#include <asm/mach-pic32/pic32.h>\n\n#define REG_INTCON\t0x0000\n#define REG_INTSTAT\t0x0020\n#define REG_IFS_OFFSET\t0x0040\n#define REG_IEC_OFFSET\t0x00C0\n#define REG_IPC_OFFSET\t0x0140\n#define REG_OFF_OFFSET\t0x0540\n\n#define MAJPRI_MASK\t0x07\n#define SUBPRI_MASK\t0x03\n#define PRIORITY_MASK\t0x1F\n\n#define PIC32_INT_PRI(pri, subpri)\t\t\t\t\\\n\t((((pri) & MAJPRI_MASK) << 2) | ((subpri) & SUBPRI_MASK))\n\nstruct evic_chip_data {\n\tu32 irq_types[NR_IRQS];\n\tu32 ext_irqs[8];\n};\n\nstatic struct irq_domain *evic_irq_domain;\nstatic void __iomem *evic_base;\n\nasmlinkage void __weak plat_irq_dispatch(void)\n{\n\tunsigned int hwirq;\n\n\thwirq = readl(evic_base + REG_INTSTAT) & 0xFF;\n\tdo_domain_IRQ(evic_irq_domain, hwirq);\n}\n\nstatic struct evic_chip_data *irqd_to_priv(struct irq_data *data)\n{\n\treturn (struct evic_chip_data *)data->domain->host_data;\n}\n\nstatic int pic32_set_ext_polarity(int bit, u32 type)\n{\n\t \n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\twritel(BIT(bit), evic_base + PIC32_SET(REG_INTCON));\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\twritel(BIT(bit), evic_base + PIC32_CLR(REG_INTCON));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int pic32_set_type_edge(struct irq_data *data,\n\t\t\t       unsigned int flow_type)\n{\n\tstruct evic_chip_data *priv = irqd_to_priv(data);\n\tint ret;\n\tint i;\n\n\tif (!(flow_type & IRQ_TYPE_EDGE_BOTH))\n\t\treturn -EBADR;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(priv->ext_irqs); i++) {\n\t\tif (priv->ext_irqs[i] == data->hwirq) {\n\t\t\tret = pic32_set_ext_polarity(i, flow_type);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tirqd_set_trigger_type(data, flow_type);\n\n\treturn IRQ_SET_MASK_OK;\n}\n\nstatic void pic32_bind_evic_interrupt(int irq, int set)\n{\n\twritel(set, evic_base + REG_OFF_OFFSET + irq * 4);\n}\n\nstatic void pic32_set_irq_priority(int irq, int priority)\n{\n\tu32 reg, shift;\n\n\treg = irq / 4;\n\tshift = (irq % 4) * 8;\n\n\twritel(PRIORITY_MASK << shift,\n\t\tevic_base + PIC32_CLR(REG_IPC_OFFSET + reg * 0x10));\n\twritel(priority << shift,\n\t\tevic_base + PIC32_SET(REG_IPC_OFFSET + reg * 0x10));\n}\n\n#define IRQ_REG_MASK(_hwirq, _reg, _mask)\t\t       \\\n\tdo {\t\t\t\t\t\t       \\\n\t\t_reg = _hwirq / 32;\t\t\t       \\\n\t\t_mask = 1 << (_hwirq % 32);\t\t       \\\n\t} while (0)\n\nstatic int pic32_irq_domain_map(struct irq_domain *d, unsigned int virq,\n\t\t\t\tirq_hw_number_t hw)\n{\n\tstruct evic_chip_data *priv = d->host_data;\n\tstruct irq_data *data;\n\tint ret;\n\tu32 iecclr, ifsclr;\n\tu32 reg, mask;\n\n\tret = irq_map_generic_chip(d, virq, hw);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (priv->irq_types[hw] & IRQ_TYPE_SENSE_MASK) {\n\t\tdata = irq_domain_get_irq_data(d, virq);\n\t\tirqd_set_trigger_type(data, priv->irq_types[hw]);\n\t\tirq_setup_alt_chip(data, priv->irq_types[hw]);\n\t}\n\n\tIRQ_REG_MASK(hw, reg, mask);\n\n\tiecclr = PIC32_CLR(REG_IEC_OFFSET + reg * 0x10);\n\tifsclr = PIC32_CLR(REG_IFS_OFFSET + reg * 0x10);\n\n\t \n\twritel(mask, evic_base + iecclr);\n\twritel(mask, evic_base + ifsclr);\n\n\t \n\tpic32_set_irq_priority(hw, PIC32_INT_PRI(2, 0));\n\n\treturn ret;\n}\n\nint pic32_irq_domain_xlate(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\t   const u32 *intspec, unsigned int intsize,\n\t\t\t   irq_hw_number_t *out_hwirq, unsigned int *out_type)\n{\n\tstruct evic_chip_data *priv = d->host_data;\n\n\tif (WARN_ON(intsize < 2))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(intspec[0] >= NR_IRQS))\n\t\treturn -EINVAL;\n\n\t*out_hwirq = intspec[0];\n\t*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\n\tpriv->irq_types[intspec[0]] = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops pic32_irq_domain_ops = {\n\t.map\t= pic32_irq_domain_map,\n\t.xlate\t= pic32_irq_domain_xlate,\n};\n\nstatic void __init pic32_ext_irq_of_init(struct irq_domain *domain)\n{\n\tstruct device_node *node = irq_domain_get_of_node(domain);\n\tstruct evic_chip_data *priv = domain->host_data;\n\tstruct property *prop;\n\tconst __le32 *p;\n\tu32 hwirq;\n\tint i = 0;\n\tconst char *pname = \"microchip,external-irqs\";\n\n\tof_property_for_each_u32(node, pname, prop, p, hwirq) {\n\t\tif (i >= ARRAY_SIZE(priv->ext_irqs)) {\n\t\t\tpr_warn(\"More than %d external irq, skip rest\\n\",\n\t\t\t\tARRAY_SIZE(priv->ext_irqs));\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->ext_irqs[i] = hwirq;\n\t\ti++;\n\t}\n}\n\nstatic int __init pic32_of_init(struct device_node *node,\n\t\t\t\tstruct device_node *parent)\n{\n\tstruct irq_chip_generic *gc;\n\tstruct evic_chip_data *priv;\n\tunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\n\tint nchips, ret;\n\tint i;\n\n\tnchips = DIV_ROUND_UP(NR_IRQS, 32);\n\n\tevic_base = of_iomap(node, 0);\n\tif (!evic_base)\n\t\treturn -ENOMEM;\n\n\tpriv = kcalloc(nchips, sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tret = -ENOMEM;\n\t\tgoto err_iounmap;\n\t}\n\n\tevic_irq_domain = irq_domain_add_linear(node, nchips * 32,\n\t\t\t\t\t\t&pic32_irq_domain_ops,\n\t\t\t\t\t\tpriv);\n\tif (!evic_irq_domain) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_priv;\n\t}\n\n\t \n\tret = irq_alloc_domain_generic_chips(evic_irq_domain, 32, 2,\n\t\t\t\t\t     \"evic-level\", handle_level_irq,\n\t\t\t\t\t     clr, 0, 0);\n\tif (ret)\n\t\tgoto err_domain_remove;\n\n\tboard_bind_eic_interrupt = &pic32_bind_evic_interrupt;\n\n\tfor (i = 0; i < nchips; i++) {\n\t\tu32 ifsclr = PIC32_CLR(REG_IFS_OFFSET + (i * 0x10));\n\t\tu32 iec = REG_IEC_OFFSET + (i * 0x10);\n\n\t\tgc = irq_get_domain_generic_chip(evic_irq_domain, i * 32);\n\n\t\tgc->reg_base = evic_base;\n\t\tgc->unused = 0;\n\n\t\t \n\t\tgc->chip_types[0].type\t\t\t= IRQ_TYPE_LEVEL_MASK;\n\t\tgc->chip_types[0].handler\t\t= handle_fasteoi_irq;\n\t\tgc->chip_types[0].regs.ack\t\t= ifsclr;\n\t\tgc->chip_types[0].regs.mask\t\t= iec;\n\t\tgc->chip_types[0].chip.name\t\t= \"evic-level\";\n\t\tgc->chip_types[0].chip.irq_eoi\t\t= irq_gc_ack_set_bit;\n\t\tgc->chip_types[0].chip.irq_mask\t\t= irq_gc_mask_clr_bit;\n\t\tgc->chip_types[0].chip.irq_unmask\t= irq_gc_mask_set_bit;\n\t\tgc->chip_types[0].chip.flags\t\t= IRQCHIP_SKIP_SET_WAKE;\n\n\t\t \n\t\tgc->chip_types[1].type\t\t\t= IRQ_TYPE_EDGE_BOTH;\n\t\tgc->chip_types[1].handler\t\t= handle_edge_irq;\n\t\tgc->chip_types[1].regs.ack\t\t= ifsclr;\n\t\tgc->chip_types[1].regs.mask\t\t= iec;\n\t\tgc->chip_types[1].chip.name\t\t= \"evic-edge\";\n\t\tgc->chip_types[1].chip.irq_ack\t\t= irq_gc_ack_set_bit;\n\t\tgc->chip_types[1].chip.irq_mask\t\t= irq_gc_mask_clr_bit;\n\t\tgc->chip_types[1].chip.irq_unmask\t= irq_gc_mask_set_bit;\n\t\tgc->chip_types[1].chip.irq_set_type\t= pic32_set_type_edge;\n\t\tgc->chip_types[1].chip.flags\t\t= IRQCHIP_SKIP_SET_WAKE;\n\n\t\tgc->private = &priv[i];\n\t}\n\n\tirq_set_default_host(evic_irq_domain);\n\n\t \n\tpic32_ext_irq_of_init(evic_irq_domain);\n\n\treturn 0;\n\nerr_domain_remove:\n\tirq_domain_remove(evic_irq_domain);\n\nerr_free_priv:\n\tkfree(priv);\n\nerr_iounmap:\n\tiounmap(evic_base);\n\n\treturn ret;\n}\n\nIRQCHIP_DECLARE(pic32_evic, \"microchip,pic32mzda-evic\", pic32_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}