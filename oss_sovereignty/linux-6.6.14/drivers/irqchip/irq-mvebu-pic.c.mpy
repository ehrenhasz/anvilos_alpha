{
  "module_name": "irq-mvebu-pic.c",
  "hash_id": "1a3fcff63acda46b0def74c881b84ef9986cb26b20081f8571100f141771c28e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mvebu-pic.c",
  "human_readable_source": " \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n\n#define PIC_CAUSE\t       0x0\n#define PIC_MASK\t       0x4\n\n#define PIC_MAX_IRQS\t\t32\n#define PIC_MAX_IRQ_MASK\t((1UL << PIC_MAX_IRQS) - 1)\n\nstruct mvebu_pic {\n\tvoid __iomem *base;\n\tu32 parent_irq;\n\tstruct irq_domain *domain;\n\tstruct platform_device *pdev;\n};\n\nstatic void mvebu_pic_reset(struct mvebu_pic *pic)\n{\n\t \n\twritel(0, pic->base + PIC_MASK);\n\twritel(PIC_MAX_IRQ_MASK, pic->base + PIC_CAUSE);\n}\n\nstatic void mvebu_pic_eoi_irq(struct irq_data *d)\n{\n\tstruct mvebu_pic *pic = irq_data_get_irq_chip_data(d);\n\n\twritel(1 << d->hwirq, pic->base + PIC_CAUSE);\n}\n\nstatic void mvebu_pic_mask_irq(struct irq_data *d)\n{\n\tstruct mvebu_pic *pic = irq_data_get_irq_chip_data(d);\n\tu32 reg;\n\n\treg =  readl(pic->base + PIC_MASK);\n\treg |= (1 << d->hwirq);\n\twritel(reg, pic->base + PIC_MASK);\n}\n\nstatic void mvebu_pic_unmask_irq(struct irq_data *d)\n{\n\tstruct mvebu_pic *pic = irq_data_get_irq_chip_data(d);\n\tu32 reg;\n\n\treg = readl(pic->base + PIC_MASK);\n\treg &= ~(1 << d->hwirq);\n\twritel(reg, pic->base + PIC_MASK);\n}\n\nstatic void mvebu_pic_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct mvebu_pic *pic = irq_data_get_irq_chip_data(d);\n\n\tseq_printf(p, dev_name(&pic->pdev->dev));\n}\n\nstatic const struct irq_chip mvebu_pic_chip = {\n\t.irq_mask\t= mvebu_pic_mask_irq,\n\t.irq_unmask\t= mvebu_pic_unmask_irq,\n\t.irq_eoi\t= mvebu_pic_eoi_irq,\n\t.irq_print_chip\t= mvebu_pic_print_chip,\n};\n\nstatic int mvebu_pic_irq_map(struct irq_domain *domain, unsigned int virq,\n\t\t\t     irq_hw_number_t hwirq)\n{\n\tstruct mvebu_pic *pic = domain->host_data;\n\n\tirq_set_percpu_devid(virq);\n\tirq_set_chip_data(virq, pic);\n\tirq_set_chip_and_handler(virq, &mvebu_pic_chip, handle_percpu_devid_irq);\n\tirq_set_status_flags(virq, IRQ_LEVEL);\n\tirq_set_probe(virq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mvebu_pic_domain_ops = {\n\t.map = mvebu_pic_irq_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic void mvebu_pic_handle_cascade_irq(struct irq_desc *desc)\n{\n\tstruct mvebu_pic *pic = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned long irqmap, irqn;\n\n\tirqmap = readl_relaxed(pic->base + PIC_CAUSE);\n\tchained_irq_enter(chip, desc);\n\n\tfor_each_set_bit(irqn, &irqmap, BITS_PER_LONG)\n\t\tgeneric_handle_domain_irq(pic->domain, irqn);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void mvebu_pic_enable_percpu_irq(void *data)\n{\n\tstruct mvebu_pic *pic = data;\n\n\tmvebu_pic_reset(pic);\n\tenable_percpu_irq(pic->parent_irq, IRQ_TYPE_NONE);\n}\n\nstatic void mvebu_pic_disable_percpu_irq(void *data)\n{\n\tstruct mvebu_pic *pic = data;\n\n\tdisable_percpu_irq(pic->parent_irq);\n}\n\nstatic int mvebu_pic_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct mvebu_pic *pic;\n\n\tpic = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_pic), GFP_KERNEL);\n\tif (!pic)\n\t\treturn -ENOMEM;\n\n\tpic->pdev = pdev;\n\tpic->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pic->base))\n\t\treturn PTR_ERR(pic->base);\n\n\tpic->parent_irq = irq_of_parse_and_map(node, 0);\n\tif (pic->parent_irq <= 0) {\n\t\tdev_err(&pdev->dev, \"Failed to parse parent interrupt\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpic->domain = irq_domain_add_linear(node, PIC_MAX_IRQS,\n\t\t\t\t\t    &mvebu_pic_domain_ops, pic);\n\tif (!pic->domain) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate irq domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tirq_set_chained_handler(pic->parent_irq, mvebu_pic_handle_cascade_irq);\n\tirq_set_handler_data(pic->parent_irq, pic);\n\n\ton_each_cpu(mvebu_pic_enable_percpu_irq, pic, 1);\n\n\tplatform_set_drvdata(pdev, pic);\n\n\treturn 0;\n}\n\nstatic int mvebu_pic_remove(struct platform_device *pdev)\n{\n\tstruct mvebu_pic *pic = platform_get_drvdata(pdev);\n\n\ton_each_cpu(mvebu_pic_disable_percpu_irq, pic, 1);\n\tirq_domain_remove(pic->domain);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mvebu_pic_of_match[] = {\n\t{ .compatible = \"marvell,armada-8k-pic\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mvebu_pic_of_match);\n\nstatic struct platform_driver mvebu_pic_driver = {\n\t.probe  = mvebu_pic_probe,\n\t.remove = mvebu_pic_remove,\n\t.driver = {\n\t\t.name = \"mvebu-pic\",\n\t\t.of_match_table = mvebu_pic_of_match,\n\t},\n};\nmodule_platform_driver(mvebu_pic_driver);\n\nMODULE_AUTHOR(\"Yehuda Yitschak <yehuday@marvell.com>\");\nMODULE_AUTHOR(\"Thomas Petazzoni <thomas.petazzoni@free-electrons.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:mvebu_pic\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}