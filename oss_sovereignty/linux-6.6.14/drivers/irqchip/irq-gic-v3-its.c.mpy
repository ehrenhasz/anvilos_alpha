{
  "module_name": "irq-gic-v3-its.c",
  "hash_id": "824068efc6ea032ea285a45f5c2dbe0d2aa7a772c43ec55bda42127d059143c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-gic-v3-its.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/acpi_iort.h>\n#include <linux/bitfield.h>\n#include <linux/bitmap.h>\n#include <linux/cpu.h>\n#include <linux/crash_dump.h>\n#include <linux/delay.h>\n#include <linux/efi.h>\n#include <linux/interrupt.h>\n#include <linux/iommu.h>\n#include <linux/iopoll.h>\n#include <linux/irqdomain.h>\n#include <linux/list.h>\n#include <linux/log2.h>\n#include <linux/memblock.h>\n#include <linux/mm.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/syscore_ops.h>\n\n#include <linux/irqchip.h>\n#include <linux/irqchip/arm-gic-v3.h>\n#include <linux/irqchip/arm-gic-v4.h>\n\n#include <asm/cputype.h>\n#include <asm/exception.h>\n\n#include \"irq-gic-common.h\"\n\n#define ITS_FLAGS_CMDQ_NEEDS_FLUSHING\t\t(1ULL << 0)\n#define ITS_FLAGS_WORKAROUND_CAVIUM_22375\t(1ULL << 1)\n#define ITS_FLAGS_WORKAROUND_CAVIUM_23144\t(1ULL << 2)\n#define ITS_FLAGS_FORCE_NON_SHAREABLE\t\t(1ULL << 3)\n\n#define RD_LOCAL_LPI_ENABLED                    BIT(0)\n#define RD_LOCAL_PENDTABLE_PREALLOCATED         BIT(1)\n#define RD_LOCAL_MEMRESERVE_DONE                BIT(2)\n\nstatic u32 lpi_id_bits;\n\n \n#define LPI_NRBITS\t\tlpi_id_bits\n#define LPI_PROPBASE_SZ\t\tALIGN(BIT(LPI_NRBITS), SZ_64K)\n#define LPI_PENDBASE_SZ\t\tALIGN(BIT(LPI_NRBITS) / 8, SZ_64K)\n\n#define LPI_PROP_DEFAULT_PRIO\tGICD_INT_DEF_PRI\n\n \nstruct its_collection {\n\tu64\t\t\ttarget_address;\n\tu16\t\t\tcol_id;\n};\n\n \nstruct its_baser {\n\tvoid\t\t*base;\n\tu64\t\tval;\n\tu32\t\torder;\n\tu32\t\tpsz;\n};\n\nstruct its_device;\n\n \nstruct its_node {\n\traw_spinlock_t\t\tlock;\n\tstruct mutex\t\tdev_alloc_lock;\n\tstruct list_head\tentry;\n\tvoid __iomem\t\t*base;\n\tvoid __iomem\t\t*sgir_base;\n\tphys_addr_t\t\tphys_base;\n\tstruct its_cmd_block\t*cmd_base;\n\tstruct its_cmd_block\t*cmd_write;\n\tstruct its_baser\ttables[GITS_BASER_NR_REGS];\n\tstruct its_collection\t*collections;\n\tstruct fwnode_handle\t*fwnode_handle;\n\tu64\t\t\t(*get_msi_base)(struct its_device *its_dev);\n\tu64\t\t\ttyper;\n\tu64\t\t\tcbaser_save;\n\tu32\t\t\tctlr_save;\n\tu32\t\t\tmpidr;\n\tstruct list_head\tits_device_list;\n\tu64\t\t\tflags;\n\tunsigned long\t\tlist_nr;\n\tint\t\t\tnuma_node;\n\tunsigned int\t\tmsi_domain_flags;\n\tu32\t\t\tpre_its_base;  \n\tint\t\t\tvlpi_redist_offset;\n};\n\n#define is_v4(its)\t\t(!!((its)->typer & GITS_TYPER_VLPIS))\n#define is_v4_1(its)\t\t(!!((its)->typer & GITS_TYPER_VMAPP))\n#define device_ids(its)\t\t(FIELD_GET(GITS_TYPER_DEVBITS, (its)->typer) + 1)\n\n#define ITS_ITT_ALIGN\t\tSZ_256\n\n \n#define ITS_MAX_VPEID_BITS\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tint nvpeid = 16;\t\t\t\t\t\\\n\t\tif (gic_rdists->has_rvpeid &&\t\t\t\t\\\n\t\t    gic_rdists->gicd_typer2 & GICD_TYPER2_VIL)\t\t\\\n\t\t\tnvpeid = 1 + (gic_rdists->gicd_typer2 &\t\t\\\n\t\t\t\t      GICD_TYPER2_VID);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tnvpeid;\t\t\t\t\t\t\t\\\n\t})\n#define ITS_MAX_VPEID\t\t(1 << (ITS_MAX_VPEID_BITS))\n\n \n#define PAGE_ORDER_TO_SIZE(o)\t(PAGE_SIZE << (o))\n\nstruct event_lpi_map {\n\tunsigned long\t\t*lpi_map;\n\tu16\t\t\t*col_map;\n\tirq_hw_number_t\t\tlpi_base;\n\tint\t\t\tnr_lpis;\n\traw_spinlock_t\t\tvlpi_lock;\n\tstruct its_vm\t\t*vm;\n\tstruct its_vlpi_map\t*vlpi_maps;\n\tint\t\t\tnr_vlpis;\n};\n\n \nstruct its_device {\n\tstruct list_head\tentry;\n\tstruct its_node\t\t*its;\n\tstruct event_lpi_map\tevent_map;\n\tvoid\t\t\t*itt;\n\tu32\t\t\tnr_ites;\n\tu32\t\t\tdevice_id;\n\tbool\t\t\tshared;\n};\n\nstatic struct {\n\traw_spinlock_t\t\tlock;\n\tstruct its_device\t*dev;\n\tstruct its_vpe\t\t**vpes;\n\tint\t\t\tnext_victim;\n} vpe_proxy;\n\nstruct cpu_lpi_count {\n\tatomic_t\tmanaged;\n\tatomic_t\tunmanaged;\n};\n\nstatic DEFINE_PER_CPU(struct cpu_lpi_count, cpu_lpi_count);\n\nstatic LIST_HEAD(its_nodes);\nstatic DEFINE_RAW_SPINLOCK(its_lock);\nstatic struct rdists *gic_rdists;\nstatic struct irq_domain *its_parent;\n\nstatic unsigned long its_list_map;\nstatic u16 vmovp_seq_num;\nstatic DEFINE_RAW_SPINLOCK(vmovp_lock);\n\nstatic DEFINE_IDA(its_vpeid_ida);\n\n#define gic_data_rdist()\t\t(raw_cpu_ptr(gic_rdists->rdist))\n#define gic_data_rdist_cpu(cpu)\t\t(per_cpu_ptr(gic_rdists->rdist, cpu))\n#define gic_data_rdist_rd_base()\t(gic_data_rdist()->rd_base)\n#define gic_data_rdist_vlpi_base()\t(gic_data_rdist_rd_base() + SZ_128K)\n\n \nstatic bool require_its_list_vmovp(struct its_vm *vm, struct its_node *its)\n{\n\treturn (gic_rdists->has_rvpeid || vm->vlpi_count[its->list_nr]);\n}\n\nstatic u16 get_its_list(struct its_vm *vm)\n{\n\tstruct its_node *its;\n\tunsigned long its_list = 0;\n\n\tlist_for_each_entry(its, &its_nodes, entry) {\n\t\tif (!is_v4(its))\n\t\t\tcontinue;\n\n\t\tif (require_its_list_vmovp(vm, its))\n\t\t\t__set_bit(its->list_nr, &its_list);\n\t}\n\n\treturn (u16)its_list;\n}\n\nstatic inline u32 its_get_event_id(struct irq_data *d)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\treturn d->hwirq - its_dev->event_map.lpi_base;\n}\n\nstatic struct its_collection *dev_event_to_col(struct its_device *its_dev,\n\t\t\t\t\t       u32 event)\n{\n\tstruct its_node *its = its_dev->its;\n\n\treturn its->collections + its_dev->event_map.col_map[event];\n}\n\nstatic struct its_vlpi_map *dev_event_to_vlpi_map(struct its_device *its_dev,\n\t\t\t\t\t       u32 event)\n{\n\tif (WARN_ON_ONCE(event >= its_dev->event_map.nr_lpis))\n\t\treturn NULL;\n\n\treturn &its_dev->event_map.vlpi_maps[event];\n}\n\nstatic struct its_vlpi_map *get_vlpi_map(struct irq_data *d)\n{\n\tif (irqd_is_forwarded_to_vcpu(d)) {\n\t\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\t\tu32 event = its_get_event_id(d);\n\n\t\treturn dev_event_to_vlpi_map(its_dev, event);\n\t}\n\n\treturn NULL;\n}\n\nstatic int vpe_to_cpuid_lock(struct its_vpe *vpe, unsigned long *flags)\n{\n\traw_spin_lock_irqsave(&vpe->vpe_lock, *flags);\n\treturn vpe->col_idx;\n}\n\nstatic void vpe_to_cpuid_unlock(struct its_vpe *vpe, unsigned long flags)\n{\n\traw_spin_unlock_irqrestore(&vpe->vpe_lock, flags);\n}\n\nstatic struct irq_chip its_vpe_irq_chip;\n\nstatic int irq_to_cpuid_lock(struct irq_data *d, unsigned long *flags)\n{\n\tstruct its_vpe *vpe = NULL;\n\tint cpu;\n\n\tif (d->chip == &its_vpe_irq_chip) {\n\t\tvpe = irq_data_get_irq_chip_data(d);\n\t} else {\n\t\tstruct its_vlpi_map *map = get_vlpi_map(d);\n\t\tif (map)\n\t\t\tvpe = map->vpe;\n\t}\n\n\tif (vpe) {\n\t\tcpu = vpe_to_cpuid_lock(vpe, flags);\n\t} else {\n\t\t \n\t\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\t\tcpu = its_dev->event_map.col_map[its_get_event_id(d)];\n\t\t \n\t\t*flags = 0;\n\t}\n\n\treturn cpu;\n}\n\nstatic void irq_to_cpuid_unlock(struct irq_data *d, unsigned long flags)\n{\n\tstruct its_vpe *vpe = NULL;\n\n\tif (d->chip == &its_vpe_irq_chip) {\n\t\tvpe = irq_data_get_irq_chip_data(d);\n\t} else {\n\t\tstruct its_vlpi_map *map = get_vlpi_map(d);\n\t\tif (map)\n\t\t\tvpe = map->vpe;\n\t}\n\n\tif (vpe)\n\t\tvpe_to_cpuid_unlock(vpe, flags);\n}\n\nstatic struct its_collection *valid_col(struct its_collection *col)\n{\n\tif (WARN_ON_ONCE(col->target_address & GENMASK_ULL(15, 0)))\n\t\treturn NULL;\n\n\treturn col;\n}\n\nstatic struct its_vpe *valid_vpe(struct its_node *its, struct its_vpe *vpe)\n{\n\tif (valid_col(its->collections + vpe->col_idx))\n\t\treturn vpe;\n\n\treturn NULL;\n}\n\n \nstruct its_cmd_desc {\n\tunion {\n\t\tstruct {\n\t\t\tstruct its_device *dev;\n\t\t\tu32 event_id;\n\t\t} its_inv_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_device *dev;\n\t\t\tu32 event_id;\n\t\t} its_clear_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_device *dev;\n\t\t\tu32 event_id;\n\t\t} its_int_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_device *dev;\n\t\t\tint valid;\n\t\t} its_mapd_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_collection *col;\n\t\t\tint valid;\n\t\t} its_mapc_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_device *dev;\n\t\t\tu32 phys_id;\n\t\t\tu32 event_id;\n\t\t} its_mapti_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_device *dev;\n\t\t\tstruct its_collection *col;\n\t\t\tu32 event_id;\n\t\t} its_movi_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_device *dev;\n\t\t\tu32 event_id;\n\t\t} its_discard_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_collection *col;\n\t\t} its_invall_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_vpe *vpe;\n\t\t} its_vinvall_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_vpe *vpe;\n\t\t\tstruct its_collection *col;\n\t\t\tbool valid;\n\t\t} its_vmapp_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_vpe *vpe;\n\t\t\tstruct its_device *dev;\n\t\t\tu32 virt_id;\n\t\t\tu32 event_id;\n\t\t\tbool db_enabled;\n\t\t} its_vmapti_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_vpe *vpe;\n\t\t\tstruct its_device *dev;\n\t\t\tu32 event_id;\n\t\t\tbool db_enabled;\n\t\t} its_vmovi_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_vpe *vpe;\n\t\t\tstruct its_collection *col;\n\t\t\tu16 seq_num;\n\t\t\tu16 its_list;\n\t\t} its_vmovp_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_vpe *vpe;\n\t\t} its_invdb_cmd;\n\n\t\tstruct {\n\t\t\tstruct its_vpe *vpe;\n\t\t\tu8 sgi;\n\t\t\tu8 priority;\n\t\t\tbool enable;\n\t\t\tbool group;\n\t\t\tbool clear;\n\t\t} its_vsgi_cmd;\n\t};\n};\n\n \nstruct its_cmd_block {\n\tunion {\n\t\tu64\traw_cmd[4];\n\t\t__le64\traw_cmd_le[4];\n\t};\n};\n\n#define ITS_CMD_QUEUE_SZ\t\tSZ_64K\n#define ITS_CMD_QUEUE_NR_ENTRIES\t(ITS_CMD_QUEUE_SZ / sizeof(struct its_cmd_block))\n\ntypedef struct its_collection *(*its_cmd_builder_t)(struct its_node *,\n\t\t\t\t\t\t    struct its_cmd_block *,\n\t\t\t\t\t\t    struct its_cmd_desc *);\n\ntypedef struct its_vpe *(*its_cmd_vbuilder_t)(struct its_node *,\n\t\t\t\t\t      struct its_cmd_block *,\n\t\t\t\t\t      struct its_cmd_desc *);\n\nstatic void its_mask_encode(u64 *raw_cmd, u64 val, int h, int l)\n{\n\tu64 mask = GENMASK_ULL(h, l);\n\t*raw_cmd &= ~mask;\n\t*raw_cmd |= (val << l) & mask;\n}\n\nstatic void its_encode_cmd(struct its_cmd_block *cmd, u8 cmd_nr)\n{\n\tits_mask_encode(&cmd->raw_cmd[0], cmd_nr, 7, 0);\n}\n\nstatic void its_encode_devid(struct its_cmd_block *cmd, u32 devid)\n{\n\tits_mask_encode(&cmd->raw_cmd[0], devid, 63, 32);\n}\n\nstatic void its_encode_event_id(struct its_cmd_block *cmd, u32 id)\n{\n\tits_mask_encode(&cmd->raw_cmd[1], id, 31, 0);\n}\n\nstatic void its_encode_phys_id(struct its_cmd_block *cmd, u32 phys_id)\n{\n\tits_mask_encode(&cmd->raw_cmd[1], phys_id, 63, 32);\n}\n\nstatic void its_encode_size(struct its_cmd_block *cmd, u8 size)\n{\n\tits_mask_encode(&cmd->raw_cmd[1], size, 4, 0);\n}\n\nstatic void its_encode_itt(struct its_cmd_block *cmd, u64 itt_addr)\n{\n\tits_mask_encode(&cmd->raw_cmd[2], itt_addr >> 8, 51, 8);\n}\n\nstatic void its_encode_valid(struct its_cmd_block *cmd, int valid)\n{\n\tits_mask_encode(&cmd->raw_cmd[2], !!valid, 63, 63);\n}\n\nstatic void its_encode_target(struct its_cmd_block *cmd, u64 target_addr)\n{\n\tits_mask_encode(&cmd->raw_cmd[2], target_addr >> 16, 51, 16);\n}\n\nstatic void its_encode_collection(struct its_cmd_block *cmd, u16 col)\n{\n\tits_mask_encode(&cmd->raw_cmd[2], col, 15, 0);\n}\n\nstatic void its_encode_vpeid(struct its_cmd_block *cmd, u16 vpeid)\n{\n\tits_mask_encode(&cmd->raw_cmd[1], vpeid, 47, 32);\n}\n\nstatic void its_encode_virt_id(struct its_cmd_block *cmd, u32 virt_id)\n{\n\tits_mask_encode(&cmd->raw_cmd[2], virt_id, 31, 0);\n}\n\nstatic void its_encode_db_phys_id(struct its_cmd_block *cmd, u32 db_phys_id)\n{\n\tits_mask_encode(&cmd->raw_cmd[2], db_phys_id, 63, 32);\n}\n\nstatic void its_encode_db_valid(struct its_cmd_block *cmd, bool db_valid)\n{\n\tits_mask_encode(&cmd->raw_cmd[2], db_valid, 0, 0);\n}\n\nstatic void its_encode_seq_num(struct its_cmd_block *cmd, u16 seq_num)\n{\n\tits_mask_encode(&cmd->raw_cmd[0], seq_num, 47, 32);\n}\n\nstatic void its_encode_its_list(struct its_cmd_block *cmd, u16 its_list)\n{\n\tits_mask_encode(&cmd->raw_cmd[1], its_list, 15, 0);\n}\n\nstatic void its_encode_vpt_addr(struct its_cmd_block *cmd, u64 vpt_pa)\n{\n\tits_mask_encode(&cmd->raw_cmd[3], vpt_pa >> 16, 51, 16);\n}\n\nstatic void its_encode_vpt_size(struct its_cmd_block *cmd, u8 vpt_size)\n{\n\tits_mask_encode(&cmd->raw_cmd[3], vpt_size, 4, 0);\n}\n\nstatic void its_encode_vconf_addr(struct its_cmd_block *cmd, u64 vconf_pa)\n{\n\tits_mask_encode(&cmd->raw_cmd[0], vconf_pa >> 16, 51, 16);\n}\n\nstatic void its_encode_alloc(struct its_cmd_block *cmd, bool alloc)\n{\n\tits_mask_encode(&cmd->raw_cmd[0], alloc, 8, 8);\n}\n\nstatic void its_encode_ptz(struct its_cmd_block *cmd, bool ptz)\n{\n\tits_mask_encode(&cmd->raw_cmd[0], ptz, 9, 9);\n}\n\nstatic void its_encode_vmapp_default_db(struct its_cmd_block *cmd,\n\t\t\t\t\tu32 vpe_db_lpi)\n{\n\tits_mask_encode(&cmd->raw_cmd[1], vpe_db_lpi, 31, 0);\n}\n\nstatic void its_encode_vmovp_default_db(struct its_cmd_block *cmd,\n\t\t\t\t\tu32 vpe_db_lpi)\n{\n\tits_mask_encode(&cmd->raw_cmd[3], vpe_db_lpi, 31, 0);\n}\n\nstatic void its_encode_db(struct its_cmd_block *cmd, bool db)\n{\n\tits_mask_encode(&cmd->raw_cmd[2], db, 63, 63);\n}\n\nstatic void its_encode_sgi_intid(struct its_cmd_block *cmd, u8 sgi)\n{\n\tits_mask_encode(&cmd->raw_cmd[0], sgi, 35, 32);\n}\n\nstatic void its_encode_sgi_priority(struct its_cmd_block *cmd, u8 prio)\n{\n\tits_mask_encode(&cmd->raw_cmd[0], prio >> 4, 23, 20);\n}\n\nstatic void its_encode_sgi_group(struct its_cmd_block *cmd, bool grp)\n{\n\tits_mask_encode(&cmd->raw_cmd[0], grp, 10, 10);\n}\n\nstatic void its_encode_sgi_clear(struct its_cmd_block *cmd, bool clr)\n{\n\tits_mask_encode(&cmd->raw_cmd[0], clr, 9, 9);\n}\n\nstatic void its_encode_sgi_enable(struct its_cmd_block *cmd, bool en)\n{\n\tits_mask_encode(&cmd->raw_cmd[0], en, 8, 8);\n}\n\nstatic inline void its_fixup_cmd(struct its_cmd_block *cmd)\n{\n\t \n\tcmd->raw_cmd_le[0] = cpu_to_le64(cmd->raw_cmd[0]);\n\tcmd->raw_cmd_le[1] = cpu_to_le64(cmd->raw_cmd[1]);\n\tcmd->raw_cmd_le[2] = cpu_to_le64(cmd->raw_cmd[2]);\n\tcmd->raw_cmd_le[3] = cpu_to_le64(cmd->raw_cmd[3]);\n}\n\nstatic struct its_collection *its_build_mapd_cmd(struct its_node *its,\n\t\t\t\t\t\t struct its_cmd_block *cmd,\n\t\t\t\t\t\t struct its_cmd_desc *desc)\n{\n\tunsigned long itt_addr;\n\tu8 size = ilog2(desc->its_mapd_cmd.dev->nr_ites);\n\n\titt_addr = virt_to_phys(desc->its_mapd_cmd.dev->itt);\n\titt_addr = ALIGN(itt_addr, ITS_ITT_ALIGN);\n\n\tits_encode_cmd(cmd, GITS_CMD_MAPD);\n\tits_encode_devid(cmd, desc->its_mapd_cmd.dev->device_id);\n\tits_encode_size(cmd, size - 1);\n\tits_encode_itt(cmd, itt_addr);\n\tits_encode_valid(cmd, desc->its_mapd_cmd.valid);\n\n\tits_fixup_cmd(cmd);\n\n\treturn NULL;\n}\n\nstatic struct its_collection *its_build_mapc_cmd(struct its_node *its,\n\t\t\t\t\t\t struct its_cmd_block *cmd,\n\t\t\t\t\t\t struct its_cmd_desc *desc)\n{\n\tits_encode_cmd(cmd, GITS_CMD_MAPC);\n\tits_encode_collection(cmd, desc->its_mapc_cmd.col->col_id);\n\tits_encode_target(cmd, desc->its_mapc_cmd.col->target_address);\n\tits_encode_valid(cmd, desc->its_mapc_cmd.valid);\n\n\tits_fixup_cmd(cmd);\n\n\treturn desc->its_mapc_cmd.col;\n}\n\nstatic struct its_collection *its_build_mapti_cmd(struct its_node *its,\n\t\t\t\t\t\t  struct its_cmd_block *cmd,\n\t\t\t\t\t\t  struct its_cmd_desc *desc)\n{\n\tstruct its_collection *col;\n\n\tcol = dev_event_to_col(desc->its_mapti_cmd.dev,\n\t\t\t       desc->its_mapti_cmd.event_id);\n\n\tits_encode_cmd(cmd, GITS_CMD_MAPTI);\n\tits_encode_devid(cmd, desc->its_mapti_cmd.dev->device_id);\n\tits_encode_event_id(cmd, desc->its_mapti_cmd.event_id);\n\tits_encode_phys_id(cmd, desc->its_mapti_cmd.phys_id);\n\tits_encode_collection(cmd, col->col_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_col(col);\n}\n\nstatic struct its_collection *its_build_movi_cmd(struct its_node *its,\n\t\t\t\t\t\t struct its_cmd_block *cmd,\n\t\t\t\t\t\t struct its_cmd_desc *desc)\n{\n\tstruct its_collection *col;\n\n\tcol = dev_event_to_col(desc->its_movi_cmd.dev,\n\t\t\t       desc->its_movi_cmd.event_id);\n\n\tits_encode_cmd(cmd, GITS_CMD_MOVI);\n\tits_encode_devid(cmd, desc->its_movi_cmd.dev->device_id);\n\tits_encode_event_id(cmd, desc->its_movi_cmd.event_id);\n\tits_encode_collection(cmd, desc->its_movi_cmd.col->col_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_col(col);\n}\n\nstatic struct its_collection *its_build_discard_cmd(struct its_node *its,\n\t\t\t\t\t\t    struct its_cmd_block *cmd,\n\t\t\t\t\t\t    struct its_cmd_desc *desc)\n{\n\tstruct its_collection *col;\n\n\tcol = dev_event_to_col(desc->its_discard_cmd.dev,\n\t\t\t       desc->its_discard_cmd.event_id);\n\n\tits_encode_cmd(cmd, GITS_CMD_DISCARD);\n\tits_encode_devid(cmd, desc->its_discard_cmd.dev->device_id);\n\tits_encode_event_id(cmd, desc->its_discard_cmd.event_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_col(col);\n}\n\nstatic struct its_collection *its_build_inv_cmd(struct its_node *its,\n\t\t\t\t\t\tstruct its_cmd_block *cmd,\n\t\t\t\t\t\tstruct its_cmd_desc *desc)\n{\n\tstruct its_collection *col;\n\n\tcol = dev_event_to_col(desc->its_inv_cmd.dev,\n\t\t\t       desc->its_inv_cmd.event_id);\n\n\tits_encode_cmd(cmd, GITS_CMD_INV);\n\tits_encode_devid(cmd, desc->its_inv_cmd.dev->device_id);\n\tits_encode_event_id(cmd, desc->its_inv_cmd.event_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_col(col);\n}\n\nstatic struct its_collection *its_build_int_cmd(struct its_node *its,\n\t\t\t\t\t\tstruct its_cmd_block *cmd,\n\t\t\t\t\t\tstruct its_cmd_desc *desc)\n{\n\tstruct its_collection *col;\n\n\tcol = dev_event_to_col(desc->its_int_cmd.dev,\n\t\t\t       desc->its_int_cmd.event_id);\n\n\tits_encode_cmd(cmd, GITS_CMD_INT);\n\tits_encode_devid(cmd, desc->its_int_cmd.dev->device_id);\n\tits_encode_event_id(cmd, desc->its_int_cmd.event_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_col(col);\n}\n\nstatic struct its_collection *its_build_clear_cmd(struct its_node *its,\n\t\t\t\t\t\t  struct its_cmd_block *cmd,\n\t\t\t\t\t\t  struct its_cmd_desc *desc)\n{\n\tstruct its_collection *col;\n\n\tcol = dev_event_to_col(desc->its_clear_cmd.dev,\n\t\t\t       desc->its_clear_cmd.event_id);\n\n\tits_encode_cmd(cmd, GITS_CMD_CLEAR);\n\tits_encode_devid(cmd, desc->its_clear_cmd.dev->device_id);\n\tits_encode_event_id(cmd, desc->its_clear_cmd.event_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_col(col);\n}\n\nstatic struct its_collection *its_build_invall_cmd(struct its_node *its,\n\t\t\t\t\t\t   struct its_cmd_block *cmd,\n\t\t\t\t\t\t   struct its_cmd_desc *desc)\n{\n\tits_encode_cmd(cmd, GITS_CMD_INVALL);\n\tits_encode_collection(cmd, desc->its_invall_cmd.col->col_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn desc->its_invall_cmd.col;\n}\n\nstatic struct its_vpe *its_build_vinvall_cmd(struct its_node *its,\n\t\t\t\t\t     struct its_cmd_block *cmd,\n\t\t\t\t\t     struct its_cmd_desc *desc)\n{\n\tits_encode_cmd(cmd, GITS_CMD_VINVALL);\n\tits_encode_vpeid(cmd, desc->its_vinvall_cmd.vpe->vpe_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_vpe(its, desc->its_vinvall_cmd.vpe);\n}\n\nstatic struct its_vpe *its_build_vmapp_cmd(struct its_node *its,\n\t\t\t\t\t   struct its_cmd_block *cmd,\n\t\t\t\t\t   struct its_cmd_desc *desc)\n{\n\tunsigned long vpt_addr, vconf_addr;\n\tu64 target;\n\tbool alloc;\n\n\tits_encode_cmd(cmd, GITS_CMD_VMAPP);\n\tits_encode_vpeid(cmd, desc->its_vmapp_cmd.vpe->vpe_id);\n\tits_encode_valid(cmd, desc->its_vmapp_cmd.valid);\n\n\tif (!desc->its_vmapp_cmd.valid) {\n\t\tif (is_v4_1(its)) {\n\t\t\talloc = !atomic_dec_return(&desc->its_vmapp_cmd.vpe->vmapp_count);\n\t\t\tits_encode_alloc(cmd, alloc);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tvpt_addr = virt_to_phys(page_address(desc->its_vmapp_cmd.vpe->vpt_page));\n\ttarget = desc->its_vmapp_cmd.col->target_address + its->vlpi_redist_offset;\n\n\tits_encode_target(cmd, target);\n\tits_encode_vpt_addr(cmd, vpt_addr);\n\tits_encode_vpt_size(cmd, LPI_NRBITS - 1);\n\n\tif (!is_v4_1(its))\n\t\tgoto out;\n\n\tvconf_addr = virt_to_phys(page_address(desc->its_vmapp_cmd.vpe->its_vm->vprop_page));\n\n\talloc = !atomic_fetch_inc(&desc->its_vmapp_cmd.vpe->vmapp_count);\n\n\tits_encode_alloc(cmd, alloc);\n\n\t \n\tits_encode_ptz(cmd, false);\n\tits_encode_vconf_addr(cmd, vconf_addr);\n\tits_encode_vmapp_default_db(cmd, desc->its_vmapp_cmd.vpe->vpe_db_lpi);\n\nout:\n\tits_fixup_cmd(cmd);\n\n\treturn valid_vpe(its, desc->its_vmapp_cmd.vpe);\n}\n\nstatic struct its_vpe *its_build_vmapti_cmd(struct its_node *its,\n\t\t\t\t\t    struct its_cmd_block *cmd,\n\t\t\t\t\t    struct its_cmd_desc *desc)\n{\n\tu32 db;\n\n\tif (!is_v4_1(its) && desc->its_vmapti_cmd.db_enabled)\n\t\tdb = desc->its_vmapti_cmd.vpe->vpe_db_lpi;\n\telse\n\t\tdb = 1023;\n\n\tits_encode_cmd(cmd, GITS_CMD_VMAPTI);\n\tits_encode_devid(cmd, desc->its_vmapti_cmd.dev->device_id);\n\tits_encode_vpeid(cmd, desc->its_vmapti_cmd.vpe->vpe_id);\n\tits_encode_event_id(cmd, desc->its_vmapti_cmd.event_id);\n\tits_encode_db_phys_id(cmd, db);\n\tits_encode_virt_id(cmd, desc->its_vmapti_cmd.virt_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_vpe(its, desc->its_vmapti_cmd.vpe);\n}\n\nstatic struct its_vpe *its_build_vmovi_cmd(struct its_node *its,\n\t\t\t\t\t   struct its_cmd_block *cmd,\n\t\t\t\t\t   struct its_cmd_desc *desc)\n{\n\tu32 db;\n\n\tif (!is_v4_1(its) && desc->its_vmovi_cmd.db_enabled)\n\t\tdb = desc->its_vmovi_cmd.vpe->vpe_db_lpi;\n\telse\n\t\tdb = 1023;\n\n\tits_encode_cmd(cmd, GITS_CMD_VMOVI);\n\tits_encode_devid(cmd, desc->its_vmovi_cmd.dev->device_id);\n\tits_encode_vpeid(cmd, desc->its_vmovi_cmd.vpe->vpe_id);\n\tits_encode_event_id(cmd, desc->its_vmovi_cmd.event_id);\n\tits_encode_db_phys_id(cmd, db);\n\tits_encode_db_valid(cmd, true);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_vpe(its, desc->its_vmovi_cmd.vpe);\n}\n\nstatic struct its_vpe *its_build_vmovp_cmd(struct its_node *its,\n\t\t\t\t\t   struct its_cmd_block *cmd,\n\t\t\t\t\t   struct its_cmd_desc *desc)\n{\n\tu64 target;\n\n\ttarget = desc->its_vmovp_cmd.col->target_address + its->vlpi_redist_offset;\n\tits_encode_cmd(cmd, GITS_CMD_VMOVP);\n\tits_encode_seq_num(cmd, desc->its_vmovp_cmd.seq_num);\n\tits_encode_its_list(cmd, desc->its_vmovp_cmd.its_list);\n\tits_encode_vpeid(cmd, desc->its_vmovp_cmd.vpe->vpe_id);\n\tits_encode_target(cmd, target);\n\n\tif (is_v4_1(its)) {\n\t\tits_encode_db(cmd, true);\n\t\tits_encode_vmovp_default_db(cmd, desc->its_vmovp_cmd.vpe->vpe_db_lpi);\n\t}\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_vpe(its, desc->its_vmovp_cmd.vpe);\n}\n\nstatic struct its_vpe *its_build_vinv_cmd(struct its_node *its,\n\t\t\t\t\t  struct its_cmd_block *cmd,\n\t\t\t\t\t  struct its_cmd_desc *desc)\n{\n\tstruct its_vlpi_map *map;\n\n\tmap = dev_event_to_vlpi_map(desc->its_inv_cmd.dev,\n\t\t\t\t    desc->its_inv_cmd.event_id);\n\n\tits_encode_cmd(cmd, GITS_CMD_INV);\n\tits_encode_devid(cmd, desc->its_inv_cmd.dev->device_id);\n\tits_encode_event_id(cmd, desc->its_inv_cmd.event_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_vpe(its, map->vpe);\n}\n\nstatic struct its_vpe *its_build_vint_cmd(struct its_node *its,\n\t\t\t\t\t  struct its_cmd_block *cmd,\n\t\t\t\t\t  struct its_cmd_desc *desc)\n{\n\tstruct its_vlpi_map *map;\n\n\tmap = dev_event_to_vlpi_map(desc->its_int_cmd.dev,\n\t\t\t\t    desc->its_int_cmd.event_id);\n\n\tits_encode_cmd(cmd, GITS_CMD_INT);\n\tits_encode_devid(cmd, desc->its_int_cmd.dev->device_id);\n\tits_encode_event_id(cmd, desc->its_int_cmd.event_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_vpe(its, map->vpe);\n}\n\nstatic struct its_vpe *its_build_vclear_cmd(struct its_node *its,\n\t\t\t\t\t    struct its_cmd_block *cmd,\n\t\t\t\t\t    struct its_cmd_desc *desc)\n{\n\tstruct its_vlpi_map *map;\n\n\tmap = dev_event_to_vlpi_map(desc->its_clear_cmd.dev,\n\t\t\t\t    desc->its_clear_cmd.event_id);\n\n\tits_encode_cmd(cmd, GITS_CMD_CLEAR);\n\tits_encode_devid(cmd, desc->its_clear_cmd.dev->device_id);\n\tits_encode_event_id(cmd, desc->its_clear_cmd.event_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_vpe(its, map->vpe);\n}\n\nstatic struct its_vpe *its_build_invdb_cmd(struct its_node *its,\n\t\t\t\t\t   struct its_cmd_block *cmd,\n\t\t\t\t\t   struct its_cmd_desc *desc)\n{\n\tif (WARN_ON(!is_v4_1(its)))\n\t\treturn NULL;\n\n\tits_encode_cmd(cmd, GITS_CMD_INVDB);\n\tits_encode_vpeid(cmd, desc->its_invdb_cmd.vpe->vpe_id);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_vpe(its, desc->its_invdb_cmd.vpe);\n}\n\nstatic struct its_vpe *its_build_vsgi_cmd(struct its_node *its,\n\t\t\t\t\t  struct its_cmd_block *cmd,\n\t\t\t\t\t  struct its_cmd_desc *desc)\n{\n\tif (WARN_ON(!is_v4_1(its)))\n\t\treturn NULL;\n\n\tits_encode_cmd(cmd, GITS_CMD_VSGI);\n\tits_encode_vpeid(cmd, desc->its_vsgi_cmd.vpe->vpe_id);\n\tits_encode_sgi_intid(cmd, desc->its_vsgi_cmd.sgi);\n\tits_encode_sgi_priority(cmd, desc->its_vsgi_cmd.priority);\n\tits_encode_sgi_group(cmd, desc->its_vsgi_cmd.group);\n\tits_encode_sgi_clear(cmd, desc->its_vsgi_cmd.clear);\n\tits_encode_sgi_enable(cmd, desc->its_vsgi_cmd.enable);\n\n\tits_fixup_cmd(cmd);\n\n\treturn valid_vpe(its, desc->its_vsgi_cmd.vpe);\n}\n\nstatic u64 its_cmd_ptr_to_offset(struct its_node *its,\n\t\t\t\t struct its_cmd_block *ptr)\n{\n\treturn (ptr - its->cmd_base) * sizeof(*ptr);\n}\n\nstatic int its_queue_full(struct its_node *its)\n{\n\tint widx;\n\tint ridx;\n\n\twidx = its->cmd_write - its->cmd_base;\n\tridx = readl_relaxed(its->base + GITS_CREADR) / sizeof(struct its_cmd_block);\n\n\t \n\tif (((widx + 1) % ITS_CMD_QUEUE_NR_ENTRIES) == ridx)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct its_cmd_block *its_allocate_entry(struct its_node *its)\n{\n\tstruct its_cmd_block *cmd;\n\tu32 count = 1000000;\t \n\n\twhile (its_queue_full(its)) {\n\t\tcount--;\n\t\tif (!count) {\n\t\t\tpr_err_ratelimited(\"ITS queue not draining\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tcpu_relax();\n\t\tudelay(1);\n\t}\n\n\tcmd = its->cmd_write++;\n\n\t \n\tif (its->cmd_write == (its->cmd_base + ITS_CMD_QUEUE_NR_ENTRIES))\n\t\tits->cmd_write = its->cmd_base;\n\n\t \n\tcmd->raw_cmd[0] = 0;\n\tcmd->raw_cmd[1] = 0;\n\tcmd->raw_cmd[2] = 0;\n\tcmd->raw_cmd[3] = 0;\n\n\treturn cmd;\n}\n\nstatic struct its_cmd_block *its_post_commands(struct its_node *its)\n{\n\tu64 wr = its_cmd_ptr_to_offset(its, its->cmd_write);\n\n\twritel_relaxed(wr, its->base + GITS_CWRITER);\n\n\treturn its->cmd_write;\n}\n\nstatic void its_flush_cmd(struct its_node *its, struct its_cmd_block *cmd)\n{\n\t \n\tif (its->flags & ITS_FLAGS_CMDQ_NEEDS_FLUSHING)\n\t\tgic_flush_dcache_to_poc(cmd, sizeof(*cmd));\n\telse\n\t\tdsb(ishst);\n}\n\nstatic int its_wait_for_range_completion(struct its_node *its,\n\t\t\t\t\t u64\tprev_idx,\n\t\t\t\t\t struct its_cmd_block *to)\n{\n\tu64 rd_idx, to_idx, linear_idx;\n\tu32 count = 1000000;\t \n\n\t \n\tto_idx = its_cmd_ptr_to_offset(its, to);\n\tif (to_idx < prev_idx)\n\t\tto_idx += ITS_CMD_QUEUE_SZ;\n\n\tlinear_idx = prev_idx;\n\n\twhile (1) {\n\t\ts64 delta;\n\n\t\trd_idx = readl_relaxed(its->base + GITS_CREADR);\n\n\t\t \n\t\tdelta = rd_idx - prev_idx;\n\t\tif (rd_idx < prev_idx)\n\t\t\tdelta += ITS_CMD_QUEUE_SZ;\n\n\t\tlinear_idx += delta;\n\t\tif (linear_idx >= to_idx)\n\t\t\tbreak;\n\n\t\tcount--;\n\t\tif (!count) {\n\t\t\tpr_err_ratelimited(\"ITS queue timeout (%llu %llu)\\n\",\n\t\t\t\t\t   to_idx, linear_idx);\n\t\t\treturn -1;\n\t\t}\n\t\tprev_idx = rd_idx;\n\t\tcpu_relax();\n\t\tudelay(1);\n\t}\n\n\treturn 0;\n}\n\n \n#define BUILD_SINGLE_CMD_FUNC(name, buildtype, synctype, buildfn)\t\\\nvoid name(struct its_node *its,\t\t\t\t\t\t\\\n\t  buildtype builder,\t\t\t\t\t\t\\\n\t  struct its_cmd_desc *desc)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct its_cmd_block *cmd, *sync_cmd, *next_cmd;\t\t\\\n\tsynctype *sync_obj;\t\t\t\t\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\tu64 rd_idx;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\traw_spin_lock_irqsave(&its->lock, flags);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tcmd = its_allocate_entry(its);\t\t\t\t\t\\\n\tif (!cmd) {\t\t \t\t\\\n\t\traw_spin_unlock_irqrestore(&its->lock, flags);\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tsync_obj = builder(its, cmd, desc);\t\t\t\t\\\n\tits_flush_cmd(its, cmd);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (sync_obj) {\t\t\t\t\t\t\t\\\n\t\tsync_cmd = its_allocate_entry(its);\t\t\t\\\n\t\tif (!sync_cmd)\t\t\t\t\t\t\\\n\t\t\tgoto post;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tbuildfn(its, sync_cmd, sync_obj);\t\t\t\\\n\t\tits_flush_cmd(its, sync_cmd);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\npost:\t\t\t\t\t\t\t\t\t\\\n\trd_idx = readl_relaxed(its->base + GITS_CREADR);\t\t\\\n\tnext_cmd = its_post_commands(its);\t\t\t\t\\\n\traw_spin_unlock_irqrestore(&its->lock, flags);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (its_wait_for_range_completion(its, rd_idx, next_cmd))\t\\\n\t\tpr_err_ratelimited(\"ITS cmd %ps failed\\n\", builder);\t\\\n}\n\nstatic void its_build_sync_cmd(struct its_node *its,\n\t\t\t       struct its_cmd_block *sync_cmd,\n\t\t\t       struct its_collection *sync_col)\n{\n\tits_encode_cmd(sync_cmd, GITS_CMD_SYNC);\n\tits_encode_target(sync_cmd, sync_col->target_address);\n\n\tits_fixup_cmd(sync_cmd);\n}\n\nstatic BUILD_SINGLE_CMD_FUNC(its_send_single_command, its_cmd_builder_t,\n\t\t\t     struct its_collection, its_build_sync_cmd)\n\nstatic void its_build_vsync_cmd(struct its_node *its,\n\t\t\t\tstruct its_cmd_block *sync_cmd,\n\t\t\t\tstruct its_vpe *sync_vpe)\n{\n\tits_encode_cmd(sync_cmd, GITS_CMD_VSYNC);\n\tits_encode_vpeid(sync_cmd, sync_vpe->vpe_id);\n\n\tits_fixup_cmd(sync_cmd);\n}\n\nstatic BUILD_SINGLE_CMD_FUNC(its_send_single_vcommand, its_cmd_vbuilder_t,\n\t\t\t     struct its_vpe, its_build_vsync_cmd)\n\nstatic void its_send_int(struct its_device *dev, u32 event_id)\n{\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_int_cmd.dev = dev;\n\tdesc.its_int_cmd.event_id = event_id;\n\n\tits_send_single_command(dev->its, its_build_int_cmd, &desc);\n}\n\nstatic void its_send_clear(struct its_device *dev, u32 event_id)\n{\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_clear_cmd.dev = dev;\n\tdesc.its_clear_cmd.event_id = event_id;\n\n\tits_send_single_command(dev->its, its_build_clear_cmd, &desc);\n}\n\nstatic void its_send_inv(struct its_device *dev, u32 event_id)\n{\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_inv_cmd.dev = dev;\n\tdesc.its_inv_cmd.event_id = event_id;\n\n\tits_send_single_command(dev->its, its_build_inv_cmd, &desc);\n}\n\nstatic void its_send_mapd(struct its_device *dev, int valid)\n{\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_mapd_cmd.dev = dev;\n\tdesc.its_mapd_cmd.valid = !!valid;\n\n\tits_send_single_command(dev->its, its_build_mapd_cmd, &desc);\n}\n\nstatic void its_send_mapc(struct its_node *its, struct its_collection *col,\n\t\t\t  int valid)\n{\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_mapc_cmd.col = col;\n\tdesc.its_mapc_cmd.valid = !!valid;\n\n\tits_send_single_command(its, its_build_mapc_cmd, &desc);\n}\n\nstatic void its_send_mapti(struct its_device *dev, u32 irq_id, u32 id)\n{\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_mapti_cmd.dev = dev;\n\tdesc.its_mapti_cmd.phys_id = irq_id;\n\tdesc.its_mapti_cmd.event_id = id;\n\n\tits_send_single_command(dev->its, its_build_mapti_cmd, &desc);\n}\n\nstatic void its_send_movi(struct its_device *dev,\n\t\t\t  struct its_collection *col, u32 id)\n{\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_movi_cmd.dev = dev;\n\tdesc.its_movi_cmd.col = col;\n\tdesc.its_movi_cmd.event_id = id;\n\n\tits_send_single_command(dev->its, its_build_movi_cmd, &desc);\n}\n\nstatic void its_send_discard(struct its_device *dev, u32 id)\n{\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_discard_cmd.dev = dev;\n\tdesc.its_discard_cmd.event_id = id;\n\n\tits_send_single_command(dev->its, its_build_discard_cmd, &desc);\n}\n\nstatic void its_send_invall(struct its_node *its, struct its_collection *col)\n{\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_invall_cmd.col = col;\n\n\tits_send_single_command(its, its_build_invall_cmd, &desc);\n}\n\nstatic void its_send_vmapti(struct its_device *dev, u32 id)\n{\n\tstruct its_vlpi_map *map = dev_event_to_vlpi_map(dev, id);\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_vmapti_cmd.vpe = map->vpe;\n\tdesc.its_vmapti_cmd.dev = dev;\n\tdesc.its_vmapti_cmd.virt_id = map->vintid;\n\tdesc.its_vmapti_cmd.event_id = id;\n\tdesc.its_vmapti_cmd.db_enabled = map->db_enabled;\n\n\tits_send_single_vcommand(dev->its, its_build_vmapti_cmd, &desc);\n}\n\nstatic void its_send_vmovi(struct its_device *dev, u32 id)\n{\n\tstruct its_vlpi_map *map = dev_event_to_vlpi_map(dev, id);\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_vmovi_cmd.vpe = map->vpe;\n\tdesc.its_vmovi_cmd.dev = dev;\n\tdesc.its_vmovi_cmd.event_id = id;\n\tdesc.its_vmovi_cmd.db_enabled = map->db_enabled;\n\n\tits_send_single_vcommand(dev->its, its_build_vmovi_cmd, &desc);\n}\n\nstatic void its_send_vmapp(struct its_node *its,\n\t\t\t   struct its_vpe *vpe, bool valid)\n{\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_vmapp_cmd.vpe = vpe;\n\tdesc.its_vmapp_cmd.valid = valid;\n\tdesc.its_vmapp_cmd.col = &its->collections[vpe->col_idx];\n\n\tits_send_single_vcommand(its, its_build_vmapp_cmd, &desc);\n}\n\nstatic void its_send_vmovp(struct its_vpe *vpe)\n{\n\tstruct its_cmd_desc desc = {};\n\tstruct its_node *its;\n\tunsigned long flags;\n\tint col_id = vpe->col_idx;\n\n\tdesc.its_vmovp_cmd.vpe = vpe;\n\n\tif (!its_list_map) {\n\t\tits = list_first_entry(&its_nodes, struct its_node, entry);\n\t\tdesc.its_vmovp_cmd.col = &its->collections[col_id];\n\t\tits_send_single_vcommand(its, its_build_vmovp_cmd, &desc);\n\t\treturn;\n\t}\n\n\t \n\traw_spin_lock_irqsave(&vmovp_lock, flags);\n\n\tdesc.its_vmovp_cmd.seq_num = vmovp_seq_num++;\n\tdesc.its_vmovp_cmd.its_list = get_its_list(vpe->its_vm);\n\n\t \n\tlist_for_each_entry(its, &its_nodes, entry) {\n\t\tif (!is_v4(its))\n\t\t\tcontinue;\n\n\t\tif (!require_its_list_vmovp(vpe->its_vm, its))\n\t\t\tcontinue;\n\n\t\tdesc.its_vmovp_cmd.col = &its->collections[col_id];\n\t\tits_send_single_vcommand(its, its_build_vmovp_cmd, &desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&vmovp_lock, flags);\n}\n\nstatic void its_send_vinvall(struct its_node *its, struct its_vpe *vpe)\n{\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_vinvall_cmd.vpe = vpe;\n\tits_send_single_vcommand(its, its_build_vinvall_cmd, &desc);\n}\n\nstatic void its_send_vinv(struct its_device *dev, u32 event_id)\n{\n\tstruct its_cmd_desc desc;\n\n\t \n\tdesc.its_inv_cmd.dev = dev;\n\tdesc.its_inv_cmd.event_id = event_id;\n\n\tits_send_single_vcommand(dev->its, its_build_vinv_cmd, &desc);\n}\n\nstatic void its_send_vint(struct its_device *dev, u32 event_id)\n{\n\tstruct its_cmd_desc desc;\n\n\t \n\tdesc.its_int_cmd.dev = dev;\n\tdesc.its_int_cmd.event_id = event_id;\n\n\tits_send_single_vcommand(dev->its, its_build_vint_cmd, &desc);\n}\n\nstatic void its_send_vclear(struct its_device *dev, u32 event_id)\n{\n\tstruct its_cmd_desc desc;\n\n\t \n\tdesc.its_clear_cmd.dev = dev;\n\tdesc.its_clear_cmd.event_id = event_id;\n\n\tits_send_single_vcommand(dev->its, its_build_vclear_cmd, &desc);\n}\n\nstatic void its_send_invdb(struct its_node *its, struct its_vpe *vpe)\n{\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_invdb_cmd.vpe = vpe;\n\tits_send_single_vcommand(its, its_build_invdb_cmd, &desc);\n}\n\n \nstatic void lpi_write_config(struct irq_data *d, u8 clr, u8 set)\n{\n\tstruct its_vlpi_map *map = get_vlpi_map(d);\n\tirq_hw_number_t hwirq;\n\tvoid *va;\n\tu8 *cfg;\n\n\tif (map) {\n\t\tva = page_address(map->vm->vprop_page);\n\t\thwirq = map->vintid;\n\n\t\t \n\t\tmap->properties &= ~clr;\n\t\tmap->properties |= set | LPI_PROP_GROUP1;\n\t} else {\n\t\tva = gic_rdists->prop_table_va;\n\t\thwirq = d->hwirq;\n\t}\n\n\tcfg = va + hwirq - 8192;\n\t*cfg &= ~clr;\n\t*cfg |= set | LPI_PROP_GROUP1;\n\n\t \n\tif (gic_rdists->flags & RDIST_FLAGS_PROPBASE_NEEDS_FLUSHING)\n\t\tgic_flush_dcache_to_poc(cfg, sizeof(*cfg));\n\telse\n\t\tdsb(ishst);\n}\n\nstatic void wait_for_syncr(void __iomem *rdbase)\n{\n\twhile (readl_relaxed(rdbase + GICR_SYNCR) & 1)\n\t\tcpu_relax();\n}\n\nstatic void __direct_lpi_inv(struct irq_data *d, u64 val)\n{\n\tvoid __iomem *rdbase;\n\tunsigned long flags;\n\tint cpu;\n\n\t \n\tcpu = irq_to_cpuid_lock(d, &flags);\n\traw_spin_lock(&gic_data_rdist_cpu(cpu)->rd_lock);\n\n\trdbase = per_cpu_ptr(gic_rdists->rdist, cpu)->rd_base;\n\tgic_write_lpir(val, rdbase + GICR_INVLPIR);\n\twait_for_syncr(rdbase);\n\n\traw_spin_unlock(&gic_data_rdist_cpu(cpu)->rd_lock);\n\tirq_to_cpuid_unlock(d, flags);\n}\n\nstatic void direct_lpi_inv(struct irq_data *d)\n{\n\tstruct its_vlpi_map *map = get_vlpi_map(d);\n\tu64 val;\n\n\tif (map) {\n\t\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\n\t\tWARN_ON(!is_v4_1(its_dev->its));\n\n\t\tval  = GICR_INVLPIR_V;\n\t\tval |= FIELD_PREP(GICR_INVLPIR_VPEID, map->vpe->vpe_id);\n\t\tval |= FIELD_PREP(GICR_INVLPIR_INTID, map->vintid);\n\t} else {\n\t\tval = d->hwirq;\n\t}\n\n\t__direct_lpi_inv(d, val);\n}\n\nstatic void lpi_update_config(struct irq_data *d, u8 clr, u8 set)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\n\tlpi_write_config(d, clr, set);\n\tif (gic_rdists->has_direct_lpi &&\n\t    (is_v4_1(its_dev->its) || !irqd_is_forwarded_to_vcpu(d)))\n\t\tdirect_lpi_inv(d);\n\telse if (!irqd_is_forwarded_to_vcpu(d))\n\t\tits_send_inv(its_dev, its_get_event_id(d));\n\telse\n\t\tits_send_vinv(its_dev, its_get_event_id(d));\n}\n\nstatic void its_vlpi_set_doorbell(struct irq_data *d, bool enable)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\tu32 event = its_get_event_id(d);\n\tstruct its_vlpi_map *map;\n\n\t \n\tif (is_v4_1(its_dev->its))\n\t\treturn;\n\n\tmap = dev_event_to_vlpi_map(its_dev, event);\n\n\tif (map->db_enabled == enable)\n\t\treturn;\n\n\tmap->db_enabled = enable;\n\n\t \n\tits_send_vmovi(its_dev, event);\n}\n\nstatic void its_mask_irq(struct irq_data *d)\n{\n\tif (irqd_is_forwarded_to_vcpu(d))\n\t\tits_vlpi_set_doorbell(d, false);\n\n\tlpi_update_config(d, LPI_PROP_ENABLED, 0);\n}\n\nstatic void its_unmask_irq(struct irq_data *d)\n{\n\tif (irqd_is_forwarded_to_vcpu(d))\n\t\tits_vlpi_set_doorbell(d, true);\n\n\tlpi_update_config(d, 0, LPI_PROP_ENABLED);\n}\n\nstatic __maybe_unused u32 its_read_lpi_count(struct irq_data *d, int cpu)\n{\n\tif (irqd_affinity_is_managed(d))\n\t\treturn atomic_read(&per_cpu_ptr(&cpu_lpi_count, cpu)->managed);\n\n\treturn atomic_read(&per_cpu_ptr(&cpu_lpi_count, cpu)->unmanaged);\n}\n\nstatic void its_inc_lpi_count(struct irq_data *d, int cpu)\n{\n\tif (irqd_affinity_is_managed(d))\n\t\tatomic_inc(&per_cpu_ptr(&cpu_lpi_count, cpu)->managed);\n\telse\n\t\tatomic_inc(&per_cpu_ptr(&cpu_lpi_count, cpu)->unmanaged);\n}\n\nstatic void its_dec_lpi_count(struct irq_data *d, int cpu)\n{\n\tif (irqd_affinity_is_managed(d))\n\t\tatomic_dec(&per_cpu_ptr(&cpu_lpi_count, cpu)->managed);\n\telse\n\t\tatomic_dec(&per_cpu_ptr(&cpu_lpi_count, cpu)->unmanaged);\n}\n\nstatic unsigned int cpumask_pick_least_loaded(struct irq_data *d,\n\t\t\t\t\t      const struct cpumask *cpu_mask)\n{\n\tunsigned int cpu = nr_cpu_ids, tmp;\n\tint count = S32_MAX;\n\n\tfor_each_cpu(tmp, cpu_mask) {\n\t\tint this_count = its_read_lpi_count(d, tmp);\n\t\tif (this_count < count) {\n\t\t\tcpu = tmp;\n\t\t        count = this_count;\n\t\t}\n\t}\n\n\treturn cpu;\n}\n\n \nstatic int its_select_cpu(struct irq_data *d,\n\t\t\t  const struct cpumask *aff_mask)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\tstatic DEFINE_RAW_SPINLOCK(tmpmask_lock);\n\tstatic struct cpumask __tmpmask;\n\tstruct cpumask *tmpmask;\n\tunsigned long flags;\n\tint cpu, node;\n\tnode = its_dev->its->numa_node;\n\ttmpmask = &__tmpmask;\n\n\traw_spin_lock_irqsave(&tmpmask_lock, flags);\n\n\tif (!irqd_affinity_is_managed(d)) {\n\t\t \n\t\tif (node != NUMA_NO_NODE) {\n\t\t\t \n\t\t\tcpumask_and(tmpmask, cpumask_of_node(node), aff_mask);\n\t\t\tcpumask_and(tmpmask, tmpmask, cpu_online_mask);\n\n\t\t\t \n\t\t\tcpu = cpumask_pick_least_loaded(d, tmpmask);\n\t\t\tif (cpu < nr_cpu_ids)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tif ((its_dev->its->flags & ITS_FLAGS_WORKAROUND_CAVIUM_23144))\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t}\n\n\t\t \n\t\tcpumask_and(tmpmask, aff_mask, cpu_online_mask);\n\n\t\t \n\t\tif (cpumask_empty(tmpmask))\n\t\t\tcpumask_copy(tmpmask, cpu_online_mask);\n\n\t\tcpu = cpumask_pick_least_loaded(d, tmpmask);\n\t} else {\n\t\tcpumask_copy(tmpmask, aff_mask);\n\n\t\t \n\t\tif ((its_dev->its->flags & ITS_FLAGS_WORKAROUND_CAVIUM_23144) &&\n\t\t    node != NUMA_NO_NODE)\n\t\t\tcpumask_and(tmpmask, tmpmask, cpumask_of_node(node));\n\n\t\tcpu = cpumask_pick_least_loaded(d, tmpmask);\n\t}\nout:\n\traw_spin_unlock_irqrestore(&tmpmask_lock, flags);\n\n\tpr_debug(\"IRQ%d -> %*pbl CPU%d\\n\", d->irq, cpumask_pr_args(aff_mask), cpu);\n\treturn cpu;\n}\n\nstatic int its_set_affinity(struct irq_data *d, const struct cpumask *mask_val,\n\t\t\t    bool force)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\tstruct its_collection *target_col;\n\tu32 id = its_get_event_id(d);\n\tint cpu, prev_cpu;\n\n\t \n\tif (irqd_is_forwarded_to_vcpu(d))\n\t\treturn -EINVAL;\n\n\tprev_cpu = its_dev->event_map.col_map[id];\n\tits_dec_lpi_count(d, prev_cpu);\n\n\tif (!force)\n\t\tcpu = its_select_cpu(d, mask_val);\n\telse\n\t\tcpu = cpumask_pick_least_loaded(d, mask_val);\n\n\tif (cpu < 0 || cpu >= nr_cpu_ids)\n\t\tgoto err;\n\n\t \n\tif (cpu != prev_cpu) {\n\t\ttarget_col = &its_dev->its->collections[cpu];\n\t\tits_send_movi(its_dev, target_col, id);\n\t\tits_dev->event_map.col_map[id] = cpu;\n\t\tirq_data_update_effective_affinity(d, cpumask_of(cpu));\n\t}\n\n\tits_inc_lpi_count(d, cpu);\n\n\treturn IRQ_SET_MASK_OK_DONE;\n\nerr:\n\tits_inc_lpi_count(d, prev_cpu);\n\treturn -EINVAL;\n}\n\nstatic u64 its_irq_get_msi_base(struct its_device *its_dev)\n{\n\tstruct its_node *its = its_dev->its;\n\n\treturn its->phys_base + GITS_TRANSLATER;\n}\n\nstatic void its_irq_compose_msi_msg(struct irq_data *d, struct msi_msg *msg)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\tstruct its_node *its;\n\tu64 addr;\n\n\tits = its_dev->its;\n\taddr = its->get_msi_base(its_dev);\n\n\tmsg->address_lo\t\t= lower_32_bits(addr);\n\tmsg->address_hi\t\t= upper_32_bits(addr);\n\tmsg->data\t\t= its_get_event_id(d);\n\n\tiommu_dma_compose_msi_msg(irq_data_get_msi_desc(d), msg);\n}\n\nstatic int its_irq_set_irqchip_state(struct irq_data *d,\n\t\t\t\t     enum irqchip_irq_state which,\n\t\t\t\t     bool state)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\tu32 event = its_get_event_id(d);\n\n\tif (which != IRQCHIP_STATE_PENDING)\n\t\treturn -EINVAL;\n\n\tif (irqd_is_forwarded_to_vcpu(d)) {\n\t\tif (state)\n\t\t\tits_send_vint(its_dev, event);\n\t\telse\n\t\t\tits_send_vclear(its_dev, event);\n\t} else {\n\t\tif (state)\n\t\t\tits_send_int(its_dev, event);\n\t\telse\n\t\t\tits_send_clear(its_dev, event);\n\t}\n\n\treturn 0;\n}\n\nstatic int its_irq_retrigger(struct irq_data *d)\n{\n\treturn !its_irq_set_irqchip_state(d, IRQCHIP_STATE_PENDING, true);\n}\n\n \nstatic bool gic_requires_eager_mapping(void)\n{\n\tif (!its_list_map || gic_rdists->has_rvpeid)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void its_map_vm(struct its_node *its, struct its_vm *vm)\n{\n\tunsigned long flags;\n\n\tif (gic_requires_eager_mapping())\n\t\treturn;\n\n\traw_spin_lock_irqsave(&vmovp_lock, flags);\n\n\t \n\tvm->vlpi_count[its->list_nr]++;\n\n\tif (vm->vlpi_count[its->list_nr] == 1) {\n\t\tint i;\n\n\t\tfor (i = 0; i < vm->nr_vpes; i++) {\n\t\t\tstruct its_vpe *vpe = vm->vpes[i];\n\t\t\tstruct irq_data *d = irq_get_irq_data(vpe->irq);\n\n\t\t\t \n\t\t\tvpe->col_idx = cpumask_first(cpu_online_mask);\n\t\t\tits_send_vmapp(its, vpe, true);\n\t\t\tits_send_vinvall(its, vpe);\n\t\t\tirq_data_update_effective_affinity(d, cpumask_of(vpe->col_idx));\n\t\t}\n\t}\n\n\traw_spin_unlock_irqrestore(&vmovp_lock, flags);\n}\n\nstatic void its_unmap_vm(struct its_node *its, struct its_vm *vm)\n{\n\tunsigned long flags;\n\n\t \n\tif (gic_requires_eager_mapping())\n\t\treturn;\n\n\traw_spin_lock_irqsave(&vmovp_lock, flags);\n\n\tif (!--vm->vlpi_count[its->list_nr]) {\n\t\tint i;\n\n\t\tfor (i = 0; i < vm->nr_vpes; i++)\n\t\t\tits_send_vmapp(its, vm->vpes[i], false);\n\t}\n\n\traw_spin_unlock_irqrestore(&vmovp_lock, flags);\n}\n\nstatic int its_vlpi_map(struct irq_data *d, struct its_cmd_info *info)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\tu32 event = its_get_event_id(d);\n\tint ret = 0;\n\n\tif (!info->map)\n\t\treturn -EINVAL;\n\n\traw_spin_lock(&its_dev->event_map.vlpi_lock);\n\n\tif (!its_dev->event_map.vm) {\n\t\tstruct its_vlpi_map *maps;\n\n\t\tmaps = kcalloc(its_dev->event_map.nr_lpis, sizeof(*maps),\n\t\t\t       GFP_ATOMIC);\n\t\tif (!maps) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tits_dev->event_map.vm = info->map->vm;\n\t\tits_dev->event_map.vlpi_maps = maps;\n\t} else if (its_dev->event_map.vm != info->map->vm) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tits_dev->event_map.vlpi_maps[event] = *info->map;\n\n\tif (irqd_is_forwarded_to_vcpu(d)) {\n\t\t \n\t\tits_send_vmovi(its_dev, event);\n\t} else {\n\t\t \n\t\tits_map_vm(its_dev->its, info->map->vm);\n\n\t\t \n\t\tirqd_set_forwarded_to_vcpu(d);\n\n\t\t \n\t\tlpi_write_config(d, 0xff, info->map->properties);\n\n\t\t \n\t\tits_send_discard(its_dev, event);\n\n\t\t \n\t\tits_send_vmapti(its_dev, event);\n\n\t\t \n\t\tits_dev->event_map.nr_vlpis++;\n\t}\n\nout:\n\traw_spin_unlock(&its_dev->event_map.vlpi_lock);\n\treturn ret;\n}\n\nstatic int its_vlpi_get(struct irq_data *d, struct its_cmd_info *info)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\tstruct its_vlpi_map *map;\n\tint ret = 0;\n\n\traw_spin_lock(&its_dev->event_map.vlpi_lock);\n\n\tmap = get_vlpi_map(d);\n\n\tif (!its_dev->event_map.vm || !map) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\t*info->map = *map;\n\nout:\n\traw_spin_unlock(&its_dev->event_map.vlpi_lock);\n\treturn ret;\n}\n\nstatic int its_vlpi_unmap(struct irq_data *d)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\tu32 event = its_get_event_id(d);\n\tint ret = 0;\n\n\traw_spin_lock(&its_dev->event_map.vlpi_lock);\n\n\tif (!its_dev->event_map.vm || !irqd_is_forwarded_to_vcpu(d)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tits_send_discard(its_dev, event);\n\n\t \n\tirqd_clr_forwarded_to_vcpu(d);\n\tits_send_mapti(its_dev, d->hwirq, event);\n\tlpi_update_config(d, 0xff, (LPI_PROP_DEFAULT_PRIO |\n\t\t\t\t    LPI_PROP_ENABLED |\n\t\t\t\t    LPI_PROP_GROUP1));\n\n\t \n\tits_unmap_vm(its_dev->its, its_dev->event_map.vm);\n\n\t \n\tif (!--its_dev->event_map.nr_vlpis) {\n\t\tits_dev->event_map.vm = NULL;\n\t\tkfree(its_dev->event_map.vlpi_maps);\n\t}\n\nout:\n\traw_spin_unlock(&its_dev->event_map.vlpi_lock);\n\treturn ret;\n}\n\nstatic int its_vlpi_prop_update(struct irq_data *d, struct its_cmd_info *info)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\n\tif (!its_dev->event_map.vm || !irqd_is_forwarded_to_vcpu(d))\n\t\treturn -EINVAL;\n\n\tif (info->cmd_type == PROP_UPDATE_AND_INV_VLPI)\n\t\tlpi_update_config(d, 0xff, info->config);\n\telse\n\t\tlpi_write_config(d, 0xff, info->config);\n\tits_vlpi_set_doorbell(d, !!(info->config & LPI_PROP_ENABLED));\n\n\treturn 0;\n}\n\nstatic int its_irq_set_vcpu_affinity(struct irq_data *d, void *vcpu_info)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\tstruct its_cmd_info *info = vcpu_info;\n\n\t \n\tif (!is_v4(its_dev->its))\n\t\treturn -EINVAL;\n\n\t \n\tif (!info)\n\t\treturn its_vlpi_unmap(d);\n\n\tswitch (info->cmd_type) {\n\tcase MAP_VLPI:\n\t\treturn its_vlpi_map(d, info);\n\n\tcase GET_VLPI:\n\t\treturn its_vlpi_get(d, info);\n\n\tcase PROP_UPDATE_VLPI:\n\tcase PROP_UPDATE_AND_INV_VLPI:\n\t\treturn its_vlpi_prop_update(d, info);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic struct irq_chip its_irq_chip = {\n\t.name\t\t\t= \"ITS\",\n\t.irq_mask\t\t= its_mask_irq,\n\t.irq_unmask\t\t= its_unmask_irq,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_affinity\t= its_set_affinity,\n\t.irq_compose_msi_msg\t= its_irq_compose_msi_msg,\n\t.irq_set_irqchip_state\t= its_irq_set_irqchip_state,\n\t.irq_retrigger\t\t= its_irq_retrigger,\n\t.irq_set_vcpu_affinity\t= its_irq_set_vcpu_affinity,\n};\n\n\n \n#define ITS_MAX_LPI_NRBITS\t16  \n\nstatic DEFINE_MUTEX(lpi_range_lock);\nstatic LIST_HEAD(lpi_range_list);\n\nstruct lpi_range {\n\tstruct list_head\tentry;\n\tu32\t\t\tbase_id;\n\tu32\t\t\tspan;\n};\n\nstatic struct lpi_range *mk_lpi_range(u32 base, u32 span)\n{\n\tstruct lpi_range *range;\n\n\trange = kmalloc(sizeof(*range), GFP_KERNEL);\n\tif (range) {\n\t\trange->base_id = base;\n\t\trange->span = span;\n\t}\n\n\treturn range;\n}\n\nstatic int alloc_lpi_range(u32 nr_lpis, u32 *base)\n{\n\tstruct lpi_range *range, *tmp;\n\tint err = -ENOSPC;\n\n\tmutex_lock(&lpi_range_lock);\n\n\tlist_for_each_entry_safe(range, tmp, &lpi_range_list, entry) {\n\t\tif (range->span >= nr_lpis) {\n\t\t\t*base = range->base_id;\n\t\t\trange->base_id += nr_lpis;\n\t\t\trange->span -= nr_lpis;\n\n\t\t\tif (range->span == 0) {\n\t\t\t\tlist_del(&range->entry);\n\t\t\t\tkfree(range);\n\t\t\t}\n\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&lpi_range_lock);\n\n\tpr_debug(\"ITS: alloc %u:%u\\n\", *base, nr_lpis);\n\treturn err;\n}\n\nstatic void merge_lpi_ranges(struct lpi_range *a, struct lpi_range *b)\n{\n\tif (&a->entry == &lpi_range_list || &b->entry == &lpi_range_list)\n\t\treturn;\n\tif (a->base_id + a->span != b->base_id)\n\t\treturn;\n\tb->base_id = a->base_id;\n\tb->span += a->span;\n\tlist_del(&a->entry);\n\tkfree(a);\n}\n\nstatic int free_lpi_range(u32 base, u32 nr_lpis)\n{\n\tstruct lpi_range *new, *old;\n\n\tnew = mk_lpi_range(base, nr_lpis);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&lpi_range_lock);\n\n\tlist_for_each_entry_reverse(old, &lpi_range_list, entry) {\n\t\tif (old->base_id < base)\n\t\t\tbreak;\n\t}\n\t \n\tlist_add(&new->entry, &old->entry);\n\t \n\tmerge_lpi_ranges(old, new);\n\tmerge_lpi_ranges(new, list_next_entry(new, entry));\n\n\tmutex_unlock(&lpi_range_lock);\n\treturn 0;\n}\n\nstatic int __init its_lpi_init(u32 id_bits)\n{\n\tu32 lpis = (1UL << id_bits) - 8192;\n\tu32 numlpis;\n\tint err;\n\n\tnumlpis = 1UL << GICD_TYPER_NUM_LPIS(gic_rdists->gicd_typer);\n\n\tif (numlpis > 2 && !WARN_ON(numlpis > lpis)) {\n\t\tlpis = numlpis;\n\t\tpr_info(\"ITS: Using hypervisor restricted LPI range [%u]\\n\",\n\t\t\tlpis);\n\t}\n\n\t \n\terr = free_lpi_range(8192, lpis);\n\tpr_debug(\"ITS: Allocator initialized for %u LPIs\\n\", lpis);\n\treturn err;\n}\n\nstatic unsigned long *its_lpi_alloc(int nr_irqs, u32 *base, int *nr_ids)\n{\n\tunsigned long *bitmap = NULL;\n\tint err = 0;\n\n\tdo {\n\t\terr = alloc_lpi_range(nr_irqs, base);\n\t\tif (!err)\n\t\t\tbreak;\n\n\t\tnr_irqs /= 2;\n\t} while (nr_irqs > 0);\n\n\tif (!nr_irqs)\n\t\terr = -ENOSPC;\n\n\tif (err)\n\t\tgoto out;\n\n\tbitmap = bitmap_zalloc(nr_irqs, GFP_ATOMIC);\n\tif (!bitmap)\n\t\tgoto out;\n\n\t*nr_ids = nr_irqs;\n\nout:\n\tif (!bitmap)\n\t\t*base = *nr_ids = 0;\n\n\treturn bitmap;\n}\n\nstatic void its_lpi_free(unsigned long *bitmap, u32 base, u32 nr_ids)\n{\n\tWARN_ON(free_lpi_range(base, nr_ids));\n\tbitmap_free(bitmap);\n}\n\nstatic void gic_reset_prop_table(void *va)\n{\n\t \n\tmemset(va, LPI_PROP_DEFAULT_PRIO | LPI_PROP_GROUP1, LPI_PROPBASE_SZ);\n\n\t \n\tgic_flush_dcache_to_poc(va, LPI_PROPBASE_SZ);\n}\n\nstatic struct page *its_allocate_prop_table(gfp_t gfp_flags)\n{\n\tstruct page *prop_page;\n\n\tprop_page = alloc_pages(gfp_flags, get_order(LPI_PROPBASE_SZ));\n\tif (!prop_page)\n\t\treturn NULL;\n\n\tgic_reset_prop_table(page_address(prop_page));\n\n\treturn prop_page;\n}\n\nstatic void its_free_prop_table(struct page *prop_page)\n{\n\tfree_pages((unsigned long)page_address(prop_page),\n\t\t   get_order(LPI_PROPBASE_SZ));\n}\n\nstatic bool gic_check_reserved_range(phys_addr_t addr, unsigned long size)\n{\n\tphys_addr_t start, end, addr_end;\n\tu64 i;\n\n\t \n\tif (is_kdump_kernel())\n\t\treturn true;\n\n\taddr_end = addr + size - 1;\n\n\tfor_each_reserved_mem_range(i, &start, &end) {\n\t\tif (addr >= start && addr_end <= end)\n\t\t\treturn true;\n\t}\n\n\t \n\tpr_warn(\"GICv3: Expected reserved range [%pa:%pa], not found\\n\",\n\t\t&addr, &addr_end);\n\tadd_taint(TAINT_CRAP, LOCKDEP_STILL_OK);\n\treturn false;\n}\n\nstatic int gic_reserve_range(phys_addr_t addr, unsigned long size)\n{\n\tif (efi_enabled(EFI_CONFIG_TABLES))\n\t\treturn efi_mem_reserve_persistent(addr, size);\n\n\treturn 0;\n}\n\nstatic int __init its_setup_lpi_prop_table(void)\n{\n\tif (gic_rdists->flags & RDIST_FLAGS_RD_TABLES_PREALLOCATED) {\n\t\tu64 val;\n\n\t\tval = gicr_read_propbaser(gic_data_rdist_rd_base() + GICR_PROPBASER);\n\t\tlpi_id_bits = (val & GICR_PROPBASER_IDBITS_MASK) + 1;\n\n\t\tgic_rdists->prop_table_pa = val & GENMASK_ULL(51, 12);\n\t\tgic_rdists->prop_table_va = memremap(gic_rdists->prop_table_pa,\n\t\t\t\t\t\t     LPI_PROPBASE_SZ,\n\t\t\t\t\t\t     MEMREMAP_WB);\n\t\tgic_reset_prop_table(gic_rdists->prop_table_va);\n\t} else {\n\t\tstruct page *page;\n\n\t\tlpi_id_bits = min_t(u32,\n\t\t\t\t    GICD_TYPER_ID_BITS(gic_rdists->gicd_typer),\n\t\t\t\t    ITS_MAX_LPI_NRBITS);\n\t\tpage = its_allocate_prop_table(GFP_NOWAIT);\n\t\tif (!page) {\n\t\t\tpr_err(\"Failed to allocate PROPBASE\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tgic_rdists->prop_table_pa = page_to_phys(page);\n\t\tgic_rdists->prop_table_va = page_address(page);\n\t\tWARN_ON(gic_reserve_range(gic_rdists->prop_table_pa,\n\t\t\t\t\t  LPI_PROPBASE_SZ));\n\t}\n\n\tpr_info(\"GICv3: using LPI property table @%pa\\n\",\n\t\t&gic_rdists->prop_table_pa);\n\n\treturn its_lpi_init(lpi_id_bits);\n}\n\nstatic const char *its_base_type_string[] = {\n\t[GITS_BASER_TYPE_DEVICE]\t= \"Devices\",\n\t[GITS_BASER_TYPE_VCPU]\t\t= \"Virtual CPUs\",\n\t[GITS_BASER_TYPE_RESERVED3]\t= \"Reserved (3)\",\n\t[GITS_BASER_TYPE_COLLECTION]\t= \"Interrupt Collections\",\n\t[GITS_BASER_TYPE_RESERVED5] \t= \"Reserved (5)\",\n\t[GITS_BASER_TYPE_RESERVED6] \t= \"Reserved (6)\",\n\t[GITS_BASER_TYPE_RESERVED7] \t= \"Reserved (7)\",\n};\n\nstatic u64 its_read_baser(struct its_node *its, struct its_baser *baser)\n{\n\tu32 idx = baser - its->tables;\n\n\treturn gits_read_baser(its->base + GITS_BASER + (idx << 3));\n}\n\nstatic void its_write_baser(struct its_node *its, struct its_baser *baser,\n\t\t\t    u64 val)\n{\n\tu32 idx = baser - its->tables;\n\n\tgits_write_baser(val, its->base + GITS_BASER + (idx << 3));\n\tbaser->val = its_read_baser(its, baser);\n}\n\nstatic int its_setup_baser(struct its_node *its, struct its_baser *baser,\n\t\t\t   u64 cache, u64 shr, u32 order, bool indirect)\n{\n\tu64 val = its_read_baser(its, baser);\n\tu64 esz = GITS_BASER_ENTRY_SIZE(val);\n\tu64 type = GITS_BASER_TYPE(val);\n\tu64 baser_phys, tmp;\n\tu32 alloc_pages, psz;\n\tstruct page *page;\n\tvoid *base;\n\n\tpsz = baser->psz;\n\talloc_pages = (PAGE_ORDER_TO_SIZE(order) / psz);\n\tif (alloc_pages > GITS_BASER_PAGES_MAX) {\n\t\tpr_warn(\"ITS@%pa: %s too large, reduce ITS pages %u->%u\\n\",\n\t\t\t&its->phys_base, its_base_type_string[type],\n\t\t\talloc_pages, GITS_BASER_PAGES_MAX);\n\t\talloc_pages = GITS_BASER_PAGES_MAX;\n\t\torder = get_order(GITS_BASER_PAGES_MAX * psz);\n\t}\n\n\tpage = alloc_pages_node(its->numa_node, GFP_KERNEL | __GFP_ZERO, order);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tbase = (void *)page_address(page);\n\tbaser_phys = virt_to_phys(base);\n\n\t \n\tif (IS_ENABLED(CONFIG_ARM64_64K_PAGES) && (baser_phys >> 48)) {\n\n\t\t \n\t\tif (psz != SZ_64K) {\n\t\t\tpr_err(\"ITS: no 52bit PA support when psz=%d\\n\", psz);\n\t\t\tfree_pages((unsigned long)base, order);\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\t \n\t\tbaser_phys = GITS_BASER_PHYS_52_to_48(baser_phys);\n\t}\n\nretry_baser:\n\tval = (baser_phys\t\t\t\t\t |\n\t\t(type << GITS_BASER_TYPE_SHIFT)\t\t\t |\n\t\t((esz - 1) << GITS_BASER_ENTRY_SIZE_SHIFT)\t |\n\t\t((alloc_pages - 1) << GITS_BASER_PAGES_SHIFT)\t |\n\t\tcache\t\t\t\t\t\t |\n\t\tshr\t\t\t\t\t\t |\n\t\tGITS_BASER_VALID);\n\n\tval |=\tindirect ? GITS_BASER_INDIRECT : 0x0;\n\n\tswitch (psz) {\n\tcase SZ_4K:\n\t\tval |= GITS_BASER_PAGE_SIZE_4K;\n\t\tbreak;\n\tcase SZ_16K:\n\t\tval |= GITS_BASER_PAGE_SIZE_16K;\n\t\tbreak;\n\tcase SZ_64K:\n\t\tval |= GITS_BASER_PAGE_SIZE_64K;\n\t\tbreak;\n\t}\n\n\tif (!shr)\n\t\tgic_flush_dcache_to_poc(base, PAGE_ORDER_TO_SIZE(order));\n\n\tits_write_baser(its, baser, val);\n\ttmp = baser->val;\n\n\tif ((val ^ tmp) & GITS_BASER_SHAREABILITY_MASK) {\n\t\t \n\t\tshr = tmp & GITS_BASER_SHAREABILITY_MASK;\n\t\tif (!shr)\n\t\t\tcache = GITS_BASER_nC;\n\n\t\tgoto retry_baser;\n\t}\n\n\tif (val != tmp) {\n\t\tpr_err(\"ITS@%pa: %s doesn't stick: %llx %llx\\n\",\n\t\t       &its->phys_base, its_base_type_string[type],\n\t\t       val, tmp);\n\t\tfree_pages((unsigned long)base, order);\n\t\treturn -ENXIO;\n\t}\n\n\tbaser->order = order;\n\tbaser->base = base;\n\tbaser->psz = psz;\n\ttmp = indirect ? GITS_LVL1_ENTRY_SIZE : esz;\n\n\tpr_info(\"ITS@%pa: allocated %d %s @%lx (%s, esz %d, psz %dK, shr %d)\\n\",\n\t\t&its->phys_base, (int)(PAGE_ORDER_TO_SIZE(order) / (int)tmp),\n\t\tits_base_type_string[type],\n\t\t(unsigned long)virt_to_phys(base),\n\t\tindirect ? \"indirect\" : \"flat\", (int)esz,\n\t\tpsz / SZ_1K, (int)shr >> GITS_BASER_SHAREABILITY_SHIFT);\n\n\treturn 0;\n}\n\nstatic bool its_parse_indirect_baser(struct its_node *its,\n\t\t\t\t     struct its_baser *baser,\n\t\t\t\t     u32 *order, u32 ids)\n{\n\tu64 tmp = its_read_baser(its, baser);\n\tu64 type = GITS_BASER_TYPE(tmp);\n\tu64 esz = GITS_BASER_ENTRY_SIZE(tmp);\n\tu64 val = GITS_BASER_InnerShareable | GITS_BASER_RaWaWb;\n\tu32 new_order = *order;\n\tu32 psz = baser->psz;\n\tbool indirect = false;\n\n\t \n\tif ((esz << ids) > (psz * 2)) {\n\t\t \n\t\tits_write_baser(its, baser, val | GITS_BASER_INDIRECT);\n\t\tindirect = !!(baser->val & GITS_BASER_INDIRECT);\n\n\t\tif (indirect) {\n\t\t\t \n\t\t\tids -= ilog2(psz / (int)esz);\n\t\t\tesz = GITS_LVL1_ENTRY_SIZE;\n\t\t}\n\t}\n\n\t \n\tnew_order = max_t(u32, get_order(esz << ids), new_order);\n\tif (new_order > MAX_ORDER) {\n\t\tnew_order = MAX_ORDER;\n\t\tids = ilog2(PAGE_ORDER_TO_SIZE(new_order) / (int)esz);\n\t\tpr_warn(\"ITS@%pa: %s Table too large, reduce ids %llu->%u\\n\",\n\t\t\t&its->phys_base, its_base_type_string[type],\n\t\t\tdevice_ids(its), ids);\n\t}\n\n\t*order = new_order;\n\n\treturn indirect;\n}\n\nstatic u32 compute_common_aff(u64 val)\n{\n\tu32 aff, clpiaff;\n\n\taff = FIELD_GET(GICR_TYPER_AFFINITY, val);\n\tclpiaff = FIELD_GET(GICR_TYPER_COMMON_LPI_AFF, val);\n\n\treturn aff & ~(GENMASK(31, 0) >> (clpiaff * 8));\n}\n\nstatic u32 compute_its_aff(struct its_node *its)\n{\n\tu64 val;\n\tu32 svpet;\n\n\t \n\tsvpet = FIELD_GET(GITS_TYPER_SVPET, its->typer);\n\tval  = FIELD_PREP(GICR_TYPER_COMMON_LPI_AFF, svpet);\n\tval |= FIELD_PREP(GICR_TYPER_AFFINITY, its->mpidr);\n\treturn compute_common_aff(val);\n}\n\nstatic struct its_node *find_sibling_its(struct its_node *cur_its)\n{\n\tstruct its_node *its;\n\tu32 aff;\n\n\tif (!FIELD_GET(GITS_TYPER_SVPET, cur_its->typer))\n\t\treturn NULL;\n\n\taff = compute_its_aff(cur_its);\n\n\tlist_for_each_entry(its, &its_nodes, entry) {\n\t\tu64 baser;\n\n\t\tif (!is_v4_1(its) || its == cur_its)\n\t\t\tcontinue;\n\n\t\tif (!FIELD_GET(GITS_TYPER_SVPET, its->typer))\n\t\t\tcontinue;\n\n\t\tif (aff != compute_its_aff(its))\n\t\t\tcontinue;\n\n\t\t \n\t\tbaser = its->tables[2].val;\n\t\tif (!(baser & GITS_BASER_VALID))\n\t\t\tcontinue;\n\n\t\treturn its;\n\t}\n\n\treturn NULL;\n}\n\nstatic void its_free_tables(struct its_node *its)\n{\n\tint i;\n\n\tfor (i = 0; i < GITS_BASER_NR_REGS; i++) {\n\t\tif (its->tables[i].base) {\n\t\t\tfree_pages((unsigned long)its->tables[i].base,\n\t\t\t\t   its->tables[i].order);\n\t\t\tits->tables[i].base = NULL;\n\t\t}\n\t}\n}\n\nstatic int its_probe_baser_psz(struct its_node *its, struct its_baser *baser)\n{\n\tu64 psz = SZ_64K;\n\n\twhile (psz) {\n\t\tu64 val, gpsz;\n\n\t\tval = its_read_baser(its, baser);\n\t\tval &= ~GITS_BASER_PAGE_SIZE_MASK;\n\n\t\tswitch (psz) {\n\t\tcase SZ_64K:\n\t\t\tgpsz = GITS_BASER_PAGE_SIZE_64K;\n\t\t\tbreak;\n\t\tcase SZ_16K:\n\t\t\tgpsz = GITS_BASER_PAGE_SIZE_16K;\n\t\t\tbreak;\n\t\tcase SZ_4K:\n\t\tdefault:\n\t\t\tgpsz = GITS_BASER_PAGE_SIZE_4K;\n\t\t\tbreak;\n\t\t}\n\n\t\tgpsz >>= GITS_BASER_PAGE_SIZE_SHIFT;\n\n\t\tval |= FIELD_PREP(GITS_BASER_PAGE_SIZE_MASK, gpsz);\n\t\tits_write_baser(its, baser, val);\n\n\t\tif (FIELD_GET(GITS_BASER_PAGE_SIZE_MASK, baser->val) == gpsz)\n\t\t\tbreak;\n\n\t\tswitch (psz) {\n\t\tcase SZ_64K:\n\t\t\tpsz = SZ_16K;\n\t\t\tbreak;\n\t\tcase SZ_16K:\n\t\t\tpsz = SZ_4K;\n\t\t\tbreak;\n\t\tcase SZ_4K:\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbaser->psz = psz;\n\treturn 0;\n}\n\nstatic int its_alloc_tables(struct its_node *its)\n{\n\tu64 shr = GITS_BASER_InnerShareable;\n\tu64 cache = GITS_BASER_RaWaWb;\n\tint err, i;\n\n\tif (its->flags & ITS_FLAGS_WORKAROUND_CAVIUM_22375)\n\t\t \n\t\tcache = GITS_BASER_nCnB;\n\n\tif (its->flags & ITS_FLAGS_FORCE_NON_SHAREABLE) {\n\t\tcache = GITS_BASER_nC;\n\t\tshr = 0;\n\t}\n\n\tfor (i = 0; i < GITS_BASER_NR_REGS; i++) {\n\t\tstruct its_baser *baser = its->tables + i;\n\t\tu64 val = its_read_baser(its, baser);\n\t\tu64 type = GITS_BASER_TYPE(val);\n\t\tbool indirect = false;\n\t\tu32 order;\n\n\t\tif (type == GITS_BASER_TYPE_NONE)\n\t\t\tcontinue;\n\n\t\tif (its_probe_baser_psz(its, baser)) {\n\t\t\tits_free_tables(its);\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\torder = get_order(baser->psz);\n\n\t\tswitch (type) {\n\t\tcase GITS_BASER_TYPE_DEVICE:\n\t\t\tindirect = its_parse_indirect_baser(its, baser, &order,\n\t\t\t\t\t\t\t    device_ids(its));\n\t\t\tbreak;\n\n\t\tcase GITS_BASER_TYPE_VCPU:\n\t\t\tif (is_v4_1(its)) {\n\t\t\t\tstruct its_node *sibling;\n\n\t\t\t\tWARN_ON(i != 2);\n\t\t\t\tif ((sibling = find_sibling_its(its))) {\n\t\t\t\t\t*baser = sibling->tables[2];\n\t\t\t\t\tits_write_baser(its, baser, baser->val);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tindirect = its_parse_indirect_baser(its, baser, &order,\n\t\t\t\t\t\t\t    ITS_MAX_VPEID_BITS);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = its_setup_baser(its, baser, cache, shr, order, indirect);\n\t\tif (err < 0) {\n\t\t\tits_free_tables(its);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tcache = baser->val & GITS_BASER_CACHEABILITY_MASK;\n\t\tshr = baser->val & GITS_BASER_SHAREABILITY_MASK;\n\t}\n\n\treturn 0;\n}\n\nstatic u64 inherit_vpe_l1_table_from_its(void)\n{\n\tstruct its_node *its;\n\tu64 val;\n\tu32 aff;\n\n\tval = gic_read_typer(gic_data_rdist_rd_base() + GICR_TYPER);\n\taff = compute_common_aff(val);\n\n\tlist_for_each_entry(its, &its_nodes, entry) {\n\t\tu64 baser, addr;\n\n\t\tif (!is_v4_1(its))\n\t\t\tcontinue;\n\n\t\tif (!FIELD_GET(GITS_TYPER_SVPET, its->typer))\n\t\t\tcontinue;\n\n\t\tif (aff != compute_its_aff(its))\n\t\t\tcontinue;\n\n\t\t \n\t\tbaser = its->tables[2].val;\n\t\tif (!(baser & GITS_BASER_VALID))\n\t\t\tcontinue;\n\n\t\t \n\t\tgic_data_rdist()->vpe_l1_base = its->tables[2].base;\n\n\t\tval  = GICR_VPROPBASER_4_1_VALID;\n\t\tif (baser & GITS_BASER_INDIRECT)\n\t\t\tval |= GICR_VPROPBASER_4_1_INDIRECT;\n\t\tval |= FIELD_PREP(GICR_VPROPBASER_4_1_PAGE_SIZE,\n\t\t\t\t  FIELD_GET(GITS_BASER_PAGE_SIZE_MASK, baser));\n\t\tswitch (FIELD_GET(GITS_BASER_PAGE_SIZE_MASK, baser)) {\n\t\tcase GIC_PAGE_SIZE_64K:\n\t\t\taddr = GITS_BASER_ADDR_48_to_52(baser);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\taddr = baser & GENMASK_ULL(47, 12);\n\t\t\tbreak;\n\t\t}\n\t\tval |= FIELD_PREP(GICR_VPROPBASER_4_1_ADDR, addr >> 12);\n\t\tval |= FIELD_PREP(GICR_VPROPBASER_SHAREABILITY_MASK,\n\t\t\t\t  FIELD_GET(GITS_BASER_SHAREABILITY_MASK, baser));\n\t\tval |= FIELD_PREP(GICR_VPROPBASER_INNER_CACHEABILITY_MASK,\n\t\t\t\t  FIELD_GET(GITS_BASER_INNER_CACHEABILITY_MASK, baser));\n\t\tval |= FIELD_PREP(GICR_VPROPBASER_4_1_SIZE, GITS_BASER_NR_PAGES(baser) - 1);\n\n\t\treturn val;\n\t}\n\n\treturn 0;\n}\n\nstatic u64 inherit_vpe_l1_table_from_rd(cpumask_t **mask)\n{\n\tu32 aff;\n\tu64 val;\n\tint cpu;\n\n\tval = gic_read_typer(gic_data_rdist_rd_base() + GICR_TYPER);\n\taff = compute_common_aff(val);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tvoid __iomem *base = gic_data_rdist_cpu(cpu)->rd_base;\n\n\t\tif (!base || cpu == smp_processor_id())\n\t\t\tcontinue;\n\n\t\tval = gic_read_typer(base + GICR_TYPER);\n\t\tif (aff != compute_common_aff(val))\n\t\t\tcontinue;\n\n\t\t \n\t\tval = gicr_read_vpropbaser(base + SZ_128K + GICR_VPROPBASER);\n\t\tval &= ~GICR_VPROPBASER_4_1_Z;\n\n\t\tgic_data_rdist()->vpe_l1_base = gic_data_rdist_cpu(cpu)->vpe_l1_base;\n\t\t*mask = gic_data_rdist_cpu(cpu)->vpe_table_mask;\n\n\t\treturn val;\n\t}\n\n\treturn 0;\n}\n\nstatic bool allocate_vpe_l2_table(int cpu, u32 id)\n{\n\tvoid __iomem *base = gic_data_rdist_cpu(cpu)->rd_base;\n\tunsigned int psz, esz, idx, npg, gpsz;\n\tu64 val;\n\tstruct page *page;\n\t__le64 *table;\n\n\tif (!gic_rdists->has_rvpeid)\n\t\treturn true;\n\n\t \n\tif (!base)\n\t\treturn true;\n\n\tval  = gicr_read_vpropbaser(base + SZ_128K + GICR_VPROPBASER);\n\n\tesz  = FIELD_GET(GICR_VPROPBASER_4_1_ENTRY_SIZE, val) + 1;\n\tgpsz = FIELD_GET(GICR_VPROPBASER_4_1_PAGE_SIZE, val);\n\tnpg  = FIELD_GET(GICR_VPROPBASER_4_1_SIZE, val) + 1;\n\n\tswitch (gpsz) {\n\tdefault:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase GIC_PAGE_SIZE_4K:\n\t\tpsz = SZ_4K;\n\t\tbreak;\n\tcase GIC_PAGE_SIZE_16K:\n\t\tpsz = SZ_16K;\n\t\tbreak;\n\tcase GIC_PAGE_SIZE_64K:\n\t\tpsz = SZ_64K;\n\t\tbreak;\n\t}\n\n\t \n\tif (!(val & GICR_VPROPBASER_4_1_INDIRECT))\n\t\treturn (id < (npg * psz / (esz * SZ_8)));\n\n\t \n\tidx = id >> ilog2(psz / (esz * SZ_8));\n\tif (idx >= (npg * psz / GITS_LVL1_ENTRY_SIZE))\n\t\treturn false;\n\n\ttable = gic_data_rdist_cpu(cpu)->vpe_l1_base;\n\n\t \n\tif (!table[idx]) {\n\t\tpage = alloc_pages(GFP_KERNEL | __GFP_ZERO, get_order(psz));\n\t\tif (!page)\n\t\t\treturn false;\n\n\t\t \n\t\tif (!(val & GICR_VPROPBASER_SHAREABILITY_MASK))\n\t\t\tgic_flush_dcache_to_poc(page_address(page), psz);\n\n\t\ttable[idx] = cpu_to_le64(page_to_phys(page) | GITS_BASER_VALID);\n\n\t\t \n\t\tif (!(val & GICR_VPROPBASER_SHAREABILITY_MASK))\n\t\t\tgic_flush_dcache_to_poc(table + idx, GITS_LVL1_ENTRY_SIZE);\n\n\t\t \n\t\tdsb(sy);\n\t}\n\n\treturn true;\n}\n\nstatic int allocate_vpe_l1_table(void)\n{\n\tvoid __iomem *vlpi_base = gic_data_rdist_vlpi_base();\n\tu64 val, gpsz, npg, pa;\n\tunsigned int psz = SZ_64K;\n\tunsigned int np, epp, esz;\n\tstruct page *page;\n\n\tif (!gic_rdists->has_rvpeid)\n\t\treturn 0;\n\n\t \n\tif (gicr_read_vpendbaser(vlpi_base + GICR_VPENDBASER) & GICR_VPENDBASER_Valid)\n\t\tgicr_write_vpendbaser(GICR_VPENDBASER_PendingLast,\n\t\t\t\t      vlpi_base + GICR_VPENDBASER);\n\n\t \n\tval = inherit_vpe_l1_table_from_rd(&gic_data_rdist()->vpe_table_mask);\n\tif (val & GICR_VPROPBASER_4_1_VALID)\n\t\tgoto out;\n\n\tgic_data_rdist()->vpe_table_mask = kzalloc(sizeof(cpumask_t), GFP_ATOMIC);\n\tif (!gic_data_rdist()->vpe_table_mask)\n\t\treturn -ENOMEM;\n\n\tval = inherit_vpe_l1_table_from_its();\n\tif (val & GICR_VPROPBASER_4_1_VALID)\n\t\tgoto out;\n\n\t \n\tval = FIELD_PREP(GICR_VPROPBASER_4_1_PAGE_SIZE, GIC_PAGE_SIZE_64K);\n\tgicr_write_vpropbaser(val, vlpi_base + GICR_VPROPBASER);\n\tval = gicr_read_vpropbaser(vlpi_base + GICR_VPROPBASER);\n\tgpsz = FIELD_GET(GICR_VPROPBASER_4_1_PAGE_SIZE, val);\n\tesz = FIELD_GET(GICR_VPROPBASER_4_1_ENTRY_SIZE, val);\n\n\tswitch (gpsz) {\n\tdefault:\n\t\tgpsz = GIC_PAGE_SIZE_4K;\n\t\tfallthrough;\n\tcase GIC_PAGE_SIZE_4K:\n\t\tpsz = SZ_4K;\n\t\tbreak;\n\tcase GIC_PAGE_SIZE_16K:\n\t\tpsz = SZ_16K;\n\t\tbreak;\n\tcase GIC_PAGE_SIZE_64K:\n\t\tpsz = SZ_64K;\n\t\tbreak;\n\t}\n\n\t \n\tval = 0;\n\tval |= FIELD_PREP(GICR_VPROPBASER_4_1_PAGE_SIZE, gpsz);\n\tval |= FIELD_PREP(GICR_VPROPBASER_4_1_ENTRY_SIZE, esz);\n\n\t \n\tesz++;\n\tepp = psz / (esz * SZ_8);\n\n\t \n\tif (epp < ITS_MAX_VPEID) {\n\t\tint nl2;\n\n\t\tval |= GICR_VPROPBASER_4_1_INDIRECT;\n\n\t\t \n\t\tnl2 = DIV_ROUND_UP(ITS_MAX_VPEID, epp);\n\n\t\t \n\t\tnpg = DIV_ROUND_UP(nl2 * SZ_8, psz);\n\t} else {\n\t\tnpg = 1;\n\t}\n\n\tval |= FIELD_PREP(GICR_VPROPBASER_4_1_SIZE, npg - 1);\n\n\t \n\tnp = DIV_ROUND_UP(npg * psz, PAGE_SIZE);\n\n\tpr_debug(\"np = %d, npg = %lld, psz = %d, epp = %d, esz = %d\\n\",\n\t\t np, npg, psz, epp, esz);\n\tpage = alloc_pages(GFP_ATOMIC | __GFP_ZERO, get_order(np * PAGE_SIZE));\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tgic_data_rdist()->vpe_l1_base = page_address(page);\n\tpa = virt_to_phys(page_address(page));\n\tWARN_ON(!IS_ALIGNED(pa, psz));\n\n\tval |= FIELD_PREP(GICR_VPROPBASER_4_1_ADDR, pa >> 12);\n\tval |= GICR_VPROPBASER_RaWb;\n\tval |= GICR_VPROPBASER_InnerShareable;\n\tval |= GICR_VPROPBASER_4_1_Z;\n\tval |= GICR_VPROPBASER_4_1_VALID;\n\nout:\n\tgicr_write_vpropbaser(val, vlpi_base + GICR_VPROPBASER);\n\tcpumask_set_cpu(smp_processor_id(), gic_data_rdist()->vpe_table_mask);\n\n\tpr_debug(\"CPU%d: VPROPBASER = %llx %*pbl\\n\",\n\t\t smp_processor_id(), val,\n\t\t cpumask_pr_args(gic_data_rdist()->vpe_table_mask));\n\n\treturn 0;\n}\n\nstatic int its_alloc_collections(struct its_node *its)\n{\n\tint i;\n\n\tits->collections = kcalloc(nr_cpu_ids, sizeof(*its->collections),\n\t\t\t\t   GFP_KERNEL);\n\tif (!its->collections)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nr_cpu_ids; i++)\n\t\tits->collections[i].target_address = ~0ULL;\n\n\treturn 0;\n}\n\nstatic struct page *its_allocate_pending_table(gfp_t gfp_flags)\n{\n\tstruct page *pend_page;\n\n\tpend_page = alloc_pages(gfp_flags | __GFP_ZERO,\n\t\t\t\tget_order(LPI_PENDBASE_SZ));\n\tif (!pend_page)\n\t\treturn NULL;\n\n\t \n\tgic_flush_dcache_to_poc(page_address(pend_page), LPI_PENDBASE_SZ);\n\n\treturn pend_page;\n}\n\nstatic void its_free_pending_table(struct page *pt)\n{\n\tfree_pages((unsigned long)page_address(pt), get_order(LPI_PENDBASE_SZ));\n}\n\n \nstatic bool enabled_lpis_allowed(void)\n{\n\tphys_addr_t addr;\n\tu64 val;\n\n\t \n\tval = gicr_read_propbaser(gic_data_rdist_rd_base() + GICR_PROPBASER);\n\taddr = val & GENMASK_ULL(51, 12);\n\n\treturn gic_check_reserved_range(addr, LPI_PROPBASE_SZ);\n}\n\nstatic int __init allocate_lpi_tables(void)\n{\n\tu64 val;\n\tint err, cpu;\n\n\t \n\tval = readl_relaxed(gic_data_rdist_rd_base() + GICR_CTLR);\n\tif ((val & GICR_CTLR_ENABLE_LPIS) && enabled_lpis_allowed()) {\n\t\tgic_rdists->flags |= (RDIST_FLAGS_RD_TABLES_PREALLOCATED |\n\t\t\t\t      RDIST_FLAGS_PROPBASE_NEEDS_FLUSHING);\n\t\tpr_info(\"GICv3: Using preallocated redistributor tables\\n\");\n\t}\n\n\terr = its_setup_lpi_prop_table();\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tstruct page *pend_page;\n\n\t\tpend_page = its_allocate_pending_table(GFP_NOWAIT);\n\t\tif (!pend_page) {\n\t\t\tpr_err(\"Failed to allocate PENDBASE for CPU%d\\n\", cpu);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tgic_data_rdist_cpu(cpu)->pend_page = pend_page;\n\t}\n\n\treturn 0;\n}\n\nstatic u64 read_vpend_dirty_clear(void __iomem *vlpi_base)\n{\n\tu32 count = 1000000;\t \n\tbool clean;\n\tu64 val;\n\n\tdo {\n\t\tval = gicr_read_vpendbaser(vlpi_base + GICR_VPENDBASER);\n\t\tclean = !(val & GICR_VPENDBASER_Dirty);\n\t\tif (!clean) {\n\t\t\tcount--;\n\t\t\tcpu_relax();\n\t\t\tudelay(1);\n\t\t}\n\t} while (!clean && count);\n\n\tif (unlikely(!clean))\n\t\tpr_err_ratelimited(\"ITS virtual pending table not cleaning\\n\");\n\n\treturn val;\n}\n\nstatic u64 its_clear_vpend_valid(void __iomem *vlpi_base, u64 clr, u64 set)\n{\n\tu64 val;\n\n\t \n\tval = read_vpend_dirty_clear(vlpi_base);\n\tval &= ~GICR_VPENDBASER_Valid;\n\tval &= ~clr;\n\tval |= set;\n\tgicr_write_vpendbaser(val, vlpi_base + GICR_VPENDBASER);\n\n\tval = read_vpend_dirty_clear(vlpi_base);\n\tif (unlikely(val & GICR_VPENDBASER_Dirty))\n\t\tval |= GICR_VPENDBASER_PendingLast;\n\n\treturn val;\n}\n\nstatic void its_cpu_init_lpis(void)\n{\n\tvoid __iomem *rbase = gic_data_rdist_rd_base();\n\tstruct page *pend_page;\n\tphys_addr_t paddr;\n\tu64 val, tmp;\n\n\tif (gic_data_rdist()->flags & RD_LOCAL_LPI_ENABLED)\n\t\treturn;\n\n\tval = readl_relaxed(rbase + GICR_CTLR);\n\tif ((gic_rdists->flags & RDIST_FLAGS_RD_TABLES_PREALLOCATED) &&\n\t    (val & GICR_CTLR_ENABLE_LPIS)) {\n\t\t \n\t\tpaddr = gicr_read_propbaser(rbase + GICR_PROPBASER);\n\t\tpaddr &= GENMASK_ULL(51, 12);\n\t\tif (WARN_ON(gic_rdists->prop_table_pa != paddr))\n\t\t\tadd_taint(TAINT_CRAP, LOCKDEP_STILL_OK);\n\n\t\tpaddr = gicr_read_pendbaser(rbase + GICR_PENDBASER);\n\t\tpaddr &= GENMASK_ULL(51, 16);\n\n\t\tWARN_ON(!gic_check_reserved_range(paddr, LPI_PENDBASE_SZ));\n\t\tgic_data_rdist()->flags |= RD_LOCAL_PENDTABLE_PREALLOCATED;\n\n\t\tgoto out;\n\t}\n\n\tpend_page = gic_data_rdist()->pend_page;\n\tpaddr = page_to_phys(pend_page);\n\n\t \n\tval = (gic_rdists->prop_table_pa |\n\t       GICR_PROPBASER_InnerShareable |\n\t       GICR_PROPBASER_RaWaWb |\n\t       ((LPI_NRBITS - 1) & GICR_PROPBASER_IDBITS_MASK));\n\n\tgicr_write_propbaser(val, rbase + GICR_PROPBASER);\n\ttmp = gicr_read_propbaser(rbase + GICR_PROPBASER);\n\n\tif (gic_rdists->flags & RDIST_FLAGS_FORCE_NON_SHAREABLE)\n\t\ttmp &= ~GICR_PROPBASER_SHAREABILITY_MASK;\n\n\tif ((tmp ^ val) & GICR_PROPBASER_SHAREABILITY_MASK) {\n\t\tif (!(tmp & GICR_PROPBASER_SHAREABILITY_MASK)) {\n\t\t\t \n\t\t\tval &= ~(GICR_PROPBASER_SHAREABILITY_MASK |\n\t\t\t\t GICR_PROPBASER_CACHEABILITY_MASK);\n\t\t\tval |= GICR_PROPBASER_nC;\n\t\t\tgicr_write_propbaser(val, rbase + GICR_PROPBASER);\n\t\t}\n\t\tpr_info_once(\"GIC: using cache flushing for LPI property table\\n\");\n\t\tgic_rdists->flags |= RDIST_FLAGS_PROPBASE_NEEDS_FLUSHING;\n\t}\n\n\t \n\tval = (page_to_phys(pend_page) |\n\t       GICR_PENDBASER_InnerShareable |\n\t       GICR_PENDBASER_RaWaWb);\n\n\tgicr_write_pendbaser(val, rbase + GICR_PENDBASER);\n\ttmp = gicr_read_pendbaser(rbase + GICR_PENDBASER);\n\n\tif (gic_rdists->flags & RDIST_FLAGS_FORCE_NON_SHAREABLE)\n\t\ttmp &= ~GICR_PENDBASER_SHAREABILITY_MASK;\n\n\tif (!(tmp & GICR_PENDBASER_SHAREABILITY_MASK)) {\n\t\t \n\t\tval &= ~(GICR_PENDBASER_SHAREABILITY_MASK |\n\t\t\t GICR_PENDBASER_CACHEABILITY_MASK);\n\t\tval |= GICR_PENDBASER_nC;\n\t\tgicr_write_pendbaser(val, rbase + GICR_PENDBASER);\n\t}\n\n\t \n\tval = readl_relaxed(rbase + GICR_CTLR);\n\tval |= GICR_CTLR_ENABLE_LPIS;\n\twritel_relaxed(val, rbase + GICR_CTLR);\n\n\tif (gic_rdists->has_vlpis && !gic_rdists->has_rvpeid) {\n\t\tvoid __iomem *vlpi_base = gic_data_rdist_vlpi_base();\n\n\t\t \n\t\tval = (LPI_NRBITS - 1) & GICR_VPROPBASER_IDBITS_MASK;\n\t\tpr_debug(\"GICv4: CPU%d: Init IDbits to 0x%llx for GICR_VPROPBASER\\n\",\n\t\t\tsmp_processor_id(), val);\n\t\tgicr_write_vpropbaser(val, vlpi_base + GICR_VPROPBASER);\n\n\t\t \n\t\tval = its_clear_vpend_valid(vlpi_base, 0, 0);\n\t}\n\n\tif (allocate_vpe_l1_table()) {\n\t\t \n\t\tgic_rdists->has_rvpeid = false;\n\t\tgic_rdists->has_vlpis = false;\n\t}\n\n\t \n\tdsb(sy);\nout:\n\tgic_data_rdist()->flags |= RD_LOCAL_LPI_ENABLED;\n\tpr_info(\"GICv3: CPU%d: using %s LPI pending table @%pa\\n\",\n\t\tsmp_processor_id(),\n\t\tgic_data_rdist()->flags & RD_LOCAL_PENDTABLE_PREALLOCATED ?\n\t\t\"reserved\" : \"allocated\",\n\t\t&paddr);\n}\n\nstatic void its_cpu_init_collection(struct its_node *its)\n{\n\tint cpu = smp_processor_id();\n\tu64 target;\n\n\t \n\tif (its->flags & ITS_FLAGS_WORKAROUND_CAVIUM_23144) {\n\t\tstruct device_node *cpu_node;\n\n\t\tcpu_node = of_get_cpu_node(cpu, NULL);\n\t\tif (its->numa_node != NUMA_NO_NODE &&\n\t\t\tits->numa_node != of_node_to_nid(cpu_node))\n\t\t\treturn;\n\t}\n\n\t \n\tif (gic_read_typer(its->base + GITS_TYPER) & GITS_TYPER_PTA) {\n\t\t \n\t\ttarget = gic_data_rdist()->phys_base;\n\t} else {\n\t\t \n\t\ttarget = gic_read_typer(gic_data_rdist_rd_base() + GICR_TYPER);\n\t\ttarget = GICR_TYPER_CPU_NUMBER(target) << 16;\n\t}\n\n\t \n\tits->collections[cpu].target_address = target;\n\tits->collections[cpu].col_id = cpu;\n\n\tits_send_mapc(its, &its->collections[cpu], 1);\n\tits_send_invall(its, &its->collections[cpu]);\n}\n\nstatic void its_cpu_init_collections(void)\n{\n\tstruct its_node *its;\n\n\traw_spin_lock(&its_lock);\n\n\tlist_for_each_entry(its, &its_nodes, entry)\n\t\tits_cpu_init_collection(its);\n\n\traw_spin_unlock(&its_lock);\n}\n\nstatic struct its_device *its_find_device(struct its_node *its, u32 dev_id)\n{\n\tstruct its_device *its_dev = NULL, *tmp;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&its->lock, flags);\n\n\tlist_for_each_entry(tmp, &its->its_device_list, entry) {\n\t\tif (tmp->device_id == dev_id) {\n\t\t\tits_dev = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\traw_spin_unlock_irqrestore(&its->lock, flags);\n\n\treturn its_dev;\n}\n\nstatic struct its_baser *its_get_baser(struct its_node *its, u32 type)\n{\n\tint i;\n\n\tfor (i = 0; i < GITS_BASER_NR_REGS; i++) {\n\t\tif (GITS_BASER_TYPE(its->tables[i].val) == type)\n\t\t\treturn &its->tables[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic bool its_alloc_table_entry(struct its_node *its,\n\t\t\t\t  struct its_baser *baser, u32 id)\n{\n\tstruct page *page;\n\tu32 esz, idx;\n\t__le64 *table;\n\n\t \n\tesz = GITS_BASER_ENTRY_SIZE(baser->val);\n\tif (!(baser->val & GITS_BASER_INDIRECT))\n\t\treturn (id < (PAGE_ORDER_TO_SIZE(baser->order) / esz));\n\n\t \n\tidx = id >> ilog2(baser->psz / esz);\n\tif (idx >= (PAGE_ORDER_TO_SIZE(baser->order) / GITS_LVL1_ENTRY_SIZE))\n\t\treturn false;\n\n\ttable = baser->base;\n\n\t \n\tif (!table[idx]) {\n\t\tpage = alloc_pages_node(its->numa_node, GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\tget_order(baser->psz));\n\t\tif (!page)\n\t\t\treturn false;\n\n\t\t \n\t\tif (!(baser->val & GITS_BASER_SHAREABILITY_MASK))\n\t\t\tgic_flush_dcache_to_poc(page_address(page), baser->psz);\n\n\t\ttable[idx] = cpu_to_le64(page_to_phys(page) | GITS_BASER_VALID);\n\n\t\t \n\t\tif (!(baser->val & GITS_BASER_SHAREABILITY_MASK))\n\t\t\tgic_flush_dcache_to_poc(table + idx, GITS_LVL1_ENTRY_SIZE);\n\n\t\t \n\t\tdsb(sy);\n\t}\n\n\treturn true;\n}\n\nstatic bool its_alloc_device_table(struct its_node *its, u32 dev_id)\n{\n\tstruct its_baser *baser;\n\n\tbaser = its_get_baser(its, GITS_BASER_TYPE_DEVICE);\n\n\t \n\tif (!baser)\n\t\treturn (ilog2(dev_id) < device_ids(its));\n\n\treturn its_alloc_table_entry(its, baser, dev_id);\n}\n\nstatic bool its_alloc_vpe_table(u32 vpe_id)\n{\n\tstruct its_node *its;\n\tint cpu;\n\n\t \n\tlist_for_each_entry(its, &its_nodes, entry) {\n\t\tstruct its_baser *baser;\n\n\t\tif (!is_v4(its))\n\t\t\tcontinue;\n\n\t\tbaser = its_get_baser(its, GITS_BASER_TYPE_VCPU);\n\t\tif (!baser)\n\t\t\treturn false;\n\n\t\tif (!its_alloc_table_entry(its, baser, vpe_id))\n\t\t\treturn false;\n\t}\n\n\t \n\tif (!gic_rdists->has_rvpeid)\n\t\treturn true;\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tif (!allocate_vpe_l2_table(cpu, vpe_id))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic struct its_device *its_create_device(struct its_node *its, u32 dev_id,\n\t\t\t\t\t    int nvecs, bool alloc_lpis)\n{\n\tstruct its_device *dev;\n\tunsigned long *lpi_map = NULL;\n\tunsigned long flags;\n\tu16 *col_map = NULL;\n\tvoid *itt;\n\tint lpi_base;\n\tint nr_lpis;\n\tint nr_ites;\n\tint sz;\n\n\tif (!its_alloc_device_table(its, dev_id))\n\t\treturn NULL;\n\n\tif (WARN_ON(!is_power_of_2(nvecs)))\n\t\tnvecs = roundup_pow_of_two(nvecs);\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\t \n\tnr_ites = max(2, nvecs);\n\tsz = nr_ites * (FIELD_GET(GITS_TYPER_ITT_ENTRY_SIZE, its->typer) + 1);\n\tsz = max(sz, ITS_ITT_ALIGN) + ITS_ITT_ALIGN - 1;\n\titt = kzalloc_node(sz, GFP_KERNEL, its->numa_node);\n\tif (alloc_lpis) {\n\t\tlpi_map = its_lpi_alloc(nvecs, &lpi_base, &nr_lpis);\n\t\tif (lpi_map)\n\t\t\tcol_map = kcalloc(nr_lpis, sizeof(*col_map),\n\t\t\t\t\t  GFP_KERNEL);\n\t} else {\n\t\tcol_map = kcalloc(nr_ites, sizeof(*col_map), GFP_KERNEL);\n\t\tnr_lpis = 0;\n\t\tlpi_base = 0;\n\t}\n\n\tif (!dev || !itt ||  !col_map || (!lpi_map && alloc_lpis)) {\n\t\tkfree(dev);\n\t\tkfree(itt);\n\t\tbitmap_free(lpi_map);\n\t\tkfree(col_map);\n\t\treturn NULL;\n\t}\n\n\tgic_flush_dcache_to_poc(itt, sz);\n\n\tdev->its = its;\n\tdev->itt = itt;\n\tdev->nr_ites = nr_ites;\n\tdev->event_map.lpi_map = lpi_map;\n\tdev->event_map.col_map = col_map;\n\tdev->event_map.lpi_base = lpi_base;\n\tdev->event_map.nr_lpis = nr_lpis;\n\traw_spin_lock_init(&dev->event_map.vlpi_lock);\n\tdev->device_id = dev_id;\n\tINIT_LIST_HEAD(&dev->entry);\n\n\traw_spin_lock_irqsave(&its->lock, flags);\n\tlist_add(&dev->entry, &its->its_device_list);\n\traw_spin_unlock_irqrestore(&its->lock, flags);\n\n\t \n\tits_send_mapd(dev, 1);\n\n\treturn dev;\n}\n\nstatic void its_free_device(struct its_device *its_dev)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&its_dev->its->lock, flags);\n\tlist_del(&its_dev->entry);\n\traw_spin_unlock_irqrestore(&its_dev->its->lock, flags);\n\tkfree(its_dev->event_map.col_map);\n\tkfree(its_dev->itt);\n\tkfree(its_dev);\n}\n\nstatic int its_alloc_device_irq(struct its_device *dev, int nvecs, irq_hw_number_t *hwirq)\n{\n\tint idx;\n\n\t \n\tidx = bitmap_find_free_region(dev->event_map.lpi_map,\n\t\t\t\t      dev->event_map.nr_lpis,\n\t\t\t\t      get_count_order(nvecs));\n\tif (idx < 0)\n\t\treturn -ENOSPC;\n\n\t*hwirq = dev->event_map.lpi_base + idx;\n\n\treturn 0;\n}\n\nstatic int its_msi_prepare(struct irq_domain *domain, struct device *dev,\n\t\t\t   int nvec, msi_alloc_info_t *info)\n{\n\tstruct its_node *its;\n\tstruct its_device *its_dev;\n\tstruct msi_domain_info *msi_info;\n\tu32 dev_id;\n\tint err = 0;\n\n\t \n\tdev_id = info->scratchpad[0].ul;\n\n\tmsi_info = msi_get_domain_info(domain);\n\tits = msi_info->data;\n\n\tif (!gic_rdists->has_direct_lpi &&\n\t    vpe_proxy.dev &&\n\t    vpe_proxy.dev->its == its &&\n\t    dev_id == vpe_proxy.dev->device_id) {\n\t\t \n\t\tWARN_ONCE(1, \"DevId %x clashes with GICv4 VPE proxy device\\n\",\n\t\t\t  dev_id);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&its->dev_alloc_lock);\n\tits_dev = its_find_device(its, dev_id);\n\tif (its_dev) {\n\t\t \n\t\tits_dev->shared = true;\n\t\tpr_debug(\"Reusing ITT for devID %x\\n\", dev_id);\n\t\tgoto out;\n\t}\n\n\tits_dev = its_create_device(its, dev_id, nvec, true);\n\tif (!its_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (info->flags & MSI_ALLOC_FLAGS_PROXY_DEVICE)\n\t\tits_dev->shared = true;\n\n\tpr_debug(\"ITT %d entries, %d bits\\n\", nvec, ilog2(nvec));\nout:\n\tmutex_unlock(&its->dev_alloc_lock);\n\tinfo->scratchpad[0].ptr = its_dev;\n\treturn err;\n}\n\nstatic struct msi_domain_ops its_msi_domain_ops = {\n\t.msi_prepare\t= its_msi_prepare,\n};\n\nstatic int its_irq_gic_domain_alloc(struct irq_domain *domain,\n\t\t\t\t    unsigned int virq,\n\t\t\t\t    irq_hw_number_t hwirq)\n{\n\tstruct irq_fwspec fwspec;\n\n\tif (irq_domain_get_of_node(domain->parent)) {\n\t\tfwspec.fwnode = domain->parent->fwnode;\n\t\tfwspec.param_count = 3;\n\t\tfwspec.param[0] = GIC_IRQ_TYPE_LPI;\n\t\tfwspec.param[1] = hwirq;\n\t\tfwspec.param[2] = IRQ_TYPE_EDGE_RISING;\n\t} else if (is_fwnode_irqchip(domain->parent->fwnode)) {\n\t\tfwspec.fwnode = domain->parent->fwnode;\n\t\tfwspec.param_count = 2;\n\t\tfwspec.param[0] = hwirq;\n\t\tfwspec.param[1] = IRQ_TYPE_EDGE_RISING;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\n}\n\nstatic int its_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs, void *args)\n{\n\tmsi_alloc_info_t *info = args;\n\tstruct its_device *its_dev = info->scratchpad[0].ptr;\n\tstruct its_node *its = its_dev->its;\n\tstruct irq_data *irqd;\n\tirq_hw_number_t hwirq;\n\tint err;\n\tint i;\n\n\terr = its_alloc_device_irq(its_dev, nr_irqs, &hwirq);\n\tif (err)\n\t\treturn err;\n\n\terr = iommu_dma_prepare_msi(info->desc, its->get_msi_base(its_dev));\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\terr = its_irq_gic_domain_alloc(domain, virq + i, hwirq + i);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i,\n\t\t\t\t\t      hwirq + i, &its_irq_chip, its_dev);\n\t\tirqd = irq_get_irq_data(virq + i);\n\t\tirqd_set_single_target(irqd);\n\t\tirqd_set_affinity_on_activate(irqd);\n\t\tirqd_set_resend_when_in_progress(irqd);\n\t\tpr_debug(\"ID:%d pID:%d vID:%d\\n\",\n\t\t\t (int)(hwirq + i - its_dev->event_map.lpi_base),\n\t\t\t (int)(hwirq + i), virq + i);\n\t}\n\n\treturn 0;\n}\n\nstatic int its_irq_domain_activate(struct irq_domain *domain,\n\t\t\t\t   struct irq_data *d, bool reserve)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\tu32 event = its_get_event_id(d);\n\tint cpu;\n\n\tcpu = its_select_cpu(d, cpu_online_mask);\n\tif (cpu < 0 || cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tits_inc_lpi_count(d, cpu);\n\tits_dev->event_map.col_map[event] = cpu;\n\tirq_data_update_effective_affinity(d, cpumask_of(cpu));\n\n\t \n\tits_send_mapti(its_dev, d->hwirq, event);\n\treturn 0;\n}\n\nstatic void its_irq_domain_deactivate(struct irq_domain *domain,\n\t\t\t\t      struct irq_data *d)\n{\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\tu32 event = its_get_event_id(d);\n\n\tits_dec_lpi_count(d, its_dev->event_map.col_map[event]);\n\t \n\tits_send_discard(its_dev, event);\n}\n\nstatic void its_irq_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct its_device *its_dev = irq_data_get_irq_chip_data(d);\n\tstruct its_node *its = its_dev->its;\n\tint i;\n\n\tbitmap_release_region(its_dev->event_map.lpi_map,\n\t\t\t      its_get_event_id(irq_domain_get_irq_data(domain, virq)),\n\t\t\t      get_count_order(nr_irqs));\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tstruct irq_data *data = irq_domain_get_irq_data(domain,\n\t\t\t\t\t\t\t\tvirq + i);\n\t\t \n\t\tirq_domain_reset_irq_data(data);\n\t}\n\n\tmutex_lock(&its->dev_alloc_lock);\n\n\t \n\tif (!its_dev->shared &&\n\t    bitmap_empty(its_dev->event_map.lpi_map,\n\t\t\t its_dev->event_map.nr_lpis)) {\n\t\tits_lpi_free(its_dev->event_map.lpi_map,\n\t\t\t     its_dev->event_map.lpi_base,\n\t\t\t     its_dev->event_map.nr_lpis);\n\n\t\t \n\t\tits_send_mapd(its_dev, 0);\n\t\tits_free_device(its_dev);\n\t}\n\n\tmutex_unlock(&its->dev_alloc_lock);\n\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}\n\nstatic const struct irq_domain_ops its_domain_ops = {\n\t.alloc\t\t\t= its_irq_domain_alloc,\n\t.free\t\t\t= its_irq_domain_free,\n\t.activate\t\t= its_irq_domain_activate,\n\t.deactivate\t\t= its_irq_domain_deactivate,\n};\n\n \nstatic void its_vpe_db_proxy_unmap_locked(struct its_vpe *vpe)\n{\n\t \n\tif (gic_rdists->has_rvpeid)\n\t\treturn;\n\n\t \n\tif (vpe->vpe_proxy_event == -1)\n\t\treturn;\n\n\tits_send_discard(vpe_proxy.dev, vpe->vpe_proxy_event);\n\tvpe_proxy.vpes[vpe->vpe_proxy_event] = NULL;\n\n\t \n\tif (vpe_proxy.vpes[vpe_proxy.next_victim])\n\t\tvpe_proxy.next_victim = vpe->vpe_proxy_event;\n\n\tvpe->vpe_proxy_event = -1;\n}\n\nstatic void its_vpe_db_proxy_unmap(struct its_vpe *vpe)\n{\n\t \n\tif (gic_rdists->has_rvpeid)\n\t\treturn;\n\n\tif (!gic_rdists->has_direct_lpi) {\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&vpe_proxy.lock, flags);\n\t\tits_vpe_db_proxy_unmap_locked(vpe);\n\t\traw_spin_unlock_irqrestore(&vpe_proxy.lock, flags);\n\t}\n}\n\nstatic void its_vpe_db_proxy_map_locked(struct its_vpe *vpe)\n{\n\t \n\tif (gic_rdists->has_rvpeid)\n\t\treturn;\n\n\t \n\tif (vpe->vpe_proxy_event != -1)\n\t\treturn;\n\n\t \n\tif (vpe_proxy.vpes[vpe_proxy.next_victim])\n\t\tits_vpe_db_proxy_unmap_locked(vpe_proxy.vpes[vpe_proxy.next_victim]);\n\n\t \n\tvpe_proxy.vpes[vpe_proxy.next_victim] = vpe;\n\tvpe->vpe_proxy_event = vpe_proxy.next_victim;\n\tvpe_proxy.next_victim = (vpe_proxy.next_victim + 1) % vpe_proxy.dev->nr_ites;\n\n\tvpe_proxy.dev->event_map.col_map[vpe->vpe_proxy_event] = vpe->col_idx;\n\tits_send_mapti(vpe_proxy.dev, vpe->vpe_db_lpi, vpe->vpe_proxy_event);\n}\n\nstatic void its_vpe_db_proxy_move(struct its_vpe *vpe, int from, int to)\n{\n\tunsigned long flags;\n\tstruct its_collection *target_col;\n\n\t \n\tif (gic_rdists->has_rvpeid)\n\t\treturn;\n\n\tif (gic_rdists->has_direct_lpi) {\n\t\tvoid __iomem *rdbase;\n\n\t\trdbase = per_cpu_ptr(gic_rdists->rdist, from)->rd_base;\n\t\tgic_write_lpir(vpe->vpe_db_lpi, rdbase + GICR_CLRLPIR);\n\t\twait_for_syncr(rdbase);\n\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&vpe_proxy.lock, flags);\n\n\tits_vpe_db_proxy_map_locked(vpe);\n\n\ttarget_col = &vpe_proxy.dev->its->collections[to];\n\tits_send_movi(vpe_proxy.dev, target_col, vpe->vpe_proxy_event);\n\tvpe_proxy.dev->event_map.col_map[vpe->vpe_proxy_event] = to;\n\n\traw_spin_unlock_irqrestore(&vpe_proxy.lock, flags);\n}\n\nstatic int its_vpe_set_affinity(struct irq_data *d,\n\t\t\t\tconst struct cpumask *mask_val,\n\t\t\t\tbool force)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\tint from, cpu = cpumask_first(mask_val);\n\tunsigned long flags;\n\n\t \n\tfrom = vpe_to_cpuid_lock(vpe, &flags);\n\tif (from == cpu)\n\t\tgoto out;\n\n\tvpe->col_idx = cpu;\n\n\t \n\tif (gic_data_rdist_cpu(cpu)->vpe_table_mask &&\n\t    cpumask_test_cpu(from, gic_data_rdist_cpu(cpu)->vpe_table_mask))\n\t\tgoto out;\n\n\tits_send_vmovp(vpe);\n\tits_vpe_db_proxy_move(vpe, from, cpu);\n\nout:\n\tirq_data_update_effective_affinity(d, cpumask_of(cpu));\n\tvpe_to_cpuid_unlock(vpe, flags);\n\n\treturn IRQ_SET_MASK_OK_DONE;\n}\n\nstatic void its_wait_vpt_parse_complete(void)\n{\n\tvoid __iomem *vlpi_base = gic_data_rdist_vlpi_base();\n\tu64 val;\n\n\tif (!gic_rdists->has_vpend_valid_dirty)\n\t\treturn;\n\n\tWARN_ON_ONCE(readq_relaxed_poll_timeout_atomic(vlpi_base + GICR_VPENDBASER,\n\t\t\t\t\t\t       val,\n\t\t\t\t\t\t       !(val & GICR_VPENDBASER_Dirty),\n\t\t\t\t\t\t       1, 500));\n}\n\nstatic void its_vpe_schedule(struct its_vpe *vpe)\n{\n\tvoid __iomem *vlpi_base = gic_data_rdist_vlpi_base();\n\tu64 val;\n\n\t \n\tval  = virt_to_phys(page_address(vpe->its_vm->vprop_page)) &\n\t\tGENMASK_ULL(51, 12);\n\tval |= (LPI_NRBITS - 1) & GICR_VPROPBASER_IDBITS_MASK;\n\tval |= GICR_VPROPBASER_RaWb;\n\tval |= GICR_VPROPBASER_InnerShareable;\n\tgicr_write_vpropbaser(val, vlpi_base + GICR_VPROPBASER);\n\n\tval  = virt_to_phys(page_address(vpe->vpt_page)) &\n\t\tGENMASK_ULL(51, 16);\n\tval |= GICR_VPENDBASER_RaWaWb;\n\tval |= GICR_VPENDBASER_InnerShareable;\n\t \n\tval |= GICR_VPENDBASER_PendingLast;\n\tval |= vpe->idai ? GICR_VPENDBASER_IDAI : 0;\n\tval |= GICR_VPENDBASER_Valid;\n\tgicr_write_vpendbaser(val, vlpi_base + GICR_VPENDBASER);\n}\n\nstatic void its_vpe_deschedule(struct its_vpe *vpe)\n{\n\tvoid __iomem *vlpi_base = gic_data_rdist_vlpi_base();\n\tu64 val;\n\n\tval = its_clear_vpend_valid(vlpi_base, 0, 0);\n\n\tvpe->idai = !!(val & GICR_VPENDBASER_IDAI);\n\tvpe->pending_last = !!(val & GICR_VPENDBASER_PendingLast);\n}\n\nstatic void its_vpe_invall(struct its_vpe *vpe)\n{\n\tstruct its_node *its;\n\n\tlist_for_each_entry(its, &its_nodes, entry) {\n\t\tif (!is_v4(its))\n\t\t\tcontinue;\n\n\t\tif (its_list_map && !vpe->its_vm->vlpi_count[its->list_nr])\n\t\t\tcontinue;\n\n\t\t \n\t\tits_send_vinvall(its, vpe);\n\t\treturn;\n\t}\n}\n\nstatic int its_vpe_set_vcpu_affinity(struct irq_data *d, void *vcpu_info)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\tstruct its_cmd_info *info = vcpu_info;\n\n\tswitch (info->cmd_type) {\n\tcase SCHEDULE_VPE:\n\t\tits_vpe_schedule(vpe);\n\t\treturn 0;\n\n\tcase DESCHEDULE_VPE:\n\t\tits_vpe_deschedule(vpe);\n\t\treturn 0;\n\n\tcase COMMIT_VPE:\n\t\tits_wait_vpt_parse_complete();\n\t\treturn 0;\n\n\tcase INVALL_VPE:\n\t\tits_vpe_invall(vpe);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void its_vpe_send_cmd(struct its_vpe *vpe,\n\t\t\t     void (*cmd)(struct its_device *, u32))\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&vpe_proxy.lock, flags);\n\n\tits_vpe_db_proxy_map_locked(vpe);\n\tcmd(vpe_proxy.dev, vpe->vpe_proxy_event);\n\n\traw_spin_unlock_irqrestore(&vpe_proxy.lock, flags);\n}\n\nstatic void its_vpe_send_inv(struct irq_data *d)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\n\tif (gic_rdists->has_direct_lpi)\n\t\t__direct_lpi_inv(d, d->parent_data->hwirq);\n\telse\n\t\tits_vpe_send_cmd(vpe, its_send_inv);\n}\n\nstatic void its_vpe_mask_irq(struct irq_data *d)\n{\n\t \n\tlpi_write_config(d->parent_data, LPI_PROP_ENABLED, 0);\n\tits_vpe_send_inv(d);\n}\n\nstatic void its_vpe_unmask_irq(struct irq_data *d)\n{\n\t \n\tlpi_write_config(d->parent_data, 0, LPI_PROP_ENABLED);\n\tits_vpe_send_inv(d);\n}\n\nstatic int its_vpe_set_irqchip_state(struct irq_data *d,\n\t\t\t\t     enum irqchip_irq_state which,\n\t\t\t\t     bool state)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\n\tif (which != IRQCHIP_STATE_PENDING)\n\t\treturn -EINVAL;\n\n\tif (gic_rdists->has_direct_lpi) {\n\t\tvoid __iomem *rdbase;\n\n\t\trdbase = per_cpu_ptr(gic_rdists->rdist, vpe->col_idx)->rd_base;\n\t\tif (state) {\n\t\t\tgic_write_lpir(vpe->vpe_db_lpi, rdbase + GICR_SETLPIR);\n\t\t} else {\n\t\t\tgic_write_lpir(vpe->vpe_db_lpi, rdbase + GICR_CLRLPIR);\n\t\t\twait_for_syncr(rdbase);\n\t\t}\n\t} else {\n\t\tif (state)\n\t\t\tits_vpe_send_cmd(vpe, its_send_int);\n\t\telse\n\t\t\tits_vpe_send_cmd(vpe, its_send_clear);\n\t}\n\n\treturn 0;\n}\n\nstatic int its_vpe_retrigger(struct irq_data *d)\n{\n\treturn !its_vpe_set_irqchip_state(d, IRQCHIP_STATE_PENDING, true);\n}\n\nstatic struct irq_chip its_vpe_irq_chip = {\n\t.name\t\t\t= \"GICv4-vpe\",\n\t.irq_mask\t\t= its_vpe_mask_irq,\n\t.irq_unmask\t\t= its_vpe_unmask_irq,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_affinity\t= its_vpe_set_affinity,\n\t.irq_retrigger\t\t= its_vpe_retrigger,\n\t.irq_set_irqchip_state\t= its_vpe_set_irqchip_state,\n\t.irq_set_vcpu_affinity\t= its_vpe_set_vcpu_affinity,\n};\n\nstatic struct its_node *find_4_1_its(void)\n{\n\tstatic struct its_node *its = NULL;\n\n\tif (!its) {\n\t\tlist_for_each_entry(its, &its_nodes, entry) {\n\t\t\tif (is_v4_1(its))\n\t\t\t\treturn its;\n\t\t}\n\n\t\t \n\t\tits = NULL;\n\t}\n\n\treturn its;\n}\n\nstatic void its_vpe_4_1_send_inv(struct irq_data *d)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\tstruct its_node *its;\n\n\t \n\tits = find_4_1_its();\n\tif (its)\n\t\tits_send_invdb(its, vpe);\n}\n\nstatic void its_vpe_4_1_mask_irq(struct irq_data *d)\n{\n\tlpi_write_config(d->parent_data, LPI_PROP_ENABLED, 0);\n\tits_vpe_4_1_send_inv(d);\n}\n\nstatic void its_vpe_4_1_unmask_irq(struct irq_data *d)\n{\n\tlpi_write_config(d->parent_data, 0, LPI_PROP_ENABLED);\n\tits_vpe_4_1_send_inv(d);\n}\n\nstatic void its_vpe_4_1_schedule(struct its_vpe *vpe,\n\t\t\t\t struct its_cmd_info *info)\n{\n\tvoid __iomem *vlpi_base = gic_data_rdist_vlpi_base();\n\tu64 val = 0;\n\n\t \n\tval |= GICR_VPENDBASER_Valid;\n\tval |= info->g0en ? GICR_VPENDBASER_4_1_VGRP0EN : 0;\n\tval |= info->g1en ? GICR_VPENDBASER_4_1_VGRP1EN : 0;\n\tval |= FIELD_PREP(GICR_VPENDBASER_4_1_VPEID, vpe->vpe_id);\n\n\tgicr_write_vpendbaser(val, vlpi_base + GICR_VPENDBASER);\n}\n\nstatic void its_vpe_4_1_deschedule(struct its_vpe *vpe,\n\t\t\t\t   struct its_cmd_info *info)\n{\n\tvoid __iomem *vlpi_base = gic_data_rdist_vlpi_base();\n\tu64 val;\n\n\tif (info->req_db) {\n\t\tunsigned long flags;\n\n\t\t \n\t\traw_spin_lock_irqsave(&vpe->vpe_lock, flags);\n\t\tval = its_clear_vpend_valid(vlpi_base,\n\t\t\t\t\t    GICR_VPENDBASER_PendingLast,\n\t\t\t\t\t    GICR_VPENDBASER_4_1_DB);\n\t\tvpe->pending_last = !!(val & GICR_VPENDBASER_PendingLast);\n\t\traw_spin_unlock_irqrestore(&vpe->vpe_lock, flags);\n\t} else {\n\t\t \n\t\tval = its_clear_vpend_valid(vlpi_base,\n\t\t\t\t\t    0,\n\t\t\t\t\t    GICR_VPENDBASER_PendingLast);\n\t\tvpe->pending_last = true;\n\t}\n}\n\nstatic void its_vpe_4_1_invall(struct its_vpe *vpe)\n{\n\tvoid __iomem *rdbase;\n\tunsigned long flags;\n\tu64 val;\n\tint cpu;\n\n\tval  = GICR_INVALLR_V;\n\tval |= FIELD_PREP(GICR_INVALLR_VPEID, vpe->vpe_id);\n\n\t \n\tcpu = vpe_to_cpuid_lock(vpe, &flags);\n\traw_spin_lock(&gic_data_rdist_cpu(cpu)->rd_lock);\n\trdbase = per_cpu_ptr(gic_rdists->rdist, cpu)->rd_base;\n\tgic_write_lpir(val, rdbase + GICR_INVALLR);\n\n\twait_for_syncr(rdbase);\n\traw_spin_unlock(&gic_data_rdist_cpu(cpu)->rd_lock);\n\tvpe_to_cpuid_unlock(vpe, flags);\n}\n\nstatic int its_vpe_4_1_set_vcpu_affinity(struct irq_data *d, void *vcpu_info)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\tstruct its_cmd_info *info = vcpu_info;\n\n\tswitch (info->cmd_type) {\n\tcase SCHEDULE_VPE:\n\t\tits_vpe_4_1_schedule(vpe, info);\n\t\treturn 0;\n\n\tcase DESCHEDULE_VPE:\n\t\tits_vpe_4_1_deschedule(vpe, info);\n\t\treturn 0;\n\n\tcase COMMIT_VPE:\n\t\tits_wait_vpt_parse_complete();\n\t\treturn 0;\n\n\tcase INVALL_VPE:\n\t\tits_vpe_4_1_invall(vpe);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic struct irq_chip its_vpe_4_1_irq_chip = {\n\t.name\t\t\t= \"GICv4.1-vpe\",\n\t.irq_mask\t\t= its_vpe_4_1_mask_irq,\n\t.irq_unmask\t\t= its_vpe_4_1_unmask_irq,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_affinity\t= its_vpe_set_affinity,\n\t.irq_set_vcpu_affinity\t= its_vpe_4_1_set_vcpu_affinity,\n};\n\nstatic void its_configure_sgi(struct irq_data *d, bool clear)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\tstruct its_cmd_desc desc;\n\n\tdesc.its_vsgi_cmd.vpe = vpe;\n\tdesc.its_vsgi_cmd.sgi = d->hwirq;\n\tdesc.its_vsgi_cmd.priority = vpe->sgi_config[d->hwirq].priority;\n\tdesc.its_vsgi_cmd.enable = vpe->sgi_config[d->hwirq].enabled;\n\tdesc.its_vsgi_cmd.group = vpe->sgi_config[d->hwirq].group;\n\tdesc.its_vsgi_cmd.clear = clear;\n\n\t \n\tits_send_single_vcommand(find_4_1_its(), its_build_vsgi_cmd, &desc);\n}\n\nstatic void its_sgi_mask_irq(struct irq_data *d)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\n\tvpe->sgi_config[d->hwirq].enabled = false;\n\tits_configure_sgi(d, false);\n}\n\nstatic void its_sgi_unmask_irq(struct irq_data *d)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\n\tvpe->sgi_config[d->hwirq].enabled = true;\n\tits_configure_sgi(d, false);\n}\n\nstatic int its_sgi_set_affinity(struct irq_data *d,\n\t\t\t\tconst struct cpumask *mask_val,\n\t\t\t\tbool force)\n{\n\t \n\tirq_data_update_effective_affinity(d, mask_val);\n\treturn IRQ_SET_MASK_OK;\n}\n\nstatic int its_sgi_set_irqchip_state(struct irq_data *d,\n\t\t\t\t     enum irqchip_irq_state which,\n\t\t\t\t     bool state)\n{\n\tif (which != IRQCHIP_STATE_PENDING)\n\t\treturn -EINVAL;\n\n\tif (state) {\n\t\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\t\tstruct its_node *its = find_4_1_its();\n\t\tu64 val;\n\n\t\tval  = FIELD_PREP(GITS_SGIR_VPEID, vpe->vpe_id);\n\t\tval |= FIELD_PREP(GITS_SGIR_VINTID, d->hwirq);\n\t\twriteq_relaxed(val, its->sgir_base + GITS_SGIR - SZ_128K);\n\t} else {\n\t\tits_configure_sgi(d, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int its_sgi_get_irqchip_state(struct irq_data *d,\n\t\t\t\t     enum irqchip_irq_state which, bool *val)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\tvoid __iomem *base;\n\tunsigned long flags;\n\tu32 count = 1000000;\t \n\tu32 status;\n\tint cpu;\n\n\tif (which != IRQCHIP_STATE_PENDING)\n\t\treturn -EINVAL;\n\n\t \n\tcpu = vpe_to_cpuid_lock(vpe, &flags);\n\traw_spin_lock(&gic_data_rdist_cpu(cpu)->rd_lock);\n\tbase = gic_data_rdist_cpu(cpu)->rd_base + SZ_128K;\n\twritel_relaxed(vpe->vpe_id, base + GICR_VSGIR);\n\tdo {\n\t\tstatus = readl_relaxed(base + GICR_VSGIPENDR);\n\t\tif (!(status & GICR_VSGIPENDR_BUSY))\n\t\t\tgoto out;\n\n\t\tcount--;\n\t\tif (!count) {\n\t\t\tpr_err_ratelimited(\"Unable to get SGI status\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tcpu_relax();\n\t\tudelay(1);\n\t} while (count);\n\nout:\n\traw_spin_unlock(&gic_data_rdist_cpu(cpu)->rd_lock);\n\tvpe_to_cpuid_unlock(vpe, flags);\n\n\tif (!count)\n\t\treturn -ENXIO;\n\n\t*val = !!(status & (1 << d->hwirq));\n\n\treturn 0;\n}\n\nstatic int its_sgi_set_vcpu_affinity(struct irq_data *d, void *vcpu_info)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\tstruct its_cmd_info *info = vcpu_info;\n\n\tswitch (info->cmd_type) {\n\tcase PROP_UPDATE_VSGI:\n\t\tvpe->sgi_config[d->hwirq].priority = info->priority;\n\t\tvpe->sgi_config[d->hwirq].group = info->group;\n\t\tits_configure_sgi(d, false);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic struct irq_chip its_sgi_irq_chip = {\n\t.name\t\t\t= \"GICv4.1-sgi\",\n\t.irq_mask\t\t= its_sgi_mask_irq,\n\t.irq_unmask\t\t= its_sgi_unmask_irq,\n\t.irq_set_affinity\t= its_sgi_set_affinity,\n\t.irq_set_irqchip_state\t= its_sgi_set_irqchip_state,\n\t.irq_get_irqchip_state\t= its_sgi_get_irqchip_state,\n\t.irq_set_vcpu_affinity\t= its_sgi_set_vcpu_affinity,\n};\n\nstatic int its_sgi_irq_domain_alloc(struct irq_domain *domain,\n\t\t\t\t    unsigned int virq, unsigned int nr_irqs,\n\t\t\t\t    void *args)\n{\n\tstruct its_vpe *vpe = args;\n\tint i;\n\n\t \n\tWARN_ON(nr_irqs != 16);\n\n\tfor (i = 0; i < 16; i++) {\n\t\tvpe->sgi_config[i].priority = 0;\n\t\tvpe->sgi_config[i].enabled = false;\n\t\tvpe->sgi_config[i].group = false;\n\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, i,\n\t\t\t\t\t      &its_sgi_irq_chip, vpe);\n\t\tirq_set_status_flags(virq + i, IRQ_DISABLE_UNLAZY);\n\t}\n\n\treturn 0;\n}\n\nstatic void its_sgi_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t    unsigned int virq,\n\t\t\t\t    unsigned int nr_irqs)\n{\n\t \n}\n\nstatic int its_sgi_irq_domain_activate(struct irq_domain *domain,\n\t\t\t\t       struct irq_data *d, bool reserve)\n{\n\t \n\tits_configure_sgi(d, false);\n\treturn 0;\n}\n\nstatic void its_sgi_irq_domain_deactivate(struct irq_domain *domain,\n\t\t\t\t\t  struct irq_data *d)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\n\t \n\tvpe->sgi_config[d->hwirq].enabled = false;\n\tits_configure_sgi(d, false);\n\tits_configure_sgi(d, true);\n}\n\nstatic const struct irq_domain_ops its_sgi_domain_ops = {\n\t.alloc\t\t= its_sgi_irq_domain_alloc,\n\t.free\t\t= its_sgi_irq_domain_free,\n\t.activate\t= its_sgi_irq_domain_activate,\n\t.deactivate\t= its_sgi_irq_domain_deactivate,\n};\n\nstatic int its_vpe_id_alloc(void)\n{\n\treturn ida_simple_get(&its_vpeid_ida, 0, ITS_MAX_VPEID, GFP_KERNEL);\n}\n\nstatic void its_vpe_id_free(u16 id)\n{\n\tida_simple_remove(&its_vpeid_ida, id);\n}\n\nstatic int its_vpe_init(struct its_vpe *vpe)\n{\n\tstruct page *vpt_page;\n\tint vpe_id;\n\n\t \n\tvpe_id = its_vpe_id_alloc();\n\tif (vpe_id < 0)\n\t\treturn vpe_id;\n\n\t \n\tvpt_page = its_allocate_pending_table(GFP_KERNEL);\n\tif (!vpt_page) {\n\t\tits_vpe_id_free(vpe_id);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!its_alloc_vpe_table(vpe_id)) {\n\t\tits_vpe_id_free(vpe_id);\n\t\tits_free_pending_table(vpt_page);\n\t\treturn -ENOMEM;\n\t}\n\n\traw_spin_lock_init(&vpe->vpe_lock);\n\tvpe->vpe_id = vpe_id;\n\tvpe->vpt_page = vpt_page;\n\tif (gic_rdists->has_rvpeid)\n\t\tatomic_set(&vpe->vmapp_count, 0);\n\telse\n\t\tvpe->vpe_proxy_event = -1;\n\n\treturn 0;\n}\n\nstatic void its_vpe_teardown(struct its_vpe *vpe)\n{\n\tits_vpe_db_proxy_unmap(vpe);\n\tits_vpe_id_free(vpe->vpe_id);\n\tits_free_pending_table(vpe->vpt_page);\n}\n\nstatic void its_vpe_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t    unsigned int virq,\n\t\t\t\t    unsigned int nr_irqs)\n{\n\tstruct its_vm *vm = domain->host_data;\n\tint i;\n\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tstruct irq_data *data = irq_domain_get_irq_data(domain,\n\t\t\t\t\t\t\t\tvirq + i);\n\t\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(data);\n\n\t\tBUG_ON(vm != vpe->its_vm);\n\n\t\tclear_bit(data->hwirq, vm->db_bitmap);\n\t\tits_vpe_teardown(vpe);\n\t\tirq_domain_reset_irq_data(data);\n\t}\n\n\tif (bitmap_empty(vm->db_bitmap, vm->nr_db_lpis)) {\n\t\tits_lpi_free(vm->db_bitmap, vm->db_lpi_base, vm->nr_db_lpis);\n\t\tits_free_prop_table(vm->vprop_page);\n\t}\n}\n\nstatic int its_vpe_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t    unsigned int nr_irqs, void *args)\n{\n\tstruct irq_chip *irqchip = &its_vpe_irq_chip;\n\tstruct its_vm *vm = args;\n\tunsigned long *bitmap;\n\tstruct page *vprop_page;\n\tint base, nr_ids, i, err = 0;\n\n\tBUG_ON(!vm);\n\n\tbitmap = its_lpi_alloc(roundup_pow_of_two(nr_irqs), &base, &nr_ids);\n\tif (!bitmap)\n\t\treturn -ENOMEM;\n\n\tif (nr_ids < nr_irqs) {\n\t\tits_lpi_free(bitmap, base, nr_ids);\n\t\treturn -ENOMEM;\n\t}\n\n\tvprop_page = its_allocate_prop_table(GFP_KERNEL);\n\tif (!vprop_page) {\n\t\tits_lpi_free(bitmap, base, nr_ids);\n\t\treturn -ENOMEM;\n\t}\n\n\tvm->db_bitmap = bitmap;\n\tvm->db_lpi_base = base;\n\tvm->nr_db_lpis = nr_ids;\n\tvm->vprop_page = vprop_page;\n\n\tif (gic_rdists->has_rvpeid)\n\t\tirqchip = &its_vpe_4_1_irq_chip;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tvm->vpes[i]->vpe_db_lpi = base + i;\n\t\terr = its_vpe_init(vm->vpes[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = its_irq_gic_domain_alloc(domain, virq + i,\n\t\t\t\t\t       vm->vpes[i]->vpe_db_lpi);\n\t\tif (err)\n\t\t\tbreak;\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, i,\n\t\t\t\t\t      irqchip, vm->vpes[i]);\n\t\tset_bit(i, bitmap);\n\t\tirqd_set_resend_when_in_progress(irq_get_irq_data(virq + i));\n\t}\n\n\tif (err) {\n\t\tif (i > 0)\n\t\t\tits_vpe_irq_domain_free(domain, virq, i);\n\n\t\tits_lpi_free(bitmap, base, nr_ids);\n\t\tits_free_prop_table(vprop_page);\n\t}\n\n\treturn err;\n}\n\nstatic int its_vpe_irq_domain_activate(struct irq_domain *domain,\n\t\t\t\t       struct irq_data *d, bool reserve)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\tstruct its_node *its;\n\n\t \n\tif (!gic_requires_eager_mapping())\n\t\treturn 0;\n\n\t \n\tvpe->col_idx = cpumask_first(cpu_online_mask);\n\n\tlist_for_each_entry(its, &its_nodes, entry) {\n\t\tif (!is_v4(its))\n\t\t\tcontinue;\n\n\t\tits_send_vmapp(its, vpe, true);\n\t\tits_send_vinvall(its, vpe);\n\t}\n\n\tirq_data_update_effective_affinity(d, cpumask_of(vpe->col_idx));\n\n\treturn 0;\n}\n\nstatic void its_vpe_irq_domain_deactivate(struct irq_domain *domain,\n\t\t\t\t\t  struct irq_data *d)\n{\n\tstruct its_vpe *vpe = irq_data_get_irq_chip_data(d);\n\tstruct its_node *its;\n\n\t \n\tif (!gic_requires_eager_mapping())\n\t\treturn;\n\n\tlist_for_each_entry(its, &its_nodes, entry) {\n\t\tif (!is_v4(its))\n\t\t\tcontinue;\n\n\t\tits_send_vmapp(its, vpe, false);\n\t}\n\n\t \n\tif (find_4_1_its() && !atomic_read(&vpe->vmapp_count))\n\t\tgic_flush_dcache_to_poc(page_address(vpe->vpt_page),\n\t\t\t\t\tLPI_PENDBASE_SZ);\n}\n\nstatic const struct irq_domain_ops its_vpe_domain_ops = {\n\t.alloc\t\t\t= its_vpe_irq_domain_alloc,\n\t.free\t\t\t= its_vpe_irq_domain_free,\n\t.activate\t\t= its_vpe_irq_domain_activate,\n\t.deactivate\t\t= its_vpe_irq_domain_deactivate,\n};\n\nstatic int its_force_quiescent(void __iomem *base)\n{\n\tu32 count = 1000000;\t \n\tu32 val;\n\n\tval = readl_relaxed(base + GITS_CTLR);\n\t \n\tif ((val & GITS_CTLR_QUIESCENT) && !(val & GITS_CTLR_ENABLE))\n\t\treturn 0;\n\n\t \n\tval &= ~(GITS_CTLR_ENABLE | GITS_CTLR_ImDe);\n\twritel_relaxed(val, base + GITS_CTLR);\n\n\t \n\twhile (1) {\n\t\tval = readl_relaxed(base + GITS_CTLR);\n\t\tif (val & GITS_CTLR_QUIESCENT)\n\t\t\treturn 0;\n\n\t\tcount--;\n\t\tif (!count)\n\t\t\treturn -EBUSY;\n\n\t\tcpu_relax();\n\t\tudelay(1);\n\t}\n}\n\nstatic bool __maybe_unused its_enable_quirk_cavium_22375(void *data)\n{\n\tstruct its_node *its = data;\n\n\t \n\tits->typer &= ~GITS_TYPER_DEVBITS;\n\tits->typer |= FIELD_PREP(GITS_TYPER_DEVBITS, 20 - 1);\n\tits->flags |= ITS_FLAGS_WORKAROUND_CAVIUM_22375;\n\n\treturn true;\n}\n\nstatic bool __maybe_unused its_enable_quirk_cavium_23144(void *data)\n{\n\tstruct its_node *its = data;\n\n\tits->flags |= ITS_FLAGS_WORKAROUND_CAVIUM_23144;\n\n\treturn true;\n}\n\nstatic bool __maybe_unused its_enable_quirk_qdf2400_e0065(void *data)\n{\n\tstruct its_node *its = data;\n\n\t \n\tits->typer &= ~GITS_TYPER_ITT_ENTRY_SIZE;\n\tits->typer |= FIELD_PREP(GITS_TYPER_ITT_ENTRY_SIZE, 16 - 1);\n\n\treturn true;\n}\n\nstatic u64 its_irq_get_msi_base_pre_its(struct its_device *its_dev)\n{\n\tstruct its_node *its = its_dev->its;\n\n\t \n\treturn its->pre_its_base + (its_dev->device_id << 2);\n}\n\nstatic bool __maybe_unused its_enable_quirk_socionext_synquacer(void *data)\n{\n\tstruct its_node *its = data;\n\tu32 pre_its_window[2];\n\tu32 ids;\n\n\tif (!fwnode_property_read_u32_array(its->fwnode_handle,\n\t\t\t\t\t   \"socionext,synquacer-pre-its\",\n\t\t\t\t\t   pre_its_window,\n\t\t\t\t\t   ARRAY_SIZE(pre_its_window))) {\n\n\t\tits->pre_its_base = pre_its_window[0];\n\t\tits->get_msi_base = its_irq_get_msi_base_pre_its;\n\n\t\tids = ilog2(pre_its_window[1]) - 2;\n\t\tif (device_ids(its) > ids) {\n\t\t\tits->typer &= ~GITS_TYPER_DEVBITS;\n\t\t\tits->typer |= FIELD_PREP(GITS_TYPER_DEVBITS, ids - 1);\n\t\t}\n\n\t\t \n\t\tits->msi_domain_flags &= ~IRQ_DOMAIN_FLAG_ISOLATED_MSI;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool __maybe_unused its_enable_quirk_hip07_161600802(void *data)\n{\n\tstruct its_node *its = data;\n\n\t \n\tits->vlpi_redist_offset = SZ_128K;\n\treturn true;\n}\n\nstatic bool __maybe_unused its_enable_rk3588001(void *data)\n{\n\tstruct its_node *its = data;\n\n\tif (!of_machine_is_compatible(\"rockchip,rk3588\") &&\n\t    !of_machine_is_compatible(\"rockchip,rk3588s\"))\n\t\treturn false;\n\n\tits->flags |= ITS_FLAGS_FORCE_NON_SHAREABLE;\n\tgic_rdists->flags |= RDIST_FLAGS_FORCE_NON_SHAREABLE;\n\n\treturn true;\n}\n\nstatic bool its_set_non_coherent(void *data)\n{\n\tstruct its_node *its = data;\n\n\tits->flags |= ITS_FLAGS_FORCE_NON_SHAREABLE;\n\treturn true;\n}\n\nstatic const struct gic_quirk its_quirks[] = {\n#ifdef CONFIG_CAVIUM_ERRATUM_22375\n\t{\n\t\t.desc\t= \"ITS: Cavium errata 22375, 24313\",\n\t\t.iidr\t= 0xa100034c,\t \n\t\t.mask\t= 0xffff0fff,\n\t\t.init\t= its_enable_quirk_cavium_22375,\n\t},\n#endif\n#ifdef CONFIG_CAVIUM_ERRATUM_23144\n\t{\n\t\t.desc\t= \"ITS: Cavium erratum 23144\",\n\t\t.iidr\t= 0xa100034c,\t \n\t\t.mask\t= 0xffff0fff,\n\t\t.init\t= its_enable_quirk_cavium_23144,\n\t},\n#endif\n#ifdef CONFIG_QCOM_QDF2400_ERRATUM_0065\n\t{\n\t\t.desc\t= \"ITS: QDF2400 erratum 0065\",\n\t\t.iidr\t= 0x00001070,  \n\t\t.mask\t= 0xffffffff,\n\t\t.init\t= its_enable_quirk_qdf2400_e0065,\n\t},\n#endif\n#ifdef CONFIG_SOCIONEXT_SYNQUACER_PREITS\n\t{\n\t\t \n\t\t.desc\t= \"ITS: Socionext Synquacer pre-ITS\",\n\t\t.iidr\t= 0x0001143b,\n\t\t.mask\t= 0xffffffff,\n\t\t.init\t= its_enable_quirk_socionext_synquacer,\n\t},\n#endif\n#ifdef CONFIG_HISILICON_ERRATUM_161600802\n\t{\n\t\t.desc\t= \"ITS: Hip07 erratum 161600802\",\n\t\t.iidr\t= 0x00000004,\n\t\t.mask\t= 0xffffffff,\n\t\t.init\t= its_enable_quirk_hip07_161600802,\n\t},\n#endif\n#ifdef CONFIG_ROCKCHIP_ERRATUM_3588001\n\t{\n\t\t.desc   = \"ITS: Rockchip erratum RK3588001\",\n\t\t.iidr   = 0x0201743b,\n\t\t.mask   = 0xffffffff,\n\t\t.init   = its_enable_rk3588001,\n\t},\n#endif\n\t{\n\t\t.desc   = \"ITS: non-coherent attribute\",\n\t\t.property = \"dma-noncoherent\",\n\t\t.init   = its_set_non_coherent,\n\t},\n\t{\n\t}\n};\n\nstatic void its_enable_quirks(struct its_node *its)\n{\n\tu32 iidr = readl_relaxed(its->base + GITS_IIDR);\n\n\tgic_enable_quirks(iidr, its_quirks, its);\n\n\tif (is_of_node(its->fwnode_handle))\n\t\tgic_enable_of_quirks(to_of_node(its->fwnode_handle),\n\t\t\t\t     its_quirks, its);\n}\n\nstatic int its_save_disable(void)\n{\n\tstruct its_node *its;\n\tint err = 0;\n\n\traw_spin_lock(&its_lock);\n\tlist_for_each_entry(its, &its_nodes, entry) {\n\t\tvoid __iomem *base;\n\n\t\tbase = its->base;\n\t\tits->ctlr_save = readl_relaxed(base + GITS_CTLR);\n\t\terr = its_force_quiescent(base);\n\t\tif (err) {\n\t\t\tpr_err(\"ITS@%pa: failed to quiesce: %d\\n\",\n\t\t\t       &its->phys_base, err);\n\t\t\twritel_relaxed(its->ctlr_save, base + GITS_CTLR);\n\t\t\tgoto err;\n\t\t}\n\n\t\tits->cbaser_save = gits_read_cbaser(base + GITS_CBASER);\n\t}\n\nerr:\n\tif (err) {\n\t\tlist_for_each_entry_continue_reverse(its, &its_nodes, entry) {\n\t\t\tvoid __iomem *base;\n\n\t\t\tbase = its->base;\n\t\t\twritel_relaxed(its->ctlr_save, base + GITS_CTLR);\n\t\t}\n\t}\n\traw_spin_unlock(&its_lock);\n\n\treturn err;\n}\n\nstatic void its_restore_enable(void)\n{\n\tstruct its_node *its;\n\tint ret;\n\n\traw_spin_lock(&its_lock);\n\tlist_for_each_entry(its, &its_nodes, entry) {\n\t\tvoid __iomem *base;\n\t\tint i;\n\n\t\tbase = its->base;\n\n\t\t \n\t\tWARN_ON(readl_relaxed(base + GITS_CTLR) & GITS_CTLR_ENABLE);\n\t\tret = its_force_quiescent(base);\n\t\tif (ret) {\n\t\t\tpr_err(\"ITS@%pa: failed to quiesce on resume: %d\\n\",\n\t\t\t       &its->phys_base, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgits_write_cbaser(its->cbaser_save, base + GITS_CBASER);\n\n\t\t \n\t\tits->cmd_write = its->cmd_base;\n\t\tgits_write_cwriter(0, base + GITS_CWRITER);\n\n\t\t \n\t\tfor (i = 0; i < GITS_BASER_NR_REGS; i++) {\n\t\t\tstruct its_baser *baser = &its->tables[i];\n\n\t\t\tif (!(baser->val & GITS_BASER_VALID))\n\t\t\t\tcontinue;\n\n\t\t\tits_write_baser(its, baser, baser->val);\n\t\t}\n\t\twritel_relaxed(its->ctlr_save, base + GITS_CTLR);\n\n\t\t \n\t\tif (its->collections[smp_processor_id()].col_id <\n\t\t    GITS_TYPER_HCC(gic_read_typer(base + GITS_TYPER)))\n\t\t\tits_cpu_init_collection(its);\n\t}\n\traw_spin_unlock(&its_lock);\n}\n\nstatic struct syscore_ops its_syscore_ops = {\n\t.suspend = its_save_disable,\n\t.resume = its_restore_enable,\n};\n\nstatic void __init __iomem *its_map_one(struct resource *res, int *err)\n{\n\tvoid __iomem *its_base;\n\tu32 val;\n\n\tits_base = ioremap(res->start, SZ_64K);\n\tif (!its_base) {\n\t\tpr_warn(\"ITS@%pa: Unable to map ITS registers\\n\", &res->start);\n\t\t*err = -ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tval = readl_relaxed(its_base + GITS_PIDR2) & GIC_PIDR2_ARCH_MASK;\n\tif (val != 0x30 && val != 0x40) {\n\t\tpr_warn(\"ITS@%pa: No ITS detected, giving up\\n\", &res->start);\n\t\t*err = -ENODEV;\n\t\tgoto out_unmap;\n\t}\n\n\t*err = its_force_quiescent(its_base);\n\tif (*err) {\n\t\tpr_warn(\"ITS@%pa: Failed to quiesce, giving up\\n\", &res->start);\n\t\tgoto out_unmap;\n\t}\n\n\treturn its_base;\n\nout_unmap:\n\tiounmap(its_base);\n\treturn NULL;\n}\n\nstatic int its_init_domain(struct its_node *its)\n{\n\tstruct irq_domain *inner_domain;\n\tstruct msi_domain_info *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->ops = &its_msi_domain_ops;\n\tinfo->data = its;\n\n\tinner_domain = irq_domain_create_hierarchy(its_parent,\n\t\t\t\t\t\t   its->msi_domain_flags, 0,\n\t\t\t\t\t\t   its->fwnode_handle, &its_domain_ops,\n\t\t\t\t\t\t   info);\n\tif (!inner_domain) {\n\t\tkfree(info);\n\t\treturn -ENOMEM;\n\t}\n\n\tirq_domain_update_bus_token(inner_domain, DOMAIN_BUS_NEXUS);\n\n\treturn 0;\n}\n\nstatic int its_init_vpe_domain(void)\n{\n\tstruct its_node *its;\n\tu32 devid;\n\tint entries;\n\n\tif (gic_rdists->has_direct_lpi) {\n\t\tpr_info(\"ITS: Using DirectLPI for VPE invalidation\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tits = list_first_entry(&its_nodes, struct its_node, entry);\n\n\tentries = roundup_pow_of_two(nr_cpu_ids);\n\tvpe_proxy.vpes = kcalloc(entries, sizeof(*vpe_proxy.vpes),\n\t\t\t\t GFP_KERNEL);\n\tif (!vpe_proxy.vpes)\n\t\treturn -ENOMEM;\n\n\t \n\tdevid = GENMASK(device_ids(its) - 1, 0);\n\tvpe_proxy.dev = its_create_device(its, devid, entries, false);\n\tif (!vpe_proxy.dev) {\n\t\tkfree(vpe_proxy.vpes);\n\t\tpr_err(\"ITS: Can't allocate GICv4 proxy device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tBUG_ON(entries > vpe_proxy.dev->nr_ites);\n\n\traw_spin_lock_init(&vpe_proxy.lock);\n\tvpe_proxy.next_victim = 0;\n\tpr_info(\"ITS: Allocated DevID %x as GICv4 proxy device (%d slots)\\n\",\n\t\tdevid, vpe_proxy.dev->nr_ites);\n\n\treturn 0;\n}\n\nstatic int __init its_compute_its_list_map(struct its_node *its)\n{\n\tint its_number;\n\tu32 ctlr;\n\n\t \n\tits_number = find_first_zero_bit(&its_list_map, GICv4_ITS_LIST_MAX);\n\tif (its_number >= GICv4_ITS_LIST_MAX) {\n\t\tpr_err(\"ITS@%pa: No ITSList entry available!\\n\",\n\t\t       &its->phys_base);\n\t\treturn -EINVAL;\n\t}\n\n\tctlr = readl_relaxed(its->base + GITS_CTLR);\n\tctlr &= ~GITS_CTLR_ITS_NUMBER;\n\tctlr |= its_number << GITS_CTLR_ITS_NUMBER_SHIFT;\n\twritel_relaxed(ctlr, its->base + GITS_CTLR);\n\tctlr = readl_relaxed(its->base + GITS_CTLR);\n\tif ((ctlr & GITS_CTLR_ITS_NUMBER) != (its_number << GITS_CTLR_ITS_NUMBER_SHIFT)) {\n\t\tits_number = ctlr & GITS_CTLR_ITS_NUMBER;\n\t\tits_number >>= GITS_CTLR_ITS_NUMBER_SHIFT;\n\t}\n\n\tif (test_and_set_bit(its_number, &its_list_map)) {\n\t\tpr_err(\"ITS@%pa: Duplicate ITSList entry %d\\n\",\n\t\t       &its->phys_base, its_number);\n\t\treturn -EINVAL;\n\t}\n\n\treturn its_number;\n}\n\nstatic int __init its_probe_one(struct its_node *its)\n{\n\tu64 baser, tmp;\n\tstruct page *page;\n\tu32 ctlr;\n\tint err;\n\n\tif (is_v4(its)) {\n\t\tif (!(its->typer & GITS_TYPER_VMOVP)) {\n\t\t\terr = its_compute_its_list_map(its);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\tits->list_nr = err;\n\n\t\t\tpr_info(\"ITS@%pa: Using ITS number %d\\n\",\n\t\t\t\t&its->phys_base, err);\n\t\t} else {\n\t\t\tpr_info(\"ITS@%pa: Single VMOVP capable\\n\", &its->phys_base);\n\t\t}\n\n\t\tif (is_v4_1(its)) {\n\t\t\tu32 svpet = FIELD_GET(GITS_TYPER_SVPET, its->typer);\n\n\t\t\tits->sgir_base = ioremap(its->phys_base + SZ_128K, SZ_64K);\n\t\t\tif (!its->sgir_base) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tits->mpidr = readl_relaxed(its->base + GITS_MPIDR);\n\n\t\t\tpr_info(\"ITS@%pa: Using GICv4.1 mode %08x %08x\\n\",\n\t\t\t\t&its->phys_base, its->mpidr, svpet);\n\t\t}\n\t}\n\n\tpage = alloc_pages_node(its->numa_node, GFP_KERNEL | __GFP_ZERO,\n\t\t\t\tget_order(ITS_CMD_QUEUE_SZ));\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unmap_sgir;\n\t}\n\tits->cmd_base = (void *)page_address(page);\n\tits->cmd_write = its->cmd_base;\n\n\terr = its_alloc_tables(its);\n\tif (err)\n\t\tgoto out_free_cmd;\n\n\terr = its_alloc_collections(its);\n\tif (err)\n\t\tgoto out_free_tables;\n\n\tbaser = (virt_to_phys(its->cmd_base)\t|\n\t\t GITS_CBASER_RaWaWb\t\t|\n\t\t GITS_CBASER_InnerShareable\t|\n\t\t (ITS_CMD_QUEUE_SZ / SZ_4K - 1)\t|\n\t\t GITS_CBASER_VALID);\n\n\tgits_write_cbaser(baser, its->base + GITS_CBASER);\n\ttmp = gits_read_cbaser(its->base + GITS_CBASER);\n\n\tif (its->flags & ITS_FLAGS_FORCE_NON_SHAREABLE)\n\t\ttmp &= ~GITS_CBASER_SHAREABILITY_MASK;\n\n\tif ((tmp ^ baser) & GITS_CBASER_SHAREABILITY_MASK) {\n\t\tif (!(tmp & GITS_CBASER_SHAREABILITY_MASK)) {\n\t\t\t \n\t\t\tbaser &= ~(GITS_CBASER_SHAREABILITY_MASK |\n\t\t\t\t   GITS_CBASER_CACHEABILITY_MASK);\n\t\t\tbaser |= GITS_CBASER_nC;\n\t\t\tgits_write_cbaser(baser, its->base + GITS_CBASER);\n\t\t}\n\t\tpr_info(\"ITS: using cache flushing for cmd queue\\n\");\n\t\tits->flags |= ITS_FLAGS_CMDQ_NEEDS_FLUSHING;\n\t}\n\n\tgits_write_cwriter(0, its->base + GITS_CWRITER);\n\tctlr = readl_relaxed(its->base + GITS_CTLR);\n\tctlr |= GITS_CTLR_ENABLE;\n\tif (is_v4(its))\n\t\tctlr |= GITS_CTLR_ImDe;\n\twritel_relaxed(ctlr, its->base + GITS_CTLR);\n\n\terr = its_init_domain(its);\n\tif (err)\n\t\tgoto out_free_tables;\n\n\traw_spin_lock(&its_lock);\n\tlist_add(&its->entry, &its_nodes);\n\traw_spin_unlock(&its_lock);\n\n\treturn 0;\n\nout_free_tables:\n\tits_free_tables(its);\nout_free_cmd:\n\tfree_pages((unsigned long)its->cmd_base, get_order(ITS_CMD_QUEUE_SZ));\nout_unmap_sgir:\n\tif (its->sgir_base)\n\t\tiounmap(its->sgir_base);\nout:\n\tpr_err(\"ITS@%pa: failed probing (%d)\\n\", &its->phys_base, err);\n\treturn err;\n}\n\nstatic bool gic_rdists_supports_plpis(void)\n{\n\treturn !!(gic_read_typer(gic_data_rdist_rd_base() + GICR_TYPER) & GICR_TYPER_PLPIS);\n}\n\nstatic int redist_disable_lpis(void)\n{\n\tvoid __iomem *rbase = gic_data_rdist_rd_base();\n\tu64 timeout = USEC_PER_SEC;\n\tu64 val;\n\n\tif (!gic_rdists_supports_plpis()) {\n\t\tpr_info(\"CPU%d: LPIs not supported\\n\", smp_processor_id());\n\t\treturn -ENXIO;\n\t}\n\n\tval = readl_relaxed(rbase + GICR_CTLR);\n\tif (!(val & GICR_CTLR_ENABLE_LPIS))\n\t\treturn 0;\n\n\t \n\tif ((gic_data_rdist()->flags & RD_LOCAL_LPI_ENABLED) ||\n\t    (gic_rdists->flags & RDIST_FLAGS_RD_TABLES_PREALLOCATED))\n\t\treturn 0;\n\n\t \n\tpr_warn(\"GICv3: CPU%d: Booted with LPIs enabled, memory probably corrupted\\n\",\n\t\tsmp_processor_id());\n\tadd_taint(TAINT_CRAP, LOCKDEP_STILL_OK);\n\n\t \n\tval &= ~GICR_CTLR_ENABLE_LPIS;\n\twritel_relaxed(val, rbase + GICR_CTLR);\n\n\t \n\tdsb(sy);\n\n\t \n\twhile (readl_relaxed(rbase + GICR_CTLR) & GICR_CTLR_RWP) {\n\t\tif (!timeout) {\n\t\t\tpr_err(\"CPU%d: Timeout while disabling LPIs\\n\",\n\t\t\t       smp_processor_id());\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(1);\n\t\ttimeout--;\n\t}\n\n\t \n\tif (readl_relaxed(rbase + GICR_CTLR) & GICR_CTLR_ENABLE_LPIS) {\n\t\tpr_err(\"CPU%d: Failed to disable LPIs\\n\", smp_processor_id());\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nint its_cpu_init(void)\n{\n\tif (!list_empty(&its_nodes)) {\n\t\tint ret;\n\n\t\tret = redist_disable_lpis();\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tits_cpu_init_lpis();\n\t\tits_cpu_init_collections();\n\t}\n\n\treturn 0;\n}\n\nstatic void rdist_memreserve_cpuhp_cleanup_workfn(struct work_struct *work)\n{\n\tcpuhp_remove_state_nocalls(gic_rdists->cpuhp_memreserve_state);\n\tgic_rdists->cpuhp_memreserve_state = CPUHP_INVALID;\n}\n\nstatic DECLARE_WORK(rdist_memreserve_cpuhp_cleanup_work,\n\t\t    rdist_memreserve_cpuhp_cleanup_workfn);\n\nstatic int its_cpu_memreserve_lpi(unsigned int cpu)\n{\n\tstruct page *pend_page;\n\tint ret = 0;\n\n\t \n\tif (gic_data_rdist()->flags & RD_LOCAL_MEMRESERVE_DONE)\n\t\treturn 0;\n\n\tpend_page = gic_data_rdist()->pend_page;\n\tif (WARN_ON(!pend_page)) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t \n\tif (gic_data_rdist()->flags & RD_LOCAL_PENDTABLE_PREALLOCATED) {\n\t\tits_free_pending_table(pend_page);\n\t\tgic_data_rdist()->pend_page = NULL;\n\t} else {\n\t\tphys_addr_t paddr = page_to_phys(pend_page);\n\t\tWARN_ON(gic_reserve_range(paddr, LPI_PENDBASE_SZ));\n\t}\n\nout:\n\t \n\tif (!IS_ENABLED(CONFIG_SMP) ||\n\t    cpumask_equal(&cpus_booted_once_mask, cpu_possible_mask))\n\t\tschedule_work(&rdist_memreserve_cpuhp_cleanup_work);\n\n\tgic_data_rdist()->flags |= RD_LOCAL_MEMRESERVE_DONE;\n\treturn ret;\n}\n\n \nstatic int __init its_reset_one(struct resource *res)\n{\n\tvoid __iomem *its_base;\n\tint err, i;\n\n\tits_base = its_map_one(res, &err);\n\tif (!its_base)\n\t\treturn err;\n\n\tfor (i = 0; i < GITS_BASER_NR_REGS; i++)\n\t\tgits_write_baser(0, its_base + GITS_BASER + (i << 3));\n\n\tiounmap(its_base);\n\treturn 0;\n}\n\nstatic const struct of_device_id its_device_id[] = {\n\t{\t.compatible\t= \"arm,gic-v3-its\",\t},\n\t{},\n};\n\nstatic struct its_node __init *its_node_init(struct resource *res,\n\t\t\t\t\t     struct fwnode_handle *handle, int numa_node)\n{\n\tvoid __iomem *its_base;\n\tstruct its_node *its;\n\tint err;\n\n\tits_base = its_map_one(res, &err);\n\tif (!its_base)\n\t\treturn NULL;\n\n\tpr_info(\"ITS %pR\\n\", res);\n\n\tits = kzalloc(sizeof(*its), GFP_KERNEL);\n\tif (!its)\n\t\tgoto out_unmap;\n\n\traw_spin_lock_init(&its->lock);\n\tmutex_init(&its->dev_alloc_lock);\n\tINIT_LIST_HEAD(&its->entry);\n\tINIT_LIST_HEAD(&its->its_device_list);\n\n\tits->typer = gic_read_typer(its_base + GITS_TYPER);\n\tits->base = its_base;\n\tits->phys_base = res->start;\n\tits->get_msi_base = its_irq_get_msi_base;\n\tits->msi_domain_flags = IRQ_DOMAIN_FLAG_ISOLATED_MSI;\n\n\tits->numa_node = numa_node;\n\tits->fwnode_handle = handle;\n\n\treturn its;\n\nout_unmap:\n\tiounmap(its_base);\n\treturn NULL;\n}\n\nstatic void its_node_destroy(struct its_node *its)\n{\n\tiounmap(its->base);\n\tkfree(its);\n}\n\nstatic int __init its_of_probe(struct device_node *node)\n{\n\tstruct device_node *np;\n\tstruct resource res;\n\tint err;\n\n\t \n\tfor (np = of_find_matching_node(node, its_device_id); np;\n\t     np = of_find_matching_node(np, its_device_id)) {\n\t\tif (!of_device_is_available(np) ||\n\t\t    !of_property_read_bool(np, \"msi-controller\") ||\n\t\t    of_address_to_resource(np, 0, &res))\n\t\t\tcontinue;\n\n\t\terr = its_reset_one(&res);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (np = of_find_matching_node(node, its_device_id); np;\n\t     np = of_find_matching_node(np, its_device_id)) {\n\t\tstruct its_node *its;\n\n\t\tif (!of_device_is_available(np))\n\t\t\tcontinue;\n\t\tif (!of_property_read_bool(np, \"msi-controller\")) {\n\t\t\tpr_warn(\"%pOF: no msi-controller property, ITS ignored\\n\",\n\t\t\t\tnp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (of_address_to_resource(np, 0, &res)) {\n\t\t\tpr_warn(\"%pOF: no regs?\\n\", np);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tits = its_node_init(&res, &np->fwnode, of_node_to_nid(np));\n\t\tif (!its)\n\t\t\treturn -ENOMEM;\n\n\t\tits_enable_quirks(its);\n\t\terr = its_probe_one(its);\n\t\tif (err)  {\n\t\t\tits_node_destroy(its);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\n\n#define ACPI_GICV3_ITS_MEM_SIZE (SZ_128K)\n\n#ifdef CONFIG_ACPI_NUMA\nstruct its_srat_map {\n\t \n\tu32\tnuma_node;\n\t \n\tu32\tits_id;\n};\n\nstatic struct its_srat_map *its_srat_maps __initdata;\nstatic int its_in_srat __initdata;\n\nstatic int __init acpi_get_its_numa_node(u32 its_id)\n{\n\tint i;\n\n\tfor (i = 0; i < its_in_srat; i++) {\n\t\tif (its_id == its_srat_maps[i].its_id)\n\t\t\treturn its_srat_maps[i].numa_node;\n\t}\n\treturn NUMA_NO_NODE;\n}\n\nstatic int __init gic_acpi_match_srat_its(union acpi_subtable_headers *header,\n\t\t\t\t\t  const unsigned long end)\n{\n\treturn 0;\n}\n\nstatic int __init gic_acpi_parse_srat_its(union acpi_subtable_headers *header,\n\t\t\t const unsigned long end)\n{\n\tint node;\n\tstruct acpi_srat_gic_its_affinity *its_affinity;\n\n\tits_affinity = (struct acpi_srat_gic_its_affinity *)header;\n\tif (!its_affinity)\n\t\treturn -EINVAL;\n\n\tif (its_affinity->header.length < sizeof(*its_affinity)) {\n\t\tpr_err(\"SRAT: Invalid header length %d in ITS affinity\\n\",\n\t\t\tits_affinity->header.length);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnode = pxm_to_node(its_affinity->proximity_domain);\n\n\tif (node == NUMA_NO_NODE || node >= MAX_NUMNODES) {\n\t\tpr_err(\"SRAT: Invalid NUMA node %d in ITS affinity\\n\", node);\n\t\treturn 0;\n\t}\n\n\tits_srat_maps[its_in_srat].numa_node = node;\n\tits_srat_maps[its_in_srat].its_id = its_affinity->its_id;\n\tits_in_srat++;\n\tpr_info(\"SRAT: PXM %d -> ITS %d -> Node %d\\n\",\n\t\tits_affinity->proximity_domain, its_affinity->its_id, node);\n\n\treturn 0;\n}\n\nstatic void __init acpi_table_parse_srat_its(void)\n{\n\tint count;\n\n\tcount = acpi_table_parse_entries(ACPI_SIG_SRAT,\n\t\t\tsizeof(struct acpi_table_srat),\n\t\t\tACPI_SRAT_TYPE_GIC_ITS_AFFINITY,\n\t\t\tgic_acpi_match_srat_its, 0);\n\tif (count <= 0)\n\t\treturn;\n\n\tits_srat_maps = kmalloc_array(count, sizeof(struct its_srat_map),\n\t\t\t\t      GFP_KERNEL);\n\tif (!its_srat_maps)\n\t\treturn;\n\n\tacpi_table_parse_entries(ACPI_SIG_SRAT,\n\t\t\tsizeof(struct acpi_table_srat),\n\t\t\tACPI_SRAT_TYPE_GIC_ITS_AFFINITY,\n\t\t\tgic_acpi_parse_srat_its, 0);\n}\n\n \nstatic void __init acpi_its_srat_maps_free(void)\n{\n\tkfree(its_srat_maps);\n}\n#else\nstatic void __init acpi_table_parse_srat_its(void)\t{ }\nstatic int __init acpi_get_its_numa_node(u32 its_id) { return NUMA_NO_NODE; }\nstatic void __init acpi_its_srat_maps_free(void) { }\n#endif\n\nstatic int __init gic_acpi_parse_madt_its(union acpi_subtable_headers *header,\n\t\t\t\t\t  const unsigned long end)\n{\n\tstruct acpi_madt_generic_translator *its_entry;\n\tstruct fwnode_handle *dom_handle;\n\tstruct its_node *its;\n\tstruct resource res;\n\tint err;\n\n\tits_entry = (struct acpi_madt_generic_translator *)header;\n\tmemset(&res, 0, sizeof(res));\n\tres.start = its_entry->base_address;\n\tres.end = its_entry->base_address + ACPI_GICV3_ITS_MEM_SIZE - 1;\n\tres.flags = IORESOURCE_MEM;\n\n\tdom_handle = irq_domain_alloc_fwnode(&res.start);\n\tif (!dom_handle) {\n\t\tpr_err(\"ITS@%pa: Unable to allocate GICv3 ITS domain token\\n\",\n\t\t       &res.start);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = iort_register_domain_token(its_entry->translation_id, res.start,\n\t\t\t\t\t dom_handle);\n\tif (err) {\n\t\tpr_err(\"ITS@%pa: Unable to register GICv3 ITS domain token (ITS ID %d) to IORT\\n\",\n\t\t       &res.start, its_entry->translation_id);\n\t\tgoto dom_err;\n\t}\n\n\tits = its_node_init(&res, dom_handle,\n\t\t\t    acpi_get_its_numa_node(its_entry->translation_id));\n\tif (!its) {\n\t\terr = -ENOMEM;\n\t\tgoto node_err;\n\t}\n\n\terr = its_probe_one(its);\n\tif (!err)\n\t\treturn 0;\n\nnode_err:\n\tiort_deregister_domain_token(its_entry->translation_id);\ndom_err:\n\tirq_domain_free_fwnode(dom_handle);\n\treturn err;\n}\n\nstatic int __init its_acpi_reset(union acpi_subtable_headers *header,\n\t\t\t\t const unsigned long end)\n{\n\tstruct acpi_madt_generic_translator *its_entry;\n\tstruct resource res;\n\n\tits_entry = (struct acpi_madt_generic_translator *)header;\n\tres = (struct resource) {\n\t\t.start\t= its_entry->base_address,\n\t\t.end\t= its_entry->base_address + ACPI_GICV3_ITS_MEM_SIZE - 1,\n\t\t.flags\t= IORESOURCE_MEM,\n\t};\n\n\treturn its_reset_one(&res);\n}\n\nstatic void __init its_acpi_probe(void)\n{\n\tacpi_table_parse_srat_its();\n\t \n\tif (acpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_TRANSLATOR,\n\t\t\t\t  its_acpi_reset, 0) > 0)\n\t\tacpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_TRANSLATOR,\n\t\t\t\t      gic_acpi_parse_madt_its, 0);\n\tacpi_its_srat_maps_free();\n}\n#else\nstatic void __init its_acpi_probe(void) { }\n#endif\n\nint __init its_lpi_memreserve_init(void)\n{\n\tint state;\n\n\tif (!efi_enabled(EFI_CONFIG_TABLES))\n\t\treturn 0;\n\n\tif (list_empty(&its_nodes))\n\t\treturn 0;\n\n\tgic_rdists->cpuhp_memreserve_state = CPUHP_INVALID;\n\tstate = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t  \"irqchip/arm/gicv3/memreserve:online\",\n\t\t\t\t  its_cpu_memreserve_lpi,\n\t\t\t\t  NULL);\n\tif (state < 0)\n\t\treturn state;\n\n\tgic_rdists->cpuhp_memreserve_state = state;\n\n\treturn 0;\n}\n\nint __init its_init(struct fwnode_handle *handle, struct rdists *rdists,\n\t\t    struct irq_domain *parent_domain)\n{\n\tstruct device_node *of_node;\n\tstruct its_node *its;\n\tbool has_v4 = false;\n\tbool has_v4_1 = false;\n\tint err;\n\n\tgic_rdists = rdists;\n\n\tits_parent = parent_domain;\n\tof_node = to_of_node(handle);\n\tif (of_node)\n\t\tits_of_probe(of_node);\n\telse\n\t\tits_acpi_probe();\n\n\tif (list_empty(&its_nodes)) {\n\t\tpr_warn(\"ITS: No ITS available, not enabling LPIs\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\terr = allocate_lpi_tables();\n\tif (err)\n\t\treturn err;\n\n\tlist_for_each_entry(its, &its_nodes, entry) {\n\t\thas_v4 |= is_v4(its);\n\t\thas_v4_1 |= is_v4_1(its);\n\t}\n\n\t \n\tif (WARN_ON(!has_v4_1 && rdists->has_rvpeid))\n\t\trdists->has_rvpeid = false;\n\n\tif (has_v4 & rdists->has_vlpis) {\n\t\tconst struct irq_domain_ops *sgi_ops;\n\n\t\tif (has_v4_1)\n\t\t\tsgi_ops = &its_sgi_domain_ops;\n\t\telse\n\t\t\tsgi_ops = NULL;\n\n\t\tif (its_init_vpe_domain() ||\n\t\t    its_init_v4(parent_domain, &its_vpe_domain_ops, sgi_ops)) {\n\t\t\trdists->has_vlpis = false;\n\t\t\tpr_err(\"ITS: Disabling GICv4 support\\n\");\n\t\t}\n\t}\n\n\tregister_syscore_ops(&its_syscore_ops);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}