{
  "module_name": "irq-loongson-liointc.c",
  "hash_id": "62ed61428d71307f8c9e46616c19d5ce3228eaf81515f91ce7bbc1600066180b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-loongson-liointc.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/irqchip.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/io.h>\n#include <linux/smp.h>\n#include <linux/irqchip/chained_irq.h>\n\n#ifdef CONFIG_MIPS\n#include <loongson.h>\n#else\n#include <asm/loongson.h>\n#endif\n\n#define LIOINTC_CHIP_IRQ\t32\n#define LIOINTC_NUM_PARENT\t4\n#define LIOINTC_NUM_CORES\t4\n\n#define LIOINTC_INTC_CHIP_START\t0x20\n\n#define LIOINTC_REG_INTC_STATUS\t(LIOINTC_INTC_CHIP_START + 0x20)\n#define LIOINTC_REG_INTC_EN_STATUS\t(LIOINTC_INTC_CHIP_START + 0x04)\n#define LIOINTC_REG_INTC_ENABLE\t(LIOINTC_INTC_CHIP_START + 0x08)\n#define LIOINTC_REG_INTC_DISABLE\t(LIOINTC_INTC_CHIP_START + 0x0c)\n \n#define LIOINTC_REG_INTC_POL\t(LIOINTC_INTC_CHIP_START + 0x10)\n#define LIOINTC_REG_INTC_EDGE\t(LIOINTC_INTC_CHIP_START + 0x14)\n\n#define LIOINTC_SHIFT_INTx\t4\n\n#define LIOINTC_ERRATA_IRQ\t10\n\n#if defined(CONFIG_MIPS)\n#define liointc_core_id get_ebase_cpunum()\n#else\n#define liointc_core_id get_csr_cpuid()\n#endif\n\nstruct liointc_handler_data {\n\tstruct liointc_priv\t*priv;\n\tu32\t\t\tparent_int_map;\n};\n\nstruct liointc_priv {\n\tstruct irq_chip_generic\t\t*gc;\n\tstruct liointc_handler_data\thandler[LIOINTC_NUM_PARENT];\n\tvoid __iomem\t\t\t*core_isr[LIOINTC_NUM_CORES];\n\tu8\t\t\t\tmap_cache[LIOINTC_CHIP_IRQ];\n\tu32\t\t\t\tint_pol;\n\tu32\t\t\t\tint_edge;\n\tbool\t\t\t\thas_lpc_irq_errata;\n};\n\nstruct fwnode_handle *liointc_handle;\n\nstatic void liointc_chained_handle_irq(struct irq_desc *desc)\n{\n\tstruct liointc_handler_data *handler = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irq_chip_generic *gc = handler->priv->gc;\n\tint core = liointc_core_id % LIOINTC_NUM_CORES;\n\tu32 pending;\n\n\tchained_irq_enter(chip, desc);\n\n\tpending = readl(handler->priv->core_isr[core]);\n\n\tif (!pending) {\n\t\t \n\t\tif (handler->priv->has_lpc_irq_errata &&\n\t\t\t(handler->parent_int_map & gc->mask_cache &\n\t\t\tBIT(LIOINTC_ERRATA_IRQ)))\n\t\t\tpending = BIT(LIOINTC_ERRATA_IRQ);\n\t\telse\n\t\t\tspurious_interrupt();\n\t}\n\n\twhile (pending) {\n\t\tint bit = __ffs(pending);\n\n\t\tgeneric_handle_domain_irq(gc->domain, bit);\n\t\tpending &= ~BIT(bit);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void liointc_set_bit(struct irq_chip_generic *gc,\n\t\t\t\tunsigned int offset,\n\t\t\t\tu32 mask, bool set)\n{\n\tif (set)\n\t\twritel(readl(gc->reg_base + offset) | mask,\n\t\t\t\tgc->reg_base + offset);\n\telse\n\t\twritel(readl(gc->reg_base + offset) & ~mask,\n\t\t\t\tgc->reg_base + offset);\n}\n\nstatic int liointc_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\n\tu32 mask = data->mask;\n\tunsigned long flags;\n\n\tirq_gc_lock_irqsave(gc, flags);\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tliointc_set_bit(gc, LIOINTC_REG_INTC_EDGE, mask, false);\n\t\tliointc_set_bit(gc, LIOINTC_REG_INTC_POL, mask, false);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tliointc_set_bit(gc, LIOINTC_REG_INTC_EDGE, mask, false);\n\t\tliointc_set_bit(gc, LIOINTC_REG_INTC_POL, mask, true);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tliointc_set_bit(gc, LIOINTC_REG_INTC_EDGE, mask, true);\n\t\tliointc_set_bit(gc, LIOINTC_REG_INTC_POL, mask, false);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tliointc_set_bit(gc, LIOINTC_REG_INTC_EDGE, mask, true);\n\t\tliointc_set_bit(gc, LIOINTC_REG_INTC_POL, mask, true);\n\t\tbreak;\n\tdefault:\n\t\tirq_gc_unlock_irqrestore(gc, flags);\n\t\treturn -EINVAL;\n\t}\n\tirq_gc_unlock_irqrestore(gc, flags);\n\n\tirqd_set_trigger_type(data, type);\n\treturn 0;\n}\n\nstatic void liointc_suspend(struct irq_chip_generic *gc)\n{\n\tstruct liointc_priv *priv = gc->private;\n\n\tpriv->int_pol = readl(gc->reg_base + LIOINTC_REG_INTC_POL);\n\tpriv->int_edge = readl(gc->reg_base + LIOINTC_REG_INTC_EDGE);\n}\n\nstatic void liointc_resume(struct irq_chip_generic *gc)\n{\n\tstruct liointc_priv *priv = gc->private;\n\tunsigned long flags;\n\tint i;\n\n\tirq_gc_lock_irqsave(gc, flags);\n\t \n\twritel(0xffffffff, gc->reg_base + LIOINTC_REG_INTC_DISABLE);\n\t \n\tfor (i = 0; i < LIOINTC_CHIP_IRQ; i++)\n\t\twriteb(priv->map_cache[i], gc->reg_base + i);\n\twritel(priv->int_pol, gc->reg_base + LIOINTC_REG_INTC_POL);\n\twritel(priv->int_edge, gc->reg_base + LIOINTC_REG_INTC_EDGE);\n\t \n\twritel(gc->mask_cache, gc->reg_base + LIOINTC_REG_INTC_ENABLE);\n\tirq_gc_unlock_irqrestore(gc, flags);\n}\n\nstatic int parent_irq[LIOINTC_NUM_PARENT];\nstatic u32 parent_int_map[LIOINTC_NUM_PARENT];\nstatic const char *const parent_names[] = {\"int0\", \"int1\", \"int2\", \"int3\"};\nstatic const char *const core_reg_names[] = {\"isr0\", \"isr1\", \"isr2\", \"isr3\"};\n\nstatic int liointc_domain_xlate(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\t     const u32 *intspec, unsigned int intsize,\n\t\t\t     unsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0] - GSI_MIN_CPU_IRQ;\n\n\tif (intsize > 1)\n\t\t*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\telse\n\t\t*out_type = IRQ_TYPE_NONE;\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops acpi_irq_gc_ops = {\n\t.map\t= irq_map_generic_chip,\n\t.unmap  = irq_unmap_generic_chip,\n\t.xlate\t= liointc_domain_xlate,\n};\n\nstatic int liointc_init(phys_addr_t addr, unsigned long size, int revision,\n\t\tstruct fwnode_handle *domain_handle, struct device_node *node)\n{\n\tint i, err;\n\tvoid __iomem *base;\n\tstruct irq_chip_type *ct;\n\tstruct irq_chip_generic *gc;\n\tstruct irq_domain *domain;\n\tstruct liointc_priv *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tbase = ioremap(addr, size);\n\tif (!base)\n\t\tgoto out_free_priv;\n\n\tfor (i = 0; i < LIOINTC_NUM_CORES; i++)\n\t\tpriv->core_isr[i] = base + LIOINTC_REG_INTC_STATUS;\n\n\tfor (i = 0; i < LIOINTC_NUM_PARENT; i++)\n\t\tpriv->handler[i].parent_int_map = parent_int_map[i];\n\n\tif (revision > 1) {\n\t\tfor (i = 0; i < LIOINTC_NUM_CORES; i++) {\n\t\t\tint index = of_property_match_string(node,\n\t\t\t\t\t\"reg-names\", core_reg_names[i]);\n\n\t\t\tif (index < 0)\n\t\t\t\tcontinue;\n\n\t\t\tpriv->core_isr[i] = of_iomap(node, index);\n\t\t}\n\n\t\tif (!priv->core_isr[0])\n\t\t\tgoto out_iounmap;\n\t}\n\n\t \n\tif (!acpi_disabled)\n\t\tdomain = irq_domain_create_linear(domain_handle, LIOINTC_CHIP_IRQ,\n\t\t\t\t\t&acpi_irq_gc_ops, priv);\n\telse\n\t\tdomain = irq_domain_create_linear(domain_handle, LIOINTC_CHIP_IRQ,\n\t\t\t\t\t&irq_generic_chip_ops, priv);\n\tif (!domain) {\n\t\tpr_err(\"loongson-liointc: cannot add IRQ domain\\n\");\n\t\tgoto out_iounmap;\n\t}\n\n\terr = irq_alloc_domain_generic_chips(domain, LIOINTC_CHIP_IRQ, 1,\n\t\t\t\t\t(node ? node->full_name : \"LIOINTC\"),\n\t\t\t\t\thandle_level_irq, 0, IRQ_NOPROBE, 0);\n\tif (err) {\n\t\tpr_err(\"loongson-liointc: unable to register IRQ domain\\n\");\n\t\tgoto out_free_domain;\n\t}\n\n\n\t \n\twritel(0xffffffff, base + LIOINTC_REG_INTC_DISABLE);\n\t \n\twritel(0x0, base + LIOINTC_REG_INTC_EDGE);\n\n\t \n\tfor (i = 0; i < LIOINTC_NUM_PARENT; i++) {\n\t\tu32 pending = priv->handler[i].parent_int_map;\n\n\t\twhile (pending) {\n\t\t\tint bit = __ffs(pending);\n\n\t\t\tpriv->map_cache[bit] = BIT(i) << LIOINTC_SHIFT_INTx;\n\t\t\tpending &= ~BIT(bit);\n\t\t}\n\t}\n\n\tfor (i = 0; i < LIOINTC_CHIP_IRQ; i++) {\n\t\t \n\t\tpriv->map_cache[i] |= BIT(loongson_sysconf.boot_cpu_id);\n\t\twriteb(priv->map_cache[i], base + i);\n\t}\n\n\tgc = irq_get_domain_generic_chip(domain, 0);\n\tgc->private = priv;\n\tgc->reg_base = base;\n\tgc->domain = domain;\n\tgc->suspend = liointc_suspend;\n\tgc->resume = liointc_resume;\n\n\tct = gc->chip_types;\n\tct->regs.enable = LIOINTC_REG_INTC_ENABLE;\n\tct->regs.disable = LIOINTC_REG_INTC_DISABLE;\n\tct->chip.irq_unmask = irq_gc_unmask_enable_reg;\n\tct->chip.irq_mask = irq_gc_mask_disable_reg;\n\tct->chip.irq_mask_ack = irq_gc_mask_disable_reg;\n\tct->chip.irq_set_type = liointc_set_type;\n\tct->chip.flags = IRQCHIP_SKIP_SET_WAKE;\n\n\tgc->mask_cache = 0;\n\tpriv->gc = gc;\n\n\tfor (i = 0; i < LIOINTC_NUM_PARENT; i++) {\n\t\tif (parent_irq[i] <= 0)\n\t\t\tcontinue;\n\n\t\tpriv->handler[i].priv = priv;\n\t\tirq_set_chained_handler_and_data(parent_irq[i],\n\t\t\t\tliointc_chained_handle_irq, &priv->handler[i]);\n\t}\n\n\tliointc_handle = domain_handle;\n\treturn 0;\n\nout_free_domain:\n\tirq_domain_remove(domain);\nout_iounmap:\n\tiounmap(base);\nout_free_priv:\n\tkfree(priv);\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_OF\n\nstatic int __init liointc_of_init(struct device_node *node,\n\t\t\t\t  struct device_node *parent)\n{\n\tbool have_parent = FALSE;\n\tint sz, i, index, revision, err = 0;\n\tstruct resource res;\n\n\tif (!of_device_is_compatible(node, \"loongson,liointc-2.0\")) {\n\t\tindex = 0;\n\t\trevision = 1;\n\t} else {\n\t\tindex = of_property_match_string(node, \"reg-names\", \"main\");\n\t\trevision = 2;\n\t}\n\n\tif (of_address_to_resource(node, index, &res))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < LIOINTC_NUM_PARENT; i++) {\n\t\tparent_irq[i] = of_irq_get_byname(node, parent_names[i]);\n\t\tif (parent_irq[i] > 0)\n\t\t\thave_parent = TRUE;\n\t}\n\tif (!have_parent)\n\t\treturn -ENODEV;\n\n\tsz = of_property_read_variable_u32_array(node,\n\t\t\t\t\t\t\"loongson,parent_int_map\",\n\t\t\t\t\t\t&parent_int_map[0],\n\t\t\t\t\t\tLIOINTC_NUM_PARENT,\n\t\t\t\t\t\tLIOINTC_NUM_PARENT);\n\tif (sz < 4) {\n\t\tpr_err(\"loongson-liointc: No parent_int_map\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = liointc_init(res.start, resource_size(&res),\n\t\t\trevision, of_node_to_fwnode(node), node);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(loongson_liointc_1_0, \"loongson,liointc-1.0\", liointc_of_init);\nIRQCHIP_DECLARE(loongson_liointc_1_0a, \"loongson,liointc-1.0a\", liointc_of_init);\nIRQCHIP_DECLARE(loongson_liointc_2_0, \"loongson,liointc-2.0\", liointc_of_init);\n\n#endif\n\n#ifdef CONFIG_ACPI\nstatic int __init htintc_parse_madt(union acpi_subtable_headers *header,\n\t\t\t\t\tconst unsigned long end)\n{\n\tstruct acpi_madt_ht_pic *htintc_entry = (struct acpi_madt_ht_pic *)header;\n\tstruct irq_domain *parent = irq_find_matching_fwnode(liointc_handle, DOMAIN_BUS_ANY);\n\n\treturn htvec_acpi_init(parent, htintc_entry);\n}\n\nstatic int __init acpi_cascade_irqdomain_init(void)\n{\n\tint r;\n\n\tr = acpi_table_parse_madt(ACPI_MADT_TYPE_HT_PIC, htintc_parse_madt, 0);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nint __init liointc_acpi_init(struct irq_domain *parent, struct acpi_madt_lio_pic *acpi_liointc)\n{\n\tint ret;\n\tstruct fwnode_handle *domain_handle;\n\n\tparent_int_map[0] = acpi_liointc->cascade_map[0];\n\tparent_int_map[1] = acpi_liointc->cascade_map[1];\n\n\tparent_irq[0] = irq_create_mapping(parent, acpi_liointc->cascade[0]);\n\tparent_irq[1] = irq_create_mapping(parent, acpi_liointc->cascade[1]);\n\n\tdomain_handle = irq_domain_alloc_fwnode(&acpi_liointc->address);\n\tif (!domain_handle) {\n\t\tpr_err(\"Unable to allocate domain handle\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = liointc_init(acpi_liointc->address, acpi_liointc->size,\n\t\t\t   1, domain_handle, NULL);\n\tif (ret == 0)\n\t\tret = acpi_cascade_irqdomain_init();\n\telse\n\t\tirq_domain_free_fwnode(domain_handle);\n\n\treturn ret;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}