{
  "module_name": "irq-mmp.c",
  "hash_id": "49a0c0a3c28cf41fadd30589ba5bc78acd8b8f3e357674d0a6d8bbb151cbadfc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-mmp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <asm/exception.h>\n#include <asm/hardirq.h>\n\n#define MAX_ICU_NR\t\t16\n\n#define PJ1_INT_SEL\t\t0x10c\n#define PJ4_INT_SEL\t\t0x104\n\n \n#define SEL_INT_PENDING\t\t(1 << 6)\n#define SEL_INT_NUM_MASK\t0x3f\n\n#define MMP2_ICU_INT_ROUTE_PJ4_IRQ\t(1 << 5)\n#define MMP2_ICU_INT_ROUTE_PJ4_FIQ\t(1 << 6)\n\nstruct icu_chip_data {\n\tint\t\t\tnr_irqs;\n\tunsigned int\t\tvirq_base;\n\tunsigned int\t\tcascade_irq;\n\tvoid __iomem\t\t*reg_status;\n\tvoid __iomem\t\t*reg_mask;\n\tunsigned int\t\tconf_enable;\n\tunsigned int\t\tconf_disable;\n\tunsigned int\t\tconf_mask;\n\tunsigned int\t\tconf2_mask;\n\tunsigned int\t\tclr_mfp_irq_base;\n\tunsigned int\t\tclr_mfp_hwirq;\n\tstruct irq_domain\t*domain;\n};\n\nstruct mmp_intc_conf {\n\tunsigned int\tconf_enable;\n\tunsigned int\tconf_disable;\n\tunsigned int\tconf_mask;\n\tunsigned int\tconf2_mask;\n};\n\nstatic void __iomem *mmp_icu_base;\nstatic void __iomem *mmp_icu2_base;\nstatic struct icu_chip_data icu_data[MAX_ICU_NR];\nstatic int max_icu_nr;\n\nextern void mmp2_clear_pmic_int(void);\n\nstatic void icu_mask_ack_irq(struct irq_data *d)\n{\n\tstruct irq_domain *domain = d->domain;\n\tstruct icu_chip_data *data = (struct icu_chip_data *)domain->host_data;\n\tint hwirq;\n\tu32 r;\n\n\thwirq = d->irq - data->virq_base;\n\tif (data == &icu_data[0]) {\n\t\tr = readl_relaxed(mmp_icu_base + (hwirq << 2));\n\t\tr &= ~data->conf_mask;\n\t\tr |= data->conf_disable;\n\t\twritel_relaxed(r, mmp_icu_base + (hwirq << 2));\n\t} else {\n#ifdef CONFIG_CPU_MMP2\n\t\tif ((data->virq_base == data->clr_mfp_irq_base)\n\t\t\t&& (hwirq == data->clr_mfp_hwirq))\n\t\t\tmmp2_clear_pmic_int();\n#endif\n\t\tr = readl_relaxed(data->reg_mask) | (1 << hwirq);\n\t\twritel_relaxed(r, data->reg_mask);\n\t}\n}\n\nstatic void icu_mask_irq(struct irq_data *d)\n{\n\tstruct irq_domain *domain = d->domain;\n\tstruct icu_chip_data *data = (struct icu_chip_data *)domain->host_data;\n\tint hwirq;\n\tu32 r;\n\n\thwirq = d->irq - data->virq_base;\n\tif (data == &icu_data[0]) {\n\t\tr = readl_relaxed(mmp_icu_base + (hwirq << 2));\n\t\tr &= ~data->conf_mask;\n\t\tr |= data->conf_disable;\n\t\twritel_relaxed(r, mmp_icu_base + (hwirq << 2));\n\n\t\tif (data->conf2_mask) {\n\t\t\t \n\t\t\tr = readl_relaxed(mmp_icu2_base + (hwirq << 2));\n\t\t\tr &= ~data->conf2_mask;\n\t\t\twritel_relaxed(r, mmp_icu2_base + (hwirq << 2));\n\t\t}\n\t} else {\n\t\tr = readl_relaxed(data->reg_mask) | (1 << hwirq);\n\t\twritel_relaxed(r, data->reg_mask);\n\t}\n}\n\nstatic void icu_unmask_irq(struct irq_data *d)\n{\n\tstruct irq_domain *domain = d->domain;\n\tstruct icu_chip_data *data = (struct icu_chip_data *)domain->host_data;\n\tint hwirq;\n\tu32 r;\n\n\thwirq = d->irq - data->virq_base;\n\tif (data == &icu_data[0]) {\n\t\tr = readl_relaxed(mmp_icu_base + (hwirq << 2));\n\t\tr &= ~data->conf_mask;\n\t\tr |= data->conf_enable;\n\t\twritel_relaxed(r, mmp_icu_base + (hwirq << 2));\n\t} else {\n\t\tr = readl_relaxed(data->reg_mask) & ~(1 << hwirq);\n\t\twritel_relaxed(r, data->reg_mask);\n\t}\n}\n\nstruct irq_chip icu_irq_chip = {\n\t.name\t\t= \"icu_irq\",\n\t.irq_mask\t= icu_mask_irq,\n\t.irq_mask_ack\t= icu_mask_ack_irq,\n\t.irq_unmask\t= icu_unmask_irq,\n};\n\nstatic void icu_mux_irq_demux(struct irq_desc *desc)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irq_domain *domain;\n\tstruct icu_chip_data *data;\n\tint i;\n\tunsigned long mask, status, n;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (i = 1; i < max_icu_nr; i++) {\n\t\tif (irq == icu_data[i].cascade_irq) {\n\t\t\tdomain = icu_data[i].domain;\n\t\t\tdata = (struct icu_chip_data *)domain->host_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= max_icu_nr) {\n\t\tpr_err(\"Spurious irq %d in MMP INTC\\n\", irq);\n\t\tgoto out;\n\t}\n\n\tmask = readl_relaxed(data->reg_mask);\n\twhile (1) {\n\t\tstatus = readl_relaxed(data->reg_status) & ~mask;\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tfor_each_set_bit(n, &status, BITS_PER_LONG) {\n\t\t\tgeneric_handle_irq(icu_data[i].virq_base + n);\n\t\t}\n\t}\n\nout:\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int mmp_irq_domain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t      irq_hw_number_t hw)\n{\n\tirq_set_chip_and_handler(irq, &icu_irq_chip, handle_level_irq);\n\treturn 0;\n}\n\nstatic int mmp_irq_domain_xlate(struct irq_domain *d, struct device_node *node,\n\t\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\t\tunsigned long *out_hwirq,\n\t\t\t\tunsigned int *out_type)\n{\n\t*out_hwirq = intspec[0];\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mmp_irq_domain_ops = {\n\t.map\t\t= mmp_irq_domain_map,\n\t.xlate\t\t= mmp_irq_domain_xlate,\n};\n\nstatic const struct mmp_intc_conf mmp_conf = {\n\t.conf_enable\t= 0x51,\n\t.conf_disable\t= 0x0,\n\t.conf_mask\t= 0x7f,\n};\n\nstatic const struct mmp_intc_conf mmp2_conf = {\n\t.conf_enable\t= 0x20,\n\t.conf_disable\t= 0x0,\n\t.conf_mask\t= MMP2_ICU_INT_ROUTE_PJ4_IRQ |\n\t\t\t  MMP2_ICU_INT_ROUTE_PJ4_FIQ,\n};\n\nstatic struct mmp_intc_conf mmp3_conf = {\n\t.conf_enable\t= 0x20,\n\t.conf_disable\t= 0x0,\n\t.conf_mask\t= MMP2_ICU_INT_ROUTE_PJ4_IRQ |\n\t\t\t  MMP2_ICU_INT_ROUTE_PJ4_FIQ,\n\t.conf2_mask\t= 0xf0,\n};\n\nstatic void __exception_irq_entry mmp_handle_irq(struct pt_regs *regs)\n{\n\tint hwirq;\n\n\thwirq = readl_relaxed(mmp_icu_base + PJ1_INT_SEL);\n\tif (!(hwirq & SEL_INT_PENDING))\n\t\treturn;\n\thwirq &= SEL_INT_NUM_MASK;\n\tgeneric_handle_domain_irq(icu_data[0].domain, hwirq);\n}\n\nstatic void __exception_irq_entry mmp2_handle_irq(struct pt_regs *regs)\n{\n\tint hwirq;\n\n\thwirq = readl_relaxed(mmp_icu_base + PJ4_INT_SEL);\n\tif (!(hwirq & SEL_INT_PENDING))\n\t\treturn;\n\thwirq &= SEL_INT_NUM_MASK;\n\tgeneric_handle_domain_irq(icu_data[0].domain, hwirq);\n}\n\nstatic int __init mmp_init_bases(struct device_node *node)\n{\n\tint ret, nr_irqs, irq, i = 0;\n\n\tret = of_property_read_u32(node, \"mrvl,intc-nr-irqs\", &nr_irqs);\n\tif (ret) {\n\t\tpr_err(\"Not found mrvl,intc-nr-irqs property\\n\");\n\t\treturn ret;\n\t}\n\n\tmmp_icu_base = of_iomap(node, 0);\n\tif (!mmp_icu_base) {\n\t\tpr_err(\"Failed to get interrupt controller register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ticu_data[0].virq_base = 0;\n\ticu_data[0].domain = irq_domain_add_linear(node, nr_irqs,\n\t\t\t\t\t\t   &mmp_irq_domain_ops,\n\t\t\t\t\t\t   &icu_data[0]);\n\tfor (irq = 0; irq < nr_irqs; irq++) {\n\t\tret = irq_create_mapping(icu_data[0].domain, irq);\n\t\tif (!ret) {\n\t\t\tpr_err(\"Failed to mapping hwirq\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (!irq)\n\t\t\ticu_data[0].virq_base = ret;\n\t}\n\ticu_data[0].nr_irqs = nr_irqs;\n\treturn 0;\nerr:\n\tif (icu_data[0].virq_base) {\n\t\tfor (i = 0; i < irq; i++)\n\t\t\tirq_dispose_mapping(icu_data[0].virq_base + i);\n\t}\n\tirq_domain_remove(icu_data[0].domain);\n\tiounmap(mmp_icu_base);\n\treturn -EINVAL;\n}\n\nstatic int __init mmp_of_init(struct device_node *node,\n\t\t\t      struct device_node *parent)\n{\n\tint ret;\n\n\tret = mmp_init_bases(node);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ticu_data[0].conf_enable = mmp_conf.conf_enable;\n\ticu_data[0].conf_disable = mmp_conf.conf_disable;\n\ticu_data[0].conf_mask = mmp_conf.conf_mask;\n\tset_handle_irq(mmp_handle_irq);\n\tmax_icu_nr = 1;\n\treturn 0;\n}\nIRQCHIP_DECLARE(mmp_intc, \"mrvl,mmp-intc\", mmp_of_init);\n\nstatic int __init mmp2_of_init(struct device_node *node,\n\t\t\t       struct device_node *parent)\n{\n\tint ret;\n\n\tret = mmp_init_bases(node);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ticu_data[0].conf_enable = mmp2_conf.conf_enable;\n\ticu_data[0].conf_disable = mmp2_conf.conf_disable;\n\ticu_data[0].conf_mask = mmp2_conf.conf_mask;\n\tset_handle_irq(mmp2_handle_irq);\n\tmax_icu_nr = 1;\n\treturn 0;\n}\nIRQCHIP_DECLARE(mmp2_intc, \"mrvl,mmp2-intc\", mmp2_of_init);\n\nstatic int __init mmp3_of_init(struct device_node *node,\n\t\t\t       struct device_node *parent)\n{\n\tint ret;\n\n\tmmp_icu2_base = of_iomap(node, 1);\n\tif (!mmp_icu2_base) {\n\t\tpr_err(\"Failed to get interrupt controller register #2\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = mmp_init_bases(node);\n\tif (ret < 0) {\n\t\tiounmap(mmp_icu2_base);\n\t\treturn ret;\n\t}\n\n\ticu_data[0].conf_enable = mmp3_conf.conf_enable;\n\ticu_data[0].conf_disable = mmp3_conf.conf_disable;\n\ticu_data[0].conf_mask = mmp3_conf.conf_mask;\n\ticu_data[0].conf2_mask = mmp3_conf.conf2_mask;\n\n\tif (!parent) {\n\t\t \n\t\tset_handle_irq(mmp2_handle_irq);\n\t}\n\n\tmax_icu_nr = 1;\n\treturn 0;\n}\nIRQCHIP_DECLARE(mmp3_intc, \"marvell,mmp3-intc\", mmp3_of_init);\n\nstatic int __init mmp2_mux_of_init(struct device_node *node,\n\t\t\t\t   struct device_node *parent)\n{\n\tint i, ret, irq, j = 0;\n\tu32 nr_irqs, mfp_irq;\n\tu32 reg[4];\n\n\tif (!parent)\n\t\treturn -ENODEV;\n\n\ti = max_icu_nr;\n\tret = of_property_read_u32(node, \"mrvl,intc-nr-irqs\",\n\t\t\t\t   &nr_irqs);\n\tif (ret) {\n\t\tpr_err(\"Not found mrvl,intc-nr-irqs property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = of_property_read_variable_u32_array(node, \"reg\", reg,\n\t\t\t\t\t\t  ARRAY_SIZE(reg),\n\t\t\t\t\t\t  ARRAY_SIZE(reg));\n\tif (ret < 0) {\n\t\tpr_err(\"Not found reg property\\n\");\n\t\treturn -EINVAL;\n\t}\n\ticu_data[i].reg_status = mmp_icu_base + reg[0];\n\ticu_data[i].reg_mask = mmp_icu_base + reg[2];\n\ticu_data[i].cascade_irq = irq_of_parse_and_map(node, 0);\n\tif (!icu_data[i].cascade_irq)\n\t\treturn -EINVAL;\n\n\ticu_data[i].virq_base = 0;\n\ticu_data[i].domain = irq_domain_add_linear(node, nr_irqs,\n\t\t\t\t\t\t   &mmp_irq_domain_ops,\n\t\t\t\t\t\t   &icu_data[i]);\n\tfor (irq = 0; irq < nr_irqs; irq++) {\n\t\tret = irq_create_mapping(icu_data[i].domain, irq);\n\t\tif (!ret) {\n\t\t\tpr_err(\"Failed to mapping hwirq\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (!irq)\n\t\t\ticu_data[i].virq_base = ret;\n\t}\n\ticu_data[i].nr_irqs = nr_irqs;\n\tif (!of_property_read_u32(node, \"mrvl,clr-mfp-irq\",\n\t\t\t\t  &mfp_irq)) {\n\t\ticu_data[i].clr_mfp_irq_base = icu_data[i].virq_base;\n\t\ticu_data[i].clr_mfp_hwirq = mfp_irq;\n\t}\n\tirq_set_chained_handler(icu_data[i].cascade_irq,\n\t\t\t\ticu_mux_irq_demux);\n\tmax_icu_nr++;\n\treturn 0;\nerr:\n\tif (icu_data[i].virq_base) {\n\t\tfor (j = 0; j < irq; j++)\n\t\t\tirq_dispose_mapping(icu_data[i].virq_base + j);\n\t}\n\tirq_domain_remove(icu_data[i].domain);\n\treturn -EINVAL;\n}\nIRQCHIP_DECLARE(mmp2_mux_intc, \"mrvl,mmp2-mux-intc\", mmp2_mux_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}