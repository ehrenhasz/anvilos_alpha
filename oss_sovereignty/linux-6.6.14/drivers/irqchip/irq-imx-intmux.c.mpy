{
  "module_name": "irq-imx-intmux.c",
  "hash_id": "89fbaaae7f03138bad2eedaee8d93b8c9fbd6c106f00fd993ae2d2471bf5922b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-imx-intmux.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/pm_runtime.h>\n\n#define CHANIER(n)\t(0x10 + (0x40 * n))\n#define CHANIPR(n)\t(0x20 + (0x40 * n))\n\n#define CHAN_MAX_NUM\t\t0x8\n\nstruct intmux_irqchip_data {\n\tu32\t\t\tsaved_reg;\n\tint\t\t\tchanidx;\n\tint\t\t\tirq;\n\tstruct irq_domain\t*domain;\n};\n\nstruct intmux_data {\n\traw_spinlock_t\t\t\tlock;\n\tvoid __iomem\t\t\t*regs;\n\tstruct clk\t\t\t*ipg_clk;\n\tint\t\t\t\tchannum;\n\tstruct intmux_irqchip_data\tirqchip_data[];\n};\n\nstatic void imx_intmux_irq_mask(struct irq_data *d)\n{\n\tstruct intmux_irqchip_data *irqchip_data = d->chip_data;\n\tint idx = irqchip_data->chanidx;\n\tstruct intmux_data *data = container_of(irqchip_data, struct intmux_data,\n\t\t\t\t\t\tirqchip_data[idx]);\n\tunsigned long flags;\n\tvoid __iomem *reg;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&data->lock, flags);\n\treg = data->regs + CHANIER(idx);\n\tval = readl_relaxed(reg);\n\t \n\tval &= ~BIT(d->hwirq);\n\twritel_relaxed(val, reg);\n\traw_spin_unlock_irqrestore(&data->lock, flags);\n}\n\nstatic void imx_intmux_irq_unmask(struct irq_data *d)\n{\n\tstruct intmux_irqchip_data *irqchip_data = d->chip_data;\n\tint idx = irqchip_data->chanidx;\n\tstruct intmux_data *data = container_of(irqchip_data, struct intmux_data,\n\t\t\t\t\t\tirqchip_data[idx]);\n\tunsigned long flags;\n\tvoid __iomem *reg;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&data->lock, flags);\n\treg = data->regs + CHANIER(idx);\n\tval = readl_relaxed(reg);\n\t \n\tval |= BIT(d->hwirq);\n\twritel_relaxed(val, reg);\n\traw_spin_unlock_irqrestore(&data->lock, flags);\n}\n\nstatic struct irq_chip imx_intmux_irq_chip __ro_after_init = {\n\t.name\t\t= \"intmux\",\n\t.irq_mask\t= imx_intmux_irq_mask,\n\t.irq_unmask\t= imx_intmux_irq_unmask,\n};\n\nstatic int imx_intmux_irq_map(struct irq_domain *h, unsigned int irq,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct intmux_irqchip_data *data = h->host_data;\n\n\tirq_set_chip_data(irq, data);\n\tirq_set_chip_and_handler(irq, &imx_intmux_irq_chip, handle_level_irq);\n\n\treturn 0;\n}\n\nstatic int imx_intmux_irq_xlate(struct irq_domain *d, struct device_node *node,\n\t\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\t\tunsigned long *out_hwirq, unsigned int *out_type)\n{\n\tstruct intmux_irqchip_data *irqchip_data = d->host_data;\n\tint idx = irqchip_data->chanidx;\n\tstruct intmux_data *data = container_of(irqchip_data, struct intmux_data,\n\t\t\t\t\t\tirqchip_data[idx]);\n\n\t \n\tif (WARN_ON(intsize != 2))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(intspec[1] >= data->channum))\n\t\treturn -EINVAL;\n\n\t*out_hwirq = intspec[0];\n\t*out_type = IRQ_TYPE_LEVEL_HIGH;\n\n\treturn 0;\n}\n\nstatic int imx_intmux_irq_select(struct irq_domain *d, struct irq_fwspec *fwspec,\n\t\t\t\t enum irq_domain_bus_token bus_token)\n{\n\tstruct intmux_irqchip_data *irqchip_data = d->host_data;\n\n\t \n\tif (fwspec->fwnode != d->fwnode)\n\t\treturn false;\n\n\treturn irqchip_data->chanidx == fwspec->param[1];\n}\n\nstatic const struct irq_domain_ops imx_intmux_domain_ops = {\n\t.map\t\t= imx_intmux_irq_map,\n\t.xlate\t\t= imx_intmux_irq_xlate,\n\t.select\t\t= imx_intmux_irq_select,\n};\n\nstatic void imx_intmux_irq_handler(struct irq_desc *desc)\n{\n\tstruct intmux_irqchip_data *irqchip_data = irq_desc_get_handler_data(desc);\n\tint idx = irqchip_data->chanidx;\n\tstruct intmux_data *data = container_of(irqchip_data, struct intmux_data,\n\t\t\t\t\t\tirqchip_data[idx]);\n\tunsigned long irqstat;\n\tint pos;\n\n\tchained_irq_enter(irq_desc_get_chip(desc), desc);\n\n\t \n\tirqstat = readl_relaxed(data->regs + CHANIPR(idx));\n\n\tfor_each_set_bit(pos, &irqstat, 32)\n\t\tgeneric_handle_domain_irq(irqchip_data->domain, pos);\n\n\tchained_irq_exit(irq_desc_get_chip(desc), desc);\n}\n\nstatic int imx_intmux_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct irq_domain *domain;\n\tstruct intmux_data *data;\n\tint channum;\n\tint i, ret;\n\n\tchannum = platform_irq_count(pdev);\n\tif (channum == -EPROBE_DEFER) {\n\t\treturn -EPROBE_DEFER;\n\t} else if (channum > CHAN_MAX_NUM) {\n\t\tdev_err(&pdev->dev, \"supports up to %d multiplex channels\\n\",\n\t\t\tCHAN_MAX_NUM);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = devm_kzalloc(&pdev->dev, struct_size(data, irqchip_data, channum), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->regs)) {\n\t\tdev_err(&pdev->dev, \"failed to initialize reg\\n\");\n\t\treturn PTR_ERR(data->regs);\n\t}\n\n\tdata->ipg_clk = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(data->ipg_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->ipg_clk),\n\t\t\t\t     \"failed to get ipg clk\\n\");\n\n\tdata->channum = channum;\n\traw_spin_lock_init(&data->lock);\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = clk_prepare_enable(data->ipg_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable ipg clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < channum; i++) {\n\t\tdata->irqchip_data[i].chanidx = i;\n\n\t\tdata->irqchip_data[i].irq = irq_of_parse_and_map(np, i);\n\t\tif (data->irqchip_data[i].irq <= 0) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(&pdev->dev, \"failed to get irq\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tdomain = irq_domain_add_linear(np, 32, &imx_intmux_domain_ops,\n\t\t\t\t\t       &data->irqchip_data[i]);\n\t\tif (!domain) {\n\t\t\tret = -ENOMEM;\n\t\t\tdev_err(&pdev->dev, \"failed to create IRQ domain\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tdata->irqchip_data[i].domain = domain;\n\t\tirq_domain_set_pm_device(domain, &pdev->dev);\n\n\t\t \n\t\twritel_relaxed(0, data->regs + CHANIER(i));\n\n\t\tirq_set_chained_handler_and_data(data->irqchip_data[i].irq,\n\t\t\t\t\t\t imx_intmux_irq_handler,\n\t\t\t\t\t\t &data->irqchip_data[i]);\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\nout:\n\tclk_disable_unprepare(data->ipg_clk);\n\treturn ret;\n}\n\nstatic int imx_intmux_remove(struct platform_device *pdev)\n{\n\tstruct intmux_data *data = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < data->channum; i++) {\n\t\t \n\t\twritel_relaxed(0, data->regs + CHANIER(i));\n\n\t\tirq_set_chained_handler_and_data(data->irqchip_data[i].irq,\n\t\t\t\t\t\t NULL, NULL);\n\n\t\tirq_domain_remove(data->irqchip_data[i].domain);\n\t}\n\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int imx_intmux_runtime_suspend(struct device *dev)\n{\n\tstruct intmux_data *data = dev_get_drvdata(dev);\n\tstruct intmux_irqchip_data *irqchip_data;\n\tint i;\n\n\tfor (i = 0; i < data->channum; i++) {\n\t\tirqchip_data = &data->irqchip_data[i];\n\t\tirqchip_data->saved_reg = readl_relaxed(data->regs + CHANIER(i));\n\t}\n\n\tclk_disable_unprepare(data->ipg_clk);\n\n\treturn 0;\n}\n\nstatic int imx_intmux_runtime_resume(struct device *dev)\n{\n\tstruct intmux_data *data = dev_get_drvdata(dev);\n\tstruct intmux_irqchip_data *irqchip_data;\n\tint ret, i;\n\n\tret = clk_prepare_enable(data->ipg_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable ipg clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < data->channum; i++) {\n\t\tirqchip_data = &data->irqchip_data[i];\n\t\twritel_relaxed(irqchip_data->saved_reg, data->regs + CHANIER(i));\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops imx_intmux_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t      pm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(imx_intmux_runtime_suspend,\n\t\t\t   imx_intmux_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id imx_intmux_id[] = {\n\t{ .compatible = \"fsl,imx-intmux\", },\n\t{   },\n};\n\nstatic struct platform_driver imx_intmux_driver = {\n\t.driver = {\n\t\t.name = \"imx-intmux\",\n\t\t.of_match_table = imx_intmux_id,\n\t\t.pm = &imx_intmux_pm_ops,\n\t},\n\t.probe = imx_intmux_probe,\n\t.remove = imx_intmux_remove,\n};\nbuiltin_platform_driver(imx_intmux_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}