{
  "module_name": "irq-renesas-rza1.c",
  "hash_id": "486a5ee716f3de1b70f88da299cee87ad574b1f7575555a6cfdd43b77743cb56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-renesas-rza1.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/interrupt-controller/arm-gic.h>\n\n#define IRQC_NUM_IRQ\t\t8\n\n#define ICR0\t\t\t0\t \n\n#define ICR0_NMIL\t\tBIT(15)\t \n#define ICR0_NMIE\t\tBIT(8)\t \n#define ICR0_NMIF\t\tBIT(1)\t \n\n#define ICR1\t\t\t2\t \n\n#define ICR1_IRQS(n, sense)\t((sense) << ((n) * 2))\t \n#define ICR1_IRQS_LEVEL_LOW\t0\n#define ICR1_IRQS_EDGE_FALLING\t1\n#define ICR1_IRQS_EDGE_RISING\t2\n#define ICR1_IRQS_EDGE_BOTH\t3\n#define ICR1_IRQS_MASK(n)\tICR1_IRQS((n), 3)\n\n#define IRQRR\t\t\t4\t \n\n\nstruct rza1_irqc_priv {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct irq_chip chip;\n\tstruct irq_domain *irq_domain;\n\tstruct of_phandle_args map[IRQC_NUM_IRQ];\n};\n\nstatic struct rza1_irqc_priv *irq_data_to_priv(struct irq_data *data)\n{\n\treturn data->domain->host_data;\n}\n\nstatic void rza1_irqc_eoi(struct irq_data *d)\n{\n\tstruct rza1_irqc_priv *priv = irq_data_to_priv(d);\n\tu16 bit = BIT(irqd_to_hwirq(d));\n\tu16 tmp;\n\n\ttmp = readw_relaxed(priv->base + IRQRR);\n\tif (tmp & bit)\n\t\twritew_relaxed(GENMASK(IRQC_NUM_IRQ - 1, 0) & ~bit,\n\t\t\t       priv->base + IRQRR);\n\n\tirq_chip_eoi_parent(d);\n}\n\nstatic int rza1_irqc_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct rza1_irqc_priv *priv = irq_data_to_priv(d);\n\tunsigned int hw_irq = irqd_to_hwirq(d);\n\tu16 sense, tmp;\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tsense = ICR1_IRQS_LEVEL_LOW;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tsense = ICR1_IRQS_EDGE_FALLING;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tsense = ICR1_IRQS_EDGE_RISING;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tsense = ICR1_IRQS_EDGE_BOTH;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = readw_relaxed(priv->base + ICR1);\n\ttmp &= ~ICR1_IRQS_MASK(hw_irq);\n\ttmp |= ICR1_IRQS(hw_irq, sense);\n\twritew_relaxed(tmp, priv->base + ICR1);\n\treturn 0;\n}\n\nstatic int rza1_irqc_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t   unsigned int nr_irqs, void *arg)\n{\n\tstruct rza1_irqc_priv *priv = domain->host_data;\n\tstruct irq_fwspec *fwspec = arg;\n\tunsigned int hwirq = fwspec->param[0];\n\tstruct irq_fwspec spec;\n\tunsigned int i;\n\tint ret;\n\n\tret = irq_domain_set_hwirq_and_chip(domain, virq, hwirq, &priv->chip,\n\t\t\t\t\t    priv);\n\tif (ret)\n\t\treturn ret;\n\n\tspec.fwnode = &priv->dev->of_node->fwnode;\n\tspec.param_count = priv->map[hwirq].args_count;\n\tfor (i = 0; i < spec.param_count; i++)\n\t\tspec.param[i] = priv->map[hwirq].args[i];\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &spec);\n}\n\nstatic int rza1_irqc_translate(struct irq_domain *domain,\n\t\t\t       struct irq_fwspec *fwspec, unsigned long *hwirq,\n\t\t\t       unsigned int *type)\n{\n\tif (fwspec->param_count != 2 || fwspec->param[0] >= IRQC_NUM_IRQ)\n\t\treturn -EINVAL;\n\n\t*hwirq = fwspec->param[0];\n\t*type = fwspec->param[1];\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops rza1_irqc_domain_ops = {\n\t.alloc = rza1_irqc_alloc,\n\t.translate = rza1_irqc_translate,\n};\n\nstatic int rza1_irqc_parse_map(struct rza1_irqc_priv *priv,\n\t\t\t       struct device_node *gic_node)\n{\n\tunsigned int imaplen, i, j, ret;\n\tstruct device *dev = priv->dev;\n\tstruct device_node *ipar;\n\tconst __be32 *imap;\n\tu32 intsize;\n\n\timap = of_get_property(dev->of_node, \"interrupt-map\", &imaplen);\n\tif (!imap)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < IRQC_NUM_IRQ; i++) {\n\t\tif (imaplen < 3)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (be32_to_cpup(imap) != i)\n\t\t\treturn -EINVAL;\n\n\t\tipar = of_find_node_by_phandle(be32_to_cpup(imap + 2));\n\t\tif (ipar != gic_node) {\n\t\t\tof_node_put(ipar);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\timap += 3;\n\t\timaplen -= 3;\n\n\t\tret = of_property_read_u32(ipar, \"#interrupt-cells\", &intsize);\n\t\tof_node_put(ipar);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (imaplen < intsize)\n\t\t\treturn -EINVAL;\n\n\t\tpriv->map[i].args_count = intsize;\n\t\tfor (j = 0; j < intsize; j++)\n\t\t\tpriv->map[i].args[j] = be32_to_cpup(imap++);\n\n\t\timaplen -= intsize;\n\t}\n\n\treturn 0;\n}\n\nstatic int rza1_irqc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct irq_domain *parent = NULL;\n\tstruct device_node *gic_node;\n\tstruct rza1_irqc_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\tpriv->dev = dev;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tgic_node = of_irq_find_parent(np);\n\tif (gic_node)\n\t\tparent = irq_find_host(gic_node);\n\n\tif (!parent) {\n\t\tdev_err(dev, \"cannot find parent domain\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_put_node;\n\t}\n\n\tret = rza1_irqc_parse_map(priv, gic_node);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot parse %s: %d\\n\", \"interrupt-map\", ret);\n\t\tgoto out_put_node;\n\t}\n\n\tpriv->chip.name = \"rza1-irqc\";\n\tpriv->chip.irq_mask = irq_chip_mask_parent;\n\tpriv->chip.irq_unmask = irq_chip_unmask_parent;\n\tpriv->chip.irq_eoi = rza1_irqc_eoi;\n\tpriv->chip.irq_retrigger = irq_chip_retrigger_hierarchy;\n\tpriv->chip.irq_set_type = rza1_irqc_set_type;\n\tpriv->chip.flags = IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_SKIP_SET_WAKE;\n\n\tpriv->irq_domain = irq_domain_add_hierarchy(parent, 0, IRQC_NUM_IRQ,\n\t\t\t\t\t\t    np, &rza1_irqc_domain_ops,\n\t\t\t\t\t\t    priv);\n\tif (!priv->irq_domain) {\n\t\tdev_err(dev, \"cannot initialize irq domain\\n\");\n\t\tret = -ENOMEM;\n\t}\n\nout_put_node:\n\tof_node_put(gic_node);\n\treturn ret;\n}\n\nstatic int rza1_irqc_remove(struct platform_device *pdev)\n{\n\tstruct rza1_irqc_priv *priv = platform_get_drvdata(pdev);\n\n\tirq_domain_remove(priv->irq_domain);\n\treturn 0;\n}\n\nstatic const struct of_device_id rza1_irqc_dt_ids[] = {\n\t{ .compatible = \"renesas,rza1-irqc\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rza1_irqc_dt_ids);\n\nstatic struct platform_driver rza1_irqc_device_driver = {\n\t.probe\t\t= rza1_irqc_probe,\n\t.remove\t\t= rza1_irqc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"renesas_rza1_irqc\",\n\t\t.of_match_table\t= rza1_irqc_dt_ids,\n\t}\n};\n\nstatic int __init rza1_irqc_init(void)\n{\n\treturn platform_driver_register(&rza1_irqc_device_driver);\n}\npostcore_initcall(rza1_irqc_init);\n\nstatic void __exit rza1_irqc_exit(void)\n{\n\tplatform_driver_unregister(&rza1_irqc_device_driver);\n}\nmodule_exit(rza1_irqc_exit);\n\nMODULE_AUTHOR(\"Geert Uytterhoeven <geert+renesas@glider.be>\");\nMODULE_DESCRIPTION(\"Renesas RZ/A1 IRQC Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}