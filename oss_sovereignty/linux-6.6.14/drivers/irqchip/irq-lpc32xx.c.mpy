{
  "module_name": "irq-lpc32xx.c",
  "hash_id": "3e4ff550728f7ab9b3d52d58c99cfb41a1f7f1c8b878b54ce125c950bc058813",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-lpc32xx.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/io.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <asm/exception.h>\n\n#define LPC32XX_INTC_MASK\t\t0x00\n#define LPC32XX_INTC_RAW\t\t0x04\n#define LPC32XX_INTC_STAT\t\t0x08\n#define LPC32XX_INTC_POL\t\t0x0C\n#define LPC32XX_INTC_TYPE\t\t0x10\n#define LPC32XX_INTC_FIQ\t\t0x14\n\n#define NR_LPC32XX_IC_IRQS\t\t32\n\nstruct lpc32xx_irq_chip {\n\tvoid __iomem *base;\n\tphys_addr_t addr;\n\tstruct irq_domain *domain;\n};\n\nstatic struct lpc32xx_irq_chip *lpc32xx_mic_irqc;\n\nstatic inline u32 lpc32xx_ic_read(struct lpc32xx_irq_chip *ic, u32 reg)\n{\n\treturn readl_relaxed(ic->base + reg);\n}\n\nstatic inline void lpc32xx_ic_write(struct lpc32xx_irq_chip *ic,\n\t\t\t\t    u32 reg, u32 val)\n{\n\twritel_relaxed(val, ic->base + reg);\n}\n\nstatic void lpc32xx_irq_mask(struct irq_data *d)\n{\n\tstruct lpc32xx_irq_chip *ic = irq_data_get_irq_chip_data(d);\n\tu32 val, mask = BIT(d->hwirq);\n\n\tval = lpc32xx_ic_read(ic, LPC32XX_INTC_MASK) & ~mask;\n\tlpc32xx_ic_write(ic, LPC32XX_INTC_MASK, val);\n}\n\nstatic void lpc32xx_irq_unmask(struct irq_data *d)\n{\n\tstruct lpc32xx_irq_chip *ic = irq_data_get_irq_chip_data(d);\n\tu32 val, mask = BIT(d->hwirq);\n\n\tval = lpc32xx_ic_read(ic, LPC32XX_INTC_MASK) | mask;\n\tlpc32xx_ic_write(ic, LPC32XX_INTC_MASK, val);\n}\n\nstatic void lpc32xx_irq_ack(struct irq_data *d)\n{\n\tstruct lpc32xx_irq_chip *ic = irq_data_get_irq_chip_data(d);\n\tu32 mask = BIT(d->hwirq);\n\n\tlpc32xx_ic_write(ic, LPC32XX_INTC_RAW, mask);\n}\n\nstatic int lpc32xx_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct lpc32xx_irq_chip *ic = irq_data_get_irq_chip_data(d);\n\tu32 val, mask = BIT(d->hwirq);\n\tbool high, edge;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tedge = true;\n\t\thigh = true;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tedge = true;\n\t\thigh = false;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tedge = false;\n\t\thigh = true;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tedge = false;\n\t\thigh = false;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"unsupported irq type %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tirqd_set_trigger_type(d, type);\n\n\tval = lpc32xx_ic_read(ic, LPC32XX_INTC_POL);\n\tif (high)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\tlpc32xx_ic_write(ic, LPC32XX_INTC_POL, val);\n\n\tval = lpc32xx_ic_read(ic, LPC32XX_INTC_TYPE);\n\tif (edge) {\n\t\tval |= mask;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t} else {\n\t\tval &= ~mask;\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t}\n\tlpc32xx_ic_write(ic, LPC32XX_INTC_TYPE, val);\n\n\treturn 0;\n}\n\nstatic void lpc32xx_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct lpc32xx_irq_chip *ic = irq_data_get_irq_chip_data(d);\n\n\tif (ic == lpc32xx_mic_irqc)\n\t\tseq_printf(p, \"%08x.mic\", ic->addr);\n\telse\n\t\tseq_printf(p, \"%08x.sic\", ic->addr);\n}\n\nstatic const struct irq_chip lpc32xx_chip = {\n\t.irq_ack\t= lpc32xx_irq_ack,\n\t.irq_mask\t= lpc32xx_irq_mask,\n\t.irq_unmask\t= lpc32xx_irq_unmask,\n\t.irq_set_type\t= lpc32xx_irq_set_type,\n\t.irq_print_chip\t= lpc32xx_irq_print_chip,\n};\n\nstatic void __exception_irq_entry lpc32xx_handle_irq(struct pt_regs *regs)\n{\n\tstruct lpc32xx_irq_chip *ic = lpc32xx_mic_irqc;\n\tu32 hwirq = lpc32xx_ic_read(ic, LPC32XX_INTC_STAT), irq;\n\n\twhile (hwirq) {\n\t\tirq = __ffs(hwirq);\n\t\thwirq &= ~BIT(irq);\n\t\tgeneric_handle_domain_irq(lpc32xx_mic_irqc->domain, irq);\n\t}\n}\n\nstatic void lpc32xx_sic_handler(struct irq_desc *desc)\n{\n\tstruct lpc32xx_irq_chip *ic = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tu32 hwirq = lpc32xx_ic_read(ic, LPC32XX_INTC_STAT), irq;\n\n\tchained_irq_enter(chip, desc);\n\n\twhile (hwirq) {\n\t\tirq = __ffs(hwirq);\n\t\thwirq &= ~BIT(irq);\n\t\tgeneric_handle_domain_irq(ic->domain, irq);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int lpc32xx_irq_domain_map(struct irq_domain *id, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hw)\n{\n\tstruct lpc32xx_irq_chip *ic = id->host_data;\n\n\tirq_set_chip_data(virq, ic);\n\tirq_set_chip_and_handler(virq, &lpc32xx_chip, handle_level_irq);\n\tirq_set_status_flags(virq, IRQ_LEVEL);\n\tirq_set_noprobe(virq);\n\n\treturn 0;\n}\n\nstatic void lpc32xx_irq_domain_unmap(struct irq_domain *id, unsigned int virq)\n{\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n}\n\nstatic const struct irq_domain_ops lpc32xx_irq_domain_ops = {\n\t.map    = lpc32xx_irq_domain_map,\n\t.unmap\t= lpc32xx_irq_domain_unmap,\n\t.xlate  = irq_domain_xlate_twocell,\n};\n\nstatic int __init lpc32xx_of_ic_init(struct device_node *node,\n\t\t\t\t     struct device_node *parent)\n{\n\tstruct lpc32xx_irq_chip *irqc;\n\tbool is_mic = of_device_is_compatible(node, \"nxp,lpc3220-mic\");\n\tconst __be32 *reg = of_get_property(node, \"reg\", NULL);\n\tu32 parent_irq, i, addr = reg ? be32_to_cpu(*reg) : 0;\n\n\tirqc = kzalloc(sizeof(*irqc), GFP_KERNEL);\n\tif (!irqc)\n\t\treturn -ENOMEM;\n\n\tirqc->addr = addr;\n\tirqc->base = of_iomap(node, 0);\n\tif (!irqc->base) {\n\t\tpr_err(\"%pOF: unable to map registers\\n\", node);\n\t\tkfree(irqc);\n\t\treturn -EINVAL;\n\t}\n\n\tirqc->domain = irq_domain_add_linear(node, NR_LPC32XX_IC_IRQS,\n\t\t\t\t\t     &lpc32xx_irq_domain_ops, irqc);\n\tif (!irqc->domain) {\n\t\tpr_err(\"unable to add irq domain\\n\");\n\t\tiounmap(irqc->base);\n\t\tkfree(irqc);\n\t\treturn -ENODEV;\n\t}\n\n\tif (is_mic) {\n\t\tlpc32xx_mic_irqc = irqc;\n\t\tset_handle_irq(lpc32xx_handle_irq);\n\t} else {\n\t\tfor (i = 0; i < of_irq_count(node); i++) {\n\t\t\tparent_irq = irq_of_parse_and_map(node, i);\n\t\t\tif (parent_irq)\n\t\t\t\tirq_set_chained_handler_and_data(parent_irq,\n\t\t\t\t\t\t lpc32xx_sic_handler, irqc);\n\t\t}\n\t}\n\n\tlpc32xx_ic_write(irqc, LPC32XX_INTC_MASK, 0x00);\n\tlpc32xx_ic_write(irqc, LPC32XX_INTC_POL,  0x00);\n\tlpc32xx_ic_write(irqc, LPC32XX_INTC_TYPE, 0x00);\n\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(nxp_lpc32xx_mic, \"nxp,lpc3220-mic\", lpc32xx_of_ic_init);\nIRQCHIP_DECLARE(nxp_lpc32xx_sic, \"nxp,lpc3220-sic\", lpc32xx_of_ic_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}