{
  "module_name": "irq-bcm2835.c",
  "hash_id": "4bdd5ccfa3a7bdc914e104cdb16425c7be444ee4c2e66655c34d4e32a271a3e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-bcm2835.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdomain.h>\n\n#include <asm/exception.h>\n\n \n#define MAKE_HWIRQ(b, n)\t((b << 5) | (n))\n#define HWIRQ_BANK(i)\t\t(i >> 5)\n#define HWIRQ_BIT(i)\t\tBIT(i & 0x1f)\n\n#define NR_IRQS_BANK0\t\t8\n#define BANK0_HWIRQ_MASK\t0xff\n \n#define SHORTCUT1_MASK\t\t0x00007c00\n#define SHORTCUT2_MASK\t\t0x001f8000\n#define SHORTCUT_SHIFT\t\t10\n#define BANK1_HWIRQ\t\tBIT(8)\n#define BANK2_HWIRQ\t\tBIT(9)\n#define BANK0_VALID_MASK\t(BANK0_HWIRQ_MASK | BANK1_HWIRQ | BANK2_HWIRQ \\\n\t\t\t\t\t| SHORTCUT1_MASK | SHORTCUT2_MASK)\n\n#define REG_FIQ_CONTROL\t\t0x0c\n#define FIQ_CONTROL_ENABLE\tBIT(7)\n\n#define NR_BANKS\t\t3\n#define IRQS_PER_BANK\t\t32\n\nstatic const int reg_pending[] __initconst = { 0x00, 0x04, 0x08 };\nstatic const int reg_enable[] __initconst = { 0x18, 0x10, 0x14 };\nstatic const int reg_disable[] __initconst = { 0x24, 0x1c, 0x20 };\nstatic const int bank_irqs[] __initconst = { 8, 32, 32 };\n\nstatic const int shortcuts[] = {\n\t7, 9, 10, 18, 19,\t\t \n\t21, 22, 23, 24, 25, 30\t\t \n};\n\nstruct armctrl_ic {\n\tvoid __iomem *base;\n\tvoid __iomem *pending[NR_BANKS];\n\tvoid __iomem *enable[NR_BANKS];\n\tvoid __iomem *disable[NR_BANKS];\n\tstruct irq_domain *domain;\n};\n\nstatic struct armctrl_ic intc __read_mostly;\nstatic void __exception_irq_entry bcm2835_handle_irq(\n\tstruct pt_regs *regs);\nstatic void bcm2836_chained_handle_irq(struct irq_desc *desc);\n\nstatic void armctrl_mask_irq(struct irq_data *d)\n{\n\twritel_relaxed(HWIRQ_BIT(d->hwirq), intc.disable[HWIRQ_BANK(d->hwirq)]);\n}\n\nstatic void armctrl_unmask_irq(struct irq_data *d)\n{\n\twritel_relaxed(HWIRQ_BIT(d->hwirq), intc.enable[HWIRQ_BANK(d->hwirq)]);\n}\n\nstatic struct irq_chip armctrl_chip = {\n\t.name = \"ARMCTRL-level\",\n\t.irq_mask = armctrl_mask_irq,\n\t.irq_unmask = armctrl_unmask_irq\n};\n\nstatic int armctrl_xlate(struct irq_domain *d, struct device_node *ctrlr,\n\tconst u32 *intspec, unsigned int intsize,\n\tunsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize != 2))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(intspec[0] >= NR_BANKS))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(intspec[1] >= IRQS_PER_BANK))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(intspec[0] == 0 && intspec[1] >= NR_IRQS_BANK0))\n\t\treturn -EINVAL;\n\n\t*out_hwirq = MAKE_HWIRQ(intspec[0], intspec[1]);\n\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops armctrl_ops = {\n\t.xlate = armctrl_xlate\n};\n\nstatic int __init armctrl_of_init(struct device_node *node,\n\t\t\t\t  struct device_node *parent,\n\t\t\t\t  bool is_2836)\n{\n\tvoid __iomem *base;\n\tint irq, b, i;\n\tu32 reg;\n\n\tbase = of_iomap(node, 0);\n\tif (!base)\n\t\tpanic(\"%pOF: unable to map IC registers\\n\", node);\n\n\tintc.domain = irq_domain_add_linear(node, MAKE_HWIRQ(NR_BANKS, 0),\n\t\t\t&armctrl_ops, NULL);\n\tif (!intc.domain)\n\t\tpanic(\"%pOF: unable to create IRQ domain\\n\", node);\n\n\tfor (b = 0; b < NR_BANKS; b++) {\n\t\tintc.pending[b] = base + reg_pending[b];\n\t\tintc.enable[b] = base + reg_enable[b];\n\t\tintc.disable[b] = base + reg_disable[b];\n\n\t\tfor (i = 0; i < bank_irqs[b]; i++) {\n\t\t\tirq = irq_create_mapping(intc.domain, MAKE_HWIRQ(b, i));\n\t\t\tBUG_ON(irq <= 0);\n\t\t\tirq_set_chip_and_handler(irq, &armctrl_chip,\n\t\t\t\thandle_level_irq);\n\t\t\tirq_set_probe(irq);\n\t\t}\n\n\t\treg = readl_relaxed(intc.enable[b]);\n\t\tif (reg) {\n\t\t\twritel_relaxed(reg, intc.disable[b]);\n\t\t\tpr_err(FW_BUG \"Bootloader left irq enabled: \"\n\t\t\t       \"bank %d irq %*pbl\\n\", b, IRQS_PER_BANK, &reg);\n\t\t}\n\t}\n\n\treg = readl_relaxed(base + REG_FIQ_CONTROL);\n\tif (reg & FIQ_CONTROL_ENABLE) {\n\t\twritel_relaxed(0, base + REG_FIQ_CONTROL);\n\t\tpr_err(FW_BUG \"Bootloader left fiq enabled\\n\");\n\t}\n\n\tif (is_2836) {\n\t\tint parent_irq = irq_of_parse_and_map(node, 0);\n\n\t\tif (!parent_irq) {\n\t\t\tpanic(\"%pOF: unable to get parent interrupt.\\n\",\n\t\t\t      node);\n\t\t}\n\t\tirq_set_chained_handler(parent_irq, bcm2836_chained_handle_irq);\n\t} else {\n\t\tset_handle_irq(bcm2835_handle_irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int __init bcm2835_armctrl_of_init(struct device_node *node,\n\t\t\t\t\t  struct device_node *parent)\n{\n\treturn armctrl_of_init(node, parent, false);\n}\n\nstatic int __init bcm2836_armctrl_of_init(struct device_node *node,\n\t\t\t\t\t  struct device_node *parent)\n{\n\treturn armctrl_of_init(node, parent, true);\n}\n\n\n \n\nstatic u32 armctrl_translate_bank(int bank)\n{\n\tu32 stat = readl_relaxed(intc.pending[bank]);\n\n\treturn MAKE_HWIRQ(bank, ffs(stat) - 1);\n}\n\nstatic u32 armctrl_translate_shortcut(int bank, u32 stat)\n{\n\treturn MAKE_HWIRQ(bank, shortcuts[ffs(stat >> SHORTCUT_SHIFT) - 1]);\n}\n\nstatic u32 get_next_armctrl_hwirq(void)\n{\n\tu32 stat = readl_relaxed(intc.pending[0]) & BANK0_VALID_MASK;\n\n\tif (stat == 0)\n\t\treturn ~0;\n\telse if (stat & BANK0_HWIRQ_MASK)\n\t\treturn MAKE_HWIRQ(0, ffs(stat & BANK0_HWIRQ_MASK) - 1);\n\telse if (stat & SHORTCUT1_MASK)\n\t\treturn armctrl_translate_shortcut(1, stat & SHORTCUT1_MASK);\n\telse if (stat & SHORTCUT2_MASK)\n\t\treturn armctrl_translate_shortcut(2, stat & SHORTCUT2_MASK);\n\telse if (stat & BANK1_HWIRQ)\n\t\treturn armctrl_translate_bank(1);\n\telse if (stat & BANK2_HWIRQ)\n\t\treturn armctrl_translate_bank(2);\n\telse\n\t\tBUG();\n}\n\nstatic void __exception_irq_entry bcm2835_handle_irq(\n\tstruct pt_regs *regs)\n{\n\tu32 hwirq;\n\n\twhile ((hwirq = get_next_armctrl_hwirq()) != ~0)\n\t\tgeneric_handle_domain_irq(intc.domain, hwirq);\n}\n\nstatic void bcm2836_chained_handle_irq(struct irq_desc *desc)\n{\n\tu32 hwirq;\n\n\twhile ((hwirq = get_next_armctrl_hwirq()) != ~0)\n\t\tgeneric_handle_domain_irq(intc.domain, hwirq);\n}\n\nIRQCHIP_DECLARE(bcm2835_armctrl_ic, \"brcm,bcm2835-armctrl-ic\",\n\t\tbcm2835_armctrl_of_init);\nIRQCHIP_DECLARE(bcm2836_armctrl_ic, \"brcm,bcm2836-armctrl-ic\",\n\t\tbcm2836_armctrl_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}