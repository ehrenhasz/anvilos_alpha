{
  "module_name": "irq-imx-gpcv2.c",
  "hash_id": "bfd81eda1cd9689c13c109e2e836254498ae8ad7d07ef73d759cfb1c7040ad3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/irqchip/irq-imx-gpcv2.c",
  "human_readable_source": "\n \n\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/slab.h>\n#include <linux/irqchip.h>\n#include <linux/syscore_ops.h>\n\n#define IMR_NUM\t\t\t4\n#define GPC_MAX_IRQS            (IMR_NUM * 32)\n\n#define GPC_IMR1_CORE0\t\t0x30\n#define GPC_IMR1_CORE1\t\t0x40\n#define GPC_IMR1_CORE2\t\t0x1c0\n#define GPC_IMR1_CORE3\t\t0x1d0\n\n\nstruct gpcv2_irqchip_data {\n\tstruct raw_spinlock\trlock;\n\tvoid __iomem\t\t*gpc_base;\n\tu32\t\t\twakeup_sources[IMR_NUM];\n\tu32\t\t\tsaved_irq_mask[IMR_NUM];\n\tu32\t\t\tcpu2wakeup;\n};\n\nstatic struct gpcv2_irqchip_data *imx_gpcv2_instance __ro_after_init;\n\nstatic void __iomem *gpcv2_idx_to_reg(struct gpcv2_irqchip_data *cd, int i)\n{\n\treturn cd->gpc_base + cd->cpu2wakeup + i * 4;\n}\n\nstatic int gpcv2_wakeup_source_save(void)\n{\n\tstruct gpcv2_irqchip_data *cd;\n\tvoid __iomem *reg;\n\tint i;\n\n\tcd = imx_gpcv2_instance;\n\tif (!cd)\n\t\treturn 0;\n\n\tfor (i = 0; i < IMR_NUM; i++) {\n\t\treg = gpcv2_idx_to_reg(cd, i);\n\t\tcd->saved_irq_mask[i] = readl_relaxed(reg);\n\t\twritel_relaxed(cd->wakeup_sources[i], reg);\n\t}\n\n\treturn 0;\n}\n\nstatic void gpcv2_wakeup_source_restore(void)\n{\n\tstruct gpcv2_irqchip_data *cd;\n\tint i;\n\n\tcd = imx_gpcv2_instance;\n\tif (!cd)\n\t\treturn;\n\n\tfor (i = 0; i < IMR_NUM; i++)\n\t\twritel_relaxed(cd->saved_irq_mask[i], gpcv2_idx_to_reg(cd, i));\n}\n\nstatic struct syscore_ops imx_gpcv2_syscore_ops = {\n\t.suspend\t= gpcv2_wakeup_source_save,\n\t.resume\t\t= gpcv2_wakeup_source_restore,\n};\n\nstatic int imx_gpcv2_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct gpcv2_irqchip_data *cd = d->chip_data;\n\tunsigned int idx = d->hwirq / 32;\n\tunsigned long flags;\n\tu32 mask, val;\n\n\traw_spin_lock_irqsave(&cd->rlock, flags);\n\tmask = BIT(d->hwirq % 32);\n\tval = cd->wakeup_sources[idx];\n\n\tcd->wakeup_sources[idx] = on ? (val & ~mask) : (val | mask);\n\traw_spin_unlock_irqrestore(&cd->rlock, flags);\n\n\t \n\n\treturn 0;\n}\n\nstatic void imx_gpcv2_irq_unmask(struct irq_data *d)\n{\n\tstruct gpcv2_irqchip_data *cd = d->chip_data;\n\tvoid __iomem *reg;\n\tu32 val;\n\n\traw_spin_lock(&cd->rlock);\n\treg = gpcv2_idx_to_reg(cd, d->hwirq / 32);\n\tval = readl_relaxed(reg);\n\tval &= ~BIT(d->hwirq % 32);\n\twritel_relaxed(val, reg);\n\traw_spin_unlock(&cd->rlock);\n\n\tirq_chip_unmask_parent(d);\n}\n\nstatic void imx_gpcv2_irq_mask(struct irq_data *d)\n{\n\tstruct gpcv2_irqchip_data *cd = d->chip_data;\n\tvoid __iomem *reg;\n\tu32 val;\n\n\traw_spin_lock(&cd->rlock);\n\treg = gpcv2_idx_to_reg(cd, d->hwirq / 32);\n\tval = readl_relaxed(reg);\n\tval |= BIT(d->hwirq % 32);\n\twritel_relaxed(val, reg);\n\traw_spin_unlock(&cd->rlock);\n\n\tirq_chip_mask_parent(d);\n}\n\nstatic struct irq_chip gpcv2_irqchip_data_chip = {\n\t.name\t\t\t= \"GPCv2\",\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_mask\t\t= imx_gpcv2_irq_mask,\n\t.irq_unmask\t\t= imx_gpcv2_irq_unmask,\n\t.irq_set_wake\t\t= imx_gpcv2_irq_set_wake,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n#endif\n};\n\nstatic int imx_gpcv2_domain_translate(struct irq_domain *d,\n\t\t\t\t      struct irq_fwspec *fwspec,\n\t\t\t\t      unsigned long *hwirq,\n\t\t\t\t      unsigned int *type)\n{\n\tif (is_of_node(fwspec->fwnode)) {\n\t\tif (fwspec->param_count != 3)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (fwspec->param[0] != 0)\n\t\t\treturn -EINVAL;\n\n\t\t*hwirq = fwspec->param[1];\n\t\t*type = fwspec->param[2];\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int imx_gpcv2_domain_alloc(struct irq_domain *domain,\n\t\t\t\t  unsigned int irq, unsigned int nr_irqs,\n\t\t\t\t  void *data)\n{\n\tstruct irq_fwspec *fwspec = data;\n\tstruct irq_fwspec parent_fwspec;\n\tirq_hw_number_t hwirq;\n\tunsigned int type;\n\tint err;\n\tint i;\n\n\terr = imx_gpcv2_domain_translate(domain, fwspec, &hwirq, &type);\n\tif (err)\n\t\treturn err;\n\n\tif (hwirq >= GPC_MAX_IRQS)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_domain_set_hwirq_and_chip(domain, irq + i, hwirq + i,\n\t\t\t\t&gpcv2_irqchip_data_chip, domain->host_data);\n\t}\n\n\tparent_fwspec = *fwspec;\n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\treturn irq_domain_alloc_irqs_parent(domain, irq, nr_irqs,\n\t\t\t\t\t    &parent_fwspec);\n}\n\nstatic const struct irq_domain_ops gpcv2_irqchip_data_domain_ops = {\n\t.translate\t= imx_gpcv2_domain_translate,\n\t.alloc\t\t= imx_gpcv2_domain_alloc,\n\t.free\t\t= irq_domain_free_irqs_common,\n};\n\nstatic const struct of_device_id gpcv2_of_match[] = {\n\t{ .compatible = \"fsl,imx7d-gpc\",  .data = (const void *) 2 },\n\t{ .compatible = \"fsl,imx8mq-gpc\", .data = (const void *) 4 },\n\t{   }\n};\n\nstatic int __init imx_gpcv2_irqchip_init(struct device_node *node,\n\t\t\t       struct device_node *parent)\n{\n\tstruct irq_domain *parent_domain, *domain;\n\tstruct gpcv2_irqchip_data *cd;\n\tconst struct of_device_id *id;\n\tunsigned long core_num;\n\tint i;\n\n\tif (!parent) {\n\t\tpr_err(\"%pOF: no parent, giving up\\n\", node);\n\t\treturn -ENODEV;\n\t}\n\n\tid = of_match_node(gpcv2_of_match, node);\n\tif (!id) {\n\t\tpr_err(\"%pOF: unknown compatibility string\\n\", node);\n\t\treturn -ENODEV;\n\t}\n\n\tcore_num = (unsigned long)id->data;\n\n\tparent_domain = irq_find_host(parent);\n\tif (!parent_domain) {\n\t\tpr_err(\"%pOF: unable to get parent domain\\n\", node);\n\t\treturn -ENXIO;\n\t}\n\n\tcd = kzalloc(sizeof(struct gpcv2_irqchip_data), GFP_KERNEL);\n\tif (!cd)\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_init(&cd->rlock);\n\n\tcd->gpc_base = of_iomap(node, 0);\n\tif (!cd->gpc_base) {\n\t\tpr_err(\"%pOF: unable to map gpc registers\\n\", node);\n\t\tkfree(cd);\n\t\treturn -ENOMEM;\n\t}\n\n\tdomain = irq_domain_add_hierarchy(parent_domain, 0, GPC_MAX_IRQS,\n\t\t\t\tnode, &gpcv2_irqchip_data_domain_ops, cd);\n\tif (!domain) {\n\t\tiounmap(cd->gpc_base);\n\t\tkfree(cd);\n\t\treturn -ENOMEM;\n\t}\n\tirq_set_default_host(domain);\n\n\t \n\tfor (i = 0; i < IMR_NUM; i++) {\n\t\tvoid __iomem *reg = cd->gpc_base + i * 4;\n\n\t\tswitch (core_num) {\n\t\tcase 4:\n\t\t\twritel_relaxed(~0, reg + GPC_IMR1_CORE2);\n\t\t\twritel_relaxed(~0, reg + GPC_IMR1_CORE3);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\twritel_relaxed(~0, reg + GPC_IMR1_CORE0);\n\t\t\twritel_relaxed(~0, reg + GPC_IMR1_CORE1);\n\t\t}\n\t\tcd->wakeup_sources[i] = ~0;\n\t}\n\n\t \n\tcd->cpu2wakeup = GPC_IMR1_CORE0;\n\n\t \n\twritel_relaxed(~0x1, cd->gpc_base + cd->cpu2wakeup);\n\n\timx_gpcv2_instance = cd;\n\tregister_syscore_ops(&imx_gpcv2_syscore_ops);\n\n\t \n\tof_node_clear_flag(node, OF_POPULATED);\n\tfwnode_dev_initialized(domain->fwnode, false);\n\treturn 0;\n}\n\nIRQCHIP_DECLARE(imx_gpcv2_imx7d, \"fsl,imx7d-gpc\", imx_gpcv2_irqchip_init);\nIRQCHIP_DECLARE(imx_gpcv2_imx8mq, \"fsl,imx8mq-gpc\", imx_gpcv2_irqchip_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}