{
  "module_name": "ax45mp_cache.c",
  "hash_id": "d6ce90082b95aee939b82a4f47a253b83fec3ecc0be258e69b6cdeb907c450f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cache/ax45mp_cache.c",
  "human_readable_source": "\n \n\n#include <linux/cacheflush.h>\n#include <linux/cacheinfo.h>\n#include <linux/dma-direction.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n\n#include <asm/dma-noncoherent.h>\n\n \n#define AX45MP_L2C_REG_CTL_OFFSET\t\t0x8\n\n#define AX45MP_L2C_REG_C0_CMD_OFFSET\t\t0x40\n#define AX45MP_L2C_REG_C0_ACC_OFFSET\t\t0x48\n#define AX45MP_L2C_REG_STATUS_OFFSET\t\t0x80\n\n \n#define AX45MP_CCTL_L1D_VA_INVAL\t\t0  \n#define AX45MP_CCTL_L1D_VA_WB\t\t\t1  \n\n \n#define AX45MP_CCTL_L2_STATUS_IDLE\t\t0\n\n \n#define AX45MP_CCTL_L2_STATUS_C0_MASK\t\t0xf\n\n \n#define AX45MP_CCTL_L2_PA_INVAL\t\t\t0x8  \n#define AX45MP_CCTL_L2_PA_WB\t\t\t0x9  \n\n#define AX45MP_L2C_REG_PER_CORE_OFFSET\t\t0x10\n#define AX45MP_CCTL_L2_STATUS_PER_CORE_OFFSET\t4\n\n#define AX45MP_L2C_REG_CN_CMD_OFFSET(n)\t\\\n\t(AX45MP_L2C_REG_C0_CMD_OFFSET + ((n) * AX45MP_L2C_REG_PER_CORE_OFFSET))\n#define AX45MP_L2C_REG_CN_ACC_OFFSET(n)\t\\\n\t(AX45MP_L2C_REG_C0_ACC_OFFSET + ((n) * AX45MP_L2C_REG_PER_CORE_OFFSET))\n#define AX45MP_CCTL_L2_STATUS_CN_MASK(n)\t\\\n\t(AX45MP_CCTL_L2_STATUS_C0_MASK << ((n) * AX45MP_CCTL_L2_STATUS_PER_CORE_OFFSET))\n\n#define AX45MP_CCTL_REG_UCCTLBEGINADDR_NUM\t0x80b\n#define AX45MP_CCTL_REG_UCCTLCOMMAND_NUM\t0x80c\n\n#define AX45MP_CACHE_LINE_SIZE\t\t\t64\n\nstruct ax45mp_priv {\n\tvoid __iomem *l2c_base;\n\tu32 ax45mp_cache_line_size;\n};\n\nstatic struct ax45mp_priv ax45mp_priv;\n\n \nstatic inline uint32_t ax45mp_cpu_l2c_get_cctl_status(void)\n{\n\treturn readl(ax45mp_priv.l2c_base + AX45MP_L2C_REG_STATUS_OFFSET);\n}\n\nstatic void ax45mp_cpu_cache_operation(unsigned long start, unsigned long end,\n\t\t\t\t       unsigned int l1_op, unsigned int l2_op)\n{\n\tunsigned long line_size = ax45mp_priv.ax45mp_cache_line_size;\n\tvoid __iomem *base = ax45mp_priv.l2c_base;\n\tint mhartid = smp_processor_id();\n\tunsigned long pa;\n\n\twhile (end > start) {\n\t\tcsr_write(AX45MP_CCTL_REG_UCCTLBEGINADDR_NUM, start);\n\t\tcsr_write(AX45MP_CCTL_REG_UCCTLCOMMAND_NUM, l1_op);\n\n\t\tpa = virt_to_phys((void *)start);\n\t\twritel(pa, base + AX45MP_L2C_REG_CN_ACC_OFFSET(mhartid));\n\t\twritel(l2_op, base + AX45MP_L2C_REG_CN_CMD_OFFSET(mhartid));\n\t\twhile ((ax45mp_cpu_l2c_get_cctl_status() &\n\t\t\tAX45MP_CCTL_L2_STATUS_CN_MASK(mhartid)) !=\n\t\t\tAX45MP_CCTL_L2_STATUS_IDLE)\n\t\t\t;\n\n\t\tstart += line_size;\n\t}\n}\n\n \nstatic inline void ax45mp_cpu_dcache_wb_range(unsigned long start, unsigned long end)\n{\n\tax45mp_cpu_cache_operation(start, end, AX45MP_CCTL_L1D_VA_WB,\n\t\t\t\t   AX45MP_CCTL_L2_PA_WB);\n}\n\n \nstatic inline void ax45mp_cpu_dcache_inval_range(unsigned long start, unsigned long end)\n{\n\tax45mp_cpu_cache_operation(start, end, AX45MP_CCTL_L1D_VA_INVAL,\n\t\t\t\t   AX45MP_CCTL_L2_PA_INVAL);\n}\n\nstatic void ax45mp_dma_cache_inv(phys_addr_t paddr, size_t size)\n{\n\tunsigned long start = (unsigned long)phys_to_virt(paddr);\n\tunsigned long end = start + size;\n\tunsigned long line_size;\n\tunsigned long flags;\n\n\tif (unlikely(start == end))\n\t\treturn;\n\n\tline_size = ax45mp_priv.ax45mp_cache_line_size;\n\n\tstart = start & (~(line_size - 1));\n\tend = ((end + line_size - 1) & (~(line_size - 1)));\n\n\tlocal_irq_save(flags);\n\n\tax45mp_cpu_dcache_inval_range(start, end);\n\n\tlocal_irq_restore(flags);\n}\n\nstatic void ax45mp_dma_cache_wback(phys_addr_t paddr, size_t size)\n{\n\tunsigned long start = (unsigned long)phys_to_virt(paddr);\n\tunsigned long end = start + size;\n\tunsigned long line_size;\n\tunsigned long flags;\n\n\tline_size = ax45mp_priv.ax45mp_cache_line_size;\n\tstart = start & (~(line_size - 1));\n\tlocal_irq_save(flags);\n\tax45mp_cpu_dcache_wb_range(start, end);\n\tlocal_irq_restore(flags);\n}\n\nstatic void ax45mp_dma_cache_wback_inv(phys_addr_t paddr, size_t size)\n{\n\tax45mp_dma_cache_wback(paddr, size);\n\tax45mp_dma_cache_inv(paddr, size);\n}\n\nstatic int ax45mp_get_l2_line_size(struct device_node *np)\n{\n\tint ret;\n\n\tret = of_property_read_u32(np, \"cache-line-size\", &ax45mp_priv.ax45mp_cache_line_size);\n\tif (ret) {\n\t\tpr_err(\"Failed to get cache-line-size, defaulting to 64 bytes\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ax45mp_priv.ax45mp_cache_line_size != AX45MP_CACHE_LINE_SIZE) {\n\t\tpr_err(\"Expected cache-line-size to be 64 bytes (found:%u)\\n\",\n\t\t       ax45mp_priv.ax45mp_cache_line_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct riscv_nonstd_cache_ops ax45mp_cmo_ops __initdata = {\n\t.wback = &ax45mp_dma_cache_wback,\n\t.inv = &ax45mp_dma_cache_inv,\n\t.wback_inv = &ax45mp_dma_cache_wback_inv,\n};\n\nstatic const struct of_device_id ax45mp_cache_ids[] = {\n\t{ .compatible = \"andestech,ax45mp-cache\" },\n\t{   }\n};\n\nstatic int __init ax45mp_cache_init(void)\n{\n\tstruct device_node *np;\n\tstruct resource res;\n\tint ret;\n\n\tnp = of_find_matching_node(NULL, ax45mp_cache_ids);\n\tif (!of_device_is_available(np))\n\t\treturn -ENODEV;\n\n\tret = of_address_to_resource(np, 0, &res);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!riscv_cbom_block_size)\n\t\treturn 0;\n\n\tax45mp_priv.l2c_base = ioremap(res.start, resource_size(&res));\n\tif (!ax45mp_priv.l2c_base)\n\t\treturn -ENOMEM;\n\n\tret = ax45mp_get_l2_line_size(np);\n\tif (ret) {\n\t\tiounmap(ax45mp_priv.l2c_base);\n\t\treturn ret;\n\t}\n\n\triscv_noncoherent_register_cache_ops(&ax45mp_cmo_ops);\n\n\treturn 0;\n}\nearly_initcall(ax45mp_cache_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}