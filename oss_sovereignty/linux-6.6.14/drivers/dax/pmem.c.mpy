{
  "module_name": "pmem.c",
  "hash_id": "53f532f360bcf85bbd4b0ad763ec173c752da2c63c26988b2f63f2a79ff10cfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dax/pmem.c",
  "human_readable_source": "\n \n#include <linux/memremap.h>\n#include <linux/module.h>\n#include <linux/pfn_t.h>\n#include \"../nvdimm/pfn.h\"\n#include \"../nvdimm/nd.h\"\n#include \"bus.h\"\n\nstatic struct dev_dax *__dax_pmem_probe(struct device *dev)\n{\n\tstruct range range;\n\tint rc, id, region_id;\n\tresource_size_t offset;\n\tstruct nd_pfn_sb *pfn_sb;\n\tstruct dev_dax_data data;\n\tstruct nd_namespace_io *nsio;\n\tstruct dax_region *dax_region;\n\tstruct dev_pagemap pgmap = { };\n\tstruct nd_namespace_common *ndns;\n\tstruct nd_dax *nd_dax = to_nd_dax(dev);\n\tstruct nd_pfn *nd_pfn = &nd_dax->nd_pfn;\n\tstruct nd_region *nd_region = to_nd_region(dev->parent);\n\n\tndns = nvdimm_namespace_common_probe(dev);\n\tif (IS_ERR(ndns))\n\t\treturn ERR_CAST(ndns);\n\n\t \n\trc = devm_namespace_enable(dev, ndns, nd_info_block_reserve());\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\trc = nvdimm_setup_pfn(nd_pfn, &pgmap);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\tdevm_namespace_disable(dev, ndns);\n\n\t \n\tpfn_sb = nd_pfn->pfn_sb;\n\toffset = le64_to_cpu(pfn_sb->dataoff);\n\tnsio = to_nd_namespace_io(&ndns->dev);\n\tif (!devm_request_mem_region(dev, nsio->res.start, offset,\n\t\t\t\tdev_name(&ndns->dev))) {\n\t\tdev_warn(dev, \"could not reserve metadata\\n\");\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\trc = sscanf(dev_name(&ndns->dev), \"namespace%d.%d\", &region_id, &id);\n\tif (rc != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\trange = pgmap.range;\n\trange.start += offset;\n\tdax_region = alloc_dax_region(dev, region_id, &range,\n\t\t\tnd_region->target_node, le32_to_cpu(pfn_sb->align),\n\t\t\tIORESOURCE_DAX_STATIC);\n\tif (!dax_region)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = (struct dev_dax_data) {\n\t\t.dax_region = dax_region,\n\t\t.id = id,\n\t\t.pgmap = &pgmap,\n\t\t.size = range_len(&range),\n\t};\n\n\treturn devm_create_dev_dax(&data);\n}\n\nstatic int dax_pmem_probe(struct device *dev)\n{\n\treturn PTR_ERR_OR_ZERO(__dax_pmem_probe(dev));\n}\n\nstatic struct nd_device_driver dax_pmem_driver = {\n\t.probe = dax_pmem_probe,\n\t.drv = {\n\t\t.name = \"dax_pmem\",\n\t},\n\t.type = ND_DRIVER_DAX_PMEM,\n};\n\nstatic int __init dax_pmem_init(void)\n{\n\treturn nd_driver_register(&dax_pmem_driver);\n}\nmodule_init(dax_pmem_init);\n\nstatic void __exit dax_pmem_exit(void)\n{\n\tdriver_unregister(&dax_pmem_driver.drv);\n}\nmodule_exit(dax_pmem_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_ALIAS_ND_DEVICE(ND_DEVICE_DAX_PMEM);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}