{
  "module_name": "hmem.c",
  "hash_id": "d94647c4b964f595c20dc6f53b077f738c55996a6d1ecb3d2594b806aba81bce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dax/hmem/hmem.c",
  "human_readable_source": "\n#include <linux/platform_device.h>\n#include <linux/memregion.h>\n#include <linux/module.h>\n#include <linux/pfn_t.h>\n#include <linux/dax.h>\n#include \"../bus.h\"\n\nstatic bool region_idle;\nmodule_param_named(region_idle, region_idle, bool, 0644);\n\nstatic int dax_hmem_probe(struct platform_device *pdev)\n{\n\tunsigned long flags = IORESOURCE_DAX_KMEM;\n\tstruct device *dev = &pdev->dev;\n\tstruct dax_region *dax_region;\n\tstruct memregion_info *mri;\n\tstruct dev_dax_data data;\n\n\t \n\tif (region_idle)\n\t\tflags = 0;\n\n\tmri = dev->platform_data;\n\tdax_region = alloc_dax_region(dev, pdev->id, &mri->range,\n\t\t\t\t      mri->target_node, PMD_SIZE, flags);\n\tif (!dax_region)\n\t\treturn -ENOMEM;\n\n\tdata = (struct dev_dax_data) {\n\t\t.dax_region = dax_region,\n\t\t.id = -1,\n\t\t.size = region_idle ? 0 : range_len(&mri->range),\n\t};\n\n\treturn PTR_ERR_OR_ZERO(devm_create_dev_dax(&data));\n}\n\nstatic struct platform_driver dax_hmem_driver = {\n\t.probe = dax_hmem_probe,\n\t.driver = {\n\t\t.name = \"hmem\",\n\t},\n};\n\nstatic void release_memregion(void *data)\n{\n\tmemregion_free((long) data);\n}\n\nstatic void release_hmem(void *pdev)\n{\n\tplatform_device_unregister(pdev);\n}\n\nstatic int hmem_register_device(struct device *host, int target_nid,\n\t\t\t\tconst struct resource *res)\n{\n\tstruct platform_device *pdev;\n\tstruct memregion_info info;\n\tlong id;\n\tint rc;\n\n\tif (IS_ENABLED(CONFIG_CXL_REGION) &&\n\t    region_intersects(res->start, resource_size(res), IORESOURCE_MEM,\n\t\t\t      IORES_DESC_CXL) != REGION_DISJOINT) {\n\t\tdev_dbg(host, \"deferring range to CXL: %pr\\n\", res);\n\t\treturn 0;\n\t}\n\n\trc = region_intersects(res->start, resource_size(res), IORESOURCE_MEM,\n\t\t\t       IORES_DESC_SOFT_RESERVED);\n\tif (rc != REGION_INTERSECTS)\n\t\treturn 0;\n\n\tid = memregion_alloc(GFP_KERNEL);\n\tif (id < 0) {\n\t\tdev_err(host, \"memregion allocation failure for %pr\\n\", res);\n\t\treturn -ENOMEM;\n\t}\n\trc = devm_add_action_or_reset(host, release_memregion, (void *) id);\n\tif (rc)\n\t\treturn rc;\n\n\tpdev = platform_device_alloc(\"hmem\", id);\n\tif (!pdev) {\n\t\tdev_err(host, \"device allocation failure for %pr\\n\", res);\n\t\treturn -ENOMEM;\n\t}\n\n\tpdev->dev.numa_node = numa_map_to_online_node(target_nid);\n\tinfo = (struct memregion_info) {\n\t\t.target_node = target_nid,\n\t\t.range = {\n\t\t\t.start = res->start,\n\t\t\t.end = res->end,\n\t\t},\n\t};\n\trc = platform_device_add_data(pdev, &info, sizeof(info));\n\tif (rc < 0) {\n\t\tdev_err(host, \"memregion_info allocation failure for %pr\\n\",\n\t\t       res);\n\t\tgoto out_put;\n\t}\n\n\trc = platform_device_add(pdev);\n\tif (rc < 0) {\n\t\tdev_err(host, \"%s add failed for %pr\\n\", dev_name(&pdev->dev),\n\t\t\tres);\n\t\tgoto out_put;\n\t}\n\n\treturn devm_add_action_or_reset(host, release_hmem, pdev);\n\nout_put:\n\tplatform_device_put(pdev);\n\treturn rc;\n}\n\nstatic int dax_hmem_platform_probe(struct platform_device *pdev)\n{\n\treturn walk_hmem_resources(&pdev->dev, hmem_register_device);\n}\n\nstatic struct platform_driver dax_hmem_platform_driver = {\n\t.probe = dax_hmem_platform_probe,\n\t.driver = {\n\t\t.name = \"hmem_platform\",\n\t},\n};\n\nstatic __init int dax_hmem_init(void)\n{\n\tint rc;\n\n\trc = platform_driver_register(&dax_hmem_platform_driver);\n\tif (rc)\n\t\treturn rc;\n\n\trc = platform_driver_register(&dax_hmem_driver);\n\tif (rc)\n\t\tplatform_driver_unregister(&dax_hmem_platform_driver);\n\n\treturn rc;\n}\n\nstatic __exit void dax_hmem_exit(void)\n{\n\tplatform_driver_unregister(&dax_hmem_driver);\n\tplatform_driver_unregister(&dax_hmem_platform_driver);\n}\n\nmodule_init(dax_hmem_init);\nmodule_exit(dax_hmem_exit);\n\n \n#if IS_ENABLED(CONFIG_CXL_REGION)\n#if IS_MODULE(CONFIG_CXL_ACPI)\nMODULE_SOFTDEP(\"pre: cxl_acpi\");\n#endif\n#endif\n\nMODULE_ALIAS(\"platform:hmem*\");\nMODULE_ALIAS(\"platform:hmem_platform*\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Intel Corporation\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}