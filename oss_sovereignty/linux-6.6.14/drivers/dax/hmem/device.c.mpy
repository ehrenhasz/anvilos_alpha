{
  "module_name": "device.c",
  "hash_id": "b441790e412ae17b2cc667d67b034ed2fdd6273849aca882d9d583ad765b1ddb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dax/hmem/device.c",
  "human_readable_source": "\n#include <linux/platform_device.h>\n#include <linux/memregion.h>\n#include <linux/module.h>\n#include <linux/dax.h>\n#include <linux/mm.h>\n\nstatic bool nohmem;\nmodule_param_named(disable, nohmem, bool, 0444);\n\nstatic bool platform_initialized;\nstatic DEFINE_MUTEX(hmem_resource_lock);\nstatic struct resource hmem_active = {\n\t.name = \"HMEM devices\",\n\t.start = 0,\n\t.end = -1,\n\t.flags = IORESOURCE_MEM,\n};\n\nint walk_hmem_resources(struct device *host, walk_hmem_fn fn)\n{\n\tstruct resource *res;\n\tint rc = 0;\n\n\tmutex_lock(&hmem_resource_lock);\n\tfor (res = hmem_active.child; res; res = res->sibling) {\n\t\trc = fn(host, (int) res->desc, res);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&hmem_resource_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(walk_hmem_resources);\n\nstatic void __hmem_register_resource(int target_nid, struct resource *res)\n{\n\tstruct platform_device *pdev;\n\tstruct resource *new;\n\tint rc;\n\n\tnew = __request_region(&hmem_active, res->start, resource_size(res), \"\",\n\t\t\t       0);\n\tif (!new) {\n\t\tpr_debug(\"hmem range %pr already active\\n\", res);\n\t\treturn;\n\t}\n\n\tnew->desc = target_nid;\n\n\tif (platform_initialized)\n\t\treturn;\n\n\tpdev = platform_device_alloc(\"hmem_platform\", 0);\n\tif (!pdev) {\n\t\tpr_err_once(\"failed to register device-dax hmem_platform device\\n\");\n\t\treturn;\n\t}\n\n\trc = platform_device_add(pdev);\n\tif (rc)\n\t\tplatform_device_put(pdev);\n\telse\n\t\tplatform_initialized = true;\n}\n\nvoid hmem_register_resource(int target_nid, struct resource *res)\n{\n\tif (nohmem)\n\t\treturn;\n\n\tmutex_lock(&hmem_resource_lock);\n\t__hmem_register_resource(target_nid, res);\n\tmutex_unlock(&hmem_resource_lock);\n}\n\nstatic __init int hmem_register_one(struct resource *res, void *data)\n{\n\thmem_register_resource(phys_to_target_node(res->start), res);\n\n\treturn 0;\n}\n\nstatic __init int hmem_init(void)\n{\n\twalk_iomem_res_desc(IORES_DESC_SOFT_RESERVED,\n\t\t\tIORESOURCE_MEM, 0, -1, NULL, hmem_register_one);\n\treturn 0;\n}\n\n \ndevice_initcall(hmem_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}