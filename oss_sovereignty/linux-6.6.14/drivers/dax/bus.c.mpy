{
  "module_name": "bus.c",
  "hash_id": "7d5a8ddf0dff4a134243c95732607b5fdd35e484fc41b0b03c1bd36b143756dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dax/bus.c",
  "human_readable_source": "\n \n#include <linux/memremap.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/dax.h>\n#include <linux/io.h>\n#include \"dax-private.h\"\n#include \"bus.h\"\n\nstatic DEFINE_MUTEX(dax_bus_lock);\n\n#define DAX_NAME_LEN 30\nstruct dax_id {\n\tstruct list_head list;\n\tchar dev_name[DAX_NAME_LEN];\n};\n\nstatic int dax_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\t \n\treturn add_uevent_var(env, \"MODALIAS=\" DAX_DEVICE_MODALIAS_FMT, 0);\n}\n\nstatic struct dax_device_driver *to_dax_drv(struct device_driver *drv)\n{\n\treturn container_of(drv, struct dax_device_driver, drv);\n}\n\nstatic struct dax_id *__dax_match_id(struct dax_device_driver *dax_drv,\n\t\tconst char *dev_name)\n{\n\tstruct dax_id *dax_id;\n\n\tlockdep_assert_held(&dax_bus_lock);\n\n\tlist_for_each_entry(dax_id, &dax_drv->ids, list)\n\t\tif (sysfs_streq(dax_id->dev_name, dev_name))\n\t\t\treturn dax_id;\n\treturn NULL;\n}\n\nstatic int dax_match_id(struct dax_device_driver *dax_drv, struct device *dev)\n{\n\tint match;\n\n\tmutex_lock(&dax_bus_lock);\n\tmatch = !!__dax_match_id(dax_drv, dev_name(dev));\n\tmutex_unlock(&dax_bus_lock);\n\n\treturn match;\n}\n\nstatic int dax_match_type(struct dax_device_driver *dax_drv, struct device *dev)\n{\n\tenum dax_driver_type type = DAXDRV_DEVICE_TYPE;\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\n\tif (dev_dax->region->res.flags & IORESOURCE_DAX_KMEM)\n\t\ttype = DAXDRV_KMEM_TYPE;\n\n\tif (dax_drv->type == type)\n\t\treturn 1;\n\n\t \n\tif (dax_drv->type == DAXDRV_DEVICE_TYPE &&\n\t    !IS_ENABLED(CONFIG_DEV_DAX_KMEM))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nenum id_action {\n\tID_REMOVE,\n\tID_ADD,\n};\n\nstatic ssize_t do_id_store(struct device_driver *drv, const char *buf,\n\t\tsize_t count, enum id_action action)\n{\n\tstruct dax_device_driver *dax_drv = to_dax_drv(drv);\n\tunsigned int region_id, id;\n\tchar devname[DAX_NAME_LEN];\n\tstruct dax_id *dax_id;\n\tssize_t rc = count;\n\tint fields;\n\n\tfields = sscanf(buf, \"dax%d.%d\", &region_id, &id);\n\tif (fields != 2)\n\t\treturn -EINVAL;\n\tsprintf(devname, \"dax%d.%d\", region_id, id);\n\tif (!sysfs_streq(buf, devname))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dax_bus_lock);\n\tdax_id = __dax_match_id(dax_drv, buf);\n\tif (!dax_id) {\n\t\tif (action == ID_ADD) {\n\t\t\tdax_id = kzalloc(sizeof(*dax_id), GFP_KERNEL);\n\t\t\tif (dax_id) {\n\t\t\t\tstrncpy(dax_id->dev_name, buf, DAX_NAME_LEN);\n\t\t\t\tlist_add(&dax_id->list, &dax_drv->ids);\n\t\t\t} else\n\t\t\t\trc = -ENOMEM;\n\t\t}\n\t} else if (action == ID_REMOVE) {\n\t\tlist_del(&dax_id->list);\n\t\tkfree(dax_id);\n\t}\n\tmutex_unlock(&dax_bus_lock);\n\n\tif (rc < 0)\n\t\treturn rc;\n\tif (action == ID_ADD)\n\t\trc = driver_attach(drv);\n\tif (rc)\n\t\treturn rc;\n\treturn count;\n}\n\nstatic ssize_t new_id_store(struct device_driver *drv, const char *buf,\n\t\tsize_t count)\n{\n\treturn do_id_store(drv, buf, count, ID_ADD);\n}\nstatic DRIVER_ATTR_WO(new_id);\n\nstatic ssize_t remove_id_store(struct device_driver *drv, const char *buf,\n\t\tsize_t count)\n{\n\treturn do_id_store(drv, buf, count, ID_REMOVE);\n}\nstatic DRIVER_ATTR_WO(remove_id);\n\nstatic struct attribute *dax_drv_attrs[] = {\n\t&driver_attr_new_id.attr,\n\t&driver_attr_remove_id.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(dax_drv);\n\nstatic int dax_bus_match(struct device *dev, struct device_driver *drv);\n\n \nstatic bool is_static(struct dax_region *dax_region)\n{\n\treturn (dax_region->res.flags & IORESOURCE_DAX_STATIC) != 0;\n}\n\nbool static_dev_dax(struct dev_dax *dev_dax)\n{\n\treturn is_static(dev_dax->region);\n}\nEXPORT_SYMBOL_GPL(static_dev_dax);\n\nstatic u64 dev_dax_size(struct dev_dax *dev_dax)\n{\n\tu64 size = 0;\n\tint i;\n\n\tdevice_lock_assert(&dev_dax->dev);\n\n\tfor (i = 0; i < dev_dax->nr_range; i++)\n\t\tsize += range_len(&dev_dax->ranges[i].range);\n\n\treturn size;\n}\n\nstatic int dax_bus_probe(struct device *dev)\n{\n\tstruct dax_device_driver *dax_drv = to_dax_drv(dev->driver);\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\tstruct dax_region *dax_region = dev_dax->region;\n\tint rc;\n\n\tif (dev_dax_size(dev_dax) == 0 || dev_dax->id < 0)\n\t\treturn -ENXIO;\n\n\trc = dax_drv->probe(dev_dax);\n\n\tif (rc || is_static(dax_region))\n\t\treturn rc;\n\n\t \n\tif (dax_region->seed == dev)\n\t\tdax_region->seed = NULL;\n\n\treturn 0;\n}\n\nstatic void dax_bus_remove(struct device *dev)\n{\n\tstruct dax_device_driver *dax_drv = to_dax_drv(dev->driver);\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\n\tif (dax_drv->remove)\n\t\tdax_drv->remove(dev_dax);\n}\n\nstatic struct bus_type dax_bus_type = {\n\t.name = \"dax\",\n\t.uevent = dax_bus_uevent,\n\t.match = dax_bus_match,\n\t.probe = dax_bus_probe,\n\t.remove = dax_bus_remove,\n\t.drv_groups = dax_drv_groups,\n};\n\nstatic int dax_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct dax_device_driver *dax_drv = to_dax_drv(drv);\n\n\tif (dax_match_id(dax_drv, dev))\n\t\treturn 1;\n\treturn dax_match_type(dax_drv, dev);\n}\n\n \nstatic ssize_t id_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dax_region *dax_region = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", dax_region->id);\n}\nstatic DEVICE_ATTR_RO(id);\n\nstatic ssize_t region_size_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dax_region *dax_region = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%llu\\n\", (unsigned long long)\n\t\t\tresource_size(&dax_region->res));\n}\nstatic struct device_attribute dev_attr_region_size = __ATTR(size, 0444,\n\t\tregion_size_show, NULL);\n\nstatic ssize_t region_align_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dax_region *dax_region = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", dax_region->align);\n}\nstatic struct device_attribute dev_attr_region_align =\n\t\t__ATTR(align, 0400, region_align_show, NULL);\n\n#define for_each_dax_region_resource(dax_region, res) \\\n\tfor (res = (dax_region)->res.child; res; res = res->sibling)\n\nstatic unsigned long long dax_region_avail_size(struct dax_region *dax_region)\n{\n\tresource_size_t size = resource_size(&dax_region->res);\n\tstruct resource *res;\n\n\tdevice_lock_assert(dax_region->dev);\n\n\tfor_each_dax_region_resource(dax_region, res)\n\t\tsize -= resource_size(res);\n\treturn size;\n}\n\nstatic ssize_t available_size_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dax_region *dax_region = dev_get_drvdata(dev);\n\tunsigned long long size;\n\n\tdevice_lock(dev);\n\tsize = dax_region_avail_size(dax_region);\n\tdevice_unlock(dev);\n\n\treturn sprintf(buf, \"%llu\\n\", size);\n}\nstatic DEVICE_ATTR_RO(available_size);\n\nstatic ssize_t seed_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dax_region *dax_region = dev_get_drvdata(dev);\n\tstruct device *seed;\n\tssize_t rc;\n\n\tif (is_static(dax_region))\n\t\treturn -EINVAL;\n\n\tdevice_lock(dev);\n\tseed = dax_region->seed;\n\trc = sprintf(buf, \"%s\\n\", seed ? dev_name(seed) : \"\");\n\tdevice_unlock(dev);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(seed);\n\nstatic ssize_t create_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dax_region *dax_region = dev_get_drvdata(dev);\n\tstruct device *youngest;\n\tssize_t rc;\n\n\tif (is_static(dax_region))\n\t\treturn -EINVAL;\n\n\tdevice_lock(dev);\n\tyoungest = dax_region->youngest;\n\trc = sprintf(buf, \"%s\\n\", youngest ? dev_name(youngest) : \"\");\n\tdevice_unlock(dev);\n\n\treturn rc;\n}\n\nstatic ssize_t create_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t len)\n{\n\tstruct dax_region *dax_region = dev_get_drvdata(dev);\n\tunsigned long long avail;\n\tssize_t rc;\n\tint val;\n\n\tif (is_static(dax_region))\n\t\treturn -EINVAL;\n\n\trc = kstrtoint(buf, 0, &val);\n\tif (rc)\n\t\treturn rc;\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tdevice_lock(dev);\n\tavail = dax_region_avail_size(dax_region);\n\tif (avail == 0)\n\t\trc = -ENOSPC;\n\telse {\n\t\tstruct dev_dax_data data = {\n\t\t\t.dax_region = dax_region,\n\t\t\t.size = 0,\n\t\t\t.id = -1,\n\t\t};\n\t\tstruct dev_dax *dev_dax = devm_create_dev_dax(&data);\n\n\t\tif (IS_ERR(dev_dax))\n\t\t\trc = PTR_ERR(dev_dax);\n\t\telse {\n\t\t\t \n\t\t\tif (!dax_region->seed)\n\t\t\t\tdax_region->seed = &dev_dax->dev;\n\t\t\tdax_region->youngest = &dev_dax->dev;\n\t\t\trc = len;\n\t\t}\n\t}\n\tdevice_unlock(dev);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RW(create);\n\nvoid kill_dev_dax(struct dev_dax *dev_dax)\n{\n\tstruct dax_device *dax_dev = dev_dax->dax_dev;\n\tstruct inode *inode = dax_inode(dax_dev);\n\n\tkill_dax(dax_dev);\n\tunmap_mapping_range(inode->i_mapping, 0, 0, 1);\n\n\t \n\tif (!static_dev_dax(dev_dax))\n\t\tdev_dax->pgmap = NULL;\n}\nEXPORT_SYMBOL_GPL(kill_dev_dax);\n\nstatic void trim_dev_dax_range(struct dev_dax *dev_dax)\n{\n\tint i = dev_dax->nr_range - 1;\n\tstruct range *range = &dev_dax->ranges[i].range;\n\tstruct dax_region *dax_region = dev_dax->region;\n\n\tdevice_lock_assert(dax_region->dev);\n\tdev_dbg(&dev_dax->dev, \"delete range[%d]: %#llx:%#llx\\n\", i,\n\t\t(unsigned long long)range->start,\n\t\t(unsigned long long)range->end);\n\n\t__release_region(&dax_region->res, range->start, range_len(range));\n\tif (--dev_dax->nr_range == 0) {\n\t\tkfree(dev_dax->ranges);\n\t\tdev_dax->ranges = NULL;\n\t}\n}\n\nstatic void free_dev_dax_ranges(struct dev_dax *dev_dax)\n{\n\twhile (dev_dax->nr_range)\n\t\ttrim_dev_dax_range(dev_dax);\n}\n\nstatic void unregister_dev_dax(void *dev)\n{\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tkill_dev_dax(dev_dax);\n\tdevice_del(dev);\n\tfree_dev_dax_ranges(dev_dax);\n\tput_device(dev);\n}\n\nstatic void dax_region_free(struct kref *kref)\n{\n\tstruct dax_region *dax_region;\n\n\tdax_region = container_of(kref, struct dax_region, kref);\n\tkfree(dax_region);\n}\n\nstatic void dax_region_put(struct dax_region *dax_region)\n{\n\tkref_put(&dax_region->kref, dax_region_free);\n}\n\n \nstatic int __free_dev_dax_id(struct dev_dax *dev_dax)\n{\n\tstruct device *dev = &dev_dax->dev;\n\tstruct dax_region *dax_region;\n\tint rc = dev_dax->id;\n\n\tdevice_lock_assert(dev);\n\n\tif (!dev_dax->dyn_id || dev_dax->id < 0)\n\t\treturn -1;\n\tdax_region = dev_dax->region;\n\tida_free(&dax_region->ida, dev_dax->id);\n\tdax_region_put(dax_region);\n\tdev_dax->id = -1;\n\treturn rc;\n}\n\nstatic int free_dev_dax_id(struct dev_dax *dev_dax)\n{\n\tstruct device *dev = &dev_dax->dev;\n\tint rc;\n\n\tdevice_lock(dev);\n\trc = __free_dev_dax_id(dev_dax);\n\tdevice_unlock(dev);\n\treturn rc;\n}\n\nstatic int alloc_dev_dax_id(struct dev_dax *dev_dax)\n{\n\tstruct dax_region *dax_region = dev_dax->region;\n\tint id;\n\n\tid = ida_alloc(&dax_region->ida, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\tkref_get(&dax_region->kref);\n\tdev_dax->dyn_id = true;\n\tdev_dax->id = id;\n\treturn id;\n}\n\nstatic ssize_t delete_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t len)\n{\n\tstruct dax_region *dax_region = dev_get_drvdata(dev);\n\tstruct dev_dax *dev_dax;\n\tstruct device *victim;\n\tbool do_del = false;\n\tint rc;\n\n\tif (is_static(dax_region))\n\t\treturn -EINVAL;\n\n\tvictim = device_find_child_by_name(dax_region->dev, buf);\n\tif (!victim)\n\t\treturn -ENXIO;\n\n\tdevice_lock(dev);\n\tdevice_lock(victim);\n\tdev_dax = to_dev_dax(victim);\n\tif (victim->driver || dev_dax_size(dev_dax))\n\t\trc = -EBUSY;\n\telse {\n\t\t \n\t\tif (dev_dax->id > 0) {\n\t\t\tdo_del = __free_dev_dax_id(dev_dax) >= 0;\n\t\t\trc = len;\n\t\t\tif (dax_region->seed == victim)\n\t\t\t\tdax_region->seed = NULL;\n\t\t\tif (dax_region->youngest == victim)\n\t\t\t\tdax_region->youngest = NULL;\n\t\t} else\n\t\t\trc = -EBUSY;\n\t}\n\tdevice_unlock(victim);\n\n\t \n\tif (do_del)\n\t\tdevm_release_action(dev, unregister_dev_dax, victim);\n\tdevice_unlock(dev);\n\tput_device(victim);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_WO(delete);\n\nstatic umode_t dax_region_visible(struct kobject *kobj, struct attribute *a,\n\t\tint n)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct dax_region *dax_region = dev_get_drvdata(dev);\n\n\tif (is_static(dax_region))\n\t\tif (a == &dev_attr_available_size.attr\n\t\t\t\t|| a == &dev_attr_create.attr\n\t\t\t\t|| a == &dev_attr_seed.attr\n\t\t\t\t|| a == &dev_attr_delete.attr)\n\t\t\treturn 0;\n\treturn a->mode;\n}\n\nstatic struct attribute *dax_region_attributes[] = {\n\t&dev_attr_available_size.attr,\n\t&dev_attr_region_size.attr,\n\t&dev_attr_region_align.attr,\n\t&dev_attr_create.attr,\n\t&dev_attr_seed.attr,\n\t&dev_attr_delete.attr,\n\t&dev_attr_id.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group dax_region_attribute_group = {\n\t.name = \"dax_region\",\n\t.attrs = dax_region_attributes,\n\t.is_visible = dax_region_visible,\n};\n\nstatic const struct attribute_group *dax_region_attribute_groups[] = {\n\t&dax_region_attribute_group,\n\tNULL,\n};\n\nstatic void dax_region_unregister(void *region)\n{\n\tstruct dax_region *dax_region = region;\n\n\tsysfs_remove_groups(&dax_region->dev->kobj,\n\t\t\tdax_region_attribute_groups);\n\tdax_region_put(dax_region);\n}\n\nstruct dax_region *alloc_dax_region(struct device *parent, int region_id,\n\t\tstruct range *range, int target_node, unsigned int align,\n\t\tunsigned long flags)\n{\n\tstruct dax_region *dax_region;\n\n\t \n\tif (dev_get_drvdata(parent)) {\n\t\tdev_WARN(parent, \"dax core failed to setup private data\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!IS_ALIGNED(range->start, align)\n\t\t\t|| !IS_ALIGNED(range_len(range), align))\n\t\treturn NULL;\n\n\tdax_region = kzalloc(sizeof(*dax_region), GFP_KERNEL);\n\tif (!dax_region)\n\t\treturn NULL;\n\n\tdev_set_drvdata(parent, dax_region);\n\tkref_init(&dax_region->kref);\n\tdax_region->id = region_id;\n\tdax_region->align = align;\n\tdax_region->dev = parent;\n\tdax_region->target_node = target_node;\n\tida_init(&dax_region->ida);\n\tdax_region->res = (struct resource) {\n\t\t.start = range->start,\n\t\t.end = range->end,\n\t\t.flags = IORESOURCE_MEM | flags,\n\t};\n\n\tif (sysfs_create_groups(&parent->kobj, dax_region_attribute_groups)) {\n\t\tkfree(dax_region);\n\t\treturn NULL;\n\t}\n\n\tif (devm_add_action_or_reset(parent, dax_region_unregister, dax_region))\n\t\treturn NULL;\n\treturn dax_region;\n}\nEXPORT_SYMBOL_GPL(alloc_dax_region);\n\nstatic void dax_mapping_release(struct device *dev)\n{\n\tstruct dax_mapping *mapping = to_dax_mapping(dev);\n\tstruct device *parent = dev->parent;\n\tstruct dev_dax *dev_dax = to_dev_dax(parent);\n\n\tida_free(&dev_dax->ida, mapping->id);\n\tkfree(mapping);\n\tput_device(parent);\n}\n\nstatic void unregister_dax_mapping(void *data)\n{\n\tstruct device *dev = data;\n\tstruct dax_mapping *mapping = to_dax_mapping(dev);\n\tstruct dev_dax *dev_dax = to_dev_dax(dev->parent);\n\tstruct dax_region *dax_region = dev_dax->region;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tdevice_lock_assert(dax_region->dev);\n\n\tdev_dax->ranges[mapping->range_id].mapping = NULL;\n\tmapping->range_id = -1;\n\n\tdevice_unregister(dev);\n}\n\nstatic struct dev_dax_range *get_dax_range(struct device *dev)\n{\n\tstruct dax_mapping *mapping = to_dax_mapping(dev);\n\tstruct dev_dax *dev_dax = to_dev_dax(dev->parent);\n\tstruct dax_region *dax_region = dev_dax->region;\n\n\tdevice_lock(dax_region->dev);\n\tif (mapping->range_id < 0) {\n\t\tdevice_unlock(dax_region->dev);\n\t\treturn NULL;\n\t}\n\n\treturn &dev_dax->ranges[mapping->range_id];\n}\n\nstatic void put_dax_range(struct dev_dax_range *dax_range)\n{\n\tstruct dax_mapping *mapping = dax_range->mapping;\n\tstruct dev_dax *dev_dax = to_dev_dax(mapping->dev.parent);\n\tstruct dax_region *dax_region = dev_dax->region;\n\n\tdevice_unlock(dax_region->dev);\n}\n\nstatic ssize_t start_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dev_dax_range *dax_range;\n\tssize_t rc;\n\n\tdax_range = get_dax_range(dev);\n\tif (!dax_range)\n\t\treturn -ENXIO;\n\trc = sprintf(buf, \"%#llx\\n\", dax_range->range.start);\n\tput_dax_range(dax_range);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR(start, 0400, start_show, NULL);\n\nstatic ssize_t end_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dev_dax_range *dax_range;\n\tssize_t rc;\n\n\tdax_range = get_dax_range(dev);\n\tif (!dax_range)\n\t\treturn -ENXIO;\n\trc = sprintf(buf, \"%#llx\\n\", dax_range->range.end);\n\tput_dax_range(dax_range);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR(end, 0400, end_show, NULL);\n\nstatic ssize_t pgoff_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dev_dax_range *dax_range;\n\tssize_t rc;\n\n\tdax_range = get_dax_range(dev);\n\tif (!dax_range)\n\t\treturn -ENXIO;\n\trc = sprintf(buf, \"%#lx\\n\", dax_range->pgoff);\n\tput_dax_range(dax_range);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR(page_offset, 0400, pgoff_show, NULL);\n\nstatic struct attribute *dax_mapping_attributes[] = {\n\t&dev_attr_start.attr,\n\t&dev_attr_end.attr,\n\t&dev_attr_page_offset.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group dax_mapping_attribute_group = {\n\t.attrs = dax_mapping_attributes,\n};\n\nstatic const struct attribute_group *dax_mapping_attribute_groups[] = {\n\t&dax_mapping_attribute_group,\n\tNULL,\n};\n\nstatic struct device_type dax_mapping_type = {\n\t.release = dax_mapping_release,\n\t.groups = dax_mapping_attribute_groups,\n};\n\nstatic int devm_register_dax_mapping(struct dev_dax *dev_dax, int range_id)\n{\n\tstruct dax_region *dax_region = dev_dax->region;\n\tstruct dax_mapping *mapping;\n\tstruct device *dev;\n\tint rc;\n\n\tdevice_lock_assert(dax_region->dev);\n\n\tif (dev_WARN_ONCE(&dev_dax->dev, !dax_region->dev->driver,\n\t\t\t\t\"region disabled\\n\"))\n\t\treturn -ENXIO;\n\n\tmapping = kzalloc(sizeof(*mapping), GFP_KERNEL);\n\tif (!mapping)\n\t\treturn -ENOMEM;\n\tmapping->range_id = range_id;\n\tmapping->id = ida_alloc(&dev_dax->ida, GFP_KERNEL);\n\tif (mapping->id < 0) {\n\t\tkfree(mapping);\n\t\treturn -ENOMEM;\n\t}\n\tdev_dax->ranges[range_id].mapping = mapping;\n\tdev = &mapping->dev;\n\tdevice_initialize(dev);\n\tdev->parent = &dev_dax->dev;\n\tget_device(dev->parent);\n\tdev->type = &dax_mapping_type;\n\tdev_set_name(dev, \"mapping%d\", mapping->id);\n\trc = device_add(dev);\n\tif (rc) {\n\t\tput_device(dev);\n\t\treturn rc;\n\t}\n\n\trc = devm_add_action_or_reset(dax_region->dev, unregister_dax_mapping,\n\t\t\tdev);\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}\n\nstatic int alloc_dev_dax_range(struct dev_dax *dev_dax, u64 start,\n\t\tresource_size_t size)\n{\n\tstruct dax_region *dax_region = dev_dax->region;\n\tstruct resource *res = &dax_region->res;\n\tstruct device *dev = &dev_dax->dev;\n\tstruct dev_dax_range *ranges;\n\tunsigned long pgoff = 0;\n\tstruct resource *alloc;\n\tint i, rc;\n\n\tdevice_lock_assert(dax_region->dev);\n\n\t \n\tif (!size) {\n\t\tif (dev_WARN_ONCE(dev, dev_dax->nr_range,\n\t\t\t\t\t\"0-size allocation must be first\\n\"))\n\t\t\treturn -EBUSY;\n\t\t \n\t\treturn 0;\n\t}\n\n\talloc = __request_region(res, start, size, dev_name(dev), 0);\n\tif (!alloc)\n\t\treturn -ENOMEM;\n\n\tranges = krealloc(dev_dax->ranges, sizeof(*ranges)\n\t\t\t* (dev_dax->nr_range + 1), GFP_KERNEL);\n\tif (!ranges) {\n\t\t__release_region(res, alloc->start, resource_size(alloc));\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < dev_dax->nr_range; i++)\n\t\tpgoff += PHYS_PFN(range_len(&ranges[i].range));\n\tdev_dax->ranges = ranges;\n\tranges[dev_dax->nr_range++] = (struct dev_dax_range) {\n\t\t.pgoff = pgoff,\n\t\t.range = {\n\t\t\t.start = alloc->start,\n\t\t\t.end = alloc->end,\n\t\t},\n\t};\n\n\tdev_dbg(dev, \"alloc range[%d]: %pa:%pa\\n\", dev_dax->nr_range - 1,\n\t\t\t&alloc->start, &alloc->end);\n\t \n\tif (!device_is_registered(&dev_dax->dev))\n\t\treturn 0;\n\n\trc = devm_register_dax_mapping(dev_dax, dev_dax->nr_range - 1);\n\tif (rc)\n\t\ttrim_dev_dax_range(dev_dax);\n\n\treturn rc;\n}\n\nstatic int adjust_dev_dax_range(struct dev_dax *dev_dax, struct resource *res, resource_size_t size)\n{\n\tint last_range = dev_dax->nr_range - 1;\n\tstruct dev_dax_range *dax_range = &dev_dax->ranges[last_range];\n\tstruct dax_region *dax_region = dev_dax->region;\n\tbool is_shrink = resource_size(res) > size;\n\tstruct range *range = &dax_range->range;\n\tstruct device *dev = &dev_dax->dev;\n\tint rc;\n\n\tdevice_lock_assert(dax_region->dev);\n\n\tif (dev_WARN_ONCE(dev, !size, \"deletion is handled by dev_dax_shrink\\n\"))\n\t\treturn -EINVAL;\n\n\trc = adjust_resource(res, range->start, size);\n\tif (rc)\n\t\treturn rc;\n\n\t*range = (struct range) {\n\t\t.start = range->start,\n\t\t.end = range->start + size - 1,\n\t};\n\n\tdev_dbg(dev, \"%s range[%d]: %#llx:%#llx\\n\", is_shrink ? \"shrink\" : \"extend\",\n\t\t\tlast_range, (unsigned long long) range->start,\n\t\t\t(unsigned long long) range->end);\n\n\treturn 0;\n}\n\nstatic ssize_t size_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\tunsigned long long size;\n\n\tdevice_lock(dev);\n\tsize = dev_dax_size(dev_dax);\n\tdevice_unlock(dev);\n\n\treturn sprintf(buf, \"%llu\\n\", size);\n}\n\nstatic bool alloc_is_aligned(struct dev_dax *dev_dax, resource_size_t size)\n{\n\t \n\treturn IS_ALIGNED(size, max_t(unsigned long, dev_dax->align, memremap_compat_align()));\n}\n\nstatic int dev_dax_shrink(struct dev_dax *dev_dax, resource_size_t size)\n{\n\tresource_size_t to_shrink = dev_dax_size(dev_dax) - size;\n\tstruct dax_region *dax_region = dev_dax->region;\n\tstruct device *dev = &dev_dax->dev;\n\tint i;\n\n\tfor (i = dev_dax->nr_range - 1; i >= 0; i--) {\n\t\tstruct range *range = &dev_dax->ranges[i].range;\n\t\tstruct dax_mapping *mapping = dev_dax->ranges[i].mapping;\n\t\tstruct resource *adjust = NULL, *res;\n\t\tresource_size_t shrink;\n\n\t\tshrink = min_t(u64, to_shrink, range_len(range));\n\t\tif (shrink >= range_len(range)) {\n\t\t\tdevm_release_action(dax_region->dev,\n\t\t\t\t\tunregister_dax_mapping, &mapping->dev);\n\t\t\ttrim_dev_dax_range(dev_dax);\n\t\t\tto_shrink -= shrink;\n\t\t\tif (!to_shrink)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_dax_region_resource(dax_region, res)\n\t\t\tif (strcmp(res->name, dev_name(dev)) == 0\n\t\t\t\t\t&& res->start == range->start) {\n\t\t\t\tadjust = res;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (dev_WARN_ONCE(dev, !adjust || i != dev_dax->nr_range - 1,\n\t\t\t\t\t\"failed to find matching resource\\n\"))\n\t\t\treturn -ENXIO;\n\t\treturn adjust_dev_dax_range(dev_dax, adjust, range_len(range)\n\t\t\t\t- shrink);\n\t}\n\treturn 0;\n}\n\n \nstatic bool adjust_ok(struct dev_dax *dev_dax, struct resource *res)\n{\n\tstruct dev_dax_range *last;\n\tint i;\n\n\tif (dev_dax->nr_range == 0)\n\t\treturn false;\n\tif (strcmp(res->name, dev_name(&dev_dax->dev)) != 0)\n\t\treturn false;\n\tlast = &dev_dax->ranges[dev_dax->nr_range - 1];\n\tif (last->range.start != res->start || last->range.end != res->end)\n\t\treturn false;\n\tfor (i = 0; i < dev_dax->nr_range - 1; i++) {\n\t\tstruct dev_dax_range *dax_range = &dev_dax->ranges[i];\n\n\t\tif (dax_range->pgoff > last->pgoff)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic ssize_t dev_dax_resize(struct dax_region *dax_region,\n\t\tstruct dev_dax *dev_dax, resource_size_t size)\n{\n\tresource_size_t avail = dax_region_avail_size(dax_region), to_alloc;\n\tresource_size_t dev_size = dev_dax_size(dev_dax);\n\tstruct resource *region_res = &dax_region->res;\n\tstruct device *dev = &dev_dax->dev;\n\tstruct resource *res, *first;\n\tresource_size_t alloc = 0;\n\tint rc;\n\n\tif (dev->driver)\n\t\treturn -EBUSY;\n\tif (size == dev_size)\n\t\treturn 0;\n\tif (size > dev_size && size - dev_size > avail)\n\t\treturn -ENOSPC;\n\tif (size < dev_size)\n\t\treturn dev_dax_shrink(dev_dax, size);\n\n\tto_alloc = size - dev_size;\n\tif (dev_WARN_ONCE(dev, !alloc_is_aligned(dev_dax, to_alloc),\n\t\t\t\"resize of %pa misaligned\\n\", &to_alloc))\n\t\treturn -ENXIO;\n\n\t \nretry:\n\tfirst = region_res->child;\n\tif (!first)\n\t\treturn alloc_dev_dax_range(dev_dax, dax_region->res.start, to_alloc);\n\n\trc = -ENOSPC;\n\tfor (res = first; res; res = res->sibling) {\n\t\tstruct resource *next = res->sibling;\n\n\t\t \n\t\tif (res == first && res->start > dax_region->res.start) {\n\t\t\talloc = min(res->start - dax_region->res.start, to_alloc);\n\t\t\trc = alloc_dev_dax_range(dev_dax, dax_region->res.start, alloc);\n\t\t\tbreak;\n\t\t}\n\n\t\talloc = 0;\n\t\t \n\t\tif (next && next->start > res->end + 1)\n\t\t\talloc = min(next->start - (res->end + 1), to_alloc);\n\n\t\t \n\t\tif (!alloc && !next && res->end < region_res->end)\n\t\t\talloc = min(region_res->end - res->end, to_alloc);\n\n\t\tif (!alloc)\n\t\t\tcontinue;\n\n\t\tif (adjust_ok(dev_dax, res)) {\n\t\t\trc = adjust_dev_dax_range(dev_dax, res, resource_size(res) + alloc);\n\t\t\tbreak;\n\t\t}\n\t\trc = alloc_dev_dax_range(dev_dax, res->end + 1, alloc);\n\t\tbreak;\n\t}\n\tif (rc)\n\t\treturn rc;\n\tto_alloc -= alloc;\n\tif (to_alloc)\n\t\tgoto retry;\n\treturn 0;\n}\n\nstatic ssize_t size_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t len)\n{\n\tssize_t rc;\n\tunsigned long long val;\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\tstruct dax_region *dax_region = dev_dax->region;\n\n\trc = kstrtoull(buf, 0, &val);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!alloc_is_aligned(dev_dax, val)) {\n\t\tdev_dbg(dev, \"%s: size: %lld misaligned\\n\", __func__, val);\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_lock(dax_region->dev);\n\tif (!dax_region->dev->driver) {\n\t\tdevice_unlock(dax_region->dev);\n\t\treturn -ENXIO;\n\t}\n\tdevice_lock(dev);\n\trc = dev_dax_resize(dax_region, dev_dax, val);\n\tdevice_unlock(dev);\n\tdevice_unlock(dax_region->dev);\n\n\treturn rc == 0 ? len : rc;\n}\nstatic DEVICE_ATTR_RW(size);\n\nstatic ssize_t range_parse(const char *opt, size_t len, struct range *range)\n{\n\tunsigned long long addr = 0;\n\tchar *start, *end, *str;\n\tssize_t rc = -EINVAL;\n\n\tstr = kstrdup(opt, GFP_KERNEL);\n\tif (!str)\n\t\treturn rc;\n\n\tend = str;\n\tstart = strsep(&end, \"-\");\n\tif (!start || !end)\n\t\tgoto err;\n\n\trc = kstrtoull(start, 16, &addr);\n\tif (rc)\n\t\tgoto err;\n\trange->start = addr;\n\n\trc = kstrtoull(end, 16, &addr);\n\tif (rc)\n\t\tgoto err;\n\trange->end = addr;\n\nerr:\n\tkfree(str);\n\treturn rc;\n}\n\nstatic ssize_t mapping_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t len)\n{\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\tstruct dax_region *dax_region = dev_dax->region;\n\tsize_t to_alloc;\n\tstruct range r;\n\tssize_t rc;\n\n\trc = range_parse(buf, len, &r);\n\tif (rc)\n\t\treturn rc;\n\n\trc = -ENXIO;\n\tdevice_lock(dax_region->dev);\n\tif (!dax_region->dev->driver) {\n\t\tdevice_unlock(dax_region->dev);\n\t\treturn rc;\n\t}\n\tdevice_lock(dev);\n\n\tto_alloc = range_len(&r);\n\tif (alloc_is_aligned(dev_dax, to_alloc))\n\t\trc = alloc_dev_dax_range(dev_dax, r.start, to_alloc);\n\tdevice_unlock(dev);\n\tdevice_unlock(dax_region->dev);\n\n\treturn rc == 0 ? len : rc;\n}\nstatic DEVICE_ATTR_WO(mapping);\n\nstatic ssize_t align_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\n\treturn sprintf(buf, \"%d\\n\", dev_dax->align);\n}\n\nstatic ssize_t dev_dax_validate_align(struct dev_dax *dev_dax)\n{\n\tstruct device *dev = &dev_dax->dev;\n\tint i;\n\n\tfor (i = 0; i < dev_dax->nr_range; i++) {\n\t\tsize_t len = range_len(&dev_dax->ranges[i].range);\n\n\t\tif (!alloc_is_aligned(dev_dax, len)) {\n\t\t\tdev_dbg(dev, \"%s: align %u invalid for range %d\\n\",\n\t\t\t\t__func__, dev_dax->align, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t align_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t len)\n{\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\tstruct dax_region *dax_region = dev_dax->region;\n\tunsigned long val, align_save;\n\tssize_t rc;\n\n\trc = kstrtoul(buf, 0, &val);\n\tif (rc)\n\t\treturn -ENXIO;\n\n\tif (!dax_align_valid(val))\n\t\treturn -EINVAL;\n\n\tdevice_lock(dax_region->dev);\n\tif (!dax_region->dev->driver) {\n\t\tdevice_unlock(dax_region->dev);\n\t\treturn -ENXIO;\n\t}\n\n\tdevice_lock(dev);\n\tif (dev->driver) {\n\t\trc = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\talign_save = dev_dax->align;\n\tdev_dax->align = val;\n\trc = dev_dax_validate_align(dev_dax);\n\tif (rc)\n\t\tdev_dax->align = align_save;\nout_unlock:\n\tdevice_unlock(dev);\n\tdevice_unlock(dax_region->dev);\n\treturn rc == 0 ? len : rc;\n}\nstatic DEVICE_ATTR_RW(align);\n\nstatic int dev_dax_target_node(struct dev_dax *dev_dax)\n{\n\tstruct dax_region *dax_region = dev_dax->region;\n\n\treturn dax_region->target_node;\n}\n\nstatic ssize_t target_node_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\n\treturn sprintf(buf, \"%d\\n\", dev_dax_target_node(dev_dax));\n}\nstatic DEVICE_ATTR_RO(target_node);\n\nstatic ssize_t resource_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\tstruct dax_region *dax_region = dev_dax->region;\n\tunsigned long long start;\n\n\tif (dev_dax->nr_range < 1)\n\t\tstart = dax_region->res.start;\n\telse\n\t\tstart = dev_dax->ranges[0].range.start;\n\n\treturn sprintf(buf, \"%#llx\\n\", start);\n}\nstatic DEVICE_ATTR(resource, 0400, resource_show, NULL);\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\t \n\treturn sprintf(buf, DAX_DEVICE_MODALIAS_FMT \"\\n\", 0);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t numa_node_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", dev_to_node(dev));\n}\nstatic DEVICE_ATTR_RO(numa_node);\n\nstatic umode_t dev_dax_visible(struct kobject *kobj, struct attribute *a, int n)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\tstruct dax_region *dax_region = dev_dax->region;\n\n\tif (a == &dev_attr_target_node.attr && dev_dax_target_node(dev_dax) < 0)\n\t\treturn 0;\n\tif (a == &dev_attr_numa_node.attr && !IS_ENABLED(CONFIG_NUMA))\n\t\treturn 0;\n\tif (a == &dev_attr_mapping.attr && is_static(dax_region))\n\t\treturn 0;\n\tif ((a == &dev_attr_align.attr ||\n\t     a == &dev_attr_size.attr) && is_static(dax_region))\n\t\treturn 0444;\n\treturn a->mode;\n}\n\nstatic struct attribute *dev_dax_attributes[] = {\n\t&dev_attr_modalias.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_mapping.attr,\n\t&dev_attr_target_node.attr,\n\t&dev_attr_align.attr,\n\t&dev_attr_resource.attr,\n\t&dev_attr_numa_node.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group dev_dax_attribute_group = {\n\t.attrs = dev_dax_attributes,\n\t.is_visible = dev_dax_visible,\n};\n\nstatic const struct attribute_group *dax_attribute_groups[] = {\n\t&dev_dax_attribute_group,\n\tNULL,\n};\n\nstatic void dev_dax_release(struct device *dev)\n{\n\tstruct dev_dax *dev_dax = to_dev_dax(dev);\n\tstruct dax_device *dax_dev = dev_dax->dax_dev;\n\n\tput_dax(dax_dev);\n\tfree_dev_dax_id(dev_dax);\n\tkfree(dev_dax->pgmap);\n\tkfree(dev_dax);\n}\n\nstatic const struct device_type dev_dax_type = {\n\t.release = dev_dax_release,\n\t.groups = dax_attribute_groups,\n};\n\nstruct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)\n{\n\tstruct dax_region *dax_region = data->dax_region;\n\tstruct device *parent = dax_region->dev;\n\tstruct dax_device *dax_dev;\n\tstruct dev_dax *dev_dax;\n\tstruct inode *inode;\n\tstruct device *dev;\n\tint rc;\n\n\tdev_dax = kzalloc(sizeof(*dev_dax), GFP_KERNEL);\n\tif (!dev_dax)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev_dax->region = dax_region;\n\tif (is_static(dax_region)) {\n\t\tif (dev_WARN_ONCE(parent, data->id < 0,\n\t\t\t\t\"dynamic id specified to static region\\n\")) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_id;\n\t\t}\n\n\t\tdev_dax->id = data->id;\n\t} else {\n\t\tif (dev_WARN_ONCE(parent, data->id >= 0,\n\t\t\t\t\"static id specified to dynamic region\\n\")) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_id;\n\t\t}\n\n\t\trc = alloc_dev_dax_id(dev_dax);\n\t\tif (rc < 0)\n\t\t\tgoto err_id;\n\t}\n\n\tdev = &dev_dax->dev;\n\tdevice_initialize(dev);\n\tdev_set_name(dev, \"dax%d.%d\", dax_region->id, dev_dax->id);\n\n\trc = alloc_dev_dax_range(dev_dax, dax_region->res.start, data->size);\n\tif (rc)\n\t\tgoto err_range;\n\n\tif (data->pgmap) {\n\t\tdev_WARN_ONCE(parent, !is_static(dax_region),\n\t\t\t\"custom dev_pagemap requires a static dax_region\\n\");\n\n\t\tdev_dax->pgmap = kmemdup(data->pgmap,\n\t\t\t\tsizeof(struct dev_pagemap), GFP_KERNEL);\n\t\tif (!dev_dax->pgmap) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_pgmap;\n\t\t}\n\t}\n\n\t \n\tdax_dev = alloc_dax(dev_dax, NULL);\n\tif (IS_ERR(dax_dev)) {\n\t\trc = PTR_ERR(dax_dev);\n\t\tgoto err_alloc_dax;\n\t}\n\tset_dax_synchronous(dax_dev);\n\tset_dax_nocache(dax_dev);\n\tset_dax_nomc(dax_dev);\n\n\t \n\tkill_dax(dax_dev);\n\n\tdev_dax->dax_dev = dax_dev;\n\tdev_dax->target_node = dax_region->target_node;\n\tdev_dax->align = dax_region->align;\n\tida_init(&dev_dax->ida);\n\n\tinode = dax_inode(dax_dev);\n\tdev->devt = inode->i_rdev;\n\tdev->bus = &dax_bus_type;\n\tdev->parent = parent;\n\tdev->type = &dev_dax_type;\n\n\trc = device_add(dev);\n\tif (rc) {\n\t\tkill_dev_dax(dev_dax);\n\t\tput_device(dev);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\trc = devm_add_action_or_reset(dax_region->dev, unregister_dev_dax, dev);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\t \n\tif (dev_dax->nr_range && range_len(&dev_dax->ranges[0].range)) {\n\t\trc = devm_register_dax_mapping(dev_dax, 0);\n\t\tif (rc)\n\t\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn dev_dax;\n\nerr_alloc_dax:\n\tkfree(dev_dax->pgmap);\nerr_pgmap:\n\tfree_dev_dax_ranges(dev_dax);\nerr_range:\n\tfree_dev_dax_id(dev_dax);\nerr_id:\n\tkfree(dev_dax);\n\n\treturn ERR_PTR(rc);\n}\nEXPORT_SYMBOL_GPL(devm_create_dev_dax);\n\nint __dax_driver_register(struct dax_device_driver *dax_drv,\n\t\tstruct module *module, const char *mod_name)\n{\n\tstruct device_driver *drv = &dax_drv->drv;\n\n\t \n\tif (!dax_drv->probe)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&dax_drv->ids);\n\tdrv->owner = module;\n\tdrv->name = mod_name;\n\tdrv->mod_name = mod_name;\n\tdrv->bus = &dax_bus_type;\n\n\treturn driver_register(drv);\n}\nEXPORT_SYMBOL_GPL(__dax_driver_register);\n\nvoid dax_driver_unregister(struct dax_device_driver *dax_drv)\n{\n\tstruct device_driver *drv = &dax_drv->drv;\n\tstruct dax_id *dax_id, *_id;\n\n\tmutex_lock(&dax_bus_lock);\n\tlist_for_each_entry_safe(dax_id, _id, &dax_drv->ids, list) {\n\t\tlist_del(&dax_id->list);\n\t\tkfree(dax_id);\n\t}\n\tmutex_unlock(&dax_bus_lock);\n\tdriver_unregister(drv);\n}\nEXPORT_SYMBOL_GPL(dax_driver_unregister);\n\nint __init dax_bus_init(void)\n{\n\treturn bus_register(&dax_bus_type);\n}\n\nvoid __exit dax_bus_exit(void)\n{\n\tbus_unregister(&dax_bus_type);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}