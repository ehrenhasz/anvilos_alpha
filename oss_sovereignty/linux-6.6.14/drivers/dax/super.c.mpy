{
  "module_name": "super.c",
  "hash_id": "3f7d1ea99fe3eea21458621450ef5705b57e5aebf1278a2282769c957980b242",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dax/super.c",
  "human_readable_source": "\n \n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/pseudo_fs.h>\n#include <linux/magic.h>\n#include <linux/pfn_t.h>\n#include <linux/cdev.h>\n#include <linux/slab.h>\n#include <linux/uio.h>\n#include <linux/dax.h>\n#include <linux/fs.h>\n#include \"dax-private.h\"\n\n \nstruct dax_device {\n\tstruct inode inode;\n\tstruct cdev cdev;\n\tvoid *private;\n\tunsigned long flags;\n\tconst struct dax_operations *ops;\n\tvoid *holder_data;\n\tconst struct dax_holder_operations *holder_ops;\n};\n\nstatic dev_t dax_devt;\nDEFINE_STATIC_SRCU(dax_srcu);\nstatic struct vfsmount *dax_mnt;\nstatic DEFINE_IDA(dax_minor_ida);\nstatic struct kmem_cache *dax_cache __read_mostly;\nstatic struct super_block *dax_superblock __read_mostly;\n\nint dax_read_lock(void)\n{\n\treturn srcu_read_lock(&dax_srcu);\n}\nEXPORT_SYMBOL_GPL(dax_read_lock);\n\nvoid dax_read_unlock(int id)\n{\n\tsrcu_read_unlock(&dax_srcu, id);\n}\nEXPORT_SYMBOL_GPL(dax_read_unlock);\n\n#if defined(CONFIG_BLOCK) && defined(CONFIG_FS_DAX)\n#include <linux/blkdev.h>\n\nstatic DEFINE_XARRAY(dax_hosts);\n\nint dax_add_host(struct dax_device *dax_dev, struct gendisk *disk)\n{\n\treturn xa_insert(&dax_hosts, (unsigned long)disk, dax_dev, GFP_KERNEL);\n}\nEXPORT_SYMBOL_GPL(dax_add_host);\n\nvoid dax_remove_host(struct gendisk *disk)\n{\n\txa_erase(&dax_hosts, (unsigned long)disk);\n}\nEXPORT_SYMBOL_GPL(dax_remove_host);\n\n \nstruct dax_device *fs_dax_get_by_bdev(struct block_device *bdev, u64 *start_off,\n\t\tvoid *holder, const struct dax_holder_operations *ops)\n{\n\tstruct dax_device *dax_dev;\n\tu64 part_size;\n\tint id;\n\n\tif (!blk_queue_dax(bdev->bd_disk->queue))\n\t\treturn NULL;\n\n\t*start_off = get_start_sect(bdev) * SECTOR_SIZE;\n\tpart_size = bdev_nr_sectors(bdev) * SECTOR_SIZE;\n\tif (*start_off % PAGE_SIZE || part_size % PAGE_SIZE) {\n\t\tpr_info(\"%pg: error: unaligned partition for dax\\n\", bdev);\n\t\treturn NULL;\n\t}\n\n\tid = dax_read_lock();\n\tdax_dev = xa_load(&dax_hosts, (unsigned long)bdev->bd_disk);\n\tif (!dax_dev || !dax_alive(dax_dev) || !igrab(&dax_dev->inode))\n\t\tdax_dev = NULL;\n\telse if (holder) {\n\t\tif (!cmpxchg(&dax_dev->holder_data, NULL, holder))\n\t\t\tdax_dev->holder_ops = ops;\n\t\telse\n\t\t\tdax_dev = NULL;\n\t}\n\tdax_read_unlock(id);\n\n\treturn dax_dev;\n}\nEXPORT_SYMBOL_GPL(fs_dax_get_by_bdev);\n\nvoid fs_put_dax(struct dax_device *dax_dev, void *holder)\n{\n\tif (dax_dev && holder &&\n\t    cmpxchg(&dax_dev->holder_data, holder, NULL) == holder)\n\t\tdax_dev->holder_ops = NULL;\n\tput_dax(dax_dev);\n}\nEXPORT_SYMBOL_GPL(fs_put_dax);\n#endif  \n\nenum dax_device_flags {\n\t \n\tDAXDEV_ALIVE,\n\t \n\tDAXDEV_WRITE_CACHE,\n\t \n\tDAXDEV_SYNC,\n\t \n\tDAXDEV_NOCACHE,\n\t \n\tDAXDEV_NOMC,\n};\n\n \nlong dax_direct_access(struct dax_device *dax_dev, pgoff_t pgoff, long nr_pages,\n\t\tenum dax_access_mode mode, void **kaddr, pfn_t *pfn)\n{\n\tlong avail;\n\n\tif (!dax_dev)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!dax_alive(dax_dev))\n\t\treturn -ENXIO;\n\n\tif (nr_pages < 0)\n\t\treturn -EINVAL;\n\n\tavail = dax_dev->ops->direct_access(dax_dev, pgoff, nr_pages,\n\t\t\tmode, kaddr, pfn);\n\tif (!avail)\n\t\treturn -ERANGE;\n\treturn min(avail, nr_pages);\n}\nEXPORT_SYMBOL_GPL(dax_direct_access);\n\nsize_t dax_copy_from_iter(struct dax_device *dax_dev, pgoff_t pgoff, void *addr,\n\t\tsize_t bytes, struct iov_iter *i)\n{\n\tif (!dax_alive(dax_dev))\n\t\treturn 0;\n\n\t \n\tif (test_bit(DAXDEV_NOCACHE, &dax_dev->flags))\n\t\treturn _copy_from_iter_flushcache(addr, bytes, i);\n\treturn _copy_from_iter(addr, bytes, i);\n}\n\nsize_t dax_copy_to_iter(struct dax_device *dax_dev, pgoff_t pgoff, void *addr,\n\t\tsize_t bytes, struct iov_iter *i)\n{\n\tif (!dax_alive(dax_dev))\n\t\treturn 0;\n\n\t \n\tif (test_bit(DAXDEV_NOMC, &dax_dev->flags))\n\t\treturn _copy_mc_to_iter(addr, bytes, i);\n\treturn _copy_to_iter(addr, bytes, i);\n}\n\nint dax_zero_page_range(struct dax_device *dax_dev, pgoff_t pgoff,\n\t\t\tsize_t nr_pages)\n{\n\tint ret;\n\n\tif (!dax_alive(dax_dev))\n\t\treturn -ENXIO;\n\t \n\tif (nr_pages != 1)\n\t\treturn -EIO;\n\n\tret = dax_dev->ops->zero_page_range(dax_dev, pgoff, nr_pages);\n\treturn dax_mem2blk_err(ret);\n}\nEXPORT_SYMBOL_GPL(dax_zero_page_range);\n\nsize_t dax_recovery_write(struct dax_device *dax_dev, pgoff_t pgoff,\n\t\tvoid *addr, size_t bytes, struct iov_iter *iter)\n{\n\tif (!dax_dev->ops->recovery_write)\n\t\treturn 0;\n\treturn dax_dev->ops->recovery_write(dax_dev, pgoff, addr, bytes, iter);\n}\nEXPORT_SYMBOL_GPL(dax_recovery_write);\n\nint dax_holder_notify_failure(struct dax_device *dax_dev, u64 off,\n\t\t\t      u64 len, int mf_flags)\n{\n\tint rc, id;\n\n\tid = dax_read_lock();\n\tif (!dax_alive(dax_dev)) {\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tif (!dax_dev->holder_ops) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trc = dax_dev->holder_ops->notify_failure(dax_dev, off, len, mf_flags);\nout:\n\tdax_read_unlock(id);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(dax_holder_notify_failure);\n\n#ifdef CONFIG_ARCH_HAS_PMEM_API\nvoid arch_wb_cache_pmem(void *addr, size_t size);\nvoid dax_flush(struct dax_device *dax_dev, void *addr, size_t size)\n{\n\tif (unlikely(!dax_write_cache_enabled(dax_dev)))\n\t\treturn;\n\n\tarch_wb_cache_pmem(addr, size);\n}\n#else\nvoid dax_flush(struct dax_device *dax_dev, void *addr, size_t size)\n{\n}\n#endif\nEXPORT_SYMBOL_GPL(dax_flush);\n\nvoid dax_write_cache(struct dax_device *dax_dev, bool wc)\n{\n\tif (wc)\n\t\tset_bit(DAXDEV_WRITE_CACHE, &dax_dev->flags);\n\telse\n\t\tclear_bit(DAXDEV_WRITE_CACHE, &dax_dev->flags);\n}\nEXPORT_SYMBOL_GPL(dax_write_cache);\n\nbool dax_write_cache_enabled(struct dax_device *dax_dev)\n{\n\treturn test_bit(DAXDEV_WRITE_CACHE, &dax_dev->flags);\n}\nEXPORT_SYMBOL_GPL(dax_write_cache_enabled);\n\nbool dax_synchronous(struct dax_device *dax_dev)\n{\n\treturn test_bit(DAXDEV_SYNC, &dax_dev->flags);\n}\nEXPORT_SYMBOL_GPL(dax_synchronous);\n\nvoid set_dax_synchronous(struct dax_device *dax_dev)\n{\n\tset_bit(DAXDEV_SYNC, &dax_dev->flags);\n}\nEXPORT_SYMBOL_GPL(set_dax_synchronous);\n\nvoid set_dax_nocache(struct dax_device *dax_dev)\n{\n\tset_bit(DAXDEV_NOCACHE, &dax_dev->flags);\n}\nEXPORT_SYMBOL_GPL(set_dax_nocache);\n\nvoid set_dax_nomc(struct dax_device *dax_dev)\n{\n\tset_bit(DAXDEV_NOMC, &dax_dev->flags);\n}\nEXPORT_SYMBOL_GPL(set_dax_nomc);\n\nbool dax_alive(struct dax_device *dax_dev)\n{\n\tlockdep_assert_held(&dax_srcu);\n\treturn test_bit(DAXDEV_ALIVE, &dax_dev->flags);\n}\nEXPORT_SYMBOL_GPL(dax_alive);\n\n \nvoid kill_dax(struct dax_device *dax_dev)\n{\n\tif (!dax_dev)\n\t\treturn;\n\n\tif (dax_dev->holder_data != NULL)\n\t\tdax_holder_notify_failure(dax_dev, 0, U64_MAX, 0);\n\n\tclear_bit(DAXDEV_ALIVE, &dax_dev->flags);\n\tsynchronize_srcu(&dax_srcu);\n\n\t \n\tdax_dev->holder_ops = NULL;\n\tdax_dev->holder_data = NULL;\n}\nEXPORT_SYMBOL_GPL(kill_dax);\n\nvoid run_dax(struct dax_device *dax_dev)\n{\n\tset_bit(DAXDEV_ALIVE, &dax_dev->flags);\n}\nEXPORT_SYMBOL_GPL(run_dax);\n\nstatic struct inode *dax_alloc_inode(struct super_block *sb)\n{\n\tstruct dax_device *dax_dev;\n\tstruct inode *inode;\n\n\tdax_dev = alloc_inode_sb(sb, dax_cache, GFP_KERNEL);\n\tif (!dax_dev)\n\t\treturn NULL;\n\n\tinode = &dax_dev->inode;\n\tinode->i_rdev = 0;\n\treturn inode;\n}\n\nstatic struct dax_device *to_dax_dev(struct inode *inode)\n{\n\treturn container_of(inode, struct dax_device, inode);\n}\n\nstatic void dax_free_inode(struct inode *inode)\n{\n\tstruct dax_device *dax_dev = to_dax_dev(inode);\n\tif (inode->i_rdev)\n\t\tida_free(&dax_minor_ida, iminor(inode));\n\tkmem_cache_free(dax_cache, dax_dev);\n}\n\nstatic void dax_destroy_inode(struct inode *inode)\n{\n\tstruct dax_device *dax_dev = to_dax_dev(inode);\n\tWARN_ONCE(test_bit(DAXDEV_ALIVE, &dax_dev->flags),\n\t\t\t\"kill_dax() must be called before final iput()\\n\");\n}\n\nstatic const struct super_operations dax_sops = {\n\t.statfs = simple_statfs,\n\t.alloc_inode = dax_alloc_inode,\n\t.destroy_inode = dax_destroy_inode,\n\t.free_inode = dax_free_inode,\n\t.drop_inode = generic_delete_inode,\n};\n\nstatic int dax_init_fs_context(struct fs_context *fc)\n{\n\tstruct pseudo_fs_context *ctx = init_pseudo(fc, DAXFS_MAGIC);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->ops = &dax_sops;\n\treturn 0;\n}\n\nstatic struct file_system_type dax_fs_type = {\n\t.name\t\t= \"dax\",\n\t.init_fs_context = dax_init_fs_context,\n\t.kill_sb\t= kill_anon_super,\n};\n\nstatic int dax_test(struct inode *inode, void *data)\n{\n\tdev_t devt = *(dev_t *) data;\n\n\treturn inode->i_rdev == devt;\n}\n\nstatic int dax_set(struct inode *inode, void *data)\n{\n\tdev_t devt = *(dev_t *) data;\n\n\tinode->i_rdev = devt;\n\treturn 0;\n}\n\nstatic struct dax_device *dax_dev_get(dev_t devt)\n{\n\tstruct dax_device *dax_dev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(dax_superblock, hash_32(devt + DAXFS_MAGIC, 31),\n\t\t\tdax_test, dax_set, &devt);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tdax_dev = to_dax_dev(inode);\n\tif (inode->i_state & I_NEW) {\n\t\tset_bit(DAXDEV_ALIVE, &dax_dev->flags);\n\t\tinode->i_cdev = &dax_dev->cdev;\n\t\tinode->i_mode = S_IFCHR;\n\t\tinode->i_flags = S_DAX;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tunlock_new_inode(inode);\n\t}\n\n\treturn dax_dev;\n}\n\nstruct dax_device *alloc_dax(void *private, const struct dax_operations *ops)\n{\n\tstruct dax_device *dax_dev;\n\tdev_t devt;\n\tint minor;\n\n\tif (WARN_ON_ONCE(ops && !ops->zero_page_range))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tminor = ida_alloc_max(&dax_minor_ida, MINORMASK, GFP_KERNEL);\n\tif (minor < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdevt = MKDEV(MAJOR(dax_devt), minor);\n\tdax_dev = dax_dev_get(devt);\n\tif (!dax_dev)\n\t\tgoto err_dev;\n\n\tdax_dev->ops = ops;\n\tdax_dev->private = private;\n\treturn dax_dev;\n\n err_dev:\n\tida_free(&dax_minor_ida, minor);\n\treturn ERR_PTR(-ENOMEM);\n}\nEXPORT_SYMBOL_GPL(alloc_dax);\n\nvoid put_dax(struct dax_device *dax_dev)\n{\n\tif (!dax_dev)\n\t\treturn;\n\tiput(&dax_dev->inode);\n}\nEXPORT_SYMBOL_GPL(put_dax);\n\n \nvoid *dax_holder(struct dax_device *dax_dev)\n{\n\treturn dax_dev->holder_data;\n}\nEXPORT_SYMBOL_GPL(dax_holder);\n\n \nstruct dax_device *inode_dax(struct inode *inode)\n{\n\tstruct cdev *cdev = inode->i_cdev;\n\n\treturn container_of(cdev, struct dax_device, cdev);\n}\nEXPORT_SYMBOL_GPL(inode_dax);\n\nstruct inode *dax_inode(struct dax_device *dax_dev)\n{\n\treturn &dax_dev->inode;\n}\nEXPORT_SYMBOL_GPL(dax_inode);\n\nvoid *dax_get_private(struct dax_device *dax_dev)\n{\n\tif (!test_bit(DAXDEV_ALIVE, &dax_dev->flags))\n\t\treturn NULL;\n\treturn dax_dev->private;\n}\nEXPORT_SYMBOL_GPL(dax_get_private);\n\nstatic void init_once(void *_dax_dev)\n{\n\tstruct dax_device *dax_dev = _dax_dev;\n\tstruct inode *inode = &dax_dev->inode;\n\n\tmemset(dax_dev, 0, sizeof(*dax_dev));\n\tinode_init_once(inode);\n}\n\nstatic int dax_fs_init(void)\n{\n\tint rc;\n\n\tdax_cache = kmem_cache_create(\"dax_cache\", sizeof(struct dax_device), 0,\n\t\t\t(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t SLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\tinit_once);\n\tif (!dax_cache)\n\t\treturn -ENOMEM;\n\n\tdax_mnt = kern_mount(&dax_fs_type);\n\tif (IS_ERR(dax_mnt)) {\n\t\trc = PTR_ERR(dax_mnt);\n\t\tgoto err_mount;\n\t}\n\tdax_superblock = dax_mnt->mnt_sb;\n\n\treturn 0;\n\n err_mount:\n\tkmem_cache_destroy(dax_cache);\n\n\treturn rc;\n}\n\nstatic void dax_fs_exit(void)\n{\n\tkern_unmount(dax_mnt);\n\trcu_barrier();\n\tkmem_cache_destroy(dax_cache);\n}\n\nstatic int __init dax_core_init(void)\n{\n\tint rc;\n\n\trc = dax_fs_init();\n\tif (rc)\n\t\treturn rc;\n\n\trc = alloc_chrdev_region(&dax_devt, 0, MINORMASK+1, \"dax\");\n\tif (rc)\n\t\tgoto err_chrdev;\n\n\trc = dax_bus_init();\n\tif (rc)\n\t\tgoto err_bus;\n\treturn 0;\n\nerr_bus:\n\tunregister_chrdev_region(dax_devt, MINORMASK+1);\nerr_chrdev:\n\tdax_fs_exit();\n\treturn 0;\n}\n\nstatic void __exit dax_core_exit(void)\n{\n\tdax_bus_exit();\n\tunregister_chrdev_region(dax_devt, MINORMASK+1);\n\tida_destroy(&dax_minor_ida);\n\tdax_fs_exit();\n}\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nsubsys_initcall(dax_core_init);\nmodule_exit(dax_core_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}