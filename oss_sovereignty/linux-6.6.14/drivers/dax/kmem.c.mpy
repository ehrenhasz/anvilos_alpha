{
  "module_name": "kmem.c",
  "hash_id": "e0a628a5cdad3a7ffa6cc57ca10255eedc3257a69dd8363e8b286bc2255bdafb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dax/kmem.c",
  "human_readable_source": "\n \n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/memory.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/pfn_t.h>\n#include <linux/slab.h>\n#include <linux/dax.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/memory-tiers.h>\n#include \"dax-private.h\"\n#include \"bus.h\"\n\n \n#define MEMTIER_DEFAULT_DAX_ADISTANCE\t(MEMTIER_ADISTANCE_DRAM * 5)\n\n \nstatic const char *kmem_name;\n \nstatic bool any_hotremove_failed;\n\nstatic int dax_kmem_range(struct dev_dax *dev_dax, int i, struct range *r)\n{\n\tstruct dev_dax_range *dax_range = &dev_dax->ranges[i];\n\tstruct range *range = &dax_range->range;\n\n\t \n\tr->start = ALIGN(range->start, memory_block_size_bytes());\n\tr->end = ALIGN_DOWN(range->end + 1, memory_block_size_bytes()) - 1;\n\tif (r->start >= r->end) {\n\t\tr->start = range->start;\n\t\tr->end = range->end;\n\t\treturn -ENOSPC;\n\t}\n\treturn 0;\n}\n\nstruct dax_kmem_data {\n\tconst char *res_name;\n\tint mgid;\n\tstruct resource *res[];\n};\n\nstatic struct memory_dev_type *dax_slowmem_type;\nstatic int dev_dax_kmem_probe(struct dev_dax *dev_dax)\n{\n\tstruct device *dev = &dev_dax->dev;\n\tunsigned long total_len = 0;\n\tstruct dax_kmem_data *data;\n\tint i, rc, mapped = 0;\n\tint numa_node;\n\n\t \n\tnuma_node = dev_dax->target_node;\n\tif (numa_node < 0) {\n\t\tdev_warn(dev, \"rejecting DAX region with invalid node: %d\\n\",\n\t\t\t\tnuma_node);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < dev_dax->nr_range; i++) {\n\t\tstruct range range;\n\n\t\trc = dax_kmem_range(dev_dax, i, &range);\n\t\tif (rc) {\n\t\t\tdev_info(dev, \"mapping%d: %#llx-%#llx too small after alignment\\n\",\n\t\t\t\t\ti, range.start, range.end);\n\t\t\tcontinue;\n\t\t}\n\t\ttotal_len += range_len(&range);\n\t}\n\n\tif (!total_len) {\n\t\tdev_warn(dev, \"rejecting DAX region without any memory after alignment\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinit_node_memory_type(numa_node, dax_slowmem_type);\n\n\trc = -ENOMEM;\n\tdata = kzalloc(struct_size(data, res, dev_dax->nr_range), GFP_KERNEL);\n\tif (!data)\n\t\tgoto err_dax_kmem_data;\n\n\tdata->res_name = kstrdup(dev_name(dev), GFP_KERNEL);\n\tif (!data->res_name)\n\t\tgoto err_res_name;\n\n\trc = memory_group_register_static(numa_node, PFN_UP(total_len));\n\tif (rc < 0)\n\t\tgoto err_reg_mgid;\n\tdata->mgid = rc;\n\n\tfor (i = 0; i < dev_dax->nr_range; i++) {\n\t\tstruct resource *res;\n\t\tstruct range range;\n\n\t\trc = dax_kmem_range(dev_dax, i, &range);\n\t\tif (rc)\n\t\t\tcontinue;\n\n\t\t \n\t\tres = request_mem_region(range.start, range_len(&range), data->res_name);\n\t\tif (!res) {\n\t\t\tdev_warn(dev, \"mapping%d: %#llx-%#llx could not reserve region\\n\",\n\t\t\t\t\ti, range.start, range.end);\n\t\t\t \n\t\t\tif (mapped)\n\t\t\t\tcontinue;\n\t\t\trc = -EBUSY;\n\t\t\tgoto err_request_mem;\n\t\t}\n\t\tdata->res[i] = res;\n\n\t\t \n\t\tres->flags = IORESOURCE_SYSTEM_RAM;\n\n\t\t \n\t\trc = add_memory_driver_managed(data->mgid, range.start,\n\t\t\t\trange_len(&range), kmem_name, MHP_NID_IS_MGID);\n\n\t\tif (rc) {\n\t\t\tdev_warn(dev, \"mapping%d: %#llx-%#llx memory add failed\\n\",\n\t\t\t\t\ti, range.start, range.end);\n\t\t\tremove_resource(res);\n\t\t\tkfree(res);\n\t\t\tdata->res[i] = NULL;\n\t\t\tif (mapped)\n\t\t\t\tcontinue;\n\t\t\tgoto err_request_mem;\n\t\t}\n\t\tmapped++;\n\t}\n\n\tdev_set_drvdata(dev, data);\n\n\treturn 0;\n\nerr_request_mem:\n\tmemory_group_unregister(data->mgid);\nerr_reg_mgid:\n\tkfree(data->res_name);\nerr_res_name:\n\tkfree(data);\nerr_dax_kmem_data:\n\tclear_node_memory_type(numa_node, dax_slowmem_type);\n\treturn rc;\n}\n\n#ifdef CONFIG_MEMORY_HOTREMOVE\nstatic void dev_dax_kmem_remove(struct dev_dax *dev_dax)\n{\n\tint i, success = 0;\n\tint node = dev_dax->target_node;\n\tstruct device *dev = &dev_dax->dev;\n\tstruct dax_kmem_data *data = dev_get_drvdata(dev);\n\n\t \n\tfor (i = 0; i < dev_dax->nr_range; i++) {\n\t\tstruct range range;\n\t\tint rc;\n\n\t\trc = dax_kmem_range(dev_dax, i, &range);\n\t\tif (rc)\n\t\t\tcontinue;\n\n\t\trc = remove_memory(range.start, range_len(&range));\n\t\tif (rc == 0) {\n\t\t\tremove_resource(data->res[i]);\n\t\t\tkfree(data->res[i]);\n\t\t\tdata->res[i] = NULL;\n\t\t\tsuccess++;\n\t\t\tcontinue;\n\t\t}\n\t\tany_hotremove_failed = true;\n\t\tdev_err(dev,\n\t\t\t\"mapping%d: %#llx-%#llx cannot be hotremoved until the next reboot\\n\",\n\t\t\t\ti, range.start, range.end);\n\t}\n\n\tif (success >= dev_dax->nr_range) {\n\t\tmemory_group_unregister(data->mgid);\n\t\tkfree(data->res_name);\n\t\tkfree(data);\n\t\tdev_set_drvdata(dev, NULL);\n\t\t \n\t\tclear_node_memory_type(node, dax_slowmem_type);\n\t}\n}\n#else\nstatic void dev_dax_kmem_remove(struct dev_dax *dev_dax)\n{\n\t \n\tany_hotremove_failed = true;\n}\n#endif  \n\nstatic struct dax_device_driver device_dax_kmem_driver = {\n\t.probe = dev_dax_kmem_probe,\n\t.remove = dev_dax_kmem_remove,\n\t.type = DAXDRV_KMEM_TYPE,\n};\n\nstatic int __init dax_kmem_init(void)\n{\n\tint rc;\n\n\t \n\tkmem_name = kstrdup_const(\"System RAM (kmem)\", GFP_KERNEL);\n\tif (!kmem_name)\n\t\treturn -ENOMEM;\n\n\tdax_slowmem_type = alloc_memory_type(MEMTIER_DEFAULT_DAX_ADISTANCE);\n\tif (IS_ERR(dax_slowmem_type)) {\n\t\trc = PTR_ERR(dax_slowmem_type);\n\t\tgoto err_dax_slowmem_type;\n\t}\n\n\trc = dax_driver_register(&device_dax_kmem_driver);\n\tif (rc)\n\t\tgoto error_dax_driver;\n\n\treturn rc;\n\nerror_dax_driver:\n\tput_memory_type(dax_slowmem_type);\nerr_dax_slowmem_type:\n\tkfree_const(kmem_name);\n\treturn rc;\n}\n\nstatic void __exit dax_kmem_exit(void)\n{\n\tdax_driver_unregister(&device_dax_kmem_driver);\n\tif (!any_hotremove_failed)\n\t\tkfree_const(kmem_name);\n\tput_memory_type(dax_slowmem_type);\n}\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nmodule_init(dax_kmem_init);\nmodule_exit(dax_kmem_exit);\nMODULE_ALIAS_DAX_DEVICE(0);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}