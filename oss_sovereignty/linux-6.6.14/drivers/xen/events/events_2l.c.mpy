{
  "module_name": "events_2l.c",
  "hash_id": "b6164cfe6f64b47864a8cd8145f7d60af3ba18755c32da9e6a8d53acdb49239a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/events/events_2l.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"xen:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/linkage.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n\n#include <asm/sync_bitops.h>\n#include <asm/xen/hypercall.h>\n#include <asm/xen/hypervisor.h>\n\n#include <xen/xen.h>\n#include <xen/xen-ops.h>\n#include <xen/events.h>\n#include <xen/interface/xen.h>\n#include <xen/interface/event_channel.h>\n\n#include \"events_internal.h\"\n\n \n#define BITS_PER_EVTCHN_WORD (sizeof(xen_ulong_t)*8)\n \n#define BM(x) (unsigned long *)(x)\n \n#define EVTCHN_FIRST_BIT(w) find_first_bit(BM(&(w)), BITS_PER_EVTCHN_WORD)\n\n#define EVTCHN_MASK_SIZE (EVTCHN_2L_NR_CHANNELS/BITS_PER_EVTCHN_WORD)\n\nstatic DEFINE_PER_CPU(xen_ulong_t [EVTCHN_MASK_SIZE], cpu_evtchn_mask);\n\nstatic unsigned evtchn_2l_max_channels(void)\n{\n\treturn EVTCHN_2L_NR_CHANNELS;\n}\n\nstatic void evtchn_2l_remove(evtchn_port_t evtchn, unsigned int cpu)\n{\n\tclear_bit(evtchn, BM(per_cpu(cpu_evtchn_mask, cpu)));\n}\n\nstatic void evtchn_2l_bind_to_cpu(evtchn_port_t evtchn, unsigned int cpu,\n\t\t\t\t  unsigned int old_cpu)\n{\n\tclear_bit(evtchn, BM(per_cpu(cpu_evtchn_mask, old_cpu)));\n\tset_bit(evtchn, BM(per_cpu(cpu_evtchn_mask, cpu)));\n}\n\nstatic void evtchn_2l_clear_pending(evtchn_port_t port)\n{\n\tstruct shared_info *s = HYPERVISOR_shared_info;\n\tsync_clear_bit(port, BM(&s->evtchn_pending[0]));\n}\n\nstatic void evtchn_2l_set_pending(evtchn_port_t port)\n{\n\tstruct shared_info *s = HYPERVISOR_shared_info;\n\tsync_set_bit(port, BM(&s->evtchn_pending[0]));\n}\n\nstatic bool evtchn_2l_is_pending(evtchn_port_t port)\n{\n\tstruct shared_info *s = HYPERVISOR_shared_info;\n\treturn sync_test_bit(port, BM(&s->evtchn_pending[0]));\n}\n\nstatic void evtchn_2l_mask(evtchn_port_t port)\n{\n\tstruct shared_info *s = HYPERVISOR_shared_info;\n\tsync_set_bit(port, BM(&s->evtchn_mask[0]));\n}\n\nstatic void evtchn_2l_unmask(evtchn_port_t port)\n{\n\tstruct shared_info *s = HYPERVISOR_shared_info;\n\tunsigned int cpu = get_cpu();\n\tint do_hypercall = 0, evtchn_pending = 0;\n\n\tBUG_ON(!irqs_disabled());\n\n\tsmp_wmb();\t \n\n\tif (unlikely((cpu != cpu_from_evtchn(port))))\n\t\tdo_hypercall = 1;\n\telse {\n\t\t \n\t\tsync_clear_bit(port, BM(&s->evtchn_mask[0]));\n\t\tevtchn_pending = sync_test_bit(port, BM(&s->evtchn_pending[0]));\n\n\t\tif (unlikely(evtchn_pending && xen_hvm_domain())) {\n\t\t\tsync_set_bit(port, BM(&s->evtchn_mask[0]));\n\t\t\tdo_hypercall = 1;\n\t\t}\n\t}\n\n\t \n\tif (do_hypercall) {\n\t\tstruct evtchn_unmask unmask = { .port = port };\n\t\t(void)HYPERVISOR_event_channel_op(EVTCHNOP_unmask, &unmask);\n\t} else {\n\t\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\n\t\t \n\t\tif (evtchn_pending &&\n\t\t    !sync_test_and_set_bit(port / BITS_PER_EVTCHN_WORD,\n\t\t\t\t\t   BM(&vcpu_info->evtchn_pending_sel)))\n\t\t\tvcpu_info->evtchn_upcall_pending = 1;\n\t}\n\n\tput_cpu();\n}\n\nstatic DEFINE_PER_CPU(unsigned int, current_word_idx);\nstatic DEFINE_PER_CPU(unsigned int, current_bit_idx);\n\n \n#define MASK_LSBS(w, i) (w & ((~((xen_ulong_t)0UL)) << i))\n\nstatic inline xen_ulong_t active_evtchns(unsigned int cpu,\n\t\t\t\t\t struct shared_info *sh,\n\t\t\t\t\t unsigned int idx)\n{\n\treturn sh->evtchn_pending[idx] &\n\t\tper_cpu(cpu_evtchn_mask, cpu)[idx] &\n\t\t~sh->evtchn_mask[idx];\n}\n\n \nstatic void evtchn_2l_handle_events(unsigned cpu, struct evtchn_loop_ctrl *ctrl)\n{\n\tint irq;\n\txen_ulong_t pending_words;\n\txen_ulong_t pending_bits;\n\tint start_word_idx, start_bit_idx;\n\tint word_idx, bit_idx;\n\tint i;\n\tstruct shared_info *s = HYPERVISOR_shared_info;\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\n\t \n\tirq = irq_from_virq(cpu, VIRQ_TIMER);\n\tif (irq != -1) {\n\t\tevtchn_port_t evtchn = evtchn_from_irq(irq);\n\t\tword_idx = evtchn / BITS_PER_LONG;\n\t\tbit_idx = evtchn % BITS_PER_LONG;\n\t\tif (active_evtchns(cpu, s, word_idx) & (1ULL << bit_idx))\n\t\t\tgeneric_handle_irq(irq);\n\t}\n\n\t \n\tpending_words = xchg_xen_ulong(&vcpu_info->evtchn_pending_sel, 0);\n\n\tstart_word_idx = __this_cpu_read(current_word_idx);\n\tstart_bit_idx = __this_cpu_read(current_bit_idx);\n\n\tword_idx = start_word_idx;\n\n\tfor (i = 0; pending_words != 0; i++) {\n\t\txen_ulong_t words;\n\n\t\twords = MASK_LSBS(pending_words, word_idx);\n\n\t\t \n\t\tif (words == 0) {\n\t\t\tword_idx = 0;\n\t\t\tbit_idx = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tword_idx = EVTCHN_FIRST_BIT(words);\n\n\t\tpending_bits = active_evtchns(cpu, s, word_idx);\n\t\tbit_idx = 0;  \n\t\t \n\t\tif (word_idx == start_word_idx) {\n\t\t\tif (i == 0)\n\t\t\t\tbit_idx = start_bit_idx;\n\t\t}\n\n\t\tdo {\n\t\t\txen_ulong_t bits;\n\t\t\tevtchn_port_t port;\n\n\t\t\tbits = MASK_LSBS(pending_bits, bit_idx);\n\n\t\t\t \n\t\t\tif (bits == 0)\n\t\t\t\tbreak;\n\n\t\t\tbit_idx = EVTCHN_FIRST_BIT(bits);\n\n\t\t\t \n\t\t\tport = (word_idx * BITS_PER_EVTCHN_WORD) + bit_idx;\n\t\t\thandle_irq_for_port(port, ctrl);\n\n\t\t\tbit_idx = (bit_idx + 1) % BITS_PER_EVTCHN_WORD;\n\n\t\t\t \n\t\t\t__this_cpu_write(current_word_idx,\n\t\t\t\t\t bit_idx ? word_idx :\n\t\t\t\t\t (word_idx+1) % BITS_PER_EVTCHN_WORD);\n\t\t\t__this_cpu_write(current_bit_idx, bit_idx);\n\t\t} while (bit_idx != 0);\n\n\t\t \n\t\tif ((word_idx != start_word_idx) || (i != 0))\n\t\t\tpending_words &= ~(1UL << word_idx);\n\n\t\tword_idx = (word_idx + 1) % BITS_PER_EVTCHN_WORD;\n\t}\n}\n\nirqreturn_t xen_debug_interrupt(int irq, void *dev_id)\n{\n\tstruct shared_info *sh = HYPERVISOR_shared_info;\n\tint cpu = smp_processor_id();\n\txen_ulong_t *cpu_evtchn = per_cpu(cpu_evtchn_mask, cpu);\n\tint i;\n\tunsigned long flags;\n\tstatic DEFINE_SPINLOCK(debug_lock);\n\tstruct vcpu_info *v;\n\n\tspin_lock_irqsave(&debug_lock, flags);\n\n\tprintk(\"\\nvcpu %d\\n  \", cpu);\n\n\tfor_each_online_cpu(i) {\n\t\tint pending;\n\t\tv = per_cpu(xen_vcpu, i);\n\t\tpending = (get_irq_regs() && i == cpu)\n\t\t\t? xen_irqs_disabled(get_irq_regs())\n\t\t\t: v->evtchn_upcall_mask;\n\t\tprintk(\"%d: masked=%d pending=%d event_sel %0*\"PRI_xen_ulong\"\\n  \", i,\n\t\t       pending, v->evtchn_upcall_pending,\n\t\t       (int)(sizeof(v->evtchn_pending_sel)*2),\n\t\t       v->evtchn_pending_sel);\n\t}\n\tv = per_cpu(xen_vcpu, cpu);\n\n\tprintk(\"\\npending:\\n   \");\n\tfor (i = ARRAY_SIZE(sh->evtchn_pending)-1; i >= 0; i--)\n\t\tprintk(\"%0*\"PRI_xen_ulong\"%s\",\n\t\t       (int)sizeof(sh->evtchn_pending[0])*2,\n\t\t       sh->evtchn_pending[i],\n\t\t       i % 8 == 0 ? \"\\n   \" : \" \");\n\tprintk(\"\\nglobal mask:\\n   \");\n\tfor (i = ARRAY_SIZE(sh->evtchn_mask)-1; i >= 0; i--)\n\t\tprintk(\"%0*\"PRI_xen_ulong\"%s\",\n\t\t       (int)(sizeof(sh->evtchn_mask[0])*2),\n\t\t       sh->evtchn_mask[i],\n\t\t       i % 8 == 0 ? \"\\n   \" : \" \");\n\n\tprintk(\"\\nglobally unmasked:\\n   \");\n\tfor (i = ARRAY_SIZE(sh->evtchn_mask)-1; i >= 0; i--)\n\t\tprintk(\"%0*\"PRI_xen_ulong\"%s\",\n\t\t       (int)(sizeof(sh->evtchn_mask[0])*2),\n\t\t       sh->evtchn_pending[i] & ~sh->evtchn_mask[i],\n\t\t       i % 8 == 0 ? \"\\n   \" : \" \");\n\n\tprintk(\"\\nlocal cpu%d mask:\\n   \", cpu);\n\tfor (i = (EVTCHN_2L_NR_CHANNELS/BITS_PER_EVTCHN_WORD)-1; i >= 0; i--)\n\t\tprintk(\"%0*\"PRI_xen_ulong\"%s\", (int)(sizeof(cpu_evtchn[0])*2),\n\t\t       cpu_evtchn[i],\n\t\t       i % 8 == 0 ? \"\\n   \" : \" \");\n\n\tprintk(\"\\nlocally unmasked:\\n   \");\n\tfor (i = ARRAY_SIZE(sh->evtchn_mask)-1; i >= 0; i--) {\n\t\txen_ulong_t pending = sh->evtchn_pending[i]\n\t\t\t& ~sh->evtchn_mask[i]\n\t\t\t& cpu_evtchn[i];\n\t\tprintk(\"%0*\"PRI_xen_ulong\"%s\",\n\t\t       (int)(sizeof(sh->evtchn_mask[0])*2),\n\t\t       pending, i % 8 == 0 ? \"\\n   \" : \" \");\n\t}\n\n\tprintk(\"\\npending list:\\n\");\n\tfor (i = 0; i < EVTCHN_2L_NR_CHANNELS; i++) {\n\t\tif (sync_test_bit(i, BM(sh->evtchn_pending))) {\n\t\t\tint word_idx = i / BITS_PER_EVTCHN_WORD;\n\t\t\tprintk(\"  %d: event %d -> irq %d%s%s%s\\n\",\n\t\t\t       cpu_from_evtchn(i), i,\n\t\t\t       get_evtchn_to_irq(i),\n\t\t\t       sync_test_bit(word_idx, BM(&v->evtchn_pending_sel))\n\t\t\t       ? \"\" : \" l2-clear\",\n\t\t\t       !sync_test_bit(i, BM(sh->evtchn_mask))\n\t\t\t       ? \"\" : \" globally-masked\",\n\t\t\t       sync_test_bit(i, BM(cpu_evtchn))\n\t\t\t       ? \"\" : \" locally-masked\");\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&debug_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void evtchn_2l_resume(void)\n{\n\tint i;\n\n\tfor_each_online_cpu(i)\n\t\tmemset(per_cpu(cpu_evtchn_mask, i), 0, sizeof(xen_ulong_t) *\n\t\t\t\tEVTCHN_2L_NR_CHANNELS/BITS_PER_EVTCHN_WORD);\n}\n\nstatic int evtchn_2l_percpu_deinit(unsigned int cpu)\n{\n\tmemset(per_cpu(cpu_evtchn_mask, cpu), 0, sizeof(xen_ulong_t) *\n\t\t\tEVTCHN_2L_NR_CHANNELS/BITS_PER_EVTCHN_WORD);\n\n\treturn 0;\n}\n\nstatic const struct evtchn_ops evtchn_ops_2l = {\n\t.max_channels      = evtchn_2l_max_channels,\n\t.nr_channels       = evtchn_2l_max_channels,\n\t.remove            = evtchn_2l_remove,\n\t.bind_to_cpu       = evtchn_2l_bind_to_cpu,\n\t.clear_pending     = evtchn_2l_clear_pending,\n\t.set_pending       = evtchn_2l_set_pending,\n\t.is_pending        = evtchn_2l_is_pending,\n\t.mask              = evtchn_2l_mask,\n\t.unmask            = evtchn_2l_unmask,\n\t.handle_events     = evtchn_2l_handle_events,\n\t.resume\t           = evtchn_2l_resume,\n\t.percpu_deinit     = evtchn_2l_percpu_deinit,\n};\n\nvoid __init xen_evtchn_2l_init(void)\n{\n\tpr_info(\"Using 2-level ABI\\n\");\n\tevtchn_ops = &evtchn_ops_2l;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}