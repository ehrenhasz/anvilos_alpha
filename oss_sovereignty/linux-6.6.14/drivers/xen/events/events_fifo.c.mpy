{
  "module_name": "events_fifo.c",
  "hash_id": "41129662864924fcb121135e3f4139e517b78f93fa204296566c41101c84c290",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/events/events_fifo.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"xen:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/linkage.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/cpu.h>\n\n#include <asm/barrier.h>\n#include <asm/sync_bitops.h>\n#include <asm/xen/hypercall.h>\n#include <asm/xen/hypervisor.h>\n\n#include <xen/xen.h>\n#include <xen/xen-ops.h>\n#include <xen/events.h>\n#include <xen/interface/xen.h>\n#include <xen/interface/event_channel.h>\n#include <xen/page.h>\n\n#include \"events_internal.h\"\n\n#define EVENT_WORDS_PER_PAGE (XEN_PAGE_SIZE / sizeof(event_word_t))\n#define MAX_EVENT_ARRAY_PAGES (EVTCHN_FIFO_NR_CHANNELS / EVENT_WORDS_PER_PAGE)\n\nstruct evtchn_fifo_queue {\n\tuint32_t head[EVTCHN_FIFO_MAX_QUEUES];\n};\n\nstatic DEFINE_PER_CPU(struct evtchn_fifo_control_block *, cpu_control_block);\nstatic DEFINE_PER_CPU(struct evtchn_fifo_queue, cpu_queue);\nstatic event_word_t *event_array[MAX_EVENT_ARRAY_PAGES] __read_mostly;\nstatic unsigned event_array_pages __read_mostly;\n\n \n#if BITS_PER_LONG > 32\n\n#define BM(w) (unsigned long *)((unsigned long)w & ~0x7UL)\n#define EVTCHN_FIFO_BIT(b, w) \\\n    (((unsigned long)w & 0x4UL) ? (EVTCHN_FIFO_ ##b + 32) : EVTCHN_FIFO_ ##b)\n\n#else\n\n#define BM(w) ((unsigned long *)(w))\n#define EVTCHN_FIFO_BIT(b, w) EVTCHN_FIFO_ ##b\n\n#endif\n\nstatic inline event_word_t *event_word_from_port(evtchn_port_t port)\n{\n\tunsigned i = port / EVENT_WORDS_PER_PAGE;\n\n\treturn event_array[i] + port % EVENT_WORDS_PER_PAGE;\n}\n\nstatic unsigned evtchn_fifo_max_channels(void)\n{\n\treturn EVTCHN_FIFO_NR_CHANNELS;\n}\n\nstatic unsigned evtchn_fifo_nr_channels(void)\n{\n\treturn event_array_pages * EVENT_WORDS_PER_PAGE;\n}\n\nstatic int init_control_block(int cpu,\n                              struct evtchn_fifo_control_block *control_block)\n{\n\tstruct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);\n\tstruct evtchn_init_control init_control;\n\tunsigned int i;\n\n\t \n\tclear_page(control_block);\n\tfor (i = 0; i < EVTCHN_FIFO_MAX_QUEUES; i++)\n\t\tq->head[i] = 0;\n\n\tinit_control.control_gfn = virt_to_gfn(control_block);\n\tinit_control.offset      = 0;\n\tinit_control.vcpu        = xen_vcpu_nr(cpu);\n\n\treturn HYPERVISOR_event_channel_op(EVTCHNOP_init_control, &init_control);\n}\n\nstatic void free_unused_array_pages(void)\n{\n\tunsigned i;\n\n\tfor (i = event_array_pages; i < MAX_EVENT_ARRAY_PAGES; i++) {\n\t\tif (!event_array[i])\n\t\t\tbreak;\n\t\tfree_page((unsigned long)event_array[i]);\n\t\tevent_array[i] = NULL;\n\t}\n}\n\nstatic void init_array_page(event_word_t *array_page)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < EVENT_WORDS_PER_PAGE; i++)\n\t\tarray_page[i] = 1 << EVTCHN_FIFO_MASKED;\n}\n\nstatic int evtchn_fifo_setup(evtchn_port_t port)\n{\n\tunsigned new_array_pages;\n\tint ret;\n\n\tnew_array_pages = port / EVENT_WORDS_PER_PAGE + 1;\n\n\tif (new_array_pages > MAX_EVENT_ARRAY_PAGES)\n\t\treturn -EINVAL;\n\n\twhile (event_array_pages < new_array_pages) {\n\t\tvoid *array_page;\n\t\tstruct evtchn_expand_array expand_array;\n\n\t\t \n\t\tarray_page = event_array[event_array_pages];\n\t\tif (!array_page) {\n\t\t\tarray_page = (void *)__get_free_page(GFP_KERNEL);\n\t\t\tif (array_page == NULL) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tevent_array[event_array_pages] = array_page;\n\t\t}\n\n\t\t \n\t\tinit_array_page(array_page);\n\n\t\texpand_array.array_gfn = virt_to_gfn(array_page);\n\n\t\tret = HYPERVISOR_event_channel_op(EVTCHNOP_expand_array, &expand_array);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tevent_array_pages++;\n\t}\n\treturn 0;\n\n  error:\n\tif (event_array_pages == 0)\n\t\tpanic(\"xen: unable to expand event array with initial page (%d)\\n\", ret);\n\telse\n\t\tpr_err(\"unable to expand event array (%d)\\n\", ret);\n\tfree_unused_array_pages();\n\treturn ret;\n}\n\nstatic void evtchn_fifo_bind_to_cpu(evtchn_port_t evtchn, unsigned int cpu, \n\t\t\t\t    unsigned int old_cpu)\n{\n\t \n}\n\nstatic void evtchn_fifo_clear_pending(evtchn_port_t port)\n{\n\tevent_word_t *word = event_word_from_port(port);\n\tsync_clear_bit(EVTCHN_FIFO_BIT(PENDING, word), BM(word));\n}\n\nstatic void evtchn_fifo_set_pending(evtchn_port_t port)\n{\n\tevent_word_t *word = event_word_from_port(port);\n\tsync_set_bit(EVTCHN_FIFO_BIT(PENDING, word), BM(word));\n}\n\nstatic bool evtchn_fifo_is_pending(evtchn_port_t port)\n{\n\tevent_word_t *word = event_word_from_port(port);\n\treturn sync_test_bit(EVTCHN_FIFO_BIT(PENDING, word), BM(word));\n}\n\nstatic void evtchn_fifo_mask(evtchn_port_t port)\n{\n\tevent_word_t *word = event_word_from_port(port);\n\tsync_set_bit(EVTCHN_FIFO_BIT(MASKED, word), BM(word));\n}\n\nstatic bool evtchn_fifo_is_masked(evtchn_port_t port)\n{\n\tevent_word_t *word = event_word_from_port(port);\n\treturn sync_test_bit(EVTCHN_FIFO_BIT(MASKED, word), BM(word));\n}\n \nstatic bool clear_masked_cond(volatile event_word_t *word)\n{\n\tevent_word_t new, old, w;\n\n\tw = *word;\n\n\tdo {\n\t\tif (!(w & (1 << EVTCHN_FIFO_MASKED)))\n\t\t\treturn true;\n\n\t\tif (w & (1 << EVTCHN_FIFO_PENDING))\n\t\t\treturn false;\n\n\t\told = w & ~(1 << EVTCHN_FIFO_BUSY);\n\t\tnew = old & ~(1 << EVTCHN_FIFO_MASKED);\n\t\tw = sync_cmpxchg(word, old, new);\n\t} while (w != old);\n\n\treturn true;\n}\n\nstatic void evtchn_fifo_unmask(evtchn_port_t port)\n{\n\tevent_word_t *word = event_word_from_port(port);\n\n\tBUG_ON(!irqs_disabled());\n\n\tif (!clear_masked_cond(word)) {\n\t\tstruct evtchn_unmask unmask = { .port = port };\n\t\t(void)HYPERVISOR_event_channel_op(EVTCHNOP_unmask, &unmask);\n\t}\n}\n\nstatic uint32_t clear_linked(volatile event_word_t *word)\n{\n\tevent_word_t new, old, w;\n\n\tw = *word;\n\n\tdo {\n\t\told = w;\n\t\tnew = (w & ~((1 << EVTCHN_FIFO_LINKED)\n\t\t\t     | EVTCHN_FIFO_LINK_MASK));\n\t} while ((w = sync_cmpxchg(word, old, new)) != old);\n\n\treturn w & EVTCHN_FIFO_LINK_MASK;\n}\n\nstatic void consume_one_event(unsigned cpu, struct evtchn_loop_ctrl *ctrl,\n\t\t\t      struct evtchn_fifo_control_block *control_block,\n\t\t\t      unsigned priority, unsigned long *ready)\n{\n\tstruct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);\n\tuint32_t head;\n\tevtchn_port_t port;\n\tevent_word_t *word;\n\n\thead = q->head[priority];\n\n\t \n\tif (head == 0) {\n\t\tvirt_rmb();  \n\t\thead = control_block->head[priority];\n\t}\n\n\tport = head;\n\tword = event_word_from_port(port);\n\thead = clear_linked(word);\n\n\t \n\tif (head == 0)\n\t\tclear_bit(priority, ready);\n\n\tif (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {\n\t\tif (unlikely(!ctrl))\n\t\t\tpr_warn(\"Dropping pending event for port %u\\n\", port);\n\t\telse\n\t\t\thandle_irq_for_port(port, ctrl);\n\t}\n\n\tq->head[priority] = head;\n}\n\nstatic void __evtchn_fifo_handle_events(unsigned cpu,\n\t\t\t\t\tstruct evtchn_loop_ctrl *ctrl)\n{\n\tstruct evtchn_fifo_control_block *control_block;\n\tunsigned long ready;\n\tunsigned q;\n\n\tcontrol_block = per_cpu(cpu_control_block, cpu);\n\n\tready = xchg(&control_block->ready, 0);\n\n\twhile (ready) {\n\t\tq = find_first_bit(&ready, EVTCHN_FIFO_MAX_QUEUES);\n\t\tconsume_one_event(cpu, ctrl, control_block, q, &ready);\n\t\tready |= xchg(&control_block->ready, 0);\n\t}\n}\n\nstatic void evtchn_fifo_handle_events(unsigned cpu,\n\t\t\t\t      struct evtchn_loop_ctrl *ctrl)\n{\n\t__evtchn_fifo_handle_events(cpu, ctrl);\n}\n\nstatic void evtchn_fifo_resume(void)\n{\n\tunsigned cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tvoid *control_block = per_cpu(cpu_control_block, cpu);\n\t\tint ret;\n\n\t\tif (!control_block)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!cpu_online(cpu)) {\n\t\t\tfree_page((unsigned long)control_block);\n\t\t\tper_cpu(cpu_control_block, cpu) = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = init_control_block(cpu, control_block);\n\t\tBUG_ON(ret < 0);\n\t}\n\n\t \n\tevent_array_pages = 0;\n}\n\nstatic int evtchn_fifo_alloc_control_block(unsigned cpu)\n{\n\tvoid *control_block = NULL;\n\tint ret = -ENOMEM;\n\n\tcontrol_block = (void *)__get_free_page(GFP_KERNEL);\n\tif (control_block == NULL)\n\t\tgoto error;\n\n\tret = init_control_block(cpu, control_block);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tper_cpu(cpu_control_block, cpu) = control_block;\n\n\treturn 0;\n\n  error:\n\tfree_page((unsigned long)control_block);\n\treturn ret;\n}\n\nstatic int evtchn_fifo_percpu_init(unsigned int cpu)\n{\n\tif (!per_cpu(cpu_control_block, cpu))\n\t\treturn evtchn_fifo_alloc_control_block(cpu);\n\treturn 0;\n}\n\nstatic int evtchn_fifo_percpu_deinit(unsigned int cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, NULL);\n\treturn 0;\n}\n\nstatic const struct evtchn_ops evtchn_ops_fifo = {\n\t.max_channels      = evtchn_fifo_max_channels,\n\t.nr_channels       = evtchn_fifo_nr_channels,\n\t.setup             = evtchn_fifo_setup,\n\t.bind_to_cpu       = evtchn_fifo_bind_to_cpu,\n\t.clear_pending     = evtchn_fifo_clear_pending,\n\t.set_pending       = evtchn_fifo_set_pending,\n\t.is_pending        = evtchn_fifo_is_pending,\n\t.mask              = evtchn_fifo_mask,\n\t.unmask            = evtchn_fifo_unmask,\n\t.handle_events     = evtchn_fifo_handle_events,\n\t.resume            = evtchn_fifo_resume,\n\t.percpu_init       = evtchn_fifo_percpu_init,\n\t.percpu_deinit     = evtchn_fifo_percpu_deinit,\n};\n\nint __init xen_evtchn_fifo_init(void)\n{\n\tint cpu = smp_processor_id();\n\tint ret;\n\n\tret = evtchn_fifo_alloc_control_block(cpu);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpr_info(\"Using FIFO-based ABI\\n\");\n\n\tevtchn_ops = &evtchn_ops_fifo;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}