{
  "module_name": "xen-scsiback.c",
  "hash_id": "69a1c3d453d8633f38a7935fb9589164db0a44f7fc20fa212956d0565cd54f3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-scsiback.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"xen-pvscsi: \" fmt\n\n#include <linux/module.h>\n#include <linux/utsname.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/configfs.h>\n\n#include <generated/utsrelease.h>\n\n#include <scsi/scsi_host.h>  \n\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include <asm/hypervisor.h>\n\n#include <xen/xen.h>\n#include <xen/balloon.h>\n#include <xen/events.h>\n#include <xen/xenbus.h>\n#include <xen/grant_table.h>\n#include <xen/page.h>\n\n#include <xen/interface/grant_table.h>\n#include <xen/interface/io/vscsiif.h>\n\n#define VSCSI_VERSION\t\"v0.1\"\n#define VSCSI_NAMELEN\t32\n\nstruct ids_tuple {\n\tunsigned int hst;\t\t \n\tunsigned int chn;\t\t \n\tunsigned int tgt;\t\t \n\tunsigned int lun;\t\t \n};\n\nstruct v2p_entry {\n\tstruct ids_tuple v;\t\t \n\tstruct scsiback_tpg *tpg;\t \n\tunsigned int lun;\n\tstruct kref kref;\n\tstruct list_head l;\n};\n\nstruct vscsibk_info {\n\tstruct xenbus_device *dev;\n\n\tdomid_t domid;\n\tunsigned int irq;\n\n\tstruct vscsiif_back_ring ring;\n\n\tspinlock_t ring_lock;\n\tatomic_t nr_unreplied_reqs;\n\n\tspinlock_t v2p_lock;\n\tstruct list_head v2p_entry_lists;\n\n\twait_queue_head_t waiting_to_free;\n\n\tstruct gnttab_page_cache free_pages;\n};\n\n \n#define VSCSI_MAX_GRANTS\t(SG_ALL + VSCSIIF_SG_TABLESIZE)\n\n \n#define VSCSI_GRANT_BATCH\t16\n\nstruct vscsibk_pend {\n\tuint16_t rqid;\n\n\tuint8_t cmnd[VSCSIIF_MAX_COMMAND_SIZE];\n\tuint8_t cmd_len;\n\n\tuint8_t sc_data_direction;\n\tuint16_t n_sg;\t\t \n\tuint16_t n_grants;\t \n\tuint32_t data_len;\n\tuint32_t result;\n\n\tstruct vscsibk_info *info;\n\tstruct v2p_entry *v2p;\n\tstruct scatterlist *sgl;\n\n\tuint8_t sense_buffer[VSCSIIF_SENSE_BUFFERSIZE];\n\n\tgrant_handle_t grant_handles[VSCSI_MAX_GRANTS];\n\tstruct page *pages[VSCSI_MAX_GRANTS];\n\n\tstruct se_cmd se_cmd;\n\n\tstruct completion tmr_done;\n};\n\n#define VSCSI_DEFAULT_SESSION_TAGS\t128\n\nstruct scsiback_nexus {\n\t \n\tstruct se_session *tvn_se_sess;\n};\n\nstruct scsiback_tport {\n\t \n\tu8 tport_proto_id;\n\t \n\tu64 tport_wwpn;\n\t \n\tchar tport_name[VSCSI_NAMELEN];\n\t \n\tstruct se_wwn tport_wwn;\n};\n\nstruct scsiback_tpg {\n\t \n\tu16 tport_tpgt;\n\t \n\tint tv_tpg_port_count;\n\t \n\tint tv_tpg_fe_count;\n\t \n\tstruct list_head tv_tpg_list;\n\t \n\tstruct mutex tv_tpg_mutex;\n\t \n\tstruct scsiback_nexus *tpg_nexus;\n\t \n\tstruct scsiback_tport *tport;\n\t \n\tstruct se_portal_group se_tpg;\n\t \n\tchar param_alias[VSCSI_NAMELEN];\n\t \n\tstruct list_head info_list;\n};\n\n#define SCSIBACK_INVALID_HANDLE (~0)\n\nstatic bool log_print_stat;\nmodule_param(log_print_stat, bool, 0644);\n\nstatic int scsiback_max_buffer_pages = 1024;\nmodule_param_named(max_buffer_pages, scsiback_max_buffer_pages, int, 0644);\nMODULE_PARM_DESC(max_buffer_pages,\n\"Maximum number of free pages to keep in backend buffer\");\n\n \nstatic DEFINE_MUTEX(scsiback_mutex);\nstatic LIST_HEAD(scsiback_list);\n\nstatic void scsiback_get(struct vscsibk_info *info)\n{\n\tatomic_inc(&info->nr_unreplied_reqs);\n}\n\nstatic void scsiback_put(struct vscsibk_info *info)\n{\n\tif (atomic_dec_and_test(&info->nr_unreplied_reqs))\n\t\twake_up(&info->waiting_to_free);\n}\n\nstatic unsigned long vaddr_page(struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\n\treturn (unsigned long)pfn_to_kaddr(pfn);\n}\n\nstatic unsigned long vaddr(struct vscsibk_pend *req, int seg)\n{\n\treturn vaddr_page(req->pages[seg]);\n}\n\nstatic void scsiback_print_status(char *sense_buffer, int errors,\n\t\t\t\t\tstruct vscsibk_pend *pending_req)\n{\n\tstruct scsiback_tpg *tpg = pending_req->v2p->tpg;\n\n\tpr_err(\"[%s:%d] cmnd[0]=%02x -> st=%02x msg=%02x host=%02x\\n\",\n\t       tpg->tport->tport_name, pending_req->v2p->lun,\n\t       pending_req->cmnd[0], errors & 0xff, COMMAND_COMPLETE,\n\t       host_byte(errors));\n}\n\nstatic void scsiback_fast_flush_area(struct vscsibk_pend *req)\n{\n\tstruct gnttab_unmap_grant_ref unmap[VSCSI_GRANT_BATCH];\n\tstruct page *pages[VSCSI_GRANT_BATCH];\n\tunsigned int i, invcount = 0;\n\tgrant_handle_t handle;\n\tint err;\n\n\tkfree(req->sgl);\n\treq->sgl = NULL;\n\treq->n_sg = 0;\n\n\tif (!req->n_grants)\n\t\treturn;\n\n\tfor (i = 0; i < req->n_grants; i++) {\n\t\thandle = req->grant_handles[i];\n\t\tif (handle == SCSIBACK_INVALID_HANDLE)\n\t\t\tcontinue;\n\t\tgnttab_set_unmap_op(&unmap[invcount], vaddr(req, i),\n\t\t\t\t    GNTMAP_host_map, handle);\n\t\treq->grant_handles[i] = SCSIBACK_INVALID_HANDLE;\n\t\tpages[invcount] = req->pages[i];\n\t\tput_page(pages[invcount]);\n\t\tinvcount++;\n\t\tif (invcount < VSCSI_GRANT_BATCH)\n\t\t\tcontinue;\n\t\terr = gnttab_unmap_refs(unmap, NULL, pages, invcount);\n\t\tBUG_ON(err);\n\t\tinvcount = 0;\n\t}\n\n\tif (invcount) {\n\t\terr = gnttab_unmap_refs(unmap, NULL, pages, invcount);\n\t\tBUG_ON(err);\n\t}\n\n\tgnttab_page_cache_put(&req->info->free_pages, req->pages,\n\t\t\t      req->n_grants);\n\treq->n_grants = 0;\n}\n\nstatic void scsiback_free_translation_entry(struct kref *kref)\n{\n\tstruct v2p_entry *entry = container_of(kref, struct v2p_entry, kref);\n\tstruct scsiback_tpg *tpg = entry->tpg;\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\ttpg->tv_tpg_fe_count--;\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n\n\tkfree(entry);\n}\n\nstatic int32_t scsiback_result(int32_t result)\n{\n\tint32_t host_status;\n\n\tswitch (XEN_VSCSIIF_RSLT_HOST(result)) {\n\tcase DID_OK:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_OK;\n\t\tbreak;\n\tcase DID_NO_CONNECT:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_NO_CONNECT;\n\t\tbreak;\n\tcase DID_BUS_BUSY:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_BUS_BUSY;\n\t\tbreak;\n\tcase DID_TIME_OUT:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_TIME_OUT;\n\t\tbreak;\n\tcase DID_BAD_TARGET:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_BAD_TARGET;\n\t\tbreak;\n\tcase DID_ABORT:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_ABORT;\n\t\tbreak;\n\tcase DID_PARITY:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_PARITY;\n\t\tbreak;\n\tcase DID_ERROR:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_ERROR;\n\t\tbreak;\n\tcase DID_RESET:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_RESET;\n\t\tbreak;\n\tcase DID_BAD_INTR:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_BAD_INTR;\n\t\tbreak;\n\tcase DID_PASSTHROUGH:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_PASSTHROUGH;\n\t\tbreak;\n\tcase DID_SOFT_ERROR:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_SOFT_ERROR;\n\t\tbreak;\n\tcase DID_IMM_RETRY:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_IMM_RETRY;\n\t\tbreak;\n\tcase DID_REQUEUE:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_REQUEUE;\n\t\tbreak;\n\tcase DID_TRANSPORT_DISRUPTED:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_TRANSPORT_DISRUPTED;\n\t\tbreak;\n\tcase DID_TRANSPORT_FAILFAST:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_TRANSPORT_FAILFAST;\n\t\tbreak;\n\tcase DID_TRANSPORT_MARGINAL:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_TRANSPORT_MARGINAL;\n\t\tbreak;\n\tdefault:\n\t\thost_status = XEN_VSCSIIF_RSLT_HOST_ERROR;\n\t\tbreak;\n\t}\n\n\treturn (host_status << 16) | (result & 0x00ffff);\n}\n\nstatic void scsiback_send_response(struct vscsibk_info *info,\n\t\t\tchar *sense_buffer, int32_t result, uint32_t resid,\n\t\t\tuint16_t rqid)\n{\n\tstruct vscsiif_response *ring_res;\n\tint notify;\n\tstruct scsi_sense_hdr sshdr;\n\tunsigned long flags;\n\tunsigned len;\n\n\tspin_lock_irqsave(&info->ring_lock, flags);\n\n\tring_res = RING_GET_RESPONSE(&info->ring, info->ring.rsp_prod_pvt);\n\tinfo->ring.rsp_prod_pvt++;\n\n\tring_res->rslt   = scsiback_result(result);\n\tring_res->rqid   = rqid;\n\n\tif (sense_buffer != NULL &&\n\t    scsi_normalize_sense(sense_buffer, VSCSIIF_SENSE_BUFFERSIZE,\n\t\t\t\t &sshdr)) {\n\t\tlen = min_t(unsigned, 8 + sense_buffer[7],\n\t\t\t    VSCSIIF_SENSE_BUFFERSIZE);\n\t\tmemcpy(ring_res->sense_buffer, sense_buffer, len);\n\t\tring_res->sense_len = len;\n\t} else {\n\t\tring_res->sense_len = 0;\n\t}\n\n\tring_res->residual_len = resid;\n\n\tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&info->ring, notify);\n\tspin_unlock_irqrestore(&info->ring_lock, flags);\n\n\tif (notify)\n\t\tnotify_remote_via_irq(info->irq);\n}\n\nstatic void scsiback_do_resp_with_sense(char *sense_buffer, int32_t result,\n\t\t\tuint32_t resid, struct vscsibk_pend *pending_req)\n{\n\tscsiback_send_response(pending_req->info, sense_buffer, result,\n\t\t\t       resid, pending_req->rqid);\n\n\tif (pending_req->v2p)\n\t\tkref_put(&pending_req->v2p->kref,\n\t\t\t scsiback_free_translation_entry);\n}\n\nstatic void scsiback_cmd_done(struct vscsibk_pend *pending_req)\n{\n\tstruct vscsibk_info *info = pending_req->info;\n\tunsigned char *sense_buffer;\n\tunsigned int resid;\n\tint errors;\n\n\tsense_buffer = pending_req->sense_buffer;\n\tresid        = pending_req->se_cmd.residual_count;\n\terrors       = pending_req->result;\n\n\tif (errors && log_print_stat)\n\t\tscsiback_print_status(sense_buffer, errors, pending_req);\n\n\tscsiback_fast_flush_area(pending_req);\n\tscsiback_do_resp_with_sense(sense_buffer, errors, resid, pending_req);\n\tscsiback_put(info);\n\t \n\ttarget_put_sess_cmd(&pending_req->se_cmd);\n}\n\nstatic void scsiback_cmd_exec(struct vscsibk_pend *pending_req)\n{\n\tstruct se_cmd *se_cmd = &pending_req->se_cmd;\n\tstruct se_session *sess = pending_req->v2p->tpg->tpg_nexus->tvn_se_sess;\n\n\tscsiback_get(pending_req->info);\n\tse_cmd->tag = pending_req->rqid;\n\ttarget_init_cmd(se_cmd, sess, pending_req->sense_buffer,\n\t\t\tpending_req->v2p->lun, pending_req->data_len, 0,\n\t\t\tpending_req->sc_data_direction, TARGET_SCF_ACK_KREF);\n\n\tif (target_submit_prep(se_cmd, pending_req->cmnd, pending_req->sgl,\n\t\t\t       pending_req->n_sg, NULL, 0, NULL, 0, GFP_KERNEL))\n\t\treturn;\n\n\ttarget_submit(se_cmd);\n}\n\nstatic int scsiback_gnttab_data_map_batch(struct gnttab_map_grant_ref *map,\n\tstruct page **pg, grant_handle_t *grant, int cnt)\n{\n\tint err, i;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\terr = gnttab_map_refs(map, NULL, pg, cnt);\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (unlikely(map[i].status != GNTST_okay)) {\n\t\t\tpr_err(\"invalid buffer -- could not remap it\\n\");\n\t\t\tmap[i].handle = SCSIBACK_INVALID_HANDLE;\n\t\t\tif (!err)\n\t\t\t\terr = -ENOMEM;\n\t\t} else {\n\t\t\tget_page(pg[i]);\n\t\t}\n\t\tgrant[i] = map[i].handle;\n\t}\n\treturn err;\n}\n\nstatic int scsiback_gnttab_data_map_list(struct vscsibk_pend *pending_req,\n\t\t\tstruct scsiif_request_segment *seg, struct page **pg,\n\t\t\tgrant_handle_t *grant, int cnt, u32 flags)\n{\n\tint mapcount = 0, i, err = 0;\n\tstruct gnttab_map_grant_ref map[VSCSI_GRANT_BATCH];\n\tstruct vscsibk_info *info = pending_req->info;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (gnttab_page_cache_get(&info->free_pages, pg + mapcount)) {\n\t\t\tgnttab_page_cache_put(&info->free_pages, pg, mapcount);\n\t\t\tpr_err(\"no grant page\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tgnttab_set_map_op(&map[mapcount], vaddr_page(pg[mapcount]),\n\t\t\t\t  flags, seg[i].gref, info->domid);\n\t\tmapcount++;\n\t\tif (mapcount < VSCSI_GRANT_BATCH)\n\t\t\tcontinue;\n\t\terr = scsiback_gnttab_data_map_batch(map, pg, grant, mapcount);\n\t\tpg += mapcount;\n\t\tgrant += mapcount;\n\t\tpending_req->n_grants += mapcount;\n\t\tif (err)\n\t\t\treturn err;\n\t\tmapcount = 0;\n\t}\n\terr = scsiback_gnttab_data_map_batch(map, pg, grant, mapcount);\n\tpending_req->n_grants += mapcount;\n\treturn err;\n}\n\nstatic int scsiback_gnttab_data_map(struct vscsiif_request *ring_req,\n\t\t\t\t\tstruct vscsibk_pend *pending_req)\n{\n\tu32 flags;\n\tint i, err, n_segs, i_seg = 0;\n\tstruct page **pg;\n\tstruct scsiif_request_segment *seg;\n\tunsigned long end_seg = 0;\n\tunsigned int nr_segments = (unsigned int)ring_req->nr_segments;\n\tunsigned int nr_sgl = 0;\n\tstruct scatterlist *sg;\n\tgrant_handle_t *grant;\n\n\tpending_req->n_sg = 0;\n\tpending_req->n_grants = 0;\n\tpending_req->data_len = 0;\n\n\tnr_segments &= ~VSCSIIF_SG_GRANT;\n\tif (!nr_segments)\n\t\treturn 0;\n\n\tif (nr_segments > VSCSIIF_SG_TABLESIZE) {\n\t\tpr_debug(\"invalid parameter nr_seg = %d\\n\",\n\t\t\tring_req->nr_segments);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ring_req->nr_segments & VSCSIIF_SG_GRANT) {\n\t\terr = scsiback_gnttab_data_map_list(pending_req, ring_req->seg,\n\t\t\tpending_req->pages, pending_req->grant_handles,\n\t\t\tnr_segments, GNTMAP_host_map | GNTMAP_readonly);\n\t\tif (err)\n\t\t\treturn err;\n\t\tnr_sgl = nr_segments;\n\t\tnr_segments = 0;\n\t\tfor (i = 0; i < nr_sgl; i++) {\n\t\t\tn_segs = ring_req->seg[i].length /\n\t\t\t\t sizeof(struct scsiif_request_segment);\n\t\t\tif ((unsigned)ring_req->seg[i].offset +\n\t\t\t    (unsigned)ring_req->seg[i].length > PAGE_SIZE ||\n\t\t\t    n_segs * sizeof(struct scsiif_request_segment) !=\n\t\t\t    ring_req->seg[i].length)\n\t\t\t\treturn -EINVAL;\n\t\t\tnr_segments += n_segs;\n\t\t}\n\t\tif (nr_segments > SG_ALL) {\n\t\t\tpr_debug(\"invalid nr_seg = %d\\n\", nr_segments);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tpending_req->sgl = kmalloc_array(nr_segments,\n\t\t\t\t\tsizeof(struct scatterlist), GFP_KERNEL);\n\tif (!pending_req->sgl)\n\t\treturn -ENOMEM;\n\n\tsg_init_table(pending_req->sgl, nr_segments);\n\tpending_req->n_sg = nr_segments;\n\n\tflags = GNTMAP_host_map;\n\tif (pending_req->sc_data_direction == DMA_TO_DEVICE)\n\t\tflags |= GNTMAP_readonly;\n\n\tpg = pending_req->pages + nr_sgl;\n\tgrant = pending_req->grant_handles + nr_sgl;\n\tif (!nr_sgl) {\n\t\tseg = ring_req->seg;\n\t\terr = scsiback_gnttab_data_map_list(pending_req, seg,\n\t\t\tpg, grant, nr_segments, flags);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tfor (i = 0; i < nr_sgl; i++) {\n\t\t\tseg = (struct scsiif_request_segment *)(\n\t\t\t      vaddr(pending_req, i) + ring_req->seg[i].offset);\n\t\t\tn_segs = ring_req->seg[i].length /\n\t\t\t\t sizeof(struct scsiif_request_segment);\n\t\t\terr = scsiback_gnttab_data_map_list(pending_req, seg,\n\t\t\t\tpg, grant, n_segs, flags);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tpg += n_segs;\n\t\t\tgrant += n_segs;\n\t\t}\n\t\tend_seg = vaddr(pending_req, 0) + ring_req->seg[0].offset;\n\t\tseg = (struct scsiif_request_segment *)end_seg;\n\t\tend_seg += ring_req->seg[0].length;\n\t\tpg = pending_req->pages + nr_sgl;\n\t}\n\n\tfor_each_sg(pending_req->sgl, sg, nr_segments, i) {\n\t\tsg_set_page(sg, pg[i], seg->length, seg->offset);\n\t\tpending_req->data_len += seg->length;\n\t\tseg++;\n\t\tif (nr_sgl && (unsigned long)seg >= end_seg) {\n\t\t\ti_seg++;\n\t\t\tend_seg = vaddr(pending_req, i_seg) +\n\t\t\t\t  ring_req->seg[i_seg].offset;\n\t\t\tseg = (struct scsiif_request_segment *)end_seg;\n\t\t\tend_seg += ring_req->seg[i_seg].length;\n\t\t}\n\t\tif (sg->offset >= PAGE_SIZE ||\n\t\t    sg->length > PAGE_SIZE ||\n\t\t    sg->offset + sg->length > PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void scsiback_disconnect(struct vscsibk_info *info)\n{\n\twait_event(info->waiting_to_free,\n\t\tatomic_read(&info->nr_unreplied_reqs) == 0);\n\n\tunbind_from_irqhandler(info->irq, info);\n\tinfo->irq = 0;\n\txenbus_unmap_ring_vfree(info->dev, info->ring.sring);\n}\n\nstatic void scsiback_device_action(struct vscsibk_pend *pending_req,\n\tenum tcm_tmreq_table act, int tag)\n{\n\tstruct scsiback_tpg *tpg = pending_req->v2p->tpg;\n\tstruct scsiback_nexus *nexus = tpg->tpg_nexus;\n\tstruct se_cmd *se_cmd = &pending_req->se_cmd;\n\tu64 unpacked_lun = pending_req->v2p->lun;\n\tint rc, err = XEN_VSCSIIF_RSLT_RESET_FAILED;\n\n\tinit_completion(&pending_req->tmr_done);\n\n\trc = target_submit_tmr(&pending_req->se_cmd, nexus->tvn_se_sess,\n\t\t\t       &pending_req->sense_buffer[0],\n\t\t\t       unpacked_lun, NULL, act, GFP_KERNEL,\n\t\t\t       tag, TARGET_SCF_ACK_KREF);\n\tif (rc)\n\t\tgoto err;\n\n\twait_for_completion(&pending_req->tmr_done);\n\n\terr = (se_cmd->se_tmr_req->response == TMR_FUNCTION_COMPLETE) ?\n\t\tXEN_VSCSIIF_RSLT_RESET_SUCCESS : XEN_VSCSIIF_RSLT_RESET_FAILED;\n\n\tscsiback_do_resp_with_sense(NULL, err, 0, pending_req);\n\ttransport_generic_free_cmd(&pending_req->se_cmd, 0);\n\treturn;\n\nerr:\n\tscsiback_do_resp_with_sense(NULL, err, 0, pending_req);\n}\n\n \nstatic struct v2p_entry *scsiback_do_translation(struct vscsibk_info *info,\n\t\t\tstruct ids_tuple *v)\n{\n\tstruct v2p_entry *entry;\n\tstruct list_head *head = &(info->v2p_entry_lists);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->v2p_lock, flags);\n\tlist_for_each_entry(entry, head, l) {\n\t\tif ((entry->v.chn == v->chn) &&\n\t\t    (entry->v.tgt == v->tgt) &&\n\t\t    (entry->v.lun == v->lun)) {\n\t\t\tkref_get(&entry->kref);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tentry = NULL;\n\nout:\n\tspin_unlock_irqrestore(&info->v2p_lock, flags);\n\treturn entry;\n}\n\nstatic struct vscsibk_pend *scsiback_get_pend_req(struct vscsiif_back_ring *ring,\n\t\t\t\tstruct v2p_entry *v2p)\n{\n\tstruct scsiback_tpg *tpg = v2p->tpg;\n\tstruct scsiback_nexus *nexus = tpg->tpg_nexus;\n\tstruct se_session *se_sess = nexus->tvn_se_sess;\n\tstruct vscsibk_pend *req;\n\tint tag, cpu, i;\n\n\ttag = sbitmap_queue_get(&se_sess->sess_tag_pool, &cpu);\n\tif (tag < 0) {\n\t\tpr_err(\"Unable to obtain tag for vscsiif_request\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treq = &((struct vscsibk_pend *)se_sess->sess_cmd_map)[tag];\n\tmemset(req, 0, sizeof(*req));\n\treq->se_cmd.map_tag = tag;\n\treq->se_cmd.map_cpu = cpu;\n\n\tfor (i = 0; i < VSCSI_MAX_GRANTS; i++)\n\t\treq->grant_handles[i] = SCSIBACK_INVALID_HANDLE;\n\n\treturn req;\n}\n\nstatic struct vscsibk_pend *prepare_pending_reqs(struct vscsibk_info *info,\n\t\t\t\tstruct vscsiif_back_ring *ring,\n\t\t\t\tstruct vscsiif_request *ring_req)\n{\n\tstruct vscsibk_pend *pending_req;\n\tstruct v2p_entry *v2p;\n\tstruct ids_tuple vir;\n\n\t \n\tif ((ring_req->sc_data_direction != DMA_BIDIRECTIONAL) &&\n\t\t(ring_req->sc_data_direction != DMA_TO_DEVICE) &&\n\t\t(ring_req->sc_data_direction != DMA_FROM_DEVICE) &&\n\t\t(ring_req->sc_data_direction != DMA_NONE)) {\n\t\tpr_debug(\"invalid parameter data_dir = %d\\n\",\n\t\t\tring_req->sc_data_direction);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (ring_req->cmd_len > VSCSIIF_MAX_COMMAND_SIZE) {\n\t\tpr_debug(\"invalid parameter cmd_len = %d\\n\",\n\t\t\tring_req->cmd_len);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tvir.chn = ring_req->channel;\n\tvir.tgt = ring_req->id;\n\tvir.lun = ring_req->lun;\n\n\tv2p = scsiback_do_translation(info, &vir);\n\tif (!v2p) {\n\t\tpr_debug(\"the v2p of (chn:%d, tgt:%d, lun:%d) doesn't exist.\\n\",\n\t\t\t vir.chn, vir.tgt, vir.lun);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tpending_req = scsiback_get_pend_req(ring, v2p);\n\tif (IS_ERR(pending_req)) {\n\t\tkref_put(&v2p->kref, scsiback_free_translation_entry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tpending_req->rqid = ring_req->rqid;\n\tpending_req->info = info;\n\tpending_req->v2p = v2p;\n\tpending_req->sc_data_direction = ring_req->sc_data_direction;\n\tpending_req->cmd_len = ring_req->cmd_len;\n\tmemcpy(pending_req->cmnd, ring_req->cmnd, pending_req->cmd_len);\n\n\treturn pending_req;\n}\n\nstatic int scsiback_do_cmd_fn(struct vscsibk_info *info,\n\t\t\t      unsigned int *eoi_flags)\n{\n\tstruct vscsiif_back_ring *ring = &info->ring;\n\tstruct vscsiif_request ring_req;\n\tstruct vscsibk_pend *pending_req;\n\tRING_IDX rc, rp;\n\tint more_to_do;\n\tuint32_t result;\n\n\trc = ring->req_cons;\n\trp = ring->sring->req_prod;\n\trmb();\t \n\n\tif (RING_REQUEST_PROD_OVERFLOW(ring, rp)) {\n\t\trc = ring->rsp_prod_pvt;\n\t\tpr_warn(\"Dom%d provided bogus ring requests (%#x - %#x = %u). Halting ring processing\\n\",\n\t\t\t   info->domid, rp, rc, rp - rc);\n\t\treturn -EINVAL;\n\t}\n\n\twhile ((rc != rp)) {\n\t\t*eoi_flags &= ~XEN_EOI_FLAG_SPURIOUS;\n\n\t\tif (RING_REQUEST_CONS_OVERFLOW(ring, rc))\n\t\t\tbreak;\n\n\t\tRING_COPY_REQUEST(ring, rc, &ring_req);\n\t\tring->req_cons = ++rc;\n\n\t\tpending_req = prepare_pending_reqs(info, ring, &ring_req);\n\t\tif (IS_ERR(pending_req)) {\n\t\t\tswitch (PTR_ERR(pending_req)) {\n\t\t\tcase -ENODEV:\n\t\t\t\tresult = DID_NO_CONNECT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult = DID_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tscsiback_send_response(info, NULL, result << 16, 0,\n\t\t\t\t\t       ring_req.rqid);\n\t\t\treturn 1;\n\t\t}\n\n\t\tswitch (ring_req.act) {\n\t\tcase VSCSIIF_ACT_SCSI_CDB:\n\t\t\tif (scsiback_gnttab_data_map(&ring_req, pending_req)) {\n\t\t\t\tscsiback_fast_flush_area(pending_req);\n\t\t\t\tscsiback_do_resp_with_sense(NULL,\n\t\t\t\t\t\tDID_ERROR << 16, 0, pending_req);\n\t\t\t\ttransport_generic_free_cmd(&pending_req->se_cmd, 0);\n\t\t\t} else {\n\t\t\t\tscsiback_cmd_exec(pending_req);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VSCSIIF_ACT_SCSI_ABORT:\n\t\t\tscsiback_device_action(pending_req, TMR_ABORT_TASK,\n\t\t\t\tring_req.ref_rqid);\n\t\t\tbreak;\n\t\tcase VSCSIIF_ACT_SCSI_RESET:\n\t\t\tscsiback_device_action(pending_req, TMR_LUN_RESET, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err_ratelimited(\"invalid request\\n\");\n\t\t\tscsiback_do_resp_with_sense(NULL, DID_ERROR << 16, 0,\n\t\t\t\t\t\t    pending_req);\n\t\t\ttransport_generic_free_cmd(&pending_req->se_cmd, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcond_resched();\n\t}\n\n\tgnttab_page_cache_shrink(&info->free_pages, scsiback_max_buffer_pages);\n\n\tRING_FINAL_CHECK_FOR_REQUESTS(&info->ring, more_to_do);\n\treturn more_to_do;\n}\n\nstatic irqreturn_t scsiback_irq_fn(int irq, void *dev_id)\n{\n\tstruct vscsibk_info *info = dev_id;\n\tint rc;\n\tunsigned int eoi_flags = XEN_EOI_FLAG_SPURIOUS;\n\n\twhile ((rc = scsiback_do_cmd_fn(info, &eoi_flags)) > 0)\n\t\tcond_resched();\n\n\t \n\tif (!rc)\n\t\txen_irq_lateeoi(irq, eoi_flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int scsiback_init_sring(struct vscsibk_info *info, grant_ref_t ring_ref,\n\t\t\tevtchn_port_t evtchn)\n{\n\tvoid *area;\n\tstruct vscsiif_sring *sring;\n\tint err;\n\n\tif (info->irq)\n\t\treturn -1;\n\n\terr = xenbus_map_ring_valloc(info->dev, &ring_ref, 1, &area);\n\tif (err)\n\t\treturn err;\n\n\tsring = (struct vscsiif_sring *)area;\n\tBACK_RING_INIT(&info->ring, sring, PAGE_SIZE);\n\n\terr = bind_interdomain_evtchn_to_irq_lateeoi(info->dev, evtchn);\n\tif (err < 0)\n\t\tgoto unmap_page;\n\n\tinfo->irq = err;\n\n\terr = request_threaded_irq(info->irq, NULL, scsiback_irq_fn,\n\t\t\t\t   IRQF_ONESHOT, \"vscsiif-backend\", info);\n\tif (err)\n\t\tgoto free_irq;\n\n\treturn 0;\n\nfree_irq:\n\tunbind_from_irqhandler(info->irq, info);\n\tinfo->irq = 0;\nunmap_page:\n\txenbus_unmap_ring_vfree(info->dev, area);\n\n\treturn err;\n}\n\nstatic int scsiback_map(struct vscsibk_info *info)\n{\n\tstruct xenbus_device *dev = info->dev;\n\tunsigned int ring_ref;\n\tevtchn_port_t evtchn;\n\tint err;\n\n\terr = xenbus_gather(XBT_NIL, dev->otherend,\n\t\t\t\"ring-ref\", \"%u\", &ring_ref,\n\t\t\t\"event-channel\", \"%u\", &evtchn, NULL);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"reading %s ring\", dev->otherend);\n\t\treturn err;\n\t}\n\n\treturn scsiback_init_sring(info, ring_ref, evtchn);\n}\n\n \nstatic struct v2p_entry *scsiback_chk_translation_entry(\n\tstruct vscsibk_info *info, struct ids_tuple *v)\n{\n\tstruct list_head *head = &(info->v2p_entry_lists);\n\tstruct v2p_entry *entry;\n\n\tlist_for_each_entry(entry, head, l)\n\t\tif ((entry->v.chn == v->chn) &&\n\t\t    (entry->v.tgt == v->tgt) &&\n\t\t    (entry->v.lun == v->lun))\n\t\t\treturn entry;\n\n\treturn NULL;\n}\n\n \nstatic int scsiback_add_translation_entry(struct vscsibk_info *info,\n\t\t\t\t\t  char *phy, struct ids_tuple *v)\n{\n\tint err = 0;\n\tstruct v2p_entry *new;\n\tunsigned long flags;\n\tchar *lunp;\n\tunsigned long long unpacked_lun;\n\tstruct se_lun *se_lun;\n\tstruct scsiback_tpg *tpg_entry, *tpg = NULL;\n\tchar *error = \"doesn't exist\";\n\n\tlunp = strrchr(phy, ':');\n\tif (!lunp) {\n\t\tpr_err(\"illegal format of physical device %s\\n\", phy);\n\t\treturn -EINVAL;\n\t}\n\t*lunp = 0;\n\tlunp++;\n\terr = kstrtoull(lunp, 10, &unpacked_lun);\n\tif (err < 0) {\n\t\tpr_err(\"lun number not valid: %s\\n\", lunp);\n\t\treturn err;\n\t}\n\n\tmutex_lock(&scsiback_mutex);\n\tlist_for_each_entry(tpg_entry, &scsiback_list, tv_tpg_list) {\n\t\tif (!strcmp(phy, tpg_entry->tport->tport_name) ||\n\t\t    !strcmp(phy, tpg_entry->param_alias)) {\n\t\t\tmutex_lock(&tpg_entry->se_tpg.tpg_lun_mutex);\n\t\t\thlist_for_each_entry(se_lun, &tpg_entry->se_tpg.tpg_lun_hlist, link) {\n\t\t\t\tif (se_lun->unpacked_lun == unpacked_lun) {\n\t\t\t\t\tif (!tpg_entry->tpg_nexus)\n\t\t\t\t\t\terror = \"nexus undefined\";\n\t\t\t\t\telse\n\t\t\t\t\t\ttpg = tpg_entry;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&tpg_entry->se_tpg.tpg_lun_mutex);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tpg) {\n\t\tmutex_lock(&tpg->tv_tpg_mutex);\n\t\ttpg->tv_tpg_fe_count++;\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t}\n\tmutex_unlock(&scsiback_mutex);\n\n\tif (!tpg) {\n\t\tpr_err(\"%s:%llu %s\\n\", phy, unpacked_lun, error);\n\t\treturn -ENODEV;\n\t}\n\n\tnew = kmalloc(sizeof(struct v2p_entry), GFP_KERNEL);\n\tif (new == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tspin_lock_irqsave(&info->v2p_lock, flags);\n\n\t \n\tif (scsiback_chk_translation_entry(info, v)) {\n\t\tpr_warn(\"Virtual ID is already used. Assignment was not performed.\\n\");\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t \n\tkref_init(&new->kref);\n\tnew->v = *v;\n\tnew->tpg = tpg;\n\tnew->lun = unpacked_lun;\n\tlist_add_tail(&new->l, &info->v2p_entry_lists);\n\nout:\n\tspin_unlock_irqrestore(&info->v2p_lock, flags);\n\nout_free:\n\tif (err) {\n\t\tmutex_lock(&tpg->tv_tpg_mutex);\n\t\ttpg->tv_tpg_fe_count--;\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\tkfree(new);\n\t}\n\n\treturn err;\n}\n\n \nstatic int scsiback_del_translation_entry(struct vscsibk_info *info,\n\t\t\t\t\t  struct ids_tuple *v)\n{\n\tstruct v2p_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->v2p_lock, flags);\n\t \n\tentry = scsiback_chk_translation_entry(info, v);\n\tif (entry)\n\t\tlist_del(&entry->l);\n\n\tspin_unlock_irqrestore(&info->v2p_lock, flags);\n\n\tif (!entry)\n\t\treturn -ENOENT;\n\n\tkref_put(&entry->kref, scsiback_free_translation_entry);\n\treturn 0;\n}\n\nstatic void scsiback_do_add_lun(struct vscsibk_info *info, const char *state,\n\t\t\t\tchar *phy, struct ids_tuple *vir, int try)\n{\n\tstruct v2p_entry *entry;\n\tunsigned long flags;\n\tint err;\n\n\tif (try) {\n\t\tspin_lock_irqsave(&info->v2p_lock, flags);\n\t\tentry = scsiback_chk_translation_entry(info, vir);\n\t\tspin_unlock_irqrestore(&info->v2p_lock, flags);\n\t\tif (entry)\n\t\t\treturn;\n\t}\n\tif (!scsiback_add_translation_entry(info, phy, vir)) {\n\t\tif (xenbus_printf(XBT_NIL, info->dev->nodename, state,\n\t\t\t\t  \"%d\", XenbusStateInitialised)) {\n\t\t\tpr_err(\"xenbus_printf error %s\\n\", state);\n\t\t\tscsiback_del_translation_entry(info, vir);\n\t\t}\n\t} else if (!try) {\n\t\terr = xenbus_printf(XBT_NIL, info->dev->nodename, state,\n\t\t\t      \"%d\", XenbusStateClosed);\n\t\tif (err)\n\t\t\txenbus_dev_error(info->dev, err,\n\t\t\t\t\"%s: writing %s\", __func__, state);\n\t}\n}\n\nstatic void scsiback_do_del_lun(struct vscsibk_info *info, const char *state,\n\t\t\t\tstruct ids_tuple *vir)\n{\n\tif (!scsiback_del_translation_entry(info, vir)) {\n\t\tif (xenbus_printf(XBT_NIL, info->dev->nodename, state,\n\t\t\t\t  \"%d\", XenbusStateClosed))\n\t\t\tpr_err(\"xenbus_printf error %s\\n\", state);\n\t}\n}\n\n#define VSCSIBACK_OP_ADD_OR_DEL_LUN\t1\n#define VSCSIBACK_OP_UPDATEDEV_STATE\t2\n\nstatic void scsiback_do_1lun_hotplug(struct vscsibk_info *info, int op,\n\t\t\t\t     char *ent)\n{\n\tint err;\n\tstruct ids_tuple vir;\n\tchar *val;\n\tint device_state;\n\tchar phy[VSCSI_NAMELEN];\n\tchar str[64];\n\tchar state[64];\n\tstruct xenbus_device *dev = info->dev;\n\n\t \n\tsnprintf(state, sizeof(state), \"vscsi-devs/%s/state\", ent);\n\terr = xenbus_scanf(XBT_NIL, dev->nodename, state, \"%u\", &device_state);\n\tif (XENBUS_EXIST_ERR(err))\n\t\treturn;\n\n\t \n\tsnprintf(str, sizeof(str), \"vscsi-devs/%s/p-dev\", ent);\n\tval = xenbus_read(XBT_NIL, dev->nodename, str, NULL);\n\tif (IS_ERR(val)) {\n\t\terr = xenbus_printf(XBT_NIL, dev->nodename, state,\n\t\t\t      \"%d\", XenbusStateClosed);\n\t\tif (err)\n\t\t\txenbus_dev_error(info->dev, err,\n\t\t\t\t\"%s: writing %s\", __func__, state);\n\t\treturn;\n\t}\n\tstrscpy(phy, val, VSCSI_NAMELEN);\n\tkfree(val);\n\n\t \n\tsnprintf(str, sizeof(str), \"vscsi-devs/%s/v-dev\", ent);\n\terr = xenbus_scanf(XBT_NIL, dev->nodename, str, \"%u:%u:%u:%u\",\n\t\t\t   &vir.hst, &vir.chn, &vir.tgt, &vir.lun);\n\tif (XENBUS_EXIST_ERR(err)) {\n\t\terr = xenbus_printf(XBT_NIL, dev->nodename, state,\n\t\t\t      \"%d\", XenbusStateClosed);\n\t\tif (err)\n\t\t\txenbus_dev_error(info->dev, err,\n\t\t\t\t\"%s: writing %s\", __func__, state);\n\t\treturn;\n\t}\n\n\tswitch (op) {\n\tcase VSCSIBACK_OP_ADD_OR_DEL_LUN:\n\t\tswitch (device_state) {\n\t\tcase XenbusStateInitialising:\n\t\t\tscsiback_do_add_lun(info, state, phy, &vir, 0);\n\t\t\tbreak;\n\t\tcase XenbusStateConnected:\n\t\t\tscsiback_do_add_lun(info, state, phy, &vir, 1);\n\t\t\tbreak;\n\t\tcase XenbusStateClosing:\n\t\t\tscsiback_do_del_lun(info, state, &vir);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase VSCSIBACK_OP_UPDATEDEV_STATE:\n\t\tif (device_state == XenbusStateInitialised) {\n\t\t\t \n\t\t\tif (xenbus_printf(XBT_NIL, dev->nodename, state,\n\t\t\t\t\t  \"%d\", XenbusStateConnected)) {\n\t\t\t\tpr_err(\"xenbus_printf error %s\\n\", str);\n\t\t\t\tscsiback_del_translation_entry(info, &vir);\n\t\t\t\txenbus_printf(XBT_NIL, dev->nodename, state,\n\t\t\t\t\t      \"%d\", XenbusStateClosed);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t \n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void scsiback_do_lun_hotplug(struct vscsibk_info *info, int op)\n{\n\tint i;\n\tchar **dir;\n\tunsigned int ndir = 0;\n\n\tdir = xenbus_directory(XBT_NIL, info->dev->nodename, \"vscsi-devs\",\n\t\t\t       &ndir);\n\tif (IS_ERR(dir))\n\t\treturn;\n\n\tfor (i = 0; i < ndir; i++)\n\t\tscsiback_do_1lun_hotplug(info, op, dir[i]);\n\n\tkfree(dir);\n}\n\nstatic void scsiback_frontend_changed(struct xenbus_device *dev,\n\t\t\t\t\tenum xenbus_state frontend_state)\n{\n\tstruct vscsibk_info *info = dev_get_drvdata(&dev->dev);\n\n\tswitch (frontend_state) {\n\tcase XenbusStateInitialising:\n\t\tbreak;\n\n\tcase XenbusStateInitialised:\n\t\tif (scsiback_map(info))\n\t\t\tbreak;\n\n\t\tscsiback_do_lun_hotplug(info, VSCSIBACK_OP_ADD_OR_DEL_LUN);\n\t\txenbus_switch_state(dev, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateConnected:\n\t\tscsiback_do_lun_hotplug(info, VSCSIBACK_OP_UPDATEDEV_STATE);\n\n\t\tif (dev->state == XenbusStateConnected)\n\t\t\tbreak;\n\n\t\txenbus_switch_state(dev, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateClosing:\n\t\tif (info->irq)\n\t\t\tscsiback_disconnect(info);\n\n\t\txenbus_switch_state(dev, XenbusStateClosing);\n\t\tbreak;\n\n\tcase XenbusStateClosed:\n\t\txenbus_switch_state(dev, XenbusStateClosed);\n\t\tif (xenbus_dev_is_online(dev))\n\t\t\tbreak;\n\t\tfallthrough;\t \n\tcase XenbusStateUnknown:\n\t\tdevice_unregister(&dev->dev);\n\t\tbreak;\n\n\tcase XenbusStateReconfiguring:\n\t\tscsiback_do_lun_hotplug(info, VSCSIBACK_OP_ADD_OR_DEL_LUN);\n\t\txenbus_switch_state(dev, XenbusStateReconfigured);\n\n\t\tbreak;\n\n\tdefault:\n\t\txenbus_dev_fatal(dev, -EINVAL, \"saw state %d at frontend\",\n\t\t\t\t\tfrontend_state);\n\t\tbreak;\n\t}\n}\n\n \nstatic void scsiback_release_translation_entry(struct vscsibk_info *info)\n{\n\tstruct v2p_entry *entry, *tmp;\n\tstruct list_head *head = &(info->v2p_entry_lists);\n\tstruct list_head tmp_list;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->v2p_lock, flags);\n\n\tlist_cut_before(&tmp_list, head, head);\n\n\tspin_unlock_irqrestore(&info->v2p_lock, flags);\n\n\tlist_for_each_entry_safe(entry, tmp, &tmp_list, l) {\n\t\tlist_del(&entry->l);\n\t\tkref_put(&entry->kref, scsiback_free_translation_entry);\n\t}\n}\n\nstatic void scsiback_remove(struct xenbus_device *dev)\n{\n\tstruct vscsibk_info *info = dev_get_drvdata(&dev->dev);\n\n\tif (info->irq)\n\t\tscsiback_disconnect(info);\n\n\tscsiback_release_translation_entry(info);\n\n\tgnttab_page_cache_shrink(&info->free_pages, 0);\n\n\tdev_set_drvdata(&dev->dev, NULL);\n}\n\nstatic int scsiback_probe(struct xenbus_device *dev,\n\t\t\t   const struct xenbus_device_id *id)\n{\n\tint err;\n\n\tstruct vscsibk_info *info = kzalloc(sizeof(struct vscsibk_info),\n\t\t\t\t\t    GFP_KERNEL);\n\n\tpr_debug(\"%s %p %d\\n\", __func__, dev, dev->otherend_id);\n\n\tif (!info) {\n\t\txenbus_dev_fatal(dev, -ENOMEM, \"allocating backend structure\");\n\t\treturn -ENOMEM;\n\t}\n\tinfo->dev = dev;\n\tdev_set_drvdata(&dev->dev, info);\n\n\tinfo->domid = dev->otherend_id;\n\tspin_lock_init(&info->ring_lock);\n\tatomic_set(&info->nr_unreplied_reqs, 0);\n\tinit_waitqueue_head(&info->waiting_to_free);\n\tinfo->dev = dev;\n\tinfo->irq = 0;\n\tINIT_LIST_HEAD(&info->v2p_entry_lists);\n\tspin_lock_init(&info->v2p_lock);\n\tgnttab_page_cache_init(&info->free_pages);\n\n\terr = xenbus_printf(XBT_NIL, dev->nodename, \"feature-sg-grant\", \"%u\",\n\t\t\t    SG_ALL);\n\tif (err)\n\t\txenbus_dev_error(dev, err, \"writing feature-sg-grant\");\n\n\terr = xenbus_switch_state(dev, XenbusStateInitWait);\n\tif (err)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tpr_warn(\"%s failed\\n\", __func__);\n\tscsiback_remove(dev);\n\n\treturn err;\n}\n\nstatic char *scsiback_dump_proto_id(struct scsiback_tport *tport)\n{\n\tswitch (tport->tport_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn \"SAS\";\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn \"FCP\";\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn \"iSCSI\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic char *scsiback_get_fabric_wwn(struct se_portal_group *se_tpg)\n{\n\tstruct scsiback_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct scsiback_tpg, se_tpg);\n\tstruct scsiback_tport *tport = tpg->tport;\n\n\treturn &tport->tport_name[0];\n}\n\nstatic u16 scsiback_get_tag(struct se_portal_group *se_tpg)\n{\n\tstruct scsiback_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct scsiback_tpg, se_tpg);\n\treturn tpg->tport_tpgt;\n}\n\nstatic struct se_wwn *\nscsiback_make_tport(struct target_fabric_configfs *tf,\n\t\t     struct config_group *group,\n\t\t     const char *name)\n{\n\tstruct scsiback_tport *tport;\n\tchar *ptr;\n\tu64 wwpn = 0;\n\tint off = 0;\n\n\ttport = kzalloc(sizeof(struct scsiback_tport), GFP_KERNEL);\n\tif (!tport)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttport->tport_wwpn = wwpn;\n\t \n\tptr = strstr(name, \"naa.\");\n\tif (ptr) {\n\t\ttport->tport_proto_id = SCSI_PROTOCOL_SAS;\n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"fc.\");\n\tif (ptr) {\n\t\ttport->tport_proto_id = SCSI_PROTOCOL_FCP;\n\t\toff = 3;  \n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"iqn.\");\n\tif (ptr) {\n\t\ttport->tport_proto_id = SCSI_PROTOCOL_ISCSI;\n\t\tgoto check_len;\n\t}\n\n\tpr_err(\"Unable to locate prefix for emulated Target Port: %s\\n\", name);\n\tkfree(tport);\n\treturn ERR_PTR(-EINVAL);\n\ncheck_len:\n\tif (strlen(name) >= VSCSI_NAMELEN) {\n\t\tpr_err(\"Emulated %s Address: %s, exceeds max: %d\\n\", name,\n\t\t\tscsiback_dump_proto_id(tport), VSCSI_NAMELEN);\n\t\tkfree(tport);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tsnprintf(&tport->tport_name[0], VSCSI_NAMELEN, \"%s\", &name[off]);\n\n\tpr_debug(\"Allocated emulated Target %s Address: %s\\n\",\n\t\t scsiback_dump_proto_id(tport), name);\n\n\treturn &tport->tport_wwn;\n}\n\nstatic void scsiback_drop_tport(struct se_wwn *wwn)\n{\n\tstruct scsiback_tport *tport = container_of(wwn,\n\t\t\t\tstruct scsiback_tport, tport_wwn);\n\n\tpr_debug(\"Deallocating emulated Target %s Address: %s\\n\",\n\t\t scsiback_dump_proto_id(tport), tport->tport_name);\n\n\tkfree(tport);\n}\n\nstatic int scsiback_check_stop_free(struct se_cmd *se_cmd)\n{\n\treturn transport_generic_free_cmd(se_cmd, 0);\n}\n\nstatic void scsiback_release_cmd(struct se_cmd *se_cmd)\n{\n\ttarget_free_tag(se_cmd->se_sess, se_cmd);\n}\n\nstatic int scsiback_write_pending(struct se_cmd *se_cmd)\n{\n\t \n\ttarget_execute_cmd(se_cmd);\n\n\treturn 0;\n}\n\nstatic int scsiback_queue_data_in(struct se_cmd *se_cmd)\n{\n\tstruct vscsibk_pend *pending_req = container_of(se_cmd,\n\t\t\t\tstruct vscsibk_pend, se_cmd);\n\n\tpending_req->result = SAM_STAT_GOOD;\n\tscsiback_cmd_done(pending_req);\n\treturn 0;\n}\n\nstatic int scsiback_queue_status(struct se_cmd *se_cmd)\n{\n\tstruct vscsibk_pend *pending_req = container_of(se_cmd,\n\t\t\t\tstruct vscsibk_pend, se_cmd);\n\n\tif (se_cmd->sense_buffer &&\n\t    ((se_cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ||\n\t     (se_cmd->se_cmd_flags & SCF_EMULATED_TASK_SENSE)))\n\t\tpending_req->result = SAM_STAT_CHECK_CONDITION;\n\telse\n\t\tpending_req->result = se_cmd->scsi_status;\n\n\tscsiback_cmd_done(pending_req);\n\treturn 0;\n}\n\nstatic void scsiback_queue_tm_rsp(struct se_cmd *se_cmd)\n{\n\tstruct vscsibk_pend *pending_req = container_of(se_cmd,\n\t\t\t\tstruct vscsibk_pend, se_cmd);\n\n\tcomplete(&pending_req->tmr_done);\n}\n\nstatic void scsiback_aborted_task(struct se_cmd *se_cmd)\n{\n}\n\nstatic ssize_t scsiback_tpg_param_alias_show(struct config_item *item,\n\t\t\t\t\t     char *page)\n{\n\tstruct se_portal_group *se_tpg = param_to_tpg(item);\n\tstruct scsiback_tpg *tpg = container_of(se_tpg, struct scsiback_tpg,\n\t\t\t\t\t\tse_tpg);\n\tssize_t rb;\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\trb = snprintf(page, PAGE_SIZE, \"%s\\n\", tpg->param_alias);\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n\n\treturn rb;\n}\n\nstatic ssize_t scsiback_tpg_param_alias_store(struct config_item *item,\n\t\t\t\t\t      const char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = param_to_tpg(item);\n\tstruct scsiback_tpg *tpg = container_of(se_tpg, struct scsiback_tpg,\n\t\t\t\t\t\tse_tpg);\n\tint len;\n\n\tif (strlen(page) >= VSCSI_NAMELEN) {\n\t\tpr_err(\"param alias: %s, exceeds max: %d\\n\", page,\n\t\t\tVSCSI_NAMELEN);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\tlen = snprintf(tpg->param_alias, VSCSI_NAMELEN, \"%s\", page);\n\tif (tpg->param_alias[len - 1] == '\\n')\n\t\ttpg->param_alias[len - 1] = '\\0';\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(scsiback_tpg_param_, alias);\n\nstatic struct configfs_attribute *scsiback_param_attrs[] = {\n\t&scsiback_tpg_param_attr_alias,\n\tNULL,\n};\n\nstatic int scsiback_alloc_sess_cb(struct se_portal_group *se_tpg,\n\t\t\t\t  struct se_session *se_sess, void *p)\n{\n\tstruct scsiback_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct scsiback_tpg, se_tpg);\n\n\ttpg->tpg_nexus = p;\n\treturn 0;\n}\n\nstatic int scsiback_make_nexus(struct scsiback_tpg *tpg,\n\t\t\t\tconst char *name)\n{\n\tstruct scsiback_nexus *tv_nexus;\n\tint ret = 0;\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\tif (tpg->tpg_nexus) {\n\t\tpr_debug(\"tpg->tpg_nexus already exists\\n\");\n\t\tret = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\ttv_nexus = kzalloc(sizeof(struct scsiback_nexus), GFP_KERNEL);\n\tif (!tv_nexus) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\ttv_nexus->tvn_se_sess = target_setup_session(&tpg->se_tpg,\n\t\t\t\t\t\t     VSCSI_DEFAULT_SESSION_TAGS,\n\t\t\t\t\t\t     sizeof(struct vscsibk_pend),\n\t\t\t\t\t\t     TARGET_PROT_NORMAL, name,\n\t\t\t\t\t\t     tv_nexus, scsiback_alloc_sess_cb);\n\tif (IS_ERR(tv_nexus->tvn_se_sess)) {\n\t\tkfree(tv_nexus);\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n\treturn ret;\n}\n\nstatic int scsiback_drop_nexus(struct scsiback_tpg *tpg)\n{\n\tstruct se_session *se_sess;\n\tstruct scsiback_nexus *tv_nexus;\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\ttv_nexus = tpg->tpg_nexus;\n\tif (!tv_nexus) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tse_sess = tv_nexus->tvn_se_sess;\n\tif (!se_sess) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (tpg->tv_tpg_port_count != 0) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\tpr_err(\"Unable to remove xen-pvscsi I_T Nexus with active TPG port count: %d\\n\",\n\t\t\ttpg->tv_tpg_port_count);\n\t\treturn -EBUSY;\n\t}\n\n\tif (tpg->tv_tpg_fe_count != 0) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\tpr_err(\"Unable to remove xen-pvscsi I_T Nexus with active TPG frontend count: %d\\n\",\n\t\t\ttpg->tv_tpg_fe_count);\n\t\treturn -EBUSY;\n\t}\n\n\tpr_debug(\"Removing I_T Nexus to emulated %s Initiator Port: %s\\n\",\n\t\tscsiback_dump_proto_id(tpg->tport),\n\t\ttv_nexus->tvn_se_sess->se_node_acl->initiatorname);\n\n\t \n\ttarget_remove_session(se_sess);\n\ttpg->tpg_nexus = NULL;\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n\n\tkfree(tv_nexus);\n\treturn 0;\n}\n\nstatic ssize_t scsiback_tpg_nexus_show(struct config_item *item, char *page)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct scsiback_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct scsiback_tpg, se_tpg);\n\tstruct scsiback_nexus *tv_nexus;\n\tssize_t ret;\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\ttv_nexus = tpg->tpg_nexus;\n\tif (!tv_nexus) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\treturn -ENODEV;\n\t}\n\tret = snprintf(page, PAGE_SIZE, \"%s\\n\",\n\t\t\ttv_nexus->tvn_se_sess->se_node_acl->initiatorname);\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t scsiback_tpg_nexus_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct scsiback_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct scsiback_tpg, se_tpg);\n\tstruct scsiback_tport *tport_wwn = tpg->tport;\n\tunsigned char i_port[VSCSI_NAMELEN], *ptr, *port_ptr;\n\tint ret;\n\t \n\tif (!strncmp(page, \"NULL\", 4)) {\n\t\tret = scsiback_drop_nexus(tpg);\n\t\treturn (!ret) ? count : ret;\n\t}\n\t \n\tif (strlen(page) >= VSCSI_NAMELEN) {\n\t\tpr_err(\"Emulated NAA Sas Address: %s, exceeds max: %d\\n\",\n\t\t\tpage, VSCSI_NAMELEN);\n\t\treturn -EINVAL;\n\t}\n\tsnprintf(&i_port[0], VSCSI_NAMELEN, \"%s\", page);\n\n\tptr = strstr(i_port, \"naa.\");\n\tif (ptr) {\n\t\tif (tport_wwn->tport_proto_id != SCSI_PROTOCOL_SAS) {\n\t\t\tpr_err(\"Passed SAS Initiator Port %s does not match target port protoid: %s\\n\",\n\t\t\t\ti_port, scsiback_dump_proto_id(tport_wwn));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[0];\n\t\tgoto check_newline;\n\t}\n\tptr = strstr(i_port, \"fc.\");\n\tif (ptr) {\n\t\tif (tport_wwn->tport_proto_id != SCSI_PROTOCOL_FCP) {\n\t\t\tpr_err(\"Passed FCP Initiator Port %s does not match target port protoid: %s\\n\",\n\t\t\t\ti_port, scsiback_dump_proto_id(tport_wwn));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[3];  \n\t\tgoto check_newline;\n\t}\n\tptr = strstr(i_port, \"iqn.\");\n\tif (ptr) {\n\t\tif (tport_wwn->tport_proto_id != SCSI_PROTOCOL_ISCSI) {\n\t\t\tpr_err(\"Passed iSCSI Initiator Port %s does not match target port protoid: %s\\n\",\n\t\t\t\ti_port, scsiback_dump_proto_id(tport_wwn));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[0];\n\t\tgoto check_newline;\n\t}\n\tpr_err(\"Unable to locate prefix for emulated Initiator Port: %s\\n\",\n\t\ti_port);\n\treturn -EINVAL;\n\t \ncheck_newline:\n\tif (i_port[strlen(i_port) - 1] == '\\n')\n\t\ti_port[strlen(i_port) - 1] = '\\0';\n\n\tret = scsiback_make_nexus(tpg, port_ptr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(scsiback_tpg_, nexus);\n\nstatic struct configfs_attribute *scsiback_tpg_attrs[] = {\n\t&scsiback_tpg_attr_nexus,\n\tNULL,\n};\n\nstatic ssize_t\nscsiback_wwn_version_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"xen-pvscsi fabric module %s on %s/%s on \"\n\t\tUTS_RELEASE\"\\n\",\n\t\tVSCSI_VERSION, utsname()->sysname, utsname()->machine);\n}\n\nCONFIGFS_ATTR_RO(scsiback_wwn_, version);\n\nstatic struct configfs_attribute *scsiback_wwn_attrs[] = {\n\t&scsiback_wwn_attr_version,\n\tNULL,\n};\n\nstatic int scsiback_port_link(struct se_portal_group *se_tpg,\n\t\t\t       struct se_lun *lun)\n{\n\tstruct scsiback_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct scsiback_tpg, se_tpg);\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\ttpg->tv_tpg_port_count++;\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n\n\treturn 0;\n}\n\nstatic void scsiback_port_unlink(struct se_portal_group *se_tpg,\n\t\t\t\t  struct se_lun *lun)\n{\n\tstruct scsiback_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct scsiback_tpg, se_tpg);\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\ttpg->tv_tpg_port_count--;\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n}\n\nstatic struct se_portal_group *\nscsiback_make_tpg(struct se_wwn *wwn, const char *name)\n{\n\tstruct scsiback_tport *tport = container_of(wwn,\n\t\t\tstruct scsiback_tport, tport_wwn);\n\n\tstruct scsiback_tpg *tpg;\n\tu16 tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tret = kstrtou16(name + 5, 10, &tpgt);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\ttpg = kzalloc(sizeof(struct scsiback_tpg), GFP_KERNEL);\n\tif (!tpg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\tINIT_LIST_HEAD(&tpg->info_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(wwn, &tpg->se_tpg, tport->tport_proto_id);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&scsiback_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &scsiback_list);\n\tmutex_unlock(&scsiback_mutex);\n\n\treturn &tpg->se_tpg;\n}\n\nstatic void scsiback_drop_tpg(struct se_portal_group *se_tpg)\n{\n\tstruct scsiback_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct scsiback_tpg, se_tpg);\n\n\tmutex_lock(&scsiback_mutex);\n\tlist_del(&tpg->tv_tpg_list);\n\tmutex_unlock(&scsiback_mutex);\n\t \n\tscsiback_drop_nexus(tpg);\n\t \n\tcore_tpg_deregister(se_tpg);\n\tkfree(tpg);\n}\n\nstatic int scsiback_check_true(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic const struct target_core_fabric_ops scsiback_ops = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.fabric_name\t\t\t= \"xen-pvscsi\",\n\t.tpg_get_wwn\t\t\t= scsiback_get_fabric_wwn,\n\t.tpg_get_tag\t\t\t= scsiback_get_tag,\n\t.tpg_check_demo_mode\t\t= scsiback_check_true,\n\t.tpg_check_demo_mode_cache\t= scsiback_check_true,\n\t.check_stop_free\t\t= scsiback_check_stop_free,\n\t.release_cmd\t\t\t= scsiback_release_cmd,\n\t.sess_get_initiator_sid\t\t= NULL,\n\t.write_pending\t\t\t= scsiback_write_pending,\n\t.queue_data_in\t\t\t= scsiback_queue_data_in,\n\t.queue_status\t\t\t= scsiback_queue_status,\n\t.queue_tm_rsp\t\t\t= scsiback_queue_tm_rsp,\n\t.aborted_task\t\t\t= scsiback_aborted_task,\n\t \n\t.fabric_make_wwn\t\t= scsiback_make_tport,\n\t.fabric_drop_wwn\t\t= scsiback_drop_tport,\n\t.fabric_make_tpg\t\t= scsiback_make_tpg,\n\t.fabric_drop_tpg\t\t= scsiback_drop_tpg,\n\t.fabric_post_link\t\t= scsiback_port_link,\n\t.fabric_pre_unlink\t\t= scsiback_port_unlink,\n\n\t.tfc_wwn_attrs\t\t\t= scsiback_wwn_attrs,\n\t.tfc_tpg_base_attrs\t\t= scsiback_tpg_attrs,\n\t.tfc_tpg_param_attrs\t\t= scsiback_param_attrs,\n};\n\nstatic const struct xenbus_device_id scsiback_ids[] = {\n\t{ \"vscsi\" },\n\t{ \"\" }\n};\n\nstatic struct xenbus_driver scsiback_driver = {\n\t.ids\t\t\t= scsiback_ids,\n\t.probe\t\t\t= scsiback_probe,\n\t.remove\t\t\t= scsiback_remove,\n\t.otherend_changed\t= scsiback_frontend_changed\n};\n\nstatic int __init scsiback_init(void)\n{\n\tint ret;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tpr_debug(\"xen-pvscsi: fabric module %s on %s/%s on \"UTS_RELEASE\"\\n\",\n\t\t VSCSI_VERSION, utsname()->sysname, utsname()->machine);\n\n\tret = xenbus_register_backend(&scsiback_driver);\n\tif (ret)\n\t\tgoto out;\n\n\tret = target_register_template(&scsiback_ops);\n\tif (ret)\n\t\tgoto out_unregister_xenbus;\n\n\treturn 0;\n\nout_unregister_xenbus:\n\txenbus_unregister_driver(&scsiback_driver);\nout:\n\tpr_err(\"%s: error %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic void __exit scsiback_exit(void)\n{\n\ttarget_unregister_template(&scsiback_ops);\n\txenbus_unregister_driver(&scsiback_driver);\n}\n\nmodule_init(scsiback_init);\nmodule_exit(scsiback_exit);\n\nMODULE_DESCRIPTION(\"Xen SCSI backend driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"xen-backend:vscsi\");\nMODULE_AUTHOR(\"Juergen Gross <jgross@suse.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}