{
  "module_name": "arm-device.c",
  "hash_id": "69623b3f976d82285708cf66be78f1cc7b504f53e527807939cb75f1f11799fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/arm-device.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/acpi.h>\n#include <xen/xen.h>\n#include <xen/page.h>\n#include <xen/interface/memory.h>\n#include <asm/xen/hypervisor.h>\n#include <asm/xen/hypercall.h>\n\nstatic int xen_unmap_device_mmio(const struct resource *resources,\n\t\t\t\t unsigned int count)\n{\n\tunsigned int i, j, nr;\n\tint rc = 0;\n\tconst struct resource *r;\n\tstruct xen_remove_from_physmap xrp;\n\n\tfor (i = 0; i < count; i++) {\n\t\tr = &resources[i];\n\t\tnr = DIV_ROUND_UP(resource_size(r), XEN_PAGE_SIZE);\n\t\tif ((resource_type(r) != IORESOURCE_MEM) || (nr == 0))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < nr; j++) {\n\t\t\txrp.domid = DOMID_SELF;\n\t\t\txrp.gpfn = XEN_PFN_DOWN(r->start) + j;\n\t\t\trc = HYPERVISOR_memory_op(XENMEM_remove_from_physmap,\n\t\t\t\t\t\t  &xrp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int xen_map_device_mmio(const struct resource *resources,\n\t\t\t       unsigned int count)\n{\n\tunsigned int i, j, nr;\n\tint rc = 0;\n\tconst struct resource *r;\n\txen_pfn_t *gpfns;\n\txen_ulong_t *idxs;\n\tint *errs;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct xen_add_to_physmap_range xatp = {\n\t\t\t.domid = DOMID_SELF,\n\t\t\t.space = XENMAPSPACE_dev_mmio\n\t\t};\n\n\t\tr = &resources[i];\n\t\tnr = DIV_ROUND_UP(resource_size(r), XEN_PAGE_SIZE);\n\t\tif ((resource_type(r) != IORESOURCE_MEM) || (nr == 0))\n\t\t\tcontinue;\n\n\t\tgpfns = kcalloc(nr, sizeof(xen_pfn_t), GFP_KERNEL);\n\t\tidxs = kcalloc(nr, sizeof(xen_ulong_t), GFP_KERNEL);\n\t\terrs = kcalloc(nr, sizeof(int), GFP_KERNEL);\n\t\tif (!gpfns || !idxs || !errs) {\n\t\t\tkfree(gpfns);\n\t\t\tkfree(idxs);\n\t\t\tkfree(errs);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto unmap;\n\t\t}\n\n\t\tfor (j = 0; j < nr; j++) {\n\t\t\t \n\t\t\tgpfns[j] = XEN_PFN_DOWN(r->start) + j;\n\t\t\tidxs[j] = XEN_PFN_DOWN(r->start) + j;\n\t\t}\n\n\t\txatp.size = nr;\n\n\t\tset_xen_guest_handle(xatp.gpfns, gpfns);\n\t\tset_xen_guest_handle(xatp.idxs, idxs);\n\t\tset_xen_guest_handle(xatp.errs, errs);\n\n\t\trc = HYPERVISOR_memory_op(XENMEM_add_to_physmap_range, &xatp);\n\t\tkfree(gpfns);\n\t\tkfree(idxs);\n\t\tkfree(errs);\n\t\tif (rc)\n\t\t\tgoto unmap;\n\t}\n\n\treturn rc;\n\nunmap:\n\txen_unmap_device_mmio(resources, i);\n\treturn rc;\n}\n\nstatic int xen_platform_notifier(struct notifier_block *nb,\n\t\t\t\t unsigned long action, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(data);\n\tint r = 0;\n\n\tif (pdev->num_resources == 0 || pdev->resource == NULL)\n\t\treturn NOTIFY_OK;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tr = xen_map_device_mmio(pdev->resource, pdev->num_resources);\n\t\tbreak;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tr = xen_unmap_device_mmio(pdev->resource, pdev->num_resources);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\tif (r)\n\t\tdev_err(&pdev->dev, \"Platform: Failed to %s device %s MMIO!\\n\",\n\t\t\taction == BUS_NOTIFY_ADD_DEVICE ? \"map\" :\n\t\t\t(action == BUS_NOTIFY_DEL_DEVICE ? \"unmap\" : \"?\"),\n\t\t\tpdev->name);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block platform_device_nb = {\n\t.notifier_call = xen_platform_notifier,\n};\n\nstatic int __init register_xen_platform_notifier(void)\n{\n\tif (!xen_initial_domain() || acpi_disabled)\n\t\treturn 0;\n\n\treturn bus_register_notifier(&platform_bus_type, &platform_device_nb);\n}\n\narch_initcall(register_xen_platform_notifier);\n\n#ifdef CONFIG_ARM_AMBA\n#include <linux/amba/bus.h>\n\nstatic int xen_amba_notifier(struct notifier_block *nb,\n\t\t\t     unsigned long action, void *data)\n{\n\tstruct amba_device *adev = to_amba_device(data);\n\tint r = 0;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tr = xen_map_device_mmio(&adev->res, 1);\n\t\tbreak;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tr = xen_unmap_device_mmio(&adev->res, 1);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\tif (r)\n\t\tdev_err(&adev->dev, \"AMBA: Failed to %s device %s MMIO!\\n\",\n\t\t\taction == BUS_NOTIFY_ADD_DEVICE ? \"map\" :\n\t\t\t(action == BUS_NOTIFY_DEL_DEVICE ? \"unmap\" : \"?\"),\n\t\t\tadev->dev.init_name);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block amba_device_nb = {\n\t.notifier_call = xen_amba_notifier,\n};\n\nstatic int __init register_xen_amba_notifier(void)\n{\n\tif (!xen_initial_domain() || acpi_disabled)\n\t\treturn 0;\n\n\treturn bus_register_notifier(&amba_bustype, &amba_device_nb);\n}\n\narch_initcall(register_xen_amba_notifier);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}