{
  "module_name": "privcmd-buf.c",
  "hash_id": "3319cea810c271fdc7ec669d5349806bb7fe9cdf34423a7366fd6d15e613af44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/privcmd-buf.c",
  "human_readable_source": "\n\n \n\n#define pr_fmt(fmt) \"xen:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/miscdevice.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#include \"privcmd.h\"\n\nMODULE_LICENSE(\"GPL\");\n\nstruct privcmd_buf_private {\n\tstruct mutex lock;\n\tstruct list_head list;\n};\n\nstruct privcmd_buf_vma_private {\n\tstruct privcmd_buf_private *file_priv;\n\tstruct list_head list;\n\tunsigned int users;\n\tunsigned int n_pages;\n\tstruct page *pages[];\n};\n\nstatic int privcmd_buf_open(struct inode *ino, struct file *file)\n{\n\tstruct privcmd_buf_private *file_priv;\n\n\tfile_priv = kzalloc(sizeof(*file_priv), GFP_KERNEL);\n\tif (!file_priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&file_priv->lock);\n\tINIT_LIST_HEAD(&file_priv->list);\n\n\tfile->private_data = file_priv;\n\n\treturn 0;\n}\n\nstatic void privcmd_buf_vmapriv_free(struct privcmd_buf_vma_private *vma_priv)\n{\n\tunsigned int i;\n\n\tlist_del(&vma_priv->list);\n\n\tfor (i = 0; i < vma_priv->n_pages; i++)\n\t\t__free_page(vma_priv->pages[i]);\n\n\tkfree(vma_priv);\n}\n\nstatic int privcmd_buf_release(struct inode *ino, struct file *file)\n{\n\tstruct privcmd_buf_private *file_priv = file->private_data;\n\tstruct privcmd_buf_vma_private *vma_priv;\n\n\tmutex_lock(&file_priv->lock);\n\n\twhile (!list_empty(&file_priv->list)) {\n\t\tvma_priv = list_first_entry(&file_priv->list,\n\t\t\t\t\t    struct privcmd_buf_vma_private,\n\t\t\t\t\t    list);\n\t\tprivcmd_buf_vmapriv_free(vma_priv);\n\t}\n\n\tmutex_unlock(&file_priv->lock);\n\n\tkfree(file_priv);\n\n\treturn 0;\n}\n\nstatic void privcmd_buf_vma_open(struct vm_area_struct *vma)\n{\n\tstruct privcmd_buf_vma_private *vma_priv = vma->vm_private_data;\n\n\tif (!vma_priv)\n\t\treturn;\n\n\tmutex_lock(&vma_priv->file_priv->lock);\n\tvma_priv->users++;\n\tmutex_unlock(&vma_priv->file_priv->lock);\n}\n\nstatic void privcmd_buf_vma_close(struct vm_area_struct *vma)\n{\n\tstruct privcmd_buf_vma_private *vma_priv = vma->vm_private_data;\n\tstruct privcmd_buf_private *file_priv;\n\n\tif (!vma_priv)\n\t\treturn;\n\n\tfile_priv = vma_priv->file_priv;\n\n\tmutex_lock(&file_priv->lock);\n\n\tvma_priv->users--;\n\tif (!vma_priv->users)\n\t\tprivcmd_buf_vmapriv_free(vma_priv);\n\n\tmutex_unlock(&file_priv->lock);\n}\n\nstatic vm_fault_t privcmd_buf_vma_fault(struct vm_fault *vmf)\n{\n\tpr_debug(\"fault: vma=%p %lx-%lx, pgoff=%lx, uv=%p\\n\",\n\t\t vmf->vma, vmf->vma->vm_start, vmf->vma->vm_end,\n\t\t vmf->pgoff, (void *)vmf->address);\n\n\treturn VM_FAULT_SIGBUS;\n}\n\nstatic const struct vm_operations_struct privcmd_buf_vm_ops = {\n\t.open = privcmd_buf_vma_open,\n\t.close = privcmd_buf_vma_close,\n\t.fault = privcmd_buf_vma_fault,\n};\n\nstatic int privcmd_buf_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct privcmd_buf_private *file_priv = file->private_data;\n\tstruct privcmd_buf_vma_private *vma_priv;\n\tunsigned long count = vma_pages(vma);\n\tunsigned int i;\n\tint ret = 0;\n\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\tvma_priv = kzalloc(struct_size(vma_priv, pages, count), GFP_KERNEL);\n\tif (!vma_priv)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; i++) {\n\t\tvma_priv->pages[i] = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\t\tif (!vma_priv->pages[i])\n\t\t\tbreak;\n\t\tvma_priv->n_pages++;\n\t}\n\n\tmutex_lock(&file_priv->lock);\n\n\tvma_priv->file_priv = file_priv;\n\tvma_priv->users = 1;\n\n\tvm_flags_set(vma, VM_IO | VM_DONTEXPAND);\n\tvma->vm_ops = &privcmd_buf_vm_ops;\n\tvma->vm_private_data = vma_priv;\n\n\tlist_add(&vma_priv->list, &file_priv->list);\n\n\tif (vma_priv->n_pages != count)\n\t\tret = -ENOMEM;\n\telse\n\t\tret = vm_map_pages_zero(vma, vma_priv->pages,\n\t\t\t\t\t\tvma_priv->n_pages);\n\n\tif (ret)\n\t\tprivcmd_buf_vmapriv_free(vma_priv);\n\n\tmutex_unlock(&file_priv->lock);\n\n\treturn ret;\n}\n\nconst struct file_operations xen_privcmdbuf_fops = {\n\t.owner = THIS_MODULE,\n\t.open = privcmd_buf_open,\n\t.release = privcmd_buf_release,\n\t.mmap = privcmd_buf_mmap,\n};\nEXPORT_SYMBOL_GPL(xen_privcmdbuf_fops);\n\nstruct miscdevice xen_privcmdbuf_dev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"xen/hypercall\",\n\t.fops = &xen_privcmdbuf_fops,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}