{
  "module_name": "pci.c",
  "hash_id": "b3f7426ee0aa4249d7a51073a65746dd5d93e398db09ea81f78041e0d160f76e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/pci.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/acpi.h>\n#include <linux/pci-acpi.h>\n#include <xen/pci.h>\n#include <xen/xen.h>\n#include <xen/interface/physdev.h>\n#include <xen/interface/xen.h>\n\n#include <asm/xen/hypervisor.h>\n#include <asm/xen/hypercall.h>\n#include \"../pci/pci.h\"\n#ifdef CONFIG_PCI_MMCONFIG\n#include <asm/pci_x86.h>\n\nstatic int xen_mcfg_late(void);\n#endif\n\nstatic bool __read_mostly pci_seg_supported = true;\n\nstatic int xen_add_device(struct device *dev)\n{\n\tint r;\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n#ifdef CONFIG_PCI_IOV\n\tstruct pci_dev *physfn = pci_dev->physfn;\n#endif\n#ifdef CONFIG_PCI_MMCONFIG\n\tstatic bool pci_mcfg_reserved = false;\n\t \n\tif (!pci_mcfg_reserved) {\n\t\txen_mcfg_late();\n\t\tpci_mcfg_reserved = true;\n\t}\n#endif\n\tif (pci_seg_supported) {\n\t\tstruct {\n\t\t\tstruct physdev_pci_device_add add;\n\t\t\tuint32_t pxm;\n\t\t} add_ext = {\n\t\t\t.add.seg = pci_domain_nr(pci_dev->bus),\n\t\t\t.add.bus = pci_dev->bus->number,\n\t\t\t.add.devfn = pci_dev->devfn\n\t\t};\n\t\tstruct physdev_pci_device_add *add = &add_ext.add;\n\n#ifdef CONFIG_ACPI\n\t\tacpi_handle handle;\n#endif\n\n#ifdef CONFIG_PCI_IOV\n\t\tif (pci_dev->is_virtfn) {\n\t\t\tadd->flags = XEN_PCI_DEV_VIRTFN;\n\t\t\tadd->physfn.bus = physfn->bus->number;\n\t\t\tadd->physfn.devfn = physfn->devfn;\n\t\t} else\n#endif\n\t\tif (pci_ari_enabled(pci_dev->bus) && PCI_SLOT(pci_dev->devfn))\n\t\t\tadd->flags = XEN_PCI_DEV_EXTFN;\n\n#ifdef CONFIG_ACPI\n\t\thandle = ACPI_HANDLE(&pci_dev->dev);\n#ifdef CONFIG_PCI_IOV\n\t\tif (!handle && pci_dev->is_virtfn)\n\t\t\thandle = ACPI_HANDLE(physfn->bus->bridge);\n#endif\n\t\tif (!handle) {\n\t\t\t \n\t\t\tstruct pci_bus *pbus;\n\t\t\tfor (pbus = pci_dev->bus; pbus; pbus = pbus->parent) {\n\t\t\t\thandle = acpi_pci_get_bridge_handle(pbus);\n\t\t\t\tif (handle)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (handle) {\n\t\t\tacpi_status status;\n\n\t\t\tdo {\n\t\t\t\tunsigned long long pxm;\n\n\t\t\t\tstatus = acpi_evaluate_integer(handle, \"_PXM\",\n\t\t\t\t\t\t\t       NULL, &pxm);\n\t\t\t\tif (ACPI_SUCCESS(status)) {\n\t\t\t\t\tadd->optarr[0] = pxm;\n\t\t\t\t\tadd->flags |= XEN_PCI_DEV_PXM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstatus = acpi_get_parent(handle, &handle);\n\t\t\t} while (ACPI_SUCCESS(status));\n\t\t}\n#endif  \n\n\t\tr = HYPERVISOR_physdev_op(PHYSDEVOP_pci_device_add, add);\n\t\tif (r != -ENOSYS)\n\t\t\treturn r;\n\t\tpci_seg_supported = false;\n\t}\n\n\tif (pci_domain_nr(pci_dev->bus))\n\t\tr = -ENOSYS;\n#ifdef CONFIG_PCI_IOV\n\telse if (pci_dev->is_virtfn) {\n\t\tstruct physdev_manage_pci_ext manage_pci_ext = {\n\t\t\t.bus\t\t= pci_dev->bus->number,\n\t\t\t.devfn\t\t= pci_dev->devfn,\n\t\t\t.is_virtfn \t= 1,\n\t\t\t.physfn.bus\t= physfn->bus->number,\n\t\t\t.physfn.devfn\t= physfn->devfn,\n\t\t};\n\n\t\tr = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_add_ext,\n\t\t\t&manage_pci_ext);\n\t}\n#endif\n\telse if (pci_ari_enabled(pci_dev->bus) && PCI_SLOT(pci_dev->devfn)) {\n\t\tstruct physdev_manage_pci_ext manage_pci_ext = {\n\t\t\t.bus\t\t= pci_dev->bus->number,\n\t\t\t.devfn\t\t= pci_dev->devfn,\n\t\t\t.is_extfn\t= 1,\n\t\t};\n\n\t\tr = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_add_ext,\n\t\t\t&manage_pci_ext);\n\t} else {\n\t\tstruct physdev_manage_pci manage_pci = {\n\t\t\t.bus\t= pci_dev->bus->number,\n\t\t\t.devfn\t= pci_dev->devfn,\n\t\t};\n\n\t\tr = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_add,\n\t\t\t&manage_pci);\n\t}\n\n\treturn r;\n}\n\nstatic int xen_remove_device(struct device *dev)\n{\n\tint r;\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\n\tif (pci_seg_supported) {\n\t\tstruct physdev_pci_device device = {\n\t\t\t.seg = pci_domain_nr(pci_dev->bus),\n\t\t\t.bus = pci_dev->bus->number,\n\t\t\t.devfn = pci_dev->devfn\n\t\t};\n\n\t\tr = HYPERVISOR_physdev_op(PHYSDEVOP_pci_device_remove,\n\t\t\t\t\t  &device);\n\t} else if (pci_domain_nr(pci_dev->bus))\n\t\tr = -ENOSYS;\n\telse {\n\t\tstruct physdev_manage_pci manage_pci = {\n\t\t\t.bus = pci_dev->bus->number,\n\t\t\t.devfn = pci_dev->devfn\n\t\t};\n\n\t\tr = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_remove,\n\t\t\t\t\t  &manage_pci);\n\t}\n\n\treturn r;\n}\n\nstatic int xen_pci_notifier(struct notifier_block *nb,\n\t\t\t    unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tint r = 0;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tr = xen_add_device(dev);\n\t\tbreak;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tr = xen_remove_device(dev);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\tif (r)\n\t\tdev_err(dev, \"Failed to %s - passthrough or MSI/MSI-X might fail!\\n\",\n\t\t\taction == BUS_NOTIFY_ADD_DEVICE ? \"add\" :\n\t\t\t(action == BUS_NOTIFY_DEL_DEVICE ? \"delete\" : \"?\"));\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block device_nb = {\n\t.notifier_call = xen_pci_notifier,\n};\n\nstatic int __init register_xen_pci_notifier(void)\n{\n\tif (!xen_initial_domain())\n\t\treturn 0;\n\n\treturn bus_register_notifier(&pci_bus_type, &device_nb);\n}\n\narch_initcall(register_xen_pci_notifier);\n\n#ifdef CONFIG_PCI_MMCONFIG\nstatic int xen_mcfg_late(void)\n{\n\tstruct pci_mmcfg_region *cfg;\n\tint rc;\n\n\tif (!xen_initial_domain())\n\t\treturn 0;\n\n\tif ((pci_probe & PCI_PROBE_MMCONF) == 0)\n\t\treturn 0;\n\n\tif (list_empty(&pci_mmcfg_list))\n\t\treturn 0;\n\n\t \n\tlist_for_each_entry(cfg, &pci_mmcfg_list, list) {\n\t\tstruct physdev_pci_mmcfg_reserved r;\n\n\t\tr.address = cfg->address;\n\t\tr.segment = cfg->segment;\n\t\tr.start_bus = cfg->start_bus;\n\t\tr.end_bus = cfg->end_bus;\n\t\tr.flags = XEN_PCI_MMCFG_RESERVED;\n\n\t\trc = HYPERVISOR_physdev_op(PHYSDEVOP_pci_mmcfg_reserved, &r);\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\tcase -ENOSYS:\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tpr_warn(\"Failed to report MMCONFIG reservation\"\n\t\t\t\t\" state for %s to hypervisor\"\n\t\t\t\t\" (%d)\\n\",\n\t\t\t\tcfg->name, rc);\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_XEN_DOM0\nstruct xen_device_domain_owner {\n\tdomid_t domain;\n\tstruct pci_dev *dev;\n\tstruct list_head list;\n};\n\nstatic DEFINE_SPINLOCK(dev_domain_list_spinlock);\nstatic LIST_HEAD(dev_domain_list);\n\nstatic struct xen_device_domain_owner *find_device(struct pci_dev *dev)\n{\n\tstruct xen_device_domain_owner *owner;\n\n\tlist_for_each_entry(owner, &dev_domain_list, list) {\n\t\tif (owner->dev == dev)\n\t\t\treturn owner;\n\t}\n\treturn NULL;\n}\n\nint xen_find_device_domain_owner(struct pci_dev *dev)\n{\n\tstruct xen_device_domain_owner *owner;\n\tint domain = -ENODEV;\n\n\tspin_lock(&dev_domain_list_spinlock);\n\towner = find_device(dev);\n\tif (owner)\n\t\tdomain = owner->domain;\n\tspin_unlock(&dev_domain_list_spinlock);\n\treturn domain;\n}\nEXPORT_SYMBOL_GPL(xen_find_device_domain_owner);\n\nint xen_register_device_domain_owner(struct pci_dev *dev, uint16_t domain)\n{\n\tstruct xen_device_domain_owner *owner;\n\n\towner = kzalloc(sizeof(struct xen_device_domain_owner), GFP_KERNEL);\n\tif (!owner)\n\t\treturn -ENODEV;\n\n\tspin_lock(&dev_domain_list_spinlock);\n\tif (find_device(dev)) {\n\t\tspin_unlock(&dev_domain_list_spinlock);\n\t\tkfree(owner);\n\t\treturn -EEXIST;\n\t}\n\towner->domain = domain;\n\towner->dev = dev;\n\tlist_add_tail(&owner->list, &dev_domain_list);\n\tspin_unlock(&dev_domain_list_spinlock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xen_register_device_domain_owner);\n\nint xen_unregister_device_domain_owner(struct pci_dev *dev)\n{\n\tstruct xen_device_domain_owner *owner;\n\n\tspin_lock(&dev_domain_list_spinlock);\n\towner = find_device(dev);\n\tif (!owner) {\n\t\tspin_unlock(&dev_domain_list_spinlock);\n\t\treturn -ENODEV;\n\t}\n\tlist_del(&owner->list);\n\tspin_unlock(&dev_domain_list_spinlock);\n\tkfree(owner);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xen_unregister_device_domain_owner);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}