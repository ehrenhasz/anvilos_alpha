{
  "module_name": "xen-acpi-pad.c",
  "hash_id": "871162b2d92f86724a95550399b5900b3248573243fde5436c77bf5505ebe609",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-acpi-pad.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/acpi.h>\n#include <xen/xen.h>\n#include <xen/interface/version.h>\n#include <xen/xen-ops.h>\n#include <asm/xen/hypercall.h>\n\n#define ACPI_PROCESSOR_AGGREGATOR_CLASS\t\"acpi_pad\"\n#define ACPI_PROCESSOR_AGGREGATOR_DEVICE_NAME \"Processor Aggregator\"\n#define ACPI_PROCESSOR_AGGREGATOR_NOTIFY 0x80\nstatic DEFINE_MUTEX(xen_cpu_lock);\n\nstatic int xen_acpi_pad_idle_cpus(unsigned int idle_nums)\n{\n\tstruct xen_platform_op op;\n\n\top.cmd = XENPF_core_parking;\n\top.u.core_parking.type = XEN_CORE_PARKING_SET;\n\top.u.core_parking.idle_nums = idle_nums;\n\n\treturn HYPERVISOR_platform_op(&op);\n}\n\nstatic int xen_acpi_pad_idle_cpus_num(void)\n{\n\tstruct xen_platform_op op;\n\n\top.cmd = XENPF_core_parking;\n\top.u.core_parking.type = XEN_CORE_PARKING_GET;\n\n\treturn HYPERVISOR_platform_op(&op)\n\t       ?: op.u.core_parking.idle_nums;\n}\n\n \nstatic int acpi_pad_pur(acpi_handle handle)\n{\n\tstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\n\tunion acpi_object *package;\n\tint num = -1;\n\n\tif (ACPI_FAILURE(acpi_evaluate_object(handle, \"_PUR\", NULL, &buffer)))\n\t\treturn num;\n\n\tif (!buffer.length || !buffer.pointer)\n\t\treturn num;\n\n\tpackage = buffer.pointer;\n\n\tif (package->type == ACPI_TYPE_PACKAGE &&\n\t\tpackage->package.count == 2 &&\n\t\tpackage->package.elements[0].integer.value == 1)  \n\t\tnum = package->package.elements[1].integer.value;\n\n\tkfree(buffer.pointer);\n\treturn num;\n}\n\nstatic void acpi_pad_handle_notify(acpi_handle handle)\n{\n\tint idle_nums;\n\tstruct acpi_buffer param = {\n\t\t.length = 4,\n\t\t.pointer = (void *)&idle_nums,\n\t};\n\n\n\tmutex_lock(&xen_cpu_lock);\n\tidle_nums = acpi_pad_pur(handle);\n\tif (idle_nums < 0) {\n\t\tmutex_unlock(&xen_cpu_lock);\n\t\treturn;\n\t}\n\n\tidle_nums = xen_acpi_pad_idle_cpus(idle_nums)\n\t\t    ?: xen_acpi_pad_idle_cpus_num();\n\tif (idle_nums >= 0)\n\t\tacpi_evaluate_ost(handle, ACPI_PROCESSOR_AGGREGATOR_NOTIFY,\n\t\t\t\t  0, &param);\n\tmutex_unlock(&xen_cpu_lock);\n}\n\nstatic void acpi_pad_notify(acpi_handle handle, u32 event,\n\tvoid *data)\n{\n\tswitch (event) {\n\tcase ACPI_PROCESSOR_AGGREGATOR_NOTIFY:\n\t\tacpi_pad_handle_notify(handle);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unsupported event [0x%x]\\n\", event);\n\t\tbreak;\n\t}\n}\n\nstatic int acpi_pad_add(struct acpi_device *device)\n{\n\tacpi_status status;\n\n\tstrcpy(acpi_device_name(device), ACPI_PROCESSOR_AGGREGATOR_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_PROCESSOR_AGGREGATOR_CLASS);\n\n\tstatus = acpi_install_notify_handler(device->handle,\n\t\tACPI_DEVICE_NOTIFY, acpi_pad_notify, device);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void acpi_pad_remove(struct acpi_device *device)\n{\n\tmutex_lock(&xen_cpu_lock);\n\txen_acpi_pad_idle_cpus(0);\n\tmutex_unlock(&xen_cpu_lock);\n\n\tacpi_remove_notify_handler(device->handle,\n\t\tACPI_DEVICE_NOTIFY, acpi_pad_notify);\n}\n\nstatic const struct acpi_device_id pad_device_ids[] = {\n\t{\"ACPI000C\", 0},\n\t{\"\", 0},\n};\n\nstatic struct acpi_driver acpi_pad_driver = {\n\t.name = \"processor_aggregator\",\n\t.class = ACPI_PROCESSOR_AGGREGATOR_CLASS,\n\t.ids = pad_device_ids,\n\t.ops = {\n\t\t.add = acpi_pad_add,\n\t\t.remove = acpi_pad_remove,\n\t},\n};\n\nstatic int __init xen_acpi_pad_init(void)\n{\n\t \n\tif (!xen_initial_domain())\n\t\treturn -ENODEV;\n\n\t \n\tif (!xen_running_on_version_or_later(4, 2))\n\t\treturn -ENODEV;\n\n\treturn acpi_bus_register_driver(&acpi_pad_driver);\n}\nsubsys_initcall(xen_acpi_pad_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}