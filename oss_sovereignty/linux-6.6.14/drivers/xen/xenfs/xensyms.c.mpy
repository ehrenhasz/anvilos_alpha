{
  "module_name": "xensyms.c",
  "hash_id": "7c0cd9a2a3319f6711dd35b582c461e410862ba6f587ebd2136f8e67759b7e69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xenfs/xensyms.c",
  "human_readable_source": "\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <xen/interface/platform.h>\n#include <asm/xen/hypercall.h>\n#include <xen/xen-ops.h>\n#include \"xenfs.h\"\n\n\n#define XEN_KSYM_NAME_LEN 127  \n\nstruct xensyms {\n\tstruct xen_platform_op op;\n\tchar *name;\n\tuint32_t namelen;\n};\n\n \nstatic int xensyms_next_sym(struct xensyms *xs)\n{\n\tint ret;\n\tstruct xenpf_symdata *symdata = &xs->op.u.symdata;\n\tuint64_t symnum;\n\n\tmemset(xs->name, 0, xs->namelen);\n\tsymdata->namelen = xs->namelen;\n\n\tsymnum = symdata->symnum;\n\n\tret = HYPERVISOR_platform_op(&xs->op);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (unlikely(symdata->namelen > xs->namelen)) {\n\t\tkfree(xs->name);\n\n\t\txs->namelen = symdata->namelen;\n\t\txs->name = kzalloc(xs->namelen, GFP_KERNEL);\n\t\tif (!xs->name)\n\t\t\treturn -ENOMEM;\n\n\t\tset_xen_guest_handle(symdata->name, xs->name);\n\t\tsymdata->symnum--;  \n\n\t\tret = HYPERVISOR_platform_op(&xs->op);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (symdata->symnum == symnum)\n\t\t \n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void *xensyms_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct xensyms *xs = m->private;\n\n\txs->op.u.symdata.symnum = *pos;\n\n\tif (xensyms_next_sym(xs))\n\t\treturn NULL;\n\n\treturn m->private;\n}\n\nstatic void *xensyms_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\tstruct xensyms *xs = m->private;\n\n\txs->op.u.symdata.symnum = ++(*pos);\n\n\tif (xensyms_next_sym(xs))\n\t\treturn NULL;\n\n\treturn p;\n}\n\nstatic int xensyms_show(struct seq_file *m, void *p)\n{\n\tstruct xensyms *xs = m->private;\n\tstruct xenpf_symdata *symdata = &xs->op.u.symdata;\n\n\tseq_printf(m, \"%016llx %c %s\\n\", symdata->address,\n\t\t   symdata->type, xs->name);\n\n\treturn 0;\n}\n\nstatic void xensyms_stop(struct seq_file *m, void *p)\n{\n}\n\nstatic const struct seq_operations xensyms_seq_ops = {\n\t.start = xensyms_start,\n\t.next = xensyms_next,\n\t.show = xensyms_show,\n\t.stop = xensyms_stop,\n};\n\nstatic int xensyms_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m;\n\tstruct xensyms *xs;\n\tint ret;\n\n\tret = seq_open_private(file, &xensyms_seq_ops,\n\t\t\t       sizeof(struct xensyms));\n\tif (ret)\n\t\treturn ret;\n\n\tm = file->private_data;\n\txs = m->private;\n\n\txs->namelen = XEN_KSYM_NAME_LEN + 1;\n\txs->name = kzalloc(xs->namelen, GFP_KERNEL);\n\tif (!xs->name) {\n\t\tseq_release_private(inode, file);\n\t\treturn -ENOMEM;\n\t}\n\tset_xen_guest_handle(xs->op.u.symdata.name, xs->name);\n\txs->op.cmd = XENPF_get_symbol;\n\txs->op.u.symdata.namelen = xs->namelen;\n\n\treturn 0;\n}\n\nstatic int xensyms_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct xensyms *xs = m->private;\n\n\tkfree(xs->name);\n\treturn seq_release_private(inode, file);\n}\n\nconst struct file_operations xensyms_ops = {\n\t.open = xensyms_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = xensyms_release\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}