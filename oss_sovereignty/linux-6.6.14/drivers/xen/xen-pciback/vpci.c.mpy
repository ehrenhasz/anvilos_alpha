{
  "module_name": "vpci.c",
  "hash_id": "3eee5527950fc09647412f3be8fdeca1aed066ccd380393a3a71887edf226ecd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-pciback/vpci.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#define dev_fmt pr_fmt\n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include \"pciback.h\"\n\n#define PCI_SLOT_MAX 32\n\nstruct vpci_dev_data {\n\t \n\tstruct list_head dev_list[PCI_SLOT_MAX];\n\tstruct mutex lock;\n};\n\nstatic inline struct list_head *list_first(struct list_head *head)\n{\n\treturn head->next;\n}\n\nstatic struct pci_dev *__xen_pcibk_get_pci_dev(struct xen_pcibk_device *pdev,\n\t\t\t\t\t       unsigned int domain,\n\t\t\t\t\t       unsigned int bus,\n\t\t\t\t\t       unsigned int devfn)\n{\n\tstruct pci_dev_entry *entry;\n\tstruct pci_dev *dev = NULL;\n\tstruct vpci_dev_data *vpci_dev = pdev->pci_dev_data;\n\n\tif (domain != 0 || bus != 0)\n\t\treturn NULL;\n\n\tif (PCI_SLOT(devfn) < PCI_SLOT_MAX) {\n\t\tmutex_lock(&vpci_dev->lock);\n\n\t\tlist_for_each_entry(entry,\n\t\t\t\t    &vpci_dev->dev_list[PCI_SLOT(devfn)],\n\t\t\t\t    list) {\n\t\t\tif (PCI_FUNC(entry->dev->devfn) == PCI_FUNC(devfn)) {\n\t\t\t\tdev = entry->dev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmutex_unlock(&vpci_dev->lock);\n\t}\n\treturn dev;\n}\n\nstatic inline int match_slot(struct pci_dev *l, struct pci_dev *r)\n{\n\tif (pci_domain_nr(l->bus) == pci_domain_nr(r->bus)\n\t    && l->bus == r->bus && PCI_SLOT(l->devfn) == PCI_SLOT(r->devfn))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int __xen_pcibk_add_pci_dev(struct xen_pcibk_device *pdev,\n\t\t\t\t   struct pci_dev *dev, int devid,\n\t\t\t\t   publish_pci_dev_cb publish_cb)\n{\n\tint err = 0, slot, func = PCI_FUNC(dev->devfn);\n\tstruct pci_dev_entry *t, *dev_entry;\n\tstruct vpci_dev_data *vpci_dev = pdev->pci_dev_data;\n\n\tif ((dev->class >> 24) == PCI_BASE_CLASS_BRIDGE) {\n\t\terr = -EFAULT;\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Can't export bridges on the virtual PCI bus\");\n\t\tgoto out;\n\t}\n\n\tdev_entry = kmalloc(sizeof(*dev_entry), GFP_KERNEL);\n\tif (!dev_entry) {\n\t\terr = -ENOMEM;\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error adding entry to virtual PCI bus\");\n\t\tgoto out;\n\t}\n\n\tdev_entry->dev = dev;\n\n\tmutex_lock(&vpci_dev->lock);\n\n\t \n\tif (!dev->is_virtfn || func) {\n\t\tfor (slot = 0; slot < PCI_SLOT_MAX; slot++) {\n\t\t\tif (list_empty(&vpci_dev->dev_list[slot]))\n\t\t\t\tcontinue;\n\n\t\t\tt = list_entry(list_first(&vpci_dev->dev_list[slot]),\n\t\t\t\t       struct pci_dev_entry, list);\n\t\t\tif (t->dev->is_virtfn && !PCI_FUNC(t->dev->devfn))\n\t\t\t\tcontinue;\n\n\t\t\tif (match_slot(dev, t->dev)) {\n\t\t\t\tdev_info(&dev->dev, \"vpci: assign to virtual slot %d func %d\\n\",\n\t\t\t\t\t slot, func);\n\t\t\t\tlist_add_tail(&dev_entry->list,\n\t\t\t\t\t      &vpci_dev->dev_list[slot]);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (slot = 0; slot < PCI_SLOT_MAX; slot++) {\n\t\tif (list_empty(&vpci_dev->dev_list[slot])) {\n\t\t\tdev_info(&dev->dev, \"vpci: assign to virtual slot %d\\n\",\n\t\t\t\t slot);\n\t\t\tlist_add_tail(&dev_entry->list,\n\t\t\t\t      &vpci_dev->dev_list[slot]);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\terr = -ENOMEM;\n\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t \"No more space on root virtual PCI bus\");\n\nunlock:\n\tmutex_unlock(&vpci_dev->lock);\n\n\t \n\tif (!err)\n\t\terr = publish_cb(pdev, 0, 0, PCI_DEVFN(slot, func), devid);\n\telse\n\t\tkfree(dev_entry);\n\nout:\n\treturn err;\n}\n\nstatic void __xen_pcibk_release_pci_dev(struct xen_pcibk_device *pdev,\n\t\t\t\t\tstruct pci_dev *dev, bool lock)\n{\n\tint slot;\n\tstruct vpci_dev_data *vpci_dev = pdev->pci_dev_data;\n\tstruct pci_dev *found_dev = NULL;\n\n\tmutex_lock(&vpci_dev->lock);\n\n\tfor (slot = 0; slot < PCI_SLOT_MAX; slot++) {\n\t\tstruct pci_dev_entry *e;\n\n\t\tlist_for_each_entry(e, &vpci_dev->dev_list[slot], list) {\n\t\t\tif (e->dev == dev) {\n\t\t\t\tlist_del(&e->list);\n\t\t\t\tfound_dev = e->dev;\n\t\t\t\tkfree(e);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&vpci_dev->lock);\n\n\tif (found_dev) {\n\t\tif (lock)\n\t\t\tdevice_lock(&found_dev->dev);\n\t\tpcistub_put_pci_dev(found_dev);\n\t\tif (lock)\n\t\t\tdevice_unlock(&found_dev->dev);\n\t}\n}\n\nstatic int __xen_pcibk_init_devices(struct xen_pcibk_device *pdev)\n{\n\tint slot;\n\tstruct vpci_dev_data *vpci_dev;\n\n\tvpci_dev = kmalloc(sizeof(*vpci_dev), GFP_KERNEL);\n\tif (!vpci_dev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&vpci_dev->lock);\n\n\tfor (slot = 0; slot < PCI_SLOT_MAX; slot++)\n\t\tINIT_LIST_HEAD(&vpci_dev->dev_list[slot]);\n\n\tpdev->pci_dev_data = vpci_dev;\n\n\treturn 0;\n}\n\nstatic int __xen_pcibk_publish_pci_roots(struct xen_pcibk_device *pdev,\n\t\t\t\t\t publish_pci_root_cb publish_cb)\n{\n\t \n\treturn publish_cb(pdev, 0, 0);\n}\n\nstatic void __xen_pcibk_release_devices(struct xen_pcibk_device *pdev)\n{\n\tint slot;\n\tstruct vpci_dev_data *vpci_dev = pdev->pci_dev_data;\n\n\tfor (slot = 0; slot < PCI_SLOT_MAX; slot++) {\n\t\tstruct pci_dev_entry *e, *tmp;\n\t\tlist_for_each_entry_safe(e, tmp, &vpci_dev->dev_list[slot],\n\t\t\t\t\t list) {\n\t\t\tstruct pci_dev *dev = e->dev;\n\t\t\tlist_del(&e->list);\n\t\t\tdevice_lock(&dev->dev);\n\t\t\tpcistub_put_pci_dev(dev);\n\t\t\tdevice_unlock(&dev->dev);\n\t\t\tkfree(e);\n\t\t}\n\t}\n\n\tkfree(vpci_dev);\n\tpdev->pci_dev_data = NULL;\n}\n\nstatic int __xen_pcibk_get_pcifront_dev(struct pci_dev *pcidev,\n\t\t\t\t\tstruct xen_pcibk_device *pdev,\n\t\t\t\t\tunsigned int *domain, unsigned int *bus,\n\t\t\t\t\tunsigned int *devfn)\n{\n\tstruct pci_dev_entry *entry;\n\tstruct vpci_dev_data *vpci_dev = pdev->pci_dev_data;\n\tint found = 0, slot;\n\n\tmutex_lock(&vpci_dev->lock);\n\tfor (slot = 0; slot < PCI_SLOT_MAX; slot++) {\n\t\tlist_for_each_entry(entry,\n\t\t\t    &vpci_dev->dev_list[slot],\n\t\t\t    list) {\n\t\t\tif (entry->dev == pcidev) {\n\t\t\t\tfound = 1;\n\t\t\t\t*domain = 0;\n\t\t\t\t*bus = 0;\n\t\t\t\t*devfn = PCI_DEVFN(slot,\n\t\t\t\t\t PCI_FUNC(pcidev->devfn));\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&vpci_dev->lock);\n\treturn found;\n}\n\nconst struct xen_pcibk_backend xen_pcibk_vpci_backend = {\n\t.name\t\t= \"vpci\",\n\t.init\t\t= __xen_pcibk_init_devices,\n\t.free\t\t= __xen_pcibk_release_devices,\n\t.find\t\t= __xen_pcibk_get_pcifront_dev,\n\t.publish\t= __xen_pcibk_publish_pci_roots,\n\t.release\t= __xen_pcibk_release_pci_dev,\n\t.add\t\t= __xen_pcibk_add_pci_dev,\n\t.get\t\t= __xen_pcibk_get_pci_dev,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}