{
  "module_name": "xenbus.c",
  "hash_id": "19a9cae4ad4717f20cdbf0e06719766e18044f79c153bfd6b2a57fae607620de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-pciback/xenbus.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/workqueue.h>\n#include <xen/xenbus.h>\n#include <xen/events.h>\n#include <xen/pci.h>\n#include \"pciback.h\"\n\n#define INVALID_EVTCHN_IRQ  (-1)\n\nstatic bool __read_mostly passthrough;\nmodule_param(passthrough, bool, S_IRUGO);\nMODULE_PARM_DESC(passthrough,\n\t\"Option to specify how to export PCI topology to guest:\\n\"\\\n\t\" 0 - (default) Hide the true PCI topology and makes the frontend\\n\"\\\n\t\"   there is a single PCI bus with only the exported devices on it.\\n\"\\\n\t\"   For example, a device at 03:05.0 will be re-assigned to 00:00.0\\n\"\\\n\t\"   while second device at 02:1a.1 will be re-assigned to 00:01.1.\\n\"\\\n\t\" 1 - Passthrough provides a real view of the PCI topology to the\\n\"\\\n\t\"   frontend (for example, a device at 06:01.b will still appear at\\n\"\\\n\t\"   06:01.b to the frontend). This is similar to how Xen 2.0.x\\n\"\\\n\t\"   exposed PCI devices to its driver domains. This may be required\\n\"\\\n\t\"   for drivers which depend on finding their hardware in certain\\n\"\\\n\t\"   bus/slot locations.\");\n\nstatic struct xen_pcibk_device *alloc_pdev(struct xenbus_device *xdev)\n{\n\tstruct xen_pcibk_device *pdev;\n\n\tpdev = kzalloc(sizeof(struct xen_pcibk_device), GFP_KERNEL);\n\tif (pdev == NULL)\n\t\tgoto out;\n\tdev_dbg(&xdev->dev, \"allocated pdev @ 0x%p\\n\", pdev);\n\n\tpdev->xdev = xdev;\n\n\tmutex_init(&pdev->dev_lock);\n\n\tpdev->sh_info = NULL;\n\tpdev->evtchn_irq = INVALID_EVTCHN_IRQ;\n\tpdev->be_watching = 0;\n\n\tINIT_WORK(&pdev->op_work, xen_pcibk_do_op);\n\n\tif (xen_pcibk_init_devices(pdev)) {\n\t\tkfree(pdev);\n\t\tpdev = NULL;\n\t}\n\n\tdev_set_drvdata(&xdev->dev, pdev);\n\nout:\n\treturn pdev;\n}\n\nstatic void xen_pcibk_disconnect(struct xen_pcibk_device *pdev)\n{\n\tmutex_lock(&pdev->dev_lock);\n\t \n\tif (pdev->evtchn_irq != INVALID_EVTCHN_IRQ) {\n\t\tunbind_from_irqhandler(pdev->evtchn_irq, pdev);\n\t\tpdev->evtchn_irq = INVALID_EVTCHN_IRQ;\n\t}\n\n\t \n\n\tflush_work(&pdev->op_work);\n\n\tif (pdev->sh_info != NULL) {\n\t\txenbus_unmap_ring_vfree(pdev->xdev, pdev->sh_info);\n\t\tpdev->sh_info = NULL;\n\t}\n\tmutex_unlock(&pdev->dev_lock);\n}\n\nstatic void free_pdev(struct xen_pcibk_device *pdev)\n{\n\tif (pdev->be_watching) {\n\t\tunregister_xenbus_watch(&pdev->be_watch);\n\t\tpdev->be_watching = 0;\n\t}\n\n\txen_pcibk_disconnect(pdev);\n\n\t \n\txen_pcibk_release_devices(pdev);\n\n\tdev_set_drvdata(&pdev->xdev->dev, NULL);\n\tpdev->xdev = NULL;\n\n\tkfree(pdev);\n}\n\nstatic int xen_pcibk_do_attach(struct xen_pcibk_device *pdev, int gnt_ref,\n\t\t\t     evtchn_port_t remote_evtchn)\n{\n\tint err = 0;\n\tvoid *vaddr;\n\n\tdev_dbg(&pdev->xdev->dev,\n\t\t\"Attaching to frontend resources - gnt_ref=%d evtchn=%u\\n\",\n\t\tgnt_ref, remote_evtchn);\n\n\terr = xenbus_map_ring_valloc(pdev->xdev, &gnt_ref, 1, &vaddr);\n\tif (err < 0) {\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\"Error mapping other domain page in ours.\");\n\t\tgoto out;\n\t}\n\n\tpdev->sh_info = vaddr;\n\n\terr = bind_interdomain_evtchn_to_irqhandler_lateeoi(\n\t\tpdev->xdev, remote_evtchn, xen_pcibk_handle_event,\n\t\t0, DRV_NAME, pdev);\n\tif (err < 0) {\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error binding event channel to IRQ\");\n\t\tgoto out;\n\t}\n\tpdev->evtchn_irq = err;\n\terr = 0;\n\n\tdev_dbg(&pdev->xdev->dev, \"Attached!\\n\");\nout:\n\treturn err;\n}\n\nstatic int xen_pcibk_attach(struct xen_pcibk_device *pdev)\n{\n\tint err = 0;\n\tint gnt_ref;\n\tevtchn_port_t remote_evtchn;\n\tchar *magic = NULL;\n\n\n\tmutex_lock(&pdev->dev_lock);\n\t \n\tif (xenbus_read_driver_state(pdev->xdev->nodename) !=\n\t    XenbusStateInitialised)\n\t\tgoto out;\n\n\t \n\tif (xenbus_read_driver_state(pdev->xdev->otherend) !=\n\t    XenbusStateInitialised)\n\t\tgoto out;\n\n\tdev_dbg(&pdev->xdev->dev, \"Reading frontend config\\n\");\n\n\terr = xenbus_gather(XBT_NIL, pdev->xdev->otherend,\n\t\t\t    \"pci-op-ref\", \"%u\", &gnt_ref,\n\t\t\t    \"event-channel\", \"%u\", &remote_evtchn,\n\t\t\t    \"magic\", NULL, &magic, NULL);\n\tif (err) {\n\t\t \n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error reading configuration from frontend\");\n\t\tgoto out;\n\t}\n\n\tif (magic == NULL || strcmp(magic, XEN_PCI_MAGIC) != 0) {\n\t\txenbus_dev_fatal(pdev->xdev, -EFAULT,\n\t\t\t\t \"version mismatch (%s/%s) with pcifront - \"\n\t\t\t\t \"halting \" DRV_NAME,\n\t\t\t\t magic, XEN_PCI_MAGIC);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = xen_pcibk_do_attach(pdev, gnt_ref, remote_evtchn);\n\tif (err)\n\t\tgoto out;\n\n\tdev_dbg(&pdev->xdev->dev, \"Connecting...\\n\");\n\n\terr = xenbus_switch_state(pdev->xdev, XenbusStateConnected);\n\tif (err)\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error switching to connected state!\");\n\n\tdev_dbg(&pdev->xdev->dev, \"Connected? %d\\n\", err);\nout:\n\tmutex_unlock(&pdev->dev_lock);\n\n\tkfree(magic);\n\n\treturn err;\n}\n\nstatic int xen_pcibk_publish_pci_dev(struct xen_pcibk_device *pdev,\n\t\t\t\t   unsigned int domain, unsigned int bus,\n\t\t\t\t   unsigned int devfn, unsigned int devid)\n{\n\tint err;\n\tint len;\n\tchar str[64];\n\n\tlen = snprintf(str, sizeof(str), \"vdev-%d\", devid);\n\tif (unlikely(len >= (sizeof(str) - 1))) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\terr = xenbus_printf(XBT_NIL, pdev->xdev->nodename, str,\n\t\t\t    \"%04x:%02x:%02x.%02x\", domain, bus,\n\t\t\t    PCI_SLOT(devfn), PCI_FUNC(devfn));\n\nout:\n\treturn err;\n}\n\nstatic int xen_pcibk_export_device(struct xen_pcibk_device *pdev,\n\t\t\t\t int domain, int bus, int slot, int func,\n\t\t\t\t int devid)\n{\n\tstruct pci_dev *dev;\n\tint err = 0;\n\n\tdev_dbg(&pdev->xdev->dev, \"exporting dom %x bus %x slot %x func %x\\n\",\n\t\tdomain, bus, slot, func);\n\n\tdev = pcistub_get_pci_dev_by_slot(pdev, domain, bus, slot, func);\n\tif (!dev) {\n\t\terr = -EINVAL;\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Couldn't locate PCI device \"\n\t\t\t\t \"(%04x:%02x:%02x.%d)! \"\n\t\t\t\t \"perhaps already in-use?\",\n\t\t\t\t domain, bus, slot, func);\n\t\tgoto out;\n\t}\n\n\terr = xen_pcibk_add_pci_dev(pdev, dev, devid,\n\t\t\t\t    xen_pcibk_publish_pci_dev);\n\tif (err)\n\t\tgoto out;\n\n\tdev_info(&dev->dev, \"registering for %d\\n\", pdev->xdev->otherend_id);\n\tif (xen_register_device_domain_owner(dev,\n\t\t\t\t\t     pdev->xdev->otherend_id) != 0) {\n\t\tdev_err(&dev->dev, \"Stealing ownership from dom%d.\\n\",\n\t\t\txen_find_device_domain_owner(dev));\n\t\txen_unregister_device_domain_owner(dev);\n\t\txen_register_device_domain_owner(dev, pdev->xdev->otherend_id);\n\t}\n\n\t \nout:\n\treturn err;\n}\n\nstatic int xen_pcibk_remove_device(struct xen_pcibk_device *pdev,\n\t\t\t\t int domain, int bus, int slot, int func)\n{\n\tint err = 0;\n\tstruct pci_dev *dev;\n\n\tdev_dbg(&pdev->xdev->dev, \"removing dom %x bus %x slot %x func %x\\n\",\n\t\tdomain, bus, slot, func);\n\n\tdev = xen_pcibk_get_pci_dev(pdev, domain, bus, PCI_DEVFN(slot, func));\n\tif (!dev) {\n\t\terr = -EINVAL;\n\t\tdev_dbg(&pdev->xdev->dev, \"Couldn't locate PCI device \"\n\t\t\t\"(%04x:%02x:%02x.%d)! not owned by this domain\\n\",\n\t\t\tdomain, bus, slot, func);\n\t\tgoto out;\n\t}\n\n\tdev_dbg(&dev->dev, \"unregistering for %d\\n\", pdev->xdev->otherend_id);\n\txen_unregister_device_domain_owner(dev);\n\n\t \n\txen_pcibk_release_pci_dev(pdev, dev, true  );\n\nout:\n\treturn err;\n}\n\nstatic int xen_pcibk_publish_pci_root(struct xen_pcibk_device *pdev,\n\t\t\t\t    unsigned int domain, unsigned int bus)\n{\n\tunsigned int d, b;\n\tint i, root_num, len, err;\n\tchar str[64];\n\n\tdev_dbg(&pdev->xdev->dev, \"Publishing pci roots\\n\");\n\n\terr = xenbus_scanf(XBT_NIL, pdev->xdev->nodename,\n\t\t\t   \"root_num\", \"%d\", &root_num);\n\tif (err == 0 || err == -ENOENT)\n\t\troot_num = 0;\n\telse if (err < 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < root_num; i++) {\n\t\tlen = snprintf(str, sizeof(str), \"root-%d\", i);\n\t\tif (unlikely(len >= (sizeof(str) - 1))) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = xenbus_scanf(XBT_NIL, pdev->xdev->nodename,\n\t\t\t\t   str, \"%x:%x\", &d, &b);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tif (err != 2) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (d == domain && b == bus) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlen = snprintf(str, sizeof(str), \"root-%d\", root_num);\n\tif (unlikely(len >= (sizeof(str) - 1))) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdev_dbg(&pdev->xdev->dev, \"writing root %d at %04x:%02x\\n\",\n\t\troot_num, domain, bus);\n\n\terr = xenbus_printf(XBT_NIL, pdev->xdev->nodename, str,\n\t\t\t    \"%04x:%02x\", domain, bus);\n\tif (err)\n\t\tgoto out;\n\n\terr = xenbus_printf(XBT_NIL, pdev->xdev->nodename,\n\t\t\t    \"root_num\", \"%d\", (root_num + 1));\n\nout:\n\treturn err;\n}\n\nstatic int xen_pcibk_reconfigure(struct xen_pcibk_device *pdev,\n\t\t\t\t enum xenbus_state state)\n{\n\tint err = 0;\n\tint num_devs;\n\tint domain, bus, slot, func;\n\tunsigned int substate;\n\tint i, len;\n\tchar state_str[64];\n\tchar dev_str[64];\n\n\n\tdev_dbg(&pdev->xdev->dev, \"Reconfiguring device ...\\n\");\n\n\tmutex_lock(&pdev->dev_lock);\n\tif (xenbus_read_driver_state(pdev->xdev->nodename) != state)\n\t\tgoto out;\n\n\terr = xenbus_scanf(XBT_NIL, pdev->xdev->nodename, \"num_devs\", \"%d\",\n\t\t\t   &num_devs);\n\tif (err != 1) {\n\t\tif (err >= 0)\n\t\t\terr = -EINVAL;\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error reading number of devices\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_devs; i++) {\n\t\tlen = snprintf(state_str, sizeof(state_str), \"state-%d\", i);\n\t\tif (unlikely(len >= (sizeof(state_str) - 1))) {\n\t\t\terr = -ENOMEM;\n\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t \"String overflow while reading \"\n\t\t\t\t\t \"configuration\");\n\t\t\tgoto out;\n\t\t}\n\t\tsubstate = xenbus_read_unsigned(pdev->xdev->nodename, state_str,\n\t\t\t\t\t\tXenbusStateUnknown);\n\n\t\tswitch (substate) {\n\t\tcase XenbusStateInitialising:\n\t\t\tdev_dbg(&pdev->xdev->dev, \"Attaching dev-%d ...\\n\", i);\n\n\t\t\tlen = snprintf(dev_str, sizeof(dev_str), \"dev-%d\", i);\n\t\t\tif (unlikely(len >= (sizeof(dev_str) - 1))) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t\t \"String overflow while \"\n\t\t\t\t\t\t \"reading configuration\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = xenbus_scanf(XBT_NIL, pdev->xdev->nodename,\n\t\t\t\t\t   dev_str, \"%x:%x:%x.%x\",\n\t\t\t\t\t   &domain, &bus, &slot, &func);\n\t\t\tif (err < 0) {\n\t\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t\t \"Error reading device \"\n\t\t\t\t\t\t \"configuration\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (err != 4) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t\t \"Error parsing pci device \"\n\t\t\t\t\t\t \"configuration\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = xen_pcibk_export_device(pdev, domain, bus, slot,\n\t\t\t\t\t\t    func, i);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\terr = xen_pcibk_publish_pci_roots(pdev,\n\t\t\t\t\t\txen_pcibk_publish_pci_root);\n\t\t\tif (err) {\n\t\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t\t \"Error while publish PCI root\"\n\t\t\t\t\t\t \"buses for frontend\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = xenbus_printf(XBT_NIL, pdev->xdev->nodename,\n\t\t\t\t\t    state_str, \"%d\",\n\t\t\t\t\t    XenbusStateInitialised);\n\t\t\tif (err) {\n\t\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t\t \"Error switching substate of \"\n\t\t\t\t\t\t \"dev-%d\\n\", i);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XenbusStateClosing:\n\t\t\tdev_dbg(&pdev->xdev->dev, \"Detaching dev-%d ...\\n\", i);\n\n\t\t\tlen = snprintf(dev_str, sizeof(dev_str), \"vdev-%d\", i);\n\t\t\tif (unlikely(len >= (sizeof(dev_str) - 1))) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t\t \"String overflow while \"\n\t\t\t\t\t\t \"reading configuration\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = xenbus_scanf(XBT_NIL, pdev->xdev->nodename,\n\t\t\t\t\t   dev_str, \"%x:%x:%x.%x\",\n\t\t\t\t\t   &domain, &bus, &slot, &func);\n\t\t\tif (err < 0) {\n\t\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t\t \"Error reading device \"\n\t\t\t\t\t\t \"configuration\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (err != 4) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t\t \"Error parsing pci device \"\n\t\t\t\t\t\t \"configuration\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = xen_pcibk_remove_device(pdev, domain, bus, slot,\n\t\t\t\t\t\t    func);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\t \n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (state != XenbusStateReconfiguring)\n\t\t \n\t\tgoto out;\n\n\terr = xenbus_switch_state(pdev->xdev, XenbusStateReconfigured);\n\tif (err) {\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error switching to reconfigured state!\");\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&pdev->dev_lock);\n\treturn 0;\n}\n\nstatic void xen_pcibk_frontend_changed(struct xenbus_device *xdev,\n\t\t\t\t     enum xenbus_state fe_state)\n{\n\tstruct xen_pcibk_device *pdev = dev_get_drvdata(&xdev->dev);\n\n\tdev_dbg(&xdev->dev, \"fe state changed %d\\n\", fe_state);\n\n\tswitch (fe_state) {\n\tcase XenbusStateInitialised:\n\t\txen_pcibk_attach(pdev);\n\t\tbreak;\n\n\tcase XenbusStateReconfiguring:\n\t\txen_pcibk_reconfigure(pdev, XenbusStateReconfiguring);\n\t\tbreak;\n\n\tcase XenbusStateConnected:\n\t\t \n\t\txenbus_switch_state(xdev, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateClosing:\n\t\txen_pcibk_disconnect(pdev);\n\t\txenbus_switch_state(xdev, XenbusStateClosing);\n\t\tbreak;\n\n\tcase XenbusStateClosed:\n\t\txen_pcibk_disconnect(pdev);\n\t\txenbus_switch_state(xdev, XenbusStateClosed);\n\t\tif (xenbus_dev_is_online(xdev))\n\t\t\tbreak;\n\t\tfallthrough;\t \n\tcase XenbusStateUnknown:\n\t\tdev_dbg(&xdev->dev, \"frontend is gone! unregister device\\n\");\n\t\tdevice_unregister(&xdev->dev);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int xen_pcibk_setup_backend(struct xen_pcibk_device *pdev)\n{\n\t \n\tint domain, bus, slot, func;\n\tint err = 0;\n\tint i, num_devs;\n\tchar dev_str[64];\n\tchar state_str[64];\n\n\tmutex_lock(&pdev->dev_lock);\n\t \n\tif (xenbus_read_driver_state(pdev->xdev->nodename) !=\n\t    XenbusStateInitWait)\n\t\tgoto out;\n\n\tdev_dbg(&pdev->xdev->dev, \"getting be setup\\n\");\n\n\terr = xenbus_scanf(XBT_NIL, pdev->xdev->nodename, \"num_devs\", \"%d\",\n\t\t\t   &num_devs);\n\tif (err != 1) {\n\t\tif (err >= 0)\n\t\t\terr = -EINVAL;\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error reading number of devices\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_devs; i++) {\n\t\tint l = snprintf(dev_str, sizeof(dev_str), \"dev-%d\", i);\n\t\tif (unlikely(l >= (sizeof(dev_str) - 1))) {\n\t\t\terr = -ENOMEM;\n\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t \"String overflow while reading \"\n\t\t\t\t\t \"configuration\");\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = xenbus_scanf(XBT_NIL, pdev->xdev->nodename, dev_str,\n\t\t\t\t   \"%x:%x:%x.%x\", &domain, &bus, &slot, &func);\n\t\tif (err < 0) {\n\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t \"Error reading device configuration\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (err != 4) {\n\t\t\terr = -EINVAL;\n\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t \"Error parsing pci device \"\n\t\t\t\t\t \"configuration\");\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = xen_pcibk_export_device(pdev, domain, bus, slot, func, i);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tl = snprintf(state_str, sizeof(state_str), \"state-%d\", i);\n\t\tif (unlikely(l >= (sizeof(state_str) - 1))) {\n\t\t\terr = -ENOMEM;\n\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t \"String overflow while reading \"\n\t\t\t\t\t \"configuration\");\n\t\t\tgoto out;\n\t\t}\n\t\terr = xenbus_printf(XBT_NIL, pdev->xdev->nodename, state_str,\n\t\t\t\t    \"%d\", XenbusStateInitialised);\n\t\tif (err) {\n\t\t\txenbus_dev_fatal(pdev->xdev, err, \"Error switching \"\n\t\t\t\t\t \"substate of dev-%d\\n\", i);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = xen_pcibk_publish_pci_roots(pdev, xen_pcibk_publish_pci_root);\n\tif (err) {\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error while publish PCI root buses \"\n\t\t\t\t \"for frontend\");\n\t\tgoto out;\n\t}\n\n\terr = xenbus_switch_state(pdev->xdev, XenbusStateInitialised);\n\tif (err)\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error switching to initialised state!\");\n\nout:\n\tmutex_unlock(&pdev->dev_lock);\n\tif (!err)\n\t\t \n\t\txen_pcibk_attach(pdev);\n\treturn err;\n}\n\nstatic void xen_pcibk_be_watch(struct xenbus_watch *watch,\n\t\t\t       const char *path, const char *token)\n{\n\tstruct xen_pcibk_device *pdev =\n\t    container_of(watch, struct xen_pcibk_device, be_watch);\n\n\tswitch (xenbus_read_driver_state(pdev->xdev->nodename)) {\n\tcase XenbusStateInitWait:\n\t\txen_pcibk_setup_backend(pdev);\n\t\tbreak;\n\n\tcase XenbusStateInitialised:\n\t\t \n\t\txen_pcibk_reconfigure(pdev, XenbusStateInitialised);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int xen_pcibk_xenbus_probe(struct xenbus_device *dev,\n\t\t\t\tconst struct xenbus_device_id *id)\n{\n\tint err = 0;\n\tstruct xen_pcibk_device *pdev = alloc_pdev(dev);\n\n\tif (pdev == NULL) {\n\t\terr = -ENOMEM;\n\t\txenbus_dev_fatal(dev, err,\n\t\t\t\t \"Error allocating xen_pcibk_device struct\");\n\t\tgoto out;\n\t}\n\n\t \n\terr = xenbus_switch_state(dev, XenbusStateInitWait);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = xenbus_watch_path(dev, dev->nodename, &pdev->be_watch,\n\t\t\t\tNULL, xen_pcibk_be_watch);\n\tif (err)\n\t\tgoto out;\n\n\tpdev->be_watching = 1;\n\n\t \n\txen_pcibk_be_watch(&pdev->be_watch, NULL, NULL);\n\nout:\n\treturn err;\n}\n\nstatic void xen_pcibk_xenbus_remove(struct xenbus_device *dev)\n{\n\tstruct xen_pcibk_device *pdev = dev_get_drvdata(&dev->dev);\n\n\tif (pdev != NULL)\n\t\tfree_pdev(pdev);\n}\n\nstatic const struct xenbus_device_id xen_pcibk_ids[] = {\n\t{\"pci\"},\n\t{\"\"},\n};\n\nstatic struct xenbus_driver xen_pcibk_driver = {\n\t.name                   = DRV_NAME,\n\t.ids                    = xen_pcibk_ids,\n\t.probe\t\t\t= xen_pcibk_xenbus_probe,\n\t.remove\t\t\t= xen_pcibk_xenbus_remove,\n\t.otherend_changed\t= xen_pcibk_frontend_changed,\n};\n\nconst struct xen_pcibk_backend *__read_mostly xen_pcibk_backend;\n\nint __init xen_pcibk_xenbus_register(void)\n{\n\tif (!xen_pcibk_pv_support())\n\t\treturn 0;\n\n\txen_pcibk_backend = &xen_pcibk_vpci_backend;\n\tif (passthrough)\n\t\txen_pcibk_backend = &xen_pcibk_passthrough_backend;\n\tpr_info(\"backend is %s\\n\", xen_pcibk_backend->name);\n\treturn xenbus_register_backend(&xen_pcibk_driver);\n}\n\nvoid __exit xen_pcibk_xenbus_unregister(void)\n{\n\tif (xen_pcibk_pv_support())\n\t\txenbus_unregister_driver(&xen_pcibk_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}