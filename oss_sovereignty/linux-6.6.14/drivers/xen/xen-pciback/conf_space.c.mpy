{
  "module_name": "conf_space.c",
  "hash_id": "42ef8c45f8e9df06e44fea032d0daa36e889559bd4504ab1b09e3e191293bca1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-pciback/conf_space.c",
  "human_readable_source": "\n \n\n#define dev_fmt(fmt) DRV_NAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include \"pciback.h\"\n#include \"conf_space.h\"\n#include \"conf_space_quirks.h\"\n\nbool xen_pcibk_permissive;\nmodule_param_named(permissive, xen_pcibk_permissive, bool, 0644);\n\n \n#define DEFINE_PCI_CONFIG(op, size, type)\t\t\t\\\nint xen_pcibk_##op##_config_##size\t\t\t\t\\\n(struct pci_dev *dev, int offset, type value, void *data)\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn pci_##op##_config_##size(dev, offset, value);\t\\\n}\n\nDEFINE_PCI_CONFIG(read, byte, u8 *)\nDEFINE_PCI_CONFIG(read, word, u16 *)\nDEFINE_PCI_CONFIG(read, dword, u32 *)\n\nDEFINE_PCI_CONFIG(write, byte, u8)\nDEFINE_PCI_CONFIG(write, word, u16)\nDEFINE_PCI_CONFIG(write, dword, u32)\n\nstatic int conf_space_read(struct pci_dev *dev,\n\t\t\t   const struct config_field_entry *entry,\n\t\t\t   int offset, u32 *value)\n{\n\tint ret = 0;\n\tconst struct config_field *field = entry->field;\n\n\t*value = 0;\n\n\tswitch (field->size) {\n\tcase 1:\n\t\tif (field->u.b.read)\n\t\t\tret = field->u.b.read(dev, offset, (u8 *) value,\n\t\t\t\t\t      entry->data);\n\t\tbreak;\n\tcase 2:\n\t\tif (field->u.w.read)\n\t\t\tret = field->u.w.read(dev, offset, (u16 *) value,\n\t\t\t\t\t      entry->data);\n\t\tbreak;\n\tcase 4:\n\t\tif (field->u.dw.read)\n\t\t\tret = field->u.dw.read(dev, offset, value, entry->data);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int conf_space_write(struct pci_dev *dev,\n\t\t\t    const struct config_field_entry *entry,\n\t\t\t    int offset, u32 value)\n{\n\tint ret = 0;\n\tconst struct config_field *field = entry->field;\n\n\tswitch (field->size) {\n\tcase 1:\n\t\tif (field->u.b.write)\n\t\t\tret = field->u.b.write(dev, offset, (u8) value,\n\t\t\t\t\t       entry->data);\n\t\tbreak;\n\tcase 2:\n\t\tif (field->u.w.write)\n\t\t\tret = field->u.w.write(dev, offset, (u16) value,\n\t\t\t\t\t       entry->data);\n\t\tbreak;\n\tcase 4:\n\t\tif (field->u.dw.write)\n\t\t\tret = field->u.dw.write(dev, offset, value,\n\t\t\t\t\t\tentry->data);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic inline u32 get_mask(int size)\n{\n\tif (size == 1)\n\t\treturn 0xff;\n\telse if (size == 2)\n\t\treturn 0xffff;\n\telse\n\t\treturn 0xffffffff;\n}\n\nstatic inline int valid_request(int offset, int size)\n{\n\t \n\tif ((size == 1 || size == 2 || size == 4) && (offset % size) == 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline u32 merge_value(u32 val, u32 new_val, u32 new_val_mask,\n\t\t\t      int offset)\n{\n\tif (offset >= 0) {\n\t\tnew_val_mask <<= (offset * 8);\n\t\tnew_val <<= (offset * 8);\n\t} else {\n\t\tnew_val_mask >>= (offset * -8);\n\t\tnew_val >>= (offset * -8);\n\t}\n\tval = (val & ~new_val_mask) | (new_val & new_val_mask);\n\n\treturn val;\n}\n\nstatic int xen_pcibios_err_to_errno(int err)\n{\n\tswitch (err) {\n\tcase PCIBIOS_SUCCESSFUL:\n\t\treturn XEN_PCI_ERR_success;\n\tcase PCIBIOS_DEVICE_NOT_FOUND:\n\t\treturn XEN_PCI_ERR_dev_not_found;\n\tcase PCIBIOS_BAD_REGISTER_NUMBER:\n\t\treturn XEN_PCI_ERR_invalid_offset;\n\tcase PCIBIOS_FUNC_NOT_SUPPORTED:\n\t\treturn XEN_PCI_ERR_not_implemented;\n\tcase PCIBIOS_SET_FAILED:\n\t\treturn XEN_PCI_ERR_access_denied;\n\t}\n\treturn err;\n}\n\nint xen_pcibk_config_read(struct pci_dev *dev, int offset, int size,\n\t\t\t  u32 *ret_val)\n{\n\tint err = 0;\n\tstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\n\tconst struct config_field_entry *cfg_entry;\n\tconst struct config_field *field;\n\tint field_start, field_end;\n\t \n\tu32 value = 0, tmp_val;\n\n\tdev_dbg(&dev->dev, \"read %d bytes at 0x%x\\n\", size, offset);\n\n\tif (!valid_request(offset, size)) {\n\t\terr = XEN_PCI_ERR_invalid_offset;\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (size) {\n\tcase 1:\n\t\terr = pci_read_config_byte(dev, offset, (u8 *) &value);\n\t\tbreak;\n\tcase 2:\n\t\terr = pci_read_config_word(dev, offset, (u16 *) &value);\n\t\tbreak;\n\tcase 4:\n\t\terr = pci_read_config_dword(dev, offset, &value);\n\t\tbreak;\n\t}\n\n\tlist_for_each_entry(cfg_entry, &dev_data->config_fields, list) {\n\t\tfield = cfg_entry->field;\n\n\t\tfield_start = OFFSET(cfg_entry);\n\t\tfield_end = OFFSET(cfg_entry) + field->size;\n\n\t\tif (offset + size > field_start && field_end > offset) {\n\t\t\terr = conf_space_read(dev, cfg_entry, field_start,\n\t\t\t\t\t      &tmp_val);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tvalue = merge_value(value, tmp_val,\n\t\t\t\t\t    get_mask(field->size),\n\t\t\t\t\t    field_start - offset);\n\t\t}\n\t}\n\nout:\n\tdev_dbg(&dev->dev, \"read %d bytes at 0x%x = %x\\n\", size, offset, value);\n\n\t*ret_val = value;\n\treturn xen_pcibios_err_to_errno(err);\n}\n\nint xen_pcibk_config_write(struct pci_dev *dev, int offset, int size, u32 value)\n{\n\tint err = 0, handled = 0;\n\tstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\n\tconst struct config_field_entry *cfg_entry;\n\tconst struct config_field *field;\n\tu32 tmp_val;\n\tint field_start, field_end;\n\n\tdev_dbg(&dev->dev, \"write request %d bytes at 0x%x = %x\\n\",\n\t\tsize, offset, value);\n\n\tif (!valid_request(offset, size))\n\t\treturn XEN_PCI_ERR_invalid_offset;\n\n\tlist_for_each_entry(cfg_entry, &dev_data->config_fields, list) {\n\t\tfield = cfg_entry->field;\n\n\t\tfield_start = OFFSET(cfg_entry);\n\t\tfield_end = OFFSET(cfg_entry) + field->size;\n\n\t\tif (offset + size > field_start && field_end > offset) {\n\t\t\terr = conf_space_read(dev, cfg_entry, field_start,\n\t\t\t\t\t      &tmp_val);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\ttmp_val = merge_value(tmp_val, value, get_mask(size),\n\t\t\t\t\t      offset - field_start);\n\n\t\t\terr = conf_space_write(dev, cfg_entry, field_start,\n\t\t\t\t\t       tmp_val);\n\n\t\t\t \n\t\t\thandled = 1;\n\t\t}\n\t}\n\n\tif (!handled && !err) {\n\t\t \n\t\tif (dev_data->permissive || xen_pcibk_permissive) {\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\terr = pci_write_config_byte(dev, offset,\n\t\t\t\t\t\t\t    (u8) value);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\terr = pci_write_config_word(dev, offset,\n\t\t\t\t\t\t\t    (u16) value);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\terr = pci_write_config_dword(dev, offset,\n\t\t\t\t\t\t\t     (u32) value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!dev_data->warned_on_write) {\n\t\t\tdev_data->warned_on_write = 1;\n\t\t\tdev_warn(&dev->dev, \"Driver tried to write to a \"\n\t\t\t\t \"read-only configuration space field at offset\"\n\t\t\t\t \" 0x%x, size %d. This may be harmless, but if \"\n\t\t\t\t \"you have problems with your device:\\n\"\n\t\t\t\t \"1) see permissive attribute in sysfs\\n\"\n\t\t\t\t \"2) report problems to the xen-devel \"\n\t\t\t\t \"mailing list along with details of your \"\n\t\t\t\t \"device obtained from lspci.\\n\", offset, size);\n\t\t}\n\t}\n\n\treturn xen_pcibios_err_to_errno(err);\n}\n\nint xen_pcibk_get_interrupt_type(struct pci_dev *dev)\n{\n\tint err;\n\tu16 val;\n\tint ret = 0;\n\n\t \n\tif (dev->msi_cap) {\n\t\terr = pci_read_config_word(dev,\n\t\t\t\tdev->msi_cap + PCI_MSI_FLAGS,\n\t\t\t\t&val);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (val & PCI_MSI_FLAGS_ENABLE)\n\t\t\tret |= INTERRUPT_TYPE_MSI;\n\t}\n\tif (dev->msix_cap) {\n\t\terr = pci_read_config_word(dev,\n\t\t\t\tdev->msix_cap + PCI_MSIX_FLAGS,\n\t\t\t\t&val);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (val & PCI_MSIX_FLAGS_ENABLE)\n\t\t\tret |= INTERRUPT_TYPE_MSIX;\n\t}\n\n\t \n\tif (!ret) {\n\t\terr = pci_read_config_word(dev, PCI_COMMAND, &val);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!(val & PCI_COMMAND_INTX_DISABLE))\n\t\t\tret |= INTERRUPT_TYPE_INTX;\n\t}\n\n\treturn ret ?: INTERRUPT_TYPE_NONE;\n}\n\nvoid xen_pcibk_config_free_dyn_fields(struct pci_dev *dev)\n{\n\tstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\n\tstruct config_field_entry *cfg_entry, *t;\n\tconst struct config_field *field;\n\n\tdev_dbg(&dev->dev, \"free-ing dynamically allocated virtual \"\n\t\t\t   \"configuration space fields\\n\");\n\tif (!dev_data)\n\t\treturn;\n\n\tlist_for_each_entry_safe(cfg_entry, t, &dev_data->config_fields, list) {\n\t\tfield = cfg_entry->field;\n\n\t\tif (field->clean) {\n\t\t\tfield->clean((struct config_field *)field);\n\n\t\t\tkfree(cfg_entry->data);\n\n\t\t\tlist_del(&cfg_entry->list);\n\t\t\tkfree(cfg_entry);\n\t\t}\n\n\t}\n}\n\nvoid xen_pcibk_config_reset_dev(struct pci_dev *dev)\n{\n\tstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\n\tconst struct config_field_entry *cfg_entry;\n\tconst struct config_field *field;\n\n\tdev_dbg(&dev->dev, \"resetting virtual configuration space\\n\");\n\tif (!dev_data)\n\t\treturn;\n\n\tlist_for_each_entry(cfg_entry, &dev_data->config_fields, list) {\n\t\tfield = cfg_entry->field;\n\n\t\tif (field->reset)\n\t\t\tfield->reset(dev, OFFSET(cfg_entry), cfg_entry->data);\n\t}\n}\n\nvoid xen_pcibk_config_free_dev(struct pci_dev *dev)\n{\n\tstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\n\tstruct config_field_entry *cfg_entry, *t;\n\tconst struct config_field *field;\n\n\tdev_dbg(&dev->dev, \"free-ing virtual configuration space fields\\n\");\n\tif (!dev_data)\n\t\treturn;\n\n\tlist_for_each_entry_safe(cfg_entry, t, &dev_data->config_fields, list) {\n\t\tlist_del(&cfg_entry->list);\n\n\t\tfield = cfg_entry->field;\n\n\t\tif (field->release)\n\t\t\tfield->release(dev, OFFSET(cfg_entry), cfg_entry->data);\n\n\t\tkfree(cfg_entry);\n\t}\n}\n\nint xen_pcibk_config_add_field_offset(struct pci_dev *dev,\n\t\t\t\t    const struct config_field *field,\n\t\t\t\t    unsigned int base_offset)\n{\n\tint err = 0;\n\tstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\n\tstruct config_field_entry *cfg_entry;\n\tvoid *tmp;\n\n\tcfg_entry = kmalloc(sizeof(*cfg_entry), GFP_KERNEL);\n\tif (!cfg_entry) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcfg_entry->data = NULL;\n\tcfg_entry->field = field;\n\tcfg_entry->base_offset = base_offset;\n\n\t \n\terr = xen_pcibk_field_is_dup(dev, OFFSET(cfg_entry));\n\tif (err)\n\t\tgoto out;\n\n\tif (field->init) {\n\t\ttmp = field->init(dev, OFFSET(cfg_entry));\n\n\t\tif (IS_ERR(tmp)) {\n\t\t\terr = PTR_ERR(tmp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcfg_entry->data = tmp;\n\t}\n\n\tdev_dbg(&dev->dev, \"added config field at offset 0x%02x\\n\",\n\t\tOFFSET(cfg_entry));\n\tlist_add_tail(&cfg_entry->list, &dev_data->config_fields);\n\nout:\n\tif (err)\n\t\tkfree(cfg_entry);\n\n\treturn err;\n}\n\n \nint xen_pcibk_config_init_dev(struct pci_dev *dev)\n{\n\tint err = 0;\n\tstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\n\n\tdev_dbg(&dev->dev, \"initializing virtual configuration space\\n\");\n\n\tINIT_LIST_HEAD(&dev_data->config_fields);\n\n\terr = xen_pcibk_config_header_add_fields(dev);\n\tif (err)\n\t\tgoto out;\n\n\terr = xen_pcibk_config_capability_add_fields(dev);\n\tif (err)\n\t\tgoto out;\n\n\terr = xen_pcibk_config_quirks_init(dev);\n\nout:\n\treturn err;\n}\n\nint xen_pcibk_config_init(void)\n{\n\treturn xen_pcibk_config_capability_init();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}