{
  "module_name": "pci_stub.c",
  "hash_id": "728c98165a2908305d4edd77dce823779a4699006024fd3985deefb65f1eba8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-pciback/pci_stub.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#define dev_fmt pr_fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/rwsem.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/kref.h>\n#include <linux/pci.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <xen/events.h>\n#include <xen/pci.h>\n#include <xen/xen.h>\n#include <asm/xen/hypervisor.h>\n#include <xen/interface/physdev.h>\n#include \"pciback.h\"\n#include \"conf_space.h\"\n#include \"conf_space_quirks.h\"\n\n#define PCISTUB_DRIVER_NAME \"pciback\"\n\nstatic char *pci_devs_to_hide;\nwait_queue_head_t xen_pcibk_aer_wait_queue;\n \nstatic DECLARE_RWSEM(pcistub_sem);\nmodule_param_named(hide, pci_devs_to_hide, charp, 0444);\n\nstruct pcistub_device_id {\n\tstruct list_head slot_list;\n\tint domain;\n\tunsigned char bus;\n\tunsigned int devfn;\n};\nstatic LIST_HEAD(pcistub_device_ids);\nstatic DEFINE_SPINLOCK(device_ids_lock);\n\nstruct pcistub_device {\n\tstruct kref kref;\n\tstruct list_head dev_list;\n\tspinlock_t lock;\n\n\tstruct pci_dev *dev;\n\tstruct xen_pcibk_device *pdev; \n};\n\n \nstatic DEFINE_SPINLOCK(pcistub_devices_lock);\nstatic LIST_HEAD(pcistub_devices);\n\n \nstatic int initialize_devices;\nstatic LIST_HEAD(seized_devices);\n\nstatic struct pcistub_device *pcistub_device_alloc(struct pci_dev *dev)\n{\n\tstruct pcistub_device *psdev;\n\n\tdev_dbg(&dev->dev, \"pcistub_device_alloc\\n\");\n\n\tpsdev = kzalloc(sizeof(*psdev), GFP_KERNEL);\n\tif (!psdev)\n\t\treturn NULL;\n\n\tpsdev->dev = pci_dev_get(dev);\n\tif (!psdev->dev) {\n\t\tkfree(psdev);\n\t\treturn NULL;\n\t}\n\n\tkref_init(&psdev->kref);\n\tspin_lock_init(&psdev->lock);\n\n\treturn psdev;\n}\n\n \nstatic void pcistub_device_release(struct kref *kref)\n{\n\tstruct pcistub_device *psdev;\n\tstruct pci_dev *dev;\n\tstruct xen_pcibk_dev_data *dev_data;\n\n\tpsdev = container_of(kref, struct pcistub_device, kref);\n\tdev = psdev->dev;\n\tdev_data = pci_get_drvdata(dev);\n\n\tdev_dbg(&dev->dev, \"pcistub_device_release\\n\");\n\n\txen_unregister_device_domain_owner(dev);\n\n\t \n\t__pci_reset_function_locked(dev);\n\tif (dev_data &&\n\t    pci_load_and_free_saved_state(dev, &dev_data->pci_saved_state))\n\t\tdev_info(&dev->dev, \"Could not reload PCI state\\n\");\n\telse\n\t\tpci_restore_state(dev);\n\n\tif (dev->msix_cap) {\n\t\tstruct physdev_pci_device ppdev = {\n\t\t\t.seg = pci_domain_nr(dev->bus),\n\t\t\t.bus = dev->bus->number,\n\t\t\t.devfn = dev->devfn\n\t\t};\n\t\tint err = HYPERVISOR_physdev_op(PHYSDEVOP_release_msix,\n\t\t\t\t\t\t&ppdev);\n\n\t\tif (err && err != -ENOSYS)\n\t\t\tdev_warn(&dev->dev, \"MSI-X release failed (%d)\\n\",\n\t\t\t\t err);\n\t}\n\n\t \n\txen_pcibk_reset_device(dev);\n\n\tkfree(dev_data);\n\tpci_set_drvdata(dev, NULL);\n\n\t \n\txen_pcibk_config_free_dyn_fields(dev);\n\txen_pcibk_config_free_dev(dev);\n\n\tpci_clear_dev_assigned(dev);\n\tpci_dev_put(dev);\n\n\tkfree(psdev);\n}\n\nstatic inline void pcistub_device_get(struct pcistub_device *psdev)\n{\n\tkref_get(&psdev->kref);\n}\n\nstatic inline void pcistub_device_put(struct pcistub_device *psdev)\n{\n\tkref_put(&psdev->kref, pcistub_device_release);\n}\n\nstatic struct pcistub_device *pcistub_device_find_locked(int domain, int bus,\n\t\t\t\t\t\t\t int slot, int func)\n{\n\tstruct pcistub_device *psdev;\n\n\tlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\n\t\tif (psdev->dev != NULL\n\t\t    && domain == pci_domain_nr(psdev->dev->bus)\n\t\t    && bus == psdev->dev->bus->number\n\t\t    && slot == PCI_SLOT(psdev->dev->devfn)\n\t\t    && func == PCI_FUNC(psdev->dev->devfn)) {\n\t\t\treturn psdev;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct pcistub_device *pcistub_device_find(int domain, int bus,\n\t\t\t\t\t\t  int slot, int func)\n{\n\tstruct pcistub_device *psdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\n\tpsdev = pcistub_device_find_locked(domain, bus, slot, func);\n\tif (psdev)\n\t\tpcistub_device_get(psdev);\n\n\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\treturn psdev;\n}\n\nstatic struct pci_dev *pcistub_device_get_pci_dev(struct xen_pcibk_device *pdev,\n\t\t\t\t\t\t  struct pcistub_device *psdev)\n{\n\tstruct pci_dev *pci_dev = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&psdev->lock, flags);\n\tif (!psdev->pdev) {\n\t\tpsdev->pdev = pdev;\n\t\tpci_dev = psdev->dev;\n\t}\n\tspin_unlock_irqrestore(&psdev->lock, flags);\n\n\tif (pci_dev)\n\t\tpcistub_device_get(psdev);\n\n\treturn pci_dev;\n}\n\nstruct pci_dev *pcistub_get_pci_dev_by_slot(struct xen_pcibk_device *pdev,\n\t\t\t\t\t    int domain, int bus,\n\t\t\t\t\t    int slot, int func)\n{\n\tstruct pcistub_device *psdev;\n\tstruct pci_dev *found_dev = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\n\tpsdev = pcistub_device_find_locked(domain, bus, slot, func);\n\tif (psdev)\n\t\tfound_dev = pcistub_device_get_pci_dev(pdev, psdev);\n\n\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\treturn found_dev;\n}\n\nstruct pci_dev *pcistub_get_pci_dev(struct xen_pcibk_device *pdev,\n\t\t\t\t    struct pci_dev *dev)\n{\n\tstruct pcistub_device *psdev;\n\tstruct pci_dev *found_dev = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\n\tlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\n\t\tif (psdev->dev == dev) {\n\t\t\tfound_dev = pcistub_device_get_pci_dev(pdev, psdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\treturn found_dev;\n}\n\n \nvoid pcistub_put_pci_dev(struct pci_dev *dev)\n{\n\tstruct pcistub_device *psdev, *found_psdev = NULL;\n\tunsigned long flags;\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint ret;\n\n\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\n\tlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\n\t\tif (psdev->dev == dev) {\n\t\t\tfound_psdev = psdev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\tif (WARN_ON(!found_psdev))\n\t\treturn;\n\n\t \n\tdown_write(&pcistub_sem);\n\t \n\tdevice_lock_assert(&dev->dev);\n\t__pci_reset_function_locked(dev);\n\n\tdev_data = pci_get_drvdata(dev);\n\tret = pci_load_saved_state(dev, dev_data->pci_saved_state);\n\tif (!ret) {\n\t\t \n\t\tpci_restore_state(dev);\n\t} else\n\t\tdev_info(&dev->dev, \"Could not reload PCI state\\n\");\n\t \n\txen_pcibk_reset_device(dev);\n\n\t \n\txen_pcibk_config_reset_dev(dev);\n\txen_pcibk_config_free_dyn_fields(dev);\n\n\tdev_data->allow_interrupt_control = 0;\n\n\txen_unregister_device_domain_owner(dev);\n\n\tspin_lock_irqsave(&found_psdev->lock, flags);\n\tfound_psdev->pdev = NULL;\n\tspin_unlock_irqrestore(&found_psdev->lock, flags);\n\n\tpcistub_device_put(found_psdev);\n\tup_write(&pcistub_sem);\n}\n\nstatic int pcistub_match_one(struct pci_dev *dev,\n\t\t\t     struct pcistub_device_id *pdev_id)\n{\n\t \n\tfor (; dev != NULL; dev = dev->bus->self) {\n\t\tif (pci_domain_nr(dev->bus) == pdev_id->domain\n\t\t    && dev->bus->number == pdev_id->bus\n\t\t    && dev->devfn == pdev_id->devfn)\n\t\t\treturn 1;\n\n\t\t \n\t\tif (dev == dev->bus->self)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int pcistub_match(struct pci_dev *dev)\n{\n\tstruct pcistub_device_id *pdev_id;\n\tunsigned long flags;\n\tint found = 0;\n\n\tspin_lock_irqsave(&device_ids_lock, flags);\n\tlist_for_each_entry(pdev_id, &pcistub_device_ids, slot_list) {\n\t\tif (pcistub_match_one(dev, pdev_id)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&device_ids_lock, flags);\n\n\treturn found;\n}\n\nstatic int pcistub_init_device(struct pci_dev *dev)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint err = 0;\n\n\tdev_dbg(&dev->dev, \"initializing...\\n\");\n\n\t \n\tdev_data = kzalloc(sizeof(*dev_data) +  strlen(DRV_NAME \"[]\")\n\t\t\t\t+ strlen(pci_name(dev)) + 1, GFP_KERNEL);\n\tif (!dev_data) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpci_set_drvdata(dev, dev_data);\n\n\t \n\tsprintf(dev_data->irq_name, DRV_NAME \"[%s]\", pci_name(dev));\n\n\tdev_dbg(&dev->dev, \"initializing config\\n\");\n\n\tinit_waitqueue_head(&xen_pcibk_aer_wait_queue);\n\terr = xen_pcibk_config_init_dev(dev);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tdev_dbg(&dev->dev, \"enabling device\\n\");\n\terr = pci_enable_device(dev);\n\tif (err)\n\t\tgoto config_release;\n\n\tif (dev->msix_cap) {\n\t\tstruct physdev_pci_device ppdev = {\n\t\t\t.seg = pci_domain_nr(dev->bus),\n\t\t\t.bus = dev->bus->number,\n\t\t\t.devfn = dev->devfn\n\t\t};\n\n\t\terr = HYPERVISOR_physdev_op(PHYSDEVOP_prepare_msix, &ppdev);\n\t\tif (err && err != -ENOSYS)\n\t\t\tdev_err(&dev->dev, \"MSI-X preparation failed (%d)\\n\",\n\t\t\t\terr);\n\t}\n\n\t \n\tdev_dbg(&dev->dev, \"save state of device\\n\");\n\tpci_save_state(dev);\n\tdev_data->pci_saved_state = pci_store_saved_state(dev);\n\tif (!dev_data->pci_saved_state)\n\t\tdev_err(&dev->dev, \"Could not store PCI conf saved state!\\n\");\n\telse {\n\t\tdev_dbg(&dev->dev, \"resetting (FLR, D3, etc) the device\\n\");\n\t\t__pci_reset_function_locked(dev);\n\t\tpci_restore_state(dev);\n\t}\n\t \n\tdev_dbg(&dev->dev, \"reset device\\n\");\n\txen_pcibk_reset_device(dev);\n\n\tpci_set_dev_assigned(dev);\n\treturn 0;\n\nconfig_release:\n\txen_pcibk_config_free_dev(dev);\n\nout:\n\tpci_set_drvdata(dev, NULL);\n\tkfree(dev_data);\n\treturn err;\n}\n\n \nstatic int __init pcistub_init_devices_late(void)\n{\n\tstruct pcistub_device *psdev;\n\tunsigned long flags;\n\tint err = 0;\n\n\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\n\twhile (!list_empty(&seized_devices)) {\n\t\tpsdev = container_of(seized_devices.next,\n\t\t\t\t     struct pcistub_device, dev_list);\n\t\tlist_del(&psdev->dev_list);\n\n\t\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\n\t\terr = pcistub_init_device(psdev->dev);\n\t\tif (err) {\n\t\t\tdev_err(&psdev->dev->dev,\n\t\t\t\t\"error %d initializing device\\n\", err);\n\t\t\tkfree(psdev);\n\t\t\tpsdev = NULL;\n\t\t}\n\n\t\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\n\t\tif (psdev)\n\t\t\tlist_add_tail(&psdev->dev_list, &pcistub_devices);\n\t}\n\n\tinitialize_devices = 1;\n\n\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\n\treturn 0;\n}\n\nstatic void pcistub_device_id_add_list(struct pcistub_device_id *new,\n\t\t\t\t       int domain, int bus, unsigned int devfn)\n{\n\tstruct pcistub_device_id *pci_dev_id;\n\tunsigned long flags;\n\tint found = 0;\n\n\tspin_lock_irqsave(&device_ids_lock, flags);\n\n\tlist_for_each_entry(pci_dev_id, &pcistub_device_ids, slot_list) {\n\t\tif (pci_dev_id->domain == domain && pci_dev_id->bus == bus &&\n\t\t    pci_dev_id->devfn == devfn) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tnew->domain = domain;\n\t\tnew->bus = bus;\n\t\tnew->devfn = devfn;\n\t\tlist_add_tail(&new->slot_list, &pcistub_device_ids);\n\t}\n\n\tspin_unlock_irqrestore(&device_ids_lock, flags);\n\n\tif (found)\n\t\tkfree(new);\n}\n\nstatic int pcistub_seize(struct pci_dev *dev,\n\t\t\t struct pcistub_device_id *pci_dev_id)\n{\n\tstruct pcistub_device *psdev;\n\tunsigned long flags;\n\tint err = 0;\n\n\tpsdev = pcistub_device_alloc(dev);\n\tif (!psdev) {\n\t\tkfree(pci_dev_id);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\n\tif (initialize_devices) {\n\t\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\n\t\t \n\t\terr = pcistub_init_device(psdev->dev);\n\n\t\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\n\t\tif (!err)\n\t\t\tlist_add(&psdev->dev_list, &pcistub_devices);\n\t} else {\n\t\tdev_dbg(&dev->dev, \"deferring initialization\\n\");\n\t\tlist_add(&psdev->dev_list, &seized_devices);\n\t}\n\n\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\n\tif (err) {\n\t\tkfree(pci_dev_id);\n\t\tpcistub_device_put(psdev);\n\t} else if (pci_dev_id)\n\t\tpcistub_device_id_add_list(pci_dev_id, pci_domain_nr(dev->bus),\n\t\t\t\t\t   dev->bus->number, dev->devfn);\n\n\treturn err;\n}\n\n \nstatic int pcistub_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tint err = 0, match;\n\tstruct pcistub_device_id *pci_dev_id = NULL;\n\n\tdev_dbg(&dev->dev, \"probing...\\n\");\n\n\tmatch = pcistub_match(dev);\n\n\tif ((dev->driver_override &&\n\t     !strcmp(dev->driver_override, PCISTUB_DRIVER_NAME)) ||\n\t    match) {\n\n\t\tif (dev->hdr_type != PCI_HEADER_TYPE_NORMAL\n\t\t    && dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tdev_err(&dev->dev, \"can't export pci devices that \"\n\t\t\t\t\"don't have a normal (0) or bridge (1) \"\n\t\t\t\t\"header type!\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!match) {\n\t\t\tpci_dev_id = kmalloc(sizeof(*pci_dev_id), GFP_KERNEL);\n\t\t\tif (!pci_dev_id) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tdev_info(&dev->dev, \"seizing device\\n\");\n\t\terr = pcistub_seize(dev, pci_dev_id);\n\t} else\n\t\t \n\t\terr = -ENODEV;\n\nout:\n\treturn err;\n}\n\n \nstatic void pcistub_remove(struct pci_dev *dev)\n{\n\tstruct pcistub_device *psdev, *found_psdev = NULL;\n\tunsigned long flags;\n\n\tdev_dbg(&dev->dev, \"removing\\n\");\n\n\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\n\txen_pcibk_config_quirk_release(dev);\n\n\tlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\n\t\tif (psdev->dev == dev) {\n\t\t\tfound_psdev = psdev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\n\tif (found_psdev) {\n\t\tdev_dbg(&dev->dev, \"found device to remove %s\\n\",\n\t\t\tfound_psdev->pdev ? \"- in-use\" : \"\");\n\n\t\tif (found_psdev->pdev) {\n\t\t\tint domid = xen_find_device_domain_owner(dev);\n\n\t\t\tdev_warn(&dev->dev, \"****** removing device %s while still in-use by domain %d! ******\\n\",\n\t\t\t       pci_name(found_psdev->dev), domid);\n\t\t\tdev_warn(&dev->dev, \"****** driver domain may still access this device's i/o resources!\\n\");\n\t\t\tdev_warn(&dev->dev, \"****** shutdown driver domain before binding device\\n\");\n\t\t\tdev_warn(&dev->dev, \"****** to other drivers or domains\\n\");\n\n\t\t\t \n\t\t\txen_pcibk_release_pci_dev(found_psdev->pdev,\n\t\t\t\t\t\tfound_psdev->dev,\n\t\t\t\t\t\tfalse  );\n\t\t}\n\n\t\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\t\tlist_del(&found_psdev->dev_list);\n\t\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\n\t\t \n\t\tpcistub_device_put(found_psdev);\n\t}\n}\n\nstatic const struct pci_device_id pcistub_ids[] = {\n\t{\n\t .vendor = PCI_ANY_ID,\n\t .device = PCI_ANY_ID,\n\t .subvendor = PCI_ANY_ID,\n\t .subdevice = PCI_ANY_ID,\n\t },\n\t{0,},\n};\n\n#define PCI_NODENAME_MAX 40\nstatic void kill_domain_by_device(struct pcistub_device *psdev)\n{\n\tstruct xenbus_transaction xbt;\n\tint err;\n\tchar nodename[PCI_NODENAME_MAX];\n\n\tBUG_ON(!psdev);\n\tsnprintf(nodename, PCI_NODENAME_MAX, \"/local/domain/0/backend/pci/%d/0\",\n\t\tpsdev->pdev->xdev->otherend_id);\n\nagain:\n\terr = xenbus_transaction_start(&xbt);\n\tif (err) {\n\t\tdev_err(&psdev->dev->dev,\n\t\t\t\"error %d when start xenbus transaction\\n\", err);\n\t\treturn;\n\t}\n\t \n\txenbus_printf(xbt, nodename, \"aerState\" , \"aerfail\");\n\terr = xenbus_transaction_end(xbt, 0);\n\tif (err) {\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\t\tdev_err(&psdev->dev->dev,\n\t\t\t\"error %d when end xenbus transaction\\n\", err);\n\t\treturn;\n\t}\n}\n\n \nstatic pci_ers_result_t common_process(struct pcistub_device *psdev,\n\t\t\t\t       pci_channel_state_t state, int aer_cmd,\n\t\t\t\t       pci_ers_result_t result)\n{\n\tpci_ers_result_t res = result;\n\tstruct xen_pcie_aer_op *aer_op;\n\tstruct xen_pcibk_device *pdev = psdev->pdev;\n\tstruct xen_pci_sharedinfo *sh_info = pdev->sh_info;\n\tint ret;\n\n\t \n\taer_op = &(sh_info->aer_op);\n\taer_op->cmd = aer_cmd ;\n\t \n\taer_op->err = state;\n\t \n\tret = xen_pcibk_get_pcifront_dev(psdev->dev, psdev->pdev,\n\t\t&aer_op->domain, &aer_op->bus, &aer_op->devfn);\n\tif (!ret) {\n\t\tdev_err(&psdev->dev->dev, \"failed to get pcifront device\\n\");\n\t\treturn PCI_ERS_RESULT_NONE;\n\t}\n\twmb();\n\n\tdev_dbg(&psdev->dev->dev, \"aer_op %x dom %x bus %x devfn %x\\n\",\n\t\t\taer_cmd, aer_op->domain, aer_op->bus, aer_op->devfn);\n\t \n\tset_bit(_PCIB_op_pending, (unsigned long *)&pdev->flags);\n\n\t \n\tset_bit(_XEN_PCIB_active,\n\t\t(unsigned long *)&sh_info->flags);\n\twmb();\n\tnotify_remote_via_irq(pdev->evtchn_irq);\n\n\t \n\txen_pcibk_lateeoi(pdev, 0);\n\n\tret = wait_event_timeout(xen_pcibk_aer_wait_queue,\n\t\t\t\t !(test_bit(_XEN_PCIB_active, (unsigned long *)\n\t\t\t\t &sh_info->flags)), 300*HZ);\n\n\t \n\tif (!test_bit(_PDEVF_op_active, &pdev->flags))\n\t\txen_pcibk_lateeoi(pdev, 0);\n\n\tif (!ret) {\n\t\tif (test_bit(_XEN_PCIB_active,\n\t\t\t(unsigned long *)&sh_info->flags)) {\n\t\t\tdev_err(&psdev->dev->dev,\n\t\t\t\t\"pcifront aer process not responding!\\n\");\n\t\t\tclear_bit(_XEN_PCIB_active,\n\t\t\t  (unsigned long *)&sh_info->flags);\n\t\t\taer_op->err = PCI_ERS_RESULT_NONE;\n\t\t\treturn res;\n\t\t}\n\t}\n\tclear_bit(_PCIB_op_pending, (unsigned long *)&pdev->flags);\n\n\tres = (pci_ers_result_t)aer_op->err;\n\treturn res;\n}\n\n \nstatic pci_ers_result_t xen_pcibk_slot_reset(struct pci_dev *dev)\n{\n\tstruct pcistub_device *psdev;\n\tpci_ers_result_t result;\n\n\tresult = PCI_ERS_RESULT_RECOVERED;\n\tdev_dbg(&dev->dev, \"xen_pcibk_slot_reset(bus:%x,devfn:%x)\\n\",\n\t\tdev->bus->number, dev->devfn);\n\n\tdown_write(&pcistub_sem);\n\tpsdev = pcistub_device_find(pci_domain_nr(dev->bus),\n\t\t\t\tdev->bus->number,\n\t\t\t\tPCI_SLOT(dev->devfn),\n\t\t\t\tPCI_FUNC(dev->devfn));\n\n\tif (!psdev || !psdev->pdev) {\n\t\tdev_err(&dev->dev, \"device is not found/assigned\\n\");\n\t\tgoto end;\n\t}\n\n\tif (!psdev->pdev->sh_info) {\n\t\tdev_err(&dev->dev, \"device is not connected or owned\"\n\t\t\t\" by HVM, kill it\\n\");\n\t\tkill_domain_by_device(psdev);\n\t\tgoto end;\n\t}\n\n\tif (!test_bit(_XEN_PCIB_AERHANDLER,\n\t\t(unsigned long *)&psdev->pdev->sh_info->flags)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"guest with no AER driver should have been killed\\n\");\n\t\tgoto end;\n\t}\n\tresult = common_process(psdev, pci_channel_io_normal, XEN_PCI_OP_aer_slotreset, result);\n\n\tif (result == PCI_ERS_RESULT_NONE ||\n\t\tresult == PCI_ERS_RESULT_DISCONNECT) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"No AER slot_reset service or disconnected!\\n\");\n\t\tkill_domain_by_device(psdev);\n\t}\nend:\n\tif (psdev)\n\t\tpcistub_device_put(psdev);\n\tup_write(&pcistub_sem);\n\treturn result;\n\n}\n\n\n \n\nstatic pci_ers_result_t xen_pcibk_mmio_enabled(struct pci_dev *dev)\n{\n\tstruct pcistub_device *psdev;\n\tpci_ers_result_t result;\n\n\tresult = PCI_ERS_RESULT_RECOVERED;\n\tdev_dbg(&dev->dev, \"xen_pcibk_mmio_enabled(bus:%x,devfn:%x)\\n\",\n\t\tdev->bus->number, dev->devfn);\n\n\tdown_write(&pcistub_sem);\n\tpsdev = pcistub_device_find(pci_domain_nr(dev->bus),\n\t\t\t\tdev->bus->number,\n\t\t\t\tPCI_SLOT(dev->devfn),\n\t\t\t\tPCI_FUNC(dev->devfn));\n\n\tif (!psdev || !psdev->pdev) {\n\t\tdev_err(&dev->dev, \"device is not found/assigned\\n\");\n\t\tgoto end;\n\t}\n\n\tif (!psdev->pdev->sh_info) {\n\t\tdev_err(&dev->dev, \"device is not connected or owned\"\n\t\t\t\" by HVM, kill it\\n\");\n\t\tkill_domain_by_device(psdev);\n\t\tgoto end;\n\t}\n\n\tif (!test_bit(_XEN_PCIB_AERHANDLER,\n\t\t(unsigned long *)&psdev->pdev->sh_info->flags)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"guest with no AER driver should have been killed\\n\");\n\t\tgoto end;\n\t}\n\tresult = common_process(psdev, pci_channel_io_normal, XEN_PCI_OP_aer_mmio, result);\n\n\tif (result == PCI_ERS_RESULT_NONE ||\n\t\tresult == PCI_ERS_RESULT_DISCONNECT) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"No AER mmio_enabled service or disconnected!\\n\");\n\t\tkill_domain_by_device(psdev);\n\t}\nend:\n\tif (psdev)\n\t\tpcistub_device_put(psdev);\n\tup_write(&pcistub_sem);\n\treturn result;\n}\n\n \n\nstatic pci_ers_result_t xen_pcibk_error_detected(struct pci_dev *dev,\n\tpci_channel_state_t error)\n{\n\tstruct pcistub_device *psdev;\n\tpci_ers_result_t result;\n\n\tresult = PCI_ERS_RESULT_CAN_RECOVER;\n\tdev_dbg(&dev->dev, \"xen_pcibk_error_detected(bus:%x,devfn:%x)\\n\",\n\t\tdev->bus->number, dev->devfn);\n\n\tdown_write(&pcistub_sem);\n\tpsdev = pcistub_device_find(pci_domain_nr(dev->bus),\n\t\t\t\tdev->bus->number,\n\t\t\t\tPCI_SLOT(dev->devfn),\n\t\t\t\tPCI_FUNC(dev->devfn));\n\n\tif (!psdev || !psdev->pdev) {\n\t\tdev_err(&dev->dev, \"device is not found/assigned\\n\");\n\t\tgoto end;\n\t}\n\n\tif (!psdev->pdev->sh_info) {\n\t\tdev_err(&dev->dev, \"device is not connected or owned\"\n\t\t\t\" by HVM, kill it\\n\");\n\t\tkill_domain_by_device(psdev);\n\t\tgoto end;\n\t}\n\n\t \n\tif (!test_bit(_XEN_PCIB_AERHANDLER,\n\t\t(unsigned long *)&psdev->pdev->sh_info->flags)) {\n\t\tdev_dbg(&dev->dev, \"guest may have no aer driver, kill it\\n\");\n\t\tkill_domain_by_device(psdev);\n\t\tgoto end;\n\t}\n\tresult = common_process(psdev, error, XEN_PCI_OP_aer_detected, result);\n\n\tif (result == PCI_ERS_RESULT_NONE ||\n\t\tresult == PCI_ERS_RESULT_DISCONNECT) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"No AER error_detected service or disconnected!\\n\");\n\t\tkill_domain_by_device(psdev);\n\t}\nend:\n\tif (psdev)\n\t\tpcistub_device_put(psdev);\n\tup_write(&pcistub_sem);\n\treturn result;\n}\n\n \n\nstatic void xen_pcibk_error_resume(struct pci_dev *dev)\n{\n\tstruct pcistub_device *psdev;\n\n\tdev_dbg(&dev->dev, \"xen_pcibk_error_resume(bus:%x,devfn:%x)\\n\",\n\t\tdev->bus->number, dev->devfn);\n\n\tdown_write(&pcistub_sem);\n\tpsdev = pcistub_device_find(pci_domain_nr(dev->bus),\n\t\t\t\tdev->bus->number,\n\t\t\t\tPCI_SLOT(dev->devfn),\n\t\t\t\tPCI_FUNC(dev->devfn));\n\n\tif (!psdev || !psdev->pdev) {\n\t\tdev_err(&dev->dev, \"device is not found/assigned\\n\");\n\t\tgoto end;\n\t}\n\n\tif (!psdev->pdev->sh_info) {\n\t\tdev_err(&dev->dev, \"device is not connected or owned\"\n\t\t\t\" by HVM, kill it\\n\");\n\t\tkill_domain_by_device(psdev);\n\t\tgoto end;\n\t}\n\n\tif (!test_bit(_XEN_PCIB_AERHANDLER,\n\t\t(unsigned long *)&psdev->pdev->sh_info->flags)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"guest with no AER driver should have been killed\\n\");\n\t\tkill_domain_by_device(psdev);\n\t\tgoto end;\n\t}\n\tcommon_process(psdev, pci_channel_io_normal, XEN_PCI_OP_aer_resume,\n\t\t       PCI_ERS_RESULT_RECOVERED);\nend:\n\tif (psdev)\n\t\tpcistub_device_put(psdev);\n\tup_write(&pcistub_sem);\n\treturn;\n}\n\n \nstatic const struct pci_error_handlers xen_pcibk_error_handler = {\n\t.error_detected = xen_pcibk_error_detected,\n\t.mmio_enabled = xen_pcibk_mmio_enabled,\n\t.slot_reset = xen_pcibk_slot_reset,\n\t.resume = xen_pcibk_error_resume,\n};\n\n \n\nstatic struct pci_driver xen_pcibk_pci_driver = {\n\t \n\t.name = PCISTUB_DRIVER_NAME,\n\t.id_table = pcistub_ids,\n\t.probe = pcistub_probe,\n\t.remove = pcistub_remove,\n\t.err_handler = &xen_pcibk_error_handler,\n};\n\nstatic inline int str_to_slot(const char *buf, int *domain, int *bus,\n\t\t\t      int *slot, int *func)\n{\n\tint parsed = 0;\n\n\tswitch (sscanf(buf, \" %x:%x:%x.%x %n\", domain, bus, slot, func,\n\t\t       &parsed)) {\n\tcase 3:\n\t\t*func = -1;\n\t\tsscanf(buf, \" %x:%x:%x.* %n\", domain, bus, slot, &parsed);\n\t\tbreak;\n\tcase 2:\n\t\t*slot = *func = -1;\n\t\tsscanf(buf, \" %x:%x:*.* %n\", domain, bus, &parsed);\n\t\tbreak;\n\t}\n\tif (parsed && !buf[parsed])\n\t\treturn 0;\n\n\t \n\t*domain = 0;\n\tswitch (sscanf(buf, \" %x:%x.%x %n\", bus, slot, func, &parsed)) {\n\tcase 2:\n\t\t*func = -1;\n\t\tsscanf(buf, \" %x:%x.* %n\", bus, slot, &parsed);\n\t\tbreak;\n\tcase 1:\n\t\t*slot = *func = -1;\n\t\tsscanf(buf, \" %x:*.* %n\", bus, &parsed);\n\t\tbreak;\n\t}\n\tif (parsed && !buf[parsed])\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic inline int str_to_quirk(const char *buf, int *domain, int *bus, int\n\t\t\t       *slot, int *func, int *reg, int *size, int *mask)\n{\n\tint parsed = 0;\n\n\tsscanf(buf, \" %x:%x:%x.%x-%x:%x:%x %n\", domain, bus, slot, func,\n\t       reg, size, mask, &parsed);\n\tif (parsed && !buf[parsed])\n\t\treturn 0;\n\n\t \n\t*domain = 0;\n\tsscanf(buf, \" %x:%x.%x-%x:%x:%x %n\", bus, slot, func, reg, size,\n\t       mask, &parsed);\n\tif (parsed && !buf[parsed])\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int pcistub_device_id_add(int domain, int bus, int slot, int func)\n{\n\tstruct pcistub_device_id *pci_dev_id;\n\tint rc = 0, devfn = PCI_DEVFN(slot, func);\n\n\tif (slot < 0) {\n\t\tfor (slot = 0; !rc && slot < 32; ++slot)\n\t\t\trc = pcistub_device_id_add(domain, bus, slot, func);\n\t\treturn rc;\n\t}\n\n\tif (func < 0) {\n\t\tfor (func = 0; !rc && func < 8; ++func)\n\t\t\trc = pcistub_device_id_add(domain, bus, slot, func);\n\t\treturn rc;\n\t}\n\n\tif ((\n#if !defined(MODULE)   \\\n    || !defined(CONFIG_PCI_DOMAINS)\n\t     !pci_domains_supported ? domain :\n#endif\n\t     domain < 0 || domain > 0xffff)\n\t    || bus < 0 || bus > 0xff\n\t    || PCI_SLOT(devfn) != slot\n\t    || PCI_FUNC(devfn) != func)\n\t\treturn -EINVAL;\n\n\tpci_dev_id = kmalloc(sizeof(*pci_dev_id), GFP_KERNEL);\n\tif (!pci_dev_id)\n\t\treturn -ENOMEM;\n\n\tpr_debug(\"wants to seize %04x:%02x:%02x.%d\\n\",\n\t\t domain, bus, slot, func);\n\n\tpcistub_device_id_add_list(pci_dev_id, domain, bus, devfn);\n\n\treturn 0;\n}\n\nstatic int pcistub_device_id_remove(int domain, int bus, int slot, int func)\n{\n\tstruct pcistub_device_id *pci_dev_id, *t;\n\tint err = -ENOENT;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&device_ids_lock, flags);\n\tlist_for_each_entry_safe(pci_dev_id, t, &pcistub_device_ids,\n\t\t\t\t slot_list) {\n\t\tif (pci_dev_id->domain == domain && pci_dev_id->bus == bus\n\t\t    && (slot < 0 || PCI_SLOT(pci_dev_id->devfn) == slot)\n\t\t    && (func < 0 || PCI_FUNC(pci_dev_id->devfn) == func)) {\n\t\t\t \n\t\t\tlist_del(&pci_dev_id->slot_list);\n\t\t\tkfree(pci_dev_id);\n\n\t\t\terr = 0;\n\n\t\t\tpr_debug(\"removed %04x:%02x:%02x.%d from seize list\\n\",\n\t\t\t\t domain, bus, slot, func);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&device_ids_lock, flags);\n\n\treturn err;\n}\n\nstatic int pcistub_reg_add(int domain, int bus, int slot, int func,\n\t\t\t   unsigned int reg, unsigned int size,\n\t\t\t   unsigned int mask)\n{\n\tint err = 0;\n\tstruct pcistub_device *psdev;\n\tstruct pci_dev *dev;\n\tstruct config_field *field;\n\n\tif (reg > 0xfff || (size < 4 && (mask >> (size * 8))))\n\t\treturn -EINVAL;\n\n\tpsdev = pcistub_device_find(domain, bus, slot, func);\n\tif (!psdev) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tdev = psdev->dev;\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfield->offset = reg;\n\tfield->size = size;\n\tfield->mask = mask;\n\tfield->init = NULL;\n\tfield->reset = NULL;\n\tfield->release = NULL;\n\tfield->clean = xen_pcibk_config_field_free;\n\n\terr = xen_pcibk_config_quirks_add_field(dev, field);\n\tif (err)\n\t\tkfree(field);\nout:\n\tif (psdev)\n\t\tpcistub_device_put(psdev);\n\treturn err;\n}\n\nstatic ssize_t new_slot_store(struct device_driver *drv, const char *buf,\n\t\t\t      size_t count)\n{\n\tint domain, bus, slot, func;\n\tint err;\n\n\terr = str_to_slot(buf, &domain, &bus, &slot, &func);\n\tif (err)\n\t\tgoto out;\n\n\terr = pcistub_device_id_add(domain, bus, slot, func);\n\nout:\n\tif (!err)\n\t\terr = count;\n\treturn err;\n}\nstatic DRIVER_ATTR_WO(new_slot);\n\nstatic ssize_t remove_slot_store(struct device_driver *drv, const char *buf,\n\t\t\t\t size_t count)\n{\n\tint domain, bus, slot, func;\n\tint err;\n\n\terr = str_to_slot(buf, &domain, &bus, &slot, &func);\n\tif (err)\n\t\tgoto out;\n\n\terr = pcistub_device_id_remove(domain, bus, slot, func);\n\nout:\n\tif (!err)\n\t\terr = count;\n\treturn err;\n}\nstatic DRIVER_ATTR_WO(remove_slot);\n\nstatic ssize_t slots_show(struct device_driver *drv, char *buf)\n{\n\tstruct pcistub_device_id *pci_dev_id;\n\tsize_t count = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&device_ids_lock, flags);\n\tlist_for_each_entry(pci_dev_id, &pcistub_device_ids, slot_list) {\n\t\tif (count >= PAGE_SIZE)\n\t\t\tbreak;\n\n\t\tcount += scnprintf(buf + count, PAGE_SIZE - count,\n\t\t\t\t   \"%04x:%02x:%02x.%d\\n\",\n\t\t\t\t   pci_dev_id->domain, pci_dev_id->bus,\n\t\t\t\t   PCI_SLOT(pci_dev_id->devfn),\n\t\t\t\t   PCI_FUNC(pci_dev_id->devfn));\n\t}\n\tspin_unlock_irqrestore(&device_ids_lock, flags);\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RO(slots);\n\nstatic ssize_t irq_handlers_show(struct device_driver *drv, char *buf)\n{\n\tstruct pcistub_device *psdev;\n\tstruct xen_pcibk_dev_data *dev_data;\n\tsize_t count = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\tlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\n\t\tif (count >= PAGE_SIZE)\n\t\t\tbreak;\n\t\tif (!psdev->dev)\n\t\t\tcontinue;\n\t\tdev_data = pci_get_drvdata(psdev->dev);\n\t\tif (!dev_data)\n\t\t\tcontinue;\n\t\tcount +=\n\t\t    scnprintf(buf + count, PAGE_SIZE - count,\n\t\t\t      \"%s:%s:%sing:%ld\\n\",\n\t\t\t      pci_name(psdev->dev),\n\t\t\t      dev_data->isr_on ? \"on\" : \"off\",\n\t\t\t      dev_data->ack_intr ? \"ack\" : \"not ack\",\n\t\t\t      dev_data->handled);\n\t}\n\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\treturn count;\n}\nstatic DRIVER_ATTR_RO(irq_handlers);\n\nstatic ssize_t irq_handler_state_store(struct device_driver *drv,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct pcistub_device *psdev;\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint domain, bus, slot, func;\n\tint err;\n\n\terr = str_to_slot(buf, &domain, &bus, &slot, &func);\n\tif (err)\n\t\treturn err;\n\n\tpsdev = pcistub_device_find(domain, bus, slot, func);\n\tif (!psdev) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tdev_data = pci_get_drvdata(psdev->dev);\n\tif (!dev_data) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tdev_dbg(&psdev->dev->dev, \"%s fake irq handler: %d->%d\\n\",\n\t\tdev_data->irq_name, dev_data->isr_on,\n\t\t!dev_data->isr_on);\n\n\tdev_data->isr_on = !(dev_data->isr_on);\n\tif (dev_data->isr_on)\n\t\tdev_data->ack_intr = 1;\nout:\n\tif (psdev)\n\t\tpcistub_device_put(psdev);\n\tif (!err)\n\t\terr = count;\n\treturn err;\n}\nstatic DRIVER_ATTR_WO(irq_handler_state);\n\nstatic ssize_t quirks_store(struct device_driver *drv, const char *buf,\n\t\t\t    size_t count)\n{\n\tint domain, bus, slot, func, reg, size, mask;\n\tint err;\n\n\terr = str_to_quirk(buf, &domain, &bus, &slot, &func, &reg, &size,\n\t\t\t   &mask);\n\tif (err)\n\t\tgoto out;\n\n\terr = pcistub_reg_add(domain, bus, slot, func, reg, size, mask);\n\nout:\n\tif (!err)\n\t\terr = count;\n\treturn err;\n}\n\nstatic ssize_t quirks_show(struct device_driver *drv, char *buf)\n{\n\tint count = 0;\n\tunsigned long flags;\n\tstruct xen_pcibk_config_quirk *quirk;\n\tstruct xen_pcibk_dev_data *dev_data;\n\tconst struct config_field *field;\n\tconst struct config_field_entry *cfg_entry;\n\n\tspin_lock_irqsave(&device_ids_lock, flags);\n\tlist_for_each_entry(quirk, &xen_pcibk_quirks, quirks_list) {\n\t\tif (count >= PAGE_SIZE)\n\t\t\tgoto out;\n\n\t\tcount += scnprintf(buf + count, PAGE_SIZE - count,\n\t\t\t\t   \"%02x:%02x.%01x\\n\\t%04x:%04x:%04x:%04x\\n\",\n\t\t\t\t   quirk->pdev->bus->number,\n\t\t\t\t   PCI_SLOT(quirk->pdev->devfn),\n\t\t\t\t   PCI_FUNC(quirk->pdev->devfn),\n\t\t\t\t   quirk->devid.vendor, quirk->devid.device,\n\t\t\t\t   quirk->devid.subvendor,\n\t\t\t\t   quirk->devid.subdevice);\n\n\t\tdev_data = pci_get_drvdata(quirk->pdev);\n\n\t\tlist_for_each_entry(cfg_entry, &dev_data->config_fields, list) {\n\t\t\tfield = cfg_entry->field;\n\t\t\tif (count >= PAGE_SIZE)\n\t\t\t\tgoto out;\n\n\t\t\tcount += scnprintf(buf + count, PAGE_SIZE - count,\n\t\t\t\t\t   \"\\t\\t%08x:%01x:%08x\\n\",\n\t\t\t\t\t   cfg_entry->base_offset +\n\t\t\t\t\t   field->offset, field->size,\n\t\t\t\t\t   field->mask);\n\t\t}\n\t}\n\nout:\n\tspin_unlock_irqrestore(&device_ids_lock, flags);\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(quirks);\n\nstatic ssize_t permissive_store(struct device_driver *drv, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tint domain, bus, slot, func;\n\tint err;\n\tstruct pcistub_device *psdev;\n\tstruct xen_pcibk_dev_data *dev_data;\n\n\terr = str_to_slot(buf, &domain, &bus, &slot, &func);\n\tif (err)\n\t\tgoto out;\n\n\tpsdev = pcistub_device_find(domain, bus, slot, func);\n\tif (!psdev) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdev_data = pci_get_drvdata(psdev->dev);\n\t \n\tif (!dev_data) {\n\t\terr = -ENXIO;\n\t\tgoto release;\n\t}\n\tif (!dev_data->permissive) {\n\t\tdev_data->permissive = 1;\n\t\t \n\t\tdev_warn(&psdev->dev->dev, \"enabling permissive mode \"\n\t\t\t \"configuration space accesses!\\n\");\n\t\tdev_warn(&psdev->dev->dev,\n\t\t\t \"permissive mode is potentially unsafe!\\n\");\n\t}\nrelease:\n\tpcistub_device_put(psdev);\nout:\n\tif (!err)\n\t\terr = count;\n\treturn err;\n}\n\nstatic ssize_t permissive_show(struct device_driver *drv, char *buf)\n{\n\tstruct pcistub_device *psdev;\n\tstruct xen_pcibk_dev_data *dev_data;\n\tsize_t count = 0;\n\tunsigned long flags;\n\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\tlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\n\t\tif (count >= PAGE_SIZE)\n\t\t\tbreak;\n\t\tif (!psdev->dev)\n\t\t\tcontinue;\n\t\tdev_data = pci_get_drvdata(psdev->dev);\n\t\tif (!dev_data || !dev_data->permissive)\n\t\t\tcontinue;\n\t\tcount +=\n\t\t    scnprintf(buf + count, PAGE_SIZE - count, \"%s\\n\",\n\t\t\t      pci_name(psdev->dev));\n\t}\n\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(permissive);\n\nstatic ssize_t allow_interrupt_control_store(struct device_driver *drv,\n\t\t\t\t\t     const char *buf, size_t count)\n{\n\tint domain, bus, slot, func;\n\tint err;\n\tstruct pcistub_device *psdev;\n\tstruct xen_pcibk_dev_data *dev_data;\n\n\terr = str_to_slot(buf, &domain, &bus, &slot, &func);\n\tif (err)\n\t\tgoto out;\n\n\tpsdev = pcistub_device_find(domain, bus, slot, func);\n\tif (!psdev) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdev_data = pci_get_drvdata(psdev->dev);\n\t \n\tif (!dev_data) {\n\t\terr = -ENXIO;\n\t\tgoto release;\n\t}\n\tdev_data->allow_interrupt_control = 1;\nrelease:\n\tpcistub_device_put(psdev);\nout:\n\tif (!err)\n\t\terr = count;\n\treturn err;\n}\n\nstatic ssize_t allow_interrupt_control_show(struct device_driver *drv,\n\t\t\t\t\t    char *buf)\n{\n\tstruct pcistub_device *psdev;\n\tstruct xen_pcibk_dev_data *dev_data;\n\tsize_t count = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\tlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\n\t\tif (count >= PAGE_SIZE)\n\t\t\tbreak;\n\t\tif (!psdev->dev)\n\t\t\tcontinue;\n\t\tdev_data = pci_get_drvdata(psdev->dev);\n\t\tif (!dev_data || !dev_data->allow_interrupt_control)\n\t\t\tcontinue;\n\t\tcount +=\n\t\t    scnprintf(buf + count, PAGE_SIZE - count, \"%s\\n\",\n\t\t\t      pci_name(psdev->dev));\n\t}\n\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(allow_interrupt_control);\n\nstatic void pcistub_exit(void)\n{\n\tdriver_remove_file(&xen_pcibk_pci_driver.driver, &driver_attr_new_slot);\n\tdriver_remove_file(&xen_pcibk_pci_driver.driver,\n\t\t\t   &driver_attr_remove_slot);\n\tdriver_remove_file(&xen_pcibk_pci_driver.driver, &driver_attr_slots);\n\tdriver_remove_file(&xen_pcibk_pci_driver.driver, &driver_attr_quirks);\n\tdriver_remove_file(&xen_pcibk_pci_driver.driver,\n\t\t\t   &driver_attr_permissive);\n\tdriver_remove_file(&xen_pcibk_pci_driver.driver,\n\t\t\t   &driver_attr_allow_interrupt_control);\n\tdriver_remove_file(&xen_pcibk_pci_driver.driver,\n\t\t\t   &driver_attr_irq_handlers);\n\tdriver_remove_file(&xen_pcibk_pci_driver.driver,\n\t\t\t   &driver_attr_irq_handler_state);\n\tpci_unregister_driver(&xen_pcibk_pci_driver);\n}\n\nstatic int __init pcistub_init(void)\n{\n\tint pos = 0;\n\tint err = 0;\n\tint domain, bus, slot, func;\n\tint parsed;\n\n\tif (pci_devs_to_hide && *pci_devs_to_hide) {\n\t\tdo {\n\t\t\tparsed = 0;\n\n\t\t\terr = sscanf(pci_devs_to_hide + pos,\n\t\t\t\t     \" (%x:%x:%x.%x) %n\",\n\t\t\t\t     &domain, &bus, &slot, &func, &parsed);\n\t\t\tswitch (err) {\n\t\t\tcase 3:\n\t\t\t\tfunc = -1;\n\t\t\t\tsscanf(pci_devs_to_hide + pos,\n\t\t\t\t       \" (%x:%x:%x.*) %n\",\n\t\t\t\t       &domain, &bus, &slot, &parsed);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tslot = func = -1;\n\t\t\t\tsscanf(pci_devs_to_hide + pos,\n\t\t\t\t       \" (%x:%x:*.*) %n\",\n\t\t\t\t       &domain, &bus, &parsed);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!parsed) {\n\t\t\t\tdomain = 0;\n\t\t\t\terr = sscanf(pci_devs_to_hide + pos,\n\t\t\t\t\t     \" (%x:%x.%x) %n\",\n\t\t\t\t\t     &bus, &slot, &func, &parsed);\n\t\t\t\tswitch (err) {\n\t\t\t\tcase 2:\n\t\t\t\t\tfunc = -1;\n\t\t\t\t\tsscanf(pci_devs_to_hide + pos,\n\t\t\t\t\t       \" (%x:%x.*) %n\",\n\t\t\t\t\t       &bus, &slot, &parsed);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tslot = func = -1;\n\t\t\t\t\tsscanf(pci_devs_to_hide + pos,\n\t\t\t\t\t       \" (%x:*.*) %n\",\n\t\t\t\t\t       &bus, &parsed);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (parsed <= 0)\n\t\t\t\tgoto parse_error;\n\n\t\t\terr = pcistub_device_id_add(domain, bus, slot, func);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tpos += parsed;\n\t\t} while (pci_devs_to_hide[pos]);\n\t}\n\n\t \n\terr = pci_register_driver(&xen_pcibk_pci_driver);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = driver_create_file(&xen_pcibk_pci_driver.driver,\n\t\t\t\t &driver_attr_new_slot);\n\tif (!err)\n\t\terr = driver_create_file(&xen_pcibk_pci_driver.driver,\n\t\t\t\t\t &driver_attr_remove_slot);\n\tif (!err)\n\t\terr = driver_create_file(&xen_pcibk_pci_driver.driver,\n\t\t\t\t\t &driver_attr_slots);\n\tif (!err)\n\t\terr = driver_create_file(&xen_pcibk_pci_driver.driver,\n\t\t\t\t\t &driver_attr_quirks);\n\tif (!err)\n\t\terr = driver_create_file(&xen_pcibk_pci_driver.driver,\n\t\t\t\t\t &driver_attr_permissive);\n\tif (!err)\n\t\terr = driver_create_file(&xen_pcibk_pci_driver.driver,\n\t\t\t\t\t &driver_attr_allow_interrupt_control);\n\n\tif (!err)\n\t\terr = driver_create_file(&xen_pcibk_pci_driver.driver,\n\t\t\t\t\t &driver_attr_irq_handlers);\n\tif (!err)\n\t\terr = driver_create_file(&xen_pcibk_pci_driver.driver,\n\t\t\t\t\t&driver_attr_irq_handler_state);\n\tif (err)\n\t\tpcistub_exit();\n\nout:\n\treturn err;\n\nparse_error:\n\tpr_err(\"Error parsing pci_devs_to_hide at \\\"%s\\\"\\n\",\n\t       pci_devs_to_hide + pos);\n\treturn -EINVAL;\n}\n\n#ifndef MODULE\n \nfs_initcall(pcistub_init);\n#endif\n\n#ifdef CONFIG_PCI_IOV\nstatic struct pcistub_device *find_vfs(const struct pci_dev *pdev)\n{\n\tstruct pcistub_device *psdev = NULL;\n\tunsigned long flags;\n\tbool found = false;\n\n\tspin_lock_irqsave(&pcistub_devices_lock, flags);\n\tlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\n\t\tif (!psdev->pdev && psdev->dev != pdev\n\t\t    && pci_physfn(psdev->dev) == pdev) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pcistub_devices_lock, flags);\n\tif (found)\n\t\treturn psdev;\n\treturn NULL;\n}\n\nstatic int pci_stub_notifier(struct notifier_block *nb,\n\t\t\t     unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tconst struct pci_dev *pdev = to_pci_dev(dev);\n\n\tif (action != BUS_NOTIFY_UNBIND_DRIVER)\n\t\treturn NOTIFY_DONE;\n\n\tif (!pdev->is_physfn)\n\t\treturn NOTIFY_DONE;\n\n\tfor (;;) {\n\t\tstruct pcistub_device *psdev = find_vfs(pdev);\n\t\tif (!psdev)\n\t\t\tbreak;\n\t\tdevice_release_driver(&psdev->dev->dev);\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block pci_stub_nb = {\n\t.notifier_call = pci_stub_notifier,\n};\n#endif\n\nstatic int __init xen_pcibk_init(void)\n{\n\tint err;\n\n\tif (!xen_initial_domain())\n\t\treturn -ENODEV;\n\n\terr = xen_pcibk_config_init();\n\tif (err)\n\t\treturn err;\n\n#ifdef MODULE\n\terr = pcistub_init();\n\tif (err < 0)\n\t\treturn err;\n#endif\n\n\tpcistub_init_devices_late();\n\terr = xen_pcibk_xenbus_register();\n\tif (err)\n\t\tpcistub_exit();\n#ifdef CONFIG_PCI_IOV\n\telse\n\t\tbus_register_notifier(&pci_bus_type, &pci_stub_nb);\n#endif\n\n\treturn err;\n}\n\nstatic void __exit xen_pcibk_cleanup(void)\n{\n#ifdef CONFIG_PCI_IOV\n\tbus_unregister_notifier(&pci_bus_type, &pci_stub_nb);\n#endif\n\txen_pcibk_xenbus_unregister();\n\tpcistub_exit();\n}\n\nmodule_init(xen_pcibk_init);\nmodule_exit(xen_pcibk_cleanup);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"xen-backend:pci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}