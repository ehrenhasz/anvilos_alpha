{
  "module_name": "pciback_ops.c",
  "hash_id": "1dd1f53bfcf2a7df8a0401c0a380256c98e9d2e47678ab1b197852b11aa06e5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-pciback/pciback_ops.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#define dev_fmt pr_fmt\n\n#include <linux/moduleparam.h>\n#include <linux/wait.h>\n#include <linux/bitops.h>\n#include <xen/events.h>\n#include <linux/sched.h>\n#include \"pciback.h\"\n\nstatic irqreturn_t xen_pcibk_guest_interrupt(int irq, void *dev_id);\n\n \nstatic void xen_pcibk_control_isr(struct pci_dev *dev, int reset)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint rc;\n\tint enable = 0;\n\n\tdev_data = pci_get_drvdata(dev);\n\tif (!dev_data)\n\t\treturn;\n\n\t \n\tif (dev->hdr_type != PCI_HEADER_TYPE_NORMAL)\n\t\treturn;\n\n\tif (reset) {\n\t\tdev_data->enable_intx = 0;\n\t\tdev_data->ack_intr = 0;\n\t}\n\tenable =  dev_data->enable_intx;\n\n\t \n\tif (!enable && !dev_data->isr_on)\n\t\treturn;\n\n\t \n\tif (enable)\n\t\tdev_data->irq = dev->irq;\n\n\t \n\tif (dev_data->irq == 0)\n\t\tgoto out;\n\n\tdev_dbg(&dev->dev, \"%s: #%d %s %s%s %s-> %s\\n\",\n\t\tdev_data->irq_name,\n\t\tdev_data->irq,\n\t\tpci_is_enabled(dev) ? \"on\" : \"off\",\n\t\tdev->msi_enabled ? \"MSI\" : \"\",\n\t\tdev->msix_enabled ? \"MSI/X\" : \"\",\n\t\tdev_data->isr_on ? \"enable\" : \"disable\",\n\t\tenable ? \"enable\" : \"disable\");\n\n\tif (enable) {\n\t\t \n\t\tif (dev->msi_enabled || dev->msix_enabled)\n\t\t\tgoto out;\n\n\t\trc = request_irq(dev_data->irq,\n\t\t\t\txen_pcibk_guest_interrupt, IRQF_SHARED,\n\t\t\t\tdev_data->irq_name, dev);\n\t\tif (rc) {\n\t\t\tdev_err(&dev->dev, \"%s: failed to install fake IRQ \" \\\n\t\t\t\t\"handler for IRQ %d! (rc:%d)\\n\",\n\t\t\t\tdev_data->irq_name, dev_data->irq, rc);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tfree_irq(dev_data->irq, dev);\n\t\tdev_data->irq = 0;\n\t}\n\tdev_data->isr_on = enable;\n\tdev_data->ack_intr = enable;\nout:\n\tdev_dbg(&dev->dev, \"%s: #%d %s %s%s %s\\n\",\n\t\tdev_data->irq_name,\n\t\tdev_data->irq,\n\t\tpci_is_enabled(dev) ? \"on\" : \"off\",\n\t\tdev->msi_enabled ? \"MSI\" : \"\",\n\t\tdev->msix_enabled ? \"MSI/X\" : \"\",\n\t\tenable ? (dev_data->isr_on ? \"enabled\" : \"failed to enable\") :\n\t\t\t(dev_data->isr_on ? \"failed to disable\" : \"disabled\"));\n}\n\n \nvoid xen_pcibk_reset_device(struct pci_dev *dev)\n{\n\tu16 cmd;\n\n\txen_pcibk_control_isr(dev, 1  );\n\n\t \n\tif (dev->hdr_type == PCI_HEADER_TYPE_NORMAL) {\n#ifdef CONFIG_PCI_MSI\n\t\t \n\t\tif (dev->msix_enabled)\n\t\t\tpci_disable_msix(dev);\n\t\tif (dev->msi_enabled)\n\t\t\tpci_disable_msi(dev);\n#endif\n\t\tif (pci_is_enabled(dev))\n\t\t\tpci_disable_device(dev);\n\n\t\tdev->is_busmaster = 0;\n\t} else {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\t\tif (cmd & (PCI_COMMAND_INVALIDATE)) {\n\t\t\tcmd &= ~(PCI_COMMAND_INVALIDATE);\n\t\t\tpci_write_config_word(dev, PCI_COMMAND, cmd);\n\n\t\t\tdev->is_busmaster = 0;\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_PCI_MSI\nstatic\nint xen_pcibk_enable_msi(struct xen_pcibk_device *pdev,\n\t\t\t struct pci_dev *dev, struct xen_pci_op *op)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint status;\n\n\tif (dev->msi_enabled)\n\t\tstatus = -EALREADY;\n\telse if (dev->msix_enabled)\n\t\tstatus = -ENXIO;\n\telse\n\t\tstatus = pci_enable_msi(dev);\n\n\tif (status) {\n\t\tdev_warn_ratelimited(&dev->dev, \"error enabling MSI for guest %u: err %d\\n\",\n\t\t\t\t     pdev->xdev->otherend_id, status);\n\t\top->value = 0;\n\t\treturn XEN_PCI_ERR_op_failed;\n\t}\n\n\t \n\n\top->value = dev->irq ? xen_pirq_from_irq(dev->irq) : 0;\n\n\tdev_dbg(&dev->dev, \"MSI: %d\\n\", op->value);\n\n\tdev_data = pci_get_drvdata(dev);\n\tif (dev_data)\n\t\tdev_data->ack_intr = 0;\n\n\treturn 0;\n}\n\nstatic\nint xen_pcibk_disable_msi(struct xen_pcibk_device *pdev,\n\t\t\t  struct pci_dev *dev, struct xen_pci_op *op)\n{\n\tif (dev->msi_enabled) {\n\t\tstruct xen_pcibk_dev_data *dev_data;\n\n\t\tpci_disable_msi(dev);\n\n\t\tdev_data = pci_get_drvdata(dev);\n\t\tif (dev_data)\n\t\t\tdev_data->ack_intr = 1;\n\t}\n\top->value = dev->irq ? xen_pirq_from_irq(dev->irq) : 0;\n\n\tdev_dbg(&dev->dev, \"MSI: %d\\n\", op->value);\n\n\treturn 0;\n}\n\nstatic\nint xen_pcibk_enable_msix(struct xen_pcibk_device *pdev,\n\t\t\t  struct pci_dev *dev, struct xen_pci_op *op)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint i, result;\n\tstruct msix_entry *entries;\n\tu16 cmd;\n\n\tdev_dbg(&dev->dev, \"enable MSI-X\\n\");\n\n\tif (op->value > SH_INFO_MAX_VEC)\n\t\treturn -EINVAL;\n\n\tif (dev->msix_enabled)\n\t\treturn -EALREADY;\n\n\t \n\tpci_read_config_word(pci_physfn(dev), PCI_COMMAND, &cmd);\n\tif (dev->msi_enabled || !(cmd & PCI_COMMAND_MEMORY))\n\t\treturn -ENXIO;\n\n\tentries = kmalloc_array(op->value, sizeof(*entries), GFP_KERNEL);\n\tif (entries == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < op->value; i++) {\n\t\tentries[i].entry = op->msix_entries[i].entry;\n\t\tentries[i].vector = op->msix_entries[i].vector;\n\t}\n\n\tresult = pci_enable_msix_exact(dev, entries, op->value);\n\tif (result == 0) {\n\t\tfor (i = 0; i < op->value; i++) {\n\t\t\top->msix_entries[i].entry = entries[i].entry;\n\t\t\tif (entries[i].vector) {\n\t\t\t\top->msix_entries[i].vector =\n\t\t\t\t\txen_pirq_from_irq(entries[i].vector);\n\t\t\t\tdev_dbg(&dev->dev, \"MSI-X[%d]: %d\\n\", i,\n\t\t\t\t\top->msix_entries[i].vector);\n\t\t\t}\n\t\t}\n\t} else\n\t\tdev_warn_ratelimited(&dev->dev, \"error enabling MSI-X for guest %u: err %d!\\n\",\n\t\t\t\t     pdev->xdev->otherend_id, result);\n\tkfree(entries);\n\n\top->value = result;\n\tdev_data = pci_get_drvdata(dev);\n\tif (dev_data)\n\t\tdev_data->ack_intr = 0;\n\n\treturn result > 0 ? 0 : result;\n}\n\nstatic\nint xen_pcibk_disable_msix(struct xen_pcibk_device *pdev,\n\t\t\t   struct pci_dev *dev, struct xen_pci_op *op)\n{\n\tif (dev->msix_enabled) {\n\t\tstruct xen_pcibk_dev_data *dev_data;\n\n\t\tpci_disable_msix(dev);\n\n\t\tdev_data = pci_get_drvdata(dev);\n\t\tif (dev_data)\n\t\t\tdev_data->ack_intr = 1;\n\t}\n\t \n\top->value = dev->irq ? xen_pirq_from_irq(dev->irq) : 0;\n\n\tdev_dbg(&dev->dev, \"MSI-X: %d\\n\", op->value);\n\n\treturn 0;\n}\n#endif\n\nstatic inline bool xen_pcibk_test_op_pending(struct xen_pcibk_device *pdev)\n{\n\treturn test_bit(_XEN_PCIF_active,\n\t\t\t(unsigned long *)&pdev->sh_info->flags) &&\n\t       !test_and_set_bit(_PDEVF_op_active, &pdev->flags);\n}\n\n \nstatic void xen_pcibk_test_and_schedule_op(struct xen_pcibk_device *pdev)\n{\n\tbool eoi = true;\n\n\t \n\tif (xen_pcibk_test_op_pending(pdev)) {\n\t\tschedule_work(&pdev->op_work);\n\t\teoi = false;\n\t}\n\t \n\tif (!test_bit(_XEN_PCIB_active, (unsigned long *)&pdev->sh_info->flags)\n\t    && test_bit(_PCIB_op_pending, &pdev->flags)) {\n\t\twake_up(&xen_pcibk_aer_wait_queue);\n\t\teoi = false;\n\t}\n\n\t \n\tif (eoi)\n\t\txen_pcibk_lateeoi(pdev, XEN_EOI_FLAG_SPURIOUS);\n}\n\n \n\nstatic void xen_pcibk_do_one_op(struct xen_pcibk_device *pdev)\n{\n\tstruct pci_dev *dev;\n\tstruct xen_pcibk_dev_data *dev_data = NULL;\n\tstruct xen_pci_op *op = &pdev->op;\n\tint test_intx = 0;\n#ifdef CONFIG_PCI_MSI\n\tunsigned int nr = 0;\n#endif\n\n\t*op = pdev->sh_info->op;\n\tbarrier();\n\tdev = xen_pcibk_get_pci_dev(pdev, op->domain, op->bus, op->devfn);\n\n\tif (dev == NULL)\n\t\top->err = XEN_PCI_ERR_dev_not_found;\n\telse {\n\t\tdev_data = pci_get_drvdata(dev);\n\t\tif (dev_data)\n\t\t\ttest_intx = dev_data->enable_intx;\n\t\tswitch (op->cmd) {\n\t\tcase XEN_PCI_OP_conf_read:\n\t\t\top->err = xen_pcibk_config_read(dev,\n\t\t\t\t  op->offset, op->size, &op->value);\n\t\t\tbreak;\n\t\tcase XEN_PCI_OP_conf_write:\n\t\t\top->err = xen_pcibk_config_write(dev,\n\t\t\t\t  op->offset, op->size,\top->value);\n\t\t\tbreak;\n#ifdef CONFIG_PCI_MSI\n\t\tcase XEN_PCI_OP_enable_msi:\n\t\t\top->err = xen_pcibk_enable_msi(pdev, dev, op);\n\t\t\tbreak;\n\t\tcase XEN_PCI_OP_disable_msi:\n\t\t\top->err = xen_pcibk_disable_msi(pdev, dev, op);\n\t\t\tbreak;\n\t\tcase XEN_PCI_OP_enable_msix:\n\t\t\tnr = op->value;\n\t\t\top->err = xen_pcibk_enable_msix(pdev, dev, op);\n\t\t\tbreak;\n\t\tcase XEN_PCI_OP_disable_msix:\n\t\t\top->err = xen_pcibk_disable_msix(pdev, dev, op);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\top->err = XEN_PCI_ERR_not_implemented;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!op->err && dev && dev_data) {\n\t\t \n\t\tif ((dev_data->enable_intx != test_intx))\n\t\t\txen_pcibk_control_isr(dev, 0  );\n\t}\n\tpdev->sh_info->op.err = op->err;\n\tpdev->sh_info->op.value = op->value;\n#ifdef CONFIG_PCI_MSI\n\tif (op->cmd == XEN_PCI_OP_enable_msix && op->err == 0) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tpdev->sh_info->op.msix_entries[i].vector =\n\t\t\t\top->msix_entries[i].vector;\n\t}\n#endif\n\t \n\twmb();\n\tclear_bit(_XEN_PCIF_active, (unsigned long *)&pdev->sh_info->flags);\n\tnotify_remote_via_irq(pdev->evtchn_irq);\n\n\t \n\tsmp_mb__before_atomic();  \n\tclear_bit(_PDEVF_op_active, &pdev->flags);\n\tsmp_mb__after_atomic();  \n}\n\nvoid xen_pcibk_do_op(struct work_struct *data)\n{\n\tstruct xen_pcibk_device *pdev =\n\t\tcontainer_of(data, struct xen_pcibk_device, op_work);\n\n\tdo {\n\t\txen_pcibk_do_one_op(pdev);\n\t} while (xen_pcibk_test_op_pending(pdev));\n\n\txen_pcibk_lateeoi(pdev, 0);\n}\n\nirqreturn_t xen_pcibk_handle_event(int irq, void *dev_id)\n{\n\tstruct xen_pcibk_device *pdev = dev_id;\n\tbool eoi;\n\n\t \n\tif (unlikely(pdev->evtchn_irq != irq))\n\t\tpdev->evtchn_irq = irq;\n\n\teoi = test_and_set_bit(_EOI_pending, &pdev->flags);\n\tWARN(eoi, \"IRQ while EOI pending\\n\");\n\n\txen_pcibk_test_and_schedule_op(pdev);\n\n\treturn IRQ_HANDLED;\n}\nstatic irqreturn_t xen_pcibk_guest_interrupt(int irq, void *dev_id)\n{\n\tstruct pci_dev *dev = (struct pci_dev *)dev_id;\n\tstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\n\n\tif (dev_data->isr_on && dev_data->ack_intr) {\n\t\tdev_data->handled++;\n\t\tif ((dev_data->handled % 1000) == 0) {\n\t\t\tif (xen_test_irq_shared(irq)) {\n\t\t\t\tdev_info(&dev->dev, \"%s IRQ line is not shared \"\n\t\t\t\t\t\"with other domains. Turning ISR off\\n\",\n\t\t\t\t\t dev_data->irq_name);\n\t\t\t\tdev_data->ack_intr = 0;\n\t\t\t}\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}