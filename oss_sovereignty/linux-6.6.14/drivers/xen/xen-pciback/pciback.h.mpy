{
  "module_name": "pciback.h",
  "hash_id": "0856427a2a446a58c9b729e6c1e95948aea5fd5d0a56a9228f3364c73ee40790",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-pciback/pciback.h",
  "human_readable_source": " \n \n#ifndef __XEN_PCIBACK_H__\n#define __XEN_PCIBACK_H__\n\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <xen/xenbus.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/atomic.h>\n#include <xen/events.h>\n#include <xen/interface/io/pciif.h>\n\n#define DRV_NAME\t\"xen-pciback\"\n\nstruct pci_dev_entry {\n\tstruct list_head list;\n\tstruct pci_dev *dev;\n};\n\n#define _PDEVF_op_active\t(0)\n#define PDEVF_op_active\t\t(1<<(_PDEVF_op_active))\n#define _PCIB_op_pending\t(1)\n#define PCIB_op_pending\t\t(1<<(_PCIB_op_pending))\n#define _EOI_pending\t\t(2)\n#define EOI_pending\t\t(1<<(_EOI_pending))\n\nstruct xen_pcibk_device {\n\tvoid *pci_dev_data;\n\tstruct mutex dev_lock;\n\tstruct xenbus_device *xdev;\n\tstruct xenbus_watch be_watch;\n\tu8 be_watching;\n\tint evtchn_irq;\n\tstruct xen_pci_sharedinfo *sh_info;\n\tunsigned long flags;\n\tstruct work_struct op_work;\n\tstruct xen_pci_op op;\n};\n\nstruct xen_pcibk_dev_data {\n\tstruct list_head config_fields;\n\tstruct pci_saved_state *pci_saved_state;\n\tunsigned int permissive:1;\n\tunsigned int allow_interrupt_control:1;\n\tunsigned int warned_on_write:1;\n\tunsigned int enable_intx:1;\n\tunsigned int isr_on:1;  \n\tunsigned int ack_intr:1;  \n\tunsigned long handled;\n\tunsigned int irq;  \n\tchar irq_name[];  \n};\n\n \nextern wait_queue_head_t xen_pcibk_aer_wait_queue;\n \nextern struct list_head xen_pcibk_quirks;\n\n \nstruct pci_dev *pcistub_get_pci_dev_by_slot(struct xen_pcibk_device *pdev,\n\t\t\t\t\t    int domain, int bus,\n\t\t\t\t\t    int slot, int func);\nstruct pci_dev *pcistub_get_pci_dev(struct xen_pcibk_device *pdev,\n\t\t\t\t    struct pci_dev *dev);\nvoid pcistub_put_pci_dev(struct pci_dev *dev);\n\nstatic inline bool xen_pcibk_pv_support(void)\n{\n\treturn IS_ENABLED(CONFIG_XEN_PCIDEV_BACKEND);\n}\n\n \nvoid xen_pcibk_reset_device(struct pci_dev *pdev);\n\n \nint xen_pcibk_config_init(void);\nint xen_pcibk_config_init_dev(struct pci_dev *dev);\nvoid xen_pcibk_config_free_dyn_fields(struct pci_dev *dev);\nvoid xen_pcibk_config_reset_dev(struct pci_dev *dev);\nvoid xen_pcibk_config_free_dev(struct pci_dev *dev);\nint xen_pcibk_config_read(struct pci_dev *dev, int offset, int size,\n\t\t\t  u32 *ret_val);\nint xen_pcibk_config_write(struct pci_dev *dev, int offset, int size,\n\t\t\t   u32 value);\n\n \ntypedef int (*publish_pci_dev_cb) (struct xen_pcibk_device *pdev,\n\t\t\t\t   unsigned int domain, unsigned int bus,\n\t\t\t\t   unsigned int devfn, unsigned int devid);\ntypedef int (*publish_pci_root_cb) (struct xen_pcibk_device *pdev,\n\t\t\t\t    unsigned int domain, unsigned int bus);\n\n \nstruct xen_pcibk_backend {\n\tconst char *name;\n\tint (*init)(struct xen_pcibk_device *pdev);\n\tvoid (*free)(struct xen_pcibk_device *pdev);\n\tint (*find)(struct pci_dev *pcidev, struct xen_pcibk_device *pdev,\n\t\t    unsigned int *domain, unsigned int *bus,\n\t\t    unsigned int *devfn);\n\tint (*publish)(struct xen_pcibk_device *pdev, publish_pci_root_cb cb);\n\tvoid (*release)(struct xen_pcibk_device *pdev, struct pci_dev *dev,\n                        bool lock);\n\tint (*add)(struct xen_pcibk_device *pdev, struct pci_dev *dev,\n\t\t   int devid, publish_pci_dev_cb publish_cb);\n\tstruct pci_dev *(*get)(struct xen_pcibk_device *pdev,\n\t\t\t       unsigned int domain, unsigned int bus,\n\t\t\t       unsigned int devfn);\n};\n\nextern const struct xen_pcibk_backend xen_pcibk_vpci_backend;\nextern const struct xen_pcibk_backend xen_pcibk_passthrough_backend;\nextern const struct xen_pcibk_backend *xen_pcibk_backend;\n\nstatic inline int xen_pcibk_add_pci_dev(struct xen_pcibk_device *pdev,\n\t\t\t\t\tstruct pci_dev *dev,\n\t\t\t\t\tint devid,\n\t\t\t\t\tpublish_pci_dev_cb publish_cb)\n{\n\tif (xen_pcibk_backend && xen_pcibk_backend->add)\n\t\treturn xen_pcibk_backend->add(pdev, dev, devid, publish_cb);\n\treturn -1;\n}\n\nstatic inline void xen_pcibk_release_pci_dev(struct xen_pcibk_device *pdev,\n\t\t\t\t\t     struct pci_dev *dev, bool lock)\n{\n\tif (xen_pcibk_backend && xen_pcibk_backend->release)\n\t\treturn xen_pcibk_backend->release(pdev, dev, lock);\n}\n\nstatic inline struct pci_dev *\nxen_pcibk_get_pci_dev(struct xen_pcibk_device *pdev, unsigned int domain,\n\t\t      unsigned int bus, unsigned int devfn)\n{\n\tif (xen_pcibk_backend && xen_pcibk_backend->get)\n\t\treturn xen_pcibk_backend->get(pdev, domain, bus, devfn);\n\treturn NULL;\n}\n\n \nstatic inline int xen_pcibk_get_pcifront_dev(struct pci_dev *pcidev,\n\t\t\t\t\t     struct xen_pcibk_device *pdev,\n\t\t\t\t\t     unsigned int *domain,\n\t\t\t\t\t     unsigned int *bus,\n\t\t\t\t\t     unsigned int *devfn)\n{\n\tif (xen_pcibk_backend && xen_pcibk_backend->find)\n\t\treturn xen_pcibk_backend->find(pcidev, pdev, domain, bus,\n\t\t\t\t\t       devfn);\n\treturn -1;\n}\n\nstatic inline int xen_pcibk_init_devices(struct xen_pcibk_device *pdev)\n{\n\tif (xen_pcibk_backend && xen_pcibk_backend->init)\n\t\treturn xen_pcibk_backend->init(pdev);\n\treturn -1;\n}\n\nstatic inline int xen_pcibk_publish_pci_roots(struct xen_pcibk_device *pdev,\n\t\t\t\t\t      publish_pci_root_cb cb)\n{\n\tif (xen_pcibk_backend && xen_pcibk_backend->publish)\n\t\treturn xen_pcibk_backend->publish(pdev, cb);\n\treturn -1;\n}\n\nstatic inline void xen_pcibk_release_devices(struct xen_pcibk_device *pdev)\n{\n\tif (xen_pcibk_backend && xen_pcibk_backend->free)\n\t\treturn xen_pcibk_backend->free(pdev);\n}\n\n \nirqreturn_t xen_pcibk_handle_event(int irq, void *dev_id);\nvoid xen_pcibk_do_op(struct work_struct *data);\n\nstatic inline void xen_pcibk_lateeoi(struct xen_pcibk_device *pdev,\n\t\t\t\t     unsigned int eoi_flag)\n{\n\tif (test_and_clear_bit(_EOI_pending, &pdev->flags))\n\t\txen_irq_lateeoi(pdev->evtchn_irq, eoi_flag);\n}\n\nint xen_pcibk_xenbus_register(void);\nvoid xen_pcibk_xenbus_unregister(void);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}