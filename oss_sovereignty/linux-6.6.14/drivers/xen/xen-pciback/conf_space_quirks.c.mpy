{
  "module_name": "conf_space_quirks.c",
  "hash_id": "473d7d804f8ac1a3f3720cdf0c1710472ae794d221dbefb251c42cb4aa697955",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-pciback/conf_space_quirks.c",
  "human_readable_source": "\n \n\n#define dev_fmt(fmt) DRV_NAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include \"pciback.h\"\n#include \"conf_space.h\"\n#include \"conf_space_quirks.h\"\n\nLIST_HEAD(xen_pcibk_quirks);\nstatic inline const struct pci_device_id *\nmatch_one_device(const struct pci_device_id *id, const struct pci_dev *dev)\n{\n\tif ((id->vendor == PCI_ANY_ID || id->vendor == dev->vendor) &&\n\t    (id->device == PCI_ANY_ID || id->device == dev->device) &&\n\t    (id->subvendor == PCI_ANY_ID ||\n\t\t\t\tid->subvendor == dev->subsystem_vendor) &&\n\t    (id->subdevice == PCI_ANY_ID ||\n\t\t\t\tid->subdevice == dev->subsystem_device) &&\n\t    !((id->class ^ dev->class) & id->class_mask))\n\t\treturn id;\n\treturn NULL;\n}\n\nstatic struct xen_pcibk_config_quirk *xen_pcibk_find_quirk(struct pci_dev *dev)\n{\n\tstruct xen_pcibk_config_quirk *tmp_quirk;\n\n\tlist_for_each_entry(tmp_quirk, &xen_pcibk_quirks, quirks_list)\n\t\tif (match_one_device(&tmp_quirk->devid, dev) != NULL)\n\t\t\tgoto out;\n\ttmp_quirk = NULL;\n\tdev_printk(KERN_DEBUG, &dev->dev,\n\t\t   \"quirk didn't match any device known\\n\");\nout:\n\treturn tmp_quirk;\n}\n\nstatic inline void register_quirk(struct xen_pcibk_config_quirk *quirk)\n{\n\tlist_add_tail(&quirk->quirks_list, &xen_pcibk_quirks);\n}\n\nint xen_pcibk_field_is_dup(struct pci_dev *dev, unsigned int reg)\n{\n\tint ret = 0;\n\tstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\n\tstruct config_field_entry *cfg_entry;\n\n\tlist_for_each_entry(cfg_entry, &dev_data->config_fields, list) {\n\t\tif (OFFSET(cfg_entry) == reg) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint xen_pcibk_config_quirks_add_field(struct pci_dev *dev, struct config_field\n\t\t\t\t    *field)\n{\n\tint err = 0;\n\n\tswitch (field->size) {\n\tcase 1:\n\t\tfield->u.b.read = xen_pcibk_read_config_byte;\n\t\tfield->u.b.write = xen_pcibk_write_config_byte;\n\t\tbreak;\n\tcase 2:\n\t\tfield->u.w.read = xen_pcibk_read_config_word;\n\t\tfield->u.w.write = xen_pcibk_write_config_word;\n\t\tbreak;\n\tcase 4:\n\t\tfield->u.dw.read = xen_pcibk_read_config_dword;\n\t\tfield->u.dw.write = xen_pcibk_write_config_dword;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\txen_pcibk_config_add_field(dev, field);\n\nout:\n\treturn err;\n}\n\nint xen_pcibk_config_quirks_init(struct pci_dev *dev)\n{\n\tstruct xen_pcibk_config_quirk *quirk;\n\tint ret = 0;\n\n\tquirk = kzalloc(sizeof(*quirk), GFP_KERNEL);\n\tif (!quirk) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tquirk->devid.vendor = dev->vendor;\n\tquirk->devid.device = dev->device;\n\tquirk->devid.subvendor = dev->subsystem_vendor;\n\tquirk->devid.subdevice = dev->subsystem_device;\n\tquirk->devid.class = 0;\n\tquirk->devid.class_mask = 0;\n\tquirk->devid.driver_data = 0UL;\n\n\tquirk->pdev = dev;\n\n\tregister_quirk(quirk);\nout:\n\treturn ret;\n}\n\nvoid xen_pcibk_config_field_free(struct config_field *field)\n{\n\tkfree(field);\n}\n\nint xen_pcibk_config_quirk_release(struct pci_dev *dev)\n{\n\tstruct xen_pcibk_config_quirk *quirk;\n\tint ret = 0;\n\n\tquirk = xen_pcibk_find_quirk(dev);\n\tif (!quirk) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tlist_del(&quirk->quirks_list);\n\tkfree(quirk);\n\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}