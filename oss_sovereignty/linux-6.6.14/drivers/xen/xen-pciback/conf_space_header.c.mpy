{
  "module_name": "conf_space_header.c",
  "hash_id": "c8b3923f3ccea0d2cdf873fca4435661230447673451f675f3c69d3de06e13c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-pciback/conf_space_header.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#define dev_fmt pr_fmt\n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include \"pciback.h\"\n#include \"conf_space.h\"\n\nstruct pci_cmd_info {\n\tu16 val;\n};\n\nstruct pci_bar_info {\n\tu32 val;\n\tu32 len_val;\n\tint which;\n};\n\n#define is_enable_cmd(value) ((value)&(PCI_COMMAND_MEMORY|PCI_COMMAND_IO))\n#define is_master_cmd(value) ((value)&PCI_COMMAND_MASTER)\n\n \n#define PCI_COMMAND_GUEST (PCI_COMMAND_MASTER|PCI_COMMAND_SPECIAL| \\\n\t\t\t   PCI_COMMAND_INVALIDATE|PCI_COMMAND_VGA_PALETTE| \\\n\t\t\t   PCI_COMMAND_WAIT|PCI_COMMAND_FAST_BACK)\n\nstatic void *command_init(struct pci_dev *dev, int offset)\n{\n\tstruct pci_cmd_info *cmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tint err;\n\n\tif (!cmd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = pci_read_config_word(dev, PCI_COMMAND, &cmd->val);\n\tif (err) {\n\t\tkfree(cmd);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn cmd;\n}\n\nstatic int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n{\n\tint ret = pci_read_config_word(dev, offset, value);\n\tconst struct pci_cmd_info *cmd = data;\n\n\t*value &= PCI_COMMAND_GUEST;\n\t*value |= cmd->val & ~PCI_COMMAND_GUEST;\n\n\treturn ret;\n}\n\nstatic int command_write(struct pci_dev *dev, int offset, u16 value, void *data)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint err;\n\tu16 val;\n\tstruct pci_cmd_info *cmd = data;\n\n\tdev_data = pci_get_drvdata(dev);\n\tif (!pci_is_enabled(dev) && is_enable_cmd(value)) {\n\t\tdev_dbg(&dev->dev, \"enable\\n\");\n\t\terr = pci_enable_device(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (dev_data)\n\t\t\tdev_data->enable_intx = 1;\n\t} else if (pci_is_enabled(dev) && !is_enable_cmd(value)) {\n\t\tdev_dbg(&dev->dev, \"disable\\n\");\n\t\tpci_disable_device(dev);\n\t\tif (dev_data)\n\t\t\tdev_data->enable_intx = 0;\n\t}\n\n\tif (!dev->is_busmaster && is_master_cmd(value)) {\n\t\tdev_dbg(&dev->dev, \"set bus master\\n\");\n\t\tpci_set_master(dev);\n\t} else if (dev->is_busmaster && !is_master_cmd(value)) {\n\t\tdev_dbg(&dev->dev, \"clear bus master\\n\");\n\t\tpci_clear_master(dev);\n\t}\n\n\tif (!(cmd->val & PCI_COMMAND_INVALIDATE) &&\n\t    (value & PCI_COMMAND_INVALIDATE)) {\n\t\tdev_dbg(&dev->dev, \"enable memory-write-invalidate\\n\");\n\t\terr = pci_set_mwi(dev);\n\t\tif (err) {\n\t\t\tdev_warn(&dev->dev, \"cannot enable memory-write-invalidate (%d)\\n\",\n\t\t\t\terr);\n\t\t\tvalue &= ~PCI_COMMAND_INVALIDATE;\n\t\t}\n\t} else if ((cmd->val & PCI_COMMAND_INVALIDATE) &&\n\t\t   !(value & PCI_COMMAND_INVALIDATE)) {\n\t\tdev_dbg(&dev->dev, \"disable memory-write-invalidate\\n\");\n\t\tpci_clear_mwi(dev);\n\t}\n\n\tif (dev_data && dev_data->allow_interrupt_control &&\n\t    ((cmd->val ^ value) & PCI_COMMAND_INTX_DISABLE))\n\t\tpci_intx(dev, !(value & PCI_COMMAND_INTX_DISABLE));\n\n\tcmd->val = value;\n\n\tif (!xen_pcibk_permissive && (!dev_data || !dev_data->permissive))\n\t\treturn 0;\n\n\t \n\terr = pci_read_config_word(dev, offset, &val);\n\tif (err || val == value)\n\t\treturn err;\n\n\tvalue &= PCI_COMMAND_GUEST;\n\tvalue |= val & ~PCI_COMMAND_GUEST;\n\n\treturn pci_write_config_word(dev, offset, value);\n}\n\nstatic int rom_write(struct pci_dev *dev, int offset, u32 value, void *data)\n{\n\tstruct pci_bar_info *bar = data;\n\n\tif (unlikely(!bar)) {\n\t\tdev_warn(&dev->dev, \"driver data not found\\n\");\n\t\treturn XEN_PCI_ERR_op_failed;\n\t}\n\n\t \n\tif ((value | ~PCI_ROM_ADDRESS_MASK) == ~0U)\n\t\tbar->which = 1;\n\telse {\n\t\tu32 tmpval;\n\t\tpci_read_config_dword(dev, offset, &tmpval);\n\t\tif (tmpval != bar->val && value == bar->val) {\n\t\t\t \n\t\t\tpci_write_config_dword(dev, offset, bar->val);\n\t\t}\n\t\tbar->which = 0;\n\t}\n\n\t \n\n\treturn 0;\n}\n\n \nstatic int bar_write(struct pci_dev *dev, int offset, u32 value, void *data)\n{\n\tstruct pci_bar_info *bar = data;\n\tunsigned int pos = (offset - PCI_BASE_ADDRESS_0) / 4;\n\tconst struct resource *res = dev->resource;\n\tu32 mask;\n\n\tif (unlikely(!bar)) {\n\t\tdev_warn(&dev->dev, \"driver data not found\\n\");\n\t\treturn XEN_PCI_ERR_op_failed;\n\t}\n\n\t \n\tif (res[pos].flags & IORESOURCE_IO)\n\t\tmask = ~PCI_BASE_ADDRESS_IO_MASK;\n\telse if (pos && (res[pos - 1].flags & IORESOURCE_MEM_64))\n\t\tmask = 0;\n\telse\n\t\tmask = ~PCI_BASE_ADDRESS_MEM_MASK;\n\tif ((value | mask) == ~0U)\n\t\tbar->which = 1;\n\telse {\n\t\tu32 tmpval;\n\t\tpci_read_config_dword(dev, offset, &tmpval);\n\t\tif (tmpval != bar->val && value == bar->val) {\n\t\t\t \n\t\t\tpci_write_config_dword(dev, offset, bar->val);\n\t\t}\n\t\tbar->which = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int bar_read(struct pci_dev *dev, int offset, u32 * value, void *data)\n{\n\tstruct pci_bar_info *bar = data;\n\n\tif (unlikely(!bar)) {\n\t\tdev_warn(&dev->dev, \"driver data not found\\n\");\n\t\treturn XEN_PCI_ERR_op_failed;\n\t}\n\n\t*value = bar->which ? bar->len_val : bar->val;\n\n\treturn 0;\n}\n\nstatic void *bar_init(struct pci_dev *dev, int offset)\n{\n\tunsigned int pos;\n\tconst struct resource *res = dev->resource;\n\tstruct pci_bar_info *bar = kzalloc(sizeof(*bar), GFP_KERNEL);\n\n\tif (!bar)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (offset == PCI_ROM_ADDRESS || offset == PCI_ROM_ADDRESS1)\n\t\tpos = PCI_ROM_RESOURCE;\n\telse {\n\t\tpos = (offset - PCI_BASE_ADDRESS_0) / 4;\n\t\tif (pos && (res[pos - 1].flags & IORESOURCE_MEM_64)) {\n\t\t\t \n\t\t\tbar->val = res[pos - 1].start >> 16 >> 16;\n\t\t\tbar->len_val = -resource_size(&res[pos - 1]) >> 16 >> 16;\n\t\t\treturn bar;\n\t\t}\n\t}\n\n\tif (!res[pos].flags ||\n\t    (res[pos].flags & (IORESOURCE_DISABLED | IORESOURCE_UNSET |\n\t\t\t       IORESOURCE_BUSY)))\n\t\treturn bar;\n\n\tbar->val = res[pos].start |\n\t\t   (res[pos].flags & PCI_REGION_FLAG_MASK);\n\tbar->len_val = -resource_size(&res[pos]) |\n\t\t       (res[pos].flags & PCI_REGION_FLAG_MASK);\n\n\treturn bar;\n}\n\nstatic void bar_reset(struct pci_dev *dev, int offset, void *data)\n{\n\tstruct pci_bar_info *bar = data;\n\n\tbar->which = 0;\n}\n\nstatic void bar_release(struct pci_dev *dev, int offset, void *data)\n{\n\tkfree(data);\n}\n\nstatic int xen_pcibk_read_vendor(struct pci_dev *dev, int offset,\n\t\t\t       u16 *value, void *data)\n{\n\t*value = dev->vendor;\n\n\treturn 0;\n}\n\nstatic int xen_pcibk_read_device(struct pci_dev *dev, int offset,\n\t\t\t       u16 *value, void *data)\n{\n\t*value = dev->device;\n\n\treturn 0;\n}\n\nstatic int interrupt_read(struct pci_dev *dev, int offset, u8 * value,\n\t\t\t  void *data)\n{\n\t*value = (u8) dev->irq;\n\n\treturn 0;\n}\n\nstatic int bist_write(struct pci_dev *dev, int offset, u8 value, void *data)\n{\n\tu8 cur_value;\n\tint err;\n\n\terr = pci_read_config_byte(dev, offset, &cur_value);\n\tif (err)\n\t\tgoto out;\n\n\tif ((cur_value & ~PCI_BIST_START) == (value & ~PCI_BIST_START)\n\t    || value == PCI_BIST_START)\n\t\terr = pci_write_config_byte(dev, offset, value);\n\nout:\n\treturn err;\n}\n\nstatic const struct config_field header_common[] = {\n\t{\n\t .offset    = PCI_VENDOR_ID,\n\t .size      = 2,\n\t .u.w.read  = xen_pcibk_read_vendor,\n\t},\n\t{\n\t .offset    = PCI_DEVICE_ID,\n\t .size      = 2,\n\t .u.w.read  = xen_pcibk_read_device,\n\t},\n\t{\n\t .offset    = PCI_COMMAND,\n\t .size      = 2,\n\t .init      = command_init,\n\t .release   = bar_release,\n\t .u.w.read  = command_read,\n\t .u.w.write = command_write,\n\t},\n\t{\n\t .offset    = PCI_INTERRUPT_LINE,\n\t .size      = 1,\n\t .u.b.read  = interrupt_read,\n\t},\n\t{\n\t .offset    = PCI_INTERRUPT_PIN,\n\t .size      = 1,\n\t .u.b.read  = xen_pcibk_read_config_byte,\n\t},\n\t{\n\t  \n\t .offset    = PCI_CACHE_LINE_SIZE,\n\t .size      = 1,\n\t .u.b.read  = xen_pcibk_read_config_byte,\n\t .u.b.write = xen_pcibk_write_config_byte,\n\t},\n\t{\n\t .offset    = PCI_LATENCY_TIMER,\n\t .size      = 1,\n\t .u.b.read  = xen_pcibk_read_config_byte,\n\t},\n\t{\n\t .offset    = PCI_BIST,\n\t .size      = 1,\n\t .u.b.read  = xen_pcibk_read_config_byte,\n\t .u.b.write = bist_write,\n\t},\n\t{}\n};\n\n#define CFG_FIELD_BAR(reg_offset)\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t.offset     = reg_offset,\t\t\t\\\n\t.size       = 4,\t\t\t\t\\\n\t.init       = bar_init,\t\t\t\t\\\n\t.reset      = bar_reset,\t\t\t\\\n\t.release    = bar_release,\t\t\t\\\n\t.u.dw.read  = bar_read,\t\t\t\t\\\n\t.u.dw.write = bar_write,\t\t\t\\\n\t}\n\n#define CFG_FIELD_ROM(reg_offset)\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t.offset     = reg_offset,\t\t\t\\\n\t.size       = 4,\t\t\t\t\\\n\t.init       = bar_init,\t\t\t\t\\\n\t.reset      = bar_reset,\t\t\t\\\n\t.release    = bar_release,\t\t\t\\\n\t.u.dw.read  = bar_read,\t\t\t\t\\\n\t.u.dw.write = rom_write,\t\t\t\\\n\t}\n\nstatic const struct config_field header_0[] = {\n\tCFG_FIELD_BAR(PCI_BASE_ADDRESS_0),\n\tCFG_FIELD_BAR(PCI_BASE_ADDRESS_1),\n\tCFG_FIELD_BAR(PCI_BASE_ADDRESS_2),\n\tCFG_FIELD_BAR(PCI_BASE_ADDRESS_3),\n\tCFG_FIELD_BAR(PCI_BASE_ADDRESS_4),\n\tCFG_FIELD_BAR(PCI_BASE_ADDRESS_5),\n\tCFG_FIELD_ROM(PCI_ROM_ADDRESS),\n\t{}\n};\n\nstatic const struct config_field header_1[] = {\n\tCFG_FIELD_BAR(PCI_BASE_ADDRESS_0),\n\tCFG_FIELD_BAR(PCI_BASE_ADDRESS_1),\n\tCFG_FIELD_ROM(PCI_ROM_ADDRESS1),\n\t{}\n};\n\nint xen_pcibk_config_header_add_fields(struct pci_dev *dev)\n{\n\tint err;\n\n\terr = xen_pcibk_config_add_fields(dev, header_common);\n\tif (err)\n\t\tgoto out;\n\n\tswitch (dev->hdr_type) {\n\tcase PCI_HEADER_TYPE_NORMAL:\n\t\terr = xen_pcibk_config_add_fields(dev, header_0);\n\t\tbreak;\n\n\tcase PCI_HEADER_TYPE_BRIDGE:\n\t\terr = xen_pcibk_config_add_fields(dev, header_1);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tdev_err(&dev->dev, \"Unsupported header type %d!\\n\",\n\t\t\tdev->hdr_type);\n\t\tbreak;\n\t}\n\nout:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}