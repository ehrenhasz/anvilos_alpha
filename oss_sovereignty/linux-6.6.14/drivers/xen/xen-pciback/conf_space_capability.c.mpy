{
  "module_name": "conf_space_capability.c",
  "hash_id": "3b67f4ecc3d24147fbc4cc85bb42356b59358768fdf3389971e93db24ddcd386",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-pciback/conf_space_capability.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include \"pciback.h\"\n#include \"conf_space.h\"\n\nstatic LIST_HEAD(capabilities);\nstruct xen_pcibk_config_capability {\n\tstruct list_head cap_list;\n\n\tint capability;\n\n\t \n\tconst struct config_field *fields;\n};\n\nstatic const struct config_field caplist_header[] = {\n\t{\n\t .offset    = PCI_CAP_LIST_ID,\n\t .size      = 2,  \n\t .u.w.read  = xen_pcibk_read_config_word,\n\t .u.w.write = NULL,\n\t},\n\t{}\n};\n\nstatic inline void register_capability(struct xen_pcibk_config_capability *cap)\n{\n\tlist_add_tail(&cap->cap_list, &capabilities);\n}\n\nint xen_pcibk_config_capability_add_fields(struct pci_dev *dev)\n{\n\tint err = 0;\n\tstruct xen_pcibk_config_capability *cap;\n\tint cap_offset;\n\n\tlist_for_each_entry(cap, &capabilities, cap_list) {\n\t\tcap_offset = pci_find_capability(dev, cap->capability);\n\t\tif (cap_offset) {\n\t\t\tdev_dbg(&dev->dev, \"Found capability 0x%x at 0x%x\\n\",\n\t\t\t\tcap->capability, cap_offset);\n\n\t\t\terr = xen_pcibk_config_add_fields_offset(dev,\n\t\t\t\t\t\t\t       caplist_header,\n\t\t\t\t\t\t\t       cap_offset);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = xen_pcibk_config_add_fields_offset(dev,\n\t\t\t\t\t\t\t       cap->fields,\n\t\t\t\t\t\t\t       cap_offset);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn err;\n}\n\nstatic int vpd_address_write(struct pci_dev *dev, int offset, u16 value,\n\t\t\t     void *data)\n{\n\t \n\tif (value & PCI_VPD_ADDR_F)\n\t\treturn PCIBIOS_SET_FAILED;\n\telse\n\t\treturn pci_write_config_word(dev, offset, value);\n}\n\nstatic const struct config_field caplist_vpd[] = {\n\t{\n\t .offset    = PCI_VPD_ADDR,\n\t .size      = 2,\n\t .u.w.read  = xen_pcibk_read_config_word,\n\t .u.w.write = vpd_address_write,\n\t },\n\t{\n\t .offset     = PCI_VPD_DATA,\n\t .size       = 4,\n\t .u.dw.read  = xen_pcibk_read_config_dword,\n\t .u.dw.write = NULL,\n\t },\n\t{}\n};\n\nstatic int pm_caps_read(struct pci_dev *dev, int offset, u16 *value,\n\t\t\tvoid *data)\n{\n\tint err;\n\tu16 real_value;\n\n\terr = pci_read_config_word(dev, offset, &real_value);\n\tif (err)\n\t\tgoto out;\n\n\t*value = real_value & ~PCI_PM_CAP_PME_MASK;\n\nout:\n\treturn err;\n}\n\n \n#define PM_OK_BITS (PCI_PM_CTRL_PME_STATUS|PCI_PM_CTRL_DATA_SEL_MASK)\n\nstatic int pm_ctrl_write(struct pci_dev *dev, int offset, u16 new_value,\n\t\t\t void *data)\n{\n\tint err;\n\tu16 old_value;\n\tpci_power_t new_state;\n\n\terr = pci_read_config_word(dev, offset, &old_value);\n\tif (err)\n\t\tgoto out;\n\n\tnew_state = (pci_power_t)(new_value & PCI_PM_CTRL_STATE_MASK);\n\n\tnew_value &= PM_OK_BITS;\n\tif ((old_value & PM_OK_BITS) != new_value) {\n\t\tnew_value = (old_value & ~PM_OK_BITS) | new_value;\n\t\terr = pci_write_config_word(dev, offset, new_value);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\tdev_dbg(&dev->dev, \"set power state to %x\\n\", new_state);\n\terr = pci_set_power_state(dev, new_state);\n\tif (err) {\n\t\terr = PCIBIOS_SET_FAILED;\n\t\tgoto out;\n\t}\n\n out:\n\treturn err;\n}\n\n \nstatic void *pm_ctrl_init(struct pci_dev *dev, int offset)\n{\n\tint err;\n\tu16 value;\n\n\terr = pci_read_config_word(dev, offset, &value);\n\tif (err)\n\t\tgoto out;\n\n\tif (value & PCI_PM_CTRL_PME_ENABLE) {\n\t\tvalue &= ~PCI_PM_CTRL_PME_ENABLE;\n\t\terr = pci_write_config_word(dev, offset, value);\n\t}\n\nout:\n\treturn err ? ERR_PTR(err) : NULL;\n}\n\nstatic const struct config_field caplist_pm[] = {\n\t{\n\t\t.offset     = PCI_PM_PMC,\n\t\t.size       = 2,\n\t\t.u.w.read   = pm_caps_read,\n\t},\n\t{\n\t\t.offset     = PCI_PM_CTRL,\n\t\t.size       = 2,\n\t\t.init       = pm_ctrl_init,\n\t\t.u.w.read   = xen_pcibk_read_config_word,\n\t\t.u.w.write  = pm_ctrl_write,\n\t},\n\t{\n\t\t.offset     = PCI_PM_PPB_EXTENSIONS,\n\t\t.size       = 1,\n\t\t.u.b.read   = xen_pcibk_read_config_byte,\n\t},\n\t{\n\t\t.offset     = PCI_PM_DATA_REGISTER,\n\t\t.size       = 1,\n\t\t.u.b.read   = xen_pcibk_read_config_byte,\n\t},\n\t{}\n};\n\nstatic struct msi_msix_field_config {\n\tu16          enable_bit;    \n\tu16          allowed_bits;  \n\tunsigned int int_type;      \n} msi_field_config = {\n\t.enable_bit\t= PCI_MSI_FLAGS_ENABLE,\n\t.allowed_bits\t= PCI_MSI_FLAGS_ENABLE,\n\t.int_type\t= INTERRUPT_TYPE_MSI,\n}, msix_field_config = {\n\t.enable_bit\t= PCI_MSIX_FLAGS_ENABLE,\n\t.allowed_bits\t= PCI_MSIX_FLAGS_ENABLE | PCI_MSIX_FLAGS_MASKALL,\n\t.int_type\t= INTERRUPT_TYPE_MSIX,\n};\n\nstatic void *msi_field_init(struct pci_dev *dev, int offset)\n{\n\treturn &msi_field_config;\n}\n\nstatic void *msix_field_init(struct pci_dev *dev, int offset)\n{\n\treturn &msix_field_config;\n}\n\nstatic int msi_msix_flags_write(struct pci_dev *dev, int offset, u16 new_value,\n\t\t\t\tvoid *data)\n{\n\tint err;\n\tu16 old_value;\n\tconst struct msi_msix_field_config *field_config = data;\n\tconst struct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\n\n\tif (xen_pcibk_permissive || dev_data->permissive)\n\t\tgoto write;\n\n\terr = pci_read_config_word(dev, offset, &old_value);\n\tif (err)\n\t\treturn err;\n\n\tif (new_value == old_value)\n\t\treturn 0;\n\n\tif (!dev_data->allow_interrupt_control ||\n\t    (new_value ^ old_value) & ~field_config->allowed_bits)\n\t\treturn PCIBIOS_SET_FAILED;\n\n\tif (new_value & field_config->enable_bit) {\n\t\t \n\t\tint int_type = xen_pcibk_get_interrupt_type(dev);\n\n\t\tif (int_type == INTERRUPT_TYPE_NONE ||\n\t\t    int_type == INTERRUPT_TYPE_INTX ||\n\t\t    int_type == field_config->int_type)\n\t\t\tgoto write;\n\t\treturn PCIBIOS_SET_FAILED;\n\t}\n\nwrite:\n\treturn pci_write_config_word(dev, offset, new_value);\n}\n\nstatic const struct config_field caplist_msix[] = {\n\t{\n\t\t.offset    = PCI_MSIX_FLAGS,\n\t\t.size      = 2,\n\t\t.init      = msix_field_init,\n\t\t.u.w.read  = xen_pcibk_read_config_word,\n\t\t.u.w.write = msi_msix_flags_write,\n\t},\n\t{}\n};\n\nstatic const struct config_field caplist_msi[] = {\n\t{\n\t\t.offset    = PCI_MSI_FLAGS,\n\t\t.size      = 2,\n\t\t.init      = msi_field_init,\n\t\t.u.w.read  = xen_pcibk_read_config_word,\n\t\t.u.w.write = msi_msix_flags_write,\n\t},\n\t{}\n};\n\nstatic struct xen_pcibk_config_capability xen_pcibk_config_capability_pm = {\n\t.capability = PCI_CAP_ID_PM,\n\t.fields = caplist_pm,\n};\nstatic struct xen_pcibk_config_capability xen_pcibk_config_capability_vpd = {\n\t.capability = PCI_CAP_ID_VPD,\n\t.fields = caplist_vpd,\n};\nstatic struct xen_pcibk_config_capability xen_pcibk_config_capability_msi = {\n\t.capability = PCI_CAP_ID_MSI,\n\t.fields = caplist_msi,\n};\nstatic struct xen_pcibk_config_capability xen_pcibk_config_capability_msix = {\n\t.capability = PCI_CAP_ID_MSIX,\n\t.fields = caplist_msix,\n};\n\nint xen_pcibk_config_capability_init(void)\n{\n\tregister_capability(&xen_pcibk_config_capability_vpd);\n\tregister_capability(&xen_pcibk_config_capability_pm);\n\tregister_capability(&xen_pcibk_config_capability_msi);\n\tregister_capability(&xen_pcibk_config_capability_msix);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}