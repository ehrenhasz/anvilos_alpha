{
  "module_name": "passthrough.c",
  "hash_id": "e8dd363077f1efa85e48bfdcbbd7331b69a231412c22e9343d7c824424a8a791",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-pciback/passthrough.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include \"pciback.h\"\n\nstruct passthrough_dev_data {\n\t \n\tstruct list_head dev_list;\n\tstruct mutex lock;\n};\n\nstatic struct pci_dev *__xen_pcibk_get_pci_dev(struct xen_pcibk_device *pdev,\n\t\t\t\t\t       unsigned int domain,\n\t\t\t\t\t       unsigned int bus,\n\t\t\t\t\t       unsigned int devfn)\n{\n\tstruct passthrough_dev_data *dev_data = pdev->pci_dev_data;\n\tstruct pci_dev_entry *dev_entry;\n\tstruct pci_dev *dev = NULL;\n\n\tmutex_lock(&dev_data->lock);\n\n\tlist_for_each_entry(dev_entry, &dev_data->dev_list, list) {\n\t\tif (domain == (unsigned int)pci_domain_nr(dev_entry->dev->bus)\n\t\t    && bus == (unsigned int)dev_entry->dev->bus->number\n\t\t    && devfn == dev_entry->dev->devfn) {\n\t\t\tdev = dev_entry->dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&dev_data->lock);\n\n\treturn dev;\n}\n\nstatic int __xen_pcibk_add_pci_dev(struct xen_pcibk_device *pdev,\n\t\t\t\t   struct pci_dev *dev,\n\t\t\t\t   int devid, publish_pci_dev_cb publish_cb)\n{\n\tstruct passthrough_dev_data *dev_data = pdev->pci_dev_data;\n\tstruct pci_dev_entry *dev_entry;\n\tunsigned int domain, bus, devfn;\n\tint err;\n\n\tdev_entry = kmalloc(sizeof(*dev_entry), GFP_KERNEL);\n\tif (!dev_entry)\n\t\treturn -ENOMEM;\n\tdev_entry->dev = dev;\n\n\tmutex_lock(&dev_data->lock);\n\tlist_add_tail(&dev_entry->list, &dev_data->dev_list);\n\tmutex_unlock(&dev_data->lock);\n\n\t \n\tdomain = (unsigned int)pci_domain_nr(dev->bus);\n\tbus = (unsigned int)dev->bus->number;\n\tdevfn = dev->devfn;\n\terr = publish_cb(pdev, domain, bus, devfn, devid);\n\n\treturn err;\n}\n\nstatic void __xen_pcibk_release_pci_dev(struct xen_pcibk_device *pdev,\n\t\t\t\t\tstruct pci_dev *dev, bool lock)\n{\n\tstruct passthrough_dev_data *dev_data = pdev->pci_dev_data;\n\tstruct pci_dev_entry *dev_entry, *t;\n\tstruct pci_dev *found_dev = NULL;\n\n\tmutex_lock(&dev_data->lock);\n\n\tlist_for_each_entry_safe(dev_entry, t, &dev_data->dev_list, list) {\n\t\tif (dev_entry->dev == dev) {\n\t\t\tlist_del(&dev_entry->list);\n\t\t\tfound_dev = dev_entry->dev;\n\t\t\tkfree(dev_entry);\n\t\t}\n\t}\n\n\tmutex_unlock(&dev_data->lock);\n\n\tif (found_dev) {\n\t\tif (lock)\n\t\t\tdevice_lock(&found_dev->dev);\n\t\tpcistub_put_pci_dev(found_dev);\n\t\tif (lock)\n\t\t\tdevice_unlock(&found_dev->dev);\n\t}\n}\n\nstatic int __xen_pcibk_init_devices(struct xen_pcibk_device *pdev)\n{\n\tstruct passthrough_dev_data *dev_data;\n\n\tdev_data = kmalloc(sizeof(*dev_data), GFP_KERNEL);\n\tif (!dev_data)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev_data->lock);\n\n\tINIT_LIST_HEAD(&dev_data->dev_list);\n\n\tpdev->pci_dev_data = dev_data;\n\n\treturn 0;\n}\n\nstatic int __xen_pcibk_publish_pci_roots(struct xen_pcibk_device *pdev,\n\t\t\t\t\t publish_pci_root_cb publish_root_cb)\n{\n\tint err = 0;\n\tstruct passthrough_dev_data *dev_data = pdev->pci_dev_data;\n\tstruct pci_dev_entry *dev_entry, *e;\n\tstruct pci_dev *dev;\n\tint found;\n\tunsigned int domain, bus;\n\n\tmutex_lock(&dev_data->lock);\n\n\tlist_for_each_entry(dev_entry, &dev_data->dev_list, list) {\n\t\t \n\t\tfound = 0;\n\t\tdev = dev_entry->dev->bus->self;\n\t\tfor (; !found && dev != NULL; dev = dev->bus->self) {\n\t\t\tlist_for_each_entry(e, &dev_data->dev_list, list) {\n\t\t\t\tif (dev == e->dev) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdomain = (unsigned int)pci_domain_nr(dev_entry->dev->bus);\n\t\tbus = (unsigned int)dev_entry->dev->bus->number;\n\n\t\tif (!found) {\n\t\t\terr = publish_root_cb(pdev, domain, bus);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&dev_data->lock);\n\n\treturn err;\n}\n\nstatic void __xen_pcibk_release_devices(struct xen_pcibk_device *pdev)\n{\n\tstruct passthrough_dev_data *dev_data = pdev->pci_dev_data;\n\tstruct pci_dev_entry *dev_entry, *t;\n\n\tlist_for_each_entry_safe(dev_entry, t, &dev_data->dev_list, list) {\n\t\tstruct pci_dev *dev = dev_entry->dev;\n\t\tlist_del(&dev_entry->list);\n\t\tdevice_lock(&dev->dev);\n\t\tpcistub_put_pci_dev(dev);\n\t\tdevice_unlock(&dev->dev);\n\t\tkfree(dev_entry);\n\t}\n\n\tkfree(dev_data);\n\tpdev->pci_dev_data = NULL;\n}\n\nstatic int __xen_pcibk_get_pcifront_dev(struct pci_dev *pcidev,\n\t\t\t\t\tstruct xen_pcibk_device *pdev,\n\t\t\t\t\tunsigned int *domain, unsigned int *bus,\n\t\t\t\t\tunsigned int *devfn)\n{\n\t*domain = pci_domain_nr(pcidev->bus);\n\t*bus = pcidev->bus->number;\n\t*devfn = pcidev->devfn;\n\treturn 1;\n}\n\nconst struct xen_pcibk_backend xen_pcibk_passthrough_backend = {\n\t.name           = \"passthrough\",\n\t.init           = __xen_pcibk_init_devices,\n\t.free\t\t= __xen_pcibk_release_devices,\n\t.find           = __xen_pcibk_get_pcifront_dev,\n\t.publish        = __xen_pcibk_publish_pci_roots,\n\t.release        = __xen_pcibk_release_pci_dev,\n\t.add            = __xen_pcibk_add_pci_dev,\n\t.get            = __xen_pcibk_get_pci_dev,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}