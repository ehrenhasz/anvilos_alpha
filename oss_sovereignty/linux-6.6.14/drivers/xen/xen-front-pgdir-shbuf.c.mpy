{
  "module_name": "xen-front-pgdir-shbuf.c",
  "hash_id": "95ae9db6a51cf9b30831afbe3f8a31abfd06ee7c213f029130872a167cc1d544",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-front-pgdir-shbuf.c",
  "human_readable_source": "\n\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n\n#include <asm/xen/hypervisor.h>\n#include <xen/balloon.h>\n#include <xen/xen.h>\n#include <xen/xenbus.h>\n#include <xen/interface/io/ring.h>\n\n#include <xen/xen-front-pgdir-shbuf.h>\n\n \nstruct xen_page_directory {\n\tgrant_ref_t gref_dir_next_page;\n#define XEN_GREF_LIST_END\t0\n\tgrant_ref_t gref[];  \n};\n\n \nstruct xen_front_pgdir_shbuf_ops {\n\t \n\tvoid (*calc_num_grefs)(struct xen_front_pgdir_shbuf *buf);\n\n\t \n\tvoid (*fill_page_dir)(struct xen_front_pgdir_shbuf *buf);\n\n\t \n\tint (*grant_refs_for_buffer)(struct xen_front_pgdir_shbuf *buf,\n\t\t\t\t     grant_ref_t *priv_gref_head, int gref_idx);\n\n\t \n\tint (*map)(struct xen_front_pgdir_shbuf *buf);\n\n\t \n\tint (*unmap)(struct xen_front_pgdir_shbuf *buf);\n};\n\n \ngrant_ref_t\nxen_front_pgdir_shbuf_get_dir_start(struct xen_front_pgdir_shbuf *buf)\n{\n\tif (!buf->grefs)\n\t\treturn INVALID_GRANT_REF;\n\n\treturn buf->grefs[0];\n}\nEXPORT_SYMBOL_GPL(xen_front_pgdir_shbuf_get_dir_start);\n\n \nint xen_front_pgdir_shbuf_map(struct xen_front_pgdir_shbuf *buf)\n{\n\tif (buf->ops && buf->ops->map)\n\t\treturn buf->ops->map(buf);\n\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xen_front_pgdir_shbuf_map);\n\n \nint xen_front_pgdir_shbuf_unmap(struct xen_front_pgdir_shbuf *buf)\n{\n\tif (buf->ops && buf->ops->unmap)\n\t\treturn buf->ops->unmap(buf);\n\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xen_front_pgdir_shbuf_unmap);\n\n \nvoid xen_front_pgdir_shbuf_free(struct xen_front_pgdir_shbuf *buf)\n{\n\tif (buf->grefs) {\n\t\tint i;\n\n\t\tfor (i = 0; i < buf->num_grefs; i++)\n\t\t\tif (buf->grefs[i] != INVALID_GRANT_REF)\n\t\t\t\tgnttab_end_foreign_access(buf->grefs[i], NULL);\n\t}\n\tkfree(buf->grefs);\n\tkfree(buf->directory);\n}\nEXPORT_SYMBOL_GPL(xen_front_pgdir_shbuf_free);\n\n \n#define XEN_NUM_GREFS_PER_PAGE ((PAGE_SIZE - \\\n\t\t\t\t offsetof(struct xen_page_directory, \\\n\t\t\t\t\t  gref)) / sizeof(grant_ref_t))\n\n \nstatic int get_num_pages_dir(struct xen_front_pgdir_shbuf *buf)\n{\n\treturn DIV_ROUND_UP(buf->num_pages, XEN_NUM_GREFS_PER_PAGE);\n}\n\n \nstatic void backend_calc_num_grefs(struct xen_front_pgdir_shbuf *buf)\n{\n\t \n\tbuf->num_grefs = get_num_pages_dir(buf);\n}\n\n \nstatic void guest_calc_num_grefs(struct xen_front_pgdir_shbuf *buf)\n{\n\t \n\tbuf->num_grefs = get_num_pages_dir(buf) + buf->num_pages;\n}\n\n#define xen_page_to_vaddr(page) \\\n\t((uintptr_t)pfn_to_kaddr(page_to_xen_pfn(page)))\n\n \nstatic int backend_unmap(struct xen_front_pgdir_shbuf *buf)\n{\n\tstruct gnttab_unmap_grant_ref *unmap_ops;\n\tint i, ret;\n\n\tif (!buf->pages || !buf->backend_map_handles || !buf->grefs)\n\t\treturn 0;\n\n\tunmap_ops = kcalloc(buf->num_pages, sizeof(*unmap_ops),\n\t\t\t    GFP_KERNEL);\n\tif (!unmap_ops)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < buf->num_pages; i++) {\n\t\tphys_addr_t addr;\n\n\t\taddr = xen_page_to_vaddr(buf->pages[i]);\n\t\tgnttab_set_unmap_op(&unmap_ops[i], addr, GNTMAP_host_map,\n\t\t\t\t    buf->backend_map_handles[i]);\n\t}\n\n\tret = gnttab_unmap_refs(unmap_ops, NULL, buf->pages,\n\t\t\t\tbuf->num_pages);\n\n\tfor (i = 0; i < buf->num_pages; i++) {\n\t\tif (unlikely(unmap_ops[i].status != GNTST_okay))\n\t\t\tdev_err(&buf->xb_dev->dev,\n\t\t\t\t\"Failed to unmap page %d: %d\\n\",\n\t\t\t\ti, unmap_ops[i].status);\n\t}\n\n\tif (ret)\n\t\tdev_err(&buf->xb_dev->dev,\n\t\t\t\"Failed to unmap grant references, ret %d\", ret);\n\n\tkfree(unmap_ops);\n\tkfree(buf->backend_map_handles);\n\tbuf->backend_map_handles = NULL;\n\treturn ret;\n}\n\n \nstatic int backend_map(struct xen_front_pgdir_shbuf *buf)\n{\n\tstruct gnttab_map_grant_ref *map_ops = NULL;\n\tunsigned char *ptr;\n\tint ret, cur_gref, cur_dir_page, cur_page, grefs_left;\n\n\tmap_ops = kcalloc(buf->num_pages, sizeof(*map_ops), GFP_KERNEL);\n\tif (!map_ops)\n\t\treturn -ENOMEM;\n\n\tbuf->backend_map_handles = kcalloc(buf->num_pages,\n\t\t\t\t\t   sizeof(*buf->backend_map_handles),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!buf->backend_map_handles) {\n\t\tkfree(map_ops);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tptr = buf->directory;\n\tgrefs_left = buf->num_pages;\n\tcur_page = 0;\n\tfor (cur_dir_page = 0; cur_dir_page < buf->num_grefs; cur_dir_page++) {\n\t\tstruct xen_page_directory *page_dir =\n\t\t\t(struct xen_page_directory *)ptr;\n\t\tint to_copy = XEN_NUM_GREFS_PER_PAGE;\n\n\t\tif (to_copy > grefs_left)\n\t\t\tto_copy = grefs_left;\n\n\t\tfor (cur_gref = 0; cur_gref < to_copy; cur_gref++) {\n\t\t\tphys_addr_t addr;\n\n\t\t\taddr = xen_page_to_vaddr(buf->pages[cur_page]);\n\t\t\tgnttab_set_map_op(&map_ops[cur_page], addr,\n\t\t\t\t\t  GNTMAP_host_map,\n\t\t\t\t\t  page_dir->gref[cur_gref],\n\t\t\t\t\t  buf->xb_dev->otherend_id);\n\t\t\tcur_page++;\n\t\t}\n\n\t\tgrefs_left -= to_copy;\n\t\tptr += PAGE_SIZE;\n\t}\n\tret = gnttab_map_refs(map_ops, NULL, buf->pages, buf->num_pages);\n\n\t \n\tfor (cur_page = 0; cur_page < buf->num_pages; cur_page++) {\n\t\tif (likely(map_ops[cur_page].status == GNTST_okay)) {\n\t\t\tbuf->backend_map_handles[cur_page] =\n\t\t\t\tmap_ops[cur_page].handle;\n\t\t} else {\n\t\t\tbuf->backend_map_handles[cur_page] =\n\t\t\t\tINVALID_GRANT_HANDLE;\n\t\t\tif (!ret)\n\t\t\t\tret = -ENXIO;\n\t\t\tdev_err(&buf->xb_dev->dev,\n\t\t\t\t\"Failed to map page %d: %d\\n\",\n\t\t\t\tcur_page, map_ops[cur_page].status);\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tdev_err(&buf->xb_dev->dev,\n\t\t\t\"Failed to map grant references, ret %d\", ret);\n\t\tbackend_unmap(buf);\n\t}\n\n\tkfree(map_ops);\n\treturn ret;\n}\n\n \nstatic void backend_fill_page_dir(struct xen_front_pgdir_shbuf *buf)\n{\n\tstruct xen_page_directory *page_dir;\n\tunsigned char *ptr;\n\tint i, num_pages_dir;\n\n\tptr = buf->directory;\n\tnum_pages_dir = get_num_pages_dir(buf);\n\n\t \n\tfor (i = 0; i < num_pages_dir - 1; i++) {\n\t\tpage_dir = (struct xen_page_directory *)ptr;\n\n\t\tpage_dir->gref_dir_next_page = buf->grefs[i + 1];\n\t\tptr += PAGE_SIZE;\n\t}\n\t \n\tpage_dir = (struct xen_page_directory *)ptr;\n\tpage_dir->gref_dir_next_page = XEN_GREF_LIST_END;\n}\n\n \nstatic void guest_fill_page_dir(struct xen_front_pgdir_shbuf *buf)\n{\n\tunsigned char *ptr;\n\tint cur_gref, grefs_left, to_copy, i, num_pages_dir;\n\n\tptr = buf->directory;\n\tnum_pages_dir = get_num_pages_dir(buf);\n\n\t \n\tcur_gref = num_pages_dir;\n\tgrefs_left = buf->num_pages;\n\tfor (i = 0; i < num_pages_dir; i++) {\n\t\tstruct xen_page_directory *page_dir =\n\t\t\t(struct xen_page_directory *)ptr;\n\n\t\tif (grefs_left <= XEN_NUM_GREFS_PER_PAGE) {\n\t\t\tto_copy = grefs_left;\n\t\t\tpage_dir->gref_dir_next_page = XEN_GREF_LIST_END;\n\t\t} else {\n\t\t\tto_copy = XEN_NUM_GREFS_PER_PAGE;\n\t\t\tpage_dir->gref_dir_next_page = buf->grefs[i + 1];\n\t\t}\n\t\tmemcpy(&page_dir->gref, &buf->grefs[cur_gref],\n\t\t       to_copy * sizeof(grant_ref_t));\n\t\tptr += PAGE_SIZE;\n\t\tgrefs_left -= to_copy;\n\t\tcur_gref += to_copy;\n\t}\n}\n\n \nstatic int guest_grant_refs_for_buffer(struct xen_front_pgdir_shbuf *buf,\n\t\t\t\t       grant_ref_t *priv_gref_head,\n\t\t\t\t       int gref_idx)\n{\n\tint i, cur_ref, otherend_id;\n\n\totherend_id = buf->xb_dev->otherend_id;\n\tfor (i = 0; i < buf->num_pages; i++) {\n\t\tcur_ref = gnttab_claim_grant_reference(priv_gref_head);\n\t\tif (cur_ref < 0)\n\t\t\treturn cur_ref;\n\n\t\tgnttab_grant_foreign_access_ref(cur_ref, otherend_id,\n\t\t\t\t\t\txen_page_to_gfn(buf->pages[i]),\n\t\t\t\t\t\t0);\n\t\tbuf->grefs[gref_idx++] = cur_ref;\n\t}\n\treturn 0;\n}\n\n \nstatic int grant_references(struct xen_front_pgdir_shbuf *buf)\n{\n\tgrant_ref_t priv_gref_head;\n\tint ret, i, j, cur_ref;\n\tint otherend_id, num_pages_dir;\n\n\tret = gnttab_alloc_grant_references(buf->num_grefs, &priv_gref_head);\n\tif (ret < 0) {\n\t\tdev_err(&buf->xb_dev->dev,\n\t\t\t\"Cannot allocate grant references\\n\");\n\t\treturn ret;\n\t}\n\n\totherend_id = buf->xb_dev->otherend_id;\n\tj = 0;\n\tnum_pages_dir = get_num_pages_dir(buf);\n\tfor (i = 0; i < num_pages_dir; i++) {\n\t\tunsigned long frame;\n\n\t\tcur_ref = gnttab_claim_grant_reference(&priv_gref_head);\n\t\tif (cur_ref < 0)\n\t\t\treturn cur_ref;\n\n\t\tframe = xen_page_to_gfn(virt_to_page(buf->directory +\n\t\t\t\t\t\t     PAGE_SIZE * i));\n\t\tgnttab_grant_foreign_access_ref(cur_ref, otherend_id, frame, 0);\n\t\tbuf->grefs[j++] = cur_ref;\n\t}\n\n\tif (buf->ops->grant_refs_for_buffer) {\n\t\tret = buf->ops->grant_refs_for_buffer(buf, &priv_gref_head, j);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tgnttab_free_grant_references(priv_gref_head);\n\treturn 0;\n}\n\n \nstatic int alloc_storage(struct xen_front_pgdir_shbuf *buf)\n{\n\tbuf->grefs = kcalloc(buf->num_grefs, sizeof(*buf->grefs), GFP_KERNEL);\n\tif (!buf->grefs)\n\t\treturn -ENOMEM;\n\n\tbuf->directory = kcalloc(get_num_pages_dir(buf), PAGE_SIZE, GFP_KERNEL);\n\tif (!buf->directory)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic const struct xen_front_pgdir_shbuf_ops backend_ops = {\n\t.calc_num_grefs = backend_calc_num_grefs,\n\t.fill_page_dir = backend_fill_page_dir,\n\t.map = backend_map,\n\t.unmap = backend_unmap\n};\n\n \nstatic const struct xen_front_pgdir_shbuf_ops local_ops = {\n\t.calc_num_grefs = guest_calc_num_grefs,\n\t.fill_page_dir = guest_fill_page_dir,\n\t.grant_refs_for_buffer = guest_grant_refs_for_buffer,\n};\n\n \nint xen_front_pgdir_shbuf_alloc(struct xen_front_pgdir_shbuf_cfg *cfg)\n{\n\tstruct xen_front_pgdir_shbuf *buf = cfg->pgdir;\n\tint ret;\n\n\tif (cfg->be_alloc)\n\t\tbuf->ops = &backend_ops;\n\telse\n\t\tbuf->ops = &local_ops;\n\tbuf->xb_dev = cfg->xb_dev;\n\tbuf->num_pages = cfg->num_pages;\n\tbuf->pages = cfg->pages;\n\n\tbuf->ops->calc_num_grefs(buf);\n\n\tret = alloc_storage(buf);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = grant_references(buf);\n\tif (ret)\n\t\tgoto fail;\n\n\tbuf->ops->fill_page_dir(buf);\n\n\treturn 0;\n\nfail:\n\txen_front_pgdir_shbuf_free(buf);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xen_front_pgdir_shbuf_alloc);\n\nMODULE_DESCRIPTION(\"Xen frontend/backend page directory based \"\n\t\t   \"shared buffer handling\");\nMODULE_AUTHOR(\"Oleksandr Andrushchenko\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}