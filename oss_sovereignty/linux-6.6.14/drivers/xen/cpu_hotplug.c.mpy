{
  "module_name": "cpu_hotplug.c",
  "hash_id": "13f0c607d588158a3c87f223c04289d39d7b4f0220bd5b5dce5945470c68530d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/cpu_hotplug.c",
  "human_readable_source": "\n#define pr_fmt(fmt) \"xen:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/notifier.h>\n\n#include <xen/xen.h>\n#include <xen/xenbus.h>\n\n#include <asm/xen/hypervisor.h>\n#include <asm/cpu.h>\n\nstatic void enable_hotplug_cpu(int cpu)\n{\n\tif (!cpu_present(cpu))\n\t\txen_arch_register_cpu(cpu);\n\n\tset_cpu_present(cpu, true);\n}\n\nstatic void disable_hotplug_cpu(int cpu)\n{\n\tif (!cpu_is_hotpluggable(cpu))\n\t\treturn;\n\tlock_device_hotplug();\n\tif (cpu_online(cpu))\n\t\tdevice_offline(get_cpu_device(cpu));\n\tif (!cpu_online(cpu) && cpu_present(cpu)) {\n\t\txen_arch_unregister_cpu(cpu);\n\t\tset_cpu_present(cpu, false);\n\t}\n\tunlock_device_hotplug();\n}\n\nstatic int vcpu_online(unsigned int cpu)\n{\n\tint err;\n\tchar dir[16], state[16];\n\n\tsprintf(dir, \"cpu/%u\", cpu);\n\terr = xenbus_scanf(XBT_NIL, dir, \"availability\", \"%15s\", state);\n\tif (err != 1) {\n\t\tif (!xen_initial_domain())\n\t\t\tpr_err(\"Unable to read cpu state\\n\");\n\t\treturn err;\n\t}\n\n\tif (strcmp(state, \"online\") == 0)\n\t\treturn 1;\n\telse if (strcmp(state, \"offline\") == 0)\n\t\treturn 0;\n\n\tpr_err(\"unknown state(%s) on CPU%d\\n\", state, cpu);\n\treturn -EINVAL;\n}\nstatic void vcpu_hotplug(unsigned int cpu)\n{\n\tif (cpu >= nr_cpu_ids || !cpu_possible(cpu))\n\t\treturn;\n\n\tswitch (vcpu_online(cpu)) {\n\tcase 1:\n\t\tenable_hotplug_cpu(cpu);\n\t\tbreak;\n\tcase 0:\n\t\tdisable_hotplug_cpu(cpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void handle_vcpu_hotplug_event(struct xenbus_watch *watch,\n\t\t\t\t      const char *path, const char *token)\n{\n\tunsigned int cpu;\n\tchar *cpustr;\n\n\tcpustr = strstr(path, \"cpu/\");\n\tif (cpustr != NULL) {\n\t\tsscanf(cpustr, \"cpu/%u\", &cpu);\n\t\tvcpu_hotplug(cpu);\n\t}\n}\n\nstatic int setup_cpu_watcher(struct notifier_block *notifier,\n\t\t\t      unsigned long event, void *data)\n{\n\tint cpu;\n\tstatic struct xenbus_watch cpu_watch = {\n\t\t.node = \"cpu\",\n\t\t.callback = handle_vcpu_hotplug_event};\n\n\t(void)register_xenbus_watch(&cpu_watch);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (vcpu_online(cpu) == 0)\n\t\t\tdisable_hotplug_cpu(cpu);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int __init setup_vcpu_hotplug_event(void)\n{\n\tstatic struct notifier_block xsn_cpu = {\n\t\t.notifier_call = setup_cpu_watcher };\n\n#ifdef CONFIG_X86\n\tif (!xen_pv_domain() && !xen_pvh_domain())\n#else\n\tif (!xen_domain())\n#endif\n\t\treturn -ENODEV;\n\n\tregister_xenstore_notifier(&xsn_cpu);\n\n\treturn 0;\n}\n\nlate_initcall(setup_vcpu_hotplug_event);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}