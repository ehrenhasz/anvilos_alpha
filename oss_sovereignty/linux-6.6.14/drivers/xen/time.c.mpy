{
  "module_name": "time.c",
  "hash_id": "615e659ef9d97da5db8e66ddaf4164633dd03d7980ad904c528f96594d3fc509",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/time.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/kernel_stat.h>\n#include <linux/math64.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/static_call.h>\n\n#include <asm/paravirt.h>\n#include <asm/xen/hypervisor.h>\n#include <asm/xen/hypercall.h>\n\n#include <xen/events.h>\n#include <xen/features.h>\n#include <xen/interface/xen.h>\n#include <xen/interface/vcpu.h>\n#include <xen/xen-ops.h>\n\n \nstatic DEFINE_PER_CPU(struct vcpu_runstate_info, xen_runstate);\n\nstatic DEFINE_PER_CPU(u64[4], old_runstate_time);\n\n \nstatic u64 get64(const u64 *p)\n{\n\tu64 ret;\n\n\tif (BITS_PER_LONG < 64) {\n\t\tu32 *p32 = (u32 *)p;\n\t\tu32 h, l, h2;\n\n\t\t \n\t\tdo {\n\t\t\th = READ_ONCE(p32[1]);\n\t\t\tl = READ_ONCE(p32[0]);\n\t\t\th2 = READ_ONCE(p32[1]);\n\t\t} while(h2 != h);\n\n\t\tret = (((u64)h) << 32) | l;\n\t} else\n\t\tret = READ_ONCE(*p);\n\n\treturn ret;\n}\n\nstatic void xen_get_runstate_snapshot_cpu_delta(\n\t\t\t      struct vcpu_runstate_info *res, unsigned int cpu)\n{\n\tu64 state_time;\n\tstruct vcpu_runstate_info *state;\n\n\tBUG_ON(preemptible());\n\n\tstate = per_cpu_ptr(&xen_runstate, cpu);\n\n\tdo {\n\t\tstate_time = get64(&state->state_entry_time);\n\t\trmb();\t \n\t\t*res = __READ_ONCE(*state);\n\t\trmb();\t \n\t} while (get64(&state->state_entry_time) != state_time ||\n\t\t (state_time & XEN_RUNSTATE_UPDATE));\n}\n\nstatic void xen_get_runstate_snapshot_cpu(struct vcpu_runstate_info *res,\n\t\t\t\t\t  unsigned int cpu)\n{\n\tint i;\n\n\txen_get_runstate_snapshot_cpu_delta(res, cpu);\n\n\tfor (i = 0; i < 4; i++)\n\t\tres->time[i] += per_cpu(old_runstate_time, cpu)[i];\n}\n\nvoid xen_manage_runstate_time(int action)\n{\n\tstatic struct vcpu_runstate_info *runstate_delta;\n\tstruct vcpu_runstate_info state;\n\tint cpu, i;\n\n\tswitch (action) {\n\tcase -1:  \n\t\tif (unlikely(runstate_delta))\n\t\t\tpr_warn_once(\"%s: memory leak as runstate_delta is not NULL\\n\",\n\t\t\t\t\t__func__);\n\n\t\trunstate_delta = kmalloc_array(num_possible_cpus(),\n\t\t\t\t\tsizeof(*runstate_delta),\n\t\t\t\t\tGFP_ATOMIC);\n\t\tif (unlikely(!runstate_delta)) {\n\t\t\tpr_warn(\"%s: failed to allocate runstate_delta\\n\",\n\t\t\t\t\t__func__);\n\t\t\treturn;\n\t\t}\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\txen_get_runstate_snapshot_cpu_delta(&state, cpu);\n\t\t\tmemcpy(runstate_delta[cpu].time, state.time,\n\t\t\t\t\tsizeof(runstate_delta[cpu].time));\n\t\t}\n\n\t\tbreak;\n\n\tcase 0:  \n\t\tif (unlikely(!runstate_delta)) {\n\t\t\tpr_warn(\"%s: cannot accumulate runstate time as runstate_delta is NULL\\n\",\n\t\t\t\t\t__func__);\n\t\t\treturn;\n\t\t}\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tper_cpu(old_runstate_time, cpu)[i] +=\n\t\t\t\t\trunstate_delta[cpu].time[i];\n\t\t}\n\n\t\tbreak;\n\n\tdefault:  \n\t\tbreak;\n\t}\n\n\tif (action != -1 && runstate_delta) {\n\t\tkfree(runstate_delta);\n\t\trunstate_delta = NULL;\n\t}\n}\n\n \nvoid xen_get_runstate_snapshot(struct vcpu_runstate_info *res)\n{\n\txen_get_runstate_snapshot_cpu(res, smp_processor_id());\n}\n\n \nbool xen_vcpu_stolen(int vcpu)\n{\n\treturn per_cpu(xen_runstate, vcpu).state == RUNSTATE_runnable;\n}\n\nu64 xen_steal_clock(int cpu)\n{\n\tstruct vcpu_runstate_info state;\n\n\txen_get_runstate_snapshot_cpu(&state, cpu);\n\treturn state.time[RUNSTATE_runnable] + state.time[RUNSTATE_offline];\n}\n\nvoid xen_setup_runstate_info(int cpu)\n{\n\tstruct vcpu_register_runstate_memory_area area;\n\n\tarea.addr.v = &per_cpu(xen_runstate, cpu);\n\n\tif (HYPERVISOR_vcpu_op(VCPUOP_register_runstate_memory_area,\n\t\t\t       xen_vcpu_nr(cpu), &area))\n\t\tBUG();\n}\n\nvoid __init xen_time_setup_guest(void)\n{\n\tbool xen_runstate_remote;\n\n\txen_runstate_remote = !HYPERVISOR_vm_assist(VMASST_CMD_enable,\n\t\t\t\t\tVMASST_TYPE_runstate_update_flag);\n\n\tstatic_call_update(pv_steal_clock, xen_steal_clock);\n\n\tstatic_key_slow_inc(&paravirt_steal_enabled);\n\tif (xen_runstate_remote)\n\t\tstatic_key_slow_inc(&paravirt_steal_rq_enabled);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}