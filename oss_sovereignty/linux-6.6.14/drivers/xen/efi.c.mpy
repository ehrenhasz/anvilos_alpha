{
  "module_name": "efi.c",
  "hash_id": "013d2ba49d6b29827f4a5e26b17af19e426c6c7d3983b9137781685dc25f9e1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/efi.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/efi.h>\n#include <linux/init.h>\n#include <linux/string.h>\n\n#include <xen/interface/xen.h>\n#include <xen/interface/platform.h>\n#include <xen/page.h>\n#include <xen/xen.h>\n#include <xen/xen-ops.h>\n\n#include <asm/page.h>\n\n#include <asm/xen/hypercall.h>\n\n#define INIT_EFI_OP(name) \\\n\t{.cmd = XENPF_efi_runtime_call, \\\n\t .u.efi_runtime_call.function = XEN_EFI_##name, \\\n\t .u.efi_runtime_call.misc = 0}\n\n#define efi_data(op)\t(op.u.efi_runtime_call)\n\nstatic efi_status_t xen_efi_get_time(efi_time_t *tm, efi_time_cap_t *tc)\n{\n\tstruct xen_platform_op op = INIT_EFI_OP(get_time);\n\n\tif (HYPERVISOR_platform_op(&op) < 0)\n\t\treturn EFI_UNSUPPORTED;\n\n\tif (tm) {\n\t\tBUILD_BUG_ON(sizeof(*tm) != sizeof(efi_data(op).u.get_time.time));\n\t\tmemcpy(tm, &efi_data(op).u.get_time.time, sizeof(*tm));\n\t}\n\n\tif (tc) {\n\t\ttc->resolution = efi_data(op).u.get_time.resolution;\n\t\ttc->accuracy = efi_data(op).u.get_time.accuracy;\n\t\ttc->sets_to_zero = !!(efi_data(op).misc &\n\t\t\t\t      XEN_EFI_GET_TIME_SET_CLEARS_NS);\n\t}\n\n\treturn efi_data(op).status;\n}\n\nstatic efi_status_t xen_efi_set_time(efi_time_t *tm)\n{\n\tstruct xen_platform_op op = INIT_EFI_OP(set_time);\n\n\tBUILD_BUG_ON(sizeof(*tm) != sizeof(efi_data(op).u.set_time));\n\tmemcpy(&efi_data(op).u.set_time, tm, sizeof(*tm));\n\n\tif (HYPERVISOR_platform_op(&op) < 0)\n\t\treturn EFI_UNSUPPORTED;\n\n\treturn efi_data(op).status;\n}\n\nstatic efi_status_t xen_efi_get_wakeup_time(efi_bool_t *enabled,\n\t\t\t\t\t    efi_bool_t *pending,\n\t\t\t\t\t    efi_time_t *tm)\n{\n\tstruct xen_platform_op op = INIT_EFI_OP(get_wakeup_time);\n\n\tif (HYPERVISOR_platform_op(&op) < 0)\n\t\treturn EFI_UNSUPPORTED;\n\n\tif (tm) {\n\t\tBUILD_BUG_ON(sizeof(*tm) != sizeof(efi_data(op).u.get_wakeup_time));\n\t\tmemcpy(tm, &efi_data(op).u.get_wakeup_time, sizeof(*tm));\n\t}\n\n\tif (enabled)\n\t\t*enabled = !!(efi_data(op).misc & XEN_EFI_GET_WAKEUP_TIME_ENABLED);\n\n\tif (pending)\n\t\t*pending = !!(efi_data(op).misc & XEN_EFI_GET_WAKEUP_TIME_PENDING);\n\n\treturn efi_data(op).status;\n}\n\nstatic efi_status_t xen_efi_set_wakeup_time(efi_bool_t enabled, efi_time_t *tm)\n{\n\tstruct xen_platform_op op = INIT_EFI_OP(set_wakeup_time);\n\n\tBUILD_BUG_ON(sizeof(*tm) != sizeof(efi_data(op).u.set_wakeup_time));\n\tif (enabled)\n\t\tefi_data(op).misc = XEN_EFI_SET_WAKEUP_TIME_ENABLE;\n\tif (tm)\n\t\tmemcpy(&efi_data(op).u.set_wakeup_time, tm, sizeof(*tm));\n\telse\n\t\tefi_data(op).misc |= XEN_EFI_SET_WAKEUP_TIME_ENABLE_ONLY;\n\n\tif (HYPERVISOR_platform_op(&op) < 0)\n\t\treturn EFI_UNSUPPORTED;\n\n\treturn efi_data(op).status;\n}\n\nstatic efi_status_t xen_efi_get_variable(efi_char16_t *name, efi_guid_t *vendor,\n\t\t\t\t\t u32 *attr, unsigned long *data_size,\n\t\t\t\t\t void *data)\n{\n\tstruct xen_platform_op op = INIT_EFI_OP(get_variable);\n\n\tset_xen_guest_handle(efi_data(op).u.get_variable.name, name);\n\tBUILD_BUG_ON(sizeof(*vendor) !=\n\t\t     sizeof(efi_data(op).u.get_variable.vendor_guid));\n\tmemcpy(&efi_data(op).u.get_variable.vendor_guid, vendor, sizeof(*vendor));\n\tefi_data(op).u.get_variable.size = *data_size;\n\tset_xen_guest_handle(efi_data(op).u.get_variable.data, data);\n\n\tif (HYPERVISOR_platform_op(&op) < 0)\n\t\treturn EFI_UNSUPPORTED;\n\n\t*data_size = efi_data(op).u.get_variable.size;\n\tif (attr)\n\t\t*attr = efi_data(op).misc;\n\n\treturn efi_data(op).status;\n}\n\nstatic efi_status_t xen_efi_get_next_variable(unsigned long *name_size,\n\t\t\t\t\t      efi_char16_t *name,\n\t\t\t\t\t      efi_guid_t *vendor)\n{\n\tstruct xen_platform_op op = INIT_EFI_OP(get_next_variable_name);\n\n\tefi_data(op).u.get_next_variable_name.size = *name_size;\n\tset_xen_guest_handle(efi_data(op).u.get_next_variable_name.name, name);\n\tBUILD_BUG_ON(sizeof(*vendor) !=\n\t\t     sizeof(efi_data(op).u.get_next_variable_name.vendor_guid));\n\tmemcpy(&efi_data(op).u.get_next_variable_name.vendor_guid, vendor,\n\t       sizeof(*vendor));\n\n\tif (HYPERVISOR_platform_op(&op) < 0)\n\t\treturn EFI_UNSUPPORTED;\n\n\t*name_size = efi_data(op).u.get_next_variable_name.size;\n\tmemcpy(vendor, &efi_data(op).u.get_next_variable_name.vendor_guid,\n\t       sizeof(*vendor));\n\n\treturn efi_data(op).status;\n}\n\nstatic efi_status_t xen_efi_set_variable(efi_char16_t *name, efi_guid_t *vendor,\n\t\t\t\t\t u32 attr, unsigned long data_size,\n\t\t\t\t\t void *data)\n{\n\tstruct xen_platform_op op = INIT_EFI_OP(set_variable);\n\n\tset_xen_guest_handle(efi_data(op).u.set_variable.name, name);\n\tefi_data(op).misc = attr;\n\tBUILD_BUG_ON(sizeof(*vendor) !=\n\t\t     sizeof(efi_data(op).u.set_variable.vendor_guid));\n\tmemcpy(&efi_data(op).u.set_variable.vendor_guid, vendor, sizeof(*vendor));\n\tefi_data(op).u.set_variable.size = data_size;\n\tset_xen_guest_handle(efi_data(op).u.set_variable.data, data);\n\n\tif (HYPERVISOR_platform_op(&op) < 0)\n\t\treturn EFI_UNSUPPORTED;\n\n\treturn efi_data(op).status;\n}\n\nstatic efi_status_t xen_efi_query_variable_info(u32 attr, u64 *storage_space,\n\t\t\t\t\t\tu64 *remaining_space,\n\t\t\t\t\t\tu64 *max_variable_size)\n{\n\tstruct xen_platform_op op = INIT_EFI_OP(query_variable_info);\n\n\tif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\n\t\treturn EFI_UNSUPPORTED;\n\n\tefi_data(op).u.query_variable_info.attr = attr;\n\n\tif (HYPERVISOR_platform_op(&op) < 0)\n\t\treturn EFI_UNSUPPORTED;\n\n\t*storage_space = efi_data(op).u.query_variable_info.max_store_size;\n\t*remaining_space = efi_data(op).u.query_variable_info.remain_store_size;\n\t*max_variable_size = efi_data(op).u.query_variable_info.max_size;\n\n\treturn efi_data(op).status;\n}\n\nstatic efi_status_t xen_efi_get_next_high_mono_count(u32 *count)\n{\n\tstruct xen_platform_op op = INIT_EFI_OP(get_next_high_monotonic_count);\n\n\tif (HYPERVISOR_platform_op(&op) < 0)\n\t\treturn EFI_UNSUPPORTED;\n\n\t*count = efi_data(op).misc;\n\n\treturn efi_data(op).status;\n}\n\nstatic efi_status_t xen_efi_update_capsule(efi_capsule_header_t **capsules,\n\t\t\t\tunsigned long count, unsigned long sg_list)\n{\n\tstruct xen_platform_op op = INIT_EFI_OP(update_capsule);\n\n\tif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\n\t\treturn EFI_UNSUPPORTED;\n\n\tset_xen_guest_handle(efi_data(op).u.update_capsule.capsule_header_array,\n\t\t\t     capsules);\n\tefi_data(op).u.update_capsule.capsule_count = count;\n\tefi_data(op).u.update_capsule.sg_list = sg_list;\n\n\tif (HYPERVISOR_platform_op(&op) < 0)\n\t\treturn EFI_UNSUPPORTED;\n\n\treturn efi_data(op).status;\n}\n\nstatic efi_status_t xen_efi_query_capsule_caps(efi_capsule_header_t **capsules,\n\t\t\tunsigned long count, u64 *max_size, int *reset_type)\n{\n\tstruct xen_platform_op op = INIT_EFI_OP(query_capsule_capabilities);\n\n\tif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\n\t\treturn EFI_UNSUPPORTED;\n\n\tset_xen_guest_handle(efi_data(op).u.query_capsule_capabilities.capsule_header_array,\n\t\t\t\t\tcapsules);\n\tefi_data(op).u.query_capsule_capabilities.capsule_count = count;\n\n\tif (HYPERVISOR_platform_op(&op) < 0)\n\t\treturn EFI_UNSUPPORTED;\n\n\t*max_size = efi_data(op).u.query_capsule_capabilities.max_capsule_size;\n\t*reset_type = efi_data(op).u.query_capsule_capabilities.reset_type;\n\n\treturn efi_data(op).status;\n}\n\nstatic void xen_efi_reset_system(int reset_type, efi_status_t status,\n\t\t\t\t unsigned long data_size, efi_char16_t *data)\n{\n\tswitch (reset_type) {\n\tcase EFI_RESET_COLD:\n\tcase EFI_RESET_WARM:\n\t\txen_reboot(SHUTDOWN_reboot);\n\t\tbreak;\n\tcase EFI_RESET_SHUTDOWN:\n\t\txen_reboot(SHUTDOWN_poweroff);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n \nvoid __init xen_efi_runtime_setup(void)\n{\n\tefi.get_time\t\t\t= xen_efi_get_time;\n\tefi.set_time\t\t\t= xen_efi_set_time;\n\tefi.get_wakeup_time\t\t= xen_efi_get_wakeup_time;\n\tefi.set_wakeup_time\t\t= xen_efi_set_wakeup_time;\n\tefi.get_variable\t\t= xen_efi_get_variable;\n\tefi.get_next_variable\t\t= xen_efi_get_next_variable;\n\tefi.set_variable\t\t= xen_efi_set_variable;\n\tefi.set_variable_nonblocking\t= xen_efi_set_variable;\n\tefi.query_variable_info\t\t= xen_efi_query_variable_info;\n\tefi.query_variable_info_nonblocking = xen_efi_query_variable_info;\n\tefi.update_capsule\t\t= xen_efi_update_capsule;\n\tefi.query_capsule_caps\t\t= xen_efi_query_capsule_caps;\n\tefi.get_next_high_mono_count\t= xen_efi_get_next_high_mono_count;\n\tefi.reset_system\t\t= xen_efi_reset_system;\n}\n\nint efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)\n{\n\tstatic_assert(XEN_PAGE_SHIFT == EFI_PAGE_SHIFT,\n\t              \"Mismatch between EFI_PAGE_SHIFT and XEN_PAGE_SHIFT\");\n\tstruct xen_platform_op op;\n\tunion xenpf_efi_info *info = &op.u.firmware_info.u.efi_info;\n\tint rc;\n\n\tif (!efi_enabled(EFI_PARAVIRT) || efi_enabled(EFI_MEMMAP))\n\t\treturn __efi_mem_desc_lookup(phys_addr, out_md);\n\tphys_addr &= ~(u64)(EFI_PAGE_SIZE - 1);\n\top = (struct xen_platform_op) {\n\t\t.cmd = XENPF_firmware_info,\n\t\t.u.firmware_info = {\n\t\t\t.type = XEN_FW_EFI_INFO,\n\t\t\t.index = XEN_FW_EFI_MEM_INFO,\n\t\t\t.u.efi_info.mem.addr = phys_addr,\n\t\t\t.u.efi_info.mem.size = U64_MAX - phys_addr,\n\t\t},\n\t};\n\n\trc = HYPERVISOR_platform_op(&op);\n\tif (rc) {\n\t\tpr_warn(\"Failed to lookup header 0x%llx in Xen memory map: error %d\\n\",\n\t\t        phys_addr, rc);\n\t}\n\n\tout_md->phys_addr\t= info->mem.addr;\n\tout_md->num_pages\t= info->mem.size >> EFI_PAGE_SHIFT;\n\tout_md->type    \t= info->mem.type;\n\tout_md->attribute\t= info->mem.attr;\n\n\treturn 0;\n}\n\nbool __init xen_efi_config_table_is_usable(const efi_guid_t *guid,\n                                           unsigned long table)\n{\n\tefi_memory_desc_t md;\n\tint rc;\n\n\tif (!efi_enabled(EFI_PARAVIRT))\n\t\treturn true;\n\n\trc = efi_mem_desc_lookup(table, &md);\n\tif (rc)\n\t\treturn false;\n\n\tswitch (md.type) {\n\tcase EFI_RUNTIME_SERVICES_CODE:\n\tcase EFI_RUNTIME_SERVICES_DATA:\n\tcase EFI_ACPI_RECLAIM_MEMORY:\n\tcase EFI_ACPI_MEMORY_NVS:\n\tcase EFI_RESERVED_TYPE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}