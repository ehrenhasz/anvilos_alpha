{
  "module_name": "pcpu.c",
  "hash_id": "d5b90a779e9e7a8619632c944e71d19124ee877f257f1e9e525a4b726e057963",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/pcpu.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"xen_cpu: \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/cpu.h>\n#include <linux/stat.h>\n#include <linux/capability.h>\n\n#include <xen/xen.h>\n#include <xen/acpi.h>\n#include <xen/xenbus.h>\n#include <xen/events.h>\n#include <xen/interface/platform.h>\n#include <asm/xen/hypervisor.h>\n#include <asm/xen/hypercall.h>\n\n#ifdef CONFIG_ACPI\n#include <acpi/processor.h>\n#endif\n\n \nstruct pcpu {\n\tstruct list_head list;\n\tstruct device dev;\n\tuint32_t cpu_id;\n\tuint32_t acpi_id;\n\tuint32_t flags;\n};\n\nstatic struct bus_type xen_pcpu_subsys = {\n\t.name = \"xen_cpu\",\n\t.dev_name = \"xen_cpu\",\n};\n\nstatic DEFINE_MUTEX(xen_pcpu_lock);\n\nstatic LIST_HEAD(xen_pcpus);\n\nstatic int xen_pcpu_down(uint32_t cpu_id)\n{\n\tstruct xen_platform_op op = {\n\t\t.cmd\t\t\t= XENPF_cpu_offline,\n\t\t.interface_version\t= XENPF_INTERFACE_VERSION,\n\t\t.u.cpu_ol.cpuid\t\t= cpu_id,\n\t};\n\n\treturn HYPERVISOR_platform_op(&op);\n}\n\nstatic int xen_pcpu_up(uint32_t cpu_id)\n{\n\tstruct xen_platform_op op = {\n\t\t.cmd\t\t\t= XENPF_cpu_online,\n\t\t.interface_version\t= XENPF_INTERFACE_VERSION,\n\t\t.u.cpu_ol.cpuid\t\t= cpu_id,\n\t};\n\n\treturn HYPERVISOR_platform_op(&op);\n}\n\nstatic ssize_t online_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct pcpu *cpu = container_of(dev, struct pcpu, dev);\n\n\treturn sprintf(buf, \"%u\\n\", !!(cpu->flags & XEN_PCPU_FLAGS_ONLINE));\n}\n\nstatic ssize_t __ref online_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct pcpu *pcpu = container_of(dev, struct pcpu, dev);\n\tunsigned long long val;\n\tssize_t ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (kstrtoull(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tswitch (val) {\n\tcase 0:\n\t\tret = xen_pcpu_down(pcpu->cpu_id);\n\t\tbreak;\n\tcase 1:\n\t\tret = xen_pcpu_up(pcpu->cpu_id);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret >= 0)\n\t\tret = count;\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(online);\n\nstatic struct attribute *pcpu_dev_attrs[] = {\n\t&dev_attr_online.attr,\n\tNULL\n};\n\nstatic umode_t pcpu_dev_is_visible(struct kobject *kobj,\n\t\t\t\t   struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\t \n\treturn dev->id ? attr->mode : 0;\n}\n\nstatic const struct attribute_group pcpu_dev_group = {\n\t.attrs = pcpu_dev_attrs,\n\t.is_visible = pcpu_dev_is_visible,\n};\n\nstatic const struct attribute_group *pcpu_dev_groups[] = {\n\t&pcpu_dev_group,\n\tNULL\n};\n\nstatic bool xen_pcpu_online(uint32_t flags)\n{\n\treturn !!(flags & XEN_PCPU_FLAGS_ONLINE);\n}\n\nstatic void pcpu_online_status(struct xenpf_pcpuinfo *info,\n\t\t\t       struct pcpu *pcpu)\n{\n\tif (xen_pcpu_online(info->flags) &&\n\t   !xen_pcpu_online(pcpu->flags)) {\n\t\t \n\t\tpcpu->flags |= XEN_PCPU_FLAGS_ONLINE;\n\t\tkobject_uevent(&pcpu->dev.kobj, KOBJ_ONLINE);\n\t} else if (!xen_pcpu_online(info->flags) &&\n\t\t    xen_pcpu_online(pcpu->flags)) {\n\t\t \n\t\tpcpu->flags &= ~XEN_PCPU_FLAGS_ONLINE;\n\t\tkobject_uevent(&pcpu->dev.kobj, KOBJ_OFFLINE);\n\t}\n}\n\nstatic struct pcpu *get_pcpu(uint32_t cpu_id)\n{\n\tstruct pcpu *pcpu;\n\n\tlist_for_each_entry(pcpu, &xen_pcpus, list) {\n\t\tif (pcpu->cpu_id == cpu_id)\n\t\t\treturn pcpu;\n\t}\n\n\treturn NULL;\n}\n\nstatic void pcpu_release(struct device *dev)\n{\n\tstruct pcpu *pcpu = container_of(dev, struct pcpu, dev);\n\n\tlist_del(&pcpu->list);\n\tkfree(pcpu);\n}\n\nstatic void unregister_and_remove_pcpu(struct pcpu *pcpu)\n{\n\tstruct device *dev;\n\n\tif (!pcpu)\n\t\treturn;\n\n\tdev = &pcpu->dev;\n\t \n\tdevice_unregister(dev);\n}\n\nstatic int register_pcpu(struct pcpu *pcpu)\n{\n\tstruct device *dev;\n\tint err = -EINVAL;\n\n\tif (!pcpu)\n\t\treturn err;\n\n\tdev = &pcpu->dev;\n\tdev->bus = &xen_pcpu_subsys;\n\tdev->id = pcpu->cpu_id;\n\tdev->release = pcpu_release;\n\tdev->groups = pcpu_dev_groups;\n\n\terr = device_register(dev);\n\tif (err) {\n\t\tput_device(dev);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct pcpu *create_and_register_pcpu(struct xenpf_pcpuinfo *info)\n{\n\tstruct pcpu *pcpu;\n\tint err;\n\n\tif (info->flags & XEN_PCPU_FLAGS_INVALID)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpcpu = kzalloc(sizeof(struct pcpu), GFP_KERNEL);\n\tif (!pcpu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&pcpu->list);\n\tpcpu->cpu_id = info->xen_cpuid;\n\tpcpu->acpi_id = info->acpi_id;\n\tpcpu->flags = info->flags;\n\n\t \n\tlist_add_tail(&pcpu->list, &xen_pcpus);\n\n\terr = register_pcpu(pcpu);\n\tif (err) {\n\t\tpr_warn(\"Failed to register pcpu%u\\n\", info->xen_cpuid);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn pcpu;\n}\n\n \nstatic int sync_pcpu(uint32_t cpu, uint32_t *max_cpu)\n{\n\tint ret;\n\tstruct pcpu *pcpu = NULL;\n\tstruct xenpf_pcpuinfo *info;\n\tstruct xen_platform_op op = {\n\t\t.cmd                   = XENPF_get_cpuinfo,\n\t\t.interface_version     = XENPF_INTERFACE_VERSION,\n\t\t.u.pcpu_info.xen_cpuid = cpu,\n\t};\n\n\tret = HYPERVISOR_platform_op(&op);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo = &op.u.pcpu_info;\n\tif (max_cpu)\n\t\t*max_cpu = info->max_present;\n\n\tpcpu = get_pcpu(cpu);\n\n\t \n\tif (info->flags & XEN_PCPU_FLAGS_INVALID) {\n\t\tunregister_and_remove_pcpu(pcpu);\n\t\treturn 0;\n\t}\n\n\tif (!pcpu) {\n\t\tpcpu = create_and_register_pcpu(info);\n\t\tif (IS_ERR_OR_NULL(pcpu))\n\t\t\treturn -ENODEV;\n\t} else\n\t\tpcpu_online_status(info, pcpu);\n\n\treturn 0;\n}\n\n \nstatic int xen_sync_pcpus(void)\n{\n\t \n\tuint32_t cpu = 0, max_cpu = 0;\n\tint err = 0;\n\tstruct pcpu *pcpu, *tmp;\n\n\tmutex_lock(&xen_pcpu_lock);\n\n\twhile (!err && (cpu <= max_cpu)) {\n\t\terr = sync_pcpu(cpu, &max_cpu);\n\t\tcpu++;\n\t}\n\n\tif (err)\n\t\tlist_for_each_entry_safe(pcpu, tmp, &xen_pcpus, list)\n\t\t\tunregister_and_remove_pcpu(pcpu);\n\n\tmutex_unlock(&xen_pcpu_lock);\n\n\treturn err;\n}\n\nstatic void xen_pcpu_work_fn(struct work_struct *work)\n{\n\txen_sync_pcpus();\n}\nstatic DECLARE_WORK(xen_pcpu_work, xen_pcpu_work_fn);\n\nstatic irqreturn_t xen_pcpu_interrupt(int irq, void *dev_id)\n{\n\tschedule_work(&xen_pcpu_work);\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init xen_pcpu_init(void)\n{\n\tint irq, ret;\n\n\tif (!xen_initial_domain())\n\t\treturn -ENODEV;\n\n\tirq = bind_virq_to_irqhandler(VIRQ_PCPU_STATE, 0,\n\t\t\t\t      xen_pcpu_interrupt, 0,\n\t\t\t\t      \"xen-pcpu\", NULL);\n\tif (irq < 0) {\n\t\tpr_warn(\"Failed to bind pcpu virq\\n\");\n\t\treturn irq;\n\t}\n\n\tret = subsys_system_register(&xen_pcpu_subsys, NULL);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register pcpu subsys\\n\");\n\t\tgoto err1;\n\t}\n\n\tret = xen_sync_pcpus();\n\tif (ret) {\n\t\tpr_warn(\"Failed to sync pcpu info\\n\");\n\t\tgoto err2;\n\t}\n\n\treturn 0;\n\nerr2:\n\tbus_unregister(&xen_pcpu_subsys);\nerr1:\n\tunbind_from_irqhandler(irq, NULL);\n\treturn ret;\n}\narch_initcall(xen_pcpu_init);\n\n#ifdef CONFIG_ACPI\nbool __init xen_processor_present(uint32_t acpi_id)\n{\n\tconst struct pcpu *pcpu;\n\tbool online = false;\n\n\tmutex_lock(&xen_pcpu_lock);\n\tlist_for_each_entry(pcpu, &xen_pcpus, list)\n\t\tif (pcpu->acpi_id == acpi_id) {\n\t\t\tonline = pcpu->flags & XEN_PCPU_FLAGS_ONLINE;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&xen_pcpu_lock);\n\n\treturn online;\n}\n\nvoid xen_sanitize_proc_cap_bits(uint32_t *cap)\n{\n\tstruct xen_platform_op op = {\n\t\t.cmd\t\t\t= XENPF_set_processor_pminfo,\n\t\t.u.set_pminfo.id\t= -1,\n\t\t.u.set_pminfo.type\t= XEN_PM_PDC,\n\t};\n\tu32 buf[3] = { ACPI_PDC_REVISION_ID, 1, *cap };\n\tint ret;\n\n\tset_xen_guest_handle(op.u.set_pminfo.pdc, buf);\n\tret = HYPERVISOR_platform_op(&op);\n\tif (ret)\n\t\tpr_err(\"sanitize of _PDC buffer bits from Xen failed: %d\\n\",\n\t\t       ret);\n\telse\n\t\t*cap = buf[2];\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}