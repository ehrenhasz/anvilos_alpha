{
  "module_name": "balloon.c",
  "hash_id": "a7a40835e0b924e9d6e7e727e071af4e3f447e92ba20fc6c3b84f26c8417b882",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/balloon.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"xen:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/errno.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/memblock.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/gfp.h>\n#include <linux/notifier.h>\n#include <linux/memory.h>\n#include <linux/memory_hotplug.h>\n#include <linux/percpu-defs.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/moduleparam.h>\n#include <linux/jiffies.h>\n\n#include <asm/page.h>\n#include <asm/tlb.h>\n\n#include <asm/xen/hypervisor.h>\n#include <asm/xen/hypercall.h>\n\n#include <xen/xen.h>\n#include <xen/interface/xen.h>\n#include <xen/interface/memory.h>\n#include <xen/balloon.h>\n#include <xen/features.h>\n#include <xen/page.h>\n#include <xen/mem-reservation.h>\n\n#undef MODULE_PARAM_PREFIX\n#define MODULE_PARAM_PREFIX \"xen.\"\n\nstatic uint __read_mostly balloon_boot_timeout = 180;\nmodule_param(balloon_boot_timeout, uint, 0444);\n\n#ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\nstatic int xen_hotplug_unpopulated;\n\nstatic struct ctl_table balloon_table[] = {\n\t{\n\t\t.procname\t= \"hotplug_unpopulated\",\n\t\t.data\t\t= &xen_hotplug_unpopulated,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1         = SYSCTL_ZERO,\n\t\t.extra2         = SYSCTL_ONE,\n\t},\n\t{ }\n};\n\n#else\n#define xen_hotplug_unpopulated 0\n#endif\n\n \n#define EXTENT_ORDER (fls(XEN_PFN_PER_PAGE) - 1)\n\n \n\nstatic enum bp_state {\n\tBP_DONE,\n\tBP_WAIT,\n\tBP_EAGAIN,\n\tBP_ECANCELED\n} balloon_state = BP_DONE;\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(balloon_thread_wq);\n\nstatic DEFINE_MUTEX(balloon_mutex);\n\nstruct balloon_stats balloon_stats;\nEXPORT_SYMBOL_GPL(balloon_stats);\n\n \nstatic xen_pfn_t frame_list[PAGE_SIZE / sizeof(xen_pfn_t)];\n\n\n \nstatic LIST_HEAD(ballooned_pages);\nstatic DECLARE_WAIT_QUEUE_HEAD(balloon_wq);\n\n \n#define GFP_BALLOON \\\n\t(GFP_HIGHUSER | __GFP_NOWARN | __GFP_NORETRY | __GFP_NOMEMALLOC)\n\n \nstatic void balloon_append(struct page *page)\n{\n\t__SetPageOffline(page);\n\n\t \n\tif (PageHighMem(page)) {\n\t\tlist_add_tail(&page->lru, &ballooned_pages);\n\t\tballoon_stats.balloon_high++;\n\t} else {\n\t\tlist_add(&page->lru, &ballooned_pages);\n\t\tballoon_stats.balloon_low++;\n\t}\n\twake_up(&balloon_wq);\n}\n\n \nstatic struct page *balloon_retrieve(bool require_lowmem)\n{\n\tstruct page *page;\n\n\tif (list_empty(&ballooned_pages))\n\t\treturn NULL;\n\n\tpage = list_entry(ballooned_pages.next, struct page, lru);\n\tif (require_lowmem && PageHighMem(page))\n\t\treturn NULL;\n\tlist_del(&page->lru);\n\n\tif (PageHighMem(page))\n\t\tballoon_stats.balloon_high--;\n\telse\n\t\tballoon_stats.balloon_low--;\n\n\t__ClearPageOffline(page);\n\treturn page;\n}\n\nstatic struct page *balloon_next_page(struct page *page)\n{\n\tstruct list_head *next = page->lru.next;\n\tif (next == &ballooned_pages)\n\t\treturn NULL;\n\treturn list_entry(next, struct page, lru);\n}\n\nstatic void update_schedule(void)\n{\n\tif (balloon_state == BP_WAIT || balloon_state == BP_ECANCELED)\n\t\treturn;\n\n\tif (balloon_state == BP_DONE) {\n\t\tballoon_stats.schedule_delay = 1;\n\t\tballoon_stats.retry_count = 1;\n\t\treturn;\n\t}\n\n\t++balloon_stats.retry_count;\n\n\tif (balloon_stats.max_retry_count != RETRY_UNLIMITED &&\n\t\t\tballoon_stats.retry_count > balloon_stats.max_retry_count) {\n\t\tballoon_stats.schedule_delay = 1;\n\t\tballoon_stats.retry_count = 1;\n\t\tballoon_state = BP_ECANCELED;\n\t\treturn;\n\t}\n\n\tballoon_stats.schedule_delay <<= 1;\n\n\tif (balloon_stats.schedule_delay > balloon_stats.max_schedule_delay)\n\t\tballoon_stats.schedule_delay = balloon_stats.max_schedule_delay;\n\n\tballoon_state = BP_EAGAIN;\n}\n\n#ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\nstatic void release_memory_resource(struct resource *resource)\n{\n\tif (!resource)\n\t\treturn;\n\n\t \n\trelease_resource(resource);\n\tkfree(resource);\n}\n\nstatic struct resource *additional_memory_resource(phys_addr_t size)\n{\n\tstruct resource *res;\n\tint ret;\n\n\tres = kzalloc(sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn NULL;\n\n\tres->name = \"System RAM\";\n\tres->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\n\tret = allocate_resource(&iomem_resource, res,\n\t\t\t\tsize, 0, -1,\n\t\t\t\tPAGES_PER_SECTION * PAGE_SIZE, NULL, NULL);\n\tif (ret < 0) {\n\t\tpr_err(\"Cannot allocate new System RAM resource\\n\");\n\t\tkfree(res);\n\t\treturn NULL;\n\t}\n\n\treturn res;\n}\n\nstatic enum bp_state reserve_additional_memory(void)\n{\n\tlong credit;\n\tstruct resource *resource;\n\tint nid, rc;\n\tunsigned long balloon_hotplug;\n\n\tcredit = balloon_stats.target_pages + balloon_stats.target_unpopulated\n\t\t- balloon_stats.total_pages;\n\n\t \n\tif (credit <= 0)\n\t\treturn BP_WAIT;\n\n\tballoon_hotplug = round_up(credit, PAGES_PER_SECTION);\n\n\tresource = additional_memory_resource(balloon_hotplug * PAGE_SIZE);\n\tif (!resource)\n\t\tgoto err;\n\n\tnid = memory_add_physaddr_to_nid(resource->start);\n\n#ifdef CONFIG_XEN_HAVE_PVMMU\n\t \n\tBUILD_BUG_ON(XEN_PAGE_SIZE != PAGE_SIZE);\n\n          \n\tif (!xen_feature(XENFEAT_auto_translated_physmap)) {\n\t\tunsigned long pfn, i;\n\n\t\tpfn = PFN_DOWN(resource->start);\n\t\tfor (i = 0; i < balloon_hotplug; i++) {\n\t\t\tif (!set_phys_to_machine(pfn + i, INVALID_P2M_ENTRY)) {\n\t\t\t\tpr_warn(\"set_phys_to_machine() failed, no memory added\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n                }\n\t}\n#endif\n\n\t \n\tmutex_unlock(&balloon_mutex);\n\t \n\tlock_device_hotplug();\n\trc = add_memory_resource(nid, resource, MHP_MERGE_RESOURCE);\n\tunlock_device_hotplug();\n\tmutex_lock(&balloon_mutex);\n\n\tif (rc) {\n\t\tpr_warn(\"Cannot add additional memory (%i)\\n\", rc);\n\t\tgoto err;\n\t}\n\n\tballoon_stats.total_pages += balloon_hotplug;\n\n\treturn BP_WAIT;\n  err:\n\trelease_memory_resource(resource);\n\treturn BP_ECANCELED;\n}\n\nstatic void xen_online_page(struct page *page, unsigned int order)\n{\n\tunsigned long i, size = (1 << order);\n\tunsigned long start_pfn = page_to_pfn(page);\n\tstruct page *p;\n\n\tpr_debug(\"Online %lu pages starting at pfn 0x%lx\\n\", size, start_pfn);\n\tmutex_lock(&balloon_mutex);\n\tfor (i = 0; i < size; i++) {\n\t\tp = pfn_to_page(start_pfn + i);\n\t\tballoon_append(p);\n\t}\n\tmutex_unlock(&balloon_mutex);\n}\n\nstatic int xen_memory_notifier(struct notifier_block *nb, unsigned long val, void *v)\n{\n\tif (val == MEM_ONLINE)\n\t\twake_up(&balloon_thread_wq);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block xen_memory_nb = {\n\t.notifier_call = xen_memory_notifier,\n\t.priority = 0\n};\n#else\nstatic enum bp_state reserve_additional_memory(void)\n{\n\tballoon_stats.target_pages = balloon_stats.current_pages +\n\t\t\t\t     balloon_stats.target_unpopulated;\n\treturn BP_ECANCELED;\n}\n#endif  \n\nstatic long current_credit(void)\n{\n\treturn balloon_stats.target_pages - balloon_stats.current_pages;\n}\n\nstatic bool balloon_is_inflated(void)\n{\n\treturn balloon_stats.balloon_low || balloon_stats.balloon_high;\n}\n\nstatic enum bp_state increase_reservation(unsigned long nr_pages)\n{\n\tint rc;\n\tunsigned long i;\n\tstruct page   *page;\n\n\tif (nr_pages > ARRAY_SIZE(frame_list))\n\t\tnr_pages = ARRAY_SIZE(frame_list);\n\n\tpage = list_first_entry_or_null(&ballooned_pages, struct page, lru);\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (!page) {\n\t\t\tnr_pages = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tframe_list[i] = page_to_xen_pfn(page);\n\t\tpage = balloon_next_page(page);\n\t}\n\n\trc = xenmem_reservation_increase(nr_pages, frame_list);\n\tif (rc <= 0)\n\t\treturn BP_EAGAIN;\n\n\tfor (i = 0; i < rc; i++) {\n\t\tpage = balloon_retrieve(false);\n\t\tBUG_ON(page == NULL);\n\n\t\txenmem_reservation_va_mapping_update(1, &page, &frame_list[i]);\n\n\t\t \n\t\tfree_reserved_page(page);\n\t}\n\n\tballoon_stats.current_pages += rc;\n\n\treturn BP_DONE;\n}\n\nstatic enum bp_state decrease_reservation(unsigned long nr_pages, gfp_t gfp)\n{\n\tenum bp_state state = BP_DONE;\n\tunsigned long i;\n\tstruct page *page, *tmp;\n\tint ret;\n\tLIST_HEAD(pages);\n\n\tif (nr_pages > ARRAY_SIZE(frame_list))\n\t\tnr_pages = ARRAY_SIZE(frame_list);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_page(gfp);\n\t\tif (page == NULL) {\n\t\t\tnr_pages = i;\n\t\t\tstate = BP_EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tadjust_managed_page_count(page, -1);\n\t\txenmem_reservation_scrub_page(page);\n\t\tlist_add(&page->lru, &pages);\n\t}\n\n\t \n\tkmap_flush_unused();\n\n\t \n\ti = 0;\n\tlist_for_each_entry_safe(page, tmp, &pages, lru) {\n\t\tframe_list[i++] = xen_page_to_gfn(page);\n\n\t\txenmem_reservation_va_mapping_reset(1, &page);\n\n\t\tlist_del(&page->lru);\n\n\t\tballoon_append(page);\n\t}\n\n\tflush_tlb_all();\n\n\tret = xenmem_reservation_decrease(nr_pages, frame_list);\n\tBUG_ON(ret != nr_pages);\n\n\tballoon_stats.current_pages -= nr_pages;\n\n\treturn state;\n}\n\n \nstatic bool balloon_thread_cond(long credit)\n{\n\tif (balloon_state == BP_DONE)\n\t\tcredit = 0;\n\n\treturn current_credit() != credit || kthread_should_stop();\n}\n\n \nstatic int balloon_thread(void *unused)\n{\n\tlong credit;\n\tunsigned long timeout;\n\n\tset_freezable();\n\tfor (;;) {\n\t\tswitch (balloon_state) {\n\t\tcase BP_DONE:\n\t\tcase BP_ECANCELED:\n\t\t\ttimeout = 3600 * HZ;\n\t\t\tbreak;\n\t\tcase BP_EAGAIN:\n\t\t\ttimeout = balloon_stats.schedule_delay * HZ;\n\t\t\tbreak;\n\t\tcase BP_WAIT:\n\t\t\ttimeout = HZ;\n\t\t\tbreak;\n\t\t}\n\n\t\tcredit = current_credit();\n\n\t\twait_event_freezable_timeout(balloon_thread_wq,\n\t\t\tballoon_thread_cond(credit), timeout);\n\n\t\tif (kthread_should_stop())\n\t\t\treturn 0;\n\n\t\tmutex_lock(&balloon_mutex);\n\n\t\tcredit = current_credit();\n\n\t\tif (credit > 0) {\n\t\t\tif (balloon_is_inflated())\n\t\t\t\tballoon_state = increase_reservation(credit);\n\t\t\telse\n\t\t\t\tballoon_state = reserve_additional_memory();\n\t\t}\n\n\t\tif (credit < 0) {\n\t\t\tlong n_pages;\n\n\t\t\tn_pages = min(-credit, si_mem_available());\n\t\t\tballoon_state = decrease_reservation(n_pages,\n\t\t\t\t\t\t\t     GFP_BALLOON);\n\t\t\tif (balloon_state == BP_DONE && n_pages != -credit &&\n\t\t\t    n_pages < totalreserve_pages)\n\t\t\t\tballoon_state = BP_EAGAIN;\n\t\t}\n\n\t\tupdate_schedule();\n\n\t\tmutex_unlock(&balloon_mutex);\n\n\t\tcond_resched();\n\t}\n}\n\n \nvoid balloon_set_new_target(unsigned long target)\n{\n\t \n\tballoon_stats.target_pages = target;\n\twake_up(&balloon_thread_wq);\n}\nEXPORT_SYMBOL_GPL(balloon_set_new_target);\n\nstatic int add_ballooned_pages(unsigned int nr_pages)\n{\n\tenum bp_state st;\n\n\tif (xen_hotplug_unpopulated) {\n\t\tst = reserve_additional_memory();\n\t\tif (st != BP_ECANCELED) {\n\t\t\tint rc;\n\n\t\t\tmutex_unlock(&balloon_mutex);\n\t\t\trc = wait_event_interruptible(balloon_wq,\n\t\t\t\t   !list_empty(&ballooned_pages));\n\t\t\tmutex_lock(&balloon_mutex);\n\t\t\treturn rc ? -ENOMEM : 0;\n\t\t}\n\t}\n\n\tif (si_mem_available() < nr_pages)\n\t\treturn -ENOMEM;\n\n\tst = decrease_reservation(nr_pages, GFP_USER);\n\tif (st != BP_DONE)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nint xen_alloc_ballooned_pages(unsigned int nr_pages, struct page **pages)\n{\n\tunsigned int pgno = 0;\n\tstruct page *page;\n\tint ret;\n\n\tmutex_lock(&balloon_mutex);\n\n\tballoon_stats.target_unpopulated += nr_pages;\n\n\twhile (pgno < nr_pages) {\n\t\tpage = balloon_retrieve(true);\n\t\tif (page) {\n\t\t\tpages[pgno++] = page;\n#ifdef CONFIG_XEN_HAVE_PVMMU\n\t\t\t \n\t\t\tBUILD_BUG_ON(XEN_PAGE_SIZE != PAGE_SIZE);\n\n\t\t\tif (!xen_feature(XENFEAT_auto_translated_physmap)) {\n\t\t\t\tret = xen_alloc_p2m_entry(page_to_pfn(page));\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_undo;\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tret = add_ballooned_pages(nr_pages - pgno);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_undo;\n\t\t}\n\t}\n\tmutex_unlock(&balloon_mutex);\n\treturn 0;\n out_undo:\n\tmutex_unlock(&balloon_mutex);\n\txen_free_ballooned_pages(pgno, pages);\n\t \n\tballoon_stats.target_unpopulated -= nr_pages - pgno;\n\treturn ret;\n}\nEXPORT_SYMBOL(xen_alloc_ballooned_pages);\n\n \nvoid xen_free_ballooned_pages(unsigned int nr_pages, struct page **pages)\n{\n\tunsigned int i;\n\n\tmutex_lock(&balloon_mutex);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (pages[i])\n\t\t\tballoon_append(pages[i]);\n\t}\n\n\tballoon_stats.target_unpopulated -= nr_pages;\n\n\t \n\tif (current_credit())\n\t\twake_up(&balloon_thread_wq);\n\n\tmutex_unlock(&balloon_mutex);\n}\nEXPORT_SYMBOL(xen_free_ballooned_pages);\n\nstatic void __init balloon_add_regions(void)\n{\n#if defined(CONFIG_XEN_PV)\n\tunsigned long start_pfn, pages;\n\tunsigned long pfn, extra_pfn_end;\n\tunsigned int i;\n\n\tfor (i = 0; i < XEN_EXTRA_MEM_MAX_REGIONS; i++) {\n\t\tpages = xen_extra_mem[i].n_pfns;\n\t\tif (!pages)\n\t\t\tcontinue;\n\n\t\tstart_pfn = xen_extra_mem[i].start_pfn;\n\n\t\t \n\t\textra_pfn_end = min(max_pfn, start_pfn + pages);\n\n\t\tfor (pfn = start_pfn; pfn < extra_pfn_end; pfn++)\n\t\t\tballoon_append(pfn_to_page(pfn));\n\n\t\tballoon_stats.total_pages += extra_pfn_end - start_pfn;\n\t}\n#endif\n}\n\nstatic int __init balloon_init(void)\n{\n\tstruct task_struct *task;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tpr_info(\"Initialising balloon driver\\n\");\n\n#ifdef CONFIG_XEN_PV\n\tballoon_stats.current_pages = xen_pv_domain()\n\t\t? min(xen_start_info->nr_pages - xen_released_pages, max_pfn)\n\t\t: get_num_physpages();\n#else\n\tballoon_stats.current_pages = get_num_physpages();\n#endif\n\tballoon_stats.target_pages  = balloon_stats.current_pages;\n\tballoon_stats.balloon_low   = 0;\n\tballoon_stats.balloon_high  = 0;\n\tballoon_stats.total_pages   = balloon_stats.current_pages;\n\n\tballoon_stats.schedule_delay = 1;\n\tballoon_stats.max_schedule_delay = 32;\n\tballoon_stats.retry_count = 1;\n\tballoon_stats.max_retry_count = 4;\n\n#ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\n\tset_online_page_callback(&xen_online_page);\n\tregister_memory_notifier(&xen_memory_nb);\n\tregister_sysctl_init(\"xen/balloon\", balloon_table);\n#endif\n\n\tballoon_add_regions();\n\n\ttask = kthread_run(balloon_thread, NULL, \"xen-balloon\");\n\tif (IS_ERR(task)) {\n\t\tpr_err(\"xen-balloon thread could not be started, ballooning will not work!\\n\");\n\t\treturn PTR_ERR(task);\n\t}\n\n\t \n\txen_balloon_init();\n\n\treturn 0;\n}\nsubsys_initcall(balloon_init);\n\nstatic int __init balloon_wait_finish(void)\n{\n\tlong credit, last_credit = 0;\n\tunsigned long last_changed = 0;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\t \n\tif (xen_pv_domain() || !current_credit())\n\t\treturn 0;\n\n\tpr_notice(\"Waiting for initial ballooning down having finished.\\n\");\n\n\twhile ((credit = current_credit()) < 0) {\n\t\tif (credit != last_credit) {\n\t\t\tlast_changed = jiffies;\n\t\t\tlast_credit = credit;\n\t\t}\n\t\tif (balloon_state == BP_ECANCELED) {\n\t\t\tpr_warn_once(\"Initial ballooning failed, %ld pages need to be freed.\\n\",\n\t\t\t\t     -credit);\n\t\t\tif (time_is_before_eq_jiffies(last_changed + HZ * balloon_boot_timeout))\n\t\t\t\tpanic(\"Initial ballooning failed!\\n\");\n\t\t}\n\n\t\tschedule_timeout_interruptible(HZ / 10);\n\t}\n\n\tpr_notice(\"Initial ballooning down finished.\\n\");\n\n\treturn 0;\n}\nlate_initcall_sync(balloon_wait_finish);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}