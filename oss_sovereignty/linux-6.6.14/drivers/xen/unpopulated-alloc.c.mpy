{
  "module_name": "unpopulated-alloc.c",
  "hash_id": "9914ba033c1fd393ecc09b97550efa77cde1d86fa24de8164441095d0a57283f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/unpopulated-alloc.c",
  "human_readable_source": "\n#include <linux/errno.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/memremap.h>\n#include <linux/slab.h>\n\n#include <asm/page.h>\n\n#include <xen/balloon.h>\n#include <xen/page.h>\n#include <xen/xen.h>\n\nstatic DEFINE_MUTEX(list_lock);\nstatic struct page *page_list;\nstatic unsigned int list_count;\n\nstatic struct resource *target_resource;\n\n \nint __weak __init arch_xen_unpopulated_init(struct resource **res)\n{\n\t*res = &iomem_resource;\n\n\treturn 0;\n}\n\nstatic int fill_list(unsigned int nr_pages)\n{\n\tstruct dev_pagemap *pgmap;\n\tstruct resource *res, *tmp_res = NULL;\n\tvoid *vaddr;\n\tunsigned int i, alloc_pages = round_up(nr_pages, PAGES_PER_SECTION);\n\tstruct range mhp_range;\n\tint ret;\n\n\tres = kzalloc(sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\tres->name = \"Xen scratch\";\n\tres->flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\n\tmhp_range = mhp_get_pluggable_range(true);\n\n\tret = allocate_resource(target_resource, res,\n\t\t\t\talloc_pages * PAGE_SIZE, mhp_range.start, mhp_range.end,\n\t\t\t\tPAGES_PER_SECTION * PAGE_SIZE, NULL, NULL);\n\tif (ret < 0) {\n\t\tpr_err(\"Cannot allocate new IOMEM resource\\n\");\n\t\tgoto err_resource;\n\t}\n\n\t \n\tif (target_resource != &iomem_resource) {\n\t\ttmp_res = kzalloc(sizeof(*tmp_res), GFP_KERNEL);\n\t\tif (!tmp_res) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_insert;\n\t\t}\n\n\t\ttmp_res->name = res->name;\n\t\ttmp_res->start = res->start;\n\t\ttmp_res->end = res->end;\n\t\ttmp_res->flags = res->flags;\n\n\t\tret = request_resource(&iomem_resource, tmp_res);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Cannot request resource %pR (%d)\\n\", tmp_res, ret);\n\t\t\tkfree(tmp_res);\n\t\t\tgoto err_insert;\n\t\t}\n\t}\n\n\tpgmap = kzalloc(sizeof(*pgmap), GFP_KERNEL);\n\tif (!pgmap) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pgmap;\n\t}\n\n\tpgmap->type = MEMORY_DEVICE_GENERIC;\n\tpgmap->range = (struct range) {\n\t\t.start = res->start,\n\t\t.end = res->end,\n\t};\n\tpgmap->nr_range = 1;\n\tpgmap->owner = res;\n\n#ifdef CONFIG_XEN_HAVE_PVMMU\n         \n\tif (!xen_feature(XENFEAT_auto_translated_physmap)) {\n\t\txen_pfn_t pfn = PFN_DOWN(res->start);\n\n\t\tfor (i = 0; i < alloc_pages; i++) {\n\t\t\tif (!set_phys_to_machine(pfn + i, INVALID_P2M_ENTRY)) {\n\t\t\t\tpr_warn(\"set_phys_to_machine() failed, no memory added\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_memremap;\n\t\t\t}\n                }\n\t}\n#endif\n\n\tvaddr = memremap_pages(pgmap, NUMA_NO_NODE);\n\tif (IS_ERR(vaddr)) {\n\t\tpr_err(\"Cannot remap memory range\\n\");\n\t\tret = PTR_ERR(vaddr);\n\t\tgoto err_memremap;\n\t}\n\n\tfor (i = 0; i < alloc_pages; i++) {\n\t\tstruct page *pg = virt_to_page(vaddr + PAGE_SIZE * i);\n\n\t\tpg->zone_device_data = page_list;\n\t\tpage_list = pg;\n\t\tlist_count++;\n\t}\n\n\treturn 0;\n\nerr_memremap:\n\tkfree(pgmap);\nerr_pgmap:\n\tif (tmp_res) {\n\t\trelease_resource(tmp_res);\n\t\tkfree(tmp_res);\n\t}\nerr_insert:\n\trelease_resource(res);\nerr_resource:\n\tkfree(res);\n\treturn ret;\n}\n\n \nint xen_alloc_unpopulated_pages(unsigned int nr_pages, struct page **pages)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\t \n\tif (!target_resource)\n\t\treturn xen_alloc_ballooned_pages(nr_pages, pages);\n\n\tmutex_lock(&list_lock);\n\tif (list_count < nr_pages) {\n\t\tret = fill_list(nr_pages - list_count);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *pg = page_list;\n\n\t\tBUG_ON(!pg);\n\t\tpage_list = pg->zone_device_data;\n\t\tlist_count--;\n\t\tpages[i] = pg;\n\n#ifdef CONFIG_XEN_HAVE_PVMMU\n\t\tif (!xen_feature(XENFEAT_auto_translated_physmap)) {\n\t\t\tret = xen_alloc_p2m_entry(page_to_pfn(pg));\n\t\t\tif (ret < 0) {\n\t\t\t\tunsigned int j;\n\n\t\t\t\tfor (j = 0; j <= i; j++) {\n\t\t\t\t\tpages[j]->zone_device_data = page_list;\n\t\t\t\t\tpage_list = pages[j];\n\t\t\t\t\tlist_count++;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\nout:\n\tmutex_unlock(&list_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(xen_alloc_unpopulated_pages);\n\n \nvoid xen_free_unpopulated_pages(unsigned int nr_pages, struct page **pages)\n{\n\tunsigned int i;\n\n\tif (!target_resource) {\n\t\txen_free_ballooned_pages(nr_pages, pages);\n\t\treturn;\n\t}\n\n\tmutex_lock(&list_lock);\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpages[i]->zone_device_data = page_list;\n\t\tpage_list = pages[i];\n\t\tlist_count++;\n\t}\n\tmutex_unlock(&list_lock);\n}\nEXPORT_SYMBOL(xen_free_unpopulated_pages);\n\nstatic int __init unpopulated_init(void)\n{\n\tint ret;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tret = arch_xen_unpopulated_init(&target_resource);\n\tif (ret) {\n\t\tpr_err(\"xen:unpopulated: Cannot initialize target resource\\n\");\n\t\ttarget_resource = NULL;\n\t}\n\n\treturn ret;\n}\nearly_initcall(unpopulated_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}