{
  "module_name": "xen-balloon.c",
  "hash_id": "50ba53b804f77b9d130e59f0532561c6f6fa8710769e30905a005258e9c9c2f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-balloon.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/mm_types.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/memory_hotplug.h>\n\n#include <xen/xen.h>\n#include <xen/interface/xen.h>\n#include <xen/balloon.h>\n#include <xen/xenbus.h>\n#include <xen/features.h>\n#include <xen/page.h>\n#include <xen/mem-reservation.h>\n\n#define PAGES2KB(_p) ((_p)<<(PAGE_SHIFT-10))\n\n#define BALLOON_CLASS_NAME \"xen_memory\"\n\n#ifdef CONFIG_MEMORY_HOTPLUG\nu64 xen_saved_max_mem_size = 0;\n#endif\n\nstatic struct device balloon_dev;\n\nstatic int register_balloon(struct device *dev);\n\n \nstatic void watch_target(struct xenbus_watch *watch,\n\t\t\t const char *path, const char *token)\n{\n\tunsigned long long new_target, static_max;\n\tint err;\n\tstatic bool watch_fired;\n\tstatic long target_diff;\n\n#ifdef CONFIG_MEMORY_HOTPLUG\n\t \n\tif (xen_saved_max_mem_size)\n\t\tmax_mem_size = xen_saved_max_mem_size;\n#endif\n\n\terr = xenbus_scanf(XBT_NIL, \"memory\", \"target\", \"%llu\", &new_target);\n\tif (err != 1) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tnew_target >>= PAGE_SHIFT - 10;\n\n\tif (!watch_fired) {\n\t\twatch_fired = true;\n\n\t\tif ((xenbus_scanf(XBT_NIL, \"memory\", \"static-max\",\n\t\t\t\t  \"%llu\", &static_max) == 1) ||\n\t\t    (xenbus_scanf(XBT_NIL, \"memory\", \"memory_static_max\",\n\t\t\t\t  \"%llu\", &static_max) == 1))\n\t\t\tstatic_max >>= PAGE_SHIFT - 10;\n\t\telse\n\t\t\tstatic_max = balloon_stats.current_pages;\n\n\t\ttarget_diff = (xen_pv_domain() || xen_initial_domain()) ? 0\n\t\t\t\t: static_max - balloon_stats.target_pages;\n\t}\n\n\tballoon_set_new_target(new_target - target_diff);\n}\nstatic struct xenbus_watch target_watch = {\n\t.node = \"memory/target\",\n\t.callback = watch_target,\n};\n\n\nstatic int balloon_init_watcher(struct notifier_block *notifier,\n\t\t\t\tunsigned long event,\n\t\t\t\tvoid *data)\n{\n\tint err;\n\n\terr = register_xenbus_watch(&target_watch);\n\tif (err)\n\t\tpr_err(\"Failed to set balloon watcher\\n\");\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block xenstore_notifier = {\n\t.notifier_call = balloon_init_watcher,\n};\n\nvoid xen_balloon_init(void)\n{\n\tregister_balloon(&balloon_dev);\n\n\tregister_xenstore_notifier(&xenstore_notifier);\n}\nEXPORT_SYMBOL_GPL(xen_balloon_init);\n\n#define BALLOON_SHOW(name, format, args...)\t\t\t\t\\\n\tstatic ssize_t name##_show(struct device *dev,\t\t\t\\\n\t\t\t\t   struct device_attribute *attr,\t\\\n\t\t\t\t   char *buf)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn sprintf(buf, format, ##args);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic DEVICE_ATTR_RO(name)\n\nBALLOON_SHOW(current_kb, \"%lu\\n\", PAGES2KB(balloon_stats.current_pages));\nBALLOON_SHOW(low_kb, \"%lu\\n\", PAGES2KB(balloon_stats.balloon_low));\nBALLOON_SHOW(high_kb, \"%lu\\n\", PAGES2KB(balloon_stats.balloon_high));\n\nstatic DEVICE_ULONG_ATTR(schedule_delay, 0444, balloon_stats.schedule_delay);\nstatic DEVICE_ULONG_ATTR(max_schedule_delay, 0644, balloon_stats.max_schedule_delay);\nstatic DEVICE_ULONG_ATTR(retry_count, 0444, balloon_stats.retry_count);\nstatic DEVICE_ULONG_ATTR(max_retry_count, 0644, balloon_stats.max_retry_count);\nstatic DEVICE_BOOL_ATTR(scrub_pages, 0644, xen_scrub_pages);\n\nstatic ssize_t target_kb_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", PAGES2KB(balloon_stats.target_pages));\n}\n\nstatic ssize_t target_kb_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tchar *endchar;\n\tunsigned long long target_bytes;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\ttarget_bytes = simple_strtoull(buf, &endchar, 0) * 1024;\n\n\tballoon_set_new_target(target_bytes >> PAGE_SHIFT);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(target_kb);\n\nstatic ssize_t target_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\",\n\t\t       (unsigned long long)balloon_stats.target_pages\n\t\t       << PAGE_SHIFT);\n}\n\nstatic ssize_t target_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tchar *endchar;\n\tunsigned long long target_bytes;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\ttarget_bytes = memparse(buf, &endchar);\n\n\tballoon_set_new_target(target_bytes >> PAGE_SHIFT);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(target);\n\nstatic struct attribute *balloon_attrs[] = {\n\t&dev_attr_target_kb.attr,\n\t&dev_attr_target.attr,\n\t&dev_attr_schedule_delay.attr.attr,\n\t&dev_attr_max_schedule_delay.attr.attr,\n\t&dev_attr_retry_count.attr.attr,\n\t&dev_attr_max_retry_count.attr.attr,\n\t&dev_attr_scrub_pages.attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group balloon_group = {\n\t.attrs = balloon_attrs\n};\n\nstatic struct attribute *balloon_info_attrs[] = {\n\t&dev_attr_current_kb.attr,\n\t&dev_attr_low_kb.attr,\n\t&dev_attr_high_kb.attr,\n\tNULL\n};\n\nstatic const struct attribute_group balloon_info_group = {\n\t.name = \"info\",\n\t.attrs = balloon_info_attrs\n};\n\nstatic const struct attribute_group *balloon_groups[] = {\n\t&balloon_group,\n\t&balloon_info_group,\n\tNULL\n};\n\nstatic struct bus_type balloon_subsys = {\n\t.name = BALLOON_CLASS_NAME,\n\t.dev_name = BALLOON_CLASS_NAME,\n};\n\nstatic int register_balloon(struct device *dev)\n{\n\tint error;\n\n\terror = subsys_system_register(&balloon_subsys, NULL);\n\tif (error)\n\t\treturn error;\n\n\tdev->id = 0;\n\tdev->bus = &balloon_subsys;\n\tdev->groups = balloon_groups;\n\n\terror = device_register(dev);\n\tif (error) {\n\t\tbus_unregister(&balloon_subsys);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}