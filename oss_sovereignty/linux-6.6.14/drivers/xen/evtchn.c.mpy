{
  "module_name": "evtchn.c",
  "hash_id": "deb33c49b65460b8e8bf54ef2ecb934f21ed67b5dee3e965400d1c35d4fa6dee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/evtchn.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"xen:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/major.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/poll.h>\n#include <linux/irq.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#include <xen/xen.h>\n#include <xen/events.h>\n#include <xen/evtchn.h>\n#include <xen/xen-ops.h>\n#include <asm/xen/hypervisor.h>\n\nstruct per_user_data {\n\tstruct mutex bind_mutex;  \n\tstruct rb_root evtchns;\n\tunsigned int nr_evtchns;\n\n\t \n\tunsigned int ring_size;\n\tevtchn_port_t *ring;\n\tunsigned int ring_cons, ring_prod, ring_overflow;\n\tstruct mutex ring_cons_mutex;  \n\tspinlock_t ring_prod_lock;  \n\n\t \n\twait_queue_head_t evtchn_wait;\n\tstruct fasync_struct *evtchn_async_queue;\n\tconst char *name;\n\n\tdomid_t restrict_domid;\n};\n\n#define UNRESTRICTED_DOMID ((domid_t)-1)\n\nstruct user_evtchn {\n\tstruct rb_node node;\n\tstruct per_user_data *user;\n\tevtchn_port_t port;\n\tbool enabled;\n};\n\nstatic void evtchn_free_ring(evtchn_port_t *ring)\n{\n\tkvfree(ring);\n}\n\nstatic unsigned int evtchn_ring_offset(struct per_user_data *u,\n\t\t\t\t       unsigned int idx)\n{\n\treturn idx & (u->ring_size - 1);\n}\n\nstatic evtchn_port_t *evtchn_ring_entry(struct per_user_data *u,\n\t\t\t\t\tunsigned int idx)\n{\n\treturn u->ring + evtchn_ring_offset(u, idx);\n}\n\nstatic int add_evtchn(struct per_user_data *u, struct user_evtchn *evtchn)\n{\n\tstruct rb_node **new = &(u->evtchns.rb_node), *parent = NULL;\n\n\tu->nr_evtchns++;\n\n\twhile (*new) {\n\t\tstruct user_evtchn *this;\n\n\t\tthis = rb_entry(*new, struct user_evtchn, node);\n\n\t\tparent = *new;\n\t\tif (this->port < evtchn->port)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (this->port > evtchn->port)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\t \n\trb_link_node(&evtchn->node, parent, new);\n\trb_insert_color(&evtchn->node, &u->evtchns);\n\n\treturn 0;\n}\n\nstatic void del_evtchn(struct per_user_data *u, struct user_evtchn *evtchn)\n{\n\tu->nr_evtchns--;\n\trb_erase(&evtchn->node, &u->evtchns);\n\tkfree(evtchn);\n}\n\nstatic struct user_evtchn *find_evtchn(struct per_user_data *u,\n\t\t\t\t       evtchn_port_t port)\n{\n\tstruct rb_node *node = u->evtchns.rb_node;\n\n\twhile (node) {\n\t\tstruct user_evtchn *evtchn;\n\n\t\tevtchn = rb_entry(node, struct user_evtchn, node);\n\n\t\tif (evtchn->port < port)\n\t\t\tnode = node->rb_left;\n\t\telse if (evtchn->port > port)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn evtchn;\n\t}\n\treturn NULL;\n}\n\nstatic irqreturn_t evtchn_interrupt(int irq, void *data)\n{\n\tstruct user_evtchn *evtchn = data;\n\tstruct per_user_data *u = evtchn->user;\n\tunsigned int prod, cons;\n\n\tWARN(!evtchn->enabled,\n\t     \"Interrupt for port %u, but apparently not enabled; per-user %p\\n\",\n\t     evtchn->port, u);\n\n\tevtchn->enabled = false;\n\n\tspin_lock(&u->ring_prod_lock);\n\n\tprod = READ_ONCE(u->ring_prod);\n\tcons = READ_ONCE(u->ring_cons);\n\n\tif ((prod - cons) < u->ring_size) {\n\t\t*evtchn_ring_entry(u, prod) = evtchn->port;\n\t\tsmp_wmb();  \n\t\tWRITE_ONCE(u->ring_prod, prod + 1);\n\t\tif (cons == prod) {\n\t\t\twake_up_interruptible(&u->evtchn_wait);\n\t\t\tkill_fasync(&u->evtchn_async_queue,\n\t\t\t\t    SIGIO, POLL_IN);\n\t\t}\n\t} else\n\t\tu->ring_overflow = 1;\n\n\tspin_unlock(&u->ring_prod_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t evtchn_read(struct file *file, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tint rc;\n\tunsigned int c, p, bytes1 = 0, bytes2 = 0;\n\tstruct per_user_data *u = file->private_data;\n\n\t \n\tcount &= ~(sizeof(evtchn_port_t)-1);\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tif (count > PAGE_SIZE)\n\t\tcount = PAGE_SIZE;\n\n\tfor (;;) {\n\t\tmutex_lock(&u->ring_cons_mutex);\n\n\t\trc = -EFBIG;\n\t\tif (u->ring_overflow)\n\t\t\tgoto unlock_out;\n\n\t\tc = READ_ONCE(u->ring_cons);\n\t\tp = READ_ONCE(u->ring_prod);\n\t\tif (c != p)\n\t\t\tbreak;\n\n\t\tmutex_unlock(&u->ring_cons_mutex);\n\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\trc = wait_event_interruptible(u->evtchn_wait,\n\t\t\tREAD_ONCE(u->ring_cons) != READ_ONCE(u->ring_prod));\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tif (((c ^ p) & u->ring_size) != 0) {\n\t\tbytes1 = (u->ring_size - evtchn_ring_offset(u, c)) *\n\t\t\tsizeof(evtchn_port_t);\n\t\tbytes2 = evtchn_ring_offset(u, p) * sizeof(evtchn_port_t);\n\t} else {\n\t\tbytes1 = (p - c) * sizeof(evtchn_port_t);\n\t\tbytes2 = 0;\n\t}\n\n\t \n\tif (bytes1 > count) {\n\t\tbytes1 = count;\n\t\tbytes2 = 0;\n\t} else if ((bytes1 + bytes2) > count) {\n\t\tbytes2 = count - bytes1;\n\t}\n\n\trc = -EFAULT;\n\tsmp_rmb();  \n\tif (copy_to_user(buf, evtchn_ring_entry(u, c), bytes1) ||\n\t    ((bytes2 != 0) &&\n\t     copy_to_user(&buf[bytes1], &u->ring[0], bytes2)))\n\t\tgoto unlock_out;\n\n\tWRITE_ONCE(u->ring_cons, c + (bytes1 + bytes2) / sizeof(evtchn_port_t));\n\trc = bytes1 + bytes2;\n\n unlock_out:\n\tmutex_unlock(&u->ring_cons_mutex);\n\treturn rc;\n}\n\nstatic ssize_t evtchn_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tint rc, i;\n\tevtchn_port_t *kbuf = (evtchn_port_t *)__get_free_page(GFP_KERNEL);\n\tstruct per_user_data *u = file->private_data;\n\n\tif (kbuf == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tcount &= ~(sizeof(evtchn_port_t)-1);\n\n\trc = 0;\n\tif (count == 0)\n\t\tgoto out;\n\n\tif (count > PAGE_SIZE)\n\t\tcount = PAGE_SIZE;\n\n\trc = -EFAULT;\n\tif (copy_from_user(kbuf, buf, count) != 0)\n\t\tgoto out;\n\n\tmutex_lock(&u->bind_mutex);\n\n\tfor (i = 0; i < (count/sizeof(evtchn_port_t)); i++) {\n\t\tevtchn_port_t port = kbuf[i];\n\t\tstruct user_evtchn *evtchn;\n\n\t\tevtchn = find_evtchn(u, port);\n\t\tif (evtchn && !evtchn->enabled) {\n\t\t\tevtchn->enabled = true;\n\t\t\txen_irq_lateeoi(irq_from_evtchn(port), 0);\n\t\t}\n\t}\n\n\tmutex_unlock(&u->bind_mutex);\n\n\trc = count;\n\n out:\n\tfree_page((unsigned long)kbuf);\n\treturn rc;\n}\n\nstatic int evtchn_resize_ring(struct per_user_data *u)\n{\n\tunsigned int new_size;\n\tevtchn_port_t *new_ring, *old_ring;\n\n\t \n\tif (u->nr_evtchns <= u->ring_size)\n\t\treturn 0;\n\n\tif (u->ring_size == 0)\n\t\tnew_size = 64;\n\telse\n\t\tnew_size = 2 * u->ring_size;\n\n\tnew_ring = kvmalloc_array(new_size, sizeof(*new_ring), GFP_KERNEL);\n\tif (!new_ring)\n\t\treturn -ENOMEM;\n\n\told_ring = u->ring;\n\n\t \n\tmutex_lock(&u->ring_cons_mutex);\n\tspin_lock_irq(&u->ring_prod_lock);\n\n\t \n\tmemcpy(new_ring, old_ring, u->ring_size * sizeof(*u->ring));\n\tmemcpy(new_ring + u->ring_size, old_ring,\n\t       u->ring_size * sizeof(*u->ring));\n\n\tu->ring = new_ring;\n\tu->ring_size = new_size;\n\n\tspin_unlock_irq(&u->ring_prod_lock);\n\tmutex_unlock(&u->ring_cons_mutex);\n\n\tevtchn_free_ring(old_ring);\n\n\treturn 0;\n}\n\nstatic int evtchn_bind_to_user(struct per_user_data *u, evtchn_port_t port,\n\t\t\t       bool is_static)\n{\n\tstruct user_evtchn *evtchn;\n\tint rc = 0;\n\n\t \n\n\tevtchn = kzalloc(sizeof(*evtchn), GFP_KERNEL);\n\tif (!evtchn)\n\t\treturn -ENOMEM;\n\n\tevtchn->user = u;\n\tevtchn->port = port;\n\tevtchn->enabled = true;  \n\n\trc = add_evtchn(u, evtchn);\n\tif (rc < 0)\n\t\tgoto err;\n\n\trc = evtchn_resize_ring(u);\n\tif (rc < 0)\n\t\tgoto err;\n\n\trc = bind_evtchn_to_irqhandler_lateeoi(port, evtchn_interrupt, 0,\n\t\t\t\t\t       u->name, evtchn);\n\tif (rc < 0)\n\t\tgoto err;\n\n\trc = evtchn_make_refcounted(port, is_static);\n\treturn rc;\n\nerr:\n\t \n\tif (!is_static)\n\t\txen_evtchn_close(port);\n\n\tdel_evtchn(u, evtchn);\n\treturn rc;\n}\n\nstatic void evtchn_unbind_from_user(struct per_user_data *u,\n\t\t\t\t    struct user_evtchn *evtchn)\n{\n\tint irq = irq_from_evtchn(evtchn->port);\n\n\tBUG_ON(irq < 0);\n\n\tunbind_from_irqhandler(irq, evtchn);\n\n\tdel_evtchn(u, evtchn);\n}\n\nstatic long evtchn_ioctl(struct file *file,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tint rc;\n\tstruct per_user_data *u = file->private_data;\n\tvoid __user *uarg = (void __user *) arg;\n\n\t \n\tmutex_lock(&u->bind_mutex);\n\n\tswitch (cmd) {\n\tcase IOCTL_EVTCHN_BIND_VIRQ: {\n\t\tstruct ioctl_evtchn_bind_virq bind;\n\t\tstruct evtchn_bind_virq bind_virq;\n\n\t\trc = -EACCES;\n\t\tif (u->restrict_domid != UNRESTRICTED_DOMID)\n\t\t\tbreak;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&bind, uarg, sizeof(bind)))\n\t\t\tbreak;\n\n\t\tbind_virq.virq = bind.virq;\n\t\tbind_virq.vcpu = xen_vcpu_nr(0);\n\t\trc = HYPERVISOR_event_channel_op(EVTCHNOP_bind_virq,\n\t\t\t\t\t\t &bind_virq);\n\t\tif (rc != 0)\n\t\t\tbreak;\n\n\t\trc = evtchn_bind_to_user(u, bind_virq.port, false);\n\t\tif (rc == 0)\n\t\t\trc = bind_virq.port;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_EVTCHN_BIND_INTERDOMAIN: {\n\t\tstruct ioctl_evtchn_bind_interdomain bind;\n\t\tstruct evtchn_bind_interdomain bind_interdomain;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&bind, uarg, sizeof(bind)))\n\t\t\tbreak;\n\n\t\trc = -EACCES;\n\t\tif (u->restrict_domid != UNRESTRICTED_DOMID &&\n\t\t    u->restrict_domid != bind.remote_domain)\n\t\t\tbreak;\n\n\t\tbind_interdomain.remote_dom  = bind.remote_domain;\n\t\tbind_interdomain.remote_port = bind.remote_port;\n\t\trc = HYPERVISOR_event_channel_op(EVTCHNOP_bind_interdomain,\n\t\t\t\t\t\t &bind_interdomain);\n\t\tif (rc != 0)\n\t\t\tbreak;\n\n\t\trc = evtchn_bind_to_user(u, bind_interdomain.local_port, false);\n\t\tif (rc == 0)\n\t\t\trc = bind_interdomain.local_port;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_EVTCHN_BIND_UNBOUND_PORT: {\n\t\tstruct ioctl_evtchn_bind_unbound_port bind;\n\t\tstruct evtchn_alloc_unbound alloc_unbound;\n\n\t\trc = -EACCES;\n\t\tif (u->restrict_domid != UNRESTRICTED_DOMID)\n\t\t\tbreak;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&bind, uarg, sizeof(bind)))\n\t\t\tbreak;\n\n\t\talloc_unbound.dom        = DOMID_SELF;\n\t\talloc_unbound.remote_dom = bind.remote_domain;\n\t\trc = HYPERVISOR_event_channel_op(EVTCHNOP_alloc_unbound,\n\t\t\t\t\t\t &alloc_unbound);\n\t\tif (rc != 0)\n\t\t\tbreak;\n\n\t\trc = evtchn_bind_to_user(u, alloc_unbound.port, false);\n\t\tif (rc == 0)\n\t\t\trc = alloc_unbound.port;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_EVTCHN_UNBIND: {\n\t\tstruct ioctl_evtchn_unbind unbind;\n\t\tstruct user_evtchn *evtchn;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&unbind, uarg, sizeof(unbind)))\n\t\t\tbreak;\n\n\t\trc = -EINVAL;\n\t\tif (unbind.port >= xen_evtchn_nr_channels())\n\t\t\tbreak;\n\n\t\trc = -ENOTCONN;\n\t\tevtchn = find_evtchn(u, unbind.port);\n\t\tif (!evtchn)\n\t\t\tbreak;\n\n\t\tdisable_irq(irq_from_evtchn(unbind.port));\n\t\tevtchn_unbind_from_user(u, evtchn);\n\t\trc = 0;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_EVTCHN_BIND_STATIC: {\n\t\tstruct ioctl_evtchn_bind bind;\n\t\tstruct user_evtchn *evtchn;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&bind, uarg, sizeof(bind)))\n\t\t\tbreak;\n\n\t\trc = -EISCONN;\n\t\tevtchn = find_evtchn(u, bind.port);\n\t\tif (evtchn)\n\t\t\tbreak;\n\n\t\trc = evtchn_bind_to_user(u, bind.port, true);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_EVTCHN_NOTIFY: {\n\t\tstruct ioctl_evtchn_notify notify;\n\t\tstruct user_evtchn *evtchn;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&notify, uarg, sizeof(notify)))\n\t\t\tbreak;\n\n\t\trc = -ENOTCONN;\n\t\tevtchn = find_evtchn(u, notify.port);\n\t\tif (evtchn) {\n\t\t\tnotify_remote_via_evtchn(notify.port);\n\t\t\trc = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IOCTL_EVTCHN_RESET: {\n\t\t \n\t\tmutex_lock(&u->ring_cons_mutex);\n\t\tspin_lock_irq(&u->ring_prod_lock);\n\t\tWRITE_ONCE(u->ring_cons, 0);\n\t\tWRITE_ONCE(u->ring_prod, 0);\n\t\tu->ring_overflow = 0;\n\t\tspin_unlock_irq(&u->ring_prod_lock);\n\t\tmutex_unlock(&u->ring_cons_mutex);\n\t\trc = 0;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_EVTCHN_RESTRICT_DOMID: {\n\t\tstruct ioctl_evtchn_restrict_domid ierd;\n\n\t\trc = -EACCES;\n\t\tif (u->restrict_domid != UNRESTRICTED_DOMID)\n\t\t\tbreak;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ierd, uarg, sizeof(ierd)))\n\t\t    break;\n\n\t\trc = -EINVAL;\n\t\tif (ierd.domid == 0 || ierd.domid >= DOMID_FIRST_RESERVED)\n\t\t\tbreak;\n\n\t\tu->restrict_domid = ierd.domid;\n\t\trc = 0;\n\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\trc = -ENOSYS;\n\t\tbreak;\n\t}\n\tmutex_unlock(&u->bind_mutex);\n\n\treturn rc;\n}\n\nstatic __poll_t evtchn_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t mask = EPOLLOUT | EPOLLWRNORM;\n\tstruct per_user_data *u = file->private_data;\n\n\tpoll_wait(file, &u->evtchn_wait, wait);\n\tif (READ_ONCE(u->ring_cons) != READ_ONCE(u->ring_prod))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (u->ring_overflow)\n\t\tmask = EPOLLERR;\n\treturn mask;\n}\n\nstatic int evtchn_fasync(int fd, struct file *filp, int on)\n{\n\tstruct per_user_data *u = filp->private_data;\n\treturn fasync_helper(fd, filp, on, &u->evtchn_async_queue);\n}\n\nstatic int evtchn_open(struct inode *inode, struct file *filp)\n{\n\tstruct per_user_data *u;\n\n\tu = kzalloc(sizeof(*u), GFP_KERNEL);\n\tif (u == NULL)\n\t\treturn -ENOMEM;\n\n\tu->name = kasprintf(GFP_KERNEL, \"evtchn:%s\", current->comm);\n\tif (u->name == NULL) {\n\t\tkfree(u);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_waitqueue_head(&u->evtchn_wait);\n\n\tmutex_init(&u->bind_mutex);\n\tmutex_init(&u->ring_cons_mutex);\n\tspin_lock_init(&u->ring_prod_lock);\n\n\tu->restrict_domid = UNRESTRICTED_DOMID;\n\n\tfilp->private_data = u;\n\n\treturn stream_open(inode, filp);\n}\n\nstatic int evtchn_release(struct inode *inode, struct file *filp)\n{\n\tstruct per_user_data *u = filp->private_data;\n\tstruct rb_node *node;\n\n\twhile ((node = u->evtchns.rb_node)) {\n\t\tstruct user_evtchn *evtchn;\n\n\t\tevtchn = rb_entry(node, struct user_evtchn, node);\n\t\tdisable_irq(irq_from_evtchn(evtchn->port));\n\t\tevtchn_unbind_from_user(u, evtchn);\n\t}\n\n\tevtchn_free_ring(u->ring);\n\tkfree(u->name);\n\tkfree(u);\n\n\treturn 0;\n}\n\nstatic const struct file_operations evtchn_fops = {\n\t.owner   = THIS_MODULE,\n\t.read    = evtchn_read,\n\t.write   = evtchn_write,\n\t.unlocked_ioctl = evtchn_ioctl,\n\t.poll    = evtchn_poll,\n\t.fasync  = evtchn_fasync,\n\t.open    = evtchn_open,\n\t.release = evtchn_release,\n\t.llseek\t = no_llseek,\n};\n\nstatic struct miscdevice evtchn_miscdev = {\n\t.minor        = MISC_DYNAMIC_MINOR,\n\t.name         = \"xen/evtchn\",\n\t.fops         = &evtchn_fops,\n};\nstatic int __init evtchn_init(void)\n{\n\tint err;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\t \n\terr = misc_register(&evtchn_miscdev);\n\tif (err != 0) {\n\t\tpr_err(\"Could not register /dev/xen/evtchn\\n\");\n\t\treturn err;\n\t}\n\n\tpr_info(\"Event-channel device installed\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit evtchn_cleanup(void)\n{\n\tmisc_deregister(&evtchn_miscdev);\n}\n\nmodule_init(evtchn_init);\nmodule_exit(evtchn_cleanup);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}