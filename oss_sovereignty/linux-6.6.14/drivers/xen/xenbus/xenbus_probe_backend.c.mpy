{
  "module_name": "xenbus_probe_backend.c",
  "hash_id": "673eb8d85fa81b11ba1216548d73b3b3379c0f45b9509fd313766f25ddb70a3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xenbus/xenbus_probe_backend.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DPRINTK(fmt, ...)\t\t\t\t\\\n\tpr_debug(\"(%s:%d) \" fmt \"\\n\",\t\t\t\\\n\t\t __func__, __LINE__, ##__VA_ARGS__)\n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/semaphore.h>\n\n#include <asm/page.h>\n#include <asm/xen/hypervisor.h>\n#include <asm/hypervisor.h>\n#include <xen/xenbus.h>\n#include <xen/features.h>\n\n#include \"xenbus.h\"\n\n \nstatic int backend_bus_id(char bus_id[XEN_BUS_ID_SIZE], const char *nodename)\n{\n\tint domid, err;\n\tconst char *devid, *type, *frontend;\n\tunsigned int typelen;\n\n\ttype = strchr(nodename, '/');\n\tif (!type)\n\t\treturn -EINVAL;\n\ttype++;\n\ttypelen = strcspn(type, \"/\");\n\tif (!typelen || type[typelen] != '/')\n\t\treturn -EINVAL;\n\n\tdevid = strrchr(nodename, '/') + 1;\n\n\terr = xenbus_gather(XBT_NIL, nodename, \"frontend-id\", \"%i\", &domid,\n\t\t\t    \"frontend\", NULL, &frontend,\n\t\t\t    NULL);\n\tif (err)\n\t\treturn err;\n\tif (strlen(frontend) == 0)\n\t\terr = -ERANGE;\n\tif (!err && !xenbus_exists(XBT_NIL, frontend, \"\"))\n\t\terr = -ENOENT;\n\tkfree(frontend);\n\n\tif (err)\n\t\treturn err;\n\n\tif (snprintf(bus_id, XEN_BUS_ID_SIZE, \"%.*s-%i-%s\",\n\t\t     typelen, type, domid, devid) >= XEN_BUS_ID_SIZE)\n\t\treturn -ENOSPC;\n\treturn 0;\n}\n\nstatic int xenbus_uevent_backend(const struct device *dev,\n\t\t\t\t struct kobj_uevent_env *env)\n{\n\tconst struct xenbus_device *xdev;\n\tconst struct xenbus_driver *drv;\n\tconst struct xen_bus_type *bus;\n\n\tDPRINTK(\"\");\n\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\txdev = to_xenbus_device(dev);\n\tbus = container_of(xdev->dev.bus, struct xen_bus_type, bus);\n\n\tif (add_uevent_var(env, \"MODALIAS=xen-backend:%s\", xdev->devicetype))\n\t\treturn -ENOMEM;\n\n\t \n\tif (add_uevent_var(env, \"XENBUS_TYPE=%s\", xdev->devicetype))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"XENBUS_PATH=%s\", xdev->nodename))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"XENBUS_BASE_PATH=%s\", bus->root))\n\t\treturn -ENOMEM;\n\n\tif (dev->driver) {\n\t\tdrv = to_xenbus_driver(dev->driver);\n\t\tif (drv && drv->uevent)\n\t\t\treturn drv->uevent(xdev, env);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int xenbus_probe_backend_unit(struct xen_bus_type *bus,\n\t\t\t\t     const char *dir,\n\t\t\t\t     const char *type,\n\t\t\t\t     const char *name)\n{\n\tchar *nodename;\n\tint err;\n\n\tnodename = kasprintf(GFP_KERNEL, \"%s/%s\", dir, name);\n\tif (!nodename)\n\t\treturn -ENOMEM;\n\n\tDPRINTK(\"%s\\n\", nodename);\n\n\terr = xenbus_probe_node(bus, type, nodename);\n\tkfree(nodename);\n\treturn err;\n}\n\n \nstatic int xenbus_probe_backend(struct xen_bus_type *bus, const char *type,\n\t\t\t\tconst char *domid)\n{\n\tchar *nodename;\n\tint err = 0;\n\tchar **dir;\n\tunsigned int i, dir_n = 0;\n\n\tDPRINTK(\"\");\n\n\tnodename = kasprintf(GFP_KERNEL, \"%s/%s/%s\", bus->root, type, domid);\n\tif (!nodename)\n\t\treturn -ENOMEM;\n\n\tdir = xenbus_directory(XBT_NIL, nodename, \"\", &dir_n);\n\tif (IS_ERR(dir)) {\n\t\tkfree(nodename);\n\t\treturn PTR_ERR(dir);\n\t}\n\n\tfor (i = 0; i < dir_n; i++) {\n\t\terr = xenbus_probe_backend_unit(bus, nodename, type, dir[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tkfree(dir);\n\tkfree(nodename);\n\treturn err;\n}\n\nstatic bool frontend_will_handle(struct xenbus_watch *watch,\n\t\t\t\t const char *path, const char *token)\n{\n\treturn watch->nr_pending == 0;\n}\n\nstatic void frontend_changed(struct xenbus_watch *watch,\n\t\t\t     const char *path, const char *token)\n{\n\txenbus_otherend_changed(watch, path, token, 0);\n}\n\nstatic struct xen_bus_type xenbus_backend = {\n\t.root = \"backend\",\n\t.levels = 3,\t\t \n\t.get_bus_id = backend_bus_id,\n\t.probe = xenbus_probe_backend,\n\t.otherend_will_handle = frontend_will_handle,\n\t.otherend_changed = frontend_changed,\n\t.bus = {\n\t\t.name\t\t= \"xen-backend\",\n\t\t.match\t\t= xenbus_match,\n\t\t.uevent\t\t= xenbus_uevent_backend,\n\t\t.probe\t\t= xenbus_dev_probe,\n\t\t.remove\t\t= xenbus_dev_remove,\n\t\t.dev_groups\t= xenbus_dev_groups,\n\t},\n};\n\nstatic void backend_changed(struct xenbus_watch *watch,\n\t\t\t    const char *path, const char *token)\n{\n\tDPRINTK(\"\");\n\n\txenbus_dev_changed(path, &xenbus_backend);\n}\n\nstatic struct xenbus_watch be_watch = {\n\t.node = \"backend\",\n\t.callback = backend_changed,\n};\n\nstatic int read_frontend_details(struct xenbus_device *xendev)\n{\n\treturn xenbus_read_otherend_details(xendev, \"frontend-id\", \"frontend\");\n}\n\nint xenbus_dev_is_online(struct xenbus_device *dev)\n{\n\treturn !!xenbus_read_unsigned(dev->nodename, \"online\", 0);\n}\nEXPORT_SYMBOL_GPL(xenbus_dev_is_online);\n\nint __xenbus_register_backend(struct xenbus_driver *drv, struct module *owner,\n\t\t\t      const char *mod_name)\n{\n\tdrv->read_otherend_details = read_frontend_details;\n\n\treturn xenbus_register_driver_common(drv, &xenbus_backend,\n\t\t\t\t\t     owner, mod_name);\n}\nEXPORT_SYMBOL_GPL(__xenbus_register_backend);\n\nstatic int backend_probe_and_watch(struct notifier_block *notifier,\n\t\t\t\t   unsigned long event,\n\t\t\t\t   void *data)\n{\n\t \n\txenbus_probe_devices(&xenbus_backend);\n\tregister_xenbus_watch(&be_watch);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int backend_reclaim_memory(struct device *dev, void *data)\n{\n\tconst struct xenbus_driver *drv;\n\tstruct xenbus_device *xdev;\n\n\tif (!dev->driver)\n\t\treturn 0;\n\tdrv = to_xenbus_driver(dev->driver);\n\tif (drv && drv->reclaim_memory) {\n\t\txdev = to_xenbus_device(dev);\n\t\tif (down_trylock(&xdev->reclaim_sem))\n\t\t\treturn 0;\n\t\tdrv->reclaim_memory(xdev);\n\t\tup(&xdev->reclaim_sem);\n\t}\n\treturn 0;\n}\n\n \nstatic unsigned long backend_shrink_memory_count(struct shrinker *shrinker,\n\t\t\t\tstruct shrink_control *sc)\n{\n\tbus_for_each_dev(&xenbus_backend.bus, NULL, NULL,\n\t\t\tbackend_reclaim_memory);\n\treturn 0;\n}\n\nstatic struct shrinker backend_memory_shrinker = {\n\t.count_objects = backend_shrink_memory_count,\n\t.seeks = DEFAULT_SEEKS,\n};\n\nstatic int __init xenbus_probe_backend_init(void)\n{\n\tstatic struct notifier_block xenstore_notifier = {\n\t\t.notifier_call = backend_probe_and_watch\n\t};\n\tint err;\n\n\tDPRINTK(\"\");\n\n\t \n\terr = bus_register(&xenbus_backend.bus);\n\tif (err)\n\t\treturn err;\n\n\tregister_xenstore_notifier(&xenstore_notifier);\n\n\tif (register_shrinker(&backend_memory_shrinker, \"xen-backend\"))\n\t\tpr_warn(\"shrinker registration failed\\n\");\n\n\treturn 0;\n}\nsubsys_initcall(xenbus_probe_backend_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}