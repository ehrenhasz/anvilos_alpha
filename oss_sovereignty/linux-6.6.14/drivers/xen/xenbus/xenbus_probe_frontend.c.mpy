{
  "module_name": "xenbus_probe_frontend.c",
  "hash_id": "d789ba8bd7d224aef082d5bf0d9bcb67c09544589cad968dd116cbacb53b3a97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xenbus/xenbus_probe_frontend.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DPRINTK(fmt, ...)\t\t\t\t\\\n\tpr_debug(\"(%s:%d) \" fmt \"\\n\",\t\t\t\\\n\t\t __func__, __LINE__, ##__VA_ARGS__)\n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/notifier.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/module.h>\n\n#include <asm/page.h>\n#include <asm/xen/hypervisor.h>\n#include <xen/xenbus.h>\n#include <xen/events.h>\n#include <xen/page.h>\n#include <xen/xen.h>\n\n#include <xen/platform_pci.h>\n\n#include \"xenbus.h\"\n\n\n\n \nstatic int frontend_bus_id(char bus_id[XEN_BUS_ID_SIZE], const char *nodename)\n{\n\tnodename = strchr(nodename, '/');\n\tif (!nodename || strlen(nodename + 1) >= XEN_BUS_ID_SIZE) {\n\t\tpr_warn(\"bad frontend %s\\n\", nodename);\n\t\treturn -EINVAL;\n\t}\n\n\tstrscpy(bus_id, nodename + 1, XEN_BUS_ID_SIZE);\n\tif (!strchr(bus_id, '/')) {\n\t\tpr_warn(\"bus_id %s no slash\\n\", bus_id);\n\t\treturn -EINVAL;\n\t}\n\t*strchr(bus_id, '/') = '-';\n\treturn 0;\n}\n\n \nstatic int xenbus_probe_frontend(struct xen_bus_type *bus, const char *type,\n\t\t\t\t const char *name)\n{\n\tchar *nodename;\n\tint err;\n\n\t \n\tif (!strncmp(type, \"console\", 7) && !strncmp(name, \"0\", 1)) {\n\t\tDPRINTK(\"Ignoring buggy device entry console/0\");\n\t\treturn 0;\n\t}\n\n\tnodename = kasprintf(GFP_KERNEL, \"%s/%s/%s\", bus->root, type, name);\n\tif (!nodename)\n\t\treturn -ENOMEM;\n\n\tDPRINTK(\"%s\", nodename);\n\n\terr = xenbus_probe_node(bus, type, nodename);\n\tkfree(nodename);\n\treturn err;\n}\n\nstatic int xenbus_uevent_frontend(const struct device *_dev,\n\t\t\t\t  struct kobj_uevent_env *env)\n{\n\tconst struct xenbus_device *dev = to_xenbus_device(_dev);\n\n\tif (add_uevent_var(env, \"MODALIAS=xen:%s\", dev->devicetype))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n\nstatic void backend_changed(struct xenbus_watch *watch,\n\t\t\t    const char *path, const char *token)\n{\n\txenbus_otherend_changed(watch, path, token, 1);\n}\n\nstatic void xenbus_frontend_delayed_resume(struct work_struct *w)\n{\n\tstruct xenbus_device *xdev = container_of(w, struct xenbus_device, work);\n\n\txenbus_dev_resume(&xdev->dev);\n}\n\nstatic int xenbus_frontend_dev_resume(struct device *dev)\n{\n\t \n\tif (xen_store_domain_type == XS_LOCAL) {\n\t\tstruct xenbus_device *xdev = to_xenbus_device(dev);\n\n\t\tschedule_work(&xdev->work);\n\n\t\treturn 0;\n\t}\n\n\treturn xenbus_dev_resume(dev);\n}\n\nstatic int xenbus_frontend_dev_probe(struct device *dev)\n{\n\tif (xen_store_domain_type == XS_LOCAL) {\n\t\tstruct xenbus_device *xdev = to_xenbus_device(dev);\n\t\tINIT_WORK(&xdev->work, xenbus_frontend_delayed_resume);\n\t}\n\n\treturn xenbus_dev_probe(dev);\n}\n\nstatic void xenbus_frontend_dev_shutdown(struct device *_dev)\n{\n\tstruct xenbus_device *dev = to_xenbus_device(_dev);\n\tunsigned long timeout = 5*HZ;\n\n\tDPRINTK(\"%s\", dev->nodename);\n\n\tget_device(&dev->dev);\n\tif (dev->state != XenbusStateConnected) {\n\t\tpr_info(\"%s: %s: %s != Connected, skipping\\n\",\n\t\t\t__func__, dev->nodename, xenbus_strstate(dev->state));\n\t\tgoto out;\n\t}\n\txenbus_switch_state(dev, XenbusStateClosing);\n\ttimeout = wait_for_completion_timeout(&dev->down, timeout);\n\tif (!timeout)\n\t\tpr_info(\"%s: %s timeout closing device\\n\",\n\t\t\t__func__, dev->nodename);\n out:\n\tput_device(&dev->dev);\n}\n\nstatic const struct dev_pm_ops xenbus_pm_ops = {\n\t.suspend\t= xenbus_dev_suspend,\n\t.resume\t\t= xenbus_frontend_dev_resume,\n\t.freeze\t\t= xenbus_dev_suspend,\n\t.thaw\t\t= xenbus_dev_cancel,\n\t.restore\t= xenbus_dev_resume,\n};\n\nstatic struct xen_bus_type xenbus_frontend = {\n\t.root = \"device\",\n\t.levels = 2,\t\t \n\t.get_bus_id = frontend_bus_id,\n\t.probe = xenbus_probe_frontend,\n\t.otherend_changed = backend_changed,\n\t.bus = {\n\t\t.name\t\t= \"xen\",\n\t\t.match\t\t= xenbus_match,\n\t\t.uevent\t\t= xenbus_uevent_frontend,\n\t\t.probe\t\t= xenbus_frontend_dev_probe,\n\t\t.remove\t\t= xenbus_dev_remove,\n\t\t.shutdown\t= xenbus_frontend_dev_shutdown,\n\t\t.dev_groups\t= xenbus_dev_groups,\n\n\t\t.pm\t\t= &xenbus_pm_ops,\n\t},\n};\n\nstatic void frontend_changed(struct xenbus_watch *watch,\n\t\t\t     const char *path, const char *token)\n{\n\tDPRINTK(\"\");\n\n\txenbus_dev_changed(path, &xenbus_frontend);\n}\n\n\n \nstatic struct xenbus_watch fe_watch = {\n\t.node = \"device\",\n\t.callback = frontend_changed,\n};\n\nstatic int read_backend_details(struct xenbus_device *xendev)\n{\n\treturn xenbus_read_otherend_details(xendev, \"backend-id\", \"backend\");\n}\n\nstatic int is_device_connecting(struct device *dev, void *data, bool ignore_nonessential)\n{\n\tstruct xenbus_device *xendev = to_xenbus_device(dev);\n\tstruct device_driver *drv = data;\n\tstruct xenbus_driver *xendrv;\n\n\t \n\tif (!dev->driver)\n\t\treturn 0;\n\n\t \n\tif (drv && (dev->driver != drv))\n\t\treturn 0;\n\n\txendrv = to_xenbus_driver(dev->driver);\n\n\tif (ignore_nonessential && xendrv->not_essential)\n\t\treturn 0;\n\n\treturn (xendev->state < XenbusStateConnected ||\n\t\t(xendev->state == XenbusStateConnected &&\n\t\t xendrv->is_ready && !xendrv->is_ready(xendev)));\n}\nstatic int essential_device_connecting(struct device *dev, void *data)\n{\n\treturn is_device_connecting(dev, data, true  );\n}\nstatic int non_essential_device_connecting(struct device *dev, void *data)\n{\n\treturn is_device_connecting(dev, data, false);\n}\n\nstatic int exists_essential_connecting_device(struct device_driver *drv)\n{\n\treturn bus_for_each_dev(&xenbus_frontend.bus, NULL, drv,\n\t\t\t\tessential_device_connecting);\n}\nstatic int exists_non_essential_connecting_device(struct device_driver *drv)\n{\n\treturn bus_for_each_dev(&xenbus_frontend.bus, NULL, drv,\n\t\t\t\tnon_essential_device_connecting);\n}\n\nstatic int print_device_status(struct device *dev, void *data)\n{\n\tstruct xenbus_device *xendev = to_xenbus_device(dev);\n\tstruct device_driver *drv = data;\n\n\t \n\tif (drv && (dev->driver != drv))\n\t\treturn 0;\n\n\tif (!dev->driver) {\n\t\t \n\t\tpr_info(\"Device with no driver: %s\\n\", xendev->nodename);\n\t} else if (xendev->state < XenbusStateConnected) {\n\t\tenum xenbus_state rstate = XenbusStateUnknown;\n\t\tif (xendev->otherend)\n\t\t\trstate = xenbus_read_driver_state(xendev->otherend);\n\t\tpr_warn(\"Timeout connecting to device: %s (local state %d, remote state %d)\\n\",\n\t\t\txendev->nodename, xendev->state, rstate);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ready_to_wait_for_devices;\n\nstatic bool wait_loop(unsigned long start, unsigned int max_delay,\n\t\t     unsigned int *seconds_waited)\n{\n\tif (time_after(jiffies, start + (*seconds_waited+5)*HZ)) {\n\t\tif (!*seconds_waited)\n\t\t\tpr_warn(\"Waiting for devices to initialise: \");\n\t\t*seconds_waited += 5;\n\t\tpr_cont(\"%us...\", max_delay - *seconds_waited);\n\t\tif (*seconds_waited == max_delay) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tschedule_timeout_interruptible(HZ/10);\n\n\treturn false;\n}\n \nstatic void wait_for_devices(struct xenbus_driver *xendrv)\n{\n\tunsigned long start = jiffies;\n\tstruct device_driver *drv = xendrv ? &xendrv->driver : NULL;\n\tunsigned int seconds_waited = 0;\n\n\tif (!ready_to_wait_for_devices || !xen_domain())\n\t\treturn;\n\n\twhile (exists_non_essential_connecting_device(drv))\n\t\tif (wait_loop(start, 30, &seconds_waited))\n\t\t\tbreak;\n\n\t \n\twhile (exists_essential_connecting_device(drv))\n\t\tif (wait_loop(start, 270, &seconds_waited))\n\t\t\tbreak;\n\n\tif (seconds_waited)\n\t\tprintk(\"\\n\");\n\n\tbus_for_each_dev(&xenbus_frontend.bus, NULL, drv,\n\t\t\t print_device_status);\n}\n\nint __xenbus_register_frontend(struct xenbus_driver *drv, struct module *owner,\n\t\t\t       const char *mod_name)\n{\n\tint ret;\n\n\tdrv->read_otherend_details = read_backend_details;\n\n\tret = xenbus_register_driver_common(drv, &xenbus_frontend,\n\t\t\t\t\t    owner, mod_name);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twait_for_devices(drv);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__xenbus_register_frontend);\n\nstatic DECLARE_WAIT_QUEUE_HEAD(backend_state_wq);\nstatic int backend_state;\n\nstatic void xenbus_reset_backend_state_changed(struct xenbus_watch *w,\n\t\t\t\t\tconst char *path, const char *token)\n{\n\tif (xenbus_scanf(XBT_NIL, path, \"\", \"%i\",\n\t\t\t &backend_state) != 1)\n\t\tbackend_state = XenbusStateUnknown;\n\tprintk(KERN_DEBUG \"XENBUS: backend %s %s\\n\",\n\t       path, xenbus_strstate(backend_state));\n\twake_up(&backend_state_wq);\n}\n\nstatic void xenbus_reset_wait_for_backend(char *be, int expected)\n{\n\tlong timeout;\n\ttimeout = wait_event_interruptible_timeout(backend_state_wq,\n\t\t\tbackend_state == expected, 5 * HZ);\n\tif (timeout <= 0)\n\t\tpr_info(\"backend %s timed out\\n\", be);\n}\n\n \nstatic void xenbus_reset_frontend(char *fe, char *be, int be_state)\n{\n\tstruct xenbus_watch be_watch;\n\n\tprintk(KERN_DEBUG \"XENBUS: backend %s %s\\n\",\n\t\t\tbe, xenbus_strstate(be_state));\n\n\tmemset(&be_watch, 0, sizeof(be_watch));\n\tbe_watch.node = kasprintf(GFP_NOIO | __GFP_HIGH, \"%s/state\", be);\n\tif (!be_watch.node)\n\t\treturn;\n\n\tbe_watch.callback = xenbus_reset_backend_state_changed;\n\tbackend_state = XenbusStateUnknown;\n\n\tpr_info(\"triggering reconnect on %s\\n\", be);\n\tregister_xenbus_watch(&be_watch);\n\n\t \n\tswitch (be_state) {\n\tcase XenbusStateConnected:\n\t\txenbus_printf(XBT_NIL, fe, \"state\", \"%d\", XenbusStateClosing);\n\t\txenbus_reset_wait_for_backend(be, XenbusStateClosing);\n\t\tfallthrough;\n\n\tcase XenbusStateClosing:\n\t\txenbus_printf(XBT_NIL, fe, \"state\", \"%d\", XenbusStateClosed);\n\t\txenbus_reset_wait_for_backend(be, XenbusStateClosed);\n\t\tfallthrough;\n\n\tcase XenbusStateClosed:\n\t\txenbus_printf(XBT_NIL, fe, \"state\", \"%d\", XenbusStateInitialising);\n\t\txenbus_reset_wait_for_backend(be, XenbusStateInitWait);\n\t}\n\n\tunregister_xenbus_watch(&be_watch);\n\tpr_info(\"reconnect done on %s\\n\", be);\n\tkfree(be_watch.node);\n}\n\nstatic void xenbus_check_frontend(char *class, char *dev)\n{\n\tint be_state, fe_state, err;\n\tchar *backend, *frontend;\n\n\tfrontend = kasprintf(GFP_NOIO | __GFP_HIGH, \"device/%s/%s\", class, dev);\n\tif (!frontend)\n\t\treturn;\n\n\terr = xenbus_scanf(XBT_NIL, frontend, \"state\", \"%i\", &fe_state);\n\tif (err != 1)\n\t\tgoto out;\n\n\tswitch (fe_state) {\n\tcase XenbusStateConnected:\n\tcase XenbusStateClosed:\n\t\tprintk(KERN_DEBUG \"XENBUS: frontend %s %s\\n\",\n\t\t\t\tfrontend, xenbus_strstate(fe_state));\n\t\tbackend = xenbus_read(XBT_NIL, frontend, \"backend\", NULL);\n\t\tif (IS_ERR_OR_NULL(backend))\n\t\t\tgoto out;\n\t\terr = xenbus_scanf(XBT_NIL, backend, \"state\", \"%i\", &be_state);\n\t\tif (err == 1)\n\t\t\txenbus_reset_frontend(frontend, backend, be_state);\n\t\tkfree(backend);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\tkfree(frontend);\n}\n\nstatic void xenbus_reset_state(void)\n{\n\tchar **devclass, **dev;\n\tint devclass_n, dev_n;\n\tint i, j;\n\n\tdevclass = xenbus_directory(XBT_NIL, \"device\", \"\", &devclass_n);\n\tif (IS_ERR(devclass))\n\t\treturn;\n\n\tfor (i = 0; i < devclass_n; i++) {\n\t\tdev = xenbus_directory(XBT_NIL, \"device\", devclass[i], &dev_n);\n\t\tif (IS_ERR(dev))\n\t\t\tcontinue;\n\t\tfor (j = 0; j < dev_n; j++)\n\t\t\txenbus_check_frontend(devclass[i], dev[j]);\n\t\tkfree(dev);\n\t}\n\tkfree(devclass);\n}\n\nstatic int frontend_probe_and_watch(struct notifier_block *notifier,\n\t\t\t\t   unsigned long event,\n\t\t\t\t   void *data)\n{\n\t \n\tif (xen_hvm_domain())\n\t\txenbus_reset_state();\n\t \n\txenbus_probe_devices(&xenbus_frontend);\n\tregister_xenbus_watch(&fe_watch);\n\n\treturn NOTIFY_DONE;\n}\n\n\nstatic int __init xenbus_probe_frontend_init(void)\n{\n\tstatic struct notifier_block xenstore_notifier = {\n\t\t.notifier_call = frontend_probe_and_watch\n\t};\n\tint err;\n\n\tDPRINTK(\"\");\n\n\t \n\terr = bus_register(&xenbus_frontend.bus);\n\tif (err)\n\t\treturn err;\n\n\tregister_xenstore_notifier(&xenstore_notifier);\n\n\treturn 0;\n}\nsubsys_initcall(xenbus_probe_frontend_init);\n\n#ifndef MODULE\nstatic int __init boot_wait_for_devices(void)\n{\n\tif (!xen_has_pv_devices())\n\t\treturn -ENODEV;\n\n\tready_to_wait_for_devices = 1;\n\twait_for_devices(NULL);\n\treturn 0;\n}\n\nlate_initcall(boot_wait_for_devices);\n#endif\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}