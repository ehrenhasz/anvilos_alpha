{
  "module_name": "xenbus_probe.c",
  "hash_id": "dedb0cc17867f49d0ca5424262617ed89454b5e27f64a11a1c864996e09d395d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xenbus/xenbus_probe.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#define dev_fmt pr_fmt\n\n#define DPRINTK(fmt, args...)\t\t\t\t\\\n\tpr_debug(\"xenbus_probe (%s:%d) \" fmt \".\\n\",\t\\\n\t\t __func__, __LINE__, ##args)\n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/notifier.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <asm/page.h>\n#include <asm/xen/hypervisor.h>\n\n#include <xen/xen.h>\n#include <xen/xenbus.h>\n#include <xen/events.h>\n#include <xen/xen-ops.h>\n#include <xen/page.h>\n\n#include <xen/hvm.h>\n\n#include \"xenbus.h\"\n\n\nstatic int xs_init_irq;\nint xen_store_evtchn;\nEXPORT_SYMBOL_GPL(xen_store_evtchn);\n\nstruct xenstore_domain_interface *xen_store_interface;\nEXPORT_SYMBOL_GPL(xen_store_interface);\n\nenum xenstore_init xen_store_domain_type;\nEXPORT_SYMBOL_GPL(xen_store_domain_type);\n\nstatic unsigned long xen_store_gfn;\n\nstatic BLOCKING_NOTIFIER_HEAD(xenstore_chain);\n\n \nstatic const struct xenbus_device_id *\nmatch_device(const struct xenbus_device_id *arr, struct xenbus_device *dev)\n{\n\tfor (; *arr->devicetype != '\\0'; arr++) {\n\t\tif (!strcmp(arr->devicetype, dev->devicetype))\n\t\t\treturn arr;\n\t}\n\treturn NULL;\n}\n\nint xenbus_match(struct device *_dev, struct device_driver *_drv)\n{\n\tstruct xenbus_driver *drv = to_xenbus_driver(_drv);\n\n\tif (!drv->ids)\n\t\treturn 0;\n\n\treturn match_device(drv->ids, to_xenbus_device(_dev)) != NULL;\n}\nEXPORT_SYMBOL_GPL(xenbus_match);\n\n\nstatic void free_otherend_details(struct xenbus_device *dev)\n{\n\tkfree(dev->otherend);\n\tdev->otherend = NULL;\n}\n\n\nstatic void free_otherend_watch(struct xenbus_device *dev)\n{\n\tif (dev->otherend_watch.node) {\n\t\tunregister_xenbus_watch(&dev->otherend_watch);\n\t\tkfree(dev->otherend_watch.node);\n\t\tdev->otherend_watch.node = NULL;\n\t}\n}\n\n\nstatic int talk_to_otherend(struct xenbus_device *dev)\n{\n\tstruct xenbus_driver *drv = to_xenbus_driver(dev->dev.driver);\n\n\tfree_otherend_watch(dev);\n\tfree_otherend_details(dev);\n\n\treturn drv->read_otherend_details(dev);\n}\n\n\n\nstatic int watch_otherend(struct xenbus_device *dev)\n{\n\tstruct xen_bus_type *bus =\n\t\tcontainer_of(dev->dev.bus, struct xen_bus_type, bus);\n\n\treturn xenbus_watch_pathfmt(dev, &dev->otherend_watch,\n\t\t\t\t    bus->otherend_will_handle,\n\t\t\t\t    bus->otherend_changed,\n\t\t\t\t    \"%s/%s\", dev->otherend, \"state\");\n}\n\n\nint xenbus_read_otherend_details(struct xenbus_device *xendev,\n\t\t\t\t char *id_node, char *path_node)\n{\n\tint err = xenbus_gather(XBT_NIL, xendev->nodename,\n\t\t\t\tid_node, \"%i\", &xendev->otherend_id,\n\t\t\t\tpath_node, NULL, &xendev->otherend,\n\t\t\t\tNULL);\n\tif (err) {\n\t\txenbus_dev_fatal(xendev, err,\n\t\t\t\t \"reading other end details from %s\",\n\t\t\t\t xendev->nodename);\n\t\treturn err;\n\t}\n\tif (strlen(xendev->otherend) == 0 ||\n\t    !xenbus_exists(XBT_NIL, xendev->otherend, \"\")) {\n\t\txenbus_dev_fatal(xendev, -ENOENT,\n\t\t\t\t \"unable to read other end from %s.  \"\n\t\t\t\t \"missing or inaccessible.\",\n\t\t\t\t xendev->nodename);\n\t\tfree_otherend_details(xendev);\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xenbus_read_otherend_details);\n\nvoid xenbus_otherend_changed(struct xenbus_watch *watch,\n\t\t\t     const char *path, const char *token,\n\t\t\t     int ignore_on_shutdown)\n{\n\tstruct xenbus_device *dev =\n\t\tcontainer_of(watch, struct xenbus_device, otherend_watch);\n\tstruct xenbus_driver *drv = to_xenbus_driver(dev->dev.driver);\n\tenum xenbus_state state;\n\n\t \n\tif (!dev->otherend ||\n\t    strncmp(dev->otherend, path, strlen(dev->otherend))) {\n\t\tdev_dbg(&dev->dev, \"Ignoring watch at %s\\n\", path);\n\t\treturn;\n\t}\n\n\tstate = xenbus_read_driver_state(dev->otherend);\n\n\tdev_dbg(&dev->dev, \"state is %d, (%s), %s, %s\\n\",\n\t\tstate, xenbus_strstate(state), dev->otherend_watch.node, path);\n\n\t \n\tif (system_state > SYSTEM_RUNNING) {\n\t\tif (ignore_on_shutdown && (state == XenbusStateClosing))\n\t\t\txenbus_frontend_closed(dev);\n\t\treturn;\n\t}\n\n\tif (drv->otherend_changed)\n\t\tdrv->otherend_changed(dev, state);\n}\nEXPORT_SYMBOL_GPL(xenbus_otherend_changed);\n\n#define XENBUS_SHOW_STAT(name)\t\t\t\t\t\t\\\nstatic ssize_t name##_show(struct device *_dev,\t\t\t\t\\\n\t\t\t   struct device_attribute *attr,\t\t\\\n\t\t\t   char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct xenbus_device *dev = to_xenbus_device(_dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%d\\n\", atomic_read(&dev->name));\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name)\n\nXENBUS_SHOW_STAT(event_channels);\nXENBUS_SHOW_STAT(events);\nXENBUS_SHOW_STAT(spurious_events);\nXENBUS_SHOW_STAT(jiffies_eoi_delayed);\n\nstatic ssize_t spurious_threshold_show(struct device *_dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct xenbus_device *dev = to_xenbus_device(_dev);\n\n\treturn sprintf(buf, \"%d\\n\", dev->spurious_threshold);\n}\n\nstatic ssize_t spurious_threshold_store(struct device *_dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct xenbus_device *dev = to_xenbus_device(_dev);\n\tunsigned int val;\n\tssize_t ret;\n\n\tret = kstrtouint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->spurious_threshold = val;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(spurious_threshold);\n\nstatic struct attribute *xenbus_attrs[] = {\n\t&dev_attr_event_channels.attr,\n\t&dev_attr_events.attr,\n\t&dev_attr_spurious_events.attr,\n\t&dev_attr_jiffies_eoi_delayed.attr,\n\t&dev_attr_spurious_threshold.attr,\n\tNULL\n};\n\nstatic const struct attribute_group xenbus_group = {\n\t.name = \"xenbus\",\n\t.attrs = xenbus_attrs,\n};\n\nint xenbus_dev_probe(struct device *_dev)\n{\n\tstruct xenbus_device *dev = to_xenbus_device(_dev);\n\tstruct xenbus_driver *drv = to_xenbus_driver(_dev->driver);\n\tconst struct xenbus_device_id *id;\n\tint err;\n\n\tDPRINTK(\"%s\", dev->nodename);\n\n\tif (!drv->probe) {\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tid = match_device(drv->ids, dev);\n\tif (!id) {\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\terr = talk_to_otherend(dev);\n\tif (err) {\n\t\tdev_warn(&dev->dev, \"talk_to_otherend on %s failed.\\n\",\n\t\t\t dev->nodename);\n\t\treturn err;\n\t}\n\n\tif (!try_module_get(drv->driver.owner)) {\n\t\tdev_warn(&dev->dev, \"failed to acquire module reference on '%s'\\n\",\n\t\t\t drv->driver.name);\n\t\terr = -ESRCH;\n\t\tgoto fail;\n\t}\n\n\tdown(&dev->reclaim_sem);\n\terr = drv->probe(dev, id);\n\tup(&dev->reclaim_sem);\n\tif (err)\n\t\tgoto fail_put;\n\n\terr = watch_otherend(dev);\n\tif (err) {\n\t\tdev_warn(&dev->dev, \"watch_otherend on %s failed.\\n\",\n\t\t       dev->nodename);\n\t\treturn err;\n\t}\n\n\tdev->spurious_threshold = 1;\n\tif (sysfs_create_group(&dev->dev.kobj, &xenbus_group))\n\t\tdev_warn(&dev->dev, \"sysfs_create_group on %s failed.\\n\",\n\t\t\t dev->nodename);\n\n\treturn 0;\nfail_put:\n\tmodule_put(drv->driver.owner);\nfail:\n\txenbus_dev_error(dev, err, \"xenbus_dev_probe on %s\", dev->nodename);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(xenbus_dev_probe);\n\nvoid xenbus_dev_remove(struct device *_dev)\n{\n\tstruct xenbus_device *dev = to_xenbus_device(_dev);\n\tstruct xenbus_driver *drv = to_xenbus_driver(_dev->driver);\n\n\tDPRINTK(\"%s\", dev->nodename);\n\n\tsysfs_remove_group(&dev->dev.kobj, &xenbus_group);\n\n\tfree_otherend_watch(dev);\n\n\tif (drv->remove) {\n\t\tdown(&dev->reclaim_sem);\n\t\tdrv->remove(dev);\n\t\tup(&dev->reclaim_sem);\n\t}\n\n\tmodule_put(drv->driver.owner);\n\n\tfree_otherend_details(dev);\n\n\t \n\tif (!drv->allow_rebind ||\n\t    xenbus_read_driver_state(dev->nodename) == XenbusStateClosing)\n\t\txenbus_switch_state(dev, XenbusStateClosed);\n}\nEXPORT_SYMBOL_GPL(xenbus_dev_remove);\n\nint xenbus_register_driver_common(struct xenbus_driver *drv,\n\t\t\t\t  struct xen_bus_type *bus,\n\t\t\t\t  struct module *owner, const char *mod_name)\n{\n\tdrv->driver.name = drv->name ? drv->name : drv->ids[0].devicetype;\n\tdrv->driver.bus = &bus->bus;\n\tdrv->driver.owner = owner;\n\tdrv->driver.mod_name = mod_name;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(xenbus_register_driver_common);\n\nvoid xenbus_unregister_driver(struct xenbus_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(xenbus_unregister_driver);\n\nstruct xb_find_info {\n\tstruct xenbus_device *dev;\n\tconst char *nodename;\n};\n\nstatic int cmp_dev(struct device *dev, void *data)\n{\n\tstruct xenbus_device *xendev = to_xenbus_device(dev);\n\tstruct xb_find_info *info = data;\n\n\tif (!strcmp(xendev->nodename, info->nodename)) {\n\t\tinfo->dev = xendev;\n\t\tget_device(dev);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic struct xenbus_device *xenbus_device_find(const char *nodename,\n\t\t\t\t\t\tstruct bus_type *bus)\n{\n\tstruct xb_find_info info = { .dev = NULL, .nodename = nodename };\n\n\tbus_for_each_dev(bus, NULL, &info, cmp_dev);\n\treturn info.dev;\n}\n\nstatic int cleanup_dev(struct device *dev, void *data)\n{\n\tstruct xenbus_device *xendev = to_xenbus_device(dev);\n\tstruct xb_find_info *info = data;\n\tint len = strlen(info->nodename);\n\n\tDPRINTK(\"%s\", info->nodename);\n\n\t \n\tif (strncmp(xendev->nodename, info->nodename, len))\n\t\treturn 0;\n\n\t \n\tif ((strlen(xendev->nodename) > len) && (xendev->nodename[len] != '/'))\n\t\treturn 0;\n\n\tinfo->dev = xendev;\n\tget_device(dev);\n\treturn 1;\n}\n\nstatic void xenbus_cleanup_devices(const char *path, struct bus_type *bus)\n{\n\tstruct xb_find_info info = { .nodename = path };\n\n\tdo {\n\t\tinfo.dev = NULL;\n\t\tbus_for_each_dev(bus, NULL, &info, cleanup_dev);\n\t\tif (info.dev) {\n\t\t\tdevice_unregister(&info.dev->dev);\n\t\t\tput_device(&info.dev->dev);\n\t\t}\n\t} while (info.dev);\n}\n\nstatic void xenbus_dev_release(struct device *dev)\n{\n\tif (dev)\n\t\tkfree(to_xenbus_device(dev));\n}\n\nstatic ssize_t nodename_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", to_xenbus_device(dev)->nodename);\n}\nstatic DEVICE_ATTR_RO(nodename);\n\nstatic ssize_t devtype_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", to_xenbus_device(dev)->devicetype);\n}\nstatic DEVICE_ATTR_RO(devtype);\n\nstatic ssize_t modalias_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s:%s\\n\", dev->bus->name,\n\t\t       to_xenbus_device(dev)->devicetype);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t state_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\",\n\t\t\txenbus_strstate(to_xenbus_device(dev)->state));\n}\nstatic DEVICE_ATTR_RO(state);\n\nstatic struct attribute *xenbus_dev_attrs[] = {\n\t&dev_attr_nodename.attr,\n\t&dev_attr_devtype.attr,\n\t&dev_attr_modalias.attr,\n\t&dev_attr_state.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group xenbus_dev_group = {\n\t.attrs = xenbus_dev_attrs,\n};\n\nconst struct attribute_group *xenbus_dev_groups[] = {\n\t&xenbus_dev_group,\n\tNULL,\n};\nEXPORT_SYMBOL_GPL(xenbus_dev_groups);\n\nint xenbus_probe_node(struct xen_bus_type *bus,\n\t\t      const char *type,\n\t\t      const char *nodename)\n{\n\tchar devname[XEN_BUS_ID_SIZE];\n\tint err;\n\tstruct xenbus_device *xendev;\n\tsize_t stringlen;\n\tchar *tmpstring;\n\n\tenum xenbus_state state = xenbus_read_driver_state(nodename);\n\n\tif (state != XenbusStateInitialising) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tstringlen = strlen(nodename) + 1 + strlen(type) + 1;\n\txendev = kzalloc(sizeof(*xendev) + stringlen, GFP_KERNEL);\n\tif (!xendev)\n\t\treturn -ENOMEM;\n\n\txendev->state = XenbusStateInitialising;\n\n\t \n\n\ttmpstring = (char *)(xendev + 1);\n\tstrcpy(tmpstring, nodename);\n\txendev->nodename = tmpstring;\n\n\ttmpstring += strlen(tmpstring) + 1;\n\tstrcpy(tmpstring, type);\n\txendev->devicetype = tmpstring;\n\tinit_completion(&xendev->down);\n\n\txendev->dev.bus = &bus->bus;\n\txendev->dev.release = xenbus_dev_release;\n\n\terr = bus->get_bus_id(devname, xendev->nodename);\n\tif (err)\n\t\tgoto fail;\n\n\tdev_set_name(&xendev->dev, \"%s\", devname);\n\tsema_init(&xendev->reclaim_sem, 1);\n\n\t \n\terr = device_register(&xendev->dev);\n\tif (err) {\n\t\tput_device(&xendev->dev);\n\t\txendev = NULL;\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tkfree(xendev);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(xenbus_probe_node);\n\nstatic int xenbus_probe_device_type(struct xen_bus_type *bus, const char *type)\n{\n\tint err = 0;\n\tchar **dir;\n\tunsigned int dir_n = 0;\n\tint i;\n\n\tdir = xenbus_directory(XBT_NIL, bus->root, type, &dir_n);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\tfor (i = 0; i < dir_n; i++) {\n\t\terr = bus->probe(bus, type, dir[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tkfree(dir);\n\treturn err;\n}\n\nint xenbus_probe_devices(struct xen_bus_type *bus)\n{\n\tint err = 0;\n\tchar **dir;\n\tunsigned int i, dir_n;\n\n\tdir = xenbus_directory(XBT_NIL, bus->root, \"\", &dir_n);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\tfor (i = 0; i < dir_n; i++) {\n\t\terr = xenbus_probe_device_type(bus, dir[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tkfree(dir);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(xenbus_probe_devices);\n\nstatic unsigned int char_count(const char *str, char c)\n{\n\tunsigned int i, ret = 0;\n\n\tfor (i = 0; str[i]; i++)\n\t\tif (str[i] == c)\n\t\t\tret++;\n\treturn ret;\n}\n\nstatic int strsep_len(const char *str, char c, unsigned int len)\n{\n\tunsigned int i;\n\n\tfor (i = 0; str[i]; i++)\n\t\tif (str[i] == c) {\n\t\t\tif (len == 0)\n\t\t\t\treturn i;\n\t\t\tlen--;\n\t\t}\n\treturn (len == 0) ? i : -ERANGE;\n}\n\nvoid xenbus_dev_changed(const char *node, struct xen_bus_type *bus)\n{\n\tint exists, rootlen;\n\tstruct xenbus_device *dev;\n\tchar type[XEN_BUS_ID_SIZE];\n\tconst char *p, *root;\n\n\tif (char_count(node, '/') < 2)\n\t\treturn;\n\n\texists = xenbus_exists(XBT_NIL, node, \"\");\n\tif (!exists) {\n\t\txenbus_cleanup_devices(node, &bus->bus);\n\t\treturn;\n\t}\n\n\t \n\tp = strchr(node, '/') + 1;\n\tsnprintf(type, XEN_BUS_ID_SIZE, \"%.*s\", (int)strcspn(p, \"/\"), p);\n\ttype[XEN_BUS_ID_SIZE-1] = '\\0';\n\n\trootlen = strsep_len(node, '/', bus->levels);\n\tif (rootlen < 0)\n\t\treturn;\n\troot = kasprintf(GFP_KERNEL, \"%.*s\", rootlen, node);\n\tif (!root)\n\t\treturn;\n\n\tdev = xenbus_device_find(root, &bus->bus);\n\tif (!dev)\n\t\txenbus_probe_node(bus, type, root);\n\telse\n\t\tput_device(&dev->dev);\n\n\tkfree(root);\n}\nEXPORT_SYMBOL_GPL(xenbus_dev_changed);\n\nint xenbus_dev_suspend(struct device *dev)\n{\n\tint err = 0;\n\tstruct xenbus_driver *drv;\n\tstruct xenbus_device *xdev\n\t\t= container_of(dev, struct xenbus_device, dev);\n\n\tDPRINTK(\"%s\", xdev->nodename);\n\n\tif (dev->driver == NULL)\n\t\treturn 0;\n\tdrv = to_xenbus_driver(dev->driver);\n\tif (drv->suspend)\n\t\terr = drv->suspend(xdev);\n\tif (err)\n\t\tdev_warn(dev, \"suspend failed: %i\\n\", err);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xenbus_dev_suspend);\n\nint xenbus_dev_resume(struct device *dev)\n{\n\tint err;\n\tstruct xenbus_driver *drv;\n\tstruct xenbus_device *xdev\n\t\t= container_of(dev, struct xenbus_device, dev);\n\n\tDPRINTK(\"%s\", xdev->nodename);\n\n\tif (dev->driver == NULL)\n\t\treturn 0;\n\tdrv = to_xenbus_driver(dev->driver);\n\terr = talk_to_otherend(xdev);\n\tif (err) {\n\t\tdev_warn(dev, \"resume (talk_to_otherend) failed: %i\\n\", err);\n\t\treturn err;\n\t}\n\n\txdev->state = XenbusStateInitialising;\n\n\tif (drv->resume) {\n\t\terr = drv->resume(xdev);\n\t\tif (err) {\n\t\t\tdev_warn(dev, \"resume failed: %i\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = watch_otherend(xdev);\n\tif (err) {\n\t\tdev_warn(dev, \"resume (watch_otherend) failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xenbus_dev_resume);\n\nint xenbus_dev_cancel(struct device *dev)\n{\n\t \n\tDPRINTK(\"cancel\");\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xenbus_dev_cancel);\n\n \nint xenstored_ready;\n\n\nint register_xenstore_notifier(struct notifier_block *nb)\n{\n\tint ret = 0;\n\n\tif (xenstored_ready > 0)\n\t\tret = nb->notifier_call(nb, 0, NULL);\n\telse\n\t\tblocking_notifier_chain_register(&xenstore_chain, nb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(register_xenstore_notifier);\n\nvoid unregister_xenstore_notifier(struct notifier_block *nb)\n{\n\tblocking_notifier_chain_unregister(&xenstore_chain, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_xenstore_notifier);\n\nstatic void xenbus_probe(void)\n{\n\txenstored_ready = 1;\n\n\tif (!xen_store_interface) {\n\t\txen_store_interface = memremap(xen_store_gfn << XEN_PAGE_SHIFT,\n\t\t\t\t\t       XEN_PAGE_SIZE, MEMREMAP_WB);\n\t\t \n\t\tfree_irq(xs_init_irq, &xb_waitq);\n\t}\n\n\t \n\tif (xen_store_domain_type == XS_HVM)\n\t\txs_init();\n\n\t \n\tblocking_notifier_call_chain(&xenstore_chain, 0, NULL);\n}\n\n \nstatic bool xs_hvm_defer_init_for_callback(void)\n{\n#ifdef CONFIG_XEN_PVHVM\n\treturn xen_store_domain_type == XS_HVM &&\n\t\t!xen_have_vector_callback;\n#else\n\treturn false;\n#endif\n}\n\nstatic int xenbus_probe_thread(void *unused)\n{\n\tDEFINE_WAIT(w);\n\n\t \n\tprepare_to_wait(&xb_waitq, &w, TASK_INTERRUPTIBLE);\n\tschedule();\n\tfinish_wait(&xb_waitq, &w);\n\n\tDPRINTK(\"probing\");\n\txenbus_probe();\n\treturn 0;\n}\n\nstatic int __init xenbus_probe_initcall(void)\n{\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\t \n\tif (xen_store_domain_type == XS_PV ||\n\t    (xen_store_domain_type == XS_HVM &&\n\t     !xs_hvm_defer_init_for_callback() &&\n\t     xen_store_interface != NULL))\n\t\txenbus_probe();\n\n\t \n\tif (xen_store_domain_type == XS_LOCAL || xen_store_interface == NULL) {\n\t\tstruct task_struct *probe_task;\n\n\t\tprobe_task = kthread_run(xenbus_probe_thread, NULL,\n\t\t\t\t\t \"xenbus_probe\");\n\t\tif (IS_ERR(probe_task))\n\t\t\treturn PTR_ERR(probe_task);\n\t}\n\treturn 0;\n}\ndevice_initcall(xenbus_probe_initcall);\n\nint xen_set_callback_via(uint64_t via)\n{\n\tstruct xen_hvm_param a;\n\tint ret;\n\n\ta.domid = DOMID_SELF;\n\ta.index = HVM_PARAM_CALLBACK_IRQ;\n\ta.value = via;\n\n\tret = HYPERVISOR_hvm_op(HVMOP_set_param, &a);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!xenstored_ready && xs_hvm_defer_init_for_callback())\n\t\txenbus_probe();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xen_set_callback_via);\n\n \nstatic int __init xenstored_local_init(void)\n{\n\tint err = -ENOMEM;\n\tunsigned long page = 0;\n\tstruct evtchn_alloc_unbound alloc_unbound;\n\n\t \n\tpage = get_zeroed_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto out_err;\n\n\txen_store_gfn = virt_to_gfn((void *)page);\n\n\t \n\talloc_unbound.dom        = DOMID_SELF;\n\talloc_unbound.remote_dom = DOMID_SELF;\n\n\terr = HYPERVISOR_event_channel_op(EVTCHNOP_alloc_unbound,\n\t\t\t\t\t  &alloc_unbound);\n\tif (err == -ENOSYS)\n\t\tgoto out_err;\n\n\tBUG_ON(err);\n\txen_store_evtchn = alloc_unbound.port;\n\n\treturn 0;\n\n out_err:\n\tif (page != 0)\n\t\tfree_page(page);\n\treturn err;\n}\n\nstatic int xenbus_resume_cb(struct notifier_block *nb,\n\t\t\t    unsigned long action, void *data)\n{\n\tint err = 0;\n\n\tif (xen_hvm_domain()) {\n\t\tuint64_t v = 0;\n\n\t\terr = hvm_get_parameter(HVM_PARAM_STORE_EVTCHN, &v);\n\t\tif (!err && v)\n\t\t\txen_store_evtchn = v;\n\t\telse\n\t\t\tpr_warn(\"Cannot update xenstore event channel: %d\\n\",\n\t\t\t\terr);\n\t} else\n\t\txen_store_evtchn = xen_start_info->store_evtchn;\n\n\treturn err;\n}\n\nstatic struct notifier_block xenbus_resume_nb = {\n\t.notifier_call = xenbus_resume_cb,\n};\n\nstatic irqreturn_t xenbus_late_init(int irq, void *unused)\n{\n\tint err;\n\tuint64_t v = 0;\n\n\terr = hvm_get_parameter(HVM_PARAM_STORE_PFN, &v);\n\tif (err || !v || !~v)\n\t\treturn IRQ_HANDLED;\n\txen_store_gfn = (unsigned long)v;\n\n\twake_up(&xb_waitq);\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init xenbus_init(void)\n{\n\tint err;\n\tuint64_t v = 0;\n\tbool wait = false;\n\txen_store_domain_type = XS_UNKNOWN;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\txenbus_ring_ops_init();\n\n\tif (xen_pv_domain())\n\t\txen_store_domain_type = XS_PV;\n\tif (xen_hvm_domain())\n\t\txen_store_domain_type = XS_HVM;\n\tif (xen_hvm_domain() && xen_initial_domain())\n\t\txen_store_domain_type = XS_LOCAL;\n\tif (xen_pv_domain() && !xen_start_info->store_evtchn)\n\t\txen_store_domain_type = XS_LOCAL;\n\tif (xen_pv_domain() && xen_start_info->store_evtchn)\n\t\txenstored_ready = 1;\n\n\tswitch (xen_store_domain_type) {\n\tcase XS_LOCAL:\n\t\terr = xenstored_local_init();\n\t\tif (err)\n\t\t\tgoto out_error;\n\t\txen_store_interface = gfn_to_virt(xen_store_gfn);\n\t\tbreak;\n\tcase XS_PV:\n\t\txen_store_evtchn = xen_start_info->store_evtchn;\n\t\txen_store_gfn = xen_start_info->store_mfn;\n\t\txen_store_interface = gfn_to_virt(xen_store_gfn);\n\t\tbreak;\n\tcase XS_HVM:\n\t\terr = hvm_get_parameter(HVM_PARAM_STORE_EVTCHN, &v);\n\t\tif (err)\n\t\t\tgoto out_error;\n\t\txen_store_evtchn = (int)v;\n\t\terr = hvm_get_parameter(HVM_PARAM_STORE_PFN, &v);\n\t\tif (err)\n\t\t\tgoto out_error;\n\t\t \n\t\tif (!v) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (v == ~0ULL) {\n\t\t\twait = true;\n\t\t} else {\n\t\t\t \n#if BITS_PER_LONG == 32\n\t\t\tif (v > ULONG_MAX) {\n\t\t\t\tpr_err(\"%s: cannot handle HVM_PARAM_STORE_PFN=%llx > ULONG_MAX\\n\",\n\t\t\t\t       __func__, v);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_error;\n\t\t\t}\n#endif\n\t\t\txen_store_gfn = (unsigned long)v;\n\t\t\txen_store_interface =\n\t\t\t\tmemremap(xen_store_gfn << XEN_PAGE_SHIFT,\n\t\t\t\t\t XEN_PAGE_SIZE, MEMREMAP_WB);\n\t\t\tif (xen_store_interface->connection != XENSTORE_CONNECTED)\n\t\t\t\twait = true;\n\t\t}\n\t\tif (wait) {\n\t\t\terr = bind_evtchn_to_irqhandler(xen_store_evtchn,\n\t\t\t\t\t\t\txenbus_late_init,\n\t\t\t\t\t\t\t0, \"xenstore_late_init\",\n\t\t\t\t\t\t\t&xb_waitq);\n\t\t\tif (err < 0) {\n\t\t\t\tpr_err(\"xenstore_late_init couldn't bind irq err=%d\\n\",\n\t\t\t\t       err);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\n\t\t\txs_init_irq = err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Xenstore state unknown\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tif (xen_store_domain_type != XS_HVM) {\n\t\terr = xs_init();\n\t\tif (err) {\n\t\t\tpr_warn(\"Error initializing xenstore comms: %i\\n\", err);\n\t\t\tgoto out_error;\n\t\t}\n\t}\n\n\tif ((xen_store_domain_type != XS_LOCAL) &&\n\t    (xen_store_domain_type != XS_UNKNOWN))\n\t\txen_resume_notifier_register(&xenbus_resume_nb);\n\n#ifdef CONFIG_XEN_COMPAT_XENFS\n\t \n\tproc_create_mount_point(\"xen\");\n#endif\n\treturn 0;\n\nout_error:\n\txen_store_domain_type = XS_UNKNOWN;\n\treturn err;\n}\n\npostcore_initcall(xenbus_init);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}