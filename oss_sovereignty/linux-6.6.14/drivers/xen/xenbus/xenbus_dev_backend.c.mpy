{
  "module_name": "xenbus_dev_backend.c",
  "hash_id": "d54ef575f8ccb3350c6d437a571ba8d8af221b18242f6bfa94ac6ce737075d37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xenbus/xenbus_dev_backend.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n\n#include <xen/xen.h>\n#include <xen/page.h>\n#include <xen/xenbus.h>\n#include <xen/xenbus_dev.h>\n#include <xen/grant_table.h>\n#include <xen/events.h>\n#include <asm/xen/hypervisor.h>\n\n#include \"xenbus.h\"\n\nstatic int xenbus_backend_open(struct inode *inode, struct file *filp)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn nonseekable_open(inode, filp);\n}\n\nstatic long xenbus_alloc(domid_t domid)\n{\n\tstruct evtchn_alloc_unbound arg;\n\tint err = -EEXIST;\n\n\txs_suspend();\n\n\t \n\tif (xenstored_ready)\n\t\tgoto out_err;\n\n\tgnttab_grant_foreign_access_ref(GNTTAB_RESERVED_XENSTORE, domid,\n\t\t\tvirt_to_gfn(xen_store_interface), 0  );\n\n\targ.dom = DOMID_SELF;\n\targ.remote_dom = domid;\n\n\terr = HYPERVISOR_event_channel_op(EVTCHNOP_alloc_unbound, &arg);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (xen_store_evtchn > 0)\n\t\txb_deinit_comms();\n\n\txen_store_evtchn = arg.port;\n\n\txs_resume();\n\n\treturn arg.port;\n\n out_err:\n\txs_suspend_cancel();\n\treturn err;\n}\n\nstatic long xenbus_backend_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long data)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase IOCTL_XENBUS_BACKEND_EVTCHN:\n\t\tif (xen_store_evtchn > 0)\n\t\t\treturn xen_store_evtchn;\n\t\treturn -ENODEV;\n\tcase IOCTL_XENBUS_BACKEND_SETUP:\n\t\treturn xenbus_alloc(data);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic int xenbus_backend_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tsize_t size = vma->vm_end - vma->vm_start;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((size > PAGE_SIZE) || (vma->vm_pgoff != 0))\n\t\treturn -EINVAL;\n\n\tif (remap_pfn_range(vma, vma->vm_start,\n\t\t\t    virt_to_pfn(xen_store_interface),\n\t\t\t    size, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic const struct file_operations xenbus_backend_fops = {\n\t.open = xenbus_backend_open,\n\t.mmap = xenbus_backend_mmap,\n\t.unlocked_ioctl = xenbus_backend_ioctl,\n};\n\nstatic struct miscdevice xenbus_backend_dev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"xen/xenbus_backend\",\n\t.fops = &xenbus_backend_fops,\n};\n\nstatic int __init xenbus_backend_init(void)\n{\n\tint err;\n\n\tif (!xen_initial_domain())\n\t\treturn -ENODEV;\n\n\terr = misc_register(&xenbus_backend_dev);\n\tif (err)\n\t\tpr_err(\"Could not register xenbus backend device\\n\");\n\treturn err;\n}\ndevice_initcall(xenbus_backend_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}