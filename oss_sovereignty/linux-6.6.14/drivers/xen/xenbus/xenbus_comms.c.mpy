{
  "module_name": "xenbus_comms.c",
  "hash_id": "0e8cfdb872d0d6b8c4a0147d827e317bccc70778ea7324b096fc217cefe10b3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xenbus/xenbus_comms.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/wait.h>\n#include <linux/interrupt.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <xen/xenbus.h>\n#include <asm/xen/hypervisor.h>\n#include <xen/events.h>\n#include <xen/page.h>\n#include \"xenbus.h\"\n\n \nLIST_HEAD(xs_reply_list);\n\n \nLIST_HEAD(xb_write_list);\nDECLARE_WAIT_QUEUE_HEAD(xb_waitq);\nDEFINE_MUTEX(xb_write_mutex);\n\n \nDEFINE_MUTEX(xs_response_mutex);\n\nstatic int xenbus_irq;\nstatic struct task_struct *xenbus_task;\n\nstatic irqreturn_t wake_waiting(int irq, void *unused)\n{\n\twake_up(&xb_waitq);\n\treturn IRQ_HANDLED;\n}\n\nstatic int check_indexes(XENSTORE_RING_IDX cons, XENSTORE_RING_IDX prod)\n{\n\treturn ((prod - cons) <= XENSTORE_RING_SIZE);\n}\n\nstatic void *get_output_chunk(XENSTORE_RING_IDX cons,\n\t\t\t      XENSTORE_RING_IDX prod,\n\t\t\t      char *buf, uint32_t *len)\n{\n\t*len = XENSTORE_RING_SIZE - MASK_XENSTORE_IDX(prod);\n\tif ((XENSTORE_RING_SIZE - (prod - cons)) < *len)\n\t\t*len = XENSTORE_RING_SIZE - (prod - cons);\n\treturn buf + MASK_XENSTORE_IDX(prod);\n}\n\nstatic const void *get_input_chunk(XENSTORE_RING_IDX cons,\n\t\t\t\t   XENSTORE_RING_IDX prod,\n\t\t\t\t   const char *buf, uint32_t *len)\n{\n\t*len = XENSTORE_RING_SIZE - MASK_XENSTORE_IDX(cons);\n\tif ((prod - cons) < *len)\n\t\t*len = prod - cons;\n\treturn buf + MASK_XENSTORE_IDX(cons);\n}\n\nstatic int xb_data_to_write(void)\n{\n\tstruct xenstore_domain_interface *intf = xen_store_interface;\n\n\treturn (intf->req_prod - intf->req_cons) != XENSTORE_RING_SIZE &&\n\t\t!list_empty(&xb_write_list);\n}\n\n \nstatic int xb_write(const void *data, unsigned int len)\n{\n\tstruct xenstore_domain_interface *intf = xen_store_interface;\n\tXENSTORE_RING_IDX cons, prod;\n\tunsigned int bytes = 0;\n\n\twhile (len != 0) {\n\t\tvoid *dst;\n\t\tunsigned int avail;\n\n\t\t \n\t\tcons = intf->req_cons;\n\t\tprod = intf->req_prod;\n\t\tif (!check_indexes(cons, prod)) {\n\t\t\tintf->req_cons = intf->req_prod = 0;\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!xb_data_to_write())\n\t\t\treturn bytes;\n\n\t\t \n\t\tvirt_mb();\n\n\t\tdst = get_output_chunk(cons, prod, intf->req, &avail);\n\t\tif (avail == 0)\n\t\t\tcontinue;\n\t\tif (avail > len)\n\t\t\tavail = len;\n\n\t\tmemcpy(dst, data, avail);\n\t\tdata += avail;\n\t\tlen -= avail;\n\t\tbytes += avail;\n\n\t\t \n\t\tvirt_wmb();\n\t\tintf->req_prod += avail;\n\n\t\t \n\t\tif (prod <= intf->req_cons)\n\t\t\tnotify_remote_via_evtchn(xen_store_evtchn);\n\t}\n\n\treturn bytes;\n}\n\nstatic int xb_data_to_read(void)\n{\n\tstruct xenstore_domain_interface *intf = xen_store_interface;\n\treturn (intf->rsp_cons != intf->rsp_prod);\n}\n\nstatic int xb_read(void *data, unsigned int len)\n{\n\tstruct xenstore_domain_interface *intf = xen_store_interface;\n\tXENSTORE_RING_IDX cons, prod;\n\tunsigned int bytes = 0;\n\n\twhile (len != 0) {\n\t\tunsigned int avail;\n\t\tconst char *src;\n\n\t\t \n\t\tcons = intf->rsp_cons;\n\t\tprod = intf->rsp_prod;\n\t\tif (cons == prod)\n\t\t\treturn bytes;\n\n\t\tif (!check_indexes(cons, prod)) {\n\t\t\tintf->rsp_cons = intf->rsp_prod = 0;\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tsrc = get_input_chunk(cons, prod, intf->rsp, &avail);\n\t\tif (avail == 0)\n\t\t\tcontinue;\n\t\tif (avail > len)\n\t\t\tavail = len;\n\n\t\t \n\t\tvirt_rmb();\n\n\t\tmemcpy(data, src, avail);\n\t\tdata += avail;\n\t\tlen -= avail;\n\t\tbytes += avail;\n\n\t\t \n\t\tvirt_mb();\n\t\tintf->rsp_cons += avail;\n\n\t\t \n\t\tif (intf->rsp_prod - cons >= XENSTORE_RING_SIZE)\n\t\t\tnotify_remote_via_evtchn(xen_store_evtchn);\n\t}\n\n\treturn bytes;\n}\n\nstatic int process_msg(void)\n{\n\tstatic struct {\n\t\tstruct xsd_sockmsg msg;\n\t\tchar *body;\n\t\tunion {\n\t\t\tvoid *alloc;\n\t\t\tstruct xs_watch_event *watch;\n\t\t};\n\t\tbool in_msg;\n\t\tbool in_hdr;\n\t\tunsigned int read;\n\t} state;\n\tstruct xb_req_data *req;\n\tint err;\n\tunsigned int len;\n\n\tif (!state.in_msg) {\n\t\tstate.in_msg = true;\n\t\tstate.in_hdr = true;\n\t\tstate.read = 0;\n\n\t\t \n\t\tmutex_lock(&xs_response_mutex);\n\n\t\tif (!xb_data_to_read()) {\n\t\t\t \n\t\t\tmutex_unlock(&xs_response_mutex);\n\t\t\tstate.in_msg = false;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (state.in_hdr) {\n\t\tif (state.read != sizeof(state.msg)) {\n\t\t\terr = xb_read((void *)&state.msg + state.read,\n\t\t\t\t      sizeof(state.msg) - state.read);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\tstate.read += err;\n\t\t\tif (state.read != sizeof(state.msg))\n\t\t\t\treturn 0;\n\t\t\tif (state.msg.len > XENSTORE_PAYLOAD_MAX) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tlen = state.msg.len + 1;\n\t\tif (state.msg.type == XS_WATCH_EVENT)\n\t\t\tlen += sizeof(*state.watch);\n\n\t\tstate.alloc = kmalloc(len, GFP_NOIO | __GFP_HIGH);\n\t\tif (!state.alloc)\n\t\t\treturn -ENOMEM;\n\n\t\tif (state.msg.type == XS_WATCH_EVENT)\n\t\t\tstate.body = state.watch->body;\n\t\telse\n\t\t\tstate.body = state.alloc;\n\t\tstate.in_hdr = false;\n\t\tstate.read = 0;\n\t}\n\n\terr = xb_read(state.body + state.read, state.msg.len - state.read);\n\tif (err < 0)\n\t\tgoto out;\n\n\tstate.read += err;\n\tif (state.read != state.msg.len)\n\t\treturn 0;\n\n\tstate.body[state.msg.len] = '\\0';\n\n\tif (state.msg.type == XS_WATCH_EVENT) {\n\t\tstate.watch->len = state.msg.len;\n\t\terr = xs_watch_msg(state.watch);\n\t} else {\n\t\terr = -ENOENT;\n\t\tmutex_lock(&xb_write_mutex);\n\t\tlist_for_each_entry(req, &xs_reply_list, list) {\n\t\t\tif (req->msg.req_id == state.msg.req_id) {\n\t\t\t\tlist_del(&req->list);\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&xb_write_mutex);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (req->state == xb_req_state_wait_reply) {\n\t\t\treq->msg.req_id = req->caller_req_id;\n\t\t\treq->msg.type = state.msg.type;\n\t\t\treq->msg.len = state.msg.len;\n\t\t\treq->body = state.body;\n\t\t\t \n\t\t\tvirt_wmb();\n\t\t\treq->state = xb_req_state_got_reply;\n\t\t\treq->cb(req);\n\t\t} else\n\t\t\tkfree(req);\n\t}\n\n\tmutex_unlock(&xs_response_mutex);\n\n\tstate.in_msg = false;\n\tstate.alloc = NULL;\n\treturn err;\n\n out:\n\tmutex_unlock(&xs_response_mutex);\n\tstate.in_msg = false;\n\tkfree(state.alloc);\n\tstate.alloc = NULL;\n\treturn err;\n}\n\nstatic int process_writes(void)\n{\n\tstatic struct {\n\t\tstruct xb_req_data *req;\n\t\tint idx;\n\t\tunsigned int written;\n\t} state;\n\tvoid *base;\n\tunsigned int len;\n\tint err = 0;\n\n\tif (!xb_data_to_write())\n\t\treturn 0;\n\n\tmutex_lock(&xb_write_mutex);\n\n\tif (!state.req) {\n\t\tstate.req = list_first_entry(&xb_write_list,\n\t\t\t\t\t     struct xb_req_data, list);\n\t\tstate.idx = -1;\n\t\tstate.written = 0;\n\t}\n\n\tif (state.req->state == xb_req_state_aborted)\n\t\tgoto out_err;\n\n\twhile (state.idx < state.req->num_vecs) {\n\t\tif (state.idx < 0) {\n\t\t\tbase = &state.req->msg;\n\t\t\tlen = sizeof(state.req->msg);\n\t\t} else {\n\t\t\tbase = state.req->vec[state.idx].iov_base;\n\t\t\tlen = state.req->vec[state.idx].iov_len;\n\t\t}\n\t\terr = xb_write(base + state.written, len - state.written);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tstate.written += err;\n\t\tif (state.written != len)\n\t\t\tgoto out;\n\n\t\tstate.idx++;\n\t\tstate.written = 0;\n\t}\n\n\tlist_del(&state.req->list);\n\tstate.req->state = xb_req_state_wait_reply;\n\tlist_add_tail(&state.req->list, &xs_reply_list);\n\tstate.req = NULL;\n\n out:\n\tmutex_unlock(&xb_write_mutex);\n\n\treturn 0;\n\n out_err:\n\tstate.req->msg.type = XS_ERROR;\n\tstate.req->err = err;\n\tlist_del(&state.req->list);\n\tif (state.req->state == xb_req_state_aborted)\n\t\tkfree(state.req);\n\telse {\n\t\t \n\t\tvirt_wmb();\n\t\tstate.req->state = xb_req_state_got_reply;\n\t\twake_up(&state.req->wq);\n\t}\n\n\tmutex_unlock(&xb_write_mutex);\n\n\tstate.req = NULL;\n\n\treturn err;\n}\n\nstatic int xb_thread_work(void)\n{\n\treturn xb_data_to_read() || xb_data_to_write();\n}\n\nstatic int xenbus_thread(void *unused)\n{\n\tint err;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (wait_event_interruptible(xb_waitq, xb_thread_work()))\n\t\t\tcontinue;\n\n\t\terr = process_msg();\n\t\tif (err == -ENOMEM)\n\t\t\tschedule();\n\t\telse if (err)\n\t\t\tpr_warn_ratelimited(\"error %d while reading message\\n\",\n\t\t\t\t\t    err);\n\n\t\terr = process_writes();\n\t\tif (err)\n\t\t\tpr_warn_ratelimited(\"error %d while writing message\\n\",\n\t\t\t\t\t    err);\n\t}\n\n\txenbus_task = NULL;\n\treturn 0;\n}\n\n \nint xb_init_comms(void)\n{\n\tstruct xenstore_domain_interface *intf = xen_store_interface;\n\n\tif (intf->req_prod != intf->req_cons)\n\t\tpr_err(\"request ring is not quiescent (%08x:%08x)!\\n\",\n\t\t       intf->req_cons, intf->req_prod);\n\n\tif (intf->rsp_prod != intf->rsp_cons) {\n\t\tpr_warn(\"response ring is not quiescent (%08x:%08x): fixing up\\n\",\n\t\t\tintf->rsp_cons, intf->rsp_prod);\n\t\t \n\t\tif (!reset_devices)\n\t\t\tintf->rsp_cons = intf->rsp_prod;\n\t}\n\n\tif (xenbus_irq) {\n\t\t \n\t\trebind_evtchn_irq(xen_store_evtchn, xenbus_irq);\n\t} else {\n\t\tint err;\n\n\t\terr = bind_evtchn_to_irqhandler(xen_store_evtchn, wake_waiting,\n\t\t\t\t\t\t0, \"xenbus\", &xb_waitq);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"request irq failed %i\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\txenbus_irq = err;\n\n\t\tif (!xenbus_task) {\n\t\t\txenbus_task = kthread_run(xenbus_thread, NULL,\n\t\t\t\t\t\t  \"xenbus\");\n\t\t\tif (IS_ERR(xenbus_task))\n\t\t\t\treturn PTR_ERR(xenbus_task);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid xb_deinit_comms(void)\n{\n\tunbind_from_irqhandler(xenbus_irq, &xb_waitq);\n\txenbus_irq = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}