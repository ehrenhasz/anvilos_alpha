{
  "module_name": "xenbus_xs.c",
  "hash_id": "72ee9a1eb2cae5303b7be10a960f157a342edd56c831ee02a72b618142a70ea3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xenbus/xenbus_xs.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/kthread.h>\n#include <linux/reboot.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <asm/xen/hypervisor.h>\n#include <xen/xenbus.h>\n#include <xen/xen.h>\n#include \"xenbus.h\"\n\n \n\n \nstatic DEFINE_SPINLOCK(xs_state_lock);\n \nstatic unsigned int xs_state_users;\n \nstatic int xs_suspend_active;\n \nstatic uint32_t xs_request_id;\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(xs_state_enter_wq);\n \nstatic DECLARE_WAIT_QUEUE_HEAD(xs_state_exit_wq);\n\n \nstatic LIST_HEAD(watches);\nstatic DEFINE_SPINLOCK(watches_lock);\n\n \nstatic LIST_HEAD(watch_events);\nstatic DEFINE_SPINLOCK(watch_events_lock);\n\n \nstatic DECLARE_RWSEM(xs_watch_rwsem);\n\n \nstatic pid_t xenwatch_pid;\nstatic DEFINE_MUTEX(xenwatch_mutex);\nstatic DECLARE_WAIT_QUEUE_HEAD(watch_events_waitq);\n\nstatic void xs_suspend_enter(void)\n{\n\tspin_lock(&xs_state_lock);\n\txs_suspend_active++;\n\tspin_unlock(&xs_state_lock);\n\twait_event(xs_state_exit_wq, xs_state_users == 0);\n}\n\nstatic void xs_suspend_exit(void)\n{\n\txb_dev_generation_id++;\n\tspin_lock(&xs_state_lock);\n\txs_suspend_active--;\n\tspin_unlock(&xs_state_lock);\n\twake_up_all(&xs_state_enter_wq);\n}\n\nstatic uint32_t xs_request_enter(struct xb_req_data *req)\n{\n\tuint32_t rq_id;\n\n\treq->type = req->msg.type;\n\n\tspin_lock(&xs_state_lock);\n\n\twhile (!xs_state_users && xs_suspend_active) {\n\t\tspin_unlock(&xs_state_lock);\n\t\twait_event(xs_state_enter_wq, xs_suspend_active == 0);\n\t\tspin_lock(&xs_state_lock);\n\t}\n\n\tif (req->type == XS_TRANSACTION_START && !req->user_req)\n\t\txs_state_users++;\n\txs_state_users++;\n\trq_id = xs_request_id++;\n\n\tspin_unlock(&xs_state_lock);\n\n\treturn rq_id;\n}\n\nvoid xs_request_exit(struct xb_req_data *req)\n{\n\tspin_lock(&xs_state_lock);\n\txs_state_users--;\n\tif ((req->type == XS_TRANSACTION_START && req->msg.type == XS_ERROR) ||\n\t    (req->type == XS_TRANSACTION_END && !req->user_req &&\n\t     !WARN_ON_ONCE(req->msg.type == XS_ERROR &&\n\t\t\t   !strcmp(req->body, \"ENOENT\"))))\n\t\txs_state_users--;\n\tspin_unlock(&xs_state_lock);\n\n\tif (xs_suspend_active && !xs_state_users)\n\t\twake_up(&xs_state_exit_wq);\n}\n\nstatic int get_error(const char *errorstring)\n{\n\tunsigned int i;\n\n\tfor (i = 0; strcmp(errorstring, xsd_errors[i].errstring) != 0; i++) {\n\t\tif (i == ARRAY_SIZE(xsd_errors) - 1) {\n\t\t\tpr_warn(\"xen store gave: unknown error %s\\n\",\n\t\t\t\terrorstring);\n\t\t\treturn EINVAL;\n\t\t}\n\t}\n\treturn xsd_errors[i].errnum;\n}\n\nstatic bool xenbus_ok(void)\n{\n\tswitch (xen_store_domain_type) {\n\tcase XS_LOCAL:\n\t\tswitch (system_state) {\n\t\tcase SYSTEM_POWER_OFF:\n\t\tcase SYSTEM_RESTART:\n\t\tcase SYSTEM_HALT:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\tcase XS_PV:\n\tcase XS_HVM:\n\t\t \n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic bool test_reply(struct xb_req_data *req)\n{\n\tif (req->state == xb_req_state_got_reply || !xenbus_ok()) {\n\t\t \n\t\tvirt_rmb();\n\t\treturn true;\n\t}\n\n\t \n\tbarrier();\n\n\treturn false;\n}\n\nstatic void *read_reply(struct xb_req_data *req)\n{\n\tdo {\n\t\twait_event(req->wq, test_reply(req));\n\n\t\tif (!xenbus_ok())\n\t\t\t \n\t\t\treturn ERR_PTR(-EIO);\n\t\tif (req->err)\n\t\t\treturn ERR_PTR(req->err);\n\n\t} while (req->state != xb_req_state_got_reply);\n\n\treturn req->body;\n}\n\nstatic void xs_send(struct xb_req_data *req, struct xsd_sockmsg *msg)\n{\n\tbool notify;\n\n\treq->msg = *msg;\n\treq->err = 0;\n\treq->state = xb_req_state_queued;\n\tinit_waitqueue_head(&req->wq);\n\n\t \n\treq->caller_req_id = req->msg.req_id;\n\treq->msg.req_id = xs_request_enter(req);\n\n\tmutex_lock(&xb_write_mutex);\n\tlist_add_tail(&req->list, &xb_write_list);\n\tnotify = list_is_singular(&xb_write_list);\n\tmutex_unlock(&xb_write_mutex);\n\n\tif (notify)\n\t\twake_up(&xb_waitq);\n}\n\nstatic void *xs_wait_for_reply(struct xb_req_data *req, struct xsd_sockmsg *msg)\n{\n\tvoid *ret;\n\n\tret = read_reply(req);\n\n\txs_request_exit(req);\n\n\tmsg->type = req->msg.type;\n\tmsg->len = req->msg.len;\n\n\tmutex_lock(&xb_write_mutex);\n\tif (req->state == xb_req_state_queued ||\n\t    req->state == xb_req_state_wait_reply)\n\t\treq->state = xb_req_state_aborted;\n\telse\n\t\tkfree(req);\n\tmutex_unlock(&xb_write_mutex);\n\n\treturn ret;\n}\n\nstatic void xs_wake_up(struct xb_req_data *req)\n{\n\twake_up(&req->wq);\n}\n\nint xenbus_dev_request_and_reply(struct xsd_sockmsg *msg, void *par)\n{\n\tstruct xb_req_data *req;\n\tstruct kvec *vec;\n\n\treq = kmalloc(sizeof(*req) + sizeof(*vec), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tvec = (struct kvec *)(req + 1);\n\tvec->iov_len = msg->len;\n\tvec->iov_base = msg + 1;\n\n\treq->vec = vec;\n\treq->num_vecs = 1;\n\treq->cb = xenbus_dev_queue_reply;\n\treq->par = par;\n\treq->user_req = true;\n\n\txs_send(req, msg);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(xenbus_dev_request_and_reply);\n\n \nstatic void *xs_talkv(struct xenbus_transaction t,\n\t\t      enum xsd_sockmsg_type type,\n\t\t      const struct kvec *iovec,\n\t\t      unsigned int num_vecs,\n\t\t      unsigned int *len)\n{\n\tstruct xb_req_data *req;\n\tstruct xsd_sockmsg msg;\n\tvoid *ret = NULL;\n\tunsigned int i;\n\tint err;\n\n\treq = kmalloc(sizeof(*req), GFP_NOIO | __GFP_HIGH);\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treq->vec = iovec;\n\treq->num_vecs = num_vecs;\n\treq->cb = xs_wake_up;\n\treq->user_req = false;\n\n\tmsg.req_id = 0;\n\tmsg.tx_id = t.id;\n\tmsg.type = type;\n\tmsg.len = 0;\n\tfor (i = 0; i < num_vecs; i++)\n\t\tmsg.len += iovec[i].iov_len;\n\n\txs_send(req, &msg);\n\n\tret = xs_wait_for_reply(req, &msg);\n\tif (len)\n\t\t*len = msg.len;\n\n\tif (IS_ERR(ret))\n\t\treturn ret;\n\n\tif (msg.type == XS_ERROR) {\n\t\terr = get_error(ret);\n\t\tkfree(ret);\n\t\treturn ERR_PTR(-err);\n\t}\n\n\tif (msg.type != type) {\n\t\tpr_warn_ratelimited(\"unexpected type [%d], expected [%d]\\n\",\n\t\t\t\t    msg.type, type);\n\t\tkfree(ret);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\treturn ret;\n}\n\n \nstatic void *xs_single(struct xenbus_transaction t,\n\t\t       enum xsd_sockmsg_type type,\n\t\t       const char *string,\n\t\t       unsigned int *len)\n{\n\tstruct kvec iovec;\n\n\tiovec.iov_base = (void *)string;\n\tiovec.iov_len = strlen(string) + 1;\n\treturn xs_talkv(t, type, &iovec, 1, len);\n}\n\n \nstatic int xs_error(char *reply)\n{\n\tif (IS_ERR(reply))\n\t\treturn PTR_ERR(reply);\n\tkfree(reply);\n\treturn 0;\n}\n\nstatic unsigned int count_strings(const char *strings, unsigned int len)\n{\n\tunsigned int num;\n\tconst char *p;\n\n\tfor (p = strings, num = 0; p < strings + len; p += strlen(p) + 1)\n\t\tnum++;\n\n\treturn num;\n}\n\n \nstatic char *join(const char *dir, const char *name)\n{\n\tchar *buffer;\n\n\tif (strlen(name) == 0)\n\t\tbuffer = kasprintf(GFP_NOIO | __GFP_HIGH, \"%s\", dir);\n\telse\n\t\tbuffer = kasprintf(GFP_NOIO | __GFP_HIGH, \"%s/%s\", dir, name);\n\treturn (!buffer) ? ERR_PTR(-ENOMEM) : buffer;\n}\n\nstatic char **split(char *strings, unsigned int len, unsigned int *num)\n{\n\tchar *p, **ret;\n\n\t \n\t*num = count_strings(strings, len);\n\n\t \n\tret = kmalloc(*num * sizeof(char *) + len, GFP_NOIO | __GFP_HIGH);\n\tif (!ret) {\n\t\tkfree(strings);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmemcpy(&ret[*num], strings, len);\n\tkfree(strings);\n\n\tstrings = (char *)&ret[*num];\n\tfor (p = strings, *num = 0; p < strings + len; p += strlen(p) + 1)\n\t\tret[(*num)++] = p;\n\n\treturn ret;\n}\n\nchar **xenbus_directory(struct xenbus_transaction t,\n\t\t\tconst char *dir, const char *node, unsigned int *num)\n{\n\tchar *strings, *path;\n\tunsigned int len;\n\n\tpath = join(dir, node);\n\tif (IS_ERR(path))\n\t\treturn (char **)path;\n\n\tstrings = xs_single(t, XS_DIRECTORY, path, &len);\n\tkfree(path);\n\tif (IS_ERR(strings))\n\t\treturn (char **)strings;\n\n\treturn split(strings, len, num);\n}\nEXPORT_SYMBOL_GPL(xenbus_directory);\n\n \nint xenbus_exists(struct xenbus_transaction t,\n\t\t  const char *dir, const char *node)\n{\n\tchar **d;\n\tint dir_n;\n\n\td = xenbus_directory(t, dir, node, &dir_n);\n\tif (IS_ERR(d))\n\t\treturn 0;\n\tkfree(d);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(xenbus_exists);\n\n \nvoid *xenbus_read(struct xenbus_transaction t,\n\t\t  const char *dir, const char *node, unsigned int *len)\n{\n\tchar *path;\n\tvoid *ret;\n\n\tpath = join(dir, node);\n\tif (IS_ERR(path))\n\t\treturn (void *)path;\n\n\tret = xs_single(t, XS_READ, path, len);\n\tkfree(path);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xenbus_read);\n\n \nint xenbus_write(struct xenbus_transaction t,\n\t\t const char *dir, const char *node, const char *string)\n{\n\tconst char *path;\n\tstruct kvec iovec[2];\n\tint ret;\n\n\tpath = join(dir, node);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tiovec[0].iov_base = (void *)path;\n\tiovec[0].iov_len = strlen(path) + 1;\n\tiovec[1].iov_base = (void *)string;\n\tiovec[1].iov_len = strlen(string);\n\n\tret = xs_error(xs_talkv(t, XS_WRITE, iovec, ARRAY_SIZE(iovec), NULL));\n\tkfree(path);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xenbus_write);\n\n \nint xenbus_mkdir(struct xenbus_transaction t,\n\t\t const char *dir, const char *node)\n{\n\tchar *path;\n\tint ret;\n\n\tpath = join(dir, node);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tret = xs_error(xs_single(t, XS_MKDIR, path, NULL));\n\tkfree(path);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xenbus_mkdir);\n\n \nint xenbus_rm(struct xenbus_transaction t, const char *dir, const char *node)\n{\n\tchar *path;\n\tint ret;\n\n\tpath = join(dir, node);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tret = xs_error(xs_single(t, XS_RM, path, NULL));\n\tkfree(path);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xenbus_rm);\n\n \nint xenbus_transaction_start(struct xenbus_transaction *t)\n{\n\tchar *id_str;\n\n\tid_str = xs_single(XBT_NIL, XS_TRANSACTION_START, \"\", NULL);\n\tif (IS_ERR(id_str))\n\t\treturn PTR_ERR(id_str);\n\n\tt->id = simple_strtoul(id_str, NULL, 0);\n\tkfree(id_str);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xenbus_transaction_start);\n\n \nint xenbus_transaction_end(struct xenbus_transaction t, int abort)\n{\n\tchar abortstr[2];\n\n\tif (abort)\n\t\tstrcpy(abortstr, \"F\");\n\telse\n\t\tstrcpy(abortstr, \"T\");\n\n\treturn xs_error(xs_single(t, XS_TRANSACTION_END, abortstr, NULL));\n}\nEXPORT_SYMBOL_GPL(xenbus_transaction_end);\n\n \nint xenbus_scanf(struct xenbus_transaction t,\n\t\t const char *dir, const char *node, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tchar *val;\n\n\tval = xenbus_read(t, dir, node, NULL);\n\tif (IS_ERR(val))\n\t\treturn PTR_ERR(val);\n\n\tva_start(ap, fmt);\n\tret = vsscanf(val, fmt, ap);\n\tva_end(ap);\n\tkfree(val);\n\t \n\tif (ret == 0)\n\t\treturn -ERANGE;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xenbus_scanf);\n\n \nunsigned int xenbus_read_unsigned(const char *dir, const char *node,\n\t\t\t\t  unsigned int default_val)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = xenbus_scanf(XBT_NIL, dir, node, \"%u\", &val);\n\tif (ret <= 0)\n\t\tval = default_val;\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(xenbus_read_unsigned);\n\n \nint xenbus_printf(struct xenbus_transaction t,\n\t\t  const char *dir, const char *node, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tchar *buf;\n\n\tva_start(ap, fmt);\n\tbuf = kvasprintf(GFP_NOIO | __GFP_HIGH, fmt, ap);\n\tva_end(ap);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = xenbus_write(t, dir, node, buf);\n\n\tkfree(buf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xenbus_printf);\n\n \nint xenbus_gather(struct xenbus_transaction t, const char *dir, ...)\n{\n\tva_list ap;\n\tconst char *name;\n\tint ret = 0;\n\n\tva_start(ap, dir);\n\twhile (ret == 0 && (name = va_arg(ap, char *)) != NULL) {\n\t\tconst char *fmt = va_arg(ap, char *);\n\t\tvoid *result = va_arg(ap, void *);\n\t\tchar *p;\n\n\t\tp = xenbus_read(t, dir, name, NULL);\n\t\tif (IS_ERR(p)) {\n\t\t\tret = PTR_ERR(p);\n\t\t\tbreak;\n\t\t}\n\t\tif (fmt) {\n\t\t\tif (sscanf(p, fmt, result) == 0)\n\t\t\t\tret = -EINVAL;\n\t\t\tkfree(p);\n\t\t} else\n\t\t\t*(char **)result = p;\n\t}\n\tva_end(ap);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xenbus_gather);\n\nstatic int xs_watch(const char *path, const char *token)\n{\n\tstruct kvec iov[2];\n\n\tiov[0].iov_base = (void *)path;\n\tiov[0].iov_len = strlen(path) + 1;\n\tiov[1].iov_base = (void *)token;\n\tiov[1].iov_len = strlen(token) + 1;\n\n\treturn xs_error(xs_talkv(XBT_NIL, XS_WATCH, iov,\n\t\t\t\t ARRAY_SIZE(iov), NULL));\n}\n\nstatic int xs_unwatch(const char *path, const char *token)\n{\n\tstruct kvec iov[2];\n\n\tiov[0].iov_base = (char *)path;\n\tiov[0].iov_len = strlen(path) + 1;\n\tiov[1].iov_base = (char *)token;\n\tiov[1].iov_len = strlen(token) + 1;\n\n\treturn xs_error(xs_talkv(XBT_NIL, XS_UNWATCH, iov,\n\t\t\t\t ARRAY_SIZE(iov), NULL));\n}\n\nstatic struct xenbus_watch *find_watch(const char *token)\n{\n\tstruct xenbus_watch *i, *cmp;\n\n\tcmp = (void *)simple_strtoul(token, NULL, 16);\n\n\tlist_for_each_entry(i, &watches, list)\n\t\tif (i == cmp)\n\t\t\treturn i;\n\n\treturn NULL;\n}\n\nint xs_watch_msg(struct xs_watch_event *event)\n{\n\tif (count_strings(event->body, event->len) != 2) {\n\t\tkfree(event);\n\t\treturn -EINVAL;\n\t}\n\tevent->path = (const char *)event->body;\n\tevent->token = (const char *)strchr(event->body, '\\0') + 1;\n\n\tspin_lock(&watches_lock);\n\tevent->handle = find_watch(event->token);\n\tif (event->handle != NULL &&\n\t\t\t(!event->handle->will_handle ||\n\t\t\t event->handle->will_handle(event->handle,\n\t\t\t\t event->path, event->token))) {\n\t\tspin_lock(&watch_events_lock);\n\t\tlist_add_tail(&event->list, &watch_events);\n\t\tevent->handle->nr_pending++;\n\t\twake_up(&watch_events_waitq);\n\t\tspin_unlock(&watch_events_lock);\n\t} else\n\t\tkfree(event);\n\tspin_unlock(&watches_lock);\n\n\treturn 0;\n}\n\n \nstatic bool xen_strict_xenbus_quirk(void)\n{\n#ifdef CONFIG_X86\n\tuint32_t eax, ebx, ecx, edx, base;\n\n\tbase = xen_cpuid_base();\n\tcpuid(base + 1, &eax, &ebx, &ecx, &edx);\n\n\tif ((eax >> 16) < 4)\n\t\treturn true;\n#endif\n\treturn false;\n\n}\nstatic void xs_reset_watches(void)\n{\n\tint err;\n\n\tif (!xen_hvm_domain() || xen_initial_domain())\n\t\treturn;\n\n\tif (xen_strict_xenbus_quirk())\n\t\treturn;\n\n\tif (!xenbus_read_unsigned(\"control\",\n\t\t\t\t  \"platform-feature-xs_reset_watches\", 0))\n\t\treturn;\n\n\terr = xs_error(xs_single(XBT_NIL, XS_RESET_WATCHES, \"\", NULL));\n\tif (err && err != -EEXIST)\n\t\tpr_warn(\"xs_reset_watches failed: %d\\n\", err);\n}\n\n \nint register_xenbus_watch(struct xenbus_watch *watch)\n{\n\t \n\tchar token[sizeof(watch) * 2 + 1];\n\tint err;\n\n\tsprintf(token, \"%lX\", (long)watch);\n\n\twatch->nr_pending = 0;\n\n\tdown_read(&xs_watch_rwsem);\n\n\tspin_lock(&watches_lock);\n\tBUG_ON(find_watch(token));\n\tlist_add(&watch->list, &watches);\n\tspin_unlock(&watches_lock);\n\n\terr = xs_watch(watch->node, token);\n\n\tif (err) {\n\t\tspin_lock(&watches_lock);\n\t\tlist_del(&watch->list);\n\t\tspin_unlock(&watches_lock);\n\t}\n\n\tup_read(&xs_watch_rwsem);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(register_xenbus_watch);\n\nvoid unregister_xenbus_watch(struct xenbus_watch *watch)\n{\n\tstruct xs_watch_event *event, *tmp;\n\tchar token[sizeof(watch) * 2 + 1];\n\tint err;\n\n\tsprintf(token, \"%lX\", (long)watch);\n\n\tdown_read(&xs_watch_rwsem);\n\n\tspin_lock(&watches_lock);\n\tBUG_ON(!find_watch(token));\n\tlist_del(&watch->list);\n\tspin_unlock(&watches_lock);\n\n\terr = xs_unwatch(watch->node, token);\n\tif (err)\n\t\tpr_warn(\"Failed to release watch %s: %i\\n\", watch->node, err);\n\n\tup_read(&xs_watch_rwsem);\n\n\t \n\tif (current->pid != xenwatch_pid)\n\t\tmutex_lock(&xenwatch_mutex);\n\n\t \n\tspin_lock(&watch_events_lock);\n\tif (watch->nr_pending) {\n\t\tlist_for_each_entry_safe(event, tmp, &watch_events, list) {\n\t\t\tif (event->handle != watch)\n\t\t\t\tcontinue;\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t}\n\t\twatch->nr_pending = 0;\n\t}\n\tspin_unlock(&watch_events_lock);\n\n\tif (current->pid != xenwatch_pid)\n\t\tmutex_unlock(&xenwatch_mutex);\n}\nEXPORT_SYMBOL_GPL(unregister_xenbus_watch);\n\nvoid xs_suspend(void)\n{\n\txs_suspend_enter();\n\n\tmutex_lock(&xs_response_mutex);\n\tdown_write(&xs_watch_rwsem);\n}\n\nvoid xs_resume(void)\n{\n\tstruct xenbus_watch *watch;\n\tchar token[sizeof(watch) * 2 + 1];\n\n\txb_init_comms();\n\n\tmutex_unlock(&xs_response_mutex);\n\n\txs_suspend_exit();\n\n\t \n\tlist_for_each_entry(watch, &watches, list) {\n\t\tsprintf(token, \"%lX\", (long)watch);\n\t\txs_watch(watch->node, token);\n\t}\n\n\tup_write(&xs_watch_rwsem);\n}\n\nvoid xs_suspend_cancel(void)\n{\n\tup_write(&xs_watch_rwsem);\n\tmutex_unlock(&xs_response_mutex);\n\n\txs_suspend_exit();\n}\n\nstatic int xenwatch_thread(void *unused)\n{\n\tstruct xs_watch_event *event;\n\n\txenwatch_pid = current->pid;\n\n\tfor (;;) {\n\t\twait_event_interruptible(watch_events_waitq,\n\t\t\t\t\t !list_empty(&watch_events));\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tmutex_lock(&xenwatch_mutex);\n\n\t\tspin_lock(&watch_events_lock);\n\t\tevent = list_first_entry_or_null(&watch_events,\n\t\t\t\tstruct xs_watch_event, list);\n\t\tif (event) {\n\t\t\tlist_del(&event->list);\n\t\t\tevent->handle->nr_pending--;\n\t\t}\n\t\tspin_unlock(&watch_events_lock);\n\n\t\tif (event) {\n\t\t\tevent->handle->callback(event->handle, event->path,\n\t\t\t\t\t\tevent->token);\n\t\t\tkfree(event);\n\t\t}\n\n\t\tmutex_unlock(&xenwatch_mutex);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int xs_reboot_notify(struct notifier_block *nb,\n\t\t\t    unsigned long code, void *unused)\n{\n\tstruct xb_req_data *req;\n\n\tmutex_lock(&xb_write_mutex);\n\tlist_for_each_entry(req, &xs_reply_list, list)\n\t\twake_up(&req->wq);\n\tlist_for_each_entry(req, &xb_write_list, list)\n\t\twake_up(&req->wq);\n\tmutex_unlock(&xb_write_mutex);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block xs_reboot_nb = {\n\t.notifier_call = xs_reboot_notify,\n};\n\nint xs_init(void)\n{\n\tint err;\n\tstruct task_struct *task;\n\n\tregister_reboot_notifier(&xs_reboot_nb);\n\n\t \n\terr = xb_init_comms();\n\tif (err)\n\t\treturn err;\n\n\ttask = kthread_run(xenwatch_thread, NULL, \"xenwatch\");\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\n\t \n\txs_reset_watches();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}