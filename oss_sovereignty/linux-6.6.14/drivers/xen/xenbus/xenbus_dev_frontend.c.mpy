{
  "module_name": "xenbus_dev_frontend.c",
  "hash_id": "e132e53dea76588909d7acfc0b1bef156fd8ac00fd6a5040da3af4c65883fe00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xenbus/xenbus_dev_frontend.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/uio.h>\n#include <linux/notifier.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/miscdevice.h>\n#include <linux/workqueue.h>\n\n#include <xen/xenbus.h>\n#include <xen/xen.h>\n#include <asm/xen/hypervisor.h>\n\n#include \"xenbus.h\"\n\nunsigned int xb_dev_generation_id;\n\n \nstruct xenbus_transaction_holder {\n\tstruct list_head list;\n\tstruct xenbus_transaction handle;\n\tunsigned int generation_id;\n};\n\n \nstruct read_buffer {\n\tstruct list_head list;\n\tunsigned int cons;\n\tunsigned int len;\n\tchar msg[];\n};\n\nstruct xenbus_file_priv {\n\t \n\tstruct mutex msgbuffer_mutex;\n\n\t \n\tstruct list_head transactions;\n\n\t \n\tstruct list_head watches;\n\n\t \n\tunsigned int len;\n\tunion {\n\t\tstruct xsd_sockmsg msg;\n\t\tchar buffer[XENSTORE_PAYLOAD_MAX];\n\t} u;\n\n\t \n\tstruct mutex reply_mutex;\n\tstruct list_head read_buffers;\n\twait_queue_head_t read_waitq;\n\n\tstruct kref kref;\n\n\tstruct work_struct wq;\n};\n\n \nstatic ssize_t xenbus_file_read(struct file *filp,\n\t\t\t       char __user *ubuf,\n\t\t\t       size_t len, loff_t *ppos)\n{\n\tstruct xenbus_file_priv *u = filp->private_data;\n\tstruct read_buffer *rb;\n\tssize_t i;\n\tint ret;\n\n\tmutex_lock(&u->reply_mutex);\nagain:\n\twhile (list_empty(&u->read_buffers)) {\n\t\tmutex_unlock(&u->reply_mutex);\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tret = wait_event_interruptible(u->read_waitq,\n\t\t\t\t\t       !list_empty(&u->read_buffers));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmutex_lock(&u->reply_mutex);\n\t}\n\n\trb = list_entry(u->read_buffers.next, struct read_buffer, list);\n\ti = 0;\n\twhile (i < len) {\n\t\tsize_t sz = min_t(size_t, len - i, rb->len - rb->cons);\n\n\t\tret = copy_to_user(ubuf + i, &rb->msg[rb->cons], sz);\n\n\t\ti += sz - ret;\n\t\trb->cons += sz - ret;\n\n\t\tif (ret != 0) {\n\t\t\tif (i == 0)\n\t\t\t\ti = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (rb->cons == rb->len) {\n\t\t\tlist_del(&rb->list);\n\t\t\tkfree(rb);\n\t\t\tif (list_empty(&u->read_buffers))\n\t\t\t\tbreak;\n\t\t\trb = list_entry(u->read_buffers.next,\n\t\t\t\t\tstruct read_buffer, list);\n\t\t}\n\t}\n\tif (i == 0)\n\t\tgoto again;\n\nout:\n\tmutex_unlock(&u->reply_mutex);\n\treturn i;\n}\n\n \nstatic int queue_reply(struct list_head *queue, const void *data, size_t len)\n{\n\tstruct read_buffer *rb;\n\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > XENSTORE_PAYLOAD_MAX)\n\t\treturn -EINVAL;\n\n\trb = kmalloc(sizeof(*rb) + len, GFP_KERNEL);\n\tif (rb == NULL)\n\t\treturn -ENOMEM;\n\n\trb->cons = 0;\n\trb->len = len;\n\n\tmemcpy(rb->msg, data, len);\n\n\tlist_add_tail(&rb->list, queue);\n\treturn 0;\n}\n\n \nstatic void queue_cleanup(struct list_head *list)\n{\n\tstruct read_buffer *rb;\n\n\twhile (!list_empty(list)) {\n\t\trb = list_entry(list->next, struct read_buffer, list);\n\t\tlist_del(list->next);\n\t\tkfree(rb);\n\t}\n}\n\nstruct watch_adapter {\n\tstruct list_head list;\n\tstruct xenbus_watch watch;\n\tstruct xenbus_file_priv *dev_data;\n\tchar *token;\n};\n\nstatic void free_watch_adapter(struct watch_adapter *watch)\n{\n\tkfree(watch->watch.node);\n\tkfree(watch->token);\n\tkfree(watch);\n}\n\nstatic struct watch_adapter *alloc_watch_adapter(const char *path,\n\t\t\t\t\t\t const char *token)\n{\n\tstruct watch_adapter *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (watch == NULL)\n\t\tgoto out_fail;\n\n\twatch->watch.node = kstrdup(path, GFP_KERNEL);\n\tif (watch->watch.node == NULL)\n\t\tgoto out_free;\n\n\twatch->token = kstrdup(token, GFP_KERNEL);\n\tif (watch->token == NULL)\n\t\tgoto out_free;\n\n\treturn watch;\n\nout_free:\n\tfree_watch_adapter(watch);\n\nout_fail:\n\treturn NULL;\n}\n\nstatic void watch_fired(struct xenbus_watch *watch,\n\t\t\tconst char *path,\n\t\t\tconst char *token)\n{\n\tstruct watch_adapter *adap;\n\tstruct xsd_sockmsg hdr;\n\tconst char *token_caller;\n\tint path_len, tok_len, body_len;\n\tint ret;\n\tLIST_HEAD(staging_q);\n\n\tadap = container_of(watch, struct watch_adapter, watch);\n\n\ttoken_caller = adap->token;\n\n\tpath_len = strlen(path) + 1;\n\ttok_len = strlen(token_caller) + 1;\n\tbody_len = path_len + tok_len;\n\n\thdr.type = XS_WATCH_EVENT;\n\thdr.len = body_len;\n\n\tmutex_lock(&adap->dev_data->reply_mutex);\n\n\tret = queue_reply(&staging_q, &hdr, sizeof(hdr));\n\tif (!ret)\n\t\tret = queue_reply(&staging_q, path, path_len);\n\tif (!ret)\n\t\tret = queue_reply(&staging_q, token_caller, tok_len);\n\n\tif (!ret) {\n\t\t \n\t\tlist_splice_tail(&staging_q, &adap->dev_data->read_buffers);\n\t\twake_up(&adap->dev_data->read_waitq);\n\t} else\n\t\tqueue_cleanup(&staging_q);\n\n\tmutex_unlock(&adap->dev_data->reply_mutex);\n}\n\nstatic void xenbus_worker(struct work_struct *wq)\n{\n\tstruct xenbus_file_priv *u;\n\tstruct xenbus_transaction_holder *trans, *tmp;\n\tstruct watch_adapter *watch, *tmp_watch;\n\tstruct read_buffer *rb, *tmp_rb;\n\n\tu = container_of(wq, struct xenbus_file_priv, wq);\n\n\t \n\n\tlist_for_each_entry_safe(trans, tmp, &u->transactions, list) {\n\t\txenbus_transaction_end(trans->handle, 1);\n\t\tlist_del(&trans->list);\n\t\tkfree(trans);\n\t}\n\n\tlist_for_each_entry_safe(watch, tmp_watch, &u->watches, list) {\n\t\tunregister_xenbus_watch(&watch->watch);\n\t\tlist_del(&watch->list);\n\t\tfree_watch_adapter(watch);\n\t}\n\n\tlist_for_each_entry_safe(rb, tmp_rb, &u->read_buffers, list) {\n\t\tlist_del(&rb->list);\n\t\tkfree(rb);\n\t}\n\tkfree(u);\n}\n\nstatic void xenbus_file_free(struct kref *kref)\n{\n\tstruct xenbus_file_priv *u;\n\n\t \n\tu = container_of(kref, struct xenbus_file_priv, kref);\n\tschedule_work(&u->wq);\n}\n\nstatic struct xenbus_transaction_holder *xenbus_get_transaction(\n\tstruct xenbus_file_priv *u, uint32_t tx_id)\n{\n\tstruct xenbus_transaction_holder *trans;\n\n\tlist_for_each_entry(trans, &u->transactions, list)\n\t\tif (trans->handle.id == tx_id)\n\t\t\treturn trans;\n\n\treturn NULL;\n}\n\nvoid xenbus_dev_queue_reply(struct xb_req_data *req)\n{\n\tstruct xenbus_file_priv *u = req->par;\n\tstruct xenbus_transaction_holder *trans = NULL;\n\tint rc;\n\tLIST_HEAD(staging_q);\n\n\txs_request_exit(req);\n\n\tmutex_lock(&u->msgbuffer_mutex);\n\n\tif (req->type == XS_TRANSACTION_START) {\n\t\ttrans = xenbus_get_transaction(u, 0);\n\t\tif (WARN_ON(!trans))\n\t\t\tgoto out;\n\t\tif (req->msg.type == XS_ERROR) {\n\t\t\tlist_del(&trans->list);\n\t\t\tkfree(trans);\n\t\t} else {\n\t\t\trc = kstrtou32(req->body, 10, &trans->handle.id);\n\t\t\tif (WARN_ON(rc))\n\t\t\t\tgoto out;\n\t\t}\n\t} else if (req->type == XS_TRANSACTION_END) {\n\t\ttrans = xenbus_get_transaction(u, req->msg.tx_id);\n\t\tif (WARN_ON(!trans))\n\t\t\tgoto out;\n\t\tlist_del(&trans->list);\n\t\tkfree(trans);\n\t}\n\n\tmutex_unlock(&u->msgbuffer_mutex);\n\n\tmutex_lock(&u->reply_mutex);\n\trc = queue_reply(&staging_q, &req->msg, sizeof(req->msg));\n\tif (!rc)\n\t\trc = queue_reply(&staging_q, req->body, req->msg.len);\n\tif (!rc) {\n\t\tlist_splice_tail(&staging_q, &u->read_buffers);\n\t\twake_up(&u->read_waitq);\n\t} else {\n\t\tqueue_cleanup(&staging_q);\n\t}\n\tmutex_unlock(&u->reply_mutex);\n\n\tkfree(req->body);\n\tkfree(req);\n\n\tkref_put(&u->kref, xenbus_file_free);\n\n\treturn;\n\n out:\n\tmutex_unlock(&u->msgbuffer_mutex);\n}\n\nstatic int xenbus_command_reply(struct xenbus_file_priv *u,\n\t\t\t\tunsigned int msg_type, const char *reply)\n{\n\tstruct {\n\t\tstruct xsd_sockmsg hdr;\n\t\tchar body[16];\n\t} msg;\n\tint rc;\n\n\tmsg.hdr = u->u.msg;\n\tmsg.hdr.type = msg_type;\n\tmsg.hdr.len = strlen(reply) + 1;\n\tif (msg.hdr.len > sizeof(msg.body))\n\t\treturn -E2BIG;\n\tmemcpy(&msg.body, reply, msg.hdr.len);\n\n\tmutex_lock(&u->reply_mutex);\n\trc = queue_reply(&u->read_buffers, &msg, sizeof(msg.hdr) + msg.hdr.len);\n\twake_up(&u->read_waitq);\n\tmutex_unlock(&u->reply_mutex);\n\n\tif (!rc)\n\t\tkref_put(&u->kref, xenbus_file_free);\n\n\treturn rc;\n}\n\nstatic int xenbus_write_transaction(unsigned msg_type,\n\t\t\t\t    struct xenbus_file_priv *u)\n{\n\tint rc;\n\tstruct xenbus_transaction_holder *trans = NULL;\n\tstruct {\n\t\tstruct xsd_sockmsg hdr;\n\t\tchar body[];\n\t} *msg = (void *)u->u.buffer;\n\n\tif (msg_type == XS_TRANSACTION_START) {\n\t\ttrans = kzalloc(sizeof(*trans), GFP_KERNEL);\n\t\tif (!trans) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttrans->generation_id = xb_dev_generation_id;\n\t\tlist_add(&trans->list, &u->transactions);\n\t} else if (msg->hdr.tx_id != 0 &&\n\t\t   !xenbus_get_transaction(u, msg->hdr.tx_id))\n\t\treturn xenbus_command_reply(u, XS_ERROR, \"ENOENT\");\n\telse if (msg_type == XS_TRANSACTION_END &&\n\t\t !(msg->hdr.len == 2 &&\n\t\t   (!strcmp(msg->body, \"T\") || !strcmp(msg->body, \"F\"))))\n\t\treturn xenbus_command_reply(u, XS_ERROR, \"EINVAL\");\n\telse if (msg_type == XS_TRANSACTION_END) {\n\t\ttrans = xenbus_get_transaction(u, msg->hdr.tx_id);\n\t\tif (trans && trans->generation_id != xb_dev_generation_id) {\n\t\t\tlist_del(&trans->list);\n\t\t\tkfree(trans);\n\t\t\tif (!strcmp(msg->body, \"T\"))\n\t\t\t\treturn xenbus_command_reply(u, XS_ERROR,\n\t\t\t\t\t\t\t    \"EAGAIN\");\n\t\t\telse\n\t\t\t\treturn xenbus_command_reply(u,\n\t\t\t\t\t\t\t    XS_TRANSACTION_END,\n\t\t\t\t\t\t\t    \"OK\");\n\t\t}\n\t}\n\n\trc = xenbus_dev_request_and_reply(&msg->hdr, u);\n\tif (rc && trans) {\n\t\tlist_del(&trans->list);\n\t\tkfree(trans);\n\t}\n\nout:\n\treturn rc;\n}\n\nstatic int xenbus_write_watch(unsigned msg_type, struct xenbus_file_priv *u)\n{\n\tstruct watch_adapter *watch;\n\tchar *path, *token;\n\tint err, rc;\n\n\tpath = u->u.buffer + sizeof(u->u.msg);\n\ttoken = memchr(path, 0, u->u.msg.len);\n\tif (token == NULL) {\n\t\trc = xenbus_command_reply(u, XS_ERROR, \"EINVAL\");\n\t\tgoto out;\n\t}\n\ttoken++;\n\tif (memchr(token, 0, u->u.msg.len - (token - path)) == NULL) {\n\t\trc = xenbus_command_reply(u, XS_ERROR, \"EINVAL\");\n\t\tgoto out;\n\t}\n\n\tif (msg_type == XS_WATCH) {\n\t\twatch = alloc_watch_adapter(path, token);\n\t\tif (watch == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\twatch->watch.callback = watch_fired;\n\t\twatch->dev_data = u;\n\n\t\terr = register_xenbus_watch(&watch->watch);\n\t\tif (err) {\n\t\t\tfree_watch_adapter(watch);\n\t\t\trc = err;\n\t\t\tgoto out;\n\t\t}\n\t\tlist_add(&watch->list, &u->watches);\n\t} else {\n\t\tlist_for_each_entry(watch, &u->watches, list) {\n\t\t\tif (!strcmp(watch->token, token) &&\n\t\t\t    !strcmp(watch->watch.node, path)) {\n\t\t\t\tunregister_xenbus_watch(&watch->watch);\n\t\t\t\tlist_del(&watch->list);\n\t\t\t\tfree_watch_adapter(watch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\trc = xenbus_command_reply(u, msg_type, \"OK\");\n\nout:\n\treturn rc;\n}\n\nstatic ssize_t xenbus_file_write(struct file *filp,\n\t\t\t\tconst char __user *ubuf,\n\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tstruct xenbus_file_priv *u = filp->private_data;\n\tuint32_t msg_type;\n\tint rc = len;\n\tint ret;\n\n\t \n\n\t \n\tmutex_lock(&u->msgbuffer_mutex);\n\n\t \n\tif (len == 0)\n\t\tgoto out;\n\n\t \n\tif (len > sizeof(u->u.buffer) - u->len) {\n\t\t \n\t\tu->len = 0;\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = copy_from_user(u->u.buffer + u->len, ubuf, len);\n\n\tif (ret != 0) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t \n\tlen -= ret;\n\trc = len;\n\n\tu->len += len;\n\n\t \n\tif (u->len < sizeof(u->u.msg))\n\t\tgoto out;\t \n\n\t \n\tif ((sizeof(u->u.msg) + u->u.msg.len) > sizeof(u->u.buffer)) {\n\t\trc = -E2BIG;\n\t\tu->len = 0;\n\t\tgoto out;\n\t}\n\n\tif (u->len < (sizeof(u->u.msg) + u->u.msg.len))\n\t\tgoto out;\t \n\n\t \n\n\tkref_get(&u->kref);\n\n\tmsg_type = u->u.msg.type;\n\n\tswitch (msg_type) {\n\tcase XS_WATCH:\n\tcase XS_UNWATCH:\n\t\t \n\t\tret = xenbus_write_watch(msg_type, u);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tret = xenbus_write_transaction(msg_type, u);\n\t\tbreak;\n\t}\n\tif (ret != 0) {\n\t\trc = ret;\n\t\tkref_put(&u->kref, xenbus_file_free);\n\t}\n\n\t \n\tu->len = 0;\n\n out:\n\tmutex_unlock(&u->msgbuffer_mutex);\n\treturn rc;\n}\n\nstatic int xenbus_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct xenbus_file_priv *u;\n\n\tif (xen_store_evtchn == 0)\n\t\treturn -ENOENT;\n\n\tstream_open(inode, filp);\n\n\tu = kzalloc(sizeof(*u), GFP_KERNEL);\n\tif (u == NULL)\n\t\treturn -ENOMEM;\n\n\tkref_init(&u->kref);\n\n\tINIT_LIST_HEAD(&u->transactions);\n\tINIT_LIST_HEAD(&u->watches);\n\tINIT_LIST_HEAD(&u->read_buffers);\n\tinit_waitqueue_head(&u->read_waitq);\n\tINIT_WORK(&u->wq, xenbus_worker);\n\n\tmutex_init(&u->reply_mutex);\n\tmutex_init(&u->msgbuffer_mutex);\n\n\tfilp->private_data = u;\n\n\treturn 0;\n}\n\nstatic int xenbus_file_release(struct inode *inode, struct file *filp)\n{\n\tstruct xenbus_file_priv *u = filp->private_data;\n\n\tkref_put(&u->kref, xenbus_file_free);\n\n\treturn 0;\n}\n\nstatic __poll_t xenbus_file_poll(struct file *file, poll_table *wait)\n{\n\tstruct xenbus_file_priv *u = file->private_data;\n\n\tpoll_wait(file, &u->read_waitq, wait);\n\tif (!list_empty(&u->read_buffers))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}\n\nconst struct file_operations xen_xenbus_fops = {\n\t.read = xenbus_file_read,\n\t.write = xenbus_file_write,\n\t.open = xenbus_file_open,\n\t.release = xenbus_file_release,\n\t.poll = xenbus_file_poll,\n\t.llseek = no_llseek,\n};\nEXPORT_SYMBOL_GPL(xen_xenbus_fops);\n\nstatic struct miscdevice xenbus_dev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"xen/xenbus\",\n\t.fops = &xen_xenbus_fops,\n};\n\nstatic int __init xenbus_init(void)\n{\n\tint err;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\terr = misc_register(&xenbus_dev);\n\tif (err)\n\t\tpr_err(\"Could not register xenbus frontend device\\n\");\n\treturn err;\n}\ndevice_initcall(xenbus_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}