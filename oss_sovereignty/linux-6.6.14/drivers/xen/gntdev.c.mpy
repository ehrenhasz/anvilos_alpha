{
  "module_name": "gntdev.c",
  "hash_id": "d9b83c4f6b8e2490e524fb1b724bc61b69b67326b003d4700f104933747bc9ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/gntdev.c",
  "human_readable_source": " \n\n#undef DEBUG\n\n#define pr_fmt(fmt) \"xen:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/refcount.h>\n#include <linux/workqueue.h>\n\n#include <xen/xen.h>\n#include <xen/grant_table.h>\n#include <xen/balloon.h>\n#include <xen/gntdev.h>\n#include <xen/events.h>\n#include <xen/page.h>\n#include <asm/xen/hypervisor.h>\n#include <asm/xen/hypercall.h>\n\n#include \"gntdev-common.h\"\n#ifdef CONFIG_XEN_GNTDEV_DMABUF\n#include \"gntdev-dmabuf.h\"\n#endif\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Derek G. Murray <Derek.Murray@cl.cam.ac.uk>, \"\n\t      \"Gerd Hoffmann <kraxel@redhat.com>\");\nMODULE_DESCRIPTION(\"User-space granted page access driver\");\n\nstatic unsigned int limit = 64*1024;\nmodule_param(limit, uint, 0644);\nMODULE_PARM_DESC(limit,\n\t\"Maximum number of grants that may be mapped by one mapping request\");\n\n \nstatic int use_ptemod;\n\nstatic void unmap_grant_pages(struct gntdev_grant_map *map,\n\t\t\t      int offset, int pages);\n\nstatic struct miscdevice gntdev_miscdev;\n\n \n\nbool gntdev_test_page_count(unsigned int count)\n{\n\treturn !count || count > limit;\n}\n\nstatic void gntdev_print_maps(struct gntdev_priv *priv,\n\t\t\t      char *text, int text_index)\n{\n#ifdef DEBUG\n\tstruct gntdev_grant_map *map;\n\n\tpr_debug(\"%s: maps list (priv %p)\\n\", __func__, priv);\n\tlist_for_each_entry(map, &priv->maps, next)\n\t\tpr_debug(\"  index %2d, count %2d %s\\n\",\n\t\t       map->index, map->count,\n\t\t       map->index == text_index && text ? text : \"\");\n#endif\n}\n\nstatic void gntdev_free_map(struct gntdev_grant_map *map)\n{\n\tif (map == NULL)\n\t\treturn;\n\n#ifdef CONFIG_XEN_GRANT_DMA_ALLOC\n\tif (map->dma_vaddr) {\n\t\tstruct gnttab_dma_alloc_args args;\n\n\t\targs.dev = map->dma_dev;\n\t\targs.coherent = !!(map->dma_flags & GNTDEV_DMA_FLAG_COHERENT);\n\t\targs.nr_pages = map->count;\n\t\targs.pages = map->pages;\n\t\targs.frames = map->frames;\n\t\targs.vaddr = map->dma_vaddr;\n\t\targs.dev_bus_addr = map->dma_bus_addr;\n\n\t\tgnttab_dma_free_pages(&args);\n\t} else\n#endif\n\tif (map->pages)\n\t\tgnttab_free_pages(map->count, map->pages);\n\n#ifdef CONFIG_XEN_GRANT_DMA_ALLOC\n\tkvfree(map->frames);\n#endif\n\tkvfree(map->pages);\n\tkvfree(map->grants);\n\tkvfree(map->map_ops);\n\tkvfree(map->unmap_ops);\n\tkvfree(map->kmap_ops);\n\tkvfree(map->kunmap_ops);\n\tkvfree(map->being_removed);\n\tkfree(map);\n}\n\nstruct gntdev_grant_map *gntdev_alloc_map(struct gntdev_priv *priv, int count,\n\t\t\t\t\t  int dma_flags)\n{\n\tstruct gntdev_grant_map *add;\n\tint i;\n\n\tadd = kzalloc(sizeof(*add), GFP_KERNEL);\n\tif (NULL == add)\n\t\treturn NULL;\n\n\tadd->grants    = kvmalloc_array(count, sizeof(add->grants[0]),\n\t\t\t\t\tGFP_KERNEL);\n\tadd->map_ops   = kvmalloc_array(count, sizeof(add->map_ops[0]),\n\t\t\t\t\tGFP_KERNEL);\n\tadd->unmap_ops = kvmalloc_array(count, sizeof(add->unmap_ops[0]),\n\t\t\t\t\tGFP_KERNEL);\n\tadd->pages     = kvcalloc(count, sizeof(add->pages[0]), GFP_KERNEL);\n\tadd->being_removed =\n\t\tkvcalloc(count, sizeof(add->being_removed[0]), GFP_KERNEL);\n\tif (NULL == add->grants    ||\n\t    NULL == add->map_ops   ||\n\t    NULL == add->unmap_ops ||\n\t    NULL == add->pages     ||\n\t    NULL == add->being_removed)\n\t\tgoto err;\n\tif (use_ptemod) {\n\t\tadd->kmap_ops   = kvmalloc_array(count, sizeof(add->kmap_ops[0]),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tadd->kunmap_ops = kvmalloc_array(count, sizeof(add->kunmap_ops[0]),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (NULL == add->kmap_ops || NULL == add->kunmap_ops)\n\t\t\tgoto err;\n\t}\n\n#ifdef CONFIG_XEN_GRANT_DMA_ALLOC\n\tadd->dma_flags = dma_flags;\n\n\t \n\tif (dma_flags & (GNTDEV_DMA_FLAG_WC | GNTDEV_DMA_FLAG_COHERENT)) {\n\t\tstruct gnttab_dma_alloc_args args;\n\n\t\tadd->frames = kvcalloc(count, sizeof(add->frames[0]),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!add->frames)\n\t\t\tgoto err;\n\n\t\t \n\t\tadd->dma_dev = priv->dma_dev;\n\n\t\targs.dev = priv->dma_dev;\n\t\targs.coherent = !!(dma_flags & GNTDEV_DMA_FLAG_COHERENT);\n\t\targs.nr_pages = count;\n\t\targs.pages = add->pages;\n\t\targs.frames = add->frames;\n\n\t\tif (gnttab_dma_alloc_pages(&args))\n\t\t\tgoto err;\n\n\t\tadd->dma_vaddr = args.vaddr;\n\t\tadd->dma_bus_addr = args.dev_bus_addr;\n\t} else\n#endif\n\tif (gnttab_alloc_pages(count, add->pages))\n\t\tgoto err;\n\n\tfor (i = 0; i < count; i++) {\n\t\tadd->grants[i].domid = DOMID_INVALID;\n\t\tadd->grants[i].ref = INVALID_GRANT_REF;\n\t\tadd->map_ops[i].handle = INVALID_GRANT_HANDLE;\n\t\tadd->unmap_ops[i].handle = INVALID_GRANT_HANDLE;\n\t\tif (use_ptemod) {\n\t\t\tadd->kmap_ops[i].handle = INVALID_GRANT_HANDLE;\n\t\t\tadd->kunmap_ops[i].handle = INVALID_GRANT_HANDLE;\n\t\t}\n\t}\n\n\tadd->index = 0;\n\tadd->count = count;\n\trefcount_set(&add->users, 1);\n\n\treturn add;\n\nerr:\n\tgntdev_free_map(add);\n\treturn NULL;\n}\n\nvoid gntdev_add_map(struct gntdev_priv *priv, struct gntdev_grant_map *add)\n{\n\tstruct gntdev_grant_map *map;\n\n\tlist_for_each_entry(map, &priv->maps, next) {\n\t\tif (add->index + add->count < map->index) {\n\t\t\tlist_add_tail(&add->next, &map->next);\n\t\t\tgoto done;\n\t\t}\n\t\tadd->index = map->index + map->count;\n\t}\n\tlist_add_tail(&add->next, &priv->maps);\n\ndone:\n\tgntdev_print_maps(priv, \"[new]\", add->index);\n}\n\nstatic struct gntdev_grant_map *gntdev_find_map_index(struct gntdev_priv *priv,\n\t\t\t\t\t\t      int index, int count)\n{\n\tstruct gntdev_grant_map *map;\n\n\tlist_for_each_entry(map, &priv->maps, next) {\n\t\tif (map->index != index)\n\t\t\tcontinue;\n\t\tif (count && map->count != count)\n\t\t\tcontinue;\n\t\treturn map;\n\t}\n\treturn NULL;\n}\n\nvoid gntdev_put_map(struct gntdev_priv *priv, struct gntdev_grant_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&map->users))\n\t\treturn;\n\n\tif (map->pages && !use_ptemod) {\n\t\t \n\t\trefcount_set(&map->users, 1);\n\n\t\t \n\t\tunmap_grant_pages(map, 0, map->count);\n\n\t\t \n\t\tif (!refcount_dec_and_test(&map->users))\n\t\t\treturn;\n\n\t\t \n\t}\n\n\tif (use_ptemod && map->notifier_init)\n\t\tmmu_interval_notifier_remove(&map->notifier);\n\n\tif (map->notify.flags & UNMAP_NOTIFY_SEND_EVENT) {\n\t\tnotify_remote_via_evtchn(map->notify.event);\n\t\tevtchn_put(map->notify.event);\n\t}\n\tgntdev_free_map(map);\n}\n\n \n\nstatic int find_grant_ptes(pte_t *pte, unsigned long addr, void *data)\n{\n\tstruct gntdev_grant_map *map = data;\n\tunsigned int pgnr = (addr - map->pages_vm_start) >> PAGE_SHIFT;\n\tint flags = map->flags | GNTMAP_application_map | GNTMAP_contains_pte |\n\t\t    (1 << _GNTMAP_guest_avail0);\n\tu64 pte_maddr;\n\n\tBUG_ON(pgnr >= map->count);\n\tpte_maddr = arbitrary_virt_to_machine(pte).maddr;\n\n\tgnttab_set_map_op(&map->map_ops[pgnr], pte_maddr, flags,\n\t\t\t  map->grants[pgnr].ref,\n\t\t\t  map->grants[pgnr].domid);\n\tgnttab_set_unmap_op(&map->unmap_ops[pgnr], pte_maddr, flags,\n\t\t\t    INVALID_GRANT_HANDLE);\n\treturn 0;\n}\n\nint gntdev_map_grant_pages(struct gntdev_grant_map *map)\n{\n\tsize_t alloced = 0;\n\tint i, err = 0;\n\n\tif (!use_ptemod) {\n\t\t \n\t\tif (map->map_ops[0].handle != INVALID_GRANT_HANDLE)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < map->count; i++) {\n\t\t\tunsigned long addr = (unsigned long)\n\t\t\t\tpfn_to_kaddr(page_to_pfn(map->pages[i]));\n\t\t\tgnttab_set_map_op(&map->map_ops[i], addr, map->flags,\n\t\t\t\tmap->grants[i].ref,\n\t\t\t\tmap->grants[i].domid);\n\t\t\tgnttab_set_unmap_op(&map->unmap_ops[i], addr,\n\t\t\t\tmap->flags, INVALID_GRANT_HANDLE);\n\t\t}\n\t} else {\n\t\t \n\t\tunsigned int flags = (map->flags & ~GNTMAP_device_map) |\n\t\t\t\t     GNTMAP_host_map;\n\n\t\tfor (i = 0; i < map->count; i++) {\n\t\t\tunsigned long address = (unsigned long)\n\t\t\t\tpfn_to_kaddr(page_to_pfn(map->pages[i]));\n\t\t\tBUG_ON(PageHighMem(map->pages[i]));\n\n\t\t\tgnttab_set_map_op(&map->kmap_ops[i], address, flags,\n\t\t\t\tmap->grants[i].ref,\n\t\t\t\tmap->grants[i].domid);\n\t\t\tgnttab_set_unmap_op(&map->kunmap_ops[i], address,\n\t\t\t\tflags, INVALID_GRANT_HANDLE);\n\t\t}\n\t}\n\n\tpr_debug(\"map %d+%d\\n\", map->index, map->count);\n\terr = gnttab_map_refs(map->map_ops, map->kmap_ops, map->pages,\n\t\t\tmap->count);\n\n\tfor (i = 0; i < map->count; i++) {\n\t\tif (map->map_ops[i].status == GNTST_okay) {\n\t\t\tmap->unmap_ops[i].handle = map->map_ops[i].handle;\n\t\t\talloced++;\n\t\t} else if (!err)\n\t\t\terr = -EINVAL;\n\n\t\tif (map->flags & GNTMAP_device_map)\n\t\t\tmap->unmap_ops[i].dev_bus_addr = map->map_ops[i].dev_bus_addr;\n\n\t\tif (use_ptemod) {\n\t\t\tif (map->kmap_ops[i].status == GNTST_okay) {\n\t\t\t\talloced++;\n\t\t\t\tmap->kunmap_ops[i].handle = map->kmap_ops[i].handle;\n\t\t\t} else if (!err)\n\t\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\tatomic_add(alloced, &map->live_grants);\n\treturn err;\n}\n\nstatic void __unmap_grant_pages_done(int result,\n\t\tstruct gntab_unmap_queue_data *data)\n{\n\tunsigned int i;\n\tstruct gntdev_grant_map *map = data->data;\n\tunsigned int offset = data->unmap_ops - map->unmap_ops;\n\tint successful_unmaps = 0;\n\tint live_grants;\n\n\tfor (i = 0; i < data->count; i++) {\n\t\tif (map->unmap_ops[offset + i].status == GNTST_okay &&\n\t\t    map->unmap_ops[offset + i].handle != INVALID_GRANT_HANDLE)\n\t\t\tsuccessful_unmaps++;\n\n\t\tWARN_ON(map->unmap_ops[offset + i].status != GNTST_okay &&\n\t\t\tmap->unmap_ops[offset + i].handle != INVALID_GRANT_HANDLE);\n\t\tpr_debug(\"unmap handle=%d st=%d\\n\",\n\t\t\tmap->unmap_ops[offset+i].handle,\n\t\t\tmap->unmap_ops[offset+i].status);\n\t\tmap->unmap_ops[offset+i].handle = INVALID_GRANT_HANDLE;\n\t\tif (use_ptemod) {\n\t\t\tif (map->kunmap_ops[offset + i].status == GNTST_okay &&\n\t\t\t    map->kunmap_ops[offset + i].handle != INVALID_GRANT_HANDLE)\n\t\t\t\tsuccessful_unmaps++;\n\n\t\t\tWARN_ON(map->kunmap_ops[offset + i].status != GNTST_okay &&\n\t\t\t\tmap->kunmap_ops[offset + i].handle != INVALID_GRANT_HANDLE);\n\t\t\tpr_debug(\"kunmap handle=%u st=%d\\n\",\n\t\t\t\t map->kunmap_ops[offset+i].handle,\n\t\t\t\t map->kunmap_ops[offset+i].status);\n\t\t\tmap->kunmap_ops[offset+i].handle = INVALID_GRANT_HANDLE;\n\t\t}\n\t}\n\n\t \n\tlive_grants = atomic_sub_return(successful_unmaps, &map->live_grants);\n\tif (WARN_ON(live_grants < 0))\n\t\tpr_err(\"%s: live_grants became negative (%d) after unmapping %d pages!\\n\",\n\t\t       __func__, live_grants, successful_unmaps);\n\n\t \n\tgntdev_put_map(NULL, map);\n}\n\nstatic void __unmap_grant_pages(struct gntdev_grant_map *map, int offset,\n\t\t\t       int pages)\n{\n\tif (map->notify.flags & UNMAP_NOTIFY_CLEAR_BYTE) {\n\t\tint pgno = (map->notify.addr >> PAGE_SHIFT);\n\n\t\tif (pgno >= offset && pgno < offset + pages) {\n\t\t\t \n\t\t\tuint8_t *tmp = pfn_to_kaddr(page_to_pfn(map->pages[pgno]));\n\n\t\t\ttmp[map->notify.addr & (PAGE_SIZE-1)] = 0;\n\t\t\tmap->notify.flags &= ~UNMAP_NOTIFY_CLEAR_BYTE;\n\t\t}\n\t}\n\n\tmap->unmap_data.unmap_ops = map->unmap_ops + offset;\n\tmap->unmap_data.kunmap_ops = use_ptemod ? map->kunmap_ops + offset : NULL;\n\tmap->unmap_data.pages = map->pages + offset;\n\tmap->unmap_data.count = pages;\n\tmap->unmap_data.done = __unmap_grant_pages_done;\n\tmap->unmap_data.data = map;\n\trefcount_inc(&map->users);  \n\n\tgnttab_unmap_refs_async(&map->unmap_data);\n}\n\nstatic void unmap_grant_pages(struct gntdev_grant_map *map, int offset,\n\t\t\t      int pages)\n{\n\tint range;\n\n\tif (atomic_read(&map->live_grants) == 0)\n\t\treturn;  \n\n\tpr_debug(\"unmap %d+%d [%d+%d]\\n\", map->index, map->count, offset, pages);\n\n\t \n\twhile (pages) {\n\t\twhile (pages && map->being_removed[offset]) {\n\t\t\toffset++;\n\t\t\tpages--;\n\t\t}\n\t\trange = 0;\n\t\twhile (range < pages) {\n\t\t\tif (map->being_removed[offset + range])\n\t\t\t\tbreak;\n\t\t\tmap->being_removed[offset + range] = true;\n\t\t\trange++;\n\t\t}\n\t\tif (range)\n\t\t\t__unmap_grant_pages(map, offset, range);\n\t\toffset += range;\n\t\tpages -= range;\n\t}\n}\n\n \n\nstatic void gntdev_vma_open(struct vm_area_struct *vma)\n{\n\tstruct gntdev_grant_map *map = vma->vm_private_data;\n\n\tpr_debug(\"gntdev_vma_open %p\\n\", vma);\n\trefcount_inc(&map->users);\n}\n\nstatic void gntdev_vma_close(struct vm_area_struct *vma)\n{\n\tstruct gntdev_grant_map *map = vma->vm_private_data;\n\tstruct file *file = vma->vm_file;\n\tstruct gntdev_priv *priv = file->private_data;\n\n\tpr_debug(\"gntdev_vma_close %p\\n\", vma);\n\n\tvma->vm_private_data = NULL;\n\tgntdev_put_map(priv, map);\n}\n\nstatic struct page *gntdev_vma_find_special_page(struct vm_area_struct *vma,\n\t\t\t\t\t\t unsigned long addr)\n{\n\tstruct gntdev_grant_map *map = vma->vm_private_data;\n\n\treturn map->pages[(addr - map->pages_vm_start) >> PAGE_SHIFT];\n}\n\nstatic const struct vm_operations_struct gntdev_vmops = {\n\t.open = gntdev_vma_open,\n\t.close = gntdev_vma_close,\n\t.find_special_page = gntdev_vma_find_special_page,\n};\n\n \n\nstatic bool gntdev_invalidate(struct mmu_interval_notifier *mn,\n\t\t\t      const struct mmu_notifier_range *range,\n\t\t\t      unsigned long cur_seq)\n{\n\tstruct gntdev_grant_map *map =\n\t\tcontainer_of(mn, struct gntdev_grant_map, notifier);\n\tunsigned long mstart, mend;\n\tunsigned long map_start, map_end;\n\n\tif (!mmu_notifier_range_blockable(range))\n\t\treturn false;\n\n\tmap_start = map->pages_vm_start;\n\tmap_end = map->pages_vm_start + (map->count << PAGE_SHIFT);\n\n\t \n\tif (map_start >= range->end || map_end <= range->start)\n\t\treturn true;\n\n\tmstart = max(range->start, map_start);\n\tmend = min(range->end, map_end);\n\tpr_debug(\"map %d+%d (%lx %lx), range %lx %lx, mrange %lx %lx\\n\",\n\t\t map->index, map->count, map_start, map_end,\n\t\t range->start, range->end, mstart, mend);\n\tunmap_grant_pages(map, (mstart - map_start) >> PAGE_SHIFT,\n\t\t\t  (mend - mstart) >> PAGE_SHIFT);\n\n\treturn true;\n}\n\nstatic const struct mmu_interval_notifier_ops gntdev_mmu_ops = {\n\t.invalidate = gntdev_invalidate,\n};\n\n \n\nstatic int gntdev_open(struct inode *inode, struct file *flip)\n{\n\tstruct gntdev_priv *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&priv->maps);\n\tmutex_init(&priv->lock);\n\n#ifdef CONFIG_XEN_GNTDEV_DMABUF\n\tpriv->dmabuf_priv = gntdev_dmabuf_init(flip);\n\tif (IS_ERR(priv->dmabuf_priv)) {\n\t\tint ret = PTR_ERR(priv->dmabuf_priv);\n\n\t\tkfree(priv);\n\t\treturn ret;\n\t}\n#endif\n\n\tflip->private_data = priv;\n#ifdef CONFIG_XEN_GRANT_DMA_ALLOC\n\tpriv->dma_dev = gntdev_miscdev.this_device;\n\tdma_coerce_mask_and_coherent(priv->dma_dev, DMA_BIT_MASK(64));\n#endif\n\tpr_debug(\"priv %p\\n\", priv);\n\n\treturn 0;\n}\n\nstatic int gntdev_release(struct inode *inode, struct file *flip)\n{\n\tstruct gntdev_priv *priv = flip->private_data;\n\tstruct gntdev_grant_map *map;\n\n\tpr_debug(\"priv %p\\n\", priv);\n\n\tmutex_lock(&priv->lock);\n\twhile (!list_empty(&priv->maps)) {\n\t\tmap = list_entry(priv->maps.next,\n\t\t\t\t struct gntdev_grant_map, next);\n\t\tlist_del(&map->next);\n\t\tgntdev_put_map(NULL  , map);\n\t}\n\tmutex_unlock(&priv->lock);\n\n#ifdef CONFIG_XEN_GNTDEV_DMABUF\n\tgntdev_dmabuf_fini(priv->dmabuf_priv);\n#endif\n\n\tkfree(priv);\n\treturn 0;\n}\n\nstatic long gntdev_ioctl_map_grant_ref(struct gntdev_priv *priv,\n\t\t\t\t       struct ioctl_gntdev_map_grant_ref __user *u)\n{\n\tstruct ioctl_gntdev_map_grant_ref op;\n\tstruct gntdev_grant_map *map;\n\tint err;\n\n\tif (copy_from_user(&op, u, sizeof(op)) != 0)\n\t\treturn -EFAULT;\n\tpr_debug(\"priv %p, add %d\\n\", priv, op.count);\n\tif (unlikely(gntdev_test_page_count(op.count)))\n\t\treturn -EINVAL;\n\n\terr = -ENOMEM;\n\tmap = gntdev_alloc_map(priv, op.count, 0  );\n\tif (!map)\n\t\treturn err;\n\n\tif (copy_from_user(map->grants, &u->refs,\n\t\t\t   sizeof(map->grants[0]) * op.count) != 0) {\n\t\tgntdev_put_map(NULL, map);\n\t\treturn -EFAULT;\n\t}\n\n\tmutex_lock(&priv->lock);\n\tgntdev_add_map(priv, map);\n\top.index = map->index << PAGE_SHIFT;\n\tmutex_unlock(&priv->lock);\n\n\tif (copy_to_user(u, &op, sizeof(op)) != 0)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long gntdev_ioctl_unmap_grant_ref(struct gntdev_priv *priv,\n\t\t\t\t\t struct ioctl_gntdev_unmap_grant_ref __user *u)\n{\n\tstruct ioctl_gntdev_unmap_grant_ref op;\n\tstruct gntdev_grant_map *map;\n\tint err = -ENOENT;\n\n\tif (copy_from_user(&op, u, sizeof(op)) != 0)\n\t\treturn -EFAULT;\n\tpr_debug(\"priv %p, del %d+%d\\n\", priv, (int)op.index, (int)op.count);\n\n\tmutex_lock(&priv->lock);\n\tmap = gntdev_find_map_index(priv, op.index >> PAGE_SHIFT, op.count);\n\tif (map) {\n\t\tlist_del(&map->next);\n\t\terr = 0;\n\t}\n\tmutex_unlock(&priv->lock);\n\tif (map)\n\t\tgntdev_put_map(priv, map);\n\treturn err;\n}\n\nstatic long gntdev_ioctl_get_offset_for_vaddr(struct gntdev_priv *priv,\n\t\t\t\t\t      struct ioctl_gntdev_get_offset_for_vaddr __user *u)\n{\n\tstruct ioctl_gntdev_get_offset_for_vaddr op;\n\tstruct vm_area_struct *vma;\n\tstruct gntdev_grant_map *map;\n\tint rv = -EINVAL;\n\n\tif (copy_from_user(&op, u, sizeof(op)) != 0)\n\t\treturn -EFAULT;\n\tpr_debug(\"priv %p, offset for vaddr %lx\\n\", priv, (unsigned long)op.vaddr);\n\n\tmmap_read_lock(current->mm);\n\tvma = find_vma(current->mm, op.vaddr);\n\tif (!vma || vma->vm_ops != &gntdev_vmops)\n\t\tgoto out_unlock;\n\n\tmap = vma->vm_private_data;\n\tif (!map)\n\t\tgoto out_unlock;\n\n\top.offset = map->index << PAGE_SHIFT;\n\top.count = map->count;\n\trv = 0;\n\n out_unlock:\n\tmmap_read_unlock(current->mm);\n\n\tif (rv == 0 && copy_to_user(u, &op, sizeof(op)) != 0)\n\t\treturn -EFAULT;\n\treturn rv;\n}\n\nstatic long gntdev_ioctl_notify(struct gntdev_priv *priv, void __user *u)\n{\n\tstruct ioctl_gntdev_unmap_notify op;\n\tstruct gntdev_grant_map *map;\n\tint rc;\n\tint out_flags;\n\tevtchn_port_t out_event;\n\n\tif (copy_from_user(&op, u, sizeof(op)))\n\t\treturn -EFAULT;\n\n\tif (op.action & ~(UNMAP_NOTIFY_CLEAR_BYTE|UNMAP_NOTIFY_SEND_EVENT))\n\t\treturn -EINVAL;\n\n\t \n\tif (op.action & UNMAP_NOTIFY_SEND_EVENT) {\n\t\tif (evtchn_get(op.event_channel_port))\n\t\t\treturn -EINVAL;\n\t}\n\n\tout_flags = op.action;\n\tout_event = op.event_channel_port;\n\n\tmutex_lock(&priv->lock);\n\n\tlist_for_each_entry(map, &priv->maps, next) {\n\t\tuint64_t begin = map->index << PAGE_SHIFT;\n\t\tuint64_t end = (map->index + map->count) << PAGE_SHIFT;\n\t\tif (op.index >= begin && op.index < end)\n\t\t\tgoto found;\n\t}\n\trc = -ENOENT;\n\tgoto unlock_out;\n\n found:\n\tif ((op.action & UNMAP_NOTIFY_CLEAR_BYTE) &&\n\t\t\t(map->flags & GNTMAP_readonly)) {\n\t\trc = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\n\tout_flags = map->notify.flags;\n\tout_event = map->notify.event;\n\n\tmap->notify.flags = op.action;\n\tmap->notify.addr = op.index - (map->index << PAGE_SHIFT);\n\tmap->notify.event = op.event_channel_port;\n\n\trc = 0;\n\n unlock_out:\n\tmutex_unlock(&priv->lock);\n\n\t \n\tif (out_flags & UNMAP_NOTIFY_SEND_EVENT)\n\t\tevtchn_put(out_event);\n\n\treturn rc;\n}\n\n#define GNTDEV_COPY_BATCH 16\n\nstruct gntdev_copy_batch {\n\tstruct gnttab_copy ops[GNTDEV_COPY_BATCH];\n\tstruct page *pages[GNTDEV_COPY_BATCH];\n\ts16 __user *status[GNTDEV_COPY_BATCH];\n\tunsigned int nr_ops;\n\tunsigned int nr_pages;\n\tbool writeable;\n};\n\nstatic int gntdev_get_page(struct gntdev_copy_batch *batch, void __user *virt,\n\t\t\t\tunsigned long *gfn)\n{\n\tunsigned long addr = (unsigned long)virt;\n\tstruct page *page;\n\tunsigned long xen_pfn;\n\tint ret;\n\n\tret = pin_user_pages_fast(addr, 1, batch->writeable ? FOLL_WRITE : 0, &page);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbatch->pages[batch->nr_pages++] = page;\n\n\txen_pfn = page_to_xen_pfn(page) + XEN_PFN_DOWN(addr & ~PAGE_MASK);\n\t*gfn = pfn_to_gfn(xen_pfn);\n\n\treturn 0;\n}\n\nstatic void gntdev_put_pages(struct gntdev_copy_batch *batch)\n{\n\tunpin_user_pages_dirty_lock(batch->pages, batch->nr_pages, batch->writeable);\n\tbatch->nr_pages = 0;\n\tbatch->writeable = false;\n}\n\nstatic int gntdev_copy(struct gntdev_copy_batch *batch)\n{\n\tunsigned int i;\n\n\tgnttab_batch_copy(batch->ops, batch->nr_ops);\n\tgntdev_put_pages(batch);\n\n\t \n\tfor (i = 0; i < batch->nr_ops; i++) {\n\t\ts16 status = batch->ops[i].status;\n\t\ts16 old_status;\n\n\t\tif (status == GNTST_okay)\n\t\t\tcontinue;\n\n\t\tif (__get_user(old_status, batch->status[i]))\n\t\t\treturn -EFAULT;\n\n\t\tif (old_status != GNTST_okay)\n\t\t\tcontinue;\n\n\t\tif (__put_user(status, batch->status[i]))\n\t\t\treturn -EFAULT;\n\t}\n\n\tbatch->nr_ops = 0;\n\treturn 0;\n}\n\nstatic int gntdev_grant_copy_seg(struct gntdev_copy_batch *batch,\n\t\t\t\t struct gntdev_grant_copy_segment *seg,\n\t\t\t\t s16 __user *status)\n{\n\tuint16_t copied = 0;\n\n\t \n\tif (!(seg->flags & (GNTCOPY_source_gref | GNTCOPY_dest_gref)))\n\t\treturn -EINVAL;\n\n\t \n\tif (seg->flags & GNTCOPY_source_gref) {\n\t\tif (seg->source.foreign.offset + seg->len > XEN_PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t}\n\tif (seg->flags & GNTCOPY_dest_gref) {\n\t\tif (seg->dest.foreign.offset + seg->len > XEN_PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (put_user(GNTST_okay, status))\n\t\treturn -EFAULT;\n\n\twhile (copied < seg->len) {\n\t\tstruct gnttab_copy *op;\n\t\tvoid __user *virt;\n\t\tsize_t len, off;\n\t\tunsigned long gfn;\n\t\tint ret;\n\n\t\tif (batch->nr_ops >= GNTDEV_COPY_BATCH) {\n\t\t\tret = gntdev_copy(batch);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tlen = seg->len - copied;\n\n\t\top = &batch->ops[batch->nr_ops];\n\t\top->flags = 0;\n\n\t\tif (seg->flags & GNTCOPY_source_gref) {\n\t\t\top->source.u.ref = seg->source.foreign.ref;\n\t\t\top->source.domid = seg->source.foreign.domid;\n\t\t\top->source.offset = seg->source.foreign.offset + copied;\n\t\t\top->flags |= GNTCOPY_source_gref;\n\t\t} else {\n\t\t\tvirt = seg->source.virt + copied;\n\t\t\toff = (unsigned long)virt & ~XEN_PAGE_MASK;\n\t\t\tlen = min(len, (size_t)XEN_PAGE_SIZE - off);\n\t\t\tbatch->writeable = false;\n\n\t\t\tret = gntdev_get_page(batch, virt, &gfn);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\top->source.u.gmfn = gfn;\n\t\t\top->source.domid = DOMID_SELF;\n\t\t\top->source.offset = off;\n\t\t}\n\n\t\tif (seg->flags & GNTCOPY_dest_gref) {\n\t\t\top->dest.u.ref = seg->dest.foreign.ref;\n\t\t\top->dest.domid = seg->dest.foreign.domid;\n\t\t\top->dest.offset = seg->dest.foreign.offset + copied;\n\t\t\top->flags |= GNTCOPY_dest_gref;\n\t\t} else {\n\t\t\tvirt = seg->dest.virt + copied;\n\t\t\toff = (unsigned long)virt & ~XEN_PAGE_MASK;\n\t\t\tlen = min(len, (size_t)XEN_PAGE_SIZE - off);\n\t\t\tbatch->writeable = true;\n\n\t\t\tret = gntdev_get_page(batch, virt, &gfn);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\top->dest.u.gmfn = gfn;\n\t\t\top->dest.domid = DOMID_SELF;\n\t\t\top->dest.offset = off;\n\t\t}\n\n\t\top->len = len;\n\t\tcopied += len;\n\n\t\tbatch->status[batch->nr_ops] = status;\n\t\tbatch->nr_ops++;\n\t}\n\n\treturn 0;\n}\n\nstatic long gntdev_ioctl_grant_copy(struct gntdev_priv *priv, void __user *u)\n{\n\tstruct ioctl_gntdev_grant_copy copy;\n\tstruct gntdev_copy_batch batch;\n\tunsigned int i;\n\tint ret = 0;\n\n\tif (copy_from_user(&copy, u, sizeof(copy)))\n\t\treturn -EFAULT;\n\n\tbatch.nr_ops = 0;\n\tbatch.nr_pages = 0;\n\n\tfor (i = 0; i < copy.count; i++) {\n\t\tstruct gntdev_grant_copy_segment seg;\n\n\t\tif (copy_from_user(&seg, &copy.segments[i], sizeof(seg))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = gntdev_grant_copy_seg(&batch, &seg, &copy.segments[i].status);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tcond_resched();\n\t}\n\tif (batch.nr_ops)\n\t\tret = gntdev_copy(&batch);\n\treturn ret;\n\n  out:\n\tgntdev_put_pages(&batch);\n\treturn ret;\n}\n\nstatic long gntdev_ioctl(struct file *flip,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct gntdev_priv *priv = flip->private_data;\n\tvoid __user *ptr = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase IOCTL_GNTDEV_MAP_GRANT_REF:\n\t\treturn gntdev_ioctl_map_grant_ref(priv, ptr);\n\n\tcase IOCTL_GNTDEV_UNMAP_GRANT_REF:\n\t\treturn gntdev_ioctl_unmap_grant_ref(priv, ptr);\n\n\tcase IOCTL_GNTDEV_GET_OFFSET_FOR_VADDR:\n\t\treturn gntdev_ioctl_get_offset_for_vaddr(priv, ptr);\n\n\tcase IOCTL_GNTDEV_SET_UNMAP_NOTIFY:\n\t\treturn gntdev_ioctl_notify(priv, ptr);\n\n\tcase IOCTL_GNTDEV_GRANT_COPY:\n\t\treturn gntdev_ioctl_grant_copy(priv, ptr);\n\n#ifdef CONFIG_XEN_GNTDEV_DMABUF\n\tcase IOCTL_GNTDEV_DMABUF_EXP_FROM_REFS:\n\t\treturn gntdev_ioctl_dmabuf_exp_from_refs(priv, use_ptemod, ptr);\n\n\tcase IOCTL_GNTDEV_DMABUF_EXP_WAIT_RELEASED:\n\t\treturn gntdev_ioctl_dmabuf_exp_wait_released(priv, ptr);\n\n\tcase IOCTL_GNTDEV_DMABUF_IMP_TO_REFS:\n\t\treturn gntdev_ioctl_dmabuf_imp_to_refs(priv, ptr);\n\n\tcase IOCTL_GNTDEV_DMABUF_IMP_RELEASE:\n\t\treturn gntdev_ioctl_dmabuf_imp_release(priv, ptr);\n#endif\n\n\tdefault:\n\t\tpr_debug(\"priv %p, unknown cmd %x\\n\", priv, cmd);\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)\n{\n\tstruct gntdev_priv *priv = flip->private_data;\n\tint index = vma->vm_pgoff;\n\tint count = vma_pages(vma);\n\tstruct gntdev_grant_map *map;\n\tint err = -EINVAL;\n\n\tif ((vma->vm_flags & VM_WRITE) && !(vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"map %d+%d at %lx (pgoff %lx)\\n\",\n\t\t index, count, vma->vm_start, vma->vm_pgoff);\n\n\tmutex_lock(&priv->lock);\n\tmap = gntdev_find_map_index(priv, index, count);\n\tif (!map)\n\t\tgoto unlock_out;\n\tif (!atomic_add_unless(&map->in_use, 1, 1))\n\t\tgoto unlock_out;\n\n\trefcount_inc(&map->users);\n\n\tvma->vm_ops = &gntdev_vmops;\n\n\tvm_flags_set(vma, VM_DONTEXPAND | VM_DONTDUMP | VM_MIXEDMAP);\n\n\tif (use_ptemod)\n\t\tvm_flags_set(vma, VM_DONTCOPY);\n\n\tvma->vm_private_data = map;\n\tif (map->flags) {\n\t\tif ((vma->vm_flags & VM_WRITE) &&\n\t\t\t\t(map->flags & GNTMAP_readonly))\n\t\t\tgoto out_unlock_put;\n\t} else {\n\t\tmap->flags = GNTMAP_host_map;\n\t\tif (!(vma->vm_flags & VM_WRITE))\n\t\t\tmap->flags |= GNTMAP_readonly;\n\t}\n\n\tmap->pages_vm_start = vma->vm_start;\n\n\tif (use_ptemod) {\n\t\terr = mmu_interval_notifier_insert_locked(\n\t\t\t&map->notifier, vma->vm_mm, vma->vm_start,\n\t\t\tvma->vm_end - vma->vm_start, &gntdev_mmu_ops);\n\t\tif (err)\n\t\t\tgoto out_unlock_put;\n\n\t\tmap->notifier_init = true;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\tif (use_ptemod) {\n\t\t \n\t\tmmu_interval_read_begin(&map->notifier);\n\n\t\terr = apply_to_page_range(vma->vm_mm, vma->vm_start,\n\t\t\t\t\t  vma->vm_end - vma->vm_start,\n\t\t\t\t\t  find_grant_ptes, map);\n\t\tif (err) {\n\t\t\tpr_warn(\"find_grant_ptes() failure.\\n\");\n\t\t\tgoto out_put_map;\n\t\t}\n\t}\n\n\terr = gntdev_map_grant_pages(map);\n\tif (err)\n\t\tgoto out_put_map;\n\n\tif (!use_ptemod) {\n\t\terr = vm_map_pages_zero(vma, map->pages, map->count);\n\t\tif (err)\n\t\t\tgoto out_put_map;\n\t}\n\n\treturn 0;\n\nunlock_out:\n\tmutex_unlock(&priv->lock);\n\treturn err;\n\nout_unlock_put:\n\tmutex_unlock(&priv->lock);\nout_put_map:\n\tif (use_ptemod)\n\t\tunmap_grant_pages(map, 0, map->count);\n\tgntdev_put_map(priv, map);\n\treturn err;\n}\n\nstatic const struct file_operations gntdev_fops = {\n\t.owner = THIS_MODULE,\n\t.open = gntdev_open,\n\t.release = gntdev_release,\n\t.mmap = gntdev_mmap,\n\t.unlocked_ioctl = gntdev_ioctl\n};\n\nstatic struct miscdevice gntdev_miscdev = {\n\t.minor        = MISC_DYNAMIC_MINOR,\n\t.name         = \"xen/gntdev\",\n\t.fops         = &gntdev_fops,\n};\n\n \n\nstatic int __init gntdev_init(void)\n{\n\tint err;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tuse_ptemod = !xen_feature(XENFEAT_auto_translated_physmap);\n\n\terr = misc_register(&gntdev_miscdev);\n\tif (err != 0) {\n\t\tpr_err(\"Could not register gntdev device\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void __exit gntdev_exit(void)\n{\n\tmisc_deregister(&gntdev_miscdev);\n}\n\nmodule_init(gntdev_init);\nmodule_exit(gntdev_exit);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}