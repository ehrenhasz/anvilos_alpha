{
  "module_name": "xlate_mmu.c",
  "hash_id": "894f1e99f3776e390d3e81b18bc3d45956606833db9edaea33753a14334d5759",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xlate_mmu.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\n#include <asm/xen/hypercall.h>\n#include <asm/xen/hypervisor.h>\n\n#include <xen/xen.h>\n#include <xen/xen-ops.h>\n#include <xen/page.h>\n#include <xen/interface/xen.h>\n#include <xen/interface/memory.h>\n#include <xen/balloon.h>\n\ntypedef void (*xen_gfn_fn_t)(unsigned long gfn, void *data);\n\n \nstatic void xen_for_each_gfn(struct page **pages, unsigned nr_gfn,\n\t\t\t     xen_gfn_fn_t fn, void *data)\n{\n\tunsigned long xen_pfn = 0;\n\tstruct page *page;\n\tint i;\n\n\tfor (i = 0; i < nr_gfn; i++) {\n\t\tif ((i % XEN_PFN_PER_PAGE) == 0) {\n\t\t\tpage = pages[i / XEN_PFN_PER_PAGE];\n\t\t\txen_pfn = page_to_xen_pfn(page);\n\t\t}\n\t\tfn(pfn_to_gfn(xen_pfn++), data);\n\t}\n}\n\nstruct remap_data {\n\txen_pfn_t *fgfn;  \n\tint nr_fgfn;  \n\tpgprot_t prot;\n\tdomid_t  domid;\n\tstruct vm_area_struct *vma;\n\tint index;\n\tstruct page **pages;\n\tstruct xen_remap_gfn_info *info;\n\tint *err_ptr;\n\tint mapped;\n\n\t \n\tint h_errs[XEN_PFN_PER_PAGE];\n\txen_ulong_t h_idxs[XEN_PFN_PER_PAGE];\n\txen_pfn_t h_gpfns[XEN_PFN_PER_PAGE];\n\n\tint h_iter;\t \n};\n\nstatic void setup_hparams(unsigned long gfn, void *data)\n{\n\tstruct remap_data *info = data;\n\n\tinfo->h_idxs[info->h_iter] = *info->fgfn;\n\tinfo->h_gpfns[info->h_iter] = gfn;\n\tinfo->h_errs[info->h_iter] = 0;\n\n\tinfo->h_iter++;\n\tinfo->fgfn++;\n}\n\nstatic int remap_pte_fn(pte_t *ptep, unsigned long addr, void *data)\n{\n\tstruct remap_data *info = data;\n\tstruct page *page = info->pages[info->index++];\n\tpte_t pte = pte_mkspecial(pfn_pte(page_to_pfn(page), info->prot));\n\tint rc, nr_gfn;\n\tuint32_t i;\n\tstruct xen_add_to_physmap_range xatp = {\n\t\t.domid = DOMID_SELF,\n\t\t.foreign_domid = info->domid,\n\t\t.space = XENMAPSPACE_gmfn_foreign,\n\t};\n\n\tnr_gfn = min_t(typeof(info->nr_fgfn), XEN_PFN_PER_PAGE, info->nr_fgfn);\n\tinfo->nr_fgfn -= nr_gfn;\n\n\tinfo->h_iter = 0;\n\txen_for_each_gfn(&page, nr_gfn, setup_hparams, info);\n\tBUG_ON(info->h_iter != nr_gfn);\n\n\tset_xen_guest_handle(xatp.idxs, info->h_idxs);\n\tset_xen_guest_handle(xatp.gpfns, info->h_gpfns);\n\tset_xen_guest_handle(xatp.errs, info->h_errs);\n\txatp.size = nr_gfn;\n\n\trc = HYPERVISOR_memory_op(XENMEM_add_to_physmap_range, &xatp);\n\n\t \n\tfor (i = 0; i < nr_gfn; i++) {\n\t\tint err = (rc < 0) ? rc : info->h_errs[i];\n\n\t\t*(info->err_ptr++) = err;\n\t\tif (!err)\n\t\t\tinfo->mapped++;\n\t}\n\n\t \n\tif (!rc)\n\t\tset_pte_at(info->vma->vm_mm, addr, ptep, pte);\n\n\treturn 0;\n}\n\nint xen_xlate_remap_gfn_array(struct vm_area_struct *vma,\n\t\t\t      unsigned long addr,\n\t\t\t      xen_pfn_t *gfn, int nr,\n\t\t\t      int *err_ptr, pgprot_t prot,\n\t\t\t      unsigned domid,\n\t\t\t      struct page **pages)\n{\n\tint err;\n\tstruct remap_data data;\n\tunsigned long range = DIV_ROUND_UP(nr, XEN_PFN_PER_PAGE) << PAGE_SHIFT;\n\n\t \n\tBUG_ON(!((vma->vm_flags & (VM_PFNMAP | VM_IO)) == (VM_PFNMAP | VM_IO)));\n\n\tdata.fgfn = gfn;\n\tdata.nr_fgfn = nr;\n\tdata.prot  = prot;\n\tdata.domid = domid;\n\tdata.vma   = vma;\n\tdata.pages = pages;\n\tdata.index = 0;\n\tdata.err_ptr = err_ptr;\n\tdata.mapped = 0;\n\n\terr = apply_to_page_range(vma->vm_mm, addr, range,\n\t\t\t\t  remap_pte_fn, &data);\n\treturn err < 0 ? err : data.mapped;\n}\nEXPORT_SYMBOL_GPL(xen_xlate_remap_gfn_array);\n\nstatic void unmap_gfn(unsigned long gfn, void *data)\n{\n\tstruct xen_remove_from_physmap xrp;\n\n\txrp.domid = DOMID_SELF;\n\txrp.gpfn = gfn;\n\t(void)HYPERVISOR_memory_op(XENMEM_remove_from_physmap, &xrp);\n}\n\nint xen_xlate_unmap_gfn_range(struct vm_area_struct *vma,\n\t\t\t      int nr, struct page **pages)\n{\n\txen_for_each_gfn(pages, nr, unmap_gfn, NULL);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xen_xlate_unmap_gfn_range);\n\nstruct map_balloon_pages {\n\txen_pfn_t *pfns;\n\tunsigned int idx;\n};\n\nstatic void setup_balloon_gfn(unsigned long gfn, void *data)\n{\n\tstruct map_balloon_pages *info = data;\n\n\tinfo->pfns[info->idx++] = gfn;\n}\n\n \nint __init xen_xlate_map_ballooned_pages(xen_pfn_t **gfns, void **virt,\n\t\t\t\t\t unsigned long nr_grant_frames)\n{\n\tstruct page **pages;\n\txen_pfn_t *pfns;\n\tvoid *vaddr;\n\tstruct map_balloon_pages data;\n\tint rc;\n\tunsigned long nr_pages;\n\n\tBUG_ON(nr_grant_frames == 0);\n\tnr_pages = DIV_ROUND_UP(nr_grant_frames, XEN_PFN_PER_PAGE);\n\tpages = kcalloc(nr_pages, sizeof(pages[0]), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tpfns = kcalloc(nr_grant_frames, sizeof(pfns[0]), GFP_KERNEL);\n\tif (!pfns) {\n\t\tkfree(pages);\n\t\treturn -ENOMEM;\n\t}\n\trc = xen_alloc_unpopulated_pages(nr_pages, pages);\n\tif (rc) {\n\t\tpr_warn(\"%s Couldn't balloon alloc %ld pages rc:%d\\n\", __func__,\n\t\t\tnr_pages, rc);\n\t\tkfree(pages);\n\t\tkfree(pfns);\n\t\treturn rc;\n\t}\n\n\tdata.pfns = pfns;\n\tdata.idx = 0;\n\txen_for_each_gfn(pages, nr_grant_frames, setup_balloon_gfn, &data);\n\n\tvaddr = vmap(pages, nr_pages, 0, PAGE_KERNEL);\n\tif (!vaddr) {\n\t\tpr_warn(\"%s Couldn't map %ld pages rc:%d\\n\", __func__,\n\t\t\tnr_pages, rc);\n\t\txen_free_unpopulated_pages(nr_pages, pages);\n\t\tkfree(pages);\n\t\tkfree(pfns);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(pages);\n\n\t*gfns = pfns;\n\t*virt = vaddr;\n\n\treturn 0;\n}\n\nstruct remap_pfn {\n\tstruct mm_struct *mm;\n\tstruct page **pages;\n\tpgprot_t prot;\n\tunsigned long i;\n};\n\nstatic int remap_pfn_fn(pte_t *ptep, unsigned long addr, void *data)\n{\n\tstruct remap_pfn *r = data;\n\tstruct page *page = r->pages[r->i];\n\tpte_t pte = pte_mkspecial(pfn_pte(page_to_pfn(page), r->prot));\n\n\tset_pte_at(r->mm, addr, ptep, pte);\n\tr->i++;\n\n\treturn 0;\n}\n\n \nint xen_remap_vma_range(struct vm_area_struct *vma, unsigned long addr, unsigned long len)\n{\n\tstruct remap_pfn r = {\n\t\t.mm = vma->vm_mm,\n\t\t.pages = vma->vm_private_data,\n\t\t.prot = vma->vm_page_prot,\n\t};\n\n\treturn apply_to_page_range(vma->vm_mm, addr, len, remap_pfn_fn, &r);\n}\nEXPORT_SYMBOL_GPL(xen_remap_vma_range);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}