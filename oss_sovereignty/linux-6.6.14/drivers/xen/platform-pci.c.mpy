{
  "module_name": "platform-pci.c",
  "hash_id": "f2a1ffe33910b16557dc92da2d4015ddbe27a3ff3db1a60df22bbdc82964b4b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/platform-pci.c",
  "human_readable_source": "\n \n\n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n\n#include <xen/platform_pci.h>\n#include <xen/grant_table.h>\n#include <xen/xenbus.h>\n#include <xen/events.h>\n#include <xen/hvm.h>\n#include <xen/xen-ops.h>\n\n#define DRV_NAME    \"xen-platform-pci\"\n\nstatic unsigned long platform_mmio;\nstatic unsigned long platform_mmio_alloc;\nstatic unsigned long platform_mmiolen;\nstatic uint64_t callback_via;\n\nstatic unsigned long alloc_xen_mmio(unsigned long len)\n{\n\tunsigned long addr;\n\n\taddr = platform_mmio + platform_mmio_alloc;\n\tplatform_mmio_alloc += len;\n\tBUG_ON(platform_mmio_alloc > platform_mmiolen);\n\n\treturn addr;\n}\n\nstatic uint64_t get_callback_via(struct pci_dev *pdev)\n{\n\tu8 pin;\n\tint irq;\n\n\tirq = pdev->irq;\n\tif (irq < 16)\n\t\treturn irq;  \n\n\tpin = pdev->pin;\n\n\t \n\treturn ((uint64_t)HVM_PARAM_CALLBACK_TYPE_PCI_INTX <<\n\t\t\t  HVM_CALLBACK_VIA_TYPE_SHIFT) |\n\t\t((uint64_t)pci_domain_nr(pdev->bus) << 32) |\n\t\t((uint64_t)pdev->bus->number << 16) |\n\t\t((uint64_t)(pdev->devfn & 0xff) << 8) |\n\t\t((uint64_t)(pin - 1) & 3);\n}\n\nstatic irqreturn_t do_hvm_evtchn_intr(int irq, void *dev_id)\n{\n\treturn xen_evtchn_do_upcall();\n}\n\nstatic int xen_allocate_irq(struct pci_dev *pdev)\n{\n\treturn request_irq(pdev->irq, do_hvm_evtchn_intr,\n\t\t\tIRQF_NOBALANCING | IRQF_SHARED,\n\t\t\t\"xen-platform-pci\", pdev);\n}\n\nstatic int platform_pci_resume(struct device *dev)\n{\n\tint err;\n\n\tif (xen_have_vector_callback)\n\t\treturn 0;\n\n\terr = xen_set_callback_via(callback_via);\n\tif (err) {\n\t\tdev_err(dev, \"platform_pci_resume failure!\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int platform_pci_probe(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tint i, ret;\n\tlong ioaddr;\n\tlong mmio_addr, mmio_len;\n\tunsigned int max_nr_gframes;\n\tunsigned long grant_frames;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\ti = pci_enable_device(pdev);\n\tif (i)\n\t\treturn i;\n\n\tioaddr = pci_resource_start(pdev, 0);\n\n\tmmio_addr = pci_resource_start(pdev, 1);\n\tmmio_len = pci_resource_len(pdev, 1);\n\n\tif (mmio_addr == 0 || ioaddr == 0) {\n\t\tdev_err(&pdev->dev, \"no resources found\\n\");\n\t\tret = -ENOENT;\n\t\tgoto pci_out;\n\t}\n\n\tret = pci_request_region(pdev, 1, DRV_NAME);\n\tif (ret < 0)\n\t\tgoto pci_out;\n\n\tret = pci_request_region(pdev, 0, DRV_NAME);\n\tif (ret < 0)\n\t\tgoto mem_out;\n\n\tplatform_mmio = mmio_addr;\n\tplatform_mmiolen = mmio_len;\n\tif (!xen_have_vector_callback) {\n\t\tret = xen_allocate_irq(pdev);\n\t\tif (ret) {\n\t\t\tdev_warn(&pdev->dev, \"request_irq failed err=%d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tirq_set_affinity(pdev->irq, cpumask_of(0));\n\n\t\tcallback_via = get_callback_via(pdev);\n\t\tret = xen_set_callback_via(callback_via);\n\t\tif (ret) {\n\t\t\tdev_warn(&pdev->dev, \"Unable to set the evtchn callback \"\n\t\t\t\t\t \"err=%d\\n\", ret);\n\t\t\tgoto irq_out;\n\t\t}\n\t}\n\n\tmax_nr_gframes = gnttab_max_grant_frames();\n\tgrant_frames = alloc_xen_mmio(PAGE_SIZE * max_nr_gframes);\n\tret = gnttab_setup_auto_xlat_frames(grant_frames);\n\tif (ret)\n\t\tgoto irq_out;\n\tret = gnttab_init();\n\tif (ret)\n\t\tgoto grant_out;\n\treturn 0;\ngrant_out:\n\tgnttab_free_auto_xlat_frames();\nirq_out:\n\tif (!xen_have_vector_callback)\n\t\tfree_irq(pdev->irq, pdev);\nout:\n\tpci_release_region(pdev, 0);\nmem_out:\n\tpci_release_region(pdev, 1);\npci_out:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic const struct pci_device_id platform_pci_tbl[] = {\n\t{PCI_VENDOR_ID_XEN, PCI_DEVICE_ID_XEN_PLATFORM,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{0,}\n};\n\nstatic const struct dev_pm_ops platform_pm_ops = {\n\t.resume_noirq =   platform_pci_resume,\n};\n\nstatic struct pci_driver platform_driver = {\n\t.name =           DRV_NAME,\n\t.probe =          platform_pci_probe,\n\t.id_table =       platform_pci_tbl,\n\t.driver = {\n\t\t.pm =     &platform_pm_ops,\n\t},\n};\n\nbuiltin_pci_driver(platform_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}