{
  "module_name": "manage.c",
  "hash_id": "0316c9c63919d14beff74e754f283bcc8ff3c34b9189ebd3eca3f8297a9b655f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/manage.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"xen:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/stop_machine.h>\n#include <linux/freezer.h>\n#include <linux/syscore_ops.h>\n#include <linux/export.h>\n\n#include <xen/xen.h>\n#include <xen/xenbus.h>\n#include <xen/grant_table.h>\n#include <xen/events.h>\n#include <xen/hvc-console.h>\n#include <xen/page.h>\n#include <xen/xen-ops.h>\n\n#include <asm/xen/hypercall.h>\n#include <asm/xen/hypervisor.h>\n\nenum shutdown_state {\n\tSHUTDOWN_INVALID = -1,\n\tSHUTDOWN_POWEROFF = 0,\n\tSHUTDOWN_SUSPEND = 2,\n\t \n\t SHUTDOWN_HALT = 4,\n};\n\n \nstatic enum shutdown_state shutting_down = SHUTDOWN_INVALID;\n\nstruct suspend_info {\n\tint cancelled;\n};\n\nstatic RAW_NOTIFIER_HEAD(xen_resume_notifier);\n\nvoid xen_resume_notifier_register(struct notifier_block *nb)\n{\n\traw_notifier_chain_register(&xen_resume_notifier, nb);\n}\nEXPORT_SYMBOL_GPL(xen_resume_notifier_register);\n\nvoid xen_resume_notifier_unregister(struct notifier_block *nb)\n{\n\traw_notifier_chain_unregister(&xen_resume_notifier, nb);\n}\nEXPORT_SYMBOL_GPL(xen_resume_notifier_unregister);\n\n#ifdef CONFIG_HIBERNATE_CALLBACKS\nstatic int xen_suspend(void *data)\n{\n\tstruct suspend_info *si = data;\n\tint err;\n\n\tBUG_ON(!irqs_disabled());\n\n\terr = syscore_suspend();\n\tif (err) {\n\t\tpr_err(\"%s: system core suspend failed: %d\\n\", __func__, err);\n\t\treturn err;\n\t}\n\n\tgnttab_suspend();\n\txen_manage_runstate_time(-1);\n\txen_arch_pre_suspend();\n\n\tsi->cancelled = HYPERVISOR_suspend(xen_pv_domain()\n                                           ? virt_to_gfn(xen_start_info)\n                                           : 0);\n\n\txen_arch_post_suspend(si->cancelled);\n\txen_manage_runstate_time(si->cancelled ? 1 : 0);\n\tgnttab_resume();\n\n\tif (!si->cancelled) {\n\t\txen_irq_resume();\n\t\txen_timer_resume();\n\t}\n\n\tsyscore_resume();\n\n\treturn 0;\n}\n\nstatic void do_suspend(void)\n{\n\tint err;\n\tstruct suspend_info si;\n\n\tshutting_down = SHUTDOWN_SUSPEND;\n\n\terr = freeze_processes();\n\tif (err) {\n\t\tpr_err(\"%s: freeze processes failed %d\\n\", __func__, err);\n\t\tgoto out;\n\t}\n\n\terr = freeze_kernel_threads();\n\tif (err) {\n\t\tpr_err(\"%s: freeze kernel threads failed %d\\n\", __func__, err);\n\t\tgoto out_thaw;\n\t}\n\n\terr = dpm_suspend_start(PMSG_FREEZE);\n\tif (err) {\n\t\tpr_err(\"%s: dpm_suspend_start %d\\n\", __func__, err);\n\t\tgoto out_thaw;\n\t}\n\n\tprintk(KERN_DEBUG \"suspending xenstore...\\n\");\n\txs_suspend();\n\n\terr = dpm_suspend_end(PMSG_FREEZE);\n\tif (err) {\n\t\tpr_err(\"dpm_suspend_end failed: %d\\n\", err);\n\t\tsi.cancelled = 0;\n\t\tgoto out_resume;\n\t}\n\n\txen_arch_suspend();\n\n\tsi.cancelled = 1;\n\n\terr = stop_machine(xen_suspend, &si, cpumask_of(0));\n\n\t \n\tif (!si.cancelled)\n\t\txen_console_resume();\n\n\traw_notifier_call_chain(&xen_resume_notifier, 0, NULL);\n\n\txen_arch_resume();\n\n\tdpm_resume_start(si.cancelled ? PMSG_THAW : PMSG_RESTORE);\n\n\tif (err) {\n\t\tpr_err(\"failed to start xen_suspend: %d\\n\", err);\n\t\tsi.cancelled = 1;\n\t}\n\nout_resume:\n\tif (!si.cancelled)\n\t\txs_resume();\n\telse\n\t\txs_suspend_cancel();\n\n\tdpm_resume_end(si.cancelled ? PMSG_THAW : PMSG_RESTORE);\n\nout_thaw:\n\tthaw_processes();\nout:\n\tshutting_down = SHUTDOWN_INVALID;\n}\n#endif\t \n\nstruct shutdown_handler {\n#define SHUTDOWN_CMD_SIZE 11\n\tconst char command[SHUTDOWN_CMD_SIZE];\n\tbool flag;\n\tvoid (*cb)(void);\n};\n\nstatic int poweroff_nb(struct notifier_block *cb, unsigned long code, void *unused)\n{\n\tswitch (code) {\n\tcase SYS_DOWN:\n\tcase SYS_HALT:\n\tcase SYS_POWER_OFF:\n\t\tshutting_down = SHUTDOWN_POWEROFF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\nstatic void do_poweroff(void)\n{\n\tswitch (system_state) {\n\tcase SYSTEM_BOOTING:\n\tcase SYSTEM_SCHEDULING:\n\t\torderly_poweroff(true);\n\t\tbreak;\n\tcase SYSTEM_RUNNING:\n\t\torderly_poweroff(false);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tpr_info(\"Ignoring Xen toolstack shutdown.\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void do_reboot(void)\n{\n\tshutting_down = SHUTDOWN_POWEROFF;  \n\torderly_reboot();\n}\n\nstatic struct shutdown_handler shutdown_handlers[] = {\n\t{ \"poweroff\",\ttrue,\tdo_poweroff },\n\t{ \"halt\",\tfalse,\tdo_poweroff },\n\t{ \"reboot\",\ttrue,\tdo_reboot   },\n#ifdef CONFIG_HIBERNATE_CALLBACKS\n\t{ \"suspend\",\ttrue,\tdo_suspend  },\n#endif\n};\n\nstatic void shutdown_handler(struct xenbus_watch *watch,\n\t\t\t     const char *path, const char *token)\n{\n\tchar *str;\n\tstruct xenbus_transaction xbt;\n\tint err;\n\tint idx;\n\n\tif (shutting_down != SHUTDOWN_INVALID)\n\t\treturn;\n\n again:\n\terr = xenbus_transaction_start(&xbt);\n\tif (err)\n\t\treturn;\n\n\tstr = (char *)xenbus_read(xbt, \"control\", \"shutdown\", NULL);\n\t \n\tif (XENBUS_IS_ERR_READ(str)) {\n\t\txenbus_transaction_end(xbt, 1);\n\t\treturn;\n\t}\n\n\tfor (idx = 0; idx < ARRAY_SIZE(shutdown_handlers); idx++) {\n\t\tif (strcmp(str, shutdown_handlers[idx].command) == 0)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (idx < ARRAY_SIZE(shutdown_handlers))\n\t\txenbus_write(xbt, \"control\", \"shutdown\", \"\");\n\n\terr = xenbus_transaction_end(xbt, 0);\n\tif (err == -EAGAIN) {\n\t\tkfree(str);\n\t\tgoto again;\n\t}\n\n\tif (idx < ARRAY_SIZE(shutdown_handlers)) {\n\t\tshutdown_handlers[idx].cb();\n\t} else {\n\t\tpr_info(\"Ignoring shutdown request: %s\\n\", str);\n\t\tshutting_down = SHUTDOWN_INVALID;\n\t}\n\n\tkfree(str);\n}\n\n#ifdef CONFIG_MAGIC_SYSRQ\nstatic void sysrq_handler(struct xenbus_watch *watch, const char *path,\n\t\t\t  const char *token)\n{\n\tchar sysrq_key = '\\0';\n\tstruct xenbus_transaction xbt;\n\tint err;\n\n again:\n\terr = xenbus_transaction_start(&xbt);\n\tif (err)\n\t\treturn;\n\terr = xenbus_scanf(xbt, \"control\", \"sysrq\", \"%c\", &sysrq_key);\n\tif (err < 0) {\n\t\t \n\t\tif (err != -ENOENT && err != -ERANGE)\n\t\t\tpr_err(\"Error %d reading sysrq code in control/sysrq\\n\",\n\t\t\t       err);\n\t\txenbus_transaction_end(xbt, 1);\n\t\treturn;\n\t}\n\n\tif (sysrq_key != '\\0') {\n\t\terr = xenbus_printf(xbt, \"control\", \"sysrq\", \"%c\", '\\0');\n\t\tif (err) {\n\t\t\tpr_err(\"%s: Error %d writing sysrq in control/sysrq\\n\",\n\t\t\t       __func__, err);\n\t\t\txenbus_transaction_end(xbt, 1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\terr = xenbus_transaction_end(xbt, 0);\n\tif (err == -EAGAIN)\n\t\tgoto again;\n\n\tif (sysrq_key != '\\0')\n\t\thandle_sysrq(sysrq_key);\n}\n\nstatic struct xenbus_watch sysrq_watch = {\n\t.node = \"control/sysrq\",\n\t.callback = sysrq_handler\n};\n#endif\n\nstatic struct xenbus_watch shutdown_watch = {\n\t.node = \"control/shutdown\",\n\t.callback = shutdown_handler\n};\n\nstatic struct notifier_block xen_reboot_nb = {\n\t.notifier_call = poweroff_nb,\n};\n\nstatic int setup_shutdown_watcher(void)\n{\n\tint err;\n\tint idx;\n#define FEATURE_PATH_SIZE (SHUTDOWN_CMD_SIZE + sizeof(\"feature-\"))\n\tchar node[FEATURE_PATH_SIZE];\n\n\terr = register_xenbus_watch(&shutdown_watch);\n\tif (err) {\n\t\tpr_err(\"Failed to set shutdown watcher\\n\");\n\t\treturn err;\n\t}\n\n\n#ifdef CONFIG_MAGIC_SYSRQ\n\terr = register_xenbus_watch(&sysrq_watch);\n\tif (err) {\n\t\tpr_err(\"Failed to set sysrq watcher\\n\");\n\t\treturn err;\n\t}\n#endif\n\n\tfor (idx = 0; idx < ARRAY_SIZE(shutdown_handlers); idx++) {\n\t\tif (!shutdown_handlers[idx].flag)\n\t\t\tcontinue;\n\t\tsnprintf(node, FEATURE_PATH_SIZE, \"feature-%s\",\n\t\t\t shutdown_handlers[idx].command);\n\t\terr = xenbus_printf(XBT_NIL, \"control\", node, \"%u\", 1);\n\t\tif (err) {\n\t\t\tpr_err(\"%s: Error %d writing %s\\n\", __func__,\n\t\t\t\terr, node);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int shutdown_event(struct notifier_block *notifier,\n\t\t\t  unsigned long event,\n\t\t\t  void *data)\n{\n\tsetup_shutdown_watcher();\n\treturn NOTIFY_DONE;\n}\n\nint xen_setup_shutdown_event(void)\n{\n\tstatic struct notifier_block xenstore_notifier = {\n\t\t.notifier_call = shutdown_event\n\t};\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\tregister_xenstore_notifier(&xenstore_notifier);\n\tregister_reboot_notifier(&xen_reboot_nb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xen_setup_shutdown_event);\n\nsubsys_initcall(xen_setup_shutdown_event);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}