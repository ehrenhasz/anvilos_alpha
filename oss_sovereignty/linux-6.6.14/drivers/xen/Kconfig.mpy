{
  "module_name": "Kconfig",
  "hash_id": "e30243b410216ccd0078550aa1effdf7be7d2ee8b53dd10bbed2949ed589aacb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nmenu \"Xen driver support\"\n\tdepends on XEN\n\nconfig XEN_BALLOON\n\tbool \"Xen memory balloon driver\"\n\tdefault y\n\thelp\n\t  The balloon driver allows the Xen domain to request more memory from\n\t  the system to expand the domain's memory allocation, or alternatively\n\t  return unneeded memory to the system.\n\nconfig XEN_BALLOON_MEMORY_HOTPLUG\n\tbool \"Memory hotplug support for Xen balloon driver\"\n\tdepends on XEN_BALLOON && MEMORY_HOTPLUG\n\tdefault y\n\thelp\n\t  Memory hotplug support for Xen balloon driver allows expanding memory\n\t  available for the system above limit declared at system startup.\n\t  It is very useful on critical systems which require long\n\t  run without rebooting.\n\n\t  It's also very useful for non PV domains to obtain unpopulated physical\n\t  memory ranges to use in order to map foreign memory or grants.\n\n\t  Memory could be hotplugged in following steps:\n\n\t    1) target domain: ensure that memory auto online policy is in\n\t       effect by checking /sys/devices/system/memory/auto_online_blocks\n\t       file (should be 'online').\n\n\t    2) control domain: xl mem-max <target-domain> <maxmem>\n\t       where <maxmem> is >= requested memory size,\n\n\t    3) control domain: xl mem-set <target-domain> <memory>\n\t       where <memory> is requested memory size; alternatively memory\n\t       could be added by writing proper value to\n\t       /sys/devices/system/xen_memory/xen_memory0/target or\n\t       /sys/devices/system/xen_memory/xen_memory0/target_kb on the\n\t       target domain.\n\n\t  Alternatively, if memory auto onlining was not requested at step 1\n\t  the newly added memory can be manually onlined in the target domain\n\t  by doing the following:\n\n\t\tfor i in /sys/devices/system/memory/memory*/state; do \\\n\t\t  [ \"`cat \"$i\"`\" = offline ] && echo online > \"$i\"; done\n\n\t  or by adding the following line to udev rules:\n\n\t  SUBSYSTEM==\"memory\", ACTION==\"add\", RUN+=\"/bin/sh -c '[ -f /sys$devpath/state ] && echo online > /sys$devpath/state'\"\n\nconfig XEN_MEMORY_HOTPLUG_LIMIT\n\tint \"Hotplugged memory limit (in GiB) for a PV guest\"\n\tdefault 512\n\tdepends on XEN_HAVE_PVMMU\n\tdepends on MEMORY_HOTPLUG\n\thelp\n\t  Maximum amount of memory (in GiB) that a PV guest can be\n\t  expanded to when using memory hotplug.\n\n\t  A PV guest can have more memory than this limit if is\n\t  started with a larger maximum.\n\n\t  This value is used to allocate enough space in internal\n\t  tables needed for physical memory administration.\n\nconfig XEN_SCRUB_PAGES_DEFAULT\n\tbool \"Scrub pages before returning them to system by default\"\n\tdepends on XEN_BALLOON\n\tdefault y\n\thelp\n\t  Scrub pages before returning them to the system for reuse by\n\t  other domains.  This makes sure that any confidential data\n\t  is not accidentally visible to other domains.  It is more\n\t  secure, but slightly less efficient. This can be controlled with\n\t  xen_scrub_pages=0 parameter and\n\t  /sys/devices/system/xen_memory/xen_memory0/scrub_pages.\n\t  This option only sets the default value.\n\n\t  If in doubt, say yes.\n\nconfig XEN_DEV_EVTCHN\n\ttristate \"Xen /dev/xen/evtchn device\"\n\tdefault y\n\thelp\n\t  The evtchn driver allows a userspace process to trigger event\n\t  channels and to receive notification of an event channel\n\t  firing.\n\t  If in doubt, say yes.\n\nconfig XEN_BACKEND\n\tbool \"Backend driver support\"\n\tdefault XEN_DOM0\n\thelp\n\t  Support for backend device drivers that provide I/O services\n\t  to other virtual machines.\n\nconfig XENFS\n\ttristate \"Xen filesystem\"\n\tselect XEN_PRIVCMD\n\tdefault y\n\thelp\n\t  The xen filesystem provides a way for domains to share\n\t  information with each other and with the hypervisor.\n\t  For example, by reading and writing the \"xenbus\" file, guests\n\t  may pass arbitrary information to the initial domain.\n\t  If in doubt, say yes.\n\nconfig XEN_COMPAT_XENFS\n\tbool \"Create compatibility mount point /proc/xen\"\n\tdepends on XENFS\n\tdefault y\n\thelp\n\t  The old xenstore userspace tools expect to find \"xenbus\"\n\t  under /proc/xen, but \"xenbus\" is now found at the root of the\n\t  xenfs filesystem.  Selecting this causes the kernel to create\n\t  the compatibility mount point /proc/xen if it is running on\n\t  a xen platform.\n\t  If in doubt, say yes.\n\nconfig XEN_SYS_HYPERVISOR\n\tbool \"Create xen entries under /sys/hypervisor\"\n\tdepends on SYSFS\n\tselect SYS_HYPERVISOR\n\tdefault y\n\thelp\n\t  Create entries under /sys/hypervisor describing the Xen\n\t  hypervisor environment.  When running native or in another\n\t  virtual environment, /sys/hypervisor will still be present,\n\t  but will have no xen contents.\n\nconfig XEN_XENBUS_FRONTEND\n\ttristate\n\nconfig XEN_GNTDEV\n\ttristate \"userspace grant access device driver\"\n\tdepends on XEN\n\tdefault m\n\tselect MMU_NOTIFIER\n\thelp\n\t  Allows userspace processes to use grants.\n\nconfig XEN_GNTDEV_DMABUF\n\tbool \"Add support for dma-buf grant access device driver extension\"\n\tdepends on XEN_GNTDEV && XEN_GRANT_DMA_ALLOC\n\tselect DMA_SHARED_BUFFER\n\thelp\n\t  Allows userspace processes and kernel modules to use Xen backed\n\t  dma-buf implementation. With this extension grant references to\n\t  the pages of an imported dma-buf can be exported for other domain\n\t  use and grant references coming from a foreign domain can be\n\t  converted into a local dma-buf for local export.\n\nconfig XEN_GRANT_DEV_ALLOC\n\ttristate \"User-space grant reference allocator driver\"\n\tdepends on XEN\n\tdefault m\n\thelp\n\t  Allows userspace processes to create pages with access granted\n\t  to other domains. This can be used to implement frontend drivers\n\t  or as part of an inter-domain shared memory channel.\n\nconfig XEN_GRANT_DMA_ALLOC\n\tbool \"Allow allocating DMA capable buffers with grant reference module\"\n\tdepends on XEN && HAS_DMA\n\thelp\n\t  Extends grant table module API to allow allocating DMA capable\n\t  buffers and mapping foreign grant references on top of it.\n\t  The resulting buffer is similar to one allocated by the balloon\n\t  driver in that proper memory reservation is made by\n\t  ({increase|decrease}_reservation and VA mappings are updated if\n\t  needed).\n\t  This is useful for sharing foreign buffers with HW drivers which\n\t  cannot work with scattered buffers provided by the balloon driver,\n\t  but require DMAable memory instead.\n\nconfig SWIOTLB_XEN\n\tdef_bool y\n\tdepends on XEN_PV || ARM || ARM64\n\tselect DMA_OPS\n\tselect SWIOTLB\n\nconfig XEN_PCI_STUB\n\tbool\n\nconfig XEN_PCIDEV_STUB\n\ttristate \"Xen PCI-device stub driver\"\n\tdepends on PCI && !X86 && XEN\n\tdepends on XEN_BACKEND\n\tselect XEN_PCI_STUB\n\tdefault m\n\thelp\n\t  The PCI device stub driver provides limited version of the PCI\n\t  device backend driver without para-virtualized support for guests.\n\t  If you select this to be a module, you will need to make sure no\n\t  other driver has bound to the device(s) you want to make visible to\n\t  other guests.\n\n\t  The \"hide\" parameter (only applicable if backend driver is compiled\n\t  into the kernel) allows you to bind the PCI devices to this module\n\t  from the default device drivers. The argument is the list of PCI BDFs:\n\t  xen-pciback.hide=(03:00.0)(04:00.0)\n\n\t  If in doubt, say m.\n\nconfig XEN_PCIDEV_BACKEND\n\ttristate \"Xen PCI-device backend driver\"\n\tdepends on PCI && X86 && XEN\n\tdepends on XEN_BACKEND\n\tselect XEN_PCI_STUB\n\tdefault m\n\thelp\n\t  The PCI device backend driver allows the kernel to export arbitrary\n\t  PCI devices to other guests. If you select this to be a module, you\n\t  will need to make sure no other driver has bound to the device(s)\n\t  you want to make visible to other guests.\n\n\t  The parameter \"passthrough\" allows you specify how you want the PCI\n\t  devices to appear in the guest. You can choose the default (0) where\n\t  PCI topology starts at 00.00.0, or (1) for passthrough if you want\n\t  the PCI devices topology appear the same as in the host.\n\n\t  The \"hide\" parameter (only applicable if backend driver is compiled\n\t  into the kernel) allows you to bind the PCI devices to this module\n\t  from the default device drivers. The argument is the list of PCI BDFs:\n\t  xen-pciback.hide=(03:00.0)(04:00.0)\n\n\t  If in doubt, say m.\n\nconfig XEN_PVCALLS_FRONTEND\n\ttristate \"XEN PV Calls frontend driver\"\n\tdepends on INET && XEN\n\tselect XEN_XENBUS_FRONTEND\n\thelp\n\t  Experimental frontend for the Xen PV Calls protocol\n\t  (https://xenbits.xen.org/docs/unstable/misc/pvcalls.html). It\n\t  sends a small set of POSIX calls to the backend, which\n\t  implements them.\n\nconfig XEN_PVCALLS_BACKEND\n\ttristate \"XEN PV Calls backend driver\"\n\tdepends on INET && XEN && XEN_BACKEND\n\thelp\n\t  Experimental backend for the Xen PV Calls protocol\n\t  (https://xenbits.xen.org/docs/unstable/misc/pvcalls.html). It\n\t  allows PV Calls frontends to send POSIX calls to the backend,\n\t  which implements them.\n\n\t  If in doubt, say n.\n\nconfig XEN_SCSI_BACKEND\n\ttristate \"XEN SCSI backend driver\"\n\tdepends on XEN && XEN_BACKEND && TARGET_CORE\n\thelp\n\t  The SCSI backend driver allows the kernel to export its SCSI Devices\n\t  to other guests via a high-performance shared-memory interface.\n\t  Only needed for systems running as XEN driver domains (e.g. Dom0) and\n\t  if guests need generic access to SCSI devices.\n\nconfig XEN_PRIVCMD\n\ttristate \"Xen hypercall passthrough driver\"\n\tdepends on XEN\n\tdefault m\n\thelp\n\t  The hypercall passthrough driver allows privileged user programs to\n\t  perform Xen hypercalls. This driver is normally required for systems\n\t  running as Dom0 to perform privileged operations, but in some\n\t  disaggregated Xen setups this driver might be needed for other\n\t  domains, too.\n\nconfig XEN_PRIVCMD_IRQFD\n\tbool \"Xen irqfd support\"\n\tdepends on XEN_PRIVCMD && XEN_VIRTIO && EVENTFD\n\thelp\n\t  Using the irqfd mechanism a virtio backend running in a daemon can\n\t  speed up interrupt injection into a guest.\n\nconfig XEN_ACPI_PROCESSOR\n\ttristate \"Xen ACPI processor\"\n\tdepends on XEN && XEN_PV_DOM0 && X86 && ACPI_PROCESSOR && CPU_FREQ\n\tdefault m\n\thelp\n\t  This ACPI processor uploads Power Management information to the Xen\n\t  hypervisor.\n\n\t  To do that the driver parses the Power Management data and uploads\n\t  said information to the Xen hypervisor. Then the Xen hypervisor can\n\t  select the proper Cx and Pxx states. It also registers itself as the\n\t  SMM so that other drivers (such as ACPI cpufreq scaling driver) will\n\t  not load.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called xen_acpi_processor  If you do not know what to choose, select\n\t  M here. If the CPUFREQ drivers are built in, select Y here.\n\nconfig XEN_MCE_LOG\n\tbool \"Xen platform mcelog\"\n\tdepends on XEN_PV_DOM0 && X86_MCE\n\thelp\n\t  Allow kernel fetching MCE error from Xen platform and\n\t  converting it into Linux mcelog format for mcelog tools\n\nconfig XEN_HAVE_PVMMU\n\tbool\n\nconfig XEN_EFI\n\tdef_bool y\n\tdepends on (ARM || ARM64 || X86_64) && EFI\n\nconfig XEN_AUTO_XLATE\n\tdef_bool y\n\tdepends on ARM || ARM64 || XEN_PVHVM\n\thelp\n\t  Support for auto-translated physmap guests.\n\nconfig XEN_ACPI\n\tdef_bool y\n\tdepends on X86 && ACPI\n\nconfig XEN_SYMS\n\tbool \"Xen symbols\"\n\tdepends on X86 && XEN_DOM0 && XENFS\n\tdefault y if KALLSYMS\n\thelp\n\t  Exports hypervisor symbols (along with their types and addresses) via\n\t  /proc/xen/xensyms file, similar to /proc/kallsyms\n\nconfig XEN_HAVE_VPMU\n\tbool\n\nconfig XEN_FRONT_PGDIR_SHBUF\n\ttristate\n\nconfig XEN_UNPOPULATED_ALLOC\n\tbool \"Use unpopulated memory ranges for guest mappings\"\n\tdepends on ZONE_DEVICE\n\tdefault XEN_BACKEND || XEN_GNTDEV || XEN_DOM0\n\thelp\n\t  Use unpopulated memory ranges in order to create mappings for guest\n\t  memory regions, including grant maps and foreign pages. This avoids\n\t  having to balloon out RAM regions in order to obtain physical memory\n\t  space to create such mappings.\n\nconfig XEN_GRANT_DMA_IOMMU\n\tbool\n\tselect IOMMU_API\n\nconfig XEN_GRANT_DMA_OPS\n\tbool\n\tselect DMA_OPS\n\nconfig XEN_VIRTIO\n\tbool \"Xen virtio support\"\n\tdepends on VIRTIO\n\tselect XEN_GRANT_DMA_OPS\n\tselect XEN_GRANT_DMA_IOMMU if OF\n\thelp\n\t  Enable virtio support for running as Xen guest. Depending on the\n\t  guest type this will require special support on the backend side\n\t  (qemu or kernel, depending on the virtio device types used).\n\n\t  If in doubt, say n.\n\nconfig XEN_VIRTIO_FORCE_GRANT\n\tbool \"Require Xen virtio support to use grants\"\n\tdepends on XEN_VIRTIO\n\thelp\n\t  Require virtio for Xen guests to use grant mappings.\n\t  This will avoid the need to give the backend the right to map all\n\t  of the guest memory. This will need support on the backend side\n\t  (e.g. qemu or kernel, depending on the virtio device types used).\n\nendmenu\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}