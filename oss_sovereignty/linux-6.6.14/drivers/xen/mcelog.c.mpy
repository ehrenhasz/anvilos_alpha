{
  "module_name": "mcelog.c",
  "hash_id": "d26d9b5a1694b455fb2731523f1770e1a46ad8c7728860fbe8fd3e9447bfe3a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/mcelog.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"xen_mcelog: \" fmt\n\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/miscdevice.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n\n#include <xen/interface/xen.h>\n#include <xen/events.h>\n#include <xen/interface/vcpu.h>\n#include <xen/xen.h>\n#include <asm/xen/hypercall.h>\n#include <asm/xen/hypervisor.h>\n\nstatic struct mc_info g_mi;\nstatic struct mcinfo_logical_cpu *g_physinfo;\nstatic uint32_t ncpus;\n\nstatic DEFINE_MUTEX(mcelog_lock);\n\nstatic struct xen_mce_log xen_mcelog = {\n\t.signature\t= XEN_MCE_LOG_SIGNATURE,\n\t.len\t\t= XEN_MCE_LOG_LEN,\n\t.recordlen\t= sizeof(struct xen_mce),\n};\n\nstatic DEFINE_SPINLOCK(xen_mce_chrdev_state_lock);\nstatic int xen_mce_chrdev_open_count;\t \nstatic int xen_mce_chrdev_open_exclu;\t \n\nstatic DECLARE_WAIT_QUEUE_HEAD(xen_mce_chrdev_wait);\n\nstatic int xen_mce_chrdev_open(struct inode *inode, struct file *file)\n{\n\tspin_lock(&xen_mce_chrdev_state_lock);\n\n\tif (xen_mce_chrdev_open_exclu ||\n\t    (xen_mce_chrdev_open_count && (file->f_flags & O_EXCL))) {\n\t\tspin_unlock(&xen_mce_chrdev_state_lock);\n\n\t\treturn -EBUSY;\n\t}\n\n\tif (file->f_flags & O_EXCL)\n\t\txen_mce_chrdev_open_exclu = 1;\n\txen_mce_chrdev_open_count++;\n\n\tspin_unlock(&xen_mce_chrdev_state_lock);\n\n\treturn nonseekable_open(inode, file);\n}\n\nstatic int xen_mce_chrdev_release(struct inode *inode, struct file *file)\n{\n\tspin_lock(&xen_mce_chrdev_state_lock);\n\n\txen_mce_chrdev_open_count--;\n\txen_mce_chrdev_open_exclu = 0;\n\n\tspin_unlock(&xen_mce_chrdev_state_lock);\n\n\treturn 0;\n}\n\nstatic ssize_t xen_mce_chrdev_read(struct file *filp, char __user *ubuf,\n\t\t\t\tsize_t usize, loff_t *off)\n{\n\tchar __user *buf = ubuf;\n\tunsigned num;\n\tint i, err;\n\n\tmutex_lock(&mcelog_lock);\n\n\tnum = xen_mcelog.next;\n\n\t \n\terr = -EINVAL;\n\tif (*off != 0 || usize < XEN_MCE_LOG_LEN*sizeof(struct xen_mce))\n\t\tgoto out;\n\n\terr = 0;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct xen_mce *m = &xen_mcelog.entry[i];\n\n\t\terr |= copy_to_user(buf, m, sizeof(*m));\n\t\tbuf += sizeof(*m);\n\t}\n\n\tmemset(xen_mcelog.entry, 0, num * sizeof(struct xen_mce));\n\txen_mcelog.next = 0;\n\n\tif (err)\n\t\terr = -EFAULT;\n\nout:\n\tmutex_unlock(&mcelog_lock);\n\n\treturn err ? err : buf - ubuf;\n}\n\nstatic __poll_t xen_mce_chrdev_poll(struct file *file, poll_table *wait)\n{\n\tpoll_wait(file, &xen_mce_chrdev_wait, wait);\n\n\tif (xen_mcelog.next)\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\n\treturn 0;\n}\n\nstatic long xen_mce_chrdev_ioctl(struct file *f, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tint __user *p = (int __user *)arg;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase MCE_GET_RECORD_LEN:\n\t\treturn put_user(sizeof(struct xen_mce), p);\n\tcase MCE_GET_LOG_LEN:\n\t\treturn put_user(XEN_MCE_LOG_LEN, p);\n\tcase MCE_GETCLEAR_FLAGS: {\n\t\tunsigned flags;\n\n\t\tdo {\n\t\t\tflags = xen_mcelog.flags;\n\t\t} while (cmpxchg(&xen_mcelog.flags, flags, 0) != flags);\n\n\t\treturn put_user(flags, p);\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic const struct file_operations xen_mce_chrdev_ops = {\n\t.open\t\t\t= xen_mce_chrdev_open,\n\t.release\t\t= xen_mce_chrdev_release,\n\t.read\t\t\t= xen_mce_chrdev_read,\n\t.poll\t\t\t= xen_mce_chrdev_poll,\n\t.unlocked_ioctl\t\t= xen_mce_chrdev_ioctl,\n\t.llseek\t\t\t= no_llseek,\n};\n\nstatic struct miscdevice xen_mce_chrdev_device = {\n\tMISC_MCELOG_MINOR,\n\t\"mcelog\",\n\t&xen_mce_chrdev_ops,\n};\n\n \nstatic void xen_mce_log(struct xen_mce *mce)\n{\n\tunsigned entry;\n\n\tentry = xen_mcelog.next;\n\n\t \n\tif (entry >= XEN_MCE_LOG_LEN) {\n\t\tset_bit(XEN_MCE_OVERFLOW,\n\t\t\t(unsigned long *)&xen_mcelog.flags);\n\t\treturn;\n\t}\n\n\tmemcpy(xen_mcelog.entry + entry, mce, sizeof(struct xen_mce));\n\n\txen_mcelog.next++;\n}\n\nstatic int convert_log(struct mc_info *mi)\n{\n\tstruct mcinfo_common *mic;\n\tstruct mcinfo_global *mc_global;\n\tstruct mcinfo_bank *mc_bank;\n\tstruct xen_mce m;\n\tunsigned int i, j;\n\n\tmic = NULL;\n\tx86_mcinfo_lookup(&mic, mi, MC_TYPE_GLOBAL);\n\tif (unlikely(!mic)) {\n\t\tpr_warn(\"Failed to find global error info\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmemset(&m, 0, sizeof(struct xen_mce));\n\n\tmc_global = (struct mcinfo_global *)mic;\n\tm.mcgstatus = mc_global->mc_gstatus;\n\tm.apicid = mc_global->mc_apicid;\n\n\tfor (i = 0; i < ncpus; i++)\n\t\tif (g_physinfo[i].mc_apicid == m.apicid)\n\t\t\tbreak;\n\tif (unlikely(i == ncpus)) {\n\t\tpr_warn(\"Failed to match cpu with apicid %d\\n\", m.apicid);\n\t\treturn -ENODEV;\n\t}\n\n\tm.socketid = g_physinfo[i].mc_chipid;\n\tm.cpu = m.extcpu = g_physinfo[i].mc_cpunr;\n\tm.cpuvendor = (__u8)g_physinfo[i].mc_vendor;\n\tfor (j = 0; j < g_physinfo[i].mc_nmsrvals; ++j)\n\t\tswitch (g_physinfo[i].mc_msrvalues[j].reg) {\n\t\tcase MSR_IA32_MCG_CAP:\n\t\t\tm.mcgcap = g_physinfo[i].mc_msrvalues[j].value;\n\t\t\tbreak;\n\n\t\tcase MSR_PPIN:\n\t\tcase MSR_AMD_PPIN:\n\t\t\tm.ppin = g_physinfo[i].mc_msrvalues[j].value;\n\t\t\tbreak;\n\t\t}\n\n\tmic = NULL;\n\tx86_mcinfo_lookup(&mic, mi, MC_TYPE_BANK);\n\tif (unlikely(!mic)) {\n\t\tpr_warn(\"Fail to find bank error info\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdo {\n\t\tif ((!mic) || (mic->size == 0) ||\n\t\t    (mic->type != MC_TYPE_GLOBAL   &&\n\t\t     mic->type != MC_TYPE_BANK     &&\n\t\t     mic->type != MC_TYPE_EXTENDED &&\n\t\t     mic->type != MC_TYPE_RECOVERY))\n\t\t\tbreak;\n\n\t\tif (mic->type == MC_TYPE_BANK) {\n\t\t\tmc_bank = (struct mcinfo_bank *)mic;\n\t\t\tm.misc = mc_bank->mc_misc;\n\t\t\tm.status = mc_bank->mc_status;\n\t\t\tm.addr = mc_bank->mc_addr;\n\t\t\tm.tsc = mc_bank->mc_tsc;\n\t\t\tm.bank = mc_bank->mc_bank;\n\t\t\tm.finished = 1;\n\t\t\t \n\t\t\txen_mce_log(&m);\n\t\t}\n\t\tmic = x86_mcinfo_next(mic);\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic int mc_queue_handle(uint32_t flags)\n{\n\tstruct xen_mc mc_op;\n\tint ret = 0;\n\n\tmc_op.cmd = XEN_MC_fetch;\n\tset_xen_guest_handle(mc_op.u.mc_fetch.data, &g_mi);\n\tdo {\n\t\tmc_op.u.mc_fetch.flags = flags;\n\t\tret = HYPERVISOR_mca(&mc_op);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to fetch %surgent error log\\n\",\n\t\t\t       flags == XEN_MC_URGENT ? \"\" : \"non\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mc_op.u.mc_fetch.flags & XEN_MC_NODATA ||\n\t\t    mc_op.u.mc_fetch.flags & XEN_MC_FETCHFAILED)\n\t\t\tbreak;\n\t\telse {\n\t\t\tret = convert_log(&g_mi);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to convert this error log, continue acking it anyway\\n\");\n\n\t\t\tmc_op.u.mc_fetch.flags = flags | XEN_MC_ACK;\n\t\t\tret = HYPERVISOR_mca(&mc_op);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"Failed to ack previous error log\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (1);\n\n\treturn ret;\n}\n\n \nstatic void xen_mce_work_fn(struct work_struct *work)\n{\n\tint err;\n\n\tmutex_lock(&mcelog_lock);\n\n\t \n\terr = mc_queue_handle(XEN_MC_URGENT);\n\tif (err)\n\t\tpr_err(\"Failed to handle urgent mc_info queue, continue handling nonurgent mc_info queue anyway\\n\");\n\n\t \n\terr = mc_queue_handle(XEN_MC_NONURGENT);\n\tif (err)\n\t\tpr_err(\"Failed to handle nonurgent mc_info queue\\n\");\n\n\t \n\twake_up_interruptible(&xen_mce_chrdev_wait);\n\n\tmutex_unlock(&mcelog_lock);\n}\nstatic DECLARE_WORK(xen_mce_work, xen_mce_work_fn);\n\nstatic irqreturn_t xen_mce_interrupt(int irq, void *dev_id)\n{\n\tschedule_work(&xen_mce_work);\n\treturn IRQ_HANDLED;\n}\n\nstatic int bind_virq_for_mce(void)\n{\n\tint ret;\n\tstruct xen_mc mc_op;\n\n\tmemset(&mc_op, 0, sizeof(struct xen_mc));\n\n\t \n\tmc_op.cmd = XEN_MC_physcpuinfo;\n\tset_xen_guest_handle(mc_op.u.mc_physcpuinfo.info, g_physinfo);\n\tret = HYPERVISOR_mca(&mc_op);\n\tif (ret) {\n\t\tpr_err(\"Failed to get CPU numbers\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tncpus = mc_op.u.mc_physcpuinfo.ncpus;\n\tg_physinfo = kcalloc(ncpus, sizeof(struct mcinfo_logical_cpu),\n\t\t\t     GFP_KERNEL);\n\tif (!g_physinfo)\n\t\treturn -ENOMEM;\n\tset_xen_guest_handle(mc_op.u.mc_physcpuinfo.info, g_physinfo);\n\tret = HYPERVISOR_mca(&mc_op);\n\tif (ret) {\n\t\tpr_err(\"Failed to get CPU info\\n\");\n\t\tkfree(g_physinfo);\n\t\treturn ret;\n\t}\n\n\tret  = bind_virq_to_irqhandler(VIRQ_MCA, 0,\n\t\t\t\t       xen_mce_interrupt, 0, \"mce\", NULL);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to bind virq\\n\");\n\t\tkfree(g_physinfo);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init xen_late_init_mcelog(void)\n{\n\tint ret;\n\n\t \n\tif (!xen_initial_domain())\n\t\treturn -ENODEV;\n\n\t \n\tret = misc_register(&xen_mce_chrdev_device);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bind_virq_for_mce();\n\tif (ret)\n\t\tgoto deregister;\n\n\tpr_info(\"/dev/mcelog registered by Xen\\n\");\n\n\treturn 0;\n\nderegister:\n\tmisc_deregister(&xen_mce_chrdev_device);\n\treturn ret;\n}\ndevice_initcall(xen_late_init_mcelog);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}