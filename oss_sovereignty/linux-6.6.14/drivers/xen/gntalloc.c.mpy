{
  "module_name": "gntalloc.c",
  "hash_id": "db44949809f12168596f171a5df23fe70b8b107ca75c2283b94171e45b38f4ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/gntalloc.c",
  "human_readable_source": " \n\n \n\n#define pr_fmt(fmt) \"xen:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/atomic.h>\n#include <linux/module.h>\n#include <linux/miscdevice.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/mm.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n\n#include <xen/xen.h>\n#include <xen/page.h>\n#include <xen/grant_table.h>\n#include <xen/gntalloc.h>\n#include <xen/events.h>\n\nstatic int limit = 1024;\nmodule_param(limit, int, 0644);\nMODULE_PARM_DESC(limit, \"Maximum number of grants that may be allocated by \"\n\t\t\"the gntalloc device\");\n\nstatic LIST_HEAD(gref_list);\nstatic DEFINE_MUTEX(gref_mutex);\nstatic int gref_size;\n\nstruct notify_info {\n\tuint16_t pgoff:12;     \n\tuint16_t flags:2;      \n\tint event;             \n};\n\n \nstruct gntalloc_gref {\n\tstruct list_head next_gref;   \n\tstruct list_head next_file;   \n\tstruct page *page;\t      \n\tuint64_t file_index;          \n\tunsigned int users;           \n\tgrant_ref_t gref_id;          \n\tstruct notify_info notify;    \n};\n\nstruct gntalloc_file_private_data {\n\tstruct list_head list;\n\tuint64_t index;\n};\n\nstruct gntalloc_vma_private_data {\n\tstruct gntalloc_gref *gref;\n\tint users;\n\tint count;\n};\n\nstatic void __del_gref(struct gntalloc_gref *gref);\n\nstatic void do_cleanup(void)\n{\n\tstruct gntalloc_gref *gref, *n;\n\tlist_for_each_entry_safe(gref, n, &gref_list, next_gref) {\n\t\tif (!gref->users)\n\t\t\t__del_gref(gref);\n\t}\n}\n\nstatic int add_grefs(struct ioctl_gntalloc_alloc_gref *op,\n\tuint32_t *gref_ids, struct gntalloc_file_private_data *priv)\n{\n\tint i, rc, readonly;\n\tLIST_HEAD(queue_gref);\n\tLIST_HEAD(queue_file);\n\tstruct gntalloc_gref *gref, *next;\n\n\treadonly = !(op->flags & GNTALLOC_FLAG_WRITABLE);\n\tfor (i = 0; i < op->count; i++) {\n\t\tgref = kzalloc(sizeof(*gref), GFP_KERNEL);\n\t\tif (!gref) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto undo;\n\t\t}\n\t\tlist_add_tail(&gref->next_gref, &queue_gref);\n\t\tlist_add_tail(&gref->next_file, &queue_file);\n\t\tgref->users = 1;\n\t\tgref->file_index = op->index + i * PAGE_SIZE;\n\t\tgref->page = alloc_page(GFP_KERNEL|__GFP_ZERO);\n\t\tif (!gref->page) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto undo;\n\t\t}\n\n\t\t \n\t\trc = gnttab_grant_foreign_access(op->domid,\n\t\t\t\t\t\t xen_page_to_gfn(gref->page),\n\t\t\t\t\t\t readonly);\n\t\tif (rc < 0)\n\t\t\tgoto undo;\n\t\tgref_ids[i] = gref->gref_id = rc;\n\t}\n\n\t \n\tmutex_lock(&gref_mutex);\n\tlist_splice_tail(&queue_gref, &gref_list);\n\tlist_splice_tail(&queue_file, &priv->list);\n\tmutex_unlock(&gref_mutex);\n\n\treturn 0;\n\nundo:\n\tmutex_lock(&gref_mutex);\n\tgref_size -= (op->count - i);\n\n\tlist_for_each_entry_safe(gref, next, &queue_file, next_file) {\n\t\tlist_del(&gref->next_file);\n\t\t__del_gref(gref);\n\t}\n\n\tmutex_unlock(&gref_mutex);\n\treturn rc;\n}\n\nstatic void __del_gref(struct gntalloc_gref *gref)\n{\n\tif (gref->notify.flags & UNMAP_NOTIFY_CLEAR_BYTE) {\n\t\tuint8_t *tmp = kmap_local_page(gref->page);\n\t\ttmp[gref->notify.pgoff] = 0;\n\t\tkunmap_local(tmp);\n\t}\n\tif (gref->notify.flags & UNMAP_NOTIFY_SEND_EVENT) {\n\t\tnotify_remote_via_evtchn(gref->notify.event);\n\t\tevtchn_put(gref->notify.event);\n\t}\n\n\tgref->notify.flags = 0;\n\n\tif (gref->gref_id) {\n\t\tif (gref->page)\n\t\t\tgnttab_end_foreign_access(gref->gref_id, gref->page);\n\t\telse\n\t\t\tgnttab_free_grant_reference(gref->gref_id);\n\t}\n\n\tgref_size--;\n\tlist_del(&gref->next_gref);\n\n\tkfree(gref);\n}\n\n \nstatic struct gntalloc_gref *find_grefs(struct gntalloc_file_private_data *priv,\n\t\tuint64_t index, uint32_t count)\n{\n\tstruct gntalloc_gref *rv = NULL, *gref;\n\tlist_for_each_entry(gref, &priv->list, next_file) {\n\t\tif (gref->file_index == index && !rv)\n\t\t\trv = gref;\n\t\tif (rv) {\n\t\t\tif (gref->file_index != index)\n\t\t\t\treturn NULL;\n\t\t\tindex += PAGE_SIZE;\n\t\t\tcount--;\n\t\t\tif (count == 0)\n\t\t\t\treturn rv;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic int gntalloc_open(struct inode *inode, struct file *filp)\n{\n\tstruct gntalloc_file_private_data *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\tgoto out_nomem;\n\tINIT_LIST_HEAD(&priv->list);\n\n\tfilp->private_data = priv;\n\n\tpr_debug(\"%s: priv %p\\n\", __func__, priv);\n\n\treturn 0;\n\nout_nomem:\n\treturn -ENOMEM;\n}\n\nstatic int gntalloc_release(struct inode *inode, struct file *filp)\n{\n\tstruct gntalloc_file_private_data *priv = filp->private_data;\n\tstruct gntalloc_gref *gref;\n\n\tpr_debug(\"%s: priv %p\\n\", __func__, priv);\n\n\tmutex_lock(&gref_mutex);\n\twhile (!list_empty(&priv->list)) {\n\t\tgref = list_entry(priv->list.next,\n\t\t\tstruct gntalloc_gref, next_file);\n\t\tlist_del(&gref->next_file);\n\t\tgref->users--;\n\t\tif (gref->users == 0)\n\t\t\t__del_gref(gref);\n\t}\n\tkfree(priv);\n\tmutex_unlock(&gref_mutex);\n\n\treturn 0;\n}\n\nstatic long gntalloc_ioctl_alloc(struct gntalloc_file_private_data *priv,\n\t\tstruct ioctl_gntalloc_alloc_gref __user *arg)\n{\n\tint rc = 0;\n\tstruct ioctl_gntalloc_alloc_gref op;\n\tuint32_t *gref_ids;\n\n\tpr_debug(\"%s: priv %p\\n\", __func__, priv);\n\n\tif (copy_from_user(&op, arg, sizeof(op))) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tgref_ids = kcalloc(op.count, sizeof(gref_ids[0]), GFP_KERNEL);\n\tif (!gref_ids) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&gref_mutex);\n\t \n\tdo_cleanup();\n\tif (gref_size + op.count > limit) {\n\t\tmutex_unlock(&gref_mutex);\n\t\trc = -ENOSPC;\n\t\tgoto out_free;\n\t}\n\tgref_size += op.count;\n\top.index = priv->index;\n\tpriv->index += op.count * PAGE_SIZE;\n\tmutex_unlock(&gref_mutex);\n\n\trc = add_grefs(&op, gref_ids, priv);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\t \n\tif (copy_to_user(arg, &op, sizeof(op))) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tif (copy_to_user(arg->gref_ids, gref_ids,\n\t\t\tsizeof(gref_ids[0]) * op.count)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(gref_ids);\nout:\n\treturn rc;\n}\n\nstatic long gntalloc_ioctl_dealloc(struct gntalloc_file_private_data *priv,\n\t\tvoid __user *arg)\n{\n\tint i, rc = 0;\n\tstruct ioctl_gntalloc_dealloc_gref op;\n\tstruct gntalloc_gref *gref, *n;\n\n\tpr_debug(\"%s: priv %p\\n\", __func__, priv);\n\n\tif (copy_from_user(&op, arg, sizeof(op))) {\n\t\trc = -EFAULT;\n\t\tgoto dealloc_grant_out;\n\t}\n\n\tmutex_lock(&gref_mutex);\n\tgref = find_grefs(priv, op.index, op.count);\n\tif (gref) {\n\t\t \n\t\tfor (i = 0; i < op.count; i++) {\n\t\t\tn = list_entry(gref->next_file.next,\n\t\t\t\tstruct gntalloc_gref, next_file);\n\t\t\tlist_del(&gref->next_file);\n\t\t\tgref->users--;\n\t\t\tgref = n;\n\t\t}\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\n\tdo_cleanup();\n\n\tmutex_unlock(&gref_mutex);\ndealloc_grant_out:\n\treturn rc;\n}\n\nstatic long gntalloc_ioctl_unmap_notify(struct gntalloc_file_private_data *priv,\n\t\tvoid __user *arg)\n{\n\tstruct ioctl_gntalloc_unmap_notify op;\n\tstruct gntalloc_gref *gref;\n\tuint64_t index;\n\tint pgoff;\n\tint rc;\n\n\tif (copy_from_user(&op, arg, sizeof(op)))\n\t\treturn -EFAULT;\n\n\tindex = op.index & ~(PAGE_SIZE - 1);\n\tpgoff = op.index & (PAGE_SIZE - 1);\n\n\tmutex_lock(&gref_mutex);\n\n\tgref = find_grefs(priv, index, 1);\n\tif (!gref) {\n\t\trc = -ENOENT;\n\t\tgoto unlock_out;\n\t}\n\n\tif (op.action & ~(UNMAP_NOTIFY_CLEAR_BYTE|UNMAP_NOTIFY_SEND_EVENT)) {\n\t\trc = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\n\t \n\tif (op.action & UNMAP_NOTIFY_SEND_EVENT) {\n\t\tif (evtchn_get(op.event_channel_port)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto unlock_out;\n\t\t}\n\t}\n\n\tif (gref->notify.flags & UNMAP_NOTIFY_SEND_EVENT)\n\t\tevtchn_put(gref->notify.event);\n\n\tgref->notify.flags = op.action;\n\tgref->notify.pgoff = pgoff;\n\tgref->notify.event = op.event_channel_port;\n\trc = 0;\n\n unlock_out:\n\tmutex_unlock(&gref_mutex);\n\treturn rc;\n}\n\nstatic long gntalloc_ioctl(struct file *filp, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct gntalloc_file_private_data *priv = filp->private_data;\n\n\tswitch (cmd) {\n\tcase IOCTL_GNTALLOC_ALLOC_GREF:\n\t\treturn gntalloc_ioctl_alloc(priv, (void __user *)arg);\n\n\tcase IOCTL_GNTALLOC_DEALLOC_GREF:\n\t\treturn gntalloc_ioctl_dealloc(priv, (void __user *)arg);\n\n\tcase IOCTL_GNTALLOC_SET_UNMAP_NOTIFY:\n\t\treturn gntalloc_ioctl_unmap_notify(priv, (void __user *)arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic void gntalloc_vma_open(struct vm_area_struct *vma)\n{\n\tstruct gntalloc_vma_private_data *priv = vma->vm_private_data;\n\n\tif (!priv)\n\t\treturn;\n\n\tmutex_lock(&gref_mutex);\n\tpriv->users++;\n\tmutex_unlock(&gref_mutex);\n}\n\nstatic void gntalloc_vma_close(struct vm_area_struct *vma)\n{\n\tstruct gntalloc_vma_private_data *priv = vma->vm_private_data;\n\tstruct gntalloc_gref *gref, *next;\n\tint i;\n\n\tif (!priv)\n\t\treturn;\n\n\tmutex_lock(&gref_mutex);\n\tpriv->users--;\n\tif (priv->users == 0) {\n\t\tgref = priv->gref;\n\t\tfor (i = 0; i < priv->count; i++) {\n\t\t\tgref->users--;\n\t\t\tnext = list_entry(gref->next_gref.next,\n\t\t\t\t\t  struct gntalloc_gref, next_gref);\n\t\t\tif (gref->users == 0)\n\t\t\t\t__del_gref(gref);\n\t\t\tgref = next;\n\t\t}\n\t\tkfree(priv);\n\t}\n\tmutex_unlock(&gref_mutex);\n}\n\nstatic const struct vm_operations_struct gntalloc_vmops = {\n\t.open = gntalloc_vma_open,\n\t.close = gntalloc_vma_close,\n};\n\nstatic int gntalloc_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct gntalloc_file_private_data *priv = filp->private_data;\n\tstruct gntalloc_vma_private_data *vm_priv;\n\tstruct gntalloc_gref *gref;\n\tint count = vma_pages(vma);\n\tint rv, i;\n\n\tif (!(vma->vm_flags & VM_SHARED)) {\n\t\tpr_err(\"%s: Mapping must be shared\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tvm_priv = kmalloc(sizeof(*vm_priv), GFP_KERNEL);\n\tif (!vm_priv)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&gref_mutex);\n\n\tpr_debug(\"%s: priv %p,%p, page %lu+%d\\n\", __func__,\n\t\t       priv, vm_priv, vma->vm_pgoff, count);\n\n\tgref = find_grefs(priv, vma->vm_pgoff << PAGE_SHIFT, count);\n\tif (gref == NULL) {\n\t\trv = -ENOENT;\n\t\tpr_debug(\"%s: Could not find grant reference\",\n\t\t\t\t__func__);\n\t\tkfree(vm_priv);\n\t\tgoto out_unlock;\n\t}\n\n\tvm_priv->gref = gref;\n\tvm_priv->users = 1;\n\tvm_priv->count = count;\n\n\tvma->vm_private_data = vm_priv;\n\n\tvm_flags_set(vma, VM_DONTEXPAND | VM_DONTDUMP);\n\n\tvma->vm_ops = &gntalloc_vmops;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgref->users++;\n\t\trv = vm_insert_page(vma, vma->vm_start + i * PAGE_SIZE,\n\t\t\t\tgref->page);\n\t\tif (rv)\n\t\t\tgoto out_unlock;\n\n\t\tgref = list_entry(gref->next_file.next,\n\t\t\t\tstruct gntalloc_gref, next_file);\n\t}\n\trv = 0;\n\nout_unlock:\n\tmutex_unlock(&gref_mutex);\n\treturn rv;\n}\n\nstatic const struct file_operations gntalloc_fops = {\n\t.owner = THIS_MODULE,\n\t.open = gntalloc_open,\n\t.release = gntalloc_release,\n\t.unlocked_ioctl = gntalloc_ioctl,\n\t.mmap = gntalloc_mmap\n};\n\n \nstatic struct miscdevice gntalloc_miscdev = {\n\t.minor\t= MISC_DYNAMIC_MINOR,\n\t.name\t= \"xen/gntalloc\",\n\t.fops\t= &gntalloc_fops,\n};\n\nstatic int __init gntalloc_init(void)\n{\n\tint err;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\terr = misc_register(&gntalloc_miscdev);\n\tif (err != 0) {\n\t\tpr_err(\"Could not register misc gntalloc device\\n\");\n\t\treturn err;\n\t}\n\n\tpr_debug(\"Created grant allocation device at %d,%d\\n\",\n\t\t\tMISC_MAJOR, gntalloc_miscdev.minor);\n\n\treturn 0;\n}\n\nstatic void __exit gntalloc_exit(void)\n{\n\tmisc_deregister(&gntalloc_miscdev);\n}\n\nmodule_init(gntalloc_init);\nmodule_exit(gntalloc_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Carter Weatherly <carter.weatherly@jhuapl.edu>, \"\n\t\t\"Daniel De Graaf <dgdegra@tycho.nsa.gov>\");\nMODULE_DESCRIPTION(\"User-space grant reference allocator driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}