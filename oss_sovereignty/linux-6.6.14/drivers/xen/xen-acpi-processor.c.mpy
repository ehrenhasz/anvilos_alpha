{
  "module_name": "xen-acpi-processor.c",
  "hash_id": "307e3b33f78e84cc216c4d955c8eedb5b83dda4b087a2f3a894e33d2af50d9db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/xen/xen-acpi-processor.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/freezer.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/syscore_ops.h>\n#include <linux/acpi.h>\n#include <acpi/processor.h>\n#include <xen/xen.h>\n#include <xen/interface/platform.h>\n#include <asm/xen/hypercall.h>\n\nstatic int no_hypercall;\nMODULE_PARM_DESC(off, \"Inhibit the hypercall.\");\nmodule_param_named(off, no_hypercall, int, 0400);\n\n \nstatic unsigned int nr_acpi_bits;\n \nstatic DEFINE_MUTEX(acpi_ids_mutex);\n \nstatic unsigned long *acpi_ids_done;\n \nstatic unsigned long *acpi_id_present;\n \nstatic unsigned long *acpi_id_cst_present;\n \nstatic struct acpi_psd_package *acpi_psd;\n\nstatic int push_cxx_to_hypervisor(struct acpi_processor *_pr)\n{\n\tstruct xen_platform_op op = {\n\t\t.cmd\t\t\t= XENPF_set_processor_pminfo,\n\t\t.interface_version\t= XENPF_INTERFACE_VERSION,\n\t\t.u.set_pminfo.id\t= _pr->acpi_id,\n\t\t.u.set_pminfo.type\t= XEN_PM_CX,\n\t};\n\tstruct xen_processor_cx *dst_cx, *dst_cx_states = NULL;\n\tstruct acpi_processor_cx *cx;\n\tunsigned int i, ok;\n\tint ret = 0;\n\n\tdst_cx_states = kcalloc(_pr->power.count,\n\t\t\t\tsizeof(struct xen_processor_cx), GFP_KERNEL);\n\tif (!dst_cx_states)\n\t\treturn -ENOMEM;\n\n\tfor (ok = 0, i = 1; i <= _pr->power.count; i++) {\n\t\tcx = &_pr->power.states[i];\n\t\tif (!cx->valid)\n\t\t\tcontinue;\n\n\t\tdst_cx = &(dst_cx_states[ok++]);\n\n\t\tdst_cx->reg.space_id = ACPI_ADR_SPACE_SYSTEM_IO;\n\t\tif (cx->entry_method == ACPI_CSTATE_SYSTEMIO) {\n\t\t\tdst_cx->reg.bit_width = 8;\n\t\t\tdst_cx->reg.bit_offset = 0;\n\t\t\tdst_cx->reg.access_size = 1;\n\t\t} else {\n\t\t\tdst_cx->reg.space_id = ACPI_ADR_SPACE_FIXED_HARDWARE;\n\t\t\tif (cx->entry_method == ACPI_CSTATE_FFH) {\n\t\t\t\t \n\t\t\t\tdst_cx->reg.bit_offset = 2;\n\t\t\t\tdst_cx->reg.bit_width = 1;  \n\t\t\t}\n\t\t\tdst_cx->reg.access_size = 0;\n\t\t}\n\t\tdst_cx->reg.address = cx->address;\n\n\t\tdst_cx->type = cx->type;\n\t\tdst_cx->latency = cx->latency;\n\n\t\tdst_cx->dpcnt = 0;\n\t\tset_xen_guest_handle(dst_cx->dp, NULL);\n\t}\n\tif (!ok) {\n\t\tpr_debug(\"No _Cx for ACPI CPU %u\\n\", _pr->acpi_id);\n\t\tkfree(dst_cx_states);\n\t\treturn -EINVAL;\n\t}\n\top.u.set_pminfo.power.count = ok;\n\top.u.set_pminfo.power.flags.bm_control = _pr->flags.bm_control;\n\top.u.set_pminfo.power.flags.bm_check = _pr->flags.bm_check;\n\top.u.set_pminfo.power.flags.has_cst = _pr->flags.has_cst;\n\top.u.set_pminfo.power.flags.power_setup_done =\n\t\t_pr->flags.power_setup_done;\n\n\tset_xen_guest_handle(op.u.set_pminfo.power.states, dst_cx_states);\n\n\tif (!no_hypercall)\n\t\tret = HYPERVISOR_platform_op(&op);\n\n\tif (!ret) {\n\t\tpr_debug(\"ACPI CPU%u - C-states uploaded.\\n\", _pr->acpi_id);\n\t\tfor (i = 1; i <= _pr->power.count; i++) {\n\t\t\tcx = &_pr->power.states[i];\n\t\t\tif (!cx->valid)\n\t\t\t\tcontinue;\n\t\t\tpr_debug(\"     C%d: %s %d uS\\n\",\n\t\t\t\t cx->type, cx->desc, (u32)cx->latency);\n\t\t}\n\t} else if ((ret != -EINVAL) && (ret != -ENOSYS))\n\t\t \n\t\tpr_err(\"(CX): Hypervisor error (%d) for ACPI CPU%u\\n\",\n\t\t       ret, _pr->acpi_id);\n\n\tkfree(dst_cx_states);\n\n\treturn ret;\n}\nstatic struct xen_processor_px *\nxen_copy_pss_data(struct acpi_processor *_pr,\n\t\t  struct xen_processor_performance *dst_perf)\n{\n\tstruct xen_processor_px *dst_states = NULL;\n\tunsigned int i;\n\n\tBUILD_BUG_ON(sizeof(struct xen_processor_px) !=\n\t\t     sizeof(struct acpi_processor_px));\n\n\tdst_states = kcalloc(_pr->performance->state_count,\n\t\t\t     sizeof(struct xen_processor_px), GFP_KERNEL);\n\tif (!dst_states)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdst_perf->state_count = _pr->performance->state_count;\n\tfor (i = 0; i < _pr->performance->state_count; i++) {\n\t\t \n\t\tmemcpy(&(dst_states[i]), &(_pr->performance->states[i]),\n\t\t       sizeof(struct acpi_processor_px));\n\t}\n\treturn dst_states;\n}\nstatic int xen_copy_psd_data(struct acpi_processor *_pr,\n\t\t\t     struct xen_processor_performance *dst)\n{\n\tstruct acpi_psd_package *pdomain;\n\n\tBUILD_BUG_ON(sizeof(struct xen_psd_package) !=\n\t\t     sizeof(struct acpi_psd_package));\n\n\t \n\tdst->shared_type = _pr->performance->shared_type;\n\n\tpdomain = &(_pr->performance->domain_info);\n\n\t \n\tif (pdomain->num_processors <= 1) {\n\t\tif (pdomain->coord_type == DOMAIN_COORD_TYPE_SW_ALL)\n\t\t\tdst->shared_type = CPUFREQ_SHARED_TYPE_ALL;\n\t\telse if (pdomain->coord_type == DOMAIN_COORD_TYPE_HW_ALL)\n\t\t\tdst->shared_type = CPUFREQ_SHARED_TYPE_HW;\n\t\telse if (pdomain->coord_type == DOMAIN_COORD_TYPE_SW_ANY)\n\t\t\tdst->shared_type = CPUFREQ_SHARED_TYPE_ANY;\n\n\t}\n\tmemcpy(&(dst->domain_info), pdomain, sizeof(struct acpi_psd_package));\n\treturn 0;\n}\nstatic int xen_copy_pct_data(struct acpi_pct_register *pct,\n\t\t\t     struct xen_pct_register *dst_pct)\n{\n\t \n\tdst_pct->descriptor = pct->descriptor;\n\tdst_pct->length = pct->length;\n\tdst_pct->space_id = pct->space_id;\n\tdst_pct->bit_width = pct->bit_width;\n\tdst_pct->bit_offset = pct->bit_offset;\n\tdst_pct->reserved = pct->reserved;\n\tdst_pct->address = pct->address;\n\treturn 0;\n}\nstatic int push_pxx_to_hypervisor(struct acpi_processor *_pr)\n{\n\tint ret = 0;\n\tstruct xen_platform_op op = {\n\t\t.cmd\t\t\t= XENPF_set_processor_pminfo,\n\t\t.interface_version\t= XENPF_INTERFACE_VERSION,\n\t\t.u.set_pminfo.id\t= _pr->acpi_id,\n\t\t.u.set_pminfo.type\t= XEN_PM_PX,\n\t};\n\tstruct xen_processor_performance *dst_perf;\n\tstruct xen_processor_px *dst_states = NULL;\n\n\tdst_perf = &op.u.set_pminfo.perf;\n\n\tdst_perf->platform_limit = _pr->performance_platform_limit;\n\tdst_perf->flags |= XEN_PX_PPC;\n\txen_copy_pct_data(&(_pr->performance->control_register),\n\t\t\t  &dst_perf->control_register);\n\txen_copy_pct_data(&(_pr->performance->status_register),\n\t\t\t  &dst_perf->status_register);\n\tdst_perf->flags |= XEN_PX_PCT;\n\tdst_states = xen_copy_pss_data(_pr, dst_perf);\n\tif (!IS_ERR_OR_NULL(dst_states)) {\n\t\tset_xen_guest_handle(dst_perf->states, dst_states);\n\t\tdst_perf->flags |= XEN_PX_PSS;\n\t}\n\tif (!xen_copy_psd_data(_pr, dst_perf))\n\t\tdst_perf->flags |= XEN_PX_PSD;\n\n\tif (dst_perf->flags != (XEN_PX_PSD | XEN_PX_PSS | XEN_PX_PCT | XEN_PX_PPC)) {\n\t\tpr_warn(\"ACPI CPU%u missing some P-state data (%x), skipping\\n\",\n\t\t\t_pr->acpi_id, dst_perf->flags);\n\t\tret = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tif (!no_hypercall)\n\t\tret = HYPERVISOR_platform_op(&op);\n\n\tif (!ret) {\n\t\tstruct acpi_processor_performance *perf;\n\t\tunsigned int i;\n\n\t\tperf = _pr->performance;\n\t\tpr_debug(\"ACPI CPU%u - P-states uploaded.\\n\", _pr->acpi_id);\n\t\tfor (i = 0; i < perf->state_count; i++) {\n\t\t\tpr_debug(\"     %cP%d: %d MHz, %d mW, %d uS\\n\",\n\t\t\t(i == perf->state ? '*' : ' '), i,\n\t\t\t(u32) perf->states[i].core_frequency,\n\t\t\t(u32) perf->states[i].power,\n\t\t\t(u32) perf->states[i].transition_latency);\n\t\t}\n\t} else if ((ret != -EINVAL) && (ret != -ENOSYS))\n\t\t \n\t\tpr_warn(\"(_PXX): Hypervisor error (%d) for ACPI CPU%u\\n\",\n\t\t\tret, _pr->acpi_id);\nerr_free:\n\tif (!IS_ERR_OR_NULL(dst_states))\n\t\tkfree(dst_states);\n\n\treturn ret;\n}\nstatic int upload_pm_data(struct acpi_processor *_pr)\n{\n\tint err = 0;\n\n\tmutex_lock(&acpi_ids_mutex);\n\tif (__test_and_set_bit(_pr->acpi_id, acpi_ids_done)) {\n\t\tmutex_unlock(&acpi_ids_mutex);\n\t\treturn -EBUSY;\n\t}\n\tif (_pr->flags.power)\n\t\terr = push_cxx_to_hypervisor(_pr);\n\n\tif (_pr->performance && _pr->performance->states)\n\t\terr |= push_pxx_to_hypervisor(_pr);\n\n\tmutex_unlock(&acpi_ids_mutex);\n\treturn err;\n}\nstatic unsigned int __init get_max_acpi_id(void)\n{\n\tstruct xenpf_pcpuinfo *info;\n\tstruct xen_platform_op op = {\n\t\t.cmd = XENPF_get_cpuinfo,\n\t\t.interface_version = XENPF_INTERFACE_VERSION,\n\t};\n\tint ret = 0;\n\tunsigned int i, last_cpu, max_acpi_id = 0;\n\n\tinfo = &op.u.pcpu_info;\n\tinfo->xen_cpuid = 0;\n\n\tret = HYPERVISOR_platform_op(&op);\n\tif (ret)\n\t\treturn NR_CPUS;\n\n\t \n\tlast_cpu = op.u.pcpu_info.max_present;\n\tfor (i = 0; i <= last_cpu; i++) {\n\t\tinfo->xen_cpuid = i;\n\t\tret = HYPERVISOR_platform_op(&op);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tmax_acpi_id = max(info->acpi_id, max_acpi_id);\n\t}\n\tmax_acpi_id *= 2;  \n\tpr_debug(\"Max ACPI ID: %u\\n\", max_acpi_id);\n\treturn max_acpi_id;\n}\n \nstatic acpi_status\nread_acpi_id(acpi_handle handle, u32 lvl, void *context, void **rv)\n{\n\tu32 acpi_id;\n\tacpi_status status;\n\tacpi_object_type acpi_type;\n\tunsigned long long tmp;\n\tunion acpi_object object = { 0 };\n\tstruct acpi_buffer buffer = { sizeof(union acpi_object), &object };\n\tacpi_io_address pblk = 0;\n\n\tstatus = acpi_get_type(handle, &acpi_type);\n\tif (ACPI_FAILURE(status))\n\t\treturn AE_OK;\n\n\tswitch (acpi_type) {\n\tcase ACPI_TYPE_PROCESSOR:\n\t\tstatus = acpi_evaluate_object(handle, NULL, NULL, &buffer);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn AE_OK;\n\t\tacpi_id = object.processor.proc_id;\n\t\tpblk = object.processor.pblk_address;\n\t\tbreak;\n\tcase ACPI_TYPE_DEVICE:\n\t\tstatus = acpi_evaluate_integer(handle, \"_UID\", NULL, &tmp);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn AE_OK;\n\t\tacpi_id = tmp;\n\t\tbreak;\n\tdefault:\n\t\treturn AE_OK;\n\t}\n\tif (invalid_phys_cpuid(acpi_get_phys_id(handle,\n\t\t\t\t\t\tacpi_type == ACPI_TYPE_DEVICE,\n\t\t\t\t\t\tacpi_id))) {\n\t\tpr_debug(\"CPU with ACPI ID %u is unavailable\\n\", acpi_id);\n\t\treturn AE_OK;\n\t}\n\t \n\tif (acpi_id >= nr_acpi_bits) {\n\t\tpr_debug(\"max acpi id %u, trying to set %u\\n\",\n\t\t\t nr_acpi_bits - 1, acpi_id);\n\t\treturn AE_OK;\n\t}\n\t \n\t__set_bit(acpi_id, acpi_id_present);\n\n\tpr_debug(\"ACPI CPU%u w/ PBLK:0x%lx\\n\", acpi_id, (unsigned long)pblk);\n\n\t \n\tif (!acpi_processor_get_psd(handle, &acpi_psd[acpi_id])) {\n\t\tpr_debug(\"ACPI CPU%u w/ PST:coord_type = %llu domain = %llu\\n\",\n\t\t\t acpi_id, acpi_psd[acpi_id].coord_type,\n\t\t\t acpi_psd[acpi_id].domain);\n\t}\n\n\tstatus = acpi_evaluate_object(handle, \"_CST\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (!pblk)\n\t\t\treturn AE_OK;\n\t}\n\t \n\t__set_bit(acpi_id, acpi_id_cst_present);\n\n\treturn AE_OK;\n}\nstatic int check_acpi_ids(struct acpi_processor *pr_backup)\n{\n\n\tif (!pr_backup)\n\t\treturn -ENODEV;\n\n\tif (acpi_id_present && acpi_id_cst_present)\n\t\t \n\t\tgoto upload;\n\n\t \n\tacpi_id_present = bitmap_zalloc(nr_acpi_bits, GFP_KERNEL);\n\tif (!acpi_id_present)\n\t\treturn -ENOMEM;\n\n\tacpi_id_cst_present = bitmap_zalloc(nr_acpi_bits, GFP_KERNEL);\n\tif (!acpi_id_cst_present) {\n\t\tbitmap_free(acpi_id_present);\n\t\treturn -ENOMEM;\n\t}\n\n\tacpi_psd = kcalloc(nr_acpi_bits, sizeof(struct acpi_psd_package),\n\t\t\t   GFP_KERNEL);\n\tif (!acpi_psd) {\n\t\tbitmap_free(acpi_id_present);\n\t\tbitmap_free(acpi_id_cst_present);\n\t\treturn -ENOMEM;\n\t}\n\n\tacpi_walk_namespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT,\n\t\t\t    ACPI_UINT32_MAX,\n\t\t\t    read_acpi_id, NULL, NULL, NULL);\n\tacpi_get_devices(ACPI_PROCESSOR_DEVICE_HID, read_acpi_id, NULL, NULL);\n\nupload:\n\tif (!bitmap_equal(acpi_id_present, acpi_ids_done, nr_acpi_bits)) {\n\t\tunsigned int i;\n\t\tfor_each_set_bit(i, acpi_id_present, nr_acpi_bits) {\n\t\t\tpr_backup->acpi_id = i;\n\t\t\t \n\t\t\tpr_backup->flags.power = test_bit(i, acpi_id_cst_present);\n\t\t\t \n\t\t\tif (acpi_psd[i].num_entries) {\n\t\t\t\tmemcpy(&pr_backup->performance->domain_info,\n\t\t\t\t       &acpi_psd[i],\n\t\t\t\t       sizeof(struct acpi_psd_package));\n\t\t\t}\n\t\t\t(void)upload_pm_data(pr_backup);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct acpi_processor_performance __percpu *acpi_perf_data;\n\nstatic void free_acpi_perf_data(void)\n{\n\tint i;\n\n\t \n\tfor_each_possible_cpu(i)\n\t\tfree_cpumask_var(per_cpu_ptr(acpi_perf_data, i)\n\t\t\t\t ->shared_cpu_map);\n\tfree_percpu(acpi_perf_data);\n}\n\nstatic int xen_upload_processor_pm_data(void)\n{\n\tstruct acpi_processor *pr_backup = NULL;\n\tint i;\n\tint rc = 0;\n\n\tpr_info(\"Uploading Xen processor PM info\\n\");\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct acpi_processor *_pr;\n\t\t_pr = per_cpu(processors, i  );\n\t\tif (!_pr)\n\t\t\tcontinue;\n\n\t\tif (!pr_backup)\n\t\t\tpr_backup = kmemdup(_pr, sizeof(*_pr), GFP_KERNEL);\n\t\t(void)upload_pm_data(_pr);\n\t}\n\n\trc = check_acpi_ids(pr_backup);\n\tkfree(pr_backup);\n\n\treturn rc;\n}\n\nstatic void xen_acpi_processor_resume_worker(struct work_struct *dummy)\n{\n\tint rc;\n\n\tbitmap_zero(acpi_ids_done, nr_acpi_bits);\n\n\trc = xen_upload_processor_pm_data();\n\tif (rc != 0)\n\t\tpr_info(\"ACPI data upload failed, error = %d\\n\", rc);\n}\n\nstatic void xen_acpi_processor_resume(void)\n{\n\tstatic DECLARE_WORK(wq, xen_acpi_processor_resume_worker);\n\n\t \n\tschedule_work(&wq);\n}\n\nstatic struct syscore_ops xap_syscore_ops = {\n\t.resume\t= xen_acpi_processor_resume,\n};\n\nstatic int __init xen_acpi_processor_init(void)\n{\n\tint i;\n\tint rc;\n\n\tif (!xen_initial_domain())\n\t\treturn -ENODEV;\n\n\tnr_acpi_bits = get_max_acpi_id() + 1;\n\tacpi_ids_done = bitmap_zalloc(nr_acpi_bits, GFP_KERNEL);\n\tif (!acpi_ids_done)\n\t\treturn -ENOMEM;\n\n\tacpi_perf_data = alloc_percpu(struct acpi_processor_performance);\n\tif (!acpi_perf_data) {\n\t\tpr_debug(\"Memory allocation error for acpi_perf_data\\n\");\n\t\tbitmap_free(acpi_ids_done);\n\t\treturn -ENOMEM;\n\t}\n\tfor_each_possible_cpu(i) {\n\t\tif (!zalloc_cpumask_var_node(\n\t\t\t&per_cpu_ptr(acpi_perf_data, i)->shared_cpu_map,\n\t\t\tGFP_KERNEL, cpu_to_node(i))) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t \n\t(void)acpi_processor_preregister_performance(acpi_perf_data);\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct acpi_processor *pr;\n\t\tstruct acpi_processor_performance *perf;\n\n\t\tpr = per_cpu(processors, i);\n\t\tperf = per_cpu_ptr(acpi_perf_data, i);\n\t\tif (!pr)\n\t\t\tcontinue;\n\n\t\tpr->performance = perf;\n\t\trc = acpi_processor_get_performance_info(pr);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\trc = xen_upload_processor_pm_data();\n\tif (rc)\n\t\tgoto err_unregister;\n\n\tregister_syscore_ops(&xap_syscore_ops);\n\n\treturn 0;\nerr_unregister:\n\tfor_each_possible_cpu(i)\n\t\tacpi_processor_unregister_performance(i);\n\nerr_out:\n\t \n\tfree_acpi_perf_data();\n\tbitmap_free(acpi_ids_done);\n\treturn rc;\n}\nstatic void __exit xen_acpi_processor_exit(void)\n{\n\tint i;\n\n\tunregister_syscore_ops(&xap_syscore_ops);\n\tbitmap_free(acpi_ids_done);\n\tbitmap_free(acpi_id_present);\n\tbitmap_free(acpi_id_cst_present);\n\tkfree(acpi_psd);\n\tfor_each_possible_cpu(i)\n\t\tacpi_processor_unregister_performance(i);\n\n\tfree_acpi_perf_data();\n}\n\nMODULE_AUTHOR(\"Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\");\nMODULE_DESCRIPTION(\"Xen ACPI Processor P-states (and Cx) driver which uploads PM data to Xen hypervisor\");\nMODULE_LICENSE(\"GPL\");\n\n \ndevice_initcall(xen_acpi_processor_init);\nmodule_exit(xen_acpi_processor_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}