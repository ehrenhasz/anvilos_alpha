{
  "module_name": "cpg.c",
  "hash_id": "60c30749f668b850d7af55c6cc2acc7aa53426d610a989fc94566dc8dcc1d963",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sh/clk/cpg.c",
  "human_readable_source": " \n#include <linux/clk.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/sh_clk.h>\n\n#define CPG_CKSTP_BIT\tBIT(8)\n\nstatic unsigned int sh_clk_read(struct clk *clk)\n{\n\tif (clk->flags & CLK_ENABLE_REG_8BIT)\n\t\treturn ioread8(clk->mapped_reg);\n\telse if (clk->flags & CLK_ENABLE_REG_16BIT)\n\t\treturn ioread16(clk->mapped_reg);\n\n\treturn ioread32(clk->mapped_reg);\n}\n\nstatic void sh_clk_write(int value, struct clk *clk)\n{\n\tif (clk->flags & CLK_ENABLE_REG_8BIT)\n\t\tiowrite8(value, clk->mapped_reg);\n\telse if (clk->flags & CLK_ENABLE_REG_16BIT)\n\t\tiowrite16(value, clk->mapped_reg);\n\telse\n\t\tiowrite32(value, clk->mapped_reg);\n}\n\nstatic int sh_clk_mstp_enable(struct clk *clk)\n{\n\tsh_clk_write(sh_clk_read(clk) & ~(1 << clk->enable_bit), clk);\n\tif (clk->status_reg) {\n\t\tunsigned int (*read)(const void __iomem *addr);\n\t\tint i;\n\t\tvoid __iomem *mapped_status = (phys_addr_t)clk->status_reg -\n\t\t\t(phys_addr_t)clk->enable_reg + clk->mapped_reg;\n\n\t\tif (clk->flags & CLK_ENABLE_REG_8BIT)\n\t\t\tread = ioread8;\n\t\telse if (clk->flags & CLK_ENABLE_REG_16BIT)\n\t\t\tread = ioread16;\n\t\telse\n\t\t\tread = ioread32;\n\n\t\tfor (i = 1000;\n\t\t     (read(mapped_status) & (1 << clk->enable_bit)) && i;\n\t\t     i--)\n\t\t\tcpu_relax();\n\t\tif (!i) {\n\t\t\tpr_err(\"cpg: failed to enable %p[%d]\\n\",\n\t\t\t       clk->enable_reg, clk->enable_bit);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sh_clk_mstp_disable(struct clk *clk)\n{\n\tsh_clk_write(sh_clk_read(clk) | (1 << clk->enable_bit), clk);\n}\n\nstatic struct sh_clk_ops sh_clk_mstp_clk_ops = {\n\t.enable\t\t= sh_clk_mstp_enable,\n\t.disable\t= sh_clk_mstp_disable,\n\t.recalc\t\t= followparent_recalc,\n};\n\nint __init sh_clk_mstp_register(struct clk *clks, int nr)\n{\n\tstruct clk *clkp;\n\tint ret = 0;\n\tint k;\n\n\tfor (k = 0; !ret && (k < nr); k++) {\n\t\tclkp = clks + k;\n\t\tclkp->ops = &sh_clk_mstp_clk_ops;\n\t\tret |= clk_register(clkp);\n\t}\n\n\treturn ret;\n}\n\n \nstatic inline struct clk_div_table *clk_to_div_table(struct clk *clk)\n{\n\treturn clk->priv;\n}\n\nstatic inline struct clk_div_mult_table *clk_to_div_mult_table(struct clk *clk)\n{\n\treturn clk_to_div_table(clk)->div_mult_table;\n}\n\n \nstatic long sh_clk_div_round_rate(struct clk *clk, unsigned long rate)\n{\n\treturn clk_rate_table_round(clk, clk->freq_table, rate);\n}\n\nstatic unsigned long sh_clk_div_recalc(struct clk *clk)\n{\n\tstruct clk_div_mult_table *table = clk_to_div_mult_table(clk);\n\tunsigned int idx;\n\n\tclk_rate_table_build(clk, clk->freq_table, table->nr_divisors,\n\t\t\t     table, clk->arch_flags ? &clk->arch_flags : NULL);\n\n\tidx = (sh_clk_read(clk) >> clk->enable_bit) & clk->div_mask;\n\n\treturn clk->freq_table[idx].frequency;\n}\n\nstatic int sh_clk_div_set_rate(struct clk *clk, unsigned long rate)\n{\n\tstruct clk_div_table *dt = clk_to_div_table(clk);\n\tunsigned long value;\n\tint idx;\n\n\tidx = clk_rate_table_find(clk, clk->freq_table, rate);\n\tif (idx < 0)\n\t\treturn idx;\n\n\tvalue = sh_clk_read(clk);\n\tvalue &= ~(clk->div_mask << clk->enable_bit);\n\tvalue |= (idx << clk->enable_bit);\n\tsh_clk_write(value, clk);\n\n\t \n\tif (dt->kick)\n\t\tdt->kick(clk);\n\n\treturn 0;\n}\n\nstatic int sh_clk_div_enable(struct clk *clk)\n{\n\tif (clk->div_mask == SH_CLK_DIV6_MSK) {\n\t\tint ret = sh_clk_div_set_rate(clk, clk->rate);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tsh_clk_write(sh_clk_read(clk) & ~CPG_CKSTP_BIT, clk);\n\treturn 0;\n}\n\nstatic void sh_clk_div_disable(struct clk *clk)\n{\n\tunsigned int val;\n\n\tval = sh_clk_read(clk);\n\tval |= CPG_CKSTP_BIT;\n\n\t \n\tif (clk->flags & CLK_MASK_DIV_ON_DISABLE)\n\t\tval |= clk->div_mask;\n\n\tsh_clk_write(val, clk);\n}\n\nstatic struct sh_clk_ops sh_clk_div_clk_ops = {\n\t.recalc\t\t= sh_clk_div_recalc,\n\t.set_rate\t= sh_clk_div_set_rate,\n\t.round_rate\t= sh_clk_div_round_rate,\n};\n\nstatic struct sh_clk_ops sh_clk_div_enable_clk_ops = {\n\t.recalc\t\t= sh_clk_div_recalc,\n\t.set_rate\t= sh_clk_div_set_rate,\n\t.round_rate\t= sh_clk_div_round_rate,\n\t.enable\t\t= sh_clk_div_enable,\n\t.disable\t= sh_clk_div_disable,\n};\n\nstatic int __init sh_clk_init_parent(struct clk *clk)\n{\n\tu32 val;\n\n\tif (clk->parent)\n\t\treturn 0;\n\n\tif (!clk->parent_table || !clk->parent_num)\n\t\treturn 0;\n\n\tif (!clk->src_width) {\n\t\tpr_err(\"sh_clk_init_parent: cannot select parent clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval  = (sh_clk_read(clk) >> clk->src_shift);\n\tval &= (1 << clk->src_width) - 1;\n\n\tif (val >= clk->parent_num) {\n\t\tpr_err(\"sh_clk_init_parent: parent table size failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tclk_reparent(clk, clk->parent_table[val]);\n\tif (!clk->parent) {\n\t\tpr_err(\"sh_clk_init_parent: unable to set parent\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init sh_clk_div_register_ops(struct clk *clks, int nr,\n\t\t\tstruct clk_div_table *table, struct sh_clk_ops *ops)\n{\n\tstruct clk *clkp;\n\tvoid *freq_table;\n\tint nr_divs = table->div_mult_table->nr_divisors;\n\tint freq_table_size = sizeof(struct cpufreq_frequency_table);\n\tint ret = 0;\n\tint k;\n\n\tfreq_table_size *= (nr_divs + 1);\n\tfreq_table = kcalloc(nr, freq_table_size, GFP_KERNEL);\n\tif (!freq_table) {\n\t\tpr_err(\"%s: unable to alloc memory\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (k = 0; !ret && (k < nr); k++) {\n\t\tclkp = clks + k;\n\n\t\tclkp->ops = ops;\n\t\tclkp->priv = table;\n\n\t\tclkp->freq_table = freq_table + (k * freq_table_size);\n\t\tclkp->freq_table[nr_divs].frequency = CPUFREQ_TABLE_END;\n\n\t\tret = clk_register(clkp);\n\t\tif (ret == 0)\n\t\t\tret = sh_clk_init_parent(clkp);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sh_clk_div6_divisors[64] = {\n\t1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n\t17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\n\t33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,\n\t49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64\n};\n\nstatic struct clk_div_mult_table div6_div_mult_table = {\n\t.divisors = sh_clk_div6_divisors,\n\t.nr_divisors = ARRAY_SIZE(sh_clk_div6_divisors),\n};\n\nstatic struct clk_div_table sh_clk_div6_table = {\n\t.div_mult_table\t= &div6_div_mult_table,\n};\n\nstatic int sh_clk_div6_set_parent(struct clk *clk, struct clk *parent)\n{\n\tstruct clk_div_mult_table *table = clk_to_div_mult_table(clk);\n\tu32 value;\n\tint ret, i;\n\n\tif (!clk->parent_table || !clk->parent_num)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < clk->parent_num; i++)\n\t\tif (clk->parent_table[i] == parent)\n\t\t\tbreak;\n\n\tif (i == clk->parent_num)\n\t\treturn -ENODEV;\n\n\tret = clk_reparent(clk, parent);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvalue = sh_clk_read(clk) &\n\t\t~(((1 << clk->src_width) - 1) << clk->src_shift);\n\n\tsh_clk_write(value | (i << clk->src_shift), clk);\n\n\t \n\tclk_rate_table_build(clk, clk->freq_table, table->nr_divisors,\n\t\t\t     table, NULL);\n\n\treturn 0;\n}\n\nstatic struct sh_clk_ops sh_clk_div6_reparent_clk_ops = {\n\t.recalc\t\t= sh_clk_div_recalc,\n\t.round_rate\t= sh_clk_div_round_rate,\n\t.set_rate\t= sh_clk_div_set_rate,\n\t.enable\t\t= sh_clk_div_enable,\n\t.disable\t= sh_clk_div_disable,\n\t.set_parent\t= sh_clk_div6_set_parent,\n};\n\nint __init sh_clk_div6_register(struct clk *clks, int nr)\n{\n\treturn sh_clk_div_register_ops(clks, nr, &sh_clk_div6_table,\n\t\t\t\t       &sh_clk_div_enable_clk_ops);\n}\n\nint __init sh_clk_div6_reparent_register(struct clk *clks, int nr)\n{\n\treturn sh_clk_div_register_ops(clks, nr, &sh_clk_div6_table,\n\t\t\t\t       &sh_clk_div6_reparent_clk_ops);\n}\n\n \nstatic int sh_clk_div4_set_parent(struct clk *clk, struct clk *parent)\n{\n\tstruct clk_div_mult_table *table = clk_to_div_mult_table(clk);\n\tu32 value;\n\tint ret;\n\n\t \n\n\tif (parent->flags & CLK_ENABLE_ON_INIT)\n\t\tvalue = sh_clk_read(clk) & ~(1 << 7);\n\telse\n\t\tvalue = sh_clk_read(clk) | (1 << 7);\n\n\tret = clk_reparent(clk, parent);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsh_clk_write(value, clk);\n\n\t \n\tclk_rate_table_build(clk, clk->freq_table, table->nr_divisors,\n\t\t\t     table, &clk->arch_flags);\n\n\treturn 0;\n}\n\nstatic struct sh_clk_ops sh_clk_div4_reparent_clk_ops = {\n\t.recalc\t\t= sh_clk_div_recalc,\n\t.set_rate\t= sh_clk_div_set_rate,\n\t.round_rate\t= sh_clk_div_round_rate,\n\t.enable\t\t= sh_clk_div_enable,\n\t.disable\t= sh_clk_div_disable,\n\t.set_parent\t= sh_clk_div4_set_parent,\n};\n\nint __init sh_clk_div4_register(struct clk *clks, int nr,\n\t\t\t\tstruct clk_div4_table *table)\n{\n\treturn sh_clk_div_register_ops(clks, nr, table, &sh_clk_div_clk_ops);\n}\n\nint __init sh_clk_div4_enable_register(struct clk *clks, int nr,\n\t\t\t\tstruct clk_div4_table *table)\n{\n\treturn sh_clk_div_register_ops(clks, nr, table,\n\t\t\t\t       &sh_clk_div_enable_clk_ops);\n}\n\nint __init sh_clk_div4_reparent_register(struct clk *clks, int nr,\n\t\t\t\tstruct clk_div4_table *table)\n{\n\treturn sh_clk_div_register_ops(clks, nr, table,\n\t\t\t\t       &sh_clk_div4_reparent_clk_ops);\n}\n\n \nstatic unsigned long fsidiv_recalc(struct clk *clk)\n{\n\tu32 value;\n\n\tvalue = __raw_readl(clk->mapping->base);\n\n\tvalue >>= 16;\n\tif (value < 2)\n\t\treturn clk->parent->rate;\n\n\treturn clk->parent->rate / value;\n}\n\nstatic long fsidiv_round_rate(struct clk *clk, unsigned long rate)\n{\n\treturn clk_rate_div_range_round(clk, 1, 0xffff, rate);\n}\n\nstatic void fsidiv_disable(struct clk *clk)\n{\n\t__raw_writel(0, clk->mapping->base);\n}\n\nstatic int fsidiv_enable(struct clk *clk)\n{\n\tu32 value;\n\n\tvalue  = __raw_readl(clk->mapping->base) >> 16;\n\tif (value < 2)\n\t\treturn 0;\n\n\t__raw_writel((value << 16) | 0x3, clk->mapping->base);\n\n\treturn 0;\n}\n\nstatic int fsidiv_set_rate(struct clk *clk, unsigned long rate)\n{\n\tint idx;\n\n\tidx = (clk->parent->rate / rate) & 0xffff;\n\tif (idx < 2)\n\t\t__raw_writel(0, clk->mapping->base);\n\telse\n\t\t__raw_writel(idx << 16, clk->mapping->base);\n\n\treturn 0;\n}\n\nstatic struct sh_clk_ops fsidiv_clk_ops = {\n\t.recalc\t\t= fsidiv_recalc,\n\t.round_rate\t= fsidiv_round_rate,\n\t.set_rate\t= fsidiv_set_rate,\n\t.enable\t\t= fsidiv_enable,\n\t.disable\t= fsidiv_disable,\n};\n\nint __init sh_clk_fsidiv_register(struct clk *clks, int nr)\n{\n\tstruct clk_mapping *map;\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\n\t\tmap = kzalloc(sizeof(struct clk_mapping), GFP_KERNEL);\n\t\tif (!map) {\n\t\t\tpr_err(\"%s: unable to alloc memory\\n\", __func__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tmap->phys\t\t= (phys_addr_t)clks[i].enable_reg;\n\t\tmap->len\t\t= 8;\n\n\t\tclks[i].enable_reg\t= 0;  \n\t\tclks[i].ops\t\t= &fsidiv_clk_ops;\n\t\tclks[i].mapping\t\t= map;\n\n\t\tclk_register(&clks[i]);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}