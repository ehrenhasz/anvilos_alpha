{
  "module_name": "maple.c",
  "hash_id": "a7caca48a427ebde94644917cb909e7a785cf8bdaa079bb8cf8c6b8d8bfc7f5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sh/maple/maple.c",
  "human_readable_source": " \n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/maple.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <asm/cacheflush.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <mach/dma.h>\n#include <mach/sysasic.h>\n\nMODULE_AUTHOR(\"Adrian McMenamin <adrian@mcmen.demon.co.uk>\");\nMODULE_DESCRIPTION(\"Maple bus driver for Dreamcast\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic void maple_dma_handler(struct work_struct *work);\nstatic void maple_vblank_handler(struct work_struct *work);\n\nstatic DECLARE_WORK(maple_dma_process, maple_dma_handler);\nstatic DECLARE_WORK(maple_vblank_process, maple_vblank_handler);\n\nstatic LIST_HEAD(maple_waitq);\nstatic LIST_HEAD(maple_sentq);\n\n \nstatic DEFINE_MUTEX(maple_wlist_lock);\n\nstatic struct maple_driver maple_unsupported_device;\nstatic struct device maple_bus;\nstatic int subdevice_map[MAPLE_PORTS];\nstatic unsigned long *maple_sendbuf, *maple_sendptr, *maple_lastptr;\nstatic unsigned long maple_pnp_time;\nstatic int started, scanning, fullscan;\nstatic struct kmem_cache *maple_queue_cache;\n\nstruct maple_device_specify {\n\tint port;\n\tint unit;\n};\n\nstatic bool checked[MAPLE_PORTS];\nstatic bool empty[MAPLE_PORTS];\nstatic struct maple_device *baseunits[MAPLE_PORTS];\n\n \nint maple_driver_register(struct maple_driver *drv)\n{\n\tif (!drv)\n\t\treturn -EINVAL;\n\n\tdrv->drv.bus = &maple_bus_type;\n\n\treturn driver_register(&drv->drv);\n}\nEXPORT_SYMBOL_GPL(maple_driver_register);\n\n \nvoid maple_driver_unregister(struct maple_driver *drv)\n{\n\tdriver_unregister(&drv->drv);\n}\nEXPORT_SYMBOL_GPL(maple_driver_unregister);\n\n \nstatic void maple_dma_reset(void)\n{\n\t__raw_writel(MAPLE_MAGIC, MAPLE_RESET);\n\t \n\t__raw_writel(1, MAPLE_TRIGTYPE);\n\t \n\t__raw_writel(MAPLE_2MBPS | MAPLE_TIMEOUT(0xFFFF), MAPLE_SPEED);\n\t__raw_writel(virt_to_phys(maple_sendbuf), MAPLE_DMAADDR);\n\t__raw_writel(1, MAPLE_ENABLE);\n}\n\n \nvoid maple_getcond_callback(struct maple_device *dev,\n\t\t\tvoid (*callback) (struct mapleq *mq),\n\t\t\tunsigned long interval, unsigned long function)\n{\n\tdev->callback = callback;\n\tdev->interval = interval;\n\tdev->function = cpu_to_be32(function);\n\tdev->when = jiffies;\n}\nEXPORT_SYMBOL_GPL(maple_getcond_callback);\n\nstatic int maple_dma_done(void)\n{\n\treturn (__raw_readl(MAPLE_STATE) & 1) == 0;\n}\n\nstatic void maple_release_device(struct device *dev)\n{\n\tstruct maple_device *mdev;\n\tstruct mapleq *mq;\n\n\tmdev = to_maple_dev(dev);\n\tmq = mdev->mq;\n\tkmem_cache_free(maple_queue_cache, mq->recvbuf);\n\tkfree(mq);\n\tkfree(mdev);\n}\n\n \nint maple_add_packet(struct maple_device *mdev, u32 function, u32 command,\n\tsize_t length, void *data)\n{\n\tint ret = 0;\n\tvoid *sendbuf = NULL;\n\n\tif (length) {\n\t\tsendbuf = kcalloc(length, 4, GFP_KERNEL);\n\t\tif (!sendbuf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t((__be32 *)sendbuf)[0] = cpu_to_be32(function);\n\t}\n\n\tmdev->mq->command = command;\n\tmdev->mq->length = length;\n\tif (length > 1)\n\t\tmemcpy(sendbuf + 4, data, (length - 1) * 4);\n\tmdev->mq->sendbuf = sendbuf;\n\n\tmutex_lock(&maple_wlist_lock);\n\tlist_add_tail(&mdev->mq->list, &maple_waitq);\n\tmutex_unlock(&maple_wlist_lock);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(maple_add_packet);\n\nstatic struct mapleq *maple_allocq(struct maple_device *mdev)\n{\n\tstruct mapleq *mq;\n\n\tmq = kzalloc(sizeof(*mq), GFP_KERNEL);\n\tif (!mq)\n\t\tgoto failed_nomem;\n\n\tINIT_LIST_HEAD(&mq->list);\n\tmq->dev = mdev;\n\tmq->recvbuf = kmem_cache_zalloc(maple_queue_cache, GFP_KERNEL);\n\tif (!mq->recvbuf)\n\t\tgoto failed_p2;\n\tmq->recvbuf->buf = &((mq->recvbuf->bufx)[0]);\n\n\treturn mq;\n\nfailed_p2:\n\tkfree(mq);\nfailed_nomem:\n\tdev_err(&mdev->dev, \"could not allocate memory for device (%d, %d)\\n\",\n\t\tmdev->port, mdev->unit);\n\treturn NULL;\n}\n\nstatic struct maple_device *maple_alloc_dev(int port, int unit)\n{\n\tstruct maple_device *mdev;\n\n\t \n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn NULL;\n\n\tmdev->port = port;\n\tmdev->unit = unit;\n\n\tmdev->mq = maple_allocq(mdev);\n\n\tif (!mdev->mq) {\n\t\tkfree(mdev);\n\t\treturn NULL;\n\t}\n\tmdev->dev.bus = &maple_bus_type;\n\tmdev->dev.parent = &maple_bus;\n\tinit_waitqueue_head(&mdev->maple_wait);\n\treturn mdev;\n}\n\nstatic void maple_free_dev(struct maple_device *mdev)\n{\n\tkmem_cache_free(maple_queue_cache, mdev->mq->recvbuf);\n\tkfree(mdev->mq);\n\tkfree(mdev);\n}\n\n \nstatic void maple_build_block(struct mapleq *mq)\n{\n\tint port, unit, from, to, len;\n\tunsigned long *lsendbuf = mq->sendbuf;\n\n\tport = mq->dev->port & 3;\n\tunit = mq->dev->unit;\n\tlen = mq->length;\n\tfrom = port << 6;\n\tto = (port << 6) | (unit > 0 ? (1 << (unit - 1)) & 0x1f : 0x20);\n\n\t*maple_lastptr &= 0x7fffffff;\n\tmaple_lastptr = maple_sendptr;\n\n\t*maple_sendptr++ = (port << 16) | len | 0x80000000;\n\t*maple_sendptr++ = virt_to_phys(mq->recvbuf->buf);\n\t*maple_sendptr++ =\n\t    mq->command | (to << 8) | (from << 16) | (len << 24);\n\twhile (len-- > 0)\n\t\t*maple_sendptr++ = *lsendbuf++;\n}\n\n \nstatic void maple_send(void)\n{\n\tint i, maple_packets = 0;\n\tstruct mapleq *mq, *nmq;\n\n\tif (!maple_dma_done())\n\t\treturn;\n\n\t \n\t__raw_writel(0, MAPLE_ENABLE);\n\n\tif (!list_empty(&maple_sentq))\n\t\tgoto finish;\n\n\tmutex_lock(&maple_wlist_lock);\n\tif (list_empty(&maple_waitq)) {\n\t\tmutex_unlock(&maple_wlist_lock);\n\t\tgoto finish;\n\t}\n\n\tmaple_lastptr = maple_sendbuf;\n\tmaple_sendptr = maple_sendbuf;\n\n\tlist_for_each_entry_safe(mq, nmq, &maple_waitq, list) {\n\t\tmaple_build_block(mq);\n\t\tlist_del_init(&mq->list);\n\t\tlist_add_tail(&mq->list, &maple_sentq);\n\t\tif (maple_packets++ > MAPLE_MAXPACKETS)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&maple_wlist_lock);\n\tif (maple_packets > 0) {\n\t\tfor (i = 0; i < (1 << MAPLE_DMA_PAGES); i++)\n\t\t\t__flush_purge_region(maple_sendbuf + i * PAGE_SIZE,\n\t\t\t\t\tPAGE_SIZE);\n\t}\n\nfinish:\n\tmaple_dma_reset();\n}\n\n \nstatic int maple_check_matching_driver(struct device_driver *driver,\n\t\t\t\t\tvoid *devptr)\n{\n\tstruct maple_driver *maple_drv;\n\tstruct maple_device *mdev;\n\n\tmdev = devptr;\n\tmaple_drv = to_maple_driver(driver);\n\tif (mdev->devinfo.function & cpu_to_be32(maple_drv->function))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void maple_detach_driver(struct maple_device *mdev)\n{\n\tdevice_unregister(&mdev->dev);\n}\n\n \nstatic void maple_attach_driver(struct maple_device *mdev)\n{\n\tchar *p, *recvbuf;\n\tunsigned long function;\n\tint matched, error;\n\n\trecvbuf = mdev->mq->recvbuf->buf;\n\t \n\tmemcpy(&mdev->devinfo.function, recvbuf + 4, 4);\n\tmemcpy(&mdev->devinfo.function_data[0], recvbuf + 8, 12);\n\tmemcpy(&mdev->devinfo.area_code, recvbuf + 20, 1);\n\tmemcpy(&mdev->devinfo.connector_direction, recvbuf + 21, 1);\n\tmemcpy(&mdev->devinfo.product_name[0], recvbuf + 22, 30);\n\tmemcpy(&mdev->devinfo.standby_power, recvbuf + 112, 2);\n\tmemcpy(&mdev->devinfo.max_power, recvbuf + 114, 2);\n\tmemcpy(mdev->product_name, mdev->devinfo.product_name, 30);\n\tmdev->product_name[30] = '\\0';\n\tmemcpy(mdev->product_licence, mdev->devinfo.product_licence, 60);\n\tmdev->product_licence[60] = '\\0';\n\n\tfor (p = mdev->product_name + 29; mdev->product_name <= p; p--)\n\t\tif (*p == ' ')\n\t\t\t*p = '\\0';\n\t\telse\n\t\t\tbreak;\n\tfor (p = mdev->product_licence + 59; mdev->product_licence <= p; p--)\n\t\tif (*p == ' ')\n\t\t\t*p = '\\0';\n\t\telse\n\t\t\tbreak;\n\n\tfunction = be32_to_cpu(mdev->devinfo.function);\n\n\tdev_info(&mdev->dev, \"detected %s: function 0x%lX: at (%d, %d)\\n\",\n\t\tmdev->product_name, function, mdev->port, mdev->unit);\n\n\tif (function > 0x200) {\n\t\t \n\t\tfunction = 0;\n\t\tmdev->driver = &maple_unsupported_device;\n\t\tdev_set_name(&mdev->dev, \"%d:0.port\", mdev->port);\n\t} else {\n\t\tmatched =\n\t\t\tbus_for_each_drv(&maple_bus_type, NULL, mdev,\n\t\t\t\tmaple_check_matching_driver);\n\n\t\tif (matched == 0) {\n\t\t\t \n\t\t\tdev_info(&mdev->dev, \"no driver found\\n\");\n\t\t\tmdev->driver = &maple_unsupported_device;\n\t\t}\n\t\tdev_set_name(&mdev->dev, \"%d:0%d.%lX\", mdev->port,\n\t\t\t     mdev->unit, function);\n\t}\n\n\tmdev->function = function;\n\tmdev->dev.release = &maple_release_device;\n\n\tatomic_set(&mdev->busy, 0);\n\terror = device_register(&mdev->dev);\n\tif (error) {\n\t\tdev_warn(&mdev->dev, \"could not register device at\"\n\t\t\t\" (%d, %d), with error 0x%X\\n\", mdev->unit,\n\t\t\tmdev->port, error);\n\t\tmaple_free_dev(mdev);\n\t\tmdev = NULL;\n\t\treturn;\n\t}\n}\n\n \nstatic int check_maple_device(struct device *device, void *portptr)\n{\n\tstruct maple_device_specify *ds;\n\tstruct maple_device *mdev;\n\n\tds = portptr;\n\tmdev = to_maple_dev(device);\n\tif (mdev->port == ds->port && mdev->unit == ds->unit)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int setup_maple_commands(struct device *device, void *ignored)\n{\n\tint add;\n\tstruct maple_device *mdev = to_maple_dev(device);\n\tif (mdev->interval > 0 && atomic_read(&mdev->busy) == 0 &&\n\t\ttime_after(jiffies, mdev->when)) {\n\t\t \n\t\tadd = maple_add_packet(mdev,\n\t\t\tbe32_to_cpu(mdev->devinfo.function),\n\t\t\tMAPLE_COMMAND_GETCOND, 1, NULL);\n\t\tif (!add)\n\t\t\tmdev->when = jiffies + mdev->interval;\n\t} else {\n\t\tif (time_after(jiffies, maple_pnp_time))\n\t\t\t \n\t\t\tif (atomic_read(&mdev->busy) == 0) {\n\t\t\t\tatomic_set(&mdev->busy, 1);\n\t\t\t\tmaple_add_packet(mdev, 0,\n\t\t\t\t\tMAPLE_COMMAND_DEVINFO, 0, NULL);\n\t\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void maple_vblank_handler(struct work_struct *work)\n{\n\tint x, locking;\n\tstruct maple_device *mdev;\n\n\tif (!maple_dma_done())\n\t\treturn;\n\n\t__raw_writel(0, MAPLE_ENABLE);\n\n\tif (!list_empty(&maple_sentq))\n\t\tgoto finish;\n\n\t \n\tbus_for_each_dev(&maple_bus_type, NULL, NULL,\n\t\tsetup_maple_commands);\n\n\tif (time_after(jiffies, maple_pnp_time)) {\n\t\t \n\t\tfor (x = 0; x < MAPLE_PORTS; x++) {\n\t\t\tif (checked[x] && empty[x]) {\n\t\t\t\tmdev = baseunits[x];\n\t\t\t\tif (!mdev)\n\t\t\t\t\tbreak;\n\t\t\t\tatomic_set(&mdev->busy, 1);\n\t\t\t\tlocking = maple_add_packet(mdev, 0,\n\t\t\t\t\tMAPLE_COMMAND_DEVINFO, 0, NULL);\n\t\t\t\tif (!locking)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\tmaple_pnp_time = jiffies + MAPLE_PNP_INTERVAL;\n\t}\n\nfinish:\n\tmaple_send();\n}\n\n \nstatic void maple_map_subunits(struct maple_device *mdev, int submask)\n{\n\tint retval, k, devcheck;\n\tstruct maple_device *mdev_add;\n\tstruct maple_device_specify ds;\n\n\tds.port = mdev->port;\n\tfor (k = 0; k < 5; k++) {\n\t\tds.unit = k + 1;\n\t\tretval =\n\t\t    bus_for_each_dev(&maple_bus_type, NULL, &ds,\n\t\t\t\t     check_maple_device);\n\t\tif (retval) {\n\t\t\tsubmask = submask >> 1;\n\t\t\tcontinue;\n\t\t}\n\t\tdevcheck = submask & 0x01;\n\t\tif (devcheck) {\n\t\t\tmdev_add = maple_alloc_dev(mdev->port, k + 1);\n\t\t\tif (!mdev_add)\n\t\t\t\treturn;\n\t\t\tatomic_set(&mdev_add->busy, 1);\n\t\t\tmaple_add_packet(mdev_add, 0, MAPLE_COMMAND_DEVINFO,\n\t\t\t\t0, NULL);\n\t\t\t \n\t\t\tscanning = 1;\n\t\t}\n\t\tsubmask = submask >> 1;\n\t}\n}\n\n \nstatic void maple_clean_submap(struct maple_device *mdev)\n{\n\tint killbit;\n\n\tkillbit = (mdev->unit > 0 ? (1 << (mdev->unit - 1)) & 0x1f : 0x20);\n\tkillbit = ~killbit;\n\tkillbit &= 0xFF;\n\tsubdevice_map[mdev->port] = subdevice_map[mdev->port] & killbit;\n}\n\n \nstatic void maple_response_none(struct maple_device *mdev)\n{\n\tmaple_clean_submap(mdev);\n\n\tif (likely(mdev->unit != 0)) {\n\t\t \n\t\tif (mdev->can_unload) {\n\t\t\tif (!mdev->can_unload(mdev)) {\n\t\t\t\tatomic_set(&mdev->busy, 2);\n\t\t\t\twake_up(&mdev->maple_wait);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tdev_info(&mdev->dev, \"detaching device at (%d, %d)\\n\",\n\t\t\tmdev->port, mdev->unit);\n\t\tmaple_detach_driver(mdev);\n\t\treturn;\n\t} else {\n\t\tif (!started || !fullscan) {\n\t\t\tif (checked[mdev->port] == false) {\n\t\t\t\tchecked[mdev->port] = true;\n\t\t\t\tempty[mdev->port] = true;\n\t\t\t\tdev_info(&mdev->dev, \"no devices\"\n\t\t\t\t\t\" to port %d\\n\", mdev->port);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tatomic_set(&mdev->busy, 0);\n}\n\n \nstatic void maple_response_devinfo(struct maple_device *mdev,\n\t\t\t\t   char *recvbuf)\n{\n\tchar submask;\n\tif (!started || (scanning == 2) || !fullscan) {\n\t\tif ((mdev->unit == 0) && (checked[mdev->port] == false)) {\n\t\t\tchecked[mdev->port] = true;\n\t\t\tmaple_attach_driver(mdev);\n\t\t} else {\n\t\t\tif (mdev->unit != 0)\n\t\t\t\tmaple_attach_driver(mdev);\n\t\t\tif (mdev->unit == 0) {\n\t\t\t\tempty[mdev->port] = false;\n\t\t\t\tmaple_attach_driver(mdev);\n\t\t\t}\n\t\t}\n\t}\n\tif (mdev->unit == 0) {\n\t\tsubmask = recvbuf[2] & 0x1F;\n\t\tif (submask ^ subdevice_map[mdev->port]) {\n\t\t\tmaple_map_subunits(mdev, submask);\n\t\t\tsubdevice_map[mdev->port] = submask;\n\t\t}\n\t}\n}\n\nstatic void maple_response_fileerr(struct maple_device *mdev, void *recvbuf)\n{\n\tif (mdev->fileerr_handler) {\n\t\tmdev->fileerr_handler(mdev, recvbuf);\n\t\treturn;\n\t} else\n\t\tdev_warn(&mdev->dev, \"device at (%d, %d) reports\"\n\t\t\t\"file error 0x%X\\n\", mdev->port, mdev->unit,\n\t\t\t((int *)recvbuf)[1]);\n}\n\nstatic void maple_port_rescan(void)\n{\n\tint i;\n\tstruct maple_device *mdev;\n\n\tfullscan = 1;\n\tfor (i = 0; i < MAPLE_PORTS; i++) {\n\t\tif (checked[i] == false) {\n\t\t\tfullscan = 0;\n\t\t\tmdev = baseunits[i];\n\t\t\tmaple_add_packet(mdev, 0, MAPLE_COMMAND_DEVINFO,\n\t\t\t\t0, NULL);\n\t\t}\n\t}\n}\n\n \nstatic void maple_dma_handler(struct work_struct *work)\n{\n\tstruct mapleq *mq, *nmq;\n\tstruct maple_device *mdev;\n\tchar *recvbuf;\n\tenum maple_code code;\n\n\tif (!maple_dma_done())\n\t\treturn;\n\t__raw_writel(0, MAPLE_ENABLE);\n\tif (!list_empty(&maple_sentq)) {\n\t\tlist_for_each_entry_safe(mq, nmq, &maple_sentq, list) {\n\t\t\tmdev = mq->dev;\n\t\t\trecvbuf = mq->recvbuf->buf;\n\t\t\t__flush_invalidate_region(sh_cacheop_vaddr(recvbuf),\n\t\t\t\t\t0x400);\n\t\t\tcode = recvbuf[0];\n\t\t\tkfree(mq->sendbuf);\n\t\t\tlist_del_init(&mq->list);\n\t\t\tswitch (code) {\n\t\t\tcase MAPLE_RESPONSE_NONE:\n\t\t\t\tmaple_response_none(mdev);\n\t\t\t\tbreak;\n\n\t\t\tcase MAPLE_RESPONSE_DEVINFO:\n\t\t\t\tmaple_response_devinfo(mdev, recvbuf);\n\t\t\t\tatomic_set(&mdev->busy, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase MAPLE_RESPONSE_DATATRF:\n\t\t\t\tif (mdev->callback)\n\t\t\t\t\tmdev->callback(mq);\n\t\t\t\tatomic_set(&mdev->busy, 0);\n\t\t\t\twake_up(&mdev->maple_wait);\n\t\t\t\tbreak;\n\n\t\t\tcase MAPLE_RESPONSE_FILEERR:\n\t\t\t\tmaple_response_fileerr(mdev, recvbuf);\n\t\t\t\tatomic_set(&mdev->busy, 0);\n\t\t\t\twake_up(&mdev->maple_wait);\n\t\t\t\tbreak;\n\n\t\t\tcase MAPLE_RESPONSE_AGAIN:\n\t\t\tcase MAPLE_RESPONSE_BADCMD:\n\t\t\tcase MAPLE_RESPONSE_BADFUNC:\n\t\t\t\tdev_warn(&mdev->dev, \"non-fatal error\"\n\t\t\t\t\t\" 0x%X at (%d, %d)\\n\", code,\n\t\t\t\t\tmdev->port, mdev->unit);\n\t\t\t\tatomic_set(&mdev->busy, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase MAPLE_RESPONSE_ALLINFO:\n\t\t\t\tdev_notice(&mdev->dev, \"extended\"\n\t\t\t\t\" device information request for (%d, %d)\"\n\t\t\t\t\" but call is not supported\\n\", mdev->port,\n\t\t\t\tmdev->unit);\n\t\t\t\tatomic_set(&mdev->busy, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase MAPLE_RESPONSE_OK:\n\t\t\t\tatomic_set(&mdev->busy, 0);\n\t\t\t\twake_up(&mdev->maple_wait);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (scanning == 1) {\n\t\t\tmaple_send();\n\t\t\tscanning = 2;\n\t\t} else\n\t\t\tscanning = 0;\n\t\t \n\t\tif (!fullscan)\n\t\t\tmaple_port_rescan();\n\t\t \n\t\tstarted = 1;\n\t}\n\tmaple_send();\n}\n\nstatic irqreturn_t maple_dma_interrupt(int irq, void *dev_id)\n{\n\t \n\tschedule_work(&maple_dma_process);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t maple_vblank_interrupt(int irq, void *dev_id)\n{\n\tschedule_work(&maple_vblank_process);\n\treturn IRQ_HANDLED;\n}\n\nstatic int maple_set_dma_interrupt_handler(void)\n{\n\treturn request_irq(HW_EVENT_MAPLE_DMA, maple_dma_interrupt,\n\t\tIRQF_SHARED, \"maple bus DMA\", &maple_unsupported_device);\n}\n\nstatic int maple_set_vblank_interrupt_handler(void)\n{\n\treturn request_irq(HW_EVENT_VSYNC, maple_vblank_interrupt,\n\t\tIRQF_SHARED, \"maple bus VBLANK\", &maple_unsupported_device);\n}\n\nstatic int maple_get_dma_buffer(void)\n{\n\tmaple_sendbuf =\n\t    (void *) __get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t      MAPLE_DMA_PAGES);\n\tif (!maple_sendbuf)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int maple_match_bus_driver(struct device *devptr,\n\t\t\t\t  struct device_driver *drvptr)\n{\n\tstruct maple_driver *maple_drv = to_maple_driver(drvptr);\n\tstruct maple_device *maple_dev = to_maple_dev(devptr);\n\n\t \n\tif (maple_dev->devinfo.function == 0xFFFFFFFF)\n\t\treturn 0;\n\telse if (maple_dev->devinfo.function &\n\t\t cpu_to_be32(maple_drv->function))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void maple_bus_release(struct device *dev)\n{\n}\n\nstatic struct maple_driver maple_unsupported_device = {\n\t.drv = {\n\t\t.name = \"maple_unsupported_device\",\n\t\t.bus = &maple_bus_type,\n\t},\n};\n \nstruct bus_type maple_bus_type = {\n\t.name = \"maple\",\n\t.match = maple_match_bus_driver,\n};\nEXPORT_SYMBOL_GPL(maple_bus_type);\n\nstatic struct device maple_bus = {\n\t.init_name = \"maple\",\n\t.release = maple_bus_release,\n};\n\nstatic int __init maple_bus_init(void)\n{\n\tint retval, i;\n\tstruct maple_device *mdev[MAPLE_PORTS];\n\n\t__raw_writel(0, MAPLE_ENABLE);\n\n\tretval = device_register(&maple_bus);\n\tif (retval)\n\t\tgoto cleanup;\n\n\tretval = bus_register(&maple_bus_type);\n\tif (retval)\n\t\tgoto cleanup_device;\n\n\tretval = driver_register(&maple_unsupported_device.drv);\n\tif (retval)\n\t\tgoto cleanup_bus;\n\n\t \n\tretval = maple_get_dma_buffer();\n\tif (retval) {\n\t\tdev_err(&maple_bus, \"failed to allocate DMA buffers\\n\");\n\t\tgoto cleanup_basic;\n\t}\n\n\t \n\tretval = maple_set_dma_interrupt_handler();\n\tif (retval) {\n\t\tdev_err(&maple_bus, \"bus failed to grab maple \"\n\t\t\t\"DMA IRQ\\n\");\n\t\tgoto cleanup_dma;\n\t}\n\n\t \n\tretval = maple_set_vblank_interrupt_handler();\n\tif (retval) {\n\t\tdev_err(&maple_bus, \"bus failed to grab VBLANK IRQ\\n\");\n\t\tgoto cleanup_irq;\n\t}\n\n\tmaple_queue_cache = KMEM_CACHE(maple_buffer, SLAB_HWCACHE_ALIGN);\n\n\tif (!maple_queue_cache) {\n\t\tretval = -ENOMEM;\n\t\tgoto cleanup_bothirqs;\n\t}\n\n\tINIT_LIST_HEAD(&maple_waitq);\n\tINIT_LIST_HEAD(&maple_sentq);\n\n\t \n\tfor (i = 0; i < MAPLE_PORTS; i++) {\n\t\tchecked[i] = false;\n\t\tempty[i] = false;\n\t\tmdev[i] = maple_alloc_dev(i, 0);\n\t\tif (!mdev[i]) {\n\t\t\twhile (i-- > 0)\n\t\t\t\tmaple_free_dev(mdev[i]);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto cleanup_cache;\n\t\t}\n\t\tbaseunits[i] = mdev[i];\n\t\tatomic_set(&mdev[i]->busy, 1);\n\t\tmaple_add_packet(mdev[i], 0, MAPLE_COMMAND_DEVINFO, 0, NULL);\n\t\tsubdevice_map[i] = 0;\n\t}\n\n\tmaple_pnp_time = jiffies + HZ;\n\t \n\tmaple_send();\n\tdev_info(&maple_bus, \"bus core now registered\\n\");\n\n\treturn 0;\n\ncleanup_cache:\n\tkmem_cache_destroy(maple_queue_cache);\n\ncleanup_bothirqs:\n\tfree_irq(HW_EVENT_VSYNC, 0);\n\ncleanup_irq:\n\tfree_irq(HW_EVENT_MAPLE_DMA, 0);\n\ncleanup_dma:\n\tfree_pages((unsigned long) maple_sendbuf, MAPLE_DMA_PAGES);\n\ncleanup_basic:\n\tdriver_unregister(&maple_unsupported_device.drv);\n\ncleanup_bus:\n\tbus_unregister(&maple_bus_type);\n\ncleanup_device:\n\tdevice_unregister(&maple_bus);\n\ncleanup:\n\tprintk(KERN_ERR \"Maple bus registration failed\\n\");\n\treturn retval;\n}\n \nfs_initcall(maple_bus_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}