{
  "module_name": "handle.c",
  "hash_id": "d16595836974165ae5fddc85a878b59ab3ee0bb5e969d24dc9e6818941192528",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sh/intc/handle.c",
  "human_readable_source": " \n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/spinlock.h>\n#include \"internals.h\"\n\nstatic unsigned long ack_handle[INTC_NR_IRQS];\n\nstatic intc_enum __init intc_grp_id(struct intc_desc *desc,\n\t\t\t\t    intc_enum enum_id)\n{\n\tstruct intc_group *g = desc->hw.groups;\n\tunsigned int i, j;\n\n\tfor (i = 0; g && enum_id && i < desc->hw.nr_groups; i++) {\n\t\tg = desc->hw.groups + i;\n\n\t\tfor (j = 0; g->enum_ids[j]; j++) {\n\t\t\tif (g->enum_ids[j] != enum_id)\n\t\t\t\tcontinue;\n\n\t\t\treturn g->enum_id;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int __init _intc_mask_data(struct intc_desc *desc,\n\t\t\t\t\t   struct intc_desc_int *d,\n\t\t\t\t\t   intc_enum enum_id,\n\t\t\t\t\t   unsigned int *reg_idx,\n\t\t\t\t\t   unsigned int *fld_idx)\n{\n\tstruct intc_mask_reg *mr = desc->hw.mask_regs;\n\tunsigned int fn, mode;\n\tunsigned long reg_e, reg_d;\n\n\twhile (mr && enum_id && *reg_idx < desc->hw.nr_mask_regs) {\n\t\tmr = desc->hw.mask_regs + *reg_idx;\n\n\t\tfor (; *fld_idx < ARRAY_SIZE(mr->enum_ids); (*fld_idx)++) {\n\t\t\tif (mr->enum_ids[*fld_idx] != enum_id)\n\t\t\t\tcontinue;\n\n\t\t\tif (mr->set_reg && mr->clr_reg) {\n\t\t\t\tfn = REG_FN_WRITE_BASE;\n\t\t\t\tmode = MODE_DUAL_REG;\n\t\t\t\treg_e = mr->clr_reg;\n\t\t\t\treg_d = mr->set_reg;\n\t\t\t} else {\n\t\t\t\tfn = REG_FN_MODIFY_BASE;\n\t\t\t\tif (mr->set_reg) {\n\t\t\t\t\tmode = MODE_ENABLE_REG;\n\t\t\t\t\treg_e = mr->set_reg;\n\t\t\t\t\treg_d = mr->set_reg;\n\t\t\t\t} else {\n\t\t\t\t\tmode = MODE_MASK_REG;\n\t\t\t\t\treg_e = mr->clr_reg;\n\t\t\t\t\treg_d = mr->clr_reg;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfn += (mr->reg_width >> 3) - 1;\n\t\t\treturn _INTC_MK(fn, mode,\n\t\t\t\t\tintc_get_reg(d, reg_e),\n\t\t\t\t\tintc_get_reg(d, reg_d),\n\t\t\t\t\t1,\n\t\t\t\t\t(mr->reg_width - 1) - *fld_idx);\n\t\t}\n\n\t\t*fld_idx = 0;\n\t\t(*reg_idx)++;\n\t}\n\n\treturn 0;\n}\n\nunsigned int __init\nintc_get_mask_handle(struct intc_desc *desc, struct intc_desc_int *d,\n\t\t     intc_enum enum_id, int do_grps)\n{\n\tunsigned int i = 0;\n\tunsigned int j = 0;\n\tunsigned int ret;\n\n\tret = _intc_mask_data(desc, d, enum_id, &i, &j);\n\tif (ret)\n\t\treturn ret;\n\n\tif (do_grps)\n\t\treturn intc_get_mask_handle(desc, d, intc_grp_id(desc, enum_id), 0);\n\n\treturn 0;\n}\n\nstatic unsigned int __init _intc_prio_data(struct intc_desc *desc,\n\t\t\t\t\t   struct intc_desc_int *d,\n\t\t\t\t\t   intc_enum enum_id,\n\t\t\t\t\t   unsigned int *reg_idx,\n\t\t\t\t\t   unsigned int *fld_idx)\n{\n\tstruct intc_prio_reg *pr = desc->hw.prio_regs;\n\tunsigned int fn, n, mode, bit;\n\tunsigned long reg_e, reg_d;\n\n\twhile (pr && enum_id && *reg_idx < desc->hw.nr_prio_regs) {\n\t\tpr = desc->hw.prio_regs + *reg_idx;\n\n\t\tfor (; *fld_idx < ARRAY_SIZE(pr->enum_ids); (*fld_idx)++) {\n\t\t\tif (pr->enum_ids[*fld_idx] != enum_id)\n\t\t\t\tcontinue;\n\n\t\t\tif (pr->set_reg && pr->clr_reg) {\n\t\t\t\tfn = REG_FN_WRITE_BASE;\n\t\t\t\tmode = MODE_PCLR_REG;\n\t\t\t\treg_e = pr->set_reg;\n\t\t\t\treg_d = pr->clr_reg;\n\t\t\t} else {\n\t\t\t\tfn = REG_FN_MODIFY_BASE;\n\t\t\t\tmode = MODE_PRIO_REG;\n\t\t\t\tif (!pr->set_reg)\n\t\t\t\t\tBUG();\n\t\t\t\treg_e = pr->set_reg;\n\t\t\t\treg_d = pr->set_reg;\n\t\t\t}\n\n\t\t\tfn += (pr->reg_width >> 3) - 1;\n\t\t\tn = *fld_idx + 1;\n\n\t\t\tBUG_ON(n * pr->field_width > pr->reg_width);\n\n\t\t\tbit = pr->reg_width - (n * pr->field_width);\n\n\t\t\treturn _INTC_MK(fn, mode,\n\t\t\t\t\tintc_get_reg(d, reg_e),\n\t\t\t\t\tintc_get_reg(d, reg_d),\n\t\t\t\t\tpr->field_width, bit);\n\t\t}\n\n\t\t*fld_idx = 0;\n\t\t(*reg_idx)++;\n\t}\n\n\treturn 0;\n}\n\nunsigned int __init\nintc_get_prio_handle(struct intc_desc *desc, struct intc_desc_int *d,\n\t\t     intc_enum enum_id, int do_grps)\n{\n\tunsigned int i = 0;\n\tunsigned int j = 0;\n\tunsigned int ret;\n\n\tret = _intc_prio_data(desc, d, enum_id, &i, &j);\n\tif (ret)\n\t\treturn ret;\n\n\tif (do_grps)\n\t\treturn intc_get_prio_handle(desc, d, intc_grp_id(desc, enum_id), 0);\n\n\treturn 0;\n}\n\nstatic unsigned int intc_ack_data(struct intc_desc *desc,\n\t\t\t\t  struct intc_desc_int *d, intc_enum enum_id)\n{\n\tstruct intc_mask_reg *mr = desc->hw.ack_regs;\n\tunsigned int i, j, fn, mode;\n\tunsigned long reg_e, reg_d;\n\n\tfor (i = 0; mr && enum_id && i < desc->hw.nr_ack_regs; i++) {\n\t\tmr = desc->hw.ack_regs + i;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(mr->enum_ids); j++) {\n\t\t\tif (mr->enum_ids[j] != enum_id)\n\t\t\t\tcontinue;\n\n\t\t\tfn = REG_FN_MODIFY_BASE;\n\t\t\tmode = MODE_ENABLE_REG;\n\t\t\treg_e = mr->set_reg;\n\t\t\treg_d = mr->set_reg;\n\n\t\t\tfn += (mr->reg_width >> 3) - 1;\n\t\t\treturn _INTC_MK(fn, mode,\n\t\t\t\t\tintc_get_reg(d, reg_e),\n\t\t\t\t\tintc_get_reg(d, reg_d),\n\t\t\t\t\t1,\n\t\t\t\t\t(mr->reg_width - 1) - j);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void intc_enable_disable(struct intc_desc_int *d,\n\t\t\t\tunsigned long handle, int do_enable)\n{\n\tunsigned long addr;\n\tunsigned int cpu;\n\tunsigned long (*fn)(unsigned long, unsigned long,\n\t\t   unsigned long (*)(unsigned long, unsigned long,\n\t\t\t\t     unsigned long),\n\t\t   unsigned int);\n\n\tif (do_enable) {\n\t\tfor (cpu = 0; cpu < SMP_NR(d, _INTC_ADDR_E(handle)); cpu++) {\n\t\t\taddr = INTC_REG(d, _INTC_ADDR_E(handle), cpu);\n\t\t\tfn = intc_enable_noprio_fns[_INTC_MODE(handle)];\n\t\t\tfn(addr, handle, intc_reg_fns[_INTC_FN(handle)], 0);\n\t\t}\n\t} else {\n\t\tfor (cpu = 0; cpu < SMP_NR(d, _INTC_ADDR_D(handle)); cpu++) {\n\t\t\taddr = INTC_REG(d, _INTC_ADDR_D(handle), cpu);\n\t\t\tfn = intc_disable_fns[_INTC_MODE(handle)];\n\t\t\tfn(addr, handle, intc_reg_fns[_INTC_FN(handle)], 0);\n\t\t}\n\t}\n}\n\nvoid __init intc_enable_disable_enum(struct intc_desc *desc,\n\t\t\t\t     struct intc_desc_int *d,\n\t\t\t\t     intc_enum enum_id, int enable)\n{\n\tunsigned int i, j, data;\n\n\t \n\ti = j = 0;\n\tdo {\n\t\tdata = _intc_mask_data(desc, d, enum_id, &i, &j);\n\t\tif (data)\n\t\t\tintc_enable_disable(d, data, enable);\n\t\tj++;\n\t} while (data);\n\n\t \n\ti = j = 0;\n\tdo {\n\t\tdata = _intc_prio_data(desc, d, enum_id, &i, &j);\n\t\tif (data)\n\t\t\tintc_enable_disable(d, data, enable);\n\n\t\tj++;\n\t} while (data);\n}\n\nunsigned int __init\nintc_get_sense_handle(struct intc_desc *desc, struct intc_desc_int *d,\n\t\t      intc_enum enum_id)\n{\n\tstruct intc_sense_reg *sr = desc->hw.sense_regs;\n\tunsigned int i, j, fn, bit;\n\n\tfor (i = 0; sr && enum_id && i < desc->hw.nr_sense_regs; i++) {\n\t\tsr = desc->hw.sense_regs + i;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(sr->enum_ids); j++) {\n\t\t\tif (sr->enum_ids[j] != enum_id)\n\t\t\t\tcontinue;\n\n\t\t\tfn = REG_FN_MODIFY_BASE;\n\t\t\tfn += (sr->reg_width >> 3) - 1;\n\n\t\t\tBUG_ON((j + 1) * sr->field_width > sr->reg_width);\n\n\t\t\tbit = sr->reg_width - ((j + 1) * sr->field_width);\n\n\t\t\treturn _INTC_MK(fn, 0, intc_get_reg(d, sr->reg),\n\t\t\t\t\t0, sr->field_width, bit);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nvoid intc_set_ack_handle(unsigned int irq, struct intc_desc *desc,\n\t\t\t struct intc_desc_int *d, intc_enum id)\n{\n\tunsigned long flags;\n\n\t \n\tif (!desc->hw.ack_regs)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&intc_big_lock, flags);\n\tack_handle[irq] = intc_ack_data(desc, d, id);\n\traw_spin_unlock_irqrestore(&intc_big_lock, flags);\n}\n\nunsigned long intc_get_ack_handle(unsigned int irq)\n{\n\treturn ack_handle[irq];\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}