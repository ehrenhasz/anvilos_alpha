{
  "module_name": "virq.c",
  "hash_id": "d56cfcfef5f071f4f4ebd3a72a81cd3b73370c895622640ddff5b1b96c859270",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sh/intc/virq.c",
  "human_readable_source": " \n#define pr_fmt(fmt) \"intc: \" fmt\n\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/list.h>\n#include <linux/radix-tree.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include \"internals.h\"\n\nstatic struct intc_map_entry intc_irq_xlate[INTC_NR_IRQS];\n\nstruct intc_virq_list {\n\tunsigned int irq;\n\tstruct intc_virq_list *next;\n};\n\n#define for_each_virq(entry, head) \\\n\tfor (entry = head; entry; entry = entry->next)\n\n \n#define INTC_TAG_VIRQ_NEEDS_ALLOC\t0\n\nvoid intc_irq_xlate_set(unsigned int irq, intc_enum id, struct intc_desc_int *d)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&intc_big_lock, flags);\n\tintc_irq_xlate[irq].enum_id = id;\n\tintc_irq_xlate[irq].desc = d;\n\traw_spin_unlock_irqrestore(&intc_big_lock, flags);\n}\n\nstruct intc_map_entry *intc_irq_xlate_get(unsigned int irq)\n{\n\treturn intc_irq_xlate + irq;\n}\n\nint intc_irq_lookup(const char *chipname, intc_enum enum_id)\n{\n\tstruct intc_map_entry *ptr;\n\tstruct intc_desc_int *d;\n\tint irq = -1;\n\n\tlist_for_each_entry(d, &intc_list, list) {\n\t\tint tagged;\n\n\t\tif (strcmp(d->chip.name, chipname) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\ttagged = radix_tree_tag_get(&d->tree, enum_id,\n\t\t\t\t\t    INTC_TAG_VIRQ_NEEDS_ALLOC);\n\t\tif (unlikely(tagged))\n\t\t\tbreak;\n\n\t\tptr = radix_tree_lookup(&d->tree, enum_id);\n\t\tif (ptr) {\n\t\t\tirq = ptr - intc_irq_xlate;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn irq;\n}\nEXPORT_SYMBOL_GPL(intc_irq_lookup);\n\nstatic int add_virq_to_pirq(unsigned int irq, unsigned int virq)\n{\n\tstruct intc_virq_list *entry;\n\tstruct intc_virq_list **last = NULL;\n\n\t \n\tfor_each_virq(entry, irq_get_handler_data(irq)) {\n\t\tif (entry->irq == virq)\n\t\t\treturn 0;\n\t\tlast = &entry->next;\n\t}\n\n\tentry = kzalloc(sizeof(struct intc_virq_list), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->irq = virq;\n\n\tif (last)\n\t\t*last = entry;\n\telse\n\t\tirq_set_handler_data(irq, entry);\n\n\treturn 0;\n}\n\nstatic void intc_virq_handler(struct irq_desc *desc)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tstruct intc_virq_list *entry, *vlist = irq_data_get_irq_handler_data(data);\n\tstruct intc_desc_int *d = get_intc_desc(irq);\n\n\tchip->irq_mask_ack(data);\n\n\tfor_each_virq(entry, vlist) {\n\t\tunsigned long addr, handle;\n\t\tstruct irq_desc *vdesc = irq_to_desc(entry->irq);\n\n\t\tif (vdesc) {\n\t\t\thandle = (unsigned long)irq_desc_get_handler_data(vdesc);\n\t\t\taddr = INTC_REG(d, _INTC_ADDR_E(handle), 0);\n\t\t\tif (intc_reg_fns[_INTC_FN(handle)](addr, handle, 0))\n\t\t\t\tgeneric_handle_irq_desc(vdesc);\n\t\t}\n\t}\n\n\tchip->irq_unmask(data);\n}\n\nstatic unsigned long __init intc_subgroup_data(struct intc_subgroup *subgroup,\n\t\t\t\t\t       struct intc_desc_int *d,\n\t\t\t\t\t       unsigned int index)\n{\n\tunsigned int fn = REG_FN_TEST_BASE + (subgroup->reg_width >> 3) - 1;\n\n\treturn _INTC_MK(fn, MODE_ENABLE_REG, intc_get_reg(d, subgroup->reg),\n\t\t\t0, 1, (subgroup->reg_width - 1) - index);\n}\n\nstatic void __init intc_subgroup_init_one(struct intc_desc *desc,\n\t\t\t\t\t  struct intc_desc_int *d,\n\t\t\t\t\t  struct intc_subgroup *subgroup)\n{\n\tstruct intc_map_entry *mapped;\n\tunsigned int pirq;\n\tunsigned long flags;\n\tint i;\n\n\tmapped = radix_tree_lookup(&d->tree, subgroup->parent_id);\n\tif (!mapped) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tpirq = mapped - intc_irq_xlate;\n\n\traw_spin_lock_irqsave(&d->lock, flags);\n\n\tfor (i = 0; i < ARRAY_SIZE(subgroup->enum_ids); i++) {\n\t\tstruct intc_subgroup_entry *entry;\n\t\tint err;\n\n\t\tif (!subgroup->enum_ids[i])\n\t\t\tcontinue;\n\n\t\tentry = kmalloc(sizeof(*entry), GFP_NOWAIT);\n\t\tif (!entry)\n\t\t\tbreak;\n\n\t\tentry->pirq = pirq;\n\t\tentry->enum_id = subgroup->enum_ids[i];\n\t\tentry->handle = intc_subgroup_data(subgroup, d, i);\n\n\t\terr = radix_tree_insert(&d->tree, entry->enum_id, entry);\n\t\tif (unlikely(err < 0))\n\t\t\tbreak;\n\n\t\tradix_tree_tag_set(&d->tree, entry->enum_id,\n\t\t\t\t   INTC_TAG_VIRQ_NEEDS_ALLOC);\n\t}\n\n\traw_spin_unlock_irqrestore(&d->lock, flags);\n}\n\nvoid __init intc_subgroup_init(struct intc_desc *desc, struct intc_desc_int *d)\n{\n\tint i;\n\n\tif (!desc->hw.subgroups)\n\t\treturn;\n\n\tfor (i = 0; i < desc->hw.nr_subgroups; i++)\n\t\tintc_subgroup_init_one(desc, d, desc->hw.subgroups + i);\n}\n\nstatic void __init intc_subgroup_map(struct intc_desc_int *d)\n{\n\tstruct intc_subgroup_entry *entries[32];\n\tunsigned long flags;\n\tunsigned int nr_found;\n\tint i;\n\n\traw_spin_lock_irqsave(&d->lock, flags);\n\nrestart:\n\tnr_found = radix_tree_gang_lookup_tag_slot(&d->tree,\n\t\t\t(void ***)entries, 0, ARRAY_SIZE(entries),\n\t\t\tINTC_TAG_VIRQ_NEEDS_ALLOC);\n\n\tfor (i = 0; i < nr_found; i++) {\n\t\tstruct intc_subgroup_entry *entry;\n\t\tint irq;\n\n\t\tentry = radix_tree_deref_slot((void **)entries[i]);\n\t\tif (unlikely(!entry))\n\t\t\tcontinue;\n\t\tif (radix_tree_deref_retry(entry))\n\t\t\tgoto restart;\n\n\t\tirq = irq_alloc_desc(numa_node_id());\n\t\tif (unlikely(irq < 0)) {\n\t\t\tpr_err(\"no more free IRQs, bailing..\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tactivate_irq(irq);\n\n\t\tpr_info(\"Setting up a chained VIRQ from %d -> %d\\n\",\n\t\t\tirq, entry->pirq);\n\n\t\tintc_irq_xlate_set(irq, entry->enum_id, d);\n\n\t\tirq_set_chip_and_handler_name(irq, irq_get_chip(entry->pirq),\n\t\t\t\t\t      handle_simple_irq, \"virq\");\n\t\tirq_set_chip_data(irq, irq_get_chip_data(entry->pirq));\n\n\t\tirq_set_handler_data(irq, (void *)entry->handle);\n\n\t\t \n\t\tirq_set_nothread(irq);\n\n\t\t \n\t\tadd_virq_to_pirq(entry->pirq, irq);\n\t\tirq_set_chained_handler(entry->pirq, intc_virq_handler);\n\n\t\tradix_tree_tag_clear(&d->tree, entry->enum_id,\n\t\t\t\t     INTC_TAG_VIRQ_NEEDS_ALLOC);\n\t\tradix_tree_replace_slot(&d->tree, (void **)entries[i],\n\t\t\t\t\t&intc_irq_xlate[irq]);\n\t}\n\n\traw_spin_unlock_irqrestore(&d->lock, flags);\n}\n\nvoid __init intc_finalize(void)\n{\n\tstruct intc_desc_int *d;\n\n\tlist_for_each_entry(d, &intc_list, list)\n\t\tif (radix_tree_tagged(&d->tree, INTC_TAG_VIRQ_NEEDS_ALLOC))\n\t\t\tintc_subgroup_map(d);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}