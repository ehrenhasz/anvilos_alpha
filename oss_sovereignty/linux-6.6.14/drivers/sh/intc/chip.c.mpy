{
  "module_name": "chip.c",
  "hash_id": "7e8f25d230da24dc50cc733c5efb88cf89e9940c806c63ae606d316362b62c2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sh/intc/chip.c",
  "human_readable_source": " \n#include <linux/cpumask.h>\n#include <linux/bsearch.h>\n#include <linux/io.h>\n#include \"internals.h\"\n\nvoid _intc_enable(struct irq_data *data, unsigned long handle)\n{\n\tunsigned int irq = data->irq;\n\tstruct intc_desc_int *d = get_intc_desc(irq);\n\tunsigned long addr;\n\tunsigned int cpu;\n\n\tfor (cpu = 0; cpu < SMP_NR(d, _INTC_ADDR_E(handle)); cpu++) {\n#ifdef CONFIG_SMP\n\t\tif (!cpumask_test_cpu(cpu, irq_data_get_affinity_mask(data)))\n\t\t\tcontinue;\n#endif\n\t\taddr = INTC_REG(d, _INTC_ADDR_E(handle), cpu);\n\t\tintc_enable_fns[_INTC_MODE(handle)](addr, handle, intc_reg_fns\\\n\t\t\t\t\t\t    [_INTC_FN(handle)], irq);\n\t}\n\n\tintc_balancing_enable(irq);\n}\n\nstatic void intc_enable(struct irq_data *data)\n{\n\t_intc_enable(data, (unsigned long)irq_data_get_irq_chip_data(data));\n}\n\nstatic void intc_disable(struct irq_data *data)\n{\n\tunsigned int irq = data->irq;\n\tstruct intc_desc_int *d = get_intc_desc(irq);\n\tunsigned long handle = (unsigned long)irq_data_get_irq_chip_data(data);\n\tunsigned long addr;\n\tunsigned int cpu;\n\n\tintc_balancing_disable(irq);\n\n\tfor (cpu = 0; cpu < SMP_NR(d, _INTC_ADDR_D(handle)); cpu++) {\n#ifdef CONFIG_SMP\n\t\tif (!cpumask_test_cpu(cpu, irq_data_get_affinity_mask(data)))\n\t\t\tcontinue;\n#endif\n\t\taddr = INTC_REG(d, _INTC_ADDR_D(handle), cpu);\n\t\tintc_disable_fns[_INTC_MODE(handle)](addr, handle,intc_reg_fns\\\n\t\t\t\t\t\t     [_INTC_FN(handle)], irq);\n\t}\n}\n\n#ifdef CONFIG_SMP\n \nstatic int intc_set_affinity(struct irq_data *data,\n\t\t\t     const struct cpumask *cpumask,\n\t\t\t     bool force)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask))\n\t\treturn -1;\n\n\tirq_data_update_affinity(data, cpumask);\n\n\treturn IRQ_SET_MASK_OK_NOCOPY;\n}\n#endif\n\nstatic void intc_mask_ack(struct irq_data *data)\n{\n\tunsigned int irq = data->irq;\n\tstruct intc_desc_int *d = get_intc_desc(irq);\n\tunsigned long handle = intc_get_ack_handle(irq);\n\tvoid __iomem *addr;\n\n\tintc_disable(data);\n\n\t \n\tif (handle) {\n\t\tunsigned int value;\n\n\t\taddr = (void __iomem *)INTC_REG(d, _INTC_ADDR_D(handle), 0);\n\t\tvalue = intc_set_field_from_handle(0, 1, handle);\n\n\t\tswitch (_INTC_FN(handle)) {\n\t\tcase REG_FN_MODIFY_BASE + 0:\t \n\t\t\t__raw_readb(addr);\n\t\t\t__raw_writeb(0xff ^ value, addr);\n\t\t\tbreak;\n\t\tcase REG_FN_MODIFY_BASE + 1:\t \n\t\t\t__raw_readw(addr);\n\t\t\t__raw_writew(0xffff ^ value, addr);\n\t\t\tbreak;\n\t\tcase REG_FN_MODIFY_BASE + 3:\t \n\t\t\t__raw_readl(addr);\n\t\t\t__raw_writel(0xffffffff ^ value, addr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct intc_handle_int *intc_find_irq(struct intc_handle_int *hp,\n\t\t\t\t\t     unsigned int nr_hp,\n\t\t\t\t\t     unsigned int irq)\n{\n\tstruct intc_handle_int key;\n\n\tkey.irq = irq;\n\tkey.handle = 0;\n\n\treturn bsearch(&key, hp, nr_hp, sizeof(*hp), intc_handle_int_cmp);\n}\n\nint intc_set_priority(unsigned int irq, unsigned int prio)\n{\n\tstruct intc_desc_int *d = get_intc_desc(irq);\n\tstruct irq_data *data = irq_get_irq_data(irq);\n\tstruct intc_handle_int *ihp;\n\n\tif (!intc_get_prio_level(irq) || prio <= 1)\n\t\treturn -EINVAL;\n\n\tihp = intc_find_irq(d->prio, d->nr_prio, irq);\n\tif (ihp) {\n\t\tif (prio >= (1 << _INTC_WIDTH(ihp->handle)))\n\t\t\treturn -EINVAL;\n\n\t\tintc_set_prio_level(irq, prio);\n\n\t\t \n\t\tif (_INTC_FN(ihp->handle) != REG_FN_ERR)\n\t\t\t_intc_enable(data, ihp->handle);\n\t}\n\treturn 0;\n}\n\n#define SENSE_VALID_FLAG 0x80\n#define VALID(x) (x | SENSE_VALID_FLAG)\n\nstatic unsigned char intc_irq_sense_table[IRQ_TYPE_SENSE_MASK + 1] = {\n\t[IRQ_TYPE_EDGE_FALLING] = VALID(0),\n\t[IRQ_TYPE_EDGE_RISING] = VALID(1),\n\t[IRQ_TYPE_LEVEL_LOW] = VALID(2),\n\t \n#if !defined(CONFIG_CPU_SUBTYPE_SH7706) && \\\n    !defined(CONFIG_CPU_SUBTYPE_SH7707) && \\\n    !defined(CONFIG_CPU_SUBTYPE_SH7709)\n\t[IRQ_TYPE_LEVEL_HIGH] = VALID(3),\n#endif\n#if defined(CONFIG_ARM)  \n\t[IRQ_TYPE_EDGE_BOTH] = VALID(4),\n#endif\n};\n\nstatic int intc_set_type(struct irq_data *data, unsigned int type)\n{\n\tunsigned int irq = data->irq;\n\tstruct intc_desc_int *d = get_intc_desc(irq);\n\tunsigned char value = intc_irq_sense_table[type & IRQ_TYPE_SENSE_MASK];\n\tstruct intc_handle_int *ihp;\n\tunsigned long addr;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\tvalue &= ~SENSE_VALID_FLAG;\n\n\tihp = intc_find_irq(d->sense, d->nr_sense, irq);\n\tif (ihp) {\n\t\t \n\t\tif (value >= (1 << _INTC_WIDTH(ihp->handle)))\n\t\t\treturn -EINVAL;\n\n\t\taddr = INTC_REG(d, _INTC_ADDR_E(ihp->handle), 0);\n\t\tintc_reg_fns[_INTC_FN(ihp->handle)](addr, ihp->handle, value);\n\t}\n\n\treturn 0;\n}\n\nstruct irq_chip intc_irq_chip\t= {\n\t.irq_mask\t\t= intc_disable,\n\t.irq_unmask\t\t= intc_enable,\n\t.irq_mask_ack\t\t= intc_mask_ack,\n\t.irq_enable\t\t= intc_enable,\n\t.irq_disable\t\t= intc_disable,\n\t.irq_set_type\t\t= intc_set_type,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity\t= intc_set_affinity,\n#endif\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}