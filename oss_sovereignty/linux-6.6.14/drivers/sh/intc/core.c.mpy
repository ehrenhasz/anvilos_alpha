{
  "module_name": "core.c",
  "hash_id": "bc15cef746b809c27ea46e98ddaec830efe356d4396efda257bef82e4a2f99be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sh/intc/core.c",
  "human_readable_source": " \n#define pr_fmt(fmt) \"intc: \" fmt\n\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/interrupt.h>\n#include <linux/sh_intc.h>\n#include <linux/irqdomain.h>\n#include <linux/device.h>\n#include <linux/syscore_ops.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/radix-tree.h>\n#include <linux/export.h>\n#include <linux/sort.h>\n#include \"internals.h\"\n\nLIST_HEAD(intc_list);\nDEFINE_RAW_SPINLOCK(intc_big_lock);\nstatic unsigned int nr_intc_controllers;\n\n \nstatic unsigned int default_prio_level = 2;\t \nstatic unsigned int intc_prio_level[INTC_NR_IRQS];\t \n\nunsigned int intc_get_dfl_prio_level(void)\n{\n\treturn default_prio_level;\n}\n\nunsigned int intc_get_prio_level(unsigned int irq)\n{\n\treturn intc_prio_level[irq];\n}\n\nvoid intc_set_prio_level(unsigned int irq, unsigned int level)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&intc_big_lock, flags);\n\tintc_prio_level[irq] = level;\n\traw_spin_unlock_irqrestore(&intc_big_lock, flags);\n}\n\nstatic void intc_redirect_irq(struct irq_desc *desc)\n{\n\tgeneric_handle_irq((unsigned int)irq_desc_get_handler_data(desc));\n}\n\nstatic void __init intc_register_irq(struct intc_desc *desc,\n\t\t\t\t     struct intc_desc_int *d,\n\t\t\t\t     intc_enum enum_id,\n\t\t\t\t     unsigned int irq)\n{\n\tstruct intc_handle_int *hp;\n\tstruct irq_data *irq_data;\n\tunsigned int data[2], primary;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&intc_big_lock, flags);\n\tradix_tree_insert(&d->tree, enum_id, intc_irq_xlate_get(irq));\n\traw_spin_unlock_irqrestore(&intc_big_lock, flags);\n\n\t \n\tdata[0] = intc_get_mask_handle(desc, d, enum_id, 0);\n\tdata[1] = intc_get_prio_handle(desc, d, enum_id, 0);\n\n\tprimary = 0;\n\tif (!data[0] && data[1])\n\t\tprimary = 1;\n\n\tif (!data[0] && !data[1])\n\t\tpr_warn(\"missing unique irq mask for irq %d (vect 0x%04x)\\n\",\n\t\t\tirq, irq2evt(irq));\n\n\tdata[0] = data[0] ? data[0] : intc_get_mask_handle(desc, d, enum_id, 1);\n\tdata[1] = data[1] ? data[1] : intc_get_prio_handle(desc, d, enum_id, 1);\n\n\tif (!data[primary])\n\t\tprimary ^= 1;\n\n\tBUG_ON(!data[primary]);  \n\n\tirq_data = irq_get_irq_data(irq);\n\n\tdisable_irq_nosync(irq);\n\tirq_set_chip_and_handler_name(irq, &d->chip, handle_level_irq,\n\t\t\t\t      \"level\");\n\tirq_set_chip_data(irq, (void *)data[primary]);\n\n\t \n\tintc_set_prio_level(irq, intc_get_dfl_prio_level());\n\n\t \n\tif (data[!primary])\n\t\t_intc_enable(irq_data, data[!primary]);\n\n\t \n\tif (data[1]) {\n\t\thp = d->prio + d->nr_prio;\n\t\thp->irq = irq;\n\t\thp->handle = data[1];\n\n\t\tif (primary) {\n\t\t\t \n\t\t\thp->handle &= ~_INTC_MK(0x0f, 0, 0, 0, 0, 0);\n\t\t\thp->handle |= _INTC_MK(REG_FN_ERR, 0, 0, 0, 0, 0);\n\t\t}\n\t\td->nr_prio++;\n\t}\n\n\t \n\tdata[0] = intc_get_sense_handle(desc, d, enum_id);\n\tif (data[0]) {\n\t\t(d->sense + d->nr_sense)->irq = irq;\n\t\t(d->sense + d->nr_sense)->handle = data[0];\n\t\td->nr_sense++;\n\t}\n\n\t \n\td->chip.irq_mask(irq_data);\n\n\tintc_set_ack_handle(irq, desc, d, enum_id);\n\tintc_set_dist_handle(irq, desc, d, enum_id);\n\n\tactivate_irq(irq);\n}\n\nstatic unsigned int __init save_reg(struct intc_desc_int *d,\n\t\t\t\t    unsigned int cnt,\n\t\t\t\t    unsigned long value,\n\t\t\t\t    unsigned int smp)\n{\n\tif (value) {\n\t\tvalue = intc_phys_to_virt(d, value);\n\n\t\td->reg[cnt] = value;\n#ifdef CONFIG_SMP\n\t\td->smp[cnt] = smp;\n#endif\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic bool __init intc_map(struct irq_domain *domain, int irq)\n{\n\tif (!irq_to_desc(irq) && irq_alloc_desc_at(irq, NUMA_NO_NODE) != irq) {\n\t\tpr_err(\"uname to allocate IRQ %d\\n\", irq);\n\t\treturn false;\n\t}\n\n\tif (irq_domain_associate(domain, irq, irq)) {\n\t\tpr_err(\"domain association failure\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint __init register_intc_controller(struct intc_desc *desc)\n{\n\tunsigned int i, k, smp;\n\tstruct intc_hw_desc *hw = &desc->hw;\n\tstruct intc_desc_int *d;\n\tstruct resource *res;\n\n\tpr_info(\"Registered controller '%s' with %u IRQs\\n\",\n\t\tdesc->name, hw->nr_vectors);\n\n\td = kzalloc(sizeof(*d), GFP_NOWAIT);\n\tif (!d)\n\t\tgoto err0;\n\n\tINIT_LIST_HEAD(&d->list);\n\tlist_add_tail(&d->list, &intc_list);\n\n\traw_spin_lock_init(&d->lock);\n\tINIT_RADIX_TREE(&d->tree, GFP_ATOMIC);\n\n\td->index = nr_intc_controllers;\n\n\tif (desc->num_resources) {\n\t\td->nr_windows = desc->num_resources;\n\t\td->window = kcalloc(d->nr_windows, sizeof(*d->window),\n\t\t\t\t    GFP_NOWAIT);\n\t\tif (!d->window)\n\t\t\tgoto err1;\n\n\t\tfor (k = 0; k < d->nr_windows; k++) {\n\t\t\tres = desc->resource + k;\n\t\t\tWARN_ON(resource_type(res) != IORESOURCE_MEM);\n\t\t\td->window[k].phys = res->start;\n\t\t\td->window[k].size = resource_size(res);\n\t\t\td->window[k].virt = ioremap(res->start,\n\t\t\t\t\t\t    resource_size(res));\n\t\t\tif (!d->window[k].virt)\n\t\t\t\tgoto err2;\n\t\t}\n\t}\n\n\td->nr_reg = hw->mask_regs ? hw->nr_mask_regs * 2 : 0;\n#ifdef CONFIG_INTC_BALANCING\n\tif (d->nr_reg)\n\t\td->nr_reg += hw->nr_mask_regs;\n#endif\n\td->nr_reg += hw->prio_regs ? hw->nr_prio_regs * 2 : 0;\n\td->nr_reg += hw->sense_regs ? hw->nr_sense_regs : 0;\n\td->nr_reg += hw->ack_regs ? hw->nr_ack_regs : 0;\n\td->nr_reg += hw->subgroups ? hw->nr_subgroups : 0;\n\n\td->reg = kcalloc(d->nr_reg, sizeof(*d->reg), GFP_NOWAIT);\n\tif (!d->reg)\n\t\tgoto err2;\n\n#ifdef CONFIG_SMP\n\td->smp = kcalloc(d->nr_reg, sizeof(*d->smp), GFP_NOWAIT);\n\tif (!d->smp)\n\t\tgoto err3;\n#endif\n\tk = 0;\n\n\tif (hw->mask_regs) {\n\t\tfor (i = 0; i < hw->nr_mask_regs; i++) {\n\t\t\tsmp = IS_SMP(hw->mask_regs[i]);\n\t\t\tk += save_reg(d, k, hw->mask_regs[i].set_reg, smp);\n\t\t\tk += save_reg(d, k, hw->mask_regs[i].clr_reg, smp);\n#ifdef CONFIG_INTC_BALANCING\n\t\t\tk += save_reg(d, k, hw->mask_regs[i].dist_reg, 0);\n#endif\n\t\t}\n\t}\n\n\tif (hw->prio_regs) {\n\t\td->prio = kcalloc(hw->nr_vectors, sizeof(*d->prio),\n\t\t\t\t  GFP_NOWAIT);\n\t\tif (!d->prio)\n\t\t\tgoto err4;\n\n\t\tfor (i = 0; i < hw->nr_prio_regs; i++) {\n\t\t\tsmp = IS_SMP(hw->prio_regs[i]);\n\t\t\tk += save_reg(d, k, hw->prio_regs[i].set_reg, smp);\n\t\t\tk += save_reg(d, k, hw->prio_regs[i].clr_reg, smp);\n\t\t}\n\n\t\tsort(d->prio, hw->nr_prio_regs, sizeof(*d->prio),\n\t\t     intc_handle_int_cmp, NULL);\n\t}\n\n\tif (hw->sense_regs) {\n\t\td->sense = kcalloc(hw->nr_vectors, sizeof(*d->sense),\n\t\t\t\t   GFP_NOWAIT);\n\t\tif (!d->sense)\n\t\t\tgoto err5;\n\n\t\tfor (i = 0; i < hw->nr_sense_regs; i++)\n\t\t\tk += save_reg(d, k, hw->sense_regs[i].reg, 0);\n\n\t\tsort(d->sense, hw->nr_sense_regs, sizeof(*d->sense),\n\t\t     intc_handle_int_cmp, NULL);\n\t}\n\n\tif (hw->subgroups)\n\t\tfor (i = 0; i < hw->nr_subgroups; i++)\n\t\t\tif (hw->subgroups[i].reg)\n\t\t\t\tk+= save_reg(d, k, hw->subgroups[i].reg, 0);\n\n\tmemcpy(&d->chip, &intc_irq_chip, sizeof(struct irq_chip));\n\td->chip.name = desc->name;\n\n\tif (hw->ack_regs)\n\t\tfor (i = 0; i < hw->nr_ack_regs; i++)\n\t\t\tk += save_reg(d, k, hw->ack_regs[i].set_reg, 0);\n\telse\n\t\td->chip.irq_mask_ack = d->chip.irq_disable;\n\n\t \n\tif (desc->force_disable)\n\t\tintc_enable_disable_enum(desc, d, desc->force_disable, 0);\n\n\t \n\tif (desc->force_enable)\n\t\tintc_enable_disable_enum(desc, d, desc->force_enable, 0);\n\n\tBUG_ON(k > 256);  \n\n\tintc_irq_domain_init(d, hw);\n\n\t \n\tfor (i = 0; i < hw->nr_vectors; i++) {\n\t\tstruct intc_vect *vect = hw->vectors + i;\n\t\tunsigned int irq = evt2irq(vect->vect);\n\n\t\tif (!vect->enum_id)\n\t\t\tcontinue;\n\n\t\tif (!intc_map(d->domain, irq))\n\t\t\tcontinue;\n\n\t\tintc_irq_xlate_set(irq, vect->enum_id, d);\n\t\tintc_register_irq(desc, d, vect->enum_id, irq);\n\n\t\tfor (k = i + 1; k < hw->nr_vectors; k++) {\n\t\t\tstruct intc_vect *vect2 = hw->vectors + k;\n\t\t\tunsigned int irq2 = evt2irq(vect2->vect);\n\n\t\t\tif (vect->enum_id != vect2->enum_id)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!intc_map(d->domain, irq2))\n\t\t\t\tcontinue;\n\n\t\t\tvect2->enum_id = 0;\n\n\t\t\t \n\t\t\tirq_set_chip(irq2, &dummy_irq_chip);\n\t\t\tirq_set_chained_handler_and_data(irq2,\n\t\t\t\t\t\t\t intc_redirect_irq,\n\t\t\t\t\t\t\t (void *)irq);\n\t\t}\n\t}\n\n\tintc_subgroup_init(desc, d);\n\n\t \n\tif (desc->force_enable)\n\t\tintc_enable_disable_enum(desc, d, desc->force_enable, 1);\n\n\td->skip_suspend = desc->skip_syscore_suspend;\n\n\tnr_intc_controllers++;\n\n\treturn 0;\nerr5:\n\tkfree(d->prio);\nerr4:\n#ifdef CONFIG_SMP\n\tkfree(d->smp);\nerr3:\n#endif\n\tkfree(d->reg);\nerr2:\n\tfor (k = 0; k < d->nr_windows; k++)\n\t\tif (d->window[k].virt)\n\t\t\tiounmap(d->window[k].virt);\n\n\tkfree(d->window);\nerr1:\n\tkfree(d);\nerr0:\n\tpr_err(\"unable to allocate INTC memory\\n\");\n\n\treturn -ENOMEM;\n}\n\nstatic int intc_suspend(void)\n{\n\tstruct intc_desc_int *d;\n\n\tlist_for_each_entry(d, &intc_list, list) {\n\t\tint irq;\n\n\t\tif (d->skip_suspend)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor_each_active_irq(irq) {\n\t\t\tstruct irq_data *data;\n\t\t\tstruct irq_chip *chip;\n\n\t\t\tdata = irq_get_irq_data(irq);\n\t\t\tchip = irq_data_get_irq_chip(data);\n\t\t\tif (chip != &d->chip)\n\t\t\t\tcontinue;\n\t\t\tif (irqd_is_wakeup_set(data))\n\t\t\t\tchip->irq_enable(data);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void intc_resume(void)\n{\n\tstruct intc_desc_int *d;\n\n\tlist_for_each_entry(d, &intc_list, list) {\n\t\tint irq;\n\n\t\tif (d->skip_suspend)\n\t\t\tcontinue;\n\n\t\tfor_each_active_irq(irq) {\n\t\t\tstruct irq_data *data;\n\t\t\tstruct irq_chip *chip;\n\n\t\t\tdata = irq_get_irq_data(irq);\n\t\t\tchip = irq_data_get_irq_chip(data);\n\t\t\t \n\t\t\tif (chip != &d->chip)\n\t\t\t\tcontinue;\n\t\t\tif (irqd_irq_disabled(data))\n\t\t\t\tchip->irq_disable(data);\n\t\t\telse\n\t\t\t\tchip->irq_enable(data);\n\t\t}\n\t}\n}\n\nstruct syscore_ops intc_syscore_ops = {\n\t.suspend\t= intc_suspend,\n\t.resume\t\t= intc_resume,\n};\n\nstruct bus_type intc_subsys = {\n\t.name\t\t= \"intc\",\n\t.dev_name\t= \"intc\",\n};\n\nstatic ssize_t\nshow_intc_name(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct intc_desc_int *d;\n\n\td = container_of(dev, struct intc_desc_int, dev);\n\n\treturn sprintf(buf, \"%s\\n\", d->chip.name);\n}\n\nstatic DEVICE_ATTR(name, S_IRUGO, show_intc_name, NULL);\n\nstatic int __init register_intc_devs(void)\n{\n\tstruct intc_desc_int *d;\n\tint error;\n\n\tregister_syscore_ops(&intc_syscore_ops);\n\n\terror = subsys_system_register(&intc_subsys, NULL);\n\tif (!error) {\n\t\tlist_for_each_entry(d, &intc_list, list) {\n\t\t\td->dev.id = d->index;\n\t\t\td->dev.bus = &intc_subsys;\n\t\t\terror = device_register(&d->dev);\n\t\t\tif (error == 0)\n\t\t\t\terror = device_create_file(&d->dev,\n\t\t\t\t\t\t\t   &dev_attr_name);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error)\n\t\tpr_err(\"device registration error\\n\");\n\n\treturn error;\n}\ndevice_initcall(register_intc_devs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}