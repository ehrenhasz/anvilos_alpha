{
  "module_name": "superhyway.c",
  "hash_id": "aff3e9119cbec18db968a9c5705bea06630ca24cb9a5107ca73e9a7cf02ac6c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/sh/superhyway/superhyway.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/superhyway.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic int superhyway_devices;\n\nstatic struct device superhyway_bus_device = {\n\t.init_name = \"superhyway\",\n};\n\nstatic void superhyway_device_release(struct device *dev)\n{\n\tstruct superhyway_device *sdev = to_superhyway_device(dev);\n\n\tkfree(sdev->resource);\n\tkfree(sdev);\n}\n\n \nint superhyway_add_device(unsigned long base, struct superhyway_device *sdev,\n\t\t\t  struct superhyway_bus *bus)\n{\n\tstruct superhyway_device *dev = sdev;\n\n\tif (!dev) {\n\t\tdev = kzalloc(sizeof(struct superhyway_device), GFP_KERNEL);\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\n\t}\n\n\tdev->bus = bus;\n\tsuperhyway_read_vcr(dev, base, &dev->vcr);\n\n\tif (!dev->resource) {\n\t\tdev->resource = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\t\tif (!dev->resource) {\n\t\t\tkfree(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdev->resource->name\t= dev->name;\n\t\tdev->resource->start\t= base;\n\t\tdev->resource->end\t= dev->resource->start + 0x01000000;\n\t}\n\n\tdev->dev.parent\t\t= &superhyway_bus_device;\n\tdev->dev.bus\t\t= &superhyway_bus_type;\n\tdev->dev.release\t= superhyway_device_release;\n\tdev->id.id\t\t= dev->vcr.mod_id;\n\n\tsprintf(dev->name, \"SuperHyway device %04x\", dev->id.id);\n\tdev_set_name(&dev->dev, \"%02x\", superhyway_devices);\n\n\tsuperhyway_devices++;\n\n\treturn device_register(&dev->dev);\n}\n\nint superhyway_add_devices(struct superhyway_bus *bus,\n\t\t\t   struct superhyway_device **devices,\n\t\t\t   int nr_devices)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < nr_devices; i++) {\n\t\tstruct superhyway_device *dev = devices[i];\n\t\tret |= superhyway_add_device(dev->resource[0].start, dev, bus);\n\t}\n\n\treturn ret;\n}\n\nstatic int __init superhyway_init(void)\n{\n\tstruct superhyway_bus *bus;\n\tint ret;\n\n\tret = device_register(&superhyway_bus_device);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tfor (bus = superhyway_channels; bus->ops; bus++)\n\t\tret |= superhyway_scan_bus(bus);\n\n\treturn ret;\n}\npostcore_initcall(superhyway_init);\n\nstatic const struct superhyway_device_id *\nsuperhyway_match_id(const struct superhyway_device_id *ids,\n\t\t    struct superhyway_device *dev)\n{\n\twhile (ids->id) {\n\t\tif (ids->id == dev->id.id)\n\t\t\treturn ids;\n\n\t\tids++;\n\t}\n\n\treturn NULL;\n}\n\nstatic int superhyway_device_probe(struct device *dev)\n{\n\tstruct superhyway_device *shyway_dev = to_superhyway_device(dev);\n\tstruct superhyway_driver *shyway_drv = to_superhyway_driver(dev->driver);\n\n\tif (shyway_drv && shyway_drv->probe) {\n\t\tconst struct superhyway_device_id *id;\n\n\t\tid = superhyway_match_id(shyway_drv->id_table, shyway_dev);\n\t\tif (id)\n\t\t\treturn shyway_drv->probe(shyway_dev, id);\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic void superhyway_device_remove(struct device *dev)\n{\n\tstruct superhyway_device *shyway_dev = to_superhyway_device(dev);\n\tstruct superhyway_driver *shyway_drv = to_superhyway_driver(dev->driver);\n\n\tif (shyway_drv->remove)\n\t\tshyway_drv->remove(shyway_dev);\n}\n\n \nint superhyway_register_driver(struct superhyway_driver *drv)\n{\n\tdrv->drv.name\t= drv->name;\n\tdrv->drv.bus\t= &superhyway_bus_type;\n\n\treturn driver_register(&drv->drv);\n}\n\n \nvoid superhyway_unregister_driver(struct superhyway_driver *drv)\n{\n\tdriver_unregister(&drv->drv);\n}\n\nstatic int superhyway_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct superhyway_device *shyway_dev = to_superhyway_device(dev);\n\tstruct superhyway_driver *shyway_drv = to_superhyway_driver(drv);\n\tconst struct superhyway_device_id *ids = shyway_drv->id_table;\n\n\tif (!ids)\n\t\treturn -EINVAL;\n\tif (superhyway_match_id(ids, shyway_dev))\n\t\treturn 1;\n\n\treturn -ENODEV;\n}\n\nstruct bus_type superhyway_bus_type = {\n\t.name\t\t= \"superhyway\",\n\t.match\t\t= superhyway_bus_match,\n#ifdef CONFIG_SYSFS\n\t.dev_groups\t= superhyway_dev_groups,\n#endif\n\t.probe\t\t= superhyway_device_probe,\n\t.remove\t\t= superhyway_device_remove,\n};\n\nstatic int __init superhyway_bus_init(void)\n{\n\treturn bus_register(&superhyway_bus_type);\n}\n\nstatic void __exit superhyway_bus_exit(void)\n{\n\tdevice_unregister(&superhyway_bus_device);\n\tbus_unregister(&superhyway_bus_type);\n}\n\ncore_initcall(superhyway_bus_init);\nmodule_exit(superhyway_bus_exit);\n\nEXPORT_SYMBOL(superhyway_bus_type);\nEXPORT_SYMBOL(superhyway_add_device);\nEXPORT_SYMBOL(superhyway_add_devices);\nEXPORT_SYMBOL(superhyway_register_driver);\nEXPORT_SYMBOL(superhyway_unregister_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}