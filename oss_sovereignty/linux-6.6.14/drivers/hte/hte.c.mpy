{
  "module_name": "hte.c",
  "hash_id": "ddcc9b362772f4f1289f90a5bf388dbb0927dca23a2af52000852e82a9ad9b46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hte/hte.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/hte.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n\n#define HTE_TS_NAME_LEN\t\t10\n\n \nstatic DEFINE_SPINLOCK(hte_lock);\nstatic LIST_HEAD(hte_devices);\n\nenum {\n\tHTE_TS_REGISTERED,\n\tHTE_TS_REQ,\n\tHTE_TS_DISABLE,\n\tHTE_TS_QUEUE_WK,\n};\n\n \nstruct hte_ts_info {\n\tu32 xlated_id;\n\tunsigned long flags;\n\tunsigned long hte_cb_flags;\n\tu64 seq;\n\tchar *line_name;\n\tbool free_attr_name;\n\thte_ts_cb_t cb;\n\thte_ts_sec_cb_t tcb;\n\tatomic_t dropped_ts;\n\tspinlock_t slock;\n\tstruct work_struct cb_work;\n\tstruct mutex req_mlock;\n\tstruct dentry *ts_dbg_root;\n\tstruct hte_device *gdev;\n\tvoid *cl_data;\n};\n\n \nstruct hte_device {\n\tu32 nlines;\n\tatomic_t ts_req;\n\tstruct device *sdev;\n\tstruct dentry *dbg_root;\n\tstruct list_head list;\n\tstruct hte_chip *chip;\n\tstruct module *owner;\n\tstruct hte_ts_info ei[];\n};\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic struct dentry *hte_root;\n\nstatic int __init hte_subsys_dbgfs_init(void)\n{\n\t \n\thte_root = debugfs_create_dir(\"hte\", NULL);\n\n\treturn 0;\n}\nsubsys_initcall(hte_subsys_dbgfs_init);\n\nstatic void hte_chip_dbgfs_init(struct hte_device *gdev)\n{\n\tconst struct hte_chip *chip = gdev->chip;\n\tconst char *name = chip->name ? chip->name : dev_name(chip->dev);\n\n\tgdev->dbg_root = debugfs_create_dir(name, hte_root);\n\n\tdebugfs_create_atomic_t(\"ts_requested\", 0444, gdev->dbg_root,\n\t\t\t\t&gdev->ts_req);\n\tdebugfs_create_u32(\"total_ts\", 0444, gdev->dbg_root,\n\t\t\t   &gdev->nlines);\n}\n\nstatic void hte_ts_dbgfs_init(const char *name, struct hte_ts_info *ei)\n{\n\tif (!ei->gdev->dbg_root || !name)\n\t\treturn;\n\n\tei->ts_dbg_root = debugfs_create_dir(name, ei->gdev->dbg_root);\n\n\tdebugfs_create_atomic_t(\"dropped_timestamps\", 0444, ei->ts_dbg_root,\n\t\t\t\t&ei->dropped_ts);\n}\n\n#else\n\nstatic void hte_chip_dbgfs_init(struct hte_device *gdev)\n{\n}\n\nstatic void hte_ts_dbgfs_init(const char *name, struct hte_ts_info *ei)\n{\n}\n\n#endif\n\n \nint hte_ts_put(struct hte_ts_desc *desc)\n{\n\tint ret = 0;\n\tunsigned long flag;\n\tstruct hte_device *gdev;\n\tstruct hte_ts_info *ei;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tei = desc->hte_data;\n\n\tif (!ei || !ei->gdev)\n\t\treturn -EINVAL;\n\n\tgdev = ei->gdev;\n\n\tmutex_lock(&ei->req_mlock);\n\n\tif (unlikely(!test_bit(HTE_TS_REQ, &ei->flags) &&\n\t    !test_bit(HTE_TS_REGISTERED, &ei->flags))) {\n\t\tdev_info(gdev->sdev, \"id:%d is not requested\\n\",\n\t\t\t desc->attr.line_id);\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (unlikely(!test_bit(HTE_TS_REQ, &ei->flags) &&\n\t    test_bit(HTE_TS_REGISTERED, &ei->flags))) {\n\t\tdev_info(gdev->sdev, \"id:%d is registered but not requested\\n\",\n\t\t\t desc->attr.line_id);\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (test_bit(HTE_TS_REQ, &ei->flags) &&\n\t    !test_bit(HTE_TS_REGISTERED, &ei->flags)) {\n\t\tclear_bit(HTE_TS_REQ, &ei->flags);\n\t\tdesc->hte_data = NULL;\n\t\tret = 0;\n\t\tgoto mod_put;\n\t}\n\n\tret = gdev->chip->ops->release(gdev->chip, desc, ei->xlated_id);\n\tif (ret) {\n\t\tdev_err(gdev->sdev, \"id: %d free failed\\n\",\n\t\t\tdesc->attr.line_id);\n\t\tgoto unlock;\n\t}\n\n\tkfree(ei->line_name);\n\tif (ei->free_attr_name)\n\t\tkfree_const(desc->attr.name);\n\n\tdebugfs_remove_recursive(ei->ts_dbg_root);\n\n\tspin_lock_irqsave(&ei->slock, flag);\n\n\tif (test_bit(HTE_TS_QUEUE_WK, &ei->flags)) {\n\t\tspin_unlock_irqrestore(&ei->slock, flag);\n\t\tflush_work(&ei->cb_work);\n\t\tspin_lock_irqsave(&ei->slock, flag);\n\t}\n\n\tatomic_dec(&gdev->ts_req);\n\tatomic_set(&ei->dropped_ts, 0);\n\n\tei->seq = 1;\n\tei->flags = 0;\n\tdesc->hte_data = NULL;\n\n\tspin_unlock_irqrestore(&ei->slock, flag);\n\n\tei->cb = NULL;\n\tei->tcb = NULL;\n\tei->cl_data = NULL;\n\nmod_put:\n\tmodule_put(gdev->owner);\nunlock:\n\tmutex_unlock(&ei->req_mlock);\n\tdev_dbg(gdev->sdev, \"release id: %d\\n\", desc->attr.line_id);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hte_ts_put);\n\nstatic int hte_ts_dis_en_common(struct hte_ts_desc *desc, bool en)\n{\n\tu32 ts_id;\n\tstruct hte_device *gdev;\n\tstruct hte_ts_info *ei;\n\tint ret;\n\tunsigned long flag;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tei = desc->hte_data;\n\n\tif (!ei || !ei->gdev)\n\t\treturn -EINVAL;\n\n\tgdev = ei->gdev;\n\tts_id = desc->attr.line_id;\n\n\tmutex_lock(&ei->req_mlock);\n\n\tif (!test_bit(HTE_TS_REGISTERED, &ei->flags)) {\n\t\tdev_dbg(gdev->sdev, \"id:%d is not registered\", ts_id);\n\t\tret = -EUSERS;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&ei->slock, flag);\n\n\tif (en) {\n\t\tif (!test_bit(HTE_TS_DISABLE, &ei->flags)) {\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&ei->slock, flag);\n\t\tret = gdev->chip->ops->enable(gdev->chip, ei->xlated_id);\n\t\tif (ret) {\n\t\t\tdev_warn(gdev->sdev, \"id: %d enable failed\\n\",\n\t\t\t\t ts_id);\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock_irqsave(&ei->slock, flag);\n\t\tclear_bit(HTE_TS_DISABLE, &ei->flags);\n\t} else {\n\t\tif (test_bit(HTE_TS_DISABLE, &ei->flags)) {\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&ei->slock, flag);\n\t\tret = gdev->chip->ops->disable(gdev->chip, ei->xlated_id);\n\t\tif (ret) {\n\t\t\tdev_warn(gdev->sdev, \"id: %d disable failed\\n\",\n\t\t\t\t ts_id);\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock_irqsave(&ei->slock, flag);\n\t\tset_bit(HTE_TS_DISABLE, &ei->flags);\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&ei->slock, flag);\nout:\n\tmutex_unlock(&ei->req_mlock);\n\treturn ret;\n}\n\n \nint hte_disable_ts(struct hte_ts_desc *desc)\n{\n\treturn hte_ts_dis_en_common(desc, false);\n}\nEXPORT_SYMBOL_GPL(hte_disable_ts);\n\n \nint hte_enable_ts(struct hte_ts_desc *desc)\n{\n\treturn hte_ts_dis_en_common(desc, true);\n}\nEXPORT_SYMBOL_GPL(hte_enable_ts);\n\nstatic void hte_do_cb_work(struct work_struct *w)\n{\n\tunsigned long flag;\n\tstruct hte_ts_info *ei = container_of(w, struct hte_ts_info, cb_work);\n\n\tif (unlikely(!ei->tcb))\n\t\treturn;\n\n\tei->tcb(ei->cl_data);\n\n\tspin_lock_irqsave(&ei->slock, flag);\n\tclear_bit(HTE_TS_QUEUE_WK, &ei->flags);\n\tspin_unlock_irqrestore(&ei->slock, flag);\n}\n\nstatic int __hte_req_ts(struct hte_ts_desc *desc, hte_ts_cb_t cb,\n\t\t\thte_ts_sec_cb_t tcb, void *data)\n{\n\tint ret;\n\tstruct hte_device *gdev;\n\tstruct hte_ts_info *ei = desc->hte_data;\n\n\tgdev = ei->gdev;\n\t \n\tmutex_lock(&ei->req_mlock);\n\n\tif (test_bit(HTE_TS_REGISTERED, &ei->flags) ||\n\t    !test_bit(HTE_TS_REQ, &ei->flags)) {\n\t\tdev_dbg(gdev->chip->dev, \"id:%u req failed\\n\",\n\t\t\tdesc->attr.line_id);\n\t\tret = -EUSERS;\n\t\tgoto unlock;\n\t}\n\n\tei->cb = cb;\n\tei->tcb = tcb;\n\tif (tcb)\n\t\tINIT_WORK(&ei->cb_work, hte_do_cb_work);\n\n\tret = gdev->chip->ops->request(gdev->chip, desc, ei->xlated_id);\n\tif (ret < 0) {\n\t\tdev_err(gdev->chip->dev, \"ts request failed\\n\");\n\t\tgoto unlock;\n\t}\n\n\tei->cl_data = data;\n\tei->seq = 1;\n\n\tatomic_inc(&gdev->ts_req);\n\n\tei->line_name = NULL;\n\tif (!desc->attr.name) {\n\t\tei->line_name = kzalloc(HTE_TS_NAME_LEN, GFP_KERNEL);\n\t\tif (ei->line_name)\n\t\t\tscnprintf(ei->line_name, HTE_TS_NAME_LEN, \"ts_%u\",\n\t\t\t\t  desc->attr.line_id);\n\t}\n\n\thte_ts_dbgfs_init(desc->attr.name == NULL ?\n\t\t\t  ei->line_name : desc->attr.name, ei);\n\tset_bit(HTE_TS_REGISTERED, &ei->flags);\n\n\tdev_dbg(gdev->chip->dev, \"id: %u, xlated id:%u\",\n\t\tdesc->attr.line_id, ei->xlated_id);\n\n\tret = 0;\n\nunlock:\n\tmutex_unlock(&ei->req_mlock);\n\n\treturn ret;\n}\n\nstatic int hte_bind_ts_info_locked(struct hte_ts_info *ei,\n\t\t\t\t   struct hte_ts_desc *desc, u32 x_id)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ei->req_mlock);\n\n\tif (test_bit(HTE_TS_REQ, &ei->flags)) {\n\t\tdev_dbg(ei->gdev->chip->dev, \"id:%u is already requested\\n\",\n\t\t\tdesc->attr.line_id);\n\t\tret = -EUSERS;\n\t\tgoto out;\n\t}\n\n\tset_bit(HTE_TS_REQ, &ei->flags);\n\tdesc->hte_data = ei;\n\tei->xlated_id = x_id;\n\nout:\n\tmutex_unlock(&ei->req_mlock);\n\n\treturn ret;\n}\n\nstatic struct hte_device *of_node_to_htedevice(struct device_node *np)\n{\n\tstruct hte_device *gdev;\n\n\tspin_lock(&hte_lock);\n\n\tlist_for_each_entry(gdev, &hte_devices, list)\n\t\tif (gdev->chip && gdev->chip->dev &&\n\t\t    device_match_of_node(gdev->chip->dev, np)) {\n\t\t\tspin_unlock(&hte_lock);\n\t\t\treturn gdev;\n\t\t}\n\n\tspin_unlock(&hte_lock);\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic struct hte_device *hte_find_dev_from_linedata(struct hte_ts_desc *desc)\n{\n\tstruct hte_device *gdev;\n\n\tspin_lock(&hte_lock);\n\n\tlist_for_each_entry(gdev, &hte_devices, list)\n\t\tif (gdev->chip && gdev->chip->match_from_linedata) {\n\t\t\tif (!gdev->chip->match_from_linedata(gdev->chip, desc))\n\t\t\t\tcontinue;\n\t\t\tspin_unlock(&hte_lock);\n\t\t\treturn gdev;\n\t\t}\n\n\tspin_unlock(&hte_lock);\n\n\treturn ERR_PTR(-ENODEV);\n}\n\n \nint of_hte_req_count(struct device *dev)\n{\n\tint count;\n\n\tif (!dev || !dev->of_node)\n\t\treturn -EINVAL;\n\n\tcount = of_count_phandle_with_args(dev->of_node, \"timestamps\",\n\t\t\t\t\t   \"#timestamp-cells\");\n\n\treturn count ? count : -ENOENT;\n}\nEXPORT_SYMBOL_GPL(of_hte_req_count);\n\nstatic inline struct hte_device *hte_get_dev(struct hte_ts_desc *desc)\n{\n\treturn hte_find_dev_from_linedata(desc);\n}\n\nstatic struct hte_device *hte_of_get_dev(struct device *dev,\n\t\t\t\t\t struct hte_ts_desc *desc,\n\t\t\t\t\t int index,\n\t\t\t\t\t struct of_phandle_args *args,\n\t\t\t\t\t bool *free_name)\n{\n\tint ret;\n\tstruct device_node *np;\n\tchar *temp;\n\n\tif (!dev->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnp = dev->of_node;\n\n\tif (!of_property_present(np, \"timestamp-names\")) {\n\t\t \n\t\tdesc->attr.name = NULL;\n\t} else {\n\t\tret = of_property_read_string_index(np, \"timestamp-names\",\n\t\t\t\t\t\t    index, &desc->attr.name);\n\t\tif (ret) {\n\t\t\tpr_err(\"can't parse \\\"timestamp-names\\\" property\\n\");\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t\t*free_name = false;\n\t\tif (desc->attr.name) {\n\t\t\ttemp = skip_spaces(desc->attr.name);\n\t\t\tif (!*temp)\n\t\t\t\tdesc->attr.name = NULL;\n\t\t}\n\t}\n\n\tret = of_parse_phandle_with_args(np, \"timestamps\", \"#timestamp-cells\",\n\t\t\t\t\t index, args);\n\tif (ret) {\n\t\tpr_err(\"%s(): can't parse \\\"timestamps\\\" property\\n\",\n\t\t       __func__);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tof_node_put(args->np);\n\n\treturn of_node_to_htedevice(args->np);\n}\n\n \nint hte_ts_get(struct device *dev, struct hte_ts_desc *desc, int index)\n{\n\tstruct hte_device *gdev;\n\tstruct hte_ts_info *ei;\n\tconst struct fwnode_handle *fwnode;\n\tstruct of_phandle_args args;\n\tu32 xlated_id;\n\tint ret;\n\tbool free_name = false;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tfwnode = dev ? dev_fwnode(dev) : NULL;\n\n\tif (is_of_node(fwnode))\n\t\tgdev = hte_of_get_dev(dev, desc, index, &args, &free_name);\n\telse\n\t\tgdev = hte_get_dev(desc);\n\n\tif (IS_ERR(gdev)) {\n\t\tpr_err(\"%s() no hte dev found\\n\", __func__);\n\t\treturn PTR_ERR(gdev);\n\t}\n\n\tif (!try_module_get(gdev->owner))\n\t\treturn -ENODEV;\n\n\tif (!gdev->chip) {\n\t\tpr_err(\"%s(): requested id does not have provider\\n\",\n\t\t       __func__);\n\t\tret = -ENODEV;\n\t\tgoto put;\n\t}\n\n\tif (is_of_node(fwnode)) {\n\t\tif (!gdev->chip->xlate_of)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = gdev->chip->xlate_of(gdev->chip, &args,\n\t\t\t\t\t\t   desc, &xlated_id);\n\t} else {\n\t\tif (!gdev->chip->xlate_plat)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = gdev->chip->xlate_plat(gdev->chip, desc,\n\t\t\t\t\t\t     &xlated_id);\n\t}\n\n\tif (ret < 0)\n\t\tgoto put;\n\n\tei = &gdev->ei[xlated_id];\n\n\tret = hte_bind_ts_info_locked(ei, desc, xlated_id);\n\tif (ret)\n\t\tgoto put;\n\n\tei->free_attr_name = free_name;\n\n\treturn 0;\n\nput:\n\tmodule_put(gdev->owner);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hte_ts_get);\n\nstatic void __devm_hte_release_ts(void *res)\n{\n\thte_ts_put(res);\n}\n\n \nint hte_request_ts_ns(struct hte_ts_desc *desc, hte_ts_cb_t cb,\n\t\t      hte_ts_sec_cb_t tcb, void *data)\n{\n\tint ret;\n\tstruct hte_ts_info *ei;\n\n\tif (!desc || !desc->hte_data || !cb)\n\t\treturn -EINVAL;\n\n\tei = desc->hte_data;\n\tif (!ei || !ei->gdev)\n\t\treturn -EINVAL;\n\n\tret = __hte_req_ts(desc, cb, tcb, data);\n\tif (ret < 0) {\n\t\tdev_err(ei->gdev->chip->dev,\n\t\t\t\"failed to request id: %d\\n\", desc->attr.line_id);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hte_request_ts_ns);\n\n \nint devm_hte_request_ts_ns(struct device *dev, struct hte_ts_desc *desc,\n\t\t\t   hte_ts_cb_t cb, hte_ts_sec_cb_t tcb,\n\t\t\t   void *data)\n{\n\tint err;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\terr = hte_request_ts_ns(desc, cb, tcb, data);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_add_action_or_reset(dev, __devm_hte_release_ts, desc);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_hte_request_ts_ns);\n\n \nint hte_init_line_attr(struct hte_ts_desc *desc, u32 line_id,\n\t\t       unsigned long edge_flags, const char *name, void *data)\n{\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tmemset(&desc->attr, 0, sizeof(desc->attr));\n\n\tdesc->attr.edge_flags = edge_flags;\n\tdesc->attr.line_id = line_id;\n\tdesc->attr.line_data = data;\n\tif (name) {\n\t\tname =  kstrdup_const(name, GFP_KERNEL);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tdesc->attr.name = name;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hte_init_line_attr);\n\n \nint hte_get_clk_src_info(const struct hte_ts_desc *desc,\n\t\t\t struct hte_clk_info *ci)\n{\n\tstruct hte_chip *chip;\n\tstruct hte_ts_info *ei;\n\n\tif (!desc || !desc->hte_data || !ci) {\n\t\tpr_debug(\"%s:%d\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\n\tei = desc->hte_data;\n\tif (!ei->gdev || !ei->gdev->chip)\n\t\treturn -EINVAL;\n\n\tchip = ei->gdev->chip;\n\tif (!chip->ops->get_clk_src_info)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chip->ops->get_clk_src_info(chip, ci);\n}\nEXPORT_SYMBOL_GPL(hte_get_clk_src_info);\n\n \nint hte_push_ts_ns(const struct hte_chip *chip, u32 xlated_id,\n\t\t   struct hte_ts_data *data)\n{\n\tenum hte_return ret;\n\tint st = 0;\n\tstruct hte_ts_info *ei;\n\tunsigned long flag;\n\n\tif (!chip || !data || !chip->gdev)\n\t\treturn -EINVAL;\n\n\tif (xlated_id >= chip->nlines)\n\t\treturn -EINVAL;\n\n\tei = &chip->gdev->ei[xlated_id];\n\n\tspin_lock_irqsave(&ei->slock, flag);\n\n\t \n\tdata->seq = ei->seq++;\n\n\tif (!test_bit(HTE_TS_REGISTERED, &ei->flags) ||\n\t    test_bit(HTE_TS_DISABLE, &ei->flags)) {\n\t\tdev_dbg(chip->dev, \"Unknown timestamp push\\n\");\n\t\tatomic_inc(&ei->dropped_ts);\n\t\tst = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tret = ei->cb(data, ei->cl_data);\n\tif (ret == HTE_RUN_SECOND_CB && ei->tcb) {\n\t\tqueue_work(system_unbound_wq, &ei->cb_work);\n\t\tset_bit(HTE_TS_QUEUE_WK, &ei->flags);\n\t}\n\nunlock:\n\tspin_unlock_irqrestore(&ei->slock, flag);\n\n\treturn st;\n}\nEXPORT_SYMBOL_GPL(hte_push_ts_ns);\n\nstatic int hte_register_chip(struct hte_chip *chip)\n{\n\tstruct hte_device *gdev;\n\tu32 i;\n\n\tif (!chip || !chip->dev || !chip->dev->of_node)\n\t\treturn -EINVAL;\n\n\tif (!chip->ops || !chip->ops->request || !chip->ops->release) {\n\t\tdev_err(chip->dev, \"Driver needs to provide ops\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgdev = kzalloc(struct_size(gdev, ei, chip->nlines), GFP_KERNEL);\n\tif (!gdev)\n\t\treturn -ENOMEM;\n\n\tgdev->chip = chip;\n\tchip->gdev = gdev;\n\tgdev->nlines = chip->nlines;\n\tgdev->sdev = chip->dev;\n\n\tfor (i = 0; i < chip->nlines; i++) {\n\t\tgdev->ei[i].gdev = gdev;\n\t\tmutex_init(&gdev->ei[i].req_mlock);\n\t\tspin_lock_init(&gdev->ei[i].slock);\n\t}\n\n\tif (chip->dev->driver)\n\t\tgdev->owner = chip->dev->driver->owner;\n\telse\n\t\tgdev->owner = THIS_MODULE;\n\n\tof_node_get(chip->dev->of_node);\n\n\tINIT_LIST_HEAD(&gdev->list);\n\n\tspin_lock(&hte_lock);\n\tlist_add_tail(&gdev->list, &hte_devices);\n\tspin_unlock(&hte_lock);\n\n\thte_chip_dbgfs_init(gdev);\n\n\tdev_dbg(chip->dev, \"Added hte chip\\n\");\n\n\treturn 0;\n}\n\nstatic int hte_unregister_chip(struct hte_chip *chip)\n{\n\tstruct hte_device *gdev;\n\n\tif (!chip)\n\t\treturn -EINVAL;\n\n\tgdev = chip->gdev;\n\n\tspin_lock(&hte_lock);\n\tlist_del(&gdev->list);\n\tspin_unlock(&hte_lock);\n\n\tgdev->chip = NULL;\n\n\tof_node_put(chip->dev->of_node);\n\tdebugfs_remove_recursive(gdev->dbg_root);\n\tkfree(gdev);\n\n\tdev_dbg(chip->dev, \"Removed hte chip\\n\");\n\n\treturn 0;\n}\n\nstatic void _hte_devm_unregister_chip(void *chip)\n{\n\thte_unregister_chip(chip);\n}\n\n \nint devm_hte_register_chip(struct hte_chip *chip)\n{\n\tint err;\n\n\terr = hte_register_chip(chip);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_add_action_or_reset(chip->dev, _hte_devm_unregister_chip,\n\t\t\t\t       chip);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_hte_register_chip);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}