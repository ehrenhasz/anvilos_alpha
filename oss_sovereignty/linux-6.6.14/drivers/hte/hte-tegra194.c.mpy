{
  "module_name": "hte-tegra194.c",
  "hash_id": "92186b8a5caebfb42811848623d9fb7111027a197aa6aef94844bebfe31dcf32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hte/hte-tegra194.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/hte.h>\n#include <linux/uaccess.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/consumer.h>\n\n#define HTE_SUSPEND\t0\n\n \n#define HTE_TS_CLK_RATE_HZ\t31250000ULL\n#define HTE_CLK_RATE_NS\t\t32\n#define HTE_TS_NS_SHIFT\t__builtin_ctz(HTE_CLK_RATE_NS)\n\n#define NV_AON_SLICE_INVALID\t-1\n#define NV_LINES_IN_SLICE\t32\n\n \n#define NV_AON_HTE_SLICE1_IRQ_GPIO_28\t12\n#define NV_AON_HTE_SLICE1_IRQ_GPIO_29\t13\n\n \n#define NV_AON_HTE_SLICE2_IRQ_GPIO_0\t0\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_1\t1\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_2\t2\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_3\t3\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_4\t4\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_5\t5\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_6\t6\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_7\t7\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_8\t8\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_9\t9\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_10\t10\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_11\t11\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_12\t12\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_13\t13\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_14\t14\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_15\t15\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_16\t16\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_17\t17\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_18\t18\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_19\t19\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_20\t20\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_21\t21\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_22\t22\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_23\t23\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_24\t24\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_25\t25\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_26\t26\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_27\t27\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_28\t28\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_29\t29\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_30\t30\n#define NV_AON_HTE_SLICE2_IRQ_GPIO_31\t31\n\n#define HTE_TECTRL\t\t0x0\n#define HTE_TETSCH\t\t0x4\n#define HTE_TETSCL\t\t0x8\n#define HTE_TESRC\t\t0xC\n#define HTE_TECCV\t\t0x10\n#define HTE_TEPCV\t\t0x14\n#define HTE_TECMD\t\t0x1C\n#define HTE_TESTATUS\t\t0x20\n#define HTE_SLICE0_TETEN\t0x40\n#define HTE_SLICE1_TETEN\t0x60\n\n#define HTE_SLICE_SIZE\t\t(HTE_SLICE1_TETEN - HTE_SLICE0_TETEN)\n\n#define HTE_TECTRL_ENABLE_ENABLE\t0x1\n\n#define HTE_TECTRL_OCCU_SHIFT\t\t0x8\n#define HTE_TECTRL_INTR_SHIFT\t\t0x1\n#define HTE_TECTRL_INTR_ENABLE\t\t0x1\n\n#define HTE_TESRC_SLICE_SHIFT\t\t16\n#define HTE_TESRC_SLICE_DEFAULT_MASK\t0xFF\n\n#define HTE_TECMD_CMD_POP\t\t0x1\n\n#define HTE_TESTATUS_OCCUPANCY_SHIFT\t8\n#define HTE_TESTATUS_OCCUPANCY_MASK\t0xFF\n\nenum tegra_hte_type {\n\tHTE_TEGRA_TYPE_GPIO = 1U << 0,\n\tHTE_TEGRA_TYPE_LIC = 1U << 1,\n};\n\nstruct hte_slices {\n\tu32 r_val;\n\tunsigned long flags;\n\t \n\tspinlock_t s_lock;\n};\n\nstruct tegra_hte_line_mapped {\n\tint slice;\n\tu32 bit_index;\n};\n\nstruct tegra_hte_line_data {\n\tunsigned long flags;\n\tvoid *data;\n};\n\nstruct tegra_hte_data {\n\tenum tegra_hte_type type;\n\tu32 slices;\n\tu32 map_sz;\n\tu32 sec_map_sz;\n\tconst struct tegra_hte_line_mapped *map;\n\tconst struct tegra_hte_line_mapped *sec_map;\n};\n\nstruct tegra_hte_soc {\n\tint hte_irq;\n\tu32 itr_thrshld;\n\tu32 conf_rval;\n\tstruct hte_slices *sl;\n\tconst struct tegra_hte_data *prov_data;\n\tstruct tegra_hte_line_data *line_data;\n\tstruct hte_chip *chip;\n\tstruct gpio_chip *c;\n\tvoid __iomem *regs;\n};\n\nstatic const struct tegra_hte_line_mapped tegra194_aon_gpio_map[] = {\n\t \n\t \n\t[0]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_11},\n\t[1]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_10},\n\t[2]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_9},\n\t[3]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_8},\n\t[4]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_7},\n\t[5]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_6},\n\t[6]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_5},\n\t[7]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_4},\n\t \n\t[8]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_3},\n\t[9]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_2},\n\t[10] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_1},\n\t[11] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_0},\n\t \n\t[12] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_22},\n\t[13] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_21},\n\t[14] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_20},\n\t[15] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_19},\n\t[16] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_18},\n\t[17] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_17},\n\t[18] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_16},\n\t[19] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_15},\n\t \n\t[20] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_14},\n\t[21] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_13},\n\t[22] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_12},\n\t \n\t[23] = {1, NV_AON_HTE_SLICE1_IRQ_GPIO_29},\n\t[24] = {1, NV_AON_HTE_SLICE1_IRQ_GPIO_28},\n\t[25] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_27},\n\t[26] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_26},\n\t[27] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_25},\n\t[28] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_24},\n\t[29] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_23},\n};\n\nstatic const struct tegra_hte_line_mapped tegra194_aon_gpio_sec_map[] = {\n\t \n\t \n\t[0]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_11},\n\t[1]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_10},\n\t[2]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_9},\n\t[3]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_8},\n\t[4]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_7},\n\t[5]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_6},\n\t[6]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_5},\n\t[7]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_4},\n\t \n\t[8]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_3},\n\t[9]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_2},\n\t[10] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_1},\n\t[11] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_0},\n\t[12]  = {NV_AON_SLICE_INVALID, 0},\n\t[13]  = {NV_AON_SLICE_INVALID, 0},\n\t[14] = {NV_AON_SLICE_INVALID, 0},\n\t[15] = {NV_AON_SLICE_INVALID, 0},\n\t \n\t[16] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_22},\n\t[17] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_21},\n\t[18] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_20},\n\t[19] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_19},\n\t[20] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_18},\n\t[21] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_17},\n\t[22] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_16},\n\t[23] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_15},\n\t \n\t[24] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_14},\n\t[25] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_13},\n\t[26] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_12},\n\t[27] = {NV_AON_SLICE_INVALID, 0},\n\t[28] = {NV_AON_SLICE_INVALID, 0},\n\t[29] = {NV_AON_SLICE_INVALID, 0},\n\t[30] = {NV_AON_SLICE_INVALID, 0},\n\t[31] = {NV_AON_SLICE_INVALID, 0},\n\t \n\t[32] = {1, NV_AON_HTE_SLICE1_IRQ_GPIO_29},\n\t[33] = {1, NV_AON_HTE_SLICE1_IRQ_GPIO_28},\n\t[34] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_27},\n\t[35] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_26},\n\t[36] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_25},\n\t[37] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_24},\n\t[38] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_23},\n\t[39] = {NV_AON_SLICE_INVALID, 0},\n};\n\nstatic const struct tegra_hte_line_mapped tegra234_aon_gpio_map[] = {\n\t \n\t \n\t[0]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_11},\n\t[1]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_10},\n\t[2]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_9},\n\t[3]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_8},\n\t[4]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_7},\n\t[5]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_6},\n\t[6]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_5},\n\t[7]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_4},\n\t \n\t[8]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_3},\n\t[9]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_2},\n\t[10] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_1},\n\t[11] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_0},\n\t \n\t[12] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_22},\n\t[13] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_21},\n\t[14] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_20},\n\t[15] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_19},\n\t[16] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_18},\n\t[17] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_17},\n\t[18] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_16},\n\t[19] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_15},\n\t \n\t[20] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_14},\n\t[21] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_13},\n\t[22] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_12},\n\t \n\t[23] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_31},\n\t[24] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_30},\n\t[25] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_29},\n\t[26] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_28},\n\t[27] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_27},\n\t[28] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_26},\n\t[29] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_25},\n\t[30] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_24},\n\t \n\t[31] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_23},\n};\n\nstatic const struct tegra_hte_line_mapped tegra234_aon_gpio_sec_map[] = {\n\t \n\t \n\t[0]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_11},\n\t[1]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_10},\n\t[2]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_9},\n\t[3]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_8},\n\t[4]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_7},\n\t[5]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_6},\n\t[6]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_5},\n\t[7]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_4},\n\t \n\t[8]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_3},\n\t[9]  = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_2},\n\t[10] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_1},\n\t[11] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_0},\n\t[12] = {NV_AON_SLICE_INVALID, 0},\n\t[13] = {NV_AON_SLICE_INVALID, 0},\n\t[14] = {NV_AON_SLICE_INVALID, 0},\n\t[15] = {NV_AON_SLICE_INVALID, 0},\n\t \n\t[16] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_22},\n\t[17] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_21},\n\t[18] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_20},\n\t[19] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_19},\n\t[20] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_18},\n\t[21] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_17},\n\t[22] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_16},\n\t[23] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_15},\n\t \n\t[24] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_14},\n\t[25] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_13},\n\t[26] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_12},\n\t[27] = {NV_AON_SLICE_INVALID, 0},\n\t[28] = {NV_AON_SLICE_INVALID, 0},\n\t[29] = {NV_AON_SLICE_INVALID, 0},\n\t[30] = {NV_AON_SLICE_INVALID, 0},\n\t[31] = {NV_AON_SLICE_INVALID, 0},\n\t \n\t[32] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_31},\n\t[33] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_30},\n\t[34] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_29},\n\t[35] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_28},\n\t[36] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_27},\n\t[37] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_26},\n\t[38] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_25},\n\t[39] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_24},\n\t \n\t[40] = {2, NV_AON_HTE_SLICE2_IRQ_GPIO_23},\n};\n\nstatic const struct tegra_hte_data t194_aon_hte = {\n\t.map_sz = ARRAY_SIZE(tegra194_aon_gpio_map),\n\t.map = tegra194_aon_gpio_map,\n\t.sec_map_sz = ARRAY_SIZE(tegra194_aon_gpio_sec_map),\n\t.sec_map = tegra194_aon_gpio_sec_map,\n\t.type = HTE_TEGRA_TYPE_GPIO,\n\t.slices = 3,\n};\n\nstatic const struct tegra_hte_data t234_aon_hte = {\n\t.map_sz = ARRAY_SIZE(tegra234_aon_gpio_map),\n\t.map = tegra234_aon_gpio_map,\n\t.sec_map_sz = ARRAY_SIZE(tegra234_aon_gpio_sec_map),\n\t.sec_map = tegra234_aon_gpio_sec_map,\n\t.type = HTE_TEGRA_TYPE_GPIO,\n\t.slices = 3,\n};\n\nstatic const struct tegra_hte_data t194_lic_hte = {\n\t.map_sz = 0,\n\t.map = NULL,\n\t.type = HTE_TEGRA_TYPE_LIC,\n\t.slices = 11,\n};\n\nstatic const struct tegra_hte_data t234_lic_hte = {\n\t.map_sz = 0,\n\t.map = NULL,\n\t.type = HTE_TEGRA_TYPE_LIC,\n\t.slices = 17,\n};\n\nstatic inline u32 tegra_hte_readl(struct tegra_hte_soc *hte, u32 reg)\n{\n\treturn readl(hte->regs + reg);\n}\n\nstatic inline void tegra_hte_writel(struct tegra_hte_soc *hte, u32 reg,\n\t\t\t\t    u32 val)\n{\n\twritel(val, hte->regs + reg);\n}\n\nstatic int tegra_hte_map_to_line_id(u32 eid,\n\t\t\t\t    const struct tegra_hte_line_mapped *m,\n\t\t\t\t    u32 map_sz, u32 *mapped)\n{\n\n\tif (m) {\n\t\tif (eid >= map_sz)\n\t\t\treturn -EINVAL;\n\t\tif (m[eid].slice == NV_AON_SLICE_INVALID)\n\t\t\treturn -EINVAL;\n\n\t\t*mapped = (m[eid].slice << 5) + m[eid].bit_index;\n\t} else {\n\t\t*mapped = eid;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_hte_line_xlate(struct hte_chip *gc,\n\t\t\t\tconst struct of_phandle_args *args,\n\t\t\t\tstruct hte_ts_desc *desc, u32 *xlated_id)\n{\n\tint ret = 0;\n\tu32 line_id;\n\tstruct tegra_hte_soc *gs;\n\tconst struct tegra_hte_line_mapped *map = NULL;\n\tu32 map_sz = 0;\n\n\tif (!gc || !desc || !xlated_id)\n\t\treturn -EINVAL;\n\n\tif (args) {\n\t\tif (gc->of_hte_n_cells < 1)\n\t\t\treturn -EINVAL;\n\n\t\tif (args->args_count != gc->of_hte_n_cells)\n\t\t\treturn -EINVAL;\n\n\t\tdesc->attr.line_id = args->args[0];\n\t}\n\n\tgs = gc->data;\n\tif (!gs || !gs->prov_data)\n\t\treturn -EINVAL;\n\n\t \n\tif (gs->prov_data->type == HTE_TEGRA_TYPE_GPIO && !args) {\n\t\tline_id = desc->attr.line_id - gs->c->base;\n\t\tmap = gs->prov_data->map;\n\t\tmap_sz = gs->prov_data->map_sz;\n\t} else if (gs->prov_data->type == HTE_TEGRA_TYPE_GPIO && args) {\n\t\tline_id = desc->attr.line_id;\n\t\tmap = gs->prov_data->sec_map;\n\t\tmap_sz = gs->prov_data->sec_map_sz;\n\t} else {\n\t\tline_id = desc->attr.line_id;\n\t}\n\n\tret = tegra_hte_map_to_line_id(line_id, map, map_sz, xlated_id);\n\tif (ret < 0) {\n\t\tdev_err(gc->dev, \"line_id:%u mapping failed\\n\",\n\t\t\tdesc->attr.line_id);\n\t\treturn ret;\n\t}\n\n\tif (*xlated_id > gc->nlines)\n\t\treturn -EINVAL;\n\n\tdev_dbg(gc->dev, \"requested id:%u, xlated id:%u\\n\",\n\t\tdesc->attr.line_id, *xlated_id);\n\n\treturn 0;\n}\n\nstatic int tegra_hte_line_xlate_plat(struct hte_chip *gc,\n\t\t\t\t     struct hte_ts_desc *desc, u32 *xlated_id)\n{\n\treturn tegra_hte_line_xlate(gc, NULL, desc, xlated_id);\n}\n\nstatic int tegra_hte_en_dis_common(struct hte_chip *chip, u32 line_id, bool en)\n{\n\tu32 slice, sl_bit_shift, line_bit, val, reg;\n\tstruct tegra_hte_soc *gs;\n\n\tsl_bit_shift = __builtin_ctz(HTE_SLICE_SIZE);\n\n\tif (!chip)\n\t\treturn -EINVAL;\n\n\tgs = chip->data;\n\n\tif (line_id > chip->nlines) {\n\t\tdev_err(chip->dev,\n\t\t\t\"line id: %u is not supported by this controller\\n\",\n\t\t\tline_id);\n\t\treturn -EINVAL;\n\t}\n\n\tslice = line_id >> sl_bit_shift;\n\tline_bit = line_id & (HTE_SLICE_SIZE - 1);\n\treg = (slice << sl_bit_shift) + HTE_SLICE0_TETEN;\n\n\tspin_lock(&gs->sl[slice].s_lock);\n\n\tif (test_bit(HTE_SUSPEND, &gs->sl[slice].flags)) {\n\t\tspin_unlock(&gs->sl[slice].s_lock);\n\t\tdev_dbg(chip->dev, \"device suspended\");\n\t\treturn -EBUSY;\n\t}\n\n\tval = tegra_hte_readl(gs, reg);\n\tif (en)\n\t\tval = val | (1 << line_bit);\n\telse\n\t\tval = val & (~(1 << line_bit));\n\ttegra_hte_writel(gs, reg, val);\n\n\tspin_unlock(&gs->sl[slice].s_lock);\n\n\tdev_dbg(chip->dev, \"line: %u, slice %u, line_bit %u, reg:0x%x\\n\",\n\t\tline_id, slice, line_bit, reg);\n\n\treturn 0;\n}\n\nstatic int tegra_hte_enable(struct hte_chip *chip, u32 line_id)\n{\n\tif (!chip)\n\t\treturn -EINVAL;\n\n\treturn tegra_hte_en_dis_common(chip, line_id, true);\n}\n\nstatic int tegra_hte_disable(struct hte_chip *chip, u32 line_id)\n{\n\tif (!chip)\n\t\treturn -EINVAL;\n\n\treturn tegra_hte_en_dis_common(chip, line_id, false);\n}\n\nstatic int tegra_hte_request(struct hte_chip *chip, struct hte_ts_desc *desc,\n\t\t\t     u32 line_id)\n{\n\tint ret;\n\tstruct tegra_hte_soc *gs;\n\tstruct hte_line_attr *attr;\n\n\tif (!chip || !chip->data || !desc)\n\t\treturn -EINVAL;\n\n\tgs = chip->data;\n\tattr = &desc->attr;\n\n\tif (gs->prov_data->type == HTE_TEGRA_TYPE_GPIO) {\n\t\tif (!attr->line_data)\n\t\t\treturn -EINVAL;\n\n\t\tret = gpiod_enable_hw_timestamp_ns(attr->line_data,\n\t\t\t\t\t\t   attr->edge_flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tgs->line_data[line_id].data = attr->line_data;\n\t\tgs->line_data[line_id].flags = attr->edge_flags;\n\t}\n\n\treturn tegra_hte_en_dis_common(chip, line_id, true);\n}\n\nstatic int tegra_hte_release(struct hte_chip *chip, struct hte_ts_desc *desc,\n\t\t\t     u32 line_id)\n{\n\tstruct tegra_hte_soc *gs;\n\tstruct hte_line_attr *attr;\n\tint ret;\n\n\tif (!chip || !chip->data || !desc)\n\t\treturn -EINVAL;\n\n\tgs = chip->data;\n\tattr = &desc->attr;\n\n\tif (gs->prov_data->type == HTE_TEGRA_TYPE_GPIO) {\n\t\tret = gpiod_disable_hw_timestamp_ns(attr->line_data,\n\t\t\t\t\t\t    gs->line_data[line_id].flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tgs->line_data[line_id].data = NULL;\n\t\tgs->line_data[line_id].flags = 0;\n\t}\n\n\treturn tegra_hte_en_dis_common(chip, line_id, false);\n}\n\nstatic int tegra_hte_clk_src_info(struct hte_chip *chip,\n\t\t\t\t  struct hte_clk_info *ci)\n{\n\t(void)chip;\n\n\tif (!ci)\n\t\treturn -EINVAL;\n\n\tci->hz = HTE_TS_CLK_RATE_HZ;\n\tci->type = CLOCK_MONOTONIC;\n\n\treturn 0;\n}\n\nstatic int tegra_hte_get_level(struct tegra_hte_soc *gs, u32 line_id)\n{\n\tstruct gpio_desc *desc;\n\n\tif (gs->prov_data->type == HTE_TEGRA_TYPE_GPIO) {\n\t\tdesc = gs->line_data[line_id].data;\n\t\tif (desc)\n\t\t\treturn gpiod_get_raw_value(desc);\n\t}\n\n\treturn -1;\n}\n\nstatic void tegra_hte_read_fifo(struct tegra_hte_soc *gs)\n{\n\tu32 tsh, tsl, src, pv, cv, acv, slice, bit_index, line_id;\n\tu64 tsc;\n\tstruct hte_ts_data el;\n\n\twhile ((tegra_hte_readl(gs, HTE_TESTATUS) >>\n\t\tHTE_TESTATUS_OCCUPANCY_SHIFT) &\n\t\tHTE_TESTATUS_OCCUPANCY_MASK) {\n\t\ttsh = tegra_hte_readl(gs, HTE_TETSCH);\n\t\ttsl = tegra_hte_readl(gs, HTE_TETSCL);\n\t\ttsc = (((u64)tsh << 32) | tsl);\n\n\t\tsrc = tegra_hte_readl(gs, HTE_TESRC);\n\t\tslice = (src >> HTE_TESRC_SLICE_SHIFT) &\n\t\t\t    HTE_TESRC_SLICE_DEFAULT_MASK;\n\n\t\tpv = tegra_hte_readl(gs, HTE_TEPCV);\n\t\tcv = tegra_hte_readl(gs, HTE_TECCV);\n\t\tacv = pv ^ cv;\n\t\twhile (acv) {\n\t\t\tbit_index = __builtin_ctz(acv);\n\t\t\tline_id = bit_index + (slice << 5);\n\t\t\tel.tsc = tsc << HTE_TS_NS_SHIFT;\n\t\t\tel.raw_level = tegra_hte_get_level(gs, line_id);\n\t\t\thte_push_ts_ns(gs->chip, line_id, &el);\n\t\t\tacv &= ~BIT(bit_index);\n\t\t}\n\t\ttegra_hte_writel(gs, HTE_TECMD, HTE_TECMD_CMD_POP);\n\t}\n}\n\nstatic irqreturn_t tegra_hte_isr(int irq, void *dev_id)\n{\n\tstruct tegra_hte_soc *gs = dev_id;\n\t(void)irq;\n\n\ttegra_hte_read_fifo(gs);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool tegra_hte_match_from_linedata(const struct hte_chip *chip,\n\t\t\t\t\t  const struct hte_ts_desc *hdesc)\n{\n\tstruct tegra_hte_soc *hte_dev = chip->data;\n\n\tif (!hte_dev || (hte_dev->prov_data->type != HTE_TEGRA_TYPE_GPIO))\n\t\treturn false;\n\n\treturn hte_dev->c == gpiod_to_chip(hdesc->attr.line_data);\n}\n\nstatic const struct of_device_id tegra_hte_of_match[] = {\n\t{ .compatible = \"nvidia,tegra194-gte-lic\", .data = &t194_lic_hte},\n\t{ .compatible = \"nvidia,tegra194-gte-aon\", .data = &t194_aon_hte},\n\t{ .compatible = \"nvidia,tegra234-gte-lic\", .data = &t234_lic_hte},\n\t{ .compatible = \"nvidia,tegra234-gte-aon\", .data = &t234_aon_hte},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_hte_of_match);\n\nstatic const struct hte_ops g_ops = {\n\t.request = tegra_hte_request,\n\t.release = tegra_hte_release,\n\t.enable = tegra_hte_enable,\n\t.disable = tegra_hte_disable,\n\t.get_clk_src_info = tegra_hte_clk_src_info,\n};\n\nstatic void tegra_gte_disable(void *data)\n{\n\tstruct platform_device *pdev = data;\n\tstruct tegra_hte_soc *gs = dev_get_drvdata(&pdev->dev);\n\n\ttegra_hte_writel(gs, HTE_TECTRL, 0);\n}\n\nstatic int tegra_get_gpiochip_from_name(struct gpio_chip *chip, void *data)\n{\n\treturn !strcmp(chip->label, data);\n}\n\nstatic int tegra_gpiochip_match(struct gpio_chip *chip, void *data)\n{\n\treturn chip->fwnode == of_node_to_fwnode(data);\n}\n\nstatic int tegra_hte_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tu32 i, slices, val = 0;\n\tu32 nlines;\n\tstruct device *dev;\n\tstruct tegra_hte_soc *hte_dev;\n\tstruct hte_chip *gc;\n\tstruct device_node *gpio_ctrl;\n\n\tdev = &pdev->dev;\n\n\thte_dev = devm_kzalloc(dev, sizeof(*hte_dev), GFP_KERNEL);\n\tif (!hte_dev)\n\t\treturn -ENOMEM;\n\n\tgc = devm_kzalloc(dev, sizeof(*gc), GFP_KERNEL);\n\tif (!gc)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&pdev->dev, hte_dev);\n\thte_dev->prov_data = of_device_get_match_data(&pdev->dev);\n\n\tret = of_property_read_u32(dev->of_node, \"nvidia,slices\", &slices);\n\tif (ret != 0)\n\t\tslices = hte_dev->prov_data->slices;\n\n\tdev_dbg(dev, \"slices:%d\\n\", slices);\n\tnlines = slices << 5;\n\n\thte_dev->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hte_dev->regs))\n\t\treturn PTR_ERR(hte_dev->regs);\n\n\tret = of_property_read_u32(dev->of_node, \"nvidia,int-threshold\",\n\t\t\t\t   &hte_dev->itr_thrshld);\n\tif (ret != 0)\n\t\thte_dev->itr_thrshld = 1;\n\n\thte_dev->sl = devm_kcalloc(dev, slices, sizeof(*hte_dev->sl),\n\t\t\t\t   GFP_KERNEL);\n\tif (!hte_dev->sl)\n\t\treturn -ENOMEM;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0) {\n\t\tdev_err_probe(dev, ret, \"failed to get irq\\n\");\n\t\treturn ret;\n\t}\n\thte_dev->hte_irq = ret;\n\tret = devm_request_irq(dev, hte_dev->hte_irq, tegra_hte_isr, 0,\n\t\t\t       dev_name(dev), hte_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"request irq failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tgc->nlines = nlines;\n\tgc->ops = &g_ops;\n\tgc->dev = dev;\n\tgc->data = hte_dev;\n\tgc->xlate_of = tegra_hte_line_xlate;\n\tgc->xlate_plat = tegra_hte_line_xlate_plat;\n\tgc->of_hte_n_cells = 1;\n\n\tif (hte_dev->prov_data &&\n\t    hte_dev->prov_data->type == HTE_TEGRA_TYPE_GPIO) {\n\t\thte_dev->line_data = devm_kcalloc(dev, nlines,\n\t\t\t\t\t\t  sizeof(*hte_dev->line_data),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!hte_dev->line_data)\n\t\t\treturn -ENOMEM;\n\n\t\tgc->match_from_linedata = tegra_hte_match_from_linedata;\n\n\t\tif (of_device_is_compatible(dev->of_node,\n\t\t\t\t\t    \"nvidia,tegra194-gte-aon\")) {\n\t\t\thte_dev->c = gpiochip_find(\"tegra194-gpio-aon\",\n\t\t\t\t\t\ttegra_get_gpiochip_from_name);\n\t\t} else {\n\t\t\tgpio_ctrl = of_parse_phandle(dev->of_node,\n\t\t\t\t\t\t     \"nvidia,gpio-controller\",\n\t\t\t\t\t\t     0);\n\t\t\tif (!gpio_ctrl) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"gpio controller node not found\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\thte_dev->c = gpiochip_find(gpio_ctrl,\n\t\t\t\t\t\t   tegra_gpiochip_match);\n\t\t\tof_node_put(gpio_ctrl);\n\t\t}\n\n\t\tif (!hte_dev->c)\n\t\t\treturn dev_err_probe(dev, -EPROBE_DEFER,\n\t\t\t\t\t     \"wait for gpio controller\\n\");\n\t}\n\n\thte_dev->chip = gc;\n\n\tret = devm_hte_register_chip(hte_dev->chip);\n\tif (ret) {\n\t\tdev_err(gc->dev, \"hte chip register failed\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < slices; i++) {\n\t\thte_dev->sl[i].flags = 0;\n\t\tspin_lock_init(&hte_dev->sl[i].s_lock);\n\t}\n\n\tval = HTE_TECTRL_ENABLE_ENABLE |\n\t      (HTE_TECTRL_INTR_ENABLE << HTE_TECTRL_INTR_SHIFT) |\n\t      (hte_dev->itr_thrshld << HTE_TECTRL_OCCU_SHIFT);\n\ttegra_hte_writel(hte_dev, HTE_TECTRL, val);\n\n\tret = devm_add_action_or_reset(&pdev->dev, tegra_gte_disable, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(gc->dev, \"lines: %d, slices:%d\", gc->nlines, slices);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_hte_resume_early(struct device *dev)\n{\n\tu32 i;\n\tstruct tegra_hte_soc *gs = dev_get_drvdata(dev);\n\tu32 slices = gs->chip->nlines / NV_LINES_IN_SLICE;\n\tu32 sl_bit_shift = __builtin_ctz(HTE_SLICE_SIZE);\n\n\ttegra_hte_writel(gs, HTE_TECTRL, gs->conf_rval);\n\n\tfor (i = 0; i < slices; i++) {\n\t\tspin_lock(&gs->sl[i].s_lock);\n\t\ttegra_hte_writel(gs,\n\t\t\t\t ((i << sl_bit_shift) + HTE_SLICE0_TETEN),\n\t\t\t\t gs->sl[i].r_val);\n\t\tclear_bit(HTE_SUSPEND, &gs->sl[i].flags);\n\t\tspin_unlock(&gs->sl[i].s_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_hte_suspend_late(struct device *dev)\n{\n\tu32 i;\n\tstruct tegra_hte_soc *gs = dev_get_drvdata(dev);\n\tu32 slices = gs->chip->nlines / NV_LINES_IN_SLICE;\n\tu32 sl_bit_shift = __builtin_ctz(HTE_SLICE_SIZE);\n\n\tgs->conf_rval = tegra_hte_readl(gs, HTE_TECTRL);\n\tfor (i = 0; i < slices; i++) {\n\t\tspin_lock(&gs->sl[i].s_lock);\n\t\tgs->sl[i].r_val = tegra_hte_readl(gs,\n\t\t\t\t((i << sl_bit_shift) + HTE_SLICE0_TETEN));\n\t\tset_bit(HTE_SUSPEND, &gs->sl[i].flags);\n\t\tspin_unlock(&gs->sl[i].s_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_hte_pm = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(tegra_hte_suspend_late,\n\t\t\t\t     tegra_hte_resume_early)\n};\n\nstatic struct platform_driver tegra_hte_driver = {\n\t.probe = tegra_hte_probe,\n\t.driver = {\n\t\t.name = \"tegra_hte\",\n\t\t.pm = &tegra_hte_pm,\n\t\t.of_match_table = tegra_hte_of_match,\n\t},\n};\n\nmodule_platform_driver(tegra_hte_driver);\n\nMODULE_AUTHOR(\"Dipen Patel <dipenp@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra HTE (Hardware Timestamping Engine) driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}