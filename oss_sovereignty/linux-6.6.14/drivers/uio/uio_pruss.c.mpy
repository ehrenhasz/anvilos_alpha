{
  "module_name": "uio_pruss.c",
  "hash_id": "8b05bb15ee0e3475e92ef3cd18b39fc447aa31d92b3d3c64f76a2595e65cd665",
  "original_prompt": "Ingested from linux-6.6.14/drivers/uio/uio_pruss.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/uio_driver.h>\n#include <linux/platform_data/uio_pruss.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/genalloc.h>\n\n#define DRV_NAME \"pruss_uio\"\n#define DRV_VERSION \"1.0\"\n\nstatic int sram_pool_sz = SZ_16K;\nmodule_param(sram_pool_sz, int, 0);\nMODULE_PARM_DESC(sram_pool_sz, \"sram pool size to allocate \");\n\nstatic int extram_pool_sz = SZ_256K;\nmodule_param(extram_pool_sz, int, 0);\nMODULE_PARM_DESC(extram_pool_sz, \"external ram pool size to allocate\");\n\n \n#define MAX_PRUSS_EVT\t8\n\n#define PINTC_HIDISR\t0x0038\n#define PINTC_HIPIR\t0x0900\n#define HIPIR_NOPEND\t0x80000000\n#define PINTC_HIER\t0x1500\n\nstruct uio_pruss_dev {\n\tstruct uio_info *info;\n\tstruct clk *pruss_clk;\n\tdma_addr_t sram_paddr;\n\tdma_addr_t ddr_paddr;\n\tvoid __iomem *prussio_vaddr;\n\tunsigned long sram_vaddr;\n\tvoid *ddr_vaddr;\n\tunsigned int hostirq_start;\n\tunsigned int pintc_base;\n\tstruct gen_pool *sram_pool;\n};\n\nstatic irqreturn_t pruss_handler(int irq, struct uio_info *info)\n{\n\tstruct uio_pruss_dev *gdev = info->priv;\n\tint intr_bit = (irq - gdev->hostirq_start + 2);\n\tint val, intr_mask = (1 << intr_bit);\n\tvoid __iomem *base = gdev->prussio_vaddr + gdev->pintc_base;\n\tvoid __iomem *intren_reg = base + PINTC_HIER;\n\tvoid __iomem *intrdis_reg = base + PINTC_HIDISR;\n\tvoid __iomem *intrstat_reg = base + PINTC_HIPIR + (intr_bit << 2);\n\n\tval = ioread32(intren_reg);\n\t \n\tif (!(val & intr_mask) && (ioread32(intrstat_reg) & HIPIR_NOPEND))\n\t\treturn IRQ_NONE;\n\t \n\tiowrite32(intr_bit, intrdis_reg);\n\treturn IRQ_HANDLED;\n}\n\nstatic void pruss_cleanup(struct device *dev, struct uio_pruss_dev *gdev)\n{\n\tint cnt;\n\tstruct uio_info *p = gdev->info;\n\n\tfor (cnt = 0; cnt < MAX_PRUSS_EVT; cnt++, p++) {\n\t\tuio_unregister_device(p);\n\t}\n\tiounmap(gdev->prussio_vaddr);\n\tif (gdev->ddr_vaddr) {\n\t\tdma_free_coherent(dev, extram_pool_sz, gdev->ddr_vaddr,\n\t\t\tgdev->ddr_paddr);\n\t}\n\tif (gdev->sram_vaddr)\n\t\tgen_pool_free(gdev->sram_pool,\n\t\t\t      gdev->sram_vaddr,\n\t\t\t      sram_pool_sz);\n\tclk_disable(gdev->pruss_clk);\n}\n\nstatic int pruss_probe(struct platform_device *pdev)\n{\n\tstruct uio_info *p;\n\tstruct uio_pruss_dev *gdev;\n\tstruct resource *regs_prussio;\n\tstruct device *dev = &pdev->dev;\n\tint ret, cnt, i, len;\n\tstruct uio_pruss_pdata *pdata = dev_get_platdata(dev);\n\n\tgdev = devm_kzalloc(dev, sizeof(struct uio_pruss_dev), GFP_KERNEL);\n\tif (!gdev)\n\t\treturn -ENOMEM;\n\n\tgdev->info = devm_kcalloc(dev, MAX_PRUSS_EVT, sizeof(*p), GFP_KERNEL);\n\tif (!gdev->info)\n\t\treturn -ENOMEM;\n\n\t \n\tgdev->pruss_clk = devm_clk_get(dev, \"pruss\");\n\tif (IS_ERR(gdev->pruss_clk)) {\n\t\tdev_err(dev, \"Failed to get clock\\n\");\n\t\treturn PTR_ERR(gdev->pruss_clk);\n\t}\n\n\tret = clk_enable(gdev->pruss_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tregs_prussio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs_prussio) {\n\t\tdev_err(dev, \"No PRUSS I/O resource specified\\n\");\n\t\tret = -EIO;\n\t\tgoto err_clk_disable;\n\t}\n\n\tif (!regs_prussio->start) {\n\t\tdev_err(dev, \"Invalid memory resource\\n\");\n\t\tret = -EIO;\n\t\tgoto err_clk_disable;\n\t}\n\n\tif (pdata->sram_pool) {\n\t\tgdev->sram_pool = pdata->sram_pool;\n\t\tgdev->sram_vaddr =\n\t\t\t(unsigned long)gen_pool_dma_alloc(gdev->sram_pool,\n\t\t\t\t\tsram_pool_sz, &gdev->sram_paddr);\n\t\tif (!gdev->sram_vaddr) {\n\t\t\tdev_err(dev, \"Could not allocate SRAM pool\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_clk_disable;\n\t\t}\n\t}\n\n\tgdev->ddr_vaddr = dma_alloc_coherent(dev, extram_pool_sz,\n\t\t\t\t&(gdev->ddr_paddr), GFP_KERNEL | GFP_DMA);\n\tif (!gdev->ddr_vaddr) {\n\t\tdev_err(dev, \"Could not allocate external memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_sram;\n\t}\n\n\tlen = resource_size(regs_prussio);\n\tgdev->prussio_vaddr = ioremap(regs_prussio->start, len);\n\tif (!gdev->prussio_vaddr) {\n\t\tdev_err(dev, \"Can't remap PRUSS I/O  address range\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_ddr_vaddr;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_unmap;\n\n\tgdev->hostirq_start = ret;\n\tgdev->pintc_base = pdata->pintc_base;\n\n\tfor (cnt = 0, p = gdev->info; cnt < MAX_PRUSS_EVT; cnt++, p++) {\n\t\tp->mem[0].addr = regs_prussio->start;\n\t\tp->mem[0].size = resource_size(regs_prussio);\n\t\tp->mem[0].memtype = UIO_MEM_PHYS;\n\n\t\tp->mem[1].addr = gdev->sram_paddr;\n\t\tp->mem[1].size = sram_pool_sz;\n\t\tp->mem[1].memtype = UIO_MEM_PHYS;\n\n\t\tp->mem[2].addr = gdev->ddr_paddr;\n\t\tp->mem[2].size = extram_pool_sz;\n\t\tp->mem[2].memtype = UIO_MEM_PHYS;\n\n\t\tp->name = devm_kasprintf(dev, GFP_KERNEL, \"pruss_evt%d\", cnt);\n\t\tp->version = DRV_VERSION;\n\n\t\t \n\t\tp->irq = gdev->hostirq_start + cnt;\n\t\tp->handler = pruss_handler;\n\t\tp->priv = gdev;\n\n\t\tret = uio_register_device(dev, p);\n\t\tif (ret < 0)\n\t\t\tgoto err_unloop;\n\t}\n\n\tplatform_set_drvdata(pdev, gdev);\n\treturn 0;\n\nerr_unloop:\n\tfor (i = 0, p = gdev->info; i < cnt; i++, p++) {\n\t\tuio_unregister_device(p);\n\t}\nerr_unmap:\n\tiounmap(gdev->prussio_vaddr);\nerr_free_ddr_vaddr:\n\tdma_free_coherent(dev, extram_pool_sz, gdev->ddr_vaddr,\n\t\t\t  gdev->ddr_paddr);\nerr_free_sram:\n\tif (pdata->sram_pool)\n\t\tgen_pool_free(gdev->sram_pool, gdev->sram_vaddr, sram_pool_sz);\nerr_clk_disable:\n\tclk_disable(gdev->pruss_clk);\n\n\treturn ret;\n}\n\nstatic int pruss_remove(struct platform_device *dev)\n{\n\tstruct uio_pruss_dev *gdev = platform_get_drvdata(dev);\n\n\tpruss_cleanup(&dev->dev, gdev);\n\treturn 0;\n}\n\nstatic struct platform_driver pruss_driver = {\n\t.probe = pruss_probe,\n\t.remove = pruss_remove,\n\t.driver = {\n\t\t   .name = DRV_NAME,\n\t\t   },\n};\n\nmodule_platform_driver(pruss_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_AUTHOR(\"Amit Chatterjee <amit.chatterjee@ti.com>\");\nMODULE_AUTHOR(\"Pratheesh Gangadhar <pratheesh@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}