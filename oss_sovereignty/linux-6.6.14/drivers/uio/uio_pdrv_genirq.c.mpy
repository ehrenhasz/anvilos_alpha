{
  "module_name": "uio_pdrv_genirq.c",
  "hash_id": "15a57810a9c2a5533ee37e388b3c134dabb2370e7fa525122b0be620b02de00e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/uio/uio_pdrv_genirq.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/uio_driver.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/stringify.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n\n#define DRIVER_NAME \"uio_pdrv_genirq\"\n\nstruct uio_pdrv_genirq_platdata {\n\tstruct uio_info *uioinfo;\n\tspinlock_t lock;\n\tunsigned long flags;\n\tstruct platform_device *pdev;\n};\n\n \nenum {\n\tUIO_IRQ_DISABLED = 0,\n};\n\nstatic int uio_pdrv_genirq_open(struct uio_info *info, struct inode *inode)\n{\n\tstruct uio_pdrv_genirq_platdata *priv = info->priv;\n\n\t \n\tpm_runtime_get_sync(&priv->pdev->dev);\n\treturn 0;\n}\n\nstatic int uio_pdrv_genirq_release(struct uio_info *info, struct inode *inode)\n{\n\tstruct uio_pdrv_genirq_platdata *priv = info->priv;\n\n\t \n\tpm_runtime_put_sync(&priv->pdev->dev);\n\treturn 0;\n}\n\nstatic irqreturn_t uio_pdrv_genirq_handler(int irq, struct uio_info *dev_info)\n{\n\tstruct uio_pdrv_genirq_platdata *priv = dev_info->priv;\n\n\t \n\n\tspin_lock(&priv->lock);\n\tif (!__test_and_set_bit(UIO_IRQ_DISABLED, &priv->flags))\n\t\tdisable_irq_nosync(irq);\n\tspin_unlock(&priv->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int uio_pdrv_genirq_irqcontrol(struct uio_info *dev_info, s32 irq_on)\n{\n\tstruct uio_pdrv_genirq_platdata *priv = dev_info->priv;\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (irq_on) {\n\t\tif (__test_and_clear_bit(UIO_IRQ_DISABLED, &priv->flags))\n\t\t\tenable_irq(dev_info->irq);\n\t} else {\n\t\tif (!__test_and_set_bit(UIO_IRQ_DISABLED, &priv->flags))\n\t\t\tdisable_irq_nosync(dev_info->irq);\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic void uio_pdrv_genirq_cleanup(void *data)\n{\n\tstruct device *dev = data;\n\n\tpm_runtime_disable(dev);\n}\n\nstatic int uio_pdrv_genirq_probe(struct platform_device *pdev)\n{\n\tstruct uio_info *uioinfo = dev_get_platdata(&pdev->dev);\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct uio_pdrv_genirq_platdata *priv;\n\tstruct uio_mem *uiomem;\n\tint ret = -EINVAL;\n\tint i;\n\n\tif (node) {\n\t\tconst char *name;\n\n\t\t \n\t\tuioinfo = devm_kzalloc(&pdev->dev, sizeof(*uioinfo),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!uioinfo) {\n\t\t\tdev_err(&pdev->dev, \"unable to kmalloc\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (!of_property_read_string(node, \"linux,uio-name\", &name))\n\t\t\tuioinfo->name = devm_kstrdup(&pdev->dev, name, GFP_KERNEL);\n\t\telse\n\t\t\tuioinfo->name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t       \"%pOFn\", node);\n\n\t\tuioinfo->version = \"devicetree\";\n\t\t \n\t}\n\n\tif (!uioinfo || !uioinfo->name || !uioinfo->version) {\n\t\tdev_err(&pdev->dev, \"missing platform_data\\n\");\n\t\treturn ret;\n\t}\n\n\tif (uioinfo->handler || uioinfo->irqcontrol ||\n\t    uioinfo->irq_flags & IRQF_SHARED) {\n\t\tdev_err(&pdev->dev, \"interrupt configuration error\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tdev_err(&pdev->dev, \"unable to kmalloc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->uioinfo = uioinfo;\n\tspin_lock_init(&priv->lock);\n\tpriv->flags = 0;  \n\tpriv->pdev = pdev;\n\n\tif (!uioinfo->irq) {\n\t\tret = platform_get_irq_optional(pdev, 0);\n\t\tuioinfo->irq = ret;\n\t\tif (ret == -ENXIO)\n\t\t\tuioinfo->irq = UIO_IRQ_NONE;\n\t\telse if (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t\telse if (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to get IRQ\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (uioinfo->irq) {\n\t\tstruct irq_data *irq_data = irq_get_irq_data(uioinfo->irq);\n\n\t\t \n\t\tif (irq_data &&\n\t\t    irqd_get_trigger_type(irq_data) & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tdev_dbg(&pdev->dev, \"disable lazy unmask\\n\");\n\t\t\tirq_set_status_flags(uioinfo->irq, IRQ_DISABLE_UNLAZY);\n\t\t}\n\t}\n\n\tuiomem = &uioinfo->mem[0];\n\n\tfor (i = 0; i < pdev->num_resources; ++i) {\n\t\tstruct resource *r = &pdev->resource[i];\n\n\t\tif (r->flags != IORESOURCE_MEM)\n\t\t\tcontinue;\n\n\t\tif (uiomem >= &uioinfo->mem[MAX_UIO_MAPS]) {\n\t\t\tdev_warn(&pdev->dev, \"device has more than \"\n\t\t\t\t\t__stringify(MAX_UIO_MAPS)\n\t\t\t\t\t\" I/O memory resources.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tuiomem->memtype = UIO_MEM_PHYS;\n\t\tuiomem->addr = r->start & PAGE_MASK;\n\t\tuiomem->offs = r->start & ~PAGE_MASK;\n\t\tuiomem->size = (uiomem->offs + resource_size(r)\n\t\t\t\t+ PAGE_SIZE - 1) & PAGE_MASK;\n\t\tuiomem->name = r->name;\n\t\t++uiomem;\n\t}\n\n\twhile (uiomem < &uioinfo->mem[MAX_UIO_MAPS]) {\n\t\tuiomem->size = 0;\n\t\t++uiomem;\n\t}\n\n\t \n\n\tuioinfo->handler = uio_pdrv_genirq_handler;\n\tuioinfo->irqcontrol = uio_pdrv_genirq_irqcontrol;\n\tuioinfo->open = uio_pdrv_genirq_open;\n\tuioinfo->release = uio_pdrv_genirq_release;\n\tuioinfo->priv = priv;\n\n\t \n\tpm_runtime_enable(&pdev->dev);\n\n\tret = devm_add_action_or_reset(&pdev->dev, uio_pdrv_genirq_cleanup,\n\t\t\t\t       &pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_uio_register_device(&pdev->dev, priv->uioinfo);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"unable to register uio device\\n\");\n\n\treturn ret;\n}\n\nstatic int uio_pdrv_genirq_runtime_nop(struct device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct dev_pm_ops uio_pdrv_genirq_dev_pm_ops = {\n\t.runtime_suspend = uio_pdrv_genirq_runtime_nop,\n\t.runtime_resume = uio_pdrv_genirq_runtime_nop,\n};\n\n#ifdef CONFIG_OF\nstatic struct of_device_id uio_of_genirq_match[] = {\n\t{   },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, uio_of_genirq_match);\nmodule_param_string(of_id, uio_of_genirq_match[0].compatible, 128, 0);\nMODULE_PARM_DESC(of_id, \"Openfirmware id of the device to be handled by uio\");\n#endif\n\nstatic struct platform_driver uio_pdrv_genirq = {\n\t.probe = uio_pdrv_genirq_probe,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.pm = &uio_pdrv_genirq_dev_pm_ops,\n\t\t.of_match_table = of_match_ptr(uio_of_genirq_match),\n\t},\n};\n\nmodule_platform_driver(uio_pdrv_genirq);\n\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_DESCRIPTION(\"Userspace I/O platform driver with generic IRQ handling\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}