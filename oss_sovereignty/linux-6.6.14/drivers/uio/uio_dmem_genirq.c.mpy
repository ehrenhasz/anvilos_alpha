{
  "module_name": "uio_dmem_genirq.c",
  "hash_id": "85b1e01193cc27b663ccbba7c1995ec05bc0699a9c33db9dd8a7bc8d56664343",
  "original_prompt": "Ingested from linux-6.6.14/drivers/uio/uio_dmem_genirq.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/uio_driver.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/platform_data/uio_dmem_genirq.h>\n#include <linux/stringify.h>\n#include <linux/pm_runtime.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n\n#define DRIVER_NAME \"uio_dmem_genirq\"\n#define DMEM_MAP_ERROR (~0)\n\nstruct uio_dmem_genirq_platdata {\n\tstruct uio_info *uioinfo;\n\tspinlock_t lock;\n\tunsigned long flags;\n\tstruct platform_device *pdev;\n\tunsigned int dmem_region_start;\n\tunsigned int num_dmem_regions;\n\tvoid *dmem_region_vaddr[MAX_UIO_MAPS];\n\tstruct mutex alloc_lock;\n\tunsigned int refcnt;\n};\n\n \nenum {\n\tUIO_IRQ_DISABLED = 0,\n};\n\nstatic int uio_dmem_genirq_open(struct uio_info *info, struct inode *inode)\n{\n\tstruct uio_dmem_genirq_platdata *priv = info->priv;\n\tstruct uio_mem *uiomem;\n\tint dmem_region = priv->dmem_region_start;\n\n\tuiomem = &priv->uioinfo->mem[priv->dmem_region_start];\n\n\tmutex_lock(&priv->alloc_lock);\n\twhile (!priv->refcnt && uiomem < &priv->uioinfo->mem[MAX_UIO_MAPS]) {\n\t\tvoid *addr;\n\t\tif (!uiomem->size)\n\t\t\tbreak;\n\n\t\taddr = dma_alloc_coherent(&priv->pdev->dev, uiomem->size,\n\t\t\t\t(dma_addr_t *)&uiomem->addr, GFP_KERNEL);\n\t\tif (!addr) {\n\t\t\tuiomem->addr = DMEM_MAP_ERROR;\n\t\t}\n\t\tpriv->dmem_region_vaddr[dmem_region++] = addr;\n\t\t++uiomem;\n\t}\n\tpriv->refcnt++;\n\n\tmutex_unlock(&priv->alloc_lock);\n\t \n\tpm_runtime_get_sync(&priv->pdev->dev);\n\treturn 0;\n}\n\nstatic int uio_dmem_genirq_release(struct uio_info *info, struct inode *inode)\n{\n\tstruct uio_dmem_genirq_platdata *priv = info->priv;\n\tstruct uio_mem *uiomem;\n\tint dmem_region = priv->dmem_region_start;\n\n\t \n\tpm_runtime_put_sync(&priv->pdev->dev);\n\n\tuiomem = &priv->uioinfo->mem[priv->dmem_region_start];\n\n\tmutex_lock(&priv->alloc_lock);\n\n\tpriv->refcnt--;\n\twhile (!priv->refcnt && uiomem < &priv->uioinfo->mem[MAX_UIO_MAPS]) {\n\t\tif (!uiomem->size)\n\t\t\tbreak;\n\t\tif (priv->dmem_region_vaddr[dmem_region]) {\n\t\t\tdma_free_coherent(&priv->pdev->dev, uiomem->size,\n\t\t\t\t\tpriv->dmem_region_vaddr[dmem_region],\n\t\t\t\t\tuiomem->addr);\n\t\t}\n\t\tuiomem->addr = DMEM_MAP_ERROR;\n\t\t++dmem_region;\n\t\t++uiomem;\n\t}\n\n\tmutex_unlock(&priv->alloc_lock);\n\treturn 0;\n}\n\nstatic irqreturn_t uio_dmem_genirq_handler(int irq, struct uio_info *dev_info)\n{\n\tstruct uio_dmem_genirq_platdata *priv = dev_info->priv;\n\n\t \n\n\tspin_lock(&priv->lock);\n\tif (!__test_and_set_bit(UIO_IRQ_DISABLED, &priv->flags))\n\t\tdisable_irq_nosync(irq);\n\tspin_unlock(&priv->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int uio_dmem_genirq_irqcontrol(struct uio_info *dev_info, s32 irq_on)\n{\n\tstruct uio_dmem_genirq_platdata *priv = dev_info->priv;\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (irq_on) {\n\t\tif (__test_and_clear_bit(UIO_IRQ_DISABLED, &priv->flags))\n\t\t\tenable_irq(dev_info->irq);\n\t} else {\n\t\tif (!__test_and_set_bit(UIO_IRQ_DISABLED, &priv->flags))\n\t\t\tdisable_irq_nosync(dev_info->irq);\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic void uio_dmem_genirq_pm_disable(void *data)\n{\n\tstruct device *dev = data;\n\n\tpm_runtime_disable(dev);\n}\n\nstatic int uio_dmem_genirq_probe(struct platform_device *pdev)\n{\n\tstruct uio_dmem_genirq_pdata *pdata = dev_get_platdata(&pdev->dev);\n\tstruct uio_info *uioinfo = &pdata->uioinfo;\n\tstruct uio_dmem_genirq_platdata *priv;\n\tstruct uio_mem *uiomem;\n\tint ret = -EINVAL;\n\tint i;\n\n\tif (pdev->dev.of_node) {\n\t\t \n\t\tuioinfo = devm_kzalloc(&pdev->dev, sizeof(*uioinfo), GFP_KERNEL);\n\t\tif (!uioinfo) {\n\t\t\tdev_err(&pdev->dev, \"unable to kmalloc\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tuioinfo->name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"%pOFn\",\n\t\t\t\t\t       pdev->dev.of_node);\n\t\tuioinfo->version = \"devicetree\";\n\t}\n\n\tif (!uioinfo || !uioinfo->name || !uioinfo->version) {\n\t\tdev_err(&pdev->dev, \"missing platform_data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (uioinfo->handler || uioinfo->irqcontrol ||\n\t    uioinfo->irq_flags & IRQF_SHARED) {\n\t\tdev_err(&pdev->dev, \"interrupt configuration error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tdev_err(&pdev->dev, \"unable to kmalloc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"DMA enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->uioinfo = uioinfo;\n\tspin_lock_init(&priv->lock);\n\tpriv->flags = 0;  \n\tpriv->pdev = pdev;\n\tmutex_init(&priv->alloc_lock);\n\n\tif (!uioinfo->irq) {\n\t\t \n\t\tret = platform_get_irq(pdev, 0);\n\t\tif (ret == -ENXIO && pdev->dev.of_node)\n\t\t\tret = UIO_IRQ_NONE;\n\t\telse if (ret < 0)\n\t\t\treturn ret;\n\t\tuioinfo->irq = ret;\n\t}\n\n\tif (uioinfo->irq) {\n\t\tstruct irq_data *irq_data = irq_get_irq_data(uioinfo->irq);\n\n\t\t \n\t\tif (irq_data &&\n\t\t    irqd_get_trigger_type(irq_data) & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tdev_dbg(&pdev->dev, \"disable lazy unmask\\n\");\n\t\t\tirq_set_status_flags(uioinfo->irq, IRQ_DISABLE_UNLAZY);\n\t\t}\n\t}\n\n\tuiomem = &uioinfo->mem[0];\n\n\tfor (i = 0; i < pdev->num_resources; ++i) {\n\t\tstruct resource *r = &pdev->resource[i];\n\n\t\tif (r->flags != IORESOURCE_MEM)\n\t\t\tcontinue;\n\n\t\tif (uiomem >= &uioinfo->mem[MAX_UIO_MAPS]) {\n\t\t\tdev_warn(&pdev->dev, \"device has more than \"\n\t\t\t\t\t__stringify(MAX_UIO_MAPS)\n\t\t\t\t\t\" I/O memory resources.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tuiomem->memtype = UIO_MEM_PHYS;\n\t\tuiomem->addr = r->start;\n\t\tuiomem->size = resource_size(r);\n\t\t++uiomem;\n\t}\n\n\tpriv->dmem_region_start = uiomem - &uioinfo->mem[0];\n\tpriv->num_dmem_regions = pdata->num_dynamic_regions;\n\n\tfor (i = 0; i < pdata->num_dynamic_regions; ++i) {\n\t\tif (uiomem >= &uioinfo->mem[MAX_UIO_MAPS]) {\n\t\t\tdev_warn(&pdev->dev, \"device has more than \"\n\t\t\t\t\t__stringify(MAX_UIO_MAPS)\n\t\t\t\t\t\" dynamic and fixed memory regions.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tuiomem->memtype = UIO_MEM_PHYS;\n\t\tuiomem->addr = DMEM_MAP_ERROR;\n\t\tuiomem->size = pdata->dynamic_region_sizes[i];\n\t\t++uiomem;\n\t}\n\n\twhile (uiomem < &uioinfo->mem[MAX_UIO_MAPS]) {\n\t\tuiomem->size = 0;\n\t\t++uiomem;\n\t}\n\n\t \n\n\tuioinfo->handler = uio_dmem_genirq_handler;\n\tuioinfo->irqcontrol = uio_dmem_genirq_irqcontrol;\n\tuioinfo->open = uio_dmem_genirq_open;\n\tuioinfo->release = uio_dmem_genirq_release;\n\tuioinfo->priv = priv;\n\n\t \n\tpm_runtime_enable(&pdev->dev);\n\n\tret = devm_add_action_or_reset(&pdev->dev, uio_dmem_genirq_pm_disable, &pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_uio_register_device(&pdev->dev, priv->uioinfo);\n}\n\nstatic int uio_dmem_genirq_runtime_nop(struct device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct dev_pm_ops uio_dmem_genirq_dev_pm_ops = {\n\t.runtime_suspend = uio_dmem_genirq_runtime_nop,\n\t.runtime_resume = uio_dmem_genirq_runtime_nop,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id uio_of_genirq_match[] = {\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, uio_of_genirq_match);\n#endif\n\nstatic struct platform_driver uio_dmem_genirq = {\n\t.probe = uio_dmem_genirq_probe,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.pm = &uio_dmem_genirq_dev_pm_ops,\n\t\t.of_match_table = of_match_ptr(uio_of_genirq_match),\n\t},\n};\n\nmodule_platform_driver(uio_dmem_genirq);\n\nMODULE_AUTHOR(\"Damian Hobson-Garcia\");\nMODULE_DESCRIPTION(\"Userspace I/O platform driver with dynamic memory.\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}