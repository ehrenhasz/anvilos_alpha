{
  "module_name": "Kconfig",
  "hash_id": "46219e8e1a90e83a0e48fb9187e699554149304a6e1c84ef48e8a836c7241a29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/uio/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nmenuconfig UIO\n\ttristate \"Userspace I/O drivers\"\n\tdepends on MMU\n\thelp\n\t  Enable this to allow the userspace driver core code to be\n\t  built.  This code allows userspace programs easy access to\n\t  kernel interrupts and memory locations, allowing some drivers\n\t  to be written in userspace.  Note that a small kernel driver\n\t  is also required for interrupt handling to work properly.\n\n\t  If you don't know what to do here, say N.\n\nif UIO\n\nconfig UIO_CIF\n\ttristate \"generic Hilscher CIF Card driver\"\n\tdepends on PCI\n\thelp\n\t  Driver for Hilscher CIF DeviceNet and Profibus cards.  This\n\t  driver requires a userspace component called cif that handles\n\t  all of the heavy lifting and can be found at:\n\t        <http://www.osadl.org/projects/downloads/UIO/user/>\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called uio_cif.\n\nconfig UIO_PDRV_GENIRQ\n\ttristate \"Userspace I/O platform driver with generic IRQ handling\"\n\thelp\n\t  Platform driver for Userspace I/O devices, including generic\n\t  interrupt handling code. Shared interrupts are not supported.\n\n\t  This kernel driver requires that the matching userspace driver\n\t  handles interrupts in a special way. Userspace is responsible\n\t  for acknowledging the hardware device if needed, and re-enabling\n\t  interrupts in the interrupt controller using the write() syscall.\n\n\t  If you don't know what to do here, say N.\n\nconfig UIO_DMEM_GENIRQ\n\ttristate \"Userspace platform driver with generic irq and dynamic memory\"\n\tdepends on HAS_DMA\n\thelp\n\t  Platform driver for Userspace I/O devices, including generic\n\t  interrupt handling code. Shared interrupts are not supported.\n\n\t  Memory regions can be specified with the same platform device\n\t  resources as the UIO_PDRV drivers, but dynamic regions can also\n\t  be specified.\n\t  The number and size of these regions is static,\n\t  but the memory allocation is not performed until\n\t  the associated device file is opened. The\n\t  memory is freed once the uio device is closed.\n\n\t  If you don't know what to do here, say N.\n\nconfig UIO_AEC\n\ttristate \"AEC video timestamp device\"\n\tdepends on PCI\n\thelp\n\n\t  UIO driver for the Adrienne Electronics Corporation PCI time\n\t  code device.\n\n\t  This device differs from other UIO devices since it uses I/O\n\t  ports instead of memory mapped I/O. In order to make it\n\t  possible for UIO to work with this device a utility, uioport,\n\t  can be used to read and write the ports:\n\n\t    git clone git://ifup.org/philips/uioport.git\n\n\t  If you compile this as a module, it will be called uio_aec.\n\nconfig UIO_SERCOS3\n\ttristate \"Automata Sercos III PCI card driver\"\n\tdepends on PCI\n\thelp\n\t  Userspace I/O interface for the Sercos III PCI card from\n\t  Automata GmbH. The userspace part of this driver will be\n\t  available for download from the Automata GmbH web site.\n\n\t  Automata GmbH:        http://www.automataweb.com\n\t  Sercos III interface: http://www.sercos.com\n\n\t  If you compile this as a module, it will be called uio_sercos3.\n\nconfig UIO_PCI_GENERIC\n\ttristate \"Generic driver for PCI 2.3 and PCI Express cards\"\n\tdepends on PCI\n\thelp\n\t  Generic driver that you can bind, dynamically, to any\n\t  PCI 2.3 compliant and PCI Express card. It is useful,\n\t  primarily, for virtualization scenarios.\n\t  If you compile this as a module, it will be called uio_pci_generic.\n\nconfig UIO_NETX\n\ttristate \"Hilscher NetX Card driver\"\n\tdepends on PCI\n\thelp\n\t  Driver for Hilscher NetX based fieldbus cards (cifX, comX).\n\t  This driver requires a userspace component that comes with the card\n\t  or is available from Hilscher (http://www.hilscher.com).\n\n\t  To compile this driver as a module, choose M here; the module\n\t  will be called uio_netx.\n\nconfig UIO_FSL_ELBC_GPCM\n\ttristate \"eLBC/GPCM driver\"\n\tdepends on FSL_LBC\n\thelp\n\t  Generic driver for accessing a peripheral connected to an eLBC port\n\t  that is running in GPCM mode. GPCM is an interface for simple lower\n\t  performance memories and memory-mapped devices. For devices using\n\t  FCM or UPM eLBC modes, other device-specific drivers are available.\n\nconfig UIO_FSL_ELBC_GPCM_NETX5152\n\tbool \"eLBC/GPCM netX 51/52 support\"\n\tdepends on UIO_FSL_ELBC_GPCM\n\thelp\n\t  This will add support for netX 51/52 devices connected via eLBC/GPCM.\n\t  In particular, it implements interrupt handling. This can be used\n\t  together with the userspace netX stack from Hilscher.\n\n\t  Information about this hardware can be found at:\n\t  http://www.hilscher.com/netx\n\nconfig UIO_PRUSS\n\ttristate \"Texas Instruments PRUSS driver\"\n\tselect GENERIC_ALLOCATOR\n\tdepends on HAS_IOMEM && HAS_DMA\n\thelp\n\t  PRUSS driver for OMAPL138/DA850/AM18XX devices\n\t  PRUSS driver requires user space components, examples and user space\n\t  driver is available from below SVN repo - you may use anonymous login\n\n\t  https://gforge.ti.com/gf/project/pru_sw/\n\n\t  More info on API is available at below wiki\n\n\t  http://processors.wiki.ti.com/index.php/PRU_Linux_Application_Loader\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called uio_pruss.\n\nconfig UIO_MF624\n\ttristate \"Humusoft MF624 DAQ PCI card driver\"\n\tdepends on PCI\n\thelp\n\t  Userspace I/O interface for the Humusoft MF624 PCI card.\n\t  A sample userspace application using this driver is available\n\t  (among other MF624 related information and software components)\n\t  for download in a git repository:\n\n\t    git clone git://rtime.felk.cvut.cz/mf6xx.git\n\n\t  If you compile this as a module, it will be called uio_mf624.\n\nconfig UIO_HV_GENERIC\n\ttristate \"Generic driver for Hyper-V VMBus\"\n\tdepends on HYPERV\n\thelp\n\t  Generic driver that you can bind, dynamically, to any\n\t  Hyper-V VMBus device. It is useful to provide direct access\n\t  to network and storage devices from userspace.\n\n\t  If you compile this as a module, it will be called uio_hv_generic.\n\nconfig UIO_DFL\n\ttristate \"Generic driver for DFL (Device Feature List) bus\"\n\tdepends on FPGA_DFL\n\thelp\n\t  Generic DFL (Device Feature List) driver for Userspace I/O devices.\n\t  It is useful to provide direct access to DFL devices from userspace.\n\t  A sample userspace application using this driver is available for\n\t  download in a git repository:\n\n\t    git clone https://github.com/OPAE/opae-sdk.git\n\n\t  It could be found at:\n\n\t    opae-sdk/tools/libopaeuio/\n\n\t  If you compile this as a module, it will be called uio_dfl.\nendif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}