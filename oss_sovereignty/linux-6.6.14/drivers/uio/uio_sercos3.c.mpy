{
  "module_name": "uio_sercos3.c",
  "hash_id": "bf418d6871d6ca0c26453f0104236127ba34c7277c2b32752a87540b9e56c909",
  "original_prompt": "Ingested from linux-6.6.14/drivers/uio/uio_sercos3.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/uio_driver.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n \n#define SERCOS_SUB_VENDOR_ID  0x1971\n#define SERCOS_SUB_SYSID_3530 0x3530\n#define SERCOS_SUB_SYSID_3535 0x3535\n#define SERCOS_SUB_SYSID_3780 0x3780\n\n \n#define IER0_OFFSET 0x08\n\n \n#define ISR0_OFFSET 0x18\n\nstruct sercos3_priv {\n\tu32 ier0_cache;\n\tspinlock_t ier0_cache_lock;\n};\n\n \nstatic void sercos3_disable_interrupts(struct uio_info *info,\n\t\t\t\t       struct sercos3_priv *priv)\n{\n\tvoid __iomem *ier0 = info->mem[3].internal_addr + IER0_OFFSET;\n\n\t \n\tpriv->ier0_cache |= ioread32(ier0);\n\n\t \n\tiowrite32(0, ier0);\n}\n\n \nstatic void sercos3_enable_interrupts(struct uio_info *info,\n\t\t\t\t      struct sercos3_priv *priv)\n{\n\tvoid __iomem *ier0 = info->mem[3].internal_addr + IER0_OFFSET;\n\n\t \n\tiowrite32(ioread32(ier0) | priv->ier0_cache, ier0);\n\tpriv->ier0_cache = 0;\n}\n\nstatic irqreturn_t sercos3_handler(int irq, struct uio_info *info)\n{\n\tstruct sercos3_priv *priv = info->priv;\n\tvoid __iomem *isr0 = info->mem[3].internal_addr + ISR0_OFFSET;\n\tvoid __iomem *ier0 = info->mem[3].internal_addr + IER0_OFFSET;\n\n\tif (!(ioread32(isr0) & ioread32(ier0)))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&priv->ier0_cache_lock);\n\tsercos3_disable_interrupts(info, priv);\n\tspin_unlock(&priv->ier0_cache_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sercos3_irqcontrol(struct uio_info *info, s32 irq_on)\n{\n\tstruct sercos3_priv *priv = info->priv;\n\n\tspin_lock_irq(&priv->ier0_cache_lock);\n\tif (irq_on)\n\t\tsercos3_enable_interrupts(info, priv);\n\telse\n\t\tsercos3_disable_interrupts(info, priv);\n\tspin_unlock_irq(&priv->ier0_cache_lock);\n\n\treturn 0;\n}\n\nstatic int sercos3_setup_iomem(struct pci_dev *dev, struct uio_info *info,\n\t\t\t       int n, int pci_bar)\n{\n\tinfo->mem[n].addr = pci_resource_start(dev, pci_bar);\n\tif (!info->mem[n].addr)\n\t\treturn -1;\n\tinfo->mem[n].internal_addr = ioremap(pci_resource_start(dev, pci_bar),\n\t\t\t\t\t     pci_resource_len(dev, pci_bar));\n\tif (!info->mem[n].internal_addr)\n\t\treturn -1;\n\tinfo->mem[n].size = pci_resource_len(dev, pci_bar);\n\tinfo->mem[n].memtype = UIO_MEM_PHYS;\n\treturn 0;\n}\n\nstatic int sercos3_pci_probe(struct pci_dev *dev,\n\t\t\t\t       const struct pci_device_id *id)\n{\n\tstruct uio_info *info;\n\tstruct sercos3_priv *priv;\n\tint i;\n\n\tinfo = devm_kzalloc(&dev->dev, sizeof(struct uio_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpriv = devm_kzalloc(&dev->dev, sizeof(struct sercos3_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (pci_enable_device(dev))\n\t\treturn -ENODEV;\n\n\tif (pci_request_regions(dev, \"sercos3\"))\n\t\tgoto out_disable;\n\n\t \n\tif (sercos3_setup_iomem(dev, info, 0, 0))\n\t\tgoto out_unmap;\n\tif (sercos3_setup_iomem(dev, info, 1, 2))\n\t\tgoto out_unmap;\n\tif (sercos3_setup_iomem(dev, info, 2, 3))\n\t\tgoto out_unmap;\n\tif (sercos3_setup_iomem(dev, info, 3, 4))\n\t\tgoto out_unmap;\n\tif (sercos3_setup_iomem(dev, info, 4, 5))\n\t\tgoto out_unmap;\n\n\tspin_lock_init(&priv->ier0_cache_lock);\n\tinfo->priv = priv;\n\tinfo->name = \"Sercos_III_PCI\";\n\tinfo->version = \"0.0.1\";\n\tinfo->irq = dev->irq;\n\tinfo->irq_flags = IRQF_SHARED;\n\tinfo->handler = sercos3_handler;\n\tinfo->irqcontrol = sercos3_irqcontrol;\n\n\tpci_set_drvdata(dev, info);\n\n\tif (uio_register_device(&dev->dev, info))\n\t\tgoto out_unmap;\n\n\treturn 0;\n\nout_unmap:\n\tfor (i = 0; i < 5; i++) {\n\t\tif (info->mem[i].internal_addr)\n\t\t\tiounmap(info->mem[i].internal_addr);\n\t}\n\tpci_release_regions(dev);\nout_disable:\n\tpci_disable_device(dev);\n\treturn -ENODEV;\n}\n\nstatic void sercos3_pci_remove(struct pci_dev *dev)\n{\n\tstruct uio_info *info = pci_get_drvdata(dev);\n\tint i;\n\n\tuio_unregister_device(info);\n\tpci_release_regions(dev);\n\tpci_disable_device(dev);\n\tfor (i = 0; i < 5; i++) {\n\t\tif (info->mem[i].internal_addr)\n\t\t\tiounmap(info->mem[i].internal_addr);\n\t}\n}\n\nstatic struct pci_device_id sercos3_pci_ids[] = {\n\t{\n\t\t.vendor =       PCI_VENDOR_ID_PLX,\n\t\t.device =       PCI_DEVICE_ID_PLX_9030,\n\t\t.subvendor =    SERCOS_SUB_VENDOR_ID,\n\t\t.subdevice =    SERCOS_SUB_SYSID_3530,\n\t},\n\t{\n\t\t.vendor =       PCI_VENDOR_ID_PLX,\n\t\t.device =       PCI_DEVICE_ID_PLX_9030,\n\t\t.subvendor =    SERCOS_SUB_VENDOR_ID,\n\t\t.subdevice =    SERCOS_SUB_SYSID_3535,\n\t},\n\t{\n\t\t.vendor =       PCI_VENDOR_ID_PLX,\n\t\t.device =       PCI_DEVICE_ID_PLX_9030,\n\t\t.subvendor =    SERCOS_SUB_VENDOR_ID,\n\t\t.subdevice =    SERCOS_SUB_SYSID_3780,\n\t},\n\t{ 0, }\n};\n\nstatic struct pci_driver sercos3_pci_driver = {\n\t.name = \"sercos3\",\n\t.id_table = sercos3_pci_ids,\n\t.probe = sercos3_pci_probe,\n\t.remove = sercos3_pci_remove,\n};\n\nmodule_pci_driver(sercos3_pci_driver);\nMODULE_DESCRIPTION(\"UIO driver for the Automata Sercos III PCI card\");\nMODULE_AUTHOR(\"John Ogness <john.ogness@linutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}