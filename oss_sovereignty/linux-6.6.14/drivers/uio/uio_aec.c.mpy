{
  "module_name": "uio_aec.c",
  "hash_id": "8f51a116f2a8efd92e21035918f9a7a21410683766fbe182ca6703aa7a041a63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/uio/uio_aec.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/cdev.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/uio_driver.h>\n#include <linux/slab.h>\n\n#define PCI_VENDOR_ID_AEC 0xaecb\n#define PCI_DEVICE_ID_AEC_VITCLTC 0x6250\n\n#define INT_ENABLE_ADDR\t\t0xFC\n#define INT_ENABLE\t\t0x10\n#define INT_DISABLE\t\t0x0\n\n#define INT_MASK_ADDR\t\t0x2E\n#define INT_MASK_ALL\t\t0x3F\n\n#define INTA_DRVR_ADDR\t\t0xFE\n#define INTA_ENABLED_FLAG\t0x08\n#define INTA_FLAG\t\t0x01\n\n#define MAILBOX\t\t\t0x0F\n\nstatic struct pci_device_id ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AEC, PCI_DEVICE_ID_AEC_VITCLTC), },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, ids);\n\nstatic irqreturn_t aectc_irq(int irq, struct uio_info *dev_info)\n{\n\tvoid __iomem *int_flag = dev_info->priv + INTA_DRVR_ADDR;\n\tunsigned char status = ioread8(int_flag);\n\n\n\tif ((status & INTA_ENABLED_FLAG) && (status & INTA_FLAG)) {\n\t\t \n\t\tstatus = ioread8(dev_info->priv + MAILBOX);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic void print_board_data(struct pci_dev *pdev, struct uio_info *i)\n{\n\tdev_info(&pdev->dev, \"PCI-TC board vendor: %x%x number: %x%x\"\n\t\t\" revision: %c%c\\n\",\n\t\tioread8(i->priv + 0x01),\n\t\tioread8(i->priv + 0x00),\n\t\tioread8(i->priv + 0x03),\n\t\tioread8(i->priv + 0x02),\n\t\tioread8(i->priv + 0x06),\n\t\tioread8(i->priv + 0x07));\n}\n\nstatic int probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct uio_info *info;\n\tint ret;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(struct uio_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif (pci_enable_device(pdev))\n\t\treturn -ENODEV;\n\n\tif (pci_request_regions(pdev, \"aectc\"))\n\t\tgoto out_disable;\n\n\tinfo->name = \"aectc\";\n\tinfo->port[0].start = pci_resource_start(pdev, 0);\n\tif (!info->port[0].start)\n\t\tgoto out_release;\n\tinfo->priv = pci_iomap(pdev, 0, 0);\n\tif (!info->priv)\n\t\tgoto out_release;\n\tinfo->port[0].size = pci_resource_len(pdev, 0);\n\tinfo->port[0].porttype = UIO_PORT_GPIO;\n\n\tinfo->version = \"0.0.1\";\n\tinfo->irq = pdev->irq;\n\tinfo->irq_flags = IRQF_SHARED;\n\tinfo->handler = aectc_irq;\n\n\tprint_board_data(pdev, info);\n\tret = uio_register_device(&pdev->dev, info);\n\tif (ret)\n\t\tgoto out_unmap;\n\n\tiowrite32(INT_ENABLE, info->priv + INT_ENABLE_ADDR);\n\tiowrite8(INT_MASK_ALL, info->priv + INT_MASK_ADDR);\n\tif (!(ioread8(info->priv + INTA_DRVR_ADDR)\n\t\t\t& INTA_ENABLED_FLAG))\n\t\tdev_err(&pdev->dev, \"aectc: interrupts not enabled\\n\");\n\n\tpci_set_drvdata(pdev, info);\n\n\treturn 0;\n\nout_unmap:\n\tpci_iounmap(pdev, info->priv);\nout_release:\n\tpci_release_regions(pdev);\nout_disable:\n\tpci_disable_device(pdev);\n\treturn -ENODEV;\n}\n\nstatic void remove(struct pci_dev *pdev)\n{\n\tstruct uio_info *info = pci_get_drvdata(pdev);\n\n\t \n\tiowrite8(INT_DISABLE, info->priv + INT_MASK_ADDR);\n\tiowrite32(INT_DISABLE, info->priv + INT_ENABLE_ADDR);\n\t \n\tioread8(info->priv + MAILBOX);\n\n\tuio_unregister_device(info);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tpci_iounmap(pdev, info->priv);\n}\n\nstatic struct pci_driver pci_driver = {\n\t.name = \"aectc\",\n\t.id_table = ids,\n\t.probe = probe,\n\t.remove = remove,\n};\n\nmodule_pci_driver(pci_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}