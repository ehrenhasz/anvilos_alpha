{
  "module_name": "uio.c",
  "hash_id": "d65ba6d768bd64a0e4aeb9301ed342cedea0b6507c1a053cfbef51ac9e722f3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/uio/uio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/cdev.h>\n#include <linux/uio_driver.h>\n\n#define UIO_MAX_DEVICES\t\t(1U << MINORBITS)\n\nstatic int uio_major;\nstatic struct cdev *uio_cdev;\nstatic DEFINE_IDR(uio_idr);\nstatic const struct file_operations uio_fops;\n\n \nstatic DEFINE_MUTEX(minor_lock);\n\n \n\nstruct uio_map {\n\tstruct kobject kobj;\n\tstruct uio_mem *mem;\n};\n#define to_map(map) container_of(map, struct uio_map, kobj)\n\nstatic ssize_t map_name_show(struct uio_mem *mem, char *buf)\n{\n\tif (unlikely(!mem->name))\n\t\tmem->name = \"\";\n\n\treturn sprintf(buf, \"%s\\n\", mem->name);\n}\n\nstatic ssize_t map_addr_show(struct uio_mem *mem, char *buf)\n{\n\treturn sprintf(buf, \"%pa\\n\", &mem->addr);\n}\n\nstatic ssize_t map_size_show(struct uio_mem *mem, char *buf)\n{\n\treturn sprintf(buf, \"%pa\\n\", &mem->size);\n}\n\nstatic ssize_t map_offset_show(struct uio_mem *mem, char *buf)\n{\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)mem->offs);\n}\n\nstruct map_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct uio_mem *, char *);\n\tssize_t (*store)(struct uio_mem *, const char *, size_t);\n};\n\nstatic struct map_sysfs_entry name_attribute =\n\t__ATTR(name, S_IRUGO, map_name_show, NULL);\nstatic struct map_sysfs_entry addr_attribute =\n\t__ATTR(addr, S_IRUGO, map_addr_show, NULL);\nstatic struct map_sysfs_entry size_attribute =\n\t__ATTR(size, S_IRUGO, map_size_show, NULL);\nstatic struct map_sysfs_entry offset_attribute =\n\t__ATTR(offset, S_IRUGO, map_offset_show, NULL);\n\nstatic struct attribute *map_attrs[] = {\n\t&name_attribute.attr,\n\t&addr_attribute.attr,\n\t&size_attribute.attr,\n\t&offset_attribute.attr,\n\tNULL,\t \n};\nATTRIBUTE_GROUPS(map);\n\nstatic void map_release(struct kobject *kobj)\n{\n\tstruct uio_map *map = to_map(kobj);\n\tkfree(map);\n}\n\nstatic ssize_t map_type_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct uio_map *map = to_map(kobj);\n\tstruct uio_mem *mem = map->mem;\n\tstruct map_sysfs_entry *entry;\n\n\tentry = container_of(attr, struct map_sysfs_entry, attr);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\treturn entry->show(mem, buf);\n}\n\nstatic const struct sysfs_ops map_sysfs_ops = {\n\t.show = map_type_show,\n};\n\nstatic struct kobj_type map_attr_type = {\n\t.release\t= map_release,\n\t.sysfs_ops\t= &map_sysfs_ops,\n\t.default_groups\t= map_groups,\n};\n\nstruct uio_portio {\n\tstruct kobject kobj;\n\tstruct uio_port *port;\n};\n#define to_portio(portio) container_of(portio, struct uio_portio, kobj)\n\nstatic ssize_t portio_name_show(struct uio_port *port, char *buf)\n{\n\tif (unlikely(!port->name))\n\t\tport->name = \"\";\n\n\treturn sprintf(buf, \"%s\\n\", port->name);\n}\n\nstatic ssize_t portio_start_show(struct uio_port *port, char *buf)\n{\n\treturn sprintf(buf, \"0x%lx\\n\", port->start);\n}\n\nstatic ssize_t portio_size_show(struct uio_port *port, char *buf)\n{\n\treturn sprintf(buf, \"0x%lx\\n\", port->size);\n}\n\nstatic ssize_t portio_porttype_show(struct uio_port *port, char *buf)\n{\n\tconst char *porttypes[] = {\"none\", \"x86\", \"gpio\", \"other\"};\n\n\tif ((port->porttype < 0) || (port->porttype > UIO_PORT_OTHER))\n\t\treturn -EINVAL;\n\n\treturn sprintf(buf, \"port_%s\\n\", porttypes[port->porttype]);\n}\n\nstruct portio_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct uio_port *, char *);\n\tssize_t (*store)(struct uio_port *, const char *, size_t);\n};\n\nstatic struct portio_sysfs_entry portio_name_attribute =\n\t__ATTR(name, S_IRUGO, portio_name_show, NULL);\nstatic struct portio_sysfs_entry portio_start_attribute =\n\t__ATTR(start, S_IRUGO, portio_start_show, NULL);\nstatic struct portio_sysfs_entry portio_size_attribute =\n\t__ATTR(size, S_IRUGO, portio_size_show, NULL);\nstatic struct portio_sysfs_entry portio_porttype_attribute =\n\t__ATTR(porttype, S_IRUGO, portio_porttype_show, NULL);\n\nstatic struct attribute *portio_attrs[] = {\n\t&portio_name_attribute.attr,\n\t&portio_start_attribute.attr,\n\t&portio_size_attribute.attr,\n\t&portio_porttype_attribute.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(portio);\n\nstatic void portio_release(struct kobject *kobj)\n{\n\tstruct uio_portio *portio = to_portio(kobj);\n\tkfree(portio);\n}\n\nstatic ssize_t portio_type_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct uio_portio *portio = to_portio(kobj);\n\tstruct uio_port *port = portio->port;\n\tstruct portio_sysfs_entry *entry;\n\n\tentry = container_of(attr, struct portio_sysfs_entry, attr);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\treturn entry->show(port, buf);\n}\n\nstatic const struct sysfs_ops portio_sysfs_ops = {\n\t.show = portio_type_show,\n};\n\nstatic struct kobj_type portio_attr_type = {\n\t.release\t= portio_release,\n\t.sysfs_ops\t= &portio_sysfs_ops,\n\t.default_groups\t= portio_groups,\n};\n\nstatic ssize_t name_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct uio_device *idev = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&idev->info_lock);\n\tif (!idev->info) {\n\t\tret = -EINVAL;\n\t\tdev_err(dev, \"the device has been unregistered\\n\");\n\t\tgoto out;\n\t}\n\n\tret = sprintf(buf, \"%s\\n\", idev->info->name);\n\nout:\n\tmutex_unlock(&idev->info_lock);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t version_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct uio_device *idev = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&idev->info_lock);\n\tif (!idev->info) {\n\t\tret = -EINVAL;\n\t\tdev_err(dev, \"the device has been unregistered\\n\");\n\t\tgoto out;\n\t}\n\n\tret = sprintf(buf, \"%s\\n\", idev->info->version);\n\nout:\n\tmutex_unlock(&idev->info_lock);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(version);\n\nstatic ssize_t event_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct uio_device *idev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%u\\n\", (unsigned int)atomic_read(&idev->event));\n}\nstatic DEVICE_ATTR_RO(event);\n\nstatic struct attribute *uio_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_version.attr,\n\t&dev_attr_event.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(uio);\n\n \nstatic struct class uio_class = {\n\t.name = \"uio\",\n\t.dev_groups = uio_groups,\n};\n\nstatic bool uio_class_registered;\n\n \nstatic int uio_dev_add_attributes(struct uio_device *idev)\n{\n\tint ret;\n\tint mi, pi;\n\tint map_found = 0;\n\tint portio_found = 0;\n\tstruct uio_mem *mem;\n\tstruct uio_map *map;\n\tstruct uio_port *port;\n\tstruct uio_portio *portio;\n\n\tfor (mi = 0; mi < MAX_UIO_MAPS; mi++) {\n\t\tmem = &idev->info->mem[mi];\n\t\tif (mem->size == 0)\n\t\t\tbreak;\n\t\tif (!map_found) {\n\t\t\tmap_found = 1;\n\t\t\tidev->map_dir = kobject_create_and_add(\"maps\",\n\t\t\t\t\t\t\t&idev->dev.kobj);\n\t\t\tif (!idev->map_dir) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_map;\n\t\t\t}\n\t\t}\n\t\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\t\tif (!map) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_map;\n\t\t}\n\t\tkobject_init(&map->kobj, &map_attr_type);\n\t\tmap->mem = mem;\n\t\tmem->map = map;\n\t\tret = kobject_add(&map->kobj, idev->map_dir, \"map%d\", mi);\n\t\tif (ret)\n\t\t\tgoto err_map_kobj;\n\t\tret = kobject_uevent(&map->kobj, KOBJ_ADD);\n\t\tif (ret)\n\t\t\tgoto err_map_kobj;\n\t}\n\n\tfor (pi = 0; pi < MAX_UIO_PORT_REGIONS; pi++) {\n\t\tport = &idev->info->port[pi];\n\t\tif (port->size == 0)\n\t\t\tbreak;\n\t\tif (!portio_found) {\n\t\t\tportio_found = 1;\n\t\t\tidev->portio_dir = kobject_create_and_add(\"portio\",\n\t\t\t\t\t\t\t&idev->dev.kobj);\n\t\t\tif (!idev->portio_dir) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_portio;\n\t\t\t}\n\t\t}\n\t\tportio = kzalloc(sizeof(*portio), GFP_KERNEL);\n\t\tif (!portio) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_portio;\n\t\t}\n\t\tkobject_init(&portio->kobj, &portio_attr_type);\n\t\tportio->port = port;\n\t\tport->portio = portio;\n\t\tret = kobject_add(&portio->kobj, idev->portio_dir,\n\t\t\t\t\t\t\t\"port%d\", pi);\n\t\tif (ret)\n\t\t\tgoto err_portio_kobj;\n\t\tret = kobject_uevent(&portio->kobj, KOBJ_ADD);\n\t\tif (ret)\n\t\t\tgoto err_portio_kobj;\n\t}\n\n\treturn 0;\n\nerr_portio:\n\tpi--;\nerr_portio_kobj:\n\tfor (; pi >= 0; pi--) {\n\t\tport = &idev->info->port[pi];\n\t\tportio = port->portio;\n\t\tkobject_put(&portio->kobj);\n\t}\n\tkobject_put(idev->portio_dir);\nerr_map:\n\tmi--;\nerr_map_kobj:\n\tfor (; mi >= 0; mi--) {\n\t\tmem = &idev->info->mem[mi];\n\t\tmap = mem->map;\n\t\tkobject_put(&map->kobj);\n\t}\n\tkobject_put(idev->map_dir);\n\tdev_err(&idev->dev, \"error creating sysfs files (%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic void uio_dev_del_attributes(struct uio_device *idev)\n{\n\tint i;\n\tstruct uio_mem *mem;\n\tstruct uio_port *port;\n\n\tfor (i = 0; i < MAX_UIO_MAPS; i++) {\n\t\tmem = &idev->info->mem[i];\n\t\tif (mem->size == 0)\n\t\t\tbreak;\n\t\tkobject_put(&mem->map->kobj);\n\t}\n\tkobject_put(idev->map_dir);\n\n\tfor (i = 0; i < MAX_UIO_PORT_REGIONS; i++) {\n\t\tport = &idev->info->port[i];\n\t\tif (port->size == 0)\n\t\t\tbreak;\n\t\tkobject_put(&port->portio->kobj);\n\t}\n\tkobject_put(idev->portio_dir);\n}\n\nstatic int uio_get_minor(struct uio_device *idev)\n{\n\tint retval;\n\n\tmutex_lock(&minor_lock);\n\tretval = idr_alloc(&uio_idr, idev, 0, UIO_MAX_DEVICES, GFP_KERNEL);\n\tif (retval >= 0) {\n\t\tidev->minor = retval;\n\t\tretval = 0;\n\t} else if (retval == -ENOSPC) {\n\t\tdev_err(&idev->dev, \"too many uio devices\\n\");\n\t\tretval = -EINVAL;\n\t}\n\tmutex_unlock(&minor_lock);\n\treturn retval;\n}\n\nstatic void uio_free_minor(unsigned long minor)\n{\n\tmutex_lock(&minor_lock);\n\tidr_remove(&uio_idr, minor);\n\tmutex_unlock(&minor_lock);\n}\n\n \nvoid uio_event_notify(struct uio_info *info)\n{\n\tstruct uio_device *idev = info->uio_dev;\n\n\tatomic_inc(&idev->event);\n\twake_up_interruptible(&idev->wait);\n\tkill_fasync(&idev->async_queue, SIGIO, POLL_IN);\n}\nEXPORT_SYMBOL_GPL(uio_event_notify);\n\n \nstatic irqreturn_t uio_interrupt(int irq, void *dev_id)\n{\n\tstruct uio_device *idev = (struct uio_device *)dev_id;\n\tirqreturn_t ret;\n\n\tret = idev->info->handler(irq, idev->info);\n\tif (ret == IRQ_HANDLED)\n\t\tuio_event_notify(idev->info);\n\n\treturn ret;\n}\n\nstruct uio_listener {\n\tstruct uio_device *dev;\n\ts32 event_count;\n};\n\nstatic int uio_open(struct inode *inode, struct file *filep)\n{\n\tstruct uio_device *idev;\n\tstruct uio_listener *listener;\n\tint ret = 0;\n\n\tmutex_lock(&minor_lock);\n\tidev = idr_find(&uio_idr, iminor(inode));\n\tif (!idev) {\n\t\tret = -ENODEV;\n\t\tmutex_unlock(&minor_lock);\n\t\tgoto out;\n\t}\n\tget_device(&idev->dev);\n\tmutex_unlock(&minor_lock);\n\n\tif (!try_module_get(idev->owner)) {\n\t\tret = -ENODEV;\n\t\tgoto err_module_get;\n\t}\n\n\tlistener = kmalloc(sizeof(*listener), GFP_KERNEL);\n\tif (!listener) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_listener;\n\t}\n\n\tlistener->dev = idev;\n\tlistener->event_count = atomic_read(&idev->event);\n\tfilep->private_data = listener;\n\n\tmutex_lock(&idev->info_lock);\n\tif (!idev->info) {\n\t\tmutex_unlock(&idev->info_lock);\n\t\tret = -EINVAL;\n\t\tgoto err_infoopen;\n\t}\n\n\tif (idev->info->open)\n\t\tret = idev->info->open(idev->info, inode);\n\tmutex_unlock(&idev->info_lock);\n\tif (ret)\n\t\tgoto err_infoopen;\n\n\treturn 0;\n\nerr_infoopen:\n\tkfree(listener);\n\nerr_alloc_listener:\n\tmodule_put(idev->owner);\n\nerr_module_get:\n\tput_device(&idev->dev);\n\nout:\n\treturn ret;\n}\n\nstatic int uio_fasync(int fd, struct file *filep, int on)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\n\treturn fasync_helper(fd, filep, on, &idev->async_queue);\n}\n\nstatic int uio_release(struct inode *inode, struct file *filep)\n{\n\tint ret = 0;\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\n\tmutex_lock(&idev->info_lock);\n\tif (idev->info && idev->info->release)\n\t\tret = idev->info->release(idev->info, inode);\n\tmutex_unlock(&idev->info_lock);\n\n\tmodule_put(idev->owner);\n\tkfree(listener);\n\tput_device(&idev->dev);\n\treturn ret;\n}\n\nstatic __poll_t uio_poll(struct file *filep, poll_table *wait)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\t__poll_t ret = 0;\n\n\tmutex_lock(&idev->info_lock);\n\tif (!idev->info || !idev->info->irq)\n\t\tret = -EIO;\n\tmutex_unlock(&idev->info_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tpoll_wait(filep, &idev->wait, wait);\n\tif (listener->event_count != atomic_read(&idev->event))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}\n\nstatic ssize_t uio_read(struct file *filep, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t retval = 0;\n\ts32 event_count;\n\n\tif (count != sizeof(s32))\n\t\treturn -EINVAL;\n\n\tadd_wait_queue(&idev->wait, &wait);\n\n\tdo {\n\t\tmutex_lock(&idev->info_lock);\n\t\tif (!idev->info || !idev->info->irq) {\n\t\t\tretval = -EIO;\n\t\t\tmutex_unlock(&idev->info_lock);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&idev->info_lock);\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tevent_count = atomic_read(&idev->event);\n\t\tif (event_count != listener->event_count) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tif (copy_to_user(buf, &event_count, count))\n\t\t\t\tretval = -EFAULT;\n\t\t\telse {\n\t\t\t\tlistener->event_count = event_count;\n\t\t\t\tretval = count;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (filep->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t} while (1);\n\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&idev->wait, &wait);\n\n\treturn retval;\n}\n\nstatic ssize_t uio_write(struct file *filep, const char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\tssize_t retval;\n\ts32 irq_on;\n\n\tif (count != sizeof(s32))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&irq_on, buf, count))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&idev->info_lock);\n\tif (!idev->info) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!idev->info->irq) {\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (!idev->info->irqcontrol) {\n\t\tretval = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\tretval = idev->info->irqcontrol(idev->info, irq_on);\n\nout:\n\tmutex_unlock(&idev->info_lock);\n\treturn retval ? retval : sizeof(s32);\n}\n\nstatic int uio_find_mem_index(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\n\tif (vma->vm_pgoff < MAX_UIO_MAPS) {\n\t\tif (idev->info->mem[vma->vm_pgoff].size == 0)\n\t\t\treturn -1;\n\t\treturn (int)vma->vm_pgoff;\n\t}\n\treturn -1;\n}\n\nstatic vm_fault_t uio_vma_fault(struct vm_fault *vmf)\n{\n\tstruct uio_device *idev = vmf->vma->vm_private_data;\n\tstruct page *page;\n\tunsigned long offset;\n\tvoid *addr;\n\tvm_fault_t ret = 0;\n\tint mi;\n\n\tmutex_lock(&idev->info_lock);\n\tif (!idev->info) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\n\tmi = uio_find_mem_index(vmf->vma);\n\tif (mi < 0) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\n\t \n\toffset = (vmf->pgoff - mi) << PAGE_SHIFT;\n\n\taddr = (void *)(unsigned long)idev->info->mem[mi].addr + offset;\n\tif (idev->info->mem[mi].memtype == UIO_MEM_LOGICAL)\n\t\tpage = virt_to_page(addr);\n\telse\n\t\tpage = vmalloc_to_page(addr);\n\tget_page(page);\n\tvmf->page = page;\n\nout:\n\tmutex_unlock(&idev->info_lock);\n\n\treturn ret;\n}\n\nstatic const struct vm_operations_struct uio_logical_vm_ops = {\n\t.fault = uio_vma_fault,\n};\n\nstatic int uio_mmap_logical(struct vm_area_struct *vma)\n{\n\tvm_flags_set(vma, VM_DONTEXPAND | VM_DONTDUMP);\n\tvma->vm_ops = &uio_logical_vm_ops;\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct uio_physical_vm_ops = {\n#ifdef CONFIG_HAVE_IOREMAP_PROT\n\t.access = generic_access_phys,\n#endif\n};\n\nstatic int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tstruct uio_mem *mem;\n\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\tmem = idev->info->mem + mi;\n\n\tif (mem->addr & ~PAGE_MASK)\n\t\treturn -ENODEV;\n\tif (vma->vm_end - vma->vm_start > mem->size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\tif (idev->info->mem[mi].memtype == UIO_MEM_PHYS)\n\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t \n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       mem->addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}\n\nstatic int uio_mmap(struct file *filep, struct vm_area_struct *vma)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\tint mi;\n\tunsigned long requested_pages, actual_pages;\n\tint ret = 0;\n\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\n\tvma->vm_private_data = idev;\n\n\tmutex_lock(&idev->info_lock);\n\tif (!idev->info) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmi = uio_find_mem_index(vma);\n\tif (mi < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trequested_pages = vma_pages(vma);\n\tactual_pages = ((idev->info->mem[mi].addr & ~PAGE_MASK)\n\t\t\t+ idev->info->mem[mi].size + PAGE_SIZE -1) >> PAGE_SHIFT;\n\tif (requested_pages > actual_pages) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (idev->info->mmap) {\n\t\tret = idev->info->mmap(idev->info, vma);\n\t\tgoto out;\n\t}\n\n\tswitch (idev->info->mem[mi].memtype) {\n\tcase UIO_MEM_IOVA:\n\tcase UIO_MEM_PHYS:\n\t\tret = uio_mmap_physical(vma);\n\t\tbreak;\n\tcase UIO_MEM_LOGICAL:\n\tcase UIO_MEM_VIRTUAL:\n\t\tret = uio_mmap_logical(vma);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n out:\n\tmutex_unlock(&idev->info_lock);\n\treturn ret;\n}\n\nstatic const struct file_operations uio_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= uio_open,\n\t.release\t= uio_release,\n\t.read\t\t= uio_read,\n\t.write\t\t= uio_write,\n\t.mmap\t\t= uio_mmap,\n\t.poll\t\t= uio_poll,\n\t.fasync\t\t= uio_fasync,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int uio_major_init(void)\n{\n\tstatic const char name[] = \"uio\";\n\tstruct cdev *cdev = NULL;\n\tdev_t uio_dev = 0;\n\tint result;\n\n\tresult = alloc_chrdev_region(&uio_dev, 0, UIO_MAX_DEVICES, name);\n\tif (result)\n\t\tgoto out;\n\n\tresult = -ENOMEM;\n\tcdev = cdev_alloc();\n\tif (!cdev)\n\t\tgoto out_unregister;\n\n\tcdev->owner = THIS_MODULE;\n\tcdev->ops = &uio_fops;\n\tkobject_set_name(&cdev->kobj, \"%s\", name);\n\n\tresult = cdev_add(cdev, uio_dev, UIO_MAX_DEVICES);\n\tif (result)\n\t\tgoto out_put;\n\n\tuio_major = MAJOR(uio_dev);\n\tuio_cdev = cdev;\n\treturn 0;\nout_put:\n\tkobject_put(&cdev->kobj);\nout_unregister:\n\tunregister_chrdev_region(uio_dev, UIO_MAX_DEVICES);\nout:\n\treturn result;\n}\n\nstatic void uio_major_cleanup(void)\n{\n\tunregister_chrdev_region(MKDEV(uio_major, 0), UIO_MAX_DEVICES);\n\tcdev_del(uio_cdev);\n}\n\nstatic int init_uio_class(void)\n{\n\tint ret;\n\n\t \n\tret = uio_major_init();\n\tif (ret)\n\t\tgoto exit;\n\n\tret = class_register(&uio_class);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"class_register failed for uio\\n\");\n\t\tgoto err_class_register;\n\t}\n\n\tuio_class_registered = true;\n\n\treturn 0;\n\nerr_class_register:\n\tuio_major_cleanup();\nexit:\n\treturn ret;\n}\n\nstatic void release_uio_class(void)\n{\n\tuio_class_registered = false;\n\tclass_unregister(&uio_class);\n\tuio_major_cleanup();\n}\n\nstatic void uio_device_release(struct device *dev)\n{\n\tstruct uio_device *idev = dev_get_drvdata(dev);\n\n\tkfree(idev);\n}\n\n \nint __uio_register_device(struct module *owner,\n\t\t\t  struct device *parent,\n\t\t\t  struct uio_info *info)\n{\n\tstruct uio_device *idev;\n\tint ret = 0;\n\n\tif (!uio_class_registered)\n\t\treturn -EPROBE_DEFER;\n\n\tif (!parent || !info || !info->name || !info->version)\n\t\treturn -EINVAL;\n\n\tinfo->uio_dev = NULL;\n\n\tidev = kzalloc(sizeof(*idev), GFP_KERNEL);\n\tif (!idev) {\n\t\treturn -ENOMEM;\n\t}\n\n\tidev->owner = owner;\n\tidev->info = info;\n\tmutex_init(&idev->info_lock);\n\tinit_waitqueue_head(&idev->wait);\n\tatomic_set(&idev->event, 0);\n\n\tret = uio_get_minor(idev);\n\tif (ret) {\n\t\tkfree(idev);\n\t\treturn ret;\n\t}\n\n\tdevice_initialize(&idev->dev);\n\tidev->dev.devt = MKDEV(uio_major, idev->minor);\n\tidev->dev.class = &uio_class;\n\tidev->dev.parent = parent;\n\tidev->dev.release = uio_device_release;\n\tdev_set_drvdata(&idev->dev, idev);\n\n\tret = dev_set_name(&idev->dev, \"uio%d\", idev->minor);\n\tif (ret)\n\t\tgoto err_device_create;\n\n\tret = device_add(&idev->dev);\n\tif (ret)\n\t\tgoto err_device_create;\n\n\tret = uio_dev_add_attributes(idev);\n\tif (ret)\n\t\tgoto err_uio_dev_add_attributes;\n\n\tinfo->uio_dev = idev;\n\n\tif (info->irq && (info->irq != UIO_IRQ_CUSTOM)) {\n\t\t \n\t\tret = request_irq(info->irq, uio_interrupt,\n\t\t\t\t  info->irq_flags, info->name, idev);\n\t\tif (ret) {\n\t\t\tinfo->uio_dev = NULL;\n\t\t\tgoto err_request_irq;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_request_irq:\n\tuio_dev_del_attributes(idev);\nerr_uio_dev_add_attributes:\n\tdevice_del(&idev->dev);\nerr_device_create:\n\tuio_free_minor(idev->minor);\n\tput_device(&idev->dev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__uio_register_device);\n\nstatic void devm_uio_unregister_device(struct device *dev, void *res)\n{\n\tuio_unregister_device(*(struct uio_info **)res);\n}\n\n \nint __devm_uio_register_device(struct module *owner,\n\t\t\t       struct device *parent,\n\t\t\t       struct uio_info *info)\n{\n\tstruct uio_info **ptr;\n\tint ret;\n\n\tptr = devres_alloc(devm_uio_unregister_device, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\t*ptr = info;\n\tret = __uio_register_device(owner, parent, info);\n\tif (ret) {\n\t\tdevres_free(ptr);\n\t\treturn ret;\n\t}\n\n\tdevres_add(parent, ptr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__devm_uio_register_device);\n\n \nvoid uio_unregister_device(struct uio_info *info)\n{\n\tstruct uio_device *idev;\n\tunsigned long minor;\n\n\tif (!info || !info->uio_dev)\n\t\treturn;\n\n\tidev = info->uio_dev;\n\tminor = idev->minor;\n\n\tmutex_lock(&idev->info_lock);\n\tuio_dev_del_attributes(idev);\n\n\tif (info->irq && info->irq != UIO_IRQ_CUSTOM)\n\t\tfree_irq(info->irq, idev);\n\n\tidev->info = NULL;\n\tmutex_unlock(&idev->info_lock);\n\n\twake_up_interruptible(&idev->wait);\n\tkill_fasync(&idev->async_queue, SIGIO, POLL_HUP);\n\n\tuio_free_minor(minor);\n\tdevice_unregister(&idev->dev);\n\n\treturn;\n}\nEXPORT_SYMBOL_GPL(uio_unregister_device);\n\nstatic int __init uio_init(void)\n{\n\treturn init_uio_class();\n}\n\nstatic void __exit uio_exit(void)\n{\n\trelease_uio_class();\n\tidr_destroy(&uio_idr);\n}\n\nmodule_init(uio_init)\nmodule_exit(uio_exit)\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}