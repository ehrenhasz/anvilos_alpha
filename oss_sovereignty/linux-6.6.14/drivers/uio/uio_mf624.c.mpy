{
  "module_name": "uio_mf624.c",
  "hash_id": "2f89d81764b8396bf9c049bb58c7c932e5f3252a6382fc9248b66210f251670b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/uio/uio_mf624.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/uio_driver.h>\n\n#define PCI_VENDOR_ID_HUMUSOFT\t\t0x186c\n#define PCI_DEVICE_ID_MF624\t\t0x0624\n#define PCI_SUBVENDOR_ID_HUMUSOFT\t0x186c\n#define PCI_SUBDEVICE_DEVICE\t\t0x0624\n\n \n#define INTCSR\t\t\t\t0x4C\n#define INTCSR_ADINT_ENABLE\t\t(1 << 0)\n#define INTCSR_CTR4INT_ENABLE\t\t(1 << 3)\n#define INTCSR_PCIINT_ENABLE\t\t(1 << 6)\n#define INTCSR_ADINT_STATUS\t\t(1 << 2)\n#define INTCSR_CTR4INT_STATUS\t\t(1 << 5)\n\nenum mf624_interrupt_source {ADC, CTR4, ALL};\n\nstatic void mf624_disable_interrupt(enum mf624_interrupt_source source,\n\t\t\t     struct uio_info *info)\n{\n\tvoid __iomem *INTCSR_reg = info->mem[0].internal_addr + INTCSR;\n\n\tswitch (source) {\n\tcase ADC:\n\t\tiowrite32(ioread32(INTCSR_reg)\n\t\t\t& ~(INTCSR_ADINT_ENABLE | INTCSR_PCIINT_ENABLE),\n\t\t\tINTCSR_reg);\n\t\tbreak;\n\n\tcase CTR4:\n\t\tiowrite32(ioread32(INTCSR_reg)\n\t\t\t& ~(INTCSR_CTR4INT_ENABLE | INTCSR_PCIINT_ENABLE),\n\t\t\tINTCSR_reg);\n\t\tbreak;\n\n\tcase ALL:\n\tdefault:\n\t\tiowrite32(ioread32(INTCSR_reg)\n\t\t\t& ~(INTCSR_ADINT_ENABLE | INTCSR_CTR4INT_ENABLE\n\t\t\t    | INTCSR_PCIINT_ENABLE),\n\t\t\tINTCSR_reg);\n\t\tbreak;\n\t}\n}\n\nstatic void mf624_enable_interrupt(enum mf624_interrupt_source source,\n\t\t\t    struct uio_info *info)\n{\n\tvoid __iomem *INTCSR_reg = info->mem[0].internal_addr + INTCSR;\n\n\tswitch (source) {\n\tcase ADC:\n\t\tiowrite32(ioread32(INTCSR_reg)\n\t\t\t| INTCSR_ADINT_ENABLE | INTCSR_PCIINT_ENABLE,\n\t\t\tINTCSR_reg);\n\t\tbreak;\n\n\tcase CTR4:\n\t\tiowrite32(ioread32(INTCSR_reg)\n\t\t\t| INTCSR_CTR4INT_ENABLE | INTCSR_PCIINT_ENABLE,\n\t\t\tINTCSR_reg);\n\t\tbreak;\n\n\tcase ALL:\n\tdefault:\n\t\tiowrite32(ioread32(INTCSR_reg)\n\t\t\t| INTCSR_ADINT_ENABLE | INTCSR_CTR4INT_ENABLE\n\t\t\t| INTCSR_PCIINT_ENABLE,\n\t\t\tINTCSR_reg);\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t mf624_irq_handler(int irq, struct uio_info *info)\n{\n\tvoid __iomem *INTCSR_reg = info->mem[0].internal_addr + INTCSR;\n\n\tif ((ioread32(INTCSR_reg) & INTCSR_ADINT_ENABLE)\n\t    && (ioread32(INTCSR_reg) & INTCSR_ADINT_STATUS)) {\n\t\tmf624_disable_interrupt(ADC, info);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif ((ioread32(INTCSR_reg) & INTCSR_CTR4INT_ENABLE)\n\t    && (ioread32(INTCSR_reg) & INTCSR_CTR4INT_STATUS)) {\n\t\tmf624_disable_interrupt(CTR4, info);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int mf624_irqcontrol(struct uio_info *info, s32 irq_on)\n{\n\tif (irq_on == 0)\n\t\tmf624_disable_interrupt(ALL, info);\n\telse if (irq_on == 1)\n\t\tmf624_enable_interrupt(ALL, info);\n\n\treturn 0;\n}\n\nstatic int mf624_setup_mem(struct pci_dev *dev, int bar, struct uio_mem *mem, const char *name)\n{\n\tresource_size_t start = pci_resource_start(dev, bar);\n\tresource_size_t len = pci_resource_len(dev, bar);\n\n\tmem->name = name;\n\tmem->addr = start & PAGE_MASK;\n\tmem->offs = start & ~PAGE_MASK;\n\tif (!mem->addr)\n\t\treturn -ENODEV;\n\tmem->size = ((start & ~PAGE_MASK) + len + PAGE_SIZE - 1) & PAGE_MASK;\n\tmem->memtype = UIO_MEM_PHYS;\n\tmem->internal_addr = pci_ioremap_bar(dev, bar);\n\tif (!mem->internal_addr)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int mf624_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct uio_info *info;\n\n\tinfo = devm_kzalloc(&dev->dev, sizeof(struct uio_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif (pci_enable_device(dev))\n\t\treturn -ENODEV;\n\n\tif (pci_request_regions(dev, \"mf624\"))\n\t\tgoto out_disable;\n\n\tinfo->name = \"mf624\";\n\tinfo->version = \"0.0.1\";\n\n\t \n\n\t \n\tif (mf624_setup_mem(dev, 0, &info->mem[0], \"PCI chipset, interrupts, status \"\n\t\t\t    \"bits, special functions\"))\n\t\tgoto out_release;\n\t \n\tif (mf624_setup_mem(dev, 2, &info->mem[1], \"ADC, DAC, DIO\"))\n\t\tgoto out_unmap0;\n\n\t \n\tif (mf624_setup_mem(dev, 4, &info->mem[2], \"Counter/timer chip\"))\n\t\tgoto out_unmap1;\n\n\tinfo->irq = dev->irq;\n\tinfo->irq_flags = IRQF_SHARED;\n\tinfo->handler = mf624_irq_handler;\n\n\tinfo->irqcontrol = mf624_irqcontrol;\n\n\tif (uio_register_device(&dev->dev, info))\n\t\tgoto out_unmap2;\n\n\tpci_set_drvdata(dev, info);\n\n\treturn 0;\n\nout_unmap2:\n\tiounmap(info->mem[2].internal_addr);\nout_unmap1:\n\tiounmap(info->mem[1].internal_addr);\nout_unmap0:\n\tiounmap(info->mem[0].internal_addr);\n\nout_release:\n\tpci_release_regions(dev);\n\nout_disable:\n\tpci_disable_device(dev);\n\n\treturn -ENODEV;\n}\n\nstatic void mf624_pci_remove(struct pci_dev *dev)\n{\n\tstruct uio_info *info = pci_get_drvdata(dev);\n\n\tmf624_disable_interrupt(ALL, info);\n\n\tuio_unregister_device(info);\n\tpci_release_regions(dev);\n\tpci_disable_device(dev);\n\n\tiounmap(info->mem[0].internal_addr);\n\tiounmap(info->mem[1].internal_addr);\n\tiounmap(info->mem[2].internal_addr);\n}\n\nstatic const struct pci_device_id mf624_pci_id[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HUMUSOFT, PCI_DEVICE_ID_MF624) },\n\t{ 0, }\n};\n\nstatic struct pci_driver mf624_pci_driver = {\n\t.name = \"mf624\",\n\t.id_table = mf624_pci_id,\n\t.probe = mf624_pci_probe,\n\t.remove = mf624_pci_remove,\n};\nMODULE_DEVICE_TABLE(pci, mf624_pci_id);\n\nmodule_pci_driver(mf624_pci_driver);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Rostislav Lisovy <lisovy@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}