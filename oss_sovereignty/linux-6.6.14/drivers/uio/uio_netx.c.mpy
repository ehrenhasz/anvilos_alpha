{
  "module_name": "uio_netx.c",
  "hash_id": "e9616691d3d7f6846d9ebb84888948b0beaa00074da6ed3f71f38a22ec3d16e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/uio/uio_netx.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/uio_driver.h>\n\n#define PCI_VENDOR_ID_HILSCHER\t\t0x15CF\n#define PCI_DEVICE_ID_HILSCHER_NETX\t0x0000\n#define PCI_DEVICE_ID_HILSCHER_NETPLC\t0x0010\n#define PCI_SUBDEVICE_ID_NETPLC_RAM\t0x0000\n#define PCI_SUBDEVICE_ID_NETPLC_FLASH\t0x0001\n#define PCI_SUBDEVICE_ID_NXSB_PCA\t0x3235\n#define PCI_SUBDEVICE_ID_NXPCA\t\t0x3335\n\n#define DPM_HOST_INT_EN0\t0xfff0\n#define DPM_HOST_INT_STAT0\t0xffe0\n\n#define DPM_HOST_INT_MASK\t0xe600ffff\n#define DPM_HOST_INT_GLOBAL_EN\t0x80000000\n\nstatic irqreturn_t netx_handler(int irq, struct uio_info *dev_info)\n{\n\tvoid __iomem *int_enable_reg = dev_info->mem[0].internal_addr\n\t\t\t\t\t+ DPM_HOST_INT_EN0;\n\tvoid __iomem *int_status_reg = dev_info->mem[0].internal_addr\n\t\t\t\t\t+ DPM_HOST_INT_STAT0;\n\n\t \n\tif (!(ioread32(int_enable_reg) & ioread32(int_status_reg)\n\t\t& DPM_HOST_INT_MASK))\n\t\treturn IRQ_NONE;\n\n\t \n\tiowrite32(ioread32(int_enable_reg) & ~DPM_HOST_INT_GLOBAL_EN,\n\t\tint_enable_reg);\n\treturn IRQ_HANDLED;\n}\n\nstatic int netx_pci_probe(struct pci_dev *dev,\n\t\t\t\t\tconst struct pci_device_id *id)\n{\n\tstruct uio_info *info;\n\tint bar;\n\n\tinfo = devm_kzalloc(&dev->dev, sizeof(struct uio_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif (pci_enable_device(dev))\n\t\treturn -ENODEV;\n\n\tif (pci_request_regions(dev, \"netx\"))\n\t\tgoto out_disable;\n\n\tswitch (id->device) {\n\tcase PCI_DEVICE_ID_HILSCHER_NETX:\n\t\tbar = 0;\n\t\tinfo->name = \"netx\";\n\t\tbreak;\n\tcase PCI_DEVICE_ID_HILSCHER_NETPLC:\n\t\tbar = 0;\n\t\tinfo->name = \"netplc\";\n\t\tbreak;\n\tdefault:\n\t\tbar = 2;\n\t\tinfo->name = \"netx_plx\";\n\t}\n\n\t \n\tinfo->mem[0].addr = pci_resource_start(dev, bar);\n\tif (!info->mem[0].addr)\n\t\tgoto out_release;\n\tinfo->mem[0].internal_addr = ioremap(pci_resource_start(dev, bar),\n\t\t\t\t\t\tpci_resource_len(dev, bar));\n\n\tif (!info->mem[0].internal_addr)\n\t\t\tgoto out_release;\n\n\tinfo->mem[0].size = pci_resource_len(dev, bar);\n\tinfo->mem[0].memtype = UIO_MEM_PHYS;\n\tinfo->irq = dev->irq;\n\tinfo->irq_flags = IRQF_SHARED;\n\tinfo->handler = netx_handler;\n\tinfo->version = \"0.0.1\";\n\n\t \n\tiowrite32(0, info->mem[0].internal_addr + DPM_HOST_INT_EN0);\n\n\tif (uio_register_device(&dev->dev, info))\n\t\tgoto out_unmap;\n\n\tpci_set_drvdata(dev, info);\n\tdev_info(&dev->dev, \"Found %s card, registered UIO device.\\n\",\n\t\t\t\tinfo->name);\n\n\treturn 0;\n\nout_unmap:\n\tiounmap(info->mem[0].internal_addr);\nout_release:\n\tpci_release_regions(dev);\nout_disable:\n\tpci_disable_device(dev);\n\treturn -ENODEV;\n}\n\nstatic void netx_pci_remove(struct pci_dev *dev)\n{\n\tstruct uio_info *info = pci_get_drvdata(dev);\n\n\t \n\tiowrite32(0, info->mem[0].internal_addr + DPM_HOST_INT_EN0);\n\tuio_unregister_device(info);\n\tpci_release_regions(dev);\n\tpci_disable_device(dev);\n\tiounmap(info->mem[0].internal_addr);\n}\n\nstatic struct pci_device_id netx_pci_ids[] = {\n\t{\n\t\t.vendor =\tPCI_VENDOR_ID_HILSCHER,\n\t\t.device =\tPCI_DEVICE_ID_HILSCHER_NETX,\n\t\t.subvendor =\t0,\n\t\t.subdevice =\t0,\n\t},\n\t{\n\t\t.vendor =       PCI_VENDOR_ID_HILSCHER,\n\t\t.device =       PCI_DEVICE_ID_HILSCHER_NETPLC,\n\t\t.subvendor =    PCI_VENDOR_ID_HILSCHER,\n\t\t.subdevice =    PCI_SUBDEVICE_ID_NETPLC_RAM,\n\t},\n\t{\n\t\t.vendor =       PCI_VENDOR_ID_HILSCHER,\n\t\t.device =       PCI_DEVICE_ID_HILSCHER_NETPLC,\n\t\t.subvendor =    PCI_VENDOR_ID_HILSCHER,\n\t\t.subdevice =    PCI_SUBDEVICE_ID_NETPLC_FLASH,\n\t},\n\t{\n\t\t.vendor =\tPCI_VENDOR_ID_PLX,\n\t\t.device =\tPCI_DEVICE_ID_PLX_9030,\n\t\t.subvendor =\tPCI_VENDOR_ID_PLX,\n\t\t.subdevice =\tPCI_SUBDEVICE_ID_NXSB_PCA,\n\t},\n\t{\n\t\t.vendor =\tPCI_VENDOR_ID_PLX,\n\t\t.device =\tPCI_DEVICE_ID_PLX_9030,\n\t\t.subvendor =\tPCI_VENDOR_ID_PLX,\n\t\t.subdevice =\tPCI_SUBDEVICE_ID_NXPCA,\n\t},\n\t{ 0, }\n};\n\nstatic struct pci_driver netx_pci_driver = {\n\t.name = \"netx\",\n\t.id_table = netx_pci_ids,\n\t.probe = netx_pci_probe,\n\t.remove = netx_pci_remove,\n};\n\nmodule_pci_driver(netx_pci_driver);\nMODULE_DEVICE_TABLE(pci, netx_pci_ids);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Hans J. Koch, Manuel Traut\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}