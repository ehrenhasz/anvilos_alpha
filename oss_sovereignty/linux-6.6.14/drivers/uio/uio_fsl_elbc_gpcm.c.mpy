{
  "module_name": "uio_fsl_elbc_gpcm.c",
  "hash_id": "eeb01d6b0d2e9aefef8fc6b6bc656ced5315b560f4ab34fc7a2546197352fabe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/uio/uio_fsl_elbc_gpcm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/uio_driver.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <asm/fsl_lbc.h>\n\n#define MAX_BANKS 8\n\nstruct fsl_elbc_gpcm {\n\tstruct device *dev;\n\tstruct fsl_lbc_regs __iomem *lbc;\n\tu32 bank;\n\tconst char *name;\n\n\tvoid (*init)(struct uio_info *info);\n\tvoid (*shutdown)(struct uio_info *info, bool init_err);\n\tirqreturn_t (*irq_handler)(int irq, struct uio_info *info);\n};\n\nstatic ssize_t reg_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf);\nstatic ssize_t reg_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count);\n\nstatic DEVICE_ATTR(reg_br, 0664, reg_show, reg_store);\nstatic DEVICE_ATTR(reg_or, 0664, reg_show, reg_store);\n\nstatic struct attribute *uio_fsl_elbc_gpcm_attrs[] = {\n\t&dev_attr_reg_br.attr,\n\t&dev_attr_reg_or.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(uio_fsl_elbc_gpcm);\n\nstatic ssize_t reg_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct uio_info *info = dev_get_drvdata(dev);\n\tstruct fsl_elbc_gpcm *priv = info->priv;\n\tstruct fsl_lbc_bank *bank = &priv->lbc->bank[priv->bank];\n\n\tif (attr == &dev_attr_reg_br) {\n\t\treturn scnprintf(buf, PAGE_SIZE, \"0x%08x\\n\",\n\t\t\t\t in_be32(&bank->br));\n\n\t} else if (attr == &dev_attr_reg_or) {\n\t\treturn scnprintf(buf, PAGE_SIZE, \"0x%08x\\n\",\n\t\t\t\t in_be32(&bank->or));\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t reg_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct uio_info *info = dev_get_drvdata(dev);\n\tstruct fsl_elbc_gpcm *priv = info->priv;\n\tstruct fsl_lbc_bank *bank = &priv->lbc->bank[priv->bank];\n\tunsigned long val;\n\tu32 reg_br_cur;\n\tu32 reg_or_cur;\n\tu32 reg_new;\n\n\t \n\tif (kstrtoul(buf, 0, &val) != 0)\n\t\treturn -EINVAL;\n\treg_new = (u32)val;\n\n\t \n\treg_br_cur = in_be32(&bank->br);\n\treg_or_cur = in_be32(&bank->or);\n\n\tif (attr == &dev_attr_reg_br) {\n\t\t \n\t\tif ((reg_br_cur & reg_or_cur & BR_BA) !=\n\t\t    (reg_new & reg_or_cur & BR_BA)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif ((reg_new & BR_MSEL) != BR_MS_GPCM)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tout_be32(&bank->br, reg_new | BR_V);\n\n\t} else if (attr == &dev_attr_reg_or) {\n\t\t \n\t\tif ((reg_or_cur & OR_GPCM_AM) != (reg_new & OR_GPCM_AM))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tout_be32(&bank->or, reg_new);\n\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\n#ifdef CONFIG_UIO_FSL_ELBC_GPCM_NETX5152\n#define DPM_HOST_WIN0_OFFSET\t0xff00\n#define DPM_HOST_INT_STAT0\t0xe0\n#define DPM_HOST_INT_EN0\t0xf0\n#define DPM_HOST_INT_MASK\t0xe600ffff\n#define DPM_HOST_INT_GLOBAL_EN\t0x80000000\n\nstatic irqreturn_t netx5152_irq_handler(int irq, struct uio_info *info)\n{\n\tvoid __iomem *reg_int_en = info->mem[0].internal_addr +\n\t\t\t\t\tDPM_HOST_WIN0_OFFSET +\n\t\t\t\t\tDPM_HOST_INT_EN0;\n\tvoid __iomem *reg_int_stat = info->mem[0].internal_addr +\n\t\t\t\t\tDPM_HOST_WIN0_OFFSET +\n\t\t\t\t\tDPM_HOST_INT_STAT0;\n\n\t \n\tif ((ioread32(reg_int_en) & ioread32(reg_int_stat) &\n\t     DPM_HOST_INT_MASK) == 0) {\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tiowrite32(ioread32(reg_int_en) & ~DPM_HOST_INT_GLOBAL_EN, reg_int_en);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void netx5152_init(struct uio_info *info)\n{\n\tunsigned long win0_offset = DPM_HOST_WIN0_OFFSET;\n\tstruct fsl_elbc_gpcm *priv = info->priv;\n\tconst void *prop;\n\n\t \n\tprop = of_get_property(priv->dev->of_node,\n\t\t\t       \"netx5152,init-win0-offset\", NULL);\n\tif (prop)\n\t\twin0_offset = of_read_ulong(prop, 1);\n\n\t \n\tiowrite32(0, info->mem[0].internal_addr + win0_offset +\n\t\t     DPM_HOST_INT_EN0);\n}\n\nstatic void netx5152_shutdown(struct uio_info *info, bool init_err)\n{\n\tif (init_err)\n\t\treturn;\n\n\t \n\tiowrite32(0, info->mem[0].internal_addr + DPM_HOST_WIN0_OFFSET +\n\t\t     DPM_HOST_INT_EN0);\n}\n#endif\n\nstatic void setup_periph(struct fsl_elbc_gpcm *priv,\n\t\t\t\t   const char *type)\n{\n#ifdef CONFIG_UIO_FSL_ELBC_GPCM_NETX5152\n\tif (strcmp(type, \"netx5152\") == 0) {\n\t\tpriv->irq_handler = netx5152_irq_handler;\n\t\tpriv->init = netx5152_init;\n\t\tpriv->shutdown = netx5152_shutdown;\n\t\tpriv->name = \"netX 51/52\";\n\t\treturn;\n\t}\n#endif\n}\n\nstatic int check_of_data(struct fsl_elbc_gpcm *priv,\n\t\t\t\t   struct resource *res,\n\t\t\t\t   u32 reg_br, u32 reg_or)\n{\n\t \n\tif (priv->bank >= MAX_BANKS) {\n\t\tdev_err(priv->dev, \"invalid bank\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif ((reg_br & BR_MSEL) != BR_MS_GPCM) {\n\t\tdev_err(priv->dev, \"unsupported mode\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif ((~(reg_or & OR_GPCM_AM) + 1) != resource_size(res)) {\n\t\tdev_err(priv->dev, \"address mask / size mismatch\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif ((reg_br & reg_or & BR_BA) != fsl_lbc_addr(res->start)) {\n\t\tdev_err(priv->dev, \"base address mismatch\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_of_data(struct fsl_elbc_gpcm *priv, struct device_node *node,\n\t\t       struct resource *res, u32 *reg_br,\n\t\t       u32 *reg_or, unsigned int *irq, char **name)\n{\n\tconst char *dt_name;\n\tconst char *type;\n\tint ret;\n\n\t \n\tret = of_address_to_resource(node, 0, res);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to get resource\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = of_property_read_u32(node, \"reg\", &priv->bank);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to get bank number\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = of_property_read_u32(node, \"elbc-gpcm-br\", reg_br);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"missing elbc-gpcm-br value\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = of_property_read_u32(node, \"elbc-gpcm-or\", reg_or);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"missing elbc-gpcm-or value\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpriv->name = \"generic\";\n\tif (of_property_read_string(node, \"device_type\", &type) == 0)\n\t\tsetup_periph(priv, type);\n\n\t \n\t*irq = irq_of_parse_and_map(node, 0);\n\n\t \n\tret = check_of_data(priv, res, *reg_br, *reg_or);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (of_property_read_string(node, \"uio_name\", &dt_name) != 0)\n\t\tdt_name = \"eLBC_GPCM\";\n\t*name = devm_kstrdup(priv->dev, dt_name, GFP_KERNEL);\n\tif (!*name)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int uio_fsl_elbc_gpcm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct fsl_elbc_gpcm *priv;\n\tstruct uio_info *info;\n\tchar *uio_name = NULL;\n\tstruct resource res;\n\tunsigned int irq;\n\tu32 reg_br_cur;\n\tu32 reg_or_cur;\n\tu32 reg_br_new;\n\tu32 reg_or_new;\n\tint ret;\n\n\tif (!fsl_lbc_ctrl_dev || !fsl_lbc_ctrl_dev->regs)\n\t\treturn -ENODEV;\n\n\t \n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->dev = &pdev->dev;\n\tpriv->lbc = fsl_lbc_ctrl_dev->regs;\n\n\t \n\tret = get_of_data(priv, node, &res, &reg_br_new, &reg_or_new,\n\t\t\t  &irq, &uio_name);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\t \n\treg_br_cur = in_be32(&priv->lbc->bank[priv->bank].br);\n\treg_or_cur = in_be32(&priv->lbc->bank[priv->bank].or);\n\n\t \n\tif ((reg_br_cur & BR_V)) {\n\t\tif ((reg_br_cur & BR_MSEL) != BR_MS_GPCM ||\n\t\t    (reg_br_cur & reg_or_cur & BR_BA)\n\t\t     != fsl_lbc_addr(res.start)) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"bank in use by another peripheral\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tif ((reg_br_cur & ~(BR_BA | BR_V)) !=\n\t\t    (reg_br_new & ~(BR_BA | BR_V))) {\n\t\t\tdev_warn(priv->dev,\n\t\t\t\t \"modifying BR settings: 0x%08x -> 0x%08x\",\n\t\t\t\t reg_br_cur, reg_br_new);\n\t\t}\n\t\tif ((reg_or_cur & ~OR_GPCM_AM) != (reg_or_new & ~OR_GPCM_AM)) {\n\t\t\tdev_warn(priv->dev,\n\t\t\t\t \"modifying OR settings: 0x%08x -> 0x%08x\",\n\t\t\t\t reg_or_cur, reg_or_new);\n\t\t}\n\t}\n\n\t \n\treg_br_new &= ~(BR_BA | BR_MSEL);\n\treg_br_new |= fsl_lbc_addr(res.start) | BR_MS_GPCM | BR_V;\n\tout_be32(&priv->lbc->bank[priv->bank].or, reg_or_new);\n\tout_be32(&priv->lbc->bank[priv->bank].br, reg_br_new);\n\n\t \n\tinfo->mem[0].internal_addr = ioremap(res.start, resource_size(&res));\n\tif (!info->mem[0].internal_addr) {\n\t\tdev_err(priv->dev, \"failed to map chip region\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tinfo->mem[0].name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"%pOFn\", node);\n\tinfo->mem[0].addr = res.start;\n\tinfo->mem[0].size = resource_size(&res);\n\tinfo->mem[0].memtype = UIO_MEM_PHYS;\n\tinfo->priv = priv;\n\tinfo->name = uio_name;\n\tinfo->version = \"0.0.1\";\n\tif (irq) {\n\t\tif (priv->irq_handler) {\n\t\t\tinfo->irq = irq;\n\t\t\tinfo->irq_flags = IRQF_SHARED;\n\t\t\tinfo->handler = priv->irq_handler;\n\t\t} else {\n\t\t\tirq = 0;\n\t\t\tdev_warn(priv->dev, \"ignoring irq, no handler\\n\");\n\t\t}\n\t}\n\n\tif (priv->init)\n\t\tpriv->init(info);\n\n\t \n\tif (uio_register_device(priv->dev, info) != 0) {\n\t\tdev_err(priv->dev, \"UIO registration failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_err2;\n\t}\n\n\t \n\tplatform_set_drvdata(pdev, info);\n\n\tdev_info(priv->dev,\n\t\t \"eLBC/GPCM device (%s) at 0x%llx, bank %d, irq=%d\\n\",\n\t\t priv->name, (unsigned long long)res.start, priv->bank,\n\t\t irq ? : -1);\n\n\treturn 0;\nout_err2:\n\tif (priv->shutdown)\n\t\tpriv->shutdown(info, true);\n\tiounmap(info->mem[0].internal_addr);\n\treturn ret;\n}\n\nstatic int uio_fsl_elbc_gpcm_remove(struct platform_device *pdev)\n{\n\tstruct uio_info *info = platform_get_drvdata(pdev);\n\tstruct fsl_elbc_gpcm *priv = info->priv;\n\n\tplatform_set_drvdata(pdev, NULL);\n\tuio_unregister_device(info);\n\tif (priv->shutdown)\n\t\tpriv->shutdown(info, false);\n\tiounmap(info->mem[0].internal_addr);\n\n\treturn 0;\n\n}\n\nstatic const struct of_device_id uio_fsl_elbc_gpcm_match[] = {\n\t{ .compatible = \"fsl,elbc-gpcm-uio\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, uio_fsl_elbc_gpcm_match);\n\nstatic struct platform_driver uio_fsl_elbc_gpcm_driver = {\n\t.driver = {\n\t\t.name = \"fsl,elbc-gpcm-uio\",\n\t\t.of_match_table = uio_fsl_elbc_gpcm_match,\n\t\t.dev_groups = uio_fsl_elbc_gpcm_groups,\n\t},\n\t.probe = uio_fsl_elbc_gpcm_probe,\n\t.remove = uio_fsl_elbc_gpcm_remove,\n};\nmodule_platform_driver(uio_fsl_elbc_gpcm_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"John Ogness <john.ogness@linutronix.de>\");\nMODULE_DESCRIPTION(\"Freescale Enhanced Local Bus Controller GPCM driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}