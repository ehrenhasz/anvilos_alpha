{
  "module_name": "uio_pci_generic.c",
  "hash_id": "2b805752dd1984596c7fd31497015db455b8a926a3e5f7fa1076bb2f1ad7bf6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/uio/uio_pci_generic.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/uio_driver.h>\n\n#define DRIVER_VERSION\t\"0.01.0\"\n#define DRIVER_AUTHOR\t\"Michael S. Tsirkin <mst@redhat.com>\"\n#define DRIVER_DESC\t\"Generic UIO driver for PCI 2.3 devices\"\n\nstruct uio_pci_generic_dev {\n\tstruct uio_info info;\n\tstruct pci_dev *pdev;\n};\n\nstatic inline struct uio_pci_generic_dev *\nto_uio_pci_generic_dev(struct uio_info *info)\n{\n\treturn container_of(info, struct uio_pci_generic_dev, info);\n}\n\nstatic int release(struct uio_info *info, struct inode *inode)\n{\n\tstruct uio_pci_generic_dev *gdev = to_uio_pci_generic_dev(info);\n\n\t \n\tpci_clear_master(gdev->pdev);\n\treturn 0;\n}\n\n \nstatic irqreturn_t irqhandler(int irq, struct uio_info *info)\n{\n\tstruct uio_pci_generic_dev *gdev = to_uio_pci_generic_dev(info);\n\n\tif (!pci_check_and_mask_intx(gdev->pdev))\n\t\treturn IRQ_NONE;\n\n\t \n\treturn IRQ_HANDLED;\n}\n\nstatic int probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *id)\n{\n\tstruct uio_pci_generic_dev *gdev;\n\tstruct uio_mem *uiomem;\n\tint err;\n\tint i;\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"%s: pci_enable_device failed: %d\\n\",\n\t\t\t__func__, err);\n\t\treturn err;\n\t}\n\n\tif (pdev->irq && !pci_intx_mask_supported(pdev))\n\t\treturn -ENODEV;\n\n\tgdev = devm_kzalloc(&pdev->dev, sizeof(struct uio_pci_generic_dev), GFP_KERNEL);\n\tif (!gdev)\n\t\treturn -ENOMEM;\n\n\tgdev->info.name = \"uio_pci_generic\";\n\tgdev->info.version = DRIVER_VERSION;\n\tgdev->info.release = release;\n\tgdev->pdev = pdev;\n\tif (pdev->irq && (pdev->irq != IRQ_NOTCONNECTED)) {\n\t\tgdev->info.irq = pdev->irq;\n\t\tgdev->info.irq_flags = IRQF_SHARED;\n\t\tgdev->info.handler = irqhandler;\n\t} else {\n\t\tdev_warn(&pdev->dev, \"No IRQ assigned to device: \"\n\t\t\t \"no support for interrupts?\\n\");\n\t}\n\n\tuiomem = &gdev->info.mem[0];\n\tfor (i = 0; i < MAX_UIO_MAPS; ++i) {\n\t\tstruct resource *r = &pdev->resource[i];\n\n\t\tif (r->flags != (IORESOURCE_SIZEALIGN | IORESOURCE_MEM))\n\t\t\tcontinue;\n\n\t\tif (uiomem >= &gdev->info.mem[MAX_UIO_MAPS]) {\n\t\t\tdev_warn(\n\t\t\t\t&pdev->dev,\n\t\t\t\t\"device has more than \" __stringify(\n\t\t\t\t\tMAX_UIO_MAPS) \" I/O memory resources.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tuiomem->memtype = UIO_MEM_PHYS;\n\t\tuiomem->addr = r->start & PAGE_MASK;\n\t\tuiomem->offs = r->start & ~PAGE_MASK;\n\t\tuiomem->size =\n\t\t\t(uiomem->offs + resource_size(r) + PAGE_SIZE - 1) &\n\t\t\tPAGE_MASK;\n\t\tuiomem->name = r->name;\n\t\t++uiomem;\n\t}\n\n\twhile (uiomem < &gdev->info.mem[MAX_UIO_MAPS]) {\n\t\tuiomem->size = 0;\n\t\t++uiomem;\n\t}\n\n\treturn devm_uio_register_device(&pdev->dev, &gdev->info);\n}\n\nstatic struct pci_driver uio_pci_driver = {\n\t.name = \"uio_pci_generic\",\n\t.id_table = NULL,  \n\t.probe = probe,\n};\n\nmodule_pci_driver(uio_pci_driver);\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}