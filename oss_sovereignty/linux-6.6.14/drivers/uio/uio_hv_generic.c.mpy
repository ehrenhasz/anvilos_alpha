{
  "module_name": "uio_hv_generic.c",
  "hash_id": "f4ae043e8eaa123d1992066fe7f5a7bc2730177b5ea48079da22d188b4fbfadd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/uio/uio_hv_generic.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/uio_driver.h>\n#include <linux/netdevice.h>\n#include <linux/if_ether.h>\n#include <linux/skbuff.h>\n#include <linux/hyperv.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n\n#include \"../hv/hyperv_vmbus.h\"\n\n#define DRIVER_VERSION\t\"0.02.1\"\n#define DRIVER_AUTHOR\t\"Stephen Hemminger <sthemmin at microsoft.com>\"\n#define DRIVER_DESC\t\"Generic UIO driver for VMBus devices\"\n\n#define HV_RING_SIZE\t 512\t \n#define SEND_BUFFER_SIZE (16 * 1024 * 1024)\n#define RECV_BUFFER_SIZE (31 * 1024 * 1024)\n\n \nenum hv_uio_map {\n\tTXRX_RING_MAP = 0,\n\tINT_PAGE_MAP,\n\tMON_PAGE_MAP,\n\tRECV_BUF_MAP,\n\tSEND_BUF_MAP\n};\n\nstruct hv_uio_private_data {\n\tstruct uio_info info;\n\tstruct hv_device *device;\n\tatomic_t refcnt;\n\n\tvoid\t*recv_buf;\n\tstruct vmbus_gpadl recv_gpadl;\n\tchar\trecv_name[32];\t \n\n\tvoid\t*send_buf;\n\tstruct vmbus_gpadl send_gpadl;\n\tchar\tsend_name[32];\n};\n\n \nstatic int\nhv_uio_irqcontrol(struct uio_info *info, s32 irq_state)\n{\n\tstruct hv_uio_private_data *pdata = info->priv;\n\tstruct hv_device *dev = pdata->device;\n\n\tdev->channel->inbound.ring_buffer->interrupt_mask = !irq_state;\n\tvirt_mb();\n\n\treturn 0;\n}\n\n \nstatic void hv_uio_channel_cb(void *context)\n{\n\tstruct vmbus_channel *chan = context;\n\tstruct hv_device *hv_dev = chan->device_obj;\n\tstruct hv_uio_private_data *pdata = hv_get_drvdata(hv_dev);\n\n\tchan->inbound.ring_buffer->interrupt_mask = 1;\n\tvirt_mb();\n\n\tuio_event_notify(&pdata->info);\n}\n\n \nstatic void hv_uio_rescind(struct vmbus_channel *channel)\n{\n\tstruct hv_device *hv_dev = channel->primary_channel->device_obj;\n\tstruct hv_uio_private_data *pdata = hv_get_drvdata(hv_dev);\n\n\t \n\tpdata->info.irq = 0;\n\n\t \n\tuio_event_notify(&pdata->info);\n}\n\n \nstatic int hv_uio_ring_mmap(struct file *filp, struct kobject *kobj,\n\t\t\t    struct bin_attribute *attr,\n\t\t\t    struct vm_area_struct *vma)\n{\n\tstruct vmbus_channel *channel\n\t\t= container_of(kobj, struct vmbus_channel, kobj);\n\tvoid *ring_buffer = page_address(channel->ringbuffer_page);\n\n\tif (channel->state != CHANNEL_OPENED_STATE)\n\t\treturn -ENODEV;\n\n\treturn vm_iomap_memory(vma, virt_to_phys(ring_buffer),\n\t\t\t       channel->ringbuffer_pagecount << PAGE_SHIFT);\n}\n\nstatic const struct bin_attribute ring_buffer_bin_attr = {\n\t.attr = {\n\t\t.name = \"ring\",\n\t\t.mode = 0600,\n\t},\n\t.size = 2 * HV_RING_SIZE * PAGE_SIZE,\n\t.mmap = hv_uio_ring_mmap,\n};\n\n \nstatic void\nhv_uio_new_channel(struct vmbus_channel *new_sc)\n{\n\tstruct hv_device *hv_dev = new_sc->primary_channel->device_obj;\n\tstruct device *device = &hv_dev->device;\n\tconst size_t ring_bytes = HV_RING_SIZE * PAGE_SIZE;\n\tint ret;\n\n\t \n\tret = vmbus_open(new_sc, ring_bytes, ring_bytes, NULL, 0,\n\t\t\t hv_uio_channel_cb, new_sc);\n\tif (ret) {\n\t\tdev_err(device, \"vmbus_open subchannel failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tnew_sc->inbound.ring_buffer->interrupt_mask = 1;\n\tset_channel_read_mode(new_sc, HV_CALL_ISR);\n\n\tret = sysfs_create_bin_file(&new_sc->kobj, &ring_buffer_bin_attr);\n\tif (ret) {\n\t\tdev_err(device, \"sysfs create ring bin file failed; %d\\n\", ret);\n\t\tvmbus_close(new_sc);\n\t}\n}\n\n \nstatic void\nhv_uio_cleanup(struct hv_device *dev, struct hv_uio_private_data *pdata)\n{\n\tif (pdata->send_gpadl.gpadl_handle) {\n\t\tvmbus_teardown_gpadl(dev->channel, &pdata->send_gpadl);\n\t\tvfree(pdata->send_buf);\n\t}\n\n\tif (pdata->recv_gpadl.gpadl_handle) {\n\t\tvmbus_teardown_gpadl(dev->channel, &pdata->recv_gpadl);\n\t\tvfree(pdata->recv_buf);\n\t}\n}\n\n \nstatic int\nhv_uio_open(struct uio_info *info, struct inode *inode)\n{\n\tstruct hv_uio_private_data *pdata\n\t\t= container_of(info, struct hv_uio_private_data, info);\n\tstruct hv_device *dev = pdata->device;\n\tint ret;\n\n\tif (atomic_inc_return(&pdata->refcnt) != 1)\n\t\treturn 0;\n\n\tvmbus_set_chn_rescind_callback(dev->channel, hv_uio_rescind);\n\tvmbus_set_sc_create_callback(dev->channel, hv_uio_new_channel);\n\n\tret = vmbus_connect_ring(dev->channel,\n\t\t\t\t hv_uio_channel_cb, dev->channel);\n\tif (ret == 0)\n\t\tdev->channel->inbound.ring_buffer->interrupt_mask = 1;\n\telse\n\t\tatomic_dec(&pdata->refcnt);\n\n\treturn ret;\n}\n\n \nstatic int\nhv_uio_release(struct uio_info *info, struct inode *inode)\n{\n\tstruct hv_uio_private_data *pdata\n\t\t= container_of(info, struct hv_uio_private_data, info);\n\tstruct hv_device *dev = pdata->device;\n\tint ret = 0;\n\n\tif (atomic_dec_and_test(&pdata->refcnt))\n\t\tret = vmbus_disconnect_ring(dev->channel);\n\n\treturn ret;\n}\n\nstatic int\nhv_uio_probe(struct hv_device *dev,\n\t     const struct hv_vmbus_device_id *dev_id)\n{\n\tstruct vmbus_channel *channel = dev->channel;\n\tstruct hv_uio_private_data *pdata;\n\tvoid *ring_buffer;\n\tint ret;\n\n\t \n\tif (!channel->offermsg.monitor_allocated) {\n\t\tdev_err(&dev->device, \"vmbus channel requires hypercall\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tpdata = devm_kzalloc(&dev->device, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tret = vmbus_alloc_ring(channel, HV_RING_SIZE * PAGE_SIZE,\n\t\t\t       HV_RING_SIZE * PAGE_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tset_channel_read_mode(channel, HV_CALL_ISR);\n\n\t \n\tpdata->info.name = \"uio_hv_generic\";\n\tpdata->info.version = DRIVER_VERSION;\n\tpdata->info.irqcontrol = hv_uio_irqcontrol;\n\tpdata->info.open = hv_uio_open;\n\tpdata->info.release = hv_uio_release;\n\tpdata->info.irq = UIO_IRQ_CUSTOM;\n\tatomic_set(&pdata->refcnt, 0);\n\n\t \n\tpdata->info.mem[TXRX_RING_MAP].name = \"txrx_rings\";\n\tring_buffer = page_address(channel->ringbuffer_page);\n\tpdata->info.mem[TXRX_RING_MAP].addr\n\t\t= (uintptr_t)virt_to_phys(ring_buffer);\n\tpdata->info.mem[TXRX_RING_MAP].size\n\t\t= channel->ringbuffer_pagecount << PAGE_SHIFT;\n\tpdata->info.mem[TXRX_RING_MAP].memtype = UIO_MEM_IOVA;\n\n\tpdata->info.mem[INT_PAGE_MAP].name = \"int_page\";\n\tpdata->info.mem[INT_PAGE_MAP].addr\n\t\t= (uintptr_t)vmbus_connection.int_page;\n\tpdata->info.mem[INT_PAGE_MAP].size = PAGE_SIZE;\n\tpdata->info.mem[INT_PAGE_MAP].memtype = UIO_MEM_LOGICAL;\n\n\tpdata->info.mem[MON_PAGE_MAP].name = \"monitor_page\";\n\tpdata->info.mem[MON_PAGE_MAP].addr\n\t\t= (uintptr_t)vmbus_connection.monitor_pages[1];\n\tpdata->info.mem[MON_PAGE_MAP].size = PAGE_SIZE;\n\tpdata->info.mem[MON_PAGE_MAP].memtype = UIO_MEM_LOGICAL;\n\n\tpdata->recv_buf = vzalloc(RECV_BUFFER_SIZE);\n\tif (pdata->recv_buf == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_free_ring;\n\t}\n\n\tret = vmbus_establish_gpadl(channel, pdata->recv_buf,\n\t\t\t\t    RECV_BUFFER_SIZE, &pdata->recv_gpadl);\n\tif (ret) {\n\t\tvfree(pdata->recv_buf);\n\t\tgoto fail_close;\n\t}\n\n\t \n\tsnprintf(pdata->recv_name, sizeof(pdata->recv_name),\n\t\t \"recv:%u\", pdata->recv_gpadl.gpadl_handle);\n\tpdata->info.mem[RECV_BUF_MAP].name = pdata->recv_name;\n\tpdata->info.mem[RECV_BUF_MAP].addr\n\t\t= (uintptr_t)pdata->recv_buf;\n\tpdata->info.mem[RECV_BUF_MAP].size = RECV_BUFFER_SIZE;\n\tpdata->info.mem[RECV_BUF_MAP].memtype = UIO_MEM_VIRTUAL;\n\n\tpdata->send_buf = vzalloc(SEND_BUFFER_SIZE);\n\tif (pdata->send_buf == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_close;\n\t}\n\n\tret = vmbus_establish_gpadl(channel, pdata->send_buf,\n\t\t\t\t    SEND_BUFFER_SIZE, &pdata->send_gpadl);\n\tif (ret) {\n\t\tvfree(pdata->send_buf);\n\t\tgoto fail_close;\n\t}\n\n\tsnprintf(pdata->send_name, sizeof(pdata->send_name),\n\t\t \"send:%u\", pdata->send_gpadl.gpadl_handle);\n\tpdata->info.mem[SEND_BUF_MAP].name = pdata->send_name;\n\tpdata->info.mem[SEND_BUF_MAP].addr\n\t\t= (uintptr_t)pdata->send_buf;\n\tpdata->info.mem[SEND_BUF_MAP].size = SEND_BUFFER_SIZE;\n\tpdata->info.mem[SEND_BUF_MAP].memtype = UIO_MEM_VIRTUAL;\n\n\tpdata->info.priv = pdata;\n\tpdata->device = dev;\n\n\tret = uio_register_device(&dev->device, &pdata->info);\n\tif (ret) {\n\t\tdev_err(&dev->device, \"hv_uio register failed\\n\");\n\t\tgoto fail_close;\n\t}\n\n\tret = sysfs_create_bin_file(&channel->kobj, &ring_buffer_bin_attr);\n\tif (ret)\n\t\tdev_notice(&dev->device,\n\t\t\t   \"sysfs create ring bin file failed; %d\\n\", ret);\n\n\thv_set_drvdata(dev, pdata);\n\n\treturn 0;\n\nfail_close:\n\thv_uio_cleanup(dev, pdata);\nfail_free_ring:\n\tvmbus_free_ring(dev->channel);\n\n\treturn ret;\n}\n\nstatic void\nhv_uio_remove(struct hv_device *dev)\n{\n\tstruct hv_uio_private_data *pdata = hv_get_drvdata(dev);\n\n\tif (!pdata)\n\t\treturn;\n\n\tsysfs_remove_bin_file(&dev->channel->kobj, &ring_buffer_bin_attr);\n\tuio_unregister_device(&pdata->info);\n\thv_uio_cleanup(dev, pdata);\n\n\tvmbus_free_ring(dev->channel);\n}\n\nstatic struct hv_driver hv_uio_drv = {\n\t.name = \"uio_hv_generic\",\n\t.id_table = NULL,  \n\t.probe = hv_uio_probe,\n\t.remove = hv_uio_remove,\n};\n\nstatic int __init\nhyperv_module_init(void)\n{\n\treturn vmbus_driver_register(&hv_uio_drv);\n}\n\nstatic void __exit\nhyperv_module_exit(void)\n{\n\tvmbus_driver_unregister(&hv_uio_drv);\n}\n\nmodule_init(hyperv_module_init);\nmodule_exit(hyperv_module_exit);\n\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}