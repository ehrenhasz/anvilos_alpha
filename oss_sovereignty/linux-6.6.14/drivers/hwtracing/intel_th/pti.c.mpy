{
  "module_name": "pti.c",
  "hash_id": "68c0207a7138a9ec2dd77b124568c0d2bd90a4c840265535ce7b50574d5411b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/intel_th/pti.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/sizes.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/io.h>\n\n#include \"intel_th.h\"\n#include \"pti.h\"\n\nstruct pti_device {\n\tvoid __iomem\t\t*base;\n\tstruct intel_th_device\t*thdev;\n\tunsigned int\t\tmode;\n\tunsigned int\t\tfreeclk;\n\tunsigned int\t\tclkdiv;\n\tunsigned int\t\tpatgen;\n\tunsigned int\t\tlpp_dest_mask;\n\tunsigned int\t\tlpp_dest;\n};\n\n \nstatic const unsigned int pti_mode[] = {\n\t0, 4, 8, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic int pti_width_mode(unsigned int width)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pti_mode); i++)\n\t\tif (pti_mode[i] == width)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t mode_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct pti_device *pti = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", pti_mode[pti->mode]);\n}\n\nstatic ssize_t mode_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t size)\n{\n\tstruct pti_device *pti = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pti_width_mode(val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpti->mode = ret;\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(mode);\n\nstatic ssize_t\nfreerunning_clock_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct pti_device *pti = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", pti->freeclk);\n}\n\nstatic ssize_t\nfreerunning_clock_store(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t size)\n{\n\tstruct pti_device *pti = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tpti->freeclk = !!val;\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(freerunning_clock);\n\nstatic ssize_t\nclock_divider_show(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct pti_device *pti = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", 1u << pti->clkdiv);\n}\n\nstatic ssize_t\nclock_divider_store(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t size)\n{\n\tstruct pti_device *pti = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!is_power_of_2(val) || val > 8 || !val)\n\t\treturn -EINVAL;\n\n\tpti->clkdiv = val;\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(clock_divider);\n\nstatic struct attribute *pti_output_attrs[] = {\n\t&dev_attr_mode.attr,\n\t&dev_attr_freerunning_clock.attr,\n\t&dev_attr_clock_divider.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group pti_output_group = {\n\t.attrs\t= pti_output_attrs,\n};\n\nstatic int intel_th_pti_activate(struct intel_th_device *thdev)\n{\n\tstruct pti_device *pti = dev_get_drvdata(&thdev->dev);\n\tu32 ctl = PTI_EN;\n\n\tif (pti->patgen)\n\t\tctl |= pti->patgen << __ffs(PTI_PATGENMODE);\n\tif (pti->freeclk)\n\t\tctl |= PTI_FCEN;\n\tctl |= pti->mode << __ffs(PTI_MODE);\n\tctl |= pti->clkdiv << __ffs(PTI_CLKDIV);\n\tctl |= pti->lpp_dest << __ffs(LPP_DEST);\n\n\tiowrite32(ctl, pti->base + REG_PTI_CTL);\n\n\tintel_th_trace_enable(thdev);\n\n\treturn 0;\n}\n\nstatic void intel_th_pti_deactivate(struct intel_th_device *thdev)\n{\n\tstruct pti_device *pti = dev_get_drvdata(&thdev->dev);\n\n\tintel_th_trace_disable(thdev);\n\n\tiowrite32(0, pti->base + REG_PTI_CTL);\n}\n\nstatic void read_hw_config(struct pti_device *pti)\n{\n\tu32 ctl = ioread32(pti->base + REG_PTI_CTL);\n\n\tpti->mode\t= (ctl & PTI_MODE) >> __ffs(PTI_MODE);\n\tpti->clkdiv\t= (ctl & PTI_CLKDIV) >> __ffs(PTI_CLKDIV);\n\tpti->freeclk\t= !!(ctl & PTI_FCEN);\n\n\tif (!pti_mode[pti->mode])\n\t\tpti->mode = pti_width_mode(4);\n\tif (!pti->clkdiv)\n\t\tpti->clkdiv = 1;\n\n\tif (pti->thdev->output.type == GTH_LPP) {\n\t\tif (ctl & LPP_PTIPRESENT)\n\t\t\tpti->lpp_dest_mask |= LPP_DEST_PTI;\n\t\tif (ctl & LPP_BSSBPRESENT)\n\t\t\tpti->lpp_dest_mask |= LPP_DEST_EXI;\n\t\tif (ctl & LPP_DEST)\n\t\t\tpti->lpp_dest = 1;\n\t}\n}\n\nstatic int intel_th_pti_probe(struct intel_th_device *thdev)\n{\n\tstruct device *dev = &thdev->dev;\n\tstruct resource *res;\n\tstruct pti_device *pti;\n\tvoid __iomem *base;\n\n\tres = intel_th_device_get_resource(thdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tbase = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\tpti = devm_kzalloc(dev, sizeof(*pti), GFP_KERNEL);\n\tif (!pti)\n\t\treturn -ENOMEM;\n\n\tpti->thdev = thdev;\n\tpti->base = base;\n\n\tread_hw_config(pti);\n\n\tdev_set_drvdata(dev, pti);\n\n\treturn 0;\n}\n\nstatic void intel_th_pti_remove(struct intel_th_device *thdev)\n{\n}\n\nstatic struct intel_th_driver intel_th_pti_driver = {\n\t.probe\t= intel_th_pti_probe,\n\t.remove\t= intel_th_pti_remove,\n\t.activate\t= intel_th_pti_activate,\n\t.deactivate\t= intel_th_pti_deactivate,\n\t.attr_group\t= &pti_output_group,\n\t.driver\t= {\n\t\t.name\t= \"pti\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n};\n\nstatic const char * const lpp_dest_str[] = { \"pti\", \"exi\" };\n\nstatic ssize_t lpp_dest_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct pti_device *pti = dev_get_drvdata(dev);\n\tssize_t ret = 0;\n\tint i;\n\n\tfor (i = ARRAY_SIZE(lpp_dest_str) - 1; i >= 0; i--) {\n\t\tconst char *fmt = pti->lpp_dest == i ? \"[%s] \" : \"%s \";\n\n\t\tif (!(pti->lpp_dest_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t fmt, lpp_dest_str[i]);\n\t}\n\n\tif (ret)\n\t\tbuf[ret - 1] = '\\n';\n\n\treturn ret;\n}\n\nstatic ssize_t lpp_dest_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tstruct pti_device *pti = dev_get_drvdata(dev);\n\tint i;\n\n\ti = sysfs_match_string(lpp_dest_str, buf);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (!(pti->lpp_dest_mask & BIT(i)))\n\t\treturn -EINVAL;\n\n\tpti->lpp_dest = i;\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(lpp_dest);\n\nstatic struct attribute *lpp_output_attrs[] = {\n\t&dev_attr_mode.attr,\n\t&dev_attr_freerunning_clock.attr,\n\t&dev_attr_clock_divider.attr,\n\t&dev_attr_lpp_dest.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group lpp_output_group = {\n\t.attrs\t= lpp_output_attrs,\n};\n\nstatic struct intel_th_driver intel_th_lpp_driver = {\n\t.probe\t\t= intel_th_pti_probe,\n\t.remove\t\t= intel_th_pti_remove,\n\t.activate\t= intel_th_pti_activate,\n\t.deactivate\t= intel_th_pti_deactivate,\n\t.attr_group\t= &lpp_output_group,\n\t.driver\t= {\n\t\t.name\t= \"lpp\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init intel_th_pti_lpp_init(void)\n{\n\tint err;\n\n\terr = intel_th_driver_register(&intel_th_pti_driver);\n\tif (err)\n\t\treturn err;\n\n\terr = intel_th_driver_register(&intel_th_lpp_driver);\n\tif (err) {\n\t\tintel_th_driver_unregister(&intel_th_pti_driver);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nmodule_init(intel_th_pti_lpp_init);\n\nstatic void __exit intel_th_pti_lpp_exit(void)\n{\n\tintel_th_driver_unregister(&intel_th_pti_driver);\n\tintel_th_driver_unregister(&intel_th_lpp_driver);\n}\n\nmodule_exit(intel_th_pti_lpp_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel(R) Trace Hub PTI/LPP output driver\");\nMODULE_AUTHOR(\"Alexander Shishkin <alexander.shishkin@linux.intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}