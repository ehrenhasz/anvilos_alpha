{
  "module_name": "msu-sink.c",
  "hash_id": "6ec5eabe95cff3998dd2dd0afbf7e61b8905b549d92c405e5e3759d31aa424b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/intel_th/msu-sink.c",
  "human_readable_source": "\n \n\n#include <linux/intel_th.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n\n#define MAX_SGTS 16\n\nstruct msu_sink_private {\n\tstruct device\t*dev;\n\tstruct sg_table **sgts;\n\tunsigned int\tnr_sgts;\n};\n\nstatic void *msu_sink_assign(struct device *dev, int *mode)\n{\n\tstruct msu_sink_private *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn NULL;\n\n\tpriv->sgts = kcalloc(MAX_SGTS, sizeof(void *), GFP_KERNEL);\n\tif (!priv->sgts) {\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\n\tpriv->dev = dev;\n\t*mode = MSC_MODE_MULTI;\n\n\treturn priv;\n}\n\nstatic void msu_sink_unassign(void *data)\n{\n\tstruct msu_sink_private *priv = data;\n\n\tkfree(priv->sgts);\n\tkfree(priv);\n}\n\n \nstatic int msu_sink_alloc_window(void *data, struct sg_table **sgt, size_t size)\n{\n\tstruct msu_sink_private *priv = data;\n\tunsigned int nents;\n\tstruct scatterlist *sg_ptr;\n\tvoid *block;\n\tint ret, i;\n\n\tif (priv->nr_sgts == MAX_SGTS)\n\t\treturn -ENOMEM;\n\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\n\tret = sg_alloc_table(*sgt, nents, GFP_KERNEL);\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\tpriv->sgts[priv->nr_sgts++] = *sgt;\n\n\tfor_each_sg((*sgt)->sgl, sg_ptr, nents, i) {\n\t\tblock = dma_alloc_coherent(priv->dev->parent->parent,\n\t\t\t\t\t   PAGE_SIZE, &sg_dma_address(sg_ptr),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!block)\n\t\t\treturn -ENOMEM;\n\n\t\tsg_set_buf(sg_ptr, block, PAGE_SIZE);\n\t}\n\n\treturn nents;\n}\n\n \nstatic void msu_sink_free_window(void *data, struct sg_table *sgt)\n{\n\tstruct msu_sink_private *priv = data;\n\tstruct scatterlist *sg_ptr;\n\tint i;\n\n\tfor_each_sg(sgt->sgl, sg_ptr, sgt->nents, i) {\n\t\tdma_free_coherent(priv->dev->parent->parent, PAGE_SIZE,\n\t\t\t\t  sg_virt(sg_ptr), sg_dma_address(sg_ptr));\n\t}\n\n\tsg_free_table(sgt);\n\tpriv->nr_sgts--;\n}\n\nstatic int msu_sink_ready(void *data, struct sg_table *sgt, size_t bytes)\n{\n\tstruct msu_sink_private *priv = data;\n\n\tintel_th_msc_window_unlock(priv->dev, sgt);\n\n\treturn 0;\n}\n\nstatic const struct msu_buffer sink_mbuf = {\n\t.name\t\t= \"sink\",\n\t.assign\t\t= msu_sink_assign,\n\t.unassign\t= msu_sink_unassign,\n\t.alloc_window\t= msu_sink_alloc_window,\n\t.free_window\t= msu_sink_free_window,\n\t.ready\t\t= msu_sink_ready,\n};\n\nmodule_intel_th_msu_buffer(sink_mbuf);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}