{
  "module_name": "pci.c",
  "hash_id": "4e2d053b4db63e60c65672e9a22570c05b9e58803c59ac14678149a1ac0066ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/intel_th/pci.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/pci.h>\n\n#include \"intel_th.h\"\n\n#define DRIVER_NAME \"intel_th_pci\"\n\nenum {\n\tTH_PCI_CONFIG_BAR\t= 0,\n\tTH_PCI_STH_SW_BAR\t= 2,\n\tTH_PCI_RTIT_BAR\t\t= 4,\n};\n\n#define BAR_MASK (BIT(TH_PCI_CONFIG_BAR) | BIT(TH_PCI_STH_SW_BAR))\n\n#define PCI_REG_NPKDSC\t0x80\n#define NPKDSC_TSACT\tBIT(5)\n\nstatic int intel_th_pci_activate(struct intel_th *th)\n{\n\tstruct pci_dev *pdev = to_pci_dev(th->dev);\n\tu32 npkdsc;\n\tint err;\n\n\tif (!INTEL_TH_CAP(th, tscu_enable))\n\t\treturn 0;\n\n\terr = pci_read_config_dword(pdev, PCI_REG_NPKDSC, &npkdsc);\n\tif (!err) {\n\t\tnpkdsc |= NPKDSC_TSACT;\n\t\terr = pci_write_config_dword(pdev, PCI_REG_NPKDSC, npkdsc);\n\t}\n\n\tif (err)\n\t\tdev_err(&pdev->dev, \"failed to read NPKDSC register\\n\");\n\n\treturn err;\n}\n\nstatic void intel_th_pci_deactivate(struct intel_th *th)\n{\n\tstruct pci_dev *pdev = to_pci_dev(th->dev);\n\tu32 npkdsc;\n\tint err;\n\n\tif (!INTEL_TH_CAP(th, tscu_enable))\n\t\treturn;\n\n\terr = pci_read_config_dword(pdev, PCI_REG_NPKDSC, &npkdsc);\n\tif (!err) {\n\t\tnpkdsc |= NPKDSC_TSACT;\n\t\terr = pci_write_config_dword(pdev, PCI_REG_NPKDSC, npkdsc);\n\t}\n\n\tif (err)\n\t\tdev_err(&pdev->dev, \"failed to read NPKDSC register\\n\");\n}\n\nstatic int intel_th_pci_probe(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *id)\n{\n\tconst struct intel_th_drvdata *drvdata = (void *)id->driver_data;\n\tstruct resource resource[TH_MMIO_END + TH_NVEC_MAX] = {\n\t\t[TH_MMIO_CONFIG]\t= pdev->resource[TH_PCI_CONFIG_BAR],\n\t\t[TH_MMIO_SW]\t\t= pdev->resource[TH_PCI_STH_SW_BAR],\n\t};\n\tint err, r = TH_MMIO_SW + 1, i;\n\tstruct intel_th *th;\n\n\terr = pcim_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = pcim_iomap_regions_request_all(pdev, BAR_MASK, DRIVER_NAME);\n\tif (err)\n\t\treturn err;\n\n\tif (pdev->resource[TH_PCI_RTIT_BAR].start) {\n\t\tresource[TH_MMIO_RTIT] = pdev->resource[TH_PCI_RTIT_BAR];\n\t\tr++;\n\t}\n\n\terr = pci_alloc_irq_vectors(pdev, 1, 8, PCI_IRQ_ALL_TYPES);\n\tif (err > 0)\n\t\tfor (i = 0; i < err; i++, r++) {\n\t\t\tresource[r].flags = IORESOURCE_IRQ;\n\t\t\tresource[r].start = pci_irq_vector(pdev, i);\n\t\t}\n\n\tth = intel_th_alloc(&pdev->dev, drvdata, resource, r);\n\tif (IS_ERR(th)) {\n\t\terr = PTR_ERR(th);\n\t\tgoto err_free_irq;\n\t}\n\n\tth->activate   = intel_th_pci_activate;\n\tth->deactivate = intel_th_pci_deactivate;\n\n\tpci_set_master(pdev);\n\n\treturn 0;\n\nerr_free_irq:\n\tpci_free_irq_vectors(pdev);\n\treturn err;\n}\n\nstatic void intel_th_pci_remove(struct pci_dev *pdev)\n{\n\tstruct intel_th *th = pci_get_drvdata(pdev);\n\n\tintel_th_free(th);\n\n\tpci_free_irq_vectors(pdev);\n}\n\nstatic const struct intel_th_drvdata intel_th_1x_multi_is_broken = {\n\t.multi_is_broken\t= 1,\n};\n\nstatic const struct intel_th_drvdata intel_th_2x = {\n\t.tscu_enable\t= 1,\n\t.has_mintctl\t= 1,\n};\n\nstatic const struct pci_device_id intel_th_pci_id_table[] = {\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x9d26),\n\t\t.driver_data = (kernel_ulong_t)0,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xa126),\n\t\t.driver_data = (kernel_ulong_t)0,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x5a8e),\n\t\t.driver_data = (kernel_ulong_t)0,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0a80),\n\t\t.driver_data = (kernel_ulong_t)0,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x1a8e),\n\t\t.driver_data = (kernel_ulong_t)0,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xa2a6),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_1x_multi_is_broken,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x19e1),\n\t\t.driver_data = (kernel_ulong_t)0,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xa1a6),\n\t\t.driver_data = (kernel_ulong_t)0,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xa226),\n\t\t.driver_data = (kernel_ulong_t)0,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x318e),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xa326),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x9da6),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x18e1),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x34a6),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x02a6),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x06a6),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xa3a6),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_1x_multi_is_broken,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x45c5),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x8a29),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x9a33),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xa0a6),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x43a6),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x4da6),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x4e29),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x4529),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x4b26),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x1bcc),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x7aa6),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x51a6),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x54a6),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x7e24),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x7a26),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xa76f),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x466f),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x4c19),\n\t\t.driver_data = (kernel_ulong_t)&intel_th_2x,\n\t},\n\t{ 0 },\n};\n\nMODULE_DEVICE_TABLE(pci, intel_th_pci_id_table);\n\nstatic struct pci_driver intel_th_pci_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.id_table\t= intel_th_pci_id_table,\n\t.probe\t\t= intel_th_pci_probe,\n\t.remove\t\t= intel_th_pci_remove,\n};\n\nmodule_pci_driver(intel_th_pci_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel(R) Trace Hub PCI controller driver\");\nMODULE_AUTHOR(\"Alexander Shishkin <alexander.shishkin@intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}