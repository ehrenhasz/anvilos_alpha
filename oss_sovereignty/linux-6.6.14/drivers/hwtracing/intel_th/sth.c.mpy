{
  "module_name": "sth.c",
  "hash_id": "a688f06f43078b7d28cebb3cb0f030a2cc8982b37009753e6e0b1493d215fcda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/intel_th/sth.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/stm.h>\n\n#include \"intel_th.h\"\n#include \"sth.h\"\n\nstruct sth_device {\n\tvoid __iomem\t*base;\n\tvoid __iomem\t*channels;\n\tphys_addr_t\tchannels_phys;\n\tstruct device\t*dev;\n\tstruct stm_data\tstm;\n\tunsigned int\tsw_nmasters;\n};\n\nstatic struct intel_th_channel __iomem *\nsth_channel(struct sth_device *sth, unsigned int master, unsigned int channel)\n{\n\tstruct intel_th_channel __iomem *sw_map = sth->channels;\n\n\treturn &sw_map[(master - sth->stm.sw_start) * sth->stm.sw_nchannels +\n\t\t       channel];\n}\n\nstatic void sth_iowrite(void __iomem *dest, const unsigned char *payload,\n\t\t\tunsigned int size)\n{\n\tswitch (size) {\n#ifdef CONFIG_64BIT\n\tcase 8:\n\t\twriteq_relaxed(*(u64 *)payload, dest);\n\t\tbreak;\n#endif\n\tcase 4:\n\t\twritel_relaxed(*(u32 *)payload, dest);\n\t\tbreak;\n\tcase 2:\n\t\twritew_relaxed(*(u16 *)payload, dest);\n\t\tbreak;\n\tcase 1:\n\t\twriteb_relaxed(*(u8 *)payload, dest);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic ssize_t notrace sth_stm_packet(struct stm_data *stm_data,\n\t\t\t\t      unsigned int master,\n\t\t\t\t      unsigned int channel,\n\t\t\t\t      unsigned int packet,\n\t\t\t\t      unsigned int flags,\n\t\t\t\t      unsigned int size,\n\t\t\t\t      const unsigned char *payload)\n{\n\tstruct sth_device *sth = container_of(stm_data, struct sth_device, stm);\n\tstruct intel_th_channel __iomem *out =\n\t\tsth_channel(sth, master, channel);\n\tu64 __iomem *outp = &out->Dn;\n\tunsigned long reg = REG_STH_TRIG;\n\n#ifndef CONFIG_64BIT\n\tif (size > 4)\n\t\tsize = 4;\n#endif\n\n\tsize = rounddown_pow_of_two(size);\n\n\tswitch (packet) {\n\t \n\tcase STP_PACKET_GERR:\n\t\treg += 4;\n\t\tfallthrough;\n\n\tcase STP_PACKET_XSYNC:\n\t\treg += 8;\n\t\tfallthrough;\n\n\tcase STP_PACKET_TRIG:\n\t\tif (flags & STP_PACKET_TIMESTAMPED)\n\t\t\treg += 4;\n\t\twriteb_relaxed(*payload, sth->base + reg);\n\t\tbreak;\n\n\tcase STP_PACKET_MERR:\n\t\tif (size > 4)\n\t\t\tsize = 4;\n\n\t\tsth_iowrite(&out->MERR, payload, size);\n\t\tbreak;\n\n\tcase STP_PACKET_FLAG:\n\t\tif (flags & STP_PACKET_TIMESTAMPED)\n\t\t\toutp = (u64 __iomem *)&out->FLAG_TS;\n\t\telse\n\t\t\toutp = (u64 __iomem *)&out->FLAG;\n\n\t\tsize = 0;\n\t\twriteb_relaxed(0, outp);\n\t\tbreak;\n\n\tcase STP_PACKET_USER:\n\t\tif (flags & STP_PACKET_TIMESTAMPED)\n\t\t\toutp = &out->USER_TS;\n\t\telse\n\t\t\toutp = &out->USER;\n\t\tsth_iowrite(outp, payload, size);\n\t\tbreak;\n\n\tcase STP_PACKET_DATA:\n\t\toutp = &out->Dn;\n\n\t\tif (flags & STP_PACKET_TIMESTAMPED)\n\t\t\toutp += 2;\n\t\tif (flags & STP_PACKET_MARKED)\n\t\t\toutp++;\n\n\t\tsth_iowrite(outp, payload, size);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn size;\n}\n\nstatic phys_addr_t\nsth_stm_mmio_addr(struct stm_data *stm_data, unsigned int master,\n\t\t  unsigned int channel, unsigned int nr_chans)\n{\n\tstruct sth_device *sth = container_of(stm_data, struct sth_device, stm);\n\tphys_addr_t addr;\n\n\tmaster -= sth->stm.sw_start;\n\taddr = sth->channels_phys + (master * sth->stm.sw_nchannels + channel) *\n\t\tsizeof(struct intel_th_channel);\n\n\tif (offset_in_page(addr) ||\n\t    offset_in_page(nr_chans * sizeof(struct intel_th_channel)))\n\t\treturn 0;\n\n\treturn addr;\n}\n\nstatic int sth_stm_link(struct stm_data *stm_data, unsigned int master,\n\t\t\t unsigned int channel)\n{\n\tstruct sth_device *sth = container_of(stm_data, struct sth_device, stm);\n\n\treturn intel_th_set_output(to_intel_th_device(sth->dev), master);\n}\n\nstatic int intel_th_sw_init(struct sth_device *sth)\n{\n\tu32 reg;\n\n\treg = ioread32(sth->base + REG_STH_STHCAP1);\n\tsth->stm.sw_nchannels = reg & 0xff;\n\n\treg = ioread32(sth->base + REG_STH_STHCAP0);\n\tsth->stm.sw_start = reg & 0xffff;\n\tsth->stm.sw_end = reg >> 16;\n\n\tsth->sw_nmasters = sth->stm.sw_end - sth->stm.sw_start;\n\tdev_dbg(sth->dev, \"sw_start: %x sw_end: %x masters: %x nchannels: %x\\n\",\n\t\tsth->stm.sw_start, sth->stm.sw_end, sth->sw_nmasters,\n\t\tsth->stm.sw_nchannels);\n\n\treturn 0;\n}\n\nstatic int intel_th_sth_probe(struct intel_th_device *thdev)\n{\n\tstruct device *dev = &thdev->dev;\n\tstruct sth_device *sth;\n\tstruct resource *res;\n\tvoid __iomem *base, *channels;\n\tint err;\n\n\tres = intel_th_device_get_resource(thdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tbase = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\tres = intel_th_device_get_resource(thdev, IORESOURCE_MEM, 1);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tchannels = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\tsth = devm_kzalloc(dev, sizeof(*sth), GFP_KERNEL);\n\tif (!sth)\n\t\treturn -ENOMEM;\n\n\tsth->dev = dev;\n\tsth->base = base;\n\tsth->channels = channels;\n\tsth->channels_phys = res->start;\n\tsth->stm.name = dev_name(dev);\n\tsth->stm.packet = sth_stm_packet;\n\tsth->stm.mmio_addr = sth_stm_mmio_addr;\n\tsth->stm.sw_mmiosz = sizeof(struct intel_th_channel);\n\tsth->stm.link = sth_stm_link;\n\n\terr = intel_th_sw_init(sth);\n\tif (err)\n\t\treturn err;\n\n\terr = stm_register_device(dev, &sth->stm, THIS_MODULE);\n\tif (err) {\n\t\tdev_err(dev, \"stm_register_device failed\\n\");\n\t\treturn err;\n\t}\n\n\tdev_set_drvdata(dev, sth);\n\n\treturn 0;\n}\n\nstatic void intel_th_sth_remove(struct intel_th_device *thdev)\n{\n\tstruct sth_device *sth = dev_get_drvdata(&thdev->dev);\n\n\tstm_unregister_device(&sth->stm);\n}\n\nstatic struct intel_th_driver intel_th_sth_driver = {\n\t.probe\t= intel_th_sth_probe,\n\t.remove\t= intel_th_sth_remove,\n\t.driver\t= {\n\t\t.name\t= \"sth\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n};\n\nmodule_driver(intel_th_sth_driver,\n\t      intel_th_driver_register,\n\t      intel_th_driver_unregister);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel(R) Trace Hub Software Trace Hub driver\");\nMODULE_AUTHOR(\"Alexander Shishkin <alexander.shishkin@intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}