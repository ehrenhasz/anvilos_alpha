{
  "module_name": "msu.c",
  "hash_id": "a829d04b900443d46c21b792a45649b3ae51201b131c782a09160374b6bd7640",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/intel_th/msu.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/sizes.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/workqueue.h>\n#include <linux/dma-mapping.h>\n\n#ifdef CONFIG_X86\n#include <asm/set_memory.h>\n#endif\n\n#include <linux/intel_th.h>\n#include \"intel_th.h\"\n#include \"msu.h\"\n\n#define msc_dev(x) (&(x)->thdev->dev)\n\n \nenum lockout_state {\n\tWIN_READY = 0,\n\tWIN_INUSE,\n\tWIN_LOCKED\n};\n\n \nstruct msc_window {\n\tstruct list_head\tentry;\n\tunsigned long\t\tpgoff;\n\tenum lockout_state\tlockout;\n\tspinlock_t\t\tlo_lock;\n\tunsigned int\t\tnr_blocks;\n\tunsigned int\t\tnr_segs;\n\tstruct msc\t\t*msc;\n\tstruct sg_table\t\t_sgt;\n\tstruct sg_table\t\t*sgt;\n};\n\n \nstruct msc_iter {\n\tstruct list_head\tentry;\n\tstruct msc\t\t*msc;\n\tstruct msc_window\t*start_win;\n\tstruct msc_window\t*win;\n\tunsigned long\t\toffset;\n\tstruct scatterlist\t*start_block;\n\tstruct scatterlist\t*block;\n\tunsigned int\t\tblock_off;\n\tunsigned int\t\twrap_count;\n\tunsigned int\t\teof;\n};\n\n \nstruct msc {\n\tvoid __iomem\t\t*reg_base;\n\tvoid __iomem\t\t*msu_base;\n\tstruct intel_th_device\t*thdev;\n\n\tconst struct msu_buffer\t*mbuf;\n\tvoid\t\t\t*mbuf_priv;\n\n\tstruct work_struct\twork;\n\tstruct list_head\twin_list;\n\tstruct sg_table\t\tsingle_sgt;\n\tstruct msc_window\t*cur_win;\n\tstruct msc_window\t*switch_on_unlock;\n\tunsigned long\t\tnr_pages;\n\tunsigned long\t\tsingle_sz;\n\tunsigned int\t\tsingle_wrap : 1;\n\tvoid\t\t\t*base;\n\tdma_addr_t\t\tbase_addr;\n\tu32\t\t\torig_addr;\n\tu32\t\t\torig_sz;\n\n\t \n\tatomic_t\t\tuser_count;\n\n\tatomic_t\t\tmmap_count;\n\tstruct mutex\t\tbuf_mutex;\n\n\tstruct list_head\titer_list;\n\n\tbool\t\t\tstop_on_full;\n\n\t \n\tunsigned int\t\tenabled : 1,\n\t\t\t\twrap\t: 1,\n\t\t\t\tdo_irq\t: 1,\n\t\t\t\tmulti_is_broken : 1;\n\tunsigned int\t\tmode;\n\tunsigned int\t\tburst_len;\n\tunsigned int\t\tindex;\n};\n\nstatic LIST_HEAD(msu_buffer_list);\nstatic DEFINE_MUTEX(msu_buffer_mutex);\n\n \nstruct msu_buffer_entry {\n\tstruct list_head\tentry;\n\tconst struct msu_buffer\t*mbuf;\n\tstruct module\t\t*owner;\n};\n\nstatic struct msu_buffer_entry *__msu_buffer_entry_find(const char *name)\n{\n\tstruct msu_buffer_entry *mbe;\n\n\tlockdep_assert_held(&msu_buffer_mutex);\n\n\tlist_for_each_entry(mbe, &msu_buffer_list, entry) {\n\t\tif (!strcmp(mbe->mbuf->name, name))\n\t\t\treturn mbe;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct msu_buffer *\nmsu_buffer_get(const char *name)\n{\n\tstruct msu_buffer_entry *mbe;\n\n\tmutex_lock(&msu_buffer_mutex);\n\tmbe = __msu_buffer_entry_find(name);\n\tif (mbe && !try_module_get(mbe->owner))\n\t\tmbe = NULL;\n\tmutex_unlock(&msu_buffer_mutex);\n\n\treturn mbe ? mbe->mbuf : NULL;\n}\n\nstatic void msu_buffer_put(const struct msu_buffer *mbuf)\n{\n\tstruct msu_buffer_entry *mbe;\n\n\tmutex_lock(&msu_buffer_mutex);\n\tmbe = __msu_buffer_entry_find(mbuf->name);\n\tif (mbe)\n\t\tmodule_put(mbe->owner);\n\tmutex_unlock(&msu_buffer_mutex);\n}\n\nint intel_th_msu_buffer_register(const struct msu_buffer *mbuf,\n\t\t\t\t struct module *owner)\n{\n\tstruct msu_buffer_entry *mbe;\n\tint ret = 0;\n\n\tmbe = kzalloc(sizeof(*mbe), GFP_KERNEL);\n\tif (!mbe)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&msu_buffer_mutex);\n\tif (__msu_buffer_entry_find(mbuf->name)) {\n\t\tret = -EEXIST;\n\t\tkfree(mbe);\n\t\tgoto unlock;\n\t}\n\n\tmbe->mbuf = mbuf;\n\tmbe->owner = owner;\n\tlist_add_tail(&mbe->entry, &msu_buffer_list);\nunlock:\n\tmutex_unlock(&msu_buffer_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(intel_th_msu_buffer_register);\n\nvoid intel_th_msu_buffer_unregister(const struct msu_buffer *mbuf)\n{\n\tstruct msu_buffer_entry *mbe;\n\n\tmutex_lock(&msu_buffer_mutex);\n\tmbe = __msu_buffer_entry_find(mbuf->name);\n\tif (mbe) {\n\t\tlist_del(&mbe->entry);\n\t\tkfree(mbe);\n\t}\n\tmutex_unlock(&msu_buffer_mutex);\n}\nEXPORT_SYMBOL_GPL(intel_th_msu_buffer_unregister);\n\nstatic inline bool msc_block_is_empty(struct msc_block_desc *bdesc)\n{\n\t \n\tif (!bdesc->valid_dw)\n\t\treturn true;\n\n\t \n\tif (!msc_data_sz(bdesc))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline struct scatterlist *msc_win_base_sg(struct msc_window *win)\n{\n\treturn win->sgt->sgl;\n}\n\nstatic inline struct msc_block_desc *msc_win_base(struct msc_window *win)\n{\n\treturn sg_virt(msc_win_base_sg(win));\n}\n\nstatic inline dma_addr_t msc_win_base_dma(struct msc_window *win)\n{\n\treturn sg_dma_address(msc_win_base_sg(win));\n}\n\nstatic inline unsigned long\nmsc_win_base_pfn(struct msc_window *win)\n{\n\treturn PFN_DOWN(msc_win_base_dma(win));\n}\n\n \nstatic inline bool msc_is_last_win(struct msc_window *win)\n{\n\treturn win->entry.next == &win->msc->win_list;\n}\n\n \nstatic struct msc_window *msc_next_window(struct msc_window *win)\n{\n\tif (msc_is_last_win(win))\n\t\treturn list_first_entry(&win->msc->win_list, struct msc_window,\n\t\t\t\t\tentry);\n\n\treturn list_next_entry(win, entry);\n}\n\nstatic size_t msc_win_total_sz(struct msc_window *win)\n{\n\tstruct scatterlist *sg;\n\tunsigned int blk;\n\tsize_t size = 0;\n\n\tfor_each_sg(win->sgt->sgl, sg, win->nr_segs, blk) {\n\t\tstruct msc_block_desc *bdesc = sg_virt(sg);\n\n\t\tif (msc_block_wrapped(bdesc))\n\t\t\treturn (size_t)win->nr_blocks << PAGE_SHIFT;\n\n\t\tsize += msc_total_sz(bdesc);\n\t\tif (msc_block_last_written(bdesc))\n\t\t\tbreak;\n\t}\n\n\treturn size;\n}\n\n \nstatic struct msc_window *\nmsc_find_window(struct msc *msc, struct sg_table *sgt, bool nonempty)\n{\n\tstruct msc_window *win;\n\tunsigned int found = 0;\n\n\tif (list_empty(&msc->win_list))\n\t\treturn NULL;\n\n\t \n\tlist_for_each_entry(win, &msc->win_list, entry) {\n\t\tif (win->sgt == sgt)\n\t\t\tfound++;\n\n\t\t \n\t\tif (nonempty && msc_block_is_empty(msc_win_base(win)))\n\t\t\tcontinue;\n\n\t\tif (found)\n\t\t\treturn win;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct msc_window *msc_oldest_window(struct msc *msc)\n{\n\tstruct msc_window *win;\n\n\tif (list_empty(&msc->win_list))\n\t\treturn NULL;\n\n\twin = msc_find_window(msc, msc_next_window(msc->cur_win)->sgt, true);\n\tif (win)\n\t\treturn win;\n\n\treturn list_first_entry(&msc->win_list, struct msc_window, entry);\n}\n\n \nstatic struct scatterlist *msc_win_oldest_sg(struct msc_window *win)\n{\n\tunsigned int blk;\n\tstruct scatterlist *sg;\n\tstruct msc_block_desc *bdesc = msc_win_base(win);\n\n\t \n\tif (!msc_block_wrapped(bdesc))\n\t\treturn msc_win_base_sg(win);\n\n\t \n\tfor_each_sg(win->sgt->sgl, sg, win->nr_segs, blk) {\n\t\tstruct msc_block_desc *bdesc = sg_virt(sg);\n\n\t\tif (msc_block_last_written(bdesc))\n\t\t\treturn sg;\n\t}\n\n\treturn msc_win_base_sg(win);\n}\n\nstatic struct msc_block_desc *msc_iter_bdesc(struct msc_iter *iter)\n{\n\treturn sg_virt(iter->block);\n}\n\nstatic struct msc_iter *msc_iter_install(struct msc *msc)\n{\n\tstruct msc_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&msc->buf_mutex);\n\n\t \n\tif (msc->enabled) {\n\t\tkfree(iter);\n\t\titer = ERR_PTR(-EBUSY);\n\t\tgoto unlock;\n\t}\n\n\titer->msc = msc;\n\n\tlist_add_tail(&iter->entry, &msc->iter_list);\nunlock:\n\tmutex_unlock(&msc->buf_mutex);\n\n\treturn iter;\n}\n\nstatic void msc_iter_remove(struct msc_iter *iter, struct msc *msc)\n{\n\tmutex_lock(&msc->buf_mutex);\n\tlist_del(&iter->entry);\n\tmutex_unlock(&msc->buf_mutex);\n\n\tkfree(iter);\n}\n\nstatic void msc_iter_block_start(struct msc_iter *iter)\n{\n\tif (iter->start_block)\n\t\treturn;\n\n\titer->start_block = msc_win_oldest_sg(iter->win);\n\titer->block = iter->start_block;\n\titer->wrap_count = 0;\n\n\t \n\tif (msc_block_wrapped(msc_iter_bdesc(iter)))\n\t\titer->wrap_count = 2;\n\n}\n\nstatic int msc_iter_win_start(struct msc_iter *iter, struct msc *msc)\n{\n\t \n\tif (iter->start_win)\n\t\treturn 0;\n\n\titer->start_win = msc_oldest_window(msc);\n\tif (!iter->start_win)\n\t\treturn -EINVAL;\n\n\titer->win = iter->start_win;\n\titer->start_block = NULL;\n\n\tmsc_iter_block_start(iter);\n\n\treturn 0;\n}\n\nstatic int msc_iter_win_advance(struct msc_iter *iter)\n{\n\titer->win = msc_next_window(iter->win);\n\titer->start_block = NULL;\n\n\tif (iter->win == iter->start_win) {\n\t\titer->eof++;\n\t\treturn 1;\n\t}\n\n\tmsc_iter_block_start(iter);\n\n\treturn 0;\n}\n\nstatic int msc_iter_block_advance(struct msc_iter *iter)\n{\n\titer->block_off = 0;\n\n\t \n\tif (iter->wrap_count && iter->block == iter->start_block) {\n\t\titer->wrap_count--;\n\t\tif (!iter->wrap_count)\n\t\t\t \n\t\t\treturn msc_iter_win_advance(iter);\n\t}\n\n\t \n\tif (!iter->wrap_count && msc_block_last_written(msc_iter_bdesc(iter)))\n\t\t \n\t\treturn msc_iter_win_advance(iter);\n\n\t \n\tif (sg_is_last(iter->block))\n\t\titer->block = msc_win_base_sg(iter->win);\n\telse\n\t\titer->block = sg_next(iter->block);\n\n\t \n\tif (!iter->wrap_count && iter->block == iter->start_block)\n\t\treturn msc_iter_win_advance(iter);\n\n\treturn 0;\n}\n\n \nstatic ssize_t\nmsc_buffer_iterate(struct msc_iter *iter, size_t size, void *data,\n\t\t   unsigned long (*fn)(void *, void *, size_t))\n{\n\tstruct msc *msc = iter->msc;\n\tsize_t len = size;\n\tunsigned int advance;\n\n\tif (iter->eof)\n\t\treturn 0;\n\n\t \n\tif (msc_iter_win_start(iter, msc))\n\t\treturn 0;\n\n\tdo {\n\t\tunsigned long data_bytes = msc_data_sz(msc_iter_bdesc(iter));\n\t\tvoid *src = (void *)msc_iter_bdesc(iter) + MSC_BDESC;\n\t\tsize_t tocopy = data_bytes, copied = 0;\n\t\tsize_t remaining = 0;\n\n\t\tadvance = 1;\n\n\t\t \n\t\tif (iter->block == iter->start_block && iter->wrap_count == 2) {\n\t\t\ttocopy = DATA_IN_PAGE - data_bytes;\n\t\t\tsrc += data_bytes;\n\t\t}\n\n\t\tif (!tocopy)\n\t\t\tgoto next_block;\n\n\t\ttocopy -= iter->block_off;\n\t\tsrc += iter->block_off;\n\n\t\tif (len < tocopy) {\n\t\t\ttocopy = len;\n\t\t\tadvance = 0;\n\t\t}\n\n\t\tremaining = fn(data, src, tocopy);\n\n\t\tif (remaining)\n\t\t\tadvance = 0;\n\n\t\tcopied = tocopy - remaining;\n\t\tlen -= copied;\n\t\titer->block_off += copied;\n\t\titer->offset += copied;\n\n\t\tif (!advance)\n\t\t\tbreak;\n\nnext_block:\n\t\tif (msc_iter_block_advance(iter))\n\t\t\tbreak;\n\n\t} while (len);\n\n\treturn size - len;\n}\n\n \nstatic void msc_buffer_clear_hw_header(struct msc *msc)\n{\n\tstruct msc_window *win;\n\tstruct scatterlist *sg;\n\n\tlist_for_each_entry(win, &msc->win_list, entry) {\n\t\tunsigned int blk;\n\n\t\tfor_each_sg(win->sgt->sgl, sg, win->nr_segs, blk) {\n\t\t\tstruct msc_block_desc *bdesc = sg_virt(sg);\n\n\t\t\tmemset_startat(bdesc, 0, hw_tag);\n\t\t}\n\t}\n}\n\nstatic int intel_th_msu_init(struct msc *msc)\n{\n\tu32 mintctl, msusts;\n\n\tif (!msc->do_irq)\n\t\treturn 0;\n\n\tif (!msc->mbuf)\n\t\treturn 0;\n\n\tmintctl = ioread32(msc->msu_base + REG_MSU_MINTCTL);\n\tmintctl |= msc->index ? M1BLIE : M0BLIE;\n\tiowrite32(mintctl, msc->msu_base + REG_MSU_MINTCTL);\n\tif (mintctl != ioread32(msc->msu_base + REG_MSU_MINTCTL)) {\n\t\tdev_info(msc_dev(msc), \"MINTCTL ignores writes: no usable interrupts\\n\");\n\t\tmsc->do_irq = 0;\n\t\treturn 0;\n\t}\n\n\tmsusts = ioread32(msc->msu_base + REG_MSU_MSUSTS);\n\tiowrite32(msusts, msc->msu_base + REG_MSU_MSUSTS);\n\n\treturn 0;\n}\n\nstatic void intel_th_msu_deinit(struct msc *msc)\n{\n\tu32 mintctl;\n\n\tif (!msc->do_irq)\n\t\treturn;\n\n\tmintctl = ioread32(msc->msu_base + REG_MSU_MINTCTL);\n\tmintctl &= msc->index ? ~M1BLIE : ~M0BLIE;\n\tiowrite32(mintctl, msc->msu_base + REG_MSU_MINTCTL);\n}\n\nstatic int msc_win_set_lockout(struct msc_window *win,\n\t\t\t       enum lockout_state expect,\n\t\t\t       enum lockout_state new)\n{\n\tenum lockout_state old;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!win->msc->mbuf)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&win->lo_lock, flags);\n\told = win->lockout;\n\n\tif (old != expect) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\twin->lockout = new;\n\n\tif (old == expect && new == WIN_LOCKED)\n\t\tatomic_inc(&win->msc->user_count);\n\telse if (old == expect && old == WIN_LOCKED)\n\t\tatomic_dec(&win->msc->user_count);\n\nunlock:\n\tspin_unlock_irqrestore(&win->lo_lock, flags);\n\n\tif (ret) {\n\t\tif (expect == WIN_READY && old == WIN_LOCKED)\n\t\t\treturn -EBUSY;\n\n\t\t \n\t\tif (expect == WIN_LOCKED && old == new)\n\t\t\treturn 0;\n\n\t\tdev_warn_ratelimited(msc_dev(win->msc),\n\t\t\t\t     \"expected lockout state %d, got %d\\n\",\n\t\t\t\t     expect, old);\n\t}\n\n\treturn ret;\n}\n \nstatic int msc_configure(struct msc *msc)\n{\n\tu32 reg;\n\n\tlockdep_assert_held(&msc->buf_mutex);\n\n\tif (msc->mode > MSC_MODE_MULTI)\n\t\treturn -EINVAL;\n\n\tif (msc->mode == MSC_MODE_MULTI) {\n\t\tif (msc_win_set_lockout(msc->cur_win, WIN_READY, WIN_INUSE))\n\t\t\treturn -EBUSY;\n\n\t\tmsc_buffer_clear_hw_header(msc);\n\t}\n\n\tmsc->orig_addr = ioread32(msc->reg_base + REG_MSU_MSC0BAR);\n\tmsc->orig_sz   = ioread32(msc->reg_base + REG_MSU_MSC0SIZE);\n\n\treg = msc->base_addr >> PAGE_SHIFT;\n\tiowrite32(reg, msc->reg_base + REG_MSU_MSC0BAR);\n\n\tif (msc->mode == MSC_MODE_SINGLE) {\n\t\treg = msc->nr_pages;\n\t\tiowrite32(reg, msc->reg_base + REG_MSU_MSC0SIZE);\n\t}\n\n\treg = ioread32(msc->reg_base + REG_MSU_MSC0CTL);\n\treg &= ~(MSC_MODE | MSC_WRAPEN | MSC_EN | MSC_RD_HDR_OVRD);\n\n\treg |= MSC_EN;\n\treg |= msc->mode << __ffs(MSC_MODE);\n\treg |= msc->burst_len << __ffs(MSC_LEN);\n\n\tif (msc->wrap)\n\t\treg |= MSC_WRAPEN;\n\n\tiowrite32(reg, msc->reg_base + REG_MSU_MSC0CTL);\n\n\tintel_th_msu_init(msc);\n\n\tmsc->thdev->output.multiblock = msc->mode == MSC_MODE_MULTI;\n\tintel_th_trace_enable(msc->thdev);\n\tmsc->enabled = 1;\n\n\tif (msc->mbuf && msc->mbuf->activate)\n\t\tmsc->mbuf->activate(msc->mbuf_priv);\n\n\treturn 0;\n}\n\n \nstatic void msc_disable(struct msc *msc)\n{\n\tstruct msc_window *win = msc->cur_win;\n\tu32 reg;\n\n\tlockdep_assert_held(&msc->buf_mutex);\n\n\tif (msc->mode == MSC_MODE_MULTI)\n\t\tmsc_win_set_lockout(win, WIN_INUSE, WIN_LOCKED);\n\n\tif (msc->mbuf && msc->mbuf->deactivate)\n\t\tmsc->mbuf->deactivate(msc->mbuf_priv);\n\tintel_th_msu_deinit(msc);\n\tintel_th_trace_disable(msc->thdev);\n\n\tif (msc->mode == MSC_MODE_SINGLE) {\n\t\treg = ioread32(msc->reg_base + REG_MSU_MSC0STS);\n\t\tmsc->single_wrap = !!(reg & MSCSTS_WRAPSTAT);\n\n\t\treg = ioread32(msc->reg_base + REG_MSU_MSC0MWP);\n\t\tmsc->single_sz = reg & ((msc->nr_pages << PAGE_SHIFT) - 1);\n\t\tdev_dbg(msc_dev(msc), \"MSCnMWP: %08x/%08lx, wrap: %d\\n\",\n\t\t\treg, msc->single_sz, msc->single_wrap);\n\t}\n\n\treg = ioread32(msc->reg_base + REG_MSU_MSC0CTL);\n\treg &= ~MSC_EN;\n\tiowrite32(reg, msc->reg_base + REG_MSU_MSC0CTL);\n\n\tif (msc->mbuf && msc->mbuf->ready)\n\t\tmsc->mbuf->ready(msc->mbuf_priv, win->sgt,\n\t\t\t\t msc_win_total_sz(win));\n\n\tmsc->enabled = 0;\n\n\tiowrite32(msc->orig_addr, msc->reg_base + REG_MSU_MSC0BAR);\n\tiowrite32(msc->orig_sz, msc->reg_base + REG_MSU_MSC0SIZE);\n\n\tdev_dbg(msc_dev(msc), \"MSCnNWSA: %08x\\n\",\n\t\tioread32(msc->reg_base + REG_MSU_MSC0NWSA));\n\n\treg = ioread32(msc->reg_base + REG_MSU_MSC0STS);\n\tdev_dbg(msc_dev(msc), \"MSCnSTS: %08x\\n\", reg);\n\n\treg = ioread32(msc->reg_base + REG_MSU_MSUSTS);\n\treg &= msc->index ? MSUSTS_MSC1BLAST : MSUSTS_MSC0BLAST;\n\tiowrite32(reg, msc->reg_base + REG_MSU_MSUSTS);\n}\n\nstatic int intel_th_msc_activate(struct intel_th_device *thdev)\n{\n\tstruct msc *msc = dev_get_drvdata(&thdev->dev);\n\tint ret = -EBUSY;\n\n\tif (!atomic_inc_unless_negative(&msc->user_count))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&msc->buf_mutex);\n\n\t \n\tif (list_empty(&msc->iter_list))\n\t\tret = msc_configure(msc);\n\n\tmutex_unlock(&msc->buf_mutex);\n\n\tif (ret)\n\t\tatomic_dec(&msc->user_count);\n\n\treturn ret;\n}\n\nstatic void intel_th_msc_deactivate(struct intel_th_device *thdev)\n{\n\tstruct msc *msc = dev_get_drvdata(&thdev->dev);\n\n\tmutex_lock(&msc->buf_mutex);\n\tif (msc->enabled) {\n\t\tmsc_disable(msc);\n\t\tatomic_dec(&msc->user_count);\n\t}\n\tmutex_unlock(&msc->buf_mutex);\n}\n\n \nstatic int msc_buffer_contig_alloc(struct msc *msc, unsigned long size)\n{\n\tunsigned long nr_pages = size >> PAGE_SHIFT;\n\tunsigned int order = get_order(size);\n\tstruct page *page;\n\tint ret;\n\n\tif (!size)\n\t\treturn 0;\n\n\tret = sg_alloc_table(&msc->single_sgt, 1, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = -ENOMEM;\n\tpage = alloc_pages(GFP_KERNEL | __GFP_ZERO | GFP_DMA32, order);\n\tif (!page)\n\t\tgoto err_free_sgt;\n\n\tsplit_page(page, order);\n\tsg_set_buf(msc->single_sgt.sgl, page_address(page), size);\n\n\tret = dma_map_sg(msc_dev(msc)->parent->parent, msc->single_sgt.sgl, 1,\n\t\t\t DMA_FROM_DEVICE);\n\tif (ret < 0)\n\t\tgoto err_free_pages;\n\n\tmsc->nr_pages = nr_pages;\n\tmsc->base = page_address(page);\n\tmsc->base_addr = sg_dma_address(msc->single_sgt.sgl);\n\n\treturn 0;\n\nerr_free_pages:\n\t__free_pages(page, order);\n\nerr_free_sgt:\n\tsg_free_table(&msc->single_sgt);\n\nerr_out:\n\treturn ret;\n}\n\n \nstatic void msc_buffer_contig_free(struct msc *msc)\n{\n\tunsigned long off;\n\n\tdma_unmap_sg(msc_dev(msc)->parent->parent, msc->single_sgt.sgl,\n\t\t     1, DMA_FROM_DEVICE);\n\tsg_free_table(&msc->single_sgt);\n\n\tfor (off = 0; off < msc->nr_pages << PAGE_SHIFT; off += PAGE_SIZE) {\n\t\tstruct page *page = virt_to_page(msc->base + off);\n\n\t\tpage->mapping = NULL;\n\t\t__free_page(page);\n\t}\n\n\tmsc->nr_pages = 0;\n}\n\n \nstatic struct page *msc_buffer_contig_get_page(struct msc *msc,\n\t\t\t\t\t       unsigned long pgoff)\n{\n\tif (pgoff >= msc->nr_pages)\n\t\treturn NULL;\n\n\treturn virt_to_page(msc->base + (pgoff << PAGE_SHIFT));\n}\n\nstatic int __msc_buffer_win_alloc(struct msc_window *win,\n\t\t\t\t  unsigned int nr_segs)\n{\n\tstruct scatterlist *sg_ptr;\n\tvoid *block;\n\tint i, ret;\n\n\tret = sg_alloc_table(win->sgt, nr_segs, GFP_KERNEL);\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\tfor_each_sg(win->sgt->sgl, sg_ptr, nr_segs, i) {\n\t\tblock = dma_alloc_coherent(msc_dev(win->msc)->parent->parent,\n\t\t\t\t\t  PAGE_SIZE, &sg_dma_address(sg_ptr),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!block)\n\t\t\tgoto err_nomem;\n\n\t\tsg_set_buf(sg_ptr, block, PAGE_SIZE);\n\t}\n\n\treturn nr_segs;\n\nerr_nomem:\n\tfor_each_sg(win->sgt->sgl, sg_ptr, i, ret)\n\t\tdma_free_coherent(msc_dev(win->msc)->parent->parent, PAGE_SIZE,\n\t\t\t\t  sg_virt(sg_ptr), sg_dma_address(sg_ptr));\n\n\tsg_free_table(win->sgt);\n\n\treturn -ENOMEM;\n}\n\n#ifdef CONFIG_X86\nstatic void msc_buffer_set_uc(struct msc *msc)\n{\n\tstruct scatterlist *sg_ptr;\n\tstruct msc_window *win;\n\tint i;\n\n\tif (msc->mode == MSC_MODE_SINGLE) {\n\t\tset_memory_uc((unsigned long)msc->base, msc->nr_pages);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(win, &msc->win_list, entry) {\n\t\tfor_each_sg(win->sgt->sgl, sg_ptr, win->nr_segs, i) {\n\t\t\t \n\t\t\tset_memory_uc((unsigned long)sg_virt(sg_ptr),\n\t\t\t\t\tPFN_DOWN(sg_ptr->length));\n\t\t}\n\t}\n}\n\nstatic void msc_buffer_set_wb(struct msc *msc)\n{\n\tstruct scatterlist *sg_ptr;\n\tstruct msc_window *win;\n\tint i;\n\n\tif (msc->mode == MSC_MODE_SINGLE) {\n\t\tset_memory_wb((unsigned long)msc->base, msc->nr_pages);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(win, &msc->win_list, entry) {\n\t\tfor_each_sg(win->sgt->sgl, sg_ptr, win->nr_segs, i) {\n\t\t\t \n\t\t\tset_memory_wb((unsigned long)sg_virt(sg_ptr),\n\t\t\t\t\tPFN_DOWN(sg_ptr->length));\n\t\t}\n\t}\n}\n#else  \nstatic inline void\nmsc_buffer_set_uc(struct msc *msc) {}\nstatic inline void msc_buffer_set_wb(struct msc *msc) {}\n#endif  \n\nstatic struct page *msc_sg_page(struct scatterlist *sg)\n{\n\tvoid *addr = sg_virt(sg);\n\n\tif (is_vmalloc_addr(addr))\n\t\treturn vmalloc_to_page(addr);\n\n\treturn sg_page(sg);\n}\n\n \nstatic int msc_buffer_win_alloc(struct msc *msc, unsigned int nr_blocks)\n{\n\tstruct msc_window *win;\n\tint ret = -ENOMEM;\n\n\tif (!nr_blocks)\n\t\treturn 0;\n\n\twin = kzalloc(sizeof(*win), GFP_KERNEL);\n\tif (!win)\n\t\treturn -ENOMEM;\n\n\twin->msc = msc;\n\twin->sgt = &win->_sgt;\n\twin->lockout = WIN_READY;\n\tspin_lock_init(&win->lo_lock);\n\n\tif (!list_empty(&msc->win_list)) {\n\t\tstruct msc_window *prev = list_last_entry(&msc->win_list,\n\t\t\t\t\t\t\t  struct msc_window,\n\t\t\t\t\t\t\t  entry);\n\n\t\twin->pgoff = prev->pgoff + prev->nr_blocks;\n\t}\n\n\tif (msc->mbuf && msc->mbuf->alloc_window)\n\t\tret = msc->mbuf->alloc_window(msc->mbuf_priv, &win->sgt,\n\t\t\t\t\t      nr_blocks << PAGE_SHIFT);\n\telse\n\t\tret = __msc_buffer_win_alloc(win, nr_blocks);\n\n\tif (ret <= 0)\n\t\tgoto err_nomem;\n\n\twin->nr_segs = ret;\n\twin->nr_blocks = nr_blocks;\n\n\tif (list_empty(&msc->win_list)) {\n\t\tmsc->base = msc_win_base(win);\n\t\tmsc->base_addr = msc_win_base_dma(win);\n\t\tmsc->cur_win = win;\n\t}\n\n\tlist_add_tail(&win->entry, &msc->win_list);\n\tmsc->nr_pages += nr_blocks;\n\n\treturn 0;\n\nerr_nomem:\n\tkfree(win);\n\n\treturn ret;\n}\n\nstatic void __msc_buffer_win_free(struct msc *msc, struct msc_window *win)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(win->sgt->sgl, sg, win->nr_segs, i) {\n\t\tstruct page *page = msc_sg_page(sg);\n\n\t\tpage->mapping = NULL;\n\t\tdma_free_coherent(msc_dev(win->msc)->parent->parent, PAGE_SIZE,\n\t\t\t\t  sg_virt(sg), sg_dma_address(sg));\n\t}\n\tsg_free_table(win->sgt);\n}\n\n \nstatic void msc_buffer_win_free(struct msc *msc, struct msc_window *win)\n{\n\tmsc->nr_pages -= win->nr_blocks;\n\n\tlist_del(&win->entry);\n\tif (list_empty(&msc->win_list)) {\n\t\tmsc->base = NULL;\n\t\tmsc->base_addr = 0;\n\t}\n\n\tif (msc->mbuf && msc->mbuf->free_window)\n\t\tmsc->mbuf->free_window(msc->mbuf_priv, win->sgt);\n\telse\n\t\t__msc_buffer_win_free(msc, win);\n\n\tkfree(win);\n}\n\n \nstatic void msc_buffer_relink(struct msc *msc)\n{\n\tstruct msc_window *win, *next_win;\n\n\t \n\tlist_for_each_entry(win, &msc->win_list, entry) {\n\t\tstruct scatterlist *sg;\n\t\tunsigned int blk;\n\t\tu32 sw_tag = 0;\n\n\t\t \n\t\tif (msc_is_last_win(win)) {\n\t\t\tsw_tag |= MSC_SW_TAG_LASTWIN;\n\t\t\tnext_win = list_first_entry(&msc->win_list,\n\t\t\t\t\t\t    struct msc_window, entry);\n\t\t} else {\n\t\t\tnext_win = list_next_entry(win, entry);\n\t\t}\n\n\t\tfor_each_sg(win->sgt->sgl, sg, win->nr_segs, blk) {\n\t\t\tstruct msc_block_desc *bdesc = sg_virt(sg);\n\n\t\t\tmemset(bdesc, 0, sizeof(*bdesc));\n\n\t\t\tbdesc->next_win = msc_win_base_pfn(next_win);\n\n\t\t\t \n\t\t\tif (blk == win->nr_segs - 1) {\n\t\t\t\tsw_tag |= MSC_SW_TAG_LASTBLK;\n\t\t\t\tbdesc->next_blk = msc_win_base_pfn(win);\n\t\t\t} else {\n\t\t\t\tdma_addr_t addr = sg_dma_address(sg_next(sg));\n\n\t\t\t\tbdesc->next_blk = PFN_DOWN(addr);\n\t\t\t}\n\n\t\t\tbdesc->sw_tag = sw_tag;\n\t\t\tbdesc->block_sz = sg->length / 64;\n\t\t}\n\t}\n\n\t \n\twmb();\n}\n\nstatic void msc_buffer_multi_free(struct msc *msc)\n{\n\tstruct msc_window *win, *iter;\n\n\tlist_for_each_entry_safe(win, iter, &msc->win_list, entry)\n\t\tmsc_buffer_win_free(msc, win);\n}\n\nstatic int msc_buffer_multi_alloc(struct msc *msc, unsigned long *nr_pages,\n\t\t\t\t  unsigned int nr_wins)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < nr_wins; i++) {\n\t\tret = msc_buffer_win_alloc(msc, nr_pages[i]);\n\t\tif (ret) {\n\t\t\tmsc_buffer_multi_free(msc);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmsc_buffer_relink(msc);\n\n\treturn 0;\n}\n\n \nstatic void msc_buffer_free(struct msc *msc)\n{\n\tmsc_buffer_set_wb(msc);\n\n\tif (msc->mode == MSC_MODE_SINGLE)\n\t\tmsc_buffer_contig_free(msc);\n\telse if (msc->mode == MSC_MODE_MULTI)\n\t\tmsc_buffer_multi_free(msc);\n}\n\n \nstatic int msc_buffer_alloc(struct msc *msc, unsigned long *nr_pages,\n\t\t\t    unsigned int nr_wins)\n{\n\tint ret;\n\n\t \n\tif (atomic_read(&msc->user_count) != -1)\n\t\treturn -EBUSY;\n\n\tif (msc->mode == MSC_MODE_SINGLE) {\n\t\tif (nr_wins != 1)\n\t\t\treturn -EINVAL;\n\n\t\tret = msc_buffer_contig_alloc(msc, nr_pages[0] << PAGE_SHIFT);\n\t} else if (msc->mode == MSC_MODE_MULTI) {\n\t\tret = msc_buffer_multi_alloc(msc, nr_pages, nr_wins);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tif (!ret) {\n\t\tmsc_buffer_set_uc(msc);\n\n\t\t \n\t\tsmp_mb__before_atomic();\n\n\t\tif (WARN_ON_ONCE(atomic_cmpxchg(&msc->user_count, -1, 0) != -1))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int msc_buffer_unlocked_free_unless_used(struct msc *msc)\n{\n\tint count, ret = 0;\n\n\tcount = atomic_cmpxchg(&msc->user_count, 0, -1);\n\n\t \n\tif (count > 0)\n\t\tret = -EBUSY;\n\t \n\telse if (!count)\n\t\tmsc_buffer_free(msc);\n\t \n\n\treturn ret;\n}\n\n \nstatic int msc_buffer_free_unless_used(struct msc *msc)\n{\n\tint ret;\n\n\tmutex_lock(&msc->buf_mutex);\n\tret = msc_buffer_unlocked_free_unless_used(msc);\n\tmutex_unlock(&msc->buf_mutex);\n\n\treturn ret;\n}\n\n \nstatic struct page *msc_buffer_get_page(struct msc *msc, unsigned long pgoff)\n{\n\tstruct msc_window *win;\n\tstruct scatterlist *sg;\n\tunsigned int blk;\n\n\tif (msc->mode == MSC_MODE_SINGLE)\n\t\treturn msc_buffer_contig_get_page(msc, pgoff);\n\n\tlist_for_each_entry(win, &msc->win_list, entry)\n\t\tif (pgoff >= win->pgoff && pgoff < win->pgoff + win->nr_blocks)\n\t\t\tgoto found;\n\n\treturn NULL;\n\nfound:\n\tpgoff -= win->pgoff;\n\n\tfor_each_sg(win->sgt->sgl, sg, win->nr_segs, blk) {\n\t\tstruct page *page = msc_sg_page(sg);\n\t\tsize_t pgsz = PFN_DOWN(sg->length);\n\n\t\tif (pgoff < pgsz)\n\t\t\treturn page + pgoff;\n\n\t\tpgoff -= pgsz;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct msc_win_to_user_struct {\n\tchar __user\t*buf;\n\tunsigned long\toffset;\n};\n\n \nstatic unsigned long msc_win_to_user(void *data, void *src, size_t len)\n{\n\tstruct msc_win_to_user_struct *u = data;\n\tunsigned long ret;\n\n\tret = copy_to_user(u->buf + u->offset, src, len);\n\tu->offset += len - ret;\n\n\treturn ret;\n}\n\n\n \n\nstatic int intel_th_msc_open(struct inode *inode, struct file *file)\n{\n\tstruct intel_th_device *thdev = file->private_data;\n\tstruct msc *msc = dev_get_drvdata(&thdev->dev);\n\tstruct msc_iter *iter;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\titer = msc_iter_install(msc);\n\tif (IS_ERR(iter))\n\t\treturn PTR_ERR(iter);\n\n\tfile->private_data = iter;\n\n\treturn nonseekable_open(inode, file);\n}\n\nstatic int intel_th_msc_release(struct inode *inode, struct file *file)\n{\n\tstruct msc_iter *iter = file->private_data;\n\tstruct msc *msc = iter->msc;\n\n\tmsc_iter_remove(iter, msc);\n\n\treturn 0;\n}\n\nstatic ssize_t\nmsc_single_to_user(struct msc *msc, char __user *buf, loff_t off, size_t len)\n{\n\tunsigned long size = msc->nr_pages << PAGE_SHIFT, rem = len;\n\tunsigned long start = off, tocopy = 0;\n\n\tif (msc->single_wrap) {\n\t\tstart += msc->single_sz;\n\t\tif (start < size) {\n\t\t\ttocopy = min(rem, size - start);\n\t\t\tif (copy_to_user(buf, msc->base + start, tocopy))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tbuf += tocopy;\n\t\t\trem -= tocopy;\n\t\t\tstart += tocopy;\n\t\t}\n\n\t\tstart &= size - 1;\n\t\tif (rem) {\n\t\t\ttocopy = min(rem, msc->single_sz - start);\n\t\t\tif (copy_to_user(buf, msc->base + start, tocopy))\n\t\t\t\treturn -EFAULT;\n\n\t\t\trem -= tocopy;\n\t\t}\n\n\t\treturn len - rem;\n\t}\n\n\tif (copy_to_user(buf, msc->base + start, rem))\n\t\treturn -EFAULT;\n\n\treturn len;\n}\n\nstatic ssize_t intel_th_msc_read(struct file *file, char __user *buf,\n\t\t\t\t size_t len, loff_t *ppos)\n{\n\tstruct msc_iter *iter = file->private_data;\n\tstruct msc *msc = iter->msc;\n\tsize_t size;\n\tloff_t off = *ppos;\n\tssize_t ret = 0;\n\n\tif (!atomic_inc_unless_negative(&msc->user_count))\n\t\treturn 0;\n\n\tif (msc->mode == MSC_MODE_SINGLE && !msc->single_wrap)\n\t\tsize = msc->single_sz;\n\telse\n\t\tsize = msc->nr_pages << PAGE_SHIFT;\n\n\tif (!size)\n\t\tgoto put_count;\n\n\tif (off >= size)\n\t\tgoto put_count;\n\n\tif (off + len >= size)\n\t\tlen = size - off;\n\n\tif (msc->mode == MSC_MODE_SINGLE) {\n\t\tret = msc_single_to_user(msc, buf, off, len);\n\t\tif (ret >= 0)\n\t\t\t*ppos += ret;\n\t} else if (msc->mode == MSC_MODE_MULTI) {\n\t\tstruct msc_win_to_user_struct u = {\n\t\t\t.buf\t= buf,\n\t\t\t.offset\t= 0,\n\t\t};\n\n\t\tret = msc_buffer_iterate(iter, len, &u, msc_win_to_user);\n\t\tif (ret >= 0)\n\t\t\t*ppos = iter->offset;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\nput_count:\n\tatomic_dec(&msc->user_count);\n\n\treturn ret;\n}\n\n \n\nstatic void msc_mmap_open(struct vm_area_struct *vma)\n{\n\tstruct msc_iter *iter = vma->vm_file->private_data;\n\tstruct msc *msc = iter->msc;\n\n\tatomic_inc(&msc->mmap_count);\n}\n\nstatic void msc_mmap_close(struct vm_area_struct *vma)\n{\n\tstruct msc_iter *iter = vma->vm_file->private_data;\n\tstruct msc *msc = iter->msc;\n\tunsigned long pg;\n\n\tif (!atomic_dec_and_mutex_lock(&msc->mmap_count, &msc->buf_mutex))\n\t\treturn;\n\n\t \n\tfor (pg = 0; pg < msc->nr_pages; pg++) {\n\t\tstruct page *page = msc_buffer_get_page(msc, pg);\n\n\t\tif (WARN_ON_ONCE(!page))\n\t\t\tcontinue;\n\n\t\tif (page->mapping)\n\t\t\tpage->mapping = NULL;\n\t}\n\n\t \n\tatomic_dec(&msc->user_count);\n\tmutex_unlock(&msc->buf_mutex);\n}\n\nstatic vm_fault_t msc_mmap_fault(struct vm_fault *vmf)\n{\n\tstruct msc_iter *iter = vmf->vma->vm_file->private_data;\n\tstruct msc *msc = iter->msc;\n\n\tvmf->page = msc_buffer_get_page(msc, vmf->pgoff);\n\tif (!vmf->page)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tget_page(vmf->page);\n\tvmf->page->mapping = vmf->vma->vm_file->f_mapping;\n\tvmf->page->index = vmf->pgoff;\n\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct msc_mmap_ops = {\n\t.open\t= msc_mmap_open,\n\t.close\t= msc_mmap_close,\n\t.fault\t= msc_mmap_fault,\n};\n\nstatic int intel_th_msc_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tunsigned long size = vma->vm_end - vma->vm_start;\n\tstruct msc_iter *iter = vma->vm_file->private_data;\n\tstruct msc *msc = iter->msc;\n\tint ret = -EINVAL;\n\n\tif (!size || offset_in_page(size))\n\t\treturn -EINVAL;\n\n\tif (vma->vm_pgoff)\n\t\treturn -EINVAL;\n\n\t \n\tif (!atomic_inc_unless_negative(&msc->user_count))\n\t\treturn -EINVAL;\n\n\tif (msc->mode != MSC_MODE_SINGLE &&\n\t    msc->mode != MSC_MODE_MULTI)\n\t\tgoto out;\n\n\tif (size >> PAGE_SHIFT != msc->nr_pages)\n\t\tgoto out;\n\n\tatomic_set(&msc->mmap_count, 1);\n\tret = 0;\n\nout:\n\tif (ret)\n\t\tatomic_dec(&msc->user_count);\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tvm_flags_set(vma, VM_DONTEXPAND | VM_DONTCOPY);\n\tvma->vm_ops = &msc_mmap_ops;\n\treturn ret;\n}\n\nstatic const struct file_operations intel_th_msc_fops = {\n\t.open\t\t= intel_th_msc_open,\n\t.release\t= intel_th_msc_release,\n\t.read\t\t= intel_th_msc_read,\n\t.mmap\t\t= intel_th_msc_mmap,\n\t.llseek\t\t= no_llseek,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void intel_th_msc_wait_empty(struct intel_th_device *thdev)\n{\n\tstruct msc *msc = dev_get_drvdata(&thdev->dev);\n\tunsigned long count;\n\tu32 reg;\n\n\tfor (reg = 0, count = MSC_PLE_WAITLOOP_DEPTH;\n\t     count && !(reg & MSCSTS_PLE); count--) {\n\t\treg = __raw_readl(msc->reg_base + REG_MSU_MSC0STS);\n\t\tcpu_relax();\n\t}\n\n\tif (!count)\n\t\tdev_dbg(msc_dev(msc), \"timeout waiting for MSC0 PLE\\n\");\n}\n\nstatic int intel_th_msc_init(struct msc *msc)\n{\n\tatomic_set(&msc->user_count, -1);\n\n\tmsc->mode = msc->multi_is_broken ? MSC_MODE_SINGLE : MSC_MODE_MULTI;\n\tmutex_init(&msc->buf_mutex);\n\tINIT_LIST_HEAD(&msc->win_list);\n\tINIT_LIST_HEAD(&msc->iter_list);\n\n\tmsc->burst_len =\n\t\t(ioread32(msc->reg_base + REG_MSU_MSC0CTL) & MSC_LEN) >>\n\t\t__ffs(MSC_LEN);\n\n\treturn 0;\n}\n\nstatic int msc_win_switch(struct msc *msc)\n{\n\tstruct msc_window *first;\n\n\tif (list_empty(&msc->win_list))\n\t\treturn -EINVAL;\n\n\tfirst = list_first_entry(&msc->win_list, struct msc_window, entry);\n\n\tif (msc_is_last_win(msc->cur_win))\n\t\tmsc->cur_win = first;\n\telse\n\t\tmsc->cur_win = list_next_entry(msc->cur_win, entry);\n\n\tmsc->base = msc_win_base(msc->cur_win);\n\tmsc->base_addr = msc_win_base_dma(msc->cur_win);\n\n\tintel_th_trace_switch(msc->thdev);\n\n\treturn 0;\n}\n\n \nvoid intel_th_msc_window_unlock(struct device *dev, struct sg_table *sgt)\n{\n\tstruct msc *msc = dev_get_drvdata(dev);\n\tstruct msc_window *win;\n\n\tif (!sgt)\n\t\treturn;\n\n\twin = msc_find_window(msc, sgt, false);\n\tif (!win)\n\t\treturn;\n\n\tmsc_win_set_lockout(win, WIN_LOCKED, WIN_READY);\n\tif (msc->switch_on_unlock == win) {\n\t\tmsc->switch_on_unlock = NULL;\n\t\tmsc_win_switch(msc);\n\t}\n}\nEXPORT_SYMBOL_GPL(intel_th_msc_window_unlock);\n\nstatic void msc_work(struct work_struct *work)\n{\n\tstruct msc *msc = container_of(work, struct msc, work);\n\n\tintel_th_msc_deactivate(msc->thdev);\n}\n\nstatic irqreturn_t intel_th_msc_interrupt(struct intel_th_device *thdev)\n{\n\tstruct msc *msc = dev_get_drvdata(&thdev->dev);\n\tu32 msusts = ioread32(msc->msu_base + REG_MSU_MSUSTS);\n\tu32 mask = msc->index ? MSUSTS_MSC1BLAST : MSUSTS_MSC0BLAST;\n\tstruct msc_window *win, *next_win;\n\n\tif (!msc->do_irq || !msc->mbuf)\n\t\treturn IRQ_NONE;\n\n\tmsusts &= mask;\n\n\tif (!msusts)\n\t\treturn msc->enabled ? IRQ_HANDLED : IRQ_NONE;\n\n\tiowrite32(msusts, msc->msu_base + REG_MSU_MSUSTS);\n\n\tif (!msc->enabled)\n\t\treturn IRQ_NONE;\n\n\t \n\twin = msc->cur_win;\n\tif (!win)\n\t\treturn IRQ_HANDLED;\n\tnext_win = msc_next_window(win);\n\tif (!next_win)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (msc_win_set_lockout(next_win, WIN_READY, WIN_INUSE)) {\n\t\tif (msc->stop_on_full)\n\t\t\tschedule_work(&msc->work);\n\t\telse\n\t\t\tmsc->switch_on_unlock = next_win;\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tmsc_win_set_lockout(win, WIN_INUSE, WIN_LOCKED);\n\n\tmsc_win_switch(msc);\n\n\tif (msc->mbuf && msc->mbuf->ready)\n\t\tmsc->mbuf->ready(msc->mbuf_priv, win->sgt,\n\t\t\t\t msc_win_total_sz(win));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const char * const msc_mode[] = {\n\t[MSC_MODE_SINGLE]\t= \"single\",\n\t[MSC_MODE_MULTI]\t= \"multi\",\n\t[MSC_MODE_EXI]\t\t= \"ExI\",\n\t[MSC_MODE_DEBUG]\t= \"debug\",\n};\n\nstatic ssize_t\nwrap_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct msc *msc = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", msc->wrap);\n}\n\nstatic ssize_t\nwrap_store(struct device *dev, struct device_attribute *attr, const char *buf,\n\t   size_t size)\n{\n\tstruct msc *msc = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmsc->wrap = !!val;\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(wrap);\n\nstatic void msc_buffer_unassign(struct msc *msc)\n{\n\tlockdep_assert_held(&msc->buf_mutex);\n\n\tif (!msc->mbuf)\n\t\treturn;\n\n\tmsc->mbuf->unassign(msc->mbuf_priv);\n\tmsu_buffer_put(msc->mbuf);\n\tmsc->mbuf_priv = NULL;\n\tmsc->mbuf = NULL;\n}\n\nstatic ssize_t\nmode_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct msc *msc = dev_get_drvdata(dev);\n\tconst char *mode = msc_mode[msc->mode];\n\tssize_t ret;\n\n\tmutex_lock(&msc->buf_mutex);\n\tif (msc->mbuf)\n\t\tmode = msc->mbuf->name;\n\tret = scnprintf(buf, PAGE_SIZE, \"%s\\n\", mode);\n\tmutex_unlock(&msc->buf_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t\nmode_store(struct device *dev, struct device_attribute *attr, const char *buf,\n\t   size_t size)\n{\n\tconst struct msu_buffer *mbuf = NULL;\n\tstruct msc *msc = dev_get_drvdata(dev);\n\tsize_t len = size;\n\tchar *cp, *mode;\n\tint i, ret;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\tcp = memchr(buf, '\\n', len);\n\tif (cp)\n\t\tlen = cp - buf;\n\n\tmode = kstrndup(buf, len, GFP_KERNEL);\n\tif (!mode)\n\t\treturn -ENOMEM;\n\n\ti = match_string(msc_mode, ARRAY_SIZE(msc_mode), mode);\n\tif (i >= 0) {\n\t\tkfree(mode);\n\t\tgoto found;\n\t}\n\n\t \n\tif (!msc->do_irq) {\n\t\tkfree(mode);\n\t\treturn -EINVAL;\n\t}\n\n\tmbuf = msu_buffer_get(mode);\n\tkfree(mode);\n\tif (mbuf)\n\t\tgoto found;\n\n\treturn -EINVAL;\n\nfound:\n\tif (i == MSC_MODE_MULTI && msc->multi_is_broken)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&msc->buf_mutex);\n\tret = 0;\n\n\t \n\tif (mbuf && mbuf == msc->mbuf) {\n\t\t \n\t\tmsu_buffer_put(mbuf);\n\t\tgoto unlock;\n\t}\n\n\tret = msc_buffer_unlocked_free_unless_used(msc);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (mbuf) {\n\t\tvoid *mbuf_priv = mbuf->assign(dev, &i);\n\n\t\tif (!mbuf_priv) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tmsc_buffer_unassign(msc);\n\t\tmsc->mbuf_priv = mbuf_priv;\n\t\tmsc->mbuf = mbuf;\n\t} else {\n\t\tmsc_buffer_unassign(msc);\n\t}\n\n\tmsc->mode = i;\n\nunlock:\n\tif (ret && mbuf)\n\t\tmsu_buffer_put(mbuf);\n\tmutex_unlock(&msc->buf_mutex);\n\n\treturn ret ? ret : size;\n}\n\nstatic DEVICE_ATTR_RW(mode);\n\nstatic ssize_t\nnr_pages_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct msc *msc = dev_get_drvdata(dev);\n\tstruct msc_window *win;\n\tsize_t count = 0;\n\n\tmutex_lock(&msc->buf_mutex);\n\n\tif (msc->mode == MSC_MODE_SINGLE)\n\t\tcount = scnprintf(buf, PAGE_SIZE, \"%ld\\n\", msc->nr_pages);\n\telse if (msc->mode == MSC_MODE_MULTI) {\n\t\tlist_for_each_entry(win, &msc->win_list, entry) {\n\t\t\tcount += scnprintf(buf + count, PAGE_SIZE - count,\n\t\t\t\t\t   \"%d%c\", win->nr_blocks,\n\t\t\t\t\t   msc_is_last_win(win) ? '\\n' : ',');\n\t\t}\n\t} else {\n\t\tcount = scnprintf(buf, PAGE_SIZE, \"unsupported\\n\");\n\t}\n\n\tmutex_unlock(&msc->buf_mutex);\n\n\treturn count;\n}\n\nstatic ssize_t\nnr_pages_store(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t size)\n{\n\tstruct msc *msc = dev_get_drvdata(dev);\n\tunsigned long val, *win = NULL, *rewin;\n\tsize_t len = size;\n\tconst char *p = buf;\n\tchar *end, *s;\n\tint ret, nr_wins = 0;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\tret = msc_buffer_free_unless_used(msc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tend = memchr(buf, '\\n', len);\n\tif (end)\n\t\tlen = end - buf;\n\n\tdo {\n\t\tend = memchr(p, ',', len);\n\t\ts = kstrndup(p, end ? end - p : len, GFP_KERNEL);\n\t\tif (!s) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_win;\n\t\t}\n\n\t\tret = kstrtoul(s, 10, &val);\n\t\tkfree(s);\n\n\t\tif (ret || !val)\n\t\t\tgoto free_win;\n\n\t\tif (nr_wins && msc->mode == MSC_MODE_SINGLE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_win;\n\t\t}\n\n\t\tnr_wins++;\n\t\trewin = krealloc_array(win, nr_wins, sizeof(*win), GFP_KERNEL);\n\t\tif (!rewin) {\n\t\t\tkfree(win);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\twin = rewin;\n\t\twin[nr_wins - 1] = val;\n\n\t\tif (!end)\n\t\t\tbreak;\n\n\t\t \n\t\tlen -= end - p + 1;\n\t\tp = end + 1;\n\t} while (len);\n\n\tmutex_lock(&msc->buf_mutex);\n\tret = msc_buffer_alloc(msc, win, nr_wins);\n\tmutex_unlock(&msc->buf_mutex);\n\nfree_win:\n\tkfree(win);\n\n\treturn ret ? ret : size;\n}\n\nstatic DEVICE_ATTR_RW(nr_pages);\n\nstatic ssize_t\nwin_switch_store(struct device *dev, struct device_attribute *attr,\n\t\t const char *buf, size_t size)\n{\n\tstruct msc *msc = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tret = -EINVAL;\n\tmutex_lock(&msc->buf_mutex);\n\t \n\tif (msc->mode == MSC_MODE_MULTI && !msc->mbuf)\n\t\tret = msc_win_switch(msc);\n\tmutex_unlock(&msc->buf_mutex);\n\n\treturn ret ? ret : size;\n}\n\nstatic DEVICE_ATTR_WO(win_switch);\n\nstatic ssize_t stop_on_full_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct msc *msc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", msc->stop_on_full);\n}\n\nstatic ssize_t stop_on_full_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tstruct msc *msc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = kstrtobool(buf, &msc->stop_on_full);\n\tif (ret)\n\t\treturn ret;\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(stop_on_full);\n\nstatic struct attribute *msc_output_attrs[] = {\n\t&dev_attr_wrap.attr,\n\t&dev_attr_mode.attr,\n\t&dev_attr_nr_pages.attr,\n\t&dev_attr_win_switch.attr,\n\t&dev_attr_stop_on_full.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group msc_output_group = {\n\t.attrs\t= msc_output_attrs,\n};\n\nstatic int intel_th_msc_probe(struct intel_th_device *thdev)\n{\n\tstruct device *dev = &thdev->dev;\n\tstruct resource *res;\n\tstruct msc *msc;\n\tvoid __iomem *base;\n\tint err;\n\n\tres = intel_th_device_get_resource(thdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tbase = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\tmsc = devm_kzalloc(dev, sizeof(*msc), GFP_KERNEL);\n\tif (!msc)\n\t\treturn -ENOMEM;\n\n\tres = intel_th_device_get_resource(thdev, IORESOURCE_IRQ, 1);\n\tif (!res)\n\t\tmsc->do_irq = 1;\n\n\tif (INTEL_TH_CAP(to_intel_th(thdev), multi_is_broken))\n\t\tmsc->multi_is_broken = 1;\n\n\tmsc->index = thdev->id;\n\n\tmsc->thdev = thdev;\n\tmsc->reg_base = base + msc->index * 0x100;\n\tmsc->msu_base = base;\n\n\tINIT_WORK(&msc->work, msc_work);\n\terr = intel_th_msc_init(msc);\n\tif (err)\n\t\treturn err;\n\n\tdev_set_drvdata(dev, msc);\n\n\treturn 0;\n}\n\nstatic void intel_th_msc_remove(struct intel_th_device *thdev)\n{\n\tstruct msc *msc = dev_get_drvdata(&thdev->dev);\n\tint ret;\n\n\tintel_th_msc_deactivate(thdev);\n\n\t \n\tret = msc_buffer_free_unless_used(msc);\n\tWARN_ON_ONCE(ret);\n}\n\nstatic struct intel_th_driver intel_th_msc_driver = {\n\t.probe\t= intel_th_msc_probe,\n\t.remove\t= intel_th_msc_remove,\n\t.irq\t\t= intel_th_msc_interrupt,\n\t.wait_empty\t= intel_th_msc_wait_empty,\n\t.activate\t= intel_th_msc_activate,\n\t.deactivate\t= intel_th_msc_deactivate,\n\t.fops\t= &intel_th_msc_fops,\n\t.attr_group\t= &msc_output_group,\n\t.driver\t= {\n\t\t.name\t= \"msc\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n};\n\nmodule_driver(intel_th_msc_driver,\n\t      intel_th_driver_register,\n\t      intel_th_driver_unregister);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel(R) Trace Hub Memory Storage Unit driver\");\nMODULE_AUTHOR(\"Alexander Shishkin <alexander.shishkin@linux.intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}