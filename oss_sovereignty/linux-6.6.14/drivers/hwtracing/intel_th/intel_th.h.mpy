{
  "module_name": "intel_th.h",
  "hash_id": "25138fdcf93da30dd4f088363b08e137d52cfb45e42ccd58ac3b27095627bcf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/intel_th/intel_th.h",
  "human_readable_source": " \n \n\n#ifndef __INTEL_TH_H__\n#define __INTEL_TH_H__\n\n#include <linux/irqreturn.h>\n\n \nenum {\n\t \n\tINTEL_TH_SOURCE = 0,\n\t \n\tINTEL_TH_OUTPUT,\n\t \n\tINTEL_TH_SWITCH,\n};\n\nstruct intel_th_device;\n\n \nstruct intel_th_output {\n\tint\t\tport;\n\tunsigned int\ttype;\n\tunsigned int\tscratchpad;\n\tbool\t\tmultiblock;\n\tbool\t\tactive;\n};\n\n \nstruct intel_th_drvdata {\n\tunsigned int\ttscu_enable        : 1,\n\t\t\tmulti_is_broken    : 1,\n\t\t\thas_mintctl        : 1,\n\t\t\thost_mode_only     : 1;\n};\n\n#define INTEL_TH_CAP(_th, _cap) ((_th)->drvdata ? (_th)->drvdata->_cap : 0)\n\n \nstruct intel_th_device {\n\tstruct device\t\tdev;\n\tconst struct intel_th_drvdata *drvdata;\n\tstruct resource\t\t*resource;\n\tunsigned int\t\tnum_resources;\n\tunsigned int\t\ttype;\n\tint\t\t\tid;\n\n\t \n\tbool\t\t\thost_mode;\n\n\t \n\tstruct intel_th_output\toutput;\n\n\tchar\t\tname[];\n};\n\n#define to_intel_th_device(_d)\t\t\t\t\\\n\tcontainer_of((_d), struct intel_th_device, dev)\n\n \nstatic inline struct resource *\nintel_th_device_get_resource(struct intel_th_device *thdev, unsigned int type,\n\t\t\t     unsigned int num)\n{\n\tint i;\n\n\tfor (i = 0; i < thdev->num_resources; i++)\n\t\tif (resource_type(&thdev->resource[i]) == type && !num--)\n\t\t\treturn &thdev->resource[i];\n\n\treturn NULL;\n}\n\n \nenum {\n\tGTH_NONE = 0,\n\tGTH_MSU,\t \n\tGTH_CTP,\t \n\tGTH_LPP,\t \n\tGTH_PTI,\t \n};\n\n \nstatic inline bool\nintel_th_output_assigned(struct intel_th_device *thdev)\n{\n\treturn thdev->type == INTEL_TH_OUTPUT &&\n\t\t(thdev->output.port >= 0 ||\n\t\t thdev->output.type == GTH_NONE);\n}\n\n \nstruct intel_th_driver {\n\tstruct device_driver\tdriver;\n\tint\t\t\t(*probe)(struct intel_th_device *thdev);\n\tvoid\t\t\t(*remove)(struct intel_th_device *thdev);\n\t \n\tint\t\t\t(*assign)(struct intel_th_device *thdev,\n\t\t\t\t\t  struct intel_th_device *othdev);\n\tvoid\t\t\t(*unassign)(struct intel_th_device *thdev,\n\t\t\t\t\t    struct intel_th_device *othdev);\n\tvoid\t\t\t(*prepare)(struct intel_th_device *thdev,\n\t\t\t\t\t   struct intel_th_output *output);\n\tvoid\t\t\t(*enable)(struct intel_th_device *thdev,\n\t\t\t\t\t  struct intel_th_output *output);\n\tvoid\t\t\t(*trig_switch)(struct intel_th_device *thdev,\n\t\t\t\t\t       struct intel_th_output *output);\n\tvoid\t\t\t(*disable)(struct intel_th_device *thdev,\n\t\t\t\t\t   struct intel_th_output *output);\n\t \n\tirqreturn_t\t\t(*irq)(struct intel_th_device *thdev);\n\tvoid\t\t\t(*wait_empty)(struct intel_th_device *thdev);\n\tint\t\t\t(*activate)(struct intel_th_device *thdev);\n\tvoid\t\t\t(*deactivate)(struct intel_th_device *thdev);\n\t \n\tconst struct file_operations *fops;\n\t \n\tconst struct attribute_group *attr_group;\n\n\t \n\tint\t\t\t(*set_output)(struct intel_th_device *thdev,\n\t\t\t\t\t      unsigned int master);\n};\n\n#define to_intel_th_driver(_d)\t\t\t\t\t\\\n\tcontainer_of((_d), struct intel_th_driver, driver)\n\n#define to_intel_th_driver_or_null(_d)\t\t\\\n\t((_d) ? to_intel_th_driver(_d) : NULL)\n\n \nstatic inline struct intel_th_device *\nto_intel_th_parent(const struct intel_th_device *thdev)\n{\n\tstruct device *parent = thdev->dev.parent;\n\n\tif (!parent)\n\t\treturn NULL;\n\n\treturn to_intel_th_device(parent);\n}\n\nstatic inline struct intel_th *to_intel_th(const struct intel_th_device *thdev)\n{\n\tif (thdev->type == INTEL_TH_OUTPUT)\n\t\tthdev = to_intel_th_parent(thdev);\n\n\tif (WARN_ON_ONCE(!thdev || thdev->type == INTEL_TH_OUTPUT))\n\t\treturn NULL;\n\n\treturn dev_get_drvdata(thdev->dev.parent);\n}\n\nstruct intel_th *\nintel_th_alloc(struct device *dev, const struct intel_th_drvdata *drvdata,\n\t       struct resource *devres, unsigned int ndevres);\nvoid intel_th_free(struct intel_th *th);\n\nint intel_th_driver_register(struct intel_th_driver *thdrv);\nvoid intel_th_driver_unregister(struct intel_th_driver *thdrv);\n\nint intel_th_trace_enable(struct intel_th_device *thdev);\nint intel_th_trace_switch(struct intel_th_device *thdev);\nint intel_th_trace_disable(struct intel_th_device *thdev);\nint intel_th_set_output(struct intel_th_device *thdev,\n\t\t\tunsigned int master);\nint intel_th_output_enable(struct intel_th *th, unsigned int otype);\n\nenum th_mmio_idx {\n\tTH_MMIO_CONFIG = 0,\n\tTH_MMIO_SW = 1,\n\tTH_MMIO_RTIT = 2,\n\tTH_MMIO_END,\n};\n\n#define TH_POSSIBLE_OUTPUTS\t8\n \n#define TH_SUBDEVICE_MAX\t(TH_POSSIBLE_OUTPUTS + 2)\n#define TH_CONFIGURABLE_MASTERS 256\n#define TH_MSC_MAX\t\t2\n\n \n#define TH_NVEC_MAX\t\t8\n\n \nstruct intel_th {\n\tstruct device\t\t*dev;\n\n\tstruct intel_th_device\t*thdev[TH_SUBDEVICE_MAX];\n\tstruct intel_th_device\t*hub;\n\tconst struct intel_th_drvdata\t*drvdata;\n\n\tstruct resource\t\tresource[TH_MMIO_END];\n\tint\t\t\t(*activate)(struct intel_th *);\n\tvoid\t\t\t(*deactivate)(struct intel_th *);\n\tunsigned int\t\tnum_thdevs;\n\tunsigned int\t\tnum_resources;\n\tint\t\t\tirq;\n\tint\t\t\tnum_irqs;\n\n\tint\t\t\tid;\n\tint\t\t\tmajor;\n#ifdef CONFIG_MODULES\n\tstruct work_struct\trequest_module_work;\n#endif  \n#ifdef CONFIG_INTEL_TH_DEBUG\n\tstruct dentry\t\t*dbg;\n#endif\n};\n\nstatic inline struct intel_th_device *\nto_intel_th_hub(struct intel_th_device *thdev)\n{\n\tif (thdev->type == INTEL_TH_SWITCH)\n\t\treturn thdev;\n\telse if (thdev->type == INTEL_TH_OUTPUT)\n\t\treturn to_intel_th_parent(thdev);\n\n\treturn to_intel_th(thdev)->hub;\n}\n\n \nenum {\n\t \n\tREG_GTH_OFFSET\t\t= 0x0000,\n\tREG_GTH_LENGTH\t\t= 0x2000,\n\n\t \n\tREG_TSCU_OFFSET\t\t= 0x2000,\n\tREG_TSCU_LENGTH\t\t= 0x1000,\n\n\tREG_CTS_OFFSET\t\t= 0x3000,\n\tREG_CTS_LENGTH\t\t= 0x1000,\n\n\t \n\tREG_STH_OFFSET\t\t= 0x4000,\n\tREG_STH_LENGTH\t\t= 0x2000,\n\n\t \n\tREG_MSU_OFFSET\t\t= 0xa0000,\n\tREG_MSU_LENGTH\t\t= 0x02000,\n\n\t \n\tBUF_MSU_OFFSET\t\t= 0x80000,\n\tBUF_MSU_LENGTH\t\t= 0x20000,\n\n\t \n\tREG_PTI_OFFSET\t\t= REG_GTH_OFFSET,\n\tREG_PTI_LENGTH\t\t= REG_GTH_LENGTH,\n\n\t \n\tREG_DCIH_OFFSET\t\t= REG_MSU_OFFSET,\n\tREG_DCIH_LENGTH\t\t= REG_MSU_LENGTH,\n};\n\n \nenum {\n\t \n\tSCRPD_MEM_IS_PRIM_DEST\t\t= BIT(0),\n\t \n\tSCRPD_DBC_IS_PRIM_DEST\t\t= BIT(1),\n\t \n\tSCRPD_PTI_IS_PRIM_DEST\t\t= BIT(2),\n\t \n\tSCRPD_BSSB_IS_PRIM_DEST\t\t= BIT(3),\n\t \n\tSCRPD_PTI_IS_ALT_DEST\t\t= BIT(4),\n\t \n\tSCRPD_BSSB_IS_ALT_DEST\t\t= BIT(5),\n\t \n\tSCRPD_DEEPSX_EXIT\t\t= BIT(6),\n\t \n\tSCRPD_S4_EXIT\t\t\t= BIT(7),\n\t \n\tSCRPD_S5_EXIT\t\t\t= BIT(8),\n\t \n\tSCRPD_MSC0_IS_ENABLED\t\t= BIT(9),\n\tSCRPD_MSC1_IS_ENABLED\t\t= BIT(10),\n\t \n\tSCRPD_SX_EXIT\t\t\t= BIT(11),\n\t \n\tSCRPD_TRIGGER_IS_ENABLED\t= BIT(12),\n\tSCRPD_ODLA_IS_ENABLED\t\t= BIT(13),\n\tSCRPD_SOCHAP_IS_ENABLED\t\t= BIT(14),\n\tSCRPD_STH_IS_ENABLED\t\t= BIT(15),\n\tSCRPD_DCIH_IS_ENABLED\t\t= BIT(16),\n\tSCRPD_VER_IS_ENABLED\t\t= BIT(17),\n\t \n\tSCRPD_DEBUGGER_IN_USE\t\t= BIT(24),\n};\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}