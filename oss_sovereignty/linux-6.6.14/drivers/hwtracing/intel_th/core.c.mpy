{
  "module_name": "core.c",
  "hash_id": "5a1d18ab262fbb3ea2272a32ed52a66134961c0d74ea362b660bf992f997e33c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/intel_th/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/kdev_t.h>\n#include <linux/debugfs.h>\n#include <linux/idr.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/dma-mapping.h>\n\n#include \"intel_th.h\"\n#include \"debug.h\"\n\nstatic bool host_mode __read_mostly;\nmodule_param(host_mode, bool, 0444);\n\nstatic DEFINE_IDA(intel_th_ida);\n\nstatic int intel_th_match(struct device *dev, struct device_driver *driver)\n{\n\tstruct intel_th_driver *thdrv = to_intel_th_driver(driver);\n\tstruct intel_th_device *thdev = to_intel_th_device(dev);\n\n\tif (thdev->type == INTEL_TH_SWITCH &&\n\t    (!thdrv->enable || !thdrv->disable))\n\t\treturn 0;\n\n\treturn !strcmp(thdev->name, driver->name);\n}\n\nstatic int intel_th_child_remove(struct device *dev, void *data)\n{\n\tdevice_release_driver(dev);\n\n\treturn 0;\n}\n\nstatic int intel_th_probe(struct device *dev)\n{\n\tstruct intel_th_driver *thdrv = to_intel_th_driver(dev->driver);\n\tstruct intel_th_device *thdev = to_intel_th_device(dev);\n\tstruct intel_th_driver *hubdrv;\n\tstruct intel_th_device *hub = NULL;\n\tint ret;\n\n\tif (thdev->type == INTEL_TH_SWITCH)\n\t\thub = thdev;\n\telse if (dev->parent)\n\t\thub = to_intel_th_device(dev->parent);\n\n\tif (!hub || !hub->dev.driver)\n\t\treturn -EPROBE_DEFER;\n\n\thubdrv = to_intel_th_driver(hub->dev.driver);\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_no_callbacks(dev);\n\tpm_runtime_enable(dev);\n\n\tret = thdrv->probe(to_intel_th_device(dev));\n\tif (ret)\n\t\tgoto out_pm;\n\n\tif (thdrv->attr_group) {\n\t\tret = sysfs_create_group(&thdev->dev.kobj, thdrv->attr_group);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (thdev->type == INTEL_TH_OUTPUT &&\n\t    !intel_th_output_assigned(thdev))\n\t\t \n\t\tret = hubdrv->assign(hub, thdev);\n\nout:\n\tif (ret)\n\t\tthdrv->remove(thdev);\n\nout_pm:\n\tif (ret)\n\t\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic void intel_th_device_remove(struct intel_th_device *thdev);\n\nstatic void intel_th_remove(struct device *dev)\n{\n\tstruct intel_th_driver *thdrv = to_intel_th_driver(dev->driver);\n\tstruct intel_th_device *thdev = to_intel_th_device(dev);\n\tstruct intel_th_device *hub = to_intel_th_hub(thdev);\n\n\tif (thdev->type == INTEL_TH_SWITCH) {\n\t\tstruct intel_th *th = to_intel_th(hub);\n\t\tint i, lowest;\n\n\t\t \n\t\tdevice_for_each_child(dev, thdev, intel_th_child_remove);\n\n\t\t \n\t\tfor (i = 0, lowest = -1; i < th->num_thdevs; i++) {\n\t\t\t \n\t\t\tif (th->thdev[i]->type != INTEL_TH_OUTPUT) {\n\t\t\t\tif (lowest >= 0) {\n\t\t\t\t\tth->thdev[lowest] = th->thdev[i];\n\t\t\t\t\tth->thdev[i] = NULL;\n\t\t\t\t\t++lowest;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (lowest == -1)\n\t\t\t\tlowest = i;\n\n\t\t\tintel_th_device_remove(th->thdev[i]);\n\t\t\tth->thdev[i] = NULL;\n\t\t}\n\n\t\tif (lowest >= 0)\n\t\t\tth->num_thdevs = lowest;\n\t}\n\n\tif (thdrv->attr_group)\n\t\tsysfs_remove_group(&thdev->dev.kobj, thdrv->attr_group);\n\n\tpm_runtime_get_sync(dev);\n\n\tthdrv->remove(thdev);\n\n\tif (intel_th_output_assigned(thdev)) {\n\t\tstruct intel_th_driver *hubdrv =\n\t\t\tto_intel_th_driver(dev->parent->driver);\n\n\t\tif (hub->dev.driver)\n\t\t\t \n\t\t\thubdrv->unassign(hub, thdev);\n\t}\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n}\n\nstatic struct bus_type intel_th_bus = {\n\t.name\t\t= \"intel_th\",\n\t.match\t\t= intel_th_match,\n\t.probe\t\t= intel_th_probe,\n\t.remove\t\t= intel_th_remove,\n};\n\nstatic void intel_th_device_free(struct intel_th_device *thdev);\n\nstatic void intel_th_device_release(struct device *dev)\n{\n\tintel_th_device_free(to_intel_th_device(dev));\n}\n\nstatic struct device_type intel_th_source_device_type = {\n\t.name\t\t= \"intel_th_source_device\",\n\t.release\t= intel_th_device_release,\n};\n\nstatic char *intel_th_output_devnode(const struct device *dev, umode_t *mode,\n\t\t\t\t     kuid_t *uid, kgid_t *gid)\n{\n\tconst struct intel_th_device *thdev = to_intel_th_device(dev);\n\tconst struct intel_th *th = to_intel_th(thdev);\n\tchar *node;\n\n\tif (thdev->id >= 0)\n\t\tnode = kasprintf(GFP_KERNEL, \"intel_th%d/%s%d\", th->id,\n\t\t\t\t thdev->name, thdev->id);\n\telse\n\t\tnode = kasprintf(GFP_KERNEL, \"intel_th%d/%s\", th->id,\n\t\t\t\t thdev->name);\n\n\treturn node;\n}\n\nstatic ssize_t port_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct intel_th_device *thdev = to_intel_th_device(dev);\n\n\tif (thdev->output.port >= 0)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", thdev->output.port);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"unassigned\\n\");\n}\n\nstatic DEVICE_ATTR_RO(port);\n\nstatic void intel_th_trace_prepare(struct intel_th_device *thdev)\n{\n\tstruct intel_th_device *hub = to_intel_th_hub(thdev);\n\tstruct intel_th_driver *hubdrv = to_intel_th_driver(hub->dev.driver);\n\n\tif (hub->type != INTEL_TH_SWITCH)\n\t\treturn;\n\n\tif (thdev->type != INTEL_TH_OUTPUT)\n\t\treturn;\n\n\tpm_runtime_get_sync(&thdev->dev);\n\thubdrv->prepare(hub, &thdev->output);\n\tpm_runtime_put(&thdev->dev);\n}\n\nstatic int intel_th_output_activate(struct intel_th_device *thdev)\n{\n\tstruct intel_th_driver *thdrv =\n\t\tto_intel_th_driver_or_null(thdev->dev.driver);\n\tstruct intel_th *th = to_intel_th(thdev);\n\tint ret = 0;\n\n\tif (!thdrv)\n\t\treturn -ENODEV;\n\n\tif (!try_module_get(thdrv->driver.owner))\n\t\treturn -ENODEV;\n\n\tpm_runtime_get_sync(&thdev->dev);\n\n\tif (th->activate)\n\t\tret = th->activate(th);\n\tif (ret)\n\t\tgoto fail_put;\n\n\tintel_th_trace_prepare(thdev);\n\tif (thdrv->activate)\n\t\tret = thdrv->activate(thdev);\n\telse\n\t\tintel_th_trace_enable(thdev);\n\n\tif (ret)\n\t\tgoto fail_deactivate;\n\n\treturn 0;\n\nfail_deactivate:\n\tif (th->deactivate)\n\t\tth->deactivate(th);\n\nfail_put:\n\tpm_runtime_put(&thdev->dev);\n\tmodule_put(thdrv->driver.owner);\n\n\treturn ret;\n}\n\nstatic void intel_th_output_deactivate(struct intel_th_device *thdev)\n{\n\tstruct intel_th_driver *thdrv =\n\t\tto_intel_th_driver_or_null(thdev->dev.driver);\n\tstruct intel_th *th = to_intel_th(thdev);\n\n\tif (!thdrv)\n\t\treturn;\n\n\tif (thdrv->deactivate)\n\t\tthdrv->deactivate(thdev);\n\telse\n\t\tintel_th_trace_disable(thdev);\n\n\tif (th->deactivate)\n\t\tth->deactivate(th);\n\n\tpm_runtime_put(&thdev->dev);\n\tmodule_put(thdrv->driver.owner);\n}\n\nstatic ssize_t active_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct intel_th_device *thdev = to_intel_th_device(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", thdev->output.active);\n}\n\nstatic ssize_t active_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t size)\n{\n\tstruct intel_th_device *thdev = to_intel_th_device(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!!val != thdev->output.active) {\n\t\tif (val)\n\t\t\tret = intel_th_output_activate(thdev);\n\t\telse\n\t\t\tintel_th_output_deactivate(thdev);\n\t}\n\n\treturn ret ? ret : size;\n}\n\nstatic DEVICE_ATTR_RW(active);\n\nstatic struct attribute *intel_th_output_attrs[] = {\n\t&dev_attr_port.attr,\n\t&dev_attr_active.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(intel_th_output);\n\nstatic struct device_type intel_th_output_device_type = {\n\t.name\t\t= \"intel_th_output_device\",\n\t.groups\t\t= intel_th_output_groups,\n\t.release\t= intel_th_device_release,\n\t.devnode\t= intel_th_output_devnode,\n};\n\nstatic struct device_type intel_th_switch_device_type = {\n\t.name\t\t= \"intel_th_switch_device\",\n\t.release\t= intel_th_device_release,\n};\n\nstatic struct device_type *intel_th_device_type[] = {\n\t[INTEL_TH_SOURCE]\t= &intel_th_source_device_type,\n\t[INTEL_TH_OUTPUT]\t= &intel_th_output_device_type,\n\t[INTEL_TH_SWITCH]\t= &intel_th_switch_device_type,\n};\n\nint intel_th_driver_register(struct intel_th_driver *thdrv)\n{\n\tif (!thdrv->probe || !thdrv->remove)\n\t\treturn -EINVAL;\n\n\tthdrv->driver.bus = &intel_th_bus;\n\n\treturn driver_register(&thdrv->driver);\n}\nEXPORT_SYMBOL_GPL(intel_th_driver_register);\n\nvoid intel_th_driver_unregister(struct intel_th_driver *thdrv)\n{\n\tdriver_unregister(&thdrv->driver);\n}\nEXPORT_SYMBOL_GPL(intel_th_driver_unregister);\n\nstatic struct intel_th_device *\nintel_th_device_alloc(struct intel_th *th, unsigned int type, const char *name,\n\t\t      int id)\n{\n\tstruct device *parent;\n\tstruct intel_th_device *thdev;\n\n\tif (type == INTEL_TH_OUTPUT)\n\t\tparent = &th->hub->dev;\n\telse\n\t\tparent = th->dev;\n\n\tthdev = kzalloc(sizeof(*thdev) + strlen(name) + 1, GFP_KERNEL);\n\tif (!thdev)\n\t\treturn NULL;\n\n\tthdev->id = id;\n\tthdev->type = type;\n\n\tstrcpy(thdev->name, name);\n\tdevice_initialize(&thdev->dev);\n\tthdev->dev.bus = &intel_th_bus;\n\tthdev->dev.type = intel_th_device_type[type];\n\tthdev->dev.parent = parent;\n\tthdev->dev.dma_mask = parent->dma_mask;\n\tthdev->dev.dma_parms = parent->dma_parms;\n\tdma_set_coherent_mask(&thdev->dev, parent->coherent_dma_mask);\n\tif (id >= 0)\n\t\tdev_set_name(&thdev->dev, \"%d-%s%d\", th->id, name, id);\n\telse\n\t\tdev_set_name(&thdev->dev, \"%d-%s\", th->id, name);\n\n\treturn thdev;\n}\n\nstatic int intel_th_device_add_resources(struct intel_th_device *thdev,\n\t\t\t\t\t struct resource *res, int nres)\n{\n\tstruct resource *r;\n\n\tr = kmemdup(res, sizeof(*res) * nres, GFP_KERNEL);\n\tif (!r)\n\t\treturn -ENOMEM;\n\n\tthdev->resource = r;\n\tthdev->num_resources = nres;\n\n\treturn 0;\n}\n\nstatic void intel_th_device_remove(struct intel_th_device *thdev)\n{\n\tdevice_del(&thdev->dev);\n\tput_device(&thdev->dev);\n}\n\nstatic void intel_th_device_free(struct intel_th_device *thdev)\n{\n\tkfree(thdev->resource);\n\tkfree(thdev);\n}\n\n \nstatic const struct intel_th_subdevice {\n\tconst char\t\t*name;\n\tstruct resource\t\tres[3];\n\tunsigned\t\tnres;\n\tunsigned\t\ttype;\n\tunsigned\t\totype;\n\tbool\t\t\tmknode;\n\tunsigned\t\tscrpd;\n\tint\t\t\tid;\n} intel_th_subdevices[] = {\n\t{\n\t\t.nres\t= 1,\n\t\t.res\t= {\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.start\t= REG_GTH_OFFSET,\n\t\t\t\t.end\t= REG_CTS_OFFSET + REG_CTS_LENGTH - 1,\n\t\t\t\t.flags\t= IORESOURCE_MEM,\n\t\t\t},\n\t\t},\n\t\t.name\t= \"gth\",\n\t\t.type\t= INTEL_TH_SWITCH,\n\t\t.id\t= -1,\n\t},\n\t{\n\t\t.nres\t= 2,\n\t\t.res\t= {\n\t\t\t{\n\t\t\t\t.start\t= REG_MSU_OFFSET,\n\t\t\t\t.end\t= REG_MSU_OFFSET + REG_MSU_LENGTH - 1,\n\t\t\t\t.flags\t= IORESOURCE_MEM,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.start\t= BUF_MSU_OFFSET,\n\t\t\t\t.end\t= BUF_MSU_OFFSET + BUF_MSU_LENGTH - 1,\n\t\t\t\t.flags\t= IORESOURCE_MEM,\n\t\t\t},\n\t\t},\n\t\t.name\t= \"msc\",\n\t\t.id\t= 0,\n\t\t.type\t= INTEL_TH_OUTPUT,\n\t\t.mknode\t= true,\n\t\t.otype\t= GTH_MSU,\n\t\t.scrpd\t= SCRPD_MEM_IS_PRIM_DEST | SCRPD_MSC0_IS_ENABLED,\n\t},\n\t{\n\t\t.nres\t= 2,\n\t\t.res\t= {\n\t\t\t{\n\t\t\t\t.start\t= REG_MSU_OFFSET,\n\t\t\t\t.end\t= REG_MSU_OFFSET + REG_MSU_LENGTH - 1,\n\t\t\t\t.flags\t= IORESOURCE_MEM,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.start\t= BUF_MSU_OFFSET,\n\t\t\t\t.end\t= BUF_MSU_OFFSET + BUF_MSU_LENGTH - 1,\n\t\t\t\t.flags\t= IORESOURCE_MEM,\n\t\t\t},\n\t\t},\n\t\t.name\t= \"msc\",\n\t\t.id\t= 1,\n\t\t.type\t= INTEL_TH_OUTPUT,\n\t\t.mknode\t= true,\n\t\t.otype\t= GTH_MSU,\n\t\t.scrpd\t= SCRPD_MEM_IS_PRIM_DEST | SCRPD_MSC1_IS_ENABLED,\n\t},\n\t{\n\t\t.nres\t= 2,\n\t\t.res\t= {\n\t\t\t{\n\t\t\t\t.start\t= REG_STH_OFFSET,\n\t\t\t\t.end\t= REG_STH_OFFSET + REG_STH_LENGTH - 1,\n\t\t\t\t.flags\t= IORESOURCE_MEM,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.start\t= TH_MMIO_SW,\n\t\t\t\t.end\t= 0,\n\t\t\t\t.flags\t= IORESOURCE_MEM,\n\t\t\t},\n\t\t},\n\t\t.id\t= -1,\n\t\t.name\t= \"sth\",\n\t\t.type\t= INTEL_TH_SOURCE,\n\t},\n\t{\n\t\t.nres\t= 2,\n\t\t.res\t= {\n\t\t\t{\n\t\t\t\t.start\t= REG_STH_OFFSET,\n\t\t\t\t.end\t= REG_STH_OFFSET + REG_STH_LENGTH - 1,\n\t\t\t\t.flags\t= IORESOURCE_MEM,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.start\t= TH_MMIO_RTIT,\n\t\t\t\t.end\t= 0,\n\t\t\t\t.flags\t= IORESOURCE_MEM,\n\t\t\t},\n\t\t},\n\t\t.id\t= -1,\n\t\t.name\t= \"rtit\",\n\t\t.type\t= INTEL_TH_SOURCE,\n\t},\n\t{\n\t\t.nres\t= 1,\n\t\t.res\t= {\n\t\t\t{\n\t\t\t\t.start\t= REG_PTI_OFFSET,\n\t\t\t\t.end\t= REG_PTI_OFFSET + REG_PTI_LENGTH - 1,\n\t\t\t\t.flags\t= IORESOURCE_MEM,\n\t\t\t},\n\t\t},\n\t\t.id\t= -1,\n\t\t.name\t= \"pti\",\n\t\t.type\t= INTEL_TH_OUTPUT,\n\t\t.otype\t= GTH_PTI,\n\t\t.scrpd\t= SCRPD_PTI_IS_PRIM_DEST,\n\t},\n\t{\n\t\t.nres\t= 1,\n\t\t.res\t= {\n\t\t\t{\n\t\t\t\t.start\t= REG_PTI_OFFSET,\n\t\t\t\t.end\t= REG_PTI_OFFSET + REG_PTI_LENGTH - 1,\n\t\t\t\t.flags\t= IORESOURCE_MEM,\n\t\t\t},\n\t\t},\n\t\t.id\t= -1,\n\t\t.name\t= \"lpp\",\n\t\t.type\t= INTEL_TH_OUTPUT,\n\t\t.otype\t= GTH_LPP,\n\t\t.scrpd\t= SCRPD_PTI_IS_PRIM_DEST,\n\t},\n\t{\n\t\t.nres\t= 1,\n\t\t.res\t= {\n\t\t\t{\n\t\t\t\t.start\t= REG_DCIH_OFFSET,\n\t\t\t\t.end\t= REG_DCIH_OFFSET + REG_DCIH_LENGTH - 1,\n\t\t\t\t.flags\t= IORESOURCE_MEM,\n\t\t\t},\n\t\t},\n\t\t.id\t= -1,\n\t\t.name\t= \"dcih\",\n\t\t.type\t= INTEL_TH_OUTPUT,\n\t},\n};\n\n#ifdef CONFIG_MODULES\nstatic void __intel_th_request_hub_module(struct work_struct *work)\n{\n\tstruct intel_th *th = container_of(work, struct intel_th,\n\t\t\t\t\t   request_module_work);\n\n\trequest_module(\"intel_th_%s\", th->hub->name);\n}\n\nstatic int intel_th_request_hub_module(struct intel_th *th)\n{\n\tINIT_WORK(&th->request_module_work, __intel_th_request_hub_module);\n\tschedule_work(&th->request_module_work);\n\n\treturn 0;\n}\n\nstatic void intel_th_request_hub_module_flush(struct intel_th *th)\n{\n\tflush_work(&th->request_module_work);\n}\n#else\nstatic inline int intel_th_request_hub_module(struct intel_th *th)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void intel_th_request_hub_module_flush(struct intel_th *th)\n{\n}\n#endif  \n\nstatic struct intel_th_device *\nintel_th_subdevice_alloc(struct intel_th *th,\n\t\t\t const struct intel_th_subdevice *subdev)\n{\n\tstruct intel_th_device *thdev;\n\tstruct resource res[3];\n\tunsigned int req = 0;\n\tint r, err;\n\n\tthdev = intel_th_device_alloc(th, subdev->type, subdev->name,\n\t\t\t\t      subdev->id);\n\tif (!thdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tthdev->drvdata = th->drvdata;\n\n\tmemcpy(res, subdev->res,\n\t       sizeof(struct resource) * subdev->nres);\n\n\tfor (r = 0; r < subdev->nres; r++) {\n\t\tstruct resource *devres = th->resource;\n\t\tint bar = TH_MMIO_CONFIG;\n\n\t\t \n\t\tif (!res[r].end && res[r].flags == IORESOURCE_MEM) {\n\t\t\tbar = res[r].start;\n\t\t\terr = -ENODEV;\n\t\t\tif (bar >= th->num_resources)\n\t\t\t\tgoto fail_put_device;\n\t\t\tres[r].start = 0;\n\t\t\tres[r].end = resource_size(&devres[bar]) - 1;\n\t\t}\n\n\t\tif (res[r].flags & IORESOURCE_MEM) {\n\t\t\tres[r].start\t+= devres[bar].start;\n\t\t\tres[r].end\t+= devres[bar].start;\n\n\t\t\tdev_dbg(th->dev, \"%s:%d @ %pR\\n\",\n\t\t\t\tsubdev->name, r, &res[r]);\n\t\t} else if (res[r].flags & IORESOURCE_IRQ) {\n\t\t\t \n\t\t\tif (INTEL_TH_CAP(th, has_mintctl) && th->irq != -1)\n\t\t\t\tres[r].start = th->irq;\n\t\t}\n\t}\n\n\terr = intel_th_device_add_resources(thdev, res, subdev->nres);\n\tif (err)\n\t\tgoto fail_put_device;\n\n\tif (subdev->type == INTEL_TH_OUTPUT) {\n\t\tif (subdev->mknode)\n\t\t\tthdev->dev.devt = MKDEV(th->major, th->num_thdevs);\n\t\tthdev->output.type = subdev->otype;\n\t\tthdev->output.port = -1;\n\t\tthdev->output.scratchpad = subdev->scrpd;\n\t} else if (subdev->type == INTEL_TH_SWITCH) {\n\t\tthdev->host_mode =\n\t\t\tINTEL_TH_CAP(th, host_mode_only) ? true : host_mode;\n\t\tth->hub = thdev;\n\t}\n\n\terr = device_add(&thdev->dev);\n\tif (err)\n\t\tgoto fail_free_res;\n\n\t \n\tif (subdev->type == INTEL_TH_SWITCH && !req) {\n\t\terr = intel_th_request_hub_module(th);\n\t\tif (!err)\n\t\t\treq++;\n\t}\n\n\treturn thdev;\n\nfail_free_res:\n\tkfree(thdev->resource);\n\nfail_put_device:\n\tput_device(&thdev->dev);\n\n\treturn ERR_PTR(err);\n}\n\n \nint intel_th_output_enable(struct intel_th *th, unsigned int otype)\n{\n\tstruct intel_th_device *thdev;\n\tint src = 0, dst = 0;\n\n\tfor (src = 0, dst = 0; dst <= th->num_thdevs; src++, dst++) {\n\t\tfor (; src < ARRAY_SIZE(intel_th_subdevices); src++) {\n\t\t\tif (intel_th_subdevices[src].type != INTEL_TH_OUTPUT)\n\t\t\t\tcontinue;\n\n\t\t\tif (intel_th_subdevices[src].otype != otype)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (src == ARRAY_SIZE(intel_th_subdevices))\n\t\t\treturn -ENODEV;\n\n\t\tfor (; dst < th->num_thdevs; dst++) {\n\t\t\tif (th->thdev[dst]->type != INTEL_TH_OUTPUT)\n\t\t\t\tcontinue;\n\n\t\t\tif (th->thdev[dst]->output.type != otype)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dst == th->num_thdevs)\n\t\t\tgoto found;\n\t}\n\n\treturn -ENODEV;\n\nfound:\n\tthdev = intel_th_subdevice_alloc(th, &intel_th_subdevices[src]);\n\tif (IS_ERR(thdev))\n\t\treturn PTR_ERR(thdev);\n\n\tth->thdev[th->num_thdevs++] = thdev;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_th_output_enable);\n\nstatic int intel_th_populate(struct intel_th *th)\n{\n\tint src;\n\n\t \n\tfor (src = 0; src < ARRAY_SIZE(intel_th_subdevices); src++) {\n\t\tconst struct intel_th_subdevice *subdev =\n\t\t\t&intel_th_subdevices[src];\n\t\tstruct intel_th_device *thdev;\n\n\t\t \n\t\tif ((INTEL_TH_CAP(th, host_mode_only) || host_mode) &&\n\t\t    subdev->type == INTEL_TH_OUTPUT)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (subdev->type == INTEL_TH_OUTPUT &&\n\t\t    subdev->otype != GTH_NONE)\n\t\t\tcontinue;\n\n\t\tthdev = intel_th_subdevice_alloc(th, subdev);\n\t\t \n\t\tif (IS_ERR(thdev)) {\n\t\t\t \n\t\t\tif (PTR_ERR(thdev) == -ENODEV)\n\t\t\t\tcontinue;\n\n\t\t\treturn PTR_ERR(thdev);\n\t\t}\n\n\t\tth->thdev[th->num_thdevs++] = thdev;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_th_output_open(struct inode *inode, struct file *file)\n{\n\tconst struct file_operations *fops;\n\tstruct intel_th_driver *thdrv;\n\tstruct device *dev;\n\tint err;\n\n\tdev = bus_find_device_by_devt(&intel_th_bus, inode->i_rdev);\n\tif (!dev || !dev->driver)\n\t\treturn -ENODEV;\n\n\tthdrv = to_intel_th_driver(dev->driver);\n\tfops = fops_get(thdrv->fops);\n\tif (!fops)\n\t\treturn -ENODEV;\n\n\treplace_fops(file, fops);\n\n\tfile->private_data = to_intel_th_device(dev);\n\n\tif (file->f_op->open) {\n\t\terr = file->f_op->open(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct file_operations intel_th_output_fops = {\n\t.open\t= intel_th_output_open,\n\t.llseek\t= noop_llseek,\n};\n\nstatic irqreturn_t intel_th_irq(int irq, void *data)\n{\n\tstruct intel_th *th = data;\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct intel_th_driver *d;\n\tint i;\n\n\tfor (i = 0; i < th->num_thdevs; i++) {\n\t\tif (th->thdev[i]->type != INTEL_TH_OUTPUT)\n\t\t\tcontinue;\n\n\t\td = to_intel_th_driver(th->thdev[i]->dev.driver);\n\t\tif (d && d->irq)\n\t\t\tret |= d->irq(th->thdev[i]);\n\t}\n\n\treturn ret;\n}\n\n \nstruct intel_th *\nintel_th_alloc(struct device *dev, const struct intel_th_drvdata *drvdata,\n\t       struct resource *devres, unsigned int ndevres)\n{\n\tint err, r, nr_mmios = 0;\n\tstruct intel_th *th;\n\n\tth = kzalloc(sizeof(*th), GFP_KERNEL);\n\tif (!th)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tth->id = ida_simple_get(&intel_th_ida, 0, 0, GFP_KERNEL);\n\tif (th->id < 0) {\n\t\terr = th->id;\n\t\tgoto err_alloc;\n\t}\n\n\tth->major = __register_chrdev(0, 0, TH_POSSIBLE_OUTPUTS,\n\t\t\t\t      \"intel_th/output\", &intel_th_output_fops);\n\tif (th->major < 0) {\n\t\terr = th->major;\n\t\tgoto err_ida;\n\t}\n\tth->irq = -1;\n\tth->dev = dev;\n\tth->drvdata = drvdata;\n\n\tfor (r = 0; r < ndevres; r++)\n\t\tswitch (devres[r].flags & IORESOURCE_TYPE_BITS) {\n\t\tcase IORESOURCE_MEM:\n\t\t\tth->resource[nr_mmios++] = devres[r];\n\t\t\tbreak;\n\t\tcase IORESOURCE_IRQ:\n\t\t\terr = devm_request_irq(dev, devres[r].start,\n\t\t\t\t\t       intel_th_irq, IRQF_SHARED,\n\t\t\t\t\t       dev_name(dev), th);\n\t\t\tif (err)\n\t\t\t\tgoto err_chrdev;\n\n\t\t\tif (th->irq == -1)\n\t\t\t\tth->irq = devres[r].start;\n\t\t\tth->num_irqs++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(dev, \"Unknown resource type %lx\\n\",\n\t\t\t\t devres[r].flags);\n\t\t\tbreak;\n\t\t}\n\n\tth->num_resources = nr_mmios;\n\n\tdev_set_drvdata(dev, th);\n\n\tpm_runtime_no_callbacks(dev);\n\tpm_runtime_put(dev);\n\tpm_runtime_allow(dev);\n\n\terr = intel_th_populate(th);\n\tif (err) {\n\t\t \n\t\tintel_th_free(th);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn th;\n\nerr_chrdev:\n\t__unregister_chrdev(th->major, 0, TH_POSSIBLE_OUTPUTS,\n\t\t\t    \"intel_th/output\");\n\nerr_ida:\n\tida_simple_remove(&intel_th_ida, th->id);\n\nerr_alloc:\n\tkfree(th);\n\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(intel_th_alloc);\n\nvoid intel_th_free(struct intel_th *th)\n{\n\tint i;\n\n\tintel_th_request_hub_module_flush(th);\n\n\tintel_th_device_remove(th->hub);\n\tfor (i = 0; i < th->num_thdevs; i++) {\n\t\tif (th->thdev[i] != th->hub)\n\t\t\tintel_th_device_remove(th->thdev[i]);\n\t\tth->thdev[i] = NULL;\n\t}\n\n\tth->num_thdevs = 0;\n\n\tfor (i = 0; i < th->num_irqs; i++)\n\t\tdevm_free_irq(th->dev, th->irq + i, th);\n\n\tpm_runtime_get_sync(th->dev);\n\tpm_runtime_forbid(th->dev);\n\n\t__unregister_chrdev(th->major, 0, TH_POSSIBLE_OUTPUTS,\n\t\t\t    \"intel_th/output\");\n\n\tida_simple_remove(&intel_th_ida, th->id);\n\n\tkfree(th);\n}\nEXPORT_SYMBOL_GPL(intel_th_free);\n\n \nint intel_th_trace_enable(struct intel_th_device *thdev)\n{\n\tstruct intel_th_device *hub = to_intel_th_device(thdev->dev.parent);\n\tstruct intel_th_driver *hubdrv = to_intel_th_driver(hub->dev.driver);\n\n\tif (WARN_ON_ONCE(hub->type != INTEL_TH_SWITCH))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(thdev->type != INTEL_TH_OUTPUT))\n\t\treturn -EINVAL;\n\n\tpm_runtime_get_sync(&thdev->dev);\n\thubdrv->enable(hub, &thdev->output);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_th_trace_enable);\n\n \nint intel_th_trace_switch(struct intel_th_device *thdev)\n{\n\tstruct intel_th_device *hub = to_intel_th_device(thdev->dev.parent);\n\tstruct intel_th_driver *hubdrv = to_intel_th_driver(hub->dev.driver);\n\n\tif (WARN_ON_ONCE(hub->type != INTEL_TH_SWITCH))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(thdev->type != INTEL_TH_OUTPUT))\n\t\treturn -EINVAL;\n\n\thubdrv->trig_switch(hub, &thdev->output);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_th_trace_switch);\n\n \nint intel_th_trace_disable(struct intel_th_device *thdev)\n{\n\tstruct intel_th_device *hub = to_intel_th_device(thdev->dev.parent);\n\tstruct intel_th_driver *hubdrv = to_intel_th_driver(hub->dev.driver);\n\n\tWARN_ON_ONCE(hub->type != INTEL_TH_SWITCH);\n\tif (WARN_ON_ONCE(thdev->type != INTEL_TH_OUTPUT))\n\t\treturn -EINVAL;\n\n\thubdrv->disable(hub, &thdev->output);\n\tpm_runtime_put(&thdev->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_th_trace_disable);\n\nint intel_th_set_output(struct intel_th_device *thdev,\n\t\t\tunsigned int master)\n{\n\tstruct intel_th_device *hub = to_intel_th_hub(thdev);\n\tstruct intel_th_driver *hubdrv = to_intel_th_driver(hub->dev.driver);\n\tint ret;\n\n\t \n\tif (hub->host_mode)\n\t\treturn 0;\n\n\t \n\thubdrv = to_intel_th_driver(hub->dev.driver);\n\tif (!hubdrv || !try_module_get(hubdrv->driver.owner))\n\t\treturn -EINVAL;\n\n\tif (!hubdrv->set_output) {\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = hubdrv->set_output(hub, master);\n\nout:\n\tmodule_put(hubdrv->driver.owner);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(intel_th_set_output);\n\nstatic int __init intel_th_init(void)\n{\n\tintel_th_debug_init();\n\n\treturn bus_register(&intel_th_bus);\n}\nsubsys_initcall(intel_th_init);\n\nstatic void __exit intel_th_exit(void)\n{\n\tintel_th_debug_done();\n\n\tbus_unregister(&intel_th_bus);\n}\nmodule_exit(intel_th_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel(R) Trace Hub controller driver\");\nMODULE_AUTHOR(\"Alexander Shishkin <alexander.shishkin@linux.intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}