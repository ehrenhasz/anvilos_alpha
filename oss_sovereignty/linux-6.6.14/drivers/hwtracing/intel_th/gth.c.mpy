{
  "module_name": "gth.c",
  "hash_id": "352b599c482c4feb33dfeebc993ba54f161fdad9612a7b9963f4761a78024e6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/intel_th/gth.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/pm_runtime.h>\n\n#include \"intel_th.h\"\n#include \"gth.h\"\n\nstruct gth_device;\n\n \nstruct gth_output {\n\tstruct gth_device\t*gth;\n\tstruct intel_th_output\t*output;\n\tunsigned int\t\tindex;\n\tunsigned int\t\tport_type;\n\tDECLARE_BITMAP(master, TH_CONFIGURABLE_MASTERS + 1);\n};\n\n \nstruct gth_device {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\n\tstruct attribute_group\toutput_group;\n\tstruct attribute_group\tmaster_group;\n\tstruct gth_output\toutput[TH_POSSIBLE_OUTPUTS];\n\tsigned char\t\tmaster[TH_CONFIGURABLE_MASTERS + 1];\n\tspinlock_t\t\tgth_lock;\n};\n\nstatic void gth_output_set(struct gth_device *gth, int port,\n\t\t\t   unsigned int config)\n{\n\tunsigned long reg = port & 4 ? REG_GTH_GTHOPT1 : REG_GTH_GTHOPT0;\n\tu32 val;\n\tint shift = (port & 3) * 8;\n\n\tval = ioread32(gth->base + reg);\n\tval &= ~(0xff << shift);\n\tval |= config << shift;\n\tiowrite32(val, gth->base + reg);\n}\n\nstatic unsigned int gth_output_get(struct gth_device *gth, int port)\n{\n\tunsigned long reg = port & 4 ? REG_GTH_GTHOPT1 : REG_GTH_GTHOPT0;\n\tu32 val;\n\tint shift = (port & 3) * 8;\n\n\tval = ioread32(gth->base + reg);\n\tval &= 0xff << shift;\n\tval >>= shift;\n\n\treturn val;\n}\n\nstatic void gth_smcfreq_set(struct gth_device *gth, int port,\n\t\t\t    unsigned int freq)\n{\n\tunsigned long reg = REG_GTH_SMCR0 + ((port / 2) * 4);\n\tint shift = (port & 1) * 16;\n\tu32 val;\n\n\tval = ioread32(gth->base + reg);\n\tval &= ~(0xffff << shift);\n\tval |= freq << shift;\n\tiowrite32(val, gth->base + reg);\n}\n\nstatic unsigned int gth_smcfreq_get(struct gth_device *gth, int port)\n{\n\tunsigned long reg = REG_GTH_SMCR0 + ((port / 2) * 4);\n\tint shift = (port & 1) * 16;\n\tu32 val;\n\n\tval = ioread32(gth->base + reg);\n\tval &= 0xffff << shift;\n\tval >>= shift;\n\n\treturn val;\n}\n\n \n\nstruct master_attribute {\n\tstruct device_attribute\tattr;\n\tstruct gth_device\t*gth;\n\tunsigned int\t\tmaster;\n};\n\nstatic void\ngth_master_set(struct gth_device *gth, unsigned int master, int port)\n{\n\tunsigned int reg = REG_GTH_SWDEST0 + ((master >> 1) & ~3u);\n\tunsigned int shift = (master & 0x7) * 4;\n\tu32 val;\n\n\tif (master >= 256) {\n\t\treg = REG_GTH_GSWTDEST;\n\t\tshift = 0;\n\t}\n\n\tval = ioread32(gth->base + reg);\n\tval &= ~(0xf << shift);\n\tif (port >= 0)\n\t\tval |= (0x8 | port) << shift;\n\tiowrite32(val, gth->base + reg);\n}\n\nstatic ssize_t master_attr_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct master_attribute *ma =\n\t\tcontainer_of(attr, struct master_attribute, attr);\n\tstruct gth_device *gth = ma->gth;\n\tsize_t count;\n\tint port;\n\n\tspin_lock(&gth->gth_lock);\n\tport = gth->master[ma->master];\n\tspin_unlock(&gth->gth_lock);\n\n\tif (port >= 0)\n\t\tcount = snprintf(buf, PAGE_SIZE, \"%x\\n\", port);\n\telse\n\t\tcount = snprintf(buf, PAGE_SIZE, \"disabled\\n\");\n\n\treturn count;\n}\n\nstatic ssize_t master_attr_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct master_attribute *ma =\n\t\tcontainer_of(attr, struct master_attribute, attr);\n\tstruct gth_device *gth = ma->gth;\n\tint old_port, port;\n\n\tif (kstrtoint(buf, 10, &port) < 0)\n\t\treturn -EINVAL;\n\n\tif (port >= TH_POSSIBLE_OUTPUTS || port < -1)\n\t\treturn -EINVAL;\n\n\tspin_lock(&gth->gth_lock);\n\n\t \n\told_port = gth->master[ma->master];\n\tif (old_port >= 0) {\n\t\tgth->master[ma->master] = -1;\n\t\tclear_bit(ma->master, gth->output[old_port].master);\n\n\t\t \n\t\tif (gth->output[old_port].output->active)\n\t\t\tgth_master_set(gth, ma->master, -1);\n\t}\n\n\t \n\tif (port >= 0) {\n\t\t \n\t\tif (!gth->output[port].output) {\n\t\t\tcount = -ENODEV;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tset_bit(ma->master, gth->output[port].master);\n\n\t\t \n\t\tif (gth->output[port].output->active)\n\t\t\tgth_master_set(gth, ma->master, port);\n\t}\n\n\tgth->master[ma->master] = port;\n\nunlock:\n\tspin_unlock(&gth->gth_lock);\n\n\treturn count;\n}\n\nstruct output_attribute {\n\tstruct device_attribute attr;\n\tstruct gth_device\t*gth;\n\tunsigned int\t\tport;\n\tunsigned int\t\tparm;\n};\n\n#define OUTPUT_PARM(_name, _mask, _r, _w, _what)\t\t\t\\\n\t[TH_OUTPUT_PARM(_name)] = { .name = __stringify(_name),\t\t\\\n\t\t\t\t    .get = gth_ ## _what ## _get,\t\\\n\t\t\t\t    .set = gth_ ## _what ## _set,\t\\\n\t\t\t\t    .mask = (_mask),\t\t\t\\\n\t\t\t\t    .readable = (_r),\t\t\t\\\n\t\t\t\t    .writable = (_w) }\n\nstatic const struct output_parm {\n\tconst char\t*name;\n\tunsigned int\t(*get)(struct gth_device *gth, int port);\n\tvoid\t\t(*set)(struct gth_device *gth, int port,\n\t\t\t       unsigned int val);\n\tunsigned int\tmask;\n\tunsigned int\treadable : 1,\n\t\t\twritable : 1;\n} output_parms[] = {\n\tOUTPUT_PARM(port,\t0x7,\t1, 0, output),\n\tOUTPUT_PARM(null,\tBIT(3),\t1, 1, output),\n\tOUTPUT_PARM(drop,\tBIT(4),\t1, 1, output),\n\tOUTPUT_PARM(reset,\tBIT(5),\t1, 0, output),\n\tOUTPUT_PARM(flush,\tBIT(7),\t0, 1, output),\n\tOUTPUT_PARM(smcfreq,\t0xffff,\t1, 1, smcfreq),\n};\n\nstatic void\ngth_output_parm_set(struct gth_device *gth, int port, unsigned int parm,\n\t\t    unsigned int val)\n{\n\tunsigned int config = output_parms[parm].get(gth, port);\n\tunsigned int mask = output_parms[parm].mask;\n\tunsigned int shift = __ffs(mask);\n\n\tconfig &= ~mask;\n\tconfig |= (val << shift) & mask;\n\toutput_parms[parm].set(gth, port, config);\n}\n\nstatic unsigned int\ngth_output_parm_get(struct gth_device *gth, int port, unsigned int parm)\n{\n\tunsigned int config = output_parms[parm].get(gth, port);\n\tunsigned int mask = output_parms[parm].mask;\n\tunsigned int shift = __ffs(mask);\n\n\tconfig &= mask;\n\tconfig >>= shift;\n\treturn config;\n}\n\n \nstatic int intel_th_gth_reset(struct gth_device *gth)\n{\n\tu32 reg;\n\tint port, i;\n\n\treg = ioread32(gth->base + REG_GTH_SCRPD0);\n\tif (reg & SCRPD_DEBUGGER_IN_USE)\n\t\treturn -EBUSY;\n\n\t \n\treg |= SCRPD_STH_IS_ENABLED | SCRPD_TRIGGER_IS_ENABLED;\n\tiowrite32(reg, gth->base + REG_GTH_SCRPD0);\n\n\t \n\tfor (port = 0; port < 8; port++) {\n\t\tif (gth_output_parm_get(gth, port, TH_OUTPUT_PARM(port)) ==\n\t\t    GTH_NONE)\n\t\t\tcontinue;\n\n\t\tgth_output_set(gth, port, 0);\n\t\tgth_smcfreq_set(gth, port, 16);\n\t}\n\t \n\tiowrite32(0, gth->base + REG_GTH_DESTOVR);\n\n\t \n\tfor (i = 0; i < 33; i++)\n\t\tiowrite32(0, gth->base + REG_GTH_SWDEST0 + i * 4);\n\n\t \n\tiowrite32(0, gth->base + REG_GTH_SCR);\n\tiowrite32(0xfc, gth->base + REG_GTH_SCR2);\n\n\t \n\tiowrite32(CTS_EVENT_ENABLE_IF_ANYTHING, gth->base + REG_CTS_C0S0_EN);\n\tiowrite32(CTS_ACTION_CONTROL_SET_STATE(CTS_STATE_IDLE) |\n\t\t  CTS_ACTION_CONTROL_TRIGGER, gth->base + REG_CTS_C0S0_ACT);\n\n\treturn 0;\n}\n\n \n\nstatic ssize_t output_attr_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct output_attribute *oa =\n\t\tcontainer_of(attr, struct output_attribute, attr);\n\tstruct gth_device *gth = oa->gth;\n\tsize_t count;\n\n\tpm_runtime_get_sync(dev);\n\n\tspin_lock(&gth->gth_lock);\n\tcount = snprintf(buf, PAGE_SIZE, \"%x\\n\",\n\t\t\t gth_output_parm_get(gth, oa->port, oa->parm));\n\tspin_unlock(&gth->gth_lock);\n\n\tpm_runtime_put(dev);\n\n\treturn count;\n}\n\nstatic ssize_t output_attr_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct output_attribute *oa =\n\t\tcontainer_of(attr, struct output_attribute, attr);\n\tstruct gth_device *gth = oa->gth;\n\tunsigned int config;\n\n\tif (kstrtouint(buf, 16, &config) < 0)\n\t\treturn -EINVAL;\n\n\tpm_runtime_get_sync(dev);\n\n\tspin_lock(&gth->gth_lock);\n\tgth_output_parm_set(gth, oa->port, oa->parm, config);\n\tspin_unlock(&gth->gth_lock);\n\n\tpm_runtime_put(dev);\n\n\treturn count;\n}\n\nstatic int intel_th_master_attributes(struct gth_device *gth)\n{\n\tstruct master_attribute *master_attrs;\n\tstruct attribute **attrs;\n\tint i, nattrs = TH_CONFIGURABLE_MASTERS + 2;\n\n\tattrs = devm_kcalloc(gth->dev, nattrs, sizeof(void *), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tmaster_attrs = devm_kcalloc(gth->dev, nattrs,\n\t\t\t\t    sizeof(struct master_attribute),\n\t\t\t\t    GFP_KERNEL);\n\tif (!master_attrs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < TH_CONFIGURABLE_MASTERS + 1; i++) {\n\t\tchar *name;\n\n\t\tname = devm_kasprintf(gth->dev, GFP_KERNEL, \"%d%s\", i,\n\t\t\t\t      i == TH_CONFIGURABLE_MASTERS ? \"+\" : \"\");\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\tmaster_attrs[i].attr.attr.name = name;\n\t\tmaster_attrs[i].attr.attr.mode = S_IRUGO | S_IWUSR;\n\t\tmaster_attrs[i].attr.show = master_attr_show;\n\t\tmaster_attrs[i].attr.store = master_attr_store;\n\n\t\tsysfs_attr_init(&master_attrs[i].attr.attr);\n\t\tattrs[i] = &master_attrs[i].attr.attr;\n\n\t\tmaster_attrs[i].gth = gth;\n\t\tmaster_attrs[i].master = i;\n\t}\n\n\tgth->master_group.name\t= \"masters\";\n\tgth->master_group.attrs = attrs;\n\n\treturn sysfs_create_group(&gth->dev->kobj, &gth->master_group);\n}\n\nstatic int intel_th_output_attributes(struct gth_device *gth)\n{\n\tstruct output_attribute *out_attrs;\n\tstruct attribute **attrs;\n\tint i, j, nouts = TH_POSSIBLE_OUTPUTS;\n\tint nparms = ARRAY_SIZE(output_parms);\n\tint nattrs = nouts * nparms + 1;\n\n\tattrs = devm_kcalloc(gth->dev, nattrs, sizeof(void *), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tout_attrs = devm_kcalloc(gth->dev, nattrs,\n\t\t\t\t sizeof(struct output_attribute),\n\t\t\t\t GFP_KERNEL);\n\tif (!out_attrs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nouts; i++) {\n\t\tfor (j = 0; j < nparms; j++) {\n\t\t\tunsigned int idx = i * nparms + j;\n\t\t\tchar *name;\n\n\t\t\tname = devm_kasprintf(gth->dev, GFP_KERNEL, \"%d_%s\", i,\n\t\t\t\t\t      output_parms[j].name);\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tout_attrs[idx].attr.attr.name = name;\n\n\t\t\tif (output_parms[j].readable) {\n\t\t\t\tout_attrs[idx].attr.attr.mode |= S_IRUGO;\n\t\t\t\tout_attrs[idx].attr.show = output_attr_show;\n\t\t\t}\n\n\t\t\tif (output_parms[j].writable) {\n\t\t\t\tout_attrs[idx].attr.attr.mode |= S_IWUSR;\n\t\t\t\tout_attrs[idx].attr.store = output_attr_store;\n\t\t\t}\n\n\t\t\tsysfs_attr_init(&out_attrs[idx].attr.attr);\n\t\t\tattrs[idx] = &out_attrs[idx].attr.attr;\n\n\t\t\tout_attrs[idx].gth = gth;\n\t\t\tout_attrs[idx].port = i;\n\t\t\tout_attrs[idx].parm = j;\n\t\t}\n\t}\n\n\tgth->output_group.name\t= \"outputs\";\n\tgth->output_group.attrs = attrs;\n\n\treturn sysfs_create_group(&gth->dev->kobj, &gth->output_group);\n}\n\n \nstatic void intel_th_gth_stop(struct gth_device *gth,\n\t\t\t      struct intel_th_output *output,\n\t\t\t      bool capture_done)\n{\n\tstruct intel_th_device *outdev =\n\t\tcontainer_of(output, struct intel_th_device, output);\n\tstruct intel_th_driver *outdrv =\n\t\tto_intel_th_driver(outdev->dev.driver);\n\tunsigned long count;\n\tu32 reg;\n\tu32 scr2 = 0xfc | (capture_done ? 1 : 0);\n\n\tiowrite32(0, gth->base + REG_GTH_SCR);\n\tiowrite32(scr2, gth->base + REG_GTH_SCR2);\n\n\t \n\tfor (reg = 0, count = GTH_PLE_WAITLOOP_DEPTH;\n\t     count && !(reg & BIT(output->port)); count--) {\n\t\treg = ioread32(gth->base + REG_GTH_STAT);\n\t\tcpu_relax();\n\t}\n\n\tif (!count)\n\t\tdev_dbg(gth->dev, \"timeout waiting for GTH[%d] PLE\\n\",\n\t\t\toutput->port);\n\n\t \n\tif (outdrv->wait_empty)\n\t\toutdrv->wait_empty(outdev);\n\n\t \n\tiowrite32(0xfc, gth->base + REG_GTH_SCR2);\n}\n\n \nstatic void intel_th_gth_start(struct gth_device *gth,\n\t\t\t       struct intel_th_output *output)\n{\n\tu32 scr = 0xfc0000;\n\n\tif (output->multiblock)\n\t\tscr |= 0xff;\n\n\tiowrite32(scr, gth->base + REG_GTH_SCR);\n\tiowrite32(0, gth->base + REG_GTH_SCR2);\n}\n\n \nstatic void intel_th_gth_disable(struct intel_th_device *thdev,\n\t\t\t\t struct intel_th_output *output)\n{\n\tstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\n\tint master;\n\tu32 reg;\n\n\tspin_lock(&gth->gth_lock);\n\toutput->active = false;\n\n\tfor_each_set_bit(master, gth->output[output->port].master,\n\t\t\t TH_CONFIGURABLE_MASTERS + 1) {\n\t\tgth_master_set(gth, master, -1);\n\t}\n\tspin_unlock(&gth->gth_lock);\n\n\tintel_th_gth_stop(gth, output, true);\n\n\treg = ioread32(gth->base + REG_GTH_SCRPD0);\n\treg &= ~output->scratchpad;\n\tiowrite32(reg, gth->base + REG_GTH_SCRPD0);\n}\n\nstatic void gth_tscu_resync(struct gth_device *gth)\n{\n\tu32 reg;\n\n\treg = ioread32(gth->base + REG_TSCU_TSUCTRL);\n\treg &= ~TSUCTRL_CTCRESYNC;\n\tiowrite32(reg, gth->base + REG_TSCU_TSUCTRL);\n}\n\nstatic void intel_th_gth_prepare(struct intel_th_device *thdev,\n\t\t\t\t struct intel_th_output *output)\n{\n\tstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\n\tint count;\n\n\t \n\tfor (count = GTH_PLE_WAITLOOP_DEPTH;\n\t     count && !(gth_output_get(gth, output->port) & BIT(5)); count--)\n\t\tcpu_relax();\n}\n\n \nstatic void intel_th_gth_enable(struct intel_th_device *thdev,\n\t\t\t\tstruct intel_th_output *output)\n{\n\tstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\n\tstruct intel_th *th = to_intel_th(thdev);\n\tint master;\n\tu32 scrpd;\n\n\tspin_lock(&gth->gth_lock);\n\tfor_each_set_bit(master, gth->output[output->port].master,\n\t\t\t TH_CONFIGURABLE_MASTERS + 1) {\n\t\tgth_master_set(gth, master, output->port);\n\t}\n\n\toutput->active = true;\n\tspin_unlock(&gth->gth_lock);\n\n\tif (INTEL_TH_CAP(th, tscu_enable))\n\t\tgth_tscu_resync(gth);\n\n\tscrpd = ioread32(gth->base + REG_GTH_SCRPD0);\n\tscrpd |= output->scratchpad;\n\tiowrite32(scrpd, gth->base + REG_GTH_SCRPD0);\n\n\tintel_th_gth_start(gth, output);\n}\n\n \nstatic void intel_th_gth_switch(struct intel_th_device *thdev,\n\t\t\t\tstruct intel_th_output *output)\n{\n\tstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\n\tunsigned long count;\n\tu32 reg;\n\n\t \n\tiowrite32(0, gth->base + REG_CTS_CTL);\n\tiowrite32(CTS_CTL_SEQUENCER_ENABLE, gth->base + REG_CTS_CTL);\n\t \n\tfor (reg = 0, count = CTS_TRIG_WAITLOOP_DEPTH;\n\t     count && !(reg & BIT(4)); count--) {\n\t\treg = ioread32(gth->base + REG_CTS_STAT);\n\t\tcpu_relax();\n\t}\n\tif (!count)\n\t\tdev_dbg(&thdev->dev, \"timeout waiting for CTS Trigger\\n\");\n\n\t \n\tiowrite32(0, gth->base + REG_CTS_CTL);\n\n\tintel_th_gth_stop(gth, output, false);\n\tintel_th_gth_start(gth, output);\n}\n\n \nstatic int intel_th_gth_assign(struct intel_th_device *thdev,\n\t\t\t       struct intel_th_device *othdev)\n{\n\tstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\n\tint i, id;\n\n\tif (thdev->host_mode)\n\t\treturn -EBUSY;\n\n\tif (othdev->type != INTEL_TH_OUTPUT)\n\t\treturn -EINVAL;\n\n\tfor (i = 0, id = 0; i < TH_POSSIBLE_OUTPUTS; i++) {\n\t\tif (gth->output[i].port_type != othdev->output.type)\n\t\t\tcontinue;\n\n\t\tif (othdev->id == -1 || othdev->id == id)\n\t\t\tgoto found;\n\n\t\tid++;\n\t}\n\n\treturn -ENOENT;\n\nfound:\n\tspin_lock(&gth->gth_lock);\n\tothdev->output.port = i;\n\tothdev->output.active = false;\n\tgth->output[i].output = &othdev->output;\n\tspin_unlock(&gth->gth_lock);\n\n\treturn 0;\n}\n\n \nstatic void intel_th_gth_unassign(struct intel_th_device *thdev,\n\t\t\t\t  struct intel_th_device *othdev)\n{\n\tstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\n\tint port = othdev->output.port;\n\tint master;\n\n\tif (thdev->host_mode)\n\t\treturn;\n\n\tspin_lock(&gth->gth_lock);\n\tothdev->output.port = -1;\n\tothdev->output.active = false;\n\tgth->output[port].output = NULL;\n\tfor (master = 0; master < TH_CONFIGURABLE_MASTERS + 1; master++)\n\t\tif (gth->master[master] == port)\n\t\t\tgth->master[master] = -1;\n\tspin_unlock(&gth->gth_lock);\n}\n\nstatic int\nintel_th_gth_set_output(struct intel_th_device *thdev, unsigned int master)\n{\n\tstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\n\tint port = 0;  \n\n\t \n\tif (master > TH_CONFIGURABLE_MASTERS)\n\t\tmaster = TH_CONFIGURABLE_MASTERS;\n\n\tspin_lock(&gth->gth_lock);\n\tif (gth->master[master] == -1) {\n\t\tset_bit(master, gth->output[port].master);\n\t\tgth->master[master] = port;\n\t}\n\tspin_unlock(&gth->gth_lock);\n\n\treturn 0;\n}\n\nstatic int intel_th_gth_probe(struct intel_th_device *thdev)\n{\n\tstruct device *dev = &thdev->dev;\n\tstruct intel_th *th = dev_get_drvdata(dev->parent);\n\tstruct gth_device *gth;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tint i, ret;\n\n\tres = intel_th_device_get_resource(thdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tbase = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\tgth = devm_kzalloc(dev, sizeof(*gth), GFP_KERNEL);\n\tif (!gth)\n\t\treturn -ENOMEM;\n\n\tgth->dev = dev;\n\tgth->base = base;\n\tspin_lock_init(&gth->gth_lock);\n\n\tdev_set_drvdata(dev, gth);\n\n\t \n\tif (thdev->host_mode)\n\t\treturn 0;\n\n\tret = intel_th_gth_reset(gth);\n\tif (ret) {\n\t\tif (ret != -EBUSY)\n\t\t\treturn ret;\n\n\t\tthdev->host_mode = true;\n\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < TH_CONFIGURABLE_MASTERS + 1; i++)\n\t\tgth->master[i] = -1;\n\n\tfor (i = 0; i < TH_POSSIBLE_OUTPUTS; i++) {\n\t\tgth->output[i].gth = gth;\n\t\tgth->output[i].index = i;\n\t\tgth->output[i].port_type =\n\t\t\tgth_output_parm_get(gth, i, TH_OUTPUT_PARM(port));\n\t\tif (gth->output[i].port_type == GTH_NONE)\n\t\t\tcontinue;\n\n\t\tret = intel_th_output_enable(th, gth->output[i].port_type);\n\t\t \n\t\tif (ret && ret != -ENODEV)\n\t\t\treturn ret;\n\t}\n\n\tif (intel_th_output_attributes(gth) ||\n\t    intel_th_master_attributes(gth)) {\n\t\tpr_warn(\"Can't initialize sysfs attributes\\n\");\n\n\t\tif (gth->output_group.attrs)\n\t\t\tsysfs_remove_group(&gth->dev->kobj, &gth->output_group);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void intel_th_gth_remove(struct intel_th_device *thdev)\n{\n\tstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\n\n\tsysfs_remove_group(&gth->dev->kobj, &gth->output_group);\n\tsysfs_remove_group(&gth->dev->kobj, &gth->master_group);\n}\n\nstatic struct intel_th_driver intel_th_gth_driver = {\n\t.probe\t\t= intel_th_gth_probe,\n\t.remove\t\t= intel_th_gth_remove,\n\t.assign\t\t= intel_th_gth_assign,\n\t.unassign\t= intel_th_gth_unassign,\n\t.set_output\t= intel_th_gth_set_output,\n\t.prepare\t= intel_th_gth_prepare,\n\t.enable\t\t= intel_th_gth_enable,\n\t.trig_switch\t= intel_th_gth_switch,\n\t.disable\t= intel_th_gth_disable,\n\t.driver\t= {\n\t\t.name\t= \"gth\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n};\n\nmodule_driver(intel_th_gth_driver,\n\t      intel_th_driver_register,\n\t      intel_th_driver_unregister);\n\nMODULE_ALIAS(\"intel_th_switch\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel(R) Trace Hub Global Trace Hub driver\");\nMODULE_AUTHOR(\"Alexander Shishkin <alexander.shishkin@linux.intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}