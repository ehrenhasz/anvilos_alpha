{
  "module_name": "coresight-platform.c",
  "hash_id": "d633e0f9b5cbb3a75c8bcc57a1a98510ef18e4ad7d468307dab0a11fbce72034",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-platform.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/types.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/amba/bus.h>\n#include <linux/coresight.h>\n#include <linux/cpumask.h>\n#include <asm/smp_plat.h>\n\n#include \"coresight-priv.h\"\n\n \nstruct coresight_connection *\ncoresight_add_out_conn(struct device *dev,\n\t\t       struct coresight_platform_data *pdata,\n\t\t       const struct coresight_connection *new_conn)\n{\n\tint i;\n\tstruct coresight_connection *conn;\n\n\t \n\tfor (i = 0; i < pdata->nr_outconns; ++i) {\n\t\tconn = pdata->out_conns[i];\n\t\t \n\t\tif (conn->src_port != -1 &&\n\t\t    conn->src_port == new_conn->src_port) {\n\t\t\tdev_warn(dev, \"Duplicate output port %d\\n\",\n\t\t\t\t conn->src_port);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\tpdata->nr_outconns++;\n\tpdata->out_conns =\n\t\tdevm_krealloc_array(dev, pdata->out_conns, pdata->nr_outconns,\n\t\t\t\t    sizeof(*pdata->out_conns), GFP_KERNEL);\n\tif (!pdata->out_conns)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconn = devm_kmalloc(dev, sizeof(struct coresight_connection),\n\t\t\t    GFP_KERNEL);\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\t*conn = *new_conn;\n\tpdata->out_conns[pdata->nr_outconns - 1] = conn;\n\treturn conn;\n}\nEXPORT_SYMBOL_GPL(coresight_add_out_conn);\n\n \nint coresight_add_in_conn(struct coresight_connection *out_conn)\n{\n\tint i;\n\tstruct device *dev = out_conn->dest_dev->dev.parent;\n\tstruct coresight_platform_data *pdata = out_conn->dest_dev->pdata;\n\n\tfor (i = 0; i < pdata->nr_inconns; ++i)\n\t\tif (!pdata->in_conns[i]) {\n\t\t\tpdata->in_conns[i] = out_conn;\n\t\t\treturn 0;\n\t\t}\n\n\tpdata->nr_inconns++;\n\tpdata->in_conns =\n\t\tdevm_krealloc_array(dev, pdata->in_conns, pdata->nr_inconns,\n\t\t\t\t    sizeof(*pdata->in_conns), GFP_KERNEL);\n\tif (!pdata->in_conns)\n\t\treturn -ENOMEM;\n\tpdata->in_conns[pdata->nr_inconns - 1] = out_conn;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(coresight_add_in_conn);\n\nstatic struct device *\ncoresight_find_device_by_fwnode(struct fwnode_handle *fwnode)\n{\n\tstruct device *dev = NULL;\n\n\t \n\tdev = bus_find_device_by_fwnode(&platform_bus_type, fwnode);\n\tif (dev)\n\t\treturn dev;\n\n\t \n\treturn bus_find_device_by_fwnode(&amba_bustype, fwnode);\n}\n\n \nstruct coresight_device *\ncoresight_find_csdev_by_fwnode(struct fwnode_handle *r_fwnode)\n{\n\tstruct device *dev;\n\tstruct coresight_device *csdev = NULL;\n\n\tdev = bus_find_device_by_fwnode(&coresight_bustype, r_fwnode);\n\tif (dev) {\n\t\tcsdev = to_coresight_device(dev);\n\t\tput_device(dev);\n\t}\n\treturn csdev;\n}\nEXPORT_SYMBOL_GPL(coresight_find_csdev_by_fwnode);\n\n#ifdef CONFIG_OF\nstatic inline bool of_coresight_legacy_ep_is_input(struct device_node *ep)\n{\n\treturn of_property_read_bool(ep, \"slave-mode\");\n}\n\nstatic struct device_node *of_coresight_get_port_parent(struct device_node *ep)\n{\n\tstruct device_node *parent = of_graph_get_port_parent(ep);\n\n\t \n\tif (of_node_name_eq(parent, \"in-ports\") ||\n\t    of_node_name_eq(parent, \"out-ports\"))\n\t\tparent = of_get_next_parent(parent);\n\n\treturn parent;\n}\n\nstatic inline struct device_node *\nof_coresight_get_output_ports_node(const struct device_node *node)\n{\n\treturn of_get_child_by_name(node, \"out-ports\");\n}\n\nstatic int of_coresight_get_cpu(struct device *dev)\n{\n\tint cpu;\n\tstruct device_node *dn;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tdn = of_parse_phandle(dev->of_node, \"cpu\", 0);\n\tif (!dn)\n\t\treturn -ENODEV;\n\n\tcpu = of_cpu_node_to_id(dn);\n\tof_node_put(dn);\n\n\treturn cpu;\n}\n\n \nstatic int of_coresight_parse_endpoint(struct device *dev,\n\t\t\t\t       struct device_node *ep,\n\t\t\t\t       struct coresight_platform_data *pdata)\n{\n\tint ret = 0;\n\tstruct of_endpoint endpoint, rendpoint;\n\tstruct device_node *rparent = NULL;\n\tstruct device_node *rep = NULL;\n\tstruct device *rdev = NULL;\n\tstruct fwnode_handle *rdev_fwnode;\n\tstruct coresight_connection conn = {};\n\tstruct coresight_connection *new_conn;\n\n\tdo {\n\t\t \n\t\tif (of_graph_parse_endpoint(ep, &endpoint))\n\t\t\tbreak;\n\t\t \n\t\trep = of_graph_get_remote_endpoint(ep);\n\t\tif (!rep)\n\t\t\tbreak;\n\t\trparent = of_coresight_get_port_parent(rep);\n\t\tif (!rparent)\n\t\t\tbreak;\n\t\tif (of_graph_parse_endpoint(rep, &rendpoint))\n\t\t\tbreak;\n\n\t\trdev_fwnode = of_fwnode_handle(rparent);\n\t\t \n\t\trdev = coresight_find_device_by_fwnode(rdev_fwnode);\n\t\tif (!rdev) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tbreak;\n\t\t}\n\n\t\tconn.src_port = endpoint.port;\n\t\t \n\t\tconn.dest_fwnode = fwnode_handle_get(rdev_fwnode);\n\t\tconn.dest_port = rendpoint.port;\n\n\t\tnew_conn = coresight_add_out_conn(dev, pdata, &conn);\n\t\tif (IS_ERR_VALUE(new_conn)) {\n\t\t\tfwnode_handle_put(conn.dest_fwnode);\n\t\t\treturn PTR_ERR(new_conn);\n\t\t}\n\t\t \n\t} while (0);\n\n\tof_node_put(rparent);\n\tof_node_put(rep);\n\tput_device(rdev);\n\n\treturn ret;\n}\n\nstatic int of_get_coresight_platform_data(struct device *dev,\n\t\t\t\t\t  struct coresight_platform_data *pdata)\n{\n\tint ret = 0;\n\tstruct device_node *ep = NULL;\n\tconst struct device_node *parent = NULL;\n\tbool legacy_binding = false;\n\tstruct device_node *node = dev->of_node;\n\n\tparent = of_coresight_get_output_ports_node(node);\n\t \n\tif (!parent) {\n\t\t \n\t\tif (!of_graph_is_present(node))\n\t\t\treturn 0;\n\t\tlegacy_binding = true;\n\t\tparent = node;\n\t\tdev_warn_once(dev, \"Uses obsolete Coresight DT bindings\\n\");\n\t}\n\n\t \n\twhile ((ep = of_graph_get_next_endpoint(parent, ep))) {\n\t\t \n\t\tif (legacy_binding && of_coresight_legacy_ep_is_input(ep))\n\t\t\tcontinue;\n\n\t\tret = of_coresight_parse_endpoint(dev, ep, pdata);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#else\nstatic inline int\nof_get_coresight_platform_data(struct device *dev,\n\t\t\t       struct coresight_platform_data *pdata)\n{\n\treturn -ENOENT;\n}\n\nstatic inline int of_coresight_get_cpu(struct device *dev)\n{\n\treturn -ENODEV;\n}\n#endif\n\n#ifdef CONFIG_ACPI\n\n#include <acpi/actypes.h>\n#include <acpi/processor.h>\n\n \nstatic const guid_t acpi_graph_uuid = GUID_INIT(0xab02a46b, 0x74c7, 0x45a2,\n\t\t\t\t\t\t0xbd, 0x68, 0xf7, 0xd3,\n\t\t\t\t\t\t0x44, 0xef, 0x21, 0x53);\n \nstatic const guid_t coresight_graph_uuid = GUID_INIT(0x3ecbc8b6, 0x1d0e, 0x4fb3,\n\t\t\t\t\t\t     0x81, 0x07, 0xe6, 0x27,\n\t\t\t\t\t\t     0xf8, 0x05, 0xc6, 0xcd);\n#define ACPI_CORESIGHT_LINK_SLAVE\t0\n#define ACPI_CORESIGHT_LINK_MASTER\t1\n\nstatic inline bool is_acpi_guid(const union acpi_object *obj)\n{\n\treturn (obj->type == ACPI_TYPE_BUFFER) && (obj->buffer.length == 16);\n}\n\n \nstatic inline bool acpi_guid_matches(const union acpi_object *obj,\n\t\t\t\t   const guid_t *guid)\n{\n\treturn is_acpi_guid(obj) &&\n\t       guid_equal((guid_t *)obj->buffer.pointer, guid);\n}\n\nstatic inline bool is_acpi_dsd_graph_guid(const union acpi_object *obj)\n{\n\treturn acpi_guid_matches(obj, &acpi_graph_uuid);\n}\n\nstatic inline bool is_acpi_coresight_graph_guid(const union acpi_object *obj)\n{\n\treturn acpi_guid_matches(obj, &coresight_graph_uuid);\n}\n\nstatic inline bool is_acpi_coresight_graph(const union acpi_object *obj)\n{\n\tconst union acpi_object *graphid, *guid, *links;\n\n\tif (obj->type != ACPI_TYPE_PACKAGE ||\n\t    obj->package.count < 3)\n\t\treturn false;\n\n\tgraphid = &obj->package.elements[0];\n\tguid = &obj->package.elements[1];\n\tlinks = &obj->package.elements[2];\n\n\tif (graphid->type != ACPI_TYPE_INTEGER ||\n\t    links->type != ACPI_TYPE_INTEGER)\n\t\treturn false;\n\n\treturn is_acpi_coresight_graph_guid(guid);\n}\n\n \nstatic inline bool acpi_validate_dsd_graph(const union acpi_object *graph)\n{\n\tint i, n;\n\tconst union acpi_object *rev, *nr_graphs;\n\n\t \n\tif (graph->package.count < 2)\n\t\treturn false;\n\n\trev = &graph->package.elements[0];\n\tnr_graphs = &graph->package.elements[1];\n\n\tif (rev->type != ACPI_TYPE_INTEGER ||\n\t    nr_graphs->type != ACPI_TYPE_INTEGER)\n\t\treturn false;\n\n\t \n\tif (rev->integer.value != 0)\n\t\treturn false;\n\n\tn = nr_graphs->integer.value;\n\t \n\tif (n != 1)\n\t\treturn false;\n\n\t \n\tif (graph->package.count != (n + 2))\n\t\treturn false;\n\n\t \n\tfor (i = 2; i < n + 2; i++) {\n\t\tconst union acpi_object *obj = &graph->package.elements[i];\n\n\t\tif (obj->type != ACPI_TYPE_PACKAGE ||\n\t\t    obj->package.count < 3)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic const union acpi_object *\nacpi_get_dsd_graph(struct acpi_device *adev, struct acpi_buffer *buf)\n{\n\tint i;\n\tacpi_status status;\n\tconst union acpi_object *dsd;\n\n\tstatus = acpi_evaluate_object_typed(adev->handle, \"_DSD\", NULL,\n\t\t\t\t\t    buf, ACPI_TYPE_PACKAGE);\n\tif (ACPI_FAILURE(status))\n\t\treturn NULL;\n\n\tdsd = buf->pointer;\n\n\t \n\tfor (i = 0; i + 1 < dsd->package.count; i += 2) {\n\t\tconst union acpi_object *guid, *package;\n\n\t\tguid = &dsd->package.elements[i];\n\t\tpackage = &dsd->package.elements[i + 1];\n\n\t\t \n\t\tif (!is_acpi_guid(guid) || package->type != ACPI_TYPE_PACKAGE)\n\t\t\tbreak;\n\t\t \n\t\tif (!is_acpi_dsd_graph_guid(guid))\n\t\t\tcontinue;\n\t\tif (acpi_validate_dsd_graph(package))\n\t\t\treturn package;\n\t\t \n\t\tdev_warn(&adev->dev, \"Invalid Graph _DSD property\\n\");\n\t}\n\n\treturn NULL;\n}\n\nstatic inline bool\nacpi_validate_coresight_graph(const union acpi_object *cs_graph)\n{\n\tint nlinks;\n\n\tnlinks = cs_graph->package.elements[2].integer.value;\n\t \n\tif (cs_graph->package.count != (nlinks + 3))\n\t\treturn false;\n\t \n\treturn true;\n}\n\n \nstatic const union acpi_object *\nacpi_get_coresight_graph(struct acpi_device *adev, struct acpi_buffer *buf)\n{\n\tconst union acpi_object *graph_list, *graph;\n\tint i, nr_graphs;\n\n\tgraph_list = acpi_get_dsd_graph(adev, buf);\n\tif (!graph_list)\n\t\treturn graph_list;\n\n\tnr_graphs = graph_list->package.elements[1].integer.value;\n\n\tfor (i = 2; i < nr_graphs + 2; i++) {\n\t\tgraph = &graph_list->package.elements[i];\n\t\tif (!is_acpi_coresight_graph(graph))\n\t\t\tcontinue;\n\t\tif (acpi_validate_coresight_graph(graph))\n\t\t\treturn graph;\n\t\t \n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int acpi_coresight_parse_link(struct acpi_device *adev,\n\t\t\t\t     const union acpi_object *link,\n\t\t\t\t     struct coresight_connection *conn)\n{\n\tint dir;\n\tconst union acpi_object *fields;\n\tstruct acpi_device *r_adev;\n\tstruct device *rdev;\n\n\tif (link->type != ACPI_TYPE_PACKAGE ||\n\t    link->package.count != 4)\n\t\treturn -EINVAL;\n\n\tfields = link->package.elements;\n\n\tif (fields[0].type != ACPI_TYPE_INTEGER ||\n\t    fields[1].type != ACPI_TYPE_INTEGER ||\n\t    fields[2].type != ACPI_TYPE_LOCAL_REFERENCE ||\n\t    fields[3].type != ACPI_TYPE_INTEGER)\n\t\treturn -EINVAL;\n\n\tr_adev = acpi_fetch_acpi_dev(fields[2].reference.handle);\n\tif (!r_adev)\n\t\treturn -ENODEV;\n\n\tdir = fields[3].integer.value;\n\tif (dir == ACPI_CORESIGHT_LINK_MASTER) {\n\t\tconn->src_port = fields[0].integer.value;\n\t\tconn->dest_port = fields[1].integer.value;\n\t\trdev = coresight_find_device_by_fwnode(&r_adev->fwnode);\n\t\tif (!rdev)\n\t\t\treturn -EPROBE_DEFER;\n\t\t \n\t\tconn->dest_fwnode = fwnode_handle_get(&r_adev->fwnode);\n\t} else if (dir == ACPI_CORESIGHT_LINK_SLAVE) {\n\t\t \n\t\tconn->dest_port = fields[0].integer.value;\n\t} else {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn dir;\n}\n\n \nstatic int acpi_coresight_parse_graph(struct device *dev,\n\t\t\t\t      struct acpi_device *adev,\n\t\t\t\t      struct coresight_platform_data *pdata)\n{\n\tint ret = 0;\n\tint i, nlinks;\n\tconst union acpi_object *graph;\n\tstruct coresight_connection conn, zero_conn = {};\n\tstruct coresight_connection *new_conn;\n\tstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tgraph = acpi_get_coresight_graph(adev, &buf);\n\t \n\tif (!graph)\n\t\tgoto free;\n\n\tnlinks = graph->package.elements[2].integer.value;\n\tif (!nlinks)\n\t\tgoto free;\n\n\tfor (i = 0; i < nlinks; i++) {\n\t\tconst union acpi_object *link = &graph->package.elements[3 + i];\n\t\tint dir;\n\n\t\tconn = zero_conn;\n\t\tdir = acpi_coresight_parse_link(adev, link, &conn);\n\t\tif (dir < 0) {\n\t\t\tret = dir;\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (dir == ACPI_CORESIGHT_LINK_MASTER) {\n\t\t\tnew_conn = coresight_add_out_conn(dev, pdata, &conn);\n\t\t\tif (IS_ERR(new_conn)) {\n\t\t\t\tret = PTR_ERR(new_conn);\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t}\n\t}\n\nfree:\n\t \n\tACPI_FREE(buf.pointer);\n\treturn ret;\n}\n\n \nstatic int\nacpi_handle_to_logical_cpuid(acpi_handle handle)\n{\n\tint i;\n\tstruct acpi_processor *pr;\n\n\tfor_each_possible_cpu(i) {\n\t\tpr = per_cpu(processors, i);\n\t\tif (pr && pr->handle == handle)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\n \nstatic int acpi_coresight_get_cpu(struct device *dev)\n{\n\tint cpu;\n\tacpi_handle cpu_handle;\n\tacpi_status status;\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\n\tif (!adev)\n\t\treturn -ENODEV;\n\tstatus = acpi_get_parent(adev->handle, &cpu_handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tcpu = acpi_handle_to_logical_cpuid(cpu_handle);\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -ENODEV;\n\treturn cpu;\n}\n\nstatic int\nacpi_get_coresight_platform_data(struct device *dev,\n\t\t\t\t struct coresight_platform_data *pdata)\n{\n\tstruct acpi_device *adev;\n\n\tadev = ACPI_COMPANION(dev);\n\tif (!adev)\n\t\treturn -EINVAL;\n\n\treturn acpi_coresight_parse_graph(dev, adev, pdata);\n}\n\n#else\n\nstatic inline int\nacpi_get_coresight_platform_data(struct device *dev,\n\t\t\t\t struct coresight_platform_data *pdata)\n{\n\treturn -ENOENT;\n}\n\nstatic inline int acpi_coresight_get_cpu(struct device *dev)\n{\n\treturn -ENODEV;\n}\n#endif\n\nint coresight_get_cpu(struct device *dev)\n{\n\tif (is_of_node(dev->fwnode))\n\t\treturn of_coresight_get_cpu(dev);\n\telse if (is_acpi_device_node(dev->fwnode))\n\t\treturn acpi_coresight_get_cpu(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(coresight_get_cpu);\n\nstruct coresight_platform_data *\ncoresight_get_platform_data(struct device *dev)\n{\n\tint ret = -ENOENT;\n\tstruct coresight_platform_data *pdata = NULL;\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\n\tif (IS_ERR_OR_NULL(fwnode))\n\t\tgoto error;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tif (is_of_node(fwnode))\n\t\tret = of_get_coresight_platform_data(dev, pdata);\n\telse if (is_acpi_device_node(fwnode))\n\t\tret = acpi_get_coresight_platform_data(dev, pdata);\n\n\tif (!ret)\n\t\treturn pdata;\nerror:\n\tif (!IS_ERR_OR_NULL(pdata))\n\t\t \n\t\tcoresight_release_platform_data(NULL, dev, pdata);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(coresight_get_platform_data);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}