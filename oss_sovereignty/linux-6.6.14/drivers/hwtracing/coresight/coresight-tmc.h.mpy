{
  "module_name": "coresight-tmc.h",
  "hash_id": "dc57938f70afc690c430b0d566ba52f2f0b4952df7874ed3fc79fc18ed0376d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-tmc.h",
  "human_readable_source": " \n \n\n#ifndef _CORESIGHT_TMC_H\n#define _CORESIGHT_TMC_H\n\n#include <linux/dma-mapping.h>\n#include <linux/idr.h>\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n\n#define TMC_RSZ\t\t\t0x004\n#define TMC_STS\t\t\t0x00c\n#define TMC_RRD\t\t\t0x010\n#define TMC_RRP\t\t\t0x014\n#define TMC_RWP\t\t\t0x018\n#define TMC_TRG\t\t\t0x01c\n#define TMC_CTL\t\t\t0x020\n#define TMC_RWD\t\t\t0x024\n#define TMC_MODE\t\t0x028\n#define TMC_LBUFLEVEL\t\t0x02c\n#define TMC_CBUFLEVEL\t\t0x030\n#define TMC_BUFWM\t\t0x034\n#define TMC_RRPHI\t\t0x038\n#define TMC_RWPHI\t\t0x03c\n#define TMC_AXICTL\t\t0x110\n#define TMC_DBALO\t\t0x118\n#define TMC_DBAHI\t\t0x11c\n#define TMC_FFSR\t\t0x300\n#define TMC_FFCR\t\t0x304\n#define TMC_PSCR\t\t0x308\n#define TMC_ITMISCOP0\t\t0xee0\n#define TMC_ITTRFLIN\t\t0xee8\n#define TMC_ITATBDATA0\t\t0xeec\n#define TMC_ITATBCTR2\t\t0xef0\n#define TMC_ITATBCTR1\t\t0xef4\n#define TMC_ITATBCTR0\t\t0xef8\n#define TMC_AUTHSTATUS\t\t0xfb8\n\n \n \n#define TMC_CTL_CAPT_EN\t\tBIT(0)\n \n#define TMC_STS_TMCREADY_BIT\t2\n#define TMC_STS_FULL\t\tBIT(0)\n#define TMC_STS_TRIGGERED\tBIT(1)\n#define TMC_STS_MEMERR\t\tBIT(5)\n \n#define TMC_AXICTL_CLEAR_MASK 0xfbf\n#define TMC_AXICTL_ARCACHE_MASK (0xf << 16)\n\n#define TMC_AXICTL_PROT_CTL_B0\tBIT(0)\n#define TMC_AXICTL_PROT_CTL_B1\tBIT(1)\n#define TMC_AXICTL_SCT_GAT_MODE\tBIT(7)\n#define TMC_AXICTL_WR_BURST(v)\t(((v) & 0xf) << 8)\n#define TMC_AXICTL_WR_BURST_16\t0xf\n \n#define TMC_AXICTL_AXCACHE_OS\t(0xf << 2)\n#define TMC_AXICTL_ARCACHE_OS\t(0xf << 16)\n\n \n#define TMC_FFCR_FLUSHMAN_BIT\t6\n#define TMC_FFCR_EN_FMT\t\tBIT(0)\n#define TMC_FFCR_EN_TI\t\tBIT(1)\n#define TMC_FFCR_FON_FLIN\tBIT(4)\n#define TMC_FFCR_FON_TRIG_EVT\tBIT(5)\n#define TMC_FFCR_TRIGON_TRIGIN\tBIT(8)\n#define TMC_FFCR_STOP_ON_FLUSH\tBIT(12)\n\n\n#define TMC_DEVID_NOSCAT\tBIT(24)\n\n#define TMC_DEVID_AXIAW_VALID\tBIT(16)\n#define TMC_DEVID_AXIAW_SHIFT\t17\n#define TMC_DEVID_AXIAW_MASK\t0x7f\n\n#define TMC_AUTH_NSID_MASK\tGENMASK(1, 0)\n\nenum tmc_config_type {\n\tTMC_CONFIG_TYPE_ETB,\n\tTMC_CONFIG_TYPE_ETR,\n\tTMC_CONFIG_TYPE_ETF,\n};\n\nenum tmc_mode {\n\tTMC_MODE_CIRCULAR_BUFFER,\n\tTMC_MODE_SOFTWARE_FIFO,\n\tTMC_MODE_HARDWARE_FIFO,\n};\n\nenum tmc_mem_intf_width {\n\tTMC_MEM_INTF_WIDTH_32BITS\t= 1,\n\tTMC_MEM_INTF_WIDTH_64BITS\t= 2,\n\tTMC_MEM_INTF_WIDTH_128BITS\t= 4,\n\tTMC_MEM_INTF_WIDTH_256BITS\t= 8,\n};\n\n \n#define TMC_ETR_SG\t\t\t(0x1U << 0)\n \n#define TMC_ETR_AXI_ARCACHE\t\t(0x1U << 1)\n \n#define TMC_ETR_SAVE_RESTORE\t\t(0x1U << 2)\n\n \n#define CORESIGHT_SOC_600_ETR_CAPS\t\\\n\t(TMC_ETR_SAVE_RESTORE | TMC_ETR_AXI_ARCACHE)\n\nenum etr_mode {\n\tETR_MODE_FLAT,\t\t \n\tETR_MODE_ETR_SG,\t \n\tETR_MODE_CATU,\t\t \n};\n\nstruct etr_buf_operations;\n\n \nstruct etr_buf {\n\trefcount_t\t\t\trefcount;\n\tenum etr_mode\t\t\tmode;\n\tbool\t\t\t\tfull;\n\tssize_t\t\t\t\tsize;\n\tdma_addr_t\t\t\thwaddr;\n\tunsigned long\t\t\toffset;\n\ts64\t\t\t\tlen;\n\tconst struct etr_buf_operations\t*ops;\n\tvoid\t\t\t\t*private;\n};\n\n \nstruct tmc_drvdata {\n\tvoid __iomem\t\t*base;\n\tstruct coresight_device\t*csdev;\n\tstruct miscdevice\tmiscdev;\n\tspinlock_t\t\tspinlock;\n\tpid_t\t\t\tpid;\n\tbool\t\t\treading;\n\tunion {\n\t\tchar\t\t*buf;\t\t \n\t\tstruct etr_buf\t*etr_buf;\t \n\t};\n\tu32\t\t\tlen;\n\tu32\t\t\tsize;\n\tu32\t\t\tmax_burst_size;\n\tu32\t\t\tmode;\n\tenum tmc_config_type\tconfig_type;\n\tenum tmc_mem_intf_width\tmemwidth;\n\tu32\t\t\ttrigger_cntr;\n\tu32\t\t\tetr_caps;\n\tstruct idr\t\tidr;\n\tstruct mutex\t\tidr_mutex;\n\tstruct etr_buf\t\t*sysfs_buf;\n\tstruct etr_buf\t\t*perf_buf;\n};\n\nstruct etr_buf_operations {\n\tint (*alloc)(struct tmc_drvdata *drvdata, struct etr_buf *etr_buf,\n\t\t     int node, void **pages);\n\tvoid (*sync)(struct etr_buf *etr_buf, u64 rrp, u64 rwp);\n\tssize_t (*get_data)(struct etr_buf *etr_buf, u64 offset, size_t len,\n\t\t\t    char **bufpp);\n\tvoid (*free)(struct etr_buf *etr_buf);\n};\n\n \nstruct tmc_pages {\n\tint nr_pages;\n\tdma_addr_t\t*daddrs;\n\tstruct page\t**pages;\n};\n\n \nstruct tmc_sg_table {\n\tstruct device *dev;\n\tvoid *table_vaddr;\n\tvoid *data_vaddr;\n\tdma_addr_t table_daddr;\n\tint node;\n\tstruct tmc_pages table_pages;\n\tstruct tmc_pages data_pages;\n};\n\n \nint tmc_wait_for_tmcready(struct tmc_drvdata *drvdata);\nvoid tmc_flush_and_stop(struct tmc_drvdata *drvdata);\nvoid tmc_enable_hw(struct tmc_drvdata *drvdata);\nvoid tmc_disable_hw(struct tmc_drvdata *drvdata);\nu32 tmc_get_memwidth_mask(struct tmc_drvdata *drvdata);\n\n \nint tmc_read_prepare_etb(struct tmc_drvdata *drvdata);\nint tmc_read_unprepare_etb(struct tmc_drvdata *drvdata);\nextern const struct coresight_ops tmc_etb_cs_ops;\nextern const struct coresight_ops tmc_etf_cs_ops;\n\nssize_t tmc_etb_get_sysfs_trace(struct tmc_drvdata *drvdata,\n\t\t\t\tloff_t pos, size_t len, char **bufpp);\n \nint tmc_read_prepare_etr(struct tmc_drvdata *drvdata);\nint tmc_read_unprepare_etr(struct tmc_drvdata *drvdata);\nvoid tmc_etr_disable_hw(struct tmc_drvdata *drvdata);\nextern const struct coresight_ops tmc_etr_cs_ops;\nssize_t tmc_etr_get_sysfs_trace(struct tmc_drvdata *drvdata,\n\t\t\t\tloff_t pos, size_t len, char **bufpp);\n\n\n#define TMC_REG_PAIR(name, lo_off, hi_off)\t\t\t\t\\\nstatic inline u64\t\t\t\t\t\t\t\\\ntmc_read_##name(struct tmc_drvdata *drvdata)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn csdev_access_relaxed_read_pair(&drvdata->csdev->access, lo_off, hi_off); \\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void\t\t\t\t\t\t\t\\\ntmc_write_##name(struct tmc_drvdata *drvdata, u64 val)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tcsdev_access_relaxed_write_pair(&drvdata->csdev->access, val, lo_off, hi_off); \\\n}\n\nTMC_REG_PAIR(rrp, TMC_RRP, TMC_RRPHI)\nTMC_REG_PAIR(rwp, TMC_RWP, TMC_RWPHI)\nTMC_REG_PAIR(dba, TMC_DBALO, TMC_DBAHI)\n\n \nstatic inline void tmc_etr_init_caps(struct tmc_drvdata *drvdata, u32 dev_caps)\n{\n\tWARN_ON(drvdata->etr_caps);\n\tdrvdata->etr_caps = dev_caps;\n}\n\nstatic inline void tmc_etr_set_cap(struct tmc_drvdata *drvdata, u32 cap)\n{\n\tdrvdata->etr_caps |= cap;\n}\n\nstatic inline bool tmc_etr_has_cap(struct tmc_drvdata *drvdata, u32 cap)\n{\n\treturn !!(drvdata->etr_caps & cap);\n}\n\nstruct tmc_sg_table *tmc_alloc_sg_table(struct device *dev,\n\t\t\t\t\tint node,\n\t\t\t\t\tint nr_tpages,\n\t\t\t\t\tint nr_dpages,\n\t\t\t\t\tvoid **pages);\nvoid tmc_free_sg_table(struct tmc_sg_table *sg_table);\nvoid tmc_sg_table_sync_table(struct tmc_sg_table *sg_table);\nvoid tmc_sg_table_sync_data_range(struct tmc_sg_table *table,\n\t\t\t\t  u64 offset, u64 size);\nssize_t tmc_sg_table_get_data(struct tmc_sg_table *sg_table,\n\t\t\t      u64 offset, size_t len, char **bufpp);\nstatic inline unsigned long\ntmc_sg_table_buf_size(struct tmc_sg_table *sg_table)\n{\n\treturn (unsigned long)sg_table->data_pages.nr_pages << PAGE_SHIFT;\n}\n\nstruct coresight_device *tmc_etr_get_catu_device(struct tmc_drvdata *drvdata);\n\nvoid tmc_etr_set_catu_ops(const struct etr_buf_operations *catu);\nvoid tmc_etr_remove_catu_ops(void);\nstruct etr_buf *tmc_etr_get_buffer(struct coresight_device *csdev,\n\t\t\t\t   enum cs_mode mode, void *data);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}