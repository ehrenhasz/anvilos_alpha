{
  "module_name": "coresight-etm4x-core.c",
  "hash_id": "19019439363785fc80a114acb909e5f3c28e967fadd64fe1e4d4000c2e0836ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-etm4x-core.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sysfs.h>\n#include <linux/stat.h>\n#include <linux/clk.h>\n#include <linux/cpu.h>\n#include <linux/cpu_pm.h>\n#include <linux/coresight.h>\n#include <linux/coresight-pmu.h>\n#include <linux/pm_wakeup.h>\n#include <linux/amba/bus.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/clk/clk-conf.h>\n\n#include <asm/barrier.h>\n#include <asm/sections.h>\n#include <asm/sysreg.h>\n#include <asm/local.h>\n#include <asm/virt.h>\n\n#include \"coresight-etm4x.h\"\n#include \"coresight-etm-perf.h\"\n#include \"coresight-etm4x-cfg.h\"\n#include \"coresight-self-hosted-trace.h\"\n#include \"coresight-syscfg.h\"\n#include \"coresight-trace-id.h\"\n\nstatic int boot_enable;\nmodule_param(boot_enable, int, 0444);\nMODULE_PARM_DESC(boot_enable, \"Enable tracing on boot\");\n\n#define PARAM_PM_SAVE_FIRMWARE\t  0  \n#define PARAM_PM_SAVE_NEVER\t  1  \n#define PARAM_PM_SAVE_SELF_HOSTED 2  \n\nstatic int pm_save_enable = PARAM_PM_SAVE_FIRMWARE;\nmodule_param(pm_save_enable, int, 0444);\nMODULE_PARM_DESC(pm_save_enable,\n\t\"Save/restore state on power down: 1 = never, 2 = self-hosted\");\n\nstatic struct etmv4_drvdata *etmdrvdata[NR_CPUS];\nstatic void etm4_set_default_config(struct etmv4_config *config);\nstatic int etm4_set_event_filters(struct etmv4_drvdata *drvdata,\n\t\t\t\t  struct perf_event *event);\nstatic u64 etm4_get_access_type(struct etmv4_config *config);\n\nstatic enum cpuhp_state hp_online;\n\nstruct etm4_init_arg {\n\tstruct device\t\t*dev;\n\tstruct csdev_access\t*csa;\n};\n\nstatic DEFINE_PER_CPU(struct etm4_init_arg *, delayed_probe);\nstatic int etm4_probe_cpu(unsigned int cpu);\n\n \nstatic inline bool etm4x_sspcicrn_present(struct etmv4_drvdata *drvdata, int n)\n{\n\treturn (n < drvdata->nr_ss_cmp) &&\n\t       drvdata->nr_pe &&\n\t       (drvdata->config.ss_status[n] & TRCSSCSRn_PC);\n}\n\nu64 etm4x_sysreg_read(u32 offset, bool _relaxed, bool _64bit)\n{\n\tu64 res = 0;\n\n\tswitch (offset) {\n\tETM4x_READ_SYSREG_CASES(res)\n\tdefault :\n\t\tpr_warn_ratelimited(\"etm4x: trying to read unsupported register @%x\\n\",\n\t\t\t offset);\n\t}\n\n\tif (!_relaxed)\n\t\t__io_ar(res);\t \n\n\treturn res;\n}\n\nvoid etm4x_sysreg_write(u64 val, u32 offset, bool _relaxed, bool _64bit)\n{\n\tif (!_relaxed)\n\t\t__io_bw();\t \n\tif (!_64bit)\n\t\tval &= GENMASK(31, 0);\n\n\tswitch (offset) {\n\tETM4x_WRITE_SYSREG_CASES(val)\n\tdefault :\n\t\tpr_warn_ratelimited(\"etm4x: trying to write to unsupported register @%x\\n\",\n\t\t\toffset);\n\t}\n}\n\nstatic u64 ete_sysreg_read(u32 offset, bool _relaxed, bool _64bit)\n{\n\tu64 res = 0;\n\n\tswitch (offset) {\n\tETE_READ_CASES(res)\n\tdefault :\n\t\tpr_warn_ratelimited(\"ete: trying to read unsupported register @%x\\n\",\n\t\t\t\t    offset);\n\t}\n\n\tif (!_relaxed)\n\t\t__io_ar(res);\t \n\n\treturn res;\n}\n\nstatic void ete_sysreg_write(u64 val, u32 offset, bool _relaxed, bool _64bit)\n{\n\tif (!_relaxed)\n\t\t__io_bw();\t \n\tif (!_64bit)\n\t\tval &= GENMASK(31, 0);\n\n\tswitch (offset) {\n\tETE_WRITE_CASES(val)\n\tdefault :\n\t\tpr_warn_ratelimited(\"ete: trying to write to unsupported register @%x\\n\",\n\t\t\t\t    offset);\n\t}\n}\n\nstatic void etm_detect_os_lock(struct etmv4_drvdata *drvdata,\n\t\t\t       struct csdev_access *csa)\n{\n\tu32 oslsr = etm4x_relaxed_read32(csa, TRCOSLSR);\n\n\tdrvdata->os_lock_model = ETM_OSLSR_OSLM(oslsr);\n}\n\nstatic void etm_write_os_lock(struct etmv4_drvdata *drvdata,\n\t\t\t      struct csdev_access *csa, u32 val)\n{\n\tval = !!val;\n\n\tswitch (drvdata->os_lock_model) {\n\tcase ETM_OSLOCK_PRESENT:\n\t\tetm4x_relaxed_write32(csa, val, TRCOSLAR);\n\t\tbreak;\n\tcase ETM_OSLOCK_PE:\n\t\twrite_sysreg_s(val, SYS_OSLAR_EL1);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn_once(\"CPU%d: Unsupported Trace OSLock model: %x\\n\",\n\t\t\t     smp_processor_id(), drvdata->os_lock_model);\n\t\tfallthrough;\n\tcase ETM_OSLOCK_NI:\n\t\treturn;\n\t}\n\tisb();\n}\n\nstatic inline void etm4_os_unlock_csa(struct etmv4_drvdata *drvdata,\n\t\t\t\t      struct csdev_access *csa)\n{\n\tWARN_ON(drvdata->cpu != smp_processor_id());\n\n\t \n\tetm_write_os_lock(drvdata, csa, 0x0);\n\tdrvdata->os_unlock = true;\n}\n\nstatic void etm4_os_unlock(struct etmv4_drvdata *drvdata)\n{\n\tif (!WARN_ON(!drvdata->csdev))\n\t\tetm4_os_unlock_csa(drvdata, &drvdata->csdev->access);\n}\n\nstatic void etm4_os_lock(struct etmv4_drvdata *drvdata)\n{\n\tif (WARN_ON(!drvdata->csdev))\n\t\treturn;\n\t \n\tetm_write_os_lock(drvdata, &drvdata->csdev->access, 0x1);\n\tdrvdata->os_unlock = false;\n}\n\nstatic void etm4_cs_lock(struct etmv4_drvdata *drvdata,\n\t\t\t struct csdev_access *csa)\n{\n\t \n\tif (csa->io_mem)\n\t\tCS_LOCK(csa->base);\n}\n\nstatic void etm4_cs_unlock(struct etmv4_drvdata *drvdata,\n\t\t\t   struct csdev_access *csa)\n{\n\tif (csa->io_mem)\n\t\tCS_UNLOCK(csa->base);\n}\n\nstatic int etm4_cpu_id(struct coresight_device *csdev)\n{\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\treturn drvdata->cpu;\n}\n\nint etm4_read_alloc_trace_id(struct etmv4_drvdata *drvdata)\n{\n\tint trace_id;\n\n\t \n\ttrace_id = coresight_trace_id_get_cpu_id(drvdata->cpu);\n\tif (IS_VALID_CS_TRACE_ID(trace_id))\n\t\tdrvdata->trcid = (u8)trace_id;\n\telse\n\t\tdev_err(&drvdata->csdev->dev,\n\t\t\t\"Failed to allocate trace ID for %s on CPU%d\\n\",\n\t\t\tdev_name(&drvdata->csdev->dev), drvdata->cpu);\n\treturn trace_id;\n}\n\nvoid etm4_release_trace_id(struct etmv4_drvdata *drvdata)\n{\n\tcoresight_trace_id_put_cpu_id(drvdata->cpu);\n}\n\nstruct etm4_enable_arg {\n\tstruct etmv4_drvdata *drvdata;\n\tint rc;\n};\n\n \nstatic void etm4x_prohibit_trace(struct etmv4_drvdata *drvdata)\n{\n\t \n\tif (!drvdata->trfcr)\n\t\treturn;\n\tcpu_prohibit_trace();\n}\n\n \nstatic void etm4x_allow_trace(struct etmv4_drvdata *drvdata)\n{\n\tu64 trfcr = drvdata->trfcr;\n\n\t \n\tif (!trfcr)\n\t\treturn;\n\n\tif (drvdata->config.mode & ETM_MODE_EXCL_KERN)\n\t\ttrfcr &= ~TRFCR_ELx_ExTRE;\n\tif (drvdata->config.mode & ETM_MODE_EXCL_USER)\n\t\ttrfcr &= ~TRFCR_ELx_E0TRE;\n\n\twrite_trfcr(trfcr);\n}\n\n#ifdef CONFIG_ETM4X_IMPDEF_FEATURE\n\n#define HISI_HIP08_AMBA_ID\t\t0x000b6d01\n#define ETM4_AMBA_MASK\t\t\t0xfffff\n#define HISI_HIP08_CORE_COMMIT_MASK\t0x3000\n#define HISI_HIP08_CORE_COMMIT_SHIFT\t12\n#define HISI_HIP08_CORE_COMMIT_FULL\t0b00\n#define HISI_HIP08_CORE_COMMIT_LVL_1\t0b01\n#define HISI_HIP08_CORE_COMMIT_REG\tsys_reg(3, 1, 15, 2, 5)\n\nstruct etm4_arch_features {\n\tvoid (*arch_callback)(bool enable);\n};\n\nstatic bool etm4_hisi_match_pid(unsigned int id)\n{\n\treturn (id & ETM4_AMBA_MASK) == HISI_HIP08_AMBA_ID;\n}\n\nstatic void etm4_hisi_config_core_commit(bool enable)\n{\n\tu8 commit = enable ? HISI_HIP08_CORE_COMMIT_LVL_1 :\n\t\t    HISI_HIP08_CORE_COMMIT_FULL;\n\tu64 val;\n\n\t \n\tval = read_sysreg_s(HISI_HIP08_CORE_COMMIT_REG);\n\tval &= ~HISI_HIP08_CORE_COMMIT_MASK;\n\tval |= commit << HISI_HIP08_CORE_COMMIT_SHIFT;\n\twrite_sysreg_s(val, HISI_HIP08_CORE_COMMIT_REG);\n}\n\nstatic struct etm4_arch_features etm4_features[] = {\n\t[ETM4_IMPDEF_HISI_CORE_COMMIT] = {\n\t\t.arch_callback = etm4_hisi_config_core_commit,\n\t},\n\t{},\n};\n\nstatic void etm4_enable_arch_specific(struct etmv4_drvdata *drvdata)\n{\n\tstruct etm4_arch_features *ftr;\n\tint bit;\n\n\tfor_each_set_bit(bit, drvdata->arch_features, ETM4_IMPDEF_FEATURE_MAX) {\n\t\tftr = &etm4_features[bit];\n\n\t\tif (ftr->arch_callback)\n\t\t\tftr->arch_callback(true);\n\t}\n}\n\nstatic void etm4_disable_arch_specific(struct etmv4_drvdata *drvdata)\n{\n\tstruct etm4_arch_features *ftr;\n\tint bit;\n\n\tfor_each_set_bit(bit, drvdata->arch_features, ETM4_IMPDEF_FEATURE_MAX) {\n\t\tftr = &etm4_features[bit];\n\n\t\tif (ftr->arch_callback)\n\t\t\tftr->arch_callback(false);\n\t}\n}\n\nstatic void etm4_check_arch_features(struct etmv4_drvdata *drvdata,\n\t\t\t\t     struct csdev_access *csa)\n{\n\t \n\tif (!csa->io_mem)\n\t\treturn;\n\n\tif (etm4_hisi_match_pid(coresight_get_pid(csa)))\n\t\tset_bit(ETM4_IMPDEF_HISI_CORE_COMMIT, drvdata->arch_features);\n}\n#else\nstatic void etm4_enable_arch_specific(struct etmv4_drvdata *drvdata)\n{\n}\n\nstatic void etm4_disable_arch_specific(struct etmv4_drvdata *drvdata)\n{\n}\n\nstatic void etm4_check_arch_features(struct etmv4_drvdata *drvdata,\n\t\t\t\t     struct csdev_access *csa)\n{\n}\n#endif  \n\nstatic int etm4_enable_hw(struct etmv4_drvdata *drvdata)\n{\n\tint i, rc;\n\tstruct etmv4_config *config = &drvdata->config;\n\tstruct coresight_device *csdev = drvdata->csdev;\n\tstruct device *etm_dev = &csdev->dev;\n\tstruct csdev_access *csa = &csdev->access;\n\n\n\tetm4_cs_unlock(drvdata, csa);\n\tetm4_enable_arch_specific(drvdata);\n\n\tetm4_os_unlock(drvdata);\n\n\trc = coresight_claim_device_unlocked(csdev);\n\tif (rc)\n\t\tgoto done;\n\n\t \n\tetm4x_relaxed_write32(csa, 0, TRCPRGCTLR);\n\n\t \n\tif (!csa->io_mem)\n\t\tisb();\n\n\t \n\tif (coresight_timeout(csa, TRCSTATR, TRCSTATR_IDLE_BIT, 1))\n\t\tdev_err(etm_dev,\n\t\t\t\"timeout while waiting for Idle Trace Status\\n\");\n\tif (drvdata->nr_pe)\n\t\tetm4x_relaxed_write32(csa, config->pe_sel, TRCPROCSELR);\n\tetm4x_relaxed_write32(csa, config->cfg, TRCCONFIGR);\n\t \n\tetm4x_relaxed_write32(csa, 0x0, TRCAUXCTLR);\n\tetm4x_relaxed_write32(csa, config->eventctrl0, TRCEVENTCTL0R);\n\tetm4x_relaxed_write32(csa, config->eventctrl1, TRCEVENTCTL1R);\n\tif (drvdata->stallctl)\n\t\tetm4x_relaxed_write32(csa, config->stall_ctrl, TRCSTALLCTLR);\n\tetm4x_relaxed_write32(csa, config->ts_ctrl, TRCTSCTLR);\n\tetm4x_relaxed_write32(csa, config->syncfreq, TRCSYNCPR);\n\tetm4x_relaxed_write32(csa, config->ccctlr, TRCCCCTLR);\n\tetm4x_relaxed_write32(csa, config->bb_ctrl, TRCBBCTLR);\n\tetm4x_relaxed_write32(csa, drvdata->trcid, TRCTRACEIDR);\n\tetm4x_relaxed_write32(csa, config->vinst_ctrl, TRCVICTLR);\n\tetm4x_relaxed_write32(csa, config->viiectlr, TRCVIIECTLR);\n\tetm4x_relaxed_write32(csa, config->vissctlr, TRCVISSCTLR);\n\tif (drvdata->nr_pe_cmp)\n\t\tetm4x_relaxed_write32(csa, config->vipcssctlr, TRCVIPCSSCTLR);\n\tfor (i = 0; i < drvdata->nrseqstate - 1; i++)\n\t\tetm4x_relaxed_write32(csa, config->seq_ctrl[i], TRCSEQEVRn(i));\n\tif (drvdata->nrseqstate) {\n\t\tetm4x_relaxed_write32(csa, config->seq_rst, TRCSEQRSTEVR);\n\t\tetm4x_relaxed_write32(csa, config->seq_state, TRCSEQSTR);\n\t}\n\tetm4x_relaxed_write32(csa, config->ext_inp, TRCEXTINSELR);\n\tfor (i = 0; i < drvdata->nr_cntr; i++) {\n\t\tetm4x_relaxed_write32(csa, config->cntrldvr[i], TRCCNTRLDVRn(i));\n\t\tetm4x_relaxed_write32(csa, config->cntr_ctrl[i], TRCCNTCTLRn(i));\n\t\tetm4x_relaxed_write32(csa, config->cntr_val[i], TRCCNTVRn(i));\n\t}\n\n\t \n\tfor (i = 2; i < drvdata->nr_resource * 2; i++)\n\t\tetm4x_relaxed_write32(csa, config->res_ctrl[i], TRCRSCTLRn(i));\n\n\tfor (i = 0; i < drvdata->nr_ss_cmp; i++) {\n\t\t \n\t\tif (config->ss_ctrl[i] || config->ss_pe_cmp[i])\n\t\t\tconfig->ss_status[i] &= ~TRCSSCSRn_STATUS;\n\t\tetm4x_relaxed_write32(csa, config->ss_ctrl[i], TRCSSCCRn(i));\n\t\tetm4x_relaxed_write32(csa, config->ss_status[i], TRCSSCSRn(i));\n\t\tif (etm4x_sspcicrn_present(drvdata, i))\n\t\t\tetm4x_relaxed_write32(csa, config->ss_pe_cmp[i], TRCSSPCICRn(i));\n\t}\n\tfor (i = 0; i < drvdata->nr_addr_cmp * 2; i++) {\n\t\tetm4x_relaxed_write64(csa, config->addr_val[i], TRCACVRn(i));\n\t\tetm4x_relaxed_write64(csa, config->addr_acc[i], TRCACATRn(i));\n\t}\n\tfor (i = 0; i < drvdata->numcidc; i++)\n\t\tetm4x_relaxed_write64(csa, config->ctxid_pid[i], TRCCIDCVRn(i));\n\tetm4x_relaxed_write32(csa, config->ctxid_mask0, TRCCIDCCTLR0);\n\tif (drvdata->numcidc > 4)\n\t\tetm4x_relaxed_write32(csa, config->ctxid_mask1, TRCCIDCCTLR1);\n\n\tfor (i = 0; i < drvdata->numvmidc; i++)\n\t\tetm4x_relaxed_write64(csa, config->vmid_val[i], TRCVMIDCVRn(i));\n\tetm4x_relaxed_write32(csa, config->vmid_mask0, TRCVMIDCCTLR0);\n\tif (drvdata->numvmidc > 4)\n\t\tetm4x_relaxed_write32(csa, config->vmid_mask1, TRCVMIDCCTLR1);\n\n\tif (!drvdata->skip_power_up) {\n\t\tu32 trcpdcr = etm4x_relaxed_read32(csa, TRCPDCR);\n\n\t\t \n\t\tetm4x_relaxed_write32(csa, trcpdcr | TRCPDCR_PU, TRCPDCR);\n\t}\n\n\t \n\tif (etm4x_is_ete(drvdata))\n\t\tetm4x_relaxed_write32(csa, TRCRSR_TA, TRCRSR);\n\n\tetm4x_allow_trace(drvdata);\n\t \n\tetm4x_relaxed_write32(csa, 1, TRCPRGCTLR);\n\n\t \n\tif (!csa->io_mem)\n\t\tisb();\n\n\t \n\tif (coresight_timeout(csa, TRCSTATR, TRCSTATR_IDLE_BIT, 0))\n\t\tdev_err(etm_dev,\n\t\t\t\"timeout while waiting for Idle Trace Status\\n\");\n\n\t \n\tdsb(sy);\n\tisb();\n\ndone:\n\tetm4_cs_lock(drvdata, csa);\n\n\tdev_dbg(etm_dev, \"cpu: %d enable smp call done: %d\\n\",\n\t\tdrvdata->cpu, rc);\n\treturn rc;\n}\n\nstatic void etm4_enable_hw_smp_call(void *info)\n{\n\tstruct etm4_enable_arg *arg = info;\n\n\tif (WARN_ON(!arg))\n\t\treturn;\n\targ->rc = etm4_enable_hw(arg->drvdata);\n}\n\n \nstatic int etm4_config_timestamp_event(struct etmv4_drvdata *drvdata)\n{\n\tint ctridx, ret = -EINVAL;\n\tint counter, rselector;\n\tu32 val = 0;\n\tstruct etmv4_config *config = &drvdata->config;\n\n\t \n\tif (!drvdata->nr_cntr)\n\t\tgoto out;\n\n\t \n\tfor (ctridx = 0; ctridx < drvdata->nr_cntr; ctridx++)\n\t\tif (config->cntr_val[ctridx] == 0)\n\t\t\tbreak;\n\n\t \n\tif (ctridx == drvdata->nr_cntr) {\n\t\tpr_debug(\"%s: no available counter found\\n\", __func__);\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (rselector = 2; rselector < drvdata->nr_resource * 2; rselector++)\n\t\tif (!config->res_ctrl[rselector])\n\t\t\tbreak;\n\n\tif (rselector == drvdata->nr_resource * 2) {\n\t\tpr_debug(\"%s: no available resource selector found\\n\",\n\t\t\t __func__);\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t \n\tcounter = 1 << ctridx;\n\n\t \n\tconfig->cntr_val[ctridx] = 1;\n\tconfig->cntrldvr[ctridx] = 1;\n\n\t \n\tval =  0x1 << 16\t|   \n\t       0x0 << 7\t\t|   \n\t       0x1;\t\t    \n\n\tconfig->cntr_ctrl[ctridx] = val;\n\n\tval = 0x2 << 16\t\t|  \n\t      counter << 0;\t   \n\n\tconfig->res_ctrl[rselector] = val;\n\n\tval = 0x0 << 7\t\t|  \n\t      rselector;\t   \n\n\tconfig->ts_ctrl = val;\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic int etm4_parse_event_config(struct coresight_device *csdev,\n\t\t\t\t   struct perf_event *event)\n{\n\tint ret = 0;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\tstruct perf_event_attr *attr = &event->attr;\n\tunsigned long cfg_hash;\n\tint preset;\n\n\t \n\tmemset(config, 0, sizeof(struct etmv4_config));\n\n\tif (attr->exclude_kernel)\n\t\tconfig->mode = ETM_MODE_EXCL_KERN;\n\n\tif (attr->exclude_user)\n\t\tconfig->mode = ETM_MODE_EXCL_USER;\n\n\t \n\tetm4_set_default_config(config);\n\n\t \n\tret = etm4_set_event_filters(drvdata, event);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (attr->config & BIT(ETM_OPT_CYCACC)) {\n\t\tconfig->cfg |= TRCCONFIGR_CCI;\n\t\t \n\t\tconfig->ccctlr = ETM_CYC_THRESHOLD_DEFAULT;\n\t}\n\tif (attr->config & BIT(ETM_OPT_TS)) {\n\t\t \n\t\tret = etm4_config_timestamp_event(drvdata);\n\n\t\t \n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tconfig->cfg |= TRCCONFIGR_TS;\n\t}\n\n\t \n\tif ((attr->config & BIT(ETM_OPT_CTXTID)) &&\n\t    task_is_in_init_pid_ns(current))\n\t\t \n\t\tconfig->cfg |= TRCCONFIGR_CID;\n\n\t \n\tif (attr->config & BIT(ETM_OPT_CTXTID2)) {\n\t\tif (!is_kernel_in_hyp_mode()) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (task_is_in_init_pid_ns(current))\n\t\t\tconfig->cfg |= TRCCONFIGR_VMID | TRCCONFIGR_VMIDOPT;\n\t}\n\n\t \n\tif ((attr->config & BIT(ETM_OPT_RETSTK)) && drvdata->retstack)\n\t\t \n\t\tconfig->cfg |= TRCCONFIGR_RS;\n\n\t \n\tif (attr->config2 & GENMASK_ULL(63, 32)) {\n\t\tcfg_hash = (u32)(attr->config2 >> 32);\n\t\tpreset = attr->config & 0xF;\n\t\tret = cscfg_csdev_enable_active_config(csdev, cfg_hash, preset);\n\t}\n\n\t \n\tif (attr->config & BIT(ETM_OPT_BRANCH_BROADCAST)) {\n\t\tif (!drvdata->trcbb) {\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tconfig->cfg |= BIT(ETM4_CFG_BIT_BB);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int etm4_enable_perf(struct coresight_device *csdev,\n\t\t\t    struct perf_event *event)\n{\n\tint ret = 0, trace_id;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tif (WARN_ON_ONCE(drvdata->cpu != smp_processor_id())) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tret = etm4_parse_event_config(csdev, event);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\ttrace_id = coresight_trace_id_read_cpu_id(drvdata->cpu);\n\tif (!IS_VALID_CS_TRACE_ID(trace_id)) {\n\t\tdev_err(&drvdata->csdev->dev, \"Failed to set trace ID for %s on CPU%d\\n\",\n\t\t\tdev_name(&drvdata->csdev->dev), drvdata->cpu);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tdrvdata->trcid = (u8)trace_id;\n\n\t \n\tret = etm4_enable_hw(drvdata);\n\nout:\n\treturn ret;\n}\n\nstatic int etm4_enable_sysfs(struct coresight_device *csdev)\n{\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tstruct etm4_enable_arg arg = { };\n\tunsigned long cfg_hash;\n\tint ret, preset;\n\n\t \n\tcscfg_config_sysfs_get_active_cfg(&cfg_hash, &preset);\n\tif (cfg_hash) {\n\t\tret = cscfg_csdev_enable_active_config(csdev, cfg_hash, preset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tspin_lock(&drvdata->spinlock);\n\n\t \n\tret = etm4_read_alloc_trace_id(drvdata);\n\tif (ret < 0)\n\t\tgoto unlock_sysfs_enable;\n\n\t \n\targ.drvdata = drvdata;\n\tret = smp_call_function_single(drvdata->cpu,\n\t\t\t\t       etm4_enable_hw_smp_call, &arg, 1);\n\tif (!ret)\n\t\tret = arg.rc;\n\tif (!ret)\n\t\tdrvdata->sticky_enable = true;\n\n\tif (ret)\n\t\tetm4_release_trace_id(drvdata);\n\nunlock_sysfs_enable:\n\tspin_unlock(&drvdata->spinlock);\n\n\tif (!ret)\n\t\tdev_dbg(&csdev->dev, \"ETM tracing enabled\\n\");\n\treturn ret;\n}\n\nstatic int etm4_enable(struct coresight_device *csdev, struct perf_event *event,\n\t\t       enum cs_mode mode)\n{\n\tint ret;\n\tu32 val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tval = local_cmpxchg(&drvdata->mode, CS_MODE_DISABLED, mode);\n\n\t \n\tif (val)\n\t\treturn -EBUSY;\n\n\tswitch (mode) {\n\tcase CS_MODE_SYSFS:\n\t\tret = etm4_enable_sysfs(csdev);\n\t\tbreak;\n\tcase CS_MODE_PERF:\n\t\tret = etm4_enable_perf(csdev, event);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\t \n\tif (ret)\n\t\tlocal_set(&drvdata->mode, CS_MODE_DISABLED);\n\n\treturn ret;\n}\n\nstatic void etm4_disable_hw(void *info)\n{\n\tu32 control;\n\tstruct etmv4_drvdata *drvdata = info;\n\tstruct etmv4_config *config = &drvdata->config;\n\tstruct coresight_device *csdev = drvdata->csdev;\n\tstruct device *etm_dev = &csdev->dev;\n\tstruct csdev_access *csa = &csdev->access;\n\tint i;\n\n\tetm4_cs_unlock(drvdata, csa);\n\tetm4_disable_arch_specific(drvdata);\n\n\tif (!drvdata->skip_power_up) {\n\t\t \n\t\tcontrol = etm4x_relaxed_read32(csa, TRCPDCR);\n\t\tcontrol &= ~TRCPDCR_PU;\n\t\tetm4x_relaxed_write32(csa, control, TRCPDCR);\n\t}\n\n\tcontrol = etm4x_relaxed_read32(csa, TRCPRGCTLR);\n\n\t \n\tcontrol &= ~0x1;\n\n\t \n\tetm4x_prohibit_trace(drvdata);\n\t \n\tdsb(sy);\n\tisb();\n\t \n\ttsb_csync();\n\tetm4x_relaxed_write32(csa, control, TRCPRGCTLR);\n\n\t \n\tif (coresight_timeout(csa, TRCSTATR, TRCSTATR_PMSTABLE_BIT, 1))\n\t\tdev_err(etm_dev,\n\t\t\t\"timeout while waiting for PM stable Trace Status\\n\");\n\t \n\tfor (i = 0; i < drvdata->nr_ss_cmp; i++) {\n\t\tconfig->ss_status[i] =\n\t\t\tetm4x_relaxed_read32(csa, TRCSSCSRn(i));\n\t}\n\n\t \n\tfor (i = 0; i < drvdata->nr_cntr; i++) {\n\t\tconfig->cntr_val[i] =\n\t\t\tetm4x_relaxed_read32(csa, TRCCNTVRn(i));\n\t}\n\n\tcoresight_disclaim_device_unlocked(csdev);\n\tetm4_cs_lock(drvdata, csa);\n\n\tdev_dbg(&drvdata->csdev->dev,\n\t\t\"cpu: %d disable smp call done\\n\", drvdata->cpu);\n}\n\nstatic int etm4_disable_perf(struct coresight_device *csdev,\n\t\t\t     struct perf_event *event)\n{\n\tu32 control;\n\tstruct etm_filters *filters = event->hw.addr_filters;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tstruct perf_event_attr *attr = &event->attr;\n\n\tif (WARN_ON_ONCE(drvdata->cpu != smp_processor_id()))\n\t\treturn -EINVAL;\n\n\tetm4_disable_hw(drvdata);\n\t \n\tif (attr->config2 & GENMASK_ULL(63, 32))\n\t\tcscfg_csdev_disable_active_config(csdev);\n\n\t \n\tcontrol = etm4x_relaxed_read32(&csdev->access, TRCVICTLR);\n\t \n\tfilters->ssstatus = (control & BIT(9));\n\n\t \n\n\treturn 0;\n}\n\nstatic void etm4_disable_sysfs(struct coresight_device *csdev)\n{\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\t \n\tcpus_read_lock();\n\tspin_lock(&drvdata->spinlock);\n\n\t \n\tsmp_call_function_single(drvdata->cpu, etm4_disable_hw, drvdata, 1);\n\n\tspin_unlock(&drvdata->spinlock);\n\tcpus_read_unlock();\n\n\t \n\n\tdev_dbg(&csdev->dev, \"ETM tracing disabled\\n\");\n}\n\nstatic void etm4_disable(struct coresight_device *csdev,\n\t\t\t struct perf_event *event)\n{\n\tenum cs_mode mode;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\t \n\tmode = local_read(&drvdata->mode);\n\n\tswitch (mode) {\n\tcase CS_MODE_DISABLED:\n\t\tbreak;\n\tcase CS_MODE_SYSFS:\n\t\tetm4_disable_sysfs(csdev);\n\t\tbreak;\n\tcase CS_MODE_PERF:\n\t\tetm4_disable_perf(csdev, event);\n\t\tbreak;\n\t}\n\n\tif (mode)\n\t\tlocal_set(&drvdata->mode, CS_MODE_DISABLED);\n}\n\nstatic const struct coresight_ops_source etm4_source_ops = {\n\t.cpu_id\t\t= etm4_cpu_id,\n\t.enable\t\t= etm4_enable,\n\t.disable\t= etm4_disable,\n};\n\nstatic const struct coresight_ops etm4_cs_ops = {\n\t.source_ops\t= &etm4_source_ops,\n};\n\nstatic inline bool cpu_supports_sysreg_trace(void)\n{\n\tu64 dfr0 = read_sysreg_s(SYS_ID_AA64DFR0_EL1);\n\n\treturn ((dfr0 >> ID_AA64DFR0_EL1_TraceVer_SHIFT) & 0xfUL) > 0;\n}\n\nstatic bool etm4_init_sysreg_access(struct etmv4_drvdata *drvdata,\n\t\t\t\t    struct csdev_access *csa)\n{\n\tu32 devarch;\n\n\tif (!cpu_supports_sysreg_trace())\n\t\treturn false;\n\n\t \n\tdevarch = read_etm4x_sysreg_const_offset(TRCDEVARCH);\n\tswitch (devarch & ETM_DEVARCH_ID_MASK) {\n\tcase ETM_DEVARCH_ETMv4x_ARCH:\n\t\t*csa = (struct csdev_access) {\n\t\t\t.io_mem\t= false,\n\t\t\t.read\t= etm4x_sysreg_read,\n\t\t\t.write\t= etm4x_sysreg_write,\n\t\t};\n\t\tbreak;\n\tcase ETM_DEVARCH_ETE_ARCH:\n\t\t*csa = (struct csdev_access) {\n\t\t\t.io_mem\t= false,\n\t\t\t.read\t= ete_sysreg_read,\n\t\t\t.write\t= ete_sysreg_write,\n\t\t};\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tdrvdata->arch = etm_devarch_to_arch(devarch);\n\treturn true;\n}\n\nstatic bool is_devtype_cpu_trace(void __iomem *base)\n{\n\tu32 devtype = readl(base + TRCDEVTYPE);\n\n\treturn (devtype == CS_DEVTYPE_PE_TRACE);\n}\n\nstatic bool etm4_init_iomem_access(struct etmv4_drvdata *drvdata,\n\t\t\t\t   struct csdev_access *csa)\n{\n\tu32 devarch = readl_relaxed(drvdata->base + TRCDEVARCH);\n\n\tif (!is_coresight_device(drvdata->base) || !is_devtype_cpu_trace(drvdata->base))\n\t\treturn false;\n\n\t \n\tif ((devarch & ETM_DEVARCH_ID_MASK) != ETM_DEVARCH_ETMv4x_ARCH) {\n\t\tpr_warn_once(\"TRCDEVARCH doesn't match ETMv4 architecture\\n\");\n\t\treturn false;\n\t}\n\n\tdrvdata->arch = etm_devarch_to_arch(devarch);\n\t*csa = CSDEV_ACCESS_IOMEM(drvdata->base);\n\treturn true;\n}\n\nstatic bool etm4_init_csdev_access(struct etmv4_drvdata *drvdata,\n\t\t\t\t   struct csdev_access *csa)\n{\n\t \n\tif (drvdata->base)\n\t\treturn etm4_init_iomem_access(drvdata, csa);\n\n\tif (etm4_init_sysreg_access(drvdata, csa))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void cpu_detect_trace_filtering(struct etmv4_drvdata *drvdata)\n{\n\tu64 dfr0 = read_sysreg(id_aa64dfr0_el1);\n\tu64 trfcr;\n\n\tdrvdata->trfcr = 0;\n\tif (!cpuid_feature_extract_unsigned_field(dfr0, ID_AA64DFR0_EL1_TraceFilt_SHIFT))\n\t\treturn;\n\n\t \n\ttrfcr = (TRFCR_ELx_TS_VIRTUAL |\n\t\t TRFCR_ELx_ExTRE |\n\t\t TRFCR_ELx_E0TRE);\n\n\t \n\tif (is_kernel_in_hyp_mode())\n\t\ttrfcr |= TRFCR_EL2_CX;\n\n\tdrvdata->trfcr = trfcr;\n}\n\nstatic void etm4_init_arch_data(void *info)\n{\n\tu32 etmidr0;\n\tu32 etmidr2;\n\tu32 etmidr3;\n\tu32 etmidr4;\n\tu32 etmidr5;\n\tstruct etm4_init_arg *init_arg = info;\n\tstruct etmv4_drvdata *drvdata;\n\tstruct csdev_access *csa;\n\tint i;\n\n\tdrvdata = dev_get_drvdata(init_arg->dev);\n\tcsa = init_arg->csa;\n\n\t \n\tif (!etm4_init_csdev_access(drvdata, csa))\n\t\treturn;\n\n\t \n\tetm_detect_os_lock(drvdata, csa);\n\n\t \n\tetm4_os_unlock_csa(drvdata, csa);\n\tetm4_cs_unlock(drvdata, csa);\n\n\tetm4_check_arch_features(drvdata, csa);\n\n\t \n\tetmidr0 = etm4x_relaxed_read32(csa, TRCIDR0);\n\n\t \n\tdrvdata->instrp0 = !!(FIELD_GET(TRCIDR0_INSTP0_MASK, etmidr0) == 0b11);\n\t \n\tdrvdata->trcbb = !!(etmidr0 & TRCIDR0_TRCBB);\n\t \n\tdrvdata->trccond = !!(etmidr0 & TRCIDR0_TRCCOND);\n\t \n\tdrvdata->trccci = !!(etmidr0 & TRCIDR0_TRCCCI);\n\t \n\tdrvdata->retstack = !!(etmidr0 & TRCIDR0_RETSTACK);\n\t \n\tdrvdata->nr_event = FIELD_GET(TRCIDR0_NUMEVENT_MASK, etmidr0);\n\t \n\tdrvdata->q_support = FIELD_GET(TRCIDR0_QSUPP_MASK, etmidr0);\n\t \n\tdrvdata->ts_size = FIELD_GET(TRCIDR0_TSSIZE_MASK, etmidr0);\n\n\t \n\tetmidr2 = etm4x_relaxed_read32(csa, TRCIDR2);\n\t \n\tdrvdata->ctxid_size = FIELD_GET(TRCIDR2_CIDSIZE_MASK, etmidr2);\n\t \n\tdrvdata->vmid_size = FIELD_GET(TRCIDR2_VMIDSIZE_MASK, etmidr2);\n\t \n\tdrvdata->ccsize = FIELD_GET(TRCIDR2_CCSIZE_MASK, etmidr2);\n\n\tetmidr3 = etm4x_relaxed_read32(csa, TRCIDR3);\n\t \n\tdrvdata->ccitmin = FIELD_GET(TRCIDR3_CCITMIN_MASK, etmidr3);\n\t \n\tdrvdata->s_ex_level = FIELD_GET(TRCIDR3_EXLEVEL_S_MASK, etmidr3);\n\tdrvdata->config.s_ex_level = drvdata->s_ex_level;\n\t \n\tdrvdata->ns_ex_level = FIELD_GET(TRCIDR3_EXLEVEL_NS_MASK, etmidr3);\n\t \n\tdrvdata->trc_error = !!(etmidr3 & TRCIDR3_TRCERR);\n\t \n\tdrvdata->syncpr = !!(etmidr3 & TRCIDR3_SYNCPR);\n\t \n\tdrvdata->stallctl = !!(etmidr3 & TRCIDR3_STALLCTL);\n\t \n\tdrvdata->sysstall = !!(etmidr3 & TRCIDR3_SYSSTALL);\n\t \n\tdrvdata->nr_pe =  (FIELD_GET(TRCIDR3_NUMPROC_HI_MASK, etmidr3) << 3) |\n\t\t\t   FIELD_GET(TRCIDR3_NUMPROC_LO_MASK, etmidr3);\n\t \n\tdrvdata->nooverflow = !!(etmidr3 & TRCIDR3_NOOVERFLOW);\n\n\t \n\tetmidr4 = etm4x_relaxed_read32(csa, TRCIDR4);\n\t \n\tdrvdata->nr_addr_cmp = FIELD_GET(TRCIDR4_NUMACPAIRS_MASK, etmidr4);\n\t \n\tdrvdata->nr_pe_cmp = FIELD_GET(TRCIDR4_NUMPC_MASK, etmidr4);\n\t \n\tdrvdata->nr_resource = FIELD_GET(TRCIDR4_NUMRSPAIR_MASK, etmidr4);\n\tif ((drvdata->arch < ETM_ARCH_V4_3) || (drvdata->nr_resource > 0))\n\t\tdrvdata->nr_resource += 1;\n\t \n\tdrvdata->nr_ss_cmp = FIELD_GET(TRCIDR4_NUMSSCC_MASK, etmidr4);\n\tfor (i = 0; i < drvdata->nr_ss_cmp; i++) {\n\t\tdrvdata->config.ss_status[i] =\n\t\t\tetm4x_relaxed_read32(csa, TRCSSCSRn(i));\n\t}\n\t \n\tdrvdata->numcidc = FIELD_GET(TRCIDR4_NUMCIDC_MASK, etmidr4);\n\t \n\tdrvdata->numvmidc = FIELD_GET(TRCIDR4_NUMVMIDC_MASK, etmidr4);\n\n\tetmidr5 = etm4x_relaxed_read32(csa, TRCIDR5);\n\t \n\tdrvdata->nr_ext_inp = FIELD_GET(TRCIDR5_NUMEXTIN_MASK, etmidr5);\n\t \n\tdrvdata->trcid_size = FIELD_GET(TRCIDR5_TRACEIDSIZE_MASK, etmidr5);\n\t \n\tdrvdata->atbtrig = !!(etmidr5 & TRCIDR5_ATBTRIG);\n\t \n\tdrvdata->lpoverride = (etmidr5 & TRCIDR5_LPOVERRIDE) && (!drvdata->skip_power_up);\n\t \n\tdrvdata->nrseqstate = FIELD_GET(TRCIDR5_NUMSEQSTATE_MASK, etmidr5);\n\t \n\tdrvdata->nr_cntr = FIELD_GET(TRCIDR5_NUMCNTR_MASK, etmidr5);\n\tetm4_cs_lock(drvdata, csa);\n\tcpu_detect_trace_filtering(drvdata);\n}\n\nstatic inline u32 etm4_get_victlr_access_type(struct etmv4_config *config)\n{\n\treturn etm4_get_access_type(config) << __bf_shf(TRCVICTLR_EXLEVEL_MASK);\n}\n\n \nstatic void etm4_set_victlr_access(struct etmv4_config *config)\n{\n\tconfig->vinst_ctrl &= ~TRCVICTLR_EXLEVEL_MASK;\n\tconfig->vinst_ctrl |= etm4_get_victlr_access_type(config);\n}\n\nstatic void etm4_set_default_config(struct etmv4_config *config)\n{\n\t \n\tconfig->eventctrl0 = 0x0;\n\tconfig->eventctrl1 = 0x0;\n\n\t \n\tconfig->stall_ctrl = 0x0;\n\n\t \n\tconfig->syncfreq = 0xC;\n\n\t \n\tconfig->ts_ctrl = 0x0;\n\n\t \n\tconfig->vinst_ctrl = FIELD_PREP(TRCVICTLR_EVENT_MASK, 0x01);\n\n\t \n\tetm4_set_victlr_access(config);\n}\n\nstatic u64 etm4_get_ns_access_type(struct etmv4_config *config)\n{\n\tu64 access_type = 0;\n\n\t \n\tif (!is_kernel_in_hyp_mode()) {\n\t\t \n\t\taccess_type =  ETM_EXLEVEL_NS_HYP;\n\t\tif (config->mode & ETM_MODE_EXCL_KERN)\n\t\t\taccess_type |= ETM_EXLEVEL_NS_OS;\n\t} else if (config->mode & ETM_MODE_EXCL_KERN) {\n\t\taccess_type = ETM_EXLEVEL_NS_HYP;\n\t}\n\n\tif (config->mode & ETM_MODE_EXCL_USER)\n\t\taccess_type |= ETM_EXLEVEL_NS_APP;\n\n\treturn access_type;\n}\n\n \nstatic u64 etm4_get_access_type(struct etmv4_config *config)\n{\n\t \n\treturn etm4_get_ns_access_type(config) | (u64)config->s_ex_level;\n}\n\nstatic u64 etm4_get_comparator_access_type(struct etmv4_config *config)\n{\n\treturn etm4_get_access_type(config) << TRCACATR_EXLEVEL_SHIFT;\n}\n\nstatic void etm4_set_comparator_filter(struct etmv4_config *config,\n\t\t\t\t       u64 start, u64 stop, int comparator)\n{\n\tu64 access_type = etm4_get_comparator_access_type(config);\n\n\t \n\tconfig->addr_val[comparator] = start;\n\tconfig->addr_acc[comparator] = access_type;\n\tconfig->addr_type[comparator] = ETM_ADDR_TYPE_RANGE;\n\n\t \n\tconfig->addr_val[comparator + 1] = stop;\n\tconfig->addr_acc[comparator + 1] = access_type;\n\tconfig->addr_type[comparator + 1] = ETM_ADDR_TYPE_RANGE;\n\n\t \n\tconfig->viiectlr |= BIT(comparator / 2);\n}\n\nstatic void etm4_set_start_stop_filter(struct etmv4_config *config,\n\t\t\t\t       u64 address, int comparator,\n\t\t\t\t       enum etm_addr_type type)\n{\n\tint shift;\n\tu64 access_type = etm4_get_comparator_access_type(config);\n\n\t \n\tconfig->addr_val[comparator] = address;\n\tconfig->addr_acc[comparator] = access_type;\n\tconfig->addr_type[comparator] = type;\n\n\t \n\tshift = (type == ETM_ADDR_TYPE_START ? 0 : 16);\n\tconfig->vissctlr |= BIT(shift + comparator);\n}\n\nstatic void etm4_set_default_filter(struct etmv4_config *config)\n{\n\t \n\tconfig->viiectlr = 0x0;\n\n\t \n\tconfig->vinst_ctrl |= TRCVICTLR_SSSTATUS;\n\tconfig->mode |= ETM_MODE_VIEWINST_STARTSTOP;\n\n\t \n\tconfig->vissctlr = 0x0;\n}\n\nstatic void etm4_set_default(struct etmv4_config *config)\n{\n\tif (WARN_ON_ONCE(!config))\n\t\treturn;\n\n\t \n\tetm4_set_default_config(config);\n\tetm4_set_default_filter(config);\n}\n\nstatic int etm4_get_next_comparator(struct etmv4_drvdata *drvdata, u32 type)\n{\n\tint nr_comparator, index = 0;\n\tstruct etmv4_config *config = &drvdata->config;\n\n\t \n\tnr_comparator = drvdata->nr_addr_cmp * 2;\n\n\t \n\twhile (index < nr_comparator) {\n\t\tswitch (type) {\n\t\tcase ETM_ADDR_TYPE_RANGE:\n\t\t\tif (config->addr_type[index] == ETM_ADDR_TYPE_NONE &&\n\t\t\t    config->addr_type[index + 1] == ETM_ADDR_TYPE_NONE)\n\t\t\t\treturn index;\n\n\t\t\t \n\t\t\tindex += 2;\n\t\t\tbreak;\n\t\tcase ETM_ADDR_TYPE_START:\n\t\tcase ETM_ADDR_TYPE_STOP:\n\t\t\tif (config->addr_type[index] == ETM_ADDR_TYPE_NONE)\n\t\t\t\treturn index;\n\n\t\t\t \n\t\t\tindex += 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\treturn -ENOSPC;\n}\n\nstatic int etm4_set_event_filters(struct etmv4_drvdata *drvdata,\n\t\t\t\t  struct perf_event *event)\n{\n\tint i, comparator, ret = 0;\n\tu64 address;\n\tstruct etmv4_config *config = &drvdata->config;\n\tstruct etm_filters *filters = event->hw.addr_filters;\n\n\tif (!filters)\n\t\tgoto default_filter;\n\n\t \n\tperf_event_addr_filters_sync(event);\n\n\t \n\tif (!filters->nr_filters)\n\t\tgoto default_filter;\n\n\tfor (i = 0; i < filters->nr_filters; i++) {\n\t\tstruct etm_filter *filter = &filters->etm_filter[i];\n\t\tenum etm_addr_type type = filter->type;\n\n\t\t \n\t\tcomparator = etm4_get_next_comparator(drvdata, type);\n\t\tif (comparator < 0) {\n\t\t\tret = comparator;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase ETM_ADDR_TYPE_RANGE:\n\t\t\tetm4_set_comparator_filter(config,\n\t\t\t\t\t\t   filter->start_addr,\n\t\t\t\t\t\t   filter->stop_addr,\n\t\t\t\t\t\t   comparator);\n\t\t\t \n\t\t\tconfig->vinst_ctrl |= TRCVICTLR_SSSTATUS;\n\n\t\t\t \n\t\t\tconfig->vissctlr = 0x0;\n\t\t\tbreak;\n\t\tcase ETM_ADDR_TYPE_START:\n\t\tcase ETM_ADDR_TYPE_STOP:\n\t\t\t \n\t\t\taddress = (type == ETM_ADDR_TYPE_START ?\n\t\t\t\t   filter->start_addr :\n\t\t\t\t   filter->stop_addr);\n\n\t\t\t \n\t\t\tetm4_set_start_stop_filter(config, address,\n\t\t\t\t\t\t   comparator, type);\n\n\t\t\t \n\t\t\tif (filters->ssstatus)\n\t\t\t\tconfig->vinst_ctrl |= TRCVICTLR_SSSTATUS;\n\n\t\t\t \n\t\t\tconfig->viiectlr = 0x0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tgoto out;\n\n\ndefault_filter:\n\tetm4_set_default_filter(config);\n\nout:\n\treturn ret;\n}\n\nvoid etm4_config_trace_mode(struct etmv4_config *config)\n{\n\tu32 mode;\n\n\tmode = config->mode;\n\tmode &= (ETM_MODE_EXCL_KERN | ETM_MODE_EXCL_USER);\n\n\t \n\tWARN_ON_ONCE(mode == (ETM_MODE_EXCL_KERN | ETM_MODE_EXCL_USER));\n\n\t \n\tif (!(mode & ETM_MODE_EXCL_KERN) && !(mode & ETM_MODE_EXCL_USER))\n\t\treturn;\n\n\tetm4_set_victlr_access(config);\n}\n\nstatic int etm4_online_cpu(unsigned int cpu)\n{\n\tif (!etmdrvdata[cpu])\n\t\treturn etm4_probe_cpu(cpu);\n\n\tif (etmdrvdata[cpu]->boot_enable && !etmdrvdata[cpu]->sticky_enable)\n\t\tcoresight_enable(etmdrvdata[cpu]->csdev);\n\treturn 0;\n}\n\nstatic int etm4_starting_cpu(unsigned int cpu)\n{\n\tif (!etmdrvdata[cpu])\n\t\treturn 0;\n\n\tspin_lock(&etmdrvdata[cpu]->spinlock);\n\tif (!etmdrvdata[cpu]->os_unlock)\n\t\tetm4_os_unlock(etmdrvdata[cpu]);\n\n\tif (local_read(&etmdrvdata[cpu]->mode))\n\t\tetm4_enable_hw(etmdrvdata[cpu]);\n\tspin_unlock(&etmdrvdata[cpu]->spinlock);\n\treturn 0;\n}\n\nstatic int etm4_dying_cpu(unsigned int cpu)\n{\n\tif (!etmdrvdata[cpu])\n\t\treturn 0;\n\n\tspin_lock(&etmdrvdata[cpu]->spinlock);\n\tif (local_read(&etmdrvdata[cpu]->mode))\n\t\tetm4_disable_hw(etmdrvdata[cpu]);\n\tspin_unlock(&etmdrvdata[cpu]->spinlock);\n\treturn 0;\n}\n\nstatic int __etm4_cpu_save(struct etmv4_drvdata *drvdata)\n{\n\tint i, ret = 0;\n\tstruct etmv4_save_state *state;\n\tstruct coresight_device *csdev = drvdata->csdev;\n\tstruct csdev_access *csa;\n\tstruct device *etm_dev;\n\n\tif (WARN_ON(!csdev))\n\t\treturn -ENODEV;\n\n\tetm_dev = &csdev->dev;\n\tcsa = &csdev->access;\n\n\t \n\tdsb(sy);\n\tisb();\n\n\tetm4_cs_unlock(drvdata, csa);\n\t \n\tetm4_os_lock(drvdata);\n\n\t \n\tif (coresight_timeout(csa, TRCSTATR, TRCSTATR_PMSTABLE_BIT, 1)) {\n\t\tdev_err(etm_dev,\n\t\t\t\"timeout while waiting for PM Stable Status\\n\");\n\t\tetm4_os_unlock(drvdata);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tstate = drvdata->save_state;\n\n\tstate->trcprgctlr = etm4x_read32(csa, TRCPRGCTLR);\n\tif (drvdata->nr_pe)\n\t\tstate->trcprocselr = etm4x_read32(csa, TRCPROCSELR);\n\tstate->trcconfigr = etm4x_read32(csa, TRCCONFIGR);\n\tstate->trcauxctlr = etm4x_read32(csa, TRCAUXCTLR);\n\tstate->trceventctl0r = etm4x_read32(csa, TRCEVENTCTL0R);\n\tstate->trceventctl1r = etm4x_read32(csa, TRCEVENTCTL1R);\n\tif (drvdata->stallctl)\n\t\tstate->trcstallctlr = etm4x_read32(csa, TRCSTALLCTLR);\n\tstate->trctsctlr = etm4x_read32(csa, TRCTSCTLR);\n\tstate->trcsyncpr = etm4x_read32(csa, TRCSYNCPR);\n\tstate->trcccctlr = etm4x_read32(csa, TRCCCCTLR);\n\tstate->trcbbctlr = etm4x_read32(csa, TRCBBCTLR);\n\tstate->trctraceidr = etm4x_read32(csa, TRCTRACEIDR);\n\tstate->trcqctlr = etm4x_read32(csa, TRCQCTLR);\n\n\tstate->trcvictlr = etm4x_read32(csa, TRCVICTLR);\n\tstate->trcviiectlr = etm4x_read32(csa, TRCVIIECTLR);\n\tstate->trcvissctlr = etm4x_read32(csa, TRCVISSCTLR);\n\tif (drvdata->nr_pe_cmp)\n\t\tstate->trcvipcssctlr = etm4x_read32(csa, TRCVIPCSSCTLR);\n\tstate->trcvdctlr = etm4x_read32(csa, TRCVDCTLR);\n\tstate->trcvdsacctlr = etm4x_read32(csa, TRCVDSACCTLR);\n\tstate->trcvdarcctlr = etm4x_read32(csa, TRCVDARCCTLR);\n\n\tfor (i = 0; i < drvdata->nrseqstate - 1; i++)\n\t\tstate->trcseqevr[i] = etm4x_read32(csa, TRCSEQEVRn(i));\n\n\tif (drvdata->nrseqstate) {\n\t\tstate->trcseqrstevr = etm4x_read32(csa, TRCSEQRSTEVR);\n\t\tstate->trcseqstr = etm4x_read32(csa, TRCSEQSTR);\n\t}\n\tstate->trcextinselr = etm4x_read32(csa, TRCEXTINSELR);\n\n\tfor (i = 0; i < drvdata->nr_cntr; i++) {\n\t\tstate->trccntrldvr[i] = etm4x_read32(csa, TRCCNTRLDVRn(i));\n\t\tstate->trccntctlr[i] = etm4x_read32(csa, TRCCNTCTLRn(i));\n\t\tstate->trccntvr[i] = etm4x_read32(csa, TRCCNTVRn(i));\n\t}\n\n\tfor (i = 0; i < drvdata->nr_resource * 2; i++)\n\t\tstate->trcrsctlr[i] = etm4x_read32(csa, TRCRSCTLRn(i));\n\n\tfor (i = 0; i < drvdata->nr_ss_cmp; i++) {\n\t\tstate->trcssccr[i] = etm4x_read32(csa, TRCSSCCRn(i));\n\t\tstate->trcsscsr[i] = etm4x_read32(csa, TRCSSCSRn(i));\n\t\tif (etm4x_sspcicrn_present(drvdata, i))\n\t\t\tstate->trcsspcicr[i] = etm4x_read32(csa, TRCSSPCICRn(i));\n\t}\n\n\tfor (i = 0; i < drvdata->nr_addr_cmp * 2; i++) {\n\t\tstate->trcacvr[i] = etm4x_read64(csa, TRCACVRn(i));\n\t\tstate->trcacatr[i] = etm4x_read64(csa, TRCACATRn(i));\n\t}\n\n\t \n\n\tfor (i = 0; i < drvdata->numcidc; i++)\n\t\tstate->trccidcvr[i] = etm4x_read64(csa, TRCCIDCVRn(i));\n\n\tfor (i = 0; i < drvdata->numvmidc; i++)\n\t\tstate->trcvmidcvr[i] = etm4x_read64(csa, TRCVMIDCVRn(i));\n\n\tstate->trccidcctlr0 = etm4x_read32(csa, TRCCIDCCTLR0);\n\tif (drvdata->numcidc > 4)\n\t\tstate->trccidcctlr1 = etm4x_read32(csa, TRCCIDCCTLR1);\n\n\tstate->trcvmidcctlr0 = etm4x_read32(csa, TRCVMIDCCTLR0);\n\tif (drvdata->numvmidc > 4)\n\t\tstate->trcvmidcctlr0 = etm4x_read32(csa, TRCVMIDCCTLR1);\n\n\tstate->trcclaimset = etm4x_read32(csa, TRCCLAIMCLR);\n\n\tif (!drvdata->skip_power_up)\n\t\tstate->trcpdcr = etm4x_read32(csa, TRCPDCR);\n\n\t \n\tif (coresight_timeout(csa, TRCSTATR, TRCSTATR_IDLE_BIT, 1)) {\n\t\tdev_err(etm_dev,\n\t\t\t\"timeout while waiting for Idle Trace Status\\n\");\n\t\tetm4_os_unlock(drvdata);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tdrvdata->state_needs_restore = true;\n\n\t \n\tif (!drvdata->skip_power_up)\n\t\tetm4x_relaxed_write32(csa, (state->trcpdcr & ~TRCPDCR_PU),\n\t\t\t\t      TRCPDCR);\nout:\n\tetm4_cs_lock(drvdata, csa);\n\treturn ret;\n}\n\nstatic int etm4_cpu_save(struct etmv4_drvdata *drvdata)\n{\n\tint ret = 0;\n\n\t \n\tif (drvdata->trfcr)\n\t\tdrvdata->save_trfcr = read_trfcr();\n\t \n\tif (local_read(&drvdata->mode) && drvdata->save_state)\n\t\tret = __etm4_cpu_save(drvdata);\n\treturn ret;\n}\n\nstatic void __etm4_cpu_restore(struct etmv4_drvdata *drvdata)\n{\n\tint i;\n\tstruct etmv4_save_state *state = drvdata->save_state;\n\tstruct csdev_access tmp_csa = CSDEV_ACCESS_IOMEM(drvdata->base);\n\tstruct csdev_access *csa = &tmp_csa;\n\n\tetm4_cs_unlock(drvdata, csa);\n\tetm4x_relaxed_write32(csa, state->trcclaimset, TRCCLAIMSET);\n\n\tetm4x_relaxed_write32(csa, state->trcprgctlr, TRCPRGCTLR);\n\tif (drvdata->nr_pe)\n\t\tetm4x_relaxed_write32(csa, state->trcprocselr, TRCPROCSELR);\n\tetm4x_relaxed_write32(csa, state->trcconfigr, TRCCONFIGR);\n\tetm4x_relaxed_write32(csa, state->trcauxctlr, TRCAUXCTLR);\n\tetm4x_relaxed_write32(csa, state->trceventctl0r, TRCEVENTCTL0R);\n\tetm4x_relaxed_write32(csa, state->trceventctl1r, TRCEVENTCTL1R);\n\tif (drvdata->stallctl)\n\t\tetm4x_relaxed_write32(csa, state->trcstallctlr, TRCSTALLCTLR);\n\tetm4x_relaxed_write32(csa, state->trctsctlr, TRCTSCTLR);\n\tetm4x_relaxed_write32(csa, state->trcsyncpr, TRCSYNCPR);\n\tetm4x_relaxed_write32(csa, state->trcccctlr, TRCCCCTLR);\n\tetm4x_relaxed_write32(csa, state->trcbbctlr, TRCBBCTLR);\n\tetm4x_relaxed_write32(csa, state->trctraceidr, TRCTRACEIDR);\n\tetm4x_relaxed_write32(csa, state->trcqctlr, TRCQCTLR);\n\n\tetm4x_relaxed_write32(csa, state->trcvictlr, TRCVICTLR);\n\tetm4x_relaxed_write32(csa, state->trcviiectlr, TRCVIIECTLR);\n\tetm4x_relaxed_write32(csa, state->trcvissctlr, TRCVISSCTLR);\n\tif (drvdata->nr_pe_cmp)\n\t\tetm4x_relaxed_write32(csa, state->trcvipcssctlr, TRCVIPCSSCTLR);\n\tetm4x_relaxed_write32(csa, state->trcvdctlr, TRCVDCTLR);\n\tetm4x_relaxed_write32(csa, state->trcvdsacctlr, TRCVDSACCTLR);\n\tetm4x_relaxed_write32(csa, state->trcvdarcctlr, TRCVDARCCTLR);\n\n\tfor (i = 0; i < drvdata->nrseqstate - 1; i++)\n\t\tetm4x_relaxed_write32(csa, state->trcseqevr[i], TRCSEQEVRn(i));\n\n\tif (drvdata->nrseqstate) {\n\t\tetm4x_relaxed_write32(csa, state->trcseqrstevr, TRCSEQRSTEVR);\n\t\tetm4x_relaxed_write32(csa, state->trcseqstr, TRCSEQSTR);\n\t}\n\tetm4x_relaxed_write32(csa, state->trcextinselr, TRCEXTINSELR);\n\n\tfor (i = 0; i < drvdata->nr_cntr; i++) {\n\t\tetm4x_relaxed_write32(csa, state->trccntrldvr[i], TRCCNTRLDVRn(i));\n\t\tetm4x_relaxed_write32(csa, state->trccntctlr[i], TRCCNTCTLRn(i));\n\t\tetm4x_relaxed_write32(csa, state->trccntvr[i], TRCCNTVRn(i));\n\t}\n\n\tfor (i = 0; i < drvdata->nr_resource * 2; i++)\n\t\tetm4x_relaxed_write32(csa, state->trcrsctlr[i], TRCRSCTLRn(i));\n\n\tfor (i = 0; i < drvdata->nr_ss_cmp; i++) {\n\t\tetm4x_relaxed_write32(csa, state->trcssccr[i], TRCSSCCRn(i));\n\t\tetm4x_relaxed_write32(csa, state->trcsscsr[i], TRCSSCSRn(i));\n\t\tif (etm4x_sspcicrn_present(drvdata, i))\n\t\t\tetm4x_relaxed_write32(csa, state->trcsspcicr[i], TRCSSPCICRn(i));\n\t}\n\n\tfor (i = 0; i < drvdata->nr_addr_cmp * 2; i++) {\n\t\tetm4x_relaxed_write64(csa, state->trcacvr[i], TRCACVRn(i));\n\t\tetm4x_relaxed_write64(csa, state->trcacatr[i], TRCACATRn(i));\n\t}\n\n\tfor (i = 0; i < drvdata->numcidc; i++)\n\t\tetm4x_relaxed_write64(csa, state->trccidcvr[i], TRCCIDCVRn(i));\n\n\tfor (i = 0; i < drvdata->numvmidc; i++)\n\t\tetm4x_relaxed_write64(csa, state->trcvmidcvr[i], TRCVMIDCVRn(i));\n\n\tetm4x_relaxed_write32(csa, state->trccidcctlr0, TRCCIDCCTLR0);\n\tif (drvdata->numcidc > 4)\n\t\tetm4x_relaxed_write32(csa, state->trccidcctlr1, TRCCIDCCTLR1);\n\n\tetm4x_relaxed_write32(csa, state->trcvmidcctlr0, TRCVMIDCCTLR0);\n\tif (drvdata->numvmidc > 4)\n\t\tetm4x_relaxed_write32(csa, state->trcvmidcctlr0, TRCVMIDCCTLR1);\n\n\tetm4x_relaxed_write32(csa, state->trcclaimset, TRCCLAIMSET);\n\n\tif (!drvdata->skip_power_up)\n\t\tetm4x_relaxed_write32(csa, state->trcpdcr, TRCPDCR);\n\n\tdrvdata->state_needs_restore = false;\n\n\t \n\tdsb(sy);\n\tisb();\n\n\t \n\tetm4_os_unlock(drvdata);\n\tetm4_cs_lock(drvdata, csa);\n}\n\nstatic void etm4_cpu_restore(struct etmv4_drvdata *drvdata)\n{\n\tif (drvdata->trfcr)\n\t\twrite_trfcr(drvdata->save_trfcr);\n\tif (drvdata->state_needs_restore)\n\t\t__etm4_cpu_restore(drvdata);\n}\n\nstatic int etm4_cpu_pm_notify(struct notifier_block *nb, unsigned long cmd,\n\t\t\t      void *v)\n{\n\tstruct etmv4_drvdata *drvdata;\n\tunsigned int cpu = smp_processor_id();\n\n\tif (!etmdrvdata[cpu])\n\t\treturn NOTIFY_OK;\n\n\tdrvdata = etmdrvdata[cpu];\n\n\tif (WARN_ON_ONCE(drvdata->cpu != cpu))\n\t\treturn NOTIFY_BAD;\n\n\tswitch (cmd) {\n\tcase CPU_PM_ENTER:\n\t\tif (etm4_cpu_save(drvdata))\n\t\t\treturn NOTIFY_BAD;\n\t\tbreak;\n\tcase CPU_PM_EXIT:\n\tcase CPU_PM_ENTER_FAILED:\n\t\tetm4_cpu_restore(drvdata);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block etm4_cpu_pm_nb = {\n\t.notifier_call = etm4_cpu_pm_notify,\n};\n\n \nstatic int __init etm4_pm_setup(void)\n{\n\tint ret;\n\n\tret = cpu_pm_register_notifier(&etm4_cpu_pm_nb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ARM_CORESIGHT_STARTING,\n\t\t\t\t\t\"arm/coresight4:starting\",\n\t\t\t\t\tetm4_starting_cpu, etm4_dying_cpu);\n\n\tif (ret)\n\t\tgoto unregister_notifier;\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"arm/coresight4:online\",\n\t\t\t\t\tetm4_online_cpu, NULL);\n\n\t \n\tif (ret > 0) {\n\t\thp_online = ret;\n\t\treturn 0;\n\t}\n\n\t \n\tcpuhp_remove_state_nocalls(CPUHP_AP_ARM_CORESIGHT_STARTING);\n\nunregister_notifier:\n\tcpu_pm_unregister_notifier(&etm4_cpu_pm_nb);\n\treturn ret;\n}\n\nstatic void etm4_pm_clear(void)\n{\n\tcpu_pm_unregister_notifier(&etm4_cpu_pm_nb);\n\tcpuhp_remove_state_nocalls(CPUHP_AP_ARM_CORESIGHT_STARTING);\n\tif (hp_online) {\n\t\tcpuhp_remove_state_nocalls(hp_online);\n\t\thp_online = 0;\n\t}\n}\n\nstatic int etm4_add_coresight_dev(struct etm4_init_arg *init_arg)\n{\n\tint ret;\n\tstruct coresight_platform_data *pdata = NULL;\n\tstruct device *dev = init_arg->dev;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev);\n\tstruct coresight_desc desc = { 0 };\n\tu8 major, minor;\n\tchar *type_name;\n\n\tif (!drvdata)\n\t\treturn -EINVAL;\n\n\tdesc.access = *init_arg->csa;\n\n\tif (!drvdata->arch)\n\t\treturn -EINVAL;\n\n\t \n\tif (!desc.access.io_mem ||\n\t    fwnode_property_present(dev_fwnode(dev), \"qcom,skip-power-up\"))\n\t\tdrvdata->skip_power_up = true;\n\n\tmajor = ETM_ARCH_MAJOR_VERSION(drvdata->arch);\n\tminor = ETM_ARCH_MINOR_VERSION(drvdata->arch);\n\n\tif (etm4x_is_ete(drvdata)) {\n\t\ttype_name = \"ete\";\n\t\t \n\t\tmajor -= 4;\n\t} else {\n\t\ttype_name = \"etm\";\n\t}\n\n\tdesc.name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t   \"%s%d\", type_name, drvdata->cpu);\n\tif (!desc.name)\n\t\treturn -ENOMEM;\n\n\tetm4_set_default(&drvdata->config);\n\n\tpdata = coresight_get_platform_data(dev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\n\tdev->platform_data = pdata;\n\n\tdesc.type = CORESIGHT_DEV_TYPE_SOURCE;\n\tdesc.subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_PROC;\n\tdesc.ops = &etm4_cs_ops;\n\tdesc.pdata = pdata;\n\tdesc.dev = dev;\n\tdesc.groups = coresight_etmv4_groups;\n\tdrvdata->csdev = coresight_register(&desc);\n\tif (IS_ERR(drvdata->csdev))\n\t\treturn PTR_ERR(drvdata->csdev);\n\n\tret = etm_perf_symlink(drvdata->csdev, true);\n\tif (ret) {\n\t\tcoresight_unregister(drvdata->csdev);\n\t\treturn ret;\n\t}\n\n\t \n\tret = etm4_cscfg_register(drvdata->csdev);\n\tif (ret) {\n\t\tcoresight_unregister(drvdata->csdev);\n\t\treturn ret;\n\t}\n\n\tetmdrvdata[drvdata->cpu] = drvdata;\n\n\tdev_info(&drvdata->csdev->dev, \"CPU%d: %s v%d.%d initialized\\n\",\n\t\t drvdata->cpu, type_name, major, minor);\n\n\tif (boot_enable) {\n\t\tcoresight_enable(drvdata->csdev);\n\t\tdrvdata->boot_enable = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int etm4_probe(struct device *dev)\n{\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev);\n\tstruct csdev_access access = { 0 };\n\tstruct etm4_init_arg init_arg = { 0 };\n\tstruct etm4_init_arg *delayed;\n\n\tif (WARN_ON(!drvdata))\n\t\treturn -ENOMEM;\n\n\tif (pm_save_enable == PARAM_PM_SAVE_FIRMWARE)\n\t\tpm_save_enable = coresight_loses_context_with_cpu(dev) ?\n\t\t\t       PARAM_PM_SAVE_SELF_HOSTED : PARAM_PM_SAVE_NEVER;\n\n\tif (pm_save_enable != PARAM_PM_SAVE_NEVER) {\n\t\tdrvdata->save_state = devm_kmalloc(dev,\n\t\t\t\tsizeof(struct etmv4_save_state), GFP_KERNEL);\n\t\tif (!drvdata->save_state)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&drvdata->spinlock);\n\n\tdrvdata->cpu = coresight_get_cpu(dev);\n\tif (drvdata->cpu < 0)\n\t\treturn drvdata->cpu;\n\n\tinit_arg.dev = dev;\n\tinit_arg.csa = &access;\n\n\t \n\tcpus_read_lock();\n\tif (smp_call_function_single(drvdata->cpu,\n\t\t\t\tetm4_init_arch_data,  &init_arg, 1)) {\n\t\t \n\t\tdelayed = devm_kmalloc(dev, sizeof(*delayed), GFP_KERNEL);\n\t\tif (!delayed) {\n\t\t\tcpus_read_unlock();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t*delayed = init_arg;\n\n\t\tper_cpu(delayed_probe, drvdata->cpu) = delayed;\n\n\t\tcpus_read_unlock();\n\t\treturn 0;\n\t}\n\tcpus_read_unlock();\n\n\treturn etm4_add_coresight_dev(&init_arg);\n}\n\nstatic int etm4_probe_amba(struct amba_device *adev, const struct amba_id *id)\n{\n\tstruct etmv4_drvdata *drvdata;\n\tvoid __iomem *base;\n\tstruct device *dev = &adev->dev;\n\tstruct resource *res = &adev->res;\n\tint ret;\n\n\t \n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->base = base;\n\tdev_set_drvdata(dev, drvdata);\n\tret = etm4_probe(dev);\n\tif (!ret)\n\t\tpm_runtime_put(&adev->dev);\n\n\treturn ret;\n}\n\nstatic int etm4_probe_platform_dev(struct platform_device *pdev)\n{\n\tstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tstruct etmv4_drvdata *drvdata;\n\tint ret;\n\n\tdrvdata = devm_kzalloc(&pdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->pclk = coresight_get_enable_apb_pclk(&pdev->dev);\n\tif (IS_ERR(drvdata->pclk))\n\t\treturn -ENODEV;\n\n\tif (res) {\n\t\tdrvdata->base = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(drvdata->base)) {\n\t\t\tclk_put(drvdata->pclk);\n\t\t\treturn PTR_ERR(drvdata->base);\n\t\t}\n\t}\n\n\tdev_set_drvdata(&pdev->dev, drvdata);\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = etm4_probe(&pdev->dev);\n\n\tpm_runtime_put(&pdev->dev);\n\treturn ret;\n}\n\nstatic int etm4_probe_cpu(unsigned int cpu)\n{\n\tint ret;\n\tstruct etm4_init_arg init_arg;\n\tstruct csdev_access access = { 0 };\n\tstruct etm4_init_arg *iap = *this_cpu_ptr(&delayed_probe);\n\n\tif (!iap)\n\t\treturn 0;\n\n\tinit_arg = *iap;\n\tdevm_kfree(init_arg.dev, iap);\n\t*this_cpu_ptr(&delayed_probe) = NULL;\n\n\tret = pm_runtime_resume_and_get(init_arg.dev);\n\tif (ret < 0) {\n\t\tdev_err(init_arg.dev, \"Failed to get PM runtime!\\n\");\n\t\treturn 0;\n\t}\n\n\tinit_arg.csa = &access;\n\tetm4_init_arch_data(&init_arg);\n\n\tetm4_add_coresight_dev(&init_arg);\n\n\tpm_runtime_put(init_arg.dev);\n\treturn 0;\n}\n\nstatic struct amba_cs_uci_id uci_id_etm4[] = {\n\t{\n\t\t \n\t\t.devarch\t= ETM_DEVARCH_ETMv4x_ARCH,\n\t\t.devarch_mask\t= ETM_DEVARCH_ID_MASK,\n\t\t.devtype\t= CS_DEVTYPE_PE_TRACE,\n\t}\n};\n\nstatic void clear_etmdrvdata(void *info)\n{\n\tint cpu = *(int *)info;\n\n\tetmdrvdata[cpu] = NULL;\n\tper_cpu(delayed_probe, cpu) = NULL;\n}\n\nstatic void etm4_remove_dev(struct etmv4_drvdata *drvdata)\n{\n\tbool had_delayed_probe;\n\t \n\tcpus_read_lock();\n\n\thad_delayed_probe = per_cpu(delayed_probe, drvdata->cpu);\n\n\t \n\tif (smp_call_function_single(drvdata->cpu, clear_etmdrvdata, &drvdata->cpu, 1))\n\t\tclear_etmdrvdata(&drvdata->cpu);\n\n\tcpus_read_unlock();\n\n\tif (!had_delayed_probe) {\n\t\tetm_perf_symlink(drvdata->csdev, false);\n\t\tcscfg_unregister_csdev(drvdata->csdev);\n\t\tcoresight_unregister(drvdata->csdev);\n\t}\n}\n\nstatic void etm4_remove_amba(struct amba_device *adev)\n{\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(&adev->dev);\n\n\tif (drvdata)\n\t\tetm4_remove_dev(drvdata);\n}\n\nstatic int etm4_remove_platform_dev(struct platform_device *pdev)\n{\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(&pdev->dev);\n\n\tif (drvdata)\n\t\tetm4_remove_dev(drvdata);\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (drvdata && !IS_ERR_OR_NULL(drvdata->pclk))\n\t\tclk_put(drvdata->pclk);\n\n\treturn 0;\n}\n\nstatic const struct amba_id etm4_ids[] = {\n\tCS_AMBA_ID(0x000bb95d),\t\t\t \n\tCS_AMBA_ID(0x000bb95e),\t\t\t \n\tCS_AMBA_ID(0x000bb95a),\t\t\t \n\tCS_AMBA_ID(0x000bb959),\t\t\t \n\tCS_AMBA_UCI_ID(0x000bb9da, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000bbd05, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000bbd0a, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000bbd0c, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000bbd41, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000f0205, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000f0211, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000bb802, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000bb803, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000bb805, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000bb804, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000bbd0d, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000cc0af, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000b6d01, uci_id_etm4), \n\tCS_AMBA_UCI_ID(0x000b6d02, uci_id_etm4), \n\t \n\tCS_AMBA_MATCH_ALL_UCI(uci_id_etm4),\n\t{},\n};\n\nMODULE_DEVICE_TABLE(amba, etm4_ids);\n\nstatic struct amba_driver etm4x_amba_driver = {\n\t.drv = {\n\t\t.name   = \"coresight-etm4x\",\n\t\t.owner  = THIS_MODULE,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= etm4_probe_amba,\n\t.remove         = etm4_remove_amba,\n\t.id_table\t= etm4_ids,\n};\n\n#ifdef CONFIG_PM\nstatic int etm4_runtime_suspend(struct device *dev)\n{\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tif (drvdata->pclk && !IS_ERR(drvdata->pclk))\n\t\tclk_disable_unprepare(drvdata->pclk);\n\n\treturn 0;\n}\n\nstatic int etm4_runtime_resume(struct device *dev)\n{\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tif (drvdata->pclk && !IS_ERR(drvdata->pclk))\n\t\tclk_prepare_enable(drvdata->pclk);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops etm4_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(etm4_runtime_suspend, etm4_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id etm4_sysreg_match[] = {\n\t{ .compatible\t= \"arm,coresight-etm4x-sysreg\" },\n\t{ .compatible\t= \"arm,embedded-trace-extension\" },\n\t{}\n};\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id etm4x_acpi_ids[] = {\n\t{\"ARMHC500\", 0},  \n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, etm4x_acpi_ids);\n#endif\n\nstatic struct platform_driver etm4_platform_driver = {\n\t.probe\t\t= etm4_probe_platform_dev,\n\t.remove\t\t= etm4_remove_platform_dev,\n\t.driver\t\t\t= {\n\t\t.name\t\t\t= \"coresight-etm4x\",\n\t\t.of_match_table\t\t= etm4_sysreg_match,\n\t\t.acpi_match_table\t= ACPI_PTR(etm4x_acpi_ids),\n\t\t.suppress_bind_attrs\t= true,\n\t\t.pm\t\t\t= &etm4_dev_pm_ops,\n\t},\n};\n\nstatic int __init etm4x_init(void)\n{\n\tint ret;\n\n\tret = etm4_pm_setup();\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\tret = amba_driver_register(&etm4x_amba_driver);\n\tif (ret) {\n\t\tpr_err(\"Error registering etm4x AMBA driver\\n\");\n\t\tgoto clear_pm;\n\t}\n\n\tret = platform_driver_register(&etm4_platform_driver);\n\tif (!ret)\n\t\treturn 0;\n\n\tpr_err(\"Error registering etm4x platform driver\\n\");\n\tamba_driver_unregister(&etm4x_amba_driver);\n\nclear_pm:\n\tetm4_pm_clear();\n\treturn ret;\n}\n\nstatic void __exit etm4x_exit(void)\n{\n\tamba_driver_unregister(&etm4x_amba_driver);\n\tplatform_driver_unregister(&etm4_platform_driver);\n\tetm4_pm_clear();\n}\n\nmodule_init(etm4x_init);\nmodule_exit(etm4x_exit);\n\nMODULE_AUTHOR(\"Pratik Patel <pratikp@codeaurora.org>\");\nMODULE_AUTHOR(\"Mathieu Poirier <mathieu.poirier@linaro.org>\");\nMODULE_DESCRIPTION(\"Arm CoreSight Program Flow Trace v4.x driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}