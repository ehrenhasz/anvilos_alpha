{
  "module_name": "coresight-tpdm.c",
  "hash_id": "b55a43c568901ac0bf00a09ac87418649a852f13be041b35b8391bf9802f562a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-tpdm.c",
  "human_readable_source": "\n \n\n#include <linux/amba/bus.h>\n#include <linux/bitmap.h>\n#include <linux/coresight.h>\n#include <linux/coresight-pmu.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#include \"coresight-priv.h\"\n#include \"coresight-tpdm.h\"\n\nDEFINE_CORESIGHT_DEVLIST(tpdm_devs, \"tpdm\");\n\nstatic void tpdm_enable_dsb(struct tpdm_drvdata *drvdata)\n{\n\tu32 val;\n\n\t \n\tval = readl_relaxed(drvdata->base + TPDM_DSB_CR);\n\tval |= TPDM_DSB_CR_ENA;\n\twritel_relaxed(val, drvdata->base + TPDM_DSB_CR);\n}\n\n \nstatic void __tpdm_enable(struct tpdm_drvdata *drvdata)\n{\n\tCS_UNLOCK(drvdata->base);\n\n\t \n\tif (drvdata->datasets & TPDM_PIDR0_DS_DSB)\n\t\ttpdm_enable_dsb(drvdata);\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic int tpdm_enable(struct coresight_device *csdev, struct perf_event *event,\n\t\t       enum cs_mode mode)\n{\n\tstruct tpdm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tspin_lock(&drvdata->spinlock);\n\tif (drvdata->enable) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EBUSY;\n\t}\n\n\t__tpdm_enable(drvdata);\n\tdrvdata->enable = true;\n\tspin_unlock(&drvdata->spinlock);\n\n\tdev_dbg(drvdata->dev, \"TPDM tracing enabled\\n\");\n\treturn 0;\n}\n\nstatic void tpdm_disable_dsb(struct tpdm_drvdata *drvdata)\n{\n\tu32 val;\n\n\t \n\tval = readl_relaxed(drvdata->base + TPDM_DSB_CR);\n\tval &= ~TPDM_DSB_CR_ENA;\n\twritel_relaxed(val, drvdata->base + TPDM_DSB_CR);\n}\n\n \nstatic void __tpdm_disable(struct tpdm_drvdata *drvdata)\n{\n\tCS_UNLOCK(drvdata->base);\n\n\t \n\tif (drvdata->datasets & TPDM_PIDR0_DS_DSB)\n\t\ttpdm_disable_dsb(drvdata);\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic void tpdm_disable(struct coresight_device *csdev,\n\t\t\t struct perf_event *event)\n{\n\tstruct tpdm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tspin_lock(&drvdata->spinlock);\n\tif (!drvdata->enable) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn;\n\t}\n\n\t__tpdm_disable(drvdata);\n\tdrvdata->enable = false;\n\tspin_unlock(&drvdata->spinlock);\n\n\tdev_dbg(drvdata->dev, \"TPDM tracing disabled\\n\");\n}\n\nstatic const struct coresight_ops_source tpdm_source_ops = {\n\t.enable\t\t= tpdm_enable,\n\t.disable\t= tpdm_disable,\n};\n\nstatic const struct coresight_ops tpdm_cs_ops = {\n\t.source_ops\t= &tpdm_source_ops,\n};\n\nstatic void tpdm_init_default_data(struct tpdm_drvdata *drvdata)\n{\n\tu32 pidr;\n\n\tCS_UNLOCK(drvdata->base);\n\t \n\tpidr = readl_relaxed(drvdata->base + CORESIGHT_PERIPHIDR0);\n\tdrvdata->datasets |= pidr & GENMASK(TPDM_DATASETS - 1, 0);\n\tCS_LOCK(drvdata->base);\n}\n\n \nstatic ssize_t integration_test_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf,\n\t\t\t\t\t  size_t size)\n{\n\tint i, ret = 0;\n\tunsigned long val;\n\tstruct tpdm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 1 && val != 2)\n\t\treturn -EINVAL;\n\n\tif (!drvdata->enable)\n\t\treturn -EINVAL;\n\n\tif (val == 1)\n\t\tval = ATBCNTRL_VAL_64;\n\telse\n\t\tval = ATBCNTRL_VAL_32;\n\tCS_UNLOCK(drvdata->base);\n\twritel_relaxed(0x1, drvdata->base + TPDM_ITCNTRL);\n\n\tfor (i = 0; i < INTEGRATION_TEST_CYCLE; i++)\n\t\twritel_relaxed(val, drvdata->base + TPDM_ITATBCNTRL);\n\n\twritel_relaxed(0, drvdata->base + TPDM_ITCNTRL);\n\tCS_LOCK(drvdata->base);\n\treturn size;\n}\nstatic DEVICE_ATTR_WO(integration_test);\n\nstatic struct attribute *tpdm_attrs[] = {\n\t&dev_attr_integration_test.attr,\n\tNULL,\n};\n\nstatic struct attribute_group tpdm_attr_grp = {\n\t.attrs = tpdm_attrs,\n};\n\nstatic const struct attribute_group *tpdm_attr_grps[] = {\n\t&tpdm_attr_grp,\n\tNULL,\n};\n\nstatic int tpdm_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tvoid __iomem *base;\n\tstruct device *dev = &adev->dev;\n\tstruct coresight_platform_data *pdata;\n\tstruct tpdm_drvdata *drvdata;\n\tstruct coresight_desc desc = { 0 };\n\n\tpdata = coresight_get_platform_data(dev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\tadev->dev.platform_data = pdata;\n\n\t \n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\tdrvdata->dev = &adev->dev;\n\tdev_set_drvdata(dev, drvdata);\n\n\tbase = devm_ioremap_resource(dev, &adev->res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdrvdata->base = base;\n\n\t \n\tdesc.name = coresight_alloc_device_name(&tpdm_devs, dev);\n\tif (!desc.name)\n\t\treturn -ENOMEM;\n\tdesc.type = CORESIGHT_DEV_TYPE_SOURCE;\n\tdesc.subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_OTHERS;\n\tdesc.ops = &tpdm_cs_ops;\n\tdesc.pdata = adev->dev.platform_data;\n\tdesc.dev = &adev->dev;\n\tdesc.access = CSDEV_ACCESS_IOMEM(base);\n\tdesc.groups = tpdm_attr_grps;\n\tdrvdata->csdev = coresight_register(&desc);\n\tif (IS_ERR(drvdata->csdev))\n\t\treturn PTR_ERR(drvdata->csdev);\n\n\tspin_lock_init(&drvdata->spinlock);\n\ttpdm_init_default_data(drvdata);\n\t \n\tpm_runtime_put(&adev->dev);\n\n\treturn 0;\n}\n\nstatic void tpdm_remove(struct amba_device *adev)\n{\n\tstruct tpdm_drvdata *drvdata = dev_get_drvdata(&adev->dev);\n\n\tcoresight_unregister(drvdata->csdev);\n}\n\n \nstatic struct amba_id tpdm_ids[] = {\n\t{\n\t\t.id = 0x000f0e00,\n\t\t.mask = 0x000fff00,\n\t},\n\t{ 0, 0},\n};\n\nstatic struct amba_driver tpdm_driver = {\n\t.drv = {\n\t\t.name   = \"coresight-tpdm\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe          = tpdm_probe,\n\t.id_table\t= tpdm_ids,\n\t.remove\t\t= tpdm_remove,\n};\n\nmodule_amba_driver(tpdm_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Trace, Profiling & Diagnostic Monitor driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}