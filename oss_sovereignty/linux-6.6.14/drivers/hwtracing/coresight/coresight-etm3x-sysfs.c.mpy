{
  "module_name": "coresight-etm3x-sysfs.c",
  "hash_id": "420b2644adc8cfad8b8530099a9f439e67f49b07b8c8094c945e7618f391a11d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-etm3x-sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/pid_namespace.h>\n#include <linux/pm_runtime.h>\n#include <linux/sysfs.h>\n#include \"coresight-etm.h\"\n#include \"coresight-priv.h\"\n\nstatic ssize_t nr_addr_cmp_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->nr_addr_cmp;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(nr_addr_cmp);\n\nstatic ssize_t nr_cntr_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->nr_cntr;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(nr_cntr);\n\nstatic ssize_t nr_ctxid_cmp_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->nr_ctxid_cmp;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(nr_ctxid_cmp);\n\nstatic ssize_t etmsr_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tunsigned long flags, val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tpm_runtime_get_sync(dev->parent);\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\tCS_UNLOCK(drvdata->base);\n\n\tval = etm_readl(drvdata, ETMSR);\n\n\tCS_LOCK(drvdata->base);\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\tpm_runtime_put(dev->parent);\n\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(etmsr);\n\nstatic ssize_t reset_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t size)\n{\n\tint i, ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val) {\n\t\tspin_lock(&drvdata->spinlock);\n\t\tmemset(config, 0, sizeof(struct etm_config));\n\t\tconfig->mode = ETM_MODE_EXCLUDE;\n\t\tconfig->trigger_event = ETM_DEFAULT_EVENT_VAL;\n\t\tfor (i = 0; i < drvdata->nr_addr_cmp; i++) {\n\t\t\tconfig->addr_type[i] = ETM_ADDR_TYPE_NONE;\n\t\t}\n\n\t\tetm_set_default(config);\n\t\tetm_release_trace_id(drvdata);\n\t\tspin_unlock(&drvdata->spinlock);\n\t}\n\n\treturn size;\n}\nstatic DEVICE_ATTR_WO(reset);\n\nstatic ssize_t mode_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->mode;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t mode_store(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&drvdata->spinlock);\n\tconfig->mode = val & ETM_MODE_ALL;\n\n\tif (config->mode & ETM_MODE_EXCLUDE)\n\t\tconfig->enable_ctrl1 |= ETMTECR1_INC_EXC;\n\telse\n\t\tconfig->enable_ctrl1 &= ~ETMTECR1_INC_EXC;\n\n\tif (config->mode & ETM_MODE_CYCACC)\n\t\tconfig->ctrl |= ETMCR_CYC_ACC;\n\telse\n\t\tconfig->ctrl &= ~ETMCR_CYC_ACC;\n\n\tif (config->mode & ETM_MODE_STALL) {\n\t\tif (!(drvdata->etmccr & ETMCCR_FIFOFULL)) {\n\t\t\tdev_warn(dev, \"stall mode not supported\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tconfig->ctrl |= ETMCR_STALL_MODE;\n\t} else\n\t\tconfig->ctrl &= ~ETMCR_STALL_MODE;\n\n\tif (config->mode & ETM_MODE_TIMESTAMP) {\n\t\tif (!(drvdata->etmccer & ETMCCER_TIMESTAMP)) {\n\t\t\tdev_warn(dev, \"timestamp not supported\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tconfig->ctrl |= ETMCR_TIMESTAMP_EN;\n\t} else\n\t\tconfig->ctrl &= ~ETMCR_TIMESTAMP_EN;\n\n\tif (config->mode & ETM_MODE_CTXID)\n\t\tconfig->ctrl |= ETMCR_CTXID_SIZE;\n\telse\n\t\tconfig->ctrl &= ~ETMCR_CTXID_SIZE;\n\n\tif (config->mode & ETM_MODE_BBROAD)\n\t\tconfig->ctrl |= ETMCR_BRANCH_BROADCAST;\n\telse\n\t\tconfig->ctrl &= ~ETMCR_BRANCH_BROADCAST;\n\n\tif (config->mode & ETM_MODE_RET_STACK)\n\t\tconfig->ctrl |= ETMCR_RETURN_STACK;\n\telse\n\t\tconfig->ctrl &= ~ETMCR_RETURN_STACK;\n\n\tif (config->mode & (ETM_MODE_EXCL_KERN | ETM_MODE_EXCL_USER))\n\t\tetm_config_trace_mode(config);\n\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n\nerr_unlock:\n\tspin_unlock(&drvdata->spinlock);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(mode);\n\nstatic ssize_t trigger_event_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->trigger_event;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t trigger_event_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig->trigger_event = val & ETM_EVENT_MASK;\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(trigger_event);\n\nstatic ssize_t enable_event_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->enable_event;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t enable_event_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig->enable_event = val & ETM_EVENT_MASK;\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(enable_event);\n\nstatic ssize_t fifofull_level_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->fifofull_level;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t fifofull_level_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig->fifofull_level = val;\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(fifofull_level);\n\nstatic ssize_t addr_idx_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->addr_idx;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t addr_idx_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val >= drvdata->nr_addr_cmp)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock(&drvdata->spinlock);\n\tconfig->addr_idx = val;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_idx);\n\nstatic ssize_t addr_single_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\n\t      config->addr_type[idx] == ETM_ADDR_TYPE_SINGLE)) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EINVAL;\n\t}\n\n\tval = config->addr_val[idx];\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t addr_single_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t size)\n{\n\tu8 idx;\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\n\t      config->addr_type[idx] == ETM_ADDR_TYPE_SINGLE)) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig->addr_val[idx] = val;\n\tconfig->addr_type[idx] = ETM_ADDR_TYPE_SINGLE;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_single);\n\nstatic ssize_t addr_range_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tu8 idx;\n\tunsigned long val1, val2;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (idx % 2 != 0) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\tif (!((config->addr_type[idx] == ETM_ADDR_TYPE_NONE &&\n\t       config->addr_type[idx + 1] == ETM_ADDR_TYPE_NONE) ||\n\t      (config->addr_type[idx] == ETM_ADDR_TYPE_RANGE &&\n\t       config->addr_type[idx + 1] == ETM_ADDR_TYPE_RANGE))) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tval1 = config->addr_val[idx];\n\tval2 = config->addr_val[idx + 1];\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn sprintf(buf, \"%#lx %#lx\\n\", val1, val2);\n}\n\nstatic ssize_t addr_range_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val1, val2;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tif (sscanf(buf, \"%lx %lx\", &val1, &val2) != 2)\n\t\treturn -EINVAL;\n\t \n\tif (val1 > val2)\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (idx % 2 != 0) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\tif (!((config->addr_type[idx] == ETM_ADDR_TYPE_NONE &&\n\t       config->addr_type[idx + 1] == ETM_ADDR_TYPE_NONE) ||\n\t      (config->addr_type[idx] == ETM_ADDR_TYPE_RANGE &&\n\t       config->addr_type[idx + 1] == ETM_ADDR_TYPE_RANGE))) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tconfig->addr_val[idx] = val1;\n\tconfig->addr_type[idx] = ETM_ADDR_TYPE_RANGE;\n\tconfig->addr_val[idx + 1] = val2;\n\tconfig->addr_type[idx + 1] = ETM_ADDR_TYPE_RANGE;\n\tconfig->enable_ctrl1 |= (1 << (idx/2));\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_range);\n\nstatic ssize_t addr_start_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\n\t      config->addr_type[idx] == ETM_ADDR_TYPE_START)) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tval = config->addr_val[idx];\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t addr_start_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tu8 idx;\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\n\t      config->addr_type[idx] == ETM_ADDR_TYPE_START)) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tconfig->addr_val[idx] = val;\n\tconfig->addr_type[idx] = ETM_ADDR_TYPE_START;\n\tconfig->startstop_ctrl |= (1 << idx);\n\tconfig->enable_ctrl1 |= ETMTECR1_START_STOP;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_start);\n\nstatic ssize_t addr_stop_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\n\t      config->addr_type[idx] == ETM_ADDR_TYPE_STOP)) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tval = config->addr_val[idx];\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t addr_stop_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tu8 idx;\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\n\t      config->addr_type[idx] == ETM_ADDR_TYPE_STOP)) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tconfig->addr_val[idx] = val;\n\tconfig->addr_type[idx] = ETM_ADDR_TYPE_STOP;\n\tconfig->startstop_ctrl |= (1 << (idx + 16));\n\tconfig->enable_ctrl1 |= ETMTECR1_START_STOP;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_stop);\n\nstatic ssize_t addr_acctype_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tval = config->addr_acctype[config->addr_idx];\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t addr_acctype_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&drvdata->spinlock);\n\tconfig->addr_acctype[config->addr_idx] = val;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_acctype);\n\nstatic ssize_t cntr_idx_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->cntr_idx;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t cntr_idx_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val >= drvdata->nr_cntr)\n\t\treturn -EINVAL;\n\t \n\tspin_lock(&drvdata->spinlock);\n\tconfig->cntr_idx = val;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(cntr_idx);\n\nstatic ssize_t cntr_rld_val_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tval = config->cntr_rld_val[config->cntr_idx];\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t cntr_rld_val_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&drvdata->spinlock);\n\tconfig->cntr_rld_val[config->cntr_idx] = val;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(cntr_rld_val);\n\nstatic ssize_t cntr_event_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tval = config->cntr_event[config->cntr_idx];\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t cntr_event_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&drvdata->spinlock);\n\tconfig->cntr_event[config->cntr_idx] = val & ETM_EVENT_MASK;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(cntr_event);\n\nstatic ssize_t cntr_rld_event_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tval = config->cntr_rld_event[config->cntr_idx];\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t cntr_rld_event_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&drvdata->spinlock);\n\tconfig->cntr_rld_event[config->cntr_idx] = val & ETM_EVENT_MASK;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(cntr_rld_event);\n\nstatic ssize_t cntr_val_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint i, ret = 0;\n\tu32 val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tif (!local_read(&drvdata->mode)) {\n\t\tspin_lock(&drvdata->spinlock);\n\t\tfor (i = 0; i < drvdata->nr_cntr; i++)\n\t\t\tret += sprintf(buf, \"counter %d: %x\\n\",\n\t\t\t\t       i, config->cntr_val[i]);\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < drvdata->nr_cntr; i++) {\n\t\tval = etm_readl(drvdata, ETMCNTVRn(i));\n\t\tret += sprintf(buf, \"counter %d: %x\\n\", i, val);\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t cntr_val_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&drvdata->spinlock);\n\tconfig->cntr_val[config->cntr_idx] = val;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(cntr_val);\n\nstatic ssize_t seq_12_event_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->seq_12_event;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t seq_12_event_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig->seq_12_event = val & ETM_EVENT_MASK;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(seq_12_event);\n\nstatic ssize_t seq_21_event_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->seq_21_event;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t seq_21_event_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig->seq_21_event = val & ETM_EVENT_MASK;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(seq_21_event);\n\nstatic ssize_t seq_23_event_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->seq_23_event;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t seq_23_event_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig->seq_23_event = val & ETM_EVENT_MASK;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(seq_23_event);\n\nstatic ssize_t seq_31_event_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->seq_31_event;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t seq_31_event_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig->seq_31_event = val & ETM_EVENT_MASK;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(seq_31_event);\n\nstatic ssize_t seq_32_event_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->seq_32_event;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t seq_32_event_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig->seq_32_event = val & ETM_EVENT_MASK;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(seq_32_event);\n\nstatic ssize_t seq_13_event_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->seq_13_event;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t seq_13_event_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig->seq_13_event = val & ETM_EVENT_MASK;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(seq_13_event);\n\nstatic ssize_t seq_curr_state_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tunsigned long val, flags;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tif (!local_read(&drvdata->mode)) {\n\t\tval = config->seq_curr_state;\n\t\tgoto out;\n\t}\n\n\tpm_runtime_get_sync(dev->parent);\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\n\tCS_UNLOCK(drvdata->base);\n\tval = (etm_readl(drvdata, ETMSQR) & ETM_SQR_MASK);\n\tCS_LOCK(drvdata->base);\n\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\tpm_runtime_put(dev->parent);\nout:\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t seq_curr_state_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > ETM_SEQ_STATE_MAX_VAL)\n\t\treturn -EINVAL;\n\n\tconfig->seq_curr_state = val;\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(seq_curr_state);\n\nstatic ssize_t ctxid_idx_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->ctxid_idx;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t ctxid_idx_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val >= drvdata->nr_ctxid_cmp)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock(&drvdata->spinlock);\n\tconfig->ctxid_idx = val;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(ctxid_idx);\n\nstatic ssize_t ctxid_pid_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\t \n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tval = config->ctxid_pid[config->ctxid_idx];\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t ctxid_pid_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long pid;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\t \n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tret = kstrtoul(buf, 16, &pid);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&drvdata->spinlock);\n\tconfig->ctxid_pid[config->ctxid_idx] = pid;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(ctxid_pid);\n\nstatic ssize_t ctxid_mask_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\t \n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tval = config->ctxid_mask;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t ctxid_mask_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\t \n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig->ctxid_mask = val;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(ctxid_mask);\n\nstatic ssize_t sync_freq_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->sync_freq;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t sync_freq_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig->sync_freq = val & ETM_SYNC_MASK;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(sync_freq);\n\nstatic ssize_t timestamp_event_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tval = config->timestamp_event;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t timestamp_event_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etm_config *config = &drvdata->config;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig->timestamp_event = val & ETM_EVENT_MASK;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(timestamp_event);\n\nstatic ssize_t cpu_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->cpu;\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", val);\n\n}\nstatic DEVICE_ATTR_RO(cpu);\n\nstatic ssize_t traceid_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tint trace_id;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\ttrace_id = etm_read_alloc_trace_id(drvdata);\n\tif (trace_id < 0)\n\t\treturn trace_id;\n\n\treturn sysfs_emit(buf, \"%#x\\n\", trace_id);\n}\nstatic DEVICE_ATTR_RO(traceid);\n\nstatic struct attribute *coresight_etm_attrs[] = {\n\t&dev_attr_nr_addr_cmp.attr,\n\t&dev_attr_nr_cntr.attr,\n\t&dev_attr_nr_ctxid_cmp.attr,\n\t&dev_attr_etmsr.attr,\n\t&dev_attr_reset.attr,\n\t&dev_attr_mode.attr,\n\t&dev_attr_trigger_event.attr,\n\t&dev_attr_enable_event.attr,\n\t&dev_attr_fifofull_level.attr,\n\t&dev_attr_addr_idx.attr,\n\t&dev_attr_addr_single.attr,\n\t&dev_attr_addr_range.attr,\n\t&dev_attr_addr_start.attr,\n\t&dev_attr_addr_stop.attr,\n\t&dev_attr_addr_acctype.attr,\n\t&dev_attr_cntr_idx.attr,\n\t&dev_attr_cntr_rld_val.attr,\n\t&dev_attr_cntr_event.attr,\n\t&dev_attr_cntr_rld_event.attr,\n\t&dev_attr_cntr_val.attr,\n\t&dev_attr_seq_12_event.attr,\n\t&dev_attr_seq_21_event.attr,\n\t&dev_attr_seq_23_event.attr,\n\t&dev_attr_seq_31_event.attr,\n\t&dev_attr_seq_32_event.attr,\n\t&dev_attr_seq_13_event.attr,\n\t&dev_attr_seq_curr_state.attr,\n\t&dev_attr_ctxid_idx.attr,\n\t&dev_attr_ctxid_pid.attr,\n\t&dev_attr_ctxid_mask.attr,\n\t&dev_attr_sync_freq.attr,\n\t&dev_attr_timestamp_event.attr,\n\t&dev_attr_traceid.attr,\n\t&dev_attr_cpu.attr,\n\tNULL,\n};\n\nstatic struct attribute *coresight_etm_mgmt_attrs[] = {\n\tcoresight_simple_reg32(etmccr, ETMCCR),\n\tcoresight_simple_reg32(etmccer, ETMCCER),\n\tcoresight_simple_reg32(etmscr, ETMSCR),\n\tcoresight_simple_reg32(etmidr, ETMIDR),\n\tcoresight_simple_reg32(etmcr, ETMCR),\n\tcoresight_simple_reg32(etmtraceidr, ETMTRACEIDR),\n\tcoresight_simple_reg32(etmteevr, ETMTEEVR),\n\tcoresight_simple_reg32(etmtssvr, ETMTSSCR),\n\tcoresight_simple_reg32(etmtecr1, ETMTECR1),\n\tcoresight_simple_reg32(etmtecr2, ETMTECR2),\n\tNULL,\n};\n\nstatic const struct attribute_group coresight_etm_group = {\n\t.attrs = coresight_etm_attrs,\n};\n\nstatic const struct attribute_group coresight_etm_mgmt_group = {\n\t.attrs = coresight_etm_mgmt_attrs,\n\t.name = \"mgmt\",\n};\n\nconst struct attribute_group *coresight_etm_groups[] = {\n\t&coresight_etm_group,\n\t&coresight_etm_mgmt_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}