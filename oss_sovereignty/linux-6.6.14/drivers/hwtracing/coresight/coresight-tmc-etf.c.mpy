{
  "module_name": "coresight-tmc-etf.c",
  "hash_id": "9dd6c5620c504606a22ec4944a52905ffe41d6c8330f7c388f64410e26442acc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-tmc-etf.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/circ_buf.h>\n#include <linux/coresight.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include \"coresight-priv.h\"\n#include \"coresight-tmc.h\"\n#include \"coresight-etm-perf.h\"\n\nstatic int tmc_set_etf_buffer(struct coresight_device *csdev,\n\t\t\t      struct perf_output_handle *handle);\n\nstatic int __tmc_etb_enable_hw(struct tmc_drvdata *drvdata)\n{\n\tint rc = 0;\n\n\tCS_UNLOCK(drvdata->base);\n\n\t \n\trc = tmc_wait_for_tmcready(drvdata);\n\tif (rc) {\n\t\tdev_err(&drvdata->csdev->dev,\n\t\t\t\"Failed to enable: TMC not ready\\n\");\n\t\tCS_LOCK(drvdata->base);\n\t\treturn rc;\n\t}\n\n\twritel_relaxed(TMC_MODE_CIRCULAR_BUFFER, drvdata->base + TMC_MODE);\n\twritel_relaxed(TMC_FFCR_EN_FMT | TMC_FFCR_EN_TI |\n\t\t       TMC_FFCR_FON_FLIN | TMC_FFCR_FON_TRIG_EVT |\n\t\t       TMC_FFCR_TRIGON_TRIGIN,\n\t\t       drvdata->base + TMC_FFCR);\n\n\twritel_relaxed(drvdata->trigger_cntr, drvdata->base + TMC_TRG);\n\ttmc_enable_hw(drvdata);\n\n\tCS_LOCK(drvdata->base);\n\treturn rc;\n}\n\nstatic int tmc_etb_enable_hw(struct tmc_drvdata *drvdata)\n{\n\tint rc = coresight_claim_device(drvdata->csdev);\n\n\tif (rc)\n\t\treturn rc;\n\n\trc = __tmc_etb_enable_hw(drvdata);\n\tif (rc)\n\t\tcoresight_disclaim_device(drvdata->csdev);\n\treturn rc;\n}\n\nstatic void tmc_etb_dump_hw(struct tmc_drvdata *drvdata)\n{\n\tchar *bufp;\n\tu32 read_data, lost;\n\n\t \n\tlost = readl_relaxed(drvdata->base + TMC_STS) & TMC_STS_FULL;\n\tbufp = drvdata->buf;\n\tdrvdata->len = 0;\n\twhile (1) {\n\t\tread_data = readl_relaxed(drvdata->base + TMC_RRD);\n\t\tif (read_data == 0xFFFFFFFF)\n\t\t\tbreak;\n\t\tmemcpy(bufp, &read_data, 4);\n\t\tbufp += 4;\n\t\tdrvdata->len += 4;\n\t}\n\n\tif (lost)\n\t\tcoresight_insert_barrier_packet(drvdata->buf);\n\treturn;\n}\n\nstatic void __tmc_etb_disable_hw(struct tmc_drvdata *drvdata)\n{\n\tCS_UNLOCK(drvdata->base);\n\n\ttmc_flush_and_stop(drvdata);\n\t \n\tif (drvdata->mode == CS_MODE_SYSFS)\n\t\ttmc_etb_dump_hw(drvdata);\n\ttmc_disable_hw(drvdata);\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic void tmc_etb_disable_hw(struct tmc_drvdata *drvdata)\n{\n\t__tmc_etb_disable_hw(drvdata);\n\tcoresight_disclaim_device(drvdata->csdev);\n}\n\nstatic int __tmc_etf_enable_hw(struct tmc_drvdata *drvdata)\n{\n\tint rc = 0;\n\n\tCS_UNLOCK(drvdata->base);\n\n\t \n\trc = tmc_wait_for_tmcready(drvdata);\n\tif (rc) {\n\t\tdev_err(&drvdata->csdev->dev,\n\t\t\t\"Failed to enable : TMC is not ready\\n\");\n\t\tCS_LOCK(drvdata->base);\n\t\treturn rc;\n\t}\n\n\twritel_relaxed(TMC_MODE_HARDWARE_FIFO, drvdata->base + TMC_MODE);\n\twritel_relaxed(TMC_FFCR_EN_FMT | TMC_FFCR_EN_TI,\n\t\t       drvdata->base + TMC_FFCR);\n\twritel_relaxed(0x0, drvdata->base + TMC_BUFWM);\n\ttmc_enable_hw(drvdata);\n\n\tCS_LOCK(drvdata->base);\n\treturn rc;\n}\n\nstatic int tmc_etf_enable_hw(struct tmc_drvdata *drvdata)\n{\n\tint rc = coresight_claim_device(drvdata->csdev);\n\n\tif (rc)\n\t\treturn rc;\n\n\trc = __tmc_etf_enable_hw(drvdata);\n\tif (rc)\n\t\tcoresight_disclaim_device(drvdata->csdev);\n\treturn rc;\n}\n\nstatic void tmc_etf_disable_hw(struct tmc_drvdata *drvdata)\n{\n\tstruct coresight_device *csdev = drvdata->csdev;\n\n\tCS_UNLOCK(drvdata->base);\n\n\ttmc_flush_and_stop(drvdata);\n\ttmc_disable_hw(drvdata);\n\tcoresight_disclaim_device_unlocked(csdev);\n\tCS_LOCK(drvdata->base);\n}\n\n \nssize_t tmc_etb_get_sysfs_trace(struct tmc_drvdata *drvdata,\n\t\t\t\tloff_t pos, size_t len, char **bufpp)\n{\n\tssize_t actual = len;\n\n\t \n\tif (pos + actual > drvdata->len)\n\t\tactual = drvdata->len - pos;\n\tif (actual > 0)\n\t\t*bufpp = drvdata->buf + pos;\n\treturn actual;\n}\n\nstatic int tmc_enable_etf_sink_sysfs(struct coresight_device *csdev)\n{\n\tint ret = 0;\n\tbool used = false;\n\tchar *buf = NULL;\n\tunsigned long flags;\n\tstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\t \n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\tif (!drvdata->buf) {\n\t\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\n\t\t \n\t\tbuf = kzalloc(drvdata->size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\t}\n\n\tif (drvdata->reading) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (drvdata->mode == CS_MODE_SYSFS) {\n\t\tatomic_inc(&csdev->refcnt);\n\t\tgoto out;\n\t}\n\n\t \n\tif (drvdata->buf) {\n\t\tmemset(drvdata->buf, 0, drvdata->size);\n\t} else {\n\t\tused = true;\n\t\tdrvdata->buf = buf;\n\t}\n\n\tret = tmc_etb_enable_hw(drvdata);\n\tif (!ret) {\n\t\tdrvdata->mode = CS_MODE_SYSFS;\n\t\tatomic_inc(&csdev->refcnt);\n\t} else {\n\t\t \n\t\tused = false;\n\t}\nout:\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\n\t \n\tif (!used)\n\t\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int tmc_enable_etf_sink_perf(struct coresight_device *csdev, void *data)\n{\n\tint ret = 0;\n\tpid_t pid;\n\tunsigned long flags;\n\tstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tstruct perf_output_handle *handle = data;\n\tstruct cs_buffers *buf = etm_perf_sink_config(handle);\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\tdo {\n\t\tret = -EINVAL;\n\t\tif (drvdata->reading)\n\t\t\tbreak;\n\t\t \n\t\tif (drvdata->mode == CS_MODE_SYSFS) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpid = buf->pid;\n\n\t\tif (drvdata->pid != -1 && drvdata->pid != pid) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = tmc_set_etf_buffer(csdev, handle);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (drvdata->pid == pid) {\n\t\t\tatomic_inc(&csdev->refcnt);\n\t\t\tbreak;\n\t\t}\n\n\t\tret  = tmc_etb_enable_hw(drvdata);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tdrvdata->pid = pid;\n\t\t\tdrvdata->mode = CS_MODE_PERF;\n\t\t\tatomic_inc(&csdev->refcnt);\n\t\t}\n\t} while (0);\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\n\treturn ret;\n}\n\nstatic int tmc_enable_etf_sink(struct coresight_device *csdev,\n\t\t\t       enum cs_mode mode, void *data)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase CS_MODE_SYSFS:\n\t\tret = tmc_enable_etf_sink_sysfs(csdev);\n\t\tbreak;\n\tcase CS_MODE_PERF:\n\t\tret = tmc_enable_etf_sink_perf(csdev, data);\n\t\tbreak;\n\t \n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(&csdev->dev, \"TMC-ETB/ETF enabled\\n\");\n\treturn 0;\n}\n\nstatic int tmc_disable_etf_sink(struct coresight_device *csdev)\n{\n\tunsigned long flags;\n\tstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\n\tif (drvdata->reading) {\n\t\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tif (atomic_dec_return(&csdev->refcnt)) {\n\t\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tWARN_ON_ONCE(drvdata->mode == CS_MODE_DISABLED);\n\ttmc_etb_disable_hw(drvdata);\n\t \n\tdrvdata->pid = -1;\n\tdrvdata->mode = CS_MODE_DISABLED;\n\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\n\tdev_dbg(&csdev->dev, \"TMC-ETB/ETF disabled\\n\");\n\treturn 0;\n}\n\nstatic int tmc_enable_etf_link(struct coresight_device *csdev,\n\t\t\t       struct coresight_connection *in,\n\t\t\t       struct coresight_connection *out)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tbool first_enable = false;\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\tif (drvdata->reading) {\n\t\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tif (atomic_read(&csdev->refcnt) == 0) {\n\t\tret = tmc_etf_enable_hw(drvdata);\n\t\tif (!ret) {\n\t\t\tdrvdata->mode = CS_MODE_SYSFS;\n\t\t\tfirst_enable = true;\n\t\t}\n\t}\n\tif (!ret)\n\t\tatomic_inc(&csdev->refcnt);\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\n\tif (first_enable)\n\t\tdev_dbg(&csdev->dev, \"TMC-ETF enabled\\n\");\n\treturn ret;\n}\n\nstatic void tmc_disable_etf_link(struct coresight_device *csdev,\n\t\t\t\t struct coresight_connection *in,\n\t\t\t\t struct coresight_connection *out)\n{\n\tunsigned long flags;\n\tstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tbool last_disable = false;\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\tif (drvdata->reading) {\n\t\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\t\treturn;\n\t}\n\n\tif (atomic_dec_return(&csdev->refcnt) == 0) {\n\t\ttmc_etf_disable_hw(drvdata);\n\t\tdrvdata->mode = CS_MODE_DISABLED;\n\t\tlast_disable = true;\n\t}\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\n\tif (last_disable)\n\t\tdev_dbg(&csdev->dev, \"TMC-ETF disabled\\n\");\n}\n\nstatic void *tmc_alloc_etf_buffer(struct coresight_device *csdev,\n\t\t\t\t  struct perf_event *event, void **pages,\n\t\t\t\t  int nr_pages, bool overwrite)\n{\n\tint node;\n\tstruct cs_buffers *buf;\n\n\tnode = (event->cpu == -1) ? NUMA_NO_NODE : cpu_to_node(event->cpu);\n\n\t \n\tbuf = kzalloc_node(sizeof(struct cs_buffers), GFP_KERNEL, node);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->pid = task_pid_nr(event->owner);\n\tbuf->snapshot = overwrite;\n\tbuf->nr_pages = nr_pages;\n\tbuf->data_pages = pages;\n\n\treturn buf;\n}\n\nstatic void tmc_free_etf_buffer(void *config)\n{\n\tstruct cs_buffers *buf = config;\n\n\tkfree(buf);\n}\n\nstatic int tmc_set_etf_buffer(struct coresight_device *csdev,\n\t\t\t      struct perf_output_handle *handle)\n{\n\tint ret = 0;\n\tunsigned long head;\n\tstruct cs_buffers *buf = etm_perf_sink_config(handle);\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\t \n\thead = handle->head & (((unsigned long)buf->nr_pages << PAGE_SHIFT) - 1);\n\n\t \n\tbuf->cur = head / PAGE_SIZE;\n\n\t \n\tbuf->offset = head % PAGE_SIZE;\n\n\tlocal_set(&buf->data_size, 0);\n\n\treturn ret;\n}\n\nstatic unsigned long tmc_update_etf_buffer(struct coresight_device *csdev,\n\t\t\t\t  struct perf_output_handle *handle,\n\t\t\t\t  void *sink_config)\n{\n\tbool lost = false;\n\tint i, cur;\n\tconst u32 *barrier;\n\tu32 *buf_ptr;\n\tu64 read_ptr, write_ptr;\n\tu32 status;\n\tunsigned long offset, to_read = 0, flags;\n\tstruct cs_buffers *buf = sink_config;\n\tstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tif (!buf)\n\t\treturn 0;\n\n\t \n\tif (WARN_ON_ONCE(drvdata->mode != CS_MODE_PERF))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\n\t \n\tif (atomic_read(&csdev->refcnt) != 1)\n\t\tgoto out;\n\n\tCS_UNLOCK(drvdata->base);\n\n\ttmc_flush_and_stop(drvdata);\n\n\tread_ptr = tmc_read_rrp(drvdata);\n\twrite_ptr = tmc_read_rwp(drvdata);\n\n\t \n\tstatus = readl_relaxed(drvdata->base + TMC_STS);\n\tif (status & TMC_STS_FULL) {\n\t\tlost = true;\n\t\tto_read = drvdata->size;\n\t} else {\n\t\tto_read = CIRC_CNT(write_ptr, read_ptr, drvdata->size);\n\t}\n\n\t \n\tif (!buf->snapshot && to_read > handle->size) {\n\t\tu32 mask = tmc_get_memwidth_mask(drvdata);\n\n\t\t \n\t\tto_read = handle->size & mask;\n\t\t \n\t\tread_ptr = (write_ptr + drvdata->size) - to_read;\n\t\t \n\t\tif (read_ptr > (drvdata->size - 1))\n\t\t\tread_ptr -= drvdata->size;\n\t\t \n\t\ttmc_write_rrp(drvdata, read_ptr);\n\t\tlost = true;\n\t}\n\n\t \n\tif (!buf->snapshot && lost)\n\t\tperf_aux_output_flag(handle, PERF_AUX_FLAG_TRUNCATED);\n\n\tcur = buf->cur;\n\toffset = buf->offset;\n\tbarrier = coresight_barrier_pkt;\n\n\t \n\tfor (i = 0; i < to_read; i += 4) {\n\t\tbuf_ptr = buf->data_pages[cur] + offset;\n\t\t*buf_ptr = readl_relaxed(drvdata->base + TMC_RRD);\n\n\t\tif (lost && i < CORESIGHT_BARRIER_PKT_SIZE) {\n\t\t\t*buf_ptr = *barrier;\n\t\t\tbarrier++;\n\t\t}\n\n\t\toffset += 4;\n\t\tif (offset >= PAGE_SIZE) {\n\t\t\toffset = 0;\n\t\t\tcur++;\n\t\t\t \n\t\t\tcur &= buf->nr_pages - 1;\n\t\t}\n\t}\n\n\t \n\tif (buf->snapshot)\n\t\thandle->head += to_read;\n\n\t \n\tCS_LOCK(drvdata->base);\nout:\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\n\treturn to_read;\n}\n\nstatic const struct coresight_ops_sink tmc_etf_sink_ops = {\n\t.enable\t\t= tmc_enable_etf_sink,\n\t.disable\t= tmc_disable_etf_sink,\n\t.alloc_buffer\t= tmc_alloc_etf_buffer,\n\t.free_buffer\t= tmc_free_etf_buffer,\n\t.update_buffer\t= tmc_update_etf_buffer,\n};\n\nstatic const struct coresight_ops_link tmc_etf_link_ops = {\n\t.enable\t\t= tmc_enable_etf_link,\n\t.disable\t= tmc_disable_etf_link,\n};\n\nconst struct coresight_ops tmc_etb_cs_ops = {\n\t.sink_ops\t= &tmc_etf_sink_ops,\n};\n\nconst struct coresight_ops tmc_etf_cs_ops = {\n\t.sink_ops\t= &tmc_etf_sink_ops,\n\t.link_ops\t= &tmc_etf_link_ops,\n};\n\nint tmc_read_prepare_etb(struct tmc_drvdata *drvdata)\n{\n\tenum tmc_mode mode;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t \n\tif (WARN_ON_ONCE(drvdata->config_type != TMC_CONFIG_TYPE_ETB &&\n\t\t\t drvdata->config_type != TMC_CONFIG_TYPE_ETF))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\n\tif (drvdata->reading) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (drvdata->mode == CS_MODE_PERF) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (drvdata->buf == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (drvdata->mode == CS_MODE_SYSFS) {\n\t\t \n\t\tmode = readl_relaxed(drvdata->base + TMC_MODE);\n\t\tif (mode != TMC_MODE_CIRCULAR_BUFFER) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t__tmc_etb_disable_hw(drvdata);\n\t}\n\n\tdrvdata->reading = true;\nout:\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\n\treturn ret;\n}\n\nint tmc_read_unprepare_etb(struct tmc_drvdata *drvdata)\n{\n\tchar *buf = NULL;\n\tenum tmc_mode mode;\n\tunsigned long flags;\n\tint rc = 0;\n\n\t \n\tif (WARN_ON_ONCE(drvdata->config_type != TMC_CONFIG_TYPE_ETB &&\n\t\t\t drvdata->config_type != TMC_CONFIG_TYPE_ETF))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\n\t \n\tif (drvdata->mode == CS_MODE_SYSFS) {\n\t\t \n\t\tmode = readl_relaxed(drvdata->base + TMC_MODE);\n\t\tif (mode != TMC_MODE_CIRCULAR_BUFFER) {\n\t\t\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tmemset(drvdata->buf, 0, drvdata->size);\n\t\trc = __tmc_etb_enable_hw(drvdata);\n\t\tif (rc) {\n\t\t\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\t \n\t\tbuf = drvdata->buf;\n\t\tdrvdata->buf = NULL;\n\t}\n\n\tdrvdata->reading = false;\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\n\t \n\tkfree(buf);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}