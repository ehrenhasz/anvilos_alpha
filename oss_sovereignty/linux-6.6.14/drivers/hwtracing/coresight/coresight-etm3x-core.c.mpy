{
  "module_name": "coresight-etm3x-core.c",
  "hash_id": "528ab232af727ba6dc44cdde69c1ebcaabf5daff45926da257a49faa32e94f08",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-etm3x-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sysfs.h>\n#include <linux/stat.h>\n#include <linux/pm_runtime.h>\n#include <linux/cpu.h>\n#include <linux/of.h>\n#include <linux/coresight.h>\n#include <linux/coresight-pmu.h>\n#include <linux/amba/bus.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/clk.h>\n#include <linux/perf_event.h>\n#include <asm/sections.h>\n\n#include \"coresight-etm.h\"\n#include \"coresight-etm-perf.h\"\n#include \"coresight-trace-id.h\"\n\n \nstatic int boot_enable;\nmodule_param_named(boot_enable, boot_enable, int, S_IRUGO);\n\nstatic struct etm_drvdata *etmdrvdata[NR_CPUS];\n\nstatic enum cpuhp_state hp_online;\n\n \nstatic void etm_os_unlock(struct etm_drvdata *drvdata)\n{\n\t \n\tetm_writel(drvdata, 0x0, ETMOSLAR);\n\tdrvdata->os_unlock = true;\n\tisb();\n}\n\nstatic void etm_set_pwrdwn(struct etm_drvdata *drvdata)\n{\n\tu32 etmcr;\n\n\t \n\tmb();\n\tisb();\n\tetmcr = etm_readl(drvdata, ETMCR);\n\tetmcr |= ETMCR_PWD_DWN;\n\tetm_writel(drvdata, etmcr, ETMCR);\n}\n\nstatic void etm_clr_pwrdwn(struct etm_drvdata *drvdata)\n{\n\tu32 etmcr;\n\n\tetmcr = etm_readl(drvdata, ETMCR);\n\tetmcr &= ~ETMCR_PWD_DWN;\n\tetm_writel(drvdata, etmcr, ETMCR);\n\t \n\tmb();\n\tisb();\n}\n\nstatic void etm_set_pwrup(struct etm_drvdata *drvdata)\n{\n\tu32 etmpdcr;\n\n\tetmpdcr = readl_relaxed(drvdata->base + ETMPDCR);\n\tetmpdcr |= ETMPDCR_PWD_UP;\n\twritel_relaxed(etmpdcr, drvdata->base + ETMPDCR);\n\t \n\tmb();\n\tisb();\n}\n\nstatic void etm_clr_pwrup(struct etm_drvdata *drvdata)\n{\n\tu32 etmpdcr;\n\n\t \n\tmb();\n\tisb();\n\tetmpdcr = readl_relaxed(drvdata->base + ETMPDCR);\n\tetmpdcr &= ~ETMPDCR_PWD_UP;\n\twritel_relaxed(etmpdcr, drvdata->base + ETMPDCR);\n}\n\n \n\nstatic int coresight_timeout_etm(struct etm_drvdata *drvdata, u32 offset,\n\t\t\t\t  int position, int value)\n{\n\tint i;\n\tu32 val;\n\n\tfor (i = TIMEOUT_US; i > 0; i--) {\n\t\tval = etm_readl(drvdata, offset);\n\t\t \n\t\tif (value) {\n\t\t\tif (val & BIT(position))\n\t\t\t\treturn 0;\n\t\t \n\t\t} else {\n\t\t\tif (!(val & BIT(position)))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (i - 1)\n\t\t\tudelay(1);\n\t}\n\n\treturn -EAGAIN;\n}\n\n\nstatic void etm_set_prog(struct etm_drvdata *drvdata)\n{\n\tu32 etmcr;\n\n\tetmcr = etm_readl(drvdata, ETMCR);\n\tetmcr |= ETMCR_ETM_PRG;\n\tetm_writel(drvdata, etmcr, ETMCR);\n\t \n\tisb();\n\tif (coresight_timeout_etm(drvdata, ETMSR, ETMSR_PROG_BIT, 1)) {\n\t\tdev_err(&drvdata->csdev->dev,\n\t\t\t\"%s: timeout observed when probing at offset %#x\\n\",\n\t\t\t__func__, ETMSR);\n\t}\n}\n\nstatic void etm_clr_prog(struct etm_drvdata *drvdata)\n{\n\tu32 etmcr;\n\n\tetmcr = etm_readl(drvdata, ETMCR);\n\tetmcr &= ~ETMCR_ETM_PRG;\n\tetm_writel(drvdata, etmcr, ETMCR);\n\t \n\tisb();\n\tif (coresight_timeout_etm(drvdata, ETMSR, ETMSR_PROG_BIT, 0)) {\n\t\tdev_err(&drvdata->csdev->dev,\n\t\t\t\"%s: timeout observed when probing at offset %#x\\n\",\n\t\t\t__func__, ETMSR);\n\t}\n}\n\nvoid etm_set_default(struct etm_config *config)\n{\n\tint i;\n\n\tif (WARN_ON_ONCE(!config))\n\t\treturn;\n\n\t \n\tconfig->enable_ctrl1 = ETMTECR1_INC_EXC;\n\tconfig->enable_ctrl2 = 0x0;\n\tconfig->enable_event = ETM_HARD_WIRE_RES_A;\n\n\tconfig->trigger_event = ETM_DEFAULT_EVENT_VAL;\n\tconfig->enable_event = ETM_HARD_WIRE_RES_A;\n\n\tconfig->seq_12_event = ETM_DEFAULT_EVENT_VAL;\n\tconfig->seq_21_event = ETM_DEFAULT_EVENT_VAL;\n\tconfig->seq_23_event = ETM_DEFAULT_EVENT_VAL;\n\tconfig->seq_31_event = ETM_DEFAULT_EVENT_VAL;\n\tconfig->seq_32_event = ETM_DEFAULT_EVENT_VAL;\n\tconfig->seq_13_event = ETM_DEFAULT_EVENT_VAL;\n\tconfig->timestamp_event = ETM_DEFAULT_EVENT_VAL;\n\n\tfor (i = 0; i < ETM_MAX_CNTR; i++) {\n\t\tconfig->cntr_rld_val[i] = 0x0;\n\t\tconfig->cntr_event[i] = ETM_DEFAULT_EVENT_VAL;\n\t\tconfig->cntr_rld_event[i] = ETM_DEFAULT_EVENT_VAL;\n\t\tconfig->cntr_val[i] = 0x0;\n\t}\n\n\tconfig->seq_curr_state = 0x0;\n\tconfig->ctxid_idx = 0x0;\n\tfor (i = 0; i < ETM_MAX_CTXID_CMP; i++)\n\t\tconfig->ctxid_pid[i] = 0x0;\n\n\tconfig->ctxid_mask = 0x0;\n\t \n\tconfig->sync_freq = 0x400;\n}\n\nvoid etm_config_trace_mode(struct etm_config *config)\n{\n\tu32 flags, mode;\n\n\tmode = config->mode;\n\n\tmode &= (ETM_MODE_EXCL_KERN | ETM_MODE_EXCL_USER);\n\n\t \n\tif (mode == (ETM_MODE_EXCL_KERN | ETM_MODE_EXCL_USER))\n\t\treturn;\n\n\t \n\tif (!(mode & ETM_MODE_EXCL_KERN) && !(mode & ETM_MODE_EXCL_USER))\n\t\treturn;\n\n\tflags = (1 << 0 |\t \n\t\t 3 << 3 |\t \n\t\t 0 << 5 |\t \n\t\t 0 << 7 |\t \n\t\t 0 << 8);\t \n\n\t \n\tconfig->enable_ctrl2 = 0x0;\n\n\t \n\tconfig->enable_ctrl1 = ETMTECR1_ADDR_COMP_1;\n\n\t \n\n\t \n\tflags |= (0 << 12 | 1 << 10);\n\n\tif (mode & ETM_MODE_EXCL_USER) {\n\t\t \n\t\tflags |= (1 << 13 | 0 << 11);\n\t} else {\n\t\t \n\t\tflags |= (1 << 13 | 1 << 11);\n\t}\n\n\t \n\tconfig->addr_val[0] = (u32) 0x0;\n\tconfig->addr_val[1] = (u32) ~0x0;\n\tconfig->addr_acctype[0] = flags;\n\tconfig->addr_acctype[1] = flags;\n\tconfig->addr_type[0] = ETM_ADDR_TYPE_RANGE;\n\tconfig->addr_type[1] = ETM_ADDR_TYPE_RANGE;\n}\n\n#define ETM3X_SUPPORTED_OPTIONS (ETMCR_CYC_ACC | \\\n\t\t\t\t ETMCR_TIMESTAMP_EN | \\\n\t\t\t\t ETMCR_RETURN_STACK)\n\nstatic int etm_parse_event_config(struct etm_drvdata *drvdata,\n\t\t\t\t  struct perf_event *event)\n{\n\tstruct etm_config *config = &drvdata->config;\n\tstruct perf_event_attr *attr = &event->attr;\n\n\tif (!attr)\n\t\treturn -EINVAL;\n\n\t \n\tmemset(config, 0, sizeof(struct etm_config));\n\n\tif (attr->exclude_kernel)\n\t\tconfig->mode = ETM_MODE_EXCL_KERN;\n\n\tif (attr->exclude_user)\n\t\tconfig->mode = ETM_MODE_EXCL_USER;\n\n\t \n\tetm_set_default(config);\n\n\t \n\tif (config->mode)\n\t\tetm_config_trace_mode(config);\n\n\t \n\tif (attr->config & ~ETM3X_SUPPORTED_OPTIONS)\n\t\treturn -EINVAL;\n\n\tconfig->ctrl = attr->config;\n\n\t \n\tif (!task_is_in_init_pid_ns(current))\n\t\tconfig->ctrl &= ~ETMCR_CTXID_SIZE;\n\n\t \n\tif ((config->ctrl & ETMCR_RETURN_STACK) &&\n\t    !(drvdata->etmccer & ETMCCER_RETSTACK))\n\t\tconfig->ctrl &= ~ETMCR_RETURN_STACK;\n\n\treturn 0;\n}\n\nstatic int etm_enable_hw(struct etm_drvdata *drvdata)\n{\n\tint i, rc;\n\tu32 etmcr;\n\tstruct etm_config *config = &drvdata->config;\n\tstruct coresight_device *csdev = drvdata->csdev;\n\n\tCS_UNLOCK(drvdata->base);\n\n\trc = coresight_claim_device_unlocked(csdev);\n\tif (rc)\n\t\tgoto done;\n\n\t \n\tetm_clr_pwrdwn(drvdata);\n\t \n\tetm_set_pwrup(drvdata);\n\t \n\tetm_os_unlock(drvdata);\n\n\tetm_set_prog(drvdata);\n\n\tetmcr = etm_readl(drvdata, ETMCR);\n\t \n\tetmcr &= ~ETM3X_SUPPORTED_OPTIONS;\n\tetmcr |= drvdata->port_size;\n\tetmcr |= ETMCR_ETM_EN;\n\tetm_writel(drvdata, config->ctrl | etmcr, ETMCR);\n\tetm_writel(drvdata, config->trigger_event, ETMTRIGGER);\n\tetm_writel(drvdata, config->startstop_ctrl, ETMTSSCR);\n\tetm_writel(drvdata, config->enable_event, ETMTEEVR);\n\tetm_writel(drvdata, config->enable_ctrl1, ETMTECR1);\n\tetm_writel(drvdata, config->fifofull_level, ETMFFLR);\n\tfor (i = 0; i < drvdata->nr_addr_cmp; i++) {\n\t\tetm_writel(drvdata, config->addr_val[i], ETMACVRn(i));\n\t\tetm_writel(drvdata, config->addr_acctype[i], ETMACTRn(i));\n\t}\n\tfor (i = 0; i < drvdata->nr_cntr; i++) {\n\t\tetm_writel(drvdata, config->cntr_rld_val[i], ETMCNTRLDVRn(i));\n\t\tetm_writel(drvdata, config->cntr_event[i], ETMCNTENRn(i));\n\t\tetm_writel(drvdata, config->cntr_rld_event[i],\n\t\t\t   ETMCNTRLDEVRn(i));\n\t\tetm_writel(drvdata, config->cntr_val[i], ETMCNTVRn(i));\n\t}\n\tetm_writel(drvdata, config->seq_12_event, ETMSQ12EVR);\n\tetm_writel(drvdata, config->seq_21_event, ETMSQ21EVR);\n\tetm_writel(drvdata, config->seq_23_event, ETMSQ23EVR);\n\tetm_writel(drvdata, config->seq_31_event, ETMSQ31EVR);\n\tetm_writel(drvdata, config->seq_32_event, ETMSQ32EVR);\n\tetm_writel(drvdata, config->seq_13_event, ETMSQ13EVR);\n\tetm_writel(drvdata, config->seq_curr_state, ETMSQR);\n\tfor (i = 0; i < drvdata->nr_ext_out; i++)\n\t\tetm_writel(drvdata, ETM_DEFAULT_EVENT_VAL, ETMEXTOUTEVRn(i));\n\tfor (i = 0; i < drvdata->nr_ctxid_cmp; i++)\n\t\tetm_writel(drvdata, config->ctxid_pid[i], ETMCIDCVRn(i));\n\tetm_writel(drvdata, config->ctxid_mask, ETMCIDCMR);\n\tetm_writel(drvdata, config->sync_freq, ETMSYNCFR);\n\t \n\tetm_writel(drvdata, 0x0, ETMEXTINSELR);\n\tetm_writel(drvdata, config->timestamp_event, ETMTSEVR);\n\t \n\tetm_writel(drvdata, 0x0, ETMAUXCR);\n\tetm_writel(drvdata, drvdata->traceid, ETMTRACEIDR);\n\t \n\tetm_writel(drvdata, 0x0, ETMVMIDCVR);\n\n\tetm_clr_prog(drvdata);\n\ndone:\n\tCS_LOCK(drvdata->base);\n\n\tdev_dbg(&drvdata->csdev->dev, \"cpu: %d enable smp call done: %d\\n\",\n\t\tdrvdata->cpu, rc);\n\treturn rc;\n}\n\nstruct etm_enable_arg {\n\tstruct etm_drvdata *drvdata;\n\tint rc;\n};\n\nstatic void etm_enable_hw_smp_call(void *info)\n{\n\tstruct etm_enable_arg *arg = info;\n\n\tif (WARN_ON(!arg))\n\t\treturn;\n\targ->rc = etm_enable_hw(arg->drvdata);\n}\n\nstatic int etm_cpu_id(struct coresight_device *csdev)\n{\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\treturn drvdata->cpu;\n}\n\nint etm_read_alloc_trace_id(struct etm_drvdata *drvdata)\n{\n\tint trace_id;\n\n\t \n\ttrace_id = coresight_trace_id_get_cpu_id(drvdata->cpu);\n\tif (IS_VALID_CS_TRACE_ID(trace_id))\n\t\tdrvdata->traceid = (u8)trace_id;\n\telse\n\t\tdev_err(&drvdata->csdev->dev,\n\t\t\t\"Failed to allocate trace ID for %s on CPU%d\\n\",\n\t\t\tdev_name(&drvdata->csdev->dev), drvdata->cpu);\n\treturn trace_id;\n}\n\nvoid etm_release_trace_id(struct etm_drvdata *drvdata)\n{\n\tcoresight_trace_id_put_cpu_id(drvdata->cpu);\n}\n\nstatic int etm_enable_perf(struct coresight_device *csdev,\n\t\t\t   struct perf_event *event)\n{\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tint trace_id;\n\n\tif (WARN_ON_ONCE(drvdata->cpu != smp_processor_id()))\n\t\treturn -EINVAL;\n\n\t \n\tetm_parse_event_config(drvdata, event);\n\n\t \n\ttrace_id = coresight_trace_id_read_cpu_id(drvdata->cpu);\n\tif (!IS_VALID_CS_TRACE_ID(trace_id)) {\n\t\tdev_err(&drvdata->csdev->dev, \"Failed to set trace ID for %s on CPU%d\\n\",\n\t\t\tdev_name(&drvdata->csdev->dev), drvdata->cpu);\n\t\treturn -EINVAL;\n\t}\n\tdrvdata->traceid = (u8)trace_id;\n\n\t \n\treturn etm_enable_hw(drvdata);\n}\n\nstatic int etm_enable_sysfs(struct coresight_device *csdev)\n{\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tstruct etm_enable_arg arg = { };\n\tint ret;\n\n\tspin_lock(&drvdata->spinlock);\n\n\t \n\tret = etm_read_alloc_trace_id(drvdata);\n\tif (ret < 0)\n\t\tgoto unlock_enable_sysfs;\n\n\t \n\tif (cpu_online(drvdata->cpu)) {\n\t\targ.drvdata = drvdata;\n\t\tret = smp_call_function_single(drvdata->cpu,\n\t\t\t\t\t       etm_enable_hw_smp_call, &arg, 1);\n\t\tif (!ret)\n\t\t\tret = arg.rc;\n\t\tif (!ret)\n\t\t\tdrvdata->sticky_enable = true;\n\t} else {\n\t\tret = -ENODEV;\n\t}\n\n\tif (ret)\n\t\tetm_release_trace_id(drvdata);\n\nunlock_enable_sysfs:\n\tspin_unlock(&drvdata->spinlock);\n\n\tif (!ret)\n\t\tdev_dbg(&csdev->dev, \"ETM tracing enabled\\n\");\n\treturn ret;\n}\n\nstatic int etm_enable(struct coresight_device *csdev, struct perf_event *event,\n\t\t      enum cs_mode mode)\n{\n\tint ret;\n\tu32 val;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tval = local_cmpxchg(&drvdata->mode, CS_MODE_DISABLED, mode);\n\n\t \n\tif (val)\n\t\treturn -EBUSY;\n\n\tswitch (mode) {\n\tcase CS_MODE_SYSFS:\n\t\tret = etm_enable_sysfs(csdev);\n\t\tbreak;\n\tcase CS_MODE_PERF:\n\t\tret = etm_enable_perf(csdev, event);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\t \n\tif (ret)\n\t\tlocal_set(&drvdata->mode, CS_MODE_DISABLED);\n\n\treturn ret;\n}\n\nstatic void etm_disable_hw(void *info)\n{\n\tint i;\n\tstruct etm_drvdata *drvdata = info;\n\tstruct etm_config *config = &drvdata->config;\n\tstruct coresight_device *csdev = drvdata->csdev;\n\n\tCS_UNLOCK(drvdata->base);\n\tetm_set_prog(drvdata);\n\n\t \n\tconfig->seq_curr_state = (etm_readl(drvdata, ETMSQR) & ETM_SQR_MASK);\n\n\tfor (i = 0; i < drvdata->nr_cntr; i++)\n\t\tconfig->cntr_val[i] = etm_readl(drvdata, ETMCNTVRn(i));\n\n\tetm_set_pwrdwn(drvdata);\n\tcoresight_disclaim_device_unlocked(csdev);\n\n\tCS_LOCK(drvdata->base);\n\n\tdev_dbg(&drvdata->csdev->dev,\n\t\t\"cpu: %d disable smp call done\\n\", drvdata->cpu);\n}\n\nstatic void etm_disable_perf(struct coresight_device *csdev)\n{\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tif (WARN_ON_ONCE(drvdata->cpu != smp_processor_id()))\n\t\treturn;\n\n\tCS_UNLOCK(drvdata->base);\n\n\t \n\tetm_set_prog(drvdata);\n\n\t \n\tetm_set_pwrdwn(drvdata);\n\tcoresight_disclaim_device_unlocked(csdev);\n\n\tCS_LOCK(drvdata->base);\n\n\t \n\n}\n\nstatic void etm_disable_sysfs(struct coresight_device *csdev)\n{\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\t \n\tcpus_read_lock();\n\tspin_lock(&drvdata->spinlock);\n\n\t \n\tsmp_call_function_single(drvdata->cpu, etm_disable_hw, drvdata, 1);\n\n\tspin_unlock(&drvdata->spinlock);\n\tcpus_read_unlock();\n\n\t \n\n\tdev_dbg(&csdev->dev, \"ETM tracing disabled\\n\");\n}\n\nstatic void etm_disable(struct coresight_device *csdev,\n\t\t\tstruct perf_event *event)\n{\n\tenum cs_mode mode;\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\t \n\tmode = local_read(&drvdata->mode);\n\n\tswitch (mode) {\n\tcase CS_MODE_DISABLED:\n\t\tbreak;\n\tcase CS_MODE_SYSFS:\n\t\tetm_disable_sysfs(csdev);\n\t\tbreak;\n\tcase CS_MODE_PERF:\n\t\tetm_disable_perf(csdev);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(mode);\n\t\treturn;\n\t}\n\n\tif (mode)\n\t\tlocal_set(&drvdata->mode, CS_MODE_DISABLED);\n}\n\nstatic const struct coresight_ops_source etm_source_ops = {\n\t.cpu_id\t\t= etm_cpu_id,\n\t.enable\t\t= etm_enable,\n\t.disable\t= etm_disable,\n};\n\nstatic const struct coresight_ops etm_cs_ops = {\n\t.source_ops\t= &etm_source_ops,\n};\n\nstatic int etm_online_cpu(unsigned int cpu)\n{\n\tif (!etmdrvdata[cpu])\n\t\treturn 0;\n\n\tif (etmdrvdata[cpu]->boot_enable && !etmdrvdata[cpu]->sticky_enable)\n\t\tcoresight_enable(etmdrvdata[cpu]->csdev);\n\treturn 0;\n}\n\nstatic int etm_starting_cpu(unsigned int cpu)\n{\n\tif (!etmdrvdata[cpu])\n\t\treturn 0;\n\n\tspin_lock(&etmdrvdata[cpu]->spinlock);\n\tif (!etmdrvdata[cpu]->os_unlock) {\n\t\tetm_os_unlock(etmdrvdata[cpu]);\n\t\tetmdrvdata[cpu]->os_unlock = true;\n\t}\n\n\tif (local_read(&etmdrvdata[cpu]->mode))\n\t\tetm_enable_hw(etmdrvdata[cpu]);\n\tspin_unlock(&etmdrvdata[cpu]->spinlock);\n\treturn 0;\n}\n\nstatic int etm_dying_cpu(unsigned int cpu)\n{\n\tif (!etmdrvdata[cpu])\n\t\treturn 0;\n\n\tspin_lock(&etmdrvdata[cpu]->spinlock);\n\tif (local_read(&etmdrvdata[cpu]->mode))\n\t\tetm_disable_hw(etmdrvdata[cpu]);\n\tspin_unlock(&etmdrvdata[cpu]->spinlock);\n\treturn 0;\n}\n\nstatic bool etm_arch_supported(u8 arch)\n{\n\tswitch (arch) {\n\tcase ETM_ARCH_V3_3:\n\t\tbreak;\n\tcase ETM_ARCH_V3_5:\n\t\tbreak;\n\tcase PFT_ARCH_V1_0:\n\t\tbreak;\n\tcase PFT_ARCH_V1_1:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void etm_init_arch_data(void *info)\n{\n\tu32 etmidr;\n\tu32 etmccr;\n\tstruct etm_drvdata *drvdata = info;\n\n\t \n\tetm_os_unlock(drvdata);\n\n\tCS_UNLOCK(drvdata->base);\n\n\t \n\t(void)etm_readl(drvdata, ETMPDSR);\n\t \n\tetm_set_pwrup(drvdata);\n\t \n\tetm_clr_pwrdwn(drvdata);\n\t \n\tetm_set_prog(drvdata);\n\n\t \n\tetmidr = etm_readl(drvdata, ETMIDR);\n\tdrvdata->arch = BMVAL(etmidr, 4, 11);\n\tdrvdata->port_size = etm_readl(drvdata, ETMCR) & PORT_SIZE_MASK;\n\n\tdrvdata->etmccer = etm_readl(drvdata, ETMCCER);\n\tetmccr = etm_readl(drvdata, ETMCCR);\n\tdrvdata->etmccr = etmccr;\n\tdrvdata->nr_addr_cmp = BMVAL(etmccr, 0, 3) * 2;\n\tdrvdata->nr_cntr = BMVAL(etmccr, 13, 15);\n\tdrvdata->nr_ext_inp = BMVAL(etmccr, 17, 19);\n\tdrvdata->nr_ext_out = BMVAL(etmccr, 20, 22);\n\tdrvdata->nr_ctxid_cmp = BMVAL(etmccr, 24, 25);\n\n\tetm_set_pwrdwn(drvdata);\n\tetm_clr_pwrup(drvdata);\n\tCS_LOCK(drvdata->base);\n}\n\nstatic int __init etm_hp_setup(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_nocalls_cpuslocked(CPUHP_AP_ARM_CORESIGHT_STARTING,\n\t\t\t\t\t\t   \"arm/coresight:starting\",\n\t\t\t\t\t\t   etm_starting_cpu, etm_dying_cpu);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = cpuhp_setup_state_nocalls_cpuslocked(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\t   \"arm/coresight:online\",\n\t\t\t\t\t\t   etm_online_cpu, NULL);\n\n\t \n\tif (ret > 0) {\n\t\thp_online = ret;\n\t\treturn 0;\n\t}\n\n\t \n\tcpuhp_remove_state_nocalls(CPUHP_AP_ARM_CORESIGHT_STARTING);\n\n\treturn ret;\n}\n\nstatic void etm_hp_clear(void)\n{\n\tcpuhp_remove_state_nocalls(CPUHP_AP_ARM_CORESIGHT_STARTING);\n\tif (hp_online) {\n\t\tcpuhp_remove_state_nocalls(hp_online);\n\t\thp_online = 0;\n\t}\n}\n\nstatic int etm_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tint ret;\n\tvoid __iomem *base;\n\tstruct device *dev = &adev->dev;\n\tstruct coresight_platform_data *pdata = NULL;\n\tstruct etm_drvdata *drvdata;\n\tstruct resource *res = &adev->res;\n\tstruct coresight_desc desc = { 0 };\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->use_cp14 = fwnode_property_read_bool(dev->fwnode, \"arm,cp14\");\n\tdev_set_drvdata(dev, drvdata);\n\n\t \n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdrvdata->base = base;\n\tdesc.access = CSDEV_ACCESS_IOMEM(base);\n\n\tspin_lock_init(&drvdata->spinlock);\n\n\tdrvdata->atclk = devm_clk_get(&adev->dev, \"atclk\");  \n\tif (!IS_ERR(drvdata->atclk)) {\n\t\tret = clk_prepare_enable(drvdata->atclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdrvdata->cpu = coresight_get_cpu(dev);\n\tif (drvdata->cpu < 0)\n\t\treturn drvdata->cpu;\n\n\tdesc.name  = devm_kasprintf(dev, GFP_KERNEL, \"etm%d\", drvdata->cpu);\n\tif (!desc.name)\n\t\treturn -ENOMEM;\n\n\tif (smp_call_function_single(drvdata->cpu,\n\t\t\t\t     etm_init_arch_data,  drvdata, 1))\n\t\tdev_err(dev, \"ETM arch init failed\\n\");\n\n\tif (etm_arch_supported(drvdata->arch) == false)\n\t\treturn -EINVAL;\n\n\tetm_set_default(&drvdata->config);\n\n\tpdata = coresight_get_platform_data(dev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\n\tadev->dev.platform_data = pdata;\n\n\tdesc.type = CORESIGHT_DEV_TYPE_SOURCE;\n\tdesc.subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_PROC;\n\tdesc.ops = &etm_cs_ops;\n\tdesc.pdata = pdata;\n\tdesc.dev = dev;\n\tdesc.groups = coresight_etm_groups;\n\tdrvdata->csdev = coresight_register(&desc);\n\tif (IS_ERR(drvdata->csdev))\n\t\treturn PTR_ERR(drvdata->csdev);\n\n\tret = etm_perf_symlink(drvdata->csdev, true);\n\tif (ret) {\n\t\tcoresight_unregister(drvdata->csdev);\n\t\treturn ret;\n\t}\n\n\tetmdrvdata[drvdata->cpu] = drvdata;\n\n\tpm_runtime_put(&adev->dev);\n\tdev_info(&drvdata->csdev->dev,\n\t\t \"%s initialized\\n\", (char *)coresight_get_uci_data(id));\n\tif (boot_enable) {\n\t\tcoresight_enable(drvdata->csdev);\n\t\tdrvdata->boot_enable = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void clear_etmdrvdata(void *info)\n{\n\tint cpu = *(int *)info;\n\n\tetmdrvdata[cpu] = NULL;\n}\n\nstatic void etm_remove(struct amba_device *adev)\n{\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(&adev->dev);\n\n\tetm_perf_symlink(drvdata->csdev, false);\n\n\t \n\tcpus_read_lock();\n\t \n\tif (smp_call_function_single(drvdata->cpu, clear_etmdrvdata, &drvdata->cpu, 1))\n\t\tetmdrvdata[drvdata->cpu] = NULL;\n\n\tcpus_read_unlock();\n\n\tcoresight_unregister(drvdata->csdev);\n}\n\n#ifdef CONFIG_PM\nstatic int etm_runtime_suspend(struct device *dev)\n{\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tif (drvdata && !IS_ERR(drvdata->atclk))\n\t\tclk_disable_unprepare(drvdata->atclk);\n\n\treturn 0;\n}\n\nstatic int etm_runtime_resume(struct device *dev)\n{\n\tstruct etm_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tif (drvdata && !IS_ERR(drvdata->atclk))\n\t\tclk_prepare_enable(drvdata->atclk);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops etm_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(etm_runtime_suspend, etm_runtime_resume, NULL)\n};\n\nstatic const struct amba_id etm_ids[] = {\n\t \n\tCS_AMBA_ID_DATA(0x000bb921, \"ETM 3.3\"),\n\t \n\tCS_AMBA_ID_DATA(0x000bb955, \"ETM 3.5\"),\n\t \n\tCS_AMBA_ID_DATA(0x000bb956, \"ETM 3.5\"),\n\t \n\tCS_AMBA_ID_DATA(0x000bb950, \"PTM 1.0\"),\n\t \n\tCS_AMBA_ID_DATA(0x000bb95f, \"PTM 1.1\"),\n\t \n\tCS_AMBA_ID_DATA(0x000b006f, \"PTM 1.1\"),\n\t{ 0, 0},\n};\n\nMODULE_DEVICE_TABLE(amba, etm_ids);\n\nstatic struct amba_driver etm_driver = {\n\t.drv = {\n\t\t.name\t= \"coresight-etm3x\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= &etm_dev_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= etm_probe,\n\t.remove         = etm_remove,\n\t.id_table\t= etm_ids,\n};\n\nstatic int __init etm_init(void)\n{\n\tint ret;\n\n\tret = etm_hp_setup();\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\tret = amba_driver_register(&etm_driver);\n\tif (ret) {\n\t\tpr_err(\"Error registering etm3x driver\\n\");\n\t\tetm_hp_clear();\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit etm_exit(void)\n{\n\tamba_driver_unregister(&etm_driver);\n\tetm_hp_clear();\n}\n\nmodule_init(etm_init);\nmodule_exit(etm_exit);\n\nMODULE_AUTHOR(\"Pratik Patel <pratikp@codeaurora.org>\");\nMODULE_AUTHOR(\"Mathieu Poirier <mathieu.poirier@linaro.org>\");\nMODULE_DESCRIPTION(\"Arm CoreSight Program Flow Trace driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}