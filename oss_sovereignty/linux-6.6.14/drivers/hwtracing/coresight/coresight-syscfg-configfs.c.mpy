{
  "module_name": "coresight-syscfg-configfs.c",
  "hash_id": "51c7276c53e2d3ca27c14b7031dc93d854943abc5617e4a1b82a95db04da205a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-syscfg-configfs.c",
  "human_readable_source": "\n \n\n#include <linux/configfs.h>\n\n#include \"coresight-config.h\"\n#include \"coresight-syscfg-configfs.h\"\n\n \nstatic inline struct config_item_type *cscfg_create_ci_type(void)\n{\n\tstruct config_item_type *ci_type;\n\n\tci_type = devm_kzalloc(cscfg_device(), sizeof(*ci_type), GFP_KERNEL);\n\tif (ci_type)\n\t\tci_type->ct_owner = THIS_MODULE;\n\n\treturn ci_type;\n}\n\n \n\n \nstatic ssize_t cscfg_cfg_description_show(struct config_item *item, char *page)\n{\n\tstruct cscfg_fs_config *fs_config = container_of(to_config_group(item),\n\t\t\t\t\t\t\t struct cscfg_fs_config, group);\n\n\treturn scnprintf(page, PAGE_SIZE, \"%s\", fs_config->config_desc->description);\n}\nCONFIGFS_ATTR_RO(cscfg_cfg_, description);\n\nstatic ssize_t cscfg_cfg_feature_refs_show(struct config_item *item, char *page)\n{\n\tstruct cscfg_fs_config *fs_config = container_of(to_config_group(item),\n\t\t\t\t\t\t\t struct cscfg_fs_config, group);\n\tconst struct cscfg_config_desc *config_desc = fs_config->config_desc;\n\tssize_t ch_used = 0;\n\tint i;\n\n\tfor (i = 0; i < config_desc->nr_feat_refs; i++)\n\t\tch_used += scnprintf(page + ch_used, PAGE_SIZE - ch_used,\n\t\t\t\t     \"%s\\n\", config_desc->feat_ref_names[i]);\n\treturn ch_used;\n}\nCONFIGFS_ATTR_RO(cscfg_cfg_, feature_refs);\n\n \nstatic ssize_t cscfg_cfg_values_show(struct config_item *item, char *page)\n{\n\tconst struct cscfg_feature_desc *feat_desc;\n\tconst struct cscfg_config_desc *config_desc;\n\tstruct cscfg_fs_preset *fs_preset;\n\tint i, j, val_idx, preset_idx;\n\tssize_t used = 0;\n\n\tfs_preset = container_of(to_config_group(item), struct cscfg_fs_preset, group);\n\tconfig_desc = fs_preset->config_desc;\n\n\tif (!config_desc->nr_presets)\n\t\treturn 0;\n\n\tpreset_idx = fs_preset->preset_num - 1;\n\n\t \n\tval_idx = config_desc->nr_total_params * preset_idx;\n\n\t \n\tfor (i = 0; i < config_desc->nr_feat_refs; i++) {\n\t\tfeat_desc = cscfg_get_named_feat_desc(config_desc->feat_ref_names[i]);\n\t\tfor (j = 0; j < feat_desc->nr_params; j++) {\n\t\t\tused += scnprintf(page + used, PAGE_SIZE - used,\n\t\t\t\t\t  \"%s.%s = 0x%llx \",\n\t\t\t\t\t  feat_desc->name,\n\t\t\t\t\t  feat_desc->params_desc[j].name,\n\t\t\t\t\t  config_desc->presets[val_idx++]);\n\t\t}\n\t}\n\tused += scnprintf(page + used, PAGE_SIZE - used, \"\\n\");\n\n\treturn used;\n}\nCONFIGFS_ATTR_RO(cscfg_cfg_, values);\n\nstatic ssize_t cscfg_cfg_enable_show(struct config_item *item, char *page)\n{\n\tstruct cscfg_fs_config *fs_config = container_of(to_config_group(item),\n\t\t\t\t\t\t\t struct cscfg_fs_config, group);\n\n\treturn scnprintf(page, PAGE_SIZE, \"%d\\n\", fs_config->active);\n}\n\nstatic ssize_t cscfg_cfg_enable_store(struct config_item *item,\n\t\t\t\t\tconst char *page, size_t count)\n{\n\tstruct cscfg_fs_config *fs_config = container_of(to_config_group(item),\n\t\t\t\t\t\t\t struct cscfg_fs_config, group);\n\tint err;\n\tbool val;\n\n\terr = kstrtobool(page, &val);\n\tif (!err)\n\t\terr = cscfg_config_sysfs_activate(fs_config->config_desc, val);\n\tif (!err) {\n\t\tfs_config->active = val;\n\t\tif (val)\n\t\t\tcscfg_config_sysfs_set_preset(fs_config->preset);\n\t}\n\treturn err ? err : count;\n}\nCONFIGFS_ATTR(cscfg_cfg_, enable);\n\nstatic ssize_t cscfg_cfg_preset_show(struct config_item *item, char *page)\n{\n\tstruct cscfg_fs_config *fs_config = container_of(to_config_group(item),\n\t\t\t\t\t\t\t struct cscfg_fs_config, group);\n\n\treturn scnprintf(page, PAGE_SIZE, \"%d\\n\", fs_config->preset);\n}\n\nstatic ssize_t cscfg_cfg_preset_store(struct config_item *item,\n\t\t\t\t\t     const char *page, size_t count)\n{\n\tstruct cscfg_fs_config *fs_config = container_of(to_config_group(item),\n\t\t\t\t\t\t\t struct cscfg_fs_config, group);\n\tint preset, err;\n\n\terr = kstrtoint(page, 0, &preset);\n\tif (!err) {\n\t\t \n\t\tif ((preset < 1) || (preset > fs_config->config_desc->nr_presets))\n\t\t\terr = -EINVAL;\n\t}\n\n\tif (!err) {\n\t\t \n\t\tfs_config->preset = preset;\n\t\t \n\t\tif (fs_config->active)\n\t\t\tcscfg_config_sysfs_set_preset(fs_config->preset);\n\t}\n\treturn err ? err : count;\n}\nCONFIGFS_ATTR(cscfg_cfg_, preset);\n\nstatic struct configfs_attribute *cscfg_config_view_attrs[] = {\n\t&cscfg_cfg_attr_description,\n\t&cscfg_cfg_attr_feature_refs,\n\t&cscfg_cfg_attr_enable,\n\t&cscfg_cfg_attr_preset,\n\tNULL,\n};\n\nstatic struct config_item_type cscfg_config_view_type = {\n\t.ct_owner = THIS_MODULE,\n\t.ct_attrs = cscfg_config_view_attrs,\n};\n\nstatic struct configfs_attribute *cscfg_config_preset_attrs[] = {\n\t&cscfg_cfg_attr_values,\n\tNULL,\n};\n\nstatic struct config_item_type cscfg_config_preset_type = {\n\t.ct_owner = THIS_MODULE,\n\t.ct_attrs = cscfg_config_preset_attrs,\n};\n\nstatic int cscfg_add_preset_groups(struct cscfg_fs_config *cfg_view)\n{\n\tint preset_num;\n\tstruct cscfg_fs_preset *cfg_fs_preset;\n\tstruct cscfg_config_desc *config_desc = cfg_view->config_desc;\n\tchar name[CONFIGFS_ITEM_NAME_LEN];\n\n\tif (!config_desc->nr_presets)\n\t\treturn 0;\n\n\tfor (preset_num = 1; preset_num <= config_desc->nr_presets; preset_num++) {\n\t\tcfg_fs_preset = devm_kzalloc(cscfg_device(),\n\t\t\t\t\t     sizeof(struct cscfg_fs_preset), GFP_KERNEL);\n\n\t\tif (!cfg_fs_preset)\n\t\t\treturn -ENOMEM;\n\n\t\tsnprintf(name, CONFIGFS_ITEM_NAME_LEN, \"preset%d\", preset_num);\n\t\tcfg_fs_preset->preset_num = preset_num;\n\t\tcfg_fs_preset->config_desc = cfg_view->config_desc;\n\t\tconfig_group_init_type_name(&cfg_fs_preset->group, name,\n\t\t\t\t\t    &cscfg_config_preset_type);\n\t\tconfigfs_add_default_group(&cfg_fs_preset->group, &cfg_view->group);\n\t}\n\treturn 0;\n}\n\nstatic struct config_group *cscfg_create_config_group(struct cscfg_config_desc *config_desc)\n{\n\tstruct cscfg_fs_config *cfg_view;\n\tstruct device *dev = cscfg_device();\n\tint err;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcfg_view = devm_kzalloc(dev, sizeof(struct cscfg_fs_config), GFP_KERNEL);\n\tif (!cfg_view)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcfg_view->config_desc = config_desc;\n\tconfig_group_init_type_name(&cfg_view->group, config_desc->name, &cscfg_config_view_type);\n\n\t \n\terr = cscfg_add_preset_groups(cfg_view);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn &cfg_view->group;\n}\n\n \n\nstatic ssize_t cscfg_feat_description_show(struct config_item *item, char *page)\n{\n\tstruct cscfg_fs_feature *fs_feat = container_of(to_config_group(item),\n\t\t\t\t\t\t\tstruct cscfg_fs_feature, group);\n\n\treturn scnprintf(page, PAGE_SIZE, \"%s\", fs_feat->feat_desc->description);\n}\nCONFIGFS_ATTR_RO(cscfg_feat_, description);\n\nstatic ssize_t cscfg_feat_matches_show(struct config_item *item, char *page)\n{\n\tstruct cscfg_fs_feature *fs_feat = container_of(to_config_group(item),\n\t\t\t\t\t\t\tstruct cscfg_fs_feature, group);\n\tu32 match_flags = fs_feat->feat_desc->match_flags;\n\tint used = 0;\n\n\tif (match_flags & CS_CFG_MATCH_CLASS_SRC_ALL)\n\t\tused = scnprintf(page, PAGE_SIZE, \"SRC_ALL \");\n\n\tif (match_flags & CS_CFG_MATCH_CLASS_SRC_ETM4)\n\t\tused += scnprintf(page + used, PAGE_SIZE - used, \"SRC_ETMV4 \");\n\n\tused += scnprintf(page + used, PAGE_SIZE - used, \"\\n\");\n\treturn used;\n}\nCONFIGFS_ATTR_RO(cscfg_feat_, matches);\n\nstatic ssize_t cscfg_feat_nr_params_show(struct config_item *item, char *page)\n{\n\tstruct cscfg_fs_feature *fs_feat = container_of(to_config_group(item),\n\t\t\t\t\t\t\tstruct cscfg_fs_feature, group);\n\n\treturn scnprintf(page, PAGE_SIZE, \"%d\\n\", fs_feat->feat_desc->nr_params);\n}\nCONFIGFS_ATTR_RO(cscfg_feat_, nr_params);\n\n \nstatic struct configfs_attribute *cscfg_feature_view_attrs[] = {\n\t&cscfg_feat_attr_description,\n\t&cscfg_feat_attr_matches,\n\t&cscfg_feat_attr_nr_params,\n\tNULL,\n};\n\nstatic struct config_item_type cscfg_feature_view_type = {\n\t.ct_owner = THIS_MODULE,\n\t.ct_attrs = cscfg_feature_view_attrs,\n};\n\nstatic ssize_t cscfg_param_value_show(struct config_item *item, char *page)\n{\n\tstruct cscfg_fs_param *param_item = container_of(to_config_group(item),\n\t\t\t\t\t\t\t struct cscfg_fs_param, group);\n\tu64 value = param_item->feat_desc->params_desc[param_item->param_idx].value;\n\n\treturn scnprintf(page, PAGE_SIZE, \"0x%llx\\n\", value);\n}\n\nstatic ssize_t cscfg_param_value_store(struct config_item *item,\n\t\t\t\t       const char *page, size_t size)\n{\n\tstruct cscfg_fs_param *param_item = container_of(to_config_group(item),\n\t\t\t\t\t\t\t struct cscfg_fs_param, group);\n\tstruct cscfg_feature_desc *feat_desc = param_item->feat_desc;\n\tint param_idx = param_item->param_idx;\n\tu64 value;\n\tint err;\n\n\terr = kstrtoull(page, 0, &value);\n\tif (!err)\n\t\terr = cscfg_update_feat_param_val(feat_desc, param_idx, value);\n\n\treturn err ? err : size;\n}\nCONFIGFS_ATTR(cscfg_param_, value);\n\nstatic struct configfs_attribute *cscfg_param_view_attrs[] = {\n\t&cscfg_param_attr_value,\n\tNULL,\n};\n\nstatic struct config_item_type cscfg_param_view_type = {\n\t.ct_owner = THIS_MODULE,\n\t.ct_attrs = cscfg_param_view_attrs,\n};\n\n \nstatic int cscfg_create_params_group_items(struct cscfg_feature_desc *feat_desc,\n\t\t\t\t\t   struct config_group *params_group)\n{\n\tstruct device *dev = cscfg_device();\n\tstruct cscfg_fs_param *param_item;\n\tint i;\n\n\t \n\tfor (i = 0; i < feat_desc->nr_params; i++) {\n\t\tparam_item = devm_kzalloc(dev, sizeof(struct cscfg_fs_param), GFP_KERNEL);\n\t\tif (!param_item)\n\t\t\treturn -ENOMEM;\n\t\tparam_item->feat_desc = feat_desc;\n\t\tparam_item->param_idx = i;\n\t\tconfig_group_init_type_name(&param_item->group,\n\t\t\t\t\t    feat_desc->params_desc[i].name,\n\t\t\t\t\t    &cscfg_param_view_type);\n\t\tconfigfs_add_default_group(&param_item->group, params_group);\n\t}\n\treturn 0;\n}\n\nstatic struct config_group *cscfg_create_feature_group(struct cscfg_feature_desc *feat_desc)\n{\n\tstruct cscfg_fs_feature *feat_view;\n\tstruct config_item_type *params_group_type;\n\tstruct config_group *params_group = NULL;\n\tstruct device *dev = cscfg_device();\n\tint item_err;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfeat_view = devm_kzalloc(dev, sizeof(struct cscfg_fs_feature), GFP_KERNEL);\n\tif (!feat_view)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (feat_desc->nr_params) {\n\t\tparams_group = devm_kzalloc(dev, sizeof(struct config_group), GFP_KERNEL);\n\t\tif (!params_group)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tparams_group_type = cscfg_create_ci_type();\n\t\tif (!params_group_type)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfeat_view->feat_desc = feat_desc;\n\tconfig_group_init_type_name(&feat_view->group,\n\t\t\t\t    feat_desc->name,\n\t\t\t\t    &cscfg_feature_view_type);\n\tif (params_group) {\n\t\tconfig_group_init_type_name(params_group, \"params\", params_group_type);\n\t\tconfigfs_add_default_group(params_group, &feat_view->group);\n\t\titem_err = cscfg_create_params_group_items(feat_desc, params_group);\n\t\tif (item_err)\n\t\t\treturn ERR_PTR(item_err);\n\t}\n\treturn &feat_view->group;\n}\n\nstatic struct config_item_type cscfg_configs_type = {\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic struct config_group cscfg_configs_grp = {\n\t.cg_item = {\n\t\t.ci_namebuf = \"configurations\",\n\t\t.ci_type = &cscfg_configs_type,\n\t},\n};\n\n \nint cscfg_configfs_add_config(struct cscfg_config_desc *config_desc)\n{\n\tstruct config_group *new_group;\n\tint err;\n\n\tnew_group = cscfg_create_config_group(config_desc);\n\tif (IS_ERR(new_group))\n\t\treturn PTR_ERR(new_group);\n\terr =  configfs_register_group(&cscfg_configs_grp, new_group);\n\tif (!err)\n\t\tconfig_desc->fs_group = new_group;\n\treturn err;\n}\n\nvoid cscfg_configfs_del_config(struct cscfg_config_desc *config_desc)\n{\n\tif (config_desc->fs_group) {\n\t\tconfigfs_unregister_group(config_desc->fs_group);\n\t\tconfig_desc->fs_group = NULL;\n\t}\n}\n\nstatic struct config_item_type cscfg_features_type = {\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic struct config_group cscfg_features_grp = {\n\t.cg_item = {\n\t\t.ci_namebuf = \"features\",\n\t\t.ci_type = &cscfg_features_type,\n\t},\n};\n\n \nint cscfg_configfs_add_feature(struct cscfg_feature_desc *feat_desc)\n{\n\tstruct config_group *new_group;\n\tint err;\n\n\tnew_group = cscfg_create_feature_group(feat_desc);\n\tif (IS_ERR(new_group))\n\t\treturn PTR_ERR(new_group);\n\terr =  configfs_register_group(&cscfg_features_grp, new_group);\n\tif (!err)\n\t\tfeat_desc->fs_group = new_group;\n\treturn err;\n}\n\nvoid cscfg_configfs_del_feature(struct cscfg_feature_desc *feat_desc)\n{\n\tif (feat_desc->fs_group) {\n\t\tconfigfs_unregister_group(feat_desc->fs_group);\n\t\tfeat_desc->fs_group = NULL;\n\t}\n}\n\nint cscfg_configfs_init(struct cscfg_manager *cscfg_mgr)\n{\n\tstruct configfs_subsystem *subsys;\n\tstruct config_item_type *ci_type;\n\n\tif (!cscfg_mgr)\n\t\treturn -EINVAL;\n\n\tci_type = cscfg_create_ci_type();\n\tif (!ci_type)\n\t\treturn -ENOMEM;\n\n\tsubsys = &cscfg_mgr->cfgfs_subsys;\n\tconfig_item_set_name(&subsys->su_group.cg_item, CSCFG_FS_SUBSYS_NAME);\n\tsubsys->su_group.cg_item.ci_type = ci_type;\n\n\tconfig_group_init(&subsys->su_group);\n\tmutex_init(&subsys->su_mutex);\n\n\t \n\tconfig_group_init(&cscfg_configs_grp);\n\tconfigfs_add_default_group(&cscfg_configs_grp, &subsys->su_group);\n\n\tconfig_group_init(&cscfg_features_grp);\n\tconfigfs_add_default_group(&cscfg_features_grp, &subsys->su_group);\n\n\treturn configfs_register_subsystem(subsys);\n}\n\nvoid cscfg_configfs_release(struct cscfg_manager *cscfg_mgr)\n{\n\tconfigfs_unregister_subsystem(&cscfg_mgr->cfgfs_subsys);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}