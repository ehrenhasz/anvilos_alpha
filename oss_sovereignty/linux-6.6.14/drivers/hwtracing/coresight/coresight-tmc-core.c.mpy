{
  "module_name": "coresight-tmc-core.c",
  "hash_id": "0603efed2d37ec62ee83e89cca9a0f096c0f91a36b7a3dc463db47a3a4a8ea9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-tmc-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/idr.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/spinlock.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/coresight.h>\n#include <linux/amba/bus.h>\n\n#include \"coresight-priv.h\"\n#include \"coresight-tmc.h\"\n\nDEFINE_CORESIGHT_DEVLIST(etb_devs, \"tmc_etb\");\nDEFINE_CORESIGHT_DEVLIST(etf_devs, \"tmc_etf\");\nDEFINE_CORESIGHT_DEVLIST(etr_devs, \"tmc_etr\");\n\nint tmc_wait_for_tmcready(struct tmc_drvdata *drvdata)\n{\n\tstruct coresight_device *csdev = drvdata->csdev;\n\tstruct csdev_access *csa = &csdev->access;\n\n\t \n\tif (coresight_timeout(csa, TMC_STS, TMC_STS_TMCREADY_BIT, 1)) {\n\t\tdev_err(&csdev->dev,\n\t\t\t\"timeout while waiting for TMC to be Ready\\n\");\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nvoid tmc_flush_and_stop(struct tmc_drvdata *drvdata)\n{\n\tstruct coresight_device *csdev = drvdata->csdev;\n\tstruct csdev_access *csa = &csdev->access;\n\tu32 ffcr;\n\n\tffcr = readl_relaxed(drvdata->base + TMC_FFCR);\n\tffcr |= TMC_FFCR_STOP_ON_FLUSH;\n\twritel_relaxed(ffcr, drvdata->base + TMC_FFCR);\n\tffcr |= BIT(TMC_FFCR_FLUSHMAN_BIT);\n\twritel_relaxed(ffcr, drvdata->base + TMC_FFCR);\n\t \n\tif (coresight_timeout(csa, TMC_FFCR, TMC_FFCR_FLUSHMAN_BIT, 0)) {\n\t\tdev_err(&csdev->dev,\n\t\t\"timeout while waiting for completion of Manual Flush\\n\");\n\t}\n\n\ttmc_wait_for_tmcready(drvdata);\n}\n\nvoid tmc_enable_hw(struct tmc_drvdata *drvdata)\n{\n\twritel_relaxed(TMC_CTL_CAPT_EN, drvdata->base + TMC_CTL);\n}\n\nvoid tmc_disable_hw(struct tmc_drvdata *drvdata)\n{\n\twritel_relaxed(0x0, drvdata->base + TMC_CTL);\n}\n\nu32 tmc_get_memwidth_mask(struct tmc_drvdata *drvdata)\n{\n\tu32 mask = 0;\n\n\t \n\tswitch (drvdata->memwidth) {\n\tcase TMC_MEM_INTF_WIDTH_32BITS:\n\tcase TMC_MEM_INTF_WIDTH_64BITS:\n\tcase TMC_MEM_INTF_WIDTH_128BITS:\n\t\tmask = GENMASK(31, 4);\n\t\tbreak;\n\tcase TMC_MEM_INTF_WIDTH_256BITS:\n\t\tmask = GENMASK(31, 5);\n\t\tbreak;\n\t}\n\n\treturn mask;\n}\n\nstatic int tmc_read_prepare(struct tmc_drvdata *drvdata)\n{\n\tint ret = 0;\n\n\tswitch (drvdata->config_type) {\n\tcase TMC_CONFIG_TYPE_ETB:\n\tcase TMC_CONFIG_TYPE_ETF:\n\t\tret = tmc_read_prepare_etb(drvdata);\n\t\tbreak;\n\tcase TMC_CONFIG_TYPE_ETR:\n\t\tret = tmc_read_prepare_etr(drvdata);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (!ret)\n\t\tdev_dbg(&drvdata->csdev->dev, \"TMC read start\\n\");\n\n\treturn ret;\n}\n\nstatic int tmc_read_unprepare(struct tmc_drvdata *drvdata)\n{\n\tint ret = 0;\n\n\tswitch (drvdata->config_type) {\n\tcase TMC_CONFIG_TYPE_ETB:\n\tcase TMC_CONFIG_TYPE_ETF:\n\t\tret = tmc_read_unprepare_etb(drvdata);\n\t\tbreak;\n\tcase TMC_CONFIG_TYPE_ETR:\n\t\tret = tmc_read_unprepare_etr(drvdata);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (!ret)\n\t\tdev_dbg(&drvdata->csdev->dev, \"TMC read end\\n\");\n\n\treturn ret;\n}\n\nstatic int tmc_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct tmc_drvdata *drvdata = container_of(file->private_data,\n\t\t\t\t\t\t   struct tmc_drvdata, miscdev);\n\n\tret = tmc_read_prepare(drvdata);\n\tif (ret)\n\t\treturn ret;\n\n\tnonseekable_open(inode, file);\n\n\tdev_dbg(&drvdata->csdev->dev, \"%s: successfully opened\\n\", __func__);\n\treturn 0;\n}\n\nstatic inline ssize_t tmc_get_sysfs_trace(struct tmc_drvdata *drvdata,\n\t\t\t\t\t  loff_t pos, size_t len, char **bufpp)\n{\n\tswitch (drvdata->config_type) {\n\tcase TMC_CONFIG_TYPE_ETB:\n\tcase TMC_CONFIG_TYPE_ETF:\n\t\treturn tmc_etb_get_sysfs_trace(drvdata, pos, len, bufpp);\n\tcase TMC_CONFIG_TYPE_ETR:\n\t\treturn tmc_etr_get_sysfs_trace(drvdata, pos, len, bufpp);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t tmc_read(struct file *file, char __user *data, size_t len,\n\t\t\tloff_t *ppos)\n{\n\tchar *bufp;\n\tssize_t actual;\n\tstruct tmc_drvdata *drvdata = container_of(file->private_data,\n\t\t\t\t\t\t   struct tmc_drvdata, miscdev);\n\tactual = tmc_get_sysfs_trace(drvdata, *ppos, len, &bufp);\n\tif (actual <= 0)\n\t\treturn 0;\n\n\tif (copy_to_user(data, bufp, actual)) {\n\t\tdev_dbg(&drvdata->csdev->dev,\n\t\t\t\"%s: copy_to_user failed\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\t*ppos += actual;\n\tdev_dbg(&drvdata->csdev->dev, \"%zu bytes copied\\n\", actual);\n\n\treturn actual;\n}\n\nstatic int tmc_release(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct tmc_drvdata *drvdata = container_of(file->private_data,\n\t\t\t\t\t\t   struct tmc_drvdata, miscdev);\n\n\tret = tmc_read_unprepare(drvdata);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(&drvdata->csdev->dev, \"%s: released\\n\", __func__);\n\treturn 0;\n}\n\nstatic const struct file_operations tmc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= tmc_open,\n\t.read\t\t= tmc_read,\n\t.release\t= tmc_release,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic enum tmc_mem_intf_width tmc_get_memwidth(u32 devid)\n{\n\tenum tmc_mem_intf_width memwidth;\n\n\t \n\tswitch (BMVAL(devid, 8, 10)) {\n\tcase 0x2:\n\t\tmemwidth = TMC_MEM_INTF_WIDTH_32BITS;\n\t\tbreak;\n\tcase 0x3:\n\t\tmemwidth = TMC_MEM_INTF_WIDTH_64BITS;\n\t\tbreak;\n\tcase 0x4:\n\t\tmemwidth = TMC_MEM_INTF_WIDTH_128BITS;\n\t\tbreak;\n\tcase 0x5:\n\t\tmemwidth = TMC_MEM_INTF_WIDTH_256BITS;\n\t\tbreak;\n\tdefault:\n\t\tmemwidth = 0;\n\t}\n\n\treturn memwidth;\n}\n\nstatic struct attribute *coresight_tmc_mgmt_attrs[] = {\n\tcoresight_simple_reg32(rsz, TMC_RSZ),\n\tcoresight_simple_reg32(sts, TMC_STS),\n\tcoresight_simple_reg64(rrp, TMC_RRP, TMC_RRPHI),\n\tcoresight_simple_reg64(rwp, TMC_RWP, TMC_RWPHI),\n\tcoresight_simple_reg32(trg, TMC_TRG),\n\tcoresight_simple_reg32(ctl, TMC_CTL),\n\tcoresight_simple_reg32(ffsr, TMC_FFSR),\n\tcoresight_simple_reg32(ffcr, TMC_FFCR),\n\tcoresight_simple_reg32(mode, TMC_MODE),\n\tcoresight_simple_reg32(pscr, TMC_PSCR),\n\tcoresight_simple_reg32(devid, CORESIGHT_DEVID),\n\tcoresight_simple_reg64(dba, TMC_DBALO, TMC_DBAHI),\n\tcoresight_simple_reg32(axictl, TMC_AXICTL),\n\tcoresight_simple_reg32(authstatus, TMC_AUTHSTATUS),\n\tNULL,\n};\n\nstatic ssize_t trigger_cntr_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct tmc_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tunsigned long val = drvdata->trigger_cntr;\n\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t trigger_cntr_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct tmc_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tdrvdata->trigger_cntr = val;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(trigger_cntr);\n\nstatic ssize_t buffer_size_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct tmc_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\treturn sprintf(buf, \"%#x\\n\", drvdata->size);\n}\n\nstatic ssize_t buffer_size_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct tmc_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\t \n\tif (drvdata->config_type != TMC_CONFIG_TYPE_ETR)\n\t\treturn -EPERM;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (val & (PAGE_SIZE - 1))\n\t\treturn -EINVAL;\n\tdrvdata->size = val;\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(buffer_size);\n\nstatic struct attribute *coresight_tmc_attrs[] = {\n\t&dev_attr_trigger_cntr.attr,\n\t&dev_attr_buffer_size.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group coresight_tmc_group = {\n\t.attrs = coresight_tmc_attrs,\n};\n\nstatic const struct attribute_group coresight_tmc_mgmt_group = {\n\t.attrs = coresight_tmc_mgmt_attrs,\n\t.name = \"mgmt\",\n};\n\nstatic const struct attribute_group *coresight_tmc_groups[] = {\n\t&coresight_tmc_group,\n\t&coresight_tmc_mgmt_group,\n\tNULL,\n};\n\nstatic inline bool tmc_etr_can_use_sg(struct device *dev)\n{\n\treturn fwnode_property_present(dev->fwnode, \"arm,scatter-gather\");\n}\n\nstatic inline bool tmc_etr_has_non_secure_access(struct tmc_drvdata *drvdata)\n{\n\tu32 auth = readl_relaxed(drvdata->base + TMC_AUTHSTATUS);\n\n\treturn (auth & TMC_AUTH_NSID_MASK) == 0x3;\n}\n\n \nstatic int tmc_etr_setup_caps(struct device *parent, u32 devid, void *dev_caps)\n{\n\tint rc;\n\tu32 dma_mask = 0;\n\tstruct tmc_drvdata *drvdata = dev_get_drvdata(parent);\n\n\tif (!tmc_etr_has_non_secure_access(drvdata))\n\t\treturn -EACCES;\n\n\t \n\ttmc_etr_init_caps(drvdata, (u32)(unsigned long)dev_caps);\n\n\tif (!(devid & TMC_DEVID_NOSCAT) && tmc_etr_can_use_sg(parent))\n\t\ttmc_etr_set_cap(drvdata, TMC_ETR_SG);\n\n\t \n\tif (devid & TMC_DEVID_AXIAW_VALID)\n\t\tdma_mask = ((devid >> TMC_DEVID_AXIAW_SHIFT) &\n\t\t\t\tTMC_DEVID_AXIAW_MASK);\n\n\t \n\tswitch (dma_mask) {\n\tcase 32:\n\tcase 40:\n\tcase 44:\n\tcase 48:\n\tcase 52:\n\t\tdev_info(parent, \"Detected dma mask %dbits\\n\", dma_mask);\n\t\tbreak;\n\tdefault:\n\t\tdma_mask = 40;\n\t}\n\n\trc = dma_set_mask_and_coherent(parent, DMA_BIT_MASK(dma_mask));\n\tif (rc)\n\t\tdev_err(parent, \"Failed to setup DMA mask: %d\\n\", rc);\n\treturn rc;\n}\n\nstatic u32 tmc_etr_get_default_buffer_size(struct device *dev)\n{\n\tu32 size;\n\n\tif (fwnode_property_read_u32(dev->fwnode, \"arm,buffer-size\", &size))\n\t\tsize = SZ_1M;\n\treturn size;\n}\n\nstatic u32 tmc_etr_get_max_burst_size(struct device *dev)\n{\n\tu32 burst_size;\n\n\tif (fwnode_property_read_u32(dev->fwnode, \"arm,max-burst-size\",\n\t\t\t\t     &burst_size))\n\t\treturn TMC_AXICTL_WR_BURST_16;\n\n\t \n\tif (burst_size > 0xF)\n\t\tburst_size = TMC_AXICTL_WR_BURST_16;\n\n\treturn burst_size;\n}\n\nstatic int tmc_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tint ret = 0;\n\tu32 devid;\n\tvoid __iomem *base;\n\tstruct device *dev = &adev->dev;\n\tstruct coresight_platform_data *pdata = NULL;\n\tstruct tmc_drvdata *drvdata;\n\tstruct resource *res = &adev->res;\n\tstruct coresight_desc desc = { 0 };\n\tstruct coresight_dev_list *dev_list = NULL;\n\n\tret = -ENOMEM;\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\tgoto out;\n\n\tdev_set_drvdata(dev, drvdata);\n\n\t \n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base)) {\n\t\tret = PTR_ERR(base);\n\t\tgoto out;\n\t}\n\n\tdrvdata->base = base;\n\tdesc.access = CSDEV_ACCESS_IOMEM(base);\n\n\tspin_lock_init(&drvdata->spinlock);\n\n\tdevid = readl_relaxed(drvdata->base + CORESIGHT_DEVID);\n\tdrvdata->config_type = BMVAL(devid, 6, 7);\n\tdrvdata->memwidth = tmc_get_memwidth(devid);\n\t \n\tdrvdata->pid = -1;\n\n\tif (drvdata->config_type == TMC_CONFIG_TYPE_ETR) {\n\t\tdrvdata->size = tmc_etr_get_default_buffer_size(dev);\n\t\tdrvdata->max_burst_size = tmc_etr_get_max_burst_size(dev);\n\t} else {\n\t\tdrvdata->size = readl_relaxed(drvdata->base + TMC_RSZ) * 4;\n\t}\n\n\tdesc.dev = dev;\n\tdesc.groups = coresight_tmc_groups;\n\n\tswitch (drvdata->config_type) {\n\tcase TMC_CONFIG_TYPE_ETB:\n\t\tdesc.type = CORESIGHT_DEV_TYPE_SINK;\n\t\tdesc.subtype.sink_subtype = CORESIGHT_DEV_SUBTYPE_SINK_BUFFER;\n\t\tdesc.ops = &tmc_etb_cs_ops;\n\t\tdev_list = &etb_devs;\n\t\tbreak;\n\tcase TMC_CONFIG_TYPE_ETR:\n\t\tdesc.type = CORESIGHT_DEV_TYPE_SINK;\n\t\tdesc.subtype.sink_subtype = CORESIGHT_DEV_SUBTYPE_SINK_SYSMEM;\n\t\tdesc.ops = &tmc_etr_cs_ops;\n\t\tret = tmc_etr_setup_caps(dev, devid,\n\t\t\t\t\t coresight_get_uci_data(id));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tidr_init(&drvdata->idr);\n\t\tmutex_init(&drvdata->idr_mutex);\n\t\tdev_list = &etr_devs;\n\t\tbreak;\n\tcase TMC_CONFIG_TYPE_ETF:\n\t\tdesc.type = CORESIGHT_DEV_TYPE_LINKSINK;\n\t\tdesc.subtype.sink_subtype = CORESIGHT_DEV_SUBTYPE_SINK_BUFFER;\n\t\tdesc.subtype.link_subtype = CORESIGHT_DEV_SUBTYPE_LINK_FIFO;\n\t\tdesc.ops = &tmc_etf_cs_ops;\n\t\tdev_list = &etf_devs;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: Unsupported TMC config\\n\", desc.name);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdesc.name = coresight_alloc_device_name(dev_list, dev);\n\tif (!desc.name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpdata = coresight_get_platform_data(dev);\n\tif (IS_ERR(pdata)) {\n\t\tret = PTR_ERR(pdata);\n\t\tgoto out;\n\t}\n\tadev->dev.platform_data = pdata;\n\tdesc.pdata = pdata;\n\n\tdrvdata->csdev = coresight_register(&desc);\n\tif (IS_ERR(drvdata->csdev)) {\n\t\tret = PTR_ERR(drvdata->csdev);\n\t\tgoto out;\n\t}\n\n\tdrvdata->miscdev.name = desc.name;\n\tdrvdata->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tdrvdata->miscdev.fops = &tmc_fops;\n\tret = misc_register(&drvdata->miscdev);\n\tif (ret)\n\t\tcoresight_unregister(drvdata->csdev);\n\telse\n\t\tpm_runtime_put(&adev->dev);\nout:\n\treturn ret;\n}\n\nstatic void tmc_shutdown(struct amba_device *adev)\n{\n\tunsigned long flags;\n\tstruct tmc_drvdata *drvdata = amba_get_drvdata(adev);\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\n\tif (drvdata->mode == CS_MODE_DISABLED)\n\t\tgoto out;\n\n\tif (drvdata->config_type == TMC_CONFIG_TYPE_ETR)\n\t\ttmc_etr_disable_hw(drvdata);\n\n\t \nout:\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n}\n\nstatic void tmc_remove(struct amba_device *adev)\n{\n\tstruct tmc_drvdata *drvdata = dev_get_drvdata(&adev->dev);\n\n\t \n\tmisc_deregister(&drvdata->miscdev);\n\tcoresight_unregister(drvdata->csdev);\n}\n\nstatic const struct amba_id tmc_ids[] = {\n\tCS_AMBA_ID(0x000bb961),\n\t \n\tCS_AMBA_ID_DATA(0x000bb9e8, (unsigned long)CORESIGHT_SOC_600_ETR_CAPS),\n\t \n\tCS_AMBA_ID(0x000bb9e9),\n\t \n\tCS_AMBA_ID(0x000bb9ea),\n\t{ 0, 0},\n};\n\nMODULE_DEVICE_TABLE(amba, tmc_ids);\n\nstatic struct amba_driver tmc_driver = {\n\t.drv = {\n\t\t.name   = \"coresight-tmc\",\n\t\t.owner  = THIS_MODULE,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= tmc_probe,\n\t.shutdown\t= tmc_shutdown,\n\t.remove\t\t= tmc_remove,\n\t.id_table\t= tmc_ids,\n};\n\nmodule_amba_driver(tmc_driver);\n\nMODULE_AUTHOR(\"Pratik Patel <pratikp@codeaurora.org>\");\nMODULE_DESCRIPTION(\"Arm CoreSight Trace Memory Controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}