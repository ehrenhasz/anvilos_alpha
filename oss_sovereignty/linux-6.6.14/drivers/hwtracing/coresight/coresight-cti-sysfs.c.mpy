{
  "module_name": "coresight-cti-sysfs.c",
  "hash_id": "aca6548292e32b69e85a7cc0ad2d7bafa3869a9ca659673ddce117c557e04e9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-cti-sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/coresight.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/sysfs.h>\n\n#include \"coresight-cti.h\"\n\n \n#define CORESIGHT_CTI_STATIC_GROUPS_MAX 5\n\n \nstatic const char * const sig_type_names[] = {\n\t\"genio\",\t \n\t\"intreq\",\t \n\t\"intack\",\t \n\t\"haltreq\",\t \n\t\"restartreq\",\t \n\t\"pe_edbgreq\",\t \n\t\"pe_dbgrestart\", \n\t\"pe_ctiirq\",\t \n\t\"pe_pmuirq\",\t \n\t\"pe_dbgtrigger\", \n\t\"etm_extout\",\t \n\t\"etm_extin\",\t \n\t\"snk_full\",\t \n\t\"snk_acqcomp\",\t \n\t\"snk_flushcomp\", \n\t\"snk_flushin\",\t \n\t\"snk_trigin\",\t \n\t\"stm_asyncout\",\t \n\t\"stm_tout_spte\", \n\t\"stm_tout_sw\",\t \n\t\"stm_tout_hete\", \n\t\"stm_hwevent\",\t \n\t\"ela_tstart\",\t \n\t\"ela_tstop\",\t \n\t\"ela_dbgreq\",\t \n};\n\n \ntypedef ssize_t (*p_show_fn)(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf);\n\n \nenum cti_conn_attr_type {\n\tCTI_CON_ATTR_NAME,\n\tCTI_CON_ATTR_TRIGIN_SIG,\n\tCTI_CON_ATTR_TRIGOUT_SIG,\n\tCTI_CON_ATTR_TRIGIN_TYPES,\n\tCTI_CON_ATTR_TRIGOUT_TYPES,\n\tCTI_CON_ATTR_MAX,\n};\n\n \nstatic const char * const con_attr_names[CTI_CON_ATTR_MAX] = {\n\t\"name\",\n\t\"in_signals\",\n\t\"out_signals\",\n\t\"in_types\",\n\t\"out_types\",\n};\n\n \nstatic ssize_t enable_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint enable_req;\n\tbool enabled, powered;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tspin_lock(&drvdata->spinlock);\n\tenable_req = drvdata->config.enable_req_count;\n\tpowered = drvdata->config.hw_powered;\n\tenabled = drvdata->config.hw_enabled;\n\tspin_unlock(&drvdata->spinlock);\n\n\tif (powered)\n\t\treturn sprintf(buf, \"%d\\n\", enabled);\n\telse\n\t\treturn sprintf(buf, \"%d\\n\", !!enable_req);\n}\n\nstatic ssize_t enable_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t size)\n{\n\tint ret = 0;\n\tunsigned long val;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val) {\n\t\tret = pm_runtime_resume_and_get(dev->parent);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = cti_enable(drvdata->csdev, CS_MODE_SYSFS, NULL);\n\t\tif (ret)\n\t\t\tpm_runtime_put(dev->parent);\n\t} else {\n\t\tret = cti_disable(drvdata->csdev, NULL);\n\t\tif (!ret)\n\t\t\tpm_runtime_put(dev->parent);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(enable);\n\nstatic ssize_t powered_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tbool powered;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tspin_lock(&drvdata->spinlock);\n\tpowered = drvdata->config.hw_powered;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn sprintf(buf, \"%d\\n\", powered);\n}\nstatic DEVICE_ATTR_RO(powered);\n\nstatic ssize_t ctmid_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\treturn sprintf(buf, \"%d\\n\", drvdata->ctidev.ctm_id);\n}\nstatic DEVICE_ATTR_RO(ctmid);\n\nstatic ssize_t nr_trigger_cons_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\treturn sprintf(buf, \"%d\\n\", drvdata->ctidev.nr_trig_con);\n}\nstatic DEVICE_ATTR_RO(nr_trigger_cons);\n\n \nstatic struct attribute *coresight_cti_attrs[] = {\n\t&dev_attr_enable.attr,\n\t&dev_attr_powered.attr,\n\t&dev_attr_ctmid.attr,\n\t&dev_attr_nr_trigger_cons.attr,\n\tNULL,\n};\n\n \n\n \nstatic ssize_t coresight_cti_reg_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cs_off_attribute *cti_attr = container_of(attr, struct cs_off_attribute, attr);\n\tu32 val = 0;\n\n\tpm_runtime_get_sync(dev->parent);\n\tspin_lock(&drvdata->spinlock);\n\tif (drvdata->config.hw_powered)\n\t\tval = readl_relaxed(drvdata->base + cti_attr->off);\n\tspin_unlock(&drvdata->spinlock);\n\tpm_runtime_put_sync(dev->parent);\n\treturn sysfs_emit(buf, \"0x%x\\n\", val);\n}\n\n \nstatic __maybe_unused ssize_t coresight_cti_reg_store(struct device *dev,\n\t\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t\t      const char *buf, size_t size)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cs_off_attribute *cti_attr = container_of(attr, struct cs_off_attribute, attr);\n\tunsigned long val = 0;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tpm_runtime_get_sync(dev->parent);\n\tspin_lock(&drvdata->spinlock);\n\tif (drvdata->config.hw_powered)\n\t\tcti_write_single_reg(drvdata, cti_attr->off, val);\n\tspin_unlock(&drvdata->spinlock);\n\tpm_runtime_put_sync(dev->parent);\n\treturn size;\n}\n\n#define coresight_cti_reg(name, offset)\t\t\t\t\t\\\n\t(&((struct cs_off_attribute[]) {\t\t\t\t\\\n\t   {\t\t\t\t\t\t\t\t\\\n\t\t__ATTR(name, 0444, coresight_cti_reg_show, NULL),\t\\\n\t\toffset\t\t\t\t\t\t\t\\\n\t   }\t\t\t\t\t\t\t\t\\\n\t})[0].attr.attr)\n\n#define coresight_cti_reg_rw(name, offset)\t\t\t\t\\\n\t(&((struct cs_off_attribute[]) {\t\t\t\t\\\n\t   {\t\t\t\t\t\t\t\t\\\n\t\t__ATTR(name, 0644, coresight_cti_reg_show,\t\t\\\n\t\t       coresight_cti_reg_store),\t\t\t\\\n\t\toffset\t\t\t\t\t\t\t\\\n\t   }\t\t\t\t\t\t\t\t\\\n\t})[0].attr.attr)\n\n#define coresight_cti_reg_wo(name, offset)\t\t\t\t\\\n\t(&((struct cs_off_attribute[]) {\t\t\t\t\\\n\t   {\t\t\t\t\t\t\t\t\\\n\t\t__ATTR(name, 0200, NULL, coresight_cti_reg_store),\t\\\n\t\toffset\t\t\t\t\t\t\t\\\n\t   }\t\t\t\t\t\t\t\t\\\n\t})[0].attr.attr)\n\n \nstatic struct attribute *coresight_cti_mgmt_attrs[] = {\n\tcoresight_cti_reg(devaff0, CTIDEVAFF0),\n\tcoresight_cti_reg(devaff1, CTIDEVAFF1),\n\tcoresight_cti_reg(authstatus, CORESIGHT_AUTHSTATUS),\n\tcoresight_cti_reg(devarch, CORESIGHT_DEVARCH),\n\tcoresight_cti_reg(devid, CORESIGHT_DEVID),\n\tcoresight_cti_reg(devtype, CORESIGHT_DEVTYPE),\n\tcoresight_cti_reg(pidr0, CORESIGHT_PERIPHIDR0),\n\tcoresight_cti_reg(pidr1, CORESIGHT_PERIPHIDR1),\n\tcoresight_cti_reg(pidr2, CORESIGHT_PERIPHIDR2),\n\tcoresight_cti_reg(pidr3, CORESIGHT_PERIPHIDR3),\n\tcoresight_cti_reg(pidr4, CORESIGHT_PERIPHIDR4),\n\tNULL,\n};\n\n \n\n \nstatic ssize_t cti_reg32_show(struct device *dev, char *buf,\n\t\t\t      u32 *pcached_val, int reg_offset)\n{\n\tu32 val = 0;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tif ((reg_offset >= 0) && cti_active(config)) {\n\t\tCS_UNLOCK(drvdata->base);\n\t\tval = readl_relaxed(drvdata->base + reg_offset);\n\t\tif (pcached_val)\n\t\t\t*pcached_val = val;\n\t\tCS_LOCK(drvdata->base);\n\t} else if (pcached_val) {\n\t\tval = *pcached_val;\n\t}\n\tspin_unlock(&drvdata->spinlock);\n\treturn sprintf(buf, \"%#x\\n\", val);\n}\n\n \nstatic ssize_t cti_reg32_store(struct device *dev, const char *buf,\n\t\t\t       size_t size, u32 *pcached_val, int reg_offset)\n{\n\tunsigned long val;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\t \n\tif (pcached_val)\n\t\t*pcached_val = (u32)val;\n\n\t \n\tif ((reg_offset >= 0) && cti_active(config))\n\t\tcti_write_single_reg(drvdata, reg_offset, val);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\n\n \n#define cti_config_reg32_rw(name, cfgname, offset)\t\t\t\\\nstatic ssize_t name##_show(struct device *dev,\t\t\t\t\\\n\t\t\t   struct device_attribute *attr,\t\t\\\n\t\t\t   char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\t\\\n\treturn cti_reg32_show(dev, buf,\t\t\t\t\t\\\n\t\t\t      &drvdata->config.cfgname, offset);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t name##_store(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    const char *buf, size_t size)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\t\\\n\treturn cti_reg32_store(dev, buf, size,\t\t\t\t\\\n\t\t\t       &drvdata->config.cfgname, offset);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RW(name)\n\nstatic ssize_t inout_sel_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tu32 val;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = (u32)drvdata->config.ctiinout_sel;\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t inout_sel_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\tif (val > (CTIINOUTEN_MAX - 1))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tdrvdata->config.ctiinout_sel = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(inout_sel);\n\nstatic ssize_t inen_show(struct device *dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tunsigned long val;\n\tint index;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tspin_lock(&drvdata->spinlock);\n\tindex = drvdata->config.ctiinout_sel;\n\tval = drvdata->config.ctiinen[index];\n\tspin_unlock(&drvdata->spinlock);\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t inen_store(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buf, size_t size)\n{\n\tunsigned long val;\n\tint index;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tindex = config->ctiinout_sel;\n\tconfig->ctiinen[index] = val;\n\n\t \n\tif (cti_active(config))\n\t\tcti_write_single_reg(drvdata, CTIINEN(index), val);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(inen);\n\nstatic ssize_t outen_show(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tunsigned long val;\n\tint index;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tspin_lock(&drvdata->spinlock);\n\tindex = drvdata->config.ctiinout_sel;\n\tval = drvdata->config.ctiouten[index];\n\tspin_unlock(&drvdata->spinlock);\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t outen_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t size)\n{\n\tunsigned long val;\n\tint index;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tindex = config->ctiinout_sel;\n\tconfig->ctiouten[index] = val;\n\n\t \n\tif (cti_active(config))\n\t\tcti_write_single_reg(drvdata, CTIOUTEN(index), val);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(outen);\n\nstatic ssize_t intack_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t size)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tcti_write_intack(dev, val);\n\treturn size;\n}\nstatic DEVICE_ATTR_WO(intack);\n\ncti_config_reg32_rw(gate, ctigate, CTIGATE);\ncti_config_reg32_rw(asicctl, asicctl, ASICCTL);\ncti_config_reg32_rw(appset, ctiappset, CTIAPPSET);\n\nstatic ssize_t appclear_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\n\t \n\tconfig->ctiappset &= ~val;\n\n\t \n\tif (cti_active(config))\n\t\tcti_write_single_reg(drvdata, CTIAPPCLEAR, val);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_WO(appclear);\n\nstatic ssize_t apppulse_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\n\t \n\tif (cti_active(config))\n\t\tcti_write_single_reg(drvdata, CTIAPPPULSE, val);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_WO(apppulse);\n\n \nstatic struct attribute *coresight_cti_regs_attrs[] = {\n\t&dev_attr_inout_sel.attr,\n\t&dev_attr_inen.attr,\n\t&dev_attr_outen.attr,\n\t&dev_attr_gate.attr,\n\t&dev_attr_asicctl.attr,\n\t&dev_attr_intack.attr,\n\t&dev_attr_appset.attr,\n\t&dev_attr_appclear.attr,\n\t&dev_attr_apppulse.attr,\n\tcoresight_cti_reg(triginstatus, CTITRIGINSTATUS),\n\tcoresight_cti_reg(trigoutstatus, CTITRIGOUTSTATUS),\n\tcoresight_cti_reg(chinstatus, CTICHINSTATUS),\n\tcoresight_cti_reg(choutstatus, CTICHOUTSTATUS),\n#ifdef CONFIG_CORESIGHT_CTI_INTEGRATION_REGS\n\tcoresight_cti_reg_rw(itctrl, CORESIGHT_ITCTRL),\n\tcoresight_cti_reg(ittrigin, ITTRIGIN),\n\tcoresight_cti_reg(itchin, ITCHIN),\n\tcoresight_cti_reg_rw(ittrigout, ITTRIGOUT),\n\tcoresight_cti_reg_rw(itchout, ITCHOUT),\n\tcoresight_cti_reg(itchoutack, ITCHOUTACK),\n\tcoresight_cti_reg(ittrigoutack, ITTRIGOUTACK),\n\tcoresight_cti_reg_wo(ittriginack, ITTRIGINACK),\n\tcoresight_cti_reg_wo(itchinack, ITCHINACK),\n#endif\n\tNULL,\n};\n\n \nstatic int\ncti_trig_op_parse(struct device *dev, enum cti_chan_op op,\n\t\t  enum cti_trig_dir dir, const char *buf, size_t size)\n{\n\tu32 chan_idx;\n\tu32 trig_idx;\n\tint items, err = -EINVAL;\n\n\t \n\titems = sscanf(buf, \"%d %d\", &chan_idx, &trig_idx);\n\tif (items == 2) {\n\t\terr = cti_channel_trig_op(dev, op, dir, chan_idx, trig_idx);\n\t\tif (!err)\n\t\t\terr = size;\n\t}\n\treturn err;\n}\n\nstatic ssize_t trigin_attach_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t size)\n{\n\treturn cti_trig_op_parse(dev, CTI_CHAN_ATTACH, CTI_TRIG_IN,\n\t\t\t\t buf, size);\n}\nstatic DEVICE_ATTR_WO(trigin_attach);\n\nstatic ssize_t trigin_detach_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t size)\n{\n\treturn cti_trig_op_parse(dev, CTI_CHAN_DETACH, CTI_TRIG_IN,\n\t\t\t\t buf, size);\n}\nstatic DEVICE_ATTR_WO(trigin_detach);\n\nstatic ssize_t trigout_attach_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t size)\n{\n\treturn cti_trig_op_parse(dev, CTI_CHAN_ATTACH, CTI_TRIG_OUT,\n\t\t\t\t buf, size);\n}\nstatic DEVICE_ATTR_WO(trigout_attach);\n\nstatic ssize_t trigout_detach_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t size)\n{\n\treturn cti_trig_op_parse(dev, CTI_CHAN_DETACH, CTI_TRIG_OUT,\n\t\t\t\t buf, size);\n}\nstatic DEVICE_ATTR_WO(trigout_detach);\n\n\nstatic ssize_t chan_gate_enable_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t size)\n{\n\tint err = 0, channel = 0;\n\n\tif (kstrtoint(buf, 0, &channel))\n\t\treturn -EINVAL;\n\n\terr = cti_channel_gate_op(dev, CTI_GATE_CHAN_ENABLE, channel);\n\treturn err ? err : size;\n}\n\nstatic ssize_t chan_gate_enable_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *cfg = &drvdata->config;\n\tunsigned long ctigate_bitmask = cfg->ctigate;\n\tint size = 0;\n\n\tif (cfg->ctigate == 0)\n\t\tsize = sprintf(buf, \"\\n\");\n\telse\n\t\tsize = bitmap_print_to_pagebuf(true, buf, &ctigate_bitmask,\n\t\t\t\t\t       cfg->nr_ctm_channels);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(chan_gate_enable);\n\nstatic ssize_t chan_gate_disable_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t size)\n{\n\tint err = 0, channel = 0;\n\n\tif (kstrtoint(buf, 0, &channel))\n\t\treturn -EINVAL;\n\n\terr = cti_channel_gate_op(dev, CTI_GATE_CHAN_DISABLE, channel);\n\treturn err ? err : size;\n}\nstatic DEVICE_ATTR_WO(chan_gate_disable);\n\nstatic int\nchan_op_parse(struct device *dev, enum cti_chan_set_op op, const char *buf)\n{\n\tint err = 0, channel = 0;\n\n\tif (kstrtoint(buf, 0, &channel))\n\t\treturn -EINVAL;\n\n\terr = cti_channel_setop(dev, op, channel);\n\treturn err;\n\n}\n\nstatic ssize_t chan_set_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tint err = chan_op_parse(dev, CTI_CHAN_SET, buf);\n\n\treturn err ? err : size;\n}\nstatic DEVICE_ATTR_WO(chan_set);\n\nstatic ssize_t chan_clear_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tint err = chan_op_parse(dev, CTI_CHAN_CLR, buf);\n\n\treturn err ? err : size;\n}\nstatic DEVICE_ATTR_WO(chan_clear);\n\nstatic ssize_t chan_pulse_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tint err = chan_op_parse(dev, CTI_CHAN_PULSE, buf);\n\n\treturn err ? err : size;\n}\nstatic DEVICE_ATTR_WO(chan_pulse);\n\nstatic ssize_t trig_filter_enable_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tu32 val;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tspin_lock(&drvdata->spinlock);\n\tval = drvdata->config.trig_filter_enable;\n\tspin_unlock(&drvdata->spinlock);\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t trig_filter_enable_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tdrvdata->config.trig_filter_enable = !!val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(trig_filter_enable);\n\nstatic ssize_t trigout_filtered_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *cfg = &drvdata->config;\n\tint size = 0, nr_trig_max = cfg->nr_trig_max;\n\tunsigned long mask = cfg->trig_out_filter;\n\n\tif (mask)\n\t\tsize = bitmap_print_to_pagebuf(true, buf, &mask, nr_trig_max);\n\treturn size;\n}\nstatic DEVICE_ATTR_RO(trigout_filtered);\n\n \nstatic ssize_t chan_xtrigs_reset_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t size)\n{\n\tint i;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\n\t \n\tfor (i = 0; i < config->nr_trig_max; i++) {\n\t\tconfig->ctiinen[i] = 0;\n\t\tconfig->ctiouten[i] = 0;\n\t}\n\n\t \n\tconfig->ctigate = GENMASK(config->nr_ctm_channels - 1, 0);\n\tconfig->asicctl = 0;\n\tconfig->ctiappset = 0;\n\tconfig->ctiinout_sel = 0;\n\tconfig->xtrig_rchan_sel = 0;\n\n\t \n\tif (cti_active(config))\n\t\tcti_write_all_hw_regs(drvdata);\n\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_WO(chan_xtrigs_reset);\n\n \nstatic ssize_t chan_xtrigs_sel_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\tif (val > (drvdata->config.nr_ctm_channels - 1))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tdrvdata->config.xtrig_rchan_sel = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\n\nstatic ssize_t chan_xtrigs_sel_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tunsigned long val;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tspin_lock(&drvdata->spinlock);\n\tval = drvdata->config.xtrig_rchan_sel;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn sprintf(buf, \"%ld\\n\", val);\n}\nstatic DEVICE_ATTR_RW(chan_xtrigs_sel);\n\nstatic ssize_t chan_xtrigs_in_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *cfg = &drvdata->config;\n\tint used = 0, reg_idx;\n\tint nr_trig_max = drvdata->config.nr_trig_max;\n\tu32 chan_mask = BIT(cfg->xtrig_rchan_sel);\n\n\tfor (reg_idx = 0; reg_idx < nr_trig_max; reg_idx++) {\n\t\tif (chan_mask & cfg->ctiinen[reg_idx])\n\t\t\tused += sprintf(buf + used, \"%d \", reg_idx);\n\t}\n\n\tused += sprintf(buf + used, \"\\n\");\n\treturn used;\n}\nstatic DEVICE_ATTR_RO(chan_xtrigs_in);\n\nstatic ssize_t chan_xtrigs_out_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *cfg = &drvdata->config;\n\tint used = 0, reg_idx;\n\tint nr_trig_max = drvdata->config.nr_trig_max;\n\tu32 chan_mask = BIT(cfg->xtrig_rchan_sel);\n\n\tfor (reg_idx = 0; reg_idx < nr_trig_max; reg_idx++) {\n\t\tif (chan_mask & cfg->ctiouten[reg_idx])\n\t\t\tused += sprintf(buf + used, \"%d \", reg_idx);\n\t}\n\n\tused += sprintf(buf + used, \"\\n\");\n\treturn used;\n}\nstatic DEVICE_ATTR_RO(chan_xtrigs_out);\n\nstatic ssize_t print_chan_list(struct device *dev,\n\t\t\t       char *buf, bool inuse)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *config = &drvdata->config;\n\tint size, i;\n\tunsigned long inuse_bits = 0, chan_mask;\n\n\t \n\tspin_lock(&drvdata->spinlock);\n\tfor (i = 0; i < config->nr_trig_max; i++) {\n\t\tinuse_bits |= config->ctiinen[i];\n\t\tinuse_bits |= config->ctiouten[i];\n\t}\n\tspin_unlock(&drvdata->spinlock);\n\n\t \n\tif (!inuse)\n\t\tinuse_bits = ~inuse_bits;\n\n\t \n\tchan_mask = GENMASK(config->nr_ctm_channels - 1, 0);\n\tif (inuse_bits & chan_mask)\n\t\tsize = bitmap_print_to_pagebuf(true, buf, &inuse_bits,\n\t\t\t\t\t       config->nr_ctm_channels);\n\telse\n\t\tsize = sprintf(buf, \"\\n\");\n\treturn size;\n}\n\nstatic ssize_t chan_inuse_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn print_chan_list(dev, buf, true);\n}\nstatic DEVICE_ATTR_RO(chan_inuse);\n\nstatic ssize_t chan_free_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn print_chan_list(dev, buf, false);\n}\nstatic DEVICE_ATTR_RO(chan_free);\n\nstatic struct attribute *coresight_cti_channel_attrs[] = {\n\t&dev_attr_trigin_attach.attr,\n\t&dev_attr_trigin_detach.attr,\n\t&dev_attr_trigout_attach.attr,\n\t&dev_attr_trigout_detach.attr,\n\t&dev_attr_trig_filter_enable.attr,\n\t&dev_attr_trigout_filtered.attr,\n\t&dev_attr_chan_gate_enable.attr,\n\t&dev_attr_chan_gate_disable.attr,\n\t&dev_attr_chan_set.attr,\n\t&dev_attr_chan_clear.attr,\n\t&dev_attr_chan_pulse.attr,\n\t&dev_attr_chan_inuse.attr,\n\t&dev_attr_chan_free.attr,\n\t&dev_attr_chan_xtrigs_sel.attr,\n\t&dev_attr_chan_xtrigs_in.attr,\n\t&dev_attr_chan_xtrigs_out.attr,\n\t&dev_attr_chan_xtrigs_reset.attr,\n\tNULL,\n};\n\n \n \nstatic ssize_t con_name_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct dev_ext_attribute *ext_attr =\n\t\tcontainer_of(attr, struct dev_ext_attribute, attr);\n\tstruct cti_trig_con *con = (struct cti_trig_con *)ext_attr->var;\n\n\treturn sprintf(buf, \"%s\\n\", con->con_dev_name);\n}\n\nstatic ssize_t trigin_sig_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct dev_ext_attribute *ext_attr =\n\t\tcontainer_of(attr, struct dev_ext_attribute, attr);\n\tstruct cti_trig_con *con = (struct cti_trig_con *)ext_attr->var;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *cfg = &drvdata->config;\n\tunsigned long mask = con->con_in->used_mask;\n\n\treturn bitmap_print_to_pagebuf(true, buf, &mask, cfg->nr_trig_max);\n}\n\nstatic ssize_t trigout_sig_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct dev_ext_attribute *ext_attr =\n\t\tcontainer_of(attr, struct dev_ext_attribute, attr);\n\tstruct cti_trig_con *con = (struct cti_trig_con *)ext_attr->var;\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *cfg = &drvdata->config;\n\tunsigned long mask = con->con_out->used_mask;\n\n\treturn bitmap_print_to_pagebuf(true, buf, &mask, cfg->nr_trig_max);\n}\n\n \nstatic const char *\ncti_sig_type_name(struct cti_trig_con *con, int used_count, bool in)\n{\n\tint idx = 0;\n\tstruct cti_trig_grp *grp = in ? con->con_in : con->con_out;\n\n\tif (used_count < grp->nr_sigs)\n\t\tidx = grp->sig_types[used_count];\n\treturn sig_type_names[idx];\n}\n\nstatic ssize_t trigin_type_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct dev_ext_attribute *ext_attr =\n\t\tcontainer_of(attr, struct dev_ext_attribute, attr);\n\tstruct cti_trig_con *con = (struct cti_trig_con *)ext_attr->var;\n\tint sig_idx, used = 0;\n\tconst char *name;\n\n\tfor (sig_idx = 0; sig_idx < con->con_in->nr_sigs; sig_idx++) {\n\t\tname = cti_sig_type_name(con, sig_idx, true);\n\t\tused += sprintf(buf + used, \"%s \", name);\n\t}\n\tused += sprintf(buf + used, \"\\n\");\n\treturn used;\n}\n\nstatic ssize_t trigout_type_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct dev_ext_attribute *ext_attr =\n\t\tcontainer_of(attr, struct dev_ext_attribute, attr);\n\tstruct cti_trig_con *con = (struct cti_trig_con *)ext_attr->var;\n\tint sig_idx, used = 0;\n\tconst char *name;\n\n\tfor (sig_idx = 0; sig_idx < con->con_out->nr_sigs; sig_idx++) {\n\t\tname = cti_sig_type_name(con, sig_idx, false);\n\t\tused += sprintf(buf + used, \"%s \", name);\n\t}\n\tused += sprintf(buf + used, \"\\n\");\n\treturn used;\n}\n\n \nstatic p_show_fn show_fns[CTI_CON_ATTR_MAX] = {\n\tcon_name_show,\n\ttrigin_sig_show,\n\ttrigout_sig_show,\n\ttrigin_type_show,\n\ttrigout_type_show,\n};\n\nstatic int cti_create_con_sysfs_attr(struct device *dev,\n\t\t\t\t     struct cti_trig_con *con,\n\t\t\t\t     enum cti_conn_attr_type attr_type,\n\t\t\t\t     int attr_idx)\n{\n\tstruct dev_ext_attribute *eattr;\n\tchar *name;\n\n\teattr = devm_kzalloc(dev, sizeof(struct dev_ext_attribute),\n\t\t\t\t    GFP_KERNEL);\n\tif (eattr) {\n\t\tname = devm_kstrdup(dev, con_attr_names[attr_type],\n\t\t\t\t    GFP_KERNEL);\n\t\tif (name) {\n\t\t\t \n\t\t\teattr->attr.attr.name = name;\n\t\t\teattr->attr.attr.mode = 0444;\n\n\t\t\t \n\t\t\teattr->attr.show = show_fns[attr_type];\n\t\t} else {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\treturn -ENOMEM;\n\t}\n\teattr->var = con;\n\tcon->con_attrs[attr_idx] = &eattr->attr.attr;\n\t \n\tsysfs_attr_init(con->con_attrs[attr_idx]);\n\n\treturn 0;\n}\n\nstatic struct attribute_group *\ncti_create_con_sysfs_group(struct device *dev, struct cti_device *ctidev,\n\t\t\t   int con_idx, struct cti_trig_con *tc)\n{\n\tstruct attribute_group *group = NULL;\n\tint grp_idx;\n\n\tgroup = devm_kzalloc(dev, sizeof(struct attribute_group), GFP_KERNEL);\n\tif (!group)\n\t\treturn NULL;\n\n\tgroup->name = devm_kasprintf(dev, GFP_KERNEL, \"triggers%d\", con_idx);\n\tif (!group->name)\n\t\treturn NULL;\n\n\tgrp_idx = con_idx + CORESIGHT_CTI_STATIC_GROUPS_MAX - 1;\n\tctidev->con_groups[grp_idx] = group;\n\ttc->attr_group = group;\n\treturn group;\n}\n\n \nstatic int cti_create_con_attr_set(struct device *dev, int con_idx,\n\t\t\t\t   struct cti_device *ctidev,\n\t\t\t\t   struct cti_trig_con *tc)\n{\n\tstruct attribute_group *attr_group = NULL;\n\tint attr_idx = 0;\n\tint err = -ENOMEM;\n\n\tattr_group = cti_create_con_sysfs_group(dev, ctidev, con_idx, tc);\n\tif (!attr_group)\n\t\treturn -ENOMEM;\n\n\t \n\ttc->con_attrs = devm_kcalloc(dev, CTI_CON_ATTR_MAX + 1,\n\t\t\t\t     sizeof(struct attribute *), GFP_KERNEL);\n\tif (!tc->con_attrs)\n\t\treturn -ENOMEM;\n\n\terr = cti_create_con_sysfs_attr(dev, tc, CTI_CON_ATTR_NAME,\n\t\t\t\t\tattr_idx++);\n\tif (err)\n\t\treturn err;\n\n\tif (tc->con_in->nr_sigs > 0) {\n\t\terr = cti_create_con_sysfs_attr(dev, tc,\n\t\t\t\t\t\tCTI_CON_ATTR_TRIGIN_SIG,\n\t\t\t\t\t\tattr_idx++);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = cti_create_con_sysfs_attr(dev, tc,\n\t\t\t\t\t\tCTI_CON_ATTR_TRIGIN_TYPES,\n\t\t\t\t\t\tattr_idx++);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tc->con_out->nr_sigs > 0) {\n\t\terr = cti_create_con_sysfs_attr(dev, tc,\n\t\t\t\t\t\tCTI_CON_ATTR_TRIGOUT_SIG,\n\t\t\t\t\t\tattr_idx++);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = cti_create_con_sysfs_attr(dev, tc,\n\t\t\t\t\t\tCTI_CON_ATTR_TRIGOUT_TYPES,\n\t\t\t\t\t\tattr_idx++);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tattr_group->attrs = tc->con_attrs;\n\treturn 0;\n}\n\n \nstatic int cti_create_cons_groups(struct device *dev, struct cti_device *ctidev)\n{\n\tint nr_groups;\n\n\t \n\tnr_groups = ctidev->nr_trig_con + CORESIGHT_CTI_STATIC_GROUPS_MAX;\n\tctidev->con_groups = devm_kcalloc(dev, nr_groups,\n\t\t\t\t\t  sizeof(struct attribute_group *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!ctidev->con_groups)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nint cti_create_cons_sysfs(struct device *dev, struct cti_drvdata *drvdata)\n{\n\tstruct cti_device *ctidev = &drvdata->ctidev;\n\tint err, con_idx = 0, i;\n\tstruct cti_trig_con *tc;\n\n\terr = cti_create_cons_groups(dev, ctidev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < (CORESIGHT_CTI_STATIC_GROUPS_MAX - 1); i++)\n\t\tctidev->con_groups[i] = coresight_cti_groups[i];\n\n\t \n\tlist_for_each_entry(tc, &ctidev->trig_cons, node) {\n\t\terr = cti_create_con_attr_set(dev, con_idx++, ctidev, tc);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n \nstatic const struct attribute_group coresight_cti_group = {\n\t.attrs = coresight_cti_attrs,\n};\n\nstatic const struct attribute_group coresight_cti_mgmt_group = {\n\t.attrs = coresight_cti_mgmt_attrs,\n\t.name = \"mgmt\",\n};\n\nstatic const struct attribute_group coresight_cti_regs_group = {\n\t.attrs = coresight_cti_regs_attrs,\n\t.name = \"regs\",\n};\n\nstatic const struct attribute_group coresight_cti_channels_group = {\n\t.attrs = coresight_cti_channel_attrs,\n\t.name = \"channels\",\n};\n\nconst struct attribute_group *\ncoresight_cti_groups[CORESIGHT_CTI_STATIC_GROUPS_MAX] = {\n\t&coresight_cti_group,\n\t&coresight_cti_mgmt_group,\n\t&coresight_cti_regs_group,\n\t&coresight_cti_channels_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}