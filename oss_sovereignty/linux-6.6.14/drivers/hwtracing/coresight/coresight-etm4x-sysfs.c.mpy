{
  "module_name": "coresight-etm4x-sysfs.c",
  "hash_id": "d1639a23f46c8fceb01427c3e3302166930bd82a9e5063795ce56db72ebaf326",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-etm4x-sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/pid_namespace.h>\n#include <linux/pm_runtime.h>\n#include <linux/sysfs.h>\n#include \"coresight-etm4x.h\"\n#include \"coresight-priv.h\"\n#include \"coresight-syscfg.h\"\n\nstatic int etm4_set_mode_exclude(struct etmv4_drvdata *drvdata, bool exclude)\n{\n\tu8 idx;\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tidx = config->addr_idx;\n\n\t \n\tif (FIELD_GET(TRCACATRn_TYPE_MASK, config->addr_acc[idx]) == TRCACATRn_TYPE_ADDR) {\n\t\tif (idx % 2 != 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (config->addr_type[idx] != ETM_ADDR_TYPE_RANGE ||\n\t\t    config->addr_type[idx + 1] != ETM_ADDR_TYPE_RANGE)\n\t\t\treturn -EINVAL;\n\n\t\tif (exclude == true) {\n\t\t\t \n\t\t\tconfig->viiectlr |= BIT(idx / 2 + 16);\n\t\t\tconfig->viiectlr &= ~BIT(idx / 2);\n\t\t} else {\n\t\t\t \n\t\t\tconfig->viiectlr |= BIT(idx / 2);\n\t\t\tconfig->viiectlr &= ~BIT(idx / 2 + 16);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ssize_t nr_pe_cmp_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->nr_pe_cmp;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(nr_pe_cmp);\n\nstatic ssize_t nr_addr_cmp_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->nr_addr_cmp;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(nr_addr_cmp);\n\nstatic ssize_t nr_cntr_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->nr_cntr;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(nr_cntr);\n\nstatic ssize_t nr_ext_inp_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->nr_ext_inp;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(nr_ext_inp);\n\nstatic ssize_t numcidc_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->numcidc;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(numcidc);\n\nstatic ssize_t numvmidc_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->numvmidc;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(numvmidc);\n\nstatic ssize_t nrseqstate_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->nrseqstate;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(nrseqstate);\n\nstatic ssize_t nr_resource_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->nr_resource;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(nr_resource);\n\nstatic ssize_t nr_ss_cmp_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->nr_ss_cmp;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(nr_ss_cmp);\n\nstatic ssize_t reset_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t size)\n{\n\tint i;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tif (val)\n\t\tconfig->mode = 0x0;\n\n\t \n\tconfig->mode &= ~(ETM_MODE_LOAD | ETM_MODE_STORE);\n\tconfig->cfg &= ~(TRCCONFIGR_INSTP0_LOAD | TRCCONFIGR_INSTP0_STORE);\n\n\t \n\tconfig->mode &= ~(ETM_MODE_DATA_TRACE_ADDR |\n\t\t\t   ETM_MODE_DATA_TRACE_VAL);\n\tconfig->cfg &= ~(TRCCONFIGR_DA | TRCCONFIGR_DV);\n\n\t \n\tconfig->eventctrl0 = 0x0;\n\tconfig->eventctrl1 = 0x0;\n\n\t \n\tconfig->ts_ctrl = 0x0;\n\n\t \n\tconfig->stall_ctrl = 0x0;\n\n\t \n\tif (drvdata->syncpr == false)\n\t\tconfig->syncfreq = 0x8;\n\n\t \n\tconfig->vinst_ctrl = FIELD_PREP(TRCVICTLR_EVENT_MASK, 0x01);\n\tif (drvdata->nr_addr_cmp > 0) {\n\t\tconfig->mode |= ETM_MODE_VIEWINST_STARTSTOP;\n\t\t \n\t\tconfig->vinst_ctrl |= TRCVICTLR_SSSTATUS;\n\t}\n\n\t \n\tconfig->viiectlr = 0x0;\n\n\t \n\tconfig->vissctlr = 0x0;\n\tconfig->vipcssctlr = 0x0;\n\n\t \n\tfor (i = 0; i < drvdata->nrseqstate-1; i++)\n\t\tconfig->seq_ctrl[i] = 0x0;\n\tconfig->seq_rst = 0x0;\n\tconfig->seq_state = 0x0;\n\n\t \n\tconfig->ext_inp = 0x0;\n\n\tconfig->cntr_idx = 0x0;\n\tfor (i = 0; i < drvdata->nr_cntr; i++) {\n\t\tconfig->cntrldvr[i] = 0x0;\n\t\tconfig->cntr_ctrl[i] = 0x0;\n\t\tconfig->cntr_val[i] = 0x0;\n\t}\n\n\tconfig->res_idx = 0x0;\n\tfor (i = 2; i < 2 * drvdata->nr_resource; i++)\n\t\tconfig->res_ctrl[i] = 0x0;\n\n\tconfig->ss_idx = 0x0;\n\tfor (i = 0; i < drvdata->nr_ss_cmp; i++) {\n\t\tconfig->ss_ctrl[i] = 0x0;\n\t\tconfig->ss_pe_cmp[i] = 0x0;\n\t}\n\n\tconfig->addr_idx = 0x0;\n\tfor (i = 0; i < drvdata->nr_addr_cmp * 2; i++) {\n\t\tconfig->addr_val[i] = 0x0;\n\t\tconfig->addr_acc[i] = 0x0;\n\t\tconfig->addr_type[i] = ETM_ADDR_TYPE_NONE;\n\t}\n\n\tconfig->ctxid_idx = 0x0;\n\tfor (i = 0; i < drvdata->numcidc; i++)\n\t\tconfig->ctxid_pid[i] = 0x0;\n\n\tconfig->ctxid_mask0 = 0x0;\n\tconfig->ctxid_mask1 = 0x0;\n\n\tconfig->vmid_idx = 0x0;\n\tfor (i = 0; i < drvdata->numvmidc; i++)\n\t\tconfig->vmid_val[i] = 0x0;\n\tconfig->vmid_mask0 = 0x0;\n\tconfig->vmid_mask1 = 0x0;\n\n\tspin_unlock(&drvdata->spinlock);\n\n\t \n\tetm4_release_trace_id(drvdata);\n\n\tcscfg_csdev_reset_feats(to_coresight_device(dev));\n\n\treturn size;\n}\nstatic DEVICE_ATTR_WO(reset);\n\nstatic ssize_t mode_show(struct device *dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->mode;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t mode_store(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buf, size_t size)\n{\n\tunsigned long val, mode;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tconfig->mode = val & ETMv4_MODE_ALL;\n\n\tif (drvdata->instrp0 == true) {\n\t\t \n\t\tconfig->cfg  &= ~TRCCONFIGR_INSTP0_LOAD_STORE;\n\t\tif (config->mode & ETM_MODE_LOAD)\n\t\t\t \n\t\t\tconfig->cfg  |= TRCCONFIGR_INSTP0_LOAD;\n\t\tif (config->mode & ETM_MODE_STORE)\n\t\t\t \n\t\t\tconfig->cfg  |= TRCCONFIGR_INSTP0_STORE;\n\t\tif (config->mode & ETM_MODE_LOAD_STORE)\n\t\t\t \n\t\t\tconfig->cfg  |= TRCCONFIGR_INSTP0_LOAD_STORE;\n\t}\n\n\t \n\tif ((config->mode & ETM_MODE_BB) && (drvdata->trcbb == true))\n\t\tconfig->cfg |= TRCCONFIGR_BB;\n\telse\n\t\tconfig->cfg &= ~TRCCONFIGR_BB;\n\n\t \n\tif ((config->mode & ETMv4_MODE_CYCACC) &&\n\t\t(drvdata->trccci == true))\n\t\tconfig->cfg |= TRCCONFIGR_CCI;\n\telse\n\t\tconfig->cfg &= ~TRCCONFIGR_CCI;\n\n\t \n\tif ((config->mode & ETMv4_MODE_CTXID) && (drvdata->ctxid_size))\n\t\tconfig->cfg |= TRCCONFIGR_CID;\n\telse\n\t\tconfig->cfg &= ~TRCCONFIGR_CID;\n\n\tif ((config->mode & ETM_MODE_VMID) && (drvdata->vmid_size))\n\t\tconfig->cfg |= TRCCONFIGR_VMID;\n\telse\n\t\tconfig->cfg &= ~TRCCONFIGR_VMID;\n\n\t \n\tmode = ETM_MODE_COND(config->mode);\n\tif (drvdata->trccond == true) {\n\t\tconfig->cfg &= ~TRCCONFIGR_COND_MASK;\n\t\tconfig->cfg |= mode << __bf_shf(TRCCONFIGR_COND_MASK);\n\t}\n\n\t \n\tif ((config->mode & ETMv4_MODE_TIMESTAMP) && (drvdata->ts_size))\n\t\tconfig->cfg |= TRCCONFIGR_TS;\n\telse\n\t\tconfig->cfg &= ~TRCCONFIGR_TS;\n\n\t \n\tif ((config->mode & ETM_MODE_RETURNSTACK) &&\n\t\t\t\t\t(drvdata->retstack == true))\n\t\tconfig->cfg |= TRCCONFIGR_RS;\n\telse\n\t\tconfig->cfg &= ~TRCCONFIGR_RS;\n\n\t \n\tmode = ETM_MODE_QELEM(config->mode);\n\t \n\tconfig->cfg &= ~(TRCCONFIGR_QE_W_COUNTS | TRCCONFIGR_QE_WO_COUNTS);\n\t \n\tif (mode && drvdata->q_support)\n\t\tconfig->cfg |= TRCCONFIGR_QE_W_COUNTS;\n\t \n\tif ((mode & BIT(1)) && (drvdata->q_support & BIT(1)))\n\t\tconfig->cfg |= TRCCONFIGR_QE_WO_COUNTS;\n\n\t \n\tif ((config->mode & ETM_MODE_ATB_TRIGGER) &&\n\t    (drvdata->atbtrig == true))\n\t\tconfig->eventctrl1 |= TRCEVENTCTL1R_ATB;\n\telse\n\t\tconfig->eventctrl1 &= ~TRCEVENTCTL1R_ATB;\n\n\t \n\tif ((config->mode & ETM_MODE_LPOVERRIDE) &&\n\t    (drvdata->lpoverride == true))\n\t\tconfig->eventctrl1 |= TRCEVENTCTL1R_LPOVERRIDE;\n\telse\n\t\tconfig->eventctrl1 &= ~TRCEVENTCTL1R_LPOVERRIDE;\n\n\t \n\tif ((config->mode & ETM_MODE_ISTALL_EN) && (drvdata->stallctl == true))\n\t\tconfig->stall_ctrl |= TRCSTALLCTLR_ISTALL;\n\telse\n\t\tconfig->stall_ctrl &= ~TRCSTALLCTLR_ISTALL;\n\n\t \n\tif (config->mode & ETM_MODE_INSTPRIO)\n\t\tconfig->stall_ctrl |= TRCSTALLCTLR_INSTPRIORITY;\n\telse\n\t\tconfig->stall_ctrl &= ~TRCSTALLCTLR_INSTPRIORITY;\n\n\t \n\tif ((config->mode & ETM_MODE_NOOVERFLOW) &&\n\t\t(drvdata->nooverflow == true))\n\t\tconfig->stall_ctrl |= TRCSTALLCTLR_NOOVERFLOW;\n\telse\n\t\tconfig->stall_ctrl &= ~TRCSTALLCTLR_NOOVERFLOW;\n\n\t \n\tif (config->mode & ETM_MODE_VIEWINST_STARTSTOP)\n\t\tconfig->vinst_ctrl |= TRCVICTLR_SSSTATUS;\n\telse\n\t\tconfig->vinst_ctrl &= ~TRCVICTLR_SSSTATUS;\n\n\t \n\tif (config->mode & ETM_MODE_TRACE_RESET)\n\t\tconfig->vinst_ctrl |= TRCVICTLR_TRCRESET;\n\telse\n\t\tconfig->vinst_ctrl &= ~TRCVICTLR_TRCRESET;\n\n\t \n\tif ((config->mode & ETM_MODE_TRACE_ERR) &&\n\t\t(drvdata->trc_error == true))\n\t\tconfig->vinst_ctrl |= TRCVICTLR_TRCERR;\n\telse\n\t\tconfig->vinst_ctrl &= ~TRCVICTLR_TRCERR;\n\n\tif (config->mode & (ETM_MODE_EXCL_KERN | ETM_MODE_EXCL_USER))\n\t\tetm4_config_trace_mode(config);\n\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(mode);\n\nstatic ssize_t pe_show(struct device *dev,\n\t\t       struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->pe_sel;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t pe_store(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tif (val > drvdata->nr_pe) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig->pe_sel = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(pe);\n\nstatic ssize_t event_show(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->eventctrl0;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t event_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tswitch (drvdata->nr_event) {\n\tcase 0x0:\n\t\t \n\t\tconfig->eventctrl0 = val & 0xFF;\n\t\tbreak;\n\tcase 0x1:\n\t\t  \n\t\tconfig->eventctrl0 = val & 0xFFFF;\n\t\tbreak;\n\tcase 0x2:\n\t\t \n\t\tconfig->eventctrl0 = val & 0xFFFFFF;\n\t\tbreak;\n\tcase 0x3:\n\t\t \n\t\tconfig->eventctrl0 = val;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(event);\n\nstatic ssize_t event_instren_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = FIELD_GET(TRCEVENTCTL1R_INSTEN_MASK, config->eventctrl1);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t event_instren_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\t \n\tconfig->eventctrl1 &= ~TRCEVENTCTL1R_INSTEN_MASK;\n\tswitch (drvdata->nr_event) {\n\tcase 0x0:\n\t\t \n\t\tconfig->eventctrl1 |= val & TRCEVENTCTL1R_INSTEN_1;\n\t\tbreak;\n\tcase 0x1:\n\t\t \n\t\tconfig->eventctrl1 |= val & (TRCEVENTCTL1R_INSTEN_0 | TRCEVENTCTL1R_INSTEN_1);\n\t\tbreak;\n\tcase 0x2:\n\t\t \n\t\tconfig->eventctrl1 |= val & (TRCEVENTCTL1R_INSTEN_0 |\n\t\t\t\t\t     TRCEVENTCTL1R_INSTEN_1 |\n\t\t\t\t\t     TRCEVENTCTL1R_INSTEN_2);\n\t\tbreak;\n\tcase 0x3:\n\t\t \n\t\tconfig->eventctrl1 |= val & (TRCEVENTCTL1R_INSTEN_0 |\n\t\t\t\t\t     TRCEVENTCTL1R_INSTEN_1 |\n\t\t\t\t\t     TRCEVENTCTL1R_INSTEN_2 |\n\t\t\t\t\t     TRCEVENTCTL1R_INSTEN_3);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(event_instren);\n\nstatic ssize_t event_ts_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->ts_ctrl;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t event_ts_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (!drvdata->ts_size)\n\t\treturn -EINVAL;\n\n\tconfig->ts_ctrl = val & ETMv4_EVENT_MASK;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(event_ts);\n\nstatic ssize_t syncfreq_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->syncfreq;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t syncfreq_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (drvdata->syncpr == true)\n\t\treturn -EINVAL;\n\n\tconfig->syncfreq = val & ETMv4_SYNC_MASK;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(syncfreq);\n\nstatic ssize_t cyc_threshold_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->ccctlr;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t cyc_threshold_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\t \n\tval &= ETM_CYC_THRESHOLD_MASK;\n\tif (val < drvdata->ccitmin)\n\t\treturn -EINVAL;\n\n\tconfig->ccctlr = val;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(cyc_threshold);\n\nstatic ssize_t bb_ctrl_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->bb_ctrl;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t bb_ctrl_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (drvdata->trcbb == false)\n\t\treturn -EINVAL;\n\tif (!drvdata->nr_addr_cmp)\n\t\treturn -EINVAL;\n\n\t \n\tif ((val & TRCBBCTLR_MODE) && (FIELD_GET(TRCBBCTLR_RANGE_MASK, val) == 0))\n\t\treturn -EINVAL;\n\n\tconfig->bb_ctrl = val & (TRCBBCTLR_MODE | TRCBBCTLR_RANGE_MASK);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(bb_ctrl);\n\nstatic ssize_t event_vinst_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = FIELD_GET(TRCVICTLR_EVENT_MASK, config->vinst_ctrl);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t event_vinst_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tval &= TRCVICTLR_EVENT_MASK >> __bf_shf(TRCVICTLR_EVENT_MASK);\n\tconfig->vinst_ctrl &= ~TRCVICTLR_EVENT_MASK;\n\tconfig->vinst_ctrl |= FIELD_PREP(TRCVICTLR_EVENT_MASK, val);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(event_vinst);\n\nstatic ssize_t s_exlevel_vinst_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = FIELD_GET(TRCVICTLR_EXLEVEL_S_MASK, config->vinst_ctrl);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t s_exlevel_vinst_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\t \n\tconfig->vinst_ctrl &= ~TRCVICTLR_EXLEVEL_S_MASK;\n\t \n\tval &= drvdata->s_ex_level;\n\tconfig->vinst_ctrl |= val << __bf_shf(TRCVICTLR_EXLEVEL_S_MASK);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(s_exlevel_vinst);\n\nstatic ssize_t ns_exlevel_vinst_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\t \n\tval = FIELD_GET(TRCVICTLR_EXLEVEL_NS_MASK, config->vinst_ctrl);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t ns_exlevel_vinst_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\t \n\tconfig->vinst_ctrl &= ~TRCVICTLR_EXLEVEL_NS_MASK;\n\t \n\tval &= drvdata->ns_ex_level;\n\tconfig->vinst_ctrl |= val << __bf_shf(TRCVICTLR_EXLEVEL_NS_MASK);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(ns_exlevel_vinst);\n\nstatic ssize_t addr_idx_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->addr_idx;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t addr_idx_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (val >= drvdata->nr_addr_cmp * 2)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock(&drvdata->spinlock);\n\tconfig->addr_idx = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_idx);\n\nstatic ssize_t addr_instdatatype_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tssize_t len;\n\tu8 val, idx;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tval = FIELD_GET(TRCACATRn_TYPE_MASK, config->addr_acc[idx]);\n\tlen = scnprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\tval == TRCACATRn_TYPE_ADDR ? \"instr\" :\n\t\t\t(val == TRCACATRn_TYPE_DATA_LOAD_ADDR ? \"data_load\" :\n\t\t\t(val == TRCACATRn_TYPE_DATA_STORE_ADDR ? \"data_store\" :\n\t\t\t\"data_load_store\")));\n\tspin_unlock(&drvdata->spinlock);\n\treturn len;\n}\n\nstatic ssize_t addr_instdatatype_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t size)\n{\n\tu8 idx;\n\tchar str[20] = \"\";\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (strlen(buf) >= 20)\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%s\", str) != 1)\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (!strcmp(str, \"instr\"))\n\t\t \n\t\tconfig->addr_acc[idx] &= ~TRCACATRn_TYPE_MASK;\n\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_instdatatype);\n\nstatic ssize_t addr_single_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tidx = config->addr_idx;\n\tspin_lock(&drvdata->spinlock);\n\tif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\n\t      config->addr_type[idx] == ETM_ADDR_TYPE_SINGLE)) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\tval = (unsigned long)config->addr_val[idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t addr_single_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\n\t      config->addr_type[idx] == ETM_ADDR_TYPE_SINGLE)) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tconfig->addr_val[idx] = (u64)val;\n\tconfig->addr_type[idx] = ETM_ADDR_TYPE_SINGLE;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_single);\n\nstatic ssize_t addr_range_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tu8 idx;\n\tunsigned long val1, val2;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (idx % 2 != 0) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\tif (!((config->addr_type[idx] == ETM_ADDR_TYPE_NONE &&\n\t       config->addr_type[idx + 1] == ETM_ADDR_TYPE_NONE) ||\n\t      (config->addr_type[idx] == ETM_ADDR_TYPE_RANGE &&\n\t       config->addr_type[idx + 1] == ETM_ADDR_TYPE_RANGE))) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tval1 = (unsigned long)config->addr_val[idx];\n\tval2 = (unsigned long)config->addr_val[idx + 1];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx %#lx\\n\", val1, val2);\n}\n\nstatic ssize_t addr_range_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val1, val2;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\tint elements, exclude;\n\n\telements = sscanf(buf, \"%lx %lx %x\", &val1, &val2, &exclude);\n\n\t \n\tif (elements < 2)\n\t\treturn -EINVAL;\n\t \n\tif (val1 > val2)\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (idx % 2 != 0) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tif (!((config->addr_type[idx] == ETM_ADDR_TYPE_NONE &&\n\t       config->addr_type[idx + 1] == ETM_ADDR_TYPE_NONE) ||\n\t      (config->addr_type[idx] == ETM_ADDR_TYPE_RANGE &&\n\t       config->addr_type[idx + 1] == ETM_ADDR_TYPE_RANGE))) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tconfig->addr_val[idx] = (u64)val1;\n\tconfig->addr_type[idx] = ETM_ADDR_TYPE_RANGE;\n\tconfig->addr_val[idx + 1] = (u64)val2;\n\tconfig->addr_type[idx + 1] = ETM_ADDR_TYPE_RANGE;\n\t \n\tif (elements != 3)\n\t\texclude = config->mode & ETM_MODE_EXCLUDE;\n\tetm4_set_mode_exclude(drvdata, exclude ? true : false);\n\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_range);\n\nstatic ssize_t addr_start_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\n\tif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\n\t      config->addr_type[idx] == ETM_ADDR_TYPE_START)) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tval = (unsigned long)config->addr_val[idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t addr_start_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (!drvdata->nr_addr_cmp) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EINVAL;\n\t}\n\tif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\n\t      config->addr_type[idx] == ETM_ADDR_TYPE_START)) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tconfig->addr_val[idx] = (u64)val;\n\tconfig->addr_type[idx] = ETM_ADDR_TYPE_START;\n\tconfig->vissctlr |= BIT(idx);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_start);\n\nstatic ssize_t addr_stop_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\n\tif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\n\t      config->addr_type[idx] == ETM_ADDR_TYPE_STOP)) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tval = (unsigned long)config->addr_val[idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t addr_stop_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (!drvdata->nr_addr_cmp) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EINVAL;\n\t}\n\tif (!(config->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\n\t       config->addr_type[idx] == ETM_ADDR_TYPE_STOP)) {\n\t\tspin_unlock(&drvdata->spinlock);\n\t\treturn -EPERM;\n\t}\n\n\tconfig->addr_val[idx] = (u64)val;\n\tconfig->addr_type[idx] = ETM_ADDR_TYPE_STOP;\n\tconfig->vissctlr |= BIT(idx + 16);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_stop);\n\nstatic ssize_t addr_ctxtype_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tssize_t len;\n\tu8 idx, val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\t \n\tval = FIELD_GET(TRCACATRn_CONTEXTTYPE_MASK, config->addr_acc[idx]);\n\tlen = scnprintf(buf, PAGE_SIZE, \"%s\\n\", val == ETM_CTX_NONE ? \"none\" :\n\t\t\t(val == ETM_CTX_CTXID ? \"ctxid\" :\n\t\t\t(val == ETM_CTX_VMID ? \"vmid\" : \"all\")));\n\tspin_unlock(&drvdata->spinlock);\n\treturn len;\n}\n\nstatic ssize_t addr_ctxtype_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tu8 idx;\n\tchar str[10] = \"\";\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (strlen(buf) >= 10)\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%s\", str) != 1)\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tif (!strcmp(str, \"none\"))\n\t\t \n\t\tconfig->addr_acc[idx] &= ~TRCACATRn_CONTEXTTYPE_MASK;\n\telse if (!strcmp(str, \"ctxid\")) {\n\t\t \n\t\tif (drvdata->numcidc) {\n\t\t\tconfig->addr_acc[idx] |= TRCACATRn_CONTEXTTYPE_CTXID;\n\t\t\tconfig->addr_acc[idx] &= ~TRCACATRn_CONTEXTTYPE_VMID;\n\t\t}\n\t} else if (!strcmp(str, \"vmid\")) {\n\t\t \n\t\tif (drvdata->numvmidc) {\n\t\t\tconfig->addr_acc[idx] &= ~TRCACATRn_CONTEXTTYPE_CTXID;\n\t\t\tconfig->addr_acc[idx] |= TRCACATRn_CONTEXTTYPE_VMID;\n\t\t}\n\t} else if (!strcmp(str, \"all\")) {\n\t\t \n\t\tif (drvdata->numcidc)\n\t\t\tconfig->addr_acc[idx] |= TRCACATRn_CONTEXTTYPE_CTXID;\n\t\tif (drvdata->numvmidc)\n\t\t\tconfig->addr_acc[idx] |= TRCACATRn_CONTEXTTYPE_VMID;\n\t}\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_ctxtype);\n\nstatic ssize_t addr_context_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\t \n\tval = FIELD_GET(TRCACATRn_CONTEXT_MASK, config->addr_acc[idx]);\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t addr_context_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif ((drvdata->numcidc <= 1) && (drvdata->numvmidc <= 1))\n\t\treturn -EINVAL;\n\tif (val >=  (drvdata->numcidc >= drvdata->numvmidc ?\n\t\t     drvdata->numcidc : drvdata->numvmidc))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\t \n\tconfig->addr_acc[idx] &= ~TRCACATRn_CONTEXT_MASK;\n\tconfig->addr_acc[idx] |= val << __bf_shf(TRCACATRn_CONTEXT_MASK);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_context);\n\nstatic ssize_t addr_exlevel_s_ns_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\tval = FIELD_GET(TRCACATRn_EXLEVEL_MASK, config->addr_acc[idx]);\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t addr_exlevel_s_ns_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val & ~(TRCACATRn_EXLEVEL_MASK >> __bf_shf(TRCACATRn_EXLEVEL_MASK)))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\t \n\tconfig->addr_acc[idx] &= ~TRCACATRn_EXLEVEL_MASK;\n\tconfig->addr_acc[idx] |= val << __bf_shf(TRCACATRn_EXLEVEL_MASK);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(addr_exlevel_s_ns);\n\nstatic const char * const addr_type_names[] = {\n\t\"unused\",\n\t\"single\",\n\t\"range\",\n\t\"start\",\n\t\"stop\"\n};\n\nstatic ssize_t addr_cmp_view_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tu8 idx, addr_type;\n\tunsigned long addr_v, addr_v2, addr_ctrl;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\tint size = 0;\n\tbool exclude = false;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->addr_idx;\n\taddr_v = config->addr_val[idx];\n\taddr_ctrl = config->addr_acc[idx];\n\taddr_type = config->addr_type[idx];\n\tif (addr_type == ETM_ADDR_TYPE_RANGE) {\n\t\tif (idx & 0x1) {\n\t\t\tidx -= 1;\n\t\t\taddr_v2 = addr_v;\n\t\t\taddr_v = config->addr_val[idx];\n\t\t} else {\n\t\t\taddr_v2 = config->addr_val[idx + 1];\n\t\t}\n\t\texclude = config->viiectlr & BIT(idx / 2 + 16);\n\t}\n\tspin_unlock(&drvdata->spinlock);\n\tif (addr_type) {\n\t\tsize = scnprintf(buf, PAGE_SIZE, \"addr_cmp[%i] %s %#lx\", idx,\n\t\t\t\t addr_type_names[addr_type], addr_v);\n\t\tif (addr_type == ETM_ADDR_TYPE_RANGE) {\n\t\t\tsize += scnprintf(buf + size, PAGE_SIZE - size,\n\t\t\t\t\t  \" %#lx %s\", addr_v2,\n\t\t\t\t\t  exclude ? \"exclude\" : \"include\");\n\t\t}\n\t\tsize += scnprintf(buf + size, PAGE_SIZE - size,\n\t\t\t\t  \" ctrl(%#lx)\\n\", addr_ctrl);\n\t} else {\n\t\tsize = scnprintf(buf, PAGE_SIZE, \"addr_cmp[%i] unused\\n\", idx);\n\t}\n\treturn size;\n}\nstatic DEVICE_ATTR_RO(addr_cmp_view);\n\nstatic ssize_t vinst_pe_cmp_start_stop_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (!drvdata->nr_pe_cmp)\n\t\treturn -EINVAL;\n\tval = config->vipcssctlr;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\nstatic ssize_t vinst_pe_cmp_start_stop_store(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (!drvdata->nr_pe_cmp)\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tconfig->vipcssctlr = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(vinst_pe_cmp_start_stop);\n\nstatic ssize_t seq_idx_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->seq_idx;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t seq_idx_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (val >= drvdata->nrseqstate - 1)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock(&drvdata->spinlock);\n\tconfig->seq_idx = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(seq_idx);\n\nstatic ssize_t seq_state_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->seq_state;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t seq_state_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (val >= drvdata->nrseqstate)\n\t\treturn -EINVAL;\n\n\tconfig->seq_state = val;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(seq_state);\n\nstatic ssize_t seq_event_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->seq_idx;\n\tval = config->seq_ctrl[idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t seq_event_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->seq_idx;\n\t \n\tconfig->seq_ctrl[idx] = val & 0xFFFF;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(seq_event);\n\nstatic ssize_t seq_reset_event_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->seq_rst;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t seq_reset_event_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (!(drvdata->nrseqstate))\n\t\treturn -EINVAL;\n\n\tconfig->seq_rst = val & ETMv4_EVENT_MASK;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(seq_reset_event);\n\nstatic ssize_t cntr_idx_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->cntr_idx;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t cntr_idx_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (val >= drvdata->nr_cntr)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock(&drvdata->spinlock);\n\tconfig->cntr_idx = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(cntr_idx);\n\nstatic ssize_t cntrldvr_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->cntr_idx;\n\tval = config->cntrldvr[idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t cntrldvr_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (val > ETM_CNTR_MAX_VAL)\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->cntr_idx;\n\tconfig->cntrldvr[idx] = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(cntrldvr);\n\nstatic ssize_t cntr_val_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->cntr_idx;\n\tval = config->cntr_val[idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t cntr_val_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (val > ETM_CNTR_MAX_VAL)\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->cntr_idx;\n\tconfig->cntr_val[idx] = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(cntr_val);\n\nstatic ssize_t cntr_ctrl_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->cntr_idx;\n\tval = config->cntr_ctrl[idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t cntr_ctrl_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->cntr_idx;\n\tconfig->cntr_ctrl[idx] = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(cntr_ctrl);\n\nstatic ssize_t res_idx_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->res_idx;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t res_idx_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\t \n\tif ((val < 2) || (val >= 2 * drvdata->nr_resource))\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock(&drvdata->spinlock);\n\tconfig->res_idx = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(res_idx);\n\nstatic ssize_t res_ctrl_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->res_idx;\n\tval = config->res_ctrl[idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t res_ctrl_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->res_idx;\n\t \n\tif (idx % 2 != 0)\n\t\t \n\t\tval &= ~TRCRSCTLRn_PAIRINV;\n\tconfig->res_ctrl[idx] = val & (TRCRSCTLRn_PAIRINV |\n\t\t\t\t       TRCRSCTLRn_INV |\n\t\t\t\t       TRCRSCTLRn_GROUP_MASK |\n\t\t\t\t       TRCRSCTLRn_SELECT_MASK);\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(res_ctrl);\n\nstatic ssize_t sshot_idx_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->ss_idx;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t sshot_idx_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (val >= drvdata->nr_ss_cmp)\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tconfig->ss_idx = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(sshot_idx);\n\nstatic ssize_t sshot_ctrl_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tval = config->ss_ctrl[config->ss_idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t sshot_ctrl_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->ss_idx;\n\tconfig->ss_ctrl[idx] = FIELD_PREP(TRCSSCCRn_SAC_ARC_RST_MASK, val);\n\t \n\tconfig->ss_status[idx] &= ~TRCSSCSRn_STATUS;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(sshot_ctrl);\n\nstatic ssize_t sshot_status_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tval = config->ss_status[config->ss_idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(sshot_status);\n\nstatic ssize_t sshot_pe_ctrl_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tval = config->ss_pe_cmp[config->ss_idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t sshot_pe_ctrl_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->ss_idx;\n\tconfig->ss_pe_cmp[idx] = FIELD_PREP(TRCSSPCICRn_PC_MASK, val);\n\t \n\tconfig->ss_status[idx] &= ~TRCSSCSRn_STATUS;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(sshot_pe_ctrl);\n\nstatic ssize_t ctxid_idx_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->ctxid_idx;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t ctxid_idx_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (val >= drvdata->numcidc)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock(&drvdata->spinlock);\n\tconfig->ctxid_idx = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(ctxid_idx);\n\nstatic ssize_t ctxid_pid_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tu8 idx;\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\t \n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->ctxid_idx;\n\tval = (unsigned long)config->ctxid_pid[idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t ctxid_pid_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tu8 idx;\n\tunsigned long pid;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\t \n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\t \n\tif (!drvdata->ctxid_size || !drvdata->numcidc)\n\t\treturn -EINVAL;\n\tif (kstrtoul(buf, 16, &pid))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tidx = config->ctxid_idx;\n\tconfig->ctxid_pid[idx] = (u64)pid;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(ctxid_pid);\n\nstatic ssize_t ctxid_masks_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tunsigned long val1, val2;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\t \n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tval1 = config->ctxid_mask0;\n\tval2 = config->ctxid_mask1;\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx %#lx\\n\", val1, val2);\n}\n\nstatic ssize_t ctxid_masks_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tu8 i, j, maskbyte;\n\tunsigned long val1, val2, mask;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\tint nr_inputs;\n\n\t \n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\t \n\tif (!drvdata->ctxid_size || !drvdata->numcidc)\n\t\treturn -EINVAL;\n\t \n\tnr_inputs = sscanf(buf, \"%lx %lx\", &val1, &val2);\n\tif ((drvdata->numcidc > 4) && (nr_inputs != 2))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\t \n\tswitch (drvdata->numcidc) {\n\tcase 0x1:\n\t\t \n\t\tconfig->ctxid_mask0 = val1 & 0xFF;\n\t\tbreak;\n\tcase 0x2:\n\t\t \n\t\tconfig->ctxid_mask0 = val1 & 0xFFFF;\n\t\tbreak;\n\tcase 0x3:\n\t\t \n\t\tconfig->ctxid_mask0 = val1 & 0xFFFFFF;\n\t\tbreak;\n\tcase 0x4:\n\t\t  \n\t\tconfig->ctxid_mask0 = val1;\n\t\tbreak;\n\tcase 0x5:\n\t\t \n\t\tconfig->ctxid_mask0 = val1;\n\t\tconfig->ctxid_mask1 = val2 & 0xFF;\n\t\tbreak;\n\tcase 0x6:\n\t\t \n\t\tconfig->ctxid_mask0 = val1;\n\t\tconfig->ctxid_mask1 = val2 & 0xFFFF;\n\t\tbreak;\n\tcase 0x7:\n\t\t \n\t\tconfig->ctxid_mask0 = val1;\n\t\tconfig->ctxid_mask1 = val2 & 0xFFFFFF;\n\t\tbreak;\n\tcase 0x8:\n\t\t \n\t\tconfig->ctxid_mask0 = val1;\n\t\tconfig->ctxid_mask1 = val2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\tmask = config->ctxid_mask0;\n\tfor (i = 0; i < drvdata->numcidc; i++) {\n\t\t \n\t\tmaskbyte = mask & ETMv4_EVENT_MASK;\n\t\t \n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (maskbyte & 1)\n\t\t\t\tconfig->ctxid_pid[i] &= ~(0xFFUL << (j * 8));\n\t\t\tmaskbyte >>= 1;\n\t\t}\n\t\t \n\t\tif (i == 3)\n\t\t\t \n\t\t\tmask = config->ctxid_mask1;\n\t\telse\n\t\t\tmask >>= 0x8;\n\t}\n\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(ctxid_masks);\n\nstatic ssize_t vmid_idx_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tval = config->vmid_idx;\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t vmid_idx_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\tif (val >= drvdata->numvmidc)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock(&drvdata->spinlock);\n\tconfig->vmid_idx = val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(vmid_idx);\n\nstatic ssize_t vmid_val_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\t \n\tif (!task_is_in_init_pid_ns(current))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tval = (unsigned long)config->vmid_val[config->vmid_idx];\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t vmid_val_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tunsigned long val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\t \n\tif (!task_is_in_init_pid_ns(current))\n\t\treturn -EINVAL;\n\n\t \n\tif (!drvdata->vmid_size || !drvdata->numvmidc)\n\t\treturn -EINVAL;\n\tif (kstrtoul(buf, 16, &val))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tconfig->vmid_val[config->vmid_idx] = (u64)val;\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(vmid_val);\n\nstatic ssize_t vmid_masks_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tunsigned long val1, val2;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\n\t \n\tif (!task_is_in_init_pid_ns(current))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\tval1 = config->vmid_mask0;\n\tval2 = config->vmid_mask1;\n\tspin_unlock(&drvdata->spinlock);\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx %#lx\\n\", val1, val2);\n}\n\nstatic ssize_t vmid_masks_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tu8 i, j, maskbyte;\n\tunsigned long val1, val2, mask;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct etmv4_config *config = &drvdata->config;\n\tint nr_inputs;\n\n\t \n\tif (!task_is_in_init_pid_ns(current))\n\t\treturn -EINVAL;\n\n\t \n\tif (!drvdata->vmid_size || !drvdata->numvmidc)\n\t\treturn -EINVAL;\n\t \n\tnr_inputs = sscanf(buf, \"%lx %lx\", &val1, &val2);\n\tif ((drvdata->numvmidc > 4) && (nr_inputs != 2))\n\t\treturn -EINVAL;\n\n\tspin_lock(&drvdata->spinlock);\n\n\t \n\tswitch (drvdata->numvmidc) {\n\tcase 0x1:\n\t\t \n\t\tconfig->vmid_mask0 = val1 & 0xFF;\n\t\tbreak;\n\tcase 0x2:\n\t\t \n\t\tconfig->vmid_mask0 = val1 & 0xFFFF;\n\t\tbreak;\n\tcase 0x3:\n\t\t \n\t\tconfig->vmid_mask0 = val1 & 0xFFFFFF;\n\t\tbreak;\n\tcase 0x4:\n\t\t \n\t\tconfig->vmid_mask0 = val1;\n\t\tbreak;\n\tcase 0x5:\n\t\t \n\t\tconfig->vmid_mask0 = val1;\n\t\tconfig->vmid_mask1 = val2 & 0xFF;\n\t\tbreak;\n\tcase 0x6:\n\t\t \n\t\tconfig->vmid_mask0 = val1;\n\t\tconfig->vmid_mask1 = val2 & 0xFFFF;\n\t\tbreak;\n\tcase 0x7:\n\t\t \n\t\tconfig->vmid_mask0 = val1;\n\t\tconfig->vmid_mask1 = val2 & 0xFFFFFF;\n\t\tbreak;\n\tcase 0x8:\n\t\t \n\t\tconfig->vmid_mask0 = val1;\n\t\tconfig->vmid_mask1 = val2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tmask = config->vmid_mask0;\n\tfor (i = 0; i < drvdata->numvmidc; i++) {\n\t\t \n\t\tmaskbyte = mask & ETMv4_EVENT_MASK;\n\t\t \n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (maskbyte & 1)\n\t\t\t\tconfig->vmid_val[i] &= ~(0xFFUL << (j * 8));\n\t\t\tmaskbyte >>= 1;\n\t\t}\n\t\t \n\t\tif (i == 3)\n\t\t\t \n\t\t\tmask = config->vmid_mask1;\n\t\telse\n\t\t\tmask >>= 0x8;\n\t}\n\tspin_unlock(&drvdata->spinlock);\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(vmid_masks);\n\nstatic ssize_t cpu_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->cpu;\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", val);\n\n}\nstatic DEVICE_ATTR_RO(cpu);\n\nstatic ssize_t ts_source_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tint val;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tif (!drvdata->trfcr) {\n\t\tval = -1;\n\t\tgoto out;\n\t}\n\n\tswitch (drvdata->trfcr & TRFCR_ELx_TS_MASK) {\n\tcase TRFCR_ELx_TS_VIRTUAL:\n\tcase TRFCR_ELx_TS_GUEST_PHYSICAL:\n\tcase TRFCR_ELx_TS_PHYSICAL:\n\t\tval = FIELD_GET(TRFCR_ELx_TS_MASK, drvdata->trfcr);\n\t\tbreak;\n\tdefault:\n\t\tval = -1;\n\t\tbreak;\n\t}\n\nout:\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\nstatic DEVICE_ATTR_RO(ts_source);\n\nstatic struct attribute *coresight_etmv4_attrs[] = {\n\t&dev_attr_nr_pe_cmp.attr,\n\t&dev_attr_nr_addr_cmp.attr,\n\t&dev_attr_nr_cntr.attr,\n\t&dev_attr_nr_ext_inp.attr,\n\t&dev_attr_numcidc.attr,\n\t&dev_attr_numvmidc.attr,\n\t&dev_attr_nrseqstate.attr,\n\t&dev_attr_nr_resource.attr,\n\t&dev_attr_nr_ss_cmp.attr,\n\t&dev_attr_reset.attr,\n\t&dev_attr_mode.attr,\n\t&dev_attr_pe.attr,\n\t&dev_attr_event.attr,\n\t&dev_attr_event_instren.attr,\n\t&dev_attr_event_ts.attr,\n\t&dev_attr_syncfreq.attr,\n\t&dev_attr_cyc_threshold.attr,\n\t&dev_attr_bb_ctrl.attr,\n\t&dev_attr_event_vinst.attr,\n\t&dev_attr_s_exlevel_vinst.attr,\n\t&dev_attr_ns_exlevel_vinst.attr,\n\t&dev_attr_addr_idx.attr,\n\t&dev_attr_addr_instdatatype.attr,\n\t&dev_attr_addr_single.attr,\n\t&dev_attr_addr_range.attr,\n\t&dev_attr_addr_start.attr,\n\t&dev_attr_addr_stop.attr,\n\t&dev_attr_addr_ctxtype.attr,\n\t&dev_attr_addr_context.attr,\n\t&dev_attr_addr_exlevel_s_ns.attr,\n\t&dev_attr_addr_cmp_view.attr,\n\t&dev_attr_vinst_pe_cmp_start_stop.attr,\n\t&dev_attr_sshot_idx.attr,\n\t&dev_attr_sshot_ctrl.attr,\n\t&dev_attr_sshot_pe_ctrl.attr,\n\t&dev_attr_sshot_status.attr,\n\t&dev_attr_seq_idx.attr,\n\t&dev_attr_seq_state.attr,\n\t&dev_attr_seq_event.attr,\n\t&dev_attr_seq_reset_event.attr,\n\t&dev_attr_cntr_idx.attr,\n\t&dev_attr_cntrldvr.attr,\n\t&dev_attr_cntr_val.attr,\n\t&dev_attr_cntr_ctrl.attr,\n\t&dev_attr_res_idx.attr,\n\t&dev_attr_res_ctrl.attr,\n\t&dev_attr_ctxid_idx.attr,\n\t&dev_attr_ctxid_pid.attr,\n\t&dev_attr_ctxid_masks.attr,\n\t&dev_attr_vmid_idx.attr,\n\t&dev_attr_vmid_val.attr,\n\t&dev_attr_vmid_masks.attr,\n\t&dev_attr_cpu.attr,\n\t&dev_attr_ts_source.attr,\n\tNULL,\n};\n\n \nstatic ssize_t trctraceid_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tint trace_id;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\ttrace_id = etm4_read_alloc_trace_id(drvdata);\n\tif (trace_id < 0)\n\t\treturn trace_id;\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", trace_id);\n}\n\nstruct etmv4_reg {\n\tstruct coresight_device *csdev;\n\tu32 offset;\n\tu32 data;\n};\n\nstatic void do_smp_cross_read(void *data)\n{\n\tstruct etmv4_reg *reg = data;\n\n\treg->data = etm4x_relaxed_read32(&reg->csdev->access, reg->offset);\n}\n\nstatic u32 etmv4_cross_read(const struct etmv4_drvdata *drvdata, u32 offset)\n{\n\tstruct etmv4_reg reg;\n\n\treg.offset = offset;\n\treg.csdev = drvdata->csdev;\n\n\t \n\tsmp_call_function_single(drvdata->cpu, do_smp_cross_read, &reg, 1);\n\treturn reg.data;\n}\n\nstatic inline u32 coresight_etm4x_attr_to_offset(struct device_attribute *attr)\n{\n\tstruct dev_ext_attribute *eattr;\n\n\teattr = container_of(attr, struct dev_ext_attribute, attr);\n\treturn (u32)(unsigned long)eattr->var;\n}\n\nstatic ssize_t coresight_etm4x_reg_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *d_attr,\n\t\t\t\t\tchar *buf)\n{\n\tu32 val, offset;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\toffset = coresight_etm4x_attr_to_offset(d_attr);\n\n\tpm_runtime_get_sync(dev->parent);\n\tval = etmv4_cross_read(drvdata, offset);\n\tpm_runtime_put_sync(dev->parent);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%x\\n\", val);\n}\n\nstatic inline bool\netm4x_register_implemented(struct etmv4_drvdata *drvdata, u32 offset)\n{\n\tswitch (offset) {\n\tETM_COMMON_SYSREG_LIST_CASES\n\t\t \n\t\treturn true;\n\n\tETM4x_ONLY_SYSREG_LIST_CASES\n\t\t \n\t\treturn !etm4x_is_ete(drvdata);\n\n\tETM4x_MMAP_LIST_CASES\n\t\t \n\t\treturn !!drvdata->base;\n\n\tETE_ONLY_SYSREG_LIST_CASES\n\t\treturn etm4x_is_ete(drvdata);\n\t}\n\n\treturn false;\n}\n\n \nstatic umode_t\ncoresight_etm4x_attr_reg_implemented(struct kobject *kobj,\n\t\t\t\t     struct attribute *attr, int unused)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct device_attribute *d_attr;\n\tu32 offset;\n\n\td_attr = container_of(attr, struct device_attribute, attr);\n\toffset = coresight_etm4x_attr_to_offset(d_attr);\n\n\tif (etm4x_register_implemented(drvdata, offset))\n\t\treturn attr->mode;\n\treturn 0;\n}\n\n \n#define coresight_etm4x_reg_showfn(name, offset, showfn) (\t\\\n\t&((struct dev_ext_attribute[]) {\t\t\t\\\n\t   {\t\t\t\t\t\t\t\\\n\t\t__ATTR(name, 0444, showfn, NULL),\t\t\\\n\t\t(void *)(unsigned long)offset\t\t\t\\\n\t   }\t\t\t\t\t\t\t\\\n\t})[0].attr.attr\t\t\t\t\t\t\\\n\t)\n\n \n#define coresight_etm4x_reg(name, offset)\t\\\n\tcoresight_etm4x_reg_showfn(name, offset, coresight_etm4x_reg_show)\n\nstatic struct attribute *coresight_etmv4_mgmt_attrs[] = {\n\tcoresight_etm4x_reg(trcpdcr, TRCPDCR),\n\tcoresight_etm4x_reg(trcpdsr, TRCPDSR),\n\tcoresight_etm4x_reg(trclsr, TRCLSR),\n\tcoresight_etm4x_reg(trcauthstatus, TRCAUTHSTATUS),\n\tcoresight_etm4x_reg(trcdevid, TRCDEVID),\n\tcoresight_etm4x_reg(trcdevtype, TRCDEVTYPE),\n\tcoresight_etm4x_reg(trcpidr0, TRCPIDR0),\n\tcoresight_etm4x_reg(trcpidr1, TRCPIDR1),\n\tcoresight_etm4x_reg(trcpidr2, TRCPIDR2),\n\tcoresight_etm4x_reg(trcpidr3, TRCPIDR3),\n\tcoresight_etm4x_reg(trcoslsr, TRCOSLSR),\n\tcoresight_etm4x_reg(trcconfig, TRCCONFIGR),\n\tcoresight_etm4x_reg_showfn(trctraceid, TRCTRACEIDR, trctraceid_show),\n\tcoresight_etm4x_reg(trcdevarch, TRCDEVARCH),\n\tNULL,\n};\n\nstatic struct attribute *coresight_etmv4_trcidr_attrs[] = {\n\tcoresight_etm4x_reg(trcidr0, TRCIDR0),\n\tcoresight_etm4x_reg(trcidr1, TRCIDR1),\n\tcoresight_etm4x_reg(trcidr2, TRCIDR2),\n\tcoresight_etm4x_reg(trcidr3, TRCIDR3),\n\tcoresight_etm4x_reg(trcidr4, TRCIDR4),\n\tcoresight_etm4x_reg(trcidr5, TRCIDR5),\n\t \n\tcoresight_etm4x_reg(trcidr8, TRCIDR8),\n\tcoresight_etm4x_reg(trcidr9, TRCIDR9),\n\tcoresight_etm4x_reg(trcidr10, TRCIDR10),\n\tcoresight_etm4x_reg(trcidr11, TRCIDR11),\n\tcoresight_etm4x_reg(trcidr12, TRCIDR12),\n\tcoresight_etm4x_reg(trcidr13, TRCIDR13),\n\tNULL,\n};\n\nstatic const struct attribute_group coresight_etmv4_group = {\n\t.attrs = coresight_etmv4_attrs,\n};\n\nstatic const struct attribute_group coresight_etmv4_mgmt_group = {\n\t.is_visible = coresight_etm4x_attr_reg_implemented,\n\t.attrs = coresight_etmv4_mgmt_attrs,\n\t.name = \"mgmt\",\n};\n\nstatic const struct attribute_group coresight_etmv4_trcidr_group = {\n\t.attrs = coresight_etmv4_trcidr_attrs,\n\t.name = \"trcidr\",\n};\n\nconst struct attribute_group *coresight_etmv4_groups[] = {\n\t&coresight_etmv4_group,\n\t&coresight_etmv4_mgmt_group,\n\t&coresight_etmv4_trcidr_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}