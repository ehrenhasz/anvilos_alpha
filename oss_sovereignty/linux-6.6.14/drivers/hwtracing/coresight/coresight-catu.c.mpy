{
  "module_name": "coresight-catu.c",
  "hash_id": "23ba3e899be7df8e8e257474e36bf2844e2d680625e7c12c7198179b0c91ada8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-catu.c",
  "human_readable_source": "\n \n\n#include <linux/amba/bus.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#include \"coresight-catu.h\"\n#include \"coresight-priv.h\"\n#include \"coresight-tmc.h\"\n\n#define csdev_to_catu_drvdata(csdev)\t\\\n\tdev_get_drvdata(csdev->dev.parent)\n\n \n#ifdef CATU_DEBUG\n#define catu_dbg(x, ...) dev_dbg(x, __VA_ARGS__)\n#else\n#define catu_dbg(x, ...) do {} while (0)\n#endif\n\nDEFINE_CORESIGHT_DEVLIST(catu_devs, \"catu\");\n\nstruct catu_etr_buf {\n\tstruct tmc_sg_table *catu_table;\n\tdma_addr_t sladdr;\n};\n\n \ntypedef u64 cate_t;\n\n#define CATU_PAGE_SHIFT\t\t12\n#define CATU_PAGE_SIZE\t\t(1UL << CATU_PAGE_SHIFT)\n#define CATU_PAGES_PER_SYSPAGE\t(PAGE_SIZE / CATU_PAGE_SIZE)\n\n \n#define CATU_PTRS_PER_PAGE\t((CATU_PAGE_SIZE >> 1) / sizeof(cate_t))\n#define CATU_PTRS_PER_SYSPAGE\t(CATU_PAGES_PER_SYSPAGE * CATU_PTRS_PER_PAGE)\n#define CATU_LINK_PREV\t\t((CATU_PAGE_SIZE / sizeof(cate_t)) - 2)\n#define CATU_LINK_NEXT\t\t((CATU_PAGE_SIZE / sizeof(cate_t)) - 1)\n\n#define CATU_ADDR_SHIFT\t\t12\n#define CATU_ADDR_MASK\t\t~(((cate_t)1 << CATU_ADDR_SHIFT) - 1)\n#define CATU_ENTRY_VALID\t((cate_t)0x1)\n#define CATU_VALID_ENTRY(addr) \\\n\t(((cate_t)(addr) & CATU_ADDR_MASK) | CATU_ENTRY_VALID)\n#define CATU_ENTRY_ADDR(entry)\t((cate_t)(entry) & ~((cate_t)CATU_ENTRY_VALID))\n\n \n#define CATU_DEFAULT_INADDR\t(1ULL << 20)\n\n \nstatic inline cate_t *catu_get_table(struct tmc_sg_table *catu_table,\n\t\t\t\t     unsigned long offset,\n\t\t\t\t     dma_addr_t *daddrp)\n{\n\tunsigned long buf_size = tmc_sg_table_buf_size(catu_table);\n\tunsigned int table_nr, pg_idx, pg_offset;\n\tstruct tmc_pages *table_pages = &catu_table->table_pages;\n\tvoid *ptr;\n\n\t \n\toffset %= buf_size;\n\n\t \n\ttable_nr = offset >> 20;\n\t \n\tpg_idx = table_nr / CATU_PAGES_PER_SYSPAGE;\n\tpg_offset = (table_nr % CATU_PAGES_PER_SYSPAGE) * CATU_PAGE_SIZE;\n\tif (daddrp)\n\t\t*daddrp = table_pages->daddrs[pg_idx] + pg_offset;\n\tptr = page_address(table_pages->pages[pg_idx]);\n\treturn (cate_t *)((unsigned long)ptr + pg_offset);\n}\n\n#ifdef CATU_DEBUG\nstatic void catu_dump_table(struct tmc_sg_table *catu_table)\n{\n\tint i;\n\tcate_t *table;\n\tunsigned long table_end, buf_size, offset = 0;\n\n\tbuf_size = tmc_sg_table_buf_size(catu_table);\n\tdev_dbg(catu_table->dev,\n\t\t\"Dump table %p, tdaddr: %llx\\n\",\n\t\tcatu_table, catu_table->table_daddr);\n\n\twhile (offset < buf_size) {\n\t\ttable_end = offset + SZ_1M < buf_size ?\n\t\t\t    offset + SZ_1M : buf_size;\n\t\ttable = catu_get_table(catu_table, offset, NULL);\n\t\tfor (i = 0; offset < table_end; i++, offset += CATU_PAGE_SIZE)\n\t\t\tdev_dbg(catu_table->dev, \"%d: %llx\\n\", i, table[i]);\n\t\tdev_dbg(catu_table->dev, \"Prev : %llx, Next: %llx\\n\",\n\t\t\ttable[CATU_LINK_PREV], table[CATU_LINK_NEXT]);\n\t\tdev_dbg(catu_table->dev, \"== End of sub-table ===\");\n\t}\n\tdev_dbg(catu_table->dev, \"== End of Table ===\");\n}\n\n#else\nstatic inline void catu_dump_table(struct tmc_sg_table *catu_table)\n{\n}\n#endif\n\nstatic inline cate_t catu_make_entry(dma_addr_t addr)\n{\n\treturn addr ? CATU_VALID_ENTRY(addr) : 0;\n}\n\n \nstatic void\ncatu_populate_table(struct tmc_sg_table *catu_table)\n{\n\tint i;\n\tint sys_pidx;\t \n\tint catu_pidx;\t \n\tunsigned long offset, buf_size, table_end;\n\tdma_addr_t data_daddr;\n\tdma_addr_t prev_taddr, next_taddr, cur_taddr;\n\tcate_t *table_ptr, *next_table;\n\n\tbuf_size = tmc_sg_table_buf_size(catu_table);\n\tsys_pidx = catu_pidx = 0;\n\toffset = 0;\n\n\ttable_ptr = catu_get_table(catu_table, 0, &cur_taddr);\n\tprev_taddr = 0;\t \n\n\twhile (offset < buf_size) {\n\t\t \n\t\ttable_end = (offset + SZ_1M) < buf_size ?\n\t\t\t    (offset + SZ_1M) : buf_size;\n\t\tfor (i = 0; offset < table_end;\n\t\t     i++, offset += CATU_PAGE_SIZE) {\n\n\t\t\tdata_daddr = catu_table->data_pages.daddrs[sys_pidx] +\n\t\t\t\t     catu_pidx * CATU_PAGE_SIZE;\n\t\t\tcatu_dbg(catu_table->dev,\n\t\t\t\t\"[table %5ld:%03d] 0x%llx\\n\",\n\t\t\t\t(offset >> 20), i, data_daddr);\n\t\t\ttable_ptr[i] = catu_make_entry(data_daddr);\n\t\t\t \n\t\t\tcatu_pidx = (catu_pidx + 1) % CATU_PAGES_PER_SYSPAGE;\n\t\t\tif (catu_pidx == 0)\n\t\t\t\tsys_pidx++;\n\t\t}\n\n\t\t \n\t\tif (offset == buf_size) {\n\t\t\tmemset(&table_ptr[i], 0,\n\t\t\t       sizeof(cate_t) * (CATU_PTRS_PER_PAGE - i));\n\t\t\tnext_taddr = 0;\n\t\t} else {\n\t\t\tnext_table = catu_get_table(catu_table,\n\t\t\t\t\t\t    offset, &next_taddr);\n\t\t}\n\n\t\ttable_ptr[CATU_LINK_PREV] = catu_make_entry(prev_taddr);\n\t\ttable_ptr[CATU_LINK_NEXT] = catu_make_entry(next_taddr);\n\n\t\tcatu_dbg(catu_table->dev,\n\t\t\t\"[table%5ld]: Cur: 0x%llx Prev: 0x%llx, Next: 0x%llx\\n\",\n\t\t\t(offset >> 20) - 1,  cur_taddr, prev_taddr, next_taddr);\n\n\t\t \n\t\tif (next_taddr) {\n\t\t\tprev_taddr = cur_taddr;\n\t\t\tcur_taddr = next_taddr;\n\t\t\ttable_ptr = next_table;\n\t\t}\n\t}\n\n\t \n\ttmc_sg_table_sync_table(catu_table);\n}\n\nstatic struct tmc_sg_table *\ncatu_init_sg_table(struct device *catu_dev, int node,\n\t\t   ssize_t size, void **pages)\n{\n\tint nr_tpages;\n\tstruct tmc_sg_table *catu_table;\n\n\t \n\tnr_tpages = DIV_ROUND_UP(size, SZ_1M) / CATU_PAGES_PER_SYSPAGE;\n\tcatu_table = tmc_alloc_sg_table(catu_dev, node, nr_tpages,\n\t\t\t\t\tsize >> PAGE_SHIFT, pages);\n\tif (IS_ERR(catu_table))\n\t\treturn catu_table;\n\n\tcatu_populate_table(catu_table);\n\tdev_dbg(catu_dev,\n\t\t\"Setup table %p, size %ldKB, %d table pages\\n\",\n\t\tcatu_table, (unsigned long)size >> 10,  nr_tpages);\n\tcatu_dump_table(catu_table);\n\treturn catu_table;\n}\n\nstatic void catu_free_etr_buf(struct etr_buf *etr_buf)\n{\n\tstruct catu_etr_buf *catu_buf;\n\n\tif (!etr_buf || etr_buf->mode != ETR_MODE_CATU || !etr_buf->private)\n\t\treturn;\n\n\tcatu_buf = etr_buf->private;\n\ttmc_free_sg_table(catu_buf->catu_table);\n\tkfree(catu_buf);\n}\n\nstatic ssize_t catu_get_data_etr_buf(struct etr_buf *etr_buf, u64 offset,\n\t\t\t\t     size_t len, char **bufpp)\n{\n\tstruct catu_etr_buf *catu_buf = etr_buf->private;\n\n\treturn tmc_sg_table_get_data(catu_buf->catu_table, offset, len, bufpp);\n}\n\nstatic void catu_sync_etr_buf(struct etr_buf *etr_buf, u64 rrp, u64 rwp)\n{\n\tstruct catu_etr_buf *catu_buf = etr_buf->private;\n\tstruct tmc_sg_table *catu_table = catu_buf->catu_table;\n\tu64 r_offset, w_offset;\n\n\t \n\tr_offset = rrp - etr_buf->hwaddr;\n\tw_offset = rwp - etr_buf->hwaddr;\n\n\tif (!etr_buf->full) {\n\t\tetr_buf->len = w_offset - r_offset;\n\t\tif (w_offset < r_offset)\n\t\t\tetr_buf->len += etr_buf->size;\n\t} else {\n\t\tetr_buf->len = etr_buf->size;\n\t}\n\n\tetr_buf->offset = r_offset;\n\ttmc_sg_table_sync_data_range(catu_table, r_offset, etr_buf->len);\n}\n\nstatic int catu_alloc_etr_buf(struct tmc_drvdata *tmc_drvdata,\n\t\t\t      struct etr_buf *etr_buf, int node, void **pages)\n{\n\tstruct coresight_device *csdev;\n\tstruct tmc_sg_table *catu_table;\n\tstruct catu_etr_buf *catu_buf;\n\n\tcsdev = tmc_etr_get_catu_device(tmc_drvdata);\n\tif (!csdev)\n\t\treturn -ENODEV;\n\tcatu_buf = kzalloc(sizeof(*catu_buf), GFP_KERNEL);\n\tif (!catu_buf)\n\t\treturn -ENOMEM;\n\n\tcatu_table = catu_init_sg_table(&csdev->dev, node,\n\t\t\t\t\tetr_buf->size, pages);\n\tif (IS_ERR(catu_table)) {\n\t\tkfree(catu_buf);\n\t\treturn PTR_ERR(catu_table);\n\t}\n\n\tetr_buf->mode = ETR_MODE_CATU;\n\tetr_buf->private = catu_buf;\n\tetr_buf->hwaddr = CATU_DEFAULT_INADDR;\n\n\tcatu_buf->catu_table = catu_table;\n\t \n\tcatu_buf->sladdr = catu_table->table_daddr;\n\n\treturn 0;\n}\n\nstatic const struct etr_buf_operations etr_catu_buf_ops = {\n\t.alloc = catu_alloc_etr_buf,\n\t.free = catu_free_etr_buf,\n\t.sync = catu_sync_etr_buf,\n\t.get_data = catu_get_data_etr_buf,\n};\n\nstatic struct attribute *catu_mgmt_attrs[] = {\n\tcoresight_simple_reg32(devid, CORESIGHT_DEVID),\n\tcoresight_simple_reg32(control, CATU_CONTROL),\n\tcoresight_simple_reg32(status, CATU_STATUS),\n\tcoresight_simple_reg32(mode, CATU_MODE),\n\tcoresight_simple_reg32(axictrl, CATU_AXICTRL),\n\tcoresight_simple_reg32(irqen, CATU_IRQEN),\n\tcoresight_simple_reg64(sladdr, CATU_SLADDRLO, CATU_SLADDRHI),\n\tcoresight_simple_reg64(inaddr, CATU_INADDRLO, CATU_INADDRHI),\n\tNULL,\n};\n\nstatic const struct attribute_group catu_mgmt_group = {\n\t.attrs = catu_mgmt_attrs,\n\t.name = \"mgmt\",\n};\n\nstatic const struct attribute_group *catu_groups[] = {\n\t&catu_mgmt_group,\n\tNULL,\n};\n\n\nstatic inline int catu_wait_for_ready(struct catu_drvdata *drvdata)\n{\n\tstruct csdev_access *csa = &drvdata->csdev->access;\n\n\treturn coresight_timeout(csa, CATU_STATUS, CATU_STATUS_READY, 1);\n}\n\nstatic int catu_enable_hw(struct catu_drvdata *drvdata, enum cs_mode cs_mode,\n\t\t\t  void *data)\n{\n\tint rc;\n\tu32 control, mode;\n\tstruct etr_buf *etr_buf = NULL;\n\tstruct device *dev = &drvdata->csdev->dev;\n\tstruct coresight_device *csdev = drvdata->csdev;\n\tstruct coresight_device *etrdev;\n\tunion coresight_dev_subtype etr_subtype = {\n\t\t.sink_subtype = CORESIGHT_DEV_SUBTYPE_SINK_SYSMEM\n\t};\n\n\tif (catu_wait_for_ready(drvdata))\n\t\tdev_warn(dev, \"Timeout while waiting for READY\\n\");\n\n\tcontrol = catu_read_control(drvdata);\n\tif (control & BIT(CATU_CONTROL_ENABLE)) {\n\t\tdev_warn(dev, \"CATU is already enabled\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\trc = coresight_claim_device_unlocked(csdev);\n\tif (rc)\n\t\treturn rc;\n\n\tetrdev = coresight_find_input_type(\n\t\tcsdev->pdata, CORESIGHT_DEV_TYPE_SINK, etr_subtype);\n\tif (etrdev) {\n\t\tetr_buf = tmc_etr_get_buffer(etrdev, cs_mode, data);\n\t\tif (IS_ERR(etr_buf))\n\t\t\treturn PTR_ERR(etr_buf);\n\t}\n\tcontrol |= BIT(CATU_CONTROL_ENABLE);\n\n\tif (etr_buf && etr_buf->mode == ETR_MODE_CATU) {\n\t\tstruct catu_etr_buf *catu_buf = etr_buf->private;\n\n\t\tmode = CATU_MODE_TRANSLATE;\n\t\tcatu_write_axictrl(drvdata, CATU_OS_AXICTRL);\n\t\tcatu_write_sladdr(drvdata, catu_buf->sladdr);\n\t\tcatu_write_inaddr(drvdata, CATU_DEFAULT_INADDR);\n\t} else {\n\t\tmode = CATU_MODE_PASS_THROUGH;\n\t\tcatu_write_sladdr(drvdata, 0);\n\t\tcatu_write_inaddr(drvdata, 0);\n\t}\n\n\tcatu_write_irqen(drvdata, 0);\n\tcatu_write_mode(drvdata, mode);\n\tcatu_write_control(drvdata, control);\n\tdev_dbg(dev, \"Enabled in %s mode\\n\",\n\t\t(mode == CATU_MODE_PASS_THROUGH) ?\n\t\t\"Pass through\" :\n\t\t\"Translate\");\n\treturn 0;\n}\n\nstatic int catu_enable(struct coresight_device *csdev, enum cs_mode mode,\n\t\t       void *data)\n{\n\tint rc;\n\tstruct catu_drvdata *catu_drvdata = csdev_to_catu_drvdata(csdev);\n\n\tCS_UNLOCK(catu_drvdata->base);\n\trc = catu_enable_hw(catu_drvdata, mode, data);\n\tCS_LOCK(catu_drvdata->base);\n\treturn rc;\n}\n\nstatic int catu_disable_hw(struct catu_drvdata *drvdata)\n{\n\tint rc = 0;\n\tstruct device *dev = &drvdata->csdev->dev;\n\tstruct coresight_device *csdev = drvdata->csdev;\n\n\tcatu_write_control(drvdata, 0);\n\tcoresight_disclaim_device_unlocked(csdev);\n\tif (catu_wait_for_ready(drvdata)) {\n\t\tdev_info(dev, \"Timeout while waiting for READY\\n\");\n\t\trc = -EAGAIN;\n\t}\n\n\tdev_dbg(dev, \"Disabled\\n\");\n\treturn rc;\n}\n\nstatic int catu_disable(struct coresight_device *csdev, void *__unused)\n{\n\tint rc;\n\tstruct catu_drvdata *catu_drvdata = csdev_to_catu_drvdata(csdev);\n\n\tCS_UNLOCK(catu_drvdata->base);\n\trc = catu_disable_hw(catu_drvdata);\n\tCS_LOCK(catu_drvdata->base);\n\treturn rc;\n}\n\nstatic const struct coresight_ops_helper catu_helper_ops = {\n\t.enable = catu_enable,\n\t.disable = catu_disable,\n};\n\nstatic const struct coresight_ops catu_ops = {\n\t.helper_ops = &catu_helper_ops,\n};\n\nstatic int catu_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tint ret = 0;\n\tu32 dma_mask;\n\tstruct catu_drvdata *drvdata;\n\tstruct coresight_desc catu_desc;\n\tstruct coresight_platform_data *pdata = NULL;\n\tstruct device *dev = &adev->dev;\n\tvoid __iomem *base;\n\n\tcatu_desc.name = coresight_alloc_device_name(&catu_devs, dev);\n\tif (!catu_desc.name)\n\t\treturn -ENOMEM;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdev_set_drvdata(dev, drvdata);\n\tbase = devm_ioremap_resource(dev, &adev->res);\n\tif (IS_ERR(base)) {\n\t\tret = PTR_ERR(base);\n\t\tgoto out;\n\t}\n\n\t \n\tdma_mask = readl_relaxed(base + CORESIGHT_DEVID) & 0x3f;\n\tswitch (dma_mask) {\n\tcase 32:\n\tcase 40:\n\tcase 44:\n\tcase 48:\n\tcase 52:\n\tcase 56:\n\tcase 64:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdma_mask = 40;\n\t}\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(dma_mask));\n\tif (ret)\n\t\tgoto out;\n\n\tpdata = coresight_get_platform_data(dev);\n\tif (IS_ERR(pdata)) {\n\t\tret = PTR_ERR(pdata);\n\t\tgoto out;\n\t}\n\tdev->platform_data = pdata;\n\n\tdrvdata->base = base;\n\tcatu_desc.access = CSDEV_ACCESS_IOMEM(base);\n\tcatu_desc.pdata = pdata;\n\tcatu_desc.dev = dev;\n\tcatu_desc.groups = catu_groups;\n\tcatu_desc.type = CORESIGHT_DEV_TYPE_HELPER;\n\tcatu_desc.subtype.helper_subtype = CORESIGHT_DEV_SUBTYPE_HELPER_CATU;\n\tcatu_desc.ops = &catu_ops;\n\n\tdrvdata->csdev = coresight_register(&catu_desc);\n\tif (IS_ERR(drvdata->csdev))\n\t\tret = PTR_ERR(drvdata->csdev);\n\telse\n\t\tpm_runtime_put(&adev->dev);\nout:\n\treturn ret;\n}\n\nstatic void catu_remove(struct amba_device *adev)\n{\n\tstruct catu_drvdata *drvdata = dev_get_drvdata(&adev->dev);\n\n\tcoresight_unregister(drvdata->csdev);\n}\n\nstatic struct amba_id catu_ids[] = {\n\tCS_AMBA_ID(0x000bb9ee),\n\t{},\n};\n\nMODULE_DEVICE_TABLE(amba, catu_ids);\n\nstatic struct amba_driver catu_driver = {\n\t.drv = {\n\t\t.name\t\t\t= \"coresight-catu\",\n\t\t.owner\t\t\t= THIS_MODULE,\n\t\t.suppress_bind_attrs\t= true,\n\t},\n\t.probe\t\t\t\t= catu_probe,\n\t.remove\t\t\t\t= catu_remove,\n\t.id_table\t\t\t= catu_ids,\n};\n\nstatic int __init catu_init(void)\n{\n\tint ret;\n\n\tret = amba_driver_register(&catu_driver);\n\tif (ret)\n\t\tpr_info(\"Error registering catu driver\\n\");\n\ttmc_etr_set_catu_ops(&etr_catu_buf_ops);\n\treturn ret;\n}\n\nstatic void __exit catu_exit(void)\n{\n\ttmc_etr_remove_catu_ops();\n\tamba_driver_unregister(&catu_driver);\n}\n\nmodule_init(catu_init);\nmodule_exit(catu_exit);\n\nMODULE_AUTHOR(\"Suzuki K Poulose <suzuki.poulose@arm.com>\");\nMODULE_DESCRIPTION(\"Arm CoreSight Address Translation Unit (CATU) Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}