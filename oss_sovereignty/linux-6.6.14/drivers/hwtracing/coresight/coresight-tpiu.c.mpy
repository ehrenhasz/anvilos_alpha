{
  "module_name": "coresight-tpiu.c",
  "hash_id": "c991ab91db1588620d241b8b6687a0e982b6b3fcaf290c8adc46856da697b1bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-tpiu.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/coresight.h>\n#include <linux/amba/bus.h>\n#include <linux/clk.h>\n\n#include \"coresight-priv.h\"\n\n#define TPIU_SUPP_PORTSZ\t0x000\n#define TPIU_CURR_PORTSZ\t0x004\n#define TPIU_SUPP_TRIGMODES\t0x100\n#define TPIU_TRIG_CNTRVAL\t0x104\n#define TPIU_TRIG_MULT\t\t0x108\n#define TPIU_SUPP_TESTPATM\t0x200\n#define TPIU_CURR_TESTPATM\t0x204\n#define TPIU_TEST_PATREPCNTR\t0x208\n#define TPIU_FFSR\t\t0x300\n#define TPIU_FFCR\t\t0x304\n#define TPIU_FSYNC_CNTR\t\t0x308\n#define TPIU_EXTCTL_INPORT\t0x400\n#define TPIU_EXTCTL_OUTPORT\t0x404\n#define TPIU_ITTRFLINACK\t0xee4\n#define TPIU_ITTRFLIN\t\t0xee8\n#define TPIU_ITATBDATA0\t\t0xeec\n#define TPIU_ITATBCTR2\t\t0xef0\n#define TPIU_ITATBCTR1\t\t0xef4\n#define TPIU_ITATBCTR0\t\t0xef8\n\n \n \n#define FFSR_FT_STOPPED_BIT\t1\n \n#define FFCR_FON_MAN_BIT\t6\n#define FFCR_FON_MAN\t\tBIT(6)\n#define FFCR_STOP_FI\t\tBIT(12)\n\nDEFINE_CORESIGHT_DEVLIST(tpiu_devs, \"tpiu\");\n\n \nstruct tpiu_drvdata {\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*atclk;\n\tstruct coresight_device\t*csdev;\n};\n\nstatic void tpiu_enable_hw(struct csdev_access *csa)\n{\n\tCS_UNLOCK(csa->base);\n\n\t \n\n\tCS_LOCK(csa->base);\n}\n\nstatic int tpiu_enable(struct coresight_device *csdev, enum cs_mode mode,\n\t\t       void *__unused)\n{\n\ttpiu_enable_hw(&csdev->access);\n\tatomic_inc(&csdev->refcnt);\n\tdev_dbg(&csdev->dev, \"TPIU enabled\\n\");\n\treturn 0;\n}\n\nstatic void tpiu_disable_hw(struct csdev_access *csa)\n{\n\tCS_UNLOCK(csa->base);\n\n\t \n\tcsdev_access_relaxed_write32(csa, FFCR_STOP_FI, TPIU_FFCR);\n\t \n\tcsdev_access_relaxed_write32(csa, FFCR_STOP_FI | FFCR_FON_MAN, TPIU_FFCR);\n\t \n\tcoresight_timeout(csa, TPIU_FFCR, FFCR_FON_MAN_BIT, 0);\n\t \n\tcoresight_timeout(csa, TPIU_FFSR, FFSR_FT_STOPPED_BIT, 1);\n\n\tCS_LOCK(csa->base);\n}\n\nstatic int tpiu_disable(struct coresight_device *csdev)\n{\n\tif (atomic_dec_return(&csdev->refcnt))\n\t\treturn -EBUSY;\n\n\ttpiu_disable_hw(&csdev->access);\n\n\tdev_dbg(&csdev->dev, \"TPIU disabled\\n\");\n\treturn 0;\n}\n\nstatic const struct coresight_ops_sink tpiu_sink_ops = {\n\t.enable\t\t= tpiu_enable,\n\t.disable\t= tpiu_disable,\n};\n\nstatic const struct coresight_ops tpiu_cs_ops = {\n\t.sink_ops\t= &tpiu_sink_ops,\n};\n\nstatic int tpiu_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tint ret;\n\tvoid __iomem *base;\n\tstruct device *dev = &adev->dev;\n\tstruct coresight_platform_data *pdata = NULL;\n\tstruct tpiu_drvdata *drvdata;\n\tstruct resource *res = &adev->res;\n\tstruct coresight_desc desc = { 0 };\n\n\tdesc.name = coresight_alloc_device_name(&tpiu_devs, dev);\n\tif (!desc.name)\n\t\treturn -ENOMEM;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->atclk = devm_clk_get(&adev->dev, \"atclk\");  \n\tif (!IS_ERR(drvdata->atclk)) {\n\t\tret = clk_prepare_enable(drvdata->atclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tdev_set_drvdata(dev, drvdata);\n\n\t \n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdrvdata->base = base;\n\tdesc.access = CSDEV_ACCESS_IOMEM(base);\n\n\t \n\ttpiu_disable_hw(&desc.access);\n\n\tpdata = coresight_get_platform_data(dev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\tdev->platform_data = pdata;\n\n\tdesc.type = CORESIGHT_DEV_TYPE_SINK;\n\tdesc.subtype.sink_subtype = CORESIGHT_DEV_SUBTYPE_SINK_PORT;\n\tdesc.ops = &tpiu_cs_ops;\n\tdesc.pdata = pdata;\n\tdesc.dev = dev;\n\tdrvdata->csdev = coresight_register(&desc);\n\n\tif (!IS_ERR(drvdata->csdev)) {\n\t\tpm_runtime_put(&adev->dev);\n\t\treturn 0;\n\t}\n\n\treturn PTR_ERR(drvdata->csdev);\n}\n\nstatic void tpiu_remove(struct amba_device *adev)\n{\n\tstruct tpiu_drvdata *drvdata = dev_get_drvdata(&adev->dev);\n\n\tcoresight_unregister(drvdata->csdev);\n}\n\n#ifdef CONFIG_PM\nstatic int tpiu_runtime_suspend(struct device *dev)\n{\n\tstruct tpiu_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tif (drvdata && !IS_ERR(drvdata->atclk))\n\t\tclk_disable_unprepare(drvdata->atclk);\n\n\treturn 0;\n}\n\nstatic int tpiu_runtime_resume(struct device *dev)\n{\n\tstruct tpiu_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tif (drvdata && !IS_ERR(drvdata->atclk))\n\t\tclk_prepare_enable(drvdata->atclk);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops tpiu_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tpiu_runtime_suspend, tpiu_runtime_resume, NULL)\n};\n\nstatic const struct amba_id tpiu_ids[] = {\n\t{\n\t\t.id\t= 0x000bb912,\n\t\t.mask\t= 0x000fffff,\n\t},\n\t{\n\t\t.id\t= 0x0004b912,\n\t\t.mask\t= 0x0007ffff,\n\t},\n\t{\n\t\t \n\t\t.id\t= 0x000bb9e7,\n\t\t.mask\t= 0x000fffff,\n\t},\n\t{ 0, 0},\n};\n\nMODULE_DEVICE_TABLE(amba, tpiu_ids);\n\nstatic struct amba_driver tpiu_driver = {\n\t.drv = {\n\t\t.name\t= \"coresight-tpiu\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= &tpiu_dev_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= tpiu_probe,\n\t.remove         = tpiu_remove,\n\t.id_table\t= tpiu_ids,\n};\n\nmodule_amba_driver(tpiu_driver);\n\nMODULE_AUTHOR(\"Pratik Patel <pratikp@codeaurora.org>\");\nMODULE_AUTHOR(\"Mathieu Poirier <mathieu.poirier@linaro.org>\");\nMODULE_DESCRIPTION(\"Arm CoreSight TPIU (Trace Port Interface Unit) driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}