{
  "module_name": "coresight-cti-core.c",
  "hash_id": "778ae2ca84af5283bcc598c441b0702f4834656705c35261d17b410015de8456",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-cti-core.c",
  "human_readable_source": "\n \n\n#include <linux/amba/bus.h>\n#include <linux/atomic.h>\n#include <linux/bits.h>\n#include <linux/coresight.h>\n#include <linux/cpu_pm.h>\n#include <linux/cpuhotplug.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/spinlock.h>\n\n#include \"coresight-priv.h\"\n#include \"coresight-cti.h\"\n\n \n\n \nstatic LIST_HEAD(ect_net);\n\n \nstatic DEFINE_MUTEX(ect_mutex);\n\n#define csdev_to_cti_drvdata(csdev)\t\\\n\tdev_get_drvdata(csdev->dev.parent)\n\n \nstatic int nr_cti_cpu;\n\n \nstatic struct cti_drvdata *cti_cpu_drvdata[NR_CPUS];\n\n \nDEFINE_CORESIGHT_DEVLIST(cti_sys_devs, \"cti_sys\");\n\n \nvoid cti_write_all_hw_regs(struct cti_drvdata *drvdata)\n{\n\tstruct cti_config *config = &drvdata->config;\n\tint i;\n\n\tCS_UNLOCK(drvdata->base);\n\n\t \n\twritel_relaxed(0, drvdata->base + CTICONTROL);\n\n\t \n\tfor (i = 0; i < config->nr_trig_max; i++) {\n\t\twritel_relaxed(config->ctiinen[i], drvdata->base + CTIINEN(i));\n\t\twritel_relaxed(config->ctiouten[i],\n\t\t\t       drvdata->base + CTIOUTEN(i));\n\t}\n\n\t \n\twritel_relaxed(config->ctigate, drvdata->base + CTIGATE);\n\twritel_relaxed(config->asicctl, drvdata->base + ASICCTL);\n\twritel_relaxed(config->ctiappset, drvdata->base + CTIAPPSET);\n\n\t \n\twritel_relaxed(1, drvdata->base + CTICONTROL);\n\n\tCS_LOCK(drvdata->base);\n}\n\n \nstatic int cti_enable_hw(struct cti_drvdata *drvdata)\n{\n\tstruct cti_config *config = &drvdata->config;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\n\t \n\tif (config->hw_enabled || !config->hw_powered)\n\t\tgoto cti_state_unchanged;\n\n\t \n\trc = coresight_claim_device(drvdata->csdev);\n\tif (rc)\n\t\tgoto cti_err_not_enabled;\n\n\tcti_write_all_hw_regs(drvdata);\n\n\tconfig->hw_enabled = true;\n\tdrvdata->config.enable_req_count++;\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\treturn rc;\n\ncti_state_unchanged:\n\tdrvdata->config.enable_req_count++;\n\n\t \ncti_err_not_enabled:\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\treturn rc;\n}\n\n \nstatic void cti_cpuhp_enable_hw(struct cti_drvdata *drvdata)\n{\n\tstruct cti_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\tconfig->hw_powered = true;\n\n\t \n\tif (!drvdata->config.enable_req_count)\n\t\tgoto cti_hp_not_enabled;\n\n\t \n\tif (coresight_claim_device(drvdata->csdev))\n\t\tgoto cti_hp_not_enabled;\n\n\tcti_write_all_hw_regs(drvdata);\n\tconfig->hw_enabled = true;\n\tspin_unlock(&drvdata->spinlock);\n\treturn;\n\n\t \ncti_hp_not_enabled:\n\tspin_unlock(&drvdata->spinlock);\n}\n\n \nstatic int cti_disable_hw(struct cti_drvdata *drvdata)\n{\n\tstruct cti_config *config = &drvdata->config;\n\tstruct coresight_device *csdev = drvdata->csdev;\n\tint ret = 0;\n\n\tspin_lock(&drvdata->spinlock);\n\n\t \n\tif (!drvdata->config.enable_req_count) {\n\t\tret = -EINVAL;\n\t\tgoto cti_not_disabled;\n\t}\n\n\t \n\tif (--drvdata->config.enable_req_count > 0)\n\t\tgoto cti_not_disabled;\n\n\t \n\tif (!config->hw_enabled || !config->hw_powered)\n\t\tgoto cti_not_disabled;\n\n\tCS_UNLOCK(drvdata->base);\n\n\t \n\twritel_relaxed(0, drvdata->base + CTICONTROL);\n\tconfig->hw_enabled = false;\n\n\tcoresight_disclaim_device_unlocked(csdev);\n\tCS_LOCK(drvdata->base);\n\tspin_unlock(&drvdata->spinlock);\n\treturn ret;\n\n\t \ncti_not_disabled:\n\tspin_unlock(&drvdata->spinlock);\n\treturn ret;\n}\n\nvoid cti_write_single_reg(struct cti_drvdata *drvdata, int offset, u32 value)\n{\n\tCS_UNLOCK(drvdata->base);\n\twritel_relaxed(value, drvdata->base + offset);\n\tCS_LOCK(drvdata->base);\n}\n\nvoid cti_write_intack(struct device *dev, u32 ackval)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *config = &drvdata->config;\n\n\tspin_lock(&drvdata->spinlock);\n\t \n\tif (cti_active(config))\n\t\tcti_write_single_reg(drvdata, CTIINTACK, ackval);\n\tspin_unlock(&drvdata->spinlock);\n}\n\n \n#define CTI_DEVID_MAXTRIGS(devid_val) ((int) BMVAL(devid_val, 8, 15))\n\n \n#define CTI_DEVID_CTMCHANNELS(devid_val) ((int) BMVAL(devid_val, 16, 19))\n\nstatic void cti_set_default_config(struct device *dev,\n\t\t\t\t   struct cti_drvdata *drvdata)\n{\n\tstruct cti_config *config = &drvdata->config;\n\tu32 devid;\n\n\tdevid = readl_relaxed(drvdata->base + CORESIGHT_DEVID);\n\tconfig->nr_trig_max = CTI_DEVID_MAXTRIGS(devid);\n\n\t \n\tif (config->nr_trig_max > CTIINOUTEN_MAX) {\n\t\tdev_warn_once(dev,\n\t\t\t\"Limiting HW MaxTrig value(%d) to driver max(%d)\\n\",\n\t\t\tconfig->nr_trig_max, CTIINOUTEN_MAX);\n\t\tconfig->nr_trig_max = CTIINOUTEN_MAX;\n\t}\n\n\tconfig->nr_ctm_channels = CTI_DEVID_CTMCHANNELS(devid);\n\n\t \n\tconfig->trig_filter_enable = true;\n\tconfig->ctigate = GENMASK(config->nr_ctm_channels - 1, 0);\n\tconfig->enable_req_count = 0;\n}\n\n \nint cti_add_connection_entry(struct device *dev, struct cti_drvdata *drvdata,\n\t\t\t     struct cti_trig_con *tc,\n\t\t\t     struct coresight_device *csdev,\n\t\t\t     const char *assoc_dev_name)\n{\n\tstruct cti_device *cti_dev = &drvdata->ctidev;\n\n\ttc->con_dev = csdev;\n\t \n\tif (csdev)\n\t\ttc->con_dev_name = dev_name(&csdev->dev);\n\telse if (assoc_dev_name != NULL) {\n\t\ttc->con_dev_name = devm_kstrdup(dev,\n\t\t\t\t\t\tassoc_dev_name, GFP_KERNEL);\n\t\tif (!tc->con_dev_name)\n\t\t\treturn -ENOMEM;\n\t}\n\tlist_add_tail(&tc->node, &cti_dev->trig_cons);\n\tcti_dev->nr_trig_con++;\n\n\t \n\tdrvdata->config.trig_in_use |= tc->con_in->used_mask;\n\tdrvdata->config.trig_out_use |= tc->con_out->used_mask;\n\n\treturn 0;\n}\n\n \nstruct cti_trig_con *cti_allocate_trig_con(struct device *dev, int in_sigs,\n\t\t\t\t\t   int out_sigs)\n{\n\tstruct cti_trig_con *tc = NULL;\n\tstruct cti_trig_grp *in = NULL, *out = NULL;\n\n\ttc = devm_kzalloc(dev, sizeof(struct cti_trig_con), GFP_KERNEL);\n\tif (!tc)\n\t\treturn tc;\n\n\tin = devm_kzalloc(dev,\n\t\t\t  offsetof(struct cti_trig_grp, sig_types[in_sigs]),\n\t\t\t  GFP_KERNEL);\n\tif (!in)\n\t\treturn NULL;\n\n\tout = devm_kzalloc(dev,\n\t\t\t   offsetof(struct cti_trig_grp, sig_types[out_sigs]),\n\t\t\t   GFP_KERNEL);\n\tif (!out)\n\t\treturn NULL;\n\n\ttc->con_in = in;\n\ttc->con_out = out;\n\ttc->con_in->nr_sigs = in_sigs;\n\ttc->con_out->nr_sigs = out_sigs;\n\treturn tc;\n}\n\n \nint cti_add_default_connection(struct device *dev, struct cti_drvdata *drvdata)\n{\n\tint ret = 0;\n\tint n_trigs = drvdata->config.nr_trig_max;\n\tu32 n_trig_mask = GENMASK(n_trigs - 1, 0);\n\tstruct cti_trig_con *tc = NULL;\n\n\t \n\ttc = cti_allocate_trig_con(dev, n_trigs, n_trigs);\n\tif (!tc)\n\t\treturn -ENOMEM;\n\n\ttc->con_in->used_mask = n_trig_mask;\n\ttc->con_out->used_mask = n_trig_mask;\n\tret = cti_add_connection_entry(dev, drvdata, tc, NULL, \"default\");\n\treturn ret;\n}\n\n \n \nint cti_channel_trig_op(struct device *dev, enum cti_chan_op op,\n\t\t\tenum cti_trig_dir direction, u32 channel_idx,\n\t\t\tu32 trigger_idx)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *config = &drvdata->config;\n\tu32 trig_bitmask;\n\tu32 chan_bitmask;\n\tu32 reg_value;\n\tint reg_offset;\n\n\t \n\tif ((channel_idx >= config->nr_ctm_channels) ||\n\t   (trigger_idx >= config->nr_trig_max))\n\t\treturn -EINVAL;\n\n\ttrig_bitmask = BIT(trigger_idx);\n\n\t \n\tif (direction == CTI_TRIG_IN)\t{\n\t\tif (!(trig_bitmask & config->trig_in_use))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(trig_bitmask & config->trig_out_use))\n\t\t\treturn -EINVAL;\n\n\t\tif ((config->trig_filter_enable) &&\n\t\t    (config->trig_out_filter & trig_bitmask))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tchan_bitmask = BIT(channel_idx);\n\treg_offset = (direction == CTI_TRIG_IN ? CTIINEN(trigger_idx) :\n\t\t      CTIOUTEN(trigger_idx));\n\n\tspin_lock(&drvdata->spinlock);\n\n\t \n\treg_value = direction == CTI_TRIG_IN ? config->ctiinen[trigger_idx] :\n\t\t     config->ctiouten[trigger_idx];\n\tif (op == CTI_CHAN_ATTACH)\n\t\treg_value |= chan_bitmask;\n\telse\n\t\treg_value &= ~chan_bitmask;\n\n\t \n\tif (direction == CTI_TRIG_IN)\n\t\tconfig->ctiinen[trigger_idx] = reg_value;\n\telse\n\t\tconfig->ctiouten[trigger_idx] = reg_value;\n\n\t \n\tif (cti_active(config))\n\t\tcti_write_single_reg(drvdata, reg_offset, reg_value);\n\tspin_unlock(&drvdata->spinlock);\n\treturn 0;\n}\n\nint cti_channel_gate_op(struct device *dev, enum cti_chan_gate_op op,\n\t\t\tu32 channel_idx)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *config = &drvdata->config;\n\tu32 chan_bitmask;\n\tu32 reg_value;\n\tint err = 0;\n\n\tif (channel_idx >= config->nr_ctm_channels)\n\t\treturn -EINVAL;\n\n\tchan_bitmask = BIT(channel_idx);\n\n\tspin_lock(&drvdata->spinlock);\n\treg_value = config->ctigate;\n\tswitch (op) {\n\tcase CTI_GATE_CHAN_ENABLE:\n\t\treg_value |= chan_bitmask;\n\t\tbreak;\n\n\tcase CTI_GATE_CHAN_DISABLE:\n\t\treg_value &= ~chan_bitmask;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tif (err == 0) {\n\t\tconfig->ctigate = reg_value;\n\t\tif (cti_active(config))\n\t\t\tcti_write_single_reg(drvdata, CTIGATE, reg_value);\n\t}\n\tspin_unlock(&drvdata->spinlock);\n\treturn err;\n}\n\nint cti_channel_setop(struct device *dev, enum cti_chan_set_op op,\n\t\t      u32 channel_idx)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_config *config = &drvdata->config;\n\tu32 chan_bitmask;\n\tu32 reg_value;\n\tu32 reg_offset;\n\tint err = 0;\n\n\tif (channel_idx >= config->nr_ctm_channels)\n\t\treturn -EINVAL;\n\n\tchan_bitmask = BIT(channel_idx);\n\n\tspin_lock(&drvdata->spinlock);\n\treg_value = config->ctiappset;\n\tswitch (op) {\n\tcase CTI_CHAN_SET:\n\t\tconfig->ctiappset |= chan_bitmask;\n\t\treg_value  = config->ctiappset;\n\t\treg_offset = CTIAPPSET;\n\t\tbreak;\n\n\tcase CTI_CHAN_CLR:\n\t\tconfig->ctiappset &= ~chan_bitmask;\n\t\treg_value = chan_bitmask;\n\t\treg_offset = CTIAPPCLEAR;\n\t\tbreak;\n\n\tcase CTI_CHAN_PULSE:\n\t\tconfig->ctiappset &= ~chan_bitmask;\n\t\treg_value = chan_bitmask;\n\t\treg_offset = CTIAPPPULSE;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif ((err == 0) && cti_active(config))\n\t\tcti_write_single_reg(drvdata, reg_offset, reg_value);\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn err;\n}\n\nstatic bool cti_add_sysfs_link(struct cti_drvdata *drvdata,\n\t\t\t       struct cti_trig_con *tc)\n{\n\tstruct coresight_sysfs_link link_info;\n\tint link_err = 0;\n\n\tlink_info.orig = drvdata->csdev;\n\tlink_info.orig_name = tc->con_dev_name;\n\tlink_info.target = tc->con_dev;\n\tlink_info.target_name = dev_name(&drvdata->csdev->dev);\n\n\tlink_err = coresight_add_sysfs_link(&link_info);\n\tif (link_err)\n\t\tdev_warn(&drvdata->csdev->dev,\n\t\t\t \"Failed to set CTI sysfs link %s<=>%s\\n\",\n\t\t\t link_info.orig_name, link_info.target_name);\n\treturn !link_err;\n}\n\nstatic void cti_remove_sysfs_link(struct cti_drvdata *drvdata,\n\t\t\t\t  struct cti_trig_con *tc)\n{\n\tstruct coresight_sysfs_link link_info;\n\n\tlink_info.orig = drvdata->csdev;\n\tlink_info.orig_name = tc->con_dev_name;\n\tlink_info.target = tc->con_dev;\n\tlink_info.target_name = dev_name(&drvdata->csdev->dev);\n\tcoresight_remove_sysfs_link(&link_info);\n}\n\n \nstatic bool\ncti_match_fixup_csdev(struct cti_device *ctidev, const char *node_name,\n\t\t      struct coresight_device *csdev)\n{\n\tstruct cti_trig_con *tc;\n\tstruct cti_drvdata *drvdata = container_of(ctidev, struct cti_drvdata,\n\t\t\t\t\t\t   ctidev);\n\n\tlist_for_each_entry(tc, &ctidev->trig_cons, node) {\n\t\tif (tc->con_dev_name) {\n\t\t\tif (!strcmp(node_name, tc->con_dev_name)) {\n\t\t\t\t \n\t\t\t\ttc->con_dev_name = dev_name(&csdev->dev);\n\t\t\t\ttc->con_dev = csdev;\n\t\t\t\t \n\t\t\t\tif (cti_add_sysfs_link(drvdata, tc))\n\t\t\t\t\treturn true;\n\t\t\t\t \n\t\t\t\ttc->con_dev = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n \nstatic void cti_add_assoc_to_csdev(struct coresight_device *csdev)\n{\n\tstruct cti_drvdata *ect_item;\n\tstruct cti_device *ctidev;\n\tconst char *node_name = NULL;\n\n\t \n\tmutex_lock(&ect_mutex);\n\n\t \n\tif ((csdev->type == CORESIGHT_DEV_TYPE_HELPER &&\n\t     csdev->subtype.helper_subtype ==\n\t\t     CORESIGHT_DEV_SUBTYPE_HELPER_ECT_CTI) ||\n\t    list_empty(&ect_net))\n\t\tgoto cti_add_done;\n\n\t \n\tnode_name = cti_plat_get_node_name(dev_fwnode(csdev->dev.parent));\n\tif (!node_name)\n\t\tgoto cti_add_done;\n\n\t \n\tlist_for_each_entry(ect_item, &ect_net, node) {\n\t\tctidev = &ect_item->ctidev;\n\t\tif (cti_match_fixup_csdev(ctidev, node_name, csdev)) {\n\t\t\t \n\t\t\tcoresight_add_helper(csdev, ect_item->csdev);\n\t\t\tbreak;\n\t\t}\n\t}\ncti_add_done:\n\tmutex_unlock(&ect_mutex);\n}\n\n \nstatic void cti_remove_assoc_from_csdev(struct coresight_device *csdev)\n{\n\tstruct cti_drvdata *ctidrv;\n\tstruct cti_trig_con *tc;\n\tstruct cti_device *ctidev;\n\tunion coresight_dev_subtype cti_subtype = {\n\t\t.helper_subtype = CORESIGHT_DEV_SUBTYPE_HELPER_ECT_CTI\n\t};\n\tstruct coresight_device *cti_csdev = coresight_find_output_type(\n\t\tcsdev->pdata, CORESIGHT_DEV_TYPE_HELPER, cti_subtype);\n\n\tif (!cti_csdev)\n\t\treturn;\n\n\tmutex_lock(&ect_mutex);\n\tctidrv = csdev_to_cti_drvdata(cti_csdev);\n\tctidev = &ctidrv->ctidev;\n\tlist_for_each_entry(tc, &ctidev->trig_cons, node) {\n\t\tif (tc->con_dev == csdev) {\n\t\t\tcti_remove_sysfs_link(ctidrv, tc);\n\t\t\ttc->con_dev = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ect_mutex);\n}\n\n \nstatic struct cti_assoc_op cti_assoc_ops = {\n\t.add = cti_add_assoc_to_csdev,\n\t.remove = cti_remove_assoc_from_csdev\n};\n\n \nstatic void cti_update_conn_xrefs(struct cti_drvdata *drvdata)\n{\n\tstruct cti_trig_con *tc;\n\tstruct cti_device *ctidev = &drvdata->ctidev;\n\n\tlist_for_each_entry(tc, &ctidev->trig_cons, node) {\n\t\tif (tc->con_dev) {\n\t\t\t \n\t\t\tif (cti_add_sysfs_link(drvdata, tc))\n\t\t\t\t \n\t\t\t\tcoresight_add_helper(tc->con_dev,\n\t\t\t\t\t\t     drvdata->csdev);\n\t\t\telse\n\t\t\t\t \n\t\t\t\ttc->con_dev = NULL;\n\t\t}\n\t}\n}\n\nstatic void cti_remove_conn_xrefs(struct cti_drvdata *drvdata)\n{\n\tstruct cti_trig_con *tc;\n\tstruct cti_device *ctidev = &drvdata->ctidev;\n\n\tlist_for_each_entry(tc, &ctidev->trig_cons, node) {\n\t\tif (tc->con_dev) {\n\t\t\tcti_remove_sysfs_link(drvdata, tc);\n\t\t\ttc->con_dev = NULL;\n\t\t}\n\t}\n}\n\n \nstatic int cti_cpu_pm_notify(struct notifier_block *nb, unsigned long cmd,\n\t\t\t     void *v)\n{\n\tstruct cti_drvdata *drvdata;\n\tstruct coresight_device *csdev;\n\tunsigned int cpu = smp_processor_id();\n\tint notify_res = NOTIFY_OK;\n\n\tif (!cti_cpu_drvdata[cpu])\n\t\treturn NOTIFY_OK;\n\n\tdrvdata = cti_cpu_drvdata[cpu];\n\tcsdev = drvdata->csdev;\n\n\tif (WARN_ON_ONCE(drvdata->ctidev.cpu != cpu))\n\t\treturn NOTIFY_BAD;\n\n\tspin_lock(&drvdata->spinlock);\n\n\tswitch (cmd) {\n\tcase CPU_PM_ENTER:\n\t\t \n\t\tdrvdata->config.hw_powered = false;\n\t\tif (drvdata->config.hw_enabled)\n\t\t\tcoresight_disclaim_device(csdev);\n\t\tbreak;\n\n\tcase CPU_PM_ENTER_FAILED:\n\t\tdrvdata->config.hw_powered = true;\n\t\tif (drvdata->config.hw_enabled) {\n\t\t\tif (coresight_claim_device(csdev))\n\t\t\t\tdrvdata->config.hw_enabled = false;\n\t\t}\n\t\tbreak;\n\n\tcase CPU_PM_EXIT:\n\t\t \n\t\tdrvdata->config.hw_powered = true;\n\t\tdrvdata->config.hw_enabled = false;\n\n\t\t \n\t\tif (drvdata->config.enable_req_count) {\n\t\t\t \n\t\t\tif (coresight_claim_device(csdev))\n\t\t\t\tgoto cti_notify_exit;\n\n\t\t\tdrvdata->config.hw_enabled = true;\n\t\t\tcti_write_all_hw_regs(drvdata);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tnotify_res = NOTIFY_DONE;\n\t\tbreak;\n\t}\n\ncti_notify_exit:\n\tspin_unlock(&drvdata->spinlock);\n\treturn notify_res;\n}\n\nstatic struct notifier_block cti_cpu_pm_nb = {\n\t.notifier_call = cti_cpu_pm_notify,\n};\n\n \nstatic int cti_starting_cpu(unsigned int cpu)\n{\n\tstruct cti_drvdata *drvdata = cti_cpu_drvdata[cpu];\n\n\tif (!drvdata)\n\t\treturn 0;\n\n\tcti_cpuhp_enable_hw(drvdata);\n\treturn 0;\n}\n\nstatic int cti_dying_cpu(unsigned int cpu)\n{\n\tstruct cti_drvdata *drvdata = cti_cpu_drvdata[cpu];\n\n\tif (!drvdata)\n\t\treturn 0;\n\n\tspin_lock(&drvdata->spinlock);\n\tdrvdata->config.hw_powered = false;\n\tif (drvdata->config.hw_enabled)\n\t\tcoresight_disclaim_device(drvdata->csdev);\n\tspin_unlock(&drvdata->spinlock);\n\treturn 0;\n}\n\nstatic int cti_pm_setup(struct cti_drvdata *drvdata)\n{\n\tint ret;\n\n\tif (drvdata->ctidev.cpu == -1)\n\t\treturn 0;\n\n\tif (nr_cti_cpu)\n\t\tgoto done;\n\n\tcpus_read_lock();\n\tret = cpuhp_setup_state_nocalls_cpuslocked(\n\t\t\tCPUHP_AP_ARM_CORESIGHT_CTI_STARTING,\n\t\t\t\"arm/coresight_cti:starting\",\n\t\t\tcti_starting_cpu, cti_dying_cpu);\n\tif (ret) {\n\t\tcpus_read_unlock();\n\t\treturn ret;\n\t}\n\n\tret = cpu_pm_register_notifier(&cti_cpu_pm_nb);\n\tcpus_read_unlock();\n\tif (ret) {\n\t\tcpuhp_remove_state_nocalls(CPUHP_AP_ARM_CORESIGHT_CTI_STARTING);\n\t\treturn ret;\n\t}\n\ndone:\n\tnr_cti_cpu++;\n\tcti_cpu_drvdata[drvdata->ctidev.cpu] = drvdata;\n\n\treturn 0;\n}\n\n \nstatic void cti_pm_release(struct cti_drvdata *drvdata)\n{\n\tif (drvdata->ctidev.cpu == -1)\n\t\treturn;\n\n\tcti_cpu_drvdata[drvdata->ctidev.cpu] = NULL;\n\tif (--nr_cti_cpu == 0) {\n\t\tcpu_pm_unregister_notifier(&cti_cpu_pm_nb);\n\t\tcpuhp_remove_state_nocalls(CPUHP_AP_ARM_CORESIGHT_CTI_STARTING);\n\t}\n}\n\n \nint cti_enable(struct coresight_device *csdev, enum cs_mode mode, void *data)\n{\n\tstruct cti_drvdata *drvdata = csdev_to_cti_drvdata(csdev);\n\n\treturn cti_enable_hw(drvdata);\n}\n\nint cti_disable(struct coresight_device *csdev, void *data)\n{\n\tstruct cti_drvdata *drvdata = csdev_to_cti_drvdata(csdev);\n\n\treturn cti_disable_hw(drvdata);\n}\n\nstatic const struct coresight_ops_helper cti_ops_ect = {\n\t.enable = cti_enable,\n\t.disable = cti_disable,\n};\n\nstatic const struct coresight_ops cti_ops = {\n\t.helper_ops = &cti_ops_ect,\n};\n\n \nstatic void cti_device_release(struct device *dev)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tstruct cti_drvdata *ect_item, *ect_tmp;\n\n\tmutex_lock(&ect_mutex);\n\tcti_pm_release(drvdata);\n\n\t \n\tlist_for_each_entry_safe(ect_item, ect_tmp, &ect_net, node) {\n\t\tif (ect_item == drvdata) {\n\t\t\tlist_del(&ect_item->node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ect_mutex);\n\n\tif (drvdata->csdev_release)\n\t\tdrvdata->csdev_release(dev);\n}\nstatic void cti_remove(struct amba_device *adev)\n{\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(&adev->dev);\n\n\tmutex_lock(&ect_mutex);\n\tcti_remove_conn_xrefs(drvdata);\n\tmutex_unlock(&ect_mutex);\n\n\tcoresight_unregister(drvdata->csdev);\n}\n\nstatic int cti_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tint ret = 0;\n\tvoid __iomem *base;\n\tstruct device *dev = &adev->dev;\n\tstruct cti_drvdata *drvdata = NULL;\n\tstruct coresight_desc cti_desc;\n\tstruct coresight_platform_data *pdata = NULL;\n\tstruct resource *res = &adev->res;\n\n\t \n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\t \n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdrvdata->base = base;\n\tcti_desc.access = CSDEV_ACCESS_IOMEM(base);\n\n\tdev_set_drvdata(dev, drvdata);\n\n\t \n\tdrvdata->ctidev.cpu = -1;\n\tdrvdata->ctidev.nr_trig_con = 0;\n\tdrvdata->ctidev.ctm_id = 0;\n\tINIT_LIST_HEAD(&drvdata->ctidev.trig_cons);\n\n\tspin_lock_init(&drvdata->spinlock);\n\n\t \n\tcti_set_default_config(dev, drvdata);\n\n\tpdata = coresight_cti_get_platform_data(dev);\n\tif (IS_ERR(pdata)) {\n\t\tdev_err(dev, \"coresight_cti_get_platform_data err\\n\");\n\t\treturn  PTR_ERR(pdata);\n\t}\n\n\t \n\tdrvdata->config.hw_powered = true;\n\n\t \n\tif (drvdata->ctidev.cpu >= 0)\n\t\tcti_desc.name = devm_kasprintf(dev, GFP_KERNEL, \"cti_cpu%d\",\n\t\t\t\t\t       drvdata->ctidev.cpu);\n\telse\n\t\tcti_desc.name = coresight_alloc_device_name(&cti_sys_devs, dev);\n\tif (!cti_desc.name)\n\t\treturn -ENOMEM;\n\n\t \n\tret = cti_pm_setup(drvdata);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = cti_create_cons_sysfs(dev, drvdata);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: create dynamic sysfs entries failed\\n\",\n\t\t\tcti_desc.name);\n\t\tgoto pm_release;\n\t}\n\n\t \n\tcti_desc.pdata = pdata;\n\tcti_desc.type = CORESIGHT_DEV_TYPE_HELPER;\n\tcti_desc.subtype.helper_subtype = CORESIGHT_DEV_SUBTYPE_HELPER_ECT_CTI;\n\tcti_desc.ops = &cti_ops;\n\tcti_desc.groups = drvdata->ctidev.con_groups;\n\tcti_desc.dev = dev;\n\tdrvdata->csdev = coresight_register(&cti_desc);\n\tif (IS_ERR(drvdata->csdev)) {\n\t\tret = PTR_ERR(drvdata->csdev);\n\t\tgoto pm_release;\n\t}\n\n\t \n\tmutex_lock(&ect_mutex);\n\tlist_add(&drvdata->node, &ect_net);\n\t \n\tcti_update_conn_xrefs(drvdata);\n\tmutex_unlock(&ect_mutex);\n\n\t \n\tdrvdata->csdev_release = drvdata->csdev->dev.release;\n\tdrvdata->csdev->dev.release = cti_device_release;\n\n\t \n\tpm_runtime_put(&adev->dev);\n\tdev_info(&drvdata->csdev->dev, \"CTI initialized\\n\");\n\treturn 0;\n\npm_release:\n\tcti_pm_release(drvdata);\n\treturn ret;\n}\n\nstatic struct amba_cs_uci_id uci_id_cti[] = {\n\t{\n\t\t \n\t\t.devarch\t= 0x47701a14,  \n\t\t.devarch_mask\t= 0xfff0ffff,\n\t\t.devtype\t= 0x00000014,  \n\t}\n};\n\nstatic const struct amba_id cti_ids[] = {\n\tCS_AMBA_ID(0x000bb906),  \n\tCS_AMBA_ID(0x000bb922),  \n\tCS_AMBA_ID(0x000bb9a8),  \n\tCS_AMBA_ID(0x000bb9aa),  \n\tCS_AMBA_UCI_ID(0x000bb9da, uci_id_cti),  \n\tCS_AMBA_UCI_ID(0x000bb9ed, uci_id_cti),  \n\t{ 0, 0},\n};\n\nMODULE_DEVICE_TABLE(amba, cti_ids);\n\nstatic struct amba_driver cti_driver = {\n\t.drv = {\n\t\t.name\t= \"coresight-cti\",\n\t\t.owner = THIS_MODULE,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= cti_probe,\n\t.remove\t\t= cti_remove,\n\t.id_table\t= cti_ids,\n};\n\nstatic int __init cti_init(void)\n{\n\tint ret;\n\n\tret = amba_driver_register(&cti_driver);\n\tif (ret)\n\t\tpr_info(\"Error registering cti driver\\n\");\n\tcoresight_set_cti_ops(&cti_assoc_ops);\n\treturn ret;\n}\n\nstatic void __exit cti_exit(void)\n{\n\tcoresight_remove_cti_ops();\n\tamba_driver_unregister(&cti_driver);\n}\n\nmodule_init(cti_init);\nmodule_exit(cti_exit);\n\nMODULE_AUTHOR(\"Mike Leach <mike.leach@linaro.org>\");\nMODULE_DESCRIPTION(\"Arm CoreSight CTI Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}