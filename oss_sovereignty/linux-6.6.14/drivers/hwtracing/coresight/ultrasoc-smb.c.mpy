{
  "module_name": "ultrasoc-smb.c",
  "hash_id": "b7af15fa3b484f4169ab2cff2c86a859496bc33b18a259f70f709957e49cd7ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/ultrasoc-smb.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/acpi.h>\n#include <linux/circ_buf.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n\n#include \"coresight-etm-perf.h\"\n#include \"coresight-priv.h\"\n#include \"ultrasoc-smb.h\"\n\nDEFINE_CORESIGHT_DEVLIST(sink_devs, \"ultra_smb\");\n\n#define ULTRASOC_SMB_DSM_UUID\t\"82ae1283-7f6a-4cbe-aa06-53e8fb24db18\"\n\nstatic bool smb_buffer_not_empty(struct smb_drv_data *drvdata)\n{\n\tu32 buf_status = readl(drvdata->base + SMB_LB_INT_STS_REG);\n\n\treturn FIELD_GET(SMB_LB_INT_STS_NOT_EMPTY_MSK, buf_status);\n}\n\nstatic void smb_update_data_size(struct smb_drv_data *drvdata)\n{\n\tstruct smb_data_buffer *sdb = &drvdata->sdb;\n\tu32 buf_wrptr;\n\n\tbuf_wrptr = readl(drvdata->base + SMB_LB_WR_ADDR_REG) -\n\t\t\t  sdb->buf_hw_base;\n\n\t \n\tif (buf_wrptr == sdb->buf_rdptr && smb_buffer_not_empty(drvdata)) {\n\t\tsdb->data_size = sdb->buf_size;\n\t\treturn;\n\t}\n\n\t \n\tsdb->data_size = CIRC_CNT(buf_wrptr, sdb->buf_rdptr,\n\t\t\t\t  sdb->buf_size);\n}\n\n \nstatic void smb_update_read_ptr(struct smb_drv_data *drvdata, u32 nbytes)\n{\n\tstruct smb_data_buffer *sdb = &drvdata->sdb;\n\n\tsdb->buf_rdptr += nbytes;\n\tsdb->buf_rdptr %= sdb->buf_size;\n\twritel(sdb->buf_hw_base + sdb->buf_rdptr,\n\t       drvdata->base + SMB_LB_RD_ADDR_REG);\n\n\tsdb->data_size -= nbytes;\n}\n\nstatic void smb_reset_buffer(struct smb_drv_data *drvdata)\n{\n\tstruct smb_data_buffer *sdb = &drvdata->sdb;\n\tu32 write_ptr;\n\n\t \n\twritel(SMB_LB_PURGE_PURGED, drvdata->base + SMB_LB_PURGE_REG);\n\n\t \n\twritel(SMB_LB_INT_STS_RESET, drvdata->base + SMB_LB_INT_STS_REG);\n\n\twrite_ptr = readl(drvdata->base + SMB_LB_WR_ADDR_REG);\n\n\t \n\tif (!write_ptr || write_ptr == sdb->buf_rdptr + sdb->buf_hw_base)\n\t\treturn;\n\n\t \n\twritel(write_ptr, drvdata->base + SMB_LB_RD_ADDR_REG);\n\tsdb->buf_rdptr = write_ptr - sdb->buf_hw_base;\n}\n\nstatic int smb_open(struct inode *inode, struct file *file)\n{\n\tstruct smb_drv_data *drvdata = container_of(file->private_data,\n\t\t\t\t\tstruct smb_drv_data, miscdev);\n\tint ret = 0;\n\n\tspin_lock(&drvdata->spinlock);\n\n\tif (drvdata->reading) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (atomic_read(&drvdata->csdev->refcnt)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tsmb_update_data_size(drvdata);\n\n\tdrvdata->reading = true;\nout:\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn ret;\n}\n\nstatic ssize_t smb_read(struct file *file, char __user *data, size_t len,\n\t\t\tloff_t *ppos)\n{\n\tstruct smb_drv_data *drvdata = container_of(file->private_data,\n\t\t\t\t\tstruct smb_drv_data, miscdev);\n\tstruct smb_data_buffer *sdb = &drvdata->sdb;\n\tstruct device *dev = &drvdata->csdev->dev;\n\tssize_t to_copy = 0;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (!sdb->data_size)\n\t\treturn 0;\n\n\tto_copy = min(sdb->data_size, len);\n\n\t \n\tif (sdb->buf_rdptr + to_copy > sdb->buf_size)\n\t\tto_copy = sdb->buf_size - sdb->buf_rdptr;\n\n\tif (copy_to_user(data, sdb->buf_base + sdb->buf_rdptr, to_copy)) {\n\t\tdev_dbg(dev, \"Failed to copy data to user\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t*ppos += to_copy;\n\tsmb_update_read_ptr(drvdata, to_copy);\n\tif (!sdb->data_size)\n\t\tsmb_reset_buffer(drvdata);\n\n\tdev_dbg(dev, \"%zu bytes copied\\n\", to_copy);\n\treturn to_copy;\n}\n\nstatic int smb_release(struct inode *inode, struct file *file)\n{\n\tstruct smb_drv_data *drvdata = container_of(file->private_data,\n\t\t\t\t\tstruct smb_drv_data, miscdev);\n\n\tspin_lock(&drvdata->spinlock);\n\tdrvdata->reading = false;\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn 0;\n}\n\nstatic const struct file_operations smb_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= smb_open,\n\t.read\t\t= smb_read,\n\t.release\t= smb_release,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic ssize_t buf_size_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct smb_drv_data *drvdata = dev_get_drvdata(dev->parent);\n\n\treturn sysfs_emit(buf, \"0x%lx\\n\", drvdata->sdb.buf_size);\n}\nstatic DEVICE_ATTR_RO(buf_size);\n\nstatic struct attribute *smb_sink_attrs[] = {\n\tcoresight_simple_reg32(read_pos, SMB_LB_RD_ADDR_REG),\n\tcoresight_simple_reg32(write_pos, SMB_LB_WR_ADDR_REG),\n\tcoresight_simple_reg32(buf_status, SMB_LB_INT_STS_REG),\n\t&dev_attr_buf_size.attr,\n\tNULL\n};\n\nstatic const struct attribute_group smb_sink_group = {\n\t.attrs = smb_sink_attrs,\n\t.name = \"mgmt\",\n};\n\nstatic const struct attribute_group *smb_sink_groups[] = {\n\t&smb_sink_group,\n\tNULL\n};\n\nstatic void smb_enable_hw(struct smb_drv_data *drvdata)\n{\n\twritel(SMB_GLB_EN_HW_ENABLE, drvdata->base + SMB_GLB_EN_REG);\n}\n\nstatic void smb_disable_hw(struct smb_drv_data *drvdata)\n{\n\twritel(0x0, drvdata->base + SMB_GLB_EN_REG);\n}\n\nstatic void smb_enable_sysfs(struct coresight_device *csdev)\n{\n\tstruct smb_drv_data *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tif (drvdata->mode != CS_MODE_DISABLED)\n\t\treturn;\n\n\tsmb_enable_hw(drvdata);\n\tdrvdata->mode = CS_MODE_SYSFS;\n}\n\nstatic int smb_enable_perf(struct coresight_device *csdev, void *data)\n{\n\tstruct smb_drv_data *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tstruct perf_output_handle *handle = data;\n\tstruct cs_buffers *buf = etm_perf_sink_config(handle);\n\tpid_t pid;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\t \n\tpid = buf->pid;\n\n\t \n\tif (drvdata->pid != -1 && drvdata->pid != pid)\n\t\treturn -EBUSY;\n\n\tif (drvdata->pid == -1) {\n\t\tsmb_enable_hw(drvdata);\n\t\tdrvdata->pid = pid;\n\t\tdrvdata->mode = CS_MODE_PERF;\n\t}\n\n\treturn 0;\n}\n\nstatic int smb_enable(struct coresight_device *csdev, enum cs_mode mode,\n\t\t      void *data)\n{\n\tstruct smb_drv_data *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tint ret = 0;\n\n\tspin_lock(&drvdata->spinlock);\n\n\t \n\tif (drvdata->reading) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (drvdata->mode != CS_MODE_DISABLED && drvdata->mode != mode) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tswitch (mode) {\n\tcase CS_MODE_SYSFS:\n\t\tsmb_enable_sysfs(csdev);\n\t\tbreak;\n\tcase CS_MODE_PERF:\n\t\tret = smb_enable_perf(csdev, data);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tgoto out;\n\n\tatomic_inc(&csdev->refcnt);\n\n\tdev_dbg(&csdev->dev, \"Ultrasoc SMB enabled\\n\");\nout:\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn ret;\n}\n\nstatic int smb_disable(struct coresight_device *csdev)\n{\n\tstruct smb_drv_data *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tint ret = 0;\n\n\tspin_lock(&drvdata->spinlock);\n\n\tif (drvdata->reading) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (atomic_dec_return(&csdev->refcnt)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tWARN_ON_ONCE(drvdata->mode == CS_MODE_DISABLED);\n\n\tsmb_disable_hw(drvdata);\n\n\t \n\tdrvdata->pid = -1;\n\tdrvdata->mode = CS_MODE_DISABLED;\n\n\tdev_dbg(&csdev->dev, \"Ultrasoc SMB disabled\\n\");\nout:\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn ret;\n}\n\nstatic void *smb_alloc_buffer(struct coresight_device *csdev,\n\t\t\t      struct perf_event *event, void **pages,\n\t\t\t      int nr_pages, bool overwrite)\n{\n\tstruct cs_buffers *buf;\n\tint node;\n\n\tnode = (event->cpu == -1) ? NUMA_NO_NODE : cpu_to_node(event->cpu);\n\tbuf = kzalloc_node(sizeof(struct cs_buffers), GFP_KERNEL, node);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->snapshot = overwrite;\n\tbuf->nr_pages = nr_pages;\n\tbuf->data_pages = pages;\n\tbuf->pid = task_pid_nr(event->owner);\n\n\treturn buf;\n}\n\nstatic void smb_free_buffer(void *config)\n{\n\tstruct cs_buffers *buf = config;\n\n\tkfree(buf);\n}\n\nstatic void smb_sync_perf_buffer(struct smb_drv_data *drvdata,\n\t\t\t\t struct cs_buffers *buf,\n\t\t\t\t unsigned long head)\n{\n\tstruct smb_data_buffer *sdb = &drvdata->sdb;\n\tchar **dst_pages = (char **)buf->data_pages;\n\tunsigned long to_copy;\n\tlong pg_idx, pg_offset;\n\n\tpg_idx = head >> PAGE_SHIFT;\n\tpg_offset = head & (PAGE_SIZE - 1);\n\n\twhile (sdb->data_size) {\n\t\tunsigned long pg_space = PAGE_SIZE - pg_offset;\n\n\t\tto_copy = min(sdb->data_size, pg_space);\n\n\t\t \n\t\tif (sdb->buf_rdptr + to_copy > sdb->buf_size)\n\t\t\tto_copy = sdb->buf_size - sdb->buf_rdptr;\n\n\t\tmemcpy(dst_pages[pg_idx] + pg_offset,\n\t\t\t      sdb->buf_base + sdb->buf_rdptr, to_copy);\n\n\t\tpg_offset += to_copy;\n\t\tif (pg_offset >= PAGE_SIZE) {\n\t\t\tpg_offset = 0;\n\t\t\tpg_idx++;\n\t\t\tpg_idx %= buf->nr_pages;\n\t\t}\n\t\tsmb_update_read_ptr(drvdata, to_copy);\n\t}\n\n\tsmb_reset_buffer(drvdata);\n}\n\nstatic unsigned long smb_update_buffer(struct coresight_device *csdev,\n\t\t\t\t       struct perf_output_handle *handle,\n\t\t\t\t       void *sink_config)\n{\n\tstruct smb_drv_data *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tstruct smb_data_buffer *sdb = &drvdata->sdb;\n\tstruct cs_buffers *buf = sink_config;\n\tunsigned long data_size = 0;\n\tbool lost = false;\n\n\tif (!buf)\n\t\treturn 0;\n\n\tspin_lock(&drvdata->spinlock);\n\n\t \n\tif (atomic_read(&csdev->refcnt) != 1)\n\t\tgoto out;\n\n\tsmb_disable_hw(drvdata);\n\tsmb_update_data_size(drvdata);\n\n\t \n\tif (sdb->data_size > handle->size) {\n\t\tsmb_update_read_ptr(drvdata, sdb->data_size - handle->size);\n\t\tlost = true;\n\t}\n\n\tdata_size = sdb->data_size;\n\tsmb_sync_perf_buffer(drvdata, buf, handle->head);\n\tif (!buf->snapshot && lost)\n\t\tperf_aux_output_flag(handle, PERF_AUX_FLAG_TRUNCATED);\nout:\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn data_size;\n}\n\nstatic const struct coresight_ops_sink smb_cs_ops = {\n\t.enable\t\t= smb_enable,\n\t.disable\t= smb_disable,\n\t.alloc_buffer\t= smb_alloc_buffer,\n\t.free_buffer\t= smb_free_buffer,\n\t.update_buffer\t= smb_update_buffer,\n};\n\nstatic const struct coresight_ops cs_ops = {\n\t.sink_ops\t= &smb_cs_ops,\n};\n\nstatic int smb_init_data_buffer(struct platform_device *pdev,\n\t\t\t\tstruct smb_data_buffer *sdb)\n{\n\tstruct resource *res;\n\tvoid *base;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, SMB_BUF_ADDR_RES);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"SMB device failed to get resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsdb->buf_rdptr = 0;\n\tsdb->buf_hw_base = FIELD_GET(SMB_BUF_ADDR_LO_MSK, res->start);\n\tsdb->buf_size = resource_size(res);\n\tif (sdb->buf_size == 0)\n\t\treturn -EINVAL;\n\n\t \n\tbase = devm_memremap(&pdev->dev, sdb->buf_hw_base, sdb->buf_size,\n\t\t\t\tMEMREMAP_WB);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tsdb->buf_base = base;\n\n\treturn 0;\n}\n\nstatic void smb_init_hw(struct smb_drv_data *drvdata)\n{\n\tsmb_disable_hw(drvdata);\n\n\twritel(SMB_LB_CFG_LO_DEFAULT, drvdata->base + SMB_LB_CFG_LO_REG);\n\twritel(SMB_LB_CFG_HI_DEFAULT, drvdata->base + SMB_LB_CFG_HI_REG);\n\twritel(SMB_GLB_CFG_DEFAULT, drvdata->base + SMB_GLB_CFG_REG);\n\twritel(SMB_GLB_INT_CFG, drvdata->base + SMB_GLB_INT_REG);\n\twritel(SMB_LB_INT_CTRL_CFG, drvdata->base + SMB_LB_INT_CTRL_REG);\n}\n\nstatic int smb_register_sink(struct platform_device *pdev,\n\t\t\t     struct smb_drv_data *drvdata)\n{\n\tstruct coresight_platform_data *pdata = NULL;\n\tstruct coresight_desc desc = { 0 };\n\tint ret;\n\n\tpdata = coresight_get_platform_data(&pdev->dev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\n\tdesc.type = CORESIGHT_DEV_TYPE_SINK;\n\tdesc.subtype.sink_subtype = CORESIGHT_DEV_SUBTYPE_SINK_BUFFER;\n\tdesc.ops = &cs_ops;\n\tdesc.pdata = pdata;\n\tdesc.dev = &pdev->dev;\n\tdesc.groups = smb_sink_groups;\n\tdesc.name = coresight_alloc_device_name(&sink_devs, &pdev->dev);\n\tif (!desc.name) {\n\t\tdev_err(&pdev->dev, \"Failed to alloc coresight device name\");\n\t\treturn -ENOMEM;\n\t}\n\tdesc.access = CSDEV_ACCESS_IOMEM(drvdata->base);\n\n\tdrvdata->csdev = coresight_register(&desc);\n\tif (IS_ERR(drvdata->csdev))\n\t\treturn PTR_ERR(drvdata->csdev);\n\n\tdrvdata->miscdev.name = desc.name;\n\tdrvdata->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tdrvdata->miscdev.fops = &smb_fops;\n\tret = misc_register(&drvdata->miscdev);\n\tif (ret) {\n\t\tcoresight_unregister(drvdata->csdev);\n\t\tdev_err(&pdev->dev, \"Failed to register misc, ret=%d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic void smb_unregister_sink(struct smb_drv_data *drvdata)\n{\n\tmisc_deregister(&drvdata->miscdev);\n\tcoresight_unregister(drvdata->csdev);\n}\n\nstatic int smb_config_inport(struct device *dev, bool enable)\n{\n\tu64 func = enable ? 1 : 0;\n\tunion acpi_object *obj;\n\tguid_t guid;\n\tu64 rev = 0;\n\n\t \n\tif (guid_parse(ULTRASOC_SMB_DSM_UUID, &guid)) {\n\t\tdev_err(dev, \"Get GUID failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(dev), &guid, rev, func, NULL);\n\tif (!obj) {\n\t\tdev_err(dev, \"ACPI handle failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tACPI_FREE(obj);\n\n\treturn 0;\n}\n\nstatic int smb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct smb_drv_data *drvdata;\n\tint ret;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->base = devm_platform_ioremap_resource(pdev, SMB_REG_ADDR_RES);\n\tif (IS_ERR(drvdata->base)) {\n\t\tdev_err(dev, \"Failed to ioremap resource\\n\");\n\t\treturn PTR_ERR(drvdata->base);\n\t}\n\n\tsmb_init_hw(drvdata);\n\n\tret = smb_init_data_buffer(pdev, &drvdata->sdb);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init buffer, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = smb_config_inport(dev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tsmb_reset_buffer(drvdata);\n\tplatform_set_drvdata(pdev, drvdata);\n\tspin_lock_init(&drvdata->spinlock);\n\tdrvdata->pid = -1;\n\n\tret = smb_register_sink(pdev, drvdata);\n\tif (ret) {\n\t\tsmb_config_inport(&pdev->dev, false);\n\t\tdev_err(dev, \"Failed to register SMB sink\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int smb_remove(struct platform_device *pdev)\n{\n\tstruct smb_drv_data *drvdata = platform_get_drvdata(pdev);\n\n\tsmb_unregister_sink(drvdata);\n\n\tsmb_config_inport(&pdev->dev, false);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id ultrasoc_smb_acpi_match[] = {\n\t{\"HISI03A1\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, ultrasoc_smb_acpi_match);\n#endif\n\nstatic struct platform_driver smb_driver = {\n\t.driver = {\n\t\t.name = \"ultrasoc-smb\",\n\t\t.acpi_match_table = ACPI_PTR(ultrasoc_smb_acpi_match),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = smb_probe,\n\t.remove = smb_remove,\n};\nmodule_platform_driver(smb_driver);\n\nMODULE_DESCRIPTION(\"UltraSoc SMB CoreSight driver\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_AUTHOR(\"Jonathan Zhou <jonathan.zhouwen@huawei.com>\");\nMODULE_AUTHOR(\"Qi Liu <liuqi115@huawei.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}