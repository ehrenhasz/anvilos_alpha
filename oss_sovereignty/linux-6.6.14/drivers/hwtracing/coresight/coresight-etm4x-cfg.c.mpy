{
  "module_name": "coresight-etm4x-cfg.c",
  "hash_id": "420e9cebee5fffd674746479545ab67598d34833fe171c9de1a5a16192a92f4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-etm4x-cfg.c",
  "human_readable_source": "\n \n\n#include \"coresight-etm4x.h\"\n#include \"coresight-etm4x-cfg.h\"\n#include \"coresight-priv.h\"\n#include \"coresight-syscfg.h\"\n\n \n#define CHECKREG(cval, elem) \\\n\t{ \\\n\t\tif (offset == cval) { \\\n\t\t\treg_csdev->driver_regval = &drvcfg->elem; \\\n\t\t\terr = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n#define CHECKREGIDX(cval, elem, off_idx, mask)\t\\\n\t{ \\\n\t\tif (mask == cval) { \\\n\t\t\treg_csdev->driver_regval = &drvcfg->elem[off_idx]; \\\n\t\t\terr = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n \nstatic int etm4_cfg_map_reg_offset(struct etmv4_drvdata *drvdata,\n\t\t\t\t   struct cscfg_regval_csdev *reg_csdev, u32 offset)\n{\n\tint err = -EINVAL, idx;\n\tstruct etmv4_config *drvcfg = &drvdata->config;\n\tu32 off_mask;\n\n\tif (((offset >= TRCEVENTCTL0R) && (offset <= TRCVIPCSSCTLR)) ||\n\t    ((offset >= TRCSEQRSTEVR) && (offset <= TRCEXTINSELR)) ||\n\t    ((offset >= TRCCIDCCTLR0) && (offset <= TRCVMIDCCTLR1))) {\n\t\tdo {\n\t\t\tCHECKREG(TRCEVENTCTL0R, eventctrl0);\n\t\t\tCHECKREG(TRCEVENTCTL1R, eventctrl1);\n\t\t\tCHECKREG(TRCSTALLCTLR, stall_ctrl);\n\t\t\tCHECKREG(TRCTSCTLR, ts_ctrl);\n\t\t\tCHECKREG(TRCSYNCPR, syncfreq);\n\t\t\tCHECKREG(TRCCCCTLR, ccctlr);\n\t\t\tCHECKREG(TRCBBCTLR, bb_ctrl);\n\t\t\tCHECKREG(TRCVICTLR, vinst_ctrl);\n\t\t\tCHECKREG(TRCVIIECTLR, viiectlr);\n\t\t\tCHECKREG(TRCVISSCTLR, vissctlr);\n\t\t\tCHECKREG(TRCVIPCSSCTLR, vipcssctlr);\n\t\t\tCHECKREG(TRCSEQRSTEVR, seq_rst);\n\t\t\tCHECKREG(TRCSEQSTR, seq_state);\n\t\t\tCHECKREG(TRCEXTINSELR, ext_inp);\n\t\t\tCHECKREG(TRCCIDCCTLR0, ctxid_mask0);\n\t\t\tCHECKREG(TRCCIDCCTLR1, ctxid_mask1);\n\t\t\tCHECKREG(TRCVMIDCCTLR0, vmid_mask0);\n\t\t\tCHECKREG(TRCVMIDCCTLR1, vmid_mask1);\n\t\t} while (0);\n\t} else if ((offset & GENMASK(11, 4)) == TRCSEQEVRn(0)) {\n\t\t \n\t\tidx = (offset & GENMASK(3, 0)) / 4;\n\t\tif (idx < ETM_MAX_SEQ_STATES) {\n\t\t\treg_csdev->driver_regval = &drvcfg->seq_ctrl[idx];\n\t\t\terr = 0;\n\t\t}\n\t} else if ((offset >= TRCSSCCRn(0)) && (offset <= TRCSSPCICRn(7))) {\n\t\t \n\t\tidx = (offset & GENMASK(4, 0)) / 4;\n\t\toff_mask =  (offset & GENMASK(11, 5));\n\t\tdo {\n\t\t\tCHECKREGIDX(TRCSSCCRn(0), ss_ctrl, idx, off_mask);\n\t\t\tCHECKREGIDX(TRCSSCSRn(0), ss_status, idx, off_mask);\n\t\t\tCHECKREGIDX(TRCSSPCICRn(0), ss_pe_cmp, idx, off_mask);\n\t\t} while (0);\n\t} else if ((offset >= TRCCIDCVRn(0)) && (offset <= TRCVMIDCVRn(7))) {\n\t\t \n\t\tidx = (offset & GENMASK(5, 0)) / 8;\n\t\toff_mask = (offset & GENMASK(11, 6));\n\t\tdo {\n\t\t\tCHECKREGIDX(TRCCIDCVRn(0), ctxid_pid, idx, off_mask);\n\t\t\tCHECKREGIDX(TRCVMIDCVRn(0), vmid_val, idx, off_mask);\n\t\t} while (0);\n\t} else if ((offset >= TRCRSCTLRn(2)) &&\n\t\t   (offset <= TRCRSCTLRn((ETM_MAX_RES_SEL - 1)))) {\n\t\t \n\t\tidx = (offset & GENMASK(6, 0)) / 4;\n\t\tif (idx < ETM_MAX_RES_SEL) {\n\t\t\treg_csdev->driver_regval = &drvcfg->res_ctrl[idx];\n\t\t\terr = 0;\n\t\t}\n\t} else if ((offset >= TRCACVRn(0)) &&\n\t\t   (offset <= TRCACATRn((ETM_MAX_SINGLE_ADDR_CMP - 1)))) {\n\t\t \n\t\tidx = (offset & GENMASK(6, 0)) / 8;\n\t\toff_mask = offset & GENMASK(11, 7);\n\t\tdo {\n\t\t\tCHECKREGIDX(TRCACVRn(0), addr_val, idx, off_mask);\n\t\t\tCHECKREGIDX(TRCACATRn(0), addr_acc, idx, off_mask);\n\t\t} while (0);\n\t} else if ((offset >= TRCCNTRLDVRn(0)) &&\n\t\t   (offset <= TRCCNTVRn((ETMv4_MAX_CNTR - 1)))) {\n\t\t \n\t\tidx = (offset &  GENMASK(3, 0)) / 4;\n\t\toff_mask = offset &  GENMASK(11, 4);\n\t\tdo {\n\t\t\tCHECKREGIDX(TRCCNTRLDVRn(0), cntrldvr, idx, off_mask);\n\t\t\tCHECKREGIDX(TRCCNTCTLRn(0), cntr_ctrl, idx, off_mask);\n\t\t\tCHECKREGIDX(TRCCNTVRn(0), cntr_val, idx, off_mask);\n\t\t} while (0);\n\t}\n\treturn err;\n}\n\n \nstatic int etm4_cfg_load_feature(struct coresight_device *csdev,\n\t\t\t\t struct cscfg_feature_csdev *feat_csdev)\n{\n\tstruct device *dev = csdev->dev.parent;\n\tstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev);\n\tconst struct cscfg_feature_desc *feat_desc = feat_csdev->feat_desc;\n\tu32 offset;\n\tint i = 0, err = 0;\n\n\t \n\tfeat_csdev->drv_spinlock = &drvdata->spinlock;\n\n\t \n\tfor (i = 0; i < feat_csdev->nr_regs && !err; i++) {\n\t\toffset = feat_desc->regs_desc[i].offset;\n\t\terr = etm4_cfg_map_reg_offset(drvdata, &feat_csdev->regs_csdev[i], offset);\n\t}\n\treturn err;\n}\n\n \n#define CS_CFG_ETM4_MATCH_FLAGS\t(CS_CFG_MATCH_CLASS_SRC_ALL | \\\n\t\t\t\t CS_CFG_MATCH_CLASS_SRC_ETM4)\n\nint etm4_cscfg_register(struct coresight_device *csdev)\n{\n\tstruct cscfg_csdev_feat_ops ops;\n\n\tops.load_feat = &etm4_cfg_load_feature;\n\n\treturn cscfg_register_csdev(csdev, CS_CFG_ETM4_MATCH_FLAGS, &ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}