{
  "module_name": "coresight-core.c",
  "hash_id": "2a5d4083a966b43e6ac3239f99c5a01ff93f422a16a434b93919955df797b14d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-core.c",
  "human_readable_source": "\n \n\n#include <linux/build_bug.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/idr.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stringhash.h>\n#include <linux/mutex.h>\n#include <linux/clk.h>\n#include <linux/coresight.h>\n#include <linux/property.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n\n#include \"coresight-etm-perf.h\"\n#include \"coresight-priv.h\"\n#include \"coresight-syscfg.h\"\n\nstatic DEFINE_MUTEX(coresight_mutex);\nstatic DEFINE_PER_CPU(struct coresight_device *, csdev_sink);\n\n \nstatic DEFINE_IDR(path_idr);\n\n \nstruct coresight_node {\n\tstruct coresight_device *csdev;\n\tstruct list_head link;\n};\n\n \nstatic DEFINE_PER_CPU(struct list_head *, tracer_path);\n\n \nconst u32 coresight_barrier_pkt[4] = {0x7fffffff, 0x7fffffff, 0x7fffffff, 0x7fffffff};\nEXPORT_SYMBOL_GPL(coresight_barrier_pkt);\n\nstatic const struct cti_assoc_op *cti_assoc_ops;\n\nssize_t coresight_simple_show_pair(struct device *_dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct coresight_device *csdev = container_of(_dev, struct coresight_device, dev);\n\tstruct cs_pair_attribute *cs_attr = container_of(attr, struct cs_pair_attribute, attr);\n\tu64 val;\n\n\tpm_runtime_get_sync(_dev->parent);\n\tval = csdev_access_relaxed_read_pair(&csdev->access, cs_attr->lo_off, cs_attr->hi_off);\n\tpm_runtime_put_sync(_dev->parent);\n\treturn sysfs_emit(buf, \"0x%llx\\n\", val);\n}\nEXPORT_SYMBOL_GPL(coresight_simple_show_pair);\n\nssize_t coresight_simple_show32(struct device *_dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct coresight_device *csdev = container_of(_dev, struct coresight_device, dev);\n\tstruct cs_off_attribute *cs_attr = container_of(attr, struct cs_off_attribute, attr);\n\tu64 val;\n\n\tpm_runtime_get_sync(_dev->parent);\n\tval = csdev_access_relaxed_read32(&csdev->access, cs_attr->off);\n\tpm_runtime_put_sync(_dev->parent);\n\treturn sysfs_emit(buf, \"0x%llx\\n\", val);\n}\nEXPORT_SYMBOL_GPL(coresight_simple_show32);\n\nvoid coresight_set_cti_ops(const struct cti_assoc_op *cti_op)\n{\n\tcti_assoc_ops = cti_op;\n}\nEXPORT_SYMBOL_GPL(coresight_set_cti_ops);\n\nvoid coresight_remove_cti_ops(void)\n{\n\tcti_assoc_ops = NULL;\n}\nEXPORT_SYMBOL_GPL(coresight_remove_cti_ops);\n\nvoid coresight_set_percpu_sink(int cpu, struct coresight_device *csdev)\n{\n\tper_cpu(csdev_sink, cpu) = csdev;\n}\nEXPORT_SYMBOL_GPL(coresight_set_percpu_sink);\n\nstruct coresight_device *coresight_get_percpu_sink(int cpu)\n{\n\treturn per_cpu(csdev_sink, cpu);\n}\nEXPORT_SYMBOL_GPL(coresight_get_percpu_sink);\n\nstatic struct coresight_connection *\ncoresight_find_out_connection(struct coresight_device *src_dev,\n\t\t\t      struct coresight_device *dest_dev)\n{\n\tint i;\n\tstruct coresight_connection *conn;\n\n\tfor (i = 0; i < src_dev->pdata->nr_outconns; i++) {\n\t\tconn = src_dev->pdata->out_conns[i];\n\t\tif (conn->dest_dev == dest_dev)\n\t\t\treturn conn;\n\t}\n\n\tdev_err(&src_dev->dev,\n\t\t\"couldn't find output connection, src_dev: %s, dest_dev: %s\\n\",\n\t\tdev_name(&src_dev->dev), dev_name(&dest_dev->dev));\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic inline u32 coresight_read_claim_tags(struct coresight_device *csdev)\n{\n\treturn csdev_access_relaxed_read32(&csdev->access, CORESIGHT_CLAIMCLR);\n}\n\nstatic inline bool coresight_is_claimed_self_hosted(struct coresight_device *csdev)\n{\n\treturn coresight_read_claim_tags(csdev) == CORESIGHT_CLAIM_SELF_HOSTED;\n}\n\nstatic inline bool coresight_is_claimed_any(struct coresight_device *csdev)\n{\n\treturn coresight_read_claim_tags(csdev) != 0;\n}\n\nstatic inline void coresight_set_claim_tags(struct coresight_device *csdev)\n{\n\tcsdev_access_relaxed_write32(&csdev->access, CORESIGHT_CLAIM_SELF_HOSTED,\n\t\t\t\t     CORESIGHT_CLAIMSET);\n\tisb();\n}\n\nstatic inline void coresight_clear_claim_tags(struct coresight_device *csdev)\n{\n\tcsdev_access_relaxed_write32(&csdev->access, CORESIGHT_CLAIM_SELF_HOSTED,\n\t\t\t\t     CORESIGHT_CLAIMCLR);\n\tisb();\n}\n\n \nint coresight_claim_device_unlocked(struct coresight_device *csdev)\n{\n\tif (WARN_ON(!csdev))\n\t\treturn -EINVAL;\n\n\tif (coresight_is_claimed_any(csdev))\n\t\treturn -EBUSY;\n\n\tcoresight_set_claim_tags(csdev);\n\tif (coresight_is_claimed_self_hosted(csdev))\n\t\treturn 0;\n\t \n\tcoresight_clear_claim_tags(csdev);\n\treturn -EBUSY;\n}\nEXPORT_SYMBOL_GPL(coresight_claim_device_unlocked);\n\nint coresight_claim_device(struct coresight_device *csdev)\n{\n\tint rc;\n\n\tif (WARN_ON(!csdev))\n\t\treturn -EINVAL;\n\n\tCS_UNLOCK(csdev->access.base);\n\trc = coresight_claim_device_unlocked(csdev);\n\tCS_LOCK(csdev->access.base);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(coresight_claim_device);\n\n \nvoid coresight_disclaim_device_unlocked(struct coresight_device *csdev)\n{\n\n\tif (WARN_ON(!csdev))\n\t\treturn;\n\n\tif (coresight_is_claimed_self_hosted(csdev))\n\t\tcoresight_clear_claim_tags(csdev);\n\telse\n\t\t \n\t\tWARN_ON_ONCE(1);\n}\nEXPORT_SYMBOL_GPL(coresight_disclaim_device_unlocked);\n\nvoid coresight_disclaim_device(struct coresight_device *csdev)\n{\n\tif (WARN_ON(!csdev))\n\t\treturn;\n\n\tCS_UNLOCK(csdev->access.base);\n\tcoresight_disclaim_device_unlocked(csdev);\n\tCS_LOCK(csdev->access.base);\n}\nEXPORT_SYMBOL_GPL(coresight_disclaim_device);\n\n \nvoid coresight_add_helper(struct coresight_device *csdev,\n\t\t\t  struct coresight_device *helper)\n{\n\tint i;\n\tstruct coresight_connection conn = {};\n\tstruct coresight_connection *new_conn;\n\n\tmutex_lock(&coresight_mutex);\n\tconn.dest_fwnode = fwnode_handle_get(dev_fwnode(&helper->dev));\n\tconn.dest_dev = helper;\n\tconn.dest_port = conn.src_port = -1;\n\tconn.src_dev = csdev;\n\n\t \n\tfor (i = 0; i < csdev->pdata->nr_outconns; ++i)\n\t\tif (csdev->pdata->out_conns[i]->dest_fwnode == conn.dest_fwnode)\n\t\t\tgoto unlock;\n\n\tnew_conn = coresight_add_out_conn(csdev->dev.parent, csdev->pdata,\n\t\t\t\t\t  &conn);\n\tif (!IS_ERR(new_conn))\n\t\tcoresight_add_in_conn(new_conn);\n\nunlock:\n\tmutex_unlock(&coresight_mutex);\n}\nEXPORT_SYMBOL_GPL(coresight_add_helper);\n\nstatic int coresight_enable_sink(struct coresight_device *csdev,\n\t\t\t\t enum cs_mode mode, void *data)\n{\n\tint ret;\n\n\t \n\tif (!sink_ops(csdev)->enable)\n\t\treturn -EINVAL;\n\n\tret = sink_ops(csdev)->enable(csdev, mode, data);\n\tif (ret)\n\t\treturn ret;\n\n\tcsdev->enable = true;\n\n\treturn 0;\n}\n\nstatic void coresight_disable_sink(struct coresight_device *csdev)\n{\n\tint ret;\n\n\tif (!sink_ops(csdev)->disable)\n\t\treturn;\n\n\tret = sink_ops(csdev)->disable(csdev);\n\tif (ret)\n\t\treturn;\n\tcsdev->enable = false;\n}\n\nstatic int coresight_enable_link(struct coresight_device *csdev,\n\t\t\t\t struct coresight_device *parent,\n\t\t\t\t struct coresight_device *child)\n{\n\tint ret = 0;\n\tint link_subtype;\n\tstruct coresight_connection *inconn, *outconn;\n\n\tif (!parent || !child)\n\t\treturn -EINVAL;\n\n\tinconn = coresight_find_out_connection(parent, csdev);\n\toutconn = coresight_find_out_connection(csdev, child);\n\tlink_subtype = csdev->subtype.link_subtype;\n\n\tif (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_MERG && IS_ERR(inconn))\n\t\treturn PTR_ERR(inconn);\n\tif (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_SPLIT && IS_ERR(outconn))\n\t\treturn PTR_ERR(outconn);\n\n\tif (link_ops(csdev)->enable) {\n\t\tret = link_ops(csdev)->enable(csdev, inconn, outconn);\n\t\tif (!ret)\n\t\t\tcsdev->enable = true;\n\t}\n\n\treturn ret;\n}\n\nstatic void coresight_disable_link(struct coresight_device *csdev,\n\t\t\t\t   struct coresight_device *parent,\n\t\t\t\t   struct coresight_device *child)\n{\n\tint i;\n\tint link_subtype;\n\tstruct coresight_connection *inconn, *outconn;\n\n\tif (!parent || !child)\n\t\treturn;\n\n\tinconn = coresight_find_out_connection(parent, csdev);\n\toutconn = coresight_find_out_connection(csdev, child);\n\tlink_subtype = csdev->subtype.link_subtype;\n\n\tif (link_ops(csdev)->disable) {\n\t\tlink_ops(csdev)->disable(csdev, inconn, outconn);\n\t}\n\n\tif (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_MERG) {\n\t\tfor (i = 0; i < csdev->pdata->nr_inconns; i++)\n\t\t\tif (atomic_read(&csdev->pdata->in_conns[i]->dest_refcnt) !=\n\t\t\t    0)\n\t\t\t\treturn;\n\t} else if (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_SPLIT) {\n\t\tfor (i = 0; i < csdev->pdata->nr_outconns; i++)\n\t\t\tif (atomic_read(&csdev->pdata->out_conns[i]->src_refcnt) !=\n\t\t\t    0)\n\t\t\t\treturn;\n\t} else {\n\t\tif (atomic_read(&csdev->refcnt) != 0)\n\t\t\treturn;\n\t}\n\n\tcsdev->enable = false;\n}\n\nint coresight_enable_source(struct coresight_device *csdev, enum cs_mode mode,\n\t\t\t    void *data)\n{\n\tint ret;\n\n\tif (!csdev->enable) {\n\t\tif (source_ops(csdev)->enable) {\n\t\t\tret = source_ops(csdev)->enable(csdev, data, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tcsdev->enable = true;\n\t}\n\n\tatomic_inc(&csdev->refcnt);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(coresight_enable_source);\n\nstatic bool coresight_is_helper(struct coresight_device *csdev)\n{\n\treturn csdev->type == CORESIGHT_DEV_TYPE_HELPER;\n}\n\nstatic int coresight_enable_helper(struct coresight_device *csdev,\n\t\t\t\t   enum cs_mode mode, void *data)\n{\n\tint ret;\n\n\tif (!helper_ops(csdev)->enable)\n\t\treturn 0;\n\tret = helper_ops(csdev)->enable(csdev, mode, data);\n\tif (ret)\n\t\treturn ret;\n\n\tcsdev->enable = true;\n\treturn 0;\n}\n\nstatic void coresight_disable_helper(struct coresight_device *csdev)\n{\n\tint ret;\n\n\tif (!helper_ops(csdev)->disable)\n\t\treturn;\n\n\tret = helper_ops(csdev)->disable(csdev, NULL);\n\tif (ret)\n\t\treturn;\n\tcsdev->enable = false;\n}\n\nstatic void coresight_disable_helpers(struct coresight_device *csdev)\n{\n\tint i;\n\tstruct coresight_device *helper;\n\n\tfor (i = 0; i < csdev->pdata->nr_outconns; ++i) {\n\t\thelper = csdev->pdata->out_conns[i]->dest_dev;\n\t\tif (helper && coresight_is_helper(helper))\n\t\t\tcoresight_disable_helper(helper);\n\t}\n}\n\n \nbool coresight_disable_source(struct coresight_device *csdev, void *data)\n{\n\tif (atomic_dec_return(&csdev->refcnt) == 0) {\n\t\tif (source_ops(csdev)->disable)\n\t\t\tsource_ops(csdev)->disable(csdev, data);\n\t\tcoresight_disable_helpers(csdev);\n\t\tcsdev->enable = false;\n\t}\n\treturn !csdev->enable;\n}\nEXPORT_SYMBOL_GPL(coresight_disable_source);\n\n \nstatic void coresight_disable_path_from(struct list_head *path,\n\t\t\t\t\tstruct coresight_node *nd)\n{\n\tu32 type;\n\tstruct coresight_device *csdev, *parent, *child;\n\n\tif (!nd)\n\t\tnd = list_first_entry(path, struct coresight_node, link);\n\n\tlist_for_each_entry_continue(nd, path, link) {\n\t\tcsdev = nd->csdev;\n\t\ttype = csdev->type;\n\n\t\t \n\t\tif (type == CORESIGHT_DEV_TYPE_LINKSINK)\n\t\t\ttype = (csdev == coresight_get_sink(path)) ?\n\t\t\t\t\t\tCORESIGHT_DEV_TYPE_SINK :\n\t\t\t\t\t\tCORESIGHT_DEV_TYPE_LINK;\n\n\t\tswitch (type) {\n\t\tcase CORESIGHT_DEV_TYPE_SINK:\n\t\t\tcoresight_disable_sink(csdev);\n\t\t\tbreak;\n\t\tcase CORESIGHT_DEV_TYPE_SOURCE:\n\t\t\t \n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\tcase CORESIGHT_DEV_TYPE_LINK:\n\t\t\tparent = list_prev_entry(nd, link)->csdev;\n\t\t\tchild = list_next_entry(nd, link)->csdev;\n\t\t\tcoresight_disable_link(csdev, parent, child);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcoresight_disable_helpers(csdev);\n\t}\n}\n\nvoid coresight_disable_path(struct list_head *path)\n{\n\tcoresight_disable_path_from(path, NULL);\n}\nEXPORT_SYMBOL_GPL(coresight_disable_path);\n\nstatic int coresight_enable_helpers(struct coresight_device *csdev,\n\t\t\t\t    enum cs_mode mode, void *data)\n{\n\tint i, ret = 0;\n\tstruct coresight_device *helper;\n\n\tfor (i = 0; i < csdev->pdata->nr_outconns; ++i) {\n\t\thelper = csdev->pdata->out_conns[i]->dest_dev;\n\t\tif (!helper || !coresight_is_helper(helper))\n\t\t\tcontinue;\n\n\t\tret = coresight_enable_helper(helper, mode, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint coresight_enable_path(struct list_head *path, enum cs_mode mode,\n\t\t\t  void *sink_data)\n{\n\tint ret = 0;\n\tu32 type;\n\tstruct coresight_node *nd;\n\tstruct coresight_device *csdev, *parent, *child;\n\n\tlist_for_each_entry_reverse(nd, path, link) {\n\t\tcsdev = nd->csdev;\n\t\ttype = csdev->type;\n\n\t\t \n\t\tret = coresight_enable_helpers(csdev, mode, sink_data);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\t \n\t\tif (type == CORESIGHT_DEV_TYPE_LINKSINK)\n\t\t\ttype = (csdev == coresight_get_sink(path)) ?\n\t\t\t\t\t\tCORESIGHT_DEV_TYPE_SINK :\n\t\t\t\t\t\tCORESIGHT_DEV_TYPE_LINK;\n\n\t\tswitch (type) {\n\t\tcase CORESIGHT_DEV_TYPE_SINK:\n\t\t\tret = coresight_enable_sink(csdev, mode, sink_data);\n\t\t\t \n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase CORESIGHT_DEV_TYPE_SOURCE:\n\t\t\t \n\t\t\tbreak;\n\t\tcase CORESIGHT_DEV_TYPE_LINK:\n\t\t\tparent = list_prev_entry(nd, link)->csdev;\n\t\t\tchild = list_next_entry(nd, link)->csdev;\n\t\t\tret = coresight_enable_link(csdev, parent, child);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err;\n\t\t}\n\t}\n\nout:\n\treturn ret;\nerr:\n\tcoresight_disable_path_from(path, nd);\n\tgoto out;\n}\n\nstruct coresight_device *coresight_get_sink(struct list_head *path)\n{\n\tstruct coresight_device *csdev;\n\n\tif (!path)\n\t\treturn NULL;\n\n\tcsdev = list_last_entry(path, struct coresight_node, link)->csdev;\n\tif (csdev->type != CORESIGHT_DEV_TYPE_SINK &&\n\t    csdev->type != CORESIGHT_DEV_TYPE_LINKSINK)\n\t\treturn NULL;\n\n\treturn csdev;\n}\n\nstatic struct coresight_device *\ncoresight_find_enabled_sink(struct coresight_device *csdev)\n{\n\tint i;\n\tstruct coresight_device *sink = NULL;\n\n\tif ((csdev->type == CORESIGHT_DEV_TYPE_SINK ||\n\t     csdev->type == CORESIGHT_DEV_TYPE_LINKSINK) &&\n\t     csdev->activated)\n\t\treturn csdev;\n\n\t \n\tfor (i = 0; i < csdev->pdata->nr_outconns; i++) {\n\t\tstruct coresight_device *child_dev;\n\n\t\tchild_dev = csdev->pdata->out_conns[i]->dest_dev;\n\t\tif (child_dev)\n\t\t\tsink = coresight_find_enabled_sink(child_dev);\n\t\tif (sink)\n\t\t\treturn sink;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct coresight_device *\ncoresight_get_enabled_sink(struct coresight_device *source)\n{\n\tif (!source)\n\t\treturn NULL;\n\n\treturn coresight_find_enabled_sink(source);\n}\n\nstatic int coresight_sink_by_id(struct device *dev, const void *data)\n{\n\tstruct coresight_device *csdev = to_coresight_device(dev);\n\tunsigned long hash;\n\n\tif (csdev->type == CORESIGHT_DEV_TYPE_SINK ||\n\t     csdev->type == CORESIGHT_DEV_TYPE_LINKSINK) {\n\n\t\tif (!csdev->ea)\n\t\t\treturn 0;\n\t\t \n\t\thash = (unsigned long)csdev->ea->var;\n\n\t\tif ((u32)hash == *(u32 *)data)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstruct coresight_device *coresight_get_sink_by_id(u32 id)\n{\n\tstruct device *dev = NULL;\n\n\tdev = bus_find_device(&coresight_bustype, NULL, &id,\n\t\t\t      coresight_sink_by_id);\n\n\treturn dev ? to_coresight_device(dev) : NULL;\n}\n\n \nstatic inline bool coresight_get_ref(struct coresight_device *csdev)\n{\n\tstruct device *dev = csdev->dev.parent;\n\n\t \n\tif (!try_module_get(dev->driver->owner))\n\t\treturn false;\n\t \n\tget_device(dev);\n\tpm_runtime_get_sync(dev);\n\treturn true;\n}\n\n \nstatic inline void coresight_put_ref(struct coresight_device *csdev)\n{\n\tstruct device *dev = csdev->dev.parent;\n\n\tpm_runtime_put(dev);\n\tput_device(dev);\n\tmodule_put(dev->driver->owner);\n}\n\n \nstatic int coresight_grab_device(struct coresight_device *csdev)\n{\n\tint i;\n\n\tfor (i = 0; i < csdev->pdata->nr_outconns; i++) {\n\t\tstruct coresight_device *child;\n\n\t\tchild = csdev->pdata->out_conns[i]->dest_dev;\n\t\tif (child && coresight_is_helper(child))\n\t\t\tif (!coresight_get_ref(child))\n\t\t\t\tgoto err;\n\t}\n\tif (coresight_get_ref(csdev))\n\t\treturn 0;\nerr:\n\tfor (i--; i >= 0; i--) {\n\t\tstruct coresight_device *child;\n\n\t\tchild = csdev->pdata->out_conns[i]->dest_dev;\n\t\tif (child && coresight_is_helper(child))\n\t\t\tcoresight_put_ref(child);\n\t}\n\treturn -ENODEV;\n}\n\n \nstatic void coresight_drop_device(struct coresight_device *csdev)\n{\n\tint i;\n\n\tcoresight_put_ref(csdev);\n\tfor (i = 0; i < csdev->pdata->nr_outconns; i++) {\n\t\tstruct coresight_device *child;\n\n\t\tchild = csdev->pdata->out_conns[i]->dest_dev;\n\t\tif (child && coresight_is_helper(child))\n\t\t\tcoresight_put_ref(child);\n\t}\n}\n\n \nstatic int _coresight_build_path(struct coresight_device *csdev,\n\t\t\t\t struct coresight_device *sink,\n\t\t\t\t struct list_head *path)\n{\n\tint i, ret;\n\tbool found = false;\n\tstruct coresight_node *node;\n\n\t \n\tif (csdev == sink)\n\t\tgoto out;\n\n\tif (coresight_is_percpu_source(csdev) && coresight_is_percpu_sink(sink) &&\n\t    sink == per_cpu(csdev_sink, source_ops(csdev)->cpu_id(csdev))) {\n\t\tif (_coresight_build_path(sink, sink, path) == 0) {\n\t\t\tfound = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < csdev->pdata->nr_outconns; i++) {\n\t\tstruct coresight_device *child_dev;\n\n\t\tchild_dev = csdev->pdata->out_conns[i]->dest_dev;\n\t\tif (child_dev &&\n\t\t    _coresight_build_path(child_dev, sink, path) == 0) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn -ENODEV;\n\nout:\n\t \n\tret = coresight_grab_device(csdev);\n\tif (ret)\n\t\treturn ret;\n\n\tnode = kzalloc(sizeof(struct coresight_node), GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->csdev = csdev;\n\tlist_add(&node->link, path);\n\n\treturn 0;\n}\n\nstruct list_head *coresight_build_path(struct coresight_device *source,\n\t\t\t\t       struct coresight_device *sink)\n{\n\tstruct list_head *path;\n\tint rc;\n\n\tif (!sink)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpath = kzalloc(sizeof(struct list_head), GFP_KERNEL);\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(path);\n\n\trc = _coresight_build_path(source, sink, path);\n\tif (rc) {\n\t\tkfree(path);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn path;\n}\n\n \nvoid coresight_release_path(struct list_head *path)\n{\n\tstruct coresight_device *csdev;\n\tstruct coresight_node *nd, *next;\n\n\tlist_for_each_entry_safe(nd, next, path, link) {\n\t\tcsdev = nd->csdev;\n\n\t\tcoresight_drop_device(csdev);\n\t\tlist_del(&nd->link);\n\t\tkfree(nd);\n\t}\n\n\tkfree(path);\n}\n\n \nstatic inline bool coresight_is_def_sink_type(struct coresight_device *csdev)\n{\n\t \n\tif (((csdev->type == CORESIGHT_DEV_TYPE_SINK) ||\n\t     (csdev->type == CORESIGHT_DEV_TYPE_LINKSINK)) &&\n\t    (csdev->subtype.sink_subtype >= CORESIGHT_DEV_SUBTYPE_SINK_BUFFER))\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic struct coresight_device *\ncoresight_select_best_sink(struct coresight_device *sink, int *depth,\n\t\t\t   struct coresight_device *new_sink, int new_depth)\n{\n\tbool update = false;\n\n\tif (!sink) {\n\t\t \n\t\tupdate = true;\n\t} else if (new_sink->subtype.sink_subtype >\n\t\t   sink->subtype.sink_subtype) {\n\t\t \n\t\tupdate = true;\n\t} else if ((new_sink->subtype.sink_subtype ==\n\t\t    sink->subtype.sink_subtype) &&\n\t\t   (*depth > new_depth)) {\n\t\t \n\t\tupdate = true;\n\t}\n\n\tif (update)\n\t\t*depth = new_depth;\n\treturn update ? new_sink : sink;\n}\n\n \nstatic struct coresight_device *\ncoresight_find_sink(struct coresight_device *csdev, int *depth)\n{\n\tint i, curr_depth = *depth + 1, found_depth = 0;\n\tstruct coresight_device *found_sink = NULL;\n\n\tif (coresight_is_def_sink_type(csdev)) {\n\t\tfound_depth = curr_depth;\n\t\tfound_sink = csdev;\n\t\tif (csdev->type == CORESIGHT_DEV_TYPE_SINK)\n\t\t\tgoto return_def_sink;\n\t\t \n\t}\n\n\t \n\tfor (i = 0; i < csdev->pdata->nr_outconns; i++) {\n\t\tstruct coresight_device *child_dev, *sink = NULL;\n\t\tint child_depth = curr_depth;\n\n\t\tchild_dev = csdev->pdata->out_conns[i]->dest_dev;\n\t\tif (child_dev)\n\t\t\tsink = coresight_find_sink(child_dev, &child_depth);\n\n\t\tif (sink)\n\t\t\tfound_sink = coresight_select_best_sink(found_sink,\n\t\t\t\t\t\t\t\t&found_depth,\n\t\t\t\t\t\t\t\tsink,\n\t\t\t\t\t\t\t\tchild_depth);\n\t}\n\nreturn_def_sink:\n\t \n\tif (found_sink)\n\t\t*depth = found_depth;\n\treturn found_sink;\n}\n\n \nstruct coresight_device *\ncoresight_find_default_sink(struct coresight_device *csdev)\n{\n\tint depth = 0;\n\n\t \n\tif (!csdev->def_sink) {\n\t\tif (coresight_is_percpu_source(csdev))\n\t\t\tcsdev->def_sink = per_cpu(csdev_sink, source_ops(csdev)->cpu_id(csdev));\n\t\tif (!csdev->def_sink)\n\t\t\tcsdev->def_sink = coresight_find_sink(csdev, &depth);\n\t}\n\treturn csdev->def_sink;\n}\n\nstatic int coresight_remove_sink_ref(struct device *dev, void *data)\n{\n\tstruct coresight_device *sink = data;\n\tstruct coresight_device *source = to_coresight_device(dev);\n\n\tif (source->def_sink == sink)\n\t\tsource->def_sink = NULL;\n\treturn 0;\n}\n\n \nstatic void coresight_clear_default_sink(struct coresight_device *csdev)\n{\n\tif ((csdev->type == CORESIGHT_DEV_TYPE_SINK) ||\n\t    (csdev->type == CORESIGHT_DEV_TYPE_LINKSINK)) {\n\t\tbus_for_each_dev(&coresight_bustype, NULL, csdev,\n\t\t\t\t coresight_remove_sink_ref);\n\t}\n}\n\n \nstatic int coresight_validate_source(struct coresight_device *csdev,\n\t\t\t\t     const char *function)\n{\n\tu32 type, subtype;\n\n\ttype = csdev->type;\n\tsubtype = csdev->subtype.source_subtype;\n\n\tif (type != CORESIGHT_DEV_TYPE_SOURCE) {\n\t\tdev_err(&csdev->dev, \"wrong device type in %s\\n\", function);\n\t\treturn -EINVAL;\n\t}\n\n\tif (subtype != CORESIGHT_DEV_SUBTYPE_SOURCE_PROC &&\n\t    subtype != CORESIGHT_DEV_SUBTYPE_SOURCE_SOFTWARE &&\n\t    subtype != CORESIGHT_DEV_SUBTYPE_SOURCE_OTHERS) {\n\t\tdev_err(&csdev->dev, \"wrong device subtype in %s\\n\", function);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint coresight_enable(struct coresight_device *csdev)\n{\n\tint cpu, ret = 0;\n\tstruct coresight_device *sink;\n\tstruct list_head *path;\n\tenum coresight_dev_subtype_source subtype;\n\tu32 hash;\n\n\tsubtype = csdev->subtype.source_subtype;\n\n\tmutex_lock(&coresight_mutex);\n\n\tret = coresight_validate_source(csdev, __func__);\n\tif (ret)\n\t\tgoto out;\n\n\tif (csdev->enable) {\n\t\t \n\t\tif (subtype == CORESIGHT_DEV_SUBTYPE_SOURCE_SOFTWARE)\n\t\t\tatomic_inc(&csdev->refcnt);\n\t\tgoto out;\n\t}\n\n\tsink = coresight_get_enabled_sink(csdev);\n\tif (!sink) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpath = coresight_build_path(csdev, sink);\n\tif (IS_ERR(path)) {\n\t\tpr_err(\"building path(s) failed\\n\");\n\t\tret = PTR_ERR(path);\n\t\tgoto out;\n\t}\n\n\tret = coresight_enable_path(path, CS_MODE_SYSFS, NULL);\n\tif (ret)\n\t\tgoto err_path;\n\n\tret = coresight_enable_source(csdev, CS_MODE_SYSFS, NULL);\n\tif (ret)\n\t\tgoto err_source;\n\n\tswitch (subtype) {\n\tcase CORESIGHT_DEV_SUBTYPE_SOURCE_PROC:\n\t\t \n\t\tcpu = source_ops(csdev)->cpu_id(csdev);\n\t\tper_cpu(tracer_path, cpu) = path;\n\t\tbreak;\n\tcase CORESIGHT_DEV_SUBTYPE_SOURCE_SOFTWARE:\n\tcase CORESIGHT_DEV_SUBTYPE_SOURCE_OTHERS:\n\t\t \n\t\thash = hashlen_hash(hashlen_string(NULL, dev_name(&csdev->dev)));\n\t\tret = idr_alloc_u32(&path_idr, path, &hash, hash, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tgoto err_source;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&coresight_mutex);\n\treturn ret;\n\nerr_source:\n\tcoresight_disable_path(path);\n\nerr_path:\n\tcoresight_release_path(path);\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(coresight_enable);\n\nvoid coresight_disable(struct coresight_device *csdev)\n{\n\tint cpu, ret;\n\tstruct list_head *path = NULL;\n\tu32 hash;\n\n\tmutex_lock(&coresight_mutex);\n\n\tret = coresight_validate_source(csdev, __func__);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!csdev->enable || !coresight_disable_source(csdev, NULL))\n\t\tgoto out;\n\n\tswitch (csdev->subtype.source_subtype) {\n\tcase CORESIGHT_DEV_SUBTYPE_SOURCE_PROC:\n\t\tcpu = source_ops(csdev)->cpu_id(csdev);\n\t\tpath = per_cpu(tracer_path, cpu);\n\t\tper_cpu(tracer_path, cpu) = NULL;\n\t\tbreak;\n\tcase CORESIGHT_DEV_SUBTYPE_SOURCE_SOFTWARE:\n\tcase CORESIGHT_DEV_SUBTYPE_SOURCE_OTHERS:\n\t\thash = hashlen_hash(hashlen_string(NULL, dev_name(&csdev->dev)));\n\t\t \n\t\tpath = idr_find(&path_idr, hash);\n\t\tif (path == NULL) {\n\t\t\tpr_err(\"Path is not found for %s\\n\", dev_name(&csdev->dev));\n\t\t\tgoto out;\n\t\t}\n\t\tidr_remove(&path_idr, hash);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tcoresight_disable_path(path);\n\tcoresight_release_path(path);\n\nout:\n\tmutex_unlock(&coresight_mutex);\n}\nEXPORT_SYMBOL_GPL(coresight_disable);\n\nstatic ssize_t enable_sink_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct coresight_device *csdev = to_coresight_device(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", csdev->activated);\n}\n\nstatic ssize_t enable_sink_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct coresight_device *csdev = to_coresight_device(dev);\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val)\n\t\tcsdev->activated = true;\n\telse\n\t\tcsdev->activated = false;\n\n\treturn size;\n\n}\nstatic DEVICE_ATTR_RW(enable_sink);\n\nstatic ssize_t enable_source_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct coresight_device *csdev = to_coresight_device(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", csdev->enable);\n}\n\nstatic ssize_t enable_source_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t size)\n{\n\tint ret = 0;\n\tunsigned long val;\n\tstruct coresight_device *csdev = to_coresight_device(dev);\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val) {\n\t\tret = coresight_enable(csdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tcoresight_disable(csdev);\n\t}\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(enable_source);\n\nstatic struct attribute *coresight_sink_attrs[] = {\n\t&dev_attr_enable_sink.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(coresight_sink);\n\nstatic struct attribute *coresight_source_attrs[] = {\n\t&dev_attr_enable_source.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(coresight_source);\n\nstatic struct device_type coresight_dev_type[] = {\n\t{\n\t\t.name = \"sink\",\n\t\t.groups = coresight_sink_groups,\n\t},\n\t{\n\t\t.name = \"link\",\n\t},\n\t{\n\t\t.name = \"linksink\",\n\t\t.groups = coresight_sink_groups,\n\t},\n\t{\n\t\t.name = \"source\",\n\t\t.groups = coresight_source_groups,\n\t},\n\t{\n\t\t.name = \"helper\",\n\t}\n};\n \nstatic_assert(ARRAY_SIZE(coresight_dev_type) == CORESIGHT_DEV_TYPE_MAX);\n\nstatic void coresight_device_release(struct device *dev)\n{\n\tstruct coresight_device *csdev = to_coresight_device(dev);\n\n\tfwnode_handle_put(csdev->dev.fwnode);\n\tkfree(csdev);\n}\n\nstatic int coresight_orphan_match(struct device *dev, void *data)\n{\n\tint i, ret = 0;\n\tbool still_orphan = false;\n\tstruct coresight_device *dst_csdev = data;\n\tstruct coresight_device *src_csdev = to_coresight_device(dev);\n\tstruct coresight_connection *conn;\n\tbool fixup_self = (src_csdev == dst_csdev);\n\n\t \n\tif (!src_csdev->orphan)\n\t\treturn 0;\n\t \n\tfor (i = 0; i < src_csdev->pdata->nr_outconns; i++) {\n\t\tconn = src_csdev->pdata->out_conns[i];\n\n\t\t \n\t\tif (conn->dest_dev)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (fixup_self)\n\t\t\tdst_csdev = coresight_find_csdev_by_fwnode(\n\t\t\t\tconn->dest_fwnode);\n\n\t\t \n\t\tif (dst_csdev && conn->dest_fwnode == dst_csdev->dev.fwnode) {\n\t\t\tret = coresight_make_links(src_csdev, conn, dst_csdev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tconn->dest_dev = dst_csdev;\n\t\t\tconn->src_dev = src_csdev;\n\n\t\t\tret = coresight_add_in_conn(conn);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\t \n\t\t\tstill_orphan = true;\n\t\t}\n\t}\n\n\tsrc_csdev->orphan = still_orphan;\n\n\t \n\treturn 0;\n}\n\nstatic int coresight_fixup_orphan_conns(struct coresight_device *csdev)\n{\n\treturn bus_for_each_dev(&coresight_bustype, NULL,\n\t\t\t csdev, coresight_orphan_match);\n}\n\n \nstatic void coresight_remove_conns(struct coresight_device *csdev)\n{\n\tint i, j;\n\tstruct coresight_connection *conn;\n\n\t \n\tfor (i = 0; i < csdev->pdata->nr_outconns; i++) {\n\t\tconn = csdev->pdata->out_conns[i];\n\t\tif (!conn->dest_dev)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < conn->dest_dev->pdata->nr_inconns; ++j)\n\t\t\tif (conn->dest_dev->pdata->in_conns[j] == conn) {\n\t\t\t\tconn->dest_dev->pdata->in_conns[j] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < csdev->pdata->nr_inconns; ++i) {\n\t\tconn = csdev->pdata->in_conns[i];\n\t\t \n\t\tif (!conn)\n\t\t\tcontinue;\n\n\t\tconn->src_dev->orphan = true;\n\t\tcoresight_remove_links(conn->src_dev, conn);\n\t\tconn->dest_dev = NULL;\n\t}\n}\n\n \nint coresight_timeout(struct csdev_access *csa, u32 offset,\n\t\t      int position, int value)\n{\n\tint i;\n\tu32 val;\n\n\tfor (i = TIMEOUT_US; i > 0; i--) {\n\t\tval = csdev_access_read32(csa, offset);\n\t\t \n\t\tif (value) {\n\t\t\tif (val & BIT(position))\n\t\t\t\treturn 0;\n\t\t \n\t\t} else {\n\t\t\tif (!(val & BIT(position)))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (i - 1)\n\t\t\tudelay(1);\n\t}\n\n\treturn -EAGAIN;\n}\nEXPORT_SYMBOL_GPL(coresight_timeout);\n\nu32 coresight_relaxed_read32(struct coresight_device *csdev, u32 offset)\n{\n\treturn csdev_access_relaxed_read32(&csdev->access, offset);\n}\n\nu32 coresight_read32(struct coresight_device *csdev, u32 offset)\n{\n\treturn csdev_access_read32(&csdev->access, offset);\n}\n\nvoid coresight_relaxed_write32(struct coresight_device *csdev,\n\t\t\t       u32 val, u32 offset)\n{\n\tcsdev_access_relaxed_write32(&csdev->access, val, offset);\n}\n\nvoid coresight_write32(struct coresight_device *csdev, u32 val, u32 offset)\n{\n\tcsdev_access_write32(&csdev->access, val, offset);\n}\n\nu64 coresight_relaxed_read64(struct coresight_device *csdev, u32 offset)\n{\n\treturn csdev_access_relaxed_read64(&csdev->access, offset);\n}\n\nu64 coresight_read64(struct coresight_device *csdev, u32 offset)\n{\n\treturn csdev_access_read64(&csdev->access, offset);\n}\n\nvoid coresight_relaxed_write64(struct coresight_device *csdev,\n\t\t\t       u64 val, u32 offset)\n{\n\tcsdev_access_relaxed_write64(&csdev->access, val, offset);\n}\n\nvoid coresight_write64(struct coresight_device *csdev, u64 val, u32 offset)\n{\n\tcsdev_access_write64(&csdev->access, val, offset);\n}\n\n \nvoid coresight_release_platform_data(struct coresight_device *csdev,\n\t\t\t\t     struct device *dev,\n\t\t\t\t     struct coresight_platform_data *pdata)\n{\n\tint i;\n\tstruct coresight_connection **conns = pdata->out_conns;\n\n\tfor (i = 0; i < pdata->nr_outconns; i++) {\n\t\t \n\t\tif (csdev && conns[i]->dest_dev)\n\t\t\tcoresight_remove_links(csdev, conns[i]);\n\t\t \n\t\tfwnode_handle_put(conns[i]->dest_fwnode);\n\t\tconns[i]->dest_fwnode = NULL;\n\t\tdevm_kfree(dev, conns[i]);\n\t}\n\tdevm_kfree(dev, pdata->out_conns);\n\tdevm_kfree(dev, pdata->in_conns);\n\tdevm_kfree(dev, pdata);\n\tif (csdev)\n\t\tcoresight_remove_conns_sysfs_group(csdev);\n}\n\nstruct coresight_device *coresight_register(struct coresight_desc *desc)\n{\n\tint ret;\n\tstruct coresight_device *csdev;\n\tbool registered = false;\n\n\tcsdev = kzalloc(sizeof(*csdev), GFP_KERNEL);\n\tif (!csdev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tcsdev->pdata = desc->pdata;\n\n\tcsdev->type = desc->type;\n\tcsdev->subtype = desc->subtype;\n\tcsdev->ops = desc->ops;\n\tcsdev->access = desc->access;\n\tcsdev->orphan = true;\n\n\tcsdev->dev.type = &coresight_dev_type[desc->type];\n\tcsdev->dev.groups = desc->groups;\n\tcsdev->dev.parent = desc->dev;\n\tcsdev->dev.release = coresight_device_release;\n\tcsdev->dev.bus = &coresight_bustype;\n\t \n\tcsdev->dev.fwnode = fwnode_handle_get(dev_fwnode(desc->dev));\n\tdev_set_name(&csdev->dev, \"%s\", desc->name);\n\n\t \n\tmutex_lock(&coresight_mutex);\n\n\tret = device_register(&csdev->dev);\n\tif (ret) {\n\t\tput_device(&csdev->dev);\n\t\t \n\t\tgoto out_unlock;\n\t}\n\n\tif (csdev->type == CORESIGHT_DEV_TYPE_SINK ||\n\t    csdev->type == CORESIGHT_DEV_TYPE_LINKSINK) {\n\t\tret = etm_perf_add_symlink_sink(csdev);\n\n\t\tif (ret) {\n\t\t\tdevice_unregister(&csdev->dev);\n\t\t\t \n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\t \n\tregistered = true;\n\n\tret = coresight_create_conns_sysfs_group(csdev);\n\tif (!ret)\n\t\tret = coresight_fixup_orphan_conns(csdev);\n\nout_unlock:\n\tmutex_unlock(&coresight_mutex);\n\t \n\tif (!ret) {\n\t\tif (cti_assoc_ops && cti_assoc_ops->add)\n\t\t\tcti_assoc_ops->add(csdev);\n\t\treturn csdev;\n\t}\n\n\t \n\tif (registered) {\n\t\tcoresight_unregister(csdev);\n\t\treturn ERR_PTR(ret);\n\t}\n\nerr_out:\n\t \n\tcoresight_release_platform_data(NULL, desc->dev, desc->pdata);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(coresight_register);\n\nvoid coresight_unregister(struct coresight_device *csdev)\n{\n\tetm_perf_del_symlink_sink(csdev);\n\t \n\tif (cti_assoc_ops && cti_assoc_ops->remove)\n\t\tcti_assoc_ops->remove(csdev);\n\tcoresight_remove_conns(csdev);\n\tcoresight_clear_default_sink(csdev);\n\tcoresight_release_platform_data(csdev, csdev->dev.parent, csdev->pdata);\n\tdevice_unregister(&csdev->dev);\n}\nEXPORT_SYMBOL_GPL(coresight_unregister);\n\n\n \nstatic inline int coresight_search_device_idx(struct coresight_dev_list *dict,\n\t\t\t\t\t      struct fwnode_handle *fwnode)\n{\n\tint i;\n\n\tfor (i = 0; i < dict->nr_idx; i++)\n\t\tif (dict->fwnode_list[i] == fwnode)\n\t\t\treturn i;\n\treturn -ENOENT;\n}\n\nstatic bool coresight_compare_type(enum coresight_dev_type type_a,\n\t\t\t\t   union coresight_dev_subtype subtype_a,\n\t\t\t\t   enum coresight_dev_type type_b,\n\t\t\t\t   union coresight_dev_subtype subtype_b)\n{\n\tif (type_a != type_b)\n\t\treturn false;\n\n\tswitch (type_a) {\n\tcase CORESIGHT_DEV_TYPE_SINK:\n\t\treturn subtype_a.sink_subtype == subtype_b.sink_subtype;\n\tcase CORESIGHT_DEV_TYPE_LINK:\n\t\treturn subtype_a.link_subtype == subtype_b.link_subtype;\n\tcase CORESIGHT_DEV_TYPE_LINKSINK:\n\t\treturn subtype_a.link_subtype == subtype_b.link_subtype &&\n\t\t       subtype_a.sink_subtype == subtype_b.sink_subtype;\n\tcase CORESIGHT_DEV_TYPE_SOURCE:\n\t\treturn subtype_a.source_subtype == subtype_b.source_subtype;\n\tcase CORESIGHT_DEV_TYPE_HELPER:\n\t\treturn subtype_a.helper_subtype == subtype_b.helper_subtype;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstruct coresight_device *\ncoresight_find_input_type(struct coresight_platform_data *pdata,\n\t\t\t  enum coresight_dev_type type,\n\t\t\t  union coresight_dev_subtype subtype)\n{\n\tint i;\n\tstruct coresight_connection *conn;\n\n\tfor (i = 0; i < pdata->nr_inconns; ++i) {\n\t\tconn = pdata->in_conns[i];\n\t\tif (conn &&\n\t\t    coresight_compare_type(type, subtype, conn->src_dev->type,\n\t\t\t\t\t   conn->src_dev->subtype))\n\t\t\treturn conn->src_dev;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(coresight_find_input_type);\n\nstruct coresight_device *\ncoresight_find_output_type(struct coresight_platform_data *pdata,\n\t\t\t   enum coresight_dev_type type,\n\t\t\t   union coresight_dev_subtype subtype)\n{\n\tint i;\n\tstruct coresight_connection *conn;\n\n\tfor (i = 0; i < pdata->nr_outconns; ++i) {\n\t\tconn = pdata->out_conns[i];\n\t\tif (conn->dest_dev &&\n\t\t    coresight_compare_type(type, subtype, conn->dest_dev->type,\n\t\t\t\t\t   conn->dest_dev->subtype))\n\t\t\treturn conn->dest_dev;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(coresight_find_output_type);\n\nbool coresight_loses_context_with_cpu(struct device *dev)\n{\n\treturn fwnode_property_present(dev_fwnode(dev),\n\t\t\t\t       \"arm,coresight-loses-context-with-cpu\");\n}\nEXPORT_SYMBOL_GPL(coresight_loses_context_with_cpu);\n\n \nchar *coresight_alloc_device_name(struct coresight_dev_list *dict,\n\t\t\t\t  struct device *dev)\n{\n\tint idx;\n\tchar *name = NULL;\n\tstruct fwnode_handle **list;\n\n\tmutex_lock(&coresight_mutex);\n\n\tidx = coresight_search_device_idx(dict, dev_fwnode(dev));\n\tif (idx < 0) {\n\t\t \n\t\tidx = dict->nr_idx;\n\t\tlist = krealloc_array(dict->fwnode_list,\n\t\t\t\t      idx + 1, sizeof(*dict->fwnode_list),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (ZERO_OR_NULL_PTR(list)) {\n\t\t\tidx = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist[idx] = dev_fwnode(dev);\n\t\tdict->fwnode_list = list;\n\t\tdict->nr_idx = idx + 1;\n\t}\n\n\tname = devm_kasprintf(dev, GFP_KERNEL, \"%s%d\", dict->pfx, idx);\ndone:\n\tmutex_unlock(&coresight_mutex);\n\treturn name;\n}\nEXPORT_SYMBOL_GPL(coresight_alloc_device_name);\n\nstruct bus_type coresight_bustype = {\n\t.name\t= \"coresight\",\n};\n\nstatic int __init coresight_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&coresight_bustype);\n\tif (ret)\n\t\treturn ret;\n\n\tret = etm_perf_init();\n\tif (ret)\n\t\tgoto exit_bus_unregister;\n\n\t \n\tret = cscfg_init();\n\tif (!ret)\n\t\treturn 0;\n\n\tetm_perf_exit();\nexit_bus_unregister:\n\tbus_unregister(&coresight_bustype);\n\treturn ret;\n}\n\nstatic void __exit coresight_exit(void)\n{\n\tcscfg_exit();\n\tetm_perf_exit();\n\tbus_unregister(&coresight_bustype);\n}\n\nmodule_init(coresight_init);\nmodule_exit(coresight_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Pratik Patel <pratikp@codeaurora.org>\");\nMODULE_AUTHOR(\"Mathieu Poirier <mathieu.poirier@linaro.org>\");\nMODULE_DESCRIPTION(\"Arm CoreSight tracer driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}