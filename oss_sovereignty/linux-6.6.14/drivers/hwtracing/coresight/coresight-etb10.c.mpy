{
  "module_name": "coresight-etb10.c",
  "hash_id": "604d2e52ade634be979cf20532331c2e9d79f5c1bce5630936e9a6a40060f901",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-etb10.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/pm_runtime.h>\n#include <linux/seq_file.h>\n#include <linux/coresight.h>\n#include <linux/amba/bus.h>\n#include <linux/clk.h>\n#include <linux/circ_buf.h>\n#include <linux/mm.h>\n#include <linux/perf_event.h>\n\n\n#include \"coresight-priv.h\"\n#include \"coresight-etm-perf.h\"\n\n#define ETB_RAM_DEPTH_REG\t0x004\n#define ETB_STATUS_REG\t\t0x00c\n#define ETB_RAM_READ_DATA_REG\t0x010\n#define ETB_RAM_READ_POINTER\t0x014\n#define ETB_RAM_WRITE_POINTER\t0x018\n#define ETB_TRG\t\t\t0x01c\n#define ETB_CTL_REG\t\t0x020\n#define ETB_RWD_REG\t\t0x024\n#define ETB_FFSR\t\t0x300\n#define ETB_FFCR\t\t0x304\n#define ETB_ITMISCOP0\t\t0xee0\n#define ETB_ITTRFLINACK\t\t0xee4\n#define ETB_ITTRFLIN\t\t0xee8\n#define ETB_ITATBDATA0\t\t0xeeC\n#define ETB_ITATBCTR2\t\t0xef0\n#define ETB_ITATBCTR1\t\t0xef4\n#define ETB_ITATBCTR0\t\t0xef8\n\n \n \n#define ETB_STATUS_RAM_FULL\tBIT(0)\n \n#define ETB_CTL_CAPT_EN\t\tBIT(0)\n \n#define ETB_FFCR_EN_FTC\t\tBIT(0)\n#define ETB_FFCR_FON_MAN\tBIT(6)\n#define ETB_FFCR_STOP_FI\tBIT(12)\n#define ETB_FFCR_STOP_TRIGGER\tBIT(13)\n\n#define ETB_FFCR_BIT\t\t6\n#define ETB_FFSR_BIT\t\t1\n#define ETB_FRAME_SIZE_WORDS\t4\n\nDEFINE_CORESIGHT_DEVLIST(etb_devs, \"etb\");\n\n \nstruct etb_drvdata {\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*atclk;\n\tstruct coresight_device\t*csdev;\n\tstruct miscdevice\tmiscdev;\n\tspinlock_t\t\tspinlock;\n\tlocal_t\t\t\treading;\n\tpid_t\t\t\tpid;\n\tu8\t\t\t*buf;\n\tu32\t\t\tmode;\n\tu32\t\t\tbuffer_depth;\n\tu32\t\t\ttrigger_cntr;\n};\n\nstatic int etb_set_buffer(struct coresight_device *csdev,\n\t\t\t  struct perf_output_handle *handle);\n\nstatic inline unsigned int etb_get_buffer_depth(struct etb_drvdata *drvdata)\n{\n\treturn readl_relaxed(drvdata->base + ETB_RAM_DEPTH_REG);\n}\n\nstatic void __etb_enable_hw(struct etb_drvdata *drvdata)\n{\n\tint i;\n\tu32 depth;\n\n\tCS_UNLOCK(drvdata->base);\n\n\tdepth = drvdata->buffer_depth;\n\t \n\twritel_relaxed(0x0, drvdata->base + ETB_RAM_WRITE_POINTER);\n\t \n\tfor (i = 0; i < depth; i++)\n\t\twritel_relaxed(0x0, drvdata->base + ETB_RWD_REG);\n\n\t \n\twritel_relaxed(0x0, drvdata->base + ETB_RAM_WRITE_POINTER);\n\t \n\twritel_relaxed(0x0, drvdata->base + ETB_RAM_READ_POINTER);\n\n\twritel_relaxed(drvdata->trigger_cntr, drvdata->base + ETB_TRG);\n\twritel_relaxed(ETB_FFCR_EN_FTC | ETB_FFCR_STOP_TRIGGER,\n\t\t       drvdata->base + ETB_FFCR);\n\t \n\twritel_relaxed(ETB_CTL_CAPT_EN, drvdata->base + ETB_CTL_REG);\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic int etb_enable_hw(struct etb_drvdata *drvdata)\n{\n\tint rc = coresight_claim_device(drvdata->csdev);\n\n\tif (rc)\n\t\treturn rc;\n\n\t__etb_enable_hw(drvdata);\n\treturn 0;\n}\n\nstatic int etb_enable_sysfs(struct coresight_device *csdev)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct etb_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\n\t \n\tif (drvdata->mode == CS_MODE_PERF) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (drvdata->mode == CS_MODE_DISABLED) {\n\t\tret = etb_enable_hw(drvdata);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tdrvdata->mode = CS_MODE_SYSFS;\n\t}\n\n\tatomic_inc(&csdev->refcnt);\nout:\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\treturn ret;\n}\n\nstatic int etb_enable_perf(struct coresight_device *csdev, void *data)\n{\n\tint ret = 0;\n\tpid_t pid;\n\tunsigned long flags;\n\tstruct etb_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tstruct perf_output_handle *handle = data;\n\tstruct cs_buffers *buf = etm_perf_sink_config(handle);\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\n\t \n\tif (drvdata->mode == CS_MODE_SYSFS) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tpid = buf->pid;\n\n\tif (drvdata->pid != -1 && drvdata->pid != pid) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (drvdata->pid == pid) {\n\t\tatomic_inc(&csdev->refcnt);\n\t\tgoto out;\n\t}\n\n\t \n\tret = etb_set_buffer(csdev, handle);\n\tif (ret)\n\t\tgoto out;\n\n\tret = etb_enable_hw(drvdata);\n\tif (!ret) {\n\t\t \n\t\tdrvdata->pid = pid;\n\t\tdrvdata->mode = CS_MODE_PERF;\n\t\tatomic_inc(&csdev->refcnt);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\treturn ret;\n}\n\nstatic int etb_enable(struct coresight_device *csdev, enum cs_mode mode,\n\t\t      void *data)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase CS_MODE_SYSFS:\n\t\tret = etb_enable_sysfs(csdev);\n\t\tbreak;\n\tcase CS_MODE_PERF:\n\t\tret = etb_enable_perf(csdev, data);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(&csdev->dev, \"ETB enabled\\n\");\n\treturn 0;\n}\n\nstatic void __etb_disable_hw(struct etb_drvdata *drvdata)\n{\n\tu32 ffcr;\n\tstruct device *dev = &drvdata->csdev->dev;\n\tstruct csdev_access *csa = &drvdata->csdev->access;\n\n\tCS_UNLOCK(drvdata->base);\n\n\tffcr = readl_relaxed(drvdata->base + ETB_FFCR);\n\t \n\tffcr |= ETB_FFCR_STOP_FI;\n\twritel_relaxed(ffcr, drvdata->base + ETB_FFCR);\n\t \n\tffcr |= ETB_FFCR_FON_MAN;\n\twritel_relaxed(ffcr, drvdata->base + ETB_FFCR);\n\n\tif (coresight_timeout(csa, ETB_FFCR, ETB_FFCR_BIT, 0)) {\n\t\tdev_err(dev,\n\t\t\"timeout while waiting for completion of Manual Flush\\n\");\n\t}\n\n\t \n\twritel_relaxed(0x0, drvdata->base + ETB_CTL_REG);\n\n\tif (coresight_timeout(csa, ETB_FFSR, ETB_FFSR_BIT, 1)) {\n\t\tdev_err(dev,\n\t\t\t\"timeout while waiting for Formatter to Stop\\n\");\n\t}\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic void etb_dump_hw(struct etb_drvdata *drvdata)\n{\n\tbool lost = false;\n\tint i;\n\tu8 *buf_ptr;\n\tu32 read_data, depth;\n\tu32 read_ptr, write_ptr;\n\tu32 frame_off, frame_endoff;\n\tstruct device *dev = &drvdata->csdev->dev;\n\n\tCS_UNLOCK(drvdata->base);\n\n\tread_ptr = readl_relaxed(drvdata->base + ETB_RAM_READ_POINTER);\n\twrite_ptr = readl_relaxed(drvdata->base + ETB_RAM_WRITE_POINTER);\n\n\tframe_off = write_ptr % ETB_FRAME_SIZE_WORDS;\n\tframe_endoff = ETB_FRAME_SIZE_WORDS - frame_off;\n\tif (frame_off) {\n\t\tdev_err(dev,\n\t\t\t\"write_ptr: %lu not aligned to formatter frame size\\n\",\n\t\t\t(unsigned long)write_ptr);\n\t\tdev_err(dev, \"frameoff: %lu, frame_endoff: %lu\\n\",\n\t\t\t(unsigned long)frame_off, (unsigned long)frame_endoff);\n\t\twrite_ptr += frame_endoff;\n\t}\n\n\tif ((readl_relaxed(drvdata->base + ETB_STATUS_REG)\n\t\t      & ETB_STATUS_RAM_FULL) == 0) {\n\t\twritel_relaxed(0x0, drvdata->base + ETB_RAM_READ_POINTER);\n\t} else {\n\t\twritel_relaxed(write_ptr, drvdata->base + ETB_RAM_READ_POINTER);\n\t\tlost = true;\n\t}\n\n\tdepth = drvdata->buffer_depth;\n\tbuf_ptr = drvdata->buf;\n\tfor (i = 0; i < depth; i++) {\n\t\tread_data = readl_relaxed(drvdata->base +\n\t\t\t\t\t  ETB_RAM_READ_DATA_REG);\n\t\t*(u32 *)buf_ptr = read_data;\n\t\tbuf_ptr += 4;\n\t}\n\n\tif (lost)\n\t\tcoresight_insert_barrier_packet(drvdata->buf);\n\n\tif (frame_off) {\n\t\tbuf_ptr -= (frame_endoff * 4);\n\t\tfor (i = 0; i < frame_endoff; i++) {\n\t\t\t*buf_ptr++ = 0x0;\n\t\t\t*buf_ptr++ = 0x0;\n\t\t\t*buf_ptr++ = 0x0;\n\t\t\t*buf_ptr++ = 0x0;\n\t\t}\n\t}\n\n\twritel_relaxed(read_ptr, drvdata->base + ETB_RAM_READ_POINTER);\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic void etb_disable_hw(struct etb_drvdata *drvdata)\n{\n\t__etb_disable_hw(drvdata);\n\tetb_dump_hw(drvdata);\n\tcoresight_disclaim_device(drvdata->csdev);\n}\n\nstatic int etb_disable(struct coresight_device *csdev)\n{\n\tstruct etb_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\n\tif (atomic_dec_return(&csdev->refcnt)) {\n\t\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tWARN_ON_ONCE(drvdata->mode == CS_MODE_DISABLED);\n\tetb_disable_hw(drvdata);\n\t \n\tdrvdata->pid = -1;\n\tdrvdata->mode = CS_MODE_DISABLED;\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\n\tdev_dbg(&csdev->dev, \"ETB disabled\\n\");\n\treturn 0;\n}\n\nstatic void *etb_alloc_buffer(struct coresight_device *csdev,\n\t\t\t      struct perf_event *event, void **pages,\n\t\t\t      int nr_pages, bool overwrite)\n{\n\tint node;\n\tstruct cs_buffers *buf;\n\n\tnode = (event->cpu == -1) ? NUMA_NO_NODE : cpu_to_node(event->cpu);\n\n\tbuf = kzalloc_node(sizeof(struct cs_buffers), GFP_KERNEL, node);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->pid = task_pid_nr(event->owner);\n\tbuf->snapshot = overwrite;\n\tbuf->nr_pages = nr_pages;\n\tbuf->data_pages = pages;\n\n\treturn buf;\n}\n\nstatic void etb_free_buffer(void *config)\n{\n\tstruct cs_buffers *buf = config;\n\n\tkfree(buf);\n}\n\nstatic int etb_set_buffer(struct coresight_device *csdev,\n\t\t\t  struct perf_output_handle *handle)\n{\n\tint ret = 0;\n\tunsigned long head;\n\tstruct cs_buffers *buf = etm_perf_sink_config(handle);\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\t \n\thead = handle->head & ((buf->nr_pages << PAGE_SHIFT) - 1);\n\n\t \n\tbuf->cur = head / PAGE_SIZE;\n\n\t \n\tbuf->offset = head % PAGE_SIZE;\n\n\tlocal_set(&buf->data_size, 0);\n\n\treturn ret;\n}\n\nstatic unsigned long etb_update_buffer(struct coresight_device *csdev,\n\t\t\t      struct perf_output_handle *handle,\n\t\t\t      void *sink_config)\n{\n\tbool lost = false;\n\tint i, cur;\n\tu8 *buf_ptr;\n\tconst u32 *barrier;\n\tu32 read_ptr, write_ptr, capacity;\n\tu32 status, read_data;\n\tunsigned long offset, to_read = 0, flags;\n\tstruct cs_buffers *buf = sink_config;\n\tstruct etb_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tif (!buf)\n\t\treturn 0;\n\n\tcapacity = drvdata->buffer_depth * ETB_FRAME_SIZE_WORDS;\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\n\t \n\tif (atomic_read(&csdev->refcnt) != 1)\n\t\tgoto out;\n\n\t__etb_disable_hw(drvdata);\n\tCS_UNLOCK(drvdata->base);\n\n\t \n\tread_ptr = readl_relaxed(drvdata->base + ETB_RAM_READ_POINTER);\n\twrite_ptr = readl_relaxed(drvdata->base + ETB_RAM_WRITE_POINTER);\n\n\t \n\tif (write_ptr % ETB_FRAME_SIZE_WORDS) {\n\t\tdev_err(&csdev->dev,\n\t\t\t\"write_ptr: %lu not aligned to formatter frame size\\n\",\n\t\t\t(unsigned long)write_ptr);\n\n\t\twrite_ptr &= ~(ETB_FRAME_SIZE_WORDS - 1);\n\t\tlost = true;\n\t}\n\n\t \n\tstatus = readl_relaxed(drvdata->base + ETB_STATUS_REG);\n\tif (status & ETB_STATUS_RAM_FULL) {\n\t\tlost = true;\n\t\tto_read = capacity;\n\t\tread_ptr = write_ptr;\n\t} else {\n\t\tto_read = CIRC_CNT(write_ptr, read_ptr, drvdata->buffer_depth);\n\t\tto_read *= ETB_FRAME_SIZE_WORDS;\n\t}\n\n\t \n\tif (!buf->snapshot && to_read > handle->size) {\n\t\tu32 mask = ~(ETB_FRAME_SIZE_WORDS - 1);\n\n\t\t \n\t\tto_read = handle->size & mask;\n\t\t \n\t\tread_ptr = (write_ptr + drvdata->buffer_depth) -\n\t\t\t\t\tto_read / ETB_FRAME_SIZE_WORDS;\n\t\t \n\t\tif (read_ptr > (drvdata->buffer_depth - 1))\n\t\t\tread_ptr -= drvdata->buffer_depth;\n\t\t \n\t\tlost = true;\n\t}\n\n\t \n\tif (!buf->snapshot && lost)\n\t\tperf_aux_output_flag(handle, PERF_AUX_FLAG_TRUNCATED);\n\n\t \n\twritel_relaxed(read_ptr, drvdata->base + ETB_RAM_READ_POINTER);\n\n\tcur = buf->cur;\n\toffset = buf->offset;\n\tbarrier = coresight_barrier_pkt;\n\n\tfor (i = 0; i < to_read; i += 4) {\n\t\tbuf_ptr = buf->data_pages[cur] + offset;\n\t\tread_data = readl_relaxed(drvdata->base +\n\t\t\t\t\t  ETB_RAM_READ_DATA_REG);\n\t\tif (lost && i < CORESIGHT_BARRIER_PKT_SIZE) {\n\t\t\tread_data = *barrier;\n\t\t\tbarrier++;\n\t\t}\n\n\t\t*(u32 *)buf_ptr = read_data;\n\t\tbuf_ptr += 4;\n\n\t\toffset += 4;\n\t\tif (offset >= PAGE_SIZE) {\n\t\t\toffset = 0;\n\t\t\tcur++;\n\t\t\t \n\t\t\tcur &= buf->nr_pages - 1;\n\t\t}\n\t}\n\n\t \n\twritel_relaxed(0x0, drvdata->base + ETB_RAM_READ_POINTER);\n\twritel_relaxed(0x0, drvdata->base + ETB_RAM_WRITE_POINTER);\n\n\t \n\tif (buf->snapshot)\n\t\thandle->head += to_read;\n\n\t__etb_enable_hw(drvdata);\n\tCS_LOCK(drvdata->base);\nout:\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\n\treturn to_read;\n}\n\nstatic const struct coresight_ops_sink etb_sink_ops = {\n\t.enable\t\t= etb_enable,\n\t.disable\t= etb_disable,\n\t.alloc_buffer\t= etb_alloc_buffer,\n\t.free_buffer\t= etb_free_buffer,\n\t.update_buffer\t= etb_update_buffer,\n};\n\nstatic const struct coresight_ops etb_cs_ops = {\n\t.sink_ops\t= &etb_sink_ops,\n};\n\nstatic void etb_dump(struct etb_drvdata *drvdata)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&drvdata->spinlock, flags);\n\tif (drvdata->mode == CS_MODE_SYSFS) {\n\t\t__etb_disable_hw(drvdata);\n\t\tetb_dump_hw(drvdata);\n\t\t__etb_enable_hw(drvdata);\n\t}\n\tspin_unlock_irqrestore(&drvdata->spinlock, flags);\n\n\tdev_dbg(&drvdata->csdev->dev, \"ETB dumped\\n\");\n}\n\nstatic int etb_open(struct inode *inode, struct file *file)\n{\n\tstruct etb_drvdata *drvdata = container_of(file->private_data,\n\t\t\t\t\t\t   struct etb_drvdata, miscdev);\n\n\tif (local_cmpxchg(&drvdata->reading, 0, 1))\n\t\treturn -EBUSY;\n\n\tdev_dbg(&drvdata->csdev->dev, \"%s: successfully opened\\n\", __func__);\n\treturn 0;\n}\n\nstatic ssize_t etb_read(struct file *file, char __user *data,\n\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tu32 depth;\n\tstruct etb_drvdata *drvdata = container_of(file->private_data,\n\t\t\t\t\t\t   struct etb_drvdata, miscdev);\n\tstruct device *dev = &drvdata->csdev->dev;\n\n\tetb_dump(drvdata);\n\n\tdepth = drvdata->buffer_depth;\n\tif (*ppos + len > depth * 4)\n\t\tlen = depth * 4 - *ppos;\n\n\tif (copy_to_user(data, drvdata->buf + *ppos, len)) {\n\t\tdev_dbg(dev,\n\t\t\t\"%s: copy_to_user failed\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\t*ppos += len;\n\n\tdev_dbg(dev, \"%s: %zu bytes copied, %d bytes left\\n\",\n\t\t__func__, len, (int)(depth * 4 - *ppos));\n\treturn len;\n}\n\nstatic int etb_release(struct inode *inode, struct file *file)\n{\n\tstruct etb_drvdata *drvdata = container_of(file->private_data,\n\t\t\t\t\t\t   struct etb_drvdata, miscdev);\n\tlocal_set(&drvdata->reading, 0);\n\n\tdev_dbg(&drvdata->csdev->dev, \"%s: released\\n\", __func__);\n\treturn 0;\n}\n\nstatic const struct file_operations etb_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= etb_open,\n\t.read\t\t= etb_read,\n\t.release\t= etb_release,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct attribute *coresight_etb_mgmt_attrs[] = {\n\tcoresight_simple_reg32(rdp, ETB_RAM_DEPTH_REG),\n\tcoresight_simple_reg32(sts, ETB_STATUS_REG),\n\tcoresight_simple_reg32(rrp, ETB_RAM_READ_POINTER),\n\tcoresight_simple_reg32(rwp, ETB_RAM_WRITE_POINTER),\n\tcoresight_simple_reg32(trg, ETB_TRG),\n\tcoresight_simple_reg32(ctl, ETB_CTL_REG),\n\tcoresight_simple_reg32(ffsr, ETB_FFSR),\n\tcoresight_simple_reg32(ffcr, ETB_FFCR),\n\tNULL,\n};\n\nstatic ssize_t trigger_cntr_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct etb_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tunsigned long val = drvdata->trigger_cntr;\n\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\n\nstatic ssize_t trigger_cntr_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t size)\n{\n\tint ret;\n\tunsigned long val;\n\tstruct etb_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tdrvdata->trigger_cntr = val;\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(trigger_cntr);\n\nstatic struct attribute *coresight_etb_attrs[] = {\n\t&dev_attr_trigger_cntr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group coresight_etb_group = {\n\t.attrs = coresight_etb_attrs,\n};\n\nstatic const struct attribute_group coresight_etb_mgmt_group = {\n\t.attrs = coresight_etb_mgmt_attrs,\n\t.name = \"mgmt\",\n};\n\nstatic const struct attribute_group *coresight_etb_groups[] = {\n\t&coresight_etb_group,\n\t&coresight_etb_mgmt_group,\n\tNULL,\n};\n\nstatic int etb_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tint ret;\n\tvoid __iomem *base;\n\tstruct device *dev = &adev->dev;\n\tstruct coresight_platform_data *pdata = NULL;\n\tstruct etb_drvdata *drvdata;\n\tstruct resource *res = &adev->res;\n\tstruct coresight_desc desc = { 0 };\n\n\tdesc.name = coresight_alloc_device_name(&etb_devs, dev);\n\tif (!desc.name)\n\t\treturn -ENOMEM;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->atclk = devm_clk_get(&adev->dev, \"atclk\");  \n\tif (!IS_ERR(drvdata->atclk)) {\n\t\tret = clk_prepare_enable(drvdata->atclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tdev_set_drvdata(dev, drvdata);\n\n\t \n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdrvdata->base = base;\n\tdesc.access = CSDEV_ACCESS_IOMEM(base);\n\n\tspin_lock_init(&drvdata->spinlock);\n\n\tdrvdata->buffer_depth = etb_get_buffer_depth(drvdata);\n\n\tif (drvdata->buffer_depth & 0x80000000)\n\t\treturn -EINVAL;\n\n\tdrvdata->buf = devm_kcalloc(dev,\n\t\t\t\t    drvdata->buffer_depth, 4, GFP_KERNEL);\n\tif (!drvdata->buf)\n\t\treturn -ENOMEM;\n\n\t \n\tdrvdata->pid = -1;\n\n\tpdata = coresight_get_platform_data(dev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\tadev->dev.platform_data = pdata;\n\n\tdesc.type = CORESIGHT_DEV_TYPE_SINK;\n\tdesc.subtype.sink_subtype = CORESIGHT_DEV_SUBTYPE_SINK_BUFFER;\n\tdesc.ops = &etb_cs_ops;\n\tdesc.pdata = pdata;\n\tdesc.dev = dev;\n\tdesc.groups = coresight_etb_groups;\n\tdrvdata->csdev = coresight_register(&desc);\n\tif (IS_ERR(drvdata->csdev))\n\t\treturn PTR_ERR(drvdata->csdev);\n\n\tdrvdata->miscdev.name = desc.name;\n\tdrvdata->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tdrvdata->miscdev.fops = &etb_fops;\n\tret = misc_register(&drvdata->miscdev);\n\tif (ret)\n\t\tgoto err_misc_register;\n\n\tpm_runtime_put(&adev->dev);\n\treturn 0;\n\nerr_misc_register:\n\tcoresight_unregister(drvdata->csdev);\n\treturn ret;\n}\n\nstatic void etb_remove(struct amba_device *adev)\n{\n\tstruct etb_drvdata *drvdata = dev_get_drvdata(&adev->dev);\n\n\t \n\tmisc_deregister(&drvdata->miscdev);\n\tcoresight_unregister(drvdata->csdev);\n}\n\n#ifdef CONFIG_PM\nstatic int etb_runtime_suspend(struct device *dev)\n{\n\tstruct etb_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tif (drvdata && !IS_ERR(drvdata->atclk))\n\t\tclk_disable_unprepare(drvdata->atclk);\n\n\treturn 0;\n}\n\nstatic int etb_runtime_resume(struct device *dev)\n{\n\tstruct etb_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tif (drvdata && !IS_ERR(drvdata->atclk))\n\t\tclk_prepare_enable(drvdata->atclk);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops etb_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(etb_runtime_suspend, etb_runtime_resume, NULL)\n};\n\nstatic const struct amba_id etb_ids[] = {\n\t{\n\t\t.id\t= 0x000bb907,\n\t\t.mask\t= 0x000fffff,\n\t},\n\t{ 0, 0},\n};\n\nMODULE_DEVICE_TABLE(amba, etb_ids);\n\nstatic struct amba_driver etb_driver = {\n\t.drv = {\n\t\t.name\t= \"coresight-etb10\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= &etb_dev_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\n\t},\n\t.probe\t\t= etb_probe,\n\t.remove\t\t= etb_remove,\n\t.id_table\t= etb_ids,\n};\n\nmodule_amba_driver(etb_driver);\n\nMODULE_AUTHOR(\"Pratik Patel <pratikp@codeaurora.org>\");\nMODULE_AUTHOR(\"Mathieu Poirier <mathieu.poirier@linaro.org>\");\nMODULE_DESCRIPTION(\"Arm CoreSight Embedded Trace Buffer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}