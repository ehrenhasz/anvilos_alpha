{
  "module_name": "coresight-trbe.c",
  "hash_id": "8cf79f190d67791dfbca928143a6ebff39359f92b3d3a2e392fc511661b378c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-trbe.c",
  "human_readable_source": "\n \n#define DRVNAME \"arm_trbe\"\n\n#define pr_fmt(fmt) DRVNAME \": \" fmt\n\n#include <asm/barrier.h>\n#include <asm/cpufeature.h>\n\n#include \"coresight-self-hosted-trace.h\"\n#include \"coresight-trbe.h\"\n\n#define PERF_IDX2OFF(idx, buf) ((idx) % ((buf)->nr_pages << PAGE_SHIFT))\n\n \n#define ETE_IGNORE_PACKET\t\t0x70\n\n \n#define TRBE_TRACE_MIN_BUF_SIZE\t\t64\n\nenum trbe_fault_action {\n\tTRBE_FAULT_ACT_WRAP,\n\tTRBE_FAULT_ACT_SPURIOUS,\n\tTRBE_FAULT_ACT_FATAL,\n};\n\nstruct trbe_buf {\n\t \n\tunsigned long trbe_base;\n\t \n\tunsigned long trbe_hw_base;\n\tunsigned long trbe_limit;\n\tunsigned long trbe_write;\n\tint nr_pages;\n\tvoid **pages;\n\tbool snapshot;\n\tstruct trbe_cpudata *cpudata;\n};\n\n \n#define TRBE_WORKAROUND_OVERWRITE_FILL_MODE\t0\n#define TRBE_WORKAROUND_WRITE_OUT_OF_RANGE\t1\n#define TRBE_NEEDS_DRAIN_AFTER_DISABLE\t\t2\n#define TRBE_NEEDS_CTXT_SYNC_AFTER_ENABLE\t3\n#define TRBE_IS_BROKEN\t\t\t\t4\n\nstatic int trbe_errata_cpucaps[] = {\n\t[TRBE_WORKAROUND_OVERWRITE_FILL_MODE] = ARM64_WORKAROUND_TRBE_OVERWRITE_FILL_MODE,\n\t[TRBE_WORKAROUND_WRITE_OUT_OF_RANGE] = ARM64_WORKAROUND_TRBE_WRITE_OUT_OF_RANGE,\n\t[TRBE_NEEDS_DRAIN_AFTER_DISABLE] = ARM64_WORKAROUND_2064142,\n\t[TRBE_NEEDS_CTXT_SYNC_AFTER_ENABLE] = ARM64_WORKAROUND_2038923,\n\t[TRBE_IS_BROKEN] = ARM64_WORKAROUND_1902691,\n\t-1,\t\t \n};\n\n \n#define TRBE_ERRATA_MAX\t\t\t(ARRAY_SIZE(trbe_errata_cpucaps) - 1)\n\n \n#define TRBE_WORKAROUND_OVERWRITE_FILL_MODE_SKIP_BYTES\t256\n\n \nstruct trbe_cpudata {\n\tbool trbe_flag;\n\tu64 trbe_hw_align;\n\tu64 trbe_align;\n\tint cpu;\n\tenum cs_mode mode;\n\tstruct trbe_buf *buf;\n\tstruct trbe_drvdata *drvdata;\n\tDECLARE_BITMAP(errata, TRBE_ERRATA_MAX);\n};\n\nstruct trbe_drvdata {\n\tstruct trbe_cpudata __percpu *cpudata;\n\tstruct perf_output_handle * __percpu *handle;\n\tstruct hlist_node hotplug_node;\n\tint irq;\n\tcpumask_t supported_cpus;\n\tenum cpuhp_state trbe_online;\n\tstruct platform_device *pdev;\n};\n\nstatic void trbe_check_errata(struct trbe_cpudata *cpudata)\n{\n\tint i;\n\n\tfor (i = 0; i < TRBE_ERRATA_MAX; i++) {\n\t\tint cap = trbe_errata_cpucaps[i];\n\n\t\tif (WARN_ON_ONCE(cap < 0))\n\t\t\treturn;\n\t\tif (this_cpu_has_cap(cap))\n\t\t\tset_bit(i, cpudata->errata);\n\t}\n}\n\nstatic inline bool trbe_has_erratum(struct trbe_cpudata *cpudata, int i)\n{\n\treturn (i < TRBE_ERRATA_MAX) && test_bit(i, cpudata->errata);\n}\n\nstatic inline bool trbe_may_overwrite_in_fill_mode(struct trbe_cpudata *cpudata)\n{\n\treturn trbe_has_erratum(cpudata, TRBE_WORKAROUND_OVERWRITE_FILL_MODE);\n}\n\nstatic inline bool trbe_may_write_out_of_range(struct trbe_cpudata *cpudata)\n{\n\treturn trbe_has_erratum(cpudata, TRBE_WORKAROUND_WRITE_OUT_OF_RANGE);\n}\n\nstatic inline bool trbe_needs_drain_after_disable(struct trbe_cpudata *cpudata)\n{\n\t \n\treturn trbe_has_erratum(cpudata, TRBE_NEEDS_DRAIN_AFTER_DISABLE);\n}\n\nstatic inline bool trbe_needs_ctxt_sync_after_enable(struct trbe_cpudata *cpudata)\n{\n\t \n\treturn trbe_has_erratum(cpudata, TRBE_NEEDS_CTXT_SYNC_AFTER_ENABLE);\n}\n\nstatic inline bool trbe_is_broken(struct trbe_cpudata *cpudata)\n{\n\treturn trbe_has_erratum(cpudata, TRBE_IS_BROKEN);\n}\n\nstatic int trbe_alloc_node(struct perf_event *event)\n{\n\tif (event->cpu == -1)\n\t\treturn NUMA_NO_NODE;\n\treturn cpu_to_node(event->cpu);\n}\n\nstatic inline void trbe_drain_buffer(void)\n{\n\ttsb_csync();\n\tdsb(nsh);\n}\n\nstatic inline void set_trbe_enabled(struct trbe_cpudata *cpudata, u64 trblimitr)\n{\n\t \n\ttrblimitr |= TRBLIMITR_EL1_E;\n\twrite_sysreg_s(trblimitr, SYS_TRBLIMITR_EL1);\n\n\t \n\tisb();\n\n\tif (trbe_needs_ctxt_sync_after_enable(cpudata))\n\t\tisb();\n}\n\nstatic inline void set_trbe_disabled(struct trbe_cpudata *cpudata)\n{\n\tu64 trblimitr = read_sysreg_s(SYS_TRBLIMITR_EL1);\n\n\t \n\ttrblimitr &= ~TRBLIMITR_EL1_E;\n\twrite_sysreg_s(trblimitr, SYS_TRBLIMITR_EL1);\n\n\tif (trbe_needs_drain_after_disable(cpudata))\n\t\ttrbe_drain_buffer();\n\tisb();\n}\n\nstatic void trbe_drain_and_disable_local(struct trbe_cpudata *cpudata)\n{\n\ttrbe_drain_buffer();\n\tset_trbe_disabled(cpudata);\n}\n\nstatic void trbe_reset_local(struct trbe_cpudata *cpudata)\n{\n\ttrbe_drain_and_disable_local(cpudata);\n\twrite_sysreg_s(0, SYS_TRBLIMITR_EL1);\n\twrite_sysreg_s(0, SYS_TRBPTR_EL1);\n\twrite_sysreg_s(0, SYS_TRBBASER_EL1);\n\twrite_sysreg_s(0, SYS_TRBSR_EL1);\n}\n\nstatic void trbe_report_wrap_event(struct perf_output_handle *handle)\n{\n\t \n\tperf_aux_output_flag(handle, PERF_AUX_FLAG_COLLISION);\n}\n\nstatic void trbe_stop_and_truncate_event(struct perf_output_handle *handle)\n{\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\n\t \n\ttrbe_drain_and_disable_local(buf->cpudata);\n\tperf_aux_output_flag(handle, PERF_AUX_FLAG_TRUNCATED);\n\tperf_aux_output_end(handle, 0);\n\t*this_cpu_ptr(buf->cpudata->drvdata->handle) = NULL;\n}\n\n \n\nstatic void __trbe_pad_buf(struct trbe_buf *buf, u64 offset, int len)\n{\n\tmemset((void *)buf->trbe_base + offset, ETE_IGNORE_PACKET, len);\n}\n\nstatic void trbe_pad_buf(struct perf_output_handle *handle, int len)\n{\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\tu64 head = PERF_IDX2OFF(handle->head, buf);\n\n\t__trbe_pad_buf(buf, head, len);\n\tif (!buf->snapshot)\n\t\tperf_aux_output_skip(handle, len);\n}\n\nstatic unsigned long trbe_snapshot_offset(struct perf_output_handle *handle)\n{\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\n\t \n\treturn buf->nr_pages * PAGE_SIZE;\n}\n\nstatic u64 trbe_min_trace_buf_size(struct perf_output_handle *handle)\n{\n\tu64 size = TRBE_TRACE_MIN_BUF_SIZE;\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\tstruct trbe_cpudata *cpudata = buf->cpudata;\n\n\t \n\tif (trbe_may_write_out_of_range(cpudata))\n\t\tsize += PAGE_SIZE;\n\treturn size;\n}\n\n \nstatic unsigned long __trbe_normal_offset(struct perf_output_handle *handle)\n{\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\tstruct trbe_cpudata *cpudata = buf->cpudata;\n\tconst u64 bufsize = buf->nr_pages * PAGE_SIZE;\n\tu64 limit = bufsize;\n\tu64 head, tail, wakeup;\n\n\thead = PERF_IDX2OFF(handle->head, buf);\n\n\t \n\tif (!IS_ALIGNED(head, cpudata->trbe_align)) {\n\t\tunsigned long delta = roundup(head, cpudata->trbe_align) - head;\n\n\t\tdelta = min(delta, handle->size);\n\t\ttrbe_pad_buf(handle, delta);\n\t\thead = PERF_IDX2OFF(handle->head, buf);\n\t}\n\n\t \n\tif (!handle->size)\n\t\treturn 0;\n\n\t \n\ttail = PERF_IDX2OFF(handle->head + handle->size, buf);\n\twakeup = PERF_IDX2OFF(handle->wakeup, buf);\n\n\t \n\tif (head < tail)\n\t\tlimit = round_down(tail, PAGE_SIZE);\n\n\t \n\tif (handle->wakeup < (handle->head + handle->size) && head <= wakeup)\n\t\tlimit = min(limit, round_up(wakeup, PAGE_SIZE));\n\n\t \n\tif (limit > head)\n\t\treturn limit;\n\n\ttrbe_pad_buf(handle, handle->size);\n\treturn 0;\n}\n\nstatic unsigned long trbe_normal_offset(struct perf_output_handle *handle)\n{\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\tu64 limit = __trbe_normal_offset(handle);\n\tu64 head = PERF_IDX2OFF(handle->head, buf);\n\n\t \n\twhile (limit && ((limit - head) < trbe_min_trace_buf_size(handle))) {\n\t\ttrbe_pad_buf(handle, limit - head);\n\t\tlimit = __trbe_normal_offset(handle);\n\t\thead = PERF_IDX2OFF(handle->head, buf);\n\t}\n\treturn limit;\n}\n\nstatic unsigned long compute_trbe_buffer_limit(struct perf_output_handle *handle)\n{\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\tunsigned long offset;\n\n\tif (buf->snapshot)\n\t\toffset = trbe_snapshot_offset(handle);\n\telse\n\t\toffset = trbe_normal_offset(handle);\n\treturn buf->trbe_base + offset;\n}\n\nstatic void clr_trbe_status(void)\n{\n\tu64 trbsr = read_sysreg_s(SYS_TRBSR_EL1);\n\n\tWARN_ON(is_trbe_enabled());\n\ttrbsr &= ~TRBSR_EL1_IRQ;\n\ttrbsr &= ~TRBSR_EL1_TRG;\n\ttrbsr &= ~TRBSR_EL1_WRAP;\n\ttrbsr &= ~TRBSR_EL1_EC_MASK;\n\ttrbsr &= ~TRBSR_EL1_BSC_MASK;\n\ttrbsr &= ~TRBSR_EL1_S;\n\twrite_sysreg_s(trbsr, SYS_TRBSR_EL1);\n}\n\nstatic void set_trbe_limit_pointer_enabled(struct trbe_buf *buf)\n{\n\tu64 trblimitr = read_sysreg_s(SYS_TRBLIMITR_EL1);\n\tunsigned long addr = buf->trbe_limit;\n\n\tWARN_ON(!IS_ALIGNED(addr, (1UL << TRBLIMITR_EL1_LIMIT_SHIFT)));\n\tWARN_ON(!IS_ALIGNED(addr, PAGE_SIZE));\n\n\ttrblimitr &= ~TRBLIMITR_EL1_nVM;\n\ttrblimitr &= ~TRBLIMITR_EL1_FM_MASK;\n\ttrblimitr &= ~TRBLIMITR_EL1_TM_MASK;\n\ttrblimitr &= ~TRBLIMITR_EL1_LIMIT_MASK;\n\n\t \n\ttrblimitr |= (TRBLIMITR_EL1_FM_FILL << TRBLIMITR_EL1_FM_SHIFT) &\n\t\t     TRBLIMITR_EL1_FM_MASK;\n\n\t \n\ttrblimitr |= (TRBLIMITR_EL1_TM_IGNR << TRBLIMITR_EL1_TM_SHIFT) &\n\t\t     TRBLIMITR_EL1_TM_MASK;\n\ttrblimitr |= (addr & PAGE_MASK);\n\tset_trbe_enabled(buf->cpudata, trblimitr);\n}\n\nstatic void trbe_enable_hw(struct trbe_buf *buf)\n{\n\tWARN_ON(buf->trbe_hw_base < buf->trbe_base);\n\tWARN_ON(buf->trbe_write < buf->trbe_hw_base);\n\tWARN_ON(buf->trbe_write >= buf->trbe_limit);\n\tset_trbe_disabled(buf->cpudata);\n\tclr_trbe_status();\n\tset_trbe_base_pointer(buf->trbe_hw_base);\n\tset_trbe_write_pointer(buf->trbe_write);\n\n\t \n\tisb();\n\tset_trbe_limit_pointer_enabled(buf);\n}\n\nstatic enum trbe_fault_action trbe_get_fault_act(struct perf_output_handle *handle,\n\t\t\t\t\t\t u64 trbsr)\n{\n\tint ec = get_trbe_ec(trbsr);\n\tint bsc = get_trbe_bsc(trbsr);\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\tstruct trbe_cpudata *cpudata = buf->cpudata;\n\n\tWARN_ON(is_trbe_running(trbsr));\n\tif (is_trbe_trg(trbsr) || is_trbe_abort(trbsr))\n\t\treturn TRBE_FAULT_ACT_FATAL;\n\n\tif ((ec == TRBE_EC_STAGE1_ABORT) || (ec == TRBE_EC_STAGE2_ABORT))\n\t\treturn TRBE_FAULT_ACT_FATAL;\n\n\t \n\tif ((is_trbe_wrap(trbsr) && (ec == TRBE_EC_OTHERS) && (bsc == TRBE_BSC_FILLED)) &&\n\t    (trbe_may_overwrite_in_fill_mode(cpudata) ||\n\t     get_trbe_write_pointer() == get_trbe_base_pointer()))\n\t\treturn TRBE_FAULT_ACT_WRAP;\n\n\treturn TRBE_FAULT_ACT_SPURIOUS;\n}\n\nstatic unsigned long trbe_get_trace_size(struct perf_output_handle *handle,\n\t\t\t\t\t struct trbe_buf *buf, bool wrap)\n{\n\tu64 write;\n\tu64 start_off, end_off;\n\tu64 size;\n\tu64 overwrite_skip = TRBE_WORKAROUND_OVERWRITE_FILL_MODE_SKIP_BYTES;\n\n\t \n\tif (wrap)\n\t\twrite = get_trbe_limit_pointer();\n\telse\n\t\twrite = get_trbe_write_pointer();\n\n\t \n\tend_off = write - buf->trbe_base;\n\tstart_off = PERF_IDX2OFF(handle->head, buf);\n\n\tif (WARN_ON_ONCE(end_off < start_off))\n\t\treturn 0;\n\n\tsize = end_off - start_off;\n\t \n\tif (trbe_has_erratum(buf->cpudata, TRBE_WORKAROUND_OVERWRITE_FILL_MODE) &&\n\t    !WARN_ON(size < overwrite_skip))\n\t\t__trbe_pad_buf(buf, start_off, overwrite_skip);\n\n\treturn size;\n}\n\nstatic void *arm_trbe_alloc_buffer(struct coresight_device *csdev,\n\t\t\t\t   struct perf_event *event, void **pages,\n\t\t\t\t   int nr_pages, bool snapshot)\n{\n\tstruct trbe_buf *buf;\n\tstruct page **pglist;\n\tint i;\n\n\t \n\tif (nr_pages < 2)\n\t\treturn NULL;\n\n\tbuf = kzalloc_node(sizeof(*buf), GFP_KERNEL, trbe_alloc_node(event));\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpglist = kcalloc(nr_pages, sizeof(*pglist), GFP_KERNEL);\n\tif (!pglist) {\n\t\tkfree(buf);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 0; i < nr_pages; i++)\n\t\tpglist[i] = virt_to_page(pages[i]);\n\n\tbuf->trbe_base = (unsigned long)vmap(pglist, nr_pages, VM_MAP, PAGE_KERNEL);\n\tif (!buf->trbe_base) {\n\t\tkfree(pglist);\n\t\tkfree(buf);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tbuf->trbe_limit = buf->trbe_base + nr_pages * PAGE_SIZE;\n\tbuf->trbe_write = buf->trbe_base;\n\tbuf->snapshot = snapshot;\n\tbuf->nr_pages = nr_pages;\n\tbuf->pages = pages;\n\tkfree(pglist);\n\treturn buf;\n}\n\nstatic void arm_trbe_free_buffer(void *config)\n{\n\tstruct trbe_buf *buf = config;\n\n\tvunmap((void *)buf->trbe_base);\n\tkfree(buf);\n}\n\nstatic unsigned long arm_trbe_update_buffer(struct coresight_device *csdev,\n\t\t\t\t\t    struct perf_output_handle *handle,\n\t\t\t\t\t    void *config)\n{\n\tstruct trbe_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tstruct trbe_cpudata *cpudata = dev_get_drvdata(&csdev->dev);\n\tstruct trbe_buf *buf = config;\n\tenum trbe_fault_action act;\n\tunsigned long size, status;\n\tunsigned long flags;\n\tbool wrap = false;\n\n\tWARN_ON(buf->cpudata != cpudata);\n\tWARN_ON(cpudata->cpu != smp_processor_id());\n\tWARN_ON(cpudata->drvdata != drvdata);\n\tif (cpudata->mode != CS_MODE_PERF)\n\t\treturn 0;\n\n\t \n\tlocal_irq_save(flags);\n\n\t \n\tif (!is_trbe_enabled()) {\n\t\tsize = 0;\n\t\tgoto done;\n\t}\n\t \n\ttrbe_drain_and_disable_local(cpudata);\n\n\t \n\tstatus = read_sysreg_s(SYS_TRBSR_EL1);\n\tif (is_trbe_irq(status)) {\n\n\t\t \n\t\tclr_trbe_irq();\n\t\tisb();\n\n\t\tact = trbe_get_fault_act(handle, status);\n\t\t \n\t\tif (act != TRBE_FAULT_ACT_WRAP) {\n\t\t\tsize = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\ttrbe_report_wrap_event(handle);\n\t\twrap = true;\n\t}\n\n\tsize = trbe_get_trace_size(handle, buf, wrap);\n\ndone:\n\tlocal_irq_restore(flags);\n\n\tif (buf->snapshot)\n\t\thandle->head += size;\n\treturn size;\n}\n\n\nstatic int trbe_apply_work_around_before_enable(struct trbe_buf *buf)\n{\n\t \n\tif (trbe_has_erratum(buf->cpudata, TRBE_WORKAROUND_OVERWRITE_FILL_MODE)) {\n\t\tif (WARN_ON(!IS_ALIGNED(buf->trbe_write, PAGE_SIZE)))\n\t\t\treturn -EINVAL;\n\t\tbuf->trbe_hw_base = buf->trbe_write;\n\t\tbuf->trbe_write += TRBE_WORKAROUND_OVERWRITE_FILL_MODE_SKIP_BYTES;\n\t}\n\n\t \n\tif (trbe_has_erratum(buf->cpudata, TRBE_WORKAROUND_WRITE_OUT_OF_RANGE)) {\n\t\ts64 space = buf->trbe_limit - buf->trbe_write;\n\t\t \n\t\tif (WARN_ON(space <= PAGE_SIZE ||\n\t\t\t    !IS_ALIGNED(buf->trbe_limit, PAGE_SIZE)))\n\t\t\treturn -EINVAL;\n\t\tbuf->trbe_limit -= PAGE_SIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic int __arm_trbe_enable(struct trbe_buf *buf,\n\t\t\t     struct perf_output_handle *handle)\n{\n\tint ret = 0;\n\n\tperf_aux_output_flag(handle, PERF_AUX_FLAG_CORESIGHT_FORMAT_RAW);\n\tbuf->trbe_limit = compute_trbe_buffer_limit(handle);\n\tbuf->trbe_write = buf->trbe_base + PERF_IDX2OFF(handle->head, buf);\n\tif (buf->trbe_limit == buf->trbe_base) {\n\t\tret = -ENOSPC;\n\t\tgoto err;\n\t}\n\t \n\tbuf->trbe_hw_base = buf->trbe_base;\n\n\tret = trbe_apply_work_around_before_enable(buf);\n\tif (ret)\n\t\tgoto err;\n\n\t*this_cpu_ptr(buf->cpudata->drvdata->handle) = handle;\n\ttrbe_enable_hw(buf);\n\treturn 0;\nerr:\n\ttrbe_stop_and_truncate_event(handle);\n\treturn ret;\n}\n\nstatic int arm_trbe_enable(struct coresight_device *csdev, enum cs_mode mode,\n\t\t\t   void *data)\n{\n\tstruct trbe_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tstruct trbe_cpudata *cpudata = dev_get_drvdata(&csdev->dev);\n\tstruct perf_output_handle *handle = data;\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\n\tWARN_ON(cpudata->cpu != smp_processor_id());\n\tWARN_ON(cpudata->drvdata != drvdata);\n\tif (mode != CS_MODE_PERF)\n\t\treturn -EINVAL;\n\n\tcpudata->buf = buf;\n\tcpudata->mode = mode;\n\tbuf->cpudata = cpudata;\n\n\treturn __arm_trbe_enable(buf, handle);\n}\n\nstatic int arm_trbe_disable(struct coresight_device *csdev)\n{\n\tstruct trbe_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tstruct trbe_cpudata *cpudata = dev_get_drvdata(&csdev->dev);\n\tstruct trbe_buf *buf = cpudata->buf;\n\n\tWARN_ON(buf->cpudata != cpudata);\n\tWARN_ON(cpudata->cpu != smp_processor_id());\n\tWARN_ON(cpudata->drvdata != drvdata);\n\tif (cpudata->mode != CS_MODE_PERF)\n\t\treturn -EINVAL;\n\n\ttrbe_drain_and_disable_local(cpudata);\n\tbuf->cpudata = NULL;\n\tcpudata->buf = NULL;\n\tcpudata->mode = CS_MODE_DISABLED;\n\treturn 0;\n}\n\nstatic void trbe_handle_spurious(struct perf_output_handle *handle)\n{\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\tu64 trblimitr = read_sysreg_s(SYS_TRBLIMITR_EL1);\n\n\t \n\tset_trbe_enabled(buf->cpudata, trblimitr);\n}\n\nstatic int trbe_handle_overflow(struct perf_output_handle *handle)\n{\n\tstruct perf_event *event = handle->event;\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\tunsigned long size;\n\tstruct etm_event_data *event_data;\n\n\tsize = trbe_get_trace_size(handle, buf, true);\n\tif (buf->snapshot)\n\t\thandle->head += size;\n\n\ttrbe_report_wrap_event(handle);\n\tperf_aux_output_end(handle, size);\n\tevent_data = perf_aux_output_begin(handle, event);\n\tif (!event_data) {\n\t\t \n\t\ttrbe_drain_and_disable_local(buf->cpudata);\n\t\t*this_cpu_ptr(buf->cpudata->drvdata->handle) = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\treturn __arm_trbe_enable(buf, handle);\n}\n\nstatic bool is_perf_trbe(struct perf_output_handle *handle)\n{\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\tstruct trbe_cpudata *cpudata = buf->cpudata;\n\tstruct trbe_drvdata *drvdata = cpudata->drvdata;\n\tint cpu = smp_processor_id();\n\n\tWARN_ON(buf->trbe_hw_base != get_trbe_base_pointer());\n\tWARN_ON(buf->trbe_limit != get_trbe_limit_pointer());\n\n\tif (cpudata->mode != CS_MODE_PERF)\n\t\treturn false;\n\n\tif (cpudata->cpu != cpu)\n\t\treturn false;\n\n\tif (!cpumask_test_cpu(cpu, &drvdata->supported_cpus))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic irqreturn_t arm_trbe_irq_handler(int irq, void *dev)\n{\n\tstruct perf_output_handle **handle_ptr = dev;\n\tstruct perf_output_handle *handle = *handle_ptr;\n\tstruct trbe_buf *buf = etm_perf_sink_config(handle);\n\tenum trbe_fault_action act;\n\tu64 status;\n\tbool truncated = false;\n\tu64 trfcr;\n\n\t \n\tstatus = read_sysreg_s(SYS_TRBSR_EL1);\n\t \n\tif (!is_trbe_irq(status))\n\t\treturn IRQ_NONE;\n\n\t \n\ttrfcr = cpu_prohibit_trace();\n\t \n\ttrbe_drain_and_disable_local(buf->cpudata);\n\tclr_trbe_irq();\n\tisb();\n\n\tif (WARN_ON_ONCE(!handle) || !perf_get_aux(handle))\n\t\treturn IRQ_NONE;\n\n\tif (!is_perf_trbe(handle))\n\t\treturn IRQ_NONE;\n\n\tact = trbe_get_fault_act(handle, status);\n\tswitch (act) {\n\tcase TRBE_FAULT_ACT_WRAP:\n\t\ttruncated = !!trbe_handle_overflow(handle);\n\t\tbreak;\n\tcase TRBE_FAULT_ACT_SPURIOUS:\n\t\ttrbe_handle_spurious(handle);\n\t\tbreak;\n\tcase TRBE_FAULT_ACT_FATAL:\n\t\ttrbe_stop_and_truncate_event(handle);\n\t\ttruncated = true;\n\t\tbreak;\n\t}\n\n\t \n\tif (truncated)\n\t\tirq_work_run();\n\telse\n\t\twrite_trfcr(trfcr);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct coresight_ops_sink arm_trbe_sink_ops = {\n\t.enable\t\t= arm_trbe_enable,\n\t.disable\t= arm_trbe_disable,\n\t.alloc_buffer\t= arm_trbe_alloc_buffer,\n\t.free_buffer\t= arm_trbe_free_buffer,\n\t.update_buffer\t= arm_trbe_update_buffer,\n};\n\nstatic const struct coresight_ops arm_trbe_cs_ops = {\n\t.sink_ops\t= &arm_trbe_sink_ops,\n};\n\nstatic ssize_t align_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct trbe_cpudata *cpudata = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%llx\\n\", cpudata->trbe_hw_align);\n}\nstatic DEVICE_ATTR_RO(align);\n\nstatic ssize_t flag_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct trbe_cpudata *cpudata = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", cpudata->trbe_flag);\n}\nstatic DEVICE_ATTR_RO(flag);\n\nstatic struct attribute *arm_trbe_attrs[] = {\n\t&dev_attr_align.attr,\n\t&dev_attr_flag.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group arm_trbe_group = {\n\t.attrs = arm_trbe_attrs,\n};\n\nstatic const struct attribute_group *arm_trbe_groups[] = {\n\t&arm_trbe_group,\n\tNULL,\n};\n\nstatic void arm_trbe_enable_cpu(void *info)\n{\n\tstruct trbe_drvdata *drvdata = info;\n\tstruct trbe_cpudata *cpudata = this_cpu_ptr(drvdata->cpudata);\n\n\ttrbe_reset_local(cpudata);\n\tenable_percpu_irq(drvdata->irq, IRQ_TYPE_NONE);\n}\n\nstatic void arm_trbe_disable_cpu(void *info)\n{\n\tstruct trbe_drvdata *drvdata = info;\n\tstruct trbe_cpudata *cpudata = this_cpu_ptr(drvdata->cpudata);\n\n\tdisable_percpu_irq(drvdata->irq);\n\ttrbe_reset_local(cpudata);\n}\n\n\nstatic void arm_trbe_register_coresight_cpu(struct trbe_drvdata *drvdata, int cpu)\n{\n\tstruct trbe_cpudata *cpudata = per_cpu_ptr(drvdata->cpudata, cpu);\n\tstruct coresight_device *trbe_csdev = coresight_get_percpu_sink(cpu);\n\tstruct coresight_desc desc = { 0 };\n\tstruct device *dev;\n\n\tif (WARN_ON(trbe_csdev))\n\t\treturn;\n\n\t \n\tif (WARN_ON(!cpudata->drvdata))\n\t\treturn;\n\n\tdev = &cpudata->drvdata->pdev->dev;\n\tdesc.name = devm_kasprintf(dev, GFP_KERNEL, \"trbe%d\", cpu);\n\tif (!desc.name)\n\t\tgoto cpu_clear;\n\n\tdesc.pdata = coresight_get_platform_data(dev);\n\tif (IS_ERR(desc.pdata))\n\t\tgoto cpu_clear;\n\n\tdesc.type = CORESIGHT_DEV_TYPE_SINK;\n\tdesc.subtype.sink_subtype = CORESIGHT_DEV_SUBTYPE_SINK_PERCPU_SYSMEM;\n\tdesc.ops = &arm_trbe_cs_ops;\n\tdesc.groups = arm_trbe_groups;\n\tdesc.dev = dev;\n\ttrbe_csdev = coresight_register(&desc);\n\tif (IS_ERR(trbe_csdev))\n\t\tgoto cpu_clear;\n\n\tdev_set_drvdata(&trbe_csdev->dev, cpudata);\n\tcoresight_set_percpu_sink(cpu, trbe_csdev);\n\treturn;\ncpu_clear:\n\tcpumask_clear_cpu(cpu, &drvdata->supported_cpus);\n}\n\n \nstatic void arm_trbe_probe_cpu(void *info)\n{\n\tstruct trbe_drvdata *drvdata = info;\n\tint cpu = smp_processor_id();\n\tstruct trbe_cpudata *cpudata = per_cpu_ptr(drvdata->cpudata, cpu);\n\tu64 trbidr;\n\n\tif (WARN_ON(!cpudata))\n\t\tgoto cpu_clear;\n\n\tif (!is_trbe_available()) {\n\t\tpr_err(\"TRBE is not implemented on cpu %d\\n\", cpu);\n\t\tgoto cpu_clear;\n\t}\n\n\ttrbidr = read_sysreg_s(SYS_TRBIDR_EL1);\n\tif (!is_trbe_programmable(trbidr)) {\n\t\tpr_err(\"TRBE is owned in higher exception level on cpu %d\\n\", cpu);\n\t\tgoto cpu_clear;\n\t}\n\n\tcpudata->trbe_hw_align = 1ULL << get_trbe_address_align(trbidr);\n\tif (cpudata->trbe_hw_align > SZ_2K) {\n\t\tpr_err(\"Unsupported alignment on cpu %d\\n\", cpu);\n\t\tgoto cpu_clear;\n\t}\n\n\t \n\ttrbe_check_errata(cpudata);\n\n\tif (trbe_is_broken(cpudata)) {\n\t\tpr_err(\"Disabling TRBE on cpu%d due to erratum\\n\", cpu);\n\t\tgoto cpu_clear;\n\t}\n\n\t \n\tif (trbe_may_overwrite_in_fill_mode(cpudata))\n\t\tcpudata->trbe_align = PAGE_SIZE;\n\telse\n\t\tcpudata->trbe_align = cpudata->trbe_hw_align;\n\n\tcpudata->trbe_flag = get_trbe_flag_update(trbidr);\n\tcpudata->cpu = cpu;\n\tcpudata->drvdata = drvdata;\n\treturn;\ncpu_clear:\n\tcpumask_clear_cpu(cpu, &drvdata->supported_cpus);\n}\n\nstatic void arm_trbe_remove_coresight_cpu(struct trbe_drvdata *drvdata, int cpu)\n{\n\tstruct coresight_device *trbe_csdev = coresight_get_percpu_sink(cpu);\n\n\tif (trbe_csdev) {\n\t\tcoresight_unregister(trbe_csdev);\n\t\tcoresight_set_percpu_sink(cpu, NULL);\n\t}\n}\n\nstatic int arm_trbe_probe_coresight(struct trbe_drvdata *drvdata)\n{\n\tint cpu;\n\n\tdrvdata->cpudata = alloc_percpu(typeof(*drvdata->cpudata));\n\tif (!drvdata->cpudata)\n\t\treturn -ENOMEM;\n\n\tfor_each_cpu(cpu, &drvdata->supported_cpus) {\n\t\t \n\t\tif (smp_call_function_single(cpu, arm_trbe_probe_cpu, drvdata, 1))\n\t\t\tcontinue;\n\t\tif (cpumask_test_cpu(cpu, &drvdata->supported_cpus))\n\t\t\tarm_trbe_register_coresight_cpu(drvdata, cpu);\n\t\tif (cpumask_test_cpu(cpu, &drvdata->supported_cpus))\n\t\t\tsmp_call_function_single(cpu, arm_trbe_enable_cpu, drvdata, 1);\n\t}\n\treturn 0;\n}\n\nstatic int arm_trbe_remove_coresight(struct trbe_drvdata *drvdata)\n{\n\tint cpu;\n\n\tfor_each_cpu(cpu, &drvdata->supported_cpus) {\n\t\tsmp_call_function_single(cpu, arm_trbe_disable_cpu, drvdata, 1);\n\t\tarm_trbe_remove_coresight_cpu(drvdata, cpu);\n\t}\n\tfree_percpu(drvdata->cpudata);\n\treturn 0;\n}\n\nstatic void arm_trbe_probe_hotplugged_cpu(struct trbe_drvdata *drvdata)\n{\n\tpreempt_disable();\n\tarm_trbe_probe_cpu(drvdata);\n\tpreempt_enable();\n}\n\nstatic int arm_trbe_cpu_startup(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct trbe_drvdata *drvdata = hlist_entry_safe(node, struct trbe_drvdata, hotplug_node);\n\n\tif (cpumask_test_cpu(cpu, &drvdata->supported_cpus)) {\n\n\t\t \n\t\tif (!coresight_get_percpu_sink(cpu)) {\n\t\t\tarm_trbe_probe_hotplugged_cpu(drvdata);\n\t\t\tif (cpumask_test_cpu(cpu, &drvdata->supported_cpus))\n\t\t\t\tarm_trbe_register_coresight_cpu(drvdata, cpu);\n\t\t\tif (cpumask_test_cpu(cpu, &drvdata->supported_cpus))\n\t\t\t\tarm_trbe_enable_cpu(drvdata);\n\t\t} else {\n\t\t\tarm_trbe_enable_cpu(drvdata);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int arm_trbe_cpu_teardown(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct trbe_drvdata *drvdata = hlist_entry_safe(node, struct trbe_drvdata, hotplug_node);\n\n\tif (cpumask_test_cpu(cpu, &drvdata->supported_cpus))\n\t\tarm_trbe_disable_cpu(drvdata);\n\treturn 0;\n}\n\nstatic int arm_trbe_probe_cpuhp(struct trbe_drvdata *drvdata)\n{\n\tenum cpuhp_state trbe_online;\n\tint ret;\n\n\ttrbe_online = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, DRVNAME,\n\t\t\t\t\t      arm_trbe_cpu_startup, arm_trbe_cpu_teardown);\n\tif (trbe_online < 0)\n\t\treturn trbe_online;\n\n\tret = cpuhp_state_add_instance(trbe_online, &drvdata->hotplug_node);\n\tif (ret) {\n\t\tcpuhp_remove_multi_state(trbe_online);\n\t\treturn ret;\n\t}\n\tdrvdata->trbe_online = trbe_online;\n\treturn 0;\n}\n\nstatic void arm_trbe_remove_cpuhp(struct trbe_drvdata *drvdata)\n{\n\tcpuhp_state_remove_instance(drvdata->trbe_online, &drvdata->hotplug_node);\n\tcpuhp_remove_multi_state(drvdata->trbe_online);\n}\n\nstatic int arm_trbe_probe_irq(struct platform_device *pdev,\n\t\t\t      struct trbe_drvdata *drvdata)\n{\n\tint ret;\n\n\tdrvdata->irq = platform_get_irq(pdev, 0);\n\tif (drvdata->irq < 0) {\n\t\tpr_err(\"IRQ not found for the platform device\\n\");\n\t\treturn drvdata->irq;\n\t}\n\n\tif (!irq_is_percpu(drvdata->irq)) {\n\t\tpr_err(\"IRQ is not a PPI\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (irq_get_percpu_devid_partition(drvdata->irq, &drvdata->supported_cpus))\n\t\treturn -EINVAL;\n\n\tdrvdata->handle = alloc_percpu(struct perf_output_handle *);\n\tif (!drvdata->handle)\n\t\treturn -ENOMEM;\n\n\tret = request_percpu_irq(drvdata->irq, arm_trbe_irq_handler, DRVNAME, drvdata->handle);\n\tif (ret) {\n\t\tfree_percpu(drvdata->handle);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void arm_trbe_remove_irq(struct trbe_drvdata *drvdata)\n{\n\tfree_percpu_irq(drvdata->irq, drvdata->handle);\n\tfree_percpu(drvdata->handle);\n}\n\nstatic int arm_trbe_device_probe(struct platform_device *pdev)\n{\n\tstruct trbe_drvdata *drvdata;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\t \n\tif (arm64_kernel_unmapped_at_el0()) {\n\t\tpr_err(\"TRBE wouldn't work if kernel gets unmapped at EL0\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, drvdata);\n\tdrvdata->pdev = pdev;\n\tret = arm_trbe_probe_irq(pdev, drvdata);\n\tif (ret)\n\t\treturn ret;\n\n\tret = arm_trbe_probe_coresight(drvdata);\n\tif (ret)\n\t\tgoto probe_failed;\n\n\tret = arm_trbe_probe_cpuhp(drvdata);\n\tif (ret)\n\t\tgoto cpuhp_failed;\n\n\treturn 0;\ncpuhp_failed:\n\tarm_trbe_remove_coresight(drvdata);\nprobe_failed:\n\tarm_trbe_remove_irq(drvdata);\n\treturn ret;\n}\n\nstatic int arm_trbe_device_remove(struct platform_device *pdev)\n{\n\tstruct trbe_drvdata *drvdata = platform_get_drvdata(pdev);\n\n\tarm_trbe_remove_cpuhp(drvdata);\n\tarm_trbe_remove_coresight(drvdata);\n\tarm_trbe_remove_irq(drvdata);\n\treturn 0;\n}\n\nstatic const struct of_device_id arm_trbe_of_match[] = {\n\t{ .compatible = \"arm,trace-buffer-extension\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, arm_trbe_of_match);\n\nstatic struct platform_driver arm_trbe_driver = {\n\t.driver\t= {\n\t\t.name = DRVNAME,\n\t\t.of_match_table = of_match_ptr(arm_trbe_of_match),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t= arm_trbe_device_probe,\n\t.remove\t= arm_trbe_device_remove,\n};\n\nstatic int __init arm_trbe_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&arm_trbe_driver);\n\tif (!ret)\n\t\treturn 0;\n\n\tpr_err(\"Error registering %s platform driver\\n\", DRVNAME);\n\treturn ret;\n}\n\nstatic void __exit arm_trbe_exit(void)\n{\n\tplatform_driver_unregister(&arm_trbe_driver);\n}\nmodule_init(arm_trbe_init);\nmodule_exit(arm_trbe_exit);\n\nMODULE_AUTHOR(\"Anshuman Khandual <anshuman.khandual@arm.com>\");\nMODULE_DESCRIPTION(\"Arm Trace Buffer Extension (TRBE) driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}