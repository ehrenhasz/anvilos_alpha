{
  "module_name": "coresight-tpda.c",
  "hash_id": "922de29a91d4dc4f527c182fe274be900a65bdb77427dc9eec2a4ee8570e3121",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-tpda.c",
  "human_readable_source": "\n \n\n#include <linux/amba/bus.h>\n#include <linux/bitfield.h>\n#include <linux/coresight.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include \"coresight-priv.h\"\n#include \"coresight-tpda.h\"\n#include \"coresight-trace-id.h\"\n\nDEFINE_CORESIGHT_DEVLIST(tpda_devs, \"tpda\");\n\n \nstatic void tpda_enable_pre_port(struct tpda_drvdata *drvdata)\n{\n\tu32 val;\n\n\tval = readl_relaxed(drvdata->base + TPDA_CR);\n\tval &= ~TPDA_CR_ATID;\n\tval |= FIELD_PREP(TPDA_CR_ATID, drvdata->atid);\n\twritel_relaxed(val, drvdata->base + TPDA_CR);\n}\n\nstatic void tpda_enable_port(struct tpda_drvdata *drvdata, int port)\n{\n\tu32 val;\n\n\tval = readl_relaxed(drvdata->base + TPDA_Pn_CR(port));\n\t \n\tval |= TPDA_Pn_CR_ENA;\n\twritel_relaxed(val, drvdata->base + TPDA_Pn_CR(port));\n}\n\nstatic void __tpda_enable(struct tpda_drvdata *drvdata, int port)\n{\n\tCS_UNLOCK(drvdata->base);\n\n\tif (!drvdata->csdev->enable)\n\t\ttpda_enable_pre_port(drvdata);\n\n\ttpda_enable_port(drvdata, port);\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic int tpda_enable(struct coresight_device *csdev,\n\t\t       struct coresight_connection *in,\n\t\t       struct coresight_connection *out)\n{\n\tstruct tpda_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tspin_lock(&drvdata->spinlock);\n\tif (atomic_read(&in->dest_refcnt) == 0)\n\t\t__tpda_enable(drvdata, in->dest_port);\n\n\tatomic_inc(&in->dest_refcnt);\n\tspin_unlock(&drvdata->spinlock);\n\n\tdev_dbg(drvdata->dev, \"TPDA inport %d enabled.\\n\", in->dest_port);\n\treturn 0;\n}\n\nstatic void __tpda_disable(struct tpda_drvdata *drvdata, int port)\n{\n\tu32 val;\n\n\tCS_UNLOCK(drvdata->base);\n\n\tval = readl_relaxed(drvdata->base + TPDA_Pn_CR(port));\n\tval &= ~TPDA_Pn_CR_ENA;\n\twritel_relaxed(val, drvdata->base + TPDA_Pn_CR(port));\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic void tpda_disable(struct coresight_device *csdev,\n\t\t\t struct coresight_connection *in,\n\t\t\t struct coresight_connection *out)\n{\n\tstruct tpda_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tspin_lock(&drvdata->spinlock);\n\tif (atomic_dec_return(&in->dest_refcnt) == 0)\n\t\t__tpda_disable(drvdata, in->dest_port);\n\n\tspin_unlock(&drvdata->spinlock);\n\n\tdev_dbg(drvdata->dev, \"TPDA inport %d disabled\\n\", in->dest_port);\n}\n\nstatic const struct coresight_ops_link tpda_link_ops = {\n\t.enable\t\t= tpda_enable,\n\t.disable\t= tpda_disable,\n};\n\nstatic const struct coresight_ops tpda_cs_ops = {\n\t.link_ops\t= &tpda_link_ops,\n};\n\nstatic int tpda_init_default_data(struct tpda_drvdata *drvdata)\n{\n\tint atid;\n\t \n\tatid = coresight_trace_id_get_system_id();\n\tif (atid < 0)\n\t\treturn atid;\n\n\tdrvdata->atid = atid;\n\treturn 0;\n}\n\nstatic int tpda_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tint ret;\n\tstruct device *dev = &adev->dev;\n\tstruct coresight_platform_data *pdata;\n\tstruct tpda_drvdata *drvdata;\n\tstruct coresight_desc desc = { 0 };\n\tvoid __iomem *base;\n\n\tpdata = coresight_get_platform_data(dev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\tadev->dev.platform_data = pdata;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->dev = &adev->dev;\n\tdev_set_drvdata(dev, drvdata);\n\n\tbase = devm_ioremap_resource(dev, &adev->res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\tdrvdata->base = base;\n\n\tspin_lock_init(&drvdata->spinlock);\n\n\tret = tpda_init_default_data(drvdata);\n\tif (ret)\n\t\treturn ret;\n\n\tdesc.name = coresight_alloc_device_name(&tpda_devs, dev);\n\tif (!desc.name)\n\t\treturn -ENOMEM;\n\tdesc.type = CORESIGHT_DEV_TYPE_LINK;\n\tdesc.subtype.link_subtype = CORESIGHT_DEV_SUBTYPE_LINK_MERG;\n\tdesc.ops = &tpda_cs_ops;\n\tdesc.pdata = adev->dev.platform_data;\n\tdesc.dev = &adev->dev;\n\tdesc.access = CSDEV_ACCESS_IOMEM(base);\n\tdrvdata->csdev = coresight_register(&desc);\n\tif (IS_ERR(drvdata->csdev))\n\t\treturn PTR_ERR(drvdata->csdev);\n\n\tpm_runtime_put(&adev->dev);\n\n\tdev_dbg(drvdata->dev, \"TPDA initialized\\n\");\n\treturn 0;\n}\n\nstatic void tpda_remove(struct amba_device *adev)\n{\n\tstruct tpda_drvdata *drvdata = dev_get_drvdata(&adev->dev);\n\n\tcoresight_trace_id_put_system_id(drvdata->atid);\n\tcoresight_unregister(drvdata->csdev);\n}\n\n \nstatic struct amba_id tpda_ids[] = {\n\t{\n\t\t.id     = 0x000f0f00,\n\t\t.mask   = 0x000fff00,\n\t},\n\t{ 0, 0},\n};\n\nstatic struct amba_driver tpda_driver = {\n\t.drv = {\n\t\t.name   = \"coresight-tpda\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe          = tpda_probe,\n\t.remove\t\t= tpda_remove,\n\t.id_table\t= tpda_ids,\n};\n\nmodule_amba_driver(tpda_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Trace, Profiling & Diagnostic Aggregator driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}