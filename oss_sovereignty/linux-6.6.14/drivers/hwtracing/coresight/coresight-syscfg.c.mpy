{
  "module_name": "coresight-syscfg.c",
  "hash_id": "b140fc024cae3c1ae0c42467f0d590af2233bcb43332f37c8192eb2665f478f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-syscfg.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"coresight-config.h\"\n#include \"coresight-etm-perf.h\"\n#include \"coresight-syscfg.h\"\n#include \"coresight-syscfg-configfs.h\"\n\n \n\n \nstatic DEFINE_MUTEX(cscfg_mutex);\n\n \nstatic struct cscfg_manager *cscfg_mgr;\n\n \n\n \nstatic struct cscfg_feature_csdev *\ncscfg_get_feat_csdev(struct coresight_device *csdev, const char *name)\n{\n\tstruct cscfg_feature_csdev *feat_csdev = NULL;\n\n\tlist_for_each_entry(feat_csdev, &csdev->feature_csdev_list, node) {\n\t\tif (strcmp(feat_csdev->feat_desc->name, name) == 0)\n\t\t\treturn feat_csdev;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct cscfg_config_csdev *\ncscfg_alloc_csdev_cfg(struct coresight_device *csdev, int nr_feats)\n{\n\tstruct cscfg_config_csdev *config_csdev = NULL;\n\tstruct device *dev = csdev->dev.parent;\n\n\t \n\tconfig_csdev = devm_kzalloc(dev,\n\t\t\t\t    offsetof(struct cscfg_config_csdev, feats_csdev[nr_feats]),\n\t\t\t\t    GFP_KERNEL);\n\tif (!config_csdev)\n\t\treturn NULL;\n\n\tconfig_csdev->csdev = csdev;\n\treturn config_csdev;\n}\n\n \nstatic int cscfg_add_csdev_cfg(struct coresight_device *csdev,\n\t\t\t       struct cscfg_config_desc *config_desc)\n{\n\tstruct cscfg_config_csdev *config_csdev = NULL;\n\tstruct cscfg_feature_csdev *feat_csdev;\n\tunsigned long flags;\n\tint i;\n\n\t \n\tfor (i = 0; i < config_desc->nr_feat_refs; i++) {\n\t\t \n\t\tfeat_csdev = cscfg_get_feat_csdev(csdev, config_desc->feat_ref_names[i]);\n\t\tif (feat_csdev) {\n\t\t\t \n\t\t\tif (!config_csdev) {\n\t\t\t\tconfig_csdev = cscfg_alloc_csdev_cfg(csdev,\n\t\t\t\t\t\t\t\t     config_desc->nr_feat_refs);\n\t\t\t\tif (!config_csdev)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tconfig_csdev->config_desc = config_desc;\n\t\t\t}\n\t\t\tconfig_csdev->feats_csdev[config_csdev->nr_feat++] = feat_csdev;\n\t\t}\n\t}\n\t \n\tif (config_csdev) {\n\t\tspin_lock_irqsave(&csdev->cscfg_csdev_lock, flags);\n\t\tlist_add(&config_csdev->node, &csdev->config_csdev_list);\n\t\tspin_unlock_irqrestore(&csdev->cscfg_csdev_lock, flags);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cscfg_add_cfg_to_csdevs(struct cscfg_config_desc *config_desc)\n{\n\tstruct cscfg_registered_csdev *csdev_item;\n\tint err;\n\n\tlist_for_each_entry(csdev_item, &cscfg_mgr->csdev_desc_list, item) {\n\t\terr = cscfg_add_csdev_cfg(csdev_item->csdev, config_desc);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic struct cscfg_feature_csdev *\ncscfg_alloc_csdev_feat(struct coresight_device *csdev, struct cscfg_feature_desc *feat_desc)\n{\n\tstruct cscfg_feature_csdev *feat_csdev = NULL;\n\tstruct device *dev = csdev->dev.parent;\n\tint i;\n\n\tfeat_csdev = devm_kzalloc(dev, sizeof(struct cscfg_feature_csdev), GFP_KERNEL);\n\tif (!feat_csdev)\n\t\treturn NULL;\n\n\t \n\tfeat_csdev->nr_params = feat_desc->nr_params;\n\n\t \n\tif (feat_csdev->nr_params) {\n\t\tfeat_csdev->params_csdev = devm_kcalloc(dev, feat_csdev->nr_params,\n\t\t\t\t\t\t\tsizeof(struct cscfg_parameter_csdev),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!feat_csdev->params_csdev)\n\t\t\treturn NULL;\n\n\t\t \n\t\tfor (i = 0; i < feat_csdev->nr_params; i++)\n\t\t\tfeat_csdev->params_csdev[i].feat_csdev = feat_csdev;\n\t}\n\n\t \n\tfeat_csdev->nr_regs = feat_desc->nr_regs;\n\tfeat_csdev->regs_csdev = devm_kcalloc(dev, feat_csdev->nr_regs,\n\t\t\t\t\t      sizeof(struct cscfg_regval_csdev),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!feat_csdev->regs_csdev)\n\t\treturn NULL;\n\n\t \n\tfeat_csdev->feat_desc = feat_desc;\n\tfeat_csdev->csdev = csdev;\n\n\treturn feat_csdev;\n}\n\n \nstatic int cscfg_load_feat_csdev(struct coresight_device *csdev,\n\t\t\t\t struct cscfg_feature_desc *feat_desc,\n\t\t\t\t struct cscfg_csdev_feat_ops *ops)\n{\n\tstruct cscfg_feature_csdev *feat_csdev;\n\tunsigned long flags;\n\tint err;\n\n\tif (!ops->load_feat)\n\t\treturn -EINVAL;\n\n\tfeat_csdev = cscfg_alloc_csdev_feat(csdev, feat_desc);\n\tif (!feat_csdev)\n\t\treturn -ENOMEM;\n\n\t \n\terr = ops->load_feat(csdev, feat_csdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tcscfg_reset_feat(feat_csdev);\n\tspin_lock_irqsave(&csdev->cscfg_csdev_lock, flags);\n\tlist_add(&feat_csdev->node, &csdev->feature_csdev_list);\n\tspin_unlock_irqrestore(&csdev->cscfg_csdev_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int cscfg_add_feat_to_csdevs(struct cscfg_feature_desc *feat_desc)\n{\n\tstruct cscfg_registered_csdev *csdev_item;\n\tint err;\n\n\tlist_for_each_entry(csdev_item, &cscfg_mgr->csdev_desc_list, item) {\n\t\tif (csdev_item->match_flags & feat_desc->match_flags) {\n\t\t\terr = cscfg_load_feat_csdev(csdev_item->csdev, feat_desc, &csdev_item->ops);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic bool cscfg_match_list_feat(const char *name)\n{\n\tstruct cscfg_feature_desc *feat_desc;\n\n\tlist_for_each_entry(feat_desc, &cscfg_mgr->feat_desc_list, item) {\n\t\tif (strcmp(feat_desc->name, name) == 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic int cscfg_check_feat_for_cfg(struct cscfg_config_desc *config_desc)\n{\n\tint i;\n\n\tfor (i = 0; i < config_desc->nr_feat_refs; i++)\n\t\tif (!cscfg_match_list_feat(config_desc->feat_ref_names[i]))\n\t\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int cscfg_load_feat(struct cscfg_feature_desc *feat_desc)\n{\n\tint err;\n\tstruct cscfg_feature_desc *feat_desc_exist;\n\n\t \n\tlist_for_each_entry(feat_desc_exist, &cscfg_mgr->feat_desc_list, item) {\n\t\tif (!strcmp(feat_desc_exist->name, feat_desc->name))\n\t\t\treturn -EEXIST;\n\t}\n\n\t \n\terr = cscfg_add_feat_to_csdevs(feat_desc);\n\tif (err)\n\t\treturn err;\n\n\tlist_add(&feat_desc->item, &cscfg_mgr->feat_desc_list);\n\treturn 0;\n}\n\n \nstatic int cscfg_load_config(struct cscfg_config_desc *config_desc)\n{\n\tint err;\n\tstruct cscfg_config_desc *config_desc_exist;\n\n\t \n\tlist_for_each_entry(config_desc_exist, &cscfg_mgr->config_desc_list, item) {\n\t\tif (!strcmp(config_desc_exist->name, config_desc->name))\n\t\t\treturn -EEXIST;\n\t}\n\n\t \n\terr = cscfg_check_feat_for_cfg(config_desc);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = cscfg_add_cfg_to_csdevs(config_desc);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = etm_perf_add_symlink_cscfg(cscfg_device(), config_desc);\n\tif (err)\n\t\treturn err;\n\n\tlist_add(&config_desc->item, &cscfg_mgr->config_desc_list);\n\tatomic_set(&config_desc->active_cnt, 0);\n\treturn 0;\n}\n\n \nconst struct cscfg_feature_desc *cscfg_get_named_feat_desc(const char *name)\n{\n\tconst struct cscfg_feature_desc *feat_desc = NULL, *feat_desc_item;\n\n\tmutex_lock(&cscfg_mutex);\n\n\tlist_for_each_entry(feat_desc_item, &cscfg_mgr->feat_desc_list, item) {\n\t\tif (strcmp(feat_desc_item->name, name) == 0) {\n\t\t\tfeat_desc = feat_desc_item;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&cscfg_mutex);\n\treturn feat_desc;\n}\n\n \nstatic struct cscfg_feature_csdev *\ncscfg_csdev_get_feat_from_desc(struct coresight_device *csdev,\n\t\t\t       struct cscfg_feature_desc *feat_desc)\n{\n\tstruct cscfg_feature_csdev *feat_csdev;\n\n\tlist_for_each_entry(feat_csdev, &csdev->feature_csdev_list, node) {\n\t\tif (feat_csdev->feat_desc == feat_desc)\n\t\t\treturn feat_csdev;\n\t}\n\treturn NULL;\n}\n\nint cscfg_update_feat_param_val(struct cscfg_feature_desc *feat_desc,\n\t\t\t\tint param_idx, u64 value)\n{\n\tint err = 0;\n\tstruct cscfg_feature_csdev *feat_csdev;\n\tstruct cscfg_registered_csdev *csdev_item;\n\n\tmutex_lock(&cscfg_mutex);\n\n\t \n\tif (atomic_read(&cscfg_mgr->sys_active_cnt)) {\n\t\terr = -EBUSY;\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tif ((param_idx < 0) || (param_idx >= feat_desc->nr_params)) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_exit;\n\t}\n\tfeat_desc->params_desc[param_idx].value = value;\n\n\t \n\tlist_for_each_entry(csdev_item, &cscfg_mgr->csdev_desc_list, item) {\n\t\tfeat_csdev = cscfg_csdev_get_feat_from_desc(csdev_item->csdev, feat_desc);\n\t\tif (feat_csdev)\n\t\t\tfeat_csdev->params_csdev[param_idx].current_value = value;\n\t}\n\nunlock_exit:\n\tmutex_unlock(&cscfg_mutex);\n\treturn err;\n}\n\n \nstatic int cscfg_owner_get(struct cscfg_load_owner_info *owner_info)\n{\n\tif ((owner_info->type == CSCFG_OWNER_MODULE) &&\n\t    (!try_module_get(owner_info->owner_handle)))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic void cscfg_owner_put(struct cscfg_load_owner_info *owner_info)\n{\n\tif (owner_info->type == CSCFG_OWNER_MODULE)\n\t\tmodule_put(owner_info->owner_handle);\n}\n\nstatic void cscfg_remove_owned_csdev_configs(struct coresight_device *csdev, void *load_owner)\n{\n\tstruct cscfg_config_csdev *config_csdev, *tmp;\n\n\tif (list_empty(&csdev->config_csdev_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(config_csdev, tmp, &csdev->config_csdev_list, node) {\n\t\tif (config_csdev->config_desc->load_owner == load_owner)\n\t\t\tlist_del(&config_csdev->node);\n\t}\n}\n\nstatic void cscfg_remove_owned_csdev_features(struct coresight_device *csdev, void *load_owner)\n{\n\tstruct cscfg_feature_csdev *feat_csdev, *tmp;\n\n\tif (list_empty(&csdev->feature_csdev_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(feat_csdev, tmp, &csdev->feature_csdev_list, node) {\n\t\tif (feat_csdev->feat_desc->load_owner == load_owner)\n\t\t\tlist_del(&feat_csdev->node);\n\t}\n}\n\n \nstatic void cscfg_fs_unregister_cfgs_feats(void *load_owner)\n{\n\tstruct cscfg_config_desc *config_desc;\n\tstruct cscfg_feature_desc *feat_desc;\n\n\tlist_for_each_entry(config_desc, &cscfg_mgr->config_desc_list, item) {\n\t\tif (config_desc->load_owner == load_owner)\n\t\t\tcscfg_configfs_del_config(config_desc);\n\t}\n\tlist_for_each_entry(feat_desc, &cscfg_mgr->feat_desc_list, item) {\n\t\tif (feat_desc->load_owner == load_owner)\n\t\t\tcscfg_configfs_del_feature(feat_desc);\n\t}\n}\n\n \nstatic void cscfg_unload_owned_cfgs_feats(void *load_owner)\n{\n\tstruct cscfg_config_desc *config_desc, *cfg_tmp;\n\tstruct cscfg_feature_desc *feat_desc, *feat_tmp;\n\tstruct cscfg_registered_csdev *csdev_item;\n\n\tlockdep_assert_held(&cscfg_mutex);\n\n\t \n\tlist_for_each_entry(csdev_item, &cscfg_mgr->csdev_desc_list, item) {\n\t\t \n\t\tcscfg_remove_owned_csdev_configs(csdev_item->csdev, load_owner);\n\t\tcscfg_remove_owned_csdev_features(csdev_item->csdev, load_owner);\n\t}\n\n\t \n\tlist_for_each_entry_safe(config_desc, cfg_tmp, &cscfg_mgr->config_desc_list, item) {\n\t\tif (config_desc->load_owner == load_owner) {\n\t\t\tetm_perf_del_symlink_cscfg(config_desc);\n\t\t\tlist_del(&config_desc->item);\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_safe(feat_desc, feat_tmp, &cscfg_mgr->feat_desc_list, item) {\n\t\tif (feat_desc->load_owner == load_owner) {\n\t\t\tlist_del(&feat_desc->item);\n\t\t}\n\t}\n}\n\n \nstatic int cscfg_load_owned_cfgs_feats(struct cscfg_config_desc **config_descs,\n\t\t\t\t       struct cscfg_feature_desc **feat_descs,\n\t\t\t\t       struct cscfg_load_owner_info *owner_info)\n{\n\tint i, err;\n\n\tlockdep_assert_held(&cscfg_mutex);\n\n\t \n\tif (feat_descs) {\n\t\tfor (i = 0; feat_descs[i]; i++) {\n\t\t\terr = cscfg_load_feat(feat_descs[i]);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"coresight-syscfg: Failed to load feature %s\\n\",\n\t\t\t\t       feat_descs[i]->name);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tfeat_descs[i]->load_owner = owner_info;\n\t\t}\n\t}\n\n\t \n\tif (config_descs) {\n\t\tfor (i = 0; config_descs[i]; i++) {\n\t\t\terr = cscfg_load_config(config_descs[i]);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"coresight-syscfg: Failed to load configuration %s\\n\",\n\t\t\t\t       config_descs[i]->name);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tconfig_descs[i]->load_owner = owner_info;\n\t\t\tconfig_descs[i]->available = false;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void cscfg_set_configs_available(struct cscfg_config_desc **config_descs)\n{\n\tint i;\n\n\tlockdep_assert_held(&cscfg_mutex);\n\n\tif (config_descs) {\n\t\tfor (i = 0; config_descs[i]; i++)\n\t\t\tconfig_descs[i]->available = true;\n\t}\n}\n\n \nstatic int cscfg_fs_register_cfgs_feats(struct cscfg_config_desc **config_descs,\n\t\t\t\t\tstruct cscfg_feature_desc **feat_descs)\n{\n\tint i, err;\n\n\tif (feat_descs) {\n\t\tfor (i = 0; feat_descs[i]; i++) {\n\t\t\terr = cscfg_configfs_add_feature(feat_descs[i]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tif (config_descs) {\n\t\tfor (i = 0; config_descs[i]; i++) {\n\t\t\terr = cscfg_configfs_add_config(config_descs[i]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint cscfg_load_config_sets(struct cscfg_config_desc **config_descs,\n\t\t\t   struct cscfg_feature_desc **feat_descs,\n\t\t\t   struct cscfg_load_owner_info *owner_info)\n{\n\tint err = 0;\n\n\tmutex_lock(&cscfg_mutex);\n\tif (cscfg_mgr->load_state != CSCFG_NONE) {\n\t\tmutex_unlock(&cscfg_mutex);\n\t\treturn -EBUSY;\n\t}\n\tcscfg_mgr->load_state = CSCFG_LOAD;\n\n\t \n\terr = cscfg_load_owned_cfgs_feats(config_descs, feat_descs, owner_info);\n\tif (err)\n\t\tgoto err_clean_load;\n\n\t \n\tlist_add_tail(&owner_info->item, &cscfg_mgr->load_order_list);\n\tif (!list_is_singular(&cscfg_mgr->load_order_list)) {\n\t\t \n\t\terr = cscfg_owner_get(list_prev_entry(owner_info, item));\n\t\tif (err)\n\t\t\tgoto err_clean_owner_list;\n\t}\n\n\t \n\tmutex_unlock(&cscfg_mutex);\n\n\t \n\terr = cscfg_fs_register_cfgs_feats(config_descs, feat_descs);\n\tmutex_lock(&cscfg_mutex);\n\n\tif (err)\n\t\tgoto err_clean_cfs;\n\n\t \n\tcscfg_set_configs_available(config_descs);\n\tgoto exit_unlock;\n\nerr_clean_cfs:\n\t \n\tcscfg_fs_unregister_cfgs_feats(owner_info);\n\n\tif (!list_is_singular(&cscfg_mgr->load_order_list))\n\t\tcscfg_owner_put(list_prev_entry(owner_info, item));\n\nerr_clean_owner_list:\n\tlist_del(&owner_info->item);\n\nerr_clean_load:\n\tcscfg_unload_owned_cfgs_feats(owner_info);\n\nexit_unlock:\n\tcscfg_mgr->load_state = CSCFG_NONE;\n\tmutex_unlock(&cscfg_mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cscfg_load_config_sets);\n\n \nint cscfg_unload_config_sets(struct cscfg_load_owner_info *owner_info)\n{\n\tint err = 0;\n\tstruct cscfg_load_owner_info *load_list_item = NULL;\n\n\tmutex_lock(&cscfg_mutex);\n\tif (cscfg_mgr->load_state != CSCFG_NONE) {\n\t\tmutex_unlock(&cscfg_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tcscfg_mgr->load_state = CSCFG_UNLOAD;\n\n\t \n\tif (atomic_read(&cscfg_mgr->sys_active_cnt)) {\n\t\terr = -EBUSY;\n\t\tgoto exit_unlock;\n\t}\n\n\t \n\tif (!list_empty(&cscfg_mgr->load_order_list)) {\n\t\tload_list_item = list_last_entry(&cscfg_mgr->load_order_list,\n\t\t\t\t\t\t struct cscfg_load_owner_info, item);\n\t\tif (load_list_item != owner_info)\n\t\t\tload_list_item = NULL;\n\t}\n\n\tif (!load_list_item) {\n\t\terr = -EINVAL;\n\t\tgoto exit_unlock;\n\t}\n\n\t \n\tmutex_unlock(&cscfg_mutex);\n\tcscfg_fs_unregister_cfgs_feats(owner_info);\n\tmutex_lock(&cscfg_mutex);\n\n\t \n\tcscfg_unload_owned_cfgs_feats(owner_info);\n\n\t \n\tif (!list_is_singular(&cscfg_mgr->load_order_list)) {\n\t\t \n\t\tcscfg_owner_put(list_prev_entry(owner_info, item));\n\t}\n\tlist_del(&owner_info->item);\n\nexit_unlock:\n\tcscfg_mgr->load_state = CSCFG_NONE;\n\tmutex_unlock(&cscfg_mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cscfg_unload_config_sets);\n\n \n\n \nstatic int cscfg_add_cfgs_csdev(struct coresight_device *csdev)\n{\n\tstruct cscfg_config_desc *config_desc;\n\tint err = 0;\n\n\tlist_for_each_entry(config_desc, &cscfg_mgr->config_desc_list, item) {\n\t\terr = cscfg_add_csdev_cfg(csdev, config_desc);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n \nstatic int cscfg_add_feats_csdev(struct coresight_device *csdev,\n\t\t\t\t u32 match_flags,\n\t\t\t\t struct cscfg_csdev_feat_ops *ops)\n{\n\tstruct cscfg_feature_desc *feat_desc;\n\tint err = 0;\n\n\tif (!ops->load_feat)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(feat_desc, &cscfg_mgr->feat_desc_list, item) {\n\t\tif (feat_desc->match_flags & match_flags) {\n\t\t\terr = cscfg_load_feat_csdev(csdev, feat_desc, ops);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\n \nstatic int cscfg_list_add_csdev(struct coresight_device *csdev,\n\t\t\t\tu32 match_flags,\n\t\t\t\tstruct cscfg_csdev_feat_ops *ops)\n{\n\tstruct cscfg_registered_csdev *csdev_item;\n\n\t \n\tcsdev_item = kzalloc(sizeof(struct cscfg_registered_csdev), GFP_KERNEL);\n\tif (!csdev_item)\n\t\treturn -ENOMEM;\n\n\tcsdev_item->csdev = csdev;\n\tcsdev_item->match_flags = match_flags;\n\tcsdev_item->ops.load_feat = ops->load_feat;\n\tlist_add(&csdev_item->item, &cscfg_mgr->csdev_desc_list);\n\n\tINIT_LIST_HEAD(&csdev->feature_csdev_list);\n\tINIT_LIST_HEAD(&csdev->config_csdev_list);\n\tspin_lock_init(&csdev->cscfg_csdev_lock);\n\n\treturn 0;\n}\n\n \nstatic void cscfg_list_remove_csdev(struct coresight_device *csdev)\n{\n\tstruct cscfg_registered_csdev *csdev_item, *tmp;\n\n\tlist_for_each_entry_safe(csdev_item, tmp, &cscfg_mgr->csdev_desc_list, item) {\n\t\tif (csdev_item->csdev == csdev) {\n\t\t\tlist_del(&csdev_item->item);\n\t\t\tkfree(csdev_item);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nint cscfg_register_csdev(struct coresight_device *csdev,\n\t\t\t u32 match_flags,\n\t\t\t struct cscfg_csdev_feat_ops *ops)\n{\n\tint ret = 0;\n\n\tmutex_lock(&cscfg_mutex);\n\n\t \n\tret = cscfg_list_add_csdev(csdev, match_flags, ops);\n\tif (ret)\n\t\tgoto reg_csdev_unlock;\n\n\t \n\tret = cscfg_add_feats_csdev(csdev, match_flags, ops);\n\tif (ret) {\n\t\tcscfg_list_remove_csdev(csdev);\n\t\tgoto reg_csdev_unlock;\n\t}\n\n\tret = cscfg_add_cfgs_csdev(csdev);\n\tif (ret) {\n\t\tcscfg_list_remove_csdev(csdev);\n\t\tgoto reg_csdev_unlock;\n\t}\n\n\tpr_info(\"CSCFG registered %s\", dev_name(&csdev->dev));\n\nreg_csdev_unlock:\n\tmutex_unlock(&cscfg_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cscfg_register_csdev);\n\n \nvoid cscfg_unregister_csdev(struct coresight_device *csdev)\n{\n\tmutex_lock(&cscfg_mutex);\n\tcscfg_list_remove_csdev(csdev);\n\tmutex_unlock(&cscfg_mutex);\n}\nEXPORT_SYMBOL_GPL(cscfg_unregister_csdev);\n\n \nvoid cscfg_csdev_reset_feats(struct coresight_device *csdev)\n{\n\tstruct cscfg_feature_csdev *feat_csdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&csdev->cscfg_csdev_lock, flags);\n\tif (list_empty(&csdev->feature_csdev_list))\n\t\tgoto unlock_exit;\n\n\tlist_for_each_entry(feat_csdev, &csdev->feature_csdev_list, node)\n\t\tcscfg_reset_feat(feat_csdev);\n\nunlock_exit:\n\tspin_unlock_irqrestore(&csdev->cscfg_csdev_lock, flags);\n}\nEXPORT_SYMBOL_GPL(cscfg_csdev_reset_feats);\n\n \nstatic int _cscfg_activate_config(unsigned long cfg_hash)\n{\n\tstruct cscfg_config_desc *config_desc;\n\tint err = -EINVAL;\n\n\tif (cscfg_mgr->load_state == CSCFG_UNLOAD)\n\t\treturn -EBUSY;\n\n\tlist_for_each_entry(config_desc, &cscfg_mgr->config_desc_list, item) {\n\t\tif ((unsigned long)config_desc->event_ea->var == cfg_hash) {\n\t\t\t \n\t\t\tif (config_desc->available == false)\n\t\t\t\treturn -EBUSY;\n\n\t\t\t \n\t\t\terr = cscfg_owner_get(config_desc->load_owner);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tatomic_inc(&cscfg_mgr->sys_active_cnt);\n\n\t\t\t \n\t\t\tatomic_inc(&config_desc->active_cnt);\n\n\t\t\terr = 0;\n\t\t\tdev_dbg(cscfg_device(), \"Activate config %s.\\n\", config_desc->name);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic void _cscfg_deactivate_config(unsigned long cfg_hash)\n{\n\tstruct cscfg_config_desc *config_desc;\n\n\tlist_for_each_entry(config_desc, &cscfg_mgr->config_desc_list, item) {\n\t\tif ((unsigned long)config_desc->event_ea->var == cfg_hash) {\n\t\t\tatomic_dec(&config_desc->active_cnt);\n\t\t\tatomic_dec(&cscfg_mgr->sys_active_cnt);\n\t\t\tcscfg_owner_put(config_desc->load_owner);\n\t\t\tdev_dbg(cscfg_device(), \"Deactivate config %s.\\n\", config_desc->name);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nint cscfg_config_sysfs_activate(struct cscfg_config_desc *config_desc, bool activate)\n{\n\tunsigned long cfg_hash;\n\tint err = 0;\n\n\tmutex_lock(&cscfg_mutex);\n\n\tcfg_hash = (unsigned long)config_desc->event_ea->var;\n\n\tif (activate) {\n\t\t \n\t\tif (cscfg_mgr->sysfs_active_config) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto exit_unlock;\n\t\t}\n\t\terr = _cscfg_activate_config(cfg_hash);\n\t\tif (!err)\n\t\t\tcscfg_mgr->sysfs_active_config = cfg_hash;\n\t} else {\n\t\t \n\t\tif (cscfg_mgr->sysfs_active_config == cfg_hash) {\n\t\t\t_cscfg_deactivate_config(cfg_hash);\n\t\t\tcscfg_mgr->sysfs_active_config = 0;\n\t\t} else\n\t\t\terr = -EINVAL;\n\t}\n\nexit_unlock:\n\tmutex_unlock(&cscfg_mutex);\n\treturn err;\n}\n\n \nvoid cscfg_config_sysfs_set_preset(int preset)\n{\n\tmutex_lock(&cscfg_mutex);\n\tcscfg_mgr->sysfs_active_preset = preset;\n\tmutex_unlock(&cscfg_mutex);\n}\n\n \nvoid cscfg_config_sysfs_get_active_cfg(unsigned long *cfg_hash, int *preset)\n{\n\tmutex_lock(&cscfg_mutex);\n\t*preset = cscfg_mgr->sysfs_active_preset;\n\t*cfg_hash = cscfg_mgr->sysfs_active_config;\n\tmutex_unlock(&cscfg_mutex);\n}\nEXPORT_SYMBOL_GPL(cscfg_config_sysfs_get_active_cfg);\n\n \nint cscfg_activate_config(unsigned long cfg_hash)\n{\n\tint err = 0;\n\n\tmutex_lock(&cscfg_mutex);\n\terr = _cscfg_activate_config(cfg_hash);\n\tmutex_unlock(&cscfg_mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cscfg_activate_config);\n\n \nvoid cscfg_deactivate_config(unsigned long cfg_hash)\n{\n\tmutex_lock(&cscfg_mutex);\n\t_cscfg_deactivate_config(cfg_hash);\n\tmutex_unlock(&cscfg_mutex);\n}\nEXPORT_SYMBOL_GPL(cscfg_deactivate_config);\n\n \nint cscfg_csdev_enable_active_config(struct coresight_device *csdev,\n\t\t\t\t     unsigned long cfg_hash, int preset)\n{\n\tstruct cscfg_config_csdev *config_csdev_active = NULL, *config_csdev_item;\n\tconst struct cscfg_config_desc *config_desc;\n\tunsigned long flags;\n\tint err = 0;\n\n\t \n\tif (!atomic_read(&cscfg_mgr->sys_active_cnt))\n\t\treturn 0;\n\n\t \n\tspin_lock_irqsave(&csdev->cscfg_csdev_lock, flags);\n\tlist_for_each_entry(config_csdev_item, &csdev->config_csdev_list, node) {\n\t\tconfig_desc = config_csdev_item->config_desc;\n\t\tif ((atomic_read(&config_desc->active_cnt)) &&\n\t\t    ((unsigned long)config_desc->event_ea->var == cfg_hash)) {\n\t\t\tconfig_csdev_active = config_csdev_item;\n\t\t\tcsdev->active_cscfg_ctxt = (void *)config_csdev_active;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&csdev->cscfg_csdev_lock, flags);\n\n\t \n\tif (config_csdev_active) {\n\t\t \n\t\terr = cscfg_csdev_enable_config(config_csdev_active, preset);\n\t\tif (!err) {\n\t\t\t \n\t\t\tspin_lock_irqsave(&csdev->cscfg_csdev_lock, flags);\n\t\t\tif (csdev->active_cscfg_ctxt)\n\t\t\t\tconfig_csdev_active->enabled = true;\n\t\t\telse\n\t\t\t\terr = -EBUSY;\n\t\t\tspin_unlock_irqrestore(&csdev->cscfg_csdev_lock, flags);\n\t\t}\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cscfg_csdev_enable_active_config);\n\n \nvoid cscfg_csdev_disable_active_config(struct coresight_device *csdev)\n{\n\tstruct cscfg_config_csdev *config_csdev;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&csdev->cscfg_csdev_lock, flags);\n\tconfig_csdev = (struct cscfg_config_csdev *)csdev->active_cscfg_ctxt;\n\tif (config_csdev) {\n\t\tif (!config_csdev->enabled)\n\t\t\tconfig_csdev = NULL;\n\t\telse\n\t\t\tconfig_csdev->enabled = false;\n\t}\n\tcsdev->active_cscfg_ctxt = NULL;\n\tspin_unlock_irqrestore(&csdev->cscfg_csdev_lock, flags);\n\n\t \n\tif (config_csdev)\n\t\tcscfg_csdev_disable_config(config_csdev);\n}\nEXPORT_SYMBOL_GPL(cscfg_csdev_disable_active_config);\n\n \n\nstruct device *cscfg_device(void)\n{\n\treturn cscfg_mgr ? &cscfg_mgr->dev : NULL;\n}\n\n \nstatic void cscfg_dev_release(struct device *dev)\n{\n\tmutex_lock(&cscfg_mutex);\n\tkfree(cscfg_mgr);\n\tcscfg_mgr = NULL;\n\tmutex_unlock(&cscfg_mutex);\n}\n\n \nstatic int cscfg_create_device(void)\n{\n\tstruct device *dev;\n\tint err = -ENOMEM;\n\n\tmutex_lock(&cscfg_mutex);\n\tif (cscfg_mgr) {\n\t\terr = -EINVAL;\n\t\tgoto create_dev_exit_unlock;\n\t}\n\n\tcscfg_mgr = kzalloc(sizeof(struct cscfg_manager), GFP_KERNEL);\n\tif (!cscfg_mgr)\n\t\tgoto create_dev_exit_unlock;\n\n\t \n\tINIT_LIST_HEAD(&cscfg_mgr->csdev_desc_list);\n\tINIT_LIST_HEAD(&cscfg_mgr->feat_desc_list);\n\tINIT_LIST_HEAD(&cscfg_mgr->config_desc_list);\n\tINIT_LIST_HEAD(&cscfg_mgr->load_order_list);\n\tatomic_set(&cscfg_mgr->sys_active_cnt, 0);\n\tcscfg_mgr->load_state = CSCFG_NONE;\n\n\t \n\tdev = cscfg_device();\n\tdev->release = cscfg_dev_release;\n\tdev->init_name = \"cs_system_cfg\";\n\n\terr = device_register(dev);\n\tif (err)\n\t\tput_device(dev);\n\ncreate_dev_exit_unlock:\n\tmutex_unlock(&cscfg_mutex);\n\treturn err;\n}\n\n \nstatic void cscfg_unload_cfgs_on_exit(void)\n{\n\tstruct cscfg_load_owner_info *owner_info = NULL;\n\n\t \n\tmutex_lock(&cscfg_mutex);\n\twhile (!list_empty(&cscfg_mgr->load_order_list)) {\n\n\t\t \n\t\towner_info = list_last_entry(&cscfg_mgr->load_order_list,\n\t\t\t\t\t     struct cscfg_load_owner_info, item);\n\n\t\t \n\t\tswitch (owner_info->type) {\n\t\tcase CSCFG_OWNER_PRELOAD:\n\t\t\t \n\t\t\tpr_info(\"cscfg: unloading preloaded configurations\\n\");\n\t\t\tbreak;\n\n\t\tcase  CSCFG_OWNER_MODULE:\n\t\t\t \n\t\t\tpr_err(\"cscfg: ERROR: prior module failed to unload configuration\\n\");\n\t\t\tgoto list_remove;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&cscfg_mutex);\n\t\tcscfg_fs_unregister_cfgs_feats(owner_info);\n\t\tmutex_lock(&cscfg_mutex);\n\n\t\t \n\t\tcscfg_unload_owned_cfgs_feats(owner_info);\n\nlist_remove:\n\t\t \n\t\tlist_del(&owner_info->item);\n\t}\n\tmutex_unlock(&cscfg_mutex);\n}\n\nstatic void cscfg_clear_device(void)\n{\n\tcscfg_unload_cfgs_on_exit();\n\tcscfg_configfs_release(cscfg_mgr);\n\tdevice_unregister(cscfg_device());\n}\n\n \nint __init cscfg_init(void)\n{\n\tint err = 0;\n\n\t \n\terr = cscfg_create_device();\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = cscfg_configfs_init(cscfg_mgr);\n\tif (err)\n\t\tgoto exit_err;\n\n\t \n\terr = cscfg_preload(THIS_MODULE);\n\tif (err)\n\t\tgoto exit_err;\n\n\tdev_info(cscfg_device(), \"CoreSight Configuration manager initialised\");\n\treturn 0;\n\nexit_err:\n\tcscfg_clear_device();\n\treturn err;\n}\n\nvoid cscfg_exit(void)\n{\n\tcscfg_clear_device();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}