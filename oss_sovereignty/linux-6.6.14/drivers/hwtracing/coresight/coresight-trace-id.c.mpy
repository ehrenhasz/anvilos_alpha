{
  "module_name": "coresight-trace-id.c",
  "hash_id": "8a8c69d40a0c005a336a34e5f7b8b05924eb511290bfd70206437d780a68541a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-trace-id.c",
  "human_readable_source": "\n \n#include <linux/coresight-pmu.h>\n#include <linux/cpumask.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#include \"coresight-trace-id.h\"\n\n \nstatic struct coresight_trace_id_map id_map_default;\n\n \nstatic DEFINE_PER_CPU(atomic_t, cpu_id) = ATOMIC_INIT(0);\nstatic cpumask_t cpu_id_release_pending;\n\n \nstatic atomic_t perf_cs_etm_session_active = ATOMIC_INIT(0);\n\n \nstatic DEFINE_SPINLOCK(id_map_lock);\n\n \n#if defined(TRACE_ID_DEBUG) || defined(CONFIG_COMPILE_TEST)\n\nstatic void coresight_trace_id_dump_table(struct coresight_trace_id_map *id_map,\n\t\t\t\t\t  const char *func_name)\n{\n\tpr_debug(\"%s id_map::\\n\", func_name);\n\tpr_debug(\"Used = %*pb\\n\", CORESIGHT_TRACE_IDS_MAX, id_map->used_ids);\n\tpr_debug(\"Pend = %*pb\\n\", CORESIGHT_TRACE_IDS_MAX, id_map->pend_rel_ids);\n}\n#define DUMP_ID_MAP(map)   coresight_trace_id_dump_table(map, __func__)\n#define DUMP_ID_CPU(cpu, id) pr_debug(\"%s called;  cpu=%d, id=%d\\n\", __func__, cpu, id)\n#define DUMP_ID(id)   pr_debug(\"%s called; id=%d\\n\", __func__, id)\n#define PERF_SESSION(n) pr_debug(\"%s perf count %d\\n\", __func__, n)\n#else\n#define DUMP_ID_MAP(map)\n#define DUMP_ID(id)\n#define DUMP_ID_CPU(cpu, id)\n#define PERF_SESSION(n)\n#endif\n\n \nstatic int _coresight_trace_id_read_cpu_id(int cpu)\n{\n\treturn atomic_read(&per_cpu(cpu_id, cpu));\n}\n\n \nstatic int coresight_trace_id_find_odd_id(struct coresight_trace_id_map *id_map)\n{\n\tint found_id = 0, bit = 1, next_id;\n\n\twhile ((bit < CORESIGHT_TRACE_ID_RES_TOP) && !found_id) {\n\t\t \n\t\tnext_id = find_next_zero_bit(id_map->used_ids,\n\t\t\t\t\t     CORESIGHT_TRACE_ID_RES_TOP, bit);\n\t\tif ((next_id < CORESIGHT_TRACE_ID_RES_TOP) && (next_id & 0x1))\n\t\t\tfound_id = next_id;\n\t\telse\n\t\t\tbit = next_id + 1;\n\t}\n\treturn found_id;\n}\n\n \nstatic int coresight_trace_id_alloc_new_id(struct coresight_trace_id_map *id_map,\n\t\t\t\t\t   int preferred_id, bool prefer_odd_id)\n{\n\tint id = 0;\n\n\t \n\tif (IS_VALID_CS_TRACE_ID(preferred_id) &&\n\t    !test_bit(preferred_id, id_map->used_ids)) {\n\t\tid = preferred_id;\n\t\tgoto trace_id_allocated;\n\t} else if (prefer_odd_id) {\n\t \n\t\tid = coresight_trace_id_find_odd_id(id_map);\n\t\tif (id)\n\t\t\tgoto trace_id_allocated;\n\t}\n\n\t \n\tid = find_next_zero_bit(id_map->used_ids, CORESIGHT_TRACE_ID_RES_TOP, 1);\n\tif (id >= CORESIGHT_TRACE_ID_RES_TOP)\n\t\treturn -EINVAL;\n\n\t \ntrace_id_allocated:\n\tset_bit(id, id_map->used_ids);\n\treturn id;\n}\n\nstatic void coresight_trace_id_free(int id, struct coresight_trace_id_map *id_map)\n{\n\tif (WARN(!IS_VALID_CS_TRACE_ID(id), \"Invalid Trace ID %d\\n\", id))\n\t\treturn;\n\tif (WARN(!test_bit(id, id_map->used_ids), \"Freeing unused ID %d\\n\", id))\n\t\treturn;\n\tclear_bit(id, id_map->used_ids);\n}\n\nstatic void coresight_trace_id_set_pend_rel(int id, struct coresight_trace_id_map *id_map)\n{\n\tif (WARN(!IS_VALID_CS_TRACE_ID(id), \"Invalid Trace ID %d\\n\", id))\n\t\treturn;\n\tset_bit(id, id_map->pend_rel_ids);\n}\n\n \nstatic void coresight_trace_id_release_all_pending(void)\n{\n\tstruct coresight_trace_id_map *id_map = &id_map_default;\n\tunsigned long flags;\n\tint cpu, bit;\n\n\tspin_lock_irqsave(&id_map_lock, flags);\n\tfor_each_set_bit(bit, id_map->pend_rel_ids, CORESIGHT_TRACE_ID_RES_TOP) {\n\t\tclear_bit(bit, id_map->used_ids);\n\t\tclear_bit(bit, id_map->pend_rel_ids);\n\t}\n\tfor_each_cpu(cpu, &cpu_id_release_pending) {\n\t\tatomic_set(&per_cpu(cpu_id, cpu), 0);\n\t\tcpumask_clear_cpu(cpu, &cpu_id_release_pending);\n\t}\n\tspin_unlock_irqrestore(&id_map_lock, flags);\n\tDUMP_ID_MAP(id_map);\n}\n\nstatic int coresight_trace_id_map_get_cpu_id(int cpu, struct coresight_trace_id_map *id_map)\n{\n\tunsigned long flags;\n\tint id;\n\n\tspin_lock_irqsave(&id_map_lock, flags);\n\n\t \n\tid = _coresight_trace_id_read_cpu_id(cpu);\n\tif (id)\n\t\tgoto get_cpu_id_clr_pend;\n\n\t \n\tid = coresight_trace_id_alloc_new_id(id_map,\n\t\t\t\t\t     CORESIGHT_LEGACY_CPU_TRACE_ID(cpu),\n\t\t\t\t\t     false);\n\tif (!IS_VALID_CS_TRACE_ID(id))\n\t\tgoto get_cpu_id_out_unlock;\n\n\t \n\tatomic_set(&per_cpu(cpu_id, cpu), id);\n\nget_cpu_id_clr_pend:\n\t \n\tcpumask_clear_cpu(cpu, &cpu_id_release_pending);\n\tclear_bit(id, id_map->pend_rel_ids);\n\nget_cpu_id_out_unlock:\n\tspin_unlock_irqrestore(&id_map_lock, flags);\n\n\tDUMP_ID_CPU(cpu, id);\n\tDUMP_ID_MAP(id_map);\n\treturn id;\n}\n\nstatic void coresight_trace_id_map_put_cpu_id(int cpu, struct coresight_trace_id_map *id_map)\n{\n\tunsigned long flags;\n\tint id;\n\n\t \n\tid = _coresight_trace_id_read_cpu_id(cpu);\n\tif (!id)\n\t\treturn;\n\n\tspin_lock_irqsave(&id_map_lock, flags);\n\n\tif (atomic_read(&perf_cs_etm_session_active)) {\n\t\t \n\t\tcoresight_trace_id_set_pend_rel(id, id_map);\n\t\tcpumask_set_cpu(cpu, &cpu_id_release_pending);\n\t} else {\n\t\t \n\t\tcoresight_trace_id_free(id, id_map);\n\t\tatomic_set(&per_cpu(cpu_id, cpu), 0);\n\t}\n\n\tspin_unlock_irqrestore(&id_map_lock, flags);\n\tDUMP_ID_CPU(cpu, id);\n\tDUMP_ID_MAP(id_map);\n}\n\nstatic int coresight_trace_id_map_get_system_id(struct coresight_trace_id_map *id_map)\n{\n\tunsigned long flags;\n\tint id;\n\n\tspin_lock_irqsave(&id_map_lock, flags);\n\t \n\tid = coresight_trace_id_alloc_new_id(id_map, 0, true);\n\tspin_unlock_irqrestore(&id_map_lock, flags);\n\n\tDUMP_ID(id);\n\tDUMP_ID_MAP(id_map);\n\treturn id;\n}\n\nstatic void coresight_trace_id_map_put_system_id(struct coresight_trace_id_map *id_map, int id)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&id_map_lock, flags);\n\tcoresight_trace_id_free(id, id_map);\n\tspin_unlock_irqrestore(&id_map_lock, flags);\n\n\tDUMP_ID(id);\n\tDUMP_ID_MAP(id_map);\n}\n\n \n\nint coresight_trace_id_get_cpu_id(int cpu)\n{\n\treturn coresight_trace_id_map_get_cpu_id(cpu, &id_map_default);\n}\nEXPORT_SYMBOL_GPL(coresight_trace_id_get_cpu_id);\n\nvoid coresight_trace_id_put_cpu_id(int cpu)\n{\n\tcoresight_trace_id_map_put_cpu_id(cpu, &id_map_default);\n}\nEXPORT_SYMBOL_GPL(coresight_trace_id_put_cpu_id);\n\nint coresight_trace_id_read_cpu_id(int cpu)\n{\n\treturn _coresight_trace_id_read_cpu_id(cpu);\n}\nEXPORT_SYMBOL_GPL(coresight_trace_id_read_cpu_id);\n\nint coresight_trace_id_get_system_id(void)\n{\n\treturn coresight_trace_id_map_get_system_id(&id_map_default);\n}\nEXPORT_SYMBOL_GPL(coresight_trace_id_get_system_id);\n\nvoid coresight_trace_id_put_system_id(int id)\n{\n\tcoresight_trace_id_map_put_system_id(&id_map_default, id);\n}\nEXPORT_SYMBOL_GPL(coresight_trace_id_put_system_id);\n\nvoid coresight_trace_id_perf_start(void)\n{\n\tatomic_inc(&perf_cs_etm_session_active);\n\tPERF_SESSION(atomic_read(&perf_cs_etm_session_active));\n}\nEXPORT_SYMBOL_GPL(coresight_trace_id_perf_start);\n\nvoid coresight_trace_id_perf_stop(void)\n{\n\tif (!atomic_dec_return(&perf_cs_etm_session_active))\n\t\tcoresight_trace_id_release_all_pending();\n\tPERF_SESSION(atomic_read(&perf_cs_etm_session_active));\n}\nEXPORT_SYMBOL_GPL(coresight_trace_id_perf_stop);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}