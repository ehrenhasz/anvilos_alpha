{
  "module_name": "coresight-stm.c",
  "hash_id": "e0fb50e133ad4133206a518391952b3c0ce48a0810c4d90f3ae98b4552a4d4f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-stm.c",
  "human_readable_source": "\n \n#include <asm/local.h>\n#include <linux/acpi.h>\n#include <linux/amba/bus.h>\n#include <linux/bitmap.h>\n#include <linux/clk.h>\n#include <linux/coresight.h>\n#include <linux/coresight-stm.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/of_address.h>\n#include <linux/perf_event.h>\n#include <linux/pm_runtime.h>\n#include <linux/stm.h>\n\n#include \"coresight-priv.h\"\n#include \"coresight-trace-id.h\"\n\n#define STMDMASTARTR\t\t\t0xc04\n#define STMDMASTOPR\t\t\t0xc08\n#define STMDMASTATR\t\t\t0xc0c\n#define STMDMACTLR\t\t\t0xc10\n#define STMDMAIDR\t\t\t0xcfc\n#define STMHEER\t\t\t\t0xd00\n#define STMHETER\t\t\t0xd20\n#define STMHEBSR\t\t\t0xd60\n#define STMHEMCR\t\t\t0xd64\n#define STMHEMASTR\t\t\t0xdf4\n#define STMHEFEAT1R\t\t\t0xdf8\n#define STMHEIDR\t\t\t0xdfc\n#define STMSPER\t\t\t\t0xe00\n#define STMSPTER\t\t\t0xe20\n#define STMPRIVMASKR\t\t\t0xe40\n#define STMSPSCR\t\t\t0xe60\n#define STMSPMSCR\t\t\t0xe64\n#define STMSPOVERRIDER\t\t\t0xe68\n#define STMSPMOVERRIDER\t\t\t0xe6c\n#define STMSPTRIGCSR\t\t\t0xe70\n#define STMTCSR\t\t\t\t0xe80\n#define STMTSSTIMR\t\t\t0xe84\n#define STMTSFREQR\t\t\t0xe8c\n#define STMSYNCR\t\t\t0xe90\n#define STMAUXCR\t\t\t0xe94\n#define STMSPFEAT1R\t\t\t0xea0\n#define STMSPFEAT2R\t\t\t0xea4\n#define STMSPFEAT3R\t\t\t0xea8\n#define STMITTRIGGER\t\t\t0xee8\n#define STMITATBDATA0\t\t\t0xeec\n#define STMITATBCTR2\t\t\t0xef0\n#define STMITATBID\t\t\t0xef4\n#define STMITATBCTR0\t\t\t0xef8\n\n#define STM_32_CHANNEL\t\t\t32\n#define BYTES_PER_CHANNEL\t\t256\n#define STM_TRACE_BUF_SIZE\t\t4096\n#define STM_SW_MASTER_END\t\t127\n\n \n#define STMTCSR_BUSY_BIT\t\t23\n \n#define STM_CHANNEL_OFFSET\t\t0\n\nenum stm_pkt_type {\n\tSTM_PKT_TYPE_DATA\t= 0x98,\n\tSTM_PKT_TYPE_FLAG\t= 0xE8,\n\tSTM_PKT_TYPE_TRIG\t= 0xF8,\n};\n\n#define stm_channel_addr(drvdata, ch)\t(drvdata->chs.base +\t\\\n\t\t\t\t\t(ch * BYTES_PER_CHANNEL))\n#define stm_channel_off(type, opts)\t(type & ~opts)\n\nstatic int boot_nr_channel;\n\n \nmodule_param_named(\n\tboot_nr_channel, boot_nr_channel, int, S_IRUGO\n);\n\n \nstruct channel_space {\n\tvoid __iomem\t\t*base;\n\tphys_addr_t\t\tphys;\n\tunsigned long\t\t*guaranteed;\n};\n\nDEFINE_CORESIGHT_DEVLIST(stm_devs, \"stm\");\n\n \nstruct stm_drvdata {\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*atclk;\n\tstruct coresight_device\t*csdev;\n\tspinlock_t\t\tspinlock;\n\tstruct channel_space\tchs;\n\tstruct stm_data\t\tstm;\n\tlocal_t\t\t\tmode;\n\tu8\t\t\ttraceid;\n\tu32\t\t\twrite_bytes;\n\tu32\t\t\tstmsper;\n\tu32\t\t\tstmspscr;\n\tu32\t\t\tnumsp;\n\tu32\t\t\tstmheer;\n\tu32\t\t\tstmheter;\n\tu32\t\t\tstmhebsr;\n};\n\nstatic void stm_hwevent_enable_hw(struct stm_drvdata *drvdata)\n{\n\tCS_UNLOCK(drvdata->base);\n\n\twritel_relaxed(drvdata->stmhebsr, drvdata->base + STMHEBSR);\n\twritel_relaxed(drvdata->stmheter, drvdata->base + STMHETER);\n\twritel_relaxed(drvdata->stmheer, drvdata->base + STMHEER);\n\twritel_relaxed(0x01 |\t \n\t\t       0x04,\t \n\t\t       drvdata->base + STMHEMCR);\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic void stm_port_enable_hw(struct stm_drvdata *drvdata)\n{\n\tCS_UNLOCK(drvdata->base);\n\t \n\twritel_relaxed(0x10,\n\t\t       drvdata->base + STMSPTRIGCSR);\n\twritel_relaxed(drvdata->stmspscr, drvdata->base + STMSPSCR);\n\twritel_relaxed(drvdata->stmsper, drvdata->base + STMSPER);\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic void stm_enable_hw(struct stm_drvdata *drvdata)\n{\n\tif (drvdata->stmheer)\n\t\tstm_hwevent_enable_hw(drvdata);\n\n\tstm_port_enable_hw(drvdata);\n\n\tCS_UNLOCK(drvdata->base);\n\n\t \n\twritel_relaxed(0xFFF, drvdata->base + STMSYNCR);\n\twritel_relaxed((drvdata->traceid << 16 |  \n\t\t\t0x02 |\t\t\t  \n\t\t\t0x01),\t\t\t  \n\t\t\tdrvdata->base + STMTCSR);\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic int stm_enable(struct coresight_device *csdev, struct perf_event *event,\n\t\t      enum cs_mode mode)\n{\n\tu32 val;\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\n\tif (mode != CS_MODE_SYSFS)\n\t\treturn -EINVAL;\n\n\tval = local_cmpxchg(&drvdata->mode, CS_MODE_DISABLED, mode);\n\n\t \n\tif (val)\n\t\treturn -EBUSY;\n\n\tpm_runtime_get_sync(csdev->dev.parent);\n\n\tspin_lock(&drvdata->spinlock);\n\tstm_enable_hw(drvdata);\n\tspin_unlock(&drvdata->spinlock);\n\n\tdev_dbg(&csdev->dev, \"STM tracing enabled\\n\");\n\treturn 0;\n}\n\nstatic void stm_hwevent_disable_hw(struct stm_drvdata *drvdata)\n{\n\tCS_UNLOCK(drvdata->base);\n\n\twritel_relaxed(0x0, drvdata->base + STMHEMCR);\n\twritel_relaxed(0x0, drvdata->base + STMHEER);\n\twritel_relaxed(0x0, drvdata->base + STMHETER);\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic void stm_port_disable_hw(struct stm_drvdata *drvdata)\n{\n\tCS_UNLOCK(drvdata->base);\n\n\twritel_relaxed(0x0, drvdata->base + STMSPER);\n\twritel_relaxed(0x0, drvdata->base + STMSPTRIGCSR);\n\n\tCS_LOCK(drvdata->base);\n}\n\nstatic void stm_disable_hw(struct stm_drvdata *drvdata)\n{\n\tu32 val;\n\n\tCS_UNLOCK(drvdata->base);\n\n\tval = readl_relaxed(drvdata->base + STMTCSR);\n\tval &= ~0x1;  \n\twritel_relaxed(val, drvdata->base + STMTCSR);\n\n\tCS_LOCK(drvdata->base);\n\n\tstm_port_disable_hw(drvdata);\n\tif (drvdata->stmheer)\n\t\tstm_hwevent_disable_hw(drvdata);\n}\n\nstatic void stm_disable(struct coresight_device *csdev,\n\t\t\tstruct perf_event *event)\n{\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\n\tstruct csdev_access *csa = &csdev->access;\n\n\t \n\tif (local_read(&drvdata->mode) == CS_MODE_SYSFS) {\n\t\tspin_lock(&drvdata->spinlock);\n\t\tstm_disable_hw(drvdata);\n\t\tspin_unlock(&drvdata->spinlock);\n\n\t\t \n\t\tcoresight_timeout(csa, STMTCSR, STMTCSR_BUSY_BIT, 0);\n\n\t\tpm_runtime_put(csdev->dev.parent);\n\n\t\tlocal_set(&drvdata->mode, CS_MODE_DISABLED);\n\t\tdev_dbg(&csdev->dev, \"STM tracing disabled\\n\");\n\t}\n}\n\nstatic const struct coresight_ops_source stm_source_ops = {\n\t.enable\t\t= stm_enable,\n\t.disable\t= stm_disable,\n};\n\nstatic const struct coresight_ops stm_cs_ops = {\n\t.source_ops\t= &stm_source_ops,\n};\n\nstatic inline bool stm_addr_unaligned(const void *addr, u8 write_bytes)\n{\n\treturn ((unsigned long)addr & (write_bytes - 1));\n}\n\nstatic void stm_send(void __iomem *addr, const void *data,\n\t\t     u32 size, u8 write_bytes)\n{\n\tu8 paload[8];\n\n\tif (stm_addr_unaligned(data, write_bytes)) {\n\t\tmemcpy(paload, data, size);\n\t\tdata = paload;\n\t}\n\n\t \n\tswitch (size) {\n#ifdef CONFIG_64BIT\n\tcase 8:\n\t\twriteq_relaxed(*(u64 *)data, addr);\n\t\tbreak;\n#endif\n\tcase 4:\n\t\twritel_relaxed(*(u32 *)data, addr);\n\t\tbreak;\n\tcase 2:\n\t\twritew_relaxed(*(u16 *)data, addr);\n\t\tbreak;\n\tcase 1:\n\t\twriteb_relaxed(*(u8 *)data, addr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int stm_generic_link(struct stm_data *stm_data,\n\t\t\t    unsigned int master,  unsigned int channel)\n{\n\tstruct stm_drvdata *drvdata = container_of(stm_data,\n\t\t\t\t\t\t   struct stm_drvdata, stm);\n\tif (!drvdata || !drvdata->csdev)\n\t\treturn -EINVAL;\n\n\treturn coresight_enable(drvdata->csdev);\n}\n\nstatic void stm_generic_unlink(struct stm_data *stm_data,\n\t\t\t       unsigned int master,  unsigned int channel)\n{\n\tstruct stm_drvdata *drvdata = container_of(stm_data,\n\t\t\t\t\t\t   struct stm_drvdata, stm);\n\tif (!drvdata || !drvdata->csdev)\n\t\treturn;\n\n\tcoresight_disable(drvdata->csdev);\n}\n\nstatic phys_addr_t\nstm_mmio_addr(struct stm_data *stm_data, unsigned int master,\n\t      unsigned int channel, unsigned int nr_chans)\n{\n\tstruct stm_drvdata *drvdata = container_of(stm_data,\n\t\t\t\t\t\t   struct stm_drvdata, stm);\n\tphys_addr_t addr;\n\n\taddr = drvdata->chs.phys + channel * BYTES_PER_CHANNEL;\n\n\tif (offset_in_page(addr) ||\n\t    offset_in_page(nr_chans * BYTES_PER_CHANNEL))\n\t\treturn 0;\n\n\treturn addr;\n}\n\nstatic long stm_generic_set_options(struct stm_data *stm_data,\n\t\t\t\t    unsigned int master,\n\t\t\t\t    unsigned int channel,\n\t\t\t\t    unsigned int nr_chans,\n\t\t\t\t    unsigned long options)\n{\n\tstruct stm_drvdata *drvdata = container_of(stm_data,\n\t\t\t\t\t\t   struct stm_drvdata, stm);\n\tif (!(drvdata && local_read(&drvdata->mode)))\n\t\treturn -EINVAL;\n\n\tif (channel >= drvdata->numsp)\n\t\treturn -EINVAL;\n\n\tswitch (options) {\n\tcase STM_OPTION_GUARANTEED:\n\t\tset_bit(channel, drvdata->chs.guaranteed);\n\t\tbreak;\n\n\tcase STM_OPTION_INVARIANT:\n\t\tclear_bit(channel, drvdata->chs.guaranteed);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t notrace stm_generic_packet(struct stm_data *stm_data,\n\t\t\t\t  unsigned int master,\n\t\t\t\t  unsigned int channel,\n\t\t\t\t  unsigned int packet,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  unsigned int size,\n\t\t\t\t  const unsigned char *payload)\n{\n\tvoid __iomem *ch_addr;\n\tstruct stm_drvdata *drvdata = container_of(stm_data,\n\t\t\t\t\t\t   struct stm_drvdata, stm);\n\tunsigned int stm_flags;\n\n\tif (!(drvdata && local_read(&drvdata->mode)))\n\t\treturn -EACCES;\n\n\tif (channel >= drvdata->numsp)\n\t\treturn -EINVAL;\n\n\tch_addr = stm_channel_addr(drvdata, channel);\n\n\tstm_flags = (flags & STP_PACKET_TIMESTAMPED) ?\n\t\t\tSTM_FLAG_TIMESTAMPED : 0;\n\tstm_flags |= test_bit(channel, drvdata->chs.guaranteed) ?\n\t\t\t   STM_FLAG_GUARANTEED : 0;\n\n\tif (size > drvdata->write_bytes)\n\t\tsize = drvdata->write_bytes;\n\telse\n\t\tsize = rounddown_pow_of_two(size);\n\n\tswitch (packet) {\n\tcase STP_PACKET_FLAG:\n\t\tch_addr += stm_channel_off(STM_PKT_TYPE_FLAG, stm_flags);\n\n\t\t \n\t\tstm_send(ch_addr, payload, 1, drvdata->write_bytes);\n\t\tsize = 1;\n\t\tbreak;\n\n\tcase STP_PACKET_DATA:\n\t\tstm_flags |= (flags & STP_PACKET_MARKED) ? STM_FLAG_MARKED : 0;\n\t\tch_addr += stm_channel_off(STM_PKT_TYPE_DATA, stm_flags);\n\t\tstm_send(ch_addr, payload, size,\n\t\t\t\tdrvdata->write_bytes);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t hwevent_enable_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tunsigned long val = drvdata->stmheer;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t hwevent_enable_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t size)\n{\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tunsigned long val;\n\tint ret = 0;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tdrvdata->stmheer = val;\n\t \n\tdrvdata->stmheter = val;\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(hwevent_enable);\n\nstatic ssize_t hwevent_select_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tunsigned long val = drvdata->stmhebsr;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t hwevent_select_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t size)\n{\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tunsigned long val;\n\tint ret = 0;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tdrvdata->stmhebsr = val;\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(hwevent_select);\n\nstatic ssize_t port_select_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tunsigned long val;\n\n\tif (!local_read(&drvdata->mode)) {\n\t\tval = drvdata->stmspscr;\n\t} else {\n\t\tspin_lock(&drvdata->spinlock);\n\t\tval = readl_relaxed(drvdata->base + STMSPSCR);\n\t\tspin_unlock(&drvdata->spinlock);\n\t}\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t port_select_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t size)\n{\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tunsigned long val, stmsper;\n\tint ret = 0;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&drvdata->spinlock);\n\tdrvdata->stmspscr = val;\n\n\tif (local_read(&drvdata->mode)) {\n\t\tCS_UNLOCK(drvdata->base);\n\t\t \n\t\tstmsper = readl_relaxed(drvdata->base + STMSPER);\n\t\twritel_relaxed(0x0, drvdata->base + STMSPER);\n\t\twritel_relaxed(drvdata->stmspscr, drvdata->base + STMSPSCR);\n\t\twritel_relaxed(stmsper, drvdata->base + STMSPER);\n\t\tCS_LOCK(drvdata->base);\n\t}\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(port_select);\n\nstatic ssize_t port_enable_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tunsigned long val;\n\n\tif (!local_read(&drvdata->mode)) {\n\t\tval = drvdata->stmsper;\n\t} else {\n\t\tspin_lock(&drvdata->spinlock);\n\t\tval = readl_relaxed(drvdata->base + STMSPER);\n\t\tspin_unlock(&drvdata->spinlock);\n\t}\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%#lx\\n\", val);\n}\n\nstatic ssize_t port_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t size)\n{\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\tunsigned long val;\n\tint ret = 0;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&drvdata->spinlock);\n\tdrvdata->stmsper = val;\n\n\tif (local_read(&drvdata->mode)) {\n\t\tCS_UNLOCK(drvdata->base);\n\t\twritel_relaxed(drvdata->stmsper, drvdata->base + STMSPER);\n\t\tCS_LOCK(drvdata->base);\n\t}\n\tspin_unlock(&drvdata->spinlock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(port_enable);\n\nstatic ssize_t traceid_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tunsigned long val;\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\n\n\tval = drvdata->traceid;\n\treturn sprintf(buf, \"%#lx\\n\", val);\n}\nstatic DEVICE_ATTR_RO(traceid);\n\nstatic struct attribute *coresight_stm_attrs[] = {\n\t&dev_attr_hwevent_enable.attr,\n\t&dev_attr_hwevent_select.attr,\n\t&dev_attr_port_enable.attr,\n\t&dev_attr_port_select.attr,\n\t&dev_attr_traceid.attr,\n\tNULL,\n};\n\nstatic struct attribute *coresight_stm_mgmt_attrs[] = {\n\tcoresight_simple_reg32(tcsr, STMTCSR),\n\tcoresight_simple_reg32(tsfreqr, STMTSFREQR),\n\tcoresight_simple_reg32(syncr, STMSYNCR),\n\tcoresight_simple_reg32(sper, STMSPER),\n\tcoresight_simple_reg32(spter, STMSPTER),\n\tcoresight_simple_reg32(privmaskr, STMPRIVMASKR),\n\tcoresight_simple_reg32(spscr, STMSPSCR),\n\tcoresight_simple_reg32(spmscr, STMSPMSCR),\n\tcoresight_simple_reg32(spfeat1r, STMSPFEAT1R),\n\tcoresight_simple_reg32(spfeat2r, STMSPFEAT2R),\n\tcoresight_simple_reg32(spfeat3r, STMSPFEAT3R),\n\tcoresight_simple_reg32(devid, CORESIGHT_DEVID),\n\tNULL,\n};\n\nstatic const struct attribute_group coresight_stm_group = {\n\t.attrs = coresight_stm_attrs,\n};\n\nstatic const struct attribute_group coresight_stm_mgmt_group = {\n\t.attrs = coresight_stm_mgmt_attrs,\n\t.name = \"mgmt\",\n};\n\nstatic const struct attribute_group *coresight_stm_groups[] = {\n\t&coresight_stm_group,\n\t&coresight_stm_mgmt_group,\n\tNULL,\n};\n\n#ifdef CONFIG_OF\nstatic int of_stm_get_stimulus_area(struct device *dev, struct resource *res)\n{\n\tconst char *name = NULL;\n\tint index = 0, found = 0;\n\tstruct device_node *np = dev->of_node;\n\n\twhile (!of_property_read_string_index(np, \"reg-names\", index, &name)) {\n\t\tif (strcmp(\"stm-stimulus-base\", name)) {\n\t\t\tindex++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfound = 1;\n\t\tbreak;\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn of_address_to_resource(np, index, res);\n}\n#else\nstatic inline int of_stm_get_stimulus_area(struct device *dev,\n\t\t\t\t\t   struct resource *res)\n{\n\treturn -ENOENT;\n}\n#endif\n\n#ifdef CONFIG_ACPI\nstatic int acpi_stm_get_stimulus_area(struct device *dev, struct resource *res)\n{\n\tint rc;\n\tbool found_base = false;\n\tstruct resource_entry *rent;\n\tLIST_HEAD(res_list);\n\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\n\trc = acpi_dev_get_resources(adev, &res_list, NULL, NULL);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = -ENOENT;\n\tlist_for_each_entry(rent, &res_list, node) {\n\t\tif (resource_type(rent->res) != IORESOURCE_MEM)\n\t\t\tcontinue;\n\t\tif (found_base) {\n\t\t\t*res = *rent->res;\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tfound_base = true;\n\t}\n\n\tacpi_dev_free_resource_list(&res_list);\n\treturn rc;\n}\n#else\nstatic inline int acpi_stm_get_stimulus_area(struct device *dev,\n\t\t\t\t\t     struct resource *res)\n{\n\treturn -ENOENT;\n}\n#endif\n\nstatic int stm_get_stimulus_area(struct device *dev, struct resource *res)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\n\tif (is_of_node(fwnode))\n\t\treturn of_stm_get_stimulus_area(dev, res);\n\telse if (is_acpi_node(fwnode))\n\t\treturn acpi_stm_get_stimulus_area(dev, res);\n\treturn -ENOENT;\n}\n\nstatic u32 stm_fundamental_data_size(struct stm_drvdata *drvdata)\n{\n\tu32 stmspfeat2r;\n\n\tif (!IS_ENABLED(CONFIG_64BIT))\n\t\treturn 4;\n\n\tstmspfeat2r = readl_relaxed(drvdata->base + STMSPFEAT2R);\n\n\t \n\treturn BMVAL(stmspfeat2r, 12, 15) ? 8 : 4;\n}\n\nstatic u32 stm_num_stimulus_port(struct stm_drvdata *drvdata)\n{\n\tu32 numsp;\n\n\tnumsp = readl_relaxed(drvdata->base + CORESIGHT_DEVID);\n\t \n\tnumsp &= 0x1ffff;\n\tif (!numsp)\n\t\tnumsp = STM_32_CHANNEL;\n\treturn numsp;\n}\n\nstatic void stm_init_default_data(struct stm_drvdata *drvdata)\n{\n\t \n\tdrvdata->stmspscr = 0x0;\n\t \n\tdrvdata->stmsper = ~0x0;\n\n\t \n\tbitmap_clear(drvdata->chs.guaranteed, 0, drvdata->numsp);\n}\n\nstatic void stm_init_generic_data(struct stm_drvdata *drvdata,\n\t\t\t\t  const char *name)\n{\n\tdrvdata->stm.name = name;\n\n\t \n\tdrvdata->stm.sw_start = 1;\n\tdrvdata->stm.sw_end = 1;\n\tdrvdata->stm.hw_override = true;\n\tdrvdata->stm.sw_nchannels = drvdata->numsp;\n\tdrvdata->stm.sw_mmiosz = BYTES_PER_CHANNEL;\n\tdrvdata->stm.packet = stm_generic_packet;\n\tdrvdata->stm.mmio_addr = stm_mmio_addr;\n\tdrvdata->stm.link = stm_generic_link;\n\tdrvdata->stm.unlink = stm_generic_unlink;\n\tdrvdata->stm.set_options = stm_generic_set_options;\n}\n\nstatic int stm_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tint ret, trace_id;\n\tvoid __iomem *base;\n\tstruct device *dev = &adev->dev;\n\tstruct coresight_platform_data *pdata = NULL;\n\tstruct stm_drvdata *drvdata;\n\tstruct resource *res = &adev->res;\n\tstruct resource ch_res;\n\tstruct coresight_desc desc = { 0 };\n\n\tdesc.name = coresight_alloc_device_name(&stm_devs, dev);\n\tif (!desc.name)\n\t\treturn -ENOMEM;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->atclk = devm_clk_get(&adev->dev, \"atclk\");  \n\tif (!IS_ERR(drvdata->atclk)) {\n\t\tret = clk_prepare_enable(drvdata->atclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tdev_set_drvdata(dev, drvdata);\n\n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\tdrvdata->base = base;\n\tdesc.access = CSDEV_ACCESS_IOMEM(base);\n\n\tret = stm_get_stimulus_area(dev, &ch_res);\n\tif (ret)\n\t\treturn ret;\n\tdrvdata->chs.phys = ch_res.start;\n\n\tbase = devm_ioremap_resource(dev, &ch_res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\tdrvdata->chs.base = base;\n\n\tdrvdata->write_bytes = stm_fundamental_data_size(drvdata);\n\n\tif (boot_nr_channel)\n\t\tdrvdata->numsp = boot_nr_channel;\n\telse\n\t\tdrvdata->numsp = stm_num_stimulus_port(drvdata);\n\n\tdrvdata->chs.guaranteed = devm_bitmap_zalloc(dev, drvdata->numsp,\n\t\t\t\t\t\t     GFP_KERNEL);\n\tif (!drvdata->chs.guaranteed)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&drvdata->spinlock);\n\n\tstm_init_default_data(drvdata);\n\tstm_init_generic_data(drvdata, desc.name);\n\n\tif (stm_register_device(dev, &drvdata->stm, THIS_MODULE)) {\n\t\tdev_info(dev,\n\t\t\t \"%s : stm_register_device failed, probing deferred\\n\",\n\t\t\t desc.name);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tpdata = coresight_get_platform_data(dev);\n\tif (IS_ERR(pdata)) {\n\t\tret = PTR_ERR(pdata);\n\t\tgoto stm_unregister;\n\t}\n\tadev->dev.platform_data = pdata;\n\n\tdesc.type = CORESIGHT_DEV_TYPE_SOURCE;\n\tdesc.subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_SOFTWARE;\n\tdesc.ops = &stm_cs_ops;\n\tdesc.pdata = pdata;\n\tdesc.dev = dev;\n\tdesc.groups = coresight_stm_groups;\n\tdrvdata->csdev = coresight_register(&desc);\n\tif (IS_ERR(drvdata->csdev)) {\n\t\tret = PTR_ERR(drvdata->csdev);\n\t\tgoto stm_unregister;\n\t}\n\n\ttrace_id = coresight_trace_id_get_system_id();\n\tif (trace_id < 0) {\n\t\tret = trace_id;\n\t\tgoto cs_unregister;\n\t}\n\tdrvdata->traceid = (u8)trace_id;\n\n\tpm_runtime_put(&adev->dev);\n\n\tdev_info(&drvdata->csdev->dev, \"%s initialized\\n\",\n\t\t (char *)coresight_get_uci_data(id));\n\treturn 0;\n\ncs_unregister:\n\tcoresight_unregister(drvdata->csdev);\n\nstm_unregister:\n\tstm_unregister_device(&drvdata->stm);\n\treturn ret;\n}\n\nstatic void stm_remove(struct amba_device *adev)\n{\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(&adev->dev);\n\n\tcoresight_trace_id_put_system_id(drvdata->traceid);\n\tcoresight_unregister(drvdata->csdev);\n\n\tstm_unregister_device(&drvdata->stm);\n}\n\n#ifdef CONFIG_PM\nstatic int stm_runtime_suspend(struct device *dev)\n{\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tif (drvdata && !IS_ERR(drvdata->atclk))\n\t\tclk_disable_unprepare(drvdata->atclk);\n\n\treturn 0;\n}\n\nstatic int stm_runtime_resume(struct device *dev)\n{\n\tstruct stm_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tif (drvdata && !IS_ERR(drvdata->atclk))\n\t\tclk_prepare_enable(drvdata->atclk);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops stm_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(stm_runtime_suspend, stm_runtime_resume, NULL)\n};\n\nstatic const struct amba_id stm_ids[] = {\n\tCS_AMBA_ID_DATA(0x000bb962, \"STM32\"),\n\tCS_AMBA_ID_DATA(0x000bb963, \"STM500\"),\n\t{ 0, 0},\n};\n\nMODULE_DEVICE_TABLE(amba, stm_ids);\n\nstatic struct amba_driver stm_driver = {\n\t.drv = {\n\t\t.name   = \"coresight-stm\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= &stm_dev_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe          = stm_probe,\n\t.remove         = stm_remove,\n\t.id_table\t= stm_ids,\n};\n\nmodule_amba_driver(stm_driver);\n\nMODULE_AUTHOR(\"Pratik Patel <pratikp@codeaurora.org>\");\nMODULE_DESCRIPTION(\"Arm CoreSight System Trace Macrocell driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}