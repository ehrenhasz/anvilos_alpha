{
  "module_name": "coresight-cti-platform.c",
  "hash_id": "a7cbd1cb008236d2e7e004cfc43bf5c8b2a9a66dff5df1b87bbee2f10be3d295",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-cti-platform.c",
  "human_readable_source": "\n \n#include <linux/coresight.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/arm/coresight-cti-dt.h>\n\n#include \"coresight-cti.h\"\n#include \"coresight-priv.h\"\n\n \n#define NR_V8PE_IN_SIGS\t\t2\n#define NR_V8PE_OUT_SIGS\t3\n#define NR_V8ETM_INOUT_SIGS\t4\n\n \n#define CTI_DT_CONNS\t\t\"trig-conns\"\n\n \n#define CTI_DT_V8ARCH_COMPAT\t\"arm,coresight-cti-v8-arch\"\n#define CTI_DT_CSDEV_ASSOC\t\"arm,cs-dev-assoc\"\n#define CTI_DT_TRIGIN_SIGS\t\"arm,trig-in-sigs\"\n#define CTI_DT_TRIGOUT_SIGS\t\"arm,trig-out-sigs\"\n#define CTI_DT_TRIGIN_TYPES\t\"arm,trig-in-types\"\n#define CTI_DT_TRIGOUT_TYPES\t\"arm,trig-out-types\"\n#define CTI_DT_FILTER_OUT_SIGS\t\"arm,trig-filters\"\n#define CTI_DT_CONN_NAME\t\"arm,trig-conn-name\"\n#define CTI_DT_CTM_ID\t\t\"arm,cti-ctm-id\"\n\n#ifdef CONFIG_OF\n \nstatic int of_cti_get_cpu_at_node(const struct device_node *node)\n{\n\tint cpu;\n\tstruct device_node *dn;\n\n\tif (node == NULL)\n\t\treturn -1;\n\n\tdn = of_parse_phandle(node, \"cpu\", 0);\n\t \n\tif (!dn)\n\t\treturn -1;\n\tcpu = of_cpu_node_to_id(dn);\n\tof_node_put(dn);\n\n\t \n\treturn (cpu < 0) ? -1 : cpu;\n}\n\n#else\nstatic int of_cti_get_cpu_at_node(const struct device_node *node)\n{\n\treturn -1;\n}\n\n#endif\n\n \nstatic int cti_plat_get_cpu_at_node(struct fwnode_handle *fwnode)\n{\n\tif (is_of_node(fwnode))\n\t\treturn of_cti_get_cpu_at_node(to_of_node(fwnode));\n\treturn -1;\n}\n\nconst char *cti_plat_get_node_name(struct fwnode_handle *fwnode)\n{\n\tif (is_of_node(fwnode))\n\t\treturn of_node_full_name(to_of_node(fwnode));\n\treturn \"unknown\";\n}\n\n \nstatic const char *\ncti_plat_get_csdev_or_node_name(struct fwnode_handle *fwnode,\n\t\t\t\tstruct coresight_device **csdev)\n{\n\tconst char *name = NULL;\n\t*csdev = coresight_find_csdev_by_fwnode(fwnode);\n\tif (*csdev)\n\t\tname = dev_name(&(*csdev)->dev);\n\telse\n\t\tname = cti_plat_get_node_name(fwnode);\n\treturn name;\n}\n\nstatic bool cti_plat_node_name_eq(struct fwnode_handle *fwnode,\n\t\t\t\t  const char *name)\n{\n\tif (is_of_node(fwnode))\n\t\treturn of_node_name_eq(to_of_node(fwnode), name);\n\treturn false;\n}\n\nstatic int cti_plat_create_v8_etm_connection(struct device *dev,\n\t\t\t\t\t     struct cti_drvdata *drvdata)\n{\n\tint ret = -ENOMEM, i;\n\tstruct fwnode_handle *root_fwnode, *cs_fwnode;\n\tconst char *assoc_name = NULL;\n\tstruct coresight_device *csdev;\n\tstruct cti_trig_con *tc = NULL;\n\n\troot_fwnode = dev_fwnode(dev);\n\tif (IS_ERR_OR_NULL(root_fwnode))\n\t\treturn -EINVAL;\n\n\t \n\tcs_fwnode = fwnode_find_reference(root_fwnode, CTI_DT_CSDEV_ASSOC, 0);\n\tif (IS_ERR(cs_fwnode))\n\t\treturn 0;\n\n\t \n\ttc = cti_allocate_trig_con(dev, NR_V8ETM_INOUT_SIGS,\n\t\t\t\t   NR_V8ETM_INOUT_SIGS);\n\tif (!tc)\n\t\tgoto create_v8_etm_out;\n\n\t \n\ttc->con_in->used_mask = 0xF0;  \n\ttc->con_out->used_mask = 0xF0;  \n\n\t \n\tfor (i = 0; i < NR_V8ETM_INOUT_SIGS; i++) {\n\t\ttc->con_in->sig_types[i] = ETM_EXTOUT;\n\t\ttc->con_out->sig_types[i] = ETM_EXTIN;\n\t}\n\n\t \n\tassoc_name = cti_plat_get_csdev_or_node_name(cs_fwnode, &csdev);\n\tret = cti_add_connection_entry(dev, drvdata, tc, csdev, assoc_name);\n\ncreate_v8_etm_out:\n\tfwnode_handle_put(cs_fwnode);\n\treturn ret;\n}\n\n \nstatic int cti_plat_create_v8_connections(struct device *dev,\n\t\t\t\t\t  struct cti_drvdata *drvdata)\n{\n\tstruct cti_device *cti_dev = &drvdata->ctidev;\n\tstruct cti_trig_con *tc = NULL;\n\tint cpuid = 0;\n\tchar cpu_name_str[16];\n\tint ret = -ENOMEM;\n\n\t \n\tcpuid = cti_plat_get_cpu_at_node(dev_fwnode(dev));\n\tif (cpuid < 0) {\n\t\tdev_warn(dev,\n\t\t\t \"ARM v8 architectural CTI connection: missing cpu\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcti_dev->cpu = cpuid;\n\n\t \n\ttc = cti_allocate_trig_con(dev, NR_V8PE_IN_SIGS, NR_V8PE_OUT_SIGS);\n\tif (!tc)\n\t\tgoto of_create_v8_out;\n\n\t \n\ttc->con_in->used_mask = 0x3;  \n\ttc->con_in->sig_types[0] = PE_DBGTRIGGER;\n\ttc->con_in->sig_types[1] = PE_PMUIRQ;\n\ttc->con_out->used_mask = 0x7;  \n\ttc->con_out->sig_types[0] = PE_EDBGREQ;\n\ttc->con_out->sig_types[1] = PE_DBGRESTART;\n\ttc->con_out->sig_types[2] = PE_CTIIRQ;\n\tscnprintf(cpu_name_str, sizeof(cpu_name_str), \"cpu%d\", cpuid);\n\n\tret = cti_add_connection_entry(dev, drvdata, tc, NULL, cpu_name_str);\n\tif (ret)\n\t\tgoto of_create_v8_out;\n\n\t \n\tret = cti_plat_create_v8_etm_connection(dev, drvdata);\n\tif (ret)\n\t\tgoto of_create_v8_out;\n\n\t \n\tdrvdata->config.trig_out_filter |= 0x1;\n\nof_create_v8_out:\n\treturn ret;\n}\n\nstatic int cti_plat_check_v8_arch_compatible(struct device *dev)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\n\tif (is_of_node(fwnode))\n\t\treturn of_device_is_compatible(to_of_node(fwnode),\n\t\t\t\t\t       CTI_DT_V8ARCH_COMPAT);\n\treturn 0;\n}\n\nstatic int cti_plat_count_sig_elements(const struct fwnode_handle *fwnode,\n\t\t\t\t       const char *name)\n{\n\tint nr_elem = fwnode_property_count_u32(fwnode, name);\n\n\treturn (nr_elem < 0 ? 0 : nr_elem);\n}\n\nstatic int cti_plat_read_trig_group(struct cti_trig_grp *tgrp,\n\t\t\t\t    const struct fwnode_handle *fwnode,\n\t\t\t\t    const char *grp_name)\n{\n\tint idx, err = 0;\n\tu32 *values;\n\n\tif (!tgrp->nr_sigs)\n\t\treturn 0;\n\n\tvalues = kcalloc(tgrp->nr_sigs, sizeof(u32), GFP_KERNEL);\n\tif (!values)\n\t\treturn -ENOMEM;\n\n\terr = fwnode_property_read_u32_array(fwnode, grp_name,\n\t\t\t\t\t     values, tgrp->nr_sigs);\n\n\tif (!err) {\n\t\t \n\t\tfor (idx = 0; idx < tgrp->nr_sigs; idx++)\n\t\t\ttgrp->used_mask |= BIT(values[idx]);\n\t}\n\n\tkfree(values);\n\treturn err;\n}\n\nstatic int cti_plat_read_trig_types(struct cti_trig_grp *tgrp,\n\t\t\t\t    const struct fwnode_handle *fwnode,\n\t\t\t\t    const char *type_name)\n{\n\tint items, err = 0, nr_sigs;\n\tu32 *values = NULL, i;\n\n\t \n\tnr_sigs = tgrp->nr_sigs;\n\tif (!nr_sigs)\n\t\treturn 0;\n\n\t \n\titems = cti_plat_count_sig_elements(fwnode, type_name);\n\tif (items > nr_sigs)\n\t\treturn -EINVAL;\n\n\t \n\tif (items) {\n\t\tvalues = kcalloc(items, sizeof(u32), GFP_KERNEL);\n\t\tif (!values)\n\t\t\treturn -ENOMEM;\n\n\t\terr = fwnode_property_read_u32_array(fwnode, type_name,\n\t\t\t\t\t\t     values, items);\n\t\tif (err)\n\t\t\tgoto read_trig_types_out;\n\t}\n\n\t \n\tfor (i = 0; i < nr_sigs; i++) {\n\t\tif (i < items) {\n\t\t\ttgrp->sig_types[i] =\n\t\t\t\tvalues[i] < CTI_TRIG_MAX ? values[i] : GEN_IO;\n\t\t} else {\n\t\t\ttgrp->sig_types[i] = GEN_IO;\n\t\t}\n\t}\n\nread_trig_types_out:\n\tkfree(values);\n\treturn err;\n}\n\nstatic int cti_plat_process_filter_sigs(struct cti_drvdata *drvdata,\n\t\t\t\t\tconst struct fwnode_handle *fwnode)\n{\n\tstruct cti_trig_grp *tg = NULL;\n\tint err = 0, nr_filter_sigs;\n\n\tnr_filter_sigs = cti_plat_count_sig_elements(fwnode,\n\t\t\t\t\t\t     CTI_DT_FILTER_OUT_SIGS);\n\tif (nr_filter_sigs == 0)\n\t\treturn 0;\n\n\tif (nr_filter_sigs > drvdata->config.nr_trig_max)\n\t\treturn -EINVAL;\n\n\ttg = kzalloc(sizeof(*tg), GFP_KERNEL);\n\tif (!tg)\n\t\treturn -ENOMEM;\n\n\terr = cti_plat_read_trig_group(tg, fwnode, CTI_DT_FILTER_OUT_SIGS);\n\tif (!err)\n\t\tdrvdata->config.trig_out_filter |= tg->used_mask;\n\n\tkfree(tg);\n\treturn err;\n}\n\nstatic int cti_plat_create_connection(struct device *dev,\n\t\t\t\t      struct cti_drvdata *drvdata,\n\t\t\t\t      struct fwnode_handle *fwnode)\n{\n\tstruct cti_trig_con *tc = NULL;\n\tint cpuid = -1, err = 0;\n\tstruct coresight_device *csdev = NULL;\n\tconst char *assoc_name = \"unknown\";\n\tchar cpu_name_str[16];\n\tint nr_sigs_in, nr_sigs_out;\n\n\t \n\tnr_sigs_in = cti_plat_count_sig_elements(fwnode, CTI_DT_TRIGIN_SIGS);\n\tnr_sigs_out = cti_plat_count_sig_elements(fwnode, CTI_DT_TRIGOUT_SIGS);\n\n\tif ((nr_sigs_in > drvdata->config.nr_trig_max) ||\n\t    (nr_sigs_out > drvdata->config.nr_trig_max))\n\t\treturn -EINVAL;\n\n\ttc = cti_allocate_trig_con(dev, nr_sigs_in, nr_sigs_out);\n\tif (!tc)\n\t\treturn -ENOMEM;\n\n\t \n\terr = cti_plat_read_trig_group(tc->con_in, fwnode,\n\t\t\t\t       CTI_DT_TRIGIN_SIGS);\n\tif (err)\n\t\tgoto create_con_err;\n\n\terr = cti_plat_read_trig_types(tc->con_in, fwnode,\n\t\t\t\t       CTI_DT_TRIGIN_TYPES);\n\tif (err)\n\t\tgoto create_con_err;\n\n\terr = cti_plat_read_trig_group(tc->con_out, fwnode,\n\t\t\t\t       CTI_DT_TRIGOUT_SIGS);\n\tif (err)\n\t\tgoto create_con_err;\n\n\terr = cti_plat_read_trig_types(tc->con_out, fwnode,\n\t\t\t\t       CTI_DT_TRIGOUT_TYPES);\n\tif (err)\n\t\tgoto create_con_err;\n\n\terr = cti_plat_process_filter_sigs(drvdata, fwnode);\n\tif (err)\n\t\tgoto create_con_err;\n\n\t \n\tfwnode_property_read_string(fwnode, CTI_DT_CONN_NAME, &assoc_name);\n\n\t \n\tcpuid = cti_plat_get_cpu_at_node(fwnode);\n\tif (cpuid >= 0) {\n\t\tdrvdata->ctidev.cpu = cpuid;\n\t\tscnprintf(cpu_name_str, sizeof(cpu_name_str), \"cpu%d\", cpuid);\n\t\tassoc_name = cpu_name_str;\n\t} else {\n\t\t \n\t\tstruct fwnode_handle *cs_fwnode = fwnode_find_reference(fwnode,\n\t\t\t\t\t\t\t\t\tCTI_DT_CSDEV_ASSOC,\n\t\t\t\t\t\t\t\t\t0);\n\t\tif (!IS_ERR(cs_fwnode)) {\n\t\t\tassoc_name = cti_plat_get_csdev_or_node_name(cs_fwnode,\n\t\t\t\t\t\t\t\t     &csdev);\n\t\t\tfwnode_handle_put(cs_fwnode);\n\t\t}\n\t}\n\t \n\terr = cti_add_connection_entry(dev, drvdata, tc, csdev, assoc_name);\n\ncreate_con_err:\n\treturn err;\n}\n\nstatic int cti_plat_create_impdef_connections(struct device *dev,\n\t\t\t\t\t      struct cti_drvdata *drvdata)\n{\n\tint rc = 0;\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tstruct fwnode_handle *child = NULL;\n\n\tif (IS_ERR_OR_NULL(fwnode))\n\t\treturn -EINVAL;\n\n\tfwnode_for_each_child_node(fwnode, child) {\n\t\tif (cti_plat_node_name_eq(child, CTI_DT_CONNS))\n\t\t\trc = cti_plat_create_connection(dev, drvdata,\n\t\t\t\t\t\t\tchild);\n\t\tif (rc != 0)\n\t\t\tbreak;\n\t}\n\tfwnode_handle_put(child);\n\n\treturn rc;\n}\n\n \nstatic int cti_plat_get_hw_data(struct device *dev, struct cti_drvdata *drvdata)\n{\n\tint rc = 0;\n\tstruct cti_device *cti_dev = &drvdata->ctidev;\n\n\t \n\tdevice_property_read_u32(dev, CTI_DT_CTM_ID, &cti_dev->ctm_id);\n\n\t \n\tif (cti_plat_check_v8_arch_compatible(dev))\n\t\trc = cti_plat_create_v8_connections(dev, drvdata);\n\telse\n\t\trc = cti_plat_create_impdef_connections(dev, drvdata);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (cti_dev->nr_trig_con == 0)\n\t\trc = cti_add_default_connection(dev, drvdata);\n\treturn rc;\n}\n\nstruct coresight_platform_data *\ncoresight_cti_get_platform_data(struct device *dev)\n{\n\tint ret = -ENOENT;\n\tstruct coresight_platform_data *pdata = NULL;\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tstruct cti_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tif (IS_ERR_OR_NULL(fwnode))\n\t\tgoto error;\n\n\t \n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tret = cti_plat_get_hw_data(dev, drvdata);\n\n\tif (!ret)\n\t\treturn pdata;\nerror:\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}