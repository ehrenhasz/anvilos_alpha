{
  "module_name": "coresight-trbe.h",
  "hash_id": "615051d7de1ad0fd95f65015d3166cf648233a257cb278ae5bcaee7c6d5dcdcd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-trbe.h",
  "human_readable_source": " \n \n#include <linux/coresight.h>\n#include <linux/device.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/smp.h>\n\n#include \"coresight-etm-perf.h\"\n\nstatic inline bool is_trbe_available(void)\n{\n\tu64 aa64dfr0 = read_sysreg_s(SYS_ID_AA64DFR0_EL1);\n\tunsigned int trbe = cpuid_feature_extract_unsigned_field(aa64dfr0,\n\t\t\t\t\t\t\t\t ID_AA64DFR0_EL1_TraceBuffer_SHIFT);\n\n\treturn trbe >= ID_AA64DFR0_EL1_TraceBuffer_IMP;\n}\n\nstatic inline bool is_trbe_enabled(void)\n{\n\tu64 trblimitr = read_sysreg_s(SYS_TRBLIMITR_EL1);\n\n\treturn trblimitr & TRBLIMITR_EL1_E;\n}\n\n#define TRBE_EC_OTHERS\t\t0\n#define TRBE_EC_STAGE1_ABORT\t36\n#define TRBE_EC_STAGE2_ABORT\t37\n\nstatic inline int get_trbe_ec(u64 trbsr)\n{\n\treturn (trbsr & TRBSR_EL1_EC_MASK) >> TRBSR_EL1_EC_SHIFT;\n}\n\n#define TRBE_BSC_NOT_STOPPED 0\n#define TRBE_BSC_FILLED      1\n#define TRBE_BSC_TRIGGERED   2\n\nstatic inline int get_trbe_bsc(u64 trbsr)\n{\n\treturn (trbsr & TRBSR_EL1_BSC_MASK) >> TRBSR_EL1_BSC_SHIFT;\n}\n\nstatic inline void clr_trbe_irq(void)\n{\n\tu64 trbsr = read_sysreg_s(SYS_TRBSR_EL1);\n\n\ttrbsr &= ~TRBSR_EL1_IRQ;\n\twrite_sysreg_s(trbsr, SYS_TRBSR_EL1);\n}\n\nstatic inline bool is_trbe_irq(u64 trbsr)\n{\n\treturn trbsr & TRBSR_EL1_IRQ;\n}\n\nstatic inline bool is_trbe_trg(u64 trbsr)\n{\n\treturn trbsr & TRBSR_EL1_TRG;\n}\n\nstatic inline bool is_trbe_wrap(u64 trbsr)\n{\n\treturn trbsr & TRBSR_EL1_WRAP;\n}\n\nstatic inline bool is_trbe_abort(u64 trbsr)\n{\n\treturn trbsr & TRBSR_EL1_EA;\n}\n\nstatic inline bool is_trbe_running(u64 trbsr)\n{\n\treturn !(trbsr & TRBSR_EL1_S);\n}\n\nstatic inline bool get_trbe_flag_update(u64 trbidr)\n{\n\treturn trbidr & TRBIDR_EL1_F;\n}\n\nstatic inline bool is_trbe_programmable(u64 trbidr)\n{\n\treturn !(trbidr & TRBIDR_EL1_P);\n}\n\nstatic inline int get_trbe_address_align(u64 trbidr)\n{\n\treturn (trbidr & TRBIDR_EL1_Align_MASK) >> TRBIDR_EL1_Align_SHIFT;\n}\n\nstatic inline unsigned long get_trbe_write_pointer(void)\n{\n\treturn read_sysreg_s(SYS_TRBPTR_EL1);\n}\n\nstatic inline void set_trbe_write_pointer(unsigned long addr)\n{\n\tWARN_ON(is_trbe_enabled());\n\twrite_sysreg_s(addr, SYS_TRBPTR_EL1);\n}\n\nstatic inline unsigned long get_trbe_limit_pointer(void)\n{\n\tu64 trblimitr = read_sysreg_s(SYS_TRBLIMITR_EL1);\n\tunsigned long addr = trblimitr & TRBLIMITR_EL1_LIMIT_MASK;\n\n\tWARN_ON(!IS_ALIGNED(addr, PAGE_SIZE));\n\treturn addr;\n}\n\nstatic inline unsigned long get_trbe_base_pointer(void)\n{\n\tu64 trbbaser = read_sysreg_s(SYS_TRBBASER_EL1);\n\tunsigned long addr = trbbaser & TRBBASER_EL1_BASE_MASK;\n\n\tWARN_ON(!IS_ALIGNED(addr, PAGE_SIZE));\n\treturn addr;\n}\n\nstatic inline void set_trbe_base_pointer(unsigned long addr)\n{\n\tWARN_ON(is_trbe_enabled());\n\tWARN_ON(!IS_ALIGNED(addr, (1UL << TRBBASER_EL1_BASE_SHIFT)));\n\tWARN_ON(!IS_ALIGNED(addr, PAGE_SIZE));\n\twrite_sysreg_s(addr, SYS_TRBBASER_EL1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}