{
  "module_name": "coresight-etm.h",
  "hash_id": "15d61935c05f7913d745685834b08f44b4c49204f73c7f6e88ec11026df25f30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-etm.h",
  "human_readable_source": " \n \n\n#ifndef _CORESIGHT_CORESIGHT_ETM_H\n#define _CORESIGHT_CORESIGHT_ETM_H\n\n#include <asm/local.h>\n#include <linux/spinlock.h>\n#include \"coresight-priv.h\"\n\n \n\n \n#define ETMCR\t\t\t0x000\n#define ETMCCR\t\t\t0x004\n#define ETMTRIGGER\t\t0x008\n#define ETMSR\t\t\t0x010\n#define ETMSCR\t\t\t0x014\n#define ETMTSSCR\t\t0x018\n#define ETMTECR2\t\t0x01c\n#define ETMTEEVR\t\t0x020\n#define ETMTECR1\t\t0x024\n#define ETMFFLR\t\t\t0x02c\n#define ETMACVRn(n)\t\t(0x040 + (n * 4))\n#define ETMACTRn(n)\t\t(0x080 + (n * 4))\n#define ETMCNTRLDVRn(n)\t\t(0x140 + (n * 4))\n#define ETMCNTENRn(n)\t\t(0x150 + (n * 4))\n#define ETMCNTRLDEVRn(n)\t(0x160 + (n * 4))\n#define ETMCNTVRn(n)\t\t(0x170 + (n * 4))\n#define ETMSQ12EVR\t\t0x180\n#define ETMSQ21EVR\t\t0x184\n#define ETMSQ23EVR\t\t0x188\n#define ETMSQ31EVR\t\t0x18c\n#define ETMSQ32EVR\t\t0x190\n#define ETMSQ13EVR\t\t0x194\n#define ETMSQR\t\t\t0x19c\n#define ETMEXTOUTEVRn(n)\t(0x1a0 + (n * 4))\n#define ETMCIDCVRn(n)\t\t(0x1b0 + (n * 4))\n#define ETMCIDCMR\t\t0x1bc\n#define ETMIMPSPEC0\t\t0x1c0\n#define ETMIMPSPEC1\t\t0x1c4\n#define ETMIMPSPEC2\t\t0x1c8\n#define ETMIMPSPEC3\t\t0x1cc\n#define ETMIMPSPEC4\t\t0x1d0\n#define ETMIMPSPEC5\t\t0x1d4\n#define ETMIMPSPEC6\t\t0x1d8\n#define ETMIMPSPEC7\t\t0x1dc\n#define ETMSYNCFR\t\t0x1e0\n#define ETMIDR\t\t\t0x1e4\n#define ETMCCER\t\t\t0x1e8\n#define ETMEXTINSELR\t\t0x1ec\n#define ETMTESSEICR\t\t0x1f0\n#define ETMEIBCR\t\t0x1f4\n#define ETMTSEVR\t\t0x1f8\n#define ETMAUXCR\t\t0x1fc\n#define ETMTRACEIDR\t\t0x200\n#define ETMVMIDCVR\t\t0x240\n \n#define ETMOSLAR\t\t0x300\n#define ETMOSLSR\t\t0x304\n#define ETMOSSRR\t\t0x308\n#define ETMPDCR\t\t\t0x310\n#define ETMPDSR\t\t\t0x314\n#define ETM_MAX_ADDR_CMP\t16\n#define ETM_MAX_CNTR\t\t4\n#define ETM_MAX_CTXID_CMP\t3\n\n \n \n#define ETMCR_PWD_DWN\t\tBIT(0)\n#define ETMCR_STALL_MODE\tBIT(7)\n#define ETMCR_BRANCH_BROADCAST\tBIT(8)\n#define ETMCR_ETM_PRG\t\tBIT(10)\n#define ETMCR_ETM_EN\t\tBIT(11)\n#define ETMCR_CYC_ACC\t\tBIT(12)\n#define ETMCR_CTXID_SIZE\t(BIT(14)|BIT(15))\n#define ETMCR_TIMESTAMP_EN\tBIT(28)\n#define ETMCR_RETURN_STACK\tBIT(29)\n \n#define ETMCCR_FIFOFULL\t\tBIT(23)\n \n#define ETMPDCR_PWD_UP\t\tBIT(3)\n \n#define ETMTECR1_ADDR_COMP_1\tBIT(0)\n#define ETMTECR1_INC_EXC\tBIT(24)\n#define ETMTECR1_START_STOP\tBIT(25)\n \n#define ETMCCER_TIMESTAMP\tBIT(22)\n#define ETMCCER_RETSTACK\tBIT(23)\n\n#define ETM_MODE_EXCLUDE\tBIT(0)\n#define ETM_MODE_CYCACC\t\tBIT(1)\n#define ETM_MODE_STALL\t\tBIT(2)\n#define ETM_MODE_TIMESTAMP\tBIT(3)\n#define ETM_MODE_CTXID\t\tBIT(4)\n#define ETM_MODE_BBROAD\t\tBIT(5)\n#define ETM_MODE_RET_STACK\tBIT(6)\n#define ETM_MODE_ALL\t\t(ETM_MODE_EXCLUDE | ETM_MODE_CYCACC | \\\n\t\t\t\t ETM_MODE_STALL | ETM_MODE_TIMESTAMP | \\\n\t\t\t\t ETM_MODE_BBROAD | ETM_MODE_RET_STACK | \\\n\t\t\t\t ETM_MODE_CTXID | ETM_MODE_EXCL_KERN | \\\n\t\t\t\t ETM_MODE_EXCL_USER)\n\n#define ETM_SQR_MASK\t\t0x3\n#define ETM_TRACEID_MASK\t0x3f\n#define ETM_EVENT_MASK\t\t0x1ffff\n#define ETM_SYNC_MASK\t\t0xfff\n#define ETM_ALL_MASK\t\t0xffffffff\n\n#define ETMSR_PROG_BIT\t\t1\n#define ETM_SEQ_STATE_MAX_VAL\t(0x2)\n#define PORT_SIZE_MASK\t\t(GENMASK(21, 21) | GENMASK(6, 4))\n\n#define ETM_HARD_WIRE_RES_A\t \t\\\n\t\t\t\t((0x0f << 0)\t|\t\t\\\n\t\t\t\t \t\t\\\n\t\t\t\t(0x06 << 4))\n\n#define ETM_ADD_COMP_0\t\t \t\\\n\t\t\t\t((0x00 << 7)\t|\t\t\\\n\t\t\t\t \t\t\\\n\t\t\t\t(0x00 << 11))\n\n#define ETM_EVENT_NOT_A\t\tBIT(14)  \n\n#define ETM_DEFAULT_EVENT_VAL\t(ETM_HARD_WIRE_RES_A\t|\t\\\n\t\t\t\t ETM_ADD_COMP_0\t\t|\t\\\n\t\t\t\t ETM_EVENT_NOT_A)\n\n \nstruct etm_config {\n\tu32\t\t\t\tmode;\n\tu32\t\t\t\tctrl;\n\tu32\t\t\t\ttrigger_event;\n\tu32\t\t\t\tstartstop_ctrl;\n\tu32\t\t\t\tenable_event;\n\tu32\t\t\t\tenable_ctrl1;\n\tu32\t\t\t\tenable_ctrl2;\n\tu32\t\t\t\tfifofull_level;\n\tu8\t\t\t\taddr_idx;\n\tu32\t\t\t\taddr_val[ETM_MAX_ADDR_CMP];\n\tu32\t\t\t\taddr_acctype[ETM_MAX_ADDR_CMP];\n\tu32\t\t\t\taddr_type[ETM_MAX_ADDR_CMP];\n\tu8\t\t\t\tcntr_idx;\n\tu32\t\t\t\tcntr_rld_val[ETM_MAX_CNTR];\n\tu32\t\t\t\tcntr_event[ETM_MAX_CNTR];\n\tu32\t\t\t\tcntr_rld_event[ETM_MAX_CNTR];\n\tu32\t\t\t\tcntr_val[ETM_MAX_CNTR];\n\tu32\t\t\t\tseq_12_event;\n\tu32\t\t\t\tseq_21_event;\n\tu32\t\t\t\tseq_23_event;\n\tu32\t\t\t\tseq_31_event;\n\tu32\t\t\t\tseq_32_event;\n\tu32\t\t\t\tseq_13_event;\n\tu32\t\t\t\tseq_curr_state;\n\tu8\t\t\t\tctxid_idx;\n\tu32\t\t\t\tctxid_pid[ETM_MAX_CTXID_CMP];\n\tu32\t\t\t\tctxid_mask;\n\tu32\t\t\t\tsync_freq;\n\tu32\t\t\t\ttimestamp_event;\n};\n\n \nstruct etm_drvdata {\n\tvoid __iomem\t\t\t*base;\n\tstruct clk\t\t\t*atclk;\n\tstruct coresight_device\t\t*csdev;\n\tspinlock_t\t\t\tspinlock;\n\tint\t\t\t\tcpu;\n\tint\t\t\t\tport_size;\n\tu8\t\t\t\tarch;\n\tbool\t\t\t\tuse_cp14;\n\tlocal_t\t\t\t\tmode;\n\tbool\t\t\t\tsticky_enable;\n\tbool\t\t\t\tboot_enable;\n\tbool\t\t\t\tos_unlock;\n\tu8\t\t\t\tnr_addr_cmp;\n\tu8\t\t\t\tnr_cntr;\n\tu8\t\t\t\tnr_ext_inp;\n\tu8\t\t\t\tnr_ext_out;\n\tu8\t\t\t\tnr_ctxid_cmp;\n\tu32\t\t\t\tetmccr;\n\tu32\t\t\t\tetmccer;\n\tu32\t\t\t\ttraceid;\n\tstruct etm_config\t\tconfig;\n};\n\nstatic inline void etm_writel(struct etm_drvdata *drvdata,\n\t\t\t      u32 val, u32 off)\n{\n\tif (drvdata->use_cp14) {\n\t\tif (etm_writel_cp14(off, val)) {\n\t\t\tdev_err(&drvdata->csdev->dev,\n\t\t\t\t\"invalid CP14 access to ETM reg: %#x\", off);\n\t\t}\n\t} else {\n\t\twritel_relaxed(val, drvdata->base + off);\n\t}\n}\n\nstatic inline unsigned int etm_readl(struct etm_drvdata *drvdata, u32 off)\n{\n\tu32 val;\n\n\tif (drvdata->use_cp14) {\n\t\tif (etm_readl_cp14(off, &val)) {\n\t\t\tdev_err(&drvdata->csdev->dev,\n\t\t\t\t\"invalid CP14 access to ETM reg: %#x\", off);\n\t\t}\n\t} else {\n\t\tval = readl_relaxed(drvdata->base + off);\n\t}\n\n\treturn val;\n}\n\nextern const struct attribute_group *coresight_etm_groups[];\nvoid etm_set_default(struct etm_config *config);\nvoid etm_config_trace_mode(struct etm_config *config);\nstruct etm_config *get_etm_config(struct etm_drvdata *drvdata);\nint etm_read_alloc_trace_id(struct etm_drvdata *drvdata);\nvoid etm_release_trace_id(struct etm_drvdata *drvdata);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}