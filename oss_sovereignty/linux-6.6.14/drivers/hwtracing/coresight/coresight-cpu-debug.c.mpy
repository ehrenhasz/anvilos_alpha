{
  "module_name": "coresight-cpu-debug.c",
  "hash_id": "e0934847c27903fdbe0c79d5211998340df6049c37874f41777e04b573c249f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/coresight/coresight-cpu-debug.c",
  "human_readable_source": "\n \n#include <linux/amba/bus.h>\n#include <linux/coresight.h>\n#include <linux/cpu.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/panic_notifier.h>\n#include <linux/pm_qos.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#include \"coresight-priv.h\"\n\n#define EDPCSR\t\t\t\t0x0A0\n#define EDCIDSR\t\t\t\t0x0A4\n#define EDVIDSR\t\t\t\t0x0A8\n#define EDPCSR_HI\t\t\t0x0AC\n#define EDOSLAR\t\t\t\t0x300\n#define EDPRCR\t\t\t\t0x310\n#define EDPRSR\t\t\t\t0x314\n#define EDDEVID1\t\t\t0xFC4\n#define EDDEVID\t\t\t\t0xFC8\n\n#define EDPCSR_PROHIBITED\t\t0xFFFFFFFF\n\n \n#define EDPCSR_THUMB\t\t\tBIT(0)\n#define EDPCSR_ARM_INST_MASK\t\tGENMASK(31, 2)\n#define EDPCSR_THUMB_INST_MASK\t\tGENMASK(31, 1)\n\n \n#define EDPRCR_COREPURQ\t\t\tBIT(3)\n#define EDPRCR_CORENPDRQ\t\tBIT(0)\n\n \n#define EDPRSR_DLK\t\t\tBIT(6)\n#define EDPRSR_PU\t\t\tBIT(0)\n\n \n#define EDVIDSR_NS\t\t\tBIT(31)\n#define EDVIDSR_E2\t\t\tBIT(30)\n#define EDVIDSR_E3\t\t\tBIT(29)\n#define EDVIDSR_HV\t\t\tBIT(28)\n#define EDVIDSR_VMID\t\t\tGENMASK(7, 0)\n\n \n#define EDDEVID1_PCSR_OFFSET_MASK\tGENMASK(3, 0)\n#define EDDEVID1_PCSR_OFFSET_INS_SET\t(0x0)\n#define EDDEVID1_PCSR_NO_OFFSET_DIS_AARCH32\t(0x2)\n\n \n#define EDDEVID_PCSAMPLE_MODE\t\tGENMASK(3, 0)\n#define EDDEVID_IMPL_EDPCSR\t\t(0x1)\n#define EDDEVID_IMPL_EDPCSR_EDCIDSR\t(0x2)\n#define EDDEVID_IMPL_FULL\t\t(0x3)\n\n#define DEBUG_WAIT_SLEEP\t\t1000\n#define DEBUG_WAIT_TIMEOUT\t\t32000\n\nstruct debug_drvdata {\n\tvoid __iomem\t*base;\n\tstruct device\t*dev;\n\tint\t\tcpu;\n\n\tbool\t\tedpcsr_present;\n\tbool\t\tedcidsr_present;\n\tbool\t\tedvidsr_present;\n\tbool\t\tpc_has_offset;\n\n\tu32\t\tedpcsr;\n\tu32\t\tedpcsr_hi;\n\tu32\t\tedprsr;\n\tu32\t\tedvidsr;\n\tu32\t\tedcidsr;\n};\n\nstatic DEFINE_MUTEX(debug_lock);\nstatic DEFINE_PER_CPU(struct debug_drvdata *, debug_drvdata);\nstatic int debug_count;\nstatic struct dentry *debug_debugfs_dir;\n\nstatic bool debug_enable = IS_ENABLED(CONFIG_CORESIGHT_CPU_DEBUG_DEFAULT_ON);\nmodule_param_named(enable, debug_enable, bool, 0600);\nMODULE_PARM_DESC(enable, \"Control to enable coresight CPU debug functionality\");\n\nstatic void debug_os_unlock(struct debug_drvdata *drvdata)\n{\n\t \n\twritel_relaxed(0x0, drvdata->base + EDOSLAR);\n\n\t \n\twmb();\n}\n\n \nstatic bool debug_access_permitted(struct debug_drvdata *drvdata)\n{\n\t \n\tif (!(drvdata->edprsr & EDPRSR_PU))\n\t\treturn false;\n\n\t \n\tif (drvdata->edprsr & EDPRSR_DLK)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void debug_force_cpu_powered_up(struct debug_drvdata *drvdata)\n{\n\tu32 edprcr;\n\ntry_again:\n\n\t \n\tedprcr = readl_relaxed(drvdata->base + EDPRCR);\n\tedprcr |= EDPRCR_COREPURQ;\n\twritel_relaxed(edprcr, drvdata->base + EDPRCR);\n\n\t \n\tif (readx_poll_timeout_atomic(readl_relaxed, drvdata->base + EDPRSR,\n\t\t\tdrvdata->edprsr, (drvdata->edprsr & EDPRSR_PU),\n\t\t\tDEBUG_WAIT_SLEEP, DEBUG_WAIT_TIMEOUT)) {\n\t\t \n\t\tdev_err(drvdata->dev, \"%s: power up request for CPU%d failed\\n\",\n\t\t\t__func__, drvdata->cpu);\n\t\treturn;\n\t}\n\n\t \n\tedprcr = readl_relaxed(drvdata->base + EDPRCR);\n\tedprcr |= EDPRCR_COREPURQ | EDPRCR_CORENPDRQ;\n\twritel_relaxed(edprcr, drvdata->base + EDPRCR);\n\n\tdrvdata->edprsr = readl_relaxed(drvdata->base + EDPRSR);\n\n\t \n\tif (unlikely(!(drvdata->edprsr & EDPRSR_PU)))\n\t\tgoto try_again;\n}\n\nstatic void debug_read_regs(struct debug_drvdata *drvdata)\n{\n\tu32 save_edprcr;\n\n\tCS_UNLOCK(drvdata->base);\n\n\t \n\tdebug_os_unlock(drvdata);\n\n\t \n\tsave_edprcr = readl_relaxed(drvdata->base + EDPRCR);\n\n\t \n\tdebug_force_cpu_powered_up(drvdata);\n\n\tif (!debug_access_permitted(drvdata))\n\t\tgoto out;\n\n\tdrvdata->edpcsr = readl_relaxed(drvdata->base + EDPCSR);\n\n\t \n\tif (drvdata->edpcsr == EDPCSR_PROHIBITED)\n\t\tgoto out;\n\n\t \n\tif (IS_ENABLED(CONFIG_64BIT))\n\t\tdrvdata->edpcsr_hi = readl_relaxed(drvdata->base + EDPCSR_HI);\n\n\tif (drvdata->edcidsr_present)\n\t\tdrvdata->edcidsr = readl_relaxed(drvdata->base + EDCIDSR);\n\n\tif (drvdata->edvidsr_present)\n\t\tdrvdata->edvidsr = readl_relaxed(drvdata->base + EDVIDSR);\n\nout:\n\t \n\twritel_relaxed(save_edprcr, drvdata->base + EDPRCR);\n\n\tCS_LOCK(drvdata->base);\n}\n\n#ifdef CONFIG_64BIT\nstatic unsigned long debug_adjust_pc(struct debug_drvdata *drvdata)\n{\n\treturn (unsigned long)drvdata->edpcsr_hi << 32 |\n\t       (unsigned long)drvdata->edpcsr;\n}\n#else\nstatic unsigned long debug_adjust_pc(struct debug_drvdata *drvdata)\n{\n\tunsigned long arm_inst_offset = 0, thumb_inst_offset = 0;\n\tunsigned long pc;\n\n\tpc = (unsigned long)drvdata->edpcsr;\n\n\tif (drvdata->pc_has_offset) {\n\t\tarm_inst_offset = 8;\n\t\tthumb_inst_offset = 4;\n\t}\n\n\t \n\tif (pc & EDPCSR_THUMB) {\n\t\tpc = (pc & EDPCSR_THUMB_INST_MASK) - thumb_inst_offset;\n\t\treturn pc;\n\t}\n\n\t \n\tif (pc & BIT(1))\n\t\tdev_emerg(drvdata->dev,\n\t\t\t  \"Instruction offset is implementation defined\\n\");\n\telse\n\t\tpc = (pc & EDPCSR_ARM_INST_MASK) - arm_inst_offset;\n\n\treturn pc;\n}\n#endif\n\nstatic void debug_dump_regs(struct debug_drvdata *drvdata)\n{\n\tstruct device *dev = drvdata->dev;\n\tunsigned long pc;\n\n\tdev_emerg(dev, \" EDPRSR:  %08x (Power:%s DLK:%s)\\n\",\n\t\t  drvdata->edprsr,\n\t\t  drvdata->edprsr & EDPRSR_PU ? \"On\" : \"Off\",\n\t\t  drvdata->edprsr & EDPRSR_DLK ? \"Lock\" : \"Unlock\");\n\n\tif (!debug_access_permitted(drvdata)) {\n\t\tdev_emerg(dev, \"No permission to access debug registers!\\n\");\n\t\treturn;\n\t}\n\n\tif (drvdata->edpcsr == EDPCSR_PROHIBITED) {\n\t\tdev_emerg(dev, \"CPU is in Debug state or profiling is prohibited!\\n\");\n\t\treturn;\n\t}\n\n\tpc = debug_adjust_pc(drvdata);\n\tdev_emerg(dev, \" EDPCSR:  %pS\\n\", (void *)pc);\n\n\tif (drvdata->edcidsr_present)\n\t\tdev_emerg(dev, \" EDCIDSR: %08x\\n\", drvdata->edcidsr);\n\n\tif (drvdata->edvidsr_present)\n\t\tdev_emerg(dev, \" EDVIDSR: %08x (State:%s Mode:%s Width:%dbits VMID:%x)\\n\",\n\t\t\t  drvdata->edvidsr,\n\t\t\t  drvdata->edvidsr & EDVIDSR_NS ?\n\t\t\t  \"Non-secure\" : \"Secure\",\n\t\t\t  drvdata->edvidsr & EDVIDSR_E3 ? \"EL3\" :\n\t\t\t\t(drvdata->edvidsr & EDVIDSR_E2 ?\n\t\t\t\t \"EL2\" : \"EL1/0\"),\n\t\t\t  drvdata->edvidsr & EDVIDSR_HV ? 64 : 32,\n\t\t\t  drvdata->edvidsr & (u32)EDVIDSR_VMID);\n}\n\nstatic void debug_init_arch_data(void *info)\n{\n\tstruct debug_drvdata *drvdata = info;\n\tu32 mode, pcsr_offset;\n\tu32 eddevid, eddevid1;\n\n\tCS_UNLOCK(drvdata->base);\n\n\t \n\teddevid  = readl_relaxed(drvdata->base + EDDEVID);\n\teddevid1 = readl_relaxed(drvdata->base + EDDEVID1);\n\n\tCS_LOCK(drvdata->base);\n\n\t \n\tmode = eddevid & EDDEVID_PCSAMPLE_MODE;\n\tpcsr_offset = eddevid1 & EDDEVID1_PCSR_OFFSET_MASK;\n\n\tdrvdata->edpcsr_present  = false;\n\tdrvdata->edcidsr_present = false;\n\tdrvdata->edvidsr_present = false;\n\tdrvdata->pc_has_offset   = false;\n\n\tswitch (mode) {\n\tcase EDDEVID_IMPL_FULL:\n\t\tdrvdata->edvidsr_present = true;\n\t\tfallthrough;\n\tcase EDDEVID_IMPL_EDPCSR_EDCIDSR:\n\t\tdrvdata->edcidsr_present = true;\n\t\tfallthrough;\n\tcase EDDEVID_IMPL_EDPCSR:\n\t\t \n\t\tdrvdata->edpcsr_present =\n\t\t\t((IS_ENABLED(CONFIG_64BIT) && pcsr_offset != 0) ||\n\t\t\t (pcsr_offset != EDDEVID1_PCSR_NO_OFFSET_DIS_AARCH32));\n\n\t\tdrvdata->pc_has_offset =\n\t\t\t(pcsr_offset == EDDEVID1_PCSR_OFFSET_INS_SET);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic int debug_notifier_call(struct notifier_block *self,\n\t\t\t       unsigned long v, void *p)\n{\n\tint cpu;\n\tstruct debug_drvdata *drvdata;\n\n\t \n\tif (!mutex_trylock(&debug_lock))\n\t\treturn NOTIFY_DONE;\n\n\tif (!debug_enable)\n\t\tgoto skip_dump;\n\n\tpr_emerg(\"ARM external debug module:\\n\");\n\n\tfor_each_possible_cpu(cpu) {\n\t\tdrvdata = per_cpu(debug_drvdata, cpu);\n\t\tif (!drvdata)\n\t\t\tcontinue;\n\n\t\tdev_emerg(drvdata->dev, \"CPU[%d]:\\n\", drvdata->cpu);\n\n\t\tdebug_read_regs(drvdata);\n\t\tdebug_dump_regs(drvdata);\n\t}\n\nskip_dump:\n\tmutex_unlock(&debug_lock);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block debug_notifier = {\n\t.notifier_call = debug_notifier_call,\n};\n\nstatic int debug_enable_func(void)\n{\n\tstruct debug_drvdata *drvdata;\n\tint cpu, ret = 0;\n\tcpumask_t mask;\n\n\t \n\tcpumask_clear(&mask);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tdrvdata = per_cpu(debug_drvdata, cpu);\n\t\tif (!drvdata)\n\t\t\tcontinue;\n\n\t\tret = pm_runtime_get_sync(drvdata->dev);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\telse\n\t\t\tcpumask_set_cpu(cpu, &mask);\n\t}\n\n\treturn 0;\n\nerr:\n\t \n\tfor_each_cpu(cpu, &mask) {\n\t\tdrvdata = per_cpu(debug_drvdata, cpu);\n\t\tpm_runtime_put_noidle(drvdata->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int debug_disable_func(void)\n{\n\tstruct debug_drvdata *drvdata;\n\tint cpu, ret, err = 0;\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tdrvdata = per_cpu(debug_drvdata, cpu);\n\t\tif (!drvdata)\n\t\t\tcontinue;\n\n\t\tret = pm_runtime_put(drvdata->dev);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t}\n\n\treturn err;\n}\n\nstatic ssize_t debug_func_knob_write(struct file *f,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tu8 val;\n\tint ret;\n\n\tret = kstrtou8_from_user(buf, count, 2, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&debug_lock);\n\n\tif (val == debug_enable)\n\t\tgoto out;\n\n\tif (val)\n\t\tret = debug_enable_func();\n\telse\n\t\tret = debug_disable_func();\n\n\tif (ret) {\n\t\tpr_err(\"%s: unable to %s debug function: %d\\n\",\n\t\t       __func__, val ? \"enable\" : \"disable\", ret);\n\t\tgoto err;\n\t}\n\n\tdebug_enable = val;\nout:\n\tret = count;\nerr:\n\tmutex_unlock(&debug_lock);\n\treturn ret;\n}\n\nstatic ssize_t debug_func_knob_read(struct file *f,\n\t\tchar __user *ubuf, size_t count, loff_t *ppos)\n{\n\tssize_t ret;\n\tchar buf[3];\n\n\tmutex_lock(&debug_lock);\n\tsnprintf(buf, sizeof(buf), \"%d\\n\", debug_enable);\n\tmutex_unlock(&debug_lock);\n\n\tret = simple_read_from_buffer(ubuf, count, ppos, buf, sizeof(buf));\n\treturn ret;\n}\n\nstatic const struct file_operations debug_func_knob_fops = {\n\t.open\t= simple_open,\n\t.read\t= debug_func_knob_read,\n\t.write\t= debug_func_knob_write,\n};\n\nstatic int debug_func_init(void)\n{\n\tint ret;\n\n\t \n\tdebug_debugfs_dir = debugfs_create_dir(\"coresight_cpu_debug\", NULL);\n\tdebugfs_create_file(\"enable\", 0644, debug_debugfs_dir, NULL,\n\t\t\t    &debug_func_knob_fops);\n\n\t \n\tret = atomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t\t     &debug_notifier);\n\tif (ret) {\n\t\tpr_err(\"%s: unable to register notifier: %d\\n\",\n\t\t       __func__, ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tdebugfs_remove_recursive(debug_debugfs_dir);\n\treturn ret;\n}\n\nstatic void debug_func_exit(void)\n{\n\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t &debug_notifier);\n\tdebugfs_remove_recursive(debug_debugfs_dir);\n}\n\nstatic int debug_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tvoid __iomem *base;\n\tstruct device *dev = &adev->dev;\n\tstruct debug_drvdata *drvdata;\n\tstruct resource *res = &adev->res;\n\tint ret;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->cpu = coresight_get_cpu(dev);\n\tif (drvdata->cpu < 0)\n\t\treturn drvdata->cpu;\n\n\tif (per_cpu(debug_drvdata, drvdata->cpu)) {\n\t\tdev_err(dev, \"CPU%d drvdata has already been initialized\\n\",\n\t\t\tdrvdata->cpu);\n\t\treturn -EBUSY;\n\t}\n\n\tdrvdata->dev = &adev->dev;\n\tamba_set_drvdata(adev, drvdata);\n\n\t \n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdrvdata->base = base;\n\n\tcpus_read_lock();\n\tper_cpu(debug_drvdata, drvdata->cpu) = drvdata;\n\tret = smp_call_function_single(drvdata->cpu, debug_init_arch_data,\n\t\t\t\t       drvdata, 1);\n\tcpus_read_unlock();\n\n\tif (ret) {\n\t\tdev_err(dev, \"CPU%d debug arch init failed\\n\", drvdata->cpu);\n\t\tgoto err;\n\t}\n\n\tif (!drvdata->edpcsr_present) {\n\t\tdev_err(dev, \"CPU%d sample-based profiling isn't implemented\\n\",\n\t\t\tdrvdata->cpu);\n\t\tret = -ENXIO;\n\t\tgoto err;\n\t}\n\n\tif (!debug_count++) {\n\t\tret = debug_func_init();\n\t\tif (ret)\n\t\t\tgoto err_func_init;\n\t}\n\n\tmutex_lock(&debug_lock);\n\t \n\tif (!debug_enable)\n\t\tpm_runtime_put(dev);\n\tmutex_unlock(&debug_lock);\n\n\tdev_info(dev, \"Coresight debug-CPU%d initialized\\n\", drvdata->cpu);\n\treturn 0;\n\nerr_func_init:\n\tdebug_count--;\nerr:\n\tper_cpu(debug_drvdata, drvdata->cpu) = NULL;\n\treturn ret;\n}\n\nstatic void debug_remove(struct amba_device *adev)\n{\n\tstruct device *dev = &adev->dev;\n\tstruct debug_drvdata *drvdata = amba_get_drvdata(adev);\n\n\tper_cpu(debug_drvdata, drvdata->cpu) = NULL;\n\n\tmutex_lock(&debug_lock);\n\t \n\tif (debug_enable)\n\t\tpm_runtime_put(dev);\n\tmutex_unlock(&debug_lock);\n\n\tif (!--debug_count)\n\t\tdebug_func_exit();\n}\n\nstatic const struct amba_cs_uci_id uci_id_debug[] = {\n\t{\n\t\t \n\t\t.devarch\t= 0x47706a15,\n\t\t.devarch_mask\t= 0xfff0ffff,\n\t\t.devtype\t= 0x00000015,\n\t}\n};\n\nstatic const struct amba_id debug_ids[] = {\n\tCS_AMBA_ID(0x000bbd03),\t\t\t\t \n\tCS_AMBA_ID(0x000bbd07),\t\t\t\t \n\tCS_AMBA_ID(0x000bbd08),\t\t\t\t \n\tCS_AMBA_ID(0x000bbd09),\t\t\t\t \n\tCS_AMBA_UCI_ID(0x000f0205, uci_id_debug),\t \n\tCS_AMBA_UCI_ID(0x000f0211, uci_id_debug),\t \n\t{},\n};\n\nMODULE_DEVICE_TABLE(amba, debug_ids);\n\nstatic struct amba_driver debug_driver = {\n\t.drv = {\n\t\t.name   = \"coresight-cpu-debug\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= debug_probe,\n\t.remove\t\t= debug_remove,\n\t.id_table\t= debug_ids,\n};\n\nmodule_amba_driver(debug_driver);\n\nMODULE_AUTHOR(\"Leo Yan <leo.yan@linaro.org>\");\nMODULE_DESCRIPTION(\"ARM Coresight CPU Debug Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}