{
  "module_name": "p_sys-t.c",
  "hash_id": "9609b60b3199805d6785327be2b517cb1687bf42560e4eca6cd220eae34794f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/stm/p_sys-t.c",
  "human_readable_source": "\n \n\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/stm.h>\n#include \"stm.h\"\n\nenum sys_t_message_type {\n\tMIPI_SYST_TYPE_BUILD\t= 0,\n\tMIPI_SYST_TYPE_SHORT32,\n\tMIPI_SYST_TYPE_STRING,\n\tMIPI_SYST_TYPE_CATALOG,\n\tMIPI_SYST_TYPE_RAW\t= 6,\n\tMIPI_SYST_TYPE_SHORT64,\n\tMIPI_SYST_TYPE_CLOCK,\n};\n\nenum sys_t_message_severity {\n\tMIPI_SYST_SEVERITY_MAX\t= 0,\n\tMIPI_SYST_SEVERITY_FATAL,\n\tMIPI_SYST_SEVERITY_ERROR,\n\tMIPI_SYST_SEVERITY_WARNING,\n\tMIPI_SYST_SEVERITY_INFO,\n\tMIPI_SYST_SEVERITY_USER1,\n\tMIPI_SYST_SEVERITY_USER2,\n\tMIPI_SYST_SEVERITY_DEBUG,\n};\n\nenum sys_t_message_build_subtype {\n\tMIPI_SYST_BUILD_ID_COMPACT32 = 0,\n\tMIPI_SYST_BUILD_ID_COMPACT64,\n\tMIPI_SYST_BUILD_ID_LONG,\n};\n\nenum sys_t_message_clock_subtype {\n\tMIPI_SYST_CLOCK_TRANSPORT_SYNC = 1,\n};\n\nenum sys_t_message_string_subtype {\n\tMIPI_SYST_STRING_GENERIC\t= 1,\n\tMIPI_SYST_STRING_FUNCTIONENTER,\n\tMIPI_SYST_STRING_FUNCTIONEXIT,\n\tMIPI_SYST_STRING_INVALIDPARAM\t= 5,\n\tMIPI_SYST_STRING_ASSERT\t\t= 7,\n\tMIPI_SYST_STRING_PRINTF_32\t= 11,\n\tMIPI_SYST_STRING_PRINTF_64\t= 12,\n};\n\n#define MIPI_SYST_TYPE(t)\t\t((u32)(MIPI_SYST_TYPE_ ## t))\n#define MIPI_SYST_SEVERITY(s)\t\t((u32)(MIPI_SYST_SEVERITY_ ## s) << 4)\n#define MIPI_SYST_OPT_LOC\t\tBIT(8)\n#define MIPI_SYST_OPT_LEN\t\tBIT(9)\n#define MIPI_SYST_OPT_CHK\t\tBIT(10)\n#define MIPI_SYST_OPT_TS\t\tBIT(11)\n#define MIPI_SYST_UNIT(u)\t\t((u32)(u) << 12)\n#define MIPI_SYST_ORIGIN(o)\t\t((u32)(o) << 16)\n#define MIPI_SYST_OPT_GUID\t\tBIT(23)\n#define MIPI_SYST_SUBTYPE(s)\t\t((u32)(MIPI_SYST_ ## s) << 24)\n#define MIPI_SYST_UNITLARGE(u)\t\t(MIPI_SYST_UNIT(u & 0xf) | \\\n\t\t\t\t\t MIPI_SYST_ORIGIN(u >> 4))\n#define MIPI_SYST_TYPES(t, s)\t\t(MIPI_SYST_TYPE(t) | \\\n\t\t\t\t\t MIPI_SYST_SUBTYPE(t ## _ ## s))\n\n#define DATA_HEADER\t(MIPI_SYST_TYPES(STRING, GENERIC)\t| \\\n\t\t\t MIPI_SYST_SEVERITY(INFO)\t\t| \\\n\t\t\t MIPI_SYST_OPT_GUID)\n\n#define CLOCK_SYNC_HEADER\t(MIPI_SYST_TYPES(CLOCK, TRANSPORT_SYNC)\t| \\\n\t\t\t\t MIPI_SYST_SEVERITY(MAX))\n\nstruct sys_t_policy_node {\n\tuuid_t\t\tuuid;\n\tbool\t\tdo_len;\n\tunsigned long\tts_interval;\n\tunsigned long\tclocksync_interval;\n};\n\nstruct sys_t_output {\n\tstruct sys_t_policy_node\tnode;\n\tunsigned long\tts_jiffies;\n\tunsigned long\tclocksync_jiffies;\n};\n\nstatic void sys_t_policy_node_init(void *priv)\n{\n\tstruct sys_t_policy_node *pn = priv;\n\n\tuuid_gen(&pn->uuid);\n}\n\nstatic int sys_t_output_open(void *priv, struct stm_output *output)\n{\n\tstruct sys_t_policy_node *pn = priv;\n\tstruct sys_t_output *opriv;\n\n\topriv = kzalloc(sizeof(*opriv), GFP_ATOMIC);\n\tif (!opriv)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&opriv->node, pn, sizeof(opriv->node));\n\toutput->pdrv_private = opriv;\n\n\treturn 0;\n}\n\nstatic void sys_t_output_close(struct stm_output *output)\n{\n\tkfree(output->pdrv_private);\n}\n\nstatic ssize_t sys_t_policy_uuid_show(struct config_item *item,\n\t\t\t\t      char *page)\n{\n\tstruct sys_t_policy_node *pn = to_pdrv_policy_node(item);\n\n\treturn sprintf(page, \"%pU\\n\", &pn->uuid);\n}\n\nstatic ssize_t\nsys_t_policy_uuid_store(struct config_item *item, const char *page,\n\t\t\tsize_t count)\n{\n\tstruct mutex *mutexp = &item->ci_group->cg_subsys->su_mutex;\n\tstruct sys_t_policy_node *pn = to_pdrv_policy_node(item);\n\tint ret;\n\n\tmutex_lock(mutexp);\n\tret = uuid_parse(page, &pn->uuid);\n\tmutex_unlock(mutexp);\n\n\treturn ret < 0 ? ret : count;\n}\n\nCONFIGFS_ATTR(sys_t_policy_, uuid);\n\nstatic ssize_t sys_t_policy_do_len_show(struct config_item *item,\n\t\t\t\t      char *page)\n{\n\tstruct sys_t_policy_node *pn = to_pdrv_policy_node(item);\n\n\treturn sprintf(page, \"%d\\n\", pn->do_len);\n}\n\nstatic ssize_t\nsys_t_policy_do_len_store(struct config_item *item, const char *page,\n\t\t\tsize_t count)\n{\n\tstruct mutex *mutexp = &item->ci_group->cg_subsys->su_mutex;\n\tstruct sys_t_policy_node *pn = to_pdrv_policy_node(item);\n\tint ret;\n\n\tmutex_lock(mutexp);\n\tret = kstrtobool(page, &pn->do_len);\n\tmutex_unlock(mutexp);\n\n\treturn ret ? ret : count;\n}\n\nCONFIGFS_ATTR(sys_t_policy_, do_len);\n\nstatic ssize_t sys_t_policy_ts_interval_show(struct config_item *item,\n\t\t\t\t\t     char *page)\n{\n\tstruct sys_t_policy_node *pn = to_pdrv_policy_node(item);\n\n\treturn sprintf(page, \"%u\\n\", jiffies_to_msecs(pn->ts_interval));\n}\n\nstatic ssize_t\nsys_t_policy_ts_interval_store(struct config_item *item, const char *page,\n\t\t\t       size_t count)\n{\n\tstruct mutex *mutexp = &item->ci_group->cg_subsys->su_mutex;\n\tstruct sys_t_policy_node *pn = to_pdrv_policy_node(item);\n\tunsigned int ms;\n\tint ret;\n\n\tmutex_lock(mutexp);\n\tret = kstrtouint(page, 10, &ms);\n\tmutex_unlock(mutexp);\n\n\tif (!ret) {\n\t\tpn->ts_interval = msecs_to_jiffies(ms);\n\t\treturn count;\n\t}\n\n\treturn ret;\n}\n\nCONFIGFS_ATTR(sys_t_policy_, ts_interval);\n\nstatic ssize_t sys_t_policy_clocksync_interval_show(struct config_item *item,\n\t\t\t\t\t\t    char *page)\n{\n\tstruct sys_t_policy_node *pn = to_pdrv_policy_node(item);\n\n\treturn sprintf(page, \"%u\\n\", jiffies_to_msecs(pn->clocksync_interval));\n}\n\nstatic ssize_t\nsys_t_policy_clocksync_interval_store(struct config_item *item,\n\t\t\t\t      const char *page, size_t count)\n{\n\tstruct mutex *mutexp = &item->ci_group->cg_subsys->su_mutex;\n\tstruct sys_t_policy_node *pn = to_pdrv_policy_node(item);\n\tunsigned int ms;\n\tint ret;\n\n\tmutex_lock(mutexp);\n\tret = kstrtouint(page, 10, &ms);\n\tmutex_unlock(mutexp);\n\n\tif (!ret) {\n\t\tpn->clocksync_interval = msecs_to_jiffies(ms);\n\t\treturn count;\n\t}\n\n\treturn ret;\n}\n\nCONFIGFS_ATTR(sys_t_policy_, clocksync_interval);\n\nstatic struct configfs_attribute *sys_t_policy_attrs[] = {\n\t&sys_t_policy_attr_uuid,\n\t&sys_t_policy_attr_do_len,\n\t&sys_t_policy_attr_ts_interval,\n\t&sys_t_policy_attr_clocksync_interval,\n\tNULL,\n};\n\nstatic inline bool sys_t_need_ts(struct sys_t_output *op)\n{\n\tif (op->node.ts_interval &&\n\t    time_after(jiffies, op->ts_jiffies + op->node.ts_interval)) {\n\t\top->ts_jiffies = jiffies;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool sys_t_need_clock_sync(struct sys_t_output *op)\n{\n\tif (op->node.clocksync_interval &&\n\t    time_after(jiffies,\n\t\t       op->clocksync_jiffies + op->node.clocksync_interval)) {\n\t\top->clocksync_jiffies = jiffies;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic ssize_t\nsys_t_clock_sync(struct stm_data *data, unsigned int m, unsigned int c)\n{\n\tu32 header = CLOCK_SYNC_HEADER;\n\tconst unsigned char nil = 0;\n\tu64 payload[2];  \n\tssize_t sz;\n\n\tsz = data->packet(data, m, c, STP_PACKET_DATA, STP_PACKET_TIMESTAMPED,\n\t\t\t  4, (u8 *)&header);\n\tif (sz <= 0)\n\t\treturn sz;\n\n\tpayload[0] = ktime_get_real_ns();\n\tpayload[1] = NSEC_PER_SEC;\n\tsz = stm_data_write(data, m, c, false, &payload, sizeof(payload));\n\tif (sz <= 0)\n\t\treturn sz;\n\n\tdata->packet(data, m, c, STP_PACKET_FLAG, 0, 0, &nil);\n\n\treturn sizeof(header) + sizeof(payload);\n}\n\nstatic ssize_t sys_t_write(struct stm_data *data, struct stm_output *output,\n\t\t\t   unsigned int chan, const char *buf, size_t count)\n{\n\tstruct sys_t_output *op = output->pdrv_private;\n\tunsigned int c = output->channel + chan;\n\tunsigned int m = output->master;\n\tconst unsigned char nil = 0;\n\tu32 header = DATA_HEADER;\n\tu8 uuid[UUID_SIZE];\n\tssize_t sz;\n\n\t \n\tif (!op)\n\t\treturn -EINVAL;\n\n\tif (sys_t_need_clock_sync(op)) {\n\t\tsz = sys_t_clock_sync(data, m, c);\n\t\tif (sz <= 0)\n\t\t\treturn sz;\n\t}\n\n\tif (op->node.do_len)\n\t\theader |= MIPI_SYST_OPT_LEN;\n\tif (sys_t_need_ts(op))\n\t\theader |= MIPI_SYST_OPT_TS;\n\n\t \n\t \n\t \n\tsz = data->packet(data, m, c, STP_PACKET_DATA, STP_PACKET_TIMESTAMPED,\n\t\t\t  4, (u8 *)&header);\n\tif (sz <= 0)\n\t\treturn sz;\n\n\t \n\texport_uuid(uuid, &op->node.uuid);\n\tsz = stm_data_write(data, m, c, false, uuid, sizeof(op->node.uuid));\n\tif (sz <= 0)\n\t\treturn sz;\n\n\t \n\tif (op->node.do_len) {\n\t\tu16 length = count;\n\n\t\tsz = data->packet(data, m, c, STP_PACKET_DATA, 0, 2,\n\t\t\t\t  (u8 *)&length);\n\t\tif (sz <= 0)\n\t\t\treturn sz;\n\t}\n\n\t \n\tif (header & MIPI_SYST_OPT_TS) {\n\t\tu64 ts = ktime_get_real_ns();\n\n\t\tsz = stm_data_write(data, m, c, false, &ts, sizeof(ts));\n\t\tif (sz <= 0)\n\t\t\treturn sz;\n\t}\n\n\t \n\tsz = stm_data_write(data, m, c, false, buf, count);\n\tif (sz > 0)\n\t\tdata->packet(data, m, c, STP_PACKET_FLAG, 0, 0, &nil);\n\n\treturn sz;\n}\n\nstatic const struct stm_protocol_driver sys_t_pdrv = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"p_sys-t\",\n\t.priv_sz\t\t= sizeof(struct sys_t_policy_node),\n\t.write\t\t\t= sys_t_write,\n\t.policy_attr\t\t= sys_t_policy_attrs,\n\t.policy_node_init\t= sys_t_policy_node_init,\n\t.output_open\t\t= sys_t_output_open,\n\t.output_close\t\t= sys_t_output_close,\n};\n\nstatic int sys_t_stm_init(void)\n{\n\treturn stm_register_protocol(&sys_t_pdrv);\n}\n\nstatic void sys_t_stm_exit(void)\n{\n\tstm_unregister_protocol(&sys_t_pdrv);\n}\n\nmodule_init(sys_t_stm_init);\nmodule_exit(sys_t_stm_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MIPI SyS-T STM framing protocol driver\");\nMODULE_AUTHOR(\"Alexander Shishkin <alexander.shishkin@linux.intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}