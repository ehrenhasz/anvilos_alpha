{
  "module_name": "core.c",
  "hash_id": "3bf12f445a44923f6049518d5e0cd09330b3c6c34e1ade4c0285c72940dbe1f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/stm/core.c",
  "human_readable_source": "\n \n\n#include <linux/pm_runtime.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/compat.h>\n#include <linux/kdev_t.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/stm.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include \"stm.h\"\n\n#include <uapi/linux/stm.h>\n\nstatic unsigned int stm_core_up;\n\n \nstatic struct srcu_struct stm_source_srcu;\n\nstatic ssize_t masters_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct stm_device *stm = to_stm_device(dev);\n\tint ret;\n\n\tret = sprintf(buf, \"%u %u\\n\", stm->data->sw_start, stm->data->sw_end);\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RO(masters);\n\nstatic ssize_t channels_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct stm_device *stm = to_stm_device(dev);\n\tint ret;\n\n\tret = sprintf(buf, \"%u\\n\", stm->data->sw_nchannels);\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RO(channels);\n\nstatic ssize_t hw_override_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct stm_device *stm = to_stm_device(dev);\n\tint ret;\n\n\tret = sprintf(buf, \"%u\\n\", stm->data->hw_override);\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RO(hw_override);\n\nstatic struct attribute *stm_attrs[] = {\n\t&dev_attr_masters.attr,\n\t&dev_attr_channels.attr,\n\t&dev_attr_hw_override.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(stm);\n\nstatic struct class stm_class = {\n\t.name\t\t= \"stm\",\n\t.dev_groups\t= stm_groups,\n};\n\n \nstruct stm_device *stm_find_device(const char *buf)\n{\n\tstruct stm_device *stm;\n\tstruct device *dev;\n\n\tif (!stm_core_up)\n\t\treturn NULL;\n\n\tdev = class_find_device_by_name(&stm_class, buf);\n\tif (!dev)\n\t\treturn NULL;\n\n\tstm = to_stm_device(dev);\n\tif (!try_module_get(stm->owner)) {\n\t\t \n\t\tput_device(dev);\n\t\treturn NULL;\n\t}\n\n\treturn stm;\n}\n\n \nvoid stm_put_device(struct stm_device *stm)\n{\n\tmodule_put(stm->owner);\n\tput_device(&stm->dev);\n}\n\n \n\n#define __stm_master(_s, _m)\t\t\t\t\\\n\t((_s)->masters[(_m) - (_s)->data->sw_start])\n\nstatic inline struct stp_master *\nstm_master(struct stm_device *stm, unsigned int idx)\n{\n\tif (idx < stm->data->sw_start || idx > stm->data->sw_end)\n\t\treturn NULL;\n\n\treturn __stm_master(stm, idx);\n}\n\nstatic int stp_master_alloc(struct stm_device *stm, unsigned int idx)\n{\n\tstruct stp_master *master;\n\n\tmaster = kzalloc(struct_size(master, chan_map,\n\t\t\t\t     BITS_TO_LONGS(stm->data->sw_nchannels)),\n\t\t\t GFP_ATOMIC);\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tmaster->nr_free = stm->data->sw_nchannels;\n\t__stm_master(stm, idx) = master;\n\n\treturn 0;\n}\n\nstatic void stp_master_free(struct stm_device *stm, unsigned int idx)\n{\n\tstruct stp_master *master = stm_master(stm, idx);\n\n\tif (!master)\n\t\treturn;\n\n\t__stm_master(stm, idx) = NULL;\n\tkfree(master);\n}\n\nstatic void stm_output_claim(struct stm_device *stm, struct stm_output *output)\n{\n\tstruct stp_master *master = stm_master(stm, output->master);\n\n\tlockdep_assert_held(&stm->mc_lock);\n\tlockdep_assert_held(&output->lock);\n\n\tif (WARN_ON_ONCE(master->nr_free < output->nr_chans))\n\t\treturn;\n\n\tbitmap_allocate_region(&master->chan_map[0], output->channel,\n\t\t\t       ilog2(output->nr_chans));\n\n\tmaster->nr_free -= output->nr_chans;\n}\n\nstatic void\nstm_output_disclaim(struct stm_device *stm, struct stm_output *output)\n{\n\tstruct stp_master *master = stm_master(stm, output->master);\n\n\tlockdep_assert_held(&stm->mc_lock);\n\tlockdep_assert_held(&output->lock);\n\n\tbitmap_release_region(&master->chan_map[0], output->channel,\n\t\t\t      ilog2(output->nr_chans));\n\n\tmaster->nr_free += output->nr_chans;\n\toutput->nr_chans = 0;\n}\n\n \nstatic int find_free_channels(unsigned long *bitmap, unsigned int start,\n\t\t\t      unsigned int end, unsigned int width)\n{\n\tunsigned int pos;\n\tint i;\n\n\tfor (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {\n\t\tpos = find_next_zero_bit(bitmap, end + 1, pos);\n\t\tif (pos + width > end + 1)\n\t\t\tbreak;\n\n\t\tif (pos & (width - 1))\n\t\t\tcontinue;\n\n\t\tfor (i = 1; i < width && !test_bit(pos + i, bitmap); i++)\n\t\t\t;\n\t\tif (i == width)\n\t\t\treturn pos;\n\n\t\t \n\t\tpos += i;\n\t}\n\n\treturn -1;\n}\n\nstatic int\nstm_find_master_chan(struct stm_device *stm, unsigned int width,\n\t\t     unsigned int *mstart, unsigned int mend,\n\t\t     unsigned int *cstart, unsigned int cend)\n{\n\tstruct stp_master *master;\n\tunsigned int midx;\n\tint pos, err;\n\n\tfor (midx = *mstart; midx <= mend; midx++) {\n\t\tif (!stm_master(stm, midx)) {\n\t\t\terr = stp_master_alloc(stm, midx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tmaster = stm_master(stm, midx);\n\n\t\tif (!master->nr_free)\n\t\t\tcontinue;\n\n\t\tpos = find_free_channels(master->chan_map, *cstart, cend,\n\t\t\t\t\t width);\n\t\tif (pos < 0)\n\t\t\tcontinue;\n\n\t\t*mstart = midx;\n\t\t*cstart = pos;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}\n\nstatic int stm_output_assign(struct stm_device *stm, unsigned int width,\n\t\t\t     struct stp_policy_node *policy_node,\n\t\t\t     struct stm_output *output)\n{\n\tunsigned int midx, cidx, mend, cend;\n\tint ret = -EINVAL;\n\n\tif (width > stm->data->sw_nchannels)\n\t\treturn -EINVAL;\n\n\t \n\tif (WARN_ON_ONCE(!policy_node))\n\t\treturn -EINVAL;\n\n\t \n\tstp_policy_node_get_ranges(policy_node, &midx, &mend, &cidx, &cend);\n\n\tspin_lock(&stm->mc_lock);\n\tspin_lock(&output->lock);\n\t \n\tif (WARN_ON_ONCE(output->nr_chans))\n\t\tgoto unlock;\n\n\tret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\toutput->master = midx;\n\toutput->channel = cidx;\n\toutput->nr_chans = width;\n\tif (stm->pdrv->output_open) {\n\t\tvoid *priv = stp_policy_node_priv(policy_node);\n\n\t\tif (WARN_ON_ONCE(!priv))\n\t\t\tgoto unlock;\n\n\t\t \n\t\tret = stm->pdrv->output_open(priv, output);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tstm_output_claim(stm, output);\n\tdev_dbg(&stm->dev, \"assigned %u:%u (+%u)\\n\", midx, cidx, width);\n\n\tret = 0;\nunlock:\n\tif (ret)\n\t\toutput->nr_chans = 0;\n\n\tspin_unlock(&output->lock);\n\tspin_unlock(&stm->mc_lock);\n\n\treturn ret;\n}\n\nstatic void stm_output_free(struct stm_device *stm, struct stm_output *output)\n{\n\tspin_lock(&stm->mc_lock);\n\tspin_lock(&output->lock);\n\tif (output->nr_chans)\n\t\tstm_output_disclaim(stm, output);\n\tif (stm->pdrv && stm->pdrv->output_close)\n\t\tstm->pdrv->output_close(output);\n\tspin_unlock(&output->lock);\n\tspin_unlock(&stm->mc_lock);\n}\n\nstatic void stm_output_init(struct stm_output *output)\n{\n\tspin_lock_init(&output->lock);\n}\n\nstatic int major_match(struct device *dev, const void *data)\n{\n\tunsigned int major = *(unsigned int *)data;\n\n\treturn MAJOR(dev->devt) == major;\n}\n\n \nstatic struct list_head stm_pdrv_head;\nstatic struct mutex stm_pdrv_mutex;\n\nstruct stm_pdrv_entry {\n\tstruct list_head\t\t\tentry;\n\tconst struct stm_protocol_driver\t*pdrv;\n\tconst struct config_item_type\t\t*node_type;\n};\n\nstatic const struct stm_pdrv_entry *\n__stm_lookup_protocol(const char *name)\n{\n\tstruct stm_pdrv_entry *pe;\n\n\t \n\tif (!name || !*name)\n\t\tname = \"p_basic\";\n\n\tlist_for_each_entry(pe, &stm_pdrv_head, entry) {\n\t\tif (!strcmp(name, pe->pdrv->name))\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}\n\nint stm_register_protocol(const struct stm_protocol_driver *pdrv)\n{\n\tstruct stm_pdrv_entry *pe = NULL;\n\tint ret = -ENOMEM;\n\n\tmutex_lock(&stm_pdrv_mutex);\n\n\tif (__stm_lookup_protocol(pdrv->name)) {\n\t\tret = -EEXIST;\n\t\tgoto unlock;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\tif (!pe)\n\t\tgoto unlock;\n\n\tif (pdrv->policy_attr) {\n\t\tpe->node_type = get_policy_node_type(pdrv->policy_attr);\n\t\tif (!pe->node_type)\n\t\t\tgoto unlock;\n\t}\n\n\tlist_add_tail(&pe->entry, &stm_pdrv_head);\n\tpe->pdrv = pdrv;\n\n\tret = 0;\nunlock:\n\tmutex_unlock(&stm_pdrv_mutex);\n\n\tif (ret)\n\t\tkfree(pe);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stm_register_protocol);\n\nvoid stm_unregister_protocol(const struct stm_protocol_driver *pdrv)\n{\n\tstruct stm_pdrv_entry *pe, *iter;\n\n\tmutex_lock(&stm_pdrv_mutex);\n\n\tlist_for_each_entry_safe(pe, iter, &stm_pdrv_head, entry) {\n\t\tif (pe->pdrv == pdrv) {\n\t\t\tlist_del(&pe->entry);\n\n\t\t\tif (pe->node_type) {\n\t\t\t\tkfree(pe->node_type->ct_attrs);\n\t\t\t\tkfree(pe->node_type);\n\t\t\t}\n\t\t\tkfree(pe);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&stm_pdrv_mutex);\n}\nEXPORT_SYMBOL_GPL(stm_unregister_protocol);\n\nstatic bool stm_get_protocol(const struct stm_protocol_driver *pdrv)\n{\n\treturn try_module_get(pdrv->owner);\n}\n\nvoid stm_put_protocol(const struct stm_protocol_driver *pdrv)\n{\n\tmodule_put(pdrv->owner);\n}\n\nint stm_lookup_protocol(const char *name,\n\t\t\tconst struct stm_protocol_driver **pdrv,\n\t\t\tconst struct config_item_type **node_type)\n{\n\tconst struct stm_pdrv_entry *pe;\n\n\tmutex_lock(&stm_pdrv_mutex);\n\n\tpe = __stm_lookup_protocol(name);\n\tif (pe && pe->pdrv && stm_get_protocol(pe->pdrv)) {\n\t\t*pdrv = pe->pdrv;\n\t\t*node_type = pe->node_type;\n\t}\n\n\tmutex_unlock(&stm_pdrv_mutex);\n\n\treturn pe ? 0 : -ENOENT;\n}\n\nstatic int stm_char_open(struct inode *inode, struct file *file)\n{\n\tstruct stm_file *stmf;\n\tstruct device *dev;\n\tunsigned int major = imajor(inode);\n\tint err = -ENOMEM;\n\n\tdev = class_find_device(&stm_class, NULL, &major, major_match);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tstmf = kzalloc(sizeof(*stmf), GFP_KERNEL);\n\tif (!stmf)\n\t\tgoto err_put_device;\n\n\terr = -ENODEV;\n\tstm_output_init(&stmf->output);\n\tstmf->stm = to_stm_device(dev);\n\n\tif (!try_module_get(stmf->stm->owner))\n\t\tgoto err_free;\n\n\tfile->private_data = stmf;\n\n\treturn nonseekable_open(inode, file);\n\nerr_free:\n\tkfree(stmf);\nerr_put_device:\n\t \n\tput_device(dev);\n\n\treturn err;\n}\n\nstatic int stm_char_release(struct inode *inode, struct file *file)\n{\n\tstruct stm_file *stmf = file->private_data;\n\tstruct stm_device *stm = stmf->stm;\n\n\tif (stm->data->unlink)\n\t\tstm->data->unlink(stm->data, stmf->output.master,\n\t\t\t\t  stmf->output.channel);\n\n\tstm_output_free(stm, &stmf->output);\n\n\t \n\tstm_put_device(stm);\n\tkfree(stmf);\n\n\treturn 0;\n}\n\nstatic int\nstm_assign_first_policy(struct stm_device *stm, struct stm_output *output,\n\t\t\tchar **ids, unsigned int width)\n{\n\tstruct stp_policy_node *pn;\n\tint err, n;\n\n\t \n\tfor (n = 0, pn = NULL; ids[n] && !pn; n++)\n\t\tpn = stp_policy_node_lookup(stm, ids[n]);\n\n\tif (!pn)\n\t\treturn -EINVAL;\n\n\terr = stm_output_assign(stm, width, pn, output);\n\n\tstp_policy_node_put(pn);\n\n\treturn err;\n}\n\n \nssize_t notrace stm_data_write(struct stm_data *data, unsigned int m,\n\t\t\t       unsigned int c, bool ts_first, const void *buf,\n\t\t\t       size_t count)\n{\n\tunsigned int flags = ts_first ? STP_PACKET_TIMESTAMPED : 0;\n\tssize_t sz;\n\tsize_t pos;\n\n\tfor (pos = 0, sz = 0; pos < count; pos += sz) {\n\t\tsz = min_t(unsigned int, count - pos, 8);\n\t\tsz = data->packet(data, m, c, STP_PACKET_DATA, flags, sz,\n\t\t\t\t  &((u8 *)buf)[pos]);\n\t\tif (sz <= 0)\n\t\t\tbreak;\n\n\t\tif (ts_first) {\n\t\t\tflags = 0;\n\t\t\tts_first = false;\n\t\t}\n\t}\n\n\treturn sz < 0 ? sz : pos;\n}\nEXPORT_SYMBOL_GPL(stm_data_write);\n\nstatic ssize_t notrace\nstm_write(struct stm_device *stm, struct stm_output *output,\n\t  unsigned int chan, const char *buf, size_t count)\n{\n\tint err;\n\n\t \n\tif (!stm->pdrv)\n\t\treturn -ENODEV;\n\n\terr = stm->pdrv->write(stm->data, output, chan, buf, count);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn err;\n}\n\nstatic ssize_t stm_char_write(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct stm_file *stmf = file->private_data;\n\tstruct stm_device *stm = stmf->stm;\n\tchar *kbuf;\n\tint err;\n\n\tif (count + 1 > PAGE_SIZE)\n\t\tcount = PAGE_SIZE - 1;\n\n\t \n\tif (!stmf->output.nr_chans) {\n\t\tchar comm[sizeof(current->comm)];\n\t\tchar *ids[] = { comm, \"default\", NULL };\n\n\t\tget_task_comm(comm, current);\n\n\t\terr = stm_assign_first_policy(stmf->stm, &stmf->output, ids, 1);\n\t\t \n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tkbuf = kmalloc(count + 1, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\terr = copy_from_user(kbuf, buf, count);\n\tif (err) {\n\t\tkfree(kbuf);\n\t\treturn -EFAULT;\n\t}\n\n\tpm_runtime_get_sync(&stm->dev);\n\n\tcount = stm_write(stm, &stmf->output, 0, kbuf, count);\n\n\tpm_runtime_mark_last_busy(&stm->dev);\n\tpm_runtime_put_autosuspend(&stm->dev);\n\tkfree(kbuf);\n\n\treturn count;\n}\n\nstatic void stm_mmap_open(struct vm_area_struct *vma)\n{\n\tstruct stm_file *stmf = vma->vm_file->private_data;\n\tstruct stm_device *stm = stmf->stm;\n\n\tpm_runtime_get(&stm->dev);\n}\n\nstatic void stm_mmap_close(struct vm_area_struct *vma)\n{\n\tstruct stm_file *stmf = vma->vm_file->private_data;\n\tstruct stm_device *stm = stmf->stm;\n\n\tpm_runtime_mark_last_busy(&stm->dev);\n\tpm_runtime_put_autosuspend(&stm->dev);\n}\n\nstatic const struct vm_operations_struct stm_mmap_vmops = {\n\t.open\t= stm_mmap_open,\n\t.close\t= stm_mmap_close,\n};\n\nstatic int stm_char_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct stm_file *stmf = file->private_data;\n\tstruct stm_device *stm = stmf->stm;\n\tunsigned long size, phys;\n\n\tif (!stm->data->mmio_addr)\n\t\treturn -EOPNOTSUPP;\n\n\tif (vma->vm_pgoff)\n\t\treturn -EINVAL;\n\n\tsize = vma->vm_end - vma->vm_start;\n\n\tif (stmf->output.nr_chans * stm->data->sw_mmiosz != size)\n\t\treturn -EINVAL;\n\n\tphys = stm->data->mmio_addr(stm->data, stmf->output.master,\n\t\t\t\t    stmf->output.channel,\n\t\t\t\t    stmf->output.nr_chans);\n\n\tif (!phys)\n\t\treturn -EINVAL;\n\n\tpm_runtime_get_sync(&stm->dev);\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tvm_flags_set(vma, VM_IO | VM_DONTEXPAND | VM_DONTDUMP);\n\tvma->vm_ops = &stm_mmap_vmops;\n\tvm_iomap_memory(vma, phys, size);\n\n\treturn 0;\n}\n\nstatic int stm_char_policy_set_ioctl(struct stm_file *stmf, void __user *arg)\n{\n\tstruct stm_device *stm = stmf->stm;\n\tstruct stp_policy_id *id;\n\tchar *ids[] = { NULL, NULL };\n\tint ret = -EINVAL, wlimit = 1;\n\tu32 size;\n\n\tif (stmf->output.nr_chans)\n\t\treturn -EBUSY;\n\n\tif (copy_from_user(&size, arg, sizeof(size)))\n\t\treturn -EFAULT;\n\n\tif (size < sizeof(*id) || size >= PATH_MAX + sizeof(*id))\n\t\treturn -EINVAL;\n\n\t \n\tid = kzalloc(size + 1, GFP_KERNEL);\n\tif (!id)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(id, arg, size)) {\n\t\tret = -EFAULT;\n\t\tgoto err_free;\n\t}\n\n\tif (id->__reserved_0 || id->__reserved_1)\n\t\tgoto err_free;\n\n\tif (stm->data->sw_mmiosz)\n\t\twlimit = PAGE_SIZE / stm->data->sw_mmiosz;\n\n\tif (id->width < 1 || id->width > wlimit)\n\t\tgoto err_free;\n\n\tids[0] = id->id;\n\tret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,\n\t\t\t\t      id->width);\n\tif (ret)\n\t\tgoto err_free;\n\n\tif (stm->data->link)\n\t\tret = stm->data->link(stm->data, stmf->output.master,\n\t\t\t\t      stmf->output.channel);\n\n\tif (ret)\n\t\tstm_output_free(stmf->stm, &stmf->output);\n\nerr_free:\n\tkfree(id);\n\n\treturn ret;\n}\n\nstatic int stm_char_policy_get_ioctl(struct stm_file *stmf, void __user *arg)\n{\n\tstruct stp_policy_id id = {\n\t\t.size\t\t= sizeof(id),\n\t\t.master\t\t= stmf->output.master,\n\t\t.channel\t= stmf->output.channel,\n\t\t.width\t\t= stmf->output.nr_chans,\n\t\t.__reserved_0\t= 0,\n\t\t.__reserved_1\t= 0,\n\t};\n\n\treturn copy_to_user(arg, &id, id.size) ? -EFAULT : 0;\n}\n\nstatic long\nstm_char_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct stm_file *stmf = file->private_data;\n\tstruct stm_data *stm_data = stmf->stm->data;\n\tint err = -ENOTTY;\n\tu64 options;\n\n\tswitch (cmd) {\n\tcase STP_POLICY_ID_SET:\n\t\terr = stm_char_policy_set_ioctl(stmf, (void __user *)arg);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn stm_char_policy_get_ioctl(stmf, (void __user *)arg);\n\n\tcase STP_POLICY_ID_GET:\n\t\treturn stm_char_policy_get_ioctl(stmf, (void __user *)arg);\n\n\tcase STP_SET_OPTIONS:\n\t\tif (copy_from_user(&options, (u64 __user *)arg, sizeof(u64)))\n\t\t\treturn -EFAULT;\n\n\t\tif (stm_data->set_options)\n\t\t\terr = stm_data->set_options(stm_data,\n\t\t\t\t\t\t    stmf->output.master,\n\t\t\t\t\t\t    stmf->output.channel,\n\t\t\t\t\t\t    stmf->output.nr_chans,\n\t\t\t\t\t\t    options);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic const struct file_operations stm_fops = {\n\t.open\t\t= stm_char_open,\n\t.release\t= stm_char_release,\n\t.write\t\t= stm_char_write,\n\t.mmap\t\t= stm_char_mmap,\n\t.unlocked_ioctl\t= stm_char_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic void stm_device_release(struct device *dev)\n{\n\tstruct stm_device *stm = to_stm_device(dev);\n\n\tvfree(stm);\n}\n\nint stm_register_device(struct device *parent, struct stm_data *stm_data,\n\t\t\tstruct module *owner)\n{\n\tstruct stm_device *stm;\n\tunsigned int nmasters;\n\tint err = -ENOMEM;\n\n\tif (!stm_core_up)\n\t\treturn -EPROBE_DEFER;\n\n\tif (!stm_data->packet || !stm_data->sw_nchannels)\n\t\treturn -EINVAL;\n\n\tnmasters = stm_data->sw_end - stm_data->sw_start + 1;\n\tstm = vzalloc(sizeof(*stm) + nmasters * sizeof(void *));\n\tif (!stm)\n\t\treturn -ENOMEM;\n\n\tstm->major = register_chrdev(0, stm_data->name, &stm_fops);\n\tif (stm->major < 0)\n\t\tgoto err_free;\n\n\tdevice_initialize(&stm->dev);\n\tstm->dev.devt = MKDEV(stm->major, 0);\n\tstm->dev.class = &stm_class;\n\tstm->dev.parent = parent;\n\tstm->dev.release = stm_device_release;\n\n\tmutex_init(&stm->link_mutex);\n\tspin_lock_init(&stm->link_lock);\n\tINIT_LIST_HEAD(&stm->link_list);\n\n\t \n\tspin_lock_init(&stm->mc_lock);\n\tmutex_init(&stm->policy_mutex);\n\tstm->sw_nmasters = nmasters;\n\tstm->owner = owner;\n\tstm->data = stm_data;\n\tstm_data->stm = stm;\n\n\terr = kobject_set_name(&stm->dev.kobj, \"%s\", stm_data->name);\n\tif (err)\n\t\tgoto err_device;\n\n\terr = device_add(&stm->dev);\n\tif (err)\n\t\tgoto err_device;\n\n\t \n\tpm_runtime_no_callbacks(&stm->dev);\n\tpm_runtime_use_autosuspend(&stm->dev);\n\tpm_runtime_set_autosuspend_delay(&stm->dev, 2000);\n\tpm_runtime_set_suspended(&stm->dev);\n\tpm_runtime_enable(&stm->dev);\n\n\treturn 0;\n\nerr_device:\n\tunregister_chrdev(stm->major, stm_data->name);\n\n\t \n\tput_device(&stm->dev);\nerr_free:\n\tvfree(stm);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(stm_register_device);\n\nstatic int __stm_source_link_drop(struct stm_source_device *src,\n\t\t\t\t  struct stm_device *stm);\n\nvoid stm_unregister_device(struct stm_data *stm_data)\n{\n\tstruct stm_device *stm = stm_data->stm;\n\tstruct stm_source_device *src, *iter;\n\tint i, ret;\n\n\tpm_runtime_dont_use_autosuspend(&stm->dev);\n\tpm_runtime_disable(&stm->dev);\n\n\tmutex_lock(&stm->link_mutex);\n\tlist_for_each_entry_safe(src, iter, &stm->link_list, link_entry) {\n\t\tret = __stm_source_link_drop(src, stm);\n\t\t \n\t\tWARN_ON_ONCE(ret);\n\t}\n\tmutex_unlock(&stm->link_mutex);\n\n\tsynchronize_srcu(&stm_source_srcu);\n\n\tunregister_chrdev(stm->major, stm_data->name);\n\n\tmutex_lock(&stm->policy_mutex);\n\tif (stm->policy)\n\t\tstp_policy_unbind(stm->policy);\n\tmutex_unlock(&stm->policy_mutex);\n\n\tfor (i = stm->data->sw_start; i <= stm->data->sw_end; i++)\n\t\tstp_master_free(stm, i);\n\n\tdevice_unregister(&stm->dev);\n\tstm_data->stm = NULL;\n}\nEXPORT_SYMBOL_GPL(stm_unregister_device);\n\n \n\n \nstatic int stm_source_link_add(struct stm_source_device *src,\n\t\t\t       struct stm_device *stm)\n{\n\tchar *ids[] = { NULL, \"default\", NULL };\n\tint err = -ENOMEM;\n\n\tmutex_lock(&stm->link_mutex);\n\tspin_lock(&stm->link_lock);\n\tspin_lock(&src->link_lock);\n\n\t \n\trcu_assign_pointer(src->link, stm);\n\tlist_add_tail(&src->link_entry, &stm->link_list);\n\n\tspin_unlock(&src->link_lock);\n\tspin_unlock(&stm->link_lock);\n\tmutex_unlock(&stm->link_mutex);\n\n\tids[0] = kstrdup(src->data->name, GFP_KERNEL);\n\tif (!ids[0])\n\t\tgoto fail_detach;\n\n\terr = stm_assign_first_policy(stm, &src->output, ids,\n\t\t\t\t      src->data->nr_chans);\n\tkfree(ids[0]);\n\n\tif (err)\n\t\tgoto fail_detach;\n\n\t \n\tif (stm->data->link)\n\t\terr = stm->data->link(stm->data, src->output.master,\n\t\t\t\t      src->output.channel);\n\n\tif (err)\n\t\tgoto fail_free_output;\n\n\t \n\tif (src->data->link)\n\t\tsrc->data->link(src->data);\n\n\treturn 0;\n\nfail_free_output:\n\tstm_output_free(stm, &src->output);\n\nfail_detach:\n\tmutex_lock(&stm->link_mutex);\n\tspin_lock(&stm->link_lock);\n\tspin_lock(&src->link_lock);\n\n\trcu_assign_pointer(src->link, NULL);\n\tlist_del_init(&src->link_entry);\n\n\tspin_unlock(&src->link_lock);\n\tspin_unlock(&stm->link_lock);\n\tmutex_unlock(&stm->link_mutex);\n\n\treturn err;\n}\n\n \nstatic int __stm_source_link_drop(struct stm_source_device *src,\n\t\t\t\t  struct stm_device *stm)\n{\n\tstruct stm_device *link;\n\tint ret = 0;\n\n\tlockdep_assert_held(&stm->link_mutex);\n\n\t \n\tspin_lock(&stm->link_lock);\n\tspin_lock(&src->link_lock);\n\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n\n\t \n\tif (link != stm) {\n\t\tret = -EAGAIN;\n\t\tgoto unlock;\n\t}\n\n\tstm_output_free(link, &src->output);\n\tlist_del_init(&src->link_entry);\n\tpm_runtime_mark_last_busy(&link->dev);\n\tpm_runtime_put_autosuspend(&link->dev);\n\t \n\tstm_put_device(link);\n\trcu_assign_pointer(src->link, NULL);\n\nunlock:\n\tspin_unlock(&src->link_lock);\n\tspin_unlock(&stm->link_lock);\n\n\t \n\tif (!ret) {\n\t\tif (src->data->unlink)\n\t\t\tsrc->data->unlink(src->data);\n\n\t\tif (stm->data->unlink)\n\t\t\tstm->data->unlink(stm->data, src->output.master,\n\t\t\t\t\t  src->output.channel);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void stm_source_link_drop(struct stm_source_device *src)\n{\n\tstruct stm_device *stm;\n\tint idx, ret;\n\nretry:\n\tidx = srcu_read_lock(&stm_source_srcu);\n\t \n\tstm = srcu_dereference(src->link, &stm_source_srcu);\n\n\tret = 0;\n\tif (stm) {\n\t\tmutex_lock(&stm->link_mutex);\n\t\tret = __stm_source_link_drop(src, stm);\n\t\tmutex_unlock(&stm->link_mutex);\n\t}\n\n\tsrcu_read_unlock(&stm_source_srcu, idx);\n\n\t \n\tif (ret == -EAGAIN)\n\t\tgoto retry;\n}\n\nstatic ssize_t stm_source_link_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct stm_source_device *src = to_stm_source_device(dev);\n\tstruct stm_device *stm;\n\tint idx, ret;\n\n\tidx = srcu_read_lock(&stm_source_srcu);\n\tstm = srcu_dereference(src->link, &stm_source_srcu);\n\tret = sprintf(buf, \"%s\\n\",\n\t\t      stm ? dev_name(&stm->dev) : \"<none>\");\n\tsrcu_read_unlock(&stm_source_srcu, idx);\n\n\treturn ret;\n}\n\nstatic ssize_t stm_source_link_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct stm_source_device *src = to_stm_source_device(dev);\n\tstruct stm_device *link;\n\tint err;\n\n\tstm_source_link_drop(src);\n\n\tlink = stm_find_device(buf);\n\tif (!link)\n\t\treturn -EINVAL;\n\n\tpm_runtime_get(&link->dev);\n\n\terr = stm_source_link_add(src, link);\n\tif (err) {\n\t\tpm_runtime_put_autosuspend(&link->dev);\n\t\t \n\t\tstm_put_device(link);\n\t}\n\n\treturn err ? : count;\n}\n\nstatic DEVICE_ATTR_RW(stm_source_link);\n\nstatic struct attribute *stm_source_attrs[] = {\n\t&dev_attr_stm_source_link.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(stm_source);\n\nstatic struct class stm_source_class = {\n\t.name\t\t= \"stm_source\",\n\t.dev_groups\t= stm_source_groups,\n};\n\nstatic void stm_source_device_release(struct device *dev)\n{\n\tstruct stm_source_device *src = to_stm_source_device(dev);\n\n\tkfree(src);\n}\n\n \nint stm_source_register_device(struct device *parent,\n\t\t\t       struct stm_source_data *data)\n{\n\tstruct stm_source_device *src;\n\tint err;\n\n\tif (!stm_core_up)\n\t\treturn -EPROBE_DEFER;\n\n\tsrc = kzalloc(sizeof(*src), GFP_KERNEL);\n\tif (!src)\n\t\treturn -ENOMEM;\n\n\tdevice_initialize(&src->dev);\n\tsrc->dev.class = &stm_source_class;\n\tsrc->dev.parent = parent;\n\tsrc->dev.release = stm_source_device_release;\n\n\terr = kobject_set_name(&src->dev.kobj, \"%s\", data->name);\n\tif (err)\n\t\tgoto err;\n\n\tpm_runtime_no_callbacks(&src->dev);\n\tpm_runtime_forbid(&src->dev);\n\n\terr = device_add(&src->dev);\n\tif (err)\n\t\tgoto err;\n\n\tstm_output_init(&src->output);\n\tspin_lock_init(&src->link_lock);\n\tINIT_LIST_HEAD(&src->link_entry);\n\tsrc->data = data;\n\tdata->src = src;\n\n\treturn 0;\n\nerr:\n\tput_device(&src->dev);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(stm_source_register_device);\n\n \nvoid stm_source_unregister_device(struct stm_source_data *data)\n{\n\tstruct stm_source_device *src = data->src;\n\n\tstm_source_link_drop(src);\n\n\tdevice_unregister(&src->dev);\n}\nEXPORT_SYMBOL_GPL(stm_source_unregister_device);\n\nint notrace stm_source_write(struct stm_source_data *data,\n\t\t\t     unsigned int chan,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct stm_source_device *src = data->src;\n\tstruct stm_device *stm;\n\tint idx;\n\n\tif (!src->output.nr_chans)\n\t\treturn -ENODEV;\n\n\tif (chan >= src->output.nr_chans)\n\t\treturn -EINVAL;\n\n\tidx = srcu_read_lock(&stm_source_srcu);\n\n\tstm = srcu_dereference(src->link, &stm_source_srcu);\n\tif (stm)\n\t\tcount = stm_write(stm, &src->output, chan, buf, count);\n\telse\n\t\tcount = -ENODEV;\n\n\tsrcu_read_unlock(&stm_source_srcu, idx);\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(stm_source_write);\n\nstatic int __init stm_core_init(void)\n{\n\tint err;\n\n\terr = class_register(&stm_class);\n\tif (err)\n\t\treturn err;\n\n\terr = class_register(&stm_source_class);\n\tif (err)\n\t\tgoto err_stm;\n\n\terr = stp_configfs_init();\n\tif (err)\n\t\tgoto err_src;\n\n\tinit_srcu_struct(&stm_source_srcu);\n\tINIT_LIST_HEAD(&stm_pdrv_head);\n\tmutex_init(&stm_pdrv_mutex);\n\n\t \n\tif (IS_ENABLED(CONFIG_STM_PROTO_BASIC))\n\t\t(void)request_module_nowait(\"stm_p_basic\");\n\tstm_core_up++;\n\n\treturn 0;\n\nerr_src:\n\tclass_unregister(&stm_source_class);\nerr_stm:\n\tclass_unregister(&stm_class);\n\n\treturn err;\n}\n\nmodule_init(stm_core_init);\n\nstatic void __exit stm_core_exit(void)\n{\n\tcleanup_srcu_struct(&stm_source_srcu);\n\tclass_unregister(&stm_source_class);\n\tclass_unregister(&stm_class);\n\tstp_configfs_exit();\n}\n\nmodule_exit(stm_core_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"System Trace Module device class\");\nMODULE_AUTHOR(\"Alexander Shishkin <alexander.shishkin@linux.intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}