{
  "module_name": "stm.h",
  "hash_id": "f09c6b7a13672c9248ebd58f30f13d1f1a509d0d1988b7cd9cffd7feb3ced650",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/stm/stm.h",
  "human_readable_source": " \n \n\n#ifndef _STM_STM_H_\n#define _STM_STM_H_\n\n#include <linux/configfs.h>\n\nstruct stp_policy;\nstruct stp_policy_node;\nstruct stm_protocol_driver;\n\nint stp_configfs_init(void);\nvoid stp_configfs_exit(void);\n\nvoid *stp_policy_node_priv(struct stp_policy_node *pn);\n\nstruct stp_master {\n\tunsigned int\tnr_free;\n\tunsigned long\tchan_map[];\n};\n\nstruct stm_device {\n\tstruct device\t\tdev;\n\tstruct module\t\t*owner;\n\tstruct stp_policy\t*policy;\n\tstruct mutex\t\tpolicy_mutex;\n\tint\t\t\tmajor;\n\tunsigned int\t\tsw_nmasters;\n\tstruct stm_data\t\t*data;\n\tstruct mutex\t\tlink_mutex;\n\tspinlock_t\t\tlink_lock;\n\tstruct list_head\tlink_list;\n\t \n\tconst struct stm_protocol_driver\t*pdrv;\n\tconst struct config_item_type\t\t*pdrv_node_type;\n\t \n\tspinlock_t\t\tmc_lock;\n\tstruct stp_master\t*masters[];\n};\n\n#define to_stm_device(_d)\t\t\t\t\\\n\tcontainer_of((_d), struct stm_device, dev)\n\nstruct stp_policy_node *\nstp_policy_node_lookup(struct stm_device *stm, char *s);\nvoid stp_policy_node_put(struct stp_policy_node *policy_node);\nvoid stp_policy_unbind(struct stp_policy *policy);\n\nvoid stp_policy_node_get_ranges(struct stp_policy_node *policy_node,\n\t\t\t\tunsigned int *mstart, unsigned int *mend,\n\t\t\t\tunsigned int *cstart, unsigned int *cend);\n\nconst struct config_item_type *\nget_policy_node_type(struct configfs_attribute **attrs);\n\nstruct stm_output {\n\tspinlock_t\t\tlock;\n\tunsigned int\t\tmaster;\n\tunsigned int\t\tchannel;\n\tunsigned int\t\tnr_chans;\n\tvoid\t\t\t*pdrv_private;\n};\n\nstruct stm_file {\n\tstruct stm_device\t*stm;\n\tstruct stm_output\toutput;\n};\n\nstruct stm_device *stm_find_device(const char *name);\nvoid stm_put_device(struct stm_device *stm);\n\nstruct stm_source_device {\n\tstruct device\t\tdev;\n\tstruct stm_source_data\t*data;\n\tspinlock_t\t\tlink_lock;\n\tstruct stm_device __rcu\t*link;\n\tstruct list_head\tlink_entry;\n\t \n\tstruct stm_output\toutput;\n};\n\n#define to_stm_source_device(_d)\t\t\t\t\\\n\tcontainer_of((_d), struct stm_source_device, dev)\n\nvoid *to_pdrv_policy_node(struct config_item *item);\n\nstruct stm_protocol_driver {\n\tstruct module\t*owner;\n\tconst char\t*name;\n\tssize_t\t\t(*write)(struct stm_data *data,\n\t\t\t\t struct stm_output *output, unsigned int chan,\n\t\t\t\t const char *buf, size_t count);\n\tvoid\t\t(*policy_node_init)(void *arg);\n\tint\t\t(*output_open)(void *priv, struct stm_output *output);\n\tvoid\t\t(*output_close)(struct stm_output *output);\n\tssize_t\t\tpriv_sz;\n\tstruct configfs_attribute\t**policy_attr;\n};\n\nint stm_register_protocol(const struct stm_protocol_driver *pdrv);\nvoid stm_unregister_protocol(const struct stm_protocol_driver *pdrv);\nint stm_lookup_protocol(const char *name,\n\t\t\tconst struct stm_protocol_driver **pdrv,\n\t\t\tconst struct config_item_type **type);\nvoid stm_put_protocol(const struct stm_protocol_driver *pdrv);\nssize_t stm_data_write(struct stm_data *data, unsigned int m,\n\t\t       unsigned int c, bool ts_first, const void *buf,\n\t\t       size_t count);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}