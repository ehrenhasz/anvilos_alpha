{
  "module_name": "dummy_stm.c",
  "hash_id": "95053bdd6dc787be10980a59e6373896c4f3223efe3bb8b6d47c2491d4cbb030",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/stm/dummy_stm.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/stm.h>\n#include <uapi/linux/stm.h>\n\nstatic ssize_t notrace\ndummy_stm_packet(struct stm_data *stm_data, unsigned int master,\n\t\t unsigned int channel, unsigned int packet, unsigned int flags,\n\t\t unsigned int size, const unsigned char *payload)\n{\n#ifdef DEBUG\n\tu64 pl = 0;\n\n\tif (payload)\n\t\tpl = *(u64 *)payload;\n\n\tif (size < 8)\n\t\tpl &= (1ull << (size * 8)) - 1;\n\ttrace_printk(\"[%u:%u] [pkt: %x/%x] (%llx)\\n\", master, channel,\n\t\t     packet, size, pl);\n#endif\n\treturn size;\n}\n\n#define DUMMY_STM_MAX 32\n\nstatic struct stm_data dummy_stm[DUMMY_STM_MAX];\n\nstatic int nr_dummies = 4;\n\nmodule_param(nr_dummies, int, 0400);\n\nstatic unsigned int fail_mode;\n\nmodule_param(fail_mode, int, 0600);\n\nstatic unsigned int master_min;\n\nmodule_param(master_min, int, 0400);\n\nstatic unsigned int master_max = STP_MASTER_MAX;\n\nmodule_param(master_max, int, 0400);\n\nstatic unsigned int nr_channels = STP_CHANNEL_MAX;\n\nmodule_param(nr_channels, int, 0400);\n\nstatic int dummy_stm_link(struct stm_data *data, unsigned int master,\n\t\t\t  unsigned int channel)\n{\n\tif (fail_mode && (channel & fail_mode))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int dummy_stm_init(void)\n{\n\tint i, ret = -ENOMEM;\n\n\tif (nr_dummies < 0 || nr_dummies > DUMMY_STM_MAX)\n\t\treturn -EINVAL;\n\n\tif (master_min > master_max ||\n\t    master_max > STP_MASTER_MAX ||\n\t    nr_channels > STP_CHANNEL_MAX)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nr_dummies; i++) {\n\t\tdummy_stm[i].name = kasprintf(GFP_KERNEL, \"dummy_stm.%d\", i);\n\t\tif (!dummy_stm[i].name)\n\t\t\tgoto fail_unregister;\n\n\t\tdummy_stm[i].sw_start\t\t= master_min;\n\t\tdummy_stm[i].sw_end\t\t= master_max;\n\t\tdummy_stm[i].sw_nchannels\t= nr_channels;\n\t\tdummy_stm[i].packet\t\t= dummy_stm_packet;\n\t\tdummy_stm[i].link\t\t= dummy_stm_link;\n\n\t\tret = stm_register_device(NULL, &dummy_stm[i], THIS_MODULE);\n\t\tif (ret)\n\t\t\tgoto fail_free;\n\t}\n\n\treturn 0;\n\nfail_unregister:\n\tfor (i--; i >= 0; i--) {\n\t\tstm_unregister_device(&dummy_stm[i]);\nfail_free:\n\t\tkfree(dummy_stm[i].name);\n\t}\n\n\treturn ret;\n\n}\n\nstatic void dummy_stm_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_dummies; i++) {\n\t\tstm_unregister_device(&dummy_stm[i]);\n\t\tkfree(dummy_stm[i].name);\n\t}\n}\n\nmodule_init(dummy_stm_init);\nmodule_exit(dummy_stm_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"dummy_stm device\");\nMODULE_AUTHOR(\"Alexander Shishkin <alexander.shishkin@linux.intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}