{
  "module_name": "policy.c",
  "hash_id": "764ef350a67ade6f79c3df1c1c02491aee81e81b16dec527c011325f7e408941",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/stm/policy.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stm.h>\n#include \"stm.h\"\n\n \n\nstruct stp_policy {\n\tstruct config_group\tgroup;\n\tstruct stm_device\t*stm;\n};\n\nstruct stp_policy_node {\n\tstruct config_group\tgroup;\n\tstruct stp_policy\t*policy;\n\tunsigned int\t\tfirst_master;\n\tunsigned int\t\tlast_master;\n\tunsigned int\t\tfirst_channel;\n\tunsigned int\t\tlast_channel;\n\t \n\tunsigned char\t\tpriv[];\n};\n\nvoid *stp_policy_node_priv(struct stp_policy_node *pn)\n{\n\tif (!pn)\n\t\treturn NULL;\n\n\treturn pn->priv;\n}\n\nstatic struct configfs_subsystem stp_policy_subsys;\n\nvoid stp_policy_node_get_ranges(struct stp_policy_node *policy_node,\n\t\t\t\tunsigned int *mstart, unsigned int *mend,\n\t\t\t\tunsigned int *cstart, unsigned int *cend)\n{\n\t*mstart\t= policy_node->first_master;\n\t*mend\t= policy_node->last_master;\n\t*cstart\t= policy_node->first_channel;\n\t*cend\t= policy_node->last_channel;\n}\n\nstatic inline struct stp_policy *to_stp_policy(struct config_item *item)\n{\n\treturn item ?\n\t\tcontainer_of(to_config_group(item), struct stp_policy, group) :\n\t\tNULL;\n}\n\nstatic inline struct stp_policy_node *\nto_stp_policy_node(struct config_item *item)\n{\n\treturn item ?\n\t\tcontainer_of(to_config_group(item), struct stp_policy_node,\n\t\t\t     group) :\n\t\tNULL;\n}\n\nvoid *to_pdrv_policy_node(struct config_item *item)\n{\n\tstruct stp_policy_node *node = to_stp_policy_node(item);\n\n\treturn stp_policy_node_priv(node);\n}\nEXPORT_SYMBOL_GPL(to_pdrv_policy_node);\n\nstatic ssize_t\nstp_policy_node_masters_show(struct config_item *item, char *page)\n{\n\tstruct stp_policy_node *policy_node = to_stp_policy_node(item);\n\tssize_t count;\n\n\tcount = sprintf(page, \"%u %u\\n\", policy_node->first_master,\n\t\t\tpolicy_node->last_master);\n\n\treturn count;\n}\n\nstatic ssize_t\nstp_policy_node_masters_store(struct config_item *item, const char *page,\n\t\t\t      size_t count)\n{\n\tstruct stp_policy_node *policy_node = to_stp_policy_node(item);\n\tunsigned int first, last;\n\tstruct stm_device *stm;\n\tchar *p = (char *)page;\n\tssize_t ret = -ENODEV;\n\n\tif (sscanf(p, \"%u %u\", &first, &last) != 2)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&stp_policy_subsys.su_mutex);\n\tstm = policy_node->policy->stm;\n\tif (!stm)\n\t\tgoto unlock;\n\n\t \n\tif (first > last || first < stm->data->sw_start ||\n\t    last > stm->data->sw_end) {\n\t\tret = -ERANGE;\n\t\tgoto unlock;\n\t}\n\n\tret = count;\n\tpolicy_node->first_master = first;\n\tpolicy_node->last_master = last;\n\nunlock:\n\tmutex_unlock(&stp_policy_subsys.su_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t\nstp_policy_node_channels_show(struct config_item *item, char *page)\n{\n\tstruct stp_policy_node *policy_node = to_stp_policy_node(item);\n\tssize_t count;\n\n\tcount = sprintf(page, \"%u %u\\n\", policy_node->first_channel,\n\t\t\tpolicy_node->last_channel);\n\n\treturn count;\n}\n\nstatic ssize_t\nstp_policy_node_channels_store(struct config_item *item, const char *page,\n\t\t\t       size_t count)\n{\n\tstruct stp_policy_node *policy_node = to_stp_policy_node(item);\n\tunsigned int first, last;\n\tstruct stm_device *stm;\n\tchar *p = (char *)page;\n\tssize_t ret = -ENODEV;\n\n\tif (sscanf(p, \"%u %u\", &first, &last) != 2)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&stp_policy_subsys.su_mutex);\n\tstm = policy_node->policy->stm;\n\tif (!stm)\n\t\tgoto unlock;\n\n\tif (first > INT_MAX || last > INT_MAX || first > last ||\n\t    last >= stm->data->sw_nchannels) {\n\t\tret = -ERANGE;\n\t\tgoto unlock;\n\t}\n\n\tret = count;\n\tpolicy_node->first_channel = first;\n\tpolicy_node->last_channel = last;\n\nunlock:\n\tmutex_unlock(&stp_policy_subsys.su_mutex);\n\n\treturn ret;\n}\n\nstatic void stp_policy_node_release(struct config_item *item)\n{\n\tstruct stp_policy_node *node = to_stp_policy_node(item);\n\n\tkfree(node);\n}\n\nstatic struct configfs_item_operations stp_policy_node_item_ops = {\n\t.release\t\t= stp_policy_node_release,\n};\n\nCONFIGFS_ATTR(stp_policy_node_, masters);\nCONFIGFS_ATTR(stp_policy_node_, channels);\n\nstatic struct configfs_attribute *stp_policy_node_attrs[] = {\n\t&stp_policy_node_attr_masters,\n\t&stp_policy_node_attr_channels,\n\tNULL,\n};\n\nstatic const struct config_item_type stp_policy_type;\nstatic const struct config_item_type stp_policy_node_type;\n\nconst struct config_item_type *\nget_policy_node_type(struct configfs_attribute **attrs)\n{\n\tstruct config_item_type *type;\n\tstruct configfs_attribute **merged;\n\n\ttype = kmemdup(&stp_policy_node_type, sizeof(stp_policy_node_type),\n\t\t       GFP_KERNEL);\n\tif (!type)\n\t\treturn NULL;\n\n\tmerged = memcat_p(stp_policy_node_attrs, attrs);\n\tif (!merged) {\n\t\tkfree(type);\n\t\treturn NULL;\n\t}\n\n\ttype->ct_attrs = merged;\n\n\treturn type;\n}\n\nstatic struct config_group *\nstp_policy_node_make(struct config_group *group, const char *name)\n{\n\tconst struct config_item_type *type = &stp_policy_node_type;\n\tstruct stp_policy_node *policy_node, *parent_node;\n\tconst struct stm_protocol_driver *pdrv;\n\tstruct stp_policy *policy;\n\n\tif (group->cg_item.ci_type == &stp_policy_type) {\n\t\tpolicy = container_of(group, struct stp_policy, group);\n\t} else {\n\t\tparent_node = container_of(group, struct stp_policy_node,\n\t\t\t\t\t   group);\n\t\tpolicy = parent_node->policy;\n\t}\n\n\tif (!policy->stm)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdrv = policy->stm->pdrv;\n\tpolicy_node =\n\t\tkzalloc(offsetof(struct stp_policy_node, priv[pdrv->priv_sz]),\n\t\t\tGFP_KERNEL);\n\tif (!policy_node)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (pdrv->policy_node_init)\n\t\tpdrv->policy_node_init((void *)policy_node->priv);\n\n\tif (policy->stm->pdrv_node_type)\n\t\ttype = policy->stm->pdrv_node_type;\n\n\tconfig_group_init_type_name(&policy_node->group, name, type);\n\n\tpolicy_node->policy = policy;\n\n\t \n\tpolicy_node->first_master = policy->stm->data->sw_start;\n\tpolicy_node->last_master = policy->stm->data->sw_end;\n\tpolicy_node->first_channel = 0;\n\tpolicy_node->last_channel = policy->stm->data->sw_nchannels - 1;\n\n\treturn &policy_node->group;\n}\n\nstatic void\nstp_policy_node_drop(struct config_group *group, struct config_item *item)\n{\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations stp_policy_node_group_ops = {\n\t.make_group\t= stp_policy_node_make,\n\t.drop_item\t= stp_policy_node_drop,\n};\n\nstatic const struct config_item_type stp_policy_node_type = {\n\t.ct_item_ops\t= &stp_policy_node_item_ops,\n\t.ct_group_ops\t= &stp_policy_node_group_ops,\n\t.ct_attrs\t= stp_policy_node_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \nstatic ssize_t stp_policy_device_show(struct config_item *item,\n\t\t\t\t      char *page)\n{\n\tstruct stp_policy *policy = to_stp_policy(item);\n\tssize_t count;\n\n\tcount = sprintf(page, \"%s\\n\",\n\t\t\t(policy && policy->stm) ?\n\t\t\tpolicy->stm->data->name :\n\t\t\t\"<none>\");\n\n\treturn count;\n}\n\nCONFIGFS_ATTR_RO(stp_policy_, device);\n\nstatic ssize_t stp_policy_protocol_show(struct config_item *item,\n\t\t\t\t\tchar *page)\n{\n\tstruct stp_policy *policy = to_stp_policy(item);\n\tssize_t count;\n\n\tcount = sprintf(page, \"%s\\n\",\n\t\t\t(policy && policy->stm) ?\n\t\t\tpolicy->stm->pdrv->name :\n\t\t\t\"<none>\");\n\n\treturn count;\n}\n\nCONFIGFS_ATTR_RO(stp_policy_, protocol);\n\nstatic struct configfs_attribute *stp_policy_attrs[] = {\n\t&stp_policy_attr_device,\n\t&stp_policy_attr_protocol,\n\tNULL,\n};\n\nvoid stp_policy_unbind(struct stp_policy *policy)\n{\n\tstruct stm_device *stm = policy->stm;\n\n\t \n\tif (WARN_ON_ONCE(!policy->stm))\n\t\treturn;\n\n\tlockdep_assert_held(&stm->policy_mutex);\n\n\tstm->policy = NULL;\n\tpolicy->stm = NULL;\n\n\t \n\tstm_put_protocol(stm->pdrv);\n\tstm->pdrv = NULL;\n\tstm_put_device(stm);\n}\n\nstatic void stp_policy_release(struct config_item *item)\n{\n\tstruct stp_policy *policy = to_stp_policy(item);\n\tstruct stm_device *stm = policy->stm;\n\n\t \n\tif (!stm)\n\t\treturn;\n\n\tmutex_lock(&stm->policy_mutex);\n\tstp_policy_unbind(policy);\n\tmutex_unlock(&stm->policy_mutex);\n\n\tkfree(policy);\n}\n\nstatic struct configfs_item_operations stp_policy_item_ops = {\n\t.release\t\t= stp_policy_release,\n};\n\nstatic struct configfs_group_operations stp_policy_group_ops = {\n\t.make_group\t= stp_policy_node_make,\n};\n\nstatic const struct config_item_type stp_policy_type = {\n\t.ct_item_ops\t= &stp_policy_item_ops,\n\t.ct_group_ops\t= &stp_policy_group_ops,\n\t.ct_attrs\t= stp_policy_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_group *\nstp_policy_make(struct config_group *group, const char *name)\n{\n\tconst struct config_item_type *pdrv_node_type;\n\tconst struct stm_protocol_driver *pdrv;\n\tchar *devname, *proto, *p;\n\tstruct config_group *ret;\n\tstruct stm_device *stm;\n\tint err;\n\n\tdevname = kasprintf(GFP_KERNEL, \"%s\", name);\n\tif (!devname)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tp = strrchr(devname, '.');\n\tif (!p) {\n\t\tkfree(devname);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t*p = '\\0';\n\n\t \n\tproto = strrchr(devname, ':');\n\tif (proto)\n\t\t*proto++ = '\\0';\n\n\tstm = stm_find_device(devname);\n\tif (!stm) {\n\t\tkfree(devname);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\terr = stm_lookup_protocol(proto, &pdrv, &pdrv_node_type);\n\tkfree(devname);\n\n\tif (err) {\n\t\tstm_put_device(stm);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tmutex_lock(&stm->policy_mutex);\n\tif (stm->policy) {\n\t\tret = ERR_PTR(-EBUSY);\n\t\tgoto unlock_policy;\n\t}\n\n\tstm->policy = kzalloc(sizeof(*stm->policy), GFP_KERNEL);\n\tif (!stm->policy) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto unlock_policy;\n\t}\n\n\tconfig_group_init_type_name(&stm->policy->group, name,\n\t\t\t\t    &stp_policy_type);\n\n\tstm->pdrv = pdrv;\n\tstm->pdrv_node_type = pdrv_node_type;\n\tstm->policy->stm = stm;\n\tret = &stm->policy->group;\n\nunlock_policy:\n\tmutex_unlock(&stm->policy_mutex);\n\n\tif (IS_ERR(ret)) {\n\t\t \n\t\tstm_put_protocol(pdrv);\n\t\tstm_put_device(stm);\n\t}\n\n\treturn ret;\n}\n\nstatic struct configfs_group_operations stp_policy_root_group_ops = {\n\t.make_group\t= stp_policy_make,\n};\n\nstatic const struct config_item_type stp_policy_root_type = {\n\t.ct_group_ops\t= &stp_policy_root_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct configfs_subsystem stp_policy_subsys = {\n\t.su_group = {\n\t\t.cg_item = {\n\t\t\t.ci_namebuf\t= \"stp-policy\",\n\t\t\t.ci_type\t= &stp_policy_root_type,\n\t\t},\n\t},\n};\n\n \nstatic struct stp_policy_node *\n__stp_policy_node_lookup(struct stp_policy *policy, char *s)\n{\n\tstruct stp_policy_node *policy_node, *ret = NULL;\n\tstruct list_head *head = &policy->group.cg_children;\n\tstruct config_item *item;\n\tchar *start, *end = s;\n\n\tif (list_empty(head))\n\t\treturn NULL;\n\nnext:\n\tfor (;;) {\n\t\tstart = strsep(&end, \"/\");\n\t\tif (!start)\n\t\t\tbreak;\n\n\t\tif (!*start)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(item, head, ci_entry) {\n\t\t\tpolicy_node = to_stp_policy_node(item);\n\n\t\t\tif (!strcmp(start,\n\t\t\t\t    policy_node->group.cg_item.ci_name)) {\n\t\t\t\tret = policy_node;\n\n\t\t\t\tif (!end)\n\t\t\t\t\tgoto out;\n\n\t\t\t\thead = &policy_node->group.cg_children;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}\n\n\nstruct stp_policy_node *\nstp_policy_node_lookup(struct stm_device *stm, char *s)\n{\n\tstruct stp_policy_node *policy_node = NULL;\n\n\tmutex_lock(&stp_policy_subsys.su_mutex);\n\n\tmutex_lock(&stm->policy_mutex);\n\tif (stm->policy)\n\t\tpolicy_node = __stp_policy_node_lookup(stm->policy, s);\n\tmutex_unlock(&stm->policy_mutex);\n\n\tif (policy_node)\n\t\tconfig_item_get(&policy_node->group.cg_item);\n\telse\n\t\tmutex_unlock(&stp_policy_subsys.su_mutex);\n\n\treturn policy_node;\n}\n\nvoid stp_policy_node_put(struct stp_policy_node *policy_node)\n{\n\tlockdep_assert_held(&stp_policy_subsys.su_mutex);\n\n\tmutex_unlock(&stp_policy_subsys.su_mutex);\n\tconfig_item_put(&policy_node->group.cg_item);\n}\n\nint __init stp_configfs_init(void)\n{\n\tconfig_group_init(&stp_policy_subsys.su_group);\n\tmutex_init(&stp_policy_subsys.su_mutex);\n\treturn configfs_register_subsystem(&stp_policy_subsys);\n}\n\nvoid __exit stp_configfs_exit(void)\n{\n\tconfigfs_unregister_subsystem(&stp_policy_subsys);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}