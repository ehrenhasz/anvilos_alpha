{
  "module_name": "hisi_ptt.c",
  "hash_id": "a6157b1407d74ea0c5bef79629419a8a7346701e20cdac7d5ef12125a9219c1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwtracing/ptt/hisi_ptt.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/cpuhotplug.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iommu.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/sysfs.h>\n#include <linux/vmalloc.h>\n\n#include \"hisi_ptt.h\"\n\n \nstatic enum cpuhp_state hisi_ptt_pmu_online;\n\nstatic bool hisi_ptt_wait_tuning_finish(struct hisi_ptt *hisi_ptt)\n{\n\tu32 val;\n\n\treturn !readl_poll_timeout(hisi_ptt->iobase + HISI_PTT_TUNING_INT_STAT,\n\t\t\t\t   val, !(val & HISI_PTT_TUNING_INT_STAT_MASK),\n\t\t\t\t   HISI_PTT_WAIT_POLL_INTERVAL_US,\n\t\t\t\t   HISI_PTT_WAIT_TUNE_TIMEOUT_US);\n}\n\nstatic ssize_t hisi_ptt_tune_attr_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct hisi_ptt *hisi_ptt = to_hisi_ptt(dev_get_drvdata(dev));\n\tstruct dev_ext_attribute *ext_attr;\n\tstruct hisi_ptt_tune_desc *desc;\n\tu32 reg;\n\tu16 val;\n\n\text_attr = container_of(attr, struct dev_ext_attribute, attr);\n\tdesc = ext_attr->var;\n\n\tmutex_lock(&hisi_ptt->tune_lock);\n\n\treg = readl(hisi_ptt->iobase + HISI_PTT_TUNING_CTRL);\n\treg &= ~(HISI_PTT_TUNING_CTRL_CODE | HISI_PTT_TUNING_CTRL_SUB);\n\treg |= FIELD_PREP(HISI_PTT_TUNING_CTRL_CODE | HISI_PTT_TUNING_CTRL_SUB,\n\t\t\t  desc->event_code);\n\twritel(reg, hisi_ptt->iobase + HISI_PTT_TUNING_CTRL);\n\n\t \n\twritel(~0U, hisi_ptt->iobase + HISI_PTT_TUNING_DATA);\n\n\tif (!hisi_ptt_wait_tuning_finish(hisi_ptt)) {\n\t\tmutex_unlock(&hisi_ptt->tune_lock);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treg = readl(hisi_ptt->iobase + HISI_PTT_TUNING_DATA);\n\treg &= HISI_PTT_TUNING_DATA_VAL_MASK;\n\tval = FIELD_GET(HISI_PTT_TUNING_DATA_VAL_MASK, reg);\n\n\tmutex_unlock(&hisi_ptt->tune_lock);\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t hisi_ptt_tune_attr_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hisi_ptt *hisi_ptt = to_hisi_ptt(dev_get_drvdata(dev));\n\tstruct dev_ext_attribute *ext_attr;\n\tstruct hisi_ptt_tune_desc *desc;\n\tu32 reg;\n\tu16 val;\n\n\text_attr = container_of(attr, struct dev_ext_attribute, attr);\n\tdesc = ext_attr->var;\n\n\tif (kstrtou16(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hisi_ptt->tune_lock);\n\n\treg = readl(hisi_ptt->iobase + HISI_PTT_TUNING_CTRL);\n\treg &= ~(HISI_PTT_TUNING_CTRL_CODE | HISI_PTT_TUNING_CTRL_SUB);\n\treg |= FIELD_PREP(HISI_PTT_TUNING_CTRL_CODE | HISI_PTT_TUNING_CTRL_SUB,\n\t\t\t  desc->event_code);\n\twritel(reg, hisi_ptt->iobase + HISI_PTT_TUNING_CTRL);\n\twritel(FIELD_PREP(HISI_PTT_TUNING_DATA_VAL_MASK, val),\n\t       hisi_ptt->iobase + HISI_PTT_TUNING_DATA);\n\n\tif (!hisi_ptt_wait_tuning_finish(hisi_ptt)) {\n\t\tmutex_unlock(&hisi_ptt->tune_lock);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tmutex_unlock(&hisi_ptt->tune_lock);\n\treturn count;\n}\n\n#define HISI_PTT_TUNE_ATTR(_name, _val, _show, _store)\t\t\t\\\n\tstatic struct hisi_ptt_tune_desc _name##_desc = {\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\t\\\n\t\t.event_code = (_val),\t\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\tstatic struct dev_ext_attribute hisi_ptt_##_name##_attr = {\t\\\n\t\t.attr\t= __ATTR(_name, 0600, _show, _store),\t\t\\\n\t\t.var\t= &_name##_desc,\t\t\t\t\\\n\t}\n\n#define HISI_PTT_TUNE_ATTR_COMMON(_name, _val)\t\t\\\n\tHISI_PTT_TUNE_ATTR(_name, _val,\t\t\t\\\n\t\t\t   hisi_ptt_tune_attr_show,\t\\\n\t\t\t   hisi_ptt_tune_attr_store)\n\n \n#define HISI_PTT_TUNE_QOS_TX_CPL\t\t(0x4 | (3 << 16))\n#define HISI_PTT_TUNE_QOS_TX_NP\t\t\t(0x4 | (4 << 16))\n#define HISI_PTT_TUNE_QOS_TX_P\t\t\t(0x4 | (5 << 16))\n#define HISI_PTT_TUNE_RX_ALLOC_BUF_LEVEL\t(0x5 | (6 << 16))\n#define HISI_PTT_TUNE_TX_ALLOC_BUF_LEVEL\t(0x5 | (7 << 16))\n\nHISI_PTT_TUNE_ATTR_COMMON(qos_tx_cpl, HISI_PTT_TUNE_QOS_TX_CPL);\nHISI_PTT_TUNE_ATTR_COMMON(qos_tx_np, HISI_PTT_TUNE_QOS_TX_NP);\nHISI_PTT_TUNE_ATTR_COMMON(qos_tx_p, HISI_PTT_TUNE_QOS_TX_P);\nHISI_PTT_TUNE_ATTR_COMMON(rx_alloc_buf_level, HISI_PTT_TUNE_RX_ALLOC_BUF_LEVEL);\nHISI_PTT_TUNE_ATTR_COMMON(tx_alloc_buf_level, HISI_PTT_TUNE_TX_ALLOC_BUF_LEVEL);\n\nstatic struct attribute *hisi_ptt_tune_attrs[] = {\n\t&hisi_ptt_qos_tx_cpl_attr.attr.attr,\n\t&hisi_ptt_qos_tx_np_attr.attr.attr,\n\t&hisi_ptt_qos_tx_p_attr.attr.attr,\n\t&hisi_ptt_rx_alloc_buf_level_attr.attr.attr,\n\t&hisi_ptt_tx_alloc_buf_level_attr.attr.attr,\n\tNULL,\n};\n\nstatic struct attribute_group hisi_ptt_tune_group = {\n\t.name\t= \"tune\",\n\t.attrs\t= hisi_ptt_tune_attrs,\n};\n\nstatic u16 hisi_ptt_get_filter_val(u16 devid, bool is_port)\n{\n\tif (is_port)\n\t\treturn BIT(HISI_PCIE_CORE_PORT_ID(devid & 0xff));\n\n\treturn devid;\n}\n\nstatic bool hisi_ptt_wait_trace_hw_idle(struct hisi_ptt *hisi_ptt)\n{\n\tu32 val;\n\n\treturn !readl_poll_timeout_atomic(hisi_ptt->iobase + HISI_PTT_TRACE_STS,\n\t\t\t\t\t  val, val & HISI_PTT_TRACE_IDLE,\n\t\t\t\t\t  HISI_PTT_WAIT_POLL_INTERVAL_US,\n\t\t\t\t\t  HISI_PTT_WAIT_TRACE_TIMEOUT_US);\n}\n\nstatic void hisi_ptt_wait_dma_reset_done(struct hisi_ptt *hisi_ptt)\n{\n\tu32 val;\n\n\treadl_poll_timeout_atomic(hisi_ptt->iobase + HISI_PTT_TRACE_WR_STS,\n\t\t\t\t  val, !val, HISI_PTT_RESET_POLL_INTERVAL_US,\n\t\t\t\t  HISI_PTT_RESET_TIMEOUT_US);\n}\n\nstatic void hisi_ptt_trace_end(struct hisi_ptt *hisi_ptt)\n{\n\twritel(0, hisi_ptt->iobase + HISI_PTT_TRACE_CTRL);\n\thisi_ptt->trace_ctrl.started = false;\n}\n\nstatic int hisi_ptt_trace_start(struct hisi_ptt *hisi_ptt)\n{\n\tstruct hisi_ptt_trace_ctrl *ctrl = &hisi_ptt->trace_ctrl;\n\tu32 val;\n\tint i;\n\n\t \n\tif (!hisi_ptt_wait_trace_hw_idle(hisi_ptt)) {\n\t\tpci_err(hisi_ptt->pdev, \"Failed to start trace, the device is still busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tctrl->started = true;\n\n\t \n\tval = readl(hisi_ptt->iobase + HISI_PTT_TRACE_CTRL);\n\tval |= HISI_PTT_TRACE_CTRL_RST;\n\twritel(val, hisi_ptt->iobase + HISI_PTT_TRACE_CTRL);\n\n\thisi_ptt_wait_dma_reset_done(hisi_ptt);\n\n\tval = readl(hisi_ptt->iobase + HISI_PTT_TRACE_CTRL);\n\tval &= ~HISI_PTT_TRACE_CTRL_RST;\n\twritel(val, hisi_ptt->iobase + HISI_PTT_TRACE_CTRL);\n\n\t \n\thisi_ptt->trace_ctrl.buf_index = 0;\n\n\t \n\tfor (i = 0; i < HISI_PTT_TRACE_BUF_CNT; i++)\n\t\tmemset(ctrl->trace_buf[i].addr, 0, HISI_PTT_TRACE_BUF_SIZE);\n\n\t \n\twritel(HISI_PTT_TRACE_INT_STAT_MASK, hisi_ptt->iobase + HISI_PTT_TRACE_INT_STAT);\n\twritel(0, hisi_ptt->iobase + HISI_PTT_TRACE_INT_MASK);\n\n\t \n\tval = FIELD_PREP(HISI_PTT_TRACE_CTRL_TYPE_SEL, ctrl->type);\n\tval |= FIELD_PREP(HISI_PTT_TRACE_CTRL_RXTX_SEL, ctrl->direction);\n\tval |= FIELD_PREP(HISI_PTT_TRACE_CTRL_DATA_FORMAT, ctrl->format);\n\tval |= FIELD_PREP(HISI_PTT_TRACE_CTRL_TARGET_SEL, hisi_ptt->trace_ctrl.filter);\n\tif (!hisi_ptt->trace_ctrl.is_port)\n\t\tval |= HISI_PTT_TRACE_CTRL_FILTER_MODE;\n\n\t \n\tval |= HISI_PTT_TRACE_CTRL_EN;\n\twritel(val, hisi_ptt->iobase + HISI_PTT_TRACE_CTRL);\n\n\treturn 0;\n}\n\nstatic int hisi_ptt_update_aux(struct hisi_ptt *hisi_ptt, int index, bool stop)\n{\n\tstruct hisi_ptt_trace_ctrl *ctrl = &hisi_ptt->trace_ctrl;\n\tstruct perf_output_handle *handle = &ctrl->handle;\n\tstruct perf_event *event = handle->event;\n\tstruct hisi_ptt_pmu_buf *buf;\n\tsize_t size;\n\tvoid *addr;\n\n\tbuf = perf_get_aux(handle);\n\tif (!buf || !handle->size)\n\t\treturn -EINVAL;\n\n\taddr = ctrl->trace_buf[ctrl->buf_index].addr;\n\n\t \n\tif (stop) {\n\t\tu32 reg;\n\n\t\treg = readl(hisi_ptt->iobase + HISI_PTT_TRACE_WR_STS);\n\t\tsize = FIELD_GET(HISI_PTT_TRACE_WR_STS_WRITE, reg);\n\t} else {\n\t\tsize = HISI_PTT_TRACE_BUF_SIZE;\n\t}\n\n\tmemcpy(buf->base + buf->pos, addr, size);\n\tbuf->pos += size;\n\n\t \n\tif (stop) {\n\t\tperf_aux_output_end(handle, buf->pos);\n\t} else if (buf->length - buf->pos < HISI_PTT_TRACE_BUF_SIZE) {\n\t\tperf_aux_output_end(handle, buf->pos);\n\n\t\tbuf = perf_aux_output_begin(handle, event);\n\t\tif (!buf)\n\t\t\treturn -EINVAL;\n\n\t\tbuf->pos = handle->head % buf->length;\n\t\tif (buf->length - buf->pos < HISI_PTT_TRACE_BUF_SIZE) {\n\t\t\tperf_aux_output_end(handle, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t hisi_ptt_isr(int irq, void *context)\n{\n\tstruct hisi_ptt *hisi_ptt = context;\n\tu32 status, buf_idx;\n\n\tstatus = readl(hisi_ptt->iobase + HISI_PTT_TRACE_INT_STAT);\n\tif (!(status & HISI_PTT_TRACE_INT_STAT_MASK))\n\t\treturn IRQ_NONE;\n\n\tbuf_idx = ffs(status) - 1;\n\n\t \n\twritel(status, hisi_ptt->iobase + HISI_PTT_TRACE_INT_STAT);\n\n\t \n\tif (hisi_ptt_update_aux(hisi_ptt, buf_idx, false))\n\t\thisi_ptt_trace_end(hisi_ptt);\n\telse\n\t\thisi_ptt->trace_ctrl.buf_index = (buf_idx + 1) % HISI_PTT_TRACE_BUF_CNT;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void hisi_ptt_irq_free_vectors(void *pdev)\n{\n\tpci_free_irq_vectors(pdev);\n}\n\nstatic int hisi_ptt_register_irq(struct hisi_ptt *hisi_ptt)\n{\n\tstruct pci_dev *pdev = hisi_ptt->pdev;\n\tint ret;\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tif (ret < 0) {\n\t\tpci_err(pdev, \"failed to allocate irq vector, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&pdev->dev, hisi_ptt_irq_free_vectors, pdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thisi_ptt->trace_irq = pci_irq_vector(pdev, HISI_PTT_TRACE_DMA_IRQ);\n\tret = devm_request_irq(&pdev->dev, hisi_ptt->trace_irq, hisi_ptt_isr,\n\t\t\t\tIRQF_NOBALANCING | IRQF_NO_THREAD, DRV_NAME,\n\t\t\t\thisi_ptt);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to request irq %d, ret = %d\\n\",\n\t\t\thisi_ptt->trace_irq, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void hisi_ptt_del_free_filter(struct hisi_ptt *hisi_ptt,\n\t\t\t\t      struct hisi_ptt_filter_desc *filter)\n{\n\tif (filter->is_port)\n\t\thisi_ptt->port_mask &= ~hisi_ptt_get_filter_val(filter->devid, true);\n\n\tlist_del(&filter->list);\n\tkfree(filter->name);\n\tkfree(filter);\n}\n\nstatic struct hisi_ptt_filter_desc *\nhisi_ptt_alloc_add_filter(struct hisi_ptt *hisi_ptt, u16 devid, bool is_port)\n{\n\tstruct hisi_ptt_filter_desc *filter;\n\tu8 devfn = devid & 0xff;\n\tchar *filter_name;\n\n\tfilter_name = kasprintf(GFP_KERNEL, \"%04x:%02x:%02x.%d\", pci_domain_nr(hisi_ptt->pdev->bus),\n\t\t\t\t PCI_BUS_NUM(devid), PCI_SLOT(devfn), PCI_FUNC(devfn));\n\tif (!filter_name) {\n\t\tpci_err(hisi_ptt->pdev, \"failed to allocate name for filter %04x:%02x:%02x.%d\\n\",\n\t\t\tpci_domain_nr(hisi_ptt->pdev->bus), PCI_BUS_NUM(devid),\n\t\t\tPCI_SLOT(devfn), PCI_FUNC(devfn));\n\t\treturn NULL;\n\t}\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (!filter) {\n\t\tpci_err(hisi_ptt->pdev, \"failed to add filter for %s\\n\",\n\t\t\tfilter_name);\n\t\tkfree(filter_name);\n\t\treturn NULL;\n\t}\n\n\tfilter->name = filter_name;\n\tfilter->is_port = is_port;\n\tfilter->devid = devid;\n\n\tif (filter->is_port) {\n\t\tlist_add_tail(&filter->list, &hisi_ptt->port_filters);\n\n\t\t \n\t\thisi_ptt->port_mask |= hisi_ptt_get_filter_val(filter->devid, true);\n\t} else {\n\t\tlist_add_tail(&filter->list, &hisi_ptt->req_filters);\n\t}\n\n\treturn filter;\n}\n\nstatic ssize_t hisi_ptt_filter_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct hisi_ptt_filter_desc *filter;\n\tunsigned long filter_val;\n\n\tfilter = container_of(attr, struct hisi_ptt_filter_desc, attr);\n\tfilter_val = hisi_ptt_get_filter_val(filter->devid, filter->is_port) |\n\t\t     (filter->is_port ? HISI_PTT_PMU_FILTER_IS_PORT : 0);\n\n\treturn sysfs_emit(buf, \"0x%05lx\\n\", filter_val);\n}\n\nstatic int hisi_ptt_create_rp_filter_attr(struct hisi_ptt *hisi_ptt,\n\t\t\t\t\t  struct hisi_ptt_filter_desc *filter)\n{\n\tstruct kobject *kobj = &hisi_ptt->hisi_ptt_pmu.dev->kobj;\n\n\tsysfs_attr_init(&filter->attr.attr);\n\tfilter->attr.attr.name = filter->name;\n\tfilter->attr.attr.mode = 0400;  \n\tfilter->attr.show = hisi_ptt_filter_show;\n\n\treturn sysfs_add_file_to_group(kobj, &filter->attr.attr,\n\t\t\t\t       HISI_PTT_RP_FILTERS_GRP_NAME);\n}\n\nstatic void hisi_ptt_remove_rp_filter_attr(struct hisi_ptt *hisi_ptt,\n\t\t\t\t\t  struct hisi_ptt_filter_desc *filter)\n{\n\tstruct kobject *kobj = &hisi_ptt->hisi_ptt_pmu.dev->kobj;\n\n\tsysfs_remove_file_from_group(kobj, &filter->attr.attr,\n\t\t\t\t     HISI_PTT_RP_FILTERS_GRP_NAME);\n}\n\nstatic int hisi_ptt_create_req_filter_attr(struct hisi_ptt *hisi_ptt,\n\t\t\t\t\t   struct hisi_ptt_filter_desc *filter)\n{\n\tstruct kobject *kobj = &hisi_ptt->hisi_ptt_pmu.dev->kobj;\n\n\tsysfs_attr_init(&filter->attr.attr);\n\tfilter->attr.attr.name = filter->name;\n\tfilter->attr.attr.mode = 0400;  \n\tfilter->attr.show = hisi_ptt_filter_show;\n\n\treturn sysfs_add_file_to_group(kobj, &filter->attr.attr,\n\t\t\t\t       HISI_PTT_REQ_FILTERS_GRP_NAME);\n}\n\nstatic void hisi_ptt_remove_req_filter_attr(struct hisi_ptt *hisi_ptt,\n\t\t\t\t\t   struct hisi_ptt_filter_desc *filter)\n{\n\tstruct kobject *kobj = &hisi_ptt->hisi_ptt_pmu.dev->kobj;\n\n\tsysfs_remove_file_from_group(kobj, &filter->attr.attr,\n\t\t\t\t     HISI_PTT_REQ_FILTERS_GRP_NAME);\n}\n\nstatic int hisi_ptt_create_filter_attr(struct hisi_ptt *hisi_ptt,\n\t\t\t\t       struct hisi_ptt_filter_desc *filter)\n{\n\tint ret;\n\n\tif (filter->is_port)\n\t\tret = hisi_ptt_create_rp_filter_attr(hisi_ptt, filter);\n\telse\n\t\tret = hisi_ptt_create_req_filter_attr(hisi_ptt, filter);\n\n\tif (ret)\n\t\tpci_err(hisi_ptt->pdev, \"failed to create sysfs attribute for filter %s\\n\",\n\t\t\tfilter->name);\n\n\treturn ret;\n}\n\nstatic void hisi_ptt_remove_filter_attr(struct hisi_ptt *hisi_ptt,\n\t\t\t\t\tstruct hisi_ptt_filter_desc *filter)\n{\n\tif (filter->is_port)\n\t\thisi_ptt_remove_rp_filter_attr(hisi_ptt, filter);\n\telse\n\t\thisi_ptt_remove_req_filter_attr(hisi_ptt, filter);\n}\n\nstatic void hisi_ptt_remove_all_filter_attributes(void *data)\n{\n\tstruct hisi_ptt_filter_desc *filter;\n\tstruct hisi_ptt *hisi_ptt = data;\n\n\tmutex_lock(&hisi_ptt->filter_lock);\n\n\tlist_for_each_entry(filter, &hisi_ptt->req_filters, list)\n\t\thisi_ptt_remove_filter_attr(hisi_ptt, filter);\n\n\tlist_for_each_entry(filter, &hisi_ptt->port_filters, list)\n\t\thisi_ptt_remove_filter_attr(hisi_ptt, filter);\n\n\thisi_ptt->sysfs_inited = false;\n\tmutex_unlock(&hisi_ptt->filter_lock);\n}\n\nstatic int hisi_ptt_init_filter_attributes(struct hisi_ptt *hisi_ptt)\n{\n\tstruct hisi_ptt_filter_desc *filter;\n\tint ret;\n\n\tmutex_lock(&hisi_ptt->filter_lock);\n\n\t \n\tret = devm_add_action(&hisi_ptt->pdev->dev,\n\t\t\t      hisi_ptt_remove_all_filter_attributes,\n\t\t\t      hisi_ptt);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_for_each_entry(filter, &hisi_ptt->port_filters, list) {\n\t\tret = hisi_ptt_create_filter_attr(hisi_ptt, filter);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(filter, &hisi_ptt->req_filters, list) {\n\t\tret = hisi_ptt_create_filter_attr(hisi_ptt, filter);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\thisi_ptt->sysfs_inited = true;\nout:\n\tmutex_unlock(&hisi_ptt->filter_lock);\n\treturn ret;\n}\n\nstatic void hisi_ptt_update_filters(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct hisi_ptt_filter_update_info info;\n\tstruct hisi_ptt_filter_desc *filter;\n\tstruct hisi_ptt *hisi_ptt;\n\n\thisi_ptt = container_of(delayed_work, struct hisi_ptt, work);\n\n\tif (!mutex_trylock(&hisi_ptt->filter_lock)) {\n\t\tschedule_delayed_work(&hisi_ptt->work, HISI_PTT_WORK_DELAY_MS);\n\t\treturn;\n\t}\n\n\twhile (kfifo_get(&hisi_ptt->filter_update_kfifo, &info)) {\n\t\tif (info.is_add) {\n\t\t\t \n\t\t\tfilter = hisi_ptt_alloc_add_filter(hisi_ptt, info.devid, info.is_port);\n\t\t\tif (!filter)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (hisi_ptt->sysfs_inited &&\n\t\t\t    hisi_ptt_create_filter_attr(hisi_ptt, filter)) {\n\t\t\t\thisi_ptt_del_free_filter(hisi_ptt, filter);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct hisi_ptt_filter_desc *tmp;\n\t\t\tstruct list_head *target_list;\n\n\t\t\ttarget_list = info.is_port ? &hisi_ptt->port_filters :\n\t\t\t\t      &hisi_ptt->req_filters;\n\n\t\t\tlist_for_each_entry_safe(filter, tmp, target_list, list)\n\t\t\t\tif (filter->devid == info.devid) {\n\t\t\t\t\tif (hisi_ptt->sysfs_inited)\n\t\t\t\t\t\thisi_ptt_remove_filter_attr(hisi_ptt, filter);\n\n\t\t\t\t\thisi_ptt_del_free_filter(hisi_ptt, filter);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&hisi_ptt->filter_lock);\n}\n\n \nstatic int hisi_ptt_notifier_call(struct notifier_block *nb, unsigned long action,\n\t\t\t\t  void *data)\n{\n\tstruct hisi_ptt *hisi_ptt = container_of(nb, struct hisi_ptt, hisi_ptt_nb);\n\tstruct hisi_ptt_filter_update_info info;\n\tstruct pci_dev *pdev, *root_port;\n\tstruct device *dev = data;\n\tu32 port_devid;\n\n\tpdev = to_pci_dev(dev);\n\troot_port = pcie_find_root_port(pdev);\n\tif (!root_port)\n\t\treturn 0;\n\n\tport_devid = pci_dev_id(root_port);\n\tif (port_devid < hisi_ptt->lower_bdf ||\n\t    port_devid > hisi_ptt->upper_bdf)\n\t\treturn 0;\n\n\tinfo.is_port = pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT;\n\tinfo.devid = pci_dev_id(pdev);\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tinfo.is_add = true;\n\t\tbreak;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tinfo.is_add = false;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\tif (kfifo_in_spinlocked(&hisi_ptt->filter_update_kfifo, &info, 1,\n\t\t\t\t&hisi_ptt->filter_update_lock))\n\t\tschedule_delayed_work(&hisi_ptt->work, 0);\n\telse\n\t\tpci_warn(hisi_ptt->pdev,\n\t\t\t \"filter update fifo overflow for target %s\\n\",\n\t\t\t pci_name(pdev));\n\n\treturn 0;\n}\n\nstatic int hisi_ptt_init_filters(struct pci_dev *pdev, void *data)\n{\n\tstruct pci_dev *root_port = pcie_find_root_port(pdev);\n\tstruct hisi_ptt_filter_desc *filter;\n\tstruct hisi_ptt *hisi_ptt = data;\n\tu32 port_devid;\n\n\tif (!root_port)\n\t\treturn 0;\n\n\tport_devid = pci_dev_id(root_port);\n\tif (port_devid < hisi_ptt->lower_bdf ||\n\t    port_devid > hisi_ptt->upper_bdf)\n\t\treturn 0;\n\n\t \n\tfilter = hisi_ptt_alloc_add_filter(hisi_ptt, pci_dev_id(pdev),\n\t\t\t\t\t    pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void hisi_ptt_release_filters(void *data)\n{\n\tstruct hisi_ptt_filter_desc *filter, *tmp;\n\tstruct hisi_ptt *hisi_ptt = data;\n\n\tlist_for_each_entry_safe(filter, tmp, &hisi_ptt->req_filters, list)\n\t\thisi_ptt_del_free_filter(hisi_ptt, filter);\n\n\tlist_for_each_entry_safe(filter, tmp, &hisi_ptt->port_filters, list)\n\t\thisi_ptt_del_free_filter(hisi_ptt, filter);\n}\n\nstatic int hisi_ptt_config_trace_buf(struct hisi_ptt *hisi_ptt)\n{\n\tstruct hisi_ptt_trace_ctrl *ctrl = &hisi_ptt->trace_ctrl;\n\tstruct device *dev = &hisi_ptt->pdev->dev;\n\tint i;\n\n\tctrl->trace_buf = devm_kcalloc(dev, HISI_PTT_TRACE_BUF_CNT,\n\t\t\t\t       sizeof(*ctrl->trace_buf), GFP_KERNEL);\n\tif (!ctrl->trace_buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < HISI_PTT_TRACE_BUF_CNT; ++i) {\n\t\tctrl->trace_buf[i].addr = dmam_alloc_coherent(dev, HISI_PTT_TRACE_BUF_SIZE,\n\t\t\t\t\t\t\t     &ctrl->trace_buf[i].dma,\n\t\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!ctrl->trace_buf[i].addr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < HISI_PTT_TRACE_BUF_CNT; i++) {\n\t\twritel(lower_32_bits(ctrl->trace_buf[i].dma),\n\t\t       hisi_ptt->iobase + HISI_PTT_TRACE_ADDR_BASE_LO_0 +\n\t\t       i * HISI_PTT_TRACE_ADDR_STRIDE);\n\t\twritel(upper_32_bits(ctrl->trace_buf[i].dma),\n\t\t       hisi_ptt->iobase + HISI_PTT_TRACE_ADDR_BASE_HI_0 +\n\t\t       i * HISI_PTT_TRACE_ADDR_STRIDE);\n\t}\n\twritel(HISI_PTT_TRACE_BUF_SIZE, hisi_ptt->iobase + HISI_PTT_TRACE_ADDR_SIZE);\n\n\treturn 0;\n}\n\nstatic int hisi_ptt_init_ctrls(struct hisi_ptt *hisi_ptt)\n{\n\tstruct pci_dev *pdev = hisi_ptt->pdev;\n\tstruct pci_bus *bus;\n\tint ret;\n\tu32 reg;\n\n\tINIT_DELAYED_WORK(&hisi_ptt->work, hisi_ptt_update_filters);\n\tINIT_KFIFO(hisi_ptt->filter_update_kfifo);\n\tspin_lock_init(&hisi_ptt->filter_update_lock);\n\n\tINIT_LIST_HEAD(&hisi_ptt->port_filters);\n\tINIT_LIST_HEAD(&hisi_ptt->req_filters);\n\tmutex_init(&hisi_ptt->filter_lock);\n\n\tret = hisi_ptt_config_trace_buf(hisi_ptt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treg = readl(hisi_ptt->iobase + HISI_PTT_DEVICE_RANGE);\n\thisi_ptt->upper_bdf = FIELD_GET(HISI_PTT_DEVICE_RANGE_UPPER, reg);\n\thisi_ptt->lower_bdf = FIELD_GET(HISI_PTT_DEVICE_RANGE_LOWER, reg);\n\n\tbus = pci_find_bus(pci_domain_nr(pdev->bus), PCI_BUS_NUM(hisi_ptt->upper_bdf));\n\tif (bus)\n\t\tpci_walk_bus(bus, hisi_ptt_init_filters, hisi_ptt);\n\n\tret = devm_add_action_or_reset(&pdev->dev, hisi_ptt_release_filters, hisi_ptt);\n\tif (ret)\n\t\treturn ret;\n\n\thisi_ptt->trace_ctrl.on_cpu = -1;\n\treturn 0;\n}\n\nstatic ssize_t cpumask_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct hisi_ptt *hisi_ptt = to_hisi_ptt(dev_get_drvdata(dev));\n\tconst cpumask_t *cpumask = cpumask_of_node(dev_to_node(&hisi_ptt->pdev->dev));\n\n\treturn cpumap_print_to_pagebuf(true, buf, cpumask);\n}\nstatic DEVICE_ATTR_RO(cpumask);\n\nstatic struct attribute *hisi_ptt_cpumask_attrs[] = {\n\t&dev_attr_cpumask.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hisi_ptt_cpumask_attr_group = {\n\t.attrs = hisi_ptt_cpumask_attrs,\n};\n\n \nPMU_FORMAT_ATTR(filter,\t\t\"config:0-19\");\nPMU_FORMAT_ATTR(direction,\t\"config:20-23\");\nPMU_FORMAT_ATTR(type,\t\t\"config:24-31\");\nPMU_FORMAT_ATTR(format,\t\t\"config:32-35\");\n\nstatic struct attribute *hisi_ptt_pmu_format_attrs[] = {\n\t&format_attr_filter.attr,\n\t&format_attr_direction.attr,\n\t&format_attr_type.attr,\n\t&format_attr_format.attr,\n\tNULL\n};\n\nstatic struct attribute_group hisi_ptt_pmu_format_group = {\n\t.name = \"format\",\n\t.attrs = hisi_ptt_pmu_format_attrs,\n};\n\nstatic ssize_t hisi_ptt_filter_multiselect_show(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf)\n{\n\tstruct dev_ext_attribute *ext_attr;\n\n\text_attr = container_of(attr, struct dev_ext_attribute, attr);\n\treturn sysfs_emit(buf, \"%s\\n\", (char *)ext_attr->var);\n}\n\nstatic struct dev_ext_attribute root_port_filters_multiselect = {\n\t.attr = {\n\t\t.attr = { .name = \"multiselect\", .mode = 0400 },\n\t\t.show = hisi_ptt_filter_multiselect_show,\n\t},\n\t.var = \"1\",\n};\n\nstatic struct attribute *hisi_ptt_pmu_root_ports_attrs[] = {\n\t&root_port_filters_multiselect.attr.attr,\n\tNULL\n};\n\nstatic struct attribute_group hisi_ptt_pmu_root_ports_group = {\n\t.name = HISI_PTT_RP_FILTERS_GRP_NAME,\n\t.attrs = hisi_ptt_pmu_root_ports_attrs,\n};\n\nstatic struct dev_ext_attribute requester_filters_multiselect = {\n\t.attr = {\n\t\t.attr = { .name = \"multiselect\", .mode = 0400 },\n\t\t.show = hisi_ptt_filter_multiselect_show,\n\t},\n\t.var = \"0\",\n};\n\nstatic struct attribute *hisi_ptt_pmu_requesters_attrs[] = {\n\t&requester_filters_multiselect.attr.attr,\n\tNULL\n};\n\nstatic struct attribute_group hisi_ptt_pmu_requesters_group = {\n\t.name = HISI_PTT_REQ_FILTERS_GRP_NAME,\n\t.attrs = hisi_ptt_pmu_requesters_attrs,\n};\n\nstatic const struct attribute_group *hisi_ptt_pmu_groups[] = {\n\t&hisi_ptt_cpumask_attr_group,\n\t&hisi_ptt_pmu_format_group,\n\t&hisi_ptt_tune_group,\n\t&hisi_ptt_pmu_root_ports_group,\n\t&hisi_ptt_pmu_requesters_group,\n\tNULL\n};\n\nstatic int hisi_ptt_trace_valid_direction(u32 val)\n{\n\t \n\tstatic const u32 hisi_ptt_trace_available_direction[] = {\n\t\t0,\t \n\t\t1,\t \n\t\t2,\t \n\t\t3,\t \n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hisi_ptt_trace_available_direction); i++) {\n\t\tif (val == hisi_ptt_trace_available_direction[i])\n\t\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int hisi_ptt_trace_valid_type(u32 val)\n{\n\t \n\tstatic const u32 hisi_ptt_trace_available_type[] = {\n\t\t1,\t \n\t\t2,\t \n\t\t4,\t \n\t};\n\tint i;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(hisi_ptt_trace_available_type); i++)\n\t\tval &= ~hisi_ptt_trace_available_type[i];\n\n\tif (val)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hisi_ptt_trace_valid_format(u32 val)\n{\n\tstatic const u32 hisi_ptt_trace_availble_format[] = {\n\t\t0,\t \n\t\t1,\t \n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hisi_ptt_trace_availble_format); i++) {\n\t\tif (val == hisi_ptt_trace_availble_format[i])\n\t\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int hisi_ptt_trace_valid_filter(struct hisi_ptt *hisi_ptt, u64 config)\n{\n\tunsigned long val, port_mask = hisi_ptt->port_mask;\n\tstruct hisi_ptt_filter_desc *filter;\n\tint ret = 0;\n\n\thisi_ptt->trace_ctrl.is_port = FIELD_GET(HISI_PTT_PMU_FILTER_IS_PORT, config);\n\tval = FIELD_GET(HISI_PTT_PMU_FILTER_VAL_MASK, config);\n\n\t \n\tmutex_lock(&hisi_ptt->filter_lock);\n\tif (!hisi_ptt->trace_ctrl.is_port) {\n\t\tlist_for_each_entry(filter, &hisi_ptt->req_filters, list) {\n\t\t\tif (val == hisi_ptt_get_filter_val(filter->devid, filter->is_port))\n\t\t\t\tgoto out;\n\t\t}\n\t} else if (bitmap_subset(&val, &port_mask, BITS_PER_LONG)) {\n\t\tgoto out;\n\t}\n\n\tret = -EINVAL;\nout:\n\tmutex_unlock(&hisi_ptt->filter_lock);\n\treturn ret;\n}\n\nstatic void hisi_ptt_pmu_init_configs(struct hisi_ptt *hisi_ptt, struct perf_event *event)\n{\n\tstruct hisi_ptt_trace_ctrl *ctrl = &hisi_ptt->trace_ctrl;\n\tu32 val;\n\n\tval = FIELD_GET(HISI_PTT_PMU_FILTER_VAL_MASK, event->attr.config);\n\thisi_ptt->trace_ctrl.filter = val;\n\n\tval = FIELD_GET(HISI_PTT_PMU_DIRECTION_MASK, event->attr.config);\n\tctrl->direction = val;\n\n\tval = FIELD_GET(HISI_PTT_PMU_TYPE_MASK, event->attr.config);\n\tctrl->type = val;\n\n\tval = FIELD_GET(HISI_PTT_PMU_FORMAT_MASK, event->attr.config);\n\tctrl->format = val;\n}\n\nstatic int hisi_ptt_pmu_event_init(struct perf_event *event)\n{\n\tstruct hisi_ptt *hisi_ptt = to_hisi_ptt(event->pmu);\n\tint ret;\n\tu32 val;\n\n\tif (event->cpu < 0) {\n\t\tdev_dbg(event->pmu->dev, \"Per-task mode not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (event->attach_state & PERF_ATTACH_TASK)\n\t\treturn -EOPNOTSUPP;\n\n\tif (event->attr.type != hisi_ptt->hisi_ptt_pmu.type)\n\t\treturn -ENOENT;\n\n\tret = hisi_ptt_trace_valid_filter(hisi_ptt, event->attr.config);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = FIELD_GET(HISI_PTT_PMU_DIRECTION_MASK, event->attr.config);\n\tret = hisi_ptt_trace_valid_direction(val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = FIELD_GET(HISI_PTT_PMU_TYPE_MASK, event->attr.config);\n\tret = hisi_ptt_trace_valid_type(val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = FIELD_GET(HISI_PTT_PMU_FORMAT_MASK, event->attr.config);\n\treturn hisi_ptt_trace_valid_format(val);\n}\n\nstatic void *hisi_ptt_pmu_setup_aux(struct perf_event *event, void **pages,\n\t\t\t\t    int nr_pages, bool overwrite)\n{\n\tstruct hisi_ptt_pmu_buf *buf;\n\tstruct page **pagelist;\n\tint i;\n\n\tif (overwrite) {\n\t\tdev_warn(event->pmu->dev, \"Overwrite mode is not supported\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tif (nr_pages < HISI_PTT_TRACE_TOTAL_BUF_SIZE / PAGE_SIZE)\n\t\treturn NULL;\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tpagelist = kcalloc(nr_pages, sizeof(*pagelist), GFP_KERNEL);\n\tif (!pagelist)\n\t\tgoto err;\n\n\tfor (i = 0; i < nr_pages; i++)\n\t\tpagelist[i] = virt_to_page(pages[i]);\n\n\tbuf->base = vmap(pagelist, nr_pages, VM_MAP, PAGE_KERNEL);\n\tif (!buf->base) {\n\t\tkfree(pagelist);\n\t\tgoto err;\n\t}\n\n\tbuf->nr_pages = nr_pages;\n\tbuf->length = nr_pages * PAGE_SIZE;\n\tbuf->pos = 0;\n\n\tkfree(pagelist);\n\treturn buf;\nerr:\n\tkfree(buf);\n\treturn NULL;\n}\n\nstatic void hisi_ptt_pmu_free_aux(void *aux)\n{\n\tstruct hisi_ptt_pmu_buf *buf = aux;\n\n\tvunmap(buf->base);\n\tkfree(buf);\n}\n\nstatic void hisi_ptt_pmu_start(struct perf_event *event, int flags)\n{\n\tstruct hisi_ptt *hisi_ptt = to_hisi_ptt(event->pmu);\n\tstruct perf_output_handle *handle = &hisi_ptt->trace_ctrl.handle;\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct device *dev = event->pmu->dev;\n\tstruct hisi_ptt_pmu_buf *buf;\n\tint cpu = event->cpu;\n\tint ret;\n\n\thwc->state = 0;\n\n\t \n\tspin_lock(&hisi_ptt->pmu_lock);\n\tif (hisi_ptt->trace_ctrl.started) {\n\t\tdev_dbg(dev, \"trace has already started\\n\");\n\t\tgoto stop;\n\t}\n\n\t \n\tret = irq_set_affinity(hisi_ptt->trace_irq, cpumask_of(cpu));\n\tif (ret)\n\t\tdev_warn(dev, \"failed to set the affinity of trace interrupt\\n\");\n\n\thisi_ptt->trace_ctrl.on_cpu = cpu;\n\n\tbuf = perf_aux_output_begin(handle, event);\n\tif (!buf) {\n\t\tdev_dbg(dev, \"aux output begin failed\\n\");\n\t\tgoto stop;\n\t}\n\n\tbuf->pos = handle->head % buf->length;\n\n\thisi_ptt_pmu_init_configs(hisi_ptt, event);\n\n\tret = hisi_ptt_trace_start(hisi_ptt);\n\tif (ret) {\n\t\tdev_dbg(dev, \"trace start failed, ret = %d\\n\", ret);\n\t\tperf_aux_output_end(handle, 0);\n\t\tgoto stop;\n\t}\n\n\tspin_unlock(&hisi_ptt->pmu_lock);\n\treturn;\nstop:\n\tevent->hw.state |= PERF_HES_STOPPED;\n\tspin_unlock(&hisi_ptt->pmu_lock);\n}\n\nstatic void hisi_ptt_pmu_stop(struct perf_event *event, int flags)\n{\n\tstruct hisi_ptt *hisi_ptt = to_hisi_ptt(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (hwc->state & PERF_HES_STOPPED)\n\t\treturn;\n\n\tspin_lock(&hisi_ptt->pmu_lock);\n\tif (hisi_ptt->trace_ctrl.started) {\n\t\thisi_ptt_trace_end(hisi_ptt);\n\n\t\tif (!hisi_ptt_wait_trace_hw_idle(hisi_ptt))\n\t\t\tdev_warn(event->pmu->dev, \"Device is still busy\\n\");\n\n\t\thisi_ptt_update_aux(hisi_ptt, hisi_ptt->trace_ctrl.buf_index, true);\n\t}\n\tspin_unlock(&hisi_ptt->pmu_lock);\n\n\thwc->state |= PERF_HES_STOPPED;\n\tperf_event_update_userpage(event);\n\thwc->state |= PERF_HES_UPTODATE;\n}\n\nstatic int hisi_ptt_pmu_add(struct perf_event *event, int flags)\n{\n\tstruct hisi_ptt *hisi_ptt = to_hisi_ptt(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint cpu = event->cpu;\n\n\t \n\tif (!cpumask_test_cpu(cpu, cpumask_of_node(dev_to_node(&hisi_ptt->pdev->dev))))\n\t\treturn 0;\n\n\thwc->state = PERF_HES_STOPPED | PERF_HES_UPTODATE;\n\n\tif (flags & PERF_EF_START) {\n\t\thisi_ptt_pmu_start(event, PERF_EF_RELOAD);\n\t\tif (hwc->state & PERF_HES_STOPPED)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void hisi_ptt_pmu_del(struct perf_event *event, int flags)\n{\n\thisi_ptt_pmu_stop(event, PERF_EF_UPDATE);\n}\n\nstatic void hisi_ptt_pmu_read(struct perf_event *event)\n{\n}\n\nstatic void hisi_ptt_remove_cpuhp_instance(void *hotplug_node)\n{\n\tcpuhp_state_remove_instance_nocalls(hisi_ptt_pmu_online, hotplug_node);\n}\n\nstatic void hisi_ptt_unregister_pmu(void *pmu)\n{\n\tperf_pmu_unregister(pmu);\n}\n\nstatic int hisi_ptt_register_pmu(struct hisi_ptt *hisi_ptt)\n{\n\tu16 core_id, sicl_id;\n\tchar *pmu_name;\n\tu32 reg;\n\tint ret;\n\n\tret = cpuhp_state_add_instance_nocalls(hisi_ptt_pmu_online,\n\t\t\t\t\t       &hisi_ptt->hotplug_node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&hisi_ptt->pdev->dev,\n\t\t\t\t       hisi_ptt_remove_cpuhp_instance,\n\t\t\t\t       &hisi_ptt->hotplug_node);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&hisi_ptt->tune_lock);\n\tspin_lock_init(&hisi_ptt->pmu_lock);\n\n\thisi_ptt->hisi_ptt_pmu = (struct pmu) {\n\t\t.module\t\t= THIS_MODULE,\n\t\t.capabilities\t= PERF_PMU_CAP_EXCLUSIVE | PERF_PMU_CAP_NO_EXCLUDE,\n\t\t.task_ctx_nr\t= perf_sw_context,\n\t\t.attr_groups\t= hisi_ptt_pmu_groups,\n\t\t.event_init\t= hisi_ptt_pmu_event_init,\n\t\t.setup_aux\t= hisi_ptt_pmu_setup_aux,\n\t\t.free_aux\t= hisi_ptt_pmu_free_aux,\n\t\t.start\t\t= hisi_ptt_pmu_start,\n\t\t.stop\t\t= hisi_ptt_pmu_stop,\n\t\t.add\t\t= hisi_ptt_pmu_add,\n\t\t.del\t\t= hisi_ptt_pmu_del,\n\t\t.read\t\t= hisi_ptt_pmu_read,\n\t};\n\n\treg = readl(hisi_ptt->iobase + HISI_PTT_LOCATION);\n\tcore_id = FIELD_GET(HISI_PTT_CORE_ID, reg);\n\tsicl_id = FIELD_GET(HISI_PTT_SICL_ID, reg);\n\n\tpmu_name = devm_kasprintf(&hisi_ptt->pdev->dev, GFP_KERNEL, \"hisi_ptt%u_%u\",\n\t\t\t\t  sicl_id, core_id);\n\tif (!pmu_name)\n\t\treturn -ENOMEM;\n\n\tret = perf_pmu_register(&hisi_ptt->hisi_ptt_pmu, pmu_name, -1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(&hisi_ptt->pdev->dev,\n\t\t\t\t\thisi_ptt_unregister_pmu,\n\t\t\t\t\t&hisi_ptt->hisi_ptt_pmu);\n}\n\nstatic void hisi_ptt_unregister_filter_update_notifier(void *data)\n{\n\tstruct hisi_ptt *hisi_ptt = data;\n\n\tbus_unregister_notifier(&pci_bus_type, &hisi_ptt->hisi_ptt_nb);\n\n\t \n\tcancel_delayed_work_sync(&hisi_ptt->work);\n}\n\n \nstatic int hisi_ptt_register_filter_update_notifier(struct hisi_ptt *hisi_ptt)\n{\n\tint ret;\n\n\thisi_ptt->hisi_ptt_nb.notifier_call = hisi_ptt_notifier_call;\n\tret = bus_register_notifier(&pci_bus_type, &hisi_ptt->hisi_ptt_nb);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(&hisi_ptt->pdev->dev,\n\t\t\t\t\thisi_ptt_unregister_filter_update_notifier,\n\t\t\t\t\thisi_ptt);\n}\n\n \nstatic int hisi_ptt_check_iommu_mapping(struct pci_dev *pdev)\n{\n\tstruct iommu_domain *iommu_domain;\n\n\tiommu_domain = iommu_get_domain_for_dev(&pdev->dev);\n\tif (!iommu_domain || iommu_domain->type == IOMMU_DOMAIN_IDENTITY)\n\t\treturn 0;\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int hisi_ptt_probe(struct pci_dev *pdev,\n\t\t\t  const struct pci_device_id *id)\n{\n\tstruct hisi_ptt *hisi_ptt;\n\tint ret;\n\n\tret = hisi_ptt_check_iommu_mapping(pdev);\n\tif (ret) {\n\t\tpci_err(pdev, \"requires direct DMA mappings\\n\");\n\t\treturn ret;\n\t}\n\n\thisi_ptt = devm_kzalloc(&pdev->dev, sizeof(*hisi_ptt), GFP_KERNEL);\n\tif (!hisi_ptt)\n\t\treturn -ENOMEM;\n\n\thisi_ptt->pdev = pdev;\n\tpci_set_drvdata(pdev, hisi_ptt);\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to enable device, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pcim_iomap_regions(pdev, BIT(2), DRV_NAME);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to remap io memory, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thisi_ptt->iobase = pcim_iomap_table(pdev)[2];\n\n\tret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to set 64 bit dma mask, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpci_set_master(pdev);\n\n\tret = hisi_ptt_register_irq(hisi_ptt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_ptt_init_ctrls(hisi_ptt);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to init controls, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hisi_ptt_register_filter_update_notifier(hisi_ptt);\n\tif (ret)\n\t\tpci_warn(pdev, \"failed to register filter update notifier, ret = %d\", ret);\n\n\tret = hisi_ptt_register_pmu(hisi_ptt);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to register PMU device, ret = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hisi_ptt_init_filter_attributes(hisi_ptt);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to init sysfs filter attributes, ret = %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id hisi_ptt_id_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HUAWEI, 0xa12e) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, hisi_ptt_id_tbl);\n\nstatic struct pci_driver hisi_ptt_driver = {\n\t.name = DRV_NAME,\n\t.id_table = hisi_ptt_id_tbl,\n\t.probe = hisi_ptt_probe,\n};\n\nstatic int hisi_ptt_cpu_teardown(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct hisi_ptt *hisi_ptt;\n\tstruct device *dev;\n\tint target, src;\n\n\thisi_ptt = hlist_entry_safe(node, struct hisi_ptt, hotplug_node);\n\tsrc = hisi_ptt->trace_ctrl.on_cpu;\n\tdev = hisi_ptt->hisi_ptt_pmu.dev;\n\n\tif (!hisi_ptt->trace_ctrl.started || src != cpu)\n\t\treturn 0;\n\n\ttarget = cpumask_any_but(cpumask_of_node(dev_to_node(&hisi_ptt->pdev->dev)), cpu);\n\tif (target >= nr_cpu_ids) {\n\t\tdev_err(dev, \"no available cpu for perf context migration\\n\");\n\t\treturn 0;\n\t}\n\n\tperf_pmu_migrate_context(&hisi_ptt->hisi_ptt_pmu, src, target);\n\n\t \n\tif (irq_set_affinity(hisi_ptt->trace_irq, cpumask_of(target)))\n\t\tdev_warn(dev, \"failed to set the affinity of trace interrupt\\n\");\n\n\thisi_ptt->trace_ctrl.on_cpu = target;\n\treturn 0;\n}\n\nstatic int __init hisi_ptt_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, DRV_NAME, NULL,\n\t\t\t\t      hisi_ptt_cpu_teardown);\n\tif (ret < 0)\n\t\treturn ret;\n\thisi_ptt_pmu_online = ret;\n\n\tret = pci_register_driver(&hisi_ptt_driver);\n\tif (ret)\n\t\tcpuhp_remove_multi_state(hisi_ptt_pmu_online);\n\n\treturn ret;\n}\nmodule_init(hisi_ptt_init);\n\nstatic void __exit hisi_ptt_exit(void)\n{\n\tpci_unregister_driver(&hisi_ptt_driver);\n\tcpuhp_remove_multi_state(hisi_ptt_pmu_online);\n}\nmodule_exit(hisi_ptt_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Yicong Yang <yangyicong@hisilicon.com>\");\nMODULE_DESCRIPTION(\"Driver for HiSilicon PCIe tune and trace device\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}