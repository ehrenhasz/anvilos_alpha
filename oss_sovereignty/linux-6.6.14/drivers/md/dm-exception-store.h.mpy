{
  "module_name": "dm-exception-store.h",
  "hash_id": "dd5d30a217b75039e4cc99ce65ecc003cda92206ea61c3676bc18411cb407338",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-exception-store.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_DM_EXCEPTION_STORE\n#define _LINUX_DM_EXCEPTION_STORE\n\n#include <linux/blkdev.h>\n#include <linux/list_bl.h>\n#include <linux/device-mapper.h>\n\n \ntypedef sector_t chunk_t;\n\n \nstruct dm_exception {\n\tstruct hlist_bl_node hash_list;\n\n\tchunk_t old_chunk;\n\tchunk_t new_chunk;\n};\n\n \nstruct dm_exception_store;\nstruct dm_exception_store_type {\n\tconst char *name;\n\tstruct module *module;\n\n\tint (*ctr)(struct dm_exception_store *store, char *options);\n\n\t \n\tvoid (*dtr)(struct dm_exception_store *store);\n\n\t \n\tint (*read_metadata)(struct dm_exception_store *store,\n\t\t\t     int (*callback)(void *callback_context,\n\t\t\t\t\t     chunk_t old, chunk_t new),\n\t\t\t     void *callback_context);\n\n\t \n\tint (*prepare_exception)(struct dm_exception_store *store,\n\t\t\t\t struct dm_exception *e);\n\n\t \n\tvoid (*commit_exception)(struct dm_exception_store *store,\n\t\t\t\t struct dm_exception *e, int valid,\n\t\t\t\t void (*callback)(void *, int success),\n\t\t\t\t void *callback_context);\n\n\t \n\tint (*prepare_merge)(struct dm_exception_store *store,\n\t\t\t     chunk_t *last_old_chunk, chunk_t *last_new_chunk);\n\n\t \n\tint (*commit_merge)(struct dm_exception_store *store, int nr_merged);\n\n\t \n\tvoid (*drop_snapshot)(struct dm_exception_store *store);\n\n\tunsigned int (*status)(struct dm_exception_store *store,\n\t\t\t       status_type_t status, char *result,\n\t\t\t       unsigned int maxlen);\n\n\t \n\tvoid (*usage)(struct dm_exception_store *store,\n\t\t      sector_t *total_sectors, sector_t *sectors_allocated,\n\t\t      sector_t *metadata_sectors);\n\n\t \n\tstruct list_head list;\n};\n\nstruct dm_snapshot;\n\nstruct dm_exception_store {\n\tstruct dm_exception_store_type *type;\n\tstruct dm_snapshot *snap;\n\n\t \n\tunsigned int chunk_size;\n\tunsigned int chunk_mask;\n\tunsigned int chunk_shift;\n\n\tvoid *context;\n\n\tbool userspace_supports_overflow;\n};\n\n \nstruct dm_dev *dm_snap_origin(struct dm_snapshot *snap);\nstruct dm_dev *dm_snap_cow(struct dm_snapshot *snap);\n\n \n#define DM_CHUNK_CONSECUTIVE_BITS 8\n#define DM_CHUNK_NUMBER_BITS 56\n\nstatic inline chunk_t dm_chunk_number(chunk_t chunk)\n{\n\treturn chunk & (chunk_t)((1ULL << DM_CHUNK_NUMBER_BITS) - 1ULL);\n}\n\nstatic inline unsigned int dm_consecutive_chunk_count(struct dm_exception *e)\n{\n\treturn e->new_chunk >> DM_CHUNK_NUMBER_BITS;\n}\n\nstatic inline void dm_consecutive_chunk_count_inc(struct dm_exception *e)\n{\n\te->new_chunk += (1ULL << DM_CHUNK_NUMBER_BITS);\n\n\tBUG_ON(!dm_consecutive_chunk_count(e));\n}\n\nstatic inline void dm_consecutive_chunk_count_dec(struct dm_exception *e)\n{\n\tBUG_ON(!dm_consecutive_chunk_count(e));\n\n\te->new_chunk -= (1ULL << DM_CHUNK_NUMBER_BITS);\n}\n\n \nstatic inline sector_t get_dev_size(struct block_device *bdev)\n{\n\treturn bdev_nr_sectors(bdev);\n}\n\nstatic inline chunk_t sector_to_chunk(struct dm_exception_store *store,\n\t\t\t\t      sector_t sector)\n{\n\treturn sector >> store->chunk_shift;\n}\n\nint dm_exception_store_type_register(struct dm_exception_store_type *type);\nint dm_exception_store_type_unregister(struct dm_exception_store_type *type);\n\nint dm_exception_store_set_chunk_size(struct dm_exception_store *store,\n\t\t\t\t      unsigned int chunk_size,\n\t\t\t\t      char **error);\n\nint dm_exception_store_create(struct dm_target *ti, int argc, char **argv,\n\t\t\t      struct dm_snapshot *snap,\n\t\t\t      unsigned int *args_used,\n\t\t\t      struct dm_exception_store **store);\nvoid dm_exception_store_destroy(struct dm_exception_store *store);\n\nint dm_exception_store_init(void);\nvoid dm_exception_store_exit(void);\n\n \nint dm_persistent_snapshot_init(void);\nvoid dm_persistent_snapshot_exit(void);\n\nint dm_transient_snapshot_init(void);\nvoid dm_transient_snapshot_exit(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}