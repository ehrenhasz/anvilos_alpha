{
  "module_name": "raid0.c",
  "hash_id": "e2d6a868e07ffc48a28eb3d5701b9ac04d0dcdaa2d35423ae8360a8681042c9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/raid0.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <trace/events/block.h>\n#include \"md.h\"\n#include \"raid0.h\"\n#include \"raid5.h\"\n\nstatic int default_layout = 0;\nmodule_param(default_layout, int, 0644);\n\n#define UNSUPPORTED_MDDEV_FLAGS\t\t\\\n\t((1L << MD_HAS_JOURNAL) |\t\\\n\t (1L << MD_JOURNAL_CLEAN) |\t\\\n\t (1L << MD_FAILFAST_SUPPORTED) |\\\n\t (1L << MD_HAS_PPL) |\t\t\\\n\t (1L << MD_HAS_MULTIPLE_PPLS))\n\n \nstatic void dump_zones(struct mddev *mddev)\n{\n\tint j, k;\n\tsector_t zone_size = 0;\n\tsector_t zone_start = 0;\n\tstruct r0conf *conf = mddev->private;\n\tint raid_disks = conf->strip_zone[0].nb_dev;\n\tpr_debug(\"md: RAID0 configuration for %s - %d zone%s\\n\",\n\t\t mdname(mddev),\n\t\t conf->nr_strip_zones, conf->nr_strip_zones==1?\"\":\"s\");\n\tfor (j = 0; j < conf->nr_strip_zones; j++) {\n\t\tchar line[200];\n\t\tint len = 0;\n\n\t\tfor (k = 0; k < conf->strip_zone[j].nb_dev; k++)\n\t\t\tlen += scnprintf(line+len, 200-len, \"%s%pg\", k?\"/\":\"\",\n\t\t\t\tconf->devlist[j * raid_disks + k]->bdev);\n\t\tpr_debug(\"md: zone%d=[%s]\\n\", j, line);\n\n\t\tzone_size  = conf->strip_zone[j].zone_end - zone_start;\n\t\tpr_debug(\"      zone-offset=%10lluKB, device-offset=%10lluKB, size=%10lluKB\\n\",\n\t\t\t(unsigned long long)zone_start>>1,\n\t\t\t(unsigned long long)conf->strip_zone[j].dev_start>>1,\n\t\t\t(unsigned long long)zone_size>>1);\n\t\tzone_start = conf->strip_zone[j].zone_end;\n\t}\n}\n\nstatic int create_strip_zones(struct mddev *mddev, struct r0conf **private_conf)\n{\n\tint i, c, err;\n\tsector_t curr_zone_end, sectors;\n\tstruct md_rdev *smallest, *rdev1, *rdev2, *rdev, **dev;\n\tstruct strip_zone *zone;\n\tint cnt;\n\tstruct r0conf *conf = kzalloc(sizeof(*conf), GFP_KERNEL);\n\tunsigned blksize = 512;\n\n\t*private_conf = ERR_PTR(-ENOMEM);\n\tif (!conf)\n\t\treturn -ENOMEM;\n\trdev_for_each(rdev1, mddev) {\n\t\tpr_debug(\"md/raid0:%s: looking at %pg\\n\",\n\t\t\t mdname(mddev),\n\t\t\t rdev1->bdev);\n\t\tc = 0;\n\n\t\t \n\t\tsectors = rdev1->sectors;\n\t\tsector_div(sectors, mddev->chunk_sectors);\n\t\trdev1->sectors = sectors * mddev->chunk_sectors;\n\n\t\tblksize = max(blksize, queue_logical_block_size(\n\t\t\t\t      rdev1->bdev->bd_disk->queue));\n\n\t\trdev_for_each(rdev2, mddev) {\n\t\t\tpr_debug(\"md/raid0:%s:   comparing %pg(%llu)\"\n\t\t\t\t \" with %pg(%llu)\\n\",\n\t\t\t\t mdname(mddev),\n\t\t\t\t rdev1->bdev,\n\t\t\t\t (unsigned long long)rdev1->sectors,\n\t\t\t\t rdev2->bdev,\n\t\t\t\t (unsigned long long)rdev2->sectors);\n\t\t\tif (rdev2 == rdev1) {\n\t\t\t\tpr_debug(\"md/raid0:%s:   END\\n\",\n\t\t\t\t\t mdname(mddev));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rdev2->sectors == rdev1->sectors) {\n\t\t\t\t \n\t\t\t\tpr_debug(\"md/raid0:%s:   EQUAL\\n\",\n\t\t\t\t\t mdname(mddev));\n\t\t\t\tc = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpr_debug(\"md/raid0:%s:   NOT EQUAL\\n\",\n\t\t\t\t mdname(mddev));\n\t\t}\n\t\tif (!c) {\n\t\t\tpr_debug(\"md/raid0:%s:   ==> UNIQUE\\n\",\n\t\t\t\t mdname(mddev));\n\t\t\tconf->nr_strip_zones++;\n\t\t\tpr_debug(\"md/raid0:%s: %d zones\\n\",\n\t\t\t\t mdname(mddev), conf->nr_strip_zones);\n\t\t}\n\t}\n\tpr_debug(\"md/raid0:%s: FINAL %d zones\\n\",\n\t\t mdname(mddev), conf->nr_strip_zones);\n\n\t \n\tif ((mddev->chunk_sectors << 9) % blksize) {\n\t\tpr_warn(\"md/raid0:%s: chunk_size of %d not multiple of block size %d\\n\",\n\t\t\tmdname(mddev),\n\t\t\tmddev->chunk_sectors << 9, blksize);\n\t\terr = -EINVAL;\n\t\tgoto abort;\n\t}\n\n\terr = -ENOMEM;\n\tconf->strip_zone = kcalloc(conf->nr_strip_zones,\n\t\t\t\t   sizeof(struct strip_zone),\n\t\t\t\t   GFP_KERNEL);\n\tif (!conf->strip_zone)\n\t\tgoto abort;\n\tconf->devlist = kzalloc(array3_size(sizeof(struct md_rdev *),\n\t\t\t\t\t    conf->nr_strip_zones,\n\t\t\t\t\t    mddev->raid_disks),\n\t\t\t\tGFP_KERNEL);\n\tif (!conf->devlist)\n\t\tgoto abort;\n\n\t \n\tzone = &conf->strip_zone[0];\n\tcnt = 0;\n\tsmallest = NULL;\n\tdev = conf->devlist;\n\terr = -EINVAL;\n\trdev_for_each(rdev1, mddev) {\n\t\tint j = rdev1->raid_disk;\n\n\t\tif (mddev->level == 10) {\n\t\t\t \n\t\t\tj /= 2;\n\t\t\trdev1->new_raid_disk = j;\n\t\t}\n\n\t\tif (mddev->level == 1) {\n\t\t\t \n\t\t\tj = 0;\n\t\t\trdev1->new_raid_disk = j;\n\t\t}\n\n\t\tif (j < 0) {\n\t\t\tpr_warn(\"md/raid0:%s: remove inactive devices before converting to RAID0\\n\",\n\t\t\t\tmdname(mddev));\n\t\t\tgoto abort;\n\t\t}\n\t\tif (j >= mddev->raid_disks) {\n\t\t\tpr_warn(\"md/raid0:%s: bad disk number %d - aborting!\\n\",\n\t\t\t\tmdname(mddev), j);\n\t\t\tgoto abort;\n\t\t}\n\t\tif (dev[j]) {\n\t\t\tpr_warn(\"md/raid0:%s: multiple devices for %d - aborting!\\n\",\n\t\t\t\tmdname(mddev), j);\n\t\t\tgoto abort;\n\t\t}\n\t\tdev[j] = rdev1;\n\n\t\tif (!smallest || (rdev1->sectors < smallest->sectors))\n\t\t\tsmallest = rdev1;\n\t\tcnt++;\n\t}\n\tif (cnt != mddev->raid_disks) {\n\t\tpr_warn(\"md/raid0:%s: too few disks (%d of %d) - aborting!\\n\",\n\t\t\tmdname(mddev), cnt, mddev->raid_disks);\n\t\tgoto abort;\n\t}\n\tzone->nb_dev = cnt;\n\tzone->zone_end = smallest->sectors * cnt;\n\n\tcurr_zone_end = zone->zone_end;\n\n\t \n\tfor (i = 1; i < conf->nr_strip_zones; i++)\n\t{\n\t\tint j;\n\n\t\tzone = conf->strip_zone + i;\n\t\tdev = conf->devlist + i * mddev->raid_disks;\n\n\t\tpr_debug(\"md/raid0:%s: zone %d\\n\", mdname(mddev), i);\n\t\tzone->dev_start = smallest->sectors;\n\t\tsmallest = NULL;\n\t\tc = 0;\n\n\t\tfor (j=0; j<cnt; j++) {\n\t\t\trdev = conf->devlist[j];\n\t\t\tif (rdev->sectors <= zone->dev_start) {\n\t\t\t\tpr_debug(\"md/raid0:%s: checking %pg ... nope\\n\",\n\t\t\t\t\t mdname(mddev),\n\t\t\t\t\t rdev->bdev);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpr_debug(\"md/raid0:%s: checking %pg ...\"\n\t\t\t\t \" contained as device %d\\n\",\n\t\t\t\t mdname(mddev),\n\t\t\t\t rdev->bdev, c);\n\t\t\tdev[c] = rdev;\n\t\t\tc++;\n\t\t\tif (!smallest || rdev->sectors < smallest->sectors) {\n\t\t\t\tsmallest = rdev;\n\t\t\t\tpr_debug(\"md/raid0:%s:  (%llu) is smallest!.\\n\",\n\t\t\t\t\t mdname(mddev),\n\t\t\t\t\t (unsigned long long)rdev->sectors);\n\t\t\t}\n\t\t}\n\n\t\tzone->nb_dev = c;\n\t\tsectors = (smallest->sectors - zone->dev_start) * c;\n\t\tpr_debug(\"md/raid0:%s: zone->nb_dev: %d, sectors: %llu\\n\",\n\t\t\t mdname(mddev),\n\t\t\t zone->nb_dev, (unsigned long long)sectors);\n\n\t\tcurr_zone_end += sectors;\n\t\tzone->zone_end = curr_zone_end;\n\n\t\tpr_debug(\"md/raid0:%s: current zone start: %llu\\n\",\n\t\t\t mdname(mddev),\n\t\t\t (unsigned long long)smallest->sectors);\n\t}\n\n\tif (conf->nr_strip_zones == 1 || conf->strip_zone[1].nb_dev == 1) {\n\t\tconf->layout = RAID0_ORIG_LAYOUT;\n\t} else if (mddev->layout == RAID0_ORIG_LAYOUT ||\n\t\t   mddev->layout == RAID0_ALT_MULTIZONE_LAYOUT) {\n\t\tconf->layout = mddev->layout;\n\t} else if (default_layout == RAID0_ORIG_LAYOUT ||\n\t\t   default_layout == RAID0_ALT_MULTIZONE_LAYOUT) {\n\t\tconf->layout = default_layout;\n\t} else {\n\t\tpr_err(\"md/raid0:%s: cannot assemble multi-zone RAID0 with default_layout setting\\n\",\n\t\t       mdname(mddev));\n\t\tpr_err(\"md/raid0: please set raid0.default_layout to 1 or 2\\n\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto abort;\n\t}\n\n\tif (conf->layout == RAID0_ORIG_LAYOUT) {\n\t\tfor (i = 1; i < conf->nr_strip_zones; i++) {\n\t\t\tsector_t first_sector = conf->strip_zone[i-1].zone_end;\n\n\t\t\tsector_div(first_sector, mddev->chunk_sectors);\n\t\t\tzone = conf->strip_zone + i;\n\t\t\t \n\t\t\tzone->disk_shift = sector_div(first_sector,\n\t\t\t\t\t\t      zone->nb_dev);\n\t\t}\n\t}\n\n\tpr_debug(\"md/raid0:%s: done.\\n\", mdname(mddev));\n\t*private_conf = conf;\n\n\treturn 0;\nabort:\n\tkfree(conf->strip_zone);\n\tkfree(conf->devlist);\n\tkfree(conf);\n\t*private_conf = ERR_PTR(err);\n\treturn err;\n}\n\n \nstatic struct strip_zone *find_zone(struct r0conf *conf,\n\t\t\t\t    sector_t *sectorp)\n{\n\tint i;\n\tstruct strip_zone *z = conf->strip_zone;\n\tsector_t sector = *sectorp;\n\n\tfor (i = 0; i < conf->nr_strip_zones; i++)\n\t\tif (sector < z[i].zone_end) {\n\t\t\tif (i)\n\t\t\t\t*sectorp = sector - z[i-1].zone_end;\n\t\t\treturn z + i;\n\t\t}\n\tBUG();\n}\n\n \nstatic struct md_rdev *map_sector(struct mddev *mddev, struct strip_zone *zone,\n\t\t\t\tsector_t sector, sector_t *sector_offset)\n{\n\tunsigned int sect_in_chunk;\n\tsector_t chunk;\n\tstruct r0conf *conf = mddev->private;\n\tint raid_disks = conf->strip_zone[0].nb_dev;\n\tunsigned int chunk_sects = mddev->chunk_sectors;\n\n\tif (is_power_of_2(chunk_sects)) {\n\t\tint chunksect_bits = ffz(~chunk_sects);\n\t\t \n\t\tsect_in_chunk  = sector & (chunk_sects - 1);\n\t\tsector >>= chunksect_bits;\n\t\t \n\t\tchunk = *sector_offset;\n\t\t \n\t\tsector_div(chunk, zone->nb_dev << chunksect_bits);\n\t} else{\n\t\tsect_in_chunk = sector_div(sector, chunk_sects);\n\t\tchunk = *sector_offset;\n\t\tsector_div(chunk, chunk_sects * zone->nb_dev);\n\t}\n\t \n\t*sector_offset = (chunk * chunk_sects) + sect_in_chunk;\n\treturn conf->devlist[(zone - conf->strip_zone)*raid_disks\n\t\t\t     + sector_div(sector, zone->nb_dev)];\n}\n\nstatic sector_t raid0_size(struct mddev *mddev, sector_t sectors, int raid_disks)\n{\n\tsector_t array_sectors = 0;\n\tstruct md_rdev *rdev;\n\n\tWARN_ONCE(sectors || raid_disks,\n\t\t  \"%s does not support generic reshape\\n\", __func__);\n\n\trdev_for_each(rdev, mddev)\n\t\tarray_sectors += (rdev->sectors &\n\t\t\t\t  ~(sector_t)(mddev->chunk_sectors-1));\n\n\treturn array_sectors;\n}\n\nstatic void free_conf(struct mddev *mddev, struct r0conf *conf)\n{\n\tkfree(conf->strip_zone);\n\tkfree(conf->devlist);\n\tkfree(conf);\n}\n\nstatic void raid0_free(struct mddev *mddev, void *priv)\n{\n\tstruct r0conf *conf = priv;\n\n\tfree_conf(mddev, conf);\n}\n\nstatic int raid0_run(struct mddev *mddev)\n{\n\tstruct r0conf *conf;\n\tint ret;\n\n\tif (mddev->chunk_sectors == 0) {\n\t\tpr_warn(\"md/raid0:%s: chunk size must be set.\\n\", mdname(mddev));\n\t\treturn -EINVAL;\n\t}\n\tif (md_check_no_bitmap(mddev))\n\t\treturn -EINVAL;\n\n\t \n\tif (mddev->private == NULL) {\n\t\tret = create_strip_zones(mddev, &conf);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmddev->private = conf;\n\t}\n\tconf = mddev->private;\n\tif (mddev->queue) {\n\t\tstruct md_rdev *rdev;\n\n\t\tblk_queue_max_hw_sectors(mddev->queue, mddev->chunk_sectors);\n\t\tblk_queue_max_write_zeroes_sectors(mddev->queue, mddev->chunk_sectors);\n\n\t\tblk_queue_io_min(mddev->queue, mddev->chunk_sectors << 9);\n\t\tblk_queue_io_opt(mddev->queue,\n\t\t\t\t (mddev->chunk_sectors << 9) * mddev->raid_disks);\n\n\t\trdev_for_each(rdev, mddev) {\n\t\t\tdisk_stack_limits(mddev->gendisk, rdev->bdev,\n\t\t\t\t\t  rdev->data_offset << 9);\n\t\t}\n\t}\n\n\t \n\tmd_set_array_sectors(mddev, raid0_size(mddev, 0, 0));\n\n\tpr_debug(\"md/raid0:%s: md_size is %llu sectors.\\n\",\n\t\t mdname(mddev),\n\t\t (unsigned long long)mddev->array_sectors);\n\n\tdump_zones(mddev);\n\n\tret = md_integrity_register(mddev);\n\tif (ret)\n\t\tfree_conf(mddev, conf);\n\n\treturn ret;\n}\n\n \nstatic int map_disk_shift(int disk_index, int num_disks, int disk_shift)\n{\n\treturn ((disk_index + num_disks - disk_shift) % num_disks);\n}\n\nstatic void raid0_handle_discard(struct mddev *mddev, struct bio *bio)\n{\n\tstruct r0conf *conf = mddev->private;\n\tstruct strip_zone *zone;\n\tsector_t start = bio->bi_iter.bi_sector;\n\tsector_t end;\n\tunsigned int stripe_size;\n\tsector_t first_stripe_index, last_stripe_index;\n\tsector_t start_disk_offset;\n\tunsigned int start_disk_index;\n\tsector_t end_disk_offset;\n\tunsigned int end_disk_index;\n\tunsigned int disk;\n\tsector_t orig_start, orig_end;\n\n\torig_start = start;\n\tzone = find_zone(conf, &start);\n\n\tif (bio_end_sector(bio) > zone->zone_end) {\n\t\tstruct bio *split = bio_split(bio,\n\t\t\tzone->zone_end - bio->bi_iter.bi_sector, GFP_NOIO,\n\t\t\t&mddev->bio_set);\n\t\tbio_chain(split, bio);\n\t\tsubmit_bio_noacct(bio);\n\t\tbio = split;\n\t\tend = zone->zone_end;\n\t} else\n\t\tend = bio_end_sector(bio);\n\n\torig_end = end;\n\tif (zone != conf->strip_zone)\n\t\tend = end - zone[-1].zone_end;\n\n\t \n\tstripe_size = zone->nb_dev * mddev->chunk_sectors;\n\n\tfirst_stripe_index = start;\n\tsector_div(first_stripe_index, stripe_size);\n\tlast_stripe_index = end;\n\tsector_div(last_stripe_index, stripe_size);\n\n\t \n\tif ((conf->layout == RAID0_ORIG_LAYOUT) && (zone != conf->strip_zone)) {\n\t\tsector_div(orig_start, mddev->chunk_sectors);\n\t\tstart_disk_index = sector_div(orig_start, zone->nb_dev);\n\t\tstart_disk_index = map_disk_shift(start_disk_index,\n\t\t\t\t\t\t  zone->nb_dev,\n\t\t\t\t\t\t  zone->disk_shift);\n\t\tsector_div(orig_end, mddev->chunk_sectors);\n\t\tend_disk_index = sector_div(orig_end, zone->nb_dev);\n\t\tend_disk_index = map_disk_shift(end_disk_index,\n\t\t\t\t\t\tzone->nb_dev, zone->disk_shift);\n\t} else {\n\t\tstart_disk_index = (int)(start - first_stripe_index * stripe_size) /\n\t\t\tmddev->chunk_sectors;\n\t\tend_disk_index = (int)(end - last_stripe_index * stripe_size) /\n\t\t\tmddev->chunk_sectors;\n\t}\n\tstart_disk_offset = ((int)(start - first_stripe_index * stripe_size) %\n\t\tmddev->chunk_sectors) +\n\t\tfirst_stripe_index * mddev->chunk_sectors;\n\tend_disk_offset = ((int)(end - last_stripe_index * stripe_size) %\n\t\tmddev->chunk_sectors) +\n\t\tlast_stripe_index * mddev->chunk_sectors;\n\n\tfor (disk = 0; disk < zone->nb_dev; disk++) {\n\t\tsector_t dev_start, dev_end;\n\t\tstruct md_rdev *rdev;\n\t\tint compare_disk;\n\n\t\tcompare_disk = map_disk_shift(disk, zone->nb_dev,\n\t\t\t\t\t      zone->disk_shift);\n\n\t\tif (compare_disk < start_disk_index)\n\t\t\tdev_start = (first_stripe_index + 1) *\n\t\t\t\tmddev->chunk_sectors;\n\t\telse if (compare_disk > start_disk_index)\n\t\t\tdev_start = first_stripe_index * mddev->chunk_sectors;\n\t\telse\n\t\t\tdev_start = start_disk_offset;\n\n\t\tif (compare_disk < end_disk_index)\n\t\t\tdev_end = (last_stripe_index + 1) * mddev->chunk_sectors;\n\t\telse if (compare_disk > end_disk_index)\n\t\t\tdev_end = last_stripe_index * mddev->chunk_sectors;\n\t\telse\n\t\t\tdev_end = end_disk_offset;\n\n\t\tif (dev_end <= dev_start)\n\t\t\tcontinue;\n\n\t\trdev = conf->devlist[(zone - conf->strip_zone) *\n\t\t\tconf->strip_zone[0].nb_dev + disk];\n\t\tmd_submit_discard_bio(mddev, rdev, bio,\n\t\t\tdev_start + zone->dev_start + rdev->data_offset,\n\t\t\tdev_end - dev_start);\n\t}\n\tbio_endio(bio);\n}\n\nstatic void raid0_map_submit_bio(struct mddev *mddev, struct bio *bio)\n{\n\tstruct r0conf *conf = mddev->private;\n\tstruct strip_zone *zone;\n\tstruct md_rdev *tmp_dev;\n\tsector_t bio_sector = bio->bi_iter.bi_sector;\n\tsector_t sector = bio_sector;\n\n\tmd_account_bio(mddev, &bio);\n\n\tzone = find_zone(mddev->private, &sector);\n\tswitch (conf->layout) {\n\tcase RAID0_ORIG_LAYOUT:\n\t\ttmp_dev = map_sector(mddev, zone, bio_sector, &sector);\n\t\tbreak;\n\tcase RAID0_ALT_MULTIZONE_LAYOUT:\n\t\ttmp_dev = map_sector(mddev, zone, sector, &sector);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"md/raid0:%s: Invalid layout\\n\", mdname(mddev));\n\t\tbio_io_error(bio);\n\t\treturn;\n\t}\n\n\tif (unlikely(is_rdev_broken(tmp_dev))) {\n\t\tbio_io_error(bio);\n\t\tmd_error(mddev, tmp_dev);\n\t\treturn;\n\t}\n\n\tbio_set_dev(bio, tmp_dev->bdev);\n\tbio->bi_iter.bi_sector = sector + zone->dev_start +\n\t\ttmp_dev->data_offset;\n\n\tif (mddev->gendisk)\n\t\ttrace_block_bio_remap(bio, disk_devt(mddev->gendisk),\n\t\t\t\t      bio_sector);\n\tmddev_check_write_zeroes(mddev, bio);\n\tsubmit_bio_noacct(bio);\n}\n\nstatic bool raid0_make_request(struct mddev *mddev, struct bio *bio)\n{\n\tsector_t sector;\n\tunsigned chunk_sects;\n\tunsigned sectors;\n\n\tif (unlikely(bio->bi_opf & REQ_PREFLUSH)\n\t    && md_flush_request(mddev, bio))\n\t\treturn true;\n\n\tif (unlikely((bio_op(bio) == REQ_OP_DISCARD))) {\n\t\traid0_handle_discard(mddev, bio);\n\t\treturn true;\n\t}\n\n\tsector = bio->bi_iter.bi_sector;\n\tchunk_sects = mddev->chunk_sectors;\n\n\tsectors = chunk_sects -\n\t\t(likely(is_power_of_2(chunk_sects))\n\t\t ? (sector & (chunk_sects-1))\n\t\t : sector_div(sector, chunk_sects));\n\n\tif (sectors < bio_sectors(bio)) {\n\t\tstruct bio *split = bio_split(bio, sectors, GFP_NOIO,\n\t\t\t\t\t      &mddev->bio_set);\n\t\tbio_chain(split, bio);\n\t\traid0_map_submit_bio(mddev, bio);\n\t\tbio = split;\n\t}\n\n\traid0_map_submit_bio(mddev, bio);\n\treturn true;\n}\n\nstatic void raid0_status(struct seq_file *seq, struct mddev *mddev)\n{\n\tseq_printf(seq, \" %dk chunks\", mddev->chunk_sectors / 2);\n\treturn;\n}\n\nstatic void raid0_error(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tif (!test_and_set_bit(MD_BROKEN, &mddev->flags)) {\n\t\tchar *md_name = mdname(mddev);\n\n\t\tpr_crit(\"md/raid0%s: Disk failure on %pg detected, failing array.\\n\",\n\t\t\tmd_name, rdev->bdev);\n\t}\n}\n\nstatic void *raid0_takeover_raid45(struct mddev *mddev)\n{\n\tstruct md_rdev *rdev;\n\tstruct r0conf *priv_conf;\n\n\tif (mddev->degraded != 1) {\n\t\tpr_warn(\"md/raid0:%s: raid5 must be degraded! Degraded disks: %d\\n\",\n\t\t\tmdname(mddev),\n\t\t\tmddev->degraded);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\trdev_for_each(rdev, mddev) {\n\t\t \n\t\tif (rdev->raid_disk == mddev->raid_disks-1) {\n\t\t\tpr_warn(\"md/raid0:%s: raid5 must have missing parity disk!\\n\",\n\t\t\t\tmdname(mddev));\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\trdev->sectors = mddev->dev_sectors;\n\t}\n\n\t \n\tmddev->new_level = 0;\n\tmddev->new_layout = 0;\n\tmddev->new_chunk_sectors = mddev->chunk_sectors;\n\tmddev->raid_disks--;\n\tmddev->delta_disks = -1;\n\t \n\tmddev->recovery_cp = MaxSector;\n\tmddev_clear_unsupported_flags(mddev, UNSUPPORTED_MDDEV_FLAGS);\n\n\tcreate_strip_zones(mddev, &priv_conf);\n\n\treturn priv_conf;\n}\n\nstatic void *raid0_takeover_raid10(struct mddev *mddev)\n{\n\tstruct r0conf *priv_conf;\n\n\t \n\tif (mddev->layout != ((1 << 8) + 2)) {\n\t\tpr_warn(\"md/raid0:%s:: Raid0 cannot takeover layout: 0x%x\\n\",\n\t\t\tmdname(mddev),\n\t\t\tmddev->layout);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (mddev->raid_disks & 1) {\n\t\tpr_warn(\"md/raid0:%s: Raid0 cannot takeover Raid10 with odd disk number.\\n\",\n\t\t\tmdname(mddev));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (mddev->degraded != (mddev->raid_disks>>1)) {\n\t\tpr_warn(\"md/raid0:%s: All mirrors must be already degraded!\\n\",\n\t\t\tmdname(mddev));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tmddev->new_level = 0;\n\tmddev->new_layout = 0;\n\tmddev->new_chunk_sectors = mddev->chunk_sectors;\n\tmddev->delta_disks = - mddev->raid_disks / 2;\n\tmddev->raid_disks += mddev->delta_disks;\n\tmddev->degraded = 0;\n\t \n\tmddev->recovery_cp = MaxSector;\n\tmddev_clear_unsupported_flags(mddev, UNSUPPORTED_MDDEV_FLAGS);\n\n\tcreate_strip_zones(mddev, &priv_conf);\n\treturn priv_conf;\n}\n\nstatic void *raid0_takeover_raid1(struct mddev *mddev)\n{\n\tstruct r0conf *priv_conf;\n\tint chunksect;\n\n\t \n\tif ((mddev->raid_disks - 1) != mddev->degraded) {\n\t\tpr_err(\"md/raid0:%s: (N - 1) mirrors drives must be already faulty!\\n\",\n\t\t       mdname(mddev));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tchunksect = 64 * 2;  \n\n\t \n\twhile (chunksect && (mddev->array_sectors & (chunksect - 1)))\n\t\tchunksect >>= 1;\n\n\tif ((chunksect << 9) < PAGE_SIZE)\n\t\t \n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tmddev->new_level = 0;\n\tmddev->new_layout = 0;\n\tmddev->new_chunk_sectors = chunksect;\n\tmddev->chunk_sectors = chunksect;\n\tmddev->delta_disks = 1 - mddev->raid_disks;\n\tmddev->raid_disks = 1;\n\t \n\tmddev->recovery_cp = MaxSector;\n\tmddev_clear_unsupported_flags(mddev, UNSUPPORTED_MDDEV_FLAGS);\n\n\tcreate_strip_zones(mddev, &priv_conf);\n\treturn priv_conf;\n}\n\nstatic void *raid0_takeover(struct mddev *mddev)\n{\n\t \n\n\tif (mddev->bitmap) {\n\t\tpr_warn(\"md/raid0: %s: cannot takeover array with bitmap\\n\",\n\t\t\tmdname(mddev));\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tif (mddev->level == 4)\n\t\treturn raid0_takeover_raid45(mddev);\n\n\tif (mddev->level == 5) {\n\t\tif (mddev->layout == ALGORITHM_PARITY_N)\n\t\t\treturn raid0_takeover_raid45(mddev);\n\n\t\tpr_warn(\"md/raid0:%s: Raid can only takeover Raid5 with layout: %d\\n\",\n\t\t\tmdname(mddev), ALGORITHM_PARITY_N);\n\t}\n\n\tif (mddev->level == 10)\n\t\treturn raid0_takeover_raid10(mddev);\n\n\tif (mddev->level == 1)\n\t\treturn raid0_takeover_raid1(mddev);\n\n\tpr_warn(\"Takeover from raid%i to raid0 not supported\\n\",\n\t\tmddev->level);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void raid0_quiesce(struct mddev *mddev, int quiesce)\n{\n}\n\nstatic struct md_personality raid0_personality=\n{\n\t.name\t\t= \"raid0\",\n\t.level\t\t= 0,\n\t.owner\t\t= THIS_MODULE,\n\t.make_request\t= raid0_make_request,\n\t.run\t\t= raid0_run,\n\t.free\t\t= raid0_free,\n\t.status\t\t= raid0_status,\n\t.size\t\t= raid0_size,\n\t.takeover\t= raid0_takeover,\n\t.quiesce\t= raid0_quiesce,\n\t.error_handler\t= raid0_error,\n};\n\nstatic int __init raid0_init (void)\n{\n\treturn register_md_personality (&raid0_personality);\n}\n\nstatic void raid0_exit (void)\n{\n\tunregister_md_personality (&raid0_personality);\n}\n\nmodule_init(raid0_init);\nmodule_exit(raid0_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"RAID0 (striping) personality for MD\");\nMODULE_ALIAS(\"md-personality-2\");  \nMODULE_ALIAS(\"md-raid0\");\nMODULE_ALIAS(\"md-level-0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}