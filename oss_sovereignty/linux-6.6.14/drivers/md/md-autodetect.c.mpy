{
  "module_name": "md-autodetect.c",
  "hash_id": "f65443eaa6e449d9ebb5aff28614cd3761a1a9d5addb0ec0ada009a08e712a59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/md-autodetect.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/delay.h>\n#include <linux/init_syscalls.h>\n#include <linux/raid/detect.h>\n#include <linux/raid/md_u.h>\n#include <linux/raid/md_p.h>\n#include \"md.h\"\n\n \n\n#ifdef CONFIG_MD_AUTODETECT\nstatic int __initdata raid_noautodetect;\n#else\nstatic int __initdata raid_noautodetect=1;\n#endif\nstatic int __initdata raid_autopart;\n\nstatic struct md_setup_args {\n\tint minor;\n\tint partitioned;\n\tint level;\n\tint chunk;\n\tchar *device_names;\n} md_setup_args[256] __initdata;\n\nstatic int md_setup_ents __initdata;\n\n \nstatic int __init md_setup(char *str)\n{\n\tint minor, level, factor, fault, partitioned = 0;\n\tchar *pername = \"\";\n\tchar *str1;\n\tint ent;\n\n\tif (*str == 'd') {\n\t\tpartitioned = 1;\n\t\tstr++;\n\t}\n\tif (get_option(&str, &minor) != 2) {\t \n\t\tprintk(KERN_WARNING \"md: Too few arguments supplied to md=.\\n\");\n\t\treturn 0;\n\t}\n\tstr1 = str;\n\tfor (ent=0 ; ent< md_setup_ents ; ent++)\n\t\tif (md_setup_args[ent].minor == minor &&\n\t\t    md_setup_args[ent].partitioned == partitioned) {\n\t\t\tprintk(KERN_WARNING \"md: md=%s%d, Specified more than once. \"\n\t\t\t       \"Replacing previous definition.\\n\", partitioned?\"d\":\"\", minor);\n\t\t\tbreak;\n\t\t}\n\tif (ent >= ARRAY_SIZE(md_setup_args)) {\n\t\tprintk(KERN_WARNING \"md: md=%s%d - too many md initialisations\\n\", partitioned?\"d\":\"\", minor);\n\t\treturn 0;\n\t}\n\tif (ent >= md_setup_ents)\n\t\tmd_setup_ents++;\n\tswitch (get_option(&str, &level)) {\t \n\tcase 2:  \n\t\tif (level == 0 || level == LEVEL_LINEAR) {\n\t\t\tif (get_option(&str, &factor) != 2 ||\t \n\t\t\t\t\tget_option(&str, &fault) != 2) {\n\t\t\t\tprintk(KERN_WARNING \"md: Too few arguments supplied to md=.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmd_setup_args[ent].level = level;\n\t\t\tmd_setup_args[ent].chunk = 1 << (factor+12);\n\t\t\tif (level ==  LEVEL_LINEAR)\n\t\t\t\tpername = \"linear\";\n\t\t\telse\n\t\t\t\tpername = \"raid0\";\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase 1:  \n\t\tstr = str1;\n\t\tfallthrough;\n\tcase 0:\n\t\tmd_setup_args[ent].level = LEVEL_NONE;\n\t\tpername=\"super-block\";\n\t}\n\n\tprintk(KERN_INFO \"md: Will configure md%d (%s) from %s, below.\\n\",\n\t\tminor, pername, str);\n\tmd_setup_args[ent].device_names = str;\n\tmd_setup_args[ent].partitioned = partitioned;\n\tmd_setup_args[ent].minor = minor;\n\n\treturn 1;\n}\n\nstatic void __init md_setup_drive(struct md_setup_args *args)\n{\n\tchar *devname = args->device_names;\n\tdev_t devices[MD_SB_DISKS + 1], mdev;\n\tstruct mdu_array_info_s ainfo = { };\n\tstruct mddev *mddev;\n\tint err = 0, i;\n\tchar name[16];\n\n\tif (args->partitioned) {\n\t\tmdev = MKDEV(mdp_major, args->minor << MdpMinorShift);\n\t\tsprintf(name, \"md_d%d\", args->minor);\n\t} else {\n\t\tmdev = MKDEV(MD_MAJOR, args->minor);\n\t\tsprintf(name, \"md%d\", args->minor);\n\t}\n\n\tfor (i = 0; i < MD_SB_DISKS && devname != NULL; i++) {\n\t\tstruct kstat stat;\n\t\tchar *p;\n\t\tchar comp_name[64];\n\t\tdev_t dev;\n\n\t\tp = strchr(devname, ',');\n\t\tif (p)\n\t\t\t*p++ = 0;\n\n\t\tif (early_lookup_bdev(devname, &dev))\n\t\t\tdev = 0;\n\t\tif (strncmp(devname, \"/dev/\", 5) == 0)\n\t\t\tdevname += 5;\n\t\tsnprintf(comp_name, 63, \"/dev/%s\", devname);\n\t\tif (init_stat(comp_name, &stat, 0) == 0 && S_ISBLK(stat.mode))\n\t\t\tdev = new_decode_dev(stat.rdev);\n\t\tif (!dev) {\n\t\t\tpr_warn(\"md: Unknown device name: %s\\n\", devname);\n\t\t\tbreak;\n\t\t}\n\n\t\tdevices[i] = dev;\n\t\tdevname = p;\n\t}\n\tdevices[i] = 0;\n\n\tif (!i)\n\t\treturn;\n\n\tpr_info(\"md: Loading %s: %s\\n\", name, args->device_names);\n\n\tmddev = md_alloc(mdev, name);\n\tif (IS_ERR(mddev)) {\n\t\tpr_err(\"md: md_alloc failed - cannot start array %s\\n\", name);\n\t\treturn;\n\t}\n\n\terr = mddev_lock(mddev);\n\tif (err) {\n\t\tpr_err(\"md: failed to lock array %s\\n\", name);\n\t\tgoto out_mddev_put;\n\t}\n\n\tif (!list_empty(&mddev->disks) || mddev->raid_disks) {\n\t\tpr_warn(\"md: Ignoring %s, already autodetected. (Use raid=noautodetect)\\n\",\n\t\t       name);\n\t\tgoto out_unlock;\n\t}\n\n\tif (args->level != LEVEL_NONE) {\n\t\t \n\t\tainfo.level = args->level;\n\t\tainfo.md_minor = args->minor;\n\t\tainfo.not_persistent = 1;\n\t\tainfo.state = (1 << MD_SB_CLEAN);\n\t\tainfo.chunk_size = args->chunk;\n\t\twhile (devices[ainfo.raid_disks])\n\t\t\tainfo.raid_disks++;\n\t}\n\n\terr = md_set_array_info(mddev, &ainfo);\n\n\tfor (i = 0; i <= MD_SB_DISKS && devices[i]; i++) {\n\t\tstruct mdu_disk_info_s dinfo = {\n\t\t\t.major\t= MAJOR(devices[i]),\n\t\t\t.minor\t= MINOR(devices[i]),\n\t\t};\n\n\t\tif (args->level != LEVEL_NONE) {\n\t\t\tdinfo.number = i;\n\t\t\tdinfo.raid_disk = i;\n\t\t\tdinfo.state =\n\t\t\t\t(1 << MD_DISK_ACTIVE) | (1 << MD_DISK_SYNC);\n\t\t}\n\n\t\tmd_add_new_disk(mddev, &dinfo);\n\t}\n\n\tif (!err)\n\t\terr = do_md_run(mddev);\n\tif (err)\n\t\tpr_warn(\"md: starting %s failed\\n\", name);\nout_unlock:\n\tmddev_unlock(mddev);\nout_mddev_put:\n\tmddev_put(mddev);\n}\n\nstatic int __init raid_setup(char *str)\n{\n\tint len, pos;\n\n\tlen = strlen(str) + 1;\n\tpos = 0;\n\n\twhile (pos < len) {\n\t\tchar *comma = strchr(str+pos, ',');\n\t\tint wlen;\n\t\tif (comma)\n\t\t\twlen = (comma-str)-pos;\n\t\telse\twlen = (len-1)-pos;\n\n\t\tif (!strncmp(str, \"noautodetect\", wlen))\n\t\t\traid_noautodetect = 1;\n\t\tif (!strncmp(str, \"autodetect\", wlen))\n\t\t\traid_noautodetect = 0;\n\t\tif (strncmp(str, \"partitionable\", wlen)==0)\n\t\t\traid_autopart = 1;\n\t\tif (strncmp(str, \"part\", wlen)==0)\n\t\t\traid_autopart = 1;\n\t\tpos += wlen+1;\n\t}\n\treturn 1;\n}\n\n__setup(\"raid=\", raid_setup);\n__setup(\"md=\", md_setup);\n\nstatic void __init autodetect_raid(void)\n{\n\t \n\tprintk(KERN_INFO \"md: Waiting for all devices to be available before autodetect\\n\");\n\tprintk(KERN_INFO \"md: If you don't use raid, use raid=noautodetect\\n\");\n\n\twait_for_device_probe();\n\tmd_autostart_arrays(raid_autopart);\n}\n\nvoid __init md_run_setup(void)\n{\n\tint ent;\n\n\tif (raid_noautodetect)\n\t\tprintk(KERN_INFO \"md: Skipping autodetection of RAID arrays. (raid=autodetect will force)\\n\");\n\telse\n\t\tautodetect_raid();\n\n\tfor (ent = 0; ent < md_setup_ents; ent++)\n\t\tmd_setup_drive(&md_setup_args[ent]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}