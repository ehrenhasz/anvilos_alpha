{
  "module_name": "dm-ps-queue-length.c",
  "hash_id": "d9c113b849de740f9f3cae9bdaa0f525ab885e83c60ca8f39ae0afbe521b8264",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-ps-queue-length.c",
  "human_readable_source": "\n \n\n#include \"dm.h\"\n#include \"dm-path-selector.h\"\n\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n\n#define DM_MSG_PREFIX\t\"multipath queue-length\"\n#define QL_MIN_IO\t1\n#define QL_VERSION\t\"0.2.0\"\n\nstruct selector {\n\tstruct list_head\tvalid_paths;\n\tstruct list_head\tfailed_paths;\n\tspinlock_t lock;\n};\n\nstruct path_info {\n\tstruct list_head\tlist;\n\tstruct dm_path\t\t*path;\n\tunsigned int\t\trepeat_count;\n\tatomic_t\t\tqlen;\t \n};\n\nstatic struct selector *alloc_selector(void)\n{\n\tstruct selector *s = kmalloc(sizeof(*s), GFP_KERNEL);\n\n\tif (s) {\n\t\tINIT_LIST_HEAD(&s->valid_paths);\n\t\tINIT_LIST_HEAD(&s->failed_paths);\n\t\tspin_lock_init(&s->lock);\n\t}\n\n\treturn s;\n}\n\nstatic int ql_create(struct path_selector *ps, unsigned int argc, char **argv)\n{\n\tstruct selector *s = alloc_selector();\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tps->context = s;\n\treturn 0;\n}\n\nstatic void ql_free_paths(struct list_head *paths)\n{\n\tstruct path_info *pi, *next;\n\n\tlist_for_each_entry_safe(pi, next, paths, list) {\n\t\tlist_del(&pi->list);\n\t\tkfree(pi);\n\t}\n}\n\nstatic void ql_destroy(struct path_selector *ps)\n{\n\tstruct selector *s = ps->context;\n\n\tql_free_paths(&s->valid_paths);\n\tql_free_paths(&s->failed_paths);\n\tkfree(s);\n\tps->context = NULL;\n}\n\nstatic int ql_status(struct path_selector *ps, struct dm_path *path,\n\t\t     status_type_t type, char *result, unsigned int maxlen)\n{\n\tunsigned int sz = 0;\n\tstruct path_info *pi;\n\n\t \n\tif (!path)\n\t\tDMEMIT(\"0 \");\n\telse {\n\t\tpi = path->pscontext;\n\n\t\tswitch (type) {\n\t\tcase STATUSTYPE_INFO:\n\t\t\tDMEMIT(\"%d \", atomic_read(&pi->qlen));\n\t\t\tbreak;\n\t\tcase STATUSTYPE_TABLE:\n\t\t\tDMEMIT(\"%u \", pi->repeat_count);\n\t\t\tbreak;\n\t\tcase STATUSTYPE_IMA:\n\t\t\t*result = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sz;\n}\n\nstatic int ql_add_path(struct path_selector *ps, struct dm_path *path,\n\t\t       int argc, char **argv, char **error)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi;\n\tunsigned int repeat_count = QL_MIN_IO;\n\tchar dummy;\n\tunsigned long flags;\n\n\t \n\tif (argc > 1) {\n\t\t*error = \"queue-length ps: incorrect number of arguments\";\n\t\treturn -EINVAL;\n\t}\n\n\tif ((argc == 1) && (sscanf(argv[0], \"%u%c\", &repeat_count, &dummy) != 1)) {\n\t\t*error = \"queue-length ps: invalid repeat count\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (repeat_count > 1) {\n\t\tDMWARN_LIMIT(\"repeat_count > 1 is deprecated, using 1 instead\");\n\t\trepeat_count = 1;\n\t}\n\n\t \n\tpi = kmalloc(sizeof(*pi), GFP_KERNEL);\n\tif (!pi) {\n\t\t*error = \"queue-length ps: Error allocating path information\";\n\t\treturn -ENOMEM;\n\t}\n\n\tpi->path = path;\n\tpi->repeat_count = repeat_count;\n\tatomic_set(&pi->qlen, 0);\n\n\tpath->pscontext = pi;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tlist_add_tail(&pi->list, &s->valid_paths);\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn 0;\n}\n\nstatic void ql_fail_path(struct path_selector *ps, struct dm_path *path)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = path->pscontext;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tlist_move(&pi->list, &s->failed_paths);\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nstatic int ql_reinstate_path(struct path_selector *ps, struct dm_path *path)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = path->pscontext;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tlist_move_tail(&pi->list, &s->valid_paths);\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic struct dm_path *ql_select_path(struct path_selector *ps, size_t nr_bytes)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = NULL, *best = NULL;\n\tstruct dm_path *ret = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tif (list_empty(&s->valid_paths))\n\t\tgoto out;\n\n\tlist_for_each_entry(pi, &s->valid_paths, list) {\n\t\tif (!best ||\n\t\t    (atomic_read(&pi->qlen) < atomic_read(&best->qlen)))\n\t\t\tbest = pi;\n\n\t\tif (!atomic_read(&best->qlen))\n\t\t\tbreak;\n\t}\n\n\tif (!best)\n\t\tgoto out;\n\n\t \n\tlist_move_tail(&best->list, &s->valid_paths);\n\n\tret = best->path;\nout:\n\tspin_unlock_irqrestore(&s->lock, flags);\n\treturn ret;\n}\n\nstatic int ql_start_io(struct path_selector *ps, struct dm_path *path,\n\t\t       size_t nr_bytes)\n{\n\tstruct path_info *pi = path->pscontext;\n\n\tatomic_inc(&pi->qlen);\n\n\treturn 0;\n}\n\nstatic int ql_end_io(struct path_selector *ps, struct dm_path *path,\n\t\t     size_t nr_bytes, u64 start_time)\n{\n\tstruct path_info *pi = path->pscontext;\n\n\tatomic_dec(&pi->qlen);\n\n\treturn 0;\n}\n\nstatic struct path_selector_type ql_ps = {\n\t.name\t\t= \"queue-length\",\n\t.module\t\t= THIS_MODULE,\n\t.table_args\t= 1,\n\t.info_args\t= 1,\n\t.create\t\t= ql_create,\n\t.destroy\t= ql_destroy,\n\t.status\t\t= ql_status,\n\t.add_path\t= ql_add_path,\n\t.fail_path\t= ql_fail_path,\n\t.reinstate_path\t= ql_reinstate_path,\n\t.select_path\t= ql_select_path,\n\t.start_io\t= ql_start_io,\n\t.end_io\t\t= ql_end_io,\n};\n\nstatic int __init dm_ql_init(void)\n{\n\tint r = dm_register_path_selector(&ql_ps);\n\n\tif (r < 0)\n\t\tDMERR(\"register failed %d\", r);\n\n\tDMINFO(\"version \" QL_VERSION \" loaded\");\n\n\treturn r;\n}\n\nstatic void __exit dm_ql_exit(void)\n{\n\tint r = dm_unregister_path_selector(&ql_ps);\n\n\tif (r < 0)\n\t\tDMERR(\"unregister failed %d\", r);\n}\n\nmodule_init(dm_ql_init);\nmodule_exit(dm_ql_exit);\n\nMODULE_AUTHOR(\"Stefan Bader <Stefan.Bader at de.ibm.com>\");\nMODULE_DESCRIPTION(\n\t\"(C) Copyright IBM Corp. 2004,2005   All Rights Reserved.\\n\"\n\tDM_NAME \" path selector to balance the number of in-flight I/Os\"\n);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}