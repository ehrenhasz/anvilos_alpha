{
  "module_name": "dm-log.c",
  "hash_id": "981da80685dabe23a31c4a9dd7d55f49e12e2ba9c4e939c25e4c6658c6d105c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-log.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/dm-io.h>\n#include <linux/dm-dirty-log.h>\n\n#include <linux/device-mapper.h>\n\n#define DM_MSG_PREFIX \"dirty region log\"\n\nstatic LIST_HEAD(_log_types);\nstatic DEFINE_SPINLOCK(_lock);\n\nstatic struct dm_dirty_log_type *__find_dirty_log_type(const char *name)\n{\n\tstruct dm_dirty_log_type *log_type;\n\n\tlist_for_each_entry(log_type, &_log_types, list)\n\t\tif (!strcmp(name, log_type->name))\n\t\t\treturn log_type;\n\n\treturn NULL;\n}\n\nstatic struct dm_dirty_log_type *_get_dirty_log_type(const char *name)\n{\n\tstruct dm_dirty_log_type *log_type;\n\n\tspin_lock(&_lock);\n\n\tlog_type = __find_dirty_log_type(name);\n\tif (log_type && !try_module_get(log_type->module))\n\t\tlog_type = NULL;\n\n\tspin_unlock(&_lock);\n\n\treturn log_type;\n}\n\n \nstatic struct dm_dirty_log_type *get_type(const char *type_name)\n{\n\tchar *p, *type_name_dup;\n\tstruct dm_dirty_log_type *log_type;\n\n\tif (!type_name)\n\t\treturn NULL;\n\n\tlog_type = _get_dirty_log_type(type_name);\n\tif (log_type)\n\t\treturn log_type;\n\n\ttype_name_dup = kstrdup(type_name, GFP_KERNEL);\n\tif (!type_name_dup) {\n\t\tDMWARN(\"No memory left to attempt log module load for \\\"%s\\\"\",\n\t\t       type_name);\n\t\treturn NULL;\n\t}\n\n\twhile (request_module(\"dm-log-%s\", type_name_dup) ||\n\t       !(log_type = _get_dirty_log_type(type_name))) {\n\t\tp = strrchr(type_name_dup, '-');\n\t\tif (!p)\n\t\t\tbreak;\n\t\tp[0] = '\\0';\n\t}\n\n\tif (!log_type)\n\t\tDMWARN(\"Module for logging type \\\"%s\\\" not found.\", type_name);\n\n\tkfree(type_name_dup);\n\n\treturn log_type;\n}\n\nstatic void put_type(struct dm_dirty_log_type *type)\n{\n\tif (!type)\n\t\treturn;\n\n\tspin_lock(&_lock);\n\tif (!__find_dirty_log_type(type->name))\n\t\tgoto out;\n\n\tmodule_put(type->module);\n\nout:\n\tspin_unlock(&_lock);\n}\n\nint dm_dirty_log_type_register(struct dm_dirty_log_type *type)\n{\n\tint r = 0;\n\n\tspin_lock(&_lock);\n\tif (!__find_dirty_log_type(type->name))\n\t\tlist_add(&type->list, &_log_types);\n\telse\n\t\tr = -EEXIST;\n\tspin_unlock(&_lock);\n\n\treturn r;\n}\nEXPORT_SYMBOL(dm_dirty_log_type_register);\n\nint dm_dirty_log_type_unregister(struct dm_dirty_log_type *type)\n{\n\tspin_lock(&_lock);\n\n\tif (!__find_dirty_log_type(type->name)) {\n\t\tspin_unlock(&_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tlist_del(&type->list);\n\n\tspin_unlock(&_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dm_dirty_log_type_unregister);\n\nstruct dm_dirty_log *dm_dirty_log_create(const char *type_name,\n\t\t\tstruct dm_target *ti,\n\t\t\tint (*flush_callback_fn)(struct dm_target *ti),\n\t\t\tunsigned int argc, char **argv)\n{\n\tstruct dm_dirty_log_type *type;\n\tstruct dm_dirty_log *log;\n\n\tlog = kmalloc(sizeof(*log), GFP_KERNEL);\n\tif (!log)\n\t\treturn NULL;\n\n\ttype = get_type(type_name);\n\tif (!type) {\n\t\tkfree(log);\n\t\treturn NULL;\n\t}\n\n\tlog->flush_callback_fn = flush_callback_fn;\n\tlog->type = type;\n\tif (type->ctr(log, ti, argc, argv)) {\n\t\tkfree(log);\n\t\tput_type(type);\n\t\treturn NULL;\n\t}\n\n\treturn log;\n}\nEXPORT_SYMBOL(dm_dirty_log_create);\n\nvoid dm_dirty_log_destroy(struct dm_dirty_log *log)\n{\n\tlog->type->dtr(log);\n\tput_type(log->type);\n\tkfree(log);\n}\nEXPORT_SYMBOL(dm_dirty_log_destroy);\n\n \n \n#define MIRROR_MAGIC 0x4D695272\n\n \n#define MIRROR_DISK_VERSION 2\n#define LOG_OFFSET 2\n\nstruct log_header_disk {\n\t__le32 magic;\n\n\t \n\t__le32 version;\n\t__le64 nr_regions;\n} __packed;\n\nstruct log_header_core {\n\tuint32_t magic;\n\tuint32_t version;\n\tuint64_t nr_regions;\n};\n\nstruct log_c {\n\tstruct dm_target *ti;\n\tint touched_dirtied;\n\tint touched_cleaned;\n\tint flush_failed;\n\tuint32_t region_size;\n\tunsigned int region_count;\n\tregion_t sync_count;\n\n\tunsigned int bitset_uint32_count;\n\tuint32_t *clean_bits;\n\tuint32_t *sync_bits;\n\tuint32_t *recovering_bits;\t \n\n\tint sync_search;\n\n\t \n\tenum sync {\n\t\tDEFAULTSYNC,\t \n\t\tNOSYNC,\t\t \n\t\tFORCESYNC,\t \n\t} sync;\n\n\tstruct dm_io_request io_req;\n\n\t \n\tint log_dev_failed;\n\tint log_dev_flush_failed;\n\tstruct dm_dev *log_dev;\n\tstruct log_header_core header;\n\n\tstruct dm_io_region header_location;\n\tstruct log_header_disk *disk_header;\n};\n\n \nstatic inline int log_test_bit(uint32_t *bs, unsigned int bit)\n{\n\treturn test_bit_le(bit, bs) ? 1 : 0;\n}\n\nstatic inline void log_set_bit(struct log_c *l,\n\t\t\t       uint32_t *bs, unsigned int bit)\n{\n\t__set_bit_le(bit, bs);\n\tl->touched_cleaned = 1;\n}\n\nstatic inline void log_clear_bit(struct log_c *l,\n\t\t\t\t uint32_t *bs, unsigned int bit)\n{\n\t__clear_bit_le(bit, bs);\n\tl->touched_dirtied = 1;\n}\n\n \nstatic void header_to_disk(struct log_header_core *core, struct log_header_disk *disk)\n{\n\tdisk->magic = cpu_to_le32(core->magic);\n\tdisk->version = cpu_to_le32(core->version);\n\tdisk->nr_regions = cpu_to_le64(core->nr_regions);\n}\n\nstatic void header_from_disk(struct log_header_core *core, struct log_header_disk *disk)\n{\n\tcore->magic = le32_to_cpu(disk->magic);\n\tcore->version = le32_to_cpu(disk->version);\n\tcore->nr_regions = le64_to_cpu(disk->nr_regions);\n}\n\nstatic int rw_header(struct log_c *lc, enum req_op op)\n{\n\tlc->io_req.bi_opf = op;\n\n\treturn dm_io(&lc->io_req, 1, &lc->header_location, NULL);\n}\n\nstatic int flush_header(struct log_c *lc)\n{\n\tstruct dm_io_region null_location = {\n\t\t.bdev = lc->header_location.bdev,\n\t\t.sector = 0,\n\t\t.count = 0,\n\t};\n\n\tlc->io_req.bi_opf = REQ_OP_WRITE | REQ_PREFLUSH;\n\n\treturn dm_io(&lc->io_req, 1, &null_location, NULL);\n}\n\nstatic int read_header(struct log_c *log)\n{\n\tint r;\n\n\tr = rw_header(log, REQ_OP_READ);\n\tif (r)\n\t\treturn r;\n\n\theader_from_disk(&log->header, log->disk_header);\n\n\t \n\tif (log->sync != DEFAULTSYNC || log->header.magic != MIRROR_MAGIC) {\n\t\tlog->header.magic = MIRROR_MAGIC;\n\t\tlog->header.version = MIRROR_DISK_VERSION;\n\t\tlog->header.nr_regions = 0;\n\t}\n\n#ifdef __LITTLE_ENDIAN\n\tif (log->header.version == 1)\n\t\tlog->header.version = 2;\n#endif\n\n\tif (log->header.version != MIRROR_DISK_VERSION) {\n\t\tDMWARN(\"incompatible disk log version\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int _check_region_size(struct dm_target *ti, uint32_t region_size)\n{\n\tif (region_size < 2 || region_size > ti->len)\n\t\treturn 0;\n\n\tif (!is_power_of_2(region_size))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \n#define BYTE_SHIFT 3\nstatic int create_log_context(struct dm_dirty_log *log, struct dm_target *ti,\n\t\t\t      unsigned int argc, char **argv,\n\t\t\t      struct dm_dev *dev)\n{\n\tenum sync sync = DEFAULTSYNC;\n\n\tstruct log_c *lc;\n\tuint32_t region_size;\n\tunsigned int region_count;\n\tsize_t bitset_size, buf_size;\n\tint r;\n\tchar dummy;\n\n\tif (argc < 1 || argc > 2) {\n\t\tDMWARN(\"wrong number of arguments to dirty region log\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (argc > 1) {\n\t\tif (!strcmp(argv[1], \"sync\"))\n\t\t\tsync = FORCESYNC;\n\t\telse if (!strcmp(argv[1], \"nosync\"))\n\t\t\tsync = NOSYNC;\n\t\telse {\n\t\t\tDMWARN(\"unrecognised sync argument to dirty region log: %s\", argv[1]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sscanf(argv[0], \"%u%c\", &region_size, &dummy) != 1 ||\n\t    !_check_region_size(ti, region_size)) {\n\t\tDMWARN(\"invalid region size %s\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tregion_count = dm_sector_div_up(ti->len, region_size);\n\n\tlc = kmalloc(sizeof(*lc), GFP_KERNEL);\n\tif (!lc) {\n\t\tDMWARN(\"couldn't allocate core log\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlc->ti = ti;\n\tlc->touched_dirtied = 0;\n\tlc->touched_cleaned = 0;\n\tlc->flush_failed = 0;\n\tlc->region_size = region_size;\n\tlc->region_count = region_count;\n\tlc->sync = sync;\n\n\t \n\tbitset_size = dm_round_up(region_count, BITS_PER_LONG);\n\tbitset_size >>= BYTE_SHIFT;\n\n\tlc->bitset_uint32_count = bitset_size / sizeof(*lc->clean_bits);\n\n\t \n\tif (!dev) {\n\t\tlc->clean_bits = vmalloc(bitset_size);\n\t\tif (!lc->clean_bits) {\n\t\t\tDMWARN(\"couldn't allocate clean bitset\");\n\t\t\tkfree(lc);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlc->disk_header = NULL;\n\t} else {\n\t\tlc->log_dev = dev;\n\t\tlc->log_dev_failed = 0;\n\t\tlc->log_dev_flush_failed = 0;\n\t\tlc->header_location.bdev = lc->log_dev->bdev;\n\t\tlc->header_location.sector = 0;\n\n\t\t \n\t\tbuf_size =\n\t\t    dm_round_up((LOG_OFFSET << SECTOR_SHIFT) + bitset_size,\n\t\t\t\tbdev_logical_block_size(lc->header_location.bdev));\n\n\t\tif (buf_size > bdev_nr_bytes(dev->bdev)) {\n\t\t\tDMWARN(\"log device %s too small: need %llu bytes\",\n\t\t\t\tdev->name, (unsigned long long)buf_size);\n\t\t\tkfree(lc);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlc->header_location.count = buf_size >> SECTOR_SHIFT;\n\n\t\tlc->io_req.mem.type = DM_IO_VMA;\n\t\tlc->io_req.notify.fn = NULL;\n\t\tlc->io_req.client = dm_io_client_create();\n\t\tif (IS_ERR(lc->io_req.client)) {\n\t\t\tr = PTR_ERR(lc->io_req.client);\n\t\t\tDMWARN(\"couldn't allocate disk io client\");\n\t\t\tkfree(lc);\n\t\t\treturn r;\n\t\t}\n\n\t\tlc->disk_header = vmalloc(buf_size);\n\t\tif (!lc->disk_header) {\n\t\t\tDMWARN(\"couldn't allocate disk log buffer\");\n\t\t\tdm_io_client_destroy(lc->io_req.client);\n\t\t\tkfree(lc);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tlc->io_req.mem.ptr.vma = lc->disk_header;\n\t\tlc->clean_bits = (void *)lc->disk_header +\n\t\t\t\t (LOG_OFFSET << SECTOR_SHIFT);\n\t}\n\n\tmemset(lc->clean_bits, -1, bitset_size);\n\n\tlc->sync_bits = vmalloc(bitset_size);\n\tif (!lc->sync_bits) {\n\t\tDMWARN(\"couldn't allocate sync bitset\");\n\t\tif (!dev)\n\t\t\tvfree(lc->clean_bits);\n\t\telse\n\t\t\tdm_io_client_destroy(lc->io_req.client);\n\t\tvfree(lc->disk_header);\n\t\tkfree(lc);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(lc->sync_bits, (sync == NOSYNC) ? -1 : 0, bitset_size);\n\tlc->sync_count = (sync == NOSYNC) ? region_count : 0;\n\n\tlc->recovering_bits = vzalloc(bitset_size);\n\tif (!lc->recovering_bits) {\n\t\tDMWARN(\"couldn't allocate sync bitset\");\n\t\tvfree(lc->sync_bits);\n\t\tif (!dev)\n\t\t\tvfree(lc->clean_bits);\n\t\telse\n\t\t\tdm_io_client_destroy(lc->io_req.client);\n\t\tvfree(lc->disk_header);\n\t\tkfree(lc);\n\t\treturn -ENOMEM;\n\t}\n\tlc->sync_search = 0;\n\tlog->context = lc;\n\n\treturn 0;\n}\n\nstatic int core_ctr(struct dm_dirty_log *log, struct dm_target *ti,\n\t\t    unsigned int argc, char **argv)\n{\n\treturn create_log_context(log, ti, argc, argv, NULL);\n}\n\nstatic void destroy_log_context(struct log_c *lc)\n{\n\tvfree(lc->sync_bits);\n\tvfree(lc->recovering_bits);\n\tkfree(lc);\n}\n\nstatic void core_dtr(struct dm_dirty_log *log)\n{\n\tstruct log_c *lc = log->context;\n\n\tvfree(lc->clean_bits);\n\tdestroy_log_context(lc);\n}\n\n \nstatic int disk_ctr(struct dm_dirty_log *log, struct dm_target *ti,\n\t\t    unsigned int argc, char **argv)\n{\n\tint r;\n\tstruct dm_dev *dev;\n\n\tif (argc < 2 || argc > 3) {\n\t\tDMWARN(\"wrong number of arguments to disk dirty region log\");\n\t\treturn -EINVAL;\n\t}\n\n\tr = dm_get_device(ti, argv[0], dm_table_get_mode(ti->table), &dev);\n\tif (r)\n\t\treturn r;\n\n\tr = create_log_context(log, ti, argc - 1, argv + 1, dev);\n\tif (r) {\n\t\tdm_put_device(ti, dev);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void disk_dtr(struct dm_dirty_log *log)\n{\n\tstruct log_c *lc = log->context;\n\n\tdm_put_device(lc->ti, lc->log_dev);\n\tvfree(lc->disk_header);\n\tdm_io_client_destroy(lc->io_req.client);\n\tdestroy_log_context(lc);\n}\n\nstatic void fail_log_device(struct log_c *lc)\n{\n\tif (lc->log_dev_failed)\n\t\treturn;\n\n\tlc->log_dev_failed = 1;\n\tdm_table_event(lc->ti->table);\n}\n\nstatic int disk_resume(struct dm_dirty_log *log)\n{\n\tint r;\n\tunsigned int i;\n\tstruct log_c *lc = log->context;\n\tsize_t size = lc->bitset_uint32_count * sizeof(uint32_t);\n\n\t \n\tr = read_header(lc);\n\tif (r) {\n\t\tDMWARN(\"%s: Failed to read header on dirty region log device\",\n\t\t       lc->log_dev->name);\n\t\tfail_log_device(lc);\n\t\t \n\t\tlc->header.nr_regions = 0;\n\t}\n\n\t \n\tif (lc->sync == NOSYNC)\n\t\tfor (i = lc->header.nr_regions; i < lc->region_count; i++)\n\t\t\t \n\t\t\tlog_set_bit(lc, lc->clean_bits, i);\n\telse\n\t\tfor (i = lc->header.nr_regions; i < lc->region_count; i++)\n\t\t\t \n\t\t\tlog_clear_bit(lc, lc->clean_bits, i);\n\n\t \n\tfor (i = lc->region_count; i % BITS_PER_LONG; i++)\n\t\tlog_clear_bit(lc, lc->clean_bits, i);\n\n\t \n\tmemcpy(lc->sync_bits, lc->clean_bits, size);\n\tlc->sync_count = memweight(lc->clean_bits,\n\t\t\t\tlc->bitset_uint32_count * sizeof(uint32_t));\n\tlc->sync_search = 0;\n\n\t \n\tlc->header.nr_regions = lc->region_count;\n\n\theader_to_disk(&lc->header, lc->disk_header);\n\n\t \n\tr = rw_header(lc, REQ_OP_WRITE);\n\tif (!r) {\n\t\tr = flush_header(lc);\n\t\tif (r)\n\t\t\tlc->log_dev_flush_failed = 1;\n\t}\n\tif (r) {\n\t\tDMWARN(\"%s: Failed to write header on dirty region log device\",\n\t\t       lc->log_dev->name);\n\t\tfail_log_device(lc);\n\t}\n\n\treturn r;\n}\n\nstatic uint32_t core_get_region_size(struct dm_dirty_log *log)\n{\n\tstruct log_c *lc = log->context;\n\n\treturn lc->region_size;\n}\n\nstatic int core_resume(struct dm_dirty_log *log)\n{\n\tstruct log_c *lc = log->context;\n\n\tlc->sync_search = 0;\n\treturn 0;\n}\n\nstatic int core_is_clean(struct dm_dirty_log *log, region_t region)\n{\n\tstruct log_c *lc = log->context;\n\n\treturn log_test_bit(lc->clean_bits, region);\n}\n\nstatic int core_in_sync(struct dm_dirty_log *log, region_t region, int block)\n{\n\tstruct log_c *lc = log->context;\n\n\treturn log_test_bit(lc->sync_bits, region);\n}\n\nstatic int core_flush(struct dm_dirty_log *log)\n{\n\t \n\treturn 0;\n}\n\nstatic int disk_flush(struct dm_dirty_log *log)\n{\n\tint r, i;\n\tstruct log_c *lc = log->context;\n\n\t \n\tif (!lc->touched_cleaned && !lc->touched_dirtied)\n\t\treturn 0;\n\n\tif (lc->touched_cleaned && log->flush_callback_fn &&\n\t    log->flush_callback_fn(lc->ti)) {\n\t\t \n\t\tlc->flush_failed = 1;\n\t\tfor (i = 0; i < lc->region_count; i++)\n\t\t\tlog_clear_bit(lc, lc->clean_bits, i);\n\t}\n\n\tr = rw_header(lc, REQ_OP_WRITE);\n\tif (r)\n\t\tfail_log_device(lc);\n\telse {\n\t\tif (lc->touched_dirtied) {\n\t\t\tr = flush_header(lc);\n\t\t\tif (r) {\n\t\t\t\tlc->log_dev_flush_failed = 1;\n\t\t\t\tfail_log_device(lc);\n\t\t\t} else\n\t\t\t\tlc->touched_dirtied = 0;\n\t\t}\n\t\tlc->touched_cleaned = 0;\n\t}\n\n\treturn r;\n}\n\nstatic void core_mark_region(struct dm_dirty_log *log, region_t region)\n{\n\tstruct log_c *lc = log->context;\n\n\tlog_clear_bit(lc, lc->clean_bits, region);\n}\n\nstatic void core_clear_region(struct dm_dirty_log *log, region_t region)\n{\n\tstruct log_c *lc = log->context;\n\n\tif (likely(!lc->flush_failed))\n\t\tlog_set_bit(lc, lc->clean_bits, region);\n}\n\nstatic int core_get_resync_work(struct dm_dirty_log *log, region_t *region)\n{\n\tstruct log_c *lc = log->context;\n\n\tif (lc->sync_search >= lc->region_count)\n\t\treturn 0;\n\n\tdo {\n\t\t*region = find_next_zero_bit_le(lc->sync_bits,\n\t\t\t\t\t     lc->region_count,\n\t\t\t\t\t     lc->sync_search);\n\t\tlc->sync_search = *region + 1;\n\n\t\tif (*region >= lc->region_count)\n\t\t\treturn 0;\n\n\t} while (log_test_bit(lc->recovering_bits, *region));\n\n\tlog_set_bit(lc, lc->recovering_bits, *region);\n\treturn 1;\n}\n\nstatic void core_set_region_sync(struct dm_dirty_log *log, region_t region,\n\t\t\t\t int in_sync)\n{\n\tstruct log_c *lc = log->context;\n\n\tlog_clear_bit(lc, lc->recovering_bits, region);\n\tif (in_sync) {\n\t\tlog_set_bit(lc, lc->sync_bits, region);\n\t\tlc->sync_count++;\n\t} else if (log_test_bit(lc->sync_bits, region)) {\n\t\tlc->sync_count--;\n\t\tlog_clear_bit(lc, lc->sync_bits, region);\n\t}\n}\n\nstatic region_t core_get_sync_count(struct dm_dirty_log *log)\n{\n\tstruct log_c *lc = log->context;\n\n\treturn lc->sync_count;\n}\n\n#define\tDMEMIT_SYNC \\\n\tdo { \\\n\t\tif (lc->sync != DEFAULTSYNC) \\\n\t\t\tDMEMIT(\"%ssync \", lc->sync == NOSYNC ? \"no\" : \"\"); \\\n\t} while (0)\n\nstatic int core_status(struct dm_dirty_log *log, status_type_t status,\n\t\t       char *result, unsigned int maxlen)\n{\n\tint sz = 0;\n\tstruct log_c *lc = log->context;\n\n\tswitch (status) {\n\tcase STATUSTYPE_INFO:\n\t\tDMEMIT(\"1 %s\", log->type->name);\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\"%s %u %u \", log->type->name,\n\t\t       lc->sync == DEFAULTSYNC ? 1 : 2, lc->region_size);\n\t\tDMEMIT_SYNC;\n\t\tbreak;\n\n\tcase STATUSTYPE_IMA:\n\t\t*result = '\\0';\n\t\tbreak;\n\t}\n\n\treturn sz;\n}\n\nstatic int disk_status(struct dm_dirty_log *log, status_type_t status,\n\t\t       char *result, unsigned int maxlen)\n{\n\tint sz = 0;\n\tstruct log_c *lc = log->context;\n\n\tswitch (status) {\n\tcase STATUSTYPE_INFO:\n\t\tDMEMIT(\"3 %s %s %c\", log->type->name, lc->log_dev->name,\n\t\t       lc->log_dev_flush_failed ? 'F' :\n\t\t       lc->log_dev_failed ? 'D' :\n\t\t       'A');\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\"%s %u %s %u \", log->type->name,\n\t\t       lc->sync == DEFAULTSYNC ? 2 : 3, lc->log_dev->name,\n\t\t       lc->region_size);\n\t\tDMEMIT_SYNC;\n\t\tbreak;\n\n\tcase STATUSTYPE_IMA:\n\t\t*result = '\\0';\n\t\tbreak;\n\t}\n\n\treturn sz;\n}\n\nstatic struct dm_dirty_log_type _core_type = {\n\t.name = \"core\",\n\t.module = THIS_MODULE,\n\t.ctr = core_ctr,\n\t.dtr = core_dtr,\n\t.resume = core_resume,\n\t.get_region_size = core_get_region_size,\n\t.is_clean = core_is_clean,\n\t.in_sync = core_in_sync,\n\t.flush = core_flush,\n\t.mark_region = core_mark_region,\n\t.clear_region = core_clear_region,\n\t.get_resync_work = core_get_resync_work,\n\t.set_region_sync = core_set_region_sync,\n\t.get_sync_count = core_get_sync_count,\n\t.status = core_status,\n};\n\nstatic struct dm_dirty_log_type _disk_type = {\n\t.name = \"disk\",\n\t.module = THIS_MODULE,\n\t.ctr = disk_ctr,\n\t.dtr = disk_dtr,\n\t.postsuspend = disk_flush,\n\t.resume = disk_resume,\n\t.get_region_size = core_get_region_size,\n\t.is_clean = core_is_clean,\n\t.in_sync = core_in_sync,\n\t.flush = disk_flush,\n\t.mark_region = core_mark_region,\n\t.clear_region = core_clear_region,\n\t.get_resync_work = core_get_resync_work,\n\t.set_region_sync = core_set_region_sync,\n\t.get_sync_count = core_get_sync_count,\n\t.status = disk_status,\n};\n\nstatic int __init dm_dirty_log_init(void)\n{\n\tint r;\n\n\tr = dm_dirty_log_type_register(&_core_type);\n\tif (r)\n\t\tDMWARN(\"couldn't register core log\");\n\n\tr = dm_dirty_log_type_register(&_disk_type);\n\tif (r) {\n\t\tDMWARN(\"couldn't register disk type\");\n\t\tdm_dirty_log_type_unregister(&_core_type);\n\t}\n\n\treturn r;\n}\n\nstatic void __exit dm_dirty_log_exit(void)\n{\n\tdm_dirty_log_type_unregister(&_disk_type);\n\tdm_dirty_log_type_unregister(&_core_type);\n}\n\nmodule_init(dm_dirty_log_init);\nmodule_exit(dm_dirty_log_exit);\n\nMODULE_DESCRIPTION(DM_NAME \" dirty region log\");\nMODULE_AUTHOR(\"Joe Thornber, Heinz Mauelshagen <dm-devel@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}