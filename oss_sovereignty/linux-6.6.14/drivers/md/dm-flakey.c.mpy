{
  "module_name": "dm-flakey.c",
  "hash_id": "af17e935fc02c8aba6fe0d2f158e7faf64ea2cb6f1106ae9fc4afb80a3744d07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-flakey.c",
  "human_readable_source": "\n \n\n#include <linux/device-mapper.h>\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n\n#define DM_MSG_PREFIX \"flakey\"\n\n#define PROBABILITY_BASE\t1000000000\n\n#define all_corrupt_bio_flags_match(bio, fc)\t\\\n\t(((bio)->bi_opf & (fc)->corrupt_bio_flags) == (fc)->corrupt_bio_flags)\n\n \nstruct flakey_c {\n\tstruct dm_dev *dev;\n\tunsigned long start_time;\n\tsector_t start;\n\tunsigned int up_interval;\n\tunsigned int down_interval;\n\tunsigned long flags;\n\tunsigned int corrupt_bio_byte;\n\tunsigned int corrupt_bio_rw;\n\tunsigned int corrupt_bio_value;\n\tblk_opf_t corrupt_bio_flags;\n\tunsigned int random_read_corrupt;\n\tunsigned int random_write_corrupt;\n};\n\nenum feature_flag_bits {\n\tERROR_READS,\n\tDROP_WRITES,\n\tERROR_WRITES\n};\n\nstruct per_bio_data {\n\tbool bio_submitted;\n};\n\nstatic int parse_features(struct dm_arg_set *as, struct flakey_c *fc,\n\t\t\t  struct dm_target *ti)\n{\n\tint r;\n\tunsigned int argc;\n\tconst char *arg_name;\n\n\tstatic const struct dm_arg _args[] = {\n\t\t{0, 11, \"Invalid number of feature args\"},\n\t\t{1, UINT_MAX, \"Invalid corrupt bio byte\"},\n\t\t{0, 255, \"Invalid corrupt value to write into bio byte (0-255)\"},\n\t\t{0, UINT_MAX, \"Invalid corrupt bio flags mask\"},\n\t\t{0, PROBABILITY_BASE, \"Invalid random corrupt argument\"},\n\t};\n\n\t \n\tif (!as->argc)\n\t\treturn 0;\n\n\tr = dm_read_arg_group(_args, as, &argc, &ti->error);\n\tif (r)\n\t\treturn r;\n\n\twhile (argc) {\n\t\targ_name = dm_shift_arg(as);\n\t\targc--;\n\n\t\tif (!arg_name) {\n\t\t\tti->error = \"Insufficient feature arguments\";\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (!strcasecmp(arg_name, \"error_reads\")) {\n\t\t\tif (test_and_set_bit(ERROR_READS, &fc->flags)) {\n\t\t\t\tti->error = \"Feature error_reads duplicated\";\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!strcasecmp(arg_name, \"drop_writes\")) {\n\t\t\tif (test_and_set_bit(DROP_WRITES, &fc->flags)) {\n\t\t\t\tti->error = \"Feature drop_writes duplicated\";\n\t\t\t\treturn -EINVAL;\n\t\t\t} else if (test_bit(ERROR_WRITES, &fc->flags)) {\n\t\t\t\tti->error = \"Feature drop_writes conflicts with feature error_writes\";\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!strcasecmp(arg_name, \"error_writes\")) {\n\t\t\tif (test_and_set_bit(ERROR_WRITES, &fc->flags)) {\n\t\t\t\tti->error = \"Feature error_writes duplicated\";\n\t\t\t\treturn -EINVAL;\n\n\t\t\t} else if (test_bit(DROP_WRITES, &fc->flags)) {\n\t\t\t\tti->error = \"Feature error_writes conflicts with feature drop_writes\";\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!strcasecmp(arg_name, \"corrupt_bio_byte\")) {\n\t\t\tif (!argc) {\n\t\t\t\tti->error = \"Feature corrupt_bio_byte requires parameters\";\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tr = dm_read_arg(_args + 1, as, &fc->corrupt_bio_byte, &ti->error);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\targc--;\n\n\t\t\t \n\t\t\targ_name = dm_shift_arg(as);\n\t\t\tif (arg_name && !strcasecmp(arg_name, \"w\"))\n\t\t\t\tfc->corrupt_bio_rw = WRITE;\n\t\t\telse if (arg_name && !strcasecmp(arg_name, \"r\"))\n\t\t\t\tfc->corrupt_bio_rw = READ;\n\t\t\telse {\n\t\t\t\tti->error = \"Invalid corrupt bio direction (r or w)\";\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\targc--;\n\n\t\t\t \n\t\t\tr = dm_read_arg(_args + 2, as, &fc->corrupt_bio_value, &ti->error);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\targc--;\n\n\t\t\t \n\t\t\tBUILD_BUG_ON(sizeof(fc->corrupt_bio_flags) !=\n\t\t\t\t     sizeof(unsigned int));\n\t\t\tr = dm_read_arg(_args + 3, as,\n\t\t\t\t(__force unsigned int *)&fc->corrupt_bio_flags,\n\t\t\t\t&ti->error);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\targc--;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcasecmp(arg_name, \"random_read_corrupt\")) {\n\t\t\tif (!argc) {\n\t\t\t\tti->error = \"Feature random_read_corrupt requires a parameter\";\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tr = dm_read_arg(_args + 4, as, &fc->random_read_corrupt, &ti->error);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\targc--;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcasecmp(arg_name, \"random_write_corrupt\")) {\n\t\t\tif (!argc) {\n\t\t\t\tti->error = \"Feature random_write_corrupt requires a parameter\";\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tr = dm_read_arg(_args + 4, as, &fc->random_write_corrupt, &ti->error);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\targc--;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tti->error = \"Unrecognised flakey feature requested\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_bit(DROP_WRITES, &fc->flags) && (fc->corrupt_bio_rw == WRITE)) {\n\t\tti->error = \"drop_writes is incompatible with corrupt_bio_byte with the WRITE flag set\";\n\t\treturn -EINVAL;\n\n\t} else if (test_bit(ERROR_WRITES, &fc->flags) && (fc->corrupt_bio_rw == WRITE)) {\n\t\tti->error = \"error_writes is incompatible with corrupt_bio_byte with the WRITE flag set\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (!fc->corrupt_bio_byte && !test_bit(ERROR_READS, &fc->flags) &&\n\t    !test_bit(DROP_WRITES, &fc->flags) && !test_bit(ERROR_WRITES, &fc->flags) &&\n\t    !fc->random_read_corrupt && !fc->random_write_corrupt) {\n\t\tset_bit(ERROR_WRITES, &fc->flags);\n\t\tset_bit(ERROR_READS, &fc->flags);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int flakey_ctr(struct dm_target *ti, unsigned int argc, char **argv)\n{\n\tstatic const struct dm_arg _args[] = {\n\t\t{0, UINT_MAX, \"Invalid up interval\"},\n\t\t{0, UINT_MAX, \"Invalid down interval\"},\n\t};\n\n\tint r;\n\tstruct flakey_c *fc;\n\tunsigned long long tmpll;\n\tstruct dm_arg_set as;\n\tconst char *devname;\n\tchar dummy;\n\n\tas.argc = argc;\n\tas.argv = argv;\n\n\tif (argc < 4) {\n\t\tti->error = \"Invalid argument count\";\n\t\treturn -EINVAL;\n\t}\n\n\tfc = kzalloc(sizeof(*fc), GFP_KERNEL);\n\tif (!fc) {\n\t\tti->error = \"Cannot allocate context\";\n\t\treturn -ENOMEM;\n\t}\n\tfc->start_time = jiffies;\n\n\tdevname = dm_shift_arg(&as);\n\n\tr = -EINVAL;\n\tif (sscanf(dm_shift_arg(&as), \"%llu%c\", &tmpll, &dummy) != 1 || tmpll != (sector_t)tmpll) {\n\t\tti->error = \"Invalid device sector\";\n\t\tgoto bad;\n\t}\n\tfc->start = tmpll;\n\n\tr = dm_read_arg(_args, &as, &fc->up_interval, &ti->error);\n\tif (r)\n\t\tgoto bad;\n\n\tr = dm_read_arg(_args, &as, &fc->down_interval, &ti->error);\n\tif (r)\n\t\tgoto bad;\n\n\tif (!(fc->up_interval + fc->down_interval)) {\n\t\tti->error = \"Total (up + down) interval is zero\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\tif (fc->up_interval + fc->down_interval < fc->up_interval) {\n\t\tti->error = \"Interval overflow\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\tr = parse_features(&as, fc, ti);\n\tif (r)\n\t\tgoto bad;\n\n\tr = dm_get_device(ti, devname, dm_table_get_mode(ti->table), &fc->dev);\n\tif (r) {\n\t\tti->error = \"Device lookup failed\";\n\t\tgoto bad;\n\t}\n\n\tti->num_flush_bios = 1;\n\tti->num_discard_bios = 1;\n\tti->per_io_data_size = sizeof(struct per_bio_data);\n\tti->private = fc;\n\treturn 0;\n\nbad:\n\tkfree(fc);\n\treturn r;\n}\n\nstatic void flakey_dtr(struct dm_target *ti)\n{\n\tstruct flakey_c *fc = ti->private;\n\n\tdm_put_device(ti, fc->dev);\n\tkfree(fc);\n}\n\nstatic sector_t flakey_map_sector(struct dm_target *ti, sector_t bi_sector)\n{\n\tstruct flakey_c *fc = ti->private;\n\n\treturn fc->start + dm_target_offset(ti, bi_sector);\n}\n\nstatic void flakey_map_bio(struct dm_target *ti, struct bio *bio)\n{\n\tstruct flakey_c *fc = ti->private;\n\n\tbio_set_dev(bio, fc->dev->bdev);\n\tbio->bi_iter.bi_sector = flakey_map_sector(ti, bio->bi_iter.bi_sector);\n}\n\nstatic void corrupt_bio_common(struct bio *bio, unsigned int corrupt_bio_byte,\n\t\t\t       unsigned char corrupt_bio_value)\n{\n\tstruct bvec_iter iter;\n\tstruct bio_vec bvec;\n\n\t \n\tbio_for_each_segment(bvec, bio, iter) {\n\t\tif (bio_iter_len(bio, iter) > corrupt_bio_byte) {\n\t\t\tunsigned char *segment = bvec_kmap_local(&bvec);\n\t\t\tsegment[corrupt_bio_byte] = corrupt_bio_value;\n\t\t\tkunmap_local(segment);\n\t\t\tDMDEBUG(\"Corrupting data bio=%p by writing %u to byte %u \"\n\t\t\t\t\"(rw=%c bi_opf=%u bi_sector=%llu size=%u)\\n\",\n\t\t\t\tbio, corrupt_bio_value, corrupt_bio_byte,\n\t\t\t\t(bio_data_dir(bio) == WRITE) ? 'w' : 'r', bio->bi_opf,\n\t\t\t\t(unsigned long long)bio->bi_iter.bi_sector,\n\t\t\t\tbio->bi_iter.bi_size);\n\t\t\tbreak;\n\t\t}\n\t\tcorrupt_bio_byte -= bio_iter_len(bio, iter);\n\t}\n}\n\nstatic void corrupt_bio_data(struct bio *bio, struct flakey_c *fc)\n{\n\tunsigned int corrupt_bio_byte = fc->corrupt_bio_byte - 1;\n\n\tif (!bio_has_data(bio))\n\t\treturn;\n\n\tcorrupt_bio_common(bio, corrupt_bio_byte, fc->corrupt_bio_value);\n}\n\nstatic void corrupt_bio_random(struct bio *bio)\n{\n\tunsigned int corrupt_byte;\n\tunsigned char corrupt_value;\n\n\tif (!bio_has_data(bio))\n\t\treturn;\n\n\tcorrupt_byte = get_random_u32() % bio->bi_iter.bi_size;\n\tcorrupt_value = get_random_u8();\n\n\tcorrupt_bio_common(bio, corrupt_byte, corrupt_value);\n}\n\nstatic void clone_free(struct bio *clone)\n{\n\tstruct folio_iter fi;\n\n\tif (clone->bi_vcnt > 0) {  \n\t\tbio_for_each_folio_all(fi, clone)\n\t\t\tfolio_put(fi.folio);\n\t}\n\n\tbio_uninit(clone);\n\tkfree(clone);\n}\n\nstatic void clone_endio(struct bio *clone)\n{\n\tstruct bio *bio = clone->bi_private;\n\tbio->bi_status = clone->bi_status;\n\tclone_free(clone);\n\tbio_endio(bio);\n}\n\nstatic struct bio *clone_bio(struct dm_target *ti, struct flakey_c *fc, struct bio *bio)\n{\n\tstruct bio *clone;\n\tunsigned size, remaining_size, nr_iovecs, order;\n\tstruct bvec_iter iter = bio->bi_iter;\n\n\tif (unlikely(bio->bi_iter.bi_size > UIO_MAXIOV << PAGE_SHIFT))\n\t\tdm_accept_partial_bio(bio, UIO_MAXIOV << PAGE_SHIFT >> SECTOR_SHIFT);\n\n\tsize = bio->bi_iter.bi_size;\n\tnr_iovecs = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\tclone = bio_kmalloc(nr_iovecs, GFP_NOIO | __GFP_NORETRY | __GFP_NOWARN);\n\tif (!clone)\n\t\treturn NULL;\n\n\tbio_init(clone, fc->dev->bdev, bio->bi_inline_vecs, nr_iovecs, bio->bi_opf);\n\n\tclone->bi_iter.bi_sector = flakey_map_sector(ti, bio->bi_iter.bi_sector);\n\tclone->bi_private = bio;\n\tclone->bi_end_io = clone_endio;\n\n\tremaining_size = size;\n\n\torder = MAX_ORDER - 1;\n\twhile (remaining_size) {\n\t\tstruct page *pages;\n\t\tunsigned size_to_add, to_copy;\n\t\tunsigned char *virt;\n\t\tunsigned remaining_order = __fls((remaining_size + PAGE_SIZE - 1) >> PAGE_SHIFT);\n\t\torder = min(order, remaining_order);\n\nretry_alloc_pages:\n\t\tpages = alloc_pages(GFP_NOIO | __GFP_NORETRY | __GFP_NOWARN | __GFP_COMP, order);\n\t\tif (unlikely(!pages)) {\n\t\t\tif (order) {\n\t\t\t\torder--;\n\t\t\t\tgoto retry_alloc_pages;\n\t\t\t}\n\t\t\tclone_free(clone);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize_to_add = min((unsigned)PAGE_SIZE << order, remaining_size);\n\n\t\tvirt = page_to_virt(pages);\n\t\tto_copy = size_to_add;\n\t\tdo {\n\t\t\tstruct bio_vec bvec = bvec_iter_bvec(bio->bi_io_vec, iter);\n\t\t\tunsigned this_step = min(bvec.bv_len, to_copy);\n\t\t\tvoid *map = bvec_kmap_local(&bvec);\n\t\t\tmemcpy(virt, map, this_step);\n\t\t\tkunmap_local(map);\n\n\t\t\tbvec_iter_advance(bio->bi_io_vec, &iter, this_step);\n\t\t\tto_copy -= this_step;\n\t\t\tvirt += this_step;\n\t\t} while (to_copy);\n\n\t\t__bio_add_page(clone, pages, size_to_add, 0);\n\t\tremaining_size -= size_to_add;\n\t}\n\n\treturn clone;\n}\n\nstatic int flakey_map(struct dm_target *ti, struct bio *bio)\n{\n\tstruct flakey_c *fc = ti->private;\n\tunsigned int elapsed;\n\tstruct per_bio_data *pb = dm_per_bio_data(bio, sizeof(struct per_bio_data));\n\n\tpb->bio_submitted = false;\n\n\tif (op_is_zone_mgmt(bio_op(bio)))\n\t\tgoto map_bio;\n\n\t \n\telapsed = (jiffies - fc->start_time) / HZ;\n\tif (elapsed % (fc->up_interval + fc->down_interval) >= fc->up_interval) {\n\t\tbool corrupt_fixed, corrupt_random;\n\t\t \n\t\tpb->bio_submitted = true;\n\n\t\t \n\t\tif (bio_data_dir(bio) == READ) {\n\t\t\tif (test_bit(ERROR_READS, &fc->flags))\n\t\t\t\treturn DM_MAPIO_KILL;\n\t\t\tgoto map_bio;\n\t\t}\n\n\t\t \n\t\tif (test_bit(DROP_WRITES, &fc->flags)) {\n\t\t\tbio_endio(bio);\n\t\t\treturn DM_MAPIO_SUBMITTED;\n\t\t} else if (test_bit(ERROR_WRITES, &fc->flags)) {\n\t\t\tbio_io_error(bio);\n\t\t\treturn DM_MAPIO_SUBMITTED;\n\t\t}\n\n\t\t \n\t\tcorrupt_fixed = false;\n\t\tcorrupt_random = false;\n\t\tif (fc->corrupt_bio_byte && fc->corrupt_bio_rw == WRITE) {\n\t\t\tif (all_corrupt_bio_flags_match(bio, fc))\n\t\t\t\tcorrupt_fixed = true;\n\t\t}\n\t\tif (fc->random_write_corrupt) {\n\t\t\tu64 rnd = get_random_u64();\n\t\t\tu32 rem = do_div(rnd, PROBABILITY_BASE);\n\t\t\tif (rem < fc->random_write_corrupt)\n\t\t\t\tcorrupt_random = true;\n\t\t}\n\t\tif (corrupt_fixed || corrupt_random) {\n\t\t\tstruct bio *clone = clone_bio(ti, fc, bio);\n\t\t\tif (clone) {\n\t\t\t\tif (corrupt_fixed)\n\t\t\t\t\tcorrupt_bio_data(clone, fc);\n\t\t\t\tif (corrupt_random)\n\t\t\t\t\tcorrupt_bio_random(clone);\n\t\t\t\tsubmit_bio(clone);\n\t\t\t\treturn DM_MAPIO_SUBMITTED;\n\t\t\t}\n\t\t}\n\t}\n\nmap_bio:\n\tflakey_map_bio(ti, bio);\n\n\treturn DM_MAPIO_REMAPPED;\n}\n\nstatic int flakey_end_io(struct dm_target *ti, struct bio *bio,\n\t\t\t blk_status_t *error)\n{\n\tstruct flakey_c *fc = ti->private;\n\tstruct per_bio_data *pb = dm_per_bio_data(bio, sizeof(struct per_bio_data));\n\n\tif (op_is_zone_mgmt(bio_op(bio)))\n\t\treturn DM_ENDIO_DONE;\n\n\tif (!*error && pb->bio_submitted && (bio_data_dir(bio) == READ)) {\n\t\tif (fc->corrupt_bio_byte) {\n\t\t\tif ((fc->corrupt_bio_rw == READ) &&\n\t\t\t    all_corrupt_bio_flags_match(bio, fc)) {\n\t\t\t\t \n\t\t\t\tcorrupt_bio_data(bio, fc);\n\t\t\t}\n\t\t}\n\t\tif (fc->random_read_corrupt) {\n\t\t\tu64 rnd = get_random_u64();\n\t\t\tu32 rem = do_div(rnd, PROBABILITY_BASE);\n\t\t\tif (rem < fc->random_read_corrupt)\n\t\t\t\tcorrupt_bio_random(bio);\n\t\t}\n\t\tif (test_bit(ERROR_READS, &fc->flags)) {\n\t\t\t \n\t\t\t*error = BLK_STS_IOERR;\n\t\t}\n\t}\n\n\treturn DM_ENDIO_DONE;\n}\n\nstatic void flakey_status(struct dm_target *ti, status_type_t type,\n\t\t\t  unsigned int status_flags, char *result, unsigned int maxlen)\n{\n\tunsigned int sz = 0;\n\tstruct flakey_c *fc = ti->private;\n\tunsigned int error_reads, drop_writes, error_writes;\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\tresult[0] = '\\0';\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\"%s %llu %u %u\", fc->dev->name,\n\t\t       (unsigned long long)fc->start, fc->up_interval,\n\t\t       fc->down_interval);\n\n\t\terror_reads = test_bit(ERROR_READS, &fc->flags);\n\t\tdrop_writes = test_bit(DROP_WRITES, &fc->flags);\n\t\terror_writes = test_bit(ERROR_WRITES, &fc->flags);\n\t\tDMEMIT(\" %u\", error_reads + drop_writes + error_writes +\n\t\t\t(fc->corrupt_bio_byte > 0) * 5 +\n\t\t\t(fc->random_read_corrupt > 0) * 2 +\n\t\t\t(fc->random_write_corrupt > 0) * 2);\n\n\t\tif (error_reads)\n\t\t\tDMEMIT(\" error_reads\");\n\t\tif (drop_writes)\n\t\t\tDMEMIT(\" drop_writes\");\n\t\telse if (error_writes)\n\t\t\tDMEMIT(\" error_writes\");\n\n\t\tif (fc->corrupt_bio_byte)\n\t\t\tDMEMIT(\" corrupt_bio_byte %u %c %u %u\",\n\t\t\t       fc->corrupt_bio_byte,\n\t\t\t       (fc->corrupt_bio_rw == WRITE) ? 'w' : 'r',\n\t\t\t       fc->corrupt_bio_value, fc->corrupt_bio_flags);\n\n\t\tif (fc->random_read_corrupt > 0)\n\t\t\tDMEMIT(\" random_read_corrupt %u\", fc->random_read_corrupt);\n\t\tif (fc->random_write_corrupt > 0)\n\t\t\tDMEMIT(\" random_write_corrupt %u\", fc->random_write_corrupt);\n\n\t\tbreak;\n\n\tcase STATUSTYPE_IMA:\n\t\tresult[0] = '\\0';\n\t\tbreak;\n\t}\n}\n\nstatic int flakey_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)\n{\n\tstruct flakey_c *fc = ti->private;\n\n\t*bdev = fc->dev->bdev;\n\n\t \n\tif (fc->start || ti->len != bdev_nr_sectors((*bdev)))\n\t\treturn 1;\n\treturn 0;\n}\n\n#ifdef CONFIG_BLK_DEV_ZONED\nstatic int flakey_report_zones(struct dm_target *ti,\n\t\tstruct dm_report_zones_args *args, unsigned int nr_zones)\n{\n\tstruct flakey_c *fc = ti->private;\n\n\treturn dm_report_zones(fc->dev->bdev, fc->start,\n\t\t\t       flakey_map_sector(ti, args->next_sector),\n\t\t\t       args, nr_zones);\n}\n#else\n#define flakey_report_zones NULL\n#endif\n\nstatic int flakey_iterate_devices(struct dm_target *ti, iterate_devices_callout_fn fn, void *data)\n{\n\tstruct flakey_c *fc = ti->private;\n\n\treturn fn(ti, fc->dev, fc->start, ti->len, data);\n}\n\nstatic struct target_type flakey_target = {\n\t.name   = \"flakey\",\n\t.version = {1, 5, 0},\n\t.features = DM_TARGET_ZONED_HM | DM_TARGET_PASSES_CRYPTO,\n\t.report_zones = flakey_report_zones,\n\t.module = THIS_MODULE,\n\t.ctr    = flakey_ctr,\n\t.dtr    = flakey_dtr,\n\t.map    = flakey_map,\n\t.end_io = flakey_end_io,\n\t.status = flakey_status,\n\t.prepare_ioctl = flakey_prepare_ioctl,\n\t.iterate_devices = flakey_iterate_devices,\n};\nmodule_dm(flakey);\n\nMODULE_DESCRIPTION(DM_NAME \" flakey target\");\nMODULE_AUTHOR(\"Joe Thornber <dm-devel@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}