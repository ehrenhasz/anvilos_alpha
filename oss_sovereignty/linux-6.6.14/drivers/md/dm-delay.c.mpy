{
  "module_name": "dm-delay.c",
  "hash_id": "be6094546fd2257d6a207c97a83d0df4acec9909181c1f56897fe9291a3a576b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-delay.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n\n#include <linux/device-mapper.h>\n\n#define DM_MSG_PREFIX \"delay\"\n\nstruct delay_class {\n\tstruct dm_dev *dev;\n\tsector_t start;\n\tunsigned int delay;\n\tunsigned int ops;\n};\n\nstruct delay_c {\n\tstruct timer_list delay_timer;\n\tstruct mutex timer_lock;\n\tstruct workqueue_struct *kdelayd_wq;\n\tstruct work_struct flush_expired_bios;\n\tstruct list_head delayed_bios;\n\tbool may_delay;\n\n\tstruct delay_class read;\n\tstruct delay_class write;\n\tstruct delay_class flush;\n\n\tint argc;\n};\n\nstruct dm_delay_info {\n\tstruct delay_c *context;\n\tstruct delay_class *class;\n\tstruct list_head list;\n\tunsigned long expires;\n};\n\nstatic DEFINE_MUTEX(delayed_bios_lock);\n\nstatic void handle_delayed_timer(struct timer_list *t)\n{\n\tstruct delay_c *dc = from_timer(dc, t, delay_timer);\n\n\tqueue_work(dc->kdelayd_wq, &dc->flush_expired_bios);\n}\n\nstatic void queue_timeout(struct delay_c *dc, unsigned long expires)\n{\n\tmutex_lock(&dc->timer_lock);\n\n\tif (!timer_pending(&dc->delay_timer) || expires < dc->delay_timer.expires)\n\t\tmod_timer(&dc->delay_timer, expires);\n\n\tmutex_unlock(&dc->timer_lock);\n}\n\nstatic void flush_bios(struct bio *bio)\n{\n\tstruct bio *n;\n\n\twhile (bio) {\n\t\tn = bio->bi_next;\n\t\tbio->bi_next = NULL;\n\t\tdm_submit_bio_remap(bio, NULL);\n\t\tbio = n;\n\t}\n}\n\nstatic struct bio *flush_delayed_bios(struct delay_c *dc, int flush_all)\n{\n\tstruct dm_delay_info *delayed, *next;\n\tunsigned long next_expires = 0;\n\tunsigned long start_timer = 0;\n\tstruct bio_list flush_bios = { };\n\n\tmutex_lock(&delayed_bios_lock);\n\tlist_for_each_entry_safe(delayed, next, &dc->delayed_bios, list) {\n\t\tif (flush_all || time_after_eq(jiffies, delayed->expires)) {\n\t\t\tstruct bio *bio = dm_bio_from_per_bio_data(delayed,\n\t\t\t\t\t\tsizeof(struct dm_delay_info));\n\t\t\tlist_del(&delayed->list);\n\t\t\tbio_list_add(&flush_bios, bio);\n\t\t\tdelayed->class->ops--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!start_timer) {\n\t\t\tstart_timer = 1;\n\t\t\tnext_expires = delayed->expires;\n\t\t} else\n\t\t\tnext_expires = min(next_expires, delayed->expires);\n\t}\n\tmutex_unlock(&delayed_bios_lock);\n\n\tif (start_timer)\n\t\tqueue_timeout(dc, next_expires);\n\n\treturn bio_list_get(&flush_bios);\n}\n\nstatic void flush_expired_bios(struct work_struct *work)\n{\n\tstruct delay_c *dc;\n\n\tdc = container_of(work, struct delay_c, flush_expired_bios);\n\tflush_bios(flush_delayed_bios(dc, 0));\n}\n\nstatic void delay_dtr(struct dm_target *ti)\n{\n\tstruct delay_c *dc = ti->private;\n\n\tif (dc->kdelayd_wq)\n\t\tdestroy_workqueue(dc->kdelayd_wq);\n\n\tif (dc->read.dev)\n\t\tdm_put_device(ti, dc->read.dev);\n\tif (dc->write.dev)\n\t\tdm_put_device(ti, dc->write.dev);\n\tif (dc->flush.dev)\n\t\tdm_put_device(ti, dc->flush.dev);\n\n\tmutex_destroy(&dc->timer_lock);\n\n\tkfree(dc);\n}\n\nstatic int delay_class_ctr(struct dm_target *ti, struct delay_class *c, char **argv)\n{\n\tint ret;\n\tunsigned long long tmpll;\n\tchar dummy;\n\n\tif (sscanf(argv[1], \"%llu%c\", &tmpll, &dummy) != 1 || tmpll != (sector_t)tmpll) {\n\t\tti->error = \"Invalid device sector\";\n\t\treturn -EINVAL;\n\t}\n\tc->start = tmpll;\n\n\tif (sscanf(argv[2], \"%u%c\", &c->delay, &dummy) != 1) {\n\t\tti->error = \"Invalid delay\";\n\t\treturn -EINVAL;\n\t}\n\n\tret = dm_get_device(ti, argv[0], dm_table_get_mode(ti->table), &c->dev);\n\tif (ret) {\n\t\tti->error = \"Device lookup failed\";\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int delay_ctr(struct dm_target *ti, unsigned int argc, char **argv)\n{\n\tstruct delay_c *dc;\n\tint ret;\n\n\tif (argc != 3 && argc != 6 && argc != 9) {\n\t\tti->error = \"Requires exactly 3, 6 or 9 arguments\";\n\t\treturn -EINVAL;\n\t}\n\n\tdc = kzalloc(sizeof(*dc), GFP_KERNEL);\n\tif (!dc) {\n\t\tti->error = \"Cannot allocate context\";\n\t\treturn -ENOMEM;\n\t}\n\n\tti->private = dc;\n\ttimer_setup(&dc->delay_timer, handle_delayed_timer, 0);\n\tINIT_WORK(&dc->flush_expired_bios, flush_expired_bios);\n\tINIT_LIST_HEAD(&dc->delayed_bios);\n\tmutex_init(&dc->timer_lock);\n\tdc->may_delay = true;\n\tdc->argc = argc;\n\n\tret = delay_class_ctr(ti, &dc->read, argv);\n\tif (ret)\n\t\tgoto bad;\n\n\tif (argc == 3) {\n\t\tret = delay_class_ctr(ti, &dc->write, argv);\n\t\tif (ret)\n\t\t\tgoto bad;\n\t\tret = delay_class_ctr(ti, &dc->flush, argv);\n\t\tif (ret)\n\t\t\tgoto bad;\n\t\tgoto out;\n\t}\n\n\tret = delay_class_ctr(ti, &dc->write, argv + 3);\n\tif (ret)\n\t\tgoto bad;\n\tif (argc == 6) {\n\t\tret = delay_class_ctr(ti, &dc->flush, argv + 3);\n\t\tif (ret)\n\t\t\tgoto bad;\n\t\tgoto out;\n\t}\n\n\tret = delay_class_ctr(ti, &dc->flush, argv + 6);\n\tif (ret)\n\t\tgoto bad;\n\nout:\n\tdc->kdelayd_wq = alloc_workqueue(\"kdelayd\", WQ_MEM_RECLAIM, 0);\n\tif (!dc->kdelayd_wq) {\n\t\tret = -EINVAL;\n\t\tDMERR(\"Couldn't start kdelayd\");\n\t\tgoto bad;\n\t}\n\n\tti->num_flush_bios = 1;\n\tti->num_discard_bios = 1;\n\tti->accounts_remapped_io = true;\n\tti->per_io_data_size = sizeof(struct dm_delay_info);\n\treturn 0;\n\nbad:\n\tdelay_dtr(ti);\n\treturn ret;\n}\n\nstatic int delay_bio(struct delay_c *dc, struct delay_class *c, struct bio *bio)\n{\n\tstruct dm_delay_info *delayed;\n\tunsigned long expires = 0;\n\n\tif (!c->delay)\n\t\treturn DM_MAPIO_REMAPPED;\n\n\tdelayed = dm_per_bio_data(bio, sizeof(struct dm_delay_info));\n\n\tdelayed->context = dc;\n\tdelayed->expires = expires = jiffies + msecs_to_jiffies(c->delay);\n\n\tmutex_lock(&delayed_bios_lock);\n\tif (unlikely(!dc->may_delay)) {\n\t\tmutex_unlock(&delayed_bios_lock);\n\t\treturn DM_MAPIO_REMAPPED;\n\t}\n\tc->ops++;\n\tlist_add_tail(&delayed->list, &dc->delayed_bios);\n\tmutex_unlock(&delayed_bios_lock);\n\n\tqueue_timeout(dc, expires);\n\n\treturn DM_MAPIO_SUBMITTED;\n}\n\nstatic void delay_presuspend(struct dm_target *ti)\n{\n\tstruct delay_c *dc = ti->private;\n\n\tmutex_lock(&delayed_bios_lock);\n\tdc->may_delay = false;\n\tmutex_unlock(&delayed_bios_lock);\n\n\tdel_timer_sync(&dc->delay_timer);\n\tflush_bios(flush_delayed_bios(dc, 1));\n}\n\nstatic void delay_resume(struct dm_target *ti)\n{\n\tstruct delay_c *dc = ti->private;\n\n\tdc->may_delay = true;\n}\n\nstatic int delay_map(struct dm_target *ti, struct bio *bio)\n{\n\tstruct delay_c *dc = ti->private;\n\tstruct delay_class *c;\n\tstruct dm_delay_info *delayed = dm_per_bio_data(bio, sizeof(struct dm_delay_info));\n\n\tif (bio_data_dir(bio) == WRITE) {\n\t\tif (unlikely(bio->bi_opf & REQ_PREFLUSH))\n\t\t\tc = &dc->flush;\n\t\telse\n\t\t\tc = &dc->write;\n\t} else {\n\t\tc = &dc->read;\n\t}\n\tdelayed->class = c;\n\tbio_set_dev(bio, c->dev->bdev);\n\tbio->bi_iter.bi_sector = c->start + dm_target_offset(ti, bio->bi_iter.bi_sector);\n\n\treturn delay_bio(dc, c, bio);\n}\n\n#define DMEMIT_DELAY_CLASS(c) \\\n\tDMEMIT(\"%s %llu %u\", (c)->dev->name, (unsigned long long)(c)->start, (c)->delay)\n\nstatic void delay_status(struct dm_target *ti, status_type_t type,\n\t\t\t unsigned int status_flags, char *result, unsigned int maxlen)\n{\n\tstruct delay_c *dc = ti->private;\n\tint sz = 0;\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\tDMEMIT(\"%u %u %u\", dc->read.ops, dc->write.ops, dc->flush.ops);\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT_DELAY_CLASS(&dc->read);\n\t\tif (dc->argc >= 6) {\n\t\t\tDMEMIT(\" \");\n\t\t\tDMEMIT_DELAY_CLASS(&dc->write);\n\t\t}\n\t\tif (dc->argc >= 9) {\n\t\t\tDMEMIT(\" \");\n\t\t\tDMEMIT_DELAY_CLASS(&dc->flush);\n\t\t}\n\t\tbreak;\n\n\tcase STATUSTYPE_IMA:\n\t\t*result = '\\0';\n\t\tbreak;\n\t}\n}\n\nstatic int delay_iterate_devices(struct dm_target *ti,\n\t\t\t\t iterate_devices_callout_fn fn, void *data)\n{\n\tstruct delay_c *dc = ti->private;\n\tint ret = 0;\n\n\tret = fn(ti, dc->read.dev, dc->read.start, ti->len, data);\n\tif (ret)\n\t\tgoto out;\n\tret = fn(ti, dc->write.dev, dc->write.start, ti->len, data);\n\tif (ret)\n\t\tgoto out;\n\tret = fn(ti, dc->flush.dev, dc->flush.start, ti->len, data);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}\n\nstatic struct target_type delay_target = {\n\t.name\t     = \"delay\",\n\t.version     = {1, 3, 0},\n\t.features    = DM_TARGET_PASSES_INTEGRITY,\n\t.module      = THIS_MODULE,\n\t.ctr\t     = delay_ctr,\n\t.dtr\t     = delay_dtr,\n\t.map\t     = delay_map,\n\t.presuspend  = delay_presuspend,\n\t.resume\t     = delay_resume,\n\t.status\t     = delay_status,\n\t.iterate_devices = delay_iterate_devices,\n};\nmodule_dm(delay);\n\nMODULE_DESCRIPTION(DM_NAME \" delay target\");\nMODULE_AUTHOR(\"Heinz Mauelshagen <mauelshagen@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}