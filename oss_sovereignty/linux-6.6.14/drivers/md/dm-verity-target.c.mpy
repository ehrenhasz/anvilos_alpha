{
  "module_name": "dm-verity-target.c",
  "hash_id": "38849ea8d5ba305d1c3b2cf1b745f5b31c35a17c8d76d31d0ff3d40bf21754ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-verity-target.c",
  "human_readable_source": "\n \n\n#include \"dm-verity.h\"\n#include \"dm-verity-fec.h\"\n#include \"dm-verity-verify-sig.h\"\n#include \"dm-audit.h\"\n#include <linux/module.h>\n#include <linux/reboot.h>\n#include <linux/scatterlist.h>\n#include <linux/string.h>\n#include <linux/jump_label.h>\n\n#define DM_MSG_PREFIX\t\t\t\"verity\"\n\n#define DM_VERITY_ENV_LENGTH\t\t42\n#define DM_VERITY_ENV_VAR_NAME\t\t\"DM_VERITY_ERR_BLOCK_NR\"\n\n#define DM_VERITY_DEFAULT_PREFETCH_SIZE\t262144\n\n#define DM_VERITY_MAX_CORRUPTED_ERRS\t100\n\n#define DM_VERITY_OPT_LOGGING\t\t\"ignore_corruption\"\n#define DM_VERITY_OPT_RESTART\t\t\"restart_on_corruption\"\n#define DM_VERITY_OPT_PANIC\t\t\"panic_on_corruption\"\n#define DM_VERITY_OPT_IGN_ZEROES\t\"ignore_zero_blocks\"\n#define DM_VERITY_OPT_AT_MOST_ONCE\t\"check_at_most_once\"\n#define DM_VERITY_OPT_TASKLET_VERIFY\t\"try_verify_in_tasklet\"\n\n#define DM_VERITY_OPTS_MAX\t\t(4 + DM_VERITY_OPTS_FEC + \\\n\t\t\t\t\t DM_VERITY_ROOT_HASH_VERIFICATION_OPTS)\n\nstatic unsigned int dm_verity_prefetch_cluster = DM_VERITY_DEFAULT_PREFETCH_SIZE;\n\nmodule_param_named(prefetch_cluster, dm_verity_prefetch_cluster, uint, 0644);\n\nstatic DEFINE_STATIC_KEY_FALSE(use_tasklet_enabled);\n\nstruct dm_verity_prefetch_work {\n\tstruct work_struct work;\n\tstruct dm_verity *v;\n\tsector_t block;\n\tunsigned int n_blocks;\n};\n\n \nstruct buffer_aux {\n\tint hash_verified;\n};\n\n \nstatic void dm_bufio_alloc_callback(struct dm_buffer *buf)\n{\n\tstruct buffer_aux *aux = dm_bufio_get_aux_data(buf);\n\n\taux->hash_verified = 0;\n}\n\n \nstatic sector_t verity_map_sector(struct dm_verity *v, sector_t bi_sector)\n{\n\treturn v->data_start + dm_target_offset(v->ti, bi_sector);\n}\n\n \nstatic sector_t verity_position_at_level(struct dm_verity *v, sector_t block,\n\t\t\t\t\t int level)\n{\n\treturn block >> (level * v->hash_per_block_bits);\n}\n\nstatic int verity_hash_update(struct dm_verity *v, struct ahash_request *req,\n\t\t\t\tconst u8 *data, size_t len,\n\t\t\t\tstruct crypto_wait *wait)\n{\n\tstruct scatterlist sg;\n\n\tif (likely(!is_vmalloc_addr(data))) {\n\t\tsg_init_one(&sg, data, len);\n\t\tahash_request_set_crypt(req, &sg, NULL, len);\n\t\treturn crypto_wait_req(crypto_ahash_update(req), wait);\n\t}\n\n\tdo {\n\t\tint r;\n\t\tsize_t this_step = min_t(size_t, len, PAGE_SIZE - offset_in_page(data));\n\n\t\tflush_kernel_vmap_range((void *)data, this_step);\n\t\tsg_init_table(&sg, 1);\n\t\tsg_set_page(&sg, vmalloc_to_page(data), this_step, offset_in_page(data));\n\t\tahash_request_set_crypt(req, &sg, NULL, this_step);\n\t\tr = crypto_wait_req(crypto_ahash_update(req), wait);\n\t\tif (unlikely(r))\n\t\t\treturn r;\n\t\tdata += this_step;\n\t\tlen -= this_step;\n\t} while (len);\n\n\treturn 0;\n}\n\n \nstatic int verity_hash_init(struct dm_verity *v, struct ahash_request *req,\n\t\t\t\tstruct crypto_wait *wait, bool may_sleep)\n{\n\tint r;\n\n\tahash_request_set_tfm(req, v->tfm);\n\tahash_request_set_callback(req,\n\t\tmay_sleep ? CRYPTO_TFM_REQ_MAY_SLEEP | CRYPTO_TFM_REQ_MAY_BACKLOG : 0,\n\t\tcrypto_req_done, (void *)wait);\n\tcrypto_init_wait(wait);\n\n\tr = crypto_wait_req(crypto_ahash_init(req), wait);\n\n\tif (unlikely(r < 0)) {\n\t\tif (r != -ENOMEM)\n\t\t\tDMERR(\"crypto_ahash_init failed: %d\", r);\n\t\treturn r;\n\t}\n\n\tif (likely(v->salt_size && (v->version >= 1)))\n\t\tr = verity_hash_update(v, req, v->salt, v->salt_size, wait);\n\n\treturn r;\n}\n\nstatic int verity_hash_final(struct dm_verity *v, struct ahash_request *req,\n\t\t\t     u8 *digest, struct crypto_wait *wait)\n{\n\tint r;\n\n\tif (unlikely(v->salt_size && (!v->version))) {\n\t\tr = verity_hash_update(v, req, v->salt, v->salt_size, wait);\n\n\t\tif (r < 0) {\n\t\t\tDMERR(\"%s failed updating salt: %d\", __func__, r);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tahash_request_set_crypt(req, NULL, digest, 0);\n\tr = crypto_wait_req(crypto_ahash_final(req), wait);\nout:\n\treturn r;\n}\n\nint verity_hash(struct dm_verity *v, struct ahash_request *req,\n\t\tconst u8 *data, size_t len, u8 *digest, bool may_sleep)\n{\n\tint r;\n\tstruct crypto_wait wait;\n\n\tr = verity_hash_init(v, req, &wait, may_sleep);\n\tif (unlikely(r < 0))\n\t\tgoto out;\n\n\tr = verity_hash_update(v, req, data, len, &wait);\n\tif (unlikely(r < 0))\n\t\tgoto out;\n\n\tr = verity_hash_final(v, req, digest, &wait);\n\nout:\n\treturn r;\n}\n\nstatic void verity_hash_at_level(struct dm_verity *v, sector_t block, int level,\n\t\t\t\t sector_t *hash_block, unsigned int *offset)\n{\n\tsector_t position = verity_position_at_level(v, block, level);\n\tunsigned int idx;\n\n\t*hash_block = v->hash_level_block[level] + (position >> v->hash_per_block_bits);\n\n\tif (!offset)\n\t\treturn;\n\n\tidx = position & ((1 << v->hash_per_block_bits) - 1);\n\tif (!v->version)\n\t\t*offset = idx * v->digest_size;\n\telse\n\t\t*offset = idx << (v->hash_dev_block_bits - v->hash_per_block_bits);\n}\n\n \nstatic int verity_handle_err(struct dm_verity *v, enum verity_block_type type,\n\t\t\t     unsigned long long block)\n{\n\tchar verity_env[DM_VERITY_ENV_LENGTH];\n\tchar *envp[] = { verity_env, NULL };\n\tconst char *type_str = \"\";\n\tstruct mapped_device *md = dm_table_get_md(v->ti->table);\n\n\t \n\tv->hash_failed = true;\n\n\tif (v->corrupted_errs >= DM_VERITY_MAX_CORRUPTED_ERRS)\n\t\tgoto out;\n\n\tv->corrupted_errs++;\n\n\tswitch (type) {\n\tcase DM_VERITY_BLOCK_TYPE_DATA:\n\t\ttype_str = \"data\";\n\t\tbreak;\n\tcase DM_VERITY_BLOCK_TYPE_METADATA:\n\t\ttype_str = \"metadata\";\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tDMERR_LIMIT(\"%s: %s block %llu is corrupted\", v->data_dev->name,\n\t\t    type_str, block);\n\n\tif (v->corrupted_errs == DM_VERITY_MAX_CORRUPTED_ERRS) {\n\t\tDMERR(\"%s: reached maximum errors\", v->data_dev->name);\n\t\tdm_audit_log_target(DM_MSG_PREFIX, \"max-corrupted-errors\", v->ti, 0);\n\t}\n\n\tsnprintf(verity_env, DM_VERITY_ENV_LENGTH, \"%s=%d,%llu\",\n\t\tDM_VERITY_ENV_VAR_NAME, type, block);\n\n\tkobject_uevent_env(&disk_to_dev(dm_disk(md))->kobj, KOBJ_CHANGE, envp);\n\nout:\n\tif (v->mode == DM_VERITY_MODE_LOGGING)\n\t\treturn 0;\n\n\tif (v->mode == DM_VERITY_MODE_RESTART)\n\t\tkernel_restart(\"dm-verity device corrupted\");\n\n\tif (v->mode == DM_VERITY_MODE_PANIC)\n\t\tpanic(\"dm-verity device corrupted\");\n\n\treturn 1;\n}\n\n \nstatic int verity_verify_level(struct dm_verity *v, struct dm_verity_io *io,\n\t\t\t       sector_t block, int level, bool skip_unverified,\n\t\t\t       u8 *want_digest)\n{\n\tstruct dm_buffer *buf;\n\tstruct buffer_aux *aux;\n\tu8 *data;\n\tint r;\n\tsector_t hash_block;\n\tunsigned int offset;\n\n\tverity_hash_at_level(v, block, level, &hash_block, &offset);\n\n\tif (static_branch_unlikely(&use_tasklet_enabled) && io->in_tasklet) {\n\t\tdata = dm_bufio_get(v->bufio, hash_block, &buf);\n\t\tif (data == NULL) {\n\t\t\t \n\t\t\treturn -EAGAIN;\n\t\t}\n\t} else\n\t\tdata = dm_bufio_read(v->bufio, hash_block, &buf);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\taux = dm_bufio_get_aux_data(buf);\n\n\tif (!aux->hash_verified) {\n\t\tif (skip_unverified) {\n\t\t\tr = 1;\n\t\t\tgoto release_ret_r;\n\t\t}\n\n\t\tr = verity_hash(v, verity_io_hash_req(v, io),\n\t\t\t\tdata, 1 << v->hash_dev_block_bits,\n\t\t\t\tverity_io_real_digest(v, io), !io->in_tasklet);\n\t\tif (unlikely(r < 0))\n\t\t\tgoto release_ret_r;\n\n\t\tif (likely(memcmp(verity_io_real_digest(v, io), want_digest,\n\t\t\t\t  v->digest_size) == 0))\n\t\t\taux->hash_verified = 1;\n\t\telse if (static_branch_unlikely(&use_tasklet_enabled) &&\n\t\t\t io->in_tasklet) {\n\t\t\t \n\t\t\tr = -EAGAIN;\n\t\t\tgoto release_ret_r;\n\t\t} else if (verity_fec_decode(v, io, DM_VERITY_BLOCK_TYPE_METADATA,\n\t\t\t\t\t     hash_block, data, NULL) == 0)\n\t\t\taux->hash_verified = 1;\n\t\telse if (verity_handle_err(v,\n\t\t\t\t\t   DM_VERITY_BLOCK_TYPE_METADATA,\n\t\t\t\t\t   hash_block)) {\n\t\t\tstruct bio *bio =\n\t\t\t\tdm_bio_from_per_bio_data(io,\n\t\t\t\t\t\t\t v->ti->per_io_data_size);\n\t\t\tdm_audit_log_bio(DM_MSG_PREFIX, \"verify-metadata\", bio,\n\t\t\t\t\t block, 0);\n\t\t\tr = -EIO;\n\t\t\tgoto release_ret_r;\n\t\t}\n\t}\n\n\tdata += offset;\n\tmemcpy(want_digest, data, v->digest_size);\n\tr = 0;\n\nrelease_ret_r:\n\tdm_bufio_release(buf);\n\treturn r;\n}\n\n \nint verity_hash_for_block(struct dm_verity *v, struct dm_verity_io *io,\n\t\t\t  sector_t block, u8 *digest, bool *is_zero)\n{\n\tint r = 0, i;\n\n\tif (likely(v->levels)) {\n\t\t \n\t\tr = verity_verify_level(v, io, block, 0, true, digest);\n\t\tif (likely(r <= 0))\n\t\t\tgoto out;\n\t}\n\n\tmemcpy(digest, v->root_digest, v->digest_size);\n\n\tfor (i = v->levels - 1; i >= 0; i--) {\n\t\tr = verity_verify_level(v, io, block, i, false, digest);\n\t\tif (unlikely(r))\n\t\t\tgoto out;\n\t}\nout:\n\tif (!r && v->zero_digest)\n\t\t*is_zero = !memcmp(v->zero_digest, digest, v->digest_size);\n\telse\n\t\t*is_zero = false;\n\n\treturn r;\n}\n\n \nstatic int verity_for_io_block(struct dm_verity *v, struct dm_verity_io *io,\n\t\t\t       struct bvec_iter *iter, struct crypto_wait *wait)\n{\n\tunsigned int todo = 1 << v->data_dev_block_bits;\n\tstruct bio *bio = dm_bio_from_per_bio_data(io, v->ti->per_io_data_size);\n\tstruct scatterlist sg;\n\tstruct ahash_request *req = verity_io_hash_req(v, io);\n\n\tdo {\n\t\tint r;\n\t\tunsigned int len;\n\t\tstruct bio_vec bv = bio_iter_iovec(bio, *iter);\n\n\t\tsg_init_table(&sg, 1);\n\n\t\tlen = bv.bv_len;\n\n\t\tif (likely(len >= todo))\n\t\t\tlen = todo;\n\t\t \n\t\tsg_set_page(&sg, bv.bv_page, len, bv.bv_offset);\n\t\tahash_request_set_crypt(req, &sg, NULL, len);\n\t\tr = crypto_wait_req(crypto_ahash_update(req), wait);\n\n\t\tif (unlikely(r < 0)) {\n\t\t\tDMERR(\"%s crypto op failed: %d\", __func__, r);\n\t\t\treturn r;\n\t\t}\n\n\t\tbio_advance_iter(bio, iter, len);\n\t\ttodo -= len;\n\t} while (todo);\n\n\treturn 0;\n}\n\n \nint verity_for_bv_block(struct dm_verity *v, struct dm_verity_io *io,\n\t\t\tstruct bvec_iter *iter,\n\t\t\tint (*process)(struct dm_verity *v,\n\t\t\t\t       struct dm_verity_io *io, u8 *data,\n\t\t\t\t       size_t len))\n{\n\tunsigned int todo = 1 << v->data_dev_block_bits;\n\tstruct bio *bio = dm_bio_from_per_bio_data(io, v->ti->per_io_data_size);\n\n\tdo {\n\t\tint r;\n\t\tu8 *page;\n\t\tunsigned int len;\n\t\tstruct bio_vec bv = bio_iter_iovec(bio, *iter);\n\n\t\tpage = bvec_kmap_local(&bv);\n\t\tlen = bv.bv_len;\n\n\t\tif (likely(len >= todo))\n\t\t\tlen = todo;\n\n\t\tr = process(v, io, page, len);\n\t\tkunmap_local(page);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tbio_advance_iter(bio, iter, len);\n\t\ttodo -= len;\n\t} while (todo);\n\n\treturn 0;\n}\n\nstatic int verity_bv_zero(struct dm_verity *v, struct dm_verity_io *io,\n\t\t\t  u8 *data, size_t len)\n{\n\tmemset(data, 0, len);\n\treturn 0;\n}\n\n \nstatic inline void verity_bv_skip_block(struct dm_verity *v,\n\t\t\t\t\tstruct dm_verity_io *io,\n\t\t\t\t\tstruct bvec_iter *iter)\n{\n\tstruct bio *bio = dm_bio_from_per_bio_data(io, v->ti->per_io_data_size);\n\n\tbio_advance_iter(bio, iter, 1 << v->data_dev_block_bits);\n}\n\n \nstatic int verity_verify_io(struct dm_verity_io *io)\n{\n\tbool is_zero;\n\tstruct dm_verity *v = io->v;\n#if defined(CONFIG_DM_VERITY_FEC)\n\tstruct bvec_iter start;\n#endif\n\tstruct bvec_iter iter_copy;\n\tstruct bvec_iter *iter;\n\tstruct crypto_wait wait;\n\tstruct bio *bio = dm_bio_from_per_bio_data(io, v->ti->per_io_data_size);\n\tunsigned int b;\n\n\tif (static_branch_unlikely(&use_tasklet_enabled) && io->in_tasklet) {\n\t\t \n\t\titer_copy = io->iter;\n\t\titer = &iter_copy;\n\t} else\n\t\titer = &io->iter;\n\n\tfor (b = 0; b < io->n_blocks; b++) {\n\t\tint r;\n\t\tsector_t cur_block = io->block + b;\n\t\tstruct ahash_request *req = verity_io_hash_req(v, io);\n\n\t\tif (v->validated_blocks && bio->bi_status == BLK_STS_OK &&\n\t\t    likely(test_bit(cur_block, v->validated_blocks))) {\n\t\t\tverity_bv_skip_block(v, io, iter);\n\t\t\tcontinue;\n\t\t}\n\n\t\tr = verity_hash_for_block(v, io, cur_block,\n\t\t\t\t\t  verity_io_want_digest(v, io),\n\t\t\t\t\t  &is_zero);\n\t\tif (unlikely(r < 0))\n\t\t\treturn r;\n\n\t\tif (is_zero) {\n\t\t\t \n\t\t\tr = verity_for_bv_block(v, io, iter,\n\t\t\t\t\t\tverity_bv_zero);\n\t\t\tif (unlikely(r < 0))\n\t\t\t\treturn r;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tr = verity_hash_init(v, req, &wait, !io->in_tasklet);\n\t\tif (unlikely(r < 0))\n\t\t\treturn r;\n\n#if defined(CONFIG_DM_VERITY_FEC)\n\t\tif (verity_fec_is_enabled(v))\n\t\t\tstart = *iter;\n#endif\n\t\tr = verity_for_io_block(v, io, iter, &wait);\n\t\tif (unlikely(r < 0))\n\t\t\treturn r;\n\n\t\tr = verity_hash_final(v, req, verity_io_real_digest(v, io),\n\t\t\t\t\t&wait);\n\t\tif (unlikely(r < 0))\n\t\t\treturn r;\n\n\t\tif (likely(memcmp(verity_io_real_digest(v, io),\n\t\t\t\t  verity_io_want_digest(v, io), v->digest_size) == 0)) {\n\t\t\tif (v->validated_blocks)\n\t\t\t\tset_bit(cur_block, v->validated_blocks);\n\t\t\tcontinue;\n\t\t} else if (static_branch_unlikely(&use_tasklet_enabled) &&\n\t\t\t   io->in_tasklet) {\n\t\t\t \n\t\t\treturn -EAGAIN;\n#if defined(CONFIG_DM_VERITY_FEC)\n\t\t} else if (verity_fec_decode(v, io, DM_VERITY_BLOCK_TYPE_DATA,\n\t\t\t\t\t     cur_block, NULL, &start) == 0) {\n\t\t\tcontinue;\n#endif\n\t\t} else {\n\t\t\tif (bio->bi_status) {\n\t\t\t\t \n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (verity_handle_err(v, DM_VERITY_BLOCK_TYPE_DATA,\n\t\t\t\t\t      cur_block)) {\n\t\t\t\tdm_audit_log_bio(DM_MSG_PREFIX, \"verify-data\",\n\t\t\t\t\t\t bio, cur_block, 0);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline bool verity_is_system_shutting_down(void)\n{\n\treturn system_state == SYSTEM_HALT || system_state == SYSTEM_POWER_OFF\n\t\t|| system_state == SYSTEM_RESTART;\n}\n\n \nstatic void verity_finish_io(struct dm_verity_io *io, blk_status_t status)\n{\n\tstruct dm_verity *v = io->v;\n\tstruct bio *bio = dm_bio_from_per_bio_data(io, v->ti->per_io_data_size);\n\n\tbio->bi_end_io = io->orig_bi_end_io;\n\tbio->bi_status = status;\n\n\tif (!static_branch_unlikely(&use_tasklet_enabled) || !io->in_tasklet)\n\t\tverity_fec_finish_io(io);\n\n\tbio_endio(bio);\n}\n\nstatic void verity_work(struct work_struct *w)\n{\n\tstruct dm_verity_io *io = container_of(w, struct dm_verity_io, work);\n\n\tio->in_tasklet = false;\n\n\tverity_finish_io(io, errno_to_blk_status(verity_verify_io(io)));\n}\n\nstatic void verity_tasklet(unsigned long data)\n{\n\tstruct dm_verity_io *io = (struct dm_verity_io *)data;\n\tint err;\n\n\tio->in_tasklet = true;\n\terr = verity_verify_io(io);\n\tif (err == -EAGAIN || err == -ENOMEM) {\n\t\t \n\t\tINIT_WORK(&io->work, verity_work);\n\t\tqueue_work(io->v->verify_wq, &io->work);\n\t\treturn;\n\t}\n\n\tverity_finish_io(io, errno_to_blk_status(err));\n}\n\nstatic void verity_end_io(struct bio *bio)\n{\n\tstruct dm_verity_io *io = bio->bi_private;\n\n\tif (bio->bi_status &&\n\t    (!verity_fec_is_enabled(io->v) ||\n\t     verity_is_system_shutting_down() ||\n\t     (bio->bi_opf & REQ_RAHEAD))) {\n\t\tverity_finish_io(io, bio->bi_status);\n\t\treturn;\n\t}\n\n\tif (static_branch_unlikely(&use_tasklet_enabled) && io->v->use_tasklet) {\n\t\ttasklet_init(&io->tasklet, verity_tasklet, (unsigned long)io);\n\t\ttasklet_schedule(&io->tasklet);\n\t} else {\n\t\tINIT_WORK(&io->work, verity_work);\n\t\tqueue_work(io->v->verify_wq, &io->work);\n\t}\n}\n\n \nstatic void verity_prefetch_io(struct work_struct *work)\n{\n\tstruct dm_verity_prefetch_work *pw =\n\t\tcontainer_of(work, struct dm_verity_prefetch_work, work);\n\tstruct dm_verity *v = pw->v;\n\tint i;\n\n\tfor (i = v->levels - 2; i >= 0; i--) {\n\t\tsector_t hash_block_start;\n\t\tsector_t hash_block_end;\n\n\t\tverity_hash_at_level(v, pw->block, i, &hash_block_start, NULL);\n\t\tverity_hash_at_level(v, pw->block + pw->n_blocks - 1, i, &hash_block_end, NULL);\n\n\t\tif (!i) {\n\t\t\tunsigned int cluster = READ_ONCE(dm_verity_prefetch_cluster);\n\n\t\t\tcluster >>= v->data_dev_block_bits;\n\t\t\tif (unlikely(!cluster))\n\t\t\t\tgoto no_prefetch_cluster;\n\n\t\t\tif (unlikely(cluster & (cluster - 1)))\n\t\t\t\tcluster = 1 << __fls(cluster);\n\n\t\t\thash_block_start &= ~(sector_t)(cluster - 1);\n\t\t\thash_block_end |= cluster - 1;\n\t\t\tif (unlikely(hash_block_end >= v->hash_blocks))\n\t\t\t\thash_block_end = v->hash_blocks - 1;\n\t\t}\nno_prefetch_cluster:\n\t\tdm_bufio_prefetch(v->bufio, hash_block_start,\n\t\t\t\t  hash_block_end - hash_block_start + 1);\n\t}\n\n\tkfree(pw);\n}\n\nstatic void verity_submit_prefetch(struct dm_verity *v, struct dm_verity_io *io)\n{\n\tsector_t block = io->block;\n\tunsigned int n_blocks = io->n_blocks;\n\tstruct dm_verity_prefetch_work *pw;\n\n\tif (v->validated_blocks) {\n\t\twhile (n_blocks && test_bit(block, v->validated_blocks)) {\n\t\t\tblock++;\n\t\t\tn_blocks--;\n\t\t}\n\t\twhile (n_blocks && test_bit(block + n_blocks - 1,\n\t\t\t\t\t    v->validated_blocks))\n\t\t\tn_blocks--;\n\t\tif (!n_blocks)\n\t\t\treturn;\n\t}\n\n\tpw = kmalloc(sizeof(struct dm_verity_prefetch_work),\n\t\tGFP_NOIO | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\n\tif (!pw)\n\t\treturn;\n\n\tINIT_WORK(&pw->work, verity_prefetch_io);\n\tpw->v = v;\n\tpw->block = block;\n\tpw->n_blocks = n_blocks;\n\tqueue_work(v->verify_wq, &pw->work);\n}\n\n \nstatic int verity_map(struct dm_target *ti, struct bio *bio)\n{\n\tstruct dm_verity *v = ti->private;\n\tstruct dm_verity_io *io;\n\n\tbio_set_dev(bio, v->data_dev->bdev);\n\tbio->bi_iter.bi_sector = verity_map_sector(v, bio->bi_iter.bi_sector);\n\n\tif (((unsigned int)bio->bi_iter.bi_sector | bio_sectors(bio)) &\n\t    ((1 << (v->data_dev_block_bits - SECTOR_SHIFT)) - 1)) {\n\t\tDMERR_LIMIT(\"unaligned io\");\n\t\treturn DM_MAPIO_KILL;\n\t}\n\n\tif (bio_end_sector(bio) >>\n\t    (v->data_dev_block_bits - SECTOR_SHIFT) > v->data_blocks) {\n\t\tDMERR_LIMIT(\"io out of range\");\n\t\treturn DM_MAPIO_KILL;\n\t}\n\n\tif (bio_data_dir(bio) == WRITE)\n\t\treturn DM_MAPIO_KILL;\n\n\tio = dm_per_bio_data(bio, ti->per_io_data_size);\n\tio->v = v;\n\tio->orig_bi_end_io = bio->bi_end_io;\n\tio->block = bio->bi_iter.bi_sector >> (v->data_dev_block_bits - SECTOR_SHIFT);\n\tio->n_blocks = bio->bi_iter.bi_size >> v->data_dev_block_bits;\n\n\tbio->bi_end_io = verity_end_io;\n\tbio->bi_private = io;\n\tio->iter = bio->bi_iter;\n\n\tverity_fec_init_io(io);\n\n\tverity_submit_prefetch(v, io);\n\n\tsubmit_bio_noacct(bio);\n\n\treturn DM_MAPIO_SUBMITTED;\n}\n\n \nstatic void verity_status(struct dm_target *ti, status_type_t type,\n\t\t\t  unsigned int status_flags, char *result, unsigned int maxlen)\n{\n\tstruct dm_verity *v = ti->private;\n\tunsigned int args = 0;\n\tunsigned int sz = 0;\n\tunsigned int x;\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\tDMEMIT(\"%c\", v->hash_failed ? 'C' : 'V');\n\t\tbreak;\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\"%u %s %s %u %u %llu %llu %s \",\n\t\t\tv->version,\n\t\t\tv->data_dev->name,\n\t\t\tv->hash_dev->name,\n\t\t\t1 << v->data_dev_block_bits,\n\t\t\t1 << v->hash_dev_block_bits,\n\t\t\t(unsigned long long)v->data_blocks,\n\t\t\t(unsigned long long)v->hash_start,\n\t\t\tv->alg_name\n\t\t\t);\n\t\tfor (x = 0; x < v->digest_size; x++)\n\t\t\tDMEMIT(\"%02x\", v->root_digest[x]);\n\t\tDMEMIT(\" \");\n\t\tif (!v->salt_size)\n\t\t\tDMEMIT(\"-\");\n\t\telse\n\t\t\tfor (x = 0; x < v->salt_size; x++)\n\t\t\t\tDMEMIT(\"%02x\", v->salt[x]);\n\t\tif (v->mode != DM_VERITY_MODE_EIO)\n\t\t\targs++;\n\t\tif (verity_fec_is_enabled(v))\n\t\t\targs += DM_VERITY_OPTS_FEC;\n\t\tif (v->zero_digest)\n\t\t\targs++;\n\t\tif (v->validated_blocks)\n\t\t\targs++;\n\t\tif (v->use_tasklet)\n\t\t\targs++;\n\t\tif (v->signature_key_desc)\n\t\t\targs += DM_VERITY_ROOT_HASH_VERIFICATION_OPTS;\n\t\tif (!args)\n\t\t\treturn;\n\t\tDMEMIT(\" %u\", args);\n\t\tif (v->mode != DM_VERITY_MODE_EIO) {\n\t\t\tDMEMIT(\" \");\n\t\t\tswitch (v->mode) {\n\t\t\tcase DM_VERITY_MODE_LOGGING:\n\t\t\t\tDMEMIT(DM_VERITY_OPT_LOGGING);\n\t\t\t\tbreak;\n\t\t\tcase DM_VERITY_MODE_RESTART:\n\t\t\t\tDMEMIT(DM_VERITY_OPT_RESTART);\n\t\t\t\tbreak;\n\t\t\tcase DM_VERITY_MODE_PANIC:\n\t\t\t\tDMEMIT(DM_VERITY_OPT_PANIC);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\t\tif (v->zero_digest)\n\t\t\tDMEMIT(\" \" DM_VERITY_OPT_IGN_ZEROES);\n\t\tif (v->validated_blocks)\n\t\t\tDMEMIT(\" \" DM_VERITY_OPT_AT_MOST_ONCE);\n\t\tif (v->use_tasklet)\n\t\t\tDMEMIT(\" \" DM_VERITY_OPT_TASKLET_VERIFY);\n\t\tsz = verity_fec_status_table(v, sz, result, maxlen);\n\t\tif (v->signature_key_desc)\n\t\t\tDMEMIT(\" \" DM_VERITY_ROOT_HASH_VERIFICATION_OPT_SIG_KEY\n\t\t\t\t\" %s\", v->signature_key_desc);\n\t\tbreak;\n\n\tcase STATUSTYPE_IMA:\n\t\tDMEMIT_TARGET_NAME_VERSION(ti->type);\n\t\tDMEMIT(\",hash_failed=%c\", v->hash_failed ? 'C' : 'V');\n\t\tDMEMIT(\",verity_version=%u\", v->version);\n\t\tDMEMIT(\",data_device_name=%s\", v->data_dev->name);\n\t\tDMEMIT(\",hash_device_name=%s\", v->hash_dev->name);\n\t\tDMEMIT(\",verity_algorithm=%s\", v->alg_name);\n\n\t\tDMEMIT(\",root_digest=\");\n\t\tfor (x = 0; x < v->digest_size; x++)\n\t\t\tDMEMIT(\"%02x\", v->root_digest[x]);\n\n\t\tDMEMIT(\",salt=\");\n\t\tif (!v->salt_size)\n\t\t\tDMEMIT(\"-\");\n\t\telse\n\t\t\tfor (x = 0; x < v->salt_size; x++)\n\t\t\t\tDMEMIT(\"%02x\", v->salt[x]);\n\n\t\tDMEMIT(\",ignore_zero_blocks=%c\", v->zero_digest ? 'y' : 'n');\n\t\tDMEMIT(\",check_at_most_once=%c\", v->validated_blocks ? 'y' : 'n');\n\t\tif (v->signature_key_desc)\n\t\t\tDMEMIT(\",root_hash_sig_key_desc=%s\", v->signature_key_desc);\n\n\t\tif (v->mode != DM_VERITY_MODE_EIO) {\n\t\t\tDMEMIT(\",verity_mode=\");\n\t\t\tswitch (v->mode) {\n\t\t\tcase DM_VERITY_MODE_LOGGING:\n\t\t\t\tDMEMIT(DM_VERITY_OPT_LOGGING);\n\t\t\t\tbreak;\n\t\t\tcase DM_VERITY_MODE_RESTART:\n\t\t\t\tDMEMIT(DM_VERITY_OPT_RESTART);\n\t\t\t\tbreak;\n\t\t\tcase DM_VERITY_MODE_PANIC:\n\t\t\t\tDMEMIT(DM_VERITY_OPT_PANIC);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDMEMIT(\"invalid\");\n\t\t\t}\n\t\t}\n\t\tDMEMIT(\";\");\n\t\tbreak;\n\t}\n}\n\nstatic int verity_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)\n{\n\tstruct dm_verity *v = ti->private;\n\n\t*bdev = v->data_dev->bdev;\n\n\tif (v->data_start || ti->len != bdev_nr_sectors(v->data_dev->bdev))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int verity_iterate_devices(struct dm_target *ti,\n\t\t\t\t  iterate_devices_callout_fn fn, void *data)\n{\n\tstruct dm_verity *v = ti->private;\n\n\treturn fn(ti, v->data_dev, v->data_start, ti->len, data);\n}\n\nstatic void verity_io_hints(struct dm_target *ti, struct queue_limits *limits)\n{\n\tstruct dm_verity *v = ti->private;\n\n\tif (limits->logical_block_size < 1 << v->data_dev_block_bits)\n\t\tlimits->logical_block_size = 1 << v->data_dev_block_bits;\n\n\tif (limits->physical_block_size < 1 << v->data_dev_block_bits)\n\t\tlimits->physical_block_size = 1 << v->data_dev_block_bits;\n\n\tblk_limits_io_min(limits, limits->logical_block_size);\n}\n\nstatic void verity_dtr(struct dm_target *ti)\n{\n\tstruct dm_verity *v = ti->private;\n\n\tif (v->verify_wq)\n\t\tdestroy_workqueue(v->verify_wq);\n\n\tif (v->bufio)\n\t\tdm_bufio_client_destroy(v->bufio);\n\n\tkvfree(v->validated_blocks);\n\tkfree(v->salt);\n\tkfree(v->root_digest);\n\tkfree(v->zero_digest);\n\n\tif (v->tfm)\n\t\tcrypto_free_ahash(v->tfm);\n\n\tkfree(v->alg_name);\n\n\tif (v->hash_dev)\n\t\tdm_put_device(ti, v->hash_dev);\n\n\tif (v->data_dev)\n\t\tdm_put_device(ti, v->data_dev);\n\n\tverity_fec_dtr(v);\n\n\tkfree(v->signature_key_desc);\n\n\tif (v->use_tasklet)\n\t\tstatic_branch_dec(&use_tasklet_enabled);\n\n\tkfree(v);\n\n\tdm_audit_log_dtr(DM_MSG_PREFIX, ti, 1);\n}\n\nstatic int verity_alloc_most_once(struct dm_verity *v)\n{\n\tstruct dm_target *ti = v->ti;\n\n\t \n\tif (v->data_blocks > INT_MAX) {\n\t\tti->error = \"device too large to use check_at_most_once\";\n\t\treturn -E2BIG;\n\t}\n\n\tv->validated_blocks = kvcalloc(BITS_TO_LONGS(v->data_blocks),\n\t\t\t\t       sizeof(unsigned long),\n\t\t\t\t       GFP_KERNEL);\n\tif (!v->validated_blocks) {\n\t\tti->error = \"failed to allocate bitset for check_at_most_once\";\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int verity_alloc_zero_digest(struct dm_verity *v)\n{\n\tint r = -ENOMEM;\n\tstruct ahash_request *req;\n\tu8 *zero_data;\n\n\tv->zero_digest = kmalloc(v->digest_size, GFP_KERNEL);\n\n\tif (!v->zero_digest)\n\t\treturn r;\n\n\treq = kmalloc(v->ahash_reqsize, GFP_KERNEL);\n\n\tif (!req)\n\t\treturn r;  \n\n\tzero_data = kzalloc(1 << v->data_dev_block_bits, GFP_KERNEL);\n\n\tif (!zero_data)\n\t\tgoto out;\n\n\tr = verity_hash(v, req, zero_data, 1 << v->data_dev_block_bits,\n\t\t\tv->zero_digest, true);\n\nout:\n\tkfree(req);\n\tkfree(zero_data);\n\n\treturn r;\n}\n\nstatic inline bool verity_is_verity_mode(const char *arg_name)\n{\n\treturn (!strcasecmp(arg_name, DM_VERITY_OPT_LOGGING) ||\n\t\t!strcasecmp(arg_name, DM_VERITY_OPT_RESTART) ||\n\t\t!strcasecmp(arg_name, DM_VERITY_OPT_PANIC));\n}\n\nstatic int verity_parse_verity_mode(struct dm_verity *v, const char *arg_name)\n{\n\tif (v->mode)\n\t\treturn -EINVAL;\n\n\tif (!strcasecmp(arg_name, DM_VERITY_OPT_LOGGING))\n\t\tv->mode = DM_VERITY_MODE_LOGGING;\n\telse if (!strcasecmp(arg_name, DM_VERITY_OPT_RESTART))\n\t\tv->mode = DM_VERITY_MODE_RESTART;\n\telse if (!strcasecmp(arg_name, DM_VERITY_OPT_PANIC))\n\t\tv->mode = DM_VERITY_MODE_PANIC;\n\n\treturn 0;\n}\n\nstatic int verity_parse_opt_args(struct dm_arg_set *as, struct dm_verity *v,\n\t\t\t\t struct dm_verity_sig_opts *verify_args,\n\t\t\t\t bool only_modifier_opts)\n{\n\tint r = 0;\n\tunsigned int argc;\n\tstruct dm_target *ti = v->ti;\n\tconst char *arg_name;\n\n\tstatic const struct dm_arg _args[] = {\n\t\t{0, DM_VERITY_OPTS_MAX, \"Invalid number of feature args\"},\n\t};\n\n\tr = dm_read_arg_group(_args, as, &argc, &ti->error);\n\tif (r)\n\t\treturn -EINVAL;\n\n\tif (!argc)\n\t\treturn 0;\n\n\tdo {\n\t\targ_name = dm_shift_arg(as);\n\t\targc--;\n\n\t\tif (verity_is_verity_mode(arg_name)) {\n\t\t\tif (only_modifier_opts)\n\t\t\t\tcontinue;\n\t\t\tr = verity_parse_verity_mode(v, arg_name);\n\t\t\tif (r) {\n\t\t\t\tti->error = \"Conflicting error handling parameters\";\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t} else if (!strcasecmp(arg_name, DM_VERITY_OPT_IGN_ZEROES)) {\n\t\t\tif (only_modifier_opts)\n\t\t\t\tcontinue;\n\t\t\tr = verity_alloc_zero_digest(v);\n\t\t\tif (r) {\n\t\t\t\tti->error = \"Cannot allocate zero digest\";\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t} else if (!strcasecmp(arg_name, DM_VERITY_OPT_AT_MOST_ONCE)) {\n\t\t\tif (only_modifier_opts)\n\t\t\t\tcontinue;\n\t\t\tr = verity_alloc_most_once(v);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tcontinue;\n\n\t\t} else if (!strcasecmp(arg_name, DM_VERITY_OPT_TASKLET_VERIFY)) {\n\t\t\tv->use_tasklet = true;\n\t\t\tstatic_branch_inc(&use_tasklet_enabled);\n\t\t\tcontinue;\n\n\t\t} else if (verity_is_fec_opt_arg(arg_name)) {\n\t\t\tif (only_modifier_opts)\n\t\t\t\tcontinue;\n\t\t\tr = verity_fec_parse_opt_args(as, v, &argc, arg_name);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tcontinue;\n\n\t\t} else if (verity_verify_is_sig_opt_arg(arg_name)) {\n\t\t\tif (only_modifier_opts)\n\t\t\t\tcontinue;\n\t\t\tr = verity_verify_sig_parse_opt_args(as, v,\n\t\t\t\t\t\t\t     verify_args,\n\t\t\t\t\t\t\t     &argc, arg_name);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tcontinue;\n\n\t\t} else if (only_modifier_opts) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tDMERR(\"Unrecognized verity feature request: %s\", arg_name);\n\t\tti->error = \"Unrecognized verity feature request\";\n\t\treturn -EINVAL;\n\t} while (argc && !r);\n\n\treturn r;\n}\n\n \nstatic int verity_ctr(struct dm_target *ti, unsigned int argc, char **argv)\n{\n\tstruct dm_verity *v;\n\tstruct dm_verity_sig_opts verify_args = {0};\n\tstruct dm_arg_set as;\n\tunsigned int num;\n\tunsigned long long num_ll;\n\tint r;\n\tint i;\n\tsector_t hash_position;\n\tchar dummy;\n\tchar *root_hash_digest_to_validate;\n\n\tv = kzalloc(sizeof(struct dm_verity), GFP_KERNEL);\n\tif (!v) {\n\t\tti->error = \"Cannot allocate verity structure\";\n\t\treturn -ENOMEM;\n\t}\n\tti->private = v;\n\tv->ti = ti;\n\n\tr = verity_fec_ctr_alloc(v);\n\tif (r)\n\t\tgoto bad;\n\n\tif ((dm_table_get_mode(ti->table) & ~BLK_OPEN_READ)) {\n\t\tti->error = \"Device must be readonly\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\tif (argc < 10) {\n\t\tti->error = \"Not enough arguments\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\t \n\tif (argc > 10) {\n\t\tas.argc = argc - 10;\n\t\tas.argv = argv + 10;\n\t\tr = verity_parse_opt_args(&as, v, &verify_args, true);\n\t\tif (r < 0)\n\t\t\tgoto bad;\n\t}\n\n\tif (sscanf(argv[0], \"%u%c\", &num, &dummy) != 1 ||\n\t    num > 1) {\n\t\tti->error = \"Invalid version\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\tv->version = num;\n\n\tr = dm_get_device(ti, argv[1], BLK_OPEN_READ, &v->data_dev);\n\tif (r) {\n\t\tti->error = \"Data device lookup failed\";\n\t\tgoto bad;\n\t}\n\n\tr = dm_get_device(ti, argv[2], BLK_OPEN_READ, &v->hash_dev);\n\tif (r) {\n\t\tti->error = \"Hash device lookup failed\";\n\t\tgoto bad;\n\t}\n\n\tif (sscanf(argv[3], \"%u%c\", &num, &dummy) != 1 ||\n\t    !num || (num & (num - 1)) ||\n\t    num < bdev_logical_block_size(v->data_dev->bdev) ||\n\t    num > PAGE_SIZE) {\n\t\tti->error = \"Invalid data device block size\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\tv->data_dev_block_bits = __ffs(num);\n\n\tif (sscanf(argv[4], \"%u%c\", &num, &dummy) != 1 ||\n\t    !num || (num & (num - 1)) ||\n\t    num < bdev_logical_block_size(v->hash_dev->bdev) ||\n\t    num > INT_MAX) {\n\t\tti->error = \"Invalid hash device block size\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\tv->hash_dev_block_bits = __ffs(num);\n\n\tif (sscanf(argv[5], \"%llu%c\", &num_ll, &dummy) != 1 ||\n\t    (sector_t)(num_ll << (v->data_dev_block_bits - SECTOR_SHIFT))\n\t    >> (v->data_dev_block_bits - SECTOR_SHIFT) != num_ll) {\n\t\tti->error = \"Invalid data blocks\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\tv->data_blocks = num_ll;\n\n\tif (ti->len > (v->data_blocks << (v->data_dev_block_bits - SECTOR_SHIFT))) {\n\t\tti->error = \"Data device is too small\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\tif (sscanf(argv[6], \"%llu%c\", &num_ll, &dummy) != 1 ||\n\t    (sector_t)(num_ll << (v->hash_dev_block_bits - SECTOR_SHIFT))\n\t    >> (v->hash_dev_block_bits - SECTOR_SHIFT) != num_ll) {\n\t\tti->error = \"Invalid hash start\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\tv->hash_start = num_ll;\n\n\tv->alg_name = kstrdup(argv[7], GFP_KERNEL);\n\tif (!v->alg_name) {\n\t\tti->error = \"Cannot allocate algorithm name\";\n\t\tr = -ENOMEM;\n\t\tgoto bad;\n\t}\n\n\tv->tfm = crypto_alloc_ahash(v->alg_name, 0,\n\t\t\t\t    v->use_tasklet ? CRYPTO_ALG_ASYNC : 0);\n\tif (IS_ERR(v->tfm)) {\n\t\tti->error = \"Cannot initialize hash function\";\n\t\tr = PTR_ERR(v->tfm);\n\t\tv->tfm = NULL;\n\t\tgoto bad;\n\t}\n\n\t \n\tDMINFO(\"%s using implementation \\\"%s\\\"\", v->alg_name,\n\t       crypto_hash_alg_common(v->tfm)->base.cra_driver_name);\n\n\tv->digest_size = crypto_ahash_digestsize(v->tfm);\n\tif ((1 << v->hash_dev_block_bits) < v->digest_size * 2) {\n\t\tti->error = \"Digest size too big\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\tv->ahash_reqsize = sizeof(struct ahash_request) +\n\t\tcrypto_ahash_reqsize(v->tfm);\n\n\tv->root_digest = kmalloc(v->digest_size, GFP_KERNEL);\n\tif (!v->root_digest) {\n\t\tti->error = \"Cannot allocate root digest\";\n\t\tr = -ENOMEM;\n\t\tgoto bad;\n\t}\n\tif (strlen(argv[8]) != v->digest_size * 2 ||\n\t    hex2bin(v->root_digest, argv[8], v->digest_size)) {\n\t\tti->error = \"Invalid root digest\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\troot_hash_digest_to_validate = argv[8];\n\n\tif (strcmp(argv[9], \"-\")) {\n\t\tv->salt_size = strlen(argv[9]) / 2;\n\t\tv->salt = kmalloc(v->salt_size, GFP_KERNEL);\n\t\tif (!v->salt) {\n\t\t\tti->error = \"Cannot allocate salt\";\n\t\t\tr = -ENOMEM;\n\t\t\tgoto bad;\n\t\t}\n\t\tif (strlen(argv[9]) != v->salt_size * 2 ||\n\t\t    hex2bin(v->salt, argv[9], v->salt_size)) {\n\t\t\tti->error = \"Invalid salt\";\n\t\t\tr = -EINVAL;\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\targv += 10;\n\targc -= 10;\n\n\t \n\tif (argc) {\n\t\tas.argc = argc;\n\t\tas.argv = argv;\n\t\tr = verity_parse_opt_args(&as, v, &verify_args, false);\n\t\tif (r < 0)\n\t\t\tgoto bad;\n\t}\n\n\t \n\tr = verity_verify_root_hash(root_hash_digest_to_validate,\n\t\t\t\t    strlen(root_hash_digest_to_validate),\n\t\t\t\t    verify_args.sig,\n\t\t\t\t    verify_args.sig_size);\n\tif (r < 0) {\n\t\tti->error = \"Root hash verification failed\";\n\t\tgoto bad;\n\t}\n\tv->hash_per_block_bits =\n\t\t__fls((1 << v->hash_dev_block_bits) / v->digest_size);\n\n\tv->levels = 0;\n\tif (v->data_blocks)\n\t\twhile (v->hash_per_block_bits * v->levels < 64 &&\n\t\t       (unsigned long long)(v->data_blocks - 1) >>\n\t\t       (v->hash_per_block_bits * v->levels))\n\t\t\tv->levels++;\n\n\tif (v->levels > DM_VERITY_MAX_LEVELS) {\n\t\tti->error = \"Too many tree levels\";\n\t\tr = -E2BIG;\n\t\tgoto bad;\n\t}\n\n\thash_position = v->hash_start;\n\tfor (i = v->levels - 1; i >= 0; i--) {\n\t\tsector_t s;\n\n\t\tv->hash_level_block[i] = hash_position;\n\t\ts = (v->data_blocks + ((sector_t)1 << ((i + 1) * v->hash_per_block_bits)) - 1)\n\t\t\t\t\t>> ((i + 1) * v->hash_per_block_bits);\n\t\tif (hash_position + s < hash_position) {\n\t\t\tti->error = \"Hash device offset overflow\";\n\t\t\tr = -E2BIG;\n\t\t\tgoto bad;\n\t\t}\n\t\thash_position += s;\n\t}\n\tv->hash_blocks = hash_position;\n\n\tv->bufio = dm_bufio_client_create(v->hash_dev->bdev,\n\t\t1 << v->hash_dev_block_bits, 1, sizeof(struct buffer_aux),\n\t\tdm_bufio_alloc_callback, NULL,\n\t\tv->use_tasklet ? DM_BUFIO_CLIENT_NO_SLEEP : 0);\n\tif (IS_ERR(v->bufio)) {\n\t\tti->error = \"Cannot initialize dm-bufio\";\n\t\tr = PTR_ERR(v->bufio);\n\t\tv->bufio = NULL;\n\t\tgoto bad;\n\t}\n\n\tif (dm_bufio_get_device_size(v->bufio) < v->hash_blocks) {\n\t\tti->error = \"Hash device is too small\";\n\t\tr = -E2BIG;\n\t\tgoto bad;\n\t}\n\n\t \n\tv->verify_wq = alloc_workqueue(\"kverityd\", WQ_MEM_RECLAIM | WQ_HIGHPRI, 0);\n\tif (!v->verify_wq) {\n\t\tti->error = \"Cannot allocate workqueue\";\n\t\tr = -ENOMEM;\n\t\tgoto bad;\n\t}\n\n\tti->per_io_data_size = sizeof(struct dm_verity_io) +\n\t\t\t\tv->ahash_reqsize + v->digest_size * 2;\n\n\tr = verity_fec_ctr(v);\n\tif (r)\n\t\tgoto bad;\n\n\tti->per_io_data_size = roundup(ti->per_io_data_size,\n\t\t\t\t       __alignof__(struct dm_verity_io));\n\n\tverity_verify_sig_opts_cleanup(&verify_args);\n\n\tdm_audit_log_ctr(DM_MSG_PREFIX, ti, 1);\n\n\treturn 0;\n\nbad:\n\n\tverity_verify_sig_opts_cleanup(&verify_args);\n\tdm_audit_log_ctr(DM_MSG_PREFIX, ti, 0);\n\tverity_dtr(ti);\n\n\treturn r;\n}\n\n \nbool dm_is_verity_target(struct dm_target *ti)\n{\n\treturn ti->type->module == THIS_MODULE;\n}\n\n \nint dm_verity_get_mode(struct dm_target *ti)\n{\n\tstruct dm_verity *v = ti->private;\n\n\tif (!dm_is_verity_target(ti))\n\t\treturn -EINVAL;\n\n\treturn v->mode;\n}\n\n \nint dm_verity_get_root_digest(struct dm_target *ti, u8 **root_digest, unsigned int *digest_size)\n{\n\tstruct dm_verity *v = ti->private;\n\n\tif (!dm_is_verity_target(ti))\n\t\treturn -EINVAL;\n\n\t*root_digest = kmemdup(v->root_digest, v->digest_size, GFP_KERNEL);\n\tif (*root_digest == NULL)\n\t\treturn -ENOMEM;\n\n\t*digest_size = v->digest_size;\n\n\treturn 0;\n}\n\nstatic struct target_type verity_target = {\n\t.name\t\t= \"verity\",\n\t.features\t= DM_TARGET_IMMUTABLE,\n\t.version\t= {1, 9, 0},\n\t.module\t\t= THIS_MODULE,\n\t.ctr\t\t= verity_ctr,\n\t.dtr\t\t= verity_dtr,\n\t.map\t\t= verity_map,\n\t.status\t\t= verity_status,\n\t.prepare_ioctl\t= verity_prepare_ioctl,\n\t.iterate_devices = verity_iterate_devices,\n\t.io_hints\t= verity_io_hints,\n};\nmodule_dm(verity);\n\nMODULE_AUTHOR(\"Mikulas Patocka <mpatocka@redhat.com>\");\nMODULE_AUTHOR(\"Mandeep Baines <msb@chromium.org>\");\nMODULE_AUTHOR(\"Will Drewry <wad@chromium.org>\");\nMODULE_DESCRIPTION(DM_NAME \" target for transparent disk integrity checking\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}