{
  "module_name": "dm-clone-target.c",
  "hash_id": "827c341d41797b7aa7da2ccc8fa5470c076c4c3fa0a08f8686eafbd16b713b46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-clone-target.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/err.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/log2.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/dm-io.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/kdev_t.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/mempool.h>\n#include <linux/spinlock.h>\n#include <linux/blk_types.h>\n#include <linux/dm-kcopyd.h>\n#include <linux/workqueue.h>\n#include <linux/backing-dev.h>\n#include <linux/device-mapper.h>\n\n#include \"dm.h\"\n#include \"dm-clone-metadata.h\"\n\n#define DM_MSG_PREFIX \"clone\"\n\n \n#define MIN_REGION_SIZE (1 << 3)   \n#define MAX_REGION_SIZE (1 << 21)  \n\n#define MIN_HYDRATIONS 256  \n#define DEFAULT_HYDRATION_THRESHOLD 1  \n#define DEFAULT_HYDRATION_BATCH_SIZE 1  \n\n#define COMMIT_PERIOD HZ  \n\n \n#define HASH_TABLE_BITS 15\n\nDECLARE_DM_KCOPYD_THROTTLE_WITH_MODULE_PARM(clone_hydration_throttle,\n\t\"A percentage of time allocated for hydrating regions\");\n\n \nstatic struct kmem_cache *_hydration_cache;\n\n \nenum clone_metadata_mode {\n\tCM_WRITE,\t\t \n\tCM_READ_ONLY,\t\t \n\tCM_FAIL,\t\t \n};\n\nstruct hash_table_bucket;\n\nstruct clone {\n\tstruct dm_target *ti;\n\n\tstruct dm_dev *metadata_dev;\n\tstruct dm_dev *dest_dev;\n\tstruct dm_dev *source_dev;\n\n\tunsigned long nr_regions;\n\tsector_t region_size;\n\tunsigned int region_shift;\n\n\t \n\tstruct mutex commit_lock;\n\n\tstruct dm_clone_metadata *cmd;\n\n\t \n\tstruct hash_table_bucket *ht;\n\n\tatomic_t ios_in_flight;\n\n\twait_queue_head_t hydration_stopped;\n\n\tmempool_t hydration_pool;\n\n\tunsigned long last_commit_jiffies;\n\n\t \n\tspinlock_t lock;\n\tstruct bio_list deferred_bios;\n\tstruct bio_list deferred_discard_bios;\n\tstruct bio_list deferred_flush_bios;\n\tstruct bio_list deferred_flush_completions;\n\n\t \n\tunsigned int hydration_threshold;\n\n\t \n\tunsigned int hydration_batch_size;\n\n\t \n\tunsigned long hydration_offset;\n\n\tatomic_t hydrations_in_flight;\n\n\t \n\tunsigned int nr_ctr_args;\n\tconst char **ctr_args;\n\n\tstruct workqueue_struct *wq;\n\tstruct work_struct worker;\n\tstruct delayed_work waker;\n\n\tstruct dm_kcopyd_client *kcopyd_client;\n\n\tenum clone_metadata_mode mode;\n\tunsigned long flags;\n};\n\n \n#define DM_CLONE_DISCARD_PASSDOWN 0\n#define DM_CLONE_HYDRATION_ENABLED 1\n#define DM_CLONE_HYDRATION_SUSPENDED 2\n\n \n\n \nstatic enum clone_metadata_mode get_clone_mode(struct clone *clone)\n{\n\treturn READ_ONCE(clone->mode);\n}\n\nstatic const char *clone_device_name(struct clone *clone)\n{\n\treturn dm_table_device_name(clone->ti->table);\n}\n\nstatic void __set_clone_mode(struct clone *clone, enum clone_metadata_mode new_mode)\n{\n\tstatic const char * const descs[] = {\n\t\t\"read-write\",\n\t\t\"read-only\",\n\t\t\"fail\"\n\t};\n\n\tenum clone_metadata_mode old_mode = get_clone_mode(clone);\n\n\t \n\tif (old_mode == CM_FAIL)\n\t\tnew_mode = CM_FAIL;\n\n\tswitch (new_mode) {\n\tcase CM_FAIL:\n\tcase CM_READ_ONLY:\n\t\tdm_clone_metadata_set_read_only(clone->cmd);\n\t\tbreak;\n\n\tcase CM_WRITE:\n\t\tdm_clone_metadata_set_read_write(clone->cmd);\n\t\tbreak;\n\t}\n\n\tWRITE_ONCE(clone->mode, new_mode);\n\n\tif (new_mode != old_mode) {\n\t\tdm_table_event(clone->ti->table);\n\t\tDMINFO(\"%s: Switching to %s mode\", clone_device_name(clone),\n\t\t       descs[(int)new_mode]);\n\t}\n}\n\nstatic void __abort_transaction(struct clone *clone)\n{\n\tconst char *dev_name = clone_device_name(clone);\n\n\tif (get_clone_mode(clone) >= CM_READ_ONLY)\n\t\treturn;\n\n\tDMERR(\"%s: Aborting current metadata transaction\", dev_name);\n\tif (dm_clone_metadata_abort(clone->cmd)) {\n\t\tDMERR(\"%s: Failed to abort metadata transaction\", dev_name);\n\t\t__set_clone_mode(clone, CM_FAIL);\n\t}\n}\n\nstatic void __reload_in_core_bitset(struct clone *clone)\n{\n\tconst char *dev_name = clone_device_name(clone);\n\n\tif (get_clone_mode(clone) == CM_FAIL)\n\t\treturn;\n\n\t \n\tDMINFO(\"%s: Reloading on-disk bitmap\", dev_name);\n\tif (dm_clone_reload_in_core_bitset(clone->cmd)) {\n\t\tDMERR(\"%s: Failed to reload on-disk bitmap\", dev_name);\n\t\t__set_clone_mode(clone, CM_FAIL);\n\t}\n}\n\nstatic void __metadata_operation_failed(struct clone *clone, const char *op, int r)\n{\n\tDMERR(\"%s: Metadata operation `%s' failed: error = %d\",\n\t      clone_device_name(clone), op, r);\n\n\t__abort_transaction(clone);\n\t__set_clone_mode(clone, CM_READ_ONLY);\n\n\t \n\t__reload_in_core_bitset(clone);\n}\n\n \n\n \nstatic inline void wakeup_hydration_waiters(struct clone *clone)\n{\n\twake_up_all(&clone->hydration_stopped);\n}\n\nstatic inline void wake_worker(struct clone *clone)\n{\n\tqueue_work(clone->wq, &clone->worker);\n}\n\n \n\n \nstatic inline void remap_to_source(struct clone *clone, struct bio *bio)\n{\n\tbio_set_dev(bio, clone->source_dev->bdev);\n}\n\nstatic inline void remap_to_dest(struct clone *clone, struct bio *bio)\n{\n\tbio_set_dev(bio, clone->dest_dev->bdev);\n}\n\nstatic bool bio_triggers_commit(struct clone *clone, struct bio *bio)\n{\n\treturn op_is_flush(bio->bi_opf) &&\n\t\tdm_clone_changed_this_transaction(clone->cmd);\n}\n\n \nstatic inline sector_t region_to_sector(struct clone *clone, unsigned long region_nr)\n{\n\treturn ((sector_t)region_nr << clone->region_shift);\n}\n\n \nstatic inline unsigned long bio_to_region(struct clone *clone, struct bio *bio)\n{\n\treturn (bio->bi_iter.bi_sector >> clone->region_shift);\n}\n\n \nstatic void bio_region_range(struct clone *clone, struct bio *bio,\n\t\t\t     unsigned long *rs, unsigned long *nr_regions)\n{\n\tunsigned long end;\n\n\t*rs = dm_sector_div_up(bio->bi_iter.bi_sector, clone->region_size);\n\tend = bio_end_sector(bio) >> clone->region_shift;\n\n\tif (*rs >= end)\n\t\t*nr_regions = 0;\n\telse\n\t\t*nr_regions = end - *rs;\n}\n\n \nstatic inline bool is_overwrite_bio(struct clone *clone, struct bio *bio)\n{\n\treturn (bio_data_dir(bio) == WRITE && bio_sectors(bio) == clone->region_size);\n}\n\nstatic void fail_bios(struct bio_list *bios, blk_status_t status)\n{\n\tstruct bio *bio;\n\n\twhile ((bio = bio_list_pop(bios))) {\n\t\tbio->bi_status = status;\n\t\tbio_endio(bio);\n\t}\n}\n\nstatic void submit_bios(struct bio_list *bios)\n{\n\tstruct bio *bio;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\n\twhile ((bio = bio_list_pop(bios)))\n\t\tsubmit_bio_noacct(bio);\n\n\tblk_finish_plug(&plug);\n}\n\n \nstatic void issue_bio(struct clone *clone, struct bio *bio)\n{\n\tif (!bio_triggers_commit(clone, bio)) {\n\t\tsubmit_bio_noacct(bio);\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(get_clone_mode(clone) >= CM_READ_ONLY)) {\n\t\tbio_io_error(bio);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irq(&clone->lock);\n\tbio_list_add(&clone->deferred_flush_bios, bio);\n\tspin_unlock_irq(&clone->lock);\n\n\twake_worker(clone);\n}\n\n \nstatic void remap_and_issue(struct clone *clone, struct bio *bio)\n{\n\tremap_to_dest(clone, bio);\n\tissue_bio(clone, bio);\n}\n\n \nstatic void issue_deferred_bios(struct clone *clone, struct bio_list *bios)\n{\n\tstruct bio *bio;\n\tunsigned long flags;\n\tstruct bio_list flush_bios = BIO_EMPTY_LIST;\n\tstruct bio_list normal_bios = BIO_EMPTY_LIST;\n\n\tif (bio_list_empty(bios))\n\t\treturn;\n\n\twhile ((bio = bio_list_pop(bios))) {\n\t\tif (bio_triggers_commit(clone, bio))\n\t\t\tbio_list_add(&flush_bios, bio);\n\t\telse\n\t\t\tbio_list_add(&normal_bios, bio);\n\t}\n\n\tspin_lock_irqsave(&clone->lock, flags);\n\tbio_list_merge(&clone->deferred_bios, &normal_bios);\n\tbio_list_merge(&clone->deferred_flush_bios, &flush_bios);\n\tspin_unlock_irqrestore(&clone->lock, flags);\n\n\twake_worker(clone);\n}\n\nstatic void complete_overwrite_bio(struct clone *clone, struct bio *bio)\n{\n\tunsigned long flags;\n\n\t \n\tif (!(bio->bi_opf & REQ_FUA)) {\n\t\tbio_endio(bio);\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(get_clone_mode(clone) >= CM_READ_ONLY)) {\n\t\tbio_io_error(bio);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&clone->lock, flags);\n\tbio_list_add(&clone->deferred_flush_completions, bio);\n\tspin_unlock_irqrestore(&clone->lock, flags);\n\n\twake_worker(clone);\n}\n\nstatic void trim_bio(struct bio *bio, sector_t sector, unsigned int len)\n{\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_iter.bi_size = to_bytes(len);\n}\n\nstatic void complete_discard_bio(struct clone *clone, struct bio *bio, bool success)\n{\n\tunsigned long rs, nr_regions;\n\n\t \n\tif (test_bit(DM_CLONE_DISCARD_PASSDOWN, &clone->flags) && success) {\n\t\tremap_to_dest(clone, bio);\n\t\tbio_region_range(clone, bio, &rs, &nr_regions);\n\t\ttrim_bio(bio, region_to_sector(clone, rs),\n\t\t\t nr_regions << clone->region_shift);\n\t\tsubmit_bio_noacct(bio);\n\t} else\n\t\tbio_endio(bio);\n}\n\nstatic void process_discard_bio(struct clone *clone, struct bio *bio)\n{\n\tunsigned long rs, nr_regions;\n\n\tbio_region_range(clone, bio, &rs, &nr_regions);\n\tif (!nr_regions) {\n\t\tbio_endio(bio);\n\t\treturn;\n\t}\n\n\tif (WARN_ON(rs >= clone->nr_regions || (rs + nr_regions) < rs ||\n\t\t    (rs + nr_regions) > clone->nr_regions)) {\n\t\tDMERR(\"%s: Invalid range (%lu + %lu, total regions %lu) for discard (%llu + %u)\",\n\t\t      clone_device_name(clone), rs, nr_regions,\n\t\t      clone->nr_regions,\n\t\t      (unsigned long long)bio->bi_iter.bi_sector,\n\t\t      bio_sectors(bio));\n\t\tbio_endio(bio);\n\t\treturn;\n\t}\n\n\t \n\tif (dm_clone_is_range_hydrated(clone->cmd, rs, nr_regions)) {\n\t\tcomplete_discard_bio(clone, bio, true);\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(get_clone_mode(clone) >= CM_READ_ONLY)) {\n\t\tbio_endio(bio);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irq(&clone->lock);\n\tbio_list_add(&clone->deferred_discard_bios, bio);\n\tspin_unlock_irq(&clone->lock);\n\n\twake_worker(clone);\n}\n\n \n\n \nstruct dm_clone_region_hydration {\n\tstruct clone *clone;\n\tunsigned long region_nr;\n\n\tstruct bio *overwrite_bio;\n\tbio_end_io_t *overwrite_bio_end_io;\n\n\tstruct bio_list deferred_bios;\n\n\tblk_status_t status;\n\n\t \n\tstruct list_head list;\n\n\t \n\tstruct hlist_node h;\n};\n\n \nstruct hash_table_bucket {\n\tstruct hlist_head head;\n\n\t \n\tspinlock_t lock;\n};\n\n#define bucket_lock_irqsave(bucket, flags) \\\n\tspin_lock_irqsave(&(bucket)->lock, flags)\n\n#define bucket_unlock_irqrestore(bucket, flags) \\\n\tspin_unlock_irqrestore(&(bucket)->lock, flags)\n\n#define bucket_lock_irq(bucket) \\\n\tspin_lock_irq(&(bucket)->lock)\n\n#define bucket_unlock_irq(bucket) \\\n\tspin_unlock_irq(&(bucket)->lock)\n\nstatic int hash_table_init(struct clone *clone)\n{\n\tunsigned int i, sz;\n\tstruct hash_table_bucket *bucket;\n\n\tsz = 1 << HASH_TABLE_BITS;\n\n\tclone->ht = kvmalloc_array(sz, sizeof(struct hash_table_bucket), GFP_KERNEL);\n\tif (!clone->ht)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < sz; i++) {\n\t\tbucket = clone->ht + i;\n\n\t\tINIT_HLIST_HEAD(&bucket->head);\n\t\tspin_lock_init(&bucket->lock);\n\t}\n\n\treturn 0;\n}\n\nstatic void hash_table_exit(struct clone *clone)\n{\n\tkvfree(clone->ht);\n}\n\nstatic struct hash_table_bucket *get_hash_table_bucket(struct clone *clone,\n\t\t\t\t\t\t       unsigned long region_nr)\n{\n\treturn &clone->ht[hash_long(region_nr, HASH_TABLE_BITS)];\n}\n\n \nstatic struct dm_clone_region_hydration *__hash_find(struct hash_table_bucket *bucket,\n\t\t\t\t\t\t     unsigned long region_nr)\n{\n\tstruct dm_clone_region_hydration *hd;\n\n\thlist_for_each_entry(hd, &bucket->head, h) {\n\t\tif (hd->region_nr == region_nr)\n\t\t\treturn hd;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic inline void __insert_region_hydration(struct hash_table_bucket *bucket,\n\t\t\t\t\t     struct dm_clone_region_hydration *hd)\n{\n\thlist_add_head(&hd->h, &bucket->head);\n}\n\n \nstatic struct dm_clone_region_hydration *\n__find_or_insert_region_hydration(struct hash_table_bucket *bucket,\n\t\t\t\t  struct dm_clone_region_hydration *hd)\n{\n\tstruct dm_clone_region_hydration *hd2;\n\n\thd2 = __hash_find(bucket, hd->region_nr);\n\tif (hd2)\n\t\treturn hd2;\n\n\t__insert_region_hydration(bucket, hd);\n\n\treturn hd;\n}\n\n \n\n \nstatic struct dm_clone_region_hydration *alloc_hydration(struct clone *clone)\n{\n\tstruct dm_clone_region_hydration *hd;\n\n\t \n\thd = mempool_alloc(&clone->hydration_pool, GFP_NOIO);\n\thd->clone = clone;\n\n\treturn hd;\n}\n\nstatic inline void free_hydration(struct dm_clone_region_hydration *hd)\n{\n\tmempool_free(hd, &hd->clone->hydration_pool);\n}\n\n \nstatic void hydration_init(struct dm_clone_region_hydration *hd, unsigned long region_nr)\n{\n\thd->region_nr = region_nr;\n\thd->overwrite_bio = NULL;\n\tbio_list_init(&hd->deferred_bios);\n\thd->status = 0;\n\n\tINIT_LIST_HEAD(&hd->list);\n\tINIT_HLIST_NODE(&hd->h);\n}\n\n \n\n \nstatic int hydration_update_metadata(struct dm_clone_region_hydration *hd)\n{\n\tint r = 0;\n\tunsigned long flags;\n\tstruct hash_table_bucket *bucket;\n\tstruct clone *clone = hd->clone;\n\n\tif (unlikely(get_clone_mode(clone) >= CM_READ_ONLY))\n\t\tr = -EPERM;\n\n\t \n\tif (likely(!r) && hd->status == BLK_STS_OK)\n\t\tr = dm_clone_set_region_hydrated(clone->cmd, hd->region_nr);\n\n\tbucket = get_hash_table_bucket(clone, hd->region_nr);\n\n\t \n\tbucket_lock_irqsave(bucket, flags);\n\thlist_del(&hd->h);\n\tbucket_unlock_irqrestore(bucket, flags);\n\n\treturn r;\n}\n\n \nstatic void hydration_complete(struct dm_clone_region_hydration *hd)\n{\n\tint r;\n\tblk_status_t status;\n\tstruct clone *clone = hd->clone;\n\n\tr = hydration_update_metadata(hd);\n\n\tif (hd->status == BLK_STS_OK && likely(!r)) {\n\t\tif (hd->overwrite_bio)\n\t\t\tcomplete_overwrite_bio(clone, hd->overwrite_bio);\n\n\t\tissue_deferred_bios(clone, &hd->deferred_bios);\n\t} else {\n\t\tstatus = r ? BLK_STS_IOERR : hd->status;\n\n\t\tif (hd->overwrite_bio)\n\t\t\tbio_list_add(&hd->deferred_bios, hd->overwrite_bio);\n\n\t\tfail_bios(&hd->deferred_bios, status);\n\t}\n\n\tfree_hydration(hd);\n\n\tif (atomic_dec_and_test(&clone->hydrations_in_flight))\n\t\twakeup_hydration_waiters(clone);\n}\n\nstatic void hydration_kcopyd_callback(int read_err, unsigned long write_err, void *context)\n{\n\tblk_status_t status;\n\n\tstruct dm_clone_region_hydration *tmp, *hd = context;\n\tstruct clone *clone = hd->clone;\n\n\tLIST_HEAD(batched_hydrations);\n\n\tif (read_err || write_err) {\n\t\tDMERR_LIMIT(\"%s: hydration failed\", clone_device_name(clone));\n\t\tstatus = BLK_STS_IOERR;\n\t} else {\n\t\tstatus = BLK_STS_OK;\n\t}\n\tlist_splice_tail(&hd->list, &batched_hydrations);\n\n\thd->status = status;\n\thydration_complete(hd);\n\n\t \n\tlist_for_each_entry_safe(hd, tmp, &batched_hydrations, list) {\n\t\thd->status = status;\n\t\thydration_complete(hd);\n\t}\n\n\t \n\tif (test_bit(DM_CLONE_HYDRATION_ENABLED, &clone->flags) &&\n\t    !atomic_read(&clone->ios_in_flight))\n\t\twake_worker(clone);\n}\n\nstatic void hydration_copy(struct dm_clone_region_hydration *hd, unsigned int nr_regions)\n{\n\tunsigned long region_start, region_end;\n\tsector_t tail_size, region_size, total_size;\n\tstruct dm_io_region from, to;\n\tstruct clone *clone = hd->clone;\n\n\tif (WARN_ON(!nr_regions))\n\t\treturn;\n\n\tregion_size = clone->region_size;\n\tregion_start = hd->region_nr;\n\tregion_end = region_start + nr_regions - 1;\n\n\ttotal_size = region_to_sector(clone, nr_regions - 1);\n\n\tif (region_end == clone->nr_regions - 1) {\n\t\t \n\t\ttail_size = clone->ti->len & (region_size - 1);\n\t\tif (!tail_size)\n\t\t\ttail_size = region_size;\n\t} else {\n\t\ttail_size = region_size;\n\t}\n\n\ttotal_size += tail_size;\n\n\tfrom.bdev = clone->source_dev->bdev;\n\tfrom.sector = region_to_sector(clone, region_start);\n\tfrom.count = total_size;\n\n\tto.bdev = clone->dest_dev->bdev;\n\tto.sector = from.sector;\n\tto.count = from.count;\n\n\t \n\tatomic_add(nr_regions, &clone->hydrations_in_flight);\n\tdm_kcopyd_copy(clone->kcopyd_client, &from, 1, &to, 0,\n\t\t       hydration_kcopyd_callback, hd);\n}\n\nstatic void overwrite_endio(struct bio *bio)\n{\n\tstruct dm_clone_region_hydration *hd = bio->bi_private;\n\n\tbio->bi_end_io = hd->overwrite_bio_end_io;\n\thd->status = bio->bi_status;\n\n\thydration_complete(hd);\n}\n\nstatic void hydration_overwrite(struct dm_clone_region_hydration *hd, struct bio *bio)\n{\n\t \n\thd->overwrite_bio = bio;\n\thd->overwrite_bio_end_io = bio->bi_end_io;\n\n\tbio->bi_end_io = overwrite_endio;\n\tbio->bi_private = hd;\n\n\tatomic_inc(&hd->clone->hydrations_in_flight);\n\tsubmit_bio_noacct(bio);\n}\n\n \nstatic void hydrate_bio_region(struct clone *clone, struct bio *bio)\n{\n\tunsigned long region_nr;\n\tstruct hash_table_bucket *bucket;\n\tstruct dm_clone_region_hydration *hd, *hd2;\n\n\tregion_nr = bio_to_region(clone, bio);\n\tbucket = get_hash_table_bucket(clone, region_nr);\n\n\tbucket_lock_irq(bucket);\n\n\thd = __hash_find(bucket, region_nr);\n\tif (hd) {\n\t\t \n\t\tbio_list_add(&hd->deferred_bios, bio);\n\t\tbucket_unlock_irq(bucket);\n\t\treturn;\n\t}\n\n\tif (dm_clone_is_region_hydrated(clone->cmd, region_nr)) {\n\t\t \n\t\tbucket_unlock_irq(bucket);\n\t\tissue_bio(clone, bio);\n\t\treturn;\n\t}\n\n\t \n\tbucket_unlock_irq(bucket);\n\n\thd = alloc_hydration(clone);\n\thydration_init(hd, region_nr);\n\n\tbucket_lock_irq(bucket);\n\n\t \n\tif (dm_clone_is_region_hydrated(clone->cmd, region_nr)) {\n\t\tbucket_unlock_irq(bucket);\n\t\tfree_hydration(hd);\n\t\tissue_bio(clone, bio);\n\t\treturn;\n\t}\n\n\thd2 = __find_or_insert_region_hydration(bucket, hd);\n\tif (hd2 != hd) {\n\t\t \n\t\tbio_list_add(&hd2->deferred_bios, bio);\n\t\tbucket_unlock_irq(bucket);\n\t\tfree_hydration(hd);\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(get_clone_mode(clone) >= CM_READ_ONLY)) {\n\t\thlist_del(&hd->h);\n\t\tbucket_unlock_irq(bucket);\n\t\tfree_hydration(hd);\n\t\tbio_io_error(bio);\n\t\treturn;\n\t}\n\n\t \n\tif (is_overwrite_bio(clone, bio)) {\n\t\tbucket_unlock_irq(bucket);\n\t\thydration_overwrite(hd, bio);\n\t} else {\n\t\tbio_list_add(&hd->deferred_bios, bio);\n\t\tbucket_unlock_irq(bucket);\n\t\thydration_copy(hd, 1);\n\t}\n}\n\n \n\n \n\n \nstruct batch_info {\n\tstruct dm_clone_region_hydration *head;\n\tunsigned int nr_batched_regions;\n};\n\nstatic void __batch_hydration(struct batch_info *batch,\n\t\t\t      struct dm_clone_region_hydration *hd)\n{\n\tstruct clone *clone = hd->clone;\n\tunsigned int max_batch_size = READ_ONCE(clone->hydration_batch_size);\n\n\tif (batch->head) {\n\t\t \n\t\tif (batch->nr_batched_regions < max_batch_size &&\n\t\t    (batch->head->region_nr + batch->nr_batched_regions) == hd->region_nr) {\n\t\t\tlist_add_tail(&hd->list, &batch->head->list);\n\t\t\tbatch->nr_batched_regions++;\n\t\t\thd = NULL;\n\t\t}\n\n\t\t \n\t\tif (batch->nr_batched_regions >= max_batch_size || hd) {\n\t\t\thydration_copy(batch->head, batch->nr_batched_regions);\n\t\t\tbatch->head = NULL;\n\t\t\tbatch->nr_batched_regions = 0;\n\t\t}\n\t}\n\n\tif (!hd)\n\t\treturn;\n\n\t \n\tif (max_batch_size <= 1) {\n\t\thydration_copy(hd, 1);\n\t\treturn;\n\t}\n\n\t \n\tBUG_ON(!list_empty(&hd->list));\n\tbatch->head = hd;\n\tbatch->nr_batched_regions = 1;\n}\n\nstatic unsigned long __start_next_hydration(struct clone *clone,\n\t\t\t\t\t    unsigned long offset,\n\t\t\t\t\t    struct batch_info *batch)\n{\n\tstruct hash_table_bucket *bucket;\n\tstruct dm_clone_region_hydration *hd;\n\tunsigned long nr_regions = clone->nr_regions;\n\n\thd = alloc_hydration(clone);\n\n\t \n\tdo {\n\t\toffset = dm_clone_find_next_unhydrated_region(clone->cmd, offset);\n\t\tif (offset == nr_regions)\n\t\t\tbreak;\n\n\t\tbucket = get_hash_table_bucket(clone, offset);\n\t\tbucket_lock_irq(bucket);\n\n\t\tif (!dm_clone_is_region_hydrated(clone->cmd, offset) &&\n\t\t    !__hash_find(bucket, offset)) {\n\t\t\thydration_init(hd, offset);\n\t\t\t__insert_region_hydration(bucket, hd);\n\t\t\tbucket_unlock_irq(bucket);\n\n\t\t\t \n\t\t\t__batch_hydration(batch, hd);\n\n\t\t\treturn (offset + 1);\n\t\t}\n\n\t\tbucket_unlock_irq(bucket);\n\n\t} while (++offset < nr_regions);\n\n\tif (hd)\n\t\tfree_hydration(hd);\n\n\treturn offset;\n}\n\n \nstatic void do_hydration(struct clone *clone)\n{\n\tunsigned int current_volume;\n\tunsigned long offset, nr_regions = clone->nr_regions;\n\n\tstruct batch_info batch = {\n\t\t.head = NULL,\n\t\t.nr_batched_regions = 0,\n\t};\n\n\tif (unlikely(get_clone_mode(clone) >= CM_READ_ONLY))\n\t\treturn;\n\n\tif (dm_clone_is_hydration_done(clone->cmd))\n\t\treturn;\n\n\t \n\tatomic_inc(&clone->hydrations_in_flight);\n\n\t \n\tsmp_mb__after_atomic();\n\n\toffset = clone->hydration_offset;\n\twhile (likely(!test_bit(DM_CLONE_HYDRATION_SUSPENDED, &clone->flags)) &&\n\t       !atomic_read(&clone->ios_in_flight) &&\n\t       test_bit(DM_CLONE_HYDRATION_ENABLED, &clone->flags) &&\n\t       offset < nr_regions) {\n\t\tcurrent_volume = atomic_read(&clone->hydrations_in_flight);\n\t\tcurrent_volume += batch.nr_batched_regions;\n\n\t\tif (current_volume > READ_ONCE(clone->hydration_threshold))\n\t\t\tbreak;\n\n\t\toffset = __start_next_hydration(clone, offset, &batch);\n\t}\n\n\tif (batch.head)\n\t\thydration_copy(batch.head, batch.nr_batched_regions);\n\n\tif (offset >= nr_regions)\n\t\toffset = 0;\n\n\tclone->hydration_offset = offset;\n\n\tif (atomic_dec_and_test(&clone->hydrations_in_flight))\n\t\twakeup_hydration_waiters(clone);\n}\n\n \n\nstatic bool need_commit_due_to_time(struct clone *clone)\n{\n\treturn !time_in_range(jiffies, clone->last_commit_jiffies,\n\t\t\t      clone->last_commit_jiffies + COMMIT_PERIOD);\n}\n\n \nstatic int commit_metadata(struct clone *clone, bool *dest_dev_flushed)\n{\n\tint r = 0;\n\n\tif (dest_dev_flushed)\n\t\t*dest_dev_flushed = false;\n\n\tmutex_lock(&clone->commit_lock);\n\n\tif (!dm_clone_changed_this_transaction(clone->cmd))\n\t\tgoto out;\n\n\tif (unlikely(get_clone_mode(clone) >= CM_READ_ONLY)) {\n\t\tr = -EPERM;\n\t\tgoto out;\n\t}\n\n\tr = dm_clone_metadata_pre_commit(clone->cmd);\n\tif (unlikely(r)) {\n\t\t__metadata_operation_failed(clone, \"dm_clone_metadata_pre_commit\", r);\n\t\tgoto out;\n\t}\n\n\tr = blkdev_issue_flush(clone->dest_dev->bdev);\n\tif (unlikely(r)) {\n\t\t__metadata_operation_failed(clone, \"flush destination device\", r);\n\t\tgoto out;\n\t}\n\n\tif (dest_dev_flushed)\n\t\t*dest_dev_flushed = true;\n\n\tr = dm_clone_metadata_commit(clone->cmd);\n\tif (unlikely(r)) {\n\t\t__metadata_operation_failed(clone, \"dm_clone_metadata_commit\", r);\n\t\tgoto out;\n\t}\n\n\tif (dm_clone_is_hydration_done(clone->cmd))\n\t\tdm_table_event(clone->ti->table);\nout:\n\tmutex_unlock(&clone->commit_lock);\n\n\treturn r;\n}\n\nstatic void process_deferred_discards(struct clone *clone)\n{\n\tint r = -EPERM;\n\tstruct bio *bio;\n\tstruct blk_plug plug;\n\tunsigned long rs, nr_regions;\n\tstruct bio_list discards = BIO_EMPTY_LIST;\n\n\tspin_lock_irq(&clone->lock);\n\tbio_list_merge(&discards, &clone->deferred_discard_bios);\n\tbio_list_init(&clone->deferred_discard_bios);\n\tspin_unlock_irq(&clone->lock);\n\n\tif (bio_list_empty(&discards))\n\t\treturn;\n\n\tif (unlikely(get_clone_mode(clone) >= CM_READ_ONLY))\n\t\tgoto out;\n\n\t \n\tbio_list_for_each(bio, &discards) {\n\t\tbio_region_range(clone, bio, &rs, &nr_regions);\n\t\t \n\t\tr = dm_clone_cond_set_range(clone->cmd, rs, nr_regions);\n\t\tif (unlikely(r))\n\t\t\tbreak;\n\t}\nout:\n\tblk_start_plug(&plug);\n\twhile ((bio = bio_list_pop(&discards)))\n\t\tcomplete_discard_bio(clone, bio, r == 0);\n\tblk_finish_plug(&plug);\n}\n\nstatic void process_deferred_bios(struct clone *clone)\n{\n\tstruct bio_list bios = BIO_EMPTY_LIST;\n\n\tspin_lock_irq(&clone->lock);\n\tbio_list_merge(&bios, &clone->deferred_bios);\n\tbio_list_init(&clone->deferred_bios);\n\tspin_unlock_irq(&clone->lock);\n\n\tif (bio_list_empty(&bios))\n\t\treturn;\n\n\tsubmit_bios(&bios);\n}\n\nstatic void process_deferred_flush_bios(struct clone *clone)\n{\n\tstruct bio *bio;\n\tbool dest_dev_flushed;\n\tstruct bio_list bios = BIO_EMPTY_LIST;\n\tstruct bio_list bio_completions = BIO_EMPTY_LIST;\n\n\t \n\tspin_lock_irq(&clone->lock);\n\tbio_list_merge(&bios, &clone->deferred_flush_bios);\n\tbio_list_init(&clone->deferred_flush_bios);\n\n\tbio_list_merge(&bio_completions, &clone->deferred_flush_completions);\n\tbio_list_init(&clone->deferred_flush_completions);\n\tspin_unlock_irq(&clone->lock);\n\n\tif (bio_list_empty(&bios) && bio_list_empty(&bio_completions) &&\n\t    !(dm_clone_changed_this_transaction(clone->cmd) && need_commit_due_to_time(clone)))\n\t\treturn;\n\n\tif (commit_metadata(clone, &dest_dev_flushed)) {\n\t\tbio_list_merge(&bios, &bio_completions);\n\n\t\twhile ((bio = bio_list_pop(&bios)))\n\t\t\tbio_io_error(bio);\n\n\t\treturn;\n\t}\n\n\tclone->last_commit_jiffies = jiffies;\n\n\twhile ((bio = bio_list_pop(&bio_completions)))\n\t\tbio_endio(bio);\n\n\twhile ((bio = bio_list_pop(&bios))) {\n\t\tif ((bio->bi_opf & REQ_PREFLUSH) && dest_dev_flushed) {\n\t\t\t \n\t\t\tbio_endio(bio);\n\t\t} else {\n\t\t\tsubmit_bio_noacct(bio);\n\t\t}\n\t}\n}\n\nstatic void do_worker(struct work_struct *work)\n{\n\tstruct clone *clone = container_of(work, typeof(*clone), worker);\n\n\tprocess_deferred_bios(clone);\n\tprocess_deferred_discards(clone);\n\n\t \n\tprocess_deferred_flush_bios(clone);\n\n\t \n\tdo_hydration(clone);\n}\n\n \nstatic void do_waker(struct work_struct *work)\n{\n\tstruct clone *clone = container_of(to_delayed_work(work), struct clone, waker);\n\n\twake_worker(clone);\n\tqueue_delayed_work(clone->wq, &clone->waker, COMMIT_PERIOD);\n}\n\n \n\n \nstatic int clone_map(struct dm_target *ti, struct bio *bio)\n{\n\tstruct clone *clone = ti->private;\n\tunsigned long region_nr;\n\n\tatomic_inc(&clone->ios_in_flight);\n\n\tif (unlikely(get_clone_mode(clone) == CM_FAIL))\n\t\treturn DM_MAPIO_KILL;\n\n\t \n\tif (bio->bi_opf & REQ_PREFLUSH) {\n\t\tremap_and_issue(clone, bio);\n\t\treturn DM_MAPIO_SUBMITTED;\n\t}\n\n\tbio->bi_iter.bi_sector = dm_target_offset(ti, bio->bi_iter.bi_sector);\n\n\t \n\tif (bio_op(bio) == REQ_OP_DISCARD) {\n\t\tprocess_discard_bio(clone, bio);\n\t\treturn DM_MAPIO_SUBMITTED;\n\t}\n\n\t \n\tregion_nr = bio_to_region(clone, bio);\n\tif (dm_clone_is_region_hydrated(clone->cmd, region_nr)) {\n\t\tremap_and_issue(clone, bio);\n\t\treturn DM_MAPIO_SUBMITTED;\n\t} else if (bio_data_dir(bio) == READ) {\n\t\tremap_to_source(clone, bio);\n\t\treturn DM_MAPIO_REMAPPED;\n\t}\n\n\tremap_to_dest(clone, bio);\n\thydrate_bio_region(clone, bio);\n\n\treturn DM_MAPIO_SUBMITTED;\n}\n\nstatic int clone_endio(struct dm_target *ti, struct bio *bio, blk_status_t *error)\n{\n\tstruct clone *clone = ti->private;\n\n\tatomic_dec(&clone->ios_in_flight);\n\n\treturn DM_ENDIO_DONE;\n}\n\nstatic void emit_flags(struct clone *clone, char *result, unsigned int maxlen,\n\t\t       ssize_t *sz_ptr)\n{\n\tssize_t sz = *sz_ptr;\n\tunsigned int count;\n\n\tcount = !test_bit(DM_CLONE_HYDRATION_ENABLED, &clone->flags);\n\tcount += !test_bit(DM_CLONE_DISCARD_PASSDOWN, &clone->flags);\n\n\tDMEMIT(\"%u \", count);\n\n\tif (!test_bit(DM_CLONE_HYDRATION_ENABLED, &clone->flags))\n\t\tDMEMIT(\"no_hydration \");\n\n\tif (!test_bit(DM_CLONE_DISCARD_PASSDOWN, &clone->flags))\n\t\tDMEMIT(\"no_discard_passdown \");\n\n\t*sz_ptr = sz;\n}\n\nstatic void emit_core_args(struct clone *clone, char *result,\n\t\t\t   unsigned int maxlen, ssize_t *sz_ptr)\n{\n\tssize_t sz = *sz_ptr;\n\tunsigned int count = 4;\n\n\tDMEMIT(\"%u hydration_threshold %u hydration_batch_size %u \", count,\n\t       READ_ONCE(clone->hydration_threshold),\n\t       READ_ONCE(clone->hydration_batch_size));\n\n\t*sz_ptr = sz;\n}\n\n \nstatic void clone_status(struct dm_target *ti, status_type_t type,\n\t\t\t unsigned int status_flags, char *result,\n\t\t\t unsigned int maxlen)\n{\n\tint r;\n\tunsigned int i;\n\tssize_t sz = 0;\n\tdm_block_t nr_free_metadata_blocks = 0;\n\tdm_block_t nr_metadata_blocks = 0;\n\tchar buf[BDEVNAME_SIZE];\n\tstruct clone *clone = ti->private;\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\tif (get_clone_mode(clone) == CM_FAIL) {\n\t\t\tDMEMIT(\"Fail\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!(status_flags & DM_STATUS_NOFLUSH_FLAG) && !dm_suspended(ti))\n\t\t\t(void) commit_metadata(clone, NULL);\n\n\t\tr = dm_clone_get_free_metadata_block_count(clone->cmd, &nr_free_metadata_blocks);\n\n\t\tif (r) {\n\t\t\tDMERR(\"%s: dm_clone_get_free_metadata_block_count returned %d\",\n\t\t\t      clone_device_name(clone), r);\n\t\t\tgoto error;\n\t\t}\n\n\t\tr = dm_clone_get_metadata_dev_size(clone->cmd, &nr_metadata_blocks);\n\n\t\tif (r) {\n\t\t\tDMERR(\"%s: dm_clone_get_metadata_dev_size returned %d\",\n\t\t\t      clone_device_name(clone), r);\n\t\t\tgoto error;\n\t\t}\n\n\t\tDMEMIT(\"%u %llu/%llu %llu %u/%lu %u \",\n\t\t       DM_CLONE_METADATA_BLOCK_SIZE,\n\t\t       (unsigned long long)(nr_metadata_blocks - nr_free_metadata_blocks),\n\t\t       (unsigned long long)nr_metadata_blocks,\n\t\t       (unsigned long long)clone->region_size,\n\t\t       dm_clone_nr_of_hydrated_regions(clone->cmd),\n\t\t       clone->nr_regions,\n\t\t       atomic_read(&clone->hydrations_in_flight));\n\n\t\temit_flags(clone, result, maxlen, &sz);\n\t\temit_core_args(clone, result, maxlen, &sz);\n\n\t\tswitch (get_clone_mode(clone)) {\n\t\tcase CM_WRITE:\n\t\t\tDMEMIT(\"rw\");\n\t\t\tbreak;\n\t\tcase CM_READ_ONLY:\n\t\t\tDMEMIT(\"ro\");\n\t\t\tbreak;\n\t\tcase CM_FAIL:\n\t\t\tDMEMIT(\"Fail\");\n\t\t}\n\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tformat_dev_t(buf, clone->metadata_dev->bdev->bd_dev);\n\t\tDMEMIT(\"%s \", buf);\n\n\t\tformat_dev_t(buf, clone->dest_dev->bdev->bd_dev);\n\t\tDMEMIT(\"%s \", buf);\n\n\t\tformat_dev_t(buf, clone->source_dev->bdev->bd_dev);\n\t\tDMEMIT(\"%s\", buf);\n\n\t\tfor (i = 0; i < clone->nr_ctr_args; i++)\n\t\t\tDMEMIT(\" %s\", clone->ctr_args[i]);\n\t\tbreak;\n\n\tcase STATUSTYPE_IMA:\n\t\t*result = '\\0';\n\t\tbreak;\n\t}\n\n\treturn;\n\nerror:\n\tDMEMIT(\"Error\");\n}\n\nstatic sector_t get_dev_size(struct dm_dev *dev)\n{\n\treturn bdev_nr_sectors(dev->bdev);\n}\n\n \n\n \nstatic int parse_feature_args(struct dm_arg_set *as, struct clone *clone)\n{\n\tint r;\n\tunsigned int argc;\n\tconst char *arg_name;\n\tstruct dm_target *ti = clone->ti;\n\n\tconst struct dm_arg args = {\n\t\t.min = 0,\n\t\t.max = 2,\n\t\t.error = \"Invalid number of feature arguments\"\n\t};\n\n\t \n\tif (!as->argc)\n\t\treturn 0;\n\n\tr = dm_read_arg_group(&args, as, &argc, &ti->error);\n\tif (r)\n\t\treturn r;\n\n\twhile (argc) {\n\t\targ_name = dm_shift_arg(as);\n\t\targc--;\n\n\t\tif (!strcasecmp(arg_name, \"no_hydration\")) {\n\t\t\t__clear_bit(DM_CLONE_HYDRATION_ENABLED, &clone->flags);\n\t\t} else if (!strcasecmp(arg_name, \"no_discard_passdown\")) {\n\t\t\t__clear_bit(DM_CLONE_DISCARD_PASSDOWN, &clone->flags);\n\t\t} else {\n\t\t\tti->error = \"Invalid feature argument\";\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_core_args(struct dm_arg_set *as, struct clone *clone)\n{\n\tint r;\n\tunsigned int argc;\n\tunsigned int value;\n\tconst char *arg_name;\n\tstruct dm_target *ti = clone->ti;\n\n\tconst struct dm_arg args = {\n\t\t.min = 0,\n\t\t.max = 4,\n\t\t.error = \"Invalid number of core arguments\"\n\t};\n\n\t \n\tclone->hydration_batch_size = DEFAULT_HYDRATION_BATCH_SIZE;\n\tclone->hydration_threshold = DEFAULT_HYDRATION_THRESHOLD;\n\n\t \n\tif (!as->argc)\n\t\treturn 0;\n\n\tr = dm_read_arg_group(&args, as, &argc, &ti->error);\n\tif (r)\n\t\treturn r;\n\n\tif (argc & 1) {\n\t\tti->error = \"Number of core arguments must be even\";\n\t\treturn -EINVAL;\n\t}\n\n\twhile (argc) {\n\t\targ_name = dm_shift_arg(as);\n\t\targc -= 2;\n\n\t\tif (!strcasecmp(arg_name, \"hydration_threshold\")) {\n\t\t\tif (kstrtouint(dm_shift_arg(as), 10, &value)) {\n\t\t\t\tti->error = \"Invalid value for argument `hydration_threshold'\";\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tclone->hydration_threshold = value;\n\t\t} else if (!strcasecmp(arg_name, \"hydration_batch_size\")) {\n\t\t\tif (kstrtouint(dm_shift_arg(as), 10, &value)) {\n\t\t\t\tti->error = \"Invalid value for argument `hydration_batch_size'\";\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tclone->hydration_batch_size = value;\n\t\t} else {\n\t\t\tti->error = \"Invalid core argument\";\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_region_size(struct clone *clone, struct dm_arg_set *as, char **error)\n{\n\tint r;\n\tunsigned int region_size;\n\tstruct dm_arg arg;\n\n\targ.min = MIN_REGION_SIZE;\n\targ.max = MAX_REGION_SIZE;\n\targ.error = \"Invalid region size\";\n\n\tr = dm_read_arg(&arg, as, &region_size, error);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (!is_power_of_2(region_size)) {\n\t\t*error = \"Region size is not a power of 2\";\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (region_size % (bdev_logical_block_size(clone->source_dev->bdev) >> 9) ||\n\t    region_size % (bdev_logical_block_size(clone->dest_dev->bdev) >> 9)) {\n\t\t*error = \"Region size is not a multiple of device logical block size\";\n\t\treturn -EINVAL;\n\t}\n\n\tclone->region_size = region_size;\n\n\treturn 0;\n}\n\nstatic int validate_nr_regions(unsigned long n, char **error)\n{\n\t \n\tif (n > (1UL << 31)) {\n\t\t*error = \"Too many regions. Consider increasing the region size\";\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_metadata_dev(struct clone *clone, struct dm_arg_set *as, char **error)\n{\n\tint r;\n\tsector_t metadata_dev_size;\n\n\tr = dm_get_device(clone->ti, dm_shift_arg(as),\n\t\t\t  BLK_OPEN_READ | BLK_OPEN_WRITE, &clone->metadata_dev);\n\tif (r) {\n\t\t*error = \"Error opening metadata device\";\n\t\treturn r;\n\t}\n\n\tmetadata_dev_size = get_dev_size(clone->metadata_dev);\n\tif (metadata_dev_size > DM_CLONE_METADATA_MAX_SECTORS_WARNING)\n\t\tDMWARN(\"Metadata device %pg is larger than %u sectors: excess space will not be used.\",\n\t\t       clone->metadata_dev->bdev, DM_CLONE_METADATA_MAX_SECTORS);\n\n\treturn 0;\n}\n\nstatic int parse_dest_dev(struct clone *clone, struct dm_arg_set *as, char **error)\n{\n\tint r;\n\tsector_t dest_dev_size;\n\n\tr = dm_get_device(clone->ti, dm_shift_arg(as),\n\t\t\t  BLK_OPEN_READ | BLK_OPEN_WRITE, &clone->dest_dev);\n\tif (r) {\n\t\t*error = \"Error opening destination device\";\n\t\treturn r;\n\t}\n\n\tdest_dev_size = get_dev_size(clone->dest_dev);\n\tif (dest_dev_size < clone->ti->len) {\n\t\tdm_put_device(clone->ti, clone->dest_dev);\n\t\t*error = \"Device size larger than destination device\";\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_source_dev(struct clone *clone, struct dm_arg_set *as, char **error)\n{\n\tint r;\n\tsector_t source_dev_size;\n\n\tr = dm_get_device(clone->ti, dm_shift_arg(as), BLK_OPEN_READ,\n\t\t\t  &clone->source_dev);\n\tif (r) {\n\t\t*error = \"Error opening source device\";\n\t\treturn r;\n\t}\n\n\tsource_dev_size = get_dev_size(clone->source_dev);\n\tif (source_dev_size < clone->ti->len) {\n\t\tdm_put_device(clone->ti, clone->source_dev);\n\t\t*error = \"Device size larger than source device\";\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int copy_ctr_args(struct clone *clone, int argc, const char **argv, char **error)\n{\n\tunsigned int i;\n\tconst char **copy;\n\n\tcopy = kcalloc(argc, sizeof(*copy), GFP_KERNEL);\n\tif (!copy)\n\t\tgoto error;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tcopy[i] = kstrdup(argv[i], GFP_KERNEL);\n\n\t\tif (!copy[i]) {\n\t\t\twhile (i--)\n\t\t\t\tkfree(copy[i]);\n\t\t\tkfree(copy);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tclone->nr_ctr_args = argc;\n\tclone->ctr_args = copy;\n\treturn 0;\n\nerror:\n\t*error = \"Failed to allocate memory for table line\";\n\treturn -ENOMEM;\n}\n\nstatic int clone_ctr(struct dm_target *ti, unsigned int argc, char **argv)\n{\n\tint r;\n\tsector_t nr_regions;\n\tstruct clone *clone;\n\tstruct dm_arg_set as;\n\n\tif (argc < 4) {\n\t\tti->error = \"Invalid number of arguments\";\n\t\treturn -EINVAL;\n\t}\n\n\tas.argc = argc;\n\tas.argv = argv;\n\n\tclone = kzalloc(sizeof(*clone), GFP_KERNEL);\n\tif (!clone) {\n\t\tti->error = \"Failed to allocate clone structure\";\n\t\treturn -ENOMEM;\n\t}\n\n\tclone->ti = ti;\n\n\t \n\t__set_bit(DM_CLONE_HYDRATION_ENABLED, &clone->flags);\n\t__set_bit(DM_CLONE_HYDRATION_SUSPENDED, &clone->flags);\n\t__set_bit(DM_CLONE_DISCARD_PASSDOWN, &clone->flags);\n\n\tr = parse_metadata_dev(clone, &as, &ti->error);\n\tif (r)\n\t\tgoto out_with_clone;\n\n\tr = parse_dest_dev(clone, &as, &ti->error);\n\tif (r)\n\t\tgoto out_with_meta_dev;\n\n\tr = parse_source_dev(clone, &as, &ti->error);\n\tif (r)\n\t\tgoto out_with_dest_dev;\n\n\tr = parse_region_size(clone, &as, &ti->error);\n\tif (r)\n\t\tgoto out_with_source_dev;\n\n\tclone->region_shift = __ffs(clone->region_size);\n\tnr_regions = dm_sector_div_up(ti->len, clone->region_size);\n\n\t \n\tif (nr_regions != (unsigned long)nr_regions) {\n\t\tti->error = \"Too many regions. Consider increasing the region size\";\n\t\tr = -EOVERFLOW;\n\t\tgoto out_with_source_dev;\n\t}\n\n\tclone->nr_regions = nr_regions;\n\n\tr = validate_nr_regions(clone->nr_regions, &ti->error);\n\tif (r)\n\t\tgoto out_with_source_dev;\n\n\tr = dm_set_target_max_io_len(ti, clone->region_size);\n\tif (r) {\n\t\tti->error = \"Failed to set max io len\";\n\t\tgoto out_with_source_dev;\n\t}\n\n\tr = parse_feature_args(&as, clone);\n\tif (r)\n\t\tgoto out_with_source_dev;\n\n\tr = parse_core_args(&as, clone);\n\tif (r)\n\t\tgoto out_with_source_dev;\n\n\t \n\tclone->cmd = dm_clone_metadata_open(clone->metadata_dev->bdev, ti->len,\n\t\t\t\t\t    clone->region_size);\n\tif (IS_ERR(clone->cmd)) {\n\t\tti->error = \"Failed to load metadata\";\n\t\tr = PTR_ERR(clone->cmd);\n\t\tgoto out_with_source_dev;\n\t}\n\n\t__set_clone_mode(clone, CM_WRITE);\n\n\tif (get_clone_mode(clone) != CM_WRITE) {\n\t\tti->error = \"Unable to get write access to metadata, please check/repair metadata\";\n\t\tr = -EPERM;\n\t\tgoto out_with_metadata;\n\t}\n\n\tclone->last_commit_jiffies = jiffies;\n\n\t \n\tr = hash_table_init(clone);\n\tif (r) {\n\t\tti->error = \"Failed to allocate hydration hash table\";\n\t\tgoto out_with_metadata;\n\t}\n\n\tatomic_set(&clone->ios_in_flight, 0);\n\tinit_waitqueue_head(&clone->hydration_stopped);\n\tspin_lock_init(&clone->lock);\n\tbio_list_init(&clone->deferred_bios);\n\tbio_list_init(&clone->deferred_discard_bios);\n\tbio_list_init(&clone->deferred_flush_bios);\n\tbio_list_init(&clone->deferred_flush_completions);\n\tclone->hydration_offset = 0;\n\tatomic_set(&clone->hydrations_in_flight, 0);\n\n\tclone->wq = alloc_workqueue(\"dm-\" DM_MSG_PREFIX, WQ_MEM_RECLAIM, 0);\n\tif (!clone->wq) {\n\t\tti->error = \"Failed to allocate workqueue\";\n\t\tr = -ENOMEM;\n\t\tgoto out_with_ht;\n\t}\n\n\tINIT_WORK(&clone->worker, do_worker);\n\tINIT_DELAYED_WORK(&clone->waker, do_waker);\n\n\tclone->kcopyd_client = dm_kcopyd_client_create(&dm_kcopyd_throttle);\n\tif (IS_ERR(clone->kcopyd_client)) {\n\t\tr = PTR_ERR(clone->kcopyd_client);\n\t\tgoto out_with_wq;\n\t}\n\n\tr = mempool_init_slab_pool(&clone->hydration_pool, MIN_HYDRATIONS,\n\t\t\t\t   _hydration_cache);\n\tif (r) {\n\t\tti->error = \"Failed to create dm_clone_region_hydration memory pool\";\n\t\tgoto out_with_kcopyd;\n\t}\n\n\t \n\tr = copy_ctr_args(clone, argc - 3, (const char **)argv + 3, &ti->error);\n\tif (r)\n\t\tgoto out_with_mempool;\n\n\tmutex_init(&clone->commit_lock);\n\n\t \n\tti->num_flush_bios = 1;\n\tti->flush_supported = true;\n\n\t \n\tti->discards_supported = true;\n\tti->num_discard_bios = 1;\n\n\tti->private = clone;\n\n\treturn 0;\n\nout_with_mempool:\n\tmempool_exit(&clone->hydration_pool);\nout_with_kcopyd:\n\tdm_kcopyd_client_destroy(clone->kcopyd_client);\nout_with_wq:\n\tdestroy_workqueue(clone->wq);\nout_with_ht:\n\thash_table_exit(clone);\nout_with_metadata:\n\tdm_clone_metadata_close(clone->cmd);\nout_with_source_dev:\n\tdm_put_device(ti, clone->source_dev);\nout_with_dest_dev:\n\tdm_put_device(ti, clone->dest_dev);\nout_with_meta_dev:\n\tdm_put_device(ti, clone->metadata_dev);\nout_with_clone:\n\tkfree(clone);\n\n\treturn r;\n}\n\nstatic void clone_dtr(struct dm_target *ti)\n{\n\tunsigned int i;\n\tstruct clone *clone = ti->private;\n\n\tmutex_destroy(&clone->commit_lock);\n\n\tfor (i = 0; i < clone->nr_ctr_args; i++)\n\t\tkfree(clone->ctr_args[i]);\n\tkfree(clone->ctr_args);\n\n\tmempool_exit(&clone->hydration_pool);\n\tdm_kcopyd_client_destroy(clone->kcopyd_client);\n\tcancel_delayed_work_sync(&clone->waker);\n\tdestroy_workqueue(clone->wq);\n\thash_table_exit(clone);\n\tdm_clone_metadata_close(clone->cmd);\n\tdm_put_device(ti, clone->source_dev);\n\tdm_put_device(ti, clone->dest_dev);\n\tdm_put_device(ti, clone->metadata_dev);\n\n\tkfree(clone);\n}\n\n \n\nstatic void clone_postsuspend(struct dm_target *ti)\n{\n\tstruct clone *clone = ti->private;\n\n\t \n\tcancel_delayed_work_sync(&clone->waker);\n\n\tset_bit(DM_CLONE_HYDRATION_SUSPENDED, &clone->flags);\n\n\t \n\tsmp_mb__after_atomic();\n\n\twait_event(clone->hydration_stopped, !atomic_read(&clone->hydrations_in_flight));\n\tflush_workqueue(clone->wq);\n\n\t(void) commit_metadata(clone, NULL);\n}\n\nstatic void clone_resume(struct dm_target *ti)\n{\n\tstruct clone *clone = ti->private;\n\n\tclear_bit(DM_CLONE_HYDRATION_SUSPENDED, &clone->flags);\n\tdo_waker(&clone->waker.work);\n}\n\n \nstatic void disable_passdown_if_not_supported(struct clone *clone)\n{\n\tstruct block_device *dest_dev = clone->dest_dev->bdev;\n\tstruct queue_limits *dest_limits = &bdev_get_queue(dest_dev)->limits;\n\tconst char *reason = NULL;\n\n\tif (!test_bit(DM_CLONE_DISCARD_PASSDOWN, &clone->flags))\n\t\treturn;\n\n\tif (!bdev_max_discard_sectors(dest_dev))\n\t\treason = \"discard unsupported\";\n\telse if (dest_limits->max_discard_sectors < clone->region_size)\n\t\treason = \"max discard sectors smaller than a region\";\n\n\tif (reason) {\n\t\tDMWARN(\"Destination device (%pg) %s: Disabling discard passdown.\",\n\t\t       dest_dev, reason);\n\t\tclear_bit(DM_CLONE_DISCARD_PASSDOWN, &clone->flags);\n\t}\n}\n\nstatic void set_discard_limits(struct clone *clone, struct queue_limits *limits)\n{\n\tstruct block_device *dest_bdev = clone->dest_dev->bdev;\n\tstruct queue_limits *dest_limits = &bdev_get_queue(dest_bdev)->limits;\n\n\tif (!test_bit(DM_CLONE_DISCARD_PASSDOWN, &clone->flags)) {\n\t\t \n\t\tlimits->discard_granularity = clone->region_size << SECTOR_SHIFT;\n\t\tlimits->max_discard_sectors = round_down(UINT_MAX >> SECTOR_SHIFT, clone->region_size);\n\t\treturn;\n\t}\n\n\t \n\tlimits->max_discard_sectors = dest_limits->max_discard_sectors;\n\tlimits->max_hw_discard_sectors = dest_limits->max_hw_discard_sectors;\n\tlimits->discard_granularity = dest_limits->discard_granularity;\n\tlimits->discard_alignment = dest_limits->discard_alignment;\n\tlimits->discard_misaligned = dest_limits->discard_misaligned;\n\tlimits->max_discard_segments = dest_limits->max_discard_segments;\n}\n\nstatic void clone_io_hints(struct dm_target *ti, struct queue_limits *limits)\n{\n\tstruct clone *clone = ti->private;\n\tu64 io_opt_sectors = limits->io_opt >> SECTOR_SHIFT;\n\n\t \n\tif (io_opt_sectors < clone->region_size ||\n\t    do_div(io_opt_sectors, clone->region_size)) {\n\t\tblk_limits_io_min(limits, clone->region_size << SECTOR_SHIFT);\n\t\tblk_limits_io_opt(limits, clone->region_size << SECTOR_SHIFT);\n\t}\n\n\tdisable_passdown_if_not_supported(clone);\n\tset_discard_limits(clone, limits);\n}\n\nstatic int clone_iterate_devices(struct dm_target *ti,\n\t\t\t\t iterate_devices_callout_fn fn, void *data)\n{\n\tint ret;\n\tstruct clone *clone = ti->private;\n\tstruct dm_dev *dest_dev = clone->dest_dev;\n\tstruct dm_dev *source_dev = clone->source_dev;\n\n\tret = fn(ti, source_dev, 0, ti->len, data);\n\tif (!ret)\n\t\tret = fn(ti, dest_dev, 0, ti->len, data);\n\treturn ret;\n}\n\n \nstatic void set_hydration_threshold(struct clone *clone, unsigned int nr_regions)\n{\n\tWRITE_ONCE(clone->hydration_threshold, nr_regions);\n\n\t \n\twake_worker(clone);\n}\n\nstatic void set_hydration_batch_size(struct clone *clone, unsigned int nr_regions)\n{\n\tWRITE_ONCE(clone->hydration_batch_size, nr_regions);\n}\n\nstatic void enable_hydration(struct clone *clone)\n{\n\tif (!test_and_set_bit(DM_CLONE_HYDRATION_ENABLED, &clone->flags))\n\t\twake_worker(clone);\n}\n\nstatic void disable_hydration(struct clone *clone)\n{\n\tclear_bit(DM_CLONE_HYDRATION_ENABLED, &clone->flags);\n}\n\nstatic int clone_message(struct dm_target *ti, unsigned int argc, char **argv,\n\t\t\t char *result, unsigned int maxlen)\n{\n\tstruct clone *clone = ti->private;\n\tunsigned int value;\n\n\tif (!argc)\n\t\treturn -EINVAL;\n\n\tif (!strcasecmp(argv[0], \"enable_hydration\")) {\n\t\tenable_hydration(clone);\n\t\treturn 0;\n\t}\n\n\tif (!strcasecmp(argv[0], \"disable_hydration\")) {\n\t\tdisable_hydration(clone);\n\t\treturn 0;\n\t}\n\n\tif (argc != 2)\n\t\treturn -EINVAL;\n\n\tif (!strcasecmp(argv[0], \"hydration_threshold\")) {\n\t\tif (kstrtouint(argv[1], 10, &value))\n\t\t\treturn -EINVAL;\n\n\t\tset_hydration_threshold(clone, value);\n\n\t\treturn 0;\n\t}\n\n\tif (!strcasecmp(argv[0], \"hydration_batch_size\")) {\n\t\tif (kstrtouint(argv[1], 10, &value))\n\t\t\treturn -EINVAL;\n\n\t\tset_hydration_batch_size(clone, value);\n\n\t\treturn 0;\n\t}\n\n\tDMERR(\"%s: Unsupported message `%s'\", clone_device_name(clone), argv[0]);\n\treturn -EINVAL;\n}\n\nstatic struct target_type clone_target = {\n\t.name = \"clone\",\n\t.version = {1, 0, 0},\n\t.module = THIS_MODULE,\n\t.ctr = clone_ctr,\n\t.dtr =  clone_dtr,\n\t.map = clone_map,\n\t.end_io = clone_endio,\n\t.postsuspend = clone_postsuspend,\n\t.resume = clone_resume,\n\t.status = clone_status,\n\t.message = clone_message,\n\t.io_hints = clone_io_hints,\n\t.iterate_devices = clone_iterate_devices,\n};\n\n \n\n \nstatic int __init dm_clone_init(void)\n{\n\tint r;\n\n\t_hydration_cache = KMEM_CACHE(dm_clone_region_hydration, 0);\n\tif (!_hydration_cache)\n\t\treturn -ENOMEM;\n\n\tr = dm_register_target(&clone_target);\n\tif (r < 0) {\n\t\tkmem_cache_destroy(_hydration_cache);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit dm_clone_exit(void)\n{\n\tdm_unregister_target(&clone_target);\n\n\tkmem_cache_destroy(_hydration_cache);\n\t_hydration_cache = NULL;\n}\n\n \nmodule_init(dm_clone_init);\nmodule_exit(dm_clone_exit);\n\nMODULE_DESCRIPTION(DM_NAME \" clone target\");\nMODULE_AUTHOR(\"Nikos Tsironis <ntsironis@arrikto.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}