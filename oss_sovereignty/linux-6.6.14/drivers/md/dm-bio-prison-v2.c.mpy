{
  "module_name": "dm-bio-prison-v2.c",
  "hash_id": "6073add538541dc3091f45bf44948940b3cedd3b765cddca452f1ca7f64d8158",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-bio-prison-v2.c",
  "human_readable_source": "\n \n\n#include \"dm.h\"\n#include \"dm-bio-prison-v2.h\"\n\n#include <linux/spinlock.h>\n#include <linux/mempool.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n\n \n\n#define MIN_CELLS 1024\n\nstruct dm_bio_prison_v2 {\n\tstruct workqueue_struct *wq;\n\n\tspinlock_t lock;\n\tstruct rb_root cells;\n\tmempool_t cell_pool;\n};\n\nstatic struct kmem_cache *_cell_cache;\n\n \n\n \nstruct dm_bio_prison_v2 *dm_bio_prison_create_v2(struct workqueue_struct *wq)\n{\n\tstruct dm_bio_prison_v2 *prison = kzalloc(sizeof(*prison), GFP_KERNEL);\n\tint ret;\n\n\tif (!prison)\n\t\treturn NULL;\n\n\tprison->wq = wq;\n\tspin_lock_init(&prison->lock);\n\n\tret = mempool_init_slab_pool(&prison->cell_pool, MIN_CELLS, _cell_cache);\n\tif (ret) {\n\t\tkfree(prison);\n\t\treturn NULL;\n\t}\n\n\tprison->cells = RB_ROOT;\n\n\treturn prison;\n}\nEXPORT_SYMBOL_GPL(dm_bio_prison_create_v2);\n\nvoid dm_bio_prison_destroy_v2(struct dm_bio_prison_v2 *prison)\n{\n\tmempool_exit(&prison->cell_pool);\n\tkfree(prison);\n}\nEXPORT_SYMBOL_GPL(dm_bio_prison_destroy_v2);\n\nstruct dm_bio_prison_cell_v2 *dm_bio_prison_alloc_cell_v2(struct dm_bio_prison_v2 *prison, gfp_t gfp)\n{\n\treturn mempool_alloc(&prison->cell_pool, gfp);\n}\nEXPORT_SYMBOL_GPL(dm_bio_prison_alloc_cell_v2);\n\nvoid dm_bio_prison_free_cell_v2(struct dm_bio_prison_v2 *prison,\n\t\t\t\tstruct dm_bio_prison_cell_v2 *cell)\n{\n\tmempool_free(cell, &prison->cell_pool);\n}\nEXPORT_SYMBOL_GPL(dm_bio_prison_free_cell_v2);\n\nstatic void __setup_new_cell(struct dm_cell_key_v2 *key,\n\t\t\t     struct dm_bio_prison_cell_v2 *cell)\n{\n\tmemset(cell, 0, sizeof(*cell));\n\tmemcpy(&cell->key, key, sizeof(cell->key));\n\tbio_list_init(&cell->bios);\n}\n\nstatic int cmp_keys(struct dm_cell_key_v2 *lhs,\n\t\t    struct dm_cell_key_v2 *rhs)\n{\n\tif (lhs->virtual < rhs->virtual)\n\t\treturn -1;\n\n\tif (lhs->virtual > rhs->virtual)\n\t\treturn 1;\n\n\tif (lhs->dev < rhs->dev)\n\t\treturn -1;\n\n\tif (lhs->dev > rhs->dev)\n\t\treturn 1;\n\n\tif (lhs->block_end <= rhs->block_begin)\n\t\treturn -1;\n\n\tif (lhs->block_begin >= rhs->block_end)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic bool __find_or_insert(struct dm_bio_prison_v2 *prison,\n\t\t\t     struct dm_cell_key_v2 *key,\n\t\t\t     struct dm_bio_prison_cell_v2 *cell_prealloc,\n\t\t\t     struct dm_bio_prison_cell_v2 **result)\n{\n\tint r;\n\tstruct rb_node **new = &prison->cells.rb_node, *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct dm_bio_prison_cell_v2 *cell =\n\t\t\trb_entry(*new, struct dm_bio_prison_cell_v2, node);\n\n\t\tr = cmp_keys(key, &cell->key);\n\n\t\tparent = *new;\n\t\tif (r < 0)\n\t\t\tnew = &((*new)->rb_left);\n\n\t\telse if (r > 0)\n\t\t\tnew = &((*new)->rb_right);\n\n\t\telse {\n\t\t\t*result = cell;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t__setup_new_cell(key, cell_prealloc);\n\t*result = cell_prealloc;\n\trb_link_node(&cell_prealloc->node, parent, new);\n\trb_insert_color(&cell_prealloc->node, &prison->cells);\n\n\treturn false;\n}\n\nstatic bool __get(struct dm_bio_prison_v2 *prison,\n\t\t  struct dm_cell_key_v2 *key,\n\t\t  unsigned int lock_level,\n\t\t  struct bio *inmate,\n\t\t  struct dm_bio_prison_cell_v2 *cell_prealloc,\n\t\t  struct dm_bio_prison_cell_v2 **cell)\n{\n\tif (__find_or_insert(prison, key, cell_prealloc, cell)) {\n\t\tif ((*cell)->exclusive_lock) {\n\t\t\tif (lock_level <= (*cell)->exclusive_level) {\n\t\t\t\tbio_list_add(&(*cell)->bios, inmate);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t(*cell)->shared_count++;\n\n\t} else\n\t\t(*cell)->shared_count = 1;\n\n\treturn true;\n}\n\nbool dm_cell_get_v2(struct dm_bio_prison_v2 *prison,\n\t\t    struct dm_cell_key_v2 *key,\n\t\t    unsigned int lock_level,\n\t\t    struct bio *inmate,\n\t\t    struct dm_bio_prison_cell_v2 *cell_prealloc,\n\t\t    struct dm_bio_prison_cell_v2 **cell_result)\n{\n\tint r;\n\n\tspin_lock_irq(&prison->lock);\n\tr = __get(prison, key, lock_level, inmate, cell_prealloc, cell_result);\n\tspin_unlock_irq(&prison->lock);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_cell_get_v2);\n\nstatic bool __put(struct dm_bio_prison_v2 *prison,\n\t\t  struct dm_bio_prison_cell_v2 *cell)\n{\n\tBUG_ON(!cell->shared_count);\n\tcell->shared_count--;\n\n\t \n\tif (!cell->shared_count) {\n\t\tif (cell->exclusive_lock) {\n\t\t\tif (cell->quiesce_continuation) {\n\t\t\t\tqueue_work(prison->wq, cell->quiesce_continuation);\n\t\t\t\tcell->quiesce_continuation = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\trb_erase(&cell->node, &prison->cells);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool dm_cell_put_v2(struct dm_bio_prison_v2 *prison,\n\t\t    struct dm_bio_prison_cell_v2 *cell)\n{\n\tbool r;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prison->lock, flags);\n\tr = __put(prison, cell);\n\tspin_unlock_irqrestore(&prison->lock, flags);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_cell_put_v2);\n\nstatic int __lock(struct dm_bio_prison_v2 *prison,\n\t\t  struct dm_cell_key_v2 *key,\n\t\t  unsigned int lock_level,\n\t\t  struct dm_bio_prison_cell_v2 *cell_prealloc,\n\t\t  struct dm_bio_prison_cell_v2 **cell_result)\n{\n\tstruct dm_bio_prison_cell_v2 *cell;\n\n\tif (__find_or_insert(prison, key, cell_prealloc, &cell)) {\n\t\tif (cell->exclusive_lock)\n\t\t\treturn -EBUSY;\n\n\t\tcell->exclusive_lock = true;\n\t\tcell->exclusive_level = lock_level;\n\t\t*cell_result = cell;\n\n\t\t \n\t\t\n\t\treturn cell->shared_count > 0;\n\n\t} else {\n\t\tcell = cell_prealloc;\n\t\tcell->shared_count = 0;\n\t\tcell->exclusive_lock = true;\n\t\tcell->exclusive_level = lock_level;\n\t\t*cell_result = cell;\n\t}\n\n\treturn 0;\n}\n\nint dm_cell_lock_v2(struct dm_bio_prison_v2 *prison,\n\t\t    struct dm_cell_key_v2 *key,\n\t\t    unsigned int lock_level,\n\t\t    struct dm_bio_prison_cell_v2 *cell_prealloc,\n\t\t    struct dm_bio_prison_cell_v2 **cell_result)\n{\n\tint r;\n\n\tspin_lock_irq(&prison->lock);\n\tr = __lock(prison, key, lock_level, cell_prealloc, cell_result);\n\tspin_unlock_irq(&prison->lock);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_cell_lock_v2);\n\nstatic void __quiesce(struct dm_bio_prison_v2 *prison,\n\t\t      struct dm_bio_prison_cell_v2 *cell,\n\t\t      struct work_struct *continuation)\n{\n\tif (!cell->shared_count)\n\t\tqueue_work(prison->wq, continuation);\n\telse\n\t\tcell->quiesce_continuation = continuation;\n}\n\nvoid dm_cell_quiesce_v2(struct dm_bio_prison_v2 *prison,\n\t\t\tstruct dm_bio_prison_cell_v2 *cell,\n\t\t\tstruct work_struct *continuation)\n{\n\tspin_lock_irq(&prison->lock);\n\t__quiesce(prison, cell, continuation);\n\tspin_unlock_irq(&prison->lock);\n}\nEXPORT_SYMBOL_GPL(dm_cell_quiesce_v2);\n\nstatic int __promote(struct dm_bio_prison_v2 *prison,\n\t\t     struct dm_bio_prison_cell_v2 *cell,\n\t\t     unsigned int new_lock_level)\n{\n\tif (!cell->exclusive_lock)\n\t\treturn -EINVAL;\n\n\tcell->exclusive_level = new_lock_level;\n\treturn cell->shared_count > 0;\n}\n\nint dm_cell_lock_promote_v2(struct dm_bio_prison_v2 *prison,\n\t\t\t    struct dm_bio_prison_cell_v2 *cell,\n\t\t\t    unsigned int new_lock_level)\n{\n\tint r;\n\n\tspin_lock_irq(&prison->lock);\n\tr = __promote(prison, cell, new_lock_level);\n\tspin_unlock_irq(&prison->lock);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_cell_lock_promote_v2);\n\nstatic bool __unlock(struct dm_bio_prison_v2 *prison,\n\t\t     struct dm_bio_prison_cell_v2 *cell,\n\t\t     struct bio_list *bios)\n{\n\tBUG_ON(!cell->exclusive_lock);\n\n\tbio_list_merge(bios, &cell->bios);\n\tbio_list_init(&cell->bios);\n\n\tif (cell->shared_count) {\n\t\tcell->exclusive_lock = false;\n\t\treturn false;\n\t}\n\n\trb_erase(&cell->node, &prison->cells);\n\treturn true;\n}\n\nbool dm_cell_unlock_v2(struct dm_bio_prison_v2 *prison,\n\t\t       struct dm_bio_prison_cell_v2 *cell,\n\t\t       struct bio_list *bios)\n{\n\tbool r;\n\n\tspin_lock_irq(&prison->lock);\n\tr = __unlock(prison, cell, bios);\n\tspin_unlock_irq(&prison->lock);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_cell_unlock_v2);\n\n \n\nint __init dm_bio_prison_init_v2(void)\n{\n\t_cell_cache = KMEM_CACHE(dm_bio_prison_cell_v2, 0);\n\tif (!_cell_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid dm_bio_prison_exit_v2(void)\n{\n\tkmem_cache_destroy(_cell_cache);\n\t_cell_cache = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}