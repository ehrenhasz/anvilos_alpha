{
  "module_name": "dm-ps-io-affinity.c",
  "hash_id": "857ffbbf6fc34dcf2e4c0a6a9f3a627417c02f644da5152f5ede0d6882808618",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-ps-io-affinity.c",
  "human_readable_source": "\n \n#include \"dm-path-selector.h\"\n\n#include <linux/device-mapper.h>\n#include <linux/module.h>\n\n#define DM_MSG_PREFIX \"multipath io-affinity\"\n\nstruct path_info {\n\tstruct dm_path *path;\n\tcpumask_var_t cpumask;\n\trefcount_t refcount;\n\tbool failed;\n};\n\nstruct selector {\n\tstruct path_info **path_map;\n\tcpumask_var_t path_mask;\n\tatomic_t map_misses;\n};\n\nstatic void ioa_free_path(struct selector *s, unsigned int cpu)\n{\n\tstruct path_info *pi = s->path_map[cpu];\n\n\tif (!pi)\n\t\treturn;\n\n\tif (refcount_dec_and_test(&pi->refcount)) {\n\t\tcpumask_clear_cpu(cpu, s->path_mask);\n\t\tfree_cpumask_var(pi->cpumask);\n\t\tkfree(pi);\n\n\t\ts->path_map[cpu] = NULL;\n\t}\n}\n\nstatic int ioa_add_path(struct path_selector *ps, struct dm_path *path,\n\t\t\tint argc, char **argv, char **error)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = NULL;\n\tunsigned int cpu;\n\tint ret;\n\n\tif (argc != 1) {\n\t\t*error = \"io-affinity ps: invalid number of arguments\";\n\t\treturn -EINVAL;\n\t}\n\n\tpi = kzalloc(sizeof(*pi), GFP_KERNEL);\n\tif (!pi) {\n\t\t*error = \"io-affinity ps: Error allocating path context\";\n\t\treturn -ENOMEM;\n\t}\n\n\tpi->path = path;\n\tpath->pscontext = pi;\n\trefcount_set(&pi->refcount, 1);\n\n\tif (!zalloc_cpumask_var(&pi->cpumask, GFP_KERNEL)) {\n\t\t*error = \"io-affinity ps: Error allocating cpumask context\";\n\t\tret = -ENOMEM;\n\t\tgoto free_pi;\n\t}\n\n\tret = cpumask_parse(argv[0], pi->cpumask);\n\tif (ret) {\n\t\t*error = \"io-affinity ps: invalid cpumask\";\n\t\tret = -EINVAL;\n\t\tgoto free_mask;\n\t}\n\n\tfor_each_cpu(cpu, pi->cpumask) {\n\t\tif (cpu >= nr_cpu_ids) {\n\t\t\tDMWARN_LIMIT(\"Ignoring mapping for CPU %u. Max CPU is %u\",\n\t\t\t\t     cpu, nr_cpu_ids);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (s->path_map[cpu]) {\n\t\t\tDMWARN(\"CPU mapping for %u exists. Ignoring.\", cpu);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcpumask_set_cpu(cpu, s->path_mask);\n\t\ts->path_map[cpu] = pi;\n\t\trefcount_inc(&pi->refcount);\n\t}\n\n\tif (refcount_dec_and_test(&pi->refcount)) {\n\t\t*error = \"io-affinity ps: No new/valid CPU mapping found\";\n\t\tret = -EINVAL;\n\t\tgoto free_mask;\n\t}\n\n\treturn 0;\n\nfree_mask:\n\tfree_cpumask_var(pi->cpumask);\nfree_pi:\n\tkfree(pi);\n\treturn ret;\n}\n\nstatic int ioa_create(struct path_selector *ps, unsigned int argc, char **argv)\n{\n\tstruct selector *s;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ts->path_map = kzalloc(nr_cpu_ids * sizeof(struct path_info *),\n\t\t\t      GFP_KERNEL);\n\tif (!s->path_map)\n\t\tgoto free_selector;\n\n\tif (!zalloc_cpumask_var(&s->path_mask, GFP_KERNEL))\n\t\tgoto free_map;\n\n\tatomic_set(&s->map_misses, 0);\n\tps->context = s;\n\treturn 0;\n\nfree_map:\n\tkfree(s->path_map);\nfree_selector:\n\tkfree(s);\n\treturn -ENOMEM;\n}\n\nstatic void ioa_destroy(struct path_selector *ps)\n{\n\tstruct selector *s = ps->context;\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, s->path_mask)\n\t\tioa_free_path(s, cpu);\n\n\tfree_cpumask_var(s->path_mask);\n\tkfree(s->path_map);\n\tkfree(s);\n\n\tps->context = NULL;\n}\n\nstatic int ioa_status(struct path_selector *ps, struct dm_path *path,\n\t\t      status_type_t type, char *result, unsigned int maxlen)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi;\n\tint sz = 0;\n\n\tif (!path) {\n\t\tDMEMIT(\"0 \");\n\t\treturn sz;\n\t}\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\tDMEMIT(\"%d \", atomic_read(&s->map_misses));\n\t\tbreak;\n\tcase STATUSTYPE_TABLE:\n\t\tpi = path->pscontext;\n\t\tDMEMIT(\"%*pb \", cpumask_pr_args(pi->cpumask));\n\t\tbreak;\n\tcase STATUSTYPE_IMA:\n\t\t*result = '\\0';\n\t\tbreak;\n\t}\n\n\treturn sz;\n}\n\nstatic void ioa_fail_path(struct path_selector *ps, struct dm_path *p)\n{\n\tstruct path_info *pi = p->pscontext;\n\n\tpi->failed = true;\n}\n\nstatic int ioa_reinstate_path(struct path_selector *ps, struct dm_path *p)\n{\n\tstruct path_info *pi = p->pscontext;\n\n\tpi->failed = false;\n\treturn 0;\n}\n\nstatic struct dm_path *ioa_select_path(struct path_selector *ps,\n\t\t\t\t       size_t nr_bytes)\n{\n\tunsigned int cpu, node;\n\tstruct selector *s = ps->context;\n\tconst struct cpumask *cpumask;\n\tstruct path_info *pi;\n\tint i;\n\n\tcpu = get_cpu();\n\n\tpi = s->path_map[cpu];\n\tif (pi && !pi->failed)\n\t\tgoto done;\n\n\t \n\tif (!pi)\n\t\tatomic_inc(&s->map_misses);\n\n\tnode = cpu_to_node(cpu);\n\tcpumask = cpumask_of_node(node);\n\tfor_each_cpu(i, cpumask) {\n\t\tpi = s->path_map[i];\n\t\tif (pi && !pi->failed)\n\t\t\tgoto done;\n\t}\n\n\tfor_each_cpu(i, s->path_mask) {\n\t\tpi = s->path_map[i];\n\t\tif (pi && !pi->failed)\n\t\t\tgoto done;\n\t}\n\tpi = NULL;\n\ndone:\n\tput_cpu();\n\treturn pi ? pi->path : NULL;\n}\n\nstatic struct path_selector_type ioa_ps = {\n\t.name\t\t= \"io-affinity\",\n\t.module\t\t= THIS_MODULE,\n\t.table_args\t= 1,\n\t.info_args\t= 1,\n\t.create\t\t= ioa_create,\n\t.destroy\t= ioa_destroy,\n\t.status\t\t= ioa_status,\n\t.add_path\t= ioa_add_path,\n\t.fail_path\t= ioa_fail_path,\n\t.reinstate_path\t= ioa_reinstate_path,\n\t.select_path\t= ioa_select_path,\n};\n\nstatic int __init dm_ioa_init(void)\n{\n\tint ret = dm_register_path_selector(&ioa_ps);\n\n\tif (ret < 0)\n\t\tDMERR(\"register failed %d\", ret);\n\treturn ret;\n}\n\nstatic void __exit dm_ioa_exit(void)\n{\n\tint ret = dm_unregister_path_selector(&ioa_ps);\n\n\tif (ret < 0)\n\t\tDMERR(\"unregister failed %d\", ret);\n}\n\nmodule_init(dm_ioa_init);\nmodule_exit(dm_ioa_exit);\n\nMODULE_DESCRIPTION(DM_NAME \" multipath path selector that selects paths based on the CPU IO is being executed on\");\nMODULE_AUTHOR(\"Mike Christie <michael.christie@oracle.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}