{
  "module_name": "dm-ima.c",
  "hash_id": "cfbecc52f9ced1c0a5a856d3eb7ecf8a3ef2f2c9e07e208d9e59f364bc211e12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-ima.c",
  "human_readable_source": "\n \n\n#include \"dm-core.h\"\n#include \"dm-ima.h\"\n\n#include <linux/ima.h>\n#include <linux/sched/mm.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <crypto/hash_info.h>\n\n#define DM_MSG_PREFIX \"ima\"\n\n \nstatic void fix_separator_chars(char **buf)\n{\n\tint l = strlen(*buf);\n\tint i, j, sp = 0;\n\n\tfor (i = 0; i < l; i++)\n\t\tif ((*buf)[i] == '\\\\' || (*buf)[i] == ';' || (*buf)[i] == '=' || (*buf)[i] == ',')\n\t\t\tsp++;\n\n\tif (!sp)\n\t\treturn;\n\n\tfor (i = l-1, j = i+sp; i >= 0; i--) {\n\t\t(*buf)[j--] = (*buf)[i];\n\t\tif ((*buf)[i] == '\\\\' || (*buf)[i] == ';' || (*buf)[i] == '=' || (*buf)[i] == ',')\n\t\t\t(*buf)[j--] = '\\\\';\n\t}\n}\n\n \nstatic void *dm_ima_alloc(size_t len, gfp_t flags, bool noio)\n{\n\tunsigned int noio_flag;\n\tvoid *ptr;\n\n\tif (noio)\n\t\tnoio_flag = memalloc_noio_save();\n\n\tptr = kzalloc(len, flags);\n\n\tif (noio)\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}\n\n \nstatic int dm_ima_alloc_and_copy_name_uuid(struct mapped_device *md, char **dev_name,\n\t\t\t\t\t   char **dev_uuid, bool noio)\n{\n\tint r;\n\t*dev_name = dm_ima_alloc(DM_NAME_LEN*2, GFP_KERNEL, noio);\n\tif (!(*dev_name)) {\n\t\tr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t*dev_uuid = dm_ima_alloc(DM_UUID_LEN*2, GFP_KERNEL, noio);\n\tif (!(*dev_uuid)) {\n\t\tr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tr = dm_copy_name_and_uuid(md, *dev_name, *dev_uuid);\n\tif (r)\n\t\tgoto error;\n\n\tfix_separator_chars(dev_name);\n\tfix_separator_chars(dev_uuid);\n\n\treturn 0;\nerror:\n\tkfree(*dev_name);\n\tkfree(*dev_uuid);\n\t*dev_name = NULL;\n\t*dev_uuid = NULL;\n\treturn r;\n}\n\n \nstatic int dm_ima_alloc_and_copy_device_data(struct mapped_device *md, char **device_data,\n\t\t\t\t\t     unsigned int num_targets, bool noio)\n{\n\tchar *dev_name = NULL, *dev_uuid = NULL;\n\tint r;\n\n\tr = dm_ima_alloc_and_copy_name_uuid(md, &dev_name, &dev_uuid, noio);\n\tif (r)\n\t\treturn r;\n\n\t*device_data = dm_ima_alloc(DM_IMA_DEVICE_BUF_LEN, GFP_KERNEL, noio);\n\tif (!(*device_data)) {\n\t\tr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tscnprintf(*device_data, DM_IMA_DEVICE_BUF_LEN,\n\t\t  \"name=%s,uuid=%s,major=%d,minor=%d,minor_count=%d,num_targets=%u;\",\n\t\t  dev_name, dev_uuid, md->disk->major, md->disk->first_minor,\n\t\t  md->disk->minors, num_targets);\nerror:\n\tkfree(dev_name);\n\tkfree(dev_uuid);\n\treturn r;\n}\n\n \nstatic void dm_ima_measure_data(const char *event_name, const void *buf, size_t buf_len,\n\t\t\t\tbool noio)\n{\n\tunsigned int noio_flag;\n\n\tif (noio)\n\t\tnoio_flag = memalloc_noio_save();\n\n\tima_measure_critical_data(DM_NAME, event_name, buf, buf_len,\n\t\t\t\t  false, NULL, 0);\n\n\tif (noio)\n\t\tmemalloc_noio_restore(noio_flag);\n}\n\n \nstatic int dm_ima_alloc_and_copy_capacity_str(struct mapped_device *md, char **capacity_str,\n\t\t\t\t\t      bool noio)\n{\n\tsector_t capacity;\n\n\tcapacity = get_capacity(md->disk);\n\n\t*capacity_str = dm_ima_alloc(DM_IMA_DEVICE_CAPACITY_BUF_LEN, GFP_KERNEL, noio);\n\tif (!(*capacity_str))\n\t\treturn -ENOMEM;\n\n\tscnprintf(*capacity_str, DM_IMA_DEVICE_BUF_LEN, \"current_device_capacity=%llu;\",\n\t\t  capacity);\n\n\treturn 0;\n}\n\n \nvoid dm_ima_reset_data(struct mapped_device *md)\n{\n\tmemset(&(md->ima), 0, sizeof(md->ima));\n\tmd->ima.dm_version_str_len = strlen(DM_IMA_VERSION_STR);\n}\n\n \nvoid dm_ima_measure_on_table_load(struct dm_table *table, unsigned int status_flags)\n{\n\tsize_t device_data_buf_len, target_metadata_buf_len, target_data_buf_len, l = 0;\n\tchar *target_metadata_buf = NULL, *target_data_buf = NULL, *digest_buf = NULL;\n\tchar *ima_buf = NULL, *device_data_buf = NULL;\n\tint digest_size, last_target_measured = -1, r;\n\tstatus_type_t type = STATUSTYPE_IMA;\n\tsize_t cur_total_buf_len = 0;\n\tunsigned int num_targets, i;\n\tSHASH_DESC_ON_STACK(shash, NULL);\n\tstruct crypto_shash *tfm = NULL;\n\tu8 *digest = NULL;\n\tbool noio = false;\n\t \n\tconst size_t hash_alg_prefix_len = strlen(DM_IMA_TABLE_HASH_ALG) + 1;\n\tchar table_load_event_name[] = \"dm_table_load\";\n\n\tima_buf = dm_ima_alloc(DM_IMA_MEASUREMENT_BUF_LEN, GFP_KERNEL, noio);\n\tif (!ima_buf)\n\t\treturn;\n\n\ttarget_metadata_buf = dm_ima_alloc(DM_IMA_TARGET_METADATA_BUF_LEN, GFP_KERNEL, noio);\n\tif (!target_metadata_buf)\n\t\tgoto error;\n\n\ttarget_data_buf = dm_ima_alloc(DM_IMA_TARGET_DATA_BUF_LEN, GFP_KERNEL, noio);\n\tif (!target_data_buf)\n\t\tgoto error;\n\n\tnum_targets = table->num_targets;\n\n\tif (dm_ima_alloc_and_copy_device_data(table->md, &device_data_buf, num_targets, noio))\n\t\tgoto error;\n\n\ttfm = crypto_alloc_shash(DM_IMA_TABLE_HASH_ALG, 0, 0);\n\tif (IS_ERR(tfm))\n\t\tgoto error;\n\n\tshash->tfm = tfm;\n\tdigest_size = crypto_shash_digestsize(tfm);\n\tdigest = dm_ima_alloc(digest_size, GFP_KERNEL, noio);\n\tif (!digest)\n\t\tgoto error;\n\n\tr = crypto_shash_init(shash);\n\tif (r)\n\t\tgoto error;\n\n\tmemcpy(ima_buf + l, DM_IMA_VERSION_STR, table->md->ima.dm_version_str_len);\n\tl += table->md->ima.dm_version_str_len;\n\n\tdevice_data_buf_len = strlen(device_data_buf);\n\tmemcpy(ima_buf + l, device_data_buf, device_data_buf_len);\n\tl += device_data_buf_len;\n\n\tfor (i = 0; i < num_targets; i++) {\n\t\tstruct dm_target *ti = dm_table_get_target(table, i);\n\n\t\tlast_target_measured = 0;\n\n\t\t \n\t\tscnprintf(target_metadata_buf, DM_IMA_TARGET_METADATA_BUF_LEN,\n\t\t\t  \"target_index=%d,target_begin=%llu,target_len=%llu,\",\n\t\t\t  i, ti->begin, ti->len);\n\t\ttarget_metadata_buf_len = strlen(target_metadata_buf);\n\n\t\t \n\t\tif (ti->type->status)\n\t\t\tti->type->status(ti, type, status_flags, target_data_buf,\n\t\t\t\t\t DM_IMA_TARGET_DATA_BUF_LEN);\n\t\telse\n\t\t\ttarget_data_buf[0] = '\\0';\n\n\t\ttarget_data_buf_len = strlen(target_data_buf);\n\n\t\t \n\t\tcur_total_buf_len = l + target_metadata_buf_len + target_data_buf_len;\n\n\t\t \n\t\tif (unlikely(cur_total_buf_len >= DM_IMA_MEASUREMENT_BUF_LEN)) {\n\t\t\tdm_ima_measure_data(table_load_event_name, ima_buf, l, noio);\n\t\t\tr = crypto_shash_update(shash, (const u8 *)ima_buf, l);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\n\t\t\tmemset(ima_buf, 0, DM_IMA_MEASUREMENT_BUF_LEN);\n\t\t\tl = 0;\n\n\t\t\t \n\t\t\tmemcpy(ima_buf + l, DM_IMA_VERSION_STR, table->md->ima.dm_version_str_len);\n\t\t\tl += table->md->ima.dm_version_str_len;\n\n\t\t\tmemcpy(ima_buf + l, device_data_buf, device_data_buf_len);\n\t\t\tl += device_data_buf_len;\n\n\t\t\t \n\t\t\tlast_target_measured = 1;\n\t\t}\n\n\t\t \n\t\tmemcpy(ima_buf + l, target_metadata_buf, target_metadata_buf_len);\n\t\tl += target_metadata_buf_len;\n\n\t\tmemcpy(ima_buf + l, target_data_buf, target_data_buf_len);\n\t\tl += target_data_buf_len;\n\t}\n\n\tif (!last_target_measured) {\n\t\tdm_ima_measure_data(table_load_event_name, ima_buf, l, noio);\n\n\t\tr = crypto_shash_update(shash, (const u8 *)ima_buf, l);\n\t\tif (r < 0)\n\t\t\tgoto error;\n\t}\n\n\t \n\tr = crypto_shash_final(shash, digest);\n\tif (r < 0)\n\t\tgoto error;\n\n\tdigest_buf = dm_ima_alloc((digest_size*2) + hash_alg_prefix_len + 1, GFP_KERNEL, noio);\n\n\tif (!digest_buf)\n\t\tgoto error;\n\n\tsnprintf(digest_buf, hash_alg_prefix_len + 1, \"%s:\", DM_IMA_TABLE_HASH_ALG);\n\n\tfor (i = 0; i < digest_size; i++)\n\t\tsnprintf((digest_buf + hash_alg_prefix_len + (i*2)), 3, \"%02x\", digest[i]);\n\n\tif (table->md->ima.active_table.hash != table->md->ima.inactive_table.hash)\n\t\tkfree(table->md->ima.inactive_table.hash);\n\n\ttable->md->ima.inactive_table.hash = digest_buf;\n\ttable->md->ima.inactive_table.hash_len = strlen(digest_buf);\n\ttable->md->ima.inactive_table.num_targets = num_targets;\n\n\tif (table->md->ima.active_table.device_metadata !=\n\t    table->md->ima.inactive_table.device_metadata)\n\t\tkfree(table->md->ima.inactive_table.device_metadata);\n\n\ttable->md->ima.inactive_table.device_metadata = device_data_buf;\n\ttable->md->ima.inactive_table.device_metadata_len = device_data_buf_len;\n\n\tgoto exit;\nerror:\n\tkfree(digest_buf);\n\tkfree(device_data_buf);\nexit:\n\tkfree(digest);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(ima_buf);\n\tkfree(target_metadata_buf);\n\tkfree(target_data_buf);\n}\n\n \nvoid dm_ima_measure_on_device_resume(struct mapped_device *md, bool swap)\n{\n\tchar *device_table_data, *dev_name = NULL, *dev_uuid = NULL, *capacity_str = NULL;\n\tchar active[] = \"active_table_hash=\";\n\tunsigned int active_len = strlen(active), capacity_len = 0;\n\tunsigned int l = 0;\n\tbool noio = true;\n\tbool nodata = true;\n\tint r;\n\n\tdevice_table_data = dm_ima_alloc(DM_IMA_DEVICE_BUF_LEN, GFP_KERNEL, noio);\n\tif (!device_table_data)\n\t\treturn;\n\n\tr = dm_ima_alloc_and_copy_capacity_str(md, &capacity_str, noio);\n\tif (r)\n\t\tgoto error;\n\n\tmemcpy(device_table_data + l, DM_IMA_VERSION_STR, md->ima.dm_version_str_len);\n\tl += md->ima.dm_version_str_len;\n\n\tif (swap) {\n\t\tif (md->ima.active_table.hash != md->ima.inactive_table.hash)\n\t\t\tkfree(md->ima.active_table.hash);\n\n\t\tmd->ima.active_table.hash = NULL;\n\t\tmd->ima.active_table.hash_len = 0;\n\n\t\tif (md->ima.active_table.device_metadata !=\n\t\t    md->ima.inactive_table.device_metadata)\n\t\t\tkfree(md->ima.active_table.device_metadata);\n\n\t\tmd->ima.active_table.device_metadata = NULL;\n\t\tmd->ima.active_table.device_metadata_len = 0;\n\t\tmd->ima.active_table.num_targets = 0;\n\n\t\tif (md->ima.inactive_table.hash) {\n\t\t\tmd->ima.active_table.hash = md->ima.inactive_table.hash;\n\t\t\tmd->ima.active_table.hash_len = md->ima.inactive_table.hash_len;\n\t\t\tmd->ima.inactive_table.hash = NULL;\n\t\t\tmd->ima.inactive_table.hash_len = 0;\n\t\t}\n\n\t\tif (md->ima.inactive_table.device_metadata) {\n\t\t\tmd->ima.active_table.device_metadata =\n\t\t\t\tmd->ima.inactive_table.device_metadata;\n\t\t\tmd->ima.active_table.device_metadata_len =\n\t\t\t\tmd->ima.inactive_table.device_metadata_len;\n\t\t\tmd->ima.active_table.num_targets = md->ima.inactive_table.num_targets;\n\t\t\tmd->ima.inactive_table.device_metadata = NULL;\n\t\t\tmd->ima.inactive_table.device_metadata_len = 0;\n\t\t\tmd->ima.inactive_table.num_targets = 0;\n\t\t}\n\t}\n\n\tif (md->ima.active_table.device_metadata) {\n\t\tmemcpy(device_table_data + l, md->ima.active_table.device_metadata,\n\t\t       md->ima.active_table.device_metadata_len);\n\t\tl += md->ima.active_table.device_metadata_len;\n\n\t\tnodata = false;\n\t}\n\n\tif (md->ima.active_table.hash) {\n\t\tmemcpy(device_table_data + l, active, active_len);\n\t\tl += active_len;\n\n\t\tmemcpy(device_table_data + l, md->ima.active_table.hash,\n\t\t       md->ima.active_table.hash_len);\n\t\tl += md->ima.active_table.hash_len;\n\n\t\tmemcpy(device_table_data + l, \";\", 1);\n\t\tl++;\n\n\t\tnodata = false;\n\t}\n\n\tif (nodata) {\n\t\tr = dm_ima_alloc_and_copy_name_uuid(md, &dev_name, &dev_uuid, noio);\n\t\tif (r)\n\t\t\tgoto error;\n\n\t\tscnprintf(device_table_data, DM_IMA_DEVICE_BUF_LEN,\n\t\t\t  \"%sname=%s,uuid=%s;device_resume=no_data;\",\n\t\t\t  DM_IMA_VERSION_STR, dev_name, dev_uuid);\n\t\tl = strlen(device_table_data);\n\n\t}\n\n\tcapacity_len = strlen(capacity_str);\n\tmemcpy(device_table_data + l, capacity_str, capacity_len);\n\tl += capacity_len;\n\n\tdm_ima_measure_data(\"dm_device_resume\", device_table_data, l, noio);\n\n\tkfree(dev_name);\n\tkfree(dev_uuid);\nerror:\n\tkfree(capacity_str);\n\tkfree(device_table_data);\n}\n\n \nvoid dm_ima_measure_on_device_remove(struct mapped_device *md, bool remove_all)\n{\n\tchar *device_table_data, *dev_name = NULL, *dev_uuid = NULL, *capacity_str = NULL;\n\tchar active_table_str[] = \"active_table_hash=\";\n\tchar inactive_table_str[] = \"inactive_table_hash=\";\n\tchar device_active_str[] = \"device_active_metadata=\";\n\tchar device_inactive_str[] = \"device_inactive_metadata=\";\n\tchar remove_all_str[] = \"remove_all=\";\n\tunsigned int active_table_len = strlen(active_table_str);\n\tunsigned int inactive_table_len = strlen(inactive_table_str);\n\tunsigned int device_active_len = strlen(device_active_str);\n\tunsigned int device_inactive_len = strlen(device_inactive_str);\n\tunsigned int remove_all_len = strlen(remove_all_str);\n\tunsigned int capacity_len = 0;\n\tunsigned int l = 0;\n\tbool noio = true;\n\tbool nodata = true;\n\tint r;\n\n\tdevice_table_data = dm_ima_alloc(DM_IMA_DEVICE_BUF_LEN*2, GFP_KERNEL, noio);\n\tif (!device_table_data)\n\t\tgoto exit;\n\n\tr = dm_ima_alloc_and_copy_capacity_str(md, &capacity_str, noio);\n\tif (r) {\n\t\tkfree(device_table_data);\n\t\tgoto exit;\n\t}\n\n\tmemcpy(device_table_data + l, DM_IMA_VERSION_STR, md->ima.dm_version_str_len);\n\tl += md->ima.dm_version_str_len;\n\n\tif (md->ima.active_table.device_metadata) {\n\t\tmemcpy(device_table_data + l, device_active_str, device_active_len);\n\t\tl += device_active_len;\n\n\t\tmemcpy(device_table_data + l, md->ima.active_table.device_metadata,\n\t\t       md->ima.active_table.device_metadata_len);\n\t\tl += md->ima.active_table.device_metadata_len;\n\n\t\tnodata = false;\n\t}\n\n\tif (md->ima.inactive_table.device_metadata) {\n\t\tmemcpy(device_table_data + l, device_inactive_str, device_inactive_len);\n\t\tl += device_inactive_len;\n\n\t\tmemcpy(device_table_data + l, md->ima.inactive_table.device_metadata,\n\t\t       md->ima.inactive_table.device_metadata_len);\n\t\tl += md->ima.inactive_table.device_metadata_len;\n\n\t\tnodata = false;\n\t}\n\n\tif (md->ima.active_table.hash) {\n\t\tmemcpy(device_table_data + l, active_table_str, active_table_len);\n\t\tl += active_table_len;\n\n\t\tmemcpy(device_table_data + l, md->ima.active_table.hash,\n\t\t\t   md->ima.active_table.hash_len);\n\t\tl += md->ima.active_table.hash_len;\n\n\t\tmemcpy(device_table_data + l, \",\", 1);\n\t\tl++;\n\n\t\tnodata = false;\n\t}\n\n\tif (md->ima.inactive_table.hash) {\n\t\tmemcpy(device_table_data + l, inactive_table_str, inactive_table_len);\n\t\tl += inactive_table_len;\n\n\t\tmemcpy(device_table_data + l, md->ima.inactive_table.hash,\n\t\t       md->ima.inactive_table.hash_len);\n\t\tl += md->ima.inactive_table.hash_len;\n\n\t\tmemcpy(device_table_data + l, \",\", 1);\n\t\tl++;\n\n\t\tnodata = false;\n\t}\n\t \n\tif (nodata) {\n\t\tif (dm_ima_alloc_and_copy_name_uuid(md, &dev_name, &dev_uuid, noio))\n\t\t\tgoto error;\n\n\t\tscnprintf(device_table_data, DM_IMA_DEVICE_BUF_LEN,\n\t\t\t  \"%sname=%s,uuid=%s;device_remove=no_data;\",\n\t\t\t  DM_IMA_VERSION_STR, dev_name, dev_uuid);\n\t\tl = strlen(device_table_data);\n\t}\n\n\tmemcpy(device_table_data + l, remove_all_str, remove_all_len);\n\tl += remove_all_len;\n\tmemcpy(device_table_data + l, remove_all ? \"y;\" : \"n;\", 2);\n\tl += 2;\n\n\tcapacity_len = strlen(capacity_str);\n\tmemcpy(device_table_data + l, capacity_str, capacity_len);\n\tl += capacity_len;\n\n\tdm_ima_measure_data(\"dm_device_remove\", device_table_data, l, noio);\n\nerror:\n\tkfree(device_table_data);\n\tkfree(capacity_str);\nexit:\n\tkfree(md->ima.active_table.device_metadata);\n\n\tif (md->ima.active_table.device_metadata !=\n\t    md->ima.inactive_table.device_metadata)\n\t\tkfree(md->ima.inactive_table.device_metadata);\n\n\tkfree(md->ima.active_table.hash);\n\n\tif (md->ima.active_table.hash != md->ima.inactive_table.hash)\n\t\tkfree(md->ima.inactive_table.hash);\n\n\tdm_ima_reset_data(md);\n\n\tkfree(dev_name);\n\tkfree(dev_uuid);\n}\n\n \nvoid dm_ima_measure_on_table_clear(struct mapped_device *md, bool new_map)\n{\n\tunsigned int l = 0, capacity_len = 0;\n\tchar *device_table_data = NULL, *dev_name = NULL, *dev_uuid = NULL, *capacity_str = NULL;\n\tchar inactive_str[] = \"inactive_table_hash=\";\n\tunsigned int inactive_len = strlen(inactive_str);\n\tbool noio = true;\n\tbool nodata = true;\n\tint r;\n\n\tdevice_table_data = dm_ima_alloc(DM_IMA_DEVICE_BUF_LEN, GFP_KERNEL, noio);\n\tif (!device_table_data)\n\t\treturn;\n\n\tr = dm_ima_alloc_and_copy_capacity_str(md, &capacity_str, noio);\n\tif (r)\n\t\tgoto error1;\n\n\tmemcpy(device_table_data + l, DM_IMA_VERSION_STR, md->ima.dm_version_str_len);\n\tl += md->ima.dm_version_str_len;\n\n\tif (md->ima.inactive_table.device_metadata_len &&\n\t    md->ima.inactive_table.hash_len) {\n\t\tmemcpy(device_table_data + l, md->ima.inactive_table.device_metadata,\n\t\t       md->ima.inactive_table.device_metadata_len);\n\t\tl += md->ima.inactive_table.device_metadata_len;\n\n\t\tmemcpy(device_table_data + l, inactive_str, inactive_len);\n\t\tl += inactive_len;\n\n\t\tmemcpy(device_table_data + l, md->ima.inactive_table.hash,\n\t\t\t   md->ima.inactive_table.hash_len);\n\n\t\tl += md->ima.inactive_table.hash_len;\n\n\t\tmemcpy(device_table_data + l, \";\", 1);\n\t\tl++;\n\n\t\tnodata = false;\n\t}\n\n\tif (nodata) {\n\t\tif (dm_ima_alloc_and_copy_name_uuid(md, &dev_name, &dev_uuid, noio))\n\t\t\tgoto error2;\n\n\t\tscnprintf(device_table_data, DM_IMA_DEVICE_BUF_LEN,\n\t\t\t  \"%sname=%s,uuid=%s;table_clear=no_data;\",\n\t\t\t   DM_IMA_VERSION_STR, dev_name, dev_uuid);\n\t\tl = strlen(device_table_data);\n\t}\n\n\tcapacity_len = strlen(capacity_str);\n\tmemcpy(device_table_data + l, capacity_str, capacity_len);\n\tl += capacity_len;\n\n\tdm_ima_measure_data(\"dm_table_clear\", device_table_data, l, noio);\n\n\tif (new_map) {\n\t\tif (md->ima.inactive_table.hash &&\n\t\t    md->ima.inactive_table.hash != md->ima.active_table.hash)\n\t\t\tkfree(md->ima.inactive_table.hash);\n\n\t\tmd->ima.inactive_table.hash = NULL;\n\t\tmd->ima.inactive_table.hash_len = 0;\n\n\t\tif (md->ima.inactive_table.device_metadata &&\n\t\t    md->ima.inactive_table.device_metadata != md->ima.active_table.device_metadata)\n\t\t\tkfree(md->ima.inactive_table.device_metadata);\n\n\t\tmd->ima.inactive_table.device_metadata = NULL;\n\t\tmd->ima.inactive_table.device_metadata_len = 0;\n\t\tmd->ima.inactive_table.num_targets = 0;\n\n\t\tif (md->ima.active_table.hash) {\n\t\t\tmd->ima.inactive_table.hash = md->ima.active_table.hash;\n\t\t\tmd->ima.inactive_table.hash_len = md->ima.active_table.hash_len;\n\t\t}\n\n\t\tif (md->ima.active_table.device_metadata) {\n\t\t\tmd->ima.inactive_table.device_metadata =\n\t\t\t\tmd->ima.active_table.device_metadata;\n\t\t\tmd->ima.inactive_table.device_metadata_len =\n\t\t\t\tmd->ima.active_table.device_metadata_len;\n\t\t\tmd->ima.inactive_table.num_targets =\n\t\t\t\tmd->ima.active_table.num_targets;\n\t\t}\n\t}\n\n\tkfree(dev_name);\n\tkfree(dev_uuid);\nerror2:\n\tkfree(capacity_str);\nerror1:\n\tkfree(device_table_data);\n}\n\n \nvoid dm_ima_measure_on_device_rename(struct mapped_device *md)\n{\n\tchar *old_device_data = NULL, *new_device_data = NULL, *combined_device_data = NULL;\n\tchar *new_dev_name = NULL, *new_dev_uuid = NULL, *capacity_str = NULL;\n\tbool noio = true;\n\tint r;\n\n\tif (dm_ima_alloc_and_copy_device_data(md, &new_device_data,\n\t\t\t\t\t      md->ima.active_table.num_targets, noio))\n\t\treturn;\n\n\tif (dm_ima_alloc_and_copy_name_uuid(md, &new_dev_name, &new_dev_uuid, noio))\n\t\tgoto error;\n\n\tcombined_device_data = dm_ima_alloc(DM_IMA_DEVICE_BUF_LEN * 2, GFP_KERNEL, noio);\n\tif (!combined_device_data)\n\t\tgoto error;\n\n\tr = dm_ima_alloc_and_copy_capacity_str(md, &capacity_str, noio);\n\tif (r)\n\t\tgoto error;\n\n\told_device_data = md->ima.active_table.device_metadata;\n\n\tmd->ima.active_table.device_metadata = new_device_data;\n\tmd->ima.active_table.device_metadata_len = strlen(new_device_data);\n\n\tscnprintf(combined_device_data, DM_IMA_DEVICE_BUF_LEN * 2,\n\t\t  \"%s%snew_name=%s,new_uuid=%s;%s\", DM_IMA_VERSION_STR, old_device_data,\n\t\t  new_dev_name, new_dev_uuid, capacity_str);\n\n\tdm_ima_measure_data(\"dm_device_rename\", combined_device_data, strlen(combined_device_data),\n\t\t\t    noio);\n\n\tgoto exit;\n\nerror:\n\tkfree(new_device_data);\nexit:\n\tkfree(capacity_str);\n\tkfree(combined_device_data);\n\tkfree(old_device_data);\n\tkfree(new_dev_name);\n\tkfree(new_dev_uuid);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}