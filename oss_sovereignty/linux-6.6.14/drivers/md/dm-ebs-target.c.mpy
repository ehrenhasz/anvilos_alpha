{
  "module_name": "dm-ebs-target.c",
  "hash_id": "ad288de220f39bc6b76e8c95d03ffae9ec5f00ab35f40ad39ad7c7fe50d7416f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-ebs-target.c",
  "human_readable_source": "\n \n\n#include \"dm.h\"\n#include <linux/module.h>\n#include <linux/workqueue.h>\n#include <linux/dm-bufio.h>\n\n#define DM_MSG_PREFIX \"ebs\"\n\nstatic void ebs_dtr(struct dm_target *ti);\n\n \nstruct ebs_c {\n\tstruct dm_dev *dev;\t\t \n\tstruct dm_bufio_client *bufio;\t \n\tstruct workqueue_struct *wq;\t \n\tstruct work_struct ws;\t\t \n\tstruct bio_list bios_in;\t \n\tspinlock_t lock;\t\t \n\tsector_t start;\t\t\t \n\tunsigned int e_bs;\t\t \n\tunsigned int u_bs;\t\t \n\tunsigned char block_shift;\t \n\tbool u_bs_set:1;\t\t \n};\n\nstatic inline sector_t __sector_to_block(struct ebs_c *ec, sector_t sector)\n{\n\treturn sector >> ec->block_shift;\n}\n\nstatic inline sector_t __block_mod(sector_t sector, unsigned int bs)\n{\n\treturn sector & (bs - 1);\n}\n\n \nstatic inline unsigned int __nr_blocks(struct ebs_c *ec, struct bio *bio)\n{\n\tsector_t end_sector = __block_mod(bio->bi_iter.bi_sector, ec->u_bs) + bio_sectors(bio);\n\n\treturn __sector_to_block(ec, end_sector) + (__block_mod(end_sector, ec->u_bs) ? 1 : 0);\n}\n\nstatic inline bool __ebs_check_bs(unsigned int bs)\n{\n\treturn bs && is_power_of_2(bs);\n}\n\n \nstatic int __ebs_rw_bvec(struct ebs_c *ec, enum req_op op, struct bio_vec *bv,\n\t\t\t struct bvec_iter *iter)\n{\n\tint r = 0;\n\tunsigned char *ba, *pa;\n\tunsigned int cur_len;\n\tunsigned int bv_len = bv->bv_len;\n\tunsigned int buf_off = to_bytes(__block_mod(iter->bi_sector, ec->u_bs));\n\tsector_t block = __sector_to_block(ec, iter->bi_sector);\n\tstruct dm_buffer *b;\n\n\tif (unlikely(!bv->bv_page || !bv_len))\n\t\treturn -EIO;\n\n\tpa = bvec_virt(bv);\n\n\t \n\twhile (bv_len) {\n\t\tcur_len = min(dm_bufio_get_block_size(ec->bufio) - buf_off, bv_len);\n\n\t\t \n\t\tif (op == REQ_OP_READ || buf_off || bv_len < dm_bufio_get_block_size(ec->bufio))\n\t\t\tba = dm_bufio_read(ec->bufio, block, &b);\n\t\telse\n\t\t\tba = dm_bufio_new(ec->bufio, block, &b);\n\n\t\tif (IS_ERR(ba)) {\n\t\t\t \n\t\t\tr = PTR_ERR(ba);\n\t\t} else {\n\t\t\t \n\t\t\tba += buf_off;\n\t\t\tif (op == REQ_OP_READ) {\n\t\t\t\tmemcpy(pa, ba, cur_len);\n\t\t\t\tflush_dcache_page(bv->bv_page);\n\t\t\t} else {\n\t\t\t\tflush_dcache_page(bv->bv_page);\n\t\t\t\tmemcpy(ba, pa, cur_len);\n\t\t\t\tdm_bufio_mark_partial_buffer_dirty(b, buf_off, buf_off + cur_len);\n\t\t\t}\n\n\t\t\tdm_bufio_release(b);\n\t\t}\n\n\t\tpa += cur_len;\n\t\tbv_len -= cur_len;\n\t\tbuf_off = 0;\n\t\tblock++;\n\t}\n\n\treturn r;\n}\n\n \nstatic int __ebs_rw_bio(struct ebs_c *ec, enum req_op op, struct bio *bio)\n{\n\tint r = 0, rr;\n\tstruct bio_vec bv;\n\tstruct bvec_iter iter;\n\n\tbio_for_each_bvec(bv, bio, iter) {\n\t\trr = __ebs_rw_bvec(ec, op, &bv, &iter);\n\t\tif (rr)\n\t\t\tr = rr;\n\t}\n\n\treturn r;\n}\n\n \nstatic int __ebs_discard_bio(struct ebs_c *ec, struct bio *bio)\n{\n\tsector_t block, blocks, sector = bio->bi_iter.bi_sector;\n\n\tblock = __sector_to_block(ec, sector);\n\tblocks = __nr_blocks(ec, bio);\n\n\t \n\tif (__block_mod(sector, ec->u_bs)) {\n\t\tblock++;\n\t\tblocks--;\n\t}\n\n\t \n\tif (blocks && __block_mod(bio_end_sector(bio), ec->u_bs))\n\t\tblocks--;\n\n\treturn blocks ? dm_bufio_issue_discard(ec->bufio, block, blocks) : 0;\n}\n\n \nstatic void __ebs_forget_bio(struct ebs_c *ec, struct bio *bio)\n{\n\tsector_t blocks, sector = bio->bi_iter.bi_sector;\n\n\tblocks = __nr_blocks(ec, bio);\n\n\tdm_bufio_forget_buffers(ec->bufio, __sector_to_block(ec, sector), blocks);\n}\n\n \nstatic void __ebs_process_bios(struct work_struct *ws)\n{\n\tint r;\n\tbool write = false;\n\tsector_t block1, block2;\n\tstruct ebs_c *ec = container_of(ws, struct ebs_c, ws);\n\tstruct bio *bio;\n\tstruct bio_list bios;\n\n\tbio_list_init(&bios);\n\n\tspin_lock_irq(&ec->lock);\n\tbios = ec->bios_in;\n\tbio_list_init(&ec->bios_in);\n\tspin_unlock_irq(&ec->lock);\n\n\t \n\tbio_list_for_each(bio, &bios) {\n\t\tblock1 = __sector_to_block(ec, bio->bi_iter.bi_sector);\n\t\tif (bio_op(bio) == REQ_OP_READ)\n\t\t\tdm_bufio_prefetch(ec->bufio, block1, __nr_blocks(ec, bio));\n\t\telse if (bio_op(bio) == REQ_OP_WRITE && !(bio->bi_opf & REQ_PREFLUSH)) {\n\t\t\tblock2 = __sector_to_block(ec, bio_end_sector(bio));\n\t\t\tif (__block_mod(bio->bi_iter.bi_sector, ec->u_bs))\n\t\t\t\tdm_bufio_prefetch(ec->bufio, block1, 1);\n\t\t\tif (__block_mod(bio_end_sector(bio), ec->u_bs) && block2 != block1)\n\t\t\t\tdm_bufio_prefetch(ec->bufio, block2, 1);\n\t\t}\n\t}\n\n\tbio_list_for_each(bio, &bios) {\n\t\tr = -EIO;\n\t\tif (bio_op(bio) == REQ_OP_READ)\n\t\t\tr = __ebs_rw_bio(ec, REQ_OP_READ, bio);\n\t\telse if (bio_op(bio) == REQ_OP_WRITE) {\n\t\t\twrite = true;\n\t\t\tr = __ebs_rw_bio(ec, REQ_OP_WRITE, bio);\n\t\t} else if (bio_op(bio) == REQ_OP_DISCARD) {\n\t\t\t__ebs_forget_bio(ec, bio);\n\t\t\tr = __ebs_discard_bio(ec, bio);\n\t\t}\n\n\t\tif (r < 0)\n\t\t\tbio->bi_status = errno_to_blk_status(r);\n\t}\n\n\t \n\tr = write ? dm_bufio_write_dirty_buffers(ec->bufio) : 0;\n\n\twhile ((bio = bio_list_pop(&bios))) {\n\t\t \n\t\tif (unlikely(r && bio_op(bio) == REQ_OP_WRITE))\n\t\t\tbio_io_error(bio);\n\t\telse\n\t\t\tbio_endio(bio);\n\t}\n}\n\n \nstatic int ebs_ctr(struct dm_target *ti, unsigned int argc, char **argv)\n{\n\tint r;\n\tunsigned short tmp1;\n\tunsigned long long tmp;\n\tchar dummy;\n\tstruct ebs_c *ec;\n\n\tif (argc < 3 || argc > 4) {\n\t\tti->error = \"Invalid argument count\";\n\t\treturn -EINVAL;\n\t}\n\n\tec = ti->private = kzalloc(sizeof(*ec), GFP_KERNEL);\n\tif (!ec) {\n\t\tti->error = \"Cannot allocate ebs context\";\n\t\treturn -ENOMEM;\n\t}\n\n\tr = -EINVAL;\n\tif (sscanf(argv[1], \"%llu%c\", &tmp, &dummy) != 1 ||\n\t    tmp != (sector_t)tmp ||\n\t    (sector_t)tmp >= ti->len) {\n\t\tti->error = \"Invalid device offset sector\";\n\t\tgoto bad;\n\t}\n\tec->start = tmp;\n\n\tif (sscanf(argv[2], \"%hu%c\", &tmp1, &dummy) != 1 ||\n\t    !__ebs_check_bs(tmp1) ||\n\t    to_bytes(tmp1) > PAGE_SIZE) {\n\t\tti->error = \"Invalid emulated block size\";\n\t\tgoto bad;\n\t}\n\tec->e_bs = tmp1;\n\n\tif (argc > 3) {\n\t\tif (sscanf(argv[3], \"%hu%c\", &tmp1, &dummy) != 1 || !__ebs_check_bs(tmp1)) {\n\t\t\tti->error = \"Invalid underlying block size\";\n\t\t\tgoto bad;\n\t\t}\n\t\tec->u_bs = tmp1;\n\t\tec->u_bs_set = true;\n\t} else\n\t\tec->u_bs_set = false;\n\n\tr = dm_get_device(ti, argv[0], dm_table_get_mode(ti->table), &ec->dev);\n\tif (r) {\n\t\tti->error = \"Device lookup failed\";\n\t\tec->dev = NULL;\n\t\tgoto bad;\n\t}\n\n\tr = -EINVAL;\n\tif (!ec->u_bs_set) {\n\t\tec->u_bs = to_sector(bdev_logical_block_size(ec->dev->bdev));\n\t\tif (!__ebs_check_bs(ec->u_bs)) {\n\t\t\tti->error = \"Invalid retrieved underlying block size\";\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\tif (!ec->u_bs_set && ec->e_bs == ec->u_bs)\n\t\tDMINFO(\"Emulation superfluous: emulated equal to underlying block size\");\n\n\tif (__block_mod(ec->start, ec->u_bs)) {\n\t\tti->error = \"Device offset must be multiple of underlying block size\";\n\t\tgoto bad;\n\t}\n\n\tec->bufio = dm_bufio_client_create(ec->dev->bdev, to_bytes(ec->u_bs), 1,\n\t\t\t\t\t   0, NULL, NULL, 0);\n\tif (IS_ERR(ec->bufio)) {\n\t\tti->error = \"Cannot create dm bufio client\";\n\t\tr = PTR_ERR(ec->bufio);\n\t\tec->bufio = NULL;\n\t\tgoto bad;\n\t}\n\n\tec->wq = alloc_ordered_workqueue(\"dm-\" DM_MSG_PREFIX, WQ_MEM_RECLAIM);\n\tif (!ec->wq) {\n\t\tti->error = \"Cannot create dm-\" DM_MSG_PREFIX \" workqueue\";\n\t\tr = -ENOMEM;\n\t\tgoto bad;\n\t}\n\n\tec->block_shift = __ffs(ec->u_bs);\n\tINIT_WORK(&ec->ws, &__ebs_process_bios);\n\tbio_list_init(&ec->bios_in);\n\tspin_lock_init(&ec->lock);\n\n\tti->num_flush_bios = 1;\n\tti->num_discard_bios = 1;\n\tti->num_secure_erase_bios = 0;\n\tti->num_write_zeroes_bios = 0;\n\treturn 0;\nbad:\n\tebs_dtr(ti);\n\treturn r;\n}\n\nstatic void ebs_dtr(struct dm_target *ti)\n{\n\tstruct ebs_c *ec = ti->private;\n\n\tif (ec->wq)\n\t\tdestroy_workqueue(ec->wq);\n\tif (ec->bufio)\n\t\tdm_bufio_client_destroy(ec->bufio);\n\tif (ec->dev)\n\t\tdm_put_device(ti, ec->dev);\n\tkfree(ec);\n}\n\nstatic int ebs_map(struct dm_target *ti, struct bio *bio)\n{\n\tstruct ebs_c *ec = ti->private;\n\n\tbio_set_dev(bio, ec->dev->bdev);\n\tbio->bi_iter.bi_sector = ec->start + dm_target_offset(ti, bio->bi_iter.bi_sector);\n\n\tif (unlikely(bio_op(bio) == REQ_OP_FLUSH))\n\t\treturn DM_MAPIO_REMAPPED;\n\t \n\tif (likely(__block_mod(bio->bi_iter.bi_sector, ec->u_bs) ||\n\t\t   __block_mod(bio_end_sector(bio), ec->u_bs) ||\n\t\t   ec->e_bs == ec->u_bs)) {\n\t\tspin_lock_irq(&ec->lock);\n\t\tbio_list_add(&ec->bios_in, bio);\n\t\tspin_unlock_irq(&ec->lock);\n\n\t\tqueue_work(ec->wq, &ec->ws);\n\n\t\treturn DM_MAPIO_SUBMITTED;\n\t}\n\n\t \n\t__ebs_forget_bio(ec, bio);\n\n\treturn DM_MAPIO_REMAPPED;\n}\n\nstatic void ebs_status(struct dm_target *ti, status_type_t type,\n\t\t       unsigned int status_flags, char *result, unsigned int maxlen)\n{\n\tstruct ebs_c *ec = ti->private;\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\t*result = '\\0';\n\t\tbreak;\n\tcase STATUSTYPE_TABLE:\n\t\tsnprintf(result, maxlen, ec->u_bs_set ? \"%s %llu %u %u\" : \"%s %llu %u\",\n\t\t\t ec->dev->name, (unsigned long long) ec->start, ec->e_bs, ec->u_bs);\n\t\tbreak;\n\tcase STATUSTYPE_IMA:\n\t\t*result = '\\0';\n\t\tbreak;\n\t}\n}\n\nstatic int ebs_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)\n{\n\tstruct ebs_c *ec = ti->private;\n\tstruct dm_dev *dev = ec->dev;\n\n\t \n\t*bdev = dev->bdev;\n\treturn !!(ec->start || ti->len != bdev_nr_sectors(dev->bdev));\n}\n\nstatic void ebs_io_hints(struct dm_target *ti, struct queue_limits *limits)\n{\n\tstruct ebs_c *ec = ti->private;\n\n\tlimits->logical_block_size = to_bytes(ec->e_bs);\n\tlimits->physical_block_size = to_bytes(ec->u_bs);\n\tlimits->alignment_offset = limits->physical_block_size;\n\tblk_limits_io_min(limits, limits->logical_block_size);\n}\n\nstatic int ebs_iterate_devices(struct dm_target *ti,\n\t\t\t\t  iterate_devices_callout_fn fn, void *data)\n{\n\tstruct ebs_c *ec = ti->private;\n\n\treturn fn(ti, ec->dev, ec->start, ti->len, data);\n}\n\nstatic struct target_type ebs_target = {\n\t.name\t\t = \"ebs\",\n\t.version\t = {1, 0, 1},\n\t.features\t = DM_TARGET_PASSES_INTEGRITY,\n\t.module\t\t = THIS_MODULE,\n\t.ctr\t\t = ebs_ctr,\n\t.dtr\t\t = ebs_dtr,\n\t.map\t\t = ebs_map,\n\t.status\t\t = ebs_status,\n\t.io_hints\t = ebs_io_hints,\n\t.prepare_ioctl\t = ebs_prepare_ioctl,\n\t.iterate_devices = ebs_iterate_devices,\n};\nmodule_dm(ebs);\n\nMODULE_AUTHOR(\"Heinz Mauelshagen <dm-devel@redhat.com>\");\nMODULE_DESCRIPTION(DM_NAME \" emulated block size target\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}