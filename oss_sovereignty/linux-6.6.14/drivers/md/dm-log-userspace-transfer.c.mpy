{
  "module_name": "dm-log-userspace-transfer.c",
  "hash_id": "6f693cc80395dde9c82be3513fd18aa9a9e166eaf0b1e47b49efb790e2caab09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-log-userspace-transfer.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <linux/workqueue.h>\n#include <linux/connector.h>\n#include <linux/device-mapper.h>\n#include <linux/dm-log-userspace.h>\n\n#include \"dm-log-userspace-transfer.h\"\n\nstatic uint32_t dm_ulog_seq;\n\n \n#define DM_ULOG_RETRY_TIMEOUT (15 * HZ)\n\n \n#define DM_ULOG_PREALLOCED_SIZE 512\nstatic struct cn_msg *prealloced_cn_msg;\nstatic struct dm_ulog_request *prealloced_ulog_tfr;\n\nstatic struct cb_id ulog_cn_id = {\n\t.idx = CN_IDX_DM,\n\t.val = CN_VAL_DM_USERSPACE_LOG\n};\n\nstatic DEFINE_MUTEX(dm_ulog_lock);\n\nstruct receiving_pkg {\n\tstruct list_head list;\n\tstruct completion complete;\n\n\tuint32_t seq;\n\n\tint error;\n\tsize_t *data_size;\n\tchar *data;\n};\n\nstatic DEFINE_SPINLOCK(receiving_list_lock);\nstatic struct list_head receiving_list;\n\nstatic int dm_ulog_sendto_server(struct dm_ulog_request *tfr)\n{\n\tint r;\n\tstruct cn_msg *msg = prealloced_cn_msg;\n\n\tmemset(msg, 0, sizeof(struct cn_msg));\n\n\tmsg->id.idx = ulog_cn_id.idx;\n\tmsg->id.val = ulog_cn_id.val;\n\tmsg->ack = 0;\n\tmsg->seq = tfr->seq;\n\tmsg->len = sizeof(struct dm_ulog_request) + tfr->data_size;\n\n\tr = cn_netlink_send(msg, 0, 0, gfp_any());\n\n\treturn r;\n}\n\n \nstatic int fill_pkg(struct cn_msg *msg, struct dm_ulog_request *tfr)\n{\n\tuint32_t rtn_seq = (msg) ? msg->seq : (tfr) ? tfr->seq : 0;\n\tstruct receiving_pkg *pkg;\n\n\t \n\tlist_for_each_entry(pkg, &receiving_list, list) {\n\t\tif (rtn_seq != pkg->seq)\n\t\t\tcontinue;\n\n\t\tif (msg) {\n\t\t\tpkg->error = -msg->ack;\n\t\t\t \n\t\t\tif (pkg->error != -EAGAIN)\n\t\t\t\t*(pkg->data_size) = 0;\n\t\t} else if (tfr->data_size > *(pkg->data_size)) {\n\t\t\tDMERR(\"Insufficient space to receive package [%u] (%u vs %zu)\",\n\t\t\t      tfr->request_type, tfr->data_size, *(pkg->data_size));\n\n\t\t\t*(pkg->data_size) = 0;\n\t\t\tpkg->error = -ENOSPC;\n\t\t} else {\n\t\t\tpkg->error = tfr->error;\n\t\t\tmemcpy(pkg->data, tfr->data, tfr->data_size);\n\t\t\t*(pkg->data_size) = tfr->data_size;\n\t\t}\n\t\tcomplete(&pkg->complete);\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic void cn_ulog_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\n{\n\tstruct dm_ulog_request *tfr = (struct dm_ulog_request *)(msg + 1);\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn;\n\n\tspin_lock(&receiving_list_lock);\n\tif (msg->len == 0)\n\t\tfill_pkg(msg, NULL);\n\telse if (msg->len < sizeof(*tfr))\n\t\tDMERR(\"Incomplete message received (expected %u, got %u): [%u]\",\n\t\t      (unsigned int)sizeof(*tfr), msg->len, msg->seq);\n\telse\n\t\tfill_pkg(NULL, tfr);\n\tspin_unlock(&receiving_list_lock);\n}\n\n \nint dm_consult_userspace(const char *uuid, uint64_t luid, int request_type,\n\t\t\t char *data, size_t data_size,\n\t\t\t char *rdata, size_t *rdata_size)\n{\n\tint r = 0;\n\tunsigned long tmo;\n\tsize_t dummy = 0;\n\tint overhead_size = sizeof(struct dm_ulog_request) + sizeof(struct cn_msg);\n\tstruct dm_ulog_request *tfr = prealloced_ulog_tfr;\n\tstruct receiving_pkg pkg;\n\n\t \n\tif (data_size > (DM_ULOG_PREALLOCED_SIZE - overhead_size)) {\n\t\tDMINFO(\"Size of tfr exceeds preallocated size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rdata_size)\n\t\trdata_size = &dummy;\nresend:\n\t \n\tmutex_lock(&dm_ulog_lock);\n\n\tmemset(tfr, 0, DM_ULOG_PREALLOCED_SIZE - sizeof(struct cn_msg));\n\tmemcpy(tfr->uuid, uuid, DM_UUID_LEN);\n\ttfr->version = DM_ULOG_REQUEST_VERSION;\n\ttfr->luid = luid;\n\ttfr->seq = dm_ulog_seq++;\n\n\t \n\ttfr->request_type = request_type & DM_ULOG_REQUEST_MASK;\n\n\ttfr->data_size = data_size;\n\tif (data && data_size)\n\t\tmemcpy(tfr->data, data, data_size);\n\n\tmemset(&pkg, 0, sizeof(pkg));\n\tinit_completion(&pkg.complete);\n\tpkg.seq = tfr->seq;\n\tpkg.data_size = rdata_size;\n\tpkg.data = rdata;\n\tspin_lock(&receiving_list_lock);\n\tlist_add(&(pkg.list), &receiving_list);\n\tspin_unlock(&receiving_list_lock);\n\n\tr = dm_ulog_sendto_server(tfr);\n\n\tmutex_unlock(&dm_ulog_lock);\n\n\tif (r) {\n\t\tDMERR(\"Unable to send log request [%u] to userspace: %d\",\n\t\t      request_type, r);\n\t\tspin_lock(&receiving_list_lock);\n\t\tlist_del_init(&(pkg.list));\n\t\tspin_unlock(&receiving_list_lock);\n\n\t\tgoto out;\n\t}\n\n\ttmo = wait_for_completion_timeout(&(pkg.complete), DM_ULOG_RETRY_TIMEOUT);\n\tspin_lock(&receiving_list_lock);\n\tlist_del_init(&(pkg.list));\n\tspin_unlock(&receiving_list_lock);\n\tif (!tmo) {\n\t\tDMWARN(\"[%s] Request timed out: [%u/%u] - retrying\",\n\t\t       (strlen(uuid) > 8) ?\n\t\t       (uuid + (strlen(uuid) - 8)) : (uuid),\n\t\t       request_type, pkg.seq);\n\t\tgoto resend;\n\t}\n\n\tr = pkg.error;\n\tif (r == -EAGAIN)\n\t\tgoto resend;\n\nout:\n\treturn r;\n}\n\nint dm_ulog_tfr_init(void)\n{\n\tint r;\n\tvoid *prealloced;\n\n\tINIT_LIST_HEAD(&receiving_list);\n\n\tprealloced = kmalloc(DM_ULOG_PREALLOCED_SIZE, GFP_KERNEL);\n\tif (!prealloced)\n\t\treturn -ENOMEM;\n\n\tprealloced_cn_msg = prealloced;\n\tprealloced_ulog_tfr = prealloced + sizeof(struct cn_msg);\n\n\tr = cn_add_callback(&ulog_cn_id, \"dmlogusr\", cn_ulog_callback);\n\tif (r) {\n\t\tkfree(prealloced_cn_msg);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nvoid dm_ulog_tfr_exit(void)\n{\n\tcn_del_callback(&ulog_cn_id);\n\tkfree(prealloced_cn_msg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}