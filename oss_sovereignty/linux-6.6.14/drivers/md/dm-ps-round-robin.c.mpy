{
  "module_name": "dm-ps-round-robin.c",
  "hash_id": "eb737a2b0d0e424abe322b87ce6f26a5495eb0ffcfe24706018a8f812f43a354",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-ps-round-robin.c",
  "human_readable_source": "\n \n\n#include <linux/device-mapper.h>\n\n#include \"dm-path-selector.h\"\n\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define DM_MSG_PREFIX \"multipath round-robin\"\n#define RR_MIN_IO     1\n#define RR_VERSION    \"1.2.0\"\n\n \nstruct path_info {\n\tstruct list_head list;\n\tstruct dm_path *path;\n\tunsigned int repeat_count;\n};\n\nstatic void free_paths(struct list_head *paths)\n{\n\tstruct path_info *pi, *next;\n\n\tlist_for_each_entry_safe(pi, next, paths, list) {\n\t\tlist_del(&pi->list);\n\t\tkfree(pi);\n\t}\n}\n\n \nstruct selector {\n\tstruct list_head valid_paths;\n\tstruct list_head invalid_paths;\n\tspinlock_t lock;\n};\n\nstatic struct selector *alloc_selector(void)\n{\n\tstruct selector *s = kmalloc(sizeof(*s), GFP_KERNEL);\n\n\tif (s) {\n\t\tINIT_LIST_HEAD(&s->valid_paths);\n\t\tINIT_LIST_HEAD(&s->invalid_paths);\n\t\tspin_lock_init(&s->lock);\n\t}\n\n\treturn s;\n}\n\nstatic int rr_create(struct path_selector *ps, unsigned int argc, char **argv)\n{\n\tstruct selector *s;\n\n\ts = alloc_selector();\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tps->context = s;\n\treturn 0;\n}\n\nstatic void rr_destroy(struct path_selector *ps)\n{\n\tstruct selector *s = ps->context;\n\n\tfree_paths(&s->valid_paths);\n\tfree_paths(&s->invalid_paths);\n\tkfree(s);\n\tps->context = NULL;\n}\n\nstatic int rr_status(struct path_selector *ps, struct dm_path *path,\n\t\t     status_type_t type, char *result, unsigned int maxlen)\n{\n\tstruct path_info *pi;\n\tint sz = 0;\n\n\tif (!path)\n\t\tDMEMIT(\"0 \");\n\telse {\n\t\tswitch (type) {\n\t\tcase STATUSTYPE_INFO:\n\t\t\tbreak;\n\t\tcase STATUSTYPE_TABLE:\n\t\t\tpi = path->pscontext;\n\t\t\tDMEMIT(\"%u \", pi->repeat_count);\n\t\t\tbreak;\n\n\t\tcase STATUSTYPE_IMA:\n\t\t\t*result = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sz;\n}\n\n \nstatic int rr_add_path(struct path_selector *ps, struct dm_path *path,\n\t\t       int argc, char **argv, char **error)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi;\n\tunsigned int repeat_count = RR_MIN_IO;\n\tchar dummy;\n\tunsigned long flags;\n\n\tif (argc > 1) {\n\t\t*error = \"round-robin ps: incorrect number of arguments\";\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((argc == 1) && (sscanf(argv[0], \"%u%c\", &repeat_count, &dummy) != 1)) {\n\t\t*error = \"round-robin ps: invalid repeat count\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (repeat_count > 1) {\n\t\tDMWARN_LIMIT(\"repeat_count > 1 is deprecated, using 1 instead\");\n\t\trepeat_count = 1;\n\t}\n\n\t \n\tpi = kmalloc(sizeof(*pi), GFP_KERNEL);\n\tif (!pi) {\n\t\t*error = \"round-robin ps: Error allocating path context\";\n\t\treturn -ENOMEM;\n\t}\n\n\tpi->path = path;\n\tpi->repeat_count = repeat_count;\n\n\tpath->pscontext = pi;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tlist_add_tail(&pi->list, &s->valid_paths);\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn 0;\n}\n\nstatic void rr_fail_path(struct path_selector *ps, struct dm_path *p)\n{\n\tunsigned long flags;\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = p->pscontext;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tlist_move(&pi->list, &s->invalid_paths);\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nstatic int rr_reinstate_path(struct path_selector *ps, struct dm_path *p)\n{\n\tunsigned long flags;\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = p->pscontext;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tlist_move(&pi->list, &s->valid_paths);\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct dm_path *rr_select_path(struct path_selector *ps, size_t nr_bytes)\n{\n\tunsigned long flags;\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = NULL;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tif (!list_empty(&s->valid_paths)) {\n\t\tpi = list_entry(s->valid_paths.next, struct path_info, list);\n\t\tlist_move_tail(&pi->list, &s->valid_paths);\n\t}\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn pi ? pi->path : NULL;\n}\n\nstatic struct path_selector_type rr_ps = {\n\t.name = \"round-robin\",\n\t.module = THIS_MODULE,\n\t.table_args = 1,\n\t.info_args = 0,\n\t.create = rr_create,\n\t.destroy = rr_destroy,\n\t.status = rr_status,\n\t.add_path = rr_add_path,\n\t.fail_path = rr_fail_path,\n\t.reinstate_path = rr_reinstate_path,\n\t.select_path = rr_select_path,\n};\n\nstatic int __init dm_rr_init(void)\n{\n\tint r = dm_register_path_selector(&rr_ps);\n\n\tif (r < 0)\n\t\tDMERR(\"register failed %d\", r);\n\n\tDMINFO(\"version \" RR_VERSION \" loaded\");\n\n\treturn r;\n}\n\nstatic void __exit dm_rr_exit(void)\n{\n\tint r = dm_unregister_path_selector(&rr_ps);\n\n\tif (r < 0)\n\t\tDMERR(\"unregister failed %d\", r);\n}\n\nmodule_init(dm_rr_init);\nmodule_exit(dm_rr_exit);\n\nMODULE_DESCRIPTION(DM_NAME \" round-robin multipath path selector\");\nMODULE_AUTHOR(\"Sistina Software <dm-devel@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}