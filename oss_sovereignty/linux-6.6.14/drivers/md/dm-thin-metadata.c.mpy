{
  "module_name": "dm-thin-metadata.c",
  "hash_id": "548eb33e59f457fc0f9fcb2322013ab7b1021a5bafd1c8718033968bbc6eb313",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-thin-metadata.c",
  "human_readable_source": "\n \n\n#include \"dm-thin-metadata.h\"\n#include \"persistent-data/dm-btree.h\"\n#include \"persistent-data/dm-space-map.h\"\n#include \"persistent-data/dm-space-map-disk.h\"\n#include \"persistent-data/dm-transaction-manager.h\"\n\n#include <linux/list.h>\n#include <linux/device-mapper.h>\n#include <linux/workqueue.h>\n\n \n\n#define DM_MSG_PREFIX   \"thin metadata\"\n\n#define THIN_SUPERBLOCK_MAGIC 27022010\n#define THIN_SUPERBLOCK_LOCATION 0\n#define THIN_VERSION 2\n#define SECTOR_TO_BLOCK_SHIFT 3\n\n \n#define THIN_MAX_CONCURRENT_LOCKS 6\n\n \n#define SPACE_MAP_ROOT_SIZE 128\n\n \nstruct thin_disk_superblock {\n\t__le32 csum;\t \n\t__le32 flags;\n\t__le64 blocknr;\t \n\n\t__u8 uuid[16];\n\t__le64 magic;\n\t__le32 version;\n\t__le32 time;\n\n\t__le64 trans_id;\n\n\t \n\t__le64 held_root;\n\n\t__u8 data_space_map_root[SPACE_MAP_ROOT_SIZE];\n\t__u8 metadata_space_map_root[SPACE_MAP_ROOT_SIZE];\n\n\t \n\t__le64 data_mapping_root;\n\n\t \n\t__le64 device_details_root;\n\n\t__le32 data_block_size;\t\t \n\n\t__le32 metadata_block_size;\t \n\t__le64 metadata_nr_blocks;\n\n\t__le32 compat_flags;\n\t__le32 compat_ro_flags;\n\t__le32 incompat_flags;\n} __packed;\n\nstruct disk_device_details {\n\t__le64 mapped_blocks;\n\t__le64 transaction_id;\t\t \n\t__le32 creation_time;\n\t__le32 snapshotted_time;\n} __packed;\n\nstruct dm_pool_metadata {\n\tstruct hlist_node hash;\n\n\tstruct block_device *bdev;\n\tstruct dm_block_manager *bm;\n\tstruct dm_space_map *metadata_sm;\n\tstruct dm_space_map *data_sm;\n\tstruct dm_transaction_manager *tm;\n\tstruct dm_transaction_manager *nb_tm;\n\n\t \n\tstruct dm_btree_info info;\n\n\t \n\tstruct dm_btree_info nb_info;\n\n\t \n\tstruct dm_btree_info tl_info;\n\n\t \n\tstruct dm_btree_info bl_info;\n\n\t \n\tstruct dm_btree_info details_info;\n\n\tstruct rw_semaphore root_lock;\n\tuint32_t time;\n\tdm_block_t root;\n\tdm_block_t details_root;\n\tstruct list_head thin_devices;\n\tuint64_t trans_id;\n\tunsigned long flags;\n\tsector_t data_block_size;\n\n\t \n\tdm_pool_pre_commit_fn pre_commit_fn;\n\tvoid *pre_commit_context;\n\n\t \n\tdm_block_t metadata_reserve;\n\n\t \n\tbool fail_io:1;\n\n\t \n\tbool in_service:1;\n\n\t \n\t__u8 data_space_map_root[SPACE_MAP_ROOT_SIZE];\n\t__u8 metadata_space_map_root[SPACE_MAP_ROOT_SIZE];\n};\n\nstruct dm_thin_device {\n\tstruct list_head list;\n\tstruct dm_pool_metadata *pmd;\n\tdm_thin_id id;\n\n\tint open_count;\n\tbool changed:1;\n\tbool aborted_with_changes:1;\n\tuint64_t mapped_blocks;\n\tuint64_t transaction_id;\n\tuint32_t creation_time;\n\tuint32_t snapshotted_time;\n};\n\n \n#define SUPERBLOCK_CSUM_XOR 160774\n\nstatic void sb_prepare_for_write(struct dm_block_validator *v,\n\t\t\t\t struct dm_block *b,\n\t\t\t\t size_t block_size)\n{\n\tstruct thin_disk_superblock *disk_super = dm_block_data(b);\n\n\tdisk_super->blocknr = cpu_to_le64(dm_block_location(b));\n\tdisk_super->csum = cpu_to_le32(dm_bm_checksum(&disk_super->flags,\n\t\t\t\t\t\t      block_size - sizeof(__le32),\n\t\t\t\t\t\t      SUPERBLOCK_CSUM_XOR));\n}\n\nstatic int sb_check(struct dm_block_validator *v,\n\t\t    struct dm_block *b,\n\t\t    size_t block_size)\n{\n\tstruct thin_disk_superblock *disk_super = dm_block_data(b);\n\t__le32 csum_le;\n\n\tif (dm_block_location(b) != le64_to_cpu(disk_super->blocknr)) {\n\t\tDMERR(\"%s failed: blocknr %llu: wanted %llu\",\n\t\t      __func__, le64_to_cpu(disk_super->blocknr),\n\t\t      (unsigned long long)dm_block_location(b));\n\t\treturn -ENOTBLK;\n\t}\n\n\tif (le64_to_cpu(disk_super->magic) != THIN_SUPERBLOCK_MAGIC) {\n\t\tDMERR(\"%s failed: magic %llu: wanted %llu\",\n\t\t      __func__, le64_to_cpu(disk_super->magic),\n\t\t      (unsigned long long)THIN_SUPERBLOCK_MAGIC);\n\t\treturn -EILSEQ;\n\t}\n\n\tcsum_le = cpu_to_le32(dm_bm_checksum(&disk_super->flags,\n\t\t\t\t\t     block_size - sizeof(__le32),\n\t\t\t\t\t     SUPERBLOCK_CSUM_XOR));\n\tif (csum_le != disk_super->csum) {\n\t\tDMERR(\"%s failed: csum %u: wanted %u\",\n\t\t      __func__, le32_to_cpu(csum_le), le32_to_cpu(disk_super->csum));\n\t\treturn -EILSEQ;\n\t}\n\n\treturn 0;\n}\n\nstatic struct dm_block_validator sb_validator = {\n\t.name = \"superblock\",\n\t.prepare_for_write = sb_prepare_for_write,\n\t.check = sb_check\n};\n\n \nstatic uint64_t pack_block_time(dm_block_t b, uint32_t t)\n{\n\treturn (b << 24) | t;\n}\n\nstatic void unpack_block_time(uint64_t v, dm_block_t *b, uint32_t *t)\n{\n\t*b = v >> 24;\n\t*t = v & ((1 << 24) - 1);\n}\n\n \ntypedef int (*run_fn)(struct dm_space_map *, dm_block_t, dm_block_t);\n\nstatic void with_runs(struct dm_space_map *sm, const __le64 *value_le, unsigned int count, run_fn fn)\n{\n\tuint64_t b, begin, end;\n\tuint32_t t;\n\tbool in_run = false;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++, value_le++) {\n\t\t \n\t\tunpack_block_time(le64_to_cpu(*value_le), &b, &t);\n\n\t\tif (in_run) {\n\t\t\tif (b == end) {\n\t\t\t\tend++;\n\t\t\t} else {\n\t\t\t\tfn(sm, begin, end);\n\t\t\t\tbegin = b;\n\t\t\t\tend = b + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tin_run = true;\n\t\t\tbegin = b;\n\t\t\tend = b + 1;\n\t\t}\n\t}\n\n\tif (in_run)\n\t\tfn(sm, begin, end);\n}\n\nstatic void data_block_inc(void *context, const void *value_le, unsigned int count)\n{\n\twith_runs((struct dm_space_map *) context,\n\t\t  (const __le64 *) value_le, count, dm_sm_inc_blocks);\n}\n\nstatic void data_block_dec(void *context, const void *value_le, unsigned int count)\n{\n\twith_runs((struct dm_space_map *) context,\n\t\t  (const __le64 *) value_le, count, dm_sm_dec_blocks);\n}\n\nstatic int data_block_equal(void *context, const void *value1_le, const void *value2_le)\n{\n\t__le64 v1_le, v2_le;\n\tuint64_t b1, b2;\n\tuint32_t t;\n\n\tmemcpy(&v1_le, value1_le, sizeof(v1_le));\n\tmemcpy(&v2_le, value2_le, sizeof(v2_le));\n\tunpack_block_time(le64_to_cpu(v1_le), &b1, &t);\n\tunpack_block_time(le64_to_cpu(v2_le), &b2, &t);\n\n\treturn b1 == b2;\n}\n\nstatic void subtree_inc(void *context, const void *value, unsigned int count)\n{\n\tstruct dm_btree_info *info = context;\n\tconst __le64 *root_le = value;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++, root_le++)\n\t\tdm_tm_inc(info->tm, le64_to_cpu(*root_le));\n}\n\nstatic void subtree_dec(void *context, const void *value, unsigned int count)\n{\n\tstruct dm_btree_info *info = context;\n\tconst __le64 *root_le = value;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++, root_le++)\n\t\tif (dm_btree_del(info, le64_to_cpu(*root_le)))\n\t\t\tDMERR(\"btree delete failed\");\n}\n\nstatic int subtree_equal(void *context, const void *value1_le, const void *value2_le)\n{\n\t__le64 v1_le, v2_le;\n\n\tmemcpy(&v1_le, value1_le, sizeof(v1_le));\n\tmemcpy(&v2_le, value2_le, sizeof(v2_le));\n\n\treturn v1_le == v2_le;\n}\n\n \n\n \nstatic inline void pmd_write_lock_in_core(struct dm_pool_metadata *pmd)\n\t__acquires(pmd->root_lock)\n{\n\tdown_write(&pmd->root_lock);\n}\n\nstatic inline void pmd_write_lock(struct dm_pool_metadata *pmd)\n{\n\tpmd_write_lock_in_core(pmd);\n\tif (unlikely(!pmd->in_service))\n\t\tpmd->in_service = true;\n}\n\nstatic inline void pmd_write_unlock(struct dm_pool_metadata *pmd)\n\t__releases(pmd->root_lock)\n{\n\tup_write(&pmd->root_lock);\n}\n\n \n\nstatic int superblock_lock_zero(struct dm_pool_metadata *pmd,\n\t\t\t\tstruct dm_block **sblock)\n{\n\treturn dm_bm_write_lock_zero(pmd->bm, THIN_SUPERBLOCK_LOCATION,\n\t\t\t\t     &sb_validator, sblock);\n}\n\nstatic int superblock_lock(struct dm_pool_metadata *pmd,\n\t\t\t   struct dm_block **sblock)\n{\n\treturn dm_bm_write_lock(pmd->bm, THIN_SUPERBLOCK_LOCATION,\n\t\t\t\t&sb_validator, sblock);\n}\n\nstatic int __superblock_all_zeroes(struct dm_block_manager *bm, int *result)\n{\n\tint r;\n\tunsigned int i;\n\tstruct dm_block *b;\n\t__le64 *data_le, zero = cpu_to_le64(0);\n\tunsigned int block_size = dm_bm_block_size(bm) / sizeof(__le64);\n\n\t \n\tr = dm_bm_read_lock(bm, THIN_SUPERBLOCK_LOCATION, NULL, &b);\n\tif (r)\n\t\treturn r;\n\n\tdata_le = dm_block_data(b);\n\t*result = 1;\n\tfor (i = 0; i < block_size; i++) {\n\t\tif (data_le[i] != zero) {\n\t\t\t*result = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdm_bm_unlock(b);\n\n\treturn 0;\n}\n\nstatic void __setup_btree_details(struct dm_pool_metadata *pmd)\n{\n\tpmd->info.tm = pmd->tm;\n\tpmd->info.levels = 2;\n\tpmd->info.value_type.context = pmd->data_sm;\n\tpmd->info.value_type.size = sizeof(__le64);\n\tpmd->info.value_type.inc = data_block_inc;\n\tpmd->info.value_type.dec = data_block_dec;\n\tpmd->info.value_type.equal = data_block_equal;\n\n\tmemcpy(&pmd->nb_info, &pmd->info, sizeof(pmd->nb_info));\n\tpmd->nb_info.tm = pmd->nb_tm;\n\n\tpmd->tl_info.tm = pmd->tm;\n\tpmd->tl_info.levels = 1;\n\tpmd->tl_info.value_type.context = &pmd->bl_info;\n\tpmd->tl_info.value_type.size = sizeof(__le64);\n\tpmd->tl_info.value_type.inc = subtree_inc;\n\tpmd->tl_info.value_type.dec = subtree_dec;\n\tpmd->tl_info.value_type.equal = subtree_equal;\n\n\tpmd->bl_info.tm = pmd->tm;\n\tpmd->bl_info.levels = 1;\n\tpmd->bl_info.value_type.context = pmd->data_sm;\n\tpmd->bl_info.value_type.size = sizeof(__le64);\n\tpmd->bl_info.value_type.inc = data_block_inc;\n\tpmd->bl_info.value_type.dec = data_block_dec;\n\tpmd->bl_info.value_type.equal = data_block_equal;\n\n\tpmd->details_info.tm = pmd->tm;\n\tpmd->details_info.levels = 1;\n\tpmd->details_info.value_type.context = NULL;\n\tpmd->details_info.value_type.size = sizeof(struct disk_device_details);\n\tpmd->details_info.value_type.inc = NULL;\n\tpmd->details_info.value_type.dec = NULL;\n\tpmd->details_info.value_type.equal = NULL;\n}\n\nstatic int save_sm_roots(struct dm_pool_metadata *pmd)\n{\n\tint r;\n\tsize_t len;\n\n\tr = dm_sm_root_size(pmd->metadata_sm, &len);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_sm_copy_root(pmd->metadata_sm, &pmd->metadata_space_map_root, len);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_sm_root_size(pmd->data_sm, &len);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn dm_sm_copy_root(pmd->data_sm, &pmd->data_space_map_root, len);\n}\n\nstatic void copy_sm_roots(struct dm_pool_metadata *pmd,\n\t\t\t  struct thin_disk_superblock *disk)\n{\n\tmemcpy(&disk->metadata_space_map_root,\n\t       &pmd->metadata_space_map_root,\n\t       sizeof(pmd->metadata_space_map_root));\n\n\tmemcpy(&disk->data_space_map_root,\n\t       &pmd->data_space_map_root,\n\t       sizeof(pmd->data_space_map_root));\n}\n\nstatic int __write_initial_superblock(struct dm_pool_metadata *pmd)\n{\n\tint r;\n\tstruct dm_block *sblock;\n\tstruct thin_disk_superblock *disk_super;\n\tsector_t bdev_size = bdev_nr_sectors(pmd->bdev);\n\n\tif (bdev_size > THIN_METADATA_MAX_SECTORS)\n\t\tbdev_size = THIN_METADATA_MAX_SECTORS;\n\n\tr = dm_sm_commit(pmd->data_sm);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_tm_pre_commit(pmd->tm);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = save_sm_roots(pmd);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = superblock_lock_zero(pmd, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n\tdisk_super->flags = 0;\n\tmemset(disk_super->uuid, 0, sizeof(disk_super->uuid));\n\tdisk_super->magic = cpu_to_le64(THIN_SUPERBLOCK_MAGIC);\n\tdisk_super->version = cpu_to_le32(THIN_VERSION);\n\tdisk_super->time = 0;\n\tdisk_super->trans_id = 0;\n\tdisk_super->held_root = 0;\n\n\tcopy_sm_roots(pmd, disk_super);\n\n\tdisk_super->data_mapping_root = cpu_to_le64(pmd->root);\n\tdisk_super->device_details_root = cpu_to_le64(pmd->details_root);\n\tdisk_super->metadata_block_size = cpu_to_le32(THIN_METADATA_BLOCK_SIZE);\n\tdisk_super->metadata_nr_blocks = cpu_to_le64(bdev_size >> SECTOR_TO_BLOCK_SHIFT);\n\tdisk_super->data_block_size = cpu_to_le32(pmd->data_block_size);\n\n\treturn dm_tm_commit(pmd->tm, sblock);\n}\n\nstatic int __format_metadata(struct dm_pool_metadata *pmd)\n{\n\tint r;\n\n\tr = dm_tm_create_with_sm(pmd->bm, THIN_SUPERBLOCK_LOCATION,\n\t\t\t\t &pmd->tm, &pmd->metadata_sm);\n\tif (r < 0) {\n\t\tpmd->tm = NULL;\n\t\tpmd->metadata_sm = NULL;\n\t\tDMERR(\"tm_create_with_sm failed\");\n\t\treturn r;\n\t}\n\n\tpmd->data_sm = dm_sm_disk_create(pmd->tm, 0);\n\tif (IS_ERR(pmd->data_sm)) {\n\t\tDMERR(\"sm_disk_create failed\");\n\t\tr = PTR_ERR(pmd->data_sm);\n\t\tpmd->data_sm = NULL;\n\t\tgoto bad_cleanup_tm;\n\t}\n\n\tpmd->nb_tm = dm_tm_create_non_blocking_clone(pmd->tm);\n\tif (!pmd->nb_tm) {\n\t\tDMERR(\"could not create non-blocking clone tm\");\n\t\tr = -ENOMEM;\n\t\tgoto bad_cleanup_data_sm;\n\t}\n\n\t__setup_btree_details(pmd);\n\n\tr = dm_btree_empty(&pmd->info, &pmd->root);\n\tif (r < 0)\n\t\tgoto bad_cleanup_nb_tm;\n\n\tr = dm_btree_empty(&pmd->details_info, &pmd->details_root);\n\tif (r < 0) {\n\t\tDMERR(\"couldn't create devices root\");\n\t\tgoto bad_cleanup_nb_tm;\n\t}\n\n\tr = __write_initial_superblock(pmd);\n\tif (r)\n\t\tgoto bad_cleanup_nb_tm;\n\n\treturn 0;\n\nbad_cleanup_nb_tm:\n\tdm_tm_destroy(pmd->nb_tm);\n\tpmd->nb_tm = NULL;\nbad_cleanup_data_sm:\n\tdm_sm_destroy(pmd->data_sm);\n\tpmd->data_sm = NULL;\nbad_cleanup_tm:\n\tdm_tm_destroy(pmd->tm);\n\tpmd->tm = NULL;\n\tdm_sm_destroy(pmd->metadata_sm);\n\tpmd->metadata_sm = NULL;\n\n\treturn r;\n}\n\nstatic int __check_incompat_features(struct thin_disk_superblock *disk_super,\n\t\t\t\t     struct dm_pool_metadata *pmd)\n{\n\tuint32_t features;\n\n\tfeatures = le32_to_cpu(disk_super->incompat_flags) & ~THIN_FEATURE_INCOMPAT_SUPP;\n\tif (features) {\n\t\tDMERR(\"could not access metadata due to unsupported optional features (%lx).\",\n\t\t      (unsigned long)features);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (bdev_read_only(pmd->bdev))\n\t\treturn 0;\n\n\tfeatures = le32_to_cpu(disk_super->compat_ro_flags) & ~THIN_FEATURE_COMPAT_RO_SUPP;\n\tif (features) {\n\t\tDMERR(\"could not access metadata RDWR due to unsupported optional features (%lx).\",\n\t\t      (unsigned long)features);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __open_metadata(struct dm_pool_metadata *pmd)\n{\n\tint r;\n\tstruct dm_block *sblock;\n\tstruct thin_disk_superblock *disk_super;\n\n\tr = dm_bm_read_lock(pmd->bm, THIN_SUPERBLOCK_LOCATION,\n\t\t\t    &sb_validator, &sblock);\n\tif (r < 0) {\n\t\tDMERR(\"couldn't read superblock\");\n\t\treturn r;\n\t}\n\n\tdisk_super = dm_block_data(sblock);\n\n\t \n\tif (le32_to_cpu(disk_super->data_block_size) != pmd->data_block_size) {\n\t\tDMERR(\"changing the data block size (from %u to %llu) is not supported\",\n\t\t      le32_to_cpu(disk_super->data_block_size),\n\t\t      (unsigned long long)pmd->data_block_size);\n\t\tr = -EINVAL;\n\t\tgoto bad_unlock_sblock;\n\t}\n\n\tr = __check_incompat_features(disk_super, pmd);\n\tif (r < 0)\n\t\tgoto bad_unlock_sblock;\n\n\tr = dm_tm_open_with_sm(pmd->bm, THIN_SUPERBLOCK_LOCATION,\n\t\t\t       disk_super->metadata_space_map_root,\n\t\t\t       sizeof(disk_super->metadata_space_map_root),\n\t\t\t       &pmd->tm, &pmd->metadata_sm);\n\tif (r < 0) {\n\t\tpmd->tm = NULL;\n\t\tpmd->metadata_sm = NULL;\n\t\tDMERR(\"tm_open_with_sm failed\");\n\t\tgoto bad_unlock_sblock;\n\t}\n\n\tpmd->data_sm = dm_sm_disk_open(pmd->tm, disk_super->data_space_map_root,\n\t\t\t\t       sizeof(disk_super->data_space_map_root));\n\tif (IS_ERR(pmd->data_sm)) {\n\t\tDMERR(\"sm_disk_open failed\");\n\t\tr = PTR_ERR(pmd->data_sm);\n\t\tpmd->data_sm = NULL;\n\t\tgoto bad_cleanup_tm;\n\t}\n\n\tpmd->nb_tm = dm_tm_create_non_blocking_clone(pmd->tm);\n\tif (!pmd->nb_tm) {\n\t\tDMERR(\"could not create non-blocking clone tm\");\n\t\tr = -ENOMEM;\n\t\tgoto bad_cleanup_data_sm;\n\t}\n\n\t \n\tpmd->root = le64_to_cpu(disk_super->data_mapping_root);\n\tpmd->details_root = le64_to_cpu(disk_super->device_details_root);\n\n\t__setup_btree_details(pmd);\n\tdm_bm_unlock(sblock);\n\n\treturn 0;\n\nbad_cleanup_data_sm:\n\tdm_sm_destroy(pmd->data_sm);\n\tpmd->data_sm = NULL;\nbad_cleanup_tm:\n\tdm_tm_destroy(pmd->tm);\n\tpmd->tm = NULL;\n\tdm_sm_destroy(pmd->metadata_sm);\n\tpmd->metadata_sm = NULL;\nbad_unlock_sblock:\n\tdm_bm_unlock(sblock);\n\n\treturn r;\n}\n\nstatic int __open_or_format_metadata(struct dm_pool_metadata *pmd, bool format_device)\n{\n\tint r, unformatted;\n\n\tr = __superblock_all_zeroes(pmd->bm, &unformatted);\n\tif (r)\n\t\treturn r;\n\n\tif (unformatted)\n\t\treturn format_device ? __format_metadata(pmd) : -EPERM;\n\n\treturn __open_metadata(pmd);\n}\n\nstatic int __create_persistent_data_objects(struct dm_pool_metadata *pmd, bool format_device)\n{\n\tint r;\n\n\tpmd->bm = dm_block_manager_create(pmd->bdev, THIN_METADATA_BLOCK_SIZE << SECTOR_SHIFT,\n\t\t\t\t\t  THIN_MAX_CONCURRENT_LOCKS);\n\tif (IS_ERR(pmd->bm)) {\n\t\tDMERR(\"could not create block manager\");\n\t\tr = PTR_ERR(pmd->bm);\n\t\tpmd->bm = NULL;\n\t\treturn r;\n\t}\n\n\tr = __open_or_format_metadata(pmd, format_device);\n\tif (r) {\n\t\tdm_block_manager_destroy(pmd->bm);\n\t\tpmd->bm = NULL;\n\t}\n\n\treturn r;\n}\n\nstatic void __destroy_persistent_data_objects(struct dm_pool_metadata *pmd,\n\t\t\t\t\t      bool destroy_bm)\n{\n\tdm_sm_destroy(pmd->data_sm);\n\tpmd->data_sm = NULL;\n\tdm_sm_destroy(pmd->metadata_sm);\n\tpmd->metadata_sm = NULL;\n\tdm_tm_destroy(pmd->nb_tm);\n\tpmd->nb_tm = NULL;\n\tdm_tm_destroy(pmd->tm);\n\tpmd->tm = NULL;\n\tif (destroy_bm)\n\t\tdm_block_manager_destroy(pmd->bm);\n}\n\nstatic int __begin_transaction(struct dm_pool_metadata *pmd)\n{\n\tint r;\n\tstruct thin_disk_superblock *disk_super;\n\tstruct dm_block *sblock;\n\n\t \n\tr = dm_bm_read_lock(pmd->bm, THIN_SUPERBLOCK_LOCATION,\n\t\t\t    &sb_validator, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n\tpmd->time = le32_to_cpu(disk_super->time);\n\tpmd->root = le64_to_cpu(disk_super->data_mapping_root);\n\tpmd->details_root = le64_to_cpu(disk_super->device_details_root);\n\tpmd->trans_id = le64_to_cpu(disk_super->trans_id);\n\tpmd->flags = le32_to_cpu(disk_super->flags);\n\tpmd->data_block_size = le32_to_cpu(disk_super->data_block_size);\n\n\tdm_bm_unlock(sblock);\n\treturn 0;\n}\n\nstatic int __write_changed_details(struct dm_pool_metadata *pmd)\n{\n\tint r;\n\tstruct dm_thin_device *td, *tmp;\n\tstruct disk_device_details details;\n\tuint64_t key;\n\n\tlist_for_each_entry_safe(td, tmp, &pmd->thin_devices, list) {\n\t\tif (!td->changed)\n\t\t\tcontinue;\n\n\t\tkey = td->id;\n\n\t\tdetails.mapped_blocks = cpu_to_le64(td->mapped_blocks);\n\t\tdetails.transaction_id = cpu_to_le64(td->transaction_id);\n\t\tdetails.creation_time = cpu_to_le32(td->creation_time);\n\t\tdetails.snapshotted_time = cpu_to_le32(td->snapshotted_time);\n\t\t__dm_bless_for_disk(&details);\n\n\t\tr = dm_btree_insert(&pmd->details_info, pmd->details_root,\n\t\t\t\t    &key, &details, &pmd->details_root);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tif (td->open_count)\n\t\t\ttd->changed = false;\n\t\telse {\n\t\t\tlist_del(&td->list);\n\t\t\tkfree(td);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __commit_transaction(struct dm_pool_metadata *pmd)\n{\n\tint r;\n\tstruct thin_disk_superblock *disk_super;\n\tstruct dm_block *sblock;\n\n\t \n\tBUILD_BUG_ON(sizeof(struct thin_disk_superblock) > 512);\n\tBUG_ON(!rwsem_is_locked(&pmd->root_lock));\n\n\tif (unlikely(!pmd->in_service))\n\t\treturn 0;\n\n\tif (pmd->pre_commit_fn) {\n\t\tr = pmd->pre_commit_fn(pmd->pre_commit_context);\n\t\tif (r < 0) {\n\t\t\tDMERR(\"pre-commit callback failed\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = __write_changed_details(pmd);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_sm_commit(pmd->data_sm);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_tm_pre_commit(pmd->tm);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = save_sm_roots(pmd);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = superblock_lock(pmd, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n\tdisk_super->time = cpu_to_le32(pmd->time);\n\tdisk_super->data_mapping_root = cpu_to_le64(pmd->root);\n\tdisk_super->device_details_root = cpu_to_le64(pmd->details_root);\n\tdisk_super->trans_id = cpu_to_le64(pmd->trans_id);\n\tdisk_super->flags = cpu_to_le32(pmd->flags);\n\n\tcopy_sm_roots(pmd, disk_super);\n\n\treturn dm_tm_commit(pmd->tm, sblock);\n}\n\nstatic void __set_metadata_reserve(struct dm_pool_metadata *pmd)\n{\n\tint r;\n\tdm_block_t total;\n\tdm_block_t max_blocks = 4096;  \n\n\tr = dm_sm_get_nr_blocks(pmd->metadata_sm, &total);\n\tif (r) {\n\t\tDMERR(\"could not get size of metadata device\");\n\t\tpmd->metadata_reserve = max_blocks;\n\t} else\n\t\tpmd->metadata_reserve = min(max_blocks, div_u64(total, 10));\n}\n\nstruct dm_pool_metadata *dm_pool_metadata_open(struct block_device *bdev,\n\t\t\t\t\t       sector_t data_block_size,\n\t\t\t\t\t       bool format_device)\n{\n\tint r;\n\tstruct dm_pool_metadata *pmd;\n\n\tpmd = kmalloc(sizeof(*pmd), GFP_KERNEL);\n\tif (!pmd) {\n\t\tDMERR(\"could not allocate metadata struct\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinit_rwsem(&pmd->root_lock);\n\tpmd->time = 0;\n\tINIT_LIST_HEAD(&pmd->thin_devices);\n\tpmd->fail_io = false;\n\tpmd->in_service = false;\n\tpmd->bdev = bdev;\n\tpmd->data_block_size = data_block_size;\n\tpmd->pre_commit_fn = NULL;\n\tpmd->pre_commit_context = NULL;\n\n\tr = __create_persistent_data_objects(pmd, format_device);\n\tif (r) {\n\t\tkfree(pmd);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tr = __begin_transaction(pmd);\n\tif (r < 0) {\n\t\tif (dm_pool_metadata_close(pmd) < 0)\n\t\t\tDMWARN(\"%s: dm_pool_metadata_close() failed.\", __func__);\n\t\treturn ERR_PTR(r);\n\t}\n\n\t__set_metadata_reserve(pmd);\n\n\treturn pmd;\n}\n\nint dm_pool_metadata_close(struct dm_pool_metadata *pmd)\n{\n\tint r;\n\tunsigned int open_devices = 0;\n\tstruct dm_thin_device *td, *tmp;\n\n\tdown_read(&pmd->root_lock);\n\tlist_for_each_entry_safe(td, tmp, &pmd->thin_devices, list) {\n\t\tif (td->open_count)\n\t\t\topen_devices++;\n\t\telse {\n\t\t\tlist_del(&td->list);\n\t\t\tkfree(td);\n\t\t}\n\t}\n\tup_read(&pmd->root_lock);\n\n\tif (open_devices) {\n\t\tDMERR(\"attempt to close pmd when %u device(s) are still open\",\n\t\t       open_devices);\n\t\treturn -EBUSY;\n\t}\n\n\tpmd_write_lock_in_core(pmd);\n\tif (!pmd->fail_io && !dm_bm_is_read_only(pmd->bm)) {\n\t\tr = __commit_transaction(pmd);\n\t\tif (r < 0)\n\t\t\tDMWARN(\"%s: __commit_transaction() failed, error = %d\",\n\t\t\t       __func__, r);\n\t}\n\tpmd_write_unlock(pmd);\n\t__destroy_persistent_data_objects(pmd, true);\n\n\tkfree(pmd);\n\treturn 0;\n}\n\n \nstatic int __open_device(struct dm_pool_metadata *pmd,\n\t\t\t dm_thin_id dev, int create,\n\t\t\t struct dm_thin_device **td)\n{\n\tint r, changed = 0;\n\tstruct dm_thin_device *td2;\n\tuint64_t key = dev;\n\tstruct disk_device_details details_le;\n\n\t \n\tlist_for_each_entry(td2, &pmd->thin_devices, list)\n\t\tif (td2->id == dev) {\n\t\t\t \n\t\t\tif (create)\n\t\t\t\treturn -EEXIST;\n\n\t\t\ttd2->open_count++;\n\t\t\t*td = td2;\n\t\t\treturn 0;\n\t\t}\n\n\t \n\tr = dm_btree_lookup(&pmd->details_info, pmd->details_root,\n\t\t\t    &key, &details_le);\n\tif (r) {\n\t\tif (r != -ENODATA || !create)\n\t\t\treturn r;\n\n\t\t \n\t\tchanged = 1;\n\t\tdetails_le.mapped_blocks = 0;\n\t\tdetails_le.transaction_id = cpu_to_le64(pmd->trans_id);\n\t\tdetails_le.creation_time = cpu_to_le32(pmd->time);\n\t\tdetails_le.snapshotted_time = cpu_to_le32(pmd->time);\n\t}\n\n\t*td = kmalloc(sizeof(**td), GFP_NOIO);\n\tif (!*td)\n\t\treturn -ENOMEM;\n\n\t(*td)->pmd = pmd;\n\t(*td)->id = dev;\n\t(*td)->open_count = 1;\n\t(*td)->changed = changed;\n\t(*td)->aborted_with_changes = false;\n\t(*td)->mapped_blocks = le64_to_cpu(details_le.mapped_blocks);\n\t(*td)->transaction_id = le64_to_cpu(details_le.transaction_id);\n\t(*td)->creation_time = le32_to_cpu(details_le.creation_time);\n\t(*td)->snapshotted_time = le32_to_cpu(details_le.snapshotted_time);\n\n\tlist_add(&(*td)->list, &pmd->thin_devices);\n\n\treturn 0;\n}\n\nstatic void __close_device(struct dm_thin_device *td)\n{\n\t--td->open_count;\n}\n\nstatic int __create_thin(struct dm_pool_metadata *pmd,\n\t\t\t dm_thin_id dev)\n{\n\tint r;\n\tdm_block_t dev_root;\n\tuint64_t key = dev;\n\tstruct dm_thin_device *td;\n\t__le64 value;\n\n\tr = dm_btree_lookup(&pmd->details_info, pmd->details_root,\n\t\t\t    &key, NULL);\n\tif (!r)\n\t\treturn -EEXIST;\n\n\t \n\tr = dm_btree_empty(&pmd->bl_info, &dev_root);\n\tif (r)\n\t\treturn r;\n\n\t \n\tvalue = cpu_to_le64(dev_root);\n\t__dm_bless_for_disk(&value);\n\tr = dm_btree_insert(&pmd->tl_info, pmd->root, &key, &value, &pmd->root);\n\tif (r) {\n\t\tdm_btree_del(&pmd->bl_info, dev_root);\n\t\treturn r;\n\t}\n\n\tr = __open_device(pmd, dev, 1, &td);\n\tif (r) {\n\t\tdm_btree_remove(&pmd->tl_info, pmd->root, &key, &pmd->root);\n\t\tdm_btree_del(&pmd->bl_info, dev_root);\n\t\treturn r;\n\t}\n\t__close_device(td);\n\n\treturn r;\n}\n\nint dm_pool_create_thin(struct dm_pool_metadata *pmd, dm_thin_id dev)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(pmd);\n\tif (!pmd->fail_io)\n\t\tr = __create_thin(pmd, dev);\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nstatic int __set_snapshot_details(struct dm_pool_metadata *pmd,\n\t\t\t\t  struct dm_thin_device *snap,\n\t\t\t\t  dm_thin_id origin, uint32_t time)\n{\n\tint r;\n\tstruct dm_thin_device *td;\n\n\tr = __open_device(pmd, origin, 0, &td);\n\tif (r)\n\t\treturn r;\n\n\ttd->changed = true;\n\ttd->snapshotted_time = time;\n\n\tsnap->mapped_blocks = td->mapped_blocks;\n\tsnap->snapshotted_time = time;\n\t__close_device(td);\n\n\treturn 0;\n}\n\nstatic int __create_snap(struct dm_pool_metadata *pmd,\n\t\t\t dm_thin_id dev, dm_thin_id origin)\n{\n\tint r;\n\tdm_block_t origin_root;\n\tuint64_t key = origin, dev_key = dev;\n\tstruct dm_thin_device *td;\n\t__le64 value;\n\n\t \n\tr = dm_btree_lookup(&pmd->details_info, pmd->details_root,\n\t\t\t    &dev_key, NULL);\n\tif (!r)\n\t\treturn -EEXIST;\n\n\t \n\tr = dm_btree_lookup(&pmd->tl_info, pmd->root, &key, &value);\n\tif (r)\n\t\treturn r;\n\torigin_root = le64_to_cpu(value);\n\n\t \n\tdm_tm_inc(pmd->tm, origin_root);\n\n\t \n\tvalue = cpu_to_le64(origin_root);\n\t__dm_bless_for_disk(&value);\n\tkey = dev;\n\tr = dm_btree_insert(&pmd->tl_info, pmd->root, &key, &value, &pmd->root);\n\tif (r) {\n\t\tdm_tm_dec(pmd->tm, origin_root);\n\t\treturn r;\n\t}\n\n\tpmd->time++;\n\n\tr = __open_device(pmd, dev, 1, &td);\n\tif (r)\n\t\tgoto bad;\n\n\tr = __set_snapshot_details(pmd, td, origin, pmd->time);\n\t__close_device(td);\n\n\tif (r)\n\t\tgoto bad;\n\n\treturn 0;\n\nbad:\n\tdm_btree_remove(&pmd->tl_info, pmd->root, &key, &pmd->root);\n\tdm_btree_remove(&pmd->details_info, pmd->details_root,\n\t\t\t&key, &pmd->details_root);\n\treturn r;\n}\n\nint dm_pool_create_snap(struct dm_pool_metadata *pmd,\n\t\t\t\t dm_thin_id dev,\n\t\t\t\t dm_thin_id origin)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(pmd);\n\tif (!pmd->fail_io)\n\t\tr = __create_snap(pmd, dev, origin);\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nstatic int __delete_device(struct dm_pool_metadata *pmd, dm_thin_id dev)\n{\n\tint r;\n\tuint64_t key = dev;\n\tstruct dm_thin_device *td;\n\n\t \n\tr = __open_device(pmd, dev, 0, &td);\n\tif (r)\n\t\treturn r;\n\n\tif (td->open_count > 1) {\n\t\t__close_device(td);\n\t\treturn -EBUSY;\n\t}\n\n\tlist_del(&td->list);\n\tkfree(td);\n\tr = dm_btree_remove(&pmd->details_info, pmd->details_root,\n\t\t\t    &key, &pmd->details_root);\n\tif (r)\n\t\treturn r;\n\n\tr = dm_btree_remove(&pmd->tl_info, pmd->root, &key, &pmd->root);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nint dm_pool_delete_thin_device(struct dm_pool_metadata *pmd,\n\t\t\t       dm_thin_id dev)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(pmd);\n\tif (!pmd->fail_io)\n\t\tr = __delete_device(pmd, dev);\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nint dm_pool_set_metadata_transaction_id(struct dm_pool_metadata *pmd,\n\t\t\t\t\tuint64_t current_id,\n\t\t\t\t\tuint64_t new_id)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(pmd);\n\n\tif (pmd->fail_io)\n\t\tgoto out;\n\n\tif (pmd->trans_id != current_id) {\n\t\tDMERR(\"mismatched transaction id\");\n\t\tgoto out;\n\t}\n\n\tpmd->trans_id = new_id;\n\tr = 0;\n\nout:\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nint dm_pool_get_metadata_transaction_id(struct dm_pool_metadata *pmd,\n\t\t\t\t\tuint64_t *result)\n{\n\tint r = -EINVAL;\n\n\tdown_read(&pmd->root_lock);\n\tif (!pmd->fail_io) {\n\t\t*result = pmd->trans_id;\n\t\tr = 0;\n\t}\n\tup_read(&pmd->root_lock);\n\n\treturn r;\n}\n\nstatic int __reserve_metadata_snap(struct dm_pool_metadata *pmd)\n{\n\tint r, inc;\n\tstruct thin_disk_superblock *disk_super;\n\tstruct dm_block *copy, *sblock;\n\tdm_block_t held_root;\n\n\t \n\tr = __commit_transaction(pmd);\n\tif (r < 0) {\n\t\tDMWARN(\"%s: __commit_transaction() failed, error = %d\",\n\t\t       __func__, r);\n\t\treturn r;\n\t}\n\n\t \n\tdm_sm_inc_block(pmd->metadata_sm, THIN_SUPERBLOCK_LOCATION);\n\tr = dm_tm_shadow_block(pmd->tm, THIN_SUPERBLOCK_LOCATION,\n\t\t\t       &sb_validator, &copy, &inc);\n\tif (r)\n\t\treturn r;\n\n\tBUG_ON(!inc);\n\n\theld_root = dm_block_location(copy);\n\tdisk_super = dm_block_data(copy);\n\n\tif (le64_to_cpu(disk_super->held_root)) {\n\t\tDMWARN(\"Pool metadata snapshot already exists: release this before taking another.\");\n\n\t\tdm_tm_dec(pmd->tm, held_root);\n\t\tdm_tm_unlock(pmd->tm, copy);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tmemset(&disk_super->data_space_map_root, 0,\n\t       sizeof(disk_super->data_space_map_root));\n\tmemset(&disk_super->metadata_space_map_root, 0,\n\t       sizeof(disk_super->metadata_space_map_root));\n\n\t \n\tdm_tm_inc(pmd->tm, le64_to_cpu(disk_super->data_mapping_root));\n\tdm_tm_inc(pmd->tm, le64_to_cpu(disk_super->device_details_root));\n\tdm_tm_unlock(pmd->tm, copy);\n\n\t \n\tr = superblock_lock(pmd, &sblock);\n\tif (r) {\n\t\tdm_tm_dec(pmd->tm, held_root);\n\t\treturn r;\n\t}\n\n\tdisk_super = dm_block_data(sblock);\n\tdisk_super->held_root = cpu_to_le64(held_root);\n\tdm_bm_unlock(sblock);\n\treturn 0;\n}\n\nint dm_pool_reserve_metadata_snap(struct dm_pool_metadata *pmd)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(pmd);\n\tif (!pmd->fail_io)\n\t\tr = __reserve_metadata_snap(pmd);\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nstatic int __release_metadata_snap(struct dm_pool_metadata *pmd)\n{\n\tint r;\n\tstruct thin_disk_superblock *disk_super;\n\tstruct dm_block *sblock, *copy;\n\tdm_block_t held_root;\n\n\tr = superblock_lock(pmd, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n\theld_root = le64_to_cpu(disk_super->held_root);\n\tdisk_super->held_root = cpu_to_le64(0);\n\n\tdm_bm_unlock(sblock);\n\n\tif (!held_root) {\n\t\tDMWARN(\"No pool metadata snapshot found: nothing to release.\");\n\t\treturn -EINVAL;\n\t}\n\n\tr = dm_tm_read_lock(pmd->tm, held_root, &sb_validator, &copy);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(copy);\n\tdm_btree_del(&pmd->info, le64_to_cpu(disk_super->data_mapping_root));\n\tdm_btree_del(&pmd->details_info, le64_to_cpu(disk_super->device_details_root));\n\tdm_sm_dec_block(pmd->metadata_sm, held_root);\n\n\tdm_tm_unlock(pmd->tm, copy);\n\n\treturn 0;\n}\n\nint dm_pool_release_metadata_snap(struct dm_pool_metadata *pmd)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(pmd);\n\tif (!pmd->fail_io)\n\t\tr = __release_metadata_snap(pmd);\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nstatic int __get_metadata_snap(struct dm_pool_metadata *pmd,\n\t\t\t       dm_block_t *result)\n{\n\tint r;\n\tstruct thin_disk_superblock *disk_super;\n\tstruct dm_block *sblock;\n\n\tr = dm_bm_read_lock(pmd->bm, THIN_SUPERBLOCK_LOCATION,\n\t\t\t    &sb_validator, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n\t*result = le64_to_cpu(disk_super->held_root);\n\n\tdm_bm_unlock(sblock);\n\n\treturn 0;\n}\n\nint dm_pool_get_metadata_snap(struct dm_pool_metadata *pmd,\n\t\t\t      dm_block_t *result)\n{\n\tint r = -EINVAL;\n\n\tdown_read(&pmd->root_lock);\n\tif (!pmd->fail_io)\n\t\tr = __get_metadata_snap(pmd, result);\n\tup_read(&pmd->root_lock);\n\n\treturn r;\n}\n\nint dm_pool_open_thin_device(struct dm_pool_metadata *pmd, dm_thin_id dev,\n\t\t\t     struct dm_thin_device **td)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock_in_core(pmd);\n\tif (!pmd->fail_io)\n\t\tr = __open_device(pmd, dev, 0, td);\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nint dm_pool_close_thin_device(struct dm_thin_device *td)\n{\n\tpmd_write_lock_in_core(td->pmd);\n\t__close_device(td);\n\tpmd_write_unlock(td->pmd);\n\n\treturn 0;\n}\n\ndm_thin_id dm_thin_dev_id(struct dm_thin_device *td)\n{\n\treturn td->id;\n}\n\n \nstatic bool __snapshotted_since(struct dm_thin_device *td, uint32_t time)\n{\n\treturn td->snapshotted_time > time;\n}\n\nstatic void unpack_lookup_result(struct dm_thin_device *td, __le64 value,\n\t\t\t\t struct dm_thin_lookup_result *result)\n{\n\tuint64_t block_time = 0;\n\tdm_block_t exception_block;\n\tuint32_t exception_time;\n\n\tblock_time = le64_to_cpu(value);\n\tunpack_block_time(block_time, &exception_block, &exception_time);\n\tresult->block = exception_block;\n\tresult->shared = __snapshotted_since(td, exception_time);\n}\n\nstatic int __find_block(struct dm_thin_device *td, dm_block_t block,\n\t\t\tint can_issue_io, struct dm_thin_lookup_result *result)\n{\n\tint r;\n\t__le64 value;\n\tstruct dm_pool_metadata *pmd = td->pmd;\n\tdm_block_t keys[2] = { td->id, block };\n\tstruct dm_btree_info *info;\n\n\tif (can_issue_io)\n\t\tinfo = &pmd->info;\n\telse\n\t\tinfo = &pmd->nb_info;\n\n\tr = dm_btree_lookup(info, pmd->root, keys, &value);\n\tif (!r)\n\t\tunpack_lookup_result(td, value, result);\n\n\treturn r;\n}\n\nint dm_thin_find_block(struct dm_thin_device *td, dm_block_t block,\n\t\t       int can_issue_io, struct dm_thin_lookup_result *result)\n{\n\tint r;\n\tstruct dm_pool_metadata *pmd = td->pmd;\n\n\tdown_read(&pmd->root_lock);\n\tif (pmd->fail_io) {\n\t\tup_read(&pmd->root_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tr = __find_block(td, block, can_issue_io, result);\n\n\tup_read(&pmd->root_lock);\n\treturn r;\n}\n\nstatic int __find_next_mapped_block(struct dm_thin_device *td, dm_block_t block,\n\t\t\t\t\t  dm_block_t *vblock,\n\t\t\t\t\t  struct dm_thin_lookup_result *result)\n{\n\tint r;\n\t__le64 value;\n\tstruct dm_pool_metadata *pmd = td->pmd;\n\tdm_block_t keys[2] = { td->id, block };\n\n\tr = dm_btree_lookup_next(&pmd->info, pmd->root, keys, vblock, &value);\n\tif (!r)\n\t\tunpack_lookup_result(td, value, result);\n\n\treturn r;\n}\n\nstatic int __find_mapped_range(struct dm_thin_device *td,\n\t\t\t       dm_block_t begin, dm_block_t end,\n\t\t\t       dm_block_t *thin_begin, dm_block_t *thin_end,\n\t\t\t       dm_block_t *pool_begin, bool *maybe_shared)\n{\n\tint r;\n\tdm_block_t pool_end;\n\tstruct dm_thin_lookup_result lookup;\n\n\tif (end < begin)\n\t\treturn -ENODATA;\n\n\tr = __find_next_mapped_block(td, begin, &begin, &lookup);\n\tif (r)\n\t\treturn r;\n\n\tif (begin >= end)\n\t\treturn -ENODATA;\n\n\t*thin_begin = begin;\n\t*pool_begin = lookup.block;\n\t*maybe_shared = lookup.shared;\n\n\tbegin++;\n\tpool_end = *pool_begin + 1;\n\twhile (begin != end) {\n\t\tr = __find_block(td, begin, true, &lookup);\n\t\tif (r) {\n\t\t\tif (r == -ENODATA)\n\t\t\t\tbreak;\n\n\t\t\treturn r;\n\t\t}\n\n\t\tif ((lookup.block != pool_end) ||\n\t\t    (lookup.shared != *maybe_shared))\n\t\t\tbreak;\n\n\t\tpool_end++;\n\t\tbegin++;\n\t}\n\n\t*thin_end = begin;\n\treturn 0;\n}\n\nint dm_thin_find_mapped_range(struct dm_thin_device *td,\n\t\t\t      dm_block_t begin, dm_block_t end,\n\t\t\t      dm_block_t *thin_begin, dm_block_t *thin_end,\n\t\t\t      dm_block_t *pool_begin, bool *maybe_shared)\n{\n\tint r = -EINVAL;\n\tstruct dm_pool_metadata *pmd = td->pmd;\n\n\tdown_read(&pmd->root_lock);\n\tif (!pmd->fail_io) {\n\t\tr = __find_mapped_range(td, begin, end, thin_begin, thin_end,\n\t\t\t\t\tpool_begin, maybe_shared);\n\t}\n\tup_read(&pmd->root_lock);\n\n\treturn r;\n}\n\nstatic int __insert(struct dm_thin_device *td, dm_block_t block,\n\t\t    dm_block_t data_block)\n{\n\tint r, inserted;\n\t__le64 value;\n\tstruct dm_pool_metadata *pmd = td->pmd;\n\tdm_block_t keys[2] = { td->id, block };\n\n\tvalue = cpu_to_le64(pack_block_time(data_block, pmd->time));\n\t__dm_bless_for_disk(&value);\n\n\tr = dm_btree_insert_notify(&pmd->info, pmd->root, keys, &value,\n\t\t\t\t   &pmd->root, &inserted);\n\tif (r)\n\t\treturn r;\n\n\ttd->changed = true;\n\tif (inserted)\n\t\ttd->mapped_blocks++;\n\n\treturn 0;\n}\n\nint dm_thin_insert_block(struct dm_thin_device *td, dm_block_t block,\n\t\t\t dm_block_t data_block)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(td->pmd);\n\tif (!td->pmd->fail_io)\n\t\tr = __insert(td, block, data_block);\n\tpmd_write_unlock(td->pmd);\n\n\treturn r;\n}\n\nstatic int __remove_range(struct dm_thin_device *td, dm_block_t begin, dm_block_t end)\n{\n\tint r;\n\tunsigned int count, total_count = 0;\n\tstruct dm_pool_metadata *pmd = td->pmd;\n\tdm_block_t keys[1] = { td->id };\n\t__le64 value;\n\tdm_block_t mapping_root;\n\n\t \n\tr = dm_btree_lookup(&pmd->tl_info, pmd->root, keys, &value);\n\tif (r)\n\t\treturn r;\n\n\t \n\tmapping_root = le64_to_cpu(value);\n\tdm_tm_inc(pmd->tm, mapping_root);\n\tr = dm_btree_remove(&pmd->tl_info, pmd->root, keys, &pmd->root);\n\tif (r)\n\t\treturn r;\n\n\t \n\twhile (begin < end) {\n\t\tr = dm_btree_lookup_next(&pmd->bl_info, mapping_root, &begin, &begin, &value);\n\t\tif (r == -ENODATA)\n\t\t\tbreak;\n\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tif (begin >= end)\n\t\t\tbreak;\n\n\t\tr = dm_btree_remove_leaves(&pmd->bl_info, mapping_root, &begin, end, &mapping_root, &count);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\ttotal_count += count;\n\t}\n\n\ttd->mapped_blocks -= total_count;\n\ttd->changed = true;\n\n\t \n\tvalue = cpu_to_le64(mapping_root);\n\t__dm_bless_for_disk(&value);\n\treturn dm_btree_insert(&pmd->tl_info, pmd->root, keys, &value, &pmd->root);\n}\n\nint dm_thin_remove_range(struct dm_thin_device *td,\n\t\t\t dm_block_t begin, dm_block_t end)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(td->pmd);\n\tif (!td->pmd->fail_io)\n\t\tr = __remove_range(td, begin, end);\n\tpmd_write_unlock(td->pmd);\n\n\treturn r;\n}\n\nint dm_pool_block_is_shared(struct dm_pool_metadata *pmd, dm_block_t b, bool *result)\n{\n\tint r = -EINVAL;\n\tuint32_t ref_count;\n\n\tdown_read(&pmd->root_lock);\n\tif (!pmd->fail_io) {\n\t\tr = dm_sm_get_count(pmd->data_sm, b, &ref_count);\n\t\tif (!r)\n\t\t\t*result = (ref_count > 1);\n\t}\n\tup_read(&pmd->root_lock);\n\n\treturn r;\n}\n\nint dm_pool_inc_data_range(struct dm_pool_metadata *pmd, dm_block_t b, dm_block_t e)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(pmd);\n\tif (!pmd->fail_io)\n\t\tr = dm_sm_inc_blocks(pmd->data_sm, b, e);\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nint dm_pool_dec_data_range(struct dm_pool_metadata *pmd, dm_block_t b, dm_block_t e)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(pmd);\n\tif (!pmd->fail_io)\n\t\tr = dm_sm_dec_blocks(pmd->data_sm, b, e);\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nbool dm_thin_changed_this_transaction(struct dm_thin_device *td)\n{\n\tint r;\n\n\tdown_read(&td->pmd->root_lock);\n\tr = td->changed;\n\tup_read(&td->pmd->root_lock);\n\n\treturn r;\n}\n\nbool dm_pool_changed_this_transaction(struct dm_pool_metadata *pmd)\n{\n\tbool r = false;\n\tstruct dm_thin_device *td, *tmp;\n\n\tdown_read(&pmd->root_lock);\n\tlist_for_each_entry_safe(td, tmp, &pmd->thin_devices, list) {\n\t\tif (td->changed) {\n\t\t\tr = td->changed;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&pmd->root_lock);\n\n\treturn r;\n}\n\nbool dm_thin_aborted_changes(struct dm_thin_device *td)\n{\n\tbool r;\n\n\tdown_read(&td->pmd->root_lock);\n\tr = td->aborted_with_changes;\n\tup_read(&td->pmd->root_lock);\n\n\treturn r;\n}\n\nint dm_pool_alloc_data_block(struct dm_pool_metadata *pmd, dm_block_t *result)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(pmd);\n\tif (!pmd->fail_io)\n\t\tr = dm_sm_new_block(pmd->data_sm, result);\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nint dm_pool_commit_metadata(struct dm_pool_metadata *pmd)\n{\n\tint r = -EINVAL;\n\n\t \n\tpmd_write_lock_in_core(pmd);\n\tif (pmd->fail_io)\n\t\tgoto out;\n\n\tr = __commit_transaction(pmd);\n\tif (r < 0)\n\t\tgoto out;\n\n\t \n\tr = __begin_transaction(pmd);\nout:\n\tpmd_write_unlock(pmd);\n\treturn r;\n}\n\nstatic void __set_abort_with_changes_flags(struct dm_pool_metadata *pmd)\n{\n\tstruct dm_thin_device *td;\n\n\tlist_for_each_entry(td, &pmd->thin_devices, list)\n\t\ttd->aborted_with_changes = td->changed;\n}\n\nint dm_pool_abort_metadata(struct dm_pool_metadata *pmd)\n{\n\tint r = -EINVAL;\n\n\t \n\tif (unlikely(pmd->fail_io))\n\t\treturn r;\n\n\tpmd_write_lock(pmd);\n\tif (pmd->fail_io) {\n\t\tpmd_write_unlock(pmd);\n\t\treturn r;\n\t}\n\t__set_abort_with_changes_flags(pmd);\n\n\t \n\t__destroy_persistent_data_objects(pmd, false);\n\n\t \n\tdm_block_manager_reset(pmd->bm);\n\n\t \n\tr = __open_or_format_metadata(pmd, false);\n\tif (r)\n\t\tpmd->fail_io = true;\n\tpmd_write_unlock(pmd);\n\treturn r;\n}\n\nint dm_pool_get_free_block_count(struct dm_pool_metadata *pmd, dm_block_t *result)\n{\n\tint r = -EINVAL;\n\n\tdown_read(&pmd->root_lock);\n\tif (!pmd->fail_io)\n\t\tr = dm_sm_get_nr_free(pmd->data_sm, result);\n\tup_read(&pmd->root_lock);\n\n\treturn r;\n}\n\nint dm_pool_get_free_metadata_block_count(struct dm_pool_metadata *pmd,\n\t\t\t\t\t  dm_block_t *result)\n{\n\tint r = -EINVAL;\n\n\tdown_read(&pmd->root_lock);\n\tif (!pmd->fail_io)\n\t\tr = dm_sm_get_nr_free(pmd->metadata_sm, result);\n\n\tif (!r) {\n\t\tif (*result < pmd->metadata_reserve)\n\t\t\t*result = 0;\n\t\telse\n\t\t\t*result -= pmd->metadata_reserve;\n\t}\n\tup_read(&pmd->root_lock);\n\n\treturn r;\n}\n\nint dm_pool_get_metadata_dev_size(struct dm_pool_metadata *pmd,\n\t\t\t\t  dm_block_t *result)\n{\n\tint r = -EINVAL;\n\n\tdown_read(&pmd->root_lock);\n\tif (!pmd->fail_io)\n\t\tr = dm_sm_get_nr_blocks(pmd->metadata_sm, result);\n\tup_read(&pmd->root_lock);\n\n\treturn r;\n}\n\nint dm_pool_get_data_dev_size(struct dm_pool_metadata *pmd, dm_block_t *result)\n{\n\tint r = -EINVAL;\n\n\tdown_read(&pmd->root_lock);\n\tif (!pmd->fail_io)\n\t\tr = dm_sm_get_nr_blocks(pmd->data_sm, result);\n\tup_read(&pmd->root_lock);\n\n\treturn r;\n}\n\nint dm_thin_get_mapped_count(struct dm_thin_device *td, dm_block_t *result)\n{\n\tint r = -EINVAL;\n\tstruct dm_pool_metadata *pmd = td->pmd;\n\n\tdown_read(&pmd->root_lock);\n\tif (!pmd->fail_io) {\n\t\t*result = td->mapped_blocks;\n\t\tr = 0;\n\t}\n\tup_read(&pmd->root_lock);\n\n\treturn r;\n}\n\nstatic int __highest_block(struct dm_thin_device *td, dm_block_t *result)\n{\n\tint r;\n\t__le64 value_le;\n\tdm_block_t thin_root;\n\tstruct dm_pool_metadata *pmd = td->pmd;\n\n\tr = dm_btree_lookup(&pmd->tl_info, pmd->root, &td->id, &value_le);\n\tif (r)\n\t\treturn r;\n\n\tthin_root = le64_to_cpu(value_le);\n\n\treturn dm_btree_find_highest_key(&pmd->bl_info, thin_root, result);\n}\n\nint dm_thin_get_highest_mapped_block(struct dm_thin_device *td,\n\t\t\t\t     dm_block_t *result)\n{\n\tint r = -EINVAL;\n\tstruct dm_pool_metadata *pmd = td->pmd;\n\n\tdown_read(&pmd->root_lock);\n\tif (!pmd->fail_io)\n\t\tr = __highest_block(td, result);\n\tup_read(&pmd->root_lock);\n\n\treturn r;\n}\n\nstatic int __resize_space_map(struct dm_space_map *sm, dm_block_t new_count)\n{\n\tint r;\n\tdm_block_t old_count;\n\n\tr = dm_sm_get_nr_blocks(sm, &old_count);\n\tif (r)\n\t\treturn r;\n\n\tif (new_count == old_count)\n\t\treturn 0;\n\n\tif (new_count < old_count) {\n\t\tDMERR(\"cannot reduce size of space map\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn dm_sm_extend(sm, new_count - old_count);\n}\n\nint dm_pool_resize_data_dev(struct dm_pool_metadata *pmd, dm_block_t new_count)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(pmd);\n\tif (!pmd->fail_io)\n\t\tr = __resize_space_map(pmd->data_sm, new_count);\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nint dm_pool_resize_metadata_dev(struct dm_pool_metadata *pmd, dm_block_t new_count)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock(pmd);\n\tif (!pmd->fail_io) {\n\t\tr = __resize_space_map(pmd->metadata_sm, new_count);\n\t\tif (!r)\n\t\t\t__set_metadata_reserve(pmd);\n\t}\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nvoid dm_pool_metadata_read_only(struct dm_pool_metadata *pmd)\n{\n\tpmd_write_lock_in_core(pmd);\n\tdm_bm_set_read_only(pmd->bm);\n\tpmd_write_unlock(pmd);\n}\n\nvoid dm_pool_metadata_read_write(struct dm_pool_metadata *pmd)\n{\n\tpmd_write_lock_in_core(pmd);\n\tdm_bm_set_read_write(pmd->bm);\n\tpmd_write_unlock(pmd);\n}\n\nint dm_pool_register_metadata_threshold(struct dm_pool_metadata *pmd,\n\t\t\t\t\tdm_block_t threshold,\n\t\t\t\t\tdm_sm_threshold_fn fn,\n\t\t\t\t\tvoid *context)\n{\n\tint r = -EINVAL;\n\n\tpmd_write_lock_in_core(pmd);\n\tif (!pmd->fail_io) {\n\t\tr = dm_sm_register_threshold_callback(pmd->metadata_sm,\n\t\t\t\t\t\t      threshold, fn, context);\n\t}\n\tpmd_write_unlock(pmd);\n\n\treturn r;\n}\n\nvoid dm_pool_register_pre_commit_callback(struct dm_pool_metadata *pmd,\n\t\t\t\t\t  dm_pool_pre_commit_fn fn,\n\t\t\t\t\t  void *context)\n{\n\tpmd_write_lock_in_core(pmd);\n\tpmd->pre_commit_fn = fn;\n\tpmd->pre_commit_context = context;\n\tpmd_write_unlock(pmd);\n}\n\nint dm_pool_metadata_set_needs_check(struct dm_pool_metadata *pmd)\n{\n\tint r = -EINVAL;\n\tstruct dm_block *sblock;\n\tstruct thin_disk_superblock *disk_super;\n\n\tpmd_write_lock(pmd);\n\tif (pmd->fail_io)\n\t\tgoto out;\n\n\tpmd->flags |= THIN_METADATA_NEEDS_CHECK_FLAG;\n\n\tr = superblock_lock(pmd, &sblock);\n\tif (r) {\n\t\tDMERR(\"couldn't lock superblock\");\n\t\tgoto out;\n\t}\n\n\tdisk_super = dm_block_data(sblock);\n\tdisk_super->flags = cpu_to_le32(pmd->flags);\n\n\tdm_bm_unlock(sblock);\nout:\n\tpmd_write_unlock(pmd);\n\treturn r;\n}\n\nbool dm_pool_metadata_needs_check(struct dm_pool_metadata *pmd)\n{\n\tbool needs_check;\n\n\tdown_read(&pmd->root_lock);\n\tneeds_check = pmd->flags & THIN_METADATA_NEEDS_CHECK_FLAG;\n\tup_read(&pmd->root_lock);\n\n\treturn needs_check;\n}\n\nvoid dm_pool_issue_prefetches(struct dm_pool_metadata *pmd)\n{\n\tdown_read(&pmd->root_lock);\n\tif (!pmd->fail_io)\n\t\tdm_tm_issue_prefetches(pmd->tm);\n\tup_read(&pmd->root_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}