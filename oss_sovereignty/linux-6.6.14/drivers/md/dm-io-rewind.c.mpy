{
  "module_name": "dm-io-rewind.c",
  "hash_id": "3e27c7378d38653889e9f9217759ab7ea8db869205c17104ad2ff6163dafe481",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-io-rewind.c",
  "human_readable_source": "\n \n\n#include <linux/bio.h>\n#include <linux/blk-crypto.h>\n#include <linux/blk-integrity.h>\n\n#include \"dm-core.h\"\n\nstatic inline bool dm_bvec_iter_rewind(const struct bio_vec *bv,\n\t\t\t\t       struct bvec_iter *iter,\n\t\t\t\t       unsigned int bytes)\n{\n\tint idx;\n\n\titer->bi_size += bytes;\n\tif (bytes <= iter->bi_bvec_done) {\n\t\titer->bi_bvec_done -= bytes;\n\t\treturn true;\n\t}\n\n\tbytes -= iter->bi_bvec_done;\n\tidx = iter->bi_idx - 1;\n\n\twhile (idx >= 0 && bytes && bytes > bv[idx].bv_len) {\n\t\tbytes -= bv[idx].bv_len;\n\t\tidx--;\n\t}\n\n\tif (WARN_ONCE(idx < 0 && bytes,\n\t\t      \"Attempted to rewind iter beyond bvec's boundaries\\n\")) {\n\t\titer->bi_size -= bytes;\n\t\titer->bi_bvec_done = 0;\n\t\titer->bi_idx = 0;\n\t\treturn false;\n\t}\n\n\titer->bi_idx = idx;\n\titer->bi_bvec_done = bv[idx].bv_len - bytes;\n\treturn true;\n}\n\n#if defined(CONFIG_BLK_DEV_INTEGRITY)\n\n \nstatic void dm_bio_integrity_rewind(struct bio *bio, unsigned int bytes_done)\n{\n\tstruct bio_integrity_payload *bip = bio_integrity(bio);\n\tstruct blk_integrity *bi = blk_get_integrity(bio->bi_bdev->bd_disk);\n\tunsigned int bytes = bio_integrity_bytes(bi, bytes_done >> 9);\n\n\tbip->bip_iter.bi_sector -= bio_integrity_intervals(bi, bytes_done >> 9);\n\tdm_bvec_iter_rewind(bip->bip_vec, &bip->bip_iter, bytes);\n}\n\n#else  \n\nstatic inline void dm_bio_integrity_rewind(struct bio *bio,\n\t\t\t\t\t   unsigned int bytes_done)\n{\n}\n\n#endif\n\n#if defined(CONFIG_BLK_INLINE_ENCRYPTION)\n\n \nstatic void dm_bio_crypt_dun_decrement(u64 dun[BLK_CRYPTO_DUN_ARRAY_SIZE],\n\t\t\t\t       unsigned int dec)\n{\n\tint i;\n\n\tfor (i = 0; dec && i < BLK_CRYPTO_DUN_ARRAY_SIZE; i++) {\n\t\tu64 prev = dun[i];\n\n\t\tdun[i] -= dec;\n\t\tif (dun[i] > prev)\n\t\t\tdec = 1;\n\t\telse\n\t\t\tdec = 0;\n\t}\n}\n\nstatic void dm_bio_crypt_rewind(struct bio *bio, unsigned int bytes)\n{\n\tstruct bio_crypt_ctx *bc = bio->bi_crypt_context;\n\n\tdm_bio_crypt_dun_decrement(bc->bc_dun,\n\t\t\t\t   bytes >> bc->bc_key->data_unit_size_bits);\n}\n\n#else  \n\nstatic inline void dm_bio_crypt_rewind(struct bio *bio, unsigned int bytes)\n{\n}\n\n#endif\n\nstatic inline void dm_bio_rewind_iter(const struct bio *bio,\n\t\t\t\t      struct bvec_iter *iter, unsigned int bytes)\n{\n\titer->bi_sector -= bytes >> 9;\n\n\t \n\tif (bio_no_advance_iter(bio))\n\t\titer->bi_size += bytes;\n\telse\n\t\tdm_bvec_iter_rewind(bio->bi_io_vec, iter, bytes);\n}\n\n \nstatic void dm_bio_rewind(struct bio *bio, unsigned int bytes)\n{\n\tif (bio_integrity(bio))\n\t\tdm_bio_integrity_rewind(bio, bytes);\n\n\tif (bio_has_crypt_ctx(bio))\n\t\tdm_bio_crypt_rewind(bio, bytes);\n\n\tdm_bio_rewind_iter(bio, &bio->bi_iter, bytes);\n}\n\nvoid dm_io_rewind(struct dm_io *io, struct bio_set *bs)\n{\n\tstruct bio *orig = io->orig_bio;\n\tstruct bio *new_orig = bio_alloc_clone(orig->bi_bdev, orig,\n\t\t\t\t\t       GFP_NOIO, bs);\n\t \n\tdm_bio_rewind(new_orig, ((io->sector_offset << 9) -\n\t\t\t\t orig->bi_iter.bi_size));\n\tbio_trim(new_orig, 0, io->sectors);\n\n\tbio_chain(new_orig, orig);\n\t \n\tatomic_dec(&orig->__bi_remaining);\n\tio->orig_bio = new_orig;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}