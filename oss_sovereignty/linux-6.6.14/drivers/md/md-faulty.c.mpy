{
  "module_name": "md-faulty.c",
  "hash_id": "3081c2e9d3a13e3f55ac152955d4c83013a22bb42db3ee6aa5f3ed6b36b77f04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/md-faulty.c",
  "human_readable_source": "\n \n\n\n \n\n#define\tWriteTransient\t0\n#define\tReadTransient\t1\n#define\tWritePersistent\t2\n#define\tReadPersistent\t3\n#define\tWriteAll\t4  \n#define\tReadFixable\t5\n#define\tModes\t6\n\n#define\tClearErrors\t31\n#define\tClearFaults\t30\n\n#define AllPersist\t100  \n#define\tNoPersist\t101\n\n#define\tModeMask\t0x1f\n#define\tModeShift\t5\n\n#define MaxFault\t50\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/raid/md_u.h>\n#include <linux/slab.h>\n#include \"md.h\"\n#include <linux/seq_file.h>\n\n\nstatic void faulty_fail(struct bio *bio)\n{\n\tstruct bio *b = bio->bi_private;\n\n\tb->bi_iter.bi_size = bio->bi_iter.bi_size;\n\tb->bi_iter.bi_sector = bio->bi_iter.bi_sector;\n\n\tbio_put(bio);\n\n\tbio_io_error(b);\n}\n\nstruct faulty_conf {\n\tint period[Modes];\n\tatomic_t counters[Modes];\n\tsector_t faults[MaxFault];\n\tint\tmodes[MaxFault];\n\tint nfaults;\n\tstruct md_rdev *rdev;\n};\n\nstatic int check_mode(struct faulty_conf *conf, int mode)\n{\n\tif (conf->period[mode] == 0 &&\n\t    atomic_read(&conf->counters[mode]) <= 0)\n\t\treturn 0;  \n\n\n\tif (atomic_dec_and_test(&conf->counters[mode])) {\n\t\tif (conf->period[mode])\n\t\t\tatomic_set(&conf->counters[mode], conf->period[mode]);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int check_sector(struct faulty_conf *conf, sector_t start, sector_t end, int dir)\n{\n\t \n\tint i;\n\tfor (i=0; i<conf->nfaults; i++)\n\t\tif (conf->faults[i] >= start &&\n\t\t    conf->faults[i] < end) {\n\t\t\t \n\t\t\tswitch (conf->modes[i] * 2 + dir) {\n\t\t\tcase WritePersistent*2+WRITE: return 1;\n\t\t\tcase ReadPersistent*2+READ: return 1;\n\t\t\tcase ReadFixable*2+READ: return 1;\n\t\t\tcase ReadFixable*2+WRITE:\n\t\t\t\tconf->modes[i] = NoPersist;\n\t\t\t\treturn 0;\n\t\t\tcase AllPersist*2+READ:\n\t\t\tcase AllPersist*2+WRITE: return 1;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nstatic void add_sector(struct faulty_conf *conf, sector_t start, int mode)\n{\n\tint i;\n\tint n = conf->nfaults;\n\tfor (i=0; i<conf->nfaults; i++)\n\t\tif (conf->faults[i] == start) {\n\t\t\tswitch(mode) {\n\t\t\tcase NoPersist: conf->modes[i] = mode; return;\n\t\t\tcase WritePersistent:\n\t\t\t\tif (conf->modes[i] == ReadPersistent ||\n\t\t\t\t    conf->modes[i] == ReadFixable)\n\t\t\t\t\tconf->modes[i] = AllPersist;\n\t\t\t\telse\n\t\t\t\t\tconf->modes[i] = WritePersistent;\n\t\t\t\treturn;\n\t\t\tcase ReadPersistent:\n\t\t\t\tif (conf->modes[i] == WritePersistent)\n\t\t\t\t\tconf->modes[i] = AllPersist;\n\t\t\t\telse\n\t\t\t\t\tconf->modes[i] = ReadPersistent;\n\t\t\t\treturn;\n\t\t\tcase ReadFixable:\n\t\t\t\tif (conf->modes[i] == WritePersistent ||\n\t\t\t\t    conf->modes[i] == ReadPersistent)\n\t\t\t\t\tconf->modes[i] = AllPersist;\n\t\t\t\telse\n\t\t\t\t\tconf->modes[i] = ReadFixable;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (conf->modes[i] == NoPersist)\n\t\t\tn = i;\n\n\tif (n >= MaxFault)\n\t\treturn;\n\tconf->faults[n] = start;\n\tconf->modes[n] = mode;\n\tif (conf->nfaults == n)\n\t\tconf->nfaults = n+1;\n}\n\nstatic bool faulty_make_request(struct mddev *mddev, struct bio *bio)\n{\n\tstruct faulty_conf *conf = mddev->private;\n\tint failit = 0;\n\n\tif (bio_data_dir(bio) == WRITE) {\n\t\t \n\t\tif (atomic_read(&conf->counters[WriteAll])) {\n\t\t\t \n\t\t\tbio_io_error(bio);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (check_sector(conf, bio->bi_iter.bi_sector,\n\t\t\t\t bio_end_sector(bio), WRITE))\n\t\t\tfailit = 1;\n\t\tif (check_mode(conf, WritePersistent)) {\n\t\t\tadd_sector(conf, bio->bi_iter.bi_sector,\n\t\t\t\t   WritePersistent);\n\t\t\tfailit = 1;\n\t\t}\n\t\tif (check_mode(conf, WriteTransient))\n\t\t\tfailit = 1;\n\t} else {\n\t\t \n\t\tif (check_sector(conf, bio->bi_iter.bi_sector,\n\t\t\t\t bio_end_sector(bio), READ))\n\t\t\tfailit = 1;\n\t\tif (check_mode(conf, ReadTransient))\n\t\t\tfailit = 1;\n\t\tif (check_mode(conf, ReadPersistent)) {\n\t\t\tadd_sector(conf, bio->bi_iter.bi_sector,\n\t\t\t\t   ReadPersistent);\n\t\t\tfailit = 1;\n\t\t}\n\t\tif (check_mode(conf, ReadFixable)) {\n\t\t\tadd_sector(conf, bio->bi_iter.bi_sector,\n\t\t\t\t   ReadFixable);\n\t\t\tfailit = 1;\n\t\t}\n\t}\n\n\tmd_account_bio(mddev, &bio);\n\tif (failit) {\n\t\tstruct bio *b = bio_alloc_clone(conf->rdev->bdev, bio, GFP_NOIO,\n\t\t\t\t\t\t&mddev->bio_set);\n\n\t\tb->bi_private = bio;\n\t\tb->bi_end_io = faulty_fail;\n\t\tbio = b;\n\t} else\n\t\tbio_set_dev(bio, conf->rdev->bdev);\n\n\tsubmit_bio_noacct(bio);\n\treturn true;\n}\n\nstatic void faulty_status(struct seq_file *seq, struct mddev *mddev)\n{\n\tstruct faulty_conf *conf = mddev->private;\n\tint n;\n\n\tif ((n=atomic_read(&conf->counters[WriteTransient])) != 0)\n\t\tseq_printf(seq, \" WriteTransient=%d(%d)\",\n\t\t\t   n, conf->period[WriteTransient]);\n\n\tif ((n=atomic_read(&conf->counters[ReadTransient])) != 0)\n\t\tseq_printf(seq, \" ReadTransient=%d(%d)\",\n\t\t\t   n, conf->period[ReadTransient]);\n\n\tif ((n=atomic_read(&conf->counters[WritePersistent])) != 0)\n\t\tseq_printf(seq, \" WritePersistent=%d(%d)\",\n\t\t\t   n, conf->period[WritePersistent]);\n\n\tif ((n=atomic_read(&conf->counters[ReadPersistent])) != 0)\n\t\tseq_printf(seq, \" ReadPersistent=%d(%d)\",\n\t\t\t   n, conf->period[ReadPersistent]);\n\n\n\tif ((n=atomic_read(&conf->counters[ReadFixable])) != 0)\n\t\tseq_printf(seq, \" ReadFixable=%d(%d)\",\n\t\t\t   n, conf->period[ReadFixable]);\n\n\tif ((n=atomic_read(&conf->counters[WriteAll])) != 0)\n\t\tseq_printf(seq, \" WriteAll\");\n\n\tseq_printf(seq, \" nfaults=%d\", conf->nfaults);\n}\n\n\nstatic int faulty_reshape(struct mddev *mddev)\n{\n\tint mode = mddev->new_layout & ModeMask;\n\tint count = mddev->new_layout >> ModeShift;\n\tstruct faulty_conf *conf = mddev->private;\n\n\tif (mddev->new_layout < 0)\n\t\treturn 0;\n\n\t \n\tif (mode == ClearFaults)\n\t\tconf->nfaults = 0;\n\telse if (mode == ClearErrors) {\n\t\tint i;\n\t\tfor (i=0 ; i < Modes ; i++) {\n\t\t\tconf->period[i] = 0;\n\t\t\tatomic_set(&conf->counters[i], 0);\n\t\t}\n\t} else if (mode < Modes) {\n\t\tconf->period[mode] = count;\n\t\tif (!count) count++;\n\t\tatomic_set(&conf->counters[mode], count);\n\t} else\n\t\treturn -EINVAL;\n\tmddev->new_layout = -1;\n\tmddev->layout = -1;  \n\treturn 0;\n}\n\nstatic sector_t faulty_size(struct mddev *mddev, sector_t sectors, int raid_disks)\n{\n\tWARN_ONCE(raid_disks,\n\t\t  \"%s does not support generic reshape\\n\", __func__);\n\n\tif (sectors == 0)\n\t\treturn mddev->dev_sectors;\n\n\treturn sectors;\n}\n\nstatic int faulty_run(struct mddev *mddev)\n{\n\tstruct md_rdev *rdev;\n\tint i;\n\tstruct faulty_conf *conf;\n\n\tif (md_check_no_bitmap(mddev))\n\t\treturn -EINVAL;\n\n\tconf = kmalloc(sizeof(*conf), GFP_KERNEL);\n\tif (!conf)\n\t\treturn -ENOMEM;\n\n\tfor (i=0; i<Modes; i++) {\n\t\tatomic_set(&conf->counters[i], 0);\n\t\tconf->period[i] = 0;\n\t}\n\tconf->nfaults = 0;\n\n\trdev_for_each(rdev, mddev) {\n\t\tconf->rdev = rdev;\n\t\tdisk_stack_limits(mddev->gendisk, rdev->bdev,\n\t\t\t\t  rdev->data_offset << 9);\n\t}\n\n\tmd_set_array_sectors(mddev, faulty_size(mddev, 0, 0));\n\tmddev->private = conf;\n\n\tfaulty_reshape(mddev);\n\n\treturn 0;\n}\n\nstatic void faulty_free(struct mddev *mddev, void *priv)\n{\n\tstruct faulty_conf *conf = priv;\n\n\tkfree(conf);\n}\n\nstatic struct md_personality faulty_personality =\n{\n\t.name\t\t= \"faulty\",\n\t.level\t\t= LEVEL_FAULTY,\n\t.owner\t\t= THIS_MODULE,\n\t.make_request\t= faulty_make_request,\n\t.run\t\t= faulty_run,\n\t.free\t\t= faulty_free,\n\t.status\t\t= faulty_status,\n\t.check_reshape\t= faulty_reshape,\n\t.size\t\t= faulty_size,\n};\n\nstatic int __init raid_init(void)\n{\n\treturn register_md_personality(&faulty_personality);\n}\n\nstatic void raid_exit(void)\n{\n\tunregister_md_personality(&faulty_personality);\n}\n\nmodule_init(raid_init);\nmodule_exit(raid_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Fault injection personality for MD (deprecated)\");\nMODULE_ALIAS(\"md-personality-10\");  \nMODULE_ALIAS(\"md-faulty\");\nMODULE_ALIAS(\"md-level--5\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}