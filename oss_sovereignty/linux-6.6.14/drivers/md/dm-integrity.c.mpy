{
  "module_name": "dm-integrity.c",
  "hash_id": "6d11403e84ba66221439181e93e81eeaaf6be92d72d20602d670a2b70fe0b32e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-integrity.c",
  "human_readable_source": "\n \n\n#include \"dm-bio-record.h\"\n\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/device-mapper.h>\n#include <linux/dm-io.h>\n#include <linux/vmalloc.h>\n#include <linux/sort.h>\n#include <linux/rbtree.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/reboot.h>\n#include <crypto/hash.h>\n#include <crypto/skcipher.h>\n#include <linux/async_tx.h>\n#include <linux/dm-bufio.h>\n\n#include \"dm-audit.h\"\n\n#define DM_MSG_PREFIX \"integrity\"\n\n#define DEFAULT_INTERLEAVE_SECTORS\t32768\n#define DEFAULT_JOURNAL_SIZE_FACTOR\t7\n#define DEFAULT_SECTORS_PER_BITMAP_BIT\t32768\n#define DEFAULT_BUFFER_SECTORS\t\t128\n#define DEFAULT_JOURNAL_WATERMARK\t50\n#define DEFAULT_SYNC_MSEC\t\t10000\n#define DEFAULT_MAX_JOURNAL_SECTORS\t(IS_ENABLED(CONFIG_64BIT) ? 131072 : 8192)\n#define MIN_LOG2_INTERLEAVE_SECTORS\t3\n#define MAX_LOG2_INTERLEAVE_SECTORS\t31\n#define METADATA_WORKQUEUE_MAX_ACTIVE\t16\n#define RECALC_SECTORS\t\t\t(IS_ENABLED(CONFIG_64BIT) ? 32768 : 2048)\n#define RECALC_WRITE_SUPER\t\t16\n#define BITMAP_BLOCK_SIZE\t\t4096\t \n#define BITMAP_FLUSH_INTERVAL\t\t(10 * HZ)\n#define DISCARD_FILLER\t\t\t0xf6\n#define SALT_SIZE\t\t\t16\n\n \n\n\n\n \n\n#define SB_MAGIC\t\t\t\"integrt\"\n#define SB_VERSION_1\t\t\t1\n#define SB_VERSION_2\t\t\t2\n#define SB_VERSION_3\t\t\t3\n#define SB_VERSION_4\t\t\t4\n#define SB_VERSION_5\t\t\t5\n#define SB_SECTORS\t\t\t8\n#define MAX_SECTORS_PER_BLOCK\t\t8\n\nstruct superblock {\n\t__u8 magic[8];\n\t__u8 version;\n\t__u8 log2_interleave_sectors;\n\t__le16 integrity_tag_size;\n\t__le32 journal_sections;\n\t__le64 provided_data_sectors;\t \n\t__le32 flags;\n\t__u8 log2_sectors_per_block;\n\t__u8 log2_blocks_per_bitmap_bit;\n\t__u8 pad[2];\n\t__le64 recalc_sector;\n\t__u8 pad2[8];\n\t__u8 salt[SALT_SIZE];\n};\n\n#define SB_FLAG_HAVE_JOURNAL_MAC\t0x1\n#define SB_FLAG_RECALCULATING\t\t0x2\n#define SB_FLAG_DIRTY_BITMAP\t\t0x4\n#define SB_FLAG_FIXED_PADDING\t\t0x8\n#define SB_FLAG_FIXED_HMAC\t\t0x10\n\n#define\tJOURNAL_ENTRY_ROUNDUP\t\t8\n\ntypedef __le64 commit_id_t;\n#define JOURNAL_MAC_PER_SECTOR\t\t8\n\nstruct journal_entry {\n\tunion {\n\t\tstruct {\n\t\t\t__le32 sector_lo;\n\t\t\t__le32 sector_hi;\n\t\t} s;\n\t\t__le64 sector;\n\t} u;\n\tcommit_id_t last_bytes[];\n\t \n};\n\n#define journal_entry_tag(ic, je)\t\t((__u8 *)&(je)->last_bytes[(ic)->sectors_per_block])\n\n#if BITS_PER_LONG == 64\n#define journal_entry_set_sector(je, x)\t\tdo { smp_wmb(); WRITE_ONCE((je)->u.sector, cpu_to_le64(x)); } while (0)\n#else\n#define journal_entry_set_sector(je, x)\t\tdo { (je)->u.s.sector_lo = cpu_to_le32(x); smp_wmb(); WRITE_ONCE((je)->u.s.sector_hi, cpu_to_le32((x) >> 32)); } while (0)\n#endif\n#define journal_entry_get_sector(je)\t\tle64_to_cpu((je)->u.sector)\n#define journal_entry_is_unused(je)\t\t((je)->u.s.sector_hi == cpu_to_le32(-1))\n#define journal_entry_set_unused(je)\t\t((je)->u.s.sector_hi = cpu_to_le32(-1))\n#define journal_entry_is_inprogress(je)\t\t((je)->u.s.sector_hi == cpu_to_le32(-2))\n#define journal_entry_set_inprogress(je)\t((je)->u.s.sector_hi = cpu_to_le32(-2))\n\n#define JOURNAL_BLOCK_SECTORS\t\t8\n#define JOURNAL_SECTOR_DATA\t\t((1 << SECTOR_SHIFT) - sizeof(commit_id_t))\n#define JOURNAL_MAC_SIZE\t\t(JOURNAL_MAC_PER_SECTOR * JOURNAL_BLOCK_SECTORS)\n\nstruct journal_sector {\n\tstruct_group(sectors,\n\t\t__u8 entries[JOURNAL_SECTOR_DATA - JOURNAL_MAC_PER_SECTOR];\n\t\t__u8 mac[JOURNAL_MAC_PER_SECTOR];\n\t);\n\tcommit_id_t commit_id;\n};\n\n#define MAX_TAG_SIZE\t\t\t(JOURNAL_SECTOR_DATA - JOURNAL_MAC_PER_SECTOR - offsetof(struct journal_entry, last_bytes[MAX_SECTORS_PER_BLOCK]))\n\n#define METADATA_PADDING_SECTORS\t8\n\n#define N_COMMIT_IDS\t\t\t4\n\nstatic unsigned char prev_commit_seq(unsigned char seq)\n{\n\treturn (seq + N_COMMIT_IDS - 1) % N_COMMIT_IDS;\n}\n\nstatic unsigned char next_commit_seq(unsigned char seq)\n{\n\treturn (seq + 1) % N_COMMIT_IDS;\n}\n\n \n\nstruct journal_node {\n\tstruct rb_node node;\n\tsector_t sector;\n};\n\nstruct alg_spec {\n\tchar *alg_string;\n\tchar *key_string;\n\t__u8 *key;\n\tunsigned int key_size;\n};\n\nstruct dm_integrity_c {\n\tstruct dm_dev *dev;\n\tstruct dm_dev *meta_dev;\n\tunsigned int tag_size;\n\t__s8 log2_tag_size;\n\tsector_t start;\n\tmempool_t journal_io_mempool;\n\tstruct dm_io_client *io;\n\tstruct dm_bufio_client *bufio;\n\tstruct workqueue_struct *metadata_wq;\n\tstruct superblock *sb;\n\tunsigned int journal_pages;\n\tunsigned int n_bitmap_blocks;\n\n\tstruct page_list *journal;\n\tstruct page_list *journal_io;\n\tstruct page_list *journal_xor;\n\tstruct page_list *recalc_bitmap;\n\tstruct page_list *may_write_bitmap;\n\tstruct bitmap_block_status *bbs;\n\tunsigned int bitmap_flush_interval;\n\tint synchronous_mode;\n\tstruct bio_list synchronous_bios;\n\tstruct delayed_work bitmap_flush_work;\n\n\tstruct crypto_skcipher *journal_crypt;\n\tstruct scatterlist **journal_scatterlist;\n\tstruct scatterlist **journal_io_scatterlist;\n\tstruct skcipher_request **sk_requests;\n\n\tstruct crypto_shash *journal_mac;\n\n\tstruct journal_node *journal_tree;\n\tstruct rb_root journal_tree_root;\n\n\tsector_t provided_data_sectors;\n\n\tunsigned short journal_entry_size;\n\tunsigned char journal_entries_per_sector;\n\tunsigned char journal_section_entries;\n\tunsigned short journal_section_sectors;\n\tunsigned int journal_sections;\n\tunsigned int journal_entries;\n\tsector_t data_device_sectors;\n\tsector_t meta_device_sectors;\n\tunsigned int initial_sectors;\n\tunsigned int metadata_run;\n\t__s8 log2_metadata_run;\n\t__u8 log2_buffer_sectors;\n\t__u8 sectors_per_block;\n\t__u8 log2_blocks_per_bitmap_bit;\n\n\tunsigned char mode;\n\n\tint failed;\n\n\tstruct crypto_shash *internal_hash;\n\n\tstruct dm_target *ti;\n\n\t \n\tstruct rb_root in_progress;\n\tstruct list_head wait_list;\n\twait_queue_head_t endio_wait;\n\tstruct workqueue_struct *wait_wq;\n\tstruct workqueue_struct *offload_wq;\n\n\tunsigned char commit_seq;\n\tcommit_id_t commit_ids[N_COMMIT_IDS];\n\n\tunsigned int committed_section;\n\tunsigned int n_committed_sections;\n\n\tunsigned int uncommitted_section;\n\tunsigned int n_uncommitted_sections;\n\n\tunsigned int free_section;\n\tunsigned char free_section_entry;\n\tunsigned int free_sectors;\n\n\tunsigned int free_sectors_threshold;\n\n\tstruct workqueue_struct *commit_wq;\n\tstruct work_struct commit_work;\n\n\tstruct workqueue_struct *writer_wq;\n\tstruct work_struct writer_work;\n\n\tstruct workqueue_struct *recalc_wq;\n\tstruct work_struct recalc_work;\n\n\tstruct bio_list flush_bio_list;\n\n\tunsigned long autocommit_jiffies;\n\tstruct timer_list autocommit_timer;\n\tunsigned int autocommit_msec;\n\n\twait_queue_head_t copy_to_journal_wait;\n\n\tstruct completion crypto_backoff;\n\n\tbool wrote_to_journal;\n\tbool journal_uptodate;\n\tbool just_formatted;\n\tbool recalculate_flag;\n\tbool reset_recalculate_flag;\n\tbool discard;\n\tbool fix_padding;\n\tbool fix_hmac;\n\tbool legacy_recalculate;\n\n\tstruct alg_spec internal_hash_alg;\n\tstruct alg_spec journal_crypt_alg;\n\tstruct alg_spec journal_mac_alg;\n\n\tatomic64_t number_of_mismatches;\n\n\tstruct notifier_block reboot_notifier;\n};\n\nstruct dm_integrity_range {\n\tsector_t logical_sector;\n\tsector_t n_sectors;\n\tbool waiting;\n\tunion {\n\t\tstruct rb_node node;\n\t\tstruct {\n\t\t\tstruct task_struct *task;\n\t\t\tstruct list_head wait_entry;\n\t\t};\n\t};\n};\n\nstruct dm_integrity_io {\n\tstruct work_struct work;\n\n\tstruct dm_integrity_c *ic;\n\tenum req_op op;\n\tbool fua;\n\n\tstruct dm_integrity_range range;\n\n\tsector_t metadata_block;\n\tunsigned int metadata_offset;\n\n\tatomic_t in_flight;\n\tblk_status_t bi_status;\n\n\tstruct completion *completion;\n\n\tstruct dm_bio_details bio_details;\n};\n\nstruct journal_completion {\n\tstruct dm_integrity_c *ic;\n\tatomic_t in_flight;\n\tstruct completion comp;\n};\n\nstruct journal_io {\n\tstruct dm_integrity_range range;\n\tstruct journal_completion *comp;\n};\n\nstruct bitmap_block_status {\n\tstruct work_struct work;\n\tstruct dm_integrity_c *ic;\n\tunsigned int idx;\n\tunsigned long *bitmap;\n\tstruct bio_list bio_queue;\n\tspinlock_t bio_queue_lock;\n\n};\n\nstatic struct kmem_cache *journal_io_cache;\n\n#define JOURNAL_IO_MEMPOOL\t32\n\n#ifdef DEBUG_PRINT\n#define DEBUG_print(x, ...)\t\t\tprintk(KERN_DEBUG x, ##__VA_ARGS__)\n#define DEBUG_bytes(bytes, len, msg, ...)\tprintk(KERN_DEBUG msg \"%s%*ph\\n\", ##__VA_ARGS__, \\\n\t\t\t\t\t\t       len ? \": \" : \"\", len, bytes)\n#else\n#define DEBUG_print(x, ...)\t\t\tdo { } while (0)\n#define DEBUG_bytes(bytes, len, msg, ...)\tdo { } while (0)\n#endif\n\nstatic void dm_integrity_prepare(struct request *rq)\n{\n}\n\nstatic void dm_integrity_complete(struct request *rq, unsigned int nr_bytes)\n{\n}\n\n \nstatic const struct blk_integrity_profile dm_integrity_profile = {\n\t.name\t\t\t= \"DM-DIF-EXT-TAG\",\n\t.generate_fn\t\t= NULL,\n\t.verify_fn\t\t= NULL,\n\t.prepare_fn\t\t= dm_integrity_prepare,\n\t.complete_fn\t\t= dm_integrity_complete,\n};\n\nstatic void dm_integrity_map_continue(struct dm_integrity_io *dio, bool from_map);\nstatic void integrity_bio_wait(struct work_struct *w);\nstatic void dm_integrity_dtr(struct dm_target *ti);\n\nstatic void dm_integrity_io_error(struct dm_integrity_c *ic, const char *msg, int err)\n{\n\tif (err == -EILSEQ)\n\t\tatomic64_inc(&ic->number_of_mismatches);\n\tif (!cmpxchg(&ic->failed, 0, err))\n\t\tDMERR(\"Error on %s: %d\", msg, err);\n}\n\nstatic int dm_integrity_failed(struct dm_integrity_c *ic)\n{\n\treturn READ_ONCE(ic->failed);\n}\n\nstatic bool dm_integrity_disable_recalculate(struct dm_integrity_c *ic)\n{\n\tif (ic->legacy_recalculate)\n\t\treturn false;\n\tif (!(ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_HMAC)) ?\n\t    ic->internal_hash_alg.key || ic->journal_mac_alg.key :\n\t    ic->internal_hash_alg.key && !ic->journal_mac_alg.key)\n\t\treturn true;\n\treturn false;\n}\n\nstatic commit_id_t dm_integrity_commit_id(struct dm_integrity_c *ic, unsigned int i,\n\t\t\t\t\t  unsigned int j, unsigned char seq)\n{\n\t \n\treturn ic->commit_ids[seq] ^ cpu_to_le64(((__u64)i << 32) ^ j);\n}\n\nstatic void get_area_and_offset(struct dm_integrity_c *ic, sector_t data_sector,\n\t\t\t\tsector_t *area, sector_t *offset)\n{\n\tif (!ic->meta_dev) {\n\t\t__u8 log2_interleave_sectors = ic->sb->log2_interleave_sectors;\n\t\t*area = data_sector >> log2_interleave_sectors;\n\t\t*offset = (unsigned int)data_sector & ((1U << log2_interleave_sectors) - 1);\n\t} else {\n\t\t*area = 0;\n\t\t*offset = data_sector;\n\t}\n}\n\n#define sector_to_block(ic, n)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tBUG_ON((n) & (unsigned int)((ic)->sectors_per_block - 1));\t\t\\\n\t(n) >>= (ic)->sb->log2_sectors_per_block;\t\t\t\\\n} while (0)\n\nstatic __u64 get_metadata_sector_and_offset(struct dm_integrity_c *ic, sector_t area,\n\t\t\t\t\t    sector_t offset, unsigned int *metadata_offset)\n{\n\t__u64 ms;\n\tunsigned int mo;\n\n\tms = area << ic->sb->log2_interleave_sectors;\n\tif (likely(ic->log2_metadata_run >= 0))\n\t\tms += area << ic->log2_metadata_run;\n\telse\n\t\tms += area * ic->metadata_run;\n\tms >>= ic->log2_buffer_sectors;\n\n\tsector_to_block(ic, offset);\n\n\tif (likely(ic->log2_tag_size >= 0)) {\n\t\tms += offset >> (SECTOR_SHIFT + ic->log2_buffer_sectors - ic->log2_tag_size);\n\t\tmo = (offset << ic->log2_tag_size) & ((1U << SECTOR_SHIFT << ic->log2_buffer_sectors) - 1);\n\t} else {\n\t\tms += (__u64)offset * ic->tag_size >> (SECTOR_SHIFT + ic->log2_buffer_sectors);\n\t\tmo = (offset * ic->tag_size) & ((1U << SECTOR_SHIFT << ic->log2_buffer_sectors) - 1);\n\t}\n\t*metadata_offset = mo;\n\treturn ms;\n}\n\nstatic sector_t get_data_sector(struct dm_integrity_c *ic, sector_t area, sector_t offset)\n{\n\tsector_t result;\n\n\tif (ic->meta_dev)\n\t\treturn offset;\n\n\tresult = area << ic->sb->log2_interleave_sectors;\n\tif (likely(ic->log2_metadata_run >= 0))\n\t\tresult += (area + 1) << ic->log2_metadata_run;\n\telse\n\t\tresult += (area + 1) * ic->metadata_run;\n\n\tresult += (sector_t)ic->initial_sectors + offset;\n\tresult += ic->start;\n\n\treturn result;\n}\n\nstatic void wraparound_section(struct dm_integrity_c *ic, unsigned int *sec_ptr)\n{\n\tif (unlikely(*sec_ptr >= ic->journal_sections))\n\t\t*sec_ptr -= ic->journal_sections;\n}\n\nstatic void sb_set_version(struct dm_integrity_c *ic)\n{\n\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_HMAC))\n\t\tic->sb->version = SB_VERSION_5;\n\telse if (ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_PADDING))\n\t\tic->sb->version = SB_VERSION_4;\n\telse if (ic->mode == 'B' || ic->sb->flags & cpu_to_le32(SB_FLAG_DIRTY_BITMAP))\n\t\tic->sb->version = SB_VERSION_3;\n\telse if (ic->meta_dev || ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING))\n\t\tic->sb->version = SB_VERSION_2;\n\telse\n\t\tic->sb->version = SB_VERSION_1;\n}\n\nstatic int sb_mac(struct dm_integrity_c *ic, bool wr)\n{\n\tSHASH_DESC_ON_STACK(desc, ic->journal_mac);\n\tint r;\n\tunsigned int size = crypto_shash_digestsize(ic->journal_mac);\n\n\tif (sizeof(struct superblock) + size > 1 << SECTOR_SHIFT) {\n\t\tdm_integrity_io_error(ic, \"digest is too long\", -EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tdesc->tfm = ic->journal_mac;\n\n\tr = crypto_shash_init(desc);\n\tif (unlikely(r < 0)) {\n\t\tdm_integrity_io_error(ic, \"crypto_shash_init\", r);\n\t\treturn r;\n\t}\n\n\tr = crypto_shash_update(desc, (__u8 *)ic->sb, (1 << SECTOR_SHIFT) - size);\n\tif (unlikely(r < 0)) {\n\t\tdm_integrity_io_error(ic, \"crypto_shash_update\", r);\n\t\treturn r;\n\t}\n\n\tif (likely(wr)) {\n\t\tr = crypto_shash_final(desc, (__u8 *)ic->sb + (1 << SECTOR_SHIFT) - size);\n\t\tif (unlikely(r < 0)) {\n\t\t\tdm_integrity_io_error(ic, \"crypto_shash_final\", r);\n\t\t\treturn r;\n\t\t}\n\t} else {\n\t\t__u8 result[HASH_MAX_DIGESTSIZE];\n\n\t\tr = crypto_shash_final(desc, result);\n\t\tif (unlikely(r < 0)) {\n\t\t\tdm_integrity_io_error(ic, \"crypto_shash_final\", r);\n\t\t\treturn r;\n\t\t}\n\t\tif (memcmp((__u8 *)ic->sb + (1 << SECTOR_SHIFT) - size, result, size)) {\n\t\t\tdm_integrity_io_error(ic, \"superblock mac\", -EILSEQ);\n\t\t\tdm_audit_log_target(DM_MSG_PREFIX, \"mac-superblock\", ic->ti, 0);\n\t\t\treturn -EILSEQ;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sync_rw_sb(struct dm_integrity_c *ic, blk_opf_t opf)\n{\n\tstruct dm_io_request io_req;\n\tstruct dm_io_region io_loc;\n\tconst enum req_op op = opf & REQ_OP_MASK;\n\tint r;\n\n\tio_req.bi_opf = opf;\n\tio_req.mem.type = DM_IO_KMEM;\n\tio_req.mem.ptr.addr = ic->sb;\n\tio_req.notify.fn = NULL;\n\tio_req.client = ic->io;\n\tio_loc.bdev = ic->meta_dev ? ic->meta_dev->bdev : ic->dev->bdev;\n\tio_loc.sector = ic->start;\n\tio_loc.count = SB_SECTORS;\n\n\tif (op == REQ_OP_WRITE) {\n\t\tsb_set_version(ic);\n\t\tif (ic->journal_mac && ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_HMAC)) {\n\t\t\tr = sb_mac(ic, true);\n\t\t\tif (unlikely(r))\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = dm_io(&io_req, 1, &io_loc, NULL);\n\tif (unlikely(r))\n\t\treturn r;\n\n\tif (op == REQ_OP_READ) {\n\t\tif (ic->mode != 'R' && ic->journal_mac && ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_HMAC)) {\n\t\t\tr = sb_mac(ic, false);\n\t\t\tif (unlikely(r))\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define BITMAP_OP_TEST_ALL_SET\t\t0\n#define BITMAP_OP_TEST_ALL_CLEAR\t1\n#define BITMAP_OP_SET\t\t\t2\n#define BITMAP_OP_CLEAR\t\t\t3\n\nstatic bool block_bitmap_op(struct dm_integrity_c *ic, struct page_list *bitmap,\n\t\t\t    sector_t sector, sector_t n_sectors, int mode)\n{\n\tunsigned long bit, end_bit, this_end_bit, page, end_page;\n\tunsigned long *data;\n\n\tif (unlikely(((sector | n_sectors) & ((1 << ic->sb->log2_sectors_per_block) - 1)) != 0)) {\n\t\tDMCRIT(\"invalid bitmap access (%llx,%llx,%d,%d,%d)\",\n\t\t\tsector,\n\t\t\tn_sectors,\n\t\t\tic->sb->log2_sectors_per_block,\n\t\t\tic->log2_blocks_per_bitmap_bit,\n\t\t\tmode);\n\t\tBUG();\n\t}\n\n\tif (unlikely(!n_sectors))\n\t\treturn true;\n\n\tbit = sector >> (ic->sb->log2_sectors_per_block + ic->log2_blocks_per_bitmap_bit);\n\tend_bit = (sector + n_sectors - 1) >>\n\t\t(ic->sb->log2_sectors_per_block + ic->log2_blocks_per_bitmap_bit);\n\n\tpage = bit / (PAGE_SIZE * 8);\n\tbit %= PAGE_SIZE * 8;\n\n\tend_page = end_bit / (PAGE_SIZE * 8);\n\tend_bit %= PAGE_SIZE * 8;\n\nrepeat:\n\tif (page < end_page)\n\t\tthis_end_bit = PAGE_SIZE * 8 - 1;\n\telse\n\t\tthis_end_bit = end_bit;\n\n\tdata = lowmem_page_address(bitmap[page].page);\n\n\tif (mode == BITMAP_OP_TEST_ALL_SET) {\n\t\twhile (bit <= this_end_bit) {\n\t\t\tif (!(bit % BITS_PER_LONG) && this_end_bit >= bit + BITS_PER_LONG - 1) {\n\t\t\t\tdo {\n\t\t\t\t\tif (data[bit / BITS_PER_LONG] != -1)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbit += BITS_PER_LONG;\n\t\t\t\t} while (this_end_bit >= bit + BITS_PER_LONG - 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!test_bit(bit, data))\n\t\t\t\treturn false;\n\t\t\tbit++;\n\t\t}\n\t} else if (mode == BITMAP_OP_TEST_ALL_CLEAR) {\n\t\twhile (bit <= this_end_bit) {\n\t\t\tif (!(bit % BITS_PER_LONG) && this_end_bit >= bit + BITS_PER_LONG - 1) {\n\t\t\t\tdo {\n\t\t\t\t\tif (data[bit / BITS_PER_LONG] != 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbit += BITS_PER_LONG;\n\t\t\t\t} while (this_end_bit >= bit + BITS_PER_LONG - 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (test_bit(bit, data))\n\t\t\t\treturn false;\n\t\t\tbit++;\n\t\t}\n\t} else if (mode == BITMAP_OP_SET) {\n\t\twhile (bit <= this_end_bit) {\n\t\t\tif (!(bit % BITS_PER_LONG) && this_end_bit >= bit + BITS_PER_LONG - 1) {\n\t\t\t\tdo {\n\t\t\t\t\tdata[bit / BITS_PER_LONG] = -1;\n\t\t\t\t\tbit += BITS_PER_LONG;\n\t\t\t\t} while (this_end_bit >= bit + BITS_PER_LONG - 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t__set_bit(bit, data);\n\t\t\tbit++;\n\t\t}\n\t} else if (mode == BITMAP_OP_CLEAR) {\n\t\tif (!bit && this_end_bit == PAGE_SIZE * 8 - 1)\n\t\t\tclear_page(data);\n\t\telse {\n\t\t\twhile (bit <= this_end_bit) {\n\t\t\t\tif (!(bit % BITS_PER_LONG) && this_end_bit >= bit + BITS_PER_LONG - 1) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tdata[bit / BITS_PER_LONG] = 0;\n\t\t\t\t\t\tbit += BITS_PER_LONG;\n\t\t\t\t\t} while (this_end_bit >= bit + BITS_PER_LONG - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t__clear_bit(bit, data);\n\t\t\t\tbit++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (unlikely(page < end_page)) {\n\t\tbit = 0;\n\t\tpage++;\n\t\tgoto repeat;\n\t}\n\n\treturn true;\n}\n\nstatic void block_bitmap_copy(struct dm_integrity_c *ic, struct page_list *dst, struct page_list *src)\n{\n\tunsigned int n_bitmap_pages = DIV_ROUND_UP(ic->n_bitmap_blocks, PAGE_SIZE / BITMAP_BLOCK_SIZE);\n\tunsigned int i;\n\n\tfor (i = 0; i < n_bitmap_pages; i++) {\n\t\tunsigned long *dst_data = lowmem_page_address(dst[i].page);\n\t\tunsigned long *src_data = lowmem_page_address(src[i].page);\n\n\t\tcopy_page(dst_data, src_data);\n\t}\n}\n\nstatic struct bitmap_block_status *sector_to_bitmap_block(struct dm_integrity_c *ic, sector_t sector)\n{\n\tunsigned int bit = sector >> (ic->sb->log2_sectors_per_block + ic->log2_blocks_per_bitmap_bit);\n\tunsigned int bitmap_block = bit / (BITMAP_BLOCK_SIZE * 8);\n\n\tBUG_ON(bitmap_block >= ic->n_bitmap_blocks);\n\treturn &ic->bbs[bitmap_block];\n}\n\nstatic void access_journal_check(struct dm_integrity_c *ic, unsigned int section, unsigned int offset,\n\t\t\t\t bool e, const char *function)\n{\n#if defined(CONFIG_DM_DEBUG) || defined(INTERNAL_VERIFY)\n\tunsigned int limit = e ? ic->journal_section_entries : ic->journal_section_sectors;\n\n\tif (unlikely(section >= ic->journal_sections) ||\n\t    unlikely(offset >= limit)) {\n\t\tDMCRIT(\"%s: invalid access at (%u,%u), limit (%u,%u)\",\n\t\t       function, section, offset, ic->journal_sections, limit);\n\t\tBUG();\n\t}\n#endif\n}\n\nstatic void page_list_location(struct dm_integrity_c *ic, unsigned int section, unsigned int offset,\n\t\t\t       unsigned int *pl_index, unsigned int *pl_offset)\n{\n\tunsigned int sector;\n\n\taccess_journal_check(ic, section, offset, false, \"page_list_location\");\n\n\tsector = section * ic->journal_section_sectors + offset;\n\n\t*pl_index = sector >> (PAGE_SHIFT - SECTOR_SHIFT);\n\t*pl_offset = (sector << SECTOR_SHIFT) & (PAGE_SIZE - 1);\n}\n\nstatic struct journal_sector *access_page_list(struct dm_integrity_c *ic, struct page_list *pl,\n\t\t\t\t\t       unsigned int section, unsigned int offset, unsigned int *n_sectors)\n{\n\tunsigned int pl_index, pl_offset;\n\tchar *va;\n\n\tpage_list_location(ic, section, offset, &pl_index, &pl_offset);\n\n\tif (n_sectors)\n\t\t*n_sectors = (PAGE_SIZE - pl_offset) >> SECTOR_SHIFT;\n\n\tva = lowmem_page_address(pl[pl_index].page);\n\n\treturn (struct journal_sector *)(va + pl_offset);\n}\n\nstatic struct journal_sector *access_journal(struct dm_integrity_c *ic, unsigned int section, unsigned int offset)\n{\n\treturn access_page_list(ic, ic->journal, section, offset, NULL);\n}\n\nstatic struct journal_entry *access_journal_entry(struct dm_integrity_c *ic, unsigned int section, unsigned int n)\n{\n\tunsigned int rel_sector, offset;\n\tstruct journal_sector *js;\n\n\taccess_journal_check(ic, section, n, true, \"access_journal_entry\");\n\n\trel_sector = n % JOURNAL_BLOCK_SECTORS;\n\toffset = n / JOURNAL_BLOCK_SECTORS;\n\n\tjs = access_journal(ic, section, rel_sector);\n\treturn (struct journal_entry *)((char *)js + offset * ic->journal_entry_size);\n}\n\nstatic struct journal_sector *access_journal_data(struct dm_integrity_c *ic, unsigned int section, unsigned int n)\n{\n\tn <<= ic->sb->log2_sectors_per_block;\n\n\tn += JOURNAL_BLOCK_SECTORS;\n\n\taccess_journal_check(ic, section, n, false, \"access_journal_data\");\n\n\treturn access_journal(ic, section, n);\n}\n\nstatic void section_mac(struct dm_integrity_c *ic, unsigned int section, __u8 result[JOURNAL_MAC_SIZE])\n{\n\tSHASH_DESC_ON_STACK(desc, ic->journal_mac);\n\tint r;\n\tunsigned int j, size;\n\n\tdesc->tfm = ic->journal_mac;\n\n\tr = crypto_shash_init(desc);\n\tif (unlikely(r < 0)) {\n\t\tdm_integrity_io_error(ic, \"crypto_shash_init\", r);\n\t\tgoto err;\n\t}\n\n\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_HMAC)) {\n\t\t__le64 section_le;\n\n\t\tr = crypto_shash_update(desc, (__u8 *)&ic->sb->salt, SALT_SIZE);\n\t\tif (unlikely(r < 0)) {\n\t\t\tdm_integrity_io_error(ic, \"crypto_shash_update\", r);\n\t\t\tgoto err;\n\t\t}\n\n\t\tsection_le = cpu_to_le64(section);\n\t\tr = crypto_shash_update(desc, (__u8 *)&section_le, sizeof(section_le));\n\t\tif (unlikely(r < 0)) {\n\t\t\tdm_integrity_io_error(ic, \"crypto_shash_update\", r);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tfor (j = 0; j < ic->journal_section_entries; j++) {\n\t\tstruct journal_entry *je = access_journal_entry(ic, section, j);\n\n\t\tr = crypto_shash_update(desc, (__u8 *)&je->u.sector, sizeof(je->u.sector));\n\t\tif (unlikely(r < 0)) {\n\t\t\tdm_integrity_io_error(ic, \"crypto_shash_update\", r);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tsize = crypto_shash_digestsize(ic->journal_mac);\n\n\tif (likely(size <= JOURNAL_MAC_SIZE)) {\n\t\tr = crypto_shash_final(desc, result);\n\t\tif (unlikely(r < 0)) {\n\t\t\tdm_integrity_io_error(ic, \"crypto_shash_final\", r);\n\t\t\tgoto err;\n\t\t}\n\t\tmemset(result + size, 0, JOURNAL_MAC_SIZE - size);\n\t} else {\n\t\t__u8 digest[HASH_MAX_DIGESTSIZE];\n\n\t\tif (WARN_ON(size > sizeof(digest))) {\n\t\t\tdm_integrity_io_error(ic, \"digest_size\", -EINVAL);\n\t\t\tgoto err;\n\t\t}\n\t\tr = crypto_shash_final(desc, digest);\n\t\tif (unlikely(r < 0)) {\n\t\t\tdm_integrity_io_error(ic, \"crypto_shash_final\", r);\n\t\t\tgoto err;\n\t\t}\n\t\tmemcpy(result, digest, JOURNAL_MAC_SIZE);\n\t}\n\n\treturn;\nerr:\n\tmemset(result, 0, JOURNAL_MAC_SIZE);\n}\n\nstatic void rw_section_mac(struct dm_integrity_c *ic, unsigned int section, bool wr)\n{\n\t__u8 result[JOURNAL_MAC_SIZE];\n\tunsigned int j;\n\n\tif (!ic->journal_mac)\n\t\treturn;\n\n\tsection_mac(ic, section, result);\n\n\tfor (j = 0; j < JOURNAL_BLOCK_SECTORS; j++) {\n\t\tstruct journal_sector *js = access_journal(ic, section, j);\n\n\t\tif (likely(wr))\n\t\t\tmemcpy(&js->mac, result + (j * JOURNAL_MAC_PER_SECTOR), JOURNAL_MAC_PER_SECTOR);\n\t\telse {\n\t\t\tif (memcmp(&js->mac, result + (j * JOURNAL_MAC_PER_SECTOR), JOURNAL_MAC_PER_SECTOR)) {\n\t\t\t\tdm_integrity_io_error(ic, \"journal mac\", -EILSEQ);\n\t\t\t\tdm_audit_log_target(DM_MSG_PREFIX, \"mac-journal\", ic->ti, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void complete_journal_op(void *context)\n{\n\tstruct journal_completion *comp = context;\n\n\tBUG_ON(!atomic_read(&comp->in_flight));\n\tif (likely(atomic_dec_and_test(&comp->in_flight)))\n\t\tcomplete(&comp->comp);\n}\n\nstatic void xor_journal(struct dm_integrity_c *ic, bool encrypt, unsigned int section,\n\t\t\tunsigned int n_sections, struct journal_completion *comp)\n{\n\tstruct async_submit_ctl submit;\n\tsize_t n_bytes = (size_t)(n_sections * ic->journal_section_sectors) << SECTOR_SHIFT;\n\tunsigned int pl_index, pl_offset, section_index;\n\tstruct page_list *source_pl, *target_pl;\n\n\tif (likely(encrypt)) {\n\t\tsource_pl = ic->journal;\n\t\ttarget_pl = ic->journal_io;\n\t} else {\n\t\tsource_pl = ic->journal_io;\n\t\ttarget_pl = ic->journal;\n\t}\n\n\tpage_list_location(ic, section, 0, &pl_index, &pl_offset);\n\n\tatomic_add(roundup(pl_offset + n_bytes, PAGE_SIZE) >> PAGE_SHIFT, &comp->in_flight);\n\n\tinit_async_submit(&submit, ASYNC_TX_XOR_ZERO_DST, NULL, complete_journal_op, comp, NULL);\n\n\tsection_index = pl_index;\n\n\tdo {\n\t\tsize_t this_step;\n\t\tstruct page *src_pages[2];\n\t\tstruct page *dst_page;\n\n\t\twhile (unlikely(pl_index == section_index)) {\n\t\t\tunsigned int dummy;\n\n\t\t\tif (likely(encrypt))\n\t\t\t\trw_section_mac(ic, section, true);\n\t\t\tsection++;\n\t\t\tn_sections--;\n\t\t\tif (!n_sections)\n\t\t\t\tbreak;\n\t\t\tpage_list_location(ic, section, 0, &section_index, &dummy);\n\t\t}\n\n\t\tthis_step = min(n_bytes, (size_t)PAGE_SIZE - pl_offset);\n\t\tdst_page = target_pl[pl_index].page;\n\t\tsrc_pages[0] = source_pl[pl_index].page;\n\t\tsrc_pages[1] = ic->journal_xor[pl_index].page;\n\n\t\tasync_xor(dst_page, src_pages, pl_offset, 2, this_step, &submit);\n\n\t\tpl_index++;\n\t\tpl_offset = 0;\n\t\tn_bytes -= this_step;\n\t} while (n_bytes);\n\n\tBUG_ON(n_sections);\n\n\tasync_tx_issue_pending_all();\n}\n\nstatic void complete_journal_encrypt(void *data, int err)\n{\n\tstruct journal_completion *comp = data;\n\n\tif (unlikely(err)) {\n\t\tif (likely(err == -EINPROGRESS)) {\n\t\t\tcomplete(&comp->ic->crypto_backoff);\n\t\t\treturn;\n\t\t}\n\t\tdm_integrity_io_error(comp->ic, \"asynchronous encrypt\", err);\n\t}\n\tcomplete_journal_op(comp);\n}\n\nstatic bool do_crypt(bool encrypt, struct skcipher_request *req, struct journal_completion *comp)\n{\n\tint r;\n\n\tskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      complete_journal_encrypt, comp);\n\tif (likely(encrypt))\n\t\tr = crypto_skcipher_encrypt(req);\n\telse\n\t\tr = crypto_skcipher_decrypt(req);\n\tif (likely(!r))\n\t\treturn false;\n\tif (likely(r == -EINPROGRESS))\n\t\treturn true;\n\tif (likely(r == -EBUSY)) {\n\t\twait_for_completion(&comp->ic->crypto_backoff);\n\t\treinit_completion(&comp->ic->crypto_backoff);\n\t\treturn true;\n\t}\n\tdm_integrity_io_error(comp->ic, \"encrypt\", r);\n\treturn false;\n}\n\nstatic void crypt_journal(struct dm_integrity_c *ic, bool encrypt, unsigned int section,\n\t\t\t  unsigned int n_sections, struct journal_completion *comp)\n{\n\tstruct scatterlist **source_sg;\n\tstruct scatterlist **target_sg;\n\n\tatomic_add(2, &comp->in_flight);\n\n\tif (likely(encrypt)) {\n\t\tsource_sg = ic->journal_scatterlist;\n\t\ttarget_sg = ic->journal_io_scatterlist;\n\t} else {\n\t\tsource_sg = ic->journal_io_scatterlist;\n\t\ttarget_sg = ic->journal_scatterlist;\n\t}\n\n\tdo {\n\t\tstruct skcipher_request *req;\n\t\tunsigned int ivsize;\n\t\tchar *iv;\n\n\t\tif (likely(encrypt))\n\t\t\trw_section_mac(ic, section, true);\n\n\t\treq = ic->sk_requests[section];\n\t\tivsize = crypto_skcipher_ivsize(ic->journal_crypt);\n\t\tiv = req->iv;\n\n\t\tmemcpy(iv, iv + ivsize, ivsize);\n\n\t\treq->src = source_sg[section];\n\t\treq->dst = target_sg[section];\n\n\t\tif (unlikely(do_crypt(encrypt, req, comp)))\n\t\t\tatomic_inc(&comp->in_flight);\n\n\t\tsection++;\n\t\tn_sections--;\n\t} while (n_sections);\n\n\tatomic_dec(&comp->in_flight);\n\tcomplete_journal_op(comp);\n}\n\nstatic void encrypt_journal(struct dm_integrity_c *ic, bool encrypt, unsigned int section,\n\t\t\t    unsigned int n_sections, struct journal_completion *comp)\n{\n\tif (ic->journal_xor)\n\t\treturn xor_journal(ic, encrypt, section, n_sections, comp);\n\telse\n\t\treturn crypt_journal(ic, encrypt, section, n_sections, comp);\n}\n\nstatic void complete_journal_io(unsigned long error, void *context)\n{\n\tstruct journal_completion *comp = context;\n\n\tif (unlikely(error != 0))\n\t\tdm_integrity_io_error(comp->ic, \"writing journal\", -EIO);\n\tcomplete_journal_op(comp);\n}\n\nstatic void rw_journal_sectors(struct dm_integrity_c *ic, blk_opf_t opf,\n\t\t\t       unsigned int sector, unsigned int n_sectors,\n\t\t\t       struct journal_completion *comp)\n{\n\tstruct dm_io_request io_req;\n\tstruct dm_io_region io_loc;\n\tunsigned int pl_index, pl_offset;\n\tint r;\n\n\tif (unlikely(dm_integrity_failed(ic))) {\n\t\tif (comp)\n\t\t\tcomplete_journal_io(-1UL, comp);\n\t\treturn;\n\t}\n\n\tpl_index = sector >> (PAGE_SHIFT - SECTOR_SHIFT);\n\tpl_offset = (sector << SECTOR_SHIFT) & (PAGE_SIZE - 1);\n\n\tio_req.bi_opf = opf;\n\tio_req.mem.type = DM_IO_PAGE_LIST;\n\tif (ic->journal_io)\n\t\tio_req.mem.ptr.pl = &ic->journal_io[pl_index];\n\telse\n\t\tio_req.mem.ptr.pl = &ic->journal[pl_index];\n\tio_req.mem.offset = pl_offset;\n\tif (likely(comp != NULL)) {\n\t\tio_req.notify.fn = complete_journal_io;\n\t\tio_req.notify.context = comp;\n\t} else {\n\t\tio_req.notify.fn = NULL;\n\t}\n\tio_req.client = ic->io;\n\tio_loc.bdev = ic->meta_dev ? ic->meta_dev->bdev : ic->dev->bdev;\n\tio_loc.sector = ic->start + SB_SECTORS + sector;\n\tio_loc.count = n_sectors;\n\n\tr = dm_io(&io_req, 1, &io_loc, NULL);\n\tif (unlikely(r)) {\n\t\tdm_integrity_io_error(ic, (opf & REQ_OP_MASK) == REQ_OP_READ ?\n\t\t\t\t      \"reading journal\" : \"writing journal\", r);\n\t\tif (comp) {\n\t\t\tWARN_ONCE(1, \"asynchronous dm_io failed: %d\", r);\n\t\t\tcomplete_journal_io(-1UL, comp);\n\t\t}\n\t}\n}\n\nstatic void rw_journal(struct dm_integrity_c *ic, blk_opf_t opf,\n\t\t       unsigned int section, unsigned int n_sections,\n\t\t       struct journal_completion *comp)\n{\n\tunsigned int sector, n_sectors;\n\n\tsector = section * ic->journal_section_sectors;\n\tn_sectors = n_sections * ic->journal_section_sectors;\n\n\trw_journal_sectors(ic, opf, sector, n_sectors, comp);\n}\n\nstatic void write_journal(struct dm_integrity_c *ic, unsigned int commit_start, unsigned int commit_sections)\n{\n\tstruct journal_completion io_comp;\n\tstruct journal_completion crypt_comp_1;\n\tstruct journal_completion crypt_comp_2;\n\tunsigned int i;\n\n\tio_comp.ic = ic;\n\tinit_completion(&io_comp.comp);\n\n\tif (commit_start + commit_sections <= ic->journal_sections) {\n\t\tio_comp.in_flight = (atomic_t)ATOMIC_INIT(1);\n\t\tif (ic->journal_io) {\n\t\t\tcrypt_comp_1.ic = ic;\n\t\t\tinit_completion(&crypt_comp_1.comp);\n\t\t\tcrypt_comp_1.in_flight = (atomic_t)ATOMIC_INIT(0);\n\t\t\tencrypt_journal(ic, true, commit_start, commit_sections, &crypt_comp_1);\n\t\t\twait_for_completion_io(&crypt_comp_1.comp);\n\t\t} else {\n\t\t\tfor (i = 0; i < commit_sections; i++)\n\t\t\t\trw_section_mac(ic, commit_start + i, true);\n\t\t}\n\t\trw_journal(ic, REQ_OP_WRITE | REQ_FUA | REQ_SYNC, commit_start,\n\t\t\t   commit_sections, &io_comp);\n\t} else {\n\t\tunsigned int to_end;\n\n\t\tio_comp.in_flight = (atomic_t)ATOMIC_INIT(2);\n\t\tto_end = ic->journal_sections - commit_start;\n\t\tif (ic->journal_io) {\n\t\t\tcrypt_comp_1.ic = ic;\n\t\t\tinit_completion(&crypt_comp_1.comp);\n\t\t\tcrypt_comp_1.in_flight = (atomic_t)ATOMIC_INIT(0);\n\t\t\tencrypt_journal(ic, true, commit_start, to_end, &crypt_comp_1);\n\t\t\tif (try_wait_for_completion(&crypt_comp_1.comp)) {\n\t\t\t\trw_journal(ic, REQ_OP_WRITE | REQ_FUA,\n\t\t\t\t\t   commit_start, to_end, &io_comp);\n\t\t\t\treinit_completion(&crypt_comp_1.comp);\n\t\t\t\tcrypt_comp_1.in_flight = (atomic_t)ATOMIC_INIT(0);\n\t\t\t\tencrypt_journal(ic, true, 0, commit_sections - to_end, &crypt_comp_1);\n\t\t\t\twait_for_completion_io(&crypt_comp_1.comp);\n\t\t\t} else {\n\t\t\t\tcrypt_comp_2.ic = ic;\n\t\t\t\tinit_completion(&crypt_comp_2.comp);\n\t\t\t\tcrypt_comp_2.in_flight = (atomic_t)ATOMIC_INIT(0);\n\t\t\t\tencrypt_journal(ic, true, 0, commit_sections - to_end, &crypt_comp_2);\n\t\t\t\twait_for_completion_io(&crypt_comp_1.comp);\n\t\t\t\trw_journal(ic, REQ_OP_WRITE | REQ_FUA, commit_start, to_end, &io_comp);\n\t\t\t\twait_for_completion_io(&crypt_comp_2.comp);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < to_end; i++)\n\t\t\t\trw_section_mac(ic, commit_start + i, true);\n\t\t\trw_journal(ic, REQ_OP_WRITE | REQ_FUA, commit_start, to_end, &io_comp);\n\t\t\tfor (i = 0; i < commit_sections - to_end; i++)\n\t\t\t\trw_section_mac(ic, i, true);\n\t\t}\n\t\trw_journal(ic, REQ_OP_WRITE | REQ_FUA, 0, commit_sections - to_end, &io_comp);\n\t}\n\n\twait_for_completion_io(&io_comp.comp);\n}\n\nstatic void copy_from_journal(struct dm_integrity_c *ic, unsigned int section, unsigned int offset,\n\t\t\t      unsigned int n_sectors, sector_t target, io_notify_fn fn, void *data)\n{\n\tstruct dm_io_request io_req;\n\tstruct dm_io_region io_loc;\n\tint r;\n\tunsigned int sector, pl_index, pl_offset;\n\n\tBUG_ON((target | n_sectors | offset) & (unsigned int)(ic->sectors_per_block - 1));\n\n\tif (unlikely(dm_integrity_failed(ic))) {\n\t\tfn(-1UL, data);\n\t\treturn;\n\t}\n\n\tsector = section * ic->journal_section_sectors + JOURNAL_BLOCK_SECTORS + offset;\n\n\tpl_index = sector >> (PAGE_SHIFT - SECTOR_SHIFT);\n\tpl_offset = (sector << SECTOR_SHIFT) & (PAGE_SIZE - 1);\n\n\tio_req.bi_opf = REQ_OP_WRITE;\n\tio_req.mem.type = DM_IO_PAGE_LIST;\n\tio_req.mem.ptr.pl = &ic->journal[pl_index];\n\tio_req.mem.offset = pl_offset;\n\tio_req.notify.fn = fn;\n\tio_req.notify.context = data;\n\tio_req.client = ic->io;\n\tio_loc.bdev = ic->dev->bdev;\n\tio_loc.sector = target;\n\tio_loc.count = n_sectors;\n\n\tr = dm_io(&io_req, 1, &io_loc, NULL);\n\tif (unlikely(r)) {\n\t\tWARN_ONCE(1, \"asynchronous dm_io failed: %d\", r);\n\t\tfn(-1UL, data);\n\t}\n}\n\nstatic bool ranges_overlap(struct dm_integrity_range *range1, struct dm_integrity_range *range2)\n{\n\treturn range1->logical_sector < range2->logical_sector + range2->n_sectors &&\n\t       range1->logical_sector + range1->n_sectors > range2->logical_sector;\n}\n\nstatic bool add_new_range(struct dm_integrity_c *ic, struct dm_integrity_range *new_range, bool check_waiting)\n{\n\tstruct rb_node **n = &ic->in_progress.rb_node;\n\tstruct rb_node *parent;\n\n\tBUG_ON((new_range->logical_sector | new_range->n_sectors) & (unsigned int)(ic->sectors_per_block - 1));\n\n\tif (likely(check_waiting)) {\n\t\tstruct dm_integrity_range *range;\n\n\t\tlist_for_each_entry(range, &ic->wait_list, wait_entry) {\n\t\t\tif (unlikely(ranges_overlap(range, new_range)))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tparent = NULL;\n\n\twhile (*n) {\n\t\tstruct dm_integrity_range *range = container_of(*n, struct dm_integrity_range, node);\n\n\t\tparent = *n;\n\t\tif (new_range->logical_sector + new_range->n_sectors <= range->logical_sector)\n\t\t\tn = &range->node.rb_left;\n\t\telse if (new_range->logical_sector >= range->logical_sector + range->n_sectors)\n\t\t\tn = &range->node.rb_right;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\trb_link_node(&new_range->node, parent, n);\n\trb_insert_color(&new_range->node, &ic->in_progress);\n\n\treturn true;\n}\n\nstatic void remove_range_unlocked(struct dm_integrity_c *ic, struct dm_integrity_range *range)\n{\n\trb_erase(&range->node, &ic->in_progress);\n\twhile (unlikely(!list_empty(&ic->wait_list))) {\n\t\tstruct dm_integrity_range *last_range =\n\t\t\tlist_first_entry(&ic->wait_list, struct dm_integrity_range, wait_entry);\n\t\tstruct task_struct *last_range_task;\n\n\t\tlast_range_task = last_range->task;\n\t\tlist_del(&last_range->wait_entry);\n\t\tif (!add_new_range(ic, last_range, false)) {\n\t\t\tlast_range->task = last_range_task;\n\t\t\tlist_add(&last_range->wait_entry, &ic->wait_list);\n\t\t\tbreak;\n\t\t}\n\t\tlast_range->waiting = false;\n\t\twake_up_process(last_range_task);\n\t}\n}\n\nstatic void remove_range(struct dm_integrity_c *ic, struct dm_integrity_range *range)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ic->endio_wait.lock, flags);\n\tremove_range_unlocked(ic, range);\n\tspin_unlock_irqrestore(&ic->endio_wait.lock, flags);\n}\n\nstatic void wait_and_add_new_range(struct dm_integrity_c *ic, struct dm_integrity_range *new_range)\n{\n\tnew_range->waiting = true;\n\tlist_add_tail(&new_range->wait_entry, &ic->wait_list);\n\tnew_range->task = current;\n\tdo {\n\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock_irq(&ic->endio_wait.lock);\n\t\tio_schedule();\n\t\tspin_lock_irq(&ic->endio_wait.lock);\n\t} while (unlikely(new_range->waiting));\n}\n\nstatic void add_new_range_and_wait(struct dm_integrity_c *ic, struct dm_integrity_range *new_range)\n{\n\tif (unlikely(!add_new_range(ic, new_range, true)))\n\t\twait_and_add_new_range(ic, new_range);\n}\n\nstatic void init_journal_node(struct journal_node *node)\n{\n\tRB_CLEAR_NODE(&node->node);\n\tnode->sector = (sector_t)-1;\n}\n\nstatic void add_journal_node(struct dm_integrity_c *ic, struct journal_node *node, sector_t sector)\n{\n\tstruct rb_node **link;\n\tstruct rb_node *parent;\n\n\tnode->sector = sector;\n\tBUG_ON(!RB_EMPTY_NODE(&node->node));\n\n\tlink = &ic->journal_tree_root.rb_node;\n\tparent = NULL;\n\n\twhile (*link) {\n\t\tstruct journal_node *j;\n\n\t\tparent = *link;\n\t\tj = container_of(parent, struct journal_node, node);\n\t\tif (sector < j->sector)\n\t\t\tlink = &j->node.rb_left;\n\t\telse\n\t\t\tlink = &j->node.rb_right;\n\t}\n\n\trb_link_node(&node->node, parent, link);\n\trb_insert_color(&node->node, &ic->journal_tree_root);\n}\n\nstatic void remove_journal_node(struct dm_integrity_c *ic, struct journal_node *node)\n{\n\tBUG_ON(RB_EMPTY_NODE(&node->node));\n\trb_erase(&node->node, &ic->journal_tree_root);\n\tinit_journal_node(node);\n}\n\n#define NOT_FOUND\t(-1U)\n\nstatic unsigned int find_journal_node(struct dm_integrity_c *ic, sector_t sector, sector_t *next_sector)\n{\n\tstruct rb_node *n = ic->journal_tree_root.rb_node;\n\tunsigned int found = NOT_FOUND;\n\n\t*next_sector = (sector_t)-1;\n\twhile (n) {\n\t\tstruct journal_node *j = container_of(n, struct journal_node, node);\n\n\t\tif (sector == j->sector)\n\t\t\tfound = j - ic->journal_tree;\n\n\t\tif (sector < j->sector) {\n\t\t\t*next_sector = j->sector;\n\t\t\tn = j->node.rb_left;\n\t\t} else\n\t\t\tn = j->node.rb_right;\n\t}\n\n\treturn found;\n}\n\nstatic bool test_journal_node(struct dm_integrity_c *ic, unsigned int pos, sector_t sector)\n{\n\tstruct journal_node *node, *next_node;\n\tstruct rb_node *next;\n\n\tif (unlikely(pos >= ic->journal_entries))\n\t\treturn false;\n\tnode = &ic->journal_tree[pos];\n\tif (unlikely(RB_EMPTY_NODE(&node->node)))\n\t\treturn false;\n\tif (unlikely(node->sector != sector))\n\t\treturn false;\n\n\tnext = rb_next(&node->node);\n\tif (unlikely(!next))\n\t\treturn true;\n\n\tnext_node = container_of(next, struct journal_node, node);\n\treturn next_node->sector != sector;\n}\n\nstatic bool find_newer_committed_node(struct dm_integrity_c *ic, struct journal_node *node)\n{\n\tstruct rb_node *next;\n\tstruct journal_node *next_node;\n\tunsigned int next_section;\n\n\tBUG_ON(RB_EMPTY_NODE(&node->node));\n\n\tnext = rb_next(&node->node);\n\tif (unlikely(!next))\n\t\treturn false;\n\n\tnext_node = container_of(next, struct journal_node, node);\n\n\tif (next_node->sector != node->sector)\n\t\treturn false;\n\n\tnext_section = (unsigned int)(next_node - ic->journal_tree) / ic->journal_section_entries;\n\tif (next_section >= ic->committed_section &&\n\t    next_section < ic->committed_section + ic->n_committed_sections)\n\t\treturn true;\n\tif (next_section + ic->journal_sections < ic->committed_section + ic->n_committed_sections)\n\t\treturn true;\n\n\treturn false;\n}\n\n#define TAG_READ\t0\n#define TAG_WRITE\t1\n#define TAG_CMP\t\t2\n\nstatic int dm_integrity_rw_tag(struct dm_integrity_c *ic, unsigned char *tag, sector_t *metadata_block,\n\t\t\t       unsigned int *metadata_offset, unsigned int total_size, int op)\n{\n#define MAY_BE_FILLER\t\t1\n#define MAY_BE_HASH\t\t2\n\tunsigned int hash_offset = 0;\n\tunsigned int may_be = MAY_BE_HASH | (ic->discard ? MAY_BE_FILLER : 0);\n\n\tdo {\n\t\tunsigned char *data, *dp;\n\t\tstruct dm_buffer *b;\n\t\tunsigned int to_copy;\n\t\tint r;\n\n\t\tr = dm_integrity_failed(ic);\n\t\tif (unlikely(r))\n\t\t\treturn r;\n\n\t\tdata = dm_bufio_read(ic->bufio, *metadata_block, &b);\n\t\tif (IS_ERR(data))\n\t\t\treturn PTR_ERR(data);\n\n\t\tto_copy = min((1U << SECTOR_SHIFT << ic->log2_buffer_sectors) - *metadata_offset, total_size);\n\t\tdp = data + *metadata_offset;\n\t\tif (op == TAG_READ) {\n\t\t\tmemcpy(tag, dp, to_copy);\n\t\t} else if (op == TAG_WRITE) {\n\t\t\tif (memcmp(dp, tag, to_copy)) {\n\t\t\t\tmemcpy(dp, tag, to_copy);\n\t\t\t\tdm_bufio_mark_partial_buffer_dirty(b, *metadata_offset, *metadata_offset + to_copy);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\n\t\t\tif (likely(is_power_of_2(ic->tag_size))) {\n\t\t\t\tif (unlikely(memcmp(dp, tag, to_copy)))\n\t\t\t\t\tif (unlikely(!ic->discard) ||\n\t\t\t\t\t    unlikely(memchr_inv(dp, DISCARD_FILLER, to_copy) != NULL)) {\n\t\t\t\t\t\tgoto thorough_test;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunsigned int i, ts;\nthorough_test:\n\t\t\t\tts = total_size;\n\n\t\t\t\tfor (i = 0; i < to_copy; i++, ts--) {\n\t\t\t\t\tif (unlikely(dp[i] != tag[i]))\n\t\t\t\t\t\tmay_be &= ~MAY_BE_HASH;\n\t\t\t\t\tif (likely(dp[i] != DISCARD_FILLER))\n\t\t\t\t\t\tmay_be &= ~MAY_BE_FILLER;\n\t\t\t\t\thash_offset++;\n\t\t\t\t\tif (unlikely(hash_offset == ic->tag_size)) {\n\t\t\t\t\t\tif (unlikely(!may_be)) {\n\t\t\t\t\t\t\tdm_bufio_release(b);\n\t\t\t\t\t\t\treturn ts;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thash_offset = 0;\n\t\t\t\t\t\tmay_be = MAY_BE_HASH | (ic->discard ? MAY_BE_FILLER : 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdm_bufio_release(b);\n\n\t\ttag += to_copy;\n\t\t*metadata_offset += to_copy;\n\t\tif (unlikely(*metadata_offset == 1U << SECTOR_SHIFT << ic->log2_buffer_sectors)) {\n\t\t\t(*metadata_block)++;\n\t\t\t*metadata_offset = 0;\n\t\t}\n\n\t\tif (unlikely(!is_power_of_2(ic->tag_size)))\n\t\t\thash_offset = (hash_offset + to_copy) % ic->tag_size;\n\n\t\ttotal_size -= to_copy;\n\t} while (unlikely(total_size));\n\n\treturn 0;\n#undef MAY_BE_FILLER\n#undef MAY_BE_HASH\n}\n\nstruct flush_request {\n\tstruct dm_io_request io_req;\n\tstruct dm_io_region io_reg;\n\tstruct dm_integrity_c *ic;\n\tstruct completion comp;\n};\n\nstatic void flush_notify(unsigned long error, void *fr_)\n{\n\tstruct flush_request *fr = fr_;\n\n\tif (unlikely(error != 0))\n\t\tdm_integrity_io_error(fr->ic, \"flushing disk cache\", -EIO);\n\tcomplete(&fr->comp);\n}\n\nstatic void dm_integrity_flush_buffers(struct dm_integrity_c *ic, bool flush_data)\n{\n\tint r;\n\tstruct flush_request fr;\n\n\tif (!ic->meta_dev)\n\t\tflush_data = false;\n\tif (flush_data) {\n\t\tfr.io_req.bi_opf = REQ_OP_WRITE | REQ_PREFLUSH | REQ_SYNC,\n\t\tfr.io_req.mem.type = DM_IO_KMEM,\n\t\tfr.io_req.mem.ptr.addr = NULL,\n\t\tfr.io_req.notify.fn = flush_notify,\n\t\tfr.io_req.notify.context = &fr;\n\t\tfr.io_req.client = dm_bufio_get_dm_io_client(ic->bufio),\n\t\tfr.io_reg.bdev = ic->dev->bdev,\n\t\tfr.io_reg.sector = 0,\n\t\tfr.io_reg.count = 0,\n\t\tfr.ic = ic;\n\t\tinit_completion(&fr.comp);\n\t\tr = dm_io(&fr.io_req, 1, &fr.io_reg, NULL);\n\t\tBUG_ON(r);\n\t}\n\n\tr = dm_bufio_write_dirty_buffers(ic->bufio);\n\tif (unlikely(r))\n\t\tdm_integrity_io_error(ic, \"writing tags\", r);\n\n\tif (flush_data)\n\t\twait_for_completion(&fr.comp);\n}\n\nstatic void sleep_on_endio_wait(struct dm_integrity_c *ic)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\t__add_wait_queue(&ic->endio_wait, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock_irq(&ic->endio_wait.lock);\n\tio_schedule();\n\tspin_lock_irq(&ic->endio_wait.lock);\n\t__remove_wait_queue(&ic->endio_wait, &wait);\n}\n\nstatic void autocommit_fn(struct timer_list *t)\n{\n\tstruct dm_integrity_c *ic = from_timer(ic, t, autocommit_timer);\n\n\tif (likely(!dm_integrity_failed(ic)))\n\t\tqueue_work(ic->commit_wq, &ic->commit_work);\n}\n\nstatic void schedule_autocommit(struct dm_integrity_c *ic)\n{\n\tif (!timer_pending(&ic->autocommit_timer))\n\t\tmod_timer(&ic->autocommit_timer, jiffies + ic->autocommit_jiffies);\n}\n\nstatic void submit_flush_bio(struct dm_integrity_c *ic, struct dm_integrity_io *dio)\n{\n\tstruct bio *bio;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ic->endio_wait.lock, flags);\n\tbio = dm_bio_from_per_bio_data(dio, sizeof(struct dm_integrity_io));\n\tbio_list_add(&ic->flush_bio_list, bio);\n\tspin_unlock_irqrestore(&ic->endio_wait.lock, flags);\n\n\tqueue_work(ic->commit_wq, &ic->commit_work);\n}\n\nstatic void do_endio(struct dm_integrity_c *ic, struct bio *bio)\n{\n\tint r;\n\n\tr = dm_integrity_failed(ic);\n\tif (unlikely(r) && !bio->bi_status)\n\t\tbio->bi_status = errno_to_blk_status(r);\n\tif (unlikely(ic->synchronous_mode) && bio_op(bio) == REQ_OP_WRITE) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ic->endio_wait.lock, flags);\n\t\tbio_list_add(&ic->synchronous_bios, bio);\n\t\tqueue_delayed_work(ic->commit_wq, &ic->bitmap_flush_work, 0);\n\t\tspin_unlock_irqrestore(&ic->endio_wait.lock, flags);\n\t\treturn;\n\t}\n\tbio_endio(bio);\n}\n\nstatic void do_endio_flush(struct dm_integrity_c *ic, struct dm_integrity_io *dio)\n{\n\tstruct bio *bio = dm_bio_from_per_bio_data(dio, sizeof(struct dm_integrity_io));\n\n\tif (unlikely(dio->fua) && likely(!bio->bi_status) && likely(!dm_integrity_failed(ic)))\n\t\tsubmit_flush_bio(ic, dio);\n\telse\n\t\tdo_endio(ic, bio);\n}\n\nstatic void dec_in_flight(struct dm_integrity_io *dio)\n{\n\tif (atomic_dec_and_test(&dio->in_flight)) {\n\t\tstruct dm_integrity_c *ic = dio->ic;\n\t\tstruct bio *bio;\n\n\t\tremove_range(ic, &dio->range);\n\n\t\tif (dio->op == REQ_OP_WRITE || unlikely(dio->op == REQ_OP_DISCARD))\n\t\t\tschedule_autocommit(ic);\n\n\t\tbio = dm_bio_from_per_bio_data(dio, sizeof(struct dm_integrity_io));\n\t\tif (unlikely(dio->bi_status) && !bio->bi_status)\n\t\t\tbio->bi_status = dio->bi_status;\n\t\tif (likely(!bio->bi_status) && unlikely(bio_sectors(bio) != dio->range.n_sectors)) {\n\t\t\tdio->range.logical_sector += dio->range.n_sectors;\n\t\t\tbio_advance(bio, dio->range.n_sectors << SECTOR_SHIFT);\n\t\t\tINIT_WORK(&dio->work, integrity_bio_wait);\n\t\t\tqueue_work(ic->offload_wq, &dio->work);\n\t\t\treturn;\n\t\t}\n\t\tdo_endio_flush(ic, dio);\n\t}\n}\n\nstatic void integrity_end_io(struct bio *bio)\n{\n\tstruct dm_integrity_io *dio = dm_per_bio_data(bio, sizeof(struct dm_integrity_io));\n\n\tdm_bio_restore(&dio->bio_details, bio);\n\tif (bio->bi_integrity)\n\t\tbio->bi_opf |= REQ_INTEGRITY;\n\n\tif (dio->completion)\n\t\tcomplete(dio->completion);\n\n\tdec_in_flight(dio);\n}\n\nstatic void integrity_sector_checksum(struct dm_integrity_c *ic, sector_t sector,\n\t\t\t\t      const char *data, char *result)\n{\n\t__le64 sector_le = cpu_to_le64(sector);\n\tSHASH_DESC_ON_STACK(req, ic->internal_hash);\n\tint r;\n\tunsigned int digest_size;\n\n\treq->tfm = ic->internal_hash;\n\n\tr = crypto_shash_init(req);\n\tif (unlikely(r < 0)) {\n\t\tdm_integrity_io_error(ic, \"crypto_shash_init\", r);\n\t\tgoto failed;\n\t}\n\n\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_HMAC)) {\n\t\tr = crypto_shash_update(req, (__u8 *)&ic->sb->salt, SALT_SIZE);\n\t\tif (unlikely(r < 0)) {\n\t\t\tdm_integrity_io_error(ic, \"crypto_shash_update\", r);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tr = crypto_shash_update(req, (const __u8 *)&sector_le, sizeof(sector_le));\n\tif (unlikely(r < 0)) {\n\t\tdm_integrity_io_error(ic, \"crypto_shash_update\", r);\n\t\tgoto failed;\n\t}\n\n\tr = crypto_shash_update(req, data, ic->sectors_per_block << SECTOR_SHIFT);\n\tif (unlikely(r < 0)) {\n\t\tdm_integrity_io_error(ic, \"crypto_shash_update\", r);\n\t\tgoto failed;\n\t}\n\n\tr = crypto_shash_final(req, result);\n\tif (unlikely(r < 0)) {\n\t\tdm_integrity_io_error(ic, \"crypto_shash_final\", r);\n\t\tgoto failed;\n\t}\n\n\tdigest_size = crypto_shash_digestsize(ic->internal_hash);\n\tif (unlikely(digest_size < ic->tag_size))\n\t\tmemset(result + digest_size, 0, ic->tag_size - digest_size);\n\n\treturn;\n\nfailed:\n\t \n\tget_random_bytes(result, ic->tag_size);\n}\n\nstatic void integrity_metadata(struct work_struct *w)\n{\n\tstruct dm_integrity_io *dio = container_of(w, struct dm_integrity_io, work);\n\tstruct dm_integrity_c *ic = dio->ic;\n\n\tint r;\n\n\tif (ic->internal_hash) {\n\t\tstruct bvec_iter iter;\n\t\tstruct bio_vec bv;\n\t\tunsigned int digest_size = crypto_shash_digestsize(ic->internal_hash);\n\t\tstruct bio *bio = dm_bio_from_per_bio_data(dio, sizeof(struct dm_integrity_io));\n\t\tchar *checksums;\n\t\tunsigned int extra_space = unlikely(digest_size > ic->tag_size) ? digest_size - ic->tag_size : 0;\n\t\tchar checksums_onstack[max_t(size_t, HASH_MAX_DIGESTSIZE, MAX_TAG_SIZE)];\n\t\tsector_t sector;\n\t\tunsigned int sectors_to_process;\n\n\t\tif (unlikely(ic->mode == 'R'))\n\t\t\tgoto skip_io;\n\n\t\tif (likely(dio->op != REQ_OP_DISCARD))\n\t\t\tchecksums = kmalloc((PAGE_SIZE >> SECTOR_SHIFT >> ic->sb->log2_sectors_per_block) * ic->tag_size + extra_space,\n\t\t\t\t\t    GFP_NOIO | __GFP_NORETRY | __GFP_NOWARN);\n\t\telse\n\t\t\tchecksums = kmalloc(PAGE_SIZE, GFP_NOIO | __GFP_NORETRY | __GFP_NOWARN);\n\t\tif (!checksums) {\n\t\t\tchecksums = checksums_onstack;\n\t\t\tif (WARN_ON(extra_space &&\n\t\t\t\t    digest_size > sizeof(checksums_onstack))) {\n\t\t\t\tr = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(dio->op == REQ_OP_DISCARD)) {\n\t\t\tunsigned int bi_size = dio->bio_details.bi_iter.bi_size;\n\t\t\tunsigned int max_size = likely(checksums != checksums_onstack) ? PAGE_SIZE : HASH_MAX_DIGESTSIZE;\n\t\t\tunsigned int max_blocks = max_size / ic->tag_size;\n\n\t\t\tmemset(checksums, DISCARD_FILLER, max_size);\n\n\t\t\twhile (bi_size) {\n\t\t\t\tunsigned int this_step_blocks = bi_size >> (SECTOR_SHIFT + ic->sb->log2_sectors_per_block);\n\n\t\t\t\tthis_step_blocks = min(this_step_blocks, max_blocks);\n\t\t\t\tr = dm_integrity_rw_tag(ic, checksums, &dio->metadata_block, &dio->metadata_offset,\n\t\t\t\t\t\t\tthis_step_blocks * ic->tag_size, TAG_WRITE);\n\t\t\t\tif (unlikely(r)) {\n\t\t\t\t\tif (likely(checksums != checksums_onstack))\n\t\t\t\t\t\tkfree(checksums);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\n\t\t\t\tbi_size -= this_step_blocks << (SECTOR_SHIFT + ic->sb->log2_sectors_per_block);\n\t\t\t}\n\n\t\t\tif (likely(checksums != checksums_onstack))\n\t\t\t\tkfree(checksums);\n\t\t\tgoto skip_io;\n\t\t}\n\n\t\tsector = dio->range.logical_sector;\n\t\tsectors_to_process = dio->range.n_sectors;\n\n\t\t__bio_for_each_segment(bv, bio, iter, dio->bio_details.bi_iter) {\n\t\t\tstruct bio_vec bv_copy = bv;\n\t\t\tunsigned int pos;\n\t\t\tchar *mem, *checksums_ptr;\n\nagain:\n\t\t\tmem = bvec_kmap_local(&bv_copy);\n\t\t\tpos = 0;\n\t\t\tchecksums_ptr = checksums;\n\t\t\tdo {\n\t\t\t\tintegrity_sector_checksum(ic, sector, mem + pos, checksums_ptr);\n\t\t\t\tchecksums_ptr += ic->tag_size;\n\t\t\t\tsectors_to_process -= ic->sectors_per_block;\n\t\t\t\tpos += ic->sectors_per_block << SECTOR_SHIFT;\n\t\t\t\tsector += ic->sectors_per_block;\n\t\t\t} while (pos < bv_copy.bv_len && sectors_to_process && checksums != checksums_onstack);\n\t\t\tkunmap_local(mem);\n\n\t\t\tr = dm_integrity_rw_tag(ic, checksums, &dio->metadata_block, &dio->metadata_offset,\n\t\t\t\t\t\tchecksums_ptr - checksums, dio->op == REQ_OP_READ ? TAG_CMP : TAG_WRITE);\n\t\t\tif (unlikely(r)) {\n\t\t\t\tif (r > 0) {\n\t\t\t\t\tsector_t s;\n\n\t\t\t\t\ts = sector - ((r + ic->tag_size - 1) / ic->tag_size);\n\t\t\t\t\tDMERR_LIMIT(\"%pg: Checksum failed at sector 0x%llx\",\n\t\t\t\t\t\t    bio->bi_bdev, s);\n\t\t\t\t\tr = -EILSEQ;\n\t\t\t\t\tatomic64_inc(&ic->number_of_mismatches);\n\t\t\t\t\tdm_audit_log_bio(DM_MSG_PREFIX, \"integrity-checksum\",\n\t\t\t\t\t\t\t bio, s, 0);\n\t\t\t\t}\n\t\t\t\tif (likely(checksums != checksums_onstack))\n\t\t\t\t\tkfree(checksums);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (!sectors_to_process)\n\t\t\t\tbreak;\n\n\t\t\tif (unlikely(pos < bv_copy.bv_len)) {\n\t\t\t\tbv_copy.bv_offset += pos;\n\t\t\t\tbv_copy.bv_len -= pos;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\n\t\tif (likely(checksums != checksums_onstack))\n\t\t\tkfree(checksums);\n\t} else {\n\t\tstruct bio_integrity_payload *bip = dio->bio_details.bi_integrity;\n\n\t\tif (bip) {\n\t\t\tstruct bio_vec biv;\n\t\t\tstruct bvec_iter iter;\n\t\t\tunsigned int data_to_process = dio->range.n_sectors;\n\n\t\t\tsector_to_block(ic, data_to_process);\n\t\t\tdata_to_process *= ic->tag_size;\n\n\t\t\tbip_for_each_vec(biv, bip, iter) {\n\t\t\t\tunsigned char *tag;\n\t\t\t\tunsigned int this_len;\n\n\t\t\t\tBUG_ON(PageHighMem(biv.bv_page));\n\t\t\t\ttag = bvec_virt(&biv);\n\t\t\t\tthis_len = min(biv.bv_len, data_to_process);\n\t\t\t\tr = dm_integrity_rw_tag(ic, tag, &dio->metadata_block, &dio->metadata_offset,\n\t\t\t\t\t\t\tthis_len, dio->op == REQ_OP_READ ? TAG_READ : TAG_WRITE);\n\t\t\t\tif (unlikely(r))\n\t\t\t\t\tgoto error;\n\t\t\t\tdata_to_process -= this_len;\n\t\t\t\tif (!data_to_process)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nskip_io:\n\tdec_in_flight(dio);\n\treturn;\nerror:\n\tdio->bi_status = errno_to_blk_status(r);\n\tdec_in_flight(dio);\n}\n\nstatic int dm_integrity_map(struct dm_target *ti, struct bio *bio)\n{\n\tstruct dm_integrity_c *ic = ti->private;\n\tstruct dm_integrity_io *dio = dm_per_bio_data(bio, sizeof(struct dm_integrity_io));\n\tstruct bio_integrity_payload *bip;\n\n\tsector_t area, offset;\n\n\tdio->ic = ic;\n\tdio->bi_status = 0;\n\tdio->op = bio_op(bio);\n\n\tif (unlikely(dio->op == REQ_OP_DISCARD)) {\n\t\tif (ti->max_io_len) {\n\t\t\tsector_t sec = dm_target_offset(ti, bio->bi_iter.bi_sector);\n\t\t\tunsigned int log2_max_io_len = __fls(ti->max_io_len);\n\t\t\tsector_t start_boundary = sec >> log2_max_io_len;\n\t\t\tsector_t end_boundary = (sec + bio_sectors(bio) - 1) >> log2_max_io_len;\n\n\t\t\tif (start_boundary < end_boundary) {\n\t\t\t\tsector_t len = ti->max_io_len - (sec & (ti->max_io_len - 1));\n\n\t\t\t\tdm_accept_partial_bio(bio, len);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(bio->bi_opf & REQ_PREFLUSH)) {\n\t\tsubmit_flush_bio(ic, dio);\n\t\treturn DM_MAPIO_SUBMITTED;\n\t}\n\n\tdio->range.logical_sector = dm_target_offset(ti, bio->bi_iter.bi_sector);\n\tdio->fua = dio->op == REQ_OP_WRITE && bio->bi_opf & REQ_FUA;\n\tif (unlikely(dio->fua)) {\n\t\t \n\t\tbio->bi_opf &= ~REQ_FUA;\n\t}\n\tif (unlikely(dio->range.logical_sector + bio_sectors(bio) > ic->provided_data_sectors)) {\n\t\tDMERR(\"Too big sector number: 0x%llx + 0x%x > 0x%llx\",\n\t\t      dio->range.logical_sector, bio_sectors(bio),\n\t\t      ic->provided_data_sectors);\n\t\treturn DM_MAPIO_KILL;\n\t}\n\tif (unlikely((dio->range.logical_sector | bio_sectors(bio)) & (unsigned int)(ic->sectors_per_block - 1))) {\n\t\tDMERR(\"Bio not aligned on %u sectors: 0x%llx, 0x%x\",\n\t\t      ic->sectors_per_block,\n\t\t      dio->range.logical_sector, bio_sectors(bio));\n\t\treturn DM_MAPIO_KILL;\n\t}\n\n\tif (ic->sectors_per_block > 1 && likely(dio->op != REQ_OP_DISCARD)) {\n\t\tstruct bvec_iter iter;\n\t\tstruct bio_vec bv;\n\n\t\tbio_for_each_segment(bv, bio, iter) {\n\t\t\tif (unlikely(bv.bv_len & ((ic->sectors_per_block << SECTOR_SHIFT) - 1))) {\n\t\t\t\tDMERR(\"Bio vector (%u,%u) is not aligned on %u-sector boundary\",\n\t\t\t\t\tbv.bv_offset, bv.bv_len, ic->sectors_per_block);\n\t\t\t\treturn DM_MAPIO_KILL;\n\t\t\t}\n\t\t}\n\t}\n\n\tbip = bio_integrity(bio);\n\tif (!ic->internal_hash) {\n\t\tif (bip) {\n\t\t\tunsigned int wanted_tag_size = bio_sectors(bio) >> ic->sb->log2_sectors_per_block;\n\n\t\t\tif (ic->log2_tag_size >= 0)\n\t\t\t\twanted_tag_size <<= ic->log2_tag_size;\n\t\t\telse\n\t\t\t\twanted_tag_size *= ic->tag_size;\n\t\t\tif (unlikely(wanted_tag_size != bip->bip_iter.bi_size)) {\n\t\t\t\tDMERR(\"Invalid integrity data size %u, expected %u\",\n\t\t\t\t      bip->bip_iter.bi_size, wanted_tag_size);\n\t\t\t\treturn DM_MAPIO_KILL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (unlikely(bip != NULL)) {\n\t\t\tDMERR(\"Unexpected integrity data when using internal hash\");\n\t\t\treturn DM_MAPIO_KILL;\n\t\t}\n\t}\n\n\tif (unlikely(ic->mode == 'R') && unlikely(dio->op != REQ_OP_READ))\n\t\treturn DM_MAPIO_KILL;\n\n\tget_area_and_offset(ic, dio->range.logical_sector, &area, &offset);\n\tdio->metadata_block = get_metadata_sector_and_offset(ic, area, offset, &dio->metadata_offset);\n\tbio->bi_iter.bi_sector = get_data_sector(ic, area, offset);\n\n\tdm_integrity_map_continue(dio, true);\n\treturn DM_MAPIO_SUBMITTED;\n}\n\nstatic bool __journal_read_write(struct dm_integrity_io *dio, struct bio *bio,\n\t\t\t\t unsigned int journal_section, unsigned int journal_entry)\n{\n\tstruct dm_integrity_c *ic = dio->ic;\n\tsector_t logical_sector;\n\tunsigned int n_sectors;\n\n\tlogical_sector = dio->range.logical_sector;\n\tn_sectors = dio->range.n_sectors;\n\tdo {\n\t\tstruct bio_vec bv = bio_iovec(bio);\n\t\tchar *mem;\n\n\t\tif (unlikely(bv.bv_len >> SECTOR_SHIFT > n_sectors))\n\t\t\tbv.bv_len = n_sectors << SECTOR_SHIFT;\n\t\tn_sectors -= bv.bv_len >> SECTOR_SHIFT;\n\t\tbio_advance_iter(bio, &bio->bi_iter, bv.bv_len);\nretry_kmap:\n\t\tmem = kmap_local_page(bv.bv_page);\n\t\tif (likely(dio->op == REQ_OP_WRITE))\n\t\t\tflush_dcache_page(bv.bv_page);\n\n\t\tdo {\n\t\t\tstruct journal_entry *je = access_journal_entry(ic, journal_section, journal_entry);\n\n\t\t\tif (unlikely(dio->op == REQ_OP_READ)) {\n\t\t\t\tstruct journal_sector *js;\n\t\t\t\tchar *mem_ptr;\n\t\t\t\tunsigned int s;\n\n\t\t\t\tif (unlikely(journal_entry_is_inprogress(je))) {\n\t\t\t\t\tflush_dcache_page(bv.bv_page);\n\t\t\t\t\tkunmap_local(mem);\n\n\t\t\t\t\t__io_wait_event(ic->copy_to_journal_wait, !journal_entry_is_inprogress(je));\n\t\t\t\t\tgoto retry_kmap;\n\t\t\t\t}\n\t\t\t\tsmp_rmb();\n\t\t\t\tBUG_ON(journal_entry_get_sector(je) != logical_sector);\n\t\t\t\tjs = access_journal_data(ic, journal_section, journal_entry);\n\t\t\t\tmem_ptr = mem + bv.bv_offset;\n\t\t\t\ts = 0;\n\t\t\t\tdo {\n\t\t\t\t\tmemcpy(mem_ptr, js, JOURNAL_SECTOR_DATA);\n\t\t\t\t\t*(commit_id_t *)(mem_ptr + JOURNAL_SECTOR_DATA) = je->last_bytes[s];\n\t\t\t\t\tjs++;\n\t\t\t\t\tmem_ptr += 1 << SECTOR_SHIFT;\n\t\t\t\t} while (++s < ic->sectors_per_block);\n#ifdef INTERNAL_VERIFY\n\t\t\t\tif (ic->internal_hash) {\n\t\t\t\t\tchar checksums_onstack[max_t(size_t, HASH_MAX_DIGESTSIZE, MAX_TAG_SIZE)];\n\n\t\t\t\t\tintegrity_sector_checksum(ic, logical_sector, mem + bv.bv_offset, checksums_onstack);\n\t\t\t\t\tif (unlikely(memcmp(checksums_onstack, journal_entry_tag(ic, je), ic->tag_size))) {\n\t\t\t\t\t\tDMERR_LIMIT(\"Checksum failed when reading from journal, at sector 0x%llx\",\n\t\t\t\t\t\t\t    logical_sector);\n\t\t\t\t\t\tdm_audit_log_bio(DM_MSG_PREFIX, \"journal-checksum\",\n\t\t\t\t\t\t\t\t bio, logical_sector, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\n\t\t\tif (!ic->internal_hash) {\n\t\t\t\tstruct bio_integrity_payload *bip = bio_integrity(bio);\n\t\t\t\tunsigned int tag_todo = ic->tag_size;\n\t\t\t\tchar *tag_ptr = journal_entry_tag(ic, je);\n\n\t\t\t\tif (bip) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tstruct bio_vec biv = bvec_iter_bvec(bip->bip_vec, bip->bip_iter);\n\t\t\t\t\t\tunsigned int tag_now = min(biv.bv_len, tag_todo);\n\t\t\t\t\t\tchar *tag_addr;\n\n\t\t\t\t\t\tBUG_ON(PageHighMem(biv.bv_page));\n\t\t\t\t\t\ttag_addr = bvec_virt(&biv);\n\t\t\t\t\t\tif (likely(dio->op == REQ_OP_WRITE))\n\t\t\t\t\t\t\tmemcpy(tag_ptr, tag_addr, tag_now);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmemcpy(tag_addr, tag_ptr, tag_now);\n\t\t\t\t\t\tbvec_iter_advance(bip->bip_vec, &bip->bip_iter, tag_now);\n\t\t\t\t\t\ttag_ptr += tag_now;\n\t\t\t\t\t\ttag_todo -= tag_now;\n\t\t\t\t\t} while (unlikely(tag_todo));\n\t\t\t\t} else if (likely(dio->op == REQ_OP_WRITE))\n\t\t\t\t\tmemset(tag_ptr, 0, tag_todo);\n\t\t\t}\n\n\t\t\tif (likely(dio->op == REQ_OP_WRITE)) {\n\t\t\t\tstruct journal_sector *js;\n\t\t\t\tunsigned int s;\n\n\t\t\t\tjs = access_journal_data(ic, journal_section, journal_entry);\n\t\t\t\tmemcpy(js, mem + bv.bv_offset, ic->sectors_per_block << SECTOR_SHIFT);\n\n\t\t\t\ts = 0;\n\t\t\t\tdo {\n\t\t\t\t\tje->last_bytes[s] = js[s].commit_id;\n\t\t\t\t} while (++s < ic->sectors_per_block);\n\n\t\t\t\tif (ic->internal_hash) {\n\t\t\t\t\tunsigned int digest_size = crypto_shash_digestsize(ic->internal_hash);\n\n\t\t\t\t\tif (unlikely(digest_size > ic->tag_size)) {\n\t\t\t\t\t\tchar checksums_onstack[HASH_MAX_DIGESTSIZE];\n\n\t\t\t\t\t\tintegrity_sector_checksum(ic, logical_sector, (char *)js, checksums_onstack);\n\t\t\t\t\t\tmemcpy(journal_entry_tag(ic, je), checksums_onstack, ic->tag_size);\n\t\t\t\t\t} else\n\t\t\t\t\t\tintegrity_sector_checksum(ic, logical_sector, (char *)js, journal_entry_tag(ic, je));\n\t\t\t\t}\n\n\t\t\t\tjournal_entry_set_sector(je, logical_sector);\n\t\t\t}\n\t\t\tlogical_sector += ic->sectors_per_block;\n\n\t\t\tjournal_entry++;\n\t\t\tif (unlikely(journal_entry == ic->journal_section_entries)) {\n\t\t\t\tjournal_entry = 0;\n\t\t\t\tjournal_section++;\n\t\t\t\twraparound_section(ic, &journal_section);\n\t\t\t}\n\n\t\t\tbv.bv_offset += ic->sectors_per_block << SECTOR_SHIFT;\n\t\t} while (bv.bv_len -= ic->sectors_per_block << SECTOR_SHIFT);\n\n\t\tif (unlikely(dio->op == REQ_OP_READ))\n\t\t\tflush_dcache_page(bv.bv_page);\n\t\tkunmap_local(mem);\n\t} while (n_sectors);\n\n\tif (likely(dio->op == REQ_OP_WRITE)) {\n\t\tsmp_mb();\n\t\tif (unlikely(waitqueue_active(&ic->copy_to_journal_wait)))\n\t\t\twake_up(&ic->copy_to_journal_wait);\n\t\tif (READ_ONCE(ic->free_sectors) <= ic->free_sectors_threshold)\n\t\t\tqueue_work(ic->commit_wq, &ic->commit_work);\n\t\telse\n\t\t\tschedule_autocommit(ic);\n\t} else\n\t\tremove_range(ic, &dio->range);\n\n\tif (unlikely(bio->bi_iter.bi_size)) {\n\t\tsector_t area, offset;\n\n\t\tdio->range.logical_sector = logical_sector;\n\t\tget_area_and_offset(ic, dio->range.logical_sector, &area, &offset);\n\t\tdio->metadata_block = get_metadata_sector_and_offset(ic, area, offset, &dio->metadata_offset);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void dm_integrity_map_continue(struct dm_integrity_io *dio, bool from_map)\n{\n\tstruct dm_integrity_c *ic = dio->ic;\n\tstruct bio *bio = dm_bio_from_per_bio_data(dio, sizeof(struct dm_integrity_io));\n\tunsigned int journal_section, journal_entry;\n\tunsigned int journal_read_pos;\n\tstruct completion read_comp;\n\tbool discard_retried = false;\n\tbool need_sync_io = ic->internal_hash && dio->op == REQ_OP_READ;\n\n\tif (unlikely(dio->op == REQ_OP_DISCARD) && ic->mode != 'D')\n\t\tneed_sync_io = true;\n\n\tif (need_sync_io && from_map) {\n\t\tINIT_WORK(&dio->work, integrity_bio_wait);\n\t\tqueue_work(ic->offload_wq, &dio->work);\n\t\treturn;\n\t}\n\nlock_retry:\n\tspin_lock_irq(&ic->endio_wait.lock);\nretry:\n\tif (unlikely(dm_integrity_failed(ic))) {\n\t\tspin_unlock_irq(&ic->endio_wait.lock);\n\t\tdo_endio(ic, bio);\n\t\treturn;\n\t}\n\tdio->range.n_sectors = bio_sectors(bio);\n\tjournal_read_pos = NOT_FOUND;\n\tif (ic->mode == 'J' && likely(dio->op != REQ_OP_DISCARD)) {\n\t\tif (dio->op == REQ_OP_WRITE) {\n\t\t\tunsigned int next_entry, i, pos;\n\t\t\tunsigned int ws, we, range_sectors;\n\n\t\t\tdio->range.n_sectors = min(dio->range.n_sectors,\n\t\t\t\t\t\t   (sector_t)ic->free_sectors << ic->sb->log2_sectors_per_block);\n\t\t\tif (unlikely(!dio->range.n_sectors)) {\n\t\t\t\tif (from_map)\n\t\t\t\t\tgoto offload_to_thread;\n\t\t\t\tsleep_on_endio_wait(ic);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\trange_sectors = dio->range.n_sectors >> ic->sb->log2_sectors_per_block;\n\t\t\tic->free_sectors -= range_sectors;\n\t\t\tjournal_section = ic->free_section;\n\t\t\tjournal_entry = ic->free_section_entry;\n\n\t\t\tnext_entry = ic->free_section_entry + range_sectors;\n\t\t\tic->free_section_entry = next_entry % ic->journal_section_entries;\n\t\t\tic->free_section += next_entry / ic->journal_section_entries;\n\t\t\tic->n_uncommitted_sections += next_entry / ic->journal_section_entries;\n\t\t\twraparound_section(ic, &ic->free_section);\n\n\t\t\tpos = journal_section * ic->journal_section_entries + journal_entry;\n\t\t\tws = journal_section;\n\t\t\twe = journal_entry;\n\t\t\ti = 0;\n\t\t\tdo {\n\t\t\t\tstruct journal_entry *je;\n\n\t\t\t\tadd_journal_node(ic, &ic->journal_tree[pos], dio->range.logical_sector + i);\n\t\t\t\tpos++;\n\t\t\t\tif (unlikely(pos >= ic->journal_entries))\n\t\t\t\t\tpos = 0;\n\n\t\t\t\tje = access_journal_entry(ic, ws, we);\n\t\t\t\tBUG_ON(!journal_entry_is_unused(je));\n\t\t\t\tjournal_entry_set_inprogress(je);\n\t\t\t\twe++;\n\t\t\t\tif (unlikely(we == ic->journal_section_entries)) {\n\t\t\t\t\twe = 0;\n\t\t\t\t\tws++;\n\t\t\t\t\twraparound_section(ic, &ws);\n\t\t\t\t}\n\t\t\t} while ((i += ic->sectors_per_block) < dio->range.n_sectors);\n\n\t\t\tspin_unlock_irq(&ic->endio_wait.lock);\n\t\t\tgoto journal_read_write;\n\t\t} else {\n\t\t\tsector_t next_sector;\n\n\t\t\tjournal_read_pos = find_journal_node(ic, dio->range.logical_sector, &next_sector);\n\t\t\tif (likely(journal_read_pos == NOT_FOUND)) {\n\t\t\t\tif (unlikely(dio->range.n_sectors > next_sector - dio->range.logical_sector))\n\t\t\t\t\tdio->range.n_sectors = next_sector - dio->range.logical_sector;\n\t\t\t} else {\n\t\t\t\tunsigned int i;\n\t\t\t\tunsigned int jp = journal_read_pos + 1;\n\n\t\t\t\tfor (i = ic->sectors_per_block; i < dio->range.n_sectors; i += ic->sectors_per_block, jp++) {\n\t\t\t\t\tif (!test_journal_node(ic, jp, dio->range.logical_sector + i))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdio->range.n_sectors = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (unlikely(!add_new_range(ic, &dio->range, true))) {\n\t\t \n\t\tif (from_map) {\noffload_to_thread:\n\t\t\tspin_unlock_irq(&ic->endio_wait.lock);\n\t\t\tINIT_WORK(&dio->work, integrity_bio_wait);\n\t\t\tqueue_work(ic->wait_wq, &dio->work);\n\t\t\treturn;\n\t\t}\n\t\tif (journal_read_pos != NOT_FOUND)\n\t\t\tdio->range.n_sectors = ic->sectors_per_block;\n\t\twait_and_add_new_range(ic, &dio->range);\n\t\t \n\t\tif (journal_read_pos != NOT_FOUND) {\n\t\t\tsector_t next_sector;\n\t\t\tunsigned int new_pos;\n\n\t\t\tnew_pos = find_journal_node(ic, dio->range.logical_sector, &next_sector);\n\t\t\tif (unlikely(new_pos != journal_read_pos)) {\n\t\t\t\tremove_range_unlocked(ic, &dio->range);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\tif (ic->mode == 'J' && likely(dio->op == REQ_OP_DISCARD) && !discard_retried) {\n\t\tsector_t next_sector;\n\t\tunsigned int new_pos;\n\n\t\tnew_pos = find_journal_node(ic, dio->range.logical_sector, &next_sector);\n\t\tif (unlikely(new_pos != NOT_FOUND) ||\n\t\t    unlikely(next_sector < dio->range.logical_sector - dio->range.n_sectors)) {\n\t\t\tremove_range_unlocked(ic, &dio->range);\n\t\t\tspin_unlock_irq(&ic->endio_wait.lock);\n\t\t\tqueue_work(ic->commit_wq, &ic->commit_work);\n\t\t\tflush_workqueue(ic->commit_wq);\n\t\t\tqueue_work(ic->writer_wq, &ic->writer_work);\n\t\t\tflush_workqueue(ic->writer_wq);\n\t\t\tdiscard_retried = true;\n\t\t\tgoto lock_retry;\n\t\t}\n\t}\n\tspin_unlock_irq(&ic->endio_wait.lock);\n\n\tif (unlikely(journal_read_pos != NOT_FOUND)) {\n\t\tjournal_section = journal_read_pos / ic->journal_section_entries;\n\t\tjournal_entry = journal_read_pos % ic->journal_section_entries;\n\t\tgoto journal_read_write;\n\t}\n\n\tif (ic->mode == 'B' && (dio->op == REQ_OP_WRITE || unlikely(dio->op == REQ_OP_DISCARD))) {\n\t\tif (!block_bitmap_op(ic, ic->may_write_bitmap, dio->range.logical_sector,\n\t\t\t\t     dio->range.n_sectors, BITMAP_OP_TEST_ALL_SET)) {\n\t\t\tstruct bitmap_block_status *bbs;\n\n\t\t\tbbs = sector_to_bitmap_block(ic, dio->range.logical_sector);\n\t\t\tspin_lock(&bbs->bio_queue_lock);\n\t\t\tbio_list_add(&bbs->bio_queue, bio);\n\t\t\tspin_unlock(&bbs->bio_queue_lock);\n\t\t\tqueue_work(ic->writer_wq, &bbs->work);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdio->in_flight = (atomic_t)ATOMIC_INIT(2);\n\n\tif (need_sync_io) {\n\t\tinit_completion(&read_comp);\n\t\tdio->completion = &read_comp;\n\t} else\n\t\tdio->completion = NULL;\n\n\tdm_bio_record(&dio->bio_details, bio);\n\tbio_set_dev(bio, ic->dev->bdev);\n\tbio->bi_integrity = NULL;\n\tbio->bi_opf &= ~REQ_INTEGRITY;\n\tbio->bi_end_io = integrity_end_io;\n\tbio->bi_iter.bi_size = dio->range.n_sectors << SECTOR_SHIFT;\n\n\tif (unlikely(dio->op == REQ_OP_DISCARD) && likely(ic->mode != 'D')) {\n\t\tintegrity_metadata(&dio->work);\n\t\tdm_integrity_flush_buffers(ic, false);\n\n\t\tdio->in_flight = (atomic_t)ATOMIC_INIT(1);\n\t\tdio->completion = NULL;\n\n\t\tsubmit_bio_noacct(bio);\n\n\t\treturn;\n\t}\n\n\tsubmit_bio_noacct(bio);\n\n\tif (need_sync_io) {\n\t\twait_for_completion_io(&read_comp);\n\t\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING) &&\n\t\t    dio->range.logical_sector + dio->range.n_sectors > le64_to_cpu(ic->sb->recalc_sector))\n\t\t\tgoto skip_check;\n\t\tif (ic->mode == 'B') {\n\t\t\tif (!block_bitmap_op(ic, ic->recalc_bitmap, dio->range.logical_sector,\n\t\t\t\t\t     dio->range.n_sectors, BITMAP_OP_TEST_ALL_CLEAR))\n\t\t\t\tgoto skip_check;\n\t\t}\n\n\t\tif (likely(!bio->bi_status))\n\t\t\tintegrity_metadata(&dio->work);\n\t\telse\nskip_check:\n\t\t\tdec_in_flight(dio);\n\t} else {\n\t\tINIT_WORK(&dio->work, integrity_metadata);\n\t\tqueue_work(ic->metadata_wq, &dio->work);\n\t}\n\n\treturn;\n\njournal_read_write:\n\tif (unlikely(__journal_read_write(dio, bio, journal_section, journal_entry)))\n\t\tgoto lock_retry;\n\n\tdo_endio_flush(ic, dio);\n}\n\n\nstatic void integrity_bio_wait(struct work_struct *w)\n{\n\tstruct dm_integrity_io *dio = container_of(w, struct dm_integrity_io, work);\n\n\tdm_integrity_map_continue(dio, false);\n}\n\nstatic void pad_uncommitted(struct dm_integrity_c *ic)\n{\n\tif (ic->free_section_entry) {\n\t\tic->free_sectors -= ic->journal_section_entries - ic->free_section_entry;\n\t\tic->free_section_entry = 0;\n\t\tic->free_section++;\n\t\twraparound_section(ic, &ic->free_section);\n\t\tic->n_uncommitted_sections++;\n\t}\n\tif (WARN_ON(ic->journal_sections * ic->journal_section_entries !=\n\t\t    (ic->n_uncommitted_sections + ic->n_committed_sections) *\n\t\t    ic->journal_section_entries + ic->free_sectors)) {\n\t\tDMCRIT(\"journal_sections %u, journal_section_entries %u, \"\n\t\t       \"n_uncommitted_sections %u, n_committed_sections %u, \"\n\t\t       \"journal_section_entries %u, free_sectors %u\",\n\t\t       ic->journal_sections, ic->journal_section_entries,\n\t\t       ic->n_uncommitted_sections, ic->n_committed_sections,\n\t\t       ic->journal_section_entries, ic->free_sectors);\n\t}\n}\n\nstatic void integrity_commit(struct work_struct *w)\n{\n\tstruct dm_integrity_c *ic = container_of(w, struct dm_integrity_c, commit_work);\n\tunsigned int commit_start, commit_sections;\n\tunsigned int i, j, n;\n\tstruct bio *flushes;\n\n\tdel_timer(&ic->autocommit_timer);\n\n\tspin_lock_irq(&ic->endio_wait.lock);\n\tflushes = bio_list_get(&ic->flush_bio_list);\n\tif (unlikely(ic->mode != 'J')) {\n\t\tspin_unlock_irq(&ic->endio_wait.lock);\n\t\tdm_integrity_flush_buffers(ic, true);\n\t\tgoto release_flush_bios;\n\t}\n\n\tpad_uncommitted(ic);\n\tcommit_start = ic->uncommitted_section;\n\tcommit_sections = ic->n_uncommitted_sections;\n\tspin_unlock_irq(&ic->endio_wait.lock);\n\n\tif (!commit_sections)\n\t\tgoto release_flush_bios;\n\n\tic->wrote_to_journal = true;\n\n\ti = commit_start;\n\tfor (n = 0; n < commit_sections; n++) {\n\t\tfor (j = 0; j < ic->journal_section_entries; j++) {\n\t\t\tstruct journal_entry *je;\n\n\t\t\tje = access_journal_entry(ic, i, j);\n\t\t\tio_wait_event(ic->copy_to_journal_wait, !journal_entry_is_inprogress(je));\n\t\t}\n\t\tfor (j = 0; j < ic->journal_section_sectors; j++) {\n\t\t\tstruct journal_sector *js;\n\n\t\t\tjs = access_journal(ic, i, j);\n\t\t\tjs->commit_id = dm_integrity_commit_id(ic, i, j, ic->commit_seq);\n\t\t}\n\t\ti++;\n\t\tif (unlikely(i >= ic->journal_sections))\n\t\t\tic->commit_seq = next_commit_seq(ic->commit_seq);\n\t\twraparound_section(ic, &i);\n\t}\n\tsmp_rmb();\n\n\twrite_journal(ic, commit_start, commit_sections);\n\n\tspin_lock_irq(&ic->endio_wait.lock);\n\tic->uncommitted_section += commit_sections;\n\twraparound_section(ic, &ic->uncommitted_section);\n\tic->n_uncommitted_sections -= commit_sections;\n\tic->n_committed_sections += commit_sections;\n\tspin_unlock_irq(&ic->endio_wait.lock);\n\n\tif (READ_ONCE(ic->free_sectors) <= ic->free_sectors_threshold)\n\t\tqueue_work(ic->writer_wq, &ic->writer_work);\n\nrelease_flush_bios:\n\twhile (flushes) {\n\t\tstruct bio *next = flushes->bi_next;\n\n\t\tflushes->bi_next = NULL;\n\t\tdo_endio(ic, flushes);\n\t\tflushes = next;\n\t}\n}\n\nstatic void complete_copy_from_journal(unsigned long error, void *context)\n{\n\tstruct journal_io *io = context;\n\tstruct journal_completion *comp = io->comp;\n\tstruct dm_integrity_c *ic = comp->ic;\n\n\tremove_range(ic, &io->range);\n\tmempool_free(io, &ic->journal_io_mempool);\n\tif (unlikely(error != 0))\n\t\tdm_integrity_io_error(ic, \"copying from journal\", -EIO);\n\tcomplete_journal_op(comp);\n}\n\nstatic void restore_last_bytes(struct dm_integrity_c *ic, struct journal_sector *js,\n\t\t\t       struct journal_entry *je)\n{\n\tunsigned int s = 0;\n\n\tdo {\n\t\tjs->commit_id = je->last_bytes[s];\n\t\tjs++;\n\t} while (++s < ic->sectors_per_block);\n}\n\nstatic void do_journal_write(struct dm_integrity_c *ic, unsigned int write_start,\n\t\t\t     unsigned int write_sections, bool from_replay)\n{\n\tunsigned int i, j, n;\n\tstruct journal_completion comp;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\n\tcomp.ic = ic;\n\tcomp.in_flight = (atomic_t)ATOMIC_INIT(1);\n\tinit_completion(&comp.comp);\n\n\ti = write_start;\n\tfor (n = 0; n < write_sections; n++, i++, wraparound_section(ic, &i)) {\n#ifndef INTERNAL_VERIFY\n\t\tif (unlikely(from_replay))\n#endif\n\t\t\trw_section_mac(ic, i, false);\n\t\tfor (j = 0; j < ic->journal_section_entries; j++) {\n\t\t\tstruct journal_entry *je = access_journal_entry(ic, i, j);\n\t\t\tsector_t sec, area, offset;\n\t\t\tunsigned int k, l, next_loop;\n\t\t\tsector_t metadata_block;\n\t\t\tunsigned int metadata_offset;\n\t\t\tstruct journal_io *io;\n\n\t\t\tif (journal_entry_is_unused(je))\n\t\t\t\tcontinue;\n\t\t\tBUG_ON(unlikely(journal_entry_is_inprogress(je)) && !from_replay);\n\t\t\tsec = journal_entry_get_sector(je);\n\t\t\tif (unlikely(from_replay)) {\n\t\t\t\tif (unlikely(sec & (unsigned int)(ic->sectors_per_block - 1))) {\n\t\t\t\t\tdm_integrity_io_error(ic, \"invalid sector in journal\", -EIO);\n\t\t\t\t\tsec &= ~(sector_t)(ic->sectors_per_block - 1);\n\t\t\t\t}\n\t\t\t\tif (unlikely(sec >= ic->provided_data_sectors)) {\n\t\t\t\t\tjournal_entry_set_unused(je);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tget_area_and_offset(ic, sec, &area, &offset);\n\t\t\trestore_last_bytes(ic, access_journal_data(ic, i, j), je);\n\t\t\tfor (k = j + 1; k < ic->journal_section_entries; k++) {\n\t\t\t\tstruct journal_entry *je2 = access_journal_entry(ic, i, k);\n\t\t\t\tsector_t sec2, area2, offset2;\n\n\t\t\t\tif (journal_entry_is_unused(je2))\n\t\t\t\t\tbreak;\n\t\t\t\tBUG_ON(unlikely(journal_entry_is_inprogress(je2)) && !from_replay);\n\t\t\t\tsec2 = journal_entry_get_sector(je2);\n\t\t\t\tif (unlikely(sec2 >= ic->provided_data_sectors))\n\t\t\t\t\tbreak;\n\t\t\t\tget_area_and_offset(ic, sec2, &area2, &offset2);\n\t\t\t\tif (area2 != area || offset2 != offset + ((k - j) << ic->sb->log2_sectors_per_block))\n\t\t\t\t\tbreak;\n\t\t\t\trestore_last_bytes(ic, access_journal_data(ic, i, k), je2);\n\t\t\t}\n\t\t\tnext_loop = k - 1;\n\n\t\t\tio = mempool_alloc(&ic->journal_io_mempool, GFP_NOIO);\n\t\t\tio->comp = &comp;\n\t\t\tio->range.logical_sector = sec;\n\t\t\tio->range.n_sectors = (k - j) << ic->sb->log2_sectors_per_block;\n\n\t\t\tspin_lock_irq(&ic->endio_wait.lock);\n\t\t\tadd_new_range_and_wait(ic, &io->range);\n\n\t\t\tif (likely(!from_replay)) {\n\t\t\t\tstruct journal_node *section_node = &ic->journal_tree[i * ic->journal_section_entries];\n\n\t\t\t\t \n\t\t\t\twhile (j < k && find_newer_committed_node(ic, &section_node[j])) {\n\t\t\t\t\tstruct journal_entry *je2 = access_journal_entry(ic, i, j);\n\n\t\t\t\t\tjournal_entry_set_unused(je2);\n\t\t\t\t\tremove_journal_node(ic, &section_node[j]);\n\t\t\t\t\tj++;\n\t\t\t\t\tsec += ic->sectors_per_block;\n\t\t\t\t\toffset += ic->sectors_per_block;\n\t\t\t\t}\n\t\t\t\twhile (j < k && find_newer_committed_node(ic, &section_node[k - 1])) {\n\t\t\t\t\tstruct journal_entry *je2 = access_journal_entry(ic, i, k - 1);\n\n\t\t\t\t\tjournal_entry_set_unused(je2);\n\t\t\t\t\tremove_journal_node(ic, &section_node[k - 1]);\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tif (j == k) {\n\t\t\t\t\tremove_range_unlocked(ic, &io->range);\n\t\t\t\t\tspin_unlock_irq(&ic->endio_wait.lock);\n\t\t\t\t\tmempool_free(io, &ic->journal_io_mempool);\n\t\t\t\t\tgoto skip_io;\n\t\t\t\t}\n\t\t\t\tfor (l = j; l < k; l++)\n\t\t\t\t\tremove_journal_node(ic, &section_node[l]);\n\t\t\t}\n\t\t\tspin_unlock_irq(&ic->endio_wait.lock);\n\n\t\t\tmetadata_block = get_metadata_sector_and_offset(ic, area, offset, &metadata_offset);\n\t\t\tfor (l = j; l < k; l++) {\n\t\t\t\tint r;\n\t\t\t\tstruct journal_entry *je2 = access_journal_entry(ic, i, l);\n\n\t\t\t\tif (\n#ifndef INTERNAL_VERIFY\n\t\t\t\t    unlikely(from_replay) &&\n#endif\n\t\t\t\t    ic->internal_hash) {\n\t\t\t\t\tchar test_tag[max_t(size_t, HASH_MAX_DIGESTSIZE, MAX_TAG_SIZE)];\n\n\t\t\t\t\tintegrity_sector_checksum(ic, sec + ((l - j) << ic->sb->log2_sectors_per_block),\n\t\t\t\t\t\t\t\t  (char *)access_journal_data(ic, i, l), test_tag);\n\t\t\t\t\tif (unlikely(memcmp(test_tag, journal_entry_tag(ic, je2), ic->tag_size))) {\n\t\t\t\t\t\tdm_integrity_io_error(ic, \"tag mismatch when replaying journal\", -EILSEQ);\n\t\t\t\t\t\tdm_audit_log_target(DM_MSG_PREFIX, \"integrity-replay-journal\", ic->ti, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tjournal_entry_set_unused(je2);\n\t\t\t\tr = dm_integrity_rw_tag(ic, journal_entry_tag(ic, je2), &metadata_block, &metadata_offset,\n\t\t\t\t\t\t\tic->tag_size, TAG_WRITE);\n\t\t\t\tif (unlikely(r))\n\t\t\t\t\tdm_integrity_io_error(ic, \"reading tags\", r);\n\t\t\t}\n\n\t\t\tatomic_inc(&comp.in_flight);\n\t\t\tcopy_from_journal(ic, i, j << ic->sb->log2_sectors_per_block,\n\t\t\t\t\t  (k - j) << ic->sb->log2_sectors_per_block,\n\t\t\t\t\t  get_data_sector(ic, area, offset),\n\t\t\t\t\t  complete_copy_from_journal, io);\nskip_io:\n\t\t\tj = next_loop;\n\t\t}\n\t}\n\n\tdm_bufio_write_dirty_buffers_async(ic->bufio);\n\n\tblk_finish_plug(&plug);\n\n\tcomplete_journal_op(&comp);\n\twait_for_completion_io(&comp.comp);\n\n\tdm_integrity_flush_buffers(ic, true);\n}\n\nstatic void integrity_writer(struct work_struct *w)\n{\n\tstruct dm_integrity_c *ic = container_of(w, struct dm_integrity_c, writer_work);\n\tunsigned int write_start, write_sections;\n\tunsigned int prev_free_sectors;\n\n\tspin_lock_irq(&ic->endio_wait.lock);\n\twrite_start = ic->committed_section;\n\twrite_sections = ic->n_committed_sections;\n\tspin_unlock_irq(&ic->endio_wait.lock);\n\n\tif (!write_sections)\n\t\treturn;\n\n\tdo_journal_write(ic, write_start, write_sections, false);\n\n\tspin_lock_irq(&ic->endio_wait.lock);\n\n\tic->committed_section += write_sections;\n\twraparound_section(ic, &ic->committed_section);\n\tic->n_committed_sections -= write_sections;\n\n\tprev_free_sectors = ic->free_sectors;\n\tic->free_sectors += write_sections * ic->journal_section_entries;\n\tif (unlikely(!prev_free_sectors))\n\t\twake_up_locked(&ic->endio_wait);\n\n\tspin_unlock_irq(&ic->endio_wait.lock);\n}\n\nstatic void recalc_write_super(struct dm_integrity_c *ic)\n{\n\tint r;\n\n\tdm_integrity_flush_buffers(ic, false);\n\tif (dm_integrity_failed(ic))\n\t\treturn;\n\n\tr = sync_rw_sb(ic, REQ_OP_WRITE);\n\tif (unlikely(r))\n\t\tdm_integrity_io_error(ic, \"writing superblock\", r);\n}\n\nstatic void integrity_recalc(struct work_struct *w)\n{\n\tstruct dm_integrity_c *ic = container_of(w, struct dm_integrity_c, recalc_work);\n\tsize_t recalc_tags_size;\n\tu8 *recalc_buffer = NULL;\n\tu8 *recalc_tags = NULL;\n\tstruct dm_integrity_range range;\n\tstruct dm_io_request io_req;\n\tstruct dm_io_region io_loc;\n\tsector_t area, offset;\n\tsector_t metadata_block;\n\tunsigned int metadata_offset;\n\tsector_t logical_sector, n_sectors;\n\t__u8 *t;\n\tunsigned int i;\n\tint r;\n\tunsigned int super_counter = 0;\n\tunsigned recalc_sectors = RECALC_SECTORS;\n\nretry:\n\trecalc_buffer = __vmalloc(recalc_sectors << SECTOR_SHIFT, GFP_NOIO);\n\tif (!recalc_buffer) {\noom:\n\t\trecalc_sectors >>= 1;\n\t\tif (recalc_sectors >= 1U << ic->sb->log2_sectors_per_block)\n\t\t\tgoto retry;\n\t\tDMCRIT(\"out of memory for recalculate buffer - recalculation disabled\");\n\t\tgoto free_ret;\n\t}\n\trecalc_tags_size = (recalc_sectors >> ic->sb->log2_sectors_per_block) * ic->tag_size;\n\tif (crypto_shash_digestsize(ic->internal_hash) > ic->tag_size)\n\t\trecalc_tags_size += crypto_shash_digestsize(ic->internal_hash) - ic->tag_size;\n\trecalc_tags = kvmalloc(recalc_tags_size, GFP_NOIO);\n\tif (!recalc_tags) {\n\t\tvfree(recalc_buffer);\n\t\trecalc_buffer = NULL;\n\t\tgoto oom;\n\t}\n\n\tDEBUG_print(\"start recalculation... (position %llx)\\n\", le64_to_cpu(ic->sb->recalc_sector));\n\n\tspin_lock_irq(&ic->endio_wait.lock);\n\nnext_chunk:\n\n\tif (unlikely(dm_post_suspending(ic->ti)))\n\t\tgoto unlock_ret;\n\n\trange.logical_sector = le64_to_cpu(ic->sb->recalc_sector);\n\tif (unlikely(range.logical_sector >= ic->provided_data_sectors)) {\n\t\tif (ic->mode == 'B') {\n\t\t\tblock_bitmap_op(ic, ic->recalc_bitmap, 0, ic->provided_data_sectors, BITMAP_OP_CLEAR);\n\t\t\tDEBUG_print(\"queue_delayed_work: bitmap_flush_work\\n\");\n\t\t\tqueue_delayed_work(ic->commit_wq, &ic->bitmap_flush_work, 0);\n\t\t}\n\t\tgoto unlock_ret;\n\t}\n\n\tget_area_and_offset(ic, range.logical_sector, &area, &offset);\n\trange.n_sectors = min((sector_t)recalc_sectors, ic->provided_data_sectors - range.logical_sector);\n\tif (!ic->meta_dev)\n\t\trange.n_sectors = min(range.n_sectors, ((sector_t)1U << ic->sb->log2_interleave_sectors) - (unsigned int)offset);\n\n\tadd_new_range_and_wait(ic, &range);\n\tspin_unlock_irq(&ic->endio_wait.lock);\n\tlogical_sector = range.logical_sector;\n\tn_sectors = range.n_sectors;\n\n\tif (ic->mode == 'B') {\n\t\tif (block_bitmap_op(ic, ic->recalc_bitmap, logical_sector, n_sectors, BITMAP_OP_TEST_ALL_CLEAR))\n\t\t\tgoto advance_and_next;\n\n\t\twhile (block_bitmap_op(ic, ic->recalc_bitmap, logical_sector,\n\t\t\t\t       ic->sectors_per_block, BITMAP_OP_TEST_ALL_CLEAR)) {\n\t\t\tlogical_sector += ic->sectors_per_block;\n\t\t\tn_sectors -= ic->sectors_per_block;\n\t\t\tcond_resched();\n\t\t}\n\t\twhile (block_bitmap_op(ic, ic->recalc_bitmap, logical_sector + n_sectors - ic->sectors_per_block,\n\t\t\t\t       ic->sectors_per_block, BITMAP_OP_TEST_ALL_CLEAR)) {\n\t\t\tn_sectors -= ic->sectors_per_block;\n\t\t\tcond_resched();\n\t\t}\n\t\tget_area_and_offset(ic, logical_sector, &area, &offset);\n\t}\n\n\tDEBUG_print(\"recalculating: %llx, %llx\\n\", logical_sector, n_sectors);\n\n\tif (unlikely(++super_counter == RECALC_WRITE_SUPER)) {\n\t\trecalc_write_super(ic);\n\t\tif (ic->mode == 'B')\n\t\t\tqueue_delayed_work(ic->commit_wq, &ic->bitmap_flush_work, ic->bitmap_flush_interval);\n\n\t\tsuper_counter = 0;\n\t}\n\n\tif (unlikely(dm_integrity_failed(ic)))\n\t\tgoto err;\n\n\tio_req.bi_opf = REQ_OP_READ;\n\tio_req.mem.type = DM_IO_VMA;\n\tio_req.mem.ptr.addr = recalc_buffer;\n\tio_req.notify.fn = NULL;\n\tio_req.client = ic->io;\n\tio_loc.bdev = ic->dev->bdev;\n\tio_loc.sector = get_data_sector(ic, area, offset);\n\tio_loc.count = n_sectors;\n\n\tr = dm_io(&io_req, 1, &io_loc, NULL);\n\tif (unlikely(r)) {\n\t\tdm_integrity_io_error(ic, \"reading data\", r);\n\t\tgoto err;\n\t}\n\n\tt = recalc_tags;\n\tfor (i = 0; i < n_sectors; i += ic->sectors_per_block) {\n\t\tintegrity_sector_checksum(ic, logical_sector + i, recalc_buffer + (i << SECTOR_SHIFT), t);\n\t\tt += ic->tag_size;\n\t}\n\n\tmetadata_block = get_metadata_sector_and_offset(ic, area, offset, &metadata_offset);\n\n\tr = dm_integrity_rw_tag(ic, recalc_tags, &metadata_block, &metadata_offset, t - recalc_tags, TAG_WRITE);\n\tif (unlikely(r)) {\n\t\tdm_integrity_io_error(ic, \"writing tags\", r);\n\t\tgoto err;\n\t}\n\n\tif (ic->mode == 'B') {\n\t\tsector_t start, end;\n\n\t\tstart = (range.logical_sector >>\n\t\t\t (ic->sb->log2_sectors_per_block + ic->log2_blocks_per_bitmap_bit)) <<\n\t\t\t(ic->sb->log2_sectors_per_block + ic->log2_blocks_per_bitmap_bit);\n\t\tend = ((range.logical_sector + range.n_sectors) >>\n\t\t       (ic->sb->log2_sectors_per_block + ic->log2_blocks_per_bitmap_bit)) <<\n\t\t\t(ic->sb->log2_sectors_per_block + ic->log2_blocks_per_bitmap_bit);\n\t\tblock_bitmap_op(ic, ic->recalc_bitmap, start, end - start, BITMAP_OP_CLEAR);\n\t}\n\nadvance_and_next:\n\tcond_resched();\n\n\tspin_lock_irq(&ic->endio_wait.lock);\n\tremove_range_unlocked(ic, &range);\n\tic->sb->recalc_sector = cpu_to_le64(range.logical_sector + range.n_sectors);\n\tgoto next_chunk;\n\nerr:\n\tremove_range(ic, &range);\n\tgoto free_ret;\n\nunlock_ret:\n\tspin_unlock_irq(&ic->endio_wait.lock);\n\n\trecalc_write_super(ic);\n\nfree_ret:\n\tvfree(recalc_buffer);\n\tkvfree(recalc_tags);\n}\n\nstatic void bitmap_block_work(struct work_struct *w)\n{\n\tstruct bitmap_block_status *bbs = container_of(w, struct bitmap_block_status, work);\n\tstruct dm_integrity_c *ic = bbs->ic;\n\tstruct bio *bio;\n\tstruct bio_list bio_queue;\n\tstruct bio_list waiting;\n\n\tbio_list_init(&waiting);\n\n\tspin_lock(&bbs->bio_queue_lock);\n\tbio_queue = bbs->bio_queue;\n\tbio_list_init(&bbs->bio_queue);\n\tspin_unlock(&bbs->bio_queue_lock);\n\n\twhile ((bio = bio_list_pop(&bio_queue))) {\n\t\tstruct dm_integrity_io *dio;\n\n\t\tdio = dm_per_bio_data(bio, sizeof(struct dm_integrity_io));\n\n\t\tif (block_bitmap_op(ic, ic->may_write_bitmap, dio->range.logical_sector,\n\t\t\t\t    dio->range.n_sectors, BITMAP_OP_TEST_ALL_SET)) {\n\t\t\tremove_range(ic, &dio->range);\n\t\t\tINIT_WORK(&dio->work, integrity_bio_wait);\n\t\t\tqueue_work(ic->offload_wq, &dio->work);\n\t\t} else {\n\t\t\tblock_bitmap_op(ic, ic->journal, dio->range.logical_sector,\n\t\t\t\t\tdio->range.n_sectors, BITMAP_OP_SET);\n\t\t\tbio_list_add(&waiting, bio);\n\t\t}\n\t}\n\n\tif (bio_list_empty(&waiting))\n\t\treturn;\n\n\trw_journal_sectors(ic, REQ_OP_WRITE | REQ_FUA | REQ_SYNC,\n\t\t\t   bbs->idx * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT),\n\t\t\t   BITMAP_BLOCK_SIZE >> SECTOR_SHIFT, NULL);\n\n\twhile ((bio = bio_list_pop(&waiting))) {\n\t\tstruct dm_integrity_io *dio = dm_per_bio_data(bio, sizeof(struct dm_integrity_io));\n\n\t\tblock_bitmap_op(ic, ic->may_write_bitmap, dio->range.logical_sector,\n\t\t\t\tdio->range.n_sectors, BITMAP_OP_SET);\n\n\t\tremove_range(ic, &dio->range);\n\t\tINIT_WORK(&dio->work, integrity_bio_wait);\n\t\tqueue_work(ic->offload_wq, &dio->work);\n\t}\n\n\tqueue_delayed_work(ic->commit_wq, &ic->bitmap_flush_work, ic->bitmap_flush_interval);\n}\n\nstatic void bitmap_flush_work(struct work_struct *work)\n{\n\tstruct dm_integrity_c *ic = container_of(work, struct dm_integrity_c, bitmap_flush_work.work);\n\tstruct dm_integrity_range range;\n\tunsigned long limit;\n\tstruct bio *bio;\n\n\tdm_integrity_flush_buffers(ic, false);\n\n\trange.logical_sector = 0;\n\trange.n_sectors = ic->provided_data_sectors;\n\n\tspin_lock_irq(&ic->endio_wait.lock);\n\tadd_new_range_and_wait(ic, &range);\n\tspin_unlock_irq(&ic->endio_wait.lock);\n\n\tdm_integrity_flush_buffers(ic, true);\n\n\tlimit = ic->provided_data_sectors;\n\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING)) {\n\t\tlimit = le64_to_cpu(ic->sb->recalc_sector)\n\t\t\t>> (ic->sb->log2_sectors_per_block + ic->log2_blocks_per_bitmap_bit)\n\t\t\t<< (ic->sb->log2_sectors_per_block + ic->log2_blocks_per_bitmap_bit);\n\t}\n\t \n\tblock_bitmap_op(ic, ic->journal, 0, limit, BITMAP_OP_CLEAR);\n\tblock_bitmap_op(ic, ic->may_write_bitmap, 0, limit, BITMAP_OP_CLEAR);\n\n\trw_journal_sectors(ic, REQ_OP_WRITE | REQ_FUA | REQ_SYNC, 0,\n\t\t\t   ic->n_bitmap_blocks * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT), NULL);\n\n\tspin_lock_irq(&ic->endio_wait.lock);\n\tremove_range_unlocked(ic, &range);\n\twhile (unlikely((bio = bio_list_pop(&ic->synchronous_bios)) != NULL)) {\n\t\tbio_endio(bio);\n\t\tspin_unlock_irq(&ic->endio_wait.lock);\n\t\tspin_lock_irq(&ic->endio_wait.lock);\n\t}\n\tspin_unlock_irq(&ic->endio_wait.lock);\n}\n\n\nstatic void init_journal(struct dm_integrity_c *ic, unsigned int start_section,\n\t\t\t unsigned int n_sections, unsigned char commit_seq)\n{\n\tunsigned int i, j, n;\n\n\tif (!n_sections)\n\t\treturn;\n\n\tfor (n = 0; n < n_sections; n++) {\n\t\ti = start_section + n;\n\t\twraparound_section(ic, &i);\n\t\tfor (j = 0; j < ic->journal_section_sectors; j++) {\n\t\t\tstruct journal_sector *js = access_journal(ic, i, j);\n\n\t\t\tBUILD_BUG_ON(sizeof(js->sectors) != JOURNAL_SECTOR_DATA);\n\t\t\tmemset(&js->sectors, 0, sizeof(js->sectors));\n\t\t\tjs->commit_id = dm_integrity_commit_id(ic, i, j, commit_seq);\n\t\t}\n\t\tfor (j = 0; j < ic->journal_section_entries; j++) {\n\t\t\tstruct journal_entry *je = access_journal_entry(ic, i, j);\n\n\t\t\tjournal_entry_set_unused(je);\n\t\t}\n\t}\n\n\twrite_journal(ic, start_section, n_sections);\n}\n\nstatic int find_commit_seq(struct dm_integrity_c *ic, unsigned int i, unsigned int j, commit_id_t id)\n{\n\tunsigned char k;\n\n\tfor (k = 0; k < N_COMMIT_IDS; k++) {\n\t\tif (dm_integrity_commit_id(ic, i, j, k) == id)\n\t\t\treturn k;\n\t}\n\tdm_integrity_io_error(ic, \"journal commit id\", -EIO);\n\treturn -EIO;\n}\n\nstatic void replay_journal(struct dm_integrity_c *ic)\n{\n\tunsigned int i, j;\n\tbool used_commit_ids[N_COMMIT_IDS];\n\tunsigned int max_commit_id_sections[N_COMMIT_IDS];\n\tunsigned int write_start, write_sections;\n\tunsigned int continue_section;\n\tbool journal_empty;\n\tunsigned char unused, last_used, want_commit_seq;\n\n\tif (ic->mode == 'R')\n\t\treturn;\n\n\tif (ic->journal_uptodate)\n\t\treturn;\n\n\tlast_used = 0;\n\twrite_start = 0;\n\n\tif (!ic->just_formatted) {\n\t\tDEBUG_print(\"reading journal\\n\");\n\t\trw_journal(ic, REQ_OP_READ, 0, ic->journal_sections, NULL);\n\t\tif (ic->journal_io)\n\t\t\tDEBUG_bytes(lowmem_page_address(ic->journal_io[0].page), 64, \"read journal\");\n\t\tif (ic->journal_io) {\n\t\t\tstruct journal_completion crypt_comp;\n\n\t\t\tcrypt_comp.ic = ic;\n\t\t\tinit_completion(&crypt_comp.comp);\n\t\t\tcrypt_comp.in_flight = (atomic_t)ATOMIC_INIT(0);\n\t\t\tencrypt_journal(ic, false, 0, ic->journal_sections, &crypt_comp);\n\t\t\twait_for_completion(&crypt_comp.comp);\n\t\t}\n\t\tDEBUG_bytes(lowmem_page_address(ic->journal[0].page), 64, \"decrypted journal\");\n\t}\n\n\tif (dm_integrity_failed(ic))\n\t\tgoto clear_journal;\n\n\tjournal_empty = true;\n\tmemset(used_commit_ids, 0, sizeof(used_commit_ids));\n\tmemset(max_commit_id_sections, 0, sizeof(max_commit_id_sections));\n\tfor (i = 0; i < ic->journal_sections; i++) {\n\t\tfor (j = 0; j < ic->journal_section_sectors; j++) {\n\t\t\tint k;\n\t\t\tstruct journal_sector *js = access_journal(ic, i, j);\n\n\t\t\tk = find_commit_seq(ic, i, j, js->commit_id);\n\t\t\tif (k < 0)\n\t\t\t\tgoto clear_journal;\n\t\t\tused_commit_ids[k] = true;\n\t\t\tmax_commit_id_sections[k] = i;\n\t\t}\n\t\tif (journal_empty) {\n\t\t\tfor (j = 0; j < ic->journal_section_entries; j++) {\n\t\t\t\tstruct journal_entry *je = access_journal_entry(ic, i, j);\n\n\t\t\t\tif (!journal_entry_is_unused(je)) {\n\t\t\t\t\tjournal_empty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!used_commit_ids[N_COMMIT_IDS - 1]) {\n\t\tunused = N_COMMIT_IDS - 1;\n\t\twhile (unused && !used_commit_ids[unused - 1])\n\t\t\tunused--;\n\t} else {\n\t\tfor (unused = 0; unused < N_COMMIT_IDS; unused++)\n\t\t\tif (!used_commit_ids[unused])\n\t\t\t\tbreak;\n\t\tif (unused == N_COMMIT_IDS) {\n\t\t\tdm_integrity_io_error(ic, \"journal commit ids\", -EIO);\n\t\t\tgoto clear_journal;\n\t\t}\n\t}\n\tDEBUG_print(\"first unused commit seq %d [%d,%d,%d,%d]\\n\",\n\t\t    unused, used_commit_ids[0], used_commit_ids[1],\n\t\t    used_commit_ids[2], used_commit_ids[3]);\n\n\tlast_used = prev_commit_seq(unused);\n\twant_commit_seq = prev_commit_seq(last_used);\n\n\tif (!used_commit_ids[want_commit_seq] && used_commit_ids[prev_commit_seq(want_commit_seq)])\n\t\tjournal_empty = true;\n\n\twrite_start = max_commit_id_sections[last_used] + 1;\n\tif (unlikely(write_start >= ic->journal_sections))\n\t\twant_commit_seq = next_commit_seq(want_commit_seq);\n\twraparound_section(ic, &write_start);\n\n\ti = write_start;\n\tfor (write_sections = 0; write_sections < ic->journal_sections; write_sections++) {\n\t\tfor (j = 0; j < ic->journal_section_sectors; j++) {\n\t\t\tstruct journal_sector *js = access_journal(ic, i, j);\n\n\t\t\tif (js->commit_id != dm_integrity_commit_id(ic, i, j, want_commit_seq)) {\n\t\t\t\t \n\t\t\t\tDEBUG_print(\"commit id mismatch at position (%u, %u): %d != %d\\n\",\n\t\t\t\t\t    i, j, find_commit_seq(ic, i, j, js->commit_id), want_commit_seq);\n\t\t\t\tgoto brk;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tif (unlikely(i >= ic->journal_sections))\n\t\t\twant_commit_seq = next_commit_seq(want_commit_seq);\n\t\twraparound_section(ic, &i);\n\t}\nbrk:\n\n\tif (!journal_empty) {\n\t\tDEBUG_print(\"replaying %u sections, starting at %u, commit seq %d\\n\",\n\t\t\t    write_sections, write_start, want_commit_seq);\n\t\tdo_journal_write(ic, write_start, write_sections, true);\n\t}\n\n\tif (write_sections == ic->journal_sections && (ic->mode == 'J' || journal_empty)) {\n\t\tcontinue_section = write_start;\n\t\tic->commit_seq = want_commit_seq;\n\t\tDEBUG_print(\"continuing from section %u, commit seq %d\\n\", write_start, ic->commit_seq);\n\t} else {\n\t\tunsigned int s;\n\t\tunsigned char erase_seq;\n\nclear_journal:\n\t\tDEBUG_print(\"clearing journal\\n\");\n\n\t\terase_seq = prev_commit_seq(prev_commit_seq(last_used));\n\t\ts = write_start;\n\t\tinit_journal(ic, s, 1, erase_seq);\n\t\ts++;\n\t\twraparound_section(ic, &s);\n\t\tif (ic->journal_sections >= 2) {\n\t\t\tinit_journal(ic, s, ic->journal_sections - 2, erase_seq);\n\t\t\ts += ic->journal_sections - 2;\n\t\t\twraparound_section(ic, &s);\n\t\t\tinit_journal(ic, s, 1, erase_seq);\n\t\t}\n\n\t\tcontinue_section = 0;\n\t\tic->commit_seq = next_commit_seq(erase_seq);\n\t}\n\n\tic->committed_section = continue_section;\n\tic->n_committed_sections = 0;\n\n\tic->uncommitted_section = continue_section;\n\tic->n_uncommitted_sections = 0;\n\n\tic->free_section = continue_section;\n\tic->free_section_entry = 0;\n\tic->free_sectors = ic->journal_entries;\n\n\tic->journal_tree_root = RB_ROOT;\n\tfor (i = 0; i < ic->journal_entries; i++)\n\t\tinit_journal_node(&ic->journal_tree[i]);\n}\n\nstatic void dm_integrity_enter_synchronous_mode(struct dm_integrity_c *ic)\n{\n\tDEBUG_print(\"%s\\n\", __func__);\n\n\tif (ic->mode == 'B') {\n\t\tic->bitmap_flush_interval = msecs_to_jiffies(10) + 1;\n\t\tic->synchronous_mode = 1;\n\n\t\tcancel_delayed_work_sync(&ic->bitmap_flush_work);\n\t\tqueue_delayed_work(ic->commit_wq, &ic->bitmap_flush_work, 0);\n\t\tflush_workqueue(ic->commit_wq);\n\t}\n}\n\nstatic int dm_integrity_reboot(struct notifier_block *n, unsigned long code, void *x)\n{\n\tstruct dm_integrity_c *ic = container_of(n, struct dm_integrity_c, reboot_notifier);\n\n\tDEBUG_print(\"%s\\n\", __func__);\n\n\tdm_integrity_enter_synchronous_mode(ic);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void dm_integrity_postsuspend(struct dm_target *ti)\n{\n\tstruct dm_integrity_c *ic = ti->private;\n\tint r;\n\n\tWARN_ON(unregister_reboot_notifier(&ic->reboot_notifier));\n\n\tdel_timer_sync(&ic->autocommit_timer);\n\n\tif (ic->recalc_wq)\n\t\tdrain_workqueue(ic->recalc_wq);\n\n\tif (ic->mode == 'B')\n\t\tcancel_delayed_work_sync(&ic->bitmap_flush_work);\n\n\tqueue_work(ic->commit_wq, &ic->commit_work);\n\tdrain_workqueue(ic->commit_wq);\n\n\tif (ic->mode == 'J') {\n\t\tqueue_work(ic->writer_wq, &ic->writer_work);\n\t\tdrain_workqueue(ic->writer_wq);\n\t\tdm_integrity_flush_buffers(ic, true);\n\t\tif (ic->wrote_to_journal) {\n\t\t\tinit_journal(ic, ic->free_section,\n\t\t\t\t     ic->journal_sections - ic->free_section, ic->commit_seq);\n\t\t\tif (ic->free_section) {\n\t\t\t\tinit_journal(ic, 0, ic->free_section,\n\t\t\t\t\t     next_commit_seq(ic->commit_seq));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ic->mode == 'B') {\n\t\tdm_integrity_flush_buffers(ic, true);\n#if 1\n\t\t \n\t\tinit_journal(ic, 0, ic->journal_sections, 0);\n\t\tic->sb->flags &= ~cpu_to_le32(SB_FLAG_DIRTY_BITMAP);\n\t\tr = sync_rw_sb(ic, REQ_OP_WRITE | REQ_FUA);\n\t\tif (unlikely(r))\n\t\t\tdm_integrity_io_error(ic, \"writing superblock\", r);\n#endif\n\t}\n\n\tBUG_ON(!RB_EMPTY_ROOT(&ic->in_progress));\n\n\tic->journal_uptodate = true;\n}\n\nstatic void dm_integrity_resume(struct dm_target *ti)\n{\n\tstruct dm_integrity_c *ic = ti->private;\n\t__u64 old_provided_data_sectors = le64_to_cpu(ic->sb->provided_data_sectors);\n\tint r;\n\n\tDEBUG_print(\"resume\\n\");\n\n\tic->wrote_to_journal = false;\n\n\tif (ic->provided_data_sectors != old_provided_data_sectors) {\n\t\tif (ic->provided_data_sectors > old_provided_data_sectors &&\n\t\t    ic->mode == 'B' &&\n\t\t    ic->sb->log2_blocks_per_bitmap_bit == ic->log2_blocks_per_bitmap_bit) {\n\t\t\trw_journal_sectors(ic, REQ_OP_READ, 0,\n\t\t\t\t\t   ic->n_bitmap_blocks * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT), NULL);\n\t\t\tblock_bitmap_op(ic, ic->journal, old_provided_data_sectors,\n\t\t\t\t\tic->provided_data_sectors - old_provided_data_sectors, BITMAP_OP_SET);\n\t\t\trw_journal_sectors(ic, REQ_OP_WRITE | REQ_FUA | REQ_SYNC, 0,\n\t\t\t\t\t   ic->n_bitmap_blocks * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT), NULL);\n\t\t}\n\n\t\tic->sb->provided_data_sectors = cpu_to_le64(ic->provided_data_sectors);\n\t\tr = sync_rw_sb(ic, REQ_OP_WRITE | REQ_FUA);\n\t\tif (unlikely(r))\n\t\t\tdm_integrity_io_error(ic, \"writing superblock\", r);\n\t}\n\n\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_DIRTY_BITMAP)) {\n\t\tDEBUG_print(\"resume dirty_bitmap\\n\");\n\t\trw_journal_sectors(ic, REQ_OP_READ, 0,\n\t\t\t\t   ic->n_bitmap_blocks * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT), NULL);\n\t\tif (ic->mode == 'B') {\n\t\t\tif (ic->sb->log2_blocks_per_bitmap_bit == ic->log2_blocks_per_bitmap_bit &&\n\t\t\t    !ic->reset_recalculate_flag) {\n\t\t\t\tblock_bitmap_copy(ic, ic->recalc_bitmap, ic->journal);\n\t\t\t\tblock_bitmap_copy(ic, ic->may_write_bitmap, ic->journal);\n\t\t\t\tif (!block_bitmap_op(ic, ic->journal, 0, ic->provided_data_sectors,\n\t\t\t\t\t\t     BITMAP_OP_TEST_ALL_CLEAR)) {\n\t\t\t\t\tic->sb->flags |= cpu_to_le32(SB_FLAG_RECALCULATING);\n\t\t\t\t\tic->sb->recalc_sector = cpu_to_le64(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tDEBUG_print(\"non-matching blocks_per_bitmap_bit: %u, %u\\n\",\n\t\t\t\t\t    ic->sb->log2_blocks_per_bitmap_bit, ic->log2_blocks_per_bitmap_bit);\n\t\t\t\tic->sb->log2_blocks_per_bitmap_bit = ic->log2_blocks_per_bitmap_bit;\n\t\t\t\tblock_bitmap_op(ic, ic->recalc_bitmap, 0, ic->provided_data_sectors, BITMAP_OP_SET);\n\t\t\t\tblock_bitmap_op(ic, ic->may_write_bitmap, 0, ic->provided_data_sectors, BITMAP_OP_SET);\n\t\t\t\tblock_bitmap_op(ic, ic->journal, 0, ic->provided_data_sectors, BITMAP_OP_SET);\n\t\t\t\trw_journal_sectors(ic, REQ_OP_WRITE | REQ_FUA | REQ_SYNC, 0,\n\t\t\t\t\t\t   ic->n_bitmap_blocks * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT), NULL);\n\t\t\t\tic->sb->flags |= cpu_to_le32(SB_FLAG_RECALCULATING);\n\t\t\t\tic->sb->recalc_sector = cpu_to_le64(0);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(ic->sb->log2_blocks_per_bitmap_bit == ic->log2_blocks_per_bitmap_bit &&\n\t\t\t      block_bitmap_op(ic, ic->journal, 0, ic->provided_data_sectors, BITMAP_OP_TEST_ALL_CLEAR)) ||\n\t\t\t    ic->reset_recalculate_flag) {\n\t\t\t\tic->sb->flags |= cpu_to_le32(SB_FLAG_RECALCULATING);\n\t\t\t\tic->sb->recalc_sector = cpu_to_le64(0);\n\t\t\t}\n\t\t\tinit_journal(ic, 0, ic->journal_sections, 0);\n\t\t\treplay_journal(ic);\n\t\t\tic->sb->flags &= ~cpu_to_le32(SB_FLAG_DIRTY_BITMAP);\n\t\t}\n\t\tr = sync_rw_sb(ic, REQ_OP_WRITE | REQ_FUA);\n\t\tif (unlikely(r))\n\t\t\tdm_integrity_io_error(ic, \"writing superblock\", r);\n\t} else {\n\t\treplay_journal(ic);\n\t\tif (ic->reset_recalculate_flag) {\n\t\t\tic->sb->flags |= cpu_to_le32(SB_FLAG_RECALCULATING);\n\t\t\tic->sb->recalc_sector = cpu_to_le64(0);\n\t\t}\n\t\tif (ic->mode == 'B') {\n\t\t\tic->sb->flags |= cpu_to_le32(SB_FLAG_DIRTY_BITMAP);\n\t\t\tic->sb->log2_blocks_per_bitmap_bit = ic->log2_blocks_per_bitmap_bit;\n\t\t\tr = sync_rw_sb(ic, REQ_OP_WRITE | REQ_FUA);\n\t\t\tif (unlikely(r))\n\t\t\t\tdm_integrity_io_error(ic, \"writing superblock\", r);\n\n\t\t\tblock_bitmap_op(ic, ic->journal, 0, ic->provided_data_sectors, BITMAP_OP_CLEAR);\n\t\t\tblock_bitmap_op(ic, ic->recalc_bitmap, 0, ic->provided_data_sectors, BITMAP_OP_CLEAR);\n\t\t\tblock_bitmap_op(ic, ic->may_write_bitmap, 0, ic->provided_data_sectors, BITMAP_OP_CLEAR);\n\t\t\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING) &&\n\t\t\t    le64_to_cpu(ic->sb->recalc_sector) < ic->provided_data_sectors) {\n\t\t\t\tblock_bitmap_op(ic, ic->journal, le64_to_cpu(ic->sb->recalc_sector),\n\t\t\t\t\t\tic->provided_data_sectors - le64_to_cpu(ic->sb->recalc_sector), BITMAP_OP_SET);\n\t\t\t\tblock_bitmap_op(ic, ic->recalc_bitmap, le64_to_cpu(ic->sb->recalc_sector),\n\t\t\t\t\t\tic->provided_data_sectors - le64_to_cpu(ic->sb->recalc_sector), BITMAP_OP_SET);\n\t\t\t\tblock_bitmap_op(ic, ic->may_write_bitmap, le64_to_cpu(ic->sb->recalc_sector),\n\t\t\t\t\t\tic->provided_data_sectors - le64_to_cpu(ic->sb->recalc_sector), BITMAP_OP_SET);\n\t\t\t}\n\t\t\trw_journal_sectors(ic, REQ_OP_WRITE | REQ_FUA | REQ_SYNC, 0,\n\t\t\t\t\t   ic->n_bitmap_blocks * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT), NULL);\n\t\t}\n\t}\n\n\tDEBUG_print(\"testing recalc: %x\\n\", ic->sb->flags);\n\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING)) {\n\t\t__u64 recalc_pos = le64_to_cpu(ic->sb->recalc_sector);\n\n\t\tDEBUG_print(\"recalc pos: %llx / %llx\\n\", recalc_pos, ic->provided_data_sectors);\n\t\tif (recalc_pos < ic->provided_data_sectors) {\n\t\t\tqueue_work(ic->recalc_wq, &ic->recalc_work);\n\t\t} else if (recalc_pos > ic->provided_data_sectors) {\n\t\t\tic->sb->recalc_sector = cpu_to_le64(ic->provided_data_sectors);\n\t\t\trecalc_write_super(ic);\n\t\t}\n\t}\n\n\tic->reboot_notifier.notifier_call = dm_integrity_reboot;\n\tic->reboot_notifier.next = NULL;\n\tic->reboot_notifier.priority = INT_MAX - 1;\t \n\tWARN_ON(register_reboot_notifier(&ic->reboot_notifier));\n\n#if 0\n\t \n\tdm_integrity_enter_synchronous_mode(ic);\n#endif\n}\n\nstatic void dm_integrity_status(struct dm_target *ti, status_type_t type,\n\t\t\t\tunsigned int status_flags, char *result, unsigned int maxlen)\n{\n\tstruct dm_integrity_c *ic = ti->private;\n\tunsigned int arg_count;\n\tsize_t sz = 0;\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\tDMEMIT(\"%llu %llu\",\n\t\t\t(unsigned long long)atomic64_read(&ic->number_of_mismatches),\n\t\t\tic->provided_data_sectors);\n\t\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING))\n\t\t\tDMEMIT(\" %llu\", le64_to_cpu(ic->sb->recalc_sector));\n\t\telse\n\t\t\tDMEMIT(\" -\");\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE: {\n\t\t__u64 watermark_percentage = (__u64)(ic->journal_entries - ic->free_sectors_threshold) * 100;\n\n\t\twatermark_percentage += ic->journal_entries / 2;\n\t\tdo_div(watermark_percentage, ic->journal_entries);\n\t\targ_count = 3;\n\t\targ_count += !!ic->meta_dev;\n\t\targ_count += ic->sectors_per_block != 1;\n\t\targ_count += !!(ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING));\n\t\targ_count += ic->reset_recalculate_flag;\n\t\targ_count += ic->discard;\n\t\targ_count += ic->mode == 'J';\n\t\targ_count += ic->mode == 'J';\n\t\targ_count += ic->mode == 'B';\n\t\targ_count += ic->mode == 'B';\n\t\targ_count += !!ic->internal_hash_alg.alg_string;\n\t\targ_count += !!ic->journal_crypt_alg.alg_string;\n\t\targ_count += !!ic->journal_mac_alg.alg_string;\n\t\targ_count += (ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_PADDING)) != 0;\n\t\targ_count += (ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_HMAC)) != 0;\n\t\targ_count += ic->legacy_recalculate;\n\t\tDMEMIT(\"%s %llu %u %c %u\", ic->dev->name, ic->start,\n\t\t       ic->tag_size, ic->mode, arg_count);\n\t\tif (ic->meta_dev)\n\t\t\tDMEMIT(\" meta_device:%s\", ic->meta_dev->name);\n\t\tif (ic->sectors_per_block != 1)\n\t\t\tDMEMIT(\" block_size:%u\", ic->sectors_per_block << SECTOR_SHIFT);\n\t\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING))\n\t\t\tDMEMIT(\" recalculate\");\n\t\tif (ic->reset_recalculate_flag)\n\t\t\tDMEMIT(\" reset_recalculate\");\n\t\tif (ic->discard)\n\t\t\tDMEMIT(\" allow_discards\");\n\t\tDMEMIT(\" journal_sectors:%u\", ic->initial_sectors - SB_SECTORS);\n\t\tDMEMIT(\" interleave_sectors:%u\", 1U << ic->sb->log2_interleave_sectors);\n\t\tDMEMIT(\" buffer_sectors:%u\", 1U << ic->log2_buffer_sectors);\n\t\tif (ic->mode == 'J') {\n\t\t\tDMEMIT(\" journal_watermark:%u\", (unsigned int)watermark_percentage);\n\t\t\tDMEMIT(\" commit_time:%u\", ic->autocommit_msec);\n\t\t}\n\t\tif (ic->mode == 'B') {\n\t\t\tDMEMIT(\" sectors_per_bit:%llu\", (sector_t)ic->sectors_per_block << ic->log2_blocks_per_bitmap_bit);\n\t\t\tDMEMIT(\" bitmap_flush_interval:%u\", jiffies_to_msecs(ic->bitmap_flush_interval));\n\t\t}\n\t\tif ((ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_PADDING)) != 0)\n\t\t\tDMEMIT(\" fix_padding\");\n\t\tif ((ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_HMAC)) != 0)\n\t\t\tDMEMIT(\" fix_hmac\");\n\t\tif (ic->legacy_recalculate)\n\t\t\tDMEMIT(\" legacy_recalculate\");\n\n#define EMIT_ALG(a, n)\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\\\n\t\t\tif (ic->a.alg_string) {\t\t\t\t\\\n\t\t\t\tDMEMIT(\" %s:%s\", n, ic->a.alg_string);\t\\\n\t\t\t\tif (ic->a.key_string)\t\t\t\\\n\t\t\t\t\tDMEMIT(\":%s\", ic->a.key_string);\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t} while (0)\n\t\tEMIT_ALG(internal_hash_alg, \"internal_hash\");\n\t\tEMIT_ALG(journal_crypt_alg, \"journal_crypt\");\n\t\tEMIT_ALG(journal_mac_alg, \"journal_mac\");\n\t\tbreak;\n\t}\n\tcase STATUSTYPE_IMA:\n\t\tDMEMIT_TARGET_NAME_VERSION(ti->type);\n\t\tDMEMIT(\",dev_name=%s,start=%llu,tag_size=%u,mode=%c\",\n\t\t\tic->dev->name, ic->start, ic->tag_size, ic->mode);\n\n\t\tif (ic->meta_dev)\n\t\t\tDMEMIT(\",meta_device=%s\", ic->meta_dev->name);\n\t\tif (ic->sectors_per_block != 1)\n\t\t\tDMEMIT(\",block_size=%u\", ic->sectors_per_block << SECTOR_SHIFT);\n\n\t\tDMEMIT(\",recalculate=%c\", (ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING)) ?\n\t\t       'y' : 'n');\n\t\tDMEMIT(\",allow_discards=%c\", ic->discard ? 'y' : 'n');\n\t\tDMEMIT(\",fix_padding=%c\",\n\t\t       ((ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_PADDING)) != 0) ? 'y' : 'n');\n\t\tDMEMIT(\",fix_hmac=%c\",\n\t\t       ((ic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_HMAC)) != 0) ? 'y' : 'n');\n\t\tDMEMIT(\",legacy_recalculate=%c\", ic->legacy_recalculate ? 'y' : 'n');\n\n\t\tDMEMIT(\",journal_sectors=%u\", ic->initial_sectors - SB_SECTORS);\n\t\tDMEMIT(\",interleave_sectors=%u\", 1U << ic->sb->log2_interleave_sectors);\n\t\tDMEMIT(\",buffer_sectors=%u\", 1U << ic->log2_buffer_sectors);\n\t\tDMEMIT(\";\");\n\t\tbreak;\n\t}\n}\n\nstatic int dm_integrity_iterate_devices(struct dm_target *ti,\n\t\t\t\t\titerate_devices_callout_fn fn, void *data)\n{\n\tstruct dm_integrity_c *ic = ti->private;\n\n\tif (!ic->meta_dev)\n\t\treturn fn(ti, ic->dev, ic->start + ic->initial_sectors + ic->metadata_run, ti->len, data);\n\telse\n\t\treturn fn(ti, ic->dev, 0, ti->len, data);\n}\n\nstatic void dm_integrity_io_hints(struct dm_target *ti, struct queue_limits *limits)\n{\n\tstruct dm_integrity_c *ic = ti->private;\n\n\tif (ic->sectors_per_block > 1) {\n\t\tlimits->logical_block_size = ic->sectors_per_block << SECTOR_SHIFT;\n\t\tlimits->physical_block_size = ic->sectors_per_block << SECTOR_SHIFT;\n\t\tblk_limits_io_min(limits, ic->sectors_per_block << SECTOR_SHIFT);\n\t\tlimits->dma_alignment = limits->logical_block_size - 1;\n\t}\n}\n\nstatic void calculate_journal_section_size(struct dm_integrity_c *ic)\n{\n\tunsigned int sector_space = JOURNAL_SECTOR_DATA;\n\n\tic->journal_sections = le32_to_cpu(ic->sb->journal_sections);\n\tic->journal_entry_size = roundup(offsetof(struct journal_entry, last_bytes[ic->sectors_per_block]) + ic->tag_size,\n\t\t\t\t\t JOURNAL_ENTRY_ROUNDUP);\n\n\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_HAVE_JOURNAL_MAC))\n\t\tsector_space -= JOURNAL_MAC_PER_SECTOR;\n\tic->journal_entries_per_sector = sector_space / ic->journal_entry_size;\n\tic->journal_section_entries = ic->journal_entries_per_sector * JOURNAL_BLOCK_SECTORS;\n\tic->journal_section_sectors = (ic->journal_section_entries << ic->sb->log2_sectors_per_block) + JOURNAL_BLOCK_SECTORS;\n\tic->journal_entries = ic->journal_section_entries * ic->journal_sections;\n}\n\nstatic int calculate_device_limits(struct dm_integrity_c *ic)\n{\n\t__u64 initial_sectors;\n\n\tcalculate_journal_section_size(ic);\n\tinitial_sectors = SB_SECTORS + (__u64)ic->journal_section_sectors * ic->journal_sections;\n\tif (initial_sectors + METADATA_PADDING_SECTORS >= ic->meta_device_sectors || initial_sectors > UINT_MAX)\n\t\treturn -EINVAL;\n\tic->initial_sectors = initial_sectors;\n\n\tif (!ic->meta_dev) {\n\t\tsector_t last_sector, last_area, last_offset;\n\n\t\t \n\t\t__u64 metadata_run_padding =\n\t\t\tic->sb->flags & cpu_to_le32(SB_FLAG_FIXED_PADDING) ?\n\t\t\t(__u64)(METADATA_PADDING_SECTORS << SECTOR_SHIFT) :\n\t\t\t(__u64)(1 << SECTOR_SHIFT << METADATA_PADDING_SECTORS);\n\n\t\tic->metadata_run = round_up((__u64)ic->tag_size << (ic->sb->log2_interleave_sectors - ic->sb->log2_sectors_per_block),\n\t\t\t\t\t    metadata_run_padding) >> SECTOR_SHIFT;\n\t\tif (!(ic->metadata_run & (ic->metadata_run - 1)))\n\t\t\tic->log2_metadata_run = __ffs(ic->metadata_run);\n\t\telse\n\t\t\tic->log2_metadata_run = -1;\n\n\t\tget_area_and_offset(ic, ic->provided_data_sectors - 1, &last_area, &last_offset);\n\t\tlast_sector = get_data_sector(ic, last_area, last_offset);\n\t\tif (last_sector < ic->start || last_sector >= ic->meta_device_sectors)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t__u64 meta_size = (ic->provided_data_sectors >> ic->sb->log2_sectors_per_block) * ic->tag_size;\n\n\t\tmeta_size = (meta_size + ((1U << (ic->log2_buffer_sectors + SECTOR_SHIFT)) - 1))\n\t\t\t\t>> (ic->log2_buffer_sectors + SECTOR_SHIFT);\n\t\tmeta_size <<= ic->log2_buffer_sectors;\n\t\tif (ic->initial_sectors + meta_size < ic->initial_sectors ||\n\t\t    ic->initial_sectors + meta_size > ic->meta_device_sectors)\n\t\t\treturn -EINVAL;\n\t\tic->metadata_run = 1;\n\t\tic->log2_metadata_run = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void get_provided_data_sectors(struct dm_integrity_c *ic)\n{\n\tif (!ic->meta_dev) {\n\t\tint test_bit;\n\n\t\tic->provided_data_sectors = 0;\n\t\tfor (test_bit = fls64(ic->meta_device_sectors) - 1; test_bit >= 3; test_bit--) {\n\t\t\t__u64 prev_data_sectors = ic->provided_data_sectors;\n\n\t\t\tic->provided_data_sectors |= (sector_t)1 << test_bit;\n\t\t\tif (calculate_device_limits(ic))\n\t\t\t\tic->provided_data_sectors = prev_data_sectors;\n\t\t}\n\t} else {\n\t\tic->provided_data_sectors = ic->data_device_sectors;\n\t\tic->provided_data_sectors &= ~(sector_t)(ic->sectors_per_block - 1);\n\t}\n}\n\nstatic int initialize_superblock(struct dm_integrity_c *ic,\n\t\t\t\t unsigned int journal_sectors, unsigned int interleave_sectors)\n{\n\tunsigned int journal_sections;\n\tint test_bit;\n\n\tmemset(ic->sb, 0, SB_SECTORS << SECTOR_SHIFT);\n\tmemcpy(ic->sb->magic, SB_MAGIC, 8);\n\tic->sb->integrity_tag_size = cpu_to_le16(ic->tag_size);\n\tic->sb->log2_sectors_per_block = __ffs(ic->sectors_per_block);\n\tif (ic->journal_mac_alg.alg_string)\n\t\tic->sb->flags |= cpu_to_le32(SB_FLAG_HAVE_JOURNAL_MAC);\n\n\tcalculate_journal_section_size(ic);\n\tjournal_sections = journal_sectors / ic->journal_section_sectors;\n\tif (!journal_sections)\n\t\tjournal_sections = 1;\n\n\tif (ic->fix_hmac && (ic->internal_hash_alg.alg_string || ic->journal_mac_alg.alg_string)) {\n\t\tic->sb->flags |= cpu_to_le32(SB_FLAG_FIXED_HMAC);\n\t\tget_random_bytes(ic->sb->salt, SALT_SIZE);\n\t}\n\n\tif (!ic->meta_dev) {\n\t\tif (ic->fix_padding)\n\t\t\tic->sb->flags |= cpu_to_le32(SB_FLAG_FIXED_PADDING);\n\t\tic->sb->journal_sections = cpu_to_le32(journal_sections);\n\t\tif (!interleave_sectors)\n\t\t\tinterleave_sectors = DEFAULT_INTERLEAVE_SECTORS;\n\t\tic->sb->log2_interleave_sectors = __fls(interleave_sectors);\n\t\tic->sb->log2_interleave_sectors = max_t(__u8, MIN_LOG2_INTERLEAVE_SECTORS, ic->sb->log2_interleave_sectors);\n\t\tic->sb->log2_interleave_sectors = min_t(__u8, MAX_LOG2_INTERLEAVE_SECTORS, ic->sb->log2_interleave_sectors);\n\n\t\tget_provided_data_sectors(ic);\n\t\tif (!ic->provided_data_sectors)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tic->sb->log2_interleave_sectors = 0;\n\n\t\tget_provided_data_sectors(ic);\n\t\tif (!ic->provided_data_sectors)\n\t\t\treturn -EINVAL;\n\ntry_smaller_buffer:\n\t\tic->sb->journal_sections = cpu_to_le32(0);\n\t\tfor (test_bit = fls(journal_sections) - 1; test_bit >= 0; test_bit--) {\n\t\t\t__u32 prev_journal_sections = le32_to_cpu(ic->sb->journal_sections);\n\t\t\t__u32 test_journal_sections = prev_journal_sections | (1U << test_bit);\n\n\t\t\tif (test_journal_sections > journal_sections)\n\t\t\t\tcontinue;\n\t\t\tic->sb->journal_sections = cpu_to_le32(test_journal_sections);\n\t\t\tif (calculate_device_limits(ic))\n\t\t\t\tic->sb->journal_sections = cpu_to_le32(prev_journal_sections);\n\n\t\t}\n\t\tif (!le32_to_cpu(ic->sb->journal_sections)) {\n\t\t\tif (ic->log2_buffer_sectors > 3) {\n\t\t\t\tic->log2_buffer_sectors--;\n\t\t\t\tgoto try_smaller_buffer;\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tic->sb->provided_data_sectors = cpu_to_le64(ic->provided_data_sectors);\n\n\tsb_set_version(ic);\n\n\treturn 0;\n}\n\nstatic void dm_integrity_set(struct dm_target *ti, struct dm_integrity_c *ic)\n{\n\tstruct gendisk *disk = dm_disk(dm_table_get_md(ti->table));\n\tstruct blk_integrity bi;\n\n\tmemset(&bi, 0, sizeof(bi));\n\tbi.profile = &dm_integrity_profile;\n\tbi.tuple_size = ic->tag_size;\n\tbi.tag_size = bi.tuple_size;\n\tbi.interval_exp = ic->sb->log2_sectors_per_block + SECTOR_SHIFT;\n\n\tblk_integrity_register(disk, &bi);\n\tblk_queue_max_integrity_segments(disk->queue, UINT_MAX);\n}\n\nstatic void dm_integrity_free_page_list(struct page_list *pl)\n{\n\tunsigned int i;\n\n\tif (!pl)\n\t\treturn;\n\tfor (i = 0; pl[i].page; i++)\n\t\t__free_page(pl[i].page);\n\tkvfree(pl);\n}\n\nstatic struct page_list *dm_integrity_alloc_page_list(unsigned int n_pages)\n{\n\tstruct page_list *pl;\n\tunsigned int i;\n\n\tpl = kvmalloc_array(n_pages + 1, sizeof(struct page_list), GFP_KERNEL | __GFP_ZERO);\n\tif (!pl)\n\t\treturn NULL;\n\n\tfor (i = 0; i < n_pages; i++) {\n\t\tpl[i].page = alloc_page(GFP_KERNEL);\n\t\tif (!pl[i].page) {\n\t\t\tdm_integrity_free_page_list(pl);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (i)\n\t\t\tpl[i - 1].next = &pl[i];\n\t}\n\tpl[i].page = NULL;\n\tpl[i].next = NULL;\n\n\treturn pl;\n}\n\nstatic void dm_integrity_free_journal_scatterlist(struct dm_integrity_c *ic, struct scatterlist **sl)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ic->journal_sections; i++)\n\t\tkvfree(sl[i]);\n\tkvfree(sl);\n}\n\nstatic struct scatterlist **dm_integrity_alloc_journal_scatterlist(struct dm_integrity_c *ic,\n\t\t\t\t\t\t\t\t   struct page_list *pl)\n{\n\tstruct scatterlist **sl;\n\tunsigned int i;\n\n\tsl = kvmalloc_array(ic->journal_sections,\n\t\t\t    sizeof(struct scatterlist *),\n\t\t\t    GFP_KERNEL | __GFP_ZERO);\n\tif (!sl)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ic->journal_sections; i++) {\n\t\tstruct scatterlist *s;\n\t\tunsigned int start_index, start_offset;\n\t\tunsigned int end_index, end_offset;\n\t\tunsigned int n_pages;\n\t\tunsigned int idx;\n\n\t\tpage_list_location(ic, i, 0, &start_index, &start_offset);\n\t\tpage_list_location(ic, i, ic->journal_section_sectors - 1,\n\t\t\t\t   &end_index, &end_offset);\n\n\t\tn_pages = (end_index - start_index + 1);\n\n\t\ts = kvmalloc_array(n_pages, sizeof(struct scatterlist),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!s) {\n\t\t\tdm_integrity_free_journal_scatterlist(ic, sl);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsg_init_table(s, n_pages);\n\t\tfor (idx = start_index; idx <= end_index; idx++) {\n\t\t\tchar *va = lowmem_page_address(pl[idx].page);\n\t\t\tunsigned int start = 0, end = PAGE_SIZE;\n\n\t\t\tif (idx == start_index)\n\t\t\t\tstart = start_offset;\n\t\t\tif (idx == end_index)\n\t\t\t\tend = end_offset + (1 << SECTOR_SHIFT);\n\t\t\tsg_set_buf(&s[idx - start_index], va + start, end - start);\n\t\t}\n\n\t\tsl[i] = s;\n\t}\n\n\treturn sl;\n}\n\nstatic void free_alg(struct alg_spec *a)\n{\n\tkfree_sensitive(a->alg_string);\n\tkfree_sensitive(a->key);\n\tmemset(a, 0, sizeof(*a));\n}\n\nstatic int get_alg_and_key(const char *arg, struct alg_spec *a, char **error, char *error_inval)\n{\n\tchar *k;\n\n\tfree_alg(a);\n\n\ta->alg_string = kstrdup(strchr(arg, ':') + 1, GFP_KERNEL);\n\tif (!a->alg_string)\n\t\tgoto nomem;\n\n\tk = strchr(a->alg_string, ':');\n\tif (k) {\n\t\t*k = 0;\n\t\ta->key_string = k + 1;\n\t\tif (strlen(a->key_string) & 1)\n\t\t\tgoto inval;\n\n\t\ta->key_size = strlen(a->key_string) / 2;\n\t\ta->key = kmalloc(a->key_size, GFP_KERNEL);\n\t\tif (!a->key)\n\t\t\tgoto nomem;\n\t\tif (hex2bin(a->key, a->key_string, a->key_size))\n\t\t\tgoto inval;\n\t}\n\n\treturn 0;\ninval:\n\t*error = error_inval;\n\treturn -EINVAL;\nnomem:\n\t*error = \"Out of memory for an argument\";\n\treturn -ENOMEM;\n}\n\nstatic int get_mac(struct crypto_shash **hash, struct alg_spec *a, char **error,\n\t\t   char *error_alg, char *error_key)\n{\n\tint r;\n\n\tif (a->alg_string) {\n\t\t*hash = crypto_alloc_shash(a->alg_string, 0, CRYPTO_ALG_ALLOCATES_MEMORY);\n\t\tif (IS_ERR(*hash)) {\n\t\t\t*error = error_alg;\n\t\t\tr = PTR_ERR(*hash);\n\t\t\t*hash = NULL;\n\t\t\treturn r;\n\t\t}\n\n\t\tif (a->key) {\n\t\t\tr = crypto_shash_setkey(*hash, a->key, a->key_size);\n\t\t\tif (r) {\n\t\t\t\t*error = error_key;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t} else if (crypto_shash_get_flags(*hash) & CRYPTO_TFM_NEED_KEY) {\n\t\t\t*error = error_key;\n\t\t\treturn -ENOKEY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int create_journal(struct dm_integrity_c *ic, char **error)\n{\n\tint r = 0;\n\tunsigned int i;\n\t__u64 journal_pages, journal_desc_size, journal_tree_size;\n\tunsigned char *crypt_data = NULL, *crypt_iv = NULL;\n\tstruct skcipher_request *req = NULL;\n\n\tic->commit_ids[0] = cpu_to_le64(0x1111111111111111ULL);\n\tic->commit_ids[1] = cpu_to_le64(0x2222222222222222ULL);\n\tic->commit_ids[2] = cpu_to_le64(0x3333333333333333ULL);\n\tic->commit_ids[3] = cpu_to_le64(0x4444444444444444ULL);\n\n\tjournal_pages = roundup((__u64)ic->journal_sections * ic->journal_section_sectors,\n\t\t\t\tPAGE_SIZE >> SECTOR_SHIFT) >> (PAGE_SHIFT - SECTOR_SHIFT);\n\tjournal_desc_size = journal_pages * sizeof(struct page_list);\n\tif (journal_pages >= totalram_pages() - totalhigh_pages() || journal_desc_size > ULONG_MAX) {\n\t\t*error = \"Journal doesn't fit into memory\";\n\t\tr = -ENOMEM;\n\t\tgoto bad;\n\t}\n\tic->journal_pages = journal_pages;\n\n\tic->journal = dm_integrity_alloc_page_list(ic->journal_pages);\n\tif (!ic->journal) {\n\t\t*error = \"Could not allocate memory for journal\";\n\t\tr = -ENOMEM;\n\t\tgoto bad;\n\t}\n\tif (ic->journal_crypt_alg.alg_string) {\n\t\tunsigned int ivsize, blocksize;\n\t\tstruct journal_completion comp;\n\n\t\tcomp.ic = ic;\n\t\tic->journal_crypt = crypto_alloc_skcipher(ic->journal_crypt_alg.alg_string, 0, CRYPTO_ALG_ALLOCATES_MEMORY);\n\t\tif (IS_ERR(ic->journal_crypt)) {\n\t\t\t*error = \"Invalid journal cipher\";\n\t\t\tr = PTR_ERR(ic->journal_crypt);\n\t\t\tic->journal_crypt = NULL;\n\t\t\tgoto bad;\n\t\t}\n\t\tivsize = crypto_skcipher_ivsize(ic->journal_crypt);\n\t\tblocksize = crypto_skcipher_blocksize(ic->journal_crypt);\n\n\t\tif (ic->journal_crypt_alg.key) {\n\t\t\tr = crypto_skcipher_setkey(ic->journal_crypt, ic->journal_crypt_alg.key,\n\t\t\t\t\t\t   ic->journal_crypt_alg.key_size);\n\t\t\tif (r) {\n\t\t\t\t*error = \"Error setting encryption key\";\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t\tDEBUG_print(\"cipher %s, block size %u iv size %u\\n\",\n\t\t\t    ic->journal_crypt_alg.alg_string, blocksize, ivsize);\n\n\t\tic->journal_io = dm_integrity_alloc_page_list(ic->journal_pages);\n\t\tif (!ic->journal_io) {\n\t\t\t*error = \"Could not allocate memory for journal io\";\n\t\t\tr = -ENOMEM;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (blocksize == 1) {\n\t\t\tstruct scatterlist *sg;\n\n\t\t\treq = skcipher_request_alloc(ic->journal_crypt, GFP_KERNEL);\n\t\t\tif (!req) {\n\t\t\t\t*error = \"Could not allocate crypt request\";\n\t\t\t\tr = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\n\t\t\tcrypt_iv = kzalloc(ivsize, GFP_KERNEL);\n\t\t\tif (!crypt_iv) {\n\t\t\t\t*error = \"Could not allocate iv\";\n\t\t\t\tr = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\n\t\t\tic->journal_xor = dm_integrity_alloc_page_list(ic->journal_pages);\n\t\t\tif (!ic->journal_xor) {\n\t\t\t\t*error = \"Could not allocate memory for journal xor\";\n\t\t\t\tr = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\n\t\t\tsg = kvmalloc_array(ic->journal_pages + 1,\n\t\t\t\t\t    sizeof(struct scatterlist),\n\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (!sg) {\n\t\t\t\t*error = \"Unable to allocate sg list\";\n\t\t\t\tr = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tsg_init_table(sg, ic->journal_pages + 1);\n\t\t\tfor (i = 0; i < ic->journal_pages; i++) {\n\t\t\t\tchar *va = lowmem_page_address(ic->journal_xor[i].page);\n\n\t\t\t\tclear_page(va);\n\t\t\t\tsg_set_buf(&sg[i], va, PAGE_SIZE);\n\t\t\t}\n\t\t\tsg_set_buf(&sg[i], &ic->commit_ids, sizeof(ic->commit_ids));\n\n\t\t\tskcipher_request_set_crypt(req, sg, sg,\n\t\t\t\t\t\t   PAGE_SIZE * ic->journal_pages + sizeof(ic->commit_ids), crypt_iv);\n\t\t\tinit_completion(&comp.comp);\n\t\t\tcomp.in_flight = (atomic_t)ATOMIC_INIT(1);\n\t\t\tif (do_crypt(true, req, &comp))\n\t\t\t\twait_for_completion(&comp.comp);\n\t\t\tkvfree(sg);\n\t\t\tr = dm_integrity_failed(ic);\n\t\t\tif (r) {\n\t\t\t\t*error = \"Unable to encrypt journal\";\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tDEBUG_bytes(lowmem_page_address(ic->journal_xor[0].page), 64, \"xor data\");\n\n\t\t\tcrypto_free_skcipher(ic->journal_crypt);\n\t\t\tic->journal_crypt = NULL;\n\t\t} else {\n\t\t\tunsigned int crypt_len = roundup(ivsize, blocksize);\n\n\t\t\treq = skcipher_request_alloc(ic->journal_crypt, GFP_KERNEL);\n\t\t\tif (!req) {\n\t\t\t\t*error = \"Could not allocate crypt request\";\n\t\t\t\tr = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\n\t\t\tcrypt_iv = kmalloc(ivsize, GFP_KERNEL);\n\t\t\tif (!crypt_iv) {\n\t\t\t\t*error = \"Could not allocate iv\";\n\t\t\t\tr = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\n\t\t\tcrypt_data = kmalloc(crypt_len, GFP_KERNEL);\n\t\t\tif (!crypt_data) {\n\t\t\t\t*error = \"Unable to allocate crypt data\";\n\t\t\t\tr = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\n\t\t\tic->journal_scatterlist = dm_integrity_alloc_journal_scatterlist(ic, ic->journal);\n\t\t\tif (!ic->journal_scatterlist) {\n\t\t\t\t*error = \"Unable to allocate sg list\";\n\t\t\t\tr = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tic->journal_io_scatterlist = dm_integrity_alloc_journal_scatterlist(ic, ic->journal_io);\n\t\t\tif (!ic->journal_io_scatterlist) {\n\t\t\t\t*error = \"Unable to allocate sg list\";\n\t\t\t\tr = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tic->sk_requests = kvmalloc_array(ic->journal_sections,\n\t\t\t\t\t\t\t sizeof(struct skcipher_request *),\n\t\t\t\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\t\t\tif (!ic->sk_requests) {\n\t\t\t\t*error = \"Unable to allocate sk requests\";\n\t\t\t\tr = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tfor (i = 0; i < ic->journal_sections; i++) {\n\t\t\t\tstruct scatterlist sg;\n\t\t\t\tstruct skcipher_request *section_req;\n\t\t\t\t__le32 section_le = cpu_to_le32(i);\n\n\t\t\t\tmemset(crypt_iv, 0x00, ivsize);\n\t\t\t\tmemset(crypt_data, 0x00, crypt_len);\n\t\t\t\tmemcpy(crypt_data, &section_le, min_t(size_t, crypt_len, sizeof(section_le)));\n\n\t\t\t\tsg_init_one(&sg, crypt_data, crypt_len);\n\t\t\t\tskcipher_request_set_crypt(req, &sg, &sg, crypt_len, crypt_iv);\n\t\t\t\tinit_completion(&comp.comp);\n\t\t\t\tcomp.in_flight = (atomic_t)ATOMIC_INIT(1);\n\t\t\t\tif (do_crypt(true, req, &comp))\n\t\t\t\t\twait_for_completion(&comp.comp);\n\n\t\t\t\tr = dm_integrity_failed(ic);\n\t\t\t\tif (r) {\n\t\t\t\t\t*error = \"Unable to generate iv\";\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\n\t\t\t\tsection_req = skcipher_request_alloc(ic->journal_crypt, GFP_KERNEL);\n\t\t\t\tif (!section_req) {\n\t\t\t\t\t*error = \"Unable to allocate crypt request\";\n\t\t\t\t\tr = -ENOMEM;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tsection_req->iv = kmalloc_array(ivsize, 2,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (!section_req->iv) {\n\t\t\t\t\tskcipher_request_free(section_req);\n\t\t\t\t\t*error = \"Unable to allocate iv\";\n\t\t\t\t\tr = -ENOMEM;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tmemcpy(section_req->iv + ivsize, crypt_data, ivsize);\n\t\t\t\tsection_req->cryptlen = (size_t)ic->journal_section_sectors << SECTOR_SHIFT;\n\t\t\t\tic->sk_requests[i] = section_req;\n\t\t\t\tDEBUG_bytes(crypt_data, ivsize, \"iv(%u)\", i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < N_COMMIT_IDS; i++) {\n\t\tunsigned int j;\n\nretest_commit_id:\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (ic->commit_ids[j] == ic->commit_ids[i]) {\n\t\t\t\tic->commit_ids[i] = cpu_to_le64(le64_to_cpu(ic->commit_ids[i]) + 1);\n\t\t\t\tgoto retest_commit_id;\n\t\t\t}\n\t\t}\n\t\tDEBUG_print(\"commit id %u: %016llx\\n\", i, ic->commit_ids[i]);\n\t}\n\n\tjournal_tree_size = (__u64)ic->journal_entries * sizeof(struct journal_node);\n\tif (journal_tree_size > ULONG_MAX) {\n\t\t*error = \"Journal doesn't fit into memory\";\n\t\tr = -ENOMEM;\n\t\tgoto bad;\n\t}\n\tic->journal_tree = kvmalloc(journal_tree_size, GFP_KERNEL);\n\tif (!ic->journal_tree) {\n\t\t*error = \"Could not allocate memory for journal tree\";\n\t\tr = -ENOMEM;\n\t}\nbad:\n\tkfree(crypt_data);\n\tkfree(crypt_iv);\n\tskcipher_request_free(req);\n\n\treturn r;\n}\n\n \nstatic int dm_integrity_ctr(struct dm_target *ti, unsigned int argc, char **argv)\n{\n\tstruct dm_integrity_c *ic;\n\tchar dummy;\n\tint r;\n\tunsigned int extra_args;\n\tstruct dm_arg_set as;\n\tstatic const struct dm_arg _args[] = {\n\t\t{0, 18, \"Invalid number of feature args\"},\n\t};\n\tunsigned int journal_sectors, interleave_sectors, buffer_sectors, journal_watermark, sync_msec;\n\tbool should_write_sb;\n\t__u64 threshold;\n\tunsigned long long start;\n\t__s8 log2_sectors_per_bitmap_bit = -1;\n\t__s8 log2_blocks_per_bitmap_bit;\n\t__u64 bits_in_journal;\n\t__u64 n_bitmap_bits;\n\n#define DIRECT_ARGUMENTS\t4\n\n\tif (argc <= DIRECT_ARGUMENTS) {\n\t\tti->error = \"Invalid argument count\";\n\t\treturn -EINVAL;\n\t}\n\n\tic = kzalloc(sizeof(struct dm_integrity_c), GFP_KERNEL);\n\tif (!ic) {\n\t\tti->error = \"Cannot allocate integrity context\";\n\t\treturn -ENOMEM;\n\t}\n\tti->private = ic;\n\tti->per_io_data_size = sizeof(struct dm_integrity_io);\n\tic->ti = ti;\n\n\tic->in_progress = RB_ROOT;\n\tINIT_LIST_HEAD(&ic->wait_list);\n\tinit_waitqueue_head(&ic->endio_wait);\n\tbio_list_init(&ic->flush_bio_list);\n\tinit_waitqueue_head(&ic->copy_to_journal_wait);\n\tinit_completion(&ic->crypto_backoff);\n\tatomic64_set(&ic->number_of_mismatches, 0);\n\tic->bitmap_flush_interval = BITMAP_FLUSH_INTERVAL;\n\n\tr = dm_get_device(ti, argv[0], dm_table_get_mode(ti->table), &ic->dev);\n\tif (r) {\n\t\tti->error = \"Device lookup failed\";\n\t\tgoto bad;\n\t}\n\n\tif (sscanf(argv[1], \"%llu%c\", &start, &dummy) != 1 || start != (sector_t)start) {\n\t\tti->error = \"Invalid starting offset\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\tic->start = start;\n\n\tif (strcmp(argv[2], \"-\")) {\n\t\tif (sscanf(argv[2], \"%u%c\", &ic->tag_size, &dummy) != 1 || !ic->tag_size) {\n\t\t\tti->error = \"Invalid tag size\";\n\t\t\tr = -EINVAL;\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\tif (!strcmp(argv[3], \"J\") || !strcmp(argv[3], \"B\") ||\n\t    !strcmp(argv[3], \"D\") || !strcmp(argv[3], \"R\")) {\n\t\tic->mode = argv[3][0];\n\t} else {\n\t\tti->error = \"Invalid mode (expecting J, B, D, R)\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\tjournal_sectors = 0;\n\tinterleave_sectors = DEFAULT_INTERLEAVE_SECTORS;\n\tbuffer_sectors = DEFAULT_BUFFER_SECTORS;\n\tjournal_watermark = DEFAULT_JOURNAL_WATERMARK;\n\tsync_msec = DEFAULT_SYNC_MSEC;\n\tic->sectors_per_block = 1;\n\n\tas.argc = argc - DIRECT_ARGUMENTS;\n\tas.argv = argv + DIRECT_ARGUMENTS;\n\tr = dm_read_arg_group(_args, &as, &extra_args, &ti->error);\n\tif (r)\n\t\tgoto bad;\n\n\twhile (extra_args--) {\n\t\tconst char *opt_string;\n\t\tunsigned int val;\n\t\tunsigned long long llval;\n\n\t\topt_string = dm_shift_arg(&as);\n\t\tif (!opt_string) {\n\t\t\tr = -EINVAL;\n\t\t\tti->error = \"Not enough feature arguments\";\n\t\t\tgoto bad;\n\t\t}\n\t\tif (sscanf(opt_string, \"journal_sectors:%u%c\", &val, &dummy) == 1)\n\t\t\tjournal_sectors = val ? val : 1;\n\t\telse if (sscanf(opt_string, \"interleave_sectors:%u%c\", &val, &dummy) == 1)\n\t\t\tinterleave_sectors = val;\n\t\telse if (sscanf(opt_string, \"buffer_sectors:%u%c\", &val, &dummy) == 1)\n\t\t\tbuffer_sectors = val;\n\t\telse if (sscanf(opt_string, \"journal_watermark:%u%c\", &val, &dummy) == 1 && val <= 100)\n\t\t\tjournal_watermark = val;\n\t\telse if (sscanf(opt_string, \"commit_time:%u%c\", &val, &dummy) == 1)\n\t\t\tsync_msec = val;\n\t\telse if (!strncmp(opt_string, \"meta_device:\", strlen(\"meta_device:\"))) {\n\t\t\tif (ic->meta_dev) {\n\t\t\t\tdm_put_device(ti, ic->meta_dev);\n\t\t\t\tic->meta_dev = NULL;\n\t\t\t}\n\t\t\tr = dm_get_device(ti, strchr(opt_string, ':') + 1,\n\t\t\t\t\t  dm_table_get_mode(ti->table), &ic->meta_dev);\n\t\t\tif (r) {\n\t\t\t\tti->error = \"Device lookup failed\";\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t} else if (sscanf(opt_string, \"block_size:%u%c\", &val, &dummy) == 1) {\n\t\t\tif (val < 1 << SECTOR_SHIFT ||\n\t\t\t    val > MAX_SECTORS_PER_BLOCK << SECTOR_SHIFT ||\n\t\t\t    (val & (val - 1))) {\n\t\t\t\tr = -EINVAL;\n\t\t\t\tti->error = \"Invalid block_size argument\";\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tic->sectors_per_block = val >> SECTOR_SHIFT;\n\t\t} else if (sscanf(opt_string, \"sectors_per_bit:%llu%c\", &llval, &dummy) == 1) {\n\t\t\tlog2_sectors_per_bitmap_bit = !llval ? 0 : __ilog2_u64(llval);\n\t\t} else if (sscanf(opt_string, \"bitmap_flush_interval:%u%c\", &val, &dummy) == 1) {\n\t\t\tif (val >= (uint64_t)UINT_MAX * 1000 / HZ) {\n\t\t\t\tr = -EINVAL;\n\t\t\t\tti->error = \"Invalid bitmap_flush_interval argument\";\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tic->bitmap_flush_interval = msecs_to_jiffies(val);\n\t\t} else if (!strncmp(opt_string, \"internal_hash:\", strlen(\"internal_hash:\"))) {\n\t\t\tr = get_alg_and_key(opt_string, &ic->internal_hash_alg, &ti->error,\n\t\t\t\t\t    \"Invalid internal_hash argument\");\n\t\t\tif (r)\n\t\t\t\tgoto bad;\n\t\t} else if (!strncmp(opt_string, \"journal_crypt:\", strlen(\"journal_crypt:\"))) {\n\t\t\tr = get_alg_and_key(opt_string, &ic->journal_crypt_alg, &ti->error,\n\t\t\t\t\t    \"Invalid journal_crypt argument\");\n\t\t\tif (r)\n\t\t\t\tgoto bad;\n\t\t} else if (!strncmp(opt_string, \"journal_mac:\", strlen(\"journal_mac:\"))) {\n\t\t\tr = get_alg_and_key(opt_string, &ic->journal_mac_alg, &ti->error,\n\t\t\t\t\t    \"Invalid journal_mac argument\");\n\t\t\tif (r)\n\t\t\t\tgoto bad;\n\t\t} else if (!strcmp(opt_string, \"recalculate\")) {\n\t\t\tic->recalculate_flag = true;\n\t\t} else if (!strcmp(opt_string, \"reset_recalculate\")) {\n\t\t\tic->recalculate_flag = true;\n\t\t\tic->reset_recalculate_flag = true;\n\t\t} else if (!strcmp(opt_string, \"allow_discards\")) {\n\t\t\tic->discard = true;\n\t\t} else if (!strcmp(opt_string, \"fix_padding\")) {\n\t\t\tic->fix_padding = true;\n\t\t} else if (!strcmp(opt_string, \"fix_hmac\")) {\n\t\t\tic->fix_hmac = true;\n\t\t} else if (!strcmp(opt_string, \"legacy_recalculate\")) {\n\t\t\tic->legacy_recalculate = true;\n\t\t} else {\n\t\t\tr = -EINVAL;\n\t\t\tti->error = \"Invalid argument\";\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\tic->data_device_sectors = bdev_nr_sectors(ic->dev->bdev);\n\tif (!ic->meta_dev)\n\t\tic->meta_device_sectors = ic->data_device_sectors;\n\telse\n\t\tic->meta_device_sectors = bdev_nr_sectors(ic->meta_dev->bdev);\n\n\tif (!journal_sectors) {\n\t\tjournal_sectors = min((sector_t)DEFAULT_MAX_JOURNAL_SECTORS,\n\t\t\t\t      ic->data_device_sectors >> DEFAULT_JOURNAL_SIZE_FACTOR);\n\t}\n\n\tif (!buffer_sectors)\n\t\tbuffer_sectors = 1;\n\tic->log2_buffer_sectors = min((int)__fls(buffer_sectors), 31 - SECTOR_SHIFT);\n\n\tr = get_mac(&ic->internal_hash, &ic->internal_hash_alg, &ti->error,\n\t\t    \"Invalid internal hash\", \"Error setting internal hash key\");\n\tif (r)\n\t\tgoto bad;\n\n\tr = get_mac(&ic->journal_mac, &ic->journal_mac_alg, &ti->error,\n\t\t    \"Invalid journal mac\", \"Error setting journal mac key\");\n\tif (r)\n\t\tgoto bad;\n\n\tif (!ic->tag_size) {\n\t\tif (!ic->internal_hash) {\n\t\t\tti->error = \"Unknown tag size\";\n\t\t\tr = -EINVAL;\n\t\t\tgoto bad;\n\t\t}\n\t\tic->tag_size = crypto_shash_digestsize(ic->internal_hash);\n\t}\n\tif (ic->tag_size > MAX_TAG_SIZE) {\n\t\tti->error = \"Too big tag size\";\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\tif (!(ic->tag_size & (ic->tag_size - 1)))\n\t\tic->log2_tag_size = __ffs(ic->tag_size);\n\telse\n\t\tic->log2_tag_size = -1;\n\n\tif (ic->mode == 'B' && !ic->internal_hash) {\n\t\tr = -EINVAL;\n\t\tti->error = \"Bitmap mode can be only used with internal hash\";\n\t\tgoto bad;\n\t}\n\n\tif (ic->discard && !ic->internal_hash) {\n\t\tr = -EINVAL;\n\t\tti->error = \"Discard can be only used with internal hash\";\n\t\tgoto bad;\n\t}\n\n\tic->autocommit_jiffies = msecs_to_jiffies(sync_msec);\n\tic->autocommit_msec = sync_msec;\n\ttimer_setup(&ic->autocommit_timer, autocommit_fn, 0);\n\n\tic->io = dm_io_client_create();\n\tif (IS_ERR(ic->io)) {\n\t\tr = PTR_ERR(ic->io);\n\t\tic->io = NULL;\n\t\tti->error = \"Cannot allocate dm io\";\n\t\tgoto bad;\n\t}\n\n\tr = mempool_init_slab_pool(&ic->journal_io_mempool, JOURNAL_IO_MEMPOOL, journal_io_cache);\n\tif (r) {\n\t\tti->error = \"Cannot allocate mempool\";\n\t\tgoto bad;\n\t}\n\n\tic->metadata_wq = alloc_workqueue(\"dm-integrity-metadata\",\n\t\t\t\t\t  WQ_MEM_RECLAIM, METADATA_WORKQUEUE_MAX_ACTIVE);\n\tif (!ic->metadata_wq) {\n\t\tti->error = \"Cannot allocate workqueue\";\n\t\tr = -ENOMEM;\n\t\tgoto bad;\n\t}\n\n\t \n\tic->wait_wq = alloc_ordered_workqueue(\"dm-integrity-wait\", WQ_MEM_RECLAIM);\n\tif (!ic->wait_wq) {\n\t\tti->error = \"Cannot allocate workqueue\";\n\t\tr = -ENOMEM;\n\t\tgoto bad;\n\t}\n\n\tic->offload_wq = alloc_workqueue(\"dm-integrity-offload\", WQ_MEM_RECLAIM,\n\t\t\t\t\t  METADATA_WORKQUEUE_MAX_ACTIVE);\n\tif (!ic->offload_wq) {\n\t\tti->error = \"Cannot allocate workqueue\";\n\t\tr = -ENOMEM;\n\t\tgoto bad;\n\t}\n\n\tic->commit_wq = alloc_workqueue(\"dm-integrity-commit\", WQ_MEM_RECLAIM, 1);\n\tif (!ic->commit_wq) {\n\t\tti->error = \"Cannot allocate workqueue\";\n\t\tr = -ENOMEM;\n\t\tgoto bad;\n\t}\n\tINIT_WORK(&ic->commit_work, integrity_commit);\n\n\tif (ic->mode == 'J' || ic->mode == 'B') {\n\t\tic->writer_wq = alloc_workqueue(\"dm-integrity-writer\", WQ_MEM_RECLAIM, 1);\n\t\tif (!ic->writer_wq) {\n\t\t\tti->error = \"Cannot allocate workqueue\";\n\t\t\tr = -ENOMEM;\n\t\t\tgoto bad;\n\t\t}\n\t\tINIT_WORK(&ic->writer_work, integrity_writer);\n\t}\n\n\tic->sb = alloc_pages_exact(SB_SECTORS << SECTOR_SHIFT, GFP_KERNEL);\n\tif (!ic->sb) {\n\t\tr = -ENOMEM;\n\t\tti->error = \"Cannot allocate superblock area\";\n\t\tgoto bad;\n\t}\n\n\tr = sync_rw_sb(ic, REQ_OP_READ);\n\tif (r) {\n\t\tti->error = \"Error reading superblock\";\n\t\tgoto bad;\n\t}\n\tshould_write_sb = false;\n\tif (memcmp(ic->sb->magic, SB_MAGIC, 8)) {\n\t\tif (ic->mode != 'R') {\n\t\t\tif (memchr_inv(ic->sb, 0, SB_SECTORS << SECTOR_SHIFT)) {\n\t\t\t\tr = -EINVAL;\n\t\t\t\tti->error = \"The device is not initialized\";\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\n\t\tr = initialize_superblock(ic, journal_sectors, interleave_sectors);\n\t\tif (r) {\n\t\t\tti->error = \"Could not initialize superblock\";\n\t\t\tgoto bad;\n\t\t}\n\t\tif (ic->mode != 'R')\n\t\t\tshould_write_sb = true;\n\t}\n\n\tif (!ic->sb->version || ic->sb->version > SB_VERSION_5) {\n\t\tr = -EINVAL;\n\t\tti->error = \"Unknown version\";\n\t\tgoto bad;\n\t}\n\tif (le16_to_cpu(ic->sb->integrity_tag_size) != ic->tag_size) {\n\t\tr = -EINVAL;\n\t\tti->error = \"Tag size doesn't match the information in superblock\";\n\t\tgoto bad;\n\t}\n\tif (ic->sb->log2_sectors_per_block != __ffs(ic->sectors_per_block)) {\n\t\tr = -EINVAL;\n\t\tti->error = \"Block size doesn't match the information in superblock\";\n\t\tgoto bad;\n\t}\n\tif (!le32_to_cpu(ic->sb->journal_sections)) {\n\t\tr = -EINVAL;\n\t\tti->error = \"Corrupted superblock, journal_sections is 0\";\n\t\tgoto bad;\n\t}\n\t \n\tif (!ic->meta_dev) {\n\t\tif (ic->sb->log2_interleave_sectors < MIN_LOG2_INTERLEAVE_SECTORS ||\n\t\t    ic->sb->log2_interleave_sectors > MAX_LOG2_INTERLEAVE_SECTORS) {\n\t\t\tr = -EINVAL;\n\t\t\tti->error = \"Invalid interleave_sectors in the superblock\";\n\t\t\tgoto bad;\n\t\t}\n\t} else {\n\t\tif (ic->sb->log2_interleave_sectors) {\n\t\t\tr = -EINVAL;\n\t\t\tti->error = \"Invalid interleave_sectors in the superblock\";\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (!!(ic->sb->flags & cpu_to_le32(SB_FLAG_HAVE_JOURNAL_MAC)) != !!ic->journal_mac_alg.alg_string) {\n\t\tr = -EINVAL;\n\t\tti->error = \"Journal mac mismatch\";\n\t\tgoto bad;\n\t}\n\n\tget_provided_data_sectors(ic);\n\tif (!ic->provided_data_sectors) {\n\t\tr = -EINVAL;\n\t\tti->error = \"The device is too small\";\n\t\tgoto bad;\n\t}\n\ntry_smaller_buffer:\n\tr = calculate_device_limits(ic);\n\tif (r) {\n\t\tif (ic->meta_dev) {\n\t\t\tif (ic->log2_buffer_sectors > 3) {\n\t\t\t\tic->log2_buffer_sectors--;\n\t\t\t\tgoto try_smaller_buffer;\n\t\t\t}\n\t\t}\n\t\tti->error = \"The device is too small\";\n\t\tgoto bad;\n\t}\n\n\tif (log2_sectors_per_bitmap_bit < 0)\n\t\tlog2_sectors_per_bitmap_bit = __fls(DEFAULT_SECTORS_PER_BITMAP_BIT);\n\tif (log2_sectors_per_bitmap_bit < ic->sb->log2_sectors_per_block)\n\t\tlog2_sectors_per_bitmap_bit = ic->sb->log2_sectors_per_block;\n\n\tbits_in_journal = ((__u64)ic->journal_section_sectors * ic->journal_sections) << (SECTOR_SHIFT + 3);\n\tif (bits_in_journal > UINT_MAX)\n\t\tbits_in_journal = UINT_MAX;\n\twhile (bits_in_journal < (ic->provided_data_sectors + ((sector_t)1 << log2_sectors_per_bitmap_bit) - 1) >> log2_sectors_per_bitmap_bit)\n\t\tlog2_sectors_per_bitmap_bit++;\n\n\tlog2_blocks_per_bitmap_bit = log2_sectors_per_bitmap_bit - ic->sb->log2_sectors_per_block;\n\tic->log2_blocks_per_bitmap_bit = log2_blocks_per_bitmap_bit;\n\tif (should_write_sb)\n\t\tic->sb->log2_blocks_per_bitmap_bit = log2_blocks_per_bitmap_bit;\n\n\tn_bitmap_bits = ((ic->provided_data_sectors >> ic->sb->log2_sectors_per_block)\n\t\t\t\t+ (((sector_t)1 << log2_blocks_per_bitmap_bit) - 1)) >> log2_blocks_per_bitmap_bit;\n\tic->n_bitmap_blocks = DIV_ROUND_UP(n_bitmap_bits, BITMAP_BLOCK_SIZE * 8);\n\n\tif (!ic->meta_dev)\n\t\tic->log2_buffer_sectors = min(ic->log2_buffer_sectors, (__u8)__ffs(ic->metadata_run));\n\n\tif (ti->len > ic->provided_data_sectors) {\n\t\tr = -EINVAL;\n\t\tti->error = \"Not enough provided sectors for requested mapping size\";\n\t\tgoto bad;\n\t}\n\n\n\tthreshold = (__u64)ic->journal_entries * (100 - journal_watermark);\n\tthreshold += 50;\n\tdo_div(threshold, 100);\n\tic->free_sectors_threshold = threshold;\n\n\tDEBUG_print(\"initialized:\\n\");\n\tDEBUG_print(\"\tintegrity_tag_size %u\\n\", le16_to_cpu(ic->sb->integrity_tag_size));\n\tDEBUG_print(\"\tjournal_entry_size %u\\n\", ic->journal_entry_size);\n\tDEBUG_print(\"\tjournal_entries_per_sector %u\\n\", ic->journal_entries_per_sector);\n\tDEBUG_print(\"\tjournal_section_entries %u\\n\", ic->journal_section_entries);\n\tDEBUG_print(\"\tjournal_section_sectors %u\\n\", ic->journal_section_sectors);\n\tDEBUG_print(\"\tjournal_sections %u\\n\", (unsigned int)le32_to_cpu(ic->sb->journal_sections));\n\tDEBUG_print(\"\tjournal_entries %u\\n\", ic->journal_entries);\n\tDEBUG_print(\"\tlog2_interleave_sectors %d\\n\", ic->sb->log2_interleave_sectors);\n\tDEBUG_print(\"\tdata_device_sectors 0x%llx\\n\", bdev_nr_sectors(ic->dev->bdev));\n\tDEBUG_print(\"\tinitial_sectors 0x%x\\n\", ic->initial_sectors);\n\tDEBUG_print(\"\tmetadata_run 0x%x\\n\", ic->metadata_run);\n\tDEBUG_print(\"\tlog2_metadata_run %d\\n\", ic->log2_metadata_run);\n\tDEBUG_print(\"\tprovided_data_sectors 0x%llx (%llu)\\n\", ic->provided_data_sectors, ic->provided_data_sectors);\n\tDEBUG_print(\"\tlog2_buffer_sectors %u\\n\", ic->log2_buffer_sectors);\n\tDEBUG_print(\"\tbits_in_journal %llu\\n\", bits_in_journal);\n\n\tif (ic->recalculate_flag && !(ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING))) {\n\t\tic->sb->flags |= cpu_to_le32(SB_FLAG_RECALCULATING);\n\t\tic->sb->recalc_sector = cpu_to_le64(0);\n\t}\n\n\tif (ic->internal_hash) {\n\t\tic->recalc_wq = alloc_workqueue(\"dm-integrity-recalc\", WQ_MEM_RECLAIM, 1);\n\t\tif (!ic->recalc_wq) {\n\t\t\tti->error = \"Cannot allocate workqueue\";\n\t\t\tr = -ENOMEM;\n\t\t\tgoto bad;\n\t\t}\n\t\tINIT_WORK(&ic->recalc_work, integrity_recalc);\n\t} else {\n\t\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING)) {\n\t\t\tti->error = \"Recalculate can only be specified with internal_hash\";\n\t\t\tr = -EINVAL;\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\tif (ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING) &&\n\t    le64_to_cpu(ic->sb->recalc_sector) < ic->provided_data_sectors &&\n\t    dm_integrity_disable_recalculate(ic)) {\n\t\tti->error = \"Recalculating with HMAC is disabled for security reasons - if you really need it, use the argument \\\"legacy_recalculate\\\"\";\n\t\tr = -EOPNOTSUPP;\n\t\tgoto bad;\n\t}\n\n\tic->bufio = dm_bufio_client_create(ic->meta_dev ? ic->meta_dev->bdev : ic->dev->bdev,\n\t\t\t1U << (SECTOR_SHIFT + ic->log2_buffer_sectors), 1, 0, NULL, NULL, 0);\n\tif (IS_ERR(ic->bufio)) {\n\t\tr = PTR_ERR(ic->bufio);\n\t\tti->error = \"Cannot initialize dm-bufio\";\n\t\tic->bufio = NULL;\n\t\tgoto bad;\n\t}\n\tdm_bufio_set_sector_offset(ic->bufio, ic->start + ic->initial_sectors);\n\n\tif (ic->mode != 'R') {\n\t\tr = create_journal(ic, &ti->error);\n\t\tif (r)\n\t\t\tgoto bad;\n\n\t}\n\n\tif (ic->mode == 'B') {\n\t\tunsigned int i;\n\t\tunsigned int n_bitmap_pages = DIV_ROUND_UP(ic->n_bitmap_blocks, PAGE_SIZE / BITMAP_BLOCK_SIZE);\n\n\t\tic->recalc_bitmap = dm_integrity_alloc_page_list(n_bitmap_pages);\n\t\tif (!ic->recalc_bitmap) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto bad;\n\t\t}\n\t\tic->may_write_bitmap = dm_integrity_alloc_page_list(n_bitmap_pages);\n\t\tif (!ic->may_write_bitmap) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto bad;\n\t\t}\n\t\tic->bbs = kvmalloc_array(ic->n_bitmap_blocks, sizeof(struct bitmap_block_status), GFP_KERNEL);\n\t\tif (!ic->bbs) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto bad;\n\t\t}\n\t\tINIT_DELAYED_WORK(&ic->bitmap_flush_work, bitmap_flush_work);\n\t\tfor (i = 0; i < ic->n_bitmap_blocks; i++) {\n\t\t\tstruct bitmap_block_status *bbs = &ic->bbs[i];\n\t\t\tunsigned int sector, pl_index, pl_offset;\n\n\t\t\tINIT_WORK(&bbs->work, bitmap_block_work);\n\t\t\tbbs->ic = ic;\n\t\t\tbbs->idx = i;\n\t\t\tbio_list_init(&bbs->bio_queue);\n\t\t\tspin_lock_init(&bbs->bio_queue_lock);\n\n\t\t\tsector = i * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT);\n\t\t\tpl_index = sector >> (PAGE_SHIFT - SECTOR_SHIFT);\n\t\t\tpl_offset = (sector << SECTOR_SHIFT) & (PAGE_SIZE - 1);\n\n\t\t\tbbs->bitmap = lowmem_page_address(ic->journal[pl_index].page) + pl_offset;\n\t\t}\n\t}\n\n\tif (should_write_sb) {\n\t\tinit_journal(ic, 0, ic->journal_sections, 0);\n\t\tr = dm_integrity_failed(ic);\n\t\tif (unlikely(r)) {\n\t\t\tti->error = \"Error initializing journal\";\n\t\t\tgoto bad;\n\t\t}\n\t\tr = sync_rw_sb(ic, REQ_OP_WRITE | REQ_FUA);\n\t\tif (r) {\n\t\t\tti->error = \"Error initializing superblock\";\n\t\t\tgoto bad;\n\t\t}\n\t\tic->just_formatted = true;\n\t}\n\n\tif (!ic->meta_dev) {\n\t\tr = dm_set_target_max_io_len(ti, 1U << ic->sb->log2_interleave_sectors);\n\t\tif (r)\n\t\t\tgoto bad;\n\t}\n\tif (ic->mode == 'B') {\n\t\tunsigned int max_io_len;\n\n\t\tmax_io_len = ((sector_t)ic->sectors_per_block << ic->log2_blocks_per_bitmap_bit) * (BITMAP_BLOCK_SIZE * 8);\n\t\tif (!max_io_len)\n\t\t\tmax_io_len = 1U << 31;\n\t\tDEBUG_print(\"max_io_len: old %u, new %u\\n\", ti->max_io_len, max_io_len);\n\t\tif (!ti->max_io_len || ti->max_io_len > max_io_len) {\n\t\t\tr = dm_set_target_max_io_len(ti, max_io_len);\n\t\t\tif (r)\n\t\t\t\tgoto bad;\n\t\t}\n\t}\n\n\tif (!ic->internal_hash)\n\t\tdm_integrity_set(ti, ic);\n\n\tti->num_flush_bios = 1;\n\tti->flush_supported = true;\n\tif (ic->discard)\n\t\tti->num_discard_bios = 1;\n\n\tdm_audit_log_ctr(DM_MSG_PREFIX, ti, 1);\n\treturn 0;\n\nbad:\n\tdm_audit_log_ctr(DM_MSG_PREFIX, ti, 0);\n\tdm_integrity_dtr(ti);\n\treturn r;\n}\n\nstatic void dm_integrity_dtr(struct dm_target *ti)\n{\n\tstruct dm_integrity_c *ic = ti->private;\n\n\tBUG_ON(!RB_EMPTY_ROOT(&ic->in_progress));\n\tBUG_ON(!list_empty(&ic->wait_list));\n\n\tif (ic->mode == 'B')\n\t\tcancel_delayed_work_sync(&ic->bitmap_flush_work);\n\tif (ic->metadata_wq)\n\t\tdestroy_workqueue(ic->metadata_wq);\n\tif (ic->wait_wq)\n\t\tdestroy_workqueue(ic->wait_wq);\n\tif (ic->offload_wq)\n\t\tdestroy_workqueue(ic->offload_wq);\n\tif (ic->commit_wq)\n\t\tdestroy_workqueue(ic->commit_wq);\n\tif (ic->writer_wq)\n\t\tdestroy_workqueue(ic->writer_wq);\n\tif (ic->recalc_wq)\n\t\tdestroy_workqueue(ic->recalc_wq);\n\tkvfree(ic->bbs);\n\tif (ic->bufio)\n\t\tdm_bufio_client_destroy(ic->bufio);\n\tmempool_exit(&ic->journal_io_mempool);\n\tif (ic->io)\n\t\tdm_io_client_destroy(ic->io);\n\tif (ic->dev)\n\t\tdm_put_device(ti, ic->dev);\n\tif (ic->meta_dev)\n\t\tdm_put_device(ti, ic->meta_dev);\n\tdm_integrity_free_page_list(ic->journal);\n\tdm_integrity_free_page_list(ic->journal_io);\n\tdm_integrity_free_page_list(ic->journal_xor);\n\tdm_integrity_free_page_list(ic->recalc_bitmap);\n\tdm_integrity_free_page_list(ic->may_write_bitmap);\n\tif (ic->journal_scatterlist)\n\t\tdm_integrity_free_journal_scatterlist(ic, ic->journal_scatterlist);\n\tif (ic->journal_io_scatterlist)\n\t\tdm_integrity_free_journal_scatterlist(ic, ic->journal_io_scatterlist);\n\tif (ic->sk_requests) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < ic->journal_sections; i++) {\n\t\t\tstruct skcipher_request *req;\n\n\t\t\treq = ic->sk_requests[i];\n\t\t\tif (req) {\n\t\t\t\tkfree_sensitive(req->iv);\n\t\t\t\tskcipher_request_free(req);\n\t\t\t}\n\t\t}\n\t\tkvfree(ic->sk_requests);\n\t}\n\tkvfree(ic->journal_tree);\n\tif (ic->sb)\n\t\tfree_pages_exact(ic->sb, SB_SECTORS << SECTOR_SHIFT);\n\n\tif (ic->internal_hash)\n\t\tcrypto_free_shash(ic->internal_hash);\n\tfree_alg(&ic->internal_hash_alg);\n\n\tif (ic->journal_crypt)\n\t\tcrypto_free_skcipher(ic->journal_crypt);\n\tfree_alg(&ic->journal_crypt_alg);\n\n\tif (ic->journal_mac)\n\t\tcrypto_free_shash(ic->journal_mac);\n\tfree_alg(&ic->journal_mac_alg);\n\n\tkfree(ic);\n\tdm_audit_log_dtr(DM_MSG_PREFIX, ti, 1);\n}\n\nstatic struct target_type integrity_target = {\n\t.name\t\t\t= \"integrity\",\n\t.version\t\t= {1, 10, 0},\n\t.module\t\t\t= THIS_MODULE,\n\t.features\t\t= DM_TARGET_SINGLETON | DM_TARGET_INTEGRITY,\n\t.ctr\t\t\t= dm_integrity_ctr,\n\t.dtr\t\t\t= dm_integrity_dtr,\n\t.map\t\t\t= dm_integrity_map,\n\t.postsuspend\t\t= dm_integrity_postsuspend,\n\t.resume\t\t\t= dm_integrity_resume,\n\t.status\t\t\t= dm_integrity_status,\n\t.iterate_devices\t= dm_integrity_iterate_devices,\n\t.io_hints\t\t= dm_integrity_io_hints,\n};\n\nstatic int __init dm_integrity_init(void)\n{\n\tint r;\n\n\tjournal_io_cache = kmem_cache_create(\"integrity_journal_io\",\n\t\t\t\t\t     sizeof(struct journal_io), 0, 0, NULL);\n\tif (!journal_io_cache) {\n\t\tDMERR(\"can't allocate journal io cache\");\n\t\treturn -ENOMEM;\n\t}\n\n\tr = dm_register_target(&integrity_target);\n\tif (r < 0) {\n\t\tkmem_cache_destroy(journal_io_cache);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit dm_integrity_exit(void)\n{\n\tdm_unregister_target(&integrity_target);\n\tkmem_cache_destroy(journal_io_cache);\n}\n\nmodule_init(dm_integrity_init);\nmodule_exit(dm_integrity_exit);\n\nMODULE_AUTHOR(\"Milan Broz\");\nMODULE_AUTHOR(\"Mikulas Patocka\");\nMODULE_DESCRIPTION(DM_NAME \" target for integrity tags extension\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}