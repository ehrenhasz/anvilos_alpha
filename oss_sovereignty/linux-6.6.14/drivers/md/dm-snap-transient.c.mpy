{
  "module_name": "dm-snap-transient.c",
  "hash_id": "74d765fb25209325b8bcf5f066e3e1467e77c5261e9866bd9eccd9c69f13e845",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-snap-transient.c",
  "human_readable_source": "\n \n\n#include \"dm-exception-store.h\"\n\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/dm-io.h>\n\n#define DM_MSG_PREFIX \"transient snapshot\"\n\n \nstruct transient_c {\n\tsector_t next_free;\n};\n\nstatic void transient_dtr(struct dm_exception_store *store)\n{\n\tkfree(store->context);\n}\n\nstatic int transient_read_metadata(struct dm_exception_store *store,\n\t\t\t\t   int (*callback)(void *callback_context,\n\t\t\t\t\t\t   chunk_t old, chunk_t new),\n\t\t\t\t   void *callback_context)\n{\n\treturn 0;\n}\n\nstatic int transient_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t       struct dm_exception *e)\n{\n\tstruct transient_c *tc = store->context;\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\n\tif (size < (tc->next_free + store->chunk_size))\n\t\treturn -1;\n\n\te->new_chunk = sector_to_chunk(store, tc->next_free);\n\ttc->next_free += store->chunk_size;\n\n\treturn 0;\n}\n\nstatic void transient_commit_exception(struct dm_exception_store *store,\n\t\t\t\t       struct dm_exception *e, int valid,\n\t\t\t\t       void (*callback)(void *, int success),\n\t\t\t\t       void *callback_context)\n{\n\t \n\tcallback(callback_context, valid);\n}\n\nstatic void transient_usage(struct dm_exception_store *store,\n\t\t\t    sector_t *total_sectors,\n\t\t\t    sector_t *sectors_allocated,\n\t\t\t    sector_t *metadata_sectors)\n{\n\t*sectors_allocated = ((struct transient_c *) store->context)->next_free;\n\t*total_sectors = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\t*metadata_sectors = 0;\n}\n\nstatic int transient_ctr(struct dm_exception_store *store, char *options)\n{\n\tstruct transient_c *tc;\n\n\ttc = kmalloc(sizeof(struct transient_c), GFP_KERNEL);\n\tif (!tc)\n\t\treturn -ENOMEM;\n\n\ttc->next_free = 0;\n\tstore->context = tc;\n\n\treturn 0;\n}\n\nstatic unsigned int transient_status(struct dm_exception_store *store,\n\t\t\t\t status_type_t status, char *result,\n\t\t\t\t unsigned int maxlen)\n{\n\tunsigned int sz = 0;\n\n\tswitch (status) {\n\tcase STATUSTYPE_INFO:\n\t\tbreak;\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\" N %llu\", (unsigned long long)store->chunk_size);\n\t\tbreak;\n\tcase STATUSTYPE_IMA:\n\t\t*result = '\\0';\n\t\tbreak;\n\t}\n\n\treturn sz;\n}\n\nstatic struct dm_exception_store_type _transient_type = {\n\t.name = \"transient\",\n\t.module = THIS_MODULE,\n\t.ctr = transient_ctr,\n\t.dtr = transient_dtr,\n\t.read_metadata = transient_read_metadata,\n\t.prepare_exception = transient_prepare_exception,\n\t.commit_exception = transient_commit_exception,\n\t.usage = transient_usage,\n\t.status = transient_status,\n};\n\nstatic struct dm_exception_store_type _transient_compat_type = {\n\t.name = \"N\",\n\t.module = THIS_MODULE,\n\t.ctr = transient_ctr,\n\t.dtr = transient_dtr,\n\t.read_metadata = transient_read_metadata,\n\t.prepare_exception = transient_prepare_exception,\n\t.commit_exception = transient_commit_exception,\n\t.usage = transient_usage,\n\t.status = transient_status,\n};\n\nint dm_transient_snapshot_init(void)\n{\n\tint r;\n\n\tr = dm_exception_store_type_register(&_transient_type);\n\tif (r) {\n\t\tDMWARN(\"Unable to register transient exception store type\");\n\t\treturn r;\n\t}\n\n\tr = dm_exception_store_type_register(&_transient_compat_type);\n\tif (r) {\n\t\tDMWARN(\"Unable to register old-style transient exception store type\");\n\t\tdm_exception_store_type_unregister(&_transient_type);\n\t\treturn r;\n\t}\n\n\treturn r;\n}\n\nvoid dm_transient_snapshot_exit(void)\n{\n\tdm_exception_store_type_unregister(&_transient_type);\n\tdm_exception_store_type_unregister(&_transient_compat_type);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}