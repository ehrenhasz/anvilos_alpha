{
  "module_name": "dm-cache-policy.c",
  "hash_id": "7f6c152146c4fdb1e3587ef32649941df1050d2e752d225ff5296c12fef75a5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-cache-policy.c",
  "human_readable_source": "\n \n\n#include \"dm-cache-policy-internal.h\"\n#include \"dm.h\"\n\n#include <linux/module.h>\n#include <linux/slab.h>\n\n \n\n#define DM_MSG_PREFIX \"cache-policy\"\n\nstatic DEFINE_SPINLOCK(register_lock);\nstatic LIST_HEAD(register_list);\n\nstatic struct dm_cache_policy_type *__find_policy(const char *name)\n{\n\tstruct dm_cache_policy_type *t;\n\n\tlist_for_each_entry(t, &register_list, list)\n\t\tif (!strcmp(t->name, name))\n\t\t\treturn t;\n\n\treturn NULL;\n}\n\nstatic struct dm_cache_policy_type *__get_policy_once(const char *name)\n{\n\tstruct dm_cache_policy_type *t = __find_policy(name);\n\n\tif (t && !try_module_get(t->owner)) {\n\t\tDMWARN(\"couldn't get module %s\", name);\n\t\tt = ERR_PTR(-EINVAL);\n\t}\n\n\treturn t;\n}\n\nstatic struct dm_cache_policy_type *get_policy_once(const char *name)\n{\n\tstruct dm_cache_policy_type *t;\n\n\tspin_lock(&register_lock);\n\tt = __get_policy_once(name);\n\tspin_unlock(&register_lock);\n\n\treturn t;\n}\n\nstatic struct dm_cache_policy_type *get_policy(const char *name)\n{\n\tstruct dm_cache_policy_type *t;\n\n\tt = get_policy_once(name);\n\tif (IS_ERR(t))\n\t\treturn NULL;\n\n\tif (t)\n\t\treturn t;\n\n\trequest_module(\"dm-cache-%s\", name);\n\n\tt = get_policy_once(name);\n\tif (IS_ERR(t))\n\t\treturn NULL;\n\n\treturn t;\n}\n\nstatic void put_policy(struct dm_cache_policy_type *t)\n{\n\tmodule_put(t->owner);\n}\n\nint dm_cache_policy_register(struct dm_cache_policy_type *type)\n{\n\tint r;\n\n\t \n\tif (type->hint_size != 0 && type->hint_size != 4) {\n\t\tDMWARN(\"hint size must be 0 or 4 but %llu supplied.\", (unsigned long long) type->hint_size);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&register_lock);\n\tif (__find_policy(type->name)) {\n\t\tDMWARN(\"attempt to register policy under duplicate name %s\", type->name);\n\t\tr = -EINVAL;\n\t} else {\n\t\tlist_add(&type->list, &register_list);\n\t\tr = 0;\n\t}\n\tspin_unlock(&register_lock);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_cache_policy_register);\n\nvoid dm_cache_policy_unregister(struct dm_cache_policy_type *type)\n{\n\tspin_lock(&register_lock);\n\tlist_del_init(&type->list);\n\tspin_unlock(&register_lock);\n}\nEXPORT_SYMBOL_GPL(dm_cache_policy_unregister);\n\nstruct dm_cache_policy *dm_cache_policy_create(const char *name,\n\t\t\t\t\t       dm_cblock_t cache_size,\n\t\t\t\t\t       sector_t origin_size,\n\t\t\t\t\t       sector_t cache_block_size)\n{\n\tstruct dm_cache_policy *p = NULL;\n\tstruct dm_cache_policy_type *type;\n\n\ttype = get_policy(name);\n\tif (!type) {\n\t\tDMWARN(\"unknown policy type\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tp = type->create(cache_size, origin_size, cache_block_size);\n\tif (!p) {\n\t\tput_policy(type);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tp->private = type;\n\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(dm_cache_policy_create);\n\nvoid dm_cache_policy_destroy(struct dm_cache_policy *p)\n{\n\tstruct dm_cache_policy_type *t = p->private;\n\n\tp->destroy(p);\n\tput_policy(t);\n}\nEXPORT_SYMBOL_GPL(dm_cache_policy_destroy);\n\nconst char *dm_cache_policy_get_name(struct dm_cache_policy *p)\n{\n\tstruct dm_cache_policy_type *t = p->private;\n\n\t \n\tif (t->real)\n\t\treturn t->real->name;\n\n\treturn t->name;\n}\nEXPORT_SYMBOL_GPL(dm_cache_policy_get_name);\n\nconst unsigned int *dm_cache_policy_get_version(struct dm_cache_policy *p)\n{\n\tstruct dm_cache_policy_type *t = p->private;\n\n\treturn t->version;\n}\nEXPORT_SYMBOL_GPL(dm_cache_policy_get_version);\n\nsize_t dm_cache_policy_get_hint_size(struct dm_cache_policy *p)\n{\n\tstruct dm_cache_policy_type *t = p->private;\n\n\treturn t->hint_size;\n}\nEXPORT_SYMBOL_GPL(dm_cache_policy_get_hint_size);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}