{
  "module_name": "md-linear.c",
  "hash_id": "2e476d21b5f8f60ed745a3b0323a36db2c0dcca93efae7fe5afe5b726bea024a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/md-linear.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/raid/md_u.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <trace/events/block.h>\n#include \"md.h\"\n#include \"md-linear.h\"\n\n \nstatic inline struct dev_info *which_dev(struct mddev *mddev, sector_t sector)\n{\n\tint lo, mid, hi;\n\tstruct linear_conf *conf;\n\n\tlo = 0;\n\thi = mddev->raid_disks - 1;\n\tconf = mddev->private;\n\n\t \n\n\twhile (hi > lo) {\n\n\t\tmid = (hi + lo) / 2;\n\t\tif (sector < conf->disks[mid].end_sector)\n\t\t\thi = mid;\n\t\telse\n\t\t\tlo = mid + 1;\n\t}\n\n\treturn conf->disks + lo;\n}\n\nstatic sector_t linear_size(struct mddev *mddev, sector_t sectors, int raid_disks)\n{\n\tstruct linear_conf *conf;\n\tsector_t array_sectors;\n\n\tconf = mddev->private;\n\tWARN_ONCE(sectors || raid_disks,\n\t\t  \"%s does not support generic reshape\\n\", __func__);\n\tarray_sectors = conf->array_sectors;\n\n\treturn array_sectors;\n}\n\nstatic struct linear_conf *linear_conf(struct mddev *mddev, int raid_disks)\n{\n\tstruct linear_conf *conf;\n\tstruct md_rdev *rdev;\n\tint i, cnt;\n\n\tconf = kzalloc(struct_size(conf, disks, raid_disks), GFP_KERNEL);\n\tif (!conf)\n\t\treturn NULL;\n\n\tcnt = 0;\n\tconf->array_sectors = 0;\n\n\trdev_for_each(rdev, mddev) {\n\t\tint j = rdev->raid_disk;\n\t\tstruct dev_info *disk = conf->disks + j;\n\t\tsector_t sectors;\n\n\t\tif (j < 0 || j >= raid_disks || disk->rdev) {\n\t\t\tpr_warn(\"md/linear:%s: disk numbering problem. Aborting!\\n\",\n\t\t\t\tmdname(mddev));\n\t\t\tgoto out;\n\t\t}\n\n\t\tdisk->rdev = rdev;\n\t\tif (mddev->chunk_sectors) {\n\t\t\tsectors = rdev->sectors;\n\t\t\tsector_div(sectors, mddev->chunk_sectors);\n\t\t\trdev->sectors = sectors * mddev->chunk_sectors;\n\t\t}\n\n\t\tdisk_stack_limits(mddev->gendisk, rdev->bdev,\n\t\t\t\t  rdev->data_offset << 9);\n\n\t\tconf->array_sectors += rdev->sectors;\n\t\tcnt++;\n\t}\n\tif (cnt != raid_disks) {\n\t\tpr_warn(\"md/linear:%s: not enough drives present. Aborting!\\n\",\n\t\t\tmdname(mddev));\n\t\tgoto out;\n\t}\n\n\t \n\tconf->disks[0].end_sector = conf->disks[0].rdev->sectors;\n\n\tfor (i = 1; i < raid_disks; i++)\n\t\tconf->disks[i].end_sector =\n\t\t\tconf->disks[i-1].end_sector +\n\t\t\tconf->disks[i].rdev->sectors;\n\n\t \n\tconf->raid_disks = raid_disks;\n\n\treturn conf;\n\nout:\n\tkfree(conf);\n\treturn NULL;\n}\n\nstatic int linear_run (struct mddev *mddev)\n{\n\tstruct linear_conf *conf;\n\tint ret;\n\n\tif (md_check_no_bitmap(mddev))\n\t\treturn -EINVAL;\n\tconf = linear_conf(mddev, mddev->raid_disks);\n\n\tif (!conf)\n\t\treturn 1;\n\tmddev->private = conf;\n\tmd_set_array_sectors(mddev, linear_size(mddev, 0, 0));\n\n\tret =  md_integrity_register(mddev);\n\tif (ret) {\n\t\tkfree(conf);\n\t\tmddev->private = NULL;\n\t}\n\treturn ret;\n}\n\nstatic int linear_add(struct mddev *mddev, struct md_rdev *rdev)\n{\n\t \n\tstruct linear_conf *newconf, *oldconf;\n\n\tif (rdev->saved_raid_disk != mddev->raid_disks)\n\t\treturn -EINVAL;\n\n\trdev->raid_disk = rdev->saved_raid_disk;\n\trdev->saved_raid_disk = -1;\n\n\tnewconf = linear_conf(mddev,mddev->raid_disks+1);\n\n\tif (!newconf)\n\t\treturn -ENOMEM;\n\n\t \n\tmddev_suspend(mddev);\n\toldconf = rcu_dereference_protected(mddev->private,\n\t\t\tlockdep_is_held(&mddev->reconfig_mutex));\n\tmddev->raid_disks++;\n\tWARN_ONCE(mddev->raid_disks != newconf->raid_disks,\n\t\t\"copied raid_disks doesn't match mddev->raid_disks\");\n\trcu_assign_pointer(mddev->private, newconf);\n\tmd_set_array_sectors(mddev, linear_size(mddev, 0, 0));\n\tset_capacity_and_notify(mddev->gendisk, mddev->array_sectors);\n\tmddev_resume(mddev);\n\tkfree_rcu(oldconf, rcu);\n\treturn 0;\n}\n\nstatic void linear_free(struct mddev *mddev, void *priv)\n{\n\tstruct linear_conf *conf = priv;\n\n\tkfree(conf);\n}\n\nstatic bool linear_make_request(struct mddev *mddev, struct bio *bio)\n{\n\tstruct dev_info *tmp_dev;\n\tsector_t start_sector, end_sector, data_offset;\n\tsector_t bio_sector = bio->bi_iter.bi_sector;\n\n\tif (unlikely(bio->bi_opf & REQ_PREFLUSH)\n\t    && md_flush_request(mddev, bio))\n\t\treturn true;\n\n\ttmp_dev = which_dev(mddev, bio_sector);\n\tstart_sector = tmp_dev->end_sector - tmp_dev->rdev->sectors;\n\tend_sector = tmp_dev->end_sector;\n\tdata_offset = tmp_dev->rdev->data_offset;\n\n\tif (unlikely(bio_sector >= end_sector ||\n\t\t     bio_sector < start_sector))\n\t\tgoto out_of_bounds;\n\n\tif (unlikely(is_rdev_broken(tmp_dev->rdev))) {\n\t\tmd_error(mddev, tmp_dev->rdev);\n\t\tbio_io_error(bio);\n\t\treturn true;\n\t}\n\n\tif (unlikely(bio_end_sector(bio) > end_sector)) {\n\t\t \n\t\tstruct bio *split = bio_split(bio, end_sector - bio_sector,\n\t\t\t\t\t      GFP_NOIO, &mddev->bio_set);\n\t\tbio_chain(split, bio);\n\t\tsubmit_bio_noacct(bio);\n\t\tbio = split;\n\t}\n\n\tmd_account_bio(mddev, &bio);\n\tbio_set_dev(bio, tmp_dev->rdev->bdev);\n\tbio->bi_iter.bi_sector = bio->bi_iter.bi_sector -\n\t\tstart_sector + data_offset;\n\n\tif (unlikely((bio_op(bio) == REQ_OP_DISCARD) &&\n\t\t     !bdev_max_discard_sectors(bio->bi_bdev))) {\n\t\t \n\t\tbio_endio(bio);\n\t} else {\n\t\tif (mddev->gendisk)\n\t\t\ttrace_block_bio_remap(bio, disk_devt(mddev->gendisk),\n\t\t\t\t\t      bio_sector);\n\t\tmddev_check_write_zeroes(mddev, bio);\n\t\tsubmit_bio_noacct(bio);\n\t}\n\treturn true;\n\nout_of_bounds:\n\tpr_err(\"md/linear:%s: make_request: Sector %llu out of bounds on dev %pg: %llu sectors, offset %llu\\n\",\n\t       mdname(mddev),\n\t       (unsigned long long)bio->bi_iter.bi_sector,\n\t       tmp_dev->rdev->bdev,\n\t       (unsigned long long)tmp_dev->rdev->sectors,\n\t       (unsigned long long)start_sector);\n\tbio_io_error(bio);\n\treturn true;\n}\n\nstatic void linear_status (struct seq_file *seq, struct mddev *mddev)\n{\n\tseq_printf(seq, \" %dk rounding\", mddev->chunk_sectors / 2);\n}\n\nstatic void linear_error(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tif (!test_and_set_bit(MD_BROKEN, &mddev->flags)) {\n\t\tchar *md_name = mdname(mddev);\n\n\t\tpr_crit(\"md/linear%s: Disk failure on %pg detected, failing array.\\n\",\n\t\t\tmd_name, rdev->bdev);\n\t}\n}\n\nstatic void linear_quiesce(struct mddev *mddev, int state)\n{\n}\n\nstatic struct md_personality linear_personality =\n{\n\t.name\t\t= \"linear\",\n\t.level\t\t= LEVEL_LINEAR,\n\t.owner\t\t= THIS_MODULE,\n\t.make_request\t= linear_make_request,\n\t.run\t\t= linear_run,\n\t.free\t\t= linear_free,\n\t.status\t\t= linear_status,\n\t.hot_add_disk\t= linear_add,\n\t.size\t\t= linear_size,\n\t.quiesce\t= linear_quiesce,\n\t.error_handler\t= linear_error,\n};\n\nstatic int __init linear_init (void)\n{\n\treturn register_md_personality (&linear_personality);\n}\n\nstatic void linear_exit (void)\n{\n\tunregister_md_personality (&linear_personality);\n}\n\nmodule_init(linear_init);\nmodule_exit(linear_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Linear device concatenation personality for MD (deprecated)\");\nMODULE_ALIAS(\"md-personality-1\");  \nMODULE_ALIAS(\"md-linear\");\nMODULE_ALIAS(\"md-level--1\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}