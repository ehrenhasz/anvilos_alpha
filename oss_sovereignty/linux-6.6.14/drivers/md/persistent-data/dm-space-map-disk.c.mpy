{
  "module_name": "dm-space-map-disk.c",
  "hash_id": "3dd8692737b8d1edd88290d0c23f55ba57fe38a05ecb33768f27ff6dea319102",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/persistent-data/dm-space-map-disk.c",
  "human_readable_source": "\n \n\n#include \"dm-space-map-common.h\"\n#include \"dm-space-map-disk.h\"\n#include \"dm-space-map.h\"\n#include \"dm-transaction-manager.h\"\n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/device-mapper.h>\n\n#define DM_MSG_PREFIX \"space map disk\"\n\n \n\n \nstruct sm_disk {\n\tstruct dm_space_map sm;\n\n\tstruct ll_disk ll;\n\tstruct ll_disk old_ll;\n\n\tdm_block_t begin;\n\tdm_block_t nr_allocated_this_transaction;\n};\n\nstatic void sm_disk_destroy(struct dm_space_map *sm)\n{\n\tstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\n\n\tkfree(smd);\n}\n\nstatic int sm_disk_extend(struct dm_space_map *sm, dm_block_t extra_blocks)\n{\n\tstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\n\n\treturn sm_ll_extend(&smd->ll, extra_blocks);\n}\n\nstatic int sm_disk_get_nr_blocks(struct dm_space_map *sm, dm_block_t *count)\n{\n\tstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\n\n\t*count = smd->old_ll.nr_blocks;\n\n\treturn 0;\n}\n\nstatic int sm_disk_get_nr_free(struct dm_space_map *sm, dm_block_t *count)\n{\n\tstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\n\n\t*count = (smd->old_ll.nr_blocks - smd->old_ll.nr_allocated) - smd->nr_allocated_this_transaction;\n\n\treturn 0;\n}\n\nstatic int sm_disk_get_count(struct dm_space_map *sm, dm_block_t b,\n\t\t\t     uint32_t *result)\n{\n\tstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\n\n\treturn sm_ll_lookup(&smd->ll, b, result);\n}\n\nstatic int sm_disk_count_is_more_than_one(struct dm_space_map *sm, dm_block_t b,\n\t\t\t\t\t  int *result)\n{\n\tint r;\n\tuint32_t count;\n\n\tr = sm_disk_get_count(sm, b, &count);\n\tif (r)\n\t\treturn r;\n\n\t*result = count > 1;\n\n\treturn 0;\n}\n\nstatic int sm_disk_set_count(struct dm_space_map *sm, dm_block_t b,\n\t\t\t     uint32_t count)\n{\n\tint r;\n\tint32_t nr_allocations;\n\tstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\n\n\tr = sm_ll_insert(&smd->ll, b, count, &nr_allocations);\n\tif (!r)\n\t\tsmd->nr_allocated_this_transaction += nr_allocations;\n\n\treturn r;\n}\n\nstatic int sm_disk_inc_blocks(struct dm_space_map *sm, dm_block_t b, dm_block_t e)\n{\n\tint r;\n\tint32_t nr_allocations;\n\tstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\n\n\tr = sm_ll_inc(&smd->ll, b, e, &nr_allocations);\n\tif (!r)\n\t\tsmd->nr_allocated_this_transaction += nr_allocations;\n\n\treturn r;\n}\n\nstatic int sm_disk_dec_blocks(struct dm_space_map *sm, dm_block_t b, dm_block_t e)\n{\n\tint r;\n\tint32_t nr_allocations;\n\tstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\n\n\tr = sm_ll_dec(&smd->ll, b, e, &nr_allocations);\n\tif (!r)\n\t\tsmd->nr_allocated_this_transaction += nr_allocations;\n\n\treturn r;\n}\n\nstatic int sm_disk_new_block(struct dm_space_map *sm, dm_block_t *b)\n{\n\tint r;\n\tint32_t nr_allocations;\n\tstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\n\n\t \n\tr = sm_ll_find_common_free_block(&smd->old_ll, &smd->ll, smd->begin, smd->ll.nr_blocks, b);\n\tif (r == -ENOSPC)\n\t\t \n\t\tr = sm_ll_find_common_free_block(&smd->old_ll, &smd->ll, 0, smd->begin, b);\n\n\tif (r)\n\t\treturn r;\n\n\tsmd->begin = *b + 1;\n\tr = sm_ll_inc(&smd->ll, *b, *b + 1, &nr_allocations);\n\tif (!r)\n\t\tsmd->nr_allocated_this_transaction += nr_allocations;\n\n\treturn r;\n}\n\nstatic int sm_disk_commit(struct dm_space_map *sm)\n{\n\tint r;\n\tstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\n\n\tr = sm_ll_commit(&smd->ll);\n\tif (r)\n\t\treturn r;\n\n\tmemcpy(&smd->old_ll, &smd->ll, sizeof(smd->old_ll));\n\tsmd->nr_allocated_this_transaction = 0;\n\n\treturn 0;\n}\n\nstatic int sm_disk_root_size(struct dm_space_map *sm, size_t *result)\n{\n\t*result = sizeof(struct disk_sm_root);\n\n\treturn 0;\n}\n\nstatic int sm_disk_copy_root(struct dm_space_map *sm, void *where_le, size_t max)\n{\n\tstruct sm_disk *smd = container_of(sm, struct sm_disk, sm);\n\tstruct disk_sm_root root_le;\n\n\troot_le.nr_blocks = cpu_to_le64(smd->ll.nr_blocks);\n\troot_le.nr_allocated = cpu_to_le64(smd->ll.nr_allocated);\n\troot_le.bitmap_root = cpu_to_le64(smd->ll.bitmap_root);\n\troot_le.ref_count_root = cpu_to_le64(smd->ll.ref_count_root);\n\n\tif (max < sizeof(root_le))\n\t\treturn -ENOSPC;\n\n\tmemcpy(where_le, &root_le, sizeof(root_le));\n\n\treturn 0;\n}\n\n \n\nstatic struct dm_space_map ops = {\n\t.destroy = sm_disk_destroy,\n\t.extend = sm_disk_extend,\n\t.get_nr_blocks = sm_disk_get_nr_blocks,\n\t.get_nr_free = sm_disk_get_nr_free,\n\t.get_count = sm_disk_get_count,\n\t.count_is_more_than_one = sm_disk_count_is_more_than_one,\n\t.set_count = sm_disk_set_count,\n\t.inc_blocks = sm_disk_inc_blocks,\n\t.dec_blocks = sm_disk_dec_blocks,\n\t.new_block = sm_disk_new_block,\n\t.commit = sm_disk_commit,\n\t.root_size = sm_disk_root_size,\n\t.copy_root = sm_disk_copy_root,\n\t.register_threshold_callback = NULL\n};\n\nstruct dm_space_map *dm_sm_disk_create(struct dm_transaction_manager *tm,\n\t\t\t\t       dm_block_t nr_blocks)\n{\n\tint r;\n\tstruct sm_disk *smd;\n\n\tsmd = kmalloc(sizeof(*smd), GFP_KERNEL);\n\tif (!smd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsmd->begin = 0;\n\tsmd->nr_allocated_this_transaction = 0;\n\tmemcpy(&smd->sm, &ops, sizeof(smd->sm));\n\n\tr = sm_ll_new_disk(&smd->ll, tm);\n\tif (r)\n\t\tgoto bad;\n\n\tr = sm_ll_extend(&smd->ll, nr_blocks);\n\tif (r)\n\t\tgoto bad;\n\n\tr = sm_disk_commit(&smd->sm);\n\tif (r)\n\t\tgoto bad;\n\n\treturn &smd->sm;\n\nbad:\n\tkfree(smd);\n\treturn ERR_PTR(r);\n}\nEXPORT_SYMBOL_GPL(dm_sm_disk_create);\n\nstruct dm_space_map *dm_sm_disk_open(struct dm_transaction_manager *tm,\n\t\t\t\t     void *root_le, size_t len)\n{\n\tint r;\n\tstruct sm_disk *smd;\n\n\tsmd = kmalloc(sizeof(*smd), GFP_KERNEL);\n\tif (!smd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsmd->begin = 0;\n\tsmd->nr_allocated_this_transaction = 0;\n\tmemcpy(&smd->sm, &ops, sizeof(smd->sm));\n\n\tr = sm_ll_open_disk(&smd->ll, tm, root_le, len);\n\tif (r)\n\t\tgoto bad;\n\n\tr = sm_disk_commit(&smd->sm);\n\tif (r)\n\t\tgoto bad;\n\n\treturn &smd->sm;\n\nbad:\n\tkfree(smd);\n\treturn ERR_PTR(r);\n}\nEXPORT_SYMBOL_GPL(dm_sm_disk_open);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}