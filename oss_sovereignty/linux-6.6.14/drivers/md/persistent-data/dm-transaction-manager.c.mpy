{
  "module_name": "dm-transaction-manager.c",
  "hash_id": "7b14c03647a58e868d14ff45dae2972d9723ec063efbb272be13aa600ca0365c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/persistent-data/dm-transaction-manager.c",
  "human_readable_source": "\n \n#include \"dm-transaction-manager.h\"\n#include \"dm-space-map.h\"\n#include \"dm-space-map-disk.h\"\n#include \"dm-space-map-metadata.h\"\n#include \"dm-persistent-data-internal.h\"\n\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/device-mapper.h>\n\n#define DM_MSG_PREFIX \"transaction manager\"\n\n \n\n#define PREFETCH_SIZE 128\n#define PREFETCH_BITS 7\n#define PREFETCH_SENTINEL ((dm_block_t) -1ULL)\n\nstruct prefetch_set {\n\tstruct mutex lock;\n\tdm_block_t blocks[PREFETCH_SIZE];\n};\n\nstatic unsigned int prefetch_hash(dm_block_t b)\n{\n\treturn hash_64(b, PREFETCH_BITS);\n}\n\nstatic void prefetch_wipe(struct prefetch_set *p)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < PREFETCH_SIZE; i++)\n\t\tp->blocks[i] = PREFETCH_SENTINEL;\n}\n\nstatic void prefetch_init(struct prefetch_set *p)\n{\n\tmutex_init(&p->lock);\n\tprefetch_wipe(p);\n}\n\nstatic void prefetch_add(struct prefetch_set *p, dm_block_t b)\n{\n\tunsigned int h = prefetch_hash(b);\n\n\tmutex_lock(&p->lock);\n\tif (p->blocks[h] == PREFETCH_SENTINEL)\n\t\tp->blocks[h] = b;\n\n\tmutex_unlock(&p->lock);\n}\n\nstatic void prefetch_issue(struct prefetch_set *p, struct dm_block_manager *bm)\n{\n\tunsigned int i;\n\n\tmutex_lock(&p->lock);\n\n\tfor (i = 0; i < PREFETCH_SIZE; i++)\n\t\tif (p->blocks[i] != PREFETCH_SENTINEL) {\n\t\t\tdm_bm_prefetch(bm, p->blocks[i]);\n\t\t\tp->blocks[i] = PREFETCH_SENTINEL;\n\t\t}\n\n\tmutex_unlock(&p->lock);\n}\n\n \n\nstruct shadow_info {\n\tstruct hlist_node hlist;\n\tdm_block_t where;\n};\n\n \n#define DM_HASH_SIZE 256\n#define DM_HASH_MASK (DM_HASH_SIZE - 1)\n\nstruct dm_transaction_manager {\n\tint is_clone;\n\tstruct dm_transaction_manager *real;\n\n\tstruct dm_block_manager *bm;\n\tstruct dm_space_map *sm;\n\n\tspinlock_t lock;\n\tstruct hlist_head buckets[DM_HASH_SIZE];\n\n\tstruct prefetch_set prefetches;\n};\n\n \n\nstatic int is_shadow(struct dm_transaction_manager *tm, dm_block_t b)\n{\n\tint r = 0;\n\tunsigned int bucket = dm_hash_block(b, DM_HASH_MASK);\n\tstruct shadow_info *si;\n\n\tspin_lock(&tm->lock);\n\thlist_for_each_entry(si, tm->buckets + bucket, hlist)\n\t\tif (si->where == b) {\n\t\t\tr = 1;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&tm->lock);\n\n\treturn r;\n}\n\n \nstatic void insert_shadow(struct dm_transaction_manager *tm, dm_block_t b)\n{\n\tunsigned int bucket;\n\tstruct shadow_info *si;\n\n\tsi = kmalloc(sizeof(*si), GFP_NOIO);\n\tif (si) {\n\t\tsi->where = b;\n\t\tbucket = dm_hash_block(b, DM_HASH_MASK);\n\t\tspin_lock(&tm->lock);\n\t\thlist_add_head(&si->hlist, tm->buckets + bucket);\n\t\tspin_unlock(&tm->lock);\n\t}\n}\n\nstatic void wipe_shadow_table(struct dm_transaction_manager *tm)\n{\n\tstruct shadow_info *si;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head *bucket;\n\tint i;\n\n\tspin_lock(&tm->lock);\n\tfor (i = 0; i < DM_HASH_SIZE; i++) {\n\t\tbucket = tm->buckets + i;\n\t\thlist_for_each_entry_safe(si, tmp, bucket, hlist)\n\t\t\tkfree(si);\n\n\t\tINIT_HLIST_HEAD(bucket);\n\t}\n\n\tspin_unlock(&tm->lock);\n}\n\n \n\nstatic struct dm_transaction_manager *dm_tm_create(struct dm_block_manager *bm,\n\t\t\t\t\t\t   struct dm_space_map *sm)\n{\n\tint i;\n\tstruct dm_transaction_manager *tm;\n\n\ttm = kmalloc(sizeof(*tm), GFP_KERNEL);\n\tif (!tm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttm->is_clone = 0;\n\ttm->real = NULL;\n\ttm->bm = bm;\n\ttm->sm = sm;\n\n\tspin_lock_init(&tm->lock);\n\tfor (i = 0; i < DM_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(tm->buckets + i);\n\n\tprefetch_init(&tm->prefetches);\n\n\treturn tm;\n}\n\nstruct dm_transaction_manager *dm_tm_create_non_blocking_clone(struct dm_transaction_manager *real)\n{\n\tstruct dm_transaction_manager *tm;\n\n\ttm = kmalloc(sizeof(*tm), GFP_KERNEL);\n\tif (tm) {\n\t\ttm->is_clone = 1;\n\t\ttm->real = real;\n\t}\n\n\treturn tm;\n}\nEXPORT_SYMBOL_GPL(dm_tm_create_non_blocking_clone);\n\nvoid dm_tm_destroy(struct dm_transaction_manager *tm)\n{\n\tif (!tm)\n\t\treturn;\n\n\tif (!tm->is_clone)\n\t\twipe_shadow_table(tm);\n\n\tkfree(tm);\n}\nEXPORT_SYMBOL_GPL(dm_tm_destroy);\n\nint dm_tm_pre_commit(struct dm_transaction_manager *tm)\n{\n\tint r;\n\n\tif (tm->is_clone)\n\t\treturn -EWOULDBLOCK;\n\n\tr = dm_sm_commit(tm->sm);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn dm_bm_flush(tm->bm);\n}\nEXPORT_SYMBOL_GPL(dm_tm_pre_commit);\n\nint dm_tm_commit(struct dm_transaction_manager *tm, struct dm_block *root)\n{\n\tif (tm->is_clone)\n\t\treturn -EWOULDBLOCK;\n\n\twipe_shadow_table(tm);\n\tdm_bm_unlock(root);\n\n\treturn dm_bm_flush(tm->bm);\n}\nEXPORT_SYMBOL_GPL(dm_tm_commit);\n\nint dm_tm_new_block(struct dm_transaction_manager *tm,\n\t\t    struct dm_block_validator *v,\n\t\t    struct dm_block **result)\n{\n\tint r;\n\tdm_block_t new_block;\n\n\tif (tm->is_clone)\n\t\treturn -EWOULDBLOCK;\n\n\tr = dm_sm_new_block(tm->sm, &new_block);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_bm_write_lock_zero(tm->bm, new_block, v, result);\n\tif (r < 0) {\n\t\tdm_sm_dec_block(tm->sm, new_block);\n\t\treturn r;\n\t}\n\n\t \n\tinsert_shadow(tm, new_block);\n\n\treturn 0;\n}\n\nstatic int __shadow_block(struct dm_transaction_manager *tm, dm_block_t orig,\n\t\t\t  struct dm_block_validator *v,\n\t\t\t  struct dm_block **result)\n{\n\tint r;\n\tdm_block_t new;\n\tstruct dm_block *orig_block;\n\n\tr = dm_sm_new_block(tm->sm, &new);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_sm_dec_block(tm->sm, orig);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_bm_read_lock(tm->bm, orig, v, &orig_block);\n\tif (r < 0)\n\t\treturn r;\n\n\t \n\tr = dm_bm_write_lock_zero(tm->bm, new, v, result);\n\tif (r) {\n\t\tdm_bm_unlock(orig_block);\n\t\treturn r;\n\t}\n\n\tmemcpy(dm_block_data(*result), dm_block_data(orig_block),\n\t       dm_bm_block_size(tm->bm));\n\n\tdm_bm_unlock(orig_block);\n\treturn r;\n}\n\nint dm_tm_shadow_block(struct dm_transaction_manager *tm, dm_block_t orig,\n\t\t       struct dm_block_validator *v, struct dm_block **result,\n\t\t       int *inc_children)\n{\n\tint r;\n\n\tif (tm->is_clone)\n\t\treturn -EWOULDBLOCK;\n\n\tr = dm_sm_count_is_more_than_one(tm->sm, orig, inc_children);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (is_shadow(tm, orig) && !*inc_children)\n\t\treturn dm_bm_write_lock(tm->bm, orig, v, result);\n\n\tr = __shadow_block(tm, orig, v, result);\n\tif (r < 0)\n\t\treturn r;\n\tinsert_shadow(tm, dm_block_location(*result));\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_tm_shadow_block);\n\nint dm_tm_read_lock(struct dm_transaction_manager *tm, dm_block_t b,\n\t\t    struct dm_block_validator *v,\n\t\t    struct dm_block **blk)\n{\n\tif (tm->is_clone) {\n\t\tint r = dm_bm_read_try_lock(tm->real->bm, b, v, blk);\n\n\t\tif (r == -EWOULDBLOCK)\n\t\t\tprefetch_add(&tm->real->prefetches, b);\n\n\t\treturn r;\n\t}\n\n\treturn dm_bm_read_lock(tm->bm, b, v, blk);\n}\nEXPORT_SYMBOL_GPL(dm_tm_read_lock);\n\nvoid dm_tm_unlock(struct dm_transaction_manager *tm, struct dm_block *b)\n{\n\tdm_bm_unlock(b);\n}\nEXPORT_SYMBOL_GPL(dm_tm_unlock);\n\nvoid dm_tm_inc(struct dm_transaction_manager *tm, dm_block_t b)\n{\n\t \n\tBUG_ON(tm->is_clone);\n\n\tdm_sm_inc_block(tm->sm, b);\n}\nEXPORT_SYMBOL_GPL(dm_tm_inc);\n\nvoid dm_tm_inc_range(struct dm_transaction_manager *tm, dm_block_t b, dm_block_t e)\n{\n\t \n\tBUG_ON(tm->is_clone);\n\n\tdm_sm_inc_blocks(tm->sm, b, e);\n}\nEXPORT_SYMBOL_GPL(dm_tm_inc_range);\n\nvoid dm_tm_dec(struct dm_transaction_manager *tm, dm_block_t b)\n{\n\t \n\tBUG_ON(tm->is_clone);\n\n\tdm_sm_dec_block(tm->sm, b);\n}\nEXPORT_SYMBOL_GPL(dm_tm_dec);\n\nvoid dm_tm_dec_range(struct dm_transaction_manager *tm, dm_block_t b, dm_block_t e)\n{\n\t \n\tBUG_ON(tm->is_clone);\n\n\tdm_sm_dec_blocks(tm->sm, b, e);\n}\nEXPORT_SYMBOL_GPL(dm_tm_dec_range);\n\nvoid dm_tm_with_runs(struct dm_transaction_manager *tm,\n\t\t     const __le64 *value_le, unsigned int count, dm_tm_run_fn fn)\n{\n\tuint64_t b, begin, end;\n\tbool in_run = false;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++, value_le++) {\n\t\tb = le64_to_cpu(*value_le);\n\n\t\tif (in_run) {\n\t\t\tif (b == end)\n\t\t\t\tend++;\n\t\t\telse {\n\t\t\t\tfn(tm, begin, end);\n\t\t\t\tbegin = b;\n\t\t\t\tend = b + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tin_run = true;\n\t\t\tbegin = b;\n\t\t\tend = b + 1;\n\t\t}\n\t}\n\n\tif (in_run)\n\t\tfn(tm, begin, end);\n}\nEXPORT_SYMBOL_GPL(dm_tm_with_runs);\n\nint dm_tm_ref(struct dm_transaction_manager *tm, dm_block_t b,\n\t      uint32_t *result)\n{\n\tif (tm->is_clone)\n\t\treturn -EWOULDBLOCK;\n\n\treturn dm_sm_get_count(tm->sm, b, result);\n}\n\nint dm_tm_block_is_shared(struct dm_transaction_manager *tm, dm_block_t b,\n\t\t\t  int *result)\n{\n\tif (tm->is_clone)\n\t\treturn -EWOULDBLOCK;\n\n\treturn dm_sm_count_is_more_than_one(tm->sm, b, result);\n}\n\nstruct dm_block_manager *dm_tm_get_bm(struct dm_transaction_manager *tm)\n{\n\treturn tm->bm;\n}\n\nvoid dm_tm_issue_prefetches(struct dm_transaction_manager *tm)\n{\n\tprefetch_issue(&tm->prefetches, tm->bm);\n}\nEXPORT_SYMBOL_GPL(dm_tm_issue_prefetches);\n\n \n\nstatic int dm_tm_create_internal(struct dm_block_manager *bm,\n\t\t\t\t dm_block_t sb_location,\n\t\t\t\t struct dm_transaction_manager **tm,\n\t\t\t\t struct dm_space_map **sm,\n\t\t\t\t int create,\n\t\t\t\t void *sm_root, size_t sm_len)\n{\n\tint r;\n\n\t*sm = dm_sm_metadata_init();\n\tif (IS_ERR(*sm))\n\t\treturn PTR_ERR(*sm);\n\n\t*tm = dm_tm_create(bm, *sm);\n\tif (IS_ERR(*tm)) {\n\t\tdm_sm_destroy(*sm);\n\t\treturn PTR_ERR(*tm);\n\t}\n\n\tif (create) {\n\t\tr = dm_sm_metadata_create(*sm, *tm, dm_bm_nr_blocks(bm),\n\t\t\t\t\t  sb_location);\n\t\tif (r) {\n\t\t\tDMERR(\"couldn't create metadata space map\");\n\t\t\tgoto bad;\n\t\t}\n\n\t} else {\n\t\tr = dm_sm_metadata_open(*sm, *tm, sm_root, sm_len);\n\t\tif (r) {\n\t\t\tDMERR(\"couldn't open metadata space map\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treturn 0;\n\nbad:\n\tdm_tm_destroy(*tm);\n\tdm_sm_destroy(*sm);\n\treturn r;\n}\n\nint dm_tm_create_with_sm(struct dm_block_manager *bm, dm_block_t sb_location,\n\t\t\t struct dm_transaction_manager **tm,\n\t\t\t struct dm_space_map **sm)\n{\n\treturn dm_tm_create_internal(bm, sb_location, tm, sm, 1, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(dm_tm_create_with_sm);\n\nint dm_tm_open_with_sm(struct dm_block_manager *bm, dm_block_t sb_location,\n\t\t       void *sm_root, size_t root_len,\n\t\t       struct dm_transaction_manager **tm,\n\t\t       struct dm_space_map **sm)\n{\n\treturn dm_tm_create_internal(bm, sb_location, tm, sm, 0, sm_root, root_len);\n}\nEXPORT_SYMBOL_GPL(dm_tm_open_with_sm);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}