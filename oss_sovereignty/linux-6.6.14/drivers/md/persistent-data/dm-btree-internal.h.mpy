{
  "module_name": "dm-btree-internal.h",
  "hash_id": "216f763c46100cb3ee7128fa9d17433067e8d30c0e0f9ac6726be59fa1bcd1bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/persistent-data/dm-btree-internal.h",
  "human_readable_source": " \n \n\n#ifndef DM_BTREE_INTERNAL_H\n#define DM_BTREE_INTERNAL_H\n\n#include \"dm-btree.h\"\n\n \n\n \n\nenum node_flags {\n\tINTERNAL_NODE = 1,\n\tLEAF_NODE = 1 << 1\n};\n\n \nstruct node_header {\n\t__le32 csum;\n\t__le32 flags;\n\t__le64 blocknr;  \n\n\t__le32 nr_entries;\n\t__le32 max_entries;\n\t__le32 value_size;\n\t__le32 padding;\n} __packed __aligned(8);\n\nstruct btree_node {\n\tstruct node_header header;\n\t__le64 keys[];\n} __packed __aligned(8);\n\n\n \nint bn_read_lock(struct dm_btree_info *info, dm_block_t b,\n\t\t struct dm_block **result);\n\nvoid inc_children(struct dm_transaction_manager *tm, struct btree_node *n,\n\t\t  struct dm_btree_value_type *vt);\n\nint new_block(struct dm_btree_info *info, struct dm_block **result);\nvoid unlock_block(struct dm_btree_info *info, struct dm_block *b);\n\n \nstruct ro_spine {\n\tstruct dm_btree_info *info;\n\n\tint count;\n\tstruct dm_block *nodes[2];\n};\n\nvoid init_ro_spine(struct ro_spine *s, struct dm_btree_info *info);\nvoid exit_ro_spine(struct ro_spine *s);\nint ro_step(struct ro_spine *s, dm_block_t new_child);\nvoid ro_pop(struct ro_spine *s);\nstruct btree_node *ro_node(struct ro_spine *s);\n\nstruct shadow_spine {\n\tstruct dm_btree_info *info;\n\n\tint count;\n\tstruct dm_block *nodes[2];\n\n\tdm_block_t root;\n};\n\nvoid init_shadow_spine(struct shadow_spine *s, struct dm_btree_info *info);\nvoid exit_shadow_spine(struct shadow_spine *s);\n\nint shadow_step(struct shadow_spine *s, dm_block_t b,\n\t\tstruct dm_btree_value_type *vt);\n\n \nstruct dm_block *shadow_current(struct shadow_spine *s);\n\n \nstruct dm_block *shadow_parent(struct shadow_spine *s);\n\nint shadow_has_parent(struct shadow_spine *s);\n\ndm_block_t shadow_root(struct shadow_spine *s);\n\n \nstatic inline __le64 *key_ptr(struct btree_node *n, uint32_t index)\n{\n\treturn n->keys + index;\n}\n\nstatic inline void *value_base(struct btree_node *n)\n{\n\treturn &n->keys[le32_to_cpu(n->header.max_entries)];\n}\n\nstatic inline void *value_ptr(struct btree_node *n, uint32_t index)\n{\n\tuint32_t value_size = le32_to_cpu(n->header.value_size);\n\n\treturn value_base(n) + (value_size * index);\n}\n\n \nstatic inline uint64_t value64(struct btree_node *n, uint32_t index)\n{\n\t__le64 *values_le = value_base(n);\n\n\treturn le64_to_cpu(values_le[index]);\n}\n\n \nint lower_bound(struct btree_node *n, uint64_t key);\n\nextern struct dm_block_validator btree_node_validator;\n\n \nextern void init_le64_type(struct dm_transaction_manager *tm,\n\t\t\t   struct dm_btree_value_type *vt);\n\n \nint btree_get_overwrite_leaf(struct dm_btree_info *info, dm_block_t root,\n\t\t\t     uint64_t key, int *index,\n\t\t\t     dm_block_t *new_root, struct dm_block **leaf);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}