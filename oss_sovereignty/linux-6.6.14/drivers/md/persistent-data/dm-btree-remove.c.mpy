{
  "module_name": "dm-btree-remove.c",
  "hash_id": "a45ec0ac6e61acb1bdf24b6257b051783798dc5dadb2215f11580dd1fdb8ee37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/persistent-data/dm-btree-remove.c",
  "human_readable_source": "\n \n\n#include \"dm-btree.h\"\n#include \"dm-btree-internal.h\"\n#include \"dm-transaction-manager.h\"\n\n#include <linux/export.h>\n#include <linux/device-mapper.h>\n\n#define DM_MSG_PREFIX \"btree\"\n\n \n\n \nstatic void node_shift(struct btree_node *n, int shift)\n{\n\tuint32_t nr_entries = le32_to_cpu(n->header.nr_entries);\n\tuint32_t value_size = le32_to_cpu(n->header.value_size);\n\n\tif (shift < 0) {\n\t\tshift = -shift;\n\t\tBUG_ON(shift > nr_entries);\n\t\tBUG_ON((void *) key_ptr(n, shift) >= value_ptr(n, shift));\n\t\tmemmove(key_ptr(n, 0),\n\t\t\tkey_ptr(n, shift),\n\t\t\t(nr_entries - shift) * sizeof(__le64));\n\t\tmemmove(value_ptr(n, 0),\n\t\t\tvalue_ptr(n, shift),\n\t\t\t(nr_entries - shift) * value_size);\n\t} else {\n\t\tBUG_ON(nr_entries + shift > le32_to_cpu(n->header.max_entries));\n\t\tmemmove(key_ptr(n, shift),\n\t\t\tkey_ptr(n, 0),\n\t\t\tnr_entries * sizeof(__le64));\n\t\tmemmove(value_ptr(n, shift),\n\t\t\tvalue_ptr(n, 0),\n\t\t\tnr_entries * value_size);\n\t}\n}\n\nstatic int node_copy(struct btree_node *left, struct btree_node *right, int shift)\n{\n\tuint32_t nr_left = le32_to_cpu(left->header.nr_entries);\n\tuint32_t value_size = le32_to_cpu(left->header.value_size);\n\n\tif (value_size != le32_to_cpu(right->header.value_size)) {\n\t\tDMERR(\"mismatched value size\");\n\t\treturn -EILSEQ;\n\t}\n\n\tif (shift < 0) {\n\t\tshift = -shift;\n\n\t\tif (nr_left + shift > le32_to_cpu(left->header.max_entries)) {\n\t\t\tDMERR(\"bad shift\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(key_ptr(left, nr_left),\n\t\t       key_ptr(right, 0),\n\t\t       shift * sizeof(__le64));\n\t\tmemcpy(value_ptr(left, nr_left),\n\t\t       value_ptr(right, 0),\n\t\t       shift * value_size);\n\t} else {\n\t\tif (shift > le32_to_cpu(right->header.max_entries)) {\n\t\t\tDMERR(\"bad shift\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(key_ptr(right, 0),\n\t\t       key_ptr(left, nr_left - shift),\n\t\t       shift * sizeof(__le64));\n\t\tmemcpy(value_ptr(right, 0),\n\t\t       value_ptr(left, nr_left - shift),\n\t\t       shift * value_size);\n\t}\n\treturn 0;\n}\n\n \nstatic void delete_at(struct btree_node *n, unsigned int index)\n{\n\tunsigned int nr_entries = le32_to_cpu(n->header.nr_entries);\n\tunsigned int nr_to_copy = nr_entries - (index + 1);\n\tuint32_t value_size = le32_to_cpu(n->header.value_size);\n\n\tBUG_ON(index >= nr_entries);\n\n\tif (nr_to_copy) {\n\t\tmemmove(key_ptr(n, index),\n\t\t\tkey_ptr(n, index + 1),\n\t\t\tnr_to_copy * sizeof(__le64));\n\n\t\tmemmove(value_ptr(n, index),\n\t\t\tvalue_ptr(n, index + 1),\n\t\t\tnr_to_copy * value_size);\n\t}\n\n\tn->header.nr_entries = cpu_to_le32(nr_entries - 1);\n}\n\nstatic unsigned int merge_threshold(struct btree_node *n)\n{\n\treturn le32_to_cpu(n->header.max_entries) / 3;\n}\n\nstruct child {\n\tunsigned int index;\n\tstruct dm_block *block;\n\tstruct btree_node *n;\n};\n\nstatic int init_child(struct dm_btree_info *info, struct dm_btree_value_type *vt,\n\t\t      struct btree_node *parent,\n\t\t      unsigned int index, struct child *result)\n{\n\tint r, inc;\n\tdm_block_t root;\n\n\tresult->index = index;\n\troot = value64(parent, index);\n\n\tr = dm_tm_shadow_block(info->tm, root, &btree_node_validator,\n\t\t\t       &result->block, &inc);\n\tif (r)\n\t\treturn r;\n\n\tresult->n = dm_block_data(result->block);\n\n\tif (inc)\n\t\tinc_children(info->tm, result->n, vt);\n\n\t*((__le64 *) value_ptr(parent, index)) =\n\t\tcpu_to_le64(dm_block_location(result->block));\n\n\treturn 0;\n}\n\nstatic void exit_child(struct dm_btree_info *info, struct child *c)\n{\n\tdm_tm_unlock(info->tm, c->block);\n}\n\nstatic int shift(struct btree_node *left, struct btree_node *right, int count)\n{\n\tint r;\n\tuint32_t nr_left = le32_to_cpu(left->header.nr_entries);\n\tuint32_t nr_right = le32_to_cpu(right->header.nr_entries);\n\tuint32_t max_entries = le32_to_cpu(left->header.max_entries);\n\tuint32_t r_max_entries = le32_to_cpu(right->header.max_entries);\n\n\tif (max_entries != r_max_entries) {\n\t\tDMERR(\"node max_entries mismatch\");\n\t\treturn -EILSEQ;\n\t}\n\n\tif (nr_left - count > max_entries) {\n\t\tDMERR(\"node shift out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nr_right + count > max_entries) {\n\t\tDMERR(\"node shift out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (count > 0) {\n\t\tnode_shift(right, count);\n\t\tr = node_copy(left, right, count);\n\t\tif (r)\n\t\t\treturn r;\n\t} else {\n\t\tr = node_copy(left, right, count);\n\t\tif (r)\n\t\t\treturn r;\n\t\tnode_shift(right, count);\n\t}\n\n\tleft->header.nr_entries = cpu_to_le32(nr_left - count);\n\tright->header.nr_entries = cpu_to_le32(nr_right + count);\n\n\treturn 0;\n}\n\nstatic int __rebalance2(struct dm_btree_info *info, struct btree_node *parent,\n\t\t\tstruct child *l, struct child *r)\n{\n\tint ret;\n\tstruct btree_node *left = l->n;\n\tstruct btree_node *right = r->n;\n\tuint32_t nr_left = le32_to_cpu(left->header.nr_entries);\n\tuint32_t nr_right = le32_to_cpu(right->header.nr_entries);\n\t \n\tunsigned int threshold = 2 * (merge_threshold(left) + 1);\n\n\tif (nr_left + nr_right < threshold) {\n\t\t \n\t\tnode_copy(left, right, -nr_right);\n\t\tleft->header.nr_entries = cpu_to_le32(nr_left + nr_right);\n\t\tdelete_at(parent, r->index);\n\n\t\t \n\t\tdm_tm_dec(info->tm, dm_block_location(r->block));\n\t} else {\n\t\t \n\t\tunsigned int target_left = (nr_left + nr_right) / 2;\n\n\t\tret = shift(left, right, nr_left - target_left);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*key_ptr(parent, r->index) = right->keys[0];\n\t}\n\treturn 0;\n}\n\nstatic int rebalance2(struct shadow_spine *s, struct dm_btree_info *info,\n\t\t      struct dm_btree_value_type *vt, unsigned int left_index)\n{\n\tint r;\n\tstruct btree_node *parent;\n\tstruct child left, right;\n\n\tparent = dm_block_data(shadow_current(s));\n\n\tr = init_child(info, vt, parent, left_index, &left);\n\tif (r)\n\t\treturn r;\n\n\tr = init_child(info, vt, parent, left_index + 1, &right);\n\tif (r) {\n\t\texit_child(info, &left);\n\t\treturn r;\n\t}\n\n\tr = __rebalance2(info, parent, &left, &right);\n\n\texit_child(info, &left);\n\texit_child(info, &right);\n\n\treturn r;\n}\n\n \nstatic int delete_center_node(struct dm_btree_info *info, struct btree_node *parent,\n\t\t\t      struct child *l, struct child *c, struct child *r,\n\t\t\t      struct btree_node *left, struct btree_node *center, struct btree_node *right,\n\t\t\t      uint32_t nr_left, uint32_t nr_center, uint32_t nr_right)\n{\n\tuint32_t max_entries = le32_to_cpu(left->header.max_entries);\n\tunsigned int shift = min(max_entries - nr_left, nr_center);\n\n\tif (nr_left + shift > max_entries) {\n\t\tDMERR(\"node shift out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tnode_copy(left, center, -shift);\n\tleft->header.nr_entries = cpu_to_le32(nr_left + shift);\n\n\tif (shift != nr_center) {\n\t\tshift = nr_center - shift;\n\n\t\tif ((nr_right + shift) > max_entries) {\n\t\t\tDMERR(\"node shift out of bounds\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnode_shift(right, shift);\n\t\tnode_copy(center, right, shift);\n\t\tright->header.nr_entries = cpu_to_le32(nr_right + shift);\n\t}\n\t*key_ptr(parent, r->index) = right->keys[0];\n\n\tdelete_at(parent, c->index);\n\tr->index--;\n\n\tdm_tm_dec(info->tm, dm_block_location(c->block));\n\treturn __rebalance2(info, parent, l, r);\n}\n\n \nstatic int redistribute3(struct dm_btree_info *info, struct btree_node *parent,\n\t\t\t struct child *l, struct child *c, struct child *r,\n\t\t\t struct btree_node *left, struct btree_node *center, struct btree_node *right,\n\t\t\t uint32_t nr_left, uint32_t nr_center, uint32_t nr_right)\n{\n\tint s, ret;\n\tuint32_t max_entries = le32_to_cpu(left->header.max_entries);\n\tunsigned int total = nr_left + nr_center + nr_right;\n\tunsigned int target_right = total / 3;\n\tunsigned int remainder = (target_right * 3) != total;\n\tunsigned int target_left = target_right + remainder;\n\n\tBUG_ON(target_left > max_entries);\n\tBUG_ON(target_right > max_entries);\n\n\tif (nr_left < nr_right) {\n\t\ts = nr_left - target_left;\n\n\t\tif (s < 0 && nr_center < -s) {\n\t\t\t \n\t\t\tret = shift(left, center, -nr_center);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\ts += nr_center;\n\t\t\tret = shift(left, right, s);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tnr_right += s;\n\t\t} else {\n\t\t\tret = shift(left, center, s);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = shift(center, right, target_right - nr_right);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts = target_right - nr_right;\n\t\tif (s > 0 && nr_center < s) {\n\t\t\t \n\t\t\tret = shift(center, right, nr_center);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\ts -= nr_center;\n\t\t\tret = shift(left, right, s);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tnr_left -= s;\n\t\t} else {\n\t\t\tret = shift(center, right, s);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = shift(left, center, nr_left - target_left);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*key_ptr(parent, c->index) = center->keys[0];\n\t*key_ptr(parent, r->index) = right->keys[0];\n\treturn 0;\n}\n\nstatic int __rebalance3(struct dm_btree_info *info, struct btree_node *parent,\n\t\t\tstruct child *l, struct child *c, struct child *r)\n{\n\tstruct btree_node *left = l->n;\n\tstruct btree_node *center = c->n;\n\tstruct btree_node *right = r->n;\n\n\tuint32_t nr_left = le32_to_cpu(left->header.nr_entries);\n\tuint32_t nr_center = le32_to_cpu(center->header.nr_entries);\n\tuint32_t nr_right = le32_to_cpu(right->header.nr_entries);\n\n\tunsigned int threshold = merge_threshold(left) * 4 + 1;\n\n\tif ((left->header.max_entries != center->header.max_entries) ||\n\t    (center->header.max_entries != right->header.max_entries)) {\n\t\tDMERR(\"bad btree metadata, max_entries differ\");\n\t\treturn -EILSEQ;\n\t}\n\n\tif ((nr_left + nr_center + nr_right) < threshold) {\n\t\treturn delete_center_node(info, parent, l, c, r, left, center, right,\n\t\t\t\t\t  nr_left, nr_center, nr_right);\n\t}\n\n\treturn redistribute3(info, parent, l, c, r, left, center, right,\n\t\t\t     nr_left, nr_center, nr_right);\n}\n\nstatic int rebalance3(struct shadow_spine *s, struct dm_btree_info *info,\n\t\t      struct dm_btree_value_type *vt, unsigned int left_index)\n{\n\tint r;\n\tstruct btree_node *parent = dm_block_data(shadow_current(s));\n\tstruct child left, center, right;\n\n\t \n\tr = init_child(info, vt, parent, left_index, &left);\n\tif (r)\n\t\treturn r;\n\n\tr = init_child(info, vt, parent, left_index + 1, &center);\n\tif (r) {\n\t\texit_child(info, &left);\n\t\treturn r;\n\t}\n\n\tr = init_child(info, vt, parent, left_index + 2, &right);\n\tif (r) {\n\t\texit_child(info, &left);\n\t\texit_child(info, &center);\n\t\treturn r;\n\t}\n\n\tr = __rebalance3(info, parent, &left, &center, &right);\n\n\texit_child(info, &left);\n\texit_child(info, &center);\n\texit_child(info, &right);\n\n\treturn r;\n}\n\nstatic int rebalance_children(struct shadow_spine *s,\n\t\t\t      struct dm_btree_info *info,\n\t\t\t      struct dm_btree_value_type *vt, uint64_t key)\n{\n\tint i, r, has_left_sibling, has_right_sibling;\n\tstruct btree_node *n;\n\n\tn = dm_block_data(shadow_current(s));\n\n\tif (le32_to_cpu(n->header.nr_entries) == 1) {\n\t\tstruct dm_block *child;\n\t\tdm_block_t b = value64(n, 0);\n\n\t\tr = dm_tm_read_lock(info->tm, b, &btree_node_validator, &child);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tmemcpy(n, dm_block_data(child),\n\t\t       dm_bm_block_size(dm_tm_get_bm(info->tm)));\n\n\t\tdm_tm_dec(info->tm, dm_block_location(child));\n\t\tdm_tm_unlock(info->tm, child);\n\t\treturn 0;\n\t}\n\n\ti = lower_bound(n, key);\n\tif (i < 0)\n\t\treturn -ENODATA;\n\n\thas_left_sibling = i > 0;\n\thas_right_sibling = i < (le32_to_cpu(n->header.nr_entries) - 1);\n\n\tif (!has_left_sibling)\n\t\tr = rebalance2(s, info, vt, i);\n\n\telse if (!has_right_sibling)\n\t\tr = rebalance2(s, info, vt, i - 1);\n\n\telse\n\t\tr = rebalance3(s, info, vt, i - 1);\n\n\treturn r;\n}\n\nstatic int do_leaf(struct btree_node *n, uint64_t key, unsigned int *index)\n{\n\tint i = lower_bound(n, key);\n\n\tif ((i < 0) ||\n\t    (i >= le32_to_cpu(n->header.nr_entries)) ||\n\t    (le64_to_cpu(n->keys[i]) != key))\n\t\treturn -ENODATA;\n\n\t*index = i;\n\n\treturn 0;\n}\n\n \nstatic int remove_raw(struct shadow_spine *s, struct dm_btree_info *info,\n\t\t      struct dm_btree_value_type *vt, dm_block_t root,\n\t\t      uint64_t key, unsigned int *index)\n{\n\tint i = *index, r;\n\tstruct btree_node *n;\n\n\tfor (;;) {\n\t\tr = shadow_step(s, root, vt);\n\t\tif (r < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (shadow_has_parent(s)) {\n\t\t\t__le64 location = cpu_to_le64(dm_block_location(shadow_current(s)));\n\n\t\t\tmemcpy(value_ptr(dm_block_data(shadow_parent(s)), i),\n\t\t\t       &location, sizeof(__le64));\n\t\t}\n\n\t\tn = dm_block_data(shadow_current(s));\n\n\t\tif (le32_to_cpu(n->header.flags) & LEAF_NODE)\n\t\t\treturn do_leaf(n, key, index);\n\n\t\tr = rebalance_children(s, info, vt, key);\n\t\tif (r)\n\t\t\tbreak;\n\n\t\tn = dm_block_data(shadow_current(s));\n\t\tif (le32_to_cpu(n->header.flags) & LEAF_NODE)\n\t\t\treturn do_leaf(n, key, index);\n\n\t\ti = lower_bound(n, key);\n\n\t\t \n\t\troot = value64(n, i);\n\t}\n\n\treturn r;\n}\n\nint dm_btree_remove(struct dm_btree_info *info, dm_block_t root,\n\t\t    uint64_t *keys, dm_block_t *new_root)\n{\n\tunsigned int level, last_level = info->levels - 1;\n\tint index = 0, r = 0;\n\tstruct shadow_spine spine;\n\tstruct btree_node *n;\n\tstruct dm_btree_value_type le64_vt;\n\n\tinit_le64_type(info->tm, &le64_vt);\n\tinit_shadow_spine(&spine, info);\n\tfor (level = 0; level < info->levels; level++) {\n\t\tr = remove_raw(&spine, info,\n\t\t\t       (level == last_level ?\n\t\t\t\t&info->value_type : &le64_vt),\n\t\t\t       root, keys[level], (unsigned int *)&index);\n\t\tif (r < 0)\n\t\t\tbreak;\n\n\t\tn = dm_block_data(shadow_current(&spine));\n\t\tif (level != last_level) {\n\t\t\troot = value64(n, index);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(index < 0 || index >= le32_to_cpu(n->header.nr_entries));\n\n\t\tif (info->value_type.dec)\n\t\t\tinfo->value_type.dec(info->value_type.context,\n\t\t\t\t\t     value_ptr(n, index), 1);\n\n\t\tdelete_at(n, index);\n\t}\n\n\tif (!r)\n\t\t*new_root = shadow_root(&spine);\n\texit_shadow_spine(&spine);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_btree_remove);\n\n \n\nstatic int remove_nearest(struct shadow_spine *s, struct dm_btree_info *info,\n\t\t\t  struct dm_btree_value_type *vt, dm_block_t root,\n\t\t\t  uint64_t key, int *index)\n{\n\tint i = *index, r;\n\tstruct btree_node *n;\n\n\tfor (;;) {\n\t\tr = shadow_step(s, root, vt);\n\t\tif (r < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (shadow_has_parent(s)) {\n\t\t\t__le64 location = cpu_to_le64(dm_block_location(shadow_current(s)));\n\n\t\t\tmemcpy(value_ptr(dm_block_data(shadow_parent(s)), i),\n\t\t\t       &location, sizeof(__le64));\n\t\t}\n\n\t\tn = dm_block_data(shadow_current(s));\n\n\t\tif (le32_to_cpu(n->header.flags) & LEAF_NODE) {\n\t\t\t*index = lower_bound(n, key);\n\t\t\treturn 0;\n\t\t}\n\n\t\tr = rebalance_children(s, info, vt, key);\n\t\tif (r)\n\t\t\tbreak;\n\n\t\tn = dm_block_data(shadow_current(s));\n\t\tif (le32_to_cpu(n->header.flags) & LEAF_NODE) {\n\t\t\t*index = lower_bound(n, key);\n\t\t\treturn 0;\n\t\t}\n\n\t\ti = lower_bound(n, key);\n\n\t\t \n\t\troot = value64(n, i);\n\t}\n\n\treturn r;\n}\n\nstatic int remove_one(struct dm_btree_info *info, dm_block_t root,\n\t\t      uint64_t *keys, uint64_t end_key,\n\t\t      dm_block_t *new_root, unsigned int *nr_removed)\n{\n\tunsigned int level, last_level = info->levels - 1;\n\tint index = 0, r = 0;\n\tstruct shadow_spine spine;\n\tstruct btree_node *n;\n\tstruct dm_btree_value_type le64_vt;\n\tuint64_t k;\n\n\tinit_le64_type(info->tm, &le64_vt);\n\tinit_shadow_spine(&spine, info);\n\tfor (level = 0; level < last_level; level++) {\n\t\tr = remove_raw(&spine, info, &le64_vt,\n\t\t\t       root, keys[level], (unsigned int *) &index);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\n\t\tn = dm_block_data(shadow_current(&spine));\n\t\troot = value64(n, index);\n\t}\n\n\tr = remove_nearest(&spine, info, &info->value_type,\n\t\t\t   root, keys[last_level], &index);\n\tif (r < 0)\n\t\tgoto out;\n\n\tn = dm_block_data(shadow_current(&spine));\n\n\tif (index < 0)\n\t\tindex = 0;\n\n\tif (index >= le32_to_cpu(n->header.nr_entries)) {\n\t\tr = -ENODATA;\n\t\tgoto out;\n\t}\n\n\tk = le64_to_cpu(n->keys[index]);\n\tif (k >= keys[last_level] && k < end_key) {\n\t\tif (info->value_type.dec)\n\t\t\tinfo->value_type.dec(info->value_type.context,\n\t\t\t\t\t     value_ptr(n, index), 1);\n\n\t\tdelete_at(n, index);\n\t\tkeys[last_level] = k + 1ull;\n\n\t} else\n\t\tr = -ENODATA;\n\nout:\n\t*new_root = shadow_root(&spine);\n\texit_shadow_spine(&spine);\n\n\treturn r;\n}\n\nint dm_btree_remove_leaves(struct dm_btree_info *info, dm_block_t root,\n\t\t\t   uint64_t *first_key, uint64_t end_key,\n\t\t\t   dm_block_t *new_root, unsigned int *nr_removed)\n{\n\tint r;\n\n\t*nr_removed = 0;\n\tdo {\n\t\tr = remove_one(info, root, first_key, end_key, &root, nr_removed);\n\t\tif (!r)\n\t\t\t(*nr_removed)++;\n\t} while (!r);\n\n\t*new_root = root;\n\treturn r == -ENODATA ? 0 : r;\n}\nEXPORT_SYMBOL_GPL(dm_btree_remove_leaves);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}