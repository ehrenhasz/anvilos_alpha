{
  "module_name": "dm-space-map-common.c",
  "hash_id": "152bd9da6049626a618ea441f2f7181e5268e05afe27b9efef9e0a6b1d6ef618",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/persistent-data/dm-space-map-common.c",
  "human_readable_source": "\n \n\n#include \"dm-space-map-common.h\"\n#include \"dm-transaction-manager.h\"\n#include \"dm-btree-internal.h\"\n#include \"dm-persistent-data-internal.h\"\n\n#include <linux/bitops.h>\n#include <linux/device-mapper.h>\n\n#define DM_MSG_PREFIX \"space map common\"\n\n \n\n \n#define INDEX_CSUM_XOR 160478\n\nstatic void index_prepare_for_write(struct dm_block_validator *v,\n\t\t\t\t    struct dm_block *b,\n\t\t\t\t    size_t block_size)\n{\n\tstruct disk_metadata_index *mi_le = dm_block_data(b);\n\n\tmi_le->blocknr = cpu_to_le64(dm_block_location(b));\n\tmi_le->csum = cpu_to_le32(dm_bm_checksum(&mi_le->padding,\n\t\t\t\t\t\t block_size - sizeof(__le32),\n\t\t\t\t\t\t INDEX_CSUM_XOR));\n}\n\nstatic int index_check(struct dm_block_validator *v,\n\t\t       struct dm_block *b,\n\t\t       size_t block_size)\n{\n\tstruct disk_metadata_index *mi_le = dm_block_data(b);\n\t__le32 csum_disk;\n\n\tif (dm_block_location(b) != le64_to_cpu(mi_le->blocknr)) {\n\t\tDMERR_LIMIT(\"%s failed: blocknr %llu != wanted %llu\", __func__,\n\t\t\t    le64_to_cpu(mi_le->blocknr), dm_block_location(b));\n\t\treturn -ENOTBLK;\n\t}\n\n\tcsum_disk = cpu_to_le32(dm_bm_checksum(&mi_le->padding,\n\t\t\t\t\t       block_size - sizeof(__le32),\n\t\t\t\t\t       INDEX_CSUM_XOR));\n\tif (csum_disk != mi_le->csum) {\n\t\tDMERR_LIMIT(\"i%s failed: csum %u != wanted %u\", __func__,\n\t\t\t    le32_to_cpu(csum_disk), le32_to_cpu(mi_le->csum));\n\t\treturn -EILSEQ;\n\t}\n\n\treturn 0;\n}\n\nstatic struct dm_block_validator index_validator = {\n\t.name = \"index\",\n\t.prepare_for_write = index_prepare_for_write,\n\t.check = index_check\n};\n\n \n\n \n#define BITMAP_CSUM_XOR 240779\n\nstatic void dm_bitmap_prepare_for_write(struct dm_block_validator *v,\n\t\t\t\t\tstruct dm_block *b,\n\t\t\t\t\tsize_t block_size)\n{\n\tstruct disk_bitmap_header *disk_header = dm_block_data(b);\n\n\tdisk_header->blocknr = cpu_to_le64(dm_block_location(b));\n\tdisk_header->csum = cpu_to_le32(dm_bm_checksum(&disk_header->not_used,\n\t\t\t\t\t\t       block_size - sizeof(__le32),\n\t\t\t\t\t\t       BITMAP_CSUM_XOR));\n}\n\nstatic int dm_bitmap_check(struct dm_block_validator *v,\n\t\t\t   struct dm_block *b,\n\t\t\t   size_t block_size)\n{\n\tstruct disk_bitmap_header *disk_header = dm_block_data(b);\n\t__le32 csum_disk;\n\n\tif (dm_block_location(b) != le64_to_cpu(disk_header->blocknr)) {\n\t\tDMERR_LIMIT(\"bitmap check failed: blocknr %llu != wanted %llu\",\n\t\t\t    le64_to_cpu(disk_header->blocknr), dm_block_location(b));\n\t\treturn -ENOTBLK;\n\t}\n\n\tcsum_disk = cpu_to_le32(dm_bm_checksum(&disk_header->not_used,\n\t\t\t\t\t       block_size - sizeof(__le32),\n\t\t\t\t\t       BITMAP_CSUM_XOR));\n\tif (csum_disk != disk_header->csum) {\n\t\tDMERR_LIMIT(\"bitmap check failed: csum %u != wanted %u\",\n\t\t\t    le32_to_cpu(csum_disk), le32_to_cpu(disk_header->csum));\n\t\treturn -EILSEQ;\n\t}\n\n\treturn 0;\n}\n\nstatic struct dm_block_validator dm_sm_bitmap_validator = {\n\t.name = \"sm_bitmap\",\n\t.prepare_for_write = dm_bitmap_prepare_for_write,\n\t.check = dm_bitmap_check,\n};\n\n \n\n#define ENTRIES_PER_WORD 32\n#define ENTRIES_SHIFT\t5\n\nstatic void *dm_bitmap_data(struct dm_block *b)\n{\n\treturn dm_block_data(b) + sizeof(struct disk_bitmap_header);\n}\n\n#define WORD_MASK_HIGH 0xAAAAAAAAAAAAAAAAULL\n\nstatic unsigned int dm_bitmap_word_used(void *addr, unsigned int b)\n{\n\t__le64 *words_le = addr;\n\t__le64 *w_le = words_le + (b >> ENTRIES_SHIFT);\n\n\tuint64_t bits = le64_to_cpu(*w_le);\n\tuint64_t mask = (bits + WORD_MASK_HIGH + 1) & WORD_MASK_HIGH;\n\n\treturn !(~bits & mask);\n}\n\nstatic unsigned int sm_lookup_bitmap(void *addr, unsigned int b)\n{\n\t__le64 *words_le = addr;\n\t__le64 *w_le = words_le + (b >> ENTRIES_SHIFT);\n\tunsigned int hi, lo;\n\n\tb = (b & (ENTRIES_PER_WORD - 1)) << 1;\n\thi = !!test_bit_le(b, (void *) w_le);\n\tlo = !!test_bit_le(b + 1, (void *) w_le);\n\treturn (hi << 1) | lo;\n}\n\nstatic void sm_set_bitmap(void *addr, unsigned int b, unsigned int val)\n{\n\t__le64 *words_le = addr;\n\t__le64 *w_le = words_le + (b >> ENTRIES_SHIFT);\n\n\tb = (b & (ENTRIES_PER_WORD - 1)) << 1;\n\n\tif (val & 2)\n\t\t__set_bit_le(b, (void *) w_le);\n\telse\n\t\t__clear_bit_le(b, (void *) w_le);\n\n\tif (val & 1)\n\t\t__set_bit_le(b + 1, (void *) w_le);\n\telse\n\t\t__clear_bit_le(b + 1, (void *) w_le);\n}\n\nstatic int sm_find_free(void *addr, unsigned int begin, unsigned int end,\n\t\t\tunsigned int *result)\n{\n\twhile (begin < end) {\n\t\tif (!(begin & (ENTRIES_PER_WORD - 1)) &&\n\t\t    dm_bitmap_word_used(addr, begin)) {\n\t\t\tbegin += ENTRIES_PER_WORD;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sm_lookup_bitmap(addr, begin)) {\n\t\t\t*result = begin;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbegin++;\n\t}\n\n\treturn -ENOSPC;\n}\n\n \n\nstatic int sm_ll_init(struct ll_disk *ll, struct dm_transaction_manager *tm)\n{\n\tmemset(ll, 0, sizeof(struct ll_disk));\n\n\tll->tm = tm;\n\n\tll->bitmap_info.tm = tm;\n\tll->bitmap_info.levels = 1;\n\n\t \n\tll->bitmap_info.value_type.size = sizeof(struct disk_index_entry);\n\tll->bitmap_info.value_type.inc = NULL;\n\tll->bitmap_info.value_type.dec = NULL;\n\tll->bitmap_info.value_type.equal = NULL;\n\n\tll->ref_count_info.tm = tm;\n\tll->ref_count_info.levels = 1;\n\tll->ref_count_info.value_type.size = sizeof(uint32_t);\n\tll->ref_count_info.value_type.inc = NULL;\n\tll->ref_count_info.value_type.dec = NULL;\n\tll->ref_count_info.value_type.equal = NULL;\n\n\tll->block_size = dm_bm_block_size(dm_tm_get_bm(tm));\n\n\tif (ll->block_size > (1 << 30)) {\n\t\tDMERR(\"block size too big to hold bitmaps\");\n\t\treturn -EINVAL;\n\t}\n\n\tll->entries_per_block = (ll->block_size - sizeof(struct disk_bitmap_header)) *\n\t\tENTRIES_PER_BYTE;\n\tll->nr_blocks = 0;\n\tll->bitmap_root = 0;\n\tll->ref_count_root = 0;\n\tll->bitmap_index_changed = false;\n\n\treturn 0;\n}\n\nint sm_ll_extend(struct ll_disk *ll, dm_block_t extra_blocks)\n{\n\tint r;\n\tdm_block_t i, nr_blocks, nr_indexes;\n\tunsigned int old_blocks, blocks;\n\n\tnr_blocks = ll->nr_blocks + extra_blocks;\n\told_blocks = dm_sector_div_up(ll->nr_blocks, ll->entries_per_block);\n\tblocks = dm_sector_div_up(nr_blocks, ll->entries_per_block);\n\n\tnr_indexes = dm_sector_div_up(nr_blocks, ll->entries_per_block);\n\tif (nr_indexes > ll->max_entries(ll)) {\n\t\tDMERR(\"space map too large\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tll->nr_blocks = nr_blocks;\n\tfor (i = old_blocks; i < blocks; i++) {\n\t\tstruct dm_block *b;\n\t\tstruct disk_index_entry idx;\n\n\t\tr = dm_tm_new_block(ll->tm, &dm_sm_bitmap_validator, &b);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tidx.blocknr = cpu_to_le64(dm_block_location(b));\n\n\t\tdm_tm_unlock(ll->tm, b);\n\n\t\tidx.nr_free = cpu_to_le32(ll->entries_per_block);\n\t\tidx.none_free_before = 0;\n\n\t\tr = ll->save_ie(ll, i, &idx);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nint sm_ll_lookup_bitmap(struct ll_disk *ll, dm_block_t b, uint32_t *result)\n{\n\tint r;\n\tdm_block_t index = b;\n\tstruct disk_index_entry ie_disk;\n\tstruct dm_block *blk;\n\n\tif (b >= ll->nr_blocks) {\n\t\tDMERR_LIMIT(\"metadata block out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tb = do_div(index, ll->entries_per_block);\n\tr = ll->load_ie(ll, index, &ie_disk);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_tm_read_lock(ll->tm, le64_to_cpu(ie_disk.blocknr),\n\t\t\t    &dm_sm_bitmap_validator, &blk);\n\tif (r < 0)\n\t\treturn r;\n\n\t*result = sm_lookup_bitmap(dm_bitmap_data(blk), b);\n\n\tdm_tm_unlock(ll->tm, blk);\n\n\treturn 0;\n}\n\nstatic int sm_ll_lookup_big_ref_count(struct ll_disk *ll, dm_block_t b,\n\t\t\t\t      uint32_t *result)\n{\n\t__le32 le_rc;\n\tint r;\n\n\tr = dm_btree_lookup(&ll->ref_count_info, ll->ref_count_root, &b, &le_rc);\n\tif (r < 0)\n\t\treturn r;\n\n\t*result = le32_to_cpu(le_rc);\n\n\treturn r;\n}\n\nint sm_ll_lookup(struct ll_disk *ll, dm_block_t b, uint32_t *result)\n{\n\tint r = sm_ll_lookup_bitmap(ll, b, result);\n\n\tif (r)\n\t\treturn r;\n\n\tif (*result != 3)\n\t\treturn r;\n\n\treturn sm_ll_lookup_big_ref_count(ll, b, result);\n}\n\nint sm_ll_find_free_block(struct ll_disk *ll, dm_block_t begin,\n\t\t\t  dm_block_t end, dm_block_t *result)\n{\n\tint r;\n\tstruct disk_index_entry ie_disk;\n\tdm_block_t i, index_begin = begin;\n\tdm_block_t index_end = dm_sector_div_up(end, ll->entries_per_block);\n\n\t \n\tbegin = do_div(index_begin, ll->entries_per_block);\n\tend = do_div(end, ll->entries_per_block);\n\tif (end == 0)\n\t\tend = ll->entries_per_block;\n\n\tfor (i = index_begin; i < index_end; i++, begin = 0) {\n\t\tstruct dm_block *blk;\n\t\tunsigned int position;\n\t\tuint32_t bit_end;\n\n\t\tr = ll->load_ie(ll, i, &ie_disk);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tif (le32_to_cpu(ie_disk.nr_free) == 0)\n\t\t\tcontinue;\n\n\t\tr = dm_tm_read_lock(ll->tm, le64_to_cpu(ie_disk.blocknr),\n\t\t\t\t    &dm_sm_bitmap_validator, &blk);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tbit_end = (i == index_end - 1) ?  end : ll->entries_per_block;\n\n\t\tr = sm_find_free(dm_bitmap_data(blk),\n\t\t\t\t max_t(unsigned int, begin, le32_to_cpu(ie_disk.none_free_before)),\n\t\t\t\t bit_end, &position);\n\t\tif (r == -ENOSPC) {\n\t\t\t \n\t\t\tdm_tm_unlock(ll->tm, blk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdm_tm_unlock(ll->tm, blk);\n\n\t\t*result = i * ll->entries_per_block + (dm_block_t) position;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}\n\nint sm_ll_find_common_free_block(struct ll_disk *old_ll, struct ll_disk *new_ll,\n\t\t\t\t dm_block_t begin, dm_block_t end, dm_block_t *b)\n{\n\tint r;\n\tuint32_t count;\n\n\tdo {\n\t\tr = sm_ll_find_free_block(new_ll, begin, new_ll->nr_blocks, b);\n\t\tif (r)\n\t\t\tbreak;\n\n\t\t \n\t\tif (*b >= old_ll->nr_blocks)\n\t\t\tcount = 0;\n\t\telse {\n\t\t\tr = sm_ll_lookup(old_ll, *b, &count);\n\t\t\tif (r)\n\t\t\t\tbreak;\n\n\t\t\tif (count)\n\t\t\t\tbegin = *b + 1;\n\t\t}\n\t} while (count);\n\n\treturn r;\n}\n\n \n\nint sm_ll_insert(struct ll_disk *ll, dm_block_t b,\n\t\t uint32_t ref_count, int32_t *nr_allocations)\n{\n\tint r;\n\tuint32_t bit, old;\n\tstruct dm_block *nb;\n\tdm_block_t index = b;\n\tstruct disk_index_entry ie_disk;\n\tvoid *bm_le;\n\tint inc;\n\n\tbit = do_div(index, ll->entries_per_block);\n\tr = ll->load_ie(ll, index, &ie_disk);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_tm_shadow_block(ll->tm, le64_to_cpu(ie_disk.blocknr),\n\t\t\t       &dm_sm_bitmap_validator, &nb, &inc);\n\tif (r < 0) {\n\t\tDMERR(\"dm_tm_shadow_block() failed\");\n\t\treturn r;\n\t}\n\tie_disk.blocknr = cpu_to_le64(dm_block_location(nb));\n\tbm_le = dm_bitmap_data(nb);\n\n\told = sm_lookup_bitmap(bm_le, bit);\n\tif (old > 2) {\n\t\tr = sm_ll_lookup_big_ref_count(ll, b, &old);\n\t\tif (r < 0) {\n\t\t\tdm_tm_unlock(ll->tm, nb);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (r) {\n\t\tdm_tm_unlock(ll->tm, nb);\n\t\treturn r;\n\t}\n\n\tif (ref_count <= 2) {\n\t\tsm_set_bitmap(bm_le, bit, ref_count);\n\t\tdm_tm_unlock(ll->tm, nb);\n\n\t\tif (old > 2) {\n\t\t\tr = dm_btree_remove(&ll->ref_count_info,\n\t\t\t\t\t    ll->ref_count_root,\n\t\t\t\t\t    &b, &ll->ref_count_root);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\n\t} else {\n\t\t__le32 le_rc = cpu_to_le32(ref_count);\n\n\t\tsm_set_bitmap(bm_le, bit, 3);\n\t\tdm_tm_unlock(ll->tm, nb);\n\n\t\t__dm_bless_for_disk(&le_rc);\n\t\tr = dm_btree_insert(&ll->ref_count_info, ll->ref_count_root,\n\t\t\t\t    &b, &le_rc, &ll->ref_count_root);\n\t\tif (r < 0) {\n\t\t\tDMERR(\"ref count insert failed\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (ref_count && !old) {\n\t\t*nr_allocations = 1;\n\t\tll->nr_allocated++;\n\t\tle32_add_cpu(&ie_disk.nr_free, -1);\n\t\tif (le32_to_cpu(ie_disk.none_free_before) == bit)\n\t\t\tie_disk.none_free_before = cpu_to_le32(bit + 1);\n\n\t} else if (old && !ref_count) {\n\t\t*nr_allocations = -1;\n\t\tll->nr_allocated--;\n\t\tle32_add_cpu(&ie_disk.nr_free, 1);\n\t\tie_disk.none_free_before = cpu_to_le32(min(le32_to_cpu(ie_disk.none_free_before), bit));\n\t} else\n\t\t*nr_allocations = 0;\n\n\treturn ll->save_ie(ll, index, &ie_disk);\n}\n\n \n\n \nstruct inc_context {\n\tstruct disk_index_entry ie_disk;\n\tstruct dm_block *bitmap_block;\n\tvoid *bitmap;\n\n\tstruct dm_block *overflow_leaf;\n};\n\nstatic inline void init_inc_context(struct inc_context *ic)\n{\n\tic->bitmap_block = NULL;\n\tic->bitmap = NULL;\n\tic->overflow_leaf = NULL;\n}\n\nstatic inline void exit_inc_context(struct ll_disk *ll, struct inc_context *ic)\n{\n\tif (ic->bitmap_block)\n\t\tdm_tm_unlock(ll->tm, ic->bitmap_block);\n\tif (ic->overflow_leaf)\n\t\tdm_tm_unlock(ll->tm, ic->overflow_leaf);\n}\n\nstatic inline void reset_inc_context(struct ll_disk *ll, struct inc_context *ic)\n{\n\texit_inc_context(ll, ic);\n\tinit_inc_context(ic);\n}\n\n \nstatic bool contains_key(struct btree_node *n, uint64_t key, int index)\n{\n\treturn index >= 0 &&\n\t\tindex < le32_to_cpu(n->header.nr_entries) &&\n\t\tle64_to_cpu(n->keys[index]) == key;\n}\n\nstatic int __sm_ll_inc_overflow(struct ll_disk *ll, dm_block_t b, struct inc_context *ic)\n{\n\tint r;\n\tint index;\n\tstruct btree_node *n;\n\t__le32 *v_ptr;\n\tuint32_t rc;\n\n\t \n\treset_inc_context(ll, ic);\n\n\tr = btree_get_overwrite_leaf(&ll->ref_count_info, ll->ref_count_root,\n\t\t\t\t     b, &index, &ll->ref_count_root, &ic->overflow_leaf);\n\tif (r < 0)\n\t\treturn r;\n\n\tn = dm_block_data(ic->overflow_leaf);\n\n\tif (!contains_key(n, b, index)) {\n\t\tDMERR(\"overflow btree is missing an entry\");\n\t\treturn -EINVAL;\n\t}\n\n\tv_ptr = value_ptr(n, index);\n\trc = le32_to_cpu(*v_ptr) + 1;\n\t*v_ptr = cpu_to_le32(rc);\n\n\treturn 0;\n}\n\nstatic int sm_ll_inc_overflow(struct ll_disk *ll, dm_block_t b, struct inc_context *ic)\n{\n\tint index;\n\tstruct btree_node *n;\n\t__le32 *v_ptr;\n\tuint32_t rc;\n\n\t \n\tif (ic->overflow_leaf) {\n\t\tn = dm_block_data(ic->overflow_leaf);\n\t\tindex = lower_bound(n, b);\n\t\tif (contains_key(n, b, index)) {\n\t\t\tv_ptr = value_ptr(n, index);\n\t\t\trc = le32_to_cpu(*v_ptr) + 1;\n\t\t\t*v_ptr = cpu_to_le32(rc);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn __sm_ll_inc_overflow(ll, b, ic);\n}\n\nstatic inline int shadow_bitmap(struct ll_disk *ll, struct inc_context *ic)\n{\n\tint r, inc;\n\n\tr = dm_tm_shadow_block(ll->tm, le64_to_cpu(ic->ie_disk.blocknr),\n\t\t\t       &dm_sm_bitmap_validator, &ic->bitmap_block, &inc);\n\tif (r < 0) {\n\t\tDMERR(\"dm_tm_shadow_block() failed\");\n\t\treturn r;\n\t}\n\tic->ie_disk.blocknr = cpu_to_le64(dm_block_location(ic->bitmap_block));\n\tic->bitmap = dm_bitmap_data(ic->bitmap_block);\n\treturn 0;\n}\n\n \nstatic inline int ensure_bitmap(struct ll_disk *ll, struct inc_context *ic)\n{\n\tif (!ic->bitmap_block) {\n\t\tint r = dm_bm_write_lock(dm_tm_get_bm(ll->tm), le64_to_cpu(ic->ie_disk.blocknr),\n\t\t\t\t\t &dm_sm_bitmap_validator, &ic->bitmap_block);\n\t\tif (r) {\n\t\t\tDMERR(\"unable to re-get write lock for bitmap\");\n\t\t\treturn r;\n\t\t}\n\t\tic->bitmap = dm_bitmap_data(ic->bitmap_block);\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int sm_ll_inc_bitmap(struct ll_disk *ll, dm_block_t b,\n\t\t\t\t   uint32_t bit, uint32_t bit_end,\n\t\t\t\t   int32_t *nr_allocations, dm_block_t *new_b,\n\t\t\t\t   struct inc_context *ic)\n{\n\tint r;\n\t__le32 le_rc;\n\tuint32_t old;\n\n\tfor (; bit != bit_end; bit++, b++) {\n\t\t \n\t\tr = ensure_bitmap(ll, ic);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\told = sm_lookup_bitmap(ic->bitmap, bit);\n\t\tswitch (old) {\n\t\tcase 0:\n\t\t\t \n\t\t\tsm_set_bitmap(ic->bitmap, bit, 1);\n\t\t\t(*nr_allocations)++;\n\t\t\tll->nr_allocated++;\n\t\t\tle32_add_cpu(&ic->ie_disk.nr_free, -1);\n\t\t\tif (le32_to_cpu(ic->ie_disk.none_free_before) == bit)\n\t\t\t\tic->ie_disk.none_free_before = cpu_to_le32(bit + 1);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t \n\t\t\tsm_set_bitmap(ic->bitmap, bit, 2);\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t \n\t\t\tsm_set_bitmap(ic->bitmap, bit, 3);\n\t\t\treset_inc_context(ll, ic);\n\n\t\t\tle_rc = cpu_to_le32(3);\n\t\t\t__dm_bless_for_disk(&le_rc);\n\t\t\tr = dm_btree_insert(&ll->ref_count_info, ll->ref_count_root,\n\t\t\t\t\t    &b, &le_rc, &ll->ref_count_root);\n\t\t\tif (r < 0) {\n\t\t\t\tDMERR(\"ref count insert failed\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tr = sm_ll_inc_overflow(ll, b, ic);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\t*new_b = b;\n\treturn 0;\n}\n\n \nstatic int __sm_ll_inc(struct ll_disk *ll, dm_block_t b, dm_block_t e,\n\t\t       int32_t *nr_allocations, dm_block_t *new_b)\n{\n\tint r;\n\tstruct inc_context ic;\n\tuint32_t bit, bit_end;\n\tdm_block_t index = b;\n\n\tinit_inc_context(&ic);\n\n\tbit = do_div(index, ll->entries_per_block);\n\tr = ll->load_ie(ll, index, &ic.ie_disk);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = shadow_bitmap(ll, &ic);\n\tif (r)\n\t\treturn r;\n\n\tbit_end = min(bit + (e - b), (dm_block_t) ll->entries_per_block);\n\tr = sm_ll_inc_bitmap(ll, b, bit, bit_end, nr_allocations, new_b, &ic);\n\n\texit_inc_context(ll, &ic);\n\n\tif (r)\n\t\treturn r;\n\n\treturn ll->save_ie(ll, index, &ic.ie_disk);\n}\n\nint sm_ll_inc(struct ll_disk *ll, dm_block_t b, dm_block_t e,\n\t      int32_t *nr_allocations)\n{\n\t*nr_allocations = 0;\n\twhile (b != e) {\n\t\tint r = __sm_ll_inc(ll, b, e, nr_allocations, &b);\n\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int __sm_ll_del_overflow(struct ll_disk *ll, dm_block_t b,\n\t\t\t\tstruct inc_context *ic)\n{\n\treset_inc_context(ll, ic);\n\treturn dm_btree_remove(&ll->ref_count_info, ll->ref_count_root,\n\t\t\t       &b, &ll->ref_count_root);\n}\n\nstatic int __sm_ll_dec_overflow(struct ll_disk *ll, dm_block_t b,\n\t\t\t\tstruct inc_context *ic, uint32_t *old_rc)\n{\n\tint r;\n\tint index = -1;\n\tstruct btree_node *n;\n\t__le32 *v_ptr;\n\tuint32_t rc;\n\n\treset_inc_context(ll, ic);\n\tr = btree_get_overwrite_leaf(&ll->ref_count_info, ll->ref_count_root,\n\t\t\t\t     b, &index, &ll->ref_count_root, &ic->overflow_leaf);\n\tif (r < 0)\n\t\treturn r;\n\n\tn = dm_block_data(ic->overflow_leaf);\n\n\tif (!contains_key(n, b, index)) {\n\t\tDMERR(\"overflow btree is missing an entry\");\n\t\treturn -EINVAL;\n\t}\n\n\tv_ptr = value_ptr(n, index);\n\trc = le32_to_cpu(*v_ptr);\n\t*old_rc = rc;\n\n\tif (rc == 3)\n\t\treturn __sm_ll_del_overflow(ll, b, ic);\n\n\trc--;\n\t*v_ptr = cpu_to_le32(rc);\n\treturn 0;\n}\n\nstatic int sm_ll_dec_overflow(struct ll_disk *ll, dm_block_t b,\n\t\t\t      struct inc_context *ic, uint32_t *old_rc)\n{\n\t \n\tif (ic->overflow_leaf) {\n\t\tint index;\n\t\tstruct btree_node *n;\n\t\t__le32 *v_ptr;\n\t\tuint32_t rc;\n\n\t\tn = dm_block_data(ic->overflow_leaf);\n\t\tindex = lower_bound(n, b);\n\t\tif (contains_key(n, b, index)) {\n\t\t\tv_ptr = value_ptr(n, index);\n\t\t\trc = le32_to_cpu(*v_ptr);\n\t\t\t*old_rc = rc;\n\n\t\t\tif (rc > 3) {\n\t\t\t\trc--;\n\t\t\t\t*v_ptr = cpu_to_le32(rc);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn __sm_ll_del_overflow(ll, b, ic);\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn __sm_ll_dec_overflow(ll, b, ic, old_rc);\n}\n\n \nstatic inline int sm_ll_dec_bitmap(struct ll_disk *ll, dm_block_t b,\n\t\t\t\t   uint32_t bit, uint32_t bit_end,\n\t\t\t\t   struct inc_context *ic,\n\t\t\t\t   int32_t *nr_allocations, dm_block_t *new_b)\n{\n\tint r;\n\tuint32_t old;\n\n\tfor (; bit != bit_end; bit++, b++) {\n\t\t \n\t\tr = ensure_bitmap(ll, ic);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\told = sm_lookup_bitmap(ic->bitmap, bit);\n\t\tswitch (old) {\n\t\tcase 0:\n\t\t\tDMERR(\"unable to decrement block\");\n\t\t\treturn -EINVAL;\n\n\t\tcase 1:\n\t\t\t \n\t\t\tsm_set_bitmap(ic->bitmap, bit, 0);\n\t\t\t(*nr_allocations)--;\n\t\t\tll->nr_allocated--;\n\t\t\tle32_add_cpu(&ic->ie_disk.nr_free, 1);\n\t\t\tic->ie_disk.none_free_before =\n\t\t\t\tcpu_to_le32(min(le32_to_cpu(ic->ie_disk.none_free_before), bit));\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t \n\t\t\tsm_set_bitmap(ic->bitmap, bit, 1);\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tr = sm_ll_dec_overflow(ll, b, ic, &old);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\n\t\t\tif (old == 3) {\n\t\t\t\tr = ensure_bitmap(ll, ic);\n\t\t\t\tif (r)\n\t\t\t\t\treturn r;\n\n\t\t\t\tsm_set_bitmap(ic->bitmap, bit, 2);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*new_b = b;\n\treturn 0;\n}\n\nstatic int __sm_ll_dec(struct ll_disk *ll, dm_block_t b, dm_block_t e,\n\t\t       int32_t *nr_allocations, dm_block_t *new_b)\n{\n\tint r;\n\tuint32_t bit, bit_end;\n\tstruct inc_context ic;\n\tdm_block_t index = b;\n\n\tinit_inc_context(&ic);\n\n\tbit = do_div(index, ll->entries_per_block);\n\tr = ll->load_ie(ll, index, &ic.ie_disk);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = shadow_bitmap(ll, &ic);\n\tif (r)\n\t\treturn r;\n\n\tbit_end = min(bit + (e - b), (dm_block_t) ll->entries_per_block);\n\tr = sm_ll_dec_bitmap(ll, b, bit, bit_end, &ic, nr_allocations, new_b);\n\texit_inc_context(ll, &ic);\n\n\tif (r)\n\t\treturn r;\n\n\treturn ll->save_ie(ll, index, &ic.ie_disk);\n}\n\nint sm_ll_dec(struct ll_disk *ll, dm_block_t b, dm_block_t e,\n\t      int32_t *nr_allocations)\n{\n\t*nr_allocations = 0;\n\twhile (b != e) {\n\t\tint r = __sm_ll_dec(ll, b, e, nr_allocations, &b);\n\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n \n\nint sm_ll_commit(struct ll_disk *ll)\n{\n\tint r = 0;\n\n\tif (ll->bitmap_index_changed) {\n\t\tr = ll->commit(ll);\n\t\tif (!r)\n\t\t\tll->bitmap_index_changed = false;\n\t}\n\n\treturn r;\n}\n\n \n\nstatic int metadata_ll_load_ie(struct ll_disk *ll, dm_block_t index,\n\t\t\t       struct disk_index_entry *ie)\n{\n\tmemcpy(ie, ll->mi_le.index + index, sizeof(*ie));\n\treturn 0;\n}\n\nstatic int metadata_ll_save_ie(struct ll_disk *ll, dm_block_t index,\n\t\t\t       struct disk_index_entry *ie)\n{\n\tll->bitmap_index_changed = true;\n\tmemcpy(ll->mi_le.index + index, ie, sizeof(*ie));\n\treturn 0;\n}\n\nstatic int metadata_ll_init_index(struct ll_disk *ll)\n{\n\tint r;\n\tstruct dm_block *b;\n\n\tr = dm_tm_new_block(ll->tm, &index_validator, &b);\n\tif (r < 0)\n\t\treturn r;\n\n\tll->bitmap_root = dm_block_location(b);\n\n\tdm_tm_unlock(ll->tm, b);\n\n\treturn 0;\n}\n\nstatic int metadata_ll_open(struct ll_disk *ll)\n{\n\tint r;\n\tstruct dm_block *block;\n\n\tr = dm_tm_read_lock(ll->tm, ll->bitmap_root,\n\t\t\t    &index_validator, &block);\n\tif (r)\n\t\treturn r;\n\n\tmemcpy(&ll->mi_le, dm_block_data(block), sizeof(ll->mi_le));\n\tdm_tm_unlock(ll->tm, block);\n\n\treturn 0;\n}\n\nstatic dm_block_t metadata_ll_max_entries(struct ll_disk *ll)\n{\n\treturn MAX_METADATA_BITMAPS;\n}\n\nstatic int metadata_ll_commit(struct ll_disk *ll)\n{\n\tint r, inc;\n\tstruct dm_block *b;\n\n\tr = dm_tm_shadow_block(ll->tm, ll->bitmap_root, &index_validator, &b, &inc);\n\tif (r)\n\t\treturn r;\n\n\tmemcpy(dm_block_data(b), &ll->mi_le, sizeof(ll->mi_le));\n\tll->bitmap_root = dm_block_location(b);\n\n\tdm_tm_unlock(ll->tm, b);\n\n\treturn 0;\n}\n\nint sm_ll_new_metadata(struct ll_disk *ll, struct dm_transaction_manager *tm)\n{\n\tint r;\n\n\tr = sm_ll_init(ll, tm);\n\tif (r < 0)\n\t\treturn r;\n\n\tll->load_ie = metadata_ll_load_ie;\n\tll->save_ie = metadata_ll_save_ie;\n\tll->init_index = metadata_ll_init_index;\n\tll->open_index = metadata_ll_open;\n\tll->max_entries = metadata_ll_max_entries;\n\tll->commit = metadata_ll_commit;\n\n\tll->nr_blocks = 0;\n\tll->nr_allocated = 0;\n\n\tr = ll->init_index(ll);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_btree_empty(&ll->ref_count_info, &ll->ref_count_root);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nint sm_ll_open_metadata(struct ll_disk *ll, struct dm_transaction_manager *tm,\n\t\t\tvoid *root_le, size_t len)\n{\n\tint r;\n\tstruct disk_sm_root smr;\n\n\tif (len < sizeof(struct disk_sm_root)) {\n\t\tDMERR(\"sm_metadata root too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmemcpy(&smr, root_le, sizeof(smr));\n\n\tr = sm_ll_init(ll, tm);\n\tif (r < 0)\n\t\treturn r;\n\n\tll->load_ie = metadata_ll_load_ie;\n\tll->save_ie = metadata_ll_save_ie;\n\tll->init_index = metadata_ll_init_index;\n\tll->open_index = metadata_ll_open;\n\tll->max_entries = metadata_ll_max_entries;\n\tll->commit = metadata_ll_commit;\n\n\tll->nr_blocks = le64_to_cpu(smr.nr_blocks);\n\tll->nr_allocated = le64_to_cpu(smr.nr_allocated);\n\tll->bitmap_root = le64_to_cpu(smr.bitmap_root);\n\tll->ref_count_root = le64_to_cpu(smr.ref_count_root);\n\n\treturn ll->open_index(ll);\n}\n\n \n\nstatic inline int ie_cache_writeback(struct ll_disk *ll, struct ie_cache *iec)\n{\n\tiec->dirty = false;\n\t__dm_bless_for_disk(iec->ie);\n\treturn dm_btree_insert(&ll->bitmap_info, ll->bitmap_root,\n\t\t\t       &iec->index, &iec->ie, &ll->bitmap_root);\n}\n\nstatic inline unsigned int hash_index(dm_block_t index)\n{\n\treturn dm_hash_block(index, IE_CACHE_MASK);\n}\n\nstatic int disk_ll_load_ie(struct ll_disk *ll, dm_block_t index,\n\t\t\t   struct disk_index_entry *ie)\n{\n\tint r;\n\tunsigned int h = hash_index(index);\n\tstruct ie_cache *iec = ll->ie_cache + h;\n\n\tif (iec->valid) {\n\t\tif (iec->index == index) {\n\t\t\tmemcpy(ie, &iec->ie, sizeof(*ie));\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iec->dirty) {\n\t\t\tr = ie_cache_writeback(ll, iec);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = dm_btree_lookup(&ll->bitmap_info, ll->bitmap_root, &index, ie);\n\tif (!r) {\n\t\tiec->valid = true;\n\t\tiec->dirty = false;\n\t\tiec->index = index;\n\t\tmemcpy(&iec->ie, ie, sizeof(*ie));\n\t}\n\n\treturn r;\n}\n\nstatic int disk_ll_save_ie(struct ll_disk *ll, dm_block_t index,\n\t\t\t   struct disk_index_entry *ie)\n{\n\tint r;\n\tunsigned int h = hash_index(index);\n\tstruct ie_cache *iec = ll->ie_cache + h;\n\n\tll->bitmap_index_changed = true;\n\tif (iec->valid) {\n\t\tif (iec->index == index) {\n\t\t\tmemcpy(&iec->ie, ie, sizeof(*ie));\n\t\t\tiec->dirty = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iec->dirty) {\n\t\t\tr = ie_cache_writeback(ll, iec);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\tiec->valid = true;\n\tiec->dirty = true;\n\tiec->index = index;\n\tmemcpy(&iec->ie, ie, sizeof(*ie));\n\treturn 0;\n}\n\nstatic int disk_ll_init_index(struct ll_disk *ll)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < IE_CACHE_SIZE; i++) {\n\t\tstruct ie_cache *iec = ll->ie_cache + i;\n\n\t\tiec->valid = false;\n\t\tiec->dirty = false;\n\t}\n\treturn dm_btree_empty(&ll->bitmap_info, &ll->bitmap_root);\n}\n\nstatic int disk_ll_open(struct ll_disk *ll)\n{\n\treturn 0;\n}\n\nstatic dm_block_t disk_ll_max_entries(struct ll_disk *ll)\n{\n\treturn -1ULL;\n}\n\nstatic int disk_ll_commit(struct ll_disk *ll)\n{\n\tint r = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < IE_CACHE_SIZE; i++) {\n\t\tstruct ie_cache *iec = ll->ie_cache + i;\n\n\t\tif (iec->valid && iec->dirty)\n\t\t\tr = ie_cache_writeback(ll, iec);\n\t}\n\n\treturn r;\n}\n\nint sm_ll_new_disk(struct ll_disk *ll, struct dm_transaction_manager *tm)\n{\n\tint r;\n\n\tr = sm_ll_init(ll, tm);\n\tif (r < 0)\n\t\treturn r;\n\n\tll->load_ie = disk_ll_load_ie;\n\tll->save_ie = disk_ll_save_ie;\n\tll->init_index = disk_ll_init_index;\n\tll->open_index = disk_ll_open;\n\tll->max_entries = disk_ll_max_entries;\n\tll->commit = disk_ll_commit;\n\n\tll->nr_blocks = 0;\n\tll->nr_allocated = 0;\n\n\tr = ll->init_index(ll);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = dm_btree_empty(&ll->ref_count_info, &ll->ref_count_root);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nint sm_ll_open_disk(struct ll_disk *ll, struct dm_transaction_manager *tm,\n\t\t    void *root_le, size_t len)\n{\n\tint r;\n\tstruct disk_sm_root *smr = root_le;\n\n\tif (len < sizeof(struct disk_sm_root)) {\n\t\tDMERR(\"sm_metadata root too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tr = sm_ll_init(ll, tm);\n\tif (r < 0)\n\t\treturn r;\n\n\tll->load_ie = disk_ll_load_ie;\n\tll->save_ie = disk_ll_save_ie;\n\tll->init_index = disk_ll_init_index;\n\tll->open_index = disk_ll_open;\n\tll->max_entries = disk_ll_max_entries;\n\tll->commit = disk_ll_commit;\n\n\tll->nr_blocks = le64_to_cpu(smr->nr_blocks);\n\tll->nr_allocated = le64_to_cpu(smr->nr_allocated);\n\tll->bitmap_root = le64_to_cpu(smr->bitmap_root);\n\tll->ref_count_root = le64_to_cpu(smr->ref_count_root);\n\n\treturn ll->open_index(ll);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}