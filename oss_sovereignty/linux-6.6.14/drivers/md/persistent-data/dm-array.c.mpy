{
  "module_name": "dm-array.c",
  "hash_id": "81f34be6f233191f631643168d72255740ad6d38e8f27f0527dd97a2bb242025",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/persistent-data/dm-array.c",
  "human_readable_source": "\n \n\n#include \"dm-array.h\"\n#include \"dm-space-map.h\"\n#include \"dm-transaction-manager.h\"\n\n#include <linux/export.h>\n#include <linux/device-mapper.h>\n\n#define DM_MSG_PREFIX \"array\"\n\n \n\n \nstruct array_block {\n\t__le32 csum;\n\t__le32 max_entries;\n\t__le32 nr_entries;\n\t__le32 value_size;\n\t__le64 blocknr;  \n} __packed;\n\n \n\n \n#define CSUM_XOR 595846735\n\nstatic void array_block_prepare_for_write(struct dm_block_validator *v,\n\t\t\t\t\t  struct dm_block *b,\n\t\t\t\t\t  size_t size_of_block)\n{\n\tstruct array_block *bh_le = dm_block_data(b);\n\n\tbh_le->blocknr = cpu_to_le64(dm_block_location(b));\n\tbh_le->csum = cpu_to_le32(dm_bm_checksum(&bh_le->max_entries,\n\t\t\t\t\t\t size_of_block - sizeof(__le32),\n\t\t\t\t\t\t CSUM_XOR));\n}\n\nstatic int array_block_check(struct dm_block_validator *v,\n\t\t\t     struct dm_block *b,\n\t\t\t     size_t size_of_block)\n{\n\tstruct array_block *bh_le = dm_block_data(b);\n\t__le32 csum_disk;\n\n\tif (dm_block_location(b) != le64_to_cpu(bh_le->blocknr)) {\n\t\tDMERR_LIMIT(\"%s failed: blocknr %llu != wanted %llu\", __func__,\n\t\t\t    (unsigned long long) le64_to_cpu(bh_le->blocknr),\n\t\t\t    (unsigned long long) dm_block_location(b));\n\t\treturn -ENOTBLK;\n\t}\n\n\tcsum_disk = cpu_to_le32(dm_bm_checksum(&bh_le->max_entries,\n\t\t\t\t\t       size_of_block - sizeof(__le32),\n\t\t\t\t\t       CSUM_XOR));\n\tif (csum_disk != bh_le->csum) {\n\t\tDMERR_LIMIT(\"%s failed: csum %u != wanted %u\", __func__,\n\t\t\t    (unsigned int) le32_to_cpu(csum_disk),\n\t\t\t    (unsigned int) le32_to_cpu(bh_le->csum));\n\t\treturn -EILSEQ;\n\t}\n\n\treturn 0;\n}\n\nstatic struct dm_block_validator array_validator = {\n\t.name = \"array\",\n\t.prepare_for_write = array_block_prepare_for_write,\n\t.check = array_block_check\n};\n\n \n\n \n\n \nstatic void *element_at(struct dm_array_info *info, struct array_block *ab,\n\t\t\tunsigned int index)\n{\n\tunsigned char *entry = (unsigned char *) (ab + 1);\n\n\tentry += index * info->value_type.size;\n\n\treturn entry;\n}\n\n \nstatic void on_entries(struct dm_array_info *info, struct array_block *ab,\n\t\t       void (*fn)(void *, const void *, unsigned int))\n{\n\tunsigned int nr_entries = le32_to_cpu(ab->nr_entries);\n\n\tfn(info->value_type.context, element_at(info, ab, 0), nr_entries);\n}\n\n \nstatic void inc_ablock_entries(struct dm_array_info *info, struct array_block *ab)\n{\n\tstruct dm_btree_value_type *vt = &info->value_type;\n\n\tif (vt->inc)\n\t\ton_entries(info, ab, vt->inc);\n}\n\n \nstatic void dec_ablock_entries(struct dm_array_info *info, struct array_block *ab)\n{\n\tstruct dm_btree_value_type *vt = &info->value_type;\n\n\tif (vt->dec)\n\t\ton_entries(info, ab, vt->dec);\n}\n\n \nstatic uint32_t calc_max_entries(size_t value_size, size_t size_of_block)\n{\n\treturn (size_of_block - sizeof(struct array_block)) / value_size;\n}\n\n \nstatic int alloc_ablock(struct dm_array_info *info, size_t size_of_block,\n\t\t\tuint32_t max_entries,\n\t\t\tstruct dm_block **block, struct array_block **ab)\n{\n\tint r;\n\n\tr = dm_tm_new_block(info->btree_info.tm, &array_validator, block);\n\tif (r)\n\t\treturn r;\n\n\t(*ab) = dm_block_data(*block);\n\t(*ab)->max_entries = cpu_to_le32(max_entries);\n\t(*ab)->nr_entries = cpu_to_le32(0);\n\t(*ab)->value_size = cpu_to_le32(info->value_type.size);\n\n\treturn 0;\n}\n\n \nstatic void fill_ablock(struct dm_array_info *info, struct array_block *ab,\n\t\t\tconst void *value, unsigned int new_nr)\n{\n\tuint32_t nr_entries, delta, i;\n\tstruct dm_btree_value_type *vt = &info->value_type;\n\n\tBUG_ON(new_nr > le32_to_cpu(ab->max_entries));\n\tBUG_ON(new_nr < le32_to_cpu(ab->nr_entries));\n\n\tnr_entries = le32_to_cpu(ab->nr_entries);\n\tdelta = new_nr - nr_entries;\n\tif (vt->inc)\n\t\tvt->inc(vt->context, value, delta);\n\tfor (i = nr_entries; i < new_nr; i++)\n\t\tmemcpy(element_at(info, ab, i), value, vt->size);\n\tab->nr_entries = cpu_to_le32(new_nr);\n}\n\n \nstatic void trim_ablock(struct dm_array_info *info, struct array_block *ab,\n\t\t\tunsigned int new_nr)\n{\n\tuint32_t nr_entries, delta;\n\tstruct dm_btree_value_type *vt = &info->value_type;\n\n\tBUG_ON(new_nr > le32_to_cpu(ab->max_entries));\n\tBUG_ON(new_nr > le32_to_cpu(ab->nr_entries));\n\n\tnr_entries = le32_to_cpu(ab->nr_entries);\n\tdelta = nr_entries - new_nr;\n\tif (vt->dec)\n\t\tvt->dec(vt->context, element_at(info, ab, new_nr - 1), delta);\n\tab->nr_entries = cpu_to_le32(new_nr);\n}\n\n \nstatic int get_ablock(struct dm_array_info *info, dm_block_t b,\n\t\t      struct dm_block **block, struct array_block **ab)\n{\n\tint r;\n\n\tr = dm_tm_read_lock(info->btree_info.tm, b, &array_validator, block);\n\tif (r)\n\t\treturn r;\n\n\t*ab = dm_block_data(*block);\n\treturn 0;\n}\n\n \nstatic void unlock_ablock(struct dm_array_info *info, struct dm_block *block)\n{\n\tdm_tm_unlock(info->btree_info.tm, block);\n}\n\n \n\n \n\n \nstatic int lookup_ablock(struct dm_array_info *info, dm_block_t root,\n\t\t\t unsigned int index, struct dm_block **block,\n\t\t\t struct array_block **ab)\n{\n\tint r;\n\tuint64_t key = index;\n\t__le64 block_le;\n\n\tr = dm_btree_lookup(&info->btree_info, root, &key, &block_le);\n\tif (r)\n\t\treturn r;\n\n\treturn get_ablock(info, le64_to_cpu(block_le), block, ab);\n}\n\n \nstatic int insert_ablock(struct dm_array_info *info, uint64_t index,\n\t\t\t struct dm_block *block, dm_block_t *root)\n{\n\t__le64 block_le = cpu_to_le64(dm_block_location(block));\n\n\t__dm_bless_for_disk(block_le);\n\treturn dm_btree_insert(&info->btree_info, *root, &index, &block_le, root);\n}\n\n \n\nstatic int __shadow_ablock(struct dm_array_info *info, dm_block_t b,\n\t\t\t   struct dm_block **block, struct array_block **ab)\n{\n\tint inc;\n\tint r = dm_tm_shadow_block(info->btree_info.tm, b,\n\t\t\t\t   &array_validator, block, &inc);\n\tif (r)\n\t\treturn r;\n\n\t*ab = dm_block_data(*block);\n\tif (inc)\n\t\tinc_ablock_entries(info, *ab);\n\n\treturn 0;\n}\n\n \nstatic int __reinsert_ablock(struct dm_array_info *info, unsigned int index,\n\t\t\t     struct dm_block *block, dm_block_t b,\n\t\t\t     dm_block_t *root)\n{\n\tint r = 0;\n\n\tif (dm_block_location(block) != b) {\n\t\t \n\t\tdm_tm_inc(info->btree_info.tm, b);\n\t\tr = insert_ablock(info, index, block, root);\n\t}\n\n\treturn r;\n}\n\n \nstatic int shadow_ablock(struct dm_array_info *info, dm_block_t *root,\n\t\t\t unsigned int index, struct dm_block **block,\n\t\t\t struct array_block **ab)\n{\n\tint r;\n\tuint64_t key = index;\n\tdm_block_t b;\n\t__le64 block_le;\n\n\tr = dm_btree_lookup(&info->btree_info, *root, &key, &block_le);\n\tif (r)\n\t\treturn r;\n\tb = le64_to_cpu(block_le);\n\n\tr = __shadow_ablock(info, b, block, ab);\n\tif (r)\n\t\treturn r;\n\n\treturn __reinsert_ablock(info, index, *block, b, root);\n}\n\n \nstatic int insert_new_ablock(struct dm_array_info *info, size_t size_of_block,\n\t\t\t     uint32_t max_entries,\n\t\t\t     unsigned int block_index, uint32_t nr,\n\t\t\t     const void *value, dm_block_t *root)\n{\n\tint r;\n\tstruct dm_block *block;\n\tstruct array_block *ab;\n\n\tr = alloc_ablock(info, size_of_block, max_entries, &block, &ab);\n\tif (r)\n\t\treturn r;\n\n\tfill_ablock(info, ab, value, nr);\n\tr = insert_ablock(info, block_index, block, root);\n\tunlock_ablock(info, block);\n\n\treturn r;\n}\n\nstatic int insert_full_ablocks(struct dm_array_info *info, size_t size_of_block,\n\t\t\t       unsigned int begin_block, unsigned int end_block,\n\t\t\t       unsigned int max_entries, const void *value,\n\t\t\t       dm_block_t *root)\n{\n\tint r = 0;\n\n\tfor (; !r && begin_block != end_block; begin_block++)\n\t\tr = insert_new_ablock(info, size_of_block, max_entries, begin_block, max_entries, value, root);\n\n\treturn r;\n}\n\n \nstruct resize {\n\t \n\tstruct dm_array_info *info;\n\n\t \n\tdm_block_t root;\n\n\t \n\tsize_t size_of_block;\n\n\t \n\tunsigned int max_entries;\n\n\t \n\tunsigned int old_nr_full_blocks, new_nr_full_blocks;\n\n\t \n\tunsigned int old_nr_entries_in_last_block, new_nr_entries_in_last_block;\n\n\t \n\tconst void *value;\n};\n\n \nstatic int drop_blocks(struct resize *resize, unsigned int begin_index,\n\t\t       unsigned int end_index)\n{\n\tint r;\n\n\twhile (begin_index != end_index) {\n\t\tuint64_t key = begin_index++;\n\n\t\tr = dm_btree_remove(&resize->info->btree_info, resize->root,\n\t\t\t\t    &key, &resize->root);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n \nstatic unsigned int total_nr_blocks_needed(unsigned int nr_full_blocks,\n\t\t\t\t       unsigned int nr_entries_in_last_block)\n{\n\treturn nr_full_blocks + (nr_entries_in_last_block ? 1 : 0);\n}\n\n \nstatic int shrink(struct resize *resize)\n{\n\tint r;\n\tunsigned int begin, end;\n\tstruct dm_block *block;\n\tstruct array_block *ab;\n\n\t \n\tif (resize->new_nr_full_blocks < resize->old_nr_full_blocks) {\n\t\tbegin = total_nr_blocks_needed(resize->new_nr_full_blocks,\n\t\t\t\t\t       resize->new_nr_entries_in_last_block);\n\t\tend = total_nr_blocks_needed(resize->old_nr_full_blocks,\n\t\t\t\t\t     resize->old_nr_entries_in_last_block);\n\n\t\tr = drop_blocks(resize, begin, end);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tif (resize->new_nr_entries_in_last_block) {\n\t\tr = shadow_ablock(resize->info, &resize->root,\n\t\t\t\t  resize->new_nr_full_blocks, &block, &ab);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\ttrim_ablock(resize->info, ab, resize->new_nr_entries_in_last_block);\n\t\tunlock_ablock(resize->info, block);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int grow_extend_tail_block(struct resize *resize, uint32_t new_nr_entries)\n{\n\tint r;\n\tstruct dm_block *block;\n\tstruct array_block *ab;\n\n\tr = shadow_ablock(resize->info, &resize->root,\n\t\t\t  resize->old_nr_full_blocks, &block, &ab);\n\tif (r)\n\t\treturn r;\n\n\tfill_ablock(resize->info, ab, resize->value, new_nr_entries);\n\tunlock_ablock(resize->info, block);\n\n\treturn r;\n}\n\nstatic int grow_add_tail_block(struct resize *resize)\n{\n\treturn insert_new_ablock(resize->info, resize->size_of_block,\n\t\t\t\t resize->max_entries,\n\t\t\t\t resize->new_nr_full_blocks,\n\t\t\t\t resize->new_nr_entries_in_last_block,\n\t\t\t\t resize->value, &resize->root);\n}\n\nstatic int grow_needs_more_blocks(struct resize *resize)\n{\n\tint r;\n\tunsigned int old_nr_blocks = resize->old_nr_full_blocks;\n\n\tif (resize->old_nr_entries_in_last_block > 0) {\n\t\told_nr_blocks++;\n\n\t\tr = grow_extend_tail_block(resize, resize->max_entries);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = insert_full_ablocks(resize->info, resize->size_of_block,\n\t\t\t\told_nr_blocks,\n\t\t\t\tresize->new_nr_full_blocks,\n\t\t\t\tresize->max_entries, resize->value,\n\t\t\t\t&resize->root);\n\tif (r)\n\t\treturn r;\n\n\tif (resize->new_nr_entries_in_last_block)\n\t\tr = grow_add_tail_block(resize);\n\n\treturn r;\n}\n\nstatic int grow(struct resize *resize)\n{\n\tif (resize->new_nr_full_blocks > resize->old_nr_full_blocks)\n\t\treturn grow_needs_more_blocks(resize);\n\n\telse if (resize->old_nr_entries_in_last_block)\n\t\treturn grow_extend_tail_block(resize, resize->new_nr_entries_in_last_block);\n\n\telse\n\t\treturn grow_add_tail_block(resize);\n}\n\n \n\n \nstatic void block_inc(void *context, const void *value, unsigned int count)\n{\n\tconst __le64 *block_le = value;\n\tstruct dm_array_info *info = context;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++, block_le++)\n\t\tdm_tm_inc(info->btree_info.tm, le64_to_cpu(*block_le));\n}\n\nstatic void __block_dec(void *context, const void *value)\n{\n\tint r;\n\tuint64_t b;\n\t__le64 block_le;\n\tuint32_t ref_count;\n\tstruct dm_block *block;\n\tstruct array_block *ab;\n\tstruct dm_array_info *info = context;\n\n\tmemcpy(&block_le, value, sizeof(block_le));\n\tb = le64_to_cpu(block_le);\n\n\tr = dm_tm_ref(info->btree_info.tm, b, &ref_count);\n\tif (r) {\n\t\tDMERR_LIMIT(\"couldn't get reference count for block %llu\",\n\t\t\t    (unsigned long long) b);\n\t\treturn;\n\t}\n\n\tif (ref_count == 1) {\n\t\t \n\t\tr = get_ablock(info, b, &block, &ab);\n\t\tif (r) {\n\t\t\tDMERR_LIMIT(\"couldn't get array block %llu\",\n\t\t\t\t    (unsigned long long) b);\n\t\t\treturn;\n\t\t}\n\n\t\tdec_ablock_entries(info, ab);\n\t\tunlock_ablock(info, block);\n\t}\n\n\tdm_tm_dec(info->btree_info.tm, b);\n}\n\nstatic void block_dec(void *context, const void *value, unsigned int count)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++, value += sizeof(__le64))\n\t\t__block_dec(context, value);\n}\n\nstatic int block_equal(void *context, const void *value1, const void *value2)\n{\n\treturn !memcmp(value1, value2, sizeof(__le64));\n}\n\n \n\nvoid dm_array_info_init(struct dm_array_info *info,\n\t\t\tstruct dm_transaction_manager *tm,\n\t\t\tstruct dm_btree_value_type *vt)\n{\n\tstruct dm_btree_value_type *bvt = &info->btree_info.value_type;\n\n\tmemcpy(&info->value_type, vt, sizeof(info->value_type));\n\tinfo->btree_info.tm = tm;\n\tinfo->btree_info.levels = 1;\n\n\tbvt->context = info;\n\tbvt->size = sizeof(__le64);\n\tbvt->inc = block_inc;\n\tbvt->dec = block_dec;\n\tbvt->equal = block_equal;\n}\nEXPORT_SYMBOL_GPL(dm_array_info_init);\n\nint dm_array_empty(struct dm_array_info *info, dm_block_t *root)\n{\n\treturn dm_btree_empty(&info->btree_info, root);\n}\nEXPORT_SYMBOL_GPL(dm_array_empty);\n\nstatic int array_resize(struct dm_array_info *info, dm_block_t root,\n\t\t\tuint32_t old_size, uint32_t new_size,\n\t\t\tconst void *value, dm_block_t *new_root)\n{\n\tint r;\n\tstruct resize resize;\n\n\tif (old_size == new_size) {\n\t\t*new_root = root;\n\t\treturn 0;\n\t}\n\n\tresize.info = info;\n\tresize.root = root;\n\tresize.size_of_block = dm_bm_block_size(dm_tm_get_bm(info->btree_info.tm));\n\tresize.max_entries = calc_max_entries(info->value_type.size,\n\t\t\t\t\t      resize.size_of_block);\n\n\tresize.old_nr_full_blocks = old_size / resize.max_entries;\n\tresize.old_nr_entries_in_last_block = old_size % resize.max_entries;\n\tresize.new_nr_full_blocks = new_size / resize.max_entries;\n\tresize.new_nr_entries_in_last_block = new_size % resize.max_entries;\n\tresize.value = value;\n\n\tr = ((new_size > old_size) ? grow : shrink)(&resize);\n\tif (r)\n\t\treturn r;\n\n\t*new_root = resize.root;\n\treturn 0;\n}\n\nint dm_array_resize(struct dm_array_info *info, dm_block_t root,\n\t\t    uint32_t old_size, uint32_t new_size,\n\t\t    const void *value, dm_block_t *new_root)\n\t__dm_written_to_disk(value)\n{\n\tint r = array_resize(info, root, old_size, new_size, value, new_root);\n\n\t__dm_unbless_for_disk(value);\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_array_resize);\n\nstatic int populate_ablock_with_values(struct dm_array_info *info, struct array_block *ab,\n\t\t\t\t       value_fn fn, void *context,\n\t\t\t\t       unsigned int base, unsigned int new_nr)\n{\n\tint r;\n\tunsigned int i;\n\tstruct dm_btree_value_type *vt = &info->value_type;\n\n\tBUG_ON(le32_to_cpu(ab->nr_entries));\n\tBUG_ON(new_nr > le32_to_cpu(ab->max_entries));\n\n\tfor (i = 0; i < new_nr; i++) {\n\t\tr = fn(base + i, element_at(info, ab, i), context);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tif (vt->inc)\n\t\t\tvt->inc(vt->context, element_at(info, ab, i), 1);\n\t}\n\n\tab->nr_entries = cpu_to_le32(new_nr);\n\treturn 0;\n}\n\nint dm_array_new(struct dm_array_info *info, dm_block_t *root,\n\t\t uint32_t size, value_fn fn, void *context)\n{\n\tint r;\n\tstruct dm_block *block;\n\tstruct array_block *ab;\n\tunsigned int block_index, end_block, size_of_block, max_entries;\n\n\tr = dm_array_empty(info, root);\n\tif (r)\n\t\treturn r;\n\n\tsize_of_block = dm_bm_block_size(dm_tm_get_bm(info->btree_info.tm));\n\tmax_entries = calc_max_entries(info->value_type.size, size_of_block);\n\tend_block = dm_div_up(size, max_entries);\n\n\tfor (block_index = 0; block_index != end_block; block_index++) {\n\t\tr = alloc_ablock(info, size_of_block, max_entries, &block, &ab);\n\t\tif (r)\n\t\t\tbreak;\n\n\t\tr = populate_ablock_with_values(info, ab, fn, context,\n\t\t\t\t\t\tblock_index * max_entries,\n\t\t\t\t\t\tmin(max_entries, size));\n\t\tif (r) {\n\t\t\tunlock_ablock(info, block);\n\t\t\tbreak;\n\t\t}\n\n\t\tr = insert_ablock(info, block_index, block, root);\n\t\tunlock_ablock(info, block);\n\t\tif (r)\n\t\t\tbreak;\n\n\t\tsize -= max_entries;\n\t}\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_array_new);\n\nint dm_array_del(struct dm_array_info *info, dm_block_t root)\n{\n\treturn dm_btree_del(&info->btree_info, root);\n}\nEXPORT_SYMBOL_GPL(dm_array_del);\n\nint dm_array_get_value(struct dm_array_info *info, dm_block_t root,\n\t\t       uint32_t index, void *value_le)\n{\n\tint r;\n\tstruct dm_block *block;\n\tstruct array_block *ab;\n\tsize_t size_of_block;\n\tunsigned int entry, max_entries;\n\n\tsize_of_block = dm_bm_block_size(dm_tm_get_bm(info->btree_info.tm));\n\tmax_entries = calc_max_entries(info->value_type.size, size_of_block);\n\n\tr = lookup_ablock(info, root, index / max_entries, &block, &ab);\n\tif (r)\n\t\treturn r;\n\n\tentry = index % max_entries;\n\tif (entry >= le32_to_cpu(ab->nr_entries))\n\t\tr = -ENODATA;\n\telse\n\t\tmemcpy(value_le, element_at(info, ab, entry),\n\t\t       info->value_type.size);\n\n\tunlock_ablock(info, block);\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_array_get_value);\n\nstatic int array_set_value(struct dm_array_info *info, dm_block_t root,\n\t\t\t   uint32_t index, const void *value, dm_block_t *new_root)\n{\n\tint r;\n\tstruct dm_block *block;\n\tstruct array_block *ab;\n\tsize_t size_of_block;\n\tunsigned int max_entries;\n\tunsigned int entry;\n\tvoid *old_value;\n\tstruct dm_btree_value_type *vt = &info->value_type;\n\n\tsize_of_block = dm_bm_block_size(dm_tm_get_bm(info->btree_info.tm));\n\tmax_entries = calc_max_entries(info->value_type.size, size_of_block);\n\n\tr = shadow_ablock(info, &root, index / max_entries, &block, &ab);\n\tif (r)\n\t\treturn r;\n\t*new_root = root;\n\n\tentry = index % max_entries;\n\tif (entry >= le32_to_cpu(ab->nr_entries)) {\n\t\tr = -ENODATA;\n\t\tgoto out;\n\t}\n\n\told_value = element_at(info, ab, entry);\n\tif (vt->dec &&\n\t    (!vt->equal || !vt->equal(vt->context, old_value, value))) {\n\t\tvt->dec(vt->context, old_value, 1);\n\t\tif (vt->inc)\n\t\t\tvt->inc(vt->context, value, 1);\n\t}\n\n\tmemcpy(old_value, value, info->value_type.size);\n\nout:\n\tunlock_ablock(info, block);\n\treturn r;\n}\n\nint dm_array_set_value(struct dm_array_info *info, dm_block_t root,\n\t\t uint32_t index, const void *value, dm_block_t *new_root)\n\t__dm_written_to_disk(value)\n{\n\tint r;\n\n\tr = array_set_value(info, root, index, value, new_root);\n\t__dm_unbless_for_disk(value);\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_array_set_value);\n\nstruct walk_info {\n\tstruct dm_array_info *info;\n\tint (*fn)(void *context, uint64_t key, void *leaf);\n\tvoid *context;\n};\n\nstatic int walk_ablock(void *context, uint64_t *keys, void *leaf)\n{\n\tstruct walk_info *wi = context;\n\n\tint r;\n\tunsigned int i;\n\t__le64 block_le;\n\tunsigned int nr_entries, max_entries;\n\tstruct dm_block *block;\n\tstruct array_block *ab;\n\n\tmemcpy(&block_le, leaf, sizeof(block_le));\n\tr = get_ablock(wi->info, le64_to_cpu(block_le), &block, &ab);\n\tif (r)\n\t\treturn r;\n\n\tmax_entries = le32_to_cpu(ab->max_entries);\n\tnr_entries = le32_to_cpu(ab->nr_entries);\n\tfor (i = 0; i < nr_entries; i++) {\n\t\tr = wi->fn(wi->context, keys[0] * max_entries + i,\n\t\t\t   element_at(wi->info, ab, i));\n\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\tunlock_ablock(wi->info, block);\n\treturn r;\n}\n\nint dm_array_walk(struct dm_array_info *info, dm_block_t root,\n\t\t  int (*fn)(void *, uint64_t key, void *leaf),\n\t\t  void *context)\n{\n\tstruct walk_info wi;\n\n\twi.info = info;\n\twi.fn = fn;\n\twi.context = context;\n\n\treturn dm_btree_walk(&info->btree_info, root, walk_ablock, &wi);\n}\nEXPORT_SYMBOL_GPL(dm_array_walk);\n\n \n\nstatic int load_ablock(struct dm_array_cursor *c)\n{\n\tint r;\n\t__le64 value_le;\n\tuint64_t key;\n\n\tif (c->block)\n\t\tunlock_ablock(c->info, c->block);\n\n\tc->block = NULL;\n\tc->ab = NULL;\n\tc->index = 0;\n\n\tr = dm_btree_cursor_get_value(&c->cursor, &key, &value_le);\n\tif (r) {\n\t\tDMERR(\"dm_btree_cursor_get_value failed\");\n\t\tdm_btree_cursor_end(&c->cursor);\n\n\t} else {\n\t\tr = get_ablock(c->info, le64_to_cpu(value_le), &c->block, &c->ab);\n\t\tif (r) {\n\t\t\tDMERR(\"get_ablock failed\");\n\t\t\tdm_btree_cursor_end(&c->cursor);\n\t\t}\n\t}\n\n\treturn r;\n}\n\nint dm_array_cursor_begin(struct dm_array_info *info, dm_block_t root,\n\t\t\t  struct dm_array_cursor *c)\n{\n\tint r;\n\n\tmemset(c, 0, sizeof(*c));\n\tc->info = info;\n\tr = dm_btree_cursor_begin(&info->btree_info, root, true, &c->cursor);\n\tif (r) {\n\t\tDMERR(\"couldn't create btree cursor\");\n\t\treturn r;\n\t}\n\n\treturn load_ablock(c);\n}\nEXPORT_SYMBOL_GPL(dm_array_cursor_begin);\n\nvoid dm_array_cursor_end(struct dm_array_cursor *c)\n{\n\tif (c->block) {\n\t\tunlock_ablock(c->info, c->block);\n\t\tdm_btree_cursor_end(&c->cursor);\n\t}\n}\nEXPORT_SYMBOL_GPL(dm_array_cursor_end);\n\nint dm_array_cursor_next(struct dm_array_cursor *c)\n{\n\tint r;\n\n\tif (!c->block)\n\t\treturn -ENODATA;\n\n\tc->index++;\n\n\tif (c->index >= le32_to_cpu(c->ab->nr_entries)) {\n\t\tr = dm_btree_cursor_next(&c->cursor);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = load_ablock(c);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dm_array_cursor_next);\n\nint dm_array_cursor_skip(struct dm_array_cursor *c, uint32_t count)\n{\n\tint r;\n\n\tdo {\n\t\tuint32_t remaining = le32_to_cpu(c->ab->nr_entries) - c->index;\n\n\t\tif (count < remaining) {\n\t\t\tc->index += count;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcount -= remaining;\n\t\tr = dm_array_cursor_next(c);\n\n\t} while (!r);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_array_cursor_skip);\n\nvoid dm_array_cursor_get_value(struct dm_array_cursor *c, void **value_le)\n{\n\t*value_le = element_at(c->info, c->ab, c->index);\n}\nEXPORT_SYMBOL_GPL(dm_array_cursor_get_value);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}