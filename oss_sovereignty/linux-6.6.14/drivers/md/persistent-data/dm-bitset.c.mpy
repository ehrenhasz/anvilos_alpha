{
  "module_name": "dm-bitset.c",
  "hash_id": "ce3b1fcfae47413672689473233ea522da062da3622b45e2b39dbe5796d0e510",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/persistent-data/dm-bitset.c",
  "human_readable_source": "\n \n\n#include \"dm-bitset.h\"\n#include \"dm-transaction-manager.h\"\n\n#include <linux/export.h>\n#include <linux/device-mapper.h>\n\n#define DM_MSG_PREFIX \"bitset\"\n#define BITS_PER_ARRAY_ENTRY 64\n\n \n\nstatic struct dm_btree_value_type bitset_bvt = {\n\t.context = NULL,\n\t.size = sizeof(__le64),\n\t.inc = NULL,\n\t.dec = NULL,\n\t.equal = NULL,\n};\n\n \n\nvoid dm_disk_bitset_init(struct dm_transaction_manager *tm,\n\t\t\t struct dm_disk_bitset *info)\n{\n\tdm_array_info_init(&info->array_info, tm, &bitset_bvt);\n\tinfo->current_index_set = false;\n}\nEXPORT_SYMBOL_GPL(dm_disk_bitset_init);\n\nint dm_bitset_empty(struct dm_disk_bitset *info, dm_block_t *root)\n{\n\treturn dm_array_empty(&info->array_info, root);\n}\nEXPORT_SYMBOL_GPL(dm_bitset_empty);\n\nstruct packer_context {\n\tbit_value_fn fn;\n\tunsigned int nr_bits;\n\tvoid *context;\n};\n\nstatic int pack_bits(uint32_t index, void *value, void *context)\n{\n\tint r;\n\tstruct packer_context *p = context;\n\tunsigned int bit, nr = min(64u, p->nr_bits - (index * 64));\n\tuint64_t word = 0;\n\tbool bv;\n\n\tfor (bit = 0; bit < nr; bit++) {\n\t\tr = p->fn(index * 64 + bit, &bv, p->context);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tif (bv)\n\t\t\tset_bit(bit, (unsigned long *) &word);\n\t\telse\n\t\t\tclear_bit(bit, (unsigned long *) &word);\n\t}\n\n\t*((__le64 *) value) = cpu_to_le64(word);\n\n\treturn 0;\n}\n\nint dm_bitset_new(struct dm_disk_bitset *info, dm_block_t *root,\n\t\t  uint32_t size, bit_value_fn fn, void *context)\n{\n\tstruct packer_context p;\n\n\tp.fn = fn;\n\tp.nr_bits = size;\n\tp.context = context;\n\n\treturn dm_array_new(&info->array_info, root, dm_div_up(size, 64), pack_bits, &p);\n}\nEXPORT_SYMBOL_GPL(dm_bitset_new);\n\nint dm_bitset_resize(struct dm_disk_bitset *info, dm_block_t root,\n\t\t     uint32_t old_nr_entries, uint32_t new_nr_entries,\n\t\t     bool default_value, dm_block_t *new_root)\n{\n\tuint32_t old_blocks = dm_div_up(old_nr_entries, BITS_PER_ARRAY_ENTRY);\n\tuint32_t new_blocks = dm_div_up(new_nr_entries, BITS_PER_ARRAY_ENTRY);\n\t__le64 value = default_value ? cpu_to_le64(~0) : cpu_to_le64(0);\n\n\t__dm_bless_for_disk(&value);\n\treturn dm_array_resize(&info->array_info, root, old_blocks, new_blocks,\n\t\t\t       &value, new_root);\n}\nEXPORT_SYMBOL_GPL(dm_bitset_resize);\n\nint dm_bitset_del(struct dm_disk_bitset *info, dm_block_t root)\n{\n\treturn dm_array_del(&info->array_info, root);\n}\nEXPORT_SYMBOL_GPL(dm_bitset_del);\n\nint dm_bitset_flush(struct dm_disk_bitset *info, dm_block_t root,\n\t\t    dm_block_t *new_root)\n{\n\tint r;\n\t__le64 value;\n\n\tif (!info->current_index_set || !info->dirty)\n\t\treturn 0;\n\n\tvalue = cpu_to_le64(info->current_bits);\n\n\t__dm_bless_for_disk(&value);\n\tr = dm_array_set_value(&info->array_info, root, info->current_index,\n\t\t\t       &value, new_root);\n\tif (r)\n\t\treturn r;\n\n\tinfo->current_index_set = false;\n\tinfo->dirty = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dm_bitset_flush);\n\nstatic int read_bits(struct dm_disk_bitset *info, dm_block_t root,\n\t\t     uint32_t array_index)\n{\n\tint r;\n\t__le64 value;\n\n\tr = dm_array_get_value(&info->array_info, root, array_index, &value);\n\tif (r)\n\t\treturn r;\n\n\tinfo->current_bits = le64_to_cpu(value);\n\tinfo->current_index_set = true;\n\tinfo->current_index = array_index;\n\tinfo->dirty = false;\n\n\treturn 0;\n}\n\nstatic int get_array_entry(struct dm_disk_bitset *info, dm_block_t root,\n\t\t\t   uint32_t index, dm_block_t *new_root)\n{\n\tint r;\n\tunsigned int array_index = index / BITS_PER_ARRAY_ENTRY;\n\n\tif (info->current_index_set) {\n\t\tif (info->current_index == array_index)\n\t\t\treturn 0;\n\n\t\tr = dm_bitset_flush(info, root, new_root);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn read_bits(info, root, array_index);\n}\n\nint dm_bitset_set_bit(struct dm_disk_bitset *info, dm_block_t root,\n\t\t      uint32_t index, dm_block_t *new_root)\n{\n\tint r;\n\tunsigned int b = index % BITS_PER_ARRAY_ENTRY;\n\n\tr = get_array_entry(info, root, index, new_root);\n\tif (r)\n\t\treturn r;\n\n\tset_bit(b, (unsigned long *) &info->current_bits);\n\tinfo->dirty = true;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dm_bitset_set_bit);\n\nint dm_bitset_clear_bit(struct dm_disk_bitset *info, dm_block_t root,\n\t\t\tuint32_t index, dm_block_t *new_root)\n{\n\tint r;\n\tunsigned int b = index % BITS_PER_ARRAY_ENTRY;\n\n\tr = get_array_entry(info, root, index, new_root);\n\tif (r)\n\t\treturn r;\n\n\tclear_bit(b, (unsigned long *) &info->current_bits);\n\tinfo->dirty = true;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dm_bitset_clear_bit);\n\nint dm_bitset_test_bit(struct dm_disk_bitset *info, dm_block_t root,\n\t\t       uint32_t index, dm_block_t *new_root, bool *result)\n{\n\tint r;\n\tunsigned int b = index % BITS_PER_ARRAY_ENTRY;\n\n\tr = get_array_entry(info, root, index, new_root);\n\tif (r)\n\t\treturn r;\n\n\t*result = test_bit(b, (unsigned long *) &info->current_bits);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dm_bitset_test_bit);\n\nstatic int cursor_next_array_entry(struct dm_bitset_cursor *c)\n{\n\tint r;\n\t__le64 *value;\n\n\tr = dm_array_cursor_next(&c->cursor);\n\tif (r)\n\t\treturn r;\n\n\tdm_array_cursor_get_value(&c->cursor, (void **) &value);\n\tc->array_index++;\n\tc->bit_index = 0;\n\tc->current_bits = le64_to_cpu(*value);\n\treturn 0;\n}\n\nint dm_bitset_cursor_begin(struct dm_disk_bitset *info,\n\t\t\t   dm_block_t root, uint32_t nr_entries,\n\t\t\t   struct dm_bitset_cursor *c)\n{\n\tint r;\n\t__le64 *value;\n\n\tif (!nr_entries)\n\t\treturn -ENODATA;\n\n\tc->info = info;\n\tc->entries_remaining = nr_entries;\n\n\tr = dm_array_cursor_begin(&info->array_info, root, &c->cursor);\n\tif (r)\n\t\treturn r;\n\n\tdm_array_cursor_get_value(&c->cursor, (void **) &value);\n\tc->array_index = 0;\n\tc->bit_index = 0;\n\tc->current_bits = le64_to_cpu(*value);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_bitset_cursor_begin);\n\nvoid dm_bitset_cursor_end(struct dm_bitset_cursor *c)\n{\n\treturn dm_array_cursor_end(&c->cursor);\n}\nEXPORT_SYMBOL_GPL(dm_bitset_cursor_end);\n\nint dm_bitset_cursor_next(struct dm_bitset_cursor *c)\n{\n\tint r = 0;\n\n\tif (!c->entries_remaining)\n\t\treturn -ENODATA;\n\n\tc->entries_remaining--;\n\tif (++c->bit_index > 63)\n\t\tr = cursor_next_array_entry(c);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_bitset_cursor_next);\n\nint dm_bitset_cursor_skip(struct dm_bitset_cursor *c, uint32_t count)\n{\n\tint r;\n\t__le64 *value;\n\tuint32_t nr_array_skip;\n\tuint32_t remaining_in_word = 64 - c->bit_index;\n\n\tif (c->entries_remaining < count)\n\t\treturn -ENODATA;\n\n\tif (count < remaining_in_word) {\n\t\tc->bit_index += count;\n\t\tc->entries_remaining -= count;\n\t\treturn 0;\n\n\t} else {\n\t\tc->entries_remaining -= remaining_in_word;\n\t\tcount -= remaining_in_word;\n\t}\n\n\tnr_array_skip = (count / 64) + 1;\n\tr = dm_array_cursor_skip(&c->cursor, nr_array_skip);\n\tif (r)\n\t\treturn r;\n\n\tdm_array_cursor_get_value(&c->cursor, (void **) &value);\n\tc->entries_remaining -= count;\n\tc->array_index += nr_array_skip;\n\tc->bit_index = count & 63;\n\tc->current_bits = le64_to_cpu(*value);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dm_bitset_cursor_skip);\n\nbool dm_bitset_cursor_get_value(struct dm_bitset_cursor *c)\n{\n\treturn test_bit(c->bit_index, (unsigned long *) &c->current_bits);\n}\nEXPORT_SYMBOL_GPL(dm_bitset_cursor_get_value);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}