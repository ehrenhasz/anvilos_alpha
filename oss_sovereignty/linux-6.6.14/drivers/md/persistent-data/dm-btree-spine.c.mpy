{
  "module_name": "dm-btree-spine.c",
  "hash_id": "37049f850fdb6c601c99b9fe50e60530904f6cc2124a704db668058f14d548e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/persistent-data/dm-btree-spine.c",
  "human_readable_source": "\n \n\n#include \"dm-btree-internal.h\"\n#include \"dm-transaction-manager.h\"\n\n#include <linux/device-mapper.h>\n\n#define DM_MSG_PREFIX \"btree spine\"\n\n \n\n#define BTREE_CSUM_XOR 121107\n\nstatic void node_prepare_for_write(struct dm_block_validator *v,\n\t\t\t\t   struct dm_block *b,\n\t\t\t\t   size_t block_size)\n{\n\tstruct btree_node *n = dm_block_data(b);\n\tstruct node_header *h = &n->header;\n\n\th->blocknr = cpu_to_le64(dm_block_location(b));\n\th->csum = cpu_to_le32(dm_bm_checksum(&h->flags,\n\t\t\t\t\t     block_size - sizeof(__le32),\n\t\t\t\t\t     BTREE_CSUM_XOR));\n}\n\nstatic int node_check(struct dm_block_validator *v,\n\t\t      struct dm_block *b,\n\t\t      size_t block_size)\n{\n\tstruct btree_node *n = dm_block_data(b);\n\tstruct node_header *h = &n->header;\n\tsize_t value_size;\n\t__le32 csum_disk;\n\tuint32_t flags, nr_entries, max_entries;\n\n\tif (dm_block_location(b) != le64_to_cpu(h->blocknr)) {\n\t\tDMERR_LIMIT(\"%s failed: blocknr %llu != wanted %llu\", __func__,\n\t\t\t    le64_to_cpu(h->blocknr), dm_block_location(b));\n\t\treturn -ENOTBLK;\n\t}\n\n\tcsum_disk = cpu_to_le32(dm_bm_checksum(&h->flags,\n\t\t\t\t\t       block_size - sizeof(__le32),\n\t\t\t\t\t       BTREE_CSUM_XOR));\n\tif (csum_disk != h->csum) {\n\t\tDMERR_LIMIT(\"%s failed: csum %u != wanted %u\", __func__,\n\t\t\t    le32_to_cpu(csum_disk), le32_to_cpu(h->csum));\n\t\treturn -EILSEQ;\n\t}\n\n\tnr_entries = le32_to_cpu(h->nr_entries);\n\tmax_entries = le32_to_cpu(h->max_entries);\n\tvalue_size = le32_to_cpu(h->value_size);\n\n\tif (sizeof(struct node_header) +\n\t    (sizeof(__le64) + value_size) * max_entries > block_size) {\n\t\tDMERR_LIMIT(\"%s failed: max_entries too large\", __func__);\n\t\treturn -EILSEQ;\n\t}\n\n\tif (nr_entries > max_entries) {\n\t\tDMERR_LIMIT(\"%s failed: too many entries\", __func__);\n\t\treturn -EILSEQ;\n\t}\n\n\t \n\tflags = le32_to_cpu(h->flags);\n\tif (!(flags & INTERNAL_NODE) && !(flags & LEAF_NODE)) {\n\t\tDMERR_LIMIT(\"%s failed: node is neither INTERNAL or LEAF\", __func__);\n\t\treturn -EILSEQ;\n\t}\n\n\treturn 0;\n}\n\nstruct dm_block_validator btree_node_validator = {\n\t.name = \"btree_node\",\n\t.prepare_for_write = node_prepare_for_write,\n\t.check = node_check\n};\n\n \n\nint bn_read_lock(struct dm_btree_info *info, dm_block_t b,\n\t\t struct dm_block **result)\n{\n\treturn dm_tm_read_lock(info->tm, b, &btree_node_validator, result);\n}\n\nstatic int bn_shadow(struct dm_btree_info *info, dm_block_t orig,\n\t      struct dm_btree_value_type *vt,\n\t      struct dm_block **result)\n{\n\tint r, inc;\n\n\tr = dm_tm_shadow_block(info->tm, orig, &btree_node_validator,\n\t\t\t       result, &inc);\n\tif (!r && inc)\n\t\tinc_children(info->tm, dm_block_data(*result), vt);\n\n\treturn r;\n}\n\nint new_block(struct dm_btree_info *info, struct dm_block **result)\n{\n\treturn dm_tm_new_block(info->tm, &btree_node_validator, result);\n}\n\nvoid unlock_block(struct dm_btree_info *info, struct dm_block *b)\n{\n\tdm_tm_unlock(info->tm, b);\n}\n\n \n\nvoid init_ro_spine(struct ro_spine *s, struct dm_btree_info *info)\n{\n\ts->info = info;\n\ts->count = 0;\n\ts->nodes[0] = NULL;\n\ts->nodes[1] = NULL;\n}\n\nvoid exit_ro_spine(struct ro_spine *s)\n{\n\tint i;\n\n\tfor (i = 0; i < s->count; i++)\n\t\tunlock_block(s->info, s->nodes[i]);\n}\n\nint ro_step(struct ro_spine *s, dm_block_t new_child)\n{\n\tint r;\n\n\tif (s->count == 2) {\n\t\tunlock_block(s->info, s->nodes[0]);\n\t\ts->nodes[0] = s->nodes[1];\n\t\ts->count--;\n\t}\n\n\tr = bn_read_lock(s->info, new_child, s->nodes + s->count);\n\tif (!r)\n\t\ts->count++;\n\n\treturn r;\n}\n\nvoid ro_pop(struct ro_spine *s)\n{\n\tBUG_ON(!s->count);\n\t--s->count;\n\tunlock_block(s->info, s->nodes[s->count]);\n}\n\nstruct btree_node *ro_node(struct ro_spine *s)\n{\n\tstruct dm_block *block;\n\n\tBUG_ON(!s->count);\n\tblock = s->nodes[s->count - 1];\n\n\treturn dm_block_data(block);\n}\n\n \n\nvoid init_shadow_spine(struct shadow_spine *s, struct dm_btree_info *info)\n{\n\ts->info = info;\n\ts->count = 0;\n}\n\nvoid exit_shadow_spine(struct shadow_spine *s)\n{\n\tint i;\n\n\tfor (i = 0; i < s->count; i++)\n\t\tunlock_block(s->info, s->nodes[i]);\n}\n\nint shadow_step(struct shadow_spine *s, dm_block_t b,\n\t\tstruct dm_btree_value_type *vt)\n{\n\tint r;\n\n\tif (s->count == 2) {\n\t\tunlock_block(s->info, s->nodes[0]);\n\t\ts->nodes[0] = s->nodes[1];\n\t\ts->count--;\n\t}\n\n\tr = bn_shadow(s->info, b, vt, s->nodes + s->count);\n\tif (!r) {\n\t\tif (!s->count)\n\t\t\ts->root = dm_block_location(s->nodes[0]);\n\n\t\ts->count++;\n\t}\n\n\treturn r;\n}\n\nstruct dm_block *shadow_current(struct shadow_spine *s)\n{\n\tBUG_ON(!s->count);\n\n\treturn s->nodes[s->count - 1];\n}\n\nstruct dm_block *shadow_parent(struct shadow_spine *s)\n{\n\tBUG_ON(s->count != 2);\n\n\treturn s->count == 2 ? s->nodes[0] : NULL;\n}\n\nint shadow_has_parent(struct shadow_spine *s)\n{\n\treturn s->count >= 2;\n}\n\ndm_block_t shadow_root(struct shadow_spine *s)\n{\n\treturn s->root;\n}\n\nstatic void le64_inc(void *context, const void *value_le, unsigned int count)\n{\n\tdm_tm_with_runs(context, value_le, count, dm_tm_inc_range);\n}\n\nstatic void le64_dec(void *context, const void *value_le, unsigned int count)\n{\n\tdm_tm_with_runs(context, value_le, count, dm_tm_dec_range);\n}\n\nstatic int le64_equal(void *context, const void *value1_le, const void *value2_le)\n{\n\t__le64 v1_le, v2_le;\n\n\tmemcpy(&v1_le, value1_le, sizeof(v1_le));\n\tmemcpy(&v2_le, value2_le, sizeof(v2_le));\n\treturn v1_le == v2_le;\n}\n\nvoid init_le64_type(struct dm_transaction_manager *tm,\n\t\t    struct dm_btree_value_type *vt)\n{\n\tvt->context = tm;\n\tvt->size = sizeof(__le64);\n\tvt->inc = le64_inc;\n\tvt->dec = le64_dec;\n\tvt->equal = le64_equal;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}