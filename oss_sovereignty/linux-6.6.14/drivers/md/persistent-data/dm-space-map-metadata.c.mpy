{
  "module_name": "dm-space-map-metadata.c",
  "hash_id": "40dd25267f4bc34d2ff353728ac7d27f1cda0dd60e3805518cb0b0c37ad1ed17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/persistent-data/dm-space-map-metadata.c",
  "human_readable_source": "\n \n\n#include \"dm-space-map.h\"\n#include \"dm-space-map-common.h\"\n#include \"dm-space-map-metadata.h\"\n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/device-mapper.h>\n#include <linux/kernel.h>\n\n#define DM_MSG_PREFIX \"space map metadata\"\n\n \n\n \nstruct threshold {\n\tbool threshold_set;\n\tbool value_set;\n\tdm_block_t threshold;\n\tdm_block_t current_value;\n\tdm_sm_threshold_fn fn;\n\tvoid *context;\n};\n\nstatic void threshold_init(struct threshold *t)\n{\n\tt->threshold_set = false;\n\tt->value_set = false;\n}\n\nstatic void set_threshold(struct threshold *t, dm_block_t value,\n\t\t\t  dm_sm_threshold_fn fn, void *context)\n{\n\tt->threshold_set = true;\n\tt->threshold = value;\n\tt->fn = fn;\n\tt->context = context;\n}\n\nstatic bool below_threshold(struct threshold *t, dm_block_t value)\n{\n\treturn t->threshold_set && value <= t->threshold;\n}\n\nstatic bool threshold_already_triggered(struct threshold *t)\n{\n\treturn t->value_set && below_threshold(t, t->current_value);\n}\n\nstatic void check_threshold(struct threshold *t, dm_block_t value)\n{\n\tif (below_threshold(t, value) &&\n\t    !threshold_already_triggered(t))\n\t\tt->fn(t->context);\n\n\tt->value_set = true;\n\tt->current_value = value;\n}\n\n \n\n \n\n \n#define MAX_RECURSIVE_ALLOCATIONS 1024\n\nenum block_op_type {\n\tBOP_INC,\n\tBOP_DEC\n};\n\nstruct block_op {\n\tenum block_op_type type;\n\tdm_block_t b;\n\tdm_block_t e;\n};\n\nstruct bop_ring_buffer {\n\tunsigned int begin;\n\tunsigned int end;\n\tstruct block_op bops[MAX_RECURSIVE_ALLOCATIONS + 1];\n};\n\nstatic void brb_init(struct bop_ring_buffer *brb)\n{\n\tbrb->begin = 0;\n\tbrb->end = 0;\n}\n\nstatic bool brb_empty(struct bop_ring_buffer *brb)\n{\n\treturn brb->begin == brb->end;\n}\n\nstatic unsigned int brb_next(struct bop_ring_buffer *brb, unsigned int old)\n{\n\tunsigned int r = old + 1;\n\n\treturn r >= ARRAY_SIZE(brb->bops) ? 0 : r;\n}\n\nstatic int brb_push(struct bop_ring_buffer *brb,\n\t\t    enum block_op_type type, dm_block_t b, dm_block_t e)\n{\n\tstruct block_op *bop;\n\tunsigned int next = brb_next(brb, brb->end);\n\n\t \n\tif (next == brb->begin)\n\t\treturn -ENOMEM;\n\n\tbop = brb->bops + brb->end;\n\tbop->type = type;\n\tbop->b = b;\n\tbop->e = e;\n\n\tbrb->end = next;\n\n\treturn 0;\n}\n\nstatic int brb_peek(struct bop_ring_buffer *brb, struct block_op *result)\n{\n\tstruct block_op *bop;\n\n\tif (brb_empty(brb))\n\t\treturn -ENODATA;\n\n\tbop = brb->bops + brb->begin;\n\tmemcpy(result, bop, sizeof(*result));\n\treturn 0;\n}\n\nstatic int brb_pop(struct bop_ring_buffer *brb)\n{\n\tif (brb_empty(brb))\n\t\treturn -ENODATA;\n\n\tbrb->begin = brb_next(brb, brb->begin);\n\n\treturn 0;\n}\n\n \n\nstruct sm_metadata {\n\tstruct dm_space_map sm;\n\n\tstruct ll_disk ll;\n\tstruct ll_disk old_ll;\n\n\tdm_block_t begin;\n\n\tunsigned int recursion_count;\n\tunsigned int allocated_this_transaction;\n\tstruct bop_ring_buffer uncommitted;\n\n\tstruct threshold threshold;\n};\n\nstatic int add_bop(struct sm_metadata *smm, enum block_op_type type, dm_block_t b, dm_block_t e)\n{\n\tint r = brb_push(&smm->uncommitted, type, b, e);\n\n\tif (r) {\n\t\tDMERR(\"too many recursive allocations\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int commit_bop(struct sm_metadata *smm, struct block_op *op)\n{\n\tint r = 0;\n\tint32_t nr_allocations;\n\n\tswitch (op->type) {\n\tcase BOP_INC:\n\t\tr = sm_ll_inc(&smm->ll, op->b, op->e, &nr_allocations);\n\t\tbreak;\n\n\tcase BOP_DEC:\n\t\tr = sm_ll_dec(&smm->ll, op->b, op->e, &nr_allocations);\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic void in(struct sm_metadata *smm)\n{\n\tsmm->recursion_count++;\n}\n\nstatic int apply_bops(struct sm_metadata *smm)\n{\n\tint r = 0;\n\n\twhile (!brb_empty(&smm->uncommitted)) {\n\t\tstruct block_op bop;\n\n\t\tr = brb_peek(&smm->uncommitted, &bop);\n\t\tif (r) {\n\t\t\tDMERR(\"bug in bop ring buffer\");\n\t\t\tbreak;\n\t\t}\n\n\t\tr = commit_bop(smm, &bop);\n\t\tif (r)\n\t\t\tbreak;\n\n\t\tbrb_pop(&smm->uncommitted);\n\t}\n\n\treturn r;\n}\n\nstatic int out(struct sm_metadata *smm)\n{\n\tint r = 0;\n\n\t \n\tif (!smm->recursion_count) {\n\t\tDMERR(\"lost track of recursion depth\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (smm->recursion_count == 1)\n\t\tr = apply_bops(smm);\n\n\tsmm->recursion_count--;\n\n\treturn r;\n}\n\n \nstatic int combine_errors(int r1, int r2)\n{\n\treturn r1 ? r1 : r2;\n}\n\nstatic int recursing(struct sm_metadata *smm)\n{\n\treturn smm->recursion_count;\n}\n\nstatic void sm_metadata_destroy(struct dm_space_map *sm)\n{\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\tkfree(smm);\n}\n\nstatic int sm_metadata_get_nr_blocks(struct dm_space_map *sm, dm_block_t *count)\n{\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\t*count = smm->ll.nr_blocks;\n\n\treturn 0;\n}\n\nstatic int sm_metadata_get_nr_free(struct dm_space_map *sm, dm_block_t *count)\n{\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\t*count = smm->old_ll.nr_blocks - smm->old_ll.nr_allocated -\n\t\t smm->allocated_this_transaction;\n\n\treturn 0;\n}\n\nstatic int sm_metadata_get_count(struct dm_space_map *sm, dm_block_t b,\n\t\t\t\t uint32_t *result)\n{\n\tint r;\n\tunsigned int i;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\tunsigned int adjustment = 0;\n\n\t \n\tfor (i = smm->uncommitted.begin;\n\t     i != smm->uncommitted.end;\n\t     i = brb_next(&smm->uncommitted, i)) {\n\t\tstruct block_op *op = smm->uncommitted.bops + i;\n\n\t\tif (b < op->b || b >= op->e)\n\t\t\tcontinue;\n\n\t\tswitch (op->type) {\n\t\tcase BOP_INC:\n\t\t\tadjustment++;\n\t\t\tbreak;\n\n\t\tcase BOP_DEC:\n\t\t\tadjustment--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tr = sm_ll_lookup(&smm->ll, b, result);\n\tif (r)\n\t\treturn r;\n\n\t*result += adjustment;\n\n\treturn 0;\n}\n\nstatic int sm_metadata_count_is_more_than_one(struct dm_space_map *sm,\n\t\t\t\t\t      dm_block_t b, int *result)\n{\n\tint r, adjustment = 0;\n\tunsigned int i;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\tuint32_t rc;\n\n\t \n\tfor (i = smm->uncommitted.begin;\n\t     i != smm->uncommitted.end;\n\t     i = brb_next(&smm->uncommitted, i)) {\n\n\t\tstruct block_op *op = smm->uncommitted.bops + i;\n\n\t\tif (b < op->b || b >= op->e)\n\t\t\tcontinue;\n\n\t\tswitch (op->type) {\n\t\tcase BOP_INC:\n\t\t\tadjustment++;\n\t\t\tbreak;\n\n\t\tcase BOP_DEC:\n\t\t\tadjustment--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (adjustment > 1) {\n\t\t*result = 1;\n\t\treturn 0;\n\t}\n\n\tr = sm_ll_lookup_bitmap(&smm->ll, b, &rc);\n\tif (r)\n\t\treturn r;\n\n\tif (rc == 3)\n\t\t \n\t\t*result = 1;\n\telse\n\t\t*result = rc + adjustment > 1;\n\n\treturn 0;\n}\n\nstatic int sm_metadata_set_count(struct dm_space_map *sm, dm_block_t b,\n\t\t\t\t uint32_t count)\n{\n\tint r, r2;\n\tint32_t nr_allocations;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\tif (smm->recursion_count) {\n\t\tDMERR(\"cannot recurse set_count()\");\n\t\treturn -EINVAL;\n\t}\n\n\tin(smm);\n\tr = sm_ll_insert(&smm->ll, b, count, &nr_allocations);\n\tr2 = out(smm);\n\n\treturn combine_errors(r, r2);\n}\n\nstatic int sm_metadata_inc_blocks(struct dm_space_map *sm, dm_block_t b, dm_block_t e)\n{\n\tint r, r2 = 0;\n\tint32_t nr_allocations;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\tif (recursing(smm)) {\n\t\tr = add_bop(smm, BOP_INC, b, e);\n\t\tif (r)\n\t\t\treturn r;\n\t} else {\n\t\tin(smm);\n\t\tr = sm_ll_inc(&smm->ll, b, e, &nr_allocations);\n\t\tr2 = out(smm);\n\t}\n\n\treturn combine_errors(r, r2);\n}\n\nstatic int sm_metadata_dec_blocks(struct dm_space_map *sm, dm_block_t b, dm_block_t e)\n{\n\tint r, r2 = 0;\n\tint32_t nr_allocations;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\tif (recursing(smm))\n\t\tr = add_bop(smm, BOP_DEC, b, e);\n\telse {\n\t\tin(smm);\n\t\tr = sm_ll_dec(&smm->ll, b, e, &nr_allocations);\n\t\tr2 = out(smm);\n\t}\n\n\treturn combine_errors(r, r2);\n}\n\nstatic int sm_metadata_new_block_(struct dm_space_map *sm, dm_block_t *b)\n{\n\tint r, r2 = 0;\n\tint32_t nr_allocations;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\t \n\tr = sm_ll_find_common_free_block(&smm->old_ll, &smm->ll, smm->begin, smm->ll.nr_blocks, b);\n\tif (r == -ENOSPC) {\n\t\t \n\t\tr = sm_ll_find_common_free_block(&smm->old_ll, &smm->ll, 0, smm->begin, b);\n\t}\n\n\tif (r)\n\t\treturn r;\n\n\tsmm->begin = *b + 1;\n\n\tif (recursing(smm))\n\t\tr = add_bop(smm, BOP_INC, *b, *b + 1);\n\telse {\n\t\tin(smm);\n\t\tr = sm_ll_inc(&smm->ll, *b, *b + 1, &nr_allocations);\n\t\tr2 = out(smm);\n\t}\n\n\tif (!r)\n\t\tsmm->allocated_this_transaction++;\n\n\treturn combine_errors(r, r2);\n}\n\nstatic int sm_metadata_new_block(struct dm_space_map *sm, dm_block_t *b)\n{\n\tdm_block_t count;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\tint r = sm_metadata_new_block_(sm, b);\n\n\tif (r) {\n\t\tDMERR_LIMIT(\"unable to allocate new metadata block\");\n\t\treturn r;\n\t}\n\n\tr = sm_metadata_get_nr_free(sm, &count);\n\tif (r) {\n\t\tDMERR_LIMIT(\"couldn't get free block count\");\n\t\treturn r;\n\t}\n\n\tcheck_threshold(&smm->threshold, count);\n\n\treturn r;\n}\n\nstatic int sm_metadata_commit(struct dm_space_map *sm)\n{\n\tint r;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\tr = sm_ll_commit(&smm->ll);\n\tif (r)\n\t\treturn r;\n\n\tmemcpy(&smm->old_ll, &smm->ll, sizeof(smm->old_ll));\n\tsmm->allocated_this_transaction = 0;\n\n\treturn 0;\n}\n\nstatic int sm_metadata_register_threshold_callback(struct dm_space_map *sm,\n\t\t\t\t\t\t   dm_block_t threshold,\n\t\t\t\t\t\t   dm_sm_threshold_fn fn,\n\t\t\t\t\t\t   void *context)\n{\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\tset_threshold(&smm->threshold, threshold, fn, context);\n\n\treturn 0;\n}\n\nstatic int sm_metadata_root_size(struct dm_space_map *sm, size_t *result)\n{\n\t*result = sizeof(struct disk_sm_root);\n\n\treturn 0;\n}\n\nstatic int sm_metadata_copy_root(struct dm_space_map *sm, void *where_le, size_t max)\n{\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\tstruct disk_sm_root root_le;\n\n\troot_le.nr_blocks = cpu_to_le64(smm->ll.nr_blocks);\n\troot_le.nr_allocated = cpu_to_le64(smm->ll.nr_allocated);\n\troot_le.bitmap_root = cpu_to_le64(smm->ll.bitmap_root);\n\troot_le.ref_count_root = cpu_to_le64(smm->ll.ref_count_root);\n\n\tif (max < sizeof(root_le))\n\t\treturn -ENOSPC;\n\n\tmemcpy(where_le, &root_le, sizeof(root_le));\n\n\treturn 0;\n}\n\nstatic int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks);\n\nstatic const struct dm_space_map ops = {\n\t.destroy = sm_metadata_destroy,\n\t.extend = sm_metadata_extend,\n\t.get_nr_blocks = sm_metadata_get_nr_blocks,\n\t.get_nr_free = sm_metadata_get_nr_free,\n\t.get_count = sm_metadata_get_count,\n\t.count_is_more_than_one = sm_metadata_count_is_more_than_one,\n\t.set_count = sm_metadata_set_count,\n\t.inc_blocks = sm_metadata_inc_blocks,\n\t.dec_blocks = sm_metadata_dec_blocks,\n\t.new_block = sm_metadata_new_block,\n\t.commit = sm_metadata_commit,\n\t.root_size = sm_metadata_root_size,\n\t.copy_root = sm_metadata_copy_root,\n\t.register_threshold_callback = sm_metadata_register_threshold_callback\n};\n\n \n\n \nstatic void sm_bootstrap_destroy(struct dm_space_map *sm)\n{\n}\n\nstatic int sm_bootstrap_extend(struct dm_space_map *sm, dm_block_t extra_blocks)\n{\n\tDMERR(\"bootstrap doesn't support extend\");\n\n\treturn -EINVAL;\n}\n\nstatic int sm_bootstrap_get_nr_blocks(struct dm_space_map *sm, dm_block_t *count)\n{\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\t*count = smm->ll.nr_blocks;\n\n\treturn 0;\n}\n\nstatic int sm_bootstrap_get_nr_free(struct dm_space_map *sm, dm_block_t *count)\n{\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\t*count = smm->ll.nr_blocks - smm->begin;\n\n\treturn 0;\n}\n\nstatic int sm_bootstrap_get_count(struct dm_space_map *sm, dm_block_t b,\n\t\t\t\t  uint32_t *result)\n{\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\t*result = (b < smm->begin) ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int sm_bootstrap_count_is_more_than_one(struct dm_space_map *sm,\n\t\t\t\t\t       dm_block_t b, int *result)\n{\n\t*result = 0;\n\n\treturn 0;\n}\n\nstatic int sm_bootstrap_set_count(struct dm_space_map *sm, dm_block_t b,\n\t\t\t\t  uint32_t count)\n{\n\tDMERR(\"bootstrap doesn't support set_count\");\n\n\treturn -EINVAL;\n}\n\nstatic int sm_bootstrap_new_block(struct dm_space_map *sm, dm_block_t *b)\n{\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\t \n\tif (smm->begin == smm->ll.nr_blocks)\n\t\treturn -ENOSPC;\n\n\t*b = smm->begin++;\n\n\treturn 0;\n}\n\nstatic int sm_bootstrap_inc_blocks(struct dm_space_map *sm, dm_block_t b, dm_block_t e)\n{\n\tint r;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\tr = add_bop(smm, BOP_INC, b, e);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int sm_bootstrap_dec_blocks(struct dm_space_map *sm, dm_block_t b, dm_block_t e)\n{\n\tint r;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\tr = add_bop(smm, BOP_DEC, b, e);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int sm_bootstrap_commit(struct dm_space_map *sm)\n{\n\treturn 0;\n}\n\nstatic int sm_bootstrap_root_size(struct dm_space_map *sm, size_t *result)\n{\n\tDMERR(\"bootstrap doesn't support root_size\");\n\n\treturn -EINVAL;\n}\n\nstatic int sm_bootstrap_copy_root(struct dm_space_map *sm, void *where,\n\t\t\t\t  size_t max)\n{\n\tDMERR(\"bootstrap doesn't support copy_root\");\n\n\treturn -EINVAL;\n}\n\nstatic const struct dm_space_map bootstrap_ops = {\n\t.destroy = sm_bootstrap_destroy,\n\t.extend = sm_bootstrap_extend,\n\t.get_nr_blocks = sm_bootstrap_get_nr_blocks,\n\t.get_nr_free = sm_bootstrap_get_nr_free,\n\t.get_count = sm_bootstrap_get_count,\n\t.count_is_more_than_one = sm_bootstrap_count_is_more_than_one,\n\t.set_count = sm_bootstrap_set_count,\n\t.inc_blocks = sm_bootstrap_inc_blocks,\n\t.dec_blocks = sm_bootstrap_dec_blocks,\n\t.new_block = sm_bootstrap_new_block,\n\t.commit = sm_bootstrap_commit,\n\t.root_size = sm_bootstrap_root_size,\n\t.copy_root = sm_bootstrap_copy_root,\n\t.register_threshold_callback = NULL\n};\n\n \n\nstatic int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)\n{\n\tint r;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\tdm_block_t old_len = smm->ll.nr_blocks;\n\n\t \n\tsmm->begin = old_len;\n\tmemcpy(sm, &bootstrap_ops, sizeof(*sm));\n\n\t \n\tr = sm_ll_extend(&smm->ll, extra_blocks);\n\tif (r)\n\t\tgoto out;\n\n\t \n\tdo {\n\t\tr = add_bop(smm, BOP_INC, old_len, smm->begin);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\told_len = smm->begin;\n\n\t\tr = apply_bops(smm);\n\t\tif (r) {\n\t\t\tDMERR(\"%s: apply_bops failed\", __func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = sm_ll_commit(&smm->ll);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t} while (old_len != smm->begin);\n\nout:\n\t \n\tmemcpy(sm, &ops, sizeof(*sm));\n\treturn r;\n}\n\n \n\nstruct dm_space_map *dm_sm_metadata_init(void)\n{\n\tstruct sm_metadata *smm;\n\n\tsmm = kmalloc(sizeof(*smm), GFP_KERNEL);\n\tif (!smm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(&smm->sm, &ops, sizeof(smm->sm));\n\n\treturn &smm->sm;\n}\n\nint dm_sm_metadata_create(struct dm_space_map *sm,\n\t\t\t  struct dm_transaction_manager *tm,\n\t\t\t  dm_block_t nr_blocks,\n\t\t\t  dm_block_t superblock)\n{\n\tint r;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\tsmm->begin = superblock + 1;\n\tsmm->recursion_count = 0;\n\tsmm->allocated_this_transaction = 0;\n\tbrb_init(&smm->uncommitted);\n\tthreshold_init(&smm->threshold);\n\n\tmemcpy(&smm->sm, &bootstrap_ops, sizeof(smm->sm));\n\n\tr = sm_ll_new_metadata(&smm->ll, tm);\n\tif (!r) {\n\t\tif (nr_blocks > DM_SM_METADATA_MAX_BLOCKS)\n\t\t\tnr_blocks = DM_SM_METADATA_MAX_BLOCKS;\n\t\tr = sm_ll_extend(&smm->ll, nr_blocks);\n\t}\n\tmemcpy(&smm->sm, &ops, sizeof(smm->sm));\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = add_bop(smm, BOP_INC, superblock, smm->begin);\n\tif (r)\n\t\treturn r;\n\n\tr = apply_bops(smm);\n\tif (r) {\n\t\tDMERR(\"%s: apply_bops failed\", __func__);\n\t\treturn r;\n\t}\n\n\treturn sm_metadata_commit(sm);\n}\n\nint dm_sm_metadata_open(struct dm_space_map *sm,\n\t\t\tstruct dm_transaction_manager *tm,\n\t\t\tvoid *root_le, size_t len)\n{\n\tint r;\n\tstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\n\n\tr = sm_ll_open_metadata(&smm->ll, tm, root_le, len);\n\tif (r)\n\t\treturn r;\n\n\tsmm->begin = 0;\n\tsmm->recursion_count = 0;\n\tsmm->allocated_this_transaction = 0;\n\tbrb_init(&smm->uncommitted);\n\tthreshold_init(&smm->threshold);\n\n\tmemcpy(&smm->old_ll, &smm->ll, sizeof(smm->old_ll));\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}