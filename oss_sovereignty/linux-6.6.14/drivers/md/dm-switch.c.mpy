{
  "module_name": "dm-switch.c",
  "hash_id": "ba64dbf4533f47205abd429bec41b1658aedc230cf16a751b26067bbeaada240",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-switch.c",
  "human_readable_source": "\n \n\n#include <linux/device-mapper.h>\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n\n#define DM_MSG_PREFIX \"switch\"\n\n \ntypedef unsigned long region_table_slot_t;\n\n \nstruct switch_path {\n\tstruct dm_dev *dmdev;\n\tsector_t start;\n};\n\n \nstruct switch_ctx {\n\tstruct dm_target *ti;\n\n\tunsigned int nr_paths;\t\t \n\n\tunsigned int region_size;\t\t \n\tunsigned long nr_regions;\t \n\tsigned char region_size_bits;\t \n\n\tunsigned char region_table_entry_bits;\t \n\tunsigned char region_entries_per_slot;\t \n\tsigned char region_entries_per_slot_bits;\t \n\n\tregion_table_slot_t *region_table;\t \n\n\t \n\tstruct switch_path path_list[];\n};\n\nstatic struct switch_ctx *alloc_switch_ctx(struct dm_target *ti, unsigned int nr_paths,\n\t\t\t\t\t   unsigned int region_size)\n{\n\tstruct switch_ctx *sctx;\n\n\tsctx = kzalloc(struct_size(sctx, path_list, nr_paths), GFP_KERNEL);\n\tif (!sctx)\n\t\treturn NULL;\n\n\tsctx->ti = ti;\n\tsctx->region_size = region_size;\n\n\tti->private = sctx;\n\n\treturn sctx;\n}\n\nstatic int alloc_region_table(struct dm_target *ti, unsigned int nr_paths)\n{\n\tstruct switch_ctx *sctx = ti->private;\n\tsector_t nr_regions = ti->len;\n\tsector_t nr_slots;\n\n\tif (!(sctx->region_size & (sctx->region_size - 1)))\n\t\tsctx->region_size_bits = __ffs(sctx->region_size);\n\telse\n\t\tsctx->region_size_bits = -1;\n\n\tsctx->region_table_entry_bits = 1;\n\twhile (sctx->region_table_entry_bits < sizeof(region_table_slot_t) * 8 &&\n\t       (region_table_slot_t)1 << sctx->region_table_entry_bits < nr_paths)\n\t\tsctx->region_table_entry_bits++;\n\n\tsctx->region_entries_per_slot = (sizeof(region_table_slot_t) * 8) / sctx->region_table_entry_bits;\n\tif (!(sctx->region_entries_per_slot & (sctx->region_entries_per_slot - 1)))\n\t\tsctx->region_entries_per_slot_bits = __ffs(sctx->region_entries_per_slot);\n\telse\n\t\tsctx->region_entries_per_slot_bits = -1;\n\n\tif (sector_div(nr_regions, sctx->region_size))\n\t\tnr_regions++;\n\n\tif (nr_regions >= ULONG_MAX) {\n\t\tti->error = \"Region table too large\";\n\t\treturn -EINVAL;\n\t}\n\tsctx->nr_regions = nr_regions;\n\n\tnr_slots = nr_regions;\n\tif (sector_div(nr_slots, sctx->region_entries_per_slot))\n\t\tnr_slots++;\n\n\tif (nr_slots > ULONG_MAX / sizeof(region_table_slot_t)) {\n\t\tti->error = \"Region table too large\";\n\t\treturn -EINVAL;\n\t}\n\n\tsctx->region_table = vmalloc(array_size(nr_slots,\n\t\t\t\t\t\tsizeof(region_table_slot_t)));\n\tif (!sctx->region_table) {\n\t\tti->error = \"Cannot allocate region table\";\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void switch_get_position(struct switch_ctx *sctx, unsigned long region_nr,\n\t\t\t\tunsigned long *region_index, unsigned int *bit)\n{\n\tif (sctx->region_entries_per_slot_bits >= 0) {\n\t\t*region_index = region_nr >> sctx->region_entries_per_slot_bits;\n\t\t*bit = region_nr & (sctx->region_entries_per_slot - 1);\n\t} else {\n\t\t*region_index = region_nr / sctx->region_entries_per_slot;\n\t\t*bit = region_nr % sctx->region_entries_per_slot;\n\t}\n\n\t*bit *= sctx->region_table_entry_bits;\n}\n\nstatic unsigned int switch_region_table_read(struct switch_ctx *sctx, unsigned long region_nr)\n{\n\tunsigned long region_index;\n\tunsigned int bit;\n\n\tswitch_get_position(sctx, region_nr, &region_index, &bit);\n\n\treturn (READ_ONCE(sctx->region_table[region_index]) >> bit) &\n\t\t((1 << sctx->region_table_entry_bits) - 1);\n}\n\n \nstatic unsigned int switch_get_path_nr(struct switch_ctx *sctx, sector_t offset)\n{\n\tunsigned int path_nr;\n\tsector_t p;\n\n\tp = offset;\n\tif (sctx->region_size_bits >= 0)\n\t\tp >>= sctx->region_size_bits;\n\telse\n\t\tsector_div(p, sctx->region_size);\n\n\tpath_nr = switch_region_table_read(sctx, p);\n\n\t \n\tif (unlikely(path_nr >= sctx->nr_paths))\n\t\tpath_nr = 0;\n\n\treturn path_nr;\n}\n\nstatic void switch_region_table_write(struct switch_ctx *sctx, unsigned long region_nr,\n\t\t\t\t      unsigned int value)\n{\n\tunsigned long region_index;\n\tunsigned int bit;\n\tregion_table_slot_t pte;\n\n\tswitch_get_position(sctx, region_nr, &region_index, &bit);\n\n\tpte = sctx->region_table[region_index];\n\tpte &= ~((((region_table_slot_t)1 << sctx->region_table_entry_bits) - 1) << bit);\n\tpte |= (region_table_slot_t)value << bit;\n\tsctx->region_table[region_index] = pte;\n}\n\n \nstatic void initialise_region_table(struct switch_ctx *sctx)\n{\n\tunsigned int path_nr = 0;\n\tunsigned long region_nr;\n\n\tfor (region_nr = 0; region_nr < sctx->nr_regions; region_nr++) {\n\t\tswitch_region_table_write(sctx, region_nr, path_nr);\n\t\tif (++path_nr >= sctx->nr_paths)\n\t\t\tpath_nr = 0;\n\t}\n}\n\nstatic int parse_path(struct dm_arg_set *as, struct dm_target *ti)\n{\n\tstruct switch_ctx *sctx = ti->private;\n\tunsigned long long start;\n\tint r;\n\n\tr = dm_get_device(ti, dm_shift_arg(as), dm_table_get_mode(ti->table),\n\t\t\t  &sctx->path_list[sctx->nr_paths].dmdev);\n\tif (r) {\n\t\tti->error = \"Device lookup failed\";\n\t\treturn r;\n\t}\n\n\tif (kstrtoull(dm_shift_arg(as), 10, &start) || start != (sector_t)start) {\n\t\tti->error = \"Invalid device starting offset\";\n\t\tdm_put_device(ti, sctx->path_list[sctx->nr_paths].dmdev);\n\t\treturn -EINVAL;\n\t}\n\n\tsctx->path_list[sctx->nr_paths].start = start;\n\n\tsctx->nr_paths++;\n\n\treturn 0;\n}\n\n \nstatic void switch_dtr(struct dm_target *ti)\n{\n\tstruct switch_ctx *sctx = ti->private;\n\n\twhile (sctx->nr_paths--)\n\t\tdm_put_device(ti, sctx->path_list[sctx->nr_paths].dmdev);\n\n\tvfree(sctx->region_table);\n\tkfree(sctx);\n}\n\n \nstatic int switch_ctr(struct dm_target *ti, unsigned int argc, char **argv)\n{\n\tstatic const struct dm_arg _args[] = {\n\t\t{1, (KMALLOC_MAX_SIZE - sizeof(struct switch_ctx)) / sizeof(struct switch_path), \"Invalid number of paths\"},\n\t\t{1, UINT_MAX, \"Invalid region size\"},\n\t\t{0, 0, \"Invalid number of optional args\"},\n\t};\n\n\tstruct switch_ctx *sctx;\n\tstruct dm_arg_set as;\n\tunsigned int nr_paths, region_size, nr_optional_args;\n\tint r;\n\n\tas.argc = argc;\n\tas.argv = argv;\n\n\tr = dm_read_arg(_args, &as, &nr_paths, &ti->error);\n\tif (r)\n\t\treturn -EINVAL;\n\n\tr = dm_read_arg(_args + 1, &as, &region_size, &ti->error);\n\tif (r)\n\t\treturn r;\n\n\tr = dm_read_arg_group(_args + 2, &as, &nr_optional_args, &ti->error);\n\tif (r)\n\t\treturn r;\n\t \n\n\tif (as.argc != nr_paths * 2) {\n\t\tti->error = \"Incorrect number of path arguments\";\n\t\treturn -EINVAL;\n\t}\n\n\tsctx = alloc_switch_ctx(ti, nr_paths, region_size);\n\tif (!sctx) {\n\t\tti->error = \"Cannot allocate redirection context\";\n\t\treturn -ENOMEM;\n\t}\n\n\tr = dm_set_target_max_io_len(ti, region_size);\n\tif (r)\n\t\tgoto error;\n\n\twhile (as.argc) {\n\t\tr = parse_path(&as, ti);\n\t\tif (r)\n\t\t\tgoto error;\n\t}\n\n\tr = alloc_region_table(ti, nr_paths);\n\tif (r)\n\t\tgoto error;\n\n\tinitialise_region_table(sctx);\n\n\t \n\tti->num_discard_bios = 1;\n\n\treturn 0;\n\nerror:\n\tswitch_dtr(ti);\n\n\treturn r;\n}\n\nstatic int switch_map(struct dm_target *ti, struct bio *bio)\n{\n\tstruct switch_ctx *sctx = ti->private;\n\tsector_t offset = dm_target_offset(ti, bio->bi_iter.bi_sector);\n\tunsigned int path_nr = switch_get_path_nr(sctx, offset);\n\n\tbio_set_dev(bio, sctx->path_list[path_nr].dmdev->bdev);\n\tbio->bi_iter.bi_sector = sctx->path_list[path_nr].start + offset;\n\n\treturn DM_MAPIO_REMAPPED;\n}\n\n \nstatic const unsigned char hex_table[256] = {\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 255, 255, 255, 255, 255, 255,\n255, 10, 11, 12, 13, 14, 15, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 10, 11, 12, 13, 14, 15, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255\n};\n\nstatic __always_inline unsigned long parse_hex(const char **string)\n{\n\tunsigned char d;\n\tunsigned long r = 0;\n\n\twhile ((d = hex_table[(unsigned char)**string]) < 16) {\n\t\tr = (r << 4) | d;\n\t\t(*string)++;\n\t}\n\n\treturn r;\n}\n\nstatic int process_set_region_mappings(struct switch_ctx *sctx,\n\t\t\t\t       unsigned int argc, char **argv)\n{\n\tunsigned int i;\n\tunsigned long region_index = 0;\n\n\tfor (i = 1; i < argc; i++) {\n\t\tunsigned long path_nr;\n\t\tconst char *string = argv[i];\n\n\t\tif ((*string & 0xdf) == 'R') {\n\t\t\tunsigned long cycle_length, num_write;\n\n\t\t\tstring++;\n\t\t\tif (unlikely(*string == ',')) {\n\t\t\t\tDMWARN(\"invalid set_region_mappings argument: '%s'\", argv[i]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcycle_length = parse_hex(&string);\n\t\t\tif (unlikely(*string != ',')) {\n\t\t\t\tDMWARN(\"invalid set_region_mappings argument: '%s'\", argv[i]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tstring++;\n\t\t\tif (unlikely(!*string)) {\n\t\t\t\tDMWARN(\"invalid set_region_mappings argument: '%s'\", argv[i]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnum_write = parse_hex(&string);\n\t\t\tif (unlikely(*string)) {\n\t\t\t\tDMWARN(\"invalid set_region_mappings argument: '%s'\", argv[i]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (unlikely(!cycle_length) || unlikely(cycle_length - 1 > region_index)) {\n\t\t\t\tDMWARN(\"invalid set_region_mappings cycle length: %lu > %lu\",\n\t\t\t\t       cycle_length - 1, region_index);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (unlikely(region_index + num_write < region_index) ||\n\t\t\t    unlikely(region_index + num_write >= sctx->nr_regions)) {\n\t\t\t\tDMWARN(\"invalid set_region_mappings region number: %lu + %lu >= %lu\",\n\t\t\t\t       region_index, num_write, sctx->nr_regions);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\twhile (num_write--) {\n\t\t\t\tregion_index++;\n\t\t\t\tpath_nr = switch_region_table_read(sctx, region_index - cycle_length);\n\t\t\t\tswitch_region_table_write(sctx, region_index, path_nr);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*string == ':')\n\t\t\tregion_index++;\n\t\telse {\n\t\t\tregion_index = parse_hex(&string);\n\t\t\tif (unlikely(*string != ':')) {\n\t\t\t\tDMWARN(\"invalid set_region_mappings argument: '%s'\", argv[i]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tstring++;\n\t\tif (unlikely(!*string)) {\n\t\t\tDMWARN(\"invalid set_region_mappings argument: '%s'\", argv[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpath_nr = parse_hex(&string);\n\t\tif (unlikely(*string)) {\n\t\t\tDMWARN(\"invalid set_region_mappings argument: '%s'\", argv[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (unlikely(region_index >= sctx->nr_regions)) {\n\t\t\tDMWARN(\"invalid set_region_mappings region number: %lu >= %lu\", region_index, sctx->nr_regions);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (unlikely(path_nr >= sctx->nr_paths)) {\n\t\t\tDMWARN(\"invalid set_region_mappings device: %lu >= %u\", path_nr, sctx->nr_paths);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch_region_table_write(sctx, region_index, path_nr);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int switch_message(struct dm_target *ti, unsigned int argc, char **argv,\n\t\t\t  char *result, unsigned int maxlen)\n{\n\tstatic DEFINE_MUTEX(message_mutex);\n\n\tstruct switch_ctx *sctx = ti->private;\n\tint r = -EINVAL;\n\n\tmutex_lock(&message_mutex);\n\n\tif (!strcasecmp(argv[0], \"set_region_mappings\"))\n\t\tr = process_set_region_mappings(sctx, argc, argv);\n\telse\n\t\tDMWARN(\"Unrecognised message received.\");\n\n\tmutex_unlock(&message_mutex);\n\n\treturn r;\n}\n\nstatic void switch_status(struct dm_target *ti, status_type_t type,\n\t\t\t  unsigned int status_flags, char *result, unsigned int maxlen)\n{\n\tstruct switch_ctx *sctx = ti->private;\n\tunsigned int sz = 0;\n\tint path_nr;\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\tresult[0] = '\\0';\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\"%u %u 0\", sctx->nr_paths, sctx->region_size);\n\t\tfor (path_nr = 0; path_nr < sctx->nr_paths; path_nr++)\n\t\t\tDMEMIT(\" %s %llu\", sctx->path_list[path_nr].dmdev->name,\n\t\t\t       (unsigned long long)sctx->path_list[path_nr].start);\n\t\tbreak;\n\n\tcase STATUSTYPE_IMA:\n\t\tresult[0] = '\\0';\n\t\tbreak;\n\t}\n}\n\n \nstatic int switch_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)\n{\n\tstruct switch_ctx *sctx = ti->private;\n\tunsigned int path_nr;\n\n\tpath_nr = switch_get_path_nr(sctx, 0);\n\n\t*bdev = sctx->path_list[path_nr].dmdev->bdev;\n\n\t \n\tif (ti->len + sctx->path_list[path_nr].start !=\n\t    bdev_nr_sectors((*bdev)))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int switch_iterate_devices(struct dm_target *ti,\n\t\t\t\t  iterate_devices_callout_fn fn, void *data)\n{\n\tstruct switch_ctx *sctx = ti->private;\n\tint path_nr;\n\tint r;\n\n\tfor (path_nr = 0; path_nr < sctx->nr_paths; path_nr++) {\n\t\tr = fn(ti, sctx->path_list[path_nr].dmdev,\n\t\t\t sctx->path_list[path_nr].start, ti->len, data);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic struct target_type switch_target = {\n\t.name = \"switch\",\n\t.version = {1, 1, 0},\n\t.features = DM_TARGET_NOWAIT,\n\t.module = THIS_MODULE,\n\t.ctr = switch_ctr,\n\t.dtr = switch_dtr,\n\t.map = switch_map,\n\t.message = switch_message,\n\t.status = switch_status,\n\t.prepare_ioctl = switch_prepare_ioctl,\n\t.iterate_devices = switch_iterate_devices,\n};\nmodule_dm(switch);\n\nMODULE_DESCRIPTION(DM_NAME \" dynamic path switching target\");\nMODULE_AUTHOR(\"Kevin D. O'Kelley <Kevin_OKelley@dell.com>\");\nMODULE_AUTHOR(\"Narendran Ganapathy <Narendran_Ganapathy@dell.com>\");\nMODULE_AUTHOR(\"Jim Ramsay <Jim_Ramsay@dell.com>\");\nMODULE_AUTHOR(\"Mikulas Patocka <mpatocka@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}