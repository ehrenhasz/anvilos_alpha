{
  "module_name": "dm-cache-background-tracker.c",
  "hash_id": "66545efa5348fd5c251e4535036f2936353b384e79b95ea31ab627ef50c7752f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-cache-background-tracker.c",
  "human_readable_source": "\n \n\n#include \"dm-cache-background-tracker.h\"\n\n \n\n#define DM_MSG_PREFIX \"dm-background-tracker\"\n\nstruct bt_work {\n\tstruct list_head list;\n\tstruct rb_node node;\n\tstruct policy_work work;\n};\n\nstruct background_tracker {\n\tunsigned int max_work;\n\tatomic_t pending_promotes;\n\tatomic_t pending_writebacks;\n\tatomic_t pending_demotes;\n\n\tstruct list_head issued;\n\tstruct list_head queued;\n\tstruct rb_root pending;\n\n\tstruct kmem_cache *work_cache;\n};\n\nstruct background_tracker *btracker_create(unsigned int max_work)\n{\n\tstruct background_tracker *b = kmalloc(sizeof(*b), GFP_KERNEL);\n\n\tif (!b) {\n\t\tDMERR(\"couldn't create background_tracker\");\n\t\treturn NULL;\n\t}\n\n\tb->max_work = max_work;\n\tatomic_set(&b->pending_promotes, 0);\n\tatomic_set(&b->pending_writebacks, 0);\n\tatomic_set(&b->pending_demotes, 0);\n\n\tINIT_LIST_HEAD(&b->issued);\n\tINIT_LIST_HEAD(&b->queued);\n\n\tb->pending = RB_ROOT;\n\tb->work_cache = KMEM_CACHE(bt_work, 0);\n\tif (!b->work_cache) {\n\t\tDMERR(\"couldn't create mempool for background work items\");\n\t\tkfree(b);\n\t\tb = NULL;\n\t}\n\n\treturn b;\n}\nEXPORT_SYMBOL_GPL(btracker_create);\n\nvoid btracker_destroy(struct background_tracker *b)\n{\n\tstruct bt_work *w, *tmp;\n\n\tBUG_ON(!list_empty(&b->issued));\n\tlist_for_each_entry_safe (w, tmp, &b->queued, list) {\n\t\tlist_del(&w->list);\n\t\tkmem_cache_free(b->work_cache, w);\n\t}\n\n\tkmem_cache_destroy(b->work_cache);\n\tkfree(b);\n}\nEXPORT_SYMBOL_GPL(btracker_destroy);\n\nstatic int cmp_oblock(dm_oblock_t lhs, dm_oblock_t rhs)\n{\n\tif (from_oblock(lhs) < from_oblock(rhs))\n\t\treturn -1;\n\n\tif (from_oblock(rhs) < from_oblock(lhs))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic bool __insert_pending(struct background_tracker *b,\n\t\t\t     struct bt_work *nw)\n{\n\tint cmp;\n\tstruct bt_work *w;\n\tstruct rb_node **new = &b->pending.rb_node, *parent = NULL;\n\n\twhile (*new) {\n\t\tw = container_of(*new, struct bt_work, node);\n\n\t\tparent = *new;\n\t\tcmp = cmp_oblock(w->work.oblock, nw->work.oblock);\n\t\tif (cmp < 0)\n\t\t\tnew = &((*new)->rb_left);\n\n\t\telse if (cmp > 0)\n\t\t\tnew = &((*new)->rb_right);\n\n\t\telse\n\t\t\t \n\t\t\treturn false;\n\t}\n\n\trb_link_node(&nw->node, parent, new);\n\trb_insert_color(&nw->node, &b->pending);\n\n\treturn true;\n}\n\nstatic struct bt_work *__find_pending(struct background_tracker *b,\n\t\t\t\t      dm_oblock_t oblock)\n{\n\tint cmp;\n\tstruct bt_work *w;\n\tstruct rb_node **new = &b->pending.rb_node;\n\n\twhile (*new) {\n\t\tw = container_of(*new, struct bt_work, node);\n\n\t\tcmp = cmp_oblock(w->work.oblock, oblock);\n\t\tif (cmp < 0)\n\t\t\tnew = &((*new)->rb_left);\n\n\t\telse if (cmp > 0)\n\t\t\tnew = &((*new)->rb_right);\n\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn *new ? w : NULL;\n}\n\n\nstatic void update_stats(struct background_tracker *b, struct policy_work *w, int delta)\n{\n\tswitch (w->op) {\n\tcase POLICY_PROMOTE:\n\t\tatomic_add(delta, &b->pending_promotes);\n\t\tbreak;\n\n\tcase POLICY_DEMOTE:\n\t\tatomic_add(delta, &b->pending_demotes);\n\t\tbreak;\n\n\tcase POLICY_WRITEBACK:\n\t\tatomic_add(delta, &b->pending_writebacks);\n\t\tbreak;\n\t}\n}\n\nunsigned int btracker_nr_writebacks_queued(struct background_tracker *b)\n{\n\treturn atomic_read(&b->pending_writebacks);\n}\nEXPORT_SYMBOL_GPL(btracker_nr_writebacks_queued);\n\nunsigned int btracker_nr_demotions_queued(struct background_tracker *b)\n{\n\treturn atomic_read(&b->pending_demotes);\n}\nEXPORT_SYMBOL_GPL(btracker_nr_demotions_queued);\n\nstatic bool max_work_reached(struct background_tracker *b)\n{\n\treturn atomic_read(&b->pending_promotes) +\n\t\tatomic_read(&b->pending_writebacks) +\n\t\tatomic_read(&b->pending_demotes) >= b->max_work;\n}\n\nstatic struct bt_work *alloc_work(struct background_tracker *b)\n{\n\tif (max_work_reached(b))\n\t\treturn NULL;\n\n\treturn kmem_cache_alloc(b->work_cache, GFP_NOWAIT);\n}\n\nint btracker_queue(struct background_tracker *b,\n\t\t   struct policy_work *work,\n\t\t   struct policy_work **pwork)\n{\n\tstruct bt_work *w;\n\n\tif (pwork)\n\t\t*pwork = NULL;\n\n\tw = alloc_work(b);\n\tif (!w)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&w->work, work, sizeof(*work));\n\n\tif (!__insert_pending(b, w)) {\n\t\t \n\t\tkmem_cache_free(b->work_cache, w);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pwork) {\n\t\t*pwork = &w->work;\n\t\tlist_add(&w->list, &b->issued);\n\t} else\n\t\tlist_add(&w->list, &b->queued);\n\tupdate_stats(b, &w->work, 1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btracker_queue);\n\n \nint btracker_issue(struct background_tracker *b, struct policy_work **work)\n{\n\tstruct bt_work *w;\n\n\tif (list_empty(&b->queued))\n\t\treturn -ENODATA;\n\n\tw = list_first_entry(&b->queued, struct bt_work, list);\n\tlist_move(&w->list, &b->issued);\n\t*work = &w->work;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btracker_issue);\n\nvoid btracker_complete(struct background_tracker *b,\n\t\t       struct policy_work *op)\n{\n\tstruct bt_work *w = container_of(op, struct bt_work, work);\n\n\tupdate_stats(b, &w->work, -1);\n\trb_erase(&w->node, &b->pending);\n\tlist_del(&w->list);\n\tkmem_cache_free(b->work_cache, w);\n}\nEXPORT_SYMBOL_GPL(btracker_complete);\n\nbool btracker_promotion_already_present(struct background_tracker *b,\n\t\t\t\t\tdm_oblock_t oblock)\n{\n\treturn __find_pending(b, oblock) != NULL;\n}\nEXPORT_SYMBOL_GPL(btracker_promotion_already_present);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}