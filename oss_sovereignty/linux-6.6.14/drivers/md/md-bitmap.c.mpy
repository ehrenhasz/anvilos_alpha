{
  "module_name": "md-bitmap.c",
  "hash_id": "787bad9133b36c105238017812acac96d7b325b3e63d565fec9e4c5e046b3acb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/md-bitmap.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/seq_file.h>\n#include <trace/events/block.h>\n#include \"md.h\"\n#include \"md-bitmap.h\"\n\nstatic inline char *bmname(struct bitmap *bitmap)\n{\n\treturn bitmap->mddev ? mdname(bitmap->mddev) : \"mdX\";\n}\n\n \nstatic int md_bitmap_checkpage(struct bitmap_counts *bitmap,\n\t\t\t       unsigned long page, int create, int no_hijack)\n__releases(bitmap->lock)\n__acquires(bitmap->lock)\n{\n\tunsigned char *mappage;\n\n\tWARN_ON_ONCE(page >= bitmap->pages);\n\tif (bitmap->bp[page].hijacked)  \n\t\treturn 0;\n\n\tif (bitmap->bp[page].map)  \n\t\treturn 0;\n\n\tif (!create)\n\t\treturn -ENOENT;\n\n\t \n\n\tspin_unlock_irq(&bitmap->lock);\n\t \n\tsched_annotate_sleep();\n\tmappage = kzalloc(PAGE_SIZE, GFP_NOIO);\n\tspin_lock_irq(&bitmap->lock);\n\n\tif (mappage == NULL) {\n\t\tpr_debug(\"md/bitmap: map page allocation failed, hijacking\\n\");\n\t\t \n\t\tif (no_hijack)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tif (!bitmap->bp[page].map)\n\t\t\tbitmap->bp[page].hijacked = 1;\n\t} else if (bitmap->bp[page].map ||\n\t\t   bitmap->bp[page].hijacked) {\n\t\t \n\t\tkfree(mappage);\n\t} else {\n\n\t\t \n\n\t\tbitmap->bp[page].map = mappage;\n\t\tbitmap->missing_pages--;\n\t}\n\treturn 0;\n}\n\n \n \n \nstatic void md_bitmap_checkfree(struct bitmap_counts *bitmap, unsigned long page)\n{\n\tchar *ptr;\n\n\tif (bitmap->bp[page].count)  \n\t\treturn;\n\n\t \n\n\tif (bitmap->bp[page].hijacked) {  \n\t\tbitmap->bp[page].hijacked = 0;\n\t\tbitmap->bp[page].map = NULL;\n\t} else {\n\t\t \n\t\tptr = bitmap->bp[page].map;\n\t\tbitmap->bp[page].map = NULL;\n\t\tbitmap->missing_pages++;\n\t\tkfree(ptr);\n\t}\n}\n\n \n\n \n\n \n\n \nstatic int read_sb_page(struct mddev *mddev, loff_t offset,\n\t\tstruct page *page, unsigned long index, int size)\n{\n\n\tsector_t sector = mddev->bitmap_info.offset + offset +\n\t\tindex * (PAGE_SIZE / SECTOR_SIZE);\n\tstruct md_rdev *rdev;\n\n\trdev_for_each(rdev, mddev) {\n\t\tu32 iosize = roundup(size, bdev_logical_block_size(rdev->bdev));\n\n\t\tif (!test_bit(In_sync, &rdev->flags) ||\n\t\t    test_bit(Faulty, &rdev->flags) ||\n\t\t    test_bit(Bitmap_sync, &rdev->flags))\n\t\t\tcontinue;\n\n\t\tif (sync_page_io(rdev, sector, iosize, page, REQ_OP_READ, true))\n\t\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\nstatic struct md_rdev *next_active_rdev(struct md_rdev *rdev, struct mddev *mddev)\n{\n\t \n\trcu_read_lock();\n\tif (rdev == NULL)\n\t\t \n\t\trdev = list_entry(&mddev->disks, struct md_rdev, same_set);\n\telse {\n\t\t \n\t\trdev_dec_pending(rdev, mddev);\n\t}\n\tlist_for_each_entry_continue_rcu(rdev, &mddev->disks, same_set) {\n\t\tif (rdev->raid_disk >= 0 &&\n\t\t    !test_bit(Faulty, &rdev->flags)) {\n\t\t\t \n\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t\trcu_read_unlock();\n\t\t\treturn rdev;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\n\nstatic unsigned int optimal_io_size(struct block_device *bdev,\n\t\t\t\t    unsigned int last_page_size,\n\t\t\t\t    unsigned int io_size)\n{\n\tif (bdev_io_opt(bdev) > bdev_logical_block_size(bdev))\n\t\treturn roundup(last_page_size, bdev_io_opt(bdev));\n\treturn io_size;\n}\n\nstatic unsigned int bitmap_io_size(unsigned int io_size, unsigned int opt_size,\n\t\t\t\t   loff_t start, loff_t boundary)\n{\n\tif (io_size != opt_size &&\n\t    start + opt_size / SECTOR_SIZE <= boundary)\n\t\treturn opt_size;\n\tif (start + io_size / SECTOR_SIZE <= boundary)\n\t\treturn io_size;\n\n\t \n\treturn 0;\n}\n\nstatic int __write_sb_page(struct md_rdev *rdev, struct bitmap *bitmap,\n\t\t\t   unsigned long pg_index, struct page *page)\n{\n\tstruct block_device *bdev;\n\tstruct mddev *mddev = bitmap->mddev;\n\tstruct bitmap_storage *store = &bitmap->storage;\n\tloff_t sboff, offset = mddev->bitmap_info.offset;\n\tsector_t ps = pg_index * PAGE_SIZE / SECTOR_SIZE;\n\tunsigned int size = PAGE_SIZE;\n\tunsigned int opt_size = PAGE_SIZE;\n\tsector_t doff;\n\n\tbdev = (rdev->meta_bdev) ? rdev->meta_bdev : rdev->bdev;\n\tif (pg_index == store->file_pages - 1) {\n\t\tunsigned int last_page_size = store->bytes & (PAGE_SIZE - 1);\n\n\t\tif (last_page_size == 0)\n\t\t\tlast_page_size = PAGE_SIZE;\n\t\tsize = roundup(last_page_size, bdev_logical_block_size(bdev));\n\t\topt_size = optimal_io_size(bdev, last_page_size, size);\n\t}\n\n\tsboff = rdev->sb_start + offset;\n\tdoff = rdev->data_offset;\n\n\t \n\tif (mddev->external) {\n\t\t \n\t\tif (sboff + ps > doff &&\n\t\t    sboff < (doff + mddev->dev_sectors + PAGE_SIZE / SECTOR_SIZE))\n\t\t\treturn -EINVAL;\n\t} else if (offset < 0) {\n\t\t \n\t\tsize = bitmap_io_size(size, opt_size, offset + ps, 0);\n\t\tif (size == 0)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\tif (doff + mddev->dev_sectors > sboff)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t} else if (rdev->sb_start < rdev->data_offset) {\n\t\t \n\t\tsize = bitmap_io_size(size, opt_size, sboff + ps, doff);\n\t\tif (size == 0)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t}\n\n\tmd_super_write(mddev, rdev, sboff + ps, (int) size, page);\n\treturn 0;\n}\n\nstatic void write_sb_page(struct bitmap *bitmap, unsigned long pg_index,\n\t\t\t  struct page *page, bool wait)\n{\n\tstruct mddev *mddev = bitmap->mddev;\n\n\tdo {\n\t\tstruct md_rdev *rdev = NULL;\n\n\t\twhile ((rdev = next_active_rdev(rdev, mddev)) != NULL) {\n\t\t\tif (__write_sb_page(rdev, bitmap, pg_index, page) < 0) {\n\t\t\t\tset_bit(BITMAP_WRITE_ERROR, &bitmap->flags);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} while (wait && md_super_wait(mddev) < 0);\n}\n\nstatic void md_bitmap_file_kick(struct bitmap *bitmap);\n\n#ifdef CONFIG_MD_BITMAP_FILE\nstatic void write_file_page(struct bitmap *bitmap, struct page *page, int wait)\n{\n\tstruct buffer_head *bh = page_buffers(page);\n\n\twhile (bh && bh->b_blocknr) {\n\t\tatomic_inc(&bitmap->pending_writes);\n\t\tset_buffer_locked(bh);\n\t\tset_buffer_mapped(bh);\n\t\tsubmit_bh(REQ_OP_WRITE | REQ_SYNC, bh);\n\t\tbh = bh->b_this_page;\n\t}\n\n\tif (wait)\n\t\twait_event(bitmap->write_wait,\n\t\t\t   atomic_read(&bitmap->pending_writes) == 0);\n}\n\nstatic void end_bitmap_write(struct buffer_head *bh, int uptodate)\n{\n\tstruct bitmap *bitmap = bh->b_private;\n\n\tif (!uptodate)\n\t\tset_bit(BITMAP_WRITE_ERROR, &bitmap->flags);\n\tif (atomic_dec_and_test(&bitmap->pending_writes))\n\t\twake_up(&bitmap->write_wait);\n}\n\nstatic void free_buffers(struct page *page)\n{\n\tstruct buffer_head *bh;\n\n\tif (!PagePrivate(page))\n\t\treturn;\n\n\tbh = page_buffers(page);\n\twhile (bh) {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tfree_buffer_head(bh);\n\t\tbh = next;\n\t}\n\tdetach_page_private(page);\n\tput_page(page);\n}\n\n \nstatic int read_file_page(struct file *file, unsigned long index,\n\t\tstruct bitmap *bitmap, unsigned long count, struct page *page)\n{\n\tint ret = 0;\n\tstruct inode *inode = file_inode(file);\n\tstruct buffer_head *bh;\n\tsector_t block, blk_cur;\n\tunsigned long blocksize = i_blocksize(inode);\n\n\tpr_debug(\"read bitmap file (%dB @ %llu)\\n\", (int)PAGE_SIZE,\n\t\t (unsigned long long)index << PAGE_SHIFT);\n\n\tbh = alloc_page_buffers(page, blocksize, false);\n\tif (!bh) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tattach_page_private(page, bh);\n\tblk_cur = index << (PAGE_SHIFT - inode->i_blkbits);\n\twhile (bh) {\n\t\tblock = blk_cur;\n\n\t\tif (count == 0)\n\t\t\tbh->b_blocknr = 0;\n\t\telse {\n\t\t\tret = bmap(inode, &block);\n\t\t\tif (ret || !block) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbh->b_blocknr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbh->b_blocknr = block;\n\t\t\tbh->b_bdev = inode->i_sb->s_bdev;\n\t\t\tif (count < blocksize)\n\t\t\t\tcount = 0;\n\t\t\telse\n\t\t\t\tcount -= blocksize;\n\n\t\t\tbh->b_end_io = end_bitmap_write;\n\t\t\tbh->b_private = bitmap;\n\t\t\tatomic_inc(&bitmap->pending_writes);\n\t\t\tset_buffer_locked(bh);\n\t\t\tset_buffer_mapped(bh);\n\t\t\tsubmit_bh(REQ_OP_READ, bh);\n\t\t}\n\t\tblk_cur++;\n\t\tbh = bh->b_this_page;\n\t}\n\n\twait_event(bitmap->write_wait,\n\t\t   atomic_read(&bitmap->pending_writes)==0);\n\tif (test_bit(BITMAP_WRITE_ERROR, &bitmap->flags))\n\t\tret = -EIO;\nout:\n\tif (ret)\n\t\tpr_err(\"md: bitmap read error: (%dB @ %llu): %d\\n\",\n\t\t       (int)PAGE_SIZE,\n\t\t       (unsigned long long)index << PAGE_SHIFT,\n\t\t       ret);\n\treturn ret;\n}\n#else  \nstatic void write_file_page(struct bitmap *bitmap, struct page *page, int wait)\n{\n}\nstatic int read_file_page(struct file *file, unsigned long index,\n\t\tstruct bitmap *bitmap, unsigned long count, struct page *page)\n{\n\treturn -EIO;\n}\nstatic void free_buffers(struct page *page)\n{\n\tput_page(page);\n}\n#endif  \n\n \n\n \nstatic void filemap_write_page(struct bitmap *bitmap, unsigned long pg_index,\n\t\t\t       bool wait)\n{\n\tstruct bitmap_storage *store = &bitmap->storage;\n\tstruct page *page = store->filemap[pg_index];\n\n\tif (mddev_is_clustered(bitmap->mddev)) {\n\t\tpg_index += bitmap->cluster_slot *\n\t\t\tDIV_ROUND_UP(store->bytes, PAGE_SIZE);\n\t}\n\n\tif (store->file)\n\t\twrite_file_page(bitmap, page, wait);\n\telse\n\t\twrite_sb_page(bitmap, pg_index, page, wait);\n}\n\n \nstatic void md_bitmap_wait_writes(struct bitmap *bitmap)\n{\n\tif (bitmap->storage.file)\n\t\twait_event(bitmap->write_wait,\n\t\t\t   atomic_read(&bitmap->pending_writes)==0);\n\telse\n\t\t \n\t\tmd_super_wait(bitmap->mddev);\n}\n\n\n \nvoid md_bitmap_update_sb(struct bitmap *bitmap)\n{\n\tbitmap_super_t *sb;\n\n\tif (!bitmap || !bitmap->mddev)  \n\t\treturn;\n\tif (bitmap->mddev->bitmap_info.external)\n\t\treturn;\n\tif (!bitmap->storage.sb_page)  \n\t\treturn;\n\tsb = kmap_atomic(bitmap->storage.sb_page);\n\tsb->events = cpu_to_le64(bitmap->mddev->events);\n\tif (bitmap->mddev->events < bitmap->events_cleared)\n\t\t \n\t\tbitmap->events_cleared = bitmap->mddev->events;\n\tsb->events_cleared = cpu_to_le64(bitmap->events_cleared);\n\t \n\tsb->state = cpu_to_le32(bitmap->flags & ~BIT(BITMAP_WRITE_ERROR));\n\t \n\tsb->daemon_sleep = cpu_to_le32(bitmap->mddev->bitmap_info.daemon_sleep/HZ);\n\tsb->write_behind = cpu_to_le32(bitmap->mddev->bitmap_info.max_write_behind);\n\t \n\tsb->sync_size = cpu_to_le64(bitmap->mddev->resync_max_sectors);\n\tsb->chunksize = cpu_to_le32(bitmap->mddev->bitmap_info.chunksize);\n\tsb->nodes = cpu_to_le32(bitmap->mddev->bitmap_info.nodes);\n\tsb->sectors_reserved = cpu_to_le32(bitmap->mddev->\n\t\t\t\t\t   bitmap_info.space);\n\tkunmap_atomic(sb);\n\n\tif (bitmap->storage.file)\n\t\twrite_file_page(bitmap, bitmap->storage.sb_page, 1);\n\telse\n\t\twrite_sb_page(bitmap, bitmap->storage.sb_index,\n\t\t\t      bitmap->storage.sb_page, 1);\n}\nEXPORT_SYMBOL(md_bitmap_update_sb);\n\n \nvoid md_bitmap_print_sb(struct bitmap *bitmap)\n{\n\tbitmap_super_t *sb;\n\n\tif (!bitmap || !bitmap->storage.sb_page)\n\t\treturn;\n\tsb = kmap_atomic(bitmap->storage.sb_page);\n\tpr_debug(\"%s: bitmap file superblock:\\n\", bmname(bitmap));\n\tpr_debug(\"         magic: %08x\\n\", le32_to_cpu(sb->magic));\n\tpr_debug(\"       version: %u\\n\", le32_to_cpu(sb->version));\n\tpr_debug(\"          uuid: %08x.%08x.%08x.%08x\\n\",\n\t\t le32_to_cpu(*(__le32 *)(sb->uuid+0)),\n\t\t le32_to_cpu(*(__le32 *)(sb->uuid+4)),\n\t\t le32_to_cpu(*(__le32 *)(sb->uuid+8)),\n\t\t le32_to_cpu(*(__le32 *)(sb->uuid+12)));\n\tpr_debug(\"        events: %llu\\n\",\n\t\t (unsigned long long) le64_to_cpu(sb->events));\n\tpr_debug(\"events cleared: %llu\\n\",\n\t\t (unsigned long long) le64_to_cpu(sb->events_cleared));\n\tpr_debug(\"         state: %08x\\n\", le32_to_cpu(sb->state));\n\tpr_debug(\"     chunksize: %u B\\n\", le32_to_cpu(sb->chunksize));\n\tpr_debug(\"  daemon sleep: %us\\n\", le32_to_cpu(sb->daemon_sleep));\n\tpr_debug(\"     sync size: %llu KB\\n\",\n\t\t (unsigned long long)le64_to_cpu(sb->sync_size)/2);\n\tpr_debug(\"max write behind: %u\\n\", le32_to_cpu(sb->write_behind));\n\tkunmap_atomic(sb);\n}\n\n \nstatic int md_bitmap_new_disk_sb(struct bitmap *bitmap)\n{\n\tbitmap_super_t *sb;\n\tunsigned long chunksize, daemon_sleep, write_behind;\n\n\tbitmap->storage.sb_page = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (bitmap->storage.sb_page == NULL)\n\t\treturn -ENOMEM;\n\tbitmap->storage.sb_index = 0;\n\n\tsb = kmap_atomic(bitmap->storage.sb_page);\n\n\tsb->magic = cpu_to_le32(BITMAP_MAGIC);\n\tsb->version = cpu_to_le32(BITMAP_MAJOR_HI);\n\n\tchunksize = bitmap->mddev->bitmap_info.chunksize;\n\tBUG_ON(!chunksize);\n\tif (!is_power_of_2(chunksize)) {\n\t\tkunmap_atomic(sb);\n\t\tpr_warn(\"bitmap chunksize not a power of 2\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsb->chunksize = cpu_to_le32(chunksize);\n\n\tdaemon_sleep = bitmap->mddev->bitmap_info.daemon_sleep;\n\tif (!daemon_sleep || (daemon_sleep > MAX_SCHEDULE_TIMEOUT)) {\n\t\tpr_debug(\"Choosing daemon_sleep default (5 sec)\\n\");\n\t\tdaemon_sleep = 5 * HZ;\n\t}\n\tsb->daemon_sleep = cpu_to_le32(daemon_sleep);\n\tbitmap->mddev->bitmap_info.daemon_sleep = daemon_sleep;\n\n\t \n\twrite_behind = bitmap->mddev->bitmap_info.max_write_behind;\n\tif (write_behind > COUNTER_MAX)\n\t\twrite_behind = COUNTER_MAX / 2;\n\tsb->write_behind = cpu_to_le32(write_behind);\n\tbitmap->mddev->bitmap_info.max_write_behind = write_behind;\n\n\t \n\tsb->sync_size = cpu_to_le64(bitmap->mddev->resync_max_sectors);\n\n\tmemcpy(sb->uuid, bitmap->mddev->uuid, 16);\n\n\tset_bit(BITMAP_STALE, &bitmap->flags);\n\tsb->state = cpu_to_le32(bitmap->flags);\n\tbitmap->events_cleared = bitmap->mddev->events;\n\tsb->events_cleared = cpu_to_le64(bitmap->mddev->events);\n\tbitmap->mddev->bitmap_info.nodes = 0;\n\n\tkunmap_atomic(sb);\n\n\treturn 0;\n}\n\n \nstatic int md_bitmap_read_sb(struct bitmap *bitmap)\n{\n\tchar *reason = NULL;\n\tbitmap_super_t *sb;\n\tunsigned long chunksize, daemon_sleep, write_behind;\n\tunsigned long long events;\n\tint nodes = 0;\n\tunsigned long sectors_reserved = 0;\n\tint err = -EINVAL;\n\tstruct page *sb_page;\n\tloff_t offset = 0;\n\n\tif (!bitmap->storage.file && !bitmap->mddev->bitmap_info.offset) {\n\t\tchunksize = 128 * 1024 * 1024;\n\t\tdaemon_sleep = 5 * HZ;\n\t\twrite_behind = 0;\n\t\tset_bit(BITMAP_STALE, &bitmap->flags);\n\t\terr = 0;\n\t\tgoto out_no_sb;\n\t}\n\t \n\tsb_page = alloc_page(GFP_KERNEL);\n\tif (!sb_page)\n\t\treturn -ENOMEM;\n\tbitmap->storage.sb_page = sb_page;\n\nre_read:\n\t \n\tif (bitmap->cluster_slot >= 0) {\n\t\tsector_t bm_blocks = bitmap->mddev->resync_max_sectors;\n\n\t\tbm_blocks = DIV_ROUND_UP_SECTOR_T(bm_blocks,\n\t\t\t   (bitmap->mddev->bitmap_info.chunksize >> 9));\n\t\t \n\t\tbm_blocks = ((bm_blocks+7) >> 3) + sizeof(bitmap_super_t);\n\t\t \n\t\tbm_blocks = DIV_ROUND_UP_SECTOR_T(bm_blocks, 4096);\n\t\toffset = bitmap->cluster_slot * (bm_blocks << 3);\n\t\tpr_debug(\"%s:%d bm slot: %d offset: %llu\\n\", __func__, __LINE__,\n\t\t\tbitmap->cluster_slot, offset);\n\t}\n\n\tif (bitmap->storage.file) {\n\t\tloff_t isize = i_size_read(bitmap->storage.file->f_mapping->host);\n\t\tint bytes = isize > PAGE_SIZE ? PAGE_SIZE : isize;\n\n\t\terr = read_file_page(bitmap->storage.file, 0,\n\t\t\t\tbitmap, bytes, sb_page);\n\t} else {\n\t\terr = read_sb_page(bitmap->mddev, offset, sb_page, 0,\n\t\t\t\t   sizeof(bitmap_super_t));\n\t}\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tsb = kmap_atomic(sb_page);\n\n\tchunksize = le32_to_cpu(sb->chunksize);\n\tdaemon_sleep = le32_to_cpu(sb->daemon_sleep) * HZ;\n\twrite_behind = le32_to_cpu(sb->write_behind);\n\tsectors_reserved = le32_to_cpu(sb->sectors_reserved);\n\n\t \n\tif (sb->magic != cpu_to_le32(BITMAP_MAGIC))\n\t\treason = \"bad magic\";\n\telse if (le32_to_cpu(sb->version) < BITMAP_MAJOR_LO ||\n\t\t le32_to_cpu(sb->version) > BITMAP_MAJOR_CLUSTERED)\n\t\treason = \"unrecognized superblock version\";\n\telse if (chunksize < 512)\n\t\treason = \"bitmap chunksize too small\";\n\telse if (!is_power_of_2(chunksize))\n\t\treason = \"bitmap chunksize not a power of 2\";\n\telse if (daemon_sleep < 1 || daemon_sleep > MAX_SCHEDULE_TIMEOUT)\n\t\treason = \"daemon sleep period out of range\";\n\telse if (write_behind > COUNTER_MAX)\n\t\treason = \"write-behind limit out of range (0 - 16383)\";\n\tif (reason) {\n\t\tpr_warn(\"%s: invalid bitmap file superblock: %s\\n\",\n\t\t\tbmname(bitmap), reason);\n\t\tgoto out;\n\t}\n\n\t \n\tif (sb->version == cpu_to_le32(BITMAP_MAJOR_CLUSTERED)) {\n\t\tnodes = le32_to_cpu(sb->nodes);\n\t\tstrscpy(bitmap->mddev->bitmap_info.cluster_name,\n\t\t\t\tsb->cluster_name, 64);\n\t}\n\n\t \n\tsb->sync_size = cpu_to_le64(bitmap->mddev->resync_max_sectors);\n\n\tif (bitmap->mddev->persistent) {\n\t\t \n\t\tif (memcmp(sb->uuid, bitmap->mddev->uuid, 16)) {\n\t\t\tpr_warn(\"%s: bitmap superblock UUID mismatch\\n\",\n\t\t\t\tbmname(bitmap));\n\t\t\tgoto out;\n\t\t}\n\t\tevents = le64_to_cpu(sb->events);\n\t\tif (!nodes && (events < bitmap->mddev->events)) {\n\t\t\tpr_warn(\"%s: bitmap file is out of date (%llu < %llu) -- forcing full recovery\\n\",\n\t\t\t\tbmname(bitmap), events,\n\t\t\t\t(unsigned long long) bitmap->mddev->events);\n\t\t\tset_bit(BITMAP_STALE, &bitmap->flags);\n\t\t}\n\t}\n\n\t \n\tbitmap->flags |= le32_to_cpu(sb->state);\n\tif (le32_to_cpu(sb->version) == BITMAP_MAJOR_HOSTENDIAN)\n\t\tset_bit(BITMAP_HOSTENDIAN, &bitmap->flags);\n\tbitmap->events_cleared = le64_to_cpu(sb->events_cleared);\n\terr = 0;\n\nout:\n\tkunmap_atomic(sb);\n\tif (err == 0 && nodes && (bitmap->cluster_slot < 0)) {\n\t\t \n\t\tbitmap->mddev->bitmap_info.chunksize = chunksize;\n\t\terr = md_setup_cluster(bitmap->mddev, nodes);\n\t\tif (err) {\n\t\t\tpr_warn(\"%s: Could not setup cluster service (%d)\\n\",\n\t\t\t\tbmname(bitmap), err);\n\t\t\tgoto out_no_sb;\n\t\t}\n\t\tbitmap->cluster_slot = md_cluster_ops->slot_number(bitmap->mddev);\n\t\tgoto re_read;\n\t}\n\nout_no_sb:\n\tif (err == 0) {\n\t\tif (test_bit(BITMAP_STALE, &bitmap->flags))\n\t\t\tbitmap->events_cleared = bitmap->mddev->events;\n\t\tbitmap->mddev->bitmap_info.chunksize = chunksize;\n\t\tbitmap->mddev->bitmap_info.daemon_sleep = daemon_sleep;\n\t\tbitmap->mddev->bitmap_info.max_write_behind = write_behind;\n\t\tbitmap->mddev->bitmap_info.nodes = nodes;\n\t\tif (bitmap->mddev->bitmap_info.space == 0 ||\n\t\t\tbitmap->mddev->bitmap_info.space > sectors_reserved)\n\t\t\tbitmap->mddev->bitmap_info.space = sectors_reserved;\n\t} else {\n\t\tmd_bitmap_print_sb(bitmap);\n\t\tif (bitmap->cluster_slot < 0)\n\t\t\tmd_cluster_stop(bitmap->mddev);\n\t}\n\treturn err;\n}\n\n \n\n \n \nstatic inline unsigned long file_page_index(struct bitmap_storage *store,\n\t\t\t\t\t    unsigned long chunk)\n{\n\tif (store->sb_page)\n\t\tchunk += sizeof(bitmap_super_t) << 3;\n\treturn chunk >> PAGE_BIT_SHIFT;\n}\n\n \nstatic inline unsigned long file_page_offset(struct bitmap_storage *store,\n\t\t\t\t\t     unsigned long chunk)\n{\n\tif (store->sb_page)\n\t\tchunk += sizeof(bitmap_super_t) << 3;\n\treturn chunk & (PAGE_BITS - 1);\n}\n\n \nstatic inline struct page *filemap_get_page(struct bitmap_storage *store,\n\t\t\t\t\t    unsigned long chunk)\n{\n\tif (file_page_index(store, chunk) >= store->file_pages)\n\t\treturn NULL;\n\treturn store->filemap[file_page_index(store, chunk)];\n}\n\nstatic int md_bitmap_storage_alloc(struct bitmap_storage *store,\n\t\t\t\t   unsigned long chunks, int with_super,\n\t\t\t\t   int slot_number)\n{\n\tint pnum, offset = 0;\n\tunsigned long num_pages;\n\tunsigned long bytes;\n\n\tbytes = DIV_ROUND_UP(chunks, 8);\n\tif (with_super)\n\t\tbytes += sizeof(bitmap_super_t);\n\n\tnum_pages = DIV_ROUND_UP(bytes, PAGE_SIZE);\n\toffset = slot_number * num_pages;\n\n\tstore->filemap = kmalloc_array(num_pages, sizeof(struct page *),\n\t\t\t\t       GFP_KERNEL);\n\tif (!store->filemap)\n\t\treturn -ENOMEM;\n\n\tif (with_super && !store->sb_page) {\n\t\tstore->sb_page = alloc_page(GFP_KERNEL|__GFP_ZERO);\n\t\tif (store->sb_page == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpnum = 0;\n\tif (store->sb_page) {\n\t\tstore->filemap[0] = store->sb_page;\n\t\tpnum = 1;\n\t\tstore->sb_index = offset;\n\t}\n\n\tfor ( ; pnum < num_pages; pnum++) {\n\t\tstore->filemap[pnum] = alloc_page(GFP_KERNEL|__GFP_ZERO);\n\t\tif (!store->filemap[pnum]) {\n\t\t\tstore->file_pages = pnum;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tstore->file_pages = pnum;\n\n\t \n\tstore->filemap_attr = kzalloc(\n\t\troundup(DIV_ROUND_UP(num_pages*4, 8), sizeof(unsigned long)),\n\t\tGFP_KERNEL);\n\tif (!store->filemap_attr)\n\t\treturn -ENOMEM;\n\n\tstore->bytes = bytes;\n\n\treturn 0;\n}\n\nstatic void md_bitmap_file_unmap(struct bitmap_storage *store)\n{\n\tstruct file *file = store->file;\n\tstruct page *sb_page = store->sb_page;\n\tstruct page **map = store->filemap;\n\tint pages = store->file_pages;\n\n\twhile (pages--)\n\t\tif (map[pages] != sb_page)  \n\t\t\tfree_buffers(map[pages]);\n\tkfree(map);\n\tkfree(store->filemap_attr);\n\n\tif (sb_page)\n\t\tfree_buffers(sb_page);\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tinvalidate_mapping_pages(inode->i_mapping, 0, -1);\n\t\tfput(file);\n\t}\n}\n\n \nstatic void md_bitmap_file_kick(struct bitmap *bitmap)\n{\n\tif (!test_and_set_bit(BITMAP_STALE, &bitmap->flags)) {\n\t\tmd_bitmap_update_sb(bitmap);\n\n\t\tif (bitmap->storage.file) {\n\t\t\tpr_warn(\"%s: kicking failed bitmap file %pD4 from array!\\n\",\n\t\t\t\tbmname(bitmap), bitmap->storage.file);\n\n\t\t} else\n\t\t\tpr_warn(\"%s: disabling internal bitmap due to errors\\n\",\n\t\t\t\tbmname(bitmap));\n\t}\n}\n\nenum bitmap_page_attr {\n\tBITMAP_PAGE_DIRTY = 0,      \n\tBITMAP_PAGE_PENDING = 1,    \n\tBITMAP_PAGE_NEEDWRITE = 2,  \n};\n\nstatic inline void set_page_attr(struct bitmap *bitmap, int pnum,\n\t\t\t\t enum bitmap_page_attr attr)\n{\n\tset_bit((pnum<<2) + attr, bitmap->storage.filemap_attr);\n}\n\nstatic inline void clear_page_attr(struct bitmap *bitmap, int pnum,\n\t\t\t\t   enum bitmap_page_attr attr)\n{\n\tclear_bit((pnum<<2) + attr, bitmap->storage.filemap_attr);\n}\n\nstatic inline int test_page_attr(struct bitmap *bitmap, int pnum,\n\t\t\t\t enum bitmap_page_attr attr)\n{\n\treturn test_bit((pnum<<2) + attr, bitmap->storage.filemap_attr);\n}\n\nstatic inline int test_and_clear_page_attr(struct bitmap *bitmap, int pnum,\n\t\t\t\t\t   enum bitmap_page_attr attr)\n{\n\treturn test_and_clear_bit((pnum<<2) + attr,\n\t\t\t\t  bitmap->storage.filemap_attr);\n}\n \nstatic void md_bitmap_file_set_bit(struct bitmap *bitmap, sector_t block)\n{\n\tunsigned long bit;\n\tstruct page *page;\n\tvoid *kaddr;\n\tunsigned long chunk = block >> bitmap->counts.chunkshift;\n\tstruct bitmap_storage *store = &bitmap->storage;\n\tunsigned long index = file_page_index(store, chunk);\n\tunsigned long node_offset = 0;\n\n\tif (mddev_is_clustered(bitmap->mddev))\n\t\tnode_offset = bitmap->cluster_slot * store->file_pages;\n\n\tpage = filemap_get_page(&bitmap->storage, chunk);\n\tif (!page)\n\t\treturn;\n\tbit = file_page_offset(&bitmap->storage, chunk);\n\n\t \n\tkaddr = kmap_atomic(page);\n\tif (test_bit(BITMAP_HOSTENDIAN, &bitmap->flags))\n\t\tset_bit(bit, kaddr);\n\telse\n\t\tset_bit_le(bit, kaddr);\n\tkunmap_atomic(kaddr);\n\tpr_debug(\"set file bit %lu page %lu\\n\", bit, index);\n\t \n\tset_page_attr(bitmap, index - node_offset, BITMAP_PAGE_DIRTY);\n}\n\nstatic void md_bitmap_file_clear_bit(struct bitmap *bitmap, sector_t block)\n{\n\tunsigned long bit;\n\tstruct page *page;\n\tvoid *paddr;\n\tunsigned long chunk = block >> bitmap->counts.chunkshift;\n\tstruct bitmap_storage *store = &bitmap->storage;\n\tunsigned long index = file_page_index(store, chunk);\n\tunsigned long node_offset = 0;\n\n\tif (mddev_is_clustered(bitmap->mddev))\n\t\tnode_offset = bitmap->cluster_slot * store->file_pages;\n\n\tpage = filemap_get_page(&bitmap->storage, chunk);\n\tif (!page)\n\t\treturn;\n\tbit = file_page_offset(&bitmap->storage, chunk);\n\tpaddr = kmap_atomic(page);\n\tif (test_bit(BITMAP_HOSTENDIAN, &bitmap->flags))\n\t\tclear_bit(bit, paddr);\n\telse\n\t\tclear_bit_le(bit, paddr);\n\tkunmap_atomic(paddr);\n\tif (!test_page_attr(bitmap, index - node_offset, BITMAP_PAGE_NEEDWRITE)) {\n\t\tset_page_attr(bitmap, index - node_offset, BITMAP_PAGE_PENDING);\n\t\tbitmap->allclean = 0;\n\t}\n}\n\nstatic int md_bitmap_file_test_bit(struct bitmap *bitmap, sector_t block)\n{\n\tunsigned long bit;\n\tstruct page *page;\n\tvoid *paddr;\n\tunsigned long chunk = block >> bitmap->counts.chunkshift;\n\tint set = 0;\n\n\tpage = filemap_get_page(&bitmap->storage, chunk);\n\tif (!page)\n\t\treturn -EINVAL;\n\tbit = file_page_offset(&bitmap->storage, chunk);\n\tpaddr = kmap_atomic(page);\n\tif (test_bit(BITMAP_HOSTENDIAN, &bitmap->flags))\n\t\tset = test_bit(bit, paddr);\n\telse\n\t\tset = test_bit_le(bit, paddr);\n\tkunmap_atomic(paddr);\n\treturn set;\n}\n\n \nvoid md_bitmap_unplug(struct bitmap *bitmap)\n{\n\tunsigned long i;\n\tint dirty, need_write;\n\tint writing = 0;\n\n\tif (!md_bitmap_enabled(bitmap))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < bitmap->storage.file_pages; i++) {\n\t\tdirty = test_and_clear_page_attr(bitmap, i, BITMAP_PAGE_DIRTY);\n\t\tneed_write = test_and_clear_page_attr(bitmap, i,\n\t\t\t\t\t\t      BITMAP_PAGE_NEEDWRITE);\n\t\tif (dirty || need_write) {\n\t\t\tif (!writing) {\n\t\t\t\tmd_bitmap_wait_writes(bitmap);\n\t\t\t\tif (bitmap->mddev->queue)\n\t\t\t\t\tblk_add_trace_msg(bitmap->mddev->queue,\n\t\t\t\t\t\t\t  \"md bitmap_unplug\");\n\t\t\t}\n\t\t\tclear_page_attr(bitmap, i, BITMAP_PAGE_PENDING);\n\t\t\tfilemap_write_page(bitmap, i, false);\n\t\t\twriting = 1;\n\t\t}\n\t}\n\tif (writing)\n\t\tmd_bitmap_wait_writes(bitmap);\n\n\tif (test_bit(BITMAP_WRITE_ERROR, &bitmap->flags))\n\t\tmd_bitmap_file_kick(bitmap);\n}\nEXPORT_SYMBOL(md_bitmap_unplug);\n\nstruct bitmap_unplug_work {\n\tstruct work_struct work;\n\tstruct bitmap *bitmap;\n\tstruct completion *done;\n};\n\nstatic void md_bitmap_unplug_fn(struct work_struct *work)\n{\n\tstruct bitmap_unplug_work *unplug_work =\n\t\tcontainer_of(work, struct bitmap_unplug_work, work);\n\n\tmd_bitmap_unplug(unplug_work->bitmap);\n\tcomplete(unplug_work->done);\n}\n\nvoid md_bitmap_unplug_async(struct bitmap *bitmap)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct bitmap_unplug_work unplug_work;\n\n\tINIT_WORK_ONSTACK(&unplug_work.work, md_bitmap_unplug_fn);\n\tunplug_work.bitmap = bitmap;\n\tunplug_work.done = &done;\n\n\tqueue_work(md_bitmap_wq, &unplug_work.work);\n\twait_for_completion(&done);\n}\nEXPORT_SYMBOL(md_bitmap_unplug_async);\n\nstatic void md_bitmap_set_memory_bits(struct bitmap *bitmap, sector_t offset, int needed);\n\n \nstatic int md_bitmap_init_from_disk(struct bitmap *bitmap, sector_t start)\n{\n\tbool outofdate = test_bit(BITMAP_STALE, &bitmap->flags);\n\tstruct mddev *mddev = bitmap->mddev;\n\tunsigned long chunks = bitmap->counts.chunks;\n\tstruct bitmap_storage *store = &bitmap->storage;\n\tstruct file *file = store->file;\n\tunsigned long node_offset = 0;\n\tunsigned long bit_cnt = 0;\n\tunsigned long i;\n\tint ret;\n\n\tif (!file && !mddev->bitmap_info.offset) {\n\t\t \n\t\tstore->filemap = NULL;\n\t\tstore->file_pages = 0;\n\t\tfor (i = 0; i < chunks ; i++) {\n\t\t\t \n\t\t\tint needed = ((sector_t)(i+1) << (bitmap->counts.chunkshift)\n\t\t\t\t      >= start);\n\t\t\tmd_bitmap_set_memory_bits(bitmap,\n\t\t\t\t\t\t  (sector_t)i << bitmap->counts.chunkshift,\n\t\t\t\t\t\t  needed);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (file && i_size_read(file->f_mapping->host) < store->bytes) {\n\t\tpr_warn(\"%s: bitmap file too short %lu < %lu\\n\",\n\t\t\tbmname(bitmap),\n\t\t\t(unsigned long) i_size_read(file->f_mapping->host),\n\t\t\tstore->bytes);\n\t\tret = -ENOSPC;\n\t\tgoto err;\n\t}\n\n\tif (mddev_is_clustered(mddev))\n\t\tnode_offset = bitmap->cluster_slot * (DIV_ROUND_UP(store->bytes, PAGE_SIZE));\n\n\tfor (i = 0; i < store->file_pages; i++) {\n\t\tstruct page *page = store->filemap[i];\n\t\tint count;\n\n\t\t \n\t\tif (i == store->file_pages - 1)\n\t\t\tcount = store->bytes - i * PAGE_SIZE;\n\t\telse\n\t\t\tcount = PAGE_SIZE;\n\n\t\tif (file)\n\t\t\tret = read_file_page(file, i, bitmap, count, page);\n\t\telse\n\t\t\tret = read_sb_page(mddev, 0, page, i + node_offset,\n\t\t\t\t\t   count);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (outofdate) {\n\t\tpr_warn(\"%s: bitmap file is out of date, doing full recovery\\n\",\n\t\t\tbmname(bitmap));\n\n\t\tfor (i = 0; i < store->file_pages; i++) {\n\t\t\tstruct page *page = store->filemap[i];\n\t\t\tunsigned long offset = 0;\n\t\t\tvoid *paddr;\n\n\t\t\tif (i == 0 && !mddev->bitmap_info.external)\n\t\t\t\toffset = sizeof(bitmap_super_t);\n\n\t\t\t \n\t\t\tpaddr = kmap_atomic(page);\n\t\t\tmemset(paddr + offset, 0xff, PAGE_SIZE - offset);\n\t\t\tkunmap_atomic(paddr);\n\n\t\t\tfilemap_write_page(bitmap, i, true);\n\t\t\tif (test_bit(BITMAP_WRITE_ERROR, &bitmap->flags)) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < chunks; i++) {\n\t\tstruct page *page = filemap_get_page(&bitmap->storage, i);\n\t\tunsigned long bit = file_page_offset(&bitmap->storage, i);\n\t\tvoid *paddr;\n\t\tbool was_set;\n\n\t\tpaddr = kmap_atomic(page);\n\t\tif (test_bit(BITMAP_HOSTENDIAN, &bitmap->flags))\n\t\t\twas_set = test_bit(bit, paddr);\n\t\telse\n\t\t\twas_set = test_bit_le(bit, paddr);\n\t\tkunmap_atomic(paddr);\n\n\t\tif (was_set) {\n\t\t\t \n\t\t\tint needed = ((sector_t)(i+1) << bitmap->counts.chunkshift\n\t\t\t\t      >= start);\n\t\t\tmd_bitmap_set_memory_bits(bitmap,\n\t\t\t\t\t\t  (sector_t)i << bitmap->counts.chunkshift,\n\t\t\t\t\t\t  needed);\n\t\t\tbit_cnt++;\n\t\t}\n\t}\n\n\tpr_debug(\"%s: bitmap initialized from disk: read %lu pages, set %lu of %lu bits\\n\",\n\t\t bmname(bitmap), store->file_pages,\n\t\t bit_cnt, chunks);\n\n\treturn 0;\n\n err:\n\tpr_warn(\"%s: bitmap initialisation failed: %d\\n\",\n\t\tbmname(bitmap), ret);\n\treturn ret;\n}\n\nvoid md_bitmap_write_all(struct bitmap *bitmap)\n{\n\t \n\tint i;\n\n\tif (!bitmap || !bitmap->storage.filemap)\n\t\treturn;\n\tif (bitmap->storage.file)\n\t\t \n\t\treturn;\n\n\tfor (i = 0; i < bitmap->storage.file_pages; i++)\n\t\tset_page_attr(bitmap, i,\n\t\t\t      BITMAP_PAGE_NEEDWRITE);\n\tbitmap->allclean = 0;\n}\n\nstatic void md_bitmap_count_page(struct bitmap_counts *bitmap,\n\t\t\t\t sector_t offset, int inc)\n{\n\tsector_t chunk = offset >> bitmap->chunkshift;\n\tunsigned long page = chunk >> PAGE_COUNTER_SHIFT;\n\tbitmap->bp[page].count += inc;\n\tmd_bitmap_checkfree(bitmap, page);\n}\n\nstatic void md_bitmap_set_pending(struct bitmap_counts *bitmap, sector_t offset)\n{\n\tsector_t chunk = offset >> bitmap->chunkshift;\n\tunsigned long page = chunk >> PAGE_COUNTER_SHIFT;\n\tstruct bitmap_page *bp = &bitmap->bp[page];\n\n\tif (!bp->pending)\n\t\tbp->pending = 1;\n}\n\nstatic bitmap_counter_t *md_bitmap_get_counter(struct bitmap_counts *bitmap,\n\t\t\t\t\t       sector_t offset, sector_t *blocks,\n\t\t\t\t\t       int create);\n\nstatic void mddev_set_timeout(struct mddev *mddev, unsigned long timeout,\n\t\t\t      bool force)\n{\n\tstruct md_thread *thread;\n\n\trcu_read_lock();\n\tthread = rcu_dereference(mddev->thread);\n\n\tif (!thread)\n\t\tgoto out;\n\n\tif (force || thread->timeout < MAX_SCHEDULE_TIMEOUT)\n\t\tthread->timeout = timeout;\n\nout:\n\trcu_read_unlock();\n}\n\n \nvoid md_bitmap_daemon_work(struct mddev *mddev)\n{\n\tstruct bitmap *bitmap;\n\tunsigned long j;\n\tunsigned long nextpage;\n\tsector_t blocks;\n\tstruct bitmap_counts *counts;\n\n\t \n\tmutex_lock(&mddev->bitmap_info.mutex);\n\tbitmap = mddev->bitmap;\n\tif (bitmap == NULL) {\n\t\tmutex_unlock(&mddev->bitmap_info.mutex);\n\t\treturn;\n\t}\n\tif (time_before(jiffies, bitmap->daemon_lastrun\n\t\t\t+ mddev->bitmap_info.daemon_sleep))\n\t\tgoto done;\n\n\tbitmap->daemon_lastrun = jiffies;\n\tif (bitmap->allclean) {\n\t\tmddev_set_timeout(mddev, MAX_SCHEDULE_TIMEOUT, true);\n\t\tgoto done;\n\t}\n\tbitmap->allclean = 1;\n\n\tif (bitmap->mddev->queue)\n\t\tblk_add_trace_msg(bitmap->mddev->queue,\n\t\t\t\t  \"md bitmap_daemon_work\");\n\n\t \n\tfor (j = 0; j < bitmap->storage.file_pages; j++)\n\t\tif (test_and_clear_page_attr(bitmap, j,\n\t\t\t\t\t     BITMAP_PAGE_PENDING))\n\t\t\tset_page_attr(bitmap, j,\n\t\t\t\t      BITMAP_PAGE_NEEDWRITE);\n\n\tif (bitmap->need_sync &&\n\t    mddev->bitmap_info.external == 0) {\n\t\t \n\t\tbitmap_super_t *sb;\n\t\tbitmap->need_sync = 0;\n\t\tif (bitmap->storage.filemap) {\n\t\t\tsb = kmap_atomic(bitmap->storage.sb_page);\n\t\t\tsb->events_cleared =\n\t\t\t\tcpu_to_le64(bitmap->events_cleared);\n\t\t\tkunmap_atomic(sb);\n\t\t\tset_page_attr(bitmap, 0,\n\t\t\t\t      BITMAP_PAGE_NEEDWRITE);\n\t\t}\n\t}\n\t \n\tcounts = &bitmap->counts;\n\tspin_lock_irq(&counts->lock);\n\tnextpage = 0;\n\tfor (j = 0; j < counts->chunks; j++) {\n\t\tbitmap_counter_t *bmc;\n\t\tsector_t  block = (sector_t)j << counts->chunkshift;\n\n\t\tif (j == nextpage) {\n\t\t\tnextpage += PAGE_COUNTER_RATIO;\n\t\t\tif (!counts->bp[j >> PAGE_COUNTER_SHIFT].pending) {\n\t\t\t\tj |= PAGE_COUNTER_MASK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcounts->bp[j >> PAGE_COUNTER_SHIFT].pending = 0;\n\t\t}\n\n\t\tbmc = md_bitmap_get_counter(counts, block, &blocks, 0);\n\t\tif (!bmc) {\n\t\t\tj |= PAGE_COUNTER_MASK;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*bmc == 1 && !bitmap->need_sync) {\n\t\t\t \n\t\t\t*bmc = 0;\n\t\t\tmd_bitmap_count_page(counts, block, -1);\n\t\t\tmd_bitmap_file_clear_bit(bitmap, block);\n\t\t} else if (*bmc && *bmc <= 2) {\n\t\t\t*bmc = 1;\n\t\t\tmd_bitmap_set_pending(counts, block);\n\t\t\tbitmap->allclean = 0;\n\t\t}\n\t}\n\tspin_unlock_irq(&counts->lock);\n\n\tmd_bitmap_wait_writes(bitmap);\n\t \n\tfor (j = 0;\n\t     j < bitmap->storage.file_pages\n\t\t     && !test_bit(BITMAP_STALE, &bitmap->flags);\n\t     j++) {\n\t\tif (test_page_attr(bitmap, j,\n\t\t\t\t   BITMAP_PAGE_DIRTY))\n\t\t\t \n\t\t\tbreak;\n\t\tif (bitmap->storage.filemap &&\n\t\t    test_and_clear_page_attr(bitmap, j,\n\t\t\t\t\t     BITMAP_PAGE_NEEDWRITE))\n\t\t\tfilemap_write_page(bitmap, j, false);\n\t}\n\n done:\n\tif (bitmap->allclean == 0)\n\t\tmddev_set_timeout(mddev, mddev->bitmap_info.daemon_sleep, true);\n\tmutex_unlock(&mddev->bitmap_info.mutex);\n}\n\nstatic bitmap_counter_t *md_bitmap_get_counter(struct bitmap_counts *bitmap,\n\t\t\t\t\t       sector_t offset, sector_t *blocks,\n\t\t\t\t\t       int create)\n__releases(bitmap->lock)\n__acquires(bitmap->lock)\n{\n\t \n\tsector_t chunk = offset >> bitmap->chunkshift;\n\tunsigned long page = chunk >> PAGE_COUNTER_SHIFT;\n\tunsigned long pageoff = (chunk & PAGE_COUNTER_MASK) << COUNTER_BYTE_SHIFT;\n\tsector_t csize;\n\tint err;\n\n\tif (page >= bitmap->pages) {\n\t\t \n\t\treturn NULL;\n\t}\n\terr = md_bitmap_checkpage(bitmap, page, create, 0);\n\n\tif (bitmap->bp[page].hijacked ||\n\t    bitmap->bp[page].map == NULL)\n\t\tcsize = ((sector_t)1) << (bitmap->chunkshift +\n\t\t\t\t\t  PAGE_COUNTER_SHIFT);\n\telse\n\t\tcsize = ((sector_t)1) << bitmap->chunkshift;\n\t*blocks = csize - (offset & (csize - 1));\n\n\tif (err < 0)\n\t\treturn NULL;\n\n\t \n\n\tif (bitmap->bp[page].hijacked) {  \n\t\t \n\t\tint hi = (pageoff > PAGE_COUNTER_MASK);\n\t\treturn  &((bitmap_counter_t *)\n\t\t\t  &bitmap->bp[page].map)[hi];\n\t} else  \n\t\treturn (bitmap_counter_t *)\n\t\t\t&(bitmap->bp[page].map[pageoff]);\n}\n\nint md_bitmap_startwrite(struct bitmap *bitmap, sector_t offset, unsigned long sectors, int behind)\n{\n\tif (!bitmap)\n\t\treturn 0;\n\n\tif (behind) {\n\t\tint bw;\n\t\tatomic_inc(&bitmap->behind_writes);\n\t\tbw = atomic_read(&bitmap->behind_writes);\n\t\tif (bw > bitmap->behind_writes_used)\n\t\t\tbitmap->behind_writes_used = bw;\n\n\t\tpr_debug(\"inc write-behind count %d/%lu\\n\",\n\t\t\t bw, bitmap->mddev->bitmap_info.max_write_behind);\n\t}\n\n\twhile (sectors) {\n\t\tsector_t blocks;\n\t\tbitmap_counter_t *bmc;\n\n\t\tspin_lock_irq(&bitmap->counts.lock);\n\t\tbmc = md_bitmap_get_counter(&bitmap->counts, offset, &blocks, 1);\n\t\tif (!bmc) {\n\t\t\tspin_unlock_irq(&bitmap->counts.lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (unlikely(COUNTER(*bmc) == COUNTER_MAX)) {\n\t\t\tDEFINE_WAIT(__wait);\n\t\t\t \n\t\t\tprepare_to_wait(&bitmap->overflow_wait, &__wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&bitmap->counts.lock);\n\t\t\tschedule();\n\t\t\tfinish_wait(&bitmap->overflow_wait, &__wait);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (*bmc) {\n\t\tcase 0:\n\t\t\tmd_bitmap_file_set_bit(bitmap, offset);\n\t\t\tmd_bitmap_count_page(&bitmap->counts, offset, 1);\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\t\t*bmc = 2;\n\t\t}\n\n\t\t(*bmc)++;\n\n\t\tspin_unlock_irq(&bitmap->counts.lock);\n\n\t\toffset += blocks;\n\t\tif (sectors > blocks)\n\t\t\tsectors -= blocks;\n\t\telse\n\t\t\tsectors = 0;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(md_bitmap_startwrite);\n\nvoid md_bitmap_endwrite(struct bitmap *bitmap, sector_t offset,\n\t\t\tunsigned long sectors, int success, int behind)\n{\n\tif (!bitmap)\n\t\treturn;\n\tif (behind) {\n\t\tif (atomic_dec_and_test(&bitmap->behind_writes))\n\t\t\twake_up(&bitmap->behind_wait);\n\t\tpr_debug(\"dec write-behind count %d/%lu\\n\",\n\t\t\t atomic_read(&bitmap->behind_writes),\n\t\t\t bitmap->mddev->bitmap_info.max_write_behind);\n\t}\n\n\twhile (sectors) {\n\t\tsector_t blocks;\n\t\tunsigned long flags;\n\t\tbitmap_counter_t *bmc;\n\n\t\tspin_lock_irqsave(&bitmap->counts.lock, flags);\n\t\tbmc = md_bitmap_get_counter(&bitmap->counts, offset, &blocks, 0);\n\t\tif (!bmc) {\n\t\t\tspin_unlock_irqrestore(&bitmap->counts.lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tif (success && !bitmap->mddev->degraded &&\n\t\t    bitmap->events_cleared < bitmap->mddev->events) {\n\t\t\tbitmap->events_cleared = bitmap->mddev->events;\n\t\t\tbitmap->need_sync = 1;\n\t\t\tsysfs_notify_dirent_safe(bitmap->sysfs_can_clear);\n\t\t}\n\n\t\tif (!success && !NEEDED(*bmc))\n\t\t\t*bmc |= NEEDED_MASK;\n\n\t\tif (COUNTER(*bmc) == COUNTER_MAX)\n\t\t\twake_up(&bitmap->overflow_wait);\n\n\t\t(*bmc)--;\n\t\tif (*bmc <= 2) {\n\t\t\tmd_bitmap_set_pending(&bitmap->counts, offset);\n\t\t\tbitmap->allclean = 0;\n\t\t}\n\t\tspin_unlock_irqrestore(&bitmap->counts.lock, flags);\n\t\toffset += blocks;\n\t\tif (sectors > blocks)\n\t\t\tsectors -= blocks;\n\t\telse\n\t\t\tsectors = 0;\n\t}\n}\nEXPORT_SYMBOL(md_bitmap_endwrite);\n\nstatic int __bitmap_start_sync(struct bitmap *bitmap, sector_t offset, sector_t *blocks,\n\t\t\t       int degraded)\n{\n\tbitmap_counter_t *bmc;\n\tint rv;\n\tif (bitmap == NULL) { \n\t\t*blocks = 1024;\n\t\treturn 1;  \n\t}\n\tspin_lock_irq(&bitmap->counts.lock);\n\tbmc = md_bitmap_get_counter(&bitmap->counts, offset, blocks, 0);\n\trv = 0;\n\tif (bmc) {\n\t\t \n\t\tif (RESYNC(*bmc))\n\t\t\trv = 1;\n\t\telse if (NEEDED(*bmc)) {\n\t\t\trv = 1;\n\t\t\tif (!degraded) {  \n\t\t\t\t*bmc |= RESYNC_MASK;\n\t\t\t\t*bmc &= ~NEEDED_MASK;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irq(&bitmap->counts.lock);\n\treturn rv;\n}\n\nint md_bitmap_start_sync(struct bitmap *bitmap, sector_t offset, sector_t *blocks,\n\t\t\t int degraded)\n{\n\t \n\tint rv = 0;\n\tsector_t blocks1;\n\n\t*blocks = 0;\n\twhile (*blocks < (PAGE_SIZE>>9)) {\n\t\trv |= __bitmap_start_sync(bitmap, offset,\n\t\t\t\t\t  &blocks1, degraded);\n\t\toffset += blocks1;\n\t\t*blocks += blocks1;\n\t}\n\treturn rv;\n}\nEXPORT_SYMBOL(md_bitmap_start_sync);\n\nvoid md_bitmap_end_sync(struct bitmap *bitmap, sector_t offset, sector_t *blocks, int aborted)\n{\n\tbitmap_counter_t *bmc;\n\tunsigned long flags;\n\n\tif (bitmap == NULL) {\n\t\t*blocks = 1024;\n\t\treturn;\n\t}\n\tspin_lock_irqsave(&bitmap->counts.lock, flags);\n\tbmc = md_bitmap_get_counter(&bitmap->counts, offset, blocks, 0);\n\tif (bmc == NULL)\n\t\tgoto unlock;\n\t \n\tif (RESYNC(*bmc)) {\n\t\t*bmc &= ~RESYNC_MASK;\n\n\t\tif (!NEEDED(*bmc) && aborted)\n\t\t\t*bmc |= NEEDED_MASK;\n\t\telse {\n\t\t\tif (*bmc <= 2) {\n\t\t\t\tmd_bitmap_set_pending(&bitmap->counts, offset);\n\t\t\t\tbitmap->allclean = 0;\n\t\t\t}\n\t\t}\n\t}\n unlock:\n\tspin_unlock_irqrestore(&bitmap->counts.lock, flags);\n}\nEXPORT_SYMBOL(md_bitmap_end_sync);\n\nvoid md_bitmap_close_sync(struct bitmap *bitmap)\n{\n\t \n\tsector_t sector = 0;\n\tsector_t blocks;\n\tif (!bitmap)\n\t\treturn;\n\twhile (sector < bitmap->mddev->resync_max_sectors) {\n\t\tmd_bitmap_end_sync(bitmap, sector, &blocks, 0);\n\t\tsector += blocks;\n\t}\n}\nEXPORT_SYMBOL(md_bitmap_close_sync);\n\nvoid md_bitmap_cond_end_sync(struct bitmap *bitmap, sector_t sector, bool force)\n{\n\tsector_t s = 0;\n\tsector_t blocks;\n\n\tif (!bitmap)\n\t\treturn;\n\tif (sector == 0) {\n\t\tbitmap->last_end_sync = jiffies;\n\t\treturn;\n\t}\n\tif (!force && time_before(jiffies, (bitmap->last_end_sync\n\t\t\t\t  + bitmap->mddev->bitmap_info.daemon_sleep)))\n\t\treturn;\n\twait_event(bitmap->mddev->recovery_wait,\n\t\t   atomic_read(&bitmap->mddev->recovery_active) == 0);\n\n\tbitmap->mddev->curr_resync_completed = sector;\n\tset_bit(MD_SB_CHANGE_CLEAN, &bitmap->mddev->sb_flags);\n\tsector &= ~((1ULL << bitmap->counts.chunkshift) - 1);\n\ts = 0;\n\twhile (s < sector && s < bitmap->mddev->resync_max_sectors) {\n\t\tmd_bitmap_end_sync(bitmap, s, &blocks, 0);\n\t\ts += blocks;\n\t}\n\tbitmap->last_end_sync = jiffies;\n\tsysfs_notify_dirent_safe(bitmap->mddev->sysfs_completed);\n}\nEXPORT_SYMBOL(md_bitmap_cond_end_sync);\n\nvoid md_bitmap_sync_with_cluster(struct mddev *mddev,\n\t\t\t      sector_t old_lo, sector_t old_hi,\n\t\t\t      sector_t new_lo, sector_t new_hi)\n{\n\tstruct bitmap *bitmap = mddev->bitmap;\n\tsector_t sector, blocks = 0;\n\n\tfor (sector = old_lo; sector < new_lo; ) {\n\t\tmd_bitmap_end_sync(bitmap, sector, &blocks, 0);\n\t\tsector += blocks;\n\t}\n\tWARN((blocks > new_lo) && old_lo, \"alignment is not correct for lo\\n\");\n\n\tfor (sector = old_hi; sector < new_hi; ) {\n\t\tmd_bitmap_start_sync(bitmap, sector, &blocks, 0);\n\t\tsector += blocks;\n\t}\n\tWARN((blocks > new_hi) && old_hi, \"alignment is not correct for hi\\n\");\n}\nEXPORT_SYMBOL(md_bitmap_sync_with_cluster);\n\nstatic void md_bitmap_set_memory_bits(struct bitmap *bitmap, sector_t offset, int needed)\n{\n\t \n\n\tsector_t secs;\n\tbitmap_counter_t *bmc;\n\tspin_lock_irq(&bitmap->counts.lock);\n\tbmc = md_bitmap_get_counter(&bitmap->counts, offset, &secs, 1);\n\tif (!bmc) {\n\t\tspin_unlock_irq(&bitmap->counts.lock);\n\t\treturn;\n\t}\n\tif (!*bmc) {\n\t\t*bmc = 2;\n\t\tmd_bitmap_count_page(&bitmap->counts, offset, 1);\n\t\tmd_bitmap_set_pending(&bitmap->counts, offset);\n\t\tbitmap->allclean = 0;\n\t}\n\tif (needed)\n\t\t*bmc |= NEEDED_MASK;\n\tspin_unlock_irq(&bitmap->counts.lock);\n}\n\n \nvoid md_bitmap_dirty_bits(struct bitmap *bitmap, unsigned long s, unsigned long e)\n{\n\tunsigned long chunk;\n\n\tfor (chunk = s; chunk <= e; chunk++) {\n\t\tsector_t sec = (sector_t)chunk << bitmap->counts.chunkshift;\n\t\tmd_bitmap_set_memory_bits(bitmap, sec, 1);\n\t\tmd_bitmap_file_set_bit(bitmap, sec);\n\t\tif (sec < bitmap->mddev->recovery_cp)\n\t\t\t \n\t\t\tbitmap->mddev->recovery_cp = sec;\n\t}\n}\n\n \nvoid md_bitmap_flush(struct mddev *mddev)\n{\n\tstruct bitmap *bitmap = mddev->bitmap;\n\tlong sleep;\n\n\tif (!bitmap)  \n\t\treturn;\n\n\t \n\tsleep = mddev->bitmap_info.daemon_sleep * 2;\n\tbitmap->daemon_lastrun -= sleep;\n\tmd_bitmap_daemon_work(mddev);\n\tbitmap->daemon_lastrun -= sleep;\n\tmd_bitmap_daemon_work(mddev);\n\tbitmap->daemon_lastrun -= sleep;\n\tmd_bitmap_daemon_work(mddev);\n\tif (mddev->bitmap_info.external)\n\t\tmd_super_wait(mddev);\n\tmd_bitmap_update_sb(bitmap);\n}\n\n \nvoid md_bitmap_free(struct bitmap *bitmap)\n{\n\tunsigned long k, pages;\n\tstruct bitmap_page *bp;\n\n\tif (!bitmap)  \n\t\treturn;\n\n\tif (bitmap->sysfs_can_clear)\n\t\tsysfs_put(bitmap->sysfs_can_clear);\n\n\tif (mddev_is_clustered(bitmap->mddev) && bitmap->mddev->cluster_info &&\n\t\tbitmap->cluster_slot == md_cluster_ops->slot_number(bitmap->mddev))\n\t\tmd_cluster_stop(bitmap->mddev);\n\n\t \n\twait_event(bitmap->write_wait,\n\t\t   atomic_read(&bitmap->pending_writes) == 0);\n\n\t \n\tmd_bitmap_file_unmap(&bitmap->storage);\n\n\tbp = bitmap->counts.bp;\n\tpages = bitmap->counts.pages;\n\n\t \n\n\tif (bp)  \n\t\tfor (k = 0; k < pages; k++)\n\t\t\tif (bp[k].map && !bp[k].hijacked)\n\t\t\t\tkfree(bp[k].map);\n\tkfree(bp);\n\tkfree(bitmap);\n}\nEXPORT_SYMBOL(md_bitmap_free);\n\nvoid md_bitmap_wait_behind_writes(struct mddev *mddev)\n{\n\tstruct bitmap *bitmap = mddev->bitmap;\n\n\t \n\tif (bitmap && atomic_read(&bitmap->behind_writes) > 0) {\n\t\tpr_debug(\"md:%s: behind writes in progress - waiting to stop.\\n\",\n\t\t\t mdname(mddev));\n\t\t \n\t\twait_event(bitmap->behind_wait,\n\t\t\t   atomic_read(&bitmap->behind_writes) == 0);\n\t}\n}\n\nvoid md_bitmap_destroy(struct mddev *mddev)\n{\n\tstruct bitmap *bitmap = mddev->bitmap;\n\n\tif (!bitmap)  \n\t\treturn;\n\n\tmd_bitmap_wait_behind_writes(mddev);\n\tif (!mddev->serialize_policy)\n\t\tmddev_destroy_serial_pool(mddev, NULL, true);\n\n\tmutex_lock(&mddev->bitmap_info.mutex);\n\tspin_lock(&mddev->lock);\n\tmddev->bitmap = NULL;  \n\tspin_unlock(&mddev->lock);\n\tmutex_unlock(&mddev->bitmap_info.mutex);\n\tmddev_set_timeout(mddev, MAX_SCHEDULE_TIMEOUT, true);\n\n\tmd_bitmap_free(bitmap);\n}\n\n \nstruct bitmap *md_bitmap_create(struct mddev *mddev, int slot)\n{\n\tstruct bitmap *bitmap;\n\tsector_t blocks = mddev->resync_max_sectors;\n\tstruct file *file = mddev->bitmap_info.file;\n\tint err;\n\tstruct kernfs_node *bm = NULL;\n\n\tBUILD_BUG_ON(sizeof(bitmap_super_t) != 256);\n\n\tBUG_ON(file && mddev->bitmap_info.offset);\n\n\tif (test_bit(MD_HAS_JOURNAL, &mddev->flags)) {\n\t\tpr_notice(\"md/raid:%s: array with journal cannot have bitmap\\n\",\n\t\t\t  mdname(mddev));\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tbitmap = kzalloc(sizeof(*bitmap), GFP_KERNEL);\n\tif (!bitmap)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&bitmap->counts.lock);\n\tatomic_set(&bitmap->pending_writes, 0);\n\tinit_waitqueue_head(&bitmap->write_wait);\n\tinit_waitqueue_head(&bitmap->overflow_wait);\n\tinit_waitqueue_head(&bitmap->behind_wait);\n\n\tbitmap->mddev = mddev;\n\tbitmap->cluster_slot = slot;\n\n\tif (mddev->kobj.sd)\n\t\tbm = sysfs_get_dirent(mddev->kobj.sd, \"bitmap\");\n\tif (bm) {\n\t\tbitmap->sysfs_can_clear = sysfs_get_dirent(bm, \"can_clear\");\n\t\tsysfs_put(bm);\n\t} else\n\t\tbitmap->sysfs_can_clear = NULL;\n\n\tbitmap->storage.file = file;\n\tif (file) {\n\t\tget_file(file);\n\t\t \n\t\tvfs_fsync(file, 1);\n\t}\n\t \n\tif (!mddev->bitmap_info.external) {\n\t\t \n\t\tif (test_and_clear_bit(MD_ARRAY_FIRST_USE, &mddev->flags))\n\t\t\terr = md_bitmap_new_disk_sb(bitmap);\n\t\telse\n\t\t\terr = md_bitmap_read_sb(bitmap);\n\t} else {\n\t\terr = 0;\n\t\tif (mddev->bitmap_info.chunksize == 0 ||\n\t\t    mddev->bitmap_info.daemon_sleep == 0)\n\t\t\t \n\t\t\terr = -EINVAL;\n\t}\n\tif (err)\n\t\tgoto error;\n\n\tbitmap->daemon_lastrun = jiffies;\n\terr = md_bitmap_resize(bitmap, blocks, mddev->bitmap_info.chunksize, 1);\n\tif (err)\n\t\tgoto error;\n\n\tpr_debug(\"created bitmap (%lu pages) for device %s\\n\",\n\t\t bitmap->counts.pages, bmname(bitmap));\n\n\terr = test_bit(BITMAP_WRITE_ERROR, &bitmap->flags) ? -EIO : 0;\n\tif (err)\n\t\tgoto error;\n\n\treturn bitmap;\n error:\n\tmd_bitmap_free(bitmap);\n\treturn ERR_PTR(err);\n}\n\nint md_bitmap_load(struct mddev *mddev)\n{\n\tint err = 0;\n\tsector_t start = 0;\n\tsector_t sector = 0;\n\tstruct bitmap *bitmap = mddev->bitmap;\n\tstruct md_rdev *rdev;\n\n\tif (!bitmap)\n\t\tgoto out;\n\n\trdev_for_each(rdev, mddev)\n\t\tmddev_create_serial_pool(mddev, rdev, true);\n\n\tif (mddev_is_clustered(mddev))\n\t\tmd_cluster_ops->load_bitmaps(mddev, mddev->bitmap_info.nodes);\n\n\t \n\twhile (sector < mddev->resync_max_sectors) {\n\t\tsector_t blocks;\n\t\tmd_bitmap_start_sync(bitmap, sector, &blocks, 0);\n\t\tsector += blocks;\n\t}\n\tmd_bitmap_close_sync(bitmap);\n\n\tif (mddev->degraded == 0\n\t    || bitmap->events_cleared == mddev->events)\n\t\t \n\t\tstart = mddev->recovery_cp;\n\n\tmutex_lock(&mddev->bitmap_info.mutex);\n\terr = md_bitmap_init_from_disk(bitmap, start);\n\tmutex_unlock(&mddev->bitmap_info.mutex);\n\n\tif (err)\n\t\tgoto out;\n\tclear_bit(BITMAP_STALE, &bitmap->flags);\n\n\t \n\tset_bit(MD_RECOVERY_NEEDED, &bitmap->mddev->recovery);\n\n\tmddev_set_timeout(mddev, mddev->bitmap_info.daemon_sleep, true);\n\tmd_wakeup_thread(mddev->thread);\n\n\tmd_bitmap_update_sb(bitmap);\n\n\tif (test_bit(BITMAP_WRITE_ERROR, &bitmap->flags))\n\t\terr = -EIO;\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(md_bitmap_load);\n\n \nstruct bitmap *get_bitmap_from_slot(struct mddev *mddev, int slot)\n{\n\tint rv = 0;\n\tstruct bitmap *bitmap;\n\n\tbitmap = md_bitmap_create(mddev, slot);\n\tif (IS_ERR(bitmap)) {\n\t\trv = PTR_ERR(bitmap);\n\t\treturn ERR_PTR(rv);\n\t}\n\n\trv = md_bitmap_init_from_disk(bitmap, 0);\n\tif (rv) {\n\t\tmd_bitmap_free(bitmap);\n\t\treturn ERR_PTR(rv);\n\t}\n\n\treturn bitmap;\n}\nEXPORT_SYMBOL(get_bitmap_from_slot);\n\n \nint md_bitmap_copy_from_slot(struct mddev *mddev, int slot,\n\t\tsector_t *low, sector_t *high, bool clear_bits)\n{\n\tint rv = 0, i, j;\n\tsector_t block, lo = 0, hi = 0;\n\tstruct bitmap_counts *counts;\n\tstruct bitmap *bitmap;\n\n\tbitmap = get_bitmap_from_slot(mddev, slot);\n\tif (IS_ERR(bitmap)) {\n\t\tpr_err(\"%s can't get bitmap from slot %d\\n\", __func__, slot);\n\t\treturn -1;\n\t}\n\n\tcounts = &bitmap->counts;\n\tfor (j = 0; j < counts->chunks; j++) {\n\t\tblock = (sector_t)j << counts->chunkshift;\n\t\tif (md_bitmap_file_test_bit(bitmap, block)) {\n\t\t\tif (!lo)\n\t\t\t\tlo = block;\n\t\t\thi = block;\n\t\t\tmd_bitmap_file_clear_bit(bitmap, block);\n\t\t\tmd_bitmap_set_memory_bits(mddev->bitmap, block, 1);\n\t\t\tmd_bitmap_file_set_bit(mddev->bitmap, block);\n\t\t}\n\t}\n\n\tif (clear_bits) {\n\t\tmd_bitmap_update_sb(bitmap);\n\t\t \n\t\tfor (i = 0; i < bitmap->storage.file_pages; i++)\n\t\t\tif (test_page_attr(bitmap, i, BITMAP_PAGE_PENDING))\n\t\t\t\tset_page_attr(bitmap, i, BITMAP_PAGE_NEEDWRITE);\n\t\tmd_bitmap_unplug(bitmap);\n\t}\n\tmd_bitmap_unplug(mddev->bitmap);\n\t*low = lo;\n\t*high = hi;\n\tmd_bitmap_free(bitmap);\n\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(md_bitmap_copy_from_slot);\n\n\nvoid md_bitmap_status(struct seq_file *seq, struct bitmap *bitmap)\n{\n\tunsigned long chunk_kb;\n\tstruct bitmap_counts *counts;\n\n\tif (!bitmap)\n\t\treturn;\n\n\tcounts = &bitmap->counts;\n\n\tchunk_kb = bitmap->mddev->bitmap_info.chunksize >> 10;\n\tseq_printf(seq, \"bitmap: %lu/%lu pages [%luKB], \"\n\t\t   \"%lu%s chunk\",\n\t\t   counts->pages - counts->missing_pages,\n\t\t   counts->pages,\n\t\t   (counts->pages - counts->missing_pages)\n\t\t   << (PAGE_SHIFT - 10),\n\t\t   chunk_kb ? chunk_kb : bitmap->mddev->bitmap_info.chunksize,\n\t\t   chunk_kb ? \"KB\" : \"B\");\n\tif (bitmap->storage.file) {\n\t\tseq_printf(seq, \", file: \");\n\t\tseq_file_path(seq, bitmap->storage.file, \" \\t\\n\");\n\t}\n\n\tseq_printf(seq, \"\\n\");\n}\n\nint md_bitmap_resize(struct bitmap *bitmap, sector_t blocks,\n\t\t  int chunksize, int init)\n{\n\t \n\tstruct bitmap_storage store;\n\tstruct bitmap_counts old_counts;\n\tunsigned long chunks;\n\tsector_t block;\n\tsector_t old_blocks, new_blocks;\n\tint chunkshift;\n\tint ret = 0;\n\tlong pages;\n\tstruct bitmap_page *new_bp;\n\n\tif (bitmap->storage.file && !init) {\n\t\tpr_info(\"md: cannot resize file-based bitmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (chunksize == 0) {\n\t\t \n\t\tlong bytes;\n\t\tlong space = bitmap->mddev->bitmap_info.space;\n\n\t\tif (space == 0) {\n\t\t\t \n\t\t\tbytes = DIV_ROUND_UP(bitmap->counts.chunks, 8);\n\t\t\tif (!bitmap->mddev->bitmap_info.external)\n\t\t\t\tbytes += sizeof(bitmap_super_t);\n\t\t\tspace = DIV_ROUND_UP(bytes, 512);\n\t\t\tbitmap->mddev->bitmap_info.space = space;\n\t\t}\n\t\tchunkshift = bitmap->counts.chunkshift;\n\t\tchunkshift--;\n\t\tdo {\n\t\t\t \n\t\t\tchunkshift++;\n\t\t\tchunks = DIV_ROUND_UP_SECTOR_T(blocks, 1 << chunkshift);\n\t\t\tbytes = DIV_ROUND_UP(chunks, 8);\n\t\t\tif (!bitmap->mddev->bitmap_info.external)\n\t\t\t\tbytes += sizeof(bitmap_super_t);\n\t\t} while (bytes > (space << 9) && (chunkshift + BITMAP_BLOCK_SHIFT) <\n\t\t\t(BITS_PER_BYTE * sizeof(((bitmap_super_t *)0)->chunksize) - 1));\n\t} else\n\t\tchunkshift = ffz(~chunksize) - BITMAP_BLOCK_SHIFT;\n\n\tchunks = DIV_ROUND_UP_SECTOR_T(blocks, 1 << chunkshift);\n\tmemset(&store, 0, sizeof(store));\n\tif (bitmap->mddev->bitmap_info.offset || bitmap->mddev->bitmap_info.file)\n\t\tret = md_bitmap_storage_alloc(&store, chunks,\n\t\t\t\t\t      !bitmap->mddev->bitmap_info.external,\n\t\t\t\t\t      mddev_is_clustered(bitmap->mddev)\n\t\t\t\t\t      ? bitmap->cluster_slot : 0);\n\tif (ret) {\n\t\tmd_bitmap_file_unmap(&store);\n\t\tgoto err;\n\t}\n\n\tpages = DIV_ROUND_UP(chunks, PAGE_COUNTER_RATIO);\n\n\tnew_bp = kcalloc(pages, sizeof(*new_bp), GFP_KERNEL);\n\tret = -ENOMEM;\n\tif (!new_bp) {\n\t\tmd_bitmap_file_unmap(&store);\n\t\tgoto err;\n\t}\n\n\tif (!init)\n\t\tbitmap->mddev->pers->quiesce(bitmap->mddev, 1);\n\n\tstore.file = bitmap->storage.file;\n\tbitmap->storage.file = NULL;\n\n\tif (store.sb_page && bitmap->storage.sb_page)\n\t\tmemcpy(page_address(store.sb_page),\n\t\t       page_address(bitmap->storage.sb_page),\n\t\t       sizeof(bitmap_super_t));\n\tspin_lock_irq(&bitmap->counts.lock);\n\tmd_bitmap_file_unmap(&bitmap->storage);\n\tbitmap->storage = store;\n\n\told_counts = bitmap->counts;\n\tbitmap->counts.bp = new_bp;\n\tbitmap->counts.pages = pages;\n\tbitmap->counts.missing_pages = pages;\n\tbitmap->counts.chunkshift = chunkshift;\n\tbitmap->counts.chunks = chunks;\n\tbitmap->mddev->bitmap_info.chunksize = 1UL << (chunkshift +\n\t\t\t\t\t\t     BITMAP_BLOCK_SHIFT);\n\n\tblocks = min(old_counts.chunks << old_counts.chunkshift,\n\t\t     chunks << chunkshift);\n\n\t \n\tif (mddev_is_clustered(bitmap->mddev)) {\n\t\tunsigned long page;\n\t\tfor (page = 0; page < pages; page++) {\n\t\t\tret = md_bitmap_checkpage(&bitmap->counts, page, 1, 1);\n\t\t\tif (ret) {\n\t\t\t\tunsigned long k;\n\n\t\t\t\t \n\t\t\t\tfor (k = 0; k < page; k++) {\n\t\t\t\t\tkfree(new_bp[k].map);\n\t\t\t\t}\n\t\t\t\tkfree(new_bp);\n\n\t\t\t\t \n\t\t\t\tbitmap->counts.bp = old_counts.bp;\n\t\t\t\tbitmap->counts.pages = old_counts.pages;\n\t\t\t\tbitmap->counts.missing_pages = old_counts.pages;\n\t\t\t\tbitmap->counts.chunkshift = old_counts.chunkshift;\n\t\t\t\tbitmap->counts.chunks = old_counts.chunks;\n\t\t\t\tbitmap->mddev->bitmap_info.chunksize =\n\t\t\t\t\t1UL << (old_counts.chunkshift + BITMAP_BLOCK_SHIFT);\n\t\t\t\tblocks = old_counts.chunks << old_counts.chunkshift;\n\t\t\t\tpr_warn(\"Could not pre-allocate in-memory bitmap for cluster raid\\n\");\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbitmap->counts.bp[page].count += 1;\n\t\t}\n\t}\n\n\tfor (block = 0; block < blocks; ) {\n\t\tbitmap_counter_t *bmc_old, *bmc_new;\n\t\tint set;\n\n\t\tbmc_old = md_bitmap_get_counter(&old_counts, block, &old_blocks, 0);\n\t\tset = bmc_old && NEEDED(*bmc_old);\n\n\t\tif (set) {\n\t\t\tbmc_new = md_bitmap_get_counter(&bitmap->counts, block, &new_blocks, 1);\n\t\t\tif (bmc_new) {\n\t\t\t\tif (*bmc_new == 0) {\n\t\t\t\t\t \n\t\t\t\t\tsector_t end = block + new_blocks;\n\t\t\t\t\tsector_t start = block >> chunkshift;\n\n\t\t\t\t\tstart <<= chunkshift;\n\t\t\t\t\twhile (start < end) {\n\t\t\t\t\t\tmd_bitmap_file_set_bit(bitmap, block);\n\t\t\t\t\t\tstart += 1 << chunkshift;\n\t\t\t\t\t}\n\t\t\t\t\t*bmc_new = 2;\n\t\t\t\t\tmd_bitmap_count_page(&bitmap->counts, block, 1);\n\t\t\t\t\tmd_bitmap_set_pending(&bitmap->counts, block);\n\t\t\t\t}\n\t\t\t\t*bmc_new |= NEEDED_MASK;\n\t\t\t}\n\t\t\tif (new_blocks < old_blocks)\n\t\t\t\told_blocks = new_blocks;\n\t\t}\n\t\tblock += old_blocks;\n\t}\n\n\tif (bitmap->counts.bp != old_counts.bp) {\n\t\tunsigned long k;\n\t\tfor (k = 0; k < old_counts.pages; k++)\n\t\t\tif (!old_counts.bp[k].hijacked)\n\t\t\t\tkfree(old_counts.bp[k].map);\n\t\tkfree(old_counts.bp);\n\t}\n\n\tif (!init) {\n\t\tint i;\n\t\twhile (block < (chunks << chunkshift)) {\n\t\t\tbitmap_counter_t *bmc;\n\t\t\tbmc = md_bitmap_get_counter(&bitmap->counts, block, &new_blocks, 1);\n\t\t\tif (bmc) {\n\t\t\t\t \n\t\t\t\tif (*bmc == 0) {\n\t\t\t\t\t*bmc = NEEDED_MASK | 2;\n\t\t\t\t\tmd_bitmap_count_page(&bitmap->counts, block, 1);\n\t\t\t\t\tmd_bitmap_set_pending(&bitmap->counts, block);\n\t\t\t\t}\n\t\t\t}\n\t\t\tblock += new_blocks;\n\t\t}\n\t\tfor (i = 0; i < bitmap->storage.file_pages; i++)\n\t\t\tset_page_attr(bitmap, i, BITMAP_PAGE_DIRTY);\n\t}\n\tspin_unlock_irq(&bitmap->counts.lock);\n\n\tif (!init) {\n\t\tmd_bitmap_unplug(bitmap);\n\t\tbitmap->mddev->pers->quiesce(bitmap->mddev, 0);\n\t}\n\tret = 0;\nerr:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(md_bitmap_resize);\n\nstatic ssize_t\nlocation_show(struct mddev *mddev, char *page)\n{\n\tssize_t len;\n\tif (mddev->bitmap_info.file)\n\t\tlen = sprintf(page, \"file\");\n\telse if (mddev->bitmap_info.offset)\n\t\tlen = sprintf(page, \"%+lld\", (long long)mddev->bitmap_info.offset);\n\telse\n\t\tlen = sprintf(page, \"none\");\n\tlen += sprintf(page+len, \"\\n\");\n\treturn len;\n}\n\nstatic ssize_t\nlocation_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tint rv;\n\n\trv = mddev_lock(mddev);\n\tif (rv)\n\t\treturn rv;\n\tif (mddev->pers) {\n\t\tif (!mddev->pers->quiesce) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tif (mddev->recovery || mddev->sync_thread) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (mddev->bitmap || mddev->bitmap_info.file ||\n\t    mddev->bitmap_info.offset) {\n\t\t \n\t\tif (strncmp(buf, \"none\", 4) != 0) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tif (mddev->pers) {\n\t\t\tmddev_suspend(mddev);\n\t\t\tmd_bitmap_destroy(mddev);\n\t\t\tmddev_resume(mddev);\n\t\t}\n\t\tmddev->bitmap_info.offset = 0;\n\t\tif (mddev->bitmap_info.file) {\n\t\t\tstruct file *f = mddev->bitmap_info.file;\n\t\t\tmddev->bitmap_info.file = NULL;\n\t\t\tfput(f);\n\t\t}\n\t} else {\n\t\t \n\t\tlong long offset;\n\t\tif (strncmp(buf, \"none\", 4) == 0)\n\t\t\t ;\n\t\telse if (strncmp(buf, \"file:\", 5) == 0) {\n\t\t\t \n\t\t\trv = -EINVAL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (buf[0] == '+')\n\t\t\t\trv = kstrtoll(buf+1, 10, &offset);\n\t\t\telse\n\t\t\t\trv = kstrtoll(buf, 10, &offset);\n\t\t\tif (rv)\n\t\t\t\tgoto out;\n\t\t\tif (offset == 0) {\n\t\t\t\trv = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (mddev->bitmap_info.external == 0 &&\n\t\t\t    mddev->major_version == 0 &&\n\t\t\t    offset != mddev->bitmap_info.default_offset) {\n\t\t\t\trv = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmddev->bitmap_info.offset = offset;\n\t\t\tif (mddev->pers) {\n\t\t\t\tstruct bitmap *bitmap;\n\t\t\t\tbitmap = md_bitmap_create(mddev, -1);\n\t\t\t\tmddev_suspend(mddev);\n\t\t\t\tif (IS_ERR(bitmap))\n\t\t\t\t\trv = PTR_ERR(bitmap);\n\t\t\t\telse {\n\t\t\t\t\tmddev->bitmap = bitmap;\n\t\t\t\t\trv = md_bitmap_load(mddev);\n\t\t\t\t\tif (rv)\n\t\t\t\t\t\tmddev->bitmap_info.offset = 0;\n\t\t\t\t}\n\t\t\t\tif (rv) {\n\t\t\t\t\tmd_bitmap_destroy(mddev);\n\t\t\t\t\tmddev_resume(mddev);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmddev_resume(mddev);\n\t\t\t}\n\t\t}\n\t}\n\tif (!mddev->external) {\n\t\t \n\t\tset_bit(MD_SB_CHANGE_DEVS, &mddev->sb_flags);\n\t\tmd_wakeup_thread(mddev->thread);\n\t}\n\trv = 0;\nout:\n\tmddev_unlock(mddev);\n\tif (rv)\n\t\treturn rv;\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_location =\n__ATTR(location, S_IRUGO|S_IWUSR, location_show, location_store);\n\n \nstatic ssize_t\nspace_show(struct mddev *mddev, char *page)\n{\n\treturn sprintf(page, \"%lu\\n\", mddev->bitmap_info.space);\n}\n\nstatic ssize_t\nspace_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tunsigned long sectors;\n\tint rv;\n\n\trv = kstrtoul(buf, 10, &sectors);\n\tif (rv)\n\t\treturn rv;\n\n\tif (sectors == 0)\n\t\treturn -EINVAL;\n\n\tif (mddev->bitmap &&\n\t    sectors < (mddev->bitmap->storage.bytes + 511) >> 9)\n\t\treturn -EFBIG;  \n\n\t \n\tmddev->bitmap_info.space = sectors;\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_space =\n__ATTR(space, S_IRUGO|S_IWUSR, space_show, space_store);\n\nstatic ssize_t\ntimeout_show(struct mddev *mddev, char *page)\n{\n\tssize_t len;\n\tunsigned long secs = mddev->bitmap_info.daemon_sleep / HZ;\n\tunsigned long jifs = mddev->bitmap_info.daemon_sleep % HZ;\n\n\tlen = sprintf(page, \"%lu\", secs);\n\tif (jifs)\n\t\tlen += sprintf(page+len, \".%03u\", jiffies_to_msecs(jifs));\n\tlen += sprintf(page+len, \"\\n\");\n\treturn len;\n}\n\nstatic ssize_t\ntimeout_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\t \n\tunsigned long timeout;\n\tint rv = strict_strtoul_scaled(buf, &timeout, 4);\n\tif (rv)\n\t\treturn rv;\n\n\t \n\tif (timeout >= LONG_MAX / HZ)\n\t\treturn -EINVAL;\n\n\ttimeout = timeout * HZ / 10000;\n\n\tif (timeout >= MAX_SCHEDULE_TIMEOUT)\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT-1;\n\tif (timeout < 1)\n\t\ttimeout = 1;\n\n\tmddev->bitmap_info.daemon_sleep = timeout;\n\tmddev_set_timeout(mddev, timeout, false);\n\tmd_wakeup_thread(mddev->thread);\n\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_timeout =\n__ATTR(time_base, S_IRUGO|S_IWUSR, timeout_show, timeout_store);\n\nstatic ssize_t\nbacklog_show(struct mddev *mddev, char *page)\n{\n\treturn sprintf(page, \"%lu\\n\", mddev->bitmap_info.max_write_behind);\n}\n\nstatic ssize_t\nbacklog_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tunsigned long backlog;\n\tunsigned long old_mwb = mddev->bitmap_info.max_write_behind;\n\tstruct md_rdev *rdev;\n\tbool has_write_mostly = false;\n\tint rv = kstrtoul(buf, 10, &backlog);\n\tif (rv)\n\t\treturn rv;\n\tif (backlog > COUNTER_MAX)\n\t\treturn -EINVAL;\n\n\trv = mddev_lock(mddev);\n\tif (rv)\n\t\treturn rv;\n\n\t \n\trdev_for_each(rdev, mddev) {\n\t\tif (test_bit(WriteMostly, &rdev->flags)) {\n\t\t\thas_write_mostly = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!has_write_mostly) {\n\t\tpr_warn_ratelimited(\"%s: can't set backlog, no write mostly device available\\n\",\n\t\t\t\t    mdname(mddev));\n\t\tmddev_unlock(mddev);\n\t\treturn -EINVAL;\n\t}\n\n\tmddev->bitmap_info.max_write_behind = backlog;\n\tif (!backlog && mddev->serial_info_pool) {\n\t\t \n\t\tif (!mddev->serialize_policy)\n\t\t\tmddev_destroy_serial_pool(mddev, NULL, false);\n\t} else if (backlog && !mddev->serial_info_pool) {\n\t\t \n\t\trdev_for_each(rdev, mddev)\n\t\t\tmddev_create_serial_pool(mddev, rdev, false);\n\t}\n\tif (old_mwb != backlog)\n\t\tmd_bitmap_update_sb(mddev->bitmap);\n\n\tmddev_unlock(mddev);\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_backlog =\n__ATTR(backlog, S_IRUGO|S_IWUSR, backlog_show, backlog_store);\n\nstatic ssize_t\nchunksize_show(struct mddev *mddev, char *page)\n{\n\treturn sprintf(page, \"%lu\\n\", mddev->bitmap_info.chunksize);\n}\n\nstatic ssize_t\nchunksize_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\t \n\tint rv;\n\tunsigned long csize;\n\tif (mddev->bitmap)\n\t\treturn -EBUSY;\n\trv = kstrtoul(buf, 10, &csize);\n\tif (rv)\n\t\treturn rv;\n\tif (csize < 512 ||\n\t    !is_power_of_2(csize))\n\t\treturn -EINVAL;\n\tif (BITS_PER_LONG > 32 && csize >= (1ULL << (BITS_PER_BYTE *\n\t\tsizeof(((bitmap_super_t *)0)->chunksize))))\n\t\treturn -EOVERFLOW;\n\tmddev->bitmap_info.chunksize = csize;\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_chunksize =\n__ATTR(chunksize, S_IRUGO|S_IWUSR, chunksize_show, chunksize_store);\n\nstatic ssize_t metadata_show(struct mddev *mddev, char *page)\n{\n\tif (mddev_is_clustered(mddev))\n\t\treturn sprintf(page, \"clustered\\n\");\n\treturn sprintf(page, \"%s\\n\", (mddev->bitmap_info.external\n\t\t\t\t      ? \"external\" : \"internal\"));\n}\n\nstatic ssize_t metadata_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tif (mddev->bitmap ||\n\t    mddev->bitmap_info.file ||\n\t    mddev->bitmap_info.offset)\n\t\treturn -EBUSY;\n\tif (strncmp(buf, \"external\", 8) == 0)\n\t\tmddev->bitmap_info.external = 1;\n\telse if ((strncmp(buf, \"internal\", 8) == 0) ||\n\t\t\t(strncmp(buf, \"clustered\", 9) == 0))\n\t\tmddev->bitmap_info.external = 0;\n\telse\n\t\treturn -EINVAL;\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_metadata =\n__ATTR(metadata, S_IRUGO|S_IWUSR, metadata_show, metadata_store);\n\nstatic ssize_t can_clear_show(struct mddev *mddev, char *page)\n{\n\tint len;\n\tspin_lock(&mddev->lock);\n\tif (mddev->bitmap)\n\t\tlen = sprintf(page, \"%s\\n\", (mddev->bitmap->need_sync ?\n\t\t\t\t\t     \"false\" : \"true\"));\n\telse\n\t\tlen = sprintf(page, \"\\n\");\n\tspin_unlock(&mddev->lock);\n\treturn len;\n}\n\nstatic ssize_t can_clear_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tif (mddev->bitmap == NULL)\n\t\treturn -ENOENT;\n\tif (strncmp(buf, \"false\", 5) == 0)\n\t\tmddev->bitmap->need_sync = 1;\n\telse if (strncmp(buf, \"true\", 4) == 0) {\n\t\tif (mddev->degraded)\n\t\t\treturn -EBUSY;\n\t\tmddev->bitmap->need_sync = 0;\n\t} else\n\t\treturn -EINVAL;\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_can_clear =\n__ATTR(can_clear, S_IRUGO|S_IWUSR, can_clear_show, can_clear_store);\n\nstatic ssize_t\nbehind_writes_used_show(struct mddev *mddev, char *page)\n{\n\tssize_t ret;\n\tspin_lock(&mddev->lock);\n\tif (mddev->bitmap == NULL)\n\t\tret = sprintf(page, \"0\\n\");\n\telse\n\t\tret = sprintf(page, \"%lu\\n\",\n\t\t\t      mddev->bitmap->behind_writes_used);\n\tspin_unlock(&mddev->lock);\n\treturn ret;\n}\n\nstatic ssize_t\nbehind_writes_used_reset(struct mddev *mddev, const char *buf, size_t len)\n{\n\tif (mddev->bitmap)\n\t\tmddev->bitmap->behind_writes_used = 0;\n\treturn len;\n}\n\nstatic struct md_sysfs_entry max_backlog_used =\n__ATTR(max_backlog_used, S_IRUGO | S_IWUSR,\n       behind_writes_used_show, behind_writes_used_reset);\n\nstatic struct attribute *md_bitmap_attrs[] = {\n\t&bitmap_location.attr,\n\t&bitmap_space.attr,\n\t&bitmap_timeout.attr,\n\t&bitmap_backlog.attr,\n\t&bitmap_chunksize.attr,\n\t&bitmap_metadata.attr,\n\t&bitmap_can_clear.attr,\n\t&max_backlog_used.attr,\n\tNULL\n};\nconst struct attribute_group md_bitmap_group = {\n\t.name = \"bitmap\",\n\t.attrs = md_bitmap_attrs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}