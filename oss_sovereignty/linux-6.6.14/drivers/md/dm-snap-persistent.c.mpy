{
  "module_name": "dm-snap-persistent.c",
  "hash_id": "18353c1b999885331cf8ef75283a57116cd4413821ab4bc688c5e007d046a6b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-snap-persistent.c",
  "human_readable_source": "\n \n\n#include \"dm-exception-store.h\"\n\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/dm-io.h>\n#include <linux/dm-bufio.h>\n\n#define DM_MSG_PREFIX \"persistent snapshot\"\n#define DM_CHUNK_SIZE_DEFAULT_SECTORS 32U\t \n\n#define DM_PREFETCH_CHUNKS\t\t12\n\n \n\n \n\n \n#define SNAP_MAGIC 0x70416e53\n\n \n#define SNAPSHOT_DISK_VERSION 1\n\n#define NUM_SNAPSHOT_HDR_CHUNKS 1\n\nstruct disk_header {\n\t__le32 magic;\n\n\t \n\t__le32 valid;\n\n\t \n\t__le32 version;\n\n\t \n\t__le32 chunk_size;\n} __packed;\n\nstruct disk_exception {\n\t__le64 old_chunk;\n\t__le64 new_chunk;\n} __packed;\n\nstruct core_exception {\n\tuint64_t old_chunk;\n\tuint64_t new_chunk;\n};\n\nstruct commit_callback {\n\tvoid (*callback)(void *ref, int success);\n\tvoid *context;\n};\n\n \nstruct pstore {\n\tstruct dm_exception_store *store;\n\tint version;\n\tint valid;\n\tuint32_t exceptions_per_area;\n\n\t \n\tvoid *area;\n\n\t \n\tvoid *zero_area;\n\n\t \n\tvoid *header_area;\n\n\t \n\tchunk_t current_area;\n\n\t \n\n\tchunk_t next_free;\n\n\t \n\tuint32_t current_committed;\n\n\tatomic_t pending_count;\n\tuint32_t callback_count;\n\tstruct commit_callback *callbacks;\n\tstruct dm_io_client *io_client;\n\n\tstruct workqueue_struct *metadata_wq;\n};\n\nstatic int alloc_area(struct pstore *ps)\n{\n\tint r = -ENOMEM;\n\tsize_t len;\n\n\tlen = ps->store->chunk_size << SECTOR_SHIFT;\n\n\t \n\tps->area = vmalloc(len);\n\tif (!ps->area)\n\t\tgoto err_area;\n\n\tps->zero_area = vzalloc(len);\n\tif (!ps->zero_area)\n\t\tgoto err_zero_area;\n\n\tps->header_area = vmalloc(len);\n\tif (!ps->header_area)\n\t\tgoto err_header_area;\n\n\treturn 0;\n\nerr_header_area:\n\tvfree(ps->zero_area);\n\nerr_zero_area:\n\tvfree(ps->area);\n\nerr_area:\n\treturn r;\n}\n\nstatic void free_area(struct pstore *ps)\n{\n\tvfree(ps->area);\n\tps->area = NULL;\n\tvfree(ps->zero_area);\n\tps->zero_area = NULL;\n\tvfree(ps->header_area);\n\tps->header_area = NULL;\n}\n\nstruct mdata_req {\n\tstruct dm_io_region *where;\n\tstruct dm_io_request *io_req;\n\tstruct work_struct work;\n\tint result;\n};\n\nstatic void do_metadata(struct work_struct *work)\n{\n\tstruct mdata_req *req = container_of(work, struct mdata_req, work);\n\n\treq->result = dm_io(req->io_req, 1, req->where, NULL);\n}\n\n \nstatic int chunk_io(struct pstore *ps, void *area, chunk_t chunk, blk_opf_t opf,\n\t\t    int metadata)\n{\n\tstruct dm_io_region where = {\n\t\t.bdev = dm_snap_cow(ps->store->snap)->bdev,\n\t\t.sector = ps->store->chunk_size * chunk,\n\t\t.count = ps->store->chunk_size,\n\t};\n\tstruct dm_io_request io_req = {\n\t\t.bi_opf = opf,\n\t\t.mem.type = DM_IO_VMA,\n\t\t.mem.ptr.vma = area,\n\t\t.client = ps->io_client,\n\t\t.notify.fn = NULL,\n\t};\n\tstruct mdata_req req;\n\n\tif (!metadata)\n\t\treturn dm_io(&io_req, 1, &where, NULL);\n\n\treq.where = &where;\n\treq.io_req = &io_req;\n\n\t \n\tINIT_WORK_ONSTACK(&req.work, do_metadata);\n\tqueue_work(ps->metadata_wq, &req.work);\n\tflush_workqueue(ps->metadata_wq);\n\tdestroy_work_on_stack(&req.work);\n\n\treturn req.result;\n}\n\n \nstatic chunk_t area_location(struct pstore *ps, chunk_t area)\n{\n\treturn NUM_SNAPSHOT_HDR_CHUNKS + ((ps->exceptions_per_area + 1) * area);\n}\n\nstatic void skip_metadata(struct pstore *ps)\n{\n\tuint32_t stride = ps->exceptions_per_area + 1;\n\tchunk_t next_free = ps->next_free;\n\n\tif (sector_div(next_free, stride) == NUM_SNAPSHOT_HDR_CHUNKS)\n\t\tps->next_free++;\n}\n\n \nstatic int area_io(struct pstore *ps, blk_opf_t opf)\n{\n\tchunk_t chunk = area_location(ps, ps->current_area);\n\n\treturn chunk_io(ps, ps->area, chunk, opf, 0);\n}\n\nstatic void zero_memory_area(struct pstore *ps)\n{\n\tmemset(ps->area, 0, ps->store->chunk_size << SECTOR_SHIFT);\n}\n\nstatic int zero_disk_area(struct pstore *ps, chunk_t area)\n{\n\treturn chunk_io(ps, ps->zero_area, area_location(ps, area),\n\t\t\tREQ_OP_WRITE, 0);\n}\n\nstatic int read_header(struct pstore *ps, int *new_snapshot)\n{\n\tint r;\n\tstruct disk_header *dh;\n\tunsigned int chunk_size;\n\tint chunk_size_supplied = 1;\n\tchar *chunk_err;\n\n\t \n\tif (!ps->store->chunk_size) {\n\t\tps->store->chunk_size = max(DM_CHUNK_SIZE_DEFAULT_SECTORS,\n\t\t    bdev_logical_block_size(dm_snap_cow(ps->store->snap)->\n\t\t\t\t\t    bdev) >> 9);\n\t\tps->store->chunk_mask = ps->store->chunk_size - 1;\n\t\tps->store->chunk_shift = __ffs(ps->store->chunk_size);\n\t\tchunk_size_supplied = 0;\n\t}\n\n\tps->io_client = dm_io_client_create();\n\tif (IS_ERR(ps->io_client))\n\t\treturn PTR_ERR(ps->io_client);\n\n\tr = alloc_area(ps);\n\tif (r)\n\t\treturn r;\n\n\tr = chunk_io(ps, ps->header_area, 0, REQ_OP_READ, 1);\n\tif (r)\n\t\tgoto bad;\n\n\tdh = ps->header_area;\n\n\tif (le32_to_cpu(dh->magic) == 0) {\n\t\t*new_snapshot = 1;\n\t\treturn 0;\n\t}\n\n\tif (le32_to_cpu(dh->magic) != SNAP_MAGIC) {\n\t\tDMWARN(\"Invalid or corrupt snapshot\");\n\t\tr = -ENXIO;\n\t\tgoto bad;\n\t}\n\n\t*new_snapshot = 0;\n\tps->valid = le32_to_cpu(dh->valid);\n\tps->version = le32_to_cpu(dh->version);\n\tchunk_size = le32_to_cpu(dh->chunk_size);\n\n\tif (ps->store->chunk_size == chunk_size)\n\t\treturn 0;\n\n\tif (chunk_size_supplied)\n\t\tDMWARN(\"chunk size %u in device metadata overrides table chunk size of %u.\",\n\t\t       chunk_size, ps->store->chunk_size);\n\n\t \n\tfree_area(ps);\n\n\tr = dm_exception_store_set_chunk_size(ps->store, chunk_size,\n\t\t\t\t\t      &chunk_err);\n\tif (r) {\n\t\tDMERR(\"invalid on-disk chunk size %u: %s.\",\n\t\t      chunk_size, chunk_err);\n\t\treturn r;\n\t}\n\n\tr = alloc_area(ps);\n\treturn r;\n\nbad:\n\tfree_area(ps);\n\treturn r;\n}\n\nstatic int write_header(struct pstore *ps)\n{\n\tstruct disk_header *dh;\n\n\tmemset(ps->header_area, 0, ps->store->chunk_size << SECTOR_SHIFT);\n\n\tdh = ps->header_area;\n\tdh->magic = cpu_to_le32(SNAP_MAGIC);\n\tdh->valid = cpu_to_le32(ps->valid);\n\tdh->version = cpu_to_le32(ps->version);\n\tdh->chunk_size = cpu_to_le32(ps->store->chunk_size);\n\n\treturn chunk_io(ps, ps->header_area, 0, REQ_OP_WRITE, 1);\n}\n\n \nstatic struct disk_exception *get_exception(struct pstore *ps, void *ps_area,\n\t\t\t\t\t    uint32_t index)\n{\n\tBUG_ON(index >= ps->exceptions_per_area);\n\n\treturn ((struct disk_exception *) ps_area) + index;\n}\n\nstatic void read_exception(struct pstore *ps, void *ps_area,\n\t\t\t   uint32_t index, struct core_exception *result)\n{\n\tstruct disk_exception *de = get_exception(ps, ps_area, index);\n\n\t \n\tresult->old_chunk = le64_to_cpu(de->old_chunk);\n\tresult->new_chunk = le64_to_cpu(de->new_chunk);\n}\n\nstatic void write_exception(struct pstore *ps,\n\t\t\t    uint32_t index, struct core_exception *e)\n{\n\tstruct disk_exception *de = get_exception(ps, ps->area, index);\n\n\t \n\tde->old_chunk = cpu_to_le64(e->old_chunk);\n\tde->new_chunk = cpu_to_le64(e->new_chunk);\n}\n\nstatic void clear_exception(struct pstore *ps, uint32_t index)\n{\n\tstruct disk_exception *de = get_exception(ps, ps->area, index);\n\n\t \n\tde->old_chunk = 0;\n\tde->new_chunk = 0;\n}\n\n \nstatic int insert_exceptions(struct pstore *ps, void *ps_area,\n\t\t\t     int (*callback)(void *callback_context,\n\t\t\t\t\t     chunk_t old, chunk_t new),\n\t\t\t     void *callback_context,\n\t\t\t     int *full)\n{\n\tint r;\n\tunsigned int i;\n\tstruct core_exception e;\n\n\t \n\t*full = 1;\n\n\tfor (i = 0; i < ps->exceptions_per_area; i++) {\n\t\tread_exception(ps, ps_area, i, &e);\n\n\t\t \n\t\tif (e.new_chunk == 0LL) {\n\t\t\tps->current_committed = i;\n\t\t\t*full = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ps->next_free <= e.new_chunk)\n\t\t\tps->next_free = e.new_chunk + 1;\n\n\t\t \n\t\tr = callback(callback_context, e.old_chunk, e.new_chunk);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_exceptions(struct pstore *ps,\n\t\t\t   int (*callback)(void *callback_context, chunk_t old,\n\t\t\t\t\t   chunk_t new),\n\t\t\t   void *callback_context)\n{\n\tint r, full = 1;\n\tstruct dm_bufio_client *client;\n\tchunk_t prefetch_area = 0;\n\n\tclient = dm_bufio_client_create(dm_snap_cow(ps->store->snap)->bdev,\n\t\t\t\t\tps->store->chunk_size << SECTOR_SHIFT,\n\t\t\t\t\t1, 0, NULL, NULL, 0);\n\n\tif (IS_ERR(client))\n\t\treturn PTR_ERR(client);\n\n\t \n\tdm_bufio_set_minimum_buffers(client, 1 + DM_PREFETCH_CHUNKS);\n\n\t \n\tfor (ps->current_area = 0; full; ps->current_area++) {\n\t\tstruct dm_buffer *bp;\n\t\tvoid *area;\n\t\tchunk_t chunk;\n\n\t\tif (unlikely(prefetch_area < ps->current_area))\n\t\t\tprefetch_area = ps->current_area;\n\n\t\tif (DM_PREFETCH_CHUNKS) {\n\t\t\tdo {\n\t\t\t\tchunk_t pf_chunk = area_location(ps, prefetch_area);\n\n\t\t\t\tif (unlikely(pf_chunk >= dm_bufio_get_device_size(client)))\n\t\t\t\t\tbreak;\n\t\t\t\tdm_bufio_prefetch(client, pf_chunk, 1);\n\t\t\t\tprefetch_area++;\n\t\t\t\tif (unlikely(!prefetch_area))\n\t\t\t\t\tbreak;\n\t\t\t} while (prefetch_area <= ps->current_area + DM_PREFETCH_CHUNKS);\n\t\t}\n\n\t\tchunk = area_location(ps, ps->current_area);\n\n\t\tarea = dm_bufio_read(client, chunk, &bp);\n\t\tif (IS_ERR(area)) {\n\t\t\tr = PTR_ERR(area);\n\t\t\tgoto ret_destroy_bufio;\n\t\t}\n\n\t\tr = insert_exceptions(ps, area, callback, callback_context,\n\t\t\t\t      &full);\n\n\t\tif (!full)\n\t\t\tmemcpy(ps->area, area, ps->store->chunk_size << SECTOR_SHIFT);\n\n\t\tdm_bufio_release(bp);\n\n\t\tdm_bufio_forget(client, chunk);\n\n\t\tif (unlikely(r))\n\t\t\tgoto ret_destroy_bufio;\n\t}\n\n\tps->current_area--;\n\n\tskip_metadata(ps);\n\n\tr = 0;\n\nret_destroy_bufio:\n\tdm_bufio_client_destroy(client);\n\n\treturn r;\n}\n\nstatic struct pstore *get_info(struct dm_exception_store *store)\n{\n\treturn store->context;\n}\n\nstatic void persistent_usage(struct dm_exception_store *store,\n\t\t\t     sector_t *total_sectors,\n\t\t\t     sector_t *sectors_allocated,\n\t\t\t     sector_t *metadata_sectors)\n{\n\tstruct pstore *ps = get_info(store);\n\n\t*sectors_allocated = ps->next_free * store->chunk_size;\n\t*total_sectors = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\n\t \n\t*metadata_sectors = (ps->current_area + 1 + NUM_SNAPSHOT_HDR_CHUNKS) *\n\t\t\t    store->chunk_size;\n}\n\nstatic void persistent_dtr(struct dm_exception_store *store)\n{\n\tstruct pstore *ps = get_info(store);\n\n\tdestroy_workqueue(ps->metadata_wq);\n\n\t \n\tif (ps->io_client)\n\t\tdm_io_client_destroy(ps->io_client);\n\tfree_area(ps);\n\n\t \n\tkvfree(ps->callbacks);\n\n\tkfree(ps);\n}\n\nstatic int persistent_read_metadata(struct dm_exception_store *store,\n\t\t\t\t    int (*callback)(void *callback_context,\n\t\t\t\t\t\t    chunk_t old, chunk_t new),\n\t\t\t\t    void *callback_context)\n{\n\tint r, new_snapshot;\n\tstruct pstore *ps = get_info(store);\n\n\t \n\tr = read_header(ps, &new_snapshot);\n\tif (r)\n\t\treturn r;\n\n\t \n\tps->exceptions_per_area = (ps->store->chunk_size << SECTOR_SHIFT) /\n\t\t\t\t  sizeof(struct disk_exception);\n\tps->callbacks = kvcalloc(ps->exceptions_per_area,\n\t\t\t\t sizeof(*ps->callbacks), GFP_KERNEL);\n\tif (!ps->callbacks)\n\t\treturn -ENOMEM;\n\n\t \n\tif (new_snapshot) {\n\t\tr = write_header(ps);\n\t\tif (r) {\n\t\t\tDMWARN(\"write_header failed\");\n\t\t\treturn r;\n\t\t}\n\n\t\tps->current_area = 0;\n\t\tzero_memory_area(ps);\n\t\tr = zero_disk_area(ps, 0);\n\t\tif (r)\n\t\t\tDMWARN(\"zero_disk_area(0) failed\");\n\t\treturn r;\n\t}\n\t \n\tif (ps->version != SNAPSHOT_DISK_VERSION) {\n\t\tDMWARN(\"unable to handle snapshot disk version %d\",\n\t\t       ps->version);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!ps->valid)\n\t\treturn 1;\n\n\t \n\tr = read_exceptions(ps, callback, callback_context);\n\n\treturn r;\n}\n\nstatic int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\n\t \n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\n\te->new_chunk = ps->next_free;\n\n\t \n\tps->next_free++;\n\tskip_metadata(ps);\n\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}\n\nstatic void persistent_commit_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e, int valid,\n\t\t\t\t\tvoid (*callback)(void *, int success),\n\t\t\t\t\tvoid *callback_context)\n{\n\tunsigned int i;\n\tstruct pstore *ps = get_info(store);\n\tstruct core_exception ce;\n\tstruct commit_callback *cb;\n\n\tif (!valid)\n\t\tps->valid = 0;\n\n\tce.old_chunk = e->old_chunk;\n\tce.new_chunk = e->new_chunk;\n\twrite_exception(ps, ps->current_committed++, &ce);\n\n\t \n\tcb = ps->callbacks + ps->callback_count++;\n\tcb->callback = callback;\n\tcb->context = callback_context;\n\n\t \n\tif (!atomic_dec_and_test(&ps->pending_count) &&\n\t    (ps->current_committed != ps->exceptions_per_area))\n\t\treturn;\n\n\t \n\tif ((ps->current_committed == ps->exceptions_per_area) &&\n\t    zero_disk_area(ps, ps->current_area + 1))\n\t\tps->valid = 0;\n\n\t \n\tif (ps->valid && area_io(ps, REQ_OP_WRITE | REQ_PREFLUSH | REQ_FUA |\n\t\t\t\t REQ_SYNC))\n\t\tps->valid = 0;\n\n\t \n\tif (ps->current_committed == ps->exceptions_per_area) {\n\t\tps->current_committed = 0;\n\t\tps->current_area++;\n\t\tzero_memory_area(ps);\n\t}\n\n\tfor (i = 0; i < ps->callback_count; i++) {\n\t\tcb = ps->callbacks + i;\n\t\tcb->callback(cb->context, ps->valid);\n\t}\n\n\tps->callback_count = 0;\n}\n\nstatic int persistent_prepare_merge(struct dm_exception_store *store,\n\t\t\t\t    chunk_t *last_old_chunk,\n\t\t\t\t    chunk_t *last_new_chunk)\n{\n\tstruct pstore *ps = get_info(store);\n\tstruct core_exception ce;\n\tint nr_consecutive;\n\tint r;\n\n\t \n\tif (!ps->current_committed) {\n\t\t \n\t\tif (!ps->current_area)\n\t\t\treturn 0;\n\n\t\tps->current_area--;\n\t\tr = area_io(ps, REQ_OP_READ);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tps->current_committed = ps->exceptions_per_area;\n\t}\n\n\tread_exception(ps, ps->area, ps->current_committed - 1, &ce);\n\t*last_old_chunk = ce.old_chunk;\n\t*last_new_chunk = ce.new_chunk;\n\n\t \n\tfor (nr_consecutive = 1; nr_consecutive < ps->current_committed;\n\t     nr_consecutive++) {\n\t\tread_exception(ps, ps->area,\n\t\t\t       ps->current_committed - 1 - nr_consecutive, &ce);\n\t\tif (ce.old_chunk != *last_old_chunk - nr_consecutive ||\n\t\t    ce.new_chunk != *last_new_chunk - nr_consecutive)\n\t\t\tbreak;\n\t}\n\n\treturn nr_consecutive;\n}\n\nstatic int persistent_commit_merge(struct dm_exception_store *store,\n\t\t\t\t   int nr_merged)\n{\n\tint r, i;\n\tstruct pstore *ps = get_info(store);\n\n\tBUG_ON(nr_merged > ps->current_committed);\n\n\tfor (i = 0; i < nr_merged; i++)\n\t\tclear_exception(ps, ps->current_committed - 1 - i);\n\n\tr = area_io(ps, REQ_OP_WRITE | REQ_PREFLUSH | REQ_FUA);\n\tif (r < 0)\n\t\treturn r;\n\n\tps->current_committed -= nr_merged;\n\n\t \n\tps->next_free = area_location(ps, ps->current_area) +\n\t\t\tps->current_committed + 1;\n\n\treturn 0;\n}\n\nstatic void persistent_drop_snapshot(struct dm_exception_store *store)\n{\n\tstruct pstore *ps = get_info(store);\n\n\tps->valid = 0;\n\tif (write_header(ps))\n\t\tDMWARN(\"write header failed\");\n}\n\nstatic int persistent_ctr(struct dm_exception_store *store, char *options)\n{\n\tstruct pstore *ps;\n\tint r;\n\n\t \n\tps = kzalloc(sizeof(*ps), GFP_KERNEL);\n\tif (!ps)\n\t\treturn -ENOMEM;\n\n\tps->store = store;\n\tps->valid = 1;\n\tps->version = SNAPSHOT_DISK_VERSION;\n\tps->area = NULL;\n\tps->zero_area = NULL;\n\tps->header_area = NULL;\n\tps->next_free = NUM_SNAPSHOT_HDR_CHUNKS + 1;  \n\tps->current_committed = 0;\n\n\tps->callback_count = 0;\n\tatomic_set(&ps->pending_count, 0);\n\tps->callbacks = NULL;\n\n\tps->metadata_wq = alloc_workqueue(\"ksnaphd\", WQ_MEM_RECLAIM, 0);\n\tif (!ps->metadata_wq) {\n\t\tDMERR(\"couldn't start header metadata update thread\");\n\t\tr = -ENOMEM;\n\t\tgoto err_workqueue;\n\t}\n\n\tif (options) {\n\t\tchar overflow = toupper(options[0]);\n\n\t\tif (overflow == 'O')\n\t\t\tstore->userspace_supports_overflow = true;\n\t\telse {\n\t\t\tDMERR(\"Unsupported persistent store option: %s\", options);\n\t\t\tr = -EINVAL;\n\t\t\tgoto err_options;\n\t\t}\n\t}\n\n\tstore->context = ps;\n\n\treturn 0;\n\nerr_options:\n\tdestroy_workqueue(ps->metadata_wq);\nerr_workqueue:\n\tkfree(ps);\n\n\treturn r;\n}\n\nstatic unsigned int persistent_status(struct dm_exception_store *store,\n\t\t\t\t  status_type_t status, char *result,\n\t\t\t\t  unsigned int maxlen)\n{\n\tunsigned int sz = 0;\n\n\tswitch (status) {\n\tcase STATUSTYPE_INFO:\n\t\tbreak;\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\" %s %llu\", store->userspace_supports_overflow ? \"PO\" : \"P\",\n\t\t       (unsigned long long)store->chunk_size);\n\t\tbreak;\n\tcase STATUSTYPE_IMA:\n\t\t*result = '\\0';\n\t\tbreak;\n\t}\n\n\treturn sz;\n}\n\nstatic struct dm_exception_store_type _persistent_type = {\n\t.name = \"persistent\",\n\t.module = THIS_MODULE,\n\t.ctr = persistent_ctr,\n\t.dtr = persistent_dtr,\n\t.read_metadata = persistent_read_metadata,\n\t.prepare_exception = persistent_prepare_exception,\n\t.commit_exception = persistent_commit_exception,\n\t.prepare_merge = persistent_prepare_merge,\n\t.commit_merge = persistent_commit_merge,\n\t.drop_snapshot = persistent_drop_snapshot,\n\t.usage = persistent_usage,\n\t.status = persistent_status,\n};\n\nstatic struct dm_exception_store_type _persistent_compat_type = {\n\t.name = \"P\",\n\t.module = THIS_MODULE,\n\t.ctr = persistent_ctr,\n\t.dtr = persistent_dtr,\n\t.read_metadata = persistent_read_metadata,\n\t.prepare_exception = persistent_prepare_exception,\n\t.commit_exception = persistent_commit_exception,\n\t.prepare_merge = persistent_prepare_merge,\n\t.commit_merge = persistent_commit_merge,\n\t.drop_snapshot = persistent_drop_snapshot,\n\t.usage = persistent_usage,\n\t.status = persistent_status,\n};\n\nint dm_persistent_snapshot_init(void)\n{\n\tint r;\n\n\tr = dm_exception_store_type_register(&_persistent_type);\n\tif (r) {\n\t\tDMERR(\"Unable to register persistent exception store type\");\n\t\treturn r;\n\t}\n\n\tr = dm_exception_store_type_register(&_persistent_compat_type);\n\tif (r) {\n\t\tDMERR(\"Unable to register old-style persistent exception store type\");\n\t\tdm_exception_store_type_unregister(&_persistent_type);\n\t\treturn r;\n\t}\n\n\treturn r;\n}\n\nvoid dm_persistent_snapshot_exit(void)\n{\n\tdm_exception_store_type_unregister(&_persistent_type);\n\tdm_exception_store_type_unregister(&_persistent_compat_type);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}