{
  "module_name": "dm-zone.c",
  "hash_id": "96b423661b8545dad4153be91910750d7f8c6583212d53cbd68b55516b134265",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-zone.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/slab.h>\n#include <linux/bitmap.h>\n\n#include \"dm-core.h\"\n\n#define DM_MSG_PREFIX \"zone\"\n\n#define DM_ZONE_INVALID_WP_OFST\t\tUINT_MAX\n\n \nstatic int dm_blk_do_report_zones(struct mapped_device *md, struct dm_table *t,\n\t\t\t\t  sector_t sector, unsigned int nr_zones,\n\t\t\t\t  report_zones_cb cb, void *data)\n{\n\tstruct gendisk *disk = md->disk;\n\tint ret;\n\tstruct dm_report_zones_args args = {\n\t\t.next_sector = sector,\n\t\t.orig_data = data,\n\t\t.orig_cb = cb,\n\t};\n\n\tdo {\n\t\tstruct dm_target *tgt;\n\n\t\ttgt = dm_table_find_target(t, args.next_sector);\n\t\tif (WARN_ON_ONCE(!tgt->type->report_zones))\n\t\t\treturn -EIO;\n\n\t\targs.tgt = tgt;\n\t\tret = tgt->type->report_zones(tgt, &args,\n\t\t\t\t\t      nr_zones - args.zone_idx);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} while (args.zone_idx < nr_zones &&\n\t\t args.next_sector < get_capacity(disk));\n\n\treturn args.zone_idx;\n}\n\n \nint dm_blk_report_zones(struct gendisk *disk, sector_t sector,\n\t\t\tunsigned int nr_zones, report_zones_cb cb, void *data)\n{\n\tstruct mapped_device *md = disk->private_data;\n\tstruct dm_table *map;\n\tint srcu_idx, ret;\n\n\tif (dm_suspended_md(md))\n\t\treturn -EAGAIN;\n\n\tmap = dm_get_live_table(md, &srcu_idx);\n\tif (!map)\n\t\treturn -EIO;\n\n\tret = dm_blk_do_report_zones(md, map, sector, nr_zones, cb, data);\n\n\tdm_put_live_table(md, srcu_idx);\n\n\treturn ret;\n}\n\nstatic int dm_report_zones_cb(struct blk_zone *zone, unsigned int idx,\n\t\t\t      void *data)\n{\n\tstruct dm_report_zones_args *args = data;\n\tsector_t sector_diff = args->tgt->begin - args->start;\n\n\t \n\tif (zone->start >= args->start + args->tgt->len)\n\t\treturn 0;\n\n\t \n\tzone->start += sector_diff;\n\tif (zone->type != BLK_ZONE_TYPE_CONVENTIONAL) {\n\t\tif (zone->cond == BLK_ZONE_COND_FULL)\n\t\t\tzone->wp = zone->start + zone->len;\n\t\telse if (zone->cond == BLK_ZONE_COND_EMPTY)\n\t\t\tzone->wp = zone->start;\n\t\telse\n\t\t\tzone->wp += sector_diff;\n\t}\n\n\targs->next_sector = zone->start + zone->len;\n\treturn args->orig_cb(zone, args->zone_idx++, args->orig_data);\n}\n\n \nint dm_report_zones(struct block_device *bdev, sector_t start, sector_t sector,\n\t\t    struct dm_report_zones_args *args, unsigned int nr_zones)\n{\n\t \n\targs->start = start;\n\n\treturn blkdev_report_zones(bdev, sector, nr_zones,\n\t\t\t\t   dm_report_zones_cb, args);\n}\nEXPORT_SYMBOL_GPL(dm_report_zones);\n\nbool dm_is_zone_write(struct mapped_device *md, struct bio *bio)\n{\n\tstruct request_queue *q = md->queue;\n\n\tif (!blk_queue_is_zoned(q))\n\t\treturn false;\n\n\tswitch (bio_op(bio)) {\n\tcase REQ_OP_WRITE_ZEROES:\n\tcase REQ_OP_WRITE:\n\t\treturn !op_is_flush(bio->bi_opf) && bio_sectors(bio);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nvoid dm_cleanup_zoned_dev(struct mapped_device *md)\n{\n\tif (md->disk) {\n\t\tbitmap_free(md->disk->conv_zones_bitmap);\n\t\tmd->disk->conv_zones_bitmap = NULL;\n\t\tbitmap_free(md->disk->seq_zones_wlock);\n\t\tmd->disk->seq_zones_wlock = NULL;\n\t}\n\n\tkvfree(md->zwp_offset);\n\tmd->zwp_offset = NULL;\n\tmd->nr_zones = 0;\n}\n\nstatic unsigned int dm_get_zone_wp_offset(struct blk_zone *zone)\n{\n\tswitch (zone->cond) {\n\tcase BLK_ZONE_COND_IMP_OPEN:\n\tcase BLK_ZONE_COND_EXP_OPEN:\n\tcase BLK_ZONE_COND_CLOSED:\n\t\treturn zone->wp - zone->start;\n\tcase BLK_ZONE_COND_FULL:\n\t\treturn zone->len;\n\tcase BLK_ZONE_COND_EMPTY:\n\tcase BLK_ZONE_COND_NOT_WP:\n\tcase BLK_ZONE_COND_OFFLINE:\n\tcase BLK_ZONE_COND_READONLY:\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n}\n\nstatic int dm_zone_revalidate_cb(struct blk_zone *zone, unsigned int idx,\n\t\t\t\t void *data)\n{\n\tstruct mapped_device *md = data;\n\tstruct gendisk *disk = md->disk;\n\n\tswitch (zone->type) {\n\tcase BLK_ZONE_TYPE_CONVENTIONAL:\n\t\tif (!disk->conv_zones_bitmap) {\n\t\t\tdisk->conv_zones_bitmap = bitmap_zalloc(disk->nr_zones,\n\t\t\t\t\t\t\t\tGFP_NOIO);\n\t\t\tif (!disk->conv_zones_bitmap)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tset_bit(idx, disk->conv_zones_bitmap);\n\t\tbreak;\n\tcase BLK_ZONE_TYPE_SEQWRITE_REQ:\n\tcase BLK_ZONE_TYPE_SEQWRITE_PREF:\n\t\tif (!disk->seq_zones_wlock) {\n\t\t\tdisk->seq_zones_wlock = bitmap_zalloc(disk->nr_zones,\n\t\t\t\t\t\t\t      GFP_NOIO);\n\t\t\tif (!disk->seq_zones_wlock)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!md->zwp_offset) {\n\t\t\tmd->zwp_offset =\n\t\t\t\tkvcalloc(disk->nr_zones, sizeof(unsigned int),\n\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!md->zwp_offset)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmd->zwp_offset[idx] = dm_get_zone_wp_offset(zone);\n\n\t\tbreak;\n\tdefault:\n\t\tDMERR(\"Invalid zone type 0x%x at sectors %llu\",\n\t\t      (int)zone->type, zone->start);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dm_revalidate_zones(struct mapped_device *md, struct dm_table *t)\n{\n\tstruct gendisk *disk = md->disk;\n\tunsigned int noio_flag;\n\tint ret;\n\n\t \n\tif (!disk->nr_zones || disk->nr_zones != md->nr_zones)\n\t\tdm_cleanup_zoned_dev(md);\n\tif (md->nr_zones)\n\t\treturn 0;\n\n\t \n\tnoio_flag = memalloc_noio_save();\n\tret = dm_blk_do_report_zones(md, t, 0, disk->nr_zones,\n\t\t\t\t     dm_zone_revalidate_cb, md);\n\tmemalloc_noio_restore(noio_flag);\n\tif (ret < 0)\n\t\tgoto err;\n\tif (ret != disk->nr_zones) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tmd->nr_zones = disk->nr_zones;\n\n\treturn 0;\n\nerr:\n\tDMERR(\"Revalidate zones failed %d\", ret);\n\tdm_cleanup_zoned_dev(md);\n\treturn ret;\n}\n\nstatic int device_not_zone_append_capable(struct dm_target *ti,\n\t\t\t\t\t  struct dm_dev *dev, sector_t start,\n\t\t\t\t\t  sector_t len, void *data)\n{\n\treturn !bdev_is_zoned(dev->bdev);\n}\n\nstatic bool dm_table_supports_zone_append(struct dm_table *t)\n{\n\tfor (unsigned int i = 0; i < t->num_targets; i++) {\n\t\tstruct dm_target *ti = dm_table_get_target(t, i);\n\n\t\tif (ti->emulate_zone_append)\n\t\t\treturn false;\n\n\t\tif (!ti->type->iterate_devices ||\n\t\t    ti->type->iterate_devices(ti, device_not_zone_append_capable, NULL))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint dm_set_zones_restrictions(struct dm_table *t, struct request_queue *q)\n{\n\tstruct mapped_device *md = t->md;\n\n\t \n\tWARN_ON_ONCE(queue_is_mq(q));\n\tmd->disk->nr_zones = bdev_nr_zones(md->disk->part0);\n\n\t \n\tif (dm_table_supports_zone_append(t)) {\n\t\tclear_bit(DMF_EMULATE_ZONE_APPEND, &md->flags);\n\t\tdm_cleanup_zoned_dev(md);\n\t\treturn 0;\n\t}\n\n\t \n\tset_bit(DMF_EMULATE_ZONE_APPEND, &md->flags);\n\tif (!get_capacity(md->disk))\n\t\treturn 0;\n\n\treturn dm_revalidate_zones(md, t);\n}\n\nstatic int dm_update_zone_wp_offset_cb(struct blk_zone *zone, unsigned int idx,\n\t\t\t\t       void *data)\n{\n\tunsigned int *wp_offset = data;\n\n\t*wp_offset = dm_get_zone_wp_offset(zone);\n\n\treturn 0;\n}\n\nstatic int dm_update_zone_wp_offset(struct mapped_device *md, unsigned int zno,\n\t\t\t\t    unsigned int *wp_ofst)\n{\n\tsector_t sector = zno * bdev_zone_sectors(md->disk->part0);\n\tunsigned int noio_flag;\n\tstruct dm_table *t;\n\tint srcu_idx, ret;\n\n\tt = dm_get_live_table(md, &srcu_idx);\n\tif (!t)\n\t\treturn -EIO;\n\n\t \n\tnoio_flag = memalloc_noio_save();\n\tret = dm_blk_do_report_zones(md, t, sector, 1,\n\t\t\t\t     dm_update_zone_wp_offset_cb, wp_ofst);\n\tmemalloc_noio_restore(noio_flag);\n\n\tdm_put_live_table(md, srcu_idx);\n\n\tif (ret != 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstruct orig_bio_details {\n\tenum req_op op;\n\tunsigned int nr_sectors;\n};\n\n \nstatic bool dm_zone_map_bio_begin(struct mapped_device *md,\n\t\t\t\t  unsigned int zno, struct bio *clone)\n{\n\tsector_t zsectors = bdev_zone_sectors(md->disk->part0);\n\tunsigned int zwp_offset = READ_ONCE(md->zwp_offset[zno]);\n\n\t \n\tif (zwp_offset == DM_ZONE_INVALID_WP_OFST) {\n\t\tif (dm_update_zone_wp_offset(md, zno, &zwp_offset))\n\t\t\treturn false;\n\t\tWRITE_ONCE(md->zwp_offset[zno], zwp_offset);\n\t}\n\n\tswitch (bio_op(clone)) {\n\tcase REQ_OP_ZONE_RESET:\n\tcase REQ_OP_ZONE_FINISH:\n\t\treturn true;\n\tcase REQ_OP_WRITE_ZEROES:\n\tcase REQ_OP_WRITE:\n\t\t \n\t\tif ((clone->bi_iter.bi_sector & (zsectors - 1)) != zwp_offset)\n\t\t\treturn false;\n\t\tbreak;\n\tcase REQ_OP_ZONE_APPEND:\n\t\t \n\t\tclone->bi_opf = REQ_OP_WRITE | REQ_NOMERGE |\n\t\t\t(clone->bi_opf & (~REQ_OP_MASK));\n\t\tclone->bi_iter.bi_sector += zwp_offset;\n\t\tbreak;\n\tdefault:\n\t\tDMWARN_LIMIT(\"Invalid BIO operation\");\n\t\treturn false;\n\t}\n\n\t \n\tif (zwp_offset >= zsectors)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic blk_status_t dm_zone_map_bio_end(struct mapped_device *md, unsigned int zno,\n\t\t\t\t\tstruct orig_bio_details *orig_bio_details,\n\t\t\t\t\tunsigned int nr_sectors)\n{\n\tunsigned int zwp_offset = READ_ONCE(md->zwp_offset[zno]);\n\n\t \n\tif (zwp_offset == DM_ZONE_INVALID_WP_OFST)\n\t\treturn BLK_STS_IOERR;\n\n\t \n\tswitch (orig_bio_details->op) {\n\tcase REQ_OP_ZONE_RESET:\n\t\tWRITE_ONCE(md->zwp_offset[zno], 0);\n\t\treturn BLK_STS_OK;\n\tcase REQ_OP_ZONE_FINISH:\n\t\tWRITE_ONCE(md->zwp_offset[zno],\n\t\t\t   bdev_zone_sectors(md->disk->part0));\n\t\treturn BLK_STS_OK;\n\tcase REQ_OP_WRITE_ZEROES:\n\tcase REQ_OP_WRITE:\n\t\tWRITE_ONCE(md->zwp_offset[zno], zwp_offset + nr_sectors);\n\t\treturn BLK_STS_OK;\n\tcase REQ_OP_ZONE_APPEND:\n\t\t \n\t\tif (nr_sectors != orig_bio_details->nr_sectors) {\n\t\t\tDMWARN_LIMIT(\"Truncated write for zone append\");\n\t\t\treturn BLK_STS_IOERR;\n\t\t}\n\t\tWRITE_ONCE(md->zwp_offset[zno], zwp_offset + nr_sectors);\n\t\treturn BLK_STS_OK;\n\tdefault:\n\t\tDMWARN_LIMIT(\"Invalid BIO operation\");\n\t\treturn BLK_STS_IOERR;\n\t}\n}\n\nstatic inline void dm_zone_lock(struct gendisk *disk, unsigned int zno,\n\t\t\t\tstruct bio *clone)\n{\n\tif (WARN_ON_ONCE(bio_flagged(clone, BIO_ZONE_WRITE_LOCKED)))\n\t\treturn;\n\n\twait_on_bit_lock_io(disk->seq_zones_wlock, zno, TASK_UNINTERRUPTIBLE);\n\tbio_set_flag(clone, BIO_ZONE_WRITE_LOCKED);\n}\n\nstatic inline void dm_zone_unlock(struct gendisk *disk, unsigned int zno,\n\t\t\t\t  struct bio *clone)\n{\n\tif (!bio_flagged(clone, BIO_ZONE_WRITE_LOCKED))\n\t\treturn;\n\n\tWARN_ON_ONCE(!test_bit(zno, disk->seq_zones_wlock));\n\tclear_bit_unlock(zno, disk->seq_zones_wlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(disk->seq_zones_wlock, zno);\n\n\tbio_clear_flag(clone, BIO_ZONE_WRITE_LOCKED);\n}\n\nstatic bool dm_need_zone_wp_tracking(struct bio *bio)\n{\n\t \n\tif (op_is_flush(bio->bi_opf) && !bio_sectors(bio))\n\t\treturn false;\n\tswitch (bio_op(bio)) {\n\tcase REQ_OP_WRITE_ZEROES:\n\tcase REQ_OP_WRITE:\n\tcase REQ_OP_ZONE_RESET:\n\tcase REQ_OP_ZONE_FINISH:\n\tcase REQ_OP_ZONE_APPEND:\n\t\treturn bio_zone_is_seq(bio);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nint dm_zone_map_bio(struct dm_target_io *tio)\n{\n\tstruct dm_io *io = tio->io;\n\tstruct dm_target *ti = tio->ti;\n\tstruct mapped_device *md = io->md;\n\tstruct bio *clone = &tio->clone;\n\tstruct orig_bio_details orig_bio_details;\n\tunsigned int zno;\n\tblk_status_t sts;\n\tint r;\n\n\t \n\tif (!dm_need_zone_wp_tracking(clone))\n\t\treturn ti->type->map(ti, clone);\n\n\t \n\tzno = bio_zone_no(clone);\n\tdm_zone_lock(md->disk, zno, clone);\n\n\torig_bio_details.nr_sectors = bio_sectors(clone);\n\torig_bio_details.op = bio_op(clone);\n\n\t \n\tif (!dm_zone_map_bio_begin(md, zno, clone)) {\n\t\tdm_zone_unlock(md->disk, zno, clone);\n\t\treturn DM_MAPIO_KILL;\n\t}\n\n\t \n\tr = ti->type->map(ti, clone);\n\tswitch (r) {\n\tcase DM_MAPIO_SUBMITTED:\n\t\t \n\t\tsts = dm_zone_map_bio_end(md, zno, &orig_bio_details,\n\t\t\t\t\t  *tio->len_ptr);\n\t\tbreak;\n\tcase DM_MAPIO_REMAPPED:\n\t\t \n\t\tsts = dm_zone_map_bio_end(md, zno, &orig_bio_details,\n\t\t\t\t\t  *tio->len_ptr);\n\t\tif (sts != BLK_STS_OK)\n\t\t\tdm_zone_unlock(md->disk, zno, clone);\n\t\tbreak;\n\tcase DM_MAPIO_REQUEUE:\n\tcase DM_MAPIO_KILL:\n\tdefault:\n\t\tdm_zone_unlock(md->disk, zno, clone);\n\t\tsts = BLK_STS_IOERR;\n\t\tbreak;\n\t}\n\n\tif (sts != BLK_STS_OK)\n\t\treturn DM_MAPIO_KILL;\n\n\treturn r;\n}\n\n \nvoid dm_zone_endio(struct dm_io *io, struct bio *clone)\n{\n\tstruct mapped_device *md = io->md;\n\tstruct gendisk *disk = md->disk;\n\tstruct bio *orig_bio = io->orig_bio;\n\tunsigned int zwp_offset;\n\tunsigned int zno;\n\n\t \n\tif (!dm_emulate_zone_append(md)) {\n\t\t \n\t\tif (clone->bi_status == BLK_STS_OK &&\n\t\t    bio_op(clone) == REQ_OP_ZONE_APPEND) {\n\t\t\tsector_t mask =\n\t\t\t\t(sector_t)bdev_zone_sectors(disk->part0) - 1;\n\n\t\t\torig_bio->bi_iter.bi_sector +=\n\t\t\t\tclone->bi_iter.bi_sector & mask;\n\t\t}\n\n\t\treturn;\n\t}\n\n\t \n\tif (!bio_flagged(clone, BIO_ZONE_WRITE_LOCKED))\n\t\treturn;\n\n\tzno = bio_zone_no(orig_bio);\n\n\tif (clone->bi_status != BLK_STS_OK) {\n\t\t \n\t\tWRITE_ONCE(md->zwp_offset[zno], DM_ZONE_INVALID_WP_OFST);\n\t} else if (bio_op(orig_bio) == REQ_OP_ZONE_APPEND) {\n\t\t \n\t\tzwp_offset = READ_ONCE(md->zwp_offset[zno]);\n\t\tif (WARN_ON_ONCE(zwp_offset < bio_sectors(orig_bio)))\n\t\t\tWRITE_ONCE(md->zwp_offset[zno],\n\t\t\t\t   DM_ZONE_INVALID_WP_OFST);\n\t\telse\n\t\t\torig_bio->bi_iter.bi_sector +=\n\t\t\t\tzwp_offset - bio_sectors(orig_bio);\n\t}\n\n\tdm_zone_unlock(disk, zno, clone);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}