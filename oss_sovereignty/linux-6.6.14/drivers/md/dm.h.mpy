{
  "module_name": "dm.h",
  "hash_id": "58e078a7da960776c436ac5a6f2f0280a48a2e8f1aeff2d67493bf11b289d332",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm.h",
  "human_readable_source": " \n\n#ifndef DM_INTERNAL_H\n#define DM_INTERNAL_H\n\n#include <linux/fs.h>\n#include <linux/device-mapper.h>\n#include <linux/list.h>\n#include <linux/moduleparam.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/hdreg.h>\n#include <linux/completion.h>\n#include <linux/kobject.h>\n#include <linux/refcount.h>\n#include <linux/log2.h>\n\n#include \"dm-stats.h\"\n\n \n#define DM_SUSPEND_LOCKFS_FLAG\t\t(1 << 0)\n#define DM_SUSPEND_NOFLUSH_FLAG\t\t(1 << 1)\n\n \n#define DM_STATUS_NOFLUSH_FLAG\t\t(1 << 0)\n\n \nstruct dm_dev_internal {\n\tstruct list_head list;\n\trefcount_t count;\n\tstruct dm_dev *dm_dev;\n};\n\nstruct dm_table;\nstruct dm_md_mempools;\nstruct dm_target_io;\nstruct dm_io;\n\n \nvoid dm_table_event_callback(struct dm_table *t,\n\t\t\t     void (*fn)(void *), void *context);\nstruct dm_target *dm_table_find_target(struct dm_table *t, sector_t sector);\nbool dm_table_has_no_data_devices(struct dm_table *table);\nint dm_calculate_queue_limits(struct dm_table *table,\n\t\t\t      struct queue_limits *limits);\nint dm_table_set_restrictions(struct dm_table *t, struct request_queue *q,\n\t\t\t      struct queue_limits *limits);\nstruct list_head *dm_table_get_devices(struct dm_table *t);\nvoid dm_table_presuspend_targets(struct dm_table *t);\nvoid dm_table_presuspend_undo_targets(struct dm_table *t);\nvoid dm_table_postsuspend_targets(struct dm_table *t);\nint dm_table_resume_targets(struct dm_table *t);\nenum dm_queue_mode dm_table_get_type(struct dm_table *t);\nstruct target_type *dm_table_get_immutable_target_type(struct dm_table *t);\nstruct dm_target *dm_table_get_immutable_target(struct dm_table *t);\nstruct dm_target *dm_table_get_wildcard_target(struct dm_table *t);\nbool dm_table_bio_based(struct dm_table *t);\nbool dm_table_request_based(struct dm_table *t);\n\nvoid dm_lock_md_type(struct mapped_device *md);\nvoid dm_unlock_md_type(struct mapped_device *md);\nvoid dm_set_md_type(struct mapped_device *md, enum dm_queue_mode type);\nenum dm_queue_mode dm_get_md_type(struct mapped_device *md);\nstruct target_type *dm_get_immutable_target_type(struct mapped_device *md);\n\nint dm_setup_md_queue(struct mapped_device *md, struct dm_table *t);\n\n \n#define dm_target_bio_based(t) ((t)->type->map != NULL)\n\n \n#define dm_target_request_based(t) ((t)->type->clone_and_map_rq != NULL)\n\n \n#define dm_target_hybrid(t) (dm_target_bio_based(t) && dm_target_request_based(t))\n\n \nint dm_set_zones_restrictions(struct dm_table *t, struct request_queue *q);\nvoid dm_zone_endio(struct dm_io *io, struct bio *clone);\n#ifdef CONFIG_BLK_DEV_ZONED\nvoid dm_cleanup_zoned_dev(struct mapped_device *md);\nint dm_blk_report_zones(struct gendisk *disk, sector_t sector,\n\t\t\tunsigned int nr_zones, report_zones_cb cb, void *data);\nbool dm_is_zone_write(struct mapped_device *md, struct bio *bio);\nint dm_zone_map_bio(struct dm_target_io *io);\n#else\nstatic inline void dm_cleanup_zoned_dev(struct mapped_device *md) {}\n#define dm_blk_report_zones\tNULL\nstatic inline bool dm_is_zone_write(struct mapped_device *md, struct bio *bio)\n{\n\treturn false;\n}\nstatic inline int dm_zone_map_bio(struct dm_target_io *tio)\n{\n\treturn DM_MAPIO_KILL;\n}\n#endif\n\n \nint dm_target_init(void);\nvoid dm_target_exit(void);\nstruct target_type *dm_get_target_type(const char *name);\nvoid dm_put_target_type(struct target_type *tt);\nint dm_target_iterate(void (*iter_func)(struct target_type *tt,\n\t\t\t\t\tvoid *param), void *param);\n\nint dm_split_args(int *argc, char ***argvp, char *input);\n\n \nint dm_deleting_md(struct mapped_device *md);\n\n \nint dm_suspended_md(struct mapped_device *md);\n\n \nint dm_suspended_internally_md(struct mapped_device *md);\nvoid dm_internal_suspend_fast(struct mapped_device *md);\nvoid dm_internal_resume_fast(struct mapped_device *md);\nvoid dm_internal_suspend_noflush(struct mapped_device *md);\nvoid dm_internal_resume(struct mapped_device *md);\n\n \nint dm_test_deferred_remove_flag(struct mapped_device *md);\n\n \nvoid dm_deferred_remove(void);\n\n \nint dm_interface_init(void);\nvoid dm_interface_exit(void);\n\n \nint dm_sysfs_init(struct mapped_device *md);\nvoid dm_sysfs_exit(struct mapped_device *md);\nstruct kobject *dm_kobject(struct mapped_device *md);\nstruct mapped_device *dm_get_from_kobject(struct kobject *kobj);\n\n \nvoid dm_kobject_release(struct kobject *kobj);\n\n \nint dm_linear_init(void);\nvoid dm_linear_exit(void);\n\nint dm_stripe_init(void);\nvoid dm_stripe_exit(void);\n\n \nvoid dm_destroy(struct mapped_device *md);\nvoid dm_destroy_immediate(struct mapped_device *md);\nint dm_open_count(struct mapped_device *md);\nint dm_lock_for_deletion(struct mapped_device *md, bool mark_deferred, bool only_deferred);\nint dm_cancel_deferred_remove(struct mapped_device *md);\nint dm_request_based(struct mapped_device *md);\nint dm_get_table_device(struct mapped_device *md, dev_t dev, blk_mode_t mode,\n\t\t\tstruct dm_dev **result);\nvoid dm_put_table_device(struct mapped_device *md, struct dm_dev *d);\n\nint dm_kobject_uevent(struct mapped_device *md, enum kobject_action action,\n\t\t      unsigned int cookie, bool need_resize_uevent);\n\nint dm_io_init(void);\nvoid dm_io_exit(void);\n\nint dm_kcopyd_init(void);\nvoid dm_kcopyd_exit(void);\n\n \nvoid dm_free_md_mempools(struct dm_md_mempools *pools);\n\n \nunsigned int dm_get_reserved_bio_based_ios(void);\n\n#define DM_HASH_LOCKS_MAX 64\n\nstatic inline unsigned int dm_num_hash_locks(void)\n{\n\tunsigned int num_locks = roundup_pow_of_two(num_online_cpus()) << 1;\n\n\treturn min_t(unsigned int, num_locks, DM_HASH_LOCKS_MAX);\n}\n\n#define DM_HASH_LOCKS_MULT  4294967291ULL\n#define DM_HASH_LOCKS_SHIFT 6\n\nstatic inline unsigned int dm_hash_locks_index(sector_t block,\n\t\t\t\t\t       unsigned int num_locks)\n{\n\tsector_t h1 = (block * DM_HASH_LOCKS_MULT) >> DM_HASH_LOCKS_SHIFT;\n\tsector_t h2 = h1 >> DM_HASH_LOCKS_SHIFT;\n\n\treturn (h1 ^ h2) & (num_locks - 1);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}