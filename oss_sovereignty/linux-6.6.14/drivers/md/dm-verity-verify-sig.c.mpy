{
  "module_name": "dm-verity-verify-sig.c",
  "hash_id": "adaa857789272162f38a715ed1f0c420b626dfb33ac460b24303309a741b4c68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-verity-verify-sig.c",
  "human_readable_source": "\n \n#include <linux/device-mapper.h>\n#include <linux/verification.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include \"dm-verity.h\"\n#include \"dm-verity-verify-sig.h\"\n\n#define DM_VERITY_VERIFY_ERR(s) DM_VERITY_ROOT_HASH_VERIFICATION \" \" s\n\nstatic bool require_signatures;\nmodule_param(require_signatures, bool, 0444);\nMODULE_PARM_DESC(require_signatures,\n\t\t\"Verify the roothash of dm-verity hash tree\");\n\n#define DM_VERITY_IS_SIG_FORCE_ENABLED() \\\n\t(require_signatures != false)\n\nbool verity_verify_is_sig_opt_arg(const char *arg_name)\n{\n\treturn (!strcasecmp(arg_name,\n\t\t\t    DM_VERITY_ROOT_HASH_VERIFICATION_OPT_SIG_KEY));\n}\n\nstatic int verity_verify_get_sig_from_key(const char *key_desc,\n\t\t\t\t\tstruct dm_verity_sig_opts *sig_opts)\n{\n\tstruct key *key;\n\tconst struct user_key_payload *ukp;\n\tint ret = 0;\n\n\tkey = request_key(&key_type_user,\n\t\t\tkey_desc, NULL);\n\tif (IS_ERR(key))\n\t\treturn PTR_ERR(key);\n\n\tdown_read(&key->sem);\n\n\tukp = user_key_payload_locked(key);\n\tif (!ukp) {\n\t\tret = -EKEYREVOKED;\n\t\tgoto end;\n\t}\n\n\tsig_opts->sig = kmalloc(ukp->datalen, GFP_KERNEL);\n\tif (!sig_opts->sig) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\tsig_opts->sig_size = ukp->datalen;\n\n\tmemcpy(sig_opts->sig, ukp->data, sig_opts->sig_size);\n\nend:\n\tup_read(&key->sem);\n\tkey_put(key);\n\n\treturn ret;\n}\n\nint verity_verify_sig_parse_opt_args(struct dm_arg_set *as,\n\t\t\t\t     struct dm_verity *v,\n\t\t\t\t     struct dm_verity_sig_opts *sig_opts,\n\t\t\t\t     unsigned int *argc,\n\t\t\t\t     const char *arg_name)\n{\n\tstruct dm_target *ti = v->ti;\n\tint ret = 0;\n\tconst char *sig_key = NULL;\n\n\tif (!*argc) {\n\t\tti->error = DM_VERITY_VERIFY_ERR(\"Signature key not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tsig_key = dm_shift_arg(as);\n\t(*argc)--;\n\n\tret = verity_verify_get_sig_from_key(sig_key, sig_opts);\n\tif (ret < 0)\n\t\tti->error = DM_VERITY_VERIFY_ERR(\"Invalid key specified\");\n\n\tv->signature_key_desc = kstrdup(sig_key, GFP_KERNEL);\n\tif (!v->signature_key_desc)\n\t\treturn -ENOMEM;\n\n\treturn ret;\n}\n\n \nint verity_verify_root_hash(const void *root_hash, size_t root_hash_len,\n\t\t\t    const void *sig_data, size_t sig_len)\n{\n\tint ret;\n\n\tif (!root_hash || root_hash_len == 0)\n\t\treturn -EINVAL;\n\n\tif (!sig_data  || sig_len == 0) {\n\t\tif (DM_VERITY_IS_SIG_FORCE_ENABLED())\n\t\t\treturn -ENOKEY;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tret = verify_pkcs7_signature(root_hash, root_hash_len, sig_data,\n\t\t\t\tsig_len,\n#ifdef CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG_SECONDARY_KEYRING\n\t\t\t\tVERIFY_USE_SECONDARY_KEYRING,\n#else\n\t\t\t\tNULL,\n#endif\n\t\t\t\tVERIFYING_UNSPECIFIED_SIGNATURE, NULL, NULL);\n\n\treturn ret;\n}\n\nvoid verity_verify_sig_opts_cleanup(struct dm_verity_sig_opts *sig_opts)\n{\n\tkfree(sig_opts->sig);\n\tsig_opts->sig = NULL;\n\tsig_opts->sig_size = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}