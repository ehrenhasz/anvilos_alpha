{
  "module_name": "Kconfig",
  "hash_id": "a4dd459009101551a240dcfe291ad1a04d231a940ebbe9bda08701cbf30f12da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Block device driver configuration\n#\n\nmenuconfig MD\n\tbool \"Multiple devices driver support (RAID and LVM)\"\n\tdepends on BLOCK\n\thelp\n\t  Support multiple physical spindles through a single logical device.\n\t  Required for RAID and logical volume management.\n\nif MD\n\nconfig BLK_DEV_MD\n\ttristate \"RAID support\"\n\tselect BLOCK_HOLDER_DEPRECATED if SYSFS\n\tselect BUFFER_HEAD\n\t# BLOCK_LEGACY_AUTOLOAD requirement should be removed\n\t# after relevant mdadm enhancements - to make \"names=yes\"\n\t# the default - are widely available.\n\tselect BLOCK_LEGACY_AUTOLOAD\n\thelp\n\t  This driver lets you combine several hard disk partitions into one\n\t  logical block device. This can be used to simply append one\n\t  partition to another one or to combine several redundant hard disks\n\t  into a RAID1/4/5 device so as to provide protection against hard\n\t  disk failures. This is called \"Software RAID\" since the combining of\n\t  the partitions is done by the kernel. \"Hardware RAID\" means that the\n\t  combining is done by a dedicated controller; if you have such a\n\t  controller, you do not need to say Y here.\n\n\t  More information about Software RAID on Linux is contained in the\n\t  Software RAID mini-HOWTO, available from\n\t  <https://www.tldp.org/docs.html#howto>. There you will also learn\n\t  where to get the supporting user space utilities raidtools.\n\n\t  If unsure, say N.\n\nconfig MD_AUTODETECT\n\tbool \"Autodetect RAID arrays during kernel boot\"\n\tdepends on BLK_DEV_MD=y\n\tdefault y\n\thelp\n\t  If you say Y here, then the kernel will try to autodetect raid\n\t  arrays as part of its boot process.\n\n\t  If you don't use raid and say Y, this autodetection can cause\n\t  a several-second delay in the boot time due to various\n\t  synchronisation steps that are part of this step.\n\n\t  If unsure, say Y.\n\nconfig MD_BITMAP_FILE\n\tbool \"MD bitmap file support (deprecated)\"\n\tdefault y\n\thelp\n\t  If you say Y here, support for write intent bitmaps in files on an\n\t  external file system is enabled.  This is an alternative to the internal\n\t  bitmaps near the MD superblock, and very problematic code that abuses\n\t  various kernel APIs and can only work with files on a file system not\n\t  actually sitting on the MD device.\n\nconfig MD_LINEAR\n\ttristate \"Linear (append) mode (deprecated)\"\n\tdepends on BLK_DEV_MD\n\thelp\n\t  If you say Y here, then your multiple devices driver will be able to\n\t  use the so-called linear mode, i.e. it will combine the hard disk\n\t  partitions by simply appending one to the other.\n\n\t  To compile this as a module, choose M here: the module\n\t  will be called linear.\n\n\t  If unsure, say Y.\n\nconfig MD_RAID0\n\ttristate \"RAID-0 (striping) mode\"\n\tdepends on BLK_DEV_MD\n\thelp\n\t  If you say Y here, then your multiple devices driver will be able to\n\t  use the so-called raid0 mode, i.e. it will combine the hard disk\n\t  partitions into one logical device in such a fashion as to fill them\n\t  up evenly, one chunk here and one chunk there. This will increase\n\t  the throughput rate if the partitions reside on distinct disks.\n\n\t  Information about Software RAID on Linux is contained in the\n\t  Software-RAID mini-HOWTO, available from\n\t  <https://www.tldp.org/docs.html#howto>. There you will also\n\t  learn where to get the supporting user space utilities raidtools.\n\n\t  To compile this as a module, choose M here: the module\n\t  will be called raid0.\n\n\t  If unsure, say Y.\n\nconfig MD_RAID1\n\ttristate \"RAID-1 (mirroring) mode\"\n\tdepends on BLK_DEV_MD\n\thelp\n\t  A RAID-1 set consists of several disk drives which are exact copies\n\t  of each other.  In the event of a mirror failure, the RAID driver\n\t  will continue to use the operational mirrors in the set, providing\n\t  an error free MD (multiple device) to the higher levels of the\n\t  kernel.  In a set with N drives, the available space is the capacity\n\t  of a single drive, and the set protects against a failure of (N - 1)\n\t  drives.\n\n\t  Information about Software RAID on Linux is contained in the\n\t  Software-RAID mini-HOWTO, available from\n\t  <https://www.tldp.org/docs.html#howto>.  There you will also\n\t  learn where to get the supporting user space utilities raidtools.\n\n\t  If you want to use such a RAID-1 set, say Y.  To compile this code\n\t  as a module, choose M here: the module will be called raid1.\n\n\t  If unsure, say Y.\n\nconfig MD_RAID10\n\ttristate \"RAID-10 (mirrored striping) mode\"\n\tdepends on BLK_DEV_MD\n\thelp\n\t  RAID-10 provides a combination of striping (RAID-0) and\n\t  mirroring (RAID-1) with easier configuration and more flexible\n\t  layout.\n\t  Unlike RAID-0, but like RAID-1, RAID-10 requires all devices to\n\t  be the same size (or at least, only as much as the smallest device\n\t  will be used).\n\t  RAID-10 provides a variety of layouts that provide different levels\n\t  of redundancy and performance.\n\n\t  RAID-10 requires mdadm-1.7.0 or later, available at:\n\n\t  https://www.kernel.org/pub/linux/utils/raid/mdadm/\n\n\t  If unsure, say Y.\n\nconfig MD_RAID456\n\ttristate \"RAID-4/RAID-5/RAID-6 mode\"\n\tdepends on BLK_DEV_MD\n\tselect RAID6_PQ\n\tselect LIBCRC32C\n\tselect ASYNC_MEMCPY\n\tselect ASYNC_XOR\n\tselect ASYNC_PQ\n\tselect ASYNC_RAID6_RECOV\n\thelp\n\t  A RAID-5 set of N drives with a capacity of C MB per drive provides\n\t  the capacity of C * (N - 1) MB, and protects against a failure\n\t  of a single drive. For a given sector (row) number, (N - 1) drives\n\t  contain data sectors, and one drive contains the parity protection.\n\t  For a RAID-4 set, the parity blocks are present on a single drive,\n\t  while a RAID-5 set distributes the parity across the drives in one\n\t  of the available parity distribution methods.\n\n\t  A RAID-6 set of N drives with a capacity of C MB per drive\n\t  provides the capacity of C * (N - 2) MB, and protects\n\t  against a failure of any two drives. For a given sector\n\t  (row) number, (N - 2) drives contain data sectors, and two\n\t  drives contains two independent redundancy syndromes.  Like\n\t  RAID-5, RAID-6 distributes the syndromes across the drives\n\t  in one of the available parity distribution methods.\n\n\t  Information about Software RAID on Linux is contained in the\n\t  Software-RAID mini-HOWTO, available from\n\t  <https://www.tldp.org/docs.html#howto>. There you will also\n\t  learn where to get the supporting user space utilities raidtools.\n\n\t  If you want to use such a RAID-4/RAID-5/RAID-6 set, say Y.  To\n\t  compile this code as a module, choose M here: the module\n\t  will be called raid456.\n\n\t  If unsure, say Y.\n\nconfig MD_MULTIPATH\n\ttristate \"Multipath I/O support (deprecated)\"\n\tdepends on BLK_DEV_MD\n\thelp\n\t  MD_MULTIPATH provides a simple multi-path personality for use\n\t  the MD framework.  It is not under active development.  New\n\t  projects should consider using DM_MULTIPATH which has more\n\t  features and more testing.\n\n\t  If unsure, say N.\n\nconfig MD_FAULTY\n\ttristate \"Faulty test module for MD (deprecated)\"\n\tdepends on BLK_DEV_MD\n\thelp\n\t  The \"faulty\" module allows for a block device that occasionally returns\n\t  read or write errors.  It is useful for testing.\n\n\t  In unsure, say N.\n\n\nconfig MD_CLUSTER\n\ttristate \"Cluster Support for MD\"\n\tdepends on BLK_DEV_MD\n\tdepends on DLM\n\tdefault n\n\thelp\n\tClustering support for MD devices. This enables locking and\n\tsynchronization across multiple systems on the cluster, so all\n\tnodes in the cluster can access the MD devices simultaneously.\n\n\tThis brings the redundancy (and uptime) of RAID levels across the\n\tnodes of the cluster. Currently, it can work with raid1 and raid10\n\t(limited support).\n\n\tIf unsure, say N.\n\nsource \"drivers/md/bcache/Kconfig\"\n\nconfig BLK_DEV_DM_BUILTIN\n\tbool\n\nconfig BLK_DEV_DM\n\ttristate \"Device mapper support\"\n\tselect BLOCK_HOLDER_DEPRECATED if SYSFS\n\tselect BLK_DEV_DM_BUILTIN\n\tselect BLK_MQ_STACKING\n\tdepends on DAX || DAX=n\n\thelp\n\t  Device-mapper is a low level volume manager.  It works by allowing\n\t  people to specify mappings for ranges of logical sectors.  Various\n\t  mapping types are available, in addition people may write their own\n\t  modules containing custom mappings if they wish.\n\n\t  Higher level volume managers such as LVM2 use this driver.\n\n\t  To compile this as a module, choose M here: the module will be\n\t  called dm-mod.\n\n\t  If unsure, say N.\n\nconfig DM_DEBUG\n\tbool \"Device mapper debugging support\"\n\tdepends on BLK_DEV_DM\n\thelp\n\t  Enable this for messages that may help debug device-mapper problems.\n\n\t  If unsure, say N.\n\nconfig DM_BUFIO\n       tristate\n       depends on BLK_DEV_DM\n\thelp\n\t This interface allows you to do buffered I/O on a device and acts\n\t as a cache, holding recently-read blocks in memory and performing\n\t delayed writes.\n\nconfig DM_DEBUG_BLOCK_MANAGER_LOCKING\n       bool \"Block manager locking\"\n       depends on DM_BUFIO\n\thelp\n\t Block manager locking can catch various metadata corruption issues.\n\n\t If unsure, say N.\n\nconfig DM_DEBUG_BLOCK_STACK_TRACING\n       bool \"Keep stack trace of persistent data block lock holders\"\n       depends on STACKTRACE_SUPPORT && DM_DEBUG_BLOCK_MANAGER_LOCKING\n       select STACKTRACE\n\thelp\n\t Enable this for messages that may help debug problems with the\n\t block manager locking used by thin provisioning and caching.\n\n\t If unsure, say N.\n\nconfig DM_BIO_PRISON\n       tristate\n       depends on BLK_DEV_DM\n\thelp\n\t Some bio locking schemes used by other device-mapper targets\n\t including thin provisioning.\n\nsource \"drivers/md/persistent-data/Kconfig\"\n\nconfig DM_UNSTRIPED\n       tristate \"Unstriped target\"\n       depends on BLK_DEV_DM\n\thelp\n\t  Unstripes I/O so it is issued solely on a single drive in a HW\n\t  RAID0 or dm-striped target.\n\nconfig DM_CRYPT\n\ttristate \"Crypt target support\"\n\tdepends on BLK_DEV_DM\n\tdepends on (ENCRYPTED_KEYS || ENCRYPTED_KEYS=n)\n\tdepends on (TRUSTED_KEYS || TRUSTED_KEYS=n)\n\tselect CRYPTO\n\tselect CRYPTO_CBC\n\tselect CRYPTO_ESSIV\n\thelp\n\t  This device-mapper target allows you to create a device that\n\t  transparently encrypts the data on it. You'll need to activate\n\t  the ciphers you're going to use in the cryptoapi configuration.\n\n\t  For further information on dm-crypt and userspace tools see:\n\t  <https://gitlab.com/cryptsetup/cryptsetup/wikis/DMCrypt>\n\n\t  To compile this code as a module, choose M here: the module will\n\t  be called dm-crypt.\n\n\t  If unsure, say N.\n\nconfig DM_SNAPSHOT\n       tristate \"Snapshot target\"\n       depends on BLK_DEV_DM\n       select DM_BUFIO\n\thelp\n\t Allow volume managers to take writable snapshots of a device.\n\nconfig DM_THIN_PROVISIONING\n       tristate \"Thin provisioning target\"\n       depends on BLK_DEV_DM\n       select DM_PERSISTENT_DATA\n       select DM_BIO_PRISON\n\thelp\n\t Provides thin provisioning and snapshots that share a data store.\n\nconfig DM_CACHE\n       tristate \"Cache target (EXPERIMENTAL)\"\n       depends on BLK_DEV_DM\n       default n\n       select DM_PERSISTENT_DATA\n       select DM_BIO_PRISON\n\thelp\n\t dm-cache attempts to improve performance of a block device by\n\t moving frequently used data to a smaller, higher performance\n\t device.  Different 'policy' plugins can be used to change the\n\t algorithms used to select which blocks are promoted, demoted,\n\t cleaned etc.  It supports writeback and writethrough modes.\n\nconfig DM_CACHE_SMQ\n       tristate \"Stochastic MQ Cache Policy (EXPERIMENTAL)\"\n       depends on DM_CACHE\n       default y\n\thelp\n\t A cache policy that uses a multiqueue ordered by recent hits\n\t to select which blocks should be promoted and demoted.\n\t This is meant to be a general purpose policy.  It prioritises\n\t reads over writes.  This SMQ policy (vs MQ) offers the promise\n\t of less memory utilization, improved performance and increased\n\t adaptability in the face of changing workloads.\n\nconfig DM_WRITECACHE\n\ttristate \"Writecache target\"\n\tdepends on BLK_DEV_DM\n\thelp\n\t   The writecache target caches writes on persistent memory or SSD.\n\t   It is intended for databases or other programs that need extremely\n\t   low commit latency.\n\n\t   The writecache target doesn't cache reads because reads are supposed\n\t   to be cached in standard RAM.\n\nconfig DM_EBS\n\ttristate \"Emulated block size target (EXPERIMENTAL)\"\n\tdepends on BLK_DEV_DM && !HIGHMEM\n\tselect DM_BUFIO\n\thelp\n\t  dm-ebs emulates smaller logical block size on backing devices\n\t  with larger ones (e.g. 512 byte sectors on 4K native disks).\n\nconfig DM_ERA\n       tristate \"Era target (EXPERIMENTAL)\"\n       depends on BLK_DEV_DM\n       default n\n       select DM_PERSISTENT_DATA\n       select DM_BIO_PRISON\n\thelp\n\t dm-era tracks which parts of a block device are written to\n\t over time.  Useful for maintaining cache coherency when using\n\t vendor snapshots.\n\nconfig DM_CLONE\n       tristate \"Clone target (EXPERIMENTAL)\"\n       depends on BLK_DEV_DM\n       default n\n       select DM_PERSISTENT_DATA\n\thelp\n\t dm-clone produces a one-to-one copy of an existing, read-only source\n\t device into a writable destination device. The cloned device is\n\t visible/mountable immediately and the copy of the source device to the\n\t destination device happens in the background, in parallel with user\n\t I/O.\n\n\t If unsure, say N.\n\nconfig DM_MIRROR\n       tristate \"Mirror target\"\n       depends on BLK_DEV_DM\n\thelp\n\t Allow volume managers to mirror logical volumes, also\n\t needed for live data migration tools such as 'pvmove'.\n\nconfig DM_LOG_USERSPACE\n\ttristate \"Mirror userspace logging\"\n\tdepends on DM_MIRROR && NET\n\tselect CONNECTOR\n\thelp\n\t  The userspace logging module provides a mechanism for\n\t  relaying the dm-dirty-log API to userspace.  Log designs\n\t  which are more suited to userspace implementation (e.g.\n\t  shared storage logs) or experimental logs can be implemented\n\t  by leveraging this framework.\n\nconfig DM_RAID\n       tristate \"RAID 1/4/5/6/10 target\"\n       depends on BLK_DEV_DM\n       select MD_RAID0\n       select MD_RAID1\n       select MD_RAID10\n       select MD_RAID456\n       select BLK_DEV_MD\n\thelp\n\t A dm target that supports RAID1, RAID10, RAID4, RAID5 and RAID6 mappings\n\n\t A RAID-5 set of N drives with a capacity of C MB per drive provides\n\t the capacity of C * (N - 1) MB, and protects against a failure\n\t of a single drive. For a given sector (row) number, (N - 1) drives\n\t contain data sectors, and one drive contains the parity protection.\n\t For a RAID-4 set, the parity blocks are present on a single drive,\n\t while a RAID-5 set distributes the parity across the drives in one\n\t of the available parity distribution methods.\n\n\t A RAID-6 set of N drives with a capacity of C MB per drive\n\t provides the capacity of C * (N - 2) MB, and protects\n\t against a failure of any two drives. For a given sector\n\t (row) number, (N - 2) drives contain data sectors, and two\n\t drives contains two independent redundancy syndromes.  Like\n\t RAID-5, RAID-6 distributes the syndromes across the drives\n\t in one of the available parity distribution methods.\n\nconfig DM_ZERO\n\ttristate \"Zero target\"\n\tdepends on BLK_DEV_DM\n\thelp\n\t  A target that discards writes, and returns all zeroes for\n\t  reads.  Useful in some recovery situations.\n\nconfig DM_MULTIPATH\n\ttristate \"Multipath target\"\n\tdepends on BLK_DEV_DM\n\t# nasty syntax but means make DM_MULTIPATH independent\n\t# of SCSI_DH if the latter isn't defined but if\n\t# it is, DM_MULTIPATH must depend on it.  We get a build\n\t# error if SCSI_DH=m and DM_MULTIPATH=y\n\tdepends on !SCSI_DH || SCSI\n\thelp\n\t  Allow volume managers to support multipath hardware.\n\nconfig DM_MULTIPATH_QL\n\ttristate \"I/O Path Selector based on the number of in-flight I/Os\"\n\tdepends on DM_MULTIPATH\n\thelp\n\t  This path selector is a dynamic load balancer which selects\n\t  the path with the least number of in-flight I/Os.\n\n\t  If unsure, say N.\n\nconfig DM_MULTIPATH_ST\n\ttristate \"I/O Path Selector based on the service time\"\n\tdepends on DM_MULTIPATH\n\thelp\n\t  This path selector is a dynamic load balancer which selects\n\t  the path expected to complete the incoming I/O in the shortest\n\t  time.\n\n\t  If unsure, say N.\n\nconfig DM_MULTIPATH_HST\n\ttristate \"I/O Path Selector based on historical service time\"\n\tdepends on DM_MULTIPATH\n\thelp\n\t  This path selector is a dynamic load balancer which selects\n\t  the path expected to complete the incoming I/O in the shortest\n\t  time by comparing estimated service time (based on historical\n\t  service time).\n\n\t  If unsure, say N.\n\nconfig DM_MULTIPATH_IOA\n\ttristate \"I/O Path Selector based on CPU submission\"\n\tdepends on DM_MULTIPATH\n\thelp\n\t  This path selector selects the path based on the CPU the IO is\n\t  executed on and the CPU to path mapping setup at path addition time.\n\n\t  If unsure, say N.\n\nconfig DM_DELAY\n\ttristate \"I/O delaying target\"\n\tdepends on BLK_DEV_DM\n\thelp\n\tA target that delays reads and/or writes and can send\n\tthem to different devices.  Useful for testing.\n\n\tIf unsure, say N.\n\nconfig DM_DUST\n\ttristate \"Bad sector simulation target\"\n\tdepends on BLK_DEV_DM\n\thelp\n\tA target that simulates bad sector behavior.\n\tUseful for testing.\n\n\tIf unsure, say N.\n\nconfig DM_INIT\n\tbool \"DM \\\"dm-mod.create=\\\" parameter support\"\n\tdepends on BLK_DEV_DM=y\n\thelp\n\tEnable \"dm-mod.create=\" parameter to create mapped devices at init time.\n\tThis option is useful to allow mounting rootfs without requiring an\n\tinitramfs.\n\tSee Documentation/admin-guide/device-mapper/dm-init.rst for dm-mod.create=\"...\"\n\tformat.\n\n\tIf unsure, say N.\n\nconfig DM_UEVENT\n\tbool \"DM uevents\"\n\tdepends on BLK_DEV_DM\n\thelp\n\tGenerate udev events for DM events.\n\nconfig DM_FLAKEY\n       tristate \"Flakey target\"\n       depends on BLK_DEV_DM\n\thelp\n\t A target that intermittently fails I/O for debugging purposes.\n\nconfig DM_VERITY\n\ttristate \"Verity target support\"\n\tdepends on BLK_DEV_DM\n\tselect CRYPTO\n\tselect CRYPTO_HASH\n\tselect DM_BUFIO\n\thelp\n\t  This device-mapper target creates a read-only device that\n\t  transparently validates the data on one underlying device against\n\t  a pre-generated tree of cryptographic checksums stored on a second\n\t  device.\n\n\t  You'll need to activate the digests you're going to use in the\n\t  cryptoapi configuration.\n\n\t  To compile this code as a module, choose M here: the module will\n\t  be called dm-verity.\n\n\t  If unsure, say N.\n\nconfig DM_VERITY_VERIFY_ROOTHASH_SIG\n\tdef_bool n\n\tbool \"Verity data device root hash signature verification support\"\n\tdepends on DM_VERITY\n\tselect SYSTEM_DATA_VERIFICATION\n\thelp\n\t  Add ability for dm-verity device to be validated if the\n\t  pre-generated tree of cryptographic checksums passed has a pkcs#7\n\t  signature file that can validate the roothash of the tree.\n\n\t  By default, rely on the builtin trusted keyring.\n\n\t  If unsure, say N.\n\nconfig DM_VERITY_VERIFY_ROOTHASH_SIG_SECONDARY_KEYRING\n\tbool \"Verity data device root hash signature verification with secondary keyring\"\n\tdepends on DM_VERITY_VERIFY_ROOTHASH_SIG\n\tdepends on SECONDARY_TRUSTED_KEYRING\n\thelp\n\t  Rely on the secondary trusted keyring to verify dm-verity signatures.\n\n\t  If unsure, say N.\n\nconfig DM_VERITY_FEC\n\tbool \"Verity forward error correction support\"\n\tdepends on DM_VERITY\n\tselect REED_SOLOMON\n\tselect REED_SOLOMON_DEC8\n\thelp\n\t  Add forward error correction support to dm-verity. This option\n\t  makes it possible to use pre-generated error correction data to\n\t  recover from corrupted blocks.\n\n\t  If unsure, say N.\n\nconfig DM_SWITCH\n\ttristate \"Switch target support (EXPERIMENTAL)\"\n\tdepends on BLK_DEV_DM\n\thelp\n\t  This device-mapper target creates a device that supports an arbitrary\n\t  mapping of fixed-size regions of I/O across a fixed set of paths.\n\t  The path used for any specific region can be switched dynamically\n\t  by sending the target a message.\n\n\t  To compile this code as a module, choose M here: the module will\n\t  be called dm-switch.\n\n\t  If unsure, say N.\n\nconfig DM_LOG_WRITES\n\ttristate \"Log writes target support\"\n\tdepends on BLK_DEV_DM\n\thelp\n\t  This device-mapper target takes two devices, one device to use\n\t  normally, one to log all write operations done to the first device.\n\t  This is for use by file system developers wishing to verify that\n\t  their fs is writing a consistent file system at all times by allowing\n\t  them to replay the log in a variety of ways and to check the\n\t  contents.\n\n\t  To compile this code as a module, choose M here: the module will\n\t  be called dm-log-writes.\n\n\t  If unsure, say N.\n\nconfig DM_INTEGRITY\n\ttristate \"Integrity target support\"\n\tdepends on BLK_DEV_DM\n\tselect BLK_DEV_INTEGRITY\n\tselect DM_BUFIO\n\tselect CRYPTO\n\tselect CRYPTO_SKCIPHER\n\tselect ASYNC_XOR\n\tselect DM_AUDIT if AUDIT\n\thelp\n\t  This device-mapper target emulates a block device that has\n\t  additional per-sector tags that can be used for storing\n\t  integrity information.\n\n\t  This integrity target is used with the dm-crypt target to\n\t  provide authenticated disk encryption or it can be used\n\t  standalone.\n\n\t  To compile this code as a module, choose M here: the module will\n\t  be called dm-integrity.\n\nconfig DM_ZONED\n\ttristate \"Drive-managed zoned block device target support\"\n\tdepends on BLK_DEV_DM\n\tdepends on BLK_DEV_ZONED\n\tselect CRC32\n\thelp\n\t  This device-mapper target takes a host-managed or host-aware zoned\n\t  block device and exposes most of its capacity as a regular block\n\t  device (drive-managed zoned block device) without any write\n\t  constraints. This is mainly intended for use with file systems that\n\t  do not natively support zoned block devices but still want to\n\t  benefit from the increased capacity offered by SMR disks. Other uses\n\t  by applications using raw block devices (for example object stores)\n\t  are also possible.\n\n\t  To compile this code as a module, choose M here: the module will\n\t  be called dm-zoned.\n\n\t  If unsure, say N.\n\nconfig DM_AUDIT\n\tbool \"DM audit events\"\n\tdepends on BLK_DEV_DM\n\tdepends on AUDIT\n\thelp\n\t  Generate audit events for device-mapper.\n\n\t  Enables audit logging of several security relevant events in the\n\t  particular device-mapper targets, especially the integrity target.\n\nendif # MD\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}