{
  "module_name": "dm-sysfs.c",
  "hash_id": "35077fefb08527463f56a32da493589c6802d6bc7b2f062cff17364d8980116f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/sysfs.h>\n#include <linux/dm-ioctl.h>\n#include \"dm-core.h\"\n#include \"dm-rq.h\"\n\nstruct dm_sysfs_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct mapped_device *md, char *p);\n\tssize_t (*store)(struct mapped_device *md, const char *p, size_t count);\n};\n\n#define DM_ATTR_RO(_name) \\\nstruct dm_sysfs_attr dm_attr_##_name = \\\n\t__ATTR(_name, 0444, dm_attr_##_name##_show, NULL)\n\nstatic ssize_t dm_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t    char *page)\n{\n\tstruct dm_sysfs_attr *dm_attr;\n\tstruct mapped_device *md;\n\tssize_t ret;\n\n\tdm_attr = container_of(attr, struct dm_sysfs_attr, attr);\n\tif (!dm_attr->show)\n\t\treturn -EIO;\n\n\tmd = dm_get_from_kobject(kobj);\n\tif (!md)\n\t\treturn -EINVAL;\n\n\tret = dm_attr->show(md, page);\n\tdm_put(md);\n\n\treturn ret;\n}\n\n#define DM_ATTR_RW(_name) \\\nstruct dm_sysfs_attr dm_attr_##_name = \\\n\t__ATTR(_name, 0644, dm_attr_##_name##_show, dm_attr_##_name##_store)\n\nstatic ssize_t dm_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t     const char *page, size_t count)\n{\n\tstruct dm_sysfs_attr *dm_attr;\n\tstruct mapped_device *md;\n\tssize_t ret;\n\n\tdm_attr = container_of(attr, struct dm_sysfs_attr, attr);\n\tif (!dm_attr->store)\n\t\treturn -EIO;\n\n\tmd = dm_get_from_kobject(kobj);\n\tif (!md)\n\t\treturn -EINVAL;\n\n\tret = dm_attr->store(md, page, count);\n\tdm_put(md);\n\n\treturn ret;\n}\n\nstatic ssize_t dm_attr_name_show(struct mapped_device *md, char *buf)\n{\n\tif (dm_copy_name_and_uuid(md, buf, NULL))\n\t\treturn -EIO;\n\n\tstrcat(buf, \"\\n\");\n\treturn strlen(buf);\n}\n\nstatic ssize_t dm_attr_uuid_show(struct mapped_device *md, char *buf)\n{\n\tif (dm_copy_name_and_uuid(md, NULL, buf))\n\t\treturn -EIO;\n\n\tstrcat(buf, \"\\n\");\n\treturn strlen(buf);\n}\n\nstatic ssize_t dm_attr_suspended_show(struct mapped_device *md, char *buf)\n{\n\tsprintf(buf, \"%d\\n\", dm_suspended_md(md));\n\n\treturn strlen(buf);\n}\n\nstatic ssize_t dm_attr_use_blk_mq_show(struct mapped_device *md, char *buf)\n{\n\t \n\tsprintf(buf, \"%d\\n\", true);\n\n\treturn strlen(buf);\n}\n\nstatic DM_ATTR_RO(name);\nstatic DM_ATTR_RO(uuid);\nstatic DM_ATTR_RO(suspended);\nstatic DM_ATTR_RO(use_blk_mq);\nstatic DM_ATTR_RW(rq_based_seq_io_merge_deadline);\n\nstatic struct attribute *dm_attrs[] = {\n\t&dm_attr_name.attr,\n\t&dm_attr_uuid.attr,\n\t&dm_attr_suspended.attr,\n\t&dm_attr_use_blk_mq.attr,\n\t&dm_attr_rq_based_seq_io_merge_deadline.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(dm);\n\nstatic const struct sysfs_ops dm_sysfs_ops = {\n\t.show\t= dm_attr_show,\n\t.store\t= dm_attr_store,\n};\n\nstatic const struct kobj_type dm_ktype = {\n\t.sysfs_ops\t= &dm_sysfs_ops,\n\t.default_groups\t= dm_groups,\n\t.release\t= dm_kobject_release,\n};\n\n \nint dm_sysfs_init(struct mapped_device *md)\n{\n\treturn kobject_init_and_add(dm_kobject(md), &dm_ktype,\n\t\t\t\t    &disk_to_dev(dm_disk(md))->kobj,\n\t\t\t\t    \"%s\", \"dm\");\n}\n\n \nvoid dm_sysfs_exit(struct mapped_device *md)\n{\n\tstruct kobject *kobj = dm_kobject(md);\n\n\tkobject_put(kobj);\n\twait_for_completion(dm_get_completion_from_kobject(kobj));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}