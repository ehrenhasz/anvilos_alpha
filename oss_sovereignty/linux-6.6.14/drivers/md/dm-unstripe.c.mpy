{
  "module_name": "dm-unstripe.c",
  "hash_id": "20166a899b2bef69e77d1c971fc240d10d8178c4915621639ec367776e16052d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-unstripe.c",
  "human_readable_source": "\n \n\n#include \"dm.h\"\n\n#include <linux/module.h>\n\nstruct unstripe_c {\n\tstruct dm_dev *dev;\n\tsector_t physical_start;\n\n\tuint32_t stripes;\n\n\tuint32_t unstripe;\n\tsector_t unstripe_width;\n\tsector_t unstripe_offset;\n\n\tuint32_t chunk_size;\n\tu8 chunk_shift;\n};\n\n#define DM_MSG_PREFIX \"unstriped\"\n\nstatic void cleanup_unstripe(struct unstripe_c *uc, struct dm_target *ti)\n{\n\tif (uc->dev)\n\t\tdm_put_device(ti, uc->dev);\n\tkfree(uc);\n}\n\n \nstatic int unstripe_ctr(struct dm_target *ti, unsigned int argc, char **argv)\n{\n\tstruct unstripe_c *uc;\n\tsector_t tmp_len;\n\tunsigned long long start;\n\tchar dummy;\n\n\tif (argc != 5) {\n\t\tti->error = \"Invalid number of arguments\";\n\t\treturn -EINVAL;\n\t}\n\n\tuc = kzalloc(sizeof(*uc), GFP_KERNEL);\n\tif (!uc) {\n\t\tti->error = \"Memory allocation for unstriped context failed\";\n\t\treturn -ENOMEM;\n\t}\n\n\tif (kstrtouint(argv[0], 10, &uc->stripes) || !uc->stripes) {\n\t\tti->error = \"Invalid stripe count\";\n\t\tgoto err;\n\t}\n\n\tif (kstrtouint(argv[1], 10, &uc->chunk_size) || !uc->chunk_size) {\n\t\tti->error = \"Invalid chunk_size\";\n\t\tgoto err;\n\t}\n\n\tif (kstrtouint(argv[2], 10, &uc->unstripe)) {\n\t\tti->error = \"Invalid stripe number\";\n\t\tgoto err;\n\t}\n\n\tif (uc->unstripe > uc->stripes && uc->stripes > 1) {\n\t\tti->error = \"Please provide stripe between [0, # of stripes]\";\n\t\tgoto err;\n\t}\n\n\tif (dm_get_device(ti, argv[3], dm_table_get_mode(ti->table), &uc->dev)) {\n\t\tti->error = \"Couldn't get striped device\";\n\t\tgoto err;\n\t}\n\n\tif (sscanf(argv[4], \"%llu%c\", &start, &dummy) != 1 || start != (sector_t)start) {\n\t\tti->error = \"Invalid striped device offset\";\n\t\tgoto err;\n\t}\n\tuc->physical_start = start;\n\n\tuc->unstripe_offset = uc->unstripe * uc->chunk_size;\n\tuc->unstripe_width = (uc->stripes - 1) * uc->chunk_size;\n\tuc->chunk_shift = is_power_of_2(uc->chunk_size) ? fls(uc->chunk_size) - 1 : 0;\n\n\ttmp_len = ti->len;\n\tif (sector_div(tmp_len, uc->chunk_size)) {\n\t\tti->error = \"Target length not divisible by chunk size\";\n\t\tgoto err;\n\t}\n\n\tif (dm_set_target_max_io_len(ti, uc->chunk_size)) {\n\t\tti->error = \"Failed to set max io len\";\n\t\tgoto err;\n\t}\n\n\tti->private = uc;\n\treturn 0;\nerr:\n\tcleanup_unstripe(uc, ti);\n\treturn -EINVAL;\n}\n\nstatic void unstripe_dtr(struct dm_target *ti)\n{\n\tstruct unstripe_c *uc = ti->private;\n\n\tcleanup_unstripe(uc, ti);\n}\n\nstatic sector_t map_to_core(struct dm_target *ti, struct bio *bio)\n{\n\tstruct unstripe_c *uc = ti->private;\n\tsector_t sector = bio->bi_iter.bi_sector;\n\tsector_t tmp_sector = sector;\n\n\t \n\tif (uc->chunk_shift)\n\t\ttmp_sector >>= uc->chunk_shift;\n\telse\n\t\tsector_div(tmp_sector, uc->chunk_size);\n\n\tsector += uc->unstripe_width * tmp_sector;\n\n\t \n\treturn sector + uc->unstripe_offset;\n}\n\nstatic int unstripe_map(struct dm_target *ti, struct bio *bio)\n{\n\tstruct unstripe_c *uc = ti->private;\n\n\tbio_set_dev(bio, uc->dev->bdev);\n\tbio->bi_iter.bi_sector = map_to_core(ti, bio) + uc->physical_start;\n\n\treturn DM_MAPIO_REMAPPED;\n}\n\nstatic void unstripe_status(struct dm_target *ti, status_type_t type,\n\t\t\t    unsigned int status_flags, char *result, unsigned int maxlen)\n{\n\tstruct unstripe_c *uc = ti->private;\n\tunsigned int sz = 0;\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\"%d %llu %d %s %llu\",\n\t\t       uc->stripes, (unsigned long long)uc->chunk_size, uc->unstripe,\n\t\t       uc->dev->name, (unsigned long long)uc->physical_start);\n\t\tbreak;\n\n\tcase STATUSTYPE_IMA:\n\t\t*result = '\\0';\n\t\tbreak;\n\t}\n}\n\nstatic int unstripe_iterate_devices(struct dm_target *ti,\n\t\t\t\t    iterate_devices_callout_fn fn, void *data)\n{\n\tstruct unstripe_c *uc = ti->private;\n\n\treturn fn(ti, uc->dev, uc->physical_start, ti->len, data);\n}\n\nstatic void unstripe_io_hints(struct dm_target *ti,\n\t\t\t       struct queue_limits *limits)\n{\n\tstruct unstripe_c *uc = ti->private;\n\n\tlimits->chunk_sectors = uc->chunk_size;\n}\n\nstatic struct target_type unstripe_target = {\n\t.name = \"unstriped\",\n\t.version = {1, 1, 0},\n\t.features = DM_TARGET_NOWAIT,\n\t.module = THIS_MODULE,\n\t.ctr = unstripe_ctr,\n\t.dtr = unstripe_dtr,\n\t.map = unstripe_map,\n\t.status = unstripe_status,\n\t.iterate_devices = unstripe_iterate_devices,\n\t.io_hints = unstripe_io_hints,\n};\nmodule_dm(unstripe);\n\nMODULE_DESCRIPTION(DM_NAME \" unstriped target\");\nMODULE_ALIAS(\"dm-unstriped\");\nMODULE_AUTHOR(\"Scott Bauer <scott.bauer@intel.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}