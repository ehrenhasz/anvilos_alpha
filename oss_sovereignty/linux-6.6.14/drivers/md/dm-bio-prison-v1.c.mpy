{
  "module_name": "dm-bio-prison-v1.c",
  "hash_id": "3bd1ee4920fc8815d728fabc7f9ebca1b59c8c432d4c01200164bc5f9c0fc821",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-bio-prison-v1.c",
  "human_readable_source": "\n \n\n#include \"dm.h\"\n#include \"dm-bio-prison-v1.h\"\n#include \"dm-bio-prison-v2.h\"\n\n#include <linux/spinlock.h>\n#include <linux/mempool.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n \n\n#define MIN_CELLS 1024\n\nstruct prison_region {\n\tspinlock_t lock;\n\tstruct rb_root cell;\n} ____cacheline_aligned_in_smp;\n\nstruct dm_bio_prison {\n\tmempool_t cell_pool;\n\tunsigned int num_locks;\n\tstruct prison_region regions[];\n};\n\nstatic struct kmem_cache *_cell_cache;\n\n \n\n \nstruct dm_bio_prison *dm_bio_prison_create(void)\n{\n\tint ret;\n\tunsigned int i, num_locks;\n\tstruct dm_bio_prison *prison;\n\n\tnum_locks = dm_num_hash_locks();\n\tprison = kzalloc(struct_size(prison, regions, num_locks), GFP_KERNEL);\n\tif (!prison)\n\t\treturn NULL;\n\tprison->num_locks = num_locks;\n\n\tfor (i = 0; i < prison->num_locks; i++) {\n\t\tspin_lock_init(&prison->regions[i].lock);\n\t\tprison->regions[i].cell = RB_ROOT;\n\t}\n\n\tret = mempool_init_slab_pool(&prison->cell_pool, MIN_CELLS, _cell_cache);\n\tif (ret) {\n\t\tkfree(prison);\n\t\treturn NULL;\n\t}\n\n\treturn prison;\n}\nEXPORT_SYMBOL_GPL(dm_bio_prison_create);\n\nvoid dm_bio_prison_destroy(struct dm_bio_prison *prison)\n{\n\tmempool_exit(&prison->cell_pool);\n\tkfree(prison);\n}\nEXPORT_SYMBOL_GPL(dm_bio_prison_destroy);\n\nstruct dm_bio_prison_cell *dm_bio_prison_alloc_cell(struct dm_bio_prison *prison, gfp_t gfp)\n{\n\treturn mempool_alloc(&prison->cell_pool, gfp);\n}\nEXPORT_SYMBOL_GPL(dm_bio_prison_alloc_cell);\n\nvoid dm_bio_prison_free_cell(struct dm_bio_prison *prison,\n\t\t\t     struct dm_bio_prison_cell *cell)\n{\n\tmempool_free(cell, &prison->cell_pool);\n}\nEXPORT_SYMBOL_GPL(dm_bio_prison_free_cell);\n\nstatic void __setup_new_cell(struct dm_cell_key *key,\n\t\t\t     struct bio *holder,\n\t\t\t     struct dm_bio_prison_cell *cell)\n{\n\tmemcpy(&cell->key, key, sizeof(cell->key));\n\tcell->holder = holder;\n\tbio_list_init(&cell->bios);\n}\n\nstatic int cmp_keys(struct dm_cell_key *lhs,\n\t\t    struct dm_cell_key *rhs)\n{\n\tif (lhs->virtual < rhs->virtual)\n\t\treturn -1;\n\n\tif (lhs->virtual > rhs->virtual)\n\t\treturn 1;\n\n\tif (lhs->dev < rhs->dev)\n\t\treturn -1;\n\n\tif (lhs->dev > rhs->dev)\n\t\treturn 1;\n\n\tif (lhs->block_end <= rhs->block_begin)\n\t\treturn -1;\n\n\tif (lhs->block_begin >= rhs->block_end)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline unsigned int lock_nr(struct dm_cell_key *key, unsigned int num_locks)\n{\n\treturn dm_hash_locks_index((key->block_begin >> BIO_PRISON_MAX_RANGE_SHIFT),\n\t\t\t\t   num_locks);\n}\n\nbool dm_cell_key_has_valid_range(struct dm_cell_key *key)\n{\n\tif (WARN_ON_ONCE(key->block_end - key->block_begin > BIO_PRISON_MAX_RANGE))\n\t\treturn false;\n\tif (WARN_ON_ONCE((key->block_begin >> BIO_PRISON_MAX_RANGE_SHIFT) !=\n\t\t\t (key->block_end - 1) >> BIO_PRISON_MAX_RANGE_SHIFT))\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(dm_cell_key_has_valid_range);\n\nstatic int __bio_detain(struct rb_root *root,\n\t\t\tstruct dm_cell_key *key,\n\t\t\tstruct bio *inmate,\n\t\t\tstruct dm_bio_prison_cell *cell_prealloc,\n\t\t\tstruct dm_bio_prison_cell **cell_result)\n{\n\tint r;\n\tstruct rb_node **new = &root->rb_node, *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct dm_bio_prison_cell *cell =\n\t\t\trb_entry(*new, struct dm_bio_prison_cell, node);\n\n\t\tr = cmp_keys(key, &cell->key);\n\n\t\tparent = *new;\n\t\tif (r < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (r > 0)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse {\n\t\t\tif (inmate)\n\t\t\t\tbio_list_add(&cell->bios, inmate);\n\t\t\t*cell_result = cell;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t__setup_new_cell(key, inmate, cell_prealloc);\n\t*cell_result = cell_prealloc;\n\n\trb_link_node(&cell_prealloc->node, parent, new);\n\trb_insert_color(&cell_prealloc->node, root);\n\n\treturn 0;\n}\n\nstatic int bio_detain(struct dm_bio_prison *prison,\n\t\t      struct dm_cell_key *key,\n\t\t      struct bio *inmate,\n\t\t      struct dm_bio_prison_cell *cell_prealloc,\n\t\t      struct dm_bio_prison_cell **cell_result)\n{\n\tint r;\n\tunsigned l = lock_nr(key, prison->num_locks);\n\n\tspin_lock_irq(&prison->regions[l].lock);\n\tr = __bio_detain(&prison->regions[l].cell, key, inmate, cell_prealloc, cell_result);\n\tspin_unlock_irq(&prison->regions[l].lock);\n\n\treturn r;\n}\n\nint dm_bio_detain(struct dm_bio_prison *prison,\n\t\t  struct dm_cell_key *key,\n\t\t  struct bio *inmate,\n\t\t  struct dm_bio_prison_cell *cell_prealloc,\n\t\t  struct dm_bio_prison_cell **cell_result)\n{\n\treturn bio_detain(prison, key, inmate, cell_prealloc, cell_result);\n}\nEXPORT_SYMBOL_GPL(dm_bio_detain);\n\nint dm_get_cell(struct dm_bio_prison *prison,\n\t\tstruct dm_cell_key *key,\n\t\tstruct dm_bio_prison_cell *cell_prealloc,\n\t\tstruct dm_bio_prison_cell **cell_result)\n{\n\treturn bio_detain(prison, key, NULL, cell_prealloc, cell_result);\n}\nEXPORT_SYMBOL_GPL(dm_get_cell);\n\n \nstatic void __cell_release(struct rb_root *root,\n\t\t\t   struct dm_bio_prison_cell *cell,\n\t\t\t   struct bio_list *inmates)\n{\n\trb_erase(&cell->node, root);\n\n\tif (inmates) {\n\t\tif (cell->holder)\n\t\t\tbio_list_add(inmates, cell->holder);\n\t\tbio_list_merge(inmates, &cell->bios);\n\t}\n}\n\nvoid dm_cell_release(struct dm_bio_prison *prison,\n\t\t     struct dm_bio_prison_cell *cell,\n\t\t     struct bio_list *bios)\n{\n\tunsigned l = lock_nr(&cell->key, prison->num_locks);\n\n\tspin_lock_irq(&prison->regions[l].lock);\n\t__cell_release(&prison->regions[l].cell, cell, bios);\n\tspin_unlock_irq(&prison->regions[l].lock);\n}\nEXPORT_SYMBOL_GPL(dm_cell_release);\n\n \nstatic void __cell_release_no_holder(struct rb_root *root,\n\t\t\t\t     struct dm_bio_prison_cell *cell,\n\t\t\t\t     struct bio_list *inmates)\n{\n\trb_erase(&cell->node, root);\n\tbio_list_merge(inmates, &cell->bios);\n}\n\nvoid dm_cell_release_no_holder(struct dm_bio_prison *prison,\n\t\t\t       struct dm_bio_prison_cell *cell,\n\t\t\t       struct bio_list *inmates)\n{\n\tunsigned l = lock_nr(&cell->key, prison->num_locks);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prison->regions[l].lock, flags);\n\t__cell_release_no_holder(&prison->regions[l].cell, cell, inmates);\n\tspin_unlock_irqrestore(&prison->regions[l].lock, flags);\n}\nEXPORT_SYMBOL_GPL(dm_cell_release_no_holder);\n\nvoid dm_cell_error(struct dm_bio_prison *prison,\n\t\t   struct dm_bio_prison_cell *cell, blk_status_t error)\n{\n\tstruct bio_list bios;\n\tstruct bio *bio;\n\n\tbio_list_init(&bios);\n\tdm_cell_release(prison, cell, &bios);\n\n\twhile ((bio = bio_list_pop(&bios))) {\n\t\tbio->bi_status = error;\n\t\tbio_endio(bio);\n\t}\n}\nEXPORT_SYMBOL_GPL(dm_cell_error);\n\nvoid dm_cell_visit_release(struct dm_bio_prison *prison,\n\t\t\t   void (*visit_fn)(void *, struct dm_bio_prison_cell *),\n\t\t\t   void *context,\n\t\t\t   struct dm_bio_prison_cell *cell)\n{\n\tunsigned l = lock_nr(&cell->key, prison->num_locks);\n\tspin_lock_irq(&prison->regions[l].lock);\n\tvisit_fn(context, cell);\n\trb_erase(&cell->node, &prison->regions[l].cell);\n\tspin_unlock_irq(&prison->regions[l].lock);\n}\nEXPORT_SYMBOL_GPL(dm_cell_visit_release);\n\nstatic int __promote_or_release(struct rb_root *root,\n\t\t\t\tstruct dm_bio_prison_cell *cell)\n{\n\tif (bio_list_empty(&cell->bios)) {\n\t\trb_erase(&cell->node, root);\n\t\treturn 1;\n\t}\n\n\tcell->holder = bio_list_pop(&cell->bios);\n\treturn 0;\n}\n\nint dm_cell_promote_or_release(struct dm_bio_prison *prison,\n\t\t\t       struct dm_bio_prison_cell *cell)\n{\n\tint r;\n\tunsigned l = lock_nr(&cell->key, prison->num_locks);\n\n\tspin_lock_irq(&prison->regions[l].lock);\n\tr = __promote_or_release(&prison->regions[l].cell, cell);\n\tspin_unlock_irq(&prison->regions[l].lock);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_cell_promote_or_release);\n\n \n\n#define DEFERRED_SET_SIZE 64\n\nstruct dm_deferred_entry {\n\tstruct dm_deferred_set *ds;\n\tunsigned int count;\n\tstruct list_head work_items;\n};\n\nstruct dm_deferred_set {\n\tspinlock_t lock;\n\tunsigned int current_entry;\n\tunsigned int sweeper;\n\tstruct dm_deferred_entry entries[DEFERRED_SET_SIZE];\n};\n\nstruct dm_deferred_set *dm_deferred_set_create(void)\n{\n\tint i;\n\tstruct dm_deferred_set *ds;\n\n\tds = kmalloc(sizeof(*ds), GFP_KERNEL);\n\tif (!ds)\n\t\treturn NULL;\n\n\tspin_lock_init(&ds->lock);\n\tds->current_entry = 0;\n\tds->sweeper = 0;\n\tfor (i = 0; i < DEFERRED_SET_SIZE; i++) {\n\t\tds->entries[i].ds = ds;\n\t\tds->entries[i].count = 0;\n\t\tINIT_LIST_HEAD(&ds->entries[i].work_items);\n\t}\n\n\treturn ds;\n}\nEXPORT_SYMBOL_GPL(dm_deferred_set_create);\n\nvoid dm_deferred_set_destroy(struct dm_deferred_set *ds)\n{\n\tkfree(ds);\n}\nEXPORT_SYMBOL_GPL(dm_deferred_set_destroy);\n\nstruct dm_deferred_entry *dm_deferred_entry_inc(struct dm_deferred_set *ds)\n{\n\tunsigned long flags;\n\tstruct dm_deferred_entry *entry;\n\n\tspin_lock_irqsave(&ds->lock, flags);\n\tentry = ds->entries + ds->current_entry;\n\tentry->count++;\n\tspin_unlock_irqrestore(&ds->lock, flags);\n\n\treturn entry;\n}\nEXPORT_SYMBOL_GPL(dm_deferred_entry_inc);\n\nstatic unsigned int ds_next(unsigned int index)\n{\n\treturn (index + 1) % DEFERRED_SET_SIZE;\n}\n\nstatic void __sweep(struct dm_deferred_set *ds, struct list_head *head)\n{\n\twhile ((ds->sweeper != ds->current_entry) &&\n\t       !ds->entries[ds->sweeper].count) {\n\t\tlist_splice_init(&ds->entries[ds->sweeper].work_items, head);\n\t\tds->sweeper = ds_next(ds->sweeper);\n\t}\n\n\tif ((ds->sweeper == ds->current_entry) && !ds->entries[ds->sweeper].count)\n\t\tlist_splice_init(&ds->entries[ds->sweeper].work_items, head);\n}\n\nvoid dm_deferred_entry_dec(struct dm_deferred_entry *entry, struct list_head *head)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&entry->ds->lock, flags);\n\tBUG_ON(!entry->count);\n\t--entry->count;\n\t__sweep(entry->ds, head);\n\tspin_unlock_irqrestore(&entry->ds->lock, flags);\n}\nEXPORT_SYMBOL_GPL(dm_deferred_entry_dec);\n\n \nint dm_deferred_set_add_work(struct dm_deferred_set *ds, struct list_head *work)\n{\n\tint r = 1;\n\tunsigned int next_entry;\n\n\tspin_lock_irq(&ds->lock);\n\tif ((ds->sweeper == ds->current_entry) &&\n\t    !ds->entries[ds->current_entry].count)\n\t\tr = 0;\n\telse {\n\t\tlist_add(work, &ds->entries[ds->current_entry].work_items);\n\t\tnext_entry = ds_next(ds->current_entry);\n\t\tif (!ds->entries[next_entry].count)\n\t\t\tds->current_entry = next_entry;\n\t}\n\tspin_unlock_irq(&ds->lock);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(dm_deferred_set_add_work);\n\n \n\nstatic int __init dm_bio_prison_init_v1(void)\n{\n\t_cell_cache = KMEM_CACHE(dm_bio_prison_cell, 0);\n\tif (!_cell_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void dm_bio_prison_exit_v1(void)\n{\n\tkmem_cache_destroy(_cell_cache);\n\t_cell_cache = NULL;\n}\n\nstatic int (*_inits[])(void) __initdata = {\n\tdm_bio_prison_init_v1,\n\tdm_bio_prison_init_v2,\n};\n\nstatic void (*_exits[])(void) = {\n\tdm_bio_prison_exit_v1,\n\tdm_bio_prison_exit_v2,\n};\n\nstatic int __init dm_bio_prison_init(void)\n{\n\tconst int count = ARRAY_SIZE(_inits);\n\n\tint r, i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tr = _inits[i]();\n\t\tif (r)\n\t\t\tgoto bad;\n\t}\n\n\treturn 0;\n\nbad:\n\twhile (i--)\n\t\t_exits[i]();\n\n\treturn r;\n}\n\nstatic void __exit dm_bio_prison_exit(void)\n{\n\tint i = ARRAY_SIZE(_exits);\n\n\twhile (i--)\n\t\t_exits[i]();\n}\n\n \nmodule_init(dm_bio_prison_init);\nmodule_exit(dm_bio_prison_exit);\n\nMODULE_DESCRIPTION(DM_NAME \" bio prison\");\nMODULE_AUTHOR(\"Joe Thornber <dm-devel@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}