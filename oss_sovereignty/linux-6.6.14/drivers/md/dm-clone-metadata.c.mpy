{
  "module_name": "dm-clone-metadata.c",
  "hash_id": "4d4a16961c2ba461ebdb5a6897e07c9dae86ee129eb6c6392b18a6c81af2305b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-clone-metadata.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/device-mapper.h>\n\n#include \"persistent-data/dm-bitset.h\"\n#include \"persistent-data/dm-space-map.h\"\n#include \"persistent-data/dm-block-manager.h\"\n#include \"persistent-data/dm-transaction-manager.h\"\n\n#include \"dm-clone-metadata.h\"\n\n#define DM_MSG_PREFIX \"clone metadata\"\n\n#define SUPERBLOCK_LOCATION 0\n#define SUPERBLOCK_MAGIC 0x8af27f64\n#define SUPERBLOCK_CSUM_XOR 257649492\n\n#define DM_CLONE_MAX_CONCURRENT_LOCKS 5\n\n#define UUID_LEN 16\n\n \n#define DM_CLONE_MIN_METADATA_VERSION 1\n#define DM_CLONE_MAX_METADATA_VERSION 1\n\n \nstruct superblock_disk {\n\t__le32 csum;\n\t__le32 flags;\n\t__le64 blocknr;\n\n\t__u8 uuid[UUID_LEN];\n\t__le64 magic;\n\t__le32 version;\n\n\t__u8 metadata_space_map_root[SPACE_MAP_ROOT_SIZE];\n\n\t__le64 region_size;\n\t__le64 target_size;\n\n\t__le64 bitset_root;\n} __packed;\n\n \nstruct dirty_map {\n\tunsigned long *dirty_words;\n\tunsigned long *dirty_regions;\n\tunsigned int changed;\n};\n\nstruct dm_clone_metadata {\n\t \n\tstruct block_device *bdev;\n\n\tsector_t target_size;\n\tsector_t region_size;\n\tunsigned long nr_regions;\n\tunsigned long nr_words;\n\n\t \n\tspinlock_t bitmap_lock;\n\tstruct dirty_map dmap[2];\n\tstruct dirty_map *current_dmap;\n\n\t \n\tstruct dirty_map *committing_dmap;\n\n\t \n\tunsigned long *region_map;\n\n\t \n\tunsigned int read_only;\n\n\tstruct dm_block_manager *bm;\n\tstruct dm_space_map *sm;\n\tstruct dm_transaction_manager *tm;\n\n\tstruct rw_semaphore lock;\n\n\tstruct dm_disk_bitset bitset_info;\n\tdm_block_t bitset_root;\n\n\t \n\t__u8 metadata_space_map_root[SPACE_MAP_ROOT_SIZE];\n\n\tbool hydration_done:1;\n\tbool fail_io:1;\n};\n\n \n\n \nstatic void sb_prepare_for_write(struct dm_block_validator *v,\n\t\t\t\t struct dm_block *b, size_t sb_block_size)\n{\n\tstruct superblock_disk *sb;\n\tu32 csum;\n\n\tsb = dm_block_data(b);\n\tsb->blocknr = cpu_to_le64(dm_block_location(b));\n\n\tcsum = dm_bm_checksum(&sb->flags, sb_block_size - sizeof(__le32),\n\t\t\t      SUPERBLOCK_CSUM_XOR);\n\tsb->csum = cpu_to_le32(csum);\n}\n\nstatic int sb_check(struct dm_block_validator *v, struct dm_block *b,\n\t\t    size_t sb_block_size)\n{\n\tstruct superblock_disk *sb;\n\tu32 csum, metadata_version;\n\n\tsb = dm_block_data(b);\n\n\tif (dm_block_location(b) != le64_to_cpu(sb->blocknr)) {\n\t\tDMERR(\"Superblock check failed: blocknr %llu, expected %llu\",\n\t\t      le64_to_cpu(sb->blocknr),\n\t\t      (unsigned long long)dm_block_location(b));\n\t\treturn -ENOTBLK;\n\t}\n\n\tif (le64_to_cpu(sb->magic) != SUPERBLOCK_MAGIC) {\n\t\tDMERR(\"Superblock check failed: magic %llu, expected %llu\",\n\t\t      le64_to_cpu(sb->magic),\n\t\t      (unsigned long long)SUPERBLOCK_MAGIC);\n\t\treturn -EILSEQ;\n\t}\n\n\tcsum = dm_bm_checksum(&sb->flags, sb_block_size - sizeof(__le32),\n\t\t\t      SUPERBLOCK_CSUM_XOR);\n\tif (sb->csum != cpu_to_le32(csum)) {\n\t\tDMERR(\"Superblock check failed: checksum %u, expected %u\",\n\t\t      csum, le32_to_cpu(sb->csum));\n\t\treturn -EILSEQ;\n\t}\n\n\t \n\tmetadata_version = le32_to_cpu(sb->version);\n\tif (metadata_version < DM_CLONE_MIN_METADATA_VERSION ||\n\t    metadata_version > DM_CLONE_MAX_METADATA_VERSION) {\n\t\tDMERR(\"Clone metadata version %u found, but only versions between %u and %u supported.\",\n\t\t      metadata_version, DM_CLONE_MIN_METADATA_VERSION,\n\t\t      DM_CLONE_MAX_METADATA_VERSION);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct dm_block_validator sb_validator = {\n\t.name = \"superblock\",\n\t.prepare_for_write = sb_prepare_for_write,\n\t.check = sb_check\n};\n\n \nstatic int __superblock_all_zeroes(struct dm_block_manager *bm, bool *formatted)\n{\n\tint r;\n\tunsigned int i, nr_words;\n\tstruct dm_block *sblock;\n\t__le64 *data_le, zero = cpu_to_le64(0);\n\n\t \n\tr = dm_bm_read_lock(bm, SUPERBLOCK_LOCATION, NULL, &sblock);\n\tif (r) {\n\t\tDMERR(\"Failed to read_lock superblock\");\n\t\treturn r;\n\t}\n\n\tdata_le = dm_block_data(sblock);\n\t*formatted = false;\n\n\t \n\tBUG_ON(dm_bm_block_size(bm) % sizeof(__le64));\n\tnr_words = dm_bm_block_size(bm) / sizeof(__le64);\n\tfor (i = 0; i < nr_words; i++) {\n\t\tif (data_le[i] != zero) {\n\t\t\t*formatted = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdm_bm_unlock(sblock);\n\n\treturn 0;\n}\n\n \n\n \nstatic inline int superblock_read_lock(struct dm_clone_metadata *cmd,\n\t\t\t\t       struct dm_block **sblock)\n{\n\treturn dm_bm_read_lock(cmd->bm, SUPERBLOCK_LOCATION, &sb_validator, sblock);\n}\n\nstatic inline int superblock_write_lock_zero(struct dm_clone_metadata *cmd,\n\t\t\t\t\t     struct dm_block **sblock)\n{\n\treturn dm_bm_write_lock_zero(cmd->bm, SUPERBLOCK_LOCATION, &sb_validator, sblock);\n}\n\nstatic int __copy_sm_root(struct dm_clone_metadata *cmd)\n{\n\tint r;\n\tsize_t root_size;\n\n\tr = dm_sm_root_size(cmd->sm, &root_size);\n\tif (r)\n\t\treturn r;\n\n\treturn dm_sm_copy_root(cmd->sm, &cmd->metadata_space_map_root, root_size);\n}\n\n \nstatic void __prepare_superblock(struct dm_clone_metadata *cmd,\n\t\t\t\t struct superblock_disk *sb)\n{\n\tsb->flags = cpu_to_le32(0UL);\n\n\t \n\tmemset(sb->uuid, 0, sizeof(sb->uuid));\n\n\tsb->magic = cpu_to_le64(SUPERBLOCK_MAGIC);\n\tsb->version = cpu_to_le32(DM_CLONE_MAX_METADATA_VERSION);\n\n\t \n\tmemcpy(&sb->metadata_space_map_root, &cmd->metadata_space_map_root,\n\t       sizeof(cmd->metadata_space_map_root));\n\n\tsb->region_size = cpu_to_le64(cmd->region_size);\n\tsb->target_size = cpu_to_le64(cmd->target_size);\n\tsb->bitset_root = cpu_to_le64(cmd->bitset_root);\n}\n\nstatic int __open_metadata(struct dm_clone_metadata *cmd)\n{\n\tint r;\n\tstruct dm_block *sblock;\n\tstruct superblock_disk *sb;\n\n\tr = superblock_read_lock(cmd, &sblock);\n\n\tif (r) {\n\t\tDMERR(\"Failed to read_lock superblock\");\n\t\treturn r;\n\t}\n\n\tsb = dm_block_data(sblock);\n\n\t \n\tif (cmd->region_size != le64_to_cpu(sb->region_size) ||\n\t    cmd->target_size != le64_to_cpu(sb->target_size)) {\n\t\tDMERR(\"Region and/or target size don't match the ones in metadata\");\n\t\tr = -EINVAL;\n\t\tgoto out_with_lock;\n\t}\n\n\tr = dm_tm_open_with_sm(cmd->bm, SUPERBLOCK_LOCATION,\n\t\t\t       sb->metadata_space_map_root,\n\t\t\t       sizeof(sb->metadata_space_map_root),\n\t\t\t       &cmd->tm, &cmd->sm);\n\n\tif (r) {\n\t\tDMERR(\"dm_tm_open_with_sm failed\");\n\t\tgoto out_with_lock;\n\t}\n\n\tdm_disk_bitset_init(cmd->tm, &cmd->bitset_info);\n\tcmd->bitset_root = le64_to_cpu(sb->bitset_root);\n\nout_with_lock:\n\tdm_bm_unlock(sblock);\n\n\treturn r;\n}\n\nstatic int __format_metadata(struct dm_clone_metadata *cmd)\n{\n\tint r;\n\tstruct dm_block *sblock;\n\tstruct superblock_disk *sb;\n\n\tr = dm_tm_create_with_sm(cmd->bm, SUPERBLOCK_LOCATION, &cmd->tm, &cmd->sm);\n\tif (r) {\n\t\tDMERR(\"Failed to create transaction manager\");\n\t\treturn r;\n\t}\n\n\tdm_disk_bitset_init(cmd->tm, &cmd->bitset_info);\n\n\tr = dm_bitset_empty(&cmd->bitset_info, &cmd->bitset_root);\n\tif (r) {\n\t\tDMERR(\"Failed to create empty on-disk bitset\");\n\t\tgoto err_with_tm;\n\t}\n\n\tr = dm_bitset_resize(&cmd->bitset_info, cmd->bitset_root, 0,\n\t\t\t     cmd->nr_regions, false, &cmd->bitset_root);\n\tif (r) {\n\t\tDMERR(\"Failed to resize on-disk bitset to %lu entries\", cmd->nr_regions);\n\t\tgoto err_with_tm;\n\t}\n\n\t \n\tr = dm_tm_pre_commit(cmd->tm);\n\tif (r) {\n\t\tDMERR(\"dm_tm_pre_commit failed\");\n\t\tgoto err_with_tm;\n\t}\n\n\tr = __copy_sm_root(cmd);\n\tif (r) {\n\t\tDMERR(\"__copy_sm_root failed\");\n\t\tgoto err_with_tm;\n\t}\n\n\tr = superblock_write_lock_zero(cmd, &sblock);\n\tif (r) {\n\t\tDMERR(\"Failed to write_lock superblock\");\n\t\tgoto err_with_tm;\n\t}\n\n\tsb = dm_block_data(sblock);\n\t__prepare_superblock(cmd, sb);\n\tr = dm_tm_commit(cmd->tm, sblock);\n\tif (r) {\n\t\tDMERR(\"Failed to commit superblock\");\n\t\tgoto err_with_tm;\n\t}\n\n\treturn 0;\n\nerr_with_tm:\n\tdm_sm_destroy(cmd->sm);\n\tdm_tm_destroy(cmd->tm);\n\n\treturn r;\n}\n\nstatic int __open_or_format_metadata(struct dm_clone_metadata *cmd, bool may_format_device)\n{\n\tint r;\n\tbool formatted = false;\n\n\tr = __superblock_all_zeroes(cmd->bm, &formatted);\n\tif (r)\n\t\treturn r;\n\n\tif (!formatted)\n\t\treturn may_format_device ? __format_metadata(cmd) : -EPERM;\n\n\treturn __open_metadata(cmd);\n}\n\nstatic int __create_persistent_data_structures(struct dm_clone_metadata *cmd,\n\t\t\t\t\t       bool may_format_device)\n{\n\tint r;\n\n\t \n\tcmd->bm = dm_block_manager_create(cmd->bdev,\n\t\t\t\t\t DM_CLONE_METADATA_BLOCK_SIZE << SECTOR_SHIFT,\n\t\t\t\t\t DM_CLONE_MAX_CONCURRENT_LOCKS);\n\tif (IS_ERR(cmd->bm)) {\n\t\tDMERR(\"Failed to create block manager\");\n\t\treturn PTR_ERR(cmd->bm);\n\t}\n\n\tr = __open_or_format_metadata(cmd, may_format_device);\n\tif (r)\n\t\tdm_block_manager_destroy(cmd->bm);\n\n\treturn r;\n}\n\nstatic void __destroy_persistent_data_structures(struct dm_clone_metadata *cmd)\n{\n\tdm_sm_destroy(cmd->sm);\n\tdm_tm_destroy(cmd->tm);\n\tdm_block_manager_destroy(cmd->bm);\n}\n\n \n\nstatic size_t bitmap_size(unsigned long nr_bits)\n{\n\treturn BITS_TO_LONGS(nr_bits) * sizeof(long);\n}\n\nstatic int __dirty_map_init(struct dirty_map *dmap, unsigned long nr_words,\n\t\t\t    unsigned long nr_regions)\n{\n\tdmap->changed = 0;\n\n\tdmap->dirty_words = kvzalloc(bitmap_size(nr_words), GFP_KERNEL);\n\tif (!dmap->dirty_words)\n\t\treturn -ENOMEM;\n\n\tdmap->dirty_regions = kvzalloc(bitmap_size(nr_regions), GFP_KERNEL);\n\tif (!dmap->dirty_regions) {\n\t\tkvfree(dmap->dirty_words);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void __dirty_map_exit(struct dirty_map *dmap)\n{\n\tkvfree(dmap->dirty_words);\n\tkvfree(dmap->dirty_regions);\n}\n\nstatic int dirty_map_init(struct dm_clone_metadata *cmd)\n{\n\tif (__dirty_map_init(&cmd->dmap[0], cmd->nr_words, cmd->nr_regions)) {\n\t\tDMERR(\"Failed to allocate dirty bitmap\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (__dirty_map_init(&cmd->dmap[1], cmd->nr_words, cmd->nr_regions)) {\n\t\tDMERR(\"Failed to allocate dirty bitmap\");\n\t\t__dirty_map_exit(&cmd->dmap[0]);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd->current_dmap = &cmd->dmap[0];\n\tcmd->committing_dmap = NULL;\n\n\treturn 0;\n}\n\nstatic void dirty_map_exit(struct dm_clone_metadata *cmd)\n{\n\t__dirty_map_exit(&cmd->dmap[0]);\n\t__dirty_map_exit(&cmd->dmap[1]);\n}\n\nstatic int __load_bitset_in_core(struct dm_clone_metadata *cmd)\n{\n\tint r;\n\tunsigned long i;\n\tstruct dm_bitset_cursor c;\n\n\t \n\tr = dm_bitset_flush(&cmd->bitset_info, cmd->bitset_root, &cmd->bitset_root);\n\tif (r)\n\t\treturn r;\n\n\tr = dm_bitset_cursor_begin(&cmd->bitset_info, cmd->bitset_root, cmd->nr_regions, &c);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; ; i++) {\n\t\tif (dm_bitset_cursor_get_value(&c))\n\t\t\t__set_bit(i, cmd->region_map);\n\t\telse\n\t\t\t__clear_bit(i, cmd->region_map);\n\n\t\tif (i >= (cmd->nr_regions - 1))\n\t\t\tbreak;\n\n\t\tr = dm_bitset_cursor_next(&c);\n\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\tdm_bitset_cursor_end(&c);\n\n\treturn r;\n}\n\nstruct dm_clone_metadata *dm_clone_metadata_open(struct block_device *bdev,\n\t\t\t\t\t\t sector_t target_size,\n\t\t\t\t\t\t sector_t region_size)\n{\n\tint r;\n\tstruct dm_clone_metadata *cmd;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tDMERR(\"Failed to allocate memory for dm-clone metadata\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tcmd->bdev = bdev;\n\tcmd->target_size = target_size;\n\tcmd->region_size = region_size;\n\tcmd->nr_regions = dm_sector_div_up(cmd->target_size, cmd->region_size);\n\tcmd->nr_words = BITS_TO_LONGS(cmd->nr_regions);\n\n\tinit_rwsem(&cmd->lock);\n\tspin_lock_init(&cmd->bitmap_lock);\n\tcmd->read_only = 0;\n\tcmd->fail_io = false;\n\tcmd->hydration_done = false;\n\n\tcmd->region_map = kvmalloc(bitmap_size(cmd->nr_regions), GFP_KERNEL);\n\tif (!cmd->region_map) {\n\t\tDMERR(\"Failed to allocate memory for region bitmap\");\n\t\tr = -ENOMEM;\n\t\tgoto out_with_md;\n\t}\n\n\tr = __create_persistent_data_structures(cmd, true);\n\tif (r)\n\t\tgoto out_with_region_map;\n\n\tr = __load_bitset_in_core(cmd);\n\tif (r) {\n\t\tDMERR(\"Failed to load on-disk region map\");\n\t\tgoto out_with_pds;\n\t}\n\n\tr = dirty_map_init(cmd);\n\tif (r)\n\t\tgoto out_with_pds;\n\n\tif (bitmap_full(cmd->region_map, cmd->nr_regions))\n\t\tcmd->hydration_done = true;\n\n\treturn cmd;\n\nout_with_pds:\n\t__destroy_persistent_data_structures(cmd);\n\nout_with_region_map:\n\tkvfree(cmd->region_map);\n\nout_with_md:\n\tkfree(cmd);\n\n\treturn ERR_PTR(r);\n}\n\nvoid dm_clone_metadata_close(struct dm_clone_metadata *cmd)\n{\n\tif (!cmd->fail_io)\n\t\t__destroy_persistent_data_structures(cmd);\n\n\tdirty_map_exit(cmd);\n\tkvfree(cmd->region_map);\n\tkfree(cmd);\n}\n\nbool dm_clone_is_hydration_done(struct dm_clone_metadata *cmd)\n{\n\treturn cmd->hydration_done;\n}\n\nbool dm_clone_is_region_hydrated(struct dm_clone_metadata *cmd, unsigned long region_nr)\n{\n\treturn dm_clone_is_hydration_done(cmd) || test_bit(region_nr, cmd->region_map);\n}\n\nbool dm_clone_is_range_hydrated(struct dm_clone_metadata *cmd,\n\t\t\t\tunsigned long start, unsigned long nr_regions)\n{\n\tunsigned long bit;\n\n\tif (dm_clone_is_hydration_done(cmd))\n\t\treturn true;\n\n\tbit = find_next_zero_bit(cmd->region_map, cmd->nr_regions, start);\n\n\treturn (bit >= (start + nr_regions));\n}\n\nunsigned int dm_clone_nr_of_hydrated_regions(struct dm_clone_metadata *cmd)\n{\n\treturn bitmap_weight(cmd->region_map, cmd->nr_regions);\n}\n\nunsigned long dm_clone_find_next_unhydrated_region(struct dm_clone_metadata *cmd,\n\t\t\t\t\t\t   unsigned long start)\n{\n\treturn find_next_zero_bit(cmd->region_map, cmd->nr_regions, start);\n}\n\nstatic int __update_metadata_word(struct dm_clone_metadata *cmd,\n\t\t\t\t  unsigned long *dirty_regions,\n\t\t\t\t  unsigned long word)\n{\n\tint r;\n\tunsigned long index = word * BITS_PER_LONG;\n\tunsigned long max_index = min(cmd->nr_regions, (word + 1) * BITS_PER_LONG);\n\n\twhile (index < max_index) {\n\t\tif (test_bit(index, dirty_regions)) {\n\t\t\tr = dm_bitset_set_bit(&cmd->bitset_info, cmd->bitset_root,\n\t\t\t\t\t      index, &cmd->bitset_root);\n\t\t\tif (r) {\n\t\t\t\tDMERR(\"dm_bitset_set_bit failed\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\t__clear_bit(index, dirty_regions);\n\t\t}\n\t\tindex++;\n\t}\n\n\treturn 0;\n}\n\nstatic int __metadata_commit(struct dm_clone_metadata *cmd)\n{\n\tint r;\n\tstruct dm_block *sblock;\n\tstruct superblock_disk *sb;\n\n\t \n\tr = dm_bitset_flush(&cmd->bitset_info, cmd->bitset_root, &cmd->bitset_root);\n\tif (r) {\n\t\tDMERR(\"dm_bitset_flush failed\");\n\t\treturn r;\n\t}\n\n\t \n\tr = dm_tm_pre_commit(cmd->tm);\n\tif (r) {\n\t\tDMERR(\"dm_tm_pre_commit failed\");\n\t\treturn r;\n\t}\n\n\t \n\tr = __copy_sm_root(cmd);\n\tif (r) {\n\t\tDMERR(\"__copy_sm_root failed\");\n\t\treturn r;\n\t}\n\n\t \n\tr = superblock_write_lock_zero(cmd, &sblock);\n\tif (r) {\n\t\tDMERR(\"Failed to write_lock superblock\");\n\t\treturn r;\n\t}\n\n\t \n\tsb = dm_block_data(sblock);\n\t__prepare_superblock(cmd, sb);\n\n\t \n\tr = dm_tm_commit(cmd->tm, sblock);\n\tif (r) {\n\t\tDMERR(\"Failed to commit superblock\");\n\t\treturn r;\n\t}\n\n\t \n\tif (bitmap_full(cmd->region_map, cmd->nr_regions))\n\t\tcmd->hydration_done = true;\n\n\treturn 0;\n}\n\nstatic int __flush_dmap(struct dm_clone_metadata *cmd, struct dirty_map *dmap)\n{\n\tint r;\n\tunsigned long word;\n\n\tword = 0;\n\tdo {\n\t\tword = find_next_bit(dmap->dirty_words, cmd->nr_words, word);\n\n\t\tif (word == cmd->nr_words)\n\t\t\tbreak;\n\n\t\tr = __update_metadata_word(cmd, dmap->dirty_regions, word);\n\n\t\tif (r)\n\t\t\treturn r;\n\n\t\t__clear_bit(word, dmap->dirty_words);\n\t\tword++;\n\t} while (word < cmd->nr_words);\n\n\tr = __metadata_commit(cmd);\n\n\tif (r)\n\t\treturn r;\n\n\t \n\tspin_lock_irq(&cmd->bitmap_lock);\n\tdmap->changed = 0;\n\tspin_unlock_irq(&cmd->bitmap_lock);\n\n\treturn 0;\n}\n\nint dm_clone_metadata_pre_commit(struct dm_clone_metadata *cmd)\n{\n\tint r = 0;\n\tstruct dirty_map *dmap, *next_dmap;\n\n\tdown_write(&cmd->lock);\n\n\tif (cmd->fail_io || dm_bm_is_read_only(cmd->bm)) {\n\t\tr = -EPERM;\n\t\tgoto out;\n\t}\n\n\t \n\tdmap = cmd->current_dmap;\n\n\t \n\tnext_dmap = (dmap == &cmd->dmap[0]) ? &cmd->dmap[1] : &cmd->dmap[0];\n\n\t \n\tif (WARN_ON(next_dmap->changed || cmd->committing_dmap)) {\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tspin_lock_irq(&cmd->bitmap_lock);\n\tcmd->current_dmap = next_dmap;\n\tspin_unlock_irq(&cmd->bitmap_lock);\n\n\t \n\tcmd->committing_dmap = dmap;\nout:\n\tup_write(&cmd->lock);\n\n\treturn r;\n}\n\nint dm_clone_metadata_commit(struct dm_clone_metadata *cmd)\n{\n\tint r = -EPERM;\n\n\tdown_write(&cmd->lock);\n\n\tif (cmd->fail_io || dm_bm_is_read_only(cmd->bm))\n\t\tgoto out;\n\n\tif (WARN_ON(!cmd->committing_dmap)) {\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tr = __flush_dmap(cmd, cmd->committing_dmap);\n\tif (!r) {\n\t\t \n\t\tcmd->committing_dmap = NULL;\n\t}\nout:\n\tup_write(&cmd->lock);\n\n\treturn r;\n}\n\nint dm_clone_set_region_hydrated(struct dm_clone_metadata *cmd, unsigned long region_nr)\n{\n\tint r = 0;\n\tstruct dirty_map *dmap;\n\tunsigned long word, flags;\n\n\tif (unlikely(region_nr >= cmd->nr_regions)) {\n\t\tDMERR(\"Region %lu out of range (total number of regions %lu)\",\n\t\t      region_nr, cmd->nr_regions);\n\t\treturn -ERANGE;\n\t}\n\n\tword = region_nr / BITS_PER_LONG;\n\n\tspin_lock_irqsave(&cmd->bitmap_lock, flags);\n\n\tif (cmd->read_only) {\n\t\tr = -EPERM;\n\t\tgoto out;\n\t}\n\n\tdmap = cmd->current_dmap;\n\n\t__set_bit(word, dmap->dirty_words);\n\t__set_bit(region_nr, dmap->dirty_regions);\n\t__set_bit(region_nr, cmd->region_map);\n\tdmap->changed = 1;\n\nout:\n\tspin_unlock_irqrestore(&cmd->bitmap_lock, flags);\n\n\treturn r;\n}\n\nint dm_clone_cond_set_range(struct dm_clone_metadata *cmd, unsigned long start,\n\t\t\t    unsigned long nr_regions)\n{\n\tint r = 0;\n\tstruct dirty_map *dmap;\n\tunsigned long word, region_nr;\n\n\tif (unlikely(start >= cmd->nr_regions || (start + nr_regions) < start ||\n\t\t     (start + nr_regions) > cmd->nr_regions)) {\n\t\tDMERR(\"Invalid region range: start %lu, nr_regions %lu (total number of regions %lu)\",\n\t\t      start, nr_regions, cmd->nr_regions);\n\t\treturn -ERANGE;\n\t}\n\n\tspin_lock_irq(&cmd->bitmap_lock);\n\n\tif (cmd->read_only) {\n\t\tr = -EPERM;\n\t\tgoto out;\n\t}\n\n\tdmap = cmd->current_dmap;\n\tfor (region_nr = start; region_nr < (start + nr_regions); region_nr++) {\n\t\tif (!test_bit(region_nr, cmd->region_map)) {\n\t\t\tword = region_nr / BITS_PER_LONG;\n\t\t\t__set_bit(word, dmap->dirty_words);\n\t\t\t__set_bit(region_nr, dmap->dirty_regions);\n\t\t\t__set_bit(region_nr, cmd->region_map);\n\t\t\tdmap->changed = 1;\n\t\t}\n\t}\nout:\n\tspin_unlock_irq(&cmd->bitmap_lock);\n\n\treturn r;\n}\n\n \nint dm_clone_reload_in_core_bitset(struct dm_clone_metadata *cmd)\n{\n\tint r = -EINVAL;\n\n\tdown_write(&cmd->lock);\n\n\tif (cmd->fail_io)\n\t\tgoto out;\n\n\tr = __load_bitset_in_core(cmd);\nout:\n\tup_write(&cmd->lock);\n\n\treturn r;\n}\n\nbool dm_clone_changed_this_transaction(struct dm_clone_metadata *cmd)\n{\n\tbool r;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cmd->bitmap_lock, flags);\n\tr = cmd->dmap[0].changed || cmd->dmap[1].changed;\n\tspin_unlock_irqrestore(&cmd->bitmap_lock, flags);\n\n\treturn r;\n}\n\nint dm_clone_metadata_abort(struct dm_clone_metadata *cmd)\n{\n\tint r = -EPERM;\n\n\tdown_write(&cmd->lock);\n\n\tif (cmd->fail_io || dm_bm_is_read_only(cmd->bm))\n\t\tgoto out;\n\n\t__destroy_persistent_data_structures(cmd);\n\n\tr = __create_persistent_data_structures(cmd, false);\n\tif (r) {\n\t\t \n\t\tcmd->fail_io = true;\n\t}\nout:\n\tup_write(&cmd->lock);\n\n\treturn r;\n}\n\nvoid dm_clone_metadata_set_read_only(struct dm_clone_metadata *cmd)\n{\n\tdown_write(&cmd->lock);\n\n\tspin_lock_irq(&cmd->bitmap_lock);\n\tcmd->read_only = 1;\n\tspin_unlock_irq(&cmd->bitmap_lock);\n\n\tif (!cmd->fail_io)\n\t\tdm_bm_set_read_only(cmd->bm);\n\n\tup_write(&cmd->lock);\n}\n\nvoid dm_clone_metadata_set_read_write(struct dm_clone_metadata *cmd)\n{\n\tdown_write(&cmd->lock);\n\n\tspin_lock_irq(&cmd->bitmap_lock);\n\tcmd->read_only = 0;\n\tspin_unlock_irq(&cmd->bitmap_lock);\n\n\tif (!cmd->fail_io)\n\t\tdm_bm_set_read_write(cmd->bm);\n\n\tup_write(&cmd->lock);\n}\n\nint dm_clone_get_free_metadata_block_count(struct dm_clone_metadata *cmd,\n\t\t\t\t\t   dm_block_t *result)\n{\n\tint r = -EINVAL;\n\n\tdown_read(&cmd->lock);\n\n\tif (!cmd->fail_io)\n\t\tr = dm_sm_get_nr_free(cmd->sm, result);\n\n\tup_read(&cmd->lock);\n\n\treturn r;\n}\n\nint dm_clone_get_metadata_dev_size(struct dm_clone_metadata *cmd,\n\t\t\t\t   dm_block_t *result)\n{\n\tint r = -EINVAL;\n\n\tdown_read(&cmd->lock);\n\n\tif (!cmd->fail_io)\n\t\tr = dm_sm_get_nr_blocks(cmd->sm, result);\n\n\tup_read(&cmd->lock);\n\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}