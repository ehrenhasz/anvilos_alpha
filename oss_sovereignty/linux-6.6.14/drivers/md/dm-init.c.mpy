{
  "module_name": "dm-init.c",
  "hash_id": "25d565d18aaa1ee388b0b55ab230502a60f79f9dfe3789205f5418b638f5a573",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-init.c",
  "human_readable_source": "\n\n \n\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/device-mapper.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/moduleparam.h>\n\n#define DM_MSG_PREFIX \"init\"\n#define DM_MAX_DEVICES 256\n#define DM_MAX_TARGETS 256\n#define DM_MAX_STR_SIZE 4096\n#define DM_MAX_WAITFOR 256\n\nstatic char *create;\n\nstatic char *waitfor[DM_MAX_WAITFOR];\n\n \n\nstruct dm_device {\n\tstruct dm_ioctl dmi;\n\tstruct dm_target_spec *table[DM_MAX_TARGETS];\n\tchar *target_args_array[DM_MAX_TARGETS];\n\tstruct list_head list;\n};\n\nstatic const char * const dm_allowed_targets[] __initconst = {\n\t\"crypt\",\n\t\"delay\",\n\t\"linear\",\n\t\"snapshot-origin\",\n\t\"striped\",\n\t\"verity\",\n};\n\nstatic int __init dm_verify_target_type(const char *target)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dm_allowed_targets); i++) {\n\t\tif (!strcmp(dm_allowed_targets[i], target))\n\t\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void __init dm_setup_cleanup(struct list_head *devices)\n{\n\tstruct dm_device *dev, *tmp;\n\tunsigned int i;\n\n\tlist_for_each_entry_safe(dev, tmp, devices, list) {\n\t\tlist_del(&dev->list);\n\t\tfor (i = 0; i < dev->dmi.target_count; i++) {\n\t\t\tkfree(dev->table[i]);\n\t\t\tkfree(dev->target_args_array[i]);\n\t\t}\n\t\tkfree(dev);\n\t}\n}\n\n \nstatic char __init *str_field_delimit(char **str, char separator)\n{\n\tchar *s;\n\n\t \n\t*str = skip_spaces(*str);\n\ts = strchr(*str, separator);\n\t \n\tif (s)\n\t\t*s = '\\0';\n\t*str = strim(*str);\n\treturn s ? ++s : NULL;\n}\n\n \nstatic char __init *dm_parse_table_entry(struct dm_device *dev, char *str)\n{\n\tconst unsigned int n = dev->dmi.target_count - 1;\n\tstruct dm_target_spec *sp;\n\tunsigned int i;\n\t \n\tchar *field[4];\n\tchar *next;\n\n\tfield[0] = str;\n\t \n\tfor (i = 0; i < ARRAY_SIZE(field) - 1; i++) {\n\t\tfield[i + 1] = str_field_delimit(&field[i], ' ');\n\t\tif (!field[i + 1])\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t \n\tnext = str_field_delimit(&field[i], ',');\n\n\tsp = kzalloc(sizeof(*sp), GFP_KERNEL);\n\tif (!sp)\n\t\treturn ERR_PTR(-ENOMEM);\n\tdev->table[n] = sp;\n\n\t \n\tif (kstrtoull(field[0], 0, &sp->sector_start))\n\t\treturn ERR_PTR(-EINVAL);\n\t \n\tif (kstrtoull(field[1], 0, &sp->length))\n\t\treturn ERR_PTR(-EINVAL);\n\t \n\tstrscpy(sp->target_type, field[2], sizeof(sp->target_type));\n\tif (dm_verify_target_type(sp->target_type)) {\n\t\tDMERR(\"invalid type \\\"%s\\\"\", sp->target_type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t \n\tdev->target_args_array[n] = kstrndup(field[3], DM_MAX_STR_SIZE,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!dev->target_args_array[n])\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn next;\n}\n\n \nstatic int __init dm_parse_table(struct dm_device *dev, char *str)\n{\n\tchar *table_entry = str;\n\n\twhile (table_entry) {\n\t\tDMDEBUG(\"parsing table \\\"%s\\\"\", str);\n\t\tif (++dev->dmi.target_count > DM_MAX_TARGETS) {\n\t\t\tDMERR(\"too many targets %u > %d\",\n\t\t\t      dev->dmi.target_count, DM_MAX_TARGETS);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttable_entry = dm_parse_table_entry(dev, table_entry);\n\t\tif (IS_ERR(table_entry)) {\n\t\t\tDMERR(\"couldn't parse table\");\n\t\t\treturn PTR_ERR(table_entry);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic char __init *dm_parse_device_entry(struct dm_device *dev, char *str)\n{\n\t \n\tchar *field[5];\n\tunsigned int i;\n\tchar *next;\n\n\tfield[0] = str;\n\t \n\tfor (i = 0; i < ARRAY_SIZE(field) - 1; i++) {\n\t\tfield[i+1] = str_field_delimit(&field[i], ',');\n\t\tif (!field[i+1])\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t \n\tnext = str_field_delimit(&field[i], ';');\n\n\t \n\tstrscpy(dev->dmi.name, field[0], sizeof(dev->dmi.name));\n\t \n\tstrscpy(dev->dmi.uuid, field[1], sizeof(dev->dmi.uuid));\n\t \n\tif (strlen(field[2])) {\n\t\tif (kstrtoull(field[2], 0, &dev->dmi.dev))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tdev->dmi.flags |= DM_PERSISTENT_DEV_FLAG;\n\t}\n\t \n\tif (!strcmp(field[3], \"ro\"))\n\t\tdev->dmi.flags |= DM_READONLY_FLAG;\n\telse if (strcmp(field[3], \"rw\"))\n\t\treturn ERR_PTR(-EINVAL);\n\t \n\tif (dm_parse_table(dev, field[4]))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn next;\n}\n\n \nstatic int __init dm_parse_devices(struct list_head *devices, char *str)\n{\n\tunsigned long ndev = 0;\n\tstruct dm_device *dev;\n\tchar *device = str;\n\n\tDMDEBUG(\"parsing \\\"%s\\\"\", str);\n\twhile (device) {\n\t\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\t\tlist_add_tail(&dev->list, devices);\n\n\t\tif (++ndev > DM_MAX_DEVICES) {\n\t\t\tDMERR(\"too many devices %lu > %d\",\n\t\t\t      ndev, DM_MAX_DEVICES);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdevice = dm_parse_device_entry(dev, device);\n\t\tif (IS_ERR(device)) {\n\t\t\tDMERR(\"couldn't parse device\");\n\t\t\treturn PTR_ERR(device);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __init dm_init_init(void)\n{\n\tstruct dm_device *dev;\n\tLIST_HEAD(devices);\n\tchar *str;\n\tint i, r;\n\n\tif (!create)\n\t\treturn 0;\n\n\tif (strlen(create) >= DM_MAX_STR_SIZE) {\n\t\tDMERR(\"Argument is too big. Limit is %d\", DM_MAX_STR_SIZE);\n\t\treturn -EINVAL;\n\t}\n\tstr = kstrndup(create, DM_MAX_STR_SIZE, GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\tr = dm_parse_devices(&devices, str);\n\tif (r)\n\t\tgoto out;\n\n\tDMINFO(\"waiting for all devices to be available before creating mapped devices\");\n\twait_for_device_probe();\n\n\tfor (i = 0; i < ARRAY_SIZE(waitfor); i++) {\n\t\tif (waitfor[i]) {\n\t\t\tdev_t dev;\n\n\t\t\tDMINFO(\"waiting for device %s ...\", waitfor[i]);\n\t\t\twhile (early_lookup_bdev(waitfor[i], &dev))\n\t\t\t\tfsleep(5000);\n\t\t}\n\t}\n\n\tif (waitfor[0])\n\t\tDMINFO(\"all devices available\");\n\n\tlist_for_each_entry(dev, &devices, list) {\n\t\tif (dm_early_create(&dev->dmi, dev->table,\n\t\t\t\t    dev->target_args_array))\n\t\t\tbreak;\n\t}\nout:\n\tkfree(str);\n\tdm_setup_cleanup(&devices);\n\treturn r;\n}\n\nlate_initcall(dm_init_init);\n\nmodule_param(create, charp, 0);\nMODULE_PARM_DESC(create, \"Create a mapped device in early boot\");\n\nmodule_param_array(waitfor, charp, NULL, 0);\nMODULE_PARM_DESC(waitfor, \"Devices to wait for before setting up tables\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}