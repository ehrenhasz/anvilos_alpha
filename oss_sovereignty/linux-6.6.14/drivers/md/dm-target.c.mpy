{
  "module_name": "dm-target.c",
  "hash_id": "688f8e4734206df08e1b7c199c0390bb5b9bfd0bebe5de156bfc32b8e912db46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-target.c",
  "human_readable_source": "\n \n\n#include \"dm-core.h\"\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/bio.h>\n#include <linux/dax.h>\n\n#define DM_MSG_PREFIX \"target\"\n\nstatic LIST_HEAD(_targets);\nstatic DECLARE_RWSEM(_lock);\n\nstatic inline struct target_type *__find_target_type(const char *name)\n{\n\tstruct target_type *tt;\n\n\tlist_for_each_entry(tt, &_targets, list)\n\t\tif (!strcmp(name, tt->name))\n\t\t\treturn tt;\n\n\treturn NULL;\n}\n\nstatic struct target_type *get_target_type(const char *name)\n{\n\tstruct target_type *tt;\n\n\tdown_read(&_lock);\n\n\ttt = __find_target_type(name);\n\tif (tt && !try_module_get(tt->module))\n\t\ttt = NULL;\n\n\tup_read(&_lock);\n\treturn tt;\n}\n\nstatic void load_module(const char *name)\n{\n\trequest_module(\"dm-%s\", name);\n}\n\nstruct target_type *dm_get_target_type(const char *name)\n{\n\tstruct target_type *tt = get_target_type(name);\n\n\tif (!tt) {\n\t\tload_module(name);\n\t\ttt = get_target_type(name);\n\t}\n\n\treturn tt;\n}\n\nvoid dm_put_target_type(struct target_type *tt)\n{\n\tdown_read(&_lock);\n\tmodule_put(tt->module);\n\tup_read(&_lock);\n}\n\nint dm_target_iterate(void (*iter_func)(struct target_type *tt,\n\t\t\t\t\tvoid *param), void *param)\n{\n\tstruct target_type *tt;\n\n\tdown_read(&_lock);\n\tlist_for_each_entry(tt, &_targets, list)\n\t\titer_func(tt, param);\n\tup_read(&_lock);\n\n\treturn 0;\n}\n\nint dm_register_target(struct target_type *tt)\n{\n\tint rv = 0;\n\n\tdown_write(&_lock);\n\tif (__find_target_type(tt->name)) {\n\t\tDMERR(\"%s: '%s' target already registered\",\n\t\t      __func__, tt->name);\n\t\trv = -EEXIST;\n\t} else {\n\t\tlist_add(&tt->list, &_targets);\n\t}\n\tup_write(&_lock);\n\n\treturn rv;\n}\nEXPORT_SYMBOL(dm_register_target);\n\nvoid dm_unregister_target(struct target_type *tt)\n{\n\tdown_write(&_lock);\n\tif (!__find_target_type(tt->name)) {\n\t\tDMCRIT(\"Unregistering unrecognised target: %s\", tt->name);\n\t\tBUG();\n\t}\n\n\tlist_del(&tt->list);\n\n\tup_write(&_lock);\n}\nEXPORT_SYMBOL(dm_unregister_target);\n\n \nstatic int io_err_ctr(struct dm_target *tt, unsigned int argc, char **args)\n{\n\t \n\ttt->num_discard_bios = 1;\n\ttt->discards_supported = true;\n\n\treturn 0;\n}\n\nstatic void io_err_dtr(struct dm_target *tt)\n{\n\t \n}\n\nstatic int io_err_map(struct dm_target *tt, struct bio *bio)\n{\n\treturn DM_MAPIO_KILL;\n}\n\nstatic int io_err_clone_and_map_rq(struct dm_target *ti, struct request *rq,\n\t\t\t\t   union map_info *map_context,\n\t\t\t\t   struct request **clone)\n{\n\treturn DM_MAPIO_KILL;\n}\n\nstatic void io_err_release_clone_rq(struct request *clone,\n\t\t\t\t    union map_info *map_context)\n{\n}\n\nstatic void io_err_io_hints(struct dm_target *ti, struct queue_limits *limits)\n{\n\tlimits->max_discard_sectors = UINT_MAX;\n\tlimits->max_hw_discard_sectors = UINT_MAX;\n\tlimits->discard_granularity = 512;\n}\n\nstatic long io_err_dax_direct_access(struct dm_target *ti, pgoff_t pgoff,\n\t\tlong nr_pages, enum dax_access_mode mode, void **kaddr,\n\t\tpfn_t *pfn)\n{\n\treturn -EIO;\n}\n\nstatic struct target_type error_target = {\n\t.name = \"error\",\n\t.version = {1, 6, 0},\n\t.features = DM_TARGET_WILDCARD,\n\t.ctr  = io_err_ctr,\n\t.dtr  = io_err_dtr,\n\t.map  = io_err_map,\n\t.clone_and_map_rq = io_err_clone_and_map_rq,\n\t.release_clone_rq = io_err_release_clone_rq,\n\t.io_hints = io_err_io_hints,\n\t.direct_access = io_err_dax_direct_access,\n};\n\nint __init dm_target_init(void)\n{\n\treturn dm_register_target(&error_target);\n}\n\nvoid dm_target_exit(void)\n{\n\tdm_unregister_target(&error_target);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}