{
  "module_name": "dm-linear.c",
  "hash_id": "42df67aa37f8ec42584887154906e98753e7e59459d113ae76a8891974fa849a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-linear.c",
  "human_readable_source": "\n \n\n#include \"dm.h\"\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/dax.h>\n#include <linux/slab.h>\n#include <linux/device-mapper.h>\n\n#define DM_MSG_PREFIX \"linear\"\n\n \nstruct linear_c {\n\tstruct dm_dev *dev;\n\tsector_t start;\n};\n\n \nstatic int linear_ctr(struct dm_target *ti, unsigned int argc, char **argv)\n{\n\tstruct linear_c *lc;\n\tunsigned long long tmp;\n\tchar dummy;\n\tint ret;\n\n\tif (argc != 2) {\n\t\tti->error = \"Invalid argument count\";\n\t\treturn -EINVAL;\n\t}\n\n\tlc = kmalloc(sizeof(*lc), GFP_KERNEL);\n\tif (lc == NULL) {\n\t\tti->error = \"Cannot allocate linear context\";\n\t\treturn -ENOMEM;\n\t}\n\n\tret = -EINVAL;\n\tif (sscanf(argv[1], \"%llu%c\", &tmp, &dummy) != 1 || tmp != (sector_t)tmp) {\n\t\tti->error = \"Invalid device sector\";\n\t\tgoto bad;\n\t}\n\tlc->start = tmp;\n\n\tret = dm_get_device(ti, argv[0], dm_table_get_mode(ti->table), &lc->dev);\n\tif (ret) {\n\t\tti->error = \"Device lookup failed\";\n\t\tgoto bad;\n\t}\n\n\tti->num_flush_bios = 1;\n\tti->num_discard_bios = 1;\n\tti->num_secure_erase_bios = 1;\n\tti->num_write_zeroes_bios = 1;\n\tti->private = lc;\n\treturn 0;\n\nbad:\n\tkfree(lc);\n\treturn ret;\n}\n\nstatic void linear_dtr(struct dm_target *ti)\n{\n\tstruct linear_c *lc = ti->private;\n\n\tdm_put_device(ti, lc->dev);\n\tkfree(lc);\n}\n\nstatic sector_t linear_map_sector(struct dm_target *ti, sector_t bi_sector)\n{\n\tstruct linear_c *lc = ti->private;\n\n\treturn lc->start + dm_target_offset(ti, bi_sector);\n}\n\nstatic int linear_map(struct dm_target *ti, struct bio *bio)\n{\n\tstruct linear_c *lc = ti->private;\n\n\tbio_set_dev(bio, lc->dev->bdev);\n\tbio->bi_iter.bi_sector = linear_map_sector(ti, bio->bi_iter.bi_sector);\n\n\treturn DM_MAPIO_REMAPPED;\n}\n\nstatic void linear_status(struct dm_target *ti, status_type_t type,\n\t\t\t  unsigned int status_flags, char *result, unsigned int maxlen)\n{\n\tstruct linear_c *lc = ti->private;\n\tsize_t sz = 0;\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\tresult[0] = '\\0';\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\"%s %llu\", lc->dev->name, (unsigned long long)lc->start);\n\t\tbreak;\n\n\tcase STATUSTYPE_IMA:\n\t\tDMEMIT_TARGET_NAME_VERSION(ti->type);\n\t\tDMEMIT(\",device_name=%s,start=%llu;\", lc->dev->name,\n\t\t       (unsigned long long)lc->start);\n\t\tbreak;\n\t}\n}\n\nstatic int linear_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)\n{\n\tstruct linear_c *lc = ti->private;\n\tstruct dm_dev *dev = lc->dev;\n\n\t*bdev = dev->bdev;\n\n\t \n\tif (lc->start || ti->len != bdev_nr_sectors(dev->bdev))\n\t\treturn 1;\n\treturn 0;\n}\n\n#ifdef CONFIG_BLK_DEV_ZONED\nstatic int linear_report_zones(struct dm_target *ti,\n\t\tstruct dm_report_zones_args *args, unsigned int nr_zones)\n{\n\tstruct linear_c *lc = ti->private;\n\n\treturn dm_report_zones(lc->dev->bdev, lc->start,\n\t\t\t       linear_map_sector(ti, args->next_sector),\n\t\t\t       args, nr_zones);\n}\n#else\n#define linear_report_zones NULL\n#endif\n\nstatic int linear_iterate_devices(struct dm_target *ti,\n\t\t\t\t  iterate_devices_callout_fn fn, void *data)\n{\n\tstruct linear_c *lc = ti->private;\n\n\treturn fn(ti, lc->dev, lc->start, ti->len, data);\n}\n\n#if IS_ENABLED(CONFIG_FS_DAX)\nstatic struct dax_device *linear_dax_pgoff(struct dm_target *ti, pgoff_t *pgoff)\n{\n\tstruct linear_c *lc = ti->private;\n\tsector_t sector = linear_map_sector(ti, *pgoff << PAGE_SECTORS_SHIFT);\n\n\t*pgoff = (get_start_sect(lc->dev->bdev) + sector) >> PAGE_SECTORS_SHIFT;\n\treturn lc->dev->dax_dev;\n}\n\nstatic long linear_dax_direct_access(struct dm_target *ti, pgoff_t pgoff,\n\t\tlong nr_pages, enum dax_access_mode mode, void **kaddr,\n\t\tpfn_t *pfn)\n{\n\tstruct dax_device *dax_dev = linear_dax_pgoff(ti, &pgoff);\n\n\treturn dax_direct_access(dax_dev, pgoff, nr_pages, mode, kaddr, pfn);\n}\n\nstatic int linear_dax_zero_page_range(struct dm_target *ti, pgoff_t pgoff,\n\t\t\t\t      size_t nr_pages)\n{\n\tstruct dax_device *dax_dev = linear_dax_pgoff(ti, &pgoff);\n\n\treturn dax_zero_page_range(dax_dev, pgoff, nr_pages);\n}\n\nstatic size_t linear_dax_recovery_write(struct dm_target *ti, pgoff_t pgoff,\n\t\tvoid *addr, size_t bytes, struct iov_iter *i)\n{\n\tstruct dax_device *dax_dev = linear_dax_pgoff(ti, &pgoff);\n\n\treturn dax_recovery_write(dax_dev, pgoff, addr, bytes, i);\n}\n\n#else\n#define linear_dax_direct_access NULL\n#define linear_dax_zero_page_range NULL\n#define linear_dax_recovery_write NULL\n#endif\n\nstatic struct target_type linear_target = {\n\t.name   = \"linear\",\n\t.version = {1, 4, 0},\n\t.features = DM_TARGET_PASSES_INTEGRITY | DM_TARGET_NOWAIT |\n\t\t    DM_TARGET_ZONED_HM | DM_TARGET_PASSES_CRYPTO,\n\t.report_zones = linear_report_zones,\n\t.module = THIS_MODULE,\n\t.ctr    = linear_ctr,\n\t.dtr    = linear_dtr,\n\t.map    = linear_map,\n\t.status = linear_status,\n\t.prepare_ioctl = linear_prepare_ioctl,\n\t.iterate_devices = linear_iterate_devices,\n\t.direct_access = linear_dax_direct_access,\n\t.dax_zero_page_range = linear_dax_zero_page_range,\n\t.dax_recovery_write = linear_dax_recovery_write,\n};\n\nint __init dm_linear_init(void)\n{\n\tint r = dm_register_target(&linear_target);\n\n\tif (r < 0)\n\t\tDMERR(\"register failed %d\", r);\n\n\treturn r;\n}\n\nvoid dm_linear_exit(void)\n{\n\tdm_unregister_target(&linear_target);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}