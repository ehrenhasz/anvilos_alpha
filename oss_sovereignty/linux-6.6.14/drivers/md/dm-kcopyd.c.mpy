{
  "module_name": "dm-kcopyd.c",
  "hash_id": "cc0607eb1bb4fb387195af3af6f48167bedc60373ebb5d858b6482d732a8720c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-kcopyd.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/mempool.h>\n#include <linux/module.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/device-mapper.h>\n#include <linux/dm-kcopyd.h>\n\n#include \"dm-core.h\"\n\n#define SPLIT_COUNT\t8\n#define MIN_JOBS\t8\n\n#define DEFAULT_SUB_JOB_SIZE_KB 512\n#define MAX_SUB_JOB_SIZE_KB     1024\n\nstatic unsigned int kcopyd_subjob_size_kb = DEFAULT_SUB_JOB_SIZE_KB;\n\nmodule_param(kcopyd_subjob_size_kb, uint, 0644);\nMODULE_PARM_DESC(kcopyd_subjob_size_kb, \"Sub-job size for dm-kcopyd clients\");\n\nstatic unsigned int dm_get_kcopyd_subjob_size(void)\n{\n\tunsigned int sub_job_size_kb;\n\n\tsub_job_size_kb = __dm_get_module_param(&kcopyd_subjob_size_kb,\n\t\t\t\t\t\tDEFAULT_SUB_JOB_SIZE_KB,\n\t\t\t\t\t\tMAX_SUB_JOB_SIZE_KB);\n\n\treturn sub_job_size_kb << 1;\n}\n\n \nstruct dm_kcopyd_client {\n\tstruct page_list *pages;\n\tunsigned int nr_reserved_pages;\n\tunsigned int nr_free_pages;\n\tunsigned int sub_job_size;\n\n\tstruct dm_io_client *io_client;\n\n\twait_queue_head_t destroyq;\n\n\tmempool_t job_pool;\n\n\tstruct workqueue_struct *kcopyd_wq;\n\tstruct work_struct kcopyd_work;\n\n\tstruct dm_kcopyd_throttle *throttle;\n\n\tatomic_t nr_jobs;\n\n \n\tspinlock_t job_lock;\n\tstruct list_head callback_jobs;\n\tstruct list_head complete_jobs;\n\tstruct list_head io_jobs;\n\tstruct list_head pages_jobs;\n};\n\nstatic struct page_list zero_page_list;\n\nstatic DEFINE_SPINLOCK(throttle_spinlock);\n\n \n#define ACCOUNT_INTERVAL_SHIFT\t\tSHIFT_HZ\n\n \n#define SLEEP_USEC\t\t\t100000\n\n \n#define MAX_SLEEPS\t\t\t10\n\nstatic void io_job_start(struct dm_kcopyd_throttle *t)\n{\n\tunsigned int throttle, now, difference;\n\tint slept = 0, skew;\n\n\tif (unlikely(!t))\n\t\treturn;\n\ntry_again:\n\tspin_lock_irq(&throttle_spinlock);\n\n\tthrottle = READ_ONCE(t->throttle);\n\n\tif (likely(throttle >= 100))\n\t\tgoto skip_limit;\n\n\tnow = jiffies;\n\tdifference = now - t->last_jiffies;\n\tt->last_jiffies = now;\n\tif (t->num_io_jobs)\n\t\tt->io_period += difference;\n\tt->total_period += difference;\n\n\t \n\tif (unlikely(t->io_period > t->total_period))\n\t\tt->io_period = t->total_period;\n\n\tif (unlikely(t->total_period >= (1 << ACCOUNT_INTERVAL_SHIFT))) {\n\t\tint shift = fls(t->total_period >> ACCOUNT_INTERVAL_SHIFT);\n\n\t\tt->total_period >>= shift;\n\t\tt->io_period >>= shift;\n\t}\n\n\tskew = t->io_period - throttle * t->total_period / 100;\n\n\tif (unlikely(skew > 0) && slept < MAX_SLEEPS) {\n\t\tslept++;\n\t\tspin_unlock_irq(&throttle_spinlock);\n\t\tfsleep(SLEEP_USEC);\n\t\tgoto try_again;\n\t}\n\nskip_limit:\n\tt->num_io_jobs++;\n\n\tspin_unlock_irq(&throttle_spinlock);\n}\n\nstatic void io_job_finish(struct dm_kcopyd_throttle *t)\n{\n\tunsigned long flags;\n\n\tif (unlikely(!t))\n\t\treturn;\n\n\tspin_lock_irqsave(&throttle_spinlock, flags);\n\n\tt->num_io_jobs--;\n\n\tif (likely(READ_ONCE(t->throttle) >= 100))\n\t\tgoto skip_limit;\n\n\tif (!t->num_io_jobs) {\n\t\tunsigned int now, difference;\n\n\t\tnow = jiffies;\n\t\tdifference = now - t->last_jiffies;\n\t\tt->last_jiffies = now;\n\n\t\tt->io_period += difference;\n\t\tt->total_period += difference;\n\n\t\t \n\t\tif (unlikely(t->io_period > t->total_period))\n\t\t\tt->io_period = t->total_period;\n\t}\n\nskip_limit:\n\tspin_unlock_irqrestore(&throttle_spinlock, flags);\n}\n\n\nstatic void wake(struct dm_kcopyd_client *kc)\n{\n\tqueue_work(kc->kcopyd_wq, &kc->kcopyd_work);\n}\n\n \nstatic struct page_list *alloc_pl(gfp_t gfp)\n{\n\tstruct page_list *pl;\n\n\tpl = kmalloc(sizeof(*pl), gfp);\n\tif (!pl)\n\t\treturn NULL;\n\n\tpl->page = alloc_page(gfp | __GFP_HIGHMEM);\n\tif (!pl->page) {\n\t\tkfree(pl);\n\t\treturn NULL;\n\t}\n\n\treturn pl;\n}\n\nstatic void free_pl(struct page_list *pl)\n{\n\t__free_page(pl->page);\n\tkfree(pl);\n}\n\n \nstatic void kcopyd_put_pages(struct dm_kcopyd_client *kc, struct page_list *pl)\n{\n\tstruct page_list *next;\n\n\tdo {\n\t\tnext = pl->next;\n\n\t\tif (kc->nr_free_pages >= kc->nr_reserved_pages)\n\t\t\tfree_pl(pl);\n\t\telse {\n\t\t\tpl->next = kc->pages;\n\t\t\tkc->pages = pl;\n\t\t\tkc->nr_free_pages++;\n\t\t}\n\n\t\tpl = next;\n\t} while (pl);\n}\n\nstatic int kcopyd_get_pages(struct dm_kcopyd_client *kc,\n\t\t\t    unsigned int nr, struct page_list **pages)\n{\n\tstruct page_list *pl;\n\n\t*pages = NULL;\n\n\tdo {\n\t\tpl = alloc_pl(__GFP_NOWARN | __GFP_NORETRY | __GFP_KSWAPD_RECLAIM);\n\t\tif (unlikely(!pl)) {\n\t\t\t \n\t\t\tpl = kc->pages;\n\t\t\tif (unlikely(!pl))\n\t\t\t\tgoto out_of_memory;\n\t\t\tkc->pages = pl->next;\n\t\t\tkc->nr_free_pages--;\n\t\t}\n\t\tpl->next = *pages;\n\t\t*pages = pl;\n\t} while (--nr);\n\n\treturn 0;\n\nout_of_memory:\n\tif (*pages)\n\t\tkcopyd_put_pages(kc, *pages);\n\treturn -ENOMEM;\n}\n\n \nstatic void drop_pages(struct page_list *pl)\n{\n\tstruct page_list *next;\n\n\twhile (pl) {\n\t\tnext = pl->next;\n\t\tfree_pl(pl);\n\t\tpl = next;\n\t}\n}\n\n \nstatic int client_reserve_pages(struct dm_kcopyd_client *kc, unsigned int nr_pages)\n{\n\tunsigned int i;\n\tstruct page_list *pl = NULL, *next;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tnext = alloc_pl(GFP_KERNEL);\n\t\tif (!next) {\n\t\t\tif (pl)\n\t\t\t\tdrop_pages(pl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnext->next = pl;\n\t\tpl = next;\n\t}\n\n\tkc->nr_reserved_pages += nr_pages;\n\tkcopyd_put_pages(kc, pl);\n\n\treturn 0;\n}\n\nstatic void client_free_pages(struct dm_kcopyd_client *kc)\n{\n\tBUG_ON(kc->nr_free_pages != kc->nr_reserved_pages);\n\tdrop_pages(kc->pages);\n\tkc->pages = NULL;\n\tkc->nr_free_pages = kc->nr_reserved_pages = 0;\n}\n\n \nstruct kcopyd_job {\n\tstruct dm_kcopyd_client *kc;\n\tstruct list_head list;\n\tunsigned int flags;\n\n\t \n\tint read_err;\n\tunsigned long write_err;\n\n\t \n\tenum req_op op;\n\tstruct dm_io_region source;\n\n\t \n\tunsigned int num_dests;\n\tstruct dm_io_region dests[DM_KCOPYD_MAX_REGIONS];\n\n\tstruct page_list *pages;\n\n\t \n\tdm_kcopyd_notify_fn fn;\n\tvoid *context;\n\n\t \n\tstruct mutex lock;\n\tatomic_t sub_jobs;\n\tsector_t progress;\n\tsector_t write_offset;\n\n\tstruct kcopyd_job *master_job;\n};\n\nstatic struct kmem_cache *_job_cache;\n\nint __init dm_kcopyd_init(void)\n{\n\t_job_cache = kmem_cache_create(\"kcopyd_job\",\n\t\t\t\tsizeof(struct kcopyd_job) * (SPLIT_COUNT + 1),\n\t\t\t\t__alignof__(struct kcopyd_job), 0, NULL);\n\tif (!_job_cache)\n\t\treturn -ENOMEM;\n\n\tzero_page_list.next = &zero_page_list;\n\tzero_page_list.page = ZERO_PAGE(0);\n\n\treturn 0;\n}\n\nvoid dm_kcopyd_exit(void)\n{\n\tkmem_cache_destroy(_job_cache);\n\t_job_cache = NULL;\n}\n\n \nstatic struct kcopyd_job *pop_io_job(struct list_head *jobs,\n\t\t\t\t     struct dm_kcopyd_client *kc)\n{\n\tstruct kcopyd_job *job;\n\n\t \n\tlist_for_each_entry(job, jobs, list) {\n\t\tif (job->op == REQ_OP_READ ||\n\t\t    !(job->flags & BIT(DM_KCOPYD_WRITE_SEQ))) {\n\t\t\tlist_del(&job->list);\n\t\t\treturn job;\n\t\t}\n\n\t\tif (job->write_offset == job->master_job->write_offset) {\n\t\t\tjob->master_job->write_offset += job->source.count;\n\t\t\tlist_del(&job->list);\n\t\t\treturn job;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct kcopyd_job *pop(struct list_head *jobs,\n\t\t\t      struct dm_kcopyd_client *kc)\n{\n\tstruct kcopyd_job *job = NULL;\n\n\tspin_lock_irq(&kc->job_lock);\n\n\tif (!list_empty(jobs)) {\n\t\tif (jobs == &kc->io_jobs)\n\t\t\tjob = pop_io_job(jobs, kc);\n\t\telse {\n\t\t\tjob = list_entry(jobs->next, struct kcopyd_job, list);\n\t\t\tlist_del(&job->list);\n\t\t}\n\t}\n\tspin_unlock_irq(&kc->job_lock);\n\n\treturn job;\n}\n\nstatic void push(struct list_head *jobs, struct kcopyd_job *job)\n{\n\tunsigned long flags;\n\tstruct dm_kcopyd_client *kc = job->kc;\n\n\tspin_lock_irqsave(&kc->job_lock, flags);\n\tlist_add_tail(&job->list, jobs);\n\tspin_unlock_irqrestore(&kc->job_lock, flags);\n}\n\n\nstatic void push_head(struct list_head *jobs, struct kcopyd_job *job)\n{\n\tstruct dm_kcopyd_client *kc = job->kc;\n\n\tspin_lock_irq(&kc->job_lock);\n\tlist_add(&job->list, jobs);\n\tspin_unlock_irq(&kc->job_lock);\n}\n\n \nstatic int run_complete_job(struct kcopyd_job *job)\n{\n\tvoid *context = job->context;\n\tint read_err = job->read_err;\n\tunsigned long write_err = job->write_err;\n\tdm_kcopyd_notify_fn fn = job->fn;\n\tstruct dm_kcopyd_client *kc = job->kc;\n\n\tif (job->pages && job->pages != &zero_page_list)\n\t\tkcopyd_put_pages(kc, job->pages);\n\t \n\tif (job->master_job == job) {\n\t\tmutex_destroy(&job->lock);\n\t\tmempool_free(job, &kc->job_pool);\n\t}\n\tfn(read_err, write_err, context);\n\n\tif (atomic_dec_and_test(&kc->nr_jobs))\n\t\twake_up(&kc->destroyq);\n\n\tcond_resched();\n\n\treturn 0;\n}\n\nstatic void complete_io(unsigned long error, void *context)\n{\n\tstruct kcopyd_job *job = context;\n\tstruct dm_kcopyd_client *kc = job->kc;\n\n\tio_job_finish(kc->throttle);\n\n\tif (error) {\n\t\tif (op_is_write(job->op))\n\t\t\tjob->write_err |= error;\n\t\telse\n\t\t\tjob->read_err = 1;\n\n\t\tif (!(job->flags & BIT(DM_KCOPYD_IGNORE_ERROR))) {\n\t\t\tpush(&kc->complete_jobs, job);\n\t\t\twake(kc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (op_is_write(job->op))\n\t\tpush(&kc->complete_jobs, job);\n\n\telse {\n\t\tjob->op = REQ_OP_WRITE;\n\t\tpush(&kc->io_jobs, job);\n\t}\n\n\twake(kc);\n}\n\n \nstatic int run_io_job(struct kcopyd_job *job)\n{\n\tint r;\n\tstruct dm_io_request io_req = {\n\t\t.bi_opf = job->op,\n\t\t.mem.type = DM_IO_PAGE_LIST,\n\t\t.mem.ptr.pl = job->pages,\n\t\t.mem.offset = 0,\n\t\t.notify.fn = complete_io,\n\t\t.notify.context = job,\n\t\t.client = job->kc->io_client,\n\t};\n\n\t \n\tif (job->flags & BIT(DM_KCOPYD_WRITE_SEQ) &&\n\t    job->master_job->write_err) {\n\t\tjob->write_err = job->master_job->write_err;\n\t\treturn -EIO;\n\t}\n\n\tio_job_start(job->kc->throttle);\n\n\tif (job->op == REQ_OP_READ)\n\t\tr = dm_io(&io_req, 1, &job->source, NULL);\n\telse\n\t\tr = dm_io(&io_req, job->num_dests, job->dests, NULL);\n\n\treturn r;\n}\n\nstatic int run_pages_job(struct kcopyd_job *job)\n{\n\tint r;\n\tunsigned int nr_pages = dm_div_up(job->dests[0].count, PAGE_SIZE >> 9);\n\n\tr = kcopyd_get_pages(job->kc, nr_pages, &job->pages);\n\tif (!r) {\n\t\t \n\t\tpush(&job->kc->io_jobs, job);\n\t\treturn 0;\n\t}\n\n\tif (r == -ENOMEM)\n\t\t \n\t\treturn 1;\n\n\treturn r;\n}\n\n \nstatic int process_jobs(struct list_head *jobs, struct dm_kcopyd_client *kc,\n\t\t\tint (*fn)(struct kcopyd_job *))\n{\n\tstruct kcopyd_job *job;\n\tint r, count = 0;\n\n\twhile ((job = pop(jobs, kc))) {\n\n\t\tr = fn(job);\n\n\t\tif (r < 0) {\n\t\t\t \n\t\t\tif (op_is_write(job->op))\n\t\t\t\tjob->write_err = (unsigned long) -1L;\n\t\t\telse\n\t\t\t\tjob->read_err = 1;\n\t\t\tpush(&kc->complete_jobs, job);\n\t\t\twake(kc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (r > 0) {\n\t\t\t \n\t\t\tpush_head(jobs, job);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\n \nstatic void do_work(struct work_struct *work)\n{\n\tstruct dm_kcopyd_client *kc = container_of(work,\n\t\t\t\t\tstruct dm_kcopyd_client, kcopyd_work);\n\tstruct blk_plug plug;\n\n\t \n\tspin_lock_irq(&kc->job_lock);\n\tlist_splice_tail_init(&kc->callback_jobs, &kc->complete_jobs);\n\tspin_unlock_irq(&kc->job_lock);\n\n\tblk_start_plug(&plug);\n\tprocess_jobs(&kc->complete_jobs, kc, run_complete_job);\n\tprocess_jobs(&kc->pages_jobs, kc, run_pages_job);\n\tprocess_jobs(&kc->io_jobs, kc, run_io_job);\n\tblk_finish_plug(&plug);\n}\n\n \nstatic void dispatch_job(struct kcopyd_job *job)\n{\n\tstruct dm_kcopyd_client *kc = job->kc;\n\n\tatomic_inc(&kc->nr_jobs);\n\tif (unlikely(!job->source.count))\n\t\tpush(&kc->callback_jobs, job);\n\telse if (job->pages == &zero_page_list)\n\t\tpush(&kc->io_jobs, job);\n\telse\n\t\tpush(&kc->pages_jobs, job);\n\twake(kc);\n}\n\nstatic void segment_complete(int read_err, unsigned long write_err,\n\t\t\t     void *context)\n{\n\t \n\tsector_t progress = 0;\n\tsector_t count = 0;\n\tstruct kcopyd_job *sub_job = context;\n\tstruct kcopyd_job *job = sub_job->master_job;\n\tstruct dm_kcopyd_client *kc = job->kc;\n\n\tmutex_lock(&job->lock);\n\n\t \n\tif (read_err)\n\t\tjob->read_err = 1;\n\n\tif (write_err)\n\t\tjob->write_err |= write_err;\n\n\t \n\tif ((!job->read_err && !job->write_err) ||\n\t    job->flags & BIT(DM_KCOPYD_IGNORE_ERROR)) {\n\t\t \n\t\tprogress = job->progress;\n\t\tcount = job->source.count - progress;\n\t\tif (count) {\n\t\t\tif (count > kc->sub_job_size)\n\t\t\t\tcount = kc->sub_job_size;\n\n\t\t\tjob->progress += count;\n\t\t}\n\t}\n\tmutex_unlock(&job->lock);\n\n\tif (count) {\n\t\tint i;\n\n\t\t*sub_job = *job;\n\t\tsub_job->write_offset = progress;\n\t\tsub_job->source.sector += progress;\n\t\tsub_job->source.count = count;\n\n\t\tfor (i = 0; i < job->num_dests; i++) {\n\t\t\tsub_job->dests[i].sector += progress;\n\t\t\tsub_job->dests[i].count = count;\n\t\t}\n\n\t\tsub_job->fn = segment_complete;\n\t\tsub_job->context = sub_job;\n\t\tdispatch_job(sub_job);\n\n\t} else if (atomic_dec_and_test(&job->sub_jobs)) {\n\n\t\t \n\t\tpush(&kc->complete_jobs, job);\n\t\twake(kc);\n\t}\n}\n\n \nstatic void split_job(struct kcopyd_job *master_job)\n{\n\tint i;\n\n\tatomic_inc(&master_job->kc->nr_jobs);\n\n\tatomic_set(&master_job->sub_jobs, SPLIT_COUNT);\n\tfor (i = 0; i < SPLIT_COUNT; i++) {\n\t\tmaster_job[i + 1].master_job = master_job;\n\t\tsegment_complete(0, 0u, &master_job[i + 1]);\n\t}\n}\n\nvoid dm_kcopyd_copy(struct dm_kcopyd_client *kc, struct dm_io_region *from,\n\t\t    unsigned int num_dests, struct dm_io_region *dests,\n\t\t    unsigned int flags, dm_kcopyd_notify_fn fn, void *context)\n{\n\tstruct kcopyd_job *job;\n\tint i;\n\n\t \n\tjob = mempool_alloc(&kc->job_pool, GFP_NOIO);\n\tmutex_init(&job->lock);\n\n\t \n\tjob->kc = kc;\n\tjob->flags = flags;\n\tjob->read_err = 0;\n\tjob->write_err = 0;\n\n\tjob->num_dests = num_dests;\n\tmemcpy(&job->dests, dests, sizeof(*dests) * num_dests);\n\n\t \n\tif (!(job->flags & BIT(DM_KCOPYD_WRITE_SEQ))) {\n\t\tfor (i = 0; i < job->num_dests; i++) {\n\t\t\tif (bdev_zoned_model(dests[i].bdev) == BLK_ZONED_HM) {\n\t\t\t\tjob->flags |= BIT(DM_KCOPYD_WRITE_SEQ);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (job->flags & BIT(DM_KCOPYD_WRITE_SEQ) &&\n\t    job->flags & BIT(DM_KCOPYD_IGNORE_ERROR))\n\t\tjob->flags &= ~BIT(DM_KCOPYD_IGNORE_ERROR);\n\n\tif (from) {\n\t\tjob->source = *from;\n\t\tjob->pages = NULL;\n\t\tjob->op = REQ_OP_READ;\n\t} else {\n\t\tmemset(&job->source, 0, sizeof(job->source));\n\t\tjob->source.count = job->dests[0].count;\n\t\tjob->pages = &zero_page_list;\n\n\t\t \n\t\tjob->op = REQ_OP_WRITE_ZEROES;\n\t\tfor (i = 0; i < job->num_dests; i++)\n\t\t\tif (!bdev_write_zeroes_sectors(job->dests[i].bdev)) {\n\t\t\t\tjob->op = REQ_OP_WRITE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\tjob->fn = fn;\n\tjob->context = context;\n\tjob->master_job = job;\n\tjob->write_offset = 0;\n\n\tif (job->source.count <= kc->sub_job_size)\n\t\tdispatch_job(job);\n\telse {\n\t\tjob->progress = 0;\n\t\tsplit_job(job);\n\t}\n}\nEXPORT_SYMBOL(dm_kcopyd_copy);\n\nvoid dm_kcopyd_zero(struct dm_kcopyd_client *kc,\n\t\t    unsigned int num_dests, struct dm_io_region *dests,\n\t\t    unsigned int flags, dm_kcopyd_notify_fn fn, void *context)\n{\n\tdm_kcopyd_copy(kc, NULL, num_dests, dests, flags, fn, context);\n}\nEXPORT_SYMBOL(dm_kcopyd_zero);\n\nvoid *dm_kcopyd_prepare_callback(struct dm_kcopyd_client *kc,\n\t\t\t\t dm_kcopyd_notify_fn fn, void *context)\n{\n\tstruct kcopyd_job *job;\n\n\tjob = mempool_alloc(&kc->job_pool, GFP_NOIO);\n\n\tmemset(job, 0, sizeof(struct kcopyd_job));\n\tjob->kc = kc;\n\tjob->fn = fn;\n\tjob->context = context;\n\tjob->master_job = job;\n\n\tatomic_inc(&kc->nr_jobs);\n\n\treturn job;\n}\nEXPORT_SYMBOL(dm_kcopyd_prepare_callback);\n\nvoid dm_kcopyd_do_callback(void *j, int read_err, unsigned long write_err)\n{\n\tstruct kcopyd_job *job = j;\n\tstruct dm_kcopyd_client *kc = job->kc;\n\n\tjob->read_err = read_err;\n\tjob->write_err = write_err;\n\n\tpush(&kc->callback_jobs, job);\n\twake(kc);\n}\nEXPORT_SYMBOL(dm_kcopyd_do_callback);\n\n \n#if 0\nint kcopyd_cancel(struct kcopyd_job *job, int block)\n{\n\t \n\treturn -1;\n}\n#endif   \n\n \nstruct dm_kcopyd_client *dm_kcopyd_client_create(struct dm_kcopyd_throttle *throttle)\n{\n\tint r;\n\tunsigned int reserve_pages;\n\tstruct dm_kcopyd_client *kc;\n\n\tkc = kzalloc(sizeof(*kc), GFP_KERNEL);\n\tif (!kc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&kc->job_lock);\n\tINIT_LIST_HEAD(&kc->callback_jobs);\n\tINIT_LIST_HEAD(&kc->complete_jobs);\n\tINIT_LIST_HEAD(&kc->io_jobs);\n\tINIT_LIST_HEAD(&kc->pages_jobs);\n\tkc->throttle = throttle;\n\n\tr = mempool_init_slab_pool(&kc->job_pool, MIN_JOBS, _job_cache);\n\tif (r)\n\t\tgoto bad_slab;\n\n\tINIT_WORK(&kc->kcopyd_work, do_work);\n\tkc->kcopyd_wq = alloc_workqueue(\"kcopyd\", WQ_MEM_RECLAIM, 0);\n\tif (!kc->kcopyd_wq) {\n\t\tr = -ENOMEM;\n\t\tgoto bad_workqueue;\n\t}\n\n\tkc->sub_job_size = dm_get_kcopyd_subjob_size();\n\treserve_pages = DIV_ROUND_UP(kc->sub_job_size << SECTOR_SHIFT, PAGE_SIZE);\n\n\tkc->pages = NULL;\n\tkc->nr_reserved_pages = kc->nr_free_pages = 0;\n\tr = client_reserve_pages(kc, reserve_pages);\n\tif (r)\n\t\tgoto bad_client_pages;\n\n\tkc->io_client = dm_io_client_create();\n\tif (IS_ERR(kc->io_client)) {\n\t\tr = PTR_ERR(kc->io_client);\n\t\tgoto bad_io_client;\n\t}\n\n\tinit_waitqueue_head(&kc->destroyq);\n\tatomic_set(&kc->nr_jobs, 0);\n\n\treturn kc;\n\nbad_io_client:\n\tclient_free_pages(kc);\nbad_client_pages:\n\tdestroy_workqueue(kc->kcopyd_wq);\nbad_workqueue:\n\tmempool_exit(&kc->job_pool);\nbad_slab:\n\tkfree(kc);\n\n\treturn ERR_PTR(r);\n}\nEXPORT_SYMBOL(dm_kcopyd_client_create);\n\nvoid dm_kcopyd_client_destroy(struct dm_kcopyd_client *kc)\n{\n\t \n\twait_event(kc->destroyq, !atomic_read(&kc->nr_jobs));\n\n\tBUG_ON(!list_empty(&kc->callback_jobs));\n\tBUG_ON(!list_empty(&kc->complete_jobs));\n\tBUG_ON(!list_empty(&kc->io_jobs));\n\tBUG_ON(!list_empty(&kc->pages_jobs));\n\tdestroy_workqueue(kc->kcopyd_wq);\n\tdm_io_client_destroy(kc->io_client);\n\tclient_free_pages(kc);\n\tmempool_exit(&kc->job_pool);\n\tkfree(kc);\n}\nEXPORT_SYMBOL(dm_kcopyd_client_destroy);\n\nvoid dm_kcopyd_client_flush(struct dm_kcopyd_client *kc)\n{\n\tflush_workqueue(kc->kcopyd_wq);\n}\nEXPORT_SYMBOL(dm_kcopyd_client_flush);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}