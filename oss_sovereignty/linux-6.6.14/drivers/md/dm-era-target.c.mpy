{
  "module_name": "dm-era-target.c",
  "hash_id": "0d1963cca8c89b9b113333baf1dac458f177d30be15e7cd6c6035ce10e45403a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-era-target.c",
  "human_readable_source": "\n#include \"dm.h\"\n#include \"persistent-data/dm-transaction-manager.h\"\n#include \"persistent-data/dm-bitset.h\"\n#include \"persistent-data/dm-space-map.h\"\n\n#include <linux/dm-io.h>\n#include <linux/dm-kcopyd.h>\n#include <linux/init.h>\n#include <linux/mempool.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\n#define DM_MSG_PREFIX \"era\"\n\n#define SUPERBLOCK_LOCATION 0\n#define SUPERBLOCK_MAGIC 2126579579\n#define SUPERBLOCK_CSUM_XOR 146538381\n#define MIN_ERA_VERSION 1\n#define MAX_ERA_VERSION 1\n#define INVALID_WRITESET_ROOT SUPERBLOCK_LOCATION\n#define MIN_BLOCK_SIZE 8\n\n \nstruct writeset_metadata {\n\tuint32_t nr_bits;\n\tdm_block_t root;\n};\n\nstruct writeset {\n\tstruct writeset_metadata md;\n\n\t \n\tunsigned long *bits;\n};\n\n \nstatic void writeset_free(struct writeset *ws)\n{\n\tvfree(ws->bits);\n\tws->bits = NULL;\n}\n\nstatic int setup_on_disk_bitset(struct dm_disk_bitset *info,\n\t\t\t\tunsigned int nr_bits, dm_block_t *root)\n{\n\tint r;\n\n\tr = dm_bitset_empty(info, root);\n\tif (r)\n\t\treturn r;\n\n\treturn dm_bitset_resize(info, *root, 0, nr_bits, false, root);\n}\n\nstatic size_t bitset_size(unsigned int nr_bits)\n{\n\treturn sizeof(unsigned long) * dm_div_up(nr_bits, BITS_PER_LONG);\n}\n\n \nstatic int writeset_alloc(struct writeset *ws, dm_block_t nr_blocks)\n{\n\tws->bits = vzalloc(bitset_size(nr_blocks));\n\tif (!ws->bits) {\n\t\tDMERR(\"%s: couldn't allocate in memory bitset\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int writeset_init(struct dm_disk_bitset *info, struct writeset *ws,\n\t\t\t dm_block_t nr_blocks)\n{\n\tint r;\n\n\tmemset(ws->bits, 0, bitset_size(nr_blocks));\n\n\tws->md.nr_bits = nr_blocks;\n\tr = setup_on_disk_bitset(info, ws->md.nr_bits, &ws->md.root);\n\tif (r) {\n\t\tDMERR(\"%s: setup_on_disk_bitset failed\", __func__);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic bool writeset_marked(struct writeset *ws, dm_block_t block)\n{\n\treturn test_bit(block, ws->bits);\n}\n\nstatic int writeset_marked_on_disk(struct dm_disk_bitset *info,\n\t\t\t\t   struct writeset_metadata *m, dm_block_t block,\n\t\t\t\t   bool *result)\n{\n\tint r;\n\tdm_block_t old = m->root;\n\n\t \n\tr = dm_bitset_test_bit(info, m->root, block, &m->root, result);\n\tif (r) {\n\t\tDMERR(\"%s: dm_bitset_test_bit failed\", __func__);\n\t\treturn r;\n\t}\n\n\tBUG_ON(m->root != old);\n\n\treturn r;\n}\n\n \nstatic int writeset_test_and_set(struct dm_disk_bitset *info,\n\t\t\t\t struct writeset *ws, uint32_t block)\n{\n\tint r;\n\n\tif (!test_bit(block, ws->bits)) {\n\t\tr = dm_bitset_set_bit(info, ws->md.root, block, &ws->md.root);\n\t\tif (r) {\n\t\t\t \n\t\t\treturn r;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \n#define SPACE_MAP_ROOT_SIZE 128\n#define UUID_LEN 16\n\nstruct writeset_disk {\n\t__le32 nr_bits;\n\t__le64 root;\n} __packed;\n\nstruct superblock_disk {\n\t__le32 csum;\n\t__le32 flags;\n\t__le64 blocknr;\n\n\t__u8 uuid[UUID_LEN];\n\t__le64 magic;\n\t__le32 version;\n\n\t__u8 metadata_space_map_root[SPACE_MAP_ROOT_SIZE];\n\n\t__le32 data_block_size;\n\t__le32 metadata_block_size;\n\t__le32 nr_blocks;\n\n\t__le32 current_era;\n\tstruct writeset_disk current_writeset;\n\n\t \n\t__le64 writeset_tree_root;\n\t__le64 era_array_root;\n\n\t__le64 metadata_snap;\n} __packed;\n\n \nstatic void sb_prepare_for_write(struct dm_block_validator *v,\n\t\t\t\t struct dm_block *b,\n\t\t\t\t size_t sb_block_size)\n{\n\tstruct superblock_disk *disk = dm_block_data(b);\n\n\tdisk->blocknr = cpu_to_le64(dm_block_location(b));\n\tdisk->csum = cpu_to_le32(dm_bm_checksum(&disk->flags,\n\t\t\t\t\t\tsb_block_size - sizeof(__le32),\n\t\t\t\t\t\tSUPERBLOCK_CSUM_XOR));\n}\n\nstatic int check_metadata_version(struct superblock_disk *disk)\n{\n\tuint32_t metadata_version = le32_to_cpu(disk->version);\n\n\tif (metadata_version < MIN_ERA_VERSION || metadata_version > MAX_ERA_VERSION) {\n\t\tDMERR(\"Era metadata version %u found, but only versions between %u and %u supported.\",\n\t\t      metadata_version, MIN_ERA_VERSION, MAX_ERA_VERSION);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sb_check(struct dm_block_validator *v,\n\t\t    struct dm_block *b,\n\t\t    size_t sb_block_size)\n{\n\tstruct superblock_disk *disk = dm_block_data(b);\n\t__le32 csum_le;\n\n\tif (dm_block_location(b) != le64_to_cpu(disk->blocknr)) {\n\t\tDMERR(\"%s failed: blocknr %llu: wanted %llu\",\n\t\t      __func__, le64_to_cpu(disk->blocknr),\n\t\t      (unsigned long long)dm_block_location(b));\n\t\treturn -ENOTBLK;\n\t}\n\n\tif (le64_to_cpu(disk->magic) != SUPERBLOCK_MAGIC) {\n\t\tDMERR(\"%s failed: magic %llu: wanted %llu\",\n\t\t      __func__, le64_to_cpu(disk->magic),\n\t\t      (unsigned long long) SUPERBLOCK_MAGIC);\n\t\treturn -EILSEQ;\n\t}\n\n\tcsum_le = cpu_to_le32(dm_bm_checksum(&disk->flags,\n\t\t\t\t\t     sb_block_size - sizeof(__le32),\n\t\t\t\t\t     SUPERBLOCK_CSUM_XOR));\n\tif (csum_le != disk->csum) {\n\t\tDMERR(\"%s failed: csum %u: wanted %u\",\n\t\t      __func__, le32_to_cpu(csum_le), le32_to_cpu(disk->csum));\n\t\treturn -EILSEQ;\n\t}\n\n\treturn check_metadata_version(disk);\n}\n\nstatic struct dm_block_validator sb_validator = {\n\t.name = \"superblock\",\n\t.prepare_for_write = sb_prepare_for_write,\n\t.check = sb_check\n};\n\n \n#define DM_ERA_METADATA_BLOCK_SIZE 4096\n#define ERA_MAX_CONCURRENT_LOCKS 5\n\nstruct era_metadata {\n\tstruct block_device *bdev;\n\tstruct dm_block_manager *bm;\n\tstruct dm_space_map *sm;\n\tstruct dm_transaction_manager *tm;\n\n\tdm_block_t block_size;\n\tuint32_t nr_blocks;\n\n\tuint32_t current_era;\n\n\t \n\tstruct writeset writesets[2];\n\tstruct writeset *current_writeset;\n\n\tdm_block_t writeset_tree_root;\n\tdm_block_t era_array_root;\n\n\tstruct dm_disk_bitset bitset_info;\n\tstruct dm_btree_info writeset_tree_info;\n\tstruct dm_array_info era_array_info;\n\n\tdm_block_t metadata_snap;\n\n\t \n\tbool archived_writesets;\n\n\t \n\t__u8 metadata_space_map_root[SPACE_MAP_ROOT_SIZE];\n};\n\nstatic int superblock_read_lock(struct era_metadata *md,\n\t\t\t\tstruct dm_block **sblock)\n{\n\treturn dm_bm_read_lock(md->bm, SUPERBLOCK_LOCATION,\n\t\t\t       &sb_validator, sblock);\n}\n\nstatic int superblock_lock_zero(struct era_metadata *md,\n\t\t\t\tstruct dm_block **sblock)\n{\n\treturn dm_bm_write_lock_zero(md->bm, SUPERBLOCK_LOCATION,\n\t\t\t\t     &sb_validator, sblock);\n}\n\nstatic int superblock_lock(struct era_metadata *md,\n\t\t\t   struct dm_block **sblock)\n{\n\treturn dm_bm_write_lock(md->bm, SUPERBLOCK_LOCATION,\n\t\t\t\t&sb_validator, sblock);\n}\n\n \nstatic int superblock_all_zeroes(struct dm_block_manager *bm, bool *result)\n{\n\tint r;\n\tunsigned int i;\n\tstruct dm_block *b;\n\t__le64 *data_le, zero = cpu_to_le64(0);\n\tunsigned int sb_block_size = dm_bm_block_size(bm) / sizeof(__le64);\n\n\t \n\tr = dm_bm_read_lock(bm, SUPERBLOCK_LOCATION, NULL, &b);\n\tif (r)\n\t\treturn r;\n\n\tdata_le = dm_block_data(b);\n\t*result = true;\n\tfor (i = 0; i < sb_block_size; i++) {\n\t\tif (data_le[i] != zero) {\n\t\t\t*result = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdm_bm_unlock(b);\n\n\treturn 0;\n}\n\n \n\nstatic void ws_pack(const struct writeset_metadata *core, struct writeset_disk *disk)\n{\n\tdisk->nr_bits = cpu_to_le32(core->nr_bits);\n\tdisk->root = cpu_to_le64(core->root);\n}\n\nstatic void ws_unpack(const struct writeset_disk *disk, struct writeset_metadata *core)\n{\n\tcore->nr_bits = le32_to_cpu(disk->nr_bits);\n\tcore->root = le64_to_cpu(disk->root);\n}\n\nstatic void ws_inc(void *context, const void *value, unsigned int count)\n{\n\tstruct era_metadata *md = context;\n\tstruct writeset_disk ws_d;\n\tdm_block_t b;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tmemcpy(&ws_d, value + (i * sizeof(ws_d)), sizeof(ws_d));\n\t\tb = le64_to_cpu(ws_d.root);\n\t\tdm_tm_inc(md->tm, b);\n\t}\n}\n\nstatic void ws_dec(void *context, const void *value, unsigned int count)\n{\n\tstruct era_metadata *md = context;\n\tstruct writeset_disk ws_d;\n\tdm_block_t b;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tmemcpy(&ws_d, value + (i * sizeof(ws_d)), sizeof(ws_d));\n\t\tb = le64_to_cpu(ws_d.root);\n\t\tdm_bitset_del(&md->bitset_info, b);\n\t}\n}\n\nstatic int ws_eq(void *context, const void *value1, const void *value2)\n{\n\treturn !memcmp(value1, value2, sizeof(struct writeset_disk));\n}\n\n \n\nstatic void setup_writeset_tree_info(struct era_metadata *md)\n{\n\tstruct dm_btree_value_type *vt = &md->writeset_tree_info.value_type;\n\n\tmd->writeset_tree_info.tm = md->tm;\n\tmd->writeset_tree_info.levels = 1;\n\tvt->context = md;\n\tvt->size = sizeof(struct writeset_disk);\n\tvt->inc = ws_inc;\n\tvt->dec = ws_dec;\n\tvt->equal = ws_eq;\n}\n\nstatic void setup_era_array_info(struct era_metadata *md)\n{\n\tstruct dm_btree_value_type vt;\n\n\tvt.context = NULL;\n\tvt.size = sizeof(__le32);\n\tvt.inc = NULL;\n\tvt.dec = NULL;\n\tvt.equal = NULL;\n\n\tdm_array_info_init(&md->era_array_info, md->tm, &vt);\n}\n\nstatic void setup_infos(struct era_metadata *md)\n{\n\tdm_disk_bitset_init(md->tm, &md->bitset_info);\n\tsetup_writeset_tree_info(md);\n\tsetup_era_array_info(md);\n}\n\n \n\nstatic int create_fresh_metadata(struct era_metadata *md)\n{\n\tint r;\n\n\tr = dm_tm_create_with_sm(md->bm, SUPERBLOCK_LOCATION,\n\t\t\t\t &md->tm, &md->sm);\n\tif (r < 0) {\n\t\tDMERR(\"dm_tm_create_with_sm failed\");\n\t\treturn r;\n\t}\n\n\tsetup_infos(md);\n\n\tr = dm_btree_empty(&md->writeset_tree_info, &md->writeset_tree_root);\n\tif (r) {\n\t\tDMERR(\"couldn't create new writeset tree\");\n\t\tgoto bad;\n\t}\n\n\tr = dm_array_empty(&md->era_array_info, &md->era_array_root);\n\tif (r) {\n\t\tDMERR(\"couldn't create era array\");\n\t\tgoto bad;\n\t}\n\n\treturn 0;\n\nbad:\n\tdm_sm_destroy(md->sm);\n\tdm_tm_destroy(md->tm);\n\n\treturn r;\n}\n\nstatic int save_sm_root(struct era_metadata *md)\n{\n\tint r;\n\tsize_t metadata_len;\n\n\tr = dm_sm_root_size(md->sm, &metadata_len);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn dm_sm_copy_root(md->sm, &md->metadata_space_map_root,\n\t\t\t       metadata_len);\n}\n\nstatic void copy_sm_root(struct era_metadata *md, struct superblock_disk *disk)\n{\n\tmemcpy(&disk->metadata_space_map_root,\n\t       &md->metadata_space_map_root,\n\t       sizeof(md->metadata_space_map_root));\n}\n\n \nstatic void prepare_superblock(struct era_metadata *md, struct superblock_disk *disk)\n{\n\tdisk->magic = cpu_to_le64(SUPERBLOCK_MAGIC);\n\tdisk->flags = cpu_to_le32(0ul);\n\n\t \n\tmemset(disk->uuid, 0, sizeof(disk->uuid));\n\tdisk->version = cpu_to_le32(MAX_ERA_VERSION);\n\n\tcopy_sm_root(md, disk);\n\n\tdisk->data_block_size = cpu_to_le32(md->block_size);\n\tdisk->metadata_block_size = cpu_to_le32(DM_ERA_METADATA_BLOCK_SIZE >> SECTOR_SHIFT);\n\tdisk->nr_blocks = cpu_to_le32(md->nr_blocks);\n\tdisk->current_era = cpu_to_le32(md->current_era);\n\n\tws_pack(&md->current_writeset->md, &disk->current_writeset);\n\tdisk->writeset_tree_root = cpu_to_le64(md->writeset_tree_root);\n\tdisk->era_array_root = cpu_to_le64(md->era_array_root);\n\tdisk->metadata_snap = cpu_to_le64(md->metadata_snap);\n}\n\nstatic int write_superblock(struct era_metadata *md)\n{\n\tint r;\n\tstruct dm_block *sblock;\n\tstruct superblock_disk *disk;\n\n\tr = save_sm_root(md);\n\tif (r) {\n\t\tDMERR(\"%s: save_sm_root failed\", __func__);\n\t\treturn r;\n\t}\n\n\tr = superblock_lock_zero(md, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk = dm_block_data(sblock);\n\tprepare_superblock(md, disk);\n\n\treturn dm_tm_commit(md->tm, sblock);\n}\n\n \nstatic int format_metadata(struct era_metadata *md)\n{\n\tint r;\n\n\tr = create_fresh_metadata(md);\n\tif (r)\n\t\treturn r;\n\n\tr = write_superblock(md);\n\tif (r) {\n\t\tdm_sm_destroy(md->sm);\n\t\tdm_tm_destroy(md->tm);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int open_metadata(struct era_metadata *md)\n{\n\tint r;\n\tstruct dm_block *sblock;\n\tstruct superblock_disk *disk;\n\n\tr = superblock_read_lock(md, &sblock);\n\tif (r) {\n\t\tDMERR(\"couldn't read_lock superblock\");\n\t\treturn r;\n\t}\n\n\tdisk = dm_block_data(sblock);\n\n\t \n\tif (le32_to_cpu(disk->data_block_size) != md->block_size) {\n\t\tDMERR(\"changing the data block size (from %u to %llu) is not supported\",\n\t\t      le32_to_cpu(disk->data_block_size), md->block_size);\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\tr = dm_tm_open_with_sm(md->bm, SUPERBLOCK_LOCATION,\n\t\t\t       disk->metadata_space_map_root,\n\t\t\t       sizeof(disk->metadata_space_map_root),\n\t\t\t       &md->tm, &md->sm);\n\tif (r) {\n\t\tDMERR(\"dm_tm_open_with_sm failed\");\n\t\tgoto bad;\n\t}\n\n\tsetup_infos(md);\n\n\tmd->nr_blocks = le32_to_cpu(disk->nr_blocks);\n\tmd->current_era = le32_to_cpu(disk->current_era);\n\n\tws_unpack(&disk->current_writeset, &md->current_writeset->md);\n\tmd->writeset_tree_root = le64_to_cpu(disk->writeset_tree_root);\n\tmd->era_array_root = le64_to_cpu(disk->era_array_root);\n\tmd->metadata_snap = le64_to_cpu(disk->metadata_snap);\n\tmd->archived_writesets = true;\n\n\tdm_bm_unlock(sblock);\n\n\treturn 0;\n\nbad:\n\tdm_bm_unlock(sblock);\n\treturn r;\n}\n\nstatic int open_or_format_metadata(struct era_metadata *md,\n\t\t\t\t   bool may_format)\n{\n\tint r;\n\tbool unformatted = false;\n\n\tr = superblock_all_zeroes(md->bm, &unformatted);\n\tif (r)\n\t\treturn r;\n\n\tif (unformatted)\n\t\treturn may_format ? format_metadata(md) : -EPERM;\n\n\treturn open_metadata(md);\n}\n\nstatic int create_persistent_data_objects(struct era_metadata *md,\n\t\t\t\t\t  bool may_format)\n{\n\tint r;\n\n\tmd->bm = dm_block_manager_create(md->bdev, DM_ERA_METADATA_BLOCK_SIZE,\n\t\t\t\t\t ERA_MAX_CONCURRENT_LOCKS);\n\tif (IS_ERR(md->bm)) {\n\t\tDMERR(\"could not create block manager\");\n\t\treturn PTR_ERR(md->bm);\n\t}\n\n\tr = open_or_format_metadata(md, may_format);\n\tif (r)\n\t\tdm_block_manager_destroy(md->bm);\n\n\treturn r;\n}\n\nstatic void destroy_persistent_data_objects(struct era_metadata *md)\n{\n\tdm_sm_destroy(md->sm);\n\tdm_tm_destroy(md->tm);\n\tdm_block_manager_destroy(md->bm);\n}\n\n \nstatic void swap_writeset(struct era_metadata *md, struct writeset *new_writeset)\n{\n\trcu_assign_pointer(md->current_writeset, new_writeset);\n\tsynchronize_rcu();\n}\n\n \nstruct digest {\n\tuint32_t era;\n\tunsigned int nr_bits, current_bit;\n\tstruct writeset_metadata writeset;\n\t__le32 value;\n\tstruct dm_disk_bitset info;\n\n\tint (*step)(struct era_metadata *md, struct digest *d);\n};\n\nstatic int metadata_digest_lookup_writeset(struct era_metadata *md,\n\t\t\t\t\t   struct digest *d);\n\nstatic int metadata_digest_remove_writeset(struct era_metadata *md,\n\t\t\t\t\t   struct digest *d)\n{\n\tint r;\n\tuint64_t key = d->era;\n\n\tr = dm_btree_remove(&md->writeset_tree_info, md->writeset_tree_root,\n\t\t\t    &key, &md->writeset_tree_root);\n\tif (r) {\n\t\tDMERR(\"%s: dm_btree_remove failed\", __func__);\n\t\treturn r;\n\t}\n\n\td->step = metadata_digest_lookup_writeset;\n\treturn 0;\n}\n\n#define INSERTS_PER_STEP 100\n\nstatic int metadata_digest_transcribe_writeset(struct era_metadata *md,\n\t\t\t\t\t       struct digest *d)\n{\n\tint r;\n\tbool marked;\n\tunsigned int b, e = min(d->current_bit + INSERTS_PER_STEP, d->nr_bits);\n\n\tfor (b = d->current_bit; b < e; b++) {\n\t\tr = writeset_marked_on_disk(&d->info, &d->writeset, b, &marked);\n\t\tif (r) {\n\t\t\tDMERR(\"%s: writeset_marked_on_disk failed\", __func__);\n\t\t\treturn r;\n\t\t}\n\n\t\tif (!marked)\n\t\t\tcontinue;\n\n\t\t__dm_bless_for_disk(&d->value);\n\t\tr = dm_array_set_value(&md->era_array_info, md->era_array_root,\n\t\t\t\t       b, &d->value, &md->era_array_root);\n\t\tif (r) {\n\t\t\tDMERR(\"%s: dm_array_set_value failed\", __func__);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (b == d->nr_bits)\n\t\td->step = metadata_digest_remove_writeset;\n\telse\n\t\td->current_bit = b;\n\n\treturn 0;\n}\n\nstatic int metadata_digest_lookup_writeset(struct era_metadata *md,\n\t\t\t\t\t   struct digest *d)\n{\n\tint r;\n\tuint64_t key;\n\tstruct writeset_disk disk;\n\n\tr = dm_btree_find_lowest_key(&md->writeset_tree_info,\n\t\t\t\t     md->writeset_tree_root, &key);\n\tif (r < 0)\n\t\treturn r;\n\n\td->era = key;\n\n\tr = dm_btree_lookup(&md->writeset_tree_info,\n\t\t\t    md->writeset_tree_root, &key, &disk);\n\tif (r) {\n\t\tif (r == -ENODATA) {\n\t\t\td->step = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tDMERR(\"%s: dm_btree_lookup failed\", __func__);\n\t\treturn r;\n\t}\n\n\tws_unpack(&disk, &d->writeset);\n\td->value = cpu_to_le32(key);\n\n\t \n\tdm_disk_bitset_init(md->tm, &d->info);\n\n\td->nr_bits = min(d->writeset.nr_bits, md->nr_blocks);\n\td->current_bit = 0;\n\td->step = metadata_digest_transcribe_writeset;\n\n\treturn 0;\n}\n\nstatic int metadata_digest_start(struct era_metadata *md, struct digest *d)\n{\n\tif (d->step)\n\t\treturn 0;\n\n\tmemset(d, 0, sizeof(*d));\n\td->step = metadata_digest_lookup_writeset;\n\n\treturn 0;\n}\n\n \nstatic struct era_metadata *metadata_open(struct block_device *bdev,\n\t\t\t\t\t  sector_t block_size,\n\t\t\t\t\t  bool may_format)\n{\n\tint r;\n\tstruct era_metadata *md = kzalloc(sizeof(*md), GFP_KERNEL);\n\n\tif (!md)\n\t\treturn NULL;\n\n\tmd->bdev = bdev;\n\tmd->block_size = block_size;\n\n\tmd->writesets[0].md.root = INVALID_WRITESET_ROOT;\n\tmd->writesets[1].md.root = INVALID_WRITESET_ROOT;\n\tmd->current_writeset = &md->writesets[0];\n\n\tr = create_persistent_data_objects(md, may_format);\n\tif (r) {\n\t\tkfree(md);\n\t\treturn ERR_PTR(r);\n\t}\n\n\treturn md;\n}\n\nstatic void metadata_close(struct era_metadata *md)\n{\n\twriteset_free(&md->writesets[0]);\n\twriteset_free(&md->writesets[1]);\n\tdestroy_persistent_data_objects(md);\n\tkfree(md);\n}\n\nstatic bool valid_nr_blocks(dm_block_t n)\n{\n\t \n\treturn n < (1ull << 31);\n}\n\nstatic int metadata_resize(struct era_metadata *md, void *arg)\n{\n\tint r;\n\tdm_block_t *new_size = arg;\n\t__le32 value;\n\n\tif (!valid_nr_blocks(*new_size)) {\n\t\tDMERR(\"Invalid number of origin blocks %llu\",\n\t\t      (unsigned long long) *new_size);\n\t\treturn -EINVAL;\n\t}\n\n\twriteset_free(&md->writesets[0]);\n\twriteset_free(&md->writesets[1]);\n\n\tr = writeset_alloc(&md->writesets[0], *new_size);\n\tif (r) {\n\t\tDMERR(\"%s: writeset_alloc failed for writeset 0\", __func__);\n\t\treturn r;\n\t}\n\n\tr = writeset_alloc(&md->writesets[1], *new_size);\n\tif (r) {\n\t\tDMERR(\"%s: writeset_alloc failed for writeset 1\", __func__);\n\t\twriteset_free(&md->writesets[0]);\n\t\treturn r;\n\t}\n\n\tvalue = cpu_to_le32(0u);\n\t__dm_bless_for_disk(&value);\n\tr = dm_array_resize(&md->era_array_info, md->era_array_root,\n\t\t\t    md->nr_blocks, *new_size,\n\t\t\t    &value, &md->era_array_root);\n\tif (r) {\n\t\tDMERR(\"%s: dm_array_resize failed\", __func__);\n\t\twriteset_free(&md->writesets[0]);\n\t\twriteset_free(&md->writesets[1]);\n\t\treturn r;\n\t}\n\n\tmd->nr_blocks = *new_size;\n\treturn 0;\n}\n\nstatic int metadata_era_archive(struct era_metadata *md)\n{\n\tint r;\n\tuint64_t keys[1];\n\tstruct writeset_disk value;\n\n\tr = dm_bitset_flush(&md->bitset_info, md->current_writeset->md.root,\n\t\t\t    &md->current_writeset->md.root);\n\tif (r) {\n\t\tDMERR(\"%s: dm_bitset_flush failed\", __func__);\n\t\treturn r;\n\t}\n\n\tws_pack(&md->current_writeset->md, &value);\n\n\tkeys[0] = md->current_era;\n\t__dm_bless_for_disk(&value);\n\tr = dm_btree_insert(&md->writeset_tree_info, md->writeset_tree_root,\n\t\t\t    keys, &value, &md->writeset_tree_root);\n\tif (r) {\n\t\tDMERR(\"%s: couldn't insert writeset into btree\", __func__);\n\t\t \n\t\treturn r;\n\t}\n\n\tmd->current_writeset->md.root = INVALID_WRITESET_ROOT;\n\tmd->archived_writesets = true;\n\n\treturn 0;\n}\n\nstatic struct writeset *next_writeset(struct era_metadata *md)\n{\n\treturn (md->current_writeset == &md->writesets[0]) ?\n\t\t&md->writesets[1] : &md->writesets[0];\n}\n\nstatic int metadata_new_era(struct era_metadata *md)\n{\n\tint r;\n\tstruct writeset *new_writeset = next_writeset(md);\n\n\tr = writeset_init(&md->bitset_info, new_writeset, md->nr_blocks);\n\tif (r) {\n\t\tDMERR(\"%s: writeset_init failed\", __func__);\n\t\treturn r;\n\t}\n\n\tswap_writeset(md, new_writeset);\n\tmd->current_era++;\n\n\treturn 0;\n}\n\nstatic int metadata_era_rollover(struct era_metadata *md)\n{\n\tint r;\n\n\tif (md->current_writeset->md.root != INVALID_WRITESET_ROOT) {\n\t\tr = metadata_era_archive(md);\n\t\tif (r) {\n\t\t\tDMERR(\"%s: metadata_archive_era failed\", __func__);\n\t\t\t \n\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = metadata_new_era(md);\n\tif (r) {\n\t\tDMERR(\"%s: new era failed\", __func__);\n\t\t \n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic bool metadata_current_marked(struct era_metadata *md, dm_block_t block)\n{\n\tbool r;\n\tstruct writeset *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(md->current_writeset);\n\tr = writeset_marked(ws, block);\n\trcu_read_unlock();\n\n\treturn r;\n}\n\nstatic int metadata_commit(struct era_metadata *md)\n{\n\tint r;\n\tstruct dm_block *sblock;\n\n\tif (md->current_writeset->md.root != INVALID_WRITESET_ROOT) {\n\t\tr = dm_bitset_flush(&md->bitset_info, md->current_writeset->md.root,\n\t\t\t\t    &md->current_writeset->md.root);\n\t\tif (r) {\n\t\t\tDMERR(\"%s: bitset flush failed\", __func__);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = dm_tm_pre_commit(md->tm);\n\tif (r) {\n\t\tDMERR(\"%s: pre commit failed\", __func__);\n\t\treturn r;\n\t}\n\n\tr = save_sm_root(md);\n\tif (r) {\n\t\tDMERR(\"%s: save_sm_root failed\", __func__);\n\t\treturn r;\n\t}\n\n\tr = superblock_lock(md, &sblock);\n\tif (r) {\n\t\tDMERR(\"%s: superblock lock failed\", __func__);\n\t\treturn r;\n\t}\n\n\tprepare_superblock(md, dm_block_data(sblock));\n\n\treturn dm_tm_commit(md->tm, sblock);\n}\n\nstatic int metadata_checkpoint(struct era_metadata *md)\n{\n\t \n\treturn metadata_era_rollover(md);\n}\n\n \nstatic int metadata_take_snap(struct era_metadata *md)\n{\n\tint r, inc;\n\tstruct dm_block *clone;\n\n\tif (md->metadata_snap != SUPERBLOCK_LOCATION) {\n\t\tDMERR(\"%s: metadata snapshot already exists\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tr = metadata_era_rollover(md);\n\tif (r) {\n\t\tDMERR(\"%s: era rollover failed\", __func__);\n\t\treturn r;\n\t}\n\n\tr = metadata_commit(md);\n\tif (r) {\n\t\tDMERR(\"%s: pre commit failed\", __func__);\n\t\treturn r;\n\t}\n\n\tr = dm_sm_inc_block(md->sm, SUPERBLOCK_LOCATION);\n\tif (r) {\n\t\tDMERR(\"%s: couldn't increment superblock\", __func__);\n\t\treturn r;\n\t}\n\n\tr = dm_tm_shadow_block(md->tm, SUPERBLOCK_LOCATION,\n\t\t\t       &sb_validator, &clone, &inc);\n\tif (r) {\n\t\tDMERR(\"%s: couldn't shadow superblock\", __func__);\n\t\tdm_sm_dec_block(md->sm, SUPERBLOCK_LOCATION);\n\t\treturn r;\n\t}\n\tBUG_ON(!inc);\n\n\tr = dm_sm_inc_block(md->sm, md->writeset_tree_root);\n\tif (r) {\n\t\tDMERR(\"%s: couldn't inc writeset tree root\", __func__);\n\t\tdm_tm_unlock(md->tm, clone);\n\t\treturn r;\n\t}\n\n\tr = dm_sm_inc_block(md->sm, md->era_array_root);\n\tif (r) {\n\t\tDMERR(\"%s: couldn't inc era tree root\", __func__);\n\t\tdm_sm_dec_block(md->sm, md->writeset_tree_root);\n\t\tdm_tm_unlock(md->tm, clone);\n\t\treturn r;\n\t}\n\n\tmd->metadata_snap = dm_block_location(clone);\n\n\tdm_tm_unlock(md->tm, clone);\n\n\treturn 0;\n}\n\nstatic int metadata_drop_snap(struct era_metadata *md)\n{\n\tint r;\n\tdm_block_t location;\n\tstruct dm_block *clone;\n\tstruct superblock_disk *disk;\n\n\tif (md->metadata_snap == SUPERBLOCK_LOCATION) {\n\t\tDMERR(\"%s: no snap to drop\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tr = dm_tm_read_lock(md->tm, md->metadata_snap, &sb_validator, &clone);\n\tif (r) {\n\t\tDMERR(\"%s: couldn't read lock superblock clone\", __func__);\n\t\treturn r;\n\t}\n\n\t \n\tmd->metadata_snap = SUPERBLOCK_LOCATION;\n\n\tdisk = dm_block_data(clone);\n\tr = dm_btree_del(&md->writeset_tree_info,\n\t\t\t le64_to_cpu(disk->writeset_tree_root));\n\tif (r) {\n\t\tDMERR(\"%s: error deleting writeset tree clone\", __func__);\n\t\tdm_tm_unlock(md->tm, clone);\n\t\treturn r;\n\t}\n\n\tr = dm_array_del(&md->era_array_info, le64_to_cpu(disk->era_array_root));\n\tif (r) {\n\t\tDMERR(\"%s: error deleting era array clone\", __func__);\n\t\tdm_tm_unlock(md->tm, clone);\n\t\treturn r;\n\t}\n\n\tlocation = dm_block_location(clone);\n\tdm_tm_unlock(md->tm, clone);\n\n\treturn dm_sm_dec_block(md->sm, location);\n}\n\nstruct metadata_stats {\n\tdm_block_t used;\n\tdm_block_t total;\n\tdm_block_t snap;\n\tuint32_t era;\n};\n\nstatic int metadata_get_stats(struct era_metadata *md, void *ptr)\n{\n\tint r;\n\tstruct metadata_stats *s = ptr;\n\tdm_block_t nr_free, nr_total;\n\n\tr = dm_sm_get_nr_free(md->sm, &nr_free);\n\tif (r) {\n\t\tDMERR(\"dm_sm_get_nr_free returned %d\", r);\n\t\treturn r;\n\t}\n\n\tr = dm_sm_get_nr_blocks(md->sm, &nr_total);\n\tif (r) {\n\t\tDMERR(\"dm_pool_get_metadata_dev_size returned %d\", r);\n\t\treturn r;\n\t}\n\n\ts->used = nr_total - nr_free;\n\ts->total = nr_total;\n\ts->snap = md->metadata_snap;\n\ts->era = md->current_era;\n\n\treturn 0;\n}\n\n \n\nstruct era {\n\tstruct dm_target *ti;\n\n\tstruct dm_dev *metadata_dev;\n\tstruct dm_dev *origin_dev;\n\n\tdm_block_t nr_blocks;\n\tuint32_t sectors_per_block;\n\tint sectors_per_block_shift;\n\tstruct era_metadata *md;\n\n\tstruct workqueue_struct *wq;\n\tstruct work_struct worker;\n\n\tspinlock_t deferred_lock;\n\tstruct bio_list deferred_bios;\n\n\tspinlock_t rpc_lock;\n\tstruct list_head rpc_calls;\n\n\tstruct digest digest;\n\tatomic_t suspended;\n};\n\nstruct rpc {\n\tstruct list_head list;\n\n\tint (*fn0)(struct era_metadata *md);\n\tint (*fn1)(struct era_metadata *md, void *ref);\n\tvoid *arg;\n\tint result;\n\n\tstruct completion complete;\n};\n\n \nstatic bool block_size_is_power_of_two(struct era *era)\n{\n\treturn era->sectors_per_block_shift >= 0;\n}\n\nstatic dm_block_t get_block(struct era *era, struct bio *bio)\n{\n\tsector_t block_nr = bio->bi_iter.bi_sector;\n\n\tif (!block_size_is_power_of_two(era))\n\t\t(void) sector_div(block_nr, era->sectors_per_block);\n\telse\n\t\tblock_nr >>= era->sectors_per_block_shift;\n\n\treturn block_nr;\n}\n\nstatic void remap_to_origin(struct era *era, struct bio *bio)\n{\n\tbio_set_dev(bio, era->origin_dev->bdev);\n}\n\n \nstatic void wake_worker(struct era *era)\n{\n\tif (!atomic_read(&era->suspended))\n\t\tqueue_work(era->wq, &era->worker);\n}\n\nstatic void process_old_eras(struct era *era)\n{\n\tint r;\n\n\tif (!era->digest.step)\n\t\treturn;\n\n\tr = era->digest.step(era->md, &era->digest);\n\tif (r < 0) {\n\t\tDMERR(\"%s: digest step failed, stopping digestion\", __func__);\n\t\tera->digest.step = NULL;\n\n\t} else if (era->digest.step)\n\t\twake_worker(era);\n}\n\nstatic void process_deferred_bios(struct era *era)\n{\n\tint r;\n\tstruct bio_list deferred_bios, marked_bios;\n\tstruct bio *bio;\n\tstruct blk_plug plug;\n\tbool commit_needed = false;\n\tbool failed = false;\n\tstruct writeset *ws = era->md->current_writeset;\n\n\tbio_list_init(&deferred_bios);\n\tbio_list_init(&marked_bios);\n\n\tspin_lock(&era->deferred_lock);\n\tbio_list_merge(&deferred_bios, &era->deferred_bios);\n\tbio_list_init(&era->deferred_bios);\n\tspin_unlock(&era->deferred_lock);\n\n\tif (bio_list_empty(&deferred_bios))\n\t\treturn;\n\n\twhile ((bio = bio_list_pop(&deferred_bios))) {\n\t\tr = writeset_test_and_set(&era->md->bitset_info, ws,\n\t\t\t\t\t  get_block(era, bio));\n\t\tif (r < 0) {\n\t\t\t \n\t\t\tfailed = true;\n\t\t} else if (r == 0)\n\t\t\tcommit_needed = true;\n\n\t\tbio_list_add(&marked_bios, bio);\n\t}\n\n\tif (commit_needed) {\n\t\tr = metadata_commit(era->md);\n\t\tif (r)\n\t\t\tfailed = true;\n\t}\n\n\tif (failed)\n\t\twhile ((bio = bio_list_pop(&marked_bios)))\n\t\t\tbio_io_error(bio);\n\telse {\n\t\tblk_start_plug(&plug);\n\t\twhile ((bio = bio_list_pop(&marked_bios))) {\n\t\t\t \n\t\t\tif (commit_needed)\n\t\t\t\tset_bit(get_block(era, bio), ws->bits);\n\t\t\tsubmit_bio_noacct(bio);\n\t\t}\n\t\tblk_finish_plug(&plug);\n\t}\n}\n\nstatic void process_rpc_calls(struct era *era)\n{\n\tint r;\n\tbool need_commit = false;\n\tstruct list_head calls;\n\tstruct rpc *rpc, *tmp;\n\n\tINIT_LIST_HEAD(&calls);\n\tspin_lock(&era->rpc_lock);\n\tlist_splice_init(&era->rpc_calls, &calls);\n\tspin_unlock(&era->rpc_lock);\n\n\tlist_for_each_entry_safe(rpc, tmp, &calls, list) {\n\t\trpc->result = rpc->fn0 ? rpc->fn0(era->md) : rpc->fn1(era->md, rpc->arg);\n\t\tneed_commit = true;\n\t}\n\n\tif (need_commit) {\n\t\tr = metadata_commit(era->md);\n\t\tif (r)\n\t\t\tlist_for_each_entry_safe(rpc, tmp, &calls, list)\n\t\t\t\trpc->result = r;\n\t}\n\n\tlist_for_each_entry_safe(rpc, tmp, &calls, list)\n\t\tcomplete(&rpc->complete);\n}\n\nstatic void kick_off_digest(struct era *era)\n{\n\tif (era->md->archived_writesets) {\n\t\tera->md->archived_writesets = false;\n\t\tmetadata_digest_start(era->md, &era->digest);\n\t}\n}\n\nstatic void do_work(struct work_struct *ws)\n{\n\tstruct era *era = container_of(ws, struct era, worker);\n\n\tkick_off_digest(era);\n\tprocess_old_eras(era);\n\tprocess_deferred_bios(era);\n\tprocess_rpc_calls(era);\n}\n\nstatic void defer_bio(struct era *era, struct bio *bio)\n{\n\tspin_lock(&era->deferred_lock);\n\tbio_list_add(&era->deferred_bios, bio);\n\tspin_unlock(&era->deferred_lock);\n\n\twake_worker(era);\n}\n\n \nstatic int perform_rpc(struct era *era, struct rpc *rpc)\n{\n\trpc->result = 0;\n\tinit_completion(&rpc->complete);\n\n\tspin_lock(&era->rpc_lock);\n\tlist_add(&rpc->list, &era->rpc_calls);\n\tspin_unlock(&era->rpc_lock);\n\n\twake_worker(era);\n\twait_for_completion(&rpc->complete);\n\n\treturn rpc->result;\n}\n\nstatic int in_worker0(struct era *era, int (*fn)(struct era_metadata *md))\n{\n\tstruct rpc rpc;\n\n\trpc.fn0 = fn;\n\trpc.fn1 = NULL;\n\n\treturn perform_rpc(era, &rpc);\n}\n\nstatic int in_worker1(struct era *era,\n\t\t      int (*fn)(struct era_metadata *md, void *ref), void *arg)\n{\n\tstruct rpc rpc;\n\n\trpc.fn0 = NULL;\n\trpc.fn1 = fn;\n\trpc.arg = arg;\n\n\treturn perform_rpc(era, &rpc);\n}\n\nstatic void start_worker(struct era *era)\n{\n\tatomic_set(&era->suspended, 0);\n}\n\nstatic void stop_worker(struct era *era)\n{\n\tatomic_set(&era->suspended, 1);\n\tdrain_workqueue(era->wq);\n}\n\n \nstatic void era_destroy(struct era *era)\n{\n\tif (era->md)\n\t\tmetadata_close(era->md);\n\n\tif (era->wq)\n\t\tdestroy_workqueue(era->wq);\n\n\tif (era->origin_dev)\n\t\tdm_put_device(era->ti, era->origin_dev);\n\n\tif (era->metadata_dev)\n\t\tdm_put_device(era->ti, era->metadata_dev);\n\n\tkfree(era);\n}\n\nstatic dm_block_t calc_nr_blocks(struct era *era)\n{\n\treturn dm_sector_div_up(era->ti->len, era->sectors_per_block);\n}\n\nstatic bool valid_block_size(dm_block_t block_size)\n{\n\tbool greater_than_zero = block_size > 0;\n\tbool multiple_of_min_block_size = (block_size & (MIN_BLOCK_SIZE - 1)) == 0;\n\n\treturn greater_than_zero && multiple_of_min_block_size;\n}\n\n \nstatic int era_ctr(struct dm_target *ti, unsigned int argc, char **argv)\n{\n\tint r;\n\tchar dummy;\n\tstruct era *era;\n\tstruct era_metadata *md;\n\n\tif (argc != 3) {\n\t\tti->error = \"Invalid argument count\";\n\t\treturn -EINVAL;\n\t}\n\n\tera = kzalloc(sizeof(*era), GFP_KERNEL);\n\tif (!era) {\n\t\tti->error = \"Error allocating era structure\";\n\t\treturn -ENOMEM;\n\t}\n\n\tera->ti = ti;\n\n\tr = dm_get_device(ti, argv[0], BLK_OPEN_READ | BLK_OPEN_WRITE,\n\t\t\t  &era->metadata_dev);\n\tif (r) {\n\t\tti->error = \"Error opening metadata device\";\n\t\tera_destroy(era);\n\t\treturn -EINVAL;\n\t}\n\n\tr = dm_get_device(ti, argv[1], BLK_OPEN_READ | BLK_OPEN_WRITE,\n\t\t\t  &era->origin_dev);\n\tif (r) {\n\t\tti->error = \"Error opening data device\";\n\t\tera_destroy(era);\n\t\treturn -EINVAL;\n\t}\n\n\tr = sscanf(argv[2], \"%u%c\", &era->sectors_per_block, &dummy);\n\tif (r != 1) {\n\t\tti->error = \"Error parsing block size\";\n\t\tera_destroy(era);\n\t\treturn -EINVAL;\n\t}\n\n\tr = dm_set_target_max_io_len(ti, era->sectors_per_block);\n\tif (r) {\n\t\tti->error = \"could not set max io len\";\n\t\tera_destroy(era);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!valid_block_size(era->sectors_per_block)) {\n\t\tti->error = \"Invalid block size\";\n\t\tera_destroy(era);\n\t\treturn -EINVAL;\n\t}\n\tif (era->sectors_per_block & (era->sectors_per_block - 1))\n\t\tera->sectors_per_block_shift = -1;\n\telse\n\t\tera->sectors_per_block_shift = __ffs(era->sectors_per_block);\n\n\tmd = metadata_open(era->metadata_dev->bdev, era->sectors_per_block, true);\n\tif (IS_ERR(md)) {\n\t\tti->error = \"Error reading metadata\";\n\t\tera_destroy(era);\n\t\treturn PTR_ERR(md);\n\t}\n\tera->md = md;\n\n\tera->wq = alloc_ordered_workqueue(\"dm-\" DM_MSG_PREFIX, WQ_MEM_RECLAIM);\n\tif (!era->wq) {\n\t\tti->error = \"could not create workqueue for metadata object\";\n\t\tera_destroy(era);\n\t\treturn -ENOMEM;\n\t}\n\tINIT_WORK(&era->worker, do_work);\n\n\tspin_lock_init(&era->deferred_lock);\n\tbio_list_init(&era->deferred_bios);\n\n\tspin_lock_init(&era->rpc_lock);\n\tINIT_LIST_HEAD(&era->rpc_calls);\n\n\tti->private = era;\n\tti->num_flush_bios = 1;\n\tti->flush_supported = true;\n\n\tti->num_discard_bios = 1;\n\n\treturn 0;\n}\n\nstatic void era_dtr(struct dm_target *ti)\n{\n\tera_destroy(ti->private);\n}\n\nstatic int era_map(struct dm_target *ti, struct bio *bio)\n{\n\tstruct era *era = ti->private;\n\tdm_block_t block = get_block(era, bio);\n\n\t \n\tremap_to_origin(era, bio);\n\n\t \n\tif (!(bio->bi_opf & REQ_PREFLUSH) &&\n\t    (bio_data_dir(bio) == WRITE) &&\n\t    !metadata_current_marked(era->md, block)) {\n\t\tdefer_bio(era, bio);\n\t\treturn DM_MAPIO_SUBMITTED;\n\t}\n\n\treturn DM_MAPIO_REMAPPED;\n}\n\nstatic void era_postsuspend(struct dm_target *ti)\n{\n\tint r;\n\tstruct era *era = ti->private;\n\n\tr = in_worker0(era, metadata_era_archive);\n\tif (r) {\n\t\tDMERR(\"%s: couldn't archive current era\", __func__);\n\t\t \n\t}\n\n\tstop_worker(era);\n\n\tr = metadata_commit(era->md);\n\tif (r) {\n\t\tDMERR(\"%s: metadata_commit failed\", __func__);\n\t\t \n\t}\n}\n\nstatic int era_preresume(struct dm_target *ti)\n{\n\tint r;\n\tstruct era *era = ti->private;\n\tdm_block_t new_size = calc_nr_blocks(era);\n\n\tif (era->nr_blocks != new_size) {\n\t\tr = metadata_resize(era->md, &new_size);\n\t\tif (r) {\n\t\t\tDMERR(\"%s: metadata_resize failed\", __func__);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = metadata_commit(era->md);\n\t\tif (r) {\n\t\t\tDMERR(\"%s: metadata_commit failed\", __func__);\n\t\t\treturn r;\n\t\t}\n\n\t\tera->nr_blocks = new_size;\n\t}\n\n\tstart_worker(era);\n\n\tr = in_worker0(era, metadata_era_rollover);\n\tif (r) {\n\t\tDMERR(\"%s: metadata_era_rollover failed\", __func__);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void era_status(struct dm_target *ti, status_type_t type,\n\t\t       unsigned int status_flags, char *result, unsigned int maxlen)\n{\n\tint r;\n\tstruct era *era = ti->private;\n\tssize_t sz = 0;\n\tstruct metadata_stats stats;\n\tchar buf[BDEVNAME_SIZE];\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\tr = in_worker1(era, metadata_get_stats, &stats);\n\t\tif (r)\n\t\t\tgoto err;\n\n\t\tDMEMIT(\"%u %llu/%llu %u\",\n\t\t       (unsigned int) (DM_ERA_METADATA_BLOCK_SIZE >> SECTOR_SHIFT),\n\t\t       (unsigned long long) stats.used,\n\t\t       (unsigned long long) stats.total,\n\t\t       (unsigned int) stats.era);\n\n\t\tif (stats.snap != SUPERBLOCK_LOCATION)\n\t\t\tDMEMIT(\" %llu\", stats.snap);\n\t\telse\n\t\t\tDMEMIT(\" -\");\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tformat_dev_t(buf, era->metadata_dev->bdev->bd_dev);\n\t\tDMEMIT(\"%s \", buf);\n\t\tformat_dev_t(buf, era->origin_dev->bdev->bd_dev);\n\t\tDMEMIT(\"%s %u\", buf, era->sectors_per_block);\n\t\tbreak;\n\n\tcase STATUSTYPE_IMA:\n\t\t*result = '\\0';\n\t\tbreak;\n\t}\n\n\treturn;\n\nerr:\n\tDMEMIT(\"Error\");\n}\n\nstatic int era_message(struct dm_target *ti, unsigned int argc, char **argv,\n\t\t       char *result, unsigned int maxlen)\n{\n\tstruct era *era = ti->private;\n\n\tif (argc != 1) {\n\t\tDMERR(\"incorrect number of message arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!strcasecmp(argv[0], \"checkpoint\"))\n\t\treturn in_worker0(era, metadata_checkpoint);\n\n\tif (!strcasecmp(argv[0], \"take_metadata_snap\"))\n\t\treturn in_worker0(era, metadata_take_snap);\n\n\tif (!strcasecmp(argv[0], \"drop_metadata_snap\"))\n\t\treturn in_worker0(era, metadata_drop_snap);\n\n\tDMERR(\"unsupported message '%s'\", argv[0]);\n\treturn -EINVAL;\n}\n\nstatic sector_t get_dev_size(struct dm_dev *dev)\n{\n\treturn bdev_nr_sectors(dev->bdev);\n}\n\nstatic int era_iterate_devices(struct dm_target *ti,\n\t\t\t       iterate_devices_callout_fn fn, void *data)\n{\n\tstruct era *era = ti->private;\n\n\treturn fn(ti, era->origin_dev, 0, get_dev_size(era->origin_dev), data);\n}\n\nstatic void era_io_hints(struct dm_target *ti, struct queue_limits *limits)\n{\n\tstruct era *era = ti->private;\n\tuint64_t io_opt_sectors = limits->io_opt >> SECTOR_SHIFT;\n\n\t \n\tif (io_opt_sectors < era->sectors_per_block ||\n\t    do_div(io_opt_sectors, era->sectors_per_block)) {\n\t\tblk_limits_io_min(limits, 0);\n\t\tblk_limits_io_opt(limits, era->sectors_per_block << SECTOR_SHIFT);\n\t}\n}\n\n \n\nstatic struct target_type era_target = {\n\t.name = \"era\",\n\t.version = {1, 0, 0},\n\t.module = THIS_MODULE,\n\t.ctr = era_ctr,\n\t.dtr = era_dtr,\n\t.map = era_map,\n\t.postsuspend = era_postsuspend,\n\t.preresume = era_preresume,\n\t.status = era_status,\n\t.message = era_message,\n\t.iterate_devices = era_iterate_devices,\n\t.io_hints = era_io_hints\n};\nmodule_dm(era);\n\nMODULE_DESCRIPTION(DM_NAME \" era target\");\nMODULE_AUTHOR(\"Joe Thornber <ejt@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}