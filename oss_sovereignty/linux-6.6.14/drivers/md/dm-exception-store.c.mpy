{
  "module_name": "dm-exception-store.c",
  "hash_id": "4671a6ca3485e85e7d457a1c8d1a566b55969c055a08d85624ec30637f5ffc99",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-exception-store.c",
  "human_readable_source": "\n \n\n#include \"dm-exception-store.h\"\n\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#define DM_MSG_PREFIX \"snapshot exception stores\"\n\nstatic LIST_HEAD(_exception_store_types);\nstatic DEFINE_SPINLOCK(_lock);\n\nstatic struct dm_exception_store_type *__find_exception_store_type(const char *name)\n{\n\tstruct dm_exception_store_type *type;\n\n\tlist_for_each_entry(type, &_exception_store_types, list)\n\t\tif (!strcmp(name, type->name))\n\t\t\treturn type;\n\n\treturn NULL;\n}\n\nstatic struct dm_exception_store_type *_get_exception_store_type(const char *name)\n{\n\tstruct dm_exception_store_type *type;\n\n\tspin_lock(&_lock);\n\n\ttype = __find_exception_store_type(name);\n\n\tif (type && !try_module_get(type->module))\n\t\ttype = NULL;\n\n\tspin_unlock(&_lock);\n\n\treturn type;\n}\n\n \nstatic struct dm_exception_store_type *get_type(const char *type_name)\n{\n\tchar *p, *type_name_dup;\n\tstruct dm_exception_store_type *type;\n\n\ttype = _get_exception_store_type(type_name);\n\tif (type)\n\t\treturn type;\n\n\ttype_name_dup = kstrdup(type_name, GFP_KERNEL);\n\tif (!type_name_dup) {\n\t\tDMERR(\"No memory left to attempt load for \\\"%s\\\"\", type_name);\n\t\treturn NULL;\n\t}\n\n\twhile (request_module(\"dm-exstore-%s\", type_name_dup) ||\n\t       !(type = _get_exception_store_type(type_name))) {\n\t\tp = strrchr(type_name_dup, '-');\n\t\tif (!p)\n\t\t\tbreak;\n\t\tp[0] = '\\0';\n\t}\n\n\tif (!type)\n\t\tDMWARN(\"Module for exstore type \\\"%s\\\" not found.\", type_name);\n\n\tkfree(type_name_dup);\n\n\treturn type;\n}\n\nstatic void put_type(struct dm_exception_store_type *type)\n{\n\tspin_lock(&_lock);\n\tmodule_put(type->module);\n\tspin_unlock(&_lock);\n}\n\nint dm_exception_store_type_register(struct dm_exception_store_type *type)\n{\n\tint r = 0;\n\n\tspin_lock(&_lock);\n\tif (!__find_exception_store_type(type->name))\n\t\tlist_add(&type->list, &_exception_store_types);\n\telse\n\t\tr = -EEXIST;\n\tspin_unlock(&_lock);\n\n\treturn r;\n}\nEXPORT_SYMBOL(dm_exception_store_type_register);\n\nint dm_exception_store_type_unregister(struct dm_exception_store_type *type)\n{\n\tspin_lock(&_lock);\n\n\tif (!__find_exception_store_type(type->name)) {\n\t\tspin_unlock(&_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tlist_del(&type->list);\n\n\tspin_unlock(&_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dm_exception_store_type_unregister);\n\nstatic int set_chunk_size(struct dm_exception_store *store,\n\t\t\t  const char *chunk_size_arg, char **error)\n{\n\tunsigned int chunk_size;\n\n\tif (kstrtouint(chunk_size_arg, 10, &chunk_size)) {\n\t\t*error = \"Invalid chunk size\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (!chunk_size) {\n\t\tstore->chunk_size = store->chunk_mask = store->chunk_shift = 0;\n\t\treturn 0;\n\t}\n\n\treturn dm_exception_store_set_chunk_size(store, chunk_size, error);\n}\n\nint dm_exception_store_set_chunk_size(struct dm_exception_store *store,\n\t\t\t\t      unsigned int chunk_size,\n\t\t\t\t      char **error)\n{\n\t \n\tif (!is_power_of_2(chunk_size)) {\n\t\t*error = \"Chunk size is not a power of 2\";\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (chunk_size %\n\t    (bdev_logical_block_size(dm_snap_cow(store->snap)->bdev) >> 9) ||\n\t    chunk_size %\n\t    (bdev_logical_block_size(dm_snap_origin(store->snap)->bdev) >> 9)) {\n\t\t*error = \"Chunk size is not a multiple of device blocksize\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (chunk_size > INT_MAX >> SECTOR_SHIFT) {\n\t\t*error = \"Chunk size is too high\";\n\t\treturn -EINVAL;\n\t}\n\n\tstore->chunk_size = chunk_size;\n\tstore->chunk_mask = chunk_size - 1;\n\tstore->chunk_shift = __ffs(chunk_size);\n\n\treturn 0;\n}\n\nint dm_exception_store_create(struct dm_target *ti, int argc, char **argv,\n\t\t\t      struct dm_snapshot *snap,\n\t\t\t      unsigned int *args_used,\n\t\t\t      struct dm_exception_store **store)\n{\n\tint r = 0;\n\tstruct dm_exception_store_type *type = NULL;\n\tstruct dm_exception_store *tmp_store;\n\tchar persistent;\n\n\tif (argc < 2) {\n\t\tti->error = \"Insufficient exception store arguments\";\n\t\treturn -EINVAL;\n\t}\n\n\ttmp_store = kzalloc(sizeof(*tmp_store), GFP_KERNEL);\n\tif (!tmp_store) {\n\t\tti->error = \"Exception store allocation failed\";\n\t\treturn -ENOMEM;\n\t}\n\n\tpersistent = toupper(*argv[0]);\n\tif (persistent == 'P')\n\t\ttype = get_type(\"P\");\n\telse if (persistent == 'N')\n\t\ttype = get_type(\"N\");\n\telse {\n\t\tti->error = \"Exception store type is not P or N\";\n\t\tr = -EINVAL;\n\t\tgoto bad_type;\n\t}\n\n\tif (!type) {\n\t\tti->error = \"Exception store type not recognised\";\n\t\tr = -EINVAL;\n\t\tgoto bad_type;\n\t}\n\n\ttmp_store->type = type;\n\ttmp_store->snap = snap;\n\n\tr = set_chunk_size(tmp_store, argv[1], &ti->error);\n\tif (r)\n\t\tgoto bad;\n\n\tr = type->ctr(tmp_store, (strlen(argv[0]) > 1 ? &argv[0][1] : NULL));\n\tif (r) {\n\t\tti->error = \"Exception store type constructor failed\";\n\t\tgoto bad;\n\t}\n\n\t*args_used = 2;\n\t*store = tmp_store;\n\treturn 0;\n\nbad:\n\tput_type(type);\nbad_type:\n\tkfree(tmp_store);\n\treturn r;\n}\nEXPORT_SYMBOL(dm_exception_store_create);\n\nvoid dm_exception_store_destroy(struct dm_exception_store *store)\n{\n\tstore->type->dtr(store);\n\tput_type(store->type);\n\tkfree(store);\n}\nEXPORT_SYMBOL(dm_exception_store_destroy);\n\nint dm_exception_store_init(void)\n{\n\tint r;\n\n\tr = dm_transient_snapshot_init();\n\tif (r) {\n\t\tDMERR(\"Unable to register transient exception store type.\");\n\t\tgoto transient_fail;\n\t}\n\n\tr = dm_persistent_snapshot_init();\n\tif (r) {\n\t\tDMERR(\"Unable to register persistent exception store type\");\n\t\tgoto persistent_fail;\n\t}\n\n\treturn 0;\n\npersistent_fail:\n\tdm_transient_snapshot_exit();\ntransient_fail:\n\treturn r;\n}\n\nvoid dm_exception_store_exit(void)\n{\n\tdm_persistent_snapshot_exit();\n\tdm_transient_snapshot_exit();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}