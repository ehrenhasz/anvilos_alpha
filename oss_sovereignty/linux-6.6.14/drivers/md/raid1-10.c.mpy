{
  "module_name": "raid1-10.c",
  "hash_id": "cde435bf678497f905965654ea02ab0d55ba325261d5ba9363bfc63c1bc68531",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/raid1-10.c",
  "human_readable_source": "\n \n#define RESYNC_BLOCK_SIZE (64*1024)\n#define RESYNC_PAGES ((RESYNC_BLOCK_SIZE + PAGE_SIZE-1) / PAGE_SIZE)\n\n \n#define\tNR_RAID_BIOS 256\n\n \n#define IO_BLOCKED ((struct bio *)1)\n \n#define IO_MADE_GOOD ((struct bio *)2)\n\n#define BIO_SPECIAL(bio) ((unsigned long)bio <= 2)\n#define MAX_PLUG_BIO 32\n\n \nstruct resync_pages {\n\tvoid\t\t*raid_bio;\n\tstruct page\t*pages[RESYNC_PAGES];\n};\n\nstruct raid1_plug_cb {\n\tstruct blk_plug_cb\tcb;\n\tstruct bio_list\t\tpending;\n\tunsigned int\t\tcount;\n};\n\nstatic void rbio_pool_free(void *rbio, void *data)\n{\n\tkfree(rbio);\n}\n\nstatic inline int resync_alloc_pages(struct resync_pages *rp,\n\t\t\t\t     gfp_t gfp_flags)\n{\n\tint i;\n\n\tfor (i = 0; i < RESYNC_PAGES; i++) {\n\t\trp->pages[i] = alloc_page(gfp_flags);\n\t\tif (!rp->pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\treturn 0;\n\nout_free:\n\twhile (--i >= 0)\n\t\tput_page(rp->pages[i]);\n\treturn -ENOMEM;\n}\n\nstatic inline void resync_free_pages(struct resync_pages *rp)\n{\n\tint i;\n\n\tfor (i = 0; i < RESYNC_PAGES; i++)\n\t\tput_page(rp->pages[i]);\n}\n\nstatic inline void resync_get_all_pages(struct resync_pages *rp)\n{\n\tint i;\n\n\tfor (i = 0; i < RESYNC_PAGES; i++)\n\t\tget_page(rp->pages[i]);\n}\n\nstatic inline struct page *resync_fetch_page(struct resync_pages *rp,\n\t\t\t\t\t     unsigned idx)\n{\n\tif (WARN_ON_ONCE(idx >= RESYNC_PAGES))\n\t\treturn NULL;\n\treturn rp->pages[idx];\n}\n\n \nstatic inline struct resync_pages *get_resync_pages(struct bio *bio)\n{\n\treturn bio->bi_private;\n}\n\n \nstatic void md_bio_reset_resync_pages(struct bio *bio, struct resync_pages *rp,\n\t\t\t       int size)\n{\n\tint idx = 0;\n\n\t \n\tdo {\n\t\tstruct page *page = resync_fetch_page(rp, idx);\n\t\tint len = min_t(int, size, PAGE_SIZE);\n\n\t\tif (WARN_ON(!bio_add_page(bio, page, len, 0))) {\n\t\t\tbio->bi_status = BLK_STS_RESOURCE;\n\t\t\tbio_endio(bio);\n\t\t\treturn;\n\t\t}\n\n\t\tsize -= len;\n\t} while (idx++ < RESYNC_PAGES && size > 0);\n}\n\n\nstatic inline void raid1_submit_write(struct bio *bio)\n{\n\tstruct md_rdev *rdev = (void *)bio->bi_bdev;\n\n\tbio->bi_next = NULL;\n\tbio_set_dev(bio, rdev->bdev);\n\tif (test_bit(Faulty, &rdev->flags))\n\t\tbio_io_error(bio);\n\telse if (unlikely(bio_op(bio) ==  REQ_OP_DISCARD &&\n\t\t\t  !bdev_max_discard_sectors(bio->bi_bdev)))\n\t\t \n\t\tbio_endio(bio);\n\telse\n\t\tsubmit_bio_noacct(bio);\n}\n\nstatic inline bool raid1_add_bio_to_plug(struct mddev *mddev, struct bio *bio,\n\t\t\t\t      blk_plug_cb_fn unplug, int copies)\n{\n\tstruct raid1_plug_cb *plug = NULL;\n\tstruct blk_plug_cb *cb;\n\n\t \n\tif (!md_bitmap_enabled(mddev->bitmap)) {\n\t\traid1_submit_write(bio);\n\t\treturn true;\n\t}\n\n\tcb = blk_check_plugged(unplug, mddev, sizeof(*plug));\n\tif (!cb)\n\t\treturn false;\n\n\tplug = container_of(cb, struct raid1_plug_cb, cb);\n\tbio_list_add(&plug->pending, bio);\n\tif (++plug->count / MAX_PLUG_BIO >= copies) {\n\t\tlist_del(&cb->list);\n\t\tcb->callback(cb, false);\n\t}\n\n\n\treturn true;\n}\n\n \nstatic inline void raid1_prepare_flush_writes(struct bitmap *bitmap)\n{\n\tif (current->bio_list)\n\t\tmd_bitmap_unplug_async(bitmap);\n\telse\n\t\tmd_bitmap_unplug(bitmap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}