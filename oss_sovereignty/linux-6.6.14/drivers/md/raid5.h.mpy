{
  "module_name": "raid5.h",
  "hash_id": "ae60dcc96beaa6a48d2539c08a892a06a2dd700299cb682d6601c14acd296628",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/raid5.h",
  "human_readable_source": " \n#ifndef _RAID5_H\n#define _RAID5_H\n\n#include <linux/raid/xor.h>\n#include <linux/dmaengine.h>\n#include <linux/local_lock.h>\n\n \n\n \n \nenum check_states {\n\tcheck_state_idle = 0,\n\tcheck_state_run,  \n\tcheck_state_run_q,  \n\tcheck_state_run_pq,  \n\tcheck_state_check_result,\n\tcheck_state_compute_run,  \n\tcheck_state_compute_result,\n};\n\n \nenum reconstruct_states {\n\treconstruct_state_idle = 0,\n\treconstruct_state_prexor_drain_run,\t \n\treconstruct_state_drain_run,\t\t \n\treconstruct_state_run,\t\t\t \n\treconstruct_state_prexor_drain_result,\n\treconstruct_state_drain_result,\n\treconstruct_state_result,\n};\n\n#define DEFAULT_STRIPE_SIZE\t4096\nstruct stripe_head {\n\tstruct hlist_node\thash;\n\tstruct list_head\tlru;\t       \n\tstruct llist_node\trelease_list;\n\tstruct r5conf\t\t*raid_conf;\n\tshort\t\t\tgeneration;\t \n\tsector_t\t\tsector;\t\t \n\tshort\t\t\tpd_idx;\t\t \n\tshort\t\t\tqd_idx;\t\t \n\tshort\t\t\tddf_layout; \n\tshort\t\t\thash_lock_index;\n\tunsigned long\t\tstate;\t\t \n\tatomic_t\t\tcount;\t       \n\tint\t\t\tbm_seq;\t \n\tint\t\t\tdisks;\t\t \n\tint\t\t\toverwrite_disks;  \n\tenum check_states\tcheck_state;\n\tenum reconstruct_states reconstruct_state;\n\tspinlock_t\t\tstripe_lock;\n\tint\t\t\tcpu;\n\tstruct r5worker_group\t*group;\n\n\tstruct stripe_head\t*batch_head;  \n\tspinlock_t\t\tbatch_lock;  \n\tstruct list_head\tbatch_list;  \n\n\tunion {\n\t\tstruct r5l_io_unit\t*log_io;\n\t\tstruct ppl_io_unit\t*ppl_io;\n\t};\n\n\tstruct list_head\tlog_list;\n\tsector_t\t\tlog_start;  \n\tstruct list_head\tr5c;  \n\n\tstruct page\t\t*ppl_page;  \n\t \n\tstruct stripe_operations {\n\t\tint \t\t     target, target2;\n\t\tenum sum_check_flags zero_sum_result;\n\t} ops;\n\n#if PAGE_SIZE != DEFAULT_STRIPE_SIZE\n\t \n\tstruct page\t**pages;\n\tint\tnr_pages;\t \n\tint\tstripes_per_page;\n#endif\n\tstruct r5dev {\n\t\t \n\t\tstruct bio\treq, rreq;\n\t\tstruct bio_vec\tvec, rvec;\n\t\tstruct page\t*page, *orig_page;\n\t\tunsigned int    offset;      \n\t\tstruct bio\t*toread, *read, *towrite, *written;\n\t\tsector_t\tsector;\t\t\t \n\t\tunsigned long\tflags;\n\t\tu32\t\tlog_checksum;\n\t\tunsigned short\twrite_hint;\n\t} dev[];  \n};\n\n \nstruct stripe_head_state {\n\t \n\tint syncing, expanding, expanded, replacing;\n\tint locked, uptodate, to_read, to_write, failed, written;\n\tint to_fill, compute, req_compute, non_overwrite;\n\tint injournal, just_cached;\n\tint failed_num[2];\n\tint p_failed, q_failed;\n\tint dec_preread_active;\n\tunsigned long ops_request;\n\n\tstruct md_rdev *blocked_rdev;\n\tint handle_bad_blocks;\n\tint log_failed;\n\tint waiting_extra_page;\n};\n\n \nenum r5dev_flags {\n\tR5_UPTODATE,\t \n\tR5_LOCKED,\t \n\tR5_DOUBLE_LOCKED, \n\tR5_OVERWRITE,\t \n \n\tR5_Insync,\t \n\tR5_Wantread,\t \n\tR5_Wantwrite,\n\tR5_Overlap,\t \n\tR5_ReadNoMerge,  \n\tR5_ReadError,\t \n\tR5_ReWrite,\t \n\n\tR5_Expanded,\t \n\tR5_Wantcompute,\t \n\tR5_Wantfill,\t \n\tR5_Wantdrain,\t \n\tR5_WantFUA,\t \n\tR5_SyncIO,\t \n\tR5_WriteError,\t \n\tR5_MadeGood,\t \n\tR5_ReadRepl,\t \n\tR5_MadeGoodRepl, \n\tR5_NeedReplace,\t \n\tR5_WantReplace,  \n\tR5_Discard,\t \n\tR5_SkipCopy,\t \n\tR5_InJournal,\t \n\tR5_OrigPageUPTDODATE,\t \n};\n\n \nenum {\n\tSTRIPE_ACTIVE,\n\tSTRIPE_HANDLE,\n\tSTRIPE_SYNC_REQUESTED,\n\tSTRIPE_SYNCING,\n\tSTRIPE_INSYNC,\n\tSTRIPE_REPLACED,\n\tSTRIPE_PREREAD_ACTIVE,\n\tSTRIPE_DELAYED,\n\tSTRIPE_DEGRADED,\n\tSTRIPE_BIT_DELAY,\n\tSTRIPE_EXPANDING,\n\tSTRIPE_EXPAND_SOURCE,\n\tSTRIPE_EXPAND_READY,\n\tSTRIPE_IO_STARTED,\t \n\tSTRIPE_FULL_WRITE,\t \n\tSTRIPE_BIOFILL_RUN,\n\tSTRIPE_COMPUTE_RUN,\n\tSTRIPE_ON_UNPLUG_LIST,\n\tSTRIPE_DISCARD,\n\tSTRIPE_ON_RELEASE_LIST,\n\tSTRIPE_BATCH_READY,\n\tSTRIPE_BATCH_ERR,\n\tSTRIPE_BITMAP_PENDING,\t \n\tSTRIPE_LOG_TRAPPED,\t \n\tSTRIPE_R5C_CACHING,\t \n\tSTRIPE_R5C_PARTIAL_STRIPE,\t \n\tSTRIPE_R5C_FULL_STRIPE,\t \n\tSTRIPE_R5C_PREFLUSH,\t \n};\n\n#define STRIPE_EXPAND_SYNC_FLAGS \\\n\t((1 << STRIPE_EXPAND_SOURCE) |\\\n\t(1 << STRIPE_EXPAND_READY) |\\\n\t(1 << STRIPE_EXPANDING) |\\\n\t(1 << STRIPE_SYNC_REQUESTED))\n \nenum {\n\tSTRIPE_OP_BIOFILL,\n\tSTRIPE_OP_COMPUTE_BLK,\n\tSTRIPE_OP_PREXOR,\n\tSTRIPE_OP_BIODRAIN,\n\tSTRIPE_OP_RECONSTRUCT,\n\tSTRIPE_OP_CHECK,\n\tSTRIPE_OP_PARTIAL_PARITY,\n};\n\n \nenum {\n\tPARITY_DISABLE_RMW = 0,\n\tPARITY_ENABLE_RMW,\n\tPARITY_PREFER_RMW,\n};\n\n \nenum {\n\tSYNDROME_SRC_ALL,\n\tSYNDROME_SRC_WANT_DRAIN,\n\tSYNDROME_SRC_WRITTEN,\n};\n \n\n \n\nstruct disk_info {\n\tstruct md_rdev\t__rcu *rdev;\n\tstruct md_rdev  __rcu *replacement;\n\tstruct page\t*extra_page;  \n};\n\n \n\n#define NR_STRIPES\t\t256\n\n#if PAGE_SIZE == DEFAULT_STRIPE_SIZE\n#define STRIPE_SIZE\t\tPAGE_SIZE\n#define STRIPE_SHIFT\t\t(PAGE_SHIFT - 9)\n#define STRIPE_SECTORS\t\t(STRIPE_SIZE>>9)\n#endif\n\n#define\tIO_THRESHOLD\t\t1\n#define BYPASS_THRESHOLD\t1\n#define NR_HASH\t\t\t(PAGE_SIZE / sizeof(struct hlist_head))\n#define HASH_MASK\t\t(NR_HASH - 1)\n#define MAX_STRIPE_BATCH\t8\n\n \n#define NR_STRIPE_HASH_LOCKS 8\n#define STRIPE_HASH_LOCKS_MASK (NR_STRIPE_HASH_LOCKS - 1)\n\nstruct r5worker {\n\tstruct work_struct work;\n\tstruct r5worker_group *group;\n\tstruct list_head temp_inactive_list[NR_STRIPE_HASH_LOCKS];\n\tbool working;\n};\n\nstruct r5worker_group {\n\tstruct list_head handle_list;\n\tstruct list_head loprio_list;\n\tstruct r5conf *conf;\n\tstruct r5worker *workers;\n\tint stripes_cnt;\n};\n\n \nenum r5c_journal_mode {\n\tR5C_JOURNAL_MODE_WRITE_THROUGH = 0,\n\tR5C_JOURNAL_MODE_WRITE_BACK = 1,\n};\n\nenum r5_cache_state {\n\tR5_INACTIVE_BLOCKED,\t \n\tR5_ALLOC_MORE,\t\t \n\tR5_DID_ALLOC,\t\t \n\tR5C_LOG_TIGHT,\t\t \n\tR5C_LOG_CRITICAL,\t \n\tR5C_EXTRA_PAGE_IN_USE,\t \n};\n\n#define PENDING_IO_MAX 512\n#define PENDING_IO_ONE_FLUSH 128\nstruct r5pending_data {\n\tstruct list_head sibling;\n\tsector_t sector;  \n\tstruct bio_list bios;\n};\n\nstruct raid5_percpu {\n\tstruct page\t*spare_page;  \n\tvoid\t\t*scribble;   \n\tint             scribble_obj_size;\n\tlocal_lock_t    lock;\n};\n\nstruct r5conf {\n\tstruct hlist_head\t*stripe_hashtbl;\n\t \n\tspinlock_t\t\thash_locks[NR_STRIPE_HASH_LOCKS];\n\tstruct mddev\t\t*mddev;\n\tint\t\t\tchunk_sectors;\n\tint\t\t\tlevel, algorithm, rmw_level;\n\tint\t\t\tmax_degraded;\n\tint\t\t\traid_disks;\n\tint\t\t\tmax_nr_stripes;\n\tint\t\t\tmin_nr_stripes;\n#if PAGE_SIZE != DEFAULT_STRIPE_SIZE\n\tunsigned long\tstripe_size;\n\tunsigned int\tstripe_shift;\n\tunsigned long\tstripe_sectors;\n#endif\n\n\t \n\tsector_t\t\treshape_progress;\n\t \n\tsector_t\t\treshape_safe;\n\tint\t\t\tprevious_raid_disks;\n\tint\t\t\tprev_chunk_sectors;\n\tint\t\t\tprev_algo;\n\tshort\t\t\tgeneration;  \n\tseqcount_spinlock_t\tgen_lock;\t \n\tunsigned long\t\treshape_checkpoint;  \n\tlong long\t\tmin_offset_diff;  \n\n\tstruct list_head\thandle_list;  \n\tstruct list_head\tloprio_list;  \n\tstruct list_head\thold_list;  \n\tstruct list_head\tdelayed_list;  \n\tstruct list_head\tbitmap_list;  \n\tstruct bio\t\t*retry_read_aligned;  \n\tunsigned int\t\tretry_read_offset;  \n\tstruct bio\t\t*retry_read_aligned_list;  \n\tatomic_t\t\tpreread_active_stripes;  \n\tatomic_t\t\tactive_aligned_reads;\n\tatomic_t\t\tpending_full_writes;  \n\tint\t\t\tbypass_count;  \n\tint\t\t\tbypass_threshold;  \n\tint\t\t\tskip_copy;  \n\tstruct list_head\t*last_hold;  \n\n\tatomic_t\t\treshape_stripes;  \n\t \n\tint\t\t\tactive_name;\n\tchar\t\t\tcache_name[2][32];\n\tstruct kmem_cache\t*slab_cache;  \n\tstruct mutex\t\tcache_size_mutex;  \n\n\tint\t\t\tseq_flush, seq_write;\n\tint\t\t\tquiesce;\n\n\tint\t\t\tfullsync;   \n\tint\t\t\trecovery_disabled;\n\t \n\tstruct raid5_percpu __percpu *percpu;\n\tint scribble_disks;\n\tint scribble_sectors;\n\tstruct hlist_node node;\n\n\t \n\tatomic_t\t\tactive_stripes;\n\tstruct list_head\tinactive_list[NR_STRIPE_HASH_LOCKS];\n\n\tatomic_t\t\tr5c_cached_full_stripes;\n\tstruct list_head\tr5c_full_stripe_list;\n\tatomic_t\t\tr5c_cached_partial_stripes;\n\tstruct list_head\tr5c_partial_stripe_list;\n\tatomic_t\t\tr5c_flushing_full_stripes;\n\tatomic_t\t\tr5c_flushing_partial_stripes;\n\n\tatomic_t\t\tempty_inactive_list_nr;\n\tstruct llist_head\treleased_stripes;\n\twait_queue_head_t\twait_for_quiescent;\n\twait_queue_head_t\twait_for_stripe;\n\twait_queue_head_t\twait_for_overlap;\n\tunsigned long\t\tcache_state;\n\tstruct shrinker\t\tshrinker;\n\tint\t\t\tpool_size;  \n\tspinlock_t\t\tdevice_lock;\n\tstruct disk_info\t*disks;\n\tstruct bio_set\t\tbio_split;\n\n\t \n\tstruct md_thread __rcu\t*thread;\n\tstruct list_head\ttemp_inactive_list[NR_STRIPE_HASH_LOCKS];\n\tstruct r5worker_group\t*worker_groups;\n\tint\t\t\tgroup_cnt;\n\tint\t\t\tworker_cnt_per_group;\n\tstruct r5l_log\t\t*log;\n\tvoid\t\t\t*log_private;\n\n\tspinlock_t\t\tpending_bios_lock;\n\tbool\t\t\tbatch_bio_dispatch;\n\tstruct r5pending_data\t*pending_data;\n\tstruct list_head\tfree_list;\n\tstruct list_head\tpending_list;\n\tint\t\t\tpending_data_cnt;\n\tstruct r5pending_data\t*next_pending_data;\n};\n\n#if PAGE_SIZE == DEFAULT_STRIPE_SIZE\n#define RAID5_STRIPE_SIZE(conf)\tSTRIPE_SIZE\n#define RAID5_STRIPE_SHIFT(conf)\tSTRIPE_SHIFT\n#define RAID5_STRIPE_SECTORS(conf)\tSTRIPE_SECTORS\n#else\n#define RAID5_STRIPE_SIZE(conf)\t((conf)->stripe_size)\n#define RAID5_STRIPE_SHIFT(conf)\t((conf)->stripe_shift)\n#define RAID5_STRIPE_SECTORS(conf)\t((conf)->stripe_sectors)\n#endif\n\n \nstatic inline struct bio *r5_next_bio(struct r5conf *conf, struct bio *bio, sector_t sector)\n{\n\tif (bio_end_sector(bio) < sector + RAID5_STRIPE_SECTORS(conf))\n\t\treturn bio->bi_next;\n\telse\n\t\treturn NULL;\n}\n\n \n#define ALGORITHM_LEFT_ASYMMETRIC\t0  \n#define ALGORITHM_RIGHT_ASYMMETRIC\t1  \n#define ALGORITHM_LEFT_SYMMETRIC\t2  \n#define ALGORITHM_RIGHT_SYMMETRIC\t3  \n\n \n#define ALGORITHM_PARITY_0\t\t4  \n#define ALGORITHM_PARITY_N\t\t5  \n\n \n\n#define ALGORITHM_ROTATING_ZERO_RESTART\t8  \n#define ALGORITHM_ROTATING_N_RESTART\t9  \n#define ALGORITHM_ROTATING_N_CONTINUE\t10  \n\n \n#define ALGORITHM_LEFT_ASYMMETRIC_6\t16\n#define ALGORITHM_RIGHT_ASYMMETRIC_6\t17\n#define ALGORITHM_LEFT_SYMMETRIC_6\t18\n#define ALGORITHM_RIGHT_SYMMETRIC_6\t19\n#define ALGORITHM_PARITY_0_6\t\t20\n#define ALGORITHM_PARITY_N_6\t\tALGORITHM_PARITY_N\n\nstatic inline int algorithm_valid_raid5(int layout)\n{\n\treturn (layout >= 0) &&\n\t\t(layout <= 5);\n}\nstatic inline int algorithm_valid_raid6(int layout)\n{\n\treturn (layout >= 0 && layout <= 5)\n\t\t||\n\t\t(layout >= 8 && layout <= 10)\n\t\t||\n\t\t(layout >= 16 && layout <= 20);\n}\n\nstatic inline int algorithm_is_DDF(int layout)\n{\n\treturn layout >= 8 && layout <= 10;\n}\n\n#if PAGE_SIZE != DEFAULT_STRIPE_SIZE\n \nstatic inline int raid5_get_page_offset(struct stripe_head *sh, int disk_idx)\n{\n\treturn (disk_idx % sh->stripes_per_page) * RAID5_STRIPE_SIZE(sh->raid_conf);\n}\n\n \nstatic inline struct page *\nraid5_get_dev_page(struct stripe_head *sh, int disk_idx)\n{\n\treturn sh->pages[disk_idx / sh->stripes_per_page];\n}\n#endif\n\nvoid md_raid5_kick_device(struct r5conf *conf);\nint raid5_set_cache_size(struct mddev *mddev, int size);\nsector_t raid5_compute_blocknr(struct stripe_head *sh, int i, int previous);\nvoid raid5_release_stripe(struct stripe_head *sh);\nsector_t raid5_compute_sector(struct r5conf *conf, sector_t r_sector,\n\t\tint previous, int *dd_idx, struct stripe_head *sh);\n\nstruct stripe_request_ctx;\n \n#define R5_GAS_PREVIOUS\t\t(1 << 0)\n \n#define R5_GAS_NOBLOCK\t\t(1 << 1)\n \n#define R5_GAS_NOQUIESCE\t(1 << 2)\nstruct stripe_head *raid5_get_active_stripe(struct r5conf *conf,\n\t\tstruct stripe_request_ctx *ctx, sector_t sector,\n\t\tunsigned int flags);\n\nint raid5_calc_degraded(struct r5conf *conf);\nint r5c_journal_mode_set(struct mddev *mddev, int journal_mode);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}