{
  "module_name": "dm-ps-service-time.c",
  "hash_id": "df78dacc6aafd10b83295eeed5fafa4c70196cba352c6fd81d1c9d516639451b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-ps-service-time.c",
  "human_readable_source": "\n \n\n#include \"dm.h\"\n#include \"dm-path-selector.h\"\n\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define DM_MSG_PREFIX\t\"multipath service-time\"\n#define ST_MIN_IO\t1\n#define ST_MAX_RELATIVE_THROUGHPUT\t100\n#define ST_MAX_RELATIVE_THROUGHPUT_SHIFT\t7\n#define ST_MAX_INFLIGHT_SIZE\t((size_t)-1 >> ST_MAX_RELATIVE_THROUGHPUT_SHIFT)\n#define ST_VERSION\t\"0.3.0\"\n\nstruct selector {\n\tstruct list_head valid_paths;\n\tstruct list_head failed_paths;\n\tspinlock_t lock;\n};\n\nstruct path_info {\n\tstruct list_head list;\n\tstruct dm_path *path;\n\tunsigned int repeat_count;\n\tunsigned int relative_throughput;\n\tatomic_t in_flight_size;\t \n};\n\nstatic struct selector *alloc_selector(void)\n{\n\tstruct selector *s = kmalloc(sizeof(*s), GFP_KERNEL);\n\n\tif (s) {\n\t\tINIT_LIST_HEAD(&s->valid_paths);\n\t\tINIT_LIST_HEAD(&s->failed_paths);\n\t\tspin_lock_init(&s->lock);\n\t}\n\n\treturn s;\n}\n\nstatic int st_create(struct path_selector *ps, unsigned int argc, char **argv)\n{\n\tstruct selector *s = alloc_selector();\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tps->context = s;\n\treturn 0;\n}\n\nstatic void free_paths(struct list_head *paths)\n{\n\tstruct path_info *pi, *next;\n\n\tlist_for_each_entry_safe(pi, next, paths, list) {\n\t\tlist_del(&pi->list);\n\t\tkfree(pi);\n\t}\n}\n\nstatic void st_destroy(struct path_selector *ps)\n{\n\tstruct selector *s = ps->context;\n\n\tfree_paths(&s->valid_paths);\n\tfree_paths(&s->failed_paths);\n\tkfree(s);\n\tps->context = NULL;\n}\n\nstatic int st_status(struct path_selector *ps, struct dm_path *path,\n\t\t     status_type_t type, char *result, unsigned int maxlen)\n{\n\tunsigned int sz = 0;\n\tstruct path_info *pi;\n\n\tif (!path)\n\t\tDMEMIT(\"0 \");\n\telse {\n\t\tpi = path->pscontext;\n\n\t\tswitch (type) {\n\t\tcase STATUSTYPE_INFO:\n\t\t\tDMEMIT(\"%d %u \", atomic_read(&pi->in_flight_size),\n\t\t\t       pi->relative_throughput);\n\t\t\tbreak;\n\t\tcase STATUSTYPE_TABLE:\n\t\t\tDMEMIT(\"%u %u \", pi->repeat_count,\n\t\t\t       pi->relative_throughput);\n\t\t\tbreak;\n\t\tcase STATUSTYPE_IMA:\n\t\t\tresult[0] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sz;\n}\n\nstatic int st_add_path(struct path_selector *ps, struct dm_path *path,\n\t\t       int argc, char **argv, char **error)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi;\n\tunsigned int repeat_count = ST_MIN_IO;\n\tunsigned int relative_throughput = 1;\n\tchar dummy;\n\tunsigned long flags;\n\n\t \n\tif (argc > 2) {\n\t\t*error = \"service-time ps: incorrect number of arguments\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (argc && (sscanf(argv[0], \"%u%c\", &repeat_count, &dummy) != 1)) {\n\t\t*error = \"service-time ps: invalid repeat count\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (repeat_count > 1) {\n\t\tDMWARN_LIMIT(\"repeat_count > 1 is deprecated, using 1 instead\");\n\t\trepeat_count = 1;\n\t}\n\n\tif ((argc == 2) &&\n\t    (sscanf(argv[1], \"%u%c\", &relative_throughput, &dummy) != 1 ||\n\t     relative_throughput > ST_MAX_RELATIVE_THROUGHPUT)) {\n\t\t*error = \"service-time ps: invalid relative_throughput value\";\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpi = kmalloc(sizeof(*pi), GFP_KERNEL);\n\tif (!pi) {\n\t\t*error = \"service-time ps: Error allocating path context\";\n\t\treturn -ENOMEM;\n\t}\n\n\tpi->path = path;\n\tpi->repeat_count = repeat_count;\n\tpi->relative_throughput = relative_throughput;\n\tatomic_set(&pi->in_flight_size, 0);\n\n\tpath->pscontext = pi;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tlist_add_tail(&pi->list, &s->valid_paths);\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn 0;\n}\n\nstatic void st_fail_path(struct path_selector *ps, struct dm_path *path)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = path->pscontext;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tlist_move(&pi->list, &s->failed_paths);\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nstatic int st_reinstate_path(struct path_selector *ps, struct dm_path *path)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = path->pscontext;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tlist_move_tail(&pi->list, &s->valid_paths);\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int st_compare_load(struct path_info *pi1, struct path_info *pi2,\n\t\t\t   size_t incoming)\n{\n\tsize_t sz1, sz2, st1, st2;\n\n\tsz1 = atomic_read(&pi1->in_flight_size);\n\tsz2 = atomic_read(&pi2->in_flight_size);\n\n\t \n\tif (pi1->relative_throughput == pi2->relative_throughput)\n\t\treturn sz1 - sz2;\n\n\t \n\tif (sz1 == sz2 ||\n\t    !pi1->relative_throughput || !pi2->relative_throughput)\n\t\treturn pi2->relative_throughput - pi1->relative_throughput;\n\n\t \n\tsz1 += incoming;\n\tsz2 += incoming;\n\tif (unlikely(sz1 >= ST_MAX_INFLIGHT_SIZE ||\n\t\t     sz2 >= ST_MAX_INFLIGHT_SIZE)) {\n\t\t \n\t\tsz1 >>= ST_MAX_RELATIVE_THROUGHPUT_SHIFT;\n\t\tsz2 >>= ST_MAX_RELATIVE_THROUGHPUT_SHIFT;\n\t}\n\tst1 = sz1 * pi2->relative_throughput;\n\tst2 = sz2 * pi1->relative_throughput;\n\tif (st1 != st2)\n\t\treturn st1 - st2;\n\n\t \n\treturn pi2->relative_throughput - pi1->relative_throughput;\n}\n\nstatic struct dm_path *st_select_path(struct path_selector *ps, size_t nr_bytes)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = NULL, *best = NULL;\n\tstruct dm_path *ret = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tif (list_empty(&s->valid_paths))\n\t\tgoto out;\n\n\tlist_for_each_entry(pi, &s->valid_paths, list)\n\t\tif (!best || (st_compare_load(pi, best, nr_bytes) < 0))\n\t\t\tbest = pi;\n\n\tif (!best)\n\t\tgoto out;\n\n\t \n\tlist_move_tail(&best->list, &s->valid_paths);\n\n\tret = best->path;\nout:\n\tspin_unlock_irqrestore(&s->lock, flags);\n\treturn ret;\n}\n\nstatic int st_start_io(struct path_selector *ps, struct dm_path *path,\n\t\t       size_t nr_bytes)\n{\n\tstruct path_info *pi = path->pscontext;\n\n\tatomic_add(nr_bytes, &pi->in_flight_size);\n\n\treturn 0;\n}\n\nstatic int st_end_io(struct path_selector *ps, struct dm_path *path,\n\t\t     size_t nr_bytes, u64 start_time)\n{\n\tstruct path_info *pi = path->pscontext;\n\n\tatomic_sub(nr_bytes, &pi->in_flight_size);\n\n\treturn 0;\n}\n\nstatic struct path_selector_type st_ps = {\n\t.name\t\t= \"service-time\",\n\t.module\t\t= THIS_MODULE,\n\t.table_args\t= 2,\n\t.info_args\t= 2,\n\t.create\t\t= st_create,\n\t.destroy\t= st_destroy,\n\t.status\t\t= st_status,\n\t.add_path\t= st_add_path,\n\t.fail_path\t= st_fail_path,\n\t.reinstate_path\t= st_reinstate_path,\n\t.select_path\t= st_select_path,\n\t.start_io\t= st_start_io,\n\t.end_io\t\t= st_end_io,\n};\n\nstatic int __init dm_st_init(void)\n{\n\tint r = dm_register_path_selector(&st_ps);\n\n\tif (r < 0)\n\t\tDMERR(\"register failed %d\", r);\n\n\tDMINFO(\"version \" ST_VERSION \" loaded\");\n\n\treturn r;\n}\n\nstatic void __exit dm_st_exit(void)\n{\n\tint r = dm_unregister_path_selector(&st_ps);\n\n\tif (r < 0)\n\t\tDMERR(\"unregister failed %d\", r);\n}\n\nmodule_init(dm_st_init);\nmodule_exit(dm_st_exit);\n\nMODULE_DESCRIPTION(DM_NAME \" throughput oriented path selector\");\nMODULE_AUTHOR(\"Kiyoshi Ueda <k-ueda@ct.jp.nec.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}