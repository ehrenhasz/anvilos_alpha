{
  "module_name": "dm-uevent.c",
  "hash_id": "7b71f394a7f2df0fe81c2aea616c8d03dd39a917cfb72e6a35e0dfa22ab2ab02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-uevent.c",
  "human_readable_source": "\n \n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kobject.h>\n#include <linux/dm-ioctl.h>\n#include <linux/export.h>\n\n#include \"dm.h\"\n#include \"dm-uevent.h\"\n\n#define DM_MSG_PREFIX \"uevent\"\n\nstatic const struct {\n\tenum dm_uevent_type type;\n\tenum kobject_action action;\n\tchar *name;\n} _dm_uevent_type_names[] = {\n\t{DM_UEVENT_PATH_FAILED, KOBJ_CHANGE, \"PATH_FAILED\"},\n\t{DM_UEVENT_PATH_REINSTATED, KOBJ_CHANGE, \"PATH_REINSTATED\"},\n};\n\nstatic struct kmem_cache *_dm_event_cache;\n\nstruct dm_uevent {\n\tstruct mapped_device *md;\n\tenum kobject_action action;\n\tstruct kobj_uevent_env ku_env;\n\tstruct list_head elist;\n\tchar name[DM_NAME_LEN];\n\tchar uuid[DM_UUID_LEN];\n};\n\nstatic void dm_uevent_free(struct dm_uevent *event)\n{\n\tkmem_cache_free(_dm_event_cache, event);\n}\n\nstatic struct dm_uevent *dm_uevent_alloc(struct mapped_device *md)\n{\n\tstruct dm_uevent *event;\n\n\tevent = kmem_cache_zalloc(_dm_event_cache, GFP_ATOMIC);\n\tif (!event)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&event->elist);\n\tevent->md = md;\n\n\treturn event;\n}\n\nstatic struct dm_uevent *dm_build_path_uevent(struct mapped_device *md,\n\t\t\t\t\t      struct dm_target *ti,\n\t\t\t\t\t      enum kobject_action action,\n\t\t\t\t\t      const char *dm_action,\n\t\t\t\t\t      const char *path,\n\t\t\t\t\t      unsigned int nr_valid_paths)\n{\n\tstruct dm_uevent *event;\n\n\tevent = dm_uevent_alloc(md);\n\tif (!event) {\n\t\tDMERR(\"%s: dm_uevent_alloc() failed\", __func__);\n\t\tgoto err_nomem;\n\t}\n\n\tevent->action = action;\n\n\tif (add_uevent_var(&event->ku_env, \"DM_TARGET=%s\", ti->type->name)) {\n\t\tDMERR(\"%s: add_uevent_var() for DM_TARGET failed\",\n\t\t      __func__);\n\t\tgoto err_add;\n\t}\n\n\tif (add_uevent_var(&event->ku_env, \"DM_ACTION=%s\", dm_action)) {\n\t\tDMERR(\"%s: add_uevent_var() for DM_ACTION failed\",\n\t\t      __func__);\n\t\tgoto err_add;\n\t}\n\n\tif (add_uevent_var(&event->ku_env, \"DM_SEQNUM=%u\",\n\t\t\t   dm_next_uevent_seq(md))) {\n\t\tDMERR(\"%s: add_uevent_var() for DM_SEQNUM failed\",\n\t\t      __func__);\n\t\tgoto err_add;\n\t}\n\n\tif (add_uevent_var(&event->ku_env, \"DM_PATH=%s\", path)) {\n\t\tDMERR(\"%s: add_uevent_var() for DM_PATH failed\", __func__);\n\t\tgoto err_add;\n\t}\n\n\tif (add_uevent_var(&event->ku_env, \"DM_NR_VALID_PATHS=%d\",\n\t\t\t   nr_valid_paths)) {\n\t\tDMERR(\"%s: add_uevent_var() for DM_NR_VALID_PATHS failed\",\n\t\t      __func__);\n\t\tgoto err_add;\n\t}\n\n\treturn event;\n\nerr_add:\n\tdm_uevent_free(event);\nerr_nomem:\n\treturn ERR_PTR(-ENOMEM);\n}\n\n \nvoid dm_send_uevents(struct list_head *events, struct kobject *kobj)\n{\n\tint r;\n\tstruct dm_uevent *event, *next;\n\n\tlist_for_each_entry_safe(event, next, events, elist) {\n\t\tlist_del_init(&event->elist);\n\n\t\t \n\t\tif (dm_copy_name_and_uuid(event->md, event->name,\n\t\t\t\t\t  event->uuid)) {\n\t\t\tDMINFO(\"%s: skipping sending uevent for lost device\",\n\t\t\t       __func__);\n\t\t\tgoto uevent_free;\n\t\t}\n\n\t\tif (add_uevent_var(&event->ku_env, \"DM_NAME=%s\", event->name)) {\n\t\t\tDMERR(\"%s: add_uevent_var() for DM_NAME failed\",\n\t\t\t      __func__);\n\t\t\tgoto uevent_free;\n\t\t}\n\n\t\tif (add_uevent_var(&event->ku_env, \"DM_UUID=%s\", event->uuid)) {\n\t\t\tDMERR(\"%s: add_uevent_var() for DM_UUID failed\",\n\t\t\t      __func__);\n\t\t\tgoto uevent_free;\n\t\t}\n\n\t\tr = kobject_uevent_env(kobj, event->action, event->ku_env.envp);\n\t\tif (r)\n\t\t\tDMERR(\"%s: kobject_uevent_env failed\", __func__);\nuevent_free:\n\t\tdm_uevent_free(event);\n\t}\n}\nEXPORT_SYMBOL_GPL(dm_send_uevents);\n\n \nvoid dm_path_uevent(enum dm_uevent_type event_type, struct dm_target *ti,\n\t\t   const char *path, unsigned int nr_valid_paths)\n{\n\tstruct mapped_device *md = dm_table_get_md(ti->table);\n\tstruct dm_uevent *event;\n\n\tif (event_type >= ARRAY_SIZE(_dm_uevent_type_names)) {\n\t\tDMERR(\"%s: Invalid event_type %d\", __func__, event_type);\n\t\treturn;\n\t}\n\n\tevent = dm_build_path_uevent(md, ti,\n\t\t\t\t     _dm_uevent_type_names[event_type].action,\n\t\t\t\t     _dm_uevent_type_names[event_type].name,\n\t\t\t\t     path, nr_valid_paths);\n\tif (IS_ERR(event))\n\t\treturn;\n\n\tdm_uevent_add(md, &event->elist);\n}\nEXPORT_SYMBOL_GPL(dm_path_uevent);\n\nint dm_uevent_init(void)\n{\n\t_dm_event_cache = KMEM_CACHE(dm_uevent, 0);\n\tif (!_dm_event_cache)\n\t\treturn -ENOMEM;\n\n\tDMINFO(\"version 1.0.3\");\n\n\treturn 0;\n}\n\nvoid dm_uevent_exit(void)\n{\n\tkmem_cache_destroy(_dm_event_cache);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}