{
  "module_name": "util.c",
  "hash_id": "edbe9830b5c887c33d09eae2a3339165ea6128d9e18c3d4d73535a5edc8ee0a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/bcache/util.c",
  "human_readable_source": "\n \n\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched/clock.h>\n\n#include \"util.h\"\n\n#define simple_strtoint(c, end, base)\tsimple_strtol(c, end, base)\n#define simple_strtouint(c, end, base)\tsimple_strtoul(c, end, base)\n\n#define STRTO_H(name, type)\t\t\t\t\t\\\nint bch_ ## name ## _h(const char *cp, type *res)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tint u = 0;\t\t\t\t\t\t\\\n\tchar *e;\t\t\t\t\t\t\\\n\ttype i = simple_ ## name(cp, &e, 10);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tswitch (tolower(*e)) {\t\t\t\t\t\\\n\tdefault:\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\\\n\tcase 'y':\t\t\t\t\t\t\\\n\tcase 'z':\t\t\t\t\t\t\\\n\t\tu++;\t\t\t\t\t\t\\\n\t\tfallthrough;\t\t\t\t\t\\\n\tcase 'e':\t\t\t\t\t\t\\\n\t\tu++;\t\t\t\t\t\t\\\n\t\tfallthrough;\t\t\t\t\t\\\n\tcase 'p':\t\t\t\t\t\t\\\n\t\tu++;\t\t\t\t\t\t\\\n\t\tfallthrough;\t\t\t\t\t\\\n\tcase 't':\t\t\t\t\t\t\\\n\t\tu++;\t\t\t\t\t\t\\\n\t\tfallthrough;\t\t\t\t\t\\\n\tcase 'g':\t\t\t\t\t\t\\\n\t\tu++;\t\t\t\t\t\t\\\n\t\tfallthrough;\t\t\t\t\t\\\n\tcase 'm':\t\t\t\t\t\t\\\n\t\tu++;\t\t\t\t\t\t\\\n\t\tfallthrough;\t\t\t\t\t\\\n\tcase 'k':\t\t\t\t\t\t\\\n\t\tu++;\t\t\t\t\t\t\\\n\t\tif (e++ == cp)\t\t\t\t\t\\\n\t\t\treturn -EINVAL;\t\t\t\t\\\n\t\tfallthrough;\t\t\t\t\t\\\n\tcase '\\n':\t\t\t\t\t\t\\\n\tcase '\\0':\t\t\t\t\t\t\\\n\t\tif (*e == '\\n')\t\t\t\t\t\\\n\t\t\te++;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (*e)\t\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\twhile (u--) {\t\t\t\t\t\t\\\n\t\tif ((type) ~0 > 0 &&\t\t\t\t\\\n\t\t    (type) ~0 / 1024 <= i)\t\t\t\\\n\t\t\treturn -EINVAL;\t\t\t\t\\\n\t\tif ((i > 0 && ANYSINT_MAX(type) / 1024 < i) ||\t\\\n\t\t    (i < 0 && -ANYSINT_MAX(type) / 1024 > i))\t\\\n\t\t\treturn -EINVAL;\t\t\t\t\\\n\t\ti *= 1024;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t*res = i;\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\n\nSTRTO_H(strtoint, int)\nSTRTO_H(strtouint, unsigned int)\nSTRTO_H(strtoll, long long)\nSTRTO_H(strtoull, unsigned long long)\n\n \nssize_t bch_hprint(char *buf, int64_t v)\n{\n\tstatic const char units[] = \"?kMGTPEZY\";\n\tint u = 0, t;\n\n\tuint64_t q;\n\n\tif (v < 0)\n\t\tq = -v;\n\telse\n\t\tq = v;\n\n\t \n\tdo {\n\t\tu++;\n\n\t\tt = q & ~(~0 << 10);\n\t\tq >>= 10;\n\t} while (q >= 1000);\n\n\tif (v < 0)\n\t\t \n\t\treturn sprintf(buf, \"-%llu.%i%c\", q, t * 10 / 1024, units[u]);\n\telse\n\t\treturn sprintf(buf, \"%llu.%i%c\", q, t * 10 / 1024, units[u]);\n}\n\nbool bch_is_zero(const char *p, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++)\n\t\tif (p[i])\n\t\t\treturn false;\n\treturn true;\n}\n\nint bch_parse_uuid(const char *s, char *uuid)\n{\n\tsize_t i, j, x;\n\n\tmemset(uuid, 0, 16);\n\n\tfor (i = 0, j = 0;\n\t     i < strspn(s, \"-0123456789:ABCDEFabcdef\") && j < 32;\n\t     i++) {\n\t\tx = s[i] | 32;\n\n\t\tswitch (x) {\n\t\tcase '0'...'9':\n\t\t\tx -= '0';\n\t\t\tbreak;\n\t\tcase 'a'...'f':\n\t\t\tx -= 'a' - 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(j & 1))\n\t\t\tx <<= 4;\n\t\tuuid[j++ >> 1] |= x;\n\t}\n\treturn i;\n}\n\nvoid bch_time_stats_update(struct time_stats *stats, uint64_t start_time)\n{\n\tuint64_t now, duration, last;\n\n\tspin_lock(&stats->lock);\n\n\tnow\t\t= local_clock();\n\tduration\t= time_after64(now, start_time)\n\t\t? now - start_time : 0;\n\tlast\t\t= time_after64(now, stats->last)\n\t\t? now - stats->last : 0;\n\n\tstats->max_duration = max(stats->max_duration, duration);\n\n\tif (stats->last) {\n\t\tewma_add(stats->average_duration, duration, 8, 8);\n\n\t\tif (stats->average_frequency)\n\t\t\tewma_add(stats->average_frequency, last, 8, 8);\n\t\telse\n\t\t\tstats->average_frequency  = last << 8;\n\t} else {\n\t\tstats->average_duration  = duration << 8;\n\t}\n\n\tstats->last = now ?: 1;\n\n\tspin_unlock(&stats->lock);\n}\n\n \nuint64_t bch_next_delay(struct bch_ratelimit *d, uint64_t done)\n{\n\tuint64_t now = local_clock();\n\n\td->next += div_u64(done * NSEC_PER_SEC, atomic_long_read(&d->rate));\n\n\t \n\tif (time_before64(now + NSEC_PER_SEC * 5LLU / 2LLU, d->next))\n\t\td->next = now + NSEC_PER_SEC * 5LLU / 2LLU;\n\n\tif (time_after64(now - NSEC_PER_SEC * 2, d->next))\n\t\td->next = now - NSEC_PER_SEC * 2;\n\n\treturn time_after64(d->next, now)\n\t\t? div_u64(d->next - now, NSEC_PER_SEC / HZ)\n\t\t: 0;\n}\n\n \nvoid bch_bio_map(struct bio *bio, void *base)\n{\n\tsize_t size = bio->bi_iter.bi_size;\n\tstruct bio_vec *bv = bio->bi_io_vec;\n\n\tBUG_ON(!bio->bi_iter.bi_size);\n\tBUG_ON(bio->bi_vcnt);\n\n\tbv->bv_offset = base ? offset_in_page(base) : 0;\n\tgoto start;\n\n\tfor (; size; bio->bi_vcnt++, bv++) {\n\t\tbv->bv_offset\t= 0;\nstart:\t\tbv->bv_len\t= min_t(size_t, PAGE_SIZE - bv->bv_offset,\n\t\t\t\t\tsize);\n\t\tif (base) {\n\t\t\tbv->bv_page = is_vmalloc_addr(base)\n\t\t\t\t? vmalloc_to_page(base)\n\t\t\t\t: virt_to_page(base);\n\n\t\t\tbase += bv->bv_len;\n\t\t}\n\n\t\tsize -= bv->bv_len;\n\t}\n}\n\n \nint bch_bio_alloc_pages(struct bio *bio, gfp_t gfp_mask)\n{\n\tint i;\n\tstruct bio_vec *bv;\n\n\t \n\tfor (i = 0, bv = bio->bi_io_vec; i < bio->bi_vcnt; bv++, i++) {\n\t\tbv->bv_page = alloc_page(gfp_mask);\n\t\tif (!bv->bv_page) {\n\t\t\twhile (--bv >= bio->bi_io_vec)\n\t\t\t\t__free_page(bv->bv_page);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}