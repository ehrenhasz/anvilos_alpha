{
  "module_name": "stats.c",
  "hash_id": "357e41f62172badde70832bd9859cf6df48c41423d3500e4ffb54215882f9e73",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/bcache/stats.c",
  "human_readable_source": "\n \n\n#include \"bcache.h\"\n#include \"stats.h\"\n#include \"btree.h\"\n#include \"sysfs.h\"\n\n \n\nstatic const unsigned int DAY_RESCALE\t\t= 288;\nstatic const unsigned int HOUR_RESCALE\t\t= 12;\nstatic const unsigned int FIVE_MINUTE_RESCALE\t= 1;\nstatic const unsigned int accounting_delay\t= (HZ * 300) / 22;\nstatic const unsigned int accounting_weight\t= 32;\n\n \n\nread_attribute(cache_hits);\nread_attribute(cache_misses);\nread_attribute(cache_bypass_hits);\nread_attribute(cache_bypass_misses);\nread_attribute(cache_hit_ratio);\nread_attribute(cache_miss_collisions);\nread_attribute(bypassed);\n\nSHOW(bch_stats)\n{\n\tstruct cache_stats *s =\n\t\tcontainer_of(kobj, struct cache_stats, kobj);\n#define var(stat)\t\t(s->stat >> 16)\n\tvar_print(cache_hits);\n\tvar_print(cache_misses);\n\tvar_print(cache_bypass_hits);\n\tvar_print(cache_bypass_misses);\n\n\tsysfs_print(cache_hit_ratio,\n\t\t    DIV_SAFE(var(cache_hits) * 100,\n\t\t\t     var(cache_hits) + var(cache_misses)));\n\n\tvar_print(cache_miss_collisions);\n\tsysfs_hprint(bypassed,\tvar(sectors_bypassed) << 9);\n#undef var\n\treturn 0;\n}\n\nSTORE(bch_stats)\n{\n\treturn size;\n}\n\nstatic void bch_stats_release(struct kobject *k)\n{\n}\n\nstatic struct attribute *bch_stats_attrs[] = {\n\t&sysfs_cache_hits,\n\t&sysfs_cache_misses,\n\t&sysfs_cache_bypass_hits,\n\t&sysfs_cache_bypass_misses,\n\t&sysfs_cache_hit_ratio,\n\t&sysfs_cache_miss_collisions,\n\t&sysfs_bypassed,\n\tNULL\n};\nATTRIBUTE_GROUPS(bch_stats);\nstatic KTYPE(bch_stats);\n\nint bch_cache_accounting_add_kobjs(struct cache_accounting *acc,\n\t\t\t\t   struct kobject *parent)\n{\n\tint ret = kobject_add(&acc->total.kobj, parent,\n\t\t\t      \"stats_total\");\n\tret = ret ?: kobject_add(&acc->five_minute.kobj, parent,\n\t\t\t\t \"stats_five_minute\");\n\tret = ret ?: kobject_add(&acc->hour.kobj, parent,\n\t\t\t\t \"stats_hour\");\n\tret = ret ?: kobject_add(&acc->day.kobj, parent,\n\t\t\t\t \"stats_day\");\n\treturn ret;\n}\n\nvoid bch_cache_accounting_clear(struct cache_accounting *acc)\n{\n\tacc->total.cache_hits = 0;\n\tacc->total.cache_misses = 0;\n\tacc->total.cache_bypass_hits = 0;\n\tacc->total.cache_bypass_misses = 0;\n\tacc->total.cache_miss_collisions = 0;\n\tacc->total.sectors_bypassed = 0;\n}\n\nvoid bch_cache_accounting_destroy(struct cache_accounting *acc)\n{\n\tkobject_put(&acc->total.kobj);\n\tkobject_put(&acc->five_minute.kobj);\n\tkobject_put(&acc->hour.kobj);\n\tkobject_put(&acc->day.kobj);\n\n\tatomic_set(&acc->closing, 1);\n\tif (del_timer_sync(&acc->timer))\n\t\tclosure_return(&acc->cl);\n}\n\n \n\nstatic void scale_stat(unsigned long *stat)\n{\n\t*stat =  ewma_add(*stat, 0, accounting_weight, 0);\n}\n\nstatic void scale_stats(struct cache_stats *stats, unsigned long rescale_at)\n{\n\tif (++stats->rescale == rescale_at) {\n\t\tstats->rescale = 0;\n\t\tscale_stat(&stats->cache_hits);\n\t\tscale_stat(&stats->cache_misses);\n\t\tscale_stat(&stats->cache_bypass_hits);\n\t\tscale_stat(&stats->cache_bypass_misses);\n\t\tscale_stat(&stats->cache_miss_collisions);\n\t\tscale_stat(&stats->sectors_bypassed);\n\t}\n}\n\nstatic void scale_accounting(struct timer_list *t)\n{\n\tstruct cache_accounting *acc = from_timer(acc, t, timer);\n\n#define move_stat(name) do {\t\t\t\t\t\t\\\n\tunsigned int t = atomic_xchg(&acc->collector.name, 0);\t\t\\\n\tt <<= 16;\t\t\t\t\t\t\t\\\n\tacc->five_minute.name += t;\t\t\t\t\t\\\n\tacc->hour.name += t;\t\t\t\t\t\t\\\n\tacc->day.name += t;\t\t\t\t\t\t\\\n\tacc->total.name += t;\t\t\t\t\t\t\\\n} while (0)\n\n\tmove_stat(cache_hits);\n\tmove_stat(cache_misses);\n\tmove_stat(cache_bypass_hits);\n\tmove_stat(cache_bypass_misses);\n\tmove_stat(cache_miss_collisions);\n\tmove_stat(sectors_bypassed);\n\n\tscale_stats(&acc->total, 0);\n\tscale_stats(&acc->day, DAY_RESCALE);\n\tscale_stats(&acc->hour, HOUR_RESCALE);\n\tscale_stats(&acc->five_minute, FIVE_MINUTE_RESCALE);\n\n\tacc->timer.expires += accounting_delay;\n\n\tif (!atomic_read(&acc->closing))\n\t\tadd_timer(&acc->timer);\n\telse\n\t\tclosure_return(&acc->cl);\n}\n\nstatic void mark_cache_stats(struct cache_stat_collector *stats,\n\t\t\t     bool hit, bool bypass)\n{\n\tif (!bypass)\n\t\tif (hit)\n\t\t\tatomic_inc(&stats->cache_hits);\n\t\telse\n\t\t\tatomic_inc(&stats->cache_misses);\n\telse\n\t\tif (hit)\n\t\t\tatomic_inc(&stats->cache_bypass_hits);\n\t\telse\n\t\t\tatomic_inc(&stats->cache_bypass_misses);\n}\n\nvoid bch_mark_cache_accounting(struct cache_set *c, struct bcache_device *d,\n\t\t\t       bool hit, bool bypass)\n{\n\tstruct cached_dev *dc = container_of(d, struct cached_dev, disk);\n\n\tmark_cache_stats(&dc->accounting.collector, hit, bypass);\n\tmark_cache_stats(&c->accounting.collector, hit, bypass);\n}\n\nvoid bch_mark_cache_miss_collision(struct cache_set *c, struct bcache_device *d)\n{\n\tstruct cached_dev *dc = container_of(d, struct cached_dev, disk);\n\n\tatomic_inc(&dc->accounting.collector.cache_miss_collisions);\n\tatomic_inc(&c->accounting.collector.cache_miss_collisions);\n}\n\nvoid bch_mark_sectors_bypassed(struct cache_set *c, struct cached_dev *dc,\n\t\t\t       int sectors)\n{\n\tatomic_add(sectors, &dc->accounting.collector.sectors_bypassed);\n\tatomic_add(sectors, &c->accounting.collector.sectors_bypassed);\n}\n\nvoid bch_cache_accounting_init(struct cache_accounting *acc,\n\t\t\t       struct closure *parent)\n{\n\tkobject_init(&acc->total.kobj,\t\t&bch_stats_ktype);\n\tkobject_init(&acc->five_minute.kobj,\t&bch_stats_ktype);\n\tkobject_init(&acc->hour.kobj,\t\t&bch_stats_ktype);\n\tkobject_init(&acc->day.kobj,\t\t&bch_stats_ktype);\n\n\tclosure_init(&acc->cl, parent);\n\ttimer_setup(&acc->timer, scale_accounting, 0);\n\tacc->timer.expires\t= jiffies + accounting_delay;\n\tadd_timer(&acc->timer);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}