{
  "module_name": "bcache_ondisk.h",
  "hash_id": "7743f18a3ecd452f4d43509126938ac6a48f10755dd4015d173f2ffbd28917f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/bcache/bcache_ondisk.h",
  "human_readable_source": " \n#ifndef _LINUX_BCACHE_H\n#define _LINUX_BCACHE_H\n\n \n\n#include <linux/types.h>\n\n#define BITMASK(name, type, field, offset, size)\t\t\\\nstatic inline __u64 name(const type *k)\t\t\t\t\\\n{ return (k->field >> offset) & ~(~0ULL << size); }\t\t\\\n\t\t\t\t\t\t\t\t\\\nstatic inline void SET_##name(type *k, __u64 v)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tk->field &= ~(~(~0ULL << size) << offset);\t\t\\\n\tk->field |= (v & ~(~0ULL << size)) << offset;\t\t\\\n}\n\n \n\nstruct bkey {\n\t__u64\thigh;\n\t__u64\tlow;\n\t__u64\tptr[];\n};\n\n#define KEY_FIELD(name, field, offset, size)\t\t\t\t\\\n\tBITMASK(name, struct bkey, field, offset, size)\n\n#define PTR_FIELD(name, offset, size)\t\t\t\t\t\\\nstatic inline __u64 name(const struct bkey *k, unsigned int i)\t\t\\\n{ return (k->ptr[i] >> offset) & ~(~0ULL << size); }\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic inline void SET_##name(struct bkey *k, unsigned int i, __u64 v)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tk->ptr[i] &= ~(~(~0ULL << size) << offset);\t\t\t\\\n\tk->ptr[i] |= (v & ~(~0ULL << size)) << offset;\t\t\t\\\n}\n\n#define KEY_SIZE_BITS\t\t16\n#define KEY_MAX_U64S\t\t8\n\nKEY_FIELD(KEY_PTRS,\thigh, 60, 3)\nKEY_FIELD(__PAD0,\thigh, 58, 2)\nKEY_FIELD(KEY_CSUM,\thigh, 56, 2)\nKEY_FIELD(__PAD1,\thigh, 55, 1)\nKEY_FIELD(KEY_DIRTY,\thigh, 36, 1)\n\nKEY_FIELD(KEY_SIZE,\thigh, 20, KEY_SIZE_BITS)\nKEY_FIELD(KEY_INODE,\thigh, 0,  20)\n\n \n\nstatic inline __u64 KEY_OFFSET(const struct bkey *k)\n{\n\treturn k->low;\n}\n\nstatic inline void SET_KEY_OFFSET(struct bkey *k, __u64 v)\n{\n\tk->low = v;\n}\n\n \n#define KEY(inode, offset, size)\t\t\t\t\t\\\n((struct bkey) {\t\t\t\t\t\t\t\\\n\t.high = (1ULL << 63) | ((__u64) (size) << 20) | (inode),\t\\\n\t.low = (offset)\t\t\t\t\t\t\t\\\n})\n\n#define ZERO_KEY\t\t\tKEY(0, 0, 0)\n\n#define MAX_KEY_INODE\t\t\t(~(~0 << 20))\n#define MAX_KEY_OFFSET\t\t\t(~0ULL >> 1)\n#define MAX_KEY\t\t\t\tKEY(MAX_KEY_INODE, MAX_KEY_OFFSET, 0)\n\n#define KEY_START(k)\t\t\t(KEY_OFFSET(k) - KEY_SIZE(k))\n#define START_KEY(k)\t\t\tKEY(KEY_INODE(k), KEY_START(k), 0)\n\n#define PTR_DEV_BITS\t\t\t12\n\nPTR_FIELD(PTR_DEV,\t\t\t51, PTR_DEV_BITS)\nPTR_FIELD(PTR_OFFSET,\t\t\t8,  43)\nPTR_FIELD(PTR_GEN,\t\t\t0,  8)\n\n#define PTR_CHECK_DEV\t\t\t((1 << PTR_DEV_BITS) - 1)\n\n#define MAKE_PTR(gen, offset, dev)\t\t\t\t\t\\\n\t((((__u64) dev) << 51) | ((__u64) offset) << 8 | gen)\n\n \n\nstatic inline unsigned long bkey_u64s(const struct bkey *k)\n{\n\treturn (sizeof(struct bkey) / sizeof(__u64)) + KEY_PTRS(k);\n}\n\nstatic inline unsigned long bkey_bytes(const struct bkey *k)\n{\n\treturn bkey_u64s(k) * sizeof(__u64);\n}\n\n#define bkey_copy(_dest, _src)\tunsafe_memcpy(_dest, _src, bkey_bytes(_src), \\\n\t\t\t\t\t )\n\nstatic inline void bkey_copy_key(struct bkey *dest, const struct bkey *src)\n{\n\tSET_KEY_INODE(dest, KEY_INODE(src));\n\tSET_KEY_OFFSET(dest, KEY_OFFSET(src));\n}\n\nstatic inline struct bkey *bkey_next(const struct bkey *k)\n{\n\t__u64 *d = (void *) k;\n\n\treturn (struct bkey *) (d + bkey_u64s(k));\n}\n\nstatic inline struct bkey *bkey_idx(const struct bkey *k, unsigned int nr_keys)\n{\n\t__u64 *d = (void *) k;\n\n\treturn (struct bkey *) (d + nr_keys);\n}\n \n#define BKEY_PAD\t\t8\n\n#define BKEY_PADDED(key)\t\t\t\t\t\\\n\tunion { struct bkey key; __u64 key ## _pad[BKEY_PAD]; }\n\n \n\n \n#define BCACHE_SB_VERSION_CDEV\t\t\t0\n#define BCACHE_SB_VERSION_BDEV\t\t\t1\n#define BCACHE_SB_VERSION_CDEV_WITH_UUID\t3\n#define BCACHE_SB_VERSION_BDEV_WITH_OFFSET\t4\n#define BCACHE_SB_VERSION_CDEV_WITH_FEATURES\t5\n#define BCACHE_SB_VERSION_BDEV_WITH_FEATURES\t6\n#define BCACHE_SB_MAX_VERSION\t\t\t6\n\n#define SB_SECTOR\t\t\t8\n#define SB_OFFSET\t\t\t(SB_SECTOR << SECTOR_SHIFT)\n#define SB_SIZE\t\t\t\t4096\n#define SB_LABEL_SIZE\t\t\t32\n#define SB_JOURNAL_BUCKETS\t\t256U\n \n#define MAX_CACHES_PER_SET\t\t8\n\n#define BDEV_DATA_START_DEFAULT\t\t16\t \n\nstruct cache_sb_disk {\n\t__le64\t\t\tcsum;\n\t__le64\t\t\toffset;\t \n\t__le64\t\t\tversion;\n\n\t__u8\t\t\tmagic[16];\n\n\t__u8\t\t\tuuid[16];\n\tunion {\n\t\t__u8\t\tset_uuid[16];\n\t\t__le64\t\tset_magic;\n\t};\n\t__u8\t\t\tlabel[SB_LABEL_SIZE];\n\n\t__le64\t\t\tflags;\n\t__le64\t\t\tseq;\n\n\t__le64\t\t\tfeature_compat;\n\t__le64\t\t\tfeature_incompat;\n\t__le64\t\t\tfeature_ro_compat;\n\n\t__le64\t\t\tpad[5];\n\n\tunion {\n\tstruct {\n\t\t \n\t\t__le64\t\tnbuckets;\t \n\n\t\t__le16\t\tblock_size;\t \n\t\t__le16\t\tbucket_size;\t \n\n\t\t__le16\t\tnr_in_set;\n\t\t__le16\t\tnr_this_dev;\n\t};\n\tstruct {\n\t\t \n\t\t__le64\t\tdata_offset;\n\n\t\t \n\t};\n\t};\n\n\t__le32\t\t\tlast_mount;\t \n\n\t__le16\t\t\tfirst_bucket;\n\tunion {\n\t\t__le16\t\tnjournal_buckets;\n\t\t__le16\t\tkeys;\n\t};\n\t__le64\t\t\td[SB_JOURNAL_BUCKETS];\t \n\t__le16\t\t\tobso_bucket_size_hi;\t \n};\n\n \nstruct cache_sb {\n\t__u64\t\t\toffset;\t \n\t__u64\t\t\tversion;\n\n\t__u8\t\t\tmagic[16];\n\n\t__u8\t\t\tuuid[16];\n\tunion {\n\t\t__u8\t\tset_uuid[16];\n\t\t__u64\t\tset_magic;\n\t};\n\t__u8\t\t\tlabel[SB_LABEL_SIZE];\n\n\t__u64\t\t\tflags;\n\t__u64\t\t\tseq;\n\n\t__u64\t\t\tfeature_compat;\n\t__u64\t\t\tfeature_incompat;\n\t__u64\t\t\tfeature_ro_compat;\n\n\tunion {\n\tstruct {\n\t\t \n\t\t__u64\t\tnbuckets;\t \n\n\t\t__u16\t\tblock_size;\t \n\t\t__u16\t\tnr_in_set;\n\t\t__u16\t\tnr_this_dev;\n\t\t__u32\t\tbucket_size;\t \n\t};\n\tstruct {\n\t\t \n\t\t__u64\t\tdata_offset;\n\n\t\t \n\t};\n\t};\n\n\t__u32\t\t\tlast_mount;\t \n\n\t__u16\t\t\tfirst_bucket;\n\tunion {\n\t\t__u16\t\tnjournal_buckets;\n\t\t__u16\t\tkeys;\n\t};\n\t__u64\t\t\td[SB_JOURNAL_BUCKETS];\t \n};\n\nstatic inline _Bool SB_IS_BDEV(const struct cache_sb *sb)\n{\n\treturn sb->version == BCACHE_SB_VERSION_BDEV\n\t\t|| sb->version == BCACHE_SB_VERSION_BDEV_WITH_OFFSET\n\t\t|| sb->version == BCACHE_SB_VERSION_BDEV_WITH_FEATURES;\n}\n\nBITMASK(CACHE_SYNC,\t\t\tstruct cache_sb, flags, 0, 1);\nBITMASK(CACHE_DISCARD,\t\t\tstruct cache_sb, flags, 1, 1);\nBITMASK(CACHE_REPLACEMENT,\t\tstruct cache_sb, flags, 2, 3);\n#define CACHE_REPLACEMENT_LRU\t\t0U\n#define CACHE_REPLACEMENT_FIFO\t\t1U\n#define CACHE_REPLACEMENT_RANDOM\t2U\n\nBITMASK(BDEV_CACHE_MODE,\t\tstruct cache_sb, flags, 0, 4);\n#define CACHE_MODE_WRITETHROUGH\t\t0U\n#define CACHE_MODE_WRITEBACK\t\t1U\n#define CACHE_MODE_WRITEAROUND\t\t2U\n#define CACHE_MODE_NONE\t\t\t3U\nBITMASK(BDEV_STATE,\t\t\tstruct cache_sb, flags, 61, 2);\n#define BDEV_STATE_NONE\t\t\t0U\n#define BDEV_STATE_CLEAN\t\t1U\n#define BDEV_STATE_DIRTY\t\t2U\n#define BDEV_STATE_STALE\t\t3U\n\n \n\n#define JSET_MAGIC\t\t\t0x245235c1a3625032ULL\n#define PSET_MAGIC\t\t\t0x6750e15f87337f91ULL\n#define BSET_MAGIC\t\t\t0x90135c78b99e07f5ULL\n\nstatic inline __u64 jset_magic(struct cache_sb *sb)\n{\n\treturn sb->set_magic ^ JSET_MAGIC;\n}\n\nstatic inline __u64 pset_magic(struct cache_sb *sb)\n{\n\treturn sb->set_magic ^ PSET_MAGIC;\n}\n\nstatic inline __u64 bset_magic(struct cache_sb *sb)\n{\n\treturn sb->set_magic ^ BSET_MAGIC;\n}\n\n \n\n#define BCACHE_JSET_VERSION_UUIDv1\t1\n#define BCACHE_JSET_VERSION_UUID\t1\t \n#define BCACHE_JSET_VERSION\t\t1\n\nstruct jset {\n\t__u64\t\t\tcsum;\n\t__u64\t\t\tmagic;\n\t__u64\t\t\tseq;\n\t__u32\t\t\tversion;\n\t__u32\t\t\tkeys;\n\n\t__u64\t\t\tlast_seq;\n\n\tBKEY_PADDED(uuid_bucket);\n\tBKEY_PADDED(btree_root);\n\t__u16\t\t\tbtree_level;\n\t__u16\t\t\tpad[3];\n\n\t__u64\t\t\tprio_bucket[MAX_CACHES_PER_SET];\n\n\tunion {\n\t\tDECLARE_FLEX_ARRAY(struct bkey, start);\n\t\tDECLARE_FLEX_ARRAY(__u64, d);\n\t};\n};\n\n \n\nstruct prio_set {\n\t__u64\t\t\tcsum;\n\t__u64\t\t\tmagic;\n\t__u64\t\t\tseq;\n\t__u32\t\t\tversion;\n\t__u32\t\t\tpad;\n\n\t__u64\t\t\tnext_bucket;\n\n\tstruct bucket_disk {\n\t\t__u16\t\tprio;\n\t\t__u8\t\tgen;\n\t} __attribute((packed)) data[];\n};\n\n \n\nstruct uuid_entry {\n\tunion {\n\t\tstruct {\n\t\t\t__u8\tuuid[16];\n\t\t\t__u8\tlabel[32];\n\t\t\t__u32\tfirst_reg;  \n\t\t\t__u32\tlast_reg;\n\t\t\t__u32\tinvalidated;\n\n\t\t\t__u32\tflags;\n\t\t\t \n\t\t\t__u64\tsectors;\n\t\t};\n\n\t\t__u8\t\tpad[128];\n\t};\n};\n\nBITMASK(UUID_FLASH_ONLY,\tstruct uuid_entry, flags, 0, 1);\n\n \n\n \n#define BCACHE_BSET_CSUM\t\t1\n#define BCACHE_BSET_VERSION\t\t1\n\n \nstruct bset {\n\t__u64\t\t\tcsum;\n\t__u64\t\t\tmagic;\n\t__u64\t\t\tseq;\n\t__u32\t\t\tversion;\n\t__u32\t\t\tkeys;\n\n\tunion {\n\t\tDECLARE_FLEX_ARRAY(struct bkey, start);\n\t\tDECLARE_FLEX_ARRAY(__u64, d);\n\t};\n};\n\n \n\n \n\nstruct uuid_entry_v0 {\n\t__u8\t\tuuid[16];\n\t__u8\t\tlabel[32];\n\t__u32\t\tfirst_reg;\n\t__u32\t\tlast_reg;\n\t__u32\t\tinvalidated;\n\t__u32\t\tpad;\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}