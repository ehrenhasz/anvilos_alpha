{
  "module_name": "closure.h",
  "hash_id": "d1a7b7f6bd1a007a1ed92475655cd730be92ffa5a5c71bc531e42da0a960b768",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/bcache/closure.h",
  "human_readable_source": " \n#ifndef _LINUX_CLOSURE_H\n#define _LINUX_CLOSURE_H\n\n#include <linux/llist.h>\n#include <linux/sched.h>\n#include <linux/sched/task_stack.h>\n#include <linux/workqueue.h>\n\n \n\nstruct closure;\nstruct closure_syncer;\ntypedef void (closure_fn) (struct closure *);\nextern struct dentry *bcache_debug;\n\nstruct closure_waitlist {\n\tstruct llist_head\tlist;\n};\n\nenum closure_state {\n\t \n\n\tCLOSURE_BITS_START\t= (1U << 26),\n\tCLOSURE_DESTRUCTOR\t= (1U << 26),\n\tCLOSURE_WAITING\t\t= (1U << 28),\n\tCLOSURE_RUNNING\t\t= (1U << 30),\n};\n\n#define CLOSURE_GUARD_MASK\t\t\t\t\t\\\n\t((CLOSURE_DESTRUCTOR|CLOSURE_WAITING|CLOSURE_RUNNING) << 1)\n\n#define CLOSURE_REMAINING_MASK\t\t(CLOSURE_BITS_START - 1)\n#define CLOSURE_REMAINING_INITIALIZER\t(1|CLOSURE_RUNNING)\n\nstruct closure {\n\tunion {\n\t\tstruct {\n\t\t\tstruct workqueue_struct *wq;\n\t\t\tstruct closure_syncer\t*s;\n\t\t\tstruct llist_node\tlist;\n\t\t\tclosure_fn\t\t*fn;\n\t\t};\n\t\tstruct work_struct\twork;\n\t};\n\n\tstruct closure\t\t*parent;\n\n\tatomic_t\t\tremaining;\n\n#ifdef CONFIG_BCACHE_CLOSURES_DEBUG\n#define CLOSURE_MAGIC_DEAD\t0xc054dead\n#define CLOSURE_MAGIC_ALIVE\t0xc054a11e\n\n\tunsigned int\t\tmagic;\n\tstruct list_head\tall;\n\tunsigned long\t\tip;\n\tunsigned long\t\twaiting_on;\n#endif\n};\n\nvoid closure_sub(struct closure *cl, int v);\nvoid closure_put(struct closure *cl);\nvoid __closure_wake_up(struct closure_waitlist *list);\nbool closure_wait(struct closure_waitlist *list, struct closure *cl);\nvoid __closure_sync(struct closure *cl);\n\n \nstatic inline void closure_sync(struct closure *cl)\n{\n\tif ((atomic_read(&cl->remaining) & CLOSURE_REMAINING_MASK) != 1)\n\t\t__closure_sync(cl);\n}\n\n#ifdef CONFIG_BCACHE_CLOSURES_DEBUG\n\nvoid closure_debug_init(void);\nvoid closure_debug_create(struct closure *cl);\nvoid closure_debug_destroy(struct closure *cl);\n\n#else\n\nstatic inline void closure_debug_init(void) {}\nstatic inline void closure_debug_create(struct closure *cl) {}\nstatic inline void closure_debug_destroy(struct closure *cl) {}\n\n#endif\n\nstatic inline void closure_set_ip(struct closure *cl)\n{\n#ifdef CONFIG_BCACHE_CLOSURES_DEBUG\n\tcl->ip = _THIS_IP_;\n#endif\n}\n\nstatic inline void closure_set_ret_ip(struct closure *cl)\n{\n#ifdef CONFIG_BCACHE_CLOSURES_DEBUG\n\tcl->ip = _RET_IP_;\n#endif\n}\n\nstatic inline void closure_set_waiting(struct closure *cl, unsigned long f)\n{\n#ifdef CONFIG_BCACHE_CLOSURES_DEBUG\n\tcl->waiting_on = f;\n#endif\n}\n\nstatic inline void closure_set_stopped(struct closure *cl)\n{\n\tatomic_sub(CLOSURE_RUNNING, &cl->remaining);\n}\n\nstatic inline void set_closure_fn(struct closure *cl, closure_fn *fn,\n\t\t\t\t  struct workqueue_struct *wq)\n{\n\tclosure_set_ip(cl);\n\tcl->fn = fn;\n\tcl->wq = wq;\n\t \n\tsmp_mb__before_atomic();\n}\n\nstatic inline void closure_queue(struct closure *cl)\n{\n\tstruct workqueue_struct *wq = cl->wq;\n\t \n\tBUILD_BUG_ON(offsetof(struct closure, fn)\n\t\t     != offsetof(struct work_struct, func));\n\tif (wq) {\n\t\tINIT_WORK(&cl->work, cl->work.func);\n\t\tBUG_ON(!queue_work(wq, &cl->work));\n\t} else\n\t\tcl->fn(cl);\n}\n\n \nstatic inline void closure_get(struct closure *cl)\n{\n#ifdef CONFIG_BCACHE_CLOSURES_DEBUG\n\tBUG_ON((atomic_inc_return(&cl->remaining) &\n\t\tCLOSURE_REMAINING_MASK) <= 1);\n#else\n\tatomic_inc(&cl->remaining);\n#endif\n}\n\n \nstatic inline void closure_init(struct closure *cl, struct closure *parent)\n{\n\tmemset(cl, 0, sizeof(struct closure));\n\tcl->parent = parent;\n\tif (parent)\n\t\tclosure_get(parent);\n\n\tatomic_set(&cl->remaining, CLOSURE_REMAINING_INITIALIZER);\n\n\tclosure_debug_create(cl);\n\tclosure_set_ip(cl);\n}\n\nstatic inline void closure_init_stack(struct closure *cl)\n{\n\tmemset(cl, 0, sizeof(struct closure));\n\tatomic_set(&cl->remaining, CLOSURE_REMAINING_INITIALIZER);\n}\n\n \nstatic inline void closure_wake_up(struct closure_waitlist *list)\n{\n\t \n\tsmp_mb();\n\t__closure_wake_up(list);\n}\n\n \n#define continue_at(_cl, _fn, _wq)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tset_closure_fn(_cl, _fn, _wq);\t\t\t\t\t\\\n\tclosure_sub(_cl, CLOSURE_RUNNING + 1);\t\t\t\t\\\n} while (0)\n\n \n#define closure_return(_cl)\tcontinue_at((_cl), NULL, NULL)\n\n \n#define continue_at_nobarrier(_cl, _fn, _wq)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tset_closure_fn(_cl, _fn, _wq);\t\t\t\t\t\\\n\tclosure_queue(_cl);\t\t\t\t\t\t\\\n} while (0)\n\n \n#define closure_return_with_destructor(_cl, _destructor)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tset_closure_fn(_cl, _destructor, NULL);\t\t\t\t\\\n\tclosure_sub(_cl, CLOSURE_RUNNING - CLOSURE_DESTRUCTOR + 1);\t\\\n} while (0)\n\n \nstatic inline void closure_call(struct closure *cl, closure_fn fn,\n\t\t\t\tstruct workqueue_struct *wq,\n\t\t\t\tstruct closure *parent)\n{\n\tclosure_init(cl, parent);\n\tcontinue_at_nobarrier(cl, fn, wq);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}