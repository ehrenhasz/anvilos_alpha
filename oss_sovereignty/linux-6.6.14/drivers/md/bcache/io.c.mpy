{
  "module_name": "io.c",
  "hash_id": "3d9c25dc52a25703306bde7c3ddf5421718611d755cf436175d6b8eb656edd38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/bcache/io.c",
  "human_readable_source": "\n \n\n#include \"bcache.h\"\n#include \"bset.h\"\n#include \"debug.h\"\n\n#include <linux/blkdev.h>\n\n \n\nvoid bch_bbio_free(struct bio *bio, struct cache_set *c)\n{\n\tstruct bbio *b = container_of(bio, struct bbio, bio);\n\n\tmempool_free(b, &c->bio_meta);\n}\n\nstruct bio *bch_bbio_alloc(struct cache_set *c)\n{\n\tstruct bbio *b = mempool_alloc(&c->bio_meta, GFP_NOIO);\n\tstruct bio *bio = &b->bio;\n\n\tbio_init(bio, NULL, bio->bi_inline_vecs,\n\t\t meta_bucket_pages(&c->cache->sb), 0);\n\n\treturn bio;\n}\n\nvoid __bch_submit_bbio(struct bio *bio, struct cache_set *c)\n{\n\tstruct bbio *b = container_of(bio, struct bbio, bio);\n\n\tbio->bi_iter.bi_sector\t= PTR_OFFSET(&b->key, 0);\n\tbio_set_dev(bio, c->cache->bdev);\n\n\tb->submit_time_us = local_clock_us();\n\tclosure_bio_submit(c, bio, bio->bi_private);\n}\n\nvoid bch_submit_bbio(struct bio *bio, struct cache_set *c,\n\t\t     struct bkey *k, unsigned int ptr)\n{\n\tstruct bbio *b = container_of(bio, struct bbio, bio);\n\n\tbch_bkey_copy_single_ptr(&b->key, k, ptr);\n\t__bch_submit_bbio(bio, c);\n}\n\n \nvoid bch_count_backing_io_errors(struct cached_dev *dc, struct bio *bio)\n{\n\tunsigned int errors;\n\n\tWARN_ONCE(!dc, \"NULL pointer of struct cached_dev\");\n\n\t \n\tif (bio->bi_opf & REQ_RAHEAD) {\n\t\tpr_warn_ratelimited(\"%pg: Read-ahead I/O failed on backing device, ignore\\n\",\n\t\t\t\t    dc->bdev);\n\t\treturn;\n\t}\n\n\terrors = atomic_add_return(1, &dc->io_errors);\n\tif (errors < dc->error_limit)\n\t\tpr_err(\"%pg: IO error on backing device, unrecoverable\\n\",\n\t\t\tdc->bdev);\n\telse\n\t\tbch_cached_dev_error(dc);\n}\n\nvoid bch_count_io_errors(struct cache *ca,\n\t\t\t blk_status_t error,\n\t\t\t int is_read,\n\t\t\t const char *m)\n{\n\t \n\n\tif (ca->set->error_decay) {\n\t\tunsigned int count = atomic_inc_return(&ca->io_count);\n\n\t\twhile (count > ca->set->error_decay) {\n\t\t\tunsigned int errors;\n\t\t\tunsigned int old = count;\n\t\t\tunsigned int new = count - ca->set->error_decay;\n\n\t\t\t \n\n\t\t\tcount = atomic_cmpxchg(&ca->io_count, old, new);\n\n\t\t\tif (count == old) {\n\t\t\t\tcount = new;\n\n\t\t\t\terrors = atomic_read(&ca->io_errors);\n\t\t\t\tdo {\n\t\t\t\t\told = errors;\n\t\t\t\t\tnew = ((uint64_t) errors * 127) / 128;\n\t\t\t\t\terrors = atomic_cmpxchg(&ca->io_errors,\n\t\t\t\t\t\t\t\told, new);\n\t\t\t\t} while (old != errors);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (error) {\n\t\tunsigned int errors = atomic_add_return(1 << IO_ERROR_SHIFT,\n\t\t\t\t\t\t    &ca->io_errors);\n\t\terrors >>= IO_ERROR_SHIFT;\n\n\t\tif (errors < ca->set->error_limit)\n\t\t\tpr_err(\"%pg: IO error on %s%s\\n\",\n\t\t\t       ca->bdev, m,\n\t\t\t       is_read ? \", recovering.\" : \".\");\n\t\telse\n\t\t\tbch_cache_set_error(ca->set,\n\t\t\t\t\t    \"%pg: too many IO errors %s\\n\",\n\t\t\t\t\t    ca->bdev, m);\n\t}\n}\n\nvoid bch_bbio_count_io_errors(struct cache_set *c, struct bio *bio,\n\t\t\t      blk_status_t error, const char *m)\n{\n\tstruct bbio *b = container_of(bio, struct bbio, bio);\n\tstruct cache *ca = c->cache;\n\tint is_read = (bio_data_dir(bio) == READ ? 1 : 0);\n\n\tunsigned int threshold = op_is_write(bio_op(bio))\n\t\t? c->congested_write_threshold_us\n\t\t: c->congested_read_threshold_us;\n\n\tif (threshold) {\n\t\tunsigned int t = local_clock_us();\n\t\tint us = t - b->submit_time_us;\n\t\tint congested = atomic_read(&c->congested);\n\n\t\tif (us > (int) threshold) {\n\t\t\tint ms = us / 1024;\n\n\t\t\tc->congested_last_us = t;\n\n\t\t\tms = min(ms, CONGESTED_MAX + congested);\n\t\t\tatomic_sub(ms, &c->congested);\n\t\t} else if (congested < 0)\n\t\t\tatomic_inc(&c->congested);\n\t}\n\n\tbch_count_io_errors(ca, error, is_read, m);\n}\n\nvoid bch_bbio_endio(struct cache_set *c, struct bio *bio,\n\t\t    blk_status_t error, const char *m)\n{\n\tstruct closure *cl = bio->bi_private;\n\n\tbch_bbio_count_io_errors(c, bio, error, m);\n\tbio_put(bio);\n\tclosure_put(cl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}