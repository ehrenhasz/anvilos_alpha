{
  "module_name": "debug.c",
  "hash_id": "4c10d57e9badb33ef1082336420298ee83372f23f56d31611f12bdd1f7696de7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/bcache/debug.c",
  "human_readable_source": "\n \n\n#include \"bcache.h\"\n#include \"btree.h\"\n#include \"debug.h\"\n#include \"extents.h\"\n\n#include <linux/console.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/seq_file.h>\n\nstruct dentry *bcache_debug;\n\n#ifdef CONFIG_BCACHE_DEBUG\n\n#define for_each_written_bset(b, start, i)\t\t\t\t\\\n\tfor (i = (start);\t\t\t\t\t\t\\\n\t     (void *) i < (void *) (start) + (KEY_SIZE(&b->key) << 9) &&\\\n\t     i->seq == (start)->seq;\t\t\t\t\t\\\n\t     i = (void *) i + set_blocks(i, block_bytes(b->c->cache)) *\t\\\n\t\t block_bytes(b->c->cache))\n\nvoid bch_btree_verify(struct btree *b)\n{\n\tstruct btree *v = b->c->verify_data;\n\tstruct bset *ondisk, *sorted, *inmemory;\n\tstruct bio *bio;\n\n\tif (!b->c->verify || !b->c->verify_ondisk)\n\t\treturn;\n\n\tdown(&b->io_mutex);\n\tmutex_lock(&b->c->verify_lock);\n\n\tondisk = b->c->verify_ondisk;\n\tsorted = b->c->verify_data->keys.set->data;\n\tinmemory = b->keys.set->data;\n\n\tbkey_copy(&v->key, &b->key);\n\tv->written = 0;\n\tv->level = b->level;\n\tv->keys.ops = b->keys.ops;\n\n\tbio = bch_bbio_alloc(b->c);\n\tbio_set_dev(bio, b->c->cache->bdev);\n\tbio->bi_iter.bi_sector\t= PTR_OFFSET(&b->key, 0);\n\tbio->bi_iter.bi_size\t= KEY_SIZE(&v->key) << 9;\n\tbio->bi_opf\t\t= REQ_OP_READ | REQ_META;\n\tbch_bio_map(bio, sorted);\n\n\tsubmit_bio_wait(bio);\n\tbch_bbio_free(bio, b->c);\n\n\tmemcpy(ondisk, sorted, KEY_SIZE(&v->key) << 9);\n\n\tbch_btree_node_read_done(v);\n\tsorted = v->keys.set->data;\n\n\tif (inmemory->keys != sorted->keys ||\n\t    memcmp(inmemory->start,\n\t\t   sorted->start,\n\t\t   (void *) bset_bkey_last(inmemory) -\n\t\t   (void *) inmemory->start)) {\n\t\tstruct bset *i;\n\t\tunsigned int j;\n\n\t\tconsole_lock();\n\n\t\tpr_err(\"*** in memory:\\n\");\n\t\tbch_dump_bset(&b->keys, inmemory, 0);\n\n\t\tpr_err(\"*** read back in:\\n\");\n\t\tbch_dump_bset(&v->keys, sorted, 0);\n\n\t\tfor_each_written_bset(b, ondisk, i) {\n\t\t\tunsigned int block = ((void *) i - (void *) ondisk) /\n\t\t\t\tblock_bytes(b->c->cache);\n\n\t\t\tpr_err(\"*** on disk block %u:\\n\", block);\n\t\t\tbch_dump_bset(&b->keys, i, block);\n\t\t}\n\n\t\tpr_err(\"*** block %zu not written\\n\",\n\t\t       ((void *) i - (void *) ondisk) / block_bytes(b->c->cache));\n\n\t\tfor (j = 0; j < inmemory->keys; j++)\n\t\t\tif (inmemory->d[j] != sorted->d[j])\n\t\t\t\tbreak;\n\n\t\tpr_err(\"b->written %u\\n\", b->written);\n\n\t\tconsole_unlock();\n\t\tpanic(\"verify failed at %u\\n\", j);\n\t}\n\n\tmutex_unlock(&b->c->verify_lock);\n\tup(&b->io_mutex);\n}\n\nvoid bch_data_verify(struct cached_dev *dc, struct bio *bio)\n{\n\tunsigned int nr_segs = bio_segments(bio);\n\tstruct bio *check;\n\tstruct bio_vec bv, cbv;\n\tstruct bvec_iter iter, citer = { 0 };\n\n\tcheck = bio_kmalloc(nr_segs, GFP_NOIO);\n\tif (!check)\n\t\treturn;\n\tbio_init(check, bio->bi_bdev, check->bi_inline_vecs, nr_segs,\n\t\t REQ_OP_READ);\n\tcheck->bi_iter.bi_sector = bio->bi_iter.bi_sector;\n\tcheck->bi_iter.bi_size = bio->bi_iter.bi_size;\n\n\tbch_bio_map(check, NULL);\n\tif (bch_bio_alloc_pages(check, GFP_NOIO))\n\t\tgoto out_put;\n\n\tsubmit_bio_wait(check);\n\n\tciter.bi_size = UINT_MAX;\n\tbio_for_each_segment(bv, bio, iter) {\n\t\tvoid *p1 = bvec_kmap_local(&bv);\n\t\tvoid *p2;\n\n\t\tcbv = bio_iter_iovec(check, citer);\n\t\tp2 = bvec_kmap_local(&cbv);\n\n\t\tcache_set_err_on(memcmp(p1, p2, bv.bv_len),\n\t\t\t\t dc->disk.c,\n\t\t\t\t \"verify failed at dev %pg sector %llu\",\n\t\t\t\t dc->bdev,\n\t\t\t\t (uint64_t) bio->bi_iter.bi_sector);\n\n\t\tkunmap_local(p2);\n\t\tkunmap_local(p1);\n\t\tbio_advance_iter(check, &citer, bv.bv_len);\n\t}\n\n\tbio_free_pages(check);\nout_put:\n\tbio_uninit(check);\n\tkfree(check);\n}\n\n#endif\n\n#ifdef CONFIG_DEBUG_FS\n\n \n\nstruct dump_iterator {\n\tchar\t\t\tbuf[PAGE_SIZE];\n\tsize_t\t\t\tbytes;\n\tstruct cache_set\t*c;\n\tstruct keybuf\t\tkeys;\n};\n\nstatic bool dump_pred(struct keybuf *buf, struct bkey *k)\n{\n\treturn true;\n}\n\nstatic ssize_t bch_dump_read(struct file *file, char __user *buf,\n\t\t\t     size_t size, loff_t *ppos)\n{\n\tstruct dump_iterator *i = file->private_data;\n\tssize_t ret = 0;\n\tchar kbuf[80];\n\n\twhile (size) {\n\t\tstruct keybuf_key *w;\n\t\tunsigned int bytes = min(i->bytes, size);\n\n\t\tif (copy_to_user(buf, i->buf, bytes))\n\t\t\treturn -EFAULT;\n\n\t\tret\t += bytes;\n\t\tbuf\t += bytes;\n\t\tsize\t -= bytes;\n\t\ti->bytes -= bytes;\n\t\tmemmove(i->buf, i->buf + bytes, i->bytes);\n\n\t\tif (i->bytes)\n\t\t\tbreak;\n\n\t\tw = bch_keybuf_next_rescan(i->c, &i->keys, &MAX_KEY, dump_pred);\n\t\tif (!w)\n\t\t\tbreak;\n\n\t\tbch_extent_to_text(kbuf, sizeof(kbuf), &w->key);\n\t\ti->bytes = snprintf(i->buf, PAGE_SIZE, \"%s\\n\", kbuf);\n\t\tbch_keybuf_del(&i->keys, w);\n\t}\n\n\treturn ret;\n}\n\nstatic int bch_dump_open(struct inode *inode, struct file *file)\n{\n\tstruct cache_set *c = inode->i_private;\n\tstruct dump_iterator *i;\n\n\ti = kzalloc(sizeof(struct dump_iterator), GFP_KERNEL);\n\tif (!i)\n\t\treturn -ENOMEM;\n\n\tfile->private_data = i;\n\ti->c = c;\n\tbch_keybuf_init(&i->keys);\n\ti->keys.last_scanned = KEY(0, 0, 0);\n\n\treturn 0;\n}\n\nstatic int bch_dump_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}\n\nstatic const struct file_operations cache_set_debug_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= bch_dump_open,\n\t.read\t\t= bch_dump_read,\n\t.release\t= bch_dump_release\n};\n\nvoid bch_debug_init_cache_set(struct cache_set *c)\n{\n\tif (!IS_ERR_OR_NULL(bcache_debug)) {\n\t\tchar name[50];\n\n\t\tsnprintf(name, 50, \"bcache-%pU\", c->set_uuid);\n\t\tc->debug = debugfs_create_file(name, 0400, bcache_debug, c,\n\t\t\t\t\t       &cache_set_debug_ops);\n\t}\n}\n\n#endif\n\nvoid bch_debug_exit(void)\n{\n\tdebugfs_remove_recursive(bcache_debug);\n}\n\nvoid __init bch_debug_init(void)\n{\n\t \n\tbcache_debug = debugfs_create_dir(\"bcache\", NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}