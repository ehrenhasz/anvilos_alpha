{
  "module_name": "super.c",
  "hash_id": "63ce5aff1e406a09995ceb4a71422c7095852c21abb40fa037ec95c091f1c4b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/bcache/super.c",
  "human_readable_source": "\n \n\n#include \"bcache.h\"\n#include \"btree.h\"\n#include \"debug.h\"\n#include \"extents.h\"\n#include \"request.h\"\n#include \"writeback.h\"\n#include \"features.h\"\n\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/debugfs.h>\n#include <linux/idr.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/reboot.h>\n#include <linux/sysfs.h>\n\nunsigned int bch_cutoff_writeback;\nunsigned int bch_cutoff_writeback_sync;\n\nstatic const char bcache_magic[] = {\n\t0xc6, 0x85, 0x73, 0xf6, 0x4e, 0x1a, 0x45, 0xca,\n\t0x82, 0x65, 0xf5, 0x7f, 0x48, 0xba, 0x6d, 0x81\n};\n\nstatic const char invalid_uuid[] = {\n\t0xa0, 0x3e, 0xf8, 0xed, 0x3e, 0xe1, 0xb8, 0x78,\n\t0xc8, 0x50, 0xfc, 0x5e, 0xcb, 0x16, 0xcd, 0x99\n};\n\nstatic struct kobject *bcache_kobj;\nstruct mutex bch_register_lock;\nbool bcache_is_reboot;\nLIST_HEAD(bch_cache_sets);\nstatic LIST_HEAD(uncached_devices);\n\nstatic int bcache_major;\nstatic DEFINE_IDA(bcache_device_idx);\nstatic wait_queue_head_t unregister_wait;\nstruct workqueue_struct *bcache_wq;\nstruct workqueue_struct *bch_flush_wq;\nstruct workqueue_struct *bch_journal_wq;\n\n\n#define BTREE_MAX_PAGES\t\t(256 * 1024 / PAGE_SIZE)\n \n#define BCACHE_MINORS\t\t128\n \n#define BCACHE_DEVICE_IDX_MAX\t((1U << MINORBITS)/BCACHE_MINORS)\n\n \n\nstatic unsigned int get_bucket_size(struct cache_sb *sb, struct cache_sb_disk *s)\n{\n\tunsigned int bucket_size = le16_to_cpu(s->bucket_size);\n\n\tif (sb->version >= BCACHE_SB_VERSION_CDEV_WITH_FEATURES) {\n\t\tif (bch_has_feature_large_bucket(sb)) {\n\t\t\tunsigned int max, order;\n\n\t\t\tmax = sizeof(unsigned int) * BITS_PER_BYTE - 1;\n\t\t\torder = le16_to_cpu(s->bucket_size);\n\t\t\t \n\t\t\tif (order > max)\n\t\t\t\tpr_err(\"Bucket size (1 << %u) overflows\\n\",\n\t\t\t\t\torder);\n\t\t\tbucket_size = 1 << order;\n\t\t} else if (bch_has_feature_obso_large_bucket(sb)) {\n\t\t\tbucket_size +=\n\t\t\t\tle16_to_cpu(s->obso_bucket_size_hi) << 16;\n\t\t}\n\t}\n\n\treturn bucket_size;\n}\n\nstatic const char *read_super_common(struct cache_sb *sb,  struct block_device *bdev,\n\t\t\t\t     struct cache_sb_disk *s)\n{\n\tconst char *err;\n\tunsigned int i;\n\n\tsb->first_bucket= le16_to_cpu(s->first_bucket);\n\tsb->nbuckets\t= le64_to_cpu(s->nbuckets);\n\tsb->bucket_size\t= get_bucket_size(sb, s);\n\n\tsb->nr_in_set\t= le16_to_cpu(s->nr_in_set);\n\tsb->nr_this_dev\t= le16_to_cpu(s->nr_this_dev);\n\n\terr = \"Too many journal buckets\";\n\tif (sb->keys > SB_JOURNAL_BUCKETS)\n\t\tgoto err;\n\n\terr = \"Too many buckets\";\n\tif (sb->nbuckets > LONG_MAX)\n\t\tgoto err;\n\n\terr = \"Not enough buckets\";\n\tif (sb->nbuckets < 1 << 7)\n\t\tgoto err;\n\n\terr = \"Bad block size (not power of 2)\";\n\tif (!is_power_of_2(sb->block_size))\n\t\tgoto err;\n\n\terr = \"Bad block size (larger than page size)\";\n\tif (sb->block_size > PAGE_SECTORS)\n\t\tgoto err;\n\n\terr = \"Bad bucket size (not power of 2)\";\n\tif (!is_power_of_2(sb->bucket_size))\n\t\tgoto err;\n\n\terr = \"Bad bucket size (smaller than page size)\";\n\tif (sb->bucket_size < PAGE_SECTORS)\n\t\tgoto err;\n\n\terr = \"Invalid superblock: device too small\";\n\tif (get_capacity(bdev->bd_disk) <\n\t    sb->bucket_size * sb->nbuckets)\n\t\tgoto err;\n\n\terr = \"Bad UUID\";\n\tif (bch_is_zero(sb->set_uuid, 16))\n\t\tgoto err;\n\n\terr = \"Bad cache device number in set\";\n\tif (!sb->nr_in_set ||\n\t    sb->nr_in_set <= sb->nr_this_dev ||\n\t    sb->nr_in_set > MAX_CACHES_PER_SET)\n\t\tgoto err;\n\n\terr = \"Journal buckets not sequential\";\n\tfor (i = 0; i < sb->keys; i++)\n\t\tif (sb->d[i] != sb->first_bucket + i)\n\t\t\tgoto err;\n\n\terr = \"Too many journal buckets\";\n\tif (sb->first_bucket + sb->keys > sb->nbuckets)\n\t\tgoto err;\n\n\terr = \"Invalid superblock: first bucket comes before end of super\";\n\tif (sb->first_bucket * sb->bucket_size < 16)\n\t\tgoto err;\n\n\terr = NULL;\nerr:\n\treturn err;\n}\n\n\nstatic const char *read_super(struct cache_sb *sb, struct block_device *bdev,\n\t\t\t      struct cache_sb_disk **res)\n{\n\tconst char *err;\n\tstruct cache_sb_disk *s;\n\tstruct page *page;\n\tunsigned int i;\n\n\tpage = read_cache_page_gfp(bdev->bd_inode->i_mapping,\n\t\t\t\t   SB_OFFSET >> PAGE_SHIFT, GFP_KERNEL);\n\tif (IS_ERR(page))\n\t\treturn \"IO error\";\n\ts = page_address(page) + offset_in_page(SB_OFFSET);\n\n\tsb->offset\t\t= le64_to_cpu(s->offset);\n\tsb->version\t\t= le64_to_cpu(s->version);\n\n\tmemcpy(sb->magic,\ts->magic, 16);\n\tmemcpy(sb->uuid,\ts->uuid, 16);\n\tmemcpy(sb->set_uuid,\ts->set_uuid, 16);\n\tmemcpy(sb->label,\ts->label, SB_LABEL_SIZE);\n\n\tsb->flags\t\t= le64_to_cpu(s->flags);\n\tsb->seq\t\t\t= le64_to_cpu(s->seq);\n\tsb->last_mount\t\t= le32_to_cpu(s->last_mount);\n\tsb->keys\t\t= le16_to_cpu(s->keys);\n\n\tfor (i = 0; i < SB_JOURNAL_BUCKETS; i++)\n\t\tsb->d[i] = le64_to_cpu(s->d[i]);\n\n\tpr_debug(\"read sb version %llu, flags %llu, seq %llu, journal size %u\\n\",\n\t\t sb->version, sb->flags, sb->seq, sb->keys);\n\n\terr = \"Not a bcache superblock (bad offset)\";\n\tif (sb->offset != SB_SECTOR)\n\t\tgoto err;\n\n\terr = \"Not a bcache superblock (bad magic)\";\n\tif (memcmp(sb->magic, bcache_magic, 16))\n\t\tgoto err;\n\n\terr = \"Bad checksum\";\n\tif (s->csum != csum_set(s))\n\t\tgoto err;\n\n\terr = \"Bad UUID\";\n\tif (bch_is_zero(sb->uuid, 16))\n\t\tgoto err;\n\n\tsb->block_size\t= le16_to_cpu(s->block_size);\n\n\terr = \"Superblock block size smaller than device block size\";\n\tif (sb->block_size << 9 < bdev_logical_block_size(bdev))\n\t\tgoto err;\n\n\tswitch (sb->version) {\n\tcase BCACHE_SB_VERSION_BDEV:\n\t\tsb->data_offset\t= BDEV_DATA_START_DEFAULT;\n\t\tbreak;\n\tcase BCACHE_SB_VERSION_BDEV_WITH_OFFSET:\n\tcase BCACHE_SB_VERSION_BDEV_WITH_FEATURES:\n\t\tsb->data_offset\t= le64_to_cpu(s->data_offset);\n\n\t\terr = \"Bad data offset\";\n\t\tif (sb->data_offset < BDEV_DATA_START_DEFAULT)\n\t\t\tgoto err;\n\n\t\tbreak;\n\tcase BCACHE_SB_VERSION_CDEV:\n\tcase BCACHE_SB_VERSION_CDEV_WITH_UUID:\n\t\terr = read_super_common(sb, bdev, s);\n\t\tif (err)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase BCACHE_SB_VERSION_CDEV_WITH_FEATURES:\n\t\t \n\t\tsb->feature_compat = le64_to_cpu(s->feature_compat);\n\t\tsb->feature_incompat = le64_to_cpu(s->feature_incompat);\n\t\tsb->feature_ro_compat = le64_to_cpu(s->feature_ro_compat);\n\n\t\t \n\t\terr = \"Unsupported compatible feature found\";\n\t\tif (bch_has_unknown_compat_features(sb))\n\t\t\tgoto err;\n\n\t\terr = \"Unsupported read-only compatible feature found\";\n\t\tif (bch_has_unknown_ro_compat_features(sb))\n\t\t\tgoto err;\n\n\t\terr = \"Unsupported incompatible feature found\";\n\t\tif (bch_has_unknown_incompat_features(sb))\n\t\t\tgoto err;\n\n\t\terr = read_super_common(sb, bdev, s);\n\t\tif (err)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\terr = \"Unsupported superblock version\";\n\t\tgoto err;\n\t}\n\n\tsb->last_mount = (u32)ktime_get_real_seconds();\n\t*res = s;\n\treturn NULL;\nerr:\n\tput_page(page);\n\treturn err;\n}\n\nstatic void write_bdev_super_endio(struct bio *bio)\n{\n\tstruct cached_dev *dc = bio->bi_private;\n\n\tif (bio->bi_status)\n\t\tbch_count_backing_io_errors(dc, bio);\n\n\tclosure_put(&dc->sb_write);\n}\n\nstatic void __write_super(struct cache_sb *sb, struct cache_sb_disk *out,\n\t\tstruct bio *bio)\n{\n\tunsigned int i;\n\n\tbio->bi_opf = REQ_OP_WRITE | REQ_SYNC | REQ_META;\n\tbio->bi_iter.bi_sector\t= SB_SECTOR;\n\t__bio_add_page(bio, virt_to_page(out), SB_SIZE,\n\t\t\toffset_in_page(out));\n\n\tout->offset\t\t= cpu_to_le64(sb->offset);\n\n\tmemcpy(out->uuid,\tsb->uuid, 16);\n\tmemcpy(out->set_uuid,\tsb->set_uuid, 16);\n\tmemcpy(out->label,\tsb->label, SB_LABEL_SIZE);\n\n\tout->flags\t\t= cpu_to_le64(sb->flags);\n\tout->seq\t\t= cpu_to_le64(sb->seq);\n\n\tout->last_mount\t\t= cpu_to_le32(sb->last_mount);\n\tout->first_bucket\t= cpu_to_le16(sb->first_bucket);\n\tout->keys\t\t= cpu_to_le16(sb->keys);\n\n\tfor (i = 0; i < sb->keys; i++)\n\t\tout->d[i] = cpu_to_le64(sb->d[i]);\n\n\tif (sb->version >= BCACHE_SB_VERSION_CDEV_WITH_FEATURES) {\n\t\tout->feature_compat    = cpu_to_le64(sb->feature_compat);\n\t\tout->feature_incompat  = cpu_to_le64(sb->feature_incompat);\n\t\tout->feature_ro_compat = cpu_to_le64(sb->feature_ro_compat);\n\t}\n\n\tout->version\t\t= cpu_to_le64(sb->version);\n\tout->csum = csum_set(out);\n\n\tpr_debug(\"ver %llu, flags %llu, seq %llu\\n\",\n\t\t sb->version, sb->flags, sb->seq);\n\n\tsubmit_bio(bio);\n}\n\nstatic void bch_write_bdev_super_unlock(struct closure *cl)\n{\n\tstruct cached_dev *dc = container_of(cl, struct cached_dev, sb_write);\n\n\tup(&dc->sb_write_mutex);\n}\n\nvoid bch_write_bdev_super(struct cached_dev *dc, struct closure *parent)\n{\n\tstruct closure *cl = &dc->sb_write;\n\tstruct bio *bio = &dc->sb_bio;\n\n\tdown(&dc->sb_write_mutex);\n\tclosure_init(cl, parent);\n\n\tbio_init(bio, dc->bdev, dc->sb_bv, 1, 0);\n\tbio->bi_end_io\t= write_bdev_super_endio;\n\tbio->bi_private = dc;\n\n\tclosure_get(cl);\n\t \n\t__write_super(&dc->sb, dc->sb_disk, bio);\n\n\tclosure_return_with_destructor(cl, bch_write_bdev_super_unlock);\n}\n\nstatic void write_super_endio(struct bio *bio)\n{\n\tstruct cache *ca = bio->bi_private;\n\n\t \n\tbch_count_io_errors(ca, bio->bi_status, 0,\n\t\t\t    \"writing superblock\");\n\tclosure_put(&ca->set->sb_write);\n}\n\nstatic void bcache_write_super_unlock(struct closure *cl)\n{\n\tstruct cache_set *c = container_of(cl, struct cache_set, sb_write);\n\n\tup(&c->sb_write_mutex);\n}\n\nvoid bcache_write_super(struct cache_set *c)\n{\n\tstruct closure *cl = &c->sb_write;\n\tstruct cache *ca = c->cache;\n\tstruct bio *bio = &ca->sb_bio;\n\tunsigned int version = BCACHE_SB_VERSION_CDEV_WITH_UUID;\n\n\tdown(&c->sb_write_mutex);\n\tclosure_init(cl, &c->cl);\n\n\tca->sb.seq++;\n\n\tif (ca->sb.version < version)\n\t\tca->sb.version = version;\n\n\tbio_init(bio, ca->bdev, ca->sb_bv, 1, 0);\n\tbio->bi_end_io\t= write_super_endio;\n\tbio->bi_private = ca;\n\n\tclosure_get(cl);\n\t__write_super(&ca->sb, ca->sb_disk, bio);\n\n\tclosure_return_with_destructor(cl, bcache_write_super_unlock);\n}\n\n \n\nstatic void uuid_endio(struct bio *bio)\n{\n\tstruct closure *cl = bio->bi_private;\n\tstruct cache_set *c = container_of(cl, struct cache_set, uuid_write);\n\n\tcache_set_err_on(bio->bi_status, c, \"accessing uuids\");\n\tbch_bbio_free(bio, c);\n\tclosure_put(cl);\n}\n\nstatic void uuid_io_unlock(struct closure *cl)\n{\n\tstruct cache_set *c = container_of(cl, struct cache_set, uuid_write);\n\n\tup(&c->uuid_write_mutex);\n}\n\nstatic void uuid_io(struct cache_set *c, blk_opf_t opf, struct bkey *k,\n\t\t    struct closure *parent)\n{\n\tstruct closure *cl = &c->uuid_write;\n\tstruct uuid_entry *u;\n\tunsigned int i;\n\tchar buf[80];\n\n\tBUG_ON(!parent);\n\tdown(&c->uuid_write_mutex);\n\tclosure_init(cl, parent);\n\n\tfor (i = 0; i < KEY_PTRS(k); i++) {\n\t\tstruct bio *bio = bch_bbio_alloc(c);\n\n\t\tbio->bi_opf = opf | REQ_SYNC | REQ_META;\n\t\tbio->bi_iter.bi_size = KEY_SIZE(k) << 9;\n\n\t\tbio->bi_end_io\t= uuid_endio;\n\t\tbio->bi_private = cl;\n\t\tbch_bio_map(bio, c->uuids);\n\n\t\tbch_submit_bbio(bio, c, k, i);\n\n\t\tif ((opf & REQ_OP_MASK) != REQ_OP_WRITE)\n\t\t\tbreak;\n\t}\n\n\tbch_extent_to_text(buf, sizeof(buf), k);\n\tpr_debug(\"%s UUIDs at %s\\n\", (opf & REQ_OP_MASK) == REQ_OP_WRITE ?\n\t\t \"wrote\" : \"read\", buf);\n\n\tfor (u = c->uuids; u < c->uuids + c->nr_uuids; u++)\n\t\tif (!bch_is_zero(u->uuid, 16))\n\t\t\tpr_debug(\"Slot %zi: %pU: %s: 1st: %u last: %u inv: %u\\n\",\n\t\t\t\t u - c->uuids, u->uuid, u->label,\n\t\t\t\t u->first_reg, u->last_reg, u->invalidated);\n\n\tclosure_return_with_destructor(cl, uuid_io_unlock);\n}\n\nstatic char *uuid_read(struct cache_set *c, struct jset *j, struct closure *cl)\n{\n\tstruct bkey *k = &j->uuid_bucket;\n\n\tif (__bch_btree_ptr_invalid(c, k))\n\t\treturn \"bad uuid pointer\";\n\n\tbkey_copy(&c->uuid_bucket, k);\n\tuuid_io(c, REQ_OP_READ, k, cl);\n\n\tif (j->version < BCACHE_JSET_VERSION_UUIDv1) {\n\t\tstruct uuid_entry_v0\t*u0 = (void *) c->uuids;\n\t\tstruct uuid_entry\t*u1 = (void *) c->uuids;\n\t\tint i;\n\n\t\tclosure_sync(cl);\n\n\t\t \n\n\t\tfor (i = c->nr_uuids - 1;\n\t\t     i >= 0;\n\t\t     --i) {\n\t\t\tmemcpy(u1[i].uuid,\tu0[i].uuid, 16);\n\t\t\tmemcpy(u1[i].label,\tu0[i].label, 32);\n\n\t\t\tu1[i].first_reg\t\t= u0[i].first_reg;\n\t\t\tu1[i].last_reg\t\t= u0[i].last_reg;\n\t\t\tu1[i].invalidated\t= u0[i].invalidated;\n\n\t\t\tu1[i].flags\t= 0;\n\t\t\tu1[i].sectors\t= 0;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int __uuid_write(struct cache_set *c)\n{\n\tBKEY_PADDED(key) k;\n\tstruct closure cl;\n\tstruct cache *ca = c->cache;\n\tunsigned int size;\n\n\tclosure_init_stack(&cl);\n\tlockdep_assert_held(&bch_register_lock);\n\n\tif (bch_bucket_alloc_set(c, RESERVE_BTREE, &k.key, true))\n\t\treturn 1;\n\n\tsize =  meta_bucket_pages(&ca->sb) * PAGE_SECTORS;\n\tSET_KEY_SIZE(&k.key, size);\n\tuuid_io(c, REQ_OP_WRITE, &k.key, &cl);\n\tclosure_sync(&cl);\n\n\t \n\tatomic_long_add(ca->sb.bucket_size, &ca->meta_sectors_written);\n\n\tbkey_copy(&c->uuid_bucket, &k.key);\n\tbkey_put(c, &k.key);\n\treturn 0;\n}\n\nint bch_uuid_write(struct cache_set *c)\n{\n\tint ret = __uuid_write(c);\n\n\tif (!ret)\n\t\tbch_journal_meta(c, NULL);\n\n\treturn ret;\n}\n\nstatic struct uuid_entry *uuid_find(struct cache_set *c, const char *uuid)\n{\n\tstruct uuid_entry *u;\n\n\tfor (u = c->uuids;\n\t     u < c->uuids + c->nr_uuids; u++)\n\t\tif (!memcmp(u->uuid, uuid, 16))\n\t\t\treturn u;\n\n\treturn NULL;\n}\n\nstatic struct uuid_entry *uuid_find_empty(struct cache_set *c)\n{\n\tstatic const char zero_uuid[16] = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n\treturn uuid_find(c, zero_uuid);\n}\n\n \n\nstatic void prio_endio(struct bio *bio)\n{\n\tstruct cache *ca = bio->bi_private;\n\n\tcache_set_err_on(bio->bi_status, ca->set, \"accessing priorities\");\n\tbch_bbio_free(bio, ca->set);\n\tclosure_put(&ca->prio);\n}\n\nstatic void prio_io(struct cache *ca, uint64_t bucket, blk_opf_t opf)\n{\n\tstruct closure *cl = &ca->prio;\n\tstruct bio *bio = bch_bbio_alloc(ca->set);\n\n\tclosure_init_stack(cl);\n\n\tbio->bi_iter.bi_sector\t= bucket * ca->sb.bucket_size;\n\tbio_set_dev(bio, ca->bdev);\n\tbio->bi_iter.bi_size\t= meta_bucket_bytes(&ca->sb);\n\n\tbio->bi_end_io\t= prio_endio;\n\tbio->bi_private = ca;\n\tbio->bi_opf = opf | REQ_SYNC | REQ_META;\n\tbch_bio_map(bio, ca->disk_buckets);\n\n\tclosure_bio_submit(ca->set, bio, &ca->prio);\n\tclosure_sync(cl);\n}\n\nint bch_prio_write(struct cache *ca, bool wait)\n{\n\tint i;\n\tstruct bucket *b;\n\tstruct closure cl;\n\n\tpr_debug(\"free_prio=%zu, free_none=%zu, free_inc=%zu\\n\",\n\t\t fifo_used(&ca->free[RESERVE_PRIO]),\n\t\t fifo_used(&ca->free[RESERVE_NONE]),\n\t\t fifo_used(&ca->free_inc));\n\n\t \n\tif (!wait) {\n\t\tsize_t avail = fifo_used(&ca->free[RESERVE_PRIO]) +\n\t\t\t       fifo_used(&ca->free[RESERVE_NONE]);\n\t\tif (prio_buckets(ca) > avail)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tclosure_init_stack(&cl);\n\n\tlockdep_assert_held(&ca->set->bucket_lock);\n\n\tca->disk_buckets->seq++;\n\n\tatomic_long_add(ca->sb.bucket_size * prio_buckets(ca),\n\t\t\t&ca->meta_sectors_written);\n\n\tfor (i = prio_buckets(ca) - 1; i >= 0; --i) {\n\t\tlong bucket;\n\t\tstruct prio_set *p = ca->disk_buckets;\n\t\tstruct bucket_disk *d = p->data;\n\t\tstruct bucket_disk *end = d + prios_per_bucket(ca);\n\n\t\tfor (b = ca->buckets + i * prios_per_bucket(ca);\n\t\t     b < ca->buckets + ca->sb.nbuckets && d < end;\n\t\t     b++, d++) {\n\t\t\td->prio = cpu_to_le16(b->prio);\n\t\t\td->gen = b->gen;\n\t\t}\n\n\t\tp->next_bucket\t= ca->prio_buckets[i + 1];\n\t\tp->magic\t= pset_magic(&ca->sb);\n\t\tp->csum\t\t= bch_crc64(&p->magic, meta_bucket_bytes(&ca->sb) - 8);\n\n\t\tbucket = bch_bucket_alloc(ca, RESERVE_PRIO, wait);\n\t\tBUG_ON(bucket == -1);\n\n\t\tmutex_unlock(&ca->set->bucket_lock);\n\t\tprio_io(ca, bucket, REQ_OP_WRITE);\n\t\tmutex_lock(&ca->set->bucket_lock);\n\n\t\tca->prio_buckets[i] = bucket;\n\t\tatomic_dec_bug(&ca->buckets[bucket].pin);\n\t}\n\n\tmutex_unlock(&ca->set->bucket_lock);\n\n\tbch_journal_meta(ca->set, &cl);\n\tclosure_sync(&cl);\n\n\tmutex_lock(&ca->set->bucket_lock);\n\n\t \n\tfor (i = 0; i < prio_buckets(ca); i++) {\n\t\tif (ca->prio_last_buckets[i])\n\t\t\t__bch_bucket_free(ca,\n\t\t\t\t&ca->buckets[ca->prio_last_buckets[i]]);\n\n\t\tca->prio_last_buckets[i] = ca->prio_buckets[i];\n\t}\n\treturn 0;\n}\n\nstatic int prio_read(struct cache *ca, uint64_t bucket)\n{\n\tstruct prio_set *p = ca->disk_buckets;\n\tstruct bucket_disk *d = p->data + prios_per_bucket(ca), *end = d;\n\tstruct bucket *b;\n\tunsigned int bucket_nr = 0;\n\tint ret = -EIO;\n\n\tfor (b = ca->buckets;\n\t     b < ca->buckets + ca->sb.nbuckets;\n\t     b++, d++) {\n\t\tif (d == end) {\n\t\t\tca->prio_buckets[bucket_nr] = bucket;\n\t\t\tca->prio_last_buckets[bucket_nr] = bucket;\n\t\t\tbucket_nr++;\n\n\t\t\tprio_io(ca, bucket, REQ_OP_READ);\n\n\t\t\tif (p->csum !=\n\t\t\t    bch_crc64(&p->magic, meta_bucket_bytes(&ca->sb) - 8)) {\n\t\t\t\tpr_warn(\"bad csum reading priorities\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (p->magic != pset_magic(&ca->sb)) {\n\t\t\t\tpr_warn(\"bad magic reading priorities\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbucket = p->next_bucket;\n\t\t\td = p->data;\n\t\t}\n\n\t\tb->prio = le16_to_cpu(d->prio);\n\t\tb->gen = b->last_gc = d->gen;\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\n \n\nstatic int open_dev(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct bcache_device *d = disk->private_data;\n\n\tif (test_bit(BCACHE_DEV_CLOSING, &d->flags))\n\t\treturn -ENXIO;\n\n\tclosure_get(&d->cl);\n\treturn 0;\n}\n\nstatic void release_dev(struct gendisk *b)\n{\n\tstruct bcache_device *d = b->private_data;\n\n\tclosure_put(&d->cl);\n}\n\nstatic int ioctl_dev(struct block_device *b, blk_mode_t mode,\n\t\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct bcache_device *d = b->bd_disk->private_data;\n\n\treturn d->ioctl(d, mode, cmd, arg);\n}\n\nstatic const struct block_device_operations bcache_cached_ops = {\n\t.submit_bio\t= cached_dev_submit_bio,\n\t.open\t\t= open_dev,\n\t.release\t= release_dev,\n\t.ioctl\t\t= ioctl_dev,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct block_device_operations bcache_flash_ops = {\n\t.submit_bio\t= flash_dev_submit_bio,\n\t.open\t\t= open_dev,\n\t.release\t= release_dev,\n\t.ioctl\t\t= ioctl_dev,\n\t.owner\t\t= THIS_MODULE,\n};\n\nvoid bcache_device_stop(struct bcache_device *d)\n{\n\tif (!test_and_set_bit(BCACHE_DEV_CLOSING, &d->flags))\n\t\t \n\t\tclosure_queue(&d->cl);\n}\n\nstatic void bcache_device_unlink(struct bcache_device *d)\n{\n\tlockdep_assert_held(&bch_register_lock);\n\n\tif (d->c && !test_and_set_bit(BCACHE_DEV_UNLINK_DONE, &d->flags)) {\n\t\tstruct cache *ca = d->c->cache;\n\n\t\tsysfs_remove_link(&d->c->kobj, d->name);\n\t\tsysfs_remove_link(&d->kobj, \"cache\");\n\n\t\tbd_unlink_disk_holder(ca->bdev, d->disk);\n\t}\n}\n\nstatic void bcache_device_link(struct bcache_device *d, struct cache_set *c,\n\t\t\t       const char *name)\n{\n\tstruct cache *ca = c->cache;\n\tint ret;\n\n\tbd_link_disk_holder(ca->bdev, d->disk);\n\n\tsnprintf(d->name, BCACHEDEVNAME_SIZE,\n\t\t \"%s%u\", name, d->id);\n\n\tret = sysfs_create_link(&d->kobj, &c->kobj, \"cache\");\n\tif (ret < 0)\n\t\tpr_err(\"Couldn't create device -> cache set symlink\\n\");\n\n\tret = sysfs_create_link(&c->kobj, &d->kobj, d->name);\n\tif (ret < 0)\n\t\tpr_err(\"Couldn't create cache set -> device symlink\\n\");\n\n\tclear_bit(BCACHE_DEV_UNLINK_DONE, &d->flags);\n}\n\nstatic void bcache_device_detach(struct bcache_device *d)\n{\n\tlockdep_assert_held(&bch_register_lock);\n\n\tatomic_dec(&d->c->attached_dev_nr);\n\n\tif (test_bit(BCACHE_DEV_DETACHING, &d->flags)) {\n\t\tstruct uuid_entry *u = d->c->uuids + d->id;\n\n\t\tSET_UUID_FLASH_ONLY(u, 0);\n\t\tmemcpy(u->uuid, invalid_uuid, 16);\n\t\tu->invalidated = cpu_to_le32((u32)ktime_get_real_seconds());\n\t\tbch_uuid_write(d->c);\n\t}\n\n\tbcache_device_unlink(d);\n\n\td->c->devices[d->id] = NULL;\n\tclosure_put(&d->c->caching);\n\td->c = NULL;\n}\n\nstatic void bcache_device_attach(struct bcache_device *d, struct cache_set *c,\n\t\t\t\t unsigned int id)\n{\n\td->id = id;\n\td->c = c;\n\tc->devices[id] = d;\n\n\tif (id >= c->devices_max_used)\n\t\tc->devices_max_used = id + 1;\n\n\tclosure_get(&c->caching);\n}\n\nstatic inline int first_minor_to_idx(int first_minor)\n{\n\treturn (first_minor/BCACHE_MINORS);\n}\n\nstatic inline int idx_to_first_minor(int idx)\n{\n\treturn (idx * BCACHE_MINORS);\n}\n\nstatic void bcache_device_free(struct bcache_device *d)\n{\n\tstruct gendisk *disk = d->disk;\n\n\tlockdep_assert_held(&bch_register_lock);\n\n\tif (disk)\n\t\tpr_info(\"%s stopped\\n\", disk->disk_name);\n\telse\n\t\tpr_err(\"bcache device (NULL gendisk) stopped\\n\");\n\n\tif (d->c)\n\t\tbcache_device_detach(d);\n\n\tif (disk) {\n\t\tida_simple_remove(&bcache_device_idx,\n\t\t\t\t  first_minor_to_idx(disk->first_minor));\n\t\tput_disk(disk);\n\t}\n\n\tbioset_exit(&d->bio_split);\n\tkvfree(d->full_dirty_stripes);\n\tkvfree(d->stripe_sectors_dirty);\n\n\tclosure_debug_destroy(&d->cl);\n}\n\nstatic int bcache_device_init(struct bcache_device *d, unsigned int block_size,\n\t\tsector_t sectors, struct block_device *cached_bdev,\n\t\tconst struct block_device_operations *ops)\n{\n\tstruct request_queue *q;\n\tconst size_t max_stripes = min_t(size_t, INT_MAX,\n\t\t\t\t\t SIZE_MAX / sizeof(atomic_t));\n\tuint64_t n;\n\tint idx;\n\n\tif (!d->stripe_size)\n\t\td->stripe_size = 1 << 31;\n\telse if (d->stripe_size < BCH_MIN_STRIPE_SZ)\n\t\td->stripe_size = roundup(BCH_MIN_STRIPE_SZ, d->stripe_size);\n\n\tn = DIV_ROUND_UP_ULL(sectors, d->stripe_size);\n\tif (!n || n > max_stripes) {\n\t\tpr_err(\"nr_stripes too large or invalid: %llu (start sector beyond end of disk?)\\n\",\n\t\t\tn);\n\t\treturn -ENOMEM;\n\t}\n\td->nr_stripes = n;\n\n\tn = d->nr_stripes * sizeof(atomic_t);\n\td->stripe_sectors_dirty = kvzalloc(n, GFP_KERNEL);\n\tif (!d->stripe_sectors_dirty)\n\t\treturn -ENOMEM;\n\n\tn = BITS_TO_LONGS(d->nr_stripes) * sizeof(unsigned long);\n\td->full_dirty_stripes = kvzalloc(n, GFP_KERNEL);\n\tif (!d->full_dirty_stripes)\n\t\tgoto out_free_stripe_sectors_dirty;\n\n\tidx = ida_simple_get(&bcache_device_idx, 0,\n\t\t\t\tBCACHE_DEVICE_IDX_MAX, GFP_KERNEL);\n\tif (idx < 0)\n\t\tgoto out_free_full_dirty_stripes;\n\n\tif (bioset_init(&d->bio_split, 4, offsetof(struct bbio, bio),\n\t\t\tBIOSET_NEED_BVECS|BIOSET_NEED_RESCUER))\n\t\tgoto out_ida_remove;\n\n\td->disk = blk_alloc_disk(NUMA_NO_NODE);\n\tif (!d->disk)\n\t\tgoto out_bioset_exit;\n\n\tset_capacity(d->disk, sectors);\n\tsnprintf(d->disk->disk_name, DISK_NAME_LEN, \"bcache%i\", idx);\n\n\td->disk->major\t\t= bcache_major;\n\td->disk->first_minor\t= idx_to_first_minor(idx);\n\td->disk->minors\t\t= BCACHE_MINORS;\n\td->disk->fops\t\t= ops;\n\td->disk->private_data\t= d;\n\n\tq = d->disk->queue;\n\tq->limits.max_hw_sectors\t= UINT_MAX;\n\tq->limits.max_sectors\t\t= UINT_MAX;\n\tq->limits.max_segment_size\t= UINT_MAX;\n\tq->limits.max_segments\t\t= BIO_MAX_VECS;\n\tblk_queue_max_discard_sectors(q, UINT_MAX);\n\tq->limits.discard_granularity\t= 512;\n\tq->limits.io_min\t\t= block_size;\n\tq->limits.logical_block_size\t= block_size;\n\tq->limits.physical_block_size\t= block_size;\n\n\tif (q->limits.logical_block_size > PAGE_SIZE && cached_bdev) {\n\t\t \n\t\tpr_info(\"%s: sb/logical block size (%u) greater than page size (%lu) falling back to device logical block size (%u)\\n\",\n\t\t\td->disk->disk_name, q->limits.logical_block_size,\n\t\t\tPAGE_SIZE, bdev_logical_block_size(cached_bdev));\n\n\t\t \n\t\tblk_queue_logical_block_size(q, bdev_logical_block_size(cached_bdev));\n\t}\n\n\tblk_queue_flag_set(QUEUE_FLAG_NONROT, d->disk->queue);\n\n\tblk_queue_write_cache(q, true, true);\n\n\treturn 0;\n\nout_bioset_exit:\n\tbioset_exit(&d->bio_split);\nout_ida_remove:\n\tida_simple_remove(&bcache_device_idx, idx);\nout_free_full_dirty_stripes:\n\tkvfree(d->full_dirty_stripes);\nout_free_stripe_sectors_dirty:\n\tkvfree(d->stripe_sectors_dirty);\n\treturn -ENOMEM;\n\n}\n\n \n\nstatic void calc_cached_dev_sectors(struct cache_set *c)\n{\n\tuint64_t sectors = 0;\n\tstruct cached_dev *dc;\n\n\tlist_for_each_entry(dc, &c->cached_devs, list)\n\t\tsectors += bdev_nr_sectors(dc->bdev);\n\n\tc->cached_dev_sectors = sectors;\n}\n\n#define BACKING_DEV_OFFLINE_TIMEOUT 5\nstatic int cached_dev_status_update(void *arg)\n{\n\tstruct cached_dev *dc = arg;\n\tstruct request_queue *q;\n\n\t \n\twhile (!kthread_should_stop() && !dc->io_disable) {\n\t\tq = bdev_get_queue(dc->bdev);\n\t\tif (blk_queue_dying(q))\n\t\t\tdc->offline_seconds++;\n\t\telse\n\t\t\tdc->offline_seconds = 0;\n\n\t\tif (dc->offline_seconds >= BACKING_DEV_OFFLINE_TIMEOUT) {\n\t\t\tpr_err(\"%pg: device offline for %d seconds\\n\",\n\t\t\t       dc->bdev,\n\t\t\t       BACKING_DEV_OFFLINE_TIMEOUT);\n\t\t\tpr_err(\"%s: disable I/O request due to backing device offline\\n\",\n\t\t\t       dc->disk.name);\n\t\t\tdc->io_disable = true;\n\t\t\t \n\t\t\tsmp_mb();\n\t\t\tbcache_device_stop(&dc->disk);\n\t\t\tbreak;\n\t\t}\n\t\tschedule_timeout_interruptible(HZ);\n\t}\n\n\twait_for_kthread_stop();\n\treturn 0;\n}\n\n\nint bch_cached_dev_run(struct cached_dev *dc)\n{\n\tint ret = 0;\n\tstruct bcache_device *d = &dc->disk;\n\tchar *buf = kmemdup_nul(dc->sb.label, SB_LABEL_SIZE, GFP_KERNEL);\n\tchar *env[] = {\n\t\t\"DRIVER=bcache\",\n\t\tkasprintf(GFP_KERNEL, \"CACHED_UUID=%pU\", dc->sb.uuid),\n\t\tkasprintf(GFP_KERNEL, \"CACHED_LABEL=%s\", buf ? : \"\"),\n\t\tNULL,\n\t};\n\n\tif (dc->io_disable) {\n\t\tpr_err(\"I/O disabled on cached dev %pg\\n\", dc->bdev);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (atomic_xchg(&dc->running, 1)) {\n\t\tpr_info(\"cached dev %pg is running already\\n\", dc->bdev);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (!d->c &&\n\t    BDEV_STATE(&dc->sb) != BDEV_STATE_NONE) {\n\t\tstruct closure cl;\n\n\t\tclosure_init_stack(&cl);\n\n\t\tSET_BDEV_STATE(&dc->sb, BDEV_STATE_STALE);\n\t\tbch_write_bdev_super(dc, &cl);\n\t\tclosure_sync(&cl);\n\t}\n\n\tret = add_disk(d->disk);\n\tif (ret)\n\t\tgoto out;\n\tbd_link_disk_holder(dc->bdev, dc->disk.disk);\n\t \n\tkobject_uevent_env(&disk_to_dev(d->disk)->kobj, KOBJ_CHANGE, env);\n\n\tif (sysfs_create_link(&d->kobj, &disk_to_dev(d->disk)->kobj, \"dev\") ||\n\t    sysfs_create_link(&disk_to_dev(d->disk)->kobj,\n\t\t\t      &d->kobj, \"bcache\")) {\n\t\tpr_err(\"Couldn't create bcache dev <-> disk sysfs symlinks\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdc->status_update_thread = kthread_run(cached_dev_status_update,\n\t\t\t\t\t       dc, \"bcache_status_update\");\n\tif (IS_ERR(dc->status_update_thread)) {\n\t\tpr_warn(\"failed to create bcache_status_update kthread, continue to run without monitoring backing device status\\n\");\n\t}\n\nout:\n\tkfree(env[1]);\n\tkfree(env[2]);\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic void cancel_writeback_rate_update_dwork(struct cached_dev *dc)\n{\n\tint time_out = WRITEBACK_RATE_UPDATE_SECS_MAX * HZ;\n\n\tdo {\n\t\tif (!test_bit(BCACHE_DEV_RATE_DW_RUNNING,\n\t\t\t      &dc->disk.flags))\n\t\t\tbreak;\n\t\ttime_out--;\n\t\tschedule_timeout_interruptible(1);\n\t} while (time_out > 0);\n\n\tif (time_out == 0)\n\t\tpr_warn(\"give up waiting for dc->writeback_write_update to quit\\n\");\n\n\tcancel_delayed_work_sync(&dc->writeback_rate_update);\n}\n\nstatic void cached_dev_detach_finish(struct work_struct *w)\n{\n\tstruct cached_dev *dc = container_of(w, struct cached_dev, detach);\n\tstruct cache_set *c = dc->disk.c;\n\n\tBUG_ON(!test_bit(BCACHE_DEV_DETACHING, &dc->disk.flags));\n\tBUG_ON(refcount_read(&dc->count));\n\n\n\tif (test_and_clear_bit(BCACHE_DEV_WB_RUNNING, &dc->disk.flags))\n\t\tcancel_writeback_rate_update_dwork(dc);\n\n\tif (!IS_ERR_OR_NULL(dc->writeback_thread)) {\n\t\tkthread_stop(dc->writeback_thread);\n\t\tdc->writeback_thread = NULL;\n\t}\n\n\tmutex_lock(&bch_register_lock);\n\n\tbcache_device_detach(&dc->disk);\n\tlist_move(&dc->list, &uncached_devices);\n\tcalc_cached_dev_sectors(c);\n\n\tclear_bit(BCACHE_DEV_DETACHING, &dc->disk.flags);\n\tclear_bit(BCACHE_DEV_UNLINK_DONE, &dc->disk.flags);\n\n\tmutex_unlock(&bch_register_lock);\n\n\tpr_info(\"Caching disabled for %pg\\n\", dc->bdev);\n\n\t \n\tclosure_put(&dc->disk.cl);\n}\n\nvoid bch_cached_dev_detach(struct cached_dev *dc)\n{\n\tlockdep_assert_held(&bch_register_lock);\n\n\tif (test_bit(BCACHE_DEV_CLOSING, &dc->disk.flags))\n\t\treturn;\n\n\tif (test_and_set_bit(BCACHE_DEV_DETACHING, &dc->disk.flags))\n\t\treturn;\n\n\t \n\tclosure_get(&dc->disk.cl);\n\n\tbch_writeback_queue(dc);\n\n\tcached_dev_put(dc);\n}\n\nint bch_cached_dev_attach(struct cached_dev *dc, struct cache_set *c,\n\t\t\t  uint8_t *set_uuid)\n{\n\tuint32_t rtime = cpu_to_le32((u32)ktime_get_real_seconds());\n\tstruct uuid_entry *u;\n\tstruct cached_dev *exist_dc, *t;\n\tint ret = 0;\n\n\tif ((set_uuid && memcmp(set_uuid, c->set_uuid, 16)) ||\n\t    (!set_uuid && memcmp(dc->sb.set_uuid, c->set_uuid, 16)))\n\t\treturn -ENOENT;\n\n\tif (dc->disk.c) {\n\t\tpr_err(\"Can't attach %pg: already attached\\n\", dc->bdev);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_bit(CACHE_SET_STOPPING, &c->flags)) {\n\t\tpr_err(\"Can't attach %pg: shutting down\\n\", dc->bdev);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dc->sb.block_size < c->cache->sb.block_size) {\n\t\t \n\t\tpr_err(\"Couldn't attach %pg: block size less than set's block size\\n\",\n\t\t       dc->bdev);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlist_for_each_entry_safe(exist_dc, t, &c->cached_devs, list) {\n\t\tif (!memcmp(dc->sb.uuid, exist_dc->sb.uuid, 16)) {\n\t\t\tpr_err(\"Tried to attach %pg but duplicate UUID already attached\\n\",\n\t\t\t\tdc->bdev);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tu = uuid_find(c, dc->sb.uuid);\n\n\tif (u &&\n\t    (BDEV_STATE(&dc->sb) == BDEV_STATE_STALE ||\n\t     BDEV_STATE(&dc->sb) == BDEV_STATE_NONE)) {\n\t\tmemcpy(u->uuid, invalid_uuid, 16);\n\t\tu->invalidated = cpu_to_le32((u32)ktime_get_real_seconds());\n\t\tu = NULL;\n\t}\n\n\tif (!u) {\n\t\tif (BDEV_STATE(&dc->sb) == BDEV_STATE_DIRTY) {\n\t\t\tpr_err(\"Couldn't find uuid for %pg in set\\n\", dc->bdev);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tu = uuid_find_empty(c);\n\t\tif (!u) {\n\t\t\tpr_err(\"Not caching %pg, no room for UUID\\n\", dc->bdev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\n\tif (bch_is_zero(u->uuid, 16)) {\n\t\tstruct closure cl;\n\n\t\tclosure_init_stack(&cl);\n\n\t\tmemcpy(u->uuid, dc->sb.uuid, 16);\n\t\tmemcpy(u->label, dc->sb.label, SB_LABEL_SIZE);\n\t\tu->first_reg = u->last_reg = rtime;\n\t\tbch_uuid_write(c);\n\n\t\tmemcpy(dc->sb.set_uuid, c->set_uuid, 16);\n\t\tSET_BDEV_STATE(&dc->sb, BDEV_STATE_CLEAN);\n\n\t\tbch_write_bdev_super(dc, &cl);\n\t\tclosure_sync(&cl);\n\t} else {\n\t\tu->last_reg = rtime;\n\t\tbch_uuid_write(c);\n\t}\n\n\tbcache_device_attach(&dc->disk, c, u - c->uuids);\n\tlist_move(&dc->list, &c->cached_devs);\n\tcalc_cached_dev_sectors(c);\n\n\t \n\tsmp_wmb();\n\trefcount_set(&dc->count, 1);\n\n\t \n\tdown_write(&dc->writeback_lock);\n\tif (bch_cached_dev_writeback_start(dc)) {\n\t\tup_write(&dc->writeback_lock);\n\t\tpr_err(\"Couldn't start writeback facilities for %s\\n\",\n\t\t       dc->disk.disk->disk_name);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (BDEV_STATE(&dc->sb) == BDEV_STATE_DIRTY) {\n\t\tatomic_set(&dc->has_dirty, 1);\n\t\tbch_writeback_queue(dc);\n\t}\n\n\tbch_sectors_dirty_init(&dc->disk);\n\n\tret = bch_cached_dev_run(dc);\n\tif (ret && (ret != -EBUSY)) {\n\t\tup_write(&dc->writeback_lock);\n\t\t \n\t\tkthread_stop(dc->writeback_thread);\n\t\tcancel_writeback_rate_update_dwork(dc);\n\t\tpr_err(\"Couldn't run cached device %pg\\n\", dc->bdev);\n\t\treturn ret;\n\t}\n\n\tbcache_device_link(&dc->disk, c, \"bdev\");\n\tatomic_inc(&c->attached_dev_nr);\n\n\tif (bch_has_feature_obso_large_bucket(&(c->cache->sb))) {\n\t\tpr_err(\"The obsoleted large bucket layout is unsupported, set the bcache device into read-only\\n\");\n\t\tpr_err(\"Please update to the latest bcache-tools to create the cache device\\n\");\n\t\tset_disk_ro(dc->disk.disk, 1);\n\t}\n\n\t \n\tup_write(&dc->writeback_lock);\n\n\tpr_info(\"Caching %pg as %s on set %pU\\n\",\n\t\tdc->bdev,\n\t\tdc->disk.disk->disk_name,\n\t\tdc->disk.c->set_uuid);\n\treturn 0;\n}\n\n \nvoid bch_cached_dev_release(struct kobject *kobj)\n{\n\tstruct cached_dev *dc = container_of(kobj, struct cached_dev,\n\t\t\t\t\t     disk.kobj);\n\tkfree(dc);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic void cached_dev_free(struct closure *cl)\n{\n\tstruct cached_dev *dc = container_of(cl, struct cached_dev, disk.cl);\n\n\tif (test_and_clear_bit(BCACHE_DEV_WB_RUNNING, &dc->disk.flags))\n\t\tcancel_writeback_rate_update_dwork(dc);\n\n\tif (!IS_ERR_OR_NULL(dc->writeback_thread))\n\t\tkthread_stop(dc->writeback_thread);\n\tif (!IS_ERR_OR_NULL(dc->status_update_thread))\n\t\tkthread_stop(dc->status_update_thread);\n\n\tmutex_lock(&bch_register_lock);\n\n\tif (atomic_read(&dc->running)) {\n\t\tbd_unlink_disk_holder(dc->bdev, dc->disk.disk);\n\t\tdel_gendisk(dc->disk.disk);\n\t}\n\tbcache_device_free(&dc->disk);\n\tlist_del(&dc->list);\n\n\tmutex_unlock(&bch_register_lock);\n\n\tif (dc->sb_disk)\n\t\tput_page(virt_to_page(dc->sb_disk));\n\n\tif (!IS_ERR_OR_NULL(dc->bdev))\n\t\tblkdev_put(dc->bdev, dc);\n\n\twake_up(&unregister_wait);\n\n\tkobject_put(&dc->disk.kobj);\n}\n\nstatic void cached_dev_flush(struct closure *cl)\n{\n\tstruct cached_dev *dc = container_of(cl, struct cached_dev, disk.cl);\n\tstruct bcache_device *d = &dc->disk;\n\n\tmutex_lock(&bch_register_lock);\n\tbcache_device_unlink(d);\n\tmutex_unlock(&bch_register_lock);\n\n\tbch_cache_accounting_destroy(&dc->accounting);\n\tkobject_del(&d->kobj);\n\n\tcontinue_at(cl, cached_dev_free, system_wq);\n}\n\nstatic int cached_dev_init(struct cached_dev *dc, unsigned int block_size)\n{\n\tint ret;\n\tstruct io *io;\n\tstruct request_queue *q = bdev_get_queue(dc->bdev);\n\n\t__module_get(THIS_MODULE);\n\tINIT_LIST_HEAD(&dc->list);\n\tclosure_init(&dc->disk.cl, NULL);\n\tset_closure_fn(&dc->disk.cl, cached_dev_flush, system_wq);\n\tkobject_init(&dc->disk.kobj, &bch_cached_dev_ktype);\n\tINIT_WORK(&dc->detach, cached_dev_detach_finish);\n\tsema_init(&dc->sb_write_mutex, 1);\n\tINIT_LIST_HEAD(&dc->io_lru);\n\tspin_lock_init(&dc->io_lock);\n\tbch_cache_accounting_init(&dc->accounting, &dc->disk.cl);\n\n\tdc->sequential_cutoff\t\t= 4 << 20;\n\n\tfor (io = dc->io; io < dc->io + RECENT_IO; io++) {\n\t\tlist_add(&io->lru, &dc->io_lru);\n\t\thlist_add_head(&io->hash, dc->io_hash + RECENT_IO);\n\t}\n\n\tdc->disk.stripe_size = q->limits.io_opt >> 9;\n\n\tif (dc->disk.stripe_size)\n\t\tdc->partial_stripes_expensive =\n\t\t\tq->limits.raid_partial_stripes_expensive;\n\n\tret = bcache_device_init(&dc->disk, block_size,\n\t\t\t bdev_nr_sectors(dc->bdev) - dc->sb.data_offset,\n\t\t\t dc->bdev, &bcache_cached_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tblk_queue_io_opt(dc->disk.disk->queue,\n\t\tmax(queue_io_opt(dc->disk.disk->queue), queue_io_opt(q)));\n\n\tatomic_set(&dc->io_errors, 0);\n\tdc->io_disable = false;\n\tdc->error_limit = DEFAULT_CACHED_DEV_ERROR_LIMIT;\n\t \n\tdc->stop_when_cache_set_failed = BCH_CACHED_DEV_STOP_AUTO;\n\n\tbch_cached_dev_request_init(dc);\n\tbch_cached_dev_writeback_init(dc);\n\treturn 0;\n}\n\n \n\nstatic int register_bdev(struct cache_sb *sb, struct cache_sb_disk *sb_disk,\n\t\t\t\t struct block_device *bdev,\n\t\t\t\t struct cached_dev *dc)\n{\n\tconst char *err = \"cannot allocate memory\";\n\tstruct cache_set *c;\n\tint ret = -ENOMEM;\n\n\tmemcpy(&dc->sb, sb, sizeof(struct cache_sb));\n\tdc->bdev = bdev;\n\tdc->sb_disk = sb_disk;\n\n\tif (cached_dev_init(dc, sb->block_size << 9))\n\t\tgoto err;\n\n\terr = \"error creating kobject\";\n\tif (kobject_add(&dc->disk.kobj, bdev_kobj(bdev), \"bcache\"))\n\t\tgoto err;\n\tif (bch_cache_accounting_add_kobjs(&dc->accounting, &dc->disk.kobj))\n\t\tgoto err;\n\n\tpr_info(\"registered backing device %pg\\n\", dc->bdev);\n\n\tlist_add(&dc->list, &uncached_devices);\n\t \n\tlist_for_each_entry(c, &bch_cache_sets, list)\n\t\tbch_cached_dev_attach(dc, c, NULL);\n\n\tif (BDEV_STATE(&dc->sb) == BDEV_STATE_NONE ||\n\t    BDEV_STATE(&dc->sb) == BDEV_STATE_STALE) {\n\t\terr = \"failed to run cached device\";\n\t\tret = bch_cached_dev_run(dc);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tpr_notice(\"error %pg: %s\\n\", dc->bdev, err);\n\tbcache_device_stop(&dc->disk);\n\treturn ret;\n}\n\n \n\n \nvoid bch_flash_dev_release(struct kobject *kobj)\n{\n\tstruct bcache_device *d = container_of(kobj, struct bcache_device,\n\t\t\t\t\t       kobj);\n\tkfree(d);\n}\n\nstatic void flash_dev_free(struct closure *cl)\n{\n\tstruct bcache_device *d = container_of(cl, struct bcache_device, cl);\n\n\tmutex_lock(&bch_register_lock);\n\tatomic_long_sub(bcache_dev_sectors_dirty(d),\n\t\t\t&d->c->flash_dev_dirty_sectors);\n\tdel_gendisk(d->disk);\n\tbcache_device_free(d);\n\tmutex_unlock(&bch_register_lock);\n\tkobject_put(&d->kobj);\n}\n\nstatic void flash_dev_flush(struct closure *cl)\n{\n\tstruct bcache_device *d = container_of(cl, struct bcache_device, cl);\n\n\tmutex_lock(&bch_register_lock);\n\tbcache_device_unlink(d);\n\tmutex_unlock(&bch_register_lock);\n\tkobject_del(&d->kobj);\n\tcontinue_at(cl, flash_dev_free, system_wq);\n}\n\nstatic int flash_dev_run(struct cache_set *c, struct uuid_entry *u)\n{\n\tint err = -ENOMEM;\n\tstruct bcache_device *d = kzalloc(sizeof(struct bcache_device),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!d)\n\t\tgoto err_ret;\n\n\tclosure_init(&d->cl, NULL);\n\tset_closure_fn(&d->cl, flash_dev_flush, system_wq);\n\n\tkobject_init(&d->kobj, &bch_flash_dev_ktype);\n\n\tif (bcache_device_init(d, block_bytes(c->cache), u->sectors,\n\t\t\tNULL, &bcache_flash_ops))\n\t\tgoto err;\n\n\tbcache_device_attach(d, c, u - c->uuids);\n\tbch_sectors_dirty_init(d);\n\tbch_flash_dev_request_init(d);\n\terr = add_disk(d->disk);\n\tif (err)\n\t\tgoto err;\n\n\terr = kobject_add(&d->kobj, &disk_to_dev(d->disk)->kobj, \"bcache\");\n\tif (err)\n\t\tgoto err;\n\n\tbcache_device_link(d, c, \"volume\");\n\n\tif (bch_has_feature_obso_large_bucket(&c->cache->sb)) {\n\t\tpr_err(\"The obsoleted large bucket layout is unsupported, set the bcache device into read-only\\n\");\n\t\tpr_err(\"Please update to the latest bcache-tools to create the cache device\\n\");\n\t\tset_disk_ro(d->disk, 1);\n\t}\n\n\treturn 0;\nerr:\n\tkobject_put(&d->kobj);\nerr_ret:\n\treturn err;\n}\n\nstatic int flash_devs_run(struct cache_set *c)\n{\n\tint ret = 0;\n\tstruct uuid_entry *u;\n\n\tfor (u = c->uuids;\n\t     u < c->uuids + c->nr_uuids && !ret;\n\t     u++)\n\t\tif (UUID_FLASH_ONLY(u))\n\t\t\tret = flash_dev_run(c, u);\n\n\treturn ret;\n}\n\nint bch_flash_dev_create(struct cache_set *c, uint64_t size)\n{\n\tstruct uuid_entry *u;\n\n\tif (test_bit(CACHE_SET_STOPPING, &c->flags))\n\t\treturn -EINTR;\n\n\tif (!test_bit(CACHE_SET_RUNNING, &c->flags))\n\t\treturn -EPERM;\n\n\tu = uuid_find_empty(c);\n\tif (!u) {\n\t\tpr_err(\"Can't create volume, no room for UUID\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tget_random_bytes(u->uuid, 16);\n\tmemset(u->label, 0, 32);\n\tu->first_reg = u->last_reg = cpu_to_le32((u32)ktime_get_real_seconds());\n\n\tSET_UUID_FLASH_ONLY(u, 1);\n\tu->sectors = size >> 9;\n\n\tbch_uuid_write(c);\n\n\treturn flash_dev_run(c, u);\n}\n\nbool bch_cached_dev_error(struct cached_dev *dc)\n{\n\tif (!dc || test_bit(BCACHE_DEV_CLOSING, &dc->disk.flags))\n\t\treturn false;\n\n\tdc->io_disable = true;\n\t \n\tsmp_mb();\n\n\tpr_err(\"stop %s: too many IO errors on backing device %pg\\n\",\n\t       dc->disk.disk->disk_name, dc->bdev);\n\n\tbcache_device_stop(&dc->disk);\n\treturn true;\n}\n\n \n\n__printf(2, 3)\nbool bch_cache_set_error(struct cache_set *c, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (c->on_error != ON_ERROR_PANIC &&\n\t    test_bit(CACHE_SET_STOPPING, &c->flags))\n\t\treturn false;\n\n\tif (test_and_set_bit(CACHE_SET_IO_DISABLE, &c->flags))\n\t\tpr_info(\"CACHE_SET_IO_DISABLE already set\\n\");\n\n\t \n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error on %pU: %pV, disabling caching\\n\",\n\t       c->set_uuid, &vaf);\n\n\tva_end(args);\n\n\tif (c->on_error == ON_ERROR_PANIC)\n\t\tpanic(\"panic forced after error\\n\");\n\n\tbch_cache_set_unregister(c);\n\treturn true;\n}\n\n \nvoid bch_cache_set_release(struct kobject *kobj)\n{\n\tstruct cache_set *c = container_of(kobj, struct cache_set, kobj);\n\n\tkfree(c);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic void cache_set_free(struct closure *cl)\n{\n\tstruct cache_set *c = container_of(cl, struct cache_set, cl);\n\tstruct cache *ca;\n\n\tdebugfs_remove(c->debug);\n\n\tbch_open_buckets_free(c);\n\tbch_btree_cache_free(c);\n\tbch_journal_free(c);\n\n\tmutex_lock(&bch_register_lock);\n\tbch_bset_sort_state_free(&c->sort);\n\tfree_pages((unsigned long) c->uuids, ilog2(meta_bucket_pages(&c->cache->sb)));\n\n\tca = c->cache;\n\tif (ca) {\n\t\tca->set = NULL;\n\t\tc->cache = NULL;\n\t\tkobject_put(&ca->kobj);\n\t}\n\n\n\tif (c->moving_gc_wq)\n\t\tdestroy_workqueue(c->moving_gc_wq);\n\tbioset_exit(&c->bio_split);\n\tmempool_exit(&c->fill_iter);\n\tmempool_exit(&c->bio_meta);\n\tmempool_exit(&c->search);\n\tkfree(c->devices);\n\n\tlist_del(&c->list);\n\tmutex_unlock(&bch_register_lock);\n\n\tpr_info(\"Cache set %pU unregistered\\n\", c->set_uuid);\n\twake_up(&unregister_wait);\n\n\tclosure_debug_destroy(&c->cl);\n\tkobject_put(&c->kobj);\n}\n\nstatic void cache_set_flush(struct closure *cl)\n{\n\tstruct cache_set *c = container_of(cl, struct cache_set, caching);\n\tstruct cache *ca = c->cache;\n\tstruct btree *b;\n\n\tbch_cache_accounting_destroy(&c->accounting);\n\n\tkobject_put(&c->internal);\n\tkobject_del(&c->kobj);\n\n\tif (!IS_ERR_OR_NULL(c->gc_thread))\n\t\tkthread_stop(c->gc_thread);\n\n\tif (!IS_ERR(c->root))\n\t\tlist_add(&c->root->list, &c->btree_cache);\n\n\t \n\tif (!test_bit(CACHE_SET_IO_DISABLE, &c->flags))\n\t\tlist_for_each_entry(b, &c->btree_cache, list) {\n\t\t\tmutex_lock(&b->write_lock);\n\t\t\tif (btree_node_dirty(b))\n\t\t\t\t__bch_btree_node_write(b, NULL);\n\t\t\tmutex_unlock(&b->write_lock);\n\t\t}\n\n\tif (ca->alloc_thread)\n\t\tkthread_stop(ca->alloc_thread);\n\n\tif (c->journal.cur) {\n\t\tcancel_delayed_work_sync(&c->journal.work);\n\t\t \n\t\tc->journal.work.work.func(&c->journal.work.work);\n\t}\n\n\tclosure_return(cl);\n}\n\n \nstatic void conditional_stop_bcache_device(struct cache_set *c,\n\t\t\t\t\t   struct bcache_device *d,\n\t\t\t\t\t   struct cached_dev *dc)\n{\n\tif (dc->stop_when_cache_set_failed == BCH_CACHED_DEV_STOP_ALWAYS) {\n\t\tpr_warn(\"stop_when_cache_set_failed of %s is \\\"always\\\", stop it for failed cache set %pU.\\n\",\n\t\t\td->disk->disk_name, c->set_uuid);\n\t\tbcache_device_stop(d);\n\t} else if (atomic_read(&dc->has_dirty)) {\n\t\t \n\t\tpr_warn(\"stop_when_cache_set_failed of %s is \\\"auto\\\" and cache is dirty, stop it to avoid potential data corruption.\\n\",\n\t\t\td->disk->disk_name);\n\t\t \n\t\tdc->io_disable = true;\n\t\t \n\t\tsmp_mb();\n\t\tbcache_device_stop(d);\n\t} else {\n\t\t \n\t\tpr_warn(\"stop_when_cache_set_failed of %s is \\\"auto\\\" and cache is clean, keep it alive.\\n\",\n\t\t\td->disk->disk_name);\n\t}\n}\n\nstatic void __cache_set_unregister(struct closure *cl)\n{\n\tstruct cache_set *c = container_of(cl, struct cache_set, caching);\n\tstruct cached_dev *dc;\n\tstruct bcache_device *d;\n\tsize_t i;\n\n\tmutex_lock(&bch_register_lock);\n\n\tfor (i = 0; i < c->devices_max_used; i++) {\n\t\td = c->devices[i];\n\t\tif (!d)\n\t\t\tcontinue;\n\n\t\tif (!UUID_FLASH_ONLY(&c->uuids[i]) &&\n\t\t    test_bit(CACHE_SET_UNREGISTERING, &c->flags)) {\n\t\t\tdc = container_of(d, struct cached_dev, disk);\n\t\t\tbch_cached_dev_detach(dc);\n\t\t\tif (test_bit(CACHE_SET_IO_DISABLE, &c->flags))\n\t\t\t\tconditional_stop_bcache_device(c, d, dc);\n\t\t} else {\n\t\t\tbcache_device_stop(d);\n\t\t}\n\t}\n\n\tmutex_unlock(&bch_register_lock);\n\n\tcontinue_at(cl, cache_set_flush, system_wq);\n}\n\nvoid bch_cache_set_stop(struct cache_set *c)\n{\n\tif (!test_and_set_bit(CACHE_SET_STOPPING, &c->flags))\n\t\t \n\t\tclosure_queue(&c->caching);\n}\n\nvoid bch_cache_set_unregister(struct cache_set *c)\n{\n\tset_bit(CACHE_SET_UNREGISTERING, &c->flags);\n\tbch_cache_set_stop(c);\n}\n\n#define alloc_meta_bucket_pages(gfp, sb)\t\t\\\n\t((void *) __get_free_pages(__GFP_ZERO|__GFP_COMP|gfp, ilog2(meta_bucket_pages(sb))))\n\nstruct cache_set *bch_cache_set_alloc(struct cache_sb *sb)\n{\n\tint iter_size;\n\tstruct cache *ca = container_of(sb, struct cache, sb);\n\tstruct cache_set *c = kzalloc(sizeof(struct cache_set), GFP_KERNEL);\n\n\tif (!c)\n\t\treturn NULL;\n\n\t__module_get(THIS_MODULE);\n\tclosure_init(&c->cl, NULL);\n\tset_closure_fn(&c->cl, cache_set_free, system_wq);\n\n\tclosure_init(&c->caching, &c->cl);\n\tset_closure_fn(&c->caching, __cache_set_unregister, system_wq);\n\n\t \n\tclosure_set_stopped(&c->cl);\n\tclosure_put(&c->cl);\n\n\tkobject_init(&c->kobj, &bch_cache_set_ktype);\n\tkobject_init(&c->internal, &bch_cache_set_internal_ktype);\n\n\tbch_cache_accounting_init(&c->accounting, &c->cl);\n\n\tmemcpy(c->set_uuid, sb->set_uuid, 16);\n\n\tc->cache\t\t= ca;\n\tc->cache->set\t\t= c;\n\tc->bucket_bits\t\t= ilog2(sb->bucket_size);\n\tc->block_bits\t\t= ilog2(sb->block_size);\n\tc->nr_uuids\t\t= meta_bucket_bytes(sb) / sizeof(struct uuid_entry);\n\tc->devices_max_used\t= 0;\n\tatomic_set(&c->attached_dev_nr, 0);\n\tc->btree_pages\t\t= meta_bucket_pages(sb);\n\tif (c->btree_pages > BTREE_MAX_PAGES)\n\t\tc->btree_pages = max_t(int, c->btree_pages / 4,\n\t\t\t\t       BTREE_MAX_PAGES);\n\n\tsema_init(&c->sb_write_mutex, 1);\n\tmutex_init(&c->bucket_lock);\n\tinit_waitqueue_head(&c->btree_cache_wait);\n\tspin_lock_init(&c->btree_cannibalize_lock);\n\tinit_waitqueue_head(&c->bucket_wait);\n\tinit_waitqueue_head(&c->gc_wait);\n\tsema_init(&c->uuid_write_mutex, 1);\n\n\tspin_lock_init(&c->btree_gc_time.lock);\n\tspin_lock_init(&c->btree_split_time.lock);\n\tspin_lock_init(&c->btree_read_time.lock);\n\n\tbch_moving_init_cache_set(c);\n\n\tINIT_LIST_HEAD(&c->list);\n\tINIT_LIST_HEAD(&c->cached_devs);\n\tINIT_LIST_HEAD(&c->btree_cache);\n\tINIT_LIST_HEAD(&c->btree_cache_freeable);\n\tINIT_LIST_HEAD(&c->btree_cache_freed);\n\tINIT_LIST_HEAD(&c->data_buckets);\n\n\titer_size = ((meta_bucket_pages(sb) * PAGE_SECTORS) / sb->block_size + 1) *\n\t\tsizeof(struct btree_iter_set);\n\n\tc->devices = kcalloc(c->nr_uuids, sizeof(void *), GFP_KERNEL);\n\tif (!c->devices)\n\t\tgoto err;\n\n\tif (mempool_init_slab_pool(&c->search, 32, bch_search_cache))\n\t\tgoto err;\n\n\tif (mempool_init_kmalloc_pool(&c->bio_meta, 2,\n\t\t\tsizeof(struct bbio) +\n\t\t\tsizeof(struct bio_vec) * meta_bucket_pages(sb)))\n\t\tgoto err;\n\n\tif (mempool_init_kmalloc_pool(&c->fill_iter, 1, iter_size))\n\t\tgoto err;\n\n\tif (bioset_init(&c->bio_split, 4, offsetof(struct bbio, bio),\n\t\t\tBIOSET_NEED_RESCUER))\n\t\tgoto err;\n\n\tc->uuids = alloc_meta_bucket_pages(GFP_KERNEL, sb);\n\tif (!c->uuids)\n\t\tgoto err;\n\n\tc->moving_gc_wq = alloc_workqueue(\"bcache_gc\", WQ_MEM_RECLAIM, 0);\n\tif (!c->moving_gc_wq)\n\t\tgoto err;\n\n\tif (bch_journal_alloc(c))\n\t\tgoto err;\n\n\tif (bch_btree_cache_alloc(c))\n\t\tgoto err;\n\n\tif (bch_open_buckets_alloc(c))\n\t\tgoto err;\n\n\tif (bch_bset_sort_state_init(&c->sort, ilog2(c->btree_pages)))\n\t\tgoto err;\n\n\tc->congested_read_threshold_us\t= 2000;\n\tc->congested_write_threshold_us\t= 20000;\n\tc->error_limit\t= DEFAULT_IO_ERROR_LIMIT;\n\tc->idle_max_writeback_rate_enabled = 1;\n\tWARN_ON(test_and_clear_bit(CACHE_SET_IO_DISABLE, &c->flags));\n\n\treturn c;\nerr:\n\tbch_cache_set_unregister(c);\n\treturn NULL;\n}\n\nstatic int run_cache_set(struct cache_set *c)\n{\n\tconst char *err = \"cannot allocate memory\";\n\tstruct cached_dev *dc, *t;\n\tstruct cache *ca = c->cache;\n\tstruct closure cl;\n\tLIST_HEAD(journal);\n\tstruct journal_replay *l;\n\n\tclosure_init_stack(&cl);\n\n\tc->nbuckets = ca->sb.nbuckets;\n\tset_gc_sectors(c);\n\n\tif (CACHE_SYNC(&c->cache->sb)) {\n\t\tstruct bkey *k;\n\t\tstruct jset *j;\n\n\t\terr = \"cannot allocate memory for journal\";\n\t\tif (bch_journal_read(c, &journal))\n\t\t\tgoto err;\n\n\t\tpr_debug(\"btree_journal_read() done\\n\");\n\n\t\terr = \"no journal entries found\";\n\t\tif (list_empty(&journal))\n\t\t\tgoto err;\n\n\t\tj = &list_entry(journal.prev, struct journal_replay, list)->j;\n\n\t\terr = \"IO error reading priorities\";\n\t\tif (prio_read(ca, j->prio_bucket[ca->sb.nr_this_dev]))\n\t\t\tgoto err;\n\n\t\t \n\n\t\tk = &j->btree_root;\n\n\t\terr = \"bad btree root\";\n\t\tif (__bch_btree_ptr_invalid(c, k))\n\t\t\tgoto err;\n\n\t\terr = \"error reading btree root\";\n\t\tc->root = bch_btree_node_get(c, NULL, k,\n\t\t\t\t\t     j->btree_level,\n\t\t\t\t\t     true, NULL);\n\t\tif (IS_ERR(c->root))\n\t\t\tgoto err;\n\n\t\tlist_del_init(&c->root->list);\n\t\trw_unlock(true, c->root);\n\n\t\terr = uuid_read(c, j, &cl);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\terr = \"error in recovery\";\n\t\tif (bch_btree_check(c))\n\t\t\tgoto err;\n\n\t\tbch_journal_mark(c, &journal);\n\t\tbch_initial_gc_finish(c);\n\t\tpr_debug(\"btree_check() done\\n\");\n\n\t\t \n\t\tbch_journal_next(&c->journal);\n\n\t\terr = \"error starting allocator thread\";\n\t\tif (bch_cache_allocator_start(ca))\n\t\t\tgoto err;\n\n\t\t \n\t\tif (j->version < BCACHE_JSET_VERSION_UUID)\n\t\t\t__uuid_write(c);\n\n\t\terr = \"bcache: replay journal failed\";\n\t\tif (bch_journal_replay(c, &journal))\n\t\t\tgoto err;\n\t} else {\n\t\tunsigned int j;\n\n\t\tpr_notice(\"invalidating existing data\\n\");\n\t\tca->sb.keys = clamp_t(int, ca->sb.nbuckets >> 7,\n\t\t\t\t\t2, SB_JOURNAL_BUCKETS);\n\n\t\tfor (j = 0; j < ca->sb.keys; j++)\n\t\t\tca->sb.d[j] = ca->sb.first_bucket + j;\n\n\t\tbch_initial_gc_finish(c);\n\n\t\terr = \"error starting allocator thread\";\n\t\tif (bch_cache_allocator_start(ca))\n\t\t\tgoto err;\n\n\t\tmutex_lock(&c->bucket_lock);\n\t\tbch_prio_write(ca, true);\n\t\tmutex_unlock(&c->bucket_lock);\n\n\t\terr = \"cannot allocate new UUID bucket\";\n\t\tif (__uuid_write(c))\n\t\t\tgoto err;\n\n\t\terr = \"cannot allocate new btree root\";\n\t\tc->root = __bch_btree_node_alloc(c, NULL, 0, true, NULL);\n\t\tif (IS_ERR(c->root))\n\t\t\tgoto err;\n\n\t\tmutex_lock(&c->root->write_lock);\n\t\tbkey_copy_key(&c->root->key, &MAX_KEY);\n\t\tbch_btree_node_write(c->root, &cl);\n\t\tmutex_unlock(&c->root->write_lock);\n\n\t\tbch_btree_set_root(c->root);\n\t\trw_unlock(true, c->root);\n\n\t\t \n\t\tSET_CACHE_SYNC(&c->cache->sb, true);\n\n\t\tbch_journal_next(&c->journal);\n\t\tbch_journal_meta(c, &cl);\n\t}\n\n\terr = \"error starting gc thread\";\n\tif (bch_gc_thread_start(c))\n\t\tgoto err;\n\n\tclosure_sync(&cl);\n\tc->cache->sb.last_mount = (u32)ktime_get_real_seconds();\n\tbcache_write_super(c);\n\n\tif (bch_has_feature_obso_large_bucket(&c->cache->sb))\n\t\tpr_err(\"Detect obsoleted large bucket layout, all attached bcache device will be read-only\\n\");\n\n\tlist_for_each_entry_safe(dc, t, &uncached_devices, list)\n\t\tbch_cached_dev_attach(dc, c, NULL);\n\n\tflash_devs_run(c);\n\n\tbch_journal_space_reserve(&c->journal);\n\tset_bit(CACHE_SET_RUNNING, &c->flags);\n\treturn 0;\nerr:\n\twhile (!list_empty(&journal)) {\n\t\tl = list_first_entry(&journal, struct journal_replay, list);\n\t\tlist_del(&l->list);\n\t\tkfree(l);\n\t}\n\n\tclosure_sync(&cl);\n\n\tbch_cache_set_error(c, \"%s\", err);\n\n\treturn -EIO;\n}\n\nstatic const char *register_cache_set(struct cache *ca)\n{\n\tchar buf[12];\n\tconst char *err = \"cannot allocate memory\";\n\tstruct cache_set *c;\n\n\tlist_for_each_entry(c, &bch_cache_sets, list)\n\t\tif (!memcmp(c->set_uuid, ca->sb.set_uuid, 16)) {\n\t\t\tif (c->cache)\n\t\t\t\treturn \"duplicate cache set member\";\n\n\t\t\tgoto found;\n\t\t}\n\n\tc = bch_cache_set_alloc(&ca->sb);\n\tif (!c)\n\t\treturn err;\n\n\terr = \"error creating kobject\";\n\tif (kobject_add(&c->kobj, bcache_kobj, \"%pU\", c->set_uuid) ||\n\t    kobject_add(&c->internal, &c->kobj, \"internal\"))\n\t\tgoto err;\n\n\tif (bch_cache_accounting_add_kobjs(&c->accounting, &c->kobj))\n\t\tgoto err;\n\n\tbch_debug_init_cache_set(c);\n\n\tlist_add(&c->list, &bch_cache_sets);\nfound:\n\tsprintf(buf, \"cache%i\", ca->sb.nr_this_dev);\n\tif (sysfs_create_link(&ca->kobj, &c->kobj, \"set\") ||\n\t    sysfs_create_link(&c->kobj, &ca->kobj, buf))\n\t\tgoto err;\n\n\tkobject_get(&ca->kobj);\n\tca->set = c;\n\tca->set->cache = ca;\n\n\terr = \"failed to run cache set\";\n\tif (run_cache_set(c) < 0)\n\t\tgoto err;\n\n\treturn NULL;\nerr:\n\tbch_cache_set_unregister(c);\n\treturn err;\n}\n\n \n\n \nvoid bch_cache_release(struct kobject *kobj)\n{\n\tstruct cache *ca = container_of(kobj, struct cache, kobj);\n\tunsigned int i;\n\n\tif (ca->set) {\n\t\tBUG_ON(ca->set->cache != ca);\n\t\tca->set->cache = NULL;\n\t}\n\n\tfree_pages((unsigned long) ca->disk_buckets, ilog2(meta_bucket_pages(&ca->sb)));\n\tkfree(ca->prio_buckets);\n\tvfree(ca->buckets);\n\n\tfree_heap(&ca->heap);\n\tfree_fifo(&ca->free_inc);\n\n\tfor (i = 0; i < RESERVE_NR; i++)\n\t\tfree_fifo(&ca->free[i]);\n\n\tif (ca->sb_disk)\n\t\tput_page(virt_to_page(ca->sb_disk));\n\n\tif (!IS_ERR_OR_NULL(ca->bdev))\n\t\tblkdev_put(ca->bdev, ca);\n\n\tkfree(ca);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic int cache_alloc(struct cache *ca)\n{\n\tsize_t free;\n\tsize_t btree_buckets;\n\tstruct bucket *b;\n\tint ret = -ENOMEM;\n\tconst char *err = NULL;\n\n\t__module_get(THIS_MODULE);\n\tkobject_init(&ca->kobj, &bch_cache_ktype);\n\n\tbio_init(&ca->journal.bio, NULL, ca->journal.bio.bi_inline_vecs, 8, 0);\n\n\t \n\tbtree_buckets = ca->sb.njournal_buckets ?: 8;\n\tfree = roundup_pow_of_two(ca->sb.nbuckets) >> 10;\n\tif (!free) {\n\t\tret = -EPERM;\n\t\terr = \"ca->sb.nbuckets is too small\";\n\t\tgoto err_free;\n\t}\n\n\tif (!init_fifo(&ca->free[RESERVE_BTREE], btree_buckets,\n\t\t\t\t\t\tGFP_KERNEL)) {\n\t\terr = \"ca->free[RESERVE_BTREE] alloc failed\";\n\t\tgoto err_btree_alloc;\n\t}\n\n\tif (!init_fifo_exact(&ca->free[RESERVE_PRIO], prio_buckets(ca),\n\t\t\t\t\t\t\tGFP_KERNEL)) {\n\t\terr = \"ca->free[RESERVE_PRIO] alloc failed\";\n\t\tgoto err_prio_alloc;\n\t}\n\n\tif (!init_fifo(&ca->free[RESERVE_MOVINGGC], free, GFP_KERNEL)) {\n\t\terr = \"ca->free[RESERVE_MOVINGGC] alloc failed\";\n\t\tgoto err_movinggc_alloc;\n\t}\n\n\tif (!init_fifo(&ca->free[RESERVE_NONE], free, GFP_KERNEL)) {\n\t\terr = \"ca->free[RESERVE_NONE] alloc failed\";\n\t\tgoto err_none_alloc;\n\t}\n\n\tif (!init_fifo(&ca->free_inc, free << 2, GFP_KERNEL)) {\n\t\terr = \"ca->free_inc alloc failed\";\n\t\tgoto err_free_inc_alloc;\n\t}\n\n\tif (!init_heap(&ca->heap, free << 3, GFP_KERNEL)) {\n\t\terr = \"ca->heap alloc failed\";\n\t\tgoto err_heap_alloc;\n\t}\n\n\tca->buckets = vzalloc(array_size(sizeof(struct bucket),\n\t\t\t      ca->sb.nbuckets));\n\tif (!ca->buckets) {\n\t\terr = \"ca->buckets alloc failed\";\n\t\tgoto err_buckets_alloc;\n\t}\n\n\tca->prio_buckets = kzalloc(array3_size(sizeof(uint64_t),\n\t\t\t\t   prio_buckets(ca), 2),\n\t\t\t\t   GFP_KERNEL);\n\tif (!ca->prio_buckets) {\n\t\terr = \"ca->prio_buckets alloc failed\";\n\t\tgoto err_prio_buckets_alloc;\n\t}\n\n\tca->disk_buckets = alloc_meta_bucket_pages(GFP_KERNEL, &ca->sb);\n\tif (!ca->disk_buckets) {\n\t\terr = \"ca->disk_buckets alloc failed\";\n\t\tgoto err_disk_buckets_alloc;\n\t}\n\n\tca->prio_last_buckets = ca->prio_buckets + prio_buckets(ca);\n\n\tfor_each_bucket(b, ca)\n\t\tatomic_set(&b->pin, 0);\n\treturn 0;\n\nerr_disk_buckets_alloc:\n\tkfree(ca->prio_buckets);\nerr_prio_buckets_alloc:\n\tvfree(ca->buckets);\nerr_buckets_alloc:\n\tfree_heap(&ca->heap);\nerr_heap_alloc:\n\tfree_fifo(&ca->free_inc);\nerr_free_inc_alloc:\n\tfree_fifo(&ca->free[RESERVE_NONE]);\nerr_none_alloc:\n\tfree_fifo(&ca->free[RESERVE_MOVINGGC]);\nerr_movinggc_alloc:\n\tfree_fifo(&ca->free[RESERVE_PRIO]);\nerr_prio_alloc:\n\tfree_fifo(&ca->free[RESERVE_BTREE]);\nerr_btree_alloc:\nerr_free:\n\tmodule_put(THIS_MODULE);\n\tif (err)\n\t\tpr_notice(\"error %pg: %s\\n\", ca->bdev, err);\n\treturn ret;\n}\n\nstatic int register_cache(struct cache_sb *sb, struct cache_sb_disk *sb_disk,\n\t\t\t\tstruct block_device *bdev, struct cache *ca)\n{\n\tconst char *err = NULL;  \n\tint ret = 0;\n\n\tmemcpy(&ca->sb, sb, sizeof(struct cache_sb));\n\tca->bdev = bdev;\n\tca->sb_disk = sb_disk;\n\n\tif (bdev_max_discard_sectors((bdev)))\n\t\tca->discard = CACHE_DISCARD(&ca->sb);\n\n\tret = cache_alloc(ca);\n\tif (ret != 0) {\n\t\t \n\t\tblkdev_put(bdev, ca);\n\t\tif (ret == -ENOMEM)\n\t\t\terr = \"cache_alloc(): -ENOMEM\";\n\t\telse if (ret == -EPERM)\n\t\t\terr = \"cache_alloc(): cache device is too small\";\n\t\telse\n\t\t\terr = \"cache_alloc(): unknown error\";\n\t\tgoto err;\n\t}\n\n\tif (kobject_add(&ca->kobj, bdev_kobj(bdev), \"bcache\")) {\n\t\terr = \"error calling kobject_add\";\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&bch_register_lock);\n\terr = register_cache_set(ca);\n\tmutex_unlock(&bch_register_lock);\n\n\tif (err) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tpr_info(\"registered cache device %pg\\n\", ca->bdev);\n\nout:\n\tkobject_put(&ca->kobj);\n\nerr:\n\tif (err)\n\t\tpr_notice(\"error %pg: %s\\n\", ca->bdev, err);\n\n\treturn ret;\n}\n\n \n\nstatic ssize_t register_bcache(struct kobject *k, struct kobj_attribute *attr,\n\t\t\t       const char *buffer, size_t size);\nstatic ssize_t bch_pending_bdevs_cleanup(struct kobject *k,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t const char *buffer, size_t size);\n\nkobj_attribute_write(register,\t\tregister_bcache);\nkobj_attribute_write(register_quiet,\tregister_bcache);\nkobj_attribute_write(pendings_cleanup,\tbch_pending_bdevs_cleanup);\n\nstatic bool bch_is_open_backing(dev_t dev)\n{\n\tstruct cache_set *c, *tc;\n\tstruct cached_dev *dc, *t;\n\n\tlist_for_each_entry_safe(c, tc, &bch_cache_sets, list)\n\t\tlist_for_each_entry_safe(dc, t, &c->cached_devs, list)\n\t\t\tif (dc->bdev->bd_dev == dev)\n\t\t\t\treturn true;\n\tlist_for_each_entry_safe(dc, t, &uncached_devices, list)\n\t\tif (dc->bdev->bd_dev == dev)\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic bool bch_is_open_cache(dev_t dev)\n{\n\tstruct cache_set *c, *tc;\n\n\tlist_for_each_entry_safe(c, tc, &bch_cache_sets, list) {\n\t\tstruct cache *ca = c->cache;\n\n\t\tif (ca->bdev->bd_dev == dev)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool bch_is_open(dev_t dev)\n{\n\treturn bch_is_open_cache(dev) || bch_is_open_backing(dev);\n}\n\nstruct async_reg_args {\n\tstruct delayed_work reg_work;\n\tchar *path;\n\tstruct cache_sb *sb;\n\tstruct cache_sb_disk *sb_disk;\n\tstruct block_device *bdev;\n\tvoid *holder;\n};\n\nstatic void register_bdev_worker(struct work_struct *work)\n{\n\tint fail = false;\n\tstruct async_reg_args *args =\n\t\tcontainer_of(work, struct async_reg_args, reg_work.work);\n\n\tmutex_lock(&bch_register_lock);\n\tif (register_bdev(args->sb, args->sb_disk, args->bdev, args->holder)\n\t    < 0)\n\t\tfail = true;\n\tmutex_unlock(&bch_register_lock);\n\n\tif (fail)\n\t\tpr_info(\"error %s: fail to register backing device\\n\",\n\t\t\targs->path);\n\tkfree(args->sb);\n\tkfree(args->path);\n\tkfree(args);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic void register_cache_worker(struct work_struct *work)\n{\n\tint fail = false;\n\tstruct async_reg_args *args =\n\t\tcontainer_of(work, struct async_reg_args, reg_work.work);\n\n\t \n\tif (register_cache(args->sb, args->sb_disk, args->bdev, args->holder))\n\t\tfail = true;\n\n\tif (fail)\n\t\tpr_info(\"error %s: fail to register cache device\\n\",\n\t\t\targs->path);\n\tkfree(args->sb);\n\tkfree(args->path);\n\tkfree(args);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic void register_device_async(struct async_reg_args *args)\n{\n\tif (SB_IS_BDEV(args->sb))\n\t\tINIT_DELAYED_WORK(&args->reg_work, register_bdev_worker);\n\telse\n\t\tINIT_DELAYED_WORK(&args->reg_work, register_cache_worker);\n\n\t \n\tqueue_delayed_work(system_wq, &args->reg_work, 10);\n}\n\nstatic void *alloc_holder_object(struct cache_sb *sb)\n{\n\tif (SB_IS_BDEV(sb))\n\t\treturn kzalloc(sizeof(struct cached_dev), GFP_KERNEL);\n\treturn kzalloc(sizeof(struct cache), GFP_KERNEL);\n}\n\nstatic ssize_t register_bcache(struct kobject *k, struct kobj_attribute *attr,\n\t\t\t       const char *buffer, size_t size)\n{\n\tconst char *err;\n\tchar *path = NULL;\n\tstruct cache_sb *sb;\n\tstruct cache_sb_disk *sb_disk;\n\tstruct block_device *bdev, *bdev2;\n\tvoid *holder = NULL;\n\tssize_t ret;\n\tbool async_registration = false;\n\tbool quiet = false;\n\n#ifdef CONFIG_BCACHE_ASYNC_REGISTRATION\n\tasync_registration = true;\n#endif\n\n\tret = -EBUSY;\n\terr = \"failed to reference bcache module\";\n\tif (!try_module_get(THIS_MODULE))\n\t\tgoto out;\n\n\t \n\tsmp_mb();\n\terr = \"bcache is in reboot\";\n\tif (bcache_is_reboot)\n\t\tgoto out_module_put;\n\n\tret = -ENOMEM;\n\terr = \"cannot allocate memory\";\n\tpath = kstrndup(buffer, size, GFP_KERNEL);\n\tif (!path)\n\t\tgoto out_module_put;\n\n\tsb = kmalloc(sizeof(struct cache_sb), GFP_KERNEL);\n\tif (!sb)\n\t\tgoto out_free_path;\n\n\tret = -EINVAL;\n\terr = \"failed to open device\";\n\tbdev = blkdev_get_by_path(strim(path), BLK_OPEN_READ, NULL, NULL);\n\tif (IS_ERR(bdev))\n\t\tgoto out_free_sb;\n\n\terr = \"failed to set blocksize\";\n\tif (set_blocksize(bdev, 4096))\n\t\tgoto out_blkdev_put;\n\n\terr = read_super(sb, bdev, &sb_disk);\n\tif (err)\n\t\tgoto out_blkdev_put;\n\n\tholder = alloc_holder_object(sb);\n\tif (!holder) {\n\t\tret = -ENOMEM;\n\t\terr = \"cannot allocate memory\";\n\t\tgoto out_put_sb_page;\n\t}\n\n\t \n\tbdev2 = blkdev_get_by_dev(bdev->bd_dev, BLK_OPEN_READ | BLK_OPEN_WRITE,\n\t\t\t\t  holder, NULL);\n\tblkdev_put(bdev, NULL);\n\tbdev = bdev2;\n\tif (IS_ERR(bdev)) {\n\t\tret = PTR_ERR(bdev);\n\t\tbdev = NULL;\n\t\tif (ret == -EBUSY) {\n\t\t\tdev_t dev;\n\n\t\t\tmutex_lock(&bch_register_lock);\n\t\t\tif (lookup_bdev(strim(path), &dev) == 0 &&\n\t\t\t    bch_is_open(dev))\n\t\t\t\terr = \"device already registered\";\n\t\t\telse\n\t\t\t\terr = \"device busy\";\n\t\t\tmutex_unlock(&bch_register_lock);\n\t\t\tif (attr == &ksysfs_register_quiet) {\n\t\t\t\tquiet = true;\n\t\t\t\tret = size;\n\t\t\t}\n\t\t}\n\t\tgoto out_free_holder;\n\t}\n\n\terr = \"failed to register device\";\n\n\tif (async_registration) {\n\t\t \n\t\tstruct async_reg_args *args =\n\t\t\tkzalloc(sizeof(struct async_reg_args), GFP_KERNEL);\n\n\t\tif (!args) {\n\t\t\tret = -ENOMEM;\n\t\t\terr = \"cannot allocate memory\";\n\t\t\tgoto out_free_holder;\n\t\t}\n\n\t\targs->path\t= path;\n\t\targs->sb\t= sb;\n\t\targs->sb_disk\t= sb_disk;\n\t\targs->bdev\t= bdev;\n\t\targs->holder\t= holder;\n\t\tregister_device_async(args);\n\t\t \n\t\tgoto async_done;\n\t}\n\n\tif (SB_IS_BDEV(sb)) {\n\t\tmutex_lock(&bch_register_lock);\n\t\tret = register_bdev(sb, sb_disk, bdev, holder);\n\t\tmutex_unlock(&bch_register_lock);\n\t\t \n\t\tif (ret < 0)\n\t\t\tgoto out_free_sb;\n\t} else {\n\t\t \n\t\tret = register_cache(sb, sb_disk, bdev, holder);\n\t\tif (ret)\n\t\t\tgoto out_free_sb;\n\t}\n\n\tkfree(sb);\n\tkfree(path);\n\tmodule_put(THIS_MODULE);\nasync_done:\n\treturn size;\n\nout_free_holder:\n\tkfree(holder);\nout_put_sb_page:\n\tput_page(virt_to_page(sb_disk));\nout_blkdev_put:\n\tif (bdev)\n\t\tblkdev_put(bdev, holder);\nout_free_sb:\n\tkfree(sb);\nout_free_path:\n\tkfree(path);\n\tpath = NULL;\nout_module_put:\n\tmodule_put(THIS_MODULE);\nout:\n\tif (!quiet)\n\t\tpr_info(\"error %s: %s\\n\", path?path:\"\", err);\n\treturn ret;\n}\n\n\nstruct pdev {\n\tstruct list_head list;\n\tstruct cached_dev *dc;\n};\n\nstatic ssize_t bch_pending_bdevs_cleanup(struct kobject *k,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t const char *buffer,\n\t\t\t\t\t size_t size)\n{\n\tLIST_HEAD(pending_devs);\n\tssize_t ret = size;\n\tstruct cached_dev *dc, *tdc;\n\tstruct pdev *pdev, *tpdev;\n\tstruct cache_set *c, *tc;\n\n\tmutex_lock(&bch_register_lock);\n\tlist_for_each_entry_safe(dc, tdc, &uncached_devices, list) {\n\t\tpdev = kmalloc(sizeof(struct pdev), GFP_KERNEL);\n\t\tif (!pdev)\n\t\t\tbreak;\n\t\tpdev->dc = dc;\n\t\tlist_add(&pdev->list, &pending_devs);\n\t}\n\n\tlist_for_each_entry_safe(pdev, tpdev, &pending_devs, list) {\n\t\tchar *pdev_set_uuid = pdev->dc->sb.set_uuid;\n\t\tlist_for_each_entry_safe(c, tc, &bch_cache_sets, list) {\n\t\t\tchar *set_uuid = c->set_uuid;\n\n\t\t\tif (!memcmp(pdev_set_uuid, set_uuid, 16)) {\n\t\t\t\tlist_del(&pdev->list);\n\t\t\t\tkfree(pdev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&bch_register_lock);\n\n\tlist_for_each_entry_safe(pdev, tpdev, &pending_devs, list) {\n\t\tpr_info(\"delete pdev %p\\n\", pdev);\n\t\tlist_del(&pdev->list);\n\t\tbcache_device_stop(&pdev->dc->disk);\n\t\tkfree(pdev);\n\t}\n\n\treturn ret;\n}\n\nstatic int bcache_reboot(struct notifier_block *n, unsigned long code, void *x)\n{\n\tif (bcache_is_reboot)\n\t\treturn NOTIFY_DONE;\n\n\tif (code == SYS_DOWN ||\n\t    code == SYS_HALT ||\n\t    code == SYS_POWER_OFF) {\n\t\tDEFINE_WAIT(wait);\n\t\tunsigned long start = jiffies;\n\t\tbool stopped = false;\n\n\t\tstruct cache_set *c, *tc;\n\t\tstruct cached_dev *dc, *tdc;\n\n\t\tmutex_lock(&bch_register_lock);\n\n\t\tif (bcache_is_reboot)\n\t\t\tgoto out;\n\n\t\t \n\t\tbcache_is_reboot = true;\n\t\t \n\t\tsmp_mb();\n\n\t\tif (list_empty(&bch_cache_sets) &&\n\t\t    list_empty(&uncached_devices))\n\t\t\tgoto out;\n\n\t\tmutex_unlock(&bch_register_lock);\n\n\t\tpr_info(\"Stopping all devices:\\n\");\n\n\t\t \n\t\tlist_for_each_entry_safe(c, tc, &bch_cache_sets, list)\n\t\t\tbch_cache_set_stop(c);\n\n\t\tlist_for_each_entry_safe(dc, tdc, &uncached_devices, list)\n\t\t\tbcache_device_stop(&dc->disk);\n\n\n\t\t \n\t\tschedule();\n\n\t\t \n\t\twhile (1) {\n\t\t\tlong timeout = start + 10 * HZ - jiffies;\n\n\t\t\tmutex_lock(&bch_register_lock);\n\t\t\tstopped = list_empty(&bch_cache_sets) &&\n\t\t\t\tlist_empty(&uncached_devices);\n\n\t\t\tif (timeout < 0 || stopped)\n\t\t\t\tbreak;\n\n\t\t\tprepare_to_wait(&unregister_wait, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\t\tmutex_unlock(&bch_register_lock);\n\t\t\tschedule_timeout(timeout);\n\t\t}\n\n\t\tfinish_wait(&unregister_wait, &wait);\n\n\t\tif (stopped)\n\t\t\tpr_info(\"All devices stopped\\n\");\n\t\telse\n\t\t\tpr_notice(\"Timeout waiting for devices to be closed\\n\");\nout:\n\t\tmutex_unlock(&bch_register_lock);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block reboot = {\n\t.notifier_call\t= bcache_reboot,\n\t.priority\t= INT_MAX,  \n};\n\nstatic void bcache_exit(void)\n{\n\tbch_debug_exit();\n\tbch_request_exit();\n\tif (bcache_kobj)\n\t\tkobject_put(bcache_kobj);\n\tif (bcache_wq)\n\t\tdestroy_workqueue(bcache_wq);\n\tif (bch_journal_wq)\n\t\tdestroy_workqueue(bch_journal_wq);\n\tif (bch_flush_wq)\n\t\tdestroy_workqueue(bch_flush_wq);\n\tbch_btree_exit();\n\n\tif (bcache_major)\n\t\tunregister_blkdev(bcache_major, \"bcache\");\n\tunregister_reboot_notifier(&reboot);\n\tmutex_destroy(&bch_register_lock);\n}\n\n \nstatic void check_module_parameters(void)\n{\n\tif (bch_cutoff_writeback_sync == 0)\n\t\tbch_cutoff_writeback_sync = CUTOFF_WRITEBACK_SYNC;\n\telse if (bch_cutoff_writeback_sync > CUTOFF_WRITEBACK_SYNC_MAX) {\n\t\tpr_warn(\"set bch_cutoff_writeback_sync (%u) to max value %u\\n\",\n\t\t\tbch_cutoff_writeback_sync, CUTOFF_WRITEBACK_SYNC_MAX);\n\t\tbch_cutoff_writeback_sync = CUTOFF_WRITEBACK_SYNC_MAX;\n\t}\n\n\tif (bch_cutoff_writeback == 0)\n\t\tbch_cutoff_writeback = CUTOFF_WRITEBACK;\n\telse if (bch_cutoff_writeback > CUTOFF_WRITEBACK_MAX) {\n\t\tpr_warn(\"set bch_cutoff_writeback (%u) to max value %u\\n\",\n\t\t\tbch_cutoff_writeback, CUTOFF_WRITEBACK_MAX);\n\t\tbch_cutoff_writeback = CUTOFF_WRITEBACK_MAX;\n\t}\n\n\tif (bch_cutoff_writeback > bch_cutoff_writeback_sync) {\n\t\tpr_warn(\"set bch_cutoff_writeback (%u) to %u\\n\",\n\t\t\tbch_cutoff_writeback, bch_cutoff_writeback_sync);\n\t\tbch_cutoff_writeback = bch_cutoff_writeback_sync;\n\t}\n}\n\nstatic int __init bcache_init(void)\n{\n\tstatic const struct attribute *files[] = {\n\t\t&ksysfs_register.attr,\n\t\t&ksysfs_register_quiet.attr,\n\t\t&ksysfs_pendings_cleanup.attr,\n\t\tNULL\n\t};\n\n\tcheck_module_parameters();\n\n\tmutex_init(&bch_register_lock);\n\tinit_waitqueue_head(&unregister_wait);\n\tregister_reboot_notifier(&reboot);\n\n\tbcache_major = register_blkdev(0, \"bcache\");\n\tif (bcache_major < 0) {\n\t\tunregister_reboot_notifier(&reboot);\n\t\tmutex_destroy(&bch_register_lock);\n\t\treturn bcache_major;\n\t}\n\n\tif (bch_btree_init())\n\t\tgoto err;\n\n\tbcache_wq = alloc_workqueue(\"bcache\", WQ_MEM_RECLAIM, 0);\n\tif (!bcache_wq)\n\t\tgoto err;\n\n\t \n\tbch_flush_wq = alloc_workqueue(\"bch_flush\", 0, 0);\n\tif (!bch_flush_wq)\n\t\tgoto err;\n\n\tbch_journal_wq = alloc_workqueue(\"bch_journal\", WQ_MEM_RECLAIM, 0);\n\tif (!bch_journal_wq)\n\t\tgoto err;\n\n\tbcache_kobj = kobject_create_and_add(\"bcache\", fs_kobj);\n\tif (!bcache_kobj)\n\t\tgoto err;\n\n\tif (bch_request_init() ||\n\t    sysfs_create_files(bcache_kobj, files))\n\t\tgoto err;\n\n\tbch_debug_init();\n\tclosure_debug_init();\n\n\tbcache_is_reboot = false;\n\n\treturn 0;\nerr:\n\tbcache_exit();\n\treturn -ENOMEM;\n}\n\n \nmodule_exit(bcache_exit);\nmodule_init(bcache_init);\n\nmodule_param(bch_cutoff_writeback, uint, 0);\nMODULE_PARM_DESC(bch_cutoff_writeback, \"threshold to cutoff writeback\");\n\nmodule_param(bch_cutoff_writeback_sync, uint, 0);\nMODULE_PARM_DESC(bch_cutoff_writeback_sync, \"hard threshold to cutoff writeback\");\n\nMODULE_DESCRIPTION(\"Bcache: a Linux block layer cache\");\nMODULE_AUTHOR(\"Kent Overstreet <kent.overstreet@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}