{
  "module_name": "util.h",
  "hash_id": "57c3d053334e0cdcea42401ffbee22a883bf3ef59c9659cc6fca3f78d651b633",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/bcache/util.h",
  "human_readable_source": " \n\n#ifndef _BCACHE_UTIL_H\n#define _BCACHE_UTIL_H\n\n#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched/clock.h>\n#include <linux/llist.h>\n#include <linux/ratelimit.h>\n#include <linux/vmalloc.h>\n#include <linux/workqueue.h>\n#include <linux/crc64.h>\n\n#include \"closure.h\"\n\nstruct closure;\n\n#ifdef CONFIG_BCACHE_DEBUG\n\n#define EBUG_ON(cond)\t\t\tBUG_ON(cond)\n#define atomic_dec_bug(v)\tBUG_ON(atomic_dec_return(v) < 0)\n#define atomic_inc_bug(v, i)\tBUG_ON(atomic_inc_return(v) <= i)\n\n#else  \n\n#define EBUG_ON(cond)\t\tdo { if (cond) do {} while (0); } while (0)\n#define atomic_dec_bug(v)\tatomic_dec(v)\n#define atomic_inc_bug(v, i)\tatomic_inc(v)\n\n#endif\n\n#define DECLARE_HEAP(type, name)\t\t\t\t\t\\\n\tstruct {\t\t\t\t\t\t\t\\\n\t\tsize_t size, used;\t\t\t\t\t\\\n\t\ttype *data;\t\t\t\t\t\t\\\n\t} name\n\n#define init_heap(heap, _size, gfp)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tsize_t _bytes;\t\t\t\t\t\t\t\\\n\t(heap)->used = 0;\t\t\t\t\t\t\\\n\t(heap)->size = (_size);\t\t\t\t\t\t\\\n\t_bytes = (heap)->size * sizeof(*(heap)->data);\t\t\t\\\n\t(heap)->data = kvmalloc(_bytes, (gfp) & GFP_KERNEL);\t\t\\\n\t(heap)->data;\t\t\t\t\t\t\t\\\n})\n\n#define free_heap(heap)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tkvfree((heap)->data);\t\t\t\t\t\t\\\n\t(heap)->data = NULL;\t\t\t\t\t\t\\\n} while (0)\n\n#define heap_swap(h, i, j)\tswap((h)->data[i], (h)->data[j])\n\n#define heap_sift(h, i, cmp)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tsize_t _r, _j = i;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (; _j * 2 + 1 < (h)->used; _j = _r) {\t\t\t\\\n\t\t_r = _j * 2 + 1;\t\t\t\t\t\\\n\t\tif (_r + 1 < (h)->used &&\t\t\t\t\\\n\t\t    cmp((h)->data[_r], (h)->data[_r + 1]))\t\t\\\n\t\t\t_r++;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (cmp((h)->data[_r], (h)->data[_j]))\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\theap_swap(h, _r, _j);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define heap_sift_down(h, i, cmp)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\twhile (i) {\t\t\t\t\t\t\t\\\n\t\tsize_t p = (i - 1) / 2;\t\t\t\t\t\\\n\t\tif (cmp((h)->data[i], (h)->data[p]))\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\theap_swap(h, i, p);\t\t\t\t\t\\\n\t\ti = p;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define heap_add(h, d, cmp)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tbool _r = !heap_full(h);\t\t\t\t\t\\\n\tif (_r) {\t\t\t\t\t\t\t\\\n\t\tsize_t _i = (h)->used++;\t\t\t\t\\\n\t\t(h)->data[_i] = d;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\theap_sift_down(h, _i, cmp);\t\t\t\t\\\n\t\theap_sift(h, _i, cmp);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t_r;\t\t\t\t\t\t\t\t\\\n})\n\n#define heap_pop(h, d, cmp)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tbool _r = (h)->used;\t\t\t\t\t\t\\\n\tif (_r) {\t\t\t\t\t\t\t\\\n\t\t(d) = (h)->data[0];\t\t\t\t\t\\\n\t\t(h)->used--;\t\t\t\t\t\t\\\n\t\theap_swap(h, 0, (h)->used);\t\t\t\t\\\n\t\theap_sift(h, 0, cmp);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t_r;\t\t\t\t\t\t\t\t\\\n})\n\n#define heap_peek(h)\t((h)->used ? (h)->data[0] : NULL)\n\n#define heap_full(h)\t((h)->used == (h)->size)\n\n#define DECLARE_FIFO(type, name)\t\t\t\t\t\\\n\tstruct {\t\t\t\t\t\t\t\\\n\t\tsize_t front, back, size, mask;\t\t\t\t\\\n\t\ttype *data;\t\t\t\t\t\t\\\n\t} name\n\n#define fifo_for_each(c, fifo, iter)\t\t\t\t\t\\\n\tfor (iter = (fifo)->front;\t\t\t\t\t\\\n\t     c = (fifo)->data[iter], iter != (fifo)->back;\t\t\\\n\t     iter = (iter + 1) & (fifo)->mask)\n\n#define __init_fifo(fifo, gfp)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tsize_t _allocated_size, _bytes;\t\t\t\t\t\\\n\tBUG_ON(!(fifo)->size);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_allocated_size = roundup_pow_of_two((fifo)->size + 1);\t\t\\\n\t_bytes = _allocated_size * sizeof(*(fifo)->data);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t(fifo)->mask = _allocated_size - 1;\t\t\t\t\\\n\t(fifo)->front = (fifo)->back = 0;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t(fifo)->data = kvmalloc(_bytes, (gfp) & GFP_KERNEL);\t\t\\\n\t(fifo)->data;\t\t\t\t\t\t\t\\\n})\n\n#define init_fifo_exact(fifo, _size, gfp)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t(fifo)->size = (_size);\t\t\t\t\t\t\\\n\t__init_fifo(fifo, gfp);\t\t\t\t\t\t\\\n})\n\n#define init_fifo(fifo, _size, gfp)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t(fifo)->size = (_size);\t\t\t\t\t\t\\\n\tif ((fifo)->size > 4)\t\t\t\t\t\t\\\n\t\t(fifo)->size = roundup_pow_of_two((fifo)->size) - 1;\t\\\n\t__init_fifo(fifo, gfp);\t\t\t\t\t\t\\\n})\n\n#define free_fifo(fifo)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tkvfree((fifo)->data);\t\t\t\t\t\t\\\n\t(fifo)->data = NULL;\t\t\t\t\t\t\\\n} while (0)\n\n#define fifo_used(fifo)\t\t(((fifo)->back - (fifo)->front) & (fifo)->mask)\n#define fifo_free(fifo)\t\t((fifo)->size - fifo_used(fifo))\n\n#define fifo_empty(fifo)\t(!fifo_used(fifo))\n#define fifo_full(fifo)\t\t(!fifo_free(fifo))\n\n#define fifo_front(fifo)\t((fifo)->data[(fifo)->front])\n#define fifo_back(fifo)\t\t\t\t\t\t\t\\\n\t((fifo)->data[((fifo)->back - 1) & (fifo)->mask])\n\n#define fifo_idx(fifo, p)\t(((p) - &fifo_front(fifo)) & (fifo)->mask)\n\n#define fifo_push_back(fifo, i)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tbool _r = !fifo_full((fifo));\t\t\t\t\t\\\n\tif (_r) {\t\t\t\t\t\t\t\\\n\t\t(fifo)->data[(fifo)->back++] = (i);\t\t\t\\\n\t\t(fifo)->back &= (fifo)->mask;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t_r;\t\t\t\t\t\t\t\t\\\n})\n\n#define fifo_pop_front(fifo, i)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tbool _r = !fifo_empty((fifo));\t\t\t\t\t\\\n\tif (_r) {\t\t\t\t\t\t\t\\\n\t\t(i) = (fifo)->data[(fifo)->front++];\t\t\t\\\n\t\t(fifo)->front &= (fifo)->mask;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t_r;\t\t\t\t\t\t\t\t\\\n})\n\n#define fifo_push_front(fifo, i)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tbool _r = !fifo_full((fifo));\t\t\t\t\t\\\n\tif (_r) {\t\t\t\t\t\t\t\\\n\t\t--(fifo)->front;\t\t\t\t\t\\\n\t\t(fifo)->front &= (fifo)->mask;\t\t\t\t\\\n\t\t(fifo)->data[(fifo)->front] = (i);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t_r;\t\t\t\t\t\t\t\t\\\n})\n\n#define fifo_pop_back(fifo, i)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tbool _r = !fifo_empty((fifo));\t\t\t\t\t\\\n\tif (_r) {\t\t\t\t\t\t\t\\\n\t\t--(fifo)->back;\t\t\t\t\t\t\\\n\t\t(fifo)->back &= (fifo)->mask;\t\t\t\t\\\n\t\t(i) = (fifo)->data[(fifo)->back]\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t_r;\t\t\t\t\t\t\t\t\\\n})\n\n#define fifo_push(fifo, i)\tfifo_push_back(fifo, (i))\n#define fifo_pop(fifo, i)\tfifo_pop_front(fifo, (i))\n\n#define fifo_swap(l, r)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tswap((l)->front, (r)->front);\t\t\t\t\t\\\n\tswap((l)->back, (r)->back);\t\t\t\t\t\\\n\tswap((l)->size, (r)->size);\t\t\t\t\t\\\n\tswap((l)->mask, (r)->mask);\t\t\t\t\t\\\n\tswap((l)->data, (r)->data);\t\t\t\t\t\\\n} while (0)\n\n#define fifo_move(dest, src)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypeof(*((dest)->data)) _t;\t\t\t\t\t\\\n\twhile (!fifo_full(dest) &&\t\t\t\t\t\\\n\t       fifo_pop(src, _t))\t\t\t\t\t\\\n\t\tfifo_push(dest, _t);\t\t\t\t\t\\\n} while (0)\n\n \n\n#define DECLARE_ARRAY_ALLOCATOR(type, name, size)\t\t\t\\\n\tstruct {\t\t\t\t\t\t\t\\\n\t\ttype\t*freelist;\t\t\t\t\t\\\n\t\ttype\tdata[size];\t\t\t\t\t\\\n\t} name\n\n#define array_alloc(array)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof((array)->freelist) _ret = (array)->freelist;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (_ret)\t\t\t\t\t\t\t\\\n\t\t(array)->freelist = *((typeof((array)->freelist) *) _ret);\\\n\t\t\t\t\t\t\t\t\t\\\n\t_ret;\t\t\t\t\t\t\t\t\\\n})\n\n#define array_free(array, ptr)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypeof((array)->freelist) _ptr = ptr;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t*((typeof((array)->freelist) *) _ptr) = (array)->freelist;\t\\\n\t(array)->freelist = _ptr;\t\t\t\t\t\\\n} while (0)\n\n#define array_allocator_init(array)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypeof((array)->freelist) _i;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON(sizeof((array)->data[0]) < sizeof(void *));\t\\\n\t(array)->freelist = NULL;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (_i = (array)->data;\t\t\t\t\t\\\n\t     _i < (array)->data + ARRAY_SIZE((array)->data);\t\t\\\n\t     _i++)\t\t\t\t\t\t\t\\\n\t\tarray_free(array, _i);\t\t\t\t\t\\\n} while (0)\n\n#define array_freelist_empty(array)\t((array)->freelist == NULL)\n\n#define ANYSINT_MAX(t)\t\t\t\t\t\t\t\\\n\t((((t) 1 << (sizeof(t) * 8 - 2)) - (t) 1) * (t) 2 + (t) 1)\n\nint bch_strtoint_h(const char *cp, int *res);\nint bch_strtouint_h(const char *cp, unsigned int *res);\nint bch_strtoll_h(const char *cp, long long *res);\nint bch_strtoull_h(const char *cp, unsigned long long *res);\n\nstatic inline int bch_strtol_h(const char *cp, long *res)\n{\n#if BITS_PER_LONG == 32\n\treturn bch_strtoint_h(cp, (int *) res);\n#else\n\treturn bch_strtoll_h(cp, (long long *) res);\n#endif\n}\n\nstatic inline int bch_strtoul_h(const char *cp, long *res)\n{\n#if BITS_PER_LONG == 32\n\treturn bch_strtouint_h(cp, (unsigned int *) res);\n#else\n\treturn bch_strtoull_h(cp, (unsigned long long *) res);\n#endif\n}\n\n#define strtoi_h(cp, res)\t\t\t\t\t\t\\\n\t(__builtin_types_compatible_p(typeof(*res), int)\t\t\\\n\t? bch_strtoint_h(cp, (void *) res)\t\t\t\t\\\n\t: __builtin_types_compatible_p(typeof(*res), long)\t\t\\\n\t? bch_strtol_h(cp, (void *) res)\t\t\t\t\\\n\t: __builtin_types_compatible_p(typeof(*res), long long)\t\t\\\n\t? bch_strtoll_h(cp, (void *) res)\t\t\t\t\\\n\t: __builtin_types_compatible_p(typeof(*res), unsigned int)\t\\\n\t? bch_strtouint_h(cp, (void *) res)\t\t\t\t\\\n\t: __builtin_types_compatible_p(typeof(*res), unsigned long)\t\\\n\t? bch_strtoul_h(cp, (void *) res)\t\t\t\t\\\n\t: __builtin_types_compatible_p(typeof(*res), unsigned long long)\\\n\t? bch_strtoull_h(cp, (void *) res) : -EINVAL)\n\n#define strtoul_safe(cp, var)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tunsigned long _v;\t\t\t\t\t\t\\\n\tint _r = kstrtoul(cp, 10, &_v);\t\t\t\t\t\\\n\tif (!_r)\t\t\t\t\t\t\t\\\n\t\tvar = _v;\t\t\t\t\t\t\\\n\t_r;\t\t\t\t\t\t\t\t\\\n})\n\n#define strtoul_safe_clamp(cp, var, min, max)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tunsigned long _v;\t\t\t\t\t\t\\\n\tint _r = kstrtoul(cp, 10, &_v);\t\t\t\t\t\\\n\tif (!_r)\t\t\t\t\t\t\t\\\n\t\tvar = clamp_t(typeof(var), _v, min, max);\t\t\\\n\t_r;\t\t\t\t\t\t\t\t\\\n})\n\nssize_t bch_hprint(char *buf, int64_t v);\n\nbool bch_is_zero(const char *p, size_t n);\nint bch_parse_uuid(const char *s, char *uuid);\n\nstruct time_stats {\n\tspinlock_t\tlock;\n\t \n\tuint64_t\tmax_duration;\n\tuint64_t\taverage_duration;\n\tuint64_t\taverage_frequency;\n\tuint64_t\tlast;\n};\n\nvoid bch_time_stats_update(struct time_stats *stats, uint64_t time);\n\nstatic inline unsigned int local_clock_us(void)\n{\n\treturn local_clock() >> 10;\n}\n\n#define NSEC_PER_ns\t\t\t1L\n#define NSEC_PER_us\t\t\tNSEC_PER_USEC\n#define NSEC_PER_ms\t\t\tNSEC_PER_MSEC\n#define NSEC_PER_sec\t\t\tNSEC_PER_SEC\n\n#define __print_time_stat(stats, name, stat, units)\t\t\t\\\n\tsysfs_print(name ## _ ## stat ## _ ## units,\t\t\t\\\n\t\t    div_u64((stats)->stat >> 8, NSEC_PER_ ## units))\n\n#define sysfs_print_time_stats(stats, name,\t\t\t\t\\\n\t\t\t       frequency_units,\t\t\t\t\\\n\t\t\t       duration_units)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t__print_time_stat(stats, name,\t\t\t\t\t\\\n\t\t\t  average_frequency,\tfrequency_units);\t\\\n\t__print_time_stat(stats, name,\t\t\t\t\t\\\n\t\t\t  average_duration,\tduration_units);\t\\\n\tsysfs_print(name ## _ ##max_duration ## _ ## duration_units,\t\\\n\t\t\tdiv_u64((stats)->max_duration,\t\t\t\\\n\t\t\t\tNSEC_PER_ ## duration_units));\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tsysfs_print(name ## _last_ ## frequency_units, (stats)->last\t\\\n\t\t    ? div_s64(local_clock() - (stats)->last,\t\t\\\n\t\t\t      NSEC_PER_ ## frequency_units)\t\t\\\n\t\t    : -1LL);\t\t\t\t\t\t\\\n} while (0)\n\n#define sysfs_time_stats_attribute(name,\t\t\t\t\\\n\t\t\t\t   frequency_units,\t\t\t\\\n\t\t\t\t   duration_units)\t\t\t\\\nread_attribute(name ## _average_frequency_ ## frequency_units);\t\t\\\nread_attribute(name ## _average_duration_ ## duration_units);\t\t\\\nread_attribute(name ## _max_duration_ ## duration_units);\t\t\\\nread_attribute(name ## _last_ ## frequency_units)\n\n#define sysfs_time_stats_attribute_list(name,\t\t\t\t\\\n\t\t\t\t\tfrequency_units,\t\t\\\n\t\t\t\t\tduration_units)\t\t\t\\\n&sysfs_ ## name ## _average_frequency_ ## frequency_units,\t\t\\\n&sysfs_ ## name ## _average_duration_ ## duration_units,\t\t\\\n&sysfs_ ## name ## _max_duration_ ## duration_units,\t\t\t\\\n&sysfs_ ## name ## _last_ ## frequency_units,\n\n#define ewma_add(ewma, val, weight, factor)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t(ewma) *= (weight) - 1;\t\t\t\t\t\t\\\n\t(ewma) += (val) << factor;\t\t\t\t\t\\\n\t(ewma) /= (weight);\t\t\t\t\t\t\\\n\t(ewma) >> factor;\t\t\t\t\t\t\\\n})\n\nstruct bch_ratelimit {\n\t \n\tuint64_t\t\tnext;\n\n\t \n\tatomic_long_t\t\trate;\n};\n\nstatic inline void bch_ratelimit_reset(struct bch_ratelimit *d)\n{\n\td->next = local_clock();\n}\n\nuint64_t bch_next_delay(struct bch_ratelimit *d, uint64_t done);\n\n#define __DIV_SAFE(n, d, zero)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(n) _n = (n);\t\t\t\t\t\t\\\n\ttypeof(d) _d = (d);\t\t\t\t\t\t\\\n\t_d ? _n / _d : zero;\t\t\t\t\t\t\\\n})\n\n#define DIV_SAFE(n, d)\t__DIV_SAFE(n, d, 0)\n\n#define container_of_or_null(ptr, type, member)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) _ptr = ptr;\t\t\t\t\t\t\\\n\t_ptr ? container_of(_ptr, type, member) : NULL;\t\t\t\\\n})\n\n#define RB_INSERT(root, new, member, cmp)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__label__ dup;\t\t\t\t\t\t\t\\\n\tstruct rb_node **n = &(root)->rb_node, *parent = NULL;\t\t\\\n\ttypeof(new) this;\t\t\t\t\t\t\\\n\tint res, ret = -1;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\twhile (*n) {\t\t\t\t\t\t\t\\\n\t\tparent = *n;\t\t\t\t\t\t\\\n\t\tthis = container_of(*n, typeof(*(new)), member);\t\\\n\t\tres = cmp(new, this);\t\t\t\t\t\\\n\t\tif (!res)\t\t\t\t\t\t\\\n\t\t\tgoto dup;\t\t\t\t\t\\\n\t\tn = res < 0\t\t\t\t\t\t\\\n\t\t\t? &(*n)->rb_left\t\t\t\t\\\n\t\t\t: &(*n)->rb_right;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\trb_link_node(&(new)->member, parent, n);\t\t\t\\\n\trb_insert_color(&(new)->member, root);\t\t\t\t\\\n\tret = 0;\t\t\t\t\t\t\t\\\ndup:\t\t\t\t\t\t\t\t\t\\\n\tret;\t\t\t\t\t\t\t\t\\\n})\n\n#define RB_SEARCH(root, search, member, cmp)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct rb_node *n = (root)->rb_node;\t\t\t\t\\\n\ttypeof(&(search)) this, ret = NULL;\t\t\t\t\\\n\tint res;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\twhile (n) {\t\t\t\t\t\t\t\\\n\t\tthis = container_of(n, typeof(search), member);\t\t\\\n\t\tres = cmp(&(search), this);\t\t\t\t\\\n\t\tif (!res) {\t\t\t\t\t\t\\\n\t\t\tret = this;\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tn = res < 0\t\t\t\t\t\t\\\n\t\t\t? n->rb_left\t\t\t\t\t\\\n\t\t\t: n->rb_right;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret;\t\t\t\t\t\t\t\t\\\n})\n\n#define RB_GREATER(root, search, member, cmp)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct rb_node *n = (root)->rb_node;\t\t\t\t\\\n\ttypeof(&(search)) this, ret = NULL;\t\t\t\t\\\n\tint res;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\twhile (n) {\t\t\t\t\t\t\t\\\n\t\tthis = container_of(n, typeof(search), member);\t\t\\\n\t\tres = cmp(&(search), this);\t\t\t\t\\\n\t\tif (res < 0) {\t\t\t\t\t\t\\\n\t\t\tret = this;\t\t\t\t\t\\\n\t\t\tn = n->rb_left;\t\t\t\t\t\\\n\t\t} else\t\t\t\t\t\t\t\\\n\t\t\tn = n->rb_right;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret;\t\t\t\t\t\t\t\t\\\n})\n\n#define RB_FIRST(root, type, member)\t\t\t\t\t\\\n\tcontainer_of_or_null(rb_first(root), type, member)\n\n#define RB_LAST(root, type, member)\t\t\t\t\t\\\n\tcontainer_of_or_null(rb_last(root), type, member)\n\n#define RB_NEXT(ptr, member)\t\t\t\t\t\t\\\n\tcontainer_of_or_null(rb_next(&(ptr)->member), typeof(*ptr), member)\n\n#define RB_PREV(ptr, member)\t\t\t\t\t\t\\\n\tcontainer_of_or_null(rb_prev(&(ptr)->member), typeof(*ptr), member)\n\nstatic inline uint64_t bch_crc64(const void *p, size_t len)\n{\n\tuint64_t crc = 0xffffffffffffffffULL;\n\n\tcrc = crc64_be(crc, p, len);\n\treturn crc ^ 0xffffffffffffffffULL;\n}\n\n \nstatic inline unsigned int fract_exp_two(unsigned int x,\n\t\t\t\t\t unsigned int fract_bits)\n{\n\tunsigned int mantissa = 1 << fract_bits;\t \n\n\tmantissa += x & (mantissa - 1);\n\tx >>= fract_bits;\t \n\t \n\treturn mantissa << x >> fract_bits;\n}\n\nvoid bch_bio_map(struct bio *bio, void *base);\nint bch_bio_alloc_pages(struct bio *bio, gfp_t gfp_mask);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}