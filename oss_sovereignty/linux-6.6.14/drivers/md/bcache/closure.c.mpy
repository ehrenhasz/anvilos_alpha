{
  "module_name": "closure.c",
  "hash_id": "6098e2727401c1212f6158959ac821f1bb0ad0d4867ea3a525031d3247733cd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/bcache/closure.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/sched/debug.h>\n\n#include \"closure.h\"\n\nstatic inline void closure_put_after_sub(struct closure *cl, int flags)\n{\n\tint r = flags & CLOSURE_REMAINING_MASK;\n\n\tBUG_ON(flags & CLOSURE_GUARD_MASK);\n\tBUG_ON(!r && (flags & ~CLOSURE_DESTRUCTOR));\n\n\tif (!r) {\n\t\tif (cl->fn && !(flags & CLOSURE_DESTRUCTOR)) {\n\t\t\tatomic_set(&cl->remaining,\n\t\t\t\t   CLOSURE_REMAINING_INITIALIZER);\n\t\t\tclosure_queue(cl);\n\t\t} else {\n\t\t\tstruct closure *parent = cl->parent;\n\t\t\tclosure_fn *destructor = cl->fn;\n\n\t\t\tclosure_debug_destroy(cl);\n\n\t\t\tif (destructor)\n\t\t\t\tdestructor(cl);\n\n\t\t\tif (parent)\n\t\t\t\tclosure_put(parent);\n\t\t}\n\t}\n}\n\n \nvoid closure_sub(struct closure *cl, int v)\n{\n\tclosure_put_after_sub(cl, atomic_sub_return(v, &cl->remaining));\n}\n\n \nvoid closure_put(struct closure *cl)\n{\n\tclosure_put_after_sub(cl, atomic_dec_return(&cl->remaining));\n}\n\n \nvoid __closure_wake_up(struct closure_waitlist *wait_list)\n{\n\tstruct llist_node *list;\n\tstruct closure *cl, *t;\n\tstruct llist_node *reverse = NULL;\n\n\tlist = llist_del_all(&wait_list->list);\n\n\t \n\treverse = llist_reverse_order(list);\n\n\t \n\tllist_for_each_entry_safe(cl, t, reverse, list) {\n\t\tclosure_set_waiting(cl, 0);\n\t\tclosure_sub(cl, CLOSURE_WAITING + 1);\n\t}\n}\n\n \nbool closure_wait(struct closure_waitlist *waitlist, struct closure *cl)\n{\n\tif (atomic_read(&cl->remaining) & CLOSURE_WAITING)\n\t\treturn false;\n\n\tclosure_set_waiting(cl, _RET_IP_);\n\tatomic_add(CLOSURE_WAITING + 1, &cl->remaining);\n\tllist_add(&cl->list, &waitlist->list);\n\n\treturn true;\n}\n\nstruct closure_syncer {\n\tstruct task_struct\t*task;\n\tint\t\t\tdone;\n};\n\nstatic void closure_sync_fn(struct closure *cl)\n{\n\tstruct closure_syncer *s = cl->s;\n\tstruct task_struct *p;\n\n\trcu_read_lock();\n\tp = READ_ONCE(s->task);\n\ts->done = 1;\n\twake_up_process(p);\n\trcu_read_unlock();\n}\n\nvoid __sched __closure_sync(struct closure *cl)\n{\n\tstruct closure_syncer s = { .task = current };\n\n\tcl->s = &s;\n\tcontinue_at(cl, closure_sync_fn, NULL);\n\n\twhile (1) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (s.done)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n}\n\n#ifdef CONFIG_BCACHE_CLOSURES_DEBUG\n\nstatic LIST_HEAD(closure_list);\nstatic DEFINE_SPINLOCK(closure_list_lock);\n\nvoid closure_debug_create(struct closure *cl)\n{\n\tunsigned long flags;\n\n\tBUG_ON(cl->magic == CLOSURE_MAGIC_ALIVE);\n\tcl->magic = CLOSURE_MAGIC_ALIVE;\n\n\tspin_lock_irqsave(&closure_list_lock, flags);\n\tlist_add(&cl->all, &closure_list);\n\tspin_unlock_irqrestore(&closure_list_lock, flags);\n}\n\nvoid closure_debug_destroy(struct closure *cl)\n{\n\tunsigned long flags;\n\n\tBUG_ON(cl->magic != CLOSURE_MAGIC_ALIVE);\n\tcl->magic = CLOSURE_MAGIC_DEAD;\n\n\tspin_lock_irqsave(&closure_list_lock, flags);\n\tlist_del(&cl->all);\n\tspin_unlock_irqrestore(&closure_list_lock, flags);\n}\n\nstatic struct dentry *closure_debug;\n\nstatic int debug_show(struct seq_file *f, void *data)\n{\n\tstruct closure *cl;\n\n\tspin_lock_irq(&closure_list_lock);\n\n\tlist_for_each_entry(cl, &closure_list, all) {\n\t\tint r = atomic_read(&cl->remaining);\n\n\t\tseq_printf(f, \"%p: %pS -> %pS p %p r %i \",\n\t\t\t   cl, (void *) cl->ip, cl->fn, cl->parent,\n\t\t\t   r & CLOSURE_REMAINING_MASK);\n\n\t\tseq_printf(f, \"%s%s\\n\",\n\t\t\t   test_bit(WORK_STRUCT_PENDING_BIT,\n\t\t\t\t    work_data_bits(&cl->work)) ? \"Q\" : \"\",\n\t\t\t   r & CLOSURE_RUNNING\t? \"R\" : \"\");\n\n\t\tif (r & CLOSURE_WAITING)\n\t\t\tseq_printf(f, \" W %pS\\n\",\n\t\t\t\t   (void *) cl->waiting_on);\n\n\t\tseq_printf(f, \"\\n\");\n\t}\n\n\tspin_unlock_irq(&closure_list_lock);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(debug);\n\nvoid  __init closure_debug_init(void)\n{\n\tif (!IS_ERR_OR_NULL(bcache_debug))\n\t\t \n\t\tclosure_debug = debugfs_create_file(\n\t\t\t\"closures\", 0400, bcache_debug, NULL, &debug_fops);\n}\n#endif\n\nMODULE_AUTHOR(\"Kent Overstreet <koverstreet@google.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}