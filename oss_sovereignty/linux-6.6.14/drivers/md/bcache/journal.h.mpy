{
  "module_name": "journal.h",
  "hash_id": "61f616a6ad4bf9b448ec18b277430009dcff47043c968ea7b1ffdf0a3cb0b5c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/bcache/journal.h",
  "human_readable_source": " \n#ifndef _BCACHE_JOURNAL_H\n#define _BCACHE_JOURNAL_H\n\n \n\n \nstruct journal_replay {\n\tstruct list_head\tlist;\n\tatomic_t\t\t*pin;\n\tstruct jset\t\tj;\n};\n\n \nstruct journal_write {\n\tstruct jset\t\t*data;\n#define JSET_BITS\t\t3\n\n\tstruct cache_set\t*c;\n\tstruct closure_waitlist\twait;\n\tbool\t\t\tdirty;\n\tbool\t\t\tneed_write;\n};\n\n \nstruct journal {\n\tspinlock_t\t\tlock;\n\tspinlock_t\t\tflush_write_lock;\n\tbool\t\t\tbtree_flushing;\n\tbool\t\t\tdo_reserve;\n\t \n\tstruct closure_waitlist\twait;\n\tstruct closure\t\tio;\n\tint\t\t\tio_in_flight;\n\tstruct delayed_work\twork;\n\n\t \n\tunsigned int\t\tblocks_free;\n\tuint64_t\t\tseq;\n\tDECLARE_FIFO(atomic_t, pin);\n\n\tBKEY_PADDED(key);\n\n\tstruct journal_write\tw[2], *cur;\n};\n\n \nstruct journal_device {\n\t \n\tuint64_t\t\tseq[SB_JOURNAL_BUCKETS];\n\n\t \n\tunsigned int\t\tcur_idx;\n\n\t \n\tunsigned int\t\tlast_idx;\n\n\t \n\tunsigned int\t\tdiscard_idx;\n\n#define DISCARD_READY\t\t0\n#define DISCARD_IN_FLIGHT\t1\n#define DISCARD_DONE\t\t2\n\t \n\tatomic_t\t\tdiscard_in_flight;\n\n\tstruct work_struct\tdiscard_work;\n\tstruct bio\t\tdiscard_bio;\n\tstruct bio_vec\t\tdiscard_bv;\n\n\t \n\tstruct bio\t\tbio;\n\tstruct bio_vec\t\tbv[8];\n};\n\n#define BTREE_FLUSH_NR\t8\n\n#define journal_pin_cmp(c, l, r)\t\t\t\t\\\n\t(fifo_idx(&(c)->journal.pin, (l)) > fifo_idx(&(c)->journal.pin, (r)))\n\n#define JOURNAL_PIN\t20000\n\n#define journal_full(j)\t\t\t\t\t\t\\\n\t(!(j)->blocks_free || fifo_free(&(j)->pin) <= 1)\n\nstruct closure;\nstruct cache_set;\nstruct btree_op;\nstruct keylist;\n\natomic_t *bch_journal(struct cache_set *c,\n\t\t      struct keylist *keys,\n\t\t      struct closure *parent);\nvoid bch_journal_next(struct journal *j);\nvoid bch_journal_mark(struct cache_set *c, struct list_head *list);\nvoid bch_journal_meta(struct cache_set *c, struct closure *cl);\nint bch_journal_read(struct cache_set *c, struct list_head *list);\nint bch_journal_replay(struct cache_set *c, struct list_head *list);\n\nvoid bch_journal_free(struct cache_set *c);\nint bch_journal_alloc(struct cache_set *c);\nvoid bch_journal_space_reserve(struct journal *j);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}