{
  "module_name": "dm-dust.c",
  "hash_id": "2001bdcf0fca679bb822d3ed8c439f93e86c34f26c318a7190f24a9592813d9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-dust.c",
  "human_readable_source": "\n \n\n#include <linux/device-mapper.h>\n#include <linux/module.h>\n#include <linux/rbtree.h>\n\n#define DM_MSG_PREFIX \"dust\"\n\nstruct badblock {\n\tstruct rb_node node;\n\tsector_t bb;\n\tunsigned char wr_fail_cnt;\n};\n\nstruct dust_device {\n\tstruct dm_dev *dev;\n\tstruct rb_root badblocklist;\n\tunsigned long long badblock_count;\n\tspinlock_t dust_lock;\n\tunsigned int blksz;\n\tint sect_per_block_shift;\n\tunsigned int sect_per_block;\n\tsector_t start;\n\tbool fail_read_on_bb:1;\n\tbool quiet_mode:1;\n};\n\nstatic struct badblock *dust_rb_search(struct rb_root *root, sector_t blk)\n{\n\tstruct rb_node *node = root->rb_node;\n\n\twhile (node) {\n\t\tstruct badblock *bblk = rb_entry(node, struct badblock, node);\n\n\t\tif (bblk->bb > blk)\n\t\t\tnode = node->rb_left;\n\t\telse if (bblk->bb < blk)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn bblk;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool dust_rb_insert(struct rb_root *root, struct badblock *new)\n{\n\tstruct badblock *bblk;\n\tstruct rb_node **link = &root->rb_node, *parent = NULL;\n\tsector_t value = new->bb;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tbblk = rb_entry(parent, struct badblock, node);\n\n\t\tif (bblk->bb > value)\n\t\t\tlink = &(*link)->rb_left;\n\t\telse if (bblk->bb < value)\n\t\t\tlink = &(*link)->rb_right;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\trb_link_node(&new->node, parent, link);\n\trb_insert_color(&new->node, root);\n\n\treturn true;\n}\n\nstatic int dust_remove_block(struct dust_device *dd, unsigned long long block)\n{\n\tstruct badblock *bblock;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dd->dust_lock, flags);\n\tbblock = dust_rb_search(&dd->badblocklist, block);\n\n\tif (bblock == NULL) {\n\t\tif (!dd->quiet_mode) {\n\t\t\tDMERR(\"%s: block %llu not found in badblocklist\",\n\t\t\t      __func__, block);\n\t\t}\n\t\tspin_unlock_irqrestore(&dd->dust_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\trb_erase(&bblock->node, &dd->badblocklist);\n\tdd->badblock_count--;\n\tif (!dd->quiet_mode)\n\t\tDMINFO(\"%s: badblock removed at block %llu\", __func__, block);\n\tkfree(bblock);\n\tspin_unlock_irqrestore(&dd->dust_lock, flags);\n\n\treturn 0;\n}\n\nstatic int dust_add_block(struct dust_device *dd, unsigned long long block,\n\t\t\t  unsigned char wr_fail_cnt)\n{\n\tstruct badblock *bblock;\n\tunsigned long flags;\n\n\tbblock = kmalloc(sizeof(*bblock), GFP_KERNEL);\n\tif (bblock == NULL) {\n\t\tif (!dd->quiet_mode)\n\t\t\tDMERR(\"%s: badblock allocation failed\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&dd->dust_lock, flags);\n\tbblock->bb = block;\n\tbblock->wr_fail_cnt = wr_fail_cnt;\n\tif (!dust_rb_insert(&dd->badblocklist, bblock)) {\n\t\tif (!dd->quiet_mode) {\n\t\t\tDMERR(\"%s: block %llu already in badblocklist\",\n\t\t\t      __func__, block);\n\t\t}\n\t\tspin_unlock_irqrestore(&dd->dust_lock, flags);\n\t\tkfree(bblock);\n\t\treturn -EINVAL;\n\t}\n\n\tdd->badblock_count++;\n\tif (!dd->quiet_mode) {\n\t\tDMINFO(\"%s: badblock added at block %llu with write fail count %u\",\n\t\t       __func__, block, wr_fail_cnt);\n\t}\n\tspin_unlock_irqrestore(&dd->dust_lock, flags);\n\n\treturn 0;\n}\n\nstatic int dust_query_block(struct dust_device *dd, unsigned long long block, char *result,\n\t\t\t    unsigned int maxlen, unsigned int *sz_ptr)\n{\n\tstruct badblock *bblock;\n\tunsigned long flags;\n\tunsigned int sz = *sz_ptr;\n\n\tspin_lock_irqsave(&dd->dust_lock, flags);\n\tbblock = dust_rb_search(&dd->badblocklist, block);\n\tif (bblock != NULL)\n\t\tDMEMIT(\"%s: block %llu found in badblocklist\", __func__, block);\n\telse\n\t\tDMEMIT(\"%s: block %llu not found in badblocklist\", __func__, block);\n\tspin_unlock_irqrestore(&dd->dust_lock, flags);\n\n\treturn 1;\n}\n\nstatic int __dust_map_read(struct dust_device *dd, sector_t thisblock)\n{\n\tstruct badblock *bblk = dust_rb_search(&dd->badblocklist, thisblock);\n\n\tif (bblk)\n\t\treturn DM_MAPIO_KILL;\n\n\treturn DM_MAPIO_REMAPPED;\n}\n\nstatic int dust_map_read(struct dust_device *dd, sector_t thisblock,\n\t\t\t bool fail_read_on_bb)\n{\n\tunsigned long flags;\n\tint r = DM_MAPIO_REMAPPED;\n\n\tif (fail_read_on_bb) {\n\t\tthisblock >>= dd->sect_per_block_shift;\n\t\tspin_lock_irqsave(&dd->dust_lock, flags);\n\t\tr = __dust_map_read(dd, thisblock);\n\t\tspin_unlock_irqrestore(&dd->dust_lock, flags);\n\t}\n\n\treturn r;\n}\n\nstatic int __dust_map_write(struct dust_device *dd, sector_t thisblock)\n{\n\tstruct badblock *bblk = dust_rb_search(&dd->badblocklist, thisblock);\n\n\tif (bblk && bblk->wr_fail_cnt > 0) {\n\t\tbblk->wr_fail_cnt--;\n\t\treturn DM_MAPIO_KILL;\n\t}\n\n\tif (bblk) {\n\t\trb_erase(&bblk->node, &dd->badblocklist);\n\t\tdd->badblock_count--;\n\t\tkfree(bblk);\n\t\tif (!dd->quiet_mode) {\n\t\t\tsector_div(thisblock, dd->sect_per_block);\n\t\t\tDMINFO(\"block %llu removed from badblocklist by write\",\n\t\t\t       (unsigned long long)thisblock);\n\t\t}\n\t}\n\n\treturn DM_MAPIO_REMAPPED;\n}\n\nstatic int dust_map_write(struct dust_device *dd, sector_t thisblock,\n\t\t\t  bool fail_read_on_bb)\n{\n\tunsigned long flags;\n\tint r = DM_MAPIO_REMAPPED;\n\n\tif (fail_read_on_bb) {\n\t\tthisblock >>= dd->sect_per_block_shift;\n\t\tspin_lock_irqsave(&dd->dust_lock, flags);\n\t\tr = __dust_map_write(dd, thisblock);\n\t\tspin_unlock_irqrestore(&dd->dust_lock, flags);\n\t}\n\n\treturn r;\n}\n\nstatic int dust_map(struct dm_target *ti, struct bio *bio)\n{\n\tstruct dust_device *dd = ti->private;\n\tint r;\n\n\tbio_set_dev(bio, dd->dev->bdev);\n\tbio->bi_iter.bi_sector = dd->start + dm_target_offset(ti, bio->bi_iter.bi_sector);\n\n\tif (bio_data_dir(bio) == READ)\n\t\tr = dust_map_read(dd, bio->bi_iter.bi_sector, dd->fail_read_on_bb);\n\telse\n\t\tr = dust_map_write(dd, bio->bi_iter.bi_sector, dd->fail_read_on_bb);\n\n\treturn r;\n}\n\nstatic bool __dust_clear_badblocks(struct rb_root *tree,\n\t\t\t\t   unsigned long long count)\n{\n\tstruct rb_node *node = NULL, *nnode = NULL;\n\n\tnnode = rb_first(tree);\n\tif (nnode == NULL) {\n\t\tBUG_ON(count != 0);\n\t\treturn false;\n\t}\n\n\twhile (nnode) {\n\t\tnode = nnode;\n\t\tnnode = rb_next(node);\n\t\trb_erase(node, tree);\n\t\tcount--;\n\t\tkfree(node);\n\t}\n\tBUG_ON(count != 0);\n\tBUG_ON(tree->rb_node != NULL);\n\n\treturn true;\n}\n\nstatic int dust_clear_badblocks(struct dust_device *dd, char *result, unsigned int maxlen,\n\t\t\t\tunsigned int *sz_ptr)\n{\n\tunsigned long flags;\n\tstruct rb_root badblocklist;\n\tunsigned long long badblock_count;\n\tunsigned int sz = *sz_ptr;\n\n\tspin_lock_irqsave(&dd->dust_lock, flags);\n\tbadblocklist = dd->badblocklist;\n\tbadblock_count = dd->badblock_count;\n\tdd->badblocklist = RB_ROOT;\n\tdd->badblock_count = 0;\n\tspin_unlock_irqrestore(&dd->dust_lock, flags);\n\n\tif (!__dust_clear_badblocks(&badblocklist, badblock_count))\n\t\tDMEMIT(\"%s: no badblocks found\", __func__);\n\telse\n\t\tDMEMIT(\"%s: badblocks cleared\", __func__);\n\n\treturn 1;\n}\n\nstatic int dust_list_badblocks(struct dust_device *dd, char *result, unsigned int maxlen,\n\t\t\t\tunsigned int *sz_ptr)\n{\n\tunsigned long flags;\n\tstruct rb_root badblocklist;\n\tstruct rb_node *node;\n\tstruct badblock *bblk;\n\tunsigned int sz = *sz_ptr;\n\tunsigned long long num = 0;\n\n\tspin_lock_irqsave(&dd->dust_lock, flags);\n\tbadblocklist = dd->badblocklist;\n\tfor (node = rb_first(&badblocklist); node; node = rb_next(node)) {\n\t\tbblk = rb_entry(node, struct badblock, node);\n\t\tDMEMIT(\"%llu\\n\", bblk->bb);\n\t\tnum++;\n\t}\n\n\tspin_unlock_irqrestore(&dd->dust_lock, flags);\n\tif (!num)\n\t\tDMEMIT(\"No blocks in badblocklist\");\n\n\treturn 1;\n}\n\n \nstatic int dust_ctr(struct dm_target *ti, unsigned int argc, char **argv)\n{\n\tstruct dust_device *dd;\n\tunsigned long long tmp;\n\tchar dummy;\n\tunsigned int blksz;\n\tunsigned int sect_per_block;\n\tsector_t DUST_MAX_BLKSZ_SECTORS = 2097152;\n\tsector_t max_block_sectors = min(ti->len, DUST_MAX_BLKSZ_SECTORS);\n\n\tif (argc != 3) {\n\t\tti->error = \"Invalid argument count\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (kstrtouint(argv[2], 10, &blksz) || !blksz) {\n\t\tti->error = \"Invalid block size parameter\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (blksz < 512) {\n\t\tti->error = \"Block size must be at least 512\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_power_of_2(blksz)) {\n\t\tti->error = \"Block size must be a power of 2\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (to_sector(blksz) > max_block_sectors) {\n\t\tti->error = \"Block size is too large\";\n\t\treturn -EINVAL;\n\t}\n\n\tsect_per_block = (blksz >> SECTOR_SHIFT);\n\n\tif (sscanf(argv[1], \"%llu%c\", &tmp, &dummy) != 1 || tmp != (sector_t)tmp) {\n\t\tti->error = \"Invalid device offset sector\";\n\t\treturn -EINVAL;\n\t}\n\n\tdd = kzalloc(sizeof(struct dust_device), GFP_KERNEL);\n\tif (dd == NULL) {\n\t\tti->error = \"Cannot allocate context\";\n\t\treturn -ENOMEM;\n\t}\n\n\tif (dm_get_device(ti, argv[0], dm_table_get_mode(ti->table), &dd->dev)) {\n\t\tti->error = \"Device lookup failed\";\n\t\tkfree(dd);\n\t\treturn -EINVAL;\n\t}\n\n\tdd->sect_per_block = sect_per_block;\n\tdd->blksz = blksz;\n\tdd->start = tmp;\n\n\tdd->sect_per_block_shift = __ffs(sect_per_block);\n\n\t \n\tdd->fail_read_on_bb = false;\n\n\t \n\tdd->badblocklist = RB_ROOT;\n\tdd->badblock_count = 0;\n\tspin_lock_init(&dd->dust_lock);\n\n\tdd->quiet_mode = false;\n\n\tBUG_ON(dm_set_target_max_io_len(ti, dd->sect_per_block) != 0);\n\n\tti->num_discard_bios = 1;\n\tti->num_flush_bios = 1;\n\tti->private = dd;\n\n\treturn 0;\n}\n\nstatic void dust_dtr(struct dm_target *ti)\n{\n\tstruct dust_device *dd = ti->private;\n\n\t__dust_clear_badblocks(&dd->badblocklist, dd->badblock_count);\n\tdm_put_device(ti, dd->dev);\n\tkfree(dd);\n}\n\nstatic int dust_message(struct dm_target *ti, unsigned int argc, char **argv,\n\t\t\tchar *result, unsigned int maxlen)\n{\n\tstruct dust_device *dd = ti->private;\n\tsector_t size = bdev_nr_sectors(dd->dev->bdev);\n\tbool invalid_msg = false;\n\tint r = -EINVAL;\n\tunsigned long long tmp, block;\n\tunsigned char wr_fail_cnt;\n\tunsigned int tmp_ui;\n\tunsigned long flags;\n\tunsigned int sz = 0;\n\tchar dummy;\n\n\tif (argc == 1) {\n\t\tif (!strcasecmp(argv[0], \"addbadblock\") ||\n\t\t    !strcasecmp(argv[0], \"removebadblock\") ||\n\t\t    !strcasecmp(argv[0], \"queryblock\")) {\n\t\t\tDMERR(\"%s requires an additional argument\", argv[0]);\n\t\t} else if (!strcasecmp(argv[0], \"disable\")) {\n\t\t\tDMINFO(\"disabling read failures on bad sectors\");\n\t\t\tdd->fail_read_on_bb = false;\n\t\t\tr = 0;\n\t\t} else if (!strcasecmp(argv[0], \"enable\")) {\n\t\t\tDMINFO(\"enabling read failures on bad sectors\");\n\t\t\tdd->fail_read_on_bb = true;\n\t\t\tr = 0;\n\t\t} else if (!strcasecmp(argv[0], \"countbadblocks\")) {\n\t\t\tspin_lock_irqsave(&dd->dust_lock, flags);\n\t\t\tDMEMIT(\"countbadblocks: %llu badblock(s) found\",\n\t\t\t       dd->badblock_count);\n\t\t\tspin_unlock_irqrestore(&dd->dust_lock, flags);\n\t\t\tr = 1;\n\t\t} else if (!strcasecmp(argv[0], \"clearbadblocks\")) {\n\t\t\tr = dust_clear_badblocks(dd, result, maxlen, &sz);\n\t\t} else if (!strcasecmp(argv[0], \"quiet\")) {\n\t\t\tif (!dd->quiet_mode)\n\t\t\t\tdd->quiet_mode = true;\n\t\t\telse\n\t\t\t\tdd->quiet_mode = false;\n\t\t\tr = 0;\n\t\t} else if (!strcasecmp(argv[0], \"listbadblocks\")) {\n\t\t\tr = dust_list_badblocks(dd, result, maxlen, &sz);\n\t\t} else {\n\t\t\tinvalid_msg = true;\n\t\t}\n\t} else if (argc == 2) {\n\t\tif (sscanf(argv[1], \"%llu%c\", &tmp, &dummy) != 1)\n\t\t\treturn r;\n\n\t\tblock = tmp;\n\t\tsector_div(size, dd->sect_per_block);\n\t\tif (block > size) {\n\t\t\tDMERR(\"selected block value out of range\");\n\t\t\treturn r;\n\t\t}\n\n\t\tif (!strcasecmp(argv[0], \"addbadblock\"))\n\t\t\tr = dust_add_block(dd, block, 0);\n\t\telse if (!strcasecmp(argv[0], \"removebadblock\"))\n\t\t\tr = dust_remove_block(dd, block);\n\t\telse if (!strcasecmp(argv[0], \"queryblock\"))\n\t\t\tr = dust_query_block(dd, block, result, maxlen, &sz);\n\t\telse\n\t\t\tinvalid_msg = true;\n\n\t} else if (argc == 3) {\n\t\tif (sscanf(argv[1], \"%llu%c\", &tmp, &dummy) != 1)\n\t\t\treturn r;\n\n\t\tif (sscanf(argv[2], \"%u%c\", &tmp_ui, &dummy) != 1)\n\t\t\treturn r;\n\n\t\tblock = tmp;\n\t\tif (tmp_ui > 255) {\n\t\t\tDMERR(\"selected write fail count out of range\");\n\t\t\treturn r;\n\t\t}\n\t\twr_fail_cnt = tmp_ui;\n\t\tsector_div(size, dd->sect_per_block);\n\t\tif (block > size) {\n\t\t\tDMERR(\"selected block value out of range\");\n\t\t\treturn r;\n\t\t}\n\n\t\tif (!strcasecmp(argv[0], \"addbadblock\"))\n\t\t\tr = dust_add_block(dd, block, wr_fail_cnt);\n\t\telse\n\t\t\tinvalid_msg = true;\n\n\t} else\n\t\tDMERR(\"invalid number of arguments '%d'\", argc);\n\n\tif (invalid_msg)\n\t\tDMERR(\"unrecognized message '%s' received\", argv[0]);\n\n\treturn r;\n}\n\nstatic void dust_status(struct dm_target *ti, status_type_t type,\n\t\t\tunsigned int status_flags, char *result, unsigned int maxlen)\n{\n\tstruct dust_device *dd = ti->private;\n\tunsigned int sz = 0;\n\n\tswitch (type) {\n\tcase STATUSTYPE_INFO:\n\t\tDMEMIT(\"%s %s %s\", dd->dev->name,\n\t\t       dd->fail_read_on_bb ? \"fail_read_on_bad_block\" : \"bypass\",\n\t\t       dd->quiet_mode ? \"quiet\" : \"verbose\");\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\"%s %llu %u\", dd->dev->name,\n\t\t       (unsigned long long)dd->start, dd->blksz);\n\t\tbreak;\n\n\tcase STATUSTYPE_IMA:\n\t\t*result = '\\0';\n\t\tbreak;\n\t}\n}\n\nstatic int dust_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)\n{\n\tstruct dust_device *dd = ti->private;\n\tstruct dm_dev *dev = dd->dev;\n\n\t*bdev = dev->bdev;\n\n\t \n\tif (dd->start || ti->len != bdev_nr_sectors(dev->bdev))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int dust_iterate_devices(struct dm_target *ti, iterate_devices_callout_fn fn,\n\t\t\t\tvoid *data)\n{\n\tstruct dust_device *dd = ti->private;\n\n\treturn fn(ti, dd->dev, dd->start, ti->len, data);\n}\n\nstatic struct target_type dust_target = {\n\t.name = \"dust\",\n\t.version = {1, 0, 0},\n\t.module = THIS_MODULE,\n\t.ctr = dust_ctr,\n\t.dtr = dust_dtr,\n\t.iterate_devices = dust_iterate_devices,\n\t.map = dust_map,\n\t.message = dust_message,\n\t.status = dust_status,\n\t.prepare_ioctl = dust_prepare_ioctl,\n};\nmodule_dm(dust);\n\nMODULE_DESCRIPTION(DM_NAME \" dust test target\");\nMODULE_AUTHOR(\"Bryan Gurney <dm-devel@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}