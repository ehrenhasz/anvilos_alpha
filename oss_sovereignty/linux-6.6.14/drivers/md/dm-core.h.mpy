{
  "module_name": "dm-core.h",
  "hash_id": "60d6dd293cbca2f995201b2432e91e4470a86825683235b2804eafe4500da5df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-core.h",
  "human_readable_source": " \n \n\n#ifndef DM_CORE_INTERNAL_H\n#define DM_CORE_INTERNAL_H\n\n#include <linux/kthread.h>\n#include <linux/ktime.h>\n#include <linux/blk-mq.h>\n#include <linux/blk-crypto-profile.h>\n#include <linux/jump_label.h>\n\n#include <trace/events/block.h>\n\n#include \"dm.h\"\n#include \"dm-ima.h\"\n\n#define DM_RESERVED_MAX_IOS\t\t1024\n\nstruct dm_io;\n\nstruct dm_kobject_holder {\n\tstruct kobject kobj;\n\tstruct completion completion;\n};\n\n \n\n \nstruct dm_md_mempools {\n\tstruct bio_set bs;\n\tstruct bio_set io_bs;\n};\n\nstruct mapped_device {\n\tstruct mutex suspend_lock;\n\n\tstruct mutex table_devices_lock;\n\tstruct list_head table_devices;\n\n\t \n\tvoid __rcu *map;\n\n\tunsigned long flags;\n\n\t \n\tstruct mutex type_lock;\n\tenum dm_queue_mode type;\n\n\tint numa_node_id;\n\tstruct request_queue *queue;\n\n\tatomic_t holders;\n\tatomic_t open_count;\n\n\tstruct dm_target *immutable_target;\n\tstruct target_type *immutable_target_type;\n\n\tchar name[16];\n\tstruct gendisk *disk;\n\tstruct dax_device *dax_dev;\n\n\twait_queue_head_t wait;\n\tunsigned long __percpu *pending_io;\n\n\t \n\tstruct hd_geometry geometry;\n\n\t \n\tstruct workqueue_struct *wq;\n\n\t \n\tstruct work_struct work;\n\tspinlock_t deferred_lock;\n\tstruct bio_list deferred;\n\n\t \n\tstruct work_struct requeue_work;\n\tstruct dm_io *requeue_list;\n\n\tvoid *interface_ptr;\n\n\t \n\twait_queue_head_t eventq;\n\tatomic_t event_nr;\n\tatomic_t uevent_seq;\n\tstruct list_head uevent_list;\n\tspinlock_t uevent_lock;  \n\n\t \n\tbool init_tio_pdu:1;\n\tstruct blk_mq_tag_set *tag_set;\n\n\tstruct dm_stats stats;\n\n\t \n\tunsigned int internal_suspend_count;\n\n\tint swap_bios;\n\tstruct semaphore swap_bios_semaphore;\n\tstruct mutex swap_bios_lock;\n\n\t \n\tstruct dm_md_mempools *mempools;\n\n\t \n\tstruct dm_kobject_holder kobj_holder;\n\n\tstruct srcu_struct io_barrier;\n\n#ifdef CONFIG_BLK_DEV_ZONED\n\tunsigned int nr_zones;\n\tunsigned int *zwp_offset;\n#endif\n\n#ifdef CONFIG_IMA\n\tstruct dm_ima_measurements ima;\n#endif\n};\n\n \n#define DMF_BLOCK_IO_FOR_SUSPEND 0\n#define DMF_SUSPENDED 1\n#define DMF_FROZEN 2\n#define DMF_FREEING 3\n#define DMF_DELETING 4\n#define DMF_NOFLUSH_SUSPENDING 5\n#define DMF_DEFERRED_REMOVE 6\n#define DMF_SUSPENDED_INTERNALLY 7\n#define DMF_POST_SUSPENDING 8\n#define DMF_EMULATE_ZONE_APPEND 9\n\nvoid disable_discard(struct mapped_device *md);\nvoid disable_write_zeroes(struct mapped_device *md);\n\nstatic inline sector_t dm_get_size(struct mapped_device *md)\n{\n\treturn get_capacity(md->disk);\n}\n\nstatic inline struct dm_stats *dm_get_stats(struct mapped_device *md)\n{\n\treturn &md->stats;\n}\n\nDECLARE_STATIC_KEY_FALSE(stats_enabled);\nDECLARE_STATIC_KEY_FALSE(swap_bios_enabled);\nDECLARE_STATIC_KEY_FALSE(zoned_enabled);\n\nstatic inline bool dm_emulate_zone_append(struct mapped_device *md)\n{\n\tif (blk_queue_is_zoned(md->queue))\n\t\treturn test_bit(DMF_EMULATE_ZONE_APPEND, &md->flags);\n\treturn false;\n}\n\n#define DM_TABLE_MAX_DEPTH 16\n\nstruct dm_table {\n\tstruct mapped_device *md;\n\tenum dm_queue_mode type;\n\n\t \n\tunsigned int depth;\n\tunsigned int counts[DM_TABLE_MAX_DEPTH];  \n\tsector_t *index[DM_TABLE_MAX_DEPTH];\n\n\tunsigned int num_targets;\n\tunsigned int num_allocated;\n\tsector_t *highs;\n\tstruct dm_target *targets;\n\n\tstruct target_type *immutable_target_type;\n\n\tbool integrity_supported:1;\n\tbool singleton:1;\n\tunsigned integrity_added:1;\n\n\t \n\tblk_mode_t mode;\n\n\t \n\tstruct list_head devices;\n\tstruct rw_semaphore devices_lock;\n\n\t \n\tvoid (*event_fn)(void *data);\n\tvoid *event_context;\n\n\tstruct dm_md_mempools *mempools;\n\n#ifdef CONFIG_BLK_INLINE_ENCRYPTION\n\tstruct blk_crypto_profile *crypto_profile;\n#endif\n};\n\nstatic inline struct dm_target *dm_table_get_target(struct dm_table *t,\n\t\t\t\t\t\t    unsigned int index)\n{\n\tBUG_ON(index >= t->num_targets);\n\treturn t->targets + index;\n}\n\n \n#define DM_TIO_MAGIC 28714\nstruct dm_target_io {\n\tunsigned short magic;\n\tblk_short_t flags;\n\tunsigned int target_bio_nr;\n\tstruct dm_io *io;\n\tstruct dm_target *ti;\n\tunsigned int *len_ptr;\n\tsector_t old_sector;\n\tstruct bio clone;\n};\n#define DM_TARGET_IO_BIO_OFFSET (offsetof(struct dm_target_io, clone))\n#define DM_IO_BIO_OFFSET \\\n\t(offsetof(struct dm_target_io, clone) + offsetof(struct dm_io, tio))\n\n \nenum {\n\tDM_TIO_INSIDE_DM_IO,\n\tDM_TIO_IS_DUPLICATE_BIO\n};\n\nstatic inline bool dm_tio_flagged(struct dm_target_io *tio, unsigned int bit)\n{\n\treturn (tio->flags & (1U << bit)) != 0;\n}\n\nstatic inline void dm_tio_set_flag(struct dm_target_io *tio, unsigned int bit)\n{\n\ttio->flags |= (1U << bit);\n}\n\nstatic inline bool dm_tio_is_normal(struct dm_target_io *tio)\n{\n\treturn (dm_tio_flagged(tio, DM_TIO_INSIDE_DM_IO) &&\n\t\t!dm_tio_flagged(tio, DM_TIO_IS_DUPLICATE_BIO));\n}\n\n \n#define DM_IO_MAGIC 19577\nstruct dm_io {\n\tunsigned short magic;\n\tblk_short_t flags;\n\tspinlock_t lock;\n\tunsigned long start_time;\n\tvoid *data;\n\tstruct dm_io *next;\n\tstruct dm_stats_aux stats_aux;\n\tblk_status_t status;\n\tatomic_t io_count;\n\tstruct mapped_device *md;\n\n\t \n\tstruct bio *orig_bio;\n\tunsigned int sector_offset;  \n\tunsigned int sectors;\n\n\t \n\tstruct dm_target_io tio;\n};\n\n \nenum {\n\tDM_IO_ACCOUNTED,\n\tDM_IO_WAS_SPLIT,\n\tDM_IO_BLK_STAT\n};\n\nstatic inline bool dm_io_flagged(struct dm_io *io, unsigned int bit)\n{\n\treturn (io->flags & (1U << bit)) != 0;\n}\n\nstatic inline void dm_io_set_flag(struct dm_io *io, unsigned int bit)\n{\n\tio->flags |= (1U << bit);\n}\n\nvoid dm_io_rewind(struct dm_io *io, struct bio_set *bs);\n\nstatic inline struct completion *dm_get_completion_from_kobject(struct kobject *kobj)\n{\n\treturn &container_of(kobj, struct dm_kobject_holder, kobj)->completion;\n}\n\nunsigned int __dm_get_module_param(unsigned int *module_param, unsigned int def, unsigned int max);\n\nstatic inline bool dm_message_test_buffer_overflow(char *result, unsigned int maxlen)\n{\n\treturn !maxlen || strlen(result) + 1 >= maxlen;\n}\n\nextern atomic_t dm_global_event_nr;\nextern wait_queue_head_t dm_global_eventq;\nvoid dm_issue_global_event(void);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}