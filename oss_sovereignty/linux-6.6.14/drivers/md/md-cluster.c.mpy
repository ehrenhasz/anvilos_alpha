{
  "module_name": "md-cluster.c",
  "hash_id": "b09a41f1cb92bc7ecc63601758890f85e17d0d3d5caf953474c73067cb92a758",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/md-cluster.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/dlm.h>\n#include <linux/sched.h>\n#include <linux/raid/md_p.h>\n#include \"md.h\"\n#include \"md-bitmap.h\"\n#include \"md-cluster.h\"\n\n#define LVB_SIZE\t64\n#define NEW_DEV_TIMEOUT 5000\n\nstruct dlm_lock_resource {\n\tdlm_lockspace_t *ls;\n\tstruct dlm_lksb lksb;\n\tchar *name;  \n\tuint32_t flags;  \n\twait_queue_head_t sync_locking;  \n\tbool sync_locking_done;\n\tvoid (*bast)(void *arg, int mode);  \n\tstruct mddev *mddev;  \n\tint mode;\n};\n\nstruct resync_info {\n\t__le64 lo;\n\t__le64 hi;\n};\n\n \n#define\t\tMD_CLUSTER_WAITING_FOR_NEWDISK\t\t1\n#define\t\tMD_CLUSTER_SUSPEND_READ_BALANCING\t2\n#define\t\tMD_CLUSTER_BEGIN_JOIN_CLUSTER\t\t3\n\n \n#define\t\tMD_CLUSTER_SEND_LOCK\t\t\t4\n \n#define\t\tMD_CLUSTER_SEND_LOCKED_ALREADY\t\t5\n \n#define\t\tMD_CLUSTER_ALREADY_IN_CLUSTER\t\t6\n#define\t\tMD_CLUSTER_PENDING_RECV_EVENT\t\t7\n#define \tMD_CLUSTER_HOLDING_MUTEX_FOR_RECVD\t\t8\n\nstruct md_cluster_info {\n\tstruct mddev *mddev;  \n\t \n\tdlm_lockspace_t *lockspace;\n\tint slot_number;\n\tstruct completion completion;\n\tstruct mutex recv_mutex;\n\tstruct dlm_lock_resource *bitmap_lockres;\n\tstruct dlm_lock_resource **other_bitmap_lockres;\n\tstruct dlm_lock_resource *resync_lockres;\n\tstruct list_head suspend_list;\n\n\tspinlock_t suspend_lock;\n\t \n\tsector_t suspend_lo;\n\tsector_t suspend_hi;\n\tint suspend_from;  \n\n\tstruct md_thread __rcu *recovery_thread;\n\tunsigned long recovery_map;\n\t \n\tstruct dlm_lock_resource *ack_lockres;\n\tstruct dlm_lock_resource *message_lockres;\n\tstruct dlm_lock_resource *token_lockres;\n\tstruct dlm_lock_resource *no_new_dev_lockres;\n\tstruct md_thread __rcu *recv_thread;\n\tstruct completion newdisk_completion;\n\twait_queue_head_t wait;\n\tunsigned long state;\n\t \n\tsector_t sync_low;\n\tsector_t sync_hi;\n};\n\nenum msg_type {\n\tMETADATA_UPDATED = 0,\n\tRESYNCING,\n\tNEWDISK,\n\tREMOVE,\n\tRE_ADD,\n\tBITMAP_NEEDS_SYNC,\n\tCHANGE_CAPACITY,\n\tBITMAP_RESIZE,\n};\n\nstruct cluster_msg {\n\t__le32 type;\n\t__le32 slot;\n\t \n\t__le64 low;\n\t__le64 high;\n\tchar uuid[16];\n\t__le32 raid_slot;\n};\n\nstatic void sync_ast(void *arg)\n{\n\tstruct dlm_lock_resource *res;\n\n\tres = arg;\n\tres->sync_locking_done = true;\n\twake_up(&res->sync_locking);\n}\n\nstatic int dlm_lock_sync(struct dlm_lock_resource *res, int mode)\n{\n\tint ret = 0;\n\n\tret = dlm_lock(res->ls, mode, &res->lksb,\n\t\t\tres->flags, res->name, strlen(res->name),\n\t\t\t0, sync_ast, res, res->bast);\n\tif (ret)\n\t\treturn ret;\n\twait_event(res->sync_locking, res->sync_locking_done);\n\tres->sync_locking_done = false;\n\tif (res->lksb.sb_status == 0)\n\t\tres->mode = mode;\n\treturn res->lksb.sb_status;\n}\n\nstatic int dlm_unlock_sync(struct dlm_lock_resource *res)\n{\n\treturn dlm_lock_sync(res, DLM_LOCK_NL);\n}\n\n \nstatic int dlm_lock_sync_interruptible(struct dlm_lock_resource *res, int mode,\n\t\t\t\t       struct mddev *mddev)\n{\n\tint ret = 0;\n\n\tret = dlm_lock(res->ls, mode, &res->lksb,\n\t\t\tres->flags, res->name, strlen(res->name),\n\t\t\t0, sync_ast, res, res->bast);\n\tif (ret)\n\t\treturn ret;\n\n\twait_event(res->sync_locking, res->sync_locking_done\n\t\t\t\t      || kthread_should_stop()\n\t\t\t\t      || test_bit(MD_CLOSING, &mddev->flags));\n\tif (!res->sync_locking_done) {\n\t\t \n\t\tret = dlm_unlock(res->ls, res->lksb.sb_lkid, DLM_LKF_CANCEL,\n\t\t\t&res->lksb, res);\n\t\tres->sync_locking_done = false;\n\t\tif (unlikely(ret != 0))\n\t\t\tpr_info(\"failed to cancel previous lock request \"\n\t\t\t\t \"%s return %d\\n\", res->name, ret);\n\t\treturn -EPERM;\n\t} else\n\t\tres->sync_locking_done = false;\n\tif (res->lksb.sb_status == 0)\n\t\tres->mode = mode;\n\treturn res->lksb.sb_status;\n}\n\nstatic struct dlm_lock_resource *lockres_init(struct mddev *mddev,\n\t\tchar *name, void (*bastfn)(void *arg, int mode), int with_lvb)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\tint ret, namelen;\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\n\tres = kzalloc(sizeof(struct dlm_lock_resource), GFP_KERNEL);\n\tif (!res)\n\t\treturn NULL;\n\tinit_waitqueue_head(&res->sync_locking);\n\tres->sync_locking_done = false;\n\tres->ls = cinfo->lockspace;\n\tres->mddev = mddev;\n\tres->mode = DLM_LOCK_IV;\n\tnamelen = strlen(name);\n\tres->name = kzalloc(namelen + 1, GFP_KERNEL);\n\tif (!res->name) {\n\t\tpr_err(\"md-cluster: Unable to allocate resource name for resource %s\\n\", name);\n\t\tgoto out_err;\n\t}\n\tstrscpy(res->name, name, namelen + 1);\n\tif (with_lvb) {\n\t\tres->lksb.sb_lvbptr = kzalloc(LVB_SIZE, GFP_KERNEL);\n\t\tif (!res->lksb.sb_lvbptr) {\n\t\t\tpr_err(\"md-cluster: Unable to allocate LVB for resource %s\\n\", name);\n\t\t\tgoto out_err;\n\t\t}\n\t\tres->flags = DLM_LKF_VALBLK;\n\t}\n\n\tif (bastfn)\n\t\tres->bast = bastfn;\n\n\tres->flags |= DLM_LKF_EXPEDITE;\n\n\tret = dlm_lock_sync(res, DLM_LOCK_NL);\n\tif (ret) {\n\t\tpr_err(\"md-cluster: Unable to lock NL on new lock resource %s\\n\", name);\n\t\tgoto out_err;\n\t}\n\tres->flags &= ~DLM_LKF_EXPEDITE;\n\tres->flags |= DLM_LKF_CONVERT;\n\n\treturn res;\nout_err:\n\tkfree(res->lksb.sb_lvbptr);\n\tkfree(res->name);\n\tkfree(res);\n\treturn NULL;\n}\n\nstatic void lockres_free(struct dlm_lock_resource *res)\n{\n\tint ret = 0;\n\n\tif (!res)\n\t\treturn;\n\n\t \n\tret = dlm_unlock(res->ls, res->lksb.sb_lkid, DLM_LKF_FORCEUNLOCK,\n\t\t&res->lksb, res);\n\tif (unlikely(ret != 0))\n\t\tpr_err(\"failed to unlock %s return %d\\n\", res->name, ret);\n\telse\n\t\twait_event(res->sync_locking, res->sync_locking_done);\n\n\tkfree(res->name);\n\tkfree(res->lksb.sb_lvbptr);\n\tkfree(res);\n}\n\nstatic void add_resync_info(struct dlm_lock_resource *lockres,\n\t\t\t    sector_t lo, sector_t hi)\n{\n\tstruct resync_info *ri;\n\n\tri = (struct resync_info *)lockres->lksb.sb_lvbptr;\n\tri->lo = cpu_to_le64(lo);\n\tri->hi = cpu_to_le64(hi);\n}\n\nstatic int read_resync_info(struct mddev *mddev,\n\t\t\t    struct dlm_lock_resource *lockres)\n{\n\tstruct resync_info ri;\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tint ret = 0;\n\n\tdlm_lock_sync(lockres, DLM_LOCK_CR);\n\tmemcpy(&ri, lockres->lksb.sb_lvbptr, sizeof(struct resync_info));\n\tif (le64_to_cpu(ri.hi) > 0) {\n\t\tcinfo->suspend_hi = le64_to_cpu(ri.hi);\n\t\tcinfo->suspend_lo = le64_to_cpu(ri.lo);\n\t\tret = 1;\n\t}\n\tdlm_unlock_sync(lockres);\n\treturn ret;\n}\n\nstatic void recover_bitmaps(struct md_thread *thread)\n{\n\tstruct mddev *mddev = thread->mddev;\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tstruct dlm_lock_resource *bm_lockres;\n\tchar str[64];\n\tint slot, ret;\n\tsector_t lo, hi;\n\n\twhile (cinfo->recovery_map) {\n\t\tslot = fls64((u64)cinfo->recovery_map) - 1;\n\n\t\tsnprintf(str, 64, \"bitmap%04d\", slot);\n\t\tbm_lockres = lockres_init(mddev, str, NULL, 1);\n\t\tif (!bm_lockres) {\n\t\t\tpr_err(\"md-cluster: Cannot initialize bitmaps\\n\");\n\t\t\tgoto clear_bit;\n\t\t}\n\n\t\tret = dlm_lock_sync_interruptible(bm_lockres, DLM_LOCK_PW, mddev);\n\t\tif (ret) {\n\t\t\tpr_err(\"md-cluster: Could not DLM lock %s: %d\\n\",\n\t\t\t\t\tstr, ret);\n\t\t\tgoto clear_bit;\n\t\t}\n\t\tret = md_bitmap_copy_from_slot(mddev, slot, &lo, &hi, true);\n\t\tif (ret) {\n\t\t\tpr_err(\"md-cluster: Could not copy data from bitmap %d\\n\", slot);\n\t\t\tgoto clear_bit;\n\t\t}\n\n\t\t \n\t\tspin_lock_irq(&cinfo->suspend_lock);\n\t\tcinfo->suspend_hi = 0;\n\t\tcinfo->suspend_lo = 0;\n\t\tcinfo->suspend_from = -1;\n\t\tspin_unlock_irq(&cinfo->suspend_lock);\n\n\t\t \n\t\tif (test_bit(MD_RESYNCING_REMOTE, &mddev->recovery) &&\n\t\t    test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery) &&\n\t\t    mddev->reshape_position != MaxSector)\n\t\t\tmd_wakeup_thread(mddev->sync_thread);\n\n\t\tif (hi > 0) {\n\t\t\tif (lo < mddev->recovery_cp)\n\t\t\t\tmddev->recovery_cp = lo;\n\t\t\t \n\t\t\tif (mddev->recovery_cp != MaxSector) {\n\t\t\t\t \n\t\t\t\tclear_bit(MD_RESYNCING_REMOTE,\n\t\t\t\t\t  &mddev->recovery);\n\t\t\t\tset_bit(MD_RECOVERY_NEEDED, &mddev->recovery);\n\t\t\t\tmd_wakeup_thread(mddev->thread);\n\t\t\t}\n\t\t}\nclear_bit:\n\t\tlockres_free(bm_lockres);\n\t\tclear_bit(slot, &cinfo->recovery_map);\n\t}\n}\n\nstatic void recover_prep(void *arg)\n{\n\tstruct mddev *mddev = arg;\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tset_bit(MD_CLUSTER_SUSPEND_READ_BALANCING, &cinfo->state);\n}\n\nstatic void __recover_slot(struct mddev *mddev, int slot)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\n\tset_bit(slot, &cinfo->recovery_map);\n\tif (!cinfo->recovery_thread) {\n\t\trcu_assign_pointer(cinfo->recovery_thread,\n\t\t\tmd_register_thread(recover_bitmaps, mddev, \"recover\"));\n\t\tif (!cinfo->recovery_thread) {\n\t\t\tpr_warn(\"md-cluster: Could not create recovery thread\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tmd_wakeup_thread(cinfo->recovery_thread);\n}\n\nstatic void recover_slot(void *arg, struct dlm_slot *slot)\n{\n\tstruct mddev *mddev = arg;\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\n\tpr_info(\"md-cluster: %s Node %d/%d down. My slot: %d. Initiating recovery.\\n\",\n\t\t\tmddev->bitmap_info.cluster_name,\n\t\t\tslot->nodeid, slot->slot,\n\t\t\tcinfo->slot_number);\n\t \n\t__recover_slot(mddev, slot->slot - 1);\n}\n\nstatic void recover_done(void *arg, struct dlm_slot *slots,\n\t\tint num_slots, int our_slot,\n\t\tuint32_t generation)\n{\n\tstruct mddev *mddev = arg;\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\n\tcinfo->slot_number = our_slot;\n\t \n\tif (test_bit(MD_CLUSTER_BEGIN_JOIN_CLUSTER, &cinfo->state)) {\n\t\tcomplete(&cinfo->completion);\n\t\tclear_bit(MD_CLUSTER_BEGIN_JOIN_CLUSTER, &cinfo->state);\n\t}\n\tclear_bit(MD_CLUSTER_SUSPEND_READ_BALANCING, &cinfo->state);\n}\n\n \nstatic const struct dlm_lockspace_ops md_ls_ops = {\n\t.recover_prep = recover_prep,\n\t.recover_slot = recover_slot,\n\t.recover_done = recover_done,\n};\n\n \nstatic void ack_bast(void *arg, int mode)\n{\n\tstruct dlm_lock_resource *res = arg;\n\tstruct md_cluster_info *cinfo = res->mddev->cluster_info;\n\n\tif (mode == DLM_LOCK_EX) {\n\t\tif (test_bit(MD_CLUSTER_ALREADY_IN_CLUSTER, &cinfo->state))\n\t\t\tmd_wakeup_thread(cinfo->recv_thread);\n\t\telse\n\t\t\tset_bit(MD_CLUSTER_PENDING_RECV_EVENT, &cinfo->state);\n\t}\n}\n\nstatic void remove_suspend_info(struct mddev *mddev, int slot)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tmddev->pers->quiesce(mddev, 1);\n\tspin_lock_irq(&cinfo->suspend_lock);\n\tcinfo->suspend_hi = 0;\n\tcinfo->suspend_lo = 0;\n\tspin_unlock_irq(&cinfo->suspend_lock);\n\tmddev->pers->quiesce(mddev, 0);\n}\n\nstatic void process_suspend_info(struct mddev *mddev,\n\t\tint slot, sector_t lo, sector_t hi)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tstruct mdp_superblock_1 *sb = NULL;\n\tstruct md_rdev *rdev;\n\n\tif (!hi) {\n\t\t \n\t\tclear_bit(MD_RESYNCING_REMOTE, &mddev->recovery);\n\t\tremove_suspend_info(mddev, slot);\n\t\tset_bit(MD_RECOVERY_NEEDED, &mddev->recovery);\n\t\tmd_wakeup_thread(mddev->thread);\n\t\treturn;\n\t}\n\n\trdev_for_each(rdev, mddev)\n\t\tif (rdev->raid_disk > -1 && !test_bit(Faulty, &rdev->flags)) {\n\t\t\tsb = page_address(rdev->sb_page);\n\t\t\tbreak;\n\t\t}\n\n\t \n\tif (sb && !(le32_to_cpu(sb->feature_map) & MD_FEATURE_RESHAPE_ACTIVE))\n\t\tmd_bitmap_sync_with_cluster(mddev, cinfo->sync_low,\n\t\t\t\t\t    cinfo->sync_hi, lo, hi);\n\tcinfo->sync_low = lo;\n\tcinfo->sync_hi = hi;\n\n\tmddev->pers->quiesce(mddev, 1);\n\tspin_lock_irq(&cinfo->suspend_lock);\n\tcinfo->suspend_from = slot;\n\tcinfo->suspend_lo = lo;\n\tcinfo->suspend_hi = hi;\n\tspin_unlock_irq(&cinfo->suspend_lock);\n\tmddev->pers->quiesce(mddev, 0);\n}\n\nstatic void process_add_new_disk(struct mddev *mddev, struct cluster_msg *cmsg)\n{\n\tchar disk_uuid[64];\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tchar event_name[] = \"EVENT=ADD_DEVICE\";\n\tchar raid_slot[16];\n\tchar *envp[] = {event_name, disk_uuid, raid_slot, NULL};\n\tint len;\n\n\tlen = snprintf(disk_uuid, 64, \"DEVICE_UUID=\");\n\tsprintf(disk_uuid + len, \"%pU\", cmsg->uuid);\n\tsnprintf(raid_slot, 16, \"RAID_DISK=%d\", le32_to_cpu(cmsg->raid_slot));\n\tpr_info(\"%s:%d Sending kobject change with %s and %s\\n\", __func__, __LINE__, disk_uuid, raid_slot);\n\tinit_completion(&cinfo->newdisk_completion);\n\tset_bit(MD_CLUSTER_WAITING_FOR_NEWDISK, &cinfo->state);\n\tkobject_uevent_env(&disk_to_dev(mddev->gendisk)->kobj, KOBJ_CHANGE, envp);\n\twait_for_completion_timeout(&cinfo->newdisk_completion,\n\t\t\tNEW_DEV_TIMEOUT);\n\tclear_bit(MD_CLUSTER_WAITING_FOR_NEWDISK, &cinfo->state);\n}\n\n\nstatic void process_metadata_update(struct mddev *mddev, struct cluster_msg *msg)\n{\n\tint got_lock = 0;\n\tstruct md_thread *thread;\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tmddev->good_device_nr = le32_to_cpu(msg->raid_slot);\n\n\tdlm_lock_sync(cinfo->no_new_dev_lockres, DLM_LOCK_CR);\n\n\t \n\tthread = rcu_dereference_protected(mddev->thread, true);\n\twait_event(thread->wqueue,\n\t\t   (got_lock = mddev_trylock(mddev)) ||\n\t\t    test_bit(MD_CLUSTER_HOLDING_MUTEX_FOR_RECVD, &cinfo->state));\n\tmd_reload_sb(mddev, mddev->good_device_nr);\n\tif (got_lock)\n\t\tmddev_unlock(mddev);\n}\n\nstatic void process_remove_disk(struct mddev *mddev, struct cluster_msg *msg)\n{\n\tstruct md_rdev *rdev;\n\n\trcu_read_lock();\n\trdev = md_find_rdev_nr_rcu(mddev, le32_to_cpu(msg->raid_slot));\n\tif (rdev) {\n\t\tset_bit(ClusterRemove, &rdev->flags);\n\t\tset_bit(MD_RECOVERY_NEEDED, &mddev->recovery);\n\t\tmd_wakeup_thread(mddev->thread);\n\t}\n\telse\n\t\tpr_warn(\"%s: %d Could not find disk(%d) to REMOVE\\n\",\n\t\t\t__func__, __LINE__, le32_to_cpu(msg->raid_slot));\n\trcu_read_unlock();\n}\n\nstatic void process_readd_disk(struct mddev *mddev, struct cluster_msg *msg)\n{\n\tstruct md_rdev *rdev;\n\n\trcu_read_lock();\n\trdev = md_find_rdev_nr_rcu(mddev, le32_to_cpu(msg->raid_slot));\n\tif (rdev && test_bit(Faulty, &rdev->flags))\n\t\tclear_bit(Faulty, &rdev->flags);\n\telse\n\t\tpr_warn(\"%s: %d Could not find disk(%d) which is faulty\",\n\t\t\t__func__, __LINE__, le32_to_cpu(msg->raid_slot));\n\trcu_read_unlock();\n}\n\nstatic int process_recvd_msg(struct mddev *mddev, struct cluster_msg *msg)\n{\n\tint ret = 0;\n\n\tif (WARN(mddev->cluster_info->slot_number - 1 == le32_to_cpu(msg->slot),\n\t\t\"node %d received its own msg\\n\", le32_to_cpu(msg->slot)))\n\t\treturn -1;\n\tswitch (le32_to_cpu(msg->type)) {\n\tcase METADATA_UPDATED:\n\t\tprocess_metadata_update(mddev, msg);\n\t\tbreak;\n\tcase CHANGE_CAPACITY:\n\t\tset_capacity_and_notify(mddev->gendisk, mddev->array_sectors);\n\t\tbreak;\n\tcase RESYNCING:\n\t\tset_bit(MD_RESYNCING_REMOTE, &mddev->recovery);\n\t\tprocess_suspend_info(mddev, le32_to_cpu(msg->slot),\n\t\t\t\t     le64_to_cpu(msg->low),\n\t\t\t\t     le64_to_cpu(msg->high));\n\t\tbreak;\n\tcase NEWDISK:\n\t\tprocess_add_new_disk(mddev, msg);\n\t\tbreak;\n\tcase REMOVE:\n\t\tprocess_remove_disk(mddev, msg);\n\t\tbreak;\n\tcase RE_ADD:\n\t\tprocess_readd_disk(mddev, msg);\n\t\tbreak;\n\tcase BITMAP_NEEDS_SYNC:\n\t\t__recover_slot(mddev, le32_to_cpu(msg->slot));\n\t\tbreak;\n\tcase BITMAP_RESIZE:\n\t\tif (le64_to_cpu(msg->high) != mddev->pers->size(mddev, 0, 0))\n\t\t\tret = md_bitmap_resize(mddev->bitmap,\n\t\t\t\t\t    le64_to_cpu(msg->high), 0, 0);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tpr_warn(\"%s:%d Received unknown message from %d\\n\",\n\t\t\t__func__, __LINE__, msg->slot);\n\t}\n\treturn ret;\n}\n\n \nstatic void recv_daemon(struct md_thread *thread)\n{\n\tstruct md_cluster_info *cinfo = thread->mddev->cluster_info;\n\tstruct dlm_lock_resource *ack_lockres = cinfo->ack_lockres;\n\tstruct dlm_lock_resource *message_lockres = cinfo->message_lockres;\n\tstruct cluster_msg msg;\n\tint ret;\n\n\tmutex_lock(&cinfo->recv_mutex);\n\t \n\tif (dlm_lock_sync(message_lockres, DLM_LOCK_CR)) {\n\t\tpr_err(\"md/raid1:failed to get CR on MESSAGE\\n\");\n\t\tmutex_unlock(&cinfo->recv_mutex);\n\t\treturn;\n\t}\n\n\t \n\tmemcpy(&msg, message_lockres->lksb.sb_lvbptr, sizeof(struct cluster_msg));\n\tret = process_recvd_msg(thread->mddev, &msg);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = dlm_unlock_sync(ack_lockres);\n\tif (unlikely(ret != 0))\n\t\tpr_info(\"unlock ack failed return %d\\n\", ret);\n\t \n\tret = dlm_lock_sync(message_lockres, DLM_LOCK_PR);\n\tif (unlikely(ret != 0))\n\t\tpr_info(\"lock PR on msg failed return %d\\n\", ret);\n\t \n\tret = dlm_lock_sync(ack_lockres, DLM_LOCK_CR);\n\tif (unlikely(ret != 0))\n\t\tpr_info(\"lock CR on ack failed return %d\\n\", ret);\nout:\n\t \n\tret = dlm_unlock_sync(message_lockres);\n\tif (unlikely(ret != 0))\n\t\tpr_info(\"unlock msg failed return %d\\n\", ret);\n\tmutex_unlock(&cinfo->recv_mutex);\n}\n\n \nstatic int lock_token(struct md_cluster_info *cinfo)\n{\n\tint error;\n\n\terror = dlm_lock_sync(cinfo->token_lockres, DLM_LOCK_EX);\n\tif (error) {\n\t\tpr_err(\"md-cluster(%s:%d): failed to get EX on TOKEN (%d)\\n\",\n\t\t\t\t__func__, __LINE__, error);\n\t} else {\n\t\t \n\t\tmutex_lock(&cinfo->recv_mutex);\n\t}\n\treturn error;\n}\n\n \nstatic int lock_comm(struct md_cluster_info *cinfo, bool mddev_locked)\n{\n\tint rv, set_bit = 0;\n\tstruct mddev *mddev = cinfo->mddev;\n\n\t \n\tif (mddev_locked && !test_bit(MD_CLUSTER_HOLDING_MUTEX_FOR_RECVD,\n\t\t\t\t      &cinfo->state)) {\n\t\trv = test_and_set_bit_lock(MD_CLUSTER_HOLDING_MUTEX_FOR_RECVD,\n\t\t\t\t\t      &cinfo->state);\n\t\tWARN_ON_ONCE(rv);\n\t\tmd_wakeup_thread(mddev->thread);\n\t\tset_bit = 1;\n\t}\n\n\twait_event(cinfo->wait,\n\t\t   !test_and_set_bit(MD_CLUSTER_SEND_LOCK, &cinfo->state));\n\trv = lock_token(cinfo);\n\tif (set_bit)\n\t\tclear_bit_unlock(MD_CLUSTER_HOLDING_MUTEX_FOR_RECVD, &cinfo->state);\n\treturn rv;\n}\n\nstatic void unlock_comm(struct md_cluster_info *cinfo)\n{\n\tWARN_ON(cinfo->token_lockres->mode != DLM_LOCK_EX);\n\tmutex_unlock(&cinfo->recv_mutex);\n\tdlm_unlock_sync(cinfo->token_lockres);\n\tclear_bit(MD_CLUSTER_SEND_LOCK, &cinfo->state);\n\twake_up(&cinfo->wait);\n}\n\n \nstatic int __sendmsg(struct md_cluster_info *cinfo, struct cluster_msg *cmsg)\n{\n\tint error;\n\tint slot = cinfo->slot_number - 1;\n\n\tcmsg->slot = cpu_to_le32(slot);\n\t \n\terror = dlm_lock_sync(cinfo->message_lockres, DLM_LOCK_EX);\n\tif (error) {\n\t\tpr_err(\"md-cluster: failed to get EX on MESSAGE (%d)\\n\", error);\n\t\tgoto failed_message;\n\t}\n\n\tmemcpy(cinfo->message_lockres->lksb.sb_lvbptr, (void *)cmsg,\n\t\t\tsizeof(struct cluster_msg));\n\t \n\terror = dlm_lock_sync(cinfo->message_lockres, DLM_LOCK_CW);\n\tif (error) {\n\t\tpr_err(\"md-cluster: failed to convert EX to CW on MESSAGE(%d)\\n\",\n\t\t\t\terror);\n\t\tgoto failed_ack;\n\t}\n\n\t \n\terror = dlm_lock_sync(cinfo->ack_lockres, DLM_LOCK_EX);\n\tif (error) {\n\t\tpr_err(\"md-cluster: failed to convert CR to EX on ACK(%d)\\n\",\n\t\t\t\terror);\n\t\tgoto failed_ack;\n\t}\n\n\t \n\terror = dlm_lock_sync(cinfo->ack_lockres, DLM_LOCK_CR);\n\tif (error) {\n\t\tpr_err(\"md-cluster: failed to convert EX to CR on ACK(%d)\\n\",\n\t\t\t\terror);\n\t\tgoto failed_ack;\n\t}\n\nfailed_ack:\n\terror = dlm_unlock_sync(cinfo->message_lockres);\n\tif (unlikely(error != 0)) {\n\t\tpr_err(\"md-cluster: failed convert to NL on MESSAGE(%d)\\n\",\n\t\t\terror);\n\t\t \n\t\tgoto failed_ack;\n\t}\nfailed_message:\n\treturn error;\n}\n\nstatic int sendmsg(struct md_cluster_info *cinfo, struct cluster_msg *cmsg,\n\t\t   bool mddev_locked)\n{\n\tint ret;\n\n\tret = lock_comm(cinfo, mddev_locked);\n\tif (!ret) {\n\t\tret = __sendmsg(cinfo, cmsg);\n\t\tunlock_comm(cinfo);\n\t}\n\treturn ret;\n}\n\nstatic int gather_all_resync_info(struct mddev *mddev, int total_slots)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tint i, ret = 0;\n\tstruct dlm_lock_resource *bm_lockres;\n\tchar str[64];\n\tsector_t lo, hi;\n\n\n\tfor (i = 0; i < total_slots; i++) {\n\t\tmemset(str, '\\0', 64);\n\t\tsnprintf(str, 64, \"bitmap%04d\", i);\n\t\tbm_lockres = lockres_init(mddev, str, NULL, 1);\n\t\tif (!bm_lockres)\n\t\t\treturn -ENOMEM;\n\t\tif (i == (cinfo->slot_number - 1)) {\n\t\t\tlockres_free(bm_lockres);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbm_lockres->flags |= DLM_LKF_NOQUEUE;\n\t\tret = dlm_lock_sync(bm_lockres, DLM_LOCK_PW);\n\t\tif (ret == -EAGAIN) {\n\t\t\tif (read_resync_info(mddev, bm_lockres)) {\n\t\t\t\tpr_info(\"%s:%d Resync[%llu..%llu] in progress on %d\\n\",\n\t\t\t\t\t\t__func__, __LINE__,\n\t\t\t\t\t(unsigned long long) cinfo->suspend_lo,\n\t\t\t\t\t(unsigned long long) cinfo->suspend_hi,\n\t\t\t\t\ti);\n\t\t\t\tcinfo->suspend_from = i;\n\t\t\t}\n\t\t\tret = 0;\n\t\t\tlockres_free(bm_lockres);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret) {\n\t\t\tlockres_free(bm_lockres);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = md_bitmap_copy_from_slot(mddev, i, &lo, &hi, false);\n\t\tif (ret) {\n\t\t\tpr_warn(\"md-cluster: Could not gather bitmaps from slot %d\", i);\n\t\t\tlockres_free(bm_lockres);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((hi > 0) && (lo < mddev->recovery_cp)) {\n\t\t\tset_bit(MD_RECOVERY_NEEDED, &mddev->recovery);\n\t\t\tmddev->recovery_cp = lo;\n\t\t\tmd_check_recovery(mddev);\n\t\t}\n\n\t\tlockres_free(bm_lockres);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int join(struct mddev *mddev, int nodes)\n{\n\tstruct md_cluster_info *cinfo;\n\tint ret, ops_rv;\n\tchar str[64];\n\n\tcinfo = kzalloc(sizeof(struct md_cluster_info), GFP_KERNEL);\n\tif (!cinfo)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&cinfo->suspend_list);\n\tspin_lock_init(&cinfo->suspend_lock);\n\tinit_completion(&cinfo->completion);\n\tset_bit(MD_CLUSTER_BEGIN_JOIN_CLUSTER, &cinfo->state);\n\tinit_waitqueue_head(&cinfo->wait);\n\tmutex_init(&cinfo->recv_mutex);\n\n\tmddev->cluster_info = cinfo;\n\tcinfo->mddev = mddev;\n\n\tmemset(str, 0, 64);\n\tsprintf(str, \"%pU\", mddev->uuid);\n\tret = dlm_new_lockspace(str, mddev->bitmap_info.cluster_name,\n\t\t\t\t0, LVB_SIZE, &md_ls_ops, mddev,\n\t\t\t\t&ops_rv, &cinfo->lockspace);\n\tif (ret)\n\t\tgoto err;\n\twait_for_completion(&cinfo->completion);\n\tif (nodes < cinfo->slot_number) {\n\t\tpr_err(\"md-cluster: Slot allotted(%d) is greater than available slots(%d).\",\n\t\t\tcinfo->slot_number, nodes);\n\t\tret = -ERANGE;\n\t\tgoto err;\n\t}\n\t \n\tret = -ENOMEM;\n\trcu_assign_pointer(cinfo->recv_thread,\n\t\t\tmd_register_thread(recv_daemon, mddev, \"cluster_recv\"));\n\tif (!cinfo->recv_thread) {\n\t\tpr_err(\"md-cluster: cannot allocate memory for recv_thread!\\n\");\n\t\tgoto err;\n\t}\n\tcinfo->message_lockres = lockres_init(mddev, \"message\", NULL, 1);\n\tif (!cinfo->message_lockres)\n\t\tgoto err;\n\tcinfo->token_lockres = lockres_init(mddev, \"token\", NULL, 0);\n\tif (!cinfo->token_lockres)\n\t\tgoto err;\n\tcinfo->no_new_dev_lockres = lockres_init(mddev, \"no-new-dev\", NULL, 0);\n\tif (!cinfo->no_new_dev_lockres)\n\t\tgoto err;\n\n\tret = dlm_lock_sync(cinfo->token_lockres, DLM_LOCK_EX);\n\tif (ret) {\n\t\tret = -EAGAIN;\n\t\tpr_err(\"md-cluster: can't join cluster to avoid lock issue\\n\");\n\t\tgoto err;\n\t}\n\tcinfo->ack_lockres = lockres_init(mddev, \"ack\", ack_bast, 0);\n\tif (!cinfo->ack_lockres) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\t \n\tif (dlm_lock_sync(cinfo->ack_lockres, DLM_LOCK_CR))\n\t\tpr_err(\"md-cluster: failed to get a sync CR lock on ACK!(%d)\\n\",\n\t\t\t\tret);\n\tdlm_unlock_sync(cinfo->token_lockres);\n\t \n\tif (dlm_lock_sync(cinfo->no_new_dev_lockres, DLM_LOCK_CR))\n\t\tpr_err(\"md-cluster: failed to get a sync CR lock on no-new-dev!(%d)\\n\", ret);\n\n\n\tpr_info(\"md-cluster: Joined cluster %s slot %d\\n\", str, cinfo->slot_number);\n\tsnprintf(str, 64, \"bitmap%04d\", cinfo->slot_number - 1);\n\tcinfo->bitmap_lockres = lockres_init(mddev, str, NULL, 1);\n\tif (!cinfo->bitmap_lockres) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (dlm_lock_sync(cinfo->bitmap_lockres, DLM_LOCK_PW)) {\n\t\tpr_err(\"Failed to get bitmap lock\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tcinfo->resync_lockres = lockres_init(mddev, \"resync\", NULL, 0);\n\tif (!cinfo->resync_lockres) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tset_bit(MD_CLUSTER_HOLDING_MUTEX_FOR_RECVD, &cinfo->state);\n\tmd_unregister_thread(mddev, &cinfo->recovery_thread);\n\tmd_unregister_thread(mddev, &cinfo->recv_thread);\n\tlockres_free(cinfo->message_lockres);\n\tlockres_free(cinfo->token_lockres);\n\tlockres_free(cinfo->ack_lockres);\n\tlockres_free(cinfo->no_new_dev_lockres);\n\tlockres_free(cinfo->resync_lockres);\n\tlockres_free(cinfo->bitmap_lockres);\n\tif (cinfo->lockspace)\n\t\tdlm_release_lockspace(cinfo->lockspace, 2);\n\tmddev->cluster_info = NULL;\n\tkfree(cinfo);\n\treturn ret;\n}\n\nstatic void load_bitmaps(struct mddev *mddev, int total_slots)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\n\t \n\tif (gather_all_resync_info(mddev, total_slots))\n\t\tpr_err(\"md-cluster: failed to gather all resyn infos\\n\");\n\tset_bit(MD_CLUSTER_ALREADY_IN_CLUSTER, &cinfo->state);\n\t \n\tif (test_and_clear_bit(MD_CLUSTER_PENDING_RECV_EVENT, &cinfo->state))\n\t\tmd_wakeup_thread(cinfo->recv_thread);\n}\n\nstatic void resync_bitmap(struct mddev *mddev)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tstruct cluster_msg cmsg = {0};\n\tint err;\n\n\tcmsg.type = cpu_to_le32(BITMAP_NEEDS_SYNC);\n\terr = sendmsg(cinfo, &cmsg, 1);\n\tif (err)\n\t\tpr_err(\"%s:%d: failed to send BITMAP_NEEDS_SYNC message (%d)\\n\",\n\t\t\t__func__, __LINE__, err);\n}\n\nstatic void unlock_all_bitmaps(struct mddev *mddev);\nstatic int leave(struct mddev *mddev)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\n\tif (!cinfo)\n\t\treturn 0;\n\n\t \n\tif ((cinfo->slot_number > 0 && mddev->recovery_cp != MaxSector) ||\n\t    (mddev->reshape_position != MaxSector &&\n\t     test_bit(MD_CLOSING, &mddev->flags)))\n\t\tresync_bitmap(mddev);\n\n\tset_bit(MD_CLUSTER_HOLDING_MUTEX_FOR_RECVD, &cinfo->state);\n\tmd_unregister_thread(mddev, &cinfo->recovery_thread);\n\tmd_unregister_thread(mddev, &cinfo->recv_thread);\n\tlockres_free(cinfo->message_lockres);\n\tlockres_free(cinfo->token_lockres);\n\tlockres_free(cinfo->ack_lockres);\n\tlockres_free(cinfo->no_new_dev_lockres);\n\tlockres_free(cinfo->resync_lockres);\n\tlockres_free(cinfo->bitmap_lockres);\n\tunlock_all_bitmaps(mddev);\n\tdlm_release_lockspace(cinfo->lockspace, 2);\n\tkfree(cinfo);\n\treturn 0;\n}\n\n \nstatic int slot_number(struct mddev *mddev)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\n\treturn cinfo->slot_number - 1;\n}\n\n \nstatic int metadata_update_start(struct mddev *mddev)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tint ret;\n\n\t \n\tret = test_and_set_bit_lock(MD_CLUSTER_HOLDING_MUTEX_FOR_RECVD,\n\t\t\t\t    &cinfo->state);\n\tWARN_ON_ONCE(ret);\n\tmd_wakeup_thread(mddev->thread);\n\n\twait_event(cinfo->wait,\n\t\t   !test_and_set_bit(MD_CLUSTER_SEND_LOCK, &cinfo->state) ||\n\t\t   test_and_clear_bit(MD_CLUSTER_SEND_LOCKED_ALREADY, &cinfo->state));\n\n\t \n\tif (cinfo->token_lockres->mode == DLM_LOCK_EX) {\n\t\tclear_bit_unlock(MD_CLUSTER_HOLDING_MUTEX_FOR_RECVD, &cinfo->state);\n\t\treturn 0;\n\t}\n\n\tret = lock_token(cinfo);\n\tclear_bit_unlock(MD_CLUSTER_HOLDING_MUTEX_FOR_RECVD, &cinfo->state);\n\treturn ret;\n}\n\nstatic int metadata_update_finish(struct mddev *mddev)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tstruct cluster_msg cmsg;\n\tstruct md_rdev *rdev;\n\tint ret = 0;\n\tint raid_slot = -1;\n\n\tmemset(&cmsg, 0, sizeof(cmsg));\n\tcmsg.type = cpu_to_le32(METADATA_UPDATED);\n\t \n\trdev_for_each(rdev, mddev)\n\t\tif (rdev->raid_disk > -1 && !test_bit(Faulty, &rdev->flags)) {\n\t\t\traid_slot = rdev->desc_nr;\n\t\t\tbreak;\n\t\t}\n\tif (raid_slot >= 0) {\n\t\tcmsg.raid_slot = cpu_to_le32(raid_slot);\n\t\tret = __sendmsg(cinfo, &cmsg);\n\t} else\n\t\tpr_warn(\"md-cluster: No good device id found to send\\n\");\n\tclear_bit(MD_CLUSTER_SEND_LOCKED_ALREADY, &cinfo->state);\n\tunlock_comm(cinfo);\n\treturn ret;\n}\n\nstatic void metadata_update_cancel(struct mddev *mddev)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tclear_bit(MD_CLUSTER_SEND_LOCKED_ALREADY, &cinfo->state);\n\tunlock_comm(cinfo);\n}\n\nstatic int update_bitmap_size(struct mddev *mddev, sector_t size)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tstruct cluster_msg cmsg = {0};\n\tint ret;\n\n\tcmsg.type = cpu_to_le32(BITMAP_RESIZE);\n\tcmsg.high = cpu_to_le64(size);\n\tret = sendmsg(cinfo, &cmsg, 0);\n\tif (ret)\n\t\tpr_err(\"%s:%d: failed to send BITMAP_RESIZE message (%d)\\n\",\n\t\t\t__func__, __LINE__, ret);\n\treturn ret;\n}\n\nstatic int resize_bitmaps(struct mddev *mddev, sector_t newsize, sector_t oldsize)\n{\n\tstruct bitmap_counts *counts;\n\tchar str[64];\n\tstruct dlm_lock_resource *bm_lockres;\n\tstruct bitmap *bitmap = mddev->bitmap;\n\tunsigned long my_pages = bitmap->counts.pages;\n\tint i, rv;\n\n\t \n\trv = update_bitmap_size(mddev, newsize);\n\tif (rv)\n\t\treturn rv;\n\n\tfor (i = 0; i < mddev->bitmap_info.nodes; i++) {\n\t\tif (i == md_cluster_ops->slot_number(mddev))\n\t\t\tcontinue;\n\n\t\tbitmap = get_bitmap_from_slot(mddev, i);\n\t\tif (IS_ERR(bitmap)) {\n\t\t\tpr_err(\"can't get bitmap from slot %d\\n\", i);\n\t\t\tbitmap = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tcounts = &bitmap->counts;\n\n\t\t \n\t\tsnprintf(str, 64, \"bitmap%04d\", i);\n\t\tbm_lockres = lockres_init(mddev, str, NULL, 1);\n\t\tif (!bm_lockres) {\n\t\t\tpr_err(\"Cannot initialize %s lock\\n\", str);\n\t\t\tgoto out;\n\t\t}\n\t\tbm_lockres->flags |= DLM_LKF_NOQUEUE;\n\t\trv = dlm_lock_sync(bm_lockres, DLM_LOCK_PW);\n\t\tif (!rv)\n\t\t\tcounts->pages = my_pages;\n\t\tlockres_free(bm_lockres);\n\n\t\tif (my_pages != counts->pages)\n\t\t\t \n\t\t\tgoto out;\n\t\tmd_bitmap_free(bitmap);\n\t}\n\n\treturn 0;\nout:\n\tmd_bitmap_free(bitmap);\n\tupdate_bitmap_size(mddev, oldsize);\n\treturn -1;\n}\n\n \nstatic int cluster_check_sync_size(struct mddev *mddev)\n{\n\tint i, rv;\n\tbitmap_super_t *sb;\n\tunsigned long my_sync_size, sync_size = 0;\n\tint node_num = mddev->bitmap_info.nodes;\n\tint current_slot = md_cluster_ops->slot_number(mddev);\n\tstruct bitmap *bitmap = mddev->bitmap;\n\tchar str[64];\n\tstruct dlm_lock_resource *bm_lockres;\n\n\tsb = kmap_atomic(bitmap->storage.sb_page);\n\tmy_sync_size = sb->sync_size;\n\tkunmap_atomic(sb);\n\n\tfor (i = 0; i < node_num; i++) {\n\t\tif (i == current_slot)\n\t\t\tcontinue;\n\n\t\tbitmap = get_bitmap_from_slot(mddev, i);\n\t\tif (IS_ERR(bitmap)) {\n\t\t\tpr_err(\"can't get bitmap from slot %d\\n\", i);\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tsnprintf(str, 64, \"bitmap%04d\", i);\n\t\tbm_lockres = lockres_init(mddev, str, NULL, 1);\n\t\tif (!bm_lockres) {\n\t\t\tpr_err(\"md-cluster: Cannot initialize %s\\n\", str);\n\t\t\tmd_bitmap_free(bitmap);\n\t\t\treturn -1;\n\t\t}\n\t\tbm_lockres->flags |= DLM_LKF_NOQUEUE;\n\t\trv = dlm_lock_sync(bm_lockres, DLM_LOCK_PW);\n\t\tif (!rv)\n\t\t\tmd_bitmap_update_sb(bitmap);\n\t\tlockres_free(bm_lockres);\n\n\t\tsb = kmap_atomic(bitmap->storage.sb_page);\n\t\tif (sync_size == 0)\n\t\t\tsync_size = sb->sync_size;\n\t\telse if (sync_size != sb->sync_size) {\n\t\t\tkunmap_atomic(sb);\n\t\t\tmd_bitmap_free(bitmap);\n\t\t\treturn -1;\n\t\t}\n\t\tkunmap_atomic(sb);\n\t\tmd_bitmap_free(bitmap);\n\t}\n\n\treturn (my_sync_size == sync_size) ? 0 : -1;\n}\n\n \nstatic void update_size(struct mddev *mddev, sector_t old_dev_sectors)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tstruct cluster_msg cmsg;\n\tstruct md_rdev *rdev;\n\tint ret = 0;\n\tint raid_slot = -1;\n\n\tmd_update_sb(mddev, 1);\n\tif (lock_comm(cinfo, 1)) {\n\t\tpr_err(\"%s: lock_comm failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tmemset(&cmsg, 0, sizeof(cmsg));\n\tcmsg.type = cpu_to_le32(METADATA_UPDATED);\n\trdev_for_each(rdev, mddev)\n\t\tif (rdev->raid_disk >= 0 && !test_bit(Faulty, &rdev->flags)) {\n\t\t\traid_slot = rdev->desc_nr;\n\t\t\tbreak;\n\t\t}\n\tif (raid_slot >= 0) {\n\t\tcmsg.raid_slot = cpu_to_le32(raid_slot);\n\t\t \n\t\tret = __sendmsg(cinfo, &cmsg);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s:%d: failed to send METADATA_UPDATED msg\\n\",\n\t\t\t       __func__, __LINE__);\n\t\t\tunlock_comm(cinfo);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tpr_err(\"md-cluster: No good device id found to send\\n\");\n\t\tunlock_comm(cinfo);\n\t\treturn;\n\t}\n\n\t \n\tif (cluster_check_sync_size(mddev) == 0) {\n\t\tmemset(&cmsg, 0, sizeof(cmsg));\n\t\tcmsg.type = cpu_to_le32(CHANGE_CAPACITY);\n\t\tret = __sendmsg(cinfo, &cmsg);\n\t\tif (ret)\n\t\t\tpr_err(\"%s:%d: failed to send CHANGE_CAPACITY msg\\n\",\n\t\t\t       __func__, __LINE__);\n\t\tset_capacity_and_notify(mddev->gendisk, mddev->array_sectors);\n\t} else {\n\t\t \n\t\tret = mddev->pers->resize(mddev, old_dev_sectors);\n\t\tret = __sendmsg(cinfo, &cmsg);\n\t\tif (ret)\n\t\t\tpr_err(\"%s:%d: failed to send METADATA_UPDATED msg\\n\",\n\t\t\t       __func__, __LINE__);\n\t}\n\tunlock_comm(cinfo);\n}\n\nstatic int resync_start(struct mddev *mddev)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\treturn dlm_lock_sync_interruptible(cinfo->resync_lockres, DLM_LOCK_EX, mddev);\n}\n\nstatic void resync_info_get(struct mddev *mddev, sector_t *lo, sector_t *hi)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\n\tspin_lock_irq(&cinfo->suspend_lock);\n\t*lo = cinfo->suspend_lo;\n\t*hi = cinfo->suspend_hi;\n\tspin_unlock_irq(&cinfo->suspend_lock);\n}\n\nstatic int resync_info_update(struct mddev *mddev, sector_t lo, sector_t hi)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tstruct resync_info ri;\n\tstruct cluster_msg cmsg = {0};\n\n\t \n\tif (hi == 0) {\n\t\tmemcpy(&ri, cinfo->bitmap_lockres->lksb.sb_lvbptr, sizeof(struct resync_info));\n\t\tif (le64_to_cpu(ri.hi) == 0)\n\t\t\treturn 0;\n\t}\n\n\tadd_resync_info(cinfo->bitmap_lockres, lo, hi);\n\t \n\tdlm_lock_sync(cinfo->bitmap_lockres, DLM_LOCK_PW);\n\tcmsg.type = cpu_to_le32(RESYNCING);\n\tcmsg.low = cpu_to_le64(lo);\n\tcmsg.high = cpu_to_le64(hi);\n\n\t \n\tif (lo == 0 && hi == 0)\n\t\treturn sendmsg(cinfo, &cmsg, 1);\n\telse\n\t\treturn sendmsg(cinfo, &cmsg, 0);\n}\n\nstatic int resync_finish(struct mddev *mddev)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tint ret = 0;\n\n\tclear_bit(MD_RESYNCING_REMOTE, &mddev->recovery);\n\n\t \n\tif (!test_bit(MD_CLOSING, &mddev->flags))\n\t\tret = resync_info_update(mddev, 0, 0);\n\tdlm_unlock_sync(cinfo->resync_lockres);\n\treturn ret;\n}\n\nstatic int area_resyncing(struct mddev *mddev, int direction,\n\t\tsector_t lo, sector_t hi)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tint ret = 0;\n\n\tif ((direction == READ) &&\n\t\ttest_bit(MD_CLUSTER_SUSPEND_READ_BALANCING, &cinfo->state))\n\t\treturn 1;\n\n\tspin_lock_irq(&cinfo->suspend_lock);\n\tif (hi > cinfo->suspend_lo && lo < cinfo->suspend_hi)\n\t\tret = 1;\n\tspin_unlock_irq(&cinfo->suspend_lock);\n\treturn ret;\n}\n\n \nstatic int add_new_disk(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tstruct cluster_msg cmsg;\n\tint ret = 0;\n\tstruct mdp_superblock_1 *sb = page_address(rdev->sb_page);\n\tchar *uuid = sb->device_uuid;\n\n\tmemset(&cmsg, 0, sizeof(cmsg));\n\tcmsg.type = cpu_to_le32(NEWDISK);\n\tmemcpy(cmsg.uuid, uuid, 16);\n\tcmsg.raid_slot = cpu_to_le32(rdev->desc_nr);\n\tif (lock_comm(cinfo, 1))\n\t\treturn -EAGAIN;\n\tret = __sendmsg(cinfo, &cmsg);\n\tif (ret) {\n\t\tunlock_comm(cinfo);\n\t\treturn ret;\n\t}\n\tcinfo->no_new_dev_lockres->flags |= DLM_LKF_NOQUEUE;\n\tret = dlm_lock_sync(cinfo->no_new_dev_lockres, DLM_LOCK_EX);\n\tcinfo->no_new_dev_lockres->flags &= ~DLM_LKF_NOQUEUE;\n\t \n\tif (ret == -EAGAIN)\n\t\tret = -ENOENT;\n\tif (ret)\n\t\tunlock_comm(cinfo);\n\telse {\n\t\tdlm_lock_sync(cinfo->no_new_dev_lockres, DLM_LOCK_CR);\n\t\t \n\t\tset_bit(MD_CLUSTER_SEND_LOCKED_ALREADY, &cinfo->state);\n\t\twake_up(&cinfo->wait);\n\t}\n\treturn ret;\n}\n\nstatic void add_new_disk_cancel(struct mddev *mddev)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tclear_bit(MD_CLUSTER_SEND_LOCKED_ALREADY, &cinfo->state);\n\tunlock_comm(cinfo);\n}\n\nstatic int new_disk_ack(struct mddev *mddev, bool ack)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\n\tif (!test_bit(MD_CLUSTER_WAITING_FOR_NEWDISK, &cinfo->state)) {\n\t\tpr_warn(\"md-cluster(%s): Spurious cluster confirmation\\n\", mdname(mddev));\n\t\treturn -EINVAL;\n\t}\n\n\tif (ack)\n\t\tdlm_unlock_sync(cinfo->no_new_dev_lockres);\n\tcomplete(&cinfo->newdisk_completion);\n\treturn 0;\n}\n\nstatic int remove_disk(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tstruct cluster_msg cmsg = {0};\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tcmsg.type = cpu_to_le32(REMOVE);\n\tcmsg.raid_slot = cpu_to_le32(rdev->desc_nr);\n\treturn sendmsg(cinfo, &cmsg, 1);\n}\n\nstatic int lock_all_bitmaps(struct mddev *mddev)\n{\n\tint slot, my_slot, ret, held = 1, i = 0;\n\tchar str[64];\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\n\tcinfo->other_bitmap_lockres =\n\t\tkcalloc(mddev->bitmap_info.nodes - 1,\n\t\t\tsizeof(struct dlm_lock_resource *), GFP_KERNEL);\n\tif (!cinfo->other_bitmap_lockres) {\n\t\tpr_err(\"md: can't alloc mem for other bitmap locks\\n\");\n\t\treturn 0;\n\t}\n\n\tmy_slot = slot_number(mddev);\n\tfor (slot = 0; slot < mddev->bitmap_info.nodes; slot++) {\n\t\tif (slot == my_slot)\n\t\t\tcontinue;\n\n\t\tmemset(str, '\\0', 64);\n\t\tsnprintf(str, 64, \"bitmap%04d\", slot);\n\t\tcinfo->other_bitmap_lockres[i] = lockres_init(mddev, str, NULL, 1);\n\t\tif (!cinfo->other_bitmap_lockres[i])\n\t\t\treturn -ENOMEM;\n\n\t\tcinfo->other_bitmap_lockres[i]->flags |= DLM_LKF_NOQUEUE;\n\t\tret = dlm_lock_sync(cinfo->other_bitmap_lockres[i], DLM_LOCK_PW);\n\t\tif (ret)\n\t\t\theld = -1;\n\t\ti++;\n\t}\n\n\treturn held;\n}\n\nstatic void unlock_all_bitmaps(struct mddev *mddev)\n{\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\tint i;\n\n\t \n\tif (cinfo->other_bitmap_lockres) {\n\t\tfor (i = 0; i < mddev->bitmap_info.nodes - 1; i++) {\n\t\t\tif (cinfo->other_bitmap_lockres[i]) {\n\t\t\t\tlockres_free(cinfo->other_bitmap_lockres[i]);\n\t\t\t}\n\t\t}\n\t\tkfree(cinfo->other_bitmap_lockres);\n\t\tcinfo->other_bitmap_lockres = NULL;\n\t}\n}\n\nstatic int gather_bitmaps(struct md_rdev *rdev)\n{\n\tint sn, err;\n\tsector_t lo, hi;\n\tstruct cluster_msg cmsg = {0};\n\tstruct mddev *mddev = rdev->mddev;\n\tstruct md_cluster_info *cinfo = mddev->cluster_info;\n\n\tcmsg.type = cpu_to_le32(RE_ADD);\n\tcmsg.raid_slot = cpu_to_le32(rdev->desc_nr);\n\terr = sendmsg(cinfo, &cmsg, 1);\n\tif (err)\n\t\tgoto out;\n\n\tfor (sn = 0; sn < mddev->bitmap_info.nodes; sn++) {\n\t\tif (sn == (cinfo->slot_number - 1))\n\t\t\tcontinue;\n\t\terr = md_bitmap_copy_from_slot(mddev, sn, &lo, &hi, false);\n\t\tif (err) {\n\t\t\tpr_warn(\"md-cluster: Could not gather bitmaps from slot %d\", sn);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((hi > 0) && (lo < mddev->recovery_cp))\n\t\t\tmddev->recovery_cp = lo;\n\t}\nout:\n\treturn err;\n}\n\nstatic struct md_cluster_operations cluster_ops = {\n\t.join   = join,\n\t.leave  = leave,\n\t.slot_number = slot_number,\n\t.resync_start = resync_start,\n\t.resync_finish = resync_finish,\n\t.resync_info_update = resync_info_update,\n\t.resync_info_get = resync_info_get,\n\t.metadata_update_start = metadata_update_start,\n\t.metadata_update_finish = metadata_update_finish,\n\t.metadata_update_cancel = metadata_update_cancel,\n\t.area_resyncing = area_resyncing,\n\t.add_new_disk = add_new_disk,\n\t.add_new_disk_cancel = add_new_disk_cancel,\n\t.new_disk_ack = new_disk_ack,\n\t.remove_disk = remove_disk,\n\t.load_bitmaps = load_bitmaps,\n\t.gather_bitmaps = gather_bitmaps,\n\t.resize_bitmaps = resize_bitmaps,\n\t.lock_all_bitmaps = lock_all_bitmaps,\n\t.unlock_all_bitmaps = unlock_all_bitmaps,\n\t.update_size = update_size,\n};\n\nstatic int __init cluster_init(void)\n{\n\tpr_warn(\"md-cluster: support raid1 and raid10 (limited support)\\n\");\n\tpr_info(\"Registering Cluster MD functions\\n\");\n\tregister_md_cluster_operations(&cluster_ops, THIS_MODULE);\n\treturn 0;\n}\n\nstatic void cluster_exit(void)\n{\n\tunregister_md_cluster_operations();\n}\n\nmodule_init(cluster_init);\nmodule_exit(cluster_exit);\nMODULE_AUTHOR(\"SUSE\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Clustering support for MD\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}