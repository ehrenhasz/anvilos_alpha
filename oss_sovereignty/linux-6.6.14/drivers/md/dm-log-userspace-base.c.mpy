{
  "module_name": "dm-log-userspace-base.c",
  "hash_id": "8cb08758b32283cdd7454a503d5a27a5672d8c9ba9414fa1f4f483f2104f5bcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-log-userspace-base.c",
  "human_readable_source": "\n \n\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/dm-dirty-log.h>\n#include <linux/device-mapper.h>\n#include <linux/dm-log-userspace.h>\n#include <linux/module.h>\n#include <linux/workqueue.h>\n\n#include \"dm-log-userspace-transfer.h\"\n\n#define DM_LOG_USERSPACE_VSN \"1.3.0\"\n\n#define FLUSH_ENTRY_POOL_SIZE 16\n\nstruct dm_dirty_log_flush_entry {\n\tint type;\n\tregion_t region;\n\tstruct list_head list;\n};\n\n \n#define MAX_FLUSH_GROUP_COUNT 32\n\nstruct log_c {\n\tstruct dm_target *ti;\n\tstruct dm_dev *log_dev;\n\n\tchar *usr_argv_str;\n\tuint32_t usr_argc;\n\n\tuint32_t region_size;\n\tregion_t region_count;\n\tuint64_t luid;\n\tchar uuid[DM_UUID_LEN];\n\n\t \n\tspinlock_t flush_lock;\n\tstruct list_head mark_list;\n\tstruct list_head clear_list;\n\n\t \n\tuint64_t in_sync_hint;\n\n\t \n\tstruct workqueue_struct *dmlog_wq;\n\tstruct delayed_work flush_log_work;\n\tatomic_t sched_flush;\n\n\t \n\tuint32_t integrated_flush;\n\n\tmempool_t flush_entry_pool;\n};\n\nstatic struct kmem_cache *_flush_entry_cache;\n\nstatic int userspace_do_request(struct log_c *lc, const char *uuid,\n\t\t\t\tint request_type, char *data, size_t data_size,\n\t\t\t\tchar *rdata, size_t *rdata_size)\n{\n\tint r;\n\n\t \nretry:\n\tr = dm_consult_userspace(uuid, lc->luid, request_type, data,\n\t\t\t\t data_size, rdata, rdata_size);\n\n\tif (r != -ESRCH)\n\t\treturn r;\n\n\tDMERR(\" Userspace log server not found.\");\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(2*HZ);\n\t\tDMWARN(\"Attempting to contact userspace log server...\");\n\t\tr = dm_consult_userspace(uuid, lc->luid, DM_ULOG_CTR,\n\t\t\t\t\t lc->usr_argv_str,\n\t\t\t\t\t strlen(lc->usr_argv_str) + 1,\n\t\t\t\t\t NULL, NULL);\n\t\tif (!r)\n\t\t\tbreak;\n\t}\n\tDMINFO(\"Reconnected to userspace log server... DM_ULOG_CTR complete\");\n\tr = dm_consult_userspace(uuid, lc->luid, DM_ULOG_RESUME, NULL,\n\t\t\t\t 0, NULL, NULL);\n\tif (!r)\n\t\tgoto retry;\n\n\tDMERR(\"Error trying to resume userspace log: %d\", r);\n\n\treturn -ESRCH;\n}\n\nstatic int build_constructor_string(struct dm_target *ti,\n\t\t\t\t    unsigned int argc, char **argv,\n\t\t\t\t    char **ctr_str)\n{\n\tint i, str_size;\n\tchar *str = NULL;\n\n\t*ctr_str = NULL;\n\n\t \n\tfor (i = 0, str_size = 0; i < argc; i++)\n\t\tstr_size += strlen(argv[i]) + 1;  \n\n\tstr_size += 20;  \n\n\tstr = kzalloc(str_size, GFP_KERNEL);\n\tif (!str) {\n\t\tDMWARN(\"Unable to allocate memory for constructor string\");\n\t\treturn -ENOMEM;\n\t}\n\n\tstr_size = sprintf(str, \"%llu\", (unsigned long long)ti->len);\n\tfor (i = 0; i < argc; i++)\n\t\tstr_size += sprintf(str + str_size, \" %s\", argv[i]);\n\n\t*ctr_str = str;\n\treturn str_size;\n}\n\nstatic void do_flush(struct work_struct *work)\n{\n\tint r;\n\tstruct log_c *lc = container_of(work, struct log_c, flush_log_work.work);\n\n\tatomic_set(&lc->sched_flush, 0);\n\n\tr = userspace_do_request(lc, lc->uuid, DM_ULOG_FLUSH, NULL, 0, NULL, NULL);\n\n\tif (r)\n\t\tdm_table_event(lc->ti->table);\n}\n\n \nstatic int userspace_ctr(struct dm_dirty_log *log, struct dm_target *ti,\n\t\t\t unsigned int argc, char **argv)\n{\n\tint r = 0;\n\tint str_size;\n\tchar *ctr_str = NULL;\n\tstruct log_c *lc = NULL;\n\tuint64_t rdata;\n\tsize_t rdata_size = sizeof(rdata);\n\tchar *devices_rdata = NULL;\n\tsize_t devices_rdata_size = DM_NAME_LEN;\n\n\tif (argc < 3) {\n\t\tDMWARN(\"Too few arguments to userspace dirty log\");\n\t\treturn -EINVAL;\n\t}\n\n\tlc = kzalloc(sizeof(*lc), GFP_KERNEL);\n\tif (!lc) {\n\t\tDMWARN(\"Unable to allocate userspace log context.\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tlc->luid = (unsigned long)lc;\n\n\tlc->ti = ti;\n\n\tif (strlen(argv[0]) > (DM_UUID_LEN - 1)) {\n\t\tDMWARN(\"UUID argument too long.\");\n\t\tkfree(lc);\n\t\treturn -EINVAL;\n\t}\n\n\tlc->usr_argc = argc;\n\n\tstrncpy(lc->uuid, argv[0], DM_UUID_LEN);\n\targc--;\n\targv++;\n\tspin_lock_init(&lc->flush_lock);\n\tINIT_LIST_HEAD(&lc->mark_list);\n\tINIT_LIST_HEAD(&lc->clear_list);\n\n\tif (!strcasecmp(argv[0], \"integrated_flush\")) {\n\t\tlc->integrated_flush = 1;\n\t\targc--;\n\t\targv++;\n\t}\n\n\tstr_size = build_constructor_string(ti, argc, argv, &ctr_str);\n\tif (str_size < 0) {\n\t\tkfree(lc);\n\t\treturn str_size;\n\t}\n\n\tdevices_rdata = kzalloc(devices_rdata_size, GFP_KERNEL);\n\tif (!devices_rdata) {\n\t\tDMERR(\"Failed to allocate memory for device information\");\n\t\tr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tr = mempool_init_slab_pool(&lc->flush_entry_pool, FLUSH_ENTRY_POOL_SIZE,\n\t\t\t\t   _flush_entry_cache);\n\tif (r) {\n\t\tDMERR(\"Failed to create flush_entry_pool\");\n\t\tgoto out;\n\t}\n\n\t \n\tr = dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_CTR,\n\t\t\t\t ctr_str, str_size,\n\t\t\t\t devices_rdata, &devices_rdata_size);\n\n\tif (r < 0) {\n\t\tif (r == -ESRCH)\n\t\t\tDMERR(\"Userspace log server not found\");\n\t\telse\n\t\t\tDMERR(\"Userspace log server failed to create log\");\n\t\tgoto out;\n\t}\n\n\t \n\trdata_size = sizeof(rdata);\n\tr = dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_GET_REGION_SIZE,\n\t\t\t\t NULL, 0, (char *)&rdata, &rdata_size);\n\n\tif (r) {\n\t\tDMERR(\"Failed to get region size of dirty log\");\n\t\tgoto out;\n\t}\n\n\tlc->region_size = (uint32_t)rdata;\n\tlc->region_count = dm_sector_div_up(ti->len, lc->region_size);\n\n\tif (devices_rdata_size) {\n\t\tif (devices_rdata[devices_rdata_size - 1] != '\\0') {\n\t\t\tDMERR(\"DM_ULOG_CTR device return string not properly terminated\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tr = dm_get_device(ti, devices_rdata,\n\t\t\t\t  dm_table_get_mode(ti->table), &lc->log_dev);\n\t\tif (r)\n\t\t\tDMERR(\"Failed to register %s with device-mapper\",\n\t\t\t      devices_rdata);\n\t}\n\n\tif (lc->integrated_flush) {\n\t\tlc->dmlog_wq = alloc_workqueue(\"dmlogd\", WQ_MEM_RECLAIM, 0);\n\t\tif (!lc->dmlog_wq) {\n\t\t\tDMERR(\"couldn't start dmlogd\");\n\t\t\tr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&lc->flush_log_work, do_flush);\n\t\tatomic_set(&lc->sched_flush, 0);\n\t}\n\nout:\n\tkfree(devices_rdata);\n\tif (r) {\n\t\tmempool_exit(&lc->flush_entry_pool);\n\t\tkfree(lc);\n\t\tkfree(ctr_str);\n\t} else {\n\t\tlc->usr_argv_str = ctr_str;\n\t\tlog->context = lc;\n\t}\n\n\treturn r;\n}\n\nstatic void userspace_dtr(struct dm_dirty_log *log)\n{\n\tstruct log_c *lc = log->context;\n\n\tif (lc->integrated_flush) {\n\t\t \n\t\tif (atomic_read(&lc->sched_flush))\n\t\t\tflush_delayed_work(&lc->flush_log_work);\n\n\t\tdestroy_workqueue(lc->dmlog_wq);\n\t}\n\n\t(void) dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_DTR,\n\t\t\t\t    NULL, 0, NULL, NULL);\n\n\tif (lc->log_dev)\n\t\tdm_put_device(lc->ti, lc->log_dev);\n\n\tmempool_exit(&lc->flush_entry_pool);\n\n\tkfree(lc->usr_argv_str);\n\tkfree(lc);\n}\n\nstatic int userspace_presuspend(struct dm_dirty_log *log)\n{\n\tint r;\n\tstruct log_c *lc = log->context;\n\n\tr = dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_PRESUSPEND,\n\t\t\t\t NULL, 0, NULL, NULL);\n\n\treturn r;\n}\n\nstatic int userspace_postsuspend(struct dm_dirty_log *log)\n{\n\tint r;\n\tstruct log_c *lc = log->context;\n\n\t \n\tif (lc->integrated_flush && atomic_read(&lc->sched_flush))\n\t\tflush_delayed_work(&lc->flush_log_work);\n\n\tr = dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_POSTSUSPEND,\n\t\t\t\t NULL, 0, NULL, NULL);\n\n\treturn r;\n}\n\nstatic int userspace_resume(struct dm_dirty_log *log)\n{\n\tint r;\n\tstruct log_c *lc = log->context;\n\n\tlc->in_sync_hint = 0;\n\tr = dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_RESUME,\n\t\t\t\t NULL, 0, NULL, NULL);\n\n\treturn r;\n}\n\nstatic uint32_t userspace_get_region_size(struct dm_dirty_log *log)\n{\n\tstruct log_c *lc = log->context;\n\n\treturn lc->region_size;\n}\n\n \nstatic int userspace_is_clean(struct dm_dirty_log *log, region_t region)\n{\n\tint r;\n\tuint64_t region64 = (uint64_t)region;\n\tint64_t is_clean;\n\tsize_t rdata_size;\n\tstruct log_c *lc = log->context;\n\n\trdata_size = sizeof(is_clean);\n\tr = userspace_do_request(lc, lc->uuid, DM_ULOG_IS_CLEAN,\n\t\t\t\t (char *)&region64, sizeof(region64),\n\t\t\t\t (char *)&is_clean, &rdata_size);\n\n\treturn (r) ? 0 : (int)is_clean;\n}\n\n \nstatic int userspace_in_sync(struct dm_dirty_log *log, region_t region,\n\t\t\t     int can_block)\n{\n\tint r;\n\tuint64_t region64 = region;\n\tint64_t in_sync;\n\tsize_t rdata_size;\n\tstruct log_c *lc = log->context;\n\n\t \n\tif (!can_block)\n\t\treturn -EWOULDBLOCK;\n\n\trdata_size = sizeof(in_sync);\n\tr = userspace_do_request(lc, lc->uuid, DM_ULOG_IN_SYNC,\n\t\t\t\t (char *)&region64, sizeof(region64),\n\t\t\t\t (char *)&in_sync, &rdata_size);\n\treturn (r) ? 0 : (int)in_sync;\n}\n\nstatic int flush_one_by_one(struct log_c *lc, struct list_head *flush_list)\n{\n\tint r = 0;\n\tstruct dm_dirty_log_flush_entry *fe;\n\n\tlist_for_each_entry(fe, flush_list, list) {\n\t\tr = userspace_do_request(lc, lc->uuid, fe->type,\n\t\t\t\t\t (char *)&fe->region,\n\t\t\t\t\t sizeof(fe->region),\n\t\t\t\t\t NULL, NULL);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic int flush_by_group(struct log_c *lc, struct list_head *flush_list,\n\t\t\t  int flush_with_payload)\n{\n\tint r = 0;\n\tint count;\n\tuint32_t type = 0;\n\tstruct dm_dirty_log_flush_entry *fe, *tmp_fe;\n\tLIST_HEAD(tmp_list);\n\tuint64_t group[MAX_FLUSH_GROUP_COUNT];\n\n\t \n\twhile (!list_empty(flush_list)) {\n\t\tcount = 0;\n\n\t\tlist_for_each_entry_safe(fe, tmp_fe, flush_list, list) {\n\t\t\tgroup[count] = fe->region;\n\t\t\tcount++;\n\n\t\t\tlist_move(&fe->list, &tmp_list);\n\n\t\t\ttype = fe->type;\n\t\t\tif (count >= MAX_FLUSH_GROUP_COUNT)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (flush_with_payload) {\n\t\t\tr = userspace_do_request(lc, lc->uuid, DM_ULOG_FLUSH,\n\t\t\t\t\t\t (char *)(group),\n\t\t\t\t\t\t count * sizeof(uint64_t),\n\t\t\t\t\t\t NULL, NULL);\n\t\t\t \n\t\t\tif (r)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tr = userspace_do_request(lc, lc->uuid, type,\n\t\t\t\t\t\t (char *)(group),\n\t\t\t\t\t\t count * sizeof(uint64_t),\n\t\t\t\t\t\t NULL, NULL);\n\t\t\tif (r) {\n\t\t\t\t \n\t\t\t\tlist_splice_init(&tmp_list, flush_list);\n\t\t\t\tr = flush_one_by_one(lc, flush_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlist_splice_init(&tmp_list, flush_list);\n\n\treturn r;\n}\n\n \nstatic int userspace_flush(struct dm_dirty_log *log)\n{\n\tint r = 0;\n\tunsigned long flags;\n\tstruct log_c *lc = log->context;\n\tLIST_HEAD(mark_list);\n\tLIST_HEAD(clear_list);\n\tint mark_list_is_empty;\n\tint clear_list_is_empty;\n\tstruct dm_dirty_log_flush_entry *fe, *tmp_fe;\n\tmempool_t *flush_entry_pool = &lc->flush_entry_pool;\n\n\tspin_lock_irqsave(&lc->flush_lock, flags);\n\tlist_splice_init(&lc->mark_list, &mark_list);\n\tlist_splice_init(&lc->clear_list, &clear_list);\n\tspin_unlock_irqrestore(&lc->flush_lock, flags);\n\n\tmark_list_is_empty = list_empty(&mark_list);\n\tclear_list_is_empty = list_empty(&clear_list);\n\n\tif (mark_list_is_empty && clear_list_is_empty)\n\t\treturn 0;\n\n\tr = flush_by_group(lc, &clear_list, 0);\n\tif (r)\n\t\tgoto out;\n\n\tif (!lc->integrated_flush) {\n\t\tr = flush_by_group(lc, &mark_list, 0);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = userspace_do_request(lc, lc->uuid, DM_ULOG_FLUSH,\n\t\t\t\t\t NULL, 0, NULL, NULL);\n\t\tgoto out;\n\t}\n\n\t \n\tr = flush_by_group(lc, &mark_list, 1);\n\tif (r)\n\t\tgoto out;\n\n\tif (mark_list_is_empty && !atomic_read(&lc->sched_flush)) {\n\t\t \n\t\tqueue_delayed_work(lc->dmlog_wq, &lc->flush_log_work, 3 * HZ);\n\t\tatomic_set(&lc->sched_flush, 1);\n\t} else {\n\t\t \n\t\tcancel_delayed_work(&lc->flush_log_work);\n\t\tatomic_set(&lc->sched_flush, 0);\n\t}\n\nout:\n\t \n\tlist_for_each_entry_safe(fe, tmp_fe, &mark_list, list) {\n\t\tlist_del(&fe->list);\n\t\tmempool_free(fe, flush_entry_pool);\n\t}\n\tlist_for_each_entry_safe(fe, tmp_fe, &clear_list, list) {\n\t\tlist_del(&fe->list);\n\t\tmempool_free(fe, flush_entry_pool);\n\t}\n\n\tif (r)\n\t\tdm_table_event(lc->ti->table);\n\n\treturn r;\n}\n\n \nstatic void userspace_mark_region(struct dm_dirty_log *log, region_t region)\n{\n\tunsigned long flags;\n\tstruct log_c *lc = log->context;\n\tstruct dm_dirty_log_flush_entry *fe;\n\n\t \n\tfe = mempool_alloc(&lc->flush_entry_pool, GFP_NOIO);\n\tBUG_ON(!fe);\n\n\tspin_lock_irqsave(&lc->flush_lock, flags);\n\tfe->type = DM_ULOG_MARK_REGION;\n\tfe->region = region;\n\tlist_add(&fe->list, &lc->mark_list);\n\tspin_unlock_irqrestore(&lc->flush_lock, flags);\n}\n\n \nstatic void userspace_clear_region(struct dm_dirty_log *log, region_t region)\n{\n\tunsigned long flags;\n\tstruct log_c *lc = log->context;\n\tstruct dm_dirty_log_flush_entry *fe;\n\n\t \n\tfe = mempool_alloc(&lc->flush_entry_pool, GFP_ATOMIC);\n\tif (!fe) {\n\t\tDMERR(\"Failed to allocate memory to clear region.\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&lc->flush_lock, flags);\n\tfe->type = DM_ULOG_CLEAR_REGION;\n\tfe->region = region;\n\tlist_add(&fe->list, &lc->clear_list);\n\tspin_unlock_irqrestore(&lc->flush_lock, flags);\n}\n\n \nstatic int userspace_get_resync_work(struct dm_dirty_log *log, region_t *region)\n{\n\tint r;\n\tsize_t rdata_size;\n\tstruct log_c *lc = log->context;\n\tstruct {\n\t\tint64_t i;  \n\t\tregion_t r;\n\t} pkg;\n\n\tif (lc->in_sync_hint >= lc->region_count)\n\t\treturn 0;\n\n\trdata_size = sizeof(pkg);\n\tr = userspace_do_request(lc, lc->uuid, DM_ULOG_GET_RESYNC_WORK,\n\t\t\t\t NULL, 0, (char *)&pkg, &rdata_size);\n\n\t*region = pkg.r;\n\treturn (r) ? r : (int)pkg.i;\n}\n\n \nstatic void userspace_set_region_sync(struct dm_dirty_log *log,\n\t\t\t\t      region_t region, int in_sync)\n{\n\tstruct log_c *lc = log->context;\n\tstruct {\n\t\tregion_t r;\n\t\tint64_t i;\n\t} pkg;\n\n\tpkg.r = region;\n\tpkg.i = (int64_t)in_sync;\n\n\t(void) userspace_do_request(lc, lc->uuid, DM_ULOG_SET_REGION_SYNC,\n\t\t\t\t    (char *)&pkg, sizeof(pkg), NULL, NULL);\n\n\t \n}\n\n \nstatic region_t userspace_get_sync_count(struct dm_dirty_log *log)\n{\n\tint r;\n\tsize_t rdata_size;\n\tuint64_t sync_count;\n\tstruct log_c *lc = log->context;\n\n\trdata_size = sizeof(sync_count);\n\tr = userspace_do_request(lc, lc->uuid, DM_ULOG_GET_SYNC_COUNT,\n\t\t\t\t NULL, 0, (char *)&sync_count, &rdata_size);\n\n\tif (r)\n\t\treturn 0;\n\n\tif (sync_count >= lc->region_count)\n\t\tlc->in_sync_hint = lc->region_count;\n\n\treturn (region_t)sync_count;\n}\n\n \nstatic int userspace_status(struct dm_dirty_log *log, status_type_t status_type,\n\t\t\t    char *result, unsigned int maxlen)\n{\n\tint r = 0;\n\tchar *table_args;\n\tsize_t sz = (size_t)maxlen;\n\tstruct log_c *lc = log->context;\n\n\tswitch (status_type) {\n\tcase STATUSTYPE_INFO:\n\t\tr = userspace_do_request(lc, lc->uuid, DM_ULOG_STATUS_INFO,\n\t\t\t\t\t NULL, 0, result, &sz);\n\n\t\tif (r) {\n\t\t\tsz = 0;\n\t\t\tDMEMIT(\"%s 1 COM_FAILURE\", log->type->name);\n\t\t}\n\t\tbreak;\n\tcase STATUSTYPE_TABLE:\n\t\tsz = 0;\n\t\ttable_args = strchr(lc->usr_argv_str, ' ');\n\t\tBUG_ON(!table_args);  \n\t\ttable_args++;\n\n\t\tDMEMIT(\"%s %u %s \", log->type->name, lc->usr_argc, lc->uuid);\n\t\tif (lc->integrated_flush)\n\t\t\tDMEMIT(\"integrated_flush \");\n\t\tDMEMIT(\"%s \", table_args);\n\t\tbreak;\n\tcase STATUSTYPE_IMA:\n\t\t*result = '\\0';\n\t\tbreak;\n\t}\n\treturn (r) ? 0 : (int)sz;\n}\n\n \nstatic int userspace_is_remote_recovering(struct dm_dirty_log *log,\n\t\t\t\t\t  region_t region)\n{\n\tint r;\n\tuint64_t region64 = region;\n\tstruct log_c *lc = log->context;\n\tstatic unsigned long limit;\n\tstruct {\n\t\tint64_t is_recovering;\n\t\tuint64_t in_sync_hint;\n\t} pkg;\n\tsize_t rdata_size = sizeof(pkg);\n\n\t \n\tif (region < lc->in_sync_hint)\n\t\treturn 0;\n\telse if (time_after(limit, jiffies))\n\t\treturn 1;\n\n\tlimit = jiffies + (HZ / 4);\n\tr = userspace_do_request(lc, lc->uuid, DM_ULOG_IS_REMOTE_RECOVERING,\n\t\t\t\t (char *)&region64, sizeof(region64),\n\t\t\t\t (char *)&pkg, &rdata_size);\n\tif (r)\n\t\treturn 1;\n\n\tlc->in_sync_hint = pkg.in_sync_hint;\n\n\treturn (int)pkg.is_recovering;\n}\n\nstatic struct dm_dirty_log_type _userspace_type = {\n\t.name = \"userspace\",\n\t.module = THIS_MODULE,\n\t.ctr = userspace_ctr,\n\t.dtr = userspace_dtr,\n\t.presuspend = userspace_presuspend,\n\t.postsuspend = userspace_postsuspend,\n\t.resume = userspace_resume,\n\t.get_region_size = userspace_get_region_size,\n\t.is_clean = userspace_is_clean,\n\t.in_sync = userspace_in_sync,\n\t.flush = userspace_flush,\n\t.mark_region = userspace_mark_region,\n\t.clear_region = userspace_clear_region,\n\t.get_resync_work = userspace_get_resync_work,\n\t.set_region_sync = userspace_set_region_sync,\n\t.get_sync_count = userspace_get_sync_count,\n\t.status = userspace_status,\n\t.is_remote_recovering = userspace_is_remote_recovering,\n};\n\nstatic int __init userspace_dirty_log_init(void)\n{\n\tint r = 0;\n\n\t_flush_entry_cache = KMEM_CACHE(dm_dirty_log_flush_entry, 0);\n\tif (!_flush_entry_cache) {\n\t\tDMWARN(\"Unable to create flush_entry_cache: No memory.\");\n\t\treturn -ENOMEM;\n\t}\n\n\tr = dm_ulog_tfr_init();\n\tif (r) {\n\t\tDMWARN(\"Unable to initialize userspace log communications\");\n\t\tkmem_cache_destroy(_flush_entry_cache);\n\t\treturn r;\n\t}\n\n\tr = dm_dirty_log_type_register(&_userspace_type);\n\tif (r) {\n\t\tDMWARN(\"Couldn't register userspace dirty log type\");\n\t\tdm_ulog_tfr_exit();\n\t\tkmem_cache_destroy(_flush_entry_cache);\n\t\treturn r;\n\t}\n\n\tDMINFO(\"version \" DM_LOG_USERSPACE_VSN \" loaded\");\n\treturn 0;\n}\n\nstatic void __exit userspace_dirty_log_exit(void)\n{\n\tdm_dirty_log_type_unregister(&_userspace_type);\n\tdm_ulog_tfr_exit();\n\tkmem_cache_destroy(_flush_entry_cache);\n\n\tDMINFO(\"version \" DM_LOG_USERSPACE_VSN \" unloaded\");\n}\n\nmodule_init(userspace_dirty_log_init);\nmodule_exit(userspace_dirty_log_exit);\n\nMODULE_DESCRIPTION(DM_NAME \" userspace dirty log link\");\nMODULE_AUTHOR(\"Jonathan Brassow <dm-devel@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}