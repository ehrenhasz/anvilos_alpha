{
  "module_name": "dm-ps-historical-service-time.c",
  "hash_id": "81981453f6e02fdbdb4ee187b3e907a8de70a2a1c2fd0400198d3d3b8768f099",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-ps-historical-service-time.c",
  "human_readable_source": "\n \n\n#include \"dm.h\"\n#include \"dm-path-selector.h\"\n\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n\n#define DM_MSG_PREFIX\t\"multipath historical-service-time\"\n#define HST_MIN_IO 1\n#define HST_VERSION \"0.1.1\"\n\n#define HST_FIXED_SHIFT 10   \n#define HST_FIXED_MAX (ULLONG_MAX >> HST_FIXED_SHIFT)\n#define HST_FIXED_1 (1 << HST_FIXED_SHIFT)\n#define HST_FIXED_95 972\n#define HST_MAX_INFLIGHT HST_FIXED_1\n#define HST_BUCKET_SHIFT 24  \n#define HST_WEIGHT_COUNT 64ULL\n\nstruct selector {\n\tstruct list_head valid_paths;\n\tstruct list_head failed_paths;\n\tint valid_count;\n\tspinlock_t lock;\n\n\tunsigned int weights[HST_WEIGHT_COUNT];\n\tunsigned int threshold_multiplier;\n};\n\nstruct path_info {\n\tstruct list_head list;\n\tstruct dm_path *path;\n\tunsigned int repeat_count;\n\n\tspinlock_t lock;\n\n\tu64 historical_service_time;  \n\n\tu64 stale_after;\n\tu64 last_finish;\n\n\tu64 outstanding;\n};\n\n \nstatic u64 fixed_power(u64 x, unsigned int frac_bits, unsigned int n)\n{\n\tunsigned long result = 1UL << frac_bits;\n\n\tif (n) {\n\t\tfor (;;) {\n\t\t\tif (n & 1) {\n\t\t\t\tresult *= x;\n\t\t\t\tresult += 1UL << (frac_bits - 1);\n\t\t\t\tresult >>= frac_bits;\n\t\t\t}\n\t\t\tn >>= 1;\n\t\t\tif (!n)\n\t\t\t\tbreak;\n\t\t\tx *= x;\n\t\t\tx += 1UL << (frac_bits - 1);\n\t\t\tx >>= frac_bits;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n \nstatic u64 fixed_ema(u64 last, u64 next, u64 weight)\n{\n\tlast *= weight;\n\tlast += next * (HST_FIXED_1 - weight);\n\tlast += 1ULL << (HST_FIXED_SHIFT - 1);\n\treturn last >> HST_FIXED_SHIFT;\n}\n\nstatic struct selector *alloc_selector(void)\n{\n\tstruct selector *s = kmalloc(sizeof(*s), GFP_KERNEL);\n\n\tif (s) {\n\t\tINIT_LIST_HEAD(&s->valid_paths);\n\t\tINIT_LIST_HEAD(&s->failed_paths);\n\t\tspin_lock_init(&s->lock);\n\t\ts->valid_count = 0;\n\t}\n\n\treturn s;\n}\n\n \nstatic u64 hst_weight(struct path_selector *ps, u64 delta)\n{\n\tstruct selector *s = ps->context;\n\tint bucket = clamp(delta >> HST_BUCKET_SHIFT, 0ULL,\n\t\t\t   HST_WEIGHT_COUNT - 1);\n\n\treturn s->weights[bucket];\n}\n\n \nstatic void hst_set_weights(struct path_selector *ps, unsigned int base)\n{\n\tstruct selector *s = ps->context;\n\tint i;\n\n\tif (base >= HST_FIXED_1)\n\t\treturn;\n\n\tfor (i = 0; i < HST_WEIGHT_COUNT - 1; i++)\n\t\ts->weights[i] = fixed_power(base, HST_FIXED_SHIFT, i + 1);\n\ts->weights[HST_WEIGHT_COUNT - 1] = 0;\n}\n\nstatic int hst_create(struct path_selector *ps, unsigned int argc, char **argv)\n{\n\tstruct selector *s;\n\tunsigned int base_weight = HST_FIXED_95;\n\tunsigned int threshold_multiplier = 0;\n\tchar dummy;\n\n\t \n\tif (argc > 2)\n\t\treturn -EINVAL;\n\n\tif (argc && (sscanf(argv[0], \"%u%c\", &base_weight, &dummy) != 1 ||\n\t     base_weight >= HST_FIXED_1)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (argc > 1 && (sscanf(argv[1], \"%u%c\",\n\t\t\t\t&threshold_multiplier, &dummy) != 1)) {\n\t\treturn -EINVAL;\n\t}\n\n\ts = alloc_selector();\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tps->context = s;\n\n\thst_set_weights(ps, base_weight);\n\ts->threshold_multiplier = threshold_multiplier;\n\treturn 0;\n}\n\nstatic void free_paths(struct list_head *paths)\n{\n\tstruct path_info *pi, *next;\n\n\tlist_for_each_entry_safe(pi, next, paths, list) {\n\t\tlist_del(&pi->list);\n\t\tkfree(pi);\n\t}\n}\n\nstatic void hst_destroy(struct path_selector *ps)\n{\n\tstruct selector *s = ps->context;\n\n\tfree_paths(&s->valid_paths);\n\tfree_paths(&s->failed_paths);\n\tkfree(s);\n\tps->context = NULL;\n}\n\nstatic int hst_status(struct path_selector *ps, struct dm_path *path,\n\t\t     status_type_t type, char *result, unsigned int maxlen)\n{\n\tunsigned int sz = 0;\n\tstruct path_info *pi;\n\n\tif (!path) {\n\t\tstruct selector *s = ps->context;\n\n\t\tDMEMIT(\"2 %u %u \", s->weights[0], s->threshold_multiplier);\n\t} else {\n\t\tpi = path->pscontext;\n\n\t\tswitch (type) {\n\t\tcase STATUSTYPE_INFO:\n\t\t\tDMEMIT(\"%llu %llu %llu \", pi->historical_service_time,\n\t\t\t       pi->outstanding, pi->stale_after);\n\t\t\tbreak;\n\t\tcase STATUSTYPE_TABLE:\n\t\t\tDMEMIT(\"0 \");\n\t\t\tbreak;\n\t\tcase STATUSTYPE_IMA:\n\t\t\t*result = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sz;\n}\n\nstatic int hst_add_path(struct path_selector *ps, struct dm_path *path,\n\t\t       int argc, char **argv, char **error)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi;\n\tunsigned int repeat_count = HST_MIN_IO;\n\tchar dummy;\n\tunsigned long flags;\n\n\t \n\tif (argc > 1) {\n\t\t*error = \"historical-service-time ps: incorrect number of arguments\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (argc && (sscanf(argv[0], \"%u%c\", &repeat_count, &dummy) != 1)) {\n\t\t*error = \"historical-service-time ps: invalid repeat count\";\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpi = kmalloc(sizeof(*pi), GFP_KERNEL);\n\tif (!pi) {\n\t\t*error = \"historical-service-time ps: Error allocating path context\";\n\t\treturn -ENOMEM;\n\t}\n\n\tpi->path = path;\n\tpi->repeat_count = repeat_count;\n\n\tpi->historical_service_time = HST_FIXED_1;\n\n\tspin_lock_init(&pi->lock);\n\tpi->outstanding = 0;\n\n\tpi->stale_after = 0;\n\tpi->last_finish = 0;\n\n\tpath->pscontext = pi;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tlist_add_tail(&pi->list, &s->valid_paths);\n\ts->valid_count++;\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn 0;\n}\n\nstatic void hst_fail_path(struct path_selector *ps, struct dm_path *path)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = path->pscontext;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tlist_move(&pi->list, &s->failed_paths);\n\ts->valid_count--;\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nstatic int hst_reinstate_path(struct path_selector *ps, struct dm_path *path)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = path->pscontext;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tlist_move_tail(&pi->list, &s->valid_paths);\n\ts->valid_count++;\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn 0;\n}\n\nstatic void hst_fill_compare(struct path_info *pi, u64 *hst,\n\t\t\t     u64 *out, u64 *stale)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pi->lock, flags);\n\t*hst = pi->historical_service_time;\n\t*out = pi->outstanding;\n\t*stale = pi->stale_after;\n\tspin_unlock_irqrestore(&pi->lock, flags);\n}\n\n \nstatic long long hst_compare(struct path_info *pi1, struct path_info *pi2,\n\t\t\t     u64 time_now, struct path_selector *ps)\n{\n\tstruct selector *s = ps->context;\n\tu64 hst1, hst2;\n\tlong long out1, out2, stale1, stale2;\n\tint pi2_better, over_threshold;\n\n\thst_fill_compare(pi1, &hst1, &out1, &stale1);\n\thst_fill_compare(pi2, &hst2, &out2, &stale2);\n\n\t \n\tif (hst1 > hst2)\n\t\tover_threshold = hst1 > (s->threshold_multiplier * hst2);\n\telse\n\t\tover_threshold = hst2 > (s->threshold_multiplier * hst1);\n\n\tif (!over_threshold)\n\t\treturn out1 - out2;\n\n\t \n\tif ((!out1 && stale1 < time_now) || (!out2 && stale2 < time_now) ||\n\t    (!out1 && !out2))\n\t\treturn (!out2 * stale1) - (!out1 * stale2);\n\n\t \n\tif (out1 == out2) {\n\t\tpi2_better = hst1 > hst2;\n\t} else {\n\t\t \n\t\tif (unlikely(out1 >= HST_MAX_INFLIGHT ||\n\t\t\t     out2 >= HST_MAX_INFLIGHT)) {\n\t\t\t \n\t\t\thst1 >>= HST_FIXED_SHIFT;\n\t\t\thst2 >>= HST_FIXED_SHIFT;\n\t\t}\n\t\tpi2_better = (1 + out1) * hst1 > (1 + out2) * hst2;\n\t}\n\n\t \n\tif (pi2_better) {\n\t\tif (stale2 < time_now)\n\t\t\treturn out1 - out2;\n\t\treturn 1;\n\t}\n\tif (stale1 < time_now)\n\t\treturn out1 - out2;\n\treturn -1;\n}\n\nstatic struct dm_path *hst_select_path(struct path_selector *ps,\n\t\t\t\t       size_t nr_bytes)\n{\n\tstruct selector *s = ps->context;\n\tstruct path_info *pi = NULL, *best = NULL;\n\tu64 time_now = ktime_get_ns();\n\tstruct dm_path *ret = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tif (list_empty(&s->valid_paths))\n\t\tgoto out;\n\n\tlist_for_each_entry(pi, &s->valid_paths, list) {\n\t\tif (!best || (hst_compare(pi, best, time_now, ps) < 0))\n\t\t\tbest = pi;\n\t}\n\n\tif (!best)\n\t\tgoto out;\n\n\t \n\tlist_move_tail(&best->list, &s->valid_paths);\n\n\tret = best->path;\n\nout:\n\tspin_unlock_irqrestore(&s->lock, flags);\n\treturn ret;\n}\n\nstatic int hst_start_io(struct path_selector *ps, struct dm_path *path,\n\t\t\tsize_t nr_bytes)\n{\n\tstruct path_info *pi = path->pscontext;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pi->lock, flags);\n\tpi->outstanding++;\n\tspin_unlock_irqrestore(&pi->lock, flags);\n\n\treturn 0;\n}\n\nstatic u64 path_service_time(struct path_info *pi, u64 start_time)\n{\n\tu64 now = ktime_get_ns();\n\n\t \n\tif (time_after64(pi->last_finish, start_time))\n\t\tstart_time = pi->last_finish;\n\n\tpi->last_finish = now;\n\tif (time_before64(now, start_time))\n\t\treturn 0;\n\n\treturn now - start_time;\n}\n\nstatic int hst_end_io(struct path_selector *ps, struct dm_path *path,\n\t\t      size_t nr_bytes, u64 start_time)\n{\n\tstruct path_info *pi = path->pscontext;\n\tstruct selector *s = ps->context;\n\tunsigned long flags;\n\tu64 st;\n\n\tspin_lock_irqsave(&pi->lock, flags);\n\n\tst = path_service_time(pi, start_time);\n\tpi->outstanding--;\n\tpi->historical_service_time =\n\t\tfixed_ema(pi->historical_service_time,\n\t\t\t  min(st * HST_FIXED_1, HST_FIXED_MAX),\n\t\t\t  hst_weight(ps, st));\n\n\t \n\tpi->stale_after = pi->last_finish +\n\t\t(s->valid_count * (pi->historical_service_time >> HST_FIXED_SHIFT));\n\n\tspin_unlock_irqrestore(&pi->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct path_selector_type hst_ps = {\n\t.name\t\t= \"historical-service-time\",\n\t.module\t\t= THIS_MODULE,\n\t.features\t= DM_PS_USE_HR_TIMER,\n\t.table_args\t= 1,\n\t.info_args\t= 3,\n\t.create\t\t= hst_create,\n\t.destroy\t= hst_destroy,\n\t.status\t\t= hst_status,\n\t.add_path\t= hst_add_path,\n\t.fail_path\t= hst_fail_path,\n\t.reinstate_path\t= hst_reinstate_path,\n\t.select_path\t= hst_select_path,\n\t.start_io\t= hst_start_io,\n\t.end_io\t\t= hst_end_io,\n};\n\nstatic int __init dm_hst_init(void)\n{\n\tint r = dm_register_path_selector(&hst_ps);\n\n\tif (r < 0)\n\t\tDMERR(\"register failed %d\", r);\n\n\tDMINFO(\"version \" HST_VERSION \" loaded\");\n\n\treturn r;\n}\n\nstatic void __exit dm_hst_exit(void)\n{\n\tint r = dm_unregister_path_selector(&hst_ps);\n\n\tif (r < 0)\n\t\tDMERR(\"unregister failed %d\", r);\n}\n\nmodule_init(dm_hst_init);\nmodule_exit(dm_hst_exit);\n\nMODULE_DESCRIPTION(DM_NAME \" measured service time oriented path selector\");\nMODULE_AUTHOR(\"Khazhismel Kumykov <khazhy@google.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}