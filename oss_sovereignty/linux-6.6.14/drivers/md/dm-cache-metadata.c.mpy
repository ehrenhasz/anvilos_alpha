{
  "module_name": "dm-cache-metadata.c",
  "hash_id": "c15290391bb2c5f07d21a4405ddc6c19972a7346720cfb9053db3ba07c8b8c94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-cache-metadata.c",
  "human_readable_source": "\n \n\n#include \"dm-cache-metadata.h\"\n\n#include \"persistent-data/dm-array.h\"\n#include \"persistent-data/dm-bitset.h\"\n#include \"persistent-data/dm-space-map.h\"\n#include \"persistent-data/dm-space-map-disk.h\"\n#include \"persistent-data/dm-transaction-manager.h\"\n\n#include <linux/device-mapper.h>\n#include <linux/refcount.h>\n\n \n\n#define DM_MSG_PREFIX   \"cache metadata\"\n\n#define CACHE_SUPERBLOCK_MAGIC 06142003\n#define CACHE_SUPERBLOCK_LOCATION 0\n\n \n#define MIN_CACHE_VERSION 1\n#define MAX_CACHE_VERSION 2\n\n \n#define CACHE_MAX_CONCURRENT_LOCKS 5\n#define SPACE_MAP_ROOT_SIZE 128\n\nenum superblock_flag_bits {\n\t \n\tCLEAN_SHUTDOWN,\n\t \n\tNEEDS_CHECK,\n};\n\n \nenum mapping_bits {\n\t \n\tM_VALID = 1,\n\n\t \n\tM_DIRTY = 2\n};\n\nstruct cache_disk_superblock {\n\t__le32 csum;\n\t__le32 flags;\n\t__le64 blocknr;\n\n\t__u8 uuid[16];\n\t__le64 magic;\n\t__le32 version;\n\n\t__u8 policy_name[CACHE_POLICY_NAME_SIZE];\n\t__le32 policy_hint_size;\n\n\t__u8 metadata_space_map_root[SPACE_MAP_ROOT_SIZE];\n\t__le64 mapping_root;\n\t__le64 hint_root;\n\n\t__le64 discard_root;\n\t__le64 discard_block_size;\n\t__le64 discard_nr_blocks;\n\n\t__le32 data_block_size;\n\t__le32 metadata_block_size;\n\t__le32 cache_blocks;\n\n\t__le32 compat_flags;\n\t__le32 compat_ro_flags;\n\t__le32 incompat_flags;\n\n\t__le32 read_hits;\n\t__le32 read_misses;\n\t__le32 write_hits;\n\t__le32 write_misses;\n\n\t__le32 policy_version[CACHE_POLICY_VERSION_SIZE];\n\n\t \n\t__le64 dirty_root;\n} __packed;\n\nstruct dm_cache_metadata {\n\trefcount_t ref_count;\n\tstruct list_head list;\n\n\tunsigned int version;\n\tstruct block_device *bdev;\n\tstruct dm_block_manager *bm;\n\tstruct dm_space_map *metadata_sm;\n\tstruct dm_transaction_manager *tm;\n\n\tstruct dm_array_info info;\n\tstruct dm_array_info hint_info;\n\tstruct dm_disk_bitset discard_info;\n\n\tstruct rw_semaphore root_lock;\n\tunsigned long flags;\n\tdm_block_t root;\n\tdm_block_t hint_root;\n\tdm_block_t discard_root;\n\n\tsector_t discard_block_size;\n\tdm_dblock_t discard_nr_blocks;\n\n\tsector_t data_block_size;\n\tdm_cblock_t cache_blocks;\n\tbool changed:1;\n\tbool clean_when_opened:1;\n\n\tchar policy_name[CACHE_POLICY_NAME_SIZE];\n\tunsigned int policy_version[CACHE_POLICY_VERSION_SIZE];\n\tsize_t policy_hint_size;\n\tstruct dm_cache_statistics stats;\n\n\t \n\t__u8 metadata_space_map_root[SPACE_MAP_ROOT_SIZE];\n\n\t \n\tbool fail_io:1;\n\n\t \n\tdm_block_t dirty_root;\n\tstruct dm_disk_bitset dirty_info;\n\n\t \n\tstruct dm_array_cursor mapping_cursor;\n\tstruct dm_array_cursor hint_cursor;\n\tstruct dm_bitset_cursor dirty_cursor;\n};\n\n \n#define SUPERBLOCK_CSUM_XOR 9031977\n\nstatic void sb_prepare_for_write(struct dm_block_validator *v,\n\t\t\t\t struct dm_block *b,\n\t\t\t\t size_t sb_block_size)\n{\n\tstruct cache_disk_superblock *disk_super = dm_block_data(b);\n\n\tdisk_super->blocknr = cpu_to_le64(dm_block_location(b));\n\tdisk_super->csum = cpu_to_le32(dm_bm_checksum(&disk_super->flags,\n\t\t\t\t\t\t      sb_block_size - sizeof(__le32),\n\t\t\t\t\t\t      SUPERBLOCK_CSUM_XOR));\n}\n\nstatic int check_metadata_version(struct cache_disk_superblock *disk_super)\n{\n\tuint32_t metadata_version = le32_to_cpu(disk_super->version);\n\n\tif (metadata_version < MIN_CACHE_VERSION || metadata_version > MAX_CACHE_VERSION) {\n\t\tDMERR(\"Cache metadata version %u found, but only versions between %u and %u supported.\",\n\t\t      metadata_version, MIN_CACHE_VERSION, MAX_CACHE_VERSION);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sb_check(struct dm_block_validator *v,\n\t\t    struct dm_block *b,\n\t\t    size_t sb_block_size)\n{\n\tstruct cache_disk_superblock *disk_super = dm_block_data(b);\n\t__le32 csum_le;\n\n\tif (dm_block_location(b) != le64_to_cpu(disk_super->blocknr)) {\n\t\tDMERR(\"%s failed: blocknr %llu: wanted %llu\",\n\t\t      __func__, le64_to_cpu(disk_super->blocknr),\n\t\t      (unsigned long long)dm_block_location(b));\n\t\treturn -ENOTBLK;\n\t}\n\n\tif (le64_to_cpu(disk_super->magic) != CACHE_SUPERBLOCK_MAGIC) {\n\t\tDMERR(\"%s failed: magic %llu: wanted %llu\",\n\t\t      __func__, le64_to_cpu(disk_super->magic),\n\t\t      (unsigned long long)CACHE_SUPERBLOCK_MAGIC);\n\t\treturn -EILSEQ;\n\t}\n\n\tcsum_le = cpu_to_le32(dm_bm_checksum(&disk_super->flags,\n\t\t\t\t\t     sb_block_size - sizeof(__le32),\n\t\t\t\t\t     SUPERBLOCK_CSUM_XOR));\n\tif (csum_le != disk_super->csum) {\n\t\tDMERR(\"%s failed: csum %u: wanted %u\",\n\t\t      __func__, le32_to_cpu(csum_le), le32_to_cpu(disk_super->csum));\n\t\treturn -EILSEQ;\n\t}\n\n\treturn check_metadata_version(disk_super);\n}\n\nstatic struct dm_block_validator sb_validator = {\n\t.name = \"superblock\",\n\t.prepare_for_write = sb_prepare_for_write,\n\t.check = sb_check\n};\n\n \n\nstatic int superblock_read_lock(struct dm_cache_metadata *cmd,\n\t\t\t\tstruct dm_block **sblock)\n{\n\treturn dm_bm_read_lock(cmd->bm, CACHE_SUPERBLOCK_LOCATION,\n\t\t\t       &sb_validator, sblock);\n}\n\nstatic int superblock_lock_zero(struct dm_cache_metadata *cmd,\n\t\t\t\tstruct dm_block **sblock)\n{\n\treturn dm_bm_write_lock_zero(cmd->bm, CACHE_SUPERBLOCK_LOCATION,\n\t\t\t\t     &sb_validator, sblock);\n}\n\nstatic int superblock_lock(struct dm_cache_metadata *cmd,\n\t\t\t   struct dm_block **sblock)\n{\n\treturn dm_bm_write_lock(cmd->bm, CACHE_SUPERBLOCK_LOCATION,\n\t\t\t\t&sb_validator, sblock);\n}\n\n \n\nstatic int __superblock_all_zeroes(struct dm_block_manager *bm, bool *result)\n{\n\tint r;\n\tunsigned int i;\n\tstruct dm_block *b;\n\t__le64 *data_le, zero = cpu_to_le64(0);\n\tunsigned int sb_block_size = dm_bm_block_size(bm) / sizeof(__le64);\n\n\t \n\tr = dm_bm_read_lock(bm, CACHE_SUPERBLOCK_LOCATION, NULL, &b);\n\tif (r)\n\t\treturn r;\n\n\tdata_le = dm_block_data(b);\n\t*result = true;\n\tfor (i = 0; i < sb_block_size; i++) {\n\t\tif (data_le[i] != zero) {\n\t\t\t*result = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdm_bm_unlock(b);\n\n\treturn 0;\n}\n\nstatic void __setup_mapping_info(struct dm_cache_metadata *cmd)\n{\n\tstruct dm_btree_value_type vt;\n\n\tvt.context = NULL;\n\tvt.size = sizeof(__le64);\n\tvt.inc = NULL;\n\tvt.dec = NULL;\n\tvt.equal = NULL;\n\tdm_array_info_init(&cmd->info, cmd->tm, &vt);\n\n\tif (cmd->policy_hint_size) {\n\t\tvt.size = sizeof(__le32);\n\t\tdm_array_info_init(&cmd->hint_info, cmd->tm, &vt);\n\t}\n}\n\nstatic int __save_sm_root(struct dm_cache_metadata *cmd)\n{\n\tint r;\n\tsize_t metadata_len;\n\n\tr = dm_sm_root_size(cmd->metadata_sm, &metadata_len);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn dm_sm_copy_root(cmd->metadata_sm, &cmd->metadata_space_map_root,\n\t\t\t       metadata_len);\n}\n\nstatic void __copy_sm_root(struct dm_cache_metadata *cmd,\n\t\t\t   struct cache_disk_superblock *disk_super)\n{\n\tmemcpy(&disk_super->metadata_space_map_root,\n\t       &cmd->metadata_space_map_root,\n\t       sizeof(cmd->metadata_space_map_root));\n}\n\nstatic bool separate_dirty_bits(struct dm_cache_metadata *cmd)\n{\n\treturn cmd->version >= 2;\n}\n\nstatic int __write_initial_superblock(struct dm_cache_metadata *cmd)\n{\n\tint r;\n\tstruct dm_block *sblock;\n\tstruct cache_disk_superblock *disk_super;\n\tsector_t bdev_size = bdev_nr_sectors(cmd->bdev);\n\n\t \n\tif (bdev_size > DM_CACHE_METADATA_MAX_SECTORS)\n\t\tbdev_size = DM_CACHE_METADATA_MAX_SECTORS;\n\n\tr = dm_tm_pre_commit(cmd->tm);\n\tif (r < 0)\n\t\treturn r;\n\n\t \n\tr = __save_sm_root(cmd);\n\tif (r)\n\t\treturn r;\n\n\tr = superblock_lock_zero(cmd, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n\tdisk_super->flags = 0;\n\tmemset(disk_super->uuid, 0, sizeof(disk_super->uuid));\n\tdisk_super->magic = cpu_to_le64(CACHE_SUPERBLOCK_MAGIC);\n\tdisk_super->version = cpu_to_le32(cmd->version);\n\tmemset(disk_super->policy_name, 0, sizeof(disk_super->policy_name));\n\tmemset(disk_super->policy_version, 0, sizeof(disk_super->policy_version));\n\tdisk_super->policy_hint_size = cpu_to_le32(0);\n\n\t__copy_sm_root(cmd, disk_super);\n\n\tdisk_super->mapping_root = cpu_to_le64(cmd->root);\n\tdisk_super->hint_root = cpu_to_le64(cmd->hint_root);\n\tdisk_super->discard_root = cpu_to_le64(cmd->discard_root);\n\tdisk_super->discard_block_size = cpu_to_le64(cmd->discard_block_size);\n\tdisk_super->discard_nr_blocks = cpu_to_le64(from_dblock(cmd->discard_nr_blocks));\n\tdisk_super->metadata_block_size = cpu_to_le32(DM_CACHE_METADATA_BLOCK_SIZE);\n\tdisk_super->data_block_size = cpu_to_le32(cmd->data_block_size);\n\tdisk_super->cache_blocks = cpu_to_le32(0);\n\n\tdisk_super->read_hits = cpu_to_le32(0);\n\tdisk_super->read_misses = cpu_to_le32(0);\n\tdisk_super->write_hits = cpu_to_le32(0);\n\tdisk_super->write_misses = cpu_to_le32(0);\n\n\tif (separate_dirty_bits(cmd))\n\t\tdisk_super->dirty_root = cpu_to_le64(cmd->dirty_root);\n\n\treturn dm_tm_commit(cmd->tm, sblock);\n}\n\nstatic int __format_metadata(struct dm_cache_metadata *cmd)\n{\n\tint r;\n\n\tr = dm_tm_create_with_sm(cmd->bm, CACHE_SUPERBLOCK_LOCATION,\n\t\t\t\t &cmd->tm, &cmd->metadata_sm);\n\tif (r < 0) {\n\t\tDMERR(\"tm_create_with_sm failed\");\n\t\treturn r;\n\t}\n\n\t__setup_mapping_info(cmd);\n\n\tr = dm_array_empty(&cmd->info, &cmd->root);\n\tif (r < 0)\n\t\tgoto bad;\n\n\tif (separate_dirty_bits(cmd)) {\n\t\tdm_disk_bitset_init(cmd->tm, &cmd->dirty_info);\n\t\tr = dm_bitset_empty(&cmd->dirty_info, &cmd->dirty_root);\n\t\tif (r < 0)\n\t\t\tgoto bad;\n\t}\n\n\tdm_disk_bitset_init(cmd->tm, &cmd->discard_info);\n\tr = dm_bitset_empty(&cmd->discard_info, &cmd->discard_root);\n\tif (r < 0)\n\t\tgoto bad;\n\n\tcmd->discard_block_size = 0;\n\tcmd->discard_nr_blocks = 0;\n\n\tr = __write_initial_superblock(cmd);\n\tif (r)\n\t\tgoto bad;\n\n\tcmd->clean_when_opened = true;\n\treturn 0;\n\nbad:\n\tdm_tm_destroy(cmd->tm);\n\tdm_sm_destroy(cmd->metadata_sm);\n\n\treturn r;\n}\n\nstatic int __check_incompat_features(struct cache_disk_superblock *disk_super,\n\t\t\t\t     struct dm_cache_metadata *cmd)\n{\n\tuint32_t incompat_flags, features;\n\n\tincompat_flags = le32_to_cpu(disk_super->incompat_flags);\n\tfeatures = incompat_flags & ~DM_CACHE_FEATURE_INCOMPAT_SUPP;\n\tif (features) {\n\t\tDMERR(\"could not access metadata due to unsupported optional features (%lx).\",\n\t\t      (unsigned long)features);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (bdev_read_only(cmd->bdev))\n\t\treturn 0;\n\n\tfeatures = le32_to_cpu(disk_super->compat_ro_flags) & ~DM_CACHE_FEATURE_COMPAT_RO_SUPP;\n\tif (features) {\n\t\tDMERR(\"could not access metadata RDWR due to unsupported optional features (%lx).\",\n\t\t      (unsigned long)features);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __open_metadata(struct dm_cache_metadata *cmd)\n{\n\tint r;\n\tstruct dm_block *sblock;\n\tstruct cache_disk_superblock *disk_super;\n\tunsigned long sb_flags;\n\n\tr = superblock_read_lock(cmd, &sblock);\n\tif (r < 0) {\n\t\tDMERR(\"couldn't read lock superblock\");\n\t\treturn r;\n\t}\n\n\tdisk_super = dm_block_data(sblock);\n\n\t \n\tif (le32_to_cpu(disk_super->data_block_size) != cmd->data_block_size) {\n\t\tDMERR(\"changing the data block size (from %u to %llu) is not supported\",\n\t\t      le32_to_cpu(disk_super->data_block_size),\n\t\t      (unsigned long long)cmd->data_block_size);\n\t\tr = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\tr = __check_incompat_features(disk_super, cmd);\n\tif (r < 0)\n\t\tgoto bad;\n\n\tr = dm_tm_open_with_sm(cmd->bm, CACHE_SUPERBLOCK_LOCATION,\n\t\t\t       disk_super->metadata_space_map_root,\n\t\t\t       sizeof(disk_super->metadata_space_map_root),\n\t\t\t       &cmd->tm, &cmd->metadata_sm);\n\tif (r < 0) {\n\t\tDMERR(\"tm_open_with_sm failed\");\n\t\tgoto bad;\n\t}\n\n\t__setup_mapping_info(cmd);\n\tdm_disk_bitset_init(cmd->tm, &cmd->dirty_info);\n\tdm_disk_bitset_init(cmd->tm, &cmd->discard_info);\n\tsb_flags = le32_to_cpu(disk_super->flags);\n\tcmd->clean_when_opened = test_bit(CLEAN_SHUTDOWN, &sb_flags);\n\tdm_bm_unlock(sblock);\n\n\treturn 0;\n\nbad:\n\tdm_bm_unlock(sblock);\n\treturn r;\n}\n\nstatic int __open_or_format_metadata(struct dm_cache_metadata *cmd,\n\t\t\t\t     bool format_device)\n{\n\tint r;\n\tbool unformatted = false;\n\n\tr = __superblock_all_zeroes(cmd->bm, &unformatted);\n\tif (r)\n\t\treturn r;\n\n\tif (unformatted)\n\t\treturn format_device ? __format_metadata(cmd) : -EPERM;\n\n\treturn __open_metadata(cmd);\n}\n\nstatic int __create_persistent_data_objects(struct dm_cache_metadata *cmd,\n\t\t\t\t\t    bool may_format_device)\n{\n\tint r;\n\n\tcmd->bm = dm_block_manager_create(cmd->bdev, DM_CACHE_METADATA_BLOCK_SIZE << SECTOR_SHIFT,\n\t\t\t\t\t  CACHE_MAX_CONCURRENT_LOCKS);\n\tif (IS_ERR(cmd->bm)) {\n\t\tDMERR(\"could not create block manager\");\n\t\tr = PTR_ERR(cmd->bm);\n\t\tcmd->bm = NULL;\n\t\treturn r;\n\t}\n\n\tr = __open_or_format_metadata(cmd, may_format_device);\n\tif (r) {\n\t\tdm_block_manager_destroy(cmd->bm);\n\t\tcmd->bm = NULL;\n\t}\n\n\treturn r;\n}\n\nstatic void __destroy_persistent_data_objects(struct dm_cache_metadata *cmd,\n\t\t\t\t\t      bool destroy_bm)\n{\n\tdm_sm_destroy(cmd->metadata_sm);\n\tdm_tm_destroy(cmd->tm);\n\tif (destroy_bm)\n\t\tdm_block_manager_destroy(cmd->bm);\n}\n\ntypedef unsigned long (*flags_mutator)(unsigned long);\n\nstatic void update_flags(struct cache_disk_superblock *disk_super,\n\t\t\t flags_mutator mutator)\n{\n\tuint32_t sb_flags = mutator(le32_to_cpu(disk_super->flags));\n\n\tdisk_super->flags = cpu_to_le32(sb_flags);\n}\n\nstatic unsigned long set_clean_shutdown(unsigned long flags)\n{\n\tset_bit(CLEAN_SHUTDOWN, &flags);\n\treturn flags;\n}\n\nstatic unsigned long clear_clean_shutdown(unsigned long flags)\n{\n\tclear_bit(CLEAN_SHUTDOWN, &flags);\n\treturn flags;\n}\n\nstatic void read_superblock_fields(struct dm_cache_metadata *cmd,\n\t\t\t\t   struct cache_disk_superblock *disk_super)\n{\n\tcmd->version = le32_to_cpu(disk_super->version);\n\tcmd->flags = le32_to_cpu(disk_super->flags);\n\tcmd->root = le64_to_cpu(disk_super->mapping_root);\n\tcmd->hint_root = le64_to_cpu(disk_super->hint_root);\n\tcmd->discard_root = le64_to_cpu(disk_super->discard_root);\n\tcmd->discard_block_size = le64_to_cpu(disk_super->discard_block_size);\n\tcmd->discard_nr_blocks = to_dblock(le64_to_cpu(disk_super->discard_nr_blocks));\n\tcmd->data_block_size = le32_to_cpu(disk_super->data_block_size);\n\tcmd->cache_blocks = to_cblock(le32_to_cpu(disk_super->cache_blocks));\n\tstrncpy(cmd->policy_name, disk_super->policy_name, sizeof(cmd->policy_name));\n\tcmd->policy_version[0] = le32_to_cpu(disk_super->policy_version[0]);\n\tcmd->policy_version[1] = le32_to_cpu(disk_super->policy_version[1]);\n\tcmd->policy_version[2] = le32_to_cpu(disk_super->policy_version[2]);\n\tcmd->policy_hint_size = le32_to_cpu(disk_super->policy_hint_size);\n\n\tcmd->stats.read_hits = le32_to_cpu(disk_super->read_hits);\n\tcmd->stats.read_misses = le32_to_cpu(disk_super->read_misses);\n\tcmd->stats.write_hits = le32_to_cpu(disk_super->write_hits);\n\tcmd->stats.write_misses = le32_to_cpu(disk_super->write_misses);\n\n\tif (separate_dirty_bits(cmd))\n\t\tcmd->dirty_root = le64_to_cpu(disk_super->dirty_root);\n\n\tcmd->changed = false;\n}\n\n \nstatic int __begin_transaction_flags(struct dm_cache_metadata *cmd,\n\t\t\t\t     flags_mutator mutator)\n{\n\tint r;\n\tstruct cache_disk_superblock *disk_super;\n\tstruct dm_block *sblock;\n\n\tr = superblock_lock(cmd, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n\tupdate_flags(disk_super, mutator);\n\tread_superblock_fields(cmd, disk_super);\n\tdm_bm_unlock(sblock);\n\n\treturn dm_bm_flush(cmd->bm);\n}\n\nstatic int __begin_transaction(struct dm_cache_metadata *cmd)\n{\n\tint r;\n\tstruct cache_disk_superblock *disk_super;\n\tstruct dm_block *sblock;\n\n\t \n\tr = superblock_read_lock(cmd, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n\tread_superblock_fields(cmd, disk_super);\n\tdm_bm_unlock(sblock);\n\n\treturn 0;\n}\n\nstatic int __commit_transaction(struct dm_cache_metadata *cmd,\n\t\t\t\tflags_mutator mutator)\n{\n\tint r;\n\tstruct cache_disk_superblock *disk_super;\n\tstruct dm_block *sblock;\n\n\t \n\tBUILD_BUG_ON(sizeof(struct cache_disk_superblock) > 512);\n\n\tif (separate_dirty_bits(cmd)) {\n\t\tr = dm_bitset_flush(&cmd->dirty_info, cmd->dirty_root,\n\t\t\t\t    &cmd->dirty_root);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = dm_bitset_flush(&cmd->discard_info, cmd->discard_root,\n\t\t\t    &cmd->discard_root);\n\tif (r)\n\t\treturn r;\n\n\tr = dm_tm_pre_commit(cmd->tm);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = __save_sm_root(cmd);\n\tif (r)\n\t\treturn r;\n\n\tr = superblock_lock(cmd, &sblock);\n\tif (r)\n\t\treturn r;\n\n\tdisk_super = dm_block_data(sblock);\n\n\tdisk_super->flags = cpu_to_le32(cmd->flags);\n\tif (mutator)\n\t\tupdate_flags(disk_super, mutator);\n\n\tdisk_super->mapping_root = cpu_to_le64(cmd->root);\n\tif (separate_dirty_bits(cmd))\n\t\tdisk_super->dirty_root = cpu_to_le64(cmd->dirty_root);\n\tdisk_super->hint_root = cpu_to_le64(cmd->hint_root);\n\tdisk_super->discard_root = cpu_to_le64(cmd->discard_root);\n\tdisk_super->discard_block_size = cpu_to_le64(cmd->discard_block_size);\n\tdisk_super->discard_nr_blocks = cpu_to_le64(from_dblock(cmd->discard_nr_blocks));\n\tdisk_super->cache_blocks = cpu_to_le32(from_cblock(cmd->cache_blocks));\n\tstrncpy(disk_super->policy_name, cmd->policy_name, sizeof(disk_super->policy_name));\n\tdisk_super->policy_version[0] = cpu_to_le32(cmd->policy_version[0]);\n\tdisk_super->policy_version[1] = cpu_to_le32(cmd->policy_version[1]);\n\tdisk_super->policy_version[2] = cpu_to_le32(cmd->policy_version[2]);\n\tdisk_super->policy_hint_size = cpu_to_le32(cmd->policy_hint_size);\n\n\tdisk_super->read_hits = cpu_to_le32(cmd->stats.read_hits);\n\tdisk_super->read_misses = cpu_to_le32(cmd->stats.read_misses);\n\tdisk_super->write_hits = cpu_to_le32(cmd->stats.write_hits);\n\tdisk_super->write_misses = cpu_to_le32(cmd->stats.write_misses);\n\t__copy_sm_root(cmd, disk_super);\n\n\treturn dm_tm_commit(cmd->tm, sblock);\n}\n\n \n\n \n#define FLAGS_MASK ((1 << 16) - 1)\n\nstatic __le64 pack_value(dm_oblock_t block, unsigned int flags)\n{\n\tuint64_t value = from_oblock(block);\n\n\tvalue <<= 16;\n\tvalue = value | (flags & FLAGS_MASK);\n\treturn cpu_to_le64(value);\n}\n\nstatic void unpack_value(__le64 value_le, dm_oblock_t *block, unsigned int *flags)\n{\n\tuint64_t value = le64_to_cpu(value_le);\n\tuint64_t b = value >> 16;\n\n\t*block = to_oblock(b);\n\t*flags = value & FLAGS_MASK;\n}\n\n \n\nstatic struct dm_cache_metadata *metadata_open(struct block_device *bdev,\n\t\t\t\t\t       sector_t data_block_size,\n\t\t\t\t\t       bool may_format_device,\n\t\t\t\t\t       size_t policy_hint_size,\n\t\t\t\t\t       unsigned int metadata_version)\n{\n\tint r;\n\tstruct dm_cache_metadata *cmd;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tDMERR(\"could not allocate metadata struct\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tcmd->version = metadata_version;\n\trefcount_set(&cmd->ref_count, 1);\n\tinit_rwsem(&cmd->root_lock);\n\tcmd->bdev = bdev;\n\tcmd->data_block_size = data_block_size;\n\tcmd->cache_blocks = 0;\n\tcmd->policy_hint_size = policy_hint_size;\n\tcmd->changed = true;\n\tcmd->fail_io = false;\n\n\tr = __create_persistent_data_objects(cmd, may_format_device);\n\tif (r) {\n\t\tkfree(cmd);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tr = __begin_transaction_flags(cmd, clear_clean_shutdown);\n\tif (r < 0) {\n\t\tdm_cache_metadata_close(cmd);\n\t\treturn ERR_PTR(r);\n\t}\n\n\treturn cmd;\n}\n\n \nstatic DEFINE_MUTEX(table_lock);\nstatic LIST_HEAD(table);\n\nstatic struct dm_cache_metadata *lookup(struct block_device *bdev)\n{\n\tstruct dm_cache_metadata *cmd;\n\n\tlist_for_each_entry(cmd, &table, list)\n\t\tif (cmd->bdev == bdev) {\n\t\t\trefcount_inc(&cmd->ref_count);\n\t\t\treturn cmd;\n\t\t}\n\n\treturn NULL;\n}\n\nstatic struct dm_cache_metadata *lookup_or_open(struct block_device *bdev,\n\t\t\t\t\t\tsector_t data_block_size,\n\t\t\t\t\t\tbool may_format_device,\n\t\t\t\t\t\tsize_t policy_hint_size,\n\t\t\t\t\t\tunsigned int metadata_version)\n{\n\tstruct dm_cache_metadata *cmd, *cmd2;\n\n\tmutex_lock(&table_lock);\n\tcmd = lookup(bdev);\n\tmutex_unlock(&table_lock);\n\n\tif (cmd)\n\t\treturn cmd;\n\n\tcmd = metadata_open(bdev, data_block_size, may_format_device,\n\t\t\t    policy_hint_size, metadata_version);\n\tif (!IS_ERR(cmd)) {\n\t\tmutex_lock(&table_lock);\n\t\tcmd2 = lookup(bdev);\n\t\tif (cmd2) {\n\t\t\tmutex_unlock(&table_lock);\n\t\t\t__destroy_persistent_data_objects(cmd, true);\n\t\t\tkfree(cmd);\n\t\t\treturn cmd2;\n\t\t}\n\t\tlist_add(&cmd->list, &table);\n\t\tmutex_unlock(&table_lock);\n\t}\n\n\treturn cmd;\n}\n\nstatic bool same_params(struct dm_cache_metadata *cmd, sector_t data_block_size)\n{\n\tif (cmd->data_block_size != data_block_size) {\n\t\tDMERR(\"data_block_size (%llu) different from that in metadata (%llu)\",\n\t\t      (unsigned long long) data_block_size,\n\t\t      (unsigned long long) cmd->data_block_size);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstruct dm_cache_metadata *dm_cache_metadata_open(struct block_device *bdev,\n\t\t\t\t\t\t sector_t data_block_size,\n\t\t\t\t\t\t bool may_format_device,\n\t\t\t\t\t\t size_t policy_hint_size,\n\t\t\t\t\t\t unsigned int metadata_version)\n{\n\tstruct dm_cache_metadata *cmd = lookup_or_open(bdev, data_block_size, may_format_device,\n\t\t\t\t\t\t       policy_hint_size, metadata_version);\n\n\tif (!IS_ERR(cmd) && !same_params(cmd, data_block_size)) {\n\t\tdm_cache_metadata_close(cmd);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn cmd;\n}\n\nvoid dm_cache_metadata_close(struct dm_cache_metadata *cmd)\n{\n\tif (refcount_dec_and_test(&cmd->ref_count)) {\n\t\tmutex_lock(&table_lock);\n\t\tlist_del(&cmd->list);\n\t\tmutex_unlock(&table_lock);\n\n\t\tif (!cmd->fail_io)\n\t\t\t__destroy_persistent_data_objects(cmd, true);\n\t\tkfree(cmd);\n\t}\n}\n\n \nstatic int block_clean_combined_dirty(struct dm_cache_metadata *cmd, dm_cblock_t b,\n\t\t\t\t      bool *result)\n{\n\tint r;\n\t__le64 value;\n\tdm_oblock_t ob;\n\tunsigned int flags;\n\n\tr = dm_array_get_value(&cmd->info, cmd->root, from_cblock(b), &value);\n\tif (r)\n\t\treturn r;\n\n\tunpack_value(value, &ob, &flags);\n\t*result = !((flags & M_VALID) && (flags & M_DIRTY));\n\n\treturn 0;\n}\n\nstatic int blocks_are_clean_combined_dirty(struct dm_cache_metadata *cmd,\n\t\t\t\t\t   dm_cblock_t begin, dm_cblock_t end,\n\t\t\t\t\t   bool *result)\n{\n\tint r;\n\t*result = true;\n\n\twhile (begin != end) {\n\t\tr = block_clean_combined_dirty(cmd, begin, result);\n\t\tif (r) {\n\t\t\tDMERR(\"block_clean_combined_dirty failed\");\n\t\t\treturn r;\n\t\t}\n\n\t\tif (!*result) {\n\t\t\tDMERR(\"cache block %llu is dirty\",\n\t\t\t      (unsigned long long) from_cblock(begin));\n\t\t\treturn 0;\n\t\t}\n\n\t\tbegin = to_cblock(from_cblock(begin) + 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int blocks_are_clean_separate_dirty(struct dm_cache_metadata *cmd,\n\t\t\t\t\t   dm_cblock_t begin, dm_cblock_t end,\n\t\t\t\t\t   bool *result)\n{\n\tint r;\n\tbool dirty_flag;\n\t*result = true;\n\n\tif (from_cblock(cmd->cache_blocks) == 0)\n\t\t \n\t\treturn 0;\n\n\tr = dm_bitset_cursor_begin(&cmd->dirty_info, cmd->dirty_root,\n\t\t\t\t   from_cblock(cmd->cache_blocks), &cmd->dirty_cursor);\n\tif (r) {\n\t\tDMERR(\"%s: dm_bitset_cursor_begin for dirty failed\", __func__);\n\t\treturn r;\n\t}\n\n\tr = dm_bitset_cursor_skip(&cmd->dirty_cursor, from_cblock(begin));\n\tif (r) {\n\t\tDMERR(\"%s: dm_bitset_cursor_skip for dirty failed\", __func__);\n\t\tdm_bitset_cursor_end(&cmd->dirty_cursor);\n\t\treturn r;\n\t}\n\n\twhile (begin != end) {\n\t\t \n\t\tdirty_flag = dm_bitset_cursor_get_value(&cmd->dirty_cursor);\n\t\tif (dirty_flag) {\n\t\t\tDMERR(\"%s: cache block %llu is dirty\", __func__,\n\t\t\t      (unsigned long long) from_cblock(begin));\n\t\t\tdm_bitset_cursor_end(&cmd->dirty_cursor);\n\t\t\t*result = false;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbegin = to_cblock(from_cblock(begin) + 1);\n\t\tif (begin == end)\n\t\t\tbreak;\n\n\t\tr = dm_bitset_cursor_next(&cmd->dirty_cursor);\n\t\tif (r) {\n\t\t\tDMERR(\"%s: dm_bitset_cursor_next for dirty failed\", __func__);\n\t\t\tdm_bitset_cursor_end(&cmd->dirty_cursor);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tdm_bitset_cursor_end(&cmd->dirty_cursor);\n\n\treturn 0;\n}\n\nstatic int blocks_are_unmapped_or_clean(struct dm_cache_metadata *cmd,\n\t\t\t\t\tdm_cblock_t begin, dm_cblock_t end,\n\t\t\t\t\tbool *result)\n{\n\tif (separate_dirty_bits(cmd))\n\t\treturn blocks_are_clean_separate_dirty(cmd, begin, end, result);\n\telse\n\t\treturn blocks_are_clean_combined_dirty(cmd, begin, end, result);\n}\n\nstatic bool cmd_write_lock(struct dm_cache_metadata *cmd)\n{\n\tdown_write(&cmd->root_lock);\n\tif (cmd->fail_io || dm_bm_is_read_only(cmd->bm)) {\n\t\tup_write(&cmd->root_lock);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n#define WRITE_LOCK(cmd)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tif (!cmd_write_lock((cmd)))\t\\\n\t\t\treturn -EINVAL;\t\t\\\n\t} while (0)\n\n#define WRITE_LOCK_VOID(cmd)\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tif (!cmd_write_lock((cmd)))\t\\\n\t\t\treturn;\t\t\t\\\n\t} while (0)\n\n#define WRITE_UNLOCK(cmd) \\\n\tup_write(&(cmd)->root_lock)\n\nstatic bool cmd_read_lock(struct dm_cache_metadata *cmd)\n{\n\tdown_read(&cmd->root_lock);\n\tif (cmd->fail_io) {\n\t\tup_read(&cmd->root_lock);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n#define READ_LOCK(cmd)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tif (!cmd_read_lock((cmd)))\t\\\n\t\t\treturn -EINVAL;\t\t\\\n\t} while (0)\n\n#define READ_LOCK_VOID(cmd)\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tif (!cmd_read_lock((cmd)))\t\\\n\t\t\treturn;\t\t\t\\\n\t} while (0)\n\n#define READ_UNLOCK(cmd) \\\n\tup_read(&(cmd)->root_lock)\n\nint dm_cache_resize(struct dm_cache_metadata *cmd, dm_cblock_t new_cache_size)\n{\n\tint r;\n\tbool clean;\n\t__le64 null_mapping = pack_value(0, 0);\n\n\tWRITE_LOCK(cmd);\n\t__dm_bless_for_disk(&null_mapping);\n\n\tif (from_cblock(new_cache_size) < from_cblock(cmd->cache_blocks)) {\n\t\tr = blocks_are_unmapped_or_clean(cmd, new_cache_size, cmd->cache_blocks, &clean);\n\t\tif (r) {\n\t\t\t__dm_unbless_for_disk(&null_mapping);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!clean) {\n\t\t\tDMERR(\"unable to shrink cache due to dirty blocks\");\n\t\t\tr = -EINVAL;\n\t\t\t__dm_unbless_for_disk(&null_mapping);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tr = dm_array_resize(&cmd->info, cmd->root, from_cblock(cmd->cache_blocks),\n\t\t\t    from_cblock(new_cache_size),\n\t\t\t    &null_mapping, &cmd->root);\n\tif (r)\n\t\tgoto out;\n\n\tif (separate_dirty_bits(cmd)) {\n\t\tr = dm_bitset_resize(&cmd->dirty_info, cmd->dirty_root,\n\t\t\t\t     from_cblock(cmd->cache_blocks), from_cblock(new_cache_size),\n\t\t\t\t     false, &cmd->dirty_root);\n\t\tif (r)\n\t\t\tgoto out;\n\t}\n\n\tcmd->cache_blocks = new_cache_size;\n\tcmd->changed = true;\n\nout:\n\tWRITE_UNLOCK(cmd);\n\n\treturn r;\n}\n\nint dm_cache_discard_bitset_resize(struct dm_cache_metadata *cmd,\n\t\t\t\t   sector_t discard_block_size,\n\t\t\t\t   dm_dblock_t new_nr_entries)\n{\n\tint r;\n\n\tWRITE_LOCK(cmd);\n\tr = dm_bitset_resize(&cmd->discard_info,\n\t\t\t     cmd->discard_root,\n\t\t\t     from_dblock(cmd->discard_nr_blocks),\n\t\t\t     from_dblock(new_nr_entries),\n\t\t\t     false, &cmd->discard_root);\n\tif (!r) {\n\t\tcmd->discard_block_size = discard_block_size;\n\t\tcmd->discard_nr_blocks = new_nr_entries;\n\t}\n\n\tcmd->changed = true;\n\tWRITE_UNLOCK(cmd);\n\n\treturn r;\n}\n\nstatic int __set_discard(struct dm_cache_metadata *cmd, dm_dblock_t b)\n{\n\treturn dm_bitset_set_bit(&cmd->discard_info, cmd->discard_root,\n\t\t\t\t from_dblock(b), &cmd->discard_root);\n}\n\nstatic int __clear_discard(struct dm_cache_metadata *cmd, dm_dblock_t b)\n{\n\treturn dm_bitset_clear_bit(&cmd->discard_info, cmd->discard_root,\n\t\t\t\t   from_dblock(b), &cmd->discard_root);\n}\n\nstatic int __discard(struct dm_cache_metadata *cmd,\n\t\t     dm_dblock_t dblock, bool discard)\n{\n\tint r;\n\n\tr = (discard ? __set_discard : __clear_discard)(cmd, dblock);\n\tif (r)\n\t\treturn r;\n\n\tcmd->changed = true;\n\treturn 0;\n}\n\nint dm_cache_set_discard(struct dm_cache_metadata *cmd,\n\t\t\t dm_dblock_t dblock, bool discard)\n{\n\tint r;\n\n\tWRITE_LOCK(cmd);\n\tr = __discard(cmd, dblock, discard);\n\tWRITE_UNLOCK(cmd);\n\n\treturn r;\n}\n\nstatic int __load_discards(struct dm_cache_metadata *cmd,\n\t\t\t   load_discard_fn fn, void *context)\n{\n\tint r = 0;\n\tuint32_t b;\n\tstruct dm_bitset_cursor c;\n\n\tif (from_dblock(cmd->discard_nr_blocks) == 0)\n\t\t \n\t\treturn 0;\n\n\tif (cmd->clean_when_opened) {\n\t\tr = dm_bitset_flush(&cmd->discard_info, cmd->discard_root, &cmd->discard_root);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = dm_bitset_cursor_begin(&cmd->discard_info, cmd->discard_root,\n\t\t\t\t\t   from_dblock(cmd->discard_nr_blocks), &c);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tfor (b = 0; ; b++) {\n\t\t\tr = fn(context, cmd->discard_block_size, to_dblock(b),\n\t\t\t       dm_bitset_cursor_get_value(&c));\n\t\t\tif (r)\n\t\t\t\tbreak;\n\n\t\t\tif (b >= (from_dblock(cmd->discard_nr_blocks) - 1))\n\t\t\t\tbreak;\n\n\t\t\tr = dm_bitset_cursor_next(&c);\n\t\t\tif (r)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdm_bitset_cursor_end(&c);\n\n\t} else {\n\t\tfor (b = 0; b < from_dblock(cmd->discard_nr_blocks); b++) {\n\t\t\tr = fn(context, cmd->discard_block_size, to_dblock(b), false);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn r;\n}\n\nint dm_cache_load_discards(struct dm_cache_metadata *cmd,\n\t\t\t   load_discard_fn fn, void *context)\n{\n\tint r;\n\n\tREAD_LOCK(cmd);\n\tr = __load_discards(cmd, fn, context);\n\tREAD_UNLOCK(cmd);\n\n\treturn r;\n}\n\nint dm_cache_size(struct dm_cache_metadata *cmd, dm_cblock_t *result)\n{\n\tREAD_LOCK(cmd);\n\t*result = cmd->cache_blocks;\n\tREAD_UNLOCK(cmd);\n\n\treturn 0;\n}\n\nstatic int __remove(struct dm_cache_metadata *cmd, dm_cblock_t cblock)\n{\n\tint r;\n\t__le64 value = pack_value(0, 0);\n\n\t__dm_bless_for_disk(&value);\n\tr = dm_array_set_value(&cmd->info, cmd->root, from_cblock(cblock),\n\t\t\t       &value, &cmd->root);\n\tif (r)\n\t\treturn r;\n\n\tcmd->changed = true;\n\treturn 0;\n}\n\nint dm_cache_remove_mapping(struct dm_cache_metadata *cmd, dm_cblock_t cblock)\n{\n\tint r;\n\n\tWRITE_LOCK(cmd);\n\tr = __remove(cmd, cblock);\n\tWRITE_UNLOCK(cmd);\n\n\treturn r;\n}\n\nstatic int __insert(struct dm_cache_metadata *cmd,\n\t\t    dm_cblock_t cblock, dm_oblock_t oblock)\n{\n\tint r;\n\t__le64 value = pack_value(oblock, M_VALID);\n\n\t__dm_bless_for_disk(&value);\n\n\tr = dm_array_set_value(&cmd->info, cmd->root, from_cblock(cblock),\n\t\t\t       &value, &cmd->root);\n\tif (r)\n\t\treturn r;\n\n\tcmd->changed = true;\n\treturn 0;\n}\n\nint dm_cache_insert_mapping(struct dm_cache_metadata *cmd,\n\t\t\t    dm_cblock_t cblock, dm_oblock_t oblock)\n{\n\tint r;\n\n\tWRITE_LOCK(cmd);\n\tr = __insert(cmd, cblock, oblock);\n\tWRITE_UNLOCK(cmd);\n\n\treturn r;\n}\n\nstruct thunk {\n\tload_mapping_fn fn;\n\tvoid *context;\n\n\tstruct dm_cache_metadata *cmd;\n\tbool respect_dirty_flags;\n\tbool hints_valid;\n};\n\nstatic bool policy_unchanged(struct dm_cache_metadata *cmd,\n\t\t\t     struct dm_cache_policy *policy)\n{\n\tconst char *policy_name = dm_cache_policy_get_name(policy);\n\tconst unsigned int *policy_version = dm_cache_policy_get_version(policy);\n\tsize_t policy_hint_size = dm_cache_policy_get_hint_size(policy);\n\n\t \n\tif (strncmp(cmd->policy_name, policy_name, sizeof(cmd->policy_name)))\n\t\treturn false;\n\n\t \n\tif (cmd->policy_version[0] != policy_version[0])\n\t\treturn false;\n\n\t \n\tif (cmd->policy_hint_size != policy_hint_size)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool hints_array_initialized(struct dm_cache_metadata *cmd)\n{\n\treturn cmd->hint_root && cmd->policy_hint_size;\n}\n\nstatic bool hints_array_available(struct dm_cache_metadata *cmd,\n\t\t\t\t  struct dm_cache_policy *policy)\n{\n\treturn cmd->clean_when_opened && policy_unchanged(cmd, policy) &&\n\t\thints_array_initialized(cmd);\n}\n\nstatic int __load_mapping_v1(struct dm_cache_metadata *cmd,\n\t\t\t     uint64_t cb, bool hints_valid,\n\t\t\t     struct dm_array_cursor *mapping_cursor,\n\t\t\t     struct dm_array_cursor *hint_cursor,\n\t\t\t     load_mapping_fn fn, void *context)\n{\n\tint r = 0;\n\n\t__le64 mapping;\n\t__le32 hint = 0;\n\n\t__le64 *mapping_value_le;\n\t__le32 *hint_value_le;\n\n\tdm_oblock_t oblock;\n\tunsigned int flags;\n\tbool dirty = true;\n\n\tdm_array_cursor_get_value(mapping_cursor, (void **) &mapping_value_le);\n\tmemcpy(&mapping, mapping_value_le, sizeof(mapping));\n\tunpack_value(mapping, &oblock, &flags);\n\n\tif (flags & M_VALID) {\n\t\tif (hints_valid) {\n\t\t\tdm_array_cursor_get_value(hint_cursor, (void **) &hint_value_le);\n\t\t\tmemcpy(&hint, hint_value_le, sizeof(hint));\n\t\t}\n\t\tif (cmd->clean_when_opened)\n\t\t\tdirty = flags & M_DIRTY;\n\n\t\tr = fn(context, oblock, to_cblock(cb), dirty,\n\t\t       le32_to_cpu(hint), hints_valid);\n\t\tif (r) {\n\t\t\tDMERR(\"policy couldn't load cache block %llu\",\n\t\t\t      (unsigned long long) from_cblock(to_cblock(cb)));\n\t\t}\n\t}\n\n\treturn r;\n}\n\nstatic int __load_mapping_v2(struct dm_cache_metadata *cmd,\n\t\t\t     uint64_t cb, bool hints_valid,\n\t\t\t     struct dm_array_cursor *mapping_cursor,\n\t\t\t     struct dm_array_cursor *hint_cursor,\n\t\t\t     struct dm_bitset_cursor *dirty_cursor,\n\t\t\t     load_mapping_fn fn, void *context)\n{\n\tint r = 0;\n\n\t__le64 mapping;\n\t__le32 hint = 0;\n\n\t__le64 *mapping_value_le;\n\t__le32 *hint_value_le;\n\n\tdm_oblock_t oblock;\n\tunsigned int flags;\n\tbool dirty = true;\n\n\tdm_array_cursor_get_value(mapping_cursor, (void **) &mapping_value_le);\n\tmemcpy(&mapping, mapping_value_le, sizeof(mapping));\n\tunpack_value(mapping, &oblock, &flags);\n\n\tif (flags & M_VALID) {\n\t\tif (hints_valid) {\n\t\t\tdm_array_cursor_get_value(hint_cursor, (void **) &hint_value_le);\n\t\t\tmemcpy(&hint, hint_value_le, sizeof(hint));\n\t\t}\n\t\tif (cmd->clean_when_opened)\n\t\t\tdirty = dm_bitset_cursor_get_value(dirty_cursor);\n\n\t\tr = fn(context, oblock, to_cblock(cb), dirty,\n\t\t       le32_to_cpu(hint), hints_valid);\n\t\tif (r) {\n\t\t\tDMERR(\"policy couldn't load cache block %llu\",\n\t\t\t      (unsigned long long) from_cblock(to_cblock(cb)));\n\t\t}\n\t}\n\n\treturn r;\n}\n\nstatic int __load_mappings(struct dm_cache_metadata *cmd,\n\t\t\t   struct dm_cache_policy *policy,\n\t\t\t   load_mapping_fn fn, void *context)\n{\n\tint r;\n\tuint64_t cb;\n\n\tbool hints_valid = hints_array_available(cmd, policy);\n\n\tif (from_cblock(cmd->cache_blocks) == 0)\n\t\t \n\t\treturn 0;\n\n\tr = dm_array_cursor_begin(&cmd->info, cmd->root, &cmd->mapping_cursor);\n\tif (r)\n\t\treturn r;\n\n\tif (hints_valid) {\n\t\tr = dm_array_cursor_begin(&cmd->hint_info, cmd->hint_root, &cmd->hint_cursor);\n\t\tif (r) {\n\t\t\tdm_array_cursor_end(&cmd->mapping_cursor);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (separate_dirty_bits(cmd)) {\n\t\tr = dm_bitset_cursor_begin(&cmd->dirty_info, cmd->dirty_root,\n\t\t\t\t\t   from_cblock(cmd->cache_blocks),\n\t\t\t\t\t   &cmd->dirty_cursor);\n\t\tif (r) {\n\t\t\tdm_array_cursor_end(&cmd->hint_cursor);\n\t\t\tdm_array_cursor_end(&cmd->mapping_cursor);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tfor (cb = 0; ; cb++) {\n\t\tif (separate_dirty_bits(cmd))\n\t\t\tr = __load_mapping_v2(cmd, cb, hints_valid,\n\t\t\t\t\t      &cmd->mapping_cursor,\n\t\t\t\t\t      &cmd->hint_cursor,\n\t\t\t\t\t      &cmd->dirty_cursor,\n\t\t\t\t\t      fn, context);\n\t\telse\n\t\t\tr = __load_mapping_v1(cmd, cb, hints_valid,\n\t\t\t\t\t      &cmd->mapping_cursor, &cmd->hint_cursor,\n\t\t\t\t\t      fn, context);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (cb >= (from_cblock(cmd->cache_blocks) - 1))\n\t\t\tbreak;\n\n\t\tr = dm_array_cursor_next(&cmd->mapping_cursor);\n\t\tif (r) {\n\t\t\tDMERR(\"dm_array_cursor_next for mapping failed\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (hints_valid) {\n\t\t\tr = dm_array_cursor_next(&cmd->hint_cursor);\n\t\t\tif (r) {\n\t\t\t\tdm_array_cursor_end(&cmd->hint_cursor);\n\t\t\t\thints_valid = false;\n\t\t\t}\n\t\t}\n\n\t\tif (separate_dirty_bits(cmd)) {\n\t\t\tr = dm_bitset_cursor_next(&cmd->dirty_cursor);\n\t\t\tif (r) {\n\t\t\t\tDMERR(\"dm_bitset_cursor_next for dirty failed\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tdm_array_cursor_end(&cmd->mapping_cursor);\n\tif (hints_valid)\n\t\tdm_array_cursor_end(&cmd->hint_cursor);\n\n\tif (separate_dirty_bits(cmd))\n\t\tdm_bitset_cursor_end(&cmd->dirty_cursor);\n\n\treturn r;\n}\n\nint dm_cache_load_mappings(struct dm_cache_metadata *cmd,\n\t\t\t   struct dm_cache_policy *policy,\n\t\t\t   load_mapping_fn fn, void *context)\n{\n\tint r;\n\n\tREAD_LOCK(cmd);\n\tr = __load_mappings(cmd, policy, fn, context);\n\tREAD_UNLOCK(cmd);\n\n\treturn r;\n}\n\nstatic int __dump_mapping(void *context, uint64_t cblock, void *leaf)\n{\n\t__le64 value;\n\tdm_oblock_t oblock;\n\tunsigned int flags;\n\n\tmemcpy(&value, leaf, sizeof(value));\n\tunpack_value(value, &oblock, &flags);\n\n\treturn 0;\n}\n\nstatic int __dump_mappings(struct dm_cache_metadata *cmd)\n{\n\treturn dm_array_walk(&cmd->info, cmd->root, __dump_mapping, NULL);\n}\n\nvoid dm_cache_dump(struct dm_cache_metadata *cmd)\n{\n\tREAD_LOCK_VOID(cmd);\n\t__dump_mappings(cmd);\n\tREAD_UNLOCK(cmd);\n}\n\nint dm_cache_changed_this_transaction(struct dm_cache_metadata *cmd)\n{\n\tint r;\n\n\tREAD_LOCK(cmd);\n\tr = cmd->changed;\n\tREAD_UNLOCK(cmd);\n\n\treturn r;\n}\n\nstatic int __dirty(struct dm_cache_metadata *cmd, dm_cblock_t cblock, bool dirty)\n{\n\tint r;\n\tunsigned int flags;\n\tdm_oblock_t oblock;\n\t__le64 value;\n\n\tr = dm_array_get_value(&cmd->info, cmd->root, from_cblock(cblock), &value);\n\tif (r)\n\t\treturn r;\n\n\tunpack_value(value, &oblock, &flags);\n\n\tif (((flags & M_DIRTY) && dirty) || (!(flags & M_DIRTY) && !dirty))\n\t\t \n\t\treturn 0;\n\n\tvalue = pack_value(oblock, (flags & ~M_DIRTY) | (dirty ? M_DIRTY : 0));\n\t__dm_bless_for_disk(&value);\n\n\tr = dm_array_set_value(&cmd->info, cmd->root, from_cblock(cblock),\n\t\t\t       &value, &cmd->root);\n\tif (r)\n\t\treturn r;\n\n\tcmd->changed = true;\n\treturn 0;\n\n}\n\nstatic int __set_dirty_bits_v1(struct dm_cache_metadata *cmd, unsigned int nr_bits, unsigned long *bits)\n{\n\tint r;\n\tunsigned int i;\n\n\tfor (i = 0; i < nr_bits; i++) {\n\t\tr = __dirty(cmd, to_cblock(i), test_bit(i, bits));\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int is_dirty_callback(uint32_t index, bool *value, void *context)\n{\n\tunsigned long *bits = context;\n\t*value = test_bit(index, bits);\n\treturn 0;\n}\n\nstatic int __set_dirty_bits_v2(struct dm_cache_metadata *cmd, unsigned int nr_bits, unsigned long *bits)\n{\n\tint r = 0;\n\n\t \n\tif (nr_bits != from_cblock(cmd->cache_blocks)) {\n\t\tDMERR(\"dirty bitset is wrong size\");\n\t\treturn -EINVAL;\n\t}\n\n\tr = dm_bitset_del(&cmd->dirty_info, cmd->dirty_root);\n\tif (r)\n\t\treturn r;\n\n\tcmd->changed = true;\n\treturn dm_bitset_new(&cmd->dirty_info, &cmd->dirty_root, nr_bits, is_dirty_callback, bits);\n}\n\nint dm_cache_set_dirty_bits(struct dm_cache_metadata *cmd,\n\t\t\t    unsigned int nr_bits,\n\t\t\t    unsigned long *bits)\n{\n\tint r;\n\n\tWRITE_LOCK(cmd);\n\tif (separate_dirty_bits(cmd))\n\t\tr = __set_dirty_bits_v2(cmd, nr_bits, bits);\n\telse\n\t\tr = __set_dirty_bits_v1(cmd, nr_bits, bits);\n\tWRITE_UNLOCK(cmd);\n\n\treturn r;\n}\n\nvoid dm_cache_metadata_get_stats(struct dm_cache_metadata *cmd,\n\t\t\t\t struct dm_cache_statistics *stats)\n{\n\tREAD_LOCK_VOID(cmd);\n\t*stats = cmd->stats;\n\tREAD_UNLOCK(cmd);\n}\n\nvoid dm_cache_metadata_set_stats(struct dm_cache_metadata *cmd,\n\t\t\t\t struct dm_cache_statistics *stats)\n{\n\tWRITE_LOCK_VOID(cmd);\n\tcmd->stats = *stats;\n\tWRITE_UNLOCK(cmd);\n}\n\nint dm_cache_commit(struct dm_cache_metadata *cmd, bool clean_shutdown)\n{\n\tint r = -EINVAL;\n\tflags_mutator mutator = (clean_shutdown ? set_clean_shutdown :\n\t\t\t\t clear_clean_shutdown);\n\n\tWRITE_LOCK(cmd);\n\tif (cmd->fail_io)\n\t\tgoto out;\n\n\tr = __commit_transaction(cmd, mutator);\n\tif (r)\n\t\tgoto out;\n\n\tr = __begin_transaction(cmd);\nout:\n\tWRITE_UNLOCK(cmd);\n\treturn r;\n}\n\nint dm_cache_get_free_metadata_block_count(struct dm_cache_metadata *cmd,\n\t\t\t\t\t   dm_block_t *result)\n{\n\tint r = -EINVAL;\n\n\tREAD_LOCK(cmd);\n\tif (!cmd->fail_io)\n\t\tr = dm_sm_get_nr_free(cmd->metadata_sm, result);\n\tREAD_UNLOCK(cmd);\n\n\treturn r;\n}\n\nint dm_cache_get_metadata_dev_size(struct dm_cache_metadata *cmd,\n\t\t\t\t   dm_block_t *result)\n{\n\tint r = -EINVAL;\n\n\tREAD_LOCK(cmd);\n\tif (!cmd->fail_io)\n\t\tr = dm_sm_get_nr_blocks(cmd->metadata_sm, result);\n\tREAD_UNLOCK(cmd);\n\n\treturn r;\n}\n\n \n\nstatic int get_hint(uint32_t index, void *value_le, void *context)\n{\n\tuint32_t value;\n\tstruct dm_cache_policy *policy = context;\n\n\tvalue = policy_get_hint(policy, to_cblock(index));\n\t*((__le32 *) value_le) = cpu_to_le32(value);\n\n\treturn 0;\n}\n\n \nstatic int write_hints(struct dm_cache_metadata *cmd, struct dm_cache_policy *policy)\n{\n\tint r;\n\tsize_t hint_size;\n\tconst char *policy_name = dm_cache_policy_get_name(policy);\n\tconst unsigned int *policy_version = dm_cache_policy_get_version(policy);\n\n\tif (!policy_name[0] ||\n\t    (strlen(policy_name) > sizeof(cmd->policy_name) - 1))\n\t\treturn -EINVAL;\n\n\tstrncpy(cmd->policy_name, policy_name, sizeof(cmd->policy_name));\n\tmemcpy(cmd->policy_version, policy_version, sizeof(cmd->policy_version));\n\n\thint_size = dm_cache_policy_get_hint_size(policy);\n\tif (!hint_size)\n\t\treturn 0;  \n\tcmd->policy_hint_size = hint_size;\n\n\tif (cmd->hint_root) {\n\t\tr = dm_array_del(&cmd->hint_info, cmd->hint_root);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn dm_array_new(&cmd->hint_info, &cmd->hint_root,\n\t\t\t    from_cblock(cmd->cache_blocks),\n\t\t\t    get_hint, policy);\n}\n\nint dm_cache_write_hints(struct dm_cache_metadata *cmd, struct dm_cache_policy *policy)\n{\n\tint r;\n\n\tWRITE_LOCK(cmd);\n\tr = write_hints(cmd, policy);\n\tWRITE_UNLOCK(cmd);\n\n\treturn r;\n}\n\nint dm_cache_metadata_all_clean(struct dm_cache_metadata *cmd, bool *result)\n{\n\tint r;\n\n\tREAD_LOCK(cmd);\n\tr = blocks_are_unmapped_or_clean(cmd, 0, cmd->cache_blocks, result);\n\tREAD_UNLOCK(cmd);\n\n\treturn r;\n}\n\nvoid dm_cache_metadata_set_read_only(struct dm_cache_metadata *cmd)\n{\n\tWRITE_LOCK_VOID(cmd);\n\tdm_bm_set_read_only(cmd->bm);\n\tWRITE_UNLOCK(cmd);\n}\n\nvoid dm_cache_metadata_set_read_write(struct dm_cache_metadata *cmd)\n{\n\tWRITE_LOCK_VOID(cmd);\n\tdm_bm_set_read_write(cmd->bm);\n\tWRITE_UNLOCK(cmd);\n}\n\nint dm_cache_metadata_set_needs_check(struct dm_cache_metadata *cmd)\n{\n\tint r;\n\tstruct dm_block *sblock;\n\tstruct cache_disk_superblock *disk_super;\n\n\tWRITE_LOCK(cmd);\n\tset_bit(NEEDS_CHECK, &cmd->flags);\n\n\tr = superblock_lock(cmd, &sblock);\n\tif (r) {\n\t\tDMERR(\"couldn't read superblock\");\n\t\tgoto out;\n\t}\n\n\tdisk_super = dm_block_data(sblock);\n\tdisk_super->flags = cpu_to_le32(cmd->flags);\n\n\tdm_bm_unlock(sblock);\n\nout:\n\tWRITE_UNLOCK(cmd);\n\treturn r;\n}\n\nint dm_cache_metadata_needs_check(struct dm_cache_metadata *cmd, bool *result)\n{\n\tREAD_LOCK(cmd);\n\t*result = !!test_bit(NEEDS_CHECK, &cmd->flags);\n\tREAD_UNLOCK(cmd);\n\n\treturn 0;\n}\n\nint dm_cache_metadata_abort(struct dm_cache_metadata *cmd)\n{\n\tint r = -EINVAL;\n\tstruct dm_block_manager *old_bm = NULL, *new_bm = NULL;\n\n\t \n\tif (unlikely(cmd->fail_io))\n\t\treturn r;\n\n\t \n\tnew_bm = dm_block_manager_create(cmd->bdev, DM_CACHE_METADATA_BLOCK_SIZE << SECTOR_SHIFT,\n\t\t\t\t\t CACHE_MAX_CONCURRENT_LOCKS);\n\n\tWRITE_LOCK(cmd);\n\tif (cmd->fail_io) {\n\t\tWRITE_UNLOCK(cmd);\n\t\tgoto out;\n\t}\n\n\t__destroy_persistent_data_objects(cmd, false);\n\told_bm = cmd->bm;\n\tif (IS_ERR(new_bm)) {\n\t\tDMERR(\"could not create block manager during abort\");\n\t\tcmd->bm = NULL;\n\t\tr = PTR_ERR(new_bm);\n\t\tgoto out_unlock;\n\t}\n\n\tcmd->bm = new_bm;\n\tr = __open_or_format_metadata(cmd, false);\n\tif (r) {\n\t\tcmd->bm = NULL;\n\t\tgoto out_unlock;\n\t}\n\tnew_bm = NULL;\nout_unlock:\n\tif (r)\n\t\tcmd->fail_io = true;\n\tWRITE_UNLOCK(cmd);\n\tdm_block_manager_destroy(old_bm);\nout:\n\tif (new_bm && !IS_ERR(new_bm))\n\t\tdm_block_manager_destroy(new_bm);\n\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}