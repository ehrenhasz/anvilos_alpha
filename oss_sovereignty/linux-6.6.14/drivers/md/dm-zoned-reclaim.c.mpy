{
  "module_name": "dm-zoned-reclaim.c",
  "hash_id": "677f73e74fde202683ab2dc768bcf3be6a47cb277b1495fca6e44e8be7887d25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-zoned-reclaim.c",
  "human_readable_source": "\n \n\n#include \"dm-zoned.h\"\n\n#include <linux/module.h>\n\n#define\tDM_MSG_PREFIX\t\t\"zoned reclaim\"\n\nstruct dmz_reclaim {\n\tstruct dmz_metadata     *metadata;\n\n\tstruct delayed_work\twork;\n\tstruct workqueue_struct *wq;\n\n\tstruct dm_kcopyd_client\t*kc;\n\tstruct dm_kcopyd_throttle kc_throttle;\n\tint\t\t\tkc_err;\n\n\tint\t\t\tdev_idx;\n\n\tunsigned long\t\tflags;\n\n\t \n\tunsigned long\t\tatime;\n};\n\n \nenum {\n\tDMZ_RECLAIM_KCOPY,\n};\n\n \n#define DMZ_IDLE_PERIOD\t\t\t(10UL * HZ)\n\n \n#define DMZ_RECLAIM_LOW_UNMAP_ZONES\t30\n\n \n#define DMZ_RECLAIM_HIGH_UNMAP_ZONES\t50\n\n \nstatic int dmz_reclaim_align_wp(struct dmz_reclaim *zrc, struct dm_zone *zone,\n\t\t\t\tsector_t block)\n{\n\tstruct dmz_metadata *zmd = zrc->metadata;\n\tstruct dmz_dev *dev = zone->dev;\n\tsector_t wp_block = zone->wp_block;\n\tunsigned int nr_blocks;\n\tint ret;\n\n\tif (wp_block == block)\n\t\treturn 0;\n\n\tif (wp_block > block)\n\t\treturn -EIO;\n\n\t \n\tnr_blocks = block - wp_block;\n\tret = blkdev_issue_zeroout(dev->bdev,\n\t\t\t\t   dmz_start_sect(zmd, zone) + dmz_blk2sect(wp_block),\n\t\t\t\t   dmz_blk2sect(nr_blocks), GFP_NOIO, 0);\n\tif (ret) {\n\t\tdmz_dev_err(dev,\n\t\t\t    \"Align zone %u wp %llu to %llu (wp+%u) blocks failed %d\",\n\t\t\t    zone->id, (unsigned long long)wp_block,\n\t\t\t    (unsigned long long)block, nr_blocks, ret);\n\t\tdmz_check_bdev(dev);\n\t\treturn ret;\n\t}\n\n\tzone->wp_block = block;\n\n\treturn 0;\n}\n\n \nstatic void dmz_reclaim_kcopy_end(int read_err, unsigned long write_err,\n\t\t\t\t  void *context)\n{\n\tstruct dmz_reclaim *zrc = context;\n\n\tif (read_err || write_err)\n\t\tzrc->kc_err = -EIO;\n\telse\n\t\tzrc->kc_err = 0;\n\n\tclear_bit_unlock(DMZ_RECLAIM_KCOPY, &zrc->flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&zrc->flags, DMZ_RECLAIM_KCOPY);\n}\n\n \nstatic int dmz_reclaim_copy(struct dmz_reclaim *zrc,\n\t\t\t    struct dm_zone *src_zone, struct dm_zone *dst_zone)\n{\n\tstruct dmz_metadata *zmd = zrc->metadata;\n\tstruct dm_io_region src, dst;\n\tsector_t block = 0, end_block;\n\tsector_t nr_blocks;\n\tsector_t src_zone_block;\n\tsector_t dst_zone_block;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (dmz_is_seq(src_zone))\n\t\tend_block = src_zone->wp_block;\n\telse\n\t\tend_block = dmz_zone_nr_blocks(zmd);\n\tsrc_zone_block = dmz_start_block(zmd, src_zone);\n\tdst_zone_block = dmz_start_block(zmd, dst_zone);\n\n\tif (dmz_is_seq(dst_zone))\n\t\tflags |= BIT(DM_KCOPYD_WRITE_SEQ);\n\n\twhile (block < end_block) {\n\t\tif (src_zone->dev->flags & DMZ_BDEV_DYING)\n\t\t\treturn -EIO;\n\t\tif (dst_zone->dev->flags & DMZ_BDEV_DYING)\n\t\t\treturn -EIO;\n\n\t\tif (dmz_reclaim_should_terminate(src_zone))\n\t\t\treturn -EINTR;\n\n\t\t \n\t\tret = dmz_first_valid_block(zmd, src_zone, &block);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t\tnr_blocks = ret;\n\n\t\t \n\t\tif (dmz_is_seq(dst_zone)) {\n\t\t\tret = dmz_reclaim_align_wp(zrc, dst_zone, block);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tsrc.bdev = src_zone->dev->bdev;\n\t\tsrc.sector = dmz_blk2sect(src_zone_block + block);\n\t\tsrc.count = dmz_blk2sect(nr_blocks);\n\n\t\tdst.bdev = dst_zone->dev->bdev;\n\t\tdst.sector = dmz_blk2sect(dst_zone_block + block);\n\t\tdst.count = src.count;\n\n\t\t \n\t\tset_bit(DMZ_RECLAIM_KCOPY, &zrc->flags);\n\t\tdm_kcopyd_copy(zrc->kc, &src, 1, &dst, flags,\n\t\t\t       dmz_reclaim_kcopy_end, zrc);\n\n\t\t \n\t\twait_on_bit_io(&zrc->flags, DMZ_RECLAIM_KCOPY,\n\t\t\t       TASK_UNINTERRUPTIBLE);\n\t\tif (zrc->kc_err)\n\t\t\treturn zrc->kc_err;\n\n\t\tblock += nr_blocks;\n\t\tif (dmz_is_seq(dst_zone))\n\t\t\tdst_zone->wp_block = block;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dmz_reclaim_buf(struct dmz_reclaim *zrc, struct dm_zone *dzone)\n{\n\tstruct dm_zone *bzone = dzone->bzone;\n\tsector_t chunk_block = dzone->wp_block;\n\tstruct dmz_metadata *zmd = zrc->metadata;\n\tint ret;\n\n\tDMDEBUG(\"(%s/%u): Chunk %u, move buf zone %u (weight %u) to data zone %u (weight %u)\",\n\t\tdmz_metadata_label(zmd), zrc->dev_idx,\n\t\tdzone->chunk, bzone->id, dmz_weight(bzone),\n\t\tdzone->id, dmz_weight(dzone));\n\n\t \n\tret = dmz_reclaim_copy(zrc, bzone, dzone);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdmz_lock_flush(zmd);\n\n\t \n\tret = dmz_merge_valid_blocks(zmd, bzone, dzone, chunk_block);\n\tif (ret == 0) {\n\t\t \n\t\tdmz_invalidate_blocks(zmd, bzone, 0, dmz_zone_nr_blocks(zmd));\n\t\tdmz_lock_map(zmd);\n\t\tdmz_unmap_zone(zmd, bzone);\n\t\tdmz_unlock_zone_reclaim(dzone);\n\t\tdmz_free_zone(zmd, bzone);\n\t\tdmz_unlock_map(zmd);\n\t}\n\n\tdmz_unlock_flush(zmd);\n\n\treturn ret;\n}\n\n \nstatic int dmz_reclaim_seq_data(struct dmz_reclaim *zrc, struct dm_zone *dzone)\n{\n\tunsigned int chunk = dzone->chunk;\n\tstruct dm_zone *bzone = dzone->bzone;\n\tstruct dmz_metadata *zmd = zrc->metadata;\n\tint ret = 0;\n\n\tDMDEBUG(\"(%s/%u): Chunk %u, move data zone %u (weight %u) to buf zone %u (weight %u)\",\n\t\tdmz_metadata_label(zmd), zrc->dev_idx,\n\t\tchunk, dzone->id, dmz_weight(dzone),\n\t\tbzone->id, dmz_weight(bzone));\n\n\t \n\tret = dmz_reclaim_copy(zrc, dzone, bzone);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdmz_lock_flush(zmd);\n\n\t \n\tret = dmz_merge_valid_blocks(zmd, dzone, bzone, 0);\n\tif (ret == 0) {\n\t\t \n\t\tdmz_invalidate_blocks(zmd, dzone, 0, dmz_zone_nr_blocks(zmd));\n\t\tdmz_lock_map(zmd);\n\t\tdmz_unmap_zone(zmd, bzone);\n\t\tdmz_unmap_zone(zmd, dzone);\n\t\tdmz_unlock_zone_reclaim(dzone);\n\t\tdmz_free_zone(zmd, dzone);\n\t\tdmz_map_zone(zmd, bzone, chunk);\n\t\tdmz_unlock_map(zmd);\n\t}\n\n\tdmz_unlock_flush(zmd);\n\n\treturn ret;\n}\n\n \nstatic int dmz_reclaim_rnd_data(struct dmz_reclaim *zrc, struct dm_zone *dzone)\n{\n\tunsigned int chunk = dzone->chunk;\n\tstruct dm_zone *szone = NULL;\n\tstruct dmz_metadata *zmd = zrc->metadata;\n\tint ret;\n\tint alloc_flags = DMZ_ALLOC_SEQ;\n\n\t \n\tdmz_lock_map(zmd);\nagain:\n\tszone = dmz_alloc_zone(zmd, zrc->dev_idx,\n\t\t\t       alloc_flags | DMZ_ALLOC_RECLAIM);\n\tif (!szone && alloc_flags == DMZ_ALLOC_SEQ && dmz_nr_cache_zones(zmd)) {\n\t\talloc_flags = DMZ_ALLOC_RND;\n\t\tgoto again;\n\t}\n\tdmz_unlock_map(zmd);\n\tif (!szone)\n\t\treturn -ENOSPC;\n\n\tDMDEBUG(\"(%s/%u): Chunk %u, move %s zone %u (weight %u) to %s zone %u\",\n\t\tdmz_metadata_label(zmd), zrc->dev_idx, chunk,\n\t\tdmz_is_cache(dzone) ? \"cache\" : \"rnd\",\n\t\tdzone->id, dmz_weight(dzone),\n\t\tdmz_is_rnd(szone) ? \"rnd\" : \"seq\", szone->id);\n\n\t \n\tret = dmz_reclaim_copy(zrc, dzone, szone);\n\n\tdmz_lock_flush(zmd);\n\n\tif (ret == 0) {\n\t\t \n\t\tret = dmz_copy_valid_blocks(zmd, dzone, szone);\n\t}\n\tif (ret) {\n\t\t \n\t\tdmz_lock_map(zmd);\n\t\tdmz_free_zone(zmd, szone);\n\t\tdmz_unlock_map(zmd);\n\t} else {\n\t\t \n\t\tdmz_invalidate_blocks(zmd, dzone, 0, dmz_zone_nr_blocks(zmd));\n\t\tdmz_lock_map(zmd);\n\t\tdmz_unmap_zone(zmd, dzone);\n\t\tdmz_unlock_zone_reclaim(dzone);\n\t\tdmz_free_zone(zmd, dzone);\n\t\tdmz_map_zone(zmd, szone, chunk);\n\t\tdmz_unlock_map(zmd);\n\t}\n\n\tdmz_unlock_flush(zmd);\n\n\treturn ret;\n}\n\n \nstatic void dmz_reclaim_empty(struct dmz_reclaim *zrc, struct dm_zone *dzone)\n{\n\tstruct dmz_metadata *zmd = zrc->metadata;\n\n\tdmz_lock_flush(zmd);\n\tdmz_lock_map(zmd);\n\tdmz_unmap_zone(zmd, dzone);\n\tdmz_unlock_zone_reclaim(dzone);\n\tdmz_free_zone(zmd, dzone);\n\tdmz_unlock_map(zmd);\n\tdmz_unlock_flush(zmd);\n}\n\n \nstatic inline int dmz_target_idle(struct dmz_reclaim *zrc)\n{\n\treturn time_is_before_jiffies(zrc->atime + DMZ_IDLE_PERIOD);\n}\n\n \nstatic int dmz_do_reclaim(struct dmz_reclaim *zrc)\n{\n\tstruct dmz_metadata *zmd = zrc->metadata;\n\tstruct dm_zone *dzone;\n\tstruct dm_zone *rzone;\n\tunsigned long start;\n\tint ret;\n\n\t \n\tdzone = dmz_get_zone_for_reclaim(zmd, zrc->dev_idx,\n\t\t\t\t\t dmz_target_idle(zrc));\n\tif (!dzone) {\n\t\tDMDEBUG(\"(%s/%u): No zone found to reclaim\",\n\t\t\tdmz_metadata_label(zmd), zrc->dev_idx);\n\t\treturn -EBUSY;\n\t}\n\trzone = dzone;\n\n\tstart = jiffies;\n\tif (dmz_is_cache(dzone) || dmz_is_rnd(dzone)) {\n\t\tif (!dmz_weight(dzone)) {\n\t\t\t \n\t\t\tdmz_reclaim_empty(zrc, dzone);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t \n\t\t\tret = dmz_reclaim_rnd_data(zrc, dzone);\n\t\t}\n\t} else {\n\t\tstruct dm_zone *bzone = dzone->bzone;\n\t\tsector_t chunk_block = 0;\n\n\t\tret = dmz_first_valid_block(zmd, bzone, &chunk_block);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret == 0 || chunk_block >= dzone->wp_block) {\n\t\t\t \n\t\t\tret = dmz_reclaim_buf(zrc, dzone);\n\t\t\trzone = bzone;\n\t\t} else {\n\t\t\t \n\t\t\tret = dmz_reclaim_seq_data(zrc, dzone);\n\t\t}\n\t}\nout:\n\tif (ret) {\n\t\tif (ret == -EINTR)\n\t\t\tDMDEBUG(\"(%s/%u): reclaim zone %u interrupted\",\n\t\t\t\tdmz_metadata_label(zmd), zrc->dev_idx,\n\t\t\t\trzone->id);\n\t\telse\n\t\t\tDMDEBUG(\"(%s/%u): Failed to reclaim zone %u, err %d\",\n\t\t\t\tdmz_metadata_label(zmd), zrc->dev_idx,\n\t\t\t\trzone->id, ret);\n\t\tdmz_unlock_zone_reclaim(dzone);\n\t\treturn ret;\n\t}\n\n\tret = dmz_flush_metadata(zrc->metadata);\n\tif (ret) {\n\t\tDMDEBUG(\"(%s/%u): Metadata flush for zone %u failed, err %d\",\n\t\t\tdmz_metadata_label(zmd), zrc->dev_idx, rzone->id, ret);\n\t\treturn ret;\n\t}\n\n\tDMDEBUG(\"(%s/%u): Reclaimed zone %u in %u ms\",\n\t\tdmz_metadata_label(zmd), zrc->dev_idx,\n\t\trzone->id, jiffies_to_msecs(jiffies - start));\n\treturn 0;\n}\n\nstatic unsigned int dmz_reclaim_percentage(struct dmz_reclaim *zrc)\n{\n\tstruct dmz_metadata *zmd = zrc->metadata;\n\tunsigned int nr_cache = dmz_nr_cache_zones(zmd);\n\tunsigned int nr_unmap, nr_zones;\n\n\tif (nr_cache) {\n\t\tnr_zones = nr_cache;\n\t\tnr_unmap = dmz_nr_unmap_cache_zones(zmd);\n\t} else {\n\t\tnr_zones = dmz_nr_rnd_zones(zmd, zrc->dev_idx);\n\t\tnr_unmap = dmz_nr_unmap_rnd_zones(zmd, zrc->dev_idx);\n\t}\n\tif (nr_unmap <= 1)\n\t\treturn 0;\n\treturn nr_unmap * 100 / nr_zones;\n}\n\n \nstatic bool dmz_should_reclaim(struct dmz_reclaim *zrc, unsigned int p_unmap)\n{\n\tunsigned int nr_reclaim;\n\n\tnr_reclaim = dmz_nr_rnd_zones(zrc->metadata, zrc->dev_idx);\n\n\tif (dmz_nr_cache_zones(zrc->metadata)) {\n\t\t \n\t\tif (zrc->dev_idx == 0)\n\t\t\treturn false;\n\t\tnr_reclaim += dmz_nr_cache_zones(zrc->metadata);\n\t}\n\n\t \n\tif (dmz_target_idle(zrc) && nr_reclaim)\n\t\treturn true;\n\n\t \n\tif (p_unmap >= DMZ_RECLAIM_HIGH_UNMAP_ZONES)\n\t\treturn false;\n\n\t \n\treturn p_unmap <= DMZ_RECLAIM_LOW_UNMAP_ZONES;\n}\n\n \nstatic void dmz_reclaim_work(struct work_struct *work)\n{\n\tstruct dmz_reclaim *zrc = container_of(work, struct dmz_reclaim, work.work);\n\tstruct dmz_metadata *zmd = zrc->metadata;\n\tunsigned int p_unmap;\n\tint ret;\n\n\tif (dmz_dev_is_dying(zmd))\n\t\treturn;\n\n\tp_unmap = dmz_reclaim_percentage(zrc);\n\tif (!dmz_should_reclaim(zrc, p_unmap)) {\n\t\tmod_delayed_work(zrc->wq, &zrc->work, DMZ_IDLE_PERIOD);\n\t\treturn;\n\t}\n\n\t \n\tif (dmz_target_idle(zrc) || p_unmap < DMZ_RECLAIM_LOW_UNMAP_ZONES / 2) {\n\t\t \n\t\tzrc->kc_throttle.throttle = 100;\n\t} else {\n\t\t \n\t\tzrc->kc_throttle.throttle = min(75U, 100U - p_unmap / 2);\n\t}\n\n\tDMDEBUG(\"(%s/%u): Reclaim (%u): %s, %u%% free zones (%u/%u cache %u/%u random)\",\n\t\tdmz_metadata_label(zmd), zrc->dev_idx,\n\t\tzrc->kc_throttle.throttle,\n\t\t(dmz_target_idle(zrc) ? \"Idle\" : \"Busy\"),\n\t\tp_unmap, dmz_nr_unmap_cache_zones(zmd),\n\t\tdmz_nr_cache_zones(zmd),\n\t\tdmz_nr_unmap_rnd_zones(zmd, zrc->dev_idx),\n\t\tdmz_nr_rnd_zones(zmd, zrc->dev_idx));\n\n\tret = dmz_do_reclaim(zrc);\n\tif (ret && ret != -EINTR) {\n\t\tif (!dmz_check_dev(zmd))\n\t\t\treturn;\n\t}\n\n\tdmz_schedule_reclaim(zrc);\n}\n\n \nint dmz_ctr_reclaim(struct dmz_metadata *zmd,\n\t\t    struct dmz_reclaim **reclaim, int idx)\n{\n\tstruct dmz_reclaim *zrc;\n\tint ret;\n\n\tzrc = kzalloc(sizeof(struct dmz_reclaim), GFP_KERNEL);\n\tif (!zrc)\n\t\treturn -ENOMEM;\n\n\tzrc->metadata = zmd;\n\tzrc->atime = jiffies;\n\tzrc->dev_idx = idx;\n\n\t \n\tzrc->kc = dm_kcopyd_client_create(&zrc->kc_throttle);\n\tif (IS_ERR(zrc->kc)) {\n\t\tret = PTR_ERR(zrc->kc);\n\t\tzrc->kc = NULL;\n\t\tgoto err;\n\t}\n\n\t \n\tINIT_DELAYED_WORK(&zrc->work, dmz_reclaim_work);\n\tzrc->wq = alloc_ordered_workqueue(\"dmz_rwq_%s_%d\", WQ_MEM_RECLAIM,\n\t\t\t\t\t  dmz_metadata_label(zmd), idx);\n\tif (!zrc->wq) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*reclaim = zrc;\n\tqueue_delayed_work(zrc->wq, &zrc->work, 0);\n\n\treturn 0;\nerr:\n\tif (zrc->kc)\n\t\tdm_kcopyd_client_destroy(zrc->kc);\n\tkfree(zrc);\n\n\treturn ret;\n}\n\n \nvoid dmz_dtr_reclaim(struct dmz_reclaim *zrc)\n{\n\tcancel_delayed_work_sync(&zrc->work);\n\tdestroy_workqueue(zrc->wq);\n\tdm_kcopyd_client_destroy(zrc->kc);\n\tkfree(zrc);\n}\n\n \nvoid dmz_suspend_reclaim(struct dmz_reclaim *zrc)\n{\n\tcancel_delayed_work_sync(&zrc->work);\n}\n\n \nvoid dmz_resume_reclaim(struct dmz_reclaim *zrc)\n{\n\tqueue_delayed_work(zrc->wq, &zrc->work, DMZ_IDLE_PERIOD);\n}\n\n \nvoid dmz_reclaim_bio_acc(struct dmz_reclaim *zrc)\n{\n\tzrc->atime = jiffies;\n}\n\n \nvoid dmz_schedule_reclaim(struct dmz_reclaim *zrc)\n{\n\tunsigned int p_unmap = dmz_reclaim_percentage(zrc);\n\n\tif (dmz_should_reclaim(zrc, p_unmap))\n\t\tmod_delayed_work(zrc->wq, &zrc->work, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}