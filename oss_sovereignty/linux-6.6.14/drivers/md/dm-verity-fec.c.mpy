{
  "module_name": "dm-verity-fec.c",
  "hash_id": "4a54058446bde2b4f7dce7212d7fc7d86d84858b9337228145d0b20e16256aa8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/dm-verity-fec.c",
  "human_readable_source": "\n \n\n#include \"dm-verity-fec.h\"\n#include <linux/math64.h>\n\n#define DM_MSG_PREFIX\t\"verity-fec\"\n\n \nbool verity_fec_is_enabled(struct dm_verity *v)\n{\n\treturn v->fec && v->fec->dev;\n}\n\n \nstatic inline struct dm_verity_fec_io *fec_io(struct dm_verity_io *io)\n{\n\treturn (struct dm_verity_fec_io *)\n\t\t((char *)io + io->v->ti->per_io_data_size - sizeof(struct dm_verity_fec_io));\n}\n\n \nstatic inline u64 fec_interleave(struct dm_verity *v, u64 offset)\n{\n\tu32 mod;\n\n\tmod = do_div(offset, v->fec->rsn);\n\treturn offset + mod * (v->fec->rounds << v->data_dev_block_bits);\n}\n\n \nstatic int fec_decode_rs8(struct dm_verity *v, struct dm_verity_fec_io *fio,\n\t\t\t  u8 *data, u8 *fec, int neras)\n{\n\tint i;\n\tuint16_t par[DM_VERITY_FEC_RSM - DM_VERITY_FEC_MIN_RSN];\n\n\tfor (i = 0; i < v->fec->roots; i++)\n\t\tpar[i] = fec[i];\n\n\treturn decode_rs8(fio->rs, data, par, v->fec->rsn, NULL, neras,\n\t\t\t  fio->erasures, 0, NULL);\n}\n\n \nstatic u8 *fec_read_parity(struct dm_verity *v, u64 rsb, int index,\n\t\t\t   unsigned int *offset, struct dm_buffer **buf)\n{\n\tu64 position, block, rem;\n\tu8 *res;\n\n\tposition = (index + rsb) * v->fec->roots;\n\tblock = div64_u64_rem(position, v->fec->io_size, &rem);\n\t*offset = (unsigned int)rem;\n\n\tres = dm_bufio_read(v->fec->bufio, block, buf);\n\tif (IS_ERR(res)) {\n\t\tDMERR(\"%s: FEC %llu: parity read failed (block %llu): %ld\",\n\t\t      v->data_dev->name, (unsigned long long)rsb,\n\t\t      (unsigned long long)block, PTR_ERR(res));\n\t\t*buf = NULL;\n\t}\n\n\treturn res;\n}\n\n \n#define fec_for_each_prealloc_buffer(__i) \\\n\tfor (__i = 0; __i < DM_VERITY_FEC_BUF_PREALLOC; __i++)\n\n \n#define fec_for_each_extra_buffer(io, __i) \\\n\tfor (__i = DM_VERITY_FEC_BUF_PREALLOC; __i < DM_VERITY_FEC_BUF_MAX; __i++)\n\n \n#define fec_for_each_buffer(io, __i) \\\n\tfor (__i = 0; __i < (io)->nbufs; __i++)\n\n \n#define fec_for_each_buffer_rs_block(io, __i, __j) \\\n\tfec_for_each_buffer(io, __i) \\\n\t\tfor (__j = 0; __j < 1 << DM_VERITY_FEC_BUF_RS_BITS; __j++)\n\n \nstatic inline u8 *fec_buffer_rs_block(struct dm_verity *v,\n\t\t\t\t      struct dm_verity_fec_io *fio,\n\t\t\t\t      unsigned int i, unsigned int j)\n{\n\treturn &fio->bufs[i][j * v->fec->rsn];\n}\n\n \nstatic inline unsigned int fec_buffer_rs_index(unsigned int i, unsigned int j)\n{\n\treturn (i << DM_VERITY_FEC_BUF_RS_BITS) + j;\n}\n\n \nstatic int fec_decode_bufs(struct dm_verity *v, struct dm_verity_fec_io *fio,\n\t\t\t   u64 rsb, int byte_index, unsigned int block_offset,\n\t\t\t   int neras)\n{\n\tint r, corrected = 0, res;\n\tstruct dm_buffer *buf;\n\tunsigned int n, i, offset;\n\tu8 *par, *block;\n\n\tpar = fec_read_parity(v, rsb, block_offset, &offset, &buf);\n\tif (IS_ERR(par))\n\t\treturn PTR_ERR(par);\n\n\t \n\tfec_for_each_buffer_rs_block(fio, n, i) {\n\t\tblock = fec_buffer_rs_block(v, fio, n, i);\n\t\tres = fec_decode_rs8(v, fio, block, &par[offset], neras);\n\t\tif (res < 0) {\n\t\t\tr = res;\n\t\t\tgoto error;\n\t\t}\n\n\t\tcorrected += res;\n\t\tfio->output[block_offset] = block[byte_index];\n\n\t\tblock_offset++;\n\t\tif (block_offset >= 1 << v->data_dev_block_bits)\n\t\t\tgoto done;\n\n\t\t \n\t\toffset += v->fec->roots;\n\t\tif (offset >= v->fec->io_size) {\n\t\t\tdm_bufio_release(buf);\n\n\t\t\tpar = fec_read_parity(v, rsb, block_offset, &offset, &buf);\n\t\t\tif (IS_ERR(par))\n\t\t\t\treturn PTR_ERR(par);\n\t\t}\n\t}\ndone:\n\tr = corrected;\nerror:\n\tdm_bufio_release(buf);\n\n\tif (r < 0 && neras)\n\t\tDMERR_LIMIT(\"%s: FEC %llu: failed to correct: %d\",\n\t\t\t    v->data_dev->name, (unsigned long long)rsb, r);\n\telse if (r > 0)\n\t\tDMWARN_LIMIT(\"%s: FEC %llu: corrected %d errors\",\n\t\t\t     v->data_dev->name, (unsigned long long)rsb, r);\n\n\treturn r;\n}\n\n \nstatic int fec_is_erasure(struct dm_verity *v, struct dm_verity_io *io,\n\t\t\t  u8 *want_digest, u8 *data)\n{\n\tif (unlikely(verity_hash(v, verity_io_hash_req(v, io),\n\t\t\t\t data, 1 << v->data_dev_block_bits,\n\t\t\t\t verity_io_real_digest(v, io), true)))\n\t\treturn 0;\n\n\treturn memcmp(verity_io_real_digest(v, io), want_digest,\n\t\t      v->digest_size) != 0;\n}\n\n \nstatic int fec_read_bufs(struct dm_verity *v, struct dm_verity_io *io,\n\t\t\t u64 rsb, u64 target, unsigned int block_offset,\n\t\t\t int *neras)\n{\n\tbool is_zero;\n\tint i, j, target_index = -1;\n\tstruct dm_buffer *buf;\n\tstruct dm_bufio_client *bufio;\n\tstruct dm_verity_fec_io *fio = fec_io(io);\n\tu64 block, ileaved;\n\tu8 *bbuf, *rs_block;\n\tu8 want_digest[HASH_MAX_DIGESTSIZE];\n\tunsigned int n, k;\n\n\tif (neras)\n\t\t*neras = 0;\n\n\tif (WARN_ON(v->digest_size > sizeof(want_digest)))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < v->fec->rsn; i++) {\n\t\tileaved = fec_interleave(v, rsb * v->fec->rsn + i);\n\n\t\t \n\t\tif (ileaved == target)\n\t\t\ttarget_index = i;\n\n\t\tblock = ileaved >> v->data_dev_block_bits;\n\t\tbufio = v->fec->data_bufio;\n\n\t\tif (block >= v->data_blocks) {\n\t\t\tblock -= v->data_blocks;\n\n\t\t\t \n\t\t\tif (unlikely(block >= v->fec->hash_blocks))\n\t\t\t\tcontinue;\n\n\t\t\tblock += v->hash_start;\n\t\t\tbufio = v->bufio;\n\t\t}\n\n\t\tbbuf = dm_bufio_read(bufio, block, &buf);\n\t\tif (IS_ERR(bbuf)) {\n\t\t\tDMWARN_LIMIT(\"%s: FEC %llu: read failed (%llu): %ld\",\n\t\t\t\t     v->data_dev->name,\n\t\t\t\t     (unsigned long long)rsb,\n\t\t\t\t     (unsigned long long)block, PTR_ERR(bbuf));\n\n\t\t\t \n\t\t\tif (neras && *neras <= v->fec->roots)\n\t\t\t\tfio->erasures[(*neras)++] = i;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (bufio == v->fec->data_bufio &&\n\t\t    verity_hash_for_block(v, io, block, want_digest,\n\t\t\t\t\t  &is_zero) == 0) {\n\t\t\t \n\t\t\tif (is_zero)\n\t\t\t\tgoto done;\n\n\t\t\t \n\t\t\tif (neras && *neras <= v->fec->roots &&\n\t\t\t    fec_is_erasure(v, io, want_digest, bbuf))\n\t\t\t\tfio->erasures[(*neras)++] = i;\n\t\t}\n\n\t\t \n\t\tfec_for_each_buffer_rs_block(fio, n, j) {\n\t\t\tk = fec_buffer_rs_index(n, j) + block_offset;\n\n\t\t\tif (k >= 1 << v->data_dev_block_bits)\n\t\t\t\tgoto done;\n\n\t\t\trs_block = fec_buffer_rs_block(v, fio, n, j);\n\t\t\trs_block[i] = bbuf[k];\n\t\t}\ndone:\n\t\tdm_bufio_release(buf);\n\t}\n\n\treturn target_index;\n}\n\n \nstatic int fec_alloc_bufs(struct dm_verity *v, struct dm_verity_fec_io *fio)\n{\n\tunsigned int n;\n\n\tif (!fio->rs)\n\t\tfio->rs = mempool_alloc(&v->fec->rs_pool, GFP_NOIO);\n\n\tfec_for_each_prealloc_buffer(n) {\n\t\tif (fio->bufs[n])\n\t\t\tcontinue;\n\n\t\tfio->bufs[n] = mempool_alloc(&v->fec->prealloc_pool, GFP_NOWAIT);\n\t\tif (unlikely(!fio->bufs[n])) {\n\t\t\tDMERR(\"failed to allocate FEC buffer\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tfec_for_each_extra_buffer(fio, n) {\n\t\tif (fio->bufs[n])\n\t\t\tcontinue;\n\n\t\tfio->bufs[n] = mempool_alloc(&v->fec->extra_pool, GFP_NOWAIT);\n\t\t \n\t\tif (unlikely(!fio->bufs[n]))\n\t\t\tbreak;\n\t}\n\tfio->nbufs = n;\n\n\tif (!fio->output)\n\t\tfio->output = mempool_alloc(&v->fec->output_pool, GFP_NOIO);\n\n\treturn 0;\n}\n\n \nstatic void fec_init_bufs(struct dm_verity *v, struct dm_verity_fec_io *fio)\n{\n\tunsigned int n;\n\n\tfec_for_each_buffer(fio, n)\n\t\tmemset(fio->bufs[n], 0, v->fec->rsn << DM_VERITY_FEC_BUF_RS_BITS);\n\n\tmemset(fio->erasures, 0, sizeof(fio->erasures));\n}\n\n \nstatic int fec_decode_rsb(struct dm_verity *v, struct dm_verity_io *io,\n\t\t\t  struct dm_verity_fec_io *fio, u64 rsb, u64 offset,\n\t\t\t  bool use_erasures)\n{\n\tint r, neras = 0;\n\tunsigned int pos;\n\n\tr = fec_alloc_bufs(v, fio);\n\tif (unlikely(r < 0))\n\t\treturn r;\n\n\tfor (pos = 0; pos < 1 << v->data_dev_block_bits; ) {\n\t\tfec_init_bufs(v, fio);\n\n\t\tr = fec_read_bufs(v, io, rsb, offset, pos,\n\t\t\t\t  use_erasures ? &neras : NULL);\n\t\tif (unlikely(r < 0))\n\t\t\treturn r;\n\n\t\tr = fec_decode_bufs(v, fio, rsb, r, pos, neras);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tpos += fio->nbufs << DM_VERITY_FEC_BUF_RS_BITS;\n\t}\n\n\t \n\tr = verity_hash(v, verity_io_hash_req(v, io), fio->output,\n\t\t\t1 << v->data_dev_block_bits,\n\t\t\tverity_io_real_digest(v, io), true);\n\tif (unlikely(r < 0))\n\t\treturn r;\n\n\tif (memcmp(verity_io_real_digest(v, io), verity_io_want_digest(v, io),\n\t\t   v->digest_size)) {\n\t\tDMERR_LIMIT(\"%s: FEC %llu: failed to correct (%d erasures)\",\n\t\t\t    v->data_dev->name, (unsigned long long)rsb, neras);\n\t\treturn -EILSEQ;\n\t}\n\n\treturn 0;\n}\n\nstatic int fec_bv_copy(struct dm_verity *v, struct dm_verity_io *io, u8 *data,\n\t\t       size_t len)\n{\n\tstruct dm_verity_fec_io *fio = fec_io(io);\n\n\tmemcpy(data, &fio->output[fio->output_pos], len);\n\tfio->output_pos += len;\n\n\treturn 0;\n}\n\n \nint verity_fec_decode(struct dm_verity *v, struct dm_verity_io *io,\n\t\t      enum verity_block_type type, sector_t block, u8 *dest,\n\t\t      struct bvec_iter *iter)\n{\n\tint r;\n\tstruct dm_verity_fec_io *fio = fec_io(io);\n\tu64 offset, res, rsb;\n\n\tif (!verity_fec_is_enabled(v))\n\t\treturn -EOPNOTSUPP;\n\n\tif (fio->level >= DM_VERITY_FEC_MAX_RECURSION) {\n\t\tDMWARN_LIMIT(\"%s: FEC: recursion too deep\", v->data_dev->name);\n\t\treturn -EIO;\n\t}\n\n\tfio->level++;\n\n\tif (type == DM_VERITY_BLOCK_TYPE_METADATA)\n\t\tblock = block - v->hash_start + v->data_blocks;\n\n\t \n\n\toffset = block << v->data_dev_block_bits;\n\tres = div64_u64(offset, v->fec->rounds << v->data_dev_block_bits);\n\n\t \n\trsb = offset - res * (v->fec->rounds << v->data_dev_block_bits);\n\n\t \n\tr = fec_decode_rsb(v, io, fio, rsb, offset, false);\n\tif (r < 0) {\n\t\tr = fec_decode_rsb(v, io, fio, rsb, offset, true);\n\t\tif (r < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (dest)\n\t\tmemcpy(dest, fio->output, 1 << v->data_dev_block_bits);\n\telse if (iter) {\n\t\tfio->output_pos = 0;\n\t\tr = verity_for_bv_block(v, io, iter, fec_bv_copy);\n\t}\n\ndone:\n\tfio->level--;\n\treturn r;\n}\n\n \nvoid verity_fec_finish_io(struct dm_verity_io *io)\n{\n\tunsigned int n;\n\tstruct dm_verity_fec *f = io->v->fec;\n\tstruct dm_verity_fec_io *fio = fec_io(io);\n\n\tif (!verity_fec_is_enabled(io->v))\n\t\treturn;\n\n\tmempool_free(fio->rs, &f->rs_pool);\n\n\tfec_for_each_prealloc_buffer(n)\n\t\tmempool_free(fio->bufs[n], &f->prealloc_pool);\n\n\tfec_for_each_extra_buffer(fio, n)\n\t\tmempool_free(fio->bufs[n], &f->extra_pool);\n\n\tmempool_free(fio->output, &f->output_pool);\n}\n\n \nvoid verity_fec_init_io(struct dm_verity_io *io)\n{\n\tstruct dm_verity_fec_io *fio = fec_io(io);\n\n\tif (!verity_fec_is_enabled(io->v))\n\t\treturn;\n\n\tfio->rs = NULL;\n\tmemset(fio->bufs, 0, sizeof(fio->bufs));\n\tfio->nbufs = 0;\n\tfio->output = NULL;\n\tfio->level = 0;\n}\n\n \nunsigned int verity_fec_status_table(struct dm_verity *v, unsigned int sz,\n\t\t\t\t char *result, unsigned int maxlen)\n{\n\tif (!verity_fec_is_enabled(v))\n\t\treturn sz;\n\n\tDMEMIT(\" \" DM_VERITY_OPT_FEC_DEV \" %s \"\n\t       DM_VERITY_OPT_FEC_BLOCKS \" %llu \"\n\t       DM_VERITY_OPT_FEC_START \" %llu \"\n\t       DM_VERITY_OPT_FEC_ROOTS \" %d\",\n\t       v->fec->dev->name,\n\t       (unsigned long long)v->fec->blocks,\n\t       (unsigned long long)v->fec->start,\n\t       v->fec->roots);\n\n\treturn sz;\n}\n\nvoid verity_fec_dtr(struct dm_verity *v)\n{\n\tstruct dm_verity_fec *f = v->fec;\n\n\tif (!verity_fec_is_enabled(v))\n\t\tgoto out;\n\n\tmempool_exit(&f->rs_pool);\n\tmempool_exit(&f->prealloc_pool);\n\tmempool_exit(&f->extra_pool);\n\tmempool_exit(&f->output_pool);\n\tkmem_cache_destroy(f->cache);\n\n\tif (f->data_bufio)\n\t\tdm_bufio_client_destroy(f->data_bufio);\n\tif (f->bufio)\n\t\tdm_bufio_client_destroy(f->bufio);\n\n\tif (f->dev)\n\t\tdm_put_device(v->ti, f->dev);\nout:\n\tkfree(f);\n\tv->fec = NULL;\n}\n\nstatic void *fec_rs_alloc(gfp_t gfp_mask, void *pool_data)\n{\n\tstruct dm_verity *v = pool_data;\n\n\treturn init_rs_gfp(8, 0x11d, 0, 1, v->fec->roots, gfp_mask);\n}\n\nstatic void fec_rs_free(void *element, void *pool_data)\n{\n\tstruct rs_control *rs = element;\n\n\tif (rs)\n\t\tfree_rs(rs);\n}\n\nbool verity_is_fec_opt_arg(const char *arg_name)\n{\n\treturn (!strcasecmp(arg_name, DM_VERITY_OPT_FEC_DEV) ||\n\t\t!strcasecmp(arg_name, DM_VERITY_OPT_FEC_BLOCKS) ||\n\t\t!strcasecmp(arg_name, DM_VERITY_OPT_FEC_START) ||\n\t\t!strcasecmp(arg_name, DM_VERITY_OPT_FEC_ROOTS));\n}\n\nint verity_fec_parse_opt_args(struct dm_arg_set *as, struct dm_verity *v,\n\t\t\t      unsigned int *argc, const char *arg_name)\n{\n\tint r;\n\tstruct dm_target *ti = v->ti;\n\tconst char *arg_value;\n\tunsigned long long num_ll;\n\tunsigned char num_c;\n\tchar dummy;\n\n\tif (!*argc) {\n\t\tti->error = \"FEC feature arguments require a value\";\n\t\treturn -EINVAL;\n\t}\n\n\targ_value = dm_shift_arg(as);\n\t(*argc)--;\n\n\tif (!strcasecmp(arg_name, DM_VERITY_OPT_FEC_DEV)) {\n\t\tr = dm_get_device(ti, arg_value, BLK_OPEN_READ, &v->fec->dev);\n\t\tif (r) {\n\t\t\tti->error = \"FEC device lookup failed\";\n\t\t\treturn r;\n\t\t}\n\n\t} else if (!strcasecmp(arg_name, DM_VERITY_OPT_FEC_BLOCKS)) {\n\t\tif (sscanf(arg_value, \"%llu%c\", &num_ll, &dummy) != 1 ||\n\t\t    ((sector_t)(num_ll << (v->data_dev_block_bits - SECTOR_SHIFT))\n\t\t     >> (v->data_dev_block_bits - SECTOR_SHIFT) != num_ll)) {\n\t\t\tti->error = \"Invalid \" DM_VERITY_OPT_FEC_BLOCKS;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tv->fec->blocks = num_ll;\n\n\t} else if (!strcasecmp(arg_name, DM_VERITY_OPT_FEC_START)) {\n\t\tif (sscanf(arg_value, \"%llu%c\", &num_ll, &dummy) != 1 ||\n\t\t    ((sector_t)(num_ll << (v->data_dev_block_bits - SECTOR_SHIFT)) >>\n\t\t     (v->data_dev_block_bits - SECTOR_SHIFT) != num_ll)) {\n\t\t\tti->error = \"Invalid \" DM_VERITY_OPT_FEC_START;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tv->fec->start = num_ll;\n\n\t} else if (!strcasecmp(arg_name, DM_VERITY_OPT_FEC_ROOTS)) {\n\t\tif (sscanf(arg_value, \"%hhu%c\", &num_c, &dummy) != 1 || !num_c ||\n\t\t    num_c < (DM_VERITY_FEC_RSM - DM_VERITY_FEC_MAX_RSN) ||\n\t\t    num_c > (DM_VERITY_FEC_RSM - DM_VERITY_FEC_MIN_RSN)) {\n\t\t\tti->error = \"Invalid \" DM_VERITY_OPT_FEC_ROOTS;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tv->fec->roots = num_c;\n\n\t} else {\n\t\tti->error = \"Unrecognized verity FEC feature request\";\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint verity_fec_ctr_alloc(struct dm_verity *v)\n{\n\tstruct dm_verity_fec *f;\n\n\tf = kzalloc(sizeof(struct dm_verity_fec), GFP_KERNEL);\n\tif (!f) {\n\t\tv->ti->error = \"Cannot allocate FEC structure\";\n\t\treturn -ENOMEM;\n\t}\n\tv->fec = f;\n\n\treturn 0;\n}\n\n \nint verity_fec_ctr(struct dm_verity *v)\n{\n\tstruct dm_verity_fec *f = v->fec;\n\tstruct dm_target *ti = v->ti;\n\tu64 hash_blocks, fec_blocks;\n\tint ret;\n\n\tif (!verity_fec_is_enabled(v)) {\n\t\tverity_fec_dtr(v);\n\t\treturn 0;\n\t}\n\n\t \n\n\thash_blocks = v->hash_blocks - v->hash_start;\n\n\t \n\tif (v->data_dev_block_bits != v->hash_dev_block_bits) {\n\t\tti->error = \"Block sizes must match to use FEC\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (!f->roots) {\n\t\tti->error = \"Missing \" DM_VERITY_OPT_FEC_ROOTS;\n\t\treturn -EINVAL;\n\t}\n\tf->rsn = DM_VERITY_FEC_RSM - f->roots;\n\n\tif (!f->blocks) {\n\t\tti->error = \"Missing \" DM_VERITY_OPT_FEC_BLOCKS;\n\t\treturn -EINVAL;\n\t}\n\n\tf->rounds = f->blocks;\n\tif (sector_div(f->rounds, f->rsn))\n\t\tf->rounds++;\n\n\t \n\tif (f->blocks < v->data_blocks + hash_blocks || !f->rounds) {\n\t\tti->error = \"Invalid \" DM_VERITY_OPT_FEC_BLOCKS;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tf->hash_blocks = f->blocks - v->data_blocks;\n\tif (dm_bufio_get_device_size(v->bufio) < f->hash_blocks) {\n\t\tti->error = \"Hash device is too small for \"\n\t\t\tDM_VERITY_OPT_FEC_BLOCKS;\n\t\treturn -E2BIG;\n\t}\n\n\tif ((f->roots << SECTOR_SHIFT) & ((1 << v->data_dev_block_bits) - 1))\n\t\tf->io_size = 1 << v->data_dev_block_bits;\n\telse\n\t\tf->io_size = v->fec->roots << SECTOR_SHIFT;\n\n\tf->bufio = dm_bufio_client_create(f->dev->bdev,\n\t\t\t\t\t  f->io_size,\n\t\t\t\t\t  1, 0, NULL, NULL, 0);\n\tif (IS_ERR(f->bufio)) {\n\t\tti->error = \"Cannot initialize FEC bufio client\";\n\t\treturn PTR_ERR(f->bufio);\n\t}\n\n\tdm_bufio_set_sector_offset(f->bufio, f->start << (v->data_dev_block_bits - SECTOR_SHIFT));\n\n\tfec_blocks = div64_u64(f->rounds * f->roots, v->fec->roots << SECTOR_SHIFT);\n\tif (dm_bufio_get_device_size(f->bufio) < fec_blocks) {\n\t\tti->error = \"FEC device is too small\";\n\t\treturn -E2BIG;\n\t}\n\n\tf->data_bufio = dm_bufio_client_create(v->data_dev->bdev,\n\t\t\t\t\t       1 << v->data_dev_block_bits,\n\t\t\t\t\t       1, 0, NULL, NULL, 0);\n\tif (IS_ERR(f->data_bufio)) {\n\t\tti->error = \"Cannot initialize FEC data bufio client\";\n\t\treturn PTR_ERR(f->data_bufio);\n\t}\n\n\tif (dm_bufio_get_device_size(f->data_bufio) < v->data_blocks) {\n\t\tti->error = \"Data device is too small\";\n\t\treturn -E2BIG;\n\t}\n\n\t \n\tret = mempool_init(&f->rs_pool, num_online_cpus(), fec_rs_alloc,\n\t\t\t   fec_rs_free, (void *) v);\n\tif (ret) {\n\t\tti->error = \"Cannot allocate RS pool\";\n\t\treturn ret;\n\t}\n\n\tf->cache = kmem_cache_create(\"dm_verity_fec_buffers\",\n\t\t\t\t     f->rsn << DM_VERITY_FEC_BUF_RS_BITS,\n\t\t\t\t     0, 0, NULL);\n\tif (!f->cache) {\n\t\tti->error = \"Cannot create FEC buffer cache\";\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = mempool_init_slab_pool(&f->prealloc_pool, num_online_cpus() *\n\t\t\t\t     DM_VERITY_FEC_BUF_PREALLOC,\n\t\t\t\t     f->cache);\n\tif (ret) {\n\t\tti->error = \"Cannot allocate FEC buffer prealloc pool\";\n\t\treturn ret;\n\t}\n\n\tret = mempool_init_slab_pool(&f->extra_pool, 0, f->cache);\n\tif (ret) {\n\t\tti->error = \"Cannot allocate FEC buffer extra pool\";\n\t\treturn ret;\n\t}\n\n\t \n\tret = mempool_init_kmalloc_pool(&f->output_pool, num_online_cpus(),\n\t\t\t\t\t1 << v->data_dev_block_bits);\n\tif (ret) {\n\t\tti->error = \"Cannot allocate FEC output pool\";\n\t\treturn ret;\n\t}\n\n\t \n\tti->per_io_data_size += sizeof(struct dm_verity_fec_io);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}