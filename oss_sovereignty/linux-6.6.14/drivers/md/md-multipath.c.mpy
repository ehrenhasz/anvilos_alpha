{
  "module_name": "md-multipath.c",
  "hash_id": "38f3d62871e4e0953e53891ac4754b91e881e937bbfb82bae14b1877089cb468",
  "original_prompt": "Ingested from linux-6.6.14/drivers/md/md-multipath.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/raid/md_u.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include \"md.h\"\n#include \"md-multipath.h\"\n\n#define MAX_WORK_PER_DISK 128\n\n#define\tNR_RESERVED_BUFS\t32\n\nstatic int multipath_map (struct mpconf *conf)\n{\n\tint i, disks = conf->raid_disks;\n\n\t \n\n\trcu_read_lock();\n\tfor (i = 0; i < disks; i++) {\n\t\tstruct md_rdev *rdev = rcu_dereference(conf->multipaths[i].rdev);\n\t\tif (rdev && test_bit(In_sync, &rdev->flags) &&\n\t\t    !test_bit(Faulty, &rdev->flags)) {\n\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t\trcu_read_unlock();\n\t\t\treturn i;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tpr_crit_ratelimited(\"multipath_map(): no more operational IO paths?\\n\");\n\treturn (-1);\n}\n\nstatic void multipath_reschedule_retry (struct multipath_bh *mp_bh)\n{\n\tunsigned long flags;\n\tstruct mddev *mddev = mp_bh->mddev;\n\tstruct mpconf *conf = mddev->private;\n\n\tspin_lock_irqsave(&conf->device_lock, flags);\n\tlist_add(&mp_bh->retry_list, &conf->retry_list);\n\tspin_unlock_irqrestore(&conf->device_lock, flags);\n\tmd_wakeup_thread(mddev->thread);\n}\n\n \nstatic void multipath_end_bh_io(struct multipath_bh *mp_bh, blk_status_t status)\n{\n\tstruct bio *bio = mp_bh->master_bio;\n\tstruct mpconf *conf = mp_bh->mddev->private;\n\n\tbio->bi_status = status;\n\tbio_endio(bio);\n\tmempool_free(mp_bh, &conf->pool);\n}\n\nstatic void multipath_end_request(struct bio *bio)\n{\n\tstruct multipath_bh *mp_bh = bio->bi_private;\n\tstruct mpconf *conf = mp_bh->mddev->private;\n\tstruct md_rdev *rdev = conf->multipaths[mp_bh->path].rdev;\n\n\tif (!bio->bi_status)\n\t\tmultipath_end_bh_io(mp_bh, 0);\n\telse if (!(bio->bi_opf & REQ_RAHEAD)) {\n\t\t \n\t\tmd_error (mp_bh->mddev, rdev);\n\t\tpr_info(\"multipath: %pg: rescheduling sector %llu\\n\",\n\t\t\trdev->bdev,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tmultipath_reschedule_retry(mp_bh);\n\t} else\n\t\tmultipath_end_bh_io(mp_bh, bio->bi_status);\n\trdev_dec_pending(rdev, conf->mddev);\n}\n\nstatic bool multipath_make_request(struct mddev *mddev, struct bio * bio)\n{\n\tstruct mpconf *conf = mddev->private;\n\tstruct multipath_bh * mp_bh;\n\tstruct multipath_info *multipath;\n\n\tif (unlikely(bio->bi_opf & REQ_PREFLUSH)\n\t    && md_flush_request(mddev, bio))\n\t\treturn true;\n\n\tmd_account_bio(mddev, &bio);\n\tmp_bh = mempool_alloc(&conf->pool, GFP_NOIO);\n\n\tmp_bh->master_bio = bio;\n\tmp_bh->mddev = mddev;\n\n\tmp_bh->path = multipath_map(conf);\n\tif (mp_bh->path < 0) {\n\t\tbio_io_error(bio);\n\t\tmempool_free(mp_bh, &conf->pool);\n\t\treturn true;\n\t}\n\tmultipath = conf->multipaths + mp_bh->path;\n\n\tbio_init_clone(multipath->rdev->bdev, &mp_bh->bio, bio, GFP_NOIO);\n\n\tmp_bh->bio.bi_iter.bi_sector += multipath->rdev->data_offset;\n\tmp_bh->bio.bi_opf |= REQ_FAILFAST_TRANSPORT;\n\tmp_bh->bio.bi_end_io = multipath_end_request;\n\tmp_bh->bio.bi_private = mp_bh;\n\tmddev_check_write_zeroes(mddev, &mp_bh->bio);\n\tsubmit_bio_noacct(&mp_bh->bio);\n\treturn true;\n}\n\nstatic void multipath_status(struct seq_file *seq, struct mddev *mddev)\n{\n\tstruct mpconf *conf = mddev->private;\n\tint i;\n\n\tseq_printf (seq, \" [%d/%d] [\", conf->raid_disks,\n\t\t    conf->raid_disks - mddev->degraded);\n\trcu_read_lock();\n\tfor (i = 0; i < conf->raid_disks; i++) {\n\t\tstruct md_rdev *rdev = rcu_dereference(conf->multipaths[i].rdev);\n\t\tseq_printf (seq, \"%s\", rdev && test_bit(In_sync, &rdev->flags) ? \"U\" : \"_\");\n\t}\n\trcu_read_unlock();\n\tseq_putc(seq, ']');\n}\n\n \nstatic void multipath_error (struct mddev *mddev, struct md_rdev *rdev)\n{\n\tstruct mpconf *conf = mddev->private;\n\n\tif (conf->raid_disks - mddev->degraded <= 1) {\n\t\t \n\t\tpr_warn(\"multipath: only one IO path left and IO error.\\n\");\n\t\t \n\t\treturn;\n\t}\n\t \n\tif (test_and_clear_bit(In_sync, &rdev->flags)) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&conf->device_lock, flags);\n\t\tmddev->degraded++;\n\t\tspin_unlock_irqrestore(&conf->device_lock, flags);\n\t}\n\tset_bit(Faulty, &rdev->flags);\n\tset_bit(MD_SB_CHANGE_DEVS, &mddev->sb_flags);\n\tpr_err(\"multipath: IO failure on %pg, disabling IO path.\\n\"\n\t       \"multipath: Operation continuing on %d IO paths.\\n\",\n\t       rdev->bdev,\n\t       conf->raid_disks - mddev->degraded);\n}\n\nstatic void print_multipath_conf (struct mpconf *conf)\n{\n\tint i;\n\tstruct multipath_info *tmp;\n\n\tpr_debug(\"MULTIPATH conf printout:\\n\");\n\tif (!conf) {\n\t\tpr_debug(\"(conf==NULL)\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\" --- wd:%d rd:%d\\n\", conf->raid_disks - conf->mddev->degraded,\n\t\t conf->raid_disks);\n\n\tfor (i = 0; i < conf->raid_disks; i++) {\n\t\ttmp = conf->multipaths + i;\n\t\tif (tmp->rdev)\n\t\t\tpr_debug(\" disk%d, o:%d, dev:%pg\\n\",\n\t\t\t\t i,!test_bit(Faulty, &tmp->rdev->flags),\n\t\t\t\t tmp->rdev->bdev);\n\t}\n}\n\nstatic int multipath_add_disk(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tstruct mpconf *conf = mddev->private;\n\tint err = -EEXIST;\n\tint path;\n\tstruct multipath_info *p;\n\tint first = 0;\n\tint last = mddev->raid_disks - 1;\n\n\tif (rdev->raid_disk >= 0)\n\t\tfirst = last = rdev->raid_disk;\n\n\tprint_multipath_conf(conf);\n\n\tfor (path = first; path <= last; path++)\n\t\tif ((p=conf->multipaths+path)->rdev == NULL) {\n\t\t\tdisk_stack_limits(mddev->gendisk, rdev->bdev,\n\t\t\t\t\t  rdev->data_offset << 9);\n\n\t\t\terr = md_integrity_add_rdev(rdev, mddev);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tspin_lock_irq(&conf->device_lock);\n\t\t\tmddev->degraded--;\n\t\t\trdev->raid_disk = path;\n\t\t\tset_bit(In_sync, &rdev->flags);\n\t\t\tspin_unlock_irq(&conf->device_lock);\n\t\t\trcu_assign_pointer(p->rdev, rdev);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\tprint_multipath_conf(conf);\n\n\treturn err;\n}\n\nstatic int multipath_remove_disk(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tstruct mpconf *conf = mddev->private;\n\tint err = 0;\n\tint number = rdev->raid_disk;\n\tstruct multipath_info *p = conf->multipaths + number;\n\n\tprint_multipath_conf(conf);\n\n\tif (rdev == p->rdev) {\n\t\tif (test_bit(In_sync, &rdev->flags) ||\n\t\t    atomic_read(&rdev->nr_pending)) {\n\t\t\tpr_warn(\"hot-remove-disk, slot %d is identified but is still operational!\\n\", number);\n\t\t\terr = -EBUSY;\n\t\t\tgoto abort;\n\t\t}\n\t\tp->rdev = NULL;\n\t\tif (!test_bit(RemoveSynchronized, &rdev->flags)) {\n\t\t\tsynchronize_rcu();\n\t\t\tif (atomic_read(&rdev->nr_pending)) {\n\t\t\t\t \n\t\t\t\terr = -EBUSY;\n\t\t\t\tp->rdev = rdev;\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\t\terr = md_integrity_register(mddev);\n\t}\nabort:\n\n\tprint_multipath_conf(conf);\n\treturn err;\n}\n\n \n\nstatic void multipathd(struct md_thread *thread)\n{\n\tstruct mddev *mddev = thread->mddev;\n\tstruct multipath_bh *mp_bh;\n\tstruct bio *bio;\n\tunsigned long flags;\n\tstruct mpconf *conf = mddev->private;\n\tstruct list_head *head = &conf->retry_list;\n\n\tmd_check_recovery(mddev);\n\tfor (;;) {\n\t\tspin_lock_irqsave(&conf->device_lock, flags);\n\t\tif (list_empty(head))\n\t\t\tbreak;\n\t\tmp_bh = list_entry(head->prev, struct multipath_bh, retry_list);\n\t\tlist_del(head->prev);\n\t\tspin_unlock_irqrestore(&conf->device_lock, flags);\n\n\t\tbio = &mp_bh->bio;\n\t\tbio->bi_iter.bi_sector = mp_bh->master_bio->bi_iter.bi_sector;\n\n\t\tif ((mp_bh->path = multipath_map (conf))<0) {\n\t\t\tpr_err(\"multipath: %pg: unrecoverable IO read error for block %llu\\n\",\n\t\t\t       bio->bi_bdev,\n\t\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\t\tmultipath_end_bh_io(mp_bh, BLK_STS_IOERR);\n\t\t} else {\n\t\t\tpr_err(\"multipath: %pg: redirecting sector %llu to another IO path\\n\",\n\t\t\t       bio->bi_bdev,\n\t\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\t\t*bio = *(mp_bh->master_bio);\n\t\t\tbio->bi_iter.bi_sector +=\n\t\t\t\tconf->multipaths[mp_bh->path].rdev->data_offset;\n\t\t\tbio_set_dev(bio, conf->multipaths[mp_bh->path].rdev->bdev);\n\t\t\tbio->bi_opf |= REQ_FAILFAST_TRANSPORT;\n\t\t\tbio->bi_end_io = multipath_end_request;\n\t\t\tbio->bi_private = mp_bh;\n\t\t\tsubmit_bio_noacct(bio);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&conf->device_lock, flags);\n}\n\nstatic sector_t multipath_size(struct mddev *mddev, sector_t sectors, int raid_disks)\n{\n\tWARN_ONCE(sectors || raid_disks,\n\t\t  \"%s does not support generic reshape\\n\", __func__);\n\n\treturn mddev->dev_sectors;\n}\n\nstatic int multipath_run (struct mddev *mddev)\n{\n\tstruct mpconf *conf;\n\tint disk_idx;\n\tstruct multipath_info *disk;\n\tstruct md_rdev *rdev;\n\tint working_disks;\n\tint ret;\n\n\tif (md_check_no_bitmap(mddev))\n\t\treturn -EINVAL;\n\n\tif (mddev->level != LEVEL_MULTIPATH) {\n\t\tpr_warn(\"multipath: %s: raid level not set to multipath IO (%d)\\n\",\n\t\t\tmdname(mddev), mddev->level);\n\t\tgoto out;\n\t}\n\t \n\n\tconf = kzalloc(sizeof(struct mpconf), GFP_KERNEL);\n\tmddev->private = conf;\n\tif (!conf)\n\t\tgoto out;\n\n\tconf->multipaths = kcalloc(mddev->raid_disks,\n\t\t\t\t   sizeof(struct multipath_info),\n\t\t\t\t   GFP_KERNEL);\n\tif (!conf->multipaths)\n\t\tgoto out_free_conf;\n\n\tworking_disks = 0;\n\trdev_for_each(rdev, mddev) {\n\t\tdisk_idx = rdev->raid_disk;\n\t\tif (disk_idx < 0 ||\n\t\t    disk_idx >= mddev->raid_disks)\n\t\t\tcontinue;\n\n\t\tdisk = conf->multipaths + disk_idx;\n\t\tdisk->rdev = rdev;\n\t\tdisk_stack_limits(mddev->gendisk, rdev->bdev,\n\t\t\t\t  rdev->data_offset << 9);\n\n\t\tif (!test_bit(Faulty, &rdev->flags))\n\t\t\tworking_disks++;\n\t}\n\n\tconf->raid_disks = mddev->raid_disks;\n\tconf->mddev = mddev;\n\tspin_lock_init(&conf->device_lock);\n\tINIT_LIST_HEAD(&conf->retry_list);\n\n\tif (!working_disks) {\n\t\tpr_warn(\"multipath: no operational IO paths for %s\\n\",\n\t\t\tmdname(mddev));\n\t\tgoto out_free_conf;\n\t}\n\tmddev->degraded = conf->raid_disks - working_disks;\n\n\tret = mempool_init_kmalloc_pool(&conf->pool, NR_RESERVED_BUFS,\n\t\t\t\t\tsizeof(struct multipath_bh));\n\tif (ret)\n\t\tgoto out_free_conf;\n\n\trcu_assign_pointer(mddev->thread,\n\t\t\t   md_register_thread(multipathd, mddev, \"multipath\"));\n\tif (!mddev->thread)\n\t\tgoto out_free_conf;\n\n\tpr_info(\"multipath: array %s active with %d out of %d IO paths\\n\",\n\t\tmdname(mddev), conf->raid_disks - mddev->degraded,\n\t\tmddev->raid_disks);\n\t \n\tmd_set_array_sectors(mddev, multipath_size(mddev, 0, 0));\n\n\tif (md_integrity_register(mddev))\n\t\tgoto out_free_conf;\n\n\treturn 0;\n\nout_free_conf:\n\tmempool_exit(&conf->pool);\n\tkfree(conf->multipaths);\n\tkfree(conf);\n\tmddev->private = NULL;\nout:\n\treturn -EIO;\n}\n\nstatic void multipath_free(struct mddev *mddev, void *priv)\n{\n\tstruct mpconf *conf = priv;\n\n\tmempool_exit(&conf->pool);\n\tkfree(conf->multipaths);\n\tkfree(conf);\n}\n\nstatic struct md_personality multipath_personality =\n{\n\t.name\t\t= \"multipath\",\n\t.level\t\t= LEVEL_MULTIPATH,\n\t.owner\t\t= THIS_MODULE,\n\t.make_request\t= multipath_make_request,\n\t.run\t\t= multipath_run,\n\t.free\t\t= multipath_free,\n\t.status\t\t= multipath_status,\n\t.error_handler\t= multipath_error,\n\t.hot_add_disk\t= multipath_add_disk,\n\t.hot_remove_disk= multipath_remove_disk,\n\t.size\t\t= multipath_size,\n};\n\nstatic int __init multipath_init (void)\n{\n\treturn register_md_personality (&multipath_personality);\n}\n\nstatic void __exit multipath_exit (void)\n{\n\tunregister_md_personality (&multipath_personality);\n}\n\nmodule_init(multipath_init);\nmodule_exit(multipath_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"simple multi-path personality for MD (deprecated)\");\nMODULE_ALIAS(\"md-personality-7\");  \nMODULE_ALIAS(\"md-multipath\");\nMODULE_ALIAS(\"md-level--4\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}