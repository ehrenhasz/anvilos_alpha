{
  "module_name": "dimmtemp.c",
  "hash_id": "af2703cc040bdbdbf3daaed9a72b593cd77232b0cd0d79716d2345fb08ed47c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/peci/dimmtemp.c",
  "human_readable_source": "\n\n\n#include <linux/auxiliary_bus.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/devm-helpers.h>\n#include <linux/hwmon.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/peci.h>\n#include <linux/peci-cpu.h>\n#include <linux/units.h>\n#include <linux/workqueue.h>\n\n#include \"common.h\"\n\n#define DIMM_MASK_CHECK_DELAY_JIFFIES\tmsecs_to_jiffies(5000)\n\n \n#define CHAN_RANK_MAX_ON_HSX\t8\n#define DIMM_IDX_MAX_ON_HSX\t3\n#define CHAN_RANK_MAX_ON_BDX\t4\n#define DIMM_IDX_MAX_ON_BDX\t3\n#define CHAN_RANK_MAX_ON_BDXD\t2\n#define DIMM_IDX_MAX_ON_BDXD\t2\n#define CHAN_RANK_MAX_ON_SKX\t6\n#define DIMM_IDX_MAX_ON_SKX\t2\n#define CHAN_RANK_MAX_ON_ICX\t8\n#define DIMM_IDX_MAX_ON_ICX\t2\n#define CHAN_RANK_MAX_ON_ICXD\t4\n#define DIMM_IDX_MAX_ON_ICXD\t2\n#define CHAN_RANK_MAX_ON_SPR\t8\n#define DIMM_IDX_MAX_ON_SPR\t2\n\n#define CHAN_RANK_MAX\t\tCHAN_RANK_MAX_ON_HSX\n#define DIMM_IDX_MAX\t\tDIMM_IDX_MAX_ON_HSX\n#define DIMM_NUMS_MAX\t\t(CHAN_RANK_MAX * DIMM_IDX_MAX)\n\n#define CPU_SEG_MASK\t\tGENMASK(23, 16)\n#define GET_CPU_SEG(x)\t\t(((x) & CPU_SEG_MASK) >> 16)\n#define CPU_BUS_MASK\t\tGENMASK(7, 0)\n#define GET_CPU_BUS(x)\t\t((x) & CPU_BUS_MASK)\n\n#define DIMM_TEMP_MAX\t\tGENMASK(15, 8)\n#define DIMM_TEMP_CRIT\t\tGENMASK(23, 16)\n#define GET_TEMP_MAX(x)\t\t(((x) & DIMM_TEMP_MAX) >> 8)\n#define GET_TEMP_CRIT(x)\t(((x) & DIMM_TEMP_CRIT) >> 16)\n\n#define NO_DIMM_RETRY_COUNT_MAX\t5\n\nstruct peci_dimmtemp;\n\nstruct dimm_info {\n\tint chan_rank_max;\n\tint dimm_idx_max;\n\tu8 min_peci_revision;\n\tint (*read_thresholds)(struct peci_dimmtemp *priv, int dimm_order,\n\t\t\t       int chan_rank, u32 *data);\n};\n\nstruct peci_dimm_thresholds {\n\tlong temp_max;\n\tlong temp_crit;\n\tstruct peci_sensor_state state;\n};\n\nenum peci_dimm_threshold_type {\n\ttemp_max_type,\n\ttemp_crit_type,\n};\n\nstruct peci_dimmtemp {\n\tstruct peci_device *peci_dev;\n\tstruct device *dev;\n\tconst char *name;\n\tconst struct dimm_info *gen_info;\n\tstruct delayed_work detect_work;\n\tstruct {\n\t\tstruct peci_sensor_data temp;\n\t\tstruct peci_dimm_thresholds thresholds;\n\t} dimm[DIMM_NUMS_MAX];\n\tchar **dimmtemp_label;\n\tDECLARE_BITMAP(dimm_mask, DIMM_NUMS_MAX);\n\tu8 no_dimm_retry_count;\n};\n\nstatic u8 __dimm_temp(u32 reg, int dimm_order)\n{\n\treturn (reg >> (dimm_order * 8)) & 0xff;\n}\n\nstatic int get_dimm_temp(struct peci_dimmtemp *priv, int dimm_no, long *val)\n{\n\tint dimm_order = dimm_no % priv->gen_info->dimm_idx_max;\n\tint chan_rank = dimm_no / priv->gen_info->dimm_idx_max;\n\tint ret = 0;\n\tu32 data;\n\n\tmutex_lock(&priv->dimm[dimm_no].temp.state.lock);\n\tif (!peci_sensor_need_update(&priv->dimm[dimm_no].temp.state))\n\t\tgoto skip_update;\n\n\tret = peci_pcs_read(priv->peci_dev, PECI_PCS_DDR_DIMM_TEMP, chan_rank, &data);\n\tif (ret)\n\t\tgoto unlock;\n\n\tpriv->dimm[dimm_no].temp.value = __dimm_temp(data, dimm_order) * MILLIDEGREE_PER_DEGREE;\n\n\tpeci_sensor_mark_updated(&priv->dimm[dimm_no].temp.state);\n\nskip_update:\n\t*val = priv->dimm[dimm_no].temp.value;\nunlock:\n\tmutex_unlock(&priv->dimm[dimm_no].temp.state.lock);\n\treturn ret;\n}\n\nstatic int update_thresholds(struct peci_dimmtemp *priv, int dimm_no)\n{\n\tint dimm_order = dimm_no % priv->gen_info->dimm_idx_max;\n\tint chan_rank = dimm_no / priv->gen_info->dimm_idx_max;\n\tu32 data;\n\tint ret;\n\n\tif (!peci_sensor_need_update(&priv->dimm[dimm_no].thresholds.state))\n\t\treturn 0;\n\n\tret = priv->gen_info->read_thresholds(priv, dimm_order, chan_rank, &data);\n\tif (ret == -ENODATA)  \n\t\treturn 0;\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->dimm[dimm_no].thresholds.temp_max = GET_TEMP_MAX(data) * MILLIDEGREE_PER_DEGREE;\n\tpriv->dimm[dimm_no].thresholds.temp_crit = GET_TEMP_CRIT(data) * MILLIDEGREE_PER_DEGREE;\n\n\tpeci_sensor_mark_updated(&priv->dimm[dimm_no].thresholds.state);\n\n\treturn 0;\n}\n\nstatic int get_dimm_thresholds(struct peci_dimmtemp *priv, enum peci_dimm_threshold_type type,\n\t\t\t       int dimm_no, long *val)\n{\n\tint ret;\n\n\tmutex_lock(&priv->dimm[dimm_no].thresholds.state.lock);\n\tret = update_thresholds(priv, dimm_no);\n\tif (ret)\n\t\tgoto unlock;\n\n\tswitch (type) {\n\tcase temp_max_type:\n\t\t*val = priv->dimm[dimm_no].thresholds.temp_max;\n\t\tbreak;\n\tcase temp_crit_type:\n\t\t*val = priv->dimm[dimm_no].thresholds.temp_crit;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\nunlock:\n\tmutex_unlock(&priv->dimm[dimm_no].thresholds.state.lock);\n\n\treturn ret;\n}\n\nstatic int dimmtemp_read_string(struct device *dev,\n\t\t\t\tenum hwmon_sensor_types type,\n\t\t\t\tu32 attr, int channel, const char **str)\n{\n\tstruct peci_dimmtemp *priv = dev_get_drvdata(dev);\n\n\tif (attr != hwmon_temp_label)\n\t\treturn -EOPNOTSUPP;\n\n\t*str = (const char *)priv->dimmtemp_label[channel];\n\n\treturn 0;\n}\n\nstatic int dimmtemp_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long *val)\n{\n\tstruct peci_dimmtemp *priv = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treturn get_dimm_temp(priv, channel, val);\n\tcase hwmon_temp_max:\n\t\treturn get_dimm_thresholds(priv, temp_max_type, channel, val);\n\tcase hwmon_temp_crit:\n\t\treturn get_dimm_thresholds(priv, temp_crit_type, channel, val);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic umode_t dimmtemp_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t   u32 attr, int channel)\n{\n\tconst struct peci_dimmtemp *priv = data;\n\n\tif (test_bit(channel, priv->dimm_mask))\n\t\treturn 0444;\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops peci_dimmtemp_ops = {\n\t.is_visible = dimmtemp_is_visible,\n\t.read_string = dimmtemp_read_string,\n\t.read = dimmtemp_read,\n};\n\nstatic int check_populated_dimms(struct peci_dimmtemp *priv)\n{\n\tint chan_rank_max = priv->gen_info->chan_rank_max;\n\tint dimm_idx_max = priv->gen_info->dimm_idx_max;\n\tDECLARE_BITMAP(dimm_mask, DIMM_NUMS_MAX);\n\tDECLARE_BITMAP(chan_rank_empty, CHAN_RANK_MAX);\n\n\tint chan_rank, dimm_idx, ret, i;\n\tu32 pcs;\n\n\tif (chan_rank_max * dimm_idx_max > DIMM_NUMS_MAX) {\n\t\tWARN_ONCE(1, \"Unsupported number of DIMMs - chan_rank_max: %d, dimm_idx_max: %d\",\n\t\t\t  chan_rank_max, dimm_idx_max);\n\t\treturn -EINVAL;\n\t}\n\n\tbitmap_zero(dimm_mask, DIMM_NUMS_MAX);\n\tbitmap_zero(chan_rank_empty, CHAN_RANK_MAX);\n\n\tfor (chan_rank = 0; chan_rank < chan_rank_max; chan_rank++) {\n\t\tret = peci_pcs_read(priv->peci_dev, PECI_PCS_DDR_DIMM_TEMP, chan_rank, &pcs);\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (ret == -EINVAL) {\n\t\t\t\tbitmap_set(chan_rank_empty, chan_rank, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tfor (dimm_idx = 0; dimm_idx < dimm_idx_max; dimm_idx++)\n\t\t\tif (__dimm_temp(pcs, dimm_idx))\n\t\t\t\tbitmap_set(dimm_mask, chan_rank * dimm_idx_max + dimm_idx, 1);\n\t}\n\n\t \n\tif (bitmap_full(chan_rank_empty, chan_rank_max)) {\n\t\tif (priv->no_dimm_retry_count < NO_DIMM_RETRY_COUNT_MAX) {\n\t\t\tpriv->no_dimm_retry_count++;\n\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (bitmap_empty(dimm_mask, DIMM_NUMS_MAX)) {\n\t\tpriv->no_dimm_retry_count = 0;\n\t\treturn -EAGAIN;\n\t}\n\n\tfor_each_set_bit(i, dimm_mask, DIMM_NUMS_MAX) {\n\t\tdev_dbg(priv->dev, \"Found DIMM%#x\\n\", i);\n\t}\n\n\tbitmap_copy(priv->dimm_mask, dimm_mask, DIMM_NUMS_MAX);\n\n\treturn 0;\n}\n\nstatic int create_dimm_temp_label(struct peci_dimmtemp *priv, int chan)\n{\n\tint rank = chan / priv->gen_info->dimm_idx_max;\n\tint idx = chan % priv->gen_info->dimm_idx_max;\n\n\tpriv->dimmtemp_label[chan] = devm_kasprintf(priv->dev, GFP_KERNEL,\n\t\t\t\t\t\t    \"DIMM %c%d\", 'A' + rank,\n\t\t\t\t\t\t    idx + 1);\n\tif (!priv->dimmtemp_label[chan])\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const peci_dimmtemp_temp_info[] = {\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   [0 ... DIMM_NUMS_MAX - 1] = HWMON_T_LABEL |\n\t\t\t\tHWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info peci_dimmtemp_chip_info = {\n\t.ops = &peci_dimmtemp_ops,\n\t.info = peci_dimmtemp_temp_info,\n};\n\nstatic int create_dimm_temp_info(struct peci_dimmtemp *priv)\n{\n\tint ret, i, channels;\n\tstruct device *dev;\n\n\t \n\tret = check_populated_dimms(priv);\n\tif (ret == -ENODEV) {\n\t\tdev_dbg(priv->dev, \"No DIMMs found\\n\");\n\t\treturn 0;\n\t} else if (ret) {\n\t\tschedule_delayed_work(&priv->detect_work, DIMM_MASK_CHECK_DELAY_JIFFIES);\n\t\tdev_dbg(priv->dev, \"Deferred populating DIMM temp info\\n\");\n\t\treturn ret;\n\t}\n\n\tchannels = priv->gen_info->chan_rank_max * priv->gen_info->dimm_idx_max;\n\n\tpriv->dimmtemp_label = devm_kzalloc(priv->dev, channels * sizeof(char *), GFP_KERNEL);\n\tif (!priv->dimmtemp_label)\n\t\treturn -ENOMEM;\n\n\tfor_each_set_bit(i, priv->dimm_mask, DIMM_NUMS_MAX) {\n\t\tret = create_dimm_temp_label(priv, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmutex_init(&priv->dimm[i].thresholds.state.lock);\n\t\tmutex_init(&priv->dimm[i].temp.state.lock);\n\t}\n\n\tdev = devm_hwmon_device_register_with_info(priv->dev, priv->name, priv,\n\t\t\t\t\t\t   &peci_dimmtemp_chip_info, NULL);\n\tif (IS_ERR(dev)) {\n\t\tdev_err(priv->dev, \"Failed to register hwmon device\\n\");\n\t\treturn PTR_ERR(dev);\n\t}\n\n\tdev_dbg(priv->dev, \"%s: sensor '%s'\\n\", dev_name(dev), priv->name);\n\n\treturn 0;\n}\n\nstatic void create_dimm_temp_info_delayed(struct work_struct *work)\n{\n\tstruct peci_dimmtemp *priv = container_of(to_delayed_work(work),\n\t\t\t\t\t\t  struct peci_dimmtemp,\n\t\t\t\t\t\t  detect_work);\n\tint ret;\n\n\tret = create_dimm_temp_info(priv);\n\tif (ret && ret != -EAGAIN)\n\t\tdev_err(priv->dev, \"Failed to populate DIMM temp info\\n\");\n}\n\nstatic int peci_dimmtemp_probe(struct auxiliary_device *adev, const struct auxiliary_device_id *id)\n{\n\tstruct device *dev = &adev->dev;\n\tstruct peci_device *peci_dev = to_peci_device(dev->parent);\n\tstruct peci_dimmtemp *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->name = devm_kasprintf(dev, GFP_KERNEL, \"peci_dimmtemp.cpu%d\",\n\t\t\t\t    peci_dev->info.socket_id);\n\tif (!priv->name)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->peci_dev = peci_dev;\n\tpriv->gen_info = (const struct dimm_info *)id->driver_data;\n\n\t \n\tif (peci_dev->info.peci_revision < priv->gen_info->min_peci_revision)\n\t\tdev_warn(priv->dev,\n\t\t\t \"Unexpected PECI revision %#x, some features may be unavailable\\n\",\n\t\t\t peci_dev->info.peci_revision);\n\n\tret = devm_delayed_work_autocancel(priv->dev, &priv->detect_work,\n\t\t\t\t\t   create_dimm_temp_info_delayed);\n\tif (ret)\n\t\treturn ret;\n\n\tret = create_dimm_temp_info(priv);\n\tif (ret && ret != -EAGAIN) {\n\t\tdev_err(dev, \"Failed to populate DIMM temp info\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nread_thresholds_hsx(struct peci_dimmtemp *priv, int dimm_order, int chan_rank, u32 *data)\n{\n\tu8 dev, func;\n\tu16 reg;\n\tint ret;\n\n\t \n\tdev = 20 + chan_rank / 2 + chan_rank / 4;\n\tfunc = chan_rank % 2;\n\treg = 0x120 + dimm_order * 4;\n\n\tret = peci_pci_local_read(priv->peci_dev, 1, dev, func, reg, data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nread_thresholds_bdxd(struct peci_dimmtemp *priv, int dimm_order, int chan_rank, u32 *data)\n{\n\tu8 dev, func;\n\tu16 reg;\n\tint ret;\n\n\t \n\tdev = 10 + chan_rank / 2 * 2;\n\tfunc = (chan_rank % 2) ? 6 : 2;\n\treg = 0x120 + dimm_order * 4;\n\n\tret = peci_pci_local_read(priv->peci_dev, 2, dev, func, reg, data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nread_thresholds_skx(struct peci_dimmtemp *priv, int dimm_order, int chan_rank, u32 *data)\n{\n\tu8 dev, func;\n\tu16 reg;\n\tint ret;\n\n\t \n\tdev = 10 + chan_rank / 3 * 2 + (chan_rank % 3 == 2 ? 1 : 0);\n\tfunc = chan_rank % 3 == 1 ? 6 : 2;\n\treg = 0x120 + dimm_order * 4;\n\n\tret = peci_pci_local_read(priv->peci_dev, 2, dev, func, reg, data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nread_thresholds_icx(struct peci_dimmtemp *priv, int dimm_order, int chan_rank, u32 *data)\n{\n\tu32 reg_val;\n\tu64 offset;\n\tint ret;\n\tu8 dev;\n\n\tret = peci_ep_pci_local_read(priv->peci_dev, 0, 13, 0, 2, 0xd4, &reg_val);\n\tif (ret || !(reg_val & BIT(31)))\n\t\treturn -ENODATA;  \n\n\tret = peci_ep_pci_local_read(priv->peci_dev, 0, 13, 0, 2, 0xd0, &reg_val);\n\tif (ret)\n\t\treturn -ENODATA;  \n\n\t \n\tdev = 26 + chan_rank / 2;\n\toffset = 0x224e0 + dimm_order * 4 + (chan_rank % 2) * 0x4000;\n\n\tret = peci_mmio_read(priv->peci_dev, 0, GET_CPU_SEG(reg_val), GET_CPU_BUS(reg_val),\n\t\t\t     dev, 0, offset, data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nread_thresholds_spr(struct peci_dimmtemp *priv, int dimm_order, int chan_rank, u32 *data)\n{\n\tu32 reg_val;\n\tu64 offset;\n\tint ret;\n\tu8 dev;\n\n\tret = peci_ep_pci_local_read(priv->peci_dev, 0, 30, 0, 2, 0xd4, &reg_val);\n\tif (ret || !(reg_val & BIT(31)))\n\t\treturn -ENODATA;  \n\n\tret = peci_ep_pci_local_read(priv->peci_dev, 0, 30, 0, 2, 0xd0, &reg_val);\n\tif (ret)\n\t\treturn -ENODATA;  \n\n\t \n\tdev = 26 + chan_rank / 2;\n\toffset = 0x219a8 + dimm_order * 4 + (chan_rank % 2) * 0x8000;\n\n\tret = peci_mmio_read(priv->peci_dev, 0, GET_CPU_SEG(reg_val), GET_CPU_BUS(reg_val),\n\t\t\t     dev, 0, offset, data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct dimm_info dimm_hsx = {\n\t.chan_rank_max\t= CHAN_RANK_MAX_ON_HSX,\n\t.dimm_idx_max\t= DIMM_IDX_MAX_ON_HSX,\n\t.min_peci_revision = 0x33,\n\t.read_thresholds = &read_thresholds_hsx,\n};\n\nstatic const struct dimm_info dimm_bdx = {\n\t.chan_rank_max\t= CHAN_RANK_MAX_ON_BDX,\n\t.dimm_idx_max\t= DIMM_IDX_MAX_ON_BDX,\n\t.min_peci_revision = 0x33,\n\t.read_thresholds = &read_thresholds_hsx,\n};\n\nstatic const struct dimm_info dimm_bdxd = {\n\t.chan_rank_max\t= CHAN_RANK_MAX_ON_BDXD,\n\t.dimm_idx_max\t= DIMM_IDX_MAX_ON_BDXD,\n\t.min_peci_revision = 0x33,\n\t.read_thresholds = &read_thresholds_bdxd,\n};\n\nstatic const struct dimm_info dimm_skx = {\n\t.chan_rank_max\t= CHAN_RANK_MAX_ON_SKX,\n\t.dimm_idx_max\t= DIMM_IDX_MAX_ON_SKX,\n\t.min_peci_revision = 0x33,\n\t.read_thresholds = &read_thresholds_skx,\n};\n\nstatic const struct dimm_info dimm_icx = {\n\t.chan_rank_max\t= CHAN_RANK_MAX_ON_ICX,\n\t.dimm_idx_max\t= DIMM_IDX_MAX_ON_ICX,\n\t.min_peci_revision = 0x40,\n\t.read_thresholds = &read_thresholds_icx,\n};\n\nstatic const struct dimm_info dimm_icxd = {\n\t.chan_rank_max\t= CHAN_RANK_MAX_ON_ICXD,\n\t.dimm_idx_max\t= DIMM_IDX_MAX_ON_ICXD,\n\t.min_peci_revision = 0x40,\n\t.read_thresholds = &read_thresholds_icx,\n};\n\nstatic const struct dimm_info dimm_spr = {\n\t.chan_rank_max\t= CHAN_RANK_MAX_ON_SPR,\n\t.dimm_idx_max\t= DIMM_IDX_MAX_ON_SPR,\n\t.min_peci_revision = 0x40,\n\t.read_thresholds = &read_thresholds_spr,\n};\n\nstatic const struct auxiliary_device_id peci_dimmtemp_ids[] = {\n\t{\n\t\t.name = \"peci_cpu.dimmtemp.hsx\",\n\t\t.driver_data = (kernel_ulong_t)&dimm_hsx,\n\t},\n\t{\n\t\t.name = \"peci_cpu.dimmtemp.bdx\",\n\t\t.driver_data = (kernel_ulong_t)&dimm_bdx,\n\t},\n\t{\n\t\t.name = \"peci_cpu.dimmtemp.bdxd\",\n\t\t.driver_data = (kernel_ulong_t)&dimm_bdxd,\n\t},\n\t{\n\t\t.name = \"peci_cpu.dimmtemp.skx\",\n\t\t.driver_data = (kernel_ulong_t)&dimm_skx,\n\t},\n\t{\n\t\t.name = \"peci_cpu.dimmtemp.icx\",\n\t\t.driver_data = (kernel_ulong_t)&dimm_icx,\n\t},\n\t{\n\t\t.name = \"peci_cpu.dimmtemp.icxd\",\n\t\t.driver_data = (kernel_ulong_t)&dimm_icxd,\n\t},\n\t{\n\t\t.name = \"peci_cpu.dimmtemp.spr\",\n\t\t.driver_data = (kernel_ulong_t)&dimm_spr,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(auxiliary, peci_dimmtemp_ids);\n\nstatic struct auxiliary_driver peci_dimmtemp_driver = {\n\t.probe\t\t= peci_dimmtemp_probe,\n\t.id_table\t= peci_dimmtemp_ids,\n};\n\nmodule_auxiliary_driver(peci_dimmtemp_driver);\n\nMODULE_AUTHOR(\"Jae Hyun Yoo <jae.hyun.yoo@linux.intel.com>\");\nMODULE_AUTHOR(\"Iwona Winiarska <iwona.winiarska@intel.com>\");\nMODULE_DESCRIPTION(\"PECI dimmtemp driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PECI_CPU);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}