{
  "module_name": "cputemp.c",
  "hash_id": "4629dac30b26cf992e0a03c90c4fb6830fc3bcf1ef01e8e06b05ee201ecc5a27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/peci/cputemp.c",
  "human_readable_source": "\n\n\n#include <linux/auxiliary_bus.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/hwmon.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/peci.h>\n#include <linux/peci-cpu.h>\n#include <linux/units.h>\n\n#include \"common.h\"\n\n#define CORE_NUMS_MAX\t\t64\n\n#define BASE_CHANNEL_NUMS\t5\n#define CPUTEMP_CHANNEL_NUMS\t(BASE_CHANNEL_NUMS + CORE_NUMS_MAX)\n\n#define TEMP_TARGET_FAN_TEMP_MASK\tGENMASK(15, 8)\n#define TEMP_TARGET_REF_TEMP_MASK\tGENMASK(23, 16)\n#define TEMP_TARGET_TJ_OFFSET_MASK\tGENMASK(29, 24)\n\n#define DTS_MARGIN_MASK\t\tGENMASK(15, 0)\n#define PCS_MODULE_TEMP_MASK\tGENMASK(15, 0)\n\nstruct resolved_cores_reg {\n\tu8 bus;\n\tu8 dev;\n\tu8 func;\n\tu8 offset;\n};\n\nstruct cpu_info {\n\tstruct resolved_cores_reg *reg;\n\tu8 min_peci_revision;\n\ts32 (*thermal_margin_to_millidegree)(u16 val);\n};\n\nstruct peci_temp_target {\n\ts32 tcontrol;\n\ts32 tthrottle;\n\ts32 tjmax;\n\tstruct peci_sensor_state state;\n};\n\nenum peci_temp_target_type {\n\ttcontrol_type,\n\ttthrottle_type,\n\ttjmax_type,\n\tcrit_hyst_type,\n};\n\nstruct peci_cputemp {\n\tstruct peci_device *peci_dev;\n\tstruct device *dev;\n\tconst char *name;\n\tconst struct cpu_info *gen_info;\n\tstruct {\n\t\tstruct peci_temp_target target;\n\t\tstruct peci_sensor_data die;\n\t\tstruct peci_sensor_data dts;\n\t\tstruct peci_sensor_data core[CORE_NUMS_MAX];\n\t} temp;\n\tconst char **coretemp_label;\n\tDECLARE_BITMAP(core_mask, CORE_NUMS_MAX);\n};\n\nenum cputemp_channels {\n\tchannel_die,\n\tchannel_dts,\n\tchannel_tcontrol,\n\tchannel_tthrottle,\n\tchannel_tjmax,\n\tchannel_core,\n};\n\nstatic const char * const cputemp_label[BASE_CHANNEL_NUMS] = {\n\t\"Die\",\n\t\"DTS\",\n\t\"Tcontrol\",\n\t\"Tthrottle\",\n\t\"Tjmax\",\n};\n\nstatic int update_temp_target(struct peci_cputemp *priv)\n{\n\ts32 tthrottle_offset, tcontrol_margin;\n\tu32 pcs;\n\tint ret;\n\n\tif (!peci_sensor_need_update(&priv->temp.target.state))\n\t\treturn 0;\n\n\tret = peci_pcs_read(priv->peci_dev, PECI_PCS_TEMP_TARGET, 0, &pcs);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->temp.target.tjmax =\n\t\tFIELD_GET(TEMP_TARGET_REF_TEMP_MASK, pcs) * MILLIDEGREE_PER_DEGREE;\n\n\ttcontrol_margin = FIELD_GET(TEMP_TARGET_FAN_TEMP_MASK, pcs);\n\ttcontrol_margin = sign_extend32(tcontrol_margin, 7) * MILLIDEGREE_PER_DEGREE;\n\tpriv->temp.target.tcontrol = priv->temp.target.tjmax - tcontrol_margin;\n\n\ttthrottle_offset = FIELD_GET(TEMP_TARGET_TJ_OFFSET_MASK, pcs) * MILLIDEGREE_PER_DEGREE;\n\tpriv->temp.target.tthrottle = priv->temp.target.tjmax - tthrottle_offset;\n\n\tpeci_sensor_mark_updated(&priv->temp.target.state);\n\n\treturn 0;\n}\n\nstatic int get_temp_target(struct peci_cputemp *priv, enum peci_temp_target_type type, long *val)\n{\n\tint ret;\n\n\tmutex_lock(&priv->temp.target.state.lock);\n\n\tret = update_temp_target(priv);\n\tif (ret)\n\t\tgoto unlock;\n\n\tswitch (type) {\n\tcase tcontrol_type:\n\t\t*val = priv->temp.target.tcontrol;\n\t\tbreak;\n\tcase tthrottle_type:\n\t\t*val = priv->temp.target.tthrottle;\n\t\tbreak;\n\tcase tjmax_type:\n\t\t*val = priv->temp.target.tjmax;\n\t\tbreak;\n\tcase crit_hyst_type:\n\t\t*val = priv->temp.target.tjmax - priv->temp.target.tcontrol;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\nunlock:\n\tmutex_unlock(&priv->temp.target.state.lock);\n\n\treturn ret;\n}\n\n \nstatic bool dts_valid(u16 val)\n{\n\treturn val < 0x8000 || val > 0x81ff;\n}\n\n \nstatic s32 dts_ten_dot_six_to_millidegree(u16 val)\n{\n\treturn sign_extend32(val, 15) * MILLIDEGREE_PER_DEGREE / 64;\n}\n\n \nstatic s32 dts_eight_dot_eight_to_millidegree(u16 val)\n{\n\treturn sign_extend32(val, 15) * MILLIDEGREE_PER_DEGREE / 256;\n}\n\nstatic int get_die_temp(struct peci_cputemp *priv, long *val)\n{\n\tint ret = 0;\n\tlong tjmax;\n\tu16 temp;\n\n\tmutex_lock(&priv->temp.die.state.lock);\n\tif (!peci_sensor_need_update(&priv->temp.die.state))\n\t\tgoto skip_update;\n\n\tret = peci_temp_read(priv->peci_dev, &temp);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tif (!dts_valid(temp)) {\n\t\tret = -EIO;\n\t\tgoto err_unlock;\n\t}\n\n\tret = get_temp_target(priv, tjmax_type, &tjmax);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tpriv->temp.die.value = (s32)tjmax + dts_ten_dot_six_to_millidegree(temp);\n\n\tpeci_sensor_mark_updated(&priv->temp.die.state);\n\nskip_update:\n\t*val = priv->temp.die.value;\nerr_unlock:\n\tmutex_unlock(&priv->temp.die.state.lock);\n\treturn ret;\n}\n\nstatic int get_dts(struct peci_cputemp *priv, long *val)\n{\n\tint ret = 0;\n\tu16 thermal_margin;\n\tlong tcontrol;\n\tu32 pcs;\n\n\tmutex_lock(&priv->temp.dts.state.lock);\n\tif (!peci_sensor_need_update(&priv->temp.dts.state))\n\t\tgoto skip_update;\n\n\tret = peci_pcs_read(priv->peci_dev, PECI_PCS_THERMAL_MARGIN, 0, &pcs);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tthermal_margin = FIELD_GET(DTS_MARGIN_MASK, pcs);\n\tif (!dts_valid(thermal_margin)) {\n\t\tret = -EIO;\n\t\tgoto err_unlock;\n\t}\n\n\tret = get_temp_target(priv, tcontrol_type, &tcontrol);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\t \n\tpriv->temp.dts.value =\n\t\t(s32)tcontrol - priv->gen_info->thermal_margin_to_millidegree(thermal_margin);\n\n\tpeci_sensor_mark_updated(&priv->temp.dts.state);\n\nskip_update:\n\t*val = priv->temp.dts.value;\nerr_unlock:\n\tmutex_unlock(&priv->temp.dts.state.lock);\n\treturn ret;\n}\n\nstatic int get_core_temp(struct peci_cputemp *priv, int core_index, long *val)\n{\n\tint ret = 0;\n\tu16 core_dts_margin;\n\tlong tjmax;\n\tu32 pcs;\n\n\tmutex_lock(&priv->temp.core[core_index].state.lock);\n\tif (!peci_sensor_need_update(&priv->temp.core[core_index].state))\n\t\tgoto skip_update;\n\n\tret = peci_pcs_read(priv->peci_dev, PECI_PCS_MODULE_TEMP, core_index, &pcs);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tcore_dts_margin = FIELD_GET(PCS_MODULE_TEMP_MASK, pcs);\n\tif (!dts_valid(core_dts_margin)) {\n\t\tret = -EIO;\n\t\tgoto err_unlock;\n\t}\n\n\tret = get_temp_target(priv, tjmax_type, &tjmax);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\t \n\tpriv->temp.core[core_index].value =\n\t\t(s32)tjmax + dts_ten_dot_six_to_millidegree(core_dts_margin);\n\n\tpeci_sensor_mark_updated(&priv->temp.core[core_index].state);\n\nskip_update:\n\t*val = priv->temp.core[core_index].value;\nerr_unlock:\n\tmutex_unlock(&priv->temp.core[core_index].state.lock);\n\treturn ret;\n}\n\nstatic int cputemp_read_string(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t       u32 attr, int channel, const char **str)\n{\n\tstruct peci_cputemp *priv = dev_get_drvdata(dev);\n\n\tif (attr != hwmon_temp_label)\n\t\treturn -EOPNOTSUPP;\n\n\t*str = channel < channel_core ?\n\t\tcputemp_label[channel] : priv->coretemp_label[channel - channel_core];\n\n\treturn 0;\n}\n\nstatic int cputemp_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct peci_cputemp *priv = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tswitch (channel) {\n\t\tcase channel_die:\n\t\t\treturn get_die_temp(priv, val);\n\t\tcase channel_dts:\n\t\t\treturn get_dts(priv, val);\n\t\tcase channel_tcontrol:\n\t\t\treturn get_temp_target(priv, tcontrol_type, val);\n\t\tcase channel_tthrottle:\n\t\t\treturn get_temp_target(priv, tthrottle_type, val);\n\t\tcase channel_tjmax:\n\t\t\treturn get_temp_target(priv, tjmax_type, val);\n\t\tdefault:\n\t\t\treturn get_core_temp(priv, channel - channel_core, val);\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\treturn get_temp_target(priv, tcontrol_type, val);\n\tcase hwmon_temp_crit:\n\t\treturn get_temp_target(priv, tjmax_type, val);\n\tcase hwmon_temp_crit_hyst:\n\t\treturn get_temp_target(priv, crit_hyst_type, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic umode_t cputemp_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tconst struct peci_cputemp *priv = data;\n\n\tif (channel > CPUTEMP_CHANNEL_NUMS)\n\t\treturn 0;\n\n\tif (channel < channel_core)\n\t\treturn 0444;\n\n\tif (test_bit(channel - channel_core, priv->core_mask))\n\t\treturn 0444;\n\n\treturn 0;\n}\n\nstatic int init_core_mask(struct peci_cputemp *priv)\n{\n\tstruct peci_device *peci_dev = priv->peci_dev;\n\tstruct resolved_cores_reg *reg = priv->gen_info->reg;\n\tu64 core_mask;\n\tu32 data;\n\tint ret;\n\n\t \n\tswitch (peci_dev->info.model) {\n\tcase INTEL_FAM6_ICELAKE_X:\n\tcase INTEL_FAM6_ICELAKE_D:\n\tcase INTEL_FAM6_SAPPHIRERAPIDS_X:\n\t\tret = peci_ep_pci_local_read(peci_dev, 0, reg->bus, reg->dev,\n\t\t\t\t\t     reg->func, reg->offset + 4, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcore_mask = (u64)data << 32;\n\n\t\tret = peci_ep_pci_local_read(peci_dev, 0, reg->bus, reg->dev,\n\t\t\t\t\t     reg->func, reg->offset, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcore_mask |= data;\n\n\t\tbreak;\n\tdefault:\n\t\tret = peci_pci_local_read(peci_dev, reg->bus, reg->dev,\n\t\t\t\t\t  reg->func, reg->offset, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcore_mask = data;\n\n\t\tbreak;\n\t}\n\n\tif (!core_mask)\n\t\treturn -EIO;\n\n\tbitmap_from_u64(priv->core_mask, core_mask);\n\n\treturn 0;\n}\n\nstatic int create_temp_label(struct peci_cputemp *priv)\n{\n\tunsigned long core_max = find_last_bit(priv->core_mask, CORE_NUMS_MAX);\n\tint i;\n\n\tpriv->coretemp_label = devm_kzalloc(priv->dev, (core_max + 1) * sizeof(char *), GFP_KERNEL);\n\tif (!priv->coretemp_label)\n\t\treturn -ENOMEM;\n\n\tfor_each_set_bit(i, priv->core_mask, CORE_NUMS_MAX) {\n\t\tpriv->coretemp_label[i] = devm_kasprintf(priv->dev, GFP_KERNEL, \"Core %d\", i);\n\t\tif (!priv->coretemp_label[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void check_resolved_cores(struct peci_cputemp *priv)\n{\n\t \n\n\tif (init_core_mask(priv))\n\t\treturn;\n\n\tif (create_temp_label(priv))\n\t\tbitmap_zero(priv->core_mask, CORE_NUMS_MAX);\n}\n\nstatic void sensor_init(struct peci_cputemp *priv)\n{\n\tint i;\n\n\tmutex_init(&priv->temp.target.state.lock);\n\tmutex_init(&priv->temp.die.state.lock);\n\tmutex_init(&priv->temp.dts.state.lock);\n\n\tfor_each_set_bit(i, priv->core_mask, CORE_NUMS_MAX)\n\t\tmutex_init(&priv->temp.core[i].state.lock);\n}\n\nstatic const struct hwmon_ops peci_cputemp_ops = {\n\t.is_visible = cputemp_is_visible,\n\t.read_string = cputemp_read_string,\n\t.read = cputemp_read,\n};\n\nstatic const struct hwmon_channel_info * const peci_cputemp_info[] = {\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t    \n\t\t\t   HWMON_T_LABEL | HWMON_T_INPUT | HWMON_T_MAX |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST,\n\t\t\t    \n\t\t\t   HWMON_T_LABEL | HWMON_T_INPUT | HWMON_T_MAX |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST,\n\t\t\t    \n\t\t\t   HWMON_T_LABEL | HWMON_T_INPUT | HWMON_T_CRIT,\n\t\t\t    \n\t\t\t   HWMON_T_LABEL | HWMON_T_INPUT,\n\t\t\t    \n\t\t\t   HWMON_T_LABEL | HWMON_T_INPUT,\n\t\t\t    \n\t\t\t   [channel_core ... CPUTEMP_CHANNEL_NUMS - 1] =\n\t\t\t\t\t\tHWMON_T_LABEL | HWMON_T_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info peci_cputemp_chip_info = {\n\t.ops = &peci_cputemp_ops,\n\t.info = peci_cputemp_info,\n};\n\nstatic int peci_cputemp_probe(struct auxiliary_device *adev,\n\t\t\t      const struct auxiliary_device_id *id)\n{\n\tstruct device *dev = &adev->dev;\n\tstruct peci_device *peci_dev = to_peci_device(dev->parent);\n\tstruct peci_cputemp *priv;\n\tstruct device *hwmon_dev;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->name = devm_kasprintf(dev, GFP_KERNEL, \"peci_cputemp.cpu%d\",\n\t\t\t\t    peci_dev->info.socket_id);\n\tif (!priv->name)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->peci_dev = peci_dev;\n\tpriv->gen_info = (const struct cpu_info *)id->driver_data;\n\n\t \n\tif (peci_dev->info.peci_revision < priv->gen_info->min_peci_revision)\n\t\tdev_warn(priv->dev,\n\t\t\t \"Unexpected PECI revision %#x, some features may be unavailable\\n\",\n\t\t\t peci_dev->info.peci_revision);\n\n\tcheck_resolved_cores(priv);\n\n\tsensor_init(priv);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(priv->dev, priv->name,\n\t\t\t\t\t\t\t priv, &peci_cputemp_chip_info, NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\n \nstatic struct resolved_cores_reg resolved_cores_reg_hsx = {\n\t.bus = 1,\n\t.dev = 30,\n\t.func = 3,\n\t.offset = 0xb4,\n};\n\nstatic struct resolved_cores_reg resolved_cores_reg_icx = {\n\t.bus = 14,\n\t.dev = 30,\n\t.func = 3,\n\t.offset = 0xd0,\n};\n\nstatic struct resolved_cores_reg resolved_cores_reg_spr = {\n\t.bus = 31,\n\t.dev = 30,\n\t.func = 6,\n\t.offset = 0x80,\n};\n\nstatic const struct cpu_info cpu_hsx = {\n\t.reg\t\t= &resolved_cores_reg_hsx,\n\t.min_peci_revision = 0x33,\n\t.thermal_margin_to_millidegree = &dts_eight_dot_eight_to_millidegree,\n};\n\nstatic const struct cpu_info cpu_skx = {\n\t.reg\t\t= &resolved_cores_reg_hsx,\n\t.min_peci_revision = 0x33,\n\t.thermal_margin_to_millidegree = &dts_ten_dot_six_to_millidegree,\n};\n\nstatic const struct cpu_info cpu_icx = {\n\t.reg\t\t= &resolved_cores_reg_icx,\n\t.min_peci_revision = 0x40,\n\t.thermal_margin_to_millidegree = &dts_ten_dot_six_to_millidegree,\n};\n\nstatic const struct cpu_info cpu_spr = {\n\t.reg\t\t= &resolved_cores_reg_spr,\n\t.min_peci_revision = 0x40,\n\t.thermal_margin_to_millidegree = &dts_ten_dot_six_to_millidegree,\n};\n\nstatic const struct auxiliary_device_id peci_cputemp_ids[] = {\n\t{\n\t\t.name = \"peci_cpu.cputemp.hsx\",\n\t\t.driver_data = (kernel_ulong_t)&cpu_hsx,\n\t},\n\t{\n\t\t.name = \"peci_cpu.cputemp.bdx\",\n\t\t.driver_data = (kernel_ulong_t)&cpu_hsx,\n\t},\n\t{\n\t\t.name = \"peci_cpu.cputemp.bdxd\",\n\t\t.driver_data = (kernel_ulong_t)&cpu_hsx,\n\t},\n\t{\n\t\t.name = \"peci_cpu.cputemp.skx\",\n\t\t.driver_data = (kernel_ulong_t)&cpu_skx,\n\t},\n\t{\n\t\t.name = \"peci_cpu.cputemp.icx\",\n\t\t.driver_data = (kernel_ulong_t)&cpu_icx,\n\t},\n\t{\n\t\t.name = \"peci_cpu.cputemp.icxd\",\n\t\t.driver_data = (kernel_ulong_t)&cpu_icx,\n\t},\n\t{\n\t\t.name = \"peci_cpu.cputemp.spr\",\n\t\t.driver_data = (kernel_ulong_t)&cpu_spr,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(auxiliary, peci_cputemp_ids);\n\nstatic struct auxiliary_driver peci_cputemp_driver = {\n\t.probe\t\t= peci_cputemp_probe,\n\t.id_table\t= peci_cputemp_ids,\n};\n\nmodule_auxiliary_driver(peci_cputemp_driver);\n\nMODULE_AUTHOR(\"Jae Hyun Yoo <jae.hyun.yoo@linux.intel.com>\");\nMODULE_AUTHOR(\"Iwona Winiarska <iwona.winiarska@intel.com>\");\nMODULE_DESCRIPTION(\"PECI cputemp driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PECI_CPU);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}