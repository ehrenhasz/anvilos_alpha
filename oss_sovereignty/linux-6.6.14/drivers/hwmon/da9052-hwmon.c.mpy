{
  "module_name": "da9052-hwmon.c",
  "hash_id": "a0fb9f9fd8de06eda20f5b0fa0128571162709caf5233dda7ea4696d6002f133",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/da9052-hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#include <linux/mfd/da9052/da9052.h>\n#include <linux/mfd/da9052/reg.h>\n#include <linux/regulator/consumer.h>\n\nstruct da9052_hwmon {\n\tstruct da9052\t\t*da9052;\n\tstruct mutex\t\thwmon_lock;\n\tbool\t\t\ttsi_as_adc;\n\tint\t\t\ttsiref_mv;\n\tstruct regulator\t*tsiref;\n\tstruct completion\ttsidone;\n};\n\nstatic const char * const input_names[] = {\n\t[DA9052_ADC_VDDOUT]\t=\t\"VDDOUT\",\n\t[DA9052_ADC_ICH]\t=\t\"CHARGING CURRENT\",\n\t[DA9052_ADC_TBAT]\t=\t\"BATTERY TEMP\",\n\t[DA9052_ADC_VBAT]\t=\t\"BATTERY VOLTAGE\",\n\t[DA9052_ADC_IN4]\t=\t\"ADC IN4\",\n\t[DA9052_ADC_IN5]\t=\t\"ADC IN5\",\n\t[DA9052_ADC_IN6]\t=\t\"ADC IN6\",\n\t[DA9052_ADC_TSI_XP]\t=\t\"ADC TS X+\",\n\t[DA9052_ADC_TSI_YP]\t=\t\"ADC TS Y+\",\n\t[DA9052_ADC_TSI_XN]\t=\t\"ADC TS X-\",\n\t[DA9052_ADC_TSI_YN]\t=\t\"ADC TS Y-\",\n\t[DA9052_ADC_TJUNC]\t=\t\"BATTERY JUNCTION TEMP\",\n\t[DA9052_ADC_VBBAT]\t=\t\"BACK-UP BATTERY VOLTAGE\",\n};\n\n \nstatic inline int volt_reg_to_mv(int value)\n{\n\treturn DIV_ROUND_CLOSEST(value * 2000, 1023) + 2500;\n}\n\n \nstatic inline int input_reg_to_mv(int value)\n{\n\treturn DIV_ROUND_CLOSEST(value * 2500, 1023);\n}\n\n \nstatic inline int vbbat_reg_to_mv(int value)\n{\n\treturn DIV_ROUND_CLOSEST(value * 5000, 1023);\n}\n\nstatic inline int input_tsireg_to_mv(struct da9052_hwmon *hwmon, int value)\n{\n\treturn DIV_ROUND_CLOSEST(value * hwmon->tsiref_mv, 1023);\n}\n\nstatic inline int da9052_enable_vddout_channel(struct da9052 *da9052)\n{\n\treturn da9052_reg_update(da9052, DA9052_ADC_CONT_REG,\n\t\t\t\t DA9052_ADCCONT_AUTOVDDEN,\n\t\t\t\t DA9052_ADCCONT_AUTOVDDEN);\n}\n\nstatic inline int da9052_disable_vddout_channel(struct da9052 *da9052)\n{\n\treturn da9052_reg_update(da9052, DA9052_ADC_CONT_REG,\n\t\t\t\t DA9052_ADCCONT_AUTOVDDEN, 0);\n}\n\nstatic ssize_t da9052_vddout_show(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\tstruct da9052_hwmon *hwmon = dev_get_drvdata(dev);\n\tint ret, vdd;\n\n\tmutex_lock(&hwmon->hwmon_lock);\n\n\tret = da9052_enable_vddout_channel(hwmon->da9052);\n\tif (ret < 0)\n\t\tgoto hwmon_err;\n\n\tvdd = da9052_reg_read(hwmon->da9052, DA9052_VDD_RES_REG);\n\tif (vdd < 0) {\n\t\tret = vdd;\n\t\tgoto hwmon_err_release;\n\t}\n\n\tret = da9052_disable_vddout_channel(hwmon->da9052);\n\tif (ret < 0)\n\t\tgoto hwmon_err;\n\n\tmutex_unlock(&hwmon->hwmon_lock);\n\treturn sprintf(buf, \"%d\\n\", volt_reg_to_mv(vdd));\n\nhwmon_err_release:\n\tda9052_disable_vddout_channel(hwmon->da9052);\nhwmon_err:\n\tmutex_unlock(&hwmon->hwmon_lock);\n\treturn ret;\n}\n\nstatic ssize_t da9052_ich_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tstruct da9052_hwmon *hwmon = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = da9052_reg_read(hwmon->da9052, DA9052_ICHG_AV_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn sprintf(buf, \"%d\\n\", DIV_ROUND_CLOSEST(ret * 39, 10));\n}\n\nstatic ssize_t da9052_tbat_show(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct da9052_hwmon *hwmon = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", da9052_adc_read_temp(hwmon->da9052));\n}\n\nstatic ssize_t da9052_vbat_show(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct da9052_hwmon *hwmon = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = da9052_adc_manual_read(hwmon->da9052, DA9052_ADC_VBAT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", volt_reg_to_mv(ret));\n}\n\nstatic ssize_t da9052_misc_channel_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct da9052_hwmon *hwmon = dev_get_drvdata(dev);\n\tint channel = to_sensor_dev_attr(devattr)->index;\n\tint ret;\n\n\tret = da9052_adc_manual_read(hwmon->da9052, channel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", input_reg_to_mv(ret));\n}\n\nstatic int da9052_request_tsi_read(struct da9052_hwmon *hwmon, int channel)\n{\n\tu8 val = DA9052_TSICONTB_TSIMAN;\n\n\tswitch (channel) {\n\tcase DA9052_ADC_TSI_XP:\n\t\tval |= DA9052_TSICONTB_TSIMUX_XP;\n\t\tbreak;\n\tcase DA9052_ADC_TSI_YP:\n\t\tval |= DA9052_TSICONTB_TSIMUX_YP;\n\t\tbreak;\n\tcase DA9052_ADC_TSI_XN:\n\t\tval |= DA9052_TSICONTB_TSIMUX_XN;\n\t\tbreak;\n\tcase DA9052_ADC_TSI_YN:\n\t\tval |= DA9052_TSICONTB_TSIMUX_YN;\n\t\tbreak;\n\t}\n\n\treturn da9052_reg_write(hwmon->da9052, DA9052_TSI_CONT_B_REG, val);\n}\n\nstatic int da9052_get_tsi_result(struct da9052_hwmon *hwmon, int channel)\n{\n\tu8 regs[3];\n\tint msb, lsb, err;\n\n\t \n\terr = da9052_group_read(hwmon->da9052, DA9052_TSI_X_MSB_REG,\n\t\t\t\tARRAY_SIZE(regs), regs);\n\tif (err)\n\t\treturn err;\n\n\tswitch (channel) {\n\tcase DA9052_ADC_TSI_XP:\n\tcase DA9052_ADC_TSI_XN:\n\t\tmsb = regs[0] << DA9052_TSILSB_TSIXL_BITS;\n\t\tlsb = regs[2] & DA9052_TSILSB_TSIXL;\n\t\tlsb >>= DA9052_TSILSB_TSIXL_SHIFT;\n\t\tbreak;\n\tcase DA9052_ADC_TSI_YP:\n\tcase DA9052_ADC_TSI_YN:\n\t\tmsb = regs[1] << DA9052_TSILSB_TSIYL_BITS;\n\t\tlsb = regs[2] & DA9052_TSILSB_TSIYL;\n\t\tlsb >>= DA9052_TSILSB_TSIYL_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn msb | lsb;\n}\n\n\nstatic ssize_t __da9052_read_tsi(struct device *dev, int channel)\n{\n\tstruct da9052_hwmon *hwmon = dev_get_drvdata(dev);\n\tint ret;\n\n\treinit_completion(&hwmon->tsidone);\n\n\tret = da9052_request_tsi_read(hwmon, channel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!wait_for_completion_timeout(&hwmon->tsidone,\n\t\t\t\t\t msecs_to_jiffies(500)))\n\t\treturn -ETIMEDOUT;\n\n\treturn da9052_get_tsi_result(hwmon, channel);\n}\n\nstatic ssize_t da9052_tsi_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tstruct da9052_hwmon *hwmon = dev_get_drvdata(dev);\n\tint channel = to_sensor_dev_attr(devattr)->index;\n\tint ret;\n\n\tmutex_lock(&hwmon->da9052->auxadc_lock);\n\tret = __da9052_read_tsi(dev, channel);\n\tmutex_unlock(&hwmon->da9052->auxadc_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn sprintf(buf, \"%d\\n\", input_tsireg_to_mv(hwmon, ret));\n}\n\nstatic ssize_t da9052_tjunc_show(struct device *dev,\n\t\t\t\t struct device_attribute *devattr, char *buf)\n{\n\tstruct da9052_hwmon *hwmon = dev_get_drvdata(dev);\n\tint tjunc;\n\tint toffset;\n\n\ttjunc = da9052_reg_read(hwmon->da9052, DA9052_TJUNC_RES_REG);\n\tif (tjunc < 0)\n\t\treturn tjunc;\n\n\ttoffset = da9052_reg_read(hwmon->da9052, DA9052_T_OFFSET_REG);\n\tif (toffset < 0)\n\t\treturn toffset;\n\n\t \n\treturn sprintf(buf, \"%d\\n\", 1708 * (tjunc - toffset) - 108800);\n}\n\nstatic ssize_t da9052_vbbat_show(struct device *dev,\n\t\t\t\t struct device_attribute *devattr, char *buf)\n{\n\tstruct da9052_hwmon *hwmon = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = da9052_adc_manual_read(hwmon->da9052, DA9052_ADC_VBBAT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", vbbat_reg_to_mv(ret));\n}\n\nstatic ssize_t label_show(struct device *dev,\n\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       input_names[to_sensor_dev_attr(devattr)->index]);\n}\n\nstatic umode_t da9052_channel_is_visible(struct kobject *kobj,\n\t\t\t\t\t struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct da9052_hwmon *hwmon = dev_get_drvdata(dev);\n\tstruct device_attribute *dattr = container_of(attr,\n\t\t\t\tstruct device_attribute, attr);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(dattr);\n\n\tif (!hwmon->tsi_as_adc) {\n\t\tswitch (sattr->index) {\n\t\tcase DA9052_ADC_TSI_XP:\n\t\tcase DA9052_ADC_TSI_YP:\n\t\tcase DA9052_ADC_TSI_XN:\n\t\tcase DA9052_ADC_TSI_YN:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn attr->mode;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_input, da9052_vddout, DA9052_ADC_VDDOUT);\nstatic SENSOR_DEVICE_ATTR_RO(in0_label, label, DA9052_ADC_VDDOUT);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, da9052_vbat, DA9052_ADC_VBAT);\nstatic SENSOR_DEVICE_ATTR_RO(in3_label, label, DA9052_ADC_VBAT);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, da9052_misc_channel, DA9052_ADC_IN4);\nstatic SENSOR_DEVICE_ATTR_RO(in4_label, label, DA9052_ADC_IN4);\nstatic SENSOR_DEVICE_ATTR_RO(in5_input, da9052_misc_channel, DA9052_ADC_IN5);\nstatic SENSOR_DEVICE_ATTR_RO(in5_label, label, DA9052_ADC_IN5);\nstatic SENSOR_DEVICE_ATTR_RO(in6_input, da9052_misc_channel, DA9052_ADC_IN6);\nstatic SENSOR_DEVICE_ATTR_RO(in6_label, label, DA9052_ADC_IN6);\nstatic SENSOR_DEVICE_ATTR_RO(in9_input, da9052_vbbat, DA9052_ADC_VBBAT);\nstatic SENSOR_DEVICE_ATTR_RO(in9_label, label, DA9052_ADC_VBBAT);\n\nstatic SENSOR_DEVICE_ATTR_RO(in70_input, da9052_tsi, DA9052_ADC_TSI_XP);\nstatic SENSOR_DEVICE_ATTR_RO(in70_label, label, DA9052_ADC_TSI_XP);\nstatic SENSOR_DEVICE_ATTR_RO(in71_input, da9052_tsi, DA9052_ADC_TSI_XN);\nstatic SENSOR_DEVICE_ATTR_RO(in71_label, label, DA9052_ADC_TSI_XN);\nstatic SENSOR_DEVICE_ATTR_RO(in72_input, da9052_tsi, DA9052_ADC_TSI_YP);\nstatic SENSOR_DEVICE_ATTR_RO(in72_label, label, DA9052_ADC_TSI_YP);\nstatic SENSOR_DEVICE_ATTR_RO(in73_input, da9052_tsi, DA9052_ADC_TSI_YN);\nstatic SENSOR_DEVICE_ATTR_RO(in73_label, label, DA9052_ADC_TSI_YN);\n\nstatic SENSOR_DEVICE_ATTR_RO(curr1_input, da9052_ich, DA9052_ADC_ICH);\nstatic SENSOR_DEVICE_ATTR_RO(curr1_label, label, DA9052_ADC_ICH);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, da9052_tbat, DA9052_ADC_TBAT);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_label, label, DA9052_ADC_TBAT);\nstatic SENSOR_DEVICE_ATTR_RO(temp8_input, da9052_tjunc, DA9052_ADC_TJUNC);\nstatic SENSOR_DEVICE_ATTR_RO(temp8_label, label, DA9052_ADC_TJUNC);\n\nstatic struct attribute *da9052_attrs[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_label.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_label.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_label.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_label.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_label.dev_attr.attr,\n\t&sensor_dev_attr_in70_input.dev_attr.attr,\n\t&sensor_dev_attr_in70_label.dev_attr.attr,\n\t&sensor_dev_attr_in71_input.dev_attr.attr,\n\t&sensor_dev_attr_in71_label.dev_attr.attr,\n\t&sensor_dev_attr_in72_input.dev_attr.attr,\n\t&sensor_dev_attr_in72_label.dev_attr.attr,\n\t&sensor_dev_attr_in73_input.dev_attr.attr,\n\t&sensor_dev_attr_in73_label.dev_attr.attr,\n\t&sensor_dev_attr_in9_input.dev_attr.attr,\n\t&sensor_dev_attr_in9_label.dev_attr.attr,\n\t&sensor_dev_attr_curr1_input.dev_attr.attr,\n\t&sensor_dev_attr_curr1_label.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_label.dev_attr.attr,\n\t&sensor_dev_attr_temp8_input.dev_attr.attr,\n\t&sensor_dev_attr_temp8_label.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group da9052_group = {\n\t.attrs = da9052_attrs,\n\t.is_visible = da9052_channel_is_visible,\n};\n__ATTRIBUTE_GROUPS(da9052);\n\nstatic irqreturn_t da9052_tsi_datardy_irq(int irq, void *data)\n{\n\tstruct da9052_hwmon *hwmon = data;\n\n\tcomplete(&hwmon->tsidone);\n\treturn IRQ_HANDLED;\n}\n\nstatic int da9052_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct da9052_hwmon *hwmon;\n\tstruct device *hwmon_dev;\n\tint err;\n\n\thwmon = devm_kzalloc(dev, sizeof(struct da9052_hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, hwmon);\n\n\tmutex_init(&hwmon->hwmon_lock);\n\thwmon->da9052 = dev_get_drvdata(pdev->dev.parent);\n\n\tinit_completion(&hwmon->tsidone);\n\n\thwmon->tsi_as_adc =\n\t\tdevice_property_read_bool(pdev->dev.parent, \"dlg,tsi-as-adc\");\n\n\tif (hwmon->tsi_as_adc) {\n\t\thwmon->tsiref = devm_regulator_get(pdev->dev.parent, \"tsiref\");\n\t\tif (IS_ERR(hwmon->tsiref)) {\n\t\t\terr = PTR_ERR(hwmon->tsiref);\n\t\t\tdev_err(&pdev->dev, \"failed to get tsiref: %d\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = regulator_enable(hwmon->tsiref);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\thwmon->tsiref_mv = regulator_get_voltage(hwmon->tsiref);\n\t\tif (hwmon->tsiref_mv < 0) {\n\t\t\terr = hwmon->tsiref_mv;\n\t\t\tgoto exit_regulator;\n\t\t}\n\n\t\t \n\t\thwmon->tsiref_mv /= 1000;\n\n\t\t \n\t\tif (hwmon->tsiref_mv < 1800 || hwmon->tsiref_mv > 2600) {\n\t\t\tdev_err(hwmon->da9052->dev, \"invalid TSIREF voltage: %d\",\n\t\t\t\thwmon->tsiref_mv);\n\t\t\terr = -ENXIO;\n\t\t\tgoto exit_regulator;\n\t\t}\n\n\t\t \n\t\tda9052_reg_write(hwmon->da9052, DA9052_TSI_CONT_A_REG, 0x00);\n\n\t\t \n\t\tda9052_reg_update(hwmon->da9052, DA9052_ADC_CONT_REG,\n\t\t\t\t\t  DA9052_ADCCONT_ADCMODE,\n\t\t\t\t\t  DA9052_ADCCONT_ADCMODE);\n\n\t\terr = da9052_request_irq(hwmon->da9052, DA9052_IRQ_TSIREADY,\n\t\t\t\t\t \"tsiready-irq\", da9052_tsi_datardy_irq,\n\t\t\t\t\t hwmon);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed to register TSIRDY IRQ: %d\",\n\t\t\t\terr);\n\t\t\tgoto exit_regulator;\n\t\t}\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, \"da9052\",\n\t\t\t\t\t\t\t   hwmon,\n\t\t\t\t\t\t\t   da9052_groups);\n\terr = PTR_ERR_OR_ZERO(hwmon_dev);\n\tif (err)\n\t\tgoto exit_irq;\n\n\treturn 0;\n\nexit_irq:\n\tif (hwmon->tsi_as_adc)\n\t\tda9052_free_irq(hwmon->da9052, DA9052_IRQ_TSIREADY, hwmon);\nexit_regulator:\n\tif (hwmon->tsiref)\n\t\tregulator_disable(hwmon->tsiref);\n\n\treturn err;\n}\n\nstatic int da9052_hwmon_remove(struct platform_device *pdev)\n{\n\tstruct da9052_hwmon *hwmon = platform_get_drvdata(pdev);\n\n\tif (hwmon->tsi_as_adc) {\n\t\tda9052_free_irq(hwmon->da9052, DA9052_IRQ_TSIREADY, hwmon);\n\t\tregulator_disable(hwmon->tsiref);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver da9052_hwmon_driver = {\n\t.probe = da9052_hwmon_probe,\n\t.remove = da9052_hwmon_remove,\n\t.driver = {\n\t\t.name = \"da9052-hwmon\",\n\t},\n};\n\nmodule_platform_driver(da9052_hwmon_driver);\n\nMODULE_AUTHOR(\"David Dajun Chen <dchen@diasemi.com>\");\nMODULE_DESCRIPTION(\"DA9052 HWMON driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9052-hwmon\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}