{
  "module_name": "adc128d818.c",
  "hash_id": "d2e086a853832c7cfbf639f586dfc88991664f23d8b3479f6aceda9723fc8092",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adc128d818.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/regulator/consumer.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/of.h>\n\n \nstatic const unsigned short normal_i2c[] = {\n\t0x1d, 0x1e, 0x1f, 0x2d, 0x2e, 0x2f, I2C_CLIENT_END };\n\n \n#define ADC128_REG_IN_MAX(nr)\t\t(0x2a + (nr) * 2)\n#define ADC128_REG_IN_MIN(nr)\t\t(0x2b + (nr) * 2)\n#define ADC128_REG_IN(nr)\t\t(0x20 + (nr))\n\n#define ADC128_REG_TEMP\t\t\t0x27\n#define ADC128_REG_TEMP_MAX\t\t0x38\n#define ADC128_REG_TEMP_HYST\t\t0x39\n\n#define ADC128_REG_CONFIG\t\t0x00\n#define ADC128_REG_ALARM\t\t0x01\n#define ADC128_REG_MASK\t\t\t0x03\n#define ADC128_REG_CONV_RATE\t\t0x07\n#define ADC128_REG_ONESHOT\t\t0x09\n#define ADC128_REG_SHUTDOWN\t\t0x0a\n#define ADC128_REG_CONFIG_ADV\t\t0x0b\n#define ADC128_REG_BUSY_STATUS\t\t0x0c\n\n#define ADC128_REG_MAN_ID\t\t0x3e\n#define ADC128_REG_DEV_ID\t\t0x3f\n\n \n#define ADC128_ATTR_NUM_VOLT\t\t(8 * 4)\n\n \nstatic const u8 num_inputs[] = { 7, 8, 4, 6 };\n\nstruct adc128_data {\n\tstruct i2c_client *client;\n\tstruct regulator *regulator;\n\tint vref;\t\t \n\tstruct mutex update_lock;\n\tu8 mode;\t\t \n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\n\tu16 in[3][8];\t\t \n\ts16 temp[3];\t\t \n\tu8 alarms;\t\t \n};\n\nstatic struct adc128_data *adc128_update_device(struct device *dev)\n{\n\tstruct adc128_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tstruct adc128_data *ret = data;\n\tint i, rv;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\n\t\tfor (i = 0; i < num_inputs[data->mode]; i++) {\n\t\t\trv = i2c_smbus_read_word_swapped(client,\n\t\t\t\t\t\t\t ADC128_REG_IN(i));\n\t\t\tif (rv < 0)\n\t\t\t\tgoto abort;\n\t\t\tdata->in[0][i] = rv >> 4;\n\n\t\t\trv = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t      ADC128_REG_IN_MIN(i));\n\t\t\tif (rv < 0)\n\t\t\t\tgoto abort;\n\t\t\tdata->in[1][i] = rv << 4;\n\n\t\t\trv = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t      ADC128_REG_IN_MAX(i));\n\t\t\tif (rv < 0)\n\t\t\t\tgoto abort;\n\t\t\tdata->in[2][i] = rv << 4;\n\t\t}\n\n\t\tif (data->mode != 1) {\n\t\t\trv = i2c_smbus_read_word_swapped(client,\n\t\t\t\t\t\t\t ADC128_REG_TEMP);\n\t\t\tif (rv < 0)\n\t\t\t\tgoto abort;\n\t\t\tdata->temp[0] = rv >> 7;\n\n\t\t\trv = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t      ADC128_REG_TEMP_MAX);\n\t\t\tif (rv < 0)\n\t\t\t\tgoto abort;\n\t\t\tdata->temp[1] = rv << 1;\n\n\t\t\trv = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t      ADC128_REG_TEMP_HYST);\n\t\t\tif (rv < 0)\n\t\t\t\tgoto abort;\n\t\t\tdata->temp[2] = rv << 1;\n\t\t}\n\n\t\trv = i2c_smbus_read_byte_data(client, ADC128_REG_ALARM);\n\t\tif (rv < 0)\n\t\t\tgoto abort;\n\t\tdata->alarms |= rv;\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\tgoto done;\n\nabort:\n\tret = ERR_PTR(rv);\n\tdata->valid = false;\ndone:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t adc128_in_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct adc128_data *data = adc128_update_device(dev);\n\tint index = to_sensor_dev_attr_2(attr)->index;\n\tint nr = to_sensor_dev_attr_2(attr)->nr;\n\tint val;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tval = DIV_ROUND_CLOSEST(data->in[index][nr] * data->vref, 4095);\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t adc128_in_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct adc128_data *data = dev_get_drvdata(dev);\n\tint index = to_sensor_dev_attr_2(attr)->index;\n\tint nr = to_sensor_dev_attr_2(attr)->nr;\n\tu8 reg, regval;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\t \n\tregval = clamp_val(DIV_ROUND_CLOSEST(val, 10), 0, 255);\n\tdata->in[index][nr] = regval << 4;\n\treg = index == 1 ? ADC128_REG_IN_MIN(nr) : ADC128_REG_IN_MAX(nr);\n\ti2c_smbus_write_byte_data(data->client, reg, regval);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t adc128_temp_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct adc128_data *data = adc128_update_device(dev);\n\tint index = to_sensor_dev_attr(attr)->index;\n\tint temp;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\ttemp = sign_extend32(data->temp[index], 8);\n\treturn sprintf(buf, \"%d\\n\", temp * 500); \n}\n\nstatic ssize_t adc128_temp_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct adc128_data *data = dev_get_drvdata(dev);\n\tint index = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\tint err;\n\ts8 regval;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tregval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), -128, 127);\n\tdata->temp[index] = regval << 1;\n\ti2c_smbus_write_byte_data(data->client,\n\t\t\t\t  index == 1 ? ADC128_REG_TEMP_MAX\n\t\t\t\t\t     : ADC128_REG_TEMP_HYST,\n\t\t\t\t  regval);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t adc128_alarm_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct adc128_data *data = adc128_update_device(dev);\n\tint mask = 1 << to_sensor_dev_attr(attr)->index;\n\tu8 alarms;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t \n\talarms = data->alarms;\n\tdata->alarms &= ~mask;\n\n\treturn sprintf(buf, \"%u\\n\", !!(alarms & mask));\n}\n\nstatic umode_t adc128_is_visible(struct kobject *kobj,\n\t\t\t\t struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct adc128_data *data = dev_get_drvdata(dev);\n\n\tif (index < ADC128_ATTR_NUM_VOLT) {\n\t\t \n\t\tif (index >= num_inputs[data->mode] * 4)\n\t\t\treturn 0;\n\t} else {\n\t\t \n\t\tif (data->mode == 1)\n\t\t\treturn 0;\n\t}\n\n\treturn attr->mode;\n}\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in0_input, adc128_in, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in0_min, adc128_in, 0, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in0_max, adc128_in, 0, 2);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in1_input, adc128_in, 1, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in1_min, adc128_in, 1, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in1_max, adc128_in, 1, 2);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in2_input, adc128_in, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_min, adc128_in, 2, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_max, adc128_in, 2, 2);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in3_input, adc128_in, 3, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_min, adc128_in, 3, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_max, adc128_in, 3, 2);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in4_input, adc128_in, 4, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_min, adc128_in, 4, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_max, adc128_in, 4, 2);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in5_input, adc128_in, 5, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in5_min, adc128_in, 5, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in5_max, adc128_in, 5, 2);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in6_input, adc128_in, 6, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in6_min, adc128_in, 6, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in6_max, adc128_in, 6, 2);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in7_input, adc128_in, 7, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in7_min, adc128_in, 7, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in7_max, adc128_in, 7, 2);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, adc128_temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, adc128_temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max_hyst, adc128_temp, 2);\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_alarm, adc128_alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_alarm, adc128_alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_alarm, adc128_alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_alarm, adc128_alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_alarm, adc128_alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in5_alarm, adc128_alarm, 5);\nstatic SENSOR_DEVICE_ATTR_RO(in6_alarm, adc128_alarm, 6);\nstatic SENSOR_DEVICE_ATTR_RO(in7_alarm, adc128_alarm, 7);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, adc128_alarm, 7);\n\nstatic struct attribute *adc128_attrs[] = {\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in6_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_max.dev_attr.attr,\n\t&sensor_dev_attr_in6_min.dev_attr.attr,\n\t&sensor_dev_attr_in7_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_max.dev_attr.attr,\n\t&sensor_dev_attr_in7_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adc128_group = {\n\t.attrs = adc128_attrs,\n\t.is_visible = adc128_is_visible,\n};\n__ATTRIBUTE_GROUPS(adc128);\n\nstatic int adc128_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tint man_id, dev_id;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tman_id = i2c_smbus_read_byte_data(client, ADC128_REG_MAN_ID);\n\tdev_id = i2c_smbus_read_byte_data(client, ADC128_REG_DEV_ID);\n\tif (man_id != 0x01 || dev_id != 0x09)\n\t\treturn -ENODEV;\n\n\t \n\tif (i2c_smbus_read_byte_data(client, ADC128_REG_CONFIG) & 0xf4)\n\t\treturn -ENODEV;\n\tif (i2c_smbus_read_byte_data(client, ADC128_REG_CONV_RATE) & 0xfe)\n\t\treturn -ENODEV;\n\tif (i2c_smbus_read_byte_data(client, ADC128_REG_ONESHOT) & 0xfe)\n\t\treturn -ENODEV;\n\tif (i2c_smbus_read_byte_data(client, ADC128_REG_SHUTDOWN) & 0xfe)\n\t\treturn -ENODEV;\n\tif (i2c_smbus_read_byte_data(client, ADC128_REG_CONFIG_ADV) & 0xf8)\n\t\treturn -ENODEV;\n\tif (i2c_smbus_read_byte_data(client, ADC128_REG_BUSY_STATUS) & 0xfc)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"adc128d818\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int adc128_init_client(struct adc128_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint err;\n\tu8 regval = 0x0;\n\n\t \n\terr = i2c_smbus_write_byte_data(client, ADC128_REG_CONFIG, 0x80);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (data->mode != 0)\n\t\tregval |= data->mode << 1;\n\n\t \n\tif (data->regulator)\n\t\tregval |= 0x01;\n\n\t \n\tif (regval != 0x0) {\n\t\terr = i2c_smbus_write_byte_data(client, ADC128_REG_CONFIG_ADV,\n\t\t\t\t\t\tregval);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = i2c_smbus_write_byte_data(client, ADC128_REG_CONFIG, 0x01);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int adc128_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct regulator *regulator;\n\tstruct device *hwmon_dev;\n\tstruct adc128_data *data;\n\tint err, vref;\n\n\tdata = devm_kzalloc(dev, sizeof(struct adc128_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tregulator = devm_regulator_get_optional(dev, \"vref\");\n\tif (!IS_ERR(regulator)) {\n\t\tdata->regulator = regulator;\n\t\terr = regulator_enable(regulator);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tvref = regulator_get_voltage(regulator);\n\t\tif (vref < 0) {\n\t\t\terr = vref;\n\t\t\tgoto error;\n\t\t}\n\t\tdata->vref = DIV_ROUND_CLOSEST(vref, 1000);\n\t} else {\n\t\tdata->vref = 2560;\t \n\t}\n\n\t \n\tif (of_property_read_u8(dev->of_node, \"ti,mode\", &data->mode) == 0) {\n\t\tif (data->mode > 3) {\n\t\t\tdev_err(dev, \"invalid operation mode %d\\n\",\n\t\t\t\tdata->mode);\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\terr = i2c_smbus_read_byte_data(client, ADC128_REG_CONFIG_ADV);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\tdata->mode = (err >> 1) & ADC128_REG_MASK;\n\t}\n\n\tdata->client = client;\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\n\t \n\terr = adc128_init_client(data);\n\tif (err < 0)\n\t\tgoto error;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, adc128_groups);\n\tif (IS_ERR(hwmon_dev)) {\n\t\terr = PTR_ERR(hwmon_dev);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (data->regulator)\n\t\tregulator_disable(data->regulator);\n\treturn err;\n}\n\nstatic void adc128_remove(struct i2c_client *client)\n{\n\tstruct adc128_data *data = i2c_get_clientdata(client);\n\n\tif (data->regulator)\n\t\tregulator_disable(data->regulator);\n}\n\nstatic const struct i2c_device_id adc128_id[] = {\n\t{ \"adc128d818\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adc128_id);\n\nstatic const struct of_device_id __maybe_unused adc128_of_match[] = {\n\t{ .compatible = \"ti,adc128d818\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, adc128_of_match);\n\nstatic struct i2c_driver adc128_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"adc128d818\",\n\t\t.of_match_table = of_match_ptr(adc128_of_match),\n\t},\n\t.probe\t\t= adc128_probe,\n\t.remove\t\t= adc128_remove,\n\t.id_table\t= adc128_id,\n\t.detect\t\t= adc128_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(adc128_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck\");\nMODULE_DESCRIPTION(\"Driver for ADC128D818\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}