{
  "module_name": "drivetemp.c",
  "hash_id": "a995adcad02a4a774f979e0e64b206ef1af5c753c150648ba8edf962ba07afab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/drivetemp.c",
  "human_readable_source": "\n \n\n#include <linux/ata.h>\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/hwmon.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_driver.h>\n#include <scsi/scsi_proto.h>\n\nstruct drivetemp_data {\n\tstruct list_head list;\t\t \n\tstruct mutex lock;\t\t \n\tstruct scsi_device *sdev;\t \n\tstruct device *dev;\t\t \n\tstruct device *hwdev;\t\t \n\tu8 smartdata[ATA_SECT_SIZE];\t \n\tint (*get_temp)(struct drivetemp_data *st, u32 attr, long *val);\n\tbool have_temp_lowest;\t\t \n\tbool have_temp_highest;\t\t \n\tbool have_temp_min;\t\t \n\tbool have_temp_max;\t\t \n\tbool have_temp_lcrit;\t\t \n\tbool have_temp_crit;\t\t \n\tint temp_min;\t\t\t \n\tint temp_max;\t\t\t \n\tint temp_lcrit;\t\t\t \n\tint temp_crit;\t\t\t \n};\n\nstatic LIST_HEAD(drivetemp_devlist);\n\n#define ATA_MAX_SMART_ATTRS\t30\n#define SMART_TEMP_PROP_190\t190\n#define SMART_TEMP_PROP_194\t194\n\n#define SCT_STATUS_REQ_ADDR\t0xe0\n#define  SCT_STATUS_VERSION_LOW\t\t0\t \n#define  SCT_STATUS_VERSION_HIGH\t1\n#define  SCT_STATUS_TEMP\t\t200\n#define  SCT_STATUS_TEMP_LOWEST\t\t201\n#define  SCT_STATUS_TEMP_HIGHEST\t202\n#define SCT_READ_LOG_ADDR\t0xe1\n#define  SMART_READ_LOG\t\t\t0xd5\n#define  SMART_WRITE_LOG\t\t0xd6\n\n#define INVALID_TEMP\t\t0x80\n\n#define temp_is_valid(temp)\t((temp) != INVALID_TEMP)\n#define temp_from_sct(temp)\t(((s8)(temp)) * 1000)\n\nstatic inline bool ata_id_smart_supported(u16 *id)\n{\n\treturn id[ATA_ID_COMMAND_SET_1] & BIT(0);\n}\n\nstatic inline bool ata_id_smart_enabled(u16 *id)\n{\n\treturn id[ATA_ID_CFS_ENABLE_1] & BIT(0);\n}\n\nstatic int drivetemp_scsi_command(struct drivetemp_data *st,\n\t\t\t\t u8 ata_command, u8 feature,\n\t\t\t\t u8 lba_low, u8 lba_mid, u8 lba_high)\n{\n\tu8 scsi_cmd[MAX_COMMAND_SIZE];\n\tenum req_op op;\n\n\tmemset(scsi_cmd, 0, sizeof(scsi_cmd));\n\tscsi_cmd[0] = ATA_16;\n\tif (ata_command == ATA_CMD_SMART && feature == SMART_WRITE_LOG) {\n\t\tscsi_cmd[1] = (5 << 1);\t \n\t\t \n\t\tscsi_cmd[2] = 0x06;\n\t\top = REQ_OP_DRV_OUT;\n\t} else {\n\t\tscsi_cmd[1] = (4 << 1);\t \n\t\t \n\t\tscsi_cmd[2] = 0x0e;\n\t\top = REQ_OP_DRV_IN;\n\t}\n\tscsi_cmd[4] = feature;\n\tscsi_cmd[6] = 1;\t \n\tscsi_cmd[8] = lba_low;\n\tscsi_cmd[10] = lba_mid;\n\tscsi_cmd[12] = lba_high;\n\tscsi_cmd[14] = ata_command;\n\n\treturn scsi_execute_cmd(st->sdev, scsi_cmd, op, st->smartdata,\n\t\t\t\tATA_SECT_SIZE, HZ, 5, NULL);\n}\n\nstatic int drivetemp_ata_command(struct drivetemp_data *st, u8 feature,\n\t\t\t\t u8 select)\n{\n\treturn drivetemp_scsi_command(st, ATA_CMD_SMART, feature, select,\n\t\t\t\t     ATA_SMART_LBAM_PASS, ATA_SMART_LBAH_PASS);\n}\n\nstatic int drivetemp_get_smarttemp(struct drivetemp_data *st, u32 attr,\n\t\t\t\t  long *temp)\n{\n\tu8 *buf = st->smartdata;\n\tbool have_temp = false;\n\tu8 temp_raw;\n\tu8 csum;\n\tint err;\n\tint i;\n\n\terr = drivetemp_ata_command(st, ATA_SMART_READ_VALUES, 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\tcsum = 0;\n\tfor (i = 0; i < ATA_SECT_SIZE; i++)\n\t\tcsum += buf[i];\n\tif (csum) {\n\t\tdev_dbg(&st->sdev->sdev_gendev,\n\t\t\t\"checksum error reading SMART values\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < ATA_MAX_SMART_ATTRS; i++) {\n\t\tu8 *attr = buf + i * 12;\n\t\tint id = attr[2];\n\n\t\tif (!id)\n\t\t\tcontinue;\n\n\t\tif (id == SMART_TEMP_PROP_190) {\n\t\t\ttemp_raw = attr[7];\n\t\t\thave_temp = true;\n\t\t}\n\t\tif (id == SMART_TEMP_PROP_194) {\n\t\t\ttemp_raw = attr[7];\n\t\t\thave_temp = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (have_temp) {\n\t\t*temp = temp_raw * 1000;\n\t\treturn 0;\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic int drivetemp_get_scttemp(struct drivetemp_data *st, u32 attr, long *val)\n{\n\tu8 *buf = st->smartdata;\n\tint err;\n\n\terr = drivetemp_ata_command(st, SMART_READ_LOG, SCT_STATUS_REQ_ADDR);\n\tif (err)\n\t\treturn err;\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tif (!temp_is_valid(buf[SCT_STATUS_TEMP]))\n\t\t\treturn -ENODATA;\n\t\t*val = temp_from_sct(buf[SCT_STATUS_TEMP]);\n\t\tbreak;\n\tcase hwmon_temp_lowest:\n\t\tif (!temp_is_valid(buf[SCT_STATUS_TEMP_LOWEST]))\n\t\t\treturn -ENODATA;\n\t\t*val = temp_from_sct(buf[SCT_STATUS_TEMP_LOWEST]);\n\t\tbreak;\n\tcase hwmon_temp_highest:\n\t\tif (!temp_is_valid(buf[SCT_STATUS_TEMP_HIGHEST]))\n\t\t\treturn -ENODATA;\n\t\t*val = temp_from_sct(buf[SCT_STATUS_TEMP_HIGHEST]);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic const char * const sct_avoid_models[] = {\n \n\t\"TOSHIBA DT01ACA\",\n};\n\nstatic bool drivetemp_sct_avoid(struct drivetemp_data *st)\n{\n\tstruct scsi_device *sdev = st->sdev;\n\tunsigned int ctr;\n\n\tif (!sdev->model)\n\t\treturn false;\n\n\t \n\tfor (ctr = 0; ctr < ARRAY_SIZE(sct_avoid_models); ctr++)\n\t\tif (!strncmp(sdev->model, sct_avoid_models[ctr],\n\t\t\t     strlen(sct_avoid_models[ctr])))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int drivetemp_identify_sata(struct drivetemp_data *st)\n{\n\tstruct scsi_device *sdev = st->sdev;\n\tu8 *buf = st->smartdata;\n\tstruct scsi_vpd *vpd;\n\tbool is_ata, is_sata;\n\tbool have_sct_data_table;\n\tbool have_sct_temp;\n\tbool have_smart;\n\tbool have_sct;\n\tu16 *ata_id;\n\tu16 version;\n\tlong temp;\n\tint err;\n\n\t \n\trcu_read_lock();\n\tvpd = rcu_dereference(sdev->vpd_pg89);\n\n\t \n\tif (!vpd || vpd->len < 572 || vpd->data[56] != ATA_CMD_ID_ATA ||\n\t    vpd->data[36] != 0x34) {\n\t\trcu_read_unlock();\n\t\treturn -ENODEV;\n\t}\n\tata_id = (u16 *)&vpd->data[60];\n\tis_ata = ata_id_is_ata(ata_id);\n\tis_sata = ata_id_is_sata(ata_id);\n\thave_sct = ata_id_sct_supported(ata_id);\n\thave_sct_data_table = ata_id_sct_data_tables(ata_id);\n\thave_smart = ata_id_smart_supported(ata_id) &&\n\t\t\t\tata_id_smart_enabled(ata_id);\n\n\trcu_read_unlock();\n\n\t \n\tif (!is_ata || !is_sata)\n\t\treturn -ENODEV;\n\n\tif (have_sct && drivetemp_sct_avoid(st)) {\n\t\tdev_notice(&sdev->sdev_gendev,\n\t\t\t   \"will avoid using SCT for temperature monitoring\\n\");\n\t\thave_sct = false;\n\t}\n\n\tif (!have_sct)\n\t\tgoto skip_sct;\n\n\terr = drivetemp_ata_command(st, SMART_READ_LOG, SCT_STATUS_REQ_ADDR);\n\tif (err)\n\t\tgoto skip_sct;\n\n\tversion = (buf[SCT_STATUS_VERSION_HIGH] << 8) |\n\t\t  buf[SCT_STATUS_VERSION_LOW];\n\tif (version != 2 && version != 3)\n\t\tgoto skip_sct;\n\n\thave_sct_temp = temp_is_valid(buf[SCT_STATUS_TEMP]);\n\tif (!have_sct_temp)\n\t\tgoto skip_sct;\n\n\tst->have_temp_lowest = temp_is_valid(buf[SCT_STATUS_TEMP_LOWEST]);\n\tst->have_temp_highest = temp_is_valid(buf[SCT_STATUS_TEMP_HIGHEST]);\n\n\tif (!have_sct_data_table)\n\t\tgoto skip_sct_data;\n\n\t \n\tmemset(buf, '\\0', sizeof(st->smartdata));\n\tbuf[0] = 5;\t \n\tbuf[2] = 1;\t \n\tbuf[4] = 2;\t \n\n\terr = drivetemp_ata_command(st, SMART_WRITE_LOG, SCT_STATUS_REQ_ADDR);\n\tif (err)\n\t\tgoto skip_sct_data;\n\n\terr = drivetemp_ata_command(st, SMART_READ_LOG, SCT_READ_LOG_ADDR);\n\tif (err)\n\t\tgoto skip_sct_data;\n\n\t \n\tst->have_temp_max = temp_is_valid(buf[6]);\n\tst->have_temp_crit = temp_is_valid(buf[7]);\n\tst->have_temp_min = temp_is_valid(buf[8]);\n\tst->have_temp_lcrit = temp_is_valid(buf[9]);\n\n\tst->temp_max = temp_from_sct(buf[6]);\n\tst->temp_crit = temp_from_sct(buf[7]);\n\tst->temp_min = temp_from_sct(buf[8]);\n\tst->temp_lcrit = temp_from_sct(buf[9]);\n\nskip_sct_data:\n\tif (have_sct_temp) {\n\t\tst->get_temp = drivetemp_get_scttemp;\n\t\treturn 0;\n\t}\nskip_sct:\n\tif (!have_smart)\n\t\treturn -ENODEV;\n\tst->get_temp = drivetemp_get_smarttemp;\n\treturn drivetemp_get_smarttemp(st, hwmon_temp_input, &temp);\n}\n\nstatic int drivetemp_identify(struct drivetemp_data *st)\n{\n\tstruct scsi_device *sdev = st->sdev;\n\n\t \n\tif (!sdev->inquiry || sdev->inquiry_len < 16)\n\t\treturn -ENODEV;\n\n\t \n\tif (sdev->type != TYPE_DISK && sdev->type != TYPE_ZBC)\n\t\treturn -ENODEV;\n\n\treturn drivetemp_identify_sata(st);\n}\n\nstatic int drivetemp_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long *val)\n{\n\tstruct drivetemp_data *st = dev_get_drvdata(dev);\n\tint err = 0;\n\n\tif (type != hwmon_temp)\n\t\treturn -EINVAL;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_lowest:\n\tcase hwmon_temp_highest:\n\t\tmutex_lock(&st->lock);\n\t\terr = st->get_temp(st, attr, val);\n\t\tmutex_unlock(&st->lock);\n\t\tbreak;\n\tcase hwmon_temp_lcrit:\n\t\t*val = st->temp_lcrit;\n\t\tbreak;\n\tcase hwmon_temp_min:\n\t\t*val = st->temp_min;\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\t*val = st->temp_max;\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\t*val = st->temp_crit;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic umode_t drivetemp_is_visible(const void *data,\n\t\t\t\t   enum hwmon_sensor_types type,\n\t\t\t\t   u32 attr, int channel)\n{\n\tconst struct drivetemp_data *st = data;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_lowest:\n\t\t\tif (st->have_temp_lowest)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase hwmon_temp_highest:\n\t\t\tif (st->have_temp_highest)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase hwmon_temp_min:\n\t\t\tif (st->have_temp_min)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase hwmon_temp_max:\n\t\t\tif (st->have_temp_max)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase hwmon_temp_lcrit:\n\t\t\tif (st->have_temp_lcrit)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase hwmon_temp_crit:\n\t\t\tif (st->have_temp_crit)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const drivetemp_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT |\n\t\t\t   HWMON_T_LOWEST | HWMON_T_HIGHEST |\n\t\t\t   HWMON_T_MIN | HWMON_T_MAX |\n\t\t\t   HWMON_T_LCRIT | HWMON_T_CRIT),\n\tNULL\n};\n\nstatic const struct hwmon_ops drivetemp_ops = {\n\t.is_visible = drivetemp_is_visible,\n\t.read = drivetemp_read,\n};\n\nstatic const struct hwmon_chip_info drivetemp_chip_info = {\n\t.ops = &drivetemp_ops,\n\t.info = drivetemp_info,\n};\n\n \nstatic int drivetemp_add(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev->parent);\n\tstruct drivetemp_data *st;\n\tint err;\n\n\tst = kzalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->sdev = sdev;\n\tst->dev = dev;\n\tmutex_init(&st->lock);\n\n\tif (drivetemp_identify(st)) {\n\t\terr = -ENODEV;\n\t\tgoto abort;\n\t}\n\n\tst->hwdev = hwmon_device_register_with_info(dev->parent, \"drivetemp\",\n\t\t\t\t\t\t    st, &drivetemp_chip_info,\n\t\t\t\t\t\t    NULL);\n\tif (IS_ERR(st->hwdev)) {\n\t\terr = PTR_ERR(st->hwdev);\n\t\tgoto abort;\n\t}\n\n\tlist_add(&st->list, &drivetemp_devlist);\n\treturn 0;\n\nabort:\n\tkfree(st);\n\treturn err;\n}\n\nstatic void drivetemp_remove(struct device *dev)\n{\n\tstruct drivetemp_data *st, *tmp;\n\n\tlist_for_each_entry_safe(st, tmp, &drivetemp_devlist, list) {\n\t\tif (st->dev == dev) {\n\t\t\tlist_del(&st->list);\n\t\t\thwmon_device_unregister(st->hwdev);\n\t\t\tkfree(st);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct class_interface drivetemp_interface = {\n\t.add_dev = drivetemp_add,\n\t.remove_dev = drivetemp_remove,\n};\n\nstatic int __init drivetemp_init(void)\n{\n\treturn scsi_register_interface(&drivetemp_interface);\n}\n\nstatic void __exit drivetemp_exit(void)\n{\n\tscsi_unregister_interface(&drivetemp_interface);\n}\n\nmodule_init(drivetemp_init);\nmodule_exit(drivetemp_exit);\n\nMODULE_AUTHOR(\"Guenter Roeck <linus@roeck-us.net>\");\nMODULE_DESCRIPTION(\"Hard drive temperature monitor\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:drivetemp\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}