{
  "module_name": "lm90.c",
  "hash_id": "49f901c020849583ada4e07fc79237ce90344b49af29e6ac75543830b28c642c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lm90.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/hwmon.h>\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n \n#define MAX_CHANNELS\t3\n\n \n\nstatic const unsigned short normal_i2c[] = {\n\t0x18, 0x19, 0x1a, 0x29, 0x2a, 0x2b, 0x48, 0x49, 0x4a, 0x4b, 0x4c,\n\t0x4d, 0x4e, 0x4f, I2C_CLIENT_END };\n\nenum chips { adm1023, adm1032, adt7461, adt7461a, adt7481,\n\tg781, lm84, lm90, lm99,\n\tmax1617, max6642, max6646, max6648, max6654, max6657, max6659, max6680, max6696,\n\tnct210, nct72, ne1618, sa56004, tmp451, tmp461, w83l771,\n};\n\n \n\n#define LM90_REG_MAN_ID\t\t\t0xFE\n#define LM90_REG_CHIP_ID\t\t0xFF\n#define LM90_REG_CONFIG1\t\t0x03\n#define LM90_REG_CONFIG2\t\t0xBF\n#define LM90_REG_CONVRATE\t\t0x04\n#define LM90_REG_STATUS\t\t\t0x02\n#define LM90_REG_LOCAL_TEMP\t\t0x00\n#define LM90_REG_LOCAL_HIGH\t\t0x05\n#define LM90_REG_LOCAL_LOW\t\t0x06\n#define LM90_REG_LOCAL_CRIT\t\t0x20\n#define LM90_REG_REMOTE_TEMPH\t\t0x01\n#define LM90_REG_REMOTE_TEMPL\t\t0x10\n#define LM90_REG_REMOTE_OFFSH\t\t0x11\n#define LM90_REG_REMOTE_OFFSL\t\t0x12\n#define LM90_REG_REMOTE_HIGHH\t\t0x07\n#define LM90_REG_REMOTE_HIGHL\t\t0x13\n#define LM90_REG_REMOTE_LOWH\t\t0x08\n#define LM90_REG_REMOTE_LOWL\t\t0x14\n#define LM90_REG_REMOTE_CRIT\t\t0x19\n#define LM90_REG_TCRIT_HYST\t\t0x21\n\n \n\n#define MAX6657_REG_LOCAL_TEMPL\t\t0x11\n#define MAX6696_REG_STATUS2\t\t0x12\n#define MAX6659_REG_REMOTE_EMERG\t0x16\n#define MAX6659_REG_LOCAL_EMERG\t\t0x17\n\n \n\n#define SA56004_REG_LOCAL_TEMPL\t\t0x22\n\n#define LM90_MAX_CONVRATE_MS\t16000\t \n\n \n#define TMP451_REG_LOCAL_TEMPL\t\t0x15\n#define TMP451_REG_CONALERT\t\t0x22\n\n#define TMP461_REG_CHEN\t\t\t0x16\n#define TMP461_REG_DFC\t\t\t0x24\n\n \n#define ADT7481_REG_STATUS2\t\t0x23\n#define ADT7481_REG_CONFIG2\t\t0x24\n\n#define ADT7481_REG_MAN_ID\t\t0x3e\n#define ADT7481_REG_CHIP_ID\t\t0x3d\n\n \n#define LM90_HAVE_EXTENDED_TEMP\tBIT(0)\t \n#define LM90_HAVE_OFFSET\tBIT(1)\t \n#define LM90_HAVE_UNSIGNED_TEMP\tBIT(2)\t \n#define LM90_HAVE_REM_LIMIT_EXT\tBIT(3)\t \n#define LM90_HAVE_EMERGENCY\tBIT(4)\t \n#define LM90_HAVE_EMERGENCY_ALARM BIT(5) \n#define LM90_HAVE_TEMP3\t\tBIT(6)\t \n#define LM90_HAVE_BROKEN_ALERT\tBIT(7)\t \n#define LM90_PAUSE_FOR_CONFIG\tBIT(8)\t \n#define LM90_HAVE_CRIT\t\tBIT(9)\t \n#define LM90_HAVE_CRIT_ALRM_SWP\tBIT(10)\t \n#define LM90_HAVE_PEC\t\tBIT(11)\t \n#define LM90_HAVE_PARTIAL_PEC\tBIT(12)\t \n#define LM90_HAVE_ALARMS\tBIT(13)\t \n#define LM90_HAVE_EXT_UNSIGNED\tBIT(14)\t \n#define LM90_HAVE_LOW\t\tBIT(15)\t \n#define LM90_HAVE_CONVRATE\tBIT(16)\t \n#define LM90_HAVE_REMOTE_EXT\tBIT(17)\t \n#define LM90_HAVE_FAULTQUEUE\tBIT(18)\t \n\n \n#define LM90_STATUS_LTHRM\tBIT(0)\t \n#define LM90_STATUS_RTHRM\tBIT(1)\t \n#define LM90_STATUS_ROPEN\tBIT(2)\t \n#define LM90_STATUS_RLOW\tBIT(3)\t \n#define LM90_STATUS_RHIGH\tBIT(4)\t \n#define LM90_STATUS_LLOW\tBIT(5)\t \n#define LM90_STATUS_LHIGH\tBIT(6)\t \n#define LM90_STATUS_BUSY\tBIT(7)\t \n\n \n#define MAX6696_STATUS2_R2THRM\tBIT(1)\t \n#define MAX6696_STATUS2_R2OPEN\tBIT(2)\t \n#define MAX6696_STATUS2_R2LOW\tBIT(3)\t \n#define MAX6696_STATUS2_R2HIGH\tBIT(4)\t \n#define MAX6696_STATUS2_ROT2\tBIT(5)\t \n#define MAX6696_STATUS2_R2OT2\tBIT(6)\t \n#define MAX6696_STATUS2_LOT2\tBIT(7)\t \n\n \n\nstatic const struct i2c_device_id lm90_id[] = {\n\t{ \"adm1020\", max1617 },\n\t{ \"adm1021\", max1617 },\n\t{ \"adm1023\", adm1023 },\n\t{ \"adm1032\", adm1032 },\n\t{ \"adt7421\", adt7461a },\n\t{ \"adt7461\", adt7461 },\n\t{ \"adt7461a\", adt7461a },\n\t{ \"adt7481\", adt7481 },\n\t{ \"adt7482\", adt7481 },\n\t{ \"adt7483a\", adt7481 },\n\t{ \"g781\", g781 },\n\t{ \"gl523sm\", max1617 },\n\t{ \"lm84\", lm84 },\n\t{ \"lm86\", lm90 },\n\t{ \"lm89\", lm90 },\n\t{ \"lm90\", lm90 },\n\t{ \"lm99\", lm99 },\n\t{ \"max1617\", max1617 },\n\t{ \"max6642\", max6642 },\n\t{ \"max6646\", max6646 },\n\t{ \"max6647\", max6646 },\n\t{ \"max6648\", max6648 },\n\t{ \"max6649\", max6646 },\n\t{ \"max6654\", max6654 },\n\t{ \"max6657\", max6657 },\n\t{ \"max6658\", max6657 },\n\t{ \"max6659\", max6659 },\n\t{ \"max6680\", max6680 },\n\t{ \"max6681\", max6680 },\n\t{ \"max6690\", max6654 },\n\t{ \"max6692\", max6648 },\n\t{ \"max6695\", max6696 },\n\t{ \"max6696\", max6696 },\n\t{ \"mc1066\", max1617 },\n\t{ \"nct1008\", adt7461a },\n\t{ \"nct210\", nct210 },\n\t{ \"nct214\", nct72 },\n\t{ \"nct218\", nct72 },\n\t{ \"nct72\", nct72 },\n\t{ \"ne1618\", ne1618 },\n\t{ \"w83l771\", w83l771 },\n\t{ \"sa56004\", sa56004 },\n\t{ \"thmc10\", max1617 },\n\t{ \"tmp451\", tmp451 },\n\t{ \"tmp461\", tmp461 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm90_id);\n\nstatic const struct of_device_id __maybe_unused lm90_of_match[] = {\n\t{\n\t\t.compatible = \"adi,adm1032\",\n\t\t.data = (void *)adm1032\n\t},\n\t{\n\t\t.compatible = \"adi,adt7461\",\n\t\t.data = (void *)adt7461\n\t},\n\t{\n\t\t.compatible = \"adi,adt7461a\",\n\t\t.data = (void *)adt7461a\n\t},\n\t{\n\t\t.compatible = \"adi,adt7481\",\n\t\t.data = (void *)adt7481\n\t},\n\t{\n\t\t.compatible = \"gmt,g781\",\n\t\t.data = (void *)g781\n\t},\n\t{\n\t\t.compatible = \"national,lm90\",\n\t\t.data = (void *)lm90\n\t},\n\t{\n\t\t.compatible = \"national,lm86\",\n\t\t.data = (void *)lm90\n\t},\n\t{\n\t\t.compatible = \"national,lm89\",\n\t\t.data = (void *)lm90\n\t},\n\t{\n\t\t.compatible = \"national,lm99\",\n\t\t.data = (void *)lm99\n\t},\n\t{\n\t\t.compatible = \"dallas,max6646\",\n\t\t.data = (void *)max6646\n\t},\n\t{\n\t\t.compatible = \"dallas,max6647\",\n\t\t.data = (void *)max6646\n\t},\n\t{\n\t\t.compatible = \"dallas,max6649\",\n\t\t.data = (void *)max6646\n\t},\n\t{\n\t\t.compatible = \"dallas,max6654\",\n\t\t.data = (void *)max6654\n\t},\n\t{\n\t\t.compatible = \"dallas,max6657\",\n\t\t.data = (void *)max6657\n\t},\n\t{\n\t\t.compatible = \"dallas,max6658\",\n\t\t.data = (void *)max6657\n\t},\n\t{\n\t\t.compatible = \"dallas,max6659\",\n\t\t.data = (void *)max6659\n\t},\n\t{\n\t\t.compatible = \"dallas,max6680\",\n\t\t.data = (void *)max6680\n\t},\n\t{\n\t\t.compatible = \"dallas,max6681\",\n\t\t.data = (void *)max6680\n\t},\n\t{\n\t\t.compatible = \"dallas,max6695\",\n\t\t.data = (void *)max6696\n\t},\n\t{\n\t\t.compatible = \"dallas,max6696\",\n\t\t.data = (void *)max6696\n\t},\n\t{\n\t\t.compatible = \"onnn,nct1008\",\n\t\t.data = (void *)adt7461a\n\t},\n\t{\n\t\t.compatible = \"onnn,nct214\",\n\t\t.data = (void *)nct72\n\t},\n\t{\n\t\t.compatible = \"onnn,nct218\",\n\t\t.data = (void *)nct72\n\t},\n\t{\n\t\t.compatible = \"onnn,nct72\",\n\t\t.data = (void *)nct72\n\t},\n\t{\n\t\t.compatible = \"winbond,w83l771\",\n\t\t.data = (void *)w83l771\n\t},\n\t{\n\t\t.compatible = \"nxp,sa56004\",\n\t\t.data = (void *)sa56004\n\t},\n\t{\n\t\t.compatible = \"ti,tmp451\",\n\t\t.data = (void *)tmp451\n\t},\n\t{\n\t\t.compatible = \"ti,tmp461\",\n\t\t.data = (void *)tmp461\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, lm90_of_match);\n\n \nstruct lm90_params {\n\tu32 flags;\t\t \n\tu16 alert_alarms;\t \n\t\t\t\t \n\tu8 max_convrate;\t \n\tu8 resolution;\t\t \n\tu8 reg_status2;\t\t \n\tu8 reg_local_ext;\t \n\tu8 faultqueue_mask;\t \n\tu8 faultqueue_depth;\t \n};\n\nstatic const struct lm90_params lm90_params[] = {\n\t[adm1023] = {\n\t\t.flags = LM90_HAVE_ALARMS | LM90_HAVE_OFFSET | LM90_HAVE_BROKEN_ALERT\n\t\t  | LM90_HAVE_REM_LIMIT_EXT | LM90_HAVE_LOW | LM90_HAVE_CONVRATE\n\t\t  | LM90_HAVE_REMOTE_EXT,\n\t\t.alert_alarms = 0x7c,\n\t\t.resolution = 8,\n\t\t.max_convrate = 7,\n\t},\n\t[adm1032] = {\n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_REM_LIMIT_EXT\n\t\t  | LM90_HAVE_BROKEN_ALERT | LM90_HAVE_CRIT\n\t\t  | LM90_HAVE_PARTIAL_PEC | LM90_HAVE_ALARMS\n\t\t  | LM90_HAVE_LOW | LM90_HAVE_CONVRATE | LM90_HAVE_REMOTE_EXT\n\t\t  | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 10,\n\t},\n\t[adt7461] = {\n\t\t \n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_REM_LIMIT_EXT\n\t\t  | LM90_HAVE_BROKEN_ALERT | LM90_HAVE_EXTENDED_TEMP\n\t\t  | LM90_HAVE_CRIT | LM90_HAVE_PARTIAL_PEC\n\t\t  | LM90_HAVE_ALARMS | LM90_HAVE_LOW | LM90_HAVE_CONVRATE\n\t\t  | LM90_HAVE_REMOTE_EXT | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 10,\n\t\t.resolution = 10,\n\t},\n\t[adt7461a] = {\n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_REM_LIMIT_EXT\n\t\t  | LM90_HAVE_BROKEN_ALERT | LM90_HAVE_EXTENDED_TEMP\n\t\t  | LM90_HAVE_CRIT | LM90_HAVE_PEC | LM90_HAVE_ALARMS\n\t\t  | LM90_HAVE_LOW | LM90_HAVE_CONVRATE | LM90_HAVE_REMOTE_EXT\n\t\t  | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 10,\n\t},\n\t[adt7481] = {\n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_REM_LIMIT_EXT\n\t\t  | LM90_HAVE_BROKEN_ALERT | LM90_HAVE_EXTENDED_TEMP\n\t\t  | LM90_HAVE_UNSIGNED_TEMP | LM90_HAVE_PEC\n\t\t  | LM90_HAVE_TEMP3 | LM90_HAVE_CRIT | LM90_HAVE_LOW\n\t\t  | LM90_HAVE_CONVRATE | LM90_HAVE_REMOTE_EXT\n\t\t  | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x1c7c,\n\t\t.max_convrate = 11,\n\t\t.resolution = 10,\n\t\t.reg_status2 = ADT7481_REG_STATUS2,\n\t},\n\t[g781] = {\n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_REM_LIMIT_EXT\n\t\t  | LM90_HAVE_BROKEN_ALERT | LM90_HAVE_CRIT\n\t\t  | LM90_HAVE_ALARMS | LM90_HAVE_LOW | LM90_HAVE_CONVRATE\n\t\t  | LM90_HAVE_REMOTE_EXT | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 7,\n\t},\n\t[lm84] = {\n\t\t.flags = LM90_HAVE_ALARMS,\n\t\t.resolution = 8,\n\t},\n\t[lm90] = {\n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_REM_LIMIT_EXT\n\t\t  | LM90_HAVE_CRIT | LM90_HAVE_ALARMS | LM90_HAVE_LOW\n\t\t  | LM90_HAVE_CONVRATE | LM90_HAVE_REMOTE_EXT\n\t\t  | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x7b,\n\t\t.max_convrate = 9,\n\t\t.faultqueue_mask = BIT(0),\n\t\t.faultqueue_depth = 3,\n\t},\n\t[lm99] = {\n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_REM_LIMIT_EXT\n\t\t  | LM90_HAVE_CRIT | LM90_HAVE_ALARMS | LM90_HAVE_LOW\n\t\t  | LM90_HAVE_CONVRATE | LM90_HAVE_REMOTE_EXT\n\t\t  | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x7b,\n\t\t.max_convrate = 9,\n\t\t.faultqueue_mask = BIT(0),\n\t\t.faultqueue_depth = 3,\n\t},\n\t[max1617] = {\n\t\t.flags = LM90_HAVE_CONVRATE | LM90_HAVE_BROKEN_ALERT |\n\t\t  LM90_HAVE_LOW | LM90_HAVE_ALARMS,\n\t\t.alert_alarms = 0x78,\n\t\t.resolution = 8,\n\t\t.max_convrate = 7,\n\t},\n\t[max6642] = {\n\t\t.flags = LM90_HAVE_BROKEN_ALERT | LM90_HAVE_EXT_UNSIGNED\n\t\t  | LM90_HAVE_REMOTE_EXT | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x50,\n\t\t.resolution = 10,\n\t\t.reg_local_ext = MAX6657_REG_LOCAL_TEMPL,\n\t\t.faultqueue_mask = BIT(4),\n\t\t.faultqueue_depth = 2,\n\t},\n\t[max6646] = {\n\t\t.flags = LM90_HAVE_CRIT | LM90_HAVE_BROKEN_ALERT\n\t\t  | LM90_HAVE_EXT_UNSIGNED | LM90_HAVE_ALARMS | LM90_HAVE_LOW\n\t\t  | LM90_HAVE_CONVRATE | LM90_HAVE_REMOTE_EXT,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 6,\n\t\t.reg_local_ext = MAX6657_REG_LOCAL_TEMPL,\n\t},\n\t[max6648] = {\n\t\t.flags = LM90_HAVE_UNSIGNED_TEMP | LM90_HAVE_CRIT\n\t\t  | LM90_HAVE_BROKEN_ALERT | LM90_HAVE_LOW\n\t\t  | LM90_HAVE_CONVRATE | LM90_HAVE_REMOTE_EXT,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 6,\n\t\t.reg_local_ext = MAX6657_REG_LOCAL_TEMPL,\n\t},\n\t[max6654] = {\n\t\t.flags = LM90_HAVE_BROKEN_ALERT | LM90_HAVE_ALARMS | LM90_HAVE_LOW\n\t\t  | LM90_HAVE_CONVRATE | LM90_HAVE_REMOTE_EXT,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 7,\n\t\t.reg_local_ext = MAX6657_REG_LOCAL_TEMPL,\n\t},\n\t[max6657] = {\n\t\t.flags = LM90_PAUSE_FOR_CONFIG | LM90_HAVE_CRIT\n\t\t  | LM90_HAVE_ALARMS | LM90_HAVE_LOW | LM90_HAVE_CONVRATE\n\t\t  | LM90_HAVE_REMOTE_EXT,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 8,\n\t\t.reg_local_ext = MAX6657_REG_LOCAL_TEMPL,\n\t},\n\t[max6659] = {\n\t\t.flags = LM90_HAVE_EMERGENCY | LM90_HAVE_CRIT\n\t\t  | LM90_HAVE_ALARMS | LM90_HAVE_LOW | LM90_HAVE_CONVRATE\n\t\t  | LM90_HAVE_REMOTE_EXT,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 8,\n\t\t.reg_local_ext = MAX6657_REG_LOCAL_TEMPL,\n\t},\n\t[max6680] = {\n\t\t \n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_CRIT\n\t\t  | LM90_HAVE_CRIT_ALRM_SWP | LM90_HAVE_BROKEN_ALERT\n\t\t  | LM90_HAVE_ALARMS | LM90_HAVE_LOW | LM90_HAVE_CONVRATE\n\t\t  | LM90_HAVE_REMOTE_EXT,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 7,\n\t},\n\t[max6696] = {\n\t\t.flags = LM90_HAVE_EMERGENCY\n\t\t  | LM90_HAVE_EMERGENCY_ALARM | LM90_HAVE_TEMP3 | LM90_HAVE_CRIT\n\t\t  | LM90_HAVE_ALARMS | LM90_HAVE_LOW | LM90_HAVE_CONVRATE\n\t\t  | LM90_HAVE_REMOTE_EXT | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x1c7c,\n\t\t.max_convrate = 6,\n\t\t.reg_status2 = MAX6696_REG_STATUS2,\n\t\t.reg_local_ext = MAX6657_REG_LOCAL_TEMPL,\n\t\t.faultqueue_mask = BIT(5),\n\t\t.faultqueue_depth = 4,\n\t},\n\t[nct72] = {\n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_REM_LIMIT_EXT\n\t\t  | LM90_HAVE_BROKEN_ALERT | LM90_HAVE_EXTENDED_TEMP\n\t\t  | LM90_HAVE_CRIT | LM90_HAVE_PEC | LM90_HAVE_UNSIGNED_TEMP\n\t\t  | LM90_HAVE_LOW | LM90_HAVE_CONVRATE | LM90_HAVE_REMOTE_EXT\n\t\t  | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 10,\n\t\t.resolution = 10,\n\t},\n\t[nct210] = {\n\t\t.flags = LM90_HAVE_ALARMS | LM90_HAVE_BROKEN_ALERT\n\t\t  | LM90_HAVE_REM_LIMIT_EXT | LM90_HAVE_LOW | LM90_HAVE_CONVRATE\n\t\t  | LM90_HAVE_REMOTE_EXT,\n\t\t.alert_alarms = 0x7c,\n\t\t.resolution = 11,\n\t\t.max_convrate = 7,\n\t},\n\t[ne1618] = {\n\t\t.flags = LM90_PAUSE_FOR_CONFIG | LM90_HAVE_BROKEN_ALERT\n\t\t  | LM90_HAVE_LOW | LM90_HAVE_CONVRATE | LM90_HAVE_REMOTE_EXT,\n\t\t.alert_alarms = 0x7c,\n\t\t.resolution = 11,\n\t\t.max_convrate = 7,\n\t},\n\t[w83l771] = {\n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_REM_LIMIT_EXT | LM90_HAVE_CRIT\n\t\t  | LM90_HAVE_ALARMS | LM90_HAVE_LOW | LM90_HAVE_CONVRATE\n\t\t  | LM90_HAVE_REMOTE_EXT,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 8,\n\t},\n\t[sa56004] = {\n\t\t \n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_REM_LIMIT_EXT | LM90_HAVE_CRIT\n\t\t  | LM90_HAVE_ALARMS | LM90_HAVE_LOW | LM90_HAVE_CONVRATE\n\t\t  | LM90_HAVE_REMOTE_EXT | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x7b,\n\t\t.max_convrate = 9,\n\t\t.reg_local_ext = SA56004_REG_LOCAL_TEMPL,\n\t\t.faultqueue_mask = BIT(0),\n\t\t.faultqueue_depth = 3,\n\t},\n\t[tmp451] = {\n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_REM_LIMIT_EXT\n\t\t  | LM90_HAVE_BROKEN_ALERT | LM90_HAVE_EXTENDED_TEMP | LM90_HAVE_CRIT\n\t\t  | LM90_HAVE_UNSIGNED_TEMP | LM90_HAVE_ALARMS | LM90_HAVE_LOW\n\t\t  | LM90_HAVE_CONVRATE | LM90_HAVE_REMOTE_EXT | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 9,\n\t\t.resolution = 12,\n\t\t.reg_local_ext = TMP451_REG_LOCAL_TEMPL,\n\t},\n\t[tmp461] = {\n\t\t.flags = LM90_HAVE_OFFSET | LM90_HAVE_REM_LIMIT_EXT\n\t\t  | LM90_HAVE_BROKEN_ALERT | LM90_HAVE_EXTENDED_TEMP | LM90_HAVE_CRIT\n\t\t  | LM90_HAVE_ALARMS | LM90_HAVE_LOW | LM90_HAVE_CONVRATE\n\t\t  | LM90_HAVE_REMOTE_EXT | LM90_HAVE_FAULTQUEUE,\n\t\t.alert_alarms = 0x7c,\n\t\t.max_convrate = 9,\n\t\t.resolution = 12,\n\t\t.reg_local_ext = TMP451_REG_LOCAL_TEMPL,\n\t},\n};\n\n \nenum lm90_temp_reg_index {\n\tLOCAL_LOW = 0,\n\tLOCAL_HIGH,\n\tLOCAL_CRIT,\n\tREMOTE_CRIT,\n\tLOCAL_EMERG,\t \n\tREMOTE_EMERG,\t \n\tREMOTE2_CRIT,\t \n\tREMOTE2_EMERG,\t \n\n\tREMOTE_TEMP,\n\tREMOTE_LOW,\n\tREMOTE_HIGH,\n\tREMOTE_OFFSET,\t \n\tLOCAL_TEMP,\n\tREMOTE2_TEMP,\t \n\tREMOTE2_LOW,\t \n\tREMOTE2_HIGH,\t \n\tREMOTE2_OFFSET,\n\n\tTEMP_REG_NUM\n};\n\n \n\nstruct lm90_data {\n\tstruct i2c_client *client;\n\tstruct device *hwmon_dev;\n\tu32 chip_config[2];\n\tu32 channel_config[MAX_CHANNELS + 1];\n\tconst char *channel_label[MAX_CHANNELS];\n\tstruct hwmon_channel_info chip_info;\n\tstruct hwmon_channel_info temp_info;\n\tconst struct hwmon_channel_info *info[3];\n\tstruct hwmon_chip_info chip;\n\tstruct mutex update_lock;\n\tstruct delayed_work alert_work;\n\tstruct work_struct report_work;\n\tbool valid;\t\t \n\tbool alarms_valid;\t \n\tunsigned long last_updated;  \n\tunsigned long alarms_updated;  \n\tint kind;\n\tu32 flags;\n\n\tunsigned int update_interval;  \n\n\tu8 config;\t\t \n\tu8 config_orig;\t\t \n\tu8 convrate_orig;\t \n\tu8 resolution;\t\t \n\tu16 alert_alarms;\t \n\t\t\t\t \n\tu8 max_convrate;\t \n\tu8 reg_status2;\t\t \n\tu8 reg_local_ext;\t \n\tu8 reg_remote_ext;\t \n\tu8 faultqueue_mask;\t \n\tu8 faultqueue_depth;\t \n\n\t \n\tu16 temp[TEMP_REG_NUM];\n\tu8 temp_hyst;\n\tu8 conalert;\n\tu16 reported_alarms;\t \n\tu16 current_alarms;\t \n\tu16 alarms;\t\t \n};\n\n \n\n \nstatic inline s32 lm90_write_no_pec(struct i2c_client *client, u8 value)\n{\n\treturn i2c_smbus_xfer(client->adapter, client->addr,\n\t\t\t      client->flags & ~I2C_CLIENT_PEC,\n\t\t\t      I2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, NULL);\n}\n\n \nstatic int lm90_read_reg(struct i2c_client *client, u8 reg)\n{\n\tstruct lm90_data *data = i2c_get_clientdata(client);\n\tbool partial_pec = (client->flags & I2C_CLIENT_PEC) &&\n\t\t\t(data->flags & LM90_HAVE_PARTIAL_PEC);\n\tint err;\n\n\tif (partial_pec) {\n\t\terr = lm90_write_no_pec(client, reg);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn i2c_smbus_read_byte(client);\n\t}\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\n \nstatic u8 lm90_write_reg_addr(u8 reg)\n{\n\tif (reg >= LM90_REG_CONFIG1 && reg <= LM90_REG_REMOTE_LOWH)\n\t\treturn reg + 6;\n\treturn reg;\n}\n\n \nstatic int lm90_write_reg(struct i2c_client *client, u8 reg, u8 val)\n{\n\treturn i2c_smbus_write_byte_data(client, lm90_write_reg_addr(reg), val);\n}\n\n \nstatic int lm90_write16(struct i2c_client *client, u8 regh, u8 regl, u16 val)\n{\n\tint ret;\n\n\tret = lm90_write_reg(client, regh, val >> 8);\n\tif (ret < 0 || !regl)\n\t\treturn ret;\n\treturn lm90_write_reg(client, regl, val & 0xff);\n}\n\nstatic int lm90_read16(struct i2c_client *client, u8 regh, u8 regl,\n\t\t       bool is_volatile)\n{\n\tint oldh, newh, l;\n\n\toldh = lm90_read_reg(client, regh);\n\tif (oldh < 0)\n\t\treturn oldh;\n\n\tif (!regl)\n\t\treturn oldh << 8;\n\n\tl = lm90_read_reg(client, regl);\n\tif (l < 0)\n\t\treturn l;\n\n\tif (!is_volatile)\n\t\treturn (oldh << 8) | l;\n\n\t \n\tnewh = lm90_read_reg(client, regh);\n\tif (newh < 0)\n\t\treturn newh;\n\tif (oldh != newh) {\n\t\tl = lm90_read_reg(client, regl);\n\t\tif (l < 0)\n\t\t\treturn l;\n\t}\n\treturn (newh << 8) | l;\n}\n\nstatic int lm90_update_confreg(struct lm90_data *data, u8 config)\n{\n\tif (data->config != config) {\n\t\tint err;\n\n\t\terr = lm90_write_reg(data->client, LM90_REG_CONFIG1, config);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata->config = config;\n\t}\n\treturn 0;\n}\n\n \nstatic int lm90_select_remote_channel(struct lm90_data *data, bool second)\n{\n\tu8 config = data->config & ~0x08;\n\n\tif (second)\n\t\tconfig |= 0x08;\n\n\treturn lm90_update_confreg(data, config);\n}\n\nstatic int lm90_write_convrate(struct lm90_data *data, int val)\n{\n\tu8 config = data->config;\n\tint err;\n\n\t \n\tif (data->flags & LM90_PAUSE_FOR_CONFIG) {\n\t\terr = lm90_update_confreg(data, config | 0x40);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = lm90_write_reg(data->client, LM90_REG_CONVRATE, val);\n\n\t \n\tlm90_update_confreg(data, config);\n\n\treturn err;\n}\n\n \nstatic int lm90_set_convrate(struct i2c_client *client, struct lm90_data *data,\n\t\t\t     unsigned int interval)\n{\n\tunsigned int update_interval;\n\tint i, err;\n\n\t \n\tinterval <<= 6;\n\n\t \n\tfor (i = 0, update_interval = LM90_MAX_CONVRATE_MS << 6;\n\t     i < data->max_convrate; i++, update_interval >>= 1)\n\t\tif (interval >= update_interval * 3 / 4)\n\t\t\tbreak;\n\n\terr = lm90_write_convrate(data, i);\n\tdata->update_interval = DIV_ROUND_CLOSEST(update_interval, 64);\n\treturn err;\n}\n\nstatic int lm90_set_faultqueue(struct i2c_client *client,\n\t\t\t       struct lm90_data *data, int val)\n{\n\tint err;\n\n\tif (data->faultqueue_mask) {\n\t\terr = lm90_update_confreg(data, val <= data->faultqueue_depth / 2 ?\n\t\t\t\t\t  data->config & ~data->faultqueue_mask :\n\t\t\t\t\t  data->config | data->faultqueue_mask);\n\t} else {\n\t\tstatic const u8 values[4] = {0, 2, 6, 0x0e};\n\n\t\tdata->conalert = (data->conalert & 0xf1) | values[val - 1];\n\t\terr = lm90_write_reg(data->client, TMP451_REG_CONALERT,\n\t\t\t\t     data->conalert);\n\t}\n\n\treturn err;\n}\n\nstatic int lm90_update_limits(struct device *dev)\n{\n\tstruct lm90_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint val;\n\n\tif (data->flags & LM90_HAVE_CRIT) {\n\t\tval = lm90_read_reg(client, LM90_REG_LOCAL_CRIT);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp[LOCAL_CRIT] = val << 8;\n\n\t\tval = lm90_read_reg(client, LM90_REG_REMOTE_CRIT);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp[REMOTE_CRIT] = val << 8;\n\n\t\tval = lm90_read_reg(client, LM90_REG_TCRIT_HYST);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp_hyst = val;\n\t}\n\tif ((data->flags & LM90_HAVE_FAULTQUEUE) && !data->faultqueue_mask) {\n\t\tval = lm90_read_reg(client, TMP451_REG_CONALERT);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->conalert = val;\n\t}\n\n\tval = lm90_read16(client, LM90_REG_REMOTE_LOWH,\n\t\t\t  (data->flags & LM90_HAVE_REM_LIMIT_EXT) ? LM90_REG_REMOTE_LOWL : 0,\n\t\t\t  false);\n\tif (val < 0)\n\t\treturn val;\n\tdata->temp[REMOTE_LOW] = val;\n\n\tval = lm90_read16(client, LM90_REG_REMOTE_HIGHH,\n\t\t\t  (data->flags & LM90_HAVE_REM_LIMIT_EXT) ? LM90_REG_REMOTE_HIGHL : 0,\n\t\t\t  false);\n\tif (val < 0)\n\t\treturn val;\n\tdata->temp[REMOTE_HIGH] = val;\n\n\tif (data->flags & LM90_HAVE_OFFSET) {\n\t\tval = lm90_read16(client, LM90_REG_REMOTE_OFFSH,\n\t\t\t\t  LM90_REG_REMOTE_OFFSL, false);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp[REMOTE_OFFSET] = val;\n\t}\n\n\tif (data->flags & LM90_HAVE_EMERGENCY) {\n\t\tval = lm90_read_reg(client, MAX6659_REG_LOCAL_EMERG);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp[LOCAL_EMERG] = val << 8;\n\n\t\tval = lm90_read_reg(client, MAX6659_REG_REMOTE_EMERG);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp[REMOTE_EMERG] = val << 8;\n\t}\n\n\tif (data->flags & LM90_HAVE_TEMP3) {\n\t\tval = lm90_select_remote_channel(data, true);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tval = lm90_read_reg(client, LM90_REG_REMOTE_CRIT);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp[REMOTE2_CRIT] = val << 8;\n\n\t\tif (data->flags & LM90_HAVE_EMERGENCY) {\n\t\t\tval = lm90_read_reg(client, MAX6659_REG_REMOTE_EMERG);\n\t\t\tif (val < 0)\n\t\t\t\treturn val;\n\t\t\tdata->temp[REMOTE2_EMERG] = val << 8;\n\t\t}\n\n\t\tval = lm90_read_reg(client, LM90_REG_REMOTE_LOWH);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp[REMOTE2_LOW] = val << 8;\n\n\t\tval = lm90_read_reg(client, LM90_REG_REMOTE_HIGHH);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp[REMOTE2_HIGH] = val << 8;\n\n\t\tif (data->flags & LM90_HAVE_OFFSET) {\n\t\t\tval = lm90_read16(client, LM90_REG_REMOTE_OFFSH,\n\t\t\t\t\t  LM90_REG_REMOTE_OFFSL, false);\n\t\t\tif (val < 0)\n\t\t\t\treturn val;\n\t\t\tdata->temp[REMOTE2_OFFSET] = val;\n\t\t}\n\n\t\tlm90_select_remote_channel(data, false);\n\t}\n\n\treturn 0;\n}\n\nstatic void lm90_report_alarms(struct work_struct *work)\n{\n\tstruct lm90_data *data = container_of(work, struct lm90_data, report_work);\n\tu16 cleared_alarms, new_alarms, current_alarms;\n\tstruct device *hwmon_dev = data->hwmon_dev;\n\tstruct device *dev = &data->client->dev;\n\tint st, st2;\n\n\tcurrent_alarms = data->current_alarms;\n\tcleared_alarms = data->reported_alarms & ~current_alarms;\n\tnew_alarms = current_alarms & ~data->reported_alarms;\n\n\tif (!cleared_alarms && !new_alarms)\n\t\treturn;\n\n\tst = new_alarms & 0xff;\n\tst2 = new_alarms >> 8;\n\n\tif ((st & (LM90_STATUS_LLOW | LM90_STATUS_LHIGH | LM90_STATUS_LTHRM)) ||\n\t    (st2 & MAX6696_STATUS2_LOT2))\n\t\tdev_dbg(dev, \"temp%d out of range, please check!\\n\", 1);\n\tif ((st & (LM90_STATUS_RLOW | LM90_STATUS_RHIGH | LM90_STATUS_RTHRM)) ||\n\t    (st2 & MAX6696_STATUS2_ROT2))\n\t\tdev_dbg(dev, \"temp%d out of range, please check!\\n\", 2);\n\tif (st & LM90_STATUS_ROPEN)\n\t\tdev_dbg(dev, \"temp%d diode open, please check!\\n\", 2);\n\tif (st2 & (MAX6696_STATUS2_R2LOW | MAX6696_STATUS2_R2HIGH |\n\t\t   MAX6696_STATUS2_R2THRM | MAX6696_STATUS2_R2OT2))\n\t\tdev_dbg(dev, \"temp%d out of range, please check!\\n\", 3);\n\tif (st2 & MAX6696_STATUS2_R2OPEN)\n\t\tdev_dbg(dev, \"temp%d diode open, please check!\\n\", 3);\n\n\tst |= cleared_alarms & 0xff;\n\tst2 |= cleared_alarms >> 8;\n\n\tif (st & LM90_STATUS_LLOW)\n\t\thwmon_notify_event(hwmon_dev, hwmon_temp, hwmon_temp_min_alarm, 0);\n\tif (st & LM90_STATUS_RLOW)\n\t\thwmon_notify_event(hwmon_dev, hwmon_temp, hwmon_temp_min_alarm, 1);\n\tif (st2 & MAX6696_STATUS2_R2LOW)\n\t\thwmon_notify_event(hwmon_dev, hwmon_temp, hwmon_temp_min_alarm, 2);\n\n\tif (st & LM90_STATUS_LHIGH)\n\t\thwmon_notify_event(hwmon_dev, hwmon_temp, hwmon_temp_max_alarm, 0);\n\tif (st & LM90_STATUS_RHIGH)\n\t\thwmon_notify_event(hwmon_dev, hwmon_temp, hwmon_temp_max_alarm, 1);\n\tif (st2 & MAX6696_STATUS2_R2HIGH)\n\t\thwmon_notify_event(hwmon_dev, hwmon_temp, hwmon_temp_max_alarm, 2);\n\n\tif (st & LM90_STATUS_LTHRM)\n\t\thwmon_notify_event(hwmon_dev, hwmon_temp, hwmon_temp_crit_alarm, 0);\n\tif (st & LM90_STATUS_RTHRM)\n\t\thwmon_notify_event(hwmon_dev, hwmon_temp, hwmon_temp_crit_alarm, 1);\n\tif (st2 & MAX6696_STATUS2_R2THRM)\n\t\thwmon_notify_event(hwmon_dev, hwmon_temp, hwmon_temp_crit_alarm, 2);\n\n\tif (st2 & MAX6696_STATUS2_LOT2)\n\t\thwmon_notify_event(hwmon_dev, hwmon_temp, hwmon_temp_emergency_alarm, 0);\n\tif (st2 & MAX6696_STATUS2_ROT2)\n\t\thwmon_notify_event(hwmon_dev, hwmon_temp, hwmon_temp_emergency_alarm, 1);\n\tif (st2 & MAX6696_STATUS2_R2OT2)\n\t\thwmon_notify_event(hwmon_dev, hwmon_temp, hwmon_temp_emergency_alarm, 2);\n\n\tdata->reported_alarms = current_alarms;\n}\n\nstatic int lm90_update_alarms_locked(struct lm90_data *data, bool force)\n{\n\tif (force || !data->alarms_valid ||\n\t    time_after(jiffies, data->alarms_updated + msecs_to_jiffies(data->update_interval))) {\n\t\tstruct i2c_client *client = data->client;\n\t\tbool check_enable;\n\t\tu16 alarms;\n\t\tint val;\n\n\t\tdata->alarms_valid = false;\n\n\t\tval = lm90_read_reg(client, LM90_REG_STATUS);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\talarms = val & ~LM90_STATUS_BUSY;\n\n\t\tif (data->reg_status2) {\n\t\t\tval = lm90_read_reg(client, data->reg_status2);\n\t\t\tif (val < 0)\n\t\t\t\treturn val;\n\t\t\talarms |= val << 8;\n\t\t}\n\t\t \n\t\tif (force && data->alarms_valid)\n\t\t\tdata->current_alarms |= alarms;\n\t\telse\n\t\t\tdata->current_alarms = alarms;\n\t\tdata->alarms |= alarms;\n\n\t\tcheck_enable = (client->irq || !(data->config_orig & 0x80)) &&\n\t\t\t(data->config & 0x80);\n\n\t\tif (force || check_enable)\n\t\t\tschedule_work(&data->report_work);\n\n\t\t \n\t\tif (check_enable) {\n\t\t\tif (!(data->current_alarms & data->alert_alarms)) {\n\t\t\t\tdev_dbg(&client->dev, \"Re-enabling ALERT#\\n\");\n\t\t\t\tlm90_update_confreg(data, data->config & ~0x80);\n\t\t\t\t \n\t\t\t\tcancel_delayed_work(&data->alert_work);\n\t\t\t} else {\n\t\t\t\tschedule_delayed_work(&data->alert_work,\n\t\t\t\t\tmax_t(int, HZ, msecs_to_jiffies(data->update_interval)));\n\t\t\t}\n\t\t}\n\t\tdata->alarms_updated = jiffies;\n\t\tdata->alarms_valid = true;\n\t}\n\treturn 0;\n}\n\nstatic int lm90_update_alarms(struct lm90_data *data, bool force)\n{\n\tint err;\n\n\tmutex_lock(&data->update_lock);\n\terr = lm90_update_alarms_locked(data, force);\n\tmutex_unlock(&data->update_lock);\n\n\treturn err;\n}\n\nstatic void lm90_alert_work(struct work_struct *__work)\n{\n\tstruct delayed_work *delayed_work = container_of(__work, struct delayed_work, work);\n\tstruct lm90_data *data = container_of(delayed_work, struct lm90_data, alert_work);\n\n\t \n\tif (!(data->config & 0x80))\n\t\treturn;\n\n\tlm90_update_alarms(data, true);\n}\n\nstatic int lm90_update_device(struct device *dev)\n{\n\tstruct lm90_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long next_update;\n\tint val;\n\n\tif (!data->valid) {\n\t\tval = lm90_update_limits(dev);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t}\n\n\tnext_update = data->last_updated +\n\t\t      msecs_to_jiffies(data->update_interval);\n\tif (time_after(jiffies, next_update) || !data->valid) {\n\t\tdev_dbg(&client->dev, \"Updating lm90 data.\\n\");\n\n\t\tdata->valid = false;\n\n\t\tval = lm90_read_reg(client, LM90_REG_LOCAL_LOW);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp[LOCAL_LOW] = val << 8;\n\n\t\tval = lm90_read_reg(client, LM90_REG_LOCAL_HIGH);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp[LOCAL_HIGH] = val << 8;\n\n\t\tval = lm90_read16(client, LM90_REG_LOCAL_TEMP,\n\t\t\t\t  data->reg_local_ext, true);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp[LOCAL_TEMP] = val;\n\t\tval = lm90_read16(client, LM90_REG_REMOTE_TEMPH,\n\t\t\t\t  data->reg_remote_ext, true);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp[REMOTE_TEMP] = val;\n\n\t\tif (data->flags & LM90_HAVE_TEMP3) {\n\t\t\tval = lm90_select_remote_channel(data, true);\n\t\t\tif (val < 0)\n\t\t\t\treturn val;\n\n\t\t\tval = lm90_read16(client, LM90_REG_REMOTE_TEMPH,\n\t\t\t\t\t  data->reg_remote_ext, true);\n\t\t\tif (val < 0) {\n\t\t\t\tlm90_select_remote_channel(data, false);\n\t\t\t\treturn val;\n\t\t\t}\n\t\t\tdata->temp[REMOTE2_TEMP] = val;\n\n\t\t\tlm90_select_remote_channel(data, false);\n\t\t}\n\n\t\tval = lm90_update_alarms_locked(data, false);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\treturn 0;\n}\n\n \nstatic ssize_t pec_show(struct device *dev, struct device_attribute *dummy,\n\t\t\tchar *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\treturn sprintf(buf, \"%d\\n\", !!(client->flags & I2C_CLIENT_PEC));\n}\n\nstatic ssize_t pec_store(struct device *dev, struct device_attribute *dummy,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (val) {\n\tcase 0:\n\t\tclient->flags &= ~I2C_CLIENT_PEC;\n\t\tbreak;\n\tcase 1:\n\t\tclient->flags |= I2C_CLIENT_PEC;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(pec);\n\nstatic int lm90_temp_get_resolution(struct lm90_data *data, int index)\n{\n\tswitch (index) {\n\tcase REMOTE_TEMP:\n\t\tif (data->reg_remote_ext)\n\t\t\treturn data->resolution;\n\t\treturn 8;\n\tcase REMOTE_OFFSET:\n\tcase REMOTE2_OFFSET:\n\tcase REMOTE2_TEMP:\n\t\treturn data->resolution;\n\tcase LOCAL_TEMP:\n\t\tif (data->reg_local_ext)\n\t\t\treturn data->resolution;\n\t\treturn 8;\n\tcase REMOTE_LOW:\n\tcase REMOTE_HIGH:\n\tcase REMOTE2_LOW:\n\tcase REMOTE2_HIGH:\n\t\tif (data->flags & LM90_HAVE_REM_LIMIT_EXT)\n\t\t\treturn data->resolution;\n\t\treturn 8;\n\tdefault:\n\t\treturn 8;\n\t}\n}\n\nstatic int lm90_temp_from_reg(u32 flags, u16 regval, u8 resolution)\n{\n\tint val;\n\n\tif (flags & LM90_HAVE_EXTENDED_TEMP)\n\t\tval = regval - 0x4000;\n\telse if (flags & (LM90_HAVE_UNSIGNED_TEMP | LM90_HAVE_EXT_UNSIGNED))\n\t\tval = regval;\n\telse\n\t\tval = (s16)regval;\n\n\treturn ((val >> (16 - resolution)) * 1000) >> (resolution - 8);\n}\n\nstatic int lm90_get_temp(struct lm90_data *data, int index, int channel)\n{\n\tint temp = lm90_temp_from_reg(data->flags, data->temp[index],\n\t\t\t\t      lm90_temp_get_resolution(data, index));\n\n\t \n\tif (data->kind == lm99 && channel)\n\t\ttemp += 16000;\n\n\treturn temp;\n}\n\nstatic u16 lm90_temp_to_reg(u32 flags, long val, u8 resolution)\n{\n\tint fraction = resolution > 8 ?\n\t\t\t1000 - DIV_ROUND_CLOSEST(1000, BIT(resolution - 8)) : 0;\n\n\tif (flags & LM90_HAVE_EXTENDED_TEMP) {\n\t\tval = clamp_val(val, -64000, 191000 + fraction);\n\t\tval += 64000;\n\t} else if (flags & LM90_HAVE_EXT_UNSIGNED) {\n\t\tval = clamp_val(val, 0, 255000 + fraction);\n\t} else if (flags & LM90_HAVE_UNSIGNED_TEMP) {\n\t\tval = clamp_val(val, 0, 127000 + fraction);\n\t} else {\n\t\tval = clamp_val(val, -128000, 127000 + fraction);\n\t}\n\n\treturn DIV_ROUND_CLOSEST(val << (resolution - 8), 1000) << (16 - resolution);\n}\n\nstatic int lm90_set_temp(struct lm90_data *data, int index, int channel, long val)\n{\n\tstatic const u8 regs[] = {\n\t\t[LOCAL_LOW] = LM90_REG_LOCAL_LOW,\n\t\t[LOCAL_HIGH] = LM90_REG_LOCAL_HIGH,\n\t\t[LOCAL_CRIT] = LM90_REG_LOCAL_CRIT,\n\t\t[REMOTE_CRIT] = LM90_REG_REMOTE_CRIT,\n\t\t[LOCAL_EMERG] = MAX6659_REG_LOCAL_EMERG,\n\t\t[REMOTE_EMERG] = MAX6659_REG_REMOTE_EMERG,\n\t\t[REMOTE2_CRIT] = LM90_REG_REMOTE_CRIT,\n\t\t[REMOTE2_EMERG] = MAX6659_REG_REMOTE_EMERG,\n\t\t[REMOTE_LOW] = LM90_REG_REMOTE_LOWH,\n\t\t[REMOTE_HIGH] = LM90_REG_REMOTE_HIGHH,\n\t\t[REMOTE2_LOW] = LM90_REG_REMOTE_LOWH,\n\t\t[REMOTE2_HIGH] = LM90_REG_REMOTE_HIGHH,\n\t};\n\tstruct i2c_client *client = data->client;\n\tu8 regh = regs[index];\n\tu8 regl = 0;\n\tint err;\n\n\tif (channel && (data->flags & LM90_HAVE_REM_LIMIT_EXT)) {\n\t\tif (index == REMOTE_LOW || index == REMOTE2_LOW)\n\t\t\tregl = LM90_REG_REMOTE_LOWL;\n\t\telse if (index == REMOTE_HIGH || index == REMOTE2_HIGH)\n\t\t\tregl = LM90_REG_REMOTE_HIGHL;\n\t}\n\n\t \n\tif (data->kind == lm99 && channel) {\n\t\t \n\t\tval = max(val, -128000l);\n\t\tval -= 16000;\n\t}\n\n\tdata->temp[index] = lm90_temp_to_reg(data->flags, val,\n\t\t\t\t\t     lm90_temp_get_resolution(data, index));\n\n\tif (channel > 1)\n\t\tlm90_select_remote_channel(data, true);\n\n\terr = lm90_write16(client, regh, regl, data->temp[index]);\n\n\tif (channel > 1)\n\t\tlm90_select_remote_channel(data, false);\n\n\treturn err;\n}\n\nstatic int lm90_get_temphyst(struct lm90_data *data, int index, int channel)\n{\n\tint temp = lm90_get_temp(data, index, channel);\n\n\treturn temp - data->temp_hyst * 1000;\n}\n\nstatic int lm90_set_temphyst(struct lm90_data *data, long val)\n{\n\tint temp = lm90_get_temp(data, LOCAL_CRIT, 0);\n\n\t \n\tval = clamp_val(val, -128000l, 255000l);\n\tdata->temp_hyst = clamp_val(DIV_ROUND_CLOSEST(temp - val, 1000), 0, 31);\n\n\treturn lm90_write_reg(data->client, LM90_REG_TCRIT_HYST, data->temp_hyst);\n}\n\nstatic int lm90_get_temp_offset(struct lm90_data *data, int index)\n{\n\tint res = lm90_temp_get_resolution(data, index);\n\n\treturn lm90_temp_from_reg(0, data->temp[index], res);\n}\n\nstatic int lm90_set_temp_offset(struct lm90_data *data, int index, int channel, long val)\n{\n\tint err;\n\n\tval = lm90_temp_to_reg(0, val, lm90_temp_get_resolution(data, index));\n\n\t \n\tif (channel > 1)\n\t\tlm90_select_remote_channel(data, true);\n\n\terr = lm90_write16(data->client, LM90_REG_REMOTE_OFFSH, LM90_REG_REMOTE_OFFSL, val);\n\n\tif (channel > 1)\n\t\tlm90_select_remote_channel(data, false);\n\n\tif (err)\n\t\treturn err;\n\n\tdata->temp[index] = val;\n\n\treturn 0;\n}\n\nstatic const u8 lm90_temp_index[MAX_CHANNELS] = {\n\tLOCAL_TEMP, REMOTE_TEMP, REMOTE2_TEMP\n};\n\nstatic const u8 lm90_temp_min_index[MAX_CHANNELS] = {\n\tLOCAL_LOW, REMOTE_LOW, REMOTE2_LOW\n};\n\nstatic const u8 lm90_temp_max_index[MAX_CHANNELS] = {\n\tLOCAL_HIGH, REMOTE_HIGH, REMOTE2_HIGH\n};\n\nstatic const u8 lm90_temp_crit_index[MAX_CHANNELS] = {\n\tLOCAL_CRIT, REMOTE_CRIT, REMOTE2_CRIT\n};\n\nstatic const u8 lm90_temp_emerg_index[MAX_CHANNELS] = {\n\tLOCAL_EMERG, REMOTE_EMERG, REMOTE2_EMERG\n};\n\nstatic const s8 lm90_temp_offset_index[MAX_CHANNELS] = {\n\t-1, REMOTE_OFFSET, REMOTE2_OFFSET\n};\n\nstatic const u16 lm90_min_alarm_bits[MAX_CHANNELS] = { BIT(5), BIT(3), BIT(11) };\nstatic const u16 lm90_max_alarm_bits[MAX_CHANNELS] = { BIT(6), BIT(4), BIT(12) };\nstatic const u16 lm90_crit_alarm_bits[MAX_CHANNELS] = { BIT(0), BIT(1), BIT(9) };\nstatic const u16 lm90_crit_alarm_bits_swapped[MAX_CHANNELS] = { BIT(1), BIT(0), BIT(9) };\nstatic const u16 lm90_emergency_alarm_bits[MAX_CHANNELS] = { BIT(15), BIT(13), BIT(14) };\nstatic const u16 lm90_fault_bits[MAX_CHANNELS] = { BIT(0), BIT(2), BIT(10) };\n\nstatic int lm90_temp_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct lm90_data *data = dev_get_drvdata(dev);\n\tint err;\n\tu16 bit;\n\n\tmutex_lock(&data->update_lock);\n\terr = lm90_update_device(dev);\n\tmutex_unlock(&data->update_lock);\n\tif (err)\n\t\treturn err;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\t*val = lm90_get_temp(data, lm90_temp_index[channel], channel);\n\t\tbreak;\n\tcase hwmon_temp_min_alarm:\n\tcase hwmon_temp_max_alarm:\n\tcase hwmon_temp_crit_alarm:\n\tcase hwmon_temp_emergency_alarm:\n\tcase hwmon_temp_fault:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_min_alarm:\n\t\t\tbit = lm90_min_alarm_bits[channel];\n\t\t\tbreak;\n\t\tcase hwmon_temp_max_alarm:\n\t\t\tbit = lm90_max_alarm_bits[channel];\n\t\t\tbreak;\n\t\tcase hwmon_temp_crit_alarm:\n\t\t\tif (data->flags & LM90_HAVE_CRIT_ALRM_SWP)\n\t\t\t\tbit = lm90_crit_alarm_bits_swapped[channel];\n\t\t\telse\n\t\t\t\tbit = lm90_crit_alarm_bits[channel];\n\t\t\tbreak;\n\t\tcase hwmon_temp_emergency_alarm:\n\t\t\tbit = lm90_emergency_alarm_bits[channel];\n\t\t\tbreak;\n\t\tcase hwmon_temp_fault:\n\t\t\tbit = lm90_fault_bits[channel];\n\t\t\tbreak;\n\t\t}\n\t\t*val = !!(data->alarms & bit);\n\t\tdata->alarms &= ~bit;\n\t\tdata->alarms |= data->current_alarms;\n\t\tbreak;\n\tcase hwmon_temp_min:\n\t\t*val = lm90_get_temp(data, lm90_temp_min_index[channel], channel);\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\t*val = lm90_get_temp(data, lm90_temp_max_index[channel], channel);\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\t*val = lm90_get_temp(data, lm90_temp_crit_index[channel], channel);\n\t\tbreak;\n\tcase hwmon_temp_crit_hyst:\n\t\t*val = lm90_get_temphyst(data, lm90_temp_crit_index[channel], channel);\n\t\tbreak;\n\tcase hwmon_temp_emergency:\n\t\t*val = lm90_get_temp(data, lm90_temp_emerg_index[channel], channel);\n\t\tbreak;\n\tcase hwmon_temp_emergency_hyst:\n\t\t*val = lm90_get_temphyst(data, lm90_temp_emerg_index[channel], channel);\n\t\tbreak;\n\tcase hwmon_temp_offset:\n\t\t*val = lm90_get_temp_offset(data, lm90_temp_offset_index[channel]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int lm90_temp_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct lm90_data *data = dev_get_drvdata(dev);\n\tint err;\n\n\tmutex_lock(&data->update_lock);\n\n\terr = lm90_update_device(dev);\n\tif (err)\n\t\tgoto error;\n\n\tswitch (attr) {\n\tcase hwmon_temp_min:\n\t\terr = lm90_set_temp(data, lm90_temp_min_index[channel],\n\t\t\t\t    channel, val);\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\terr = lm90_set_temp(data, lm90_temp_max_index[channel],\n\t\t\t\t    channel, val);\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\terr = lm90_set_temp(data, lm90_temp_crit_index[channel],\n\t\t\t\t    channel, val);\n\t\tbreak;\n\tcase hwmon_temp_crit_hyst:\n\t\terr = lm90_set_temphyst(data, val);\n\t\tbreak;\n\tcase hwmon_temp_emergency:\n\t\terr = lm90_set_temp(data, lm90_temp_emerg_index[channel],\n\t\t\t\t    channel, val);\n\t\tbreak;\n\tcase hwmon_temp_offset:\n\t\terr = lm90_set_temp_offset(data, lm90_temp_offset_index[channel],\n\t\t\t\t\t   channel, val);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\nerror:\n\tmutex_unlock(&data->update_lock);\n\n\treturn err;\n}\n\nstatic umode_t lm90_temp_is_visible(const void *data, u32 attr, int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_min_alarm:\n\tcase hwmon_temp_max_alarm:\n\tcase hwmon_temp_crit_alarm:\n\tcase hwmon_temp_emergency_alarm:\n\tcase hwmon_temp_emergency_hyst:\n\tcase hwmon_temp_fault:\n\tcase hwmon_temp_label:\n\t\treturn 0444;\n\tcase hwmon_temp_min:\n\tcase hwmon_temp_max:\n\tcase hwmon_temp_crit:\n\tcase hwmon_temp_emergency:\n\tcase hwmon_temp_offset:\n\t\treturn 0644;\n\tcase hwmon_temp_crit_hyst:\n\t\tif (channel == 0)\n\t\t\treturn 0644;\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int lm90_chip_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct lm90_data *data = dev_get_drvdata(dev);\n\tint err;\n\n\tmutex_lock(&data->update_lock);\n\terr = lm90_update_device(dev);\n\tmutex_unlock(&data->update_lock);\n\tif (err)\n\t\treturn err;\n\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\t*val = data->update_interval;\n\t\tbreak;\n\tcase hwmon_chip_alarms:\n\t\t*val = data->alarms;\n\t\tbreak;\n\tcase hwmon_chip_temp_samples:\n\t\tif (data->faultqueue_mask) {\n\t\t\t*val = (data->config & data->faultqueue_mask) ?\n\t\t\t\tdata->faultqueue_depth : 1;\n\t\t} else {\n\t\t\tswitch (data->conalert & 0x0e) {\n\t\t\tcase 0x0:\n\t\t\tdefault:\n\t\t\t\t*val = 1;\n\t\t\t\tbreak;\n\t\t\tcase 0x2:\n\t\t\t\t*val = 2;\n\t\t\t\tbreak;\n\t\t\tcase 0x6:\n\t\t\t\t*val = 3;\n\t\t\t\tbreak;\n\t\t\tcase 0xe:\n\t\t\t\t*val = 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int lm90_chip_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct lm90_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint err;\n\n\tmutex_lock(&data->update_lock);\n\n\terr = lm90_update_device(dev);\n\tif (err)\n\t\tgoto error;\n\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\terr = lm90_set_convrate(client, data,\n\t\t\t\t\tclamp_val(val, 0, 100000));\n\t\tbreak;\n\tcase hwmon_chip_temp_samples:\n\t\terr = lm90_set_faultqueue(client, data, clamp_val(val, 1, 4));\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\nerror:\n\tmutex_unlock(&data->update_lock);\n\n\treturn err;\n}\n\nstatic umode_t lm90_chip_is_visible(const void *data, u32 attr, int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\tcase hwmon_chip_temp_samples:\n\t\treturn 0644;\n\tcase hwmon_chip_alarms:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int lm90_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t     u32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn lm90_chip_read(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn lm90_temp_read(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lm90_read_string(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t    u32 attr, int channel, const char **str)\n{\n\tstruct lm90_data *data = dev_get_drvdata(dev);\n\n\t*str = data->channel_label[channel];\n\n\treturn 0;\n}\n\nstatic int lm90_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t      u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn lm90_chip_write(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn lm90_temp_write(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t lm90_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t       u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn lm90_chip_is_visible(data, attr, channel);\n\tcase hwmon_temp:\n\t\treturn lm90_temp_is_visible(data, attr, channel);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const char *lm90_detect_lm84(struct i2c_client *client)\n{\n\tstatic const u8 regs[] = {\n\t\tLM90_REG_STATUS, LM90_REG_LOCAL_TEMP, LM90_REG_LOCAL_HIGH,\n\t\tLM90_REG_REMOTE_TEMPH, LM90_REG_REMOTE_HIGHH\n\t};\n\tint status = i2c_smbus_read_byte_data(client, LM90_REG_STATUS);\n\tint reg1, reg2, reg3, reg4;\n\tbool nonzero = false;\n\tu8 ff = 0xff;\n\tint i;\n\n\tif (status < 0 || (status & 0xab))\n\t\treturn NULL;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(regs); i++) {\n\t\treg1 = i2c_smbus_read_byte_data(client, regs[i]);\n\t\treg2 = i2c_smbus_read_byte_data(client, LM90_REG_REMOTE_TEMPL);\n\t\treg3 = i2c_smbus_read_byte_data(client, LM90_REG_LOCAL_LOW);\n\t\treg4 = i2c_smbus_read_byte_data(client, LM90_REG_REMOTE_LOWH);\n\n\t\tif (reg1 < 0)\n\t\t\treturn NULL;\n\n\t\t \n\t\tif (reg2 != reg1 || reg3 != reg1 || reg4 != reg1)\n\t\t\treturn NULL;\n\n\t\tnonzero |= reg1 || reg2 || reg3 || reg4;\n\t\tff &= reg1;\n\t}\n\t \n\treturn nonzero && ff != 0xff ? \"lm84\" : NULL;\n}\n\nstatic const char *lm90_detect_max1617(struct i2c_client *client, int config1)\n{\n\tint status = i2c_smbus_read_byte_data(client, LM90_REG_STATUS);\n\tint llo, rlo, lhi, rhi;\n\n\tif (status < 0 || (status & 0x03))\n\t\treturn NULL;\n\n\tif (config1 & 0x3f)\n\t\treturn NULL;\n\n\t \n\tif (i2c_smbus_read_byte_data(client, LM90_REG_REMOTE_TEMPL) != 0xff ||\n\t    i2c_smbus_read_byte_data(client, MAX6657_REG_LOCAL_TEMPL) != 0xff ||\n\t    i2c_smbus_read_byte_data(client, LM90_REG_REMOTE_LOWL) != 0xff ||\n\t    i2c_smbus_read_byte(client) != 0xff)\n\t\treturn NULL;\n\n\tllo = i2c_smbus_read_byte_data(client, LM90_REG_LOCAL_LOW);\n\trlo = i2c_smbus_read_byte_data(client, LM90_REG_REMOTE_LOWH);\n\n\tlhi = i2c_smbus_read_byte_data(client, LM90_REG_LOCAL_HIGH);\n\trhi = i2c_smbus_read_byte_data(client, LM90_REG_REMOTE_HIGHH);\n\n\tif (llo < 0 || rlo < 0)\n\t\treturn NULL;\n\n\t \n\tif (i2c_smbus_read_byte(client) != rhi)\n\t\treturn NULL;\n\n\t \n\n\t \n\tif ((s8)lhi < 0 || (s8)rhi < 0)\n\t\treturn NULL;\n\n\t \n\tif ((s8)llo >= lhi || (s8)rlo >= rhi)\n\t\treturn NULL;\n\n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA)) {\n\t\t \n\t\tif (i2c_smbus_read_word_data(client, LM90_REG_REMOTE_TEMPL) !=\n\t\t\t\t\t\t0xffff)\n\t\t\treturn NULL;\n\t\tif (i2c_smbus_read_word_data(client, LM90_REG_CONFIG1) !=\n\t\t\t\t\t\t(config1 | 0xff00))\n\t\t\treturn NULL;\n\t\tif (i2c_smbus_read_word_data(client, LM90_REG_LOCAL_HIGH) !=\n\t\t\t\t\t\t(lhi | 0xff00))\n\t\t\treturn NULL;\n\t}\n\n\treturn \"max1617\";\n}\n\nstatic const char *lm90_detect_national(struct i2c_client *client, int chip_id,\n\t\t\t\t\tint config1, int convrate)\n{\n\tint config2 = i2c_smbus_read_byte_data(client, LM90_REG_CONFIG2);\n\tint address = client->addr;\n\tconst char *name = NULL;\n\n\tif (config2 < 0)\n\t\treturn NULL;\n\n\tif ((config1 & 0x2a) || (config2 & 0xf8) || convrate > 0x09)\n\t\treturn NULL;\n\n\tif (address != 0x4c && address != 0x4d)\n\t\treturn NULL;\n\n\tswitch (chip_id & 0xf0) {\n\tcase 0x10:\t \n\t\tif (address == 0x4c)\n\t\t\tname = \"lm86\";\n\t\tbreak;\n\tcase 0x20:\t \n\t\tif (address == 0x4c)\n\t\t\tname = \"lm90\";\n\t\tbreak;\n\tcase 0x30:\t \n\t\tname = \"lm99\";\t \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn name;\n}\n\nstatic const char *lm90_detect_on(struct i2c_client *client, int chip_id, int config1,\n\t\t\t\t  int convrate)\n{\n\tint address = client->addr;\n\tconst char *name = NULL;\n\n\tswitch (chip_id) {\n\tcase 0xca:\t\t \n\t\tif ((address == 0x4c || address == 0x4d) && !(config1 & 0x1b) &&\n\t\t    convrate <= 0x0a)\n\t\t\tname = \"nct218\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn name;\n}\n\nstatic const char *lm90_detect_analog(struct i2c_client *client, bool common_address,\n\t\t\t\t      int chip_id, int config1, int convrate)\n{\n\tint status = i2c_smbus_read_byte_data(client, LM90_REG_STATUS);\n\tint config2 = i2c_smbus_read_byte_data(client, ADT7481_REG_CONFIG2);\n\tint man_id2 = i2c_smbus_read_byte_data(client, ADT7481_REG_MAN_ID);\n\tint chip_id2 = i2c_smbus_read_byte_data(client, ADT7481_REG_CHIP_ID);\n\tint address = client->addr;\n\tconst char *name = NULL;\n\n\tif (status < 0 || config2 < 0 || man_id2 < 0 || chip_id2 < 0)\n\t\treturn NULL;\n\n\t \n\tswitch (chip_id) {\n\tcase 0x00 ... 0x03:\t \n\tcase 0x05 ... 0x0f:\n\t\tif (man_id2 == 0x00 && chip_id2 == 0x00 && common_address &&\n\t\t    !(status & 0x03) && !(config1 & 0x3f) && !(convrate & 0xf8))\n\t\t\tname = \"adm1021\";\n\t\tbreak;\n\tcase 0x04:\t\t \n\t\tif (man_id2 == 0x41 && chip_id2 == 0x21 &&\n\t\t    (address == 0x4c || address == 0x4d) &&\n\t\t    (config1 & 0x0b) == 0x08 && convrate <= 0x0a)\n\t\t\tname = \"adt7421\";\n\t\tbreak;\n\tcase 0x30 ... 0x38:\t \n\tcase 0x3a ... 0x3e:\n\t\t \n\t\tif (man_id2 == 0x00 && chip_id2 == 0x00 && common_address &&\n\t\t    !(status & 0x03) && !(config1 & 0x3f) && !(convrate & 0xf8))\n\t\t\tname = \"adm1023\";\n\t\tbreak;\n\tcase 0x39:\t\t \n\t\tif (man_id2 == 0x00 && chip_id2 == 0x00 &&\n\t\t    (address == 0x4c || address == 0x4d || address == 0x4e) &&\n\t\t    !(status & 0x03) && !(config1 & 0x3f) && !(convrate & 0xf8))\n\t\t\tname = \"adm1020\";\n\t\tbreak;\n\tcase 0x3f:\t\t \n\t\tif (man_id2 == 0x00 && chip_id2 == 0x00 && common_address &&\n\t\t    !(status & 0x03) && !(config1 & 0x3f) && !(convrate & 0xf8))\n\t\t\tname = \"nct210\";\n\t\tbreak;\n\tcase 0x40 ... 0x4f:\t \n\t\tif (man_id2 == 0x00 && chip_id2 == 0x00 &&\n\t\t    (address == 0x4c || address == 0x4d) && !(config1 & 0x3f) &&\n\t\t    convrate <= 0x0a)\n\t\t\tname = \"adm1032\";\n\t\tbreak;\n\tcase 0x51:\t \n\t\tif (man_id2 == 0x00 && chip_id2 == 0x00 &&\n\t\t    (address == 0x4c || address == 0x4d) && !(config1 & 0x1b) &&\n\t\t    convrate <= 0x0a)\n\t\t\tname = \"adt7461\";\n\t\tbreak;\n\tcase 0x54:\t \n\t\tif (man_id2 == 0x41 && chip_id2 == 0x61 &&\n\t\t    (address == 0x4c || address == 0x4d) && !(config1 & 0x1b) &&\n\t\t    convrate <= 0x0a)\n\t\t\tname = \"nct1008\";\n\t\tbreak;\n\tcase 0x55:\t \n\t\tif (man_id2 == 0x41 && chip_id2 == 0x61 &&\n\t\t    (address == 0x4c || address == 0x4d) && !(config1 & 0x1b) &&\n\t\t    convrate <= 0x0a)\n\t\t\tname = \"nct72\";\n\t\tbreak;\n\tcase 0x57:\t \n\t\tif (man_id2 == 0x41 && chip_id2 == 0x61 &&\n\t\t    (address == 0x4c || address == 0x4d) && !(config1 & 0x1b) &&\n\t\t    convrate <= 0x0a)\n\t\t\tname = \"adt7461a\";\n\t\tbreak;\n\tcase 0x5a:\t \n\t\tif (man_id2 == 0x41 && chip_id2 == 0x61 &&\n\t\t    common_address && !(config1 & 0x1b) && convrate <= 0x0a)\n\t\t\tname = \"nct214\";\n\t\tbreak;\n\tcase 0x62:\t \n\t\tif (man_id2 == 0x41 && chip_id2 == 0x81 &&\n\t\t    (address == 0x4b || address == 0x4c) && !(config1 & 0x10) &&\n\t\t    !(config2 & 0x7f) && (convrate & 0x0f) <= 0x0b) {\n\t\t\tname = \"adt7481\";\n\t\t}\n\t\tbreak;\n\tcase 0x65:\t \n\tcase 0x75:\t \n\t\tif (man_id2 == 0x41 && chip_id2 == 0x82 &&\n\t\t    address == 0x4c && !(config1 & 0x10) && !(config2 & 0x7f) &&\n\t\t    convrate <= 0x0a)\n\t\t\tname = \"adt7482\";\n\t\tbreak;\n\tcase 0x94:\t \n\t\tif (man_id2 == 0x41 && chip_id2 == 0x83 &&\n\t\t    common_address &&\n\t\t    ((address >= 0x18 && address <= 0x1a) ||\n\t\t     (address >= 0x29 && address <= 0x2b) ||\n\t\t     (address >= 0x4c && address <= 0x4e)) &&\n\t\t    !(config1 & 0x10) && !(config2 & 0x7f) && convrate <= 0x0a)\n\t\t\tname = \"adt7483a\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn name;\n}\n\nstatic const char *lm90_detect_maxim(struct i2c_client *client, bool common_address,\n\t\t\t\t     int chip_id, int config1, int convrate)\n{\n\tint man_id, emerg, emerg2, status2;\n\tint address = client->addr;\n\tconst char *name = NULL;\n\n\tswitch (chip_id) {\n\tcase 0x01:\n\t\tif (!common_address)\n\t\t\tbreak;\n\n\t\t \n\t\temerg = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t MAX6659_REG_REMOTE_EMERG);\n\t\tman_id = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t  LM90_REG_MAN_ID);\n\t\temerg2 = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t  MAX6659_REG_REMOTE_EMERG);\n\t\tstatus2 = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t   MAX6696_REG_STATUS2);\n\t\tif (emerg < 0 || man_id < 0 || emerg2 < 0 || status2 < 0)\n\t\t\treturn NULL;\n\n\t\t \n\t\tif (!(config1 & 0x10) && !(status2 & 0x01) && emerg == emerg2 &&\n\t\t    convrate <= 0x07)\n\t\t\tname = \"max6696\";\n\t\t \n\t\telse if (!(config1 & 0x03) && convrate <= 0x07 &&\n\t\t\t emerg2 == man_id && emerg2 != status2)\n\t\t\tname = \"max6680\";\n\t\t \n\t\telse if (!(config1 & 0x03f) && convrate <= 0x07 &&\n\t\t\t emerg == 0x01 && emerg2 == 0x01 && status2 == 0x01)\n\t\t\tname = \"max1617\";\n\t\tbreak;\n\tcase 0x08:\n\t\t \n\t\tif (common_address && !(config1 & 0x07) && convrate <= 0x07)\n\t\t\tname = \"max6654\";\n\t\tbreak;\n\tcase 0x09:\n\t\t \n\t\tif (common_address && !(config1 & 0x07) && convrate <= 0x07)\n\t\t\tname = \"max6690\";\n\t\tbreak;\n\tcase 0x4d:\n\t\t \n\t\tif (address >= 0x48 && address <= 0x4f && config1 == convrate &&\n\t\t    !(config1 & 0x0f)) {\n\t\t\tint regval;\n\n\t\t\t \n\n\t\t\t \n\t\t\tif (i2c_smbus_read_byte_data(client, LM90_REG_MAN_ID) != 0x4d)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (i2c_smbus_read_byte_data(client, LM90_REG_CONVRATE) != 0x4d ||\n\t\t\t    i2c_smbus_read_byte_data(client, LM90_REG_LOCAL_LOW) != 0x4d ||\n\t\t\t    i2c_smbus_read_byte_data(client, LM90_REG_REMOTE_LOWH) != 0x4d)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tregval = i2c_smbus_read_byte_data(client, LM90_REG_STATUS);\n\t\t\tif (regval < 0 || (regval & 0x2b))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (i2c_smbus_read_byte_data(client, LM90_REG_CONVRATE) != regval ||\n\t\t\t    i2c_smbus_read_byte_data(client, LM90_REG_LOCAL_LOW) != regval ||\n\t\t\t    i2c_smbus_read_byte_data(client, LM90_REG_REMOTE_LOWH) != regval)\n\t\t\t\tbreak;\n\n\t\t\tname = \"max6642\";\n\t\t} else if ((address == 0x4c || address == 0x4d || address == 0x4e) &&\n\t\t\t   (config1 & 0x1f) == 0x0d && convrate <= 0x09) {\n\t\t\tif (address == 0x4c)\n\t\t\t\tname = \"max6657\";\n\t\t\telse\n\t\t\t\tname = \"max6659\";\n\t\t}\n\t\tbreak;\n\tcase 0x59:\n\t\t \n\t\tif (!(config1 & 0x3f) && convrate <= 0x07) {\n\t\t\tint temp;\n\n\t\t\tswitch (address) {\n\t\t\tcase 0x4c:\n\t\t\t\t \n\t\t\t\ttemp = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t\t\tLM90_REG_REMOTE_TEMPH);\n\t\t\t\tif (temp == 0x80)\n\t\t\t\t\tname = \"max6648\";\n\t\t\t\telse\n\t\t\t\t\tname = \"max6649\";\n\t\t\t\tbreak;\n\t\t\tcase 0x4d:\n\t\t\t\tname = \"max6646\";\n\t\t\t\tbreak;\n\t\t\tcase 0x4e:\n\t\t\t\tname = \"max6647\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn name;\n}\n\nstatic const char *lm90_detect_nuvoton(struct i2c_client *client, int chip_id,\n\t\t\t\t       int config1, int convrate)\n{\n\tint config2 = i2c_smbus_read_byte_data(client, LM90_REG_CONFIG2);\n\tint address = client->addr;\n\tconst char *name = NULL;\n\n\tif (config2 < 0)\n\t\treturn NULL;\n\n\tif (address == 0x4c && !(config1 & 0x2a) && !(config2 & 0xf8)) {\n\t\tif (chip_id == 0x01 && convrate <= 0x09) {\n\t\t\t \n\t\t\tname = \"w83l771\";\n\t\t} else if ((chip_id & 0xfe) == 0x10 && convrate <= 0x08) {\n\t\t\t \n\t\t\tname = \"w83l771\";\n\t\t}\n\t}\n\treturn name;\n}\n\nstatic const char *lm90_detect_nxp(struct i2c_client *client, bool common_address,\n\t\t\t\t   int chip_id, int config1, int convrate)\n{\n\tint address = client->addr;\n\tconst char *name = NULL;\n\tint config2;\n\n\tswitch (chip_id) {\n\tcase 0x00:\n\t\tconfig2 = i2c_smbus_read_byte_data(client, LM90_REG_CONFIG2);\n\t\tif (config2 < 0)\n\t\t\treturn NULL;\n\t\tif (address >= 0x48 && address <= 0x4f &&\n\t\t    !(config1 & 0x2a) && !(config2 & 0xfe) && convrate <= 0x09)\n\t\t\tname = \"sa56004\";\n\t\tbreak;\n\tcase 0x80:\n\t\tif (common_address && !(config1 & 0x3f) && convrate <= 0x07)\n\t\t\tname = \"ne1618\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn name;\n}\n\nstatic const char *lm90_detect_gmt(struct i2c_client *client, int chip_id,\n\t\t\t\t   int config1, int convrate)\n{\n\tint address = client->addr;\n\n\t \n\tif ((chip_id == 0x01 || chip_id == 0x03) &&\n\t    (address == 0x4c || address == 0x4d) &&\n\t    !(config1 & 0x3f) && convrate <= 0x08) {\n\t\tint reg;\n\n\t\treg = i2c_smbus_read_byte_data(client, LM90_REG_REMOTE_OFFSL);\n\t\tif (reg < 0 || reg & 0x1f)\n\t\t\treturn NULL;\n\t\treg = i2c_smbus_read_byte_data(client, TMP451_REG_CONALERT);\n\t\tif (reg < 0 || reg & 0xf1)\n\t\t\treturn NULL;\n\n\t\treturn \"g781\";\n\t}\n\n\treturn NULL;\n}\n\nstatic const char *lm90_detect_ti49(struct i2c_client *client, bool common_address,\n\t\t\t\t    int chip_id, int config1, int convrate)\n{\n\tif (common_address && chip_id == 0x00 && !(config1 & 0x3f) && !(convrate & 0xf8)) {\n\t\t \n\t\tif (i2c_smbus_read_byte_data(client, LM90_REG_REMOTE_TEMPL) == 0xff &&\n\t\t    i2c_smbus_read_byte_data(client, LM90_REG_REMOTE_CRIT) == 0xff)\n\t\t\treturn \"thmc10\";\n\t}\n\treturn NULL;\n}\n\nstatic const char *lm90_detect_ti(struct i2c_client *client, int chip_id,\n\t\t\t\t  int config1, int convrate)\n{\n\tint address = client->addr;\n\tconst char *name = NULL;\n\n\tif (chip_id == 0x00 && !(config1 & 0x1b) && convrate <= 0x09) {\n\t\tint local_ext, conalert, chen, dfc;\n\n\t\tlocal_ext = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t     TMP451_REG_LOCAL_TEMPL);\n\t\tconalert = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t    TMP451_REG_CONALERT);\n\t\tchen = i2c_smbus_read_byte_data(client, TMP461_REG_CHEN);\n\t\tdfc = i2c_smbus_read_byte_data(client, TMP461_REG_DFC);\n\n\t\tif (!(local_ext & 0x0f) && (conalert & 0xf1) == 0x01 &&\n\t\t    (chen & 0xfc) == 0x00 && (dfc & 0xfc) == 0x00) {\n\t\t\tif (address == 0x4c && !(chen & 0x03))\n\t\t\t\tname = \"tmp451\";\n\t\t\telse if (address >= 0x48 && address <= 0x4f)\n\t\t\t\tname = \"tmp461\";\n\t\t}\n\t}\n\n\treturn name;\n}\n\n \nstatic int lm90_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint man_id, chip_id, config1, convrate, lhigh;\n\tconst char *name = NULL;\n\tint address = client->addr;\n\tbool common_address =\n\t\t\t(address >= 0x18 && address <= 0x1a) ||\n\t\t\t(address >= 0x29 && address <= 0x2b) ||\n\t\t\t(address >= 0x4c && address <= 0x4e);\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tlhigh = i2c_smbus_read_byte_data(client, LM90_REG_LOCAL_HIGH);\n\n\t \n\tman_id = i2c_smbus_read_byte_data(client, LM90_REG_MAN_ID);\n\tchip_id = i2c_smbus_read_byte_data(client, LM90_REG_CHIP_ID);\n\tconfig1 = i2c_smbus_read_byte_data(client, LM90_REG_CONFIG1);\n\tconvrate = i2c_smbus_read_byte_data(client, LM90_REG_CONVRATE);\n\tif (man_id < 0 || chip_id < 0 || config1 < 0 || convrate < 0 || lhigh < 0)\n\t\treturn -ENODEV;\n\n\t \n\tif (lhigh == man_id && lhigh == chip_id && lhigh == config1 && lhigh == convrate)\n\t\treturn -ENODEV;\n\n\t \n\tif (man_id == lhigh && chip_id == lhigh) {\n\t\tconvrate = i2c_smbus_read_byte_data(client, LM90_REG_CONVRATE);\n\t\tman_id = i2c_smbus_read_byte_data(client, LM90_REG_MAN_ID);\n\t\tchip_id = i2c_smbus_read_byte_data(client, LM90_REG_CHIP_ID);\n\t\tif (convrate < 0 || man_id < 0 || chip_id < 0)\n\t\t\treturn -ENODEV;\n\t\tif (man_id == convrate && chip_id == convrate)\n\t\t\tman_id = -1;\n\t}\n\tswitch (man_id) {\n\tcase -1:\t \n\t\tif (common_address && !convrate && !(config1 & 0x7f))\n\t\t\tname = lm90_detect_lm84(client);\n\t\tbreak;\n\tcase 0x01:\t \n\t\tname = lm90_detect_national(client, chip_id, config1, convrate);\n\t\tbreak;\n\tcase 0x1a:\t \n\t\tname = lm90_detect_on(client, chip_id, config1, convrate);\n\t\tbreak;\n\tcase 0x23:\t \n\t\tif (common_address && !(config1 & 0x3f) && !(convrate & 0xf8))\n\t\t\tname = \"gl523sm\";\n\t\tbreak;\n\tcase 0x41:\t \n\t\tname = lm90_detect_analog(client, common_address, chip_id, config1,\n\t\t\t\t\t  convrate);\n\t\tbreak;\n\tcase 0x47:\t \n\t\tname = lm90_detect_gmt(client, chip_id, config1, convrate);\n\t\tbreak;\n\tcase 0x49:\t \n\t\tname = lm90_detect_ti49(client, common_address, chip_id, config1, convrate);\n\t\tbreak;\n\tcase 0x4d:\t \n\t\tname = lm90_detect_maxim(client, common_address, chip_id,\n\t\t\t\t\t config1, convrate);\n\t\tbreak;\n\tcase 0x54:\t \n\t\tif (common_address && !(config1 & 0x3f) && !(convrate & 0xf8))\n\t\t\tname = \"mc1066\";\n\t\tbreak;\n\tcase 0x55:\t \n\t\tname = lm90_detect_ti(client, chip_id, config1, convrate);\n\t\tbreak;\n\tcase 0x5c:\t \n\t\tname = lm90_detect_nuvoton(client, chip_id, config1, convrate);\n\t\tbreak;\n\tcase 0xa1:\t \n\t\tname = lm90_detect_nxp(client, common_address, chip_id, config1, convrate);\n\t\tbreak;\n\tcase 0xff:\t \n\t\tif (common_address && chip_id == 0xff && convrate < 8)\n\t\t\tname = lm90_detect_max1617(client, config1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!name) {\t \n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"Unsupported chip at 0x%02x (man_id=0x%02X, chip_id=0x%02X)\\n\",\n\t\t\tclient->addr, man_id, chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic void lm90_restore_conf(void *_data)\n{\n\tstruct lm90_data *data = _data;\n\tstruct i2c_client *client = data->client;\n\n\tcancel_delayed_work_sync(&data->alert_work);\n\tcancel_work_sync(&data->report_work);\n\n\t \n\tif (data->flags & LM90_HAVE_CONVRATE)\n\t\tlm90_write_convrate(data, data->convrate_orig);\n\tlm90_write_reg(client, LM90_REG_CONFIG1, data->config_orig);\n}\n\nstatic int lm90_init_client(struct i2c_client *client, struct lm90_data *data)\n{\n\tstruct device_node *np = client->dev.of_node;\n\tint config, convrate;\n\n\tif (data->flags & LM90_HAVE_CONVRATE) {\n\t\tconvrate = lm90_read_reg(client, LM90_REG_CONVRATE);\n\t\tif (convrate < 0)\n\t\t\treturn convrate;\n\t\tdata->convrate_orig = convrate;\n\t\tlm90_set_convrate(client, data, 500);  \n\t} else {\n\t\tdata->update_interval = 500;\n\t}\n\n\t \n\tconfig = lm90_read_reg(client, LM90_REG_CONFIG1);\n\tif (config < 0)\n\t\treturn config;\n\tdata->config_orig = config;\n\tdata->config = config;\n\n\t \n\tif (data->flags & LM90_HAVE_EXTENDED_TEMP) {\n\t\tif (of_property_read_bool(np, \"ti,extended-range-enable\"))\n\t\t\tconfig |= 0x04;\n\t\tif (!(config & 0x04))\n\t\t\tdata->flags &= ~LM90_HAVE_EXTENDED_TEMP;\n\t}\n\n\t \n\tif (data->kind == max6680)\n\t\tconfig |= 0x18;\n\n\t \n\tif (data->kind == max6654)\n\t\tconfig |= 0x20;\n\n\t \n\tif (data->flags & LM90_HAVE_TEMP3)\n\t\tconfig &= ~0x08;\n\n\t \n\tif (client->irq)\n\t\tconfig &= ~0x80;\n\n\tconfig &= 0xBF;\t \n\tlm90_update_confreg(data, config);\n\n\treturn devm_add_action_or_reset(&client->dev, lm90_restore_conf, data);\n}\n\nstatic bool lm90_is_tripped(struct i2c_client *client)\n{\n\tstruct lm90_data *data = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = lm90_update_alarms(data, true);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn !!data->current_alarms;\n}\n\nstatic irqreturn_t lm90_irq_thread(int irq, void *dev_id)\n{\n\tstruct i2c_client *client = dev_id;\n\n\tif (lm90_is_tripped(client))\n\t\treturn IRQ_HANDLED;\n\telse\n\t\treturn IRQ_NONE;\n}\n\nstatic void lm90_remove_pec(void *dev)\n{\n\tdevice_remove_file(dev, &dev_attr_pec);\n}\n\nstatic int lm90_probe_channel_from_dt(struct i2c_client *client,\n\t\t\t\t      struct device_node *child,\n\t\t\t\t      struct lm90_data *data)\n{\n\tu32 id;\n\ts32 val;\n\tint err;\n\tstruct device *dev = &client->dev;\n\n\terr = of_property_read_u32(child, \"reg\", &id);\n\tif (err) {\n\t\tdev_err(dev, \"missing reg property of %pOFn\\n\", child);\n\t\treturn err;\n\t}\n\n\tif (id >= MAX_CHANNELS) {\n\t\tdev_err(dev, \"invalid reg property value %d in %pOFn\\n\", id, child);\n\t\treturn -EINVAL;\n\t}\n\n\terr = of_property_read_string(child, \"label\", &data->channel_label[id]);\n\tif (err == -ENODATA || err == -EILSEQ) {\n\t\tdev_err(dev, \"invalid label property in %pOFn\\n\", child);\n\t\treturn err;\n\t}\n\n\tif (data->channel_label[id])\n\t\tdata->channel_config[id] |= HWMON_T_LABEL;\n\n\terr = of_property_read_s32(child, \"temperature-offset-millicelsius\", &val);\n\tif (!err) {\n\t\tif (id == 0) {\n\t\t\tdev_err(dev, \"temperature-offset-millicelsius can't be set for internal channel\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = lm90_set_temp_offset(data, lm90_temp_offset_index[id], id, val);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"can't set temperature offset %d for channel %d (%d)\\n\",\n\t\t\t\tval, id, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lm90_parse_dt_channel_info(struct i2c_client *client,\n\t\t\t\t      struct lm90_data *data)\n{\n\tint err;\n\tstruct device_node *child;\n\tstruct device *dev = &client->dev;\n\tconst struct device_node *np = dev->of_node;\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (strcmp(child->name, \"channel\"))\n\t\t\tcontinue;\n\n\t\terr = lm90_probe_channel_from_dt(client, child, data);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops lm90_ops = {\n\t.is_visible = lm90_is_visible,\n\t.read = lm90_read,\n\t.read_string = lm90_read_string,\n\t.write = lm90_write,\n};\n\nstatic int lm90_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct hwmon_channel_info *info;\n\tstruct device *hwmon_dev;\n\tstruct lm90_data *data;\n\tint err;\n\n\terr = devm_regulator_get_enable(dev, \"vcc\");\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to enable regulator\\n\");\n\n\tdata = devm_kzalloc(dev, sizeof(struct lm90_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\tINIT_DELAYED_WORK(&data->alert_work, lm90_alert_work);\n\tINIT_WORK(&data->report_work, lm90_report_alarms);\n\n\t \n\tif (client->dev.of_node)\n\t\tdata->kind = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\tdata->kind = i2c_match_id(lm90_id, client)->driver_data;\n\n\t \n\tdata->alert_alarms = lm90_params[data->kind].alert_alarms;\n\tdata->resolution = lm90_params[data->kind].resolution ? : 11;\n\n\t \n\tdata->flags = lm90_params[data->kind].flags;\n\n\tif ((data->flags & (LM90_HAVE_PEC | LM90_HAVE_PARTIAL_PEC)) &&\n\t    !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_PEC))\n\t\tdata->flags &= ~(LM90_HAVE_PEC | LM90_HAVE_PARTIAL_PEC);\n\n\tif ((data->flags & LM90_HAVE_PARTIAL_PEC) &&\n\t    !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))\n\t\tdata->flags &= ~LM90_HAVE_PARTIAL_PEC;\n\n\tdata->chip.ops = &lm90_ops;\n\tdata->chip.info = data->info;\n\n\tdata->info[0] = &data->chip_info;\n\tinfo = &data->chip_info;\n\tinfo->type = hwmon_chip;\n\tinfo->config = data->chip_config;\n\n\tdata->chip_config[0] = HWMON_C_REGISTER_TZ;\n\tif (data->flags & LM90_HAVE_ALARMS)\n\t\tdata->chip_config[0] |= HWMON_C_ALARMS;\n\tif (data->flags & LM90_HAVE_CONVRATE)\n\t\tdata->chip_config[0] |= HWMON_C_UPDATE_INTERVAL;\n\tif (data->flags & LM90_HAVE_FAULTQUEUE)\n\t\tdata->chip_config[0] |= HWMON_C_TEMP_SAMPLES;\n\tdata->info[1] = &data->temp_info;\n\n\tinfo = &data->temp_info;\n\tinfo->type = hwmon_temp;\n\tinfo->config = data->channel_config;\n\n\tdata->channel_config[0] = HWMON_T_INPUT | HWMON_T_MAX |\n\t\tHWMON_T_MAX_ALARM;\n\tdata->channel_config[1] = HWMON_T_INPUT | HWMON_T_MAX |\n\t\tHWMON_T_MAX_ALARM | HWMON_T_FAULT;\n\n\tif (data->flags & LM90_HAVE_LOW) {\n\t\tdata->channel_config[0] |= HWMON_T_MIN | HWMON_T_MIN_ALARM;\n\t\tdata->channel_config[1] |= HWMON_T_MIN | HWMON_T_MIN_ALARM;\n\t}\n\n\tif (data->flags & LM90_HAVE_CRIT) {\n\t\tdata->channel_config[0] |= HWMON_T_CRIT | HWMON_T_CRIT_ALARM | HWMON_T_CRIT_HYST;\n\t\tdata->channel_config[1] |= HWMON_T_CRIT | HWMON_T_CRIT_ALARM | HWMON_T_CRIT_HYST;\n\t}\n\n\tif (data->flags & LM90_HAVE_OFFSET)\n\t\tdata->channel_config[1] |= HWMON_T_OFFSET;\n\n\tif (data->flags & LM90_HAVE_EMERGENCY) {\n\t\tdata->channel_config[0] |= HWMON_T_EMERGENCY |\n\t\t\tHWMON_T_EMERGENCY_HYST;\n\t\tdata->channel_config[1] |= HWMON_T_EMERGENCY |\n\t\t\tHWMON_T_EMERGENCY_HYST;\n\t}\n\n\tif (data->flags & LM90_HAVE_EMERGENCY_ALARM) {\n\t\tdata->channel_config[0] |= HWMON_T_EMERGENCY_ALARM;\n\t\tdata->channel_config[1] |= HWMON_T_EMERGENCY_ALARM;\n\t}\n\n\tif (data->flags & LM90_HAVE_TEMP3) {\n\t\tdata->channel_config[2] = HWMON_T_INPUT |\n\t\t\tHWMON_T_MIN | HWMON_T_MAX |\n\t\t\tHWMON_T_CRIT | HWMON_T_CRIT_HYST |\n\t\t\tHWMON_T_MIN_ALARM | HWMON_T_MAX_ALARM |\n\t\t\tHWMON_T_CRIT_ALARM | HWMON_T_FAULT;\n\t\tif (data->flags & LM90_HAVE_EMERGENCY) {\n\t\t\tdata->channel_config[2] |= HWMON_T_EMERGENCY |\n\t\t\t\tHWMON_T_EMERGENCY_HYST;\n\t\t}\n\t\tif (data->flags & LM90_HAVE_EMERGENCY_ALARM)\n\t\t\tdata->channel_config[2] |= HWMON_T_EMERGENCY_ALARM;\n\t\tif (data->flags & LM90_HAVE_OFFSET)\n\t\t\tdata->channel_config[2] |= HWMON_T_OFFSET;\n\t}\n\n\tdata->faultqueue_mask = lm90_params[data->kind].faultqueue_mask;\n\tdata->faultqueue_depth = lm90_params[data->kind].faultqueue_depth;\n\tdata->reg_local_ext = lm90_params[data->kind].reg_local_ext;\n\tif (data->flags & LM90_HAVE_REMOTE_EXT)\n\t\tdata->reg_remote_ext = LM90_REG_REMOTE_TEMPL;\n\tdata->reg_status2 = lm90_params[data->kind].reg_status2;\n\n\t \n\tdata->max_convrate = lm90_params[data->kind].max_convrate;\n\n\t \n\tif (client->dev.of_node) {\n\t\terr = lm90_parse_dt_channel_info(client, data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = lm90_init_client(client, data);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Failed to initialize device\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (data->flags & (LM90_HAVE_PEC | LM90_HAVE_PARTIAL_PEC)) {\n\t\terr = device_create_file(dev, &dev_attr_pec);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = devm_add_action_or_reset(dev, lm90_remove_pec, dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data, &data->chip,\n\t\t\t\t\t\t\t NULL);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdata->hwmon_dev = hwmon_dev;\n\n\tif (client->irq) {\n\t\tdev_dbg(dev, \"IRQ: %d\\n\", client->irq);\n\t\terr = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t\tNULL, lm90_irq_thread,\n\t\t\t\t\t\tIRQF_ONESHOT, \"lm90\", client);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"cannot request IRQ %d\\n\", client->irq);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void lm90_alert(struct i2c_client *client, enum i2c_alert_protocol type,\n\t\t       unsigned int flag)\n{\n\tif (type != I2C_PROTOCOL_SMBUS_ALERT)\n\t\treturn;\n\n\tif (lm90_is_tripped(client)) {\n\t\t \n\t\tstruct lm90_data *data = i2c_get_clientdata(client);\n\n\t\tif ((data->flags & LM90_HAVE_BROKEN_ALERT) &&\n\t\t    (data->current_alarms & data->alert_alarms)) {\n\t\t\tif (!(data->config & 0x80)) {\n\t\t\t\tdev_dbg(&client->dev, \"Disabling ALERT#\\n\");\n\t\t\t\tlm90_update_confreg(data, data->config | 0x80);\n\t\t\t}\n\t\t\tschedule_delayed_work(&data->alert_work,\n\t\t\t\tmax_t(int, HZ, msecs_to_jiffies(data->update_interval)));\n\t\t}\n\t} else {\n\t\tdev_dbg(&client->dev, \"Everything OK\\n\");\n\t}\n}\n\nstatic int lm90_suspend(struct device *dev)\n{\n\tstruct lm90_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tif (client->irq)\n\t\tdisable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic int lm90_resume(struct device *dev)\n{\n\tstruct lm90_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tif (client->irq)\n\t\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(lm90_pm_ops, lm90_suspend, lm90_resume);\n\nstatic struct i2c_driver lm90_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"lm90\",\n\t\t.of_match_table = of_match_ptr(lm90_of_match),\n\t\t.pm\t= pm_sleep_ptr(&lm90_pm_ops),\n\t},\n\t.probe\t\t= lm90_probe,\n\t.alert\t\t= lm90_alert,\n\t.id_table\t= lm90_id,\n\t.detect\t\t= lm90_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(lm90_driver);\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"LM90/ADM1032 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}