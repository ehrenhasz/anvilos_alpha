{
  "module_name": "ads7828.c",
  "hash_id": "7a5309e00fba776d538553920a770d792eb6e8eabeb30df7caaf13cdea230303",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ads7828.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_data/ads7828.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/regulator/consumer.h>\n\n \n#define ADS7828_CMD_SD_SE\t0x80\t \n#define ADS7828_CMD_PD1\t\t0x04\t \n#define ADS7828_CMD_PD3\t\t0x0C\t \n#define ADS7828_INT_VREF_MV\t2500\t \n#define ADS7828_EXT_VREF_MV_MIN\t50\t \n#define ADS7828_EXT_VREF_MV_MAX\t5250\t \n\n \nenum ads7828_chips { ads7828, ads7830 };\n\n \nstruct ads7828_data {\n\tstruct regmap *regmap;\n\tu8 cmd_byte;\t\t\t \n\tunsigned int lsb_resol;\t\t \n};\n\n \nstatic inline u8 ads7828_cmd_byte(u8 cmd, int ch)\n{\n\treturn cmd | (((ch >> 1) | (ch & 0x01) << 2) << 4);\n}\n\n \nstatic ssize_t ads7828_in_show(struct device *dev,\n\t\t\t       struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ads7828_data *data = dev_get_drvdata(dev);\n\tu8 cmd = ads7828_cmd_byte(data->cmd_byte, attr->index);\n\tunsigned int regval;\n\tint err;\n\n\terr = regmap_read(data->regmap, cmd, &regval);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       DIV_ROUND_CLOSEST(regval * data->lsb_resol, 1000));\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_input, ads7828_in, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, ads7828_in, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, ads7828_in, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, ads7828_in, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, ads7828_in, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in5_input, ads7828_in, 5);\nstatic SENSOR_DEVICE_ATTR_RO(in6_input, ads7828_in, 6);\nstatic SENSOR_DEVICE_ATTR_RO(in7_input, ads7828_in, 7);\n\nstatic struct attribute *ads7828_attrs[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(ads7828);\n\nstatic const struct regmap_config ads2828_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n};\n\nstatic const struct regmap_config ads2830_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic const struct i2c_device_id ads7828_device_ids[];\n\nstatic int ads7828_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ads7828_platform_data *pdata = dev_get_platdata(dev);\n\tstruct ads7828_data *data;\n\tstruct device *hwmon_dev;\n\tunsigned int vref_mv = ADS7828_INT_VREF_MV;\n\tunsigned int vref_uv;\n\tbool diff_input = false;\n\tbool ext_vref = false;\n\tunsigned int regval;\n\tenum ads7828_chips chip;\n\tstruct regulator *reg;\n\n\tdata = devm_kzalloc(dev, sizeof(struct ads7828_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (pdata) {\n\t\tdiff_input = pdata->diff_input;\n\t\text_vref = pdata->ext_vref;\n\t\tif (ext_vref && pdata->vref_mv)\n\t\t\tvref_mv = pdata->vref_mv;\n\t} else if (dev->of_node) {\n\t\tdiff_input = of_property_read_bool(dev->of_node,\n\t\t\t\t\t\t   \"ti,differential-input\");\n\t\treg = devm_regulator_get_optional(dev, \"vref\");\n\t\tif (!IS_ERR(reg)) {\n\t\t\tvref_uv = regulator_get_voltage(reg);\n\t\t\tvref_mv = DIV_ROUND_CLOSEST(vref_uv, 1000);\n\t\t\tif (vref_mv < ADS7828_EXT_VREF_MV_MIN ||\n\t\t\t    vref_mv > ADS7828_EXT_VREF_MV_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\text_vref = true;\n\t\t}\n\t}\n\n\tif (client->dev.of_node)\n\t\tchip = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\tchip = i2c_match_id(ads7828_device_ids, client)->driver_data;\n\n\t \n\tvref_mv = clamp_val(vref_mv, ADS7828_EXT_VREF_MV_MIN,\n\t\t\t    ADS7828_EXT_VREF_MV_MAX);\n\n\t \n\tif (chip == ads7828) {\n\t\tdata->lsb_resol = DIV_ROUND_CLOSEST(vref_mv * 1000, 4096);\n\t\tdata->regmap = devm_regmap_init_i2c(client,\n\t\t\t\t\t\t    &ads2828_regmap_config);\n\t} else {\n\t\tdata->lsb_resol = DIV_ROUND_CLOSEST(vref_mv * 1000, 256);\n\t\tdata->regmap = devm_regmap_init_i2c(client,\n\t\t\t\t\t\t    &ads2830_regmap_config);\n\t}\n\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\tdata->cmd_byte = ext_vref ? ADS7828_CMD_PD1 : ADS7828_CMD_PD3;\n\tif (!diff_input)\n\t\tdata->cmd_byte |= ADS7828_CMD_SD_SE;\n\n\t \n\tif (!ext_vref)\n\t\tregmap_read(data->regmap, data->cmd_byte, &regval);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   ads7828_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id ads7828_device_ids[] = {\n\t{ \"ads7828\", ads7828 },\n\t{ \"ads7830\", ads7830 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ads7828_device_ids);\n\nstatic const struct of_device_id __maybe_unused ads7828_of_match[] = {\n\t{\n\t\t.compatible = \"ti,ads7828\",\n\t\t.data = (void *)ads7828\n\t},\n\t{\n\t\t.compatible = \"ti,ads7830\",\n\t\t.data = (void *)ads7830\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ads7828_of_match);\n\nstatic struct i2c_driver ads7828_driver = {\n\t.driver = {\n\t\t.name = \"ads7828\",\n\t\t.of_match_table = of_match_ptr(ads7828_of_match),\n\t},\n\n\t.id_table = ads7828_device_ids,\n\t.probe = ads7828_probe,\n};\n\nmodule_i2c_driver(ads7828_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Steve Hardy <shardy@redhat.com>\");\nMODULE_DESCRIPTION(\"Driver for TI ADS7828 A/D converter and compatibles\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}