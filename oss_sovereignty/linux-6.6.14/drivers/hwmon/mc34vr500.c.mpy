{
  "module_name": "mc34vr500.c",
  "hash_id": "7159e1674a2ec079b34851ac7f7553078e84b3139f745fe88c225ca9aed78d94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/mc34vr500.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/dev_printk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irqreturn.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#define MC34VR500_I2C_ADDR\t\t0x08\n#define MC34VR500_DEVICEID_VALUE\t0x14\n\n \n#define ENS_BIT\t\tBIT(0)\n#define LOWVINS_BIT\tBIT(1)\n#define THERM110S_BIT\tBIT(2)\n#define THERM120S_BIT\tBIT(3)\n#define THERM125S_BIT\tBIT(4)\n#define THERM130S_BIT\tBIT(5)\n\n#define MC34VR500_DEVICEID\t0x00\n\n#define MC34VR500_SILICONREVID\t0x03\n#define MC34VR500_FABID\t\t0x04\n#define MC34VR500_INTSTAT0\t0x05\n#define MC34VR500_INTMASK0\t0x06\n#define MC34VR500_INTSENSE0\t0x07\n\nstruct mc34vr500_data {\n\tstruct device *hwmon_dev;\n\tstruct regmap *regmap;\n};\n\nstatic irqreturn_t mc34vr500_process_interrupt(int irq, void *userdata)\n{\n\tstruct mc34vr500_data *data = (struct mc34vr500_data *)userdata;\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(data->regmap, MC34VR500_INTSTAT0, &reg);\n\tif (ret < 0)\n\t\treturn IRQ_HANDLED;\n\n\tif (reg) {\n\t\tif (reg & LOWVINS_BIT)\n\t\t\thwmon_notify_event(data->hwmon_dev, hwmon_in,\n\t\t\t\t\t   hwmon_in_min_alarm, 0);\n\n\t\tif (reg & THERM110S_BIT)\n\t\t\thwmon_notify_event(data->hwmon_dev, hwmon_temp,\n\t\t\t\t\t   hwmon_temp_max_alarm, 0);\n\n\t\tif (reg & THERM120S_BIT)\n\t\t\thwmon_notify_event(data->hwmon_dev, hwmon_temp,\n\t\t\t\t\t   hwmon_temp_crit_alarm, 0);\n\n\t\tif (reg & THERM130S_BIT)\n\t\t\thwmon_notify_event(data->hwmon_dev, hwmon_temp,\n\t\t\t\t\t   hwmon_temp_emergency_alarm, 0);\n\n\t\t \n\t\tregmap_write(data->regmap, MC34VR500_INTSTAT0, LOWVINS_BIT |\n\t\t\t     THERM110S_BIT | THERM120S_BIT | THERM130S_BIT);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic umode_t mc34vr500_is_visible(const void *data,\n\t\t\t\t    enum hwmon_sensor_types type,\n\t\t\t\t    u32 attr, int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_in_min_alarm:\n\tcase hwmon_temp_max_alarm:\n\tcase hwmon_temp_crit_alarm:\n\tcase hwmon_temp_emergency_alarm:\n\t\treturn 0444;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mc34vr500_alarm_read(struct mc34vr500_data *data, int index,\n\t\t\t\tlong *val)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(data->regmap, MC34VR500_INTSENSE0, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = !!(reg & index);\n\n\treturn 0;\n}\n\nstatic int mc34vr500_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t  u32 attr, int channel, long *val)\n{\n\tstruct mc34vr500_data *data = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_min_alarm:\n\t\t\treturn mc34vr500_alarm_read(data, LOWVINS_BIT, val);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_max_alarm:\n\t\t\treturn mc34vr500_alarm_read(data, THERM110S_BIT, val);\n\t\tcase hwmon_temp_crit_alarm:\n\t\t\treturn mc34vr500_alarm_read(data, THERM120S_BIT, val);\n\t\tcase hwmon_temp_emergency_alarm:\n\t\t\treturn mc34vr500_alarm_read(data, THERM130S_BIT, val);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const mc34vr500_info[] = {\n\tHWMON_CHANNEL_INFO(in, HWMON_I_MIN_ALARM),\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM\n\t\t\t   | HWMON_T_EMERGENCY_ALARM),\n\tNULL,\n};\n\nstatic const struct hwmon_ops mc34vr500_hwmon_ops = {\n\t.is_visible = mc34vr500_is_visible,\n\t.read = mc34vr500_read,\n};\n\nstatic const struct hwmon_chip_info mc34vr500_chip_info = {\n\t.ops = &mc34vr500_hwmon_ops,\n\t.info = mc34vr500_info,\n};\n\nstatic const struct regmap_config mc34vr500_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MC34VR500_INTSENSE0,\n};\n\nstatic int mc34vr500_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct mc34vr500_data *data;\n\tstruct device *hwmon_dev;\n\tint ret;\n\tunsigned int reg, revid, fabid;\n\tstruct regmap *regmap;\n\n\tregmap = devm_regmap_init_i2c(client, &mc34vr500_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tdata = devm_kzalloc(dev, sizeof(struct mc34vr500_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = regmap;\n\n\tret = regmap_read(regmap, MC34VR500_DEVICEID, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (reg != MC34VR500_DEVICEID_VALUE)\n\t\treturn -ENODEV;\n\n\tret = regmap_read(regmap, MC34VR500_SILICONREVID, &revid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(regmap, MC34VR500_FABID, &fabid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"mc34vr500: revid 0x%x fabid 0x%x\\n\", revid, fabid);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &mc34vr500_chip_info,\n\t\t\t\t\t\t\t NULL);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdata->hwmon_dev = hwmon_dev;\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\t\tmc34vr500_process_interrupt,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\t\tIRQF_ONESHOT |\n\t\t\t\t\t\tIRQF_SHARED,\n\t\t\t\t\t\tdev_name(dev), data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_write(regmap, MC34VR500_INTSTAT0, LOWVINS_BIT |\n\t\t\t\t   THERM110S_BIT | THERM120S_BIT |\n\t\t\t\t   THERM130S_BIT);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_write(regmap, MC34VR500_INTMASK0,\n\t\t\t\t   (unsigned int) ~(LOWVINS_BIT | THERM110S_BIT |\n\t\t\t\t\t\t    THERM120S_BIT | THERM130S_BIT));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id mc34vr500_id[] = {\n\t{ \"mc34vr500\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, mc34vr500_id);\n\nstatic const struct of_device_id __maybe_unused mc34vr500_of_match[] = {\n\t{ .compatible = \"nxp,mc34vr500\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mc34vr500_of_match);\n\nstatic struct i2c_driver mc34vr500_driver = {\n\t.driver = {\n\t\t   .name = \"mc34vr500\",\n\t\t   .of_match_table = of_match_ptr(mc34vr500_of_match),\n\t\t    },\n\t.probe = mc34vr500_probe,\n\t.id_table = mc34vr500_id,\n};\n\nmodule_i2c_driver(mc34vr500_driver);\n\nMODULE_AUTHOR(\"Mario Kicherer <dev@kicherer.org>\");\n\nMODULE_DESCRIPTION(\"MC34VR500 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}