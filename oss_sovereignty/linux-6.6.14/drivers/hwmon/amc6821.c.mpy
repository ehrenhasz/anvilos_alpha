{
  "module_name": "amc6821.c",
  "hash_id": "7ea679d5cb0d995504aa1e6fe1e7784fff064fc506a009b937599a777464797e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/amc6821.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\t \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n\n \n\nstatic const unsigned short normal_i2c[] = {0x18, 0x19, 0x1a, 0x2c, 0x2d, 0x2e,\n\t0x4c, 0x4d, 0x4e, I2C_CLIENT_END};\n\n \n\nstatic int pwminv;\t \nmodule_param(pwminv, int, 0444);\n\nstatic int init = 1;  \nmodule_param(init, int, 0444);\n\nenum chips { amc6821 };\n\n#define AMC6821_REG_DEV_ID 0x3D\n#define AMC6821_REG_COMP_ID 0x3E\n#define AMC6821_REG_CONF1 0x00\n#define AMC6821_REG_CONF2 0x01\n#define AMC6821_REG_CONF3 0x3F\n#define AMC6821_REG_CONF4 0x04\n#define AMC6821_REG_STAT1 0x02\n#define AMC6821_REG_STAT2 0x03\n#define AMC6821_REG_TDATA_LOW 0x08\n#define AMC6821_REG_TDATA_HI 0x09\n#define AMC6821_REG_LTEMP_HI 0x0A\n#define AMC6821_REG_RTEMP_HI 0x0B\n#define AMC6821_REG_LTEMP_LIMIT_MIN 0x15\n#define AMC6821_REG_LTEMP_LIMIT_MAX 0x14\n#define AMC6821_REG_RTEMP_LIMIT_MIN 0x19\n#define AMC6821_REG_RTEMP_LIMIT_MAX 0x18\n#define AMC6821_REG_LTEMP_CRIT 0x1B\n#define AMC6821_REG_RTEMP_CRIT 0x1D\n#define AMC6821_REG_PSV_TEMP 0x1C\n#define AMC6821_REG_DCY 0x22\n#define AMC6821_REG_LTEMP_FAN_CTRL 0x24\n#define AMC6821_REG_RTEMP_FAN_CTRL 0x25\n#define AMC6821_REG_DCY_LOW_TEMP 0x21\n\n#define AMC6821_REG_TACH_LLIMITL 0x10\n#define AMC6821_REG_TACH_LLIMITH 0x11\n#define AMC6821_REG_TACH_HLIMITL 0x12\n#define AMC6821_REG_TACH_HLIMITH 0x13\n\n#define AMC6821_CONF1_START 0x01\n#define AMC6821_CONF1_FAN_INT_EN 0x02\n#define AMC6821_CONF1_FANIE 0x04\n#define AMC6821_CONF1_PWMINV 0x08\n#define AMC6821_CONF1_FAN_FAULT_EN 0x10\n#define AMC6821_CONF1_FDRC0 0x20\n#define AMC6821_CONF1_FDRC1 0x40\n#define AMC6821_CONF1_THERMOVIE 0x80\n\n#define AMC6821_CONF2_PWM_EN 0x01\n#define AMC6821_CONF2_TACH_MODE 0x02\n#define AMC6821_CONF2_TACH_EN 0x04\n#define AMC6821_CONF2_RTFIE 0x08\n#define AMC6821_CONF2_LTOIE 0x10\n#define AMC6821_CONF2_RTOIE 0x20\n#define AMC6821_CONF2_PSVIE 0x40\n#define AMC6821_CONF2_RST 0x80\n\n#define AMC6821_CONF3_THERM_FAN_EN 0x80\n#define AMC6821_CONF3_REV_MASK 0x0F\n\n#define AMC6821_CONF4_OVREN 0x10\n#define AMC6821_CONF4_TACH_FAST 0x20\n#define AMC6821_CONF4_PSPR 0x40\n#define AMC6821_CONF4_MODE 0x80\n\n#define AMC6821_STAT1_RPM_ALARM 0x01\n#define AMC6821_STAT1_FANS 0x02\n#define AMC6821_STAT1_RTH 0x04\n#define AMC6821_STAT1_RTL 0x08\n#define AMC6821_STAT1_R_THERM 0x10\n#define AMC6821_STAT1_RTF 0x20\n#define AMC6821_STAT1_LTH 0x40\n#define AMC6821_STAT1_LTL 0x80\n\n#define AMC6821_STAT2_RTC 0x08\n#define AMC6821_STAT2_LTC 0x10\n#define AMC6821_STAT2_LPSV 0x20\n#define AMC6821_STAT2_L_THERM 0x40\n#define AMC6821_STAT2_THERM_IN 0x80\n\nenum {IDX_TEMP1_INPUT = 0, IDX_TEMP1_MIN, IDX_TEMP1_MAX,\n\tIDX_TEMP1_CRIT, IDX_TEMP2_INPUT, IDX_TEMP2_MIN,\n\tIDX_TEMP2_MAX, IDX_TEMP2_CRIT,\n\tTEMP_IDX_LEN, };\n\nstatic const u8 temp_reg[] = {AMC6821_REG_LTEMP_HI,\n\t\t\tAMC6821_REG_LTEMP_LIMIT_MIN,\n\t\t\tAMC6821_REG_LTEMP_LIMIT_MAX,\n\t\t\tAMC6821_REG_LTEMP_CRIT,\n\t\t\tAMC6821_REG_RTEMP_HI,\n\t\t\tAMC6821_REG_RTEMP_LIMIT_MIN,\n\t\t\tAMC6821_REG_RTEMP_LIMIT_MAX,\n\t\t\tAMC6821_REG_RTEMP_CRIT, };\n\nenum {IDX_FAN1_INPUT = 0, IDX_FAN1_MIN, IDX_FAN1_MAX,\n\tFAN1_IDX_LEN, };\n\nstatic const u8 fan_reg_low[] = {AMC6821_REG_TDATA_LOW,\n\t\t\tAMC6821_REG_TACH_LLIMITL,\n\t\t\tAMC6821_REG_TACH_HLIMITL, };\n\n\nstatic const u8 fan_reg_hi[] = {AMC6821_REG_TDATA_HI,\n\t\t\tAMC6821_REG_TACH_LLIMITH,\n\t\t\tAMC6821_REG_TACH_HLIMITH, };\n\n \n\nstruct amc6821_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tbool valid;  \n\tunsigned long last_updated;  \n\n\t \n\tint temp[TEMP_IDX_LEN];\n\n\tu16 fan[FAN1_IDX_LEN];\n\tu8 fan1_div;\n\n\tu8 pwm1;\n\tu8 temp1_auto_point_temp[3];\n\tu8 temp2_auto_point_temp[3];\n\tu8 pwm1_auto_point_pwm[3];\n\tu8 pwm1_enable;\n\tu8 pwm1_auto_channels_temp;\n\n\tu8 stat1;\n\tu8 stat2;\n};\n\nstatic struct amc6821_data *amc6821_update_device(struct device *dev)\n{\n\tstruct amc6821_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint timeout = HZ;\n\tu8 reg;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + timeout) ||\n\t\t\t!data->valid) {\n\n\t\tfor (i = 0; i < TEMP_IDX_LEN; i++)\n\t\t\tdata->temp[i] = (int8_t)i2c_smbus_read_byte_data(\n\t\t\t\tclient, temp_reg[i]);\n\n\t\tdata->stat1 = i2c_smbus_read_byte_data(client,\n\t\t\tAMC6821_REG_STAT1);\n\t\tdata->stat2 = i2c_smbus_read_byte_data(client,\n\t\t\tAMC6821_REG_STAT2);\n\n\t\tdata->pwm1 = i2c_smbus_read_byte_data(client,\n\t\t\tAMC6821_REG_DCY);\n\t\tfor (i = 0; i < FAN1_IDX_LEN; i++) {\n\t\t\tdata->fan[i] = i2c_smbus_read_byte_data(\n\t\t\t\t\tclient,\n\t\t\t\t\tfan_reg_low[i]);\n\t\t\tdata->fan[i] += i2c_smbus_read_byte_data(\n\t\t\t\t\tclient,\n\t\t\t\t\tfan_reg_hi[i]) << 8;\n\t\t}\n\t\tdata->fan1_div = i2c_smbus_read_byte_data(client,\n\t\t\tAMC6821_REG_CONF4);\n\t\tdata->fan1_div = data->fan1_div & AMC6821_CONF4_PSPR ? 4 : 2;\n\n\t\tdata->pwm1_auto_point_pwm[0] = 0;\n\t\tdata->pwm1_auto_point_pwm[2] = 255;\n\t\tdata->pwm1_auto_point_pwm[1] = i2c_smbus_read_byte_data(client,\n\t\t\tAMC6821_REG_DCY_LOW_TEMP);\n\n\t\tdata->temp1_auto_point_temp[0] =\n\t\t\ti2c_smbus_read_byte_data(client,\n\t\t\t\t\tAMC6821_REG_PSV_TEMP);\n\t\tdata->temp2_auto_point_temp[0] =\n\t\t\t\tdata->temp1_auto_point_temp[0];\n\t\treg = i2c_smbus_read_byte_data(client,\n\t\t\tAMC6821_REG_LTEMP_FAN_CTRL);\n\t\tdata->temp1_auto_point_temp[1] = (reg & 0xF8) >> 1;\n\t\treg &= 0x07;\n\t\treg = 0x20 >> reg;\n\t\tif (reg > 0)\n\t\t\tdata->temp1_auto_point_temp[2] =\n\t\t\t\tdata->temp1_auto_point_temp[1] +\n\t\t\t\t(data->pwm1_auto_point_pwm[2] -\n\t\t\t\tdata->pwm1_auto_point_pwm[1]) / reg;\n\t\telse\n\t\t\tdata->temp1_auto_point_temp[2] = 255;\n\n\t\treg = i2c_smbus_read_byte_data(client,\n\t\t\tAMC6821_REG_RTEMP_FAN_CTRL);\n\t\tdata->temp2_auto_point_temp[1] = (reg & 0xF8) >> 1;\n\t\treg &= 0x07;\n\t\treg = 0x20 >> reg;\n\t\tif (reg > 0)\n\t\t\tdata->temp2_auto_point_temp[2] =\n\t\t\t\tdata->temp2_auto_point_temp[1] +\n\t\t\t\t(data->pwm1_auto_point_pwm[2] -\n\t\t\t\tdata->pwm1_auto_point_pwm[1]) / reg;\n\t\telse\n\t\t\tdata->temp2_auto_point_temp[2] = 255;\n\n\t\treg = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF1);\n\t\treg = (reg >> 5) & 0x3;\n\t\tswitch (reg) {\n\t\tcase 0:  \n\t\t\tdata->pwm1_auto_channels_temp = 0;\n\t\t\tdata->pwm1_enable = 1;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tdata->pwm1_auto_channels_temp = 2;\n\t\t\tdata->pwm1_enable = 2;\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tdata->pwm1_auto_channels_temp = 3;\n\t\t\tdata->pwm1_enable = 3;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tdata->pwm1_auto_channels_temp = 0;\n\t\t\tdata->pwm1_enable = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct amc6821_data *data = amc6821_update_device(dev);\n\tint ix = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%d\\n\", data->temp[ix] * 1000);\n}\n\nstatic ssize_t temp_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct amc6821_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ix = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\n\tint ret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\tval = clamp_val(val / 1000, -128, 127);\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp[ix] = val;\n\tif (i2c_smbus_write_byte_data(client, temp_reg[ix], data->temp[ix])) {\n\t\tdev_err(&client->dev, \"Register write error, aborting.\\n\");\n\t\tcount = -EIO;\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t temp_alarm_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tstruct amc6821_data *data = amc6821_update_device(dev);\n\tint ix = to_sensor_dev_attr(devattr)->index;\n\tu8 flag;\n\n\tswitch (ix) {\n\tcase IDX_TEMP1_MIN:\n\t\tflag = data->stat1 & AMC6821_STAT1_LTL;\n\t\tbreak;\n\tcase IDX_TEMP1_MAX:\n\t\tflag = data->stat1 & AMC6821_STAT1_LTH;\n\t\tbreak;\n\tcase IDX_TEMP1_CRIT:\n\t\tflag = data->stat2 & AMC6821_STAT2_LTC;\n\t\tbreak;\n\tcase IDX_TEMP2_MIN:\n\t\tflag = data->stat1 & AMC6821_STAT1_RTL;\n\t\tbreak;\n\tcase IDX_TEMP2_MAX:\n\t\tflag = data->stat1 & AMC6821_STAT1_RTH;\n\t\tbreak;\n\tcase IDX_TEMP2_CRIT:\n\t\tflag = data->stat2 & AMC6821_STAT2_RTC;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown attr->index (%d).\\n\", ix);\n\t\treturn -EINVAL;\n\t}\n\tif (flag)\n\t\treturn sprintf(buf, \"1\");\n\telse\n\t\treturn sprintf(buf, \"0\");\n}\n\nstatic ssize_t temp2_fault_show(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct amc6821_data *data = amc6821_update_device(dev);\n\tif (data->stat1 & AMC6821_STAT1_RTF)\n\t\treturn sprintf(buf, \"1\");\n\telse\n\t\treturn sprintf(buf, \"0\");\n}\n\nstatic ssize_t pwm1_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct amc6821_data *data = amc6821_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm1);\n}\n\nstatic ssize_t pwm1_store(struct device *dev,\n\t\t\t  struct device_attribute *devattr, const char *buf,\n\t\t\t  size_t count)\n{\n\tstruct amc6821_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint ret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm1 = clamp_val(val , 0, 255);\n\ti2c_smbus_write_byte_data(client, AMC6821_REG_DCY, data->pwm1);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t pwm1_enable_show(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct amc6821_data *data = amc6821_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm1_enable);\n}\n\nstatic ssize_t pwm1_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct amc6821_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint config = kstrtol(buf, 10, &val);\n\tif (config)\n\t\treturn config;\n\n\tmutex_lock(&data->update_lock);\n\tconfig = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF1);\n\tif (config < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\"Error reading configuration register, aborting.\\n\");\n\t\t\tcount = config;\n\t\t\tgoto unlock;\n\t}\n\n\tswitch (val) {\n\tcase 1:\n\t\tconfig &= ~AMC6821_CONF1_FDRC0;\n\t\tconfig &= ~AMC6821_CONF1_FDRC1;\n\t\tbreak;\n\tcase 2:\n\t\tconfig &= ~AMC6821_CONF1_FDRC0;\n\t\tconfig |= AMC6821_CONF1_FDRC1;\n\t\tbreak;\n\tcase 3:\n\t\tconfig |= AMC6821_CONF1_FDRC0;\n\t\tconfig |= AMC6821_CONF1_FDRC1;\n\t\tbreak;\n\tdefault:\n\t\tcount = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tif (i2c_smbus_write_byte_data(client, AMC6821_REG_CONF1, config)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\"Configuration register write error, aborting.\\n\");\n\t\t\tcount = -EIO;\n\t}\nunlock:\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t pwm1_auto_channels_temp_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *devattr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct amc6821_data *data = amc6821_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm1_auto_channels_temp);\n}\n\nstatic ssize_t temp_auto_point_temp_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *devattr,\n\t\t\t\t\t char *buf)\n{\n\tint ix = to_sensor_dev_attr_2(devattr)->index;\n\tint nr = to_sensor_dev_attr_2(devattr)->nr;\n\tstruct amc6821_data *data = amc6821_update_device(dev);\n\tswitch (nr) {\n\tcase 1:\n\t\treturn sprintf(buf, \"%d\\n\",\n\t\t\tdata->temp1_auto_point_temp[ix] * 1000);\n\tcase 2:\n\t\treturn sprintf(buf, \"%d\\n\",\n\t\t\tdata->temp2_auto_point_temp[ix] * 1000);\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown attr->nr (%d).\\n\", nr);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t pwm1_auto_point_pwm_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\t\tchar *buf)\n{\n\tint ix = to_sensor_dev_attr(devattr)->index;\n\tstruct amc6821_data *data = amc6821_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm1_auto_point_pwm[ix]);\n}\n\nstatic inline ssize_t set_slope_register(struct i2c_client *client,\n\t\tu8 reg,\n\t\tu8 dpwm,\n\t\tu8 *ptemp)\n{\n\tint dt;\n\tu8 tmp;\n\n\tdt = ptemp[2]-ptemp[1];\n\tfor (tmp = 4; tmp > 0; tmp--) {\n\t\tif (dt * (0x20 >> tmp) >= dpwm)\n\t\t\tbreak;\n\t}\n\ttmp |= (ptemp[1] & 0x7C) << 1;\n\tif (i2c_smbus_write_byte_data(client,\n\t\t\treg, tmp)) {\n\t\tdev_err(&client->dev, \"Register write error, aborting.\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t temp_auto_point_temp_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct amc6821_data *data = amc6821_update_device(dev);\n\tstruct i2c_client *client = data->client;\n\tint ix = to_sensor_dev_attr_2(attr)->index;\n\tint nr = to_sensor_dev_attr_2(attr)->nr;\n\tu8 *ptemp;\n\tu8 reg;\n\tint dpwm;\n\tlong val;\n\tint ret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (nr) {\n\tcase 1:\n\t\tptemp = data->temp1_auto_point_temp;\n\t\treg = AMC6821_REG_LTEMP_FAN_CTRL;\n\t\tbreak;\n\tcase 2:\n\t\tptemp = data->temp2_auto_point_temp;\n\t\treg = AMC6821_REG_RTEMP_FAN_CTRL;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown attr->nr (%d).\\n\", nr);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&data->update_lock);\n\tdata->valid = false;\n\n\tswitch (ix) {\n\tcase 0:\n\t\tptemp[0] = clamp_val(val / 1000, 0,\n\t\t\t\t     data->temp1_auto_point_temp[1]);\n\t\tptemp[0] = clamp_val(ptemp[0], 0,\n\t\t\t\t     data->temp2_auto_point_temp[1]);\n\t\tptemp[0] = clamp_val(ptemp[0], 0, 63);\n\t\tif (i2c_smbus_write_byte_data(\n\t\t\t\t\tclient,\n\t\t\t\t\tAMC6821_REG_PSV_TEMP,\n\t\t\t\t\tptemp[0])) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Register write error, aborting.\\n\");\n\t\t\t\tcount = -EIO;\n\t\t}\n\t\tgoto EXIT;\n\tcase 1:\n\t\tptemp[1] = clamp_val(val / 1000, (ptemp[0] & 0x7C) + 4, 124);\n\t\tptemp[1] &= 0x7C;\n\t\tptemp[2] = clamp_val(ptemp[2], ptemp[1] + 1, 255);\n\t\tbreak;\n\tcase 2:\n\t\tptemp[2] = clamp_val(val / 1000, ptemp[1]+1, 255);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown attr->index (%d).\\n\", ix);\n\t\tcount = -EINVAL;\n\t\tgoto EXIT;\n\t}\n\tdpwm = data->pwm1_auto_point_pwm[2] - data->pwm1_auto_point_pwm[1];\n\tif (set_slope_register(client, reg, dpwm, ptemp))\n\t\tcount = -EIO;\n\nEXIT:\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t pwm1_auto_point_pwm_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct amc6821_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint dpwm;\n\tlong val;\n\tint ret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm1_auto_point_pwm[1] = clamp_val(val, 0, 254);\n\tif (i2c_smbus_write_byte_data(client, AMC6821_REG_DCY_LOW_TEMP,\n\t\t\tdata->pwm1_auto_point_pwm[1])) {\n\t\tdev_err(&client->dev, \"Register write error, aborting.\\n\");\n\t\tcount = -EIO;\n\t\tgoto EXIT;\n\t}\n\tdpwm = data->pwm1_auto_point_pwm[2] - data->pwm1_auto_point_pwm[1];\n\tif (set_slope_register(client, AMC6821_REG_LTEMP_FAN_CTRL, dpwm,\n\t\t\tdata->temp1_auto_point_temp)) {\n\t\tcount = -EIO;\n\t\tgoto EXIT;\n\t}\n\tif (set_slope_register(client, AMC6821_REG_RTEMP_FAN_CTRL, dpwm,\n\t\t\tdata->temp2_auto_point_temp)) {\n\t\tcount = -EIO;\n\t\tgoto EXIT;\n\t}\n\nEXIT:\n\tdata->valid = false;\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t fan_show(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct amc6821_data *data = amc6821_update_device(dev);\n\tint ix = to_sensor_dev_attr(devattr)->index;\n\tif (0 == data->fan[ix])\n\t\treturn sprintf(buf, \"0\");\n\treturn sprintf(buf, \"%d\\n\", (int)(6000000 / data->fan[ix]));\n}\n\nstatic ssize_t fan1_fault_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tstruct amc6821_data *data = amc6821_update_device(dev);\n\tif (data->stat1 & AMC6821_STAT1_FANS)\n\t\treturn sprintf(buf, \"1\");\n\telse\n\t\treturn sprintf(buf, \"0\");\n}\n\nstatic ssize_t fan_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct amc6821_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint ix = to_sensor_dev_attr(attr)->index;\n\tint ret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\tval = 1 > val ? 0xFFFF : 6000000/val;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan[ix] = (u16) clamp_val(val, 1, 0xFFFF);\n\tif (i2c_smbus_write_byte_data(client, fan_reg_low[ix],\n\t\t\tdata->fan[ix] & 0xFF)) {\n\t\tdev_err(&client->dev, \"Register write error, aborting.\\n\");\n\t\tcount = -EIO;\n\t\tgoto EXIT;\n\t}\n\tif (i2c_smbus_write_byte_data(client,\n\t\t\tfan_reg_hi[ix], data->fan[ix] >> 8)) {\n\t\tdev_err(&client->dev, \"Register write error, aborting.\\n\");\n\t\tcount = -EIO;\n\t}\nEXIT:\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t fan1_div_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct amc6821_data *data = amc6821_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->fan1_div);\n}\n\nstatic ssize_t fan1_div_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct amc6821_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint config = kstrtol(buf, 10, &val);\n\tif (config)\n\t\treturn config;\n\n\tmutex_lock(&data->update_lock);\n\tconfig = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF4);\n\tif (config < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Error reading configuration register, aborting.\\n\");\n\t\tcount = config;\n\t\tgoto EXIT;\n\t}\n\tswitch (val) {\n\tcase 2:\n\t\tconfig &= ~AMC6821_CONF4_PSPR;\n\t\tdata->fan1_div = 2;\n\t\tbreak;\n\tcase 4:\n\t\tconfig |= AMC6821_CONF4_PSPR;\n\t\tdata->fan1_div = 4;\n\t\tbreak;\n\tdefault:\n\t\tcount = -EINVAL;\n\t\tgoto EXIT;\n\t}\n\tif (i2c_smbus_write_byte_data(client, AMC6821_REG_CONF4, config)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Configuration register write error, aborting.\\n\");\n\t\tcount = -EIO;\n\t}\nEXIT:\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, IDX_TEMP1_INPUT);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp, IDX_TEMP1_MIN);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp, IDX_TEMP1_MAX);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_crit, temp, IDX_TEMP1_CRIT);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_alarm, temp_alarm, IDX_TEMP1_MIN);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, temp_alarm, IDX_TEMP1_MAX);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_crit_alarm, temp_alarm, IDX_TEMP1_CRIT);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, IDX_TEMP2_INPUT);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_min, temp, IDX_TEMP2_MIN);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp, IDX_TEMP2_MAX);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_crit, temp, IDX_TEMP2_CRIT);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_fault, temp2_fault, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_min_alarm, temp_alarm, IDX_TEMP2_MIN);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_max_alarm, temp_alarm, IDX_TEMP2_MAX);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_crit_alarm, temp_alarm, IDX_TEMP2_CRIT);\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan, IDX_FAN1_INPUT);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_min, fan, IDX_FAN1_MIN);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_max, fan, IDX_FAN1_MAX);\nstatic SENSOR_DEVICE_ATTR_RO(fan1_fault, fan1_fault, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_div, fan1_div, 0);\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1, pwm1, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_enable, pwm1_enable, 0);\nstatic SENSOR_DEVICE_ATTR_RO(pwm1_auto_point1_pwm, pwm1_auto_point_pwm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point2_pwm, pwm1_auto_point_pwm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(pwm1_auto_point3_pwm, pwm1_auto_point_pwm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(pwm1_auto_channels_temp, pwm1_auto_channels_temp,\n\t\t\t     0);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_auto_point1_temp, temp_auto_point_temp,\n\t\t\t       1, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_point2_temp, temp_auto_point_temp,\n\t\t\t       1, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_point3_temp, temp_auto_point_temp,\n\t\t\t       1, 2);\n\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_point1_temp, temp_auto_point_temp,\n\t\t\t       2, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_point2_temp, temp_auto_point_temp,\n\t\t\t       2, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_point3_temp, temp_auto_point_temp,\n\t\t\t       2, 2);\n\nstatic struct attribute *amc6821_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_max.dev_attr.attr,\n\t&sensor_dev_attr_fan1_fault.dev_attr.attr,\n\t&sensor_dev_attr_fan1_div.dev_attr.attr,\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_channels_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_pwm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_point3_temp.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(amc6821);\n\n \nstatic int amc6821_detect(\n\t\tstruct i2c_client *client,\n\t\tstruct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint address = client->addr;\n\tint dev_id, comp_id;\n\n\tdev_dbg(&adapter->dev, \"amc6821_detect called.\\n\");\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"amc6821: I2C bus doesn't support byte mode, \"\n\t\t\t\"skipping.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_id = i2c_smbus_read_byte_data(client, AMC6821_REG_DEV_ID);\n\tcomp_id = i2c_smbus_read_byte_data(client, AMC6821_REG_COMP_ID);\n\tif (dev_id != 0x21 || comp_id != 0x49) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"amc6821: detection failed at 0x%02x.\\n\",\n\t\t\taddress);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdev_id = i2c_smbus_read_byte_data(client, 0x80 | AMC6821_REG_DEV_ID);\n\tcomp_id = i2c_smbus_read_byte_data(client, 0x80 | AMC6821_REG_COMP_ID);\n\tif (dev_id != 0x21 || comp_id != 0x49) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"amc6821: detection failed at 0x%02x.\\n\",\n\t\t\taddress);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&adapter->dev, \"amc6821: chip found at 0x%02x.\\n\", address);\n\tstrscpy(info->type, \"amc6821\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int amc6821_init_client(struct i2c_client *client)\n{\n\tint config;\n\tint err = -EIO;\n\n\tif (init) {\n\t\tconfig = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF4);\n\n\t\tif (config < 0) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\"Error reading configuration register, aborting.\\n\");\n\t\t\t\treturn err;\n\t\t}\n\n\t\tconfig |= AMC6821_CONF4_MODE;\n\n\t\tif (i2c_smbus_write_byte_data(client, AMC6821_REG_CONF4,\n\t\t\t\tconfig)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\"Configuration register write error, aborting.\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tconfig = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF3);\n\n\t\tif (config < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\"Error reading configuration register, aborting.\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tdev_info(&client->dev, \"Revision %d\\n\", config & 0x0f);\n\n\t\tconfig &= ~AMC6821_CONF3_THERM_FAN_EN;\n\n\t\tif (i2c_smbus_write_byte_data(client, AMC6821_REG_CONF3,\n\t\t\t\tconfig)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\"Configuration register write error, aborting.\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tconfig = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF2);\n\n\t\tif (config < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\"Error reading configuration register, aborting.\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tconfig &= ~AMC6821_CONF2_RTFIE;\n\t\tconfig &= ~AMC6821_CONF2_LTOIE;\n\t\tconfig &= ~AMC6821_CONF2_RTOIE;\n\t\tif (i2c_smbus_write_byte_data(client,\n\t\t\t\tAMC6821_REG_CONF2, config)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\"Configuration register write error, aborting.\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tconfig = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF1);\n\n\t\tif (config < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\"Error reading configuration register, aborting.\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tconfig &= ~AMC6821_CONF1_THERMOVIE;\n\t\tconfig &= ~AMC6821_CONF1_FANIE;\n\t\tconfig |= AMC6821_CONF1_START;\n\t\tif (pwminv)\n\t\t\tconfig |= AMC6821_CONF1_PWMINV;\n\t\telse\n\t\t\tconfig &= ~AMC6821_CONF1_PWMINV;\n\n\t\tif (i2c_smbus_write_byte_data(\n\t\t\t\tclient, AMC6821_REG_CONF1, config)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\"Configuration register write error, aborting.\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int amc6821_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct amc6821_data *data;\n\tstruct device *hwmon_dev;\n\tint err;\n\n\tdata = devm_kzalloc(dev, sizeof(struct amc6821_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\terr = amc6821_init_client(client);\n\tif (err)\n\t\treturn err;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   amc6821_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id amc6821_id[] = {\n\t{ \"amc6821\", amc6821 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, amc6821_id);\n\nstatic struct i2c_driver amc6821_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"amc6821\",\n\t},\n\t.probe = amc6821_probe,\n\t.id_table = amc6821_id,\n\t.detect = amc6821_detect,\n\t.address_list = normal_i2c,\n};\n\nmodule_i2c_driver(amc6821_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"T. Mertelj <tomaz.mertelj@guest.arnes.si>\");\nMODULE_DESCRIPTION(\"Texas Instruments amc6821 hwmon driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}