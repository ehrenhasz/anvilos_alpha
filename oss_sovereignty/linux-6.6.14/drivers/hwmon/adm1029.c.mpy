{
  "module_name": "adm1029.c",
  "hash_id": "b607ba1575e990029a43232ccd4ffff59ee4cb1c5c189bd5d70dca6b02fd9f9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adm1029.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n\n \n\nstatic const unsigned short normal_i2c[] = { 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,\n\t\t\t\t\t\t0x2e, 0x2f, I2C_CLIENT_END\n};\n\n \n\n#define ADM1029_REG_MAN_ID\t\t\t0x0D\n#define ADM1029_REG_CHIP_ID\t\t\t0x0E\n#define ADM1029_REG_CONFIG\t\t\t0x01\n#define ADM1029_REG_NB_FAN_SUPPORT\t\t0x02\n\n#define ADM1029_REG_TEMP_DEVICES_INSTALLED\t0x06\n\n#define ADM1029_REG_LOCAL_TEMP\t\t\t0xA0\n#define ADM1029_REG_REMOTE1_TEMP\t\t0xA1\n#define ADM1029_REG_REMOTE2_TEMP\t\t0xA2\n\n#define ADM1029_REG_LOCAL_TEMP_HIGH\t\t0x90\n#define ADM1029_REG_REMOTE1_TEMP_HIGH\t\t0x91\n#define ADM1029_REG_REMOTE2_TEMP_HIGH\t\t0x92\n\n#define ADM1029_REG_LOCAL_TEMP_LOW\t\t0x98\n#define ADM1029_REG_REMOTE1_TEMP_LOW\t\t0x99\n#define ADM1029_REG_REMOTE2_TEMP_LOW\t\t0x9A\n\n#define ADM1029_REG_FAN1\t\t\t0x70\n#define ADM1029_REG_FAN2\t\t\t0x71\n\n#define ADM1029_REG_FAN1_MIN\t\t\t0x78\n#define ADM1029_REG_FAN2_MIN\t\t\t0x79\n\n#define ADM1029_REG_FAN1_CONFIG\t\t\t0x68\n#define ADM1029_REG_FAN2_CONFIG\t\t\t0x69\n\n#define TEMP_FROM_REG(val)\t((val) * 1000)\n\n#define DIV_FROM_REG(val)\t(1 << (((val) >> 6) - 1))\n\n \nstatic const u8 ADM1029_REG_TEMP[] = {\n\tADM1029_REG_LOCAL_TEMP,\n\tADM1029_REG_REMOTE1_TEMP,\n\tADM1029_REG_REMOTE2_TEMP,\n\tADM1029_REG_LOCAL_TEMP_HIGH,\n\tADM1029_REG_REMOTE1_TEMP_HIGH,\n\tADM1029_REG_REMOTE2_TEMP_HIGH,\n\tADM1029_REG_LOCAL_TEMP_LOW,\n\tADM1029_REG_REMOTE1_TEMP_LOW,\n\tADM1029_REG_REMOTE2_TEMP_LOW,\n};\n\nstatic const u8 ADM1029_REG_FAN[] = {\n\tADM1029_REG_FAN1,\n\tADM1029_REG_FAN2,\n\tADM1029_REG_FAN1_MIN,\n\tADM1029_REG_FAN2_MIN,\n};\n\nstatic const u8 ADM1029_REG_FAN_DIV[] = {\n\tADM1029_REG_FAN1_CONFIG,\n\tADM1029_REG_FAN2_CONFIG,\n};\n\n \n\nstruct adm1029_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;  \n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\n\t \n\ts8 temp[ARRAY_SIZE(ADM1029_REG_TEMP)];\n\tu8 fan[ARRAY_SIZE(ADM1029_REG_FAN)];\n\tu8 fan_div[ARRAY_SIZE(ADM1029_REG_FAN_DIV)];\n};\n\n \nstatic struct adm1029_data *adm1029_update_device(struct device *dev)\n{\n\tstruct adm1029_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tmutex_lock(&data->update_lock);\n\t \n\tif (time_after(jiffies, data->last_updated + HZ * 2) || !data->valid) {\n\t\tint nr;\n\n\t\tdev_dbg(&client->dev, \"Updating adm1029 data\\n\");\n\n\t\tfor (nr = 0; nr < ARRAY_SIZE(ADM1029_REG_TEMP); nr++) {\n\t\t\tdata->temp[nr] =\n\t\t\t    i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t     ADM1029_REG_TEMP[nr]);\n\t\t}\n\t\tfor (nr = 0; nr < ARRAY_SIZE(ADM1029_REG_FAN); nr++) {\n\t\t\tdata->fan[nr] =\n\t\t\t    i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t     ADM1029_REG_FAN[nr]);\n\t\t}\n\t\tfor (nr = 0; nr < ARRAY_SIZE(ADM1029_REG_FAN_DIV); nr++) {\n\t\t\tdata->fan_div[nr] =\n\t\t\t    i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t     ADM1029_REG_FAN_DIV[nr]);\n\t\t}\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \n\nstatic ssize_t\ntemp_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adm1029_data *data = adm1029_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp[attr->index]));\n}\n\nstatic ssize_t\nfan_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adm1029_data *data = adm1029_update_device(dev);\n\tu16 val;\n\n\tif (data->fan[attr->index] == 0 ||\n\t    (data->fan_div[attr->index] & 0xC0) == 0 ||\n\t    data->fan[attr->index] == 255) {\n\t\treturn sprintf(buf, \"0\\n\");\n\t}\n\n\tval = 1880 * 120 / DIV_FROM_REG(data->fan_div[attr->index])\n\t    / data->fan[attr->index];\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t\nfan_div_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adm1029_data *data = adm1029_update_device(dev);\n\n\tif ((data->fan_div[attr->index] & 0xC0) == 0)\n\t\treturn sprintf(buf, \"0\\n\");\n\treturn sprintf(buf, \"%d\\n\", DIV_FROM_REG(data->fan_div[attr->index]));\n}\n\nstatic ssize_t fan_div_store(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct adm1029_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tu8 reg;\n\tlong val;\n\tint ret = kstrtol(buf, 10, &val);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\treg = i2c_smbus_read_byte_data(client,\n\t\t\t\t       ADM1029_REG_FAN_DIV[attr->index]);\n\n\tswitch (val) {\n\tcase 1:\n\t\tval = 1;\n\t\tbreak;\n\tcase 2:\n\t\tval = 2;\n\t\tbreak;\n\tcase 4:\n\t\tval = 3;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&data->update_lock);\n\t\tdev_err(&client->dev,\n\t\t\t\"fan_div value %ld not supported. Choose one of 1, 2 or 4!\\n\",\n\t\t\tval);\n\t\treturn -EINVAL;\n\t}\n\t \n\treg = (reg & 0x3F) | (val << 6);\n\n\t \n\tdata->fan_div[attr->index] = reg;\n\n\t \n\ti2c_smbus_write_byte_data(client,\n\t\t\t\t  ADM1029_REG_FAN_DIV[attr->index], reg);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp, 2);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max, temp, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_max, temp, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_max, temp, 5);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min, temp, 6);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_min, temp, 7);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_min, temp, 8);\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan, 1);\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_min, fan, 2);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_min, fan, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(fan1_div, fan_div, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_div, fan_div, 1);\n\nstatic struct attribute *adm1029_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_div.dev_attr.attr,\n\t&sensor_dev_attr_fan2_div.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(adm1029);\n\n \n\n \nstatic int adm1029_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tu8 man_id, chip_id, temp_devices_installed, nb_fan_support;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\n\tman_id = i2c_smbus_read_byte_data(client, ADM1029_REG_MAN_ID);\n\tchip_id = i2c_smbus_read_byte_data(client, ADM1029_REG_CHIP_ID);\n\ttemp_devices_installed = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tADM1029_REG_TEMP_DEVICES_INSTALLED);\n\tnb_fan_support = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t  ADM1029_REG_NB_FAN_SUPPORT);\n\t \n\tif (man_id != 0x41 || (temp_devices_installed & 0xf9) != 0x01 ||\n\t    nb_fan_support != 0x03)\n\t\treturn -ENODEV;\n\n\tif ((chip_id & 0xF0) != 0x00) {\n\t\t \n\t\tpr_info(\"Unknown major revision %x, please let us know\\n\",\n\t\t\tchip_id);\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, \"adm1029\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int adm1029_init_client(struct i2c_client *client)\n{\n\tu8 config;\n\n\tconfig = i2c_smbus_read_byte_data(client, ADM1029_REG_CONFIG);\n\tif ((config & 0x10) == 0) {\n\t\ti2c_smbus_write_byte_data(client, ADM1029_REG_CONFIG,\n\t\t\t\t\t  config | 0x10);\n\t}\n\t \n\tconfig = i2c_smbus_read_byte_data(client, ADM1029_REG_CONFIG);\n\tif ((config & 0x10) == 0) {\n\t\tdev_err(&client->dev, \"Initialization failed!\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int adm1029_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct adm1029_data *data;\n\tstruct device *hwmon_dev;\n\n\tdata = devm_kzalloc(dev, sizeof(struct adm1029_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tif (adm1029_init_client(client) == 0)\n\t\treturn -ENODEV;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   adm1029_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id adm1029_id[] = {\n\t{ \"adm1029\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adm1029_id);\n\nstatic struct i2c_driver adm1029_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"adm1029\",\n\t},\n\t.probe\t\t= adm1029_probe,\n\t.id_table\t= adm1029_id,\n\t.detect\t\t= adm1029_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(adm1029_driver);\n\nMODULE_AUTHOR(\"Corentin LABBE <clabbe.montjoie@gmail.com>\");\nMODULE_DESCRIPTION(\"adm1029 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}