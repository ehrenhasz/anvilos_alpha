{
  "module_name": "f75375s.c",
  "hash_id": "b97329bc833ca3d891273ec4ece04d8ae4840bfd9feb6a191e943339dcfb7864",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/f75375s.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/f75375s.h>\n#include <linux/slab.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x2d, 0x2e, I2C_CLIENT_END };\n\nenum chips { f75373, f75375, f75387 };\n\n \n#define F75375_REG_CONFIG0\t\t0x0\n#define F75375_REG_CONFIG1\t\t0x1\n#define F75375_REG_CONFIG2\t\t0x2\n#define F75375_REG_CONFIG3\t\t0x3\n#define F75375_REG_ADDR\t\t\t0x4\n#define F75375_REG_INTR\t\t\t0x31\n#define F75375_CHIP_ID\t\t\t0x5A\n#define F75375_REG_VERSION\t\t0x5C\n#define F75375_REG_VENDOR\t\t0x5D\n#define F75375_REG_FAN_TIMER\t\t0x60\n\n#define F75375_REG_VOLT(nr)\t\t(0x10 + (nr))\n#define F75375_REG_VOLT_HIGH(nr)\t(0x20 + (nr) * 2)\n#define F75375_REG_VOLT_LOW(nr)\t\t(0x21 + (nr) * 2)\n\n#define F75375_REG_TEMP(nr)\t\t(0x14 + (nr))\n#define F75387_REG_TEMP11_LSB(nr)\t(0x1a + (nr))\n#define F75375_REG_TEMP_HIGH(nr)\t(0x28 + (nr) * 2)\n#define F75375_REG_TEMP_HYST(nr)\t(0x29 + (nr) * 2)\n\n#define F75375_REG_FAN(nr)\t\t(0x16 + (nr) * 2)\n#define F75375_REG_FAN_MIN(nr)\t\t(0x2C + (nr) * 2)\n#define F75375_REG_FAN_FULL(nr)\t\t(0x70 + (nr) * 0x10)\n#define F75375_REG_FAN_PWM_DUTY(nr)\t(0x76 + (nr) * 0x10)\n#define F75375_REG_FAN_PWM_CLOCK(nr)\t(0x7D + (nr) * 0x10)\n\n#define F75375_REG_FAN_EXP(nr)\t\t(0x74 + (nr) * 0x10)\n#define F75375_REG_FAN_B_TEMP(nr, step)\t((0xA0 + (nr) * 0x10) + (step))\n#define F75375_REG_FAN_B_SPEED(nr, step) \\\n\t((0xA5 + (nr) * 0x10) + (step) * 2)\n\n#define F75375_REG_PWM1_RAISE_DUTY\t0x69\n#define F75375_REG_PWM2_RAISE_DUTY\t0x6A\n#define F75375_REG_PWM1_DROP_DUTY\t0x6B\n#define F75375_REG_PWM2_DROP_DUTY\t0x6C\n\n#define F75375_FAN_CTRL_LINEAR(nr)\t(4 + nr)\n#define F75387_FAN_CTRL_LINEAR(nr)\t(1 + ((nr) * 4))\n#define FAN_CTRL_MODE(nr)\t\t(4 + ((nr) * 2))\n#define F75387_FAN_DUTY_MODE(nr)\t(2 + ((nr) * 4))\n#define F75387_FAN_MANU_MODE(nr)\t((nr) * 4)\n\n \n\nstruct f75375_data {\n\tunsigned short addr;\n\tstruct device *hwmon_dev;\n\n\tconst char *name;\n\tint kind;\n\tstruct mutex update_lock;  \n\tbool valid;\n\tunsigned long last_updated;\t \n\tunsigned long last_limits;\t \n\n\t \n\tu8 in[4];\n\tu8 in_max[4];\n\tu8 in_min[4];\n\tu16 fan[2];\n\tu16 fan_min[2];\n\tu16 fan_max[2];\n\tu16 fan_target[2];\n\tu8 fan_timer;\n\tu8 pwm[2];\n\tu8 pwm_mode[2];\n\tu8 pwm_enable[2];\n\t \n\ts16 temp11[2];\n\ts8 temp_high[2];\n\ts8 temp_max_hyst[2];\n};\n\nstatic int f75375_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info);\nstatic int f75375_probe(struct i2c_client *client);\nstatic void f75375_remove(struct i2c_client *client);\n\nstatic const struct i2c_device_id f75375_id[] = {\n\t{ \"f75373\", f75373 },\n\t{ \"f75375\", f75375 },\n\t{ \"f75387\", f75387 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, f75375_id);\n\nstatic struct i2c_driver f75375_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"f75375\",\n\t},\n\t.probe = f75375_probe,\n\t.remove = f75375_remove,\n\t.id_table = f75375_id,\n\t.detect = f75375_detect,\n\t.address_list = normal_i2c,\n};\n\nstatic inline int f75375_read8(struct i2c_client *client, u8 reg)\n{\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\n \nstatic inline u16 f75375_read16(struct i2c_client *client, u8 reg)\n{\n\treturn (i2c_smbus_read_byte_data(client, reg) << 8)\n\t\t| i2c_smbus_read_byte_data(client, reg + 1);\n}\n\nstatic inline void f75375_write8(struct i2c_client *client, u8 reg,\n\t\tu8 value)\n{\n\ti2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic inline void f75375_write16(struct i2c_client *client, u8 reg,\n\t\tu16 value)\n{\n\tint err = i2c_smbus_write_byte_data(client, reg, (value >> 8));\n\tif (err)\n\t\treturn;\n\ti2c_smbus_write_byte_data(client, reg + 1, (value & 0xFF));\n}\n\nstatic void f75375_write_pwm(struct i2c_client *client, int nr)\n{\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\tif (data->kind == f75387)\n\t\tf75375_write16(client, F75375_REG_FAN_EXP(nr), data->pwm[nr]);\n\telse\n\t\tf75375_write8(client, F75375_REG_FAN_PWM_DUTY(nr),\n\t\t\t      data->pwm[nr]);\n}\n\nstatic struct f75375_data *f75375_update_device(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\tint nr;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tif (time_after(jiffies, data->last_limits + 60 * HZ)\n\t\t|| !data->valid) {\n\t\tfor (nr = 0; nr < 2; nr++) {\n\t\t\tdata->temp_high[nr] =\n\t\t\t\tf75375_read8(client, F75375_REG_TEMP_HIGH(nr));\n\t\t\tdata->temp_max_hyst[nr] =\n\t\t\t\tf75375_read8(client, F75375_REG_TEMP_HYST(nr));\n\t\t\tdata->fan_max[nr] =\n\t\t\t\tf75375_read16(client, F75375_REG_FAN_FULL(nr));\n\t\t\tdata->fan_min[nr] =\n\t\t\t\tf75375_read16(client, F75375_REG_FAN_MIN(nr));\n\t\t\tdata->fan_target[nr] =\n\t\t\t\tf75375_read16(client, F75375_REG_FAN_EXP(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 4; nr++) {\n\t\t\tdata->in_max[nr] =\n\t\t\t\tf75375_read8(client, F75375_REG_VOLT_HIGH(nr));\n\t\t\tdata->in_min[nr] =\n\t\t\t\tf75375_read8(client, F75375_REG_VOLT_LOW(nr));\n\t\t}\n\t\tdata->fan_timer = f75375_read8(client, F75375_REG_FAN_TIMER);\n\t\tdata->last_limits = jiffies;\n\t}\n\n\t \n\tif (time_after(jiffies, data->last_updated + 2 * HZ)\n\t\t|| !data->valid) {\n\t\tfor (nr = 0; nr < 2; nr++) {\n\t\t\tdata->pwm[nr] =\tf75375_read8(client,\n\t\t\t\tF75375_REG_FAN_PWM_DUTY(nr));\n\t\t\t \n\t\t\tdata->temp11[nr] =\n\t\t\t\tf75375_read8(client, F75375_REG_TEMP(nr)) << 8;\n\t\t\tif (data->kind == f75387)\n\t\t\t\t \n\t\t\t\tdata->temp11[nr] |=\n\t\t\t\t\tf75375_read8(client,\n\t\t\t\t\t\t     F75387_REG_TEMP11_LSB(nr));\n\t\t\tdata->fan[nr] =\n\t\t\t\tf75375_read16(client, F75375_REG_FAN(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 4; nr++)\n\t\t\tdata->in[nr] =\n\t\t\t\tf75375_read8(client, F75375_REG_VOLT(nr));\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n}\n\nstatic inline u16 rpm_from_reg(u16 reg)\n{\n\tif (reg == 0 || reg == 0xffff)\n\t\treturn 0;\n\treturn 1500000 / reg;\n}\n\nstatic inline u16 rpm_to_reg(int rpm)\n{\n\tif (rpm < 367 || rpm > 0xffff)\n\t\treturn 0xffff;\n\treturn 1500000 / rpm;\n}\n\nstatic bool duty_mode_enabled(u8 pwm_enable)\n{\n\tswitch (pwm_enable) {\n\tcase 0:  \n\tcase 1:  \n\tcase 4:  \n\t\treturn true;\n\tcase 2:  \n\tcase 3:  \n\t\treturn false;\n\tdefault:\n\t\tWARN(1, \"Unexpected pwm_enable value %d\\n\", pwm_enable);\n\t\treturn true;\n\t}\n}\n\nstatic bool auto_mode_enabled(u8 pwm_enable)\n{\n\tswitch (pwm_enable) {\n\tcase 0:  \n\tcase 1:  \n\tcase 3:  \n\t\treturn false;\n\tcase 2:  \n\tcase 4:  \n\t\treturn true;\n\tdefault:\n\t\tWARN(1, \"Unexpected pwm_enable value %d\\n\", pwm_enable);\n\t\treturn false;\n\t}\n}\n\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_min[nr] = rpm_to_reg(val);\n\tf75375_write16(client, F75375_REG_FAN_MIN(nr), data->fan_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t set_fan_target(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (auto_mode_enabled(data->pwm_enable[nr]))\n\t\treturn -EINVAL;\n\tif (data->kind == f75387 && duty_mode_enabled(data->pwm_enable[nr]))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_target[nr] = rpm_to_reg(val);\n\tf75375_write16(client, F75375_REG_FAN_EXP(nr), data->fan_target[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (auto_mode_enabled(data->pwm_enable[nr]) ||\n\t    !duty_mode_enabled(data->pwm_enable[nr]))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm[nr] = clamp_val(val, 0, 255);\n\tf75375_write_pwm(client, nr);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t show_pwm_enable(struct device *dev, struct device_attribute\n\t\t*attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct f75375_data *data = f75375_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm_enable[nr]);\n}\n\nstatic int set_pwm_enable_direct(struct i2c_client *client, int nr, int val)\n{\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\tu8 fanmode;\n\n\tif (val < 0 || val > 4)\n\t\treturn -EINVAL;\n\n\tfanmode = f75375_read8(client, F75375_REG_FAN_TIMER);\n\tif (data->kind == f75387) {\n\t\t \n\t\tif (duty_mode_enabled(data->pwm_enable[nr]) !=\n\t\t\t\tduty_mode_enabled(val))\n\t\t\treturn -EOPNOTSUPP;\n\t\t \n\t\tfanmode &= ~(1 << F75387_FAN_DUTY_MODE(nr));\n\t\tfanmode &= ~(1 << F75387_FAN_MANU_MODE(nr));\n\t\tswitch (val) {\n\t\tcase 0:  \n\t\t\tfanmode |= (1 << F75387_FAN_MANU_MODE(nr));\n\t\t\tfanmode |= (1 << F75387_FAN_DUTY_MODE(nr));\n\t\t\tdata->pwm[nr] = 255;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tfanmode  |= (1 << F75387_FAN_MANU_MODE(nr));\n\t\t\tfanmode  |= (1 << F75387_FAN_DUTY_MODE(nr));\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tfanmode |= (1 << F75387_FAN_MANU_MODE(nr));\n\t\t\tbreak;\n\t\tcase 4:  \n\t\t\tfanmode |= (1 << F75387_FAN_DUTY_MODE(nr));\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tfanmode &= ~(3 << FAN_CTRL_MODE(nr));\n\t\tswitch (val) {\n\t\tcase 0:  \n\t\t\tfanmode  |= (3 << FAN_CTRL_MODE(nr));\n\t\t\tdata->pwm[nr] = 255;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tfanmode  |= (3 << FAN_CTRL_MODE(nr));\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tfanmode  |= (1 << FAN_CTRL_MODE(nr));\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tbreak;\n\t\tcase 4:  \n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tf75375_write8(client, F75375_REG_FAN_TIMER, fanmode);\n\tdata->pwm_enable[nr] = val;\n\tif (val == 0)\n\t\tf75375_write_pwm(client, nr);\n\treturn 0;\n}\n\nstatic ssize_t set_pwm_enable(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\terr = set_pwm_enable_direct(client, nr, val);\n\tmutex_unlock(&data->update_lock);\n\treturn err ? err : count;\n}\n\nstatic ssize_t set_pwm_mode(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\tu8 conf;\n\tchar reg, ctrl;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!(val == 0 || val == 1))\n\t\treturn -EINVAL;\n\n\t \n\tif (data->kind == f75373 && val == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (data->kind == f75387) {\n\t\treg = F75375_REG_FAN_TIMER;\n\t\tctrl = F75387_FAN_CTRL_LINEAR(nr);\n\t} else {\n\t\treg = F75375_REG_CONFIG1;\n\t\tctrl = F75375_FAN_CTRL_LINEAR(nr);\n\t}\n\n\tmutex_lock(&data->update_lock);\n\tconf = f75375_read8(client, reg);\n\tconf &= ~(1 << ctrl);\n\n\tif (val == 0)\n\t\tconf |= (1 << ctrl);\n\n\tf75375_write8(client, reg, conf);\n\tdata->pwm_mode[nr] = val;\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute\n\t\t*attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct f75375_data *data = f75375_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm[nr]);\n}\n\nstatic ssize_t show_pwm_mode(struct device *dev, struct device_attribute\n\t\t*attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct f75375_data *data = f75375_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm_mode[nr]);\n}\n\n#define VOLT_FROM_REG(val) ((val) * 8)\n#define VOLT_TO_REG(val) ((val) / 8)\n\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct f75375_data *data = f75375_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", VOLT_FROM_REG(data->in[nr]));\n}\n\nstatic ssize_t show_in_max(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct f75375_data *data = f75375_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", VOLT_FROM_REG(data->in_max[nr]));\n}\n\nstatic ssize_t show_in_min(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct f75375_data *data = f75375_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", VOLT_FROM_REG(data->in_min[nr]));\n}\n\nstatic ssize_t set_in_max(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = clamp_val(VOLT_TO_REG(val), 0, 0xff);\n\tmutex_lock(&data->update_lock);\n\tdata->in_max[nr] = val;\n\tf75375_write8(client, F75375_REG_VOLT_HIGH(nr), data->in_max[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t set_in_min(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = clamp_val(VOLT_TO_REG(val), 0, 0xff);\n\tmutex_lock(&data->update_lock);\n\tdata->in_min[nr] = val;\n\tf75375_write8(client, F75375_REG_VOLT_LOW(nr), data->in_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n#define TEMP_FROM_REG(val) ((val) * 1000)\n#define TEMP_TO_REG(val) ((val) / 1000)\n#define TEMP11_FROM_REG(reg)\t((reg) / 32 * 125)\n\nstatic ssize_t show_temp11(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct f75375_data *data = f75375_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP11_FROM_REG(data->temp11[nr]));\n}\n\nstatic ssize_t show_temp_max(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct f75375_data *data = f75375_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_high[nr]));\n}\n\nstatic ssize_t show_temp_max_hyst(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct f75375_data *data = f75375_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_max_hyst[nr]));\n}\n\nstatic ssize_t set_temp_max(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = clamp_val(TEMP_TO_REG(val), 0, 127);\n\tmutex_lock(&data->update_lock);\n\tdata->temp_high[nr] = val;\n\tf75375_write8(client, F75375_REG_TEMP_HIGH(nr), data->temp_high[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t set_temp_max_hyst(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = clamp_val(TEMP_TO_REG(val), 0, 127);\n\tmutex_lock(&data->update_lock);\n\tdata->temp_max_hyst[nr] = val;\n\tf75375_write8(client, F75375_REG_TEMP_HYST(nr),\n\t\tdata->temp_max_hyst[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n#define show_fan(thing) \\\nstatic ssize_t show_##thing(struct device *dev, struct device_attribute *attr, \\\n\t\t\tchar *buf)\\\n{\\\n\tint nr = to_sensor_dev_attr(attr)->index;\\\n\tstruct f75375_data *data = f75375_update_device(dev); \\\n\treturn sprintf(buf, \"%d\\n\", rpm_from_reg(data->thing[nr])); \\\n}\n\nshow_fan(fan);\nshow_fan(fan_min);\nshow_fan(fan_max);\nshow_fan(fan_target);\n\nstatic SENSOR_DEVICE_ATTR(in0_input, S_IRUGO, show_in, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(in0_max, S_IRUGO|S_IWUSR,\n\tshow_in_max, set_in_max, 0);\nstatic SENSOR_DEVICE_ATTR(in0_min, S_IRUGO|S_IWUSR,\n\tshow_in_min, set_in_min, 0);\nstatic SENSOR_DEVICE_ATTR(in1_input, S_IRUGO, show_in, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in1_max, S_IRUGO|S_IWUSR,\n\tshow_in_max, set_in_max, 1);\nstatic SENSOR_DEVICE_ATTR(in1_min, S_IRUGO|S_IWUSR,\n\tshow_in_min, set_in_min, 1);\nstatic SENSOR_DEVICE_ATTR(in2_input, S_IRUGO, show_in, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(in2_max, S_IRUGO|S_IWUSR,\n\tshow_in_max, set_in_max, 2);\nstatic SENSOR_DEVICE_ATTR(in2_min, S_IRUGO|S_IWUSR,\n\tshow_in_min, set_in_min, 2);\nstatic SENSOR_DEVICE_ATTR(in3_input, S_IRUGO, show_in, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(in3_max, S_IRUGO|S_IWUSR,\n\tshow_in_max, set_in_max, 3);\nstatic SENSOR_DEVICE_ATTR(in3_min, S_IRUGO|S_IWUSR,\n\tshow_in_min, set_in_min, 3);\nstatic SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp11, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(temp1_max_hyst, S_IRUGO|S_IWUSR,\n\tshow_temp_max_hyst, set_temp_max_hyst, 0);\nstatic SENSOR_DEVICE_ATTR(temp1_max, S_IRUGO|S_IWUSR,\n\tshow_temp_max, set_temp_max, 0);\nstatic SENSOR_DEVICE_ATTR(temp2_input, S_IRUGO, show_temp11, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(temp2_max_hyst, S_IRUGO|S_IWUSR,\n\tshow_temp_max_hyst, set_temp_max_hyst, 1);\nstatic SENSOR_DEVICE_ATTR(temp2_max, S_IRUGO|S_IWUSR,\n\tshow_temp_max, set_temp_max, 1);\nstatic SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO, show_fan, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(fan1_max, S_IRUGO, show_fan_max, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(fan1_min, S_IRUGO|S_IWUSR,\n\tshow_fan_min, set_fan_min, 0);\nstatic SENSOR_DEVICE_ATTR(fan1_target, S_IRUGO|S_IWUSR,\n\tshow_fan_target, set_fan_target, 0);\nstatic SENSOR_DEVICE_ATTR(fan2_input, S_IRUGO, show_fan, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(fan2_max, S_IRUGO, show_fan_max, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(fan2_min, S_IRUGO|S_IWUSR,\n\tshow_fan_min, set_fan_min, 1);\nstatic SENSOR_DEVICE_ATTR(fan2_target, S_IRUGO|S_IWUSR,\n\tshow_fan_target, set_fan_target, 1);\nstatic SENSOR_DEVICE_ATTR(pwm1, S_IRUGO|S_IWUSR,\n\tshow_pwm, set_pwm, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1_enable, S_IRUGO|S_IWUSR,\n\tshow_pwm_enable, set_pwm_enable, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1_mode, S_IRUGO,\n\tshow_pwm_mode, set_pwm_mode, 0);\nstatic SENSOR_DEVICE_ATTR(pwm2, S_IRUGO | S_IWUSR,\n\tshow_pwm, set_pwm, 1);\nstatic SENSOR_DEVICE_ATTR(pwm2_enable, S_IRUGO|S_IWUSR,\n\tshow_pwm_enable, set_pwm_enable, 1);\nstatic SENSOR_DEVICE_ATTR(pwm2_mode, S_IRUGO,\n\tshow_pwm_mode, set_pwm_mode, 1);\n\nstatic struct attribute *f75375_attributes[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_max.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_target.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_max.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_target.dev_attr.attr,\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_mode.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_mode.dev_attr.attr,\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group f75375_group = {\n\t.attrs = f75375_attributes,\n};\n\nstatic void f75375_init(struct i2c_client *client, struct f75375_data *data,\n\t\tstruct f75375s_platform_data *f75375s_pdata)\n{\n\tint nr;\n\n\tif (!f75375s_pdata) {\n\t\tu8 conf, mode;\n\t\tint nr;\n\n\t\tconf = f75375_read8(client, F75375_REG_CONFIG1);\n\t\tmode = f75375_read8(client, F75375_REG_FAN_TIMER);\n\t\tfor (nr = 0; nr < 2; nr++) {\n\t\t\tif (data->kind == f75387) {\n\t\t\t\tbool manu, duty;\n\n\t\t\t\tif (!(mode & (1 << F75387_FAN_CTRL_LINEAR(nr))))\n\t\t\t\t\tdata->pwm_mode[nr] = 1;\n\n\t\t\t\tmanu = ((mode >> F75387_FAN_MANU_MODE(nr)) & 1);\n\t\t\t\tduty = ((mode >> F75387_FAN_DUTY_MODE(nr)) & 1);\n\t\t\t\tif (!manu && duty)\n\t\t\t\t\t \n\t\t\t\t\tdata->pwm_enable[nr] = 4;\n\t\t\t\telse if (manu && !duty)\n\t\t\t\t\t \n\t\t\t\t\tdata->pwm_enable[nr] = 3;\n\t\t\t\telse if (!manu && !duty)\n\t\t\t\t\t \n\t\t\t\t\tdata->pwm_enable[nr] = 2;\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tdata->pwm_enable[nr] = 1;\n\t\t\t} else {\n\t\t\t\tif (!(conf & (1 << F75375_FAN_CTRL_LINEAR(nr))))\n\t\t\t\t\tdata->pwm_mode[nr] = 1;\n\n\t\t\t\tswitch ((mode >> FAN_CTRL_MODE(nr)) & 3) {\n\t\t\t\tcase 0:\t\t \n\t\t\t\t\tdata->pwm_enable[nr] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\t\t \n\t\t\t\t\tdata->pwm_enable[nr] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\t \n\t\t\t\t\tdata->pwm_enable[nr] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tset_pwm_enable_direct(client, 0, f75375s_pdata->pwm_enable[0]);\n\tset_pwm_enable_direct(client, 1, f75375s_pdata->pwm_enable[1]);\n\tfor (nr = 0; nr < 2; nr++) {\n\t\tif (auto_mode_enabled(f75375s_pdata->pwm_enable[nr]) ||\n\t\t    !duty_mode_enabled(f75375s_pdata->pwm_enable[nr]))\n\t\t\tcontinue;\n\t\tdata->pwm[nr] = clamp_val(f75375s_pdata->pwm[nr], 0, 255);\n\t\tf75375_write_pwm(client, nr);\n\t}\n\n}\n\nstatic int f75375_probe(struct i2c_client *client)\n{\n\tstruct f75375_data *data;\n\tstruct f75375s_platform_data *f75375s_pdata =\n\t\t\tdev_get_platdata(&client->dev);\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\tI2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\tdata = devm_kzalloc(&client->dev, sizeof(struct f75375_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\tdata->kind = i2c_match_id(f75375_id, client)->driver_data;\n\n\terr = sysfs_create_group(&client->dev.kobj, &f75375_group);\n\tif (err)\n\t\treturn err;\n\n\tif (data->kind != f75373) {\n\t\terr = sysfs_chmod_file(&client->dev.kobj,\n\t\t\t&sensor_dev_attr_pwm1_mode.dev_attr.attr,\n\t\t\tS_IRUGO | S_IWUSR);\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\t\terr = sysfs_chmod_file(&client->dev.kobj,\n\t\t\t&sensor_dev_attr_pwm2_mode.dev_attr.attr,\n\t\t\tS_IRUGO | S_IWUSR);\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\t}\n\n\tdata->hwmon_dev = hwmon_device_register(&client->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto exit_remove;\n\t}\n\n\tf75375_init(client, data, f75375s_pdata);\n\n\treturn 0;\n\nexit_remove:\n\tsysfs_remove_group(&client->dev.kobj, &f75375_group);\n\treturn err;\n}\n\nstatic void f75375_remove(struct i2c_client *client)\n{\n\tstruct f75375_data *data = i2c_get_clientdata(client);\n\thwmon_device_unregister(data->hwmon_dev);\n\tsysfs_remove_group(&client->dev.kobj, &f75375_group);\n}\n\n \nstatic int f75375_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tu16 vendid, chipid;\n\tu8 version;\n\tconst char *name;\n\n\tvendid = f75375_read16(client, F75375_REG_VENDOR);\n\tchipid = f75375_read16(client, F75375_CHIP_ID);\n\tif (vendid != 0x1934)\n\t\treturn -ENODEV;\n\n\tif (chipid == 0x0306)\n\t\tname = \"f75375\";\n\telse if (chipid == 0x0204)\n\t\tname = \"f75373\";\n\telse if (chipid == 0x0410)\n\t\tname = \"f75387\";\n\telse\n\t\treturn -ENODEV;\n\n\tversion = f75375_read8(client, F75375_REG_VERSION);\n\tdev_info(&adapter->dev, \"found %s version: %02X\\n\", name, version);\n\tstrscpy(info->type, name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nmodule_i2c_driver(f75375_driver);\n\nMODULE_AUTHOR(\"Riku Voipio\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"F75373/F75375/F75387 hardware monitoring driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}