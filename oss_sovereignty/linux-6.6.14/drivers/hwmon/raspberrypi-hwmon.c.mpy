{
  "module_name": "raspberrypi-hwmon.c",
  "hash_id": "366dfcccb04f0d4575ccbe8739fa6c5fed9082183b7cece053ae85a4546bdf53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/raspberrypi-hwmon.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/devm-helpers.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <soc/bcm2835/raspberrypi-firmware.h>\n\n#define UNDERVOLTAGE_STICKY_BIT\tBIT(16)\n\nstruct rpi_hwmon_data {\n\tstruct device *hwmon_dev;\n\tstruct rpi_firmware *fw;\n\tu32 last_throttled;\n\tstruct delayed_work get_values_poll_work;\n};\n\nstatic void rpi_firmware_get_throttled(struct rpi_hwmon_data *data)\n{\n\tu32 new_uv, old_uv, value;\n\tint ret;\n\n\t \n\tvalue = 0xffff;\n\n\tret = rpi_firmware_property(data->fw, RPI_FIRMWARE_GET_THROTTLED,\n\t\t\t\t    &value, sizeof(value));\n\tif (ret) {\n\t\tdev_err_once(data->hwmon_dev, \"Failed to get throttled (%d)\\n\",\n\t\t\t     ret);\n\t\treturn;\n\t}\n\n\tnew_uv = value & UNDERVOLTAGE_STICKY_BIT;\n\told_uv = data->last_throttled & UNDERVOLTAGE_STICKY_BIT;\n\tdata->last_throttled = value;\n\n\tif (new_uv == old_uv)\n\t\treturn;\n\n\tif (new_uv)\n\t\tdev_crit(data->hwmon_dev, \"Undervoltage detected!\\n\");\n\telse\n\t\tdev_info(data->hwmon_dev, \"Voltage normalised\\n\");\n\n\thwmon_notify_event(data->hwmon_dev, hwmon_in, hwmon_in_lcrit_alarm, 0);\n}\n\nstatic void get_values_poll(struct work_struct *work)\n{\n\tstruct rpi_hwmon_data *data;\n\n\tdata = container_of(work, struct rpi_hwmon_data,\n\t\t\t    get_values_poll_work.work);\n\n\trpi_firmware_get_throttled(data);\n\n\t \n\tschedule_delayed_work(&data->get_values_poll_work, 2 * HZ);\n}\n\nstatic int rpi_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t    u32 attr, int channel, long *val)\n{\n\tstruct rpi_hwmon_data *data = dev_get_drvdata(dev);\n\n\t*val = !!(data->last_throttled & UNDERVOLTAGE_STICKY_BIT);\n\treturn 0;\n}\n\nstatic umode_t rpi_is_visible(const void *_data, enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel)\n{\n\treturn 0444;\n}\n\nstatic const struct hwmon_channel_info * const rpi_info[] = {\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_LCRIT_ALARM),\n\tNULL\n};\n\nstatic const struct hwmon_ops rpi_hwmon_ops = {\n\t.is_visible = rpi_is_visible,\n\t.read = rpi_read,\n};\n\nstatic const struct hwmon_chip_info rpi_chip_info = {\n\t.ops = &rpi_hwmon_ops,\n\t.info = rpi_info,\n};\n\nstatic int rpi_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rpi_hwmon_data *data;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tdata->fw = dev_get_drvdata(dev->parent);\n\n\tdata->hwmon_dev = devm_hwmon_device_register_with_info(dev, \"rpi_volt\",\n\t\t\t\t\t\t\t       data,\n\t\t\t\t\t\t\t       &rpi_chip_info,\n\t\t\t\t\t\t\t       NULL);\n\tif (IS_ERR(data->hwmon_dev))\n\t\treturn PTR_ERR(data->hwmon_dev);\n\n\tret = devm_delayed_work_autocancel(dev, &data->get_values_poll_work,\n\t\t\t\t\t   get_values_poll);\n\tif (ret)\n\t\treturn ret;\n\tplatform_set_drvdata(pdev, data);\n\n\tschedule_delayed_work(&data->get_values_poll_work, 2 * HZ);\n\n\treturn 0;\n}\n\nstatic struct platform_driver rpi_hwmon_driver = {\n\t.probe = rpi_hwmon_probe,\n\t.driver = {\n\t\t.name = \"raspberrypi-hwmon\",\n\t},\n};\nmodule_platform_driver(rpi_hwmon_driver);\n\nMODULE_AUTHOR(\"Stefan Wahren <wahrenst@gmx.net>\");\nMODULE_DESCRIPTION(\"Raspberry Pi voltage sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:raspberrypi-hwmon\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}