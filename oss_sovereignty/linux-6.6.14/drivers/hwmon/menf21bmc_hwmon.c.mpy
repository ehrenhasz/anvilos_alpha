{
  "module_name": "menf21bmc_hwmon.c",
  "hash_id": "2b440bc316381dba6958eac6833be38ee9bc93459fe388ee7e9cbdc265ad3ffd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/menf21bmc_hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n\n#define DRV_NAME  \"menf21bmc_hwmon\"\n\n#define BMC_VOLT_COUNT\t5\n#define MENF21BMC_V33\t0\n#define MENF21BMC_V5\t1\n#define MENF21BMC_V12\t2\n#define MENF21BMC_V5_SB\t3\n#define MENF21BMC_VBAT\t4\n\n#define IDX_TO_VOLT_MIN_CMD(idx) (0x40 + idx)\n#define IDX_TO_VOLT_MAX_CMD(idx) (0x50 + idx)\n#define IDX_TO_VOLT_INP_CMD(idx) (0x60 + idx)\n\nstruct menf21bmc_hwmon {\n\tbool valid;\n\tstruct i2c_client *i2c_client;\n\tunsigned long last_update;\n\tint in_val[BMC_VOLT_COUNT];\n\tint in_min[BMC_VOLT_COUNT];\n\tint in_max[BMC_VOLT_COUNT];\n};\n\nstatic const char *const input_names[] = {\n\t[MENF21BMC_V33]\t\t= \"MON_3_3V\",\n\t[MENF21BMC_V5]\t\t= \"MON_5V\",\n\t[MENF21BMC_V12]\t\t= \"MON_12V\",\n\t[MENF21BMC_V5_SB]\t= \"5V_STANDBY\",\n\t[MENF21BMC_VBAT]\t= \"VBAT\"\n};\n\nstatic struct menf21bmc_hwmon *menf21bmc_hwmon_update(struct device *dev)\n{\n\tint i;\n\tint val;\n\tstruct menf21bmc_hwmon *drv_data = dev_get_drvdata(dev);\n\tstruct menf21bmc_hwmon *data_ret = drv_data;\n\n\tif (time_after(jiffies, drv_data->last_update + HZ)\n\t    || !drv_data->valid) {\n\t\tfor (i = 0; i < BMC_VOLT_COUNT; i++) {\n\t\t\tval = i2c_smbus_read_word_data(drv_data->i2c_client,\n\t\t\t\t\t\t       IDX_TO_VOLT_INP_CMD(i));\n\t\t\tif (val < 0) {\n\t\t\t\tdata_ret = ERR_PTR(val);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tdrv_data->in_val[i] = val;\n\t\t}\n\t\tdrv_data->last_update = jiffies;\n\t\tdrv_data->valid = true;\n\t}\nabort:\n\treturn data_ret;\n}\n\nstatic int menf21bmc_hwmon_get_volt_limits(struct menf21bmc_hwmon *drv_data)\n{\n\tint i, val;\n\n\tfor (i = 0; i < BMC_VOLT_COUNT; i++) {\n\t\tval = i2c_smbus_read_word_data(drv_data->i2c_client,\n\t\t\t\t\t       IDX_TO_VOLT_MIN_CMD(i));\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tdrv_data->in_min[i] = val;\n\n\t\tval = i2c_smbus_read_word_data(drv_data->i2c_client,\n\t\t\t\t\t       IDX_TO_VOLT_MAX_CMD(i));\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tdrv_data->in_max[i] = val;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t\nlabel_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\n\treturn sprintf(buf, \"%s\\n\", input_names[attr->index]);\n}\n\nstatic ssize_t\nin_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct menf21bmc_hwmon *drv_data = menf21bmc_hwmon_update(dev);\n\n\tif (IS_ERR(drv_data))\n\t\treturn PTR_ERR(drv_data);\n\n\treturn sprintf(buf, \"%d\\n\", drv_data->in_val[attr->index]);\n}\n\nstatic ssize_t\nmin_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct menf21bmc_hwmon *drv_data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", drv_data->in_min[attr->index]);\n}\n\nstatic ssize_t\nmax_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct menf21bmc_hwmon *drv_data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", drv_data->in_max[attr->index]);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_input, in, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in0_min, min, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in0_max, max, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in0_label, label, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, in, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in1_min, min, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in1_max, max, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in1_label, label, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, in, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in2_min, min, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in2_max, max, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in2_label, label, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, in, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in3_min, min, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in3_max, max, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in3_label, label, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, in, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in4_min, min, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in4_max, max, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in4_label, label, 4);\n\nstatic struct attribute *menf21bmc_hwmon_attrs[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_label.dev_attr.attr,\n\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_label.dev_attr.attr,\n\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_label.dev_attr.attr,\n\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_label.dev_attr.attr,\n\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_label.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(menf21bmc_hwmon);\n\nstatic int menf21bmc_hwmon_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct menf21bmc_hwmon *drv_data;\n\tstruct i2c_client *i2c_client = to_i2c_client(pdev->dev.parent);\n\tstruct device *hwmon_dev;\n\n\tdrv_data = devm_kzalloc(&pdev->dev, sizeof(struct menf21bmc_hwmon),\n\t\t\t\tGFP_KERNEL);\n\tif (!drv_data)\n\t\treturn -ENOMEM;\n\n\tdrv_data->i2c_client = i2c_client;\n\n\tret = menf21bmc_hwmon_get_volt_limits(drv_data);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to read sensor limits\");\n\t\treturn ret;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(&pdev->dev,\n\t\t\t\t\t\t   \"menf21bmc\", drv_data,\n\t\t\t\t\t\t   menf21bmc_hwmon_groups);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdev_info(&pdev->dev, \"MEN 14F021P00 BMC hwmon device enabled\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver menf21bmc_hwmon = {\n\t.probe\t\t= menf21bmc_hwmon_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= DRV_NAME,\n\t},\n};\n\nmodule_platform_driver(menf21bmc_hwmon);\n\nMODULE_AUTHOR(\"Andreas Werner <andreas.werner@men.de>\");\nMODULE_DESCRIPTION(\"MEN 14F021P00 BMC hwmon\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:menf21bmc_hwmon\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}