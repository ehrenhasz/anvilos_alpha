{
  "module_name": "lm93.c",
  "hash_id": "227d7b6c2d91304300bdc4d72a486116fdec0574243d0ed1778800845525888f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lm93.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon-vid.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n\n \n\n \n#define LM93_REG_MFR_ID\t\t\t0x3e\n#define LM93_REG_VER\t\t\t0x3f\n#define LM93_REG_STATUS_CONTROL\t\t0xe2\n#define LM93_REG_CONFIG\t\t\t0xe3\n#define LM93_REG_SLEEP_CONTROL\t\t0xe4\n\n \n#define LM93_REG_HOST_ERROR_1\t\t0x48\n\n \n#define LM93_REG_IN(nr)\t\t\t(0x56 + (nr))\n#define LM93_REG_IN_MIN(nr)\t\t(0x90 + (nr) * 2)\n#define LM93_REG_IN_MAX(nr)\t\t(0x91 + (nr) * 2)\n\n \n#define LM93_REG_TEMP(nr)\t\t(0x50 + (nr))\n#define LM93_REG_TEMP_MIN(nr)\t\t(0x78 + (nr) * 2)\n#define LM93_REG_TEMP_MAX(nr)\t\t(0x79 + (nr) * 2)\n\n \n#define LM93_REG_BOOST(nr)\t\t(0x80 + (nr))\n\n \n#define LM93_REG_PROCHOT_CUR(nr)\t(0x67 + (nr) * 2)\n#define LM93_REG_PROCHOT_AVG(nr)\t(0x68 + (nr) * 2)\n#define LM93_REG_PROCHOT_MAX(nr)\t(0xb0 + (nr))\n\n \n#define LM93_REG_FAN(nr)\t\t(0x6e + (nr) * 2)\n#define LM93_REG_FAN_MIN(nr)\t\t(0xb4 + (nr) * 2)\n\n \n#define LM93_REG_PWM_CTL(nr, reg)\t(0xc8 + (reg) + (nr) * 4)\n#define LM93_PWM_CTL1\t0x0\n#define LM93_PWM_CTL2\t0x1\n#define LM93_PWM_CTL3\t0x2\n#define LM93_PWM_CTL4\t0x3\n\n \n#define LM93_REG_GPI\t\t\t0x6b\n\n \n#define LM93_REG_VID(nr)\t\t(0x6c + (nr))\n\n \n#define LM93_REG_VCCP_LIMIT_OFF(nr)\t(0xb2 + (nr))\n\n \n#define LM93_REG_BOOST_HYST_12\t\t0xc0\n#define LM93_REG_BOOST_HYST_34\t\t0xc1\n#define LM93_REG_BOOST_HYST(nr)\t\t(0xc0 + (nr)/2)\n\n \n#define LM93_REG_PWM_MIN_HYST_12\t0xc3\n#define LM93_REG_PWM_MIN_HYST_34\t0xc4\n#define LM93_REG_PWM_MIN_HYST(nr)\t(0xc3 + (nr)/2)\n\n \n#define LM93_REG_PROCHOT_OVERRIDE\t0xc6\n#define LM93_REG_PROCHOT_INTERVAL\t0xc7\n\n \n#define LM93_REG_TEMP_BASE(nr)\t\t(0xd0 + (nr))\n\n \n#define LM93_REG_TEMP_OFFSET(step)\t(0xd4 + (step))\n\n \n#define LM93_REG_PWM_RAMP_CTL\t\t0xbf\n\n \n#define LM93_REG_SFC1\t\t0xbc\n#define LM93_REG_SFC2\t\t0xbd\n#define LM93_REG_GPI_VID_CTL\t0xbe\n#define LM93_REG_SF_TACH_TO_PWM\t0xe0\n\n \n#define LM93_REG_GPI_ERR_MASK\t0xec\n#define LM93_REG_MISC_ERR_MASK\t0xed\n\n \n#define LM93_MFR_ID\t\t0x73\n#define LM93_MFR_ID_PROTOTYPE\t0x72\n\n \n#define LM94_MFR_ID_2\t\t0x7a\n#define LM94_MFR_ID\t\t0x79\n#define LM94_MFR_ID_PROTOTYPE\t0x78\n\n \n#define LM93_SMBUS_FUNC_FULL (I2C_FUNC_SMBUS_BYTE_DATA | \\\n\t\tI2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_BLOCK_DATA)\n#define LM93_SMBUS_FUNC_MIN  (I2C_FUNC_SMBUS_BYTE_DATA | \\\n\t\tI2C_FUNC_SMBUS_WORD_DATA)\n\n \nstatic const unsigned short normal_i2c[] = { 0x2c, 0x2d, 0x2e, I2C_CLIENT_END };\n\n \n\nstatic bool disable_block;\nmodule_param(disable_block, bool, 0);\nMODULE_PARM_DESC(disable_block,\n\t\"Set to non-zero to disable SMBus block data transactions.\");\n\nstatic bool init;\nmodule_param(init, bool, 0);\nMODULE_PARM_DESC(init, \"Set to non-zero to force chip initialization.\");\n\nstatic int vccp_limit_type[2] = {0, 0};\nmodule_param_array(vccp_limit_type, int, NULL, 0);\nMODULE_PARM_DESC(vccp_limit_type, \"Configures in7 and in8 limit modes.\");\n\nstatic int vid_agtl;\nmodule_param(vid_agtl, int, 0);\nMODULE_PARM_DESC(vid_agtl, \"Configures VID pin input thresholds.\");\n\n \nstatic struct i2c_driver lm93_driver;\n\n \nstatic const struct { u8 cmd; u8 len; } lm93_block_read_cmds[12] = {\n\t{ 0xf2,  8 },\n\t{ 0xf3,  8 },\n\t{ 0xf4,  6 },\n\t{ 0xf5, 16 },\n\t{ 0xf6,  4 },\n\t{ 0xf7,  8 },\n\t{ 0xf8, 12 },\n\t{ 0xf9, 32 },\n\t{ 0xfa,  8 },\n\t{ 0xfb,  8 },\n\t{ 0xfc, 16 },\n\t{ 0xfd,  9 },\n};\n\n \nstruct block1_t {\n\tu8 host_status_1;\n\tu8 host_status_2;\n\tu8 host_status_3;\n\tu8 host_status_4;\n\tu8 p1_prochot_status;\n\tu8 p2_prochot_status;\n\tu8 gpi_status;\n\tu8 fan_status;\n};\n\n \nstruct lm93_data {\n\tstruct i2c_client *client;\n\n\tstruct mutex update_lock;\n\tunsigned long last_updated;\t \n\n\t \n\tvoid (*update)(struct lm93_data *, struct i2c_client *);\n\n\tbool valid;  \n\n\t \n\tstruct block1_t block1;\n\n\t \n\tu8 block2[6];\n\n\t \n\tu8 block3[16];\n\n\t \n\tstruct {\n\t\tu8 cur;\n\t\tu8 avg;\n\t} block4[2];\n\n\t \n\tu16 block5[4];\n\n\t \n\tstruct {\n\t\tu8 min;\n\t\tu8 max;\n\t} temp_lim[4];\n\n\t \n\tstruct {\n\t\tu8 min;\n\t\tu8 max;\n\t} block7[16];\n\n\t \n\tu16 block8[4];\n\n\t \n\tu8 block9[2][4];\n\n\t \n\tstruct {\n\t\tu8 base[4];\n\t\tu8 offset[12];\n\t} block10;\n\n\t \n\tu8 config;\n\n\t \n\tu8 vid[2];\n\n\t \n\tu8 prochot_max[2];\n\n\t \n\tu8 vccp_limits[2];\n\n\t \n\tu8 gpi;\n\n\t \n\tu8 prochot_override;\n\n\t \n\tu8 prochot_interval;\n\n\t \n\tu8 boost[4];\n\n\t \n\tu8 boost_hyst[2];\n\n\t \n\tu8 auto_pwm_min_hyst[2];\n\n\t \n\tu8 pwm_ramp_ctl;\n\n\t \n\tu8 sfc1;\n\tu8 sfc2;\n\tu8 sf_tach_to_pwm;\n\n\t \n\tu8 pwm_override[2];\n};\n\n \nstatic int LM93_VID_FROM_REG(u8 reg)\n{\n\treturn vid_from_reg((reg & 0x3f), 100);\n}\n\n \nstatic const u8 lm93_vin_reg_min[16] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xae,\n};\nstatic const u8 lm93_vin_reg_max[16] = {\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xfa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd1,\n};\n \n\n \nstatic const unsigned long lm93_vin_val_min[16] = {\n\t0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 3000,\n};\n\nstatic const unsigned long lm93_vin_val_max[16] = {\n\t1236, 1236, 1236, 1600, 2000, 2000, 1600, 1600,\n\t4400, 6500, 3333, 2625, 1312, 1312, 1236, 3600,\n};\n \n\nstatic unsigned LM93_IN_FROM_REG(int nr, u8 reg)\n{\n\tconst long uv_max = lm93_vin_val_max[nr] * 1000;\n\tconst long uv_min = lm93_vin_val_min[nr] * 1000;\n\n\tconst long slope = (uv_max - uv_min) /\n\t\t(lm93_vin_reg_max[nr] - lm93_vin_reg_min[nr]);\n\tconst long intercept = uv_min - slope * lm93_vin_reg_min[nr];\n\n\treturn (slope * reg + intercept + 500) / 1000;\n}\n\n \nstatic u8 LM93_IN_TO_REG(int nr, unsigned val)\n{\n\t \n\tconst long mv = clamp_val(val,\n\t\t\t\t  lm93_vin_val_min[nr], lm93_vin_val_max[nr]);\n\n\t \n\tconst long uv = mv * 1000;\n\tconst long uv_max = lm93_vin_val_max[nr] * 1000;\n\tconst long uv_min = lm93_vin_val_min[nr] * 1000;\n\n\t \n\tconst long slope = (uv_max - uv_min) /\n\t\t(lm93_vin_reg_max[nr] - lm93_vin_reg_min[nr]);\n\tconst long intercept = uv_min - slope * lm93_vin_reg_min[nr];\n\n\tu8 result = ((uv - intercept + (slope/2)) / slope);\n\tresult = clamp_val(result,\n\t\t\t   lm93_vin_reg_min[nr], lm93_vin_reg_max[nr]);\n\treturn result;\n}\n\n \nstatic unsigned LM93_IN_REL_FROM_REG(u8 reg, int upper, int vid)\n{\n\tconst long uv_offset = upper ? (((reg >> 4 & 0x0f) + 1) * 12500) :\n\t\t\t\t(((reg >> 0 & 0x0f) + 1) * -25000);\n\tconst long uv_vid = vid * 1000;\n\treturn (uv_vid + uv_offset + 5000) / 10000;\n}\n\n#define LM93_IN_MIN_FROM_REG(reg, vid)\tLM93_IN_REL_FROM_REG((reg), 0, (vid))\n#define LM93_IN_MAX_FROM_REG(reg, vid)\tLM93_IN_REL_FROM_REG((reg), 1, (vid))\n\n \nstatic u8 LM93_IN_REL_TO_REG(unsigned val, int upper, int vid)\n{\n\tlong uv_offset = vid * 1000 - val * 10000;\n\tif (upper) {\n\t\tuv_offset = clamp_val(uv_offset, 12500, 200000);\n\t\treturn (u8)((uv_offset /  12500 - 1) << 4);\n\t} else {\n\t\tuv_offset = clamp_val(uv_offset, -400000, -25000);\n\t\treturn (u8)((uv_offset / -25000 - 1) << 0);\n\t}\n}\n\n \nstatic int LM93_TEMP_FROM_REG(u8 reg)\n{\n\treturn (s8)reg * 1000;\n}\n\n#define LM93_TEMP_MIN (-128000)\n#define LM93_TEMP_MAX (127000)\n\n \nstatic u8 LM93_TEMP_TO_REG(long temp)\n{\n\tint ntemp = clamp_val(temp, LM93_TEMP_MIN, LM93_TEMP_MAX);\n\tntemp += (ntemp < 0 ? -500 : 500);\n\treturn (u8)(ntemp / 1000);\n}\n\n \nstatic int LM93_TEMP_OFFSET_MODE_FROM_REG(u8 sfc2, int nr)\n{\n\t \n\treturn sfc2 & (nr < 2 ? 0x10 : 0x20);\n}\n\n \nstatic int LM93_TEMP_OFFSET_FROM_REG(u8 reg, int mode)\n{\n\treturn (reg & 0x0f) * (mode ? 5 : 10);\n}\n\n#define LM93_TEMP_OFFSET_MIN  (0)\n#define LM93_TEMP_OFFSET_MAX0 (150)\n#define LM93_TEMP_OFFSET_MAX1 (75)\n\n \nstatic u8 LM93_TEMP_OFFSET_TO_REG(int off, int mode)\n{\n\tint factor = mode ? 5 : 10;\n\n\toff = clamp_val(off, LM93_TEMP_OFFSET_MIN,\n\t\tmode ? LM93_TEMP_OFFSET_MAX1 : LM93_TEMP_OFFSET_MAX0);\n\treturn (u8)((off + factor/2) / factor);\n}\n\n \nstatic int LM93_TEMP_AUTO_OFFSET_FROM_REG(u8 reg, int nr, int mode)\n{\n\t \n\tif (nr < 2)\n\t\treturn LM93_TEMP_OFFSET_FROM_REG(reg & 0x0f, mode);\n\n\t \n\telse\n\t\treturn LM93_TEMP_OFFSET_FROM_REG(reg >> 4 & 0x0f, mode);\n}\n\n \nstatic u8 LM93_TEMP_AUTO_OFFSET_TO_REG(u8 old, int off, int nr, int mode)\n{\n\tu8 new = LM93_TEMP_OFFSET_TO_REG(off, mode);\n\n\t \n\tif (nr < 2)\n\t\treturn (old & 0xf0) | (new & 0x0f);\n\n\t \n\telse\n\t\treturn (new << 4 & 0xf0) | (old & 0x0f);\n}\n\nstatic int LM93_AUTO_BOOST_HYST_FROM_REGS(struct lm93_data *data, int nr,\n\t\tint mode)\n{\n\tu8 reg;\n\n\tswitch (nr) {\n\tcase 0:\n\t\treg = data->boost_hyst[0] & 0x0f;\n\t\tbreak;\n\tcase 1:\n\t\treg = data->boost_hyst[0] >> 4 & 0x0f;\n\t\tbreak;\n\tcase 2:\n\t\treg = data->boost_hyst[1] & 0x0f;\n\t\tbreak;\n\tcase 3:\n\tdefault:\n\t\treg = data->boost_hyst[1] >> 4 & 0x0f;\n\t\tbreak;\n\t}\n\n\treturn LM93_TEMP_FROM_REG(data->boost[nr]) -\n\t\t\tLM93_TEMP_OFFSET_FROM_REG(reg, mode);\n}\n\nstatic u8 LM93_AUTO_BOOST_HYST_TO_REG(struct lm93_data *data, long hyst,\n\t\tint nr, int mode)\n{\n\tu8 reg = LM93_TEMP_OFFSET_TO_REG(\n\t\t\t(LM93_TEMP_FROM_REG(data->boost[nr]) - hyst), mode);\n\n\tswitch (nr) {\n\tcase 0:\n\t\treg = (data->boost_hyst[0] & 0xf0) | (reg & 0x0f);\n\t\tbreak;\n\tcase 1:\n\t\treg = (reg << 4 & 0xf0) | (data->boost_hyst[0] & 0x0f);\n\t\tbreak;\n\tcase 2:\n\t\treg = (data->boost_hyst[1] & 0xf0) | (reg & 0x0f);\n\t\tbreak;\n\tcase 3:\n\tdefault:\n\t\treg = (reg << 4 & 0xf0) | (data->boost_hyst[1] & 0x0f);\n\t\tbreak;\n\t}\n\n\treturn reg;\n}\n\n \nenum pwm_freq { LM93_PWM_MAP_HI_FREQ, LM93_PWM_MAP_LO_FREQ };\n\nstatic int lm93_pwm_map[2][16] = {\n\t{\n\t\t0x00,   0x40,  \n\t\t0x50,   0x60,  \n\t\t0x70,   0x80,  \n\t\t0x90,   0xa0,  \n\t\t0xb0,   0xc0,  \n\t\t0xd0,   0xe0,  \n\t\t0xf0,   0xff,  \n\t\t0xff, 0xff,  \n\t},\n\t{\n\t\t0x00,   0x40,  \n\t\t0x49,   0x52,  \n\t\t0x5b,   0x64,  \n\t\t0x6d,   0x76,  \n\t\t0x80,   0x89,  \n\t\t0x92,   0xb6,  \n\t\t0xdb,   0xff,  \n\t\t0xff, 0xff,  \n\t},\n};\n\nstatic int LM93_PWM_FROM_REG(u8 reg, enum pwm_freq freq)\n{\n\treturn lm93_pwm_map[freq][reg & 0x0f];\n}\n\n \nstatic u8 LM93_PWM_TO_REG(int pwm, enum pwm_freq freq)\n{\n\tint i;\n\tfor (i = 0; i < 13; i++)\n\t\tif (pwm <= lm93_pwm_map[freq][i])\n\t\t\tbreak;\n\n\t \n\treturn (u8)i;\n}\n\nstatic int LM93_FAN_FROM_REG(u16 regs)\n{\n\tconst u16 count = le16_to_cpu(regs) >> 2;\n\treturn count == 0 ? -1 : count == 0x3fff ? 0 : 1350000 / count;\n}\n\n \nstatic u16 LM93_FAN_TO_REG(long rpm)\n{\n\tu16 count, regs;\n\n\tif (rpm == 0) {\n\t\tcount = 0x3fff;\n\t} else {\n\t\trpm = clamp_val(rpm, 1, 1000000);\n\t\tcount = clamp_val((1350000 + rpm) / rpm, 1, 0x3ffe);\n\t}\n\n\tregs = count << 2;\n\treturn cpu_to_le16(regs);\n}\n\n \nstatic int lm93_pwm_freq_map[8] = {\n\t22500, 96, 84, 72, 60, 48, 36, 12\n};\n\nstatic int LM93_PWM_FREQ_FROM_REG(u8 reg)\n{\n\treturn lm93_pwm_freq_map[reg & 0x07];\n}\n\n \nstatic u8 LM93_PWM_FREQ_TO_REG(int freq)\n{\n\tint i;\n\tfor (i = 7; i > 0; i--)\n\t\tif (freq <= lm93_pwm_freq_map[i])\n\t\t\tbreak;\n\n\t \n\treturn (u8)i;\n}\n\n \nstatic int lm93_spinup_time_map[8] = {\n\t0, 10, 25, 40, 70, 100, 200, 400,\n};\n\nstatic int LM93_SPINUP_TIME_FROM_REG(u8 reg)\n{\n\treturn lm93_spinup_time_map[reg >> 5 & 0x07];\n}\n\n \nstatic u8 LM93_SPINUP_TIME_TO_REG(int time)\n{\n\tint i;\n\tfor (i = 0; i < 7; i++)\n\t\tif (time <= lm93_spinup_time_map[i])\n\t\t\tbreak;\n\n\t \n\treturn (u8)i;\n}\n\n#define LM93_RAMP_MIN 0\n#define LM93_RAMP_MAX 75\n\nstatic int LM93_RAMP_FROM_REG(u8 reg)\n{\n\treturn (reg & 0x0f) * 5;\n}\n\n \nstatic u8 LM93_RAMP_TO_REG(int ramp)\n{\n\tramp = clamp_val(ramp, LM93_RAMP_MIN, LM93_RAMP_MAX);\n\treturn (u8)((ramp + 2) / 5);\n}\n\n \nstatic u8 LM93_PROCHOT_TO_REG(long prochot)\n{\n\tprochot = clamp_val(prochot, 0, 255);\n\treturn (u8)prochot;\n}\n\n \nstatic int lm93_interval_map[10] = {\n\t73, 146, 290, 580, 1170, 2330, 4660, 9320, 18600, 37200,\n};\n\nstatic int LM93_INTERVAL_FROM_REG(u8 reg)\n{\n\treturn lm93_interval_map[reg & 0x0f];\n}\n\n \nstatic u8 LM93_INTERVAL_TO_REG(long interval)\n{\n\tint i;\n\tfor (i = 0; i < 9; i++)\n\t\tif (interval <= lm93_interval_map[i])\n\t\t\tbreak;\n\n\t \n\treturn (u8)i;\n}\n\n \nstatic unsigned LM93_GPI_FROM_REG(u8 reg)\n{\n\treturn ~reg & 0xff;\n}\n\n \n#define LM93_ALARM_IN1\t\t0x00000001\n#define LM93_ALARM_IN2\t\t0x00000002\n#define LM93_ALARM_IN3\t\t0x00000004\n#define LM93_ALARM_IN4\t\t0x00000008\n#define LM93_ALARM_IN5\t\t0x00000010\n#define LM93_ALARM_IN6\t\t0x00000020\n#define LM93_ALARM_IN7\t\t0x00000040\n#define LM93_ALARM_IN8\t\t0x00000080\n#define LM93_ALARM_IN9\t\t0x00000100\n#define LM93_ALARM_IN10\t\t0x00000200\n#define LM93_ALARM_IN11\t\t0x00000400\n#define LM93_ALARM_IN12\t\t0x00000800\n#define LM93_ALARM_IN13\t\t0x00001000\n#define LM93_ALARM_IN14\t\t0x00002000\n#define LM93_ALARM_IN15\t\t0x00004000\n#define LM93_ALARM_IN16\t\t0x00008000\n#define LM93_ALARM_FAN1\t\t0x00010000\n#define LM93_ALARM_FAN2\t\t0x00020000\n#define LM93_ALARM_FAN3\t\t0x00040000\n#define LM93_ALARM_FAN4\t\t0x00080000\n#define LM93_ALARM_PH1_ERR\t0x00100000\n#define LM93_ALARM_PH2_ERR\t0x00200000\n#define LM93_ALARM_SCSI1_ERR\t0x00400000\n#define LM93_ALARM_SCSI2_ERR\t0x00800000\n#define LM93_ALARM_DVDDP1_ERR\t0x01000000\n#define LM93_ALARM_DVDDP2_ERR\t0x02000000\n#define LM93_ALARM_D1_ERR\t0x04000000\n#define LM93_ALARM_D2_ERR\t0x08000000\n#define LM93_ALARM_TEMP1\t0x10000000\n#define LM93_ALARM_TEMP2\t0x20000000\n#define LM93_ALARM_TEMP3\t0x40000000\n\nstatic unsigned LM93_ALARMS_FROM_REG(struct block1_t b1)\n{\n\tunsigned result;\n\tresult  = b1.host_status_2 & 0x3f;\n\n\tif (vccp_limit_type[0])\n\t\tresult |= (b1.host_status_4 & 0x10) << 2;\n\telse\n\t\tresult |= b1.host_status_2 & 0x40;\n\n\tif (vccp_limit_type[1])\n\t\tresult |= (b1.host_status_4 & 0x20) << 2;\n\telse\n\t\tresult |= b1.host_status_2 & 0x80;\n\n\tresult |= b1.host_status_3 << 8;\n\tresult |= (b1.fan_status & 0x0f) << 16;\n\tresult |= (b1.p1_prochot_status & 0x80) << 13;\n\tresult |= (b1.p2_prochot_status & 0x80) << 14;\n\tresult |= (b1.host_status_4 & 0xfc) << 20;\n\tresult |= (b1.host_status_1 & 0x07) << 28;\n\treturn result;\n}\n\n#define MAX_RETRIES 5\n\nstatic u8 lm93_read_byte(struct i2c_client *client, u8 reg)\n{\n\tint value, i;\n\n\t \n\tfor (i = 1; i <= MAX_RETRIES; i++) {\n\t\tvalue = i2c_smbus_read_byte_data(client, reg);\n\t\tif (value >= 0) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"lm93: read byte data failed, address 0x%02x.\\n\",\n\t\t\t\t reg);\n\t\t\tmdelay(i + 3);\n\t\t}\n\n\t}\n\n\t \n\tdev_err(&client->dev, \"lm93: All read byte retries failed!!\\n\");\n\treturn 0;\n}\n\nstatic int lm93_write_byte(struct i2c_client *client, u8 reg, u8 value)\n{\n\tint result;\n\n\t \n\tresult = i2c_smbus_write_byte_data(client, reg, value);\n\n\tif (result < 0)\n\t\tdev_warn(&client->dev,\n\t\t\t \"lm93: write byte data failed, 0x%02x at address 0x%02x.\\n\",\n\t\t\t value, reg);\n\n\treturn result;\n}\n\nstatic u16 lm93_read_word(struct i2c_client *client, u8 reg)\n{\n\tint value, i;\n\n\t \n\tfor (i = 1; i <= MAX_RETRIES; i++) {\n\t\tvalue = i2c_smbus_read_word_data(client, reg);\n\t\tif (value >= 0) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"lm93: read word data failed, address 0x%02x.\\n\",\n\t\t\t\t reg);\n\t\t\tmdelay(i + 3);\n\t\t}\n\n\t}\n\n\t \n\tdev_err(&client->dev, \"lm93: All read word retries failed!!\\n\");\n\treturn 0;\n}\n\nstatic int lm93_write_word(struct i2c_client *client, u8 reg, u16 value)\n{\n\tint result;\n\n\t \n\tresult = i2c_smbus_write_word_data(client, reg, value);\n\n\tif (result < 0)\n\t\tdev_warn(&client->dev,\n\t\t\t \"lm93: write word data failed, 0x%04x at address 0x%02x.\\n\",\n\t\t\t value, reg);\n\n\treturn result;\n}\n\nstatic u8 lm93_block_buffer[I2C_SMBUS_BLOCK_MAX];\n\n \nstatic void lm93_read_block(struct i2c_client *client, u8 fbn, u8 *values)\n{\n\tint i, result = 0;\n\n\tfor (i = 1; i <= MAX_RETRIES; i++) {\n\t\tresult = i2c_smbus_read_block_data(client,\n\t\t\tlm93_block_read_cmds[fbn].cmd, lm93_block_buffer);\n\n\t\tif (result == lm93_block_read_cmds[fbn].len) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"lm93: block read data failed, command 0x%02x.\\n\",\n\t\t\t\t lm93_block_read_cmds[fbn].cmd);\n\t\t\tmdelay(i + 3);\n\t\t}\n\t}\n\n\tif (result == lm93_block_read_cmds[fbn].len) {\n\t\tmemcpy(values, lm93_block_buffer,\n\t\t       lm93_block_read_cmds[fbn].len);\n\t} else {\n\t\t \n\t}\n}\n\nstatic struct lm93_data *lm93_update_device(struct device *dev)\n{\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tconst unsigned long interval = HZ + (HZ / 2);\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + interval) ||\n\t\t!data->valid) {\n\n\t\tdata->update(data, client);\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n}\n\n \nstatic void lm93_update_client_common(struct lm93_data *data,\n\t\t\t\t      struct i2c_client *client)\n{\n\tint i;\n\tu8 *ptr;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tdata->temp_lim[i].min =\n\t\t\tlm93_read_byte(client, LM93_REG_TEMP_MIN(i));\n\t\tdata->temp_lim[i].max =\n\t\t\tlm93_read_byte(client, LM93_REG_TEMP_MAX(i));\n\t}\n\n\t \n\tdata->config = lm93_read_byte(client, LM93_REG_CONFIG);\n\n\t \n\tfor (i = 0; i < 2; i++)\n\t\tdata->vid[i] = lm93_read_byte(client, LM93_REG_VID(i));\n\n\t \n\tfor (i = 0; i < 2; i++)\n\t\tdata->prochot_max[i] = lm93_read_byte(client,\n\t\t\t\tLM93_REG_PROCHOT_MAX(i));\n\n\t \n\tfor (i = 0; i < 2; i++)\n\t\tdata->vccp_limits[i] = lm93_read_byte(client,\n\t\t\t\tLM93_REG_VCCP_LIMIT_OFF(i));\n\n\t \n\tdata->gpi = lm93_read_byte(client, LM93_REG_GPI);\n\n\t \n\tdata->prochot_override = lm93_read_byte(client,\n\t\t\tLM93_REG_PROCHOT_OVERRIDE);\n\n\t \n\tdata->prochot_interval = lm93_read_byte(client,\n\t\t\tLM93_REG_PROCHOT_INTERVAL);\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\tdata->boost[i] = lm93_read_byte(client, LM93_REG_BOOST(i));\n\n\t \n\tdata->boost_hyst[0] = lm93_read_byte(client, LM93_REG_BOOST_HYST_12);\n\tdata->boost_hyst[1] = lm93_read_byte(client, LM93_REG_BOOST_HYST_34);\n\n\t \n\tdata->auto_pwm_min_hyst[0] =\n\t\t\tlm93_read_byte(client, LM93_REG_PWM_MIN_HYST_12);\n\tdata->auto_pwm_min_hyst[1] =\n\t\t\tlm93_read_byte(client, LM93_REG_PWM_MIN_HYST_34);\n\n\t \n\tdata->pwm_ramp_ctl = lm93_read_byte(client, LM93_REG_PWM_RAMP_CTL);\n\n\t \n\tdata->sfc1 = lm93_read_byte(client, LM93_REG_SFC1);\n\tdata->sfc2 = lm93_read_byte(client, LM93_REG_SFC2);\n\tdata->sf_tach_to_pwm = lm93_read_byte(client,\n\t\t\tLM93_REG_SF_TACH_TO_PWM);\n\n\t \n\tfor (i = 0, ptr = (u8 *)(&data->block1); i < 8; i++)\n\t\tlm93_write_byte(client, LM93_REG_HOST_ERROR_1 + i, *(ptr + i));\n}\n\n \nstatic void lm93_update_client_full(struct lm93_data *data,\n\t\t\t\t    struct i2c_client *client)\n{\n\tdev_dbg(&client->dev, \"starting device update (block data enabled)\\n\");\n\n\t \n\tlm93_read_block(client, 3, (u8 *)(data->block3));\n\tlm93_read_block(client, 7, (u8 *)(data->block7));\n\n\t \n\tlm93_read_block(client, 2, (u8 *)(data->block2));\n\n\t \n\tlm93_read_block(client, 4, (u8 *)(data->block4));\n\n\t \n\tlm93_read_block(client, 5, (u8 *)(data->block5));\n\tlm93_read_block(client, 8, (u8 *)(data->block8));\n\n\t \n\tlm93_read_block(client, 9, (u8 *)(data->block9));\n\n\t \n\tlm93_read_block(client, 1, (u8 *)(&data->block1));\n\n\t \n\tlm93_read_block(client, 10, (u8 *)(&data->block10));\n\n\tlm93_update_client_common(data, client);\n}\n\n \nstatic void lm93_update_client_min(struct lm93_data *data,\n\t\t\t\t   struct i2c_client *client)\n{\n\tint i, j;\n\tu8 *ptr;\n\n\tdev_dbg(&client->dev, \"starting device update (block data disabled)\\n\");\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tdata->block3[i] =\n\t\t\tlm93_read_byte(client, LM93_REG_IN(i));\n\t\tdata->block7[i].min =\n\t\t\tlm93_read_byte(client, LM93_REG_IN_MIN(i));\n\t\tdata->block7[i].max =\n\t\t\tlm93_read_byte(client, LM93_REG_IN_MAX(i));\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tdata->block2[i] =\n\t\t\tlm93_read_byte(client, LM93_REG_TEMP(i));\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tdata->block4[i].cur =\n\t\t\tlm93_read_byte(client, LM93_REG_PROCHOT_CUR(i));\n\t\tdata->block4[i].avg =\n\t\t\tlm93_read_byte(client, LM93_REG_PROCHOT_AVG(i));\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tdata->block5[i] =\n\t\t\tlm93_read_word(client, LM93_REG_FAN(i));\n\t\tdata->block8[i] =\n\t\t\tlm93_read_word(client, LM93_REG_FAN_MIN(i));\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tdata->block9[i][j] =\n\t\t\t\tlm93_read_byte(client, LM93_REG_PWM_CTL(i, j));\n\t\t}\n\t}\n\n\t \n\tfor (i = 0, ptr = (u8 *)(&data->block1); i < 8; i++) {\n\t\t*(ptr + i) =\n\t\t\tlm93_read_byte(client, LM93_REG_HOST_ERROR_1 + i);\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tdata->block10.base[i] =\n\t\t\tlm93_read_byte(client, LM93_REG_TEMP_BASE(i));\n\t}\n\n\t \n\tfor (i = 0; i < 12; i++) {\n\t\tdata->block10.offset[i] =\n\t\t\tlm93_read_byte(client, LM93_REG_TEMP_OFFSET(i));\n\t}\n\n\tlm93_update_client_common(data, client);\n}\n\n \nstatic ssize_t in_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", LM93_IN_FROM_REG(nr, data->block3[nr]));\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, in, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, in, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, in, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, in, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in5_input, in, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in6_input, in, 5);\nstatic SENSOR_DEVICE_ATTR_RO(in7_input, in, 6);\nstatic SENSOR_DEVICE_ATTR_RO(in8_input, in, 7);\nstatic SENSOR_DEVICE_ATTR_RO(in9_input, in, 8);\nstatic SENSOR_DEVICE_ATTR_RO(in10_input, in, 9);\nstatic SENSOR_DEVICE_ATTR_RO(in11_input, in, 10);\nstatic SENSOR_DEVICE_ATTR_RO(in12_input, in, 11);\nstatic SENSOR_DEVICE_ATTR_RO(in13_input, in, 12);\nstatic SENSOR_DEVICE_ATTR_RO(in14_input, in, 13);\nstatic SENSOR_DEVICE_ATTR_RO(in15_input, in, 14);\nstatic SENSOR_DEVICE_ATTR_RO(in16_input, in, 15);\n\nstatic ssize_t in_min_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\tint vccp = nr - 6;\n\tlong rc, vid;\n\n\tif ((nr == 6 || nr == 7) && vccp_limit_type[vccp]) {\n\t\tvid = LM93_VID_FROM_REG(data->vid[vccp]);\n\t\trc = LM93_IN_MIN_FROM_REG(data->vccp_limits[vccp], vid);\n\t} else {\n\t\trc = LM93_IN_FROM_REG(nr, data->block7[nr].min);\n\t}\n\treturn sprintf(buf, \"%ld\\n\", rc);\n}\n\nstatic ssize_t in_min_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint vccp = nr - 6;\n\tlong vid;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tif ((nr == 6 || nr == 7) && vccp_limit_type[vccp]) {\n\t\tvid = LM93_VID_FROM_REG(data->vid[vccp]);\n\t\tdata->vccp_limits[vccp] = (data->vccp_limits[vccp] & 0xf0) |\n\t\t\t\tLM93_IN_REL_TO_REG(val, 0, vid);\n\t\tlm93_write_byte(client, LM93_REG_VCCP_LIMIT_OFF(vccp),\n\t\t\t\tdata->vccp_limits[vccp]);\n\t} else {\n\t\tdata->block7[nr].min = LM93_IN_TO_REG(nr, val);\n\t\tlm93_write_byte(client, LM93_REG_IN_MIN(nr),\n\t\t\t\tdata->block7[nr].min);\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(in1_min, in_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(in2_min, in_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in3_min, in_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in4_min, in_min, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in5_min, in_min, 4);\nstatic SENSOR_DEVICE_ATTR_RW(in6_min, in_min, 5);\nstatic SENSOR_DEVICE_ATTR_RW(in7_min, in_min, 6);\nstatic SENSOR_DEVICE_ATTR_RW(in8_min, in_min, 7);\nstatic SENSOR_DEVICE_ATTR_RW(in9_min, in_min, 8);\nstatic SENSOR_DEVICE_ATTR_RW(in10_min, in_min, 9);\nstatic SENSOR_DEVICE_ATTR_RW(in11_min, in_min, 10);\nstatic SENSOR_DEVICE_ATTR_RW(in12_min, in_min, 11);\nstatic SENSOR_DEVICE_ATTR_RW(in13_min, in_min, 12);\nstatic SENSOR_DEVICE_ATTR_RW(in14_min, in_min, 13);\nstatic SENSOR_DEVICE_ATTR_RW(in15_min, in_min, 14);\nstatic SENSOR_DEVICE_ATTR_RW(in16_min, in_min, 15);\n\nstatic ssize_t in_max_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\tint vccp = nr - 6;\n\tlong rc, vid;\n\n\tif ((nr == 6 || nr == 7) && vccp_limit_type[vccp]) {\n\t\tvid = LM93_VID_FROM_REG(data->vid[vccp]);\n\t\trc = LM93_IN_MAX_FROM_REG(data->vccp_limits[vccp], vid);\n\t} else {\n\t\trc = LM93_IN_FROM_REG(nr, data->block7[nr].max);\n\t}\n\treturn sprintf(buf, \"%ld\\n\", rc);\n}\n\nstatic ssize_t in_max_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint vccp = nr - 6;\n\tlong vid;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tif ((nr == 6 || nr == 7) && vccp_limit_type[vccp]) {\n\t\tvid = LM93_VID_FROM_REG(data->vid[vccp]);\n\t\tdata->vccp_limits[vccp] = (data->vccp_limits[vccp] & 0x0f) |\n\t\t\t\tLM93_IN_REL_TO_REG(val, 1, vid);\n\t\tlm93_write_byte(client, LM93_REG_VCCP_LIMIT_OFF(vccp),\n\t\t\t\tdata->vccp_limits[vccp]);\n\t} else {\n\t\tdata->block7[nr].max = LM93_IN_TO_REG(nr, val);\n\t\tlm93_write_byte(client, LM93_REG_IN_MAX(nr),\n\t\t\t\tdata->block7[nr].max);\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(in1_max, in_max, 0);\nstatic SENSOR_DEVICE_ATTR_RW(in2_max, in_max, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in3_max, in_max, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in4_max, in_max, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in5_max, in_max, 4);\nstatic SENSOR_DEVICE_ATTR_RW(in6_max, in_max, 5);\nstatic SENSOR_DEVICE_ATTR_RW(in7_max, in_max, 6);\nstatic SENSOR_DEVICE_ATTR_RW(in8_max, in_max, 7);\nstatic SENSOR_DEVICE_ATTR_RW(in9_max, in_max, 8);\nstatic SENSOR_DEVICE_ATTR_RW(in10_max, in_max, 9);\nstatic SENSOR_DEVICE_ATTR_RW(in11_max, in_max, 10);\nstatic SENSOR_DEVICE_ATTR_RW(in12_max, in_max, 11);\nstatic SENSOR_DEVICE_ATTR_RW(in13_max, in_max, 12);\nstatic SENSOR_DEVICE_ATTR_RW(in14_max, in_max, 13);\nstatic SENSOR_DEVICE_ATTR_RW(in15_max, in_max, 14);\nstatic SENSOR_DEVICE_ATTR_RW(in16_max, in_max, 15);\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", LM93_TEMP_FROM_REG(data->block2[nr]));\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp, 2);\n\nstatic ssize_t temp_min_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", LM93_TEMP_FROM_REG(data->temp_lim[nr].min));\n}\n\nstatic ssize_t temp_min_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_lim[nr].min = LM93_TEMP_TO_REG(val);\n\tlm93_write_byte(client, LM93_REG_TEMP_MIN(nr), data->temp_lim[nr].min);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_min, temp_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_min, temp_min, 2);\n\nstatic ssize_t temp_max_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", LM93_TEMP_FROM_REG(data->temp_lim[nr].max));\n}\n\nstatic ssize_t temp_max_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_lim[nr].max = LM93_TEMP_TO_REG(val);\n\tlm93_write_byte(client, LM93_REG_TEMP_MAX(nr), data->temp_lim[nr].max);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp_max, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp_max, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_max, temp_max, 2);\n\nstatic ssize_t temp_auto_base_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", LM93_TEMP_FROM_REG(data->block10.base[nr]));\n}\n\nstatic ssize_t temp_auto_base_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->block10.base[nr] = LM93_TEMP_TO_REG(val);\n\tlm93_write_byte(client, LM93_REG_TEMP_BASE(nr), data->block10.base[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_base, temp_auto_base, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_base, temp_auto_base, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_base, temp_auto_base, 2);\n\nstatic ssize_t temp_auto_boost_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", LM93_TEMP_FROM_REG(data->boost[nr]));\n}\n\nstatic ssize_t temp_auto_boost_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->boost[nr] = LM93_TEMP_TO_REG(val);\n\tlm93_write_byte(client, LM93_REG_BOOST(nr), data->boost[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_boost, temp_auto_boost, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_boost, temp_auto_boost, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_boost, temp_auto_boost, 2);\n\nstatic ssize_t temp_auto_boost_hyst_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\tint mode = LM93_TEMP_OFFSET_MODE_FROM_REG(data->sfc2, nr);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       LM93_AUTO_BOOST_HYST_FROM_REGS(data, nr, mode));\n}\n\nstatic ssize_t temp_auto_boost_hyst_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\t \n\tdata->sfc2 = lm93_read_byte(client, LM93_REG_SFC2);\n\tdata->sfc2 |= ((nr < 2) ? 0x10 : 0x20);\n\tlm93_write_byte(client, LM93_REG_SFC2, data->sfc2);\n\tdata->boost_hyst[nr/2] = LM93_AUTO_BOOST_HYST_TO_REG(data, val, nr, 1);\n\tlm93_write_byte(client, LM93_REG_BOOST_HYST(nr),\n\t\t\tdata->boost_hyst[nr/2]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_boost_hyst, temp_auto_boost_hyst, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_boost_hyst, temp_auto_boost_hyst, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_boost_hyst, temp_auto_boost_hyst, 2);\n\nstatic ssize_t temp_auto_offset_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *s_attr = to_sensor_dev_attr_2(attr);\n\tint nr = s_attr->index;\n\tint ofs = s_attr->nr;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\tint mode = LM93_TEMP_OFFSET_MODE_FROM_REG(data->sfc2, nr);\n\treturn sprintf(buf, \"%d\\n\",\n\t       LM93_TEMP_AUTO_OFFSET_FROM_REG(data->block10.offset[ofs],\n\t\t\t\t\t      nr, mode));\n}\n\nstatic ssize_t temp_auto_offset_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *s_attr = to_sensor_dev_attr_2(attr);\n\tint nr = s_attr->index;\n\tint ofs = s_attr->nr;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\t \n\tdata->sfc2 = lm93_read_byte(client, LM93_REG_SFC2);\n\tdata->sfc2 |= ((nr < 2) ? 0x10 : 0x20);\n\tlm93_write_byte(client, LM93_REG_SFC2, data->sfc2);\n\tdata->block10.offset[ofs] = LM93_TEMP_AUTO_OFFSET_TO_REG(\n\t\t\tdata->block10.offset[ofs], val, nr, 1);\n\tlm93_write_byte(client, LM93_REG_TEMP_OFFSET(ofs),\n\t\t\tdata->block10.offset[ofs]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_offset1, temp_auto_offset, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_offset2, temp_auto_offset, 1, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_offset3, temp_auto_offset, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_offset4, temp_auto_offset, 3, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_offset5, temp_auto_offset, 4, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_offset6, temp_auto_offset, 5, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_offset7, temp_auto_offset, 6, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_offset8, temp_auto_offset, 7, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_offset9, temp_auto_offset, 8, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_offset10, temp_auto_offset, 9, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_offset11, temp_auto_offset, 10, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_offset12, temp_auto_offset, 11, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_offset1, temp_auto_offset, 0, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_offset2, temp_auto_offset, 1, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_offset3, temp_auto_offset, 2, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_offset4, temp_auto_offset, 3, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_offset5, temp_auto_offset, 4, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_offset6, temp_auto_offset, 5, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_offset7, temp_auto_offset, 6, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_offset8, temp_auto_offset, 7, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_offset9, temp_auto_offset, 8, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_offset10, temp_auto_offset, 9, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_offset11, temp_auto_offset, 10, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_offset12, temp_auto_offset, 11, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_offset1, temp_auto_offset, 0, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_offset2, temp_auto_offset, 1, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_offset3, temp_auto_offset, 2, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_offset4, temp_auto_offset, 3, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_offset5, temp_auto_offset, 4, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_offset6, temp_auto_offset, 5, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_offset7, temp_auto_offset, 6, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_offset8, temp_auto_offset, 7, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_offset9, temp_auto_offset, 8, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_offset10, temp_auto_offset, 9, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_offset11, temp_auto_offset, 10, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_offset12, temp_auto_offset, 11, 2);\n\nstatic ssize_t temp_auto_pwm_min_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tu8 reg, ctl4;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treg = data->auto_pwm_min_hyst[nr/2] >> 4 & 0x0f;\n\tctl4 = data->block9[nr][LM93_PWM_CTL4];\n\treturn sprintf(buf, \"%d\\n\", LM93_PWM_FROM_REG(reg, (ctl4 & 0x07) ?\n\t\t\t\tLM93_PWM_MAP_LO_FREQ : LM93_PWM_MAP_HI_FREQ));\n}\n\nstatic ssize_t temp_auto_pwm_min_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 reg, ctl4;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\treg = lm93_read_byte(client, LM93_REG_PWM_MIN_HYST(nr));\n\tctl4 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL4));\n\treg = (reg & 0x0f) |\n\t\tLM93_PWM_TO_REG(val, (ctl4 & 0x07) ?\n\t\t\t\tLM93_PWM_MAP_LO_FREQ :\n\t\t\t\tLM93_PWM_MAP_HI_FREQ) << 4;\n\tdata->auto_pwm_min_hyst[nr/2] = reg;\n\tlm93_write_byte(client, LM93_REG_PWM_MIN_HYST(nr), reg);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_pwm_min, temp_auto_pwm_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_pwm_min, temp_auto_pwm_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_pwm_min, temp_auto_pwm_min, 2);\n\nstatic ssize_t temp_auto_offset_hyst_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\tint mode = LM93_TEMP_OFFSET_MODE_FROM_REG(data->sfc2, nr);\n\treturn sprintf(buf, \"%d\\n\", LM93_TEMP_OFFSET_FROM_REG(\n\t\t\t\t\tdata->auto_pwm_min_hyst[nr / 2], mode));\n}\n\nstatic ssize_t temp_auto_offset_hyst_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 reg;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\t \n\tdata->sfc2 = lm93_read_byte(client, LM93_REG_SFC2);\n\tdata->sfc2 |= ((nr < 2) ? 0x10 : 0x20);\n\tlm93_write_byte(client, LM93_REG_SFC2, data->sfc2);\n\treg = data->auto_pwm_min_hyst[nr/2];\n\treg = (reg & 0xf0) | (LM93_TEMP_OFFSET_TO_REG(val, 1) & 0x0f);\n\tdata->auto_pwm_min_hyst[nr/2] = reg;\n\tlm93_write_byte(client, LM93_REG_PWM_MIN_HYST(nr), reg);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_offset_hyst, temp_auto_offset_hyst, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_offset_hyst, temp_auto_offset_hyst, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_offset_hyst, temp_auto_offset_hyst, 2);\n\nstatic ssize_t fan_input_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *s_attr = to_sensor_dev_attr(attr);\n\tint nr = s_attr->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", LM93_FAN_FROM_REG(data->block5[nr]));\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan_input, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan_input, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_input, fan_input, 2);\nstatic SENSOR_DEVICE_ATTR_RO(fan4_input, fan_input, 3);\n\nstatic ssize_t fan_min_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", LM93_FAN_FROM_REG(data->block8[nr]));\n}\n\nstatic ssize_t fan_min_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->block8[nr] = LM93_FAN_TO_REG(val);\n\tlm93_write_word(client, LM93_REG_FAN_MIN(nr), data->block8[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(fan1_min, fan_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_min, fan_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan3_min, fan_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(fan4_min, fan_min, 3);\n\n \n\nstatic ssize_t fan_smart_tach_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\tlong rc = 0;\n\tint mapping;\n\n\t \n\tmapping = (data->sf_tach_to_pwm >> (nr * 2)) & 0x03;\n\n\t \n\tif (mapping && ((data->sfc2 >> nr) & 0x01))\n\t\trc = mapping;\n\treturn sprintf(buf, \"%ld\\n\", rc);\n}\n\n \nstatic void lm93_write_fan_smart_tach(struct i2c_client *client,\n\tstruct lm93_data *data, int fan, long value)\n{\n\t \n\tdata->sf_tach_to_pwm = lm93_read_byte(client, LM93_REG_SF_TACH_TO_PWM);\n\tdata->sf_tach_to_pwm &= ~(0x3 << fan * 2);\n\tdata->sf_tach_to_pwm |= value << fan * 2;\n\tlm93_write_byte(client, LM93_REG_SF_TACH_TO_PWM, data->sf_tach_to_pwm);\n\n\t \n\tdata->sfc2 = lm93_read_byte(client, LM93_REG_SFC2);\n\tif (value)\n\t\tdata->sfc2 |= 1 << fan;\n\telse\n\t\tdata->sfc2 &= ~(1 << fan);\n\tlm93_write_byte(client, LM93_REG_SFC2, data->sfc2);\n}\n\nstatic ssize_t fan_smart_tach_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\t \n\tif (val <= 2) {\n\t\t \n\t\tif (val) {\n\t\t\tu8 ctl4 = lm93_read_byte(client,\n\t\t\t\tLM93_REG_PWM_CTL(val - 1, LM93_PWM_CTL4));\n\t\t\tif ((ctl4 & 0x07) == 0)\n\t\t\t\tval = 0;\n\t\t}\n\t\tlm93_write_fan_smart_tach(client, data, nr, val);\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(fan1_smart_tach, fan_smart_tach, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_smart_tach, fan_smart_tach, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan3_smart_tach, fan_smart_tach, 2);\nstatic SENSOR_DEVICE_ATTR_RW(fan4_smart_tach, fan_smart_tach, 3);\n\nstatic ssize_t pwm_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\tu8 ctl2, ctl4;\n\tlong rc;\n\n\tctl2 = data->block9[nr][LM93_PWM_CTL2];\n\tctl4 = data->block9[nr][LM93_PWM_CTL4];\n\tif (ctl2 & 0x01)  \n\t\trc = data->pwm_override[nr];\n\telse  \n\t\trc = LM93_PWM_FROM_REG(ctl2 >> 4, (ctl4 & 0x07) ?\n\t\t\tLM93_PWM_MAP_LO_FREQ : LM93_PWM_MAP_HI_FREQ);\n\treturn sprintf(buf, \"%ld\\n\", rc);\n}\n\nstatic ssize_t pwm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 ctl2, ctl4;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tctl2 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL2));\n\tctl4 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL4));\n\tctl2 = (ctl2 & 0x0f) | LM93_PWM_TO_REG(val, (ctl4 & 0x07) ?\n\t\t\tLM93_PWM_MAP_LO_FREQ : LM93_PWM_MAP_HI_FREQ) << 4;\n\t \n\tdata->pwm_override[nr] = LM93_PWM_FROM_REG(ctl2 >> 4,\n\t\t\t(ctl4 & 0x07) ?  LM93_PWM_MAP_LO_FREQ :\n\t\t\tLM93_PWM_MAP_HI_FREQ);\n\tlm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL2), ctl2);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1, pwm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2, pwm, 1);\n\nstatic ssize_t pwm_enable_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\tu8 ctl2;\n\tlong rc;\n\n\tctl2 = data->block9[nr][LM93_PWM_CTL2];\n\tif (ctl2 & 0x01)  \n\t\trc = ((ctl2 & 0xF0) == 0xF0) ? 0 : 1;\n\telse\n\t\trc = 2;\n\treturn sprintf(buf, \"%ld\\n\", rc);\n}\n\nstatic ssize_t pwm_enable_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 ctl2;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tctl2 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL2));\n\n\tswitch (val) {\n\tcase 0:\n\t\tctl2 |= 0xF1;  \n\t\tbreak;\n\tcase 1:\n\t\tctl2 |= 0x01;  \n\t\tbreak;\n\tcase 2:\n\t\tctl2 &= ~0x01;  \n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&data->update_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tlm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL2), ctl2);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_enable, pwm_enable, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_enable, pwm_enable, 1);\n\nstatic ssize_t pwm_freq_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\tu8 ctl4;\n\n\tctl4 = data->block9[nr][LM93_PWM_CTL4];\n\treturn sprintf(buf, \"%d\\n\", LM93_PWM_FREQ_FROM_REG(ctl4));\n}\n\n \nstatic void lm93_disable_fan_smart_tach(struct i2c_client *client,\n\tstruct lm93_data *data, int pwm)\n{\n\tint mapping = lm93_read_byte(client, LM93_REG_SF_TACH_TO_PWM);\n\tint mask;\n\n\t \n\tmapping = (mapping >> pwm) & 0x55;\n\tmask = mapping & 0x01;\n\tmask |= (mapping & 0x04) >> 1;\n\tmask |= (mapping & 0x10) >> 2;\n\tmask |= (mapping & 0x40) >> 3;\n\n\t \n\tdata->sfc2 = lm93_read_byte(client, LM93_REG_SFC2);\n\tdata->sfc2 &= ~mask;\n\tlm93_write_byte(client, LM93_REG_SFC2, data->sfc2);\n}\n\nstatic ssize_t pwm_freq_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 ctl4;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tctl4 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL4));\n\tctl4 = (ctl4 & 0xf8) | LM93_PWM_FREQ_TO_REG(val);\n\tdata->block9[nr][LM93_PWM_CTL4] = ctl4;\n\t \n\tif (!ctl4)\n\t\tlm93_disable_fan_smart_tach(client, data, nr);\n\tlm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL4), ctl4);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_freq, pwm_freq, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_freq, pwm_freq, 1);\n\nstatic ssize_t pwm_auto_channels_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->block9[nr][LM93_PWM_CTL1]);\n}\n\nstatic ssize_t pwm_auto_channels_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->block9[nr][LM93_PWM_CTL1] = clamp_val(val, 0, 255);\n\tlm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL1),\n\t\t\t\tdata->block9[nr][LM93_PWM_CTL1]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_channels, pwm_auto_channels, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_channels, pwm_auto_channels, 1);\n\nstatic ssize_t pwm_auto_spinup_min_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\tu8 ctl3, ctl4;\n\n\tctl3 = data->block9[nr][LM93_PWM_CTL3];\n\tctl4 = data->block9[nr][LM93_PWM_CTL4];\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       LM93_PWM_FROM_REG(ctl3 & 0x0f, (ctl4 & 0x07) ?\n\t\t\tLM93_PWM_MAP_LO_FREQ : LM93_PWM_MAP_HI_FREQ));\n}\n\nstatic ssize_t pwm_auto_spinup_min_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 ctl3, ctl4;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tctl3 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL3));\n\tctl4 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL4));\n\tctl3 = (ctl3 & 0xf0) | LM93_PWM_TO_REG(val, (ctl4 & 0x07) ?\n\t\t\tLM93_PWM_MAP_LO_FREQ :\n\t\t\tLM93_PWM_MAP_HI_FREQ);\n\tdata->block9[nr][LM93_PWM_CTL3] = ctl3;\n\tlm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL3), ctl3);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_spinup_min, pwm_auto_spinup_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_spinup_min, pwm_auto_spinup_min, 1);\n\nstatic ssize_t pwm_auto_spinup_time_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", LM93_SPINUP_TIME_FROM_REG(\n\t\t\t\tdata->block9[nr][LM93_PWM_CTL3]));\n}\n\nstatic ssize_t pwm_auto_spinup_time_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 ctl3;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tctl3 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL3));\n\tctl3 = (ctl3 & 0x1f) | (LM93_SPINUP_TIME_TO_REG(val) << 5 & 0xe0);\n\tdata->block9[nr][LM93_PWM_CTL3] = ctl3;\n\tlm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL3), ctl3);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_spinup_time, pwm_auto_spinup_time, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_spinup_time, pwm_auto_spinup_time, 1);\n\nstatic ssize_t pwm_auto_prochot_ramp_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       LM93_RAMP_FROM_REG(data->pwm_ramp_ctl >> 4 & 0x0f));\n}\n\nstatic ssize_t pwm_auto_prochot_ramp_store(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 ramp;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tramp = lm93_read_byte(client, LM93_REG_PWM_RAMP_CTL);\n\tramp = (ramp & 0x0f) | (LM93_RAMP_TO_REG(val) << 4 & 0xf0);\n\tlm93_write_byte(client, LM93_REG_PWM_RAMP_CTL, ramp);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(pwm_auto_prochot_ramp);\n\nstatic ssize_t pwm_auto_vrdhot_ramp_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       LM93_RAMP_FROM_REG(data->pwm_ramp_ctl & 0x0f));\n}\n\nstatic ssize_t pwm_auto_vrdhot_ramp_store(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 ramp;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tramp = lm93_read_byte(client, LM93_REG_PWM_RAMP_CTL);\n\tramp = (ramp & 0xf0) | (LM93_RAMP_TO_REG(val) & 0x0f);\n\tlm93_write_byte(client, LM93_REG_PWM_RAMP_CTL, ramp);\n\tmutex_unlock(&data->update_lock);\n\treturn 0;\n}\n\nstatic DEVICE_ATTR_RW(pwm_auto_vrdhot_ramp);\n\nstatic ssize_t vid_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", LM93_VID_FROM_REG(data->vid[nr]));\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(cpu0_vid, vid, 0);\nstatic SENSOR_DEVICE_ATTR_RO(cpu1_vid, vid, 1);\n\nstatic ssize_t prochot_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->block4[nr].cur);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(prochot1, prochot, 0);\nstatic SENSOR_DEVICE_ATTR_RO(prochot2, prochot, 1);\n\nstatic ssize_t prochot_avg_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->block4[nr].avg);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(prochot1_avg, prochot_avg, 0);\nstatic SENSOR_DEVICE_ATTR_RO(prochot2_avg, prochot_avg, 1);\n\nstatic ssize_t prochot_max_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->prochot_max[nr]);\n}\n\nstatic ssize_t prochot_max_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->prochot_max[nr] = LM93_PROCHOT_TO_REG(val);\n\tlm93_write_byte(client, LM93_REG_PROCHOT_MAX(nr),\n\t\t\tdata->prochot_max[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(prochot1_max, prochot_max, 0);\nstatic SENSOR_DEVICE_ATTR_RW(prochot2_max, prochot_max, 1);\n\nstatic const u8 prochot_override_mask[] = { 0x80, 0x40 };\n\nstatic ssize_t prochot_override_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t(data->prochot_override & prochot_override_mask[nr]) ? 1 : 0);\n}\n\nstatic ssize_t prochot_override_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tif (val)\n\t\tdata->prochot_override |= prochot_override_mask[nr];\n\telse\n\t\tdata->prochot_override &= (~prochot_override_mask[nr]);\n\tlm93_write_byte(client, LM93_REG_PROCHOT_OVERRIDE,\n\t\t\tdata->prochot_override);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(prochot1_override, prochot_override, 0);\nstatic SENSOR_DEVICE_ATTR_RW(prochot2_override, prochot_override, 1);\n\nstatic ssize_t prochot_interval_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\tu8 tmp;\n\tif (nr == 1)\n\t\ttmp = (data->prochot_interval & 0xf0) >> 4;\n\telse\n\t\ttmp = data->prochot_interval & 0x0f;\n\treturn sprintf(buf, \"%d\\n\", LM93_INTERVAL_FROM_REG(tmp));\n}\n\nstatic ssize_t prochot_interval_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 tmp;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\ttmp = lm93_read_byte(client, LM93_REG_PROCHOT_INTERVAL);\n\tif (nr == 1)\n\t\ttmp = (tmp & 0x0f) | (LM93_INTERVAL_TO_REG(val) << 4);\n\telse\n\t\ttmp = (tmp & 0xf0) | LM93_INTERVAL_TO_REG(val);\n\tdata->prochot_interval = tmp;\n\tlm93_write_byte(client, LM93_REG_PROCHOT_INTERVAL, tmp);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(prochot1_interval, prochot_interval, 0);\nstatic SENSOR_DEVICE_ATTR_RW(prochot2_interval, prochot_interval, 1);\n\nstatic ssize_t prochot_override_duty_cycle_show(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf)\n{\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->prochot_override & 0x0f);\n}\n\nstatic ssize_t prochot_override_duty_cycle_store(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->prochot_override = (data->prochot_override & 0xf0) |\n\t\t\t\t\tclamp_val(val, 0, 15);\n\tlm93_write_byte(client, LM93_REG_PROCHOT_OVERRIDE,\n\t\t\tdata->prochot_override);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(prochot_override_duty_cycle);\n\nstatic ssize_t prochot_short_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (data->config & 0x10) ? 1 : 0);\n}\n\nstatic ssize_t prochot_short_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct lm93_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tif (val)\n\t\tdata->config |= 0x10;\n\telse\n\t\tdata->config &= ~0x10;\n\tlm93_write_byte(client, LM93_REG_CONFIG, data->config);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(prochot_short);\n\nstatic ssize_t vrdhot_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint nr = (to_sensor_dev_attr(attr))->index;\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       data->block1.host_status_1 & (1 << (nr + 4)) ? 1 : 0);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(vrdhot1, vrdhot, 0);\nstatic SENSOR_DEVICE_ATTR_RO(vrdhot2, vrdhot, 1);\n\nstatic ssize_t gpio_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", LM93_GPI_FROM_REG(data->gpi));\n}\n\nstatic DEVICE_ATTR_RO(gpio);\n\nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct lm93_data *data = lm93_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", LM93_ALARMS_FROM_REG(data->block1));\n}\n\nstatic DEVICE_ATTR_RO(alarms);\n\nstatic struct attribute *lm93_attrs[] = {\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\t&sensor_dev_attr_in8_input.dev_attr.attr,\n\t&sensor_dev_attr_in9_input.dev_attr.attr,\n\t&sensor_dev_attr_in10_input.dev_attr.attr,\n\t&sensor_dev_attr_in11_input.dev_attr.attr,\n\t&sensor_dev_attr_in12_input.dev_attr.attr,\n\t&sensor_dev_attr_in13_input.dev_attr.attr,\n\t&sensor_dev_attr_in14_input.dev_attr.attr,\n\t&sensor_dev_attr_in15_input.dev_attr.attr,\n\t&sensor_dev_attr_in16_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in6_min.dev_attr.attr,\n\t&sensor_dev_attr_in7_min.dev_attr.attr,\n\t&sensor_dev_attr_in8_min.dev_attr.attr,\n\t&sensor_dev_attr_in9_min.dev_attr.attr,\n\t&sensor_dev_attr_in10_min.dev_attr.attr,\n\t&sensor_dev_attr_in11_min.dev_attr.attr,\n\t&sensor_dev_attr_in12_min.dev_attr.attr,\n\t&sensor_dev_attr_in13_min.dev_attr.attr,\n\t&sensor_dev_attr_in14_min.dev_attr.attr,\n\t&sensor_dev_attr_in15_min.dev_attr.attr,\n\t&sensor_dev_attr_in16_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\t&sensor_dev_attr_in6_max.dev_attr.attr,\n\t&sensor_dev_attr_in7_max.dev_attr.attr,\n\t&sensor_dev_attr_in8_max.dev_attr.attr,\n\t&sensor_dev_attr_in9_max.dev_attr.attr,\n\t&sensor_dev_attr_in10_max.dev_attr.attr,\n\t&sensor_dev_attr_in11_max.dev_attr.attr,\n\t&sensor_dev_attr_in12_max.dev_attr.attr,\n\t&sensor_dev_attr_in13_max.dev_attr.attr,\n\t&sensor_dev_attr_in14_max.dev_attr.attr,\n\t&sensor_dev_attr_in15_max.dev_attr.attr,\n\t&sensor_dev_attr_in16_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_base.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_base.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_base.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_boost.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_boost.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_boost.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_boost_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_boost_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_boost_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset1.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset2.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset3.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset4.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset5.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset6.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset7.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset8.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset9.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset10.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset11.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset12.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset1.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset2.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset3.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset4.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset5.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset6.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset7.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset8.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset9.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset10.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset11.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset12.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset1.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset2.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset3.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset4.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset5.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset6.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset7.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset8.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset9.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset10.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset11.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset12.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_pwm_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_pwm_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_pwm_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_offset_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_offset_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_offset_hyst.dev_attr.attr,\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan4_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan4_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_smart_tach.dev_attr.attr,\n\t&sensor_dev_attr_fan2_smart_tach.dev_attr.attr,\n\t&sensor_dev_attr_fan3_smart_tach.dev_attr.attr,\n\t&sensor_dev_attr_fan4_smart_tach.dev_attr.attr,\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_channels.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_channels.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_spinup_min.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_spinup_min.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_spinup_time.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_spinup_time.dev_attr.attr,\n\t&dev_attr_pwm_auto_prochot_ramp.attr,\n\t&dev_attr_pwm_auto_vrdhot_ramp.attr,\n\t&sensor_dev_attr_cpu0_vid.dev_attr.attr,\n\t&sensor_dev_attr_cpu1_vid.dev_attr.attr,\n\t&sensor_dev_attr_prochot1.dev_attr.attr,\n\t&sensor_dev_attr_prochot2.dev_attr.attr,\n\t&sensor_dev_attr_prochot1_avg.dev_attr.attr,\n\t&sensor_dev_attr_prochot2_avg.dev_attr.attr,\n\t&sensor_dev_attr_prochot1_max.dev_attr.attr,\n\t&sensor_dev_attr_prochot2_max.dev_attr.attr,\n\t&sensor_dev_attr_prochot1_override.dev_attr.attr,\n\t&sensor_dev_attr_prochot2_override.dev_attr.attr,\n\t&sensor_dev_attr_prochot1_interval.dev_attr.attr,\n\t&sensor_dev_attr_prochot2_interval.dev_attr.attr,\n\t&dev_attr_prochot_override_duty_cycle.attr,\n\t&dev_attr_prochot_short.attr,\n\t&sensor_dev_attr_vrdhot1.dev_attr.attr,\n\t&sensor_dev_attr_vrdhot2.dev_attr.attr,\n\t&dev_attr_gpio.attr,\n\t&dev_attr_alarms.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(lm93);\n\nstatic void lm93_init_client(struct i2c_client *client)\n{\n\tint i;\n\tu8 reg;\n\n\t \n\treg = lm93_read_byte(client, LM93_REG_GPI_VID_CTL);\n\tlm93_write_byte(client, LM93_REG_GPI_VID_CTL,\n\t\t\treg | (vid_agtl ? 0x03 : 0x00));\n\n\tif (init) {\n\t\t \n\t\treg = lm93_read_byte(client, LM93_REG_CONFIG);\n\t\tlm93_write_byte(client, LM93_REG_CONFIG, reg | 0x08);\n\n\t\t \n\t\treg = lm93_read_byte(client, LM93_REG_STATUS_CONTROL);\n\t\tlm93_write_byte(client, LM93_REG_STATUS_CONTROL, reg | 0x02);\n\n\t\t \n\t\tlm93_write_byte(client, LM93_REG_SLEEP_CONTROL, 0);\n\n\t\t \n\t\treg = lm93_read_byte(client, LM93_REG_MISC_ERR_MASK);\n\t\treg &= ~0x03;\n\t\treg &= ~(vccp_limit_type[0] ? 0x10 : 0);\n\t\treg &= ~(vccp_limit_type[1] ? 0x20 : 0);\n\t\tlm93_write_byte(client, LM93_REG_MISC_ERR_MASK, reg);\n\t}\n\n\t \n\treg = lm93_read_byte(client, LM93_REG_CONFIG);\n\tlm93_write_byte(client, LM93_REG_CONFIG, reg | 0x01);\n\n\t \n\tfor (i = 0; i < 20; i++) {\n\t\tmsleep(10);\n\t\tif ((lm93_read_byte(client, LM93_REG_CONFIG) & 0x80) == 0x80)\n\t\t\treturn;\n\t}\n\n\tdev_warn(&client->dev,\n\t\t \"timed out waiting for sensor chip to signal ready!\\n\");\n}\n\n \nstatic int lm93_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint mfr, ver;\n\tconst char *name;\n\n\tif (!i2c_check_functionality(adapter, LM93_SMBUS_FUNC_MIN))\n\t\treturn -ENODEV;\n\n\t \n\tmfr = lm93_read_byte(client, LM93_REG_MFR_ID);\n\tif (mfr != 0x01) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"detect failed, bad manufacturer id 0x%02x!\\n\", mfr);\n\t\treturn -ENODEV;\n\t}\n\n\tver = lm93_read_byte(client, LM93_REG_VER);\n\tswitch (ver) {\n\tcase LM93_MFR_ID:\n\tcase LM93_MFR_ID_PROTOTYPE:\n\t\tname = \"lm93\";\n\t\tbreak;\n\tcase LM94_MFR_ID_2:\n\tcase LM94_MFR_ID:\n\tcase LM94_MFR_ID_PROTOTYPE:\n\t\tname = \"lm94\";\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"detect failed, bad version id 0x%02x!\\n\", ver);\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, name, I2C_NAME_SIZE);\n\tdev_dbg(&adapter->dev, \"loading %s at %d, 0x%02x\\n\",\n\t\tclient->name, i2c_adapter_id(client->adapter),\n\t\tclient->addr);\n\n\treturn 0;\n}\n\nstatic int lm93_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct lm93_data *data;\n\tstruct device *hwmon_dev;\n\tint func;\n\tvoid (*update)(struct lm93_data *, struct i2c_client *);\n\n\t \n\tfunc = i2c_get_functionality(client->adapter);\n\tif (((LM93_SMBUS_FUNC_FULL & func) == LM93_SMBUS_FUNC_FULL) &&\n\t\t\t(!disable_block)) {\n\t\tdev_dbg(dev, \"using SMBus block data transactions\\n\");\n\t\tupdate = lm93_update_client_full;\n\t} else if ((LM93_SMBUS_FUNC_MIN & func) == LM93_SMBUS_FUNC_MIN) {\n\t\tdev_dbg(dev, \"disabled SMBus block data transactions\\n\");\n\t\tupdate = lm93_update_client_min;\n\t} else {\n\t\tdev_dbg(dev, \"detect failed, smbus byte and/or word data not supported!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(struct lm93_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tdata->client = client;\n\tdata->update = update;\n\tmutex_init(&data->update_lock);\n\n\t \n\tlm93_init_client(client);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   lm93_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id lm93_id[] = {\n\t{ \"lm93\", 0 },\n\t{ \"lm94\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm93_id);\n\nstatic struct i2c_driver lm93_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"lm93\",\n\t},\n\t.probe\t\t= lm93_probe,\n\t.id_table\t= lm93_id,\n\t.detect\t\t= lm93_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(lm93_driver);\n\nMODULE_AUTHOR(\"Mark M. Hoffman <mhoffman@lightlink.com>, \"\n\t\t\"Hans J. Koch <hjk@hansjkoch.de>\");\nMODULE_DESCRIPTION(\"LM93 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}