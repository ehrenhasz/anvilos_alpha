{
  "module_name": "w83791d.c",
  "hash_id": "4a4b82bd2b63d58cb387f4988f7e39be401c1378c85c86c11f05f531ffe75ad2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/w83791d.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-vid.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/jiffies.h>\n\n#define NUMBER_OF_VIN\t\t10\n#define NUMBER_OF_FANIN\t\t5\n#define NUMBER_OF_TEMPIN\t3\n#define NUMBER_OF_PWM\t\t5\n\n \nstatic const unsigned short normal_i2c[] = { 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t\tI2C_CLIENT_END };\n\n \n\nstatic unsigned short force_subclients[4];\nmodule_param_array(force_subclients, short, NULL, 0);\nMODULE_PARM_DESC(force_subclients,\n\t\t \"List of subclient addresses: {bus, clientaddr, subclientaddr1, subclientaddr2}\");\n\nstatic bool reset;\nmodule_param(reset, bool, 0);\nMODULE_PARM_DESC(reset, \"Set to one to force a hardware chip reset\");\n\nstatic bool init;\nmodule_param(init, bool, 0);\nMODULE_PARM_DESC(init, \"Set to one to force extra software initialization\");\n\n \nstatic const u8 W83791D_REG_IN[NUMBER_OF_VIN] = {\n\t0x20,\t\t\t \n\t0x21,\t\t\t \n\t0x22,\t\t\t \n\t0x23,\t\t\t \n\t0x24,\t\t\t \n\t0x25,\t\t\t \n\t0x26,\t\t\t \n\t0xB0,\t\t\t \n\t0xB1,\t\t\t \n\t0xB2\t\t\t \n};\n\nstatic const u8 W83791D_REG_IN_MAX[NUMBER_OF_VIN] = {\n\t0x2B,\t\t\t \n\t0x2D,\t\t\t \n\t0x2F,\t\t\t \n\t0x31,\t\t\t \n\t0x33,\t\t\t \n\t0x35,\t\t\t \n\t0x37,\t\t\t \n\t0xB4,\t\t\t \n\t0xB6,\t\t\t \n\t0xB8\t\t\t \n};\nstatic const u8 W83791D_REG_IN_MIN[NUMBER_OF_VIN] = {\n\t0x2C,\t\t\t \n\t0x2E,\t\t\t \n\t0x30,\t\t\t \n\t0x32,\t\t\t \n\t0x34,\t\t\t \n\t0x36,\t\t\t \n\t0x38,\t\t\t \n\t0xB5,\t\t\t \n\t0xB7,\t\t\t \n\t0xB9\t\t\t \n};\nstatic const u8 W83791D_REG_FAN[NUMBER_OF_FANIN] = {\n\t0x28,\t\t\t \n\t0x29,\t\t\t \n\t0x2A,\t\t\t \n\t0xBA,\t\t\t \n\t0xBB,\t\t\t \n};\nstatic const u8 W83791D_REG_FAN_MIN[NUMBER_OF_FANIN] = {\n\t0x3B,\t\t\t \n\t0x3C,\t\t\t \n\t0x3D,\t\t\t \n\t0xBC,\t\t\t \n\t0xBD,\t\t\t \n};\n\nstatic const u8 W83791D_REG_PWM[NUMBER_OF_PWM] = {\n\t0x81,\t\t\t \n\t0x83,\t\t\t \n\t0x94,\t\t\t \n\t0xA0,\t\t\t \n\t0xA1,\t\t\t \n};\n\nstatic const u8 W83791D_REG_TEMP_TARGET[3] = {\n\t0x85,\t\t\t \n\t0x86,\t\t\t \n\t0x96,\t\t\t \n};\n\nstatic const u8 W83791D_REG_TEMP_TOL[2] = {\n\t0x87,\t\t\t \n\t0x97,\t\t\t \n};\n\nstatic const u8 W83791D_REG_FAN_CFG[2] = {\n\t0x84,\t\t\t \n\t0x95,\t\t\t \n};\n\nstatic const u8 W83791D_REG_FAN_DIV[3] = {\n\t0x47,\t\t\t \n\t0x4b,\t\t\t \n\t0x5C,\t\t\t \n};\n\n#define W83791D_REG_BANK\t\t0x4E\n#define W83791D_REG_TEMP2_CONFIG\t0xC2\n#define W83791D_REG_TEMP3_CONFIG\t0xCA\n\nstatic const u8 W83791D_REG_TEMP1[3] = {\n\t0x27,\t\t\t \n\t0x39,\t\t\t \n\t0x3A,\t\t\t \n};\n\nstatic const u8 W83791D_REG_TEMP_ADD[2][6] = {\n\t{0xC0,\t\t\t \n\t 0xC1,\t\t\t \n\t 0xC5,\t\t\t \n\t 0xC6,\t\t\t \n\t 0xC3,\t\t\t \n\t 0xC4},\t\t\t \n\t{0xC8,\t\t\t \n\t 0xC9,\t\t\t \n\t 0xCD,\t\t\t \n\t 0xCE,\t\t\t \n\t 0xCB,\t\t\t \n\t 0xCC}\t\t\t \n};\n\n#define W83791D_REG_BEEP_CONFIG\t\t0x4D\n\nstatic const u8 W83791D_REG_BEEP_CTRL[3] = {\n\t0x56,\t\t\t \n\t0x57,\t\t\t \n\t0xA3,\t\t\t \n};\n\n#define W83791D_REG_GPIO\t\t0x15\n#define W83791D_REG_CONFIG\t\t0x40\n#define W83791D_REG_VID_FANDIV\t\t0x47\n#define W83791D_REG_DID_VID4\t\t0x49\n#define W83791D_REG_WCHIPID\t\t0x58\n#define W83791D_REG_CHIPMAN\t\t0x4F\n#define W83791D_REG_PIN\t\t\t0x4B\n#define W83791D_REG_I2C_SUBADDR\t\t0x4A\n\n#define W83791D_REG_ALARM1 0xA9\t \n#define W83791D_REG_ALARM2 0xAA\t \n#define W83791D_REG_ALARM3 0xAB\t \n\n#define W83791D_REG_VBAT\t\t0x5D\n#define W83791D_REG_I2C_ADDR\t\t0x48\n\n \nstatic inline int w83791d_read(struct i2c_client *client, u8 reg)\n{\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic inline int w83791d_write(struct i2c_client *client, u8 reg, u8 value)\n{\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\n \n#define IN_TO_REG(val)\t\t(clamp_val((((val) + 8) / 16), 0, 255))\n#define IN_FROM_REG(val)\t((val) * 16)\n\nstatic u8 fan_to_reg(long rpm, int div)\n{\n\tif (rpm == 0)\n\t\treturn 255;\n\trpm = clamp_val(rpm, 1, 1000000);\n\treturn clamp_val((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\n}\n\n#define FAN_FROM_REG(val, div)\t((val) == 0 ? -1 : \\\n\t\t\t\t((val) == 255 ? 0 : \\\n\t\t\t\t\t1350000 / ((val) * (div))))\n\n \n#define TEMP1_FROM_REG(val)\t((val) * 1000)\n#define TEMP1_TO_REG(val)\t((val) <= -128000 ? -128 : \\\n\t\t\t\t (val) >= 127000 ? 127 : \\\n\t\t\t\t (val) < 0 ? ((val) - 500) / 1000 : \\\n\t\t\t\t ((val) + 500) / 1000)\n\n \n#define TEMP23_FROM_REG(val)\t((val) / 128 * 500)\n#define TEMP23_TO_REG(val)\t(DIV_ROUND_CLOSEST(clamp_val((val), -128000, \\\n\t\t\t\t\t\t   127500), 500) * 128)\n\n \n#define TARGET_TEMP_TO_REG(val)\tDIV_ROUND_CLOSEST(clamp_val((val), 0, 127000), \\\n\t\t\t\t\t\t  1000)\n\n \n#define TOL_TEMP_TO_REG(val)\tDIV_ROUND_CLOSEST(clamp_val((val), 0, 15000), \\\n\t\t\t\t\t\t  1000)\n\n#define BEEP_MASK_TO_REG(val)\t\t((val) & 0xffffff)\n#define BEEP_MASK_FROM_REG(val)\t\t((val) & 0xffffff)\n\n#define DIV_FROM_REG(val)\t\t(1 << (val))\n\nstatic u8 div_to_reg(int nr, long val)\n{\n\tint i;\n\n\t \n\tval = clamp_val(val, 1, 128) >> 1;\n\tfor (i = 0; i < 7; i++) {\n\t\tif (val == 0)\n\t\t\tbreak;\n\t\tval >>= 1;\n\t}\n\treturn (u8) i;\n}\n\nstruct w83791d_data {\n\tstruct device *hwmon_dev;\n\tstruct mutex update_lock;\n\n\tbool valid;\t\t\t \n\tunsigned long last_updated;\t \n\n\t \n\tu8 in[NUMBER_OF_VIN];\t\t \n\tu8 in_max[NUMBER_OF_VIN];\t \n\tu8 in_min[NUMBER_OF_VIN];\t \n\n\t \n\tu8 fan[NUMBER_OF_FANIN];\t \n\tu8 fan_min[NUMBER_OF_FANIN];\t \n\tu8 fan_div[NUMBER_OF_FANIN];\t \n\n\t \n\n\ts8 temp1[3];\t\t \n\ts16 temp_add[2][3];\t \n\n\t \n\tu8 pwm[5];\t\t \n\tu8 pwm_enable[3];\t \n\n\tu8 temp_target[3];\t \n\tu8 temp_tolerance[3];\t \n\n\t \n\tu32 alarms;\t\t \n\tu8 beep_enable;\t\t \n\tu32 beep_mask;\t\t \n\tu8 vid;\t\t\t \n\tu8 vrm;\t\t\t \n};\n\nstatic int w83791d_probe(struct i2c_client *client);\nstatic int w83791d_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info);\nstatic void w83791d_remove(struct i2c_client *client);\n\nstatic int w83791d_read(struct i2c_client *client, u8 reg);\nstatic int w83791d_write(struct i2c_client *client, u8 reg, u8 value);\nstatic struct w83791d_data *w83791d_update_device(struct device *dev);\n\n#ifdef DEBUG\nstatic void w83791d_print_debug(struct w83791d_data *data, struct device *dev);\n#endif\n\nstatic void w83791d_init_client(struct i2c_client *client);\n\nstatic const struct i2c_device_id w83791d_id[] = {\n\t{ \"w83791d\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, w83791d_id);\n\nstatic struct i2c_driver w83791d_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"w83791d\",\n\t},\n\t.probe\t\t= w83791d_probe,\n\t.remove\t\t= w83791d_remove,\n\t.id_table\t= w83791d_id,\n\t.detect\t\t= w83791d_detect,\n\t.address_list\t= normal_i2c,\n};\n\n \n#define show_in_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\t\tchar *buf) \\\n{ \\\n\tstruct sensor_device_attribute *sensor_attr = \\\n\t\t\t\t\t\tto_sensor_dev_attr(attr); \\\n\tstruct w83791d_data *data = w83791d_update_device(dev); \\\n\tint nr = sensor_attr->index; \\\n\treturn sprintf(buf, \"%d\\n\", IN_FROM_REG(data->reg[nr])); \\\n}\n\nshow_in_reg(in);\nshow_in_reg(in_min);\nshow_in_reg(in_max);\n\n#define store_in_reg(REG, reg) \\\nstatic ssize_t store_in_##reg(struct device *dev, \\\n\t\t\t\tstruct device_attribute *attr, \\\n\t\t\t\tconst char *buf, size_t count) \\\n{ \\\n\tstruct sensor_device_attribute *sensor_attr = \\\n\t\t\t\t\t\tto_sensor_dev_attr(attr); \\\n\tstruct i2c_client *client = to_i2c_client(dev); \\\n\tstruct w83791d_data *data = i2c_get_clientdata(client); \\\n\tint nr = sensor_attr->index; \\\n\tunsigned long val; \\\n\tint err = kstrtoul(buf, 10, &val); \\\n\tif (err) \\\n\t\treturn err; \\\n\tmutex_lock(&data->update_lock); \\\n\tdata->in_##reg[nr] = IN_TO_REG(val); \\\n\tw83791d_write(client, W83791D_REG_IN_##REG[nr], data->in_##reg[nr]); \\\n\tmutex_unlock(&data->update_lock); \\\n\t \\\n\treturn count; \\\n}\nstore_in_reg(MIN, min);\nstore_in_reg(MAX, max);\n\nstatic struct sensor_device_attribute sda_in_input[] = {\n\tSENSOR_ATTR(in0_input, S_IRUGO, show_in, NULL, 0),\n\tSENSOR_ATTR(in1_input, S_IRUGO, show_in, NULL, 1),\n\tSENSOR_ATTR(in2_input, S_IRUGO, show_in, NULL, 2),\n\tSENSOR_ATTR(in3_input, S_IRUGO, show_in, NULL, 3),\n\tSENSOR_ATTR(in4_input, S_IRUGO, show_in, NULL, 4),\n\tSENSOR_ATTR(in5_input, S_IRUGO, show_in, NULL, 5),\n\tSENSOR_ATTR(in6_input, S_IRUGO, show_in, NULL, 6),\n\tSENSOR_ATTR(in7_input, S_IRUGO, show_in, NULL, 7),\n\tSENSOR_ATTR(in8_input, S_IRUGO, show_in, NULL, 8),\n\tSENSOR_ATTR(in9_input, S_IRUGO, show_in, NULL, 9),\n};\n\nstatic struct sensor_device_attribute sda_in_min[] = {\n\tSENSOR_ATTR(in0_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 0),\n\tSENSOR_ATTR(in1_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 1),\n\tSENSOR_ATTR(in2_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 2),\n\tSENSOR_ATTR(in3_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 3),\n\tSENSOR_ATTR(in4_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 4),\n\tSENSOR_ATTR(in5_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 5),\n\tSENSOR_ATTR(in6_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 6),\n\tSENSOR_ATTR(in7_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 7),\n\tSENSOR_ATTR(in8_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 8),\n\tSENSOR_ATTR(in9_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 9),\n};\n\nstatic struct sensor_device_attribute sda_in_max[] = {\n\tSENSOR_ATTR(in0_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 0),\n\tSENSOR_ATTR(in1_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 1),\n\tSENSOR_ATTR(in2_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 2),\n\tSENSOR_ATTR(in3_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 3),\n\tSENSOR_ATTR(in4_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 4),\n\tSENSOR_ATTR(in5_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 5),\n\tSENSOR_ATTR(in6_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 6),\n\tSENSOR_ATTR(in7_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 7),\n\tSENSOR_ATTR(in8_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 8),\n\tSENSOR_ATTR(in9_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 9),\n};\n\n\nstatic ssize_t show_beep(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr =\n\t\t\t\t\t\tto_sensor_dev_attr(attr);\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\tint bitnr = sensor_attr->index;\n\n\treturn sprintf(buf, \"%d\\n\", (data->beep_mask >> bitnr) & 1);\n}\n\nstatic ssize_t store_beep(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr =\n\t\t\t\t\t\tto_sensor_dev_attr(attr);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tint bitnr = sensor_attr->index;\n\tint bytenr = bitnr / 8;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tval = val ? 1 : 0;\n\n\tmutex_lock(&data->update_lock);\n\n\tdata->beep_mask &= ~(0xff << (bytenr * 8));\n\tdata->beep_mask |= w83791d_read(client, W83791D_REG_BEEP_CTRL[bytenr])\n\t\t<< (bytenr * 8);\n\n\tdata->beep_mask &= ~(1 << bitnr);\n\tdata->beep_mask |= val << bitnr;\n\n\tw83791d_write(client, W83791D_REG_BEEP_CTRL[bytenr],\n\t\t(data->beep_mask >> (bytenr * 8)) & 0xff);\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr =\n\t\t\t\t\t\tto_sensor_dev_attr(attr);\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\tint bitnr = sensor_attr->index;\n\n\treturn sprintf(buf, \"%d\\n\", (data->alarms >> bitnr) & 1);\n}\n\n \nstatic struct sensor_device_attribute sda_in_beep[] = {\n\tSENSOR_ATTR(in0_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 0),\n\tSENSOR_ATTR(in1_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 13),\n\tSENSOR_ATTR(in2_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 2),\n\tSENSOR_ATTR(in3_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 3),\n\tSENSOR_ATTR(in4_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 8),\n\tSENSOR_ATTR(in5_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 9),\n\tSENSOR_ATTR(in6_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 10),\n\tSENSOR_ATTR(in7_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 16),\n\tSENSOR_ATTR(in8_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 17),\n\tSENSOR_ATTR(in9_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 14),\n};\n\nstatic struct sensor_device_attribute sda_in_alarm[] = {\n\tSENSOR_ATTR(in0_alarm, S_IRUGO, show_alarm, NULL, 0),\n\tSENSOR_ATTR(in1_alarm, S_IRUGO, show_alarm, NULL, 1),\n\tSENSOR_ATTR(in2_alarm, S_IRUGO, show_alarm, NULL, 2),\n\tSENSOR_ATTR(in3_alarm, S_IRUGO, show_alarm, NULL, 3),\n\tSENSOR_ATTR(in4_alarm, S_IRUGO, show_alarm, NULL, 8),\n\tSENSOR_ATTR(in5_alarm, S_IRUGO, show_alarm, NULL, 9),\n\tSENSOR_ATTR(in6_alarm, S_IRUGO, show_alarm, NULL, 10),\n\tSENSOR_ATTR(in7_alarm, S_IRUGO, show_alarm, NULL, 19),\n\tSENSOR_ATTR(in8_alarm, S_IRUGO, show_alarm, NULL, 20),\n\tSENSOR_ATTR(in9_alarm, S_IRUGO, show_alarm, NULL, 14),\n};\n\n#define show_fan_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\t\t\tchar *buf) \\\n{ \\\n\tstruct sensor_device_attribute *sensor_attr = \\\n\t\t\t\t\t\tto_sensor_dev_attr(attr); \\\n\tstruct w83791d_data *data = w83791d_update_device(dev); \\\n\tint nr = sensor_attr->index; \\\n\treturn sprintf(buf, \"%d\\n\", \\\n\t\tFAN_FROM_REG(data->reg[nr], DIV_FROM_REG(data->fan_div[nr]))); \\\n}\n\nshow_fan_reg(fan);\nshow_fan_reg(fan_min);\n\nstatic ssize_t store_fan_min(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tint nr = sensor_attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_min[nr] = fan_to_reg(val, DIV_FROM_REG(data->fan_div[nr]));\n\tw83791d_write(client, W83791D_REG_FAN_MIN[nr], data->fan_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_fan_div(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", DIV_FROM_REG(data->fan_div[nr]));\n}\n\n \nstatic ssize_t store_fan_div(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tint nr = sensor_attr->index;\n\tunsigned long min;\n\tu8 tmp_fan_div;\n\tu8 fan_div_reg;\n\tu8 vbat_reg;\n\tint indx = 0;\n\tu8 keep_mask = 0;\n\tu8 new_shift = 0;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmin = FAN_FROM_REG(data->fan_min[nr], DIV_FROM_REG(data->fan_div[nr]));\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_div[nr] = div_to_reg(nr, val);\n\n\tswitch (nr) {\n\tcase 0:\n\t\tindx = 0;\n\t\tkeep_mask = 0xcf;\n\t\tnew_shift = 4;\n\t\tbreak;\n\tcase 1:\n\t\tindx = 0;\n\t\tkeep_mask = 0x3f;\n\t\tnew_shift = 6;\n\t\tbreak;\n\tcase 2:\n\t\tindx = 1;\n\t\tkeep_mask = 0x3f;\n\t\tnew_shift = 6;\n\t\tbreak;\n\tcase 3:\n\t\tindx = 2;\n\t\tkeep_mask = 0xf8;\n\t\tnew_shift = 0;\n\t\tbreak;\n\tcase 4:\n\t\tindx = 2;\n\t\tkeep_mask = 0x8f;\n\t\tnew_shift = 4;\n\t\tbreak;\n#ifdef DEBUG\n\tdefault:\n\t\tdev_warn(dev, \"store_fan_div: Unexpected nr seen: %d\\n\", nr);\n\t\tcount = -EINVAL;\n\t\tgoto err_exit;\n#endif\n\t}\n\n\tfan_div_reg = w83791d_read(client, W83791D_REG_FAN_DIV[indx])\n\t\t\t& keep_mask;\n\ttmp_fan_div = (data->fan_div[nr] << new_shift) & ~keep_mask;\n\n\tw83791d_write(client, W83791D_REG_FAN_DIV[indx],\n\t\t\t\tfan_div_reg | tmp_fan_div);\n\n\t \n\tif (nr < 3) {\n\t\tkeep_mask = ~(1 << (nr + 5));\n\t\tvbat_reg = w83791d_read(client, W83791D_REG_VBAT)\n\t\t\t\t& keep_mask;\n\t\ttmp_fan_div = (data->fan_div[nr] << (3 + nr)) & ~keep_mask;\n\t\tw83791d_write(client, W83791D_REG_VBAT,\n\t\t\t\tvbat_reg | tmp_fan_div);\n\t}\n\n\t \n\tdata->fan_min[nr] = fan_to_reg(min, DIV_FROM_REG(data->fan_div[nr]));\n\tw83791d_write(client, W83791D_REG_FAN_MIN[nr], data->fan_min[nr]);\n\n#ifdef DEBUG\nerr_exit:\n#endif\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic struct sensor_device_attribute sda_fan_input[] = {\n\tSENSOR_ATTR(fan1_input, S_IRUGO, show_fan, NULL, 0),\n\tSENSOR_ATTR(fan2_input, S_IRUGO, show_fan, NULL, 1),\n\tSENSOR_ATTR(fan3_input, S_IRUGO, show_fan, NULL, 2),\n\tSENSOR_ATTR(fan4_input, S_IRUGO, show_fan, NULL, 3),\n\tSENSOR_ATTR(fan5_input, S_IRUGO, show_fan, NULL, 4),\n};\n\nstatic struct sensor_device_attribute sda_fan_min[] = {\n\tSENSOR_ATTR(fan1_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_min, store_fan_min, 0),\n\tSENSOR_ATTR(fan2_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_min, store_fan_min, 1),\n\tSENSOR_ATTR(fan3_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_min, store_fan_min, 2),\n\tSENSOR_ATTR(fan4_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_min, store_fan_min, 3),\n\tSENSOR_ATTR(fan5_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_min, store_fan_min, 4),\n};\n\nstatic struct sensor_device_attribute sda_fan_div[] = {\n\tSENSOR_ATTR(fan1_div, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_div, store_fan_div, 0),\n\tSENSOR_ATTR(fan2_div, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_div, store_fan_div, 1),\n\tSENSOR_ATTR(fan3_div, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_div, store_fan_div, 2),\n\tSENSOR_ATTR(fan4_div, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_div, store_fan_div, 3),\n\tSENSOR_ATTR(fan5_div, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_div, store_fan_div, 4),\n};\n\nstatic struct sensor_device_attribute sda_fan_beep[] = {\n\tSENSOR_ATTR(fan1_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 6),\n\tSENSOR_ATTR(fan2_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 7),\n\tSENSOR_ATTR(fan3_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 11),\n\tSENSOR_ATTR(fan4_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 21),\n\tSENSOR_ATTR(fan5_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 22),\n};\n\nstatic struct sensor_device_attribute sda_fan_alarm[] = {\n\tSENSOR_ATTR(fan1_alarm, S_IRUGO, show_alarm, NULL, 6),\n\tSENSOR_ATTR(fan2_alarm, S_IRUGO, show_alarm, NULL, 7),\n\tSENSOR_ATTR(fan3_alarm, S_IRUGO, show_alarm, NULL, 11),\n\tSENSOR_ATTR(fan4_alarm, S_IRUGO, show_alarm, NULL, 21),\n\tSENSOR_ATTR(fan5_alarm, S_IRUGO, show_alarm, NULL, 22),\n};\n\n \nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", data->pwm[nr]);\n}\n\nstatic ssize_t store_pwm(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tint nr = sensor_attr->index;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm[nr] = clamp_val(val, 0, 255);\n\tw83791d_write(client, W83791D_REG_PWM[nr], data->pwm[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic struct sensor_device_attribute sda_pwm[] = {\n\tSENSOR_ATTR(pwm1, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwm, store_pwm, 0),\n\tSENSOR_ATTR(pwm2, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwm, store_pwm, 1),\n\tSENSOR_ATTR(pwm3, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwm, store_pwm, 2),\n\tSENSOR_ATTR(pwm4, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwm, store_pwm, 3),\n\tSENSOR_ATTR(pwm5, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwm, store_pwm, 4),\n};\n\nstatic ssize_t show_pwmenable(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", data->pwm_enable[nr] + 1);\n}\n\nstatic ssize_t store_pwmenable(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tint nr = sensor_attr->index;\n\tunsigned long val;\n\tu8 reg_cfg_tmp;\n\tu8 reg_idx = 0;\n\tu8 val_shift = 0;\n\tu8 keep_mask = 0;\n\n\tint ret = kstrtoul(buf, 10, &val);\n\n\tif (ret || val < 1 || val > 3)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm_enable[nr] = val - 1;\n\tswitch (nr) {\n\tcase 0:\n\t\treg_idx = 0;\n\t\tval_shift = 2;\n\t\tkeep_mask = 0xf3;\n\t\tbreak;\n\tcase 1:\n\t\treg_idx = 0;\n\t\tval_shift = 4;\n\t\tkeep_mask = 0xcf;\n\t\tbreak;\n\tcase 2:\n\t\treg_idx = 1;\n\t\tval_shift = 2;\n\t\tkeep_mask = 0xf3;\n\t\tbreak;\n\t}\n\n\treg_cfg_tmp = w83791d_read(client, W83791D_REG_FAN_CFG[reg_idx]);\n\treg_cfg_tmp = (reg_cfg_tmp & keep_mask) |\n\t\t\t\t\tdata->pwm_enable[nr] << val_shift;\n\n\tw83791d_write(client, W83791D_REG_FAN_CFG[reg_idx], reg_cfg_tmp);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\nstatic struct sensor_device_attribute sda_pwmenable[] = {\n\tSENSOR_ATTR(pwm1_enable, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwmenable, store_pwmenable, 0),\n\tSENSOR_ATTR(pwm2_enable, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwmenable, store_pwmenable, 1),\n\tSENSOR_ATTR(pwm3_enable, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwmenable, store_pwmenable, 2),\n};\n\n \nstatic ssize_t show_temp_target(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\tint nr = sensor_attr->index;\n\treturn sprintf(buf, \"%d\\n\", TEMP1_FROM_REG(data->temp_target[nr]));\n}\n\nstatic ssize_t store_temp_target(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tint nr = sensor_attr->index;\n\tlong val;\n\tu8 target_mask;\n\n\tif (kstrtol(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_target[nr] = TARGET_TEMP_TO_REG(val);\n\ttarget_mask = w83791d_read(client,\n\t\t\t\tW83791D_REG_TEMP_TARGET[nr]) & 0x80;\n\tw83791d_write(client, W83791D_REG_TEMP_TARGET[nr],\n\t\t\t\tdata->temp_target[nr] | target_mask);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic struct sensor_device_attribute sda_temp_target[] = {\n\tSENSOR_ATTR(temp1_target, S_IWUSR | S_IRUGO,\n\t\t\tshow_temp_target, store_temp_target, 0),\n\tSENSOR_ATTR(temp2_target, S_IWUSR | S_IRUGO,\n\t\t\tshow_temp_target, store_temp_target, 1),\n\tSENSOR_ATTR(temp3_target, S_IWUSR | S_IRUGO,\n\t\t\tshow_temp_target, store_temp_target, 2),\n};\n\nstatic ssize_t show_temp_tolerance(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\tint nr = sensor_attr->index;\n\treturn sprintf(buf, \"%d\\n\", TEMP1_FROM_REG(data->temp_tolerance[nr]));\n}\n\nstatic ssize_t store_temp_tolerance(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tint nr = sensor_attr->index;\n\tunsigned long val;\n\tu8 target_mask;\n\tu8 reg_idx = 0;\n\tu8 val_shift = 0;\n\tu8 keep_mask = 0;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tswitch (nr) {\n\tcase 0:\n\t\treg_idx = 0;\n\t\tval_shift = 0;\n\t\tkeep_mask = 0xf0;\n\t\tbreak;\n\tcase 1:\n\t\treg_idx = 0;\n\t\tval_shift = 4;\n\t\tkeep_mask = 0x0f;\n\t\tbreak;\n\tcase 2:\n\t\treg_idx = 1;\n\t\tval_shift = 0;\n\t\tkeep_mask = 0xf0;\n\t\tbreak;\n\t}\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_tolerance[nr] = TOL_TEMP_TO_REG(val);\n\ttarget_mask = w83791d_read(client,\n\t\t\tW83791D_REG_TEMP_TOL[reg_idx]) & keep_mask;\n\tw83791d_write(client, W83791D_REG_TEMP_TOL[reg_idx],\n\t\t\t(data->temp_tolerance[nr] << val_shift) | target_mask);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic struct sensor_device_attribute sda_temp_tolerance[] = {\n\tSENSOR_ATTR(temp1_tolerance, S_IWUSR | S_IRUGO,\n\t\t\tshow_temp_tolerance, store_temp_tolerance, 0),\n\tSENSOR_ATTR(temp2_tolerance, S_IWUSR | S_IRUGO,\n\t\t\tshow_temp_tolerance, store_temp_tolerance, 1),\n\tSENSOR_ATTR(temp3_tolerance, S_IWUSR | S_IRUGO,\n\t\t\tshow_temp_tolerance, store_temp_tolerance, 2),\n};\n\n \nstatic ssize_t show_temp1(struct device *dev, struct device_attribute *devattr,\n\t\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP1_FROM_REG(data->temp1[attr->index]));\n}\n\nstatic ssize_t store_temp1(struct device *dev, struct device_attribute *devattr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp1[nr] = TEMP1_TO_REG(val);\n\tw83791d_write(client, W83791D_REG_TEMP1[nr], data->temp1[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \nstatic ssize_t show_temp23(struct device *dev, struct device_attribute *devattr,\n\t\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\tint nr = attr->nr;\n\tint index = attr->index;\n\treturn sprintf(buf, \"%d\\n\", TEMP23_FROM_REG(data->temp_add[nr][index]));\n}\n\nstatic ssize_t store_temp23(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tlong val;\n\tint err;\n\tint nr = attr->nr;\n\tint index = attr->index;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_add[nr][index] = TEMP23_TO_REG(val);\n\tw83791d_write(client, W83791D_REG_TEMP_ADD[nr][index * 2],\n\t\t\t\tdata->temp_add[nr][index] >> 8);\n\tw83791d_write(client, W83791D_REG_TEMP_ADD[nr][index * 2 + 1],\n\t\t\t\tdata->temp_add[nr][index] & 0x80);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic struct sensor_device_attribute_2 sda_temp_input[] = {\n\tSENSOR_ATTR_2(temp1_input, S_IRUGO, show_temp1, NULL, 0, 0),\n\tSENSOR_ATTR_2(temp2_input, S_IRUGO, show_temp23, NULL, 0, 0),\n\tSENSOR_ATTR_2(temp3_input, S_IRUGO, show_temp23, NULL, 1, 0),\n};\n\nstatic struct sensor_device_attribute_2 sda_temp_max[] = {\n\tSENSOR_ATTR_2(temp1_max, S_IRUGO | S_IWUSR,\n\t\t\tshow_temp1, store_temp1, 0, 1),\n\tSENSOR_ATTR_2(temp2_max, S_IRUGO | S_IWUSR,\n\t\t\tshow_temp23, store_temp23, 0, 1),\n\tSENSOR_ATTR_2(temp3_max, S_IRUGO | S_IWUSR,\n\t\t\tshow_temp23, store_temp23, 1, 1),\n};\n\nstatic struct sensor_device_attribute_2 sda_temp_max_hyst[] = {\n\tSENSOR_ATTR_2(temp1_max_hyst, S_IRUGO | S_IWUSR,\n\t\t\tshow_temp1, store_temp1, 0, 2),\n\tSENSOR_ATTR_2(temp2_max_hyst, S_IRUGO | S_IWUSR,\n\t\t\tshow_temp23, store_temp23, 0, 2),\n\tSENSOR_ATTR_2(temp3_max_hyst, S_IRUGO | S_IWUSR,\n\t\t\tshow_temp23, store_temp23, 1, 2),\n};\n\n \nstatic struct sensor_device_attribute sda_temp_beep[] = {\n\tSENSOR_ATTR(temp1_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 4),\n\tSENSOR_ATTR(temp2_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 5),\n\tSENSOR_ATTR(temp3_beep, S_IWUSR | S_IRUGO, show_beep, store_beep, 1),\n};\n\nstatic struct sensor_device_attribute sda_temp_alarm[] = {\n\tSENSOR_ATTR(temp1_alarm, S_IRUGO, show_alarm, NULL, 4),\n\tSENSOR_ATTR(temp2_alarm, S_IRUGO, show_alarm, NULL, 5),\n\tSENSOR_ATTR(temp3_alarm, S_IRUGO, show_alarm, NULL, 13),\n};\n\n \nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", data->alarms);\n}\n\nstatic DEVICE_ATTR_RO(alarms);\n\n \n\n#define GLOBAL_BEEP_ENABLE_SHIFT\t15\n#define GLOBAL_BEEP_ENABLE_MASK\t\t(1 << GLOBAL_BEEP_ENABLE_SHIFT)\n\nstatic ssize_t show_beep_enable(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->beep_enable);\n}\n\nstatic ssize_t show_beep_mask(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", BEEP_MASK_FROM_REG(data->beep_mask));\n}\n\n\nstatic ssize_t store_beep_mask(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tint i;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tdata->beep_mask = BEEP_MASK_TO_REG(val) & ~GLOBAL_BEEP_ENABLE_MASK;\n\tdata->beep_mask |= (data->beep_enable << GLOBAL_BEEP_ENABLE_SHIFT);\n\n\tval = data->beep_mask;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tw83791d_write(client, W83791D_REG_BEEP_CTRL[i], (val & 0xff));\n\t\tval >>= 8;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t store_beep_enable(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\tdata->beep_enable = val ? 1 : 0;\n\n\t \n\tdata->beep_mask &= ~GLOBAL_BEEP_ENABLE_MASK;\n\tdata->beep_mask |= (data->beep_enable << GLOBAL_BEEP_ENABLE_SHIFT);\n\n\t \n\tval = (data->beep_mask >> 8) & 0xff;\n\n\tw83791d_write(client, W83791D_REG_BEEP_CTRL[1], val);\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic struct sensor_device_attribute sda_beep_ctrl[] = {\n\tSENSOR_ATTR(beep_enable, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep_enable, store_beep_enable, 0),\n\tSENSOR_ATTR(beep_mask, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep_mask, store_beep_mask, 1)\n};\n\n \nstatic ssize_t cpu0_vid_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct w83791d_data *data = w83791d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", vid_from_reg(data->vid, data->vrm));\n}\n\nstatic DEVICE_ATTR_RO(cpu0_vid);\n\nstatic ssize_t vrm_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct w83791d_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", data->vrm);\n}\n\nstatic ssize_t vrm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct w83791d_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\t \n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tdata->vrm = val;\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(vrm);\n\n#define IN_UNIT_ATTRS(X) \\\n\t&sda_in_input[X].dev_attr.attr,\t\\\n\t&sda_in_min[X].dev_attr.attr,\t\\\n\t&sda_in_max[X].dev_attr.attr,\t\\\n\t&sda_in_beep[X].dev_attr.attr,\t\\\n\t&sda_in_alarm[X].dev_attr.attr\n\n#define FAN_UNIT_ATTRS(X) \\\n\t&sda_fan_input[X].dev_attr.attr,\t\\\n\t&sda_fan_min[X].dev_attr.attr,\t\t\\\n\t&sda_fan_div[X].dev_attr.attr,\t\t\\\n\t&sda_fan_beep[X].dev_attr.attr,\t\t\\\n\t&sda_fan_alarm[X].dev_attr.attr\n\n#define TEMP_UNIT_ATTRS(X) \\\n\t&sda_temp_input[X].dev_attr.attr,\t\\\n\t&sda_temp_max[X].dev_attr.attr,\t\t\\\n\t&sda_temp_max_hyst[X].dev_attr.attr,\t\\\n\t&sda_temp_beep[X].dev_attr.attr,\t\\\n\t&sda_temp_alarm[X].dev_attr.attr\n\nstatic struct attribute *w83791d_attributes[] = {\n\tIN_UNIT_ATTRS(0),\n\tIN_UNIT_ATTRS(1),\n\tIN_UNIT_ATTRS(2),\n\tIN_UNIT_ATTRS(3),\n\tIN_UNIT_ATTRS(4),\n\tIN_UNIT_ATTRS(5),\n\tIN_UNIT_ATTRS(6),\n\tIN_UNIT_ATTRS(7),\n\tIN_UNIT_ATTRS(8),\n\tIN_UNIT_ATTRS(9),\n\tFAN_UNIT_ATTRS(0),\n\tFAN_UNIT_ATTRS(1),\n\tFAN_UNIT_ATTRS(2),\n\tTEMP_UNIT_ATTRS(0),\n\tTEMP_UNIT_ATTRS(1),\n\tTEMP_UNIT_ATTRS(2),\n\t&dev_attr_alarms.attr,\n\t&sda_beep_ctrl[0].dev_attr.attr,\n\t&sda_beep_ctrl[1].dev_attr.attr,\n\t&dev_attr_cpu0_vid.attr,\n\t&dev_attr_vrm.attr,\n\t&sda_pwm[0].dev_attr.attr,\n\t&sda_pwm[1].dev_attr.attr,\n\t&sda_pwm[2].dev_attr.attr,\n\t&sda_pwmenable[0].dev_attr.attr,\n\t&sda_pwmenable[1].dev_attr.attr,\n\t&sda_pwmenable[2].dev_attr.attr,\n\t&sda_temp_target[0].dev_attr.attr,\n\t&sda_temp_target[1].dev_attr.attr,\n\t&sda_temp_target[2].dev_attr.attr,\n\t&sda_temp_tolerance[0].dev_attr.attr,\n\t&sda_temp_tolerance[1].dev_attr.attr,\n\t&sda_temp_tolerance[2].dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group w83791d_group = {\n\t.attrs = w83791d_attributes,\n};\n\n \nstatic struct attribute *w83791d_attributes_fanpwm45[] = {\n\tFAN_UNIT_ATTRS(3),\n\tFAN_UNIT_ATTRS(4),\n\t&sda_pwm[3].dev_attr.attr,\n\t&sda_pwm[4].dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group w83791d_group_fanpwm45 = {\n\t.attrs = w83791d_attributes_fanpwm45,\n};\n\nstatic int w83791d_detect_subclients(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint address = client->addr;\n\tint i, id;\n\tu8 val;\n\n\tid = i2c_adapter_id(adapter);\n\tif (force_subclients[0] == id && force_subclients[1] == address) {\n\t\tfor (i = 2; i <= 3; i++) {\n\t\t\tif (force_subclients[i] < 0x48 ||\n\t\t\t    force_subclients[i] > 0x4f) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"invalid subclient \"\n\t\t\t\t\t\"address %d; must be 0x48-0x4f\\n\",\n\t\t\t\t\tforce_subclients[i]);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t\tw83791d_write(client, W83791D_REG_I2C_SUBADDR,\n\t\t\t\t\t(force_subclients[2] & 0x07) |\n\t\t\t\t\t((force_subclients[3] & 0x07) << 4));\n\t}\n\n\tval = w83791d_read(client, W83791D_REG_I2C_SUBADDR);\n\n\tif (!(val & 0x88) && (val & 0x7) == ((val >> 4) & 0x7)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"duplicate addresses 0x%x, use force_subclient\\n\", 0x48 + (val & 0x7));\n\t\treturn -ENODEV;\n\t}\n\n\tif (!(val & 0x08))\n\t\tdevm_i2c_new_dummy_device(&client->dev, adapter, 0x48 + (val & 0x7));\n\n\tif (!(val & 0x80))\n\t\tdevm_i2c_new_dummy_device(&client->dev, adapter, 0x48 + ((val >> 4) & 0x7));\n\n\treturn 0;\n}\n\n\n \nstatic int w83791d_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint val1, val2;\n\tunsigned short address = client->addr;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tif (w83791d_read(client, W83791D_REG_CONFIG) & 0x80)\n\t\treturn -ENODEV;\n\n\tval1 = w83791d_read(client, W83791D_REG_BANK);\n\tval2 = w83791d_read(client, W83791D_REG_CHIPMAN);\n\t \n\tif (!(val1 & 0x07)) {\n\t\tif ((!(val1 & 0x80) && val2 != 0xa3) ||\n\t\t    ((val1 & 0x80) && val2 != 0x5c)) {\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\t \n\tif (w83791d_read(client, W83791D_REG_I2C_ADDR) != address)\n\t\treturn -ENODEV;\n\n\t \n\tval1 = w83791d_read(client, W83791D_REG_BANK) & 0x78;\n\tw83791d_write(client, W83791D_REG_BANK, val1 | 0x80);\n\n\t \n\tval1 = w83791d_read(client, W83791D_REG_WCHIPID);\n\tval2 = w83791d_read(client, W83791D_REG_CHIPMAN);\n\tif (val1 != 0x71 || val2 != 0x5c)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"w83791d\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int w83791d_probe(struct i2c_client *client)\n{\n\tstruct w83791d_data *data;\n\tstruct device *dev = &client->dev;\n\tint i, err;\n\tu8 has_fanpwm45;\n\n#ifdef DEBUG\n\tint val1;\n\tval1 = w83791d_read(client, W83791D_REG_DID_VID4);\n\tdev_dbg(dev, \"Device ID version: %d.%d (0x%02x)\\n\",\n\t\t\t(val1 >> 5) & 0x07, (val1 >> 1) & 0x0f, val1);\n#endif\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct w83791d_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\n\terr = w83791d_detect_subclients(client);\n\tif (err)\n\t\treturn err;\n\n\t \n\tw83791d_init_client(client);\n\n\t \n\tfor (i = 0; i < NUMBER_OF_FANIN; i++)\n\t\tdata->fan_min[i] = w83791d_read(client, W83791D_REG_FAN_MIN[i]);\n\n\t \n\terr = sysfs_create_group(&client->dev.kobj, &w83791d_group);\n\tif (err)\n\t\treturn err;\n\n\t \n\thas_fanpwm45 = w83791d_read(client, W83791D_REG_GPIO) & 0x10;\n\tif (has_fanpwm45) {\n\t\terr = sysfs_create_group(&client->dev.kobj,\n\t\t\t\t\t &w83791d_group_fanpwm45);\n\t\tif (err)\n\t\t\tgoto error4;\n\t}\n\n\t \n\tdata->hwmon_dev = hwmon_device_register(dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto error5;\n\t}\n\n\treturn 0;\n\nerror5:\n\tif (has_fanpwm45)\n\t\tsysfs_remove_group(&client->dev.kobj, &w83791d_group_fanpwm45);\nerror4:\n\tsysfs_remove_group(&client->dev.kobj, &w83791d_group);\n\treturn err;\n}\n\nstatic void w83791d_remove(struct i2c_client *client)\n{\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tsysfs_remove_group(&client->dev.kobj, &w83791d_group);\n}\n\nstatic void w83791d_init_client(struct i2c_client *client)\n{\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tu8 tmp;\n\tu8 old_beep;\n\n\t \n\tif (reset || init) {\n\t\t \n\t\told_beep = w83791d_read(client, W83791D_REG_BEEP_CONFIG);\n\n\t\tif (reset) {\n\t\t\t \n\t\t\tw83791d_write(client, W83791D_REG_CONFIG, 0x80);\n\t\t}\n\n\t\t \n\t\tw83791d_write(client, W83791D_REG_BEEP_CONFIG, old_beep | 0x80);\n\n\t\t \n\t\ttmp = w83791d_read(client, W83791D_REG_BEEP_CTRL[1]);\n\t\tw83791d_write(client, W83791D_REG_BEEP_CTRL[1], tmp & 0xef);\n\n\t\tif (init) {\n\t\t\t \n\t\t\ttmp = w83791d_read(client, W83791D_REG_TEMP2_CONFIG);\n\t\t\tif (tmp & 1) {\n\t\t\t\tw83791d_write(client, W83791D_REG_TEMP2_CONFIG,\n\t\t\t\t\ttmp & 0xfe);\n\t\t\t}\n\n\t\t\ttmp = w83791d_read(client, W83791D_REG_TEMP3_CONFIG);\n\t\t\tif (tmp & 1) {\n\t\t\t\tw83791d_write(client, W83791D_REG_TEMP3_CONFIG,\n\t\t\t\t\ttmp & 0xfe);\n\t\t\t}\n\n\t\t\t \n\t\t\ttmp = w83791d_read(client, W83791D_REG_CONFIG) & 0xf7;\n\t\t\tw83791d_write(client, W83791D_REG_CONFIG, tmp | 0x01);\n\t\t}\n\t}\n\n\tdata->vrm = vid_which_vrm();\n}\n\nstatic struct w83791d_data *w83791d_update_device(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83791d_data *data = i2c_get_clientdata(client);\n\tint i, j;\n\tu8 reg_array_tmp[3];\n\tu8 vbat_reg;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + (HZ * 3))\n\t\t\t|| !data->valid) {\n\t\tdev_dbg(dev, \"Starting w83791d device update\\n\");\n\n\t\t \n\t\tfor (i = 0; i < NUMBER_OF_VIN; i++) {\n\t\t\tdata->in[i] = w83791d_read(client,\n\t\t\t\t\t\tW83791D_REG_IN[i]);\n\t\t\tdata->in_max[i] = w83791d_read(client,\n\t\t\t\t\t\tW83791D_REG_IN_MAX[i]);\n\t\t\tdata->in_min[i] = w83791d_read(client,\n\t\t\t\t\t\tW83791D_REG_IN_MIN[i]);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < NUMBER_OF_FANIN; i++) {\n\t\t\t \n\t\t\tdata->fan[i] = w83791d_read(client,\n\t\t\t\t\t\tW83791D_REG_FAN[i]);\n\t\t\tdata->fan_min[i] = w83791d_read(client,\n\t\t\t\t\t\tW83791D_REG_FAN_MIN[i]);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\treg_array_tmp[i] = w83791d_read(client,\n\t\t\t\t\t\tW83791D_REG_FAN_DIV[i]);\n\t\t}\n\t\tdata->fan_div[0] = (reg_array_tmp[0] >> 4) & 0x03;\n\t\tdata->fan_div[1] = (reg_array_tmp[0] >> 6) & 0x03;\n\t\tdata->fan_div[2] = (reg_array_tmp[1] >> 6) & 0x03;\n\t\tdata->fan_div[3] = reg_array_tmp[2] & 0x07;\n\t\tdata->fan_div[4] = (reg_array_tmp[2] >> 4) & 0x07;\n\n\t\t \n\t\tvbat_reg = w83791d_read(client, W83791D_REG_VBAT);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tdata->fan_div[i] |= (vbat_reg >> (3 + i)) & 0x04;\n\n\t\t \n\t\tfor (i = 0; i < NUMBER_OF_PWM; i++) {\n\t\t\tdata->pwm[i] =  w83791d_read(client,\n\t\t\t\t\t\tW83791D_REG_PWM[i]);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\treg_array_tmp[i] = w83791d_read(client,\n\t\t\t\t\t\tW83791D_REG_FAN_CFG[i]);\n\t\t}\n\t\tdata->pwm_enable[0] = (reg_array_tmp[0] >> 2) & 0x03;\n\t\tdata->pwm_enable[1] = (reg_array_tmp[0] >> 4) & 0x03;\n\t\tdata->pwm_enable[2] = (reg_array_tmp[1] >> 2) & 0x03;\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tdata->temp_target[i] = w83791d_read(client,\n\t\t\t\tW83791D_REG_TEMP_TARGET[i]) & 0x7f;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\treg_array_tmp[i] = w83791d_read(client,\n\t\t\t\t\tW83791D_REG_TEMP_TOL[i]);\n\t\t}\n\t\tdata->temp_tolerance[0] = reg_array_tmp[0] & 0x0f;\n\t\tdata->temp_tolerance[1] = (reg_array_tmp[0] >> 4) & 0x0f;\n\t\tdata->temp_tolerance[2] = reg_array_tmp[1] & 0x0f;\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tdata->temp1[i] = w83791d_read(client,\n\t\t\t\t\t\tW83791D_REG_TEMP1[i]);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\tdata->temp_add[i][j] =\n\t\t\t\t\t(w83791d_read(client,\n\t\t\t\t\tW83791D_REG_TEMP_ADD[i][j * 2]) << 8) |\n\t\t\t\t\tw83791d_read(client,\n\t\t\t\t\tW83791D_REG_TEMP_ADD[i][j * 2 + 1]);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdata->alarms =\n\t\t\tw83791d_read(client, W83791D_REG_ALARM1) +\n\t\t\t(w83791d_read(client, W83791D_REG_ALARM2) << 8) +\n\t\t\t(w83791d_read(client, W83791D_REG_ALARM3) << 16);\n\n\t\t \n\t\tdata->beep_mask =\n\t\t\tw83791d_read(client, W83791D_REG_BEEP_CTRL[0]) +\n\t\t\t(w83791d_read(client, W83791D_REG_BEEP_CTRL[1]) << 8) +\n\t\t\t(w83791d_read(client, W83791D_REG_BEEP_CTRL[2]) << 16);\n\n\t\t \n\t\tdata->beep_enable =\n\t\t\t(data->beep_mask >> GLOBAL_BEEP_ENABLE_SHIFT) & 0x01;\n\n\t\t \n\t\ti = w83791d_read(client, W83791D_REG_VID_FANDIV);\n\t\tdata->vid = i & 0x0f;\n\t\tdata->vid |= (w83791d_read(client, W83791D_REG_DID_VID4) & 0x01)\n\t\t\t\t<< 4;\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n#ifdef DEBUG\n\tw83791d_print_debug(data, dev);\n#endif\n\n\treturn data;\n}\n\n#ifdef DEBUG\nstatic void w83791d_print_debug(struct w83791d_data *data, struct device *dev)\n{\n\tint i = 0, j = 0;\n\n\tdev_dbg(dev, \"======Start of w83791d debug values======\\n\");\n\tdev_dbg(dev, \"%d set of Voltages: ===>\\n\", NUMBER_OF_VIN);\n\tfor (i = 0; i < NUMBER_OF_VIN; i++) {\n\t\tdev_dbg(dev, \"vin[%d] is:     0x%02x\\n\", i, data->in[i]);\n\t\tdev_dbg(dev, \"vin[%d] min is: 0x%02x\\n\", i, data->in_min[i]);\n\t\tdev_dbg(dev, \"vin[%d] max is: 0x%02x\\n\", i, data->in_max[i]);\n\t}\n\tdev_dbg(dev, \"%d set of Fan Counts/Divisors: ===>\\n\", NUMBER_OF_FANIN);\n\tfor (i = 0; i < NUMBER_OF_FANIN; i++) {\n\t\tdev_dbg(dev, \"fan[%d] is:     0x%02x\\n\", i, data->fan[i]);\n\t\tdev_dbg(dev, \"fan[%d] min is: 0x%02x\\n\", i, data->fan_min[i]);\n\t\tdev_dbg(dev, \"fan_div[%d] is: 0x%02x\\n\", i, data->fan_div[i]);\n\t}\n\n\t \n\tdev_dbg(dev, \"%d set of Temperatures: ===>\\n\", NUMBER_OF_TEMPIN);\n\tfor (i = 0; i < 3; i++)\n\t\tdev_dbg(dev, \"temp1[%d] is: 0x%02x\\n\", i, (u8) data->temp1[i]);\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tdev_dbg(dev, \"temp_add[%d][%d] is: 0x%04x\\n\", i, j,\n\t\t\t\t(u16) data->temp_add[i][j]);\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"Misc Information: ===>\\n\");\n\tdev_dbg(dev, \"alarm is:     0x%08x\\n\", data->alarms);\n\tdev_dbg(dev, \"beep_mask is: 0x%08x\\n\", data->beep_mask);\n\tdev_dbg(dev, \"beep_enable is: %d\\n\", data->beep_enable);\n\tdev_dbg(dev, \"vid is: 0x%02x\\n\", data->vid);\n\tdev_dbg(dev, \"vrm is: 0x%02x\\n\", data->vrm);\n\tdev_dbg(dev, \"=======End of w83791d debug values========\\n\");\n\tdev_dbg(dev, \"\\n\");\n}\n#endif\n\nmodule_i2c_driver(w83791d_driver);\n\nMODULE_AUTHOR(\"Charles Spirakis <bezaur@gmail.com>\");\nMODULE_DESCRIPTION(\"W83791D driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}