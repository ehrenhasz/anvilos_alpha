{
  "module_name": "tmp103.c",
  "hash_id": "5dbda9f998714f3c2cb0119fbae6bc89727a9c8cdf499b2b624e3605f26224d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/tmp103.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/jiffies.h>\n#include <linux/regmap.h>\n\n#define TMP103_TEMP_REG\t\t0x00\n#define TMP103_CONF_REG\t\t0x01\n#define TMP103_TLOW_REG\t\t0x02\n#define TMP103_THIGH_REG\t0x03\n\n#define TMP103_CONF_M0\t\t0x01\n#define TMP103_CONF_M1\t\t0x02\n#define TMP103_CONF_LC\t\t0x04\n#define TMP103_CONF_FL\t\t0x08\n#define TMP103_CONF_FH\t\t0x10\n#define TMP103_CONF_CR0\t\t0x20\n#define TMP103_CONF_CR1\t\t0x40\n#define TMP103_CONF_ID\t\t0x80\n#define TMP103_CONF_SD\t\t(TMP103_CONF_M1)\n#define TMP103_CONF_SD_MASK\t(TMP103_CONF_M0 | TMP103_CONF_M1)\n\n#define TMP103_CONFIG\t\t(TMP103_CONF_CR1 | TMP103_CONF_M1)\n#define TMP103_CONFIG_MASK\t(TMP103_CONF_CR0 | TMP103_CONF_CR1 | \\\n\t\t\t\t TMP103_CONF_M0 | TMP103_CONF_M1)\n\nstatic inline int tmp103_reg_to_mc(s8 val)\n{\n\treturn val * 1000;\n}\n\nstatic inline u8 tmp103_mc_to_reg(int val)\n{\n\treturn DIV_ROUND_CLOSEST(val, 1000);\n}\n\nstatic int tmp103_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long *temp)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err, reg;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treg = TMP103_TEMP_REG;\n\t\tbreak;\n\tcase hwmon_temp_min:\n\t\treg = TMP103_TLOW_REG;\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\treg = TMP103_THIGH_REG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = regmap_read(regmap, reg, &regval);\n\tif (err < 0)\n\t\treturn err;\n\n\t*temp = tmp103_reg_to_mc(regval);\n\n\treturn 0;\n}\n\nstatic int tmp103_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long temp)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\tint reg;\n\n\tswitch (attr) {\n\tcase hwmon_temp_min:\n\t\treg = TMP103_TLOW_REG;\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\treg = TMP103_THIGH_REG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\ttemp = clamp_val(temp, -55000, 127000);\n\treturn regmap_write(regmap, reg, tmp103_mc_to_reg(temp));\n}\n\nstatic umode_t tmp103_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel)\n{\n\tif (type != hwmon_temp)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treturn 0444;\n\tcase hwmon_temp_min:\n\tcase hwmon_temp_max:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const tmp103_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN),\n\tNULL\n};\n\nstatic const struct hwmon_ops tmp103_hwmon_ops = {\n\t.is_visible = tmp103_is_visible,\n\t.read = tmp103_read,\n\t.write = tmp103_write,\n};\n\nstatic const struct hwmon_chip_info tmp103_chip_info = {\n\t.ops = &tmp103_hwmon_ops,\n\t.info = tmp103_info,\n};\n\nstatic bool tmp103_regmap_is_volatile(struct device *dev, unsigned int reg)\n{\n\treturn reg == TMP103_TEMP_REG;\n}\n\nstatic const struct regmap_config tmp103_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = TMP103_THIGH_REG,\n\t.volatile_reg = tmp103_regmap_is_volatile,\n};\n\nstatic int tmp103_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tregmap = devm_regmap_init_i2c(client, &tmp103_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tret = regmap_update_bits(regmap, TMP103_CONF_REG, TMP103_CONFIG_MASK,\n\t\t\t\t TMP103_CONFIG);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"error writing config register\\n\");\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(client, regmap);\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t regmap,\n\t\t\t\t\t\t\t &tmp103_chip_info,\n\t\t\t\t\t\t\t NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic int tmp103_suspend(struct device *dev)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\n\treturn regmap_update_bits(regmap, TMP103_CONF_REG,\n\t\t\t\t  TMP103_CONF_SD_MASK, 0);\n}\n\nstatic int tmp103_resume(struct device *dev)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\n\treturn regmap_update_bits(regmap, TMP103_CONF_REG,\n\t\t\t\t  TMP103_CONF_SD_MASK, TMP103_CONF_SD);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tmp103_dev_pm_ops, tmp103_suspend, tmp103_resume);\n\nstatic const struct i2c_device_id tmp103_id[] = {\n\t{ \"tmp103\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tmp103_id);\n\nstatic const struct of_device_id __maybe_unused tmp103_of_match[] = {\n\t{ .compatible = \"ti,tmp103\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tmp103_of_match);\n\nstatic struct i2c_driver tmp103_driver = {\n\t.driver = {\n\t\t.name\t= \"tmp103\",\n\t\t.of_match_table = of_match_ptr(tmp103_of_match),\n\t\t.pm\t= pm_sleep_ptr(&tmp103_dev_pm_ops),\n\t},\n\t.probe\t\t= tmp103_probe,\n\t.id_table\t= tmp103_id,\n};\n\nmodule_i2c_driver(tmp103_driver);\n\nMODULE_AUTHOR(\"Heiko Schocher <hs@denx.de>\");\nMODULE_DESCRIPTION(\"Texas Instruments TMP103 temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}