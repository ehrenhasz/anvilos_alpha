{
  "module_name": "w83793.c",
  "hash_id": "98eb1245156ad706938c09d2dd4fe123ebd66dd45d5f2d86d18f7ea45334dddf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/w83793.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-vid.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/watchdog.h>\n#include <linux/miscdevice.h>\n#include <linux/uaccess.h>\n#include <linux/kref.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/jiffies.h>\n\n \n#define WATCHDOG_TIMEOUT 2\t \n\n \nstatic const unsigned short normal_i2c[] = { 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t\tI2C_CLIENT_END };\n\n \n\nstatic unsigned short force_subclients[4];\nmodule_param_array(force_subclients, short, NULL, 0);\nMODULE_PARM_DESC(force_subclients,\n\t\t \"List of subclient addresses: {bus, clientaddr, subclientaddr1, subclientaddr2}\");\n\nstatic bool reset;\nmodule_param(reset, bool, 0);\nMODULE_PARM_DESC(reset, \"Set to 1 to reset chip, not recommended\");\n\nstatic int timeout = WATCHDOG_TIMEOUT;\t \nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout,\n\t\"Watchdog timeout in minutes. 2<= timeout <=255 (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_TIMEOUT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \n#define W83793_REG_BANKSEL\t\t0x00\n#define W83793_REG_VENDORID\t\t0x0d\n#define W83793_REG_CHIPID\t\t0x0e\n#define W83793_REG_DEVICEID\t\t0x0f\n\n#define W83793_REG_CONFIG\t\t0x40\n#define W83793_REG_MFC\t\t\t0x58\n#define W83793_REG_FANIN_CTRL\t\t0x5c\n#define W83793_REG_FANIN_SEL\t\t0x5d\n#define W83793_REG_I2C_ADDR\t\t0x0b\n#define W83793_REG_I2C_SUBADDR\t\t0x0c\n#define W83793_REG_VID_INA\t\t0x05\n#define W83793_REG_VID_INB\t\t0x06\n#define W83793_REG_VID_LATCHA\t\t0x07\n#define W83793_REG_VID_LATCHB\t\t0x08\n#define W83793_REG_VID_CTRL\t\t0x59\n\n#define W83793_REG_WDT_LOCK\t\t0x01\n#define W83793_REG_WDT_ENABLE\t\t0x02\n#define W83793_REG_WDT_STATUS\t\t0x03\n#define W83793_REG_WDT_TIMEOUT\t\t0x04\n\nstatic u16 W83793_REG_TEMP_MODE[2] = { 0x5e, 0x5f };\n\n#define TEMP_READ\t0\n#define TEMP_CRIT\t1\n#define TEMP_CRIT_HYST\t2\n#define TEMP_WARN\t3\n#define TEMP_WARN_HYST\t4\n \nstatic u16 W83793_REG_TEMP[][5] = {\n\t{0x1c, 0x78, 0x79, 0x7a, 0x7b},\n\t{0x1d, 0x7c, 0x7d, 0x7e, 0x7f},\n\t{0x1e, 0x80, 0x81, 0x82, 0x83},\n\t{0x1f, 0x84, 0x85, 0x86, 0x87},\n\t{0x20, 0x88, 0x89, 0x8a, 0x8b},\n\t{0x21, 0x8c, 0x8d, 0x8e, 0x8f},\n};\n\n#define W83793_REG_TEMP_LOW_BITS\t0x22\n\n#define W83793_REG_BEEP(index)\t\t(0x53 + (index))\n#define W83793_REG_ALARM(index)\t\t(0x4b + (index))\n\n#define W83793_REG_CLR_CHASSIS\t\t0x4a\t \n#define W83793_REG_IRQ_CTRL\t\t0x50\n#define W83793_REG_OVT_CTRL\t\t0x51\n#define W83793_REG_OVT_BEEP\t\t0x52\n\n#define IN_READ\t\t\t\t0\n#define IN_MAX\t\t\t\t1\n#define IN_LOW\t\t\t\t2\nstatic const u16 W83793_REG_IN[][3] = {\n\t \n\t{0x10, 0x60, 0x61},\t \n\t{0x11, 0x62, 0x63},\t \n\t{0x12, 0x64, 0x65},\t \n\t{0x14, 0x6a, 0x6b},\t \n\t{0x15, 0x6c, 0x6d},\t \n\t{0x16, 0x6e, 0x6f},\t \n\t{0x17, 0x70, 0x71},\t \n\t{0x18, 0x72, 0x73},\t \n\t{0x19, 0x74, 0x75},\t \n\t{0x1a, 0x76, 0x77},\t \n};\n\n \nstatic const u16 W83793_REG_IN_LOW_BITS[] = { 0x1b, 0x68, 0x69 };\nstatic u8 scale_in[] = { 2, 2, 2, 16, 16, 16, 8, 24, 24, 16 };\nstatic u8 scale_in_add[] = { 0, 0, 0, 0, 0, 0, 0, 150, 150, 0 };\n\n#define W83793_REG_FAN(index)\t\t(0x23 + 2 * (index))\t \n#define W83793_REG_FAN_MIN(index)\t(0x90 + 2 * (index))\t \n\n#define W83793_REG_PWM_DEFAULT\t\t0xb2\n#define W83793_REG_PWM_ENABLE\t\t0x207\n#define W83793_REG_PWM_UPTIME\t\t0xc3\t \n#define W83793_REG_PWM_DOWNTIME\t\t0xc4\t \n#define W83793_REG_TEMP_CRITICAL\t0xc5\n\n#define PWM_DUTY\t\t\t0\n#define PWM_START\t\t\t1\n#define PWM_NONSTOP\t\t\t2\n#define PWM_STOP_TIME\t\t\t3\n#define W83793_REG_PWM(index, nr)\t(((nr) == 0 ? 0xb3 : \\\n\t\t\t\t\t (nr) == 1 ? 0x220 : 0x218) + (index))\n\n \n#define W83793_REG_TEMP_FAN_MAP(index)\t(0x201 + (index))\n#define W83793_REG_TEMP_TOL(index)\t(0x208 + (index))\n#define W83793_REG_TEMP_CRUISE(index)\t(0x210 + (index))\n#define W83793_REG_PWM_STOP_TIME(index)\t(0x228 + (index))\n#define W83793_REG_SF2_TEMP(index, nr)\t(0x230 + ((index) << 4) + (nr))\n#define W83793_REG_SF2_PWM(index, nr)\t(0x238 + ((index) << 4) + (nr))\n\nstatic inline unsigned long FAN_FROM_REG(u16 val)\n{\n\tif ((val >= 0xfff) || (val == 0))\n\t\treturn\t0;\n\treturn 1350000UL / val;\n}\n\nstatic inline u16 FAN_TO_REG(long rpm)\n{\n\tif (rpm <= 0)\n\t\treturn 0x0fff;\n\treturn clamp_val((1350000 + (rpm >> 1)) / rpm, 1, 0xffe);\n}\n\nstatic inline unsigned long TIME_FROM_REG(u8 reg)\n{\n\treturn reg * 100;\n}\n\nstatic inline u8 TIME_TO_REG(unsigned long val)\n{\n\treturn clamp_val((val + 50) / 100, 0, 0xff);\n}\n\nstatic inline long TEMP_FROM_REG(s8 reg)\n{\n\treturn reg * 1000;\n}\n\nstatic inline s8 TEMP_TO_REG(long val, s8 min, s8 max)\n{\n\treturn clamp_val((val + (val < 0 ? -500 : 500)) / 1000, min, max);\n}\n\nstruct w83793_data {\n\tstruct device *hwmon_dev;\n\tstruct mutex update_lock;\n\tbool valid;\t\t\t \n\tunsigned long last_updated;\t \n\tunsigned long last_nonvolatile;\t \n\n\tu8 bank;\n\tu8 vrm;\n\tu8 vid[2];\n\tu8 in[10][3];\t\t \n\tu8 in_low_bits[3];\t \n\n\tu16 has_fan;\t\t \n\tu16 fan[12];\t\t \n\tu16 fan_min[12];\t \n\n\ts8 temp[6][5];\t\t \n\tu8 temp_low_bits;\t \n\tu8 temp_mode[2];\t \n\tu8 temp_critical;\t \n\tu8 temp_fan_map[6];\t \n\n\tu8 has_pwm;\n\tu8 has_temp;\n\tu8 has_vid;\n\tu8 pwm_enable;\t\t \n\tu8 pwm_uptime;\t\t \n\tu8 pwm_downtime;\t \n\tu8 pwm_default;\t\t \n\tu8 pwm[8][3];\t\t \n\tu8 pwm_stop_time[8];\n\tu8 temp_cruise[6];\n\n\tu8 alarms[5];\t\t \n\tu8 beeps[5];\n\tu8 beep_enable;\n\tu8 tolerance[3];\t \n\tu8 sf2_pwm[6][7];\t \n\tu8 sf2_temp[6][7];\t \n\n\t \n\tstruct i2c_client *client;\n\tstruct mutex watchdog_lock;\n\tstruct list_head list;  \n\tstruct kref kref;\n\tstruct miscdevice watchdog_miscdev;\n\tunsigned long watchdog_is_open;\n\tchar watchdog_expect_close;\n\tchar watchdog_name[10];  \n\tunsigned int watchdog_caused_reboot;\n\tint watchdog_timeout;  \n};\n\n \nstatic LIST_HEAD(watchdog_data_list);\n\n \nstatic DEFINE_MUTEX(watchdog_data_mutex);\n\n \nstatic void w83793_release_resources(struct kref *ref)\n{\n\tstruct w83793_data *data = container_of(ref, struct w83793_data, kref);\n\tkfree(data);\n}\n\nstatic u8 w83793_read_value(struct i2c_client *client, u16 reg);\nstatic int w83793_write_value(struct i2c_client *client, u16 reg, u8 value);\nstatic int w83793_probe(struct i2c_client *client);\nstatic int w83793_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info);\nstatic void w83793_remove(struct i2c_client *client);\nstatic void w83793_init_client(struct i2c_client *client);\nstatic void w83793_update_nonvolatile(struct device *dev);\nstatic struct w83793_data *w83793_update_device(struct device *dev);\n\nstatic const struct i2c_device_id w83793_id[] = {\n\t{ \"w83793\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, w83793_id);\n\nstatic struct i2c_driver w83793_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t   .name = \"w83793\",\n\t},\n\t.probe\t\t= w83793_probe,\n\t.remove\t\t= w83793_remove,\n\t.id_table\t= w83793_id,\n\t.detect\t\t= w83793_detect,\n\t.address_list\t= normal_i2c,\n};\n\nstatic ssize_t\nvrm_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83793_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", data->vrm);\n}\n\nstatic ssize_t\nshow_vid(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83793_data *data = w83793_update_device(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint index = sensor_attr->index;\n\n\treturn sprintf(buf, \"%d\\n\", vid_from_reg(data->vid[index], data->vrm));\n}\n\nstatic ssize_t\nvrm_store(struct device *dev, struct device_attribute *attr,\n\t  const char *buf, size_t count)\n{\n\tstruct w83793_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tdata->vrm = val;\n\treturn count;\n}\n\n#define ALARM_STATUS\t\t\t0\n#define BEEP_ENABLE\t\t\t1\nstatic ssize_t\nshow_alarm_beep(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83793_data *data = w83793_update_device(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index >> 3;\n\tint bit = sensor_attr->index & 0x07;\n\tu8 val;\n\n\tif (nr == ALARM_STATUS) {\n\t\tval = (data->alarms[index] >> (bit)) & 1;\n\t} else {\t\t \n\t\tval = (data->beeps[index] >> (bit)) & 1;\n\t}\n\n\treturn sprintf(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t\nstore_beep(struct device *dev, struct device_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint index = sensor_attr->index >> 3;\n\tint shift = sensor_attr->index & 0x07;\n\tu8 beep_bit = 1 << shift;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->beeps[index] = w83793_read_value(client, W83793_REG_BEEP(index));\n\tdata->beeps[index] &= ~beep_bit;\n\tdata->beeps[index] |= val << shift;\n\tw83793_write_value(client, W83793_REG_BEEP(index), data->beeps[index]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_beep_enable(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83793_data *data = w83793_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", (data->beep_enable >> 1) & 0x01);\n}\n\nstatic ssize_t\nstore_beep_enable(struct device *dev, struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->beep_enable = w83793_read_value(client, W83793_REG_OVT_BEEP)\n\t\t\t    & 0xfd;\n\tdata->beep_enable |= val << 1;\n\tw83793_write_value(client, W83793_REG_OVT_BEEP, data->beep_enable);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \nstatic ssize_t\nstore_chassis_clear(struct device *dev,\n\t\t    struct device_attribute *attr, const char *buf,\n\t\t    size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tu8 reg;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tif (val)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\treg = w83793_read_value(client, W83793_REG_CLR_CHASSIS);\n\tw83793_write_value(client, W83793_REG_CLR_CHASSIS, reg | 0x80);\n\tdata->valid = false;\t\t \n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n#define FAN_INPUT\t\t\t0\n#define FAN_MIN\t\t\t\t1\nstatic ssize_t\nshow_fan(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83793_data *data = w83793_update_device(dev);\n\tu16 val;\n\n\tif (nr == FAN_INPUT)\n\t\tval = data->fan[index] & 0x0fff;\n\telse\n\t\tval = data->fan_min[index] & 0x0fff;\n\n\treturn sprintf(buf, \"%lu\\n\", FAN_FROM_REG(val));\n}\n\nstatic ssize_t\nstore_fan_min(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint index = sensor_attr->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tval = FAN_TO_REG(val);\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_min[index] = val;\n\tw83793_write_value(client, W83793_REG_FAN_MIN(index),\n\t\t\t   (val >> 8) & 0xff);\n\tw83793_write_value(client, W83793_REG_FAN_MIN(index) + 1, val & 0xff);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_pwm(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tstruct w83793_data *data = w83793_update_device(dev);\n\tu16 val;\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\n\tif (nr == PWM_STOP_TIME)\n\t\tval = TIME_FROM_REG(data->pwm_stop_time[index]);\n\telse\n\t\tval = (data->pwm[index][nr] & 0x3f) << 2;\n\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t\nstore_pwm(struct device *dev, struct device_attribute *attr,\n\t  const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tif (nr == PWM_STOP_TIME) {\n\t\tval = TIME_TO_REG(val);\n\t\tdata->pwm_stop_time[index] = val;\n\t\tw83793_write_value(client, W83793_REG_PWM_STOP_TIME(index),\n\t\t\t\t   val);\n\t} else {\n\t\tval = clamp_val(val, 0, 0xff) >> 2;\n\t\tdata->pwm[index][nr] =\n\t\t    w83793_read_value(client, W83793_REG_PWM(index, nr)) & 0xc0;\n\t\tdata->pwm[index][nr] |= val;\n\t\tw83793_write_value(client, W83793_REG_PWM(index, nr),\n\t\t\t\t\t\t\tdata->pwm[index][nr]);\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\nshow_temp(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83793_data *data = w83793_update_device(dev);\n\tlong temp = TEMP_FROM_REG(data->temp[index][nr]);\n\n\tif (nr == TEMP_READ && index < 4) {\t \n\t\tint low = ((data->temp_low_bits >> (index * 2)) & 0x03) * 250;\n\t\ttemp += temp > 0 ? low : -low;\n\t}\n\treturn sprintf(buf, \"%ld\\n\", temp);\n}\n\nstatic ssize_t\nstore_temp(struct device *dev, struct device_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tlong tmp;\n\tint err;\n\n\terr = kstrtol(buf, 10, &tmp);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp[index][nr] = TEMP_TO_REG(tmp, -128, 127);\n\tw83793_write_value(client, W83793_REG_TEMP[index][nr],\n\t\t\t   data->temp[index][nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \n\n \nstatic u8 TO_TEMP_MODE[] = { 0, 0, 0, 6 };\n\nstatic ssize_t\nshow_temp_mode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83793_data *data = w83793_update_device(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint index = sensor_attr->index;\n\tu8 mask = (index < 4) ? 0x03 : 0x01;\n\tu8 shift = (index < 4) ? (2 * index) : (index - 4);\n\tu8 tmp;\n\tindex = (index < 4) ? 0 : 1;\n\n\ttmp = (data->temp_mode[index] >> shift) & mask;\n\n\t \n\tif (tmp == 1)\n\t\ttmp = index == 0 ? 3 : 4;\n\telse\n\t\ttmp = TO_TEMP_MODE[tmp];\n\n\treturn sprintf(buf, \"%d\\n\", tmp);\n}\n\nstatic ssize_t\nstore_temp_mode(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint index = sensor_attr->index;\n\tu8 mask = (index < 4) ? 0x03 : 0x01;\n\tu8 shift = (index < 4) ? (2 * index) : (index - 4);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif ((val == 6) && (index < 4)) {\n\t\tval -= 3;\n\t} else if ((val == 3 && index < 4)\n\t\t|| (val == 4 && index >= 4)) {\n\t\t \n\t\tval = !!val;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tindex = (index < 4) ? 0 : 1;\n\tmutex_lock(&data->update_lock);\n\tdata->temp_mode[index] =\n\t    w83793_read_value(client, W83793_REG_TEMP_MODE[index]);\n\tdata->temp_mode[index] &= ~(mask << shift);\n\tdata->temp_mode[index] |= val << shift;\n\tw83793_write_value(client, W83793_REG_TEMP_MODE[index],\n\t\t\t\t\t\t\tdata->temp_mode[index]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n#define SETUP_PWM_DEFAULT\t\t0\n#define SETUP_PWM_UPTIME\t\t1\t \n#define SETUP_PWM_DOWNTIME\t\t2\t \n#define SETUP_TEMP_CRITICAL\t\t3\nstatic ssize_t\nshow_sf_setup(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tstruct w83793_data *data = w83793_update_device(dev);\n\tu32 val = 0;\n\n\tif (nr == SETUP_PWM_DEFAULT)\n\t\tval = (data->pwm_default & 0x3f) << 2;\n\telse if (nr == SETUP_PWM_UPTIME)\n\t\tval = TIME_FROM_REG(data->pwm_uptime);\n\telse if (nr == SETUP_PWM_DOWNTIME)\n\t\tval = TIME_FROM_REG(data->pwm_downtime);\n\telse if (nr == SETUP_TEMP_CRITICAL)\n\t\tval = TEMP_FROM_REG(data->temp_critical & 0x7f);\n\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t\nstore_sf_setup(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tif (nr == SETUP_PWM_DEFAULT) {\n\t\tdata->pwm_default =\n\t\t    w83793_read_value(client, W83793_REG_PWM_DEFAULT) & 0xc0;\n\t\tdata->pwm_default |= clamp_val(val, 0, 0xff) >> 2;\n\t\tw83793_write_value(client, W83793_REG_PWM_DEFAULT,\n\t\t\t\t\t\t\tdata->pwm_default);\n\t} else if (nr == SETUP_PWM_UPTIME) {\n\t\tdata->pwm_uptime = TIME_TO_REG(val);\n\t\tdata->pwm_uptime += data->pwm_uptime == 0 ? 1 : 0;\n\t\tw83793_write_value(client, W83793_REG_PWM_UPTIME,\n\t\t\t\t\t\t\tdata->pwm_uptime);\n\t} else if (nr == SETUP_PWM_DOWNTIME) {\n\t\tdata->pwm_downtime = TIME_TO_REG(val);\n\t\tdata->pwm_downtime += data->pwm_downtime == 0 ? 1 : 0;\n\t\tw83793_write_value(client, W83793_REG_PWM_DOWNTIME,\n\t\t\t\t\t\t\tdata->pwm_downtime);\n\t} else {\t\t \n\t\tdata->temp_critical =\n\t\t    w83793_read_value(client, W83793_REG_TEMP_CRITICAL) & 0x80;\n\t\tdata->temp_critical |= TEMP_TO_REG(val, 0, 0x7f);\n\t\tw83793_write_value(client, W83793_REG_TEMP_CRITICAL,\n\t\t\t\t\t\t\tdata->temp_critical);\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \n\n#define TEMP_FAN_MAP\t\t\t0\n#define TEMP_PWM_ENABLE\t\t\t1\n#define TEMP_CRUISE\t\t\t2\n#define TEMP_TOLERANCE\t\t\t3\nstatic ssize_t\nshow_sf_ctrl(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83793_data *data = w83793_update_device(dev);\n\tu32 val;\n\n\tif (nr == TEMP_FAN_MAP) {\n\t\tval = data->temp_fan_map[index];\n\t} else if (nr == TEMP_PWM_ENABLE) {\n\t\t \n\t\tval = ((data->pwm_enable >> index) & 0x01) + 2;\n\t} else if (nr == TEMP_CRUISE) {\n\t\tval = TEMP_FROM_REG(data->temp_cruise[index] & 0x7f);\n\t} else {\t\t \n\t\tval = data->tolerance[index >> 1] >> ((index & 0x01) ? 4 : 0);\n\t\tval = TEMP_FROM_REG(val & 0x0f);\n\t}\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t\nstore_sf_ctrl(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tif (nr == TEMP_FAN_MAP) {\n\t\tval = clamp_val(val, 0, 255);\n\t\tw83793_write_value(client, W83793_REG_TEMP_FAN_MAP(index), val);\n\t\tdata->temp_fan_map[index] = val;\n\t} else if (nr == TEMP_PWM_ENABLE) {\n\t\tif (val == 2 || val == 3) {\n\t\t\tdata->pwm_enable =\n\t\t\t    w83793_read_value(client, W83793_REG_PWM_ENABLE);\n\t\t\tif (val - 2)\n\t\t\t\tdata->pwm_enable |= 1 << index;\n\t\t\telse\n\t\t\t\tdata->pwm_enable &= ~(1 << index);\n\t\t\tw83793_write_value(client, W83793_REG_PWM_ENABLE,\n\t\t\t\t\t\t\tdata->pwm_enable);\n\t\t} else {\n\t\t\tmutex_unlock(&data->update_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (nr == TEMP_CRUISE) {\n\t\tdata->temp_cruise[index] =\n\t\t    w83793_read_value(client, W83793_REG_TEMP_CRUISE(index));\n\t\tdata->temp_cruise[index] &= 0x80;\n\t\tdata->temp_cruise[index] |= TEMP_TO_REG(val, 0, 0x7f);\n\n\t\tw83793_write_value(client, W83793_REG_TEMP_CRUISE(index),\n\t\t\t\t\t\tdata->temp_cruise[index]);\n\t} else {\t\t \n\t\tint i = index >> 1;\n\t\tu8 shift = (index & 0x01) ? 4 : 0;\n\t\tdata->tolerance[i] =\n\t\t    w83793_read_value(client, W83793_REG_TEMP_TOL(i));\n\n\t\tdata->tolerance[i] &= ~(0x0f << shift);\n\t\tdata->tolerance[i] |= TEMP_TO_REG(val, 0, 0x0f) << shift;\n\t\tw83793_write_value(client, W83793_REG_TEMP_TOL(i),\n\t\t\t\t\t\t\tdata->tolerance[i]);\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\nshow_sf2_pwm(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83793_data *data = w83793_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", (data->sf2_pwm[index][nr] & 0x3f) << 2);\n}\n\nstatic ssize_t\nstore_sf2_pwm(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tval = clamp_val(val, 0, 0xff) >> 2;\n\n\tmutex_lock(&data->update_lock);\n\tdata->sf2_pwm[index][nr] =\n\t    w83793_read_value(client, W83793_REG_SF2_PWM(index, nr)) & 0xc0;\n\tdata->sf2_pwm[index][nr] |= val;\n\tw83793_write_value(client, W83793_REG_SF2_PWM(index, nr),\n\t\t\t\t\t\tdata->sf2_pwm[index][nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\nshow_sf2_temp(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83793_data *data = w83793_update_device(dev);\n\n\treturn sprintf(buf, \"%ld\\n\",\n\t\t       TEMP_FROM_REG(data->sf2_temp[index][nr] & 0x7f));\n}\n\nstatic ssize_t\nstore_sf2_temp(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tval = TEMP_TO_REG(val, 0, 0x7f);\n\n\tmutex_lock(&data->update_lock);\n\tdata->sf2_temp[index][nr] =\n\t    w83793_read_value(client, W83793_REG_SF2_TEMP(index, nr)) & 0x80;\n\tdata->sf2_temp[index][nr] |= val;\n\tw83793_write_value(client, W83793_REG_SF2_TEMP(index, nr),\n\t\t\t\t\t     data->sf2_temp[index][nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \nstatic ssize_t\nshow_in(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83793_data *data = w83793_update_device(dev);\n\tu16 val = data->in[index][nr];\n\n\tif (index < 3) {\n\t\tval <<= 2;\n\t\tval += (data->in_low_bits[nr] >> (index * 2)) & 0x3;\n\t}\n\t \n\tval = val * scale_in[index] + scale_in_add[index];\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t\nstore_in(struct device *dev, struct device_attribute *attr,\n\t const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tval = (val + scale_in[index] / 2) / scale_in[index];\n\n\tmutex_lock(&data->update_lock);\n\tif (index > 2) {\n\t\t \n\t\tif (nr == 1 || nr == 2)\n\t\t\tval -= scale_in_add[index] / scale_in[index];\n\t\tval = clamp_val(val, 0, 255);\n\t} else {\n\t\tval = clamp_val(val, 0, 0x3FF);\n\t\tdata->in_low_bits[nr] =\n\t\t    w83793_read_value(client, W83793_REG_IN_LOW_BITS[nr]);\n\t\tdata->in_low_bits[nr] &= ~(0x03 << (2 * index));\n\t\tdata->in_low_bits[nr] |= (val & 0x03) << (2 * index);\n\t\tw83793_write_value(client, W83793_REG_IN_LOW_BITS[nr],\n\t\t\t\t\t\t     data->in_low_bits[nr]);\n\t\tval >>= 2;\n\t}\n\tdata->in[index][nr] = val;\n\tw83793_write_value(client, W83793_REG_IN[index][nr],\n\t\t\t\t\t\t\tdata->in[index][nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n#define NOT_USED\t\t\t-1\n\n#define SENSOR_ATTR_IN(index)\t\t\t\t\t\t\\\n\tSENSOR_ATTR_2(in##index##_input, S_IRUGO, show_in, NULL,\t\\\n\t\tIN_READ, index),\t\t\t\t\t\\\n\tSENSOR_ATTR_2(in##index##_max, S_IRUGO | S_IWUSR, show_in,\t\\\n\t\tstore_in, IN_MAX, index),\t\t\t\t\\\n\tSENSOR_ATTR_2(in##index##_min, S_IRUGO | S_IWUSR, show_in,\t\\\n\t\tstore_in, IN_LOW, index),\t\t\t\t\\\n\tSENSOR_ATTR_2(in##index##_alarm, S_IRUGO, show_alarm_beep,\t\\\n\t\tNULL, ALARM_STATUS, index + ((index > 2) ? 1 : 0)),\t\\\n\tSENSOR_ATTR_2(in##index##_beep, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_alarm_beep, store_beep, BEEP_ENABLE,\t\t\\\n\t\tindex + ((index > 2) ? 1 : 0))\n\n#define SENSOR_ATTR_FAN(index)\t\t\t\t\t\t\\\n\tSENSOR_ATTR_2(fan##index##_alarm, S_IRUGO, show_alarm_beep,\t\\\n\t\tNULL, ALARM_STATUS, index + 17),\t\t\t\\\n\tSENSOR_ATTR_2(fan##index##_beep, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_alarm_beep, store_beep, BEEP_ENABLE, index + 17),\t\\\n\tSENSOR_ATTR_2(fan##index##_input, S_IRUGO, show_fan,\t\t\\\n\t\tNULL, FAN_INPUT, index - 1),\t\t\t\t\\\n\tSENSOR_ATTR_2(fan##index##_min, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_fan, store_fan_min, FAN_MIN, index - 1)\n\n#define SENSOR_ATTR_PWM(index)\t\t\t\t\t\t\\\n\tSENSOR_ATTR_2(pwm##index, S_IWUSR | S_IRUGO, show_pwm,\t\t\\\n\t\tstore_pwm, PWM_DUTY, index - 1),\t\t\t\\\n\tSENSOR_ATTR_2(pwm##index##_nonstop, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_pwm, store_pwm, PWM_NONSTOP, index - 1),\t\t\\\n\tSENSOR_ATTR_2(pwm##index##_start, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_pwm, store_pwm, PWM_START, index - 1),\t\t\\\n\tSENSOR_ATTR_2(pwm##index##_stop_time, S_IWUSR | S_IRUGO,\t\\\n\t\tshow_pwm, store_pwm, PWM_STOP_TIME, index - 1)\n\n#define SENSOR_ATTR_TEMP(index)\t\t\t\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_type, S_IRUGO | S_IWUSR,\t\t\\\n\t\tshow_temp_mode, store_temp_mode, NOT_USED, index - 1),\t\\\n\tSENSOR_ATTR_2(temp##index##_input, S_IRUGO, show_temp,\t\t\\\n\t\tNULL, TEMP_READ, index - 1),\t\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_max, S_IRUGO | S_IWUSR, show_temp,\t\\\n\t\tstore_temp, TEMP_CRIT, index - 1),\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_max_hyst, S_IRUGO | S_IWUSR,\t\\\n\t\tshow_temp, store_temp, TEMP_CRIT_HYST, index - 1),\t\\\n\tSENSOR_ATTR_2(temp##index##_warn, S_IRUGO | S_IWUSR, show_temp,\t\\\n\t\tstore_temp, TEMP_WARN, index - 1),\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_warn_hyst, S_IRUGO | S_IWUSR,\t\\\n\t\tshow_temp, store_temp, TEMP_WARN_HYST, index - 1),\t\\\n\tSENSOR_ATTR_2(temp##index##_alarm, S_IRUGO,\t\t\t\\\n\t\tshow_alarm_beep, NULL, ALARM_STATUS, index + 11),\t\\\n\tSENSOR_ATTR_2(temp##index##_beep, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_alarm_beep, store_beep, BEEP_ENABLE, index + 11),\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_channels_pwm,\t\t\t\\\n\t\tS_IRUGO | S_IWUSR, show_sf_ctrl, store_sf_ctrl,\t\t\\\n\t\tTEMP_FAN_MAP, index - 1),\t\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_pwm_enable, S_IWUSR | S_IRUGO,\t\\\n\t\tshow_sf_ctrl, store_sf_ctrl, TEMP_PWM_ENABLE,\t\t\\\n\t\tindex - 1),\t\t\t\t\t\t\\\n\tSENSOR_ATTR_2(thermal_cruise##index, S_IRUGO | S_IWUSR,\t\t\\\n\t\tshow_sf_ctrl, store_sf_ctrl, TEMP_CRUISE, index - 1),\t\\\n\tSENSOR_ATTR_2(tolerance##index, S_IRUGO | S_IWUSR, show_sf_ctrl,\\\n\t\tstore_sf_ctrl, TEMP_TOLERANCE, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point1_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf2_pwm, store_sf2_pwm, 0, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point2_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf2_pwm, store_sf2_pwm, 1, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point3_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf2_pwm, store_sf2_pwm, 2, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point4_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf2_pwm, store_sf2_pwm, 3, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point5_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf2_pwm, store_sf2_pwm, 4, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point6_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf2_pwm, store_sf2_pwm, 5, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point7_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf2_pwm, store_sf2_pwm, 6, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point1_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf2_temp, store_sf2_temp, 0, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point2_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf2_temp, store_sf2_temp, 1, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point3_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf2_temp, store_sf2_temp, 2, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point4_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf2_temp, store_sf2_temp, 3, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point5_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf2_temp, store_sf2_temp, 4, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point6_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf2_temp, store_sf2_temp, 5, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point7_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf2_temp, store_sf2_temp, 6, index - 1)\n\nstatic struct sensor_device_attribute_2 w83793_sensor_attr_2[] = {\n\tSENSOR_ATTR_IN(0),\n\tSENSOR_ATTR_IN(1),\n\tSENSOR_ATTR_IN(2),\n\tSENSOR_ATTR_IN(3),\n\tSENSOR_ATTR_IN(4),\n\tSENSOR_ATTR_IN(5),\n\tSENSOR_ATTR_IN(6),\n\tSENSOR_ATTR_IN(7),\n\tSENSOR_ATTR_IN(8),\n\tSENSOR_ATTR_IN(9),\n\tSENSOR_ATTR_FAN(1),\n\tSENSOR_ATTR_FAN(2),\n\tSENSOR_ATTR_FAN(3),\n\tSENSOR_ATTR_FAN(4),\n\tSENSOR_ATTR_FAN(5),\n\tSENSOR_ATTR_PWM(1),\n\tSENSOR_ATTR_PWM(2),\n\tSENSOR_ATTR_PWM(3),\n};\n\nstatic struct sensor_device_attribute_2 w83793_temp[] = {\n\tSENSOR_ATTR_TEMP(1),\n\tSENSOR_ATTR_TEMP(2),\n\tSENSOR_ATTR_TEMP(3),\n\tSENSOR_ATTR_TEMP(4),\n\tSENSOR_ATTR_TEMP(5),\n\tSENSOR_ATTR_TEMP(6),\n};\n\n \nstatic struct sensor_device_attribute_2 w83793_left_fan[] = {\n\tSENSOR_ATTR_FAN(6),\n\tSENSOR_ATTR_FAN(7),\n\tSENSOR_ATTR_FAN(8),\n\tSENSOR_ATTR_FAN(9),\n\tSENSOR_ATTR_FAN(10),\n\tSENSOR_ATTR_FAN(11),\n\tSENSOR_ATTR_FAN(12),\n};\n\n \nstatic struct sensor_device_attribute_2 w83793_left_pwm[] = {\n\tSENSOR_ATTR_PWM(4),\n\tSENSOR_ATTR_PWM(5),\n\tSENSOR_ATTR_PWM(6),\n\tSENSOR_ATTR_PWM(7),\n\tSENSOR_ATTR_PWM(8),\n};\n\nstatic struct sensor_device_attribute_2 w83793_vid[] = {\n\tSENSOR_ATTR_2(cpu0_vid, S_IRUGO, show_vid, NULL, NOT_USED, 0),\n\tSENSOR_ATTR_2(cpu1_vid, S_IRUGO, show_vid, NULL, NOT_USED, 1),\n};\nstatic DEVICE_ATTR_RW(vrm);\n\nstatic struct sensor_device_attribute_2 sda_single_files[] = {\n\tSENSOR_ATTR_2(intrusion0_alarm, S_IWUSR | S_IRUGO, show_alarm_beep,\n\t\t      store_chassis_clear, ALARM_STATUS, 30),\n\tSENSOR_ATTR_2(beep_enable, S_IWUSR | S_IRUGO, show_beep_enable,\n\t\t      store_beep_enable, NOT_USED, NOT_USED),\n\tSENSOR_ATTR_2(pwm_default, S_IWUSR | S_IRUGO, show_sf_setup,\n\t\t      store_sf_setup, SETUP_PWM_DEFAULT, NOT_USED),\n\tSENSOR_ATTR_2(pwm_uptime, S_IWUSR | S_IRUGO, show_sf_setup,\n\t\t      store_sf_setup, SETUP_PWM_UPTIME, NOT_USED),\n\tSENSOR_ATTR_2(pwm_downtime, S_IWUSR | S_IRUGO, show_sf_setup,\n\t\t      store_sf_setup, SETUP_PWM_DOWNTIME, NOT_USED),\n\tSENSOR_ATTR_2(temp_critical, S_IWUSR | S_IRUGO, show_sf_setup,\n\t\t      store_sf_setup, SETUP_TEMP_CRITICAL, NOT_USED),\n};\n\nstatic void w83793_init_client(struct i2c_client *client)\n{\n\tif (reset)\n\t\tw83793_write_value(client, W83793_REG_CONFIG, 0x80);\n\n\t \n\tw83793_write_value(client, W83793_REG_CONFIG,\n\t\t\t   w83793_read_value(client, W83793_REG_CONFIG) | 0x01);\n}\n\n \n\nstatic int watchdog_set_timeout(struct w83793_data *data, int timeout)\n{\n\tunsigned int mtimeout;\n\tint ret;\n\n\tmtimeout = DIV_ROUND_UP(timeout, 60);\n\n\tif (mtimeout > 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->watchdog_lock);\n\tif (!data->client) {\n\t\tret = -ENODEV;\n\t\tgoto leave;\n\t}\n\n\tdata->watchdog_timeout = mtimeout;\n\n\t \n\tw83793_write_value(data->client, W83793_REG_WDT_TIMEOUT,\n\t\t\t   data->watchdog_timeout);\n\n\tret = mtimeout * 60;\n\nleave:\n\tmutex_unlock(&data->watchdog_lock);\n\treturn ret;\n}\n\nstatic int watchdog_get_timeout(struct w83793_data *data)\n{\n\tint timeout;\n\n\tmutex_lock(&data->watchdog_lock);\n\ttimeout = data->watchdog_timeout * 60;\n\tmutex_unlock(&data->watchdog_lock);\n\n\treturn timeout;\n}\n\nstatic int watchdog_trigger(struct w83793_data *data)\n{\n\tint ret = 0;\n\n\tmutex_lock(&data->watchdog_lock);\n\tif (!data->client) {\n\t\tret = -ENODEV;\n\t\tgoto leave;\n\t}\n\n\t \n\tw83793_write_value(data->client, W83793_REG_WDT_TIMEOUT,\n\t\t\t   data->watchdog_timeout);\n\nleave:\n\tmutex_unlock(&data->watchdog_lock);\n\treturn ret;\n}\n\nstatic int watchdog_enable(struct w83793_data *data)\n{\n\tint ret = 0;\n\n\tmutex_lock(&data->watchdog_lock);\n\tif (!data->client) {\n\t\tret = -ENODEV;\n\t\tgoto leave;\n\t}\n\n\t \n\tw83793_write_value(data->client, W83793_REG_WDT_TIMEOUT,\n\t\t\t   data->watchdog_timeout);\n\n\t \n\tw83793_write_value(data->client, W83793_REG_WDT_LOCK, 0x55);\n\nleave:\n\tmutex_unlock(&data->watchdog_lock);\n\treturn ret;\n}\n\nstatic int watchdog_disable(struct w83793_data *data)\n{\n\tint ret = 0;\n\n\tmutex_lock(&data->watchdog_lock);\n\tif (!data->client) {\n\t\tret = -ENODEV;\n\t\tgoto leave;\n\t}\n\n\t \n\tw83793_write_value(data->client, W83793_REG_WDT_LOCK, 0xAA);\n\nleave:\n\tmutex_unlock(&data->watchdog_lock);\n\treturn ret;\n}\n\nstatic int watchdog_open(struct inode *inode, struct file *filp)\n{\n\tstruct w83793_data *pos, *data = NULL;\n\tint watchdog_is_open;\n\n\t \n\tif (!mutex_trylock(&watchdog_data_mutex))\n\t\treturn -ERESTARTSYS;\n\tlist_for_each_entry(pos, &watchdog_data_list, list) {\n\t\tif (pos->watchdog_miscdev.minor == iminor(inode)) {\n\t\t\tdata = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\twatchdog_is_open = test_and_set_bit(0, &data->watchdog_is_open);\n\n\t \n\tif (!watchdog_is_open)\n\t\tkref_get(&data->kref);\n\n\tmutex_unlock(&watchdog_data_mutex);\n\n\t \n\tif (watchdog_is_open)\n\t\treturn -EBUSY;\n\n\t \n\twatchdog_enable(data);\n\n\t \n\tfilp->private_data = data;\n\n\treturn stream_open(inode, filp);\n}\n\nstatic int watchdog_close(struct inode *inode, struct file *filp)\n{\n\tstruct w83793_data *data = filp->private_data;\n\n\tif (data->watchdog_expect_close) {\n\t\twatchdog_disable(data);\n\t\tdata->watchdog_expect_close = 0;\n\t} else {\n\t\twatchdog_trigger(data);\n\t\tdev_crit(&data->client->dev,\n\t\t\t\"unexpected close, not stopping watchdog!\\n\");\n\t}\n\n\tclear_bit(0, &data->watchdog_is_open);\n\n\t \n\tmutex_lock(&watchdog_data_mutex);\n\tkref_put(&data->kref, w83793_release_resources);\n\tmutex_unlock(&watchdog_data_mutex);\n\n\treturn 0;\n}\n\nstatic ssize_t watchdog_write(struct file *filp, const char __user *buf,\n\tsize_t count, loff_t *offset)\n{\n\tssize_t ret;\n\tstruct w83793_data *data = filp->private_data;\n\n\tif (count) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\tdata->watchdog_expect_close = 0;\n\n\t\t\tfor (i = 0; i != count; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, buf + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\tdata->watchdog_expect_close = 1;\n\t\t\t}\n\t\t}\n\t\tret = watchdog_trigger(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn count;\n}\n\nstatic long watchdog_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tstruct watchdog_info ident = {\n\t\t.options = WDIOF_KEEPALIVEPING |\n\t\t\t   WDIOF_SETTIMEOUT |\n\t\t\t   WDIOF_CARDRESET,\n\t\t.identity = \"w83793 watchdog\"\n\t};\n\n\tint val, ret = 0;\n\tstruct w83793_data *data = filp->private_data;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (!nowayout)\n\t\t\tident.options |= WDIOF_MAGICCLOSE;\n\t\tif (copy_to_user((void __user *)arg, &ident, sizeof(ident)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase WDIOC_GETSTATUS:\n\t\tval = data->watchdog_caused_reboot ? WDIOF_CARDRESET : 0;\n\t\tret = put_user(val, (int __user *)arg);\n\t\tbreak;\n\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tret = put_user(0, (int __user *)arg);\n\t\tbreak;\n\n\tcase WDIOC_KEEPALIVE:\n\t\tret = watchdog_trigger(data);\n\t\tbreak;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\tval = watchdog_get_timeout(data);\n\t\tret = put_user(val, (int __user *)arg);\n\t\tbreak;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(val, (int __user *)arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = watchdog_set_timeout(data, val);\n\t\tif (ret > 0)\n\t\t\tret = put_user(ret, (int __user *)arg);\n\t\tbreak;\n\n\tcase WDIOC_SETOPTIONS:\n\t\tif (get_user(val, (int __user *)arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & WDIOS_DISABLECARD)\n\t\t\tret = watchdog_disable(data);\n\t\telse if (val & WDIOS_ENABLECARD)\n\t\t\tret = watchdog_enable(data);\n\t\telse\n\t\t\tret = -EINVAL;\n\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations watchdog_fops = {\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n\t.open = watchdog_open,\n\t.release = watchdog_close,\n\t.write = watchdog_write,\n\t.unlocked_ioctl = watchdog_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\n \n\nstatic int watchdog_notify_sys(struct notifier_block *this, unsigned long code,\n\t\t\t       void *unused)\n{\n\tstruct w83793_data *data = NULL;\n\n\tif (code == SYS_DOWN || code == SYS_HALT) {\n\n\t\t \n\t\tmutex_lock(&watchdog_data_mutex);\n\t\tlist_for_each_entry(data, &watchdog_data_list, list) {\n\t\t\tif (data->watchdog_miscdev.minor)\n\t\t\t\twatchdog_disable(data);\n\t\t}\n\t\tmutex_unlock(&watchdog_data_mutex);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \n\nstatic struct notifier_block watchdog_notifier = {\n\t.notifier_call = watchdog_notify_sys,\n};\n\n \n\nstatic void w83793_remove(struct i2c_client *client)\n{\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tstruct device *dev = &client->dev;\n\tint i, tmp;\n\n\t \n\tif (data->watchdog_miscdev.minor) {\n\t\tmisc_deregister(&data->watchdog_miscdev);\n\n\t\tif (data->watchdog_is_open) {\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t\"i2c client detached with watchdog open! \"\n\t\t\t\t\"Stopping watchdog.\\n\");\n\t\t\twatchdog_disable(data);\n\t\t}\n\n\t\tmutex_lock(&watchdog_data_mutex);\n\t\tlist_del(&data->list);\n\t\tmutex_unlock(&watchdog_data_mutex);\n\n\t\t \n\t\tmutex_lock(&data->watchdog_lock);\n\t\tdata->client = NULL;\n\t\tmutex_unlock(&data->watchdog_lock);\n\t}\n\n\t \n\ttmp = w83793_read_value(client, W83793_REG_CONFIG);\n\tw83793_write_value(client, W83793_REG_CONFIG, tmp & ~0x04);\n\n\tunregister_reboot_notifier(&watchdog_notifier);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\n\tfor (i = 0; i < ARRAY_SIZE(w83793_sensor_attr_2); i++)\n\t\tdevice_remove_file(dev,\n\t\t\t\t   &w83793_sensor_attr_2[i].dev_attr);\n\n\tfor (i = 0; i < ARRAY_SIZE(sda_single_files); i++)\n\t\tdevice_remove_file(dev, &sda_single_files[i].dev_attr);\n\n\tfor (i = 0; i < ARRAY_SIZE(w83793_vid); i++)\n\t\tdevice_remove_file(dev, &w83793_vid[i].dev_attr);\n\tdevice_remove_file(dev, &dev_attr_vrm);\n\n\tfor (i = 0; i < ARRAY_SIZE(w83793_left_fan); i++)\n\t\tdevice_remove_file(dev, &w83793_left_fan[i].dev_attr);\n\n\tfor (i = 0; i < ARRAY_SIZE(w83793_left_pwm); i++)\n\t\tdevice_remove_file(dev, &w83793_left_pwm[i].dev_attr);\n\n\tfor (i = 0; i < ARRAY_SIZE(w83793_temp); i++)\n\t\tdevice_remove_file(dev, &w83793_temp[i].dev_attr);\n\n\t \n\tmutex_lock(&watchdog_data_mutex);\n\tkref_put(&data->kref, w83793_release_resources);\n\tmutex_unlock(&watchdog_data_mutex);\n}\n\nstatic int\nw83793_detect_subclients(struct i2c_client *client)\n{\n\tint i, id;\n\tint address = client->addr;\n\tu8 tmp;\n\tstruct i2c_adapter *adapter = client->adapter;\n\n\tid = i2c_adapter_id(adapter);\n\tif (force_subclients[0] == id && force_subclients[1] == address) {\n\t\tfor (i = 2; i <= 3; i++) {\n\t\t\tif (force_subclients[i] < 0x48\n\t\t\t    || force_subclients[i] > 0x4f) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"invalid subclient \"\n\t\t\t\t\t\"address %d; must be 0x48-0x4f\\n\",\n\t\t\t\t\tforce_subclients[i]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tw83793_write_value(client, W83793_REG_I2C_SUBADDR,\n\t\t\t\t   (force_subclients[2] & 0x07) |\n\t\t\t\t   ((force_subclients[3] & 0x07) << 4));\n\t}\n\n\ttmp = w83793_read_value(client, W83793_REG_I2C_SUBADDR);\n\n\tif (!(tmp & 0x88) && (tmp & 0x7) == ((tmp >> 4) & 0x7)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"duplicate addresses 0x%x, use force_subclient\\n\", 0x48 + (tmp & 0x7));\n\t\treturn -ENODEV;\n\t}\n\n\tif (!(tmp & 0x08))\n\t\tdevm_i2c_new_dummy_device(&client->dev, adapter, 0x48 + (tmp & 0x7));\n\n\tif (!(tmp & 0x80))\n\t\tdevm_i2c_new_dummy_device(&client->dev, adapter, 0x48 + ((tmp >> 4) & 0x7));\n\n\treturn 0;\n}\n\n \nstatic int w83793_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info)\n{\n\tu8 tmp, bank, chip_id;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tunsigned short address = client->addr;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tbank = i2c_smbus_read_byte_data(client, W83793_REG_BANKSEL);\n\n\ttmp = bank & 0x80 ? 0x5c : 0xa3;\n\t \n\tif (tmp != i2c_smbus_read_byte_data(client, W83793_REG_VENDORID)) {\n\t\tpr_debug(\"w83793: Detection failed at check vendor id\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif ((bank & 0x07) == 0\n\t && i2c_smbus_read_byte_data(client, W83793_REG_I2C_ADDR) !=\n\t    (address << 1)) {\n\t\tpr_debug(\"w83793: Detection failed at check i2c addr\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tchip_id = i2c_smbus_read_byte_data(client, W83793_REG_CHIPID);\n\tif (chip_id != 0x7b)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"w83793\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int w83793_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstatic const int watchdog_minors[] = {\n\t\tWATCHDOG_MINOR, 212, 213, 214, 215\n\t};\n\tstruct w83793_data *data;\n\tint i, tmp, val, err;\n\tint files_fan = ARRAY_SIZE(w83793_left_fan) / 7;\n\tint files_pwm = ARRAY_SIZE(w83793_left_pwm) / 5;\n\tint files_temp = ARRAY_SIZE(w83793_temp) / 6;\n\n\tdata = kzalloc(sizeof(struct w83793_data), GFP_KERNEL);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\ti2c_set_clientdata(client, data);\n\tdata->bank = i2c_smbus_read_byte_data(client, W83793_REG_BANKSEL);\n\tmutex_init(&data->update_lock);\n\tmutex_init(&data->watchdog_lock);\n\tINIT_LIST_HEAD(&data->list);\n\tkref_init(&data->kref);\n\n\t \n\tdata->client = client;\n\n\terr = w83793_detect_subclients(client);\n\tif (err)\n\t\tgoto free_mem;\n\n\t \n\tw83793_init_client(client);\n\n\t \n\tdata->has_fan = 0x1f;\n\tdata->has_pwm = 0x07;\n\ttmp = w83793_read_value(client, W83793_REG_MFC);\n\tval = w83793_read_value(client, W83793_REG_FANIN_CTRL);\n\n\t \n\tif (tmp & 0x80) {\n\t\tdata->has_vid |= 0x2;\t \n\t} else {\n\t\tdata->has_pwm |= 0x18;\t \n\t\tif (val & 0x01) {\t \n\t\t\tdata->has_fan |= 0x20;\n\t\t\tdata->has_pwm |= 0x20;\n\t\t}\n\t\tif (val & 0x02) {\t \n\t\t\tdata->has_fan |= 0x40;\n\t\t\tdata->has_pwm |= 0x40;\n\t\t}\n\t\tif (!(tmp & 0x40) && (val & 0x04)) {\t \n\t\t\tdata->has_fan |= 0x80;\n\t\t\tdata->has_pwm |= 0x80;\n\t\t}\n\t}\n\n\t \n\tif (!(tmp & 0x29))\n\t\tdata->has_vid |= 0x1;\t \n\tif (0x08 == (tmp & 0x0c)) {\n\t\tif (val & 0x08)\t \n\t\t\tdata->has_fan |= 0x100;\n\t\tif (val & 0x10)\t \n\t\t\tdata->has_fan |= 0x200;\n\t}\n\tif (0x20 == (tmp & 0x30)) {\n\t\tif (val & 0x20)\t \n\t\t\tdata->has_fan |= 0x400;\n\t\tif (val & 0x40)\t \n\t\t\tdata->has_fan |= 0x800;\n\t}\n\n\tif ((tmp & 0x01) && (val & 0x04)) {\t \n\t\tdata->has_fan |= 0x80;\n\t\tdata->has_pwm |= 0x80;\n\t}\n\n\ttmp = w83793_read_value(client, W83793_REG_FANIN_SEL);\n\tif ((tmp & 0x01) && (val & 0x08)) {\t \n\t\tdata->has_fan |= 0x100;\n\t}\n\tif ((tmp & 0x02) && (val & 0x10)) {\t \n\t\tdata->has_fan |= 0x200;\n\t}\n\tif ((tmp & 0x04) && (val & 0x20)) {\t \n\t\tdata->has_fan |= 0x400;\n\t}\n\tif ((tmp & 0x08) && (val & 0x40)) {\t \n\t\tdata->has_fan |= 0x800;\n\t}\n\n\t \n\ttmp = w83793_read_value(client, W83793_REG_TEMP_MODE[0]);\n\tif (tmp & 0x01)\n\t\tdata->has_temp |= 0x01;\n\tif (tmp & 0x04)\n\t\tdata->has_temp |= 0x02;\n\tif (tmp & 0x10)\n\t\tdata->has_temp |= 0x04;\n\tif (tmp & 0x40)\n\t\tdata->has_temp |= 0x08;\n\n\ttmp = w83793_read_value(client, W83793_REG_TEMP_MODE[1]);\n\tif (tmp & 0x01)\n\t\tdata->has_temp |= 0x10;\n\tif (tmp & 0x02)\n\t\tdata->has_temp |= 0x20;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(w83793_sensor_attr_2); i++) {\n\t\terr = device_create_file(dev,\n\t\t\t\t\t &w83793_sensor_attr_2[i].dev_attr);\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(w83793_vid); i++) {\n\t\tif (!(data->has_vid & (1 << i)))\n\t\t\tcontinue;\n\t\terr = device_create_file(dev, &w83793_vid[i].dev_attr);\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\t}\n\tif (data->has_vid) {\n\t\tdata->vrm = vid_which_vrm();\n\t\terr = device_create_file(dev, &dev_attr_vrm);\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sda_single_files); i++) {\n\t\terr = device_create_file(dev, &sda_single_files[i].dev_attr);\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tint j;\n\t\tif (!(data->has_temp & (1 << i)))\n\t\t\tcontinue;\n\t\tfor (j = 0; j < files_temp; j++) {\n\t\t\terr = device_create_file(dev,\n\t\t\t\t\t\t&w83793_temp[(i) * files_temp\n\t\t\t\t\t\t\t\t+ j].dev_attr);\n\t\t\tif (err)\n\t\t\t\tgoto exit_remove;\n\t\t}\n\t}\n\n\tfor (i = 5; i < 12; i++) {\n\t\tint j;\n\t\tif (!(data->has_fan & (1 << i)))\n\t\t\tcontinue;\n\t\tfor (j = 0; j < files_fan; j++) {\n\t\t\terr = device_create_file(dev,\n\t\t\t\t\t   &w83793_left_fan[(i - 5) * files_fan\n\t\t\t\t\t\t\t\t+ j].dev_attr);\n\t\t\tif (err)\n\t\t\t\tgoto exit_remove;\n\t\t}\n\t}\n\n\tfor (i = 3; i < 8; i++) {\n\t\tint j;\n\t\tif (!(data->has_pwm & (1 << i)))\n\t\t\tcontinue;\n\t\tfor (j = 0; j < files_pwm; j++) {\n\t\t\terr = device_create_file(dev,\n\t\t\t\t\t   &w83793_left_pwm[(i - 3) * files_pwm\n\t\t\t\t\t\t\t\t+ j].dev_attr);\n\t\t\tif (err)\n\t\t\t\tgoto exit_remove;\n\t\t}\n\t}\n\n\tdata->hwmon_dev = hwmon_device_register(dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto exit_remove;\n\t}\n\n\t \n\n\t \n\terr = register_reboot_notifier(&watchdog_notifier);\n\tif (err != 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"cannot register reboot notifier (err=%d)\\n\", err);\n\t\tgoto exit_devunreg;\n\t}\n\n\t \n\ttmp = w83793_read_value(client, W83793_REG_CONFIG);\n\tw83793_write_value(client, W83793_REG_CONFIG, tmp | 0x04);\n\n\t \n\tdata->watchdog_timeout = timeout;\n\n\t \n\tdata->watchdog_caused_reboot =\n\t  w83793_read_value(data->client, W83793_REG_WDT_STATUS) & 0x01;\n\n\t \n\twatchdog_disable(data);\n\n\t \n\tmutex_lock(&watchdog_data_mutex);\n\tfor (i = 0; i < ARRAY_SIZE(watchdog_minors); i++) {\n\t\t \n\t\tsnprintf(data->watchdog_name, sizeof(data->watchdog_name),\n\t\t\t\"watchdog%c\", (i == 0) ? '\\0' : ('0' + i));\n\t\tdata->watchdog_miscdev.name = data->watchdog_name;\n\t\tdata->watchdog_miscdev.fops = &watchdog_fops;\n\t\tdata->watchdog_miscdev.minor = watchdog_minors[i];\n\n\t\terr = misc_register(&data->watchdog_miscdev);\n\t\tif (err == -EBUSY)\n\t\t\tcontinue;\n\t\tif (err) {\n\t\t\tdata->watchdog_miscdev.minor = 0;\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Registering watchdog chardev: %d\\n\", err);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&data->list, &watchdog_data_list);\n\n\t\tdev_info(&client->dev,\n\t\t\t\"Registered watchdog chardev major 10, minor: %d\\n\",\n\t\t\twatchdog_minors[i]);\n\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(watchdog_minors)) {\n\t\tdata->watchdog_miscdev.minor = 0;\n\t\tdev_warn(&client->dev,\n\t\t\t \"Couldn't register watchdog chardev (due to no free minor)\\n\");\n\t}\n\n\tmutex_unlock(&watchdog_data_mutex);\n\n\treturn 0;\n\n\t \n\nexit_devunreg:\n\n\thwmon_device_unregister(data->hwmon_dev);\n\n\t \n\nexit_remove:\n\tfor (i = 0; i < ARRAY_SIZE(w83793_sensor_attr_2); i++)\n\t\tdevice_remove_file(dev, &w83793_sensor_attr_2[i].dev_attr);\n\n\tfor (i = 0; i < ARRAY_SIZE(sda_single_files); i++)\n\t\tdevice_remove_file(dev, &sda_single_files[i].dev_attr);\n\n\tfor (i = 0; i < ARRAY_SIZE(w83793_vid); i++)\n\t\tdevice_remove_file(dev, &w83793_vid[i].dev_attr);\n\n\tfor (i = 0; i < ARRAY_SIZE(w83793_left_fan); i++)\n\t\tdevice_remove_file(dev, &w83793_left_fan[i].dev_attr);\n\n\tfor (i = 0; i < ARRAY_SIZE(w83793_left_pwm); i++)\n\t\tdevice_remove_file(dev, &w83793_left_pwm[i].dev_attr);\n\n\tfor (i = 0; i < ARRAY_SIZE(w83793_temp); i++)\n\t\tdevice_remove_file(dev, &w83793_temp[i].dev_attr);\nfree_mem:\n\tkfree(data);\nexit:\n\treturn err;\n}\n\nstatic void w83793_update_nonvolatile(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tint i, j;\n\t \n\tif (!(time_after(jiffies, data->last_nonvolatile + HZ * 300)\n\t      || !data->valid))\n\t\treturn;\n\t \n\tfor (i = 1; i < 3; i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(data->in); j++) {\n\t\t\tdata->in[j][i] =\n\t\t\t    w83793_read_value(client, W83793_REG_IN[j][i]);\n\t\t}\n\t\tdata->in_low_bits[i] =\n\t\t    w83793_read_value(client, W83793_REG_IN_LOW_BITS[i]);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data->fan_min); i++) {\n\t\t \n\t\tif (!(data->has_fan & (1 << i)))\n\t\t\tcontinue;\n\t\tdata->fan_min[i] =\n\t\t    w83793_read_value(client, W83793_REG_FAN_MIN(i)) << 8;\n\t\tdata->fan_min[i] |=\n\t\t    w83793_read_value(client, W83793_REG_FAN_MIN(i) + 1);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data->temp_fan_map); i++) {\n\t\tif (!(data->has_temp & (1 << i)))\n\t\t\tcontinue;\n\t\tdata->temp_fan_map[i] =\n\t\t    w83793_read_value(client, W83793_REG_TEMP_FAN_MAP(i));\n\t\tfor (j = 1; j < 5; j++) {\n\t\t\tdata->temp[i][j] =\n\t\t\t    w83793_read_value(client, W83793_REG_TEMP[i][j]);\n\t\t}\n\t\tdata->temp_cruise[i] =\n\t\t    w83793_read_value(client, W83793_REG_TEMP_CRUISE(i));\n\t\tfor (j = 0; j < 7; j++) {\n\t\t\tdata->sf2_pwm[i][j] =\n\t\t\t    w83793_read_value(client, W83793_REG_SF2_PWM(i, j));\n\t\t\tdata->sf2_temp[i][j] =\n\t\t\t    w83793_read_value(client,\n\t\t\t\t\t      W83793_REG_SF2_TEMP(i, j));\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data->temp_mode); i++)\n\t\tdata->temp_mode[i] =\n\t\t    w83793_read_value(client, W83793_REG_TEMP_MODE[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(data->tolerance); i++) {\n\t\tdata->tolerance[i] =\n\t\t    w83793_read_value(client, W83793_REG_TEMP_TOL(i));\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data->pwm); i++) {\n\t\tif (!(data->has_pwm & (1 << i)))\n\t\t\tcontinue;\n\t\tdata->pwm[i][PWM_NONSTOP] =\n\t\t    w83793_read_value(client, W83793_REG_PWM(i, PWM_NONSTOP));\n\t\tdata->pwm[i][PWM_START] =\n\t\t    w83793_read_value(client, W83793_REG_PWM(i, PWM_START));\n\t\tdata->pwm_stop_time[i] =\n\t\t    w83793_read_value(client, W83793_REG_PWM_STOP_TIME(i));\n\t}\n\n\tdata->pwm_default = w83793_read_value(client, W83793_REG_PWM_DEFAULT);\n\tdata->pwm_enable = w83793_read_value(client, W83793_REG_PWM_ENABLE);\n\tdata->pwm_uptime = w83793_read_value(client, W83793_REG_PWM_UPTIME);\n\tdata->pwm_downtime = w83793_read_value(client, W83793_REG_PWM_DOWNTIME);\n\tdata->temp_critical =\n\t    w83793_read_value(client, W83793_REG_TEMP_CRITICAL);\n\tdata->beep_enable = w83793_read_value(client, W83793_REG_OVT_BEEP);\n\n\tfor (i = 0; i < ARRAY_SIZE(data->beeps); i++)\n\t\tdata->beeps[i] = w83793_read_value(client, W83793_REG_BEEP(i));\n\n\tdata->last_nonvolatile = jiffies;\n}\n\nstatic struct w83793_data *w83793_update_device(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (!(time_after(jiffies, data->last_updated + HZ * 2)\n\t      || !data->valid))\n\t\tgoto END;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->in); i++)\n\t\tdata->in[i][IN_READ] =\n\t\t    w83793_read_value(client, W83793_REG_IN[i][IN_READ]);\n\n\tdata->in_low_bits[IN_READ] =\n\t    w83793_read_value(client, W83793_REG_IN_LOW_BITS[IN_READ]);\n\n\tfor (i = 0; i < ARRAY_SIZE(data->fan); i++) {\n\t\tif (!(data->has_fan & (1 << i)))\n\t\t\tcontinue;\n\t\tdata->fan[i] =\n\t\t    w83793_read_value(client, W83793_REG_FAN(i)) << 8;\n\t\tdata->fan[i] |=\n\t\t    w83793_read_value(client, W83793_REG_FAN(i) + 1);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data->temp); i++) {\n\t\tif (!(data->has_temp & (1 << i)))\n\t\t\tcontinue;\n\t\tdata->temp[i][TEMP_READ] =\n\t\t    w83793_read_value(client, W83793_REG_TEMP[i][TEMP_READ]);\n\t}\n\n\tdata->temp_low_bits =\n\t    w83793_read_value(client, W83793_REG_TEMP_LOW_BITS);\n\n\tfor (i = 0; i < ARRAY_SIZE(data->pwm); i++) {\n\t\tif (data->has_pwm & (1 << i))\n\t\t\tdata->pwm[i][PWM_DUTY] =\n\t\t\t    w83793_read_value(client,\n\t\t\t\t\t      W83793_REG_PWM(i, PWM_DUTY));\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data->alarms); i++)\n\t\tdata->alarms[i] =\n\t\t    w83793_read_value(client, W83793_REG_ALARM(i));\n\tif (data->has_vid & 0x01)\n\t\tdata->vid[0] = w83793_read_value(client, W83793_REG_VID_INA);\n\tif (data->has_vid & 0x02)\n\t\tdata->vid[1] = w83793_read_value(client, W83793_REG_VID_INB);\n\tw83793_update_nonvolatile(dev);\n\tdata->last_updated = jiffies;\n\tdata->valid = true;\n\nEND:\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n}\n\n \nstatic u8 w83793_read_value(struct i2c_client *client, u16 reg)\n{\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tu8 res;\n\tu8 new_bank = reg >> 8;\n\n\tnew_bank |= data->bank & 0xfc;\n\tif (data->bank != new_bank) {\n\t\tif (i2c_smbus_write_byte_data\n\t\t    (client, W83793_REG_BANKSEL, new_bank) >= 0)\n\t\t\tdata->bank = new_bank;\n\t\telse {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"set bank to %d failed, fall back \"\n\t\t\t\t\"to bank %d, read reg 0x%x error\\n\",\n\t\t\t\tnew_bank, data->bank, reg);\n\t\t\tres = 0x0;\t \n\t\t\tgoto END;\n\t\t}\n\t}\n\tres = i2c_smbus_read_byte_data(client, reg & 0xff);\nEND:\n\treturn res;\n}\n\n \nstatic int w83793_write_value(struct i2c_client *client, u16 reg, u8 value)\n{\n\tstruct w83793_data *data = i2c_get_clientdata(client);\n\tint res;\n\tu8 new_bank = reg >> 8;\n\n\tnew_bank |= data->bank & 0xfc;\n\tif (data->bank != new_bank) {\n\t\tres = i2c_smbus_write_byte_data(client, W83793_REG_BANKSEL,\n\t\t\t\t\t\tnew_bank);\n\t\tif (res < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"set bank to %d failed, fall back \"\n\t\t\t\t\"to bank %d, write reg 0x%x error\\n\",\n\t\t\t\tnew_bank, data->bank, reg);\n\t\t\tgoto END;\n\t\t}\n\t\tdata->bank = new_bank;\n\t}\n\n\tres = i2c_smbus_write_byte_data(client, reg & 0xff, value);\nEND:\n\treturn res;\n}\n\nmodule_i2c_driver(w83793_driver);\n\nMODULE_AUTHOR(\"Yuan Mu, Sven Anders\");\nMODULE_DESCRIPTION(\"w83793 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}