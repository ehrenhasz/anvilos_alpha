{
  "module_name": "thmc50.c",
  "hash_id": "c1fac7161497f857267796e4c096d7040aa6643dfbd550a77e9f1fec32e69895",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/thmc50.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/jiffies.h>\n\nMODULE_LICENSE(\"GPL\");\n\n \nstatic const unsigned short normal_i2c[] = { 0x2c, 0x2d, 0x2e, I2C_CLIENT_END };\n\n \nenum chips { thmc50, adm1022 };\n\nstatic unsigned short adm1022_temp3[16];\nstatic unsigned int adm1022_temp3_num;\nmodule_param_array(adm1022_temp3, ushort, &adm1022_temp3_num, 0);\nMODULE_PARM_DESC(adm1022_temp3,\n\t\t \"List of adapter,address pairs to enable 3rd temperature (ADM1022 only)\");\n\n \n\n \n#define THMC50_REG_CONF\t\t\t\t0x40\n#define THMC50_REG_COMPANY_ID\t\t\t0x3E\n#define THMC50_REG_DIE_CODE\t\t\t0x3F\n#define THMC50_REG_ANALOG_OUT\t\t\t0x19\n \n#define THMC50_REG_INTR\t\t\t\t0x41\n\nstatic const u8 THMC50_REG_TEMP[] = { 0x27, 0x26, 0x20 };\nstatic const u8 THMC50_REG_TEMP_MIN[] = { 0x3A, 0x38, 0x2C };\nstatic const u8 THMC50_REG_TEMP_MAX[] = { 0x39, 0x37, 0x2B };\nstatic const u8 THMC50_REG_TEMP_CRITICAL[] = { 0x13, 0x14, 0x14 };\nstatic const u8 THMC50_REG_TEMP_DEFAULT[] = { 0x17, 0x18, 0x18 };\n\n#define THMC50_REG_CONF_nFANOFF\t\t\t0x20\n#define THMC50_REG_CONF_PROGRAMMED\t\t0x08\n\n \nstruct thmc50_data {\n\tstruct i2c_client *client;\n\tconst struct attribute_group *groups[3];\n\n\tstruct mutex update_lock;\n\tenum chips type;\n\tunsigned long last_updated;\t \n\tchar has_temp3;\t\t \n\tbool valid;\t\t \n\n\t \n\ts8 temp_input[3];\n\ts8 temp_max[3];\n\ts8 temp_min[3];\n\ts8 temp_critical[3];\n\tu8 analog_out;\n\tu8 alarms;\n};\n\nstatic struct thmc50_data *thmc50_update_device(struct device *dev)\n{\n\tstruct thmc50_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint timeout = HZ / 5 + (data->type == thmc50 ? HZ : 0);\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + timeout)\n\t    || !data->valid) {\n\n\t\tint temps = data->has_temp3 ? 3 : 2;\n\t\tint i;\n\t\tint prog = i2c_smbus_read_byte_data(client, THMC50_REG_CONF);\n\n\t\tprog &= THMC50_REG_CONF_PROGRAMMED;\n\n\t\tfor (i = 0; i < temps; i++) {\n\t\t\tdata->temp_input[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tTHMC50_REG_TEMP[i]);\n\t\t\tdata->temp_max[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tTHMC50_REG_TEMP_MAX[i]);\n\t\t\tdata->temp_min[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tTHMC50_REG_TEMP_MIN[i]);\n\t\t\tdata->temp_critical[i] =\n\t\t\t\ti2c_smbus_read_byte_data(client,\n\t\t\t\t\tprog ? THMC50_REG_TEMP_CRITICAL[i]\n\t\t\t\t\t     : THMC50_REG_TEMP_DEFAULT[i]);\n\t\t}\n\t\tdata->analog_out =\n\t\t    i2c_smbus_read_byte_data(client, THMC50_REG_ANALOG_OUT);\n\t\tdata->alarms =\n\t\t    i2c_smbus_read_byte_data(client, THMC50_REG_INTR);\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\nstatic ssize_t analog_out_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct thmc50_data *data = thmc50_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->analog_out);\n}\n\nstatic ssize_t analog_out_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct thmc50_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint config;\n\tunsigned long tmp;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &tmp);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->analog_out = clamp_val(tmp, 0, 255);\n\ti2c_smbus_write_byte_data(client, THMC50_REG_ANALOG_OUT,\n\t\t\t\t  data->analog_out);\n\n\tconfig = i2c_smbus_read_byte_data(client, THMC50_REG_CONF);\n\tif (data->analog_out == 0)\n\t\tconfig &= ~THMC50_REG_CONF_nFANOFF;\n\telse\n\t\tconfig |= THMC50_REG_CONF_nFANOFF;\n\ti2c_smbus_write_byte_data(client, THMC50_REG_CONF, config);\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \nstatic ssize_t pwm_mode_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"0\\n\");\n}\n\n \nstatic ssize_t temp_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct thmc50_data *data = thmc50_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->temp_input[nr] * 1000);\n}\n\nstatic ssize_t temp_min_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct thmc50_data *data = thmc50_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->temp_min[nr] * 1000);\n}\n\nstatic ssize_t temp_min_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct thmc50_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_min[nr] = clamp_val(val / 1000, -128, 127);\n\ti2c_smbus_write_byte_data(client, THMC50_REG_TEMP_MIN[nr],\n\t\t\t\t  data->temp_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t temp_max_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct thmc50_data *data = thmc50_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->temp_max[nr] * 1000);\n}\n\nstatic ssize_t temp_max_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct thmc50_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_max[nr] = clamp_val(val / 1000, -128, 127);\n\ti2c_smbus_write_byte_data(client, THMC50_REG_TEMP_MAX[nr],\n\t\t\t\t  data->temp_max[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t temp_critical_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct thmc50_data *data = thmc50_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->temp_critical[nr] * 1000);\n}\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint index = to_sensor_dev_attr(attr)->index;\n\tstruct thmc50_data *data = thmc50_update_device(dev);\n\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> index) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp_max, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_crit, temp_critical, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_min, temp_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp_max, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_crit, temp_critical, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_min, temp_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_max, temp_max, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_crit, temp_critical, 2);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_alarm, alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_alarm, alarm, 5);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_alarm, alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_fault, alarm, 7);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_fault, alarm, 2);\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1, analog_out, 0);\nstatic SENSOR_DEVICE_ATTR_RO(pwm1_mode, pwm_mode, 0);\n\nstatic struct attribute *thmc50_attributes[] = {\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_mode.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group thmc50_group = {\n\t.attrs = thmc50_attributes,\n};\n\n \nstatic struct attribute *temp3_attributes[] = {\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_fault.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group temp3_group = {\n\t.attrs = temp3_attributes,\n};\n\n \nstatic int thmc50_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info)\n{\n\tunsigned company;\n\tunsigned revision;\n\tunsigned config;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tconst char *type_name;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tpr_debug(\"thmc50: detect failed, smbus byte data not supported!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpr_debug(\"thmc50: Probing for THMC50 at 0x%2X on bus %d\\n\",\n\t\t client->addr, i2c_adapter_id(client->adapter));\n\n\tcompany = i2c_smbus_read_byte_data(client, THMC50_REG_COMPANY_ID);\n\trevision = i2c_smbus_read_byte_data(client, THMC50_REG_DIE_CODE);\n\tconfig = i2c_smbus_read_byte_data(client, THMC50_REG_CONF);\n\tif (revision < 0xc0 || (config & 0x10))\n\t\treturn -ENODEV;\n\n\tif (company == 0x41) {\n\t\tint id = i2c_adapter_id(client->adapter);\n\t\tint i;\n\n\t\ttype_name = \"adm1022\";\n\t\tfor (i = 0; i + 1 < adm1022_temp3_num; i += 2)\n\t\t\tif (adm1022_temp3[i] == id &&\n\t\t\t    adm1022_temp3[i + 1] == client->addr) {\n\t\t\t\t \n\t\t\t\tconfig |= (1 << 7);\n\t\t\t\ti2c_smbus_write_byte_data(client,\n\t\t\t\t\t\t\t  THMC50_REG_CONF,\n\t\t\t\t\t\t\t  config);\n\t\t\t\tbreak;\n\t\t\t}\n\t} else if (company == 0x49) {\n\t\ttype_name = \"thmc50\";\n\t} else {\n\t\tpr_debug(\"thmc50: Detection of THMC50/ADM1022 failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpr_debug(\"thmc50: Detected %s (version %x, revision %x)\\n\",\n\t\t type_name, (revision >> 4) - 0xc, revision & 0xf);\n\n\tstrscpy(info->type, type_name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic void thmc50_init_client(struct thmc50_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint config;\n\n\tdata->analog_out = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t    THMC50_REG_ANALOG_OUT);\n\t \n\tif (data->analog_out == 0) {\n\t\tdata->analog_out = 1;\n\t\ti2c_smbus_write_byte_data(client, THMC50_REG_ANALOG_OUT,\n\t\t\t\t\t  data->analog_out);\n\t}\n\tconfig = i2c_smbus_read_byte_data(client, THMC50_REG_CONF);\n\tconfig |= 0x1;\t \n\tif (data->type == adm1022 && (config & (1 << 7)))\n\t\tdata->has_temp3 = 1;\n\ti2c_smbus_write_byte_data(client, THMC50_REG_CONF, config);\n}\n\nstatic const struct i2c_device_id thmc50_id[];\n\nstatic int thmc50_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct thmc50_data *data;\n\tstruct device *hwmon_dev;\n\tint idx = 0;\n\n\tdata = devm_kzalloc(dev, sizeof(struct thmc50_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tdata->type = i2c_match_id(thmc50_id, client)->driver_data;\n\tmutex_init(&data->update_lock);\n\n\tthmc50_init_client(data);\n\n\t \n\tdata->groups[idx++] = &thmc50_group;\n\n\t \n\tif (data->has_temp3)\n\t\tdata->groups[idx++] = &temp3_group;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, data->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id thmc50_id[] = {\n\t{ \"adm1022\", adm1022 },\n\t{ \"thmc50\", thmc50 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, thmc50_id);\n\nstatic struct i2c_driver thmc50_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"thmc50\",\n\t},\n\t.probe = thmc50_probe,\n\t.id_table = thmc50_id,\n\t.detect = thmc50_detect,\n\t.address_list = normal_i2c,\n};\n\nmodule_i2c_driver(thmc50_driver);\n\nMODULE_AUTHOR(\"Krzysztof Helt <krzysztof.h1@wp.pl>\");\nMODULE_DESCRIPTION(\"THMC50 driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}