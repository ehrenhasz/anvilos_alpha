{
  "module_name": "smpro-hwmon.c",
  "hash_id": "f11393a5c5700647c00164a5ec6bfc466db5a66fe5060f748491223dc4a716bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/smpro-hwmon.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n \n#define SOC_TEMP\t\t0x10\n#define SOC_VRD_TEMP\t\t0x11\n#define DIMM_VRD_TEMP\t\t0x12\n#define CORE_VRD_TEMP\t\t0x13\n#define CH0_DIMM_TEMP\t\t0x14\n#define CH1_DIMM_TEMP\t\t0x15\n#define CH2_DIMM_TEMP\t\t0x16\n#define CH3_DIMM_TEMP\t\t0x17\n#define CH4_DIMM_TEMP\t\t0x18\n#define CH5_DIMM_TEMP\t\t0x19\n#define CH6_DIMM_TEMP\t\t0x1A\n#define CH7_DIMM_TEMP\t\t0x1B\n#define RCA_VRD_TEMP\t\t0x1C\n\n#define CORE_VRD_PWR\t\t0x20\n#define SOC_PWR\t\t\t0x21\n#define DIMM_VRD1_PWR\t\t0x22\n#define DIMM_VRD2_PWR\t\t0x23\n#define CORE_VRD_PWR_MW\t\t0x26\n#define SOC_PWR_MW\t\t0x27\n#define DIMM_VRD1_PWR_MW\t0x28\n#define DIMM_VRD2_PWR_MW\t0x29\n#define RCA_VRD_PWR\t\t0x2A\n#define RCA_VRD_PWR_MW\t\t0x2B\n\n#define MEM_HOT_THRESHOLD\t0x32\n#define SOC_VR_HOT_THRESHOLD\t0x33\n#define CORE_VRD_VOLT\t\t0x34\n#define SOC_VRD_VOLT\t\t0x35\n#define DIMM_VRD1_VOLT\t\t0x36\n#define DIMM_VRD2_VOLT\t\t0x37\n#define RCA_VRD_VOLT\t\t0x38\n\n#define CORE_VRD_CURR\t\t0x39\n#define SOC_VRD_CURR\t\t0x3A\n#define DIMM_VRD1_CURR\t\t0x3B\n#define DIMM_VRD2_CURR\t\t0x3C\n#define RCA_VRD_CURR\t\t0x3D\n\nstruct smpro_hwmon {\n\tstruct regmap *regmap;\n};\n\nstruct smpro_sensor {\n\tconst u8 reg;\n\tconst u8 reg_ext;\n\tconst char *label;\n};\n\nstatic const struct smpro_sensor temperature[] = {\n\t{\n\t\t.reg = SOC_TEMP,\n\t\t.label = \"temp1 SoC\"\n\t},\n\t{\n\t\t.reg = SOC_VRD_TEMP,\n\t\t.reg_ext = SOC_VR_HOT_THRESHOLD,\n\t\t.label = \"temp2 SoC VRD\"\n\t},\n\t{\n\t\t.reg = DIMM_VRD_TEMP,\n\t\t.label = \"temp3 DIMM VRD\"\n\t},\n\t{\n\t\t.reg = CORE_VRD_TEMP,\n\t\t.label = \"temp4 CORE VRD\"\n\t},\n\t{\n\t\t.reg = CH0_DIMM_TEMP,\n\t\t.reg_ext = MEM_HOT_THRESHOLD,\n\t\t.label = \"temp5 CH0 DIMM\"\n\t},\n\t{\n\t\t.reg = CH1_DIMM_TEMP,\n\t\t.reg_ext = MEM_HOT_THRESHOLD,\n\t\t.label = \"temp6 CH1 DIMM\"\n\t},\n\t{\n\t\t.reg = CH2_DIMM_TEMP,\n\t\t.reg_ext = MEM_HOT_THRESHOLD,\n\t\t.label = \"temp7 CH2 DIMM\"\n\t},\n\t{\n\t\t.reg = CH3_DIMM_TEMP,\n\t\t.reg_ext = MEM_HOT_THRESHOLD,\n\t\t.label = \"temp8 CH3 DIMM\"\n\t},\n\t{\n\t\t.reg = CH4_DIMM_TEMP,\n\t\t.reg_ext = MEM_HOT_THRESHOLD,\n\t\t.label = \"temp9 CH4 DIMM\"\n\t},\n\t{\n\t\t.reg = CH5_DIMM_TEMP,\n\t\t.reg_ext = MEM_HOT_THRESHOLD,\n\t\t.label = \"temp10 CH5 DIMM\"\n\t},\n\t{\n\t\t.reg = CH6_DIMM_TEMP,\n\t\t.reg_ext = MEM_HOT_THRESHOLD,\n\t\t.label = \"temp11 CH6 DIMM\"\n\t},\n\t{\n\t\t.reg = CH7_DIMM_TEMP,\n\t\t.reg_ext = MEM_HOT_THRESHOLD,\n\t\t.label = \"temp12 CH7 DIMM\"\n\t},\n\t{\n\t\t.reg = RCA_VRD_TEMP,\n\t\t.label = \"temp13 RCA VRD\"\n\t},\n};\n\nstatic const struct smpro_sensor voltage[] = {\n\t{\n\t\t.reg = CORE_VRD_VOLT,\n\t\t.label = \"vout0 CORE VRD\"\n\t},\n\t{\n\t\t.reg = SOC_VRD_VOLT,\n\t\t.label = \"vout1 SoC VRD\"\n\t},\n\t{\n\t\t.reg = DIMM_VRD1_VOLT,\n\t\t.label = \"vout2 DIMM VRD1\"\n\t},\n\t{\n\t\t.reg = DIMM_VRD2_VOLT,\n\t\t.label = \"vout3 DIMM VRD2\"\n\t},\n\t{\n\t\t.reg = RCA_VRD_VOLT,\n\t\t.label = \"vout4 RCA VRD\"\n\t},\n};\n\nstatic const struct smpro_sensor curr_sensor[] = {\n\t{\n\t\t.reg = CORE_VRD_CURR,\n\t\t.label = \"iout1 CORE VRD\"\n\t},\n\t{\n\t\t.reg = SOC_VRD_CURR,\n\t\t.label = \"iout2 SoC VRD\"\n\t},\n\t{\n\t\t.reg = DIMM_VRD1_CURR,\n\t\t.label = \"iout3 DIMM VRD1\"\n\t},\n\t{\n\t\t.reg = DIMM_VRD2_CURR,\n\t\t.label = \"iout4 DIMM VRD2\"\n\t},\n\t{\n\t\t.reg = RCA_VRD_CURR,\n\t\t.label = \"iout5 RCA VRD\"\n\t},\n};\n\nstatic const struct smpro_sensor power[] = {\n\t{\n\t\t.reg = CORE_VRD_PWR,\n\t\t.reg_ext = CORE_VRD_PWR_MW,\n\t\t.label = \"power1 CORE VRD\"\n\t},\n\t{\n\t\t.reg = SOC_PWR,\n\t\t.reg_ext = SOC_PWR_MW,\n\t\t.label = \"power2 SoC\"\n\t},\n\t{\n\t\t.reg = DIMM_VRD1_PWR,\n\t\t.reg_ext = DIMM_VRD1_PWR_MW,\n\t\t.label = \"power3 DIMM VRD1\"\n\t},\n\t{\n\t\t.reg = DIMM_VRD2_PWR,\n\t\t.reg_ext = DIMM_VRD2_PWR_MW,\n\t\t.label = \"power4 DIMM VRD2\"\n\t},\n\t{\n\t\t.reg = RCA_VRD_PWR,\n\t\t.reg_ext = RCA_VRD_PWR_MW,\n\t\t.label = \"power5 RCA VRD\"\n\t},\n};\n\nstatic int smpro_read_temp(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct smpro_hwmon *hwmon = dev_get_drvdata(dev);\n\tunsigned int value;\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tret = regmap_read(hwmon->regmap, temperature[channel].reg, &value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\tret = regmap_read(hwmon->regmap, temperature[channel].reg_ext, &value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*val = sign_extend32(value, 8) * 1000;\n\treturn 0;\n}\n\nstatic int smpro_read_in(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct smpro_hwmon *hwmon = dev_get_drvdata(dev);\n\tunsigned int value;\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\tret = regmap_read(hwmon->regmap, voltage[channel].reg, &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\t*val = value & 0x7fff;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int smpro_read_curr(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct smpro_hwmon *hwmon = dev_get_drvdata(dev);\n\tunsigned int value;\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_curr_input:\n\t\tret = regmap_read(hwmon->regmap, curr_sensor[channel].reg, &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\t*val = value & 0x7fff;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int smpro_read_power(struct device *dev, u32 attr, int channel, long *val_pwr)\n{\n\tstruct smpro_hwmon *hwmon = dev_get_drvdata(dev);\n\tunsigned int val = 0, val_mw = 0;\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_power_input:\n\t\tret = regmap_read(hwmon->regmap, power[channel].reg, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_read(hwmon->regmap, power[channel].reg_ext, &val_mw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\t*val_pwr = (val & 0x3ff) * 1000000 + (val_mw & 0x3ff) * 1000;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int smpro_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t      u32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn smpro_read_temp(dev, attr, channel, val);\n\tcase hwmon_in:\n\t\treturn smpro_read_in(dev, attr, channel, val);\n\tcase hwmon_power:\n\t\treturn smpro_read_power(dev, attr, channel, val);\n\tcase hwmon_curr:\n\t\treturn smpro_read_curr(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int smpro_read_string(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_label:\n\t\t\t*str = temperature[channel].label;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_label:\n\t\t\t*str = voltage[channel].label;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_label:\n\t\t\t*str = curr_sensor[channel].label;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_power:\n\t\tswitch (attr) {\n\t\tcase hwmon_power_label:\n\t\t\t*str = power[channel].label;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic umode_t smpro_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\tu32 attr, int channel)\n{\n\tconst struct smpro_hwmon *hwmon = data;\n\tunsigned int value;\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_label:\n\t\tcase hwmon_temp_crit:\n\t\t\tret = regmap_read(hwmon->regmap, temperature[channel].reg, &value);\n\t\t\tif (ret || value == 0xFFFF)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0444;\n}\n\nstatic const struct hwmon_channel_info * const smpro_info[] = {\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_CRIT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_CRIT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_CRIT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_CRIT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_CRIT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_CRIT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_CRIT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_CRIT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_CRIT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL),\n\tHWMON_CHANNEL_INFO(power,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL),\n\tHWMON_CHANNEL_INFO(curr,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL),\n\tNULL\n};\n\nstatic const struct hwmon_ops smpro_hwmon_ops = {\n\t.is_visible = smpro_is_visible,\n\t.read = smpro_read,\n\t.read_string = smpro_read_string,\n};\n\nstatic const struct hwmon_chip_info smpro_chip_info = {\n\t.ops = &smpro_hwmon_ops,\n\t.info = smpro_info,\n};\n\nstatic int smpro_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct smpro_hwmon *hwmon;\n\tstruct device *hwmon_dev;\n\n\thwmon = devm_kzalloc(&pdev->dev, sizeof(struct smpro_hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn -ENOMEM;\n\n\thwmon->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!hwmon->regmap)\n\t\treturn -ENODEV;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&pdev->dev, \"smpro_hwmon\",\n\t\t\t\t\t\t\t hwmon, &smpro_chip_info, NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic struct platform_driver smpro_hwmon_driver = {\n\t.probe\t\t= smpro_hwmon_probe,\n\t.driver = {\n\t\t.name\t= \"smpro-hwmon\",\n\t},\n};\n\nmodule_platform_driver(smpro_hwmon_driver);\n\nMODULE_AUTHOR(\"Thu Nguyen <thu@os.amperecomputing.com>\");\nMODULE_AUTHOR(\"Quan Nguyen <quan@os.amperecomputing.com>\");\nMODULE_DESCRIPTION(\"Ampere Altra SMPro hwmon driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}