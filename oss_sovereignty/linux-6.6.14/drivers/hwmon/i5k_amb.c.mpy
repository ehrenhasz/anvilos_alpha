{
  "module_name": "i5k_amb.c",
  "hash_id": "69dc82f15c384c7e03c2b054cf313acefca9058859d1f455e5b1b05cc1fedb13",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/i5k_amb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/log2.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define DRVNAME \"i5k_amb\"\n\n#define I5K_REG_AMB_BASE_ADDR\t\t0x48\n#define I5K_REG_AMB_LEN_ADDR\t\t0x50\n#define I5K_REG_CHAN0_PRESENCE_ADDR\t0x64\n#define I5K_REG_CHAN1_PRESENCE_ADDR\t0x66\n\n#define AMB_REG_TEMP_MIN_ADDR\t\t0x80\n#define AMB_REG_TEMP_MID_ADDR\t\t0x81\n#define AMB_REG_TEMP_MAX_ADDR\t\t0x82\n#define AMB_REG_TEMP_STATUS_ADDR\t0x84\n#define AMB_REG_TEMP_ADDR\t\t0x85\n\n#define AMB_CONFIG_SIZE\t\t\t2048\n#define AMB_FUNC_3_OFFSET\t\t768\n\nstatic unsigned long amb_reg_temp_status(unsigned int amb)\n{\n\treturn AMB_FUNC_3_OFFSET + AMB_REG_TEMP_STATUS_ADDR +\n\t       AMB_CONFIG_SIZE * amb;\n}\n\nstatic unsigned long amb_reg_temp_min(unsigned int amb)\n{\n\treturn AMB_FUNC_3_OFFSET + AMB_REG_TEMP_MIN_ADDR +\n\t       AMB_CONFIG_SIZE * amb;\n}\n\nstatic unsigned long amb_reg_temp_mid(unsigned int amb)\n{\n\treturn AMB_FUNC_3_OFFSET + AMB_REG_TEMP_MID_ADDR +\n\t       AMB_CONFIG_SIZE * amb;\n}\n\nstatic unsigned long amb_reg_temp_max(unsigned int amb)\n{\n\treturn AMB_FUNC_3_OFFSET + AMB_REG_TEMP_MAX_ADDR +\n\t       AMB_CONFIG_SIZE * amb;\n}\n\nstatic unsigned long amb_reg_temp(unsigned int amb)\n{\n\treturn AMB_FUNC_3_OFFSET + AMB_REG_TEMP_ADDR +\n\t       AMB_CONFIG_SIZE * amb;\n}\n\n#define MAX_MEM_CHANNELS\t\t4\n#define MAX_AMBS_PER_CHANNEL\t\t16\n#define MAX_AMBS\t\t\t(MAX_MEM_CHANNELS * \\\n\t\t\t\t\t MAX_AMBS_PER_CHANNEL)\n#define CHANNEL_SHIFT\t\t\t4\n#define DIMM_MASK\t\t\t0xF\n \n#define REAL_MAX_AMBS_PER_CHANNEL\t15\n#define KNOBS_PER_AMB\t\t\t6\n\nstatic unsigned long amb_num_from_reg(unsigned int byte_num, unsigned int bit)\n{\n\treturn byte_num * MAX_AMBS_PER_CHANNEL + bit;\n}\n\n#define AMB_SYSFS_NAME_LEN\t\t16\nstruct i5k_device_attribute {\n\tstruct sensor_device_attribute s_attr;\n\tchar name[AMB_SYSFS_NAME_LEN];\n};\n\nstruct i5k_amb_data {\n\tstruct device *hwmon_dev;\n\n\tunsigned long amb_base;\n\tunsigned long amb_len;\n\tu16 amb_present[MAX_MEM_CHANNELS];\n\tvoid __iomem *amb_mmio;\n\tstruct i5k_device_attribute *attrs;\n\tunsigned int num_attrs;\n};\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", DRVNAME);\n}\n\n\nstatic DEVICE_ATTR_RO(name);\n\nstatic struct platform_device *amb_pdev;\n\nstatic u8 amb_read_byte(struct i5k_amb_data *data, unsigned long offset)\n{\n\treturn ioread8(data->amb_mmio + offset);\n}\n\nstatic void amb_write_byte(struct i5k_amb_data *data, unsigned long offset,\n\t\t\t   u8 val)\n{\n\tiowrite8(val, data->amb_mmio + offset);\n}\n\nstatic ssize_t show_amb_alarm(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct i5k_amb_data *data = dev_get_drvdata(dev);\n\n\tif (!(amb_read_byte(data, amb_reg_temp_status(attr->index)) & 0x20) &&\n\t     (amb_read_byte(data, amb_reg_temp_status(attr->index)) & 0x8))\n\t\treturn sprintf(buf, \"1\\n\");\n\telse\n\t\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t store_amb_min(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct i5k_amb_data *data = dev_get_drvdata(dev);\n\tunsigned long temp;\n\tint ret = kstrtoul(buf, 10, &temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttemp = temp / 500;\n\tif (temp > 255)\n\t\ttemp = 255;\n\n\tamb_write_byte(data, amb_reg_temp_min(attr->index), temp);\n\treturn count;\n}\n\nstatic ssize_t store_amb_mid(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct i5k_amb_data *data = dev_get_drvdata(dev);\n\tunsigned long temp;\n\tint ret = kstrtoul(buf, 10, &temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttemp = temp / 500;\n\tif (temp > 255)\n\t\ttemp = 255;\n\n\tamb_write_byte(data, amb_reg_temp_mid(attr->index), temp);\n\treturn count;\n}\n\nstatic ssize_t store_amb_max(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct i5k_amb_data *data = dev_get_drvdata(dev);\n\tunsigned long temp;\n\tint ret = kstrtoul(buf, 10, &temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttemp = temp / 500;\n\tif (temp > 255)\n\t\ttemp = 255;\n\n\tamb_write_byte(data, amb_reg_temp_max(attr->index), temp);\n\treturn count;\n}\n\nstatic ssize_t show_amb_min(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct i5k_amb_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t500 * amb_read_byte(data, amb_reg_temp_min(attr->index)));\n}\n\nstatic ssize_t show_amb_mid(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct i5k_amb_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t500 * amb_read_byte(data, amb_reg_temp_mid(attr->index)));\n}\n\nstatic ssize_t show_amb_max(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct i5k_amb_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t500 * amb_read_byte(data, amb_reg_temp_max(attr->index)));\n}\n\nstatic ssize_t show_amb_temp(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct i5k_amb_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t500 * amb_read_byte(data, amb_reg_temp(attr->index)));\n}\n\nstatic ssize_t show_label(struct device *dev,\n\t\t\t  struct device_attribute *devattr,\n\t\t\t  char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\n\treturn sprintf(buf, \"Ch. %d DIMM %d\\n\", attr->index >> CHANNEL_SHIFT,\n\t\t       attr->index & DIMM_MASK);\n}\n\nstatic int i5k_amb_hwmon_init(struct platform_device *pdev)\n{\n\tint i, j, k, d = 0;\n\tu16 c;\n\tint res = 0;\n\tint num_ambs = 0;\n\tstruct i5k_amb_data *data = platform_get_drvdata(pdev);\n\n\t \n\t \n\tfor (i = 0; i < MAX_MEM_CHANNELS; i++)\n\t\tnum_ambs += hweight16(data->amb_present[i] & 0x7fff);\n\n\t \n\tdata->attrs = kzalloc(array3_size(num_ambs, KNOBS_PER_AMB,\n\t\t\t\t\t  sizeof(*data->attrs)),\n\t\t\t      GFP_KERNEL);\n\tif (!data->attrs)\n\t\treturn -ENOMEM;\n\tdata->num_attrs = 0;\n\n\tfor (i = 0; i < MAX_MEM_CHANNELS; i++) {\n\t\tc = data->amb_present[i];\n\t\tfor (j = 0; j < REAL_MAX_AMBS_PER_CHANNEL; j++, c >>= 1) {\n\t\t\tstruct i5k_device_attribute *iattr;\n\n\t\t\tk = amb_num_from_reg(i, j);\n\t\t\tif (!(c & 0x1))\n\t\t\t\tcontinue;\n\t\t\td++;\n\n\t\t\t \n\t\t\tiattr = data->attrs + data->num_attrs;\n\t\t\tsnprintf(iattr->name, AMB_SYSFS_NAME_LEN,\n\t\t\t\t \"temp%d_label\", d);\n\t\t\tiattr->s_attr.dev_attr.attr.name = iattr->name;\n\t\t\tiattr->s_attr.dev_attr.attr.mode = 0444;\n\t\t\tiattr->s_attr.dev_attr.show = show_label;\n\t\t\tiattr->s_attr.index = k;\n\t\t\tsysfs_attr_init(&iattr->s_attr.dev_attr.attr);\n\t\t\tres = device_create_file(&pdev->dev,\n\t\t\t\t\t\t &iattr->s_attr.dev_attr);\n\t\t\tif (res)\n\t\t\t\tgoto exit_remove;\n\t\t\tdata->num_attrs++;\n\n\t\t\t \n\t\t\tiattr = data->attrs + data->num_attrs;\n\t\t\tsnprintf(iattr->name, AMB_SYSFS_NAME_LEN,\n\t\t\t\t \"temp%d_input\", d);\n\t\t\tiattr->s_attr.dev_attr.attr.name = iattr->name;\n\t\t\tiattr->s_attr.dev_attr.attr.mode = 0444;\n\t\t\tiattr->s_attr.dev_attr.show = show_amb_temp;\n\t\t\tiattr->s_attr.index = k;\n\t\t\tsysfs_attr_init(&iattr->s_attr.dev_attr.attr);\n\t\t\tres = device_create_file(&pdev->dev,\n\t\t\t\t\t\t &iattr->s_attr.dev_attr);\n\t\t\tif (res)\n\t\t\t\tgoto exit_remove;\n\t\t\tdata->num_attrs++;\n\n\t\t\t \n\t\t\tiattr = data->attrs + data->num_attrs;\n\t\t\tsnprintf(iattr->name, AMB_SYSFS_NAME_LEN,\n\t\t\t\t \"temp%d_min\", d);\n\t\t\tiattr->s_attr.dev_attr.attr.name = iattr->name;\n\t\t\tiattr->s_attr.dev_attr.attr.mode = 0644;\n\t\t\tiattr->s_attr.dev_attr.show = show_amb_min;\n\t\t\tiattr->s_attr.dev_attr.store = store_amb_min;\n\t\t\tiattr->s_attr.index = k;\n\t\t\tsysfs_attr_init(&iattr->s_attr.dev_attr.attr);\n\t\t\tres = device_create_file(&pdev->dev,\n\t\t\t\t\t\t &iattr->s_attr.dev_attr);\n\t\t\tif (res)\n\t\t\t\tgoto exit_remove;\n\t\t\tdata->num_attrs++;\n\n\t\t\t \n\t\t\tiattr = data->attrs + data->num_attrs;\n\t\t\tsnprintf(iattr->name, AMB_SYSFS_NAME_LEN,\n\t\t\t\t \"temp%d_mid\", d);\n\t\t\tiattr->s_attr.dev_attr.attr.name = iattr->name;\n\t\t\tiattr->s_attr.dev_attr.attr.mode = 0644;\n\t\t\tiattr->s_attr.dev_attr.show = show_amb_mid;\n\t\t\tiattr->s_attr.dev_attr.store = store_amb_mid;\n\t\t\tiattr->s_attr.index = k;\n\t\t\tsysfs_attr_init(&iattr->s_attr.dev_attr.attr);\n\t\t\tres = device_create_file(&pdev->dev,\n\t\t\t\t\t\t &iattr->s_attr.dev_attr);\n\t\t\tif (res)\n\t\t\t\tgoto exit_remove;\n\t\t\tdata->num_attrs++;\n\n\t\t\t \n\t\t\tiattr = data->attrs + data->num_attrs;\n\t\t\tsnprintf(iattr->name, AMB_SYSFS_NAME_LEN,\n\t\t\t\t \"temp%d_max\", d);\n\t\t\tiattr->s_attr.dev_attr.attr.name = iattr->name;\n\t\t\tiattr->s_attr.dev_attr.attr.mode = 0644;\n\t\t\tiattr->s_attr.dev_attr.show = show_amb_max;\n\t\t\tiattr->s_attr.dev_attr.store = store_amb_max;\n\t\t\tiattr->s_attr.index = k;\n\t\t\tsysfs_attr_init(&iattr->s_attr.dev_attr.attr);\n\t\t\tres = device_create_file(&pdev->dev,\n\t\t\t\t\t\t &iattr->s_attr.dev_attr);\n\t\t\tif (res)\n\t\t\t\tgoto exit_remove;\n\t\t\tdata->num_attrs++;\n\n\t\t\t \n\t\t\tiattr = data->attrs + data->num_attrs;\n\t\t\tsnprintf(iattr->name, AMB_SYSFS_NAME_LEN,\n\t\t\t\t \"temp%d_alarm\", d);\n\t\t\tiattr->s_attr.dev_attr.attr.name = iattr->name;\n\t\t\tiattr->s_attr.dev_attr.attr.mode = 0444;\n\t\t\tiattr->s_attr.dev_attr.show = show_amb_alarm;\n\t\t\tiattr->s_attr.index = k;\n\t\t\tsysfs_attr_init(&iattr->s_attr.dev_attr.attr);\n\t\t\tres = device_create_file(&pdev->dev,\n\t\t\t\t\t\t &iattr->s_attr.dev_attr);\n\t\t\tif (res)\n\t\t\t\tgoto exit_remove;\n\t\t\tdata->num_attrs++;\n\t\t}\n\t}\n\n\tres = device_create_file(&pdev->dev, &dev_attr_name);\n\tif (res)\n\t\tgoto exit_remove;\n\n\tdata->hwmon_dev = hwmon_device_register(&pdev->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\tres = PTR_ERR(data->hwmon_dev);\n\t\tgoto exit_remove;\n\t}\n\n\treturn res;\n\nexit_remove:\n\tdevice_remove_file(&pdev->dev, &dev_attr_name);\n\tfor (i = 0; i < data->num_attrs; i++)\n\t\tdevice_remove_file(&pdev->dev, &data->attrs[i].s_attr.dev_attr);\n\tkfree(data->attrs);\n\n\treturn res;\n}\n\nstatic int i5k_amb_add(void)\n{\n\tint res;\n\n\t \n\tamb_pdev = platform_device_alloc(DRVNAME, 0);\n\tif (!amb_pdev)\n\t\treturn -ENOMEM;\n\n\tres = platform_device_add(amb_pdev);\n\tif (res)\n\t\tgoto err;\n\treturn 0;\n\nerr:\n\tplatform_device_put(amb_pdev);\n\treturn res;\n}\n\nstatic int i5k_find_amb_registers(struct i5k_amb_data *data,\n\t\t\t\t\t    unsigned long devid)\n{\n\tstruct pci_dev *pcidev;\n\tu32 val32;\n\tint res = -ENODEV;\n\n\t \n\tpcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\tdevid,\n\t\t\t\tNULL);\n\tif (!pcidev)\n\t\treturn -ENODEV;\n\n\tpci_read_config_dword(pcidev, I5K_REG_AMB_BASE_ADDR, &val32);\n\tif (val32 == (u32)~0)\n\t\tgoto out;\n\tdata->amb_base = val32;\n\n\tpci_read_config_dword(pcidev, I5K_REG_AMB_LEN_ADDR, &val32);\n\tif (val32 == (u32)~0)\n\t\tgoto out;\n\tdata->amb_len = val32;\n\n\t \n\tif (data->amb_len < AMB_CONFIG_SIZE * MAX_AMBS) {\n\t\tdev_err(&pcidev->dev, \"AMB region too small!\\n\");\n\t\tgoto out;\n\t}\n\n\tres = 0;\nout:\n\tpci_dev_put(pcidev);\n\treturn res;\n}\n\nstatic int i5k_channel_probe(u16 *amb_present, unsigned long dev_id)\n{\n\tstruct pci_dev *pcidev;\n\tu16 val16;\n\tint res = -ENODEV;\n\n\t \n\tpcidev = pci_get_device(PCI_VENDOR_ID_INTEL, dev_id, NULL);\n\tif (!pcidev)\n\t\treturn -ENODEV;\n\n\tpci_read_config_word(pcidev, I5K_REG_CHAN0_PRESENCE_ADDR, &val16);\n\tif (val16 == (u16)~0)\n\t\tgoto out;\n\tamb_present[0] = val16;\n\n\tpci_read_config_word(pcidev, I5K_REG_CHAN1_PRESENCE_ADDR, &val16);\n\tif (val16 == (u16)~0)\n\t\tgoto out;\n\tamb_present[1] = val16;\n\n\tres = 0;\n\nout:\n\tpci_dev_put(pcidev);\n\treturn res;\n}\n\nstatic struct {\n\tunsigned long err;\n\tunsigned long fbd0;\n} chipset_ids[]  = {\n\t{ PCI_DEVICE_ID_INTEL_5000_ERR, PCI_DEVICE_ID_INTEL_5000_FBD0 },\n\t{ PCI_DEVICE_ID_INTEL_5400_ERR, PCI_DEVICE_ID_INTEL_5400_FBD0 },\n\t{ 0, 0 }\n};\n\n#ifdef MODULE\nstatic const struct pci_device_id i5k_amb_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_5000_ERR) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_5400_ERR) },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, i5k_amb_ids);\n#endif\n\nstatic int i5k_amb_probe(struct platform_device *pdev)\n{\n\tstruct i5k_amb_data *data;\n\tstruct resource *reso;\n\tint i, res;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\ti = 0;\n\tdo {\n\t\tres = i5k_find_amb_registers(data, chipset_ids[i].err);\n\t\tif (res == 0)\n\t\t\tbreak;\n\t\ti++;\n\t} while (chipset_ids[i].err);\n\n\tif (res)\n\t\tgoto err;\n\n\t \n\tres = i5k_channel_probe(&data->amb_present[0], chipset_ids[i].fbd0);\n\tif (res)\n\t\tgoto err;\n\n\t \n\ti5k_channel_probe(&data->amb_present[2], chipset_ids[i].fbd0 + 1);\n\n\t \n\treso = request_mem_region(data->amb_base, data->amb_len, DRVNAME);\n\tif (!reso) {\n\t\tres = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tdata->amb_mmio = ioremap(data->amb_base, data->amb_len);\n\tif (!data->amb_mmio) {\n\t\tres = -EBUSY;\n\t\tgoto err_map_failed;\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\tres = i5k_amb_hwmon_init(pdev);\n\tif (res)\n\t\tgoto err_init_failed;\n\n\treturn res;\n\nerr_init_failed:\n\tiounmap(data->amb_mmio);\nerr_map_failed:\n\trelease_mem_region(data->amb_base, data->amb_len);\nerr:\n\tkfree(data);\n\treturn res;\n}\n\nstatic int i5k_amb_remove(struct platform_device *pdev)\n{\n\tint i;\n\tstruct i5k_amb_data *data = platform_get_drvdata(pdev);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tdevice_remove_file(&pdev->dev, &dev_attr_name);\n\tfor (i = 0; i < data->num_attrs; i++)\n\t\tdevice_remove_file(&pdev->dev, &data->attrs[i].s_attr.dev_attr);\n\tkfree(data->attrs);\n\tiounmap(data->amb_mmio);\n\trelease_mem_region(data->amb_base, data->amb_len);\n\tkfree(data);\n\treturn 0;\n}\n\nstatic struct platform_driver i5k_amb_driver = {\n\t.driver = {\n\t\t.name = DRVNAME,\n\t},\n\t.probe = i5k_amb_probe,\n\t.remove = i5k_amb_remove,\n};\n\nstatic int __init i5k_amb_init(void)\n{\n\tint res;\n\n\tres = platform_driver_register(&i5k_amb_driver);\n\tif (res)\n\t\treturn res;\n\n\tres = i5k_amb_add();\n\tif (res)\n\t\tplatform_driver_unregister(&i5k_amb_driver);\n\n\treturn res;\n}\n\nstatic void __exit i5k_amb_exit(void)\n{\n\tplatform_device_unregister(amb_pdev);\n\tplatform_driver_unregister(&i5k_amb_driver);\n}\n\nMODULE_AUTHOR(\"Darrick J. Wong <darrick.wong@oracle.com>\");\nMODULE_DESCRIPTION(\"Intel 5000 chipset FB-DIMM AMB temperature sensor\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(i5k_amb_init);\nmodule_exit(i5k_amb_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}