{
  "module_name": "adt7462.c",
  "hash_id": "c90718b77a345421c22dc579421d1dcf4b8c1054fb6a858fc0402edb423e9a54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adt7462.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x58, 0x5C, I2C_CLIENT_END };\n\n \n#define ADT7462_REG_DEVICE\t\t\t0x3D\n#define ADT7462_REG_VENDOR\t\t\t0x3E\n#define ADT7462_REG_REVISION\t\t\t0x3F\n\n#define ADT7462_REG_MIN_TEMP_BASE_ADDR\t\t0x44\n#define ADT7462_REG_MIN_TEMP_MAX_ADDR\t\t0x47\n#define ADT7462_REG_MAX_TEMP_BASE_ADDR\t\t0x48\n#define ADT7462_REG_MAX_TEMP_MAX_ADDR\t\t0x4B\n#define ADT7462_REG_TEMP_BASE_ADDR\t\t0x88\n#define ADT7462_REG_TEMP_MAX_ADDR\t\t0x8F\n\n#define ADT7462_REG_FAN_BASE_ADDR\t\t0x98\n#define ADT7462_REG_FAN_MAX_ADDR\t\t0x9F\n#define ADT7462_REG_FAN2_BASE_ADDR\t\t0xA2\n#define ADT7462_REG_FAN2_MAX_ADDR\t\t0xA9\n#define ADT7462_REG_FAN_ENABLE\t\t\t0x07\n#define ADT7462_REG_FAN_MIN_BASE_ADDR\t\t0x78\n#define ADT7462_REG_FAN_MIN_MAX_ADDR\t\t0x7F\n\n#define ADT7462_REG_CFG2\t\t\t0x02\n#define\t\tADT7462_FSPD_MASK\t\t0x20\n\n#define ADT7462_REG_PWM_BASE_ADDR\t\t0xAA\n#define ADT7462_REG_PWM_MAX_ADDR\t\t0xAD\n#define\tADT7462_REG_PWM_MIN_BASE_ADDR\t\t0x28\n#define ADT7462_REG_PWM_MIN_MAX_ADDR\t\t0x2B\n#define ADT7462_REG_PWM_MAX\t\t\t0x2C\n#define ADT7462_REG_PWM_TEMP_MIN_BASE_ADDR\t0x5C\n#define ADT7462_REG_PWM_TEMP_MIN_MAX_ADDR\t0x5F\n#define ADT7462_REG_PWM_TEMP_RANGE_BASE_ADDR\t0x60\n#define ADT7462_REG_PWM_TEMP_RANGE_MAX_ADDR\t0x63\n#define\tADT7462_PWM_HYST_MASK\t\t\t0x0F\n#define\tADT7462_PWM_RANGE_MASK\t\t\t0xF0\n#define\t\tADT7462_PWM_RANGE_SHIFT\t\t4\n#define ADT7462_REG_PWM_CFG_BASE_ADDR\t\t0x21\n#define ADT7462_REG_PWM_CFG_MAX_ADDR\t\t0x24\n#define\t\tADT7462_PWM_CHANNEL_MASK\t0xE0\n#define\t\tADT7462_PWM_CHANNEL_SHIFT\t5\n\n#define ADT7462_REG_PIN_CFG_BASE_ADDR\t\t0x10\n#define ADT7462_REG_PIN_CFG_MAX_ADDR\t\t0x13\n#define\t\tADT7462_PIN7_INPUT\t\t0x01\t \n#define\t\tADT7462_DIODE3_INPUT\t\t0x20\n#define\t\tADT7462_DIODE1_INPUT\t\t0x40\n#define\t\tADT7462_VID_INPUT\t\t0x80\n#define\t\tADT7462_PIN22_INPUT\t\t0x04\t \n#define\t\tADT7462_PIN21_INPUT\t\t0x08\n#define\t\tADT7462_PIN19_INPUT\t\t0x10\n#define\t\tADT7462_PIN15_INPUT\t\t0x20\n#define\t\tADT7462_PIN13_INPUT\t\t0x40\n#define\t\tADT7462_PIN8_INPUT\t\t0x80\n#define\t\tADT7462_PIN23_MASK\t\t0x03\n#define\t\tADT7462_PIN23_SHIFT\t\t0\n#define\t\tADT7462_PIN26_MASK\t\t0x0C\t \n#define\t\tADT7462_PIN26_SHIFT\t\t2\n#define\t\tADT7462_PIN25_MASK\t\t0x30\n#define\t\tADT7462_PIN25_SHIFT\t\t4\n#define\t\tADT7462_PIN24_MASK\t\t0xC0\n#define\t\tADT7462_PIN24_SHIFT\t\t6\n#define\t\tADT7462_PIN26_VOLT_INPUT\t0x08\n#define\t\tADT7462_PIN25_VOLT_INPUT\t0x20\n#define\t\tADT7462_PIN28_SHIFT\t\t4\t \n#define\t\tADT7462_PIN28_VOLT\t\t0x5\n\n#define ADT7462_REG_ALARM1\t\t\t0xB8\n#define\tADT7462_LT_ALARM\t\t\t0x02\n#define\t\tADT7462_R1T_ALARM\t\t0x04\n#define\t\tADT7462_R2T_ALARM\t\t0x08\n#define\t\tADT7462_R3T_ALARM\t\t0x10\n#define ADT7462_REG_ALARM2\t\t\t0xBB\n#define\t\tADT7462_V0_ALARM\t\t0x01\n#define\t\tADT7462_V1_ALARM\t\t0x02\n#define\t\tADT7462_V2_ALARM\t\t0x04\n#define\t\tADT7462_V3_ALARM\t\t0x08\n#define\t\tADT7462_V4_ALARM\t\t0x10\n#define\t\tADT7462_V5_ALARM\t\t0x20\n#define\t\tADT7462_V6_ALARM\t\t0x40\n#define\t\tADT7462_V7_ALARM\t\t0x80\n#define ADT7462_REG_ALARM3\t\t\t0xBC\n#define\t\tADT7462_V8_ALARM\t\t0x08\n#define\t\tADT7462_V9_ALARM\t\t0x10\n#define\t\tADT7462_V10_ALARM\t\t0x20\n#define\t\tADT7462_V11_ALARM\t\t0x40\n#define\t\tADT7462_V12_ALARM\t\t0x80\n#define ADT7462_REG_ALARM4\t\t\t0xBD\n#define\t\tADT7462_F0_ALARM\t\t0x01\n#define\t\tADT7462_F1_ALARM\t\t0x02\n#define\t\tADT7462_F2_ALARM\t\t0x04\n#define\t\tADT7462_F3_ALARM\t\t0x08\n#define\t\tADT7462_F4_ALARM\t\t0x10\n#define\t\tADT7462_F5_ALARM\t\t0x20\n#define\t\tADT7462_F6_ALARM\t\t0x40\n#define\t\tADT7462_F7_ALARM\t\t0x80\n#define ADT7462_ALARM1\t\t\t\t0x0000\n#define ADT7462_ALARM2\t\t\t\t0x0100\n#define ADT7462_ALARM3\t\t\t\t0x0200\n#define ADT7462_ALARM4\t\t\t\t0x0300\n#define ADT7462_ALARM_REG_SHIFT\t\t\t8\n#define ADT7462_ALARM_FLAG_MASK\t\t\t0x0F\n\n#define ADT7462_TEMP_COUNT\t\t4\n#define ADT7462_TEMP_REG(x)\t\t(ADT7462_REG_TEMP_BASE_ADDR + ((x) * 2))\n#define ADT7462_TEMP_MIN_REG(x)\t\t(ADT7462_REG_MIN_TEMP_BASE_ADDR + (x))\n#define ADT7462_TEMP_MAX_REG(x)\t\t(ADT7462_REG_MAX_TEMP_BASE_ADDR + (x))\n#define TEMP_FRAC_OFFSET\t\t6\n\n#define ADT7462_FAN_COUNT\t\t8\n#define ADT7462_REG_FAN_MIN(x)\t\t(ADT7462_REG_FAN_MIN_BASE_ADDR + (x))\n\n#define ADT7462_PWM_COUNT\t\t4\n#define ADT7462_REG_PWM(x)\t\t(ADT7462_REG_PWM_BASE_ADDR + (x))\n#define ADT7462_REG_PWM_MIN(x)\t\t(ADT7462_REG_PWM_MIN_BASE_ADDR + (x))\n#define ADT7462_REG_PWM_TMIN(x)\t\t\\\n\t(ADT7462_REG_PWM_TEMP_MIN_BASE_ADDR + (x))\n#define ADT7462_REG_PWM_TRANGE(x)\t\\\n\t(ADT7462_REG_PWM_TEMP_RANGE_BASE_ADDR + (x))\n\n#define ADT7462_PIN_CFG_REG_COUNT\t4\n#define ADT7462_REG_PIN_CFG(x)\t\t(ADT7462_REG_PIN_CFG_BASE_ADDR + (x))\n#define ADT7462_REG_PWM_CFG(x)\t\t(ADT7462_REG_PWM_CFG_BASE_ADDR + (x))\n\n#define ADT7462_ALARM_REG_COUNT\t\t4\n\n \n#define ADT7462_VOLT_COUNT\t13\n\n#define ADT7462_VENDOR\t\t0x41\n#define ADT7462_DEVICE\t\t0x62\n \n#define ADT7462_REVISION\t0x04\n\n \n#define SENSOR_REFRESH_INTERVAL\t(2 * HZ)\n\n \n#define LIMIT_REFRESH_INTERVAL\t(60 * HZ)\n\n \n#define FAN_PERIOD_TO_RPM(x)\t((90000 * 60) / (x))\n#define FAN_RPM_TO_PERIOD\tFAN_PERIOD_TO_RPM\n#define FAN_PERIOD_INVALID\t65535\n#define FAN_DATA_VALID(x)\t((x) && (x) != FAN_PERIOD_INVALID)\n\n#define MASK_AND_SHIFT(value, prefix)\t\\\n\t(((value) & prefix##_MASK) >> prefix##_SHIFT)\n\nstruct adt7462_data {\n\tstruct i2c_client\t*client;\n\tstruct mutex\t\tlock;\n\tchar\t\t\tsensors_valid;\n\tchar\t\t\tlimits_valid;\n\tunsigned long\t\tsensors_last_updated;\t \n\tunsigned long\t\tlimits_last_updated;\t \n\n\tu8\t\t\ttemp[ADT7462_TEMP_COUNT];\n\t\t\t\t \n\tu8\t\t\ttemp_frac[ADT7462_TEMP_COUNT];\n\tu8\t\t\ttemp_min[ADT7462_TEMP_COUNT];\n\tu8\t\t\ttemp_max[ADT7462_TEMP_COUNT];\n\tu16\t\t\tfan[ADT7462_FAN_COUNT];\n\tu8\t\t\tfan_enabled;\n\tu8\t\t\tfan_min[ADT7462_FAN_COUNT];\n\tu8\t\t\tcfg2;\n\tu8\t\t\tpwm[ADT7462_PWM_COUNT];\n\tu8\t\t\tpin_cfg[ADT7462_PIN_CFG_REG_COUNT];\n\tu8\t\t\tvoltages[ADT7462_VOLT_COUNT];\n\tu8\t\t\tvolt_max[ADT7462_VOLT_COUNT];\n\tu8\t\t\tvolt_min[ADT7462_VOLT_COUNT];\n\tu8\t\t\tpwm_min[ADT7462_PWM_COUNT];\n\tu8\t\t\tpwm_tmin[ADT7462_PWM_COUNT];\n\tu8\t\t\tpwm_trange[ADT7462_PWM_COUNT];\n\tu8\t\t\tpwm_max;\t \n\tu8\t\t\tpwm_cfg[ADT7462_PWM_COUNT];\n\tu8\t\t\talarms[ADT7462_ALARM_REG_COUNT];\n};\n\n \nstatic inline int adt7462_read_word_data(struct i2c_client *client, u8 reg)\n{\n\tu16 foo;\n\tfoo = i2c_smbus_read_byte_data(client, reg);\n\tfoo |= ((u16)i2c_smbus_read_byte_data(client, reg + 1) << 8);\n\treturn foo;\n}\n\n \nstatic int ADT7462_REG_FAN(int fan)\n{\n\tif (fan < 4)\n\t\treturn ADT7462_REG_FAN_BASE_ADDR + (2 * fan);\n\treturn ADT7462_REG_FAN2_BASE_ADDR + (2 * (fan - 4));\n}\n\n \nstatic int ADT7462_REG_VOLT_MAX(struct adt7462_data *data, int which)\n{\n\tswitch (which) {\n\tcase 0:\n\t\tif (!(data->pin_cfg[0] & ADT7462_PIN7_INPUT))\n\t\t\treturn 0x7C;\n\t\tbreak;\n\tcase 1:\n\t\treturn 0x69;\n\tcase 2:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN22_INPUT))\n\t\t\treturn 0x7F;\n\t\tbreak;\n\tcase 3:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN21_INPUT))\n\t\t\treturn 0x7E;\n\t\tbreak;\n\tcase 4:\n\t\tif (!(data->pin_cfg[0] & ADT7462_DIODE3_INPUT))\n\t\t\treturn 0x4B;\n\t\tbreak;\n\tcase 5:\n\t\tif (!(data->pin_cfg[0] & ADT7462_DIODE1_INPUT))\n\t\t\treturn 0x49;\n\t\tbreak;\n\tcase 6:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN13_INPUT))\n\t\t\treturn 0x68;\n\t\tbreak;\n\tcase 7:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN8_INPUT))\n\t\t\treturn 0x7D;\n\t\tbreak;\n\tcase 8:\n\t\tif (!(data->pin_cfg[2] & ADT7462_PIN26_VOLT_INPUT))\n\t\t\treturn 0x6C;\n\t\tbreak;\n\tcase 9:\n\t\tif (!(data->pin_cfg[2] & ADT7462_PIN25_VOLT_INPUT))\n\t\t\treturn 0x6B;\n\t\tbreak;\n\tcase 10:\n\t\treturn 0x6A;\n\tcase 11:\n\t\tif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\n\t\t\t\t\tADT7462_PIN28_VOLT &&\n\t\t    !(data->pin_cfg[0] & ADT7462_VID_INPUT))\n\t\t\treturn 0x50;\n\t\tbreak;\n\tcase 12:\n\t\tif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\n\t\t\t\t\tADT7462_PIN28_VOLT &&\n\t\t    !(data->pin_cfg[0] & ADT7462_VID_INPUT))\n\t\t\treturn 0x4C;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ADT7462_REG_VOLT_MIN(struct adt7462_data *data, int which)\n{\n\tswitch (which) {\n\tcase 0:\n\t\tif (!(data->pin_cfg[0] & ADT7462_PIN7_INPUT))\n\t\t\treturn 0x6D;\n\t\tbreak;\n\tcase 1:\n\t\treturn 0x72;\n\tcase 2:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN22_INPUT))\n\t\t\treturn 0x6F;\n\t\tbreak;\n\tcase 3:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN21_INPUT))\n\t\t\treturn 0x71;\n\t\tbreak;\n\tcase 4:\n\t\tif (!(data->pin_cfg[0] & ADT7462_DIODE3_INPUT))\n\t\t\treturn 0x47;\n\t\tbreak;\n\tcase 5:\n\t\tif (!(data->pin_cfg[0] & ADT7462_DIODE1_INPUT))\n\t\t\treturn 0x45;\n\t\tbreak;\n\tcase 6:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN13_INPUT))\n\t\t\treturn 0x70;\n\t\tbreak;\n\tcase 7:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN8_INPUT))\n\t\t\treturn 0x6E;\n\t\tbreak;\n\tcase 8:\n\t\tif (!(data->pin_cfg[2] & ADT7462_PIN26_VOLT_INPUT))\n\t\t\treturn 0x75;\n\t\tbreak;\n\tcase 9:\n\t\tif (!(data->pin_cfg[2] & ADT7462_PIN25_VOLT_INPUT))\n\t\t\treturn 0x74;\n\t\tbreak;\n\tcase 10:\n\t\treturn 0x73;\n\tcase 11:\n\t\tif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\n\t\t\t\t\tADT7462_PIN28_VOLT &&\n\t\t    !(data->pin_cfg[0] & ADT7462_VID_INPUT))\n\t\t\treturn 0x76;\n\t\tbreak;\n\tcase 12:\n\t\tif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\n\t\t\t\t\tADT7462_PIN28_VOLT &&\n\t\t    !(data->pin_cfg[0] & ADT7462_VID_INPUT))\n\t\t\treturn 0x77;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ADT7462_REG_VOLT(struct adt7462_data *data, int which)\n{\n\tswitch (which) {\n\tcase 0:\n\t\tif (!(data->pin_cfg[0] & ADT7462_PIN7_INPUT))\n\t\t\treturn 0xA3;\n\t\tbreak;\n\tcase 1:\n\t\treturn 0x90;\n\tcase 2:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN22_INPUT))\n\t\t\treturn 0xA9;\n\t\tbreak;\n\tcase 3:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN21_INPUT))\n\t\t\treturn 0xA7;\n\t\tbreak;\n\tcase 4:\n\t\tif (!(data->pin_cfg[0] & ADT7462_DIODE3_INPUT))\n\t\t\treturn 0x8F;\n\t\tbreak;\n\tcase 5:\n\t\tif (!(data->pin_cfg[0] & ADT7462_DIODE1_INPUT))\n\t\t\treturn 0x8B;\n\t\tbreak;\n\tcase 6:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN13_INPUT))\n\t\t\treturn 0x96;\n\t\tbreak;\n\tcase 7:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN8_INPUT))\n\t\t\treturn 0xA5;\n\t\tbreak;\n\tcase 8:\n\t\tif (!(data->pin_cfg[2] & ADT7462_PIN26_VOLT_INPUT))\n\t\t\treturn 0x93;\n\t\tbreak;\n\tcase 9:\n\t\tif (!(data->pin_cfg[2] & ADT7462_PIN25_VOLT_INPUT))\n\t\t\treturn 0x92;\n\t\tbreak;\n\tcase 10:\n\t\treturn 0x91;\n\tcase 11:\n\t\tif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\n\t\t\t\t\tADT7462_PIN28_VOLT &&\n\t\t    !(data->pin_cfg[0] & ADT7462_VID_INPUT))\n\t\t\treturn 0x94;\n\t\tbreak;\n\tcase 12:\n\t\tif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\n\t\t\t\t\tADT7462_PIN28_VOLT &&\n\t\t    !(data->pin_cfg[0] & ADT7462_VID_INPUT))\n\t\t\treturn 0x95;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic const char *voltage_label(struct adt7462_data *data, int which)\n{\n\tswitch (which) {\n\tcase 0:\n\t\tif (!(data->pin_cfg[0] & ADT7462_PIN7_INPUT))\n\t\t\treturn \"+12V1\";\n\t\tbreak;\n\tcase 1:\n\t\tswitch (MASK_AND_SHIFT(data->pin_cfg[1], ADT7462_PIN23)) {\n\t\tcase 0:\n\t\t\treturn \"Vccp1\";\n\t\tcase 1:\n\t\t\treturn \"+2.5V\";\n\t\tcase 2:\n\t\t\treturn \"+1.8V\";\n\t\tcase 3:\n\t\t\treturn \"+1.5V\";\n\t\t}\n\t\tfallthrough;\n\tcase 2:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN22_INPUT))\n\t\t\treturn \"+12V3\";\n\t\tbreak;\n\tcase 3:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN21_INPUT))\n\t\t\treturn \"+5V\";\n\t\tbreak;\n\tcase 4:\n\t\tif (!(data->pin_cfg[0] & ADT7462_DIODE3_INPUT)) {\n\t\t\tif (data->pin_cfg[1] & ADT7462_PIN19_INPUT)\n\t\t\t\treturn \"+0.9V\";\n\t\t\treturn \"+1.25V\";\n\t\t}\n\t\tbreak;\n\tcase 5:\n\t\tif (!(data->pin_cfg[0] & ADT7462_DIODE1_INPUT)) {\n\t\t\tif (data->pin_cfg[1] & ADT7462_PIN19_INPUT)\n\t\t\t\treturn \"+1.8V\";\n\t\t\treturn \"+2.5V\";\n\t\t}\n\t\tbreak;\n\tcase 6:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN13_INPUT))\n\t\t\treturn \"+3.3V\";\n\t\tbreak;\n\tcase 7:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN8_INPUT))\n\t\t\treturn \"+12V2\";\n\t\tbreak;\n\tcase 8:\n\t\tswitch (MASK_AND_SHIFT(data->pin_cfg[2], ADT7462_PIN26)) {\n\t\tcase 0:\n\t\t\treturn \"Vbatt\";\n\t\tcase 1:\n\t\t\treturn \"FSB_Vtt\";\n\t\t}\n\t\tbreak;\n\tcase 9:\n\t\tswitch (MASK_AND_SHIFT(data->pin_cfg[2], ADT7462_PIN25)) {\n\t\tcase 0:\n\t\t\treturn \"+3.3V\";\n\t\tcase 1:\n\t\t\treturn \"+1.2V1\";\n\t\t}\n\t\tbreak;\n\tcase 10:\n\t\tswitch (MASK_AND_SHIFT(data->pin_cfg[2], ADT7462_PIN24)) {\n\t\tcase 0:\n\t\t\treturn \"Vccp2\";\n\t\tcase 1:\n\t\t\treturn \"+2.5V\";\n\t\tcase 2:\n\t\t\treturn \"+1.8V\";\n\t\tcase 3:\n\t\t\treturn \"+1.5\";\n\t\t}\n\t\tfallthrough;\n\tcase 11:\n\t\tif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\n\t\t\t\t\tADT7462_PIN28_VOLT &&\n\t\t    !(data->pin_cfg[0] & ADT7462_VID_INPUT))\n\t\t\treturn \"+1.5V ICH\";\n\t\tbreak;\n\tcase 12:\n\t\tif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\n\t\t\t\t\tADT7462_PIN28_VOLT &&\n\t\t    !(data->pin_cfg[0] & ADT7462_VID_INPUT))\n\t\t\treturn \"+1.5V 3GPIO\";\n\t\tbreak;\n\t}\n\treturn \"N/A\";\n}\n\n \nstatic int voltage_multiplier(struct adt7462_data *data, int which)\n{\n\tswitch (which) {\n\tcase 0:\n\t\tif (!(data->pin_cfg[0] & ADT7462_PIN7_INPUT))\n\t\t\treturn 62500;\n\t\tbreak;\n\tcase 1:\n\t\tswitch (MASK_AND_SHIFT(data->pin_cfg[1], ADT7462_PIN23)) {\n\t\tcase 0:\n\t\t\tif (data->pin_cfg[0] & ADT7462_VID_INPUT)\n\t\t\t\treturn 12500;\n\t\t\treturn 6250;\n\t\tcase 1:\n\t\t\treturn 13000;\n\t\tcase 2:\n\t\t\treturn 9400;\n\t\tcase 3:\n\t\t\treturn 7800;\n\t\t}\n\t\tfallthrough;\n\tcase 2:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN22_INPUT))\n\t\t\treturn 62500;\n\t\tbreak;\n\tcase 3:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN21_INPUT))\n\t\t\treturn 26000;\n\t\tbreak;\n\tcase 4:\n\t\tif (!(data->pin_cfg[0] & ADT7462_DIODE3_INPUT)) {\n\t\t\tif (data->pin_cfg[1] & ADT7462_PIN19_INPUT)\n\t\t\t\treturn 4690;\n\t\t\treturn 6500;\n\t\t}\n\t\tbreak;\n\tcase 5:\n\t\tif (!(data->pin_cfg[0] & ADT7462_DIODE1_INPUT)) {\n\t\t\tif (data->pin_cfg[1] & ADT7462_PIN15_INPUT)\n\t\t\t\treturn 9400;\n\t\t\treturn 13000;\n\t\t}\n\t\tbreak;\n\tcase 6:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN13_INPUT))\n\t\t\treturn 17200;\n\t\tbreak;\n\tcase 7:\n\t\tif (!(data->pin_cfg[1] & ADT7462_PIN8_INPUT))\n\t\t\treturn 62500;\n\t\tbreak;\n\tcase 8:\n\t\tswitch (MASK_AND_SHIFT(data->pin_cfg[2], ADT7462_PIN26)) {\n\t\tcase 0:\n\t\t\treturn 15600;\n\t\tcase 1:\n\t\t\treturn 6250;\n\t\t}\n\t\tbreak;\n\tcase 9:\n\t\tswitch (MASK_AND_SHIFT(data->pin_cfg[2], ADT7462_PIN25)) {\n\t\tcase 0:\n\t\t\treturn 17200;\n\t\tcase 1:\n\t\t\treturn 6250;\n\t\t}\n\t\tbreak;\n\tcase 10:\n\t\tswitch (MASK_AND_SHIFT(data->pin_cfg[2], ADT7462_PIN24)) {\n\t\tcase 0:\n\t\t\treturn 6250;\n\t\tcase 1:\n\t\t\treturn 13000;\n\t\tcase 2:\n\t\t\treturn 9400;\n\t\tcase 3:\n\t\t\treturn 7800;\n\t\t}\n\t\tfallthrough;\n\tcase 11:\n\tcase 12:\n\t\tif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\n\t\t\t\t\tADT7462_PIN28_VOLT &&\n\t\t    !(data->pin_cfg[0] & ADT7462_VID_INPUT))\n\t\t\treturn 7800;\n\t}\n\treturn 0;\n}\n\nstatic int temp_enabled(struct adt7462_data *data, int which)\n{\n\tswitch (which) {\n\tcase 0:\n\tcase 2:\n\t\treturn 1;\n\tcase 1:\n\t\tif (data->pin_cfg[0] & ADT7462_DIODE1_INPUT)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 3:\n\t\tif (data->pin_cfg[0] & ADT7462_DIODE3_INPUT)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const char *temp_label(struct adt7462_data *data, int which)\n{\n\tswitch (which) {\n\tcase 0:\n\t\treturn \"local\";\n\tcase 1:\n\t\tif (data->pin_cfg[0] & ADT7462_DIODE1_INPUT)\n\t\t\treturn \"remote1\";\n\t\tbreak;\n\tcase 2:\n\t\treturn \"remote2\";\n\tcase 3:\n\t\tif (data->pin_cfg[0] & ADT7462_DIODE3_INPUT)\n\t\t\treturn \"remote3\";\n\t\tbreak;\n\t}\n\treturn \"N/A\";\n}\n\n \n#define NUM_TRANGE_VALUES\t16\nstatic const int trange_values[NUM_TRANGE_VALUES] = {\n\t2000,\n\t2500,\n\t3300,\n\t4000,\n\t5000,\n\t6700,\n\t8000,\n\t10000,\n\t13300,\n\t16000,\n\t20000,\n\t26700,\n\t32000,\n\t40000,\n\t53300,\n\t80000\n};\n\nstatic int find_trange_value(int trange)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_TRANGE_VALUES; i++)\n\t\tif (trange_values[i] == trange)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic struct adt7462_data *adt7462_update_device(struct device *dev)\n{\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long local_jiffies = jiffies;\n\tint i;\n\n\tmutex_lock(&data->lock);\n\tif (time_before(local_jiffies, data->sensors_last_updated +\n\t\tSENSOR_REFRESH_INTERVAL)\n\t\t&& data->sensors_valid)\n\t\tgoto no_sensor_update;\n\n\tfor (i = 0; i < ADT7462_TEMP_COUNT; i++) {\n\t\t \n\t\tdata->temp_frac[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADT7462_TEMP_REG(i));\n\t\tdata->temp[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADT7462_TEMP_REG(i) + 1);\n\t}\n\n\tfor (i = 0; i < ADT7462_FAN_COUNT; i++)\n\t\tdata->fan[i] = adt7462_read_word_data(client,\n\t\t\t\t\t\tADT7462_REG_FAN(i));\n\n\tdata->fan_enabled = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tADT7462_REG_FAN_ENABLE);\n\n\tfor (i = 0; i < ADT7462_PWM_COUNT; i++)\n\t\tdata->pwm[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADT7462_REG_PWM(i));\n\n\tfor (i = 0; i < ADT7462_PIN_CFG_REG_COUNT; i++)\n\t\tdata->pin_cfg[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\tADT7462_REG_PIN_CFG(i));\n\n\tfor (i = 0; i < ADT7462_VOLT_COUNT; i++) {\n\t\tint reg = ADT7462_REG_VOLT(data, i);\n\t\tif (!reg)\n\t\t\tdata->voltages[i] = 0;\n\t\telse\n\t\t\tdata->voltages[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t\t\t     reg);\n\t}\n\n\tdata->alarms[0] = i2c_smbus_read_byte_data(client, ADT7462_REG_ALARM1);\n\tdata->alarms[1] = i2c_smbus_read_byte_data(client, ADT7462_REG_ALARM2);\n\tdata->alarms[2] = i2c_smbus_read_byte_data(client, ADT7462_REG_ALARM3);\n\tdata->alarms[3] = i2c_smbus_read_byte_data(client, ADT7462_REG_ALARM4);\n\n\tdata->sensors_last_updated = local_jiffies;\n\tdata->sensors_valid = 1;\n\nno_sensor_update:\n\tif (time_before(local_jiffies, data->limits_last_updated +\n\t\tLIMIT_REFRESH_INTERVAL)\n\t\t&& data->limits_valid)\n\t\tgoto out;\n\n\tfor (i = 0; i < ADT7462_TEMP_COUNT; i++) {\n\t\tdata->temp_min[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADT7462_TEMP_MIN_REG(i));\n\t\tdata->temp_max[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADT7462_TEMP_MAX_REG(i));\n\t}\n\n\tfor (i = 0; i < ADT7462_FAN_COUNT; i++)\n\t\tdata->fan_min[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADT7462_REG_FAN_MIN(i));\n\n\tfor (i = 0; i < ADT7462_VOLT_COUNT; i++) {\n\t\tint reg = ADT7462_REG_VOLT_MAX(data, i);\n\t\tdata->volt_max[i] =\n\t\t\t(reg ? i2c_smbus_read_byte_data(client, reg) : 0);\n\n\t\treg = ADT7462_REG_VOLT_MIN(data, i);\n\t\tdata->volt_min[i] =\n\t\t\t(reg ? i2c_smbus_read_byte_data(client, reg) : 0);\n\t}\n\n\tfor (i = 0; i < ADT7462_PWM_COUNT; i++) {\n\t\tdata->pwm_min[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADT7462_REG_PWM_MIN(i));\n\t\tdata->pwm_tmin[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADT7462_REG_PWM_TMIN(i));\n\t\tdata->pwm_trange[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADT7462_REG_PWM_TRANGE(i));\n\t\tdata->pwm_cfg[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADT7462_REG_PWM_CFG(i));\n\t}\n\n\tdata->pwm_max = i2c_smbus_read_byte_data(client, ADT7462_REG_PWM_MAX);\n\n\tdata->cfg2 = i2c_smbus_read_byte_data(client, ADT7462_REG_CFG2);\n\n\tdata->limits_last_updated = local_jiffies;\n\tdata->limits_valid = 1;\n\nout:\n\tmutex_unlock(&data->lock);\n\treturn data;\n}\n\nstatic ssize_t temp_min_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\n\tif (!temp_enabled(data, attr->index))\n\t\treturn sprintf(buf, \"0\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", 1000 * (data->temp_min[attr->index] - 64));\n}\n\nstatic ssize_t temp_min_store(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp) || !temp_enabled(data, attr->index))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, -64000, 191000);\n\ttemp = DIV_ROUND_CLOSEST(temp, 1000) + 64;\n\n\tmutex_lock(&data->lock);\n\tdata->temp_min[attr->index] = temp;\n\ti2c_smbus_write_byte_data(client, ADT7462_TEMP_MIN_REG(attr->index),\n\t\t\t\t  temp);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t temp_max_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\n\tif (!temp_enabled(data, attr->index))\n\t\treturn sprintf(buf, \"0\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", 1000 * (data->temp_max[attr->index] - 64));\n}\n\nstatic ssize_t temp_max_store(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp) || !temp_enabled(data, attr->index))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, -64000, 191000);\n\ttemp = DIV_ROUND_CLOSEST(temp, 1000) + 64;\n\n\tmutex_lock(&data->lock);\n\tdata->temp_max[attr->index] = temp;\n\ti2c_smbus_write_byte_data(client, ADT7462_TEMP_MAX_REG(attr->index),\n\t\t\t\t  temp);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\tu8 frac = data->temp_frac[attr->index] >> TEMP_FRAC_OFFSET;\n\n\tif (!temp_enabled(data, attr->index))\n\t\treturn sprintf(buf, \"0\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", 1000 * (data->temp[attr->index] - 64) +\n\t\t\t\t     250 * frac);\n}\n\nstatic ssize_t temp_label_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\n\treturn sprintf(buf, \"%s\\n\", temp_label(data, attr->index));\n}\n\nstatic ssize_t volt_max_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\tint x = voltage_multiplier(data, attr->index);\n\n\tx *= data->volt_max[attr->index];\n\tx /= 1000;  \n\n\treturn sprintf(buf, \"%d\\n\", x);\n}\n\nstatic ssize_t volt_max_store(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint x = voltage_multiplier(data, attr->index);\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp) || !x)\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, 0, 255 * x / 1000);\n\ttemp *= 1000;  \n\ttemp = DIV_ROUND_CLOSEST(temp, x);\n\n\tmutex_lock(&data->lock);\n\tdata->volt_max[attr->index] = temp;\n\ti2c_smbus_write_byte_data(client,\n\t\t\t\t  ADT7462_REG_VOLT_MAX(data, attr->index),\n\t\t\t\t  temp);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t volt_min_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\tint x = voltage_multiplier(data, attr->index);\n\n\tx *= data->volt_min[attr->index];\n\tx /= 1000;  \n\n\treturn sprintf(buf, \"%d\\n\", x);\n}\n\nstatic ssize_t volt_min_store(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint x = voltage_multiplier(data, attr->index);\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp) || !x)\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, 0, 255 * x / 1000);\n\ttemp *= 1000;  \n\ttemp = DIV_ROUND_CLOSEST(temp, x);\n\n\tmutex_lock(&data->lock);\n\tdata->volt_min[attr->index] = temp;\n\ti2c_smbus_write_byte_data(client,\n\t\t\t\t  ADT7462_REG_VOLT_MIN(data, attr->index),\n\t\t\t\t  temp);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t voltage_show(struct device *dev,\n\t\t\t    struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\tint x = voltage_multiplier(data, attr->index);\n\n\tx *= data->voltages[attr->index];\n\tx /= 1000;  \n\n\treturn sprintf(buf, \"%d\\n\", x);\n}\n\nstatic ssize_t voltage_label_show(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\n\treturn sprintf(buf, \"%s\\n\", voltage_label(data, attr->index));\n}\n\nstatic ssize_t alarm_show(struct device *dev,\n\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\tint reg = attr->index >> ADT7462_ALARM_REG_SHIFT;\n\tint mask = attr->index & ADT7462_ALARM_FLAG_MASK;\n\n\tif (data->alarms[reg] & mask)\n\t\treturn sprintf(buf, \"1\\n\");\n\telse\n\t\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic int fan_enabled(struct adt7462_data *data, int fan)\n{\n\treturn data->fan_enabled & (1 << fan);\n}\n\nstatic ssize_t fan_min_show(struct device *dev,\n\t\t\t    struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\tu16 temp;\n\n\t \n\ttemp = data->fan_min[attr->index];\n\ttemp <<= 8;\n\n\tif (!fan_enabled(data, attr->index) ||\n\t    !FAN_DATA_VALID(temp))\n\t\treturn sprintf(buf, \"0\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", FAN_PERIOD_TO_RPM(temp));\n}\n\nstatic ssize_t fan_min_store(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp) || !temp ||\n\t    !fan_enabled(data, attr->index))\n\t\treturn -EINVAL;\n\n\ttemp = FAN_RPM_TO_PERIOD(temp);\n\ttemp >>= 8;\n\ttemp = clamp_val(temp, 1, 255);\n\n\tmutex_lock(&data->lock);\n\tdata->fan_min[attr->index] = temp;\n\ti2c_smbus_write_byte_data(client, ADT7462_REG_FAN_MIN(attr->index),\n\t\t\t\t  temp);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t fan_show(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\n\tif (!fan_enabled(data, attr->index) ||\n\t    !FAN_DATA_VALID(data->fan[attr->index]))\n\t\treturn sprintf(buf, \"0\\n\");\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       FAN_PERIOD_TO_RPM(data->fan[attr->index]));\n}\n\nstatic ssize_t force_pwm_max_show(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (data->cfg2 & ADT7462_FSPD_MASK ? 1 : 0));\n}\n\nstatic ssize_t force_pwm_max_store(struct device *dev,\n\t\t\t\t   struct device_attribute *devattr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\tu8 reg;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\treg = i2c_smbus_read_byte_data(client, ADT7462_REG_CFG2);\n\tif (temp)\n\t\treg |= ADT7462_FSPD_MASK;\n\telse\n\t\treg &= ~ADT7462_FSPD_MASK;\n\tdata->cfg2 = reg;\n\ti2c_smbus_write_byte_data(client, ADT7462_REG_CFG2, reg);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t pwm_show(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm[attr->index]);\n}\n\nstatic ssize_t pwm_store(struct device *dev, struct device_attribute *devattr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, 0, 255);\n\n\tmutex_lock(&data->lock);\n\tdata->pwm[attr->index] = temp;\n\ti2c_smbus_write_byte_data(client, ADT7462_REG_PWM(attr->index), temp);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t pwm_max_show(struct device *dev,\n\t\t\t    struct device_attribute *devattr, char *buf)\n{\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm_max);\n}\n\nstatic ssize_t pwm_max_store(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, 0, 255);\n\n\tmutex_lock(&data->lock);\n\tdata->pwm_max = temp;\n\ti2c_smbus_write_byte_data(client, ADT7462_REG_PWM_MAX, temp);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t pwm_min_show(struct device *dev,\n\t\t\t    struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm_min[attr->index]);\n}\n\nstatic ssize_t pwm_min_store(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, 0, 255);\n\n\tmutex_lock(&data->lock);\n\tdata->pwm_min[attr->index] = temp;\n\ti2c_smbus_write_byte_data(client, ADT7462_REG_PWM_MIN(attr->index),\n\t\t\t\t  temp);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t pwm_hyst_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", 1000 *\n\t\t      (data->pwm_trange[attr->index] & ADT7462_PWM_HYST_MASK));\n}\n\nstatic ssize_t pwm_hyst_store(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, 0, 15000);\n\ttemp = DIV_ROUND_CLOSEST(temp, 1000);\n\n\t \n\ttemp &= ADT7462_PWM_HYST_MASK;\n\ttemp |= data->pwm_trange[attr->index] & ADT7462_PWM_RANGE_MASK;\n\n\tmutex_lock(&data->lock);\n\tdata->pwm_trange[attr->index] = temp;\n\ti2c_smbus_write_byte_data(client, ADT7462_REG_PWM_TRANGE(attr->index),\n\t\t\t\t  temp);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t pwm_tmax_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\n\t \n\tint trange = trange_values[data->pwm_trange[attr->index] >>\n\t\t\t\t   ADT7462_PWM_RANGE_SHIFT];\n\tint tmin = (data->pwm_tmin[attr->index] - 64) * 1000;\n\n\treturn sprintf(buf, \"%d\\n\", tmin + trange);\n}\n\nstatic ssize_t pwm_tmax_store(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      const char *buf, size_t count)\n{\n\tint temp;\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint tmin, trange_value;\n\tlong trange;\n\n\tif (kstrtol(buf, 10, &trange))\n\t\treturn -EINVAL;\n\n\t \n\ttmin = (data->pwm_tmin[attr->index] - 64) * 1000;\n\ttrange_value = find_trange_value(trange - tmin);\n\tif (trange_value < 0)\n\t\treturn trange_value;\n\n\ttemp = trange_value << ADT7462_PWM_RANGE_SHIFT;\n\ttemp |= data->pwm_trange[attr->index] & ADT7462_PWM_HYST_MASK;\n\n\tmutex_lock(&data->lock);\n\tdata->pwm_trange[attr->index] = temp;\n\ti2c_smbus_write_byte_data(client, ADT7462_REG_PWM_TRANGE(attr->index),\n\t\t\t\t  temp);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t pwm_tmin_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", 1000 * (data->pwm_tmin[attr->index] - 64));\n}\n\nstatic ssize_t pwm_tmin_store(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, -64000, 191000);\n\ttemp = DIV_ROUND_CLOSEST(temp, 1000) + 64;\n\n\tmutex_lock(&data->lock);\n\tdata->pwm_tmin[attr->index] = temp;\n\ti2c_smbus_write_byte_data(client, ADT7462_REG_PWM_TMIN(attr->index),\n\t\t\t\t  temp);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t pwm_auto_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\tint cfg = data->pwm_cfg[attr->index] >> ADT7462_PWM_CHANNEL_SHIFT;\n\n\tswitch (cfg) {\n\tcase 4:  \n\t\treturn sprintf(buf, \"0\\n\");\n\tcase 7:  \n\t\treturn sprintf(buf, \"1\\n\");\n\tdefault:  \n\t\treturn sprintf(buf, \"2\\n\");\n\t}\n}\n\nstatic void set_pwm_channel(struct i2c_client *client,\n\t\t\t    struct adt7462_data *data,\n\t\t\t    int which,\n\t\t\t    int value)\n{\n\tint temp = data->pwm_cfg[which] & ~ADT7462_PWM_CHANNEL_MASK;\n\ttemp |= value << ADT7462_PWM_CHANNEL_SHIFT;\n\n\tmutex_lock(&data->lock);\n\tdata->pwm_cfg[which] = temp;\n\ti2c_smbus_write_byte_data(client, ADT7462_REG_PWM_CFG(which), temp);\n\tmutex_unlock(&data->lock);\n}\n\nstatic ssize_t pwm_auto_store(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\tswitch (temp) {\n\tcase 0:  \n\t\tset_pwm_channel(client, data, attr->index, 4);\n\t\treturn count;\n\tcase 1:  \n\t\tset_pwm_channel(client, data, attr->index, 7);\n\t\treturn count;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t pwm_auto_temp_show(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = adt7462_update_device(dev);\n\tint channel = data->pwm_cfg[attr->index] >> ADT7462_PWM_CHANNEL_SHIFT;\n\n\tswitch (channel) {\n\tcase 0:  \n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t\treturn sprintf(buf, \"%d\\n\", (1 << channel));\n\tcase 5:  \n\t\treturn sprintf(buf, \"9\\n\");\n\tcase 6:\n\t\treturn sprintf(buf, \"15\\n\");\n\tdefault:\n\t\treturn sprintf(buf, \"0\\n\");\n\t}\n}\n\nstatic int cvt_auto_temp(int input)\n{\n\tif (input == 0xF)\n\t\treturn 6;\n\tif (input == 0x9)\n\t\treturn 5;\n\tif (input < 1 || !is_power_of_2(input))\n\t\treturn -EINVAL;\n\treturn ilog2(input);\n}\n\nstatic ssize_t pwm_auto_temp_store(struct device *dev,\n\t\t\t\t   struct device_attribute *devattr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7462_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = cvt_auto_temp(temp);\n\tif (temp < 0)\n\t\treturn temp;\n\n\tset_pwm_channel(client, data, attr->index, temp);\n\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp_max, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp_max, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_max, temp_max, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp4_max, temp_max, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_min, temp_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_min, temp_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp4_min, temp_min, 3);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_input, temp, 3);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_label, temp_label, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_label, temp_label, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_label, temp_label, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_label, temp_label, 3);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_alarm, alarm,\n\t\t\t     ADT7462_ALARM1 | ADT7462_LT_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_alarm, alarm,\n\t\t\t     ADT7462_ALARM1 | ADT7462_R1T_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_alarm, alarm,\n\t\t\t     ADT7462_ALARM1 | ADT7462_R2T_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_alarm, alarm,\n\t\t\t     ADT7462_ALARM1 | ADT7462_R3T_ALARM);\n\nstatic SENSOR_DEVICE_ATTR_RW(in1_max, volt_max, 0);\nstatic SENSOR_DEVICE_ATTR_RW(in2_max, volt_max, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in3_max, volt_max, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in4_max, volt_max, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in5_max, volt_max, 4);\nstatic SENSOR_DEVICE_ATTR_RW(in6_max, volt_max, 5);\nstatic SENSOR_DEVICE_ATTR_RW(in7_max, volt_max, 6);\nstatic SENSOR_DEVICE_ATTR_RW(in8_max, volt_max, 7);\nstatic SENSOR_DEVICE_ATTR_RW(in9_max, volt_max, 8);\nstatic SENSOR_DEVICE_ATTR_RW(in10_max, volt_max, 9);\nstatic SENSOR_DEVICE_ATTR_RW(in11_max, volt_max, 10);\nstatic SENSOR_DEVICE_ATTR_RW(in12_max, volt_max, 11);\nstatic SENSOR_DEVICE_ATTR_RW(in13_max, volt_max, 12);\n\nstatic SENSOR_DEVICE_ATTR_RW(in1_min, volt_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(in2_min, volt_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in3_min, volt_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in4_min, volt_min, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in5_min, volt_min, 4);\nstatic SENSOR_DEVICE_ATTR_RW(in6_min, volt_min, 5);\nstatic SENSOR_DEVICE_ATTR_RW(in7_min, volt_min, 6);\nstatic SENSOR_DEVICE_ATTR_RW(in8_min, volt_min, 7);\nstatic SENSOR_DEVICE_ATTR_RW(in9_min, volt_min, 8);\nstatic SENSOR_DEVICE_ATTR_RW(in10_min, volt_min, 9);\nstatic SENSOR_DEVICE_ATTR_RW(in11_min, volt_min, 10);\nstatic SENSOR_DEVICE_ATTR_RW(in12_min, volt_min, 11);\nstatic SENSOR_DEVICE_ATTR_RW(in13_min, volt_min, 12);\n\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, voltage, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, voltage, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, voltage, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, voltage, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in5_input, voltage, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in6_input, voltage, 5);\nstatic SENSOR_DEVICE_ATTR_RO(in7_input, voltage, 6);\nstatic SENSOR_DEVICE_ATTR_RO(in8_input, voltage, 7);\nstatic SENSOR_DEVICE_ATTR_RO(in9_input, voltage, 8);\nstatic SENSOR_DEVICE_ATTR_RO(in10_input, voltage, 9);\nstatic SENSOR_DEVICE_ATTR_RO(in11_input, voltage, 10);\nstatic SENSOR_DEVICE_ATTR_RO(in12_input, voltage, 11);\nstatic SENSOR_DEVICE_ATTR_RO(in13_input, voltage, 12);\n\nstatic SENSOR_DEVICE_ATTR_RO(in1_label, voltage_label, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in2_label, voltage_label, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in3_label, voltage_label, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in4_label, voltage_label, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in5_label, voltage_label, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in6_label, voltage_label, 5);\nstatic SENSOR_DEVICE_ATTR_RO(in7_label, voltage_label, 6);\nstatic SENSOR_DEVICE_ATTR_RO(in8_label, voltage_label, 7);\nstatic SENSOR_DEVICE_ATTR_RO(in9_label, voltage_label, 8);\nstatic SENSOR_DEVICE_ATTR_RO(in10_label, voltage_label, 9);\nstatic SENSOR_DEVICE_ATTR_RO(in11_label, voltage_label, 10);\nstatic SENSOR_DEVICE_ATTR_RO(in12_label, voltage_label, 11);\nstatic SENSOR_DEVICE_ATTR_RO(in13_label, voltage_label, 12);\n\nstatic SENSOR_DEVICE_ATTR_RO(in1_alarm, alarm,\n\t\t\t     ADT7462_ALARM2 | ADT7462_V0_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(in2_alarm, alarm,\n\t\t\t     ADT7462_ALARM2 | ADT7462_V7_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(in3_alarm, alarm,\n\t\t\t     ADT7462_ALARM2 | ADT7462_V2_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(in4_alarm, alarm,\n\t\t\t     ADT7462_ALARM2 | ADT7462_V6_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(in5_alarm, alarm,\n\t\t\t     ADT7462_ALARM2 | ADT7462_V5_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(in6_alarm, alarm,\n\t\t\t     ADT7462_ALARM2 | ADT7462_V4_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(in7_alarm, alarm,\n\t\t\t     ADT7462_ALARM2 | ADT7462_V3_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(in8_alarm, alarm,\n\t\t\t     ADT7462_ALARM2 | ADT7462_V1_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(in9_alarm, alarm,\n\t\t\t     ADT7462_ALARM3 | ADT7462_V10_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(in10_alarm, alarm,\n\t\t\t     ADT7462_ALARM3 | ADT7462_V9_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(in11_alarm, alarm,\n\t\t\t     ADT7462_ALARM3 | ADT7462_V8_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(in12_alarm, alarm,\n\t\t\t     ADT7462_ALARM3 | ADT7462_V11_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(in13_alarm, alarm,\n\t\t\t     ADT7462_ALARM3 | ADT7462_V12_ALARM);\n\nstatic SENSOR_DEVICE_ATTR_RW(fan1_min, fan_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_min, fan_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan3_min, fan_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(fan4_min, fan_min, 3);\nstatic SENSOR_DEVICE_ATTR_RW(fan5_min, fan_min, 4);\nstatic SENSOR_DEVICE_ATTR_RW(fan6_min, fan_min, 5);\nstatic SENSOR_DEVICE_ATTR_RW(fan7_min, fan_min, 6);\nstatic SENSOR_DEVICE_ATTR_RW(fan8_min, fan_min, 7);\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_input, fan, 2);\nstatic SENSOR_DEVICE_ATTR_RO(fan4_input, fan, 3);\nstatic SENSOR_DEVICE_ATTR_RO(fan5_input, fan, 4);\nstatic SENSOR_DEVICE_ATTR_RO(fan6_input, fan, 5);\nstatic SENSOR_DEVICE_ATTR_RO(fan7_input, fan, 6);\nstatic SENSOR_DEVICE_ATTR_RO(fan8_input, fan, 7);\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_alarm, alarm,\n\t\t\t     ADT7462_ALARM4 | ADT7462_F0_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_alarm, alarm,\n\t\t\t     ADT7462_ALARM4 | ADT7462_F1_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_alarm, alarm,\n\t\t\t     ADT7462_ALARM4 | ADT7462_F2_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(fan4_alarm, alarm,\n\t\t\t     ADT7462_ALARM4 | ADT7462_F3_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(fan5_alarm, alarm,\n\t\t\t     ADT7462_ALARM4 | ADT7462_F4_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(fan6_alarm, alarm,\n\t\t\t     ADT7462_ALARM4 | ADT7462_F5_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(fan7_alarm, alarm,\n\t\t\t     ADT7462_ALARM4 | ADT7462_F6_ALARM);\nstatic SENSOR_DEVICE_ATTR_RO(fan8_alarm, alarm,\n\t\t\t     ADT7462_ALARM4 | ADT7462_F7_ALARM);\n\nstatic SENSOR_DEVICE_ATTR_RW(force_pwm_max, force_pwm_max, 0);\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1, pwm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2, pwm, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3, pwm, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm4, pwm, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point1_pwm, pwm_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_point1_pwm, pwm_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_point1_pwm, pwm_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm4_auto_point1_pwm, pwm_min, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point2_pwm, pwm_max, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_point2_pwm, pwm_max, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_point2_pwm, pwm_max, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm4_auto_point2_pwm, pwm_max, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_point1_hyst, pwm_hyst, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_point1_hyst, pwm_hyst, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_point1_hyst, pwm_hyst, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp4_auto_point1_hyst, pwm_hyst, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_point2_hyst, pwm_hyst, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_point2_hyst, pwm_hyst, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_point2_hyst, pwm_hyst, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp4_auto_point2_hyst, pwm_hyst, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_point1_temp, pwm_tmin, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_point1_temp, pwm_tmin, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_point1_temp, pwm_tmin, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp4_auto_point1_temp, pwm_tmin, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_point2_temp, pwm_tmax, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_point2_temp, pwm_tmax, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_point2_temp, pwm_tmax, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp4_auto_point2_temp, pwm_tmax, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_enable, pwm_auto, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_enable, pwm_auto, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_enable, pwm_auto, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm4_enable, pwm_auto, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_channels_temp, pwm_auto_temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_channels_temp, pwm_auto_temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_channels_temp, pwm_auto_temp, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm4_auto_channels_temp, pwm_auto_temp, 3);\n\nstatic struct attribute *adt7462_attrs[] = {\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp4_min.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp4_input.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_label.dev_attr.attr,\n\t&sensor_dev_attr_temp2_label.dev_attr.attr,\n\t&sensor_dev_attr_temp3_label.dev_attr.attr,\n\t&sensor_dev_attr_temp4_label.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp4_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\t&sensor_dev_attr_in6_max.dev_attr.attr,\n\t&sensor_dev_attr_in7_max.dev_attr.attr,\n\t&sensor_dev_attr_in8_max.dev_attr.attr,\n\t&sensor_dev_attr_in9_max.dev_attr.attr,\n\t&sensor_dev_attr_in10_max.dev_attr.attr,\n\t&sensor_dev_attr_in11_max.dev_attr.attr,\n\t&sensor_dev_attr_in12_max.dev_attr.attr,\n\t&sensor_dev_attr_in13_max.dev_attr.attr,\n\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in6_min.dev_attr.attr,\n\t&sensor_dev_attr_in7_min.dev_attr.attr,\n\t&sensor_dev_attr_in8_min.dev_attr.attr,\n\t&sensor_dev_attr_in9_min.dev_attr.attr,\n\t&sensor_dev_attr_in10_min.dev_attr.attr,\n\t&sensor_dev_attr_in11_min.dev_attr.attr,\n\t&sensor_dev_attr_in12_min.dev_attr.attr,\n\t&sensor_dev_attr_in13_min.dev_attr.attr,\n\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\t&sensor_dev_attr_in8_input.dev_attr.attr,\n\t&sensor_dev_attr_in9_input.dev_attr.attr,\n\t&sensor_dev_attr_in10_input.dev_attr.attr,\n\t&sensor_dev_attr_in11_input.dev_attr.attr,\n\t&sensor_dev_attr_in12_input.dev_attr.attr,\n\t&sensor_dev_attr_in13_input.dev_attr.attr,\n\n\t&sensor_dev_attr_in1_label.dev_attr.attr,\n\t&sensor_dev_attr_in2_label.dev_attr.attr,\n\t&sensor_dev_attr_in3_label.dev_attr.attr,\n\t&sensor_dev_attr_in4_label.dev_attr.attr,\n\t&sensor_dev_attr_in5_label.dev_attr.attr,\n\t&sensor_dev_attr_in6_label.dev_attr.attr,\n\t&sensor_dev_attr_in7_label.dev_attr.attr,\n\t&sensor_dev_attr_in8_label.dev_attr.attr,\n\t&sensor_dev_attr_in9_label.dev_attr.attr,\n\t&sensor_dev_attr_in10_label.dev_attr.attr,\n\t&sensor_dev_attr_in11_label.dev_attr.attr,\n\t&sensor_dev_attr_in12_label.dev_attr.attr,\n\t&sensor_dev_attr_in13_label.dev_attr.attr,\n\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in5_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in6_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in7_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in8_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in9_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in10_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in11_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in12_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in13_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan4_min.dev_attr.attr,\n\t&sensor_dev_attr_fan5_min.dev_attr.attr,\n\t&sensor_dev_attr_fan6_min.dev_attr.attr,\n\t&sensor_dev_attr_fan7_min.dev_attr.attr,\n\t&sensor_dev_attr_fan8_min.dev_attr.attr,\n\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan4_input.dev_attr.attr,\n\t&sensor_dev_attr_fan5_input.dev_attr.attr,\n\t&sensor_dev_attr_fan6_input.dev_attr.attr,\n\t&sensor_dev_attr_fan7_input.dev_attr.attr,\n\t&sensor_dev_attr_fan8_input.dev_attr.attr,\n\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan4_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan5_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan6_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan7_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan8_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_force_pwm_max.dev_attr.attr,\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\t&sensor_dev_attr_pwm4.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_point1_pwm.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_point2_pwm.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_auto_point1_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_point1_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_point1_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp4_auto_point1_hyst.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_auto_point2_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_point2_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_point2_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp4_auto_point2_hyst.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp4_auto_point1_temp.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp4_auto_point2_temp.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_enable.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm1_auto_channels_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_channels_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_channels_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_channels_temp.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(adt7462);\n\n \nstatic int adt7462_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint vendor, device, revision;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tvendor = i2c_smbus_read_byte_data(client, ADT7462_REG_VENDOR);\n\tif (vendor != ADT7462_VENDOR)\n\t\treturn -ENODEV;\n\n\tdevice = i2c_smbus_read_byte_data(client, ADT7462_REG_DEVICE);\n\tif (device != ADT7462_DEVICE)\n\t\treturn -ENODEV;\n\n\trevision = i2c_smbus_read_byte_data(client, ADT7462_REG_REVISION);\n\tif (revision != ADT7462_REVISION)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"adt7462\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int adt7462_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct adt7462_data *data;\n\tstruct device *hwmon_dev;\n\n\tdata = devm_kzalloc(dev, sizeof(struct adt7462_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tdev_info(&client->dev, \"%s chip found\\n\", client->name);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   adt7462_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id adt7462_id[] = {\n\t{ \"adt7462\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adt7462_id);\n\nstatic struct i2c_driver adt7462_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"adt7462\",\n\t},\n\t.probe\t\t= adt7462_probe,\n\t.id_table\t= adt7462_id,\n\t.detect\t\t= adt7462_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(adt7462_driver);\n\nMODULE_AUTHOR(\"Darrick J. Wong <darrick.wong@oracle.com>\");\nMODULE_DESCRIPTION(\"ADT7462 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}