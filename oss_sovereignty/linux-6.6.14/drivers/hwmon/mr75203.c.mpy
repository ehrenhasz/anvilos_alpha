{
  "module_name": "mr75203.c",
  "hash_id": "6e2c1a0489b675ae4ddfccde28b8dd0973e6aa59924950f37baca19e2b52a8db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/mr75203.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/hwmon.h>\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/units.h>\n\n \n#define PVT_IP_CONFIG\t0x04\n#define TS_NUM_MSK\tGENMASK(4, 0)\n#define TS_NUM_SFT\t0\n#define PD_NUM_MSK\tGENMASK(12, 8)\n#define PD_NUM_SFT\t8\n#define VM_NUM_MSK\tGENMASK(20, 16)\n#define VM_NUM_SFT\t16\n#define CH_NUM_MSK\tGENMASK(31, 24)\n#define CH_NUM_SFT\t24\n\n#define VM_NUM_MAX\t(VM_NUM_MSK >> VM_NUM_SFT)\n\n \n#define CLK_SYNTH\t\t0x00\n#define CLK_SYNTH_LO_SFT\t0\n#define CLK_SYNTH_HI_SFT\t8\n#define CLK_SYNTH_HOLD_SFT\t16\n#define CLK_SYNTH_EN\t\tBIT(24)\n#define CLK_SYS_CYCLES_MAX\t514\n#define CLK_SYS_CYCLES_MIN\t2\n\n#define SDIF_DISABLE\t0x04\n\n#define SDIF_STAT\t0x08\n#define SDIF_BUSY\tBIT(0)\n#define SDIF_LOCK\tBIT(1)\n\n#define SDIF_W\t\t0x0c\n#define SDIF_PROG\tBIT(31)\n#define SDIF_WRN_W\tBIT(27)\n#define SDIF_WRN_R\t0x00\n#define SDIF_ADDR_SFT\t24\n\n#define SDIF_HALT\t0x10\n#define SDIF_CTRL\t0x14\n#define SDIF_SMPL_CTRL\t0x20\n\n \n#define COM_REG_SIZE\t0x40\n\n#define SDIF_DONE(n)\t(COM_REG_SIZE + 0x14 + 0x40 * (n))\n#define SDIF_SMPL_DONE\tBIT(0)\n\n#define SDIF_DATA(n)\t(COM_REG_SIZE + 0x18 + 0x40 * (n))\n#define SAMPLE_DATA_MSK\tGENMASK(15, 0)\n\n#define HILO_RESET(n)\t(COM_REG_SIZE + 0x2c + 0x40 * (n))\n\n \n#define VM_COM_REG_SIZE\t0x200\n#define VM_SDIF_DONE(vm)\t(VM_COM_REG_SIZE + 0x34 + 0x200 * (vm))\n#define VM_SDIF_DATA(vm, ch)\t\\\n\t(VM_COM_REG_SIZE + 0x40 + 0x200 * (vm) + 0x4 * (ch))\n\n \n#define IP_CTRL\t\t\t0x00\n#define IP_RST_REL\t\tBIT(1)\n#define IP_RUN_CONT\t\tBIT(3)\n#define IP_AUTO\t\t\tBIT(8)\n#define IP_VM_MODE\t\tBIT(10)\n\n#define IP_CFG\t\t\t0x01\n#define CFG0_MODE_2\t\tBIT(0)\n#define CFG0_PARALLEL_OUT\t0\n#define CFG0_12_BIT\t\t0\n#define CFG1_VOL_MEAS_MODE\t0\n#define CFG1_PARALLEL_OUT\t0\n#define CFG1_14_BIT\t\t0\n\n#define IP_DATA\t\t0x03\n\n#define IP_POLL\t\t0x04\n#define VM_CH_INIT\tBIT(20)\n#define VM_CH_REQ\tBIT(21)\n\n#define IP_TMR\t\t\t0x05\n#define POWER_DELAY_CYCLE_256\t0x100\n#define POWER_DELAY_CYCLE_64\t0x40\n\n#define PVT_POLL_DELAY_US\t20\n#define PVT_POLL_TIMEOUT_US\t20000\n#define PVT_CONV_BITS\t\t10\n#define PVT_N_CONST\t\t90\n#define PVT_R_CONST\t\t245805\n\n#define PVT_TEMP_MIN_mC\t\t-40000\n#define PVT_TEMP_MAX_mC\t\t125000\n\n \n#define PVT_SERIES5_H_CONST\t200000\n#define PVT_SERIES5_G_CONST\t60000\n#define PVT_SERIES5_J_CONST\t-100\n#define PVT_SERIES5_CAL5_CONST\t4094\n\n \n#define PVT_SERIES6_H_CONST\t249400\n#define PVT_SERIES6_G_CONST\t57400\n#define PVT_SERIES6_J_CONST\t0\n#define PVT_SERIES6_CAL5_CONST\t4096\n\n#define TEMPERATURE_SENSOR_SERIES_5\t5\n#define TEMPERATURE_SENSOR_SERIES_6\t6\n\n#define PRE_SCALER_X1\t1\n#define PRE_SCALER_X2\t2\n\n \nstruct voltage_device {\n\tu32 vm_map;\n\tu32 ch_map;\n\tu32 pre_scaler;\n};\n\n \nstruct voltage_channels {\n\tu32 total;\n\tu8 max;\n};\n\nstruct temp_coeff {\n\tu32 h;\n\tu32 g;\n\tu32 cal5;\n\ts32 j;\n};\n\nstruct pvt_device {\n\tstruct regmap\t\t*c_map;\n\tstruct regmap\t\t*t_map;\n\tstruct regmap\t\t*p_map;\n\tstruct regmap\t\t*v_map;\n\tstruct clk\t\t*clk;\n\tstruct reset_control\t*rst;\n\tstruct dentry\t\t*dbgfs_dir;\n\tstruct voltage_device\t*vd;\n\tstruct voltage_channels\tvm_channels;\n\tstruct temp_coeff\tts_coeff;\n\tu32\t\t\tt_num;\n\tu32\t\t\tp_num;\n\tu32\t\t\tv_num;\n\tu32\t\t\tip_freq;\n};\n\nstatic ssize_t pvt_ts_coeff_j_read(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct pvt_device *pvt = file->private_data;\n\tunsigned int len;\n\tchar buf[13];\n\n\tlen = scnprintf(buf, sizeof(buf), \"%d\\n\", pvt->ts_coeff.j);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t pvt_ts_coeff_j_write(struct file *file,\n\t\t\t\t    const char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct pvt_device *pvt = file->private_data;\n\tint ret;\n\n\tret = kstrtos32_from_user(user_buf, count, 0, &pvt->ts_coeff.j);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic const struct file_operations pvt_ts_coeff_j_fops = {\n\t.read = pvt_ts_coeff_j_read,\n\t.write = pvt_ts_coeff_j_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic void devm_pvt_ts_dbgfs_remove(void *data)\n{\n\tstruct pvt_device *pvt = (struct pvt_device *)data;\n\n\tdebugfs_remove_recursive(pvt->dbgfs_dir);\n\tpvt->dbgfs_dir = NULL;\n}\n\nstatic int pvt_ts_dbgfs_create(struct pvt_device *pvt, struct device *dev)\n{\n\tpvt->dbgfs_dir = debugfs_create_dir(dev_name(dev), NULL);\n\n\tdebugfs_create_u32(\"ts_coeff_h\", 0644, pvt->dbgfs_dir,\n\t\t\t   &pvt->ts_coeff.h);\n\tdebugfs_create_u32(\"ts_coeff_g\", 0644, pvt->dbgfs_dir,\n\t\t\t   &pvt->ts_coeff.g);\n\tdebugfs_create_u32(\"ts_coeff_cal5\", 0644, pvt->dbgfs_dir,\n\t\t\t   &pvt->ts_coeff.cal5);\n\tdebugfs_create_file(\"ts_coeff_j\", 0644, pvt->dbgfs_dir, pvt,\n\t\t\t    &pvt_ts_coeff_j_fops);\n\n\treturn devm_add_action_or_reset(dev, devm_pvt_ts_dbgfs_remove, pvt);\n}\n\nstatic umode_t pvt_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tif (attr == hwmon_temp_input)\n\t\t\treturn 0444;\n\t\tbreak;\n\tcase hwmon_in:\n\t\tif (attr == hwmon_in_input)\n\t\t\treturn 0444;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic long pvt_calc_temp(struct pvt_device *pvt, u32 nbs)\n{\n\t \n\tstruct temp_coeff *ts_coeff = &pvt->ts_coeff;\n\n\ts64 tmp = ts_coeff->g +\n\t\tdiv_s64(ts_coeff->h * (s64)nbs, ts_coeff->cal5) -\n\t\tts_coeff->h / 2 +\n\t\tdiv_s64(ts_coeff->j * (s64)pvt->ip_freq, HZ_PER_MHZ);\n\n\treturn clamp_val(tmp, PVT_TEMP_MIN_mC, PVT_TEMP_MAX_mC);\n}\n\nstatic int pvt_read_temp(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct pvt_device *pvt = dev_get_drvdata(dev);\n\tstruct regmap *t_map = pvt->t_map;\n\tu32 stat, nbs;\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tret = regmap_read_poll_timeout(t_map, SDIF_DONE(channel),\n\t\t\t\t\t       stat, stat & SDIF_SMPL_DONE,\n\t\t\t\t\t       PVT_POLL_DELAY_US,\n\t\t\t\t\t       PVT_POLL_TIMEOUT_US);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_read(t_map, SDIF_DATA(channel), &nbs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tnbs &= SAMPLE_DATA_MSK;\n\n\t\t \n\t\t*val = pvt_calc_temp(pvt, nbs);\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int pvt_read_in(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct pvt_device *pvt = dev_get_drvdata(dev);\n\tstruct regmap *v_map = pvt->v_map;\n\tu32 n, stat, pre_scaler;\n\tu8 vm_idx, ch_idx;\n\tint ret;\n\n\tif (channel >= pvt->vm_channels.total)\n\t\treturn -EINVAL;\n\n\tvm_idx = pvt->vd[channel].vm_map;\n\tch_idx = pvt->vd[channel].ch_map;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\tret = regmap_read_poll_timeout(v_map, VM_SDIF_DONE(vm_idx),\n\t\t\t\t\t       stat, stat & SDIF_SMPL_DONE,\n\t\t\t\t\t       PVT_POLL_DELAY_US,\n\t\t\t\t\t       PVT_POLL_TIMEOUT_US);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_read(v_map, VM_SDIF_DATA(vm_idx, ch_idx), &n);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tn &= SAMPLE_DATA_MSK;\n\t\tpre_scaler = pvt->vd[channel].pre_scaler;\n\t\t \n\t\t*val = pre_scaler * (PVT_N_CONST * (long)n - PVT_R_CONST) /\n\t\t\t(1 << PVT_CONV_BITS);\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int pvt_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t    u32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn pvt_read_temp(dev, attr, channel, val);\n\tcase hwmon_in:\n\t\treturn pvt_read_in(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic struct hwmon_channel_info pvt_temp = {\n\t.type = hwmon_temp,\n};\n\nstatic struct hwmon_channel_info pvt_in = {\n\t.type = hwmon_in,\n};\n\nstatic const struct hwmon_ops pvt_hwmon_ops = {\n\t.is_visible = pvt_is_visible,\n\t.read = pvt_read,\n};\n\nstatic struct hwmon_chip_info pvt_chip_info = {\n\t.ops = &pvt_hwmon_ops,\n};\n\nstatic int pvt_init(struct pvt_device *pvt)\n{\n\tu16 sys_freq, key, middle, low = 4, high = 8;\n\tstruct regmap *t_map = pvt->t_map;\n\tstruct regmap *p_map = pvt->p_map;\n\tstruct regmap *v_map = pvt->v_map;\n\tu32 t_num = pvt->t_num;\n\tu32 p_num = pvt->p_num;\n\tu32 v_num = pvt->v_num;\n\tu32 clk_synth, val;\n\tint ret;\n\n\tsys_freq = clk_get_rate(pvt->clk) / HZ_PER_MHZ;\n\twhile (high >= low) {\n\t\tmiddle = (low + high + 1) / 2;\n\t\tkey = DIV_ROUND_CLOSEST(sys_freq, middle);\n\t\tif (key > CLK_SYS_CYCLES_MAX) {\n\t\t\tlow = middle + 1;\n\t\t\tcontinue;\n\t\t} else if (key < CLK_SYS_CYCLES_MIN) {\n\t\t\thigh = middle - 1;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tkey = clamp_val(key, CLK_SYS_CYCLES_MIN, CLK_SYS_CYCLES_MAX) - 2;\n\n\tclk_synth = ((key + 1) >> 1) << CLK_SYNTH_LO_SFT |\n\t\t    (key >> 1) << CLK_SYNTH_HI_SFT |\n\t\t    (key >> 1) << CLK_SYNTH_HOLD_SFT | CLK_SYNTH_EN;\n\n\tpvt->ip_freq = clk_get_rate(pvt->clk) / (key + 2);\n\n\tif (t_num) {\n\t\tret = regmap_write(t_map, SDIF_SMPL_CTRL, 0x0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(t_map, SDIF_HALT, 0x0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(t_map, CLK_SYNTH, clk_synth);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(t_map, SDIF_DISABLE, 0x0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_read_poll_timeout(t_map, SDIF_STAT,\n\t\t\t\t\t       val, !(val & SDIF_BUSY),\n\t\t\t\t\t       PVT_POLL_DELAY_US,\n\t\t\t\t\t       PVT_POLL_TIMEOUT_US);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = CFG0_MODE_2 | CFG0_PARALLEL_OUT | CFG0_12_BIT |\n\t\t      IP_CFG << SDIF_ADDR_SFT | SDIF_WRN_W | SDIF_PROG;\n\t\tret = regmap_write(t_map, SDIF_W, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_read_poll_timeout(t_map, SDIF_STAT,\n\t\t\t\t\t       val, !(val & SDIF_BUSY),\n\t\t\t\t\t       PVT_POLL_DELAY_US,\n\t\t\t\t\t       PVT_POLL_TIMEOUT_US);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = POWER_DELAY_CYCLE_256 | IP_TMR << SDIF_ADDR_SFT |\n\t\t\t      SDIF_WRN_W | SDIF_PROG;\n\t\tret = regmap_write(t_map, SDIF_W, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_read_poll_timeout(t_map, SDIF_STAT,\n\t\t\t\t\t       val, !(val & SDIF_BUSY),\n\t\t\t\t\t       PVT_POLL_DELAY_US,\n\t\t\t\t\t       PVT_POLL_TIMEOUT_US);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = IP_RST_REL | IP_RUN_CONT | IP_AUTO |\n\t\t      IP_CTRL << SDIF_ADDR_SFT |\n\t\t      SDIF_WRN_W | SDIF_PROG;\n\t\tret = regmap_write(t_map, SDIF_W, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (p_num) {\n\t\tret = regmap_write(p_map, SDIF_HALT, 0x0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(p_map, SDIF_DISABLE, BIT(p_num) - 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(p_map, CLK_SYNTH, clk_synth);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (v_num) {\n\t\tret = regmap_write(v_map, SDIF_SMPL_CTRL, 0x0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(v_map, SDIF_HALT, 0x0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(v_map, CLK_SYNTH, clk_synth);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(v_map, SDIF_DISABLE, 0x0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_read_poll_timeout(v_map, SDIF_STAT,\n\t\t\t\t\t       val, !(val & SDIF_BUSY),\n\t\t\t\t\t       PVT_POLL_DELAY_US,\n\t\t\t\t\t       PVT_POLL_TIMEOUT_US);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = (BIT(pvt->vm_channels.max) - 1) | VM_CH_INIT |\n\t\t      IP_POLL << SDIF_ADDR_SFT | SDIF_WRN_W | SDIF_PROG;\n\t\tret = regmap_write(v_map, SDIF_W, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_read_poll_timeout(v_map, SDIF_STAT,\n\t\t\t\t\t       val, !(val & SDIF_BUSY),\n\t\t\t\t\t       PVT_POLL_DELAY_US,\n\t\t\t\t\t       PVT_POLL_TIMEOUT_US);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = CFG1_VOL_MEAS_MODE | CFG1_PARALLEL_OUT |\n\t\t      CFG1_14_BIT | IP_CFG << SDIF_ADDR_SFT |\n\t\t      SDIF_WRN_W | SDIF_PROG;\n\t\tret = regmap_write(v_map, SDIF_W, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_read_poll_timeout(v_map, SDIF_STAT,\n\t\t\t\t\t       val, !(val & SDIF_BUSY),\n\t\t\t\t\t       PVT_POLL_DELAY_US,\n\t\t\t\t\t       PVT_POLL_TIMEOUT_US);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = POWER_DELAY_CYCLE_64 | IP_TMR << SDIF_ADDR_SFT |\n\t\t      SDIF_WRN_W | SDIF_PROG;\n\t\tret = regmap_write(v_map, SDIF_W, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_read_poll_timeout(v_map, SDIF_STAT,\n\t\t\t\t\t       val, !(val & SDIF_BUSY),\n\t\t\t\t\t       PVT_POLL_DELAY_US,\n\t\t\t\t\t       PVT_POLL_TIMEOUT_US);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = IP_RST_REL | IP_RUN_CONT | IP_AUTO | IP_VM_MODE |\n\t\t      IP_CTRL << SDIF_ADDR_SFT |\n\t\t      SDIF_WRN_W | SDIF_PROG;\n\t\tret = regmap_write(v_map, SDIF_W, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct regmap_config pvt_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n};\n\nstatic int pvt_get_regmap(struct platform_device *pdev, char *reg_name,\n\t\t\t  struct pvt_device *pvt)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap **reg_map;\n\tvoid __iomem *io_base;\n\n\tif (!strcmp(reg_name, \"common\"))\n\t\treg_map = &pvt->c_map;\n\telse if (!strcmp(reg_name, \"ts\"))\n\t\treg_map = &pvt->t_map;\n\telse if (!strcmp(reg_name, \"pd\"))\n\t\treg_map = &pvt->p_map;\n\telse if (!strcmp(reg_name, \"vm\"))\n\t\treg_map = &pvt->v_map;\n\telse\n\t\treturn -EINVAL;\n\n\tio_base = devm_platform_ioremap_resource_byname(pdev, reg_name);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\tpvt_regmap_config.name = reg_name;\n\t*reg_map = devm_regmap_init_mmio(dev, io_base, &pvt_regmap_config);\n\tif (IS_ERR(*reg_map)) {\n\t\tdev_err(dev, \"failed to init register map\\n\");\n\t\treturn PTR_ERR(*reg_map);\n\t}\n\n\treturn 0;\n}\n\nstatic void pvt_reset_control_assert(void *data)\n{\n\tstruct pvt_device *pvt = data;\n\n\treset_control_assert(pvt->rst);\n}\n\nstatic int pvt_reset_control_deassert(struct device *dev, struct pvt_device *pvt)\n{\n\tint ret;\n\n\tret = reset_control_deassert(pvt->rst);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, pvt_reset_control_assert, pvt);\n}\n\nstatic int pvt_get_active_channel(struct device *dev, struct pvt_device *pvt,\n\t\t\t\t  u32 vm_num, u32 ch_num, u8 *vm_idx)\n{\n\tu8 vm_active_ch[VM_NUM_MAX];\n\tint ret, i, j, k;\n\n\tret = device_property_read_u8_array(dev, \"moortec,vm-active-channels\",\n\t\t\t\t\t    vm_active_ch, vm_num);\n\tif (ret) {\n\t\t \n\t\tmemset(vm_active_ch, ch_num, vm_num);\n\t\tpvt->vm_channels.max = ch_num;\n\t\tpvt->vm_channels.total = ch_num * vm_num;\n\t} else {\n\t\tfor (i = 0; i < vm_num; i++) {\n\t\t\tif (vm_active_ch[i] > ch_num) {\n\t\t\t\tdev_err(dev, \"invalid active channels: %u\\n\",\n\t\t\t\t\tvm_active_ch[i]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tpvt->vm_channels.total += vm_active_ch[i];\n\n\t\t\tif (vm_active_ch[i] > pvt->vm_channels.max)\n\t\t\t\tpvt->vm_channels.max = vm_active_ch[i];\n\t\t}\n\t}\n\n\t \n\tpvt->vd = devm_kcalloc(dev, pvt->vm_channels.total, sizeof(*pvt->vd),\n\t\t\t       GFP_KERNEL);\n\tif (!pvt->vd)\n\t\treturn -ENOMEM;\n\n\tk = 0;\n\tfor (i = 0; i < vm_num; i++) {\n\t\tfor (j = 0; j < vm_active_ch[i]; j++) {\n\t\t\tpvt->vd[k].vm_map = vm_idx[i];\n\t\t\tpvt->vd[k].ch_map = j;\n\t\t\tk++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pvt_get_pre_scaler(struct device *dev, struct pvt_device *pvt)\n{\n\tu8 *pre_scaler_ch_list;\n\tint i, ret, num_ch;\n\tu32 channel;\n\n\t \n\tfor (i = 0; i < pvt->vm_channels.total; i++)\n\t\tpvt->vd[i].pre_scaler = PRE_SCALER_X1;\n\n\t \n\tnum_ch = device_property_count_u8(dev, \"moortec,vm-pre-scaler-x2\");\n\tif (num_ch <= 0)\n\t\treturn 0;\n\n\tpre_scaler_ch_list = kcalloc(num_ch, sizeof(*pre_scaler_ch_list),\n\t\t\t\t     GFP_KERNEL);\n\tif (!pre_scaler_ch_list)\n\t\treturn -ENOMEM;\n\n\t \n\tret = device_property_read_u8_array(dev, \"moortec,vm-pre-scaler-x2\",\n\t\t\t\t\t    pre_scaler_ch_list, num_ch);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < num_ch; i++) {\n\t\tchannel = pre_scaler_ch_list[i];\n\t\tpvt->vd[channel].pre_scaler = PRE_SCALER_X2;\n\t}\n\nout:\n\tkfree(pre_scaler_ch_list);\n\n\treturn ret;\n}\n\nstatic int pvt_set_temp_coeff(struct device *dev, struct pvt_device *pvt)\n{\n\tstruct temp_coeff *ts_coeff = &pvt->ts_coeff;\n\tu32 series;\n\tint ret;\n\n\t \n\tret = device_property_read_u32(dev, \"moortec,ts-series\", &series);\n\tif (ret)\n\t\tseries = TEMPERATURE_SENSOR_SERIES_5;\n\n\tswitch (series) {\n\tcase TEMPERATURE_SENSOR_SERIES_5:\n\t\tts_coeff->h = PVT_SERIES5_H_CONST;\n\t\tts_coeff->g = PVT_SERIES5_G_CONST;\n\t\tts_coeff->j = PVT_SERIES5_J_CONST;\n\t\tts_coeff->cal5 = PVT_SERIES5_CAL5_CONST;\n\t\tbreak;\n\tcase TEMPERATURE_SENSOR_SERIES_6:\n\t\tts_coeff->h = PVT_SERIES6_H_CONST;\n\t\tts_coeff->g = PVT_SERIES6_G_CONST;\n\t\tts_coeff->j = PVT_SERIES6_J_CONST;\n\t\tts_coeff->cal5 = PVT_SERIES6_CAL5_CONST;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"invalid temperature sensor series (%u)\\n\",\n\t\t\tseries);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"temperature sensor series = %u\\n\", series);\n\n\t \n\tdevice_property_read_u32(dev, \"moortec,ts-coeff-h\", &ts_coeff->h);\n\tdevice_property_read_u32(dev, \"moortec,ts-coeff-g\", &ts_coeff->g);\n\tdevice_property_read_u32(dev, \"moortec,ts-coeff-j\", &ts_coeff->j);\n\tdevice_property_read_u32(dev, \"moortec,ts-coeff-cal5\", &ts_coeff->cal5);\n\n\tdev_dbg(dev, \"ts-coeff: h = %u, g = %u, j = %d, cal5 = %u\\n\",\n\t\tts_coeff->h, ts_coeff->g, ts_coeff->j, ts_coeff->cal5);\n\n\treturn 0;\n}\n\nstatic int mr75203_probe(struct platform_device *pdev)\n{\n\tu32 ts_num, vm_num, pd_num, ch_num, val, index, i;\n\tconst struct hwmon_channel_info **pvt_info;\n\tstruct device *dev = &pdev->dev;\n\tu32 *temp_config, *in_config;\n\tstruct device *hwmon_dev;\n\tstruct pvt_device *pvt;\n\tint ret;\n\n\tpvt = devm_kzalloc(dev, sizeof(*pvt), GFP_KERNEL);\n\tif (!pvt)\n\t\treturn -ENOMEM;\n\n\tret = pvt_get_regmap(pdev, \"common\", pvt);\n\tif (ret)\n\t\treturn ret;\n\n\tpvt->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(pvt->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(pvt->clk), \"failed to get clock\\n\");\n\n\tpvt->rst = devm_reset_control_get_optional_exclusive(dev, NULL);\n\tif (IS_ERR(pvt->rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(pvt->rst),\n\t\t\t\t     \"failed to get reset control\\n\");\n\n\tif (pvt->rst) {\n\t\tret = pvt_reset_control_deassert(dev, pvt);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"cannot deassert reset control\\n\");\n\t}\n\n\tret = regmap_read(pvt->c_map, PVT_IP_CONFIG, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tts_num = (val & TS_NUM_MSK) >> TS_NUM_SFT;\n\tpd_num = (val & PD_NUM_MSK) >> PD_NUM_SFT;\n\tvm_num = (val & VM_NUM_MSK) >> VM_NUM_SFT;\n\tch_num = (val & CH_NUM_MSK) >> CH_NUM_SFT;\n\tpvt->t_num = ts_num;\n\tpvt->p_num = pd_num;\n\tpvt->v_num = vm_num;\n\tval = 0;\n\tif (ts_num)\n\t\tval++;\n\tif (vm_num)\n\t\tval++;\n\tif (!val)\n\t\treturn -ENODEV;\n\n\tpvt_info = devm_kcalloc(dev, val + 2, sizeof(*pvt_info), GFP_KERNEL);\n\tif (!pvt_info)\n\t\treturn -ENOMEM;\n\tpvt_info[0] = HWMON_CHANNEL_INFO(chip, HWMON_C_REGISTER_TZ);\n\tindex = 1;\n\n\tif (ts_num) {\n\t\tret = pvt_get_regmap(pdev, \"ts\", pvt);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = pvt_set_temp_coeff(dev, pvt);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttemp_config = devm_kcalloc(dev, ts_num + 1,\n\t\t\t\t\t   sizeof(*temp_config), GFP_KERNEL);\n\t\tif (!temp_config)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset32(temp_config, HWMON_T_INPUT, ts_num);\n\t\tpvt_temp.config = temp_config;\n\t\tpvt_info[index++] = &pvt_temp;\n\n\t\tpvt_ts_dbgfs_create(pvt, dev);\n\t}\n\n\tif (pd_num) {\n\t\tret = pvt_get_regmap(pdev, \"pd\", pvt);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (vm_num) {\n\t\tu8 vm_idx[VM_NUM_MAX];\n\n\t\tret = pvt_get_regmap(pdev, \"vm\", pvt);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = device_property_read_u8_array(dev, \"intel,vm-map\", vm_idx,\n\t\t\t\t\t\t    vm_num);\n\t\tif (ret) {\n\t\t\t \n\t\t\tfor (i = 0; i < vm_num; i++)\n\t\t\t\tvm_idx[i] = i;\n\t\t} else {\n\t\t\tfor (i = 0; i < vm_num; i++)\n\t\t\t\tif (vm_idx[i] >= vm_num || vm_idx[i] == 0xff) {\n\t\t\t\t\tpvt->v_num = i;\n\t\t\t\t\tvm_num = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\n\t\tret = pvt_get_active_channel(dev, pvt, vm_num, ch_num, vm_idx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = pvt_get_pre_scaler(dev, pvt);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tin_config = devm_kcalloc(dev, pvt->vm_channels.total + 1,\n\t\t\t\t\t sizeof(*in_config), GFP_KERNEL);\n\t\tif (!in_config)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset32(in_config, HWMON_I_INPUT, pvt->vm_channels.total);\n\t\tin_config[pvt->vm_channels.total] = 0;\n\t\tpvt_in.config = in_config;\n\n\t\tpvt_info[index++] = &pvt_in;\n\t}\n\n\tret = pvt_init(pvt);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init pvt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpvt_chip_info.info = pvt_info;\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, \"pvt\",\n\t\t\t\t\t\t\t pvt,\n\t\t\t\t\t\t\t &pvt_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct of_device_id moortec_pvt_of_match[] = {\n\t{ .compatible = \"moortec,mr75203\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, moortec_pvt_of_match);\n\nstatic struct platform_driver moortec_pvt_driver = {\n\t.driver = {\n\t\t.name = \"moortec-pvt\",\n\t\t.of_match_table = moortec_pvt_of_match,\n\t},\n\t.probe = mr75203_probe,\n};\nmodule_platform_driver(moortec_pvt_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}