{
  "module_name": "tc654.c",
  "hash_id": "fc641c28e1d949edcc69c67213fded206235f9f152c27f571d9679c27beab949",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/tc654.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n#include <linux/util_macros.h>\n\nenum tc654_regs {\n\tTC654_REG_RPM1 = 0x00,\t \n\tTC654_REG_RPM2 = 0x01,\t \n\tTC654_REG_FAN_FAULT1 = 0x02,\t \n\tTC654_REG_FAN_FAULT2 = 0x03,\t \n\tTC654_REG_CONFIG = 0x04,\t \n\tTC654_REG_STATUS = 0x05,\t \n\tTC654_REG_DUTY_CYCLE = 0x06,\t \n\tTC654_REG_MFR_ID = 0x07,\t \n\tTC654_REG_VER_ID = 0x08,\t \n};\n\n \n#define TC654_REG_RPM(idx)\t\t(TC654_REG_RPM1 + (idx))\n#define TC654_REG_FAN_FAULT(idx)\t(TC654_REG_FAN_FAULT1 + (idx))\n\n \n#define TC654_REG_CONFIG_RES\t\tBIT(6)\t \n#define TC654_REG_CONFIG_DUTYC\t\tBIT(5)\t \n#define TC654_REG_CONFIG_SDM\t\tBIT(0)\t \n\n \n#define TC654_REG_STATUS_F2F\t\tBIT(1)\t \n#define TC654_REG_STATUS_F1F\t\tBIT(0)\t \n\n \n#define TC654_HIGH_RPM_RESOLUTION\t25\t \n#define TC654_LOW_RPM_RESOLUTION\t50\t \n\n \n#define TC654_FAN_FAULT_FROM_REG(val)\t((val) * 50)\t \n\n \n#define TC654_FAN_FAULT_TO_REG(val)\t(((val) / 50) & 0xff)\n\n \n#define TC654_UPDATE_INTERVAL\t\tHZ\n\nstruct tc654_data {\n\tstruct i2c_client *client;\n\n\t \n\tstruct mutex update_lock;\n\n\t \n\tbool valid;\n\tunsigned long last_updated;\t \n\n\tu8 rpm_output[2];\t \n\tu8 fan_fault[2];\t \n\tu8 config;\t \n\tu8 status;\t \n\tu8 duty_cycle;\t \n};\n\n \nstatic struct tc654_data *tc654_update_client(struct device *dev)\n{\n\tstruct tc654_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret = 0;\n\n\tmutex_lock(&data->update_lock);\n\tif (time_before(jiffies, data->last_updated + TC654_UPDATE_INTERVAL) &&\n\t    likely(data->valid))\n\t\tgoto out;\n\n\tret = i2c_smbus_read_byte_data(client, TC654_REG_RPM(0));\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->rpm_output[0] = ret;\n\n\tret = i2c_smbus_read_byte_data(client, TC654_REG_RPM(1));\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->rpm_output[1] = ret;\n\n\tret = i2c_smbus_read_byte_data(client, TC654_REG_FAN_FAULT(0));\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->fan_fault[0] = ret;\n\n\tret = i2c_smbus_read_byte_data(client, TC654_REG_FAN_FAULT(1));\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->fan_fault[1] = ret;\n\n\tret = i2c_smbus_read_byte_data(client, TC654_REG_CONFIG);\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->config = ret;\n\n\tret = i2c_smbus_read_byte_data(client, TC654_REG_STATUS);\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->status = ret;\n\n\tret = i2c_smbus_read_byte_data(client, TC654_REG_DUTY_CYCLE);\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->duty_cycle = ret & 0x0f;\n\n\tdata->last_updated = jiffies;\n\tdata->valid = true;\nout:\n\tmutex_unlock(&data->update_lock);\n\n\tif (ret < 0)\t\t \n\t\tdata = ERR_PTR(ret);\n\n\treturn data;\n}\n\n \n\nstatic ssize_t fan_show(struct device *dev, struct device_attribute *da,\n\t\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct tc654_data *data = tc654_update_client(dev);\n\tint val;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (data->config & TC654_REG_CONFIG_RES)\n\t\tval = data->rpm_output[nr] * TC654_HIGH_RPM_RESOLUTION;\n\telse\n\t\tval = data->rpm_output[nr] * TC654_LOW_RPM_RESOLUTION;\n\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t fan_min_show(struct device *dev, struct device_attribute *da,\n\t\t\t    char *buf)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct tc654_data *data = tc654_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       TC654_FAN_FAULT_FROM_REG(data->fan_fault[nr]));\n}\n\nstatic ssize_t fan_min_store(struct device *dev, struct device_attribute *da,\n\t\t\t     const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct tc654_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tval = clamp_val(val, 0, 12750);\n\n\tmutex_lock(&data->update_lock);\n\n\tdata->fan_fault[nr] = TC654_FAN_FAULT_TO_REG(val);\n\tret = i2c_smbus_write_byte_data(client, TC654_REG_FAN_FAULT(nr),\n\t\t\t\t\tdata->fan_fault[nr]);\n\n\tmutex_unlock(&data->update_lock);\n\treturn ret < 0 ? ret : count;\n}\n\nstatic ssize_t fan_alarm_show(struct device *dev, struct device_attribute *da,\n\t\t\t      char *buf)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct tc654_data *data = tc654_update_client(dev);\n\tint val;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (nr == 0)\n\t\tval = !!(data->status & TC654_REG_STATUS_F1F);\n\telse\n\t\tval = !!(data->status & TC654_REG_STATUS_F2F);\n\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic const u8 TC654_FAN_PULSE_SHIFT[] = { 1, 3 };\n\nstatic ssize_t fan_pulses_show(struct device *dev,\n\t\t\t       struct device_attribute *da, char *buf)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct tc654_data *data = tc654_update_client(dev);\n\tu8 val;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tval = BIT((data->config >> TC654_FAN_PULSE_SHIFT[nr]) & 0x03);\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t fan_pulses_store(struct device *dev,\n\t\t\t\tstruct device_attribute *da, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct tc654_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 config;\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tswitch (val) {\n\tcase 1:\n\t\tconfig = 0;\n\t\tbreak;\n\tcase 2:\n\t\tconfig = 1;\n\t\tbreak;\n\tcase 4:\n\t\tconfig = 2;\n\t\tbreak;\n\tcase 8:\n\t\tconfig = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&data->update_lock);\n\n\tdata->config &= ~(0x03 << TC654_FAN_PULSE_SHIFT[nr]);\n\tdata->config |= (config << TC654_FAN_PULSE_SHIFT[nr]);\n\tret = i2c_smbus_write_byte_data(client, TC654_REG_CONFIG, data->config);\n\n\tmutex_unlock(&data->update_lock);\n\treturn ret < 0 ? ret : count;\n}\n\nstatic ssize_t pwm_mode_show(struct device *dev, struct device_attribute *da,\n\t\t\t     char *buf)\n{\n\tstruct tc654_data *data = tc654_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", !!(data->config & TC654_REG_CONFIG_DUTYC));\n}\n\nstatic ssize_t pwm_mode_store(struct device *dev, struct device_attribute *da,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct tc654_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (val)\n\t\tdata->config |= TC654_REG_CONFIG_DUTYC;\n\telse\n\t\tdata->config &= ~TC654_REG_CONFIG_DUTYC;\n\n\tret = i2c_smbus_write_byte_data(client, TC654_REG_CONFIG, data->config);\n\n\tmutex_unlock(&data->update_lock);\n\treturn ret < 0 ? ret : count;\n}\n\nstatic const int tc654_pwm_map[16] = { 77,  88, 102, 112, 124, 136, 148, 160,\n\t\t\t\t      172, 184, 196, 207, 219, 231, 243, 255};\n\nstatic ssize_t pwm_show(struct device *dev, struct device_attribute *da,\n\t\t\tchar *buf)\n{\n\tstruct tc654_data *data = tc654_update_client(dev);\n\tint pwm;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (data->config & TC654_REG_CONFIG_SDM)\n\t\tpwm = 0;\n\telse\n\t\tpwm = tc654_pwm_map[data->duty_cycle];\n\n\treturn sprintf(buf, \"%d\\n\", pwm);\n}\n\nstatic int _set_pwm(struct tc654_data *data, unsigned long val)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (val == 0) {\n\t\tdata->config |= TC654_REG_CONFIG_SDM;\n\t\tdata->duty_cycle = 0;\n\t} else {\n\t\tdata->config &= ~TC654_REG_CONFIG_SDM;\n\t\tdata->duty_cycle = val - 1;\n\t}\n\n\tret = i2c_smbus_write_byte_data(client, TC654_REG_CONFIG, data->config);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = i2c_smbus_write_byte_data(client, TC654_REG_DUTY_CYCLE,\n\t\t\t\t\tdata->duty_cycle);\n\nout:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t pwm_store(struct device *dev, struct device_attribute *da,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct tc654_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\tif (val > 255)\n\t\treturn -EINVAL;\n\tif (val > 0)\n\t\tval = find_closest(val, tc654_pwm_map, ARRAY_SIZE(tc654_pwm_map)) + 1;\n\n\tret = _set_pwm(data, val);\n\treturn ret < 0 ? ret : count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_min, fan_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_min, fan_min, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan1_alarm, fan_alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_alarm, fan_alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_pulses, fan_pulses, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_pulses, fan_pulses, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_mode, pwm_mode, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1, pwm, 0);\n\n \nstatic struct attribute *tc654_attrs[] = {\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan1_pulses.dev_attr.attr,\n\t&sensor_dev_attr_fan2_pulses.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_mode.dev_attr.attr,\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(tc654);\n\n \n#define TC654_MAX_COOLING_STATE\t16\n\nstatic int tc654_get_max_state(struct thermal_cooling_device *cdev, unsigned long *state)\n{\n\t*state = TC654_MAX_COOLING_STATE;\n\treturn 0;\n}\n\nstatic int tc654_get_cur_state(struct thermal_cooling_device *cdev, unsigned long *state)\n{\n\tstruct tc654_data *data = tc654_update_client(cdev->devdata);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (data->config & TC654_REG_CONFIG_SDM)\n\t\t*state = 0;\t \n\telse\n\t\t*state = data->duty_cycle + 1;\t \n\n\treturn 0;\n}\n\nstatic int tc654_set_cur_state(struct thermal_cooling_device *cdev, unsigned long state)\n{\n\tstruct tc654_data *data = tc654_update_client(cdev->devdata);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn _set_pwm(data, clamp_val(state, 0, TC654_MAX_COOLING_STATE));\n}\n\nstatic const struct thermal_cooling_device_ops tc654_fan_cool_ops = {\n\t.get_max_state = tc654_get_max_state,\n\t.get_cur_state = tc654_get_cur_state,\n\t.set_cur_state = tc654_set_cur_state,\n};\n\n \n\nstatic int tc654_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tc654_data *data;\n\tstruct device *hwmon_dev;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(struct tc654_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\tret = i2c_smbus_read_byte_data(client, TC654_REG_CONFIG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->config = ret;\n\n\thwmon_dev =\n\t    devm_hwmon_device_register_with_groups(dev, client->name, data,\n\t\t\t\t\t\t   tc654_groups);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tif (IS_ENABLED(CONFIG_THERMAL)) {\n\t\tstruct thermal_cooling_device *cdev;\n\n\t\tcdev = devm_thermal_of_cooling_device_register(dev, dev->of_node, client->name,\n\t\t\t\t\t\t\t       hwmon_dev, &tc654_fan_cool_ops);\n\t\treturn PTR_ERR_OR_ZERO(cdev);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id tc654_id[] = {\n\t{\"tc654\", 0},\n\t{\"tc655\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, tc654_id);\n\nstatic struct i2c_driver tc654_driver = {\n\t.driver = {\n\t\t   .name = \"tc654\",\n\t\t   },\n\t.probe = tc654_probe,\n\t.id_table = tc654_id,\n};\n\nmodule_i2c_driver(tc654_driver);\n\nMODULE_AUTHOR(\"Allied Telesis Labs\");\nMODULE_DESCRIPTION(\"Microchip TC654/TC655 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}