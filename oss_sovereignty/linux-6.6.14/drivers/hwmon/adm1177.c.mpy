{
  "module_name": "adm1177.c",
  "hash_id": "e86fa57171a8d8f1130d2b9bb40de07ae68fad7abb7ee8f5c3e5a49e410662e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adm1177.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n\n \n#define ADM1177_CMD_V_CONT\tBIT(0)\n#define ADM1177_CMD_I_CONT\tBIT(2)\n#define ADM1177_CMD_VRANGE\tBIT(4)\n\n \n#define ADM1177_REG_ALERT_TH\t2\n\n#define ADM1177_BITS\t\t12\n\n \nstruct adm1177_state {\n\tstruct i2c_client\t*client;\n\tu32\t\t\tr_sense_uohm;\n\tu32\t\t\talert_threshold_ua;\n\tbool\t\t\tvrange_high;\n};\n\nstatic int adm1177_read_raw(struct adm1177_state *st, u8 num, u8 *data)\n{\n\treturn i2c_master_recv(st->client, data, num);\n}\n\nstatic int adm1177_write_cmd(struct adm1177_state *st, u8 cmd)\n{\n\treturn i2c_smbus_write_byte(st->client, cmd);\n}\n\nstatic int adm1177_write_alert_thr(struct adm1177_state *st,\n\t\t\t\t   u32 alert_threshold_ua)\n{\n\tu64 val;\n\tint ret;\n\n\tval = 0xFFULL * alert_threshold_ua * st->r_sense_uohm;\n\tval = div_u64(val, 105840000U);\n\tval = div_u64(val, 1000U);\n\tif (val > 0xFF)\n\t\tval = 0xFF;\n\n\tret = i2c_smbus_write_byte_data(st->client, ADM1177_REG_ALERT_TH,\n\t\t\t\t\tval);\n\tif (ret)\n\t\treturn ret;\n\n\tst->alert_threshold_ua = alert_threshold_ua;\n\treturn 0;\n}\n\nstatic int adm1177_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct adm1177_state *st = dev_get_drvdata(dev);\n\tu8 data[3];\n\tlong dummy;\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_input:\n\t\t\tret = adm1177_read_raw(st, 3, data);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tdummy = (data[1] << 4) | (data[2] & 0xF);\n\t\t\t \n\t\t\t*val = div_u64((105840000ull * dummy),\n\t\t\t\t       4096 * st->r_sense_uohm);\n\t\t\treturn 0;\n\t\tcase hwmon_curr_max_alarm:\n\t\t\t*val = st->alert_threshold_ua;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tcase hwmon_in:\n\t\tret = adm1177_read_raw(st, 3, data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdummy = (data[0] << 4) | (data[2] >> 4);\n\t\t \n\t\tif (st->vrange_high)\n\t\t\tdummy *= 26350;\n\t\telse\n\t\t\tdummy *= 6650;\n\n\t\t*val = DIV_ROUND_CLOSEST(dummy, 4096);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int adm1177_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long val)\n{\n\tstruct adm1177_state *st = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_max_alarm:\n\t\t\tadm1177_write_alert_thr(st, val);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t adm1177_is_visible(const void *data,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tconst struct adm1177_state *st = data;\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\treturn 0444;\n\t\t}\n\t\tbreak;\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_input:\n\t\t\tif (st->r_sense_uohm)\n\t\t\t\treturn 0444;\n\t\t\treturn 0;\n\t\tcase hwmon_curr_max_alarm:\n\t\t\tif (st->r_sense_uohm)\n\t\t\t\treturn 0644;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const adm1177_info[] = {\n\tHWMON_CHANNEL_INFO(curr,\n\t\t\t   HWMON_C_INPUT | HWMON_C_MAX_ALARM),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops adm1177_hwmon_ops = {\n\t.is_visible = adm1177_is_visible,\n\t.read = adm1177_read,\n\t.write = adm1177_write,\n};\n\nstatic const struct hwmon_chip_info adm1177_chip_info = {\n\t.ops = &adm1177_hwmon_ops,\n\t.info = adm1177_info,\n};\n\nstatic int adm1177_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct adm1177_state *st;\n\tu32 alert_threshold_ua;\n\tint ret;\n\n\tst = devm_kzalloc(dev, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->client = client;\n\n\tret = devm_regulator_get_enable_optional(&client->dev, \"vref\");\n\tif (ret == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tif (device_property_read_u32(dev, \"shunt-resistor-micro-ohms\",\n\t\t\t\t     &st->r_sense_uohm))\n\t\tst->r_sense_uohm = 0;\n\tif (device_property_read_u32(dev, \"adi,shutdown-threshold-microamp\",\n\t\t\t\t     &alert_threshold_ua)) {\n\t\tif (st->r_sense_uohm)\n\t\t\t \n\t\t\talert_threshold_ua = div_u64(105840000000,\n\t\t\t\t\t\t     st->r_sense_uohm);\n\t\telse\n\t\t\talert_threshold_ua = 0;\n\t}\n\tst->vrange_high = device_property_read_bool(dev,\n\t\t\t\t\t\t    \"adi,vrange-high-enable\");\n\tif (alert_threshold_ua && st->r_sense_uohm)\n\t\tadm1177_write_alert_thr(st, alert_threshold_ua);\n\n\tret = adm1177_write_cmd(st, ADM1177_CMD_V_CONT |\n\t\t\t\t    ADM1177_CMD_I_CONT |\n\t\t\t\t    (st->vrange_high ? 0 : ADM1177_CMD_VRANGE));\n\tif (ret)\n\t\treturn ret;\n\n\thwmon_dev =\n\t\tdevm_hwmon_device_register_with_info(dev, client->name, st,\n\t\t\t\t\t\t     &adm1177_chip_info, NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id adm1177_id[] = {\n\t{\"adm1177\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, adm1177_id);\n\nstatic const struct of_device_id adm1177_dt_ids[] = {\n\t{ .compatible = \"adi,adm1177\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, adm1177_dt_ids);\n\nstatic struct i2c_driver adm1177_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"adm1177\",\n\t\t.of_match_table = adm1177_dt_ids,\n\t},\n\t.probe = adm1177_probe,\n\t.id_table = adm1177_id,\n};\nmodule_i2c_driver(adm1177_driver);\n\nMODULE_AUTHOR(\"Beniamin Bia <beniamin.bia@analog.com>\");\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADM1177 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}