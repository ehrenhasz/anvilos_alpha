{
  "module_name": "ltc4245.c",
  "hash_id": "13bfd5af1ef66930774263580b7e7196cae37dcbe2e52874d9167f4e89ecb19b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ltc4245.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/platform_data/ltc4245.h>\n\n \nenum ltc4245_cmd {\n\tLTC4245_STATUS\t\t\t= 0x00,  \n\tLTC4245_ALERT\t\t\t= 0x01,\n\tLTC4245_CONTROL\t\t\t= 0x02,\n\tLTC4245_ON\t\t\t= 0x03,\n\tLTC4245_FAULT1\t\t\t= 0x04,\n\tLTC4245_FAULT2\t\t\t= 0x05,\n\tLTC4245_GPIO\t\t\t= 0x06,\n\tLTC4245_ADCADR\t\t\t= 0x07,\n\n\tLTC4245_12VIN\t\t\t= 0x10,\n\tLTC4245_12VSENSE\t\t= 0x11,\n\tLTC4245_12VOUT\t\t\t= 0x12,\n\tLTC4245_5VIN\t\t\t= 0x13,\n\tLTC4245_5VSENSE\t\t\t= 0x14,\n\tLTC4245_5VOUT\t\t\t= 0x15,\n\tLTC4245_3VIN\t\t\t= 0x16,\n\tLTC4245_3VSENSE\t\t\t= 0x17,\n\tLTC4245_3VOUT\t\t\t= 0x18,\n\tLTC4245_VEEIN\t\t\t= 0x19,\n\tLTC4245_VEESENSE\t\t= 0x1a,\n\tLTC4245_VEEOUT\t\t\t= 0x1b,\n\tLTC4245_GPIOADC\t\t\t= 0x1c,\n};\n\nstruct ltc4245_data {\n\tstruct i2c_client *client;\n\n\tstruct mutex update_lock;\n\tbool valid;\n\tunsigned long last_updated;  \n\n\t \n\tu8 cregs[0x08];\n\n\t \n\tu8 vregs[0x0d];\n\n\t \n\tbool use_extra_gpios;\n\tint gpios[3];\n};\n\n \nstatic void ltc4245_update_gpios(struct device *dev)\n{\n\tstruct ltc4245_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 gpio_curr, gpio_next, gpio_reg;\n\tint i;\n\n\t \n\tif (!data->use_extra_gpios) {\n\t\tdata->gpios[0] = data->vregs[LTC4245_GPIOADC - 0x10];\n\t\treturn;\n\t}\n\n\t \n\tif (time_after(jiffies, data->last_updated + 5 * HZ)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(data->gpios); i++)\n\t\t\tdata->gpios[i] = -EAGAIN;\n\t}\n\n\t \n\tgpio_curr = (data->cregs[LTC4245_GPIO] & 0xc0) >> 6;\n\tif (gpio_curr > 0)\n\t\tgpio_curr -= 1;\n\n\t \n\tdata->gpios[gpio_curr] = data->vregs[LTC4245_GPIOADC - 0x10];\n\n\t \n\tgpio_next = (gpio_curr + 1) % ARRAY_SIZE(data->gpios);\n\n\t \n\tgpio_reg = (data->cregs[LTC4245_GPIO] & 0x3f) | ((gpio_next + 1) << 6);\n\n\t \n\ti2c_smbus_write_byte_data(client, LTC4245_GPIO, gpio_reg);\n\n\t \n\tdata->cregs[LTC4245_GPIO] = gpio_reg;\n}\n\nstatic struct ltc4245_data *ltc4245_update_device(struct device *dev)\n{\n\tstruct ltc4245_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\ts32 val;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(data->cregs); i++) {\n\t\t\tval = i2c_smbus_read_byte_data(client, i);\n\t\t\tif (unlikely(val < 0))\n\t\t\t\tdata->cregs[i] = 0;\n\t\t\telse\n\t\t\t\tdata->cregs[i] = val;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(data->vregs); i++) {\n\t\t\tval = i2c_smbus_read_byte_data(client, i+0x10);\n\t\t\tif (unlikely(val < 0))\n\t\t\t\tdata->vregs[i] = 0;\n\t\t\telse\n\t\t\t\tdata->vregs[i] = val;\n\t\t}\n\n\t\t \n\t\tltc4245_update_gpios(dev);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \nstatic int ltc4245_get_voltage(struct device *dev, u8 reg)\n{\n\tstruct ltc4245_data *data = ltc4245_update_device(dev);\n\tconst u8 regval = data->vregs[reg - 0x10];\n\tu32 voltage = 0;\n\n\tswitch (reg) {\n\tcase LTC4245_12VIN:\n\tcase LTC4245_12VOUT:\n\t\tvoltage = regval * 55;\n\t\tbreak;\n\tcase LTC4245_5VIN:\n\tcase LTC4245_5VOUT:\n\t\tvoltage = regval * 22;\n\t\tbreak;\n\tcase LTC4245_3VIN:\n\tcase LTC4245_3VOUT:\n\t\tvoltage = regval * 15;\n\t\tbreak;\n\tcase LTC4245_VEEIN:\n\tcase LTC4245_VEEOUT:\n\t\tvoltage = regval * -55;\n\t\tbreak;\n\tcase LTC4245_GPIOADC:\n\t\tvoltage = regval * 10;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn voltage;\n}\n\n \nstatic unsigned int ltc4245_get_current(struct device *dev, u8 reg)\n{\n\tstruct ltc4245_data *data = ltc4245_update_device(dev);\n\tconst u8 regval = data->vregs[reg - 0x10];\n\tunsigned int voltage;\n\tunsigned int curr;\n\n\t \n\n\tswitch (reg) {\n\tcase LTC4245_12VSENSE:\n\t\tvoltage = regval * 250;  \n\t\tcurr = voltage / 50;  \n\t\tbreak;\n\tcase LTC4245_5VSENSE:\n\t\tvoltage = regval * 125;  \n\t\tcurr = (voltage * 10) / 35;  \n\t\tbreak;\n\tcase LTC4245_3VSENSE:\n\t\tvoltage = regval * 125;  \n\t\tcurr = (voltage * 10) / 25;  \n\t\tbreak;\n\tcase LTC4245_VEESENSE:\n\t\tvoltage = regval * 250;  \n\t\tcurr = voltage / 100;  \n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tcurr = 0;\n\t\tbreak;\n\t}\n\n\treturn curr;\n}\n\n \n\nstatic const s8 ltc4245_in_regs[] = {\n\tLTC4245_12VIN, LTC4245_5VIN, LTC4245_3VIN, LTC4245_VEEIN,\n\tLTC4245_12VOUT, LTC4245_5VOUT, LTC4245_3VOUT, LTC4245_VEEOUT,\n};\n\n \n\nstatic const s8 ltc4245_curr_regs[] = {\n\tLTC4245_12VSENSE, LTC4245_5VSENSE, LTC4245_3VSENSE, LTC4245_VEESENSE,\n};\n\nstatic int ltc4245_read_curr(struct device *dev, u32 attr, int channel,\n\t\t\t     long *val)\n{\n\tstruct ltc4245_data *data = ltc4245_update_device(dev);\n\n\tswitch (attr) {\n\tcase hwmon_curr_input:\n\t\t*val = ltc4245_get_current(dev, ltc4245_curr_regs[channel]);\n\t\treturn 0;\n\tcase hwmon_curr_max_alarm:\n\t\t*val = !!(data->cregs[LTC4245_FAULT1] & BIT(channel + 4));\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ltc4245_read_in(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct ltc4245_data *data = ltc4245_update_device(dev);\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\tif (channel < 8) {\n\t\t\t*val = ltc4245_get_voltage(dev,\n\t\t\t\t\t\tltc4245_in_regs[channel]);\n\t\t} else {\n\t\t\tint regval = data->gpios[channel - 8];\n\n\t\t\tif (regval < 0)\n\t\t\t\treturn regval;\n\t\t\t*val = regval * 10;\n\t\t}\n\t\treturn 0;\n\tcase hwmon_in_min_alarm:\n\t\tif (channel < 4)\n\t\t\t*val = !!(data->cregs[LTC4245_FAULT1] & BIT(channel));\n\t\telse\n\t\t\t*val = !!(data->cregs[LTC4245_FAULT2] &\n\t\t\t\t  BIT(channel - 4));\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ltc4245_read_power(struct device *dev, u32 attr, int channel,\n\t\t\t      long *val)\n{\n\tunsigned long curr;\n\tlong voltage;\n\n\tswitch (attr) {\n\tcase hwmon_power_input:\n\t\t(void)ltc4245_update_device(dev);\n\t\tcurr = ltc4245_get_current(dev, ltc4245_curr_regs[channel]);\n\t\tvoltage = ltc4245_get_voltage(dev, ltc4245_in_regs[channel]);\n\t\t*val = abs(curr * voltage);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ltc4245_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\n\tswitch (type) {\n\tcase hwmon_curr:\n\t\treturn ltc4245_read_curr(dev, attr, channel, val);\n\tcase hwmon_power:\n\t\treturn ltc4245_read_power(dev, attr, channel, val);\n\tcase hwmon_in:\n\t\treturn ltc4245_read_in(dev, attr, channel - 1, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t ltc4245_is_visible(const void *_data,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tconst struct ltc4245_data *data = _data;\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tif (channel == 0)\n\t\t\treturn 0;\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\tif (channel > 9 && !data->use_extra_gpios)\n\t\t\t\treturn 0;\n\t\t\treturn 0444;\n\t\tcase hwmon_in_min_alarm:\n\t\t\tif (channel > 8)\n\t\t\t\treturn 0;\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_input:\n\t\tcase hwmon_curr_max_alarm:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_power:\n\t\tswitch (attr) {\n\t\tcase hwmon_power_input:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const ltc4245_info[] = {\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN_ALARM,\n\t\t\t   HWMON_I_INPUT,\n\t\t\t   HWMON_I_INPUT,\n\t\t\t   HWMON_I_INPUT),\n\tHWMON_CHANNEL_INFO(curr,\n\t\t\t   HWMON_C_INPUT | HWMON_C_MAX_ALARM,\n\t\t\t   HWMON_C_INPUT | HWMON_C_MAX_ALARM,\n\t\t\t   HWMON_C_INPUT | HWMON_C_MAX_ALARM,\n\t\t\t   HWMON_C_INPUT | HWMON_C_MAX_ALARM),\n\tHWMON_CHANNEL_INFO(power,\n\t\t\t   HWMON_P_INPUT,\n\t\t\t   HWMON_P_INPUT,\n\t\t\t   HWMON_P_INPUT,\n\t\t\t   HWMON_P_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops ltc4245_hwmon_ops = {\n\t.is_visible = ltc4245_is_visible,\n\t.read = ltc4245_read,\n};\n\nstatic const struct hwmon_chip_info ltc4245_chip_info = {\n\t.ops = &ltc4245_hwmon_ops,\n\t.info = ltc4245_info,\n};\n\nstatic bool ltc4245_use_extra_gpios(struct i2c_client *client)\n{\n\tstruct ltc4245_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct device_node *np = client->dev.of_node;\n\n\t \n\tif (pdata)\n\t\treturn pdata->use_extra_gpios;\n\n\t \n\tif (of_property_read_bool(np, \"ltc4245,use-extra-gpios\"))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int ltc4245_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct ltc4245_data *data;\n\tstruct device *hwmon_dev;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\tdata->use_extra_gpios = ltc4245_use_extra_gpios(client);\n\n\t \n\ti2c_smbus_write_byte_data(client, LTC4245_FAULT1, 0x00);\n\ti2c_smbus_write_byte_data(client, LTC4245_FAULT2, 0x00);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&client->dev,\n\t\t\t\t\t\t\t client->name, data,\n\t\t\t\t\t\t\t &ltc4245_chip_info,\n\t\t\t\t\t\t\t NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id ltc4245_id[] = {\n\t{ \"ltc4245\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ltc4245_id);\n\n \nstatic struct i2c_driver ltc4245_driver = {\n\t.driver = {\n\t\t.name\t= \"ltc4245\",\n\t},\n\t.probe\t\t= ltc4245_probe,\n\t.id_table\t= ltc4245_id,\n};\n\nmodule_i2c_driver(ltc4245_driver);\n\nMODULE_AUTHOR(\"Ira W. Snyder <iws@ovro.caltech.edu>\");\nMODULE_DESCRIPTION(\"LTC4245 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}