{
  "module_name": "axi-fan-control.c",
  "hash_id": "ffae0379cb7e70603dc3450262d34277d374436903849fc7e4709347c1c98086",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/axi-fan-control.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/fpga/adi-axi-common.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n \n#define ADI_REG_RSTN\t\t0x0080\n#define ADI_REG_PWM_WIDTH\t0x0084\n#define ADI_REG_TACH_PERIOD\t0x0088\n#define ADI_REG_TACH_TOLERANCE\t0x008c\n#define ADI_REG_PWM_PERIOD\t0x00c0\n#define ADI_REG_TACH_MEASUR\t0x00c4\n#define ADI_REG_TEMPERATURE\t0x00c8\n#define ADI_REG_TEMP_00_H\t0x0100\n#define ADI_REG_TEMP_25_L\t0x0104\n#define ADI_REG_TEMP_25_H\t0x0108\n#define ADI_REG_TEMP_50_L\t0x010c\n#define ADI_REG_TEMP_50_H\t0x0110\n#define ADI_REG_TEMP_75_L\t0x0114\n#define ADI_REG_TEMP_75_H\t0x0118\n#define ADI_REG_TEMP_100_L\t0x011c\n\n#define ADI_REG_IRQ_MASK\t0x0040\n#define ADI_REG_IRQ_PENDING\t0x0044\n#define ADI_REG_IRQ_SRC\t\t0x0048\n\n \n#define ADI_IRQ_SRC_PWM_CHANGED\t\tBIT(0)\n#define ADI_IRQ_SRC_TACH_ERR\t\tBIT(1)\n#define ADI_IRQ_SRC_TEMP_INCREASE\tBIT(2)\n#define ADI_IRQ_SRC_NEW_MEASUR\t\tBIT(3)\n#define ADI_IRQ_SRC_MASK\t\tGENMASK(3, 0)\n#define ADI_IRQ_MASK_OUT_ALL\t\t0xFFFFFFFFU\n\n#define SYSFS_PWM_MAX\t\t\t255\n\nstruct axi_fan_control_data {\n\tvoid __iomem *base;\n\tstruct device *hdev;\n\tunsigned long clk_rate;\n\tint irq;\n\t \n\tu32 ppr;\n\tbool hw_pwm_req;\n\tbool update_tacho_params;\n\tu8 fan_fault;\n};\n\nstatic inline void axi_iowrite(const u32 val, const u32 reg,\n\t\t\t       const struct axi_fan_control_data *ctl)\n{\n\tiowrite32(val, ctl->base + reg);\n}\n\nstatic inline u32 axi_ioread(const u32 reg,\n\t\t\t     const struct axi_fan_control_data *ctl)\n{\n\treturn ioread32(ctl->base + reg);\n}\n\n \nstatic ssize_t axi_fan_control_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tstruct axi_fan_control_data *ctl = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tu32 temp = axi_ioread(attr->index, ctl);\n\n\ttemp = DIV_ROUND_CLOSEST_ULL(temp * 509314ULL, 65535) - 280230;\n\n\treturn sprintf(buf, \"%u\\n\", temp);\n}\n\nstatic ssize_t axi_fan_control_store(struct device *dev, struct device_attribute *da,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct axi_fan_control_data *ctl = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tu32 temp;\n\tint ret;\n\n\tret = kstrtou32(buf, 10, &temp);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp = DIV_ROUND_CLOSEST_ULL((temp + 280230) * 65535ULL, 509314);\n\taxi_iowrite(temp, attr->index, ctl);\n\n\treturn count;\n}\n\nstatic long axi_fan_control_get_pwm_duty(const struct axi_fan_control_data *ctl)\n{\n\tu32 pwm_width = axi_ioread(ADI_REG_PWM_WIDTH, ctl);\n\tu32 pwm_period = axi_ioread(ADI_REG_PWM_PERIOD, ctl);\n\t \n\treturn DIV_ROUND_CLOSEST(pwm_width * SYSFS_PWM_MAX, pwm_period);\n}\n\nstatic int axi_fan_control_set_pwm_duty(const long val,\n\t\t\t\t\tstruct axi_fan_control_data *ctl)\n{\n\tu32 pwm_period = axi_ioread(ADI_REG_PWM_PERIOD, ctl);\n\tu32 new_width;\n\tlong __val = clamp_val(val, 0, SYSFS_PWM_MAX);\n\n\tnew_width = DIV_ROUND_CLOSEST(__val * pwm_period, SYSFS_PWM_MAX);\n\n\taxi_iowrite(new_width, ADI_REG_PWM_WIDTH, ctl);\n\n\treturn 0;\n}\n\nstatic long axi_fan_control_get_fan_rpm(const struct axi_fan_control_data *ctl)\n{\n\tconst u32 tach = axi_ioread(ADI_REG_TACH_MEASUR, ctl);\n\n\tif (tach == 0)\n\t\t \n\t\treturn 0;\n\t \n\treturn DIV_ROUND_CLOSEST(60 * ctl->clk_rate, ctl->ppr * tach);\n}\n\nstatic int axi_fan_control_read_temp(struct device *dev, u32 attr, long *val)\n{\n\tstruct axi_fan_control_data *ctl = dev_get_drvdata(dev);\n\tlong raw_temp;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\traw_temp = axi_ioread(ADI_REG_TEMPERATURE, ctl);\n\t\t \n\t\t*val = ((raw_temp * 501374) >> 16) - 273677;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int axi_fan_control_read_fan(struct device *dev, u32 attr, long *val)\n{\n\tstruct axi_fan_control_data *ctl = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_fan_fault:\n\t\t*val = ctl->fan_fault;\n\t\t \n\t\tctl->fan_fault = 0;\n\t\treturn 0;\n\tcase hwmon_fan_input:\n\t\t*val = axi_fan_control_get_fan_rpm(ctl);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int axi_fan_control_read_pwm(struct device *dev, u32 attr, long *val)\n{\n\tstruct axi_fan_control_data *ctl = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\t*val = axi_fan_control_get_pwm_duty(ctl);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int axi_fan_control_write_pwm(struct device *dev, u32 attr, long val)\n{\n\tstruct axi_fan_control_data *ctl = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\treturn axi_fan_control_set_pwm_duty(val, ctl);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int axi_fan_control_read_labels(struct device *dev,\n\t\t\t\t       enum hwmon_sensor_types type,\n\t\t\t\t       u32 attr, int channel, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\t*str = \"FAN\";\n\t\treturn 0;\n\tcase hwmon_temp:\n\t\t*str = \"SYSMON4\";\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int axi_fan_control_read(struct device *dev,\n\t\t\t\tenum hwmon_sensor_types type,\n\t\t\t\tu32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\treturn axi_fan_control_read_fan(dev, attr, val);\n\tcase hwmon_pwm:\n\t\treturn axi_fan_control_read_pwm(dev, attr, val);\n\tcase hwmon_temp:\n\t\treturn axi_fan_control_read_temp(dev, attr, val);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int axi_fan_control_write(struct device *dev,\n\t\t\t\t enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\treturn axi_fan_control_write_pwm(dev, attr, val);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic umode_t axi_fan_control_fan_is_visible(const u32 attr)\n{\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\tcase hwmon_fan_fault:\n\tcase hwmon_fan_label:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t axi_fan_control_pwm_is_visible(const u32 attr)\n{\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t axi_fan_control_temp_is_visible(const u32 attr)\n{\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_label:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t axi_fan_control_is_visible(const void *data,\n\t\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t\t  u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\treturn axi_fan_control_fan_is_visible(attr);\n\tcase hwmon_pwm:\n\t\treturn axi_fan_control_pwm_is_visible(attr);\n\tcase hwmon_temp:\n\t\treturn axi_fan_control_temp_is_visible(attr);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic irqreturn_t axi_fan_control_irq_handler(int irq, void *data)\n{\n\tstruct axi_fan_control_data *ctl = (struct axi_fan_control_data *)data;\n\tu32 irq_pending = axi_ioread(ADI_REG_IRQ_PENDING, ctl);\n\tu32 clear_mask;\n\n\tif (irq_pending & ADI_IRQ_SRC_TEMP_INCREASE)\n\t\t \n\t\tctl->hw_pwm_req = true;\n\n\tif (irq_pending & ADI_IRQ_SRC_PWM_CHANGED) {\n\t\t \n\t\tif (!ctl->hw_pwm_req) {\n\t\t\tctl->update_tacho_params = true;\n\t\t} else {\n\t\t\tctl->hw_pwm_req = false;\n\t\t\thwmon_notify_event(ctl->hdev, hwmon_pwm,\n\t\t\t\t\t   hwmon_pwm_input, 0);\n\t\t}\n\t}\n\n\tif (irq_pending & ADI_IRQ_SRC_NEW_MEASUR) {\n\t\tif (ctl->update_tacho_params) {\n\t\t\tu32 new_tach = axi_ioread(ADI_REG_TACH_MEASUR, ctl);\n\t\t\t \n\t\t\tu32 tach_tol = DIV_ROUND_CLOSEST(new_tach * 25, 100);\n\n\t\t\t \n\t\t\taxi_iowrite(new_tach, ADI_REG_TACH_PERIOD, ctl);\n\t\t\taxi_iowrite(tach_tol, ADI_REG_TACH_TOLERANCE, ctl);\n\t\t\tctl->update_tacho_params = false;\n\t\t}\n\t}\n\n\tif (irq_pending & ADI_IRQ_SRC_TACH_ERR)\n\t\tctl->fan_fault = 1;\n\n\t \n\tclear_mask = irq_pending & ADI_IRQ_SRC_MASK;\n\taxi_iowrite(clear_mask, ADI_REG_IRQ_PENDING, ctl);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int axi_fan_control_init(struct axi_fan_control_data *ctl,\n\t\t\t\tconst struct device_node *np)\n{\n\tint ret;\n\n\t \n\tret = of_property_read_u32(np, \"pulses-per-revolution\", &ctl->ppr);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ctl->ppr != 1 && ctl->ppr != 2 && ctl->ppr != 4)\n\t\treturn -EINVAL;\n\t \n\taxi_iowrite(ADI_IRQ_MASK_OUT_ALL &\n\t\t    ~(ADI_IRQ_SRC_NEW_MEASUR | ADI_IRQ_SRC_TACH_ERR |\n\t\t      ADI_IRQ_SRC_PWM_CHANGED | ADI_IRQ_SRC_TEMP_INCREASE),\n\t\t    ADI_REG_IRQ_MASK, ctl);\n\n\t \n\taxi_iowrite(0x01, ADI_REG_RSTN, ctl);\n\n\treturn ret;\n}\n\nstatic const struct hwmon_channel_info * const axi_fan_control_info[] = {\n\tHWMON_CHANNEL_INFO(pwm, HWMON_PWM_INPUT),\n\tHWMON_CHANNEL_INFO(fan, HWMON_F_INPUT | HWMON_F_FAULT | HWMON_F_LABEL),\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT | HWMON_T_LABEL),\n\tNULL\n};\n\nstatic const struct hwmon_ops axi_fan_control_hwmon_ops = {\n\t.is_visible = axi_fan_control_is_visible,\n\t.read = axi_fan_control_read,\n\t.write = axi_fan_control_write,\n\t.read_string = axi_fan_control_read_labels,\n};\n\nstatic const struct hwmon_chip_info axi_chip_info = {\n\t.ops = &axi_fan_control_hwmon_ops,\n\t.info = axi_fan_control_info,\n};\n\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point1_temp_hyst, axi_fan_control, ADI_REG_TEMP_00_H);\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point1_temp, axi_fan_control, ADI_REG_TEMP_25_L);\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point2_temp_hyst, axi_fan_control, ADI_REG_TEMP_25_H);\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point2_temp, axi_fan_control, ADI_REG_TEMP_50_L);\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point3_temp_hyst, axi_fan_control, ADI_REG_TEMP_50_H);\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point3_temp, axi_fan_control, ADI_REG_TEMP_75_L);\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point4_temp_hyst, axi_fan_control, ADI_REG_TEMP_75_H);\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point4_temp, axi_fan_control, ADI_REG_TEMP_100_L);\n\nstatic struct attribute *axi_fan_control_attrs[] = {\n\t&sensor_dev_attr_pwm1_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_temp.dev_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(axi_fan_control);\n\nstatic const u32 version_1_0_0 = ADI_AXI_PCORE_VER(1, 0, 'a');\n\nstatic const struct of_device_id axi_fan_control_of_match[] = {\n\t{ .compatible = \"adi,axi-fan-control-1.00.a\",\n\t\t.data = (void *)&version_1_0_0},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, axi_fan_control_of_match);\n\nstatic int axi_fan_control_probe(struct platform_device *pdev)\n{\n\tstruct axi_fan_control_data *ctl;\n\tstruct clk *clk;\n\tconst struct of_device_id *id;\n\tconst char *name = \"axi_fan_control\";\n\tu32 version;\n\tint ret;\n\n\tid = of_match_node(axi_fan_control_of_match, pdev->dev.of_node);\n\tif (!id)\n\t\treturn -EINVAL;\n\n\tctl = devm_kzalloc(&pdev->dev, sizeof(*ctl), GFP_KERNEL);\n\tif (!ctl)\n\t\treturn -ENOMEM;\n\n\tctl->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctl->base))\n\t\treturn PTR_ERR(ctl->base);\n\n\tclk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"clk_get failed with %ld\\n\", PTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tctl->clk_rate = clk_get_rate(clk);\n\tif (!ctl->clk_rate)\n\t\treturn -EINVAL;\n\n\tversion = axi_ioread(ADI_AXI_REG_VERSION, ctl);\n\tif (ADI_AXI_PCORE_VER_MAJOR(version) !=\n\t    ADI_AXI_PCORE_VER_MAJOR((*(u32 *)id->data))) {\n\t\tdev_err(&pdev->dev, \"Major version mismatch. Expected %d.%.2d.%c, Reported %d.%.2d.%c\\n\",\n\t\t\tADI_AXI_PCORE_VER_MAJOR((*(u32 *)id->data)),\n\t\t\tADI_AXI_PCORE_VER_MINOR((*(u32 *)id->data)),\n\t\t\tADI_AXI_PCORE_VER_PATCH((*(u32 *)id->data)),\n\t\t\tADI_AXI_PCORE_VER_MAJOR(version),\n\t\t\tADI_AXI_PCORE_VER_MINOR(version),\n\t\t\tADI_AXI_PCORE_VER_PATCH(version));\n\t\treturn -ENODEV;\n\t}\n\n\tret = axi_fan_control_init(ctl, pdev->dev.of_node);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize device\\n\");\n\t\treturn ret;\n\t}\n\n\tctl->hdev = devm_hwmon_device_register_with_info(&pdev->dev,\n\t\t\t\t\t\t\t name,\n\t\t\t\t\t\t\t ctl,\n\t\t\t\t\t\t\t &axi_chip_info,\n\t\t\t\t\t\t\t axi_fan_control_groups);\n\n\tif (IS_ERR(ctl->hdev))\n\t\treturn PTR_ERR(ctl->hdev);\n\n\tctl->irq = platform_get_irq(pdev, 0);\n\tif (ctl->irq < 0)\n\t\treturn ctl->irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, ctl->irq, NULL,\n\t\t\t\t\taxi_fan_control_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_HIGH,\n\t\t\t\t\tpdev->driver_override, ctl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request an irq, %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver axi_fan_control_driver = {\n\t.driver = {\n\t\t.name = \"axi_fan_control_driver\",\n\t\t.of_match_table = axi_fan_control_of_match,\n\t},\n\t.probe = axi_fan_control_probe,\n};\nmodule_platform_driver(axi_fan_control_driver);\n\nMODULE_AUTHOR(\"Nuno Sa <nuno.sa@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices Fan Control HDL CORE driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}