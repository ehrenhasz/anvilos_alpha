{
  "module_name": "adm1026.c",
  "hash_id": "ab5374d88aa2d79a7a7f2f61fe71eb1b6f1711ac0b4b7b28e0e1c9bf725b05e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adm1026.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon-vid.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x2c, 0x2d, 0x2e, I2C_CLIENT_END };\n\nstatic int gpio_input[17] = { -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t-1, -1, -1, -1, -1, -1, -1, -1 };\nstatic int gpio_output[17] = { -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t-1, -1, -1, -1, -1, -1, -1, -1 };\nstatic int gpio_inverted[17] = { -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t-1, -1, -1, -1, -1, -1, -1, -1 };\nstatic int gpio_normal[17] = { -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t-1, -1, -1, -1, -1, -1, -1, -1 };\nstatic int gpio_fan[8] = { -1, -1, -1, -1, -1, -1, -1, -1 };\nmodule_param_array(gpio_input, int, NULL, 0);\nMODULE_PARM_DESC(gpio_input, \"List of GPIO pins (0-16) to program as inputs\");\nmodule_param_array(gpio_output, int, NULL, 0);\nMODULE_PARM_DESC(gpio_output,\n\t\t \"List of GPIO pins (0-16) to program as outputs\");\nmodule_param_array(gpio_inverted, int, NULL, 0);\nMODULE_PARM_DESC(gpio_inverted,\n\t\t \"List of GPIO pins (0-16) to program as inverted\");\nmodule_param_array(gpio_normal, int, NULL, 0);\nMODULE_PARM_DESC(gpio_normal,\n\t\t \"List of GPIO pins (0-16) to program as normal/non-inverted\");\nmodule_param_array(gpio_fan, int, NULL, 0);\nMODULE_PARM_DESC(gpio_fan, \"List of GPIO pins (0-7) to program as fan tachs\");\n\n \n\n \n#define ADM1026_REG_CONFIG1\t0x00\n#define CFG1_MONITOR\t\t0x01\n#define CFG1_INT_ENABLE\t\t0x02\n#define CFG1_INT_CLEAR\t\t0x04\n#define CFG1_AIN8_9\t\t0x08\n#define CFG1_THERM_HOT\t\t0x10\n#define CFG1_DAC_AFC\t\t0x20\n#define CFG1_PWM_AFC\t\t0x40\n#define CFG1_RESET\t\t0x80\n\n#define ADM1026_REG_CONFIG2\t0x01\n \n\n#define ADM1026_REG_CONFIG3\t0x07\n#define CFG3_GPIO16_ENABLE\t0x01\n#define CFG3_CI_CLEAR\t\t0x02\n#define CFG3_VREF_250\t\t0x04\n#define CFG3_GPIO16_DIR\t\t0x40\n#define CFG3_GPIO16_POL\t\t0x80\n\n#define ADM1026_REG_E2CONFIG\t0x13\n#define E2CFG_READ\t\t0x01\n#define E2CFG_WRITE\t\t0x02\n#define E2CFG_ERASE\t\t0x04\n#define E2CFG_ROM\t\t0x08\n#define E2CFG_CLK_EXT\t\t0x80\n\n \nstatic u16 ADM1026_REG_IN[] = {\n\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35,\n\t\t0x36, 0x37, 0x27, 0x29, 0x26, 0x2a,\n\t\t0x2b, 0x2c, 0x2d, 0x2e, 0x2f\n\t};\nstatic u16 ADM1026_REG_IN_MIN[] = {\n\t\t0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d,\n\t\t0x5e, 0x5f, 0x6d, 0x49, 0x6b, 0x4a,\n\t\t0x4b, 0x4c, 0x4d, 0x4e, 0x4f\n\t};\nstatic u16 ADM1026_REG_IN_MAX[] = {\n\t\t0x50, 0x51, 0x52, 0x53, 0x54, 0x55,\n\t\t0x56, 0x57, 0x6c, 0x41, 0x6a, 0x42,\n\t\t0x43, 0x44, 0x45, 0x46, 0x47\n\t};\n\n \nstatic u16 ADM1026_REG_TEMP[] = { 0x1f, 0x28, 0x29 };\nstatic u16 ADM1026_REG_TEMP_MIN[] = { 0x69, 0x48, 0x49 };\nstatic u16 ADM1026_REG_TEMP_MAX[] = { 0x68, 0x40, 0x41 };\nstatic u16 ADM1026_REG_TEMP_TMIN[] = { 0x10, 0x11, 0x12 };\nstatic u16 ADM1026_REG_TEMP_THERM[] = { 0x0d, 0x0e, 0x0f };\nstatic u16 ADM1026_REG_TEMP_OFFSET[] = { 0x1e, 0x6e, 0x6f };\n\n#define ADM1026_REG_FAN(nr)\t\t(0x38 + (nr))\n#define ADM1026_REG_FAN_MIN(nr)\t\t(0x60 + (nr))\n#define ADM1026_REG_FAN_DIV_0_3\t\t0x02\n#define ADM1026_REG_FAN_DIV_4_7\t\t0x03\n\n#define ADM1026_REG_DAC\t\t\t0x04\n#define ADM1026_REG_PWM\t\t\t0x05\n\n#define ADM1026_REG_GPIO_CFG_0_3\t0x08\n#define ADM1026_REG_GPIO_CFG_4_7\t0x09\n#define ADM1026_REG_GPIO_CFG_8_11\t0x0a\n#define ADM1026_REG_GPIO_CFG_12_15\t0x0b\n \n#define ADM1026_REG_GPIO_STATUS_0_7\t0x24\n#define ADM1026_REG_GPIO_STATUS_8_15\t0x25\n \n#define ADM1026_REG_GPIO_MASK_0_7\t0x1c\n#define ADM1026_REG_GPIO_MASK_8_15\t0x1d\n \n\n#define ADM1026_REG_COMPANY\t\t0x16\n#define ADM1026_REG_VERSTEP\t\t0x17\n \n#define ADM1026_COMPANY_ANALOG_DEV\t0x41\n#define ADM1026_VERSTEP_GENERIC\t\t0x40\n#define ADM1026_VERSTEP_ADM1026\t\t0x44\n\n#define ADM1026_REG_MASK1\t\t0x18\n#define ADM1026_REG_MASK2\t\t0x19\n#define ADM1026_REG_MASK3\t\t0x1a\n#define ADM1026_REG_MASK4\t\t0x1b\n\n#define ADM1026_REG_STATUS1\t\t0x20\n#define ADM1026_REG_STATUS2\t\t0x21\n#define ADM1026_REG_STATUS3\t\t0x22\n#define ADM1026_REG_STATUS4\t\t0x23\n\n#define ADM1026_FAN_ACTIVATION_TEMP_HYST -6\n#define ADM1026_FAN_CONTROL_TEMP_RANGE\t20\n#define ADM1026_PWM_MAX\t\t\t255\n\n \n\n \nstatic int adm1026_scaling[] = {  \n\t\t2250, 2250, 2250, 2250, 2250, 2250,\n\t\t1875, 1875, 1875, 1875, 3000, 3330,\n\t\t3330, 4995, 2250, 12000, 13875\n\t};\n#define NEG12_OFFSET  16000\n#define SCALE(val, from, to) (((val)*(to) + ((from)/2))/(from))\n#define INS_TO_REG(n, val)\t\\\n\t\tSCALE(clamp_val(val, 0, 255 * adm1026_scaling[n] / 192), \\\n\t\t      adm1026_scaling[n], 192)\n#define INS_FROM_REG(n, val) (SCALE(val, 192, adm1026_scaling[n]))\n\n \n#define FAN_TO_REG(val, div)  ((val) <= 0 ? 0xff : \\\n\t\t\t\tclamp_val(1350000 / ((val) * (div)), \\\n\t\t\t\t\t      1, 254))\n#define FAN_FROM_REG(val, div) ((val) == 0 ? -1 : (val) == 0xff ? 0 : \\\n\t\t\t\t1350000 / ((val) * (div)))\n#define DIV_FROM_REG(val) (1 << (val))\n#define DIV_TO_REG(val) ((val) >= 8 ? 3 : (val) >= 4 ? 2 : (val) >= 2 ? 1 : 0)\n\n \n#define TEMP_TO_REG(val) DIV_ROUND_CLOSEST(clamp_val(val, -128000, 127000), \\\n\t\t\t\t\t   1000)\n#define TEMP_FROM_REG(val) ((val) * 1000)\n#define OFFSET_TO_REG(val) DIV_ROUND_CLOSEST(clamp_val(val, -128000, 127000), \\\n\t\t\t\t\t     1000)\n#define OFFSET_FROM_REG(val) ((val) * 1000)\n\n#define PWM_TO_REG(val) (clamp_val(val, 0, 255))\n#define PWM_FROM_REG(val) (val)\n\n#define PWM_MIN_TO_REG(val) ((val) & 0xf0)\n#define PWM_MIN_FROM_REG(val) (((val) & 0xf0) + ((val) >> 4))\n\n \n#define DAC_TO_REG(val) DIV_ROUND_CLOSEST(clamp_val(val, 0, 2500) * 255, \\\n\t\t\t\t\t  2500)\n#define DAC_FROM_REG(val) (((val) * 2500) / 255)\n\n \n#define ADM1026_DATA_INTERVAL\t\t(1 * HZ)\n#define ADM1026_CONFIG_INTERVAL\t\t(5 * 60 * HZ)\n\n \n\nstruct pwm_data {\n\tu8 pwm;\n\tu8 enable;\n\tu8 auto_pwm_min;\n};\n\nstruct adm1026_data {\n\tstruct i2c_client *client;\n\tconst struct attribute_group *groups[3];\n\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_reading;\t \n\tunsigned long last_config;\t \n\n\tu8 in[17];\t\t \n\tu8 in_max[17];\t\t \n\tu8 in_min[17];\t\t \n\ts8 temp[3];\t\t \n\ts8 temp_min[3];\t\t \n\ts8 temp_max[3];\t\t \n\ts8 temp_tmin[3];\t \n\ts8 temp_crit[3];\t \n\ts8 temp_offset[3];\t \n\tu8 fan[8];\t\t \n\tu8 fan_min[8];\t\t \n\tu8 fan_div[8];\t\t \n\tstruct pwm_data pwm1;\t \n\tu8 vrm;\t\t\t \n\tu8 analog_out;\t\t \n\tlong alarms;\t\t \n\tlong alarm_mask;\t \n\tlong gpio;\t\t \n\tlong gpio_mask;\t\t \n\tu8 gpio_config[17];\t \n\tu8 config1;\t\t \n\tu8 config2;\t\t \n\tu8 config3;\t\t \n};\n\nstatic int adm1026_read_value(struct i2c_client *client, u8 reg)\n{\n\tint res;\n\n\tif (reg < 0x80) {\n\t\t \n\t\tres = i2c_smbus_read_byte_data(client, reg) & 0xff;\n\t} else {\n\t\t \n\t\tres = 0;\n\t}\n\treturn res;\n}\n\nstatic int adm1026_write_value(struct i2c_client *client, u8 reg, int value)\n{\n\tint res;\n\n\tif (reg < 0x80) {\n\t\t \n\t\tres = i2c_smbus_write_byte_data(client, reg, value);\n\t} else {\n\t\t \n\t\tres = 0;\n\t}\n\treturn res;\n}\n\nstatic struct adm1026_data *adm1026_update_device(struct device *dev)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint i;\n\tlong value, alarms, gpio;\n\n\tmutex_lock(&data->update_lock);\n\tif (!data->valid\n\t    || time_after(jiffies,\n\t\t\t  data->last_reading + ADM1026_DATA_INTERVAL)) {\n\t\t \n\t\tdev_dbg(&client->dev, \"Reading sensor values\\n\");\n\t\tfor (i = 0; i <= 16; ++i) {\n\t\t\tdata->in[i] =\n\t\t\t    adm1026_read_value(client, ADM1026_REG_IN[i]);\n\t\t}\n\n\t\tfor (i = 0; i <= 7; ++i) {\n\t\t\tdata->fan[i] =\n\t\t\t    adm1026_read_value(client, ADM1026_REG_FAN(i));\n\t\t}\n\n\t\tfor (i = 0; i <= 2; ++i) {\n\t\t\t \n\t\t\tdata->temp[i] =\n\t\t\t    adm1026_read_value(client, ADM1026_REG_TEMP[i]);\n\t\t}\n\n\t\tdata->pwm1.pwm = adm1026_read_value(client,\n\t\t\tADM1026_REG_PWM);\n\t\tdata->analog_out = adm1026_read_value(client,\n\t\t\tADM1026_REG_DAC);\n\t\t \n\t\talarms = adm1026_read_value(client, ADM1026_REG_STATUS4);\n\t\tgpio = alarms & 0x80 ? 0x0100 : 0;  \n\t\talarms &= 0x7f;\n\t\talarms <<= 8;\n\t\talarms |= adm1026_read_value(client, ADM1026_REG_STATUS3);\n\t\talarms <<= 8;\n\t\talarms |= adm1026_read_value(client, ADM1026_REG_STATUS2);\n\t\talarms <<= 8;\n\t\talarms |= adm1026_read_value(client, ADM1026_REG_STATUS1);\n\t\tdata->alarms = alarms;\n\n\t\t \n\t\tgpio |= adm1026_read_value(client,\n\t\t\tADM1026_REG_GPIO_STATUS_8_15);\n\t\tgpio <<= 8;\n\t\tgpio |= adm1026_read_value(client,\n\t\t\tADM1026_REG_GPIO_STATUS_0_7);\n\t\tdata->gpio = gpio;\n\n\t\tdata->last_reading = jiffies;\n\t}\t \n\n\tif (!data->valid ||\n\t    time_after(jiffies, data->last_config + ADM1026_CONFIG_INTERVAL)) {\n\t\t \n\t\tdev_dbg(&client->dev, \"Reading config values\\n\");\n\t\tfor (i = 0; i <= 16; ++i) {\n\t\t\tdata->in_min[i] = adm1026_read_value(client,\n\t\t\t\tADM1026_REG_IN_MIN[i]);\n\t\t\tdata->in_max[i] = adm1026_read_value(client,\n\t\t\t\tADM1026_REG_IN_MAX[i]);\n\t\t}\n\n\t\tvalue = adm1026_read_value(client, ADM1026_REG_FAN_DIV_0_3)\n\t\t\t| (adm1026_read_value(client, ADM1026_REG_FAN_DIV_4_7)\n\t\t\t<< 8);\n\t\tfor (i = 0; i <= 7; ++i) {\n\t\t\tdata->fan_min[i] = adm1026_read_value(client,\n\t\t\t\tADM1026_REG_FAN_MIN(i));\n\t\t\tdata->fan_div[i] = DIV_FROM_REG(value & 0x03);\n\t\t\tvalue >>= 2;\n\t\t}\n\n\t\tfor (i = 0; i <= 2; ++i) {\n\t\t\t \n\t\t\tdata->temp_min[i] = adm1026_read_value(client,\n\t\t\t\tADM1026_REG_TEMP_MIN[i]);\n\t\t\tdata->temp_max[i] = adm1026_read_value(client,\n\t\t\t\tADM1026_REG_TEMP_MAX[i]);\n\t\t\tdata->temp_tmin[i] = adm1026_read_value(client,\n\t\t\t\tADM1026_REG_TEMP_TMIN[i]);\n\t\t\tdata->temp_crit[i] = adm1026_read_value(client,\n\t\t\t\tADM1026_REG_TEMP_THERM[i]);\n\t\t\tdata->temp_offset[i] = adm1026_read_value(client,\n\t\t\t\tADM1026_REG_TEMP_OFFSET[i]);\n\t\t}\n\n\t\t \n\t\talarms = adm1026_read_value(client, ADM1026_REG_MASK4);\n\t\tgpio = alarms & 0x80 ? 0x0100 : 0;  \n\t\talarms = (alarms & 0x7f) << 8;\n\t\talarms |= adm1026_read_value(client, ADM1026_REG_MASK3);\n\t\talarms <<= 8;\n\t\talarms |= adm1026_read_value(client, ADM1026_REG_MASK2);\n\t\talarms <<= 8;\n\t\talarms |= adm1026_read_value(client, ADM1026_REG_MASK1);\n\t\tdata->alarm_mask = alarms;\n\n\t\t \n\t\tgpio |= adm1026_read_value(client,\n\t\t\tADM1026_REG_GPIO_MASK_8_15);\n\t\tgpio <<= 8;\n\t\tgpio |= adm1026_read_value(client, ADM1026_REG_GPIO_MASK_0_7);\n\t\tdata->gpio_mask = gpio;\n\n\t\t \n\t\tdata->config1 = adm1026_read_value(client,\n\t\t\tADM1026_REG_CONFIG1);\n\t\tif (data->config1 & CFG1_PWM_AFC) {\n\t\t\tdata->pwm1.enable = 2;\n\t\t\tdata->pwm1.auto_pwm_min =\n\t\t\t\tPWM_MIN_FROM_REG(data->pwm1.pwm);\n\t\t}\n\t\t \n\t\tdata->config2 = adm1026_read_value(client,\n\t\t\tADM1026_REG_CONFIG2);\n\t\tdata->config3 = adm1026_read_value(client,\n\t\t\tADM1026_REG_CONFIG3);\n\t\tdata->gpio_config[16] = (data->config3 >> 6) & 0x03;\n\n\t\tvalue = 0;\n\t\tfor (i = 0; i <= 15; ++i) {\n\t\t\tif ((i & 0x03) == 0) {\n\t\t\t\tvalue = adm1026_read_value(client,\n\t\t\t\t\t    ADM1026_REG_GPIO_CFG_0_3 + i/4);\n\t\t\t}\n\t\t\tdata->gpio_config[i] = value & 0x03;\n\t\t\tvalue >>= 2;\n\t\t}\n\n\t\tdata->last_config = jiffies;\n\t}\t \n\n\tdata->valid = true;\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n}\n\nstatic ssize_t in_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", INS_FROM_REG(nr, data->in[nr]));\n}\nstatic ssize_t in_min_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", INS_FROM_REG(nr, data->in_min[nr]));\n}\nstatic ssize_t in_min_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_min[nr] = INS_TO_REG(nr, val);\n\tadm1026_write_value(client, ADM1026_REG_IN_MIN[nr], data->in_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\nstatic ssize_t in_max_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", INS_FROM_REG(nr, data->in_max[nr]));\n}\nstatic ssize_t in_max_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_max[nr] = INS_TO_REG(nr, val);\n\tadm1026_write_value(client, ADM1026_REG_IN_MAX[nr], data->in_max[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_input, in, 0);\nstatic SENSOR_DEVICE_ATTR_RW(in0_min, in_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(in0_max, in_max, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, in, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in1_min, in_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in1_max, in_max, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, in, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in2_min, in_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in2_max, in_max, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, in, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in3_min, in_min, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in3_max, in_max, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, in, 4);\nstatic SENSOR_DEVICE_ATTR_RW(in4_min, in_min, 4);\nstatic SENSOR_DEVICE_ATTR_RW(in4_max, in_max, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in5_input, in, 5);\nstatic SENSOR_DEVICE_ATTR_RW(in5_min, in_min, 5);\nstatic SENSOR_DEVICE_ATTR_RW(in5_max, in_max, 5);\nstatic SENSOR_DEVICE_ATTR_RO(in6_input, in, 6);\nstatic SENSOR_DEVICE_ATTR_RW(in6_min, in_min, 6);\nstatic SENSOR_DEVICE_ATTR_RW(in6_max, in_max, 6);\nstatic SENSOR_DEVICE_ATTR_RO(in7_input, in, 7);\nstatic SENSOR_DEVICE_ATTR_RW(in7_min, in_min, 7);\nstatic SENSOR_DEVICE_ATTR_RW(in7_max, in_max, 7);\nstatic SENSOR_DEVICE_ATTR_RO(in8_input, in, 8);\nstatic SENSOR_DEVICE_ATTR_RW(in8_min, in_min, 8);\nstatic SENSOR_DEVICE_ATTR_RW(in8_max, in_max, 8);\nstatic SENSOR_DEVICE_ATTR_RO(in9_input, in, 9);\nstatic SENSOR_DEVICE_ATTR_RW(in9_min, in_min, 9);\nstatic SENSOR_DEVICE_ATTR_RW(in9_max, in_max, 9);\nstatic SENSOR_DEVICE_ATTR_RO(in10_input, in, 10);\nstatic SENSOR_DEVICE_ATTR_RW(in10_min, in_min, 10);\nstatic SENSOR_DEVICE_ATTR_RW(in10_max, in_max, 10);\nstatic SENSOR_DEVICE_ATTR_RO(in11_input, in, 11);\nstatic SENSOR_DEVICE_ATTR_RW(in11_min, in_min, 11);\nstatic SENSOR_DEVICE_ATTR_RW(in11_max, in_max, 11);\nstatic SENSOR_DEVICE_ATTR_RO(in12_input, in, 12);\nstatic SENSOR_DEVICE_ATTR_RW(in12_min, in_min, 12);\nstatic SENSOR_DEVICE_ATTR_RW(in12_max, in_max, 12);\nstatic SENSOR_DEVICE_ATTR_RO(in13_input, in, 13);\nstatic SENSOR_DEVICE_ATTR_RW(in13_min, in_min, 13);\nstatic SENSOR_DEVICE_ATTR_RW(in13_max, in_max, 13);\nstatic SENSOR_DEVICE_ATTR_RO(in14_input, in, 14);\nstatic SENSOR_DEVICE_ATTR_RW(in14_min, in_min, 14);\nstatic SENSOR_DEVICE_ATTR_RW(in14_max, in_max, 14);\nstatic SENSOR_DEVICE_ATTR_RO(in15_input, in, 15);\nstatic SENSOR_DEVICE_ATTR_RW(in15_min, in_min, 15);\nstatic SENSOR_DEVICE_ATTR_RW(in15_max, in_max, 15);\n\nstatic ssize_t in16_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", INS_FROM_REG(16, data->in[16]) -\n\t\tNEG12_OFFSET);\n}\nstatic ssize_t in16_min_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", INS_FROM_REG(16, data->in_min[16])\n\t\t- NEG12_OFFSET);\n}\nstatic ssize_t in16_min_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_min[16] = INS_TO_REG(16,\n\t\t\t\t      clamp_val(val, INT_MIN,\n\t\t\t\t\t\tINT_MAX - NEG12_OFFSET) +\n\t\t\t\t      NEG12_OFFSET);\n\tadm1026_write_value(client, ADM1026_REG_IN_MIN[16], data->in_min[16]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\nstatic ssize_t in16_max_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", INS_FROM_REG(16, data->in_max[16])\n\t\t\t- NEG12_OFFSET);\n}\nstatic ssize_t in16_max_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_max[16] = INS_TO_REG(16,\n\t\t\t\t      clamp_val(val, INT_MIN,\n\t\t\t\t\t\tINT_MAX - NEG12_OFFSET) +\n\t\t\t\t      NEG12_OFFSET);\n\tadm1026_write_value(client, ADM1026_REG_IN_MAX[16], data->in_max[16]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in16_input, in16, 16);\nstatic SENSOR_DEVICE_ATTR_RW(in16_min, in16_min, 16);\nstatic SENSOR_DEVICE_ATTR_RW(in16_max, in16_max, 16);\n\n \n\nstatic ssize_t fan_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", FAN_FROM_REG(data->fan[nr],\n\t\tdata->fan_div[nr]));\n}\nstatic ssize_t fan_min_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", FAN_FROM_REG(data->fan_min[nr],\n\t\tdata->fan_div[nr]));\n}\nstatic ssize_t fan_min_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_min[nr] = FAN_TO_REG(val, data->fan_div[nr]);\n\tadm1026_write_value(client, ADM1026_REG_FAN_MIN(nr),\n\t\tdata->fan_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_min, fan_min, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_min, fan_min, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_input, fan, 2);\nstatic SENSOR_DEVICE_ATTR_RW(fan3_min, fan_min, 2);\nstatic SENSOR_DEVICE_ATTR_RO(fan4_input, fan, 3);\nstatic SENSOR_DEVICE_ATTR_RW(fan4_min, fan_min, 3);\nstatic SENSOR_DEVICE_ATTR_RO(fan5_input, fan, 4);\nstatic SENSOR_DEVICE_ATTR_RW(fan5_min, fan_min, 4);\nstatic SENSOR_DEVICE_ATTR_RO(fan6_input, fan, 5);\nstatic SENSOR_DEVICE_ATTR_RW(fan6_min, fan_min, 5);\nstatic SENSOR_DEVICE_ATTR_RO(fan7_input, fan, 6);\nstatic SENSOR_DEVICE_ATTR_RW(fan7_min, fan_min, 6);\nstatic SENSOR_DEVICE_ATTR_RO(fan8_input, fan, 7);\nstatic SENSOR_DEVICE_ATTR_RW(fan8_min, fan_min, 7);\n\n \nstatic void fixup_fan_min(struct device *dev, int fan, int old_div)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint new_min;\n\tint new_div = data->fan_div[fan];\n\n\t \n\tif (data->fan_min[fan] == 0 || data->fan_min[fan] == 0xff)\n\t\treturn;\n\n\tnew_min = data->fan_min[fan] * old_div / new_div;\n\tnew_min = clamp_val(new_min, 1, 254);\n\tdata->fan_min[fan] = new_min;\n\tadm1026_write_value(client, ADM1026_REG_FAN_MIN(fan), new_min);\n}\n\n \nstatic ssize_t fan_div_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->fan_div[nr]);\n}\nstatic ssize_t fan_div_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint orig_div, new_div;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tnew_div = DIV_TO_REG(val);\n\n\tmutex_lock(&data->update_lock);\n\torig_div = data->fan_div[nr];\n\tdata->fan_div[nr] = DIV_FROM_REG(new_div);\n\n\tif (nr < 4) {  \n\t\tadm1026_write_value(client, ADM1026_REG_FAN_DIV_0_3,\n\t\t\t\t    (DIV_TO_REG(data->fan_div[0]) << 0) |\n\t\t\t\t    (DIV_TO_REG(data->fan_div[1]) << 2) |\n\t\t\t\t    (DIV_TO_REG(data->fan_div[2]) << 4) |\n\t\t\t\t    (DIV_TO_REG(data->fan_div[3]) << 6));\n\t} else {  \n\t\tadm1026_write_value(client, ADM1026_REG_FAN_DIV_4_7,\n\t\t\t\t    (DIV_TO_REG(data->fan_div[4]) << 0) |\n\t\t\t\t    (DIV_TO_REG(data->fan_div[5]) << 2) |\n\t\t\t\t    (DIV_TO_REG(data->fan_div[6]) << 4) |\n\t\t\t\t    (DIV_TO_REG(data->fan_div[7]) << 6));\n\t}\n\n\tif (data->fan_div[nr] != orig_div)\n\t\tfixup_fan_min(dev, nr, orig_div);\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(fan1_div, fan_div, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_div, fan_div, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan3_div, fan_div, 2);\nstatic SENSOR_DEVICE_ATTR_RW(fan4_div, fan_div, 3);\nstatic SENSOR_DEVICE_ATTR_RW(fan5_div, fan_div, 4);\nstatic SENSOR_DEVICE_ATTR_RW(fan6_div, fan_div, 5);\nstatic SENSOR_DEVICE_ATTR_RW(fan7_div, fan_div, 6);\nstatic SENSOR_DEVICE_ATTR_RW(fan8_div, fan_div, 7);\n\n \nstatic ssize_t temp_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp[nr]));\n}\nstatic ssize_t temp_min_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_min[nr]));\n}\nstatic ssize_t temp_min_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_min[nr] = TEMP_TO_REG(val);\n\tadm1026_write_value(client, ADM1026_REG_TEMP_MIN[nr],\n\t\tdata->temp_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\nstatic ssize_t temp_max_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_max[nr]));\n}\nstatic ssize_t temp_max_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_max[nr] = TEMP_TO_REG(val);\n\tadm1026_write_value(client, ADM1026_REG_TEMP_MAX[nr],\n\t\tdata->temp_max[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp_max, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_min, temp_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp_max, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_min, temp_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_max, temp_max, 2);\n\nstatic ssize_t temp_offset_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_offset[nr]));\n}\nstatic ssize_t temp_offset_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_offset[nr] = TEMP_TO_REG(val);\n\tadm1026_write_value(client, ADM1026_REG_TEMP_OFFSET[nr],\n\t\tdata->temp_offset[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_offset, temp_offset, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_offset, temp_offset, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_offset, temp_offset, 2);\n\nstatic ssize_t temp_auto_point1_temp_hyst_show(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(\n\t\tADM1026_FAN_ACTIVATION_TEMP_HYST + data->temp_tmin[nr]));\n}\nstatic ssize_t temp_auto_point2_temp_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_tmin[nr] +\n\t\tADM1026_FAN_CONTROL_TEMP_RANGE));\n}\nstatic ssize_t temp_auto_point1_temp_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_tmin[nr]));\n}\nstatic ssize_t temp_auto_point1_temp_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_tmin[nr] = TEMP_TO_REG(val);\n\tadm1026_write_value(client, ADM1026_REG_TEMP_TMIN[nr],\n\t\tdata->temp_tmin[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_point1_temp, temp_auto_point1_temp, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_auto_point1_temp_hyst,\n\t\t\t     temp_auto_point1_temp_hyst, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_auto_point2_temp, temp_auto_point2_temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_point1_temp, temp_auto_point1_temp, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_auto_point1_temp_hyst,\n\t\t\t     temp_auto_point1_temp_hyst, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_auto_point2_temp, temp_auto_point2_temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_point1_temp, temp_auto_point1_temp, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_auto_point1_temp_hyst,\n\t\t\t     temp_auto_point1_temp_hyst, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_auto_point2_temp, temp_auto_point2_temp, 2);\n\nstatic ssize_t show_temp_crit_enable(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (data->config1 & CFG1_THERM_HOT) >> 4);\n}\nstatic ssize_t set_temp_crit_enable(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->config1 = (data->config1 & ~CFG1_THERM_HOT) | (val << 4);\n\tadm1026_write_value(client, ADM1026_REG_CONFIG1, data->config1);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(temp1_crit_enable, 0644, show_temp_crit_enable,\n\t\t   set_temp_crit_enable);\nstatic DEVICE_ATTR(temp2_crit_enable, 0644, show_temp_crit_enable,\n\t\t   set_temp_crit_enable);\nstatic DEVICE_ATTR(temp3_crit_enable, 0644, show_temp_crit_enable,\n\t\t   set_temp_crit_enable);\n\nstatic ssize_t temp_crit_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_crit[nr]));\n}\nstatic ssize_t temp_crit_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_crit[nr] = TEMP_TO_REG(val);\n\tadm1026_write_value(client, ADM1026_REG_TEMP_THERM[nr],\n\t\tdata->temp_crit[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_crit, temp_crit, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_crit, temp_crit, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_crit, temp_crit, 2);\n\nstatic ssize_t analog_out_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", DAC_FROM_REG(data->analog_out));\n}\nstatic ssize_t analog_out_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->analog_out = DAC_TO_REG(val);\n\tadm1026_write_value(client, ADM1026_REG_DAC, data->analog_out);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(analog_out);\n\nstatic ssize_t cpu0_vid_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\tint vid = (data->gpio >> 11) & 0x1f;\n\n\tdev_dbg(dev, \"Setting VID from GPIO11-15.\\n\");\n\treturn sprintf(buf, \"%d\\n\", vid_from_reg(vid, data->vrm));\n}\n\nstatic DEVICE_ATTR_RO(cpu0_vid);\n\nstatic ssize_t vrm_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", data->vrm);\n}\n\nstatic ssize_t vrm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tdata->vrm = val;\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(vrm);\n\nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", data->alarms);\n}\n\nstatic DEVICE_ATTR_RO(alarms);\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\treturn sprintf(buf, \"%ld\\n\", (data->alarms >> bitnr) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp2_alarm, alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_alarm, alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in9_alarm, alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in11_alarm, alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in12_alarm, alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in13_alarm, alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in14_alarm, alarm, 5);\nstatic SENSOR_DEVICE_ATTR_RO(in15_alarm, alarm, 6);\nstatic SENSOR_DEVICE_ATTR_RO(in16_alarm, alarm, 7);\nstatic SENSOR_DEVICE_ATTR_RO(in0_alarm, alarm, 8);\nstatic SENSOR_DEVICE_ATTR_RO(in1_alarm, alarm, 9);\nstatic SENSOR_DEVICE_ATTR_RO(in2_alarm, alarm, 10);\nstatic SENSOR_DEVICE_ATTR_RO(in3_alarm, alarm, 11);\nstatic SENSOR_DEVICE_ATTR_RO(in4_alarm, alarm, 12);\nstatic SENSOR_DEVICE_ATTR_RO(in5_alarm, alarm, 13);\nstatic SENSOR_DEVICE_ATTR_RO(in6_alarm, alarm, 14);\nstatic SENSOR_DEVICE_ATTR_RO(in7_alarm, alarm, 15);\nstatic SENSOR_DEVICE_ATTR_RO(fan1_alarm, alarm, 16);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_alarm, alarm, 17);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_alarm, alarm, 18);\nstatic SENSOR_DEVICE_ATTR_RO(fan4_alarm, alarm, 19);\nstatic SENSOR_DEVICE_ATTR_RO(fan5_alarm, alarm, 20);\nstatic SENSOR_DEVICE_ATTR_RO(fan6_alarm, alarm, 21);\nstatic SENSOR_DEVICE_ATTR_RO(fan7_alarm, alarm, 22);\nstatic SENSOR_DEVICE_ATTR_RO(fan8_alarm, alarm, 23);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_alarm, alarm, 24);\nstatic SENSOR_DEVICE_ATTR_RO(in10_alarm, alarm, 25);\nstatic SENSOR_DEVICE_ATTR_RO(in8_alarm, alarm, 26);\n\nstatic ssize_t alarm_mask_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", data->alarm_mask);\n}\nstatic ssize_t alarm_mask_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long mask;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->alarm_mask = val & 0x7fffffff;\n\tmask = data->alarm_mask\n\t\t| (data->gpio_mask & 0x10000 ? 0x80000000 : 0);\n\tadm1026_write_value(client, ADM1026_REG_MASK1,\n\t\tmask & 0xff);\n\tmask >>= 8;\n\tadm1026_write_value(client, ADM1026_REG_MASK2,\n\t\tmask & 0xff);\n\tmask >>= 8;\n\tadm1026_write_value(client, ADM1026_REG_MASK3,\n\t\tmask & 0xff);\n\tmask >>= 8;\n\tadm1026_write_value(client, ADM1026_REG_MASK4,\n\t\tmask & 0xff);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(alarm_mask);\n\nstatic ssize_t gpio_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", data->gpio);\n}\nstatic ssize_t gpio_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong gpio;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->gpio = val & 0x1ffff;\n\tgpio = data->gpio;\n\tadm1026_write_value(client, ADM1026_REG_GPIO_STATUS_0_7, gpio & 0xff);\n\tgpio >>= 8;\n\tadm1026_write_value(client, ADM1026_REG_GPIO_STATUS_8_15, gpio & 0xff);\n\tgpio = ((gpio >> 1) & 0x80) | (data->alarms >> 24 & 0x7f);\n\tadm1026_write_value(client, ADM1026_REG_STATUS4, gpio & 0xff);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(gpio);\n\nstatic ssize_t gpio_mask_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", data->gpio_mask);\n}\nstatic ssize_t gpio_mask_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong mask;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->gpio_mask = val & 0x1ffff;\n\tmask = data->gpio_mask;\n\tadm1026_write_value(client, ADM1026_REG_GPIO_MASK_0_7, mask & 0xff);\n\tmask >>= 8;\n\tadm1026_write_value(client, ADM1026_REG_GPIO_MASK_8_15, mask & 0xff);\n\tmask = ((mask >> 1) & 0x80) | (data->alarm_mask >> 24 & 0x7f);\n\tadm1026_write_value(client, ADM1026_REG_MASK1, mask & 0xff);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(gpio_mask);\n\nstatic ssize_t pwm1_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", PWM_FROM_REG(data->pwm1.pwm));\n}\n\nstatic ssize_t pwm1_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tif (data->pwm1.enable == 1) {\n\t\tlong val;\n\t\tint err;\n\n\t\terr = kstrtol(buf, 10, &val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmutex_lock(&data->update_lock);\n\t\tdata->pwm1.pwm = PWM_TO_REG(val);\n\t\tadm1026_write_value(client, ADM1026_REG_PWM, data->pwm1.pwm);\n\t\tmutex_unlock(&data->update_lock);\n\t}\n\treturn count;\n}\n\nstatic ssize_t temp1_auto_point1_pwm_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm1.auto_pwm_min);\n}\n\nstatic ssize_t temp1_auto_point1_pwm_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm1.auto_pwm_min = clamp_val(val, 0, 255);\n\tif (data->pwm1.enable == 2) {  \n\t\tdata->pwm1.pwm = PWM_TO_REG((data->pwm1.pwm & 0x0f) |\n\t\t\tPWM_MIN_TO_REG(data->pwm1.auto_pwm_min));\n\t\tadm1026_write_value(client, ADM1026_REG_PWM, data->pwm1.pwm);\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t temp1_auto_point2_pwm_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", ADM1026_PWM_MAX);\n}\n\nstatic ssize_t pwm1_enable_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct adm1026_data *data = adm1026_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm1.enable);\n}\n\nstatic ssize_t pwm1_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct adm1026_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint old_enable;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val >= 3)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\told_enable = data->pwm1.enable;\n\tdata->pwm1.enable = val;\n\tdata->config1 = (data->config1 & ~CFG1_PWM_AFC)\n\t\t\t| ((val == 2) ? CFG1_PWM_AFC : 0);\n\tadm1026_write_value(client, ADM1026_REG_CONFIG1, data->config1);\n\tif (val == 2) {  \n\t\tdata->pwm1.pwm = PWM_TO_REG((data->pwm1.pwm & 0x0f) |\n\t\t\tPWM_MIN_TO_REG(data->pwm1.auto_pwm_min));\n\t\tadm1026_write_value(client, ADM1026_REG_PWM, data->pwm1.pwm);\n\t} else if (!((old_enable == 1) && (val == 1))) {\n\t\t \n\t\tdata->pwm1.pwm = 255;\n\t\tadm1026_write_value(client, ADM1026_REG_PWM, data->pwm1.pwm);\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \nstatic DEVICE_ATTR_RW(pwm1);\nstatic DEVICE_ATTR(pwm2, 0644, pwm1_show, pwm1_store);\nstatic DEVICE_ATTR(pwm3, 0644, pwm1_show, pwm1_store);\nstatic DEVICE_ATTR_RW(pwm1_enable);\nstatic DEVICE_ATTR(pwm2_enable, 0644, pwm1_enable_show,\n\t\t   pwm1_enable_store);\nstatic DEVICE_ATTR(pwm3_enable, 0644, pwm1_enable_show,\n\t\t   pwm1_enable_store);\nstatic DEVICE_ATTR_RW(temp1_auto_point1_pwm);\nstatic DEVICE_ATTR(temp2_auto_point1_pwm, 0644,\n\t\t   temp1_auto_point1_pwm_show, temp1_auto_point1_pwm_store);\nstatic DEVICE_ATTR(temp3_auto_point1_pwm, 0644,\n\t\t   temp1_auto_point1_pwm_show, temp1_auto_point1_pwm_store);\n\nstatic DEVICE_ATTR_RO(temp1_auto_point2_pwm);\nstatic DEVICE_ATTR(temp2_auto_point2_pwm, 0444, temp1_auto_point2_pwm_show,\n\t\t   NULL);\nstatic DEVICE_ATTR(temp3_auto_point2_pwm, 0444, temp1_auto_point2_pwm_show,\n\t\t   NULL);\n\nstatic struct attribute *adm1026_attributes[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_max.dev_attr.attr,\n\t&sensor_dev_attr_in6_min.dev_attr.attr,\n\t&sensor_dev_attr_in6_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_max.dev_attr.attr,\n\t&sensor_dev_attr_in7_min.dev_attr.attr,\n\t&sensor_dev_attr_in7_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in10_input.dev_attr.attr,\n\t&sensor_dev_attr_in10_max.dev_attr.attr,\n\t&sensor_dev_attr_in10_min.dev_attr.attr,\n\t&sensor_dev_attr_in10_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in11_input.dev_attr.attr,\n\t&sensor_dev_attr_in11_max.dev_attr.attr,\n\t&sensor_dev_attr_in11_min.dev_attr.attr,\n\t&sensor_dev_attr_in11_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in12_input.dev_attr.attr,\n\t&sensor_dev_attr_in12_max.dev_attr.attr,\n\t&sensor_dev_attr_in12_min.dev_attr.attr,\n\t&sensor_dev_attr_in12_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in13_input.dev_attr.attr,\n\t&sensor_dev_attr_in13_max.dev_attr.attr,\n\t&sensor_dev_attr_in13_min.dev_attr.attr,\n\t&sensor_dev_attr_in13_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in14_input.dev_attr.attr,\n\t&sensor_dev_attr_in14_max.dev_attr.attr,\n\t&sensor_dev_attr_in14_min.dev_attr.attr,\n\t&sensor_dev_attr_in14_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in15_input.dev_attr.attr,\n\t&sensor_dev_attr_in15_max.dev_attr.attr,\n\t&sensor_dev_attr_in15_min.dev_attr.attr,\n\t&sensor_dev_attr_in15_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in16_input.dev_attr.attr,\n\t&sensor_dev_attr_in16_max.dev_attr.attr,\n\t&sensor_dev_attr_in16_min.dev_attr.attr,\n\t&sensor_dev_attr_in16_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_div.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_div.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_div.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan4_input.dev_attr.attr,\n\t&sensor_dev_attr_fan4_div.dev_attr.attr,\n\t&sensor_dev_attr_fan4_min.dev_attr.attr,\n\t&sensor_dev_attr_fan4_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan5_input.dev_attr.attr,\n\t&sensor_dev_attr_fan5_div.dev_attr.attr,\n\t&sensor_dev_attr_fan5_min.dev_attr.attr,\n\t&sensor_dev_attr_fan5_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan6_input.dev_attr.attr,\n\t&sensor_dev_attr_fan6_div.dev_attr.attr,\n\t&sensor_dev_attr_fan6_min.dev_attr.attr,\n\t&sensor_dev_attr_fan6_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan7_input.dev_attr.attr,\n\t&sensor_dev_attr_fan7_div.dev_attr.attr,\n\t&sensor_dev_attr_fan7_min.dev_attr.attr,\n\t&sensor_dev_attr_fan7_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan8_input.dev_attr.attr,\n\t&sensor_dev_attr_fan8_div.dev_attr.attr,\n\t&sensor_dev_attr_fan8_min.dev_attr.attr,\n\t&sensor_dev_attr_fan8_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp2_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit.dev_attr.attr,\n\t&dev_attr_temp1_crit_enable.attr,\n\t&dev_attr_temp2_crit_enable.attr,\n\t&dev_attr_cpu0_vid.attr,\n\t&dev_attr_vrm.attr,\n\t&dev_attr_alarms.attr,\n\t&dev_attr_alarm_mask.attr,\n\t&dev_attr_gpio.attr,\n\t&dev_attr_gpio_mask.attr,\n\t&dev_attr_pwm1.attr,\n\t&dev_attr_pwm2.attr,\n\t&dev_attr_pwm3.attr,\n\t&dev_attr_pwm1_enable.attr,\n\t&dev_attr_pwm2_enable.attr,\n\t&dev_attr_pwm3_enable.attr,\n\t&dev_attr_temp1_auto_point1_pwm.attr,\n\t&dev_attr_temp2_auto_point1_pwm.attr,\n\t&dev_attr_temp1_auto_point2_pwm.attr,\n\t&dev_attr_temp2_auto_point2_pwm.attr,\n\t&dev_attr_analog_out.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adm1026_group = {\n\t.attrs = adm1026_attributes,\n};\n\nstatic struct attribute *adm1026_attributes_temp3[] = {\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit.dev_attr.attr,\n\t&dev_attr_temp3_crit_enable.attr,\n\t&dev_attr_temp3_auto_point1_pwm.attr,\n\t&dev_attr_temp3_auto_point2_pwm.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adm1026_group_temp3 = {\n\t.attrs = adm1026_attributes_temp3,\n};\n\nstatic struct attribute *adm1026_attributes_in8_9[] = {\n\t&sensor_dev_attr_in8_input.dev_attr.attr,\n\t&sensor_dev_attr_in8_max.dev_attr.attr,\n\t&sensor_dev_attr_in8_min.dev_attr.attr,\n\t&sensor_dev_attr_in8_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in9_input.dev_attr.attr,\n\t&sensor_dev_attr_in9_max.dev_attr.attr,\n\t&sensor_dev_attr_in9_min.dev_attr.attr,\n\t&sensor_dev_attr_in9_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adm1026_group_in8_9 = {\n\t.attrs = adm1026_attributes_in8_9,\n};\n\n \nstatic int adm1026_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint address = client->addr;\n\tint company, verstep;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\tcompany = adm1026_read_value(client, ADM1026_REG_COMPANY);\n\tverstep = adm1026_read_value(client, ADM1026_REG_VERSTEP);\n\n\tdev_dbg(&adapter->dev,\n\t\t\"Detecting device at %d,0x%02x with COMPANY: 0x%02x and VERSTEP: 0x%02x\\n\",\n\t\ti2c_adapter_id(client->adapter), client->addr,\n\t\tcompany, verstep);\n\n\t \n\tdev_dbg(&adapter->dev, \"Autodetecting device at %d,0x%02x...\\n\",\n\t\ti2c_adapter_id(adapter), address);\n\tif (company == ADM1026_COMPANY_ANALOG_DEV\n\t    && verstep == ADM1026_VERSTEP_ADM1026) {\n\t\t \n\t} else if (company == ADM1026_COMPANY_ANALOG_DEV\n\t\t&& (verstep & 0xf0) == ADM1026_VERSTEP_GENERIC) {\n\t\tdev_err(&adapter->dev,\n\t\t\t\"Unrecognized stepping 0x%02x. Defaulting to ADM1026.\\n\",\n\t\t\tverstep);\n\t} else if ((verstep & 0xf0) == ADM1026_VERSTEP_GENERIC) {\n\t\tdev_err(&adapter->dev,\n\t\t\t\"Found version/stepping 0x%02x. Assuming generic ADM1026.\\n\",\n\t\t\tverstep);\n\t} else {\n\t\tdev_dbg(&adapter->dev, \"Autodetection failed\\n\");\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, \"adm1026\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic void adm1026_print_gpio(struct i2c_client *client)\n{\n\tstruct adm1026_data *data = i2c_get_clientdata(client);\n\tint i;\n\n\tdev_dbg(&client->dev, \"GPIO config is:\\n\");\n\tfor (i = 0; i <= 7; ++i) {\n\t\tif (data->config2 & (1 << i)) {\n\t\t\tdev_dbg(&client->dev, \"\\t%sGP%s%d\\n\",\n\t\t\t\tdata->gpio_config[i] & 0x02 ? \"\" : \"!\",\n\t\t\t\tdata->gpio_config[i] & 0x01 ? \"OUT\" : \"IN\",\n\t\t\t\ti);\n\t\t} else {\n\t\t\tdev_dbg(&client->dev, \"\\tFAN%d\\n\", i);\n\t\t}\n\t}\n\tfor (i = 8; i <= 15; ++i) {\n\t\tdev_dbg(&client->dev, \"\\t%sGP%s%d\\n\",\n\t\t\tdata->gpio_config[i] & 0x02 ? \"\" : \"!\",\n\t\t\tdata->gpio_config[i] & 0x01 ? \"OUT\" : \"IN\",\n\t\t\ti);\n\t}\n\tif (data->config3 & CFG3_GPIO16_ENABLE) {\n\t\tdev_dbg(&client->dev, \"\\t%sGP%s16\\n\",\n\t\t\tdata->gpio_config[16] & 0x02 ? \"\" : \"!\",\n\t\t\tdata->gpio_config[16] & 0x01 ? \"OUT\" : \"IN\");\n\t} else {\n\t\t \n\t\tdev_dbg(&client->dev, \"\\tTHERM\\n\");\n\t}\n}\n\nstatic void adm1026_fixup_gpio(struct i2c_client *client)\n{\n\tstruct adm1026_data *data = i2c_get_clientdata(client);\n\tint i;\n\tint value;\n\n\t \n\t \n\n\t \n\tfor (i = 0; i <= 16; ++i) {\n\t\tif (gpio_output[i] >= 0 && gpio_output[i] <= 16)\n\t\t\tdata->gpio_config[gpio_output[i]] |= 0x01;\n\t\t \n\t\tif (gpio_output[i] >= 0 && gpio_output[i] <= 7)\n\t\t\tdata->config2 |= 1 << gpio_output[i];\n\t}\n\n\t \n\tfor (i = 0; i <= 16; ++i) {\n\t\tif (gpio_input[i] >= 0 && gpio_input[i] <= 16)\n\t\t\tdata->gpio_config[gpio_input[i]] &= ~0x01;\n\t\t \n\t\tif (gpio_input[i] >= 0 && gpio_input[i] <= 7)\n\t\t\tdata->config2 |= 1 << gpio_input[i];\n\t}\n\n\t \n\tfor (i = 0; i <= 16; ++i) {\n\t\tif (gpio_inverted[i] >= 0 && gpio_inverted[i] <= 16)\n\t\t\tdata->gpio_config[gpio_inverted[i]] &= ~0x02;\n\t}\n\n\t \n\tfor (i = 0; i <= 16; ++i) {\n\t\tif (gpio_normal[i] >= 0 && gpio_normal[i] <= 16)\n\t\t\tdata->gpio_config[gpio_normal[i]] |= 0x02;\n\t}\n\n\t \n\tfor (i = 0; i <= 7; ++i) {\n\t\tif (gpio_fan[i] >= 0 && gpio_fan[i] <= 7)\n\t\t\tdata->config2 &= ~(1 << gpio_fan[i]);\n\t}\n\n\t \n\tadm1026_write_value(client, ADM1026_REG_CONFIG2, data->config2);\n\tdata->config3 = (data->config3 & 0x3f)\n\t\t\t| ((data->gpio_config[16] & 0x03) << 6);\n\tadm1026_write_value(client, ADM1026_REG_CONFIG3, data->config3);\n\tfor (i = 15, value = 0; i >= 0; --i) {\n\t\tvalue <<= 2;\n\t\tvalue |= data->gpio_config[i] & 0x03;\n\t\tif ((i & 0x03) == 0) {\n\t\t\tadm1026_write_value(client,\n\t\t\t\t\tADM1026_REG_GPIO_CFG_0_3 + i/4,\n\t\t\t\t\tvalue);\n\t\t\tvalue = 0;\n\t\t}\n\t}\n\n\t \n\tadm1026_print_gpio(client);\n}\n\nstatic void adm1026_init_client(struct i2c_client *client)\n{\n\tint value, i;\n\tstruct adm1026_data *data = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"Initializing device\\n\");\n\t \n\tdata->config1 = adm1026_read_value(client, ADM1026_REG_CONFIG1);\n\tdata->config2 = adm1026_read_value(client, ADM1026_REG_CONFIG2);\n\tdata->config3 = adm1026_read_value(client, ADM1026_REG_CONFIG3);\n\n\t \n\tdev_dbg(&client->dev, \"ADM1026_REG_CONFIG1 is: 0x%02x\\n\",\n\t\tdata->config1);\n\tif ((data->config1 & CFG1_MONITOR) == 0) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Monitoring not currently enabled.\\n\");\n\t}\n\tif (data->config1 & CFG1_INT_ENABLE) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"SMBALERT interrupts are enabled.\\n\");\n\t}\n\tif (data->config1 & CFG1_AIN8_9) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"in8 and in9 enabled. temp3 disabled.\\n\");\n\t} else {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"temp3 enabled.  in8 and in9 disabled.\\n\");\n\t}\n\tif (data->config1 & CFG1_THERM_HOT) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Automatic THERM, PWM, and temp limits enabled.\\n\");\n\t}\n\n\tif (data->config3 & CFG3_GPIO16_ENABLE) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"GPIO16 enabled.  THERM pin disabled.\\n\");\n\t} else {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"THERM pin enabled.  GPIO16 disabled.\\n\");\n\t}\n\tif (data->config3 & CFG3_VREF_250)\n\t\tdev_dbg(&client->dev, \"Vref is 2.50 Volts.\\n\");\n\telse\n\t\tdev_dbg(&client->dev, \"Vref is 1.82 Volts.\\n\");\n\t \n\tvalue = 0;\n\tfor (i = 0; i <= 15; ++i) {\n\t\tif ((i & 0x03) == 0) {\n\t\t\tvalue = adm1026_read_value(client,\n\t\t\t\t\tADM1026_REG_GPIO_CFG_0_3 + i / 4);\n\t\t}\n\t\tdata->gpio_config[i] = value & 0x03;\n\t\tvalue >>= 2;\n\t}\n\tdata->gpio_config[16] = (data->config3 >> 6) & 0x03;\n\n\t \n\tadm1026_print_gpio(client);\n\n\t \n\tif (gpio_input[0] != -1 || gpio_output[0] != -1\n\t\t|| gpio_inverted[0] != -1 || gpio_normal[0] != -1\n\t\t|| gpio_fan[0] != -1) {\n\t\tadm1026_fixup_gpio(client);\n\t}\n\n\t \n\tdata->pwm1.auto_pwm_min = 255;\n\t \n\tvalue = adm1026_read_value(client, ADM1026_REG_CONFIG1);\n\t \n\tvalue = (value | CFG1_MONITOR) & (~CFG1_INT_CLEAR & ~CFG1_RESET);\n\tdev_dbg(&client->dev, \"Setting CONFIG to: 0x%02x\\n\", value);\n\tdata->config1 = value;\n\tadm1026_write_value(client, ADM1026_REG_CONFIG1, value);\n\n\t \n\tvalue = adm1026_read_value(client, ADM1026_REG_FAN_DIV_0_3) |\n\t\t(adm1026_read_value(client, ADM1026_REG_FAN_DIV_4_7) << 8);\n\tfor (i = 0; i <= 7; ++i) {\n\t\tdata->fan_div[i] = DIV_FROM_REG(value & 0x03);\n\t\tvalue >>= 2;\n\t}\n}\n\nstatic int adm1026_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct adm1026_data *data;\n\n\tdata = devm_kzalloc(dev, sizeof(struct adm1026_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tdata->vrm = vid_which_vrm();\n\n\t \n\tadm1026_init_client(client);\n\n\t \n\tdata->groups[0] = &adm1026_group;\n\tif (data->config1 & CFG1_AIN8_9)\n\t\tdata->groups[1] = &adm1026_group_in8_9;\n\telse\n\t\tdata->groups[1] = &adm1026_group_temp3;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, data->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id adm1026_id[] = {\n\t{ \"adm1026\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adm1026_id);\n\nstatic struct i2c_driver adm1026_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"adm1026\",\n\t},\n\t.probe\t\t= adm1026_probe,\n\t.id_table\t= adm1026_id,\n\t.detect\t\t= adm1026_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(adm1026_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Philip Pokorny <ppokorny@penguincomputing.com>, \"\n\t      \"Justin Thiessen <jthiessen@penguincomputing.com>\");\nMODULE_DESCRIPTION(\"ADM1026 driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}