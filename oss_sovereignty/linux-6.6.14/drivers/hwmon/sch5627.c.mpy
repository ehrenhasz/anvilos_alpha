{
  "module_name": "sch5627.c",
  "hash_id": "08abc9f026e847ab8fc0b2db95c9e3eb577cc0a32d8e21a286aea5b625fd22c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/sch5627.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bits.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include \"sch56xx-common.h\"\n\n#define DRVNAME \"sch5627\"\n#define DEVNAME DRVNAME  \n\n#define SCH5627_HWMON_ID\t\t0xa5\n#define SCH5627_COMPANY_ID\t\t0x5c\n#define SCH5627_PRIMARY_ID\t\t0xa0\n\n#define SCH5627_REG_BUILD_CODE\t\t0x39\n#define SCH5627_REG_BUILD_ID\t\t0x3a\n#define SCH5627_REG_HWMON_ID\t\t0x3c\n#define SCH5627_REG_HWMON_REV\t\t0x3d\n#define SCH5627_REG_COMPANY_ID\t\t0x3e\n#define SCH5627_REG_PRIMARY_ID\t\t0x3f\n#define SCH5627_REG_CTRL\t\t0x40\n\n#define SCH5627_CTRL_START\t\tBIT(0)\n#define SCH5627_CTRL_LOCK\t\tBIT(1)\n#define SCH5627_CTRL_VBAT\t\tBIT(4)\n\n#define SCH5627_NO_TEMPS\t\t8\n#define SCH5627_NO_FANS\t\t\t4\n#define SCH5627_NO_IN\t\t\t5\n\nstatic const u16 SCH5627_REG_TEMP_MSB[SCH5627_NO_TEMPS] = {\n\t0x2B, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x180, 0x181 };\nstatic const u16 SCH5627_REG_TEMP_LSN[SCH5627_NO_TEMPS] = {\n\t0xE2, 0xE1, 0xE1, 0xE5, 0xE5, 0xE6, 0x182, 0x182 };\nstatic const u16 SCH5627_REG_TEMP_HIGH_NIBBLE[SCH5627_NO_TEMPS] = {\n\t0, 0, 1, 1, 0, 0, 0, 1 };\nstatic const u16 SCH5627_REG_TEMP_HIGH[SCH5627_NO_TEMPS] = {\n\t0x61, 0x57, 0x59, 0x5B, 0x5D, 0x5F, 0x184, 0x186 };\nstatic const u16 SCH5627_REG_TEMP_ABS[SCH5627_NO_TEMPS] = {\n\t0x9B, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x1A8, 0x1A9 };\n\nstatic const u16 SCH5627_REG_FAN[SCH5627_NO_FANS] = {\n\t0x2C, 0x2E, 0x30, 0x32 };\nstatic const u16 SCH5627_REG_FAN_MIN[SCH5627_NO_FANS] = {\n\t0x62, 0x64, 0x66, 0x68 };\n\nstatic const u16 SCH5627_REG_PWM_MAP[SCH5627_NO_FANS] = {\n\t0xA0, 0xA1, 0xA2, 0xA3 };\n\nstatic const u16 SCH5627_REG_IN_MSB[SCH5627_NO_IN] = {\n\t0x22, 0x23, 0x24, 0x25, 0x189 };\nstatic const u16 SCH5627_REG_IN_LSN[SCH5627_NO_IN] = {\n\t0xE4, 0xE4, 0xE3, 0xE3, 0x18A };\nstatic const u16 SCH5627_REG_IN_HIGH_NIBBLE[SCH5627_NO_IN] = {\n\t1, 0, 1, 0, 1 };\nstatic const u16 SCH5627_REG_IN_FACTOR[SCH5627_NO_IN] = {\n\t10745, 3660, 9765, 10745, 3660 };\nstatic const char * const SCH5627_IN_LABELS[SCH5627_NO_IN] = {\n\t\"VCC\", \"VTT\", \"VBAT\", \"VTR\", \"V_IN\" };\n\nstruct sch5627_data {\n\tunsigned short addr;\n\tu8 control;\n\tu8 temp_max[SCH5627_NO_TEMPS];\n\tu8 temp_crit[SCH5627_NO_TEMPS];\n\tu16 fan_min[SCH5627_NO_FANS];\n\n\tstruct mutex update_lock;\n\tunsigned long last_battery;\t \n\tchar temp_valid;\t\t \n\tchar fan_valid;\n\tchar in_valid;\n\tunsigned long temp_last_updated;\t \n\tunsigned long fan_last_updated;\n\tunsigned long in_last_updated;\n\tu16 temp[SCH5627_NO_TEMPS];\n\tu16 fan[SCH5627_NO_FANS];\n\tu16 in[SCH5627_NO_IN];\n};\n\nstatic int sch5627_update_temp(struct sch5627_data *data)\n{\n\tint ret = 0;\n\tint i, val;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tif (time_after(jiffies, data->temp_last_updated + HZ) || !data->temp_valid) {\n\t\tfor (i = 0; i < SCH5627_NO_TEMPS; i++) {\n\t\t\tval = sch56xx_read_virtual_reg12(data->addr, SCH5627_REG_TEMP_MSB[i],\n\t\t\t\t\t\t\t SCH5627_REG_TEMP_LSN[i],\n\t\t\t\t\t\t\t SCH5627_REG_TEMP_HIGH_NIBBLE[i]);\n\t\t\tif (unlikely(val < 0)) {\n\t\t\t\tret = val;\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tdata->temp[i] = val;\n\t\t}\n\t\tdata->temp_last_updated = jiffies;\n\t\tdata->temp_valid = 1;\n\t}\nabort:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic int sch5627_update_fan(struct sch5627_data *data)\n{\n\tint ret = 0;\n\tint i, val;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tif (time_after(jiffies, data->fan_last_updated + HZ) || !data->fan_valid) {\n\t\tfor (i = 0; i < SCH5627_NO_FANS; i++) {\n\t\t\tval = sch56xx_read_virtual_reg16(data->addr, SCH5627_REG_FAN[i]);\n\t\t\tif (unlikely(val < 0)) {\n\t\t\t\tret = val;\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tdata->fan[i] = val;\n\t\t}\n\t\tdata->fan_last_updated = jiffies;\n\t\tdata->fan_valid = 1;\n\t}\nabort:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic int sch5627_update_in(struct sch5627_data *data)\n{\n\tint ret = 0;\n\tint i, val;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tif (time_after(jiffies, data->last_battery + 300 * HZ)) {\n\t\tsch56xx_write_virtual_reg(data->addr, SCH5627_REG_CTRL,\n\t\t\t\t\t  data->control | SCH5627_CTRL_VBAT);\n\t\tdata->last_battery = jiffies;\n\t}\n\n\t \n\tif (time_after(jiffies, data->in_last_updated + HZ) || !data->in_valid) {\n\t\tfor (i = 0; i < SCH5627_NO_IN; i++) {\n\t\t\tval = sch56xx_read_virtual_reg12(data->addr, SCH5627_REG_IN_MSB[i],\n\t\t\t\t\t\t\t SCH5627_REG_IN_LSN[i],\n\t\t\t\t\t\t\t SCH5627_REG_IN_HIGH_NIBBLE[i]);\n\t\t\tif (unlikely(val < 0)) {\n\t\t\t\tret = val;\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tdata->in[i] = val;\n\t\t}\n\t\tdata->in_last_updated = jiffies;\n\t\tdata->in_valid = 1;\n\t}\nabort:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic int sch5627_read_limits(struct sch5627_data *data)\n{\n\tint i, val;\n\n\tfor (i = 0; i < SCH5627_NO_TEMPS; i++) {\n\t\t \n\t\tval = sch56xx_read_virtual_reg(data->addr,\n\t\t\t\t\t       SCH5627_REG_TEMP_ABS[i]);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp_max[i] = val;\n\n\t\tval = sch56xx_read_virtual_reg(data->addr,\n\t\t\t\t\t       SCH5627_REG_TEMP_HIGH[i]);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->temp_crit[i] = val;\n\t}\n\tfor (i = 0; i < SCH5627_NO_FANS; i++) {\n\t\tval = sch56xx_read_virtual_reg16(data->addr,\n\t\t\t\t\t\t SCH5627_REG_FAN_MIN[i]);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tdata->fan_min[i] = val;\n\t}\n\n\treturn 0;\n}\n\nstatic int reg_to_temp(u16 reg)\n{\n\treturn (reg * 625) / 10 - 64000;\n}\n\nstatic int reg_to_temp_limit(u8 reg)\n{\n\treturn (reg - 64) * 1000;\n}\n\nstatic int reg_to_rpm(u16 reg)\n{\n\tif (reg == 0)\n\t\treturn -EIO;\n\tif (reg == 0xffff)\n\t\treturn 0;\n\n\treturn 5400540 / reg;\n}\n\nstatic umode_t sch5627_is_visible(const void *drvdata, enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t  int channel)\n{\n\tconst struct sch5627_data *data = drvdata;\n\n\t \n\tif (data->control & SCH5627_CTRL_LOCK)\n\t\treturn 0444;\n\n\tif (type == hwmon_pwm && attr == hwmon_pwm_auto_channels_temp)\n\t\treturn 0644;\n\n\treturn 0444;\n}\n\nstatic int sch5627_read(struct device *dev, enum hwmon_sensor_types type, u32 attr, int channel,\n\t\t\tlong *val)\n{\n\tstruct sch5627_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tret = sch5627_update_temp(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\t*val = reg_to_temp(data->temp[channel]);\n\t\t\treturn 0;\n\t\tcase hwmon_temp_max:\n\t\t\t*val = reg_to_temp_limit(data->temp_max[channel]);\n\t\t\treturn 0;\n\t\tcase hwmon_temp_crit:\n\t\t\t*val = reg_to_temp_limit(data->temp_crit[channel]);\n\t\t\treturn 0;\n\t\tcase hwmon_temp_fault:\n\t\t\t*val = (data->temp[channel] == 0);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tret = sch5627_update_fan(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\tret = reg_to_rpm(data->fan[channel]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\treturn 0;\n\t\tcase hwmon_fan_min:\n\t\t\tret = reg_to_rpm(data->fan_min[channel]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\treturn 0;\n\t\tcase hwmon_fan_fault:\n\t\t\t*val = (data->fan[channel] == 0xffff);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_auto_channels_temp:\n\t\t\tmutex_lock(&data->update_lock);\n\t\t\tret = sch56xx_read_virtual_reg(data->addr, SCH5627_REG_PWM_MAP[channel]);\n\t\t\tmutex_unlock(&data->update_lock);\n\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t*val = ret;\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tret = sch5627_update_in(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\t*val = DIV_ROUND_CLOSEST(data->in[channel] * SCH5627_REG_IN_FACTOR[channel],\n\t\t\t\t\t\t 10000);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int sch5627_read_string(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t       int channel, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_label:\n\t\t\t*str = SCH5627_IN_LABELS[channel];\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int sch5627_write(struct device *dev, enum hwmon_sensor_types type, u32 attr, int channel,\n\t\t\t long val)\n{\n\tstruct sch5627_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_auto_channels_temp:\n\t\t\t \n\t\t\tif (val > U8_MAX || val < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmutex_lock(&data->update_lock);\n\t\t\tret = sch56xx_write_virtual_reg(data->addr, SCH5627_REG_PWM_MAP[channel],\n\t\t\t\t\t\t\tval);\n\t\t\tmutex_unlock(&data->update_lock);\n\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct hwmon_ops sch5627_ops = {\n\t.is_visible = sch5627_is_visible,\n\t.read = sch5627_read,\n\t.read_string = sch5627_read_string,\n\t.write = sch5627_write,\n};\n\nstatic const struct hwmon_channel_info * const sch5627_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT | HWMON_T_FAULT\n\t\t\t   ),\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_FAULT\n\t\t\t   ),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP,\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP,\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP,\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP\n\t\t\t   ),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT\n\t\t\t   ),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info sch5627_chip_info = {\n\t.ops = &sch5627_ops,\n\t.info = sch5627_info,\n};\n\nstatic int sch5627_probe(struct platform_device *pdev)\n{\n\tstruct sch5627_data *data;\n\tstruct device *hwmon_dev;\n\tint err, build_code, build_id, hwmon_rev, val;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct sch5627_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->addr = platform_get_resource(pdev, IORESOURCE_IO, 0)->start;\n\tmutex_init(&data->update_lock);\n\tplatform_set_drvdata(pdev, data);\n\n\tval = sch56xx_read_virtual_reg(data->addr, SCH5627_REG_HWMON_ID);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val != SCH5627_HWMON_ID) {\n\t\tpr_err(\"invalid %s id: 0x%02X (expected 0x%02X)\\n\", \"hwmon\",\n\t\t       val, SCH5627_HWMON_ID);\n\t\treturn -ENODEV;\n\t}\n\n\tval = sch56xx_read_virtual_reg(data->addr, SCH5627_REG_COMPANY_ID);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val != SCH5627_COMPANY_ID) {\n\t\tpr_err(\"invalid %s id: 0x%02X (expected 0x%02X)\\n\", \"company\",\n\t\t       val, SCH5627_COMPANY_ID);\n\t\treturn -ENODEV;\n\t}\n\n\tval = sch56xx_read_virtual_reg(data->addr, SCH5627_REG_PRIMARY_ID);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val != SCH5627_PRIMARY_ID) {\n\t\tpr_err(\"invalid %s id: 0x%02X (expected 0x%02X)\\n\", \"primary\",\n\t\t       val, SCH5627_PRIMARY_ID);\n\t\treturn -ENODEV;\n\t}\n\n\tbuild_code = sch56xx_read_virtual_reg(data->addr,\n\t\t\t\t\t      SCH5627_REG_BUILD_CODE);\n\tif (build_code < 0)\n\t\treturn build_code;\n\n\tbuild_id = sch56xx_read_virtual_reg16(data->addr,\n\t\t\t\t\t      SCH5627_REG_BUILD_ID);\n\tif (build_id < 0)\n\t\treturn build_id;\n\n\thwmon_rev = sch56xx_read_virtual_reg(data->addr,\n\t\t\t\t\t     SCH5627_REG_HWMON_REV);\n\tif (hwmon_rev < 0)\n\t\treturn hwmon_rev;\n\n\tval = sch56xx_read_virtual_reg(data->addr, SCH5627_REG_CTRL);\n\tif (val < 0)\n\t\treturn val;\n\n\tdata->control = val;\n\tif (!(data->control & SCH5627_CTRL_START)) {\n\t\tpr_err(\"hardware monitoring not enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tsch56xx_write_virtual_reg(data->addr, SCH5627_REG_CTRL, data->control | SCH5627_CTRL_VBAT);\n\tdata->last_battery = jiffies;\n\n\t \n\terr = sch5627_read_limits(data);\n\tif (err)\n\t\treturn err;\n\n\tpr_info(\"found %s chip at %#hx\\n\", DEVNAME, data->addr);\n\tpr_info(\"firmware build: code 0x%02X, id 0x%04X, hwmon: rev 0x%02X\\n\",\n\t\tbuild_code, build_id, hwmon_rev);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&pdev->dev, DEVNAME, data,\n\t\t\t\t\t\t\t &sch5627_chip_info, NULL);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\t \n\tsch56xx_watchdog_register(&pdev->dev, data->addr,\n\t\t\t\t  (build_code << 24) | (build_id << 8) | hwmon_rev,\n\t\t\t\t  &data->update_lock, 1);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id sch5627_device_id[] = {\n\t{\n\t\t.name = \"sch5627\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, sch5627_device_id);\n\nstatic struct platform_driver sch5627_driver = {\n\t.driver = {\n\t\t.name\t= DRVNAME,\n\t},\n\t.probe\t\t= sch5627_probe,\n\t.id_table\t= sch5627_device_id,\n};\n\nmodule_platform_driver(sch5627_driver);\n\nMODULE_DESCRIPTION(\"SMSC SCH5627 Hardware Monitoring Driver\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}