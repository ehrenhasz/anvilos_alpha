{
  "module_name": "ina2xx.c",
  "hash_id": "a4ba2bb5c27a50c6e55b1db896a78825f68cee2ab4b28cb47c2bcd4c7282ecf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ina2xx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n#include <linux/util_macros.h>\n#include <linux/regmap.h>\n\n#include <linux/platform_data/ina2xx.h>\n\n \n#define INA2XX_CONFIG\t\t\t0x00\n#define INA2XX_SHUNT_VOLTAGE\t\t0x01  \n#define INA2XX_BUS_VOLTAGE\t\t0x02  \n#define INA2XX_POWER\t\t\t0x03  \n#define INA2XX_CURRENT\t\t\t0x04  \n#define INA2XX_CALIBRATION\t\t0x05\n\n \n#define INA226_MASK_ENABLE\t\t0x06\n#define INA226_ALERT_LIMIT\t\t0x07\n#define INA226_DIE_ID\t\t\t0xFF\n\n \n#define INA219_REGISTERS\t\t6\n#define INA226_REGISTERS\t\t8\n\n#define INA2XX_MAX_REGISTERS\t\t8\n\n \n#define INA219_CONFIG_DEFAULT\t\t0x399F\t \n#define INA226_CONFIG_DEFAULT\t\t0x4527\t \n\n \n#define INA2XX_CONVERSION_RATE\t\t15\n#define INA2XX_MAX_DELAY\t\t69  \n\n#define INA2XX_RSHUNT_DEFAULT\t\t10000\n\n \n#define INA226_AVG_RD_MASK\t\t0x0E00\n\n#define INA226_READ_AVG(reg)\t\t(((reg) & INA226_AVG_RD_MASK) >> 9)\n#define INA226_SHIFT_AVG(val)\t\t((val) << 9)\n\n \n#define INA226_SHUNT_OVER_VOLTAGE_BIT\t15\n#define INA226_SHUNT_UNDER_VOLTAGE_BIT\t14\n#define INA226_BUS_OVER_VOLTAGE_BIT\t13\n#define INA226_BUS_UNDER_VOLTAGE_BIT\t12\n#define INA226_POWER_OVER_LIMIT_BIT\t11\n\n \n#define INA226_ALERT_CONFIG_MASK\t0xFC00\n#define INA226_ALERT_FUNCTION_FLAG\tBIT(4)\n\n \n#define INA2XX_MAX_ATTRIBUTE_GROUPS\t3\n\n \n#define INA226_TOTAL_CONV_TIME_DEFAULT\t2200\n\nstatic struct regmap_config ina2xx_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n};\n\nenum ina2xx_ids { ina219, ina226 };\n\nstruct ina2xx_config {\n\tu16 config_default;\n\tint calibration_value;\n\tint registers;\n\tint shunt_div;\n\tint bus_voltage_shift;\n\tint bus_voltage_lsb;\t \n\tint power_lsb_factor;\n};\n\nstruct ina2xx_data {\n\tconst struct ina2xx_config *config;\n\n\tlong rshunt;\n\tlong current_lsb_uA;\n\tlong power_lsb_uW;\n\tstruct mutex config_lock;\n\tstruct regmap *regmap;\n\n\tconst struct attribute_group *groups[INA2XX_MAX_ATTRIBUTE_GROUPS];\n};\n\nstatic const struct ina2xx_config ina2xx_config[] = {\n\t[ina219] = {\n\t\t.config_default = INA219_CONFIG_DEFAULT,\n\t\t.calibration_value = 4096,\n\t\t.registers = INA219_REGISTERS,\n\t\t.shunt_div = 100,\n\t\t.bus_voltage_shift = 3,\n\t\t.bus_voltage_lsb = 4000,\n\t\t.power_lsb_factor = 20,\n\t},\n\t[ina226] = {\n\t\t.config_default = INA226_CONFIG_DEFAULT,\n\t\t.calibration_value = 2048,\n\t\t.registers = INA226_REGISTERS,\n\t\t.shunt_div = 400,\n\t\t.bus_voltage_shift = 0,\n\t\t.bus_voltage_lsb = 1250,\n\t\t.power_lsb_factor = 25,\n\t},\n};\n\n \nstatic const int ina226_avg_tab[] = { 1, 4, 16, 64, 128, 256, 512, 1024 };\n\nstatic int ina226_reg_to_interval(u16 config)\n{\n\tint avg = ina226_avg_tab[INA226_READ_AVG(config)];\n\n\t \n\treturn DIV_ROUND_CLOSEST(avg * INA226_TOTAL_CONV_TIME_DEFAULT, 1000);\n}\n\n \nstatic u16 ina226_interval_to_reg(int interval)\n{\n\tint avg, avg_bits;\n\n\tavg = DIV_ROUND_CLOSEST(interval * 1000,\n\t\t\t\tINA226_TOTAL_CONV_TIME_DEFAULT);\n\tavg_bits = find_closest(avg, ina226_avg_tab,\n\t\t\t\tARRAY_SIZE(ina226_avg_tab));\n\n\treturn INA226_SHIFT_AVG(avg_bits);\n}\n\n \nstatic int ina2xx_calibrate(struct ina2xx_data *data)\n{\n\treturn regmap_write(data->regmap, INA2XX_CALIBRATION,\n\t\t\t    data->config->calibration_value);\n}\n\n \nstatic int ina2xx_init(struct ina2xx_data *data)\n{\n\tint ret = regmap_write(data->regmap, INA2XX_CONFIG,\n\t\t\t       data->config->config_default);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ina2xx_calibrate(data);\n}\n\nstatic int ina2xx_read_reg(struct device *dev, int reg, unsigned int *regval)\n{\n\tstruct ina2xx_data *data = dev_get_drvdata(dev);\n\tint ret, retry;\n\n\tdev_dbg(dev, \"Starting register %d read\\n\", reg);\n\n\tfor (retry = 5; retry; retry--) {\n\n\t\tret = regmap_read(data->regmap, reg, regval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdev_dbg(dev, \"read %d, val = 0x%04x\\n\", reg, *regval);\n\n\t\t \n\t\tif (*regval == 0) {\n\t\t\tunsigned int cal;\n\n\t\t\tret = regmap_read(data->regmap, INA2XX_CALIBRATION,\n\t\t\t\t\t  &cal);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (cal == 0) {\n\t\t\t\tdev_warn(dev, \"chip not calibrated, reinitializing\\n\");\n\n\t\t\t\tret = ina2xx_init(data);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\t \n\t\t\t\tmsleep(INA2XX_MAX_DELAY);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tdev_err(dev, \"unable to reinitialize the chip\\n\");\n\treturn -ENODEV;\n}\n\nstatic int ina2xx_get_value(struct ina2xx_data *data, u8 reg,\n\t\t\t    unsigned int regval)\n{\n\tint val;\n\n\tswitch (reg) {\n\tcase INA2XX_SHUNT_VOLTAGE:\n\t\t \n\t\tval = DIV_ROUND_CLOSEST((s16)regval, data->config->shunt_div);\n\t\tbreak;\n\tcase INA2XX_BUS_VOLTAGE:\n\t\tval = (regval >> data->config->bus_voltage_shift)\n\t\t  * data->config->bus_voltage_lsb;\n\t\tval = DIV_ROUND_CLOSEST(val, 1000);\n\t\tbreak;\n\tcase INA2XX_POWER:\n\t\tval = regval * data->power_lsb_uW;\n\t\tbreak;\n\tcase INA2XX_CURRENT:\n\t\t \n\t\tval = (s16)regval * data->current_lsb_uA;\n\t\tval = DIV_ROUND_CLOSEST(val, 1000);\n\t\tbreak;\n\tcase INA2XX_CALIBRATION:\n\t\tval = regval;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tval = 0;\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nstatic ssize_t ina2xx_value_show(struct device *dev,\n\t\t\t\t struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ina2xx_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\n\tint err = ina2xx_read_reg(dev, attr->index, &regval);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn sysfs_emit(buf, \"%d\\n\", ina2xx_get_value(data, attr->index, regval));\n}\n\nstatic int ina226_reg_to_alert(struct ina2xx_data *data, u8 bit, u16 regval)\n{\n\tint reg;\n\n\tswitch (bit) {\n\tcase INA226_SHUNT_OVER_VOLTAGE_BIT:\n\tcase INA226_SHUNT_UNDER_VOLTAGE_BIT:\n\t\treg = INA2XX_SHUNT_VOLTAGE;\n\t\tbreak;\n\tcase INA226_BUS_OVER_VOLTAGE_BIT:\n\tcase INA226_BUS_UNDER_VOLTAGE_BIT:\n\t\treg = INA2XX_BUS_VOLTAGE;\n\t\tbreak;\n\tcase INA226_POWER_OVER_LIMIT_BIT:\n\t\treg = INA2XX_POWER;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\treturn ina2xx_get_value(data, reg, regval);\n}\n\n \nstatic s16 ina226_alert_to_reg(struct ina2xx_data *data, u8 bit, int val)\n{\n\tswitch (bit) {\n\tcase INA226_SHUNT_OVER_VOLTAGE_BIT:\n\tcase INA226_SHUNT_UNDER_VOLTAGE_BIT:\n\t\tval *= data->config->shunt_div;\n\t\treturn clamp_val(val, SHRT_MIN, SHRT_MAX);\n\tcase INA226_BUS_OVER_VOLTAGE_BIT:\n\tcase INA226_BUS_UNDER_VOLTAGE_BIT:\n\t\tval = (val * 1000) << data->config->bus_voltage_shift;\n\t\tval = DIV_ROUND_CLOSEST(val, data->config->bus_voltage_lsb);\n\t\treturn clamp_val(val, 0, SHRT_MAX);\n\tcase INA226_POWER_OVER_LIMIT_BIT:\n\t\tval = DIV_ROUND_CLOSEST(val, data->power_lsb_uW);\n\t\treturn clamp_val(val, 0, USHRT_MAX);\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}\n\nstatic ssize_t ina226_alert_show(struct device *dev,\n\t\t\t\t struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ina2xx_data *data = dev_get_drvdata(dev);\n\tint regval;\n\tint val = 0;\n\tint ret;\n\n\tmutex_lock(&data->config_lock);\n\tret = regmap_read(data->regmap, INA226_MASK_ENABLE, &regval);\n\tif (ret)\n\t\tgoto abort;\n\n\tif (regval & BIT(attr->index)) {\n\t\tret = regmap_read(data->regmap, INA226_ALERT_LIMIT, &regval);\n\t\tif (ret)\n\t\t\tgoto abort;\n\t\tval = ina226_reg_to_alert(data, attr->index, regval);\n\t}\n\n\tret = sysfs_emit(buf, \"%d\\n\", val);\nabort:\n\tmutex_unlock(&data->config_lock);\n\treturn ret;\n}\n\nstatic ssize_t ina226_alert_store(struct device *dev,\n\t\t\t\t  struct device_attribute *da,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ina2xx_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmutex_lock(&data->config_lock);\n\tret = regmap_update_bits(data->regmap, INA226_MASK_ENABLE,\n\t\t\t\t INA226_ALERT_CONFIG_MASK, 0);\n\tif (ret < 0)\n\t\tgoto abort;\n\n\tret = regmap_write(data->regmap, INA226_ALERT_LIMIT,\n\t\t\t   ina226_alert_to_reg(data, attr->index, val));\n\tif (ret < 0)\n\t\tgoto abort;\n\n\tif (val != 0) {\n\t\tret = regmap_update_bits(data->regmap, INA226_MASK_ENABLE,\n\t\t\t\t\t INA226_ALERT_CONFIG_MASK,\n\t\t\t\t\t BIT(attr->index));\n\t\tif (ret < 0)\n\t\t\tgoto abort;\n\t}\n\n\tret = count;\nabort:\n\tmutex_unlock(&data->config_lock);\n\treturn ret;\n}\n\nstatic ssize_t ina226_alarm_show(struct device *dev,\n\t\t\t\t struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ina2xx_data *data = dev_get_drvdata(dev);\n\tint regval;\n\tint alarm = 0;\n\tint ret;\n\n\tret = regmap_read(data->regmap, INA226_MASK_ENABLE, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\talarm = (regval & BIT(attr->index)) &&\n\t\t(regval & INA226_ALERT_FUNCTION_FLAG);\n\treturn sysfs_emit(buf, \"%d\\n\", alarm);\n}\n\n \nstatic int ina2xx_set_shunt(struct ina2xx_data *data, long val)\n{\n\tunsigned int dividend = DIV_ROUND_CLOSEST(1000000000,\n\t\t\t\t\t\t  data->config->shunt_div);\n\tif (val <= 0 || val > dividend)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->config_lock);\n\tdata->rshunt = val;\n\tdata->current_lsb_uA = DIV_ROUND_CLOSEST(dividend, val);\n\tdata->power_lsb_uW = data->config->power_lsb_factor *\n\t\t\t     data->current_lsb_uA;\n\tmutex_unlock(&data->config_lock);\n\n\treturn 0;\n}\n\nstatic ssize_t ina2xx_shunt_show(struct device *dev,\n\t\t\t\t struct device_attribute *da, char *buf)\n{\n\tstruct ina2xx_data *data = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%li\\n\", data->rshunt);\n}\n\nstatic ssize_t ina2xx_shunt_store(struct device *dev,\n\t\t\t\t  struct device_attribute *da,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned long val;\n\tint status;\n\tstruct ina2xx_data *data = dev_get_drvdata(dev);\n\n\tstatus = kstrtoul(buf, 10, &val);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = ina2xx_set_shunt(data, val);\n\tif (status < 0)\n\t\treturn status;\n\treturn count;\n}\n\nstatic ssize_t ina226_interval_store(struct device *dev,\n\t\t\t\t     struct device_attribute *da,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ina2xx_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint status;\n\n\tstatus = kstrtoul(buf, 10, &val);\n\tif (status < 0)\n\t\treturn status;\n\n\tif (val > INT_MAX || val == 0)\n\t\treturn -EINVAL;\n\n\tstatus = regmap_update_bits(data->regmap, INA2XX_CONFIG,\n\t\t\t\t    INA226_AVG_RD_MASK,\n\t\t\t\t    ina226_interval_to_reg(val));\n\tif (status < 0)\n\t\treturn status;\n\n\treturn count;\n}\n\nstatic ssize_t ina226_interval_show(struct device *dev,\n\t\t\t\t    struct device_attribute *da, char *buf)\n{\n\tstruct ina2xx_data *data = dev_get_drvdata(dev);\n\tint status;\n\tunsigned int regval;\n\n\tstatus = regmap_read(data->regmap, INA2XX_CONFIG, &regval);\n\tif (status)\n\t\treturn status;\n\n\treturn sysfs_emit(buf, \"%d\\n\", ina226_reg_to_interval(regval));\n}\n\n \nstatic SENSOR_DEVICE_ATTR_RO(in0_input, ina2xx_value, INA2XX_SHUNT_VOLTAGE);\n \nstatic SENSOR_DEVICE_ATTR_RW(in0_crit, ina226_alert,\n\t\t\t     INA226_SHUNT_OVER_VOLTAGE_BIT);\nstatic SENSOR_DEVICE_ATTR_RW(in0_lcrit, ina226_alert,\n\t\t\t     INA226_SHUNT_UNDER_VOLTAGE_BIT);\nstatic SENSOR_DEVICE_ATTR_RO(in0_crit_alarm, ina226_alarm,\n\t\t\t     INA226_SHUNT_OVER_VOLTAGE_BIT);\nstatic SENSOR_DEVICE_ATTR_RO(in0_lcrit_alarm, ina226_alarm,\n\t\t\t     INA226_SHUNT_UNDER_VOLTAGE_BIT);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(in1_input, ina2xx_value, INA2XX_BUS_VOLTAGE);\n \nstatic SENSOR_DEVICE_ATTR_RW(in1_crit, ina226_alert,\n\t\t\t     INA226_BUS_OVER_VOLTAGE_BIT);\nstatic SENSOR_DEVICE_ATTR_RW(in1_lcrit, ina226_alert,\n\t\t\t     INA226_BUS_UNDER_VOLTAGE_BIT);\nstatic SENSOR_DEVICE_ATTR_RO(in1_crit_alarm, ina226_alarm,\n\t\t\t     INA226_BUS_OVER_VOLTAGE_BIT);\nstatic SENSOR_DEVICE_ATTR_RO(in1_lcrit_alarm, ina226_alarm,\n\t\t\t     INA226_BUS_UNDER_VOLTAGE_BIT);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(curr1_input, ina2xx_value, INA2XX_CURRENT);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(power1_input, ina2xx_value, INA2XX_POWER);\n \nstatic SENSOR_DEVICE_ATTR_RW(power1_crit, ina226_alert,\n\t\t\t     INA226_POWER_OVER_LIMIT_BIT);\nstatic SENSOR_DEVICE_ATTR_RO(power1_crit_alarm, ina226_alarm,\n\t\t\t     INA226_POWER_OVER_LIMIT_BIT);\n\n \nstatic SENSOR_DEVICE_ATTR_RW(shunt_resistor, ina2xx_shunt, INA2XX_CALIBRATION);\n\n \nstatic SENSOR_DEVICE_ATTR_RW(update_interval, ina226_interval, 0);\n\n \nstatic struct attribute *ina2xx_attrs[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_curr1_input.dev_attr.attr,\n\t&sensor_dev_attr_power1_input.dev_attr.attr,\n\t&sensor_dev_attr_shunt_resistor.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ina2xx_group = {\n\t.attrs = ina2xx_attrs,\n};\n\nstatic struct attribute *ina226_attrs[] = {\n\t&sensor_dev_attr_in0_crit.dev_attr.attr,\n\t&sensor_dev_attr_in0_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in0_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in0_lcrit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_crit.dev_attr.attr,\n\t&sensor_dev_attr_in1_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in1_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_lcrit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_power1_crit.dev_attr.attr,\n\t&sensor_dev_attr_power1_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_update_interval.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ina226_group = {\n\t.attrs = ina226_attrs,\n};\n\nstatic const struct i2c_device_id ina2xx_id[];\n\nstatic int ina2xx_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ina2xx_data *data;\n\tstruct device *hwmon_dev;\n\tu32 val;\n\tint ret, group = 0;\n\tenum ina2xx_ids chip;\n\n\tif (client->dev.of_node)\n\t\tchip = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\tchip = i2c_match_id(ina2xx_id, client)->driver_data;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tdata->config = &ina2xx_config[chip];\n\tmutex_init(&data->config_lock);\n\n\tif (of_property_read_u32(dev->of_node, \"shunt-resistor\", &val) < 0) {\n\t\tstruct ina2xx_platform_data *pdata = dev_get_platdata(dev);\n\n\t\tif (pdata)\n\t\t\tval = pdata->shunt_uohms;\n\t\telse\n\t\t\tval = INA2XX_RSHUNT_DEFAULT;\n\t}\n\n\tina2xx_set_shunt(data, val);\n\n\tina2xx_regmap_config.max_register = data->config->registers;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &ina2xx_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\tret = devm_regulator_get_enable(dev, \"vs\");\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to enable vs regulator\\n\");\n\n\tret = ina2xx_init(data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error configuring the device: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\tdata->groups[group++] = &ina2xx_group;\n\tif (chip == ina226)\n\t\tdata->groups[group++] = &ina226_group;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, data->groups);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdev_info(dev, \"power monitor %s (Rshunt = %li uOhm)\\n\",\n\t\t client->name, data->rshunt);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id ina2xx_id[] = {\n\t{ \"ina219\", ina219 },\n\t{ \"ina220\", ina219 },\n\t{ \"ina226\", ina226 },\n\t{ \"ina230\", ina226 },\n\t{ \"ina231\", ina226 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ina2xx_id);\n\nstatic const struct of_device_id __maybe_unused ina2xx_of_match[] = {\n\t{\n\t\t.compatible = \"ti,ina219\",\n\t\t.data = (void *)ina219\n\t},\n\t{\n\t\t.compatible = \"ti,ina220\",\n\t\t.data = (void *)ina219\n\t},\n\t{\n\t\t.compatible = \"ti,ina226\",\n\t\t.data = (void *)ina226\n\t},\n\t{\n\t\t.compatible = \"ti,ina230\",\n\t\t.data = (void *)ina226\n\t},\n\t{\n\t\t.compatible = \"ti,ina231\",\n\t\t.data = (void *)ina226\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ina2xx_of_match);\n\nstatic struct i2c_driver ina2xx_driver = {\n\t.driver = {\n\t\t.name\t= \"ina2xx\",\n\t\t.of_match_table = of_match_ptr(ina2xx_of_match),\n\t},\n\t.probe\t\t= ina2xx_probe,\n\t.id_table\t= ina2xx_id,\n};\n\nmodule_i2c_driver(ina2xx_driver);\n\nMODULE_AUTHOR(\"Lothar Felten <l-felten@ti.com>\");\nMODULE_DESCRIPTION(\"ina2xx driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}