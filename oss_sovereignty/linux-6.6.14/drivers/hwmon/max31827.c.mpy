{
  "module_name": "max31827.c",
  "hash_id": "cb312232160286aaf6a95b3620a377b41e3cdb0acd7de0224a7c1720c776086c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max31827.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n\n#define MAX31827_T_REG\t\t\t0x0\n#define MAX31827_CONFIGURATION_REG\t0x2\n#define MAX31827_TH_REG\t\t\t0x4\n#define MAX31827_TL_REG\t\t\t0x6\n#define MAX31827_TH_HYST_REG\t\t0x8\n#define MAX31827_TL_HYST_REG\t\t0xA\n\n#define MAX31827_CONFIGURATION_1SHOT_MASK\tBIT(0)\n#define MAX31827_CONFIGURATION_CNV_RATE_MASK\tGENMASK(3, 1)\n#define MAX31827_CONFIGURATION_U_TEMP_STAT_MASK\tBIT(14)\n#define MAX31827_CONFIGURATION_O_TEMP_STAT_MASK\tBIT(15)\n\n#define MAX31827_12_BIT_CNV_TIME\t141\n\n#define MAX31827_CNV_1_DIV_64_HZ\t0x1\n#define MAX31827_CNV_1_DIV_32_HZ\t0x2\n#define MAX31827_CNV_1_DIV_16_HZ\t0x3\n#define MAX31827_CNV_1_DIV_4_HZ\t\t0x4\n#define MAX31827_CNV_1_HZ\t\t0x5\n#define MAX31827_CNV_4_HZ\t\t0x6\n#define MAX31827_CNV_8_HZ\t\t0x7\n\n#define MAX31827_16_BIT_TO_M_DGR(x)\t(sign_extend32(x, 15) * 1000 / 16)\n#define MAX31827_M_DGR_TO_16_BIT(x)\t(((x) << 4) / 1000)\n#define MAX31827_DEVICE_ENABLE(x)\t((x) ? 0xA : 0x0)\n\nstruct max31827_state {\n\t \n\tstruct mutex lock;\n\tstruct regmap *regmap;\n\tbool enable;\n};\n\nstatic const struct regmap_config max31827_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = 0xA,\n};\n\nstatic int write_alarm_val(struct max31827_state *st, unsigned int reg,\n\t\t\t   long val)\n{\n\tunsigned int cfg;\n\tunsigned int tmp;\n\tint ret;\n\n\tval = MAX31827_M_DGR_TO_16_BIT(val);\n\n\t \n\tmutex_lock(&st->lock);\n\n\tif (!st->enable) {\n\t\tret = regmap_write(st->regmap, reg, val);\n\t\tgoto unlock;\n\t}\n\n\tret = regmap_read(st->regmap, MAX31827_CONFIGURATION_REG, &cfg);\n\tif (ret)\n\t\tgoto unlock;\n\n\ttmp = cfg & ~(MAX31827_CONFIGURATION_1SHOT_MASK |\n\t\t      MAX31827_CONFIGURATION_CNV_RATE_MASK);\n\tret = regmap_write(st->regmap, MAX31827_CONFIGURATION_REG, tmp);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = regmap_write(st->regmap, reg, val);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = regmap_write(st->regmap, MAX31827_CONFIGURATION_REG, cfg);\n\nunlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic umode_t max31827_is_visible(const void *state,\n\t\t\t\t   enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t   int channel)\n{\n\tif (type == hwmon_temp) {\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_enable:\n\t\tcase hwmon_temp_max:\n\t\tcase hwmon_temp_min:\n\t\tcase hwmon_temp_max_hyst:\n\t\tcase hwmon_temp_min_hyst:\n\t\t\treturn 0644;\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_min_alarm:\n\t\tcase hwmon_temp_max_alarm:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t} else if (type == hwmon_chip) {\n\t\tif (attr == hwmon_chip_update_interval)\n\t\t\treturn 0644;\n\t}\n\n\treturn 0;\n}\n\nstatic int max31827_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long *val)\n{\n\tstruct max31827_state *st = dev_get_drvdata(dev);\n\tunsigned int uval;\n\tint ret = 0;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_enable:\n\t\t\tret = regmap_read(st->regmap,\n\t\t\t\t\t  MAX31827_CONFIGURATION_REG, &uval);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tuval = FIELD_GET(MAX31827_CONFIGURATION_1SHOT_MASK |\n\t\t\t\t\t MAX31827_CONFIGURATION_CNV_RATE_MASK,\n\t\t\t\t\t uval);\n\t\t\t*val = !!uval;\n\n\t\t\tbreak;\n\t\tcase hwmon_temp_input:\n\t\t\tmutex_lock(&st->lock);\n\n\t\t\tif (!st->enable) {\n\t\t\t\t \n\n\t\t\t\tret = regmap_update_bits(st->regmap,\n\t\t\t\t\t\t\t MAX31827_CONFIGURATION_REG,\n\t\t\t\t\t\t\t MAX31827_CONFIGURATION_1SHOT_MASK,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmutex_unlock(&st->lock);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tmsleep(MAX31827_12_BIT_CNV_TIME);\n\t\t\t}\n\t\t\tret = regmap_read(st->regmap, MAX31827_T_REG, &uval);\n\n\t\t\tmutex_unlock(&st->lock);\n\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t*val = MAX31827_16_BIT_TO_M_DGR(uval);\n\n\t\t\tbreak;\n\t\tcase hwmon_temp_max:\n\t\t\tret = regmap_read(st->regmap, MAX31827_TH_REG, &uval);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t*val = MAX31827_16_BIT_TO_M_DGR(uval);\n\t\t\tbreak;\n\t\tcase hwmon_temp_max_hyst:\n\t\t\tret = regmap_read(st->regmap, MAX31827_TH_HYST_REG,\n\t\t\t\t\t  &uval);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t*val = MAX31827_16_BIT_TO_M_DGR(uval);\n\t\t\tbreak;\n\t\tcase hwmon_temp_max_alarm:\n\t\t\tret = regmap_read(st->regmap,\n\t\t\t\t\t  MAX31827_CONFIGURATION_REG, &uval);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t*val = FIELD_GET(MAX31827_CONFIGURATION_O_TEMP_STAT_MASK,\n\t\t\t\t\t uval);\n\t\t\tbreak;\n\t\tcase hwmon_temp_min:\n\t\t\tret = regmap_read(st->regmap, MAX31827_TL_REG, &uval);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t*val = MAX31827_16_BIT_TO_M_DGR(uval);\n\t\t\tbreak;\n\t\tcase hwmon_temp_min_hyst:\n\t\t\tret = regmap_read(st->regmap, MAX31827_TL_HYST_REG,\n\t\t\t\t\t  &uval);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t*val = MAX31827_16_BIT_TO_M_DGR(uval);\n\t\t\tbreak;\n\t\tcase hwmon_temp_min_alarm:\n\t\t\tret = regmap_read(st->regmap,\n\t\t\t\t\t  MAX31827_CONFIGURATION_REG, &uval);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t*val = FIELD_GET(MAX31827_CONFIGURATION_U_TEMP_STAT_MASK,\n\t\t\t\t\t uval);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase hwmon_chip:\n\t\tif (attr == hwmon_chip_update_interval) {\n\t\t\tret = regmap_read(st->regmap,\n\t\t\t\t\t  MAX31827_CONFIGURATION_REG, &uval);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tuval = FIELD_GET(MAX31827_CONFIGURATION_CNV_RATE_MASK,\n\t\t\t\t\t uval);\n\t\t\tswitch (uval) {\n\t\t\tcase MAX31827_CNV_1_DIV_64_HZ:\n\t\t\t\t*val = 64000;\n\t\t\t\tbreak;\n\t\t\tcase MAX31827_CNV_1_DIV_32_HZ:\n\t\t\t\t*val = 32000;\n\t\t\t\tbreak;\n\t\t\tcase MAX31827_CNV_1_DIV_16_HZ:\n\t\t\t\t*val = 16000;\n\t\t\t\tbreak;\n\t\t\tcase MAX31827_CNV_1_DIV_4_HZ:\n\t\t\t\t*val = 4000;\n\t\t\t\tbreak;\n\t\t\tcase MAX31827_CNV_1_HZ:\n\t\t\t\t*val = 1000;\n\t\t\t\tbreak;\n\t\t\tcase MAX31827_CNV_4_HZ:\n\t\t\t\t*val = 250;\n\t\t\t\tbreak;\n\t\t\tcase MAX31827_CNV_8_HZ:\n\t\t\t\t*val = 125;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*val = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int max31827_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t  u32 attr, int channel, long val)\n{\n\tstruct max31827_state *st = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_enable:\n\t\t\tif (val >> 1)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmutex_lock(&st->lock);\n\t\t\t \n\n\t\t\tst->enable = val;\n\n\t\t\tret = regmap_update_bits(st->regmap,\n\t\t\t\t\t\t MAX31827_CONFIGURATION_REG,\n\t\t\t\t\t\t MAX31827_CONFIGURATION_1SHOT_MASK |\n\t\t\t\t\t\t MAX31827_CONFIGURATION_CNV_RATE_MASK,\n\t\t\t\t\t\t MAX31827_DEVICE_ENABLE(val));\n\n\t\t\tmutex_unlock(&st->lock);\n\n\t\t\treturn ret;\n\n\t\tcase hwmon_temp_max:\n\t\t\treturn write_alarm_val(st, MAX31827_TH_REG, val);\n\n\t\tcase hwmon_temp_max_hyst:\n\t\t\treturn write_alarm_val(st, MAX31827_TH_HYST_REG, val);\n\n\t\tcase hwmon_temp_min:\n\t\t\treturn write_alarm_val(st, MAX31827_TL_REG, val);\n\n\t\tcase hwmon_temp_min_hyst:\n\t\t\treturn write_alarm_val(st, MAX31827_TL_HYST_REG, val);\n\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\tcase hwmon_chip:\n\t\tif (attr == hwmon_chip_update_interval) {\n\t\t\tif (!st->enable)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tswitch (val) {\n\t\t\tcase 125:\n\t\t\t\tval = MAX31827_CNV_8_HZ;\n\t\t\t\tbreak;\n\t\t\tcase 250:\n\t\t\t\tval = MAX31827_CNV_4_HZ;\n\t\t\t\tbreak;\n\t\t\tcase 1000:\n\t\t\t\tval = MAX31827_CNV_1_HZ;\n\t\t\t\tbreak;\n\t\t\tcase 4000:\n\t\t\t\tval = MAX31827_CNV_1_DIV_4_HZ;\n\t\t\t\tbreak;\n\t\t\tcase 16000:\n\t\t\t\tval = MAX31827_CNV_1_DIV_16_HZ;\n\t\t\t\tbreak;\n\t\t\tcase 32000:\n\t\t\t\tval = MAX31827_CNV_1_DIV_32_HZ;\n\t\t\t\tbreak;\n\t\t\tcase 64000:\n\t\t\t\tval = MAX31827_CNV_1_DIV_64_HZ;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tval = FIELD_PREP(MAX31827_CONFIGURATION_CNV_RATE_MASK,\n\t\t\t\t\t val);\n\n\t\t\treturn regmap_update_bits(st->regmap,\n\t\t\t\t\t\t  MAX31827_CONFIGURATION_REG,\n\t\t\t\t\t\t  MAX31827_CONFIGURATION_CNV_RATE_MASK,\n\t\t\t\t\t\t  val);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int max31827_init_client(struct max31827_state *st)\n{\n\tst->enable = true;\n\n\treturn regmap_update_bits(st->regmap, MAX31827_CONFIGURATION_REG,\n\t\t\t\t  MAX31827_CONFIGURATION_1SHOT_MASK |\n\t\t\t\t\t  MAX31827_CONFIGURATION_CNV_RATE_MASK,\n\t\t\t\t  MAX31827_DEVICE_ENABLE(1));\n}\n\nstatic const struct hwmon_channel_info *max31827_info[] = {\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_ENABLE | HWMON_T_INPUT | HWMON_T_MIN |\n\t\t\t\t\t HWMON_T_MIN_HYST | HWMON_T_MIN_ALARM |\n\t\t\t\t\t HWMON_T_MAX | HWMON_T_MAX_HYST |\n\t\t\t\t\t HWMON_T_MAX_ALARM),\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_UPDATE_INTERVAL),\n\tNULL,\n};\n\nstatic const struct hwmon_ops max31827_hwmon_ops = {\n\t.is_visible = max31827_is_visible,\n\t.read = max31827_read,\n\t.write = max31827_write,\n};\n\nstatic const struct hwmon_chip_info max31827_chip_info = {\n\t.ops = &max31827_hwmon_ops,\n\t.info = max31827_info,\n};\n\nstatic int max31827_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct max31827_state *st;\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tst = devm_kzalloc(dev, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&st->lock);\n\n\tst->regmap = devm_regmap_init_i2c(client, &max31827_regmap);\n\tif (IS_ERR(st->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(st->regmap),\n\t\t\t\t     \"Failed to allocate regmap.\\n\");\n\n\terr = max31827_init_client(st);\n\tif (err)\n\t\treturn err;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name, st,\n\t\t\t\t\t\t\t &max31827_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id max31827_i2c_ids[] = {\n\t{ \"max31827\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max31827_i2c_ids);\n\nstatic const struct of_device_id max31827_of_match[] = {\n\t{ .compatible = \"adi,max31827\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max31827_of_match);\n\nstatic struct i2c_driver max31827_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"max31827\",\n\t\t.of_match_table = max31827_of_match,\n\t},\n\t.probe = max31827_probe,\n\t.id_table = max31827_i2c_ids,\n};\nmodule_i2c_driver(max31827_driver);\n\nMODULE_AUTHOR(\"Daniel Matyas <daniel.matyas@analog.com>\");\nMODULE_DESCRIPTION(\"Maxim MAX31827 low-power temperature switch driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}