{
  "module_name": "ibmpowernv.c",
  "hash_id": "19cf6c2871456883efa8441e316e8911728bd4355738c10903e03a0af08b2ab0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ibmpowernv.c",
  "human_readable_source": "\n \n\n#define DRVNAME\t\t\"ibmpowernv\"\n#define pr_fmt(fmt)\tDRVNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n#include <linux/platform_device.h>\n#include <asm/opal.h>\n#include <linux/err.h>\n#include <asm/cputhreads.h>\n#include <asm/smp.h>\n\n#define MAX_ATTR_LEN\t32\n#define MAX_LABEL_LEN\t64\n\n \n#define DT_FAULT_ATTR_SUFFIX\t\t\"faulted\"\n#define DT_DATA_ATTR_SUFFIX\t\t\"data\"\n#define DT_THRESHOLD_ATTR_SUFFIX\t\"thrs\"\n\n \nenum sensors {\n\tFAN,\n\tTEMP,\n\tPOWER_SUPPLY,\n\tPOWER_INPUT,\n\tCURRENT,\n\tENERGY,\n\tMAX_SENSOR_TYPE,\n};\n\n#define INVALID_INDEX (-1U)\n\n \nstatic const char * const legacy_compatibles[] = {\n\t\"ibm,opal-sensor-cooling-fan\",\n\t\"ibm,opal-sensor-amb-temp\",\n\t\"ibm,opal-sensor-power-supply\",\n\t\"ibm,opal-sensor-power\"\n};\n\nstatic struct sensor_group {\n\tconst char *name;  \n\tstruct attribute_group group;\n\tu32 attr_count;\n\tu32 hwmon_index;\n} sensor_groups[] = {\n\t{ \"fan\"   },\n\t{ \"temp\"  },\n\t{ \"in\"    },\n\t{ \"power\" },\n\t{ \"curr\"  },\n\t{ \"energy\" },\n};\n\nstruct sensor_data {\n\tu32 id;  \n\tu32 hwmon_index;\n\tu32 opal_index;\n\tenum sensors type;\n\tchar label[MAX_LABEL_LEN];\n\tchar name[MAX_ATTR_LEN];\n\tstruct device_attribute dev_attr;\n\tstruct sensor_group_data *sgrp_data;\n};\n\nstruct sensor_group_data {\n\tstruct mutex mutex;\n\tu32 gid;\n\tbool enable;\n};\n\nstruct platform_data {\n\tconst struct attribute_group *attr_groups[MAX_SENSOR_TYPE + 1];\n\tstruct sensor_group_data *sgrp_data;\n\tu32 sensors_count;  \n\tu32 nr_sensor_groups;  \n};\n\nstatic ssize_t show_sensor(struct device *dev, struct device_attribute *devattr,\n\t\t\t   char *buf)\n{\n\tstruct sensor_data *sdata = container_of(devattr, struct sensor_data,\n\t\t\t\t\t\t dev_attr);\n\tssize_t ret;\n\tu64 x;\n\n\tif (sdata->sgrp_data && !sdata->sgrp_data->enable)\n\t\treturn -ENODATA;\n\n\tret =  opal_get_sensor_data_u64(sdata->id, &x);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (sdata->type == TEMP)\n\t\tx *= 1000;\n\t \n\telse if (sdata->type == POWER_INPUT)\n\t\tx *= 1000000;\n\n\treturn sprintf(buf, \"%llu\\n\", x);\n}\n\nstatic ssize_t show_enable(struct device *dev,\n\t\t\t   struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_data *sdata = container_of(devattr, struct sensor_data,\n\t\t\t\t\t\t dev_attr);\n\n\treturn sprintf(buf, \"%u\\n\", sdata->sgrp_data->enable);\n}\n\nstatic ssize_t store_enable(struct device *dev,\n\t\t\t    struct device_attribute *devattr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct sensor_data *sdata = container_of(devattr, struct sensor_data,\n\t\t\t\t\t\t dev_attr);\n\tstruct sensor_group_data *sgrp_data = sdata->sgrp_data;\n\tint ret;\n\tbool data;\n\n\tret = kstrtobool(buf, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mutex_lock_interruptible(&sgrp_data->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data != sgrp_data->enable) {\n\t\tret =  sensor_group_enable(sgrp_data->gid, data);\n\t\tif (!ret)\n\t\t\tsgrp_data->enable = data;\n\t}\n\n\tif (!ret)\n\t\tret = count;\n\n\tmutex_unlock(&sgrp_data->mutex);\n\treturn ret;\n}\n\nstatic ssize_t show_label(struct device *dev, struct device_attribute *devattr,\n\t\t\t  char *buf)\n{\n\tstruct sensor_data *sdata = container_of(devattr, struct sensor_data,\n\t\t\t\t\t\t dev_attr);\n\n\treturn sprintf(buf, \"%s\\n\", sdata->label);\n}\n\nstatic int get_logical_cpu(int hwcpu)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tif (get_hard_smp_processor_id(cpu) == hwcpu)\n\t\t\treturn cpu;\n\n\treturn -ENOENT;\n}\n\nstatic void make_sensor_label(struct device_node *np,\n\t\t\t      struct sensor_data *sdata, const char *label)\n{\n\tu32 id;\n\tsize_t n;\n\n\tn = scnprintf(sdata->label, sizeof(sdata->label), \"%s\", label);\n\n\t \n\tif (!of_property_read_u32(np, \"ibm,pir\", &id)) {\n\t\tint cpuid = get_logical_cpu(id);\n\n\t\tif (cpuid >= 0)\n\t\t\t \n\t\t\tn += scnprintf(sdata->label + n,\n\t\t\t\t      sizeof(sdata->label) - n, \" %d\",\n\t\t\t\t      cpuid);\n\t\telse\n\t\t\tn += scnprintf(sdata->label + n,\n\t\t\t\t      sizeof(sdata->label) - n, \" phy%d\", id);\n\t}\n\n\t \n\tif (!of_property_read_u32(np, \"ibm,chip-id\", &id))\n\t\tn += scnprintf(sdata->label + n, sizeof(sdata->label) - n,\n\t\t\t      \" %d\", id & 0xffff);\n}\n\nstatic int get_sensor_index_attr(const char *name, u32 *index, char *attr)\n{\n\tchar *hash_pos = strchr(name, '#');\n\tchar buf[8] = { 0 };\n\tchar *dash_pos;\n\tu32 copy_len;\n\tint err;\n\n\tif (!hash_pos)\n\t\treturn -EINVAL;\n\n\tdash_pos = strchr(hash_pos, '-');\n\tif (!dash_pos)\n\t\treturn -EINVAL;\n\n\tcopy_len = dash_pos - hash_pos - 1;\n\tif (copy_len >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tstrncpy(buf, hash_pos + 1, copy_len);\n\n\terr = kstrtou32(buf, 10, index);\n\tif (err)\n\t\treturn err;\n\n\tstrscpy(attr, dash_pos + 1, MAX_ATTR_LEN);\n\n\treturn 0;\n}\n\nstatic const char *convert_opal_attr_name(enum sensors type,\n\t\t\t\t\t  const char *opal_attr)\n{\n\tconst char *attr_name = NULL;\n\n\tif (!strcmp(opal_attr, DT_FAULT_ATTR_SUFFIX)) {\n\t\tattr_name = \"fault\";\n\t} else if (!strcmp(opal_attr, DT_DATA_ATTR_SUFFIX)) {\n\t\tattr_name = \"input\";\n\t} else if (!strcmp(opal_attr, DT_THRESHOLD_ATTR_SUFFIX)) {\n\t\tif (type == TEMP)\n\t\t\tattr_name = \"max\";\n\t\telse if (type == FAN)\n\t\t\tattr_name = \"min\";\n\t}\n\n\treturn attr_name;\n}\n\n \nstatic const char *parse_opal_node_name(const char *node_name,\n\t\t\t\t\tenum sensors type, u32 *index)\n{\n\tchar attr_suffix[MAX_ATTR_LEN];\n\tconst char *attr_name;\n\tint err;\n\n\terr = get_sensor_index_attr(node_name, index, attr_suffix);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tattr_name = convert_opal_attr_name(type, attr_suffix);\n\tif (!attr_name)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn attr_name;\n}\n\nstatic int get_sensor_type(struct device_node *np)\n{\n\tenum sensors type;\n\tconst char *str;\n\n\tfor (type = 0; type < ARRAY_SIZE(legacy_compatibles); type++) {\n\t\tif (of_device_is_compatible(np, legacy_compatibles[type]))\n\t\t\treturn type;\n\t}\n\n\t \n\tif (!of_device_is_compatible(np, \"ibm,opal-sensor\"))\n\t\treturn MAX_SENSOR_TYPE;\n\n\tif (of_property_read_string(np, \"sensor-type\", &str))\n\t\treturn MAX_SENSOR_TYPE;\n\n\tfor (type = 0; type < MAX_SENSOR_TYPE; type++)\n\t\tif (!strcmp(str, sensor_groups[type].name))\n\t\t\treturn type;\n\n\treturn MAX_SENSOR_TYPE;\n}\n\nstatic u32 get_sensor_hwmon_index(struct sensor_data *sdata,\n\t\t\t\t  struct sensor_data *sdata_table, int count)\n{\n\tint i;\n\n\t \n\tif (sdata->opal_index != INVALID_INDEX) {\n\t\tfor (i = 0; i < count; i++)\n\t\t\tif (sdata_table[i].opal_index == sdata->opal_index &&\n\t\t\t    sdata_table[i].type == sdata->type)\n\t\t\t\treturn sdata_table[i].hwmon_index;\n\t}\n\treturn ++sensor_groups[sdata->type].hwmon_index;\n}\n\nstatic int init_sensor_group_data(struct platform_device *pdev,\n\t\t\t\t  struct platform_data *pdata)\n{\n\tstruct sensor_group_data *sgrp_data;\n\tstruct device_node *groups, *sgrp;\n\tint count = 0, ret = 0;\n\tenum sensors type;\n\n\tgroups = of_find_compatible_node(NULL, NULL, \"ibm,opal-sensor-group\");\n\tif (!groups)\n\t\treturn ret;\n\n\tfor_each_child_of_node(groups, sgrp) {\n\t\ttype = get_sensor_type(sgrp);\n\t\tif (type != MAX_SENSOR_TYPE)\n\t\t\tpdata->nr_sensor_groups++;\n\t}\n\n\tif (!pdata->nr_sensor_groups)\n\t\tgoto out;\n\n\tsgrp_data = devm_kcalloc(&pdev->dev, pdata->nr_sensor_groups,\n\t\t\t\t sizeof(*sgrp_data), GFP_KERNEL);\n\tif (!sgrp_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor_each_child_of_node(groups, sgrp) {\n\t\tu32 gid;\n\n\t\ttype = get_sensor_type(sgrp);\n\t\tif (type == MAX_SENSOR_TYPE)\n\t\t\tcontinue;\n\n\t\tif (of_property_read_u32(sgrp, \"sensor-group-id\", &gid))\n\t\t\tcontinue;\n\n\t\tif (of_count_phandle_with_args(sgrp, \"sensors\", NULL) <= 0)\n\t\t\tcontinue;\n\n\t\tsensor_groups[type].attr_count++;\n\t\tsgrp_data[count].gid = gid;\n\t\tmutex_init(&sgrp_data[count].mutex);\n\t\tsgrp_data[count++].enable = false;\n\t}\n\n\tpdata->sgrp_data = sgrp_data;\nout:\n\tof_node_put(groups);\n\treturn ret;\n}\n\nstatic struct sensor_group_data *get_sensor_group(struct platform_data *pdata,\n\t\t\t\t\t\t  struct device_node *node,\n\t\t\t\t\t\t  enum sensors gtype)\n{\n\tstruct sensor_group_data *sgrp_data = pdata->sgrp_data;\n\tstruct device_node *groups, *sgrp;\n\n\tgroups = of_find_compatible_node(NULL, NULL, \"ibm,opal-sensor-group\");\n\tif (!groups)\n\t\treturn NULL;\n\n\tfor_each_child_of_node(groups, sgrp) {\n\t\tstruct of_phandle_iterator it;\n\t\tu32 gid;\n\t\tint rc, i;\n\t\tenum sensors type;\n\n\t\ttype = get_sensor_type(sgrp);\n\t\tif (type != gtype)\n\t\t\tcontinue;\n\n\t\tif (of_property_read_u32(sgrp, \"sensor-group-id\", &gid))\n\t\t\tcontinue;\n\n\t\tof_for_each_phandle(&it, rc, sgrp, \"sensors\", NULL, 0)\n\t\t\tif (it.phandle == node->phandle) {\n\t\t\t\tof_node_put(it.node);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (rc)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < pdata->nr_sensor_groups; i++)\n\t\t\tif (gid == sgrp_data[i].gid) {\n\t\t\t\tof_node_put(sgrp);\n\t\t\t\tof_node_put(groups);\n\t\t\t\treturn &sgrp_data[i];\n\t\t\t}\n\t}\n\n\tof_node_put(groups);\n\treturn NULL;\n}\n\nstatic int populate_attr_groups(struct platform_device *pdev)\n{\n\tstruct platform_data *pdata = platform_get_drvdata(pdev);\n\tconst struct attribute_group **pgroups = pdata->attr_groups;\n\tstruct device_node *opal, *np;\n\tenum sensors type;\n\tint ret;\n\n\tret = init_sensor_group_data(pdev, pdata);\n\tif (ret)\n\t\treturn ret;\n\n\topal = of_find_node_by_path(\"/ibm,opal/sensors\");\n\tfor_each_child_of_node(opal, np) {\n\t\tconst char *label;\n\n\t\ttype = get_sensor_type(np);\n\t\tif (type == MAX_SENSOR_TYPE)\n\t\t\tcontinue;\n\n\t\tsensor_groups[type].attr_count++;\n\n\t\t \n\t\tif (!of_property_read_string(np, \"label\", &label))\n\t\t\tsensor_groups[type].attr_count++;\n\t\tif (of_property_present(np, \"sensor-data-min\"))\n\t\t\tsensor_groups[type].attr_count++;\n\t\tif (of_property_present(np, \"sensor-data-max\"))\n\t\t\tsensor_groups[type].attr_count++;\n\t}\n\n\tof_node_put(opal);\n\n\tfor (type = 0; type < MAX_SENSOR_TYPE; type++) {\n\t\tsensor_groups[type].group.attrs = devm_kcalloc(&pdev->dev,\n\t\t\t\t\tsensor_groups[type].attr_count + 1,\n\t\t\t\t\tsizeof(struct attribute *),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!sensor_groups[type].group.attrs)\n\t\t\treturn -ENOMEM;\n\n\t\tpgroups[type] = &sensor_groups[type].group;\n\t\tpdata->sensors_count += sensor_groups[type].attr_count;\n\t\tsensor_groups[type].attr_count = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void create_hwmon_attr(struct sensor_data *sdata, const char *attr_name,\n\t\t\t      ssize_t (*show)(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf),\n\t\t\t    ssize_t (*store)(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count))\n{\n\tsnprintf(sdata->name, MAX_ATTR_LEN, \"%s%d_%s\",\n\t\t sensor_groups[sdata->type].name, sdata->hwmon_index,\n\t\t attr_name);\n\n\tsysfs_attr_init(&sdata->dev_attr.attr);\n\tsdata->dev_attr.attr.name = sdata->name;\n\tsdata->dev_attr.show = show;\n\tif (store) {\n\t\tsdata->dev_attr.store = store;\n\t\tsdata->dev_attr.attr.mode = 0664;\n\t} else {\n\t\tsdata->dev_attr.attr.mode = 0444;\n\t}\n}\n\nstatic void populate_sensor(struct sensor_data *sdata, int od, int hd, int sid,\n\t\t\t    const char *attr_name, enum sensors type,\n\t\t\t    const struct attribute_group *pgroup,\n\t\t\t    struct sensor_group_data *sgrp_data,\n\t\t\t    ssize_t (*show)(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf),\n\t\t\t    ssize_t (*store)(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count))\n{\n\tsdata->id = sid;\n\tsdata->type = type;\n\tsdata->opal_index = od;\n\tsdata->hwmon_index = hd;\n\tcreate_hwmon_attr(sdata, attr_name, show, store);\n\tpgroup->attrs[sensor_groups[type].attr_count++] = &sdata->dev_attr.attr;\n\tsdata->sgrp_data = sgrp_data;\n}\n\nstatic char *get_max_attr(enum sensors type)\n{\n\tswitch (type) {\n\tcase POWER_INPUT:\n\t\treturn \"input_highest\";\n\tdefault:\n\t\treturn \"highest\";\n\t}\n}\n\nstatic char *get_min_attr(enum sensors type)\n{\n\tswitch (type) {\n\tcase POWER_INPUT:\n\t\treturn \"input_lowest\";\n\tdefault:\n\t\treturn \"lowest\";\n\t}\n}\n\n \nstatic int create_device_attrs(struct platform_device *pdev)\n{\n\tstruct platform_data *pdata = platform_get_drvdata(pdev);\n\tconst struct attribute_group **pgroups = pdata->attr_groups;\n\tstruct device_node *opal, *np;\n\tstruct sensor_data *sdata;\n\tu32 count = 0;\n\tu32 group_attr_id[MAX_SENSOR_TYPE] = {0};\n\n\tsdata = devm_kcalloc(&pdev->dev,\n\t\t\t     pdata->sensors_count, sizeof(*sdata),\n\t\t\t     GFP_KERNEL);\n\tif (!sdata)\n\t\treturn -ENOMEM;\n\n\topal = of_find_node_by_path(\"/ibm,opal/sensors\");\n\tfor_each_child_of_node(opal, np) {\n\t\tstruct sensor_group_data *sgrp_data;\n\t\tconst char *attr_name;\n\t\tu32 opal_index, hw_id;\n\t\tu32 sensor_id;\n\t\tconst char *label;\n\t\tenum sensors type;\n\n\t\ttype = get_sensor_type(np);\n\t\tif (type == MAX_SENSOR_TYPE)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (of_property_read_u32(np, \"sensor-id\", &sensor_id) &&\n\t\t    of_property_read_u32(np, \"sensor-data\", &sensor_id)) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"'sensor-id' missing in the node '%pOFn'\\n\",\n\t\t\t\t np);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsdata[count].id = sensor_id;\n\t\tsdata[count].type = type;\n\n\t\t \n\t\tattr_name = parse_opal_node_name(np->name, type, &opal_index);\n\t\tif (IS_ERR(attr_name)) {\n\t\t\tattr_name = \"input\";\n\t\t\topal_index = INVALID_INDEX;\n\t\t}\n\n\t\thw_id = get_sensor_hwmon_index(&sdata[count], sdata, count);\n\t\tsgrp_data = get_sensor_group(pdata, np, type);\n\t\tpopulate_sensor(&sdata[count], opal_index, hw_id, sensor_id,\n\t\t\t\tattr_name, type, pgroups[type], sgrp_data,\n\t\t\t\tshow_sensor, NULL);\n\t\tcount++;\n\n\t\tif (!of_property_read_string(np, \"label\", &label)) {\n\t\t\t \n\n\t\t\tmake_sensor_label(np, &sdata[count], label);\n\t\t\tpopulate_sensor(&sdata[count], opal_index, hw_id,\n\t\t\t\t\tsensor_id, \"label\", type, pgroups[type],\n\t\t\t\t\tNULL, show_label, NULL);\n\t\t\tcount++;\n\t\t}\n\n\t\tif (!of_property_read_u32(np, \"sensor-data-max\", &sensor_id)) {\n\t\t\tattr_name = get_max_attr(type);\n\t\t\tpopulate_sensor(&sdata[count], opal_index, hw_id,\n\t\t\t\t\tsensor_id, attr_name, type,\n\t\t\t\t\tpgroups[type], sgrp_data, show_sensor,\n\t\t\t\t\tNULL);\n\t\t\tcount++;\n\t\t}\n\n\t\tif (!of_property_read_u32(np, \"sensor-data-min\", &sensor_id)) {\n\t\t\tattr_name = get_min_attr(type);\n\t\t\tpopulate_sensor(&sdata[count], opal_index, hw_id,\n\t\t\t\t\tsensor_id, attr_name, type,\n\t\t\t\t\tpgroups[type], sgrp_data, show_sensor,\n\t\t\t\t\tNULL);\n\t\t\tcount++;\n\t\t}\n\n\t\tif (sgrp_data && !sgrp_data->enable) {\n\t\t\tsgrp_data->enable = true;\n\t\t\thw_id = ++group_attr_id[type];\n\t\t\tpopulate_sensor(&sdata[count], opal_index, hw_id,\n\t\t\t\t\tsgrp_data->gid, \"enable\", type,\n\t\t\t\t\tpgroups[type], sgrp_data, show_enable,\n\t\t\t\t\tstore_enable);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tof_node_put(opal);\n\treturn 0;\n}\n\nstatic int ibmpowernv_probe(struct platform_device *pdev)\n{\n\tstruct platform_data *pdata;\n\tstruct device *hwmon_dev;\n\tint err;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pdata);\n\tpdata->sensors_count = 0;\n\tpdata->nr_sensor_groups = 0;\n\terr = populate_attr_groups(pdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = create_device_attrs(pdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\thwmon_dev = devm_hwmon_device_register_with_groups(&pdev->dev, DRVNAME,\n\t\t\t\t\t\t\t   pdata,\n\t\t\t\t\t\t\t   pdata->attr_groups);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct platform_device_id opal_sensor_driver_ids[] = {\n\t{\n\t\t.name = \"opal-sensor\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, opal_sensor_driver_ids);\n\nstatic const struct of_device_id opal_sensor_match[] = {\n\t{ .compatible\t= \"ibm,opal-sensor\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, opal_sensor_match);\n\nstatic struct platform_driver ibmpowernv_driver = {\n\t.probe\t\t= ibmpowernv_probe,\n\t.id_table\t= opal_sensor_driver_ids,\n\t.driver\t\t= {\n\t\t.name\t= DRVNAME,\n\t\t.of_match_table\t= opal_sensor_match,\n\t},\n};\n\nmodule_platform_driver(ibmpowernv_driver);\n\nMODULE_AUTHOR(\"Neelesh Gupta <neelegup@linux.vnet.ibm.com>\");\nMODULE_DESCRIPTION(\"IBM POWERNV platform sensors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}