{
  "module_name": "aspeed-pwm-tacho.c",
  "hash_id": "f1503bb840d6e082206f014bbf34c3e5fa019b9930b550b8ea80f0a29e46e824",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/aspeed-pwm-tacho.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/sysfs.h>\n#include <linux/thermal.h>\n\n \n#define ASPEED_PTCR_CTRL\t\t0x00\n#define ASPEED_PTCR_CLK_CTRL\t\t0x04\n#define ASPEED_PTCR_DUTY0_CTRL\t\t0x08\n#define ASPEED_PTCR_DUTY1_CTRL\t\t0x0c\n#define ASPEED_PTCR_TYPEM_CTRL\t\t0x10\n#define ASPEED_PTCR_TYPEM_CTRL1\t\t0x14\n#define ASPEED_PTCR_TYPEN_CTRL\t\t0x18\n#define ASPEED_PTCR_TYPEN_CTRL1\t\t0x1c\n#define ASPEED_PTCR_TACH_SOURCE\t\t0x20\n#define ASPEED_PTCR_TRIGGER\t\t0x28\n#define ASPEED_PTCR_RESULT\t\t0x2c\n#define ASPEED_PTCR_INTR_CTRL\t\t0x30\n#define ASPEED_PTCR_INTR_STS\t\t0x34\n#define ASPEED_PTCR_TYPEM_LIMIT\t\t0x38\n#define ASPEED_PTCR_TYPEN_LIMIT\t\t0x3C\n#define ASPEED_PTCR_CTRL_EXT\t\t0x40\n#define ASPEED_PTCR_CLK_CTRL_EXT\t0x44\n#define ASPEED_PTCR_DUTY2_CTRL\t\t0x48\n#define ASPEED_PTCR_DUTY3_CTRL\t\t0x4c\n#define ASPEED_PTCR_TYPEO_CTRL\t\t0x50\n#define ASPEED_PTCR_TYPEO_CTRL1\t\t0x54\n#define ASPEED_PTCR_TACH_SOURCE_EXT\t0x60\n#define ASPEED_PTCR_TYPEO_LIMIT\t\t0x78\n\n \n#define ASPEED_PTCR_CTRL_SET_PWMD_TYPE_PART1\t15\n#define ASPEED_PTCR_CTRL_SET_PWMD_TYPE_PART2\t6\n#define ASPEED_PTCR_CTRL_SET_PWMD_TYPE_MASK\t(BIT(7) | BIT(15))\n\n#define ASPEED_PTCR_CTRL_SET_PWMC_TYPE_PART1\t14\n#define ASPEED_PTCR_CTRL_SET_PWMC_TYPE_PART2\t5\n#define ASPEED_PTCR_CTRL_SET_PWMC_TYPE_MASK\t(BIT(6) | BIT(14))\n\n#define ASPEED_PTCR_CTRL_SET_PWMB_TYPE_PART1\t13\n#define ASPEED_PTCR_CTRL_SET_PWMB_TYPE_PART2\t4\n#define ASPEED_PTCR_CTRL_SET_PWMB_TYPE_MASK\t(BIT(5) | BIT(13))\n\n#define ASPEED_PTCR_CTRL_SET_PWMA_TYPE_PART1\t12\n#define ASPEED_PTCR_CTRL_SET_PWMA_TYPE_PART2\t3\n#define ASPEED_PTCR_CTRL_SET_PWMA_TYPE_MASK\t(BIT(4) | BIT(12))\n\n#define\tASPEED_PTCR_CTRL_FAN_NUM_EN(x)\tBIT(16 + (x))\n\n#define\tASPEED_PTCR_CTRL_PWMD_EN\tBIT(11)\n#define\tASPEED_PTCR_CTRL_PWMC_EN\tBIT(10)\n#define\tASPEED_PTCR_CTRL_PWMB_EN\tBIT(9)\n#define\tASPEED_PTCR_CTRL_PWMA_EN\tBIT(8)\n\n#define\tASPEED_PTCR_CTRL_CLK_SRC\tBIT(1)\n#define\tASPEED_PTCR_CTRL_CLK_EN\t\tBIT(0)\n\n \n \n#define ASPEED_PTCR_CLK_CTRL_TYPEN_MASK\t\tGENMASK(31, 16)\n#define ASPEED_PTCR_CLK_CTRL_TYPEN_UNIT\t\t24\n#define ASPEED_PTCR_CLK_CTRL_TYPEN_H\t\t20\n#define ASPEED_PTCR_CLK_CTRL_TYPEN_L\t\t16\n \n#define ASPEED_PTCR_CLK_CTRL_TYPEM_MASK         GENMASK(15, 0)\n#define ASPEED_PTCR_CLK_CTRL_TYPEM_UNIT\t\t8\n#define ASPEED_PTCR_CLK_CTRL_TYPEM_H\t\t4\n#define ASPEED_PTCR_CLK_CTRL_TYPEM_L\t\t0\n\n \n#define DUTY_CTRL_PWM2_FALL_POINT\t24\n#define DUTY_CTRL_PWM2_RISE_POINT\t16\n#define DUTY_CTRL_PWM2_RISE_FALL_MASK\tGENMASK(31, 16)\n#define DUTY_CTRL_PWM1_FALL_POINT\t8\n#define DUTY_CTRL_PWM1_RISE_POINT\t0\n#define DUTY_CTRL_PWM1_RISE_FALL_MASK   GENMASK(15, 0)\n\n \n#define TYPE_CTRL_FAN_MASK\t\t(GENMASK(5, 1) | GENMASK(31, 16))\n#define TYPE_CTRL_FAN1_MASK\t\tGENMASK(31, 0)\n#define TYPE_CTRL_FAN_PERIOD\t\t16\n#define TYPE_CTRL_FAN_MODE\t\t4\n#define TYPE_CTRL_FAN_DIVISION\t\t1\n#define TYPE_CTRL_FAN_TYPE_EN\t\t1\n\n \n \n#define TACH_PWM_SOURCE_BIT01(x)\t((x) * 2)\n#define TACH_PWM_SOURCE_BIT2(x)\t\t((x) * 2)\n#define TACH_PWM_SOURCE_MASK_BIT01(x)\t(0x3 << ((x) * 2))\n#define TACH_PWM_SOURCE_MASK_BIT2(x)\tBIT((x) * 2)\n\n \n#define RESULT_STATUS_MASK\t\tBIT(31)\n#define RESULT_VALUE_MASK\t\t0xfffff\n\n \n#define ASPEED_PTCR_CTRL_SET_PWMH_TYPE_PART1\t15\n#define ASPEED_PTCR_CTRL_SET_PWMH_TYPE_PART2\t6\n#define ASPEED_PTCR_CTRL_SET_PWMH_TYPE_MASK\t(BIT(7) | BIT(15))\n\n#define ASPEED_PTCR_CTRL_SET_PWMG_TYPE_PART1\t14\n#define ASPEED_PTCR_CTRL_SET_PWMG_TYPE_PART2\t5\n#define ASPEED_PTCR_CTRL_SET_PWMG_TYPE_MASK\t(BIT(6) | BIT(14))\n\n#define ASPEED_PTCR_CTRL_SET_PWMF_TYPE_PART1\t13\n#define ASPEED_PTCR_CTRL_SET_PWMF_TYPE_PART2\t4\n#define ASPEED_PTCR_CTRL_SET_PWMF_TYPE_MASK\t(BIT(5) | BIT(13))\n\n#define ASPEED_PTCR_CTRL_SET_PWME_TYPE_PART1\t12\n#define ASPEED_PTCR_CTRL_SET_PWME_TYPE_PART2\t3\n#define ASPEED_PTCR_CTRL_SET_PWME_TYPE_MASK\t(BIT(4) | BIT(12))\n\n#define\tASPEED_PTCR_CTRL_PWMH_EN\tBIT(11)\n#define\tASPEED_PTCR_CTRL_PWMG_EN\tBIT(10)\n#define\tASPEED_PTCR_CTRL_PWMF_EN\tBIT(9)\n#define\tASPEED_PTCR_CTRL_PWME_EN\tBIT(8)\n\n \n \n#define ASPEED_PTCR_CLK_CTRL_TYPEO_MASK         GENMASK(15, 0)\n#define ASPEED_PTCR_CLK_CTRL_TYPEO_UNIT\t\t8\n#define ASPEED_PTCR_CLK_CTRL_TYPEO_H\t\t4\n#define ASPEED_PTCR_CLK_CTRL_TYPEO_L\t\t0\n\n#define PWM_MAX 255\n\n#define BOTH_EDGES 0x02  \n\n#define M_PWM_DIV_H 0x00\n#define M_PWM_DIV_L 0x05\n#define M_PWM_PERIOD 0x5F\n#define M_TACH_CLK_DIV 0x00\n \n#define M_TACH_MODE 0x02  \n#define M_TACH_UNIT 0x0420\n#define INIT_FAN_CTRL 0xFF\n\n \n#define ASPEED_RPM_STATUS_SLEEP_USEC\t500\n\n#define MAX_CDEV_NAME_LEN 16\n\nstruct aspeed_cooling_device {\n\tchar name[16];\n\tstruct aspeed_pwm_tacho_data *priv;\n\tstruct thermal_cooling_device *tcdev;\n\tint pwm_port;\n\tu8 *cooling_levels;\n\tu8 max_state;\n\tu8 cur_state;\n};\n\nstruct aspeed_pwm_tacho_data {\n\tstruct regmap *regmap;\n\tstruct reset_control *rst;\n\tunsigned long clk_freq;\n\tbool pwm_present[8];\n\tbool fan_tach_present[16];\n\tu8 type_pwm_clock_unit[3];\n\tu8 type_pwm_clock_division_h[3];\n\tu8 type_pwm_clock_division_l[3];\n\tu8 type_fan_tach_clock_division[3];\n\tu8 type_fan_tach_mode[3];\n\tu16 type_fan_tach_unit[3];\n\tu8 pwm_port_type[8];\n\tu8 pwm_port_fan_ctrl[8];\n\tu8 fan_tach_ch_source[16];\n\tstruct aspeed_cooling_device *cdev[8];\n\tconst struct attribute_group *groups[3];\n};\n\nenum type { TYPEM, TYPEN, TYPEO };\n\nstruct type_params {\n\tu32 l_value;\n\tu32 h_value;\n\tu32 unit_value;\n\tu32 clk_ctrl_mask;\n\tu32 clk_ctrl_reg;\n\tu32 ctrl_reg;\n\tu32 ctrl_reg1;\n};\n\nstatic const struct type_params type_params[] = {\n\t[TYPEM] = {\n\t\t.l_value = ASPEED_PTCR_CLK_CTRL_TYPEM_L,\n\t\t.h_value = ASPEED_PTCR_CLK_CTRL_TYPEM_H,\n\t\t.unit_value = ASPEED_PTCR_CLK_CTRL_TYPEM_UNIT,\n\t\t.clk_ctrl_mask = ASPEED_PTCR_CLK_CTRL_TYPEM_MASK,\n\t\t.clk_ctrl_reg = ASPEED_PTCR_CLK_CTRL,\n\t\t.ctrl_reg = ASPEED_PTCR_TYPEM_CTRL,\n\t\t.ctrl_reg1 = ASPEED_PTCR_TYPEM_CTRL1,\n\t},\n\t[TYPEN] = {\n\t\t.l_value = ASPEED_PTCR_CLK_CTRL_TYPEN_L,\n\t\t.h_value = ASPEED_PTCR_CLK_CTRL_TYPEN_H,\n\t\t.unit_value = ASPEED_PTCR_CLK_CTRL_TYPEN_UNIT,\n\t\t.clk_ctrl_mask = ASPEED_PTCR_CLK_CTRL_TYPEN_MASK,\n\t\t.clk_ctrl_reg = ASPEED_PTCR_CLK_CTRL,\n\t\t.ctrl_reg = ASPEED_PTCR_TYPEN_CTRL,\n\t\t.ctrl_reg1 = ASPEED_PTCR_TYPEN_CTRL1,\n\t},\n\t[TYPEO] = {\n\t\t.l_value = ASPEED_PTCR_CLK_CTRL_TYPEO_L,\n\t\t.h_value = ASPEED_PTCR_CLK_CTRL_TYPEO_H,\n\t\t.unit_value = ASPEED_PTCR_CLK_CTRL_TYPEO_UNIT,\n\t\t.clk_ctrl_mask = ASPEED_PTCR_CLK_CTRL_TYPEO_MASK,\n\t\t.clk_ctrl_reg = ASPEED_PTCR_CLK_CTRL_EXT,\n\t\t.ctrl_reg = ASPEED_PTCR_TYPEO_CTRL,\n\t\t.ctrl_reg1 = ASPEED_PTCR_TYPEO_CTRL1,\n\t}\n};\n\nenum pwm_port { PWMA, PWMB, PWMC, PWMD, PWME, PWMF, PWMG, PWMH };\n\nstruct pwm_port_params {\n\tu32 pwm_en;\n\tu32 ctrl_reg;\n\tu32 type_part1;\n\tu32 type_part2;\n\tu32 type_mask;\n\tu32 duty_ctrl_rise_point;\n\tu32 duty_ctrl_fall_point;\n\tu32 duty_ctrl_reg;\n\tu32 duty_ctrl_rise_fall_mask;\n};\n\nstatic const struct pwm_port_params pwm_port_params[] = {\n\t[PWMA] = {\n\t\t.pwm_en = ASPEED_PTCR_CTRL_PWMA_EN,\n\t\t.ctrl_reg = ASPEED_PTCR_CTRL,\n\t\t.type_part1 = ASPEED_PTCR_CTRL_SET_PWMA_TYPE_PART1,\n\t\t.type_part2 = ASPEED_PTCR_CTRL_SET_PWMA_TYPE_PART2,\n\t\t.type_mask = ASPEED_PTCR_CTRL_SET_PWMA_TYPE_MASK,\n\t\t.duty_ctrl_rise_point = DUTY_CTRL_PWM1_RISE_POINT,\n\t\t.duty_ctrl_fall_point = DUTY_CTRL_PWM1_FALL_POINT,\n\t\t.duty_ctrl_reg = ASPEED_PTCR_DUTY0_CTRL,\n\t\t.duty_ctrl_rise_fall_mask = DUTY_CTRL_PWM1_RISE_FALL_MASK,\n\t},\n\t[PWMB] = {\n\t\t.pwm_en = ASPEED_PTCR_CTRL_PWMB_EN,\n\t\t.ctrl_reg = ASPEED_PTCR_CTRL,\n\t\t.type_part1 = ASPEED_PTCR_CTRL_SET_PWMB_TYPE_PART1,\n\t\t.type_part2 = ASPEED_PTCR_CTRL_SET_PWMB_TYPE_PART2,\n\t\t.type_mask = ASPEED_PTCR_CTRL_SET_PWMB_TYPE_MASK,\n\t\t.duty_ctrl_rise_point = DUTY_CTRL_PWM2_RISE_POINT,\n\t\t.duty_ctrl_fall_point = DUTY_CTRL_PWM2_FALL_POINT,\n\t\t.duty_ctrl_reg = ASPEED_PTCR_DUTY0_CTRL,\n\t\t.duty_ctrl_rise_fall_mask = DUTY_CTRL_PWM2_RISE_FALL_MASK,\n\t},\n\t[PWMC] = {\n\t\t.pwm_en = ASPEED_PTCR_CTRL_PWMC_EN,\n\t\t.ctrl_reg = ASPEED_PTCR_CTRL,\n\t\t.type_part1 = ASPEED_PTCR_CTRL_SET_PWMC_TYPE_PART1,\n\t\t.type_part2 = ASPEED_PTCR_CTRL_SET_PWMC_TYPE_PART2,\n\t\t.type_mask = ASPEED_PTCR_CTRL_SET_PWMC_TYPE_MASK,\n\t\t.duty_ctrl_rise_point = DUTY_CTRL_PWM1_RISE_POINT,\n\t\t.duty_ctrl_fall_point = DUTY_CTRL_PWM1_FALL_POINT,\n\t\t.duty_ctrl_reg = ASPEED_PTCR_DUTY1_CTRL,\n\t\t.duty_ctrl_rise_fall_mask = DUTY_CTRL_PWM1_RISE_FALL_MASK,\n\t},\n\t[PWMD] = {\n\t\t.pwm_en = ASPEED_PTCR_CTRL_PWMD_EN,\n\t\t.ctrl_reg = ASPEED_PTCR_CTRL,\n\t\t.type_part1 = ASPEED_PTCR_CTRL_SET_PWMD_TYPE_PART1,\n\t\t.type_part2 = ASPEED_PTCR_CTRL_SET_PWMD_TYPE_PART2,\n\t\t.type_mask = ASPEED_PTCR_CTRL_SET_PWMD_TYPE_MASK,\n\t\t.duty_ctrl_rise_point = DUTY_CTRL_PWM2_RISE_POINT,\n\t\t.duty_ctrl_fall_point = DUTY_CTRL_PWM2_FALL_POINT,\n\t\t.duty_ctrl_reg = ASPEED_PTCR_DUTY1_CTRL,\n\t\t.duty_ctrl_rise_fall_mask = DUTY_CTRL_PWM2_RISE_FALL_MASK,\n\t},\n\t[PWME] = {\n\t\t.pwm_en = ASPEED_PTCR_CTRL_PWME_EN,\n\t\t.ctrl_reg = ASPEED_PTCR_CTRL_EXT,\n\t\t.type_part1 = ASPEED_PTCR_CTRL_SET_PWME_TYPE_PART1,\n\t\t.type_part2 = ASPEED_PTCR_CTRL_SET_PWME_TYPE_PART2,\n\t\t.type_mask = ASPEED_PTCR_CTRL_SET_PWME_TYPE_MASK,\n\t\t.duty_ctrl_rise_point = DUTY_CTRL_PWM1_RISE_POINT,\n\t\t.duty_ctrl_fall_point = DUTY_CTRL_PWM1_FALL_POINT,\n\t\t.duty_ctrl_reg = ASPEED_PTCR_DUTY2_CTRL,\n\t\t.duty_ctrl_rise_fall_mask = DUTY_CTRL_PWM1_RISE_FALL_MASK,\n\t},\n\t[PWMF] = {\n\t\t.pwm_en = ASPEED_PTCR_CTRL_PWMF_EN,\n\t\t.ctrl_reg = ASPEED_PTCR_CTRL_EXT,\n\t\t.type_part1 = ASPEED_PTCR_CTRL_SET_PWMF_TYPE_PART1,\n\t\t.type_part2 = ASPEED_PTCR_CTRL_SET_PWMF_TYPE_PART2,\n\t\t.type_mask = ASPEED_PTCR_CTRL_SET_PWMF_TYPE_MASK,\n\t\t.duty_ctrl_rise_point = DUTY_CTRL_PWM2_RISE_POINT,\n\t\t.duty_ctrl_fall_point = DUTY_CTRL_PWM2_FALL_POINT,\n\t\t.duty_ctrl_reg = ASPEED_PTCR_DUTY2_CTRL,\n\t\t.duty_ctrl_rise_fall_mask = DUTY_CTRL_PWM2_RISE_FALL_MASK,\n\t},\n\t[PWMG] = {\n\t\t.pwm_en = ASPEED_PTCR_CTRL_PWMG_EN,\n\t\t.ctrl_reg = ASPEED_PTCR_CTRL_EXT,\n\t\t.type_part1 = ASPEED_PTCR_CTRL_SET_PWMG_TYPE_PART1,\n\t\t.type_part2 = ASPEED_PTCR_CTRL_SET_PWMG_TYPE_PART2,\n\t\t.type_mask = ASPEED_PTCR_CTRL_SET_PWMG_TYPE_MASK,\n\t\t.duty_ctrl_rise_point = DUTY_CTRL_PWM1_RISE_POINT,\n\t\t.duty_ctrl_fall_point = DUTY_CTRL_PWM1_FALL_POINT,\n\t\t.duty_ctrl_reg = ASPEED_PTCR_DUTY3_CTRL,\n\t\t.duty_ctrl_rise_fall_mask = DUTY_CTRL_PWM1_RISE_FALL_MASK,\n\t},\n\t[PWMH] = {\n\t\t.pwm_en = ASPEED_PTCR_CTRL_PWMH_EN,\n\t\t.ctrl_reg = ASPEED_PTCR_CTRL_EXT,\n\t\t.type_part1 = ASPEED_PTCR_CTRL_SET_PWMH_TYPE_PART1,\n\t\t.type_part2 = ASPEED_PTCR_CTRL_SET_PWMH_TYPE_PART2,\n\t\t.type_mask = ASPEED_PTCR_CTRL_SET_PWMH_TYPE_MASK,\n\t\t.duty_ctrl_rise_point = DUTY_CTRL_PWM2_RISE_POINT,\n\t\t.duty_ctrl_fall_point = DUTY_CTRL_PWM2_FALL_POINT,\n\t\t.duty_ctrl_reg = ASPEED_PTCR_DUTY3_CTRL,\n\t\t.duty_ctrl_rise_fall_mask = DUTY_CTRL_PWM2_RISE_FALL_MASK,\n\t}\n};\n\nstatic int regmap_aspeed_pwm_tacho_reg_write(void *context, unsigned int reg,\n\t\t\t\t\t     unsigned int val)\n{\n\tvoid __iomem *regs = (void __iomem *)context;\n\n\twritel(val, regs + reg);\n\treturn 0;\n}\n\nstatic int regmap_aspeed_pwm_tacho_reg_read(void *context, unsigned int reg,\n\t\t\t\t\t    unsigned int *val)\n{\n\tvoid __iomem *regs = (void __iomem *)context;\n\n\t*val = readl(regs + reg);\n\treturn 0;\n}\n\nstatic const struct regmap_config aspeed_pwm_tacho_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = ASPEED_PTCR_TYPEO_LIMIT,\n\t.reg_write = regmap_aspeed_pwm_tacho_reg_write,\n\t.reg_read = regmap_aspeed_pwm_tacho_reg_read,\n\t.fast_io = true,\n};\n\nstatic void aspeed_set_clock_enable(struct regmap *regmap, bool val)\n{\n\tregmap_update_bits(regmap, ASPEED_PTCR_CTRL,\n\t\t\t   ASPEED_PTCR_CTRL_CLK_EN,\n\t\t\t   val ? ASPEED_PTCR_CTRL_CLK_EN : 0);\n}\n\nstatic void aspeed_set_clock_source(struct regmap *regmap, int val)\n{\n\tregmap_update_bits(regmap, ASPEED_PTCR_CTRL,\n\t\t\t   ASPEED_PTCR_CTRL_CLK_SRC,\n\t\t\t   val ? ASPEED_PTCR_CTRL_CLK_SRC : 0);\n}\n\nstatic void aspeed_set_pwm_clock_values(struct regmap *regmap, u8 type,\n\t\t\t\t\tu8 div_high, u8 div_low, u8 unit)\n{\n\tu32 reg_value = ((div_high << type_params[type].h_value) |\n\t\t\t (div_low << type_params[type].l_value) |\n\t\t\t (unit << type_params[type].unit_value));\n\n\tregmap_update_bits(regmap, type_params[type].clk_ctrl_reg,\n\t\t\t   type_params[type].clk_ctrl_mask, reg_value);\n}\n\nstatic void aspeed_set_pwm_port_enable(struct regmap *regmap, u8 pwm_port,\n\t\t\t\t       bool enable)\n{\n\tregmap_update_bits(regmap, pwm_port_params[pwm_port].ctrl_reg,\n\t\t\t   pwm_port_params[pwm_port].pwm_en,\n\t\t\t   enable ? pwm_port_params[pwm_port].pwm_en : 0);\n}\n\nstatic void aspeed_set_pwm_port_type(struct regmap *regmap,\n\t\t\t\t     u8 pwm_port, u8 type)\n{\n\tu32 reg_value = (type & 0x1) << pwm_port_params[pwm_port].type_part1;\n\n\treg_value |= (type & 0x2) << pwm_port_params[pwm_port].type_part2;\n\n\tregmap_update_bits(regmap, pwm_port_params[pwm_port].ctrl_reg,\n\t\t\t   pwm_port_params[pwm_port].type_mask, reg_value);\n}\n\nstatic void aspeed_set_pwm_port_duty_rising_falling(struct regmap *regmap,\n\t\t\t\t\t\t    u8 pwm_port, u8 rising,\n\t\t\t\t\t\t    u8 falling)\n{\n\tu32 reg_value = (rising <<\n\t\t\t pwm_port_params[pwm_port].duty_ctrl_rise_point);\n\treg_value |= (falling <<\n\t\t      pwm_port_params[pwm_port].duty_ctrl_fall_point);\n\n\tregmap_update_bits(regmap, pwm_port_params[pwm_port].duty_ctrl_reg,\n\t\t\t   pwm_port_params[pwm_port].duty_ctrl_rise_fall_mask,\n\t\t\t   reg_value);\n}\n\nstatic void aspeed_set_tacho_type_enable(struct regmap *regmap, u8 type,\n\t\t\t\t\t bool enable)\n{\n\tregmap_update_bits(regmap, type_params[type].ctrl_reg,\n\t\t\t   TYPE_CTRL_FAN_TYPE_EN,\n\t\t\t   enable ? TYPE_CTRL_FAN_TYPE_EN : 0);\n}\n\nstatic void aspeed_set_tacho_type_values(struct regmap *regmap, u8 type,\n\t\t\t\t\t u8 mode, u16 unit, u8 division)\n{\n\tu32 reg_value = ((mode << TYPE_CTRL_FAN_MODE) |\n\t\t\t (unit << TYPE_CTRL_FAN_PERIOD) |\n\t\t\t (division << TYPE_CTRL_FAN_DIVISION));\n\n\tregmap_update_bits(regmap, type_params[type].ctrl_reg,\n\t\t\t   TYPE_CTRL_FAN_MASK, reg_value);\n\tregmap_update_bits(regmap, type_params[type].ctrl_reg1,\n\t\t\t   TYPE_CTRL_FAN1_MASK, unit << 16);\n}\n\nstatic void aspeed_set_fan_tach_ch_enable(struct regmap *regmap, u8 fan_tach_ch,\n\t\t\t\t\t  bool enable)\n{\n\tregmap_update_bits(regmap, ASPEED_PTCR_CTRL,\n\t\t\t   ASPEED_PTCR_CTRL_FAN_NUM_EN(fan_tach_ch),\n\t\t\t   enable ?\n\t\t\t   ASPEED_PTCR_CTRL_FAN_NUM_EN(fan_tach_ch) : 0);\n}\n\nstatic void aspeed_set_fan_tach_ch_source(struct regmap *regmap, u8 fan_tach_ch,\n\t\t\t\t\t  u8 fan_tach_ch_source)\n{\n\tu32 reg_value1 = ((fan_tach_ch_source & 0x3) <<\n\t\t\t  TACH_PWM_SOURCE_BIT01(fan_tach_ch));\n\tu32 reg_value2 = (((fan_tach_ch_source & 0x4) >> 2) <<\n\t\t\t  TACH_PWM_SOURCE_BIT2(fan_tach_ch));\n\n\tregmap_update_bits(regmap, ASPEED_PTCR_TACH_SOURCE,\n\t\t\t   TACH_PWM_SOURCE_MASK_BIT01(fan_tach_ch),\n\t\t\t   reg_value1);\n\n\tregmap_update_bits(regmap, ASPEED_PTCR_TACH_SOURCE_EXT,\n\t\t\t   TACH_PWM_SOURCE_MASK_BIT2(fan_tach_ch),\n\t\t\t   reg_value2);\n}\n\nstatic void aspeed_set_pwm_port_fan_ctrl(struct aspeed_pwm_tacho_data *priv,\n\t\t\t\t\t u8 index, u8 fan_ctrl)\n{\n\tu16 period, dc_time_on;\n\n\tperiod = priv->type_pwm_clock_unit[priv->pwm_port_type[index]];\n\tperiod += 1;\n\tdc_time_on = (fan_ctrl * period) / PWM_MAX;\n\n\tif (dc_time_on == 0) {\n\t\taspeed_set_pwm_port_enable(priv->regmap, index, false);\n\t} else {\n\t\tif (dc_time_on == period)\n\t\t\tdc_time_on = 0;\n\n\t\taspeed_set_pwm_port_duty_rising_falling(priv->regmap, index, 0,\n\t\t\t\t\t\t\tdc_time_on);\n\t\taspeed_set_pwm_port_enable(priv->regmap, index, true);\n\t}\n}\n\nstatic u32 aspeed_get_fan_tach_ch_measure_period(struct aspeed_pwm_tacho_data\n\t\t\t\t\t\t *priv, u8 type)\n{\n\tu32 clk;\n\tu16 tacho_unit;\n\tu8 clk_unit, div_h, div_l, tacho_div;\n\n\tclk = priv->clk_freq;\n\tclk_unit = priv->type_pwm_clock_unit[type];\n\tdiv_h = priv->type_pwm_clock_division_h[type];\n\tdiv_h = 0x1 << div_h;\n\tdiv_l = priv->type_pwm_clock_division_l[type];\n\tif (div_l == 0)\n\t\tdiv_l = 1;\n\telse\n\t\tdiv_l = div_l * 2;\n\n\ttacho_unit = priv->type_fan_tach_unit[type];\n\ttacho_div = priv->type_fan_tach_clock_division[type];\n\n\ttacho_div = 0x4 << (tacho_div * 2);\n\treturn clk / (clk_unit * div_h * div_l * tacho_div * tacho_unit);\n}\n\nstatic int aspeed_get_fan_tach_ch_rpm(struct aspeed_pwm_tacho_data *priv,\n\t\t\t\t      u8 fan_tach_ch)\n{\n\tu32 raw_data, tach_div, clk_source, msec, usec, val;\n\tu8 fan_tach_ch_source, type, mode, both;\n\tint ret;\n\n\tregmap_write(priv->regmap, ASPEED_PTCR_TRIGGER, 0);\n\tregmap_write(priv->regmap, ASPEED_PTCR_TRIGGER, 0x1 << fan_tach_ch);\n\n\tfan_tach_ch_source = priv->fan_tach_ch_source[fan_tach_ch];\n\ttype = priv->pwm_port_type[fan_tach_ch_source];\n\n\tmsec = (1000 / aspeed_get_fan_tach_ch_measure_period(priv, type));\n\tusec = msec * 1000;\n\n\tret = regmap_read_poll_timeout(\n\t\tpriv->regmap,\n\t\tASPEED_PTCR_RESULT,\n\t\tval,\n\t\t(val & RESULT_STATUS_MASK),\n\t\tASPEED_RPM_STATUS_SLEEP_USEC,\n\t\tusec);\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\traw_data = val & RESULT_VALUE_MASK;\n\ttach_div = priv->type_fan_tach_clock_division[type];\n\t \n\tmode = priv->type_fan_tach_mode[type];\n\tboth = (mode & BOTH_EDGES) ? 1 : 0;\n\n\ttach_div = (0x4 << both) << (tach_div * 2);\n\tclk_source = priv->clk_freq;\n\n\tif (raw_data == 0)\n\t\treturn 0;\n\n\treturn (clk_source * 60) / (2 * raw_data * tach_div);\n}\n\nstatic ssize_t pwm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint index = sensor_attr->index;\n\tint ret;\n\tstruct aspeed_pwm_tacho_data *priv = dev_get_drvdata(dev);\n\tlong fan_ctrl;\n\n\tret = kstrtol(buf, 10, &fan_ctrl);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (fan_ctrl < 0 || fan_ctrl > PWM_MAX)\n\t\treturn -EINVAL;\n\n\tif (priv->pwm_port_fan_ctrl[index] == fan_ctrl)\n\t\treturn count;\n\n\tpriv->pwm_port_fan_ctrl[index] = fan_ctrl;\n\taspeed_set_pwm_port_fan_ctrl(priv, index, fan_ctrl);\n\n\treturn count;\n}\n\nstatic ssize_t pwm_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint index = sensor_attr->index;\n\tstruct aspeed_pwm_tacho_data *priv = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", priv->pwm_port_fan_ctrl[index]);\n}\n\nstatic ssize_t rpm_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint index = sensor_attr->index;\n\tint rpm;\n\tstruct aspeed_pwm_tacho_data *priv = dev_get_drvdata(dev);\n\n\trpm = aspeed_get_fan_tach_ch_rpm(priv, index);\n\tif (rpm < 0)\n\t\treturn rpm;\n\n\treturn sprintf(buf, \"%d\\n\", rpm);\n}\n\nstatic umode_t pwm_is_visible(struct kobject *kobj,\n\t\t\t      struct attribute *a, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct aspeed_pwm_tacho_data *priv = dev_get_drvdata(dev);\n\n\tif (!priv->pwm_present[index])\n\t\treturn 0;\n\treturn a->mode;\n}\n\nstatic umode_t fan_dev_is_visible(struct kobject *kobj,\n\t\t\t\t  struct attribute *a, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct aspeed_pwm_tacho_data *priv = dev_get_drvdata(dev);\n\n\tif (!priv->fan_tach_present[index])\n\t\treturn 0;\n\treturn a->mode;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1, pwm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2, pwm, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3, pwm, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm4, pwm, 3);\nstatic SENSOR_DEVICE_ATTR_RW(pwm5, pwm, 4);\nstatic SENSOR_DEVICE_ATTR_RW(pwm6, pwm, 5);\nstatic SENSOR_DEVICE_ATTR_RW(pwm7, pwm, 6);\nstatic SENSOR_DEVICE_ATTR_RW(pwm8, pwm, 7);\nstatic struct attribute *pwm_dev_attrs[] = {\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\t&sensor_dev_attr_pwm4.dev_attr.attr,\n\t&sensor_dev_attr_pwm5.dev_attr.attr,\n\t&sensor_dev_attr_pwm6.dev_attr.attr,\n\t&sensor_dev_attr_pwm7.dev_attr.attr,\n\t&sensor_dev_attr_pwm8.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group pwm_dev_group = {\n\t.attrs = pwm_dev_attrs,\n\t.is_visible = pwm_is_visible,\n};\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, rpm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, rpm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_input, rpm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(fan4_input, rpm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(fan5_input, rpm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(fan6_input, rpm, 5);\nstatic SENSOR_DEVICE_ATTR_RO(fan7_input, rpm, 6);\nstatic SENSOR_DEVICE_ATTR_RO(fan8_input, rpm, 7);\nstatic SENSOR_DEVICE_ATTR_RO(fan9_input, rpm, 8);\nstatic SENSOR_DEVICE_ATTR_RO(fan10_input, rpm, 9);\nstatic SENSOR_DEVICE_ATTR_RO(fan11_input, rpm, 10);\nstatic SENSOR_DEVICE_ATTR_RO(fan12_input, rpm, 11);\nstatic SENSOR_DEVICE_ATTR_RO(fan13_input, rpm, 12);\nstatic SENSOR_DEVICE_ATTR_RO(fan14_input, rpm, 13);\nstatic SENSOR_DEVICE_ATTR_RO(fan15_input, rpm, 14);\nstatic SENSOR_DEVICE_ATTR_RO(fan16_input, rpm, 15);\nstatic struct attribute *fan_dev_attrs[] = {\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan4_input.dev_attr.attr,\n\t&sensor_dev_attr_fan5_input.dev_attr.attr,\n\t&sensor_dev_attr_fan6_input.dev_attr.attr,\n\t&sensor_dev_attr_fan7_input.dev_attr.attr,\n\t&sensor_dev_attr_fan8_input.dev_attr.attr,\n\t&sensor_dev_attr_fan9_input.dev_attr.attr,\n\t&sensor_dev_attr_fan10_input.dev_attr.attr,\n\t&sensor_dev_attr_fan11_input.dev_attr.attr,\n\t&sensor_dev_attr_fan12_input.dev_attr.attr,\n\t&sensor_dev_attr_fan13_input.dev_attr.attr,\n\t&sensor_dev_attr_fan14_input.dev_attr.attr,\n\t&sensor_dev_attr_fan15_input.dev_attr.attr,\n\t&sensor_dev_attr_fan16_input.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group fan_dev_group = {\n\t.attrs = fan_dev_attrs,\n\t.is_visible = fan_dev_is_visible,\n};\n\n \nstatic void aspeed_create_type(struct aspeed_pwm_tacho_data *priv)\n{\n\tpriv->type_pwm_clock_division_h[TYPEM] = M_PWM_DIV_H;\n\tpriv->type_pwm_clock_division_l[TYPEM] = M_PWM_DIV_L;\n\tpriv->type_pwm_clock_unit[TYPEM] = M_PWM_PERIOD;\n\taspeed_set_pwm_clock_values(priv->regmap, TYPEM, M_PWM_DIV_H,\n\t\t\t\t    M_PWM_DIV_L, M_PWM_PERIOD);\n\taspeed_set_tacho_type_enable(priv->regmap, TYPEM, true);\n\tpriv->type_fan_tach_clock_division[TYPEM] = M_TACH_CLK_DIV;\n\tpriv->type_fan_tach_unit[TYPEM] = M_TACH_UNIT;\n\tpriv->type_fan_tach_mode[TYPEM] = M_TACH_MODE;\n\taspeed_set_tacho_type_values(priv->regmap, TYPEM, M_TACH_MODE,\n\t\t\t\t     M_TACH_UNIT, M_TACH_CLK_DIV);\n}\n\nstatic void aspeed_create_pwm_port(struct aspeed_pwm_tacho_data *priv,\n\t\t\t\t   u8 pwm_port)\n{\n\taspeed_set_pwm_port_enable(priv->regmap, pwm_port, true);\n\tpriv->pwm_present[pwm_port] = true;\n\n\tpriv->pwm_port_type[pwm_port] = TYPEM;\n\taspeed_set_pwm_port_type(priv->regmap, pwm_port, TYPEM);\n\n\tpriv->pwm_port_fan_ctrl[pwm_port] = INIT_FAN_CTRL;\n\taspeed_set_pwm_port_fan_ctrl(priv, pwm_port, INIT_FAN_CTRL);\n}\n\nstatic void aspeed_create_fan_tach_channel(struct aspeed_pwm_tacho_data *priv,\n\t\t\t\t\t   u8 *fan_tach_ch,\n\t\t\t\t\t   int count,\n\t\t\t\t\t   u8 pwm_source)\n{\n\tu8 val, index;\n\n\tfor (val = 0; val < count; val++) {\n\t\tindex = fan_tach_ch[val];\n\t\taspeed_set_fan_tach_ch_enable(priv->regmap, index, true);\n\t\tpriv->fan_tach_present[index] = true;\n\t\tpriv->fan_tach_ch_source[index] = pwm_source;\n\t\taspeed_set_fan_tach_ch_source(priv->regmap, index, pwm_source);\n\t}\n}\n\nstatic int\naspeed_pwm_cz_get_max_state(struct thermal_cooling_device *tcdev,\n\t\t\t    unsigned long *state)\n{\n\tstruct aspeed_cooling_device *cdev = tcdev->devdata;\n\n\t*state = cdev->max_state;\n\n\treturn 0;\n}\n\nstatic int\naspeed_pwm_cz_get_cur_state(struct thermal_cooling_device *tcdev,\n\t\t\t    unsigned long *state)\n{\n\tstruct aspeed_cooling_device *cdev = tcdev->devdata;\n\n\t*state = cdev->cur_state;\n\n\treturn 0;\n}\n\nstatic int\naspeed_pwm_cz_set_cur_state(struct thermal_cooling_device *tcdev,\n\t\t\t    unsigned long state)\n{\n\tstruct aspeed_cooling_device *cdev = tcdev->devdata;\n\n\tif (state > cdev->max_state)\n\t\treturn -EINVAL;\n\n\tcdev->cur_state = state;\n\tcdev->priv->pwm_port_fan_ctrl[cdev->pwm_port] =\n\t\t\t\t\tcdev->cooling_levels[cdev->cur_state];\n\taspeed_set_pwm_port_fan_ctrl(cdev->priv, cdev->pwm_port,\n\t\t\t\t     cdev->cooling_levels[cdev->cur_state]);\n\n\treturn 0;\n}\n\nstatic const struct thermal_cooling_device_ops aspeed_pwm_cool_ops = {\n\t.get_max_state = aspeed_pwm_cz_get_max_state,\n\t.get_cur_state = aspeed_pwm_cz_get_cur_state,\n\t.set_cur_state = aspeed_pwm_cz_set_cur_state,\n};\n\nstatic int aspeed_create_pwm_cooling(struct device *dev,\n\t\t\t\t     struct device_node *child,\n\t\t\t\t     struct aspeed_pwm_tacho_data *priv,\n\t\t\t\t     u32 pwm_port, u8 num_levels)\n{\n\tint ret;\n\tstruct aspeed_cooling_device *cdev;\n\n\tcdev = devm_kzalloc(dev, sizeof(*cdev), GFP_KERNEL);\n\n\tif (!cdev)\n\t\treturn -ENOMEM;\n\n\tcdev->cooling_levels = devm_kzalloc(dev, num_levels, GFP_KERNEL);\n\tif (!cdev->cooling_levels)\n\t\treturn -ENOMEM;\n\n\tcdev->max_state = num_levels - 1;\n\tret = of_property_read_u8_array(child, \"cooling-levels\",\n\t\t\t\t\tcdev->cooling_levels,\n\t\t\t\t\tnum_levels);\n\tif (ret) {\n\t\tdev_err(dev, \"Property 'cooling-levels' cannot be read.\\n\");\n\t\treturn ret;\n\t}\n\tsnprintf(cdev->name, MAX_CDEV_NAME_LEN, \"%pOFn%d\", child, pwm_port);\n\n\tcdev->tcdev = devm_thermal_of_cooling_device_register(dev, child,\n\t\t\t\t\tcdev->name, cdev, &aspeed_pwm_cool_ops);\n\tif (IS_ERR(cdev->tcdev))\n\t\treturn PTR_ERR(cdev->tcdev);\n\n\tcdev->priv = priv;\n\tcdev->pwm_port = pwm_port;\n\n\tpriv->cdev[pwm_port] = cdev;\n\n\treturn 0;\n}\n\nstatic int aspeed_create_fan(struct device *dev,\n\t\t\t     struct device_node *child,\n\t\t\t     struct aspeed_pwm_tacho_data *priv)\n{\n\tu8 *fan_tach_ch;\n\tu32 pwm_port;\n\tint ret, count;\n\n\tret = of_property_read_u32(child, \"reg\", &pwm_port);\n\tif (ret)\n\t\treturn ret;\n\tif (pwm_port >= ARRAY_SIZE(pwm_port_params))\n\t\treturn -EINVAL;\n\taspeed_create_pwm_port(priv, (u8)pwm_port);\n\n\tret = of_property_count_u8_elems(child, \"cooling-levels\");\n\n\tif (ret > 0) {\n\t\tret = aspeed_create_pwm_cooling(dev, child, priv, pwm_port,\n\t\t\t\t\t\tret);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcount = of_property_count_u8_elems(child, \"aspeed,fan-tach-ch\");\n\tif (count < 1)\n\t\treturn -EINVAL;\n\tfan_tach_ch = devm_kcalloc(dev, count, sizeof(*fan_tach_ch),\n\t\t\t\t   GFP_KERNEL);\n\tif (!fan_tach_ch)\n\t\treturn -ENOMEM;\n\tret = of_property_read_u8_array(child, \"aspeed,fan-tach-ch\",\n\t\t\t\t\tfan_tach_ch, count);\n\tif (ret)\n\t\treturn ret;\n\taspeed_create_fan_tach_channel(priv, fan_tach_ch, count, pwm_port);\n\n\treturn 0;\n}\n\nstatic void aspeed_pwm_tacho_remove(void *data)\n{\n\tstruct aspeed_pwm_tacho_data *priv = data;\n\n\treset_control_assert(priv->rst);\n}\n\nstatic int aspeed_pwm_tacho_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np, *child;\n\tstruct aspeed_pwm_tacho_data *priv;\n\tvoid __iomem *regs;\n\tstruct device *hwmon;\n\tstruct clk *clk;\n\tint ret;\n\n\tnp = dev->of_node;\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->regmap = devm_regmap_init(dev, NULL, (__force void *)regs,\n\t\t\t&aspeed_pwm_tacho_regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tpriv->rst = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(priv->rst)) {\n\t\tdev_err(dev,\n\t\t\t\"missing or invalid reset controller device tree entry\");\n\t\treturn PTR_ERR(priv->rst);\n\t}\n\treset_control_deassert(priv->rst);\n\n\tret = devm_add_action_or_reset(dev, aspeed_pwm_tacho_remove, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_write(priv->regmap, ASPEED_PTCR_TACH_SOURCE, 0);\n\tregmap_write(priv->regmap, ASPEED_PTCR_TACH_SOURCE_EXT, 0);\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn -ENODEV;\n\tpriv->clk_freq = clk_get_rate(clk);\n\taspeed_set_clock_enable(priv->regmap, true);\n\taspeed_set_clock_source(priv->regmap, 0);\n\n\taspeed_create_type(priv);\n\n\tfor_each_child_of_node(np, child) {\n\t\tret = aspeed_create_fan(dev, child, priv);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpriv->groups[0] = &pwm_dev_group;\n\tpriv->groups[1] = &fan_dev_group;\n\tpriv->groups[2] = NULL;\n\thwmon = devm_hwmon_device_register_with_groups(dev,\n\t\t\t\t\t\t       \"aspeed_pwm_tacho\",\n\t\t\t\t\t\t       priv, priv->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon);\n}\n\nstatic const struct of_device_id of_pwm_tacho_match_table[] = {\n\t{ .compatible = \"aspeed,ast2400-pwm-tacho\", },\n\t{ .compatible = \"aspeed,ast2500-pwm-tacho\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_pwm_tacho_match_table);\n\nstatic struct platform_driver aspeed_pwm_tacho_driver = {\n\t.probe\t\t= aspeed_pwm_tacho_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"aspeed_pwm_tacho\",\n\t\t.of_match_table = of_pwm_tacho_match_table,\n\t},\n};\n\nmodule_platform_driver(aspeed_pwm_tacho_driver);\n\nMODULE_AUTHOR(\"Jaghathiswari Rankappagounder Natarajan <jaghu@google.com>\");\nMODULE_DESCRIPTION(\"ASPEED PWM and Fan Tacho device driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}