{
  "module_name": "ultra45_env.c",
  "hash_id": "a6e86501546812dc9b9afddde8612ea3f17f93fe10ba04a14b494e5c98402e60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ultra45_env.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n\n#define DRV_MODULE_VERSION\t\"0.1\"\n\nMODULE_AUTHOR(\"David S. Miller (davem@davemloft.net)\");\nMODULE_DESCRIPTION(\"Ultra45 environmental monitor driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_MODULE_VERSION);\n\n \n#define REG_CMD\t\t0x00UL\n#define  REG_CMD_RESET\t0x80\n#define  REG_CMD_ESTAR\t0x01\n#define REG_STAT\t0x01UL\n#define  REG_STAT_FWVER\t0xf0\n#define  REG_STAT_TGOOD\t0x08\n#define  REG_STAT_STALE\t0x04\n#define  REG_STAT_BUSY\t0x02\n#define  REG_STAT_FAULT\t0x01\n#define REG_DATA\t0x40UL\n#define REG_ADDR\t0x41UL\n#define REG_SIZE\t0x42UL\n\n \n#define IREG_FAN0\t\t0x00\n#define IREG_FAN1\t\t0x01\n#define IREG_FAN2\t\t0x02\n#define IREG_FAN3\t\t0x03\n#define IREG_FAN4\t\t0x04\n#define IREG_FAN5\t\t0x05\n#define IREG_LCL_TEMP\t\t0x06\n#define IREG_RMT1_TEMP\t\t0x07\n#define IREG_RMT2_TEMP\t\t0x08\n#define IREG_RMT3_TEMP\t\t0x09\n#define IREG_LM95221_TEMP\t0x0a\n#define IREG_FIRE_TEMP\t\t0x0b\n#define IREG_LSI1064_TEMP\t0x0c\n#define IREG_FRONT_TEMP\t\t0x0d\n#define IREG_FAN_STAT\t\t0x0e\n#define IREG_VCORE0\t\t0x0f\n#define IREG_VCORE1\t\t0x10\n#define IREG_VMEM0\t\t0x11\n#define IREG_VMEM1\t\t0x12\n#define IREG_PSU_TEMP\t\t0x13\n\nstruct env {\n\tvoid __iomem\t*regs;\n\tspinlock_t\tlock;\n\n\tstruct device\t*hwmon_dev;\n};\n\nstatic u8 env_read(struct env *p, u8 ireg)\n{\n\tu8 ret;\n\n\tspin_lock(&p->lock);\n\twriteb(ireg, p->regs + REG_ADDR);\n\tret = readb(p->regs + REG_DATA);\n\tspin_unlock(&p->lock);\n\n\treturn ret;\n}\n\nstatic void env_write(struct env *p, u8 ireg, u8 val)\n{\n\tspin_lock(&p->lock);\n\twriteb(ireg, p->regs + REG_ADDR);\n\twriteb(val, p->regs + REG_DATA);\n\tspin_unlock(&p->lock);\n}\n\n \n#define FAN_PERIOD_TO_RPM(x)\t((90000 * 60) / (x))\n#define FAN_RPM_TO_PERIOD\tFAN_PERIOD_TO_RPM\n#define FAN_PERIOD_INVALID\t(0xff << 8)\n#define FAN_DATA_VALID(x)\t((x) && (x) != FAN_PERIOD_INVALID)\n\nstatic ssize_t show_fan_speed(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tint fan_nr = to_sensor_dev_attr(attr)->index;\n\tstruct env *p = dev_get_drvdata(dev);\n\tint rpm, period;\n\tu8 val;\n\n\tval = env_read(p, IREG_FAN0 + fan_nr);\n\tperiod = (int) val << 8;\n\tif (FAN_DATA_VALID(period))\n\t\trpm = FAN_PERIOD_TO_RPM(period);\n\telse\n\t\trpm = 0;\n\n\treturn sprintf(buf, \"%d\\n\", rpm);\n}\n\nstatic ssize_t set_fan_speed(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tint fan_nr = to_sensor_dev_attr(attr)->index;\n\tunsigned long rpm;\n\tstruct env *p = dev_get_drvdata(dev);\n\tint period;\n\tu8 val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &rpm);\n\tif (err)\n\t\treturn err;\n\n\tif (!rpm)\n\t\treturn -EINVAL;\n\n\tperiod = FAN_RPM_TO_PERIOD(rpm);\n\tval = period >> 8;\n\tenv_write(p, IREG_FAN0 + fan_nr, val);\n\n\treturn count;\n}\n\nstatic ssize_t show_fan_fault(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tint fan_nr = to_sensor_dev_attr(attr)->index;\n\tstruct env *p = dev_get_drvdata(dev);\n\tu8 val = env_read(p, IREG_FAN_STAT);\n\treturn sprintf(buf, \"%d\\n\", (val & (1 << fan_nr)) ? 1 : 0);\n}\n\n#define fan(index)\t\t\t\t\t\t\t\\\nstatic SENSOR_DEVICE_ATTR(fan##index##_speed, S_IRUGO | S_IWUSR,\t\\\n\t\tshow_fan_speed, set_fan_speed, index);\t\t\t\\\nstatic SENSOR_DEVICE_ATTR(fan##index##_fault, S_IRUGO,\t\t\t\\\n\t\tshow_fan_fault, NULL, index)\n\nfan(0);\nfan(1);\nfan(2);\nfan(3);\nfan(4);\n\nstatic SENSOR_DEVICE_ATTR(psu_fan_fault, S_IRUGO, show_fan_fault, NULL, 6);\n\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tint temp_nr = to_sensor_dev_attr(attr)->index;\n\tstruct env *p = dev_get_drvdata(dev);\n\ts8 val;\n\n\tval = env_read(p, IREG_LCL_TEMP + temp_nr);\n\treturn sprintf(buf, \"%d\\n\", ((int) val) - 64);\n}\n\nstatic SENSOR_DEVICE_ATTR(adt7462_local_temp, S_IRUGO, show_temp, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(cpu0_temp, S_IRUGO, show_temp, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(cpu1_temp, S_IRUGO, show_temp, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(motherboard_temp, S_IRUGO, show_temp, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(lm95221_local_temp, S_IRUGO, show_temp, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(fire_temp, S_IRUGO, show_temp, NULL, 5);\nstatic SENSOR_DEVICE_ATTR(lsi1064_local_temp, S_IRUGO, show_temp, NULL, 6);\nstatic SENSOR_DEVICE_ATTR(front_panel_temp, S_IRUGO, show_temp, NULL, 7);\nstatic SENSOR_DEVICE_ATTR(psu_temp, S_IRUGO, show_temp, NULL, 13);\n\nstatic ssize_t show_stat_bit(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tint index = to_sensor_dev_attr(attr)->index;\n\tstruct env *p = dev_get_drvdata(dev);\n\tu8 val;\n\n\tval = readb(p->regs + REG_STAT);\n\treturn sprintf(buf, \"%d\\n\", (val & (1 << index)) ? 1 : 0);\n}\n\nstatic SENSOR_DEVICE_ATTR(fan_failure, S_IRUGO, show_stat_bit, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(env_bus_busy, S_IRUGO, show_stat_bit, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(env_data_stale, S_IRUGO, show_stat_bit, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(tpm_self_test_passed, S_IRUGO, show_stat_bit, NULL,\n\t\t\t  3);\n\nstatic ssize_t show_fwver(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct env *p = dev_get_drvdata(dev);\n\tu8 val;\n\n\tval = readb(p->regs + REG_STAT);\n\treturn sprintf(buf, \"%d\\n\", val >> 4);\n}\n\nstatic SENSOR_DEVICE_ATTR(firmware_version, S_IRUGO, show_fwver, NULL, 0);\n\nstatic ssize_t show_name(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"ultra45\\n\");\n}\n\nstatic SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, 0);\n\nstatic struct attribute *env_attributes[] = {\n\t&sensor_dev_attr_fan0_speed.dev_attr.attr,\n\t&sensor_dev_attr_fan0_fault.dev_attr.attr,\n\t&sensor_dev_attr_fan1_speed.dev_attr.attr,\n\t&sensor_dev_attr_fan1_fault.dev_attr.attr,\n\t&sensor_dev_attr_fan2_speed.dev_attr.attr,\n\t&sensor_dev_attr_fan2_fault.dev_attr.attr,\n\t&sensor_dev_attr_fan3_speed.dev_attr.attr,\n\t&sensor_dev_attr_fan3_fault.dev_attr.attr,\n\t&sensor_dev_attr_fan4_speed.dev_attr.attr,\n\t&sensor_dev_attr_fan4_fault.dev_attr.attr,\n\t&sensor_dev_attr_psu_fan_fault.dev_attr.attr,\n\t&sensor_dev_attr_adt7462_local_temp.dev_attr.attr,\n\t&sensor_dev_attr_cpu0_temp.dev_attr.attr,\n\t&sensor_dev_attr_cpu1_temp.dev_attr.attr,\n\t&sensor_dev_attr_motherboard_temp.dev_attr.attr,\n\t&sensor_dev_attr_lm95221_local_temp.dev_attr.attr,\n\t&sensor_dev_attr_fire_temp.dev_attr.attr,\n\t&sensor_dev_attr_lsi1064_local_temp.dev_attr.attr,\n\t&sensor_dev_attr_front_panel_temp.dev_attr.attr,\n\t&sensor_dev_attr_psu_temp.dev_attr.attr,\n\t&sensor_dev_attr_fan_failure.dev_attr.attr,\n\t&sensor_dev_attr_env_bus_busy.dev_attr.attr,\n\t&sensor_dev_attr_env_data_stale.dev_attr.attr,\n\t&sensor_dev_attr_tpm_self_test_passed.dev_attr.attr,\n\t&sensor_dev_attr_firmware_version.dev_attr.attr,\n\t&sensor_dev_attr_name.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group env_group = {\n\t.attrs = env_attributes,\n};\n\nstatic int env_probe(struct platform_device *op)\n{\n\tstruct env *p = devm_kzalloc(&op->dev, sizeof(*p), GFP_KERNEL);\n\tint err = -ENOMEM;\n\n\tif (!p)\n\t\tgoto out;\n\n\tspin_lock_init(&p->lock);\n\n\tp->regs = of_ioremap(&op->resource[0], 0, REG_SIZE, \"pic16f747\");\n\tif (!p->regs)\n\t\tgoto out;\n\n\terr = sysfs_create_group(&op->dev.kobj, &env_group);\n\tif (err)\n\t\tgoto out_iounmap;\n\n\tp->hwmon_dev = hwmon_device_register(&op->dev);\n\tif (IS_ERR(p->hwmon_dev)) {\n\t\terr = PTR_ERR(p->hwmon_dev);\n\t\tgoto out_sysfs_remove_group;\n\t}\n\n\tplatform_set_drvdata(op, p);\n\terr = 0;\n\nout:\n\treturn err;\n\nout_sysfs_remove_group:\n\tsysfs_remove_group(&op->dev.kobj, &env_group);\n\nout_iounmap:\n\tof_iounmap(&op->resource[0], p->regs, REG_SIZE);\n\n\tgoto out;\n}\n\nstatic int env_remove(struct platform_device *op)\n{\n\tstruct env *p = platform_get_drvdata(op);\n\n\tif (p) {\n\t\tsysfs_remove_group(&op->dev.kobj, &env_group);\n\t\thwmon_device_unregister(p->hwmon_dev);\n\t\tof_iounmap(&op->resource[0], p->regs, REG_SIZE);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id env_match[] = {\n\t{\n\t\t.name = \"env-monitor\",\n\t\t.compatible = \"SUNW,ebus-pic16f747-env\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, env_match);\n\nstatic struct platform_driver env_driver = {\n\t.driver = {\n\t\t.name = \"ultra45_env\",\n\t\t.of_match_table = env_match,\n\t},\n\t.probe\t\t= env_probe,\n\t.remove\t\t= env_remove,\n};\n\nmodule_platform_driver(env_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}