{
  "module_name": "max16065.c",
  "hash_id": "24856a24857c1b86a446f4dfe6b52cc2f573bffd38524ffe091b643217ea835b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max16065.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n\nenum chips { max16065, max16066, max16067, max16068, max16070, max16071 };\n\n \n#define MAX16065_ADC(x)\t\t((x) * 2)\n\n#define MAX16065_CURR_SENSE\t0x18\n#define MAX16065_CSP_ADC\t0x19\n#define MAX16065_FAULT(x)\t(0x1b + (x))\n#define MAX16065_SCALE(x)\t(0x43 + (x))\n#define MAX16065_CURR_CONTROL\t0x47\n#define MAX16065_LIMIT(l, x)\t(0x48 + (l) + (x) * 3)\t \n\n#define MAX16065_SW_ENABLE\t0x73\n\n#define MAX16065_WARNING_OV\t(1 << 3)  \n\n#define MAX16065_CURR_ENABLE\t(1 << 0)\n\n#define MAX16065_NUM_LIMIT\t3\n#define MAX16065_NUM_ADC\t12\t \n\nstatic const int max16065_num_adc[] = {\n\t[max16065] = 12,\n\t[max16066] = 8,\n\t[max16067] = 6,\n\t[max16068] = 6,\n\t[max16070] = 12,\n\t[max16071] = 8,\n};\n\nstatic const bool max16065_have_secondary[] = {\n\t[max16065] = true,\n\t[max16066] = true,\n\t[max16067] = false,\n\t[max16068] = false,\n\t[max16070] = true,\n\t[max16071] = true,\n};\n\nstatic const bool max16065_have_current[] = {\n\t[max16065] = true,\n\t[max16066] = true,\n\t[max16067] = false,\n\t[max16068] = false,\n\t[max16070] = true,\n\t[max16071] = true,\n};\n\nstruct max16065_data {\n\tenum chips type;\n\tstruct i2c_client *client;\n\tconst struct attribute_group *groups[4];\n\tstruct mutex update_lock;\n\tbool valid;\n\tunsigned long last_updated;  \n\tint num_adc;\n\tbool have_current;\n\tint curr_gain;\n\t \n\tint limit[MAX16065_NUM_LIMIT][MAX16065_NUM_ADC];\n\tint range[MAX16065_NUM_ADC + 1]; \n\tint adc[MAX16065_NUM_ADC + 1];\t \n\tint curr_sense;\n\tint fault[2];\n};\n\nstatic const int max16065_adc_range[] = { 5560, 2780, 1390, 0 };\nstatic const int max16065_csp_adc_range[] = { 7000, 14000 };\n\n \nstatic inline int ADC_TO_MV(int adc, int range)\n{\n\treturn (adc * range) / 1024;\n}\n\n \nstatic inline int LIMIT_TO_MV(int limit, int range)\n{\n\treturn limit * range / 256;\n}\n\nstatic inline int MV_TO_LIMIT(int mv, int range)\n{\n\treturn clamp_val(DIV_ROUND_CLOSEST(mv * 256, range), 0, 255);\n}\n\nstatic inline int ADC_TO_CURR(int adc, int gain)\n{\n\treturn adc * 1400000 / (gain * 255);\n}\n\n \nstatic int max16065_read_adc(struct i2c_client *client, int reg)\n{\n\tint rv;\n\n\trv = i2c_smbus_read_word_swapped(client, reg);\n\tif (unlikely(rv < 0))\n\t\treturn rv;\n\treturn rv >> 6;\n}\n\nstatic struct max16065_data *max16065_update_device(struct device *dev)\n{\n\tstruct max16065_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tmutex_lock(&data->update_lock);\n\tif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\n\t\tint i;\n\n\t\tfor (i = 0; i < data->num_adc; i++)\n\t\t\tdata->adc[i]\n\t\t\t  = max16065_read_adc(client, MAX16065_ADC(i));\n\n\t\tif (data->have_current) {\n\t\t\tdata->adc[MAX16065_NUM_ADC]\n\t\t\t  = max16065_read_adc(client, MAX16065_CSP_ADC);\n\t\t\tdata->curr_sense\n\t\t\t  = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t     MAX16065_CURR_SENSE);\n\t\t}\n\n\t\tfor (i = 0; i < DIV_ROUND_UP(data->num_adc, 8); i++)\n\t\t\tdata->fault[i]\n\t\t\t  = i2c_smbus_read_byte_data(client, MAX16065_FAULT(i));\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n}\n\nstatic ssize_t max16065_alarm_show(struct device *dev,\n\t\t\t\t   struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr2 = to_sensor_dev_attr_2(da);\n\tstruct max16065_data *data = max16065_update_device(dev);\n\tint val = data->fault[attr2->nr];\n\n\tif (val < 0)\n\t\treturn val;\n\n\tval &= (1 << attr2->index);\n\tif (val)\n\t\ti2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t  MAX16065_FAULT(attr2->nr), val);\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!val);\n}\n\nstatic ssize_t max16065_input_show(struct device *dev,\n\t\t\t\t   struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct max16065_data *data = max16065_update_device(dev);\n\tint adc = data->adc[attr->index];\n\n\tif (unlikely(adc < 0))\n\t\treturn adc;\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  ADC_TO_MV(adc, data->range[attr->index]));\n}\n\nstatic ssize_t max16065_current_show(struct device *dev,\n\t\t\t\t     struct device_attribute *da, char *buf)\n{\n\tstruct max16065_data *data = max16065_update_device(dev);\n\n\tif (unlikely(data->curr_sense < 0))\n\t\treturn data->curr_sense;\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  ADC_TO_CURR(data->curr_sense, data->curr_gain));\n}\n\nstatic ssize_t max16065_limit_store(struct device *dev,\n\t\t\t\t    struct device_attribute *da,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *attr2 = to_sensor_dev_attr_2(da);\n\tstruct max16065_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\tint limit;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlimit = MV_TO_LIMIT(val, data->range[attr2->index]);\n\n\tmutex_lock(&data->update_lock);\n\tdata->limit[attr2->nr][attr2->index]\n\t  = LIMIT_TO_MV(limit, data->range[attr2->index]);\n\ti2c_smbus_write_byte_data(data->client,\n\t\t\t\t  MAX16065_LIMIT(attr2->nr, attr2->index),\n\t\t\t\t  limit);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t max16065_limit_show(struct device *dev,\n\t\t\t\t   struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr2 = to_sensor_dev_attr_2(da);\n\tstruct max16065_data *data = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  data->limit[attr2->nr][attr2->index]);\n}\n\n \n\n \nstatic SENSOR_DEVICE_ATTR_RO(in0_input, max16065_input, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, max16065_input, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, max16065_input, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, max16065_input, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, max16065_input, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in5_input, max16065_input, 5);\nstatic SENSOR_DEVICE_ATTR_RO(in6_input, max16065_input, 6);\nstatic SENSOR_DEVICE_ATTR_RO(in7_input, max16065_input, 7);\nstatic SENSOR_DEVICE_ATTR_RO(in8_input, max16065_input, 8);\nstatic SENSOR_DEVICE_ATTR_RO(in9_input, max16065_input, 9);\nstatic SENSOR_DEVICE_ATTR_RO(in10_input, max16065_input, 10);\nstatic SENSOR_DEVICE_ATTR_RO(in11_input, max16065_input, 11);\nstatic SENSOR_DEVICE_ATTR_RO(in12_input, max16065_input, 12);\n\n \nstatic SENSOR_DEVICE_ATTR_2_RW(in0_lcrit, max16065_limit, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in1_lcrit, max16065_limit, 2, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_lcrit, max16065_limit, 2, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_lcrit, max16065_limit, 2, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_lcrit, max16065_limit, 2, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(in5_lcrit, max16065_limit, 2, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(in6_lcrit, max16065_limit, 2, 6);\nstatic SENSOR_DEVICE_ATTR_2_RW(in7_lcrit, max16065_limit, 2, 7);\nstatic SENSOR_DEVICE_ATTR_2_RW(in8_lcrit, max16065_limit, 2, 8);\nstatic SENSOR_DEVICE_ATTR_2_RW(in9_lcrit, max16065_limit, 2, 9);\nstatic SENSOR_DEVICE_ATTR_2_RW(in10_lcrit, max16065_limit, 2, 10);\nstatic SENSOR_DEVICE_ATTR_2_RW(in11_lcrit, max16065_limit, 2, 11);\n\n \nstatic SENSOR_DEVICE_ATTR_2_RW(in0_crit, max16065_limit, 1, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in1_crit, max16065_limit, 1, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_crit, max16065_limit, 1, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_crit, max16065_limit, 1, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_crit, max16065_limit, 1, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(in5_crit, max16065_limit, 1, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(in6_crit, max16065_limit, 1, 6);\nstatic SENSOR_DEVICE_ATTR_2_RW(in7_crit, max16065_limit, 1, 7);\nstatic SENSOR_DEVICE_ATTR_2_RW(in8_crit, max16065_limit, 1, 8);\nstatic SENSOR_DEVICE_ATTR_2_RW(in9_crit, max16065_limit, 1, 9);\nstatic SENSOR_DEVICE_ATTR_2_RW(in10_crit, max16065_limit, 1, 10);\nstatic SENSOR_DEVICE_ATTR_2_RW(in11_crit, max16065_limit, 1, 11);\n\n \nstatic SENSOR_DEVICE_ATTR_2_RW(in0_min, max16065_limit, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in1_min, max16065_limit, 0, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_min, max16065_limit, 0, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_min, max16065_limit, 0, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_min, max16065_limit, 0, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(in5_min, max16065_limit, 0, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(in6_min, max16065_limit, 0, 6);\nstatic SENSOR_DEVICE_ATTR_2_RW(in7_min, max16065_limit, 0, 7);\nstatic SENSOR_DEVICE_ATTR_2_RW(in8_min, max16065_limit, 0, 8);\nstatic SENSOR_DEVICE_ATTR_2_RW(in9_min, max16065_limit, 0, 9);\nstatic SENSOR_DEVICE_ATTR_2_RW(in10_min, max16065_limit, 0, 10);\nstatic SENSOR_DEVICE_ATTR_2_RW(in11_min, max16065_limit, 0, 11);\n\n \nstatic SENSOR_DEVICE_ATTR_2_RW(in0_max, max16065_limit, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in1_max, max16065_limit, 0, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_max, max16065_limit, 0, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_max, max16065_limit, 0, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_max, max16065_limit, 0, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(in5_max, max16065_limit, 0, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(in6_max, max16065_limit, 0, 6);\nstatic SENSOR_DEVICE_ATTR_2_RW(in7_max, max16065_limit, 0, 7);\nstatic SENSOR_DEVICE_ATTR_2_RW(in8_max, max16065_limit, 0, 8);\nstatic SENSOR_DEVICE_ATTR_2_RW(in9_max, max16065_limit, 0, 9);\nstatic SENSOR_DEVICE_ATTR_2_RW(in10_max, max16065_limit, 0, 10);\nstatic SENSOR_DEVICE_ATTR_2_RW(in11_max, max16065_limit, 0, 11);\n\n \nstatic SENSOR_DEVICE_ATTR_2_RO(in0_alarm, max16065_alarm, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(in1_alarm, max16065_alarm, 0, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(in2_alarm, max16065_alarm, 0, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(in3_alarm, max16065_alarm, 0, 3);\nstatic SENSOR_DEVICE_ATTR_2_RO(in4_alarm, max16065_alarm, 0, 4);\nstatic SENSOR_DEVICE_ATTR_2_RO(in5_alarm, max16065_alarm, 0, 5);\nstatic SENSOR_DEVICE_ATTR_2_RO(in6_alarm, max16065_alarm, 0, 6);\nstatic SENSOR_DEVICE_ATTR_2_RO(in7_alarm, max16065_alarm, 0, 7);\nstatic SENSOR_DEVICE_ATTR_2_RO(in8_alarm, max16065_alarm, 1, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(in9_alarm, max16065_alarm, 1, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(in10_alarm, max16065_alarm, 1, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(in11_alarm, max16065_alarm, 1, 3);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(curr1_input, max16065_current, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(curr1_alarm, max16065_alarm, 1, 4);\n\n \nstatic struct attribute *max16065_basic_attributes[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in0_crit.dev_attr.attr,\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in1_crit.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in2_crit.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in3_crit.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in4_crit.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in5_crit.dev_attr.attr,\n\t&sensor_dev_attr_in5_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in6_crit.dev_attr.attr,\n\t&sensor_dev_attr_in6_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in7_crit.dev_attr.attr,\n\t&sensor_dev_attr_in7_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in8_input.dev_attr.attr,\n\t&sensor_dev_attr_in8_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in8_crit.dev_attr.attr,\n\t&sensor_dev_attr_in8_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in9_input.dev_attr.attr,\n\t&sensor_dev_attr_in9_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in9_crit.dev_attr.attr,\n\t&sensor_dev_attr_in9_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in10_input.dev_attr.attr,\n\t&sensor_dev_attr_in10_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in10_crit.dev_attr.attr,\n\t&sensor_dev_attr_in10_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in11_input.dev_attr.attr,\n\t&sensor_dev_attr_in11_lcrit.dev_attr.attr,\n\t&sensor_dev_attr_in11_crit.dev_attr.attr,\n\t&sensor_dev_attr_in11_alarm.dev_attr.attr,\n\n\tNULL\n};\n\nstatic struct attribute *max16065_current_attributes[] = {\n\t&sensor_dev_attr_in12_input.dev_attr.attr,\n\t&sensor_dev_attr_curr1_input.dev_attr.attr,\n\t&sensor_dev_attr_curr1_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic struct attribute *max16065_min_attributes[] = {\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in6_min.dev_attr.attr,\n\t&sensor_dev_attr_in7_min.dev_attr.attr,\n\t&sensor_dev_attr_in8_min.dev_attr.attr,\n\t&sensor_dev_attr_in9_min.dev_attr.attr,\n\t&sensor_dev_attr_in10_min.dev_attr.attr,\n\t&sensor_dev_attr_in11_min.dev_attr.attr,\n\tNULL\n};\n\nstatic struct attribute *max16065_max_attributes[] = {\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\t&sensor_dev_attr_in6_max.dev_attr.attr,\n\t&sensor_dev_attr_in7_max.dev_attr.attr,\n\t&sensor_dev_attr_in8_max.dev_attr.attr,\n\t&sensor_dev_attr_in9_max.dev_attr.attr,\n\t&sensor_dev_attr_in10_max.dev_attr.attr,\n\t&sensor_dev_attr_in11_max.dev_attr.attr,\n\tNULL\n};\n\nstatic umode_t max16065_basic_is_visible(struct kobject *kobj,\n\t\t\t\t\t struct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct max16065_data *data = dev_get_drvdata(dev);\n\tint index = n / 4;\n\n\tif (index >= data->num_adc || !data->range[index])\n\t\treturn 0;\n\treturn a->mode;\n}\n\nstatic umode_t max16065_secondary_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *a, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct max16065_data *data = dev_get_drvdata(dev);\n\n\tif (index >= data->num_adc)\n\t\treturn 0;\n\treturn a->mode;\n}\n\nstatic const struct attribute_group max16065_basic_group = {\n\t.attrs = max16065_basic_attributes,\n\t.is_visible = max16065_basic_is_visible,\n};\n\nstatic const struct attribute_group max16065_current_group = {\n\t.attrs = max16065_current_attributes,\n};\n\nstatic const struct attribute_group max16065_min_group = {\n\t.attrs = max16065_min_attributes,\n\t.is_visible = max16065_secondary_is_visible,\n};\n\nstatic const struct attribute_group max16065_max_group = {\n\t.attrs = max16065_max_attributes,\n\t.is_visible = max16065_secondary_is_visible,\n};\n\nstatic const struct i2c_device_id max16065_id[];\n\nstatic int max16065_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct max16065_data *data;\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tint i, j, val;\n\tbool have_secondary;\t\t \n\tbool secondary_is_max = false;\t \n\tint groups = 0;\n\tconst struct i2c_device_id *id = i2c_match_id(max16065_id, client);\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_READ_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\tdata->num_adc = max16065_num_adc[id->driver_data];\n\tdata->have_current = max16065_have_current[id->driver_data];\n\thave_secondary = max16065_have_secondary[id->driver_data];\n\n\tif (have_secondary) {\n\t\tval = i2c_smbus_read_byte_data(client, MAX16065_SW_ENABLE);\n\t\tif (unlikely(val < 0))\n\t\t\treturn val;\n\t\tsecondary_is_max = val & MAX16065_WARNING_OV;\n\t}\n\n\t \n\tfor (i = 0; i < DIV_ROUND_UP(data->num_adc, 4); i++) {\n\t\tval = i2c_smbus_read_byte_data(client, MAX16065_SCALE(i));\n\t\tif (unlikely(val < 0))\n\t\t\treturn val;\n\t\tfor (j = 0; j < 4 && i * 4 + j < data->num_adc; j++) {\n\t\t\tdata->range[i * 4 + j] =\n\t\t\t  max16065_adc_range[(val >> (j * 2)) & 0x3];\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < MAX16065_NUM_LIMIT; i++) {\n\t\tif (i == 0 && !have_secondary)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < data->num_adc; j++) {\n\t\t\tval = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t       MAX16065_LIMIT(i, j));\n\t\t\tif (unlikely(val < 0))\n\t\t\t\treturn val;\n\t\t\tdata->limit[i][j] = LIMIT_TO_MV(val, data->range[j]);\n\t\t}\n\t}\n\n\t \n\tdata->groups[groups++] = &max16065_basic_group;\n\tif (have_secondary)\n\t\tdata->groups[groups++] = secondary_is_max ?\n\t\t\t&max16065_max_group : &max16065_min_group;\n\n\tif (data->have_current) {\n\t\tval = i2c_smbus_read_byte_data(client, MAX16065_CURR_CONTROL);\n\t\tif (unlikely(val < 0))\n\t\t\treturn val;\n\t\tif (val & MAX16065_CURR_ENABLE) {\n\t\t\t \n\t\t\tdata->curr_gain = 6 << ((val >> 2) & 0x03);\n\t\t\tdata->range[MAX16065_NUM_ADC]\n\t\t\t  = max16065_csp_adc_range[(val >> 1) & 0x01];\n\t\t\tdata->groups[groups++] = &max16065_current_group;\n\t\t} else {\n\t\t\tdata->have_current = false;\n\t\t}\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, data->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id max16065_id[] = {\n\t{ \"max16065\", max16065 },\n\t{ \"max16066\", max16066 },\n\t{ \"max16067\", max16067 },\n\t{ \"max16068\", max16068 },\n\t{ \"max16070\", max16070 },\n\t{ \"max16071\", max16071 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, max16065_id);\n\n \nstatic struct i2c_driver max16065_driver = {\n\t.driver = {\n\t\t.name = \"max16065\",\n\t},\n\t.probe = max16065_probe,\n\t.id_table = max16065_id,\n};\n\nmodule_i2c_driver(max16065_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"MAX16065 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}