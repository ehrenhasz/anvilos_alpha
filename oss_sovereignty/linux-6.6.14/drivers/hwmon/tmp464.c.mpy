{
  "module_name": "tmp464.c",
  "hash_id": "b55c7c99e92f8a695c976de1a28b4614a2a35c9c522dfe3980966e6f99e46b72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/tmp464.c",
  "human_readable_source": "\n\n \n\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x48, 0x49, 0x4a, 0x4b, I2C_CLIENT_END };\n\n#define TMP464_NUM_CHANNELS\t\t5\t \n#define TMP468_NUM_CHANNELS\t\t9\t \n\n#define MAX_CHANNELS\t\t\t9\n\n#define TMP464_TEMP_REG(channel)\t(channel)\n#define TMP464_TEMP_OFFSET_REG(channel)\t(0x40 + ((channel) - 1) * 8)\n#define TMP464_N_FACTOR_REG(channel)\t(0x41 + ((channel) - 1) * 8)\n\nstatic const u8 TMP464_THERM_LIMIT[MAX_CHANNELS] = {\n\t0x39, 0x42, 0x4A, 0x52, 0x5A, 0x62, 0x6a, 0x72, 0x7a };\nstatic const u8 TMP464_THERM2_LIMIT[MAX_CHANNELS] = {\n\t0x3A, 0x43, 0x4B, 0x53, 0x5B, 0x63, 0x6b, 0x73, 0x7b };\n\n#define TMP464_THERM_STATUS_REG\t\t\t0x21\n#define TMP464_THERM2_STATUS_REG\t\t0x22\n#define TMP464_REMOTE_OPEN_REG\t\t\t0x23\n#define TMP464_CONFIG_REG\t\t\t0x30\n#define TMP464_TEMP_HYST_REG\t\t\t0x38\n#define TMP464_LOCK_REG\t\t\t\t0xc4\n\n \n#define TMP464_MANUFACTURER_ID_REG\t\t0xFE\n#define TMP464_DEVICE_ID_REG\t\t\t0xFF\n\n \n#define TMP464_CONFIG_SHUTDOWN\t\t\tBIT(5)\n#define TMP464_CONFIG_RANGE\t\t\t0x04\n#define TMP464_CONFIG_REG_REN(x)\t\t(BIT(7 + (x)))\n#define TMP464_CONFIG_REG_REN_MASK\t\tGENMASK(15, 7)\n#define TMP464_CONFIG_CONVERSION_RATE_B0\t2\n#define TMP464_CONFIG_CONVERSION_RATE_B2\t4\n#define TMP464_CONFIG_CONVERSION_RATE_MASK      GENMASK(TMP464_CONFIG_CONVERSION_RATE_B2, \\\n\t\t\t\t\t\t\tTMP464_CONFIG_CONVERSION_RATE_B0)\n\n#define TMP464_UNLOCK_VAL\t\t\t0xeb19\n#define TMP464_LOCK_VAL\t\t\t\t0x5ca6\n#define TMP464_LOCKED\t\t\t\t0x8000\n\n \n#define TMP464_MANUFACTURER_ID\t\t\t0x5449\n#define TMP464_DEVICE_ID\t\t\t0x1468\n#define TMP468_DEVICE_ID\t\t\t0x0468\n\nstatic const struct i2c_device_id tmp464_id[] = {\n\t{ \"tmp464\", TMP464_NUM_CHANNELS },\n\t{ \"tmp468\", TMP468_NUM_CHANNELS },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tmp464_id);\n\nstatic const struct of_device_id __maybe_unused tmp464_of_match[] = {\n\t{\n\t\t.compatible = \"ti,tmp464\",\n\t\t.data = (void *)TMP464_NUM_CHANNELS\n\t},\n\t{\n\t\t.compatible = \"ti,tmp468\",\n\t\t.data = (void *)TMP468_NUM_CHANNELS\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tmp464_of_match);\n\nstruct tmp464_channel {\n\tconst char *label;\n\tbool enabled;\n};\n\nstruct tmp464_data {\n\tstruct regmap *regmap;\n\tstruct mutex update_lock;\n\tint channels;\n\ts16 config_orig;\n\tu16 open_reg;\n\tunsigned long last_updated;\n\tbool valid;\n\tint update_interval;\n\tstruct tmp464_channel channel[MAX_CHANNELS];\n};\n\nstatic int temp_from_reg(s16 reg)\n{\n\treturn DIV_ROUND_CLOSEST((reg >> 3) * 625, 10);\n}\n\nstatic s16 temp_to_limit_reg(long temp)\n{\n\treturn DIV_ROUND_CLOSEST(temp, 500) << 6;\n}\n\nstatic s16 temp_to_offset_reg(long temp)\n{\n\treturn DIV_ROUND_CLOSEST(temp * 10, 625) << 3;\n}\n\nstatic int tmp464_enable_channels(struct tmp464_data *data)\n{\n\tstruct regmap *regmap = data->regmap;\n\tu16 enable = 0;\n\tint i;\n\n\tfor (i = 0; i < data->channels; i++)\n\t\tif (data->channel[i].enabled)\n\t\t\tenable |= TMP464_CONFIG_REG_REN(i);\n\n\treturn regmap_update_bits(regmap, TMP464_CONFIG_REG, TMP464_CONFIG_REG_REN_MASK, enable);\n}\n\nstatic int tmp464_chip_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct tmp464_data *data = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\t*val = data->update_interval;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int tmp464_temp_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct tmp464_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int regval, regval2;\n\tint err = 0;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (attr) {\n\tcase hwmon_temp_max_alarm:\n\t\terr = regmap_read(regmap, TMP464_THERM_STATUS_REG, &regval);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\t*val = !!(regval & BIT(channel + 7));\n\t\tbreak;\n\tcase hwmon_temp_crit_alarm:\n\t\terr = regmap_read(regmap, TMP464_THERM2_STATUS_REG, &regval);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\t*val = !!(regval & BIT(channel + 7));\n\t\tbreak;\n\tcase hwmon_temp_fault:\n\t\t \n\t\tif (!data->valid || time_after(jiffies, data->last_updated +\n\t\t\t\t\t       msecs_to_jiffies(data->update_interval))) {\n\t\t\terr = regmap_read(regmap, TMP464_REMOTE_OPEN_REG, &regval);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\tdata->open_reg = regval;\n\t\t\tdata->last_updated = jiffies;\n\t\t\tdata->valid = true;\n\t\t}\n\t\t*val = !!(data->open_reg & BIT(channel + 7));\n\t\tbreak;\n\tcase hwmon_temp_max_hyst:\n\t\terr = regmap_read(regmap, TMP464_THERM_LIMIT[channel], &regval);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\terr = regmap_read(regmap, TMP464_TEMP_HYST_REG, &regval2);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tregval -= regval2;\n\t\t*val = temp_from_reg(regval);\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\terr = regmap_read(regmap, TMP464_THERM_LIMIT[channel], &regval);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\t*val = temp_from_reg(regval);\n\t\tbreak;\n\tcase hwmon_temp_crit_hyst:\n\t\terr = regmap_read(regmap, TMP464_THERM2_LIMIT[channel], &regval);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\terr = regmap_read(regmap, TMP464_TEMP_HYST_REG, &regval2);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tregval -= regval2;\n\t\t*val = temp_from_reg(regval);\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\terr = regmap_read(regmap, TMP464_THERM2_LIMIT[channel], &regval);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\t*val = temp_from_reg(regval);\n\t\tbreak;\n\tcase hwmon_temp_offset:\n\t\terr = regmap_read(regmap, TMP464_TEMP_OFFSET_REG(channel), &regval);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\t*val = temp_from_reg(regval);\n\t\tbreak;\n\tcase hwmon_temp_input:\n\t\tif (!data->channel[channel].enabled) {\n\t\t\terr = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\t\terr = regmap_read(regmap, TMP464_TEMP_REG(channel), &regval);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\t*val = temp_from_reg(regval);\n\t\tbreak;\n\tcase hwmon_temp_enable:\n\t\t*val = data->channel[channel].enabled;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn err;\n}\n\nstatic int tmp464_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn tmp464_chip_read(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn tmp464_temp_read(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int tmp464_read_string(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel, const char **str)\n{\n\tstruct tmp464_data *data = dev_get_drvdata(dev);\n\n\t*str = data->channel[channel].label;\n\n\treturn 0;\n}\n\nstatic int tmp464_set_convrate(struct tmp464_data *data, long interval)\n{\n\tint rate;\n\n\t \n\tinterval = clamp_val(interval, 125, 16000);\n\trate = 7 - __fls(interval * 4 / (125 * 3));\n\tdata->update_interval = 125 << (7 - rate);\n\n\treturn regmap_update_bits(data->regmap, TMP464_CONFIG_REG,\n\t\t\t\t  TMP464_CONFIG_CONVERSION_RATE_MASK,\n\t\t\t\t  rate << TMP464_CONFIG_CONVERSION_RATE_B0);\n}\n\nstatic int tmp464_chip_write(struct tmp464_data *data, u32 attr, int channel, long val)\n{\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\treturn tmp464_set_convrate(data, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int tmp464_temp_write(struct tmp464_data *data, u32 attr, int channel, long val)\n{\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int regval;\n\tint err = 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_max_hyst:\n\t\terr = regmap_read(regmap, TMP464_THERM_LIMIT[0], &regval);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tval = clamp_val(val, -256000, 256000);\t \n\t\tval = clamp_val(temp_from_reg(regval) - val, 0, 255000);\n\t\terr = regmap_write(regmap, TMP464_TEMP_HYST_REG,\n\t\t\t\t   DIV_ROUND_CLOSEST(val, 1000) << 7);\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\tval = temp_to_limit_reg(clamp_val(val, -255000, 255500));\n\t\terr = regmap_write(regmap, TMP464_THERM_LIMIT[channel], val);\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\tval = temp_to_limit_reg(clamp_val(val, -255000, 255500));\n\t\terr = regmap_write(regmap, TMP464_THERM2_LIMIT[channel], val);\n\t\tbreak;\n\tcase hwmon_temp_offset:\n\t\tval = temp_to_offset_reg(clamp_val(val, -128000, 127937));\n\t\terr = regmap_write(regmap, TMP464_TEMP_OFFSET_REG(channel), val);\n\t\tbreak;\n\tcase hwmon_temp_enable:\n\t\tdata->channel[channel].enabled = !!val;\n\t\terr = tmp464_enable_channels(data);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int tmp464_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long val)\n{\n\tstruct tmp464_data *data = dev_get_drvdata(dev);\n\tint err;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\terr = tmp464_chip_write(data, attr, channel, val);\n\t\tbreak;\n\tcase hwmon_temp:\n\t\terr = tmp464_temp_write(data, attr, channel, val);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn err;\n}\n\nstatic umode_t tmp464_is_visible(const void *_data, enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel)\n{\n\tconst struct tmp464_data *data = _data;\n\n\tif (channel >= data->channels)\n\t\treturn 0;\n\n\tif (type == hwmon_chip) {\n\t\tif (attr == hwmon_chip_update_interval)\n\t\t\treturn 0644;\n\t\treturn 0;\n\t}\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_max_alarm:\n\tcase hwmon_temp_crit_alarm:\n\tcase hwmon_temp_crit_hyst:\n\t\treturn 0444;\n\tcase hwmon_temp_enable:\n\tcase hwmon_temp_max:\n\tcase hwmon_temp_crit:\n\t\treturn 0644;\n\tcase hwmon_temp_max_hyst:\n\t\tif (!channel)\n\t\t\treturn 0644;\n\t\treturn 0444;\n\tcase hwmon_temp_label:\n\t\tif (data->channel[channel].label)\n\t\t\treturn 0444;\n\t\treturn 0;\n\tcase hwmon_temp_fault:\n\t\tif (channel)\n\t\t\treturn 0444;\n\t\treturn 0;\n\tcase hwmon_temp_offset:\n\t\tif (channel)\n\t\t\treturn 0644;\n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void tmp464_restore_lock(void *regmap)\n{\n\tregmap_write(regmap, TMP464_LOCK_REG, TMP464_LOCK_VAL);\n}\n\nstatic void tmp464_restore_config(void *_data)\n{\n\tstruct tmp464_data *data = _data;\n\n\tregmap_write(data->regmap, TMP464_CONFIG_REG, data->config_orig);\n}\n\nstatic int tmp464_init_client(struct device *dev, struct tmp464_data *data)\n{\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int regval;\n\tint err;\n\n\terr = regmap_read(regmap, TMP464_LOCK_REG, &regval);\n\tif (err)\n\t\treturn err;\n\tif (regval == TMP464_LOCKED) {\n\t\t \n\t\terr = regmap_write(regmap, TMP464_LOCK_REG, TMP464_UNLOCK_VAL);\n\t\tif (err)\n\t\t\treturn err;\n\t\t \n\t\terr = devm_add_action_or_reset(dev, tmp464_restore_lock, regmap);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = regmap_read(regmap, TMP464_CONFIG_REG, &regval);\n\tif (err)\n\t\treturn err;\n\tdata->config_orig = regval;\n\terr = devm_add_action_or_reset(dev, tmp464_restore_config, data);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_update_bits(regmap, TMP464_CONFIG_REG,\n\t\t\t\t TMP464_CONFIG_CONVERSION_RATE_MASK | TMP464_CONFIG_SHUTDOWN,\n\t\t\t\t BIT(TMP464_CONFIG_CONVERSION_RATE_B0) |\n\t\t\t\t BIT(TMP464_CONFIG_CONVERSION_RATE_B2));\n\tif (err)\n\t\treturn err;\n\n\tdata->update_interval = 500;\n\n\treturn tmp464_enable_channels(data);\n}\n\nstatic int tmp464_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tchar *name, *chip;\n\tint reg;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_word_swapped(client, TMP464_MANUFACTURER_ID_REG);\n\tif (reg < 0)\n\t\treturn reg;\n\tif (reg != TMP464_MANUFACTURER_ID)\n\t\treturn -ENODEV;\n\n\t \n\treg = i2c_smbus_read_word_swapped(client, TMP464_THERM_STATUS_REG);\n\tif (reg < 0)\n\t\treturn reg;\n\tif (reg & 0x1f)\n\t\treturn -ENODEV;\n\treg = i2c_smbus_read_word_swapped(client, TMP464_THERM2_STATUS_REG);\n\tif (reg < 0)\n\t\treturn reg;\n\tif (reg & 0x1f)\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_word_swapped(client, TMP464_DEVICE_ID_REG);\n\tif (reg < 0)\n\t\treturn reg;\n\tswitch (reg) {\n\tcase TMP464_DEVICE_ID:\n\t\tname = \"tmp464\";\n\t\tchip = \"TMP464\";\n\t\tbreak;\n\tcase TMP468_DEVICE_ID:\n\t\tname = \"tmp468\";\n\t\tchip = \"TMP468\";\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, name, I2C_NAME_SIZE);\n\tdev_info(&adapter->dev, \"Detected TI %s chip at 0x%02x\\n\", chip, client->addr);\n\n\treturn 0;\n}\n\nstatic int tmp464_probe_child_from_dt(struct device *dev,\n\t\t\t\t      struct device_node *child,\n\t\t\t\t      struct tmp464_data *data)\n\n{\n\tstruct regmap *regmap = data->regmap;\n\tu32 channel;\n\ts32 nfactor;\n\tint err;\n\n\terr = of_property_read_u32(child, \"reg\", &channel);\n\tif (err) {\n\t\tdev_err(dev, \"missing reg property of %pOFn\\n\", child);\n\t\treturn err;\n\t}\n\n\tif (channel >= data->channels) {\n\t\tdev_err(dev, \"invalid reg %d of %pOFn\\n\", channel, child);\n\t\treturn -EINVAL;\n\t}\n\n\tof_property_read_string(child, \"label\", &data->channel[channel].label);\n\n\tdata->channel[channel].enabled = of_device_is_available(child);\n\n\terr = of_property_read_s32(child, \"ti,n-factor\", &nfactor);\n\tif (err && err != -EINVAL)\n\t\treturn err;\n\tif (!err) {\n\t\tif (channel == 0) {\n\t\t\tdev_err(dev, \"n-factor can't be set for internal channel\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nfactor > 127 || nfactor < -128) {\n\t\t\tdev_err(dev, \"n-factor for channel %d invalid (%d)\\n\",\n\t\t\t\tchannel, nfactor);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = regmap_write(regmap, TMP464_N_FACTOR_REG(channel),\n\t\t\t\t   (nfactor << 8) & 0xff00);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tmp464_probe_from_dt(struct device *dev, struct tmp464_data *data)\n{\n\tconst struct device_node *np = dev->of_node;\n\tstruct device_node *child;\n\tint err;\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (strcmp(child->name, \"channel\"))\n\t\t\tcontinue;\n\n\t\terr = tmp464_probe_child_from_dt(dev, child, data);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops tmp464_ops = {\n\t.is_visible = tmp464_is_visible,\n\t.read = tmp464_read,\n\t.read_string = tmp464_read_string,\n\t.write = tmp464_write,\n};\n\nstatic const struct hwmon_channel_info * const tmp464_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST | HWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM |\n\t\t\t   HWMON_T_LABEL | HWMON_T_ENABLE,\n\t\t\t   HWMON_T_INPUT | HWMON_T_OFFSET | HWMON_T_MAX | HWMON_T_MAX_HYST |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MAX_ALARM |\n\t\t\t   HWMON_T_CRIT_ALARM | HWMON_T_FAULT | HWMON_T_LABEL | HWMON_T_ENABLE,\n\t\t\t   HWMON_T_INPUT | HWMON_T_OFFSET | HWMON_T_MAX | HWMON_T_MAX_HYST |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MAX_ALARM |\n\t\t\t   HWMON_T_CRIT_ALARM | HWMON_T_FAULT | HWMON_T_LABEL | HWMON_T_ENABLE,\n\t\t\t   HWMON_T_INPUT | HWMON_T_OFFSET | HWMON_T_MAX | HWMON_T_MAX_HYST |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MAX_ALARM |\n\t\t\t   HWMON_T_CRIT_ALARM | HWMON_T_FAULT | HWMON_T_LABEL | HWMON_T_ENABLE,\n\t\t\t   HWMON_T_INPUT | HWMON_T_OFFSET | HWMON_T_MAX | HWMON_T_MAX_HYST |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MAX_ALARM |\n\t\t\t   HWMON_T_CRIT_ALARM | HWMON_T_FAULT | HWMON_T_LABEL | HWMON_T_ENABLE,\n\t\t\t   HWMON_T_INPUT | HWMON_T_OFFSET | HWMON_T_MAX | HWMON_T_MAX_HYST |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MAX_ALARM |\n\t\t\t   HWMON_T_CRIT_ALARM | HWMON_T_FAULT | HWMON_T_LABEL | HWMON_T_ENABLE,\n\t\t\t   HWMON_T_INPUT | HWMON_T_OFFSET | HWMON_T_MAX | HWMON_T_MAX_HYST |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MAX_ALARM |\n\t\t\t   HWMON_T_CRIT_ALARM | HWMON_T_FAULT | HWMON_T_LABEL | HWMON_T_ENABLE,\n\t\t\t   HWMON_T_INPUT | HWMON_T_OFFSET | HWMON_T_MAX | HWMON_T_MAX_HYST |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MAX_ALARM |\n\t\t\t   HWMON_T_CRIT_ALARM | HWMON_T_FAULT | HWMON_T_LABEL | HWMON_T_ENABLE,\n\t\t\t   HWMON_T_INPUT | HWMON_T_OFFSET | HWMON_T_MAX | HWMON_T_MAX_HYST |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MAX_ALARM |\n\t\t\t   HWMON_T_CRIT_ALARM | HWMON_T_FAULT | HWMON_T_LABEL | HWMON_T_ENABLE),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info tmp464_chip_info = {\n\t.ops = &tmp464_ops,\n\t.info = tmp464_info,\n};\n\n \n\nstatic bool tmp464_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn (reg < TMP464_TEMP_REG(TMP468_NUM_CHANNELS) ||\n\t\treg == TMP464_THERM_STATUS_REG ||\n\t\treg == TMP464_THERM2_STATUS_REG ||\n\t\treg == TMP464_REMOTE_OPEN_REG);\n}\n\nstatic const struct regmap_config tmp464_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = TMP464_DEVICE_ID_REG,\n\t.volatile_reg = tmp464_is_volatile_reg,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int tmp464_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct tmp464_data *data;\n\tint i, err;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA)) {\n\t\tdev_err(&client->dev, \"i2c functionality check failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdata = devm_kzalloc(dev, sizeof(struct tmp464_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&data->update_lock);\n\n\tif (dev->of_node)\n\t\tdata->channels = (int)(unsigned long)of_device_get_match_data(&client->dev);\n\telse\n\t\tdata->channels = i2c_match_id(tmp464_id, client)->driver_data;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &tmp464_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\tfor (i = 0; i < data->channels; i++)\n\t\tdata->channel[i].enabled = true;\n\n\terr = tmp464_init_client(dev, data);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->of_node) {\n\t\terr = tmp464_probe_from_dt(dev, data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data, &tmp464_chip_info, NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic struct i2c_driver tmp464_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"tmp464\",\n\t\t.of_match_table = of_match_ptr(tmp464_of_match),\n\t},\n\t.probe = tmp464_probe,\n\t.id_table = tmp464_id,\n\t.detect = tmp464_detect,\n\t.address_list = normal_i2c,\n};\n\nmodule_i2c_driver(tmp464_driver);\n\nMODULE_AUTHOR(\"Agathe Porte <agathe.porte@nokia.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments TMP464 temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}