{
  "module_name": "asus-ec-sensors.c",
  "hash_id": "47f3778cf03ea8c0f53d54f22ab1e62b9c8e8d92189ab44a69860d44bd2d60e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/asus-ec-sensors.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/dev_printk.h>\n#include <linux/dmi.h>\n#include <linux/hwmon.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/sort.h>\n#include <linux/units.h>\n\n#include <asm/unaligned.h>\n\nstatic char *mutex_path_override;\n\n \n#define ASUS_EC_BANK_REGISTER\t0xff\n#define SENSOR_LABEL_LEN\t16\n\n \n#define ASUS_EC_MAX_BANK\t3\n\n#define ACPI_LOCK_DELAY_MS\t500\n\n \n#define ASUS_HW_ACCESS_MUTEX_ASMX\t\"\\\\AMW0.ASMX\"\n\n#define ASUS_HW_ACCESS_MUTEX_RMTW_ASMX\t\"\\\\RMTW.ASMX\"\n\n#define ASUS_HW_ACCESS_MUTEX_SB_PCI0_SBRG_SIO1_MUT0 \"\\\\_SB_.PCI0.SBRG.SIO1.MUT0\"\n\n#define MAX_IDENTICAL_BOARD_VARIATIONS\t3\n\n \n#define ACPI_GLOBAL_LOCK_PSEUDO_PATH\t\":GLOBAL_LOCK\"\n\ntypedef union {\n\tu32 value;\n\tstruct {\n\t\tu8 index;\n\t\tu8 bank;\n\t\tu8 size;\n\t\tu8 dummy;\n\t} components;\n} sensor_address;\n\n#define MAKE_SENSOR_ADDRESS(size, bank, index) {                               \\\n\t\t.value = (size << 16) + (bank << 8) + index                    \\\n\t}\n\nstatic u32 hwmon_attributes[hwmon_max] = {\n\t[hwmon_chip] = HWMON_C_REGISTER_TZ,\n\t[hwmon_temp] = HWMON_T_INPUT | HWMON_T_LABEL,\n\t[hwmon_in] = HWMON_I_INPUT | HWMON_I_LABEL,\n\t[hwmon_curr] = HWMON_C_INPUT | HWMON_C_LABEL,\n\t[hwmon_fan] = HWMON_F_INPUT | HWMON_F_LABEL,\n};\n\nstruct ec_sensor_info {\n\tchar label[SENSOR_LABEL_LEN];\n\tenum hwmon_sensor_types type;\n\tsensor_address addr;\n};\n\n#define EC_SENSOR(sensor_label, sensor_type, size, bank, index) {              \\\n\t\t.label = sensor_label, .type = sensor_type,                    \\\n\t\t.addr = MAKE_SENSOR_ADDRESS(size, bank, index),                \\\n\t}\n\nenum ec_sensors {\n\t \n\tec_sensor_temp_chipset,\n\t \n\tec_sensor_temp_cpu,\n\t \n\tec_sensor_temp_cpu_package,\n\t \n\tec_sensor_temp_mb,\n\t \n\tec_sensor_temp_t_sensor,\n\t \n\tec_sensor_temp_vrm,\n\t \n\tec_sensor_in_cpu_core,\n\t \n\tec_sensor_fan_cpu_opt,\n\t \n\tec_sensor_fan_vrm_hs,\n\t \n\tec_sensor_fan_chipset,\n\t \n\tec_sensor_fan_water_flow,\n\t \n\tec_sensor_curr_cpu,\n\t \n\tec_sensor_temp_water_in,\n\t \n\tec_sensor_temp_water_out,\n\t \n\tec_sensor_temp_water_block_in,\n\t \n\tec_sensor_temp_water_block_out,\n\t \n\tec_sensor_temp_t_sensor_2,\n\t \n\tec_sensor_temp_sensor_extra_1,\n\t \n\tec_sensor_temp_sensor_extra_2,\n\t \n\tec_sensor_temp_sensor_extra_3,\n};\n\n#define SENSOR_TEMP_CHIPSET BIT(ec_sensor_temp_chipset)\n#define SENSOR_TEMP_CPU BIT(ec_sensor_temp_cpu)\n#define SENSOR_TEMP_CPU_PACKAGE BIT(ec_sensor_temp_cpu_package)\n#define SENSOR_TEMP_MB BIT(ec_sensor_temp_mb)\n#define SENSOR_TEMP_T_SENSOR BIT(ec_sensor_temp_t_sensor)\n#define SENSOR_TEMP_VRM BIT(ec_sensor_temp_vrm)\n#define SENSOR_IN_CPU_CORE BIT(ec_sensor_in_cpu_core)\n#define SENSOR_FAN_CPU_OPT BIT(ec_sensor_fan_cpu_opt)\n#define SENSOR_FAN_VRM_HS BIT(ec_sensor_fan_vrm_hs)\n#define SENSOR_FAN_CHIPSET BIT(ec_sensor_fan_chipset)\n#define SENSOR_FAN_WATER_FLOW BIT(ec_sensor_fan_water_flow)\n#define SENSOR_CURR_CPU BIT(ec_sensor_curr_cpu)\n#define SENSOR_TEMP_WATER_IN BIT(ec_sensor_temp_water_in)\n#define SENSOR_TEMP_WATER_OUT BIT(ec_sensor_temp_water_out)\n#define SENSOR_TEMP_WATER_BLOCK_IN BIT(ec_sensor_temp_water_block_in)\n#define SENSOR_TEMP_WATER_BLOCK_OUT BIT(ec_sensor_temp_water_block_out)\n#define SENSOR_TEMP_T_SENSOR_2 BIT(ec_sensor_temp_t_sensor_2)\n#define SENSOR_TEMP_SENSOR_EXTRA_1 BIT(ec_sensor_temp_sensor_extra_1)\n#define SENSOR_TEMP_SENSOR_EXTRA_2 BIT(ec_sensor_temp_sensor_extra_2)\n#define SENSOR_TEMP_SENSOR_EXTRA_3 BIT(ec_sensor_temp_sensor_extra_3)\n\nenum board_family {\n\tfamily_unknown,\n\tfamily_amd_400_series,\n\tfamily_amd_500_series,\n\tfamily_amd_600_series,\n\tfamily_intel_300_series,\n\tfamily_intel_600_series\n};\n\n \nstatic const struct ec_sensor_info sensors_family_amd_400[] = {\n\t[ec_sensor_temp_chipset] =\n\t\tEC_SENSOR(\"Chipset\", hwmon_temp, 1, 0x00, 0x3a),\n\t[ec_sensor_temp_cpu] =\n\t\tEC_SENSOR(\"CPU\", hwmon_temp, 1, 0x00, 0x3b),\n\t[ec_sensor_temp_mb] =\n\t\tEC_SENSOR(\"Motherboard\", hwmon_temp, 1, 0x00, 0x3c),\n\t[ec_sensor_temp_t_sensor] =\n\t\tEC_SENSOR(\"T_Sensor\", hwmon_temp, 1, 0x00, 0x3d),\n\t[ec_sensor_temp_vrm] =\n\t\tEC_SENSOR(\"VRM\", hwmon_temp, 1, 0x00, 0x3e),\n\t[ec_sensor_in_cpu_core] =\n\t\tEC_SENSOR(\"CPU Core\", hwmon_in, 2, 0x00, 0xa2),\n\t[ec_sensor_fan_cpu_opt] =\n\t\tEC_SENSOR(\"CPU_Opt\", hwmon_fan, 2, 0x00, 0xbc),\n\t[ec_sensor_fan_vrm_hs] =\n\t\tEC_SENSOR(\"VRM HS\", hwmon_fan, 2, 0x00, 0xb2),\n\t[ec_sensor_fan_chipset] =\n\t\t \n\t\tEC_SENSOR(\"Chipset\", hwmon_fan, 0, 0x00, 0x00),\n\t[ec_sensor_fan_water_flow] =\n\t\tEC_SENSOR(\"Water_Flow\", hwmon_fan, 2, 0x00, 0xb4),\n\t[ec_sensor_curr_cpu] =\n\t\tEC_SENSOR(\"CPU\", hwmon_curr, 1, 0x00, 0xf4),\n\t[ec_sensor_temp_water_in] =\n\t\tEC_SENSOR(\"Water_In\", hwmon_temp, 1, 0x01, 0x0d),\n\t[ec_sensor_temp_water_out] =\n\t\tEC_SENSOR(\"Water_Out\", hwmon_temp, 1, 0x01, 0x0b),\n};\n\nstatic const struct ec_sensor_info sensors_family_amd_500[] = {\n\t[ec_sensor_temp_chipset] =\n\t\tEC_SENSOR(\"Chipset\", hwmon_temp, 1, 0x00, 0x3a),\n\t[ec_sensor_temp_cpu] = EC_SENSOR(\"CPU\", hwmon_temp, 1, 0x00, 0x3b),\n\t[ec_sensor_temp_mb] =\n\t\tEC_SENSOR(\"Motherboard\", hwmon_temp, 1, 0x00, 0x3c),\n\t[ec_sensor_temp_t_sensor] =\n\t\tEC_SENSOR(\"T_Sensor\", hwmon_temp, 1, 0x00, 0x3d),\n\t[ec_sensor_temp_vrm] = EC_SENSOR(\"VRM\", hwmon_temp, 1, 0x00, 0x3e),\n\t[ec_sensor_in_cpu_core] =\n\t\tEC_SENSOR(\"CPU Core\", hwmon_in, 2, 0x00, 0xa2),\n\t[ec_sensor_fan_cpu_opt] =\n\t\tEC_SENSOR(\"CPU_Opt\", hwmon_fan, 2, 0x00, 0xb0),\n\t[ec_sensor_fan_vrm_hs] = EC_SENSOR(\"VRM HS\", hwmon_fan, 2, 0x00, 0xb2),\n\t[ec_sensor_fan_chipset] =\n\t\tEC_SENSOR(\"Chipset\", hwmon_fan, 2, 0x00, 0xb4),\n\t[ec_sensor_fan_water_flow] =\n\t\tEC_SENSOR(\"Water_Flow\", hwmon_fan, 2, 0x00, 0xbc),\n\t[ec_sensor_curr_cpu] = EC_SENSOR(\"CPU\", hwmon_curr, 1, 0x00, 0xf4),\n\t[ec_sensor_temp_water_in] =\n\t\tEC_SENSOR(\"Water_In\", hwmon_temp, 1, 0x01, 0x00),\n\t[ec_sensor_temp_water_out] =\n\t\tEC_SENSOR(\"Water_Out\", hwmon_temp, 1, 0x01, 0x01),\n\t[ec_sensor_temp_water_block_in] =\n\t\tEC_SENSOR(\"Water_Block_In\", hwmon_temp, 1, 0x01, 0x02),\n\t[ec_sensor_temp_water_block_out] =\n\t\tEC_SENSOR(\"Water_Block_Out\", hwmon_temp, 1, 0x01, 0x03),\n\t[ec_sensor_temp_sensor_extra_1] =\n\t\tEC_SENSOR(\"Extra_1\", hwmon_temp, 1, 0x01, 0x09),\n\t[ec_sensor_temp_t_sensor_2] =\n\t\tEC_SENSOR(\"T_sensor_2\", hwmon_temp, 1, 0x01, 0x0a),\n\t[ec_sensor_temp_sensor_extra_2] =\n\t\tEC_SENSOR(\"Extra_2\", hwmon_temp, 1, 0x01, 0x0b),\n\t[ec_sensor_temp_sensor_extra_3] =\n\t\tEC_SENSOR(\"Extra_3\", hwmon_temp, 1, 0x01, 0x0c),\n};\n\nstatic const struct ec_sensor_info sensors_family_amd_600[] = {\n\t[ec_sensor_temp_cpu] = EC_SENSOR(\"CPU\", hwmon_temp, 1, 0x00, 0x30),\n\t[ec_sensor_temp_cpu_package] = EC_SENSOR(\"CPU Package\", hwmon_temp, 1, 0x00, 0x31),\n\t[ec_sensor_temp_mb] =\n\tEC_SENSOR(\"Motherboard\", hwmon_temp, 1, 0x00, 0x32),\n\t[ec_sensor_temp_vrm] =\n\t\tEC_SENSOR(\"VRM\", hwmon_temp, 1, 0x00, 0x33),\n\t[ec_sensor_temp_water_in] =\n\t\tEC_SENSOR(\"Water_In\", hwmon_temp, 1, 0x01, 0x00),\n\t[ec_sensor_temp_water_out] =\n\t\tEC_SENSOR(\"Water_Out\", hwmon_temp, 1, 0x01, 0x01),\n};\n\nstatic const struct ec_sensor_info sensors_family_intel_300[] = {\n\t[ec_sensor_temp_chipset] =\n\t\tEC_SENSOR(\"Chipset\", hwmon_temp, 1, 0x00, 0x3a),\n\t[ec_sensor_temp_cpu] = EC_SENSOR(\"CPU\", hwmon_temp, 1, 0x00, 0x3b),\n\t[ec_sensor_temp_mb] =\n\t\tEC_SENSOR(\"Motherboard\", hwmon_temp, 1, 0x00, 0x3c),\n\t[ec_sensor_temp_t_sensor] =\n\t\tEC_SENSOR(\"T_Sensor\", hwmon_temp, 1, 0x00, 0x3d),\n\t[ec_sensor_temp_vrm] = EC_SENSOR(\"VRM\", hwmon_temp, 1, 0x00, 0x3e),\n\t[ec_sensor_fan_cpu_opt] =\n\t\tEC_SENSOR(\"CPU_Opt\", hwmon_fan, 2, 0x00, 0xb0),\n\t[ec_sensor_fan_vrm_hs] = EC_SENSOR(\"VRM HS\", hwmon_fan, 2, 0x00, 0xb2),\n\t[ec_sensor_fan_water_flow] =\n\t\tEC_SENSOR(\"Water_Flow\", hwmon_fan, 2, 0x00, 0xbc),\n\t[ec_sensor_temp_water_in] =\n\t\tEC_SENSOR(\"Water_In\", hwmon_temp, 1, 0x01, 0x00),\n\t[ec_sensor_temp_water_out] =\n\t\tEC_SENSOR(\"Water_Out\", hwmon_temp, 1, 0x01, 0x01),\n};\n\nstatic const struct ec_sensor_info sensors_family_intel_600[] = {\n\t[ec_sensor_temp_t_sensor] =\n\t\tEC_SENSOR(\"T_Sensor\", hwmon_temp, 1, 0x00, 0x3d),\n\t[ec_sensor_temp_vrm] = EC_SENSOR(\"VRM\", hwmon_temp, 1, 0x00, 0x3e),\n};\n\n \n#define SENSOR_SET_TEMP_CHIPSET_CPU_MB                                         \\\n\t(SENSOR_TEMP_CHIPSET | SENSOR_TEMP_CPU | SENSOR_TEMP_MB)\n#define SENSOR_SET_TEMP_WATER (SENSOR_TEMP_WATER_IN | SENSOR_TEMP_WATER_OUT)\n#define SENSOR_SET_WATER_BLOCK                                                 \\\n\t(SENSOR_TEMP_WATER_BLOCK_IN | SENSOR_TEMP_WATER_BLOCK_OUT)\n\nstruct ec_board_info {\n\tunsigned long sensors;\n\t \n\tconst char *mutex_path;\n\tenum board_family family;\n};\n\nstatic const struct ec_board_info board_info_prime_x470_pro = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB |\n\t\tSENSOR_TEMP_T_SENSOR | SENSOR_TEMP_VRM |\n\t\tSENSOR_FAN_CPU_OPT |\n\t\tSENSOR_CURR_CPU | SENSOR_IN_CPU_CORE,\n\t.mutex_path = ACPI_GLOBAL_LOCK_PSEUDO_PATH,\n\t.family = family_amd_400_series,\n};\n\nstatic const struct ec_board_info board_info_prime_x570_pro = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB | SENSOR_TEMP_VRM |\n\t\tSENSOR_TEMP_T_SENSOR | SENSOR_FAN_CHIPSET,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_pro_art_x570_creator_wifi = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB | SENSOR_TEMP_VRM |\n\t\tSENSOR_TEMP_T_SENSOR | SENSOR_FAN_CPU_OPT |\n\t\tSENSOR_CURR_CPU | SENSOR_IN_CPU_CORE,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_pro_art_b550_creator = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB |\n\t\tSENSOR_TEMP_T_SENSOR |\n\t\tSENSOR_FAN_CPU_OPT,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_pro_ws_x570_ace = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB | SENSOR_TEMP_VRM |\n\t\tSENSOR_TEMP_T_SENSOR | SENSOR_FAN_CHIPSET |\n\t\tSENSOR_CURR_CPU | SENSOR_IN_CPU_CORE,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_crosshair_x670e_hero = {\n\t.sensors = SENSOR_TEMP_CPU | SENSOR_TEMP_CPU_PACKAGE |\n\t\tSENSOR_TEMP_MB | SENSOR_TEMP_VRM |\n\t\tSENSOR_SET_TEMP_WATER,\n\t.mutex_path = ACPI_GLOBAL_LOCK_PSEUDO_PATH,\n\t.family = family_amd_600_series,\n};\n\nstatic const struct ec_board_info board_info_crosshair_viii_dark_hero = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB |\n\t\tSENSOR_TEMP_T_SENSOR |\n\t\tSENSOR_TEMP_VRM | SENSOR_SET_TEMP_WATER |\n\t\tSENSOR_FAN_CPU_OPT | SENSOR_FAN_WATER_FLOW |\n\t\tSENSOR_CURR_CPU | SENSOR_IN_CPU_CORE,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_crosshair_viii_hero = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB |\n\t\tSENSOR_TEMP_T_SENSOR |\n\t\tSENSOR_TEMP_VRM | SENSOR_SET_TEMP_WATER |\n\t\tSENSOR_FAN_CPU_OPT | SENSOR_FAN_CHIPSET |\n\t\tSENSOR_FAN_WATER_FLOW | SENSOR_CURR_CPU |\n\t\tSENSOR_IN_CPU_CORE,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_maximus_xi_hero = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB |\n\t\tSENSOR_TEMP_T_SENSOR |\n\t\tSENSOR_TEMP_VRM | SENSOR_SET_TEMP_WATER |\n\t\tSENSOR_FAN_CPU_OPT | SENSOR_FAN_WATER_FLOW,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_intel_300_series,\n};\n\nstatic const struct ec_board_info board_info_crosshair_viii_impact = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB |\n\t\tSENSOR_TEMP_T_SENSOR | SENSOR_TEMP_VRM |\n\t\tSENSOR_FAN_CHIPSET | SENSOR_CURR_CPU |\n\t\tSENSOR_IN_CPU_CORE,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_strix_b550_e_gaming = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB |\n\t\tSENSOR_TEMP_T_SENSOR | SENSOR_TEMP_VRM |\n\t\tSENSOR_FAN_CPU_OPT,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_strix_b550_i_gaming = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB |\n\t\tSENSOR_TEMP_T_SENSOR | SENSOR_TEMP_VRM |\n\t\tSENSOR_FAN_VRM_HS | SENSOR_CURR_CPU |\n\t\tSENSOR_IN_CPU_CORE,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_strix_x570_e_gaming = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB |\n\t\tSENSOR_TEMP_T_SENSOR | SENSOR_TEMP_VRM |\n\t\tSENSOR_FAN_CHIPSET | SENSOR_CURR_CPU |\n\t\tSENSOR_IN_CPU_CORE,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_strix_x570_e_gaming_wifi_ii = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB |\n\t\tSENSOR_TEMP_T_SENSOR | SENSOR_CURR_CPU |\n\t\tSENSOR_IN_CPU_CORE,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_strix_x570_f_gaming = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB |\n\t\tSENSOR_TEMP_T_SENSOR | SENSOR_FAN_CHIPSET,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_strix_x570_i_gaming = {\n\t.sensors = SENSOR_TEMP_CHIPSET | SENSOR_TEMP_VRM |\n\t\tSENSOR_TEMP_T_SENSOR |\n\t\tSENSOR_FAN_VRM_HS | SENSOR_FAN_CHIPSET |\n\t\tSENSOR_CURR_CPU | SENSOR_IN_CPU_CORE,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_amd_500_series,\n};\n\nstatic const struct ec_board_info board_info_strix_z390_f_gaming = {\n\t.sensors = SENSOR_TEMP_CHIPSET | SENSOR_TEMP_VRM |\n\t\tSENSOR_TEMP_T_SENSOR |\n\t\tSENSOR_FAN_CPU_OPT,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_ASMX,\n\t.family = family_intel_300_series,\n};\n\nstatic const struct ec_board_info board_info_strix_z690_a_gaming_wifi_d4 = {\n\t.sensors = SENSOR_TEMP_T_SENSOR | SENSOR_TEMP_VRM,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_RMTW_ASMX,\n\t.family = family_intel_600_series,\n};\n\nstatic const struct ec_board_info board_info_zenith_ii_extreme = {\n\t.sensors = SENSOR_SET_TEMP_CHIPSET_CPU_MB | SENSOR_TEMP_T_SENSOR |\n\t\tSENSOR_TEMP_VRM | SENSOR_SET_TEMP_WATER |\n\t\tSENSOR_FAN_CPU_OPT | SENSOR_FAN_CHIPSET | SENSOR_FAN_VRM_HS |\n\t\tSENSOR_FAN_WATER_FLOW | SENSOR_CURR_CPU | SENSOR_IN_CPU_CORE |\n\t\tSENSOR_SET_WATER_BLOCK |\n\t\tSENSOR_TEMP_T_SENSOR_2 | SENSOR_TEMP_SENSOR_EXTRA_1 |\n\t\tSENSOR_TEMP_SENSOR_EXTRA_2 | SENSOR_TEMP_SENSOR_EXTRA_3,\n\t.mutex_path = ASUS_HW_ACCESS_MUTEX_SB_PCI0_SBRG_SIO1_MUT0,\n\t.family = family_amd_500_series,\n};\n\n#define DMI_EXACT_MATCH_ASUS_BOARD_NAME(name, board_info)                      \\\n\t{                                                                      \\\n\t\t.matches = {                                                   \\\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR,                      \\\n\t\t\t\t\t\"ASUSTeK COMPUTER INC.\"),              \\\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, name),                 \\\n\t\t},                                                             \\\n\t\t.driver_data = (void *)board_info,                              \\\n\t}\n\nstatic const struct dmi_system_id dmi_table[] = {\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"PRIME X470-PRO\",\n\t\t\t\t\t&board_info_prime_x470_pro),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"PRIME X570-PRO\",\n\t\t\t\t\t&board_info_prime_x570_pro),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ProArt X570-CREATOR WIFI\",\n\t\t\t\t\t&board_info_pro_art_x570_creator_wifi),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ProArt B550-CREATOR\",\n\t\t\t\t\t&board_info_pro_art_b550_creator),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"Pro WS X570-ACE\",\n\t\t\t\t\t&board_info_pro_ws_x570_ace),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG CROSSHAIR VIII DARK HERO\",\n\t\t\t\t\t&board_info_crosshair_viii_dark_hero),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG CROSSHAIR VIII FORMULA\",\n\t\t\t\t\t&board_info_crosshair_viii_hero),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG CROSSHAIR VIII HERO\",\n\t\t\t\t\t&board_info_crosshair_viii_hero),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG CROSSHAIR VIII HERO (WI-FI)\",\n\t\t\t\t\t&board_info_crosshair_viii_hero),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG CROSSHAIR X670E HERO\",\n\t\t\t\t\t&board_info_crosshair_x670e_hero),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG MAXIMUS XI HERO\",\n\t\t\t\t\t&board_info_maximus_xi_hero),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG MAXIMUS XI HERO (WI-FI)\",\n\t\t\t\t\t&board_info_maximus_xi_hero),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG CROSSHAIR VIII IMPACT\",\n\t\t\t\t\t&board_info_crosshair_viii_impact),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX B550-E GAMING\",\n\t\t\t\t\t&board_info_strix_b550_e_gaming),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX B550-I GAMING\",\n\t\t\t\t\t&board_info_strix_b550_i_gaming),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX X570-E GAMING\",\n\t\t\t\t\t&board_info_strix_x570_e_gaming),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX X570-E GAMING WIFI II\",\n\t\t\t\t\t&board_info_strix_x570_e_gaming_wifi_ii),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX X570-F GAMING\",\n\t\t\t\t\t&board_info_strix_x570_f_gaming),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX X570-I GAMING\",\n\t\t\t\t\t&board_info_strix_x570_i_gaming),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX Z390-F GAMING\",\n\t\t\t\t\t&board_info_strix_z390_f_gaming),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX Z690-A GAMING WIFI D4\",\n\t\t\t\t\t&board_info_strix_z690_a_gaming_wifi_d4),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG ZENITH II EXTREME\",\n\t\t\t\t\t&board_info_zenith_ii_extreme),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG ZENITH II EXTREME ALPHA\",\n\t\t\t\t\t&board_info_zenith_ii_extreme),\n\t{},\n};\n\nstruct ec_sensor {\n\tunsigned int info_index;\n\ts32 cached_value;\n};\n\nstruct lock_data {\n\tunion {\n\t\tacpi_handle aml;\n\t\t \n\t\tu32 glk;\n\t} mutex;\n\tbool (*lock)(struct lock_data *data);\n\tbool (*unlock)(struct lock_data *data);\n};\n\n \nstatic bool lock_via_acpi_mutex(struct lock_data *data)\n{\n\t \n\treturn ACPI_SUCCESS(acpi_acquire_mutex(data->mutex.aml,\n\t\t\t\t\t       NULL, ACPI_LOCK_DELAY_MS));\n}\n\nstatic bool unlock_acpi_mutex(struct lock_data *data)\n{\n\treturn ACPI_SUCCESS(acpi_release_mutex(data->mutex.aml, NULL));\n}\n\nstatic bool lock_via_global_acpi_lock(struct lock_data *data)\n{\n\treturn ACPI_SUCCESS(acpi_acquire_global_lock(ACPI_LOCK_DELAY_MS,\n\t\t\t\t\t\t     &data->mutex.glk));\n}\n\nstatic bool unlock_global_acpi_lock(struct lock_data *data)\n{\n\treturn ACPI_SUCCESS(acpi_release_global_lock(data->mutex.glk));\n}\n\nstruct ec_sensors_data {\n\tconst struct ec_board_info *board_info;\n\tconst struct ec_sensor_info *sensors_info;\n\tstruct ec_sensor *sensors;\n\t \n\tu16 *registers;\n\tu8 *read_buffer;\n\t \n\tu8 banks[ASUS_EC_MAX_BANK + 1];\n\t \n\tunsigned long last_updated;\n\tstruct lock_data lock_data;\n\t \n\tu8 nr_sensors;\n\t \n\tu8 nr_registers;\n\t \n\tu8 nr_banks;\n};\n\nstatic u8 register_bank(u16 reg)\n{\n\treturn reg >> 8;\n}\n\nstatic u8 register_index(u16 reg)\n{\n\treturn reg & 0x00ff;\n}\n\nstatic bool is_sensor_data_signed(const struct ec_sensor_info *si)\n{\n\t \n\treturn si->type == hwmon_temp;\n}\n\nstatic const struct ec_sensor_info *\nget_sensor_info(const struct ec_sensors_data *state, int index)\n{\n\treturn state->sensors_info + state->sensors[index].info_index;\n}\n\nstatic int find_ec_sensor_index(const struct ec_sensors_data *ec,\n\t\t\t\tenum hwmon_sensor_types type, int channel)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ec->nr_sensors; i++) {\n\t\tif (get_sensor_info(ec, i)->type == type) {\n\t\t\tif (channel == 0)\n\t\t\t\treturn i;\n\t\t\tchannel--;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\nstatic int bank_compare(const void *a, const void *b)\n{\n\treturn *((const s8 *)a) - *((const s8 *)b);\n}\n\nstatic void setup_sensor_data(struct ec_sensors_data *ec)\n{\n\tstruct ec_sensor *s = ec->sensors;\n\tbool bank_found;\n\tint i, j;\n\tu8 bank;\n\n\tec->nr_banks = 0;\n\tec->nr_registers = 0;\n\n\tfor_each_set_bit(i, &ec->board_info->sensors,\n\t\t\t BITS_PER_TYPE(ec->board_info->sensors)) {\n\t\ts->info_index = i;\n\t\ts->cached_value = 0;\n\t\tec->nr_registers +=\n\t\t\tec->sensors_info[s->info_index].addr.components.size;\n\t\tbank_found = false;\n\t\tbank = ec->sensors_info[s->info_index].addr.components.bank;\n\t\tfor (j = 0; j < ec->nr_banks; j++) {\n\t\t\tif (ec->banks[j] == bank) {\n\t\t\t\tbank_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!bank_found) {\n\t\t\tec->banks[ec->nr_banks++] = bank;\n\t\t}\n\t\ts++;\n\t}\n\tsort(ec->banks, ec->nr_banks, 1, bank_compare, NULL);\n}\n\nstatic void fill_ec_registers(struct ec_sensors_data *ec)\n{\n\tconst struct ec_sensor_info *si;\n\tunsigned int i, j, register_idx = 0;\n\n\tfor (i = 0; i < ec->nr_sensors; ++i) {\n\t\tsi = get_sensor_info(ec, i);\n\t\tfor (j = 0; j < si->addr.components.size; ++j, ++register_idx) {\n\t\t\tec->registers[register_idx] =\n\t\t\t\t(si->addr.components.bank << 8) +\n\t\t\t\tsi->addr.components.index + j;\n\t\t}\n\t}\n}\n\nstatic int setup_lock_data(struct device *dev)\n{\n\tconst char *mutex_path;\n\tint status;\n\tstruct ec_sensors_data *state = dev_get_drvdata(dev);\n\n\tmutex_path = mutex_path_override ?\n\t\tmutex_path_override : state->board_info->mutex_path;\n\n\tif (!mutex_path || !strlen(mutex_path)) {\n\t\tdev_err(dev, \"Hardware access guard mutex name is empty\");\n\t\treturn -EINVAL;\n\t}\n\tif (!strcmp(mutex_path, ACPI_GLOBAL_LOCK_PSEUDO_PATH)) {\n\t\tstate->lock_data.mutex.glk = 0;\n\t\tstate->lock_data.lock = lock_via_global_acpi_lock;\n\t\tstate->lock_data.unlock = unlock_global_acpi_lock;\n\t} else {\n\t\tstatus = acpi_get_handle(NULL, (acpi_string)mutex_path,\n\t\t\t\t\t &state->lock_data.mutex.aml);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to get hardware access guard AML mutex '%s': error %d\",\n\t\t\t\tmutex_path, status);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tstate->lock_data.lock = lock_via_acpi_mutex;\n\t\tstate->lock_data.unlock = unlock_acpi_mutex;\n\t}\n\treturn 0;\n}\n\nstatic int asus_ec_bank_switch(u8 bank, u8 *old)\n{\n\tint status = 0;\n\n\tif (old) {\n\t\tstatus = ec_read(ASUS_EC_BANK_REGISTER, old);\n\t}\n\tif (status || (old && (*old == bank)))\n\t\treturn status;\n\treturn ec_write(ASUS_EC_BANK_REGISTER, bank);\n}\n\nstatic int asus_ec_block_read(const struct device *dev,\n\t\t\t      struct ec_sensors_data *ec)\n{\n\tint ireg, ibank, status;\n\tu8 bank, reg_bank, prev_bank;\n\n\tbank = 0;\n\tstatus = asus_ec_bank_switch(bank, &prev_bank);\n\tif (status) {\n\t\tdev_warn(dev, \"EC bank switch failed\");\n\t\treturn status;\n\t}\n\n\tif (prev_bank) {\n\t\t \n\t\tdev_warn(dev,\n\t\t\t\"Concurrent access to the ACPI EC detected.\\nRace condition possible.\");\n\t}\n\n\t \n\tfor (ibank = 0; ibank < ec->nr_banks; ibank++) {\n\t\tif (bank != ec->banks[ibank]) {\n\t\t\tbank = ec->banks[ibank];\n\t\t\tif (asus_ec_bank_switch(bank, NULL)) {\n\t\t\t\tdev_warn(dev, \"EC bank switch to %d failed\",\n\t\t\t\t\t bank);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (ireg = 0; ireg < ec->nr_registers; ireg++) {\n\t\t\treg_bank = register_bank(ec->registers[ireg]);\n\t\t\tif (reg_bank < bank) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tec_read(register_index(ec->registers[ireg]),\n\t\t\t\tec->read_buffer + ireg);\n\t\t}\n\t}\n\n\tstatus = asus_ec_bank_switch(prev_bank, NULL);\n\treturn status;\n}\n\nstatic inline s32 get_sensor_value(const struct ec_sensor_info *si, u8 *data)\n{\n\tif (is_sensor_data_signed(si)) {\n\t\tswitch (si->addr.components.size) {\n\t\tcase 1:\n\t\t\treturn (s8)*data;\n\t\tcase 2:\n\t\t\treturn (s16)get_unaligned_be16(data);\n\t\tcase 4:\n\t\t\treturn (s32)get_unaligned_be32(data);\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tswitch (si->addr.components.size) {\n\t\tcase 1:\n\t\t\treturn *data;\n\t\tcase 2:\n\t\t\treturn get_unaligned_be16(data);\n\t\tcase 4:\n\t\t\treturn get_unaligned_be32(data);\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\nstatic void update_sensor_values(struct ec_sensors_data *ec, u8 *data)\n{\n\tconst struct ec_sensor_info *si;\n\tstruct ec_sensor *s, *sensor_end;\n\n\tsensor_end = ec->sensors + ec->nr_sensors;\n\tfor (s = ec->sensors; s != sensor_end; s++) {\n\t\tsi = ec->sensors_info + s->info_index;\n\t\ts->cached_value = get_sensor_value(si, data);\n\t\tdata += si->addr.components.size;\n\t}\n}\n\nstatic int update_ec_sensors(const struct device *dev,\n\t\t\t     struct ec_sensors_data *ec)\n{\n\tint status;\n\n\tif (!ec->lock_data.lock(&ec->lock_data)) {\n\t\tdev_warn(dev, \"Failed to acquire mutex\");\n\t\treturn -EBUSY;\n\t}\n\n\tstatus = asus_ec_block_read(dev, ec);\n\n\tif (!status) {\n\t\tupdate_sensor_values(ec, ec->read_buffer);\n\t}\n\n\tif (!ec->lock_data.unlock(&ec->lock_data))\n\t\tdev_err(dev, \"Failed to release mutex\");\n\n\treturn status;\n}\n\nstatic long scale_sensor_value(s32 value, int data_type)\n{\n\tswitch (data_type) {\n\tcase hwmon_curr:\n\tcase hwmon_temp:\n\t\treturn value * MILLI;\n\tdefault:\n\t\treturn value;\n\t}\n}\n\nstatic int get_cached_value_or_update(const struct device *dev,\n\t\t\t\t      int sensor_index,\n\t\t\t\t      struct ec_sensors_data *state, s32 *value)\n{\n\tif (time_after(jiffies, state->last_updated + HZ)) {\n\t\tif (update_ec_sensors(dev, state)) {\n\t\t\tdev_err(dev, \"update_ec_sensors() failure\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tstate->last_updated = jiffies;\n\t}\n\n\t*value = state->sensors[sensor_index].cached_value;\n\treturn 0;\n}\n\n \n\nstatic int asus_ec_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel, long *val)\n{\n\tint ret;\n\ts32 value = 0;\n\n\tstruct ec_sensors_data *state = dev_get_drvdata(dev);\n\tint sidx = find_ec_sensor_index(state, type, channel);\n\n\tif (sidx < 0) {\n\t\treturn sidx;\n\t}\n\n\tret = get_cached_value_or_update(dev, sidx, state, &value);\n\tif (!ret) {\n\t\t*val = scale_sensor_value(value,\n\t\t\t\t\t  get_sensor_info(state, sidx)->type);\n\t}\n\n\treturn ret;\n}\n\nstatic int asus_ec_hwmon_read_string(struct device *dev,\n\t\t\t\t     enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t     int channel, const char **str)\n{\n\tstruct ec_sensors_data *state = dev_get_drvdata(dev);\n\tint sensor_index = find_ec_sensor_index(state, type, channel);\n\t*str = get_sensor_info(state, sensor_index)->label;\n\n\treturn 0;\n}\n\nstatic umode_t asus_ec_hwmon_is_visible(const void *drvdata,\n\t\t\t\t\tenum hwmon_sensor_types type, u32 attr,\n\t\t\t\t\tint channel)\n{\n\tconst struct ec_sensors_data *state = drvdata;\n\n\treturn find_ec_sensor_index(state, type, channel) >= 0 ? S_IRUGO : 0;\n}\n\nstatic int\nasus_ec_hwmon_add_chan_info(struct hwmon_channel_info *asus_ec_hwmon_chan,\n\t\t\t     struct device *dev, int num,\n\t\t\t     enum hwmon_sensor_types type, u32 config)\n{\n\tint i;\n\tu32 *cfg = devm_kcalloc(dev, num + 1, sizeof(*cfg), GFP_KERNEL);\n\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tasus_ec_hwmon_chan->type = type;\n\tasus_ec_hwmon_chan->config = cfg;\n\tfor (i = 0; i < num; i++, cfg++)\n\t\t*cfg = config;\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops asus_ec_hwmon_ops = {\n\t.is_visible = asus_ec_hwmon_is_visible,\n\t.read = asus_ec_hwmon_read,\n\t.read_string = asus_ec_hwmon_read_string,\n};\n\nstatic struct hwmon_chip_info asus_ec_chip_info = {\n\t.ops = &asus_ec_hwmon_ops,\n};\n\nstatic const struct ec_board_info *get_board_info(void)\n{\n\tconst struct dmi_system_id *dmi_entry;\n\n\tdmi_entry = dmi_first_match(dmi_table);\n\treturn dmi_entry ? dmi_entry->driver_data : NULL;\n}\n\nstatic int asus_ec_probe(struct platform_device *pdev)\n{\n\tconst struct hwmon_channel_info **ptr_asus_ec_ci;\n\tint nr_count[hwmon_max] = { 0 }, nr_types = 0;\n\tstruct hwmon_channel_info *asus_ec_hwmon_chan;\n\tconst struct ec_board_info *pboard_info;\n\tconst struct hwmon_chip_info *chip_info;\n\tstruct device *dev = &pdev->dev;\n\tstruct ec_sensors_data *ec_data;\n\tconst struct ec_sensor_info *si;\n\tenum hwmon_sensor_types type;\n\tstruct device *hwdev;\n\tunsigned int i;\n\tint status;\n\n\tpboard_info = get_board_info();\n\tif (!pboard_info)\n\t\treturn -ENODEV;\n\n\tec_data = devm_kzalloc(dev, sizeof(struct ec_sensors_data),\n\t\t\t       GFP_KERNEL);\n\tif (!ec_data)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ec_data);\n\tec_data->board_info = pboard_info;\n\n\tswitch (ec_data->board_info->family) {\n\tcase family_amd_400_series:\n\t\tec_data->sensors_info = sensors_family_amd_400;\n\t\tbreak;\n\tcase family_amd_500_series:\n\t\tec_data->sensors_info = sensors_family_amd_500;\n\t\tbreak;\n\tcase family_amd_600_series:\n\t\tec_data->sensors_info = sensors_family_amd_600;\n\t\tbreak;\n\tcase family_intel_300_series:\n\t\tec_data->sensors_info = sensors_family_intel_300;\n\t\tbreak;\n\tcase family_intel_600_series:\n\t\tec_data->sensors_info = sensors_family_intel_600;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unknown board family: %d\",\n\t\t\tec_data->board_info->family);\n\t\treturn -EINVAL;\n\t}\n\n\tec_data->nr_sensors = hweight_long(ec_data->board_info->sensors);\n\tec_data->sensors = devm_kcalloc(dev, ec_data->nr_sensors,\n\t\t\t\t\tsizeof(struct ec_sensor), GFP_KERNEL);\n\tif (!ec_data->sensors)\n\t\treturn -ENOMEM;\n\n\tstatus = setup_lock_data(dev);\n\tif (status) {\n\t\tdev_err(dev, \"Failed to setup state/EC locking: %d\", status);\n\t\treturn status;\n\t}\n\n\tsetup_sensor_data(ec_data);\n\tec_data->registers = devm_kcalloc(dev, ec_data->nr_registers,\n\t\t\t\t\t  sizeof(u16), GFP_KERNEL);\n\tec_data->read_buffer = devm_kcalloc(dev, ec_data->nr_registers,\n\t\t\t\t\t    sizeof(u8), GFP_KERNEL);\n\n\tif (!ec_data->registers || !ec_data->read_buffer)\n\t\treturn -ENOMEM;\n\n\tfill_ec_registers(ec_data);\n\n\tfor (i = 0; i < ec_data->nr_sensors; ++i) {\n\t\tsi = get_sensor_info(ec_data, i);\n\t\tif (!nr_count[si->type])\n\t\t\t++nr_types;\n\t\t++nr_count[si->type];\n\t}\n\n\tif (nr_count[hwmon_temp])\n\t\tnr_count[hwmon_chip]++, nr_types++;\n\n\tasus_ec_hwmon_chan = devm_kcalloc(\n\t\tdev, nr_types, sizeof(*asus_ec_hwmon_chan), GFP_KERNEL);\n\tif (!asus_ec_hwmon_chan)\n\t\treturn -ENOMEM;\n\n\tptr_asus_ec_ci = devm_kcalloc(dev, nr_types + 1,\n\t\t\t\t       sizeof(*ptr_asus_ec_ci), GFP_KERNEL);\n\tif (!ptr_asus_ec_ci)\n\t\treturn -ENOMEM;\n\n\tasus_ec_chip_info.info = ptr_asus_ec_ci;\n\tchip_info = &asus_ec_chip_info;\n\n\tfor (type = 0; type < hwmon_max; ++type) {\n\t\tif (!nr_count[type])\n\t\t\tcontinue;\n\n\t\tasus_ec_hwmon_add_chan_info(asus_ec_hwmon_chan, dev,\n\t\t\t\t\t     nr_count[type], type,\n\t\t\t\t\t     hwmon_attributes[type]);\n\t\t*ptr_asus_ec_ci++ = asus_ec_hwmon_chan++;\n\t}\n\n\tdev_info(dev, \"board has %d EC sensors that span %d registers\",\n\t\t ec_data->nr_sensors, ec_data->nr_registers);\n\n\thwdev = devm_hwmon_device_register_with_info(dev, \"asusec\",\n\t\t\t\t\t\t     ec_data, chip_info, NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwdev);\n}\n\nMODULE_DEVICE_TABLE(dmi, dmi_table);\n\nstatic struct platform_driver asus_ec_sensors_platform_driver = {\n\t.driver = {\n\t\t.name\t= \"asus-ec-sensors\",\n\t},\n\t.probe = asus_ec_probe,\n};\n\nstatic struct platform_device *asus_ec_sensors_platform_device;\n\nstatic int __init asus_ec_init(void)\n{\n\tasus_ec_sensors_platform_device =\n\t\tplatform_create_bundle(&asus_ec_sensors_platform_driver,\n\t\t\t\t       asus_ec_probe, NULL, 0, NULL, 0);\n\n\tif (IS_ERR(asus_ec_sensors_platform_device))\n\t\treturn PTR_ERR(asus_ec_sensors_platform_device);\n\n\treturn 0;\n}\n\nstatic void __exit asus_ec_exit(void)\n{\n\tplatform_device_unregister(asus_ec_sensors_platform_device);\n\tplatform_driver_unregister(&asus_ec_sensors_platform_driver);\n}\n\nmodule_init(asus_ec_init);\nmodule_exit(asus_ec_exit);\n\nmodule_param_named(mutex_path, mutex_path_override, charp, 0);\nMODULE_PARM_DESC(mutex_path,\n\t\t \"Override ACPI mutex path used to guard access to hardware\");\n\nMODULE_AUTHOR(\"Eugene Shalygin <eugene.shalygin@gmail.com>\");\nMODULE_DESCRIPTION(\n\t\"HWMON driver for sensors accessible via ACPI EC in ASUS motherboards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}