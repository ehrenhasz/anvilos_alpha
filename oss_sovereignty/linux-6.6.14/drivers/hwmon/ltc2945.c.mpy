{
  "module_name": "ltc2945.c",
  "hash_id": "220f9c486d560eff9b84403ed86e0a9bae7300d7692660eb84e2b815945048fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ltc2945.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/regmap.h>\n\n \n#define LTC2945_CONTROL\t\t\t0x00\n#define LTC2945_ALERT\t\t\t0x01\n#define LTC2945_STATUS\t\t\t0x02\n#define LTC2945_FAULT\t\t\t0x03\n#define LTC2945_POWER_H\t\t\t0x05\n#define LTC2945_MAX_POWER_H\t\t0x08\n#define LTC2945_MIN_POWER_H\t\t0x0b\n#define LTC2945_MAX_POWER_THRES_H\t0x0e\n#define LTC2945_MIN_POWER_THRES_H\t0x11\n#define LTC2945_SENSE_H\t\t\t0x14\n#define LTC2945_MAX_SENSE_H\t\t0x16\n#define LTC2945_MIN_SENSE_H\t\t0x18\n#define LTC2945_MAX_SENSE_THRES_H\t0x1a\n#define LTC2945_MIN_SENSE_THRES_H\t0x1c\n#define LTC2945_VIN_H\t\t\t0x1e\n#define LTC2945_MAX_VIN_H\t\t0x20\n#define LTC2945_MIN_VIN_H\t\t0x22\n#define LTC2945_MAX_VIN_THRES_H\t\t0x24\n#define LTC2945_MIN_VIN_THRES_H\t\t0x26\n#define LTC2945_ADIN_H\t\t\t0x28\n#define LTC2945_MAX_ADIN_H\t\t0x2a\n#define LTC2945_MIN_ADIN_H\t\t0x2c\n#define LTC2945_MAX_ADIN_THRES_H\t0x2e\n#define LTC2945_MIN_ADIN_THRES_H\t0x30\n#define LTC2945_MIN_ADIN_THRES_L\t0x31\n\n \n\n#define FAULT_ADIN_UV\t\t(1 << 0)\n#define FAULT_ADIN_OV\t\t(1 << 1)\n#define FAULT_VIN_UV\t\t(1 << 2)\n#define FAULT_VIN_OV\t\t(1 << 3)\n#define FAULT_SENSE_UV\t\t(1 << 4)\n#define FAULT_SENSE_OV\t\t(1 << 5)\n#define FAULT_POWER_UV\t\t(1 << 6)\n#define FAULT_POWER_OV\t\t(1 << 7)\n\n \n\n#define CONTROL_MULT_SELECT\t(1 << 0)\n#define CONTROL_TEST_MODE\t(1 << 4)\n\nstatic const struct of_device_id __maybe_unused ltc2945_of_match[] = {\n\t{ .compatible = \"adi,ltc2945\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ltc2945_of_match);\n\n \nstruct ltc2945_data {\n\tstruct regmap *regmap;\n\tu32 shunt_resistor;\n};\n\nstatic inline bool is_power_reg(u8 reg)\n{\n\treturn reg < LTC2945_SENSE_H;\n}\n\n \nstatic long long ltc2945_reg_to_val(struct device *dev, u8 reg)\n{\n\tstruct ltc2945_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tu32 shunt_resistor = data->shunt_resistor;\n\tunsigned int control;\n\tu8 buf[3];\n\tlong long val;\n\tint ret;\n\n\tret = regmap_bulk_read(regmap, reg, buf,\n\t\t\t       is_power_reg(reg) ? 3 : 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (is_power_reg(reg)) {\n\t\t \n\t\tval = (buf[0] << 16) + (buf[1] << 8) + buf[2];\n\t} else {\n\t\t \n\t\tval = (buf[0] << 4) + (buf[1] >> 4);\n\t}\n\n\tswitch (reg) {\n\tcase LTC2945_POWER_H:\n\tcase LTC2945_MAX_POWER_H:\n\tcase LTC2945_MIN_POWER_H:\n\tcase LTC2945_MAX_POWER_THRES_H:\n\tcase LTC2945_MIN_POWER_THRES_H:\n\t\t \n\t\tret = regmap_read(regmap, LTC2945_CONTROL, &control);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (control & CONTROL_MULT_SELECT) {\n\t\t\t \n\t\t\tval *= 625LL;\n\t\t} else {\n\t\t\t \n\t\t\tval = (val * 25LL) >> 1;\n\t\t}\n\t\tval *= 1000;\n\t\t \n\t\tval = DIV_ROUND_CLOSEST_ULL(val, shunt_resistor);\n\t\t \n\n\t\tbreak;\n\tcase LTC2945_VIN_H:\n\tcase LTC2945_MAX_VIN_H:\n\tcase LTC2945_MIN_VIN_H:\n\tcase LTC2945_MAX_VIN_THRES_H:\n\tcase LTC2945_MIN_VIN_THRES_H:\n\t\t \n\t\tval *= 25;\n\t\tbreak;\n\tcase LTC2945_ADIN_H:\n\tcase LTC2945_MAX_ADIN_H:\n\tcase LTC2945_MIN_ADIN_THRES_H:\n\tcase LTC2945_MAX_ADIN_THRES_H:\n\tcase LTC2945_MIN_ADIN_H:\n\t\t \n\t\tval = val >> 1;\n\t\tbreak;\n\tcase LTC2945_SENSE_H:\n\tcase LTC2945_MAX_SENSE_H:\n\tcase LTC2945_MIN_SENSE_H:\n\tcase LTC2945_MAX_SENSE_THRES_H:\n\tcase LTC2945_MIN_SENSE_THRES_H:\n\t\t \n\t\tval *= 25 * 1000;\n\t\t \n\t\tval = DIV_ROUND_CLOSEST_ULL(val, shunt_resistor);\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn val;\n}\n\nstatic long long ltc2945_val_to_reg(struct device *dev, u8 reg,\n\t\t\t\t    unsigned long long val)\n{\n\tstruct ltc2945_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tu32 shunt_resistor = data->shunt_resistor;\n\tunsigned int control;\n\tint ret;\n\n\t \n\tval = clamp_val(val, 0, U32_MAX);\n\n\tswitch (reg) {\n\tcase LTC2945_POWER_H:\n\tcase LTC2945_MAX_POWER_H:\n\tcase LTC2945_MIN_POWER_H:\n\tcase LTC2945_MAX_POWER_THRES_H:\n\tcase LTC2945_MIN_POWER_THRES_H:\n\t\t \n\t\tret = regmap_read(regmap, LTC2945_CONTROL, &control);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (control & CONTROL_MULT_SELECT) {\n\t\t\t \n\t\t\tval *= shunt_resistor;\n\t\t\t \n\t\t\tval = DIV_ROUND_CLOSEST_ULL(val, 625 * 1000);\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tval *= shunt_resistor;\n\t\t\t \n\t\t\tval = DIV_ROUND_CLOSEST_ULL(val, 25 * 1000) * 2;\n\t\t\t \n\t\t}\n\t\tbreak;\n\tcase LTC2945_VIN_H:\n\tcase LTC2945_MAX_VIN_H:\n\tcase LTC2945_MIN_VIN_H:\n\tcase LTC2945_MAX_VIN_THRES_H:\n\tcase LTC2945_MIN_VIN_THRES_H:\n\t\t \n\t\tval = DIV_ROUND_CLOSEST_ULL(val, 25);\n\t\tbreak;\n\tcase LTC2945_ADIN_H:\n\tcase LTC2945_MAX_ADIN_H:\n\tcase LTC2945_MIN_ADIN_THRES_H:\n\tcase LTC2945_MAX_ADIN_THRES_H:\n\tcase LTC2945_MIN_ADIN_H:\n\t\t \n\t\tval *= 2;\n\t\tbreak;\n\tcase LTC2945_SENSE_H:\n\tcase LTC2945_MAX_SENSE_H:\n\tcase LTC2945_MIN_SENSE_H:\n\tcase LTC2945_MAX_SENSE_THRES_H:\n\tcase LTC2945_MIN_SENSE_THRES_H:\n\t\t \n\t\tval *= shunt_resistor;\n\t\t \n\t\tval = DIV_ROUND_CLOSEST_ULL(val, 25 * 1000);\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn val;\n}\n\nstatic ssize_t ltc2945_value_show(struct device *dev,\n\t\t\t\t  struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tlong long value;\n\n\tvalue = ltc2945_reg_to_val(dev, attr->index);\n\tif (value < 0)\n\t\treturn value;\n\treturn sysfs_emit(buf, \"%lld\\n\", value);\n}\n\nstatic ssize_t ltc2945_value_store(struct device *dev,\n\t\t\t\t   struct device_attribute *da,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ltc2945_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tu8 reg = attr->index;\n\tunsigned int val;\n\tu8 regbuf[3];\n\tint num_regs;\n\tlong long regval;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregval = ltc2945_val_to_reg(dev, reg, val);\n\tif (regval < 0)\n\t\treturn regval;\n\tif (is_power_reg(reg)) {\n\t\tregval = clamp_val(regval, 0, 0xffffff);\n\t\tregbuf[0] = regval >> 16;\n\t\tregbuf[1] = (regval >> 8) & 0xff;\n\t\tregbuf[2] = regval;\n\t\tnum_regs = 3;\n\t} else {\n\t\tregval = clamp_val(regval, 0, 0xfff) << 4;\n\t\tregbuf[0] = regval >> 8;\n\t\tregbuf[1] = regval & 0xff;\n\t\tnum_regs = 2;\n\t}\n\tret = regmap_bulk_write(regmap, reg, regbuf, num_regs);\n\treturn ret < 0 ? ret : count;\n}\n\nstatic ssize_t ltc2945_history_store(struct device *dev,\n\t\t\t\t     struct device_attribute *da,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ltc2945_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tu8 reg = attr->index;\n\tint num_regs = is_power_reg(reg) ? 3 : 2;\n\tu8 buf_min[3] = { 0xff, 0xff, 0xff };\n\tu8 buf_max[3] = { 0, 0, 0 };\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tret = regmap_update_bits(regmap, LTC2945_CONTROL, CONTROL_TEST_MODE,\n\t\t\t\t CONTROL_TEST_MODE);\n\n\t \n\tret = regmap_bulk_write(regmap, reg, buf_min, num_regs);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (reg) {\n\tcase LTC2945_MIN_POWER_H:\n\t\treg = LTC2945_MAX_POWER_H;\n\t\tbreak;\n\tcase LTC2945_MIN_SENSE_H:\n\t\treg = LTC2945_MAX_SENSE_H;\n\t\tbreak;\n\tcase LTC2945_MIN_VIN_H:\n\t\treg = LTC2945_MAX_VIN_H;\n\t\tbreak;\n\tcase LTC2945_MIN_ADIN_H:\n\t\treg = LTC2945_MAX_ADIN_H;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Bad register: 0x%x\\n\", reg);\n\t\treturn -EINVAL;\n\t}\n\t \n\tret = regmap_bulk_write(regmap, reg, buf_max, num_regs);\n\n\t \n\tregmap_update_bits(regmap, LTC2945_CONTROL, CONTROL_TEST_MODE, 0);\n\n\treturn ret ? : count;\n}\n\nstatic ssize_t ltc2945_bool_show(struct device *dev,\n\t\t\t\t struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ltc2945_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int fault;\n\tint ret;\n\n\tret = regmap_read(regmap, LTC2945_FAULT, &fault);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfault &= attr->index;\n\tif (fault)\t\t \n\t\tregmap_update_bits(regmap, LTC2945_FAULT, attr->index, 0);\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!fault);\n}\n\n \n\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, ltc2945_value, LTC2945_VIN_H);\nstatic SENSOR_DEVICE_ATTR_RW(in1_min, ltc2945_value, LTC2945_MIN_VIN_THRES_H);\nstatic SENSOR_DEVICE_ATTR_RW(in1_max, ltc2945_value, LTC2945_MAX_VIN_THRES_H);\nstatic SENSOR_DEVICE_ATTR_RO(in1_lowest, ltc2945_value, LTC2945_MIN_VIN_H);\nstatic SENSOR_DEVICE_ATTR_RO(in1_highest, ltc2945_value, LTC2945_MAX_VIN_H);\nstatic SENSOR_DEVICE_ATTR_WO(in1_reset_history, ltc2945_history,\n\t\t\t     LTC2945_MIN_VIN_H);\n\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, ltc2945_value, LTC2945_ADIN_H);\nstatic SENSOR_DEVICE_ATTR_RW(in2_min, ltc2945_value, LTC2945_MIN_ADIN_THRES_H);\nstatic SENSOR_DEVICE_ATTR_RW(in2_max, ltc2945_value, LTC2945_MAX_ADIN_THRES_H);\nstatic SENSOR_DEVICE_ATTR_RO(in2_lowest, ltc2945_value, LTC2945_MIN_ADIN_H);\nstatic SENSOR_DEVICE_ATTR_RO(in2_highest, ltc2945_value, LTC2945_MAX_ADIN_H);\nstatic SENSOR_DEVICE_ATTR_WO(in2_reset_history, ltc2945_history,\n\t\t\t     LTC2945_MIN_ADIN_H);\n\n \n\nstatic SENSOR_DEVICE_ATTR_RO(in1_min_alarm, ltc2945_bool, FAULT_VIN_UV);\nstatic SENSOR_DEVICE_ATTR_RO(in1_max_alarm, ltc2945_bool, FAULT_VIN_OV);\nstatic SENSOR_DEVICE_ATTR_RO(in2_min_alarm, ltc2945_bool, FAULT_ADIN_UV);\nstatic SENSOR_DEVICE_ATTR_RO(in2_max_alarm, ltc2945_bool, FAULT_ADIN_OV);\n\n \n\nstatic SENSOR_DEVICE_ATTR_RO(curr1_input, ltc2945_value, LTC2945_SENSE_H);\nstatic SENSOR_DEVICE_ATTR_RW(curr1_min, ltc2945_value,\n\t\t\t     LTC2945_MIN_SENSE_THRES_H);\nstatic SENSOR_DEVICE_ATTR_RW(curr1_max, ltc2945_value,\n\t\t\t     LTC2945_MAX_SENSE_THRES_H);\nstatic SENSOR_DEVICE_ATTR_RO(curr1_lowest, ltc2945_value, LTC2945_MIN_SENSE_H);\nstatic SENSOR_DEVICE_ATTR_RO(curr1_highest, ltc2945_value,\n\t\t\t     LTC2945_MAX_SENSE_H);\nstatic SENSOR_DEVICE_ATTR_WO(curr1_reset_history, ltc2945_history,\n\t\t\t     LTC2945_MIN_SENSE_H);\n\n \n\nstatic SENSOR_DEVICE_ATTR_RO(curr1_min_alarm, ltc2945_bool, FAULT_SENSE_UV);\nstatic SENSOR_DEVICE_ATTR_RO(curr1_max_alarm, ltc2945_bool, FAULT_SENSE_OV);\n\n \n\nstatic SENSOR_DEVICE_ATTR_RO(power1_input, ltc2945_value, LTC2945_POWER_H);\nstatic SENSOR_DEVICE_ATTR_RW(power1_min, ltc2945_value,\n\t\t\t     LTC2945_MIN_POWER_THRES_H);\nstatic SENSOR_DEVICE_ATTR_RW(power1_max, ltc2945_value,\n\t\t\t     LTC2945_MAX_POWER_THRES_H);\nstatic SENSOR_DEVICE_ATTR_RO(power1_input_lowest, ltc2945_value,\n\t\t\t     LTC2945_MIN_POWER_H);\nstatic SENSOR_DEVICE_ATTR_RO(power1_input_highest, ltc2945_value,\n\t\t\t     LTC2945_MAX_POWER_H);\nstatic SENSOR_DEVICE_ATTR_WO(power1_reset_history, ltc2945_history,\n\t\t\t     LTC2945_MIN_POWER_H);\n\n \n\nstatic SENSOR_DEVICE_ATTR_RO(power1_min_alarm, ltc2945_bool, FAULT_POWER_UV);\nstatic SENSOR_DEVICE_ATTR_RO(power1_max_alarm, ltc2945_bool, FAULT_POWER_OV);\n\nstatic struct attribute *ltc2945_attrs[] = {\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_lowest.dev_attr.attr,\n\t&sensor_dev_attr_in1_highest.dev_attr.attr,\n\t&sensor_dev_attr_in1_reset_history.dev_attr.attr,\n\t&sensor_dev_attr_in1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_max_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_lowest.dev_attr.attr,\n\t&sensor_dev_attr_in2_highest.dev_attr.attr,\n\t&sensor_dev_attr_in2_reset_history.dev_attr.attr,\n\t&sensor_dev_attr_in2_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_max_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_curr1_input.dev_attr.attr,\n\t&sensor_dev_attr_curr1_min.dev_attr.attr,\n\t&sensor_dev_attr_curr1_max.dev_attr.attr,\n\t&sensor_dev_attr_curr1_lowest.dev_attr.attr,\n\t&sensor_dev_attr_curr1_highest.dev_attr.attr,\n\t&sensor_dev_attr_curr1_reset_history.dev_attr.attr,\n\t&sensor_dev_attr_curr1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_curr1_max_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_power1_input.dev_attr.attr,\n\t&sensor_dev_attr_power1_min.dev_attr.attr,\n\t&sensor_dev_attr_power1_max.dev_attr.attr,\n\t&sensor_dev_attr_power1_input_lowest.dev_attr.attr,\n\t&sensor_dev_attr_power1_input_highest.dev_attr.attr,\n\t&sensor_dev_attr_power1_reset_history.dev_attr.attr,\n\t&sensor_dev_attr_power1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_power1_max_alarm.dev_attr.attr,\n\n\tNULL,\n};\nATTRIBUTE_GROUPS(ltc2945);\n\nstatic const struct regmap_config ltc2945_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = LTC2945_MIN_ADIN_THRES_L,\n};\n\nstatic int ltc2945_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct regmap *regmap;\n\tstruct ltc2945_data *data;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, data);\n\n\tregmap = devm_regmap_init_i2c(client, &ltc2945_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tdata->regmap = regmap;\n\tif (device_property_read_u32(dev, \"shunt-resistor-micro-ohms\",\n\t\t\t\t     &data->shunt_resistor))\n\t\tdata->shunt_resistor = 1000;\n\n\tif (data->shunt_resistor == 0)\n\t\treturn -EINVAL;\n\n\t \n\tregmap_write(regmap, LTC2945_FAULT, 0x00);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   ltc2945_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id ltc2945_id[] = {\n\t{\"ltc2945\", 0},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, ltc2945_id);\n\nstatic struct i2c_driver ltc2945_driver = {\n\t.driver = {\n\t\t.name = \"ltc2945\",\n\t\t.of_match_table = of_match_ptr(ltc2945_of_match),\n\t},\n\t.probe = ltc2945_probe,\n\t.id_table = ltc2945_id,\n};\n\nmodule_i2c_driver(ltc2945_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"LTC2945 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}