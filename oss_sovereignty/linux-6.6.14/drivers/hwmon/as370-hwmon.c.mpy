{
  "module_name": "as370-hwmon.c",
  "hash_id": "5846e93690466cc0c4b9882ba549f760af9368cb3141a568e54f3044a6167079",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/as370-hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/hwmon.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n\n#define CTRL\t\t0x0\n#define  PD\t\tBIT(0)\n#define  EN\t\tBIT(1)\n#define  T_SEL\t\tBIT(2)\n#define  V_SEL\t\tBIT(3)\n#define  NMOS_SEL\tBIT(8)\n#define  PMOS_SEL\tBIT(9)\n#define STS\t\t0x4\n#define  BN_MASK\tGENMASK(11, 0)\n#define  EOC\t\tBIT(12)\n\nstruct as370_hwmon {\n\tvoid __iomem *base;\n};\n\nstatic void init_pvt(struct as370_hwmon *hwmon)\n{\n\tu32 val;\n\tvoid __iomem *addr = hwmon->base + CTRL;\n\n\tval = PD;\n\twritel_relaxed(val, addr);\n\tval |= T_SEL;\n\twritel_relaxed(val, addr);\n\tval |= EN;\n\twritel_relaxed(val, addr);\n\tval &= ~PD;\n\twritel_relaxed(val, addr);\n}\n\nstatic int as370_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t    u32 attr, int channel, long *temp)\n{\n\tint val;\n\tstruct as370_hwmon *hwmon = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tval = readl_relaxed(hwmon->base + STS) & BN_MASK;\n\t\t*temp = DIV_ROUND_CLOSEST(val * 251802, 4096) - 85525;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic umode_t\nas370_hwmon_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel)\n{\n\tif (type != hwmon_temp)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const as370_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops as370_hwmon_ops = {\n\t.is_visible = as370_hwmon_is_visible,\n\t.read = as370_hwmon_read,\n};\n\nstatic const struct hwmon_chip_info as370_chip_info = {\n\t.ops = &as370_hwmon_ops,\n\t.info = as370_hwmon_info,\n};\n\nstatic int as370_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct device *hwmon_dev;\n\tstruct as370_hwmon *hwmon;\n\tstruct device *dev = &pdev->dev;\n\n\thwmon = devm_kzalloc(dev, sizeof(*hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn -ENOMEM;\n\n\thwmon->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hwmon->base))\n\t\treturn PTR_ERR(hwmon->base);\n\n\tinit_pvt(hwmon);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev,\n\t\t\t\t\t\t\t \"as370\",\n\t\t\t\t\t\t\t hwmon,\n\t\t\t\t\t\t\t &as370_chip_info,\n\t\t\t\t\t\t\t NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct of_device_id as370_hwmon_match[] = {\n\t{ .compatible = \"syna,as370-hwmon\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, as370_hwmon_match);\n\nstatic struct platform_driver as370_hwmon_driver = {\n\t.probe = as370_hwmon_probe,\n\t.driver = {\n\t\t.name = \"as370-hwmon\",\n\t\t.of_match_table = as370_hwmon_match,\n\t},\n};\nmodule_platform_driver(as370_hwmon_driver);\n\nMODULE_AUTHOR(\"Jisheng Zhang<jszhang@kernel.org>\");\nMODULE_DESCRIPTION(\"Synaptics AS370 SoC hardware monitor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}