{
  "module_name": "max6621.c",
  "hash_id": "32d4e9f3d8653c7b49d72ac5632d8a3a0220e40b35a8d4b53c274d97f0c11263",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max6621.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#define MAX6621_DRV_NAME\t\t\"max6621\"\n#define MAX6621_TEMP_INPUT_REG_NUM\t9\n#define MAX6621_TEMP_INPUT_MIN\t\t-127000\n#define MAX6621_TEMP_INPUT_MAX\t\t128000\n#define MAX6621_TEMP_ALERT_CHAN_SHIFT\t1\n\n#define MAX6621_TEMP_S0D0_REG\t\t0x00\n#define MAX6621_TEMP_S0D1_REG\t\t0x01\n#define MAX6621_TEMP_S1D0_REG\t\t0x02\n#define MAX6621_TEMP_S1D1_REG\t\t0x03\n#define MAX6621_TEMP_S2D0_REG\t\t0x04\n#define MAX6621_TEMP_S2D1_REG\t\t0x05\n#define MAX6621_TEMP_S3D0_REG\t\t0x06\n#define MAX6621_TEMP_S3D1_REG\t\t0x07\n#define MAX6621_TEMP_MAX_REG\t\t0x08\n#define MAX6621_TEMP_MAX_ADDR_REG\t0x0a\n#define MAX6621_TEMP_ALERT_CAUSE_REG\t0x0b\n#define MAX6621_CONFIG0_REG\t\t0x0c\n#define MAX6621_CONFIG1_REG\t\t0x0d\n#define MAX6621_CONFIG2_REG\t\t0x0e\n#define MAX6621_CONFIG3_REG\t\t0x0f\n#define MAX6621_TEMP_S0_ALERT_REG\t0x10\n#define MAX6621_TEMP_S1_ALERT_REG\t0x11\n#define MAX6621_TEMP_S2_ALERT_REG\t0x12\n#define MAX6621_TEMP_S3_ALERT_REG\t0x13\n#define MAX6621_CLEAR_ALERT_REG\t\t0x15\n#define MAX6621_REG_MAX\t\t\t(MAX6621_CLEAR_ALERT_REG + 1)\n#define MAX6621_REG_TEMP_SHIFT\t\t0x06\n\n#define MAX6621_ENABLE_TEMP_ALERTS_BIT\t4\n#define MAX6621_ENABLE_I2C_CRC_BIT\t5\n#define MAX6621_ENABLE_ALTERNATE_DATA\t6\n#define MAX6621_ENABLE_LOCKUP_TO\t7\n#define MAX6621_ENABLE_S0D0_BIT\t\t8\n#define MAX6621_ENABLE_S3D1_BIT\t\t15\n#define MAX6621_ENABLE_TEMP_ALL\t\tGENMASK(MAX6621_ENABLE_S3D1_BIT, \\\n\t\t\t\t\t\tMAX6621_ENABLE_S0D0_BIT)\n#define MAX6621_POLL_DELAY_MASK\t\t0x5\n#define MAX6621_CONFIG0_INIT\t\t(MAX6621_ENABLE_TEMP_ALL | \\\n\t\t\t\t\t BIT(MAX6621_ENABLE_LOCKUP_TO) | \\\n\t\t\t\t\t BIT(MAX6621_ENABLE_I2C_CRC_BIT) | \\\n\t\t\t\t\t MAX6621_POLL_DELAY_MASK)\n#define MAX6621_PECI_BIT_TIME\t\t0x2\n#define MAX6621_PECI_RETRY_NUM\t\t0x3\n#define MAX6621_CONFIG1_INIT\t\t((MAX6621_PECI_BIT_TIME << 8) | \\\n\t\t\t\t\t MAX6621_PECI_RETRY_NUM)\n\n \n#define MAX6621_TRAN_FAILED\t0x8100\t \n#define MAX6621_POOL_DIS\t0x8101\t \n#define MAX6621_POOL_UNCOMPLETE\t0x8102\t \n#define MAX6621_SD_DIS\t\t0x8103\t \n#define MAX6621_ALERT_DIS\t0x8104\t \n#define MAX6621_PECI_ERR_MIN\t0x8000\t \n#define MAX6621_PECI_ERR_MAX\t0x80ff\t \n\nstatic const u32 max6621_temp_regs[] = {\n\tMAX6621_TEMP_MAX_REG, MAX6621_TEMP_S0D0_REG, MAX6621_TEMP_S1D0_REG,\n\tMAX6621_TEMP_S2D0_REG, MAX6621_TEMP_S3D0_REG, MAX6621_TEMP_S0D1_REG,\n\tMAX6621_TEMP_S1D1_REG, MAX6621_TEMP_S2D1_REG, MAX6621_TEMP_S3D1_REG,\n};\n\nstatic const char *const max6621_temp_labels[] = {\n\t\"maximum\",\n\t\"socket0_0\",\n\t\"socket1_0\",\n\t\"socket2_0\",\n\t\"socket3_0\",\n\t\"socket0_1\",\n\t\"socket1_1\",\n\t\"socket2_1\",\n\t\"socket3_1\",\n};\n\nstatic const int max6621_temp_alert_chan2reg[] = {\n\tMAX6621_TEMP_S0_ALERT_REG,\n\tMAX6621_TEMP_S1_ALERT_REG,\n\tMAX6621_TEMP_S2_ALERT_REG,\n\tMAX6621_TEMP_S3_ALERT_REG,\n};\n\n \nstruct max6621_data {\n\tstruct i2c_client\t*client;\n\tstruct regmap\t\t*regmap;\n\tint\t\t\tinput_chan2reg[MAX6621_TEMP_INPUT_REG_NUM + 1];\n};\n\nstatic long max6621_temp_mc2reg(long val)\n{\n\treturn (val / 1000L) << MAX6621_REG_TEMP_SHIFT;\n}\n\nstatic umode_t\nmax6621_is_visible(const void *data, enum hwmon_sensor_types type, u32 attr,\n\t\t   int channel)\n{\n\t \n\tif (((struct max6621_data *)data)->input_chan2reg[channel] < 0)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_label:\n\t\tcase hwmon_temp_crit_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_offset:\n\t\tcase hwmon_temp_crit:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int max6621_verify_reg_data(struct device *dev, int regval)\n{\n\tif (regval >= MAX6621_PECI_ERR_MIN &&\n\t    regval <= MAX6621_PECI_ERR_MAX) {\n\t\tdev_dbg(dev, \"PECI error code - err 0x%04x.\\n\",\n\t\t\tregval);\n\n\t\treturn -EIO;\n\t}\n\n\tswitch (regval) {\n\tcase MAX6621_TRAN_FAILED:\n\t\tdev_dbg(dev, \"PECI transaction failed - err 0x%04x.\\n\",\n\t\t\tregval);\n\t\treturn -EIO;\n\tcase MAX6621_POOL_DIS:\n\t\tdev_dbg(dev, \"Polling disabled - err 0x%04x.\\n\", regval);\n\t\treturn -EOPNOTSUPP;\n\tcase MAX6621_POOL_UNCOMPLETE:\n\t\tdev_dbg(dev, \"First poll not completed on startup - err 0x%04x.\\n\",\n\t\t\tregval);\n\t\treturn -EIO;\n\tcase MAX6621_SD_DIS:\n\t\tdev_dbg(dev, \"Resource is disabled - err 0x%04x.\\n\", regval);\n\t\treturn -EOPNOTSUPP;\n\tcase MAX6621_ALERT_DIS:\n\t\tdev_dbg(dev, \"No alert active - err 0x%04x.\\n\", regval);\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int\nmax6621_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t     int channel, long *val)\n{\n\tstruct max6621_data *data = dev_get_drvdata(dev);\n\tu32 regval;\n\tint reg;\n\ts8 temp;\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\treg = data->input_chan2reg[channel];\n\t\t\tret = regmap_read(data->regmap, reg, &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = max6621_verify_reg_data(dev, regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\ttemp = (regval >> MAX6621_REG_TEMP_SHIFT);\n\t\t\t*val = temp * 1000L;\n\n\t\t\tbreak;\n\t\tcase hwmon_temp_offset:\n\t\t\tret = regmap_read(data->regmap, MAX6621_CONFIG2_REG,\n\t\t\t\t\t  &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = max6621_verify_reg_data(dev, regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = (regval >> MAX6621_REG_TEMP_SHIFT) *\n\t\t\t       1000L;\n\n\t\t\tbreak;\n\t\tcase hwmon_temp_crit:\n\t\t\tchannel -= MAX6621_TEMP_ALERT_CHAN_SHIFT;\n\t\t\treg = max6621_temp_alert_chan2reg[channel];\n\t\t\tret = regmap_read(data->regmap, reg, &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = max6621_verify_reg_data(dev, regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = regval * 1000L;\n\n\t\t\tbreak;\n\t\tcase hwmon_temp_crit_alarm:\n\t\t\t \n\t\t\t*val = 0;\n\t\t\tret = regmap_read(data->regmap,\n\t\t\t\t\t  MAX6621_TEMP_ALERT_CAUSE_REG,\n\t\t\t\t\t  &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = max6621_verify_reg_data(dev, regval);\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\tif (regval == MAX6621_ALERT_DIS)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (regval) {\n\t\t\t\tret = i2c_smbus_write_byte(data->client,\n\t\t\t\t\t\tMAX6621_CLEAR_ALERT_REG);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t*val = !!regval;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmax6621_write(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t      int channel, long val)\n{\n\tstruct max6621_data *data = dev_get_drvdata(dev);\n\tu32 reg;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_offset:\n\t\t\t \n\t\t\tval = clamp_val(val, MAX6621_TEMP_INPUT_MIN,\n\t\t\t\t\tMAX6621_TEMP_INPUT_MAX);\n\t\t\tval = max6621_temp_mc2reg(val);\n\n\t\t\treturn regmap_write(data->regmap,\n\t\t\t\t\t    MAX6621_CONFIG2_REG, val);\n\t\tcase hwmon_temp_crit:\n\t\t\tchannel -= MAX6621_TEMP_ALERT_CHAN_SHIFT;\n\t\t\treg = max6621_temp_alert_chan2reg[channel];\n\t\t\t \n\t\t\tval = clamp_val(val, MAX6621_TEMP_INPUT_MIN,\n\t\t\t\t\tMAX6621_TEMP_INPUT_MAX);\n\t\t\tval = val / 1000L;\n\n\t\t\treturn regmap_write(data->regmap, reg, val);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nmax6621_read_string(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t    int channel, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_label:\n\t\t\t*str = max6621_temp_labels[channel];\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic bool max6621_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX6621_CONFIG0_REG:\n\tcase MAX6621_CONFIG1_REG:\n\tcase MAX6621_CONFIG2_REG:\n\tcase MAX6621_CONFIG3_REG:\n\tcase MAX6621_TEMP_S0_ALERT_REG:\n\tcase MAX6621_TEMP_S1_ALERT_REG:\n\tcase MAX6621_TEMP_S2_ALERT_REG:\n\tcase MAX6621_TEMP_S3_ALERT_REG:\n\tcase MAX6621_TEMP_ALERT_CAUSE_REG:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool max6621_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX6621_TEMP_S0D0_REG:\n\tcase MAX6621_TEMP_S0D1_REG:\n\tcase MAX6621_TEMP_S1D0_REG:\n\tcase MAX6621_TEMP_S1D1_REG:\n\tcase MAX6621_TEMP_S2D0_REG:\n\tcase MAX6621_TEMP_S2D1_REG:\n\tcase MAX6621_TEMP_S3D0_REG:\n\tcase MAX6621_TEMP_S3D1_REG:\n\tcase MAX6621_TEMP_MAX_REG:\n\tcase MAX6621_TEMP_MAX_ADDR_REG:\n\tcase MAX6621_CONFIG0_REG:\n\tcase MAX6621_CONFIG1_REG:\n\tcase MAX6621_CONFIG2_REG:\n\tcase MAX6621_CONFIG3_REG:\n\tcase MAX6621_TEMP_S0_ALERT_REG:\n\tcase MAX6621_TEMP_S1_ALERT_REG:\n\tcase MAX6621_TEMP_S2_ALERT_REG:\n\tcase MAX6621_TEMP_S3_ALERT_REG:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool max6621_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX6621_TEMP_S0D0_REG:\n\tcase MAX6621_TEMP_S0D1_REG:\n\tcase MAX6621_TEMP_S1D0_REG:\n\tcase MAX6621_TEMP_S1D1_REG:\n\tcase MAX6621_TEMP_S2D0_REG:\n\tcase MAX6621_TEMP_S2D1_REG:\n\tcase MAX6621_TEMP_S3D0_REG:\n\tcase MAX6621_TEMP_S3D1_REG:\n\tcase MAX6621_TEMP_MAX_REG:\n\tcase MAX6621_TEMP_S0_ALERT_REG:\n\tcase MAX6621_TEMP_S1_ALERT_REG:\n\tcase MAX6621_TEMP_S2_ALERT_REG:\n\tcase MAX6621_TEMP_S3_ALERT_REG:\n\tcase MAX6621_TEMP_ALERT_CAUSE_REG:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const struct reg_default max6621_regmap_default[] = {\n\t{ MAX6621_CONFIG0_REG, MAX6621_CONFIG0_INIT },\n\t{ MAX6621_CONFIG1_REG, MAX6621_CONFIG1_INIT },\n};\n\nstatic const struct regmap_config max6621_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = MAX6621_REG_MAX,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.cache_type = REGCACHE_FLAT,\n\t.writeable_reg = max6621_writeable_reg,\n\t.readable_reg = max6621_readable_reg,\n\t.volatile_reg = max6621_volatile_reg,\n\t.reg_defaults = max6621_regmap_default,\n\t.num_reg_defaults = ARRAY_SIZE(max6621_regmap_default),\n};\n\nstatic const struct hwmon_channel_info * const max6621_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_OFFSET,\n\t\t\t   HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_CRIT_ALARM | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_CRIT_ALARM | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_CRIT_ALARM | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_CRIT_ALARM | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL),\n\tNULL\n};\n\nstatic const struct hwmon_ops max6621_hwmon_ops = {\n\t.read = max6621_read,\n\t.write = max6621_write,\n\t.read_string = max6621_read_string,\n\t.is_visible = max6621_is_visible,\n};\n\nstatic const struct hwmon_chip_info max6621_chip_info = {\n\t.ops = &max6621_hwmon_ops,\n\t.info = max6621_info,\n};\n\nstatic int max6621_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct max6621_data *data;\n\tstruct device *hwmon_dev;\n\tint i;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &max6621_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\ti2c_set_clientdata(client, data);\n\tdata->client = client;\n\n\t \n\tret = regmap_write(data->regmap, MAX6621_CONFIG0_REG,\n\t\t\t   MAX6621_CONFIG0_INIT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, MAX6621_CONFIG1_REG,\n\t\t\t   MAX6621_CONFIG1_INIT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregcache_mark_dirty(data->regmap);\n\tret = regcache_sync(data->regmap);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < MAX6621_TEMP_INPUT_REG_NUM; i++) {\n\t\tret = i2c_smbus_read_word_data(client, max6621_temp_regs[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = max6621_verify_reg_data(dev, ret);\n\t\tif (ret) {\n\t\t\tdata->input_chan2reg[i] = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata->input_chan2reg[i] = max6621_temp_regs[i];\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &max6621_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id max6621_id[] = {\n\t{ MAX6621_DRV_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max6621_id);\n\nstatic const struct of_device_id __maybe_unused max6621_of_match[] = {\n\t{ .compatible = \"maxim,max6621\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max6621_of_match);\n\nstatic struct i2c_driver max6621_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = MAX6621_DRV_NAME,\n\t\t.of_match_table = of_match_ptr(max6621_of_match),\n\t},\n\t.probe\t\t= max6621_probe,\n\t.id_table\t= max6621_id,\n};\n\nmodule_i2c_driver(max6621_driver);\n\nMODULE_AUTHOR(\"Vadim Pasternak <vadimp@mellanox.com>\");\nMODULE_DESCRIPTION(\"Driver for Maxim MAX6621\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}