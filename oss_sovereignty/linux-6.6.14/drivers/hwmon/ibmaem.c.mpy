{
  "module_name": "ibmaem.c",
  "hash_id": "0d95e3a563dbbbbccdff3a7a438444d4caa2eb0eb740b9b846176e6cc3badad9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ibmaem.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/ipmi.h>\n#include <linux/module.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/kdev_t.h>\n#include <linux/spinlock.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/platform_device.h>\n#include <linux/math64.h>\n#include <linux/time.h>\n#include <linux/err.h>\n\n#define REFRESH_INTERVAL\t(HZ)\n#define IPMI_TIMEOUT\t\t(30 * HZ)\n#define DRVNAME\t\t\t\"aem\"\n\n#define AEM_NETFN\t\t0x2E\n\n#define AEM_FIND_FW_CMD\t\t0x80\n#define AEM_ELEMENT_CMD\t\t0x81\n#define AEM_FW_INSTANCE_CMD\t0x82\n\n#define AEM_READ_ELEMENT_CFG\t0x80\n#define AEM_READ_BUFFER\t\t0x81\n#define AEM_READ_REGISTER\t0x82\n#define AEM_WRITE_REGISTER\t0x83\n#define AEM_SET_REG_MASK\t0x84\n#define AEM_CLEAR_REG_MASK\t0x85\n#define AEM_READ_ELEMENT_CFG2\t0x86\n\n#define AEM_CONTROL_ELEMENT\t0\n#define AEM_ENERGY_ELEMENT\t1\n#define AEM_CLOCK_ELEMENT\t4\n#define AEM_POWER_CAP_ELEMENT\t7\n#define AEM_EXHAUST_ELEMENT\t9\n#define AEM_POWER_ELEMENT\t10\n\n#define AEM_MODULE_TYPE_ID\t0x0001\n\n#define AEM2_NUM_ENERGY_REGS\t2\n#define AEM2_NUM_PCAP_REGS\t6\n#define AEM2_NUM_TEMP_REGS\t2\n#define AEM2_NUM_SENSORS\t14\n\n#define AEM1_NUM_ENERGY_REGS\t1\n#define AEM1_NUM_SENSORS\t3\n\n \n#define AEM_NUM_ENERGY_REGS\tAEM2_NUM_ENERGY_REGS\n \n#define AEM_NUM_SENSORS\t\tAEM2_NUM_SENSORS\n\n#define POWER_CAP\t\t0\n#define POWER_CAP_MAX_HOTPLUG\t1\n#define POWER_CAP_MAX\t\t2\n#define\tPOWER_CAP_MIN_WARNING\t3\n#define POWER_CAP_MIN\t\t4\n#define\tPOWER_AUX\t\t5\n\n#define AEM_DEFAULT_POWER_INTERVAL 1000\n#define AEM_MIN_POWER_INTERVAL\t200\n#define UJ_PER_MJ\t\t1000L\n\nstatic DEFINE_IDA(aem_ida);\n\nstatic struct platform_driver aem_driver = {\n\t.driver = {\n\t\t.name = DRVNAME,\n\t\t.bus = &platform_bus_type,\n\t}\n};\n\nstruct aem_ipmi_data {\n\tstruct completion\tread_complete;\n\tstruct ipmi_addr\taddress;\n\tstruct ipmi_user\t*user;\n\tint\t\t\tinterface;\n\n\tstruct kernel_ipmi_msg\ttx_message;\n\tlong\t\t\ttx_msgid;\n\n\tvoid\t\t\t*rx_msg_data;\n\tunsigned short\t\trx_msg_len;\n\tunsigned char\t\trx_result;\n\tint\t\t\trx_recv_type;\n\n\tstruct device\t\t*bmc_device;\n};\n\nstruct aem_ro_sensor_template {\n\tchar *label;\n\tssize_t (*show)(struct device *dev,\n\t\t\tstruct device_attribute *devattr,\n\t\t\tchar *buf);\n\tint index;\n};\n\nstruct aem_rw_sensor_template {\n\tchar *label;\n\tssize_t (*show)(struct device *dev,\n\t\t\tstruct device_attribute *devattr,\n\t\t\tchar *buf);\n\tssize_t (*set)(struct device *dev,\n\t\t       struct device_attribute *devattr,\n\t\t       const char *buf, size_t count);\n\tint index;\n};\n\nstruct aem_data {\n\tstruct list_head\tlist;\n\n\tstruct device\t\t*hwmon_dev;\n\tstruct platform_device\t*pdev;\n\tstruct mutex\t\tlock;\n\tbool\t\t\tvalid;\n\tunsigned long\t\tlast_updated;\t \n\tu8\t\t\tver_major;\n\tu8\t\t\tver_minor;\n\tu8\t\t\tmodule_handle;\n\tint\t\t\tid;\n\tstruct aem_ipmi_data\tipmi;\n\n\t \n\tvoid (*update)(struct aem_data *data);\n\tstruct aem_read_sensor_resp *rs_resp;\n\n\t \n\n\t \n\tstruct sensor_device_attribute\tsensors[AEM_NUM_SENSORS];\n\n\t \n\tu64\t\t\tenergy[AEM_NUM_ENERGY_REGS];\n\n\t \n\tunsigned long\t\tpower_period[AEM_NUM_ENERGY_REGS];\n\n\t \n\n\t \n\tu16\t\t\tpcap[AEM2_NUM_PCAP_REGS];\n\n\t \n\tu8\t\t\ttemp[AEM2_NUM_TEMP_REGS];\n};\n\n \nstruct aem_iana_id {\n\tu8\t\t\tbytes[3];\n};\nstatic struct aem_iana_id system_x_id = {\n\t.bytes = {0x4D, 0x4F, 0x00}\n};\n\n \nstruct aem_find_firmware_req {\n\tstruct aem_iana_id\tid;\n\tu8\t\t\trsvd;\n\t__be16\t\t\tindex;\n\t__be16\t\t\tmodule_type_id;\n} __packed;\n\nstruct aem_find_firmware_resp {\n\tstruct aem_iana_id\tid;\n\tu8\t\t\tnum_instances;\n} __packed;\n\n \nstruct aem_find_instance_req {\n\tstruct aem_iana_id\tid;\n\tu8\t\t\tinstance_number;\n\t__be16\t\t\tmodule_type_id;\n} __packed;\n\nstruct aem_find_instance_resp {\n\tstruct aem_iana_id\tid;\n\tu8\t\t\tnum_instances;\n\tu8\t\t\tmajor;\n\tu8\t\t\tminor;\n\tu8\t\t\tmodule_handle;\n\tu16\t\t\trecord_id;\n} __packed;\n\n \nstruct aem_read_sensor_req {\n\tstruct aem_iana_id\tid;\n\tu8\t\t\tmodule_handle;\n\tu8\t\t\telement;\n\tu8\t\t\tsubcommand;\n\tu8\t\t\treg;\n\tu8\t\t\trx_buf_size;\n} __packed;\n\nstruct aem_read_sensor_resp {\n\tstruct aem_iana_id\tid;\n\tu8\t\t\tbytes[];\n} __packed;\n\n \nstruct aem_driver_data {\n\tstruct list_head\taem_devices;\n\tstruct ipmi_smi_watcher\tbmc_events;\n\tstruct ipmi_user_hndl\tipmi_hndlrs;\n};\n\nstatic void aem_register_bmc(int iface, struct device *dev);\nstatic void aem_bmc_gone(int iface);\nstatic void aem_msg_handler(struct ipmi_recv_msg *msg, void *user_msg_data);\n\nstatic void aem_remove_sensors(struct aem_data *data);\nstatic int aem1_find_sensors(struct aem_data *data);\nstatic int aem2_find_sensors(struct aem_data *data);\nstatic void update_aem1_sensors(struct aem_data *data);\nstatic void update_aem2_sensors(struct aem_data *data);\n\nstatic struct aem_driver_data driver_data = {\n\t.aem_devices = LIST_HEAD_INIT(driver_data.aem_devices),\n\t.bmc_events = {\n\t\t.owner = THIS_MODULE,\n\t\t.new_smi = aem_register_bmc,\n\t\t.smi_gone = aem_bmc_gone,\n\t},\n\t.ipmi_hndlrs = {\n\t\t.ipmi_recv_hndl = aem_msg_handler,\n\t},\n};\n\n \n\n \nstatic int aem_init_ipmi_data(struct aem_ipmi_data *data, int iface,\n\t\t\t      struct device *bmc)\n{\n\tint err;\n\n\tinit_completion(&data->read_complete);\n\tdata->bmc_device = bmc;\n\n\t \n\tdata->address.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tdata->address.channel = IPMI_BMC_CHANNEL;\n\tdata->address.data[0] = 0;\n\tdata->interface = iface;\n\n\t \n\tdata->tx_msgid = 0;\n\tdata->tx_message.netfn = AEM_NETFN;\n\n\t \n\terr = ipmi_create_user(data->interface, &driver_data.ipmi_hndlrs,\n\t\t\t       data, &data->user);\n\tif (err < 0) {\n\t\tdev_err(bmc,\n\t\t\t\"Unable to register user with IPMI interface %d\\n\",\n\t\t\tdata->interface);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int aem_send_message(struct aem_ipmi_data *data)\n{\n\tint err;\n\n\terr = ipmi_validate_addr(&data->address, sizeof(data->address));\n\tif (err)\n\t\tgoto out;\n\n\tdata->tx_msgid++;\n\terr = ipmi_request_settime(data->user, &data->address, data->tx_msgid,\n\t\t\t\t   &data->tx_message, data, 0, 0, 0);\n\tif (err)\n\t\tgoto out1;\n\n\treturn 0;\nout1:\n\tdev_err(data->bmc_device, \"request_settime=%x\\n\", err);\n\treturn err;\nout:\n\tdev_err(data->bmc_device, \"validate_addr=%x\\n\", err);\n\treturn err;\n}\n\n \nstatic void aem_msg_handler(struct ipmi_recv_msg *msg, void *user_msg_data)\n{\n\tunsigned short rx_len;\n\tstruct aem_ipmi_data *data = user_msg_data;\n\n\tif (msg->msgid != data->tx_msgid) {\n\t\tdev_err(data->bmc_device,\n\t\t\t\"Mismatch between received msgid (%02x) and transmitted msgid (%02x)!\\n\",\n\t\t\t(int)msg->msgid,\n\t\t\t(int)data->tx_msgid);\n\t\tipmi_free_recv_msg(msg);\n\t\treturn;\n\t}\n\n\tdata->rx_recv_type = msg->recv_type;\n\tif (msg->msg.data_len > 0)\n\t\tdata->rx_result = msg->msg.data[0];\n\telse\n\t\tdata->rx_result = IPMI_UNKNOWN_ERR_COMPLETION_CODE;\n\n\tif (msg->msg.data_len > 1) {\n\t\trx_len = msg->msg.data_len - 1;\n\t\tif (data->rx_msg_len < rx_len)\n\t\t\trx_len = data->rx_msg_len;\n\t\tdata->rx_msg_len = rx_len;\n\t\tmemcpy(data->rx_msg_data, msg->msg.data + 1, data->rx_msg_len);\n\t} else\n\t\tdata->rx_msg_len = 0;\n\n\tipmi_free_recv_msg(msg);\n\tcomplete(&data->read_complete);\n}\n\n \n\n \nstatic int aem_read_sensor(struct aem_data *data, u8 elt, u8 reg,\n\t\t\t   void *buf, size_t size)\n{\n\tint rs_size, res;\n\tstruct aem_read_sensor_req rs_req;\n\t \n\tstruct aem_read_sensor_resp *rs_resp = data->rs_resp;\n\tstruct aem_ipmi_data *ipmi = &data->ipmi;\n\n\t \n\tswitch (size) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trs_req.id = system_x_id;\n\trs_req.module_handle = data->module_handle;\n\trs_req.element = elt;\n\trs_req.subcommand = AEM_READ_REGISTER;\n\trs_req.reg = reg;\n\trs_req.rx_buf_size = size;\n\n\tipmi->tx_message.cmd = AEM_ELEMENT_CMD;\n\tipmi->tx_message.data = (char *)&rs_req;\n\tipmi->tx_message.data_len = sizeof(rs_req);\n\n\trs_size = sizeof(*rs_resp) + size;\n\tipmi->rx_msg_data = rs_resp;\n\tipmi->rx_msg_len = rs_size;\n\n\taem_send_message(ipmi);\n\n\tres = wait_for_completion_timeout(&ipmi->read_complete, IPMI_TIMEOUT);\n\tif (!res) {\n\t\tres = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tif (ipmi->rx_result || ipmi->rx_msg_len != rs_size ||\n\t    memcmp(&rs_resp->id, &system_x_id, sizeof(system_x_id))) {\n\t\tres = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tswitch (size) {\n\tcase 1: {\n\t\tu8 *x = buf;\n\t\t*x = rs_resp->bytes[0];\n\t\tbreak;\n\t}\n\tcase 2: {\n\t\tu16 *x = buf;\n\t\t*x = be16_to_cpup((__be16 *)rs_resp->bytes);\n\t\tbreak;\n\t}\n\tcase 4: {\n\t\tu32 *x = buf;\n\t\t*x = be32_to_cpup((__be32 *)rs_resp->bytes);\n\t\tbreak;\n\t}\n\tcase 8: {\n\t\tu64 *x = buf;\n\t\t*x = be64_to_cpup((__be64 *)rs_resp->bytes);\n\t\tbreak;\n\t}\n\t}\n\tres = 0;\n\nout:\n\treturn res;\n}\n\n \nstatic void update_aem_energy_one(struct aem_data *data, int which)\n{\n\taem_read_sensor(data, AEM_ENERGY_ELEMENT, which,\n\t\t\t&data->energy[which], 8);\n}\n\nstatic void update_aem_energy(struct aem_data *data)\n{\n\tupdate_aem_energy_one(data, 0);\n\tif (data->ver_major < 2)\n\t\treturn;\n\tupdate_aem_energy_one(data, 1);\n}\n\n \nstatic void update_aem1_sensors(struct aem_data *data)\n{\n\tmutex_lock(&data->lock);\n\tif (time_before(jiffies, data->last_updated + REFRESH_INTERVAL) &&\n\t    data->valid)\n\t\tgoto out;\n\n\tupdate_aem_energy(data);\nout:\n\tmutex_unlock(&data->lock);\n}\n\n \nstatic void update_aem2_sensors(struct aem_data *data)\n{\n\tint i;\n\n\tmutex_lock(&data->lock);\n\tif (time_before(jiffies, data->last_updated + REFRESH_INTERVAL) &&\n\t    data->valid)\n\t\tgoto out;\n\n\tupdate_aem_energy(data);\n\taem_read_sensor(data, AEM_EXHAUST_ELEMENT, 0, &data->temp[0], 1);\n\taem_read_sensor(data, AEM_EXHAUST_ELEMENT, 1, &data->temp[1], 1);\n\n\tfor (i = POWER_CAP; i <= POWER_AUX; i++)\n\t\taem_read_sensor(data, AEM_POWER_CAP_ELEMENT, i,\n\t\t\t\t&data->pcap[i], 2);\nout:\n\tmutex_unlock(&data->lock);\n}\n\n \nstatic void aem_delete(struct aem_data *data)\n{\n\tlist_del(&data->list);\n\taem_remove_sensors(data);\n\tkfree(data->rs_resp);\n\thwmon_device_unregister(data->hwmon_dev);\n\tipmi_destroy_user(data->ipmi.user);\n\tplatform_set_drvdata(data->pdev, NULL);\n\tplatform_device_unregister(data->pdev);\n\tida_free(&aem_ida, data->id);\n\tkfree(data);\n}\n\n \n\n \nstatic int aem_find_aem1_count(struct aem_ipmi_data *data)\n{\n\tint res;\n\tstruct aem_find_firmware_req\tff_req;\n\tstruct aem_find_firmware_resp\tff_resp;\n\n\tff_req.id = system_x_id;\n\tff_req.index = 0;\n\tff_req.module_type_id = cpu_to_be16(AEM_MODULE_TYPE_ID);\n\n\tdata->tx_message.cmd = AEM_FIND_FW_CMD;\n\tdata->tx_message.data = (char *)&ff_req;\n\tdata->tx_message.data_len = sizeof(ff_req);\n\n\tdata->rx_msg_data = &ff_resp;\n\tdata->rx_msg_len = sizeof(ff_resp);\n\n\taem_send_message(data);\n\n\tres = wait_for_completion_timeout(&data->read_complete, IPMI_TIMEOUT);\n\tif (!res)\n\t\treturn -ETIMEDOUT;\n\n\tif (data->rx_result || data->rx_msg_len != sizeof(ff_resp) ||\n\t    memcmp(&ff_resp.id, &system_x_id, sizeof(system_x_id)))\n\t\treturn -ENOENT;\n\n\treturn ff_resp.num_instances;\n}\n\n \nstatic int aem_init_aem1_inst(struct aem_ipmi_data *probe, u8 module_handle)\n{\n\tstruct aem_data *data;\n\tint i;\n\tint res = -ENOMEM;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn res;\n\tmutex_init(&data->lock);\n\n\t \n\tdata->ver_major = 1;\n\tdata->ver_minor = 0;\n\tdata->module_handle = module_handle;\n\tfor (i = 0; i < AEM1_NUM_ENERGY_REGS; i++)\n\t\tdata->power_period[i] = AEM_DEFAULT_POWER_INTERVAL;\n\n\t \n\tdata->id = ida_alloc(&aem_ida, GFP_KERNEL);\n\tif (data->id < 0)\n\t\tgoto id_err;\n\n\tdata->pdev = platform_device_alloc(DRVNAME, data->id);\n\tif (!data->pdev)\n\t\tgoto dev_err;\n\tdata->pdev->dev.driver = &aem_driver.driver;\n\n\tres = platform_device_add(data->pdev);\n\tif (res)\n\t\tgoto dev_add_err;\n\n\tplatform_set_drvdata(data->pdev, data);\n\n\t \n\tres = aem_init_ipmi_data(&data->ipmi, probe->interface,\n\t\t\t\t probe->bmc_device);\n\tif (res)\n\t\tgoto ipmi_err;\n\n\t \n\tdata->hwmon_dev = hwmon_device_register(&data->pdev->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\tdev_err(&data->pdev->dev,\n\t\t\t\"Unable to register hwmon device for IPMI interface %d\\n\",\n\t\t\tprobe->interface);\n\t\tres = PTR_ERR(data->hwmon_dev);\n\t\tgoto hwmon_reg_err;\n\t}\n\n\tdata->update = update_aem1_sensors;\n\tdata->rs_resp = kzalloc(sizeof(*(data->rs_resp)) + 8, GFP_KERNEL);\n\tif (!data->rs_resp) {\n\t\tres = -ENOMEM;\n\t\tgoto alloc_resp_err;\n\t}\n\n\t \n\tres = aem1_find_sensors(data);\n\tif (res)\n\t\tgoto sensor_err;\n\n\t \n\tlist_add_tail(&data->list, &driver_data.aem_devices);\n\n\tdev_info(data->ipmi.bmc_device, \"Found AEM v%d.%d at 0x%X\\n\",\n\t\t data->ver_major, data->ver_minor,\n\t\t data->module_handle);\n\treturn 0;\n\nsensor_err:\n\tkfree(data->rs_resp);\nalloc_resp_err:\n\thwmon_device_unregister(data->hwmon_dev);\nhwmon_reg_err:\n\tipmi_destroy_user(data->ipmi.user);\nipmi_err:\n\tplatform_set_drvdata(data->pdev, NULL);\n\tplatform_device_del(data->pdev);\ndev_add_err:\n\tplatform_device_put(data->pdev);\ndev_err:\n\tida_free(&aem_ida, data->id);\nid_err:\n\tkfree(data);\n\n\treturn res;\n}\n\n \nstatic void aem_init_aem1(struct aem_ipmi_data *probe)\n{\n\tint num, i, err;\n\n\tnum = aem_find_aem1_count(probe);\n\tfor (i = 0; i < num; i++) {\n\t\terr = aem_init_aem1_inst(probe, i);\n\t\tif (err) {\n\t\t\tdev_err(probe->bmc_device,\n\t\t\t\t\"Error %d initializing AEM1 0x%X\\n\",\n\t\t\t\terr, i);\n\t\t}\n\t}\n}\n\n \n\n \nstatic int aem_find_aem2(struct aem_ipmi_data *data,\n\t\t\t    struct aem_find_instance_resp *fi_resp,\n\t\t\t    int instance_num)\n{\n\tint res;\n\tstruct aem_find_instance_req fi_req;\n\n\tfi_req.id = system_x_id;\n\tfi_req.instance_number = instance_num;\n\tfi_req.module_type_id = cpu_to_be16(AEM_MODULE_TYPE_ID);\n\n\tdata->tx_message.cmd = AEM_FW_INSTANCE_CMD;\n\tdata->tx_message.data = (char *)&fi_req;\n\tdata->tx_message.data_len = sizeof(fi_req);\n\n\tdata->rx_msg_data = fi_resp;\n\tdata->rx_msg_len = sizeof(*fi_resp);\n\n\taem_send_message(data);\n\n\tres = wait_for_completion_timeout(&data->read_complete, IPMI_TIMEOUT);\n\tif (!res)\n\t\treturn -ETIMEDOUT;\n\n\tif (data->rx_result || data->rx_msg_len != sizeof(*fi_resp) ||\n\t    memcmp(&fi_resp->id, &system_x_id, sizeof(system_x_id)) ||\n\t    fi_resp->num_instances <= instance_num)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\n \nstatic int aem_init_aem2_inst(struct aem_ipmi_data *probe,\n\t\t\t      struct aem_find_instance_resp *fi_resp)\n{\n\tstruct aem_data *data;\n\tint i;\n\tint res = -ENOMEM;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn res;\n\tmutex_init(&data->lock);\n\n\t \n\tdata->ver_major = fi_resp->major;\n\tdata->ver_minor = fi_resp->minor;\n\tdata->module_handle = fi_resp->module_handle;\n\tfor (i = 0; i < AEM2_NUM_ENERGY_REGS; i++)\n\t\tdata->power_period[i] = AEM_DEFAULT_POWER_INTERVAL;\n\n\t \n\tdata->id = ida_alloc(&aem_ida, GFP_KERNEL);\n\tif (data->id < 0)\n\t\tgoto id_err;\n\n\tdata->pdev = platform_device_alloc(DRVNAME, data->id);\n\tif (!data->pdev)\n\t\tgoto dev_err;\n\tdata->pdev->dev.driver = &aem_driver.driver;\n\n\tres = platform_device_add(data->pdev);\n\tif (res)\n\t\tgoto dev_add_err;\n\n\tplatform_set_drvdata(data->pdev, data);\n\n\t \n\tres = aem_init_ipmi_data(&data->ipmi, probe->interface,\n\t\t\t\t probe->bmc_device);\n\tif (res)\n\t\tgoto ipmi_err;\n\n\t \n\tdata->hwmon_dev = hwmon_device_register(&data->pdev->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\tdev_err(&data->pdev->dev,\n\t\t\t\"Unable to register hwmon device for IPMI interface %d\\n\",\n\t\t\tprobe->interface);\n\t\tres = PTR_ERR(data->hwmon_dev);\n\t\tgoto hwmon_reg_err;\n\t}\n\n\tdata->update = update_aem2_sensors;\n\tdata->rs_resp = kzalloc(sizeof(*(data->rs_resp)) + 8, GFP_KERNEL);\n\tif (!data->rs_resp) {\n\t\tres = -ENOMEM;\n\t\tgoto alloc_resp_err;\n\t}\n\n\t \n\tres = aem2_find_sensors(data);\n\tif (res)\n\t\tgoto sensor_err;\n\n\t \n\tlist_add_tail(&data->list, &driver_data.aem_devices);\n\n\tdev_info(data->ipmi.bmc_device, \"Found AEM v%d.%d at 0x%X\\n\",\n\t\t data->ver_major, data->ver_minor,\n\t\t data->module_handle);\n\treturn 0;\n\nsensor_err:\n\tkfree(data->rs_resp);\nalloc_resp_err:\n\thwmon_device_unregister(data->hwmon_dev);\nhwmon_reg_err:\n\tipmi_destroy_user(data->ipmi.user);\nipmi_err:\n\tplatform_set_drvdata(data->pdev, NULL);\n\tplatform_device_del(data->pdev);\ndev_add_err:\n\tplatform_device_put(data->pdev);\ndev_err:\n\tida_free(&aem_ida, data->id);\nid_err:\n\tkfree(data);\n\n\treturn res;\n}\n\n \nstatic void aem_init_aem2(struct aem_ipmi_data *probe)\n{\n\tstruct aem_find_instance_resp fi_resp;\n\tint err;\n\tint i = 0;\n\n\twhile (!aem_find_aem2(probe, &fi_resp, i)) {\n\t\tif (fi_resp.major != 2) {\n\t\t\tdev_err(probe->bmc_device,\n\t\t\t\t\"Unknown AEM v%d; please report this to the maintainer.\\n\",\n\t\t\t\tfi_resp.major);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = aem_init_aem2_inst(probe, &fi_resp);\n\t\tif (err) {\n\t\t\tdev_err(probe->bmc_device,\n\t\t\t\t\"Error %d initializing AEM2 0x%X\\n\",\n\t\t\t\terr, fi_resp.module_handle);\n\t\t}\n\t\ti++;\n\t}\n}\n\n \nstatic void aem_register_bmc(int iface, struct device *dev)\n{\n\tstruct aem_ipmi_data probe;\n\n\tif (aem_init_ipmi_data(&probe, iface, dev))\n\t\treturn;\n\n\t \n\taem_init_aem1(&probe);\n\taem_init_aem2(&probe);\n\n\tipmi_destroy_user(probe.user);\n}\n\n \nstatic void aem_bmc_gone(int iface)\n{\n\tstruct aem_data *p1, *next1;\n\n\tlist_for_each_entry_safe(p1, next1, &driver_data.aem_devices, list)\n\t\tif (p1->ipmi.interface == iface)\n\t\t\taem_delete(p1);\n}\n\n \n\n \nstatic ssize_t name_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct aem_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s%d\\n\", DRVNAME, data->ver_major);\n}\nstatic SENSOR_DEVICE_ATTR_RO(name, name, 0);\n\n \nstatic ssize_t version_show(struct device *dev,\n\t\t\t    struct device_attribute *devattr, char *buf)\n{\n\tstruct aem_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d.%d\\n\", data->ver_major, data->ver_minor);\n}\nstatic SENSOR_DEVICE_ATTR_RO(version, version, 0);\n\n \nstatic ssize_t aem_show_power(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct aem_data *data = dev_get_drvdata(dev);\n\tu64 before, after, delta, time;\n\tsigned long leftover;\n\n\tmutex_lock(&data->lock);\n\tupdate_aem_energy_one(data, attr->index);\n\ttime = ktime_get_ns();\n\tbefore = data->energy[attr->index];\n\n\tleftover = schedule_timeout_interruptible(\n\t\t\tmsecs_to_jiffies(data->power_period[attr->index])\n\t\t   );\n\tif (leftover) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn 0;\n\t}\n\n\tupdate_aem_energy_one(data, attr->index);\n\ttime = ktime_get_ns() - time;\n\tafter = data->energy[attr->index];\n\tmutex_unlock(&data->lock);\n\n\tdelta = (after - before) * UJ_PER_MJ;\n\n\treturn sprintf(buf, \"%llu\\n\",\n\t\t(unsigned long long)div64_u64(delta * NSEC_PER_SEC, time));\n}\n\n \nstatic ssize_t aem_show_energy(struct device *dev,\n\t\t\t       struct device_attribute *devattr,\n\t\t\t       char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct aem_data *a = dev_get_drvdata(dev);\n\tmutex_lock(&a->lock);\n\tupdate_aem_energy_one(a, attr->index);\n\tmutex_unlock(&a->lock);\n\n\treturn sprintf(buf, \"%llu\\n\",\n\t\t\t(unsigned long long)a->energy[attr->index] * 1000);\n}\n\n \nstatic ssize_t aem_show_power_period(struct device *dev,\n\t\t\t\t     struct device_attribute *devattr,\n\t\t\t\t     char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct aem_data *a = dev_get_drvdata(dev);\n\ta->update(a);\n\n\treturn sprintf(buf, \"%lu\\n\", a->power_period[attr->index]);\n}\n\n \nstatic ssize_t aem_set_power_period(struct device *dev,\n\t\t\t\t    struct device_attribute *devattr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct aem_data *a = dev_get_drvdata(dev);\n\tunsigned long temp;\n\tint res;\n\n\tres = kstrtoul(buf, 10, &temp);\n\tif (res)\n\t\treturn res;\n\n\tif (temp < AEM_MIN_POWER_INTERVAL)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&a->lock);\n\ta->power_period[attr->index] = temp;\n\tmutex_unlock(&a->lock);\n\n\treturn count;\n}\n\n \nstatic int aem_register_sensors(struct aem_data *data,\n\t\t\t\tconst struct aem_ro_sensor_template *ro,\n\t\t\t\tconst struct aem_rw_sensor_template *rw)\n{\n\tstruct device *dev = &data->pdev->dev;\n\tstruct sensor_device_attribute *sensors = data->sensors;\n\tint err;\n\n\t \n\twhile (ro->label) {\n\t\tsysfs_attr_init(&sensors->dev_attr.attr);\n\t\tsensors->dev_attr.attr.name = ro->label;\n\t\tsensors->dev_attr.attr.mode = 0444;\n\t\tsensors->dev_attr.show = ro->show;\n\t\tsensors->index = ro->index;\n\n\t\terr = device_create_file(dev, &sensors->dev_attr);\n\t\tif (err) {\n\t\t\tsensors->dev_attr.attr.name = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\tsensors++;\n\t\tro++;\n\t}\n\n\t \n\twhile (rw->label) {\n\t\tsysfs_attr_init(&sensors->dev_attr.attr);\n\t\tsensors->dev_attr.attr.name = rw->label;\n\t\tsensors->dev_attr.attr.mode = 0644;\n\t\tsensors->dev_attr.show = rw->show;\n\t\tsensors->dev_attr.store = rw->set;\n\t\tsensors->index = rw->index;\n\n\t\terr = device_create_file(dev, &sensors->dev_attr);\n\t\tif (err) {\n\t\t\tsensors->dev_attr.attr.name = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\tsensors++;\n\t\trw++;\n\t}\n\n\terr = device_create_file(dev, &sensor_dev_attr_name.dev_attr);\n\tif (err)\n\t\tgoto error;\n\terr = device_create_file(dev, &sensor_dev_attr_version.dev_attr);\n\treturn err;\n\nerror:\n\taem_remove_sensors(data);\n\treturn err;\n}\n\n \n\n \nstatic ssize_t aem2_show_temp(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct aem_data *a = dev_get_drvdata(dev);\n\ta->update(a);\n\n\treturn sprintf(buf, \"%u\\n\", a->temp[attr->index] * 1000);\n}\n\n \nstatic ssize_t aem2_show_pcap_value(struct device *dev,\n\t\t\t\t    struct device_attribute *devattr,\n\t\t\t\t    char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct aem_data *a = dev_get_drvdata(dev);\n\ta->update(a);\n\n\treturn sprintf(buf, \"%u\\n\", a->pcap[attr->index] * 100000);\n}\n\n \nstatic void aem_remove_sensors(struct aem_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < AEM_NUM_SENSORS; i++) {\n\t\tif (!data->sensors[i].dev_attr.attr.name)\n\t\t\tcontinue;\n\t\tdevice_remove_file(&data->pdev->dev,\n\t\t\t\t   &data->sensors[i].dev_attr);\n\t}\n\n\tdevice_remove_file(&data->pdev->dev,\n\t\t\t   &sensor_dev_attr_name.dev_attr);\n\tdevice_remove_file(&data->pdev->dev,\n\t\t\t   &sensor_dev_attr_version.dev_attr);\n}\n\n \n\n \nstatic const struct aem_ro_sensor_template aem1_ro_sensors[] = {\n{\"energy1_input\",  aem_show_energy, 0},\n{\"power1_average\", aem_show_power,  0},\n{NULL,\t\t   NULL,\t    0},\n};\n\nstatic const struct aem_rw_sensor_template aem1_rw_sensors[] = {\n{\"power1_average_interval\", aem_show_power_period, aem_set_power_period, 0},\n{NULL,\t\t\t    NULL,                  NULL,                 0},\n};\n\n \nstatic const struct aem_ro_sensor_template aem2_ro_sensors[] = {\n{\"energy1_input\",\t  aem_show_energy,\t0},\n{\"energy2_input\",\t  aem_show_energy,\t1},\n{\"power1_average\",\t  aem_show_power,\t0},\n{\"power2_average\",\t  aem_show_power,\t1},\n{\"temp1_input\",\t\t  aem2_show_temp,\t0},\n{\"temp2_input\",\t\t  aem2_show_temp,\t1},\n\n{\"power4_average\",\t  aem2_show_pcap_value,\tPOWER_CAP_MAX_HOTPLUG},\n{\"power5_average\",\t  aem2_show_pcap_value,\tPOWER_CAP_MAX},\n{\"power6_average\",\t  aem2_show_pcap_value,\tPOWER_CAP_MIN_WARNING},\n{\"power7_average\",\t  aem2_show_pcap_value,\tPOWER_CAP_MIN},\n\n{\"power3_average\",\t  aem2_show_pcap_value,\tPOWER_AUX},\n{\"power_cap\",\t\t  aem2_show_pcap_value,\tPOWER_CAP},\n{NULL,                    NULL,                 0},\n};\n\nstatic const struct aem_rw_sensor_template aem2_rw_sensors[] = {\n{\"power1_average_interval\", aem_show_power_period, aem_set_power_period, 0},\n{\"power2_average_interval\", aem_show_power_period, aem_set_power_period, 1},\n{NULL,\t\t\t    NULL,                  NULL,                 0},\n};\n\n \nstatic int aem1_find_sensors(struct aem_data *data)\n{\n\treturn aem_register_sensors(data, aem1_ro_sensors, aem1_rw_sensors);\n}\n\n \nstatic int aem2_find_sensors(struct aem_data *data)\n{\n\treturn aem_register_sensors(data, aem2_ro_sensors, aem2_rw_sensors);\n}\n\n \n\nstatic int __init aem_init(void)\n{\n\tint res;\n\n\tres = driver_register(&aem_driver.driver);\n\tif (res) {\n\t\tpr_err(\"Can't register aem driver\\n\");\n\t\treturn res;\n\t}\n\n\tres = ipmi_smi_watcher_register(&driver_data.bmc_events);\n\tif (res)\n\t\tgoto ipmi_reg_err;\n\treturn 0;\n\nipmi_reg_err:\n\tdriver_unregister(&aem_driver.driver);\n\treturn res;\n\n}\n\nstatic void __exit aem_exit(void)\n{\n\tstruct aem_data *p1, *next1;\n\n\tipmi_smi_watcher_unregister(&driver_data.bmc_events);\n\tdriver_unregister(&aem_driver.driver);\n\tlist_for_each_entry_safe(p1, next1, &driver_data.aem_devices, list)\n\t\taem_delete(p1);\n}\n\nMODULE_AUTHOR(\"Darrick J. Wong <darrick.wong@oracle.com>\");\nMODULE_DESCRIPTION(\"IBM AEM power/temp/energy sensor driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(aem_init);\nmodule_exit(aem_exit);\n\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMSystemx3350-*\");\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMSystemx3550-*\");\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMSystemx3650-*\");\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMSystemx3655-*\");\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMSystemx3755-*\");\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBM3850M2/x3950M2-*\");\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMBladeHC10-*\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}