{
  "module_name": "sl28cpld-hwmon.c",
  "hash_id": "f4631cd9aedae059c36562d31166c1611cbd150a31bd313d4600073f2e2cc147",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/sl28cpld-hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/hwmon.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n#define FAN_INPUT\t\t0x00\n#define   FAN_SCALE_X8\t\tBIT(7)\n#define   FAN_VALUE_MASK\tGENMASK(6, 0)\n\nstruct sl28cpld_hwmon {\n\tstruct regmap *regmap;\n\tu32 offset;\n};\n\nstatic umode_t sl28cpld_hwmon_is_visible(const void *data,\n\t\t\t\t\t enum hwmon_sensor_types type,\n\t\t\t\t\t u32 attr, int channel)\n{\n\treturn 0444;\n}\n\nstatic int sl28cpld_hwmon_read(struct device *dev,\n\t\t\t       enum hwmon_sensor_types type, u32 attr,\n\t\t\t       int channel, long *input)\n{\n\tstruct sl28cpld_hwmon *hwmon = dev_get_drvdata(dev);\n\tunsigned int value;\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\t\tret = regmap_read(hwmon->regmap, hwmon->offset + FAN_INPUT,\n\t\t\t\t  &value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tif (value & FAN_SCALE_X8)\n\t\t\tvalue = FIELD_GET(FAN_VALUE_MASK, value) << 3;\n\n\t\t \n\t\tvalue *= 60 / 2;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*input = value;\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const sl28cpld_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(fan, HWMON_F_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops sl28cpld_hwmon_ops = {\n\t.is_visible = sl28cpld_hwmon_is_visible,\n\t.read = sl28cpld_hwmon_read,\n};\n\nstatic const struct hwmon_chip_info sl28cpld_hwmon_chip_info = {\n\t.ops = &sl28cpld_hwmon_ops,\n\t.info = sl28cpld_hwmon_info,\n};\n\nstatic int sl28cpld_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct sl28cpld_hwmon *hwmon;\n\tstruct device *hwmon_dev;\n\tint ret;\n\n\tif (!pdev->dev.parent)\n\t\treturn -ENODEV;\n\n\thwmon = devm_kzalloc(&pdev->dev, sizeof(*hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn -ENOMEM;\n\n\thwmon->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!hwmon->regmap)\n\t\treturn -ENODEV;\n\n\tret = device_property_read_u32(&pdev->dev, \"reg\", &hwmon->offset);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&pdev->dev,\n\t\t\t\t\"sl28cpld_hwmon\", hwmon,\n\t\t\t\t&sl28cpld_hwmon_chip_info, NULL);\n\tif (IS_ERR(hwmon_dev))\n\t\tdev_err(&pdev->dev, \"failed to register as hwmon device\");\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct of_device_id sl28cpld_hwmon_of_match[] = {\n\t{ .compatible = \"kontron,sl28cpld-fan\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sl28cpld_hwmon_of_match);\n\nstatic struct platform_driver sl28cpld_hwmon_driver = {\n\t.probe = sl28cpld_hwmon_probe,\n\t.driver = {\n\t\t.name = \"sl28cpld-fan\",\n\t\t.of_match_table = sl28cpld_hwmon_of_match,\n\t},\n};\nmodule_platform_driver(sl28cpld_hwmon_driver);\n\nMODULE_DESCRIPTION(\"sl28cpld Hardware Monitoring Driver\");\nMODULE_AUTHOR(\"Michael Walle <michael@walle.cc>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}