{
  "module_name": "nzxt-kraken2.c",
  "hash_id": "dcd5b342b572b0bd94dfa703d3cdf27071108e2acef018238525536290ae928c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/nzxt-kraken2.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/hid.h>\n#include <linux/hwmon.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\n#define STATUS_REPORT_ID\t0x04\n#define STATUS_VALIDITY\t\t2  \n\nstatic const char *const kraken2_temp_label[] = {\n\t\"Coolant\",\n};\n\nstatic const char *const kraken2_fan_label[] = {\n\t\"Fan\",\n\t\"Pump\",\n};\n\nstruct kraken2_priv_data {\n\tstruct hid_device *hid_dev;\n\tstruct device *hwmon_dev;\n\ts32 temp_input[1];\n\tu16 fan_input[2];\n\tunsigned long updated;  \n};\n\nstatic umode_t kraken2_is_visible(const void *data,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\treturn 0444;\n}\n\nstatic int kraken2_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct kraken2_priv_data *priv = dev_get_drvdata(dev);\n\n\tif (time_after(jiffies, priv->updated + STATUS_VALIDITY * HZ))\n\t\treturn -ENODATA;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\t*val = priv->temp_input[channel];\n\t\tbreak;\n\tcase hwmon_fan:\n\t\t*val = priv->fan_input[channel];\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;  \n\t}\n\n\treturn 0;\n}\n\nstatic int kraken2_read_string(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t       u32 attr, int channel, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\t*str = kraken2_temp_label[channel];\n\t\tbreak;\n\tcase hwmon_fan:\n\t\t*str = kraken2_fan_label[channel];\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;  \n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_ops kraken2_hwmon_ops = {\n\t.is_visible = kraken2_is_visible,\n\t.read = kraken2_read,\n\t.read_string = kraken2_read_string,\n};\n\nstatic const struct hwmon_channel_info * const kraken2_info[] = {\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL),\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info kraken2_chip_info = {\n\t.ops = &kraken2_hwmon_ops,\n\t.info = kraken2_info,\n};\n\nstatic int kraken2_raw_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data, int size)\n{\n\tstruct kraken2_priv_data *priv;\n\n\tif (size < 7 || report->id != STATUS_REPORT_ID)\n\t\treturn 0;\n\n\tpriv = hid_get_drvdata(hdev);\n\n\t \n\tpriv->temp_input[0] = data[1] * 1000 + data[2] * 100;\n\n\tpriv->fan_input[0] = get_unaligned_be16(data + 3);\n\tpriv->fan_input[1] = get_unaligned_be16(data + 5);\n\n\tpriv->updated = jiffies;\n\n\treturn 0;\n}\n\nstatic int kraken2_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct kraken2_priv_data *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&hdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->hid_dev = hdev;\n\thid_set_drvdata(hdev, priv);\n\n\t \n\tpriv->updated = jiffies - STATUS_VALIDITY * HZ;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"hid parse failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret) {\n\t\thid_err(hdev, \"hid hw start failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"hid hw open failed with %d\\n\", ret);\n\t\tgoto fail_and_stop;\n\t}\n\n\tpriv->hwmon_dev = hwmon_device_register_with_info(&hdev->dev, \"kraken2\",\n\t\t\t\t\t\t\t  priv, &kraken2_chip_info,\n\t\t\t\t\t\t\t  NULL);\n\tif (IS_ERR(priv->hwmon_dev)) {\n\t\tret = PTR_ERR(priv->hwmon_dev);\n\t\thid_err(hdev, \"hwmon registration failed with %d\\n\", ret);\n\t\tgoto fail_and_close;\n\t}\n\n\treturn 0;\n\nfail_and_close:\n\thid_hw_close(hdev);\nfail_and_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void kraken2_remove(struct hid_device *hdev)\n{\n\tstruct kraken2_priv_data *priv = hid_get_drvdata(hdev);\n\n\thwmon_device_unregister(priv->hwmon_dev);\n\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic const struct hid_device_id kraken2_table[] = {\n\t{ HID_USB_DEVICE(0x1e71, 0x170e) },  \n\t{ }\n};\n\nMODULE_DEVICE_TABLE(hid, kraken2_table);\n\nstatic struct hid_driver kraken2_driver = {\n\t.name = \"nzxt-kraken2\",\n\t.id_table = kraken2_table,\n\t.probe = kraken2_probe,\n\t.remove = kraken2_remove,\n\t.raw_event = kraken2_raw_event,\n};\n\nstatic int __init kraken2_init(void)\n{\n\treturn hid_register_driver(&kraken2_driver);\n}\n\nstatic void __exit kraken2_exit(void)\n{\n\thid_unregister_driver(&kraken2_driver);\n}\n\n \nlate_initcall(kraken2_init);\nmodule_exit(kraken2_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jonas Malaco <jonas@protocubo.io>\");\nMODULE_DESCRIPTION(\"Hwmon driver for NZXT Kraken X42/X52/X62/X72 coolers\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}