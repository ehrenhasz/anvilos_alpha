{
  "module_name": "g760a.c",
  "hash_id": "40eb7f8f8d0212e5fe4203a58f183504c0c00884f9c82efbb7b315d7081746c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/g760a.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n\nenum g760a_regs {\n\tG760A_REG_SET_CNT = 0x00,\n\tG760A_REG_ACT_CNT = 0x01,\n\tG760A_REG_FAN_STA = 0x02\n};\n\n#define G760A_REG_FAN_STA_RPM_OFF 0x1  \n#define G760A_REG_FAN_STA_RPM_LOW 0x2  \n\n \n#define G760A_UPDATE_INTERVAL (HZ)\n\nstruct g760a_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\n\t \n\tu32 clk;  \n\tu16 fan_div;  \n\n\t \n\tunsigned int valid:1;\n\tunsigned long last_updated;  \n\n\tu8 set_cnt;  \n\tu8 act_cnt;  \n\tu8 fan_sta;  \n};\n\n#define G760A_DEFAULT_CLK 32768\n#define G760A_DEFAULT_FAN_DIV 2\n\n#define PWM_FROM_CNT(cnt)\t(0xff-(cnt))\n#define PWM_TO_CNT(pwm)\t\t(0xff-(pwm))\n\nstatic inline unsigned int rpm_from_cnt(u8 val, u32 clk, u16 div)\n{\n\treturn ((val == 0x00) ? 0 : ((clk*30)/(val*div)));\n}\n\n \nstatic int g760a_read_value(struct i2c_client *client, enum g760a_regs reg)\n{\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic int g760a_write_value(struct i2c_client *client, enum g760a_regs reg,\n\t\t\t     u16 value)\n{\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\n \n\nstatic struct g760a_data *g760a_update_client(struct device *dev)\n{\n\tstruct g760a_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + G760A_UPDATE_INTERVAL)\n\t    || !data->valid) {\n\t\tdev_dbg(&client->dev, \"Starting g760a update\\n\");\n\n\t\tdata->set_cnt = g760a_read_value(client, G760A_REG_SET_CNT);\n\t\tdata->act_cnt = g760a_read_value(client, G760A_REG_ACT_CNT);\n\t\tdata->fan_sta = g760a_read_value(client, G760A_REG_FAN_STA);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\nstatic ssize_t fan1_input_show(struct device *dev,\n\t\t\t       struct device_attribute *da, char *buf)\n{\n\tstruct g760a_data *data = g760a_update_client(dev);\n\tunsigned int rpm = 0;\n\n\tmutex_lock(&data->update_lock);\n\tif (!(data->fan_sta & G760A_REG_FAN_STA_RPM_LOW))\n\t\trpm = rpm_from_cnt(data->act_cnt, data->clk, data->fan_div);\n\tmutex_unlock(&data->update_lock);\n\n\treturn sprintf(buf, \"%d\\n\", rpm);\n}\n\nstatic ssize_t fan1_alarm_show(struct device *dev,\n\t\t\t       struct device_attribute *da, char *buf)\n{\n\tstruct g760a_data *data = g760a_update_client(dev);\n\n\tint fan_alarm = (data->fan_sta & G760A_REG_FAN_STA_RPM_OFF) ? 1 : 0;\n\n\treturn sprintf(buf, \"%d\\n\", fan_alarm);\n}\n\nstatic ssize_t pwm1_show(struct device *dev, struct device_attribute *da,\n\t\t\t char *buf)\n{\n\tstruct g760a_data *data = g760a_update_client(dev);\n\n\treturn sprintf(buf, \"%d\\n\", PWM_FROM_CNT(data->set_cnt));\n}\n\nstatic ssize_t pwm1_store(struct device *dev, struct device_attribute *da,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct g760a_data *data = g760a_update_client(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->set_cnt = PWM_TO_CNT(clamp_val(val, 0, 255));\n\tg760a_write_value(client, G760A_REG_SET_CNT, data->set_cnt);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(pwm1);\nstatic DEVICE_ATTR_RO(fan1_input);\nstatic DEVICE_ATTR_RO(fan1_alarm);\n\nstatic struct attribute *g760a_attrs[] = {\n\t&dev_attr_pwm1.attr,\n\t&dev_attr_fan1_input.attr,\n\t&dev_attr_fan1_alarm.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(g760a);\n\n \n\nstatic int g760a_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct g760a_data *data;\n\tstruct device *hwmon_dev;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tdata = devm_kzalloc(dev, sizeof(struct g760a_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tdata->fan_div = G760A_DEFAULT_FAN_DIV;\n\tdata->clk = G760A_DEFAULT_CLK;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   g760a_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id g760a_id[] = {\n\t{ \"g760a\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, g760a_id);\n\nstatic struct i2c_driver g760a_driver = {\n\t.driver = {\n\t\t.name\t= \"g760a\",\n\t},\n\t.probe = g760a_probe,\n\t.id_table = g760a_id,\n};\n\nmodule_i2c_driver(g760a_driver);\n\nMODULE_AUTHOR(\"Herbert Valerio Riedel <hvr@gnu.org>\");\nMODULE_DESCRIPTION(\"GMT G760A driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}