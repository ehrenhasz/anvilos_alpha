{
  "module_name": "corsair-cpro.c",
  "hash_id": "a91d1febf624984c8a5b64e306b9edbfa5dd3dd3d67cb94e8f79e685d519f86e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/corsair-cpro.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/completion.h>\n#include <linux/hid.h>\n#include <linux/hwmon.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define USB_VENDOR_ID_CORSAIR\t\t\t0x1b1c\n#define USB_PRODUCT_ID_CORSAIR_COMMANDERPRO\t0x0c10\n#define USB_PRODUCT_ID_CORSAIR_1000D\t\t0x1d00\n\n#define OUT_BUFFER_SIZE\t\t63\n#define IN_BUFFER_SIZE\t\t16\n#define LABEL_LENGTH\t\t11\n#define REQ_TIMEOUT\t\t300\n\n#define CTL_GET_TMP_CNCT\t0x10\t \n#define CTL_GET_TMP\t\t0x11\t \n#define CTL_GET_VOLT\t\t0x12\t \n#define CTL_GET_FAN_CNCT\t0x20\t \n#define CTL_GET_FAN_RPM\t\t0x21\t \n#define CTL_GET_FAN_PWM\t\t0x22\t \n#define CTL_SET_FAN_FPWM\t0x23\t \n#define CTL_SET_FAN_TARGET\t0x24\t \n\n#define NUM_FANS\t\t6\n#define NUM_TEMP_SENSORS\t4\n\nstruct ccp_device {\n\tstruct hid_device *hdev;\n\tstruct device *hwmon_dev;\n\tstruct completion wait_input_report;\n\tstruct mutex mutex;  \n\tu8 *buffer;\n\tint target[6];\n\tDECLARE_BITMAP(temp_cnct, NUM_TEMP_SENSORS);\n\tDECLARE_BITMAP(fan_cnct, NUM_FANS);\n\tchar fan_label[6][LABEL_LENGTH];\n};\n\n \nstatic int ccp_get_errno(struct ccp_device *ccp)\n{\n\tswitch (ccp->buffer[0]) {\n\tcase 0x00:  \n\t\treturn 0;\n\tcase 0x01:  \n\t\treturn -EOPNOTSUPP;\n\tcase 0x10:  \n\t\treturn -EINVAL;\n\tcase 0x11:  \n\tcase 0x12:  \n\t\treturn -ENODATA;\n\tdefault:\n\t\thid_dbg(ccp->hdev, \"unknown device response error: %d\", ccp->buffer[0]);\n\t\treturn -EIO;\n\t}\n}\n\n \nstatic int send_usb_cmd(struct ccp_device *ccp, u8 command, u8 byte1, u8 byte2, u8 byte3)\n{\n\tunsigned long t;\n\tint ret;\n\n\tmemset(ccp->buffer, 0x00, OUT_BUFFER_SIZE);\n\tccp->buffer[0] = command;\n\tccp->buffer[1] = byte1;\n\tccp->buffer[2] = byte2;\n\tccp->buffer[3] = byte3;\n\n\treinit_completion(&ccp->wait_input_report);\n\n\tret = hid_hw_output_report(ccp->hdev, ccp->buffer, OUT_BUFFER_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tt = wait_for_completion_timeout(&ccp->wait_input_report, msecs_to_jiffies(REQ_TIMEOUT));\n\tif (!t)\n\t\treturn -ETIMEDOUT;\n\n\treturn ccp_get_errno(ccp);\n}\n\nstatic int ccp_raw_event(struct hid_device *hdev, struct hid_report *report, u8 *data, int size)\n{\n\tstruct ccp_device *ccp = hid_get_drvdata(hdev);\n\n\t \n\tif (completion_done(&ccp->wait_input_report))\n\t\treturn 0;\n\n\tmemcpy(ccp->buffer, data, min(IN_BUFFER_SIZE, size));\n\tcomplete(&ccp->wait_input_report);\n\n\treturn 0;\n}\n\n \nstatic int get_data(struct ccp_device *ccp, int command, int channel, bool two_byte_data)\n{\n\tint ret;\n\n\tmutex_lock(&ccp->mutex);\n\n\tret = send_usb_cmd(ccp, command, channel, 0, 0);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = ccp->buffer[1];\n\tif (two_byte_data)\n\t\tret = (ret << 8) + ccp->buffer[2];\n\nout_unlock:\n\tmutex_unlock(&ccp->mutex);\n\treturn ret;\n}\n\nstatic int set_pwm(struct ccp_device *ccp, int channel, long val)\n{\n\tint ret;\n\n\tif (val < 0 || val > 255)\n\t\treturn -EINVAL;\n\n\t \n\tval = DIV_ROUND_CLOSEST(val * 100, 255);\n\n\tmutex_lock(&ccp->mutex);\n\n\tret = send_usb_cmd(ccp, CTL_SET_FAN_FPWM, channel, val, 0);\n\tif (!ret)\n\t\tccp->target[channel] = -ENODATA;\n\n\tmutex_unlock(&ccp->mutex);\n\treturn ret;\n}\n\nstatic int set_target(struct ccp_device *ccp, int channel, long val)\n{\n\tint ret;\n\n\tval = clamp_val(val, 0, 0xFFFF);\n\tccp->target[channel] = val;\n\n\tmutex_lock(&ccp->mutex);\n\tret = send_usb_cmd(ccp, CTL_SET_FAN_TARGET, channel, val >> 8, val);\n\n\tmutex_unlock(&ccp->mutex);\n\treturn ret;\n}\n\nstatic int ccp_read_string(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t   u32 attr, int channel, const char **str)\n{\n\tstruct ccp_device *ccp = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_label:\n\t\t\t*str = ccp->fan_label[channel];\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ccp_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t    u32 attr, int channel, long *val)\n{\n\tstruct ccp_device *ccp = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\tret = get_data(ccp, CTL_GET_TMP, channel, true);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret * 10;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\tret = get_data(ccp, CTL_GET_FAN_RPM, channel, true);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\treturn 0;\n\t\tcase hwmon_fan_target:\n\t\t\t \n\t\t\t \n\t\t\tif (ccp->target[channel] < 0)\n\t\t\t\treturn -ENODATA;\n\t\t\t*val = ccp->target[channel];\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\tret = get_data(ccp, CTL_GET_FAN_PWM, channel, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = DIV_ROUND_CLOSEST(ret * 255, 100);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\tret = get_data(ccp, CTL_GET_VOLT, channel, true);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n};\n\nstatic int ccp_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t     u32 attr, int channel, long val)\n{\n\tstruct ccp_device *ccp = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\treturn set_pwm(ccp, channel, val);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_target:\n\t\t\treturn set_target(ccp, channel, val);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n};\n\nstatic umode_t ccp_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel)\n{\n\tconst struct ccp_device *ccp = data;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tif (!test_bit(channel, ccp->temp_cnct))\n\t\t\tbreak;\n\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_label:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tif (!test_bit(channel, ccp->fan_cnct))\n\t\t\tbreak;\n\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\treturn 0444;\n\t\tcase hwmon_fan_label:\n\t\t\treturn 0444;\n\t\tcase hwmon_fan_target:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tif (!test_bit(channel, ccp->fan_cnct))\n\t\t\tbreak;\n\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n};\n\nstatic const struct hwmon_ops ccp_hwmon_ops = {\n\t.is_visible = ccp_is_visible,\n\t.read = ccp_read,\n\t.read_string = ccp_read_string,\n\t.write = ccp_write,\n};\n\nstatic const struct hwmon_channel_info * const ccp_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT,\n\t\t\t   HWMON_T_INPUT,\n\t\t\t   HWMON_T_INPUT,\n\t\t\t   HWMON_T_INPUT\n\t\t\t   ),\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_TARGET,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_TARGET,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_TARGET,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_TARGET,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_TARGET,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_TARGET\n\t\t\t   ),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT\n\t\t\t   ),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT,\n\t\t\t   HWMON_I_INPUT,\n\t\t\t   HWMON_I_INPUT\n\t\t\t   ),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info ccp_chip_info = {\n\t.ops = &ccp_hwmon_ops,\n\t.info = ccp_info,\n};\n\n \nstatic int get_fan_cnct(struct ccp_device *ccp)\n{\n\tint channel;\n\tint mode;\n\tint ret;\n\n\tret = send_usb_cmd(ccp, CTL_GET_FAN_CNCT, 0, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (channel = 0; channel < NUM_FANS; channel++) {\n\t\tmode = ccp->buffer[channel + 1];\n\t\tif (mode == 0)\n\t\t\tcontinue;\n\n\t\tset_bit(channel, ccp->fan_cnct);\n\t\tccp->target[channel] = -ENODATA;\n\n\t\tswitch (mode) {\n\t\tcase 1:\n\t\t\tscnprintf(ccp->fan_label[channel], LABEL_LENGTH,\n\t\t\t\t  \"fan%d 3pin\", channel + 1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tscnprintf(ccp->fan_label[channel], LABEL_LENGTH,\n\t\t\t\t  \"fan%d 4pin\", channel + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tscnprintf(ccp->fan_label[channel], LABEL_LENGTH,\n\t\t\t\t  \"fan%d other\", channel + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int get_temp_cnct(struct ccp_device *ccp)\n{\n\tint channel;\n\tint mode;\n\tint ret;\n\n\tret = send_usb_cmd(ccp, CTL_GET_TMP_CNCT, 0, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (channel = 0; channel < NUM_TEMP_SENSORS; channel++) {\n\t\tmode = ccp->buffer[channel + 1];\n\t\tif (mode == 0)\n\t\t\tcontinue;\n\n\t\tset_bit(channel, ccp->temp_cnct);\n\t}\n\n\treturn 0;\n}\n\nstatic int ccp_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct ccp_device *ccp;\n\tint ret;\n\n\tccp = devm_kzalloc(&hdev->dev, sizeof(*ccp), GFP_KERNEL);\n\tif (!ccp)\n\t\treturn -ENOMEM;\n\n\tccp->buffer = devm_kmalloc(&hdev->dev, OUT_BUFFER_SIZE, GFP_KERNEL);\n\tif (!ccp->buffer)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hid_hw_open(hdev);\n\tif (ret)\n\t\tgoto out_hw_stop;\n\n\tccp->hdev = hdev;\n\thid_set_drvdata(hdev, ccp);\n\tmutex_init(&ccp->mutex);\n\tinit_completion(&ccp->wait_input_report);\n\n\thid_device_io_start(hdev);\n\n\t \n\tret = get_temp_cnct(ccp);\n\tif (ret)\n\t\tgoto out_hw_close;\n\n\tret = get_fan_cnct(ccp);\n\tif (ret)\n\t\tgoto out_hw_close;\n\tccp->hwmon_dev = hwmon_device_register_with_info(&hdev->dev, \"corsaircpro\",\n\t\t\t\t\t\t\t ccp, &ccp_chip_info, 0);\n\tif (IS_ERR(ccp->hwmon_dev)) {\n\t\tret = PTR_ERR(ccp->hwmon_dev);\n\t\tgoto out_hw_close;\n\t}\n\n\treturn 0;\n\nout_hw_close:\n\thid_hw_close(hdev);\nout_hw_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void ccp_remove(struct hid_device *hdev)\n{\n\tstruct ccp_device *ccp = hid_get_drvdata(hdev);\n\n\thwmon_device_unregister(ccp->hwmon_dev);\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic const struct hid_device_id ccp_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR, USB_PRODUCT_ID_CORSAIR_COMMANDERPRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR, USB_PRODUCT_ID_CORSAIR_1000D) },\n\t{ }\n};\n\nstatic struct hid_driver ccp_driver = {\n\t.name = \"corsair-cpro\",\n\t.id_table = ccp_devices,\n\t.probe = ccp_probe,\n\t.remove = ccp_remove,\n\t.raw_event = ccp_raw_event,\n};\n\nMODULE_DEVICE_TABLE(hid, ccp_devices);\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init ccp_init(void)\n{\n\treturn hid_register_driver(&ccp_driver);\n}\n\nstatic void __exit ccp_exit(void)\n{\n\thid_unregister_driver(&ccp_driver);\n}\n\n \nlate_initcall(ccp_init);\nmodule_exit(ccp_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}