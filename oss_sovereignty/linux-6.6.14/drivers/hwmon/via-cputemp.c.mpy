{
  "module_name": "via-cputemp.c",
  "hash_id": "fd4627b1b54deaf262697709100f549abd9c385cb8c2346f146770bc92bbde14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/via-cputemp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-vid.h>\n#include <linux/sysfs.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/platform_device.h>\n#include <linux/cpu.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <asm/cpu_device_id.h>\n\n#define DRVNAME\t\"via_cputemp\"\n\nenum { SHOW_TEMP, SHOW_LABEL, SHOW_NAME };\n\n \n\nstruct via_cputemp_data {\n\tstruct device *hwmon_dev;\n\tconst char *name;\n\tu8 vrm;\n\tu32 id;\n\tu32 msr_temp;\n\tu32 msr_vid;\n};\n\n \n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tint ret;\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct via_cputemp_data *data = dev_get_drvdata(dev);\n\n\tif (attr->index == SHOW_NAME)\n\t\tret = sprintf(buf, \"%s\\n\", data->name);\n\telse\t \n\t\tret = sprintf(buf, \"Core %d\\n\", data->id);\n\treturn ret;\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct via_cputemp_data *data = dev_get_drvdata(dev);\n\tu32 eax, edx;\n\tint err;\n\n\terr = rdmsr_safe_on_cpu(data->id, data->msr_temp, &eax, &edx);\n\tif (err)\n\t\treturn -EAGAIN;\n\n\treturn sprintf(buf, \"%lu\\n\", ((unsigned long)eax & 0xffffff) * 1000);\n}\n\nstatic ssize_t cpu0_vid_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct via_cputemp_data *data = dev_get_drvdata(dev);\n\tu32 eax, edx;\n\tint err;\n\n\terr = rdmsr_safe_on_cpu(data->id, data->msr_vid, &eax, &edx);\n\tif (err)\n\t\treturn -EAGAIN;\n\n\treturn sprintf(buf, \"%d\\n\", vid_from_reg(~edx & 0x7f, data->vrm));\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, SHOW_TEMP);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_label, name, SHOW_LABEL);\nstatic SENSOR_DEVICE_ATTR_RO(name, name, SHOW_NAME);\n\nstatic struct attribute *via_cputemp_attributes[] = {\n\t&sensor_dev_attr_name.dev_attr.attr,\n\t&sensor_dev_attr_temp1_label.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group via_cputemp_group = {\n\t.attrs = via_cputemp_attributes,\n};\n\n \nstatic DEVICE_ATTR_RO(cpu0_vid);\n\nstatic int via_cputemp_probe(struct platform_device *pdev)\n{\n\tstruct via_cputemp_data *data;\n\tstruct cpuinfo_x86 *c = &cpu_data(pdev->id);\n\tint err;\n\tu32 eax, edx;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct via_cputemp_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->id = pdev->id;\n\tdata->name = \"via_cputemp\";\n\n\tif (c->x86 == 7) {\n\t\tdata->msr_temp = 0x1423;\n\t} else {\n\t\tswitch (c->x86_model) {\n\t\tcase 0xA:\n\t\t\t \n\t\tcase 0xD:\n\t\t\t \n\t\t\tdata->msr_temp = 0x1169;\n\t\t\tdata->msr_vid = 0x198;\n\t\t\tbreak;\n\t\tcase 0xF:\n\t\t\t \n\t\t\tdata->msr_temp = 0x1423;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\terr = rdmsr_safe_on_cpu(data->id, data->msr_temp, &eax, &edx);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to access TEMPERATURE MSR, giving up\\n\");\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\terr = sysfs_create_group(&pdev->dev.kobj, &via_cputemp_group);\n\tif (err)\n\t\treturn err;\n\n\tif (data->msr_vid)\n\t\tdata->vrm = vid_which_vrm();\n\n\tif (data->vrm) {\n\t\terr = device_create_file(&pdev->dev, &dev_attr_cpu0_vid);\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\t}\n\n\tdata->hwmon_dev = hwmon_device_register(&pdev->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tdev_err(&pdev->dev, \"Class registration failed (%d)\\n\",\n\t\t\terr);\n\t\tgoto exit_remove;\n\t}\n\n\treturn 0;\n\nexit_remove:\n\tif (data->vrm)\n\t\tdevice_remove_file(&pdev->dev, &dev_attr_cpu0_vid);\n\tsysfs_remove_group(&pdev->dev.kobj, &via_cputemp_group);\n\treturn err;\n}\n\nstatic int via_cputemp_remove(struct platform_device *pdev)\n{\n\tstruct via_cputemp_data *data = platform_get_drvdata(pdev);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tif (data->vrm)\n\t\tdevice_remove_file(&pdev->dev, &dev_attr_cpu0_vid);\n\tsysfs_remove_group(&pdev->dev.kobj, &via_cputemp_group);\n\treturn 0;\n}\n\nstatic struct platform_driver via_cputemp_driver = {\n\t.driver = {\n\t\t.name = DRVNAME,\n\t},\n\t.probe = via_cputemp_probe,\n\t.remove = via_cputemp_remove,\n};\n\nstruct pdev_entry {\n\tstruct list_head list;\n\tstruct platform_device *pdev;\n\tunsigned int cpu;\n};\n\nstatic LIST_HEAD(pdev_list);\nstatic DEFINE_MUTEX(pdev_list_mutex);\n\nstatic int via_cputemp_online(unsigned int cpu)\n{\n\tint err;\n\tstruct platform_device *pdev;\n\tstruct pdev_entry *pdev_entry;\n\n\tpdev = platform_device_alloc(DRVNAME, cpu);\n\tif (!pdev) {\n\t\terr = -ENOMEM;\n\t\tpr_err(\"Device allocation failed\\n\");\n\t\tgoto exit;\n\t}\n\n\tpdev_entry = kzalloc(sizeof(struct pdev_entry), GFP_KERNEL);\n\tif (!pdev_entry) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n\t\tpr_err(\"Device addition failed (%d)\\n\", err);\n\t\tgoto exit_device_free;\n\t}\n\n\tpdev_entry->pdev = pdev;\n\tpdev_entry->cpu = cpu;\n\tmutex_lock(&pdev_list_mutex);\n\tlist_add_tail(&pdev_entry->list, &pdev_list);\n\tmutex_unlock(&pdev_list_mutex);\n\n\treturn 0;\n\nexit_device_free:\n\tkfree(pdev_entry);\nexit_device_put:\n\tplatform_device_put(pdev);\nexit:\n\treturn err;\n}\n\nstatic int via_cputemp_down_prep(unsigned int cpu)\n{\n\tstruct pdev_entry *p;\n\n\tmutex_lock(&pdev_list_mutex);\n\tlist_for_each_entry(p, &pdev_list, list) {\n\t\tif (p->cpu == cpu) {\n\t\t\tplatform_device_unregister(p->pdev);\n\t\t\tlist_del(&p->list);\n\t\t\tmutex_unlock(&pdev_list_mutex);\n\t\t\tkfree(p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmutex_unlock(&pdev_list_mutex);\n\treturn 0;\n}\n\nstatic const struct x86_cpu_id __initconst cputemp_ids[] = {\n\tX86_MATCH_VENDOR_FAM_MODEL(CENTAUR, 6, X86_CENTAUR_FAM6_C7_A,\tNULL),\n\tX86_MATCH_VENDOR_FAM_MODEL(CENTAUR, 6, X86_CENTAUR_FAM6_C7_D,\tNULL),\n\tX86_MATCH_VENDOR_FAM_MODEL(CENTAUR, 6, X86_CENTAUR_FAM6_NANO,\tNULL),\n\tX86_MATCH_VENDOR_FAM_MODEL(CENTAUR, 7, X86_MODEL_ANY,\t\tNULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, cputemp_ids);\n\nstatic enum cpuhp_state via_temp_online;\n\nstatic int __init via_cputemp_init(void)\n{\n\tint err;\n\n\tif (!x86_match_cpu(cputemp_ids))\n\t\treturn -ENODEV;\n\n\terr = platform_driver_register(&via_cputemp_driver);\n\tif (err)\n\t\tgoto exit;\n\n\terr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"hwmon/via:online\",\n\t\t\t\tvia_cputemp_online, via_cputemp_down_prep);\n\tif (err < 0)\n\t\tgoto exit_driver_unreg;\n\tvia_temp_online = err;\n\n#ifndef CONFIG_HOTPLUG_CPU\n\tif (list_empty(&pdev_list)) {\n\t\terr = -ENODEV;\n\t\tgoto exit_hp_unreg;\n\t}\n#endif\n\treturn 0;\n\n#ifndef CONFIG_HOTPLUG_CPU\nexit_hp_unreg:\n\tcpuhp_remove_state_nocalls(via_temp_online);\n#endif\nexit_driver_unreg:\n\tplatform_driver_unregister(&via_cputemp_driver);\nexit:\n\treturn err;\n}\n\nstatic void __exit via_cputemp_exit(void)\n{\n\tcpuhp_remove_state(via_temp_online);\n\tplatform_driver_unregister(&via_cputemp_driver);\n}\n\nMODULE_AUTHOR(\"Harald Welte <HaraldWelte@viatech.com>\");\nMODULE_DESCRIPTION(\"VIA CPU temperature monitor\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(via_cputemp_init)\nmodule_exit(via_cputemp_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}