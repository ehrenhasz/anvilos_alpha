{
  "module_name": "lm95245.c",
  "hash_id": "d7abfde9650fc75753a741ccf517d961e823a4b376df7f28b9ca8efb23072dec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lm95245.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\nstatic const unsigned short normal_i2c[] = {\n\t0x18, 0x19, 0x29, 0x4c, 0x4d, I2C_CLIENT_END };\n\n \n \n#define LM95245_REG_RW_CONFIG1\t\t0x03\n#define LM95245_REG_RW_CONVERS_RATE\t0x04\n#define LM95245_REG_W_ONE_SHOT\t\t0x0F\n\n \n#define LM95245_REG_RW_CONFIG2\t\t0xBF\n#define LM95245_REG_RW_REMOTE_OFFH\t0x11\n#define LM95245_REG_RW_REMOTE_OFFL\t0x12\n\n \n#define LM95245_REG_R_STATUS1\t\t0x02\n#define LM95245_REG_R_STATUS2\t\t0x33\n\n \n#define LM95245_REG_RW_REMOTE_OS_LIMIT\t\t0x07\n#define LM95245_REG_RW_LOCAL_OS_TCRIT_LIMIT\t0x20\n#define LM95245_REG_RW_REMOTE_TCRIT_LIMIT\t0x19\n#define LM95245_REG_RW_COMMON_HYSTERESIS\t0x21\n\n \n#define LM95245_REG_R_LOCAL_TEMPH_S\t0x00\n#define LM95245_REG_R_LOCAL_TEMPL_S\t0x30\n#define LM95245_REG_R_REMOTE_TEMPH_S\t0x01\n#define LM95245_REG_R_REMOTE_TEMPL_S\t0x10\n \n#define LM95245_REG_R_REMOTE_TEMPH_U\t0x31\n#define LM95245_REG_R_REMOTE_TEMPL_U\t0x32\n\n \n#define LM95245_REG_R_MAN_ID\t\t0xFE\n#define LM95245_REG_R_CHIP_ID\t\t0xFF\n\n \n#define CFG_STOP\t\t0x40\n#define CFG_REMOTE_TCRIT_MASK\t0x10\n#define CFG_REMOTE_OS_MASK\t0x08\n#define CFG_LOCAL_TCRIT_MASK\t0x04\n#define CFG_LOCAL_OS_MASK\t0x02\n\n#define CFG2_OS_A0\t\t0x40\n#define CFG2_DIODE_FAULT_OS\t0x20\n#define CFG2_DIODE_FAULT_TCRIT\t0x10\n#define CFG2_REMOTE_TT\t\t0x08\n#define CFG2_REMOTE_FILTER_DIS\t0x00\n#define CFG2_REMOTE_FILTER_EN\t0x06\n\n \n#define RATE_CR0063\t0x00\n#define RATE_CR0364\t0x01\n#define RATE_CR1000\t0x02\n#define RATE_CR2500\t0x03\n\n#define STATUS1_ROS\t\t0x10\n#define STATUS1_DIODE_FAULT\t0x04\n#define STATUS1_RTCRIT\t\t0x02\n#define STATUS1_LOC\t\t0x01\n\n#define MANUFACTURER_ID\t\t0x01\n#define LM95235_REVISION\t0xB1\n#define LM95245_REVISION\t0xB3\n\n \nstruct lm95245_data {\n\tstruct regmap *regmap;\n\tstruct mutex update_lock;\n\tint interval;\t \n};\n\n \nstatic int temp_from_reg_unsigned(u8 val_h, u8 val_l)\n{\n\treturn val_h * 1000 + val_l * 1000 / 256;\n}\n\nstatic int temp_from_reg_signed(u8 val_h, u8 val_l)\n{\n\tif (val_h & 0x80)\n\t\treturn (val_h - 0x100) * 1000;\n\treturn temp_from_reg_unsigned(val_h, val_l);\n}\n\nstatic int lm95245_read_conversion_rate(struct lm95245_data *data)\n{\n\tunsigned int rate;\n\tint ret;\n\n\tret = regmap_read(data->regmap, LM95245_REG_RW_CONVERS_RATE, &rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (rate) {\n\tcase RATE_CR0063:\n\t\tdata->interval = 63;\n\t\tbreak;\n\tcase RATE_CR0364:\n\t\tdata->interval = 364;\n\t\tbreak;\n\tcase RATE_CR1000:\n\t\tdata->interval = 1000;\n\t\tbreak;\n\tcase RATE_CR2500:\n\tdefault:\n\t\tdata->interval = 2500;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int lm95245_set_conversion_rate(struct lm95245_data *data, long interval)\n{\n\tint ret, rate;\n\n\tif (interval <= 63) {\n\t\tinterval = 63;\n\t\trate = RATE_CR0063;\n\t} else if (interval <= 364) {\n\t\tinterval = 364;\n\t\trate = RATE_CR0364;\n\t} else if (interval <= 1000) {\n\t\tinterval = 1000;\n\t\trate = RATE_CR1000;\n\t} else {\n\t\tinterval = 2500;\n\t\trate = RATE_CR2500;\n\t}\n\n\tret = regmap_write(data->regmap, LM95245_REG_RW_CONVERS_RATE, rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->interval = interval;\n\treturn 0;\n}\n\nstatic int lm95245_read_temp(struct device *dev, u32 attr, int channel,\n\t\t\t     long *val)\n{\n\tstruct lm95245_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tint ret, regl, regh, regvall, regvalh;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tregl = channel ? LM95245_REG_R_REMOTE_TEMPL_S :\n\t\t\t\t LM95245_REG_R_LOCAL_TEMPL_S;\n\t\tregh = channel ? LM95245_REG_R_REMOTE_TEMPH_S :\n\t\t\t\t LM95245_REG_R_LOCAL_TEMPH_S;\n\t\tret = regmap_read(regmap, regl, &regvall);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_read(regmap, regh, &regvalh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tif (!channel || (regvalh & 0x80) || regvalh < 0x7f) {\n\t\t\t*val = temp_from_reg_signed(regvalh, regvall);\n\t\t\treturn 0;\n\t\t}\n\t\tret = regmap_read(regmap, LM95245_REG_R_REMOTE_TEMPL_U,\n\t\t\t\t  &regvall);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_read(regmap, LM95245_REG_R_REMOTE_TEMPH_U,\n\t\t\t\t  &regvalh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = temp_from_reg_unsigned(regvalh, regvall);\n\t\treturn 0;\n\tcase hwmon_temp_max:\n\t\tret = regmap_read(regmap, LM95245_REG_RW_REMOTE_OS_LIMIT,\n\t\t\t\t  &regvalh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = regvalh * 1000;\n\t\treturn 0;\n\tcase hwmon_temp_crit:\n\t\tregh = channel ? LM95245_REG_RW_REMOTE_TCRIT_LIMIT :\n\t\t\t\t LM95245_REG_RW_LOCAL_OS_TCRIT_LIMIT;\n\t\tret = regmap_read(regmap, regh, &regvalh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = regvalh * 1000;\n\t\treturn 0;\n\tcase hwmon_temp_max_hyst:\n\t\tret = regmap_read(regmap, LM95245_REG_RW_REMOTE_OS_LIMIT,\n\t\t\t\t  &regvalh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_read(regmap, LM95245_REG_RW_COMMON_HYSTERESIS,\n\t\t\t\t  &regvall);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = (regvalh - regvall) * 1000;\n\t\treturn 0;\n\tcase hwmon_temp_crit_hyst:\n\t\tregh = channel ? LM95245_REG_RW_REMOTE_TCRIT_LIMIT :\n\t\t\t\t LM95245_REG_RW_LOCAL_OS_TCRIT_LIMIT;\n\t\tret = regmap_read(regmap, regh, &regvalh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_read(regmap, LM95245_REG_RW_COMMON_HYSTERESIS,\n\t\t\t\t  &regvall);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = (regvalh - regvall) * 1000;\n\t\treturn 0;\n\tcase hwmon_temp_type:\n\t\tret = regmap_read(regmap, LM95245_REG_RW_CONFIG2, &regvalh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = (regvalh & CFG2_REMOTE_TT) ? 1 : 2;\n\t\treturn 0;\n\tcase hwmon_temp_offset:\n\t\tret = regmap_read(regmap, LM95245_REG_RW_REMOTE_OFFL,\n\t\t\t\t  &regvall);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_read(regmap, LM95245_REG_RW_REMOTE_OFFH,\n\t\t\t\t  &regvalh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = temp_from_reg_signed(regvalh, regvall);\n\t\treturn 0;\n\tcase hwmon_temp_max_alarm:\n\t\tret = regmap_read(regmap, LM95245_REG_R_STATUS1, &regvalh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = !!(regvalh & STATUS1_ROS);\n\t\treturn 0;\n\tcase hwmon_temp_crit_alarm:\n\t\tret = regmap_read(regmap, LM95245_REG_R_STATUS1, &regvalh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = !!(regvalh & (channel ? STATUS1_RTCRIT : STATUS1_LOC));\n\t\treturn 0;\n\tcase hwmon_temp_fault:\n\t\tret = regmap_read(regmap, LM95245_REG_R_STATUS1, &regvalh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = !!(regvalh & STATUS1_DIODE_FAULT);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lm95245_write_temp(struct device *dev, u32 attr, int channel,\n\t\t\t      long val)\n{\n\tstruct lm95245_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int regval;\n\tint ret, reg;\n\n\tswitch (attr) {\n\tcase hwmon_temp_max:\n\t\tval = clamp_val(val / 1000, 0, 255);\n\t\tret = regmap_write(regmap, LM95245_REG_RW_REMOTE_OS_LIMIT, val);\n\t\treturn ret;\n\tcase hwmon_temp_crit:\n\t\treg = channel ? LM95245_REG_RW_REMOTE_TCRIT_LIMIT :\n\t\t\t\tLM95245_REG_RW_LOCAL_OS_TCRIT_LIMIT;\n\t\tval = clamp_val(val / 1000, 0, channel ? 255 : 127);\n\t\tret = regmap_write(regmap, reg, val);\n\t\treturn ret;\n\tcase hwmon_temp_crit_hyst:\n\t\tmutex_lock(&data->update_lock);\n\t\tret = regmap_read(regmap, LM95245_REG_RW_LOCAL_OS_TCRIT_LIMIT,\n\t\t\t\t  &regval);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->update_lock);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tval = clamp_val(val, -1000000, 1000000);\n\t\tval = regval - val / 1000;\n\t\tval = clamp_val(val, 0, 31);\n\t\tret = regmap_write(regmap, LM95245_REG_RW_COMMON_HYSTERESIS,\n\t\t\t\t   val);\n\t\tmutex_unlock(&data->update_lock);\n\t\treturn ret;\n\tcase hwmon_temp_offset:\n\t\tval = clamp_val(val, -128000, 127875);\n\t\tval = val * 256 / 1000;\n\t\tmutex_lock(&data->update_lock);\n\t\tret = regmap_write(regmap, LM95245_REG_RW_REMOTE_OFFL,\n\t\t\t\t   val & 0xe0);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->update_lock);\n\t\t\treturn ret;\n\t\t}\n\t\tret = regmap_write(regmap, LM95245_REG_RW_REMOTE_OFFH,\n\t\t\t\t   (val >> 8) & 0xff);\n\t\tmutex_unlock(&data->update_lock);\n\t\treturn ret;\n\tcase hwmon_temp_type:\n\t\tif (val != 1 && val != 2)\n\t\t\treturn -EINVAL;\n\t\tret = regmap_update_bits(regmap, LM95245_REG_RW_CONFIG2,\n\t\t\t\t\t CFG2_REMOTE_TT,\n\t\t\t\t\t val == 1 ? CFG2_REMOTE_TT : 0);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lm95245_read_chip(struct device *dev, u32 attr, int channel,\n\t\t\t     long *val)\n{\n\tstruct lm95245_data *data = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\t*val = data->interval;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lm95245_write_chip(struct device *dev, u32 attr, int channel,\n\t\t\t      long val)\n{\n\tstruct lm95245_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\tmutex_lock(&data->update_lock);\n\t\tret = lm95245_set_conversion_rate(data, val);\n\t\tmutex_unlock(&data->update_lock);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lm95245_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn lm95245_read_chip(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn lm95245_read_temp(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lm95245_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn lm95245_write_chip(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn lm95245_write_temp(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t lm95245_temp_is_visible(const void *data, u32 attr, int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_max_alarm:\n\tcase hwmon_temp_max_hyst:\n\tcase hwmon_temp_crit_alarm:\n\tcase hwmon_temp_fault:\n\t\treturn 0444;\n\tcase hwmon_temp_type:\n\tcase hwmon_temp_max:\n\tcase hwmon_temp_crit:\n\tcase hwmon_temp_offset:\n\t\treturn 0644;\n\tcase hwmon_temp_crit_hyst:\n\t\treturn (channel == 0) ? 0644 : 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t lm95245_is_visible(const void *data,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_temp:\n\t\treturn lm95245_temp_is_visible(data, attr, channel);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic int lm95245_detect(struct i2c_client *new_client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = new_client->adapter;\n\tint address = new_client->addr;\n\tconst char *name;\n\tint rev, id;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tid = i2c_smbus_read_byte_data(new_client, LM95245_REG_R_MAN_ID);\n\tif (id != MANUFACTURER_ID)\n\t\treturn -ENODEV;\n\n\trev = i2c_smbus_read_byte_data(new_client, LM95245_REG_R_CHIP_ID);\n\tswitch (rev) {\n\tcase LM95235_REVISION:\n\t\tif (address != 0x18 && address != 0x29 && address != 0x4c)\n\t\t\treturn -ENODEV;\n\t\tname = \"lm95235\";\n\t\tbreak;\n\tcase LM95245_REVISION:\n\t\tname = \"lm95245\";\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, name, I2C_NAME_SIZE);\n\treturn 0;\n}\n\nstatic int lm95245_init_client(struct lm95245_data *data)\n{\n\tint ret;\n\n\tret = lm95245_read_conversion_rate(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_update_bits(data->regmap, LM95245_REG_RW_CONFIG1,\n\t\t\t\t  CFG_STOP, 0);\n}\n\nstatic bool lm95245_is_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LM95245_REG_RW_CONFIG1:\n\tcase LM95245_REG_RW_CONVERS_RATE:\n\tcase LM95245_REG_W_ONE_SHOT:\n\tcase LM95245_REG_RW_CONFIG2:\n\tcase LM95245_REG_RW_REMOTE_OFFH:\n\tcase LM95245_REG_RW_REMOTE_OFFL:\n\tcase LM95245_REG_RW_REMOTE_OS_LIMIT:\n\tcase LM95245_REG_RW_LOCAL_OS_TCRIT_LIMIT:\n\tcase LM95245_REG_RW_REMOTE_TCRIT_LIMIT:\n\tcase LM95245_REG_RW_COMMON_HYSTERESIS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool lm95245_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LM95245_REG_R_STATUS1:\n\tcase LM95245_REG_R_STATUS2:\n\tcase LM95245_REG_R_LOCAL_TEMPH_S:\n\tcase LM95245_REG_R_LOCAL_TEMPL_S:\n\tcase LM95245_REG_R_REMOTE_TEMPH_S:\n\tcase LM95245_REG_R_REMOTE_TEMPL_S:\n\tcase LM95245_REG_R_REMOTE_TEMPH_U:\n\tcase LM95245_REG_R_REMOTE_TEMPL_U:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config lm95245_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.writeable_reg = lm95245_is_writeable_reg,\n\t.volatile_reg = lm95245_is_volatile_reg,\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic const struct hwmon_channel_info * const lm95245_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_CRIT_HYST |\n\t\t\t   HWMON_T_CRIT_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_FAULT |\n\t\t\t   HWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM |\n\t\t\t   HWMON_T_TYPE | HWMON_T_OFFSET),\n\tNULL\n};\n\nstatic const struct hwmon_ops lm95245_hwmon_ops = {\n\t.is_visible = lm95245_is_visible,\n\t.read = lm95245_read,\n\t.write = lm95245_write,\n};\n\nstatic const struct hwmon_chip_info lm95245_chip_info = {\n\t.ops = &lm95245_hwmon_ops,\n\t.info = lm95245_info,\n};\n\nstatic int lm95245_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct lm95245_data *data;\n\tstruct device *hwmon_dev;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(struct lm95245_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &lm95245_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\tmutex_init(&data->update_lock);\n\n\t \n\tret = lm95245_init_client(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &lm95245_chip_info,\n\t\t\t\t\t\t\t NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\n \nstatic const struct i2c_device_id lm95245_id[] = {\n\t{ \"lm95235\", 0 },\n\t{ \"lm95245\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm95245_id);\n\nstatic const struct of_device_id __maybe_unused lm95245_of_match[] = {\n\t{ .compatible = \"national,lm95235\" },\n\t{ .compatible = \"national,lm95245\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, lm95245_of_match);\n\nstatic struct i2c_driver lm95245_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"lm95245\",\n\t\t.of_match_table = of_match_ptr(lm95245_of_match),\n\t},\n\t.probe\t\t= lm95245_probe,\n\t.id_table\t= lm95245_id,\n\t.detect\t\t= lm95245_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(lm95245_driver);\n\nMODULE_AUTHOR(\"Alexander Stein <alexander.stein@systec-electronic.com>\");\nMODULE_DESCRIPTION(\"LM95235/LM95245 sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}