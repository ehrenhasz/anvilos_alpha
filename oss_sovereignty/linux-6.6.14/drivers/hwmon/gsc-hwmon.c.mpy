{
  "module_name": "gsc-hwmon.c",
  "hash_id": "dcb74dd012117ffaba10856416bb88d98ae635483e69cb73aedbbb3b7e00b14f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/gsc-hwmon.c",
  "human_readable_source": "\n \n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/mfd/gsc.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <linux/platform_data/gsc_hwmon.h>\n\n#define GSC_HWMON_MAX_TEMP_CH\t16\n#define GSC_HWMON_MAX_IN_CH\t16\n#define GSC_HWMON_MAX_FAN_CH\t16\n\n#define GSC_HWMON_RESOLUTION\t12\n#define GSC_HWMON_VREF\t\t2500\n\nstruct gsc_hwmon_data {\n\tstruct gsc_dev *gsc;\n\tstruct gsc_hwmon_platform_data *pdata;\n\tstruct regmap *regmap;\n\tconst struct gsc_hwmon_channel *temp_ch[GSC_HWMON_MAX_TEMP_CH];\n\tconst struct gsc_hwmon_channel *in_ch[GSC_HWMON_MAX_IN_CH];\n\tconst struct gsc_hwmon_channel *fan_ch[GSC_HWMON_MAX_FAN_CH];\n\tu32 temp_config[GSC_HWMON_MAX_TEMP_CH + 1];\n\tu32 in_config[GSC_HWMON_MAX_IN_CH + 1];\n\tu32 fan_config[GSC_HWMON_MAX_FAN_CH + 1];\n\tstruct hwmon_channel_info temp_info;\n\tstruct hwmon_channel_info in_info;\n\tstruct hwmon_channel_info fan_info;\n\tconst struct hwmon_channel_info *info[4];\n\tstruct hwmon_chip_info chip;\n};\n\nstatic struct regmap_bus gsc_hwmon_regmap_bus = {\n\t.reg_read = gsc_read,\n\t.reg_write = gsc_write,\n};\n\nstatic const struct regmap_config gsc_hwmon_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic ssize_t pwm_auto_point_temp_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct gsc_hwmon_data *hwmon = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tu8 reg = hwmon->pdata->fan_base + (2 * attr->index);\n\tu8 regs[2];\n\tint ret;\n\n\tret = regmap_bulk_read(hwmon->regmap, reg, regs, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regs[0] | regs[1] << 8;\n\treturn sprintf(buf, \"%d\\n\", ret * 10);\n}\n\nstatic ssize_t pwm_auto_point_temp_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *devattr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct gsc_hwmon_data *hwmon = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tu8 reg = hwmon->pdata->fan_base + (2 * attr->index);\n\tu8 regs[2];\n\tlong temp;\n\tint err;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, 0, 100000);\n\ttemp = DIV_ROUND_CLOSEST(temp, 100);\n\n\tregs[0] = temp & 0xff;\n\tregs[1] = (temp >> 8) & 0xff;\n\terr = regmap_bulk_write(hwmon->regmap, reg, regs, 2);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic ssize_t pwm_auto_point_pwm_show(struct device *dev,\n\t\t\t\t       struct device_attribute *devattr,\n\t\t\t\t       char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\n\treturn sprintf(buf, \"%d\\n\", 255 * (50 + (attr->index * 10)));\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(pwm1_auto_point1_pwm, pwm_auto_point_pwm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point1_temp, pwm_auto_point_temp, 0);\n\nstatic SENSOR_DEVICE_ATTR_RO(pwm1_auto_point2_pwm, pwm_auto_point_pwm, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point2_temp, pwm_auto_point_temp, 1);\n\nstatic SENSOR_DEVICE_ATTR_RO(pwm1_auto_point3_pwm, pwm_auto_point_pwm, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point3_temp, pwm_auto_point_temp, 2);\n\nstatic SENSOR_DEVICE_ATTR_RO(pwm1_auto_point4_pwm, pwm_auto_point_pwm, 3);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point4_temp, pwm_auto_point_temp, 3);\n\nstatic SENSOR_DEVICE_ATTR_RO(pwm1_auto_point5_pwm, pwm_auto_point_pwm, 4);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point5_temp, pwm_auto_point_temp, 4);\n\nstatic SENSOR_DEVICE_ATTR_RO(pwm1_auto_point6_pwm, pwm_auto_point_pwm, 5);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point6_temp, pwm_auto_point_temp, 5);\n\nstatic struct attribute *gsc_hwmon_attributes[] = {\n\t&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point5_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point5_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point6_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point6_temp.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group gsc_hwmon_group = {\n\t.attrs = gsc_hwmon_attributes,\n};\n__ATTRIBUTE_GROUPS(gsc_hwmon);\n\nstatic int\ngsc_hwmon_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t       int channel, long *val)\n{\n\tstruct gsc_hwmon_data *hwmon = dev_get_drvdata(dev);\n\tconst struct gsc_hwmon_channel *ch;\n\tint sz, ret;\n\tlong tmp;\n\tu8 buf[3];\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tch = hwmon->in_ch[channel];\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tch = hwmon->temp_ch[channel];\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tch = hwmon->fan_ch[channel];\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tsz = (ch->mode == mode_voltage_24bit) ? 3 : 2;\n\tret = regmap_bulk_read(hwmon->regmap, ch->reg, buf, sz);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = 0;\n\twhile (sz-- > 0)\n\t\ttmp |= (buf[sz] << (8 * sz));\n\n\tswitch (ch->mode) {\n\tcase mode_temperature:\n\t\tif (tmp > 0x8000)\n\t\t\ttmp -= 0xffff;\n\t\ttmp *= 100;  \n\t\tbreak;\n\tcase mode_voltage_raw:\n\t\ttmp = clamp_val(tmp, 0, BIT(GSC_HWMON_RESOLUTION));\n\t\t \n\t\ttmp *= GSC_HWMON_VREF;\n\t\ttmp >>= GSC_HWMON_RESOLUTION;\n\t\t \n\t\tif (ch->vdiv[0] && ch->vdiv[1]) {\n\t\t\ttmp *= (ch->vdiv[0] + ch->vdiv[1]);\n\t\t\ttmp /= ch->vdiv[1];\n\t\t}\n\t\t \n\t\ttmp += ch->mvoffset;\n\t\tbreak;\n\tcase mode_fan:\n\t\ttmp *= 30;  \n\t\tbreak;\n\tcase mode_voltage_24bit:\n\tcase mode_voltage_16bit:\n\t\t \n\t\tbreak;\n\t}\n\n\t*val = tmp;\n\n\treturn 0;\n}\n\nstatic int\ngsc_hwmon_read_string(struct device *dev, enum hwmon_sensor_types type,\n\t\t      u32 attr, int channel, const char **buf)\n{\n\tstruct gsc_hwmon_data *hwmon = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\t*buf = hwmon->in_ch[channel]->name;\n\t\tbreak;\n\tcase hwmon_temp:\n\t\t*buf = hwmon->temp_ch[channel]->name;\n\t\tbreak;\n\tcase hwmon_fan:\n\t\t*buf = hwmon->fan_ch[channel]->name;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic umode_t\ngsc_hwmon_is_visible(const void *_data, enum hwmon_sensor_types type, u32 attr,\n\t\t     int ch)\n{\n\treturn 0444;\n}\n\nstatic const struct hwmon_ops gsc_hwmon_ops = {\n\t.is_visible = gsc_hwmon_is_visible,\n\t.read = gsc_hwmon_read,\n\t.read_string = gsc_hwmon_read_string,\n};\n\nstatic struct gsc_hwmon_platform_data *\ngsc_hwmon_get_devtree_pdata(struct device *dev)\n{\n\tstruct gsc_hwmon_platform_data *pdata;\n\tstruct gsc_hwmon_channel *ch;\n\tstruct fwnode_handle *child;\n\tstruct device_node *fan;\n\tint nchannels;\n\n\tnchannels = device_get_child_node_count(dev);\n\tif (nchannels == 0)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdata = devm_kzalloc(dev, struct_size(pdata, channels, nchannels),\n\t\t\t     GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpdata->nchannels = nchannels;\n\n\t \n\tof_node_get(dev->parent->of_node);\n\tfan = of_find_compatible_node(dev->parent->of_node, NULL, \"gw,gsc-fan\");\n\tif (fan && of_property_read_u32(fan, \"reg\", &pdata->fan_base)) {\n\t\tof_node_put(fan);\n\t\tdev_err(dev, \"fan node without base\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tof_node_put(fan);\n\n\tch = pdata->channels;\n\t \n\tdevice_for_each_child_node(dev, child) {\n\t\tif (fwnode_property_read_string(child, \"label\", &ch->name)) {\n\t\t\tdev_err(dev, \"channel without label\\n\");\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tif (fwnode_property_read_u32(child, \"reg\", &ch->reg)) {\n\t\t\tdev_err(dev, \"channel without reg\\n\");\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tif (fwnode_property_read_u32(child, \"gw,mode\", &ch->mode)) {\n\t\t\tdev_err(dev, \"channel without mode\\n\");\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tif (ch->mode > mode_max) {\n\t\t\tdev_err(dev, \"invalid channel mode\\n\");\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tif (!fwnode_property_read_u32(child,\n\t\t\t\t\t      \"gw,voltage-offset-microvolt\",\n\t\t\t\t\t      &ch->mvoffset))\n\t\t\tch->mvoffset /= 1000;\n\t\tfwnode_property_read_u32_array(child,\n\t\t\t\t\t       \"gw,voltage-divider-ohms\",\n\t\t\t\t\t       ch->vdiv, ARRAY_SIZE(ch->vdiv));\n\t\tch++;\n\t}\n\n\treturn pdata;\n}\n\nstatic int gsc_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct gsc_dev *gsc = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tstruct device *hwmon_dev;\n\tstruct gsc_hwmon_platform_data *pdata = dev_get_platdata(dev);\n\tstruct gsc_hwmon_data *hwmon;\n\tconst struct attribute_group **groups;\n\tint i, i_in, i_temp, i_fan;\n\n\tif (!pdata) {\n\t\tpdata = gsc_hwmon_get_devtree_pdata(dev);\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\t}\n\n\thwmon = devm_kzalloc(dev, sizeof(*hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn -ENOMEM;\n\thwmon->gsc = gsc;\n\thwmon->pdata = pdata;\n\n\thwmon->regmap = devm_regmap_init(dev, &gsc_hwmon_regmap_bus,\n\t\t\t\t\t gsc->i2c_hwmon,\n\t\t\t\t\t &gsc_hwmon_regmap_config);\n\tif (IS_ERR(hwmon->regmap))\n\t\treturn PTR_ERR(hwmon->regmap);\n\n\tfor (i = 0, i_in = 0, i_temp = 0, i_fan = 0; i < hwmon->pdata->nchannels; i++) {\n\t\tconst struct gsc_hwmon_channel *ch = &pdata->channels[i];\n\n\t\tswitch (ch->mode) {\n\t\tcase mode_temperature:\n\t\t\tif (i_temp == GSC_HWMON_MAX_TEMP_CH) {\n\t\t\t\tdev_err(gsc->dev, \"too many temp channels\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\thwmon->temp_ch[i_temp] = ch;\n\t\t\thwmon->temp_config[i_temp] = HWMON_T_INPUT |\n\t\t\t\t\t\t     HWMON_T_LABEL;\n\t\t\ti_temp++;\n\t\t\tbreak;\n\t\tcase mode_fan:\n\t\t\tif (i_fan == GSC_HWMON_MAX_FAN_CH) {\n\t\t\t\tdev_err(gsc->dev, \"too many fan channels\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\thwmon->fan_ch[i_fan] = ch;\n\t\t\thwmon->fan_config[i_fan] = HWMON_F_INPUT |\n\t\t\t\t\t\t   HWMON_F_LABEL;\n\t\t\ti_fan++;\n\t\t\tbreak;\n\t\tcase mode_voltage_24bit:\n\t\tcase mode_voltage_16bit:\n\t\tcase mode_voltage_raw:\n\t\t\tif (i_in == GSC_HWMON_MAX_IN_CH) {\n\t\t\t\tdev_err(gsc->dev, \"too many input channels\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\thwmon->in_ch[i_in] = ch;\n\t\t\thwmon->in_config[i_in] =\n\t\t\t\tHWMON_I_INPUT | HWMON_I_LABEL;\n\t\t\ti_in++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(gsc->dev, \"invalid mode: %d\\n\", ch->mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\thwmon->chip.ops = &gsc_hwmon_ops;\n\thwmon->chip.info = hwmon->info;\n\thwmon->info[0] = &hwmon->temp_info;\n\thwmon->info[1] = &hwmon->in_info;\n\thwmon->info[2] = &hwmon->fan_info;\n\thwmon->temp_info.type = hwmon_temp;\n\thwmon->temp_info.config = hwmon->temp_config;\n\thwmon->in_info.type = hwmon_in;\n\thwmon->in_info.config = hwmon->in_config;\n\thwmon->fan_info.type = hwmon_fan;\n\thwmon->fan_info.config = hwmon->fan_config;\n\n\tgroups = pdata->fan_base ? gsc_hwmon_groups : NULL;\n\thwmon_dev = devm_hwmon_device_register_with_info(dev,\n\t\t\t\t\t\t\t KBUILD_MODNAME, hwmon,\n\t\t\t\t\t\t\t &hwmon->chip, groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct of_device_id gsc_hwmon_of_match[] = {\n\t{ .compatible = \"gw,gsc-adc\", },\n\t{}\n};\n\nstatic struct platform_driver gsc_hwmon_driver = {\n\t.driver = {\n\t\t.name = \"gsc-hwmon\",\n\t\t.of_match_table = gsc_hwmon_of_match,\n\t},\n\t.probe = gsc_hwmon_probe,\n};\n\nmodule_platform_driver(gsc_hwmon_driver);\n\nMODULE_AUTHOR(\"Tim Harvey <tharvey@gateworks.com>\");\nMODULE_DESCRIPTION(\"GSC hardware monitor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}