{
  "module_name": "sht21.c",
  "hash_id": "bd3afc2efd63de651c316bb5d002c31809baa46b62700bad6ea7e1dd498c61e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/sht21.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/jiffies.h>\n\n \n#define SHT21_TRIG_T_MEASUREMENT_HM  0xe3\n#define SHT21_TRIG_RH_MEASUREMENT_HM 0xe5\n#define SHT21_READ_SNB_CMD1 0xFA\n#define SHT21_READ_SNB_CMD2 0x0F\n#define SHT21_READ_SNAC_CMD1 0xFC\n#define SHT21_READ_SNAC_CMD2 0xC9\n\n \nstruct sht21 {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tunsigned long last_update;\n\tint temperature;\n\tint humidity;\n\tbool valid;\n\tchar eic[18];\n};\n\n \nstatic inline int sht21_temp_ticks_to_millicelsius(int ticks)\n{\n\tticks &= ~0x0003;  \n\t \n\treturn ((21965 * ticks) >> 13) - 46850;\n}\n\n \nstatic inline int sht21_rh_ticks_to_per_cent_mille(int ticks)\n{\n\tticks &= ~0x0003;  \n\t \n\treturn ((15625 * ticks) >> 13) - 6000;\n}\n\n \nstatic int sht21_update_measurements(struct device *dev)\n{\n\tint ret = 0;\n\tstruct sht21 *sht21 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = sht21->client;\n\n\tmutex_lock(&sht21->lock);\n\t \n\tif (time_after(jiffies, sht21->last_update + HZ / 2) || !sht21->valid) {\n\t\tret = i2c_smbus_read_word_swapped(client,\n\t\t\t\t\t\t  SHT21_TRIG_T_MEASUREMENT_HM);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tsht21->temperature = sht21_temp_ticks_to_millicelsius(ret);\n\t\tret = i2c_smbus_read_word_swapped(client,\n\t\t\t\t\t\t  SHT21_TRIG_RH_MEASUREMENT_HM);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tsht21->humidity = sht21_rh_ticks_to_per_cent_mille(ret);\n\t\tsht21->last_update = jiffies;\n\t\tsht21->valid = true;\n\t}\nout:\n\tmutex_unlock(&sht21->lock);\n\n\treturn ret >= 0 ? 0 : ret;\n}\n\n \nstatic ssize_t sht21_temperature_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct sht21 *sht21 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = sht21_update_measurements(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sprintf(buf, \"%d\\n\", sht21->temperature);\n}\n\n \nstatic ssize_t sht21_humidity_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct sht21 *sht21 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = sht21_update_measurements(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sprintf(buf, \"%d\\n\", sht21->humidity);\n}\n\nstatic ssize_t eic_read(struct sht21 *sht21)\n{\n\tstruct i2c_client *client = sht21->client;\n\tu8 tx[2];\n\tu8 rx[8];\n\tu8 eic[8];\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 2,\n\t\t\t.buf = tx,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 8,\n\t\t\t.buf = rx,\n\t\t},\n\t};\n\tint ret;\n\n\ttx[0] = SHT21_READ_SNB_CMD1;\n\ttx[1] = SHT21_READ_SNB_CMD2;\n\tret = i2c_transfer(client->adapter, msgs, 2);\n\tif (ret < 0)\n\t\tgoto out;\n\teic[2] = rx[0];\n\teic[3] = rx[2];\n\teic[4] = rx[4];\n\teic[5] = rx[6];\n\n\ttx[0] = SHT21_READ_SNAC_CMD1;\n\ttx[1] = SHT21_READ_SNAC_CMD2;\n\tmsgs[1].len = 6;\n\tret = i2c_transfer(client->adapter, msgs, 2);\n\tif (ret < 0)\n\t\tgoto out;\n\teic[0] = rx[3];\n\teic[1] = rx[4];\n\teic[6] = rx[0];\n\teic[7] = rx[1];\n\n\tret = snprintf(sht21->eic, sizeof(sht21->eic),\n\t\t       \"%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t       eic[0], eic[1], eic[2], eic[3],\n\t\t       eic[4], eic[5], eic[6], eic[7]);\nout:\n\tif (ret < 0)\n\t\tsht21->eic[0] = 0;\n\n\treturn ret;\n}\n\n \nstatic ssize_t eic_show(struct device *dev,\n\tstruct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct sht21 *sht21 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = sizeof(sht21->eic) - 1;\n\tmutex_lock(&sht21->lock);\n\tif (!sht21->eic[0])\n\t\tret = eic_read(sht21);\n\tif (ret > 0)\n\t\tmemcpy(buf, sht21->eic, ret);\n\tmutex_unlock(&sht21->lock);\n\treturn ret;\n}\n\n \nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, sht21_temperature, 0);\nstatic SENSOR_DEVICE_ATTR_RO(humidity1_input, sht21_humidity, 0);\nstatic DEVICE_ATTR_RO(eic);\n\nstatic struct attribute *sht21_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_humidity1_input.dev_attr.attr,\n\t&dev_attr_eic.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(sht21);\n\nstatic int sht21_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct sht21 *sht21;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"adapter does not support SMBus word transactions\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsht21 = devm_kzalloc(dev, sizeof(*sht21), GFP_KERNEL);\n\tif (!sht21)\n\t\treturn -ENOMEM;\n\n\tsht21->client = client;\n\n\tmutex_init(&sht21->lock);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   sht21, sht21_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\n \nstatic const struct i2c_device_id sht21_id[] = {\n\t{ \"sht21\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sht21_id);\n\nstatic struct i2c_driver sht21_driver = {\n\t.driver.name = \"sht21\",\n\t.probe       = sht21_probe,\n\t.id_table    = sht21_id,\n};\n\nmodule_i2c_driver(sht21_driver);\n\nMODULE_AUTHOR(\"Urs Fleisch <urs.fleisch@sensirion.com>\");\nMODULE_DESCRIPTION(\"Sensirion SHT21 humidity and temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}