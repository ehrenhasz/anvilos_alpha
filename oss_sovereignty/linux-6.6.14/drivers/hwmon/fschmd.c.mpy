{
  "module_name": "fschmd.c",
  "hash_id": "d9b612ca68b9c43458530ba163b29478978aec06745b10c4096d58fb92dfd7e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/fschmd.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/dmi.h>\n#include <linux/fs.h>\n#include <linux/watchdog.h>\n#include <linux/miscdevice.h>\n#include <linux/uaccess.h>\n#include <linux/kref.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x73, I2C_CLIENT_END };\n\n \nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nenum chips { fscpos, fscher, fscscy, fschrc, fschmd, fschds, fscsyl };\n\n \n\n \n#define FSCHMD_REG_IDENT_0\t\t0x00\n#define FSCHMD_REG_IDENT_1\t\t0x01\n#define FSCHMD_REG_IDENT_2\t\t0x02\n#define FSCHMD_REG_REVISION\t\t0x03\n\n \n#define FSCHMD_REG_EVENT_STATE\t\t0x04\n#define FSCHMD_REG_CONTROL\t\t0x05\n\n#define FSCHMD_CONTROL_ALERT_LED\t0x01\n\n \nstatic const u8 FSCHMD_REG_WDOG_CONTROL[7] = {\n\t0x21, 0x21, 0x21, 0x21, 0x21, 0x28, 0x28 };\nstatic const u8 FSCHMD_REG_WDOG_STATE[7] = {\n\t0x23, 0x23, 0x23, 0x23, 0x23, 0x29, 0x29 };\nstatic const u8 FSCHMD_REG_WDOG_PRESET[7] = {\n\t0x28, 0x28, 0x28, 0x28, 0x28, 0x2a, 0x2a };\n\n#define FSCHMD_WDOG_CONTROL_TRIGGER\t0x10\n#define FSCHMD_WDOG_CONTROL_STARTED\t0x10  \n#define FSCHMD_WDOG_CONTROL_STOP\t0x20\n#define FSCHMD_WDOG_CONTROL_RESOLUTION\t0x40\n\n#define FSCHMD_WDOG_STATE_CARDRESET\t0x02\n\n \nstatic const u8 FSCHMD_REG_VOLT[7][6] = {\n\t{ 0x45, 0x42, 0x48 },\t\t\t\t \n\t{ 0x45, 0x42, 0x48 },\t\t\t\t \n\t{ 0x45, 0x42, 0x48 },\t\t\t\t \n\t{ 0x45, 0x42, 0x48 },\t\t\t\t \n\t{ 0x45, 0x42, 0x48 },\t\t\t\t \n\t{ 0x21, 0x20, 0x22 },\t\t\t\t \n\t{ 0x21, 0x20, 0x22, 0x23, 0x24, 0x25 },\t\t \n};\n\nstatic const int FSCHMD_NO_VOLT_SENSORS[7] = { 3, 3, 3, 3, 3, 3, 6 };\n\n \nstatic const u8 FSCHMD_REG_FAN_MIN[7][7] = {\n\t{ 0x55, 0x65 },\t\t\t\t\t \n\t{ 0x55, 0x65, 0xb5 },\t\t\t\t \n\t{ 0x65, 0x65, 0x55, 0xa5, 0x55, 0xa5 },\t\t \n\t{ 0x55, 0x65, 0xa5, 0xb5 },\t\t\t \n\t{ 0x55, 0x65, 0xa5, 0xb5, 0xc5 },\t\t \n\t{ 0x55, 0x65, 0xa5, 0xb5, 0xc5 },\t\t \n\t{ 0x54, 0x64, 0x74, 0x84, 0x94, 0xa4, 0xb4 },\t \n};\n\n \nstatic const u8 FSCHMD_REG_FAN_ACT[7][7] = {\n\t{ 0x0e, 0x6b, 0xab },\t\t\t\t \n\t{ 0x0e, 0x6b, 0xbb },\t\t\t\t \n\t{ 0x6b, 0x6c, 0x0e, 0xab, 0x5c, 0xbb },\t\t \n\t{ 0x0e, 0x6b, 0xab, 0xbb },\t\t\t \n\t{ 0x5b, 0x6b, 0xab, 0xbb, 0xcb },\t\t \n\t{ 0x5b, 0x6b, 0xab, 0xbb, 0xcb },\t\t \n\t{ 0x57, 0x67, 0x77, 0x87, 0x97, 0xa7, 0xb7 },\t \n};\n\n \nstatic const u8 FSCHMD_REG_FAN_STATE[7][7] = {\n\t{ 0x0d, 0x62, 0xa2 },\t\t\t\t \n\t{ 0x0d, 0x62, 0xb2 },\t\t\t\t \n\t{ 0x62, 0x61, 0x0d, 0xa2, 0x52, 0xb2 },\t\t \n\t{ 0x0d, 0x62, 0xa2, 0xb2 },\t\t\t \n\t{ 0x52, 0x62, 0xa2, 0xb2, 0xc2 },\t\t \n\t{ 0x52, 0x62, 0xa2, 0xb2, 0xc2 },\t\t \n\t{ 0x50, 0x60, 0x70, 0x80, 0x90, 0xa0, 0xb0 },\t \n};\n\n \nstatic const u8 FSCHMD_REG_FAN_RIPPLE[7][7] = {\n\t{ 0x0f, 0x6f, 0xaf },\t\t\t\t \n\t{ 0x0f, 0x6f, 0xbf },\t\t\t\t \n\t{ 0x6f, 0x6f, 0x0f, 0xaf, 0x0f, 0xbf },\t\t \n\t{ 0x0f, 0x6f, 0xaf, 0xbf },\t\t\t \n\t{ 0x5f, 0x6f, 0xaf, 0xbf, 0xcf },\t\t \n\t{ 0x5f, 0x6f, 0xaf, 0xbf, 0xcf },\t\t \n\t{ 0x56, 0x66, 0x76, 0x86, 0x96, 0xa6, 0xb6 },\t \n};\n\nstatic const int FSCHMD_NO_FAN_SENSORS[7] = { 3, 3, 6, 4, 5, 5, 7 };\n\n \n#define FSCHMD_FAN_ALARM\t0x04  \n#define FSCHMD_FAN_NOT_PRESENT\t0x08\n#define FSCHMD_FAN_DISABLED\t0x80\n\n\n \nstatic const u8 FSCHMD_REG_TEMP_ACT[7][11] = {\n\t{ 0x64, 0x32, 0x35 },\t\t\t\t \n\t{ 0x64, 0x32, 0x35 },\t\t\t\t \n\t{ 0x64, 0xD0, 0x32, 0x35 },\t\t\t \n\t{ 0x64, 0x32, 0x35 },\t\t\t\t \n\t{ 0x70, 0x80, 0x90, 0xd0, 0xe0 },\t\t \n\t{ 0x70, 0x80, 0x90, 0xd0, 0xe0 },\t\t \n\t{ 0x58, 0x68, 0x78, 0x88, 0x98, 0xa8,\t\t \n\t  0xb8, 0xc8, 0xd8, 0xe8, 0xf8 },\n};\n\n \nstatic const u8 FSCHMD_REG_TEMP_STATE[7][11] = {\n\t{ 0x71, 0x81, 0x91 },\t\t\t\t \n\t{ 0x71, 0x81, 0x91 },\t\t\t\t \n\t{ 0x71, 0xd1, 0x81, 0x91 },\t\t\t \n\t{ 0x71, 0x81, 0x91 },\t\t\t\t \n\t{ 0x71, 0x81, 0x91, 0xd1, 0xe1 },\t\t \n\t{ 0x71, 0x81, 0x91, 0xd1, 0xe1 },\t\t \n\t{ 0x59, 0x69, 0x79, 0x89, 0x99, 0xa9,\t\t \n\t  0xb9, 0xc9, 0xd9, 0xe9, 0xf9 },\n};\n\n \nstatic const u8 FSCHMD_REG_TEMP_LIMIT[7][11] = {\n\t{ 0, 0, 0 },\t\t\t\t\t \n\t{ 0x76, 0x86, 0x96 },\t\t\t\t \n\t{ 0x76, 0xd6, 0x86, 0x96 },\t\t\t \n\t{ 0x76, 0x86, 0x96 },\t\t\t\t \n\t{ 0x76, 0x86, 0x96, 0xd6, 0xe6 },\t\t \n\t{ 0x76, 0x86, 0x96, 0xd6, 0xe6 },\t\t \n\t{ 0x5a, 0x6a, 0x7a, 0x8a, 0x9a, 0xaa,\t\t \n\t  0xba, 0xca, 0xda, 0xea, 0xfa },\n};\n\n \n\nstatic const int FSCHMD_NO_TEMP_SENSORS[7] = { 3, 3, 4, 3, 5, 5, 11 };\n\n \n#define FSCHMD_TEMP_WORKING\t0x01\n#define FSCHMD_TEMP_ALERT\t0x02\n#define FSCHMD_TEMP_DISABLED\t0x80\n \n#define FSCHMD_TEMP_ALARM_MASK \\\n\t(FSCHMD_TEMP_WORKING | FSCHMD_TEMP_ALERT)\n\n \n\nstatic int fschmd_probe(struct i2c_client *client);\nstatic int fschmd_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info);\nstatic void fschmd_remove(struct i2c_client *client);\nstatic struct fschmd_data *fschmd_update_device(struct device *dev);\n\n \n\nstatic const struct i2c_device_id fschmd_id[] = {\n\t{ \"fscpos\", fscpos },\n\t{ \"fscher\", fscher },\n\t{ \"fscscy\", fscscy },\n\t{ \"fschrc\", fschrc },\n\t{ \"fschmd\", fschmd },\n\t{ \"fschds\", fschds },\n\t{ \"fscsyl\", fscsyl },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, fschmd_id);\n\nstatic struct i2c_driver fschmd_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"fschmd\",\n\t},\n\t.probe\t\t= fschmd_probe,\n\t.remove\t\t= fschmd_remove,\n\t.id_table\t= fschmd_id,\n\t.detect\t\t= fschmd_detect,\n\t.address_list\t= normal_i2c,\n};\n\n \n\nstruct fschmd_data {\n\tstruct i2c_client *client;\n\tstruct device *hwmon_dev;\n\tstruct mutex update_lock;\n\tstruct mutex watchdog_lock;\n\tstruct list_head list;  \n\tstruct kref kref;\n\tstruct miscdevice watchdog_miscdev;\n\tenum chips kind;\n\tunsigned long watchdog_is_open;\n\tchar watchdog_expect_close;\n\tchar watchdog_name[10];  \n\tbool valid;  \n\tunsigned long last_updated;  \n\n\t \n\tu8 revision;             \n\tu8 global_control;\t \n\tu8 watchdog_control;     \n\tu8 watchdog_state;       \n\tu8 watchdog_preset;      \n\tu8 volt[6];\t\t \n\tu8 temp_act[11];\t \n\tu8 temp_status[11];\t \n\tu8 temp_max[11];\t \n\tu8 fan_act[7];\t\t \n\tu8 fan_status[7];\t \n\tu8 fan_min[7];\t\t \n\tu8 fan_ripple[7];\t \n};\n\n \nstatic int dmi_mult[6] = { 490, 200, 100, 100, 200, 100 };\nstatic int dmi_offset[6] = { 0, 0, 0, 0, 0, 0 };\nstatic int dmi_vref = -1;\n\n \nstatic LIST_HEAD(watchdog_data_list);\n \nstatic DEFINE_MUTEX(watchdog_data_mutex);\n\n \nstatic void fschmd_release_resources(struct kref *ref)\n{\n\tstruct fschmd_data *data = container_of(ref, struct fschmd_data, kref);\n\tkfree(data);\n}\n\n \n\nstatic ssize_t in_value_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tconst int max_reading[3] = { 14200, 6600, 3300 };\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = fschmd_update_device(dev);\n\n\tif (data->kind == fscher || data->kind >= fschrc)\n\t\treturn sprintf(buf, \"%d\\n\", (data->volt[index] * dmi_vref *\n\t\t\tdmi_mult[index]) / 255 + dmi_offset[index]);\n\telse\n\t\treturn sprintf(buf, \"%d\\n\", (data->volt[index] *\n\t\t\tmax_reading[index] + 128) / 255);\n}\n\n\n#define TEMP_FROM_REG(val)\t(((val) - 128) * 1000)\n\nstatic ssize_t temp_value_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = fschmd_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_act[index]));\n}\n\nstatic ssize_t temp_max_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = fschmd_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_max[index]));\n}\n\nstatic ssize_t temp_max_store(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      const char *buf, size_t count)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = dev_get_drvdata(dev);\n\tlong v;\n\tint err;\n\n\terr = kstrtol(buf, 10, &v);\n\tif (err)\n\t\treturn err;\n\n\tv = clamp_val(v / 1000, -128, 127) + 128;\n\n\tmutex_lock(&data->update_lock);\n\ti2c_smbus_write_byte_data(to_i2c_client(dev),\n\t\tFSCHMD_REG_TEMP_LIMIT[data->kind][index], v);\n\tdata->temp_max[index] = v;\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t temp_fault_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = fschmd_update_device(dev);\n\n\t \n\tif (data->temp_status[index] & FSCHMD_TEMP_WORKING)\n\t\treturn sprintf(buf, \"0\\n\");\n\telse\n\t\treturn sprintf(buf, \"1\\n\");\n}\n\nstatic ssize_t temp_alarm_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = fschmd_update_device(dev);\n\n\tif ((data->temp_status[index] & FSCHMD_TEMP_ALARM_MASK) ==\n\t\t\tFSCHMD_TEMP_ALARM_MASK)\n\t\treturn sprintf(buf, \"1\\n\");\n\telse\n\t\treturn sprintf(buf, \"0\\n\");\n}\n\n\n#define RPM_FROM_REG(val)\t((val) * 60)\n\nstatic ssize_t fan_value_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = fschmd_update_device(dev);\n\n\treturn sprintf(buf, \"%u\\n\", RPM_FROM_REG(data->fan_act[index]));\n}\n\nstatic ssize_t fan_div_show(struct device *dev,\n\t\t\t    struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = fschmd_update_device(dev);\n\n\t \n\treturn sprintf(buf, \"%d\\n\", 1 << (data->fan_ripple[index] & 3));\n}\n\nstatic ssize_t fan_div_store(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf, size_t count)\n{\n\tu8 reg;\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = dev_get_drvdata(dev);\n\t \n\tunsigned long v;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &v);\n\tif (err)\n\t\treturn err;\n\n\tswitch (v) {\n\tcase 2:\n\t\tv = 1;\n\t\tbreak;\n\tcase 4:\n\t\tv = 2;\n\t\tbreak;\n\tcase 8:\n\t\tv = 3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev,\n\t\t\t\"fan_div value %lu not supported. Choose one of 2, 4 or 8!\\n\",\n\t\t\tv);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&data->update_lock);\n\n\treg = i2c_smbus_read_byte_data(to_i2c_client(dev),\n\t\tFSCHMD_REG_FAN_RIPPLE[data->kind][index]);\n\n\t \n\treg &= ~0x03;\n\treg |= v;\n\n\ti2c_smbus_write_byte_data(to_i2c_client(dev),\n\t\tFSCHMD_REG_FAN_RIPPLE[data->kind][index], reg);\n\n\tdata->fan_ripple[index] = reg;\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t fan_alarm_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = fschmd_update_device(dev);\n\n\tif (data->fan_status[index] & FSCHMD_FAN_ALARM)\n\t\treturn sprintf(buf, \"1\\n\");\n\telse\n\t\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t fan_fault_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = fschmd_update_device(dev);\n\n\tif (data->fan_status[index] & FSCHMD_FAN_NOT_PRESENT)\n\t\treturn sprintf(buf, \"1\\n\");\n\telse\n\t\treturn sprintf(buf, \"0\\n\");\n}\n\n\nstatic ssize_t pwm_auto_point1_pwm_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\t\tchar *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = fschmd_update_device(dev);\n\tint val = data->fan_min[index];\n\n\t \n\tif (val || data->kind == fscsyl)\n\t\tval = val / 2 + 128;\n\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t pwm_auto_point1_pwm_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *devattr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct fschmd_data *data = dev_get_drvdata(dev);\n\tunsigned long v;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &v);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (v || data->kind == fscsyl) {\n\t\tv = clamp_val(v, 128, 255);\n\t\tv = (v - 128) * 2 + 1;\n\t}\n\n\tmutex_lock(&data->update_lock);\n\n\ti2c_smbus_write_byte_data(to_i2c_client(dev),\n\t\tFSCHMD_REG_FAN_MIN[data->kind][index], v);\n\tdata->fan_min[index] = v;\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n\n \nstatic ssize_t alert_led_show(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct fschmd_data *data = fschmd_update_device(dev);\n\n\tif (data->global_control & FSCHMD_CONTROL_ALERT_LED)\n\t\treturn sprintf(buf, \"1\\n\");\n\telse\n\t\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t alert_led_store(struct device *dev,\n\tstruct device_attribute *devattr, const char *buf, size_t count)\n{\n\tu8 reg;\n\tstruct fschmd_data *data = dev_get_drvdata(dev);\n\tunsigned long v;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &v);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\treg = i2c_smbus_read_byte_data(to_i2c_client(dev), FSCHMD_REG_CONTROL);\n\n\tif (v)\n\t\treg |= FSCHMD_CONTROL_ALERT_LED;\n\telse\n\t\treg &= ~FSCHMD_CONTROL_ALERT_LED;\n\n\ti2c_smbus_write_byte_data(to_i2c_client(dev), FSCHMD_REG_CONTROL, reg);\n\n\tdata->global_control = reg;\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(alert_led);\n\nstatic struct sensor_device_attribute fschmd_attr[] = {\n\tSENSOR_ATTR_RO(in0_input, in_value, 0),\n\tSENSOR_ATTR_RO(in1_input, in_value, 1),\n\tSENSOR_ATTR_RO(in2_input, in_value, 2),\n\tSENSOR_ATTR_RO(in3_input, in_value, 3),\n\tSENSOR_ATTR_RO(in4_input, in_value, 4),\n\tSENSOR_ATTR_RO(in5_input, in_value, 5),\n};\n\nstatic struct sensor_device_attribute fschmd_temp_attr[] = {\n\tSENSOR_ATTR_RO(temp1_input, temp_value, 0),\n\tSENSOR_ATTR_RW(temp1_max, temp_max, 0),\n\tSENSOR_ATTR_RO(temp1_fault, temp_fault, 0),\n\tSENSOR_ATTR_RO(temp1_alarm, temp_alarm, 0),\n\tSENSOR_ATTR_RO(temp2_input, temp_value, 1),\n\tSENSOR_ATTR_RW(temp2_max, temp_max, 1),\n\tSENSOR_ATTR_RO(temp2_fault, temp_fault, 1),\n\tSENSOR_ATTR_RO(temp2_alarm, temp_alarm, 1),\n\tSENSOR_ATTR_RO(temp3_input, temp_value, 2),\n\tSENSOR_ATTR_RW(temp3_max, temp_max, 2),\n\tSENSOR_ATTR_RO(temp3_fault, temp_fault, 2),\n\tSENSOR_ATTR_RO(temp3_alarm, temp_alarm, 2),\n\tSENSOR_ATTR_RO(temp4_input, temp_value, 3),\n\tSENSOR_ATTR_RW(temp4_max, temp_max, 3),\n\tSENSOR_ATTR_RO(temp4_fault, temp_fault, 3),\n\tSENSOR_ATTR_RO(temp4_alarm, temp_alarm, 3),\n\tSENSOR_ATTR_RO(temp5_input, temp_value, 4),\n\tSENSOR_ATTR_RW(temp5_max, temp_max, 4),\n\tSENSOR_ATTR_RO(temp5_fault, temp_fault, 4),\n\tSENSOR_ATTR_RO(temp5_alarm, temp_alarm, 4),\n\tSENSOR_ATTR_RO(temp6_input, temp_value, 5),\n\tSENSOR_ATTR_RW(temp6_max, temp_max, 5),\n\tSENSOR_ATTR_RO(temp6_fault, temp_fault, 5),\n\tSENSOR_ATTR_RO(temp6_alarm, temp_alarm, 5),\n\tSENSOR_ATTR_RO(temp7_input, temp_value, 6),\n\tSENSOR_ATTR_RW(temp7_max, temp_max, 6),\n\tSENSOR_ATTR_RO(temp7_fault, temp_fault, 6),\n\tSENSOR_ATTR_RO(temp7_alarm, temp_alarm, 6),\n\tSENSOR_ATTR_RO(temp8_input, temp_value, 7),\n\tSENSOR_ATTR_RW(temp8_max, temp_max, 7),\n\tSENSOR_ATTR_RO(temp8_fault, temp_fault, 7),\n\tSENSOR_ATTR_RO(temp8_alarm, temp_alarm, 7),\n\tSENSOR_ATTR_RO(temp9_input, temp_value, 8),\n\tSENSOR_ATTR_RW(temp9_max, temp_max, 8),\n\tSENSOR_ATTR_RO(temp9_fault, temp_fault, 8),\n\tSENSOR_ATTR_RO(temp9_alarm, temp_alarm, 8),\n\tSENSOR_ATTR_RO(temp10_input, temp_value, 9),\n\tSENSOR_ATTR_RW(temp10_max, temp_max, 9),\n\tSENSOR_ATTR_RO(temp10_fault, temp_fault, 9),\n\tSENSOR_ATTR_RO(temp10_alarm, temp_alarm, 9),\n\tSENSOR_ATTR_RO(temp11_input, temp_value, 10),\n\tSENSOR_ATTR_RW(temp11_max, temp_max, 10),\n\tSENSOR_ATTR_RO(temp11_fault, temp_fault, 10),\n\tSENSOR_ATTR_RO(temp11_alarm, temp_alarm, 10),\n};\n\nstatic struct sensor_device_attribute fschmd_fan_attr[] = {\n\tSENSOR_ATTR_RO(fan1_input, fan_value, 0),\n\tSENSOR_ATTR_RW(fan1_div, fan_div, 0),\n\tSENSOR_ATTR_RO(fan1_alarm, fan_alarm, 0),\n\tSENSOR_ATTR_RO(fan1_fault, fan_fault, 0),\n\tSENSOR_ATTR_RW(pwm1_auto_point1_pwm, pwm_auto_point1_pwm, 0),\n\tSENSOR_ATTR_RO(fan2_input, fan_value, 1),\n\tSENSOR_ATTR_RW(fan2_div, fan_div, 1),\n\tSENSOR_ATTR_RO(fan2_alarm, fan_alarm, 1),\n\tSENSOR_ATTR_RO(fan2_fault, fan_fault, 1),\n\tSENSOR_ATTR_RW(pwm2_auto_point1_pwm, pwm_auto_point1_pwm, 1),\n\tSENSOR_ATTR_RO(fan3_input, fan_value, 2),\n\tSENSOR_ATTR_RW(fan3_div, fan_div, 2),\n\tSENSOR_ATTR_RO(fan3_alarm, fan_alarm, 2),\n\tSENSOR_ATTR_RO(fan3_fault, fan_fault, 2),\n\tSENSOR_ATTR_RW(pwm3_auto_point1_pwm, pwm_auto_point1_pwm, 2),\n\tSENSOR_ATTR_RO(fan4_input, fan_value, 3),\n\tSENSOR_ATTR_RW(fan4_div, fan_div, 3),\n\tSENSOR_ATTR_RO(fan4_alarm, fan_alarm, 3),\n\tSENSOR_ATTR_RO(fan4_fault, fan_fault, 3),\n\tSENSOR_ATTR_RW(pwm4_auto_point1_pwm, pwm_auto_point1_pwm, 3),\n\tSENSOR_ATTR_RO(fan5_input, fan_value, 4),\n\tSENSOR_ATTR_RW(fan5_div, fan_div, 4),\n\tSENSOR_ATTR_RO(fan5_alarm, fan_alarm, 4),\n\tSENSOR_ATTR_RO(fan5_fault, fan_fault, 4),\n\tSENSOR_ATTR_RW(pwm5_auto_point1_pwm, pwm_auto_point1_pwm, 4),\n\tSENSOR_ATTR_RO(fan6_input, fan_value, 5),\n\tSENSOR_ATTR_RW(fan6_div, fan_div, 5),\n\tSENSOR_ATTR_RO(fan6_alarm, fan_alarm, 5),\n\tSENSOR_ATTR_RO(fan6_fault, fan_fault, 5),\n\tSENSOR_ATTR_RW(pwm6_auto_point1_pwm, pwm_auto_point1_pwm, 5),\n\tSENSOR_ATTR_RO(fan7_input, fan_value, 6),\n\tSENSOR_ATTR_RW(fan7_div, fan_div, 6),\n\tSENSOR_ATTR_RO(fan7_alarm, fan_alarm, 6),\n\tSENSOR_ATTR_RO(fan7_fault, fan_fault, 6),\n\tSENSOR_ATTR_RW(pwm7_auto_point1_pwm, pwm_auto_point1_pwm, 6),\n};\n\n\n \n\nstatic int watchdog_set_timeout(struct fschmd_data *data, int timeout)\n{\n\tint ret, resolution;\n\tint kind = data->kind + 1;  \n\n\t \n\tif (timeout <= 510 || kind == fscpos || kind == fscscy)\n\t\tresolution = 2;\n\telse\n\t\tresolution = 60;\n\n\tif (timeout < resolution || timeout > (resolution * 255))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->watchdog_lock);\n\tif (!data->client) {\n\t\tret = -ENODEV;\n\t\tgoto leave;\n\t}\n\n\tif (resolution == 2)\n\t\tdata->watchdog_control &= ~FSCHMD_WDOG_CONTROL_RESOLUTION;\n\telse\n\t\tdata->watchdog_control |= FSCHMD_WDOG_CONTROL_RESOLUTION;\n\n\tdata->watchdog_preset = DIV_ROUND_UP(timeout, resolution);\n\n\t \n\ti2c_smbus_write_byte_data(data->client,\n\t\tFSCHMD_REG_WDOG_PRESET[data->kind], data->watchdog_preset);\n\t \n\ti2c_smbus_write_byte_data(data->client,\n\t\tFSCHMD_REG_WDOG_CONTROL[data->kind],\n\t\tdata->watchdog_control & ~FSCHMD_WDOG_CONTROL_TRIGGER);\n\n\tret = data->watchdog_preset * resolution;\n\nleave:\n\tmutex_unlock(&data->watchdog_lock);\n\treturn ret;\n}\n\nstatic int watchdog_get_timeout(struct fschmd_data *data)\n{\n\tint timeout;\n\n\tmutex_lock(&data->watchdog_lock);\n\tif (data->watchdog_control & FSCHMD_WDOG_CONTROL_RESOLUTION)\n\t\ttimeout = data->watchdog_preset * 60;\n\telse\n\t\ttimeout = data->watchdog_preset * 2;\n\tmutex_unlock(&data->watchdog_lock);\n\n\treturn timeout;\n}\n\nstatic int watchdog_trigger(struct fschmd_data *data)\n{\n\tint ret = 0;\n\n\tmutex_lock(&data->watchdog_lock);\n\tif (!data->client) {\n\t\tret = -ENODEV;\n\t\tgoto leave;\n\t}\n\n\tdata->watchdog_control |= FSCHMD_WDOG_CONTROL_TRIGGER;\n\ti2c_smbus_write_byte_data(data->client,\n\t\t\t\t  FSCHMD_REG_WDOG_CONTROL[data->kind],\n\t\t\t\t  data->watchdog_control);\nleave:\n\tmutex_unlock(&data->watchdog_lock);\n\treturn ret;\n}\n\nstatic int watchdog_stop(struct fschmd_data *data)\n{\n\tint ret = 0;\n\n\tmutex_lock(&data->watchdog_lock);\n\tif (!data->client) {\n\t\tret = -ENODEV;\n\t\tgoto leave;\n\t}\n\n\tdata->watchdog_control &= ~FSCHMD_WDOG_CONTROL_STARTED;\n\t \n\ti2c_smbus_write_byte_data(data->client,\n\t\tFSCHMD_REG_WDOG_CONTROL[data->kind],\n\t\tdata->watchdog_control | FSCHMD_WDOG_CONTROL_STOP);\nleave:\n\tmutex_unlock(&data->watchdog_lock);\n\treturn ret;\n}\n\nstatic int watchdog_open(struct inode *inode, struct file *filp)\n{\n\tstruct fschmd_data *pos, *data = NULL;\n\tint watchdog_is_open;\n\n\t \n\tif (!mutex_trylock(&watchdog_data_mutex))\n\t\treturn -ERESTARTSYS;\n\tlist_for_each_entry(pos, &watchdog_data_list, list) {\n\t\tif (pos->watchdog_miscdev.minor == iminor(inode)) {\n\t\t\tdata = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\twatchdog_is_open = test_and_set_bit(0, &data->watchdog_is_open);\n\tif (!watchdog_is_open)\n\t\tkref_get(&data->kref);\n\tmutex_unlock(&watchdog_data_mutex);\n\n\tif (watchdog_is_open)\n\t\treturn -EBUSY;\n\n\t \n\twatchdog_trigger(data);\n\tfilp->private_data = data;\n\n\treturn stream_open(inode, filp);\n}\n\nstatic int watchdog_release(struct inode *inode, struct file *filp)\n{\n\tstruct fschmd_data *data = filp->private_data;\n\n\tif (data->watchdog_expect_close) {\n\t\twatchdog_stop(data);\n\t\tdata->watchdog_expect_close = 0;\n\t} else {\n\t\twatchdog_trigger(data);\n\t\tdev_crit(&data->client->dev,\n\t\t\t\"unexpected close, not stopping watchdog!\\n\");\n\t}\n\n\tclear_bit(0, &data->watchdog_is_open);\n\n\tmutex_lock(&watchdog_data_mutex);\n\tkref_put(&data->kref, fschmd_release_resources);\n\tmutex_unlock(&watchdog_data_mutex);\n\n\treturn 0;\n}\n\nstatic ssize_t watchdog_write(struct file *filp, const char __user *buf,\n\tsize_t count, loff_t *offset)\n{\n\tint ret;\n\tstruct fschmd_data *data = filp->private_data;\n\n\tif (count) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\tdata->watchdog_expect_close = 0;\n\n\t\t\tfor (i = 0; i != count; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, buf + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\tdata->watchdog_expect_close = 1;\n\t\t\t}\n\t\t}\n\t\tret = watchdog_trigger(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn count;\n}\n\nstatic long watchdog_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tstruct watchdog_info ident = {\n\t\t.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT |\n\t\t\t\tWDIOF_CARDRESET,\n\t\t.identity = \"FSC watchdog\"\n\t};\n\tint i, ret = 0;\n\tstruct fschmd_data *data = filp->private_data;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tident.firmware_version = data->revision;\n\t\tif (!nowayout)\n\t\t\tident.options |= WDIOF_MAGICCLOSE;\n\t\tif (copy_to_user((void __user *)arg, &ident, sizeof(ident)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase WDIOC_GETSTATUS:\n\t\tret = put_user(0, (int __user *)arg);\n\t\tbreak;\n\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tif (data->watchdog_state & FSCHMD_WDOG_STATE_CARDRESET)\n\t\t\tret = put_user(WDIOF_CARDRESET, (int __user *)arg);\n\t\telse\n\t\t\tret = put_user(0, (int __user *)arg);\n\t\tbreak;\n\n\tcase WDIOC_KEEPALIVE:\n\t\tret = watchdog_trigger(data);\n\t\tbreak;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\ti = watchdog_get_timeout(data);\n\t\tret = put_user(i, (int __user *)arg);\n\t\tbreak;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(i, (int __user *)arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = watchdog_set_timeout(data, i);\n\t\tif (ret > 0)\n\t\t\tret = put_user(ret, (int __user *)arg);\n\t\tbreak;\n\n\tcase WDIOC_SETOPTIONS:\n\t\tif (get_user(i, (int __user *)arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i & WDIOS_DISABLECARD)\n\t\t\tret = watchdog_stop(data);\n\t\telse if (i & WDIOS_ENABLECARD)\n\t\t\tret = watchdog_trigger(data);\n\t\telse\n\t\t\tret = -EINVAL;\n\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations watchdog_fops = {\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n\t.open = watchdog_open,\n\t.release = watchdog_release,\n\t.write = watchdog_write,\n\t.unlocked_ioctl = watchdog_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\n\n \n\n \nstatic void fschmd_dmi_decode(const struct dmi_header *header, void *dummy)\n{\n\tint i, mult[3] = { 0 }, offset[3] = { 0 }, vref = 0, found = 0;\n\n\t \n\tu8 *dmi_data = (u8 *)header;\n\n\t \n\tif (header->type != 185)\n\t\treturn;\n\n\t \n\tif (header->length < 5 || dmi_data[4] != 19)\n\t\treturn;\n\n\t \n\tfor (i = 6; (i + 4) < header->length; i += 5) {\n\t\t \n\t\tif (dmi_data[i] >= 1 && dmi_data[i] <= 3) {\n\t\t\t \n\t\t\tconst int shuffle[3] = { 1, 0, 2 };\n\t\t\tint in = shuffle[dmi_data[i] - 1];\n\n\t\t\t \n\t\t\tif (found & (1 << in))\n\t\t\t\treturn;\n\n\t\t\tmult[in] = dmi_data[i + 1] | (dmi_data[i + 2] << 8);\n\t\t\toffset[in] = dmi_data[i + 3] | (dmi_data[i + 4] << 8);\n\n\t\t\tfound |= 1 << in;\n\t\t}\n\n\t\t \n\t\tif (dmi_data[i] == 7) {\n\t\t\t \n\t\t\tif (found & 0x08)\n\t\t\t\treturn;\n\n\t\t\tvref = dmi_data[i + 1] | (dmi_data[i + 2] << 8);\n\n\t\t\tfound |= 0x08;\n\t\t}\n\t}\n\n\tif (found == 0x0F) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tdmi_mult[i] = mult[i] * 10;\n\t\t\tdmi_offset[i] = offset[i] * 10;\n\t\t}\n\t\t \n\t\tdmi_mult[3] = dmi_mult[2];\n\t\tdmi_mult[4] = dmi_mult[1];\n\t\tdmi_mult[5] = dmi_mult[2];\n\t\tdmi_offset[3] = dmi_offset[2];\n\t\tdmi_offset[4] = dmi_offset[1];\n\t\tdmi_offset[5] = dmi_offset[2];\n\t\tdmi_vref = vref;\n\t}\n}\n\nstatic int fschmd_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info)\n{\n\tenum chips kind;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tchar id[4];\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tid[0] = i2c_smbus_read_byte_data(client, FSCHMD_REG_IDENT_0);\n\tid[1] = i2c_smbus_read_byte_data(client, FSCHMD_REG_IDENT_1);\n\tid[2] = i2c_smbus_read_byte_data(client, FSCHMD_REG_IDENT_2);\n\tid[3] = '\\0';\n\n\tif (!strcmp(id, \"PEG\"))\n\t\tkind = fscpos;\n\telse if (!strcmp(id, \"HER\"))\n\t\tkind = fscher;\n\telse if (!strcmp(id, \"SCY\"))\n\t\tkind = fscscy;\n\telse if (!strcmp(id, \"HRC\"))\n\t\tkind = fschrc;\n\telse if (!strcmp(id, \"HMD\"))\n\t\tkind = fschmd;\n\telse if (!strcmp(id, \"HDS\"))\n\t\tkind = fschds;\n\telse if (!strcmp(id, \"SYL\"))\n\t\tkind = fscsyl;\n\telse\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, fschmd_id[kind].name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int fschmd_probe(struct i2c_client *client)\n{\n\tstruct fschmd_data *data;\n\tstatic const char * const names[7] = { \"Poseidon\", \"Hermes\", \"Scylla\",\n\t\t\t\t\"Heracles\", \"Heimdall\", \"Hades\", \"Syleus\" };\n\tstatic const int watchdog_minors[] = { WATCHDOG_MINOR, 212, 213, 214, 215 };\n\tint i, err;\n\tenum chips kind = i2c_match_id(fschmd_id, client)->driver_data;\n\n\tdata = kzalloc(sizeof(struct fschmd_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\tmutex_init(&data->watchdog_lock);\n\tINIT_LIST_HEAD(&data->list);\n\tkref_init(&data->kref);\n\t \n\tdata->client = client;\n\tdata->kind = kind;\n\n\tif (kind == fscpos) {\n\t\t \n\t\tdata->temp_max[0] = 70 + 128;\n\t\tdata->temp_max[1] = 50 + 128;\n\t\tdata->temp_max[2] = 50 + 128;\n\t}\n\n\t \n\tif ((kind == fscher || kind >= fschrc) && dmi_vref == -1) {\n\t\tdmi_walk(fschmd_dmi_decode, NULL);\n\t\tif (dmi_vref == -1) {\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t\"Couldn't get voltage scaling factors from \"\n\t\t\t\t\"BIOS DMI table, using builtin defaults\\n\");\n\t\t\tdmi_vref = 33;\n\t\t}\n\t}\n\n\t \n\tdata->revision = i2c_smbus_read_byte_data(client, FSCHMD_REG_REVISION);\n\tdata->global_control = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tFSCHMD_REG_CONTROL);\n\tdata->watchdog_control = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tFSCHMD_REG_WDOG_CONTROL[data->kind]);\n\tdata->watchdog_state = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tFSCHMD_REG_WDOG_STATE[data->kind]);\n\tdata->watchdog_preset = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tFSCHMD_REG_WDOG_PRESET[data->kind]);\n\n\terr = device_create_file(&client->dev, &dev_attr_alert_led);\n\tif (err)\n\t\tgoto exit_detach;\n\n\tfor (i = 0; i < FSCHMD_NO_VOLT_SENSORS[data->kind]; i++) {\n\t\terr = device_create_file(&client->dev,\n\t\t\t\t\t&fschmd_attr[i].dev_attr);\n\t\tif (err)\n\t\t\tgoto exit_detach;\n\t}\n\n\tfor (i = 0; i < (FSCHMD_NO_TEMP_SENSORS[data->kind] * 4); i++) {\n\t\t \n\t\tif (kind == fscpos && fschmd_temp_attr[i].dev_attr.show ==\n\t\t\t\ttemp_max_show)\n\t\t\tcontinue;\n\n\t\tif (kind == fscsyl) {\n\t\t\tif (i % 4 == 0)\n\t\t\t\tdata->temp_status[i / 4] =\n\t\t\t\t\ti2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tFSCHMD_REG_TEMP_STATE\n\t\t\t\t\t\t[data->kind][i / 4]);\n\t\t\tif (data->temp_status[i / 4] & FSCHMD_TEMP_DISABLED)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr = device_create_file(&client->dev,\n\t\t\t\t\t&fschmd_temp_attr[i].dev_attr);\n\t\tif (err)\n\t\t\tgoto exit_detach;\n\t}\n\n\tfor (i = 0; i < (FSCHMD_NO_FAN_SENSORS[data->kind] * 5); i++) {\n\t\t \n\t\tif (kind == fscpos &&\n\t\t\t\t!strcmp(fschmd_fan_attr[i].dev_attr.attr.name,\n\t\t\t\t\t\"pwm3_auto_point1_pwm\"))\n\t\t\tcontinue;\n\n\t\tif (kind == fscsyl) {\n\t\t\tif (i % 5 == 0)\n\t\t\t\tdata->fan_status[i / 5] =\n\t\t\t\t\ti2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tFSCHMD_REG_FAN_STATE\n\t\t\t\t\t\t[data->kind][i / 5]);\n\t\t\tif (data->fan_status[i / 5] & FSCHMD_FAN_DISABLED)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr = device_create_file(&client->dev,\n\t\t\t\t\t&fschmd_fan_attr[i].dev_attr);\n\t\tif (err)\n\t\t\tgoto exit_detach;\n\t}\n\n\tdata->hwmon_dev = hwmon_device_register(&client->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tdata->hwmon_dev = NULL;\n\t\tgoto exit_detach;\n\t}\n\n\t \n\tmutex_lock(&watchdog_data_mutex);\n\tfor (i = 0; i < ARRAY_SIZE(watchdog_minors); i++) {\n\t\t \n\t\tsnprintf(data->watchdog_name, sizeof(data->watchdog_name),\n\t\t\t\"watchdog%c\", (i == 0) ? '\\0' : ('0' + i));\n\t\tdata->watchdog_miscdev.name = data->watchdog_name;\n\t\tdata->watchdog_miscdev.fops = &watchdog_fops;\n\t\tdata->watchdog_miscdev.minor = watchdog_minors[i];\n\t\terr = misc_register(&data->watchdog_miscdev);\n\t\tif (err == -EBUSY)\n\t\t\tcontinue;\n\t\tif (err) {\n\t\t\tdata->watchdog_miscdev.minor = 0;\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Registering watchdog chardev: %d\\n\", err);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&data->list, &watchdog_data_list);\n\t\twatchdog_set_timeout(data, 60);\n\t\tdev_info(&client->dev,\n\t\t\t\"Registered watchdog chardev major 10, minor: %d\\n\",\n\t\t\twatchdog_minors[i]);\n\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(watchdog_minors)) {\n\t\tdata->watchdog_miscdev.minor = 0;\n\t\tdev_warn(&client->dev,\n\t\t\t \"Couldn't register watchdog chardev (due to no free minor)\\n\");\n\t}\n\tmutex_unlock(&watchdog_data_mutex);\n\n\tdev_info(&client->dev, \"Detected FSC %s chip, revision: %d\\n\",\n\t\tnames[data->kind], (int) data->revision);\n\n\treturn 0;\n\nexit_detach:\n\tfschmd_remove(client);  \n\treturn err;\n}\n\nstatic void fschmd_remove(struct i2c_client *client)\n{\n\tstruct fschmd_data *data = i2c_get_clientdata(client);\n\tint i;\n\n\t \n\tif (data->watchdog_miscdev.minor) {\n\t\tmisc_deregister(&data->watchdog_miscdev);\n\t\tif (data->watchdog_is_open) {\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t\"i2c client detached with watchdog open! \"\n\t\t\t\t\"Stopping watchdog.\\n\");\n\t\t\twatchdog_stop(data);\n\t\t}\n\t\tmutex_lock(&watchdog_data_mutex);\n\t\tlist_del(&data->list);\n\t\tmutex_unlock(&watchdog_data_mutex);\n\t\t \n\t\tmutex_lock(&data->watchdog_lock);\n\t\tdata->client = NULL;\n\t\tmutex_unlock(&data->watchdog_lock);\n\t}\n\n\t \n\tif (data->hwmon_dev)\n\t\thwmon_device_unregister(data->hwmon_dev);\n\n\tdevice_remove_file(&client->dev, &dev_attr_alert_led);\n\tfor (i = 0; i < (FSCHMD_NO_VOLT_SENSORS[data->kind]); i++)\n\t\tdevice_remove_file(&client->dev, &fschmd_attr[i].dev_attr);\n\tfor (i = 0; i < (FSCHMD_NO_TEMP_SENSORS[data->kind] * 4); i++)\n\t\tdevice_remove_file(&client->dev,\n\t\t\t\t\t&fschmd_temp_attr[i].dev_attr);\n\tfor (i = 0; i < (FSCHMD_NO_FAN_SENSORS[data->kind] * 5); i++)\n\t\tdevice_remove_file(&client->dev,\n\t\t\t\t\t&fschmd_fan_attr[i].dev_attr);\n\n\tmutex_lock(&watchdog_data_mutex);\n\tkref_put(&data->kref, fschmd_release_resources);\n\tmutex_unlock(&watchdog_data_mutex);\n}\n\nstatic struct fschmd_data *fschmd_update_device(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct fschmd_data *data = i2c_get_clientdata(client);\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + 2 * HZ) || !data->valid) {\n\n\t\tfor (i = 0; i < FSCHMD_NO_TEMP_SENSORS[data->kind]; i++) {\n\t\t\tdata->temp_act[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tFSCHMD_REG_TEMP_ACT[data->kind][i]);\n\t\t\tdata->temp_status[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tFSCHMD_REG_TEMP_STATE[data->kind][i]);\n\n\t\t\t \n\t\t\tif (FSCHMD_REG_TEMP_LIMIT[data->kind][i])\n\t\t\t\tdata->temp_max[i] = i2c_smbus_read_byte_data(\n\t\t\t\t\tclient,\n\t\t\t\t\tFSCHMD_REG_TEMP_LIMIT[data->kind][i]);\n\n\t\t\t \n\t\t\tif ((data->temp_status[i] & FSCHMD_TEMP_ALARM_MASK) ==\n\t\t\t\t\tFSCHMD_TEMP_ALARM_MASK &&\n\t\t\t\t\tdata->temp_act[i] < data->temp_max[i])\n\t\t\t\ti2c_smbus_write_byte_data(client,\n\t\t\t\t\tFSCHMD_REG_TEMP_STATE[data->kind][i],\n\t\t\t\t\tdata->temp_status[i]);\n\t\t}\n\n\t\tfor (i = 0; i < FSCHMD_NO_FAN_SENSORS[data->kind]; i++) {\n\t\t\tdata->fan_act[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tFSCHMD_REG_FAN_ACT[data->kind][i]);\n\t\t\tdata->fan_status[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tFSCHMD_REG_FAN_STATE[data->kind][i]);\n\t\t\tdata->fan_ripple[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tFSCHMD_REG_FAN_RIPPLE[data->kind][i]);\n\n\t\t\t \n\t\t\tif (FSCHMD_REG_FAN_MIN[data->kind][i])\n\t\t\t\tdata->fan_min[i] = i2c_smbus_read_byte_data(\n\t\t\t\t\tclient,\n\t\t\t\t\tFSCHMD_REG_FAN_MIN[data->kind][i]);\n\n\t\t\t \n\t\t\tif ((data->fan_status[i] & FSCHMD_FAN_ALARM) &&\n\t\t\t\t\tdata->fan_act[i])\n\t\t\t\ti2c_smbus_write_byte_data(client,\n\t\t\t\t\tFSCHMD_REG_FAN_STATE[data->kind][i],\n\t\t\t\t\tdata->fan_status[i]);\n\t\t}\n\n\t\tfor (i = 0; i < FSCHMD_NO_VOLT_SENSORS[data->kind]; i++)\n\t\t\tdata->volt[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t       FSCHMD_REG_VOLT[data->kind][i]);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\nmodule_i2c_driver(fschmd_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"FSC Poseidon, Hermes, Scylla, Heracles, Heimdall, Hades \"\n\t\t\t\"and Syleus driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}