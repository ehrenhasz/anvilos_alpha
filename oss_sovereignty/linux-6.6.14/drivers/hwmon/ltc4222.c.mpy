{
  "module_name": "ltc4222.c",
  "hash_id": "f8fd50897b1bb7259f08ebccd2be88803b2cfe726e5d7304c3ca091c8ac7a733",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ltc4222.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/regmap.h>\n\n \n\n#define LTC4222_CONTROL1\t0xd0\n#define LTC4222_ALERT1\t\t0xd1\n#define LTC4222_STATUS1\t\t0xd2\n#define LTC4222_FAULT1\t\t0xd3\n#define LTC4222_CONTROL2\t0xd4\n#define LTC4222_ALERT2\t\t0xd5\n#define LTC4222_STATUS2\t\t0xd6\n#define LTC4222_FAULT2\t\t0xd7\n#define LTC4222_SOURCE1\t\t0xd8\n#define LTC4222_SOURCE2\t\t0xda\n#define LTC4222_ADIN1\t\t0xdc\n#define LTC4222_ADIN2\t\t0xde\n#define LTC4222_SENSE1\t\t0xe0\n#define LTC4222_SENSE2\t\t0xe2\n#define LTC4222_ADC_CONTROL\t0xe4\n\n \n#define FAULT_OV\tBIT(0)\n#define FAULT_UV\tBIT(1)\n#define FAULT_OC\tBIT(2)\n#define FAULT_POWER_BAD\tBIT(3)\n#define FAULT_FET_BAD\tBIT(5)\n\n \nstatic int ltc4222_get_value(struct device *dev, u8 reg)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\tunsigned int val;\n\tu8 buf[2];\n\tint ret;\n\n\tret = regmap_bulk_read(regmap, reg, buf, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = ((buf[0] << 8) + buf[1]) >> 6;\n\n\tswitch (reg) {\n\tcase LTC4222_ADIN1:\n\tcase LTC4222_ADIN2:\n\t\t \n\t\tval = DIV_ROUND_CLOSEST(val * 5, 4);\n\t\tbreak;\n\tcase LTC4222_SOURCE1:\n\tcase LTC4222_SOURCE2:\n\t\t \n\t\tval = DIV_ROUND_CLOSEST(val * 125, 4);\n\t\tbreak;\n\tcase LTC4222_SENSE1:\n\tcase LTC4222_SENSE2:\n\t\t \n\t\tval = DIV_ROUND_CLOSEST(val * 125, 2);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn val;\n}\n\nstatic ssize_t ltc4222_value_show(struct device *dev,\n\t\t\t\t  struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint value;\n\n\tvalue = ltc4222_get_value(dev, attr->index);\n\tif (value < 0)\n\t\treturn value;\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t ltc4222_bool_show(struct device *dev,\n\t\t\t\t struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(da);\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\tunsigned int fault;\n\tint ret;\n\n\tret = regmap_read(regmap, attr->nr, &fault);\n\tif (ret < 0)\n\t\treturn ret;\n\tfault &= attr->index;\n\tif (fault)\t\t \n\t\tregmap_update_bits(regmap, attr->nr, attr->index, 0);\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!fault);\n}\n\n \nstatic SENSOR_DEVICE_ATTR_RO(in1_input, ltc4222_value, LTC4222_SOURCE1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, ltc4222_value, LTC4222_ADIN1);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, ltc4222_value, LTC4222_SOURCE2);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, ltc4222_value, LTC4222_ADIN2);\n\n \nstatic SENSOR_DEVICE_ATTR_2_RO(in1_min_alarm, ltc4222_bool, LTC4222_FAULT1,\n\t\t\t       FAULT_UV);\nstatic SENSOR_DEVICE_ATTR_2_RO(in1_max_alarm, ltc4222_bool, LTC4222_FAULT1,\n\t\t\t       FAULT_OV);\nstatic SENSOR_DEVICE_ATTR_2_RO(in2_alarm, ltc4222_bool, LTC4222_FAULT1,\n\t\t\t       FAULT_POWER_BAD | FAULT_FET_BAD);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in3_min_alarm, ltc4222_bool, LTC4222_FAULT2,\n\t\t\t       FAULT_UV);\nstatic SENSOR_DEVICE_ATTR_2_RO(in3_max_alarm, ltc4222_bool, LTC4222_FAULT2,\n\t\t\t       FAULT_OV);\nstatic SENSOR_DEVICE_ATTR_2_RO(in4_alarm, ltc4222_bool, LTC4222_FAULT2,\n\t\t\t       FAULT_POWER_BAD | FAULT_FET_BAD);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(curr1_input, ltc4222_value, LTC4222_SENSE1);\nstatic SENSOR_DEVICE_ATTR_RO(curr2_input, ltc4222_value, LTC4222_SENSE2);\n\n \nstatic SENSOR_DEVICE_ATTR_2_RO(curr1_max_alarm, ltc4222_bool, LTC4222_FAULT1,\n\t\t\t       FAULT_OC);\nstatic SENSOR_DEVICE_ATTR_2_RO(curr2_max_alarm, ltc4222_bool, LTC4222_FAULT2,\n\t\t\t       FAULT_OC);\n\nstatic struct attribute *ltc4222_attrs[] = {\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_curr1_input.dev_attr.attr,\n\t&sensor_dev_attr_curr1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_curr2_input.dev_attr.attr,\n\t&sensor_dev_attr_curr2_max_alarm.dev_attr.attr,\n\n\tNULL,\n};\nATTRIBUTE_GROUPS(ltc4222);\n\nstatic const struct regmap_config ltc4222_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = LTC4222_ADC_CONTROL,\n};\n\nstatic int ltc4222_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct regmap *regmap;\n\n\tregmap = devm_regmap_init_i2c(client, &ltc4222_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\t \n\tregmap_write(regmap, LTC4222_FAULT1, 0x00);\n\tregmap_write(regmap, LTC4222_FAULT2, 0x00);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   regmap,\n\t\t\t\t\t\t\t   ltc4222_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id ltc4222_id[] = {\n\t{\"ltc4222\", 0},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, ltc4222_id);\n\nstatic struct i2c_driver ltc4222_driver = {\n\t.driver = {\n\t\t   .name = \"ltc4222\",\n\t\t   },\n\t.probe = ltc4222_probe,\n\t.id_table = ltc4222_id,\n};\n\nmodule_i2c_driver(ltc4222_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"LTC4222 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}