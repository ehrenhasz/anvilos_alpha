{
  "module_name": "via686a.c",
  "hash_id": "e63199d526d53c2e8478b17e7c761eb92e8cbcb11f3ff8ca53265e5c6cdaf356",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/via686a.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\n#define DRIVER_NAME \"via686a\"\n\n \nstatic unsigned short force_addr;\nmodule_param(force_addr, ushort, 0);\nMODULE_PARM_DESC(force_addr,\n\t\t \"Initialize the base address of the sensors\");\n\nstatic struct platform_device *pdev;\n\n \n\n \n\n \n#define VIA686A_EXTENT\t\t0x80\n#define VIA686A_BASE_REG\t0x70\n#define VIA686A_ENABLE_REG\t0x74\n\n \n \n#define VIA686A_REG_IN_MAX(nr)\t(0x2b + ((nr) * 2))\n#define VIA686A_REG_IN_MIN(nr)\t(0x2c + ((nr) * 2))\n#define VIA686A_REG_IN(nr)\t(0x22 + (nr))\n\n \n#define VIA686A_REG_FAN_MIN(nr)\t(0x3a + (nr))\n#define VIA686A_REG_FAN(nr)\t(0x28 + (nr))\n\n \nstatic const u8 VIA686A_REG_TEMP[]\t= { 0x20, 0x21, 0x1f };\nstatic const u8 VIA686A_REG_TEMP_OVER[]\t= { 0x39, 0x3d, 0x1d };\nstatic const u8 VIA686A_REG_TEMP_HYST[]\t= { 0x3a, 0x3e, 0x1e };\n \n#define VIA686A_REG_TEMP_LOW1\t0x4b\n \n#define VIA686A_REG_TEMP_LOW23\t0x49\n\n#define VIA686A_REG_ALARM1\t0x41\n#define VIA686A_REG_ALARM2\t0x42\n#define VIA686A_REG_FANDIV\t0x47\n#define VIA686A_REG_CONFIG\t0x40\n \n#define VIA686A_REG_TEMP_MODE\t\t0x4b\n \n#define VIA686A_TEMP_MODE_MASK\t\t0x3F\n#define VIA686A_TEMP_MODE_CONTINUOUS\t0x00\n\n \nstatic inline u8 IN_TO_REG(long val, int in_num)\n{\n\t \n\tif (in_num <= 1)\n\t\treturn (u8) clamp_val((val * 21024 - 1205000) / 250000, 0, 255);\n\telse if (in_num == 2)\n\t\treturn (u8) clamp_val((val * 15737 - 1205000) / 250000, 0, 255);\n\telse if (in_num == 3)\n\t\treturn (u8) clamp_val((val * 10108 - 1205000) / 250000, 0, 255);\n\telse\n\t\treturn (u8) clamp_val((val * 41714 - 12050000) / 2500000, 0,\n\t\t\t\t      255);\n}\n\nstatic inline long IN_FROM_REG(u8 val, int in_num)\n{\n\t \n\tif (in_num <= 1)\n\t\treturn (long) ((250000 * val + 1330000 + 21024 / 2) / 21024);\n\telse if (in_num == 2)\n\t\treturn (long) ((250000 * val + 1330000 + 15737 / 2) / 15737);\n\telse if (in_num == 3)\n\t\treturn (long) ((250000 * val + 1330000 + 10108 / 2) / 10108);\n\telse\n\t\treturn (long) ((2500000 * val + 13300000 + 41714 / 2) / 41714);\n}\n\n \n \nstatic inline u8 FAN_TO_REG(long rpm, int div)\n{\n\tif (rpm == 0)\n\t\treturn 0;\n\trpm = clamp_val(rpm, 1, 1000000);\n\treturn clamp_val((1350000 + rpm * div / 2) / (rpm * div), 1, 255);\n}\n\n#define FAN_FROM_REG(val, div) ((val) == 0 ? 0 : (val) == 255 ? 0 : 1350000 / \\\n\t\t\t\t((val) * (div)))\n\n \n \nstatic const s16 temp_lut[] = {\n\t-709, -688, -667, -646, -627, -607, -589, -570, -553, -536, -519,\n\t-503, -487, -471, -456, -442, -428, -414, -400, -387, -375,\n\t-362, -350, -339, -327, -316, -305, -295, -285, -275, -265,\n\t-255, -246, -237, -229, -220, -212, -204, -196, -188, -180,\n\t-173, -166, -159, -152, -145, -139, -132, -126, -120, -114,\n\t-108, -102, -96, -91, -85, -80, -74, -69, -64, -59, -54, -49,\n\t-44, -39, -34, -29, -25, -20, -15, -11, -6, -2, 3, 7, 12, 16,\n\t20, 25, 29, 33, 37, 42, 46, 50, 54, 59, 63, 67, 71, 75, 79, 84,\n\t88, 92, 96, 100, 104, 109, 113, 117, 121, 125, 130, 134, 138,\n\t142, 146, 151, 155, 159, 163, 168, 172, 176, 181, 185, 189,\n\t193, 198, 202, 206, 211, 215, 219, 224, 228, 232, 237, 241,\n\t245, 250, 254, 259, 263, 267, 272, 276, 281, 285, 290, 294,\n\t299, 303, 307, 312, 316, 321, 325, 330, 334, 339, 344, 348,\n\t353, 357, 362, 366, 371, 376, 380, 385, 390, 395, 399, 404,\n\t409, 414, 419, 423, 428, 433, 438, 443, 449, 454, 459, 464,\n\t469, 475, 480, 486, 491, 497, 502, 508, 514, 520, 526, 532,\n\t538, 544, 551, 557, 564, 571, 578, 584, 592, 599, 606, 614,\n\t621, 629, 637, 645, 654, 662, 671, 680, 689, 698, 708, 718,\n\t728, 738, 749, 759, 770, 782, 793, 805, 818, 830, 843, 856,\n\t870, 883, 898, 912, 927, 943, 958, 975, 991, 1008, 1026, 1044,\n\t1062, 1081, 1101, 1121, 1141, 1162, 1184, 1206, 1229, 1252,\n\t1276, 1301, 1326, 1352, 1378, 1406, 1434, 1462\n};\n\n \nstatic const u8 via_lut[] = {\n\t12, 12, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 20, 21, 22, 23,\n\t23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 39, 40,\n\t41, 43, 45, 46, 48, 49, 51, 53, 55, 57, 59, 60, 62, 64, 66,\n\t69, 71, 73, 75, 77, 79, 82, 84, 86, 88, 91, 93, 95, 98, 100,\n\t103, 105, 107, 110, 112, 115, 117, 119, 122, 124, 126, 129,\n\t131, 134, 136, 138, 140, 143, 145, 147, 150, 152, 154, 156,\n\t158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,\n\t182, 183, 185, 187, 188, 190, 192, 193, 195, 196, 198, 199,\n\t200, 202, 203, 205, 206, 207, 208, 209, 210, 211, 212, 213,\n\t214, 215, 216, 217, 218, 219, 220, 221, 222, 222, 223, 224,\n\t225, 226, 226, 227, 228, 228, 229, 230, 230, 231, 232, 232,\n\t233, 233, 234, 235, 235, 236, 236, 237, 237, 238, 238, 239,\n\t239, 240\n};\n\n \nstatic inline u8 TEMP_TO_REG(long val)\n{\n\treturn via_lut[val <= -50000 ? 0 : val >= 110000 ? 160 :\n\t\t      (val < 0 ? val - 500 : val + 500) / 1000 + 50];\n}\n\n \n#define TEMP_FROM_REG(val)\t((long)temp_lut[val] * 100)\n\n \nstatic inline long TEMP_FROM_REG10(u16 val)\n{\n\tu16 eight_bits = val >> 2;\n\tu16 two_bits = val & 3;\n\n\t \n\tif (two_bits == 0 || eight_bits == 255)\n\t\treturn TEMP_FROM_REG(eight_bits);\n\n\t \n\treturn (temp_lut[eight_bits] * (4 - two_bits) +\n\t\ttemp_lut[eight_bits + 1] * two_bits) * 25;\n}\n\n#define DIV_FROM_REG(val) (1 << (val))\n#define DIV_TO_REG(val) ((val) == 8 ? 3 : (val) == 4 ? 2 : (val) == 1 ? 0 : 1)\n\n \nstruct via686a_data {\n\tunsigned short addr;\n\tconst char *name;\n\tstruct device *hwmon_dev;\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\n\tu8 in[5];\t\t \n\tu8 in_max[5];\t\t \n\tu8 in_min[5];\t\t \n\tu8 fan[2];\t\t \n\tu8 fan_min[2];\t\t \n\tu16 temp[3];\t\t \n\tu8 temp_over[3];\t \n\tu8 temp_hyst[3];\t \n\tu8 fan_div[2];\t\t \n\tu16 alarms;\t\t \n};\n\nstatic struct pci_dev *s_bridge;\t \n\nstatic inline int via686a_read_value(struct via686a_data *data, u8 reg)\n{\n\treturn inb_p(data->addr + reg);\n}\n\nstatic inline void via686a_write_value(struct via686a_data *data, u8 reg,\n\t\t\t\t       u8 value)\n{\n\toutb_p(value, data->addr + reg);\n}\n\nstatic void via686a_update_fan_div(struct via686a_data *data)\n{\n\tint reg = via686a_read_value(data, VIA686A_REG_FANDIV);\n\tdata->fan_div[0] = (reg >> 4) & 0x03;\n\tdata->fan_div[1] = reg >> 6;\n}\n\nstatic struct via686a_data *via686a_update_device(struct device *dev)\n{\n\tstruct via686a_data *data = dev_get_drvdata(dev);\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\n\t    || !data->valid) {\n\t\tfor (i = 0; i <= 4; i++) {\n\t\t\tdata->in[i] =\n\t\t\t    via686a_read_value(data, VIA686A_REG_IN(i));\n\t\t\tdata->in_min[i] = via686a_read_value(data,\n\t\t\t\t\t\t\t     VIA686A_REG_IN_MIN\n\t\t\t\t\t\t\t     (i));\n\t\t\tdata->in_max[i] =\n\t\t\t    via686a_read_value(data, VIA686A_REG_IN_MAX(i));\n\t\t}\n\t\tfor (i = 1; i <= 2; i++) {\n\t\t\tdata->fan[i - 1] =\n\t\t\t    via686a_read_value(data, VIA686A_REG_FAN(i));\n\t\t\tdata->fan_min[i - 1] = via686a_read_value(data,\n\t\t\t\t\t\t     VIA686A_REG_FAN_MIN(i));\n\t\t}\n\t\tfor (i = 0; i <= 2; i++) {\n\t\t\tdata->temp[i] = via686a_read_value(data,\n\t\t\t\t\t\t VIA686A_REG_TEMP[i]) << 2;\n\t\t\tdata->temp_over[i] =\n\t\t\t    via686a_read_value(data,\n\t\t\t\t\t       VIA686A_REG_TEMP_OVER[i]);\n\t\t\tdata->temp_hyst[i] =\n\t\t\t    via686a_read_value(data,\n\t\t\t\t\t       VIA686A_REG_TEMP_HYST[i]);\n\t\t}\n\t\t \n\t\tdata->temp[0] |= (via686a_read_value(data,\n\t\t\t\t\t\t     VIA686A_REG_TEMP_LOW1)\n\t\t\t\t  & 0xc0) >> 6;\n\t\tdata->temp[1] |=\n\t\t    (via686a_read_value(data, VIA686A_REG_TEMP_LOW23) &\n\t\t     0x30) >> 4;\n\t\tdata->temp[2] |=\n\t\t    (via686a_read_value(data, VIA686A_REG_TEMP_LOW23) &\n\t\t     0xc0) >> 6;\n\n\t\tvia686a_update_fan_div(data);\n\t\tdata->alarms =\n\t\t    via686a_read_value(data,\n\t\t\t\t       VIA686A_REG_ALARM1) |\n\t\t    (via686a_read_value(data, VIA686A_REG_ALARM2) << 8);\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \n\n \nstatic ssize_t in_show(struct device *dev, struct device_attribute *da,\n\t\t       char *buf) {\n\tstruct via686a_data *data = via686a_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\treturn sprintf(buf, \"%ld\\n\", IN_FROM_REG(data->in[nr], nr));\n}\n\nstatic ssize_t in_min_show(struct device *dev, struct device_attribute *da,\n\t\t\t   char *buf) {\n\tstruct via686a_data *data = via686a_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\treturn sprintf(buf, \"%ld\\n\", IN_FROM_REG(data->in_min[nr], nr));\n}\n\nstatic ssize_t in_max_show(struct device *dev, struct device_attribute *da,\n\t\t\t   char *buf) {\n\tstruct via686a_data *data = via686a_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\treturn sprintf(buf, \"%ld\\n\", IN_FROM_REG(data->in_max[nr], nr));\n}\n\nstatic ssize_t in_min_store(struct device *dev, struct device_attribute *da,\n\t\t\t    const char *buf, size_t count) {\n\tstruct via686a_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_min[nr] = IN_TO_REG(val, nr);\n\tvia686a_write_value(data, VIA686A_REG_IN_MIN(nr),\n\t\t\tdata->in_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\nstatic ssize_t in_max_store(struct device *dev, struct device_attribute *da,\n\t\t\t    const char *buf, size_t count) {\n\tstruct via686a_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_max[nr] = IN_TO_REG(val, nr);\n\tvia686a_write_value(data, VIA686A_REG_IN_MAX(nr),\n\t\t\tdata->in_max[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_input, in, 0);\nstatic SENSOR_DEVICE_ATTR_RW(in0_min, in_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(in0_max, in_max, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, in, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in1_min, in_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in1_max, in_max, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, in, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in2_min, in_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in2_max, in_max, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, in, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in3_min, in_min, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in3_max, in_max, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, in, 4);\nstatic SENSOR_DEVICE_ATTR_RW(in4_min, in_min, 4);\nstatic SENSOR_DEVICE_ATTR_RW(in4_max, in_max, 4);\n\n \nstatic ssize_t temp_show(struct device *dev, struct device_attribute *da,\n\t\t\t char *buf) {\n\tstruct via686a_data *data = via686a_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\treturn sprintf(buf, \"%ld\\n\", TEMP_FROM_REG10(data->temp[nr]));\n}\nstatic ssize_t temp_over_show(struct device *dev, struct device_attribute *da,\n\t\t\t      char *buf) {\n\tstruct via686a_data *data = via686a_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\treturn sprintf(buf, \"%ld\\n\", TEMP_FROM_REG(data->temp_over[nr]));\n}\nstatic ssize_t temp_hyst_show(struct device *dev, struct device_attribute *da,\n\t\t\t      char *buf) {\n\tstruct via686a_data *data = via686a_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\treturn sprintf(buf, \"%ld\\n\", TEMP_FROM_REG(data->temp_hyst[nr]));\n}\nstatic ssize_t temp_over_store(struct device *dev,\n\t\t\t       struct device_attribute *da, const char *buf,\n\t\t\t       size_t count) {\n\tstruct via686a_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_over[nr] = TEMP_TO_REG(val);\n\tvia686a_write_value(data, VIA686A_REG_TEMP_OVER[nr],\n\t\t\t    data->temp_over[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\nstatic ssize_t temp_hyst_store(struct device *dev,\n\t\t\t       struct device_attribute *da, const char *buf,\n\t\t\t       size_t count) {\n\tstruct via686a_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_hyst[nr] = TEMP_TO_REG(val);\n\tvia686a_write_value(data, VIA686A_REG_TEMP_HYST[nr],\n\t\t\t    data->temp_hyst[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp_over, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max_hyst, temp_hyst, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp_over, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max_hyst, temp_hyst, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_max, temp_over, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_max_hyst, temp_hyst, 2);\n\n \nstatic ssize_t fan_show(struct device *dev, struct device_attribute *da,\n\t\t\tchar *buf) {\n\tstruct via686a_data *data = via686a_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\treturn sprintf(buf, \"%d\\n\", FAN_FROM_REG(data->fan[nr],\n\t\t\t\tDIV_FROM_REG(data->fan_div[nr])));\n}\nstatic ssize_t fan_min_show(struct device *dev, struct device_attribute *da,\n\t\t\t    char *buf) {\n\tstruct via686a_data *data = via686a_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\treturn sprintf(buf, \"%d\\n\",\n\t\tFAN_FROM_REG(data->fan_min[nr],\n\t\t\t     DIV_FROM_REG(data->fan_div[nr])));\n}\nstatic ssize_t fan_div_show(struct device *dev, struct device_attribute *da,\n\t\t\t    char *buf) {\n\tstruct via686a_data *data = via686a_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\treturn sprintf(buf, \"%d\\n\", DIV_FROM_REG(data->fan_div[nr]));\n}\nstatic ssize_t fan_min_store(struct device *dev, struct device_attribute *da,\n\t\t\t     const char *buf, size_t count) {\n\tstruct via686a_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\n\tvia686a_write_value(data, VIA686A_REG_FAN_MIN(nr+1), data->fan_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\nstatic ssize_t fan_div_store(struct device *dev, struct device_attribute *da,\n\t\t\t     const char *buf, size_t count) {\n\tstruct via686a_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint nr = attr->index;\n\tint old;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\told = via686a_read_value(data, VIA686A_REG_FANDIV);\n\tdata->fan_div[nr] = DIV_TO_REG(val);\n\told = (old & 0x0f) | (data->fan_div[1] << 6) | (data->fan_div[0] << 4);\n\tvia686a_write_value(data, VIA686A_REG_FANDIV, old);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_min, fan_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_div, fan_div, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_min, fan_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_div, fan_div, 1);\n\n \nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct via686a_data *data = via686a_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", data->alarms);\n}\n\nstatic DEVICE_ATTR_RO(alarms);\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tstruct via686a_data *data = via686a_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> bitnr) & 1);\n}\nstatic SENSOR_DEVICE_ATTR_RO(in0_alarm, alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_alarm, alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_alarm, alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_alarm, alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_alarm, alarm, 8);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_alarm, alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_alarm, alarm, 11);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_alarm, alarm, 15);\nstatic SENSOR_DEVICE_ATTR_RO(fan1_alarm, alarm, 6);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_alarm, alarm, 7);\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute\n\t\t\t *devattr, char *buf)\n{\n\tstruct via686a_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%s\\n\", data->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic struct attribute *via686a_attributes[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_div.dev_attr.attr,\n\t&sensor_dev_attr_fan2_div.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\n\t&dev_attr_alarms.attr,\n\t&dev_attr_name.attr,\n\tNULL\n};\n\nstatic const struct attribute_group via686a_group = {\n\t.attrs = via686a_attributes,\n};\n\nstatic void via686a_init_device(struct via686a_data *data)\n{\n\tu8 reg;\n\n\t \n\treg = via686a_read_value(data, VIA686A_REG_CONFIG);\n\tvia686a_write_value(data, VIA686A_REG_CONFIG, (reg | 0x01) & 0x7F);\n\n\t \n\treg = via686a_read_value(data, VIA686A_REG_TEMP_MODE);\n\tvia686a_write_value(data, VIA686A_REG_TEMP_MODE,\n\t\t\t    (reg & ~VIA686A_TEMP_MODE_MASK)\n\t\t\t    | VIA686A_TEMP_MODE_CONTINUOUS);\n\n\t \n\tvia686a_update_fan_div(data);\n}\n\n \nstatic int via686a_probe(struct platform_device *pdev)\n{\n\tstruct via686a_data *data;\n\tstruct resource *res;\n\tint err;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!devm_request_region(&pdev->dev, res->start, VIA686A_EXTENT,\n\t\t\t\t DRIVER_NAME)) {\n\t\tdev_err(&pdev->dev, \"Region 0x%lx-0x%lx already in use!\\n\",\n\t\t\t(unsigned long)res->start, (unsigned long)res->end);\n\t\treturn -ENODEV;\n\t}\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct via686a_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, data);\n\tdata->addr = res->start;\n\tdata->name = DRIVER_NAME;\n\tmutex_init(&data->update_lock);\n\n\t \n\tvia686a_init_device(data);\n\n\t \n\terr = sysfs_create_group(&pdev->dev.kobj, &via686a_group);\n\tif (err)\n\t\treturn err;\n\n\tdata->hwmon_dev = hwmon_device_register(&pdev->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto exit_remove_files;\n\t}\n\n\treturn 0;\n\nexit_remove_files:\n\tsysfs_remove_group(&pdev->dev.kobj, &via686a_group);\n\treturn err;\n}\n\nstatic int via686a_remove(struct platform_device *pdev)\n{\n\tstruct via686a_data *data = platform_get_drvdata(pdev);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tsysfs_remove_group(&pdev->dev.kobj, &via686a_group);\n\n\treturn 0;\n}\n\nstatic struct platform_driver via686a_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t},\n\t.probe\t\t= via686a_probe,\n\t.remove\t\t= via686a_remove,\n};\n\nstatic const struct pci_device_id via686a_pci_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686_4) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, via686a_pci_ids);\n\nstatic int via686a_device_add(unsigned short address)\n{\n\tstruct resource res = {\n\t\t.start\t= address,\n\t\t.end\t= address + VIA686A_EXTENT - 1,\n\t\t.name\t= DRIVER_NAME,\n\t\t.flags\t= IORESOURCE_IO,\n\t};\n\tint err;\n\n\terr = acpi_check_resource_conflict(&res);\n\tif (err)\n\t\tgoto exit;\n\n\tpdev = platform_device_alloc(DRIVER_NAME, address);\n\tif (!pdev) {\n\t\terr = -ENOMEM;\n\t\tpr_err(\"Device allocation failed\\n\");\n\t\tgoto exit;\n\t}\n\n\terr = platform_device_add_resources(pdev, &res, 1);\n\tif (err) {\n\t\tpr_err(\"Device resource addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n\t\tpr_err(\"Device addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\treturn 0;\n\nexit_device_put:\n\tplatform_device_put(pdev);\nexit:\n\treturn err;\n}\n\nstatic int via686a_pci_probe(struct pci_dev *dev,\n\t\t\t\t       const struct pci_device_id *id)\n{\n\tu16 address, val;\n\tint ret;\n\n\tif (force_addr) {\n\t\taddress = force_addr & ~(VIA686A_EXTENT - 1);\n\t\tdev_warn(&dev->dev, \"Forcing ISA address 0x%x\\n\", address);\n\t\tret = pci_write_config_word(dev, VIA686A_BASE_REG, address | 1);\n\t\tif (ret != PCIBIOS_SUCCESSFUL)\n\t\t\treturn -ENODEV;\n\t}\n\tret = pci_read_config_word(dev, VIA686A_BASE_REG, &val);\n\tif (ret != PCIBIOS_SUCCESSFUL)\n\t\treturn -ENODEV;\n\n\taddress = val & ~(VIA686A_EXTENT - 1);\n\tif (address == 0) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"base address not set - upgrade BIOS or use force_addr=0xaddr\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = pci_read_config_word(dev, VIA686A_ENABLE_REG, &val);\n\tif (ret != PCIBIOS_SUCCESSFUL)\n\t\treturn -ENODEV;\n\tif (!(val & 0x0001)) {\n\t\tif (!force_addr) {\n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"Sensors disabled, enable with force_addr=0x%x\\n\",\n\t\t\t\t address);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tdev_warn(&dev->dev, \"Enabling sensors\\n\");\n\t\tret = pci_write_config_word(dev, VIA686A_ENABLE_REG, val | 0x1);\n\t\tif (ret != PCIBIOS_SUCCESSFUL)\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (platform_driver_register(&via686a_driver))\n\t\tgoto exit;\n\n\t \n\tif (via686a_device_add(address))\n\t\tgoto exit_unregister;\n\n\t \n\ts_bridge = pci_dev_get(dev);\n\treturn -ENODEV;\n\nexit_unregister:\n\tplatform_driver_unregister(&via686a_driver);\nexit:\n\treturn -ENODEV;\n}\n\nstatic struct pci_driver via686a_pci_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.id_table\t= via686a_pci_ids,\n\t.probe\t\t= via686a_pci_probe,\n};\n\nstatic int __init sm_via686a_init(void)\n{\n\treturn pci_register_driver(&via686a_pci_driver);\n}\n\nstatic void __exit sm_via686a_exit(void)\n{\n\tpci_unregister_driver(&via686a_pci_driver);\n\tif (s_bridge != NULL) {\n\t\tplatform_device_unregister(pdev);\n\t\tplatform_driver_unregister(&via686a_driver);\n\t\tpci_dev_put(s_bridge);\n\t\ts_bridge = NULL;\n\t}\n}\n\nMODULE_AUTHOR(\"Ky\u00f6sti M\u00e4lkki <kmalkki@cc.hut.fi>, \"\n\t      \"Mark Studebaker <mdsxyz123@yahoo.com> \"\n\t      \"and Bob Dougherty <bobd@stanford.edu>\");\nMODULE_DESCRIPTION(\"VIA 686A Sensor device\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(sm_via686a_init);\nmodule_exit(sm_via686a_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}