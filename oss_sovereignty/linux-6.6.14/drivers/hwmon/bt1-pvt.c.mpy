{
  "module_name": "bt1-pvt.c",
  "hash_id": "ab8309339141185c0e6228db68232cce0f1cbaf3f80bd0b274bd6c065e12c5a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/bt1-pvt.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/polynomial.h>\n#include <linux/seqlock.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n\n#include \"bt1-pvt.h\"\n\n \nstatic const struct pvt_sensor_info pvt_info[] = {\n\tPVT_SENSOR_INFO(0, \"CPU Core Temperature\", hwmon_temp, TEMP, TTHRES),\n\tPVT_SENSOR_INFO(0, \"CPU Core Voltage\", hwmon_in, VOLT, VTHRES),\n\tPVT_SENSOR_INFO(1, \"CPU Core Low-Vt\", hwmon_in, LVT, LTHRES),\n\tPVT_SENSOR_INFO(2, \"CPU Core High-Vt\", hwmon_in, HVT, HTHRES),\n\tPVT_SENSOR_INFO(3, \"CPU Core Standard-Vt\", hwmon_in, SVT, STHRES),\n};\n\n \nstatic const struct polynomial __maybe_unused poly_temp_to_N = {\n\t.total_divider = 10000,\n\t.terms = {\n\t\t{4, 18322, 10000, 10000},\n\t\t{3, 2343, 10000, 10},\n\t\t{2, 87018, 10000, 10},\n\t\t{1, 39269, 1000, 1},\n\t\t{0, 1720400, 1, 1}\n\t}\n};\n\nstatic const struct polynomial poly_N_to_temp = {\n\t.total_divider = 1,\n\t.terms = {\n\t\t{4, -16743, 1000, 1},\n\t\t{3, 81542, 1000, 1},\n\t\t{2, -182010, 1000, 1},\n\t\t{1, 310200, 1000, 1},\n\t\t{0, -48380, 1, 1}\n\t}\n};\n\n \nstatic const struct polynomial __maybe_unused poly_volt_to_N = {\n\t.total_divider = 10,\n\t.terms = {\n\t\t{1, 18658, 1000, 1},\n\t\t{0, -11572, 1, 1}\n\t}\n};\n\nstatic const struct polynomial poly_N_to_volt = {\n\t.total_divider = 10,\n\t.terms = {\n\t\t{1, 100000, 18658, 1},\n\t\t{0, 115720000, 1, 18658}\n\t}\n};\n\nstatic inline u32 pvt_update(void __iomem *reg, u32 mask, u32 data)\n{\n\tu32 old;\n\n\told = readl_relaxed(reg);\n\twritel((old & ~mask) | (data & mask), reg);\n\n\treturn old & mask;\n}\n\n \nstatic inline void pvt_set_mode(struct pvt_hwmon *pvt, u32 mode)\n{\n\tu32 old;\n\n\tmode = FIELD_PREP(PVT_CTRL_MODE_MASK, mode);\n\n\told = pvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_EN, 0);\n\tpvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_MODE_MASK | PVT_CTRL_EN,\n\t\t   mode | old);\n}\n\nstatic inline u32 pvt_calc_trim(long temp)\n{\n\ttemp = clamp_val(temp, 0, PVT_TRIM_TEMP);\n\n\treturn DIV_ROUND_UP(temp, PVT_TRIM_STEP);\n}\n\nstatic inline void pvt_set_trim(struct pvt_hwmon *pvt, u32 trim)\n{\n\tu32 old;\n\n\ttrim = FIELD_PREP(PVT_CTRL_TRIM_MASK, trim);\n\n\told = pvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_EN, 0);\n\tpvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_TRIM_MASK | PVT_CTRL_EN,\n\t\t   trim | old);\n}\n\nstatic inline void pvt_set_tout(struct pvt_hwmon *pvt, u32 tout)\n{\n\tu32 old;\n\n\told = pvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_EN, 0);\n\twritel(tout, pvt->regs + PVT_TTIMEOUT);\n\tpvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_EN, old);\n}\n\n \n\n#if defined(CONFIG_SENSORS_BT1_PVT_ALARMS)\n\n#define pvt_hard_isr NULL\n\nstatic irqreturn_t pvt_soft_isr(int irq, void *data)\n{\n\tconst struct pvt_sensor_info *info;\n\tstruct pvt_hwmon *pvt = data;\n\tstruct pvt_cache *cache;\n\tu32 val, thres_sts, old;\n\n\t \n\tthres_sts = readl(pvt->regs + PVT_RAW_INTR_STAT);\n\n\t \n\tcache = &pvt->cache[pvt->sensor];\n\tinfo = &pvt_info[pvt->sensor];\n\tpvt->sensor = (pvt->sensor == PVT_SENSOR_LAST) ?\n\t\t      PVT_SENSOR_FIRST : (pvt->sensor + 1);\n\n\t \n\tmutex_lock(&pvt->iface_mtx);\n\n\told = pvt_update(pvt->regs + PVT_INTR_MASK, PVT_INTR_DVALID,\n\t\t\t PVT_INTR_DVALID);\n\n\tval = readl(pvt->regs + PVT_DATA);\n\n\tpvt_set_mode(pvt, pvt_info[pvt->sensor].mode);\n\n\tpvt_update(pvt->regs + PVT_INTR_MASK, PVT_INTR_DVALID, old);\n\n\tmutex_unlock(&pvt->iface_mtx);\n\n\t \n\twrite_seqlock(&cache->data_seqlock);\n\n\tcache->data = FIELD_GET(PVT_DATA_DATA_MASK, val);\n\n\twrite_sequnlock(&cache->data_seqlock);\n\n\t \n\tif ((thres_sts & info->thres_sts_lo) ^ cache->thres_sts_lo) {\n\t\tWRITE_ONCE(cache->thres_sts_lo, thres_sts & info->thres_sts_lo);\n\t\thwmon_notify_event(pvt->hwmon, info->type, info->attr_min_alarm,\n\t\t\t\t   info->channel);\n\t} else if ((thres_sts & info->thres_sts_hi) ^ cache->thres_sts_hi) {\n\t\tWRITE_ONCE(cache->thres_sts_hi, thres_sts & info->thres_sts_hi);\n\t\thwmon_notify_event(pvt->hwmon, info->type, info->attr_max_alarm,\n\t\t\t\t   info->channel);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline umode_t pvt_limit_is_visible(enum pvt_sensor_type type)\n{\n\treturn 0644;\n}\n\nstatic inline umode_t pvt_alarm_is_visible(enum pvt_sensor_type type)\n{\n\treturn 0444;\n}\n\nstatic int pvt_read_data(struct pvt_hwmon *pvt, enum pvt_sensor_type type,\n\t\t\t long *val)\n{\n\tstruct pvt_cache *cache = &pvt->cache[type];\n\tunsigned int seq;\n\tu32 data;\n\n\tdo {\n\t\tseq = read_seqbegin(&cache->data_seqlock);\n\t\tdata = cache->data;\n\t} while (read_seqretry(&cache->data_seqlock, seq));\n\n\tif (type == PVT_TEMP)\n\t\t*val = polynomial_calc(&poly_N_to_temp, data);\n\telse\n\t\t*val = polynomial_calc(&poly_N_to_volt, data);\n\n\treturn 0;\n}\n\nstatic int pvt_read_limit(struct pvt_hwmon *pvt, enum pvt_sensor_type type,\n\t\t\t  bool is_low, long *val)\n{\n\tu32 data;\n\n\t \n\tdata = readl(pvt->regs + pvt_info[type].thres_base);\n\n\tif (is_low)\n\t\tdata = FIELD_GET(PVT_THRES_LO_MASK, data);\n\telse\n\t\tdata = FIELD_GET(PVT_THRES_HI_MASK, data);\n\n\tif (type == PVT_TEMP)\n\t\t*val = polynomial_calc(&poly_N_to_temp, data);\n\telse\n\t\t*val = polynomial_calc(&poly_N_to_volt, data);\n\n\treturn 0;\n}\n\nstatic int pvt_write_limit(struct pvt_hwmon *pvt, enum pvt_sensor_type type,\n\t\t\t   bool is_low, long val)\n{\n\tu32 data, limit, mask;\n\tint ret;\n\n\tif (type == PVT_TEMP) {\n\t\tval = clamp(val, PVT_TEMP_MIN, PVT_TEMP_MAX);\n\t\tdata = polynomial_calc(&poly_temp_to_N, val);\n\t} else {\n\t\tval = clamp(val, PVT_VOLT_MIN, PVT_VOLT_MAX);\n\t\tdata = polynomial_calc(&poly_volt_to_N, val);\n\t}\n\n\t \n\tret = mutex_lock_interruptible(&pvt->iface_mtx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlimit = readl(pvt->regs + pvt_info[type].thres_base);\n\tif (is_low) {\n\t\tlimit = FIELD_GET(PVT_THRES_HI_MASK, limit);\n\t\tdata = clamp_val(data, PVT_DATA_MIN, limit);\n\t\tdata = FIELD_PREP(PVT_THRES_LO_MASK, data);\n\t\tmask = PVT_THRES_LO_MASK;\n\t} else {\n\t\tlimit = FIELD_GET(PVT_THRES_LO_MASK, limit);\n\t\tdata = clamp_val(data, limit, PVT_DATA_MAX);\n\t\tdata = FIELD_PREP(PVT_THRES_HI_MASK, data);\n\t\tmask = PVT_THRES_HI_MASK;\n\t}\n\n\tpvt_update(pvt->regs + pvt_info[type].thres_base, mask, data);\n\n\tmutex_unlock(&pvt->iface_mtx);\n\n\treturn 0;\n}\n\nstatic int pvt_read_alarm(struct pvt_hwmon *pvt, enum pvt_sensor_type type,\n\t\t\t  bool is_low, long *val)\n{\n\tif (is_low)\n\t\t*val = !!READ_ONCE(pvt->cache[type].thres_sts_lo);\n\telse\n\t\t*val = !!READ_ONCE(pvt->cache[type].thres_sts_hi);\n\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const pvt_channel_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ | HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_TYPE | HWMON_T_LABEL |\n\t\t\t   HWMON_T_MIN | HWMON_T_MIN_ALARM |\n\t\t\t   HWMON_T_MAX | HWMON_T_MAX_ALARM |\n\t\t\t   HWMON_T_OFFSET),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL |\n\t\t\t   HWMON_I_MIN | HWMON_I_MIN_ALARM |\n\t\t\t   HWMON_I_MAX | HWMON_I_MAX_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL |\n\t\t\t   HWMON_I_MIN | HWMON_I_MIN_ALARM |\n\t\t\t   HWMON_I_MAX | HWMON_I_MAX_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL |\n\t\t\t   HWMON_I_MIN | HWMON_I_MIN_ALARM |\n\t\t\t   HWMON_I_MAX | HWMON_I_MAX_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL |\n\t\t\t   HWMON_I_MIN | HWMON_I_MIN_ALARM |\n\t\t\t   HWMON_I_MAX | HWMON_I_MAX_ALARM),\n\tNULL\n};\n\n#else  \n\nstatic irqreturn_t pvt_hard_isr(int irq, void *data)\n{\n\tstruct pvt_hwmon *pvt = data;\n\tstruct pvt_cache *cache;\n\tu32 val;\n\n\t \n\tpvt_update(pvt->regs + PVT_INTR_MASK, PVT_INTR_DVALID,\n\t\t   PVT_INTR_DVALID);\n\n\t \n\tval = readl(pvt->regs + PVT_DATA);\n\tif (!(val & PVT_DATA_VALID)) {\n\t\tdev_err(pvt->dev, \"Got IRQ when data isn't valid\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tcache = &pvt->cache[pvt->sensor];\n\n\tWRITE_ONCE(cache->data, FIELD_GET(PVT_DATA_DATA_MASK, val));\n\n\tcomplete(&cache->conversion);\n\n\treturn IRQ_HANDLED;\n}\n\n#define pvt_soft_isr NULL\n\nstatic inline umode_t pvt_limit_is_visible(enum pvt_sensor_type type)\n{\n\treturn 0;\n}\n\nstatic inline umode_t pvt_alarm_is_visible(enum pvt_sensor_type type)\n{\n\treturn 0;\n}\n\nstatic int pvt_read_data(struct pvt_hwmon *pvt, enum pvt_sensor_type type,\n\t\t\t long *val)\n{\n\tstruct pvt_cache *cache = &pvt->cache[type];\n\tunsigned long timeout;\n\tu32 data;\n\tint ret;\n\n\t \n\tret = mutex_lock_interruptible(&pvt->iface_mtx);\n\tif (ret)\n\t\treturn ret;\n\n\tpvt->sensor = type;\n\tpvt_set_mode(pvt, pvt_info[type].mode);\n\n\t \n\tpvt_update(pvt->regs + PVT_INTR_MASK, PVT_INTR_DVALID, 0);\n\tpvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_EN, PVT_CTRL_EN);\n\n\t \n\ttimeout = 2 * usecs_to_jiffies(ktime_to_us(pvt->timeout));\n\tret = wait_for_completion_timeout(&cache->conversion, timeout);\n\n\tpvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_EN, 0);\n\tpvt_update(pvt->regs + PVT_INTR_MASK, PVT_INTR_DVALID,\n\t\t   PVT_INTR_DVALID);\n\n\tdata = READ_ONCE(cache->data);\n\n\tmutex_unlock(&pvt->iface_mtx);\n\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\tif (type == PVT_TEMP)\n\t\t*val = polynomial_calc(&poly_N_to_temp, data);\n\telse\n\t\t*val = polynomial_calc(&poly_N_to_volt, data);\n\n\treturn 0;\n}\n\nstatic int pvt_read_limit(struct pvt_hwmon *pvt, enum pvt_sensor_type type,\n\t\t\t  bool is_low, long *val)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pvt_write_limit(struct pvt_hwmon *pvt, enum pvt_sensor_type type,\n\t\t\t   bool is_low, long val)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pvt_read_alarm(struct pvt_hwmon *pvt, enum pvt_sensor_type type,\n\t\t\t  bool is_low, long *val)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct hwmon_channel_info * const pvt_channel_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ | HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_TYPE | HWMON_T_LABEL |\n\t\t\t   HWMON_T_OFFSET),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL),\n\tNULL\n};\n\n#endif  \n\nstatic inline bool pvt_hwmon_channel_is_valid(enum hwmon_sensor_types type,\n\t\t\t\t\t      int ch)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tif (ch < 0 || ch >= PVT_TEMP_CHS)\n\t\t\treturn false;\n\t\tbreak;\n\tcase hwmon_in:\n\t\tif (ch < 0 || ch >= PVT_VOLT_CHS)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\treturn true;\n}\n\nstatic umode_t pvt_hwmon_is_visible(const void *data,\n\t\t\t\t    enum hwmon_sensor_types type,\n\t\t\t\t    u32 attr, int ch)\n{\n\tif (!pvt_hwmon_channel_is_valid(type, ch))\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_type:\n\t\tcase hwmon_temp_label:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_min:\n\t\tcase hwmon_temp_max:\n\t\t\treturn pvt_limit_is_visible(ch);\n\t\tcase hwmon_temp_min_alarm:\n\t\tcase hwmon_temp_max_alarm:\n\t\t\treturn pvt_alarm_is_visible(ch);\n\t\tcase hwmon_temp_offset:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\tcase hwmon_in_label:\n\t\t\treturn 0444;\n\t\tcase hwmon_in_min:\n\t\tcase hwmon_in_max:\n\t\t\treturn pvt_limit_is_visible(PVT_VOLT + ch);\n\t\tcase hwmon_in_min_alarm:\n\t\tcase hwmon_in_max_alarm:\n\t\t\treturn pvt_alarm_is_visible(PVT_VOLT + ch);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int pvt_read_trim(struct pvt_hwmon *pvt, long *val)\n{\n\tu32 data;\n\n\tdata = readl(pvt->regs + PVT_CTRL);\n\t*val = FIELD_GET(PVT_CTRL_TRIM_MASK, data) * PVT_TRIM_STEP;\n\n\treturn 0;\n}\n\nstatic int pvt_write_trim(struct pvt_hwmon *pvt, long val)\n{\n\tu32 trim;\n\tint ret;\n\n\t \n\tret = mutex_lock_interruptible(&pvt->iface_mtx);\n\tif (ret)\n\t\treturn ret;\n\n\ttrim = pvt_calc_trim(val);\n\tpvt_set_trim(pvt, trim);\n\n\tmutex_unlock(&pvt->iface_mtx);\n\n\treturn 0;\n}\n\nstatic int pvt_read_timeout(struct pvt_hwmon *pvt, long *val)\n{\n\tint ret;\n\n\tret = mutex_lock_interruptible(&pvt->iface_mtx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*val = ktime_to_ms(pvt->timeout);\n\n\tmutex_unlock(&pvt->iface_mtx);\n\n\treturn 0;\n}\n\nstatic int pvt_write_timeout(struct pvt_hwmon *pvt, long val)\n{\n\tunsigned long rate;\n\tktime_t kt, cache;\n\tu32 data;\n\tint ret;\n\n\trate = clk_get_rate(pvt->clks[PVT_CLOCK_REF].clk);\n\tif (!rate)\n\t\treturn -ENODEV;\n\n\t \n\tcache = kt = ms_to_ktime(val);\n#if defined(CONFIG_SENSORS_BT1_PVT_ALARMS)\n\tkt = ktime_divns(kt, PVT_SENSORS_NUM);\n#endif\n\n\t \n\tkt = ktime_sub_ns(kt, PVT_TOUT_MIN);\n\tif (ktime_to_ns(kt) < 0)\n\t\tkt = ktime_set(0, 0);\n\n\t \n\tdata = ktime_divns(kt * rate, NSEC_PER_SEC);\n\n\t \n\tret = mutex_lock_interruptible(&pvt->iface_mtx);\n\tif (ret)\n\t\treturn ret;\n\n\tpvt_set_tout(pvt, data);\n\tpvt->timeout = cache;\n\n\tmutex_unlock(&pvt->iface_mtx);\n\n\treturn 0;\n}\n\nstatic int pvt_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t  u32 attr, int ch, long *val)\n{\n\tstruct pvt_hwmon *pvt = dev_get_drvdata(dev);\n\n\tif (!pvt_hwmon_channel_is_valid(type, ch))\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\treturn pvt_read_timeout(pvt, val);\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\treturn pvt_read_data(pvt, ch, val);\n\t\tcase hwmon_temp_type:\n\t\t\t*val = 1;\n\t\t\treturn 0;\n\t\tcase hwmon_temp_min:\n\t\t\treturn pvt_read_limit(pvt, ch, true, val);\n\t\tcase hwmon_temp_max:\n\t\t\treturn pvt_read_limit(pvt, ch, false, val);\n\t\tcase hwmon_temp_min_alarm:\n\t\t\treturn pvt_read_alarm(pvt, ch, true, val);\n\t\tcase hwmon_temp_max_alarm:\n\t\t\treturn pvt_read_alarm(pvt, ch, false, val);\n\t\tcase hwmon_temp_offset:\n\t\t\treturn pvt_read_trim(pvt, val);\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\treturn pvt_read_data(pvt, PVT_VOLT + ch, val);\n\t\tcase hwmon_in_min:\n\t\t\treturn pvt_read_limit(pvt, PVT_VOLT + ch, true, val);\n\t\tcase hwmon_in_max:\n\t\t\treturn pvt_read_limit(pvt, PVT_VOLT + ch, false, val);\n\t\tcase hwmon_in_min_alarm:\n\t\t\treturn pvt_read_alarm(pvt, PVT_VOLT + ch, true, val);\n\t\tcase hwmon_in_max_alarm:\n\t\t\treturn pvt_read_alarm(pvt, PVT_VOLT + ch, false, val);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pvt_hwmon_read_string(struct device *dev,\n\t\t\t\t enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int ch, const char **str)\n{\n\tif (!pvt_hwmon_channel_is_valid(type, ch))\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_label:\n\t\t\t*str = pvt_info[ch].label;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_label:\n\t\t\t*str = pvt_info[PVT_VOLT + ch].label;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pvt_hwmon_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t   u32 attr, int ch, long val)\n{\n\tstruct pvt_hwmon *pvt = dev_get_drvdata(dev);\n\n\tif (!pvt_hwmon_channel_is_valid(type, ch))\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\treturn pvt_write_timeout(pvt, val);\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_min:\n\t\t\treturn pvt_write_limit(pvt, ch, true, val);\n\t\tcase hwmon_temp_max:\n\t\t\treturn pvt_write_limit(pvt, ch, false, val);\n\t\tcase hwmon_temp_offset:\n\t\t\treturn pvt_write_trim(pvt, val);\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_min:\n\t\t\treturn pvt_write_limit(pvt, PVT_VOLT + ch, true, val);\n\t\tcase hwmon_in_max:\n\t\t\treturn pvt_write_limit(pvt, PVT_VOLT + ch, false, val);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct hwmon_ops pvt_hwmon_ops = {\n\t.is_visible = pvt_hwmon_is_visible,\n\t.read = pvt_hwmon_read,\n\t.read_string = pvt_hwmon_read_string,\n\t.write = pvt_hwmon_write\n};\n\nstatic const struct hwmon_chip_info pvt_hwmon_info = {\n\t.ops = &pvt_hwmon_ops,\n\t.info = pvt_channel_info\n};\n\nstatic void pvt_clear_data(void *data)\n{\n\tstruct pvt_hwmon *pvt = data;\n#if !defined(CONFIG_SENSORS_BT1_PVT_ALARMS)\n\tint idx;\n\n\tfor (idx = 0; idx < PVT_SENSORS_NUM; ++idx)\n\t\tcomplete_all(&pvt->cache[idx].conversion);\n#endif\n\n\tmutex_destroy(&pvt->iface_mtx);\n}\n\nstatic struct pvt_hwmon *pvt_create_data(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pvt_hwmon *pvt;\n\tint ret, idx;\n\n\tpvt = devm_kzalloc(dev, sizeof(*pvt), GFP_KERNEL);\n\tif (!pvt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = devm_add_action(dev, pvt_clear_data, pvt);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't add PVT data clear action\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tpvt->dev = dev;\n\tpvt->sensor = PVT_SENSOR_FIRST;\n\tmutex_init(&pvt->iface_mtx);\n\n#if defined(CONFIG_SENSORS_BT1_PVT_ALARMS)\n\tfor (idx = 0; idx < PVT_SENSORS_NUM; ++idx)\n\t\tseqlock_init(&pvt->cache[idx].data_seqlock);\n#else\n\tfor (idx = 0; idx < PVT_SENSORS_NUM; ++idx)\n\t\tinit_completion(&pvt->cache[idx].conversion);\n#endif\n\n\treturn pvt;\n}\n\nstatic int pvt_request_regs(struct pvt_hwmon *pvt)\n{\n\tstruct platform_device *pdev = to_platform_device(pvt->dev);\n\n\tpvt->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pvt->regs))\n\t\treturn PTR_ERR(pvt->regs);\n\n\treturn 0;\n}\n\nstatic void pvt_disable_clks(void *data)\n{\n\tstruct pvt_hwmon *pvt = data;\n\n\tclk_bulk_disable_unprepare(PVT_CLOCK_NUM, pvt->clks);\n}\n\nstatic int pvt_request_clks(struct pvt_hwmon *pvt)\n{\n\tint ret;\n\n\tpvt->clks[PVT_CLOCK_APB].id = \"pclk\";\n\tpvt->clks[PVT_CLOCK_REF].id = \"ref\";\n\n\tret = devm_clk_bulk_get(pvt->dev, PVT_CLOCK_NUM, pvt->clks);\n\tif (ret) {\n\t\tdev_err(pvt->dev, \"Couldn't get PVT clocks descriptors\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_bulk_prepare_enable(PVT_CLOCK_NUM, pvt->clks);\n\tif (ret) {\n\t\tdev_err(pvt->dev, \"Couldn't enable the PVT clocks\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(pvt->dev, pvt_disable_clks, pvt);\n\tif (ret) {\n\t\tdev_err(pvt->dev, \"Can't add PVT clocks disable action\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int pvt_check_pwr(struct pvt_hwmon *pvt)\n{\n\tunsigned long tout;\n\tint ret = 0;\n\tu32 data;\n\n\t \n\tpvt_update(pvt->regs + PVT_INTR_MASK, PVT_INTR_ALL, PVT_INTR_ALL);\n\tpvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_EN, PVT_CTRL_EN);\n\tpvt_set_tout(pvt, 0);\n\treadl(pvt->regs + PVT_DATA);\n\n\ttout = PVT_TOUT_MIN / NSEC_PER_USEC;\n\tusleep_range(tout, 2 * tout);\n\n\tdata = readl(pvt->regs + PVT_DATA);\n\tif (!(data & PVT_DATA_VALID)) {\n\t\tret = -ENODEV;\n\t\tdev_err(pvt->dev, \"Sensor is powered down\\n\");\n\t}\n\n\tpvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_EN, 0);\n\n\treturn ret;\n}\n\nstatic int pvt_init_iface(struct pvt_hwmon *pvt)\n{\n\tunsigned long rate;\n\tu32 trim, temp;\n\n\trate = clk_get_rate(pvt->clks[PVT_CLOCK_REF].clk);\n\tif (!rate) {\n\t\tdev_err(pvt->dev, \"Invalid reference clock rate\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpvt_update(pvt->regs + PVT_INTR_MASK, PVT_INTR_ALL, PVT_INTR_ALL);\n\tpvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_EN, 0);\n\treadl(pvt->regs + PVT_CLR_INTR);\n\treadl(pvt->regs + PVT_DATA);\n\n\t \n\tpvt_set_mode(pvt, pvt_info[pvt->sensor].mode);\n\tpvt_set_tout(pvt, PVT_TOUT_DEF);\n\n\t \n#if defined(CONFIG_SENSORS_BT1_PVT_ALARMS)\n\tpvt->timeout = ktime_set(PVT_SENSORS_NUM * PVT_TOUT_DEF, 0);\n\tpvt->timeout = ktime_divns(pvt->timeout, rate);\n\tpvt->timeout = ktime_add_ns(pvt->timeout, PVT_SENSORS_NUM * PVT_TOUT_MIN);\n#else\n\tpvt->timeout = ktime_set(PVT_TOUT_DEF, 0);\n\tpvt->timeout = ktime_divns(pvt->timeout, rate);\n\tpvt->timeout = ktime_add_ns(pvt->timeout, PVT_TOUT_MIN);\n#endif\n\n\ttrim = PVT_TRIM_DEF;\n\tif (!of_property_read_u32(pvt->dev->of_node,\n\t     \"baikal,pvt-temp-offset-millicelsius\", &temp))\n\t\ttrim = pvt_calc_trim(temp);\n\n\tpvt_set_trim(pvt, trim);\n\n\treturn 0;\n}\n\nstatic int pvt_request_irq(struct pvt_hwmon *pvt)\n{\n\tstruct platform_device *pdev = to_platform_device(pvt->dev);\n\tint ret;\n\n\tpvt->irq = platform_get_irq(pdev, 0);\n\tif (pvt->irq < 0)\n\t\treturn pvt->irq;\n\n\tret = devm_request_threaded_irq(pvt->dev, pvt->irq,\n\t\t\t\t\tpvt_hard_isr, pvt_soft_isr,\n#if defined(CONFIG_SENSORS_BT1_PVT_ALARMS)\n\t\t\t\t\tIRQF_SHARED | IRQF_TRIGGER_HIGH |\n\t\t\t\t\tIRQF_ONESHOT,\n#else\n\t\t\t\t\tIRQF_SHARED | IRQF_TRIGGER_HIGH,\n#endif\n\t\t\t\t\t\"pvt\", pvt);\n\tif (ret) {\n\t\tdev_err(pvt->dev, \"Couldn't request PVT IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int pvt_create_hwmon(struct pvt_hwmon *pvt)\n{\n\tpvt->hwmon = devm_hwmon_device_register_with_info(pvt->dev, \"pvt\", pvt,\n\t\t&pvt_hwmon_info, NULL);\n\tif (IS_ERR(pvt->hwmon)) {\n\t\tdev_err(pvt->dev, \"Couldn't create hwmon device\\n\");\n\t\treturn PTR_ERR(pvt->hwmon);\n\t}\n\n\treturn 0;\n}\n\n#if defined(CONFIG_SENSORS_BT1_PVT_ALARMS)\n\nstatic void pvt_disable_iface(void *data)\n{\n\tstruct pvt_hwmon *pvt = data;\n\n\tmutex_lock(&pvt->iface_mtx);\n\tpvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_EN, 0);\n\tpvt_update(pvt->regs + PVT_INTR_MASK, PVT_INTR_DVALID,\n\t\t   PVT_INTR_DVALID);\n\tmutex_unlock(&pvt->iface_mtx);\n}\n\nstatic int pvt_enable_iface(struct pvt_hwmon *pvt)\n{\n\tint ret;\n\n\tret = devm_add_action(pvt->dev, pvt_disable_iface, pvt);\n\tif (ret) {\n\t\tdev_err(pvt->dev, \"Can't add PVT disable interface action\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tmutex_lock(&pvt->iface_mtx);\n\tpvt_update(pvt->regs + PVT_INTR_MASK, PVT_INTR_DVALID, 0);\n\tpvt_update(pvt->regs + PVT_CTRL, PVT_CTRL_EN, PVT_CTRL_EN);\n\tmutex_unlock(&pvt->iface_mtx);\n\n\treturn 0;\n}\n\n#else  \n\nstatic int pvt_enable_iface(struct pvt_hwmon *pvt)\n{\n\treturn 0;\n}\n\n#endif  \n\nstatic int pvt_probe(struct platform_device *pdev)\n{\n\tstruct pvt_hwmon *pvt;\n\tint ret;\n\n\tpvt = pvt_create_data(pdev);\n\tif (IS_ERR(pvt))\n\t\treturn PTR_ERR(pvt);\n\n\tret = pvt_request_regs(pvt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pvt_request_clks(pvt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pvt_check_pwr(pvt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pvt_init_iface(pvt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pvt_request_irq(pvt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pvt_create_hwmon(pvt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pvt_enable_iface(pvt);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id pvt_of_match[] = {\n\t{ .compatible = \"baikal,bt1-pvt\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pvt_of_match);\n\nstatic struct platform_driver pvt_driver = {\n\t.probe = pvt_probe,\n\t.driver = {\n\t\t.name = \"bt1-pvt\",\n\t\t.of_match_table = pvt_of_match\n\t}\n};\nmodule_platform_driver(pvt_driver);\n\nMODULE_AUTHOR(\"Maxim Kaurkin <maxim.kaurkin@baikalelectronics.ru>\");\nMODULE_DESCRIPTION(\"Baikal-T1 PVT driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}