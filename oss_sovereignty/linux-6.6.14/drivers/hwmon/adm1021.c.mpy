{
  "module_name": "adm1021.c",
  "hash_id": "49c9d787e2fc48ba8ac92cd05ed3413f9cdf46d55bf0052997a5ef32627ce453",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adm1021.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n\n\n \nstatic const unsigned short normal_i2c[] = {\n\t0x18, 0x19, 0x1a, 0x29, 0x2a, 0x2b, 0x4c, 0x4d, 0x4e, I2C_CLIENT_END };\n\nenum chips {\n\tadm1021, adm1023, max1617, max1617a, thmc10, lm84, gl523sm, mc1066 };\n\n \n\n \n \n \n#define ADM1021_REG_TEMP(nr)\t\t(nr)\n#define ADM1021_REG_STATUS\t\t0x02\n \n#define ADM1021_REG_MAN_ID\t\t0xFE\n \n#define ADM1021_REG_DEV_ID\t\t0xFF\n \n#define ADM1021_REG_CONFIG_R\t\t0x03\n#define ADM1021_REG_CONFIG_W\t\t0x09\n#define ADM1021_REG_CONV_RATE_R\t\t0x04\n#define ADM1021_REG_CONV_RATE_W\t\t0x0A\n \n#define ADM1023_REG_REM_TEMP_PREC\t0x10\n#define ADM1023_REG_REM_OFFSET\t\t0x11\n#define ADM1023_REG_REM_OFFSET_PREC\t0x12\n#define ADM1023_REG_REM_TOS_PREC\t0x13\n#define ADM1023_REG_REM_THYST_PREC\t0x14\n \n \n#define ADM1021_REG_TOS_R(nr)\t\t(0x05 + 2 * (nr))\n#define ADM1021_REG_TOS_W(nr)\t\t(0x0B + 2 * (nr))\n#define ADM1021_REG_THYST_R(nr)\t\t(0x06 + 2 * (nr))\n#define ADM1021_REG_THYST_W(nr)\t\t(0x0C + 2 * (nr))\n \n#define ADM1021_REG_ONESHOT\t\t0x0F\n\n \n\n \n\n \nstruct adm1021_data {\n\tstruct i2c_client *client;\n\tenum chips type;\n\n\tconst struct attribute_group *groups[3];\n\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tchar low_power;\t\t \n\tunsigned long last_updated;\t \n\n\tint temp_max[2];\t\t \n\tint temp_min[2];\n\tint temp[2];\n\tu8 alarms;\n\t \n\tu8 remote_temp_offset;\n\tu8 remote_temp_offset_prec;\n};\n\n \nstatic bool read_only;\n\nstatic struct adm1021_data *adm1021_update_device(struct device *dev)\n{\n\tstruct adm1021_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\n\t    || !data->valid) {\n\t\tint i;\n\n\t\tdev_dbg(dev, \"Starting adm1021 update\\n\");\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tdata->temp[i] = 1000 *\n\t\t\t\t(s8) i2c_smbus_read_byte_data(\n\t\t\t\t\tclient, ADM1021_REG_TEMP(i));\n\t\t\tdata->temp_max[i] = 1000 *\n\t\t\t\t(s8) i2c_smbus_read_byte_data(\n\t\t\t\t\tclient, ADM1021_REG_TOS_R(i));\n\t\t\tif (data->type != lm84) {\n\t\t\t\tdata->temp_min[i] = 1000 *\n\t\t\t\t  (s8) i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t\tADM1021_REG_THYST_R(i));\n\t\t\t}\n\t\t}\n\t\tdata->alarms = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADM1021_REG_STATUS) & 0x7c;\n\t\tif (data->type == adm1023) {\n\t\t\t \n\t\t\tdata->temp[1] += 125 * (i2c_smbus_read_byte_data(\n\t\t\t\tclient, ADM1023_REG_REM_TEMP_PREC) >> 5);\n\t\t\tdata->temp_max[1] += 125 * (i2c_smbus_read_byte_data(\n\t\t\t\tclient, ADM1023_REG_REM_TOS_PREC) >> 5);\n\t\t\tdata->temp_min[1] += 125 * (i2c_smbus_read_byte_data(\n\t\t\t\tclient, ADM1023_REG_REM_THYST_PREC) >> 5);\n\t\t\tdata->remote_temp_offset =\n\t\t\t\ti2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADM1023_REG_REM_OFFSET);\n\t\t\tdata->remote_temp_offset_prec =\n\t\t\t\ti2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tADM1023_REG_REM_OFFSET_PREC);\n\t\t}\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct adm1021_data *data = adm1021_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", data->temp[index]);\n}\n\nstatic ssize_t temp_max_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct adm1021_data *data = adm1021_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", data->temp_max[index]);\n}\n\nstatic ssize_t temp_min_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct adm1021_data *data = adm1021_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", data->temp_min[index]);\n}\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint index = to_sensor_dev_attr(attr)->index;\n\tstruct adm1021_data *data = adm1021_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> index) & 1);\n}\n\nstatic ssize_t alarms_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct adm1021_data *data = adm1021_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", data->alarms);\n}\n\nstatic ssize_t temp_max_store(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      const char *buf, size_t count)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct adm1021_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\tint reg_val, err;\n\n\terr = kstrtol(buf, 10, &temp);\n\tif (err)\n\t\treturn err;\n\ttemp /= 1000;\n\n\tmutex_lock(&data->update_lock);\n\treg_val = clamp_val(temp, -128, 127);\n\tdata->temp_max[index] = reg_val * 1000;\n\tif (!read_only)\n\t\ti2c_smbus_write_byte_data(client, ADM1021_REG_TOS_W(index),\n\t\t\t\t\t  reg_val);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t temp_min_store(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      const char *buf, size_t count)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct adm1021_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\tint reg_val, err;\n\n\terr = kstrtol(buf, 10, &temp);\n\tif (err)\n\t\treturn err;\n\ttemp /= 1000;\n\n\tmutex_lock(&data->update_lock);\n\treg_val = clamp_val(temp, -128, 127);\n\tdata->temp_min[index] = reg_val * 1000;\n\tif (!read_only)\n\t\ti2c_smbus_write_byte_data(client, ADM1021_REG_THYST_W(index),\n\t\t\t\t\t  reg_val);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t low_power_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tstruct adm1021_data *data = adm1021_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->low_power);\n}\n\nstatic ssize_t low_power_store(struct device *dev,\n\t\t\t       struct device_attribute *devattr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct adm1021_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tchar low_power;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tlow_power = val != 0;\n\n\tmutex_lock(&data->update_lock);\n\tif (low_power != data->low_power) {\n\t\tint config = i2c_smbus_read_byte_data(\n\t\t\tclient, ADM1021_REG_CONFIG_R);\n\t\tdata->low_power = low_power;\n\t\ti2c_smbus_write_byte_data(client, ADM1021_REG_CONFIG_W,\n\t\t\t(config & 0xBF) | (low_power << 6));\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp_max, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp_min, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp_max, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_min, temp_min, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, alarm, 6);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_alarm, alarm, 5);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_max_alarm, alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_min_alarm, alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_fault, alarm, 2);\n\nstatic DEVICE_ATTR_RO(alarms);\nstatic DEVICE_ATTR_RW(low_power);\n\nstatic struct attribute *adm1021_attributes[] = {\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t&dev_attr_alarms.attr,\n\t&dev_attr_low_power.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adm1021_group = {\n\t.attrs = adm1021_attributes,\n};\n\nstatic struct attribute *adm1021_min_attributes[] = {\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adm1021_min_group = {\n\t.attrs = adm1021_min_attributes,\n};\n\n \nstatic int adm1021_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tconst char *type_name;\n\tint reg, conv_rate, status, config, man_id, dev_id;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tpr_debug(\"detect failed, smbus byte data not supported!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tstatus = i2c_smbus_read_byte_data(client, ADM1021_REG_STATUS);\n\tconv_rate = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t     ADM1021_REG_CONV_RATE_R);\n\tconfig = i2c_smbus_read_byte_data(client, ADM1021_REG_CONFIG_R);\n\n\t \n\tif ((status & 0x03) || (config & 0x3F) || (conv_rate & 0xF8)) {\n\t\tpr_debug(\"detect failed, chip not detected!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tman_id = i2c_smbus_read_byte_data(client, ADM1021_REG_MAN_ID);\n\tdev_id = i2c_smbus_read_byte_data(client, ADM1021_REG_DEV_ID);\n\n\tif (man_id < 0 || dev_id < 0)\n\t\treturn -ENODEV;\n\n\tif (man_id == 0x4d && dev_id == 0x01) {\n\t\t \n\t\treg = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t       ADM1023_REG_REM_TEMP_PREC);\n\t\tif (reg != dev_id)\n\t\t\treturn -ENODEV;\n\t\ttype_name = \"max1617a\";\n\t} else if (man_id == 0x41) {\n\t\tif ((dev_id & 0xF0) == 0x30)\n\t\t\ttype_name = \"adm1023\";\n\t\telse if ((dev_id & 0xF0) == 0x00)\n\t\t\ttype_name = \"adm1021\";\n\t\telse\n\t\t\treturn -ENODEV;\n\t} else if (man_id == 0x49)\n\t\ttype_name = \"thmc10\";\n\telse if (man_id == 0x23)\n\t\ttype_name = \"gl523sm\";\n\telse if (man_id == 0x54)\n\t\ttype_name = \"mc1066\";\n\telse {\n\t\tint lte, rte, lhi, rhi, llo, rlo;\n\n\t\t \n\n\t\tllo = i2c_smbus_read_byte_data(client, ADM1021_REG_THYST_R(0));\n\t\trlo = i2c_smbus_read_byte_data(client, ADM1021_REG_THYST_R(1));\n\n\t\t \n\t\tif (llo < 0 || rlo < 0)\n\t\t\treturn -ENODEV;\n\n\t\tlte = i2c_smbus_read_byte_data(client, ADM1021_REG_TEMP(0));\n\t\trte = i2c_smbus_read_byte_data(client, ADM1021_REG_TEMP(1));\n\t\tlhi = i2c_smbus_read_byte_data(client, ADM1021_REG_TOS_R(0));\n\t\trhi = i2c_smbus_read_byte_data(client, ADM1021_REG_TOS_R(1));\n\n\t\t \n\t\tif ((s8)lte < 0 || (s8)rte < 0 || (s8)lhi < 0 || (s8)rhi < 0)\n\t\t\treturn -ENODEV;\n\n\t\t \n\t\tif (lte == rte && lte == lhi && lte == rhi && lte == llo\n\t\t    && lte == rlo)\n\t\t\treturn -ENODEV;\n\n\t\t \n\t\tif (conv_rate == 0x00\n\t\t    && man_id == config && dev_id == config\n\t\t    && (config & 0x7F) == 0x00\n\t\t    && (status & 0xAB) == 0x00) {\n\t\t\ttype_name = \"lm84\";\n\t\t} else {\n\t\t\tif ((config & 0x3f) || (status & 0x03))\n\t\t\t\treturn -ENODEV;\n\t\t\t \n\t\t\tif ((s8)llo > lhi || (s8)rlo > rhi)\n\t\t\t\treturn -ENODEV;\n\t\t\ttype_name = \"max1617\";\n\t\t}\n\t}\n\n\tpr_debug(\"Detected chip %s at adapter %d, address 0x%02x.\\n\",\n\t\t type_name, i2c_adapter_id(adapter), client->addr);\n\tstrscpy(info->type, type_name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic void adm1021_init_client(struct i2c_client *client)\n{\n\t \n\ti2c_smbus_write_byte_data(client, ADM1021_REG_CONFIG_W,\n\t\ti2c_smbus_read_byte_data(client, ADM1021_REG_CONFIG_R) & 0xBF);\n\t \n\ti2c_smbus_write_byte_data(client, ADM1021_REG_CONV_RATE_W, 0x04);\n}\n\nstatic const struct i2c_device_id adm1021_id[];\n\nstatic int adm1021_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct adm1021_data *data;\n\tstruct device *hwmon_dev;\n\n\tdata = devm_kzalloc(dev, sizeof(struct adm1021_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tdata->type = i2c_match_id(adm1021_id, client)->driver_data;\n\tmutex_init(&data->update_lock);\n\n\t \n\tif (data->type != lm84 && !read_only)\n\t\tadm1021_init_client(client);\n\n\tdata->groups[0] = &adm1021_group;\n\tif (data->type != lm84)\n\t\tdata->groups[1] = &adm1021_min_group;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, data->groups);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id adm1021_id[] = {\n\t{ \"adm1021\", adm1021 },\n\t{ \"adm1023\", adm1023 },\n\t{ \"max1617\", max1617 },\n\t{ \"max1617a\", max1617a },\n\t{ \"thmc10\", thmc10 },\n\t{ \"lm84\", lm84 },\n\t{ \"gl523sm\", gl523sm },\n\t{ \"mc1066\", mc1066 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adm1021_id);\n\nstatic struct i2c_driver adm1021_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"adm1021\",\n\t},\n\t.probe\t\t= adm1021_probe,\n\t.id_table\t= adm1021_id,\n\t.detect\t\t= adm1021_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(adm1021_driver);\n\nMODULE_AUTHOR(\"Frodo Looijaard <frodol@dds.nl> and \"\n\t\t\"Philip Edelbrock <phil@netroedge.com>\");\nMODULE_DESCRIPTION(\"adm1021 driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(read_only, bool, 0);\nMODULE_PARM_DESC(read_only, \"Don't set any values, read only mode\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}