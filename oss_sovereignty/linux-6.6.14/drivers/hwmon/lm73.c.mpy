{
  "module_name": "lm73.c",
  "hash_id": "c3593d5e46a9cdd5086398140b21b1c301edd5536f2374a0f01061f5587c1823",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lm73.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n\n\n \nstatic const unsigned short normal_i2c[] = { 0x48, 0x49, 0x4a, 0x4c,\n\t\t\t\t\t0x4d, 0x4e, I2C_CLIENT_END };\n\n \n#define LM73_REG_INPUT\t\t0x00\n#define LM73_REG_CONF\t\t0x01\n#define LM73_REG_MAX\t\t0x02\n#define LM73_REG_MIN\t\t0x03\n#define LM73_REG_CTRL\t\t0x04\n#define LM73_REG_ID\t\t0x07\n\n#define LM73_ID\t\t\t0x9001\t \n#define DRVNAME\t\t\t\"lm73\"\n#define LM73_TEMP_MIN\t\t(-256000 / 250)\n#define LM73_TEMP_MAX\t\t(255750 / 250)\n\n#define LM73_CTRL_RES_SHIFT\t5\n#define LM73_CTRL_RES_MASK\t(BIT(5) | BIT(6))\n#define LM73_CTRL_TO_MASK\tBIT(7)\n\n#define LM73_CTRL_HI_SHIFT\t2\n#define LM73_CTRL_LO_SHIFT\t1\n\nstatic const unsigned short lm73_convrates[] = {\n\t14,\t \n\t28,\t \n\t56,\t \n\t112,\t \n};\n\nstruct lm73_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tu8 ctrl;\t\t\t \n};\n\n \n\nstatic ssize_t temp_store(struct device *dev, struct device_attribute *da,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct lm73_data *data = dev_get_drvdata(dev);\n\tlong temp;\n\tshort value;\n\ts32 err;\n\n\tint status = kstrtol(buf, 10, &temp);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tvalue = clamp_val(temp / 250, LM73_TEMP_MIN, LM73_TEMP_MAX) << 5;\n\terr = i2c_smbus_write_word_swapped(data->client, attr->index, value);\n\treturn (err < 0) ? err : count;\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *da,\n\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct lm73_data *data = dev_get_drvdata(dev);\n\tint temp;\n\n\ts32 err = i2c_smbus_read_word_swapped(data->client, attr->index);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\ttemp = (((s16) err) * 250) / 32;\n\treturn sysfs_emit(buf, \"%d\\n\", temp);\n}\n\nstatic ssize_t convrate_store(struct device *dev, struct device_attribute *da,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct lm73_data *data = dev_get_drvdata(dev);\n\tunsigned long convrate;\n\ts32 err;\n\tint res = 0;\n\n\terr = kstrtoul(buf, 10, &convrate);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\twhile (res < (ARRAY_SIZE(lm73_convrates) - 1) &&\n\t\t\tconvrate > lm73_convrates[res])\n\t\tres++;\n\n\tmutex_lock(&data->lock);\n\tdata->ctrl &= LM73_CTRL_TO_MASK;\n\tdata->ctrl |= res << LM73_CTRL_RES_SHIFT;\n\terr = i2c_smbus_write_byte_data(data->client, LM73_REG_CTRL,\n\t\t\t\t\tdata->ctrl);\n\tmutex_unlock(&data->lock);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic ssize_t convrate_show(struct device *dev, struct device_attribute *da,\n\t\t\t     char *buf)\n{\n\tstruct lm73_data *data = dev_get_drvdata(dev);\n\tint res;\n\n\tres = (data->ctrl & LM73_CTRL_RES_MASK) >> LM73_CTRL_RES_SHIFT;\n\treturn sysfs_emit(buf, \"%hu\\n\", lm73_convrates[res]);\n}\n\nstatic ssize_t maxmin_alarm_show(struct device *dev,\n\t\t\t\t struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct lm73_data *data = dev_get_drvdata(dev);\n\ts32 ctrl;\n\n\tmutex_lock(&data->lock);\n\tctrl = i2c_smbus_read_byte_data(data->client, LM73_REG_CTRL);\n\tif (ctrl < 0)\n\t\tgoto abort;\n\tdata->ctrl = ctrl;\n\tmutex_unlock(&data->lock);\n\n\treturn sysfs_emit(buf, \"%d\\n\", (ctrl >> attr->index) & 1);\n\nabort:\n\tmutex_unlock(&data->lock);\n\treturn ctrl;\n}\n\n \n\n \n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp, LM73_REG_MAX);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp, LM73_REG_MIN);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, LM73_REG_INPUT);\nstatic SENSOR_DEVICE_ATTR_RW(update_interval, convrate, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, maxmin_alarm,\n\t\t\t     LM73_CTRL_HI_SHIFT);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_alarm, maxmin_alarm,\n\t\t\t     LM73_CTRL_LO_SHIFT);\n\nstatic struct attribute *lm73_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_update_interval.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(lm73);\n\n \n\n \n\nstatic int\nlm73_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct lm73_data *data;\n\tint ctrl;\n\n\tdata = devm_kzalloc(dev, sizeof(struct lm73_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tctrl = i2c_smbus_read_byte_data(client, LM73_REG_CTRL);\n\tif (ctrl < 0)\n\t\treturn ctrl;\n\tdata->ctrl = ctrl;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, lm73_groups);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdev_info(dev, \"sensor '%s'\\n\", client->name);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id lm73_ids[] = {\n\t{ \"lm73\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, lm73_ids);\n\n \nstatic int lm73_detect(struct i2c_client *new_client,\n\t\t\tstruct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = new_client->adapter;\n\tint id, ctrl, conf;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t\tI2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tctrl = i2c_smbus_read_byte_data(new_client, LM73_REG_CTRL);\n\tif (ctrl < 0 || (ctrl & 0x10))\n\t\treturn -ENODEV;\n\n\tconf = i2c_smbus_read_byte_data(new_client, LM73_REG_CONF);\n\tif (conf < 0 || (conf & 0x0c))\n\t\treturn -ENODEV;\n\n\tid = i2c_smbus_read_byte_data(new_client, LM73_REG_ID);\n\tif (id < 0 || id != (LM73_ID & 0xff))\n\t\treturn -ENODEV;\n\n\t \n\tid = i2c_smbus_read_word_data(new_client, LM73_REG_ID);\n\tif (id < 0 || id != LM73_ID)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"lm73\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id lm73_of_match[] = {\n\t{\n\t\t.compatible = \"ti,lm73\",\n\t},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, lm73_of_match);\n\nstatic struct i2c_driver lm73_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"lm73\",\n\t\t.of_match_table = lm73_of_match,\n\t},\n\t.probe\t\t= lm73_probe,\n\t.id_table\t= lm73_ids,\n\t.detect\t\t= lm73_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(lm73_driver);\n\nMODULE_AUTHOR(\"Guillaume Ligneul <guillaume.ligneul@gmail.com>\");\nMODULE_DESCRIPTION(\"LM73 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}