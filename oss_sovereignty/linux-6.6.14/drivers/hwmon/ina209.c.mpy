{
  "module_name": "ina209.c",
  "hash_id": "6bf680839de97d71dcafe02200a9429ebcc9c1910c252d94e1ccf3ee62a1cd24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ina209.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/bug.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n\n#include <linux/platform_data/ina2xx.h>\n\n \n#define INA209_CONFIGURATION\t\t0x00\n#define INA209_STATUS\t\t\t0x01\n#define INA209_STATUS_MASK\t\t0x02\n#define INA209_SHUNT_VOLTAGE\t\t0x03\n#define INA209_BUS_VOLTAGE\t\t0x04\n#define INA209_POWER\t\t\t0x05\n#define INA209_CURRENT\t\t\t0x06\n#define INA209_SHUNT_VOLTAGE_POS_PEAK\t0x07\n#define INA209_SHUNT_VOLTAGE_NEG_PEAK\t0x08\n#define INA209_BUS_VOLTAGE_MAX_PEAK\t0x09\n#define INA209_BUS_VOLTAGE_MIN_PEAK\t0x0a\n#define INA209_POWER_PEAK\t\t0x0b\n#define INA209_SHUNT_VOLTAGE_POS_WARN\t0x0c\n#define INA209_SHUNT_VOLTAGE_NEG_WARN\t0x0d\n#define INA209_POWER_WARN\t\t0x0e\n#define INA209_BUS_VOLTAGE_OVER_WARN\t0x0f\n#define INA209_BUS_VOLTAGE_UNDER_WARN\t0x10\n#define INA209_POWER_OVER_LIMIT\t\t0x11\n#define INA209_BUS_VOLTAGE_OVER_LIMIT\t0x12\n#define INA209_BUS_VOLTAGE_UNDER_LIMIT\t0x13\n#define INA209_CRITICAL_DAC_POS\t\t0x14\n#define INA209_CRITICAL_DAC_NEG\t\t0x15\n#define INA209_CALIBRATION\t\t0x16\n\n#define INA209_REGISTERS\t\t0x17\n\n#define INA209_CONFIG_DEFAULT\t\t0x3c47\t \n#define INA209_SHUNT_DEFAULT\t\t10000\t \n\nstruct ina209_data {\n\tstruct i2c_client *client;\n\n\tstruct mutex update_lock;\n\tbool valid;\n\tunsigned long last_updated;\t \n\n\tu16 regs[INA209_REGISTERS];\t \n\n\tu16 config_orig;\t\t \n\tu16 calibration_orig;\t\t \n\tu16 update_interval;\n};\n\nstatic struct ina209_data *ina209_update_device(struct device *dev)\n{\n\tstruct ina209_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tstruct ina209_data *ret = data;\n\ts32 val;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (!data->valid ||\n\t    time_after(jiffies, data->last_updated + data->update_interval)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(data->regs); i++) {\n\t\t\tval = i2c_smbus_read_word_swapped(client, i);\n\t\t\tif (val < 0) {\n\t\t\t\tret = ERR_PTR(val);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tdata->regs[i] = val;\n\t\t}\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\nabort:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\n \nstatic long ina209_from_reg(const u8 reg, const u16 val)\n{\n\tswitch (reg) {\n\tcase INA209_SHUNT_VOLTAGE:\n\tcase INA209_SHUNT_VOLTAGE_POS_PEAK:\n\tcase INA209_SHUNT_VOLTAGE_NEG_PEAK:\n\tcase INA209_SHUNT_VOLTAGE_POS_WARN:\n\tcase INA209_SHUNT_VOLTAGE_NEG_WARN:\n\t\t \n\t\treturn DIV_ROUND_CLOSEST((s16)val, 100);\n\n\tcase INA209_BUS_VOLTAGE:\n\tcase INA209_BUS_VOLTAGE_MAX_PEAK:\n\tcase INA209_BUS_VOLTAGE_MIN_PEAK:\n\tcase INA209_BUS_VOLTAGE_OVER_WARN:\n\tcase INA209_BUS_VOLTAGE_UNDER_WARN:\n\tcase INA209_BUS_VOLTAGE_OVER_LIMIT:\n\tcase INA209_BUS_VOLTAGE_UNDER_LIMIT:\n\t\t \n\t\treturn (val >> 3) * 4;\n\n\tcase INA209_CRITICAL_DAC_POS:\n\t\t \n\t\treturn val >> 8;\n\n\tcase INA209_CRITICAL_DAC_NEG:\n\t\t \n\t\treturn -1 * (val >> 8);\n\n\tcase INA209_POWER:\n\tcase INA209_POWER_PEAK:\n\tcase INA209_POWER_WARN:\n\tcase INA209_POWER_OVER_LIMIT:\n\t\t \n\t\treturn val * 20 * 1000L;\n\n\tcase INA209_CURRENT:\n\t\t \n\t\treturn (s16)val;\n\t}\n\n\t \n\tWARN_ON_ONCE(1);\n\treturn 0;\n}\n\n \nstatic int ina209_to_reg(u8 reg, u16 old, long val)\n{\n\tswitch (reg) {\n\tcase INA209_SHUNT_VOLTAGE_POS_WARN:\n\tcase INA209_SHUNT_VOLTAGE_NEG_WARN:\n\t\t \n\t\treturn clamp_val(val, -320, 320) * 100;\n\n\tcase INA209_BUS_VOLTAGE_OVER_WARN:\n\tcase INA209_BUS_VOLTAGE_UNDER_WARN:\n\tcase INA209_BUS_VOLTAGE_OVER_LIMIT:\n\tcase INA209_BUS_VOLTAGE_UNDER_LIMIT:\n\t\t \n\t\treturn (DIV_ROUND_CLOSEST(clamp_val(val, 0, 32000), 4) << 3)\n\t\t  | (old & 0x7);\n\n\tcase INA209_CRITICAL_DAC_NEG:\n\t\t \n\t\treturn (clamp_val(-val, 0, 255) << 8) | (old & 0xff);\n\n\tcase INA209_CRITICAL_DAC_POS:\n\t\t \n\t\treturn (clamp_val(val, 0, 255) << 8) | (old & 0xff);\n\n\tcase INA209_POWER_WARN:\n\tcase INA209_POWER_OVER_LIMIT:\n\t\t \n\t\treturn DIV_ROUND_CLOSEST(val, 20 * 1000);\n\t}\n\n\t \n\treturn -EACCES;\n}\n\nstatic int ina209_interval_from_reg(u16 reg)\n{\n\treturn 68 >> (15 - ((reg >> 3) & 0x0f));\n}\n\nstatic u16 ina209_reg_from_interval(u16 config, long interval)\n{\n\tint i, adc;\n\n\tif (interval <= 0) {\n\t\tadc = 8;\n\t} else {\n\t\tadc = 15;\n\t\tfor (i = 34 + 34 / 2; i; i >>= 1) {\n\t\t\tif (i < interval)\n\t\t\t\tbreak;\n\t\t\tadc--;\n\t\t}\n\t}\n\treturn (config & 0xf807) | (adc << 3) | (adc << 7);\n}\n\nstatic ssize_t ina209_interval_store(struct device *dev,\n\t\t\t\t     struct device_attribute *da,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ina209_data *data = ina209_update_device(dev);\n\tlong val;\n\tu16 regval;\n\tint ret;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&data->update_lock);\n\tregval = ina209_reg_from_interval(data->regs[INA209_CONFIGURATION],\n\t\t\t\t\t  val);\n\ti2c_smbus_write_word_swapped(data->client, INA209_CONFIGURATION,\n\t\t\t\t     regval);\n\tdata->regs[INA209_CONFIGURATION] = regval;\n\tdata->update_interval = ina209_interval_from_reg(regval);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t ina209_interval_show(struct device *dev,\n\t\t\t\t    struct device_attribute *da, char *buf)\n{\n\tstruct ina209_data *data = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", data->update_interval);\n}\n\n \nstatic u16 ina209_reset_history_regs[] = {\n\tINA209_SHUNT_VOLTAGE_POS_PEAK,\n\tINA209_SHUNT_VOLTAGE_NEG_PEAK,\n\tINA209_BUS_VOLTAGE_MAX_PEAK,\n\tINA209_BUS_VOLTAGE_MIN_PEAK,\n\tINA209_POWER_PEAK\n};\n\nstatic ssize_t ina209_history_store(struct device *dev,\n\t\t\t\t    struct device_attribute *da,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ina209_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu32 mask = attr->index;\n\tlong val;\n\tint i, ret;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&data->update_lock);\n\tfor (i = 0; i < ARRAY_SIZE(ina209_reset_history_regs); i++) {\n\t\tif (mask & (1 << i))\n\t\t\ti2c_smbus_write_word_swapped(client,\n\t\t\t\t\tina209_reset_history_regs[i], 1);\n\t}\n\tdata->valid = false;\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t ina209_value_store(struct device *dev,\n\t\t\t\t  struct device_attribute *da,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct ina209_data *data = ina209_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint reg = attr->index;\n\tlong val;\n\tint ret;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&data->update_lock);\n\tret = ina209_to_reg(reg, data->regs[reg], val);\n\tif (ret < 0) {\n\t\tcount = ret;\n\t\tgoto abort;\n\t}\n\ti2c_smbus_write_word_swapped(data->client, reg, ret);\n\tdata->regs[reg] = ret;\nabort:\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t ina209_value_show(struct device *dev,\n\t\t\t\t struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ina209_data *data = ina209_update_device(dev);\n\tlong val;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tval = ina209_from_reg(attr->index, data->regs[attr->index]);\n\treturn sysfs_emit(buf, \"%ld\\n\", val);\n}\n\nstatic ssize_t ina209_alarm_show(struct device *dev,\n\t\t\t\t struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ina209_data *data = ina209_update_device(dev);\n\tconst unsigned int mask = attr->index;\n\tu16 status;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tstatus = data->regs[INA209_STATUS];\n\n\t \n\treturn sysfs_emit(buf, \"%u\\n\", !!(status & mask));\n}\n\n \nstatic SENSOR_DEVICE_ATTR_RO(in0_input, ina209_value, INA209_SHUNT_VOLTAGE);\nstatic SENSOR_DEVICE_ATTR_RO(in0_input_highest, ina209_value,\n\t\t\t     INA209_SHUNT_VOLTAGE_POS_PEAK);\nstatic SENSOR_DEVICE_ATTR_RO(in0_input_lowest, ina209_value,\n\t\t\t     INA209_SHUNT_VOLTAGE_NEG_PEAK);\nstatic SENSOR_DEVICE_ATTR_WO(in0_reset_history, ina209_history,\n\t\t\t     (1 << 0) | (1 << 1));\nstatic SENSOR_DEVICE_ATTR_RW(in0_max, ina209_value,\n\t\t\t     INA209_SHUNT_VOLTAGE_POS_WARN);\nstatic SENSOR_DEVICE_ATTR_RW(in0_min, ina209_value,\n\t\t\t     INA209_SHUNT_VOLTAGE_NEG_WARN);\nstatic SENSOR_DEVICE_ATTR_RW(in0_crit_max, ina209_value,\n\t\t\t     INA209_CRITICAL_DAC_POS);\nstatic SENSOR_DEVICE_ATTR_RW(in0_crit_min, ina209_value,\n\t\t\t     INA209_CRITICAL_DAC_NEG);\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_min_alarm, ina209_alarm, 1 << 11);\nstatic SENSOR_DEVICE_ATTR_RO(in0_max_alarm, ina209_alarm, 1 << 12);\nstatic SENSOR_DEVICE_ATTR_RO(in0_crit_min_alarm, ina209_alarm, 1 << 6);\nstatic SENSOR_DEVICE_ATTR_RO(in0_crit_max_alarm, ina209_alarm, 1 << 7);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(in1_input, ina209_value, INA209_BUS_VOLTAGE);\nstatic SENSOR_DEVICE_ATTR_RO(in1_input_highest, ina209_value,\n\t\t\t     INA209_BUS_VOLTAGE_MAX_PEAK);\nstatic SENSOR_DEVICE_ATTR_RO(in1_input_lowest, ina209_value,\n\t\t\t     INA209_BUS_VOLTAGE_MIN_PEAK);\nstatic SENSOR_DEVICE_ATTR_WO(in1_reset_history, ina209_history,\n\t\t\t     (1 << 2) | (1 << 3));\nstatic SENSOR_DEVICE_ATTR_RW(in1_max, ina209_value,\n\t\t\t     INA209_BUS_VOLTAGE_OVER_WARN);\nstatic SENSOR_DEVICE_ATTR_RW(in1_min, ina209_value,\n\t\t\t     INA209_BUS_VOLTAGE_UNDER_WARN);\nstatic SENSOR_DEVICE_ATTR_RW(in1_crit_max, ina209_value,\n\t\t\t     INA209_BUS_VOLTAGE_OVER_LIMIT);\nstatic SENSOR_DEVICE_ATTR_RW(in1_crit_min, ina209_value,\n\t\t\t     INA209_BUS_VOLTAGE_UNDER_LIMIT);\n\nstatic SENSOR_DEVICE_ATTR_RO(in1_min_alarm, ina209_alarm, 1 << 14);\nstatic SENSOR_DEVICE_ATTR_RO(in1_max_alarm, ina209_alarm, 1 << 15);\nstatic SENSOR_DEVICE_ATTR_RO(in1_crit_min_alarm, ina209_alarm, 1 << 9);\nstatic SENSOR_DEVICE_ATTR_RO(in1_crit_max_alarm, ina209_alarm, 1 << 10);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(power1_input, ina209_value, INA209_POWER);\nstatic SENSOR_DEVICE_ATTR_RO(power1_input_highest, ina209_value,\n\t\t\t     INA209_POWER_PEAK);\nstatic SENSOR_DEVICE_ATTR_WO(power1_reset_history, ina209_history, 1 << 4);\nstatic SENSOR_DEVICE_ATTR_RW(power1_max, ina209_value, INA209_POWER_WARN);\nstatic SENSOR_DEVICE_ATTR_RW(power1_crit, ina209_value,\n\t\t\t     INA209_POWER_OVER_LIMIT);\n\nstatic SENSOR_DEVICE_ATTR_RO(power1_max_alarm, ina209_alarm, 1 << 13);\nstatic SENSOR_DEVICE_ATTR_RO(power1_crit_alarm, ina209_alarm, 1 << 8);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(curr1_input, ina209_value, INA209_CURRENT);\n\nstatic SENSOR_DEVICE_ATTR_RW(update_interval, ina209_interval, 0);\n\n \nstatic struct attribute *ina209_attrs[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_input_highest.dev_attr.attr,\n\t&sensor_dev_attr_in0_input_lowest.dev_attr.attr,\n\t&sensor_dev_attr_in0_reset_history.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_crit_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_crit_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in0_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in0_crit_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in0_crit_min_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_input_highest.dev_attr.attr,\n\t&sensor_dev_attr_in1_input_lowest.dev_attr.attr,\n\t&sensor_dev_attr_in1_reset_history.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_crit_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_crit_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_crit_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_crit_min_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_power1_input.dev_attr.attr,\n\t&sensor_dev_attr_power1_input_highest.dev_attr.attr,\n\t&sensor_dev_attr_power1_reset_history.dev_attr.attr,\n\t&sensor_dev_attr_power1_max.dev_attr.attr,\n\t&sensor_dev_attr_power1_crit.dev_attr.attr,\n\t&sensor_dev_attr_power1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_power1_crit_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_curr1_input.dev_attr.attr,\n\n\t&sensor_dev_attr_update_interval.dev_attr.attr,\n\n\tNULL,\n};\nATTRIBUTE_GROUPS(ina209);\n\nstatic void ina209_restore_conf(struct i2c_client *client,\n\t\t\t\tstruct ina209_data *data)\n{\n\t \n\ti2c_smbus_write_word_swapped(client, INA209_CONFIGURATION,\n\t\t\t\t     data->config_orig);\n\ti2c_smbus_write_word_swapped(client, INA209_CALIBRATION,\n\t\t\t\t     data->calibration_orig);\n}\n\nstatic int ina209_init_client(struct i2c_client *client,\n\t\t\t      struct ina209_data *data)\n{\n\tstruct ina2xx_platform_data *pdata = dev_get_platdata(&client->dev);\n\tu32 shunt;\n\tint reg;\n\n\treg = i2c_smbus_read_word_swapped(client, INA209_CALIBRATION);\n\tif (reg < 0)\n\t\treturn reg;\n\tdata->calibration_orig = reg;\n\n\treg = i2c_smbus_read_word_swapped(client, INA209_CONFIGURATION);\n\tif (reg < 0)\n\t\treturn reg;\n\tdata->config_orig = reg;\n\n\tif (pdata) {\n\t\tif (pdata->shunt_uohms <= 0)\n\t\t\treturn -EINVAL;\n\t\tshunt = pdata->shunt_uohms;\n\t} else if (!of_property_read_u32(client->dev.of_node, \"shunt-resistor\",\n\t\t\t\t\t &shunt)) {\n\t\tif (shunt == 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tshunt = data->calibration_orig ?\n\t\t  40960000 / data->calibration_orig : INA209_SHUNT_DEFAULT;\n\t}\n\n\ti2c_smbus_write_word_swapped(client, INA209_CONFIGURATION,\n\t\t\t\t     INA209_CONFIG_DEFAULT);\n\tdata->update_interval = ina209_interval_from_reg(INA209_CONFIG_DEFAULT);\n\n\t \n\ti2c_smbus_write_word_swapped(client, INA209_CALIBRATION,\n\t\t\t\t     clamp_val(40960000 / shunt, 1, 65535));\n\n\t \n\ti2c_smbus_read_word_swapped(client, INA209_STATUS);\n\n\treturn 0;\n}\n\nstatic int ina209_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct ina209_data *data;\n\tstruct device *hwmon_dev;\n\tint ret;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\tret = ina209_init_client(client, data);\n\tif (ret)\n\t\treturn ret;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(&client->dev,\n\t\t\t\t\t\t\t   client->name,\n\t\t\t\t\t\t\t   data, ina209_groups);\n\tif (IS_ERR(hwmon_dev)) {\n\t\tret = PTR_ERR(hwmon_dev);\n\t\tgoto out_restore_conf;\n\t}\n\n\treturn 0;\n\nout_restore_conf:\n\tina209_restore_conf(client, data);\n\treturn ret;\n}\n\nstatic void ina209_remove(struct i2c_client *client)\n{\n\tstruct ina209_data *data = i2c_get_clientdata(client);\n\n\tina209_restore_conf(client, data);\n}\n\nstatic const struct i2c_device_id ina209_id[] = {\n\t{ \"ina209\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ina209_id);\n\nstatic const struct of_device_id __maybe_unused ina209_of_match[] = {\n\t{ .compatible = \"ti,ina209\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ina209_of_match);\n\n \nstatic struct i2c_driver ina209_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"ina209\",\n\t\t.of_match_table = of_match_ptr(ina209_of_match),\n\t},\n\t.probe\t\t= ina209_probe,\n\t.remove\t\t= ina209_remove,\n\t.id_table\t= ina209_id,\n};\n\nmodule_i2c_driver(ina209_driver);\n\nMODULE_AUTHOR(\"Ira W. Snyder <iws@ovro.caltech.edu>, Paul Hays <Paul.Hays@cattail.ca>, Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"INA209 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}