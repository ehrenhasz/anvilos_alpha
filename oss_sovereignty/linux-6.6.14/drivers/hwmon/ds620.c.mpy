{
  "module_name": "ds620.c",
  "hash_id": "32c8e03381b14843ad6c683f4850ae71bf782fa667f04f0c3f0ecc1865d2ae0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ds620.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/platform_data/ds620.h>\n\n \n#define DS620_REG_CONFIG_DONE\t\t0x8000\n#define DS620_REG_CONFIG_NVB\t\t0x4000\n#define DS620_REG_CONFIG_THF\t\t0x2000\n#define DS620_REG_CONFIG_TLF\t\t0x1000\n#define DS620_REG_CONFIG_R1\t\t0x0800\n#define DS620_REG_CONFIG_R0\t\t0x0400\n#define DS620_REG_CONFIG_AUTOC\t\t0x0200\n#define DS620_REG_CONFIG_1SHOT\t\t0x0100\n#define DS620_REG_CONFIG_PO2\t\t0x0080\n#define DS620_REG_CONFIG_PO1\t\t0x0040\n#define DS620_REG_CONFIG_A2\t\t0x0020\n#define DS620_REG_CONFIG_A1\t\t0x0010\n#define DS620_REG_CONFIG_A0\t\t0x0008\n\n \nstatic const u8 DS620_REG_TEMP[3] = {\n\t0xAA,\t\t\t \n\t0xA2,\t\t\t \n\t0xA0,\t\t\t \n};\n\n#define DS620_REG_CONF\t\t0xAC\t \n#define DS620_COM_START\t\t0x51\t \n#define DS620_COM_STOP\t\t0x22\t \n\n \nstruct ds620_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\n\ts16 temp[3];\t\t \n};\n\nstatic void ds620_init_client(struct i2c_client *client)\n{\n\tstruct ds620_platform_data *ds620_info = dev_get_platdata(&client->dev);\n\tu16 conf, new_conf;\n\n\tnew_conf = conf =\n\t    i2c_smbus_read_word_swapped(client, DS620_REG_CONF);\n\n\t \n\tnew_conf &= ~DS620_REG_CONFIG_1SHOT;\n\t \n\tnew_conf |= DS620_REG_CONFIG_PO2;\n\t \n\tif (ds620_info && ds620_info->pomode == 1)\n\t\tnew_conf &= ~DS620_REG_CONFIG_PO1;  \n\telse if (ds620_info && ds620_info->pomode == 2)\n\t\tnew_conf |= DS620_REG_CONFIG_PO1;  \n\telse\n\t\tnew_conf &= ~DS620_REG_CONFIG_PO2;  \n\t \n\tnew_conf |= DS620_REG_CONFIG_R1 | DS620_REG_CONFIG_R0;\n\n\tif (conf != new_conf)\n\t\ti2c_smbus_write_word_swapped(client, DS620_REG_CONF, new_conf);\n\n\t \n\ti2c_smbus_write_byte(client, DS620_COM_START);\n}\n\nstatic struct ds620_data *ds620_update_client(struct device *dev)\n{\n\tstruct ds620_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tstruct ds620_data *ret = data;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\n\t    || !data->valid) {\n\t\tint i;\n\t\tint res;\n\n\t\tdev_dbg(&client->dev, \"Starting ds620 update\\n\");\n\n\t\tfor (i = 0; i < ARRAY_SIZE(data->temp); i++) {\n\t\t\tres = i2c_smbus_read_word_swapped(client,\n\t\t\t\t\t\t\t  DS620_REG_TEMP[i]);\n\t\t\tif (res < 0) {\n\t\t\t\tret = ERR_PTR(res);\n\t\t\t\tgoto abort;\n\t\t\t}\n\n\t\t\tdata->temp[i] = res;\n\t\t}\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\nabort:\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *da,\n\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ds620_data *data = ds620_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", ((data->temp[attr->index] / 8) * 625) / 10);\n}\n\nstatic ssize_t temp_store(struct device *dev, struct device_attribute *da,\n\t\t\t  const char *buf, size_t count)\n{\n\tint res;\n\tlong val;\n\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ds620_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tres = kstrtol(buf, 10, &val);\n\n\tif (res)\n\t\treturn res;\n\n\tval = (clamp_val(val, -128000, 128000) * 10 / 625) * 8;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp[attr->index] = val;\n\ti2c_smbus_write_word_swapped(client, DS620_REG_TEMP[attr->index],\n\t\t\t\t     data->temp[attr->index]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *da,\n\t\t\t  char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ds620_data *data = ds620_update_client(dev);\n\tstruct i2c_client *client;\n\tu16 conf, new_conf;\n\tint res;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tclient = data->client;\n\n\t \n\tres = i2c_smbus_read_word_swapped(client, DS620_REG_CONF);\n\tif (res < 0)\n\t\treturn res;\n\n\tnew_conf = conf = res;\n\tnew_conf &= ~attr->index;\n\tif (conf != new_conf) {\n\t\tres = i2c_smbus_write_word_swapped(client, DS620_REG_CONF,\n\t\t\t\t\t\t   new_conf);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", !!(conf & attr->index));\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_alarm, alarm, DS620_REG_CONFIG_TLF);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, alarm, DS620_REG_CONFIG_THF);\n\nstatic struct attribute *ds620_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(ds620);\n\nstatic int ds620_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct ds620_data *data;\n\n\tdata = devm_kzalloc(dev, sizeof(struct ds620_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tds620_init_client(client);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, ds620_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id ds620_id[] = {\n\t{\"ds620\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, ds620_id);\n\n \nstatic struct i2c_driver ds620_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t   .name = \"ds620\",\n\t},\n\t.probe = ds620_probe,\n\t.id_table = ds620_id,\n};\n\nmodule_i2c_driver(ds620_driver);\n\nMODULE_AUTHOR(\"Roland Stigge <stigge@antcom.de>\");\nMODULE_DESCRIPTION(\"DS620 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}