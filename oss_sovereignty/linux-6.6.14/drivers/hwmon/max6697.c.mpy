{
  "module_name": "max6697.c",
  "hash_id": "19f5d47f58f5ec9f78f748b696d9784f5644d66fdfd307b6f8f6b5854c86b19e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max6697.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n\n#include <linux/platform_data/max6697.h>\n\nenum chips { max6581, max6602, max6622, max6636, max6689, max6693, max6694,\n\t     max6697, max6698, max6699 };\n\n \n\nstatic const u8 MAX6697_REG_TEMP[] = {\n\t\t\t0x07, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x08 };\nstatic const u8 MAX6697_REG_TEMP_EXT[] = {\n\t\t\t0x57, 0x09, 0x52, 0x53, 0x54, 0x55, 0x56, 0 };\nstatic const u8 MAX6697_REG_MAX[] = {\n\t\t\t0x17, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x18 };\nstatic const u8 MAX6697_REG_CRIT[] = {\n\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27 };\n\n \n#define MAX6697_ALERT_MAP_BITS(reg)\t((((reg) & 0x7e) >> 1) | \\\n\t\t\t\t (((reg) & 0x01) << 6) | ((reg) & 0x80))\n#define MAX6697_OVERT_MAP_BITS(reg) (((reg) >> 1) | (((reg) & 0x01) << 7))\n\n#define MAX6697_REG_STAT(n)\t\t(0x44 + (n))\n\n#define MAX6697_REG_CONFIG\t\t0x41\n#define MAX6581_CONF_EXTENDED\t\t(1 << 1)\n#define MAX6693_CONF_BETA\t\t(1 << 2)\n#define MAX6697_CONF_RESISTANCE\t\t(1 << 3)\n#define MAX6697_CONF_TIMEOUT\t\t(1 << 5)\n#define MAX6697_REG_ALERT_MASK\t\t0x42\n#define MAX6697_REG_OVERT_MASK\t\t0x43\n\n#define MAX6581_REG_RESISTANCE\t\t0x4a\n#define MAX6581_REG_IDEALITY\t\t0x4b\n#define MAX6581_REG_IDEALITY_SELECT\t0x4c\n#define MAX6581_REG_OFFSET\t\t0x4d\n#define MAX6581_REG_OFFSET_SELECT\t0x4e\n#define MAX6581_OFFSET_MIN\t\t-31750\n#define MAX6581_OFFSET_MAX\t\t31750\n\n#define MAX6697_CONV_TIME\t\t156\t \n\nstruct max6697_chip_data {\n\tint channels;\n\tu32 have_ext;\n\tu32 have_crit;\n\tu32 have_fault;\n\tu8 valid_conf;\n\tconst u8 *alarm_map;\n};\n\nstruct max6697_data {\n\tstruct i2c_client *client;\n\n\tenum chips type;\n\tconst struct max6697_chip_data *chip;\n\n\tint update_interval;\t \n\tint temp_offset;\t \n\n\tstruct mutex update_lock;\n\tunsigned long last_updated;\t \n\tbool valid;\t\t \n\n\t \n\tu8 temp[8][4];\t\t \n#define MAX6697_TEMP_INPUT\t0\n#define MAX6697_TEMP_EXT\t1\n#define MAX6697_TEMP_MAX\t2\n#define MAX6697_TEMP_CRIT\t3\n\tu32 alarms;\n};\n\n \nstatic const u8 max6581_alarm_map[] = {\n\t 0, 0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15,\n\t 16, 17, 18, 19, 20, 21, 22, 23 };\n\nstatic const struct max6697_chip_data max6697_chip_data[] = {\n\t[max6581] = {\n\t\t.channels = 8,\n\t\t.have_crit = 0xff,\n\t\t.have_ext = 0x7f,\n\t\t.have_fault = 0xfe,\n\t\t.valid_conf = MAX6581_CONF_EXTENDED | MAX6697_CONF_TIMEOUT,\n\t\t.alarm_map = max6581_alarm_map,\n\t},\n\t[max6602] = {\n\t\t.channels = 5,\n\t\t.have_crit = 0x12,\n\t\t.have_ext = 0x02,\n\t\t.have_fault = 0x1e,\n\t\t.valid_conf = MAX6697_CONF_RESISTANCE | MAX6697_CONF_TIMEOUT,\n\t},\n\t[max6622] = {\n\t\t.channels = 5,\n\t\t.have_crit = 0x12,\n\t\t.have_ext = 0x02,\n\t\t.have_fault = 0x1e,\n\t\t.valid_conf = MAX6697_CONF_RESISTANCE | MAX6697_CONF_TIMEOUT,\n\t},\n\t[max6636] = {\n\t\t.channels = 7,\n\t\t.have_crit = 0x72,\n\t\t.have_ext = 0x02,\n\t\t.have_fault = 0x7e,\n\t\t.valid_conf = MAX6697_CONF_RESISTANCE | MAX6697_CONF_TIMEOUT,\n\t},\n\t[max6689] = {\n\t\t.channels = 7,\n\t\t.have_crit = 0x72,\n\t\t.have_ext = 0x02,\n\t\t.have_fault = 0x7e,\n\t\t.valid_conf = MAX6697_CONF_RESISTANCE | MAX6697_CONF_TIMEOUT,\n\t},\n\t[max6693] = {\n\t\t.channels = 7,\n\t\t.have_crit = 0x72,\n\t\t.have_ext = 0x02,\n\t\t.have_fault = 0x7e,\n\t\t.valid_conf = MAX6697_CONF_RESISTANCE | MAX6693_CONF_BETA |\n\t\t  MAX6697_CONF_TIMEOUT,\n\t},\n\t[max6694] = {\n\t\t.channels = 5,\n\t\t.have_crit = 0x12,\n\t\t.have_ext = 0x02,\n\t\t.have_fault = 0x1e,\n\t\t.valid_conf = MAX6697_CONF_RESISTANCE | MAX6693_CONF_BETA |\n\t\t  MAX6697_CONF_TIMEOUT,\n\t},\n\t[max6697] = {\n\t\t.channels = 7,\n\t\t.have_crit = 0x72,\n\t\t.have_ext = 0x02,\n\t\t.have_fault = 0x7e,\n\t\t.valid_conf = MAX6697_CONF_RESISTANCE | MAX6697_CONF_TIMEOUT,\n\t},\n\t[max6698] = {\n\t\t.channels = 7,\n\t\t.have_crit = 0x72,\n\t\t.have_ext = 0x02,\n\t\t.have_fault = 0x0e,\n\t\t.valid_conf = MAX6697_CONF_RESISTANCE | MAX6697_CONF_TIMEOUT,\n\t},\n\t[max6699] = {\n\t\t.channels = 5,\n\t\t.have_crit = 0x12,\n\t\t.have_ext = 0x02,\n\t\t.have_fault = 0x1e,\n\t\t.valid_conf = MAX6697_CONF_RESISTANCE | MAX6697_CONF_TIMEOUT,\n\t},\n};\n\nstatic inline int max6581_offset_to_millic(int val)\n{\n\treturn sign_extend32(val, 7) * 250;\n}\n\nstatic struct max6697_data *max6697_update_device(struct device *dev)\n{\n\tstruct max6697_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tstruct max6697_data *ret = data;\n\tint val;\n\tint i;\n\tu32 alarms;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (data->valid &&\n\t    !time_after(jiffies, data->last_updated\n\t\t\t+ msecs_to_jiffies(data->update_interval)))\n\t\tgoto abort;\n\n\tfor (i = 0; i < data->chip->channels; i++) {\n\t\tif (data->chip->have_ext & (1 << i)) {\n\t\t\tval = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t       MAX6697_REG_TEMP_EXT[i]);\n\t\t\tif (unlikely(val < 0)) {\n\t\t\t\tret = ERR_PTR(val);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tdata->temp[i][MAX6697_TEMP_EXT] = val;\n\t\t}\n\n\t\tval = i2c_smbus_read_byte_data(client, MAX6697_REG_TEMP[i]);\n\t\tif (unlikely(val < 0)) {\n\t\t\tret = ERR_PTR(val);\n\t\t\tgoto abort;\n\t\t}\n\t\tdata->temp[i][MAX6697_TEMP_INPUT] = val;\n\n\t\tval = i2c_smbus_read_byte_data(client, MAX6697_REG_MAX[i]);\n\t\tif (unlikely(val < 0)) {\n\t\t\tret = ERR_PTR(val);\n\t\t\tgoto abort;\n\t\t}\n\t\tdata->temp[i][MAX6697_TEMP_MAX] = val;\n\n\t\tif (data->chip->have_crit & (1 << i)) {\n\t\t\tval = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t       MAX6697_REG_CRIT[i]);\n\t\t\tif (unlikely(val < 0)) {\n\t\t\t\tret = ERR_PTR(val);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tdata->temp[i][MAX6697_TEMP_CRIT] = val;\n\t\t}\n\t}\n\n\talarms = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tval = i2c_smbus_read_byte_data(client, MAX6697_REG_STAT(i));\n\t\tif (unlikely(val < 0)) {\n\t\t\tret = ERR_PTR(val);\n\t\t\tgoto abort;\n\t\t}\n\t\talarms = (alarms << 8) | val;\n\t}\n\tdata->alarms = alarms;\n\tdata->last_updated = jiffies;\n\tdata->valid = true;\nabort:\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t temp_input_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct max6697_data *data = max6697_update_device(dev);\n\tint temp;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\ttemp = (data->temp[index][MAX6697_TEMP_INPUT] - data->temp_offset) << 3;\n\ttemp |= data->temp[index][MAX6697_TEMP_EXT] >> 5;\n\n\treturn sprintf(buf, \"%d\\n\", temp * 125);\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tint nr = to_sensor_dev_attr_2(devattr)->nr;\n\tint index = to_sensor_dev_attr_2(devattr)->index;\n\tstruct max6697_data *data = max6697_update_device(dev);\n\tint temp;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\ttemp = data->temp[nr][index];\n\ttemp -= data->temp_offset;\n\n\treturn sprintf(buf, \"%d\\n\", temp * 1000);\n}\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint index = to_sensor_dev_attr(attr)->index;\n\tstruct max6697_data *data = max6697_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (data->chip->alarm_map)\n\t\tindex = data->chip->alarm_map[index];\n\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> index) & 0x1);\n}\n\nstatic ssize_t temp_store(struct device *dev,\n\t\t\t  struct device_attribute *devattr, const char *buf,\n\t\t\t  size_t count)\n{\n\tint nr = to_sensor_dev_attr_2(devattr)->nr;\n\tint index = to_sensor_dev_attr_2(devattr)->index;\n\tstruct max6697_data *data = dev_get_drvdata(dev);\n\tlong temp;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&data->update_lock);\n\ttemp = DIV_ROUND_CLOSEST(temp, 1000) + data->temp_offset;\n\ttemp = clamp_val(temp, 0, data->type == max6581 ? 255 : 127);\n\tdata->temp[nr][index] = temp;\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tindex == 2 ? MAX6697_REG_MAX[nr]\n\t\t\t\t\t\t   : MAX6697_REG_CRIT[nr],\n\t\t\t\t\ttemp);\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret < 0 ? ret : count;\n}\n\nstatic ssize_t offset_store(struct device *dev, struct device_attribute *devattr, const char *buf,\n\t\t\t    size_t count)\n{\n\tint val, ret, index, select;\n\tstruct max6697_data *data;\n\tbool channel_enabled;\n\tlong temp;\n\n\tindex = to_sensor_dev_attr(devattr)->index;\n\tdata = dev_get_drvdata(dev);\n\tret = kstrtol(buf, 10, &temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&data->update_lock);\n\tselect = i2c_smbus_read_byte_data(data->client, MAX6581_REG_OFFSET_SELECT);\n\tif (select < 0) {\n\t\tret = select;\n\t\tgoto abort;\n\t}\n\tchannel_enabled = (select & (1 << (index - 1)));\n\ttemp = clamp_val(temp, MAX6581_OFFSET_MIN, MAX6581_OFFSET_MAX);\n\tval = DIV_ROUND_CLOSEST(temp, 250);\n\t \n\tif (val == 0) {\n\t\tif (channel_enabled)\n\t\t\tret = i2c_smbus_write_byte_data(data->client, MAX6581_REG_OFFSET_SELECT,\n\t\t\t\t\t\t\tselect & ~(1 << (index - 1)));\n\t\tret = ret < 0 ? ret : count;\n\t\tgoto abort;\n\t}\n\tif (!channel_enabled) {\n\t\tret = i2c_smbus_write_byte_data(data->client, MAX6581_REG_OFFSET_SELECT,\n\t\t\t\t\t\tselect | (1 << (index - 1)));\n\t\tif (ret < 0)\n\t\t\tgoto abort;\n\t}\n\tret = i2c_smbus_write_byte_data(data->client, MAX6581_REG_OFFSET, val);\n\tret = ret < 0 ? ret : count;\n\nabort:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t offset_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tstruct max6697_data *data;\n\tint select, ret, index;\n\n\tindex = to_sensor_dev_attr(devattr)->index;\n\tdata = dev_get_drvdata(dev);\n\tmutex_lock(&data->update_lock);\n\tselect = i2c_smbus_read_byte_data(data->client, MAX6581_REG_OFFSET_SELECT);\n\tif (select < 0)\n\t\tret = select;\n\telse if (select & (1 << (index - 1)))\n\t\tret = i2c_smbus_read_byte_data(data->client, MAX6581_REG_OFFSET);\n\telse\n\t\tret = 0;\n\tmutex_unlock(&data->update_lock);\n\treturn ret < 0 ? ret : sprintf(buf, \"%d\\n\", max6581_offset_to_millic(ret));\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp_input, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_max, temp, 0, MAX6697_TEMP_MAX);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_crit, temp, 0, MAX6697_TEMP_CRIT);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp_input, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_max, temp, 1, MAX6697_TEMP_MAX);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_crit, temp, 1, MAX6697_TEMP_CRIT);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp_input, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_max, temp, 2, MAX6697_TEMP_MAX);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_crit, temp, 2, MAX6697_TEMP_CRIT);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp4_input, temp_input, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp4_max, temp, 3, MAX6697_TEMP_MAX);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp4_crit, temp, 3, MAX6697_TEMP_CRIT);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp5_input, temp_input, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp5_max, temp, 4, MAX6697_TEMP_MAX);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp5_crit, temp, 4, MAX6697_TEMP_CRIT);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp6_input, temp_input, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp6_max, temp, 5, MAX6697_TEMP_MAX);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp6_crit, temp, 5, MAX6697_TEMP_CRIT);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp7_input, temp_input, 6);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp7_max, temp, 6, MAX6697_TEMP_MAX);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp7_crit, temp, 6, MAX6697_TEMP_CRIT);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp8_input, temp_input, 7);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp8_max, temp, 7, MAX6697_TEMP_MAX);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp8_crit, temp, 7, MAX6697_TEMP_CRIT);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, alarm, 22);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_max_alarm, alarm, 16);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_max_alarm, alarm, 17);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_max_alarm, alarm, 18);\nstatic SENSOR_DEVICE_ATTR_RO(temp5_max_alarm, alarm, 19);\nstatic SENSOR_DEVICE_ATTR_RO(temp6_max_alarm, alarm, 20);\nstatic SENSOR_DEVICE_ATTR_RO(temp7_max_alarm, alarm, 21);\nstatic SENSOR_DEVICE_ATTR_RO(temp8_max_alarm, alarm, 23);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_crit_alarm, alarm, 14);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_crit_alarm, alarm, 8);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_crit_alarm, alarm, 9);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_crit_alarm, alarm, 10);\nstatic SENSOR_DEVICE_ATTR_RO(temp5_crit_alarm, alarm, 11);\nstatic SENSOR_DEVICE_ATTR_RO(temp6_crit_alarm, alarm, 12);\nstatic SENSOR_DEVICE_ATTR_RO(temp7_crit_alarm, alarm, 13);\nstatic SENSOR_DEVICE_ATTR_RO(temp8_crit_alarm, alarm, 15);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp2_fault, alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_fault, alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_fault, alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp5_fault, alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp6_fault, alarm, 5);\nstatic SENSOR_DEVICE_ATTR_RO(temp7_fault, alarm, 6);\nstatic SENSOR_DEVICE_ATTR_RO(temp8_fault, alarm, 7);\n\n \nstatic SENSOR_DEVICE_ATTR_RW(temp2_offset, offset, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_offset, offset, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp4_offset, offset, 3);\nstatic SENSOR_DEVICE_ATTR_RW(temp5_offset, offset, 4);\nstatic SENSOR_DEVICE_ATTR_RW(temp6_offset, offset, 5);\nstatic SENSOR_DEVICE_ATTR_RW(temp7_offset, offset, 6);\nstatic SENSOR_DEVICE_ATTR_RW(temp8_offset, offset, 7);\n\nstatic DEVICE_ATTR(dummy, 0, NULL, NULL);\n\nstatic umode_t max6697_is_visible(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t  int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct max6697_data *data = dev_get_drvdata(dev);\n\tconst struct max6697_chip_data *chip = data->chip;\n\tint channel = index / 7;\t \n\tint nr = index % 7;\t\t \n\n\tif (channel >= chip->channels)\n\t\treturn 0;\n\n\tif ((nr == 3 || nr == 4) && !(chip->have_crit & (1 << channel)))\n\t\treturn 0;\n\tif (nr == 5 && !(chip->have_fault & (1 << channel)))\n\t\treturn 0;\n\t \n\tif (nr == 6)\n\t\tif (data->type != max6581 || channel == 0)\n\t\t\treturn 0;\n\n\treturn attr->mode;\n}\n\n \nstatic struct attribute *max6697_attributes[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_alarm.dev_attr.attr,\n\t&dev_attr_dummy.attr,\n\t&dev_attr_dummy.attr,\n\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp2_offset.dev_attr.attr,\n\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp3_offset.dev_attr.attr,\n\n\t&sensor_dev_attr_temp4_input.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp4_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp4_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp4_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp4_offset.dev_attr.attr,\n\n\t&sensor_dev_attr_temp5_input.dev_attr.attr,\n\t&sensor_dev_attr_temp5_max.dev_attr.attr,\n\t&sensor_dev_attr_temp5_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp5_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp5_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp5_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp5_offset.dev_attr.attr,\n\n\t&sensor_dev_attr_temp6_input.dev_attr.attr,\n\t&sensor_dev_attr_temp6_max.dev_attr.attr,\n\t&sensor_dev_attr_temp6_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp6_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp6_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp6_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp6_offset.dev_attr.attr,\n\n\t&sensor_dev_attr_temp7_input.dev_attr.attr,\n\t&sensor_dev_attr_temp7_max.dev_attr.attr,\n\t&sensor_dev_attr_temp7_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp7_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp7_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp7_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp7_offset.dev_attr.attr,\n\n\t&sensor_dev_attr_temp8_input.dev_attr.attr,\n\t&sensor_dev_attr_temp8_max.dev_attr.attr,\n\t&sensor_dev_attr_temp8_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp8_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp8_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp8_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp8_offset.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group max6697_group = {\n\t.attrs = max6697_attributes, .is_visible = max6697_is_visible,\n};\n__ATTRIBUTE_GROUPS(max6697);\n\nstatic void max6697_get_config_of(struct device_node *node,\n\t\t\t\t  struct max6697_platform_data *pdata)\n{\n\tint len;\n\tconst __be32 *prop;\n\n\tpdata->smbus_timeout_disable =\n\t\tof_property_read_bool(node, \"smbus-timeout-disable\");\n\tpdata->extended_range_enable =\n\t\tof_property_read_bool(node, \"extended-range-enable\");\n\tpdata->beta_compensation =\n\t\tof_property_read_bool(node, \"beta-compensation-enable\");\n\n\tprop = of_get_property(node, \"alert-mask\", &len);\n\tif (prop && len == sizeof(u32))\n\t\tpdata->alert_mask = be32_to_cpu(prop[0]);\n\tprop = of_get_property(node, \"over-temperature-mask\", &len);\n\tif (prop && len == sizeof(u32))\n\t\tpdata->over_temperature_mask = be32_to_cpu(prop[0]);\n\tprop = of_get_property(node, \"resistance-cancellation\", &len);\n\tif (prop) {\n\t\tif (len == sizeof(u32))\n\t\t\tpdata->resistance_cancellation = be32_to_cpu(prop[0]);\n\t\telse\n\t\t\tpdata->resistance_cancellation = 0xfe;\n\t}\n\tprop = of_get_property(node, \"transistor-ideality\", &len);\n\tif (prop && len == 2 * sizeof(u32)) {\n\t\t\tpdata->ideality_mask = be32_to_cpu(prop[0]);\n\t\t\tpdata->ideality_value = be32_to_cpu(prop[1]);\n\t}\n}\n\nstatic int max6697_init_chip(struct max6697_data *data,\n\t\t\t     struct i2c_client *client)\n{\n\tstruct max6697_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct max6697_platform_data p;\n\tconst struct max6697_chip_data *chip = data->chip;\n\tint factor = chip->channels;\n\tint ret, reg;\n\n\t \n\tif (!pdata && !client->dev.of_node) {\n\t\treg = i2c_smbus_read_byte_data(client, MAX6697_REG_CONFIG);\n\t\tif (reg < 0)\n\t\t\treturn reg;\n\t\tif (data->type == max6581) {\n\t\t\tif (reg & MAX6581_CONF_EXTENDED)\n\t\t\t\tdata->temp_offset = 64;\n\t\t\treg = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t       MAX6581_REG_RESISTANCE);\n\t\t\tif (reg < 0)\n\t\t\t\treturn reg;\n\t\t\tfactor += hweight8(reg);\n\t\t} else {\n\t\t\tif (reg & MAX6697_CONF_RESISTANCE)\n\t\t\t\tfactor++;\n\t\t}\n\t\tgoto done;\n\t}\n\n\tif (client->dev.of_node) {\n\t\tmemset(&p, 0, sizeof(p));\n\t\tmax6697_get_config_of(client->dev.of_node, &p);\n\t\tpdata = &p;\n\t}\n\n\treg = 0;\n\tif (pdata->smbus_timeout_disable &&\n\t    (chip->valid_conf & MAX6697_CONF_TIMEOUT)) {\n\t\treg |= MAX6697_CONF_TIMEOUT;\n\t}\n\tif (pdata->extended_range_enable &&\n\t    (chip->valid_conf & MAX6581_CONF_EXTENDED)) {\n\t\treg |= MAX6581_CONF_EXTENDED;\n\t\tdata->temp_offset = 64;\n\t}\n\tif (pdata->resistance_cancellation &&\n\t    (chip->valid_conf & MAX6697_CONF_RESISTANCE)) {\n\t\treg |= MAX6697_CONF_RESISTANCE;\n\t\tfactor++;\n\t}\n\tif (pdata->beta_compensation &&\n\t    (chip->valid_conf & MAX6693_CONF_BETA)) {\n\t\treg |= MAX6693_CONF_BETA;\n\t}\n\n\tret = i2c_smbus_write_byte_data(client, MAX6697_REG_CONFIG, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, MAX6697_REG_ALERT_MASK,\n\t\t\t\tMAX6697_ALERT_MAP_BITS(pdata->alert_mask));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, MAX6697_REG_OVERT_MASK,\n\t\t\tMAX6697_OVERT_MAP_BITS(pdata->over_temperature_mask));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (data->type == max6581) {\n\t\tfactor += hweight8(pdata->resistance_cancellation >> 1);\n\t\tret = i2c_smbus_write_byte_data(client, MAX6581_REG_RESISTANCE,\n\t\t\t\t\tpdata->resistance_cancellation >> 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = i2c_smbus_write_byte_data(client, MAX6581_REG_IDEALITY,\n\t\t\t\t\t\tpdata->ideality_value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\tMAX6581_REG_IDEALITY_SELECT,\n\t\t\t\t\t\tpdata->ideality_mask >> 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\ndone:\n\tdata->update_interval = factor * MAX6697_CONV_TIME;\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max6697_id[];\n\nstatic int max6697_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &client->dev;\n\tstruct max6697_data *data;\n\tstruct device *hwmon_dev;\n\tint err;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(struct max6697_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (client->dev.of_node)\n\t\tdata->type = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\tdata->type = i2c_match_id(max6697_id, client)->driver_data;\n\tdata->chip = &max6697_chip_data[data->type];\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\terr = max6697_init_chip(data, client);\n\tif (err)\n\t\treturn err;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   max6697_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id max6697_id[] = {\n\t{ \"max6581\", max6581 },\n\t{ \"max6602\", max6602 },\n\t{ \"max6622\", max6622 },\n\t{ \"max6636\", max6636 },\n\t{ \"max6689\", max6689 },\n\t{ \"max6693\", max6693 },\n\t{ \"max6694\", max6694 },\n\t{ \"max6697\", max6697 },\n\t{ \"max6698\", max6698 },\n\t{ \"max6699\", max6699 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max6697_id);\n\nstatic const struct of_device_id __maybe_unused max6697_of_match[] = {\n\t{\n\t\t.compatible = \"maxim,max6581\",\n\t\t.data = (void *)max6581\n\t},\n\t{\n\t\t.compatible = \"maxim,max6602\",\n\t\t.data = (void *)max6602\n\t},\n\t{\n\t\t.compatible = \"maxim,max6622\",\n\t\t.data = (void *)max6622\n\t},\n\t{\n\t\t.compatible = \"maxim,max6636\",\n\t\t.data = (void *)max6636\n\t},\n\t{\n\t\t.compatible = \"maxim,max6689\",\n\t\t.data = (void *)max6689\n\t},\n\t{\n\t\t.compatible = \"maxim,max6693\",\n\t\t.data = (void *)max6693\n\t},\n\t{\n\t\t.compatible = \"maxim,max6694\",\n\t\t.data = (void *)max6694\n\t},\n\t{\n\t\t.compatible = \"maxim,max6697\",\n\t\t.data = (void *)max6697\n\t},\n\t{\n\t\t.compatible = \"maxim,max6698\",\n\t\t.data = (void *)max6698\n\t},\n\t{\n\t\t.compatible = \"maxim,max6699\",\n\t\t.data = (void *)max6699\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, max6697_of_match);\n\nstatic struct i2c_driver max6697_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"max6697\",\n\t\t.of_match_table = of_match_ptr(max6697_of_match),\n\t},\n\t.probe = max6697_probe,\n\t.id_table = max6697_id,\n};\n\nmodule_i2c_driver(max6697_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"MAX6697 temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}