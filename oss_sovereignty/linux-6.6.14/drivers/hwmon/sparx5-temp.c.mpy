{
  "module_name": "sparx5-temp.c",
  "hash_id": "e47da4a00cc29ba8bf8a8c21adfee3c6dd73150497639769b2fb1e768d0b0ec4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/sparx5-temp.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/hwmon.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#define TEMP_CTRL\t\t0\n#define TEMP_CFG\t\t4\n#define  TEMP_CFG_CYCLES\tGENMASK(24, 15)\n#define  TEMP_CFG_ENA\t\tBIT(0)\n#define TEMP_STAT\t\t8\n#define  TEMP_STAT_VALID\tBIT(12)\n#define  TEMP_STAT_TEMP\t\tGENMASK(11, 0)\n\nstruct s5_hwmon {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic void s5_temp_enable(struct s5_hwmon *hwmon)\n{\n\tu32 val = readl(hwmon->base + TEMP_CFG);\n\tu32 clk = clk_get_rate(hwmon->clk) / USEC_PER_SEC;\n\n\tval &= ~TEMP_CFG_CYCLES;\n\tval |= FIELD_PREP(TEMP_CFG_CYCLES, clk);\n\tval |= TEMP_CFG_ENA;\n\n\twritel(val, hwmon->base + TEMP_CFG);\n}\n\nstatic int s5_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t   u32 attr, int channel, long *temp)\n{\n\tstruct s5_hwmon *hwmon = dev_get_drvdata(dev);\n\tint rc = 0, value;\n\tu32 stat;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tstat = readl_relaxed(hwmon->base + TEMP_STAT);\n\t\tif (!(stat & TEMP_STAT_VALID))\n\t\t\treturn -EAGAIN;\n\t\tvalue = stat & TEMP_STAT_TEMP;\n\t\t \n\t\tvalue = DIV_ROUND_CLOSEST(value * 3522, 4096) - 1094;\n\t\t \n\t\tvalue *= 100;\n\t\t*temp = value;\n\t\tbreak;\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic umode_t s5_is_visible(const void *_data, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel)\n{\n\tif (type != hwmon_temp)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const s5_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops s5_hwmon_ops = {\n\t.is_visible = s5_is_visible,\n\t.read = s5_read,\n};\n\nstatic const struct hwmon_chip_info s5_chip_info = {\n\t.ops = &s5_hwmon_ops,\n\t.info = s5_info,\n};\n\nstatic int s5_temp_probe(struct platform_device *pdev)\n{\n\tstruct device *hwmon_dev;\n\tstruct s5_hwmon *hwmon;\n\n\thwmon = devm_kzalloc(&pdev->dev, sizeof(*hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn -ENOMEM;\n\n\thwmon->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hwmon->base))\n\t\treturn PTR_ERR(hwmon->base);\n\n\thwmon->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(hwmon->clk))\n\t\treturn PTR_ERR(hwmon->clk);\n\n\ts5_temp_enable(hwmon);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&pdev->dev,\n\t\t\t\t\t\t\t \"s5_temp\",\n\t\t\t\t\t\t\t hwmon,\n\t\t\t\t\t\t\t &s5_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct of_device_id s5_temp_match[] = {\n\t{ .compatible = \"microchip,sparx5-temp\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, s5_temp_match);\n\nstatic struct platform_driver s5_temp_driver = {\n\t.probe = s5_temp_probe,\n\t.driver = {\n\t\t.name = \"sparx5-temp\",\n\t\t.of_match_table = s5_temp_match,\n\t},\n};\n\nmodule_platform_driver(s5_temp_driver);\n\nMODULE_AUTHOR(\"Lars Povlsen <lars.povlsen@microchip.com>\");\nMODULE_DESCRIPTION(\"Sparx5 SoC temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}