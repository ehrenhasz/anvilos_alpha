{
  "module_name": "w83l786ng.c",
  "hash_id": "f5780ada6b6cfd96add531cf210f5370e024f171a349f17ae2dae5cbea95b35e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/w83l786ng.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/jiffies.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x2e, 0x2f, I2C_CLIENT_END };\n\n \n\nstatic bool reset;\nmodule_param(reset, bool, 0);\nMODULE_PARM_DESC(reset, \"Set to 1 to reset chip, not recommended\");\n\n#define W83L786NG_REG_IN_MIN(nr)\t(0x2C + (nr) * 2)\n#define W83L786NG_REG_IN_MAX(nr)\t(0x2B + (nr) * 2)\n#define W83L786NG_REG_IN(nr)\t\t((nr) + 0x20)\n\n#define W83L786NG_REG_FAN(nr)\t\t((nr) + 0x28)\n#define W83L786NG_REG_FAN_MIN(nr)\t((nr) + 0x3B)\n\n#define W83L786NG_REG_CONFIG\t\t0x40\n#define W83L786NG_REG_ALARM1\t\t0x41\n#define W83L786NG_REG_ALARM2\t\t0x42\n#define W83L786NG_REG_GPIO_EN\t\t0x47\n#define W83L786NG_REG_MAN_ID2\t\t0x4C\n#define W83L786NG_REG_MAN_ID1\t\t0x4D\n#define W83L786NG_REG_CHIP_ID\t\t0x4E\n\n#define W83L786NG_REG_DIODE\t\t0x53\n#define W83L786NG_REG_FAN_DIV\t\t0x54\n#define W83L786NG_REG_FAN_CFG\t\t0x80\n\n#define W83L786NG_REG_TOLERANCE\t\t0x8D\n\nstatic const u8 W83L786NG_REG_TEMP[2][3] = {\n\t{ 0x25,\t\t \n\t  0x35,\t\t \n\t  0x36 },\t \n\t{ 0x26,\t\t \n\t  0x37,\t\t \n\t  0x38 }\t \n};\n\nstatic const u8 W83L786NG_PWM_MODE_SHIFT[] = {6, 7};\nstatic const u8 W83L786NG_PWM_ENABLE_SHIFT[] = {2, 4};\n\n \nstatic const u8 W83L786NG_REG_PWM[] = {0x81, 0x87};\n\n\nstatic inline u8\nFAN_TO_REG(long rpm, int div)\n{\n\tif (rpm == 0)\n\t\treturn 255;\n\trpm = clamp_val(rpm, 1, 1000000);\n\treturn clamp_val((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\n}\n\n#define FAN_FROM_REG(val, div)\t((val) == 0   ? -1 : \\\n\t\t\t\t((val) == 255 ? 0 : \\\n\t\t\t\t1350000 / ((val) * (div))))\n\n \n#define TEMP_TO_REG(val)\t(clamp_val(((val) < 0 ? (val) + 0x100 * 1000 \\\n\t\t\t\t\t\t      : (val)) / 1000, 0, 0xff))\n#define TEMP_FROM_REG(val)\t(((val) & 0x80 ? \\\n\t\t\t\t  (val) - 0x100 : (val)) * 1000)\n\n \n#define IN_TO_REG(val)\t\t(clamp_val((((val) + 4) / 8), 0, 255))\n#define IN_FROM_REG(val)\t((val) * 8)\n\n#define DIV_FROM_REG(val)\t(1 << (val))\n\nstatic inline u8\nDIV_TO_REG(long val)\n{\n\tint i;\n\tval = clamp_val(val, 1, 128) >> 1;\n\tfor (i = 0; i < 7; i++) {\n\t\tif (val == 0)\n\t\t\tbreak;\n\t\tval >>= 1;\n\t}\n\treturn (u8)i;\n}\n\nstruct w83l786ng_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tbool valid;\t\t\t \n\tunsigned long last_updated;\t \n\tunsigned long last_nonvolatile;\t \n\n\tu8 in[3];\n\tu8 in_max[3];\n\tu8 in_min[3];\n\tu8 fan[2];\n\tu8 fan_div[2];\n\tu8 fan_min[2];\n\tu8 temp_type[2];\n\tu8 temp[2][3];\n\tu8 pwm[2];\n\tu8 pwm_mode[2];\t \n\n\tu8 pwm_enable[2];  \n\tu8 tolerance[2];\n};\n\nstatic u8\nw83l786ng_read_value(struct i2c_client *client, u8 reg)\n{\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic int\nw83l786ng_write_value(struct i2c_client *client, u8 reg, u8 value)\n{\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic struct w83l786ng_data *w83l786ng_update_device(struct device *dev)\n{\n\tstruct w83l786ng_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint i, j;\n\tu8 reg_tmp, pwmcfg;\n\n\tmutex_lock(&data->update_lock);\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\n\t    || !data->valid) {\n\t\tdev_dbg(&client->dev, \"Updating w83l786ng data.\\n\");\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tdata->in[i] = w83l786ng_read_value(client,\n\t\t\t    W83L786NG_REG_IN(i));\n\t\t\tdata->in_min[i] = w83l786ng_read_value(client,\n\t\t\t    W83L786NG_REG_IN_MIN(i));\n\t\t\tdata->in_max[i] = w83l786ng_read_value(client,\n\t\t\t    W83L786NG_REG_IN_MAX(i));\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tdata->fan[i] = w83l786ng_read_value(client,\n\t\t\t    W83L786NG_REG_FAN(i));\n\t\t\tdata->fan_min[i] = w83l786ng_read_value(client,\n\t\t\t    W83L786NG_REG_FAN_MIN(i));\n\t\t}\n\n\t\t \n\t\treg_tmp = w83l786ng_read_value(client, W83L786NG_REG_FAN_DIV);\n\t\tdata->fan_div[0] = reg_tmp & 0x07;\n\t\tdata->fan_div[1] = (reg_tmp >> 4) & 0x07;\n\n\t\tpwmcfg = w83l786ng_read_value(client, W83L786NG_REG_FAN_CFG);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tdata->pwm_mode[i] =\n\t\t\t    ((pwmcfg >> W83L786NG_PWM_MODE_SHIFT[i]) & 1)\n\t\t\t    ? 0 : 1;\n\t\t\tdata->pwm_enable[i] =\n\t\t\t    ((pwmcfg >> W83L786NG_PWM_ENABLE_SHIFT[i]) & 3) + 1;\n\t\t\tdata->pwm[i] =\n\t\t\t    (w83l786ng_read_value(client, W83L786NG_REG_PWM[i])\n\t\t\t     & 0x0f) * 0x11;\n\t\t}\n\n\n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\tdata->temp[i][j] = w83l786ng_read_value(client,\n\t\t\t\t    W83L786NG_REG_TEMP[i][j]);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\treg_tmp = w83l786ng_read_value(client, W83L786NG_REG_TOLERANCE);\n\t\tdata->tolerance[0] = reg_tmp & 0x0f;\n\t\tdata->tolerance[1] = (reg_tmp >> 4) & 0x0f;\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \n#define show_in_reg(reg) \\\nstatic ssize_t \\\nshow_##reg(struct device *dev, struct device_attribute *attr, \\\n\t   char *buf) \\\n{ \\\n\tint nr = to_sensor_dev_attr(attr)->index; \\\n\tstruct w83l786ng_data *data = w83l786ng_update_device(dev); \\\n\treturn sprintf(buf, \"%d\\n\", IN_FROM_REG(data->reg[nr])); \\\n}\n\nshow_in_reg(in)\nshow_in_reg(in_min)\nshow_in_reg(in_max)\n\n#define store_in_reg(REG, reg) \\\nstatic ssize_t \\\nstore_in_##reg(struct device *dev, struct device_attribute *attr, \\\n\t       const char *buf, size_t count) \\\n{ \\\n\tint nr = to_sensor_dev_attr(attr)->index; \\\n\tstruct w83l786ng_data *data = dev_get_drvdata(dev); \\\n\tstruct i2c_client *client = data->client; \\\n\tunsigned long val; \\\n\tint err = kstrtoul(buf, 10, &val); \\\n\tif (err) \\\n\t\treturn err; \\\n\tmutex_lock(&data->update_lock); \\\n\tdata->in_##reg[nr] = IN_TO_REG(val); \\\n\tw83l786ng_write_value(client, W83L786NG_REG_IN_##REG(nr), \\\n\t\t\t      data->in_##reg[nr]); \\\n\tmutex_unlock(&data->update_lock); \\\n\treturn count; \\\n}\n\nstore_in_reg(MIN, min)\nstore_in_reg(MAX, max)\n\nstatic struct sensor_device_attribute sda_in_input[] = {\n\tSENSOR_ATTR(in0_input, S_IRUGO, show_in, NULL, 0),\n\tSENSOR_ATTR(in1_input, S_IRUGO, show_in, NULL, 1),\n\tSENSOR_ATTR(in2_input, S_IRUGO, show_in, NULL, 2),\n};\n\nstatic struct sensor_device_attribute sda_in_min[] = {\n\tSENSOR_ATTR(in0_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 0),\n\tSENSOR_ATTR(in1_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 1),\n\tSENSOR_ATTR(in2_min, S_IWUSR | S_IRUGO, show_in_min, store_in_min, 2),\n};\n\nstatic struct sensor_device_attribute sda_in_max[] = {\n\tSENSOR_ATTR(in0_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 0),\n\tSENSOR_ATTR(in1_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 1),\n\tSENSOR_ATTR(in2_max, S_IWUSR | S_IRUGO, show_in_max, store_in_max, 2),\n};\n\n#define show_fan_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\t\t  char *buf) \\\n{ \\\n\tint nr = to_sensor_dev_attr(attr)->index; \\\n\tstruct w83l786ng_data *data = w83l786ng_update_device(dev); \\\n\treturn sprintf(buf, \"%d\\n\", \\\n\t\tFAN_FROM_REG(data->reg[nr], DIV_FROM_REG(data->fan_div[nr]))); \\\n}\n\nshow_fan_reg(fan);\nshow_fan_reg(fan_min);\n\nstatic ssize_t\nstore_fan_min(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct w83l786ng_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\n\tw83l786ng_write_value(client, W83L786NG_REG_FAN_MIN(nr),\n\t\t\t      data->fan_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_fan_div(struct device *dev, struct device_attribute *attr,\n\t     char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct w83l786ng_data *data = w83l786ng_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", DIV_FROM_REG(data->fan_div[nr]));\n}\n\n \nstatic ssize_t\nstore_fan_div(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct w83l786ng_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tunsigned long min;\n\tu8 tmp_fan_div;\n\tu8 fan_div_reg;\n\tu8 keep_mask = 0;\n\tu8 new_shift = 0;\n\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmutex_lock(&data->update_lock);\n\tmin = FAN_FROM_REG(data->fan_min[nr], DIV_FROM_REG(data->fan_div[nr]));\n\n\tdata->fan_div[nr] = DIV_TO_REG(val);\n\n\tswitch (nr) {\n\tcase 0:\n\t\tkeep_mask = 0xf8;\n\t\tnew_shift = 0;\n\t\tbreak;\n\tcase 1:\n\t\tkeep_mask = 0x8f;\n\t\tnew_shift = 4;\n\t\tbreak;\n\t}\n\n\tfan_div_reg = w83l786ng_read_value(client, W83L786NG_REG_FAN_DIV)\n\t\t\t\t\t   & keep_mask;\n\n\ttmp_fan_div = (data->fan_div[nr] << new_shift) & ~keep_mask;\n\n\tw83l786ng_write_value(client, W83L786NG_REG_FAN_DIV,\n\t\t\t      fan_div_reg | tmp_fan_div);\n\n\t \n\tdata->fan_min[nr] = FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\n\tw83l786ng_write_value(client, W83L786NG_REG_FAN_MIN(nr),\n\t\t\t      data->fan_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic struct sensor_device_attribute sda_fan_input[] = {\n\tSENSOR_ATTR(fan1_input, S_IRUGO, show_fan, NULL, 0),\n\tSENSOR_ATTR(fan2_input, S_IRUGO, show_fan, NULL, 1),\n};\n\nstatic struct sensor_device_attribute sda_fan_min[] = {\n\tSENSOR_ATTR(fan1_min, S_IWUSR | S_IRUGO, show_fan_min,\n\t\t    store_fan_min, 0),\n\tSENSOR_ATTR(fan2_min, S_IWUSR | S_IRUGO, show_fan_min,\n\t\t    store_fan_min, 1),\n};\n\nstatic struct sensor_device_attribute sda_fan_div[] = {\n\tSENSOR_ATTR(fan1_div, S_IWUSR | S_IRUGO, show_fan_div,\n\t\t    store_fan_div, 0),\n\tSENSOR_ATTR(fan2_div, S_IWUSR | S_IRUGO, show_fan_div,\n\t\t    store_fan_div, 1),\n};\n\n\n \n\nstatic ssize_t\nshow_temp(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83l786ng_data *data = w83l786ng_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp[nr][index]));\n}\n\nstatic ssize_t\nstore_temp(struct device *dev, struct device_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83l786ng_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp[nr][index] = TEMP_TO_REG(val);\n\tw83l786ng_write_value(client, W83L786NG_REG_TEMP[nr][index],\n\t\t\t      data->temp[nr][index]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic struct sensor_device_attribute_2 sda_temp_input[] = {\n\tSENSOR_ATTR_2(temp1_input, S_IRUGO, show_temp, NULL, 0, 0),\n\tSENSOR_ATTR_2(temp2_input, S_IRUGO, show_temp, NULL, 1, 0),\n};\n\nstatic struct sensor_device_attribute_2 sda_temp_max[] = {\n\tSENSOR_ATTR_2(temp1_max, S_IRUGO | S_IWUSR,\n\t\t      show_temp, store_temp, 0, 1),\n\tSENSOR_ATTR_2(temp2_max, S_IRUGO | S_IWUSR,\n\t\t      show_temp, store_temp, 1, 1),\n};\n\nstatic struct sensor_device_attribute_2 sda_temp_max_hyst[] = {\n\tSENSOR_ATTR_2(temp1_max_hyst, S_IRUGO | S_IWUSR,\n\t\t      show_temp, store_temp, 0, 2),\n\tSENSOR_ATTR_2(temp2_max_hyst, S_IRUGO | S_IWUSR,\n\t\t      show_temp, store_temp, 1, 2),\n};\n\n#define show_pwm_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\t\t  char *buf) \\\n{ \\\n\tstruct w83l786ng_data *data = w83l786ng_update_device(dev); \\\n\tint nr = to_sensor_dev_attr(attr)->index; \\\n\treturn sprintf(buf, \"%d\\n\", data->reg[nr]); \\\n}\n\nshow_pwm_reg(pwm_mode)\nshow_pwm_reg(pwm_enable)\nshow_pwm_reg(pwm)\n\nstatic ssize_t\nstore_pwm_mode(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct w83l786ng_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 reg;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\tmutex_lock(&data->update_lock);\n\tdata->pwm_mode[nr] = val;\n\treg = w83l786ng_read_value(client, W83L786NG_REG_FAN_CFG);\n\treg &= ~(1 << W83L786NG_PWM_MODE_SHIFT[nr]);\n\tif (!val)\n\t\treg |= 1 << W83L786NG_PWM_MODE_SHIFT[nr];\n\tw83l786ng_write_value(client, W83L786NG_REG_FAN_CFG, reg);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\nstore_pwm(struct device *dev, struct device_attribute *attr,\n\t  const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct w83l786ng_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tval = clamp_val(val, 0, 255);\n\tval = DIV_ROUND_CLOSEST(val, 0x11);\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm[nr] = val * 0x11;\n\tval |= w83l786ng_read_value(client, W83L786NG_REG_PWM[nr]) & 0xf0;\n\tw83l786ng_write_value(client, W83L786NG_REG_PWM[nr], val);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\nstore_pwm_enable(struct device *dev, struct device_attribute *attr,\n\t\t const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct w83l786ng_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 reg;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (!val || val > 2)   \n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\treg = w83l786ng_read_value(client, W83L786NG_REG_FAN_CFG);\n\tdata->pwm_enable[nr] = val;\n\treg &= ~(0x03 << W83L786NG_PWM_ENABLE_SHIFT[nr]);\n\treg |= (val - 1) << W83L786NG_PWM_ENABLE_SHIFT[nr];\n\tw83l786ng_write_value(client, W83L786NG_REG_FAN_CFG, reg);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic struct sensor_device_attribute sda_pwm[] = {\n\tSENSOR_ATTR(pwm1, S_IWUSR | S_IRUGO, show_pwm, store_pwm, 0),\n\tSENSOR_ATTR(pwm2, S_IWUSR | S_IRUGO, show_pwm, store_pwm, 1),\n};\n\nstatic struct sensor_device_attribute sda_pwm_mode[] = {\n\tSENSOR_ATTR(pwm1_mode, S_IWUSR | S_IRUGO, show_pwm_mode,\n\t\t    store_pwm_mode, 0),\n\tSENSOR_ATTR(pwm2_mode, S_IWUSR | S_IRUGO, show_pwm_mode,\n\t\t    store_pwm_mode, 1),\n};\n\nstatic struct sensor_device_attribute sda_pwm_enable[] = {\n\tSENSOR_ATTR(pwm1_enable, S_IWUSR | S_IRUGO, show_pwm_enable,\n\t\t    store_pwm_enable, 0),\n\tSENSOR_ATTR(pwm2_enable, S_IWUSR | S_IRUGO, show_pwm_enable,\n\t\t    store_pwm_enable, 1),\n};\n\n \nstatic ssize_t\nshow_tolerance(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct w83l786ng_data *data = w83l786ng_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long)data->tolerance[nr]);\n}\n\nstatic ssize_t\nstore_tolerance(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct w83l786ng_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 tol_tmp, tol_mask;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\ttol_mask = w83l786ng_read_value(client,\n\t    W83L786NG_REG_TOLERANCE) & ((nr == 1) ? 0x0f : 0xf0);\n\ttol_tmp = clamp_val(val, 0, 15);\n\ttol_tmp &= 0x0f;\n\tdata->tolerance[nr] = tol_tmp;\n\tif (nr == 1)\n\t\ttol_tmp <<= 4;\n\n\tw83l786ng_write_value(client, W83L786NG_REG_TOLERANCE,\n\t\t\t      tol_mask | tol_tmp);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic struct sensor_device_attribute sda_tolerance[] = {\n\tSENSOR_ATTR(pwm1_tolerance, S_IWUSR | S_IRUGO,\n\t\t    show_tolerance, store_tolerance, 0),\n\tSENSOR_ATTR(pwm2_tolerance, S_IWUSR | S_IRUGO,\n\t\t    show_tolerance, store_tolerance, 1),\n};\n\n\n#define IN_UNIT_ATTRS(X)\t\\\n\t&sda_in_input[X].dev_attr.attr,\t\t\\\n\t&sda_in_min[X].dev_attr.attr,\t\t\\\n\t&sda_in_max[X].dev_attr.attr\n\n#define FAN_UNIT_ATTRS(X)\t\\\n\t&sda_fan_input[X].dev_attr.attr,\t\\\n\t&sda_fan_min[X].dev_attr.attr,\t\t\\\n\t&sda_fan_div[X].dev_attr.attr\n\n#define TEMP_UNIT_ATTRS(X)\t\\\n\t&sda_temp_input[X].dev_attr.attr,\t\\\n\t&sda_temp_max[X].dev_attr.attr,\t\t\\\n\t&sda_temp_max_hyst[X].dev_attr.attr\n\n#define PWM_UNIT_ATTRS(X)\t\\\n\t&sda_pwm[X].dev_attr.attr,\t\t\\\n\t&sda_pwm_mode[X].dev_attr.attr,\t\t\\\n\t&sda_pwm_enable[X].dev_attr.attr\n\n#define TOLERANCE_UNIT_ATTRS(X)\t\\\n\t&sda_tolerance[X].dev_attr.attr\n\nstatic struct attribute *w83l786ng_attrs[] = {\n\tIN_UNIT_ATTRS(0),\n\tIN_UNIT_ATTRS(1),\n\tIN_UNIT_ATTRS(2),\n\tFAN_UNIT_ATTRS(0),\n\tFAN_UNIT_ATTRS(1),\n\tTEMP_UNIT_ATTRS(0),\n\tTEMP_UNIT_ATTRS(1),\n\tPWM_UNIT_ATTRS(0),\n\tPWM_UNIT_ATTRS(1),\n\tTOLERANCE_UNIT_ATTRS(0),\n\tTOLERANCE_UNIT_ATTRS(1),\n\tNULL\n};\n\nATTRIBUTE_GROUPS(w83l786ng);\n\nstatic int\nw83l786ng_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tu16 man_id;\n\tu8 chip_id;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tif ((w83l786ng_read_value(client, W83L786NG_REG_CONFIG) & 0x80)) {\n\t\tdev_dbg(&adapter->dev, \"W83L786NG detection failed at 0x%02x\\n\",\n\t\t\tclient->addr);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tman_id = (w83l786ng_read_value(client, W83L786NG_REG_MAN_ID1) << 8) +\n\t\t w83l786ng_read_value(client, W83L786NG_REG_MAN_ID2);\n\tchip_id = w83l786ng_read_value(client, W83L786NG_REG_CHIP_ID);\n\n\tif (man_id != 0x5CA3 ||\t\t \n\t    chip_id != 0x80) {\t\t \n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"Unsupported chip (man_id=0x%04X, chip_id=0x%02X)\\n\",\n\t\t\tman_id, chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, \"w83l786ng\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic void w83l786ng_init_client(struct i2c_client *client)\n{\n\tu8 tmp;\n\n\tif (reset)\n\t\tw83l786ng_write_value(client, W83L786NG_REG_CONFIG, 0x80);\n\n\t \n\ttmp = w83l786ng_read_value(client, W83L786NG_REG_CONFIG);\n\tif (!(tmp & 0x01))\n\t\tw83l786ng_write_value(client, W83L786NG_REG_CONFIG, tmp | 0x01);\n}\n\nstatic int\nw83l786ng_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct w83l786ng_data *data;\n\tstruct device *hwmon_dev;\n\tint i;\n\tu8 reg_tmp;\n\n\tdata = devm_kzalloc(dev, sizeof(struct w83l786ng_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tw83l786ng_init_client(client);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tdata->fan_min[i] = w83l786ng_read_value(client,\n\t\t    W83L786NG_REG_FAN_MIN(i));\n\t}\n\n\t \n\treg_tmp = w83l786ng_read_value(client, W83L786NG_REG_FAN_DIV);\n\tdata->fan_div[0] = reg_tmp & 0x07;\n\tdata->fan_div[1] = (reg_tmp >> 4) & 0x07;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   w83l786ng_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id w83l786ng_id[] = {\n\t{ \"w83l786ng\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, w83l786ng_id);\n\nstatic struct i2c_driver w83l786ng_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t   .name = \"w83l786ng\",\n\t},\n\t.probe\t\t= w83l786ng_probe,\n\t.id_table\t= w83l786ng_id,\n\t.detect\t\t= w83l786ng_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(w83l786ng_driver);\n\nMODULE_AUTHOR(\"Kevin Lo\");\nMODULE_DESCRIPTION(\"w83l786ng driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}