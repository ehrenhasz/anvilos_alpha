{
  "module_name": "asc7621.c",
  "hash_id": "e158dd8cb833c16756d509db3578686b5419b8bb13484ee41eb6553d2931147f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/asc7621.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n\n \nstatic const unsigned short normal_i2c[] = {\n\t0x2c, 0x2d, 0x2e, I2C_CLIENT_END\n};\n\nenum asc7621_type {\n\tasc7621,\n\tasc7621a\n};\n\n#define INTERVAL_HIGH   (HZ + HZ / 2)\n#define INTERVAL_LOW    (1 * 60 * HZ)\n#define PRI_NONE        0\n#define PRI_LOW         1\n#define PRI_HIGH        2\n#define FIRST_CHIP      asc7621\n#define LAST_CHIP       asc7621a\n\nstruct asc7621_chip {\n\tchar *name;\n\tenum asc7621_type chip_type;\n\tu8 company_reg;\n\tu8 company_id;\n\tu8 verstep_reg;\n\tu8 verstep_id;\n\tconst unsigned short *addresses;\n};\n\nstatic struct asc7621_chip asc7621_chips[] = {\n\t{\n\t\t.name = \"asc7621\",\n\t\t.chip_type = asc7621,\n\t\t.company_reg = 0x3e,\n\t\t.company_id = 0x61,\n\t\t.verstep_reg = 0x3f,\n\t\t.verstep_id = 0x6c,\n\t\t.addresses = normal_i2c,\n\t },\n\t{\n\t\t.name = \"asc7621a\",\n\t\t.chip_type = asc7621a,\n\t\t.company_reg = 0x3e,\n\t\t.company_id = 0x61,\n\t\t.verstep_reg = 0x3f,\n\t\t.verstep_id = 0x6d,\n\t\t.addresses = normal_i2c,\n\t },\n};\n\n \n#define LAST_REGISTER 0xff\n\nstruct asc7621_data {\n\tstruct i2c_client client;\n\tstruct device *class_dev;\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_high_reading;\t \n\tunsigned long last_low_reading;\t\t \n\t \n\tu8 reg[LAST_REGISTER + 1];\n};\n\n \n#define to_asc7621_param(_sda) \\\n\tcontainer_of(_sda, struct asc7621_param, sda)\n\n \nstruct asc7621_param {\n\tstruct sensor_device_attribute sda;\n\tu8 priority;\n\tu8 msb[3];\n\tu8 lsb[3];\n\tu8 mask[3];\n\tu8 shift[3];\n};\n\n \nstatic u8 asc7621_register_priorities[255];\n\nstatic struct asc7621_data *asc7621_update_device(struct device *dev);\n\nstatic inline u8 read_byte(struct i2c_client *client, u8 reg)\n{\n\tint res = i2c_smbus_read_byte_data(client, reg);\n\tif (res < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Unable to read from register 0x%02x.\\n\", reg);\n\t\treturn 0;\n\t}\n\treturn res & 0xff;\n}\n\nstatic inline int write_byte(struct i2c_client *client, u8 reg, u8 data)\n{\n\tint res = i2c_smbus_write_byte_data(client, reg, data);\n\tif (res < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Unable to write value 0x%02x to register 0x%02x.\\n\",\n\t\t\tdata, reg);\n\t}\n\treturn res;\n}\n\n \n\n#define SETUP_SHOW_DATA_PARAM(d, a) \\\n\tstruct sensor_device_attribute *sda = to_sensor_dev_attr(a); \\\n\tstruct asc7621_data *data = asc7621_update_device(d); \\\n\tstruct asc7621_param *param = to_asc7621_param(sda)\n\n#define SETUP_STORE_DATA_PARAM(d, a) \\\n\tstruct sensor_device_attribute *sda = to_sensor_dev_attr(a); \\\n\tstruct i2c_client *client = to_i2c_client(d); \\\n\tstruct asc7621_data *data = i2c_get_clientdata(client); \\\n\tstruct asc7621_param *param = to_asc7621_param(sda)\n\n \nstatic ssize_t show_u8(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\n\treturn sprintf(buf, \"%u\\n\", data->reg[param->msb[0]]);\n}\n\nstatic ssize_t store_u8(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tlong reqval;\n\n\tif (kstrtol(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\treqval = clamp_val(reqval, 0, 255);\n\n\tmutex_lock(&data->update_lock);\n\tdata->reg[param->msb[0]] = reqval;\n\twrite_byte(client, param->msb[0], reqval);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \nstatic ssize_t show_bitmask(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       (data->reg[param->msb[0]] >> param->\n\t\t\tshift[0]) & param->mask[0]);\n}\n\nstatic ssize_t store_bitmask(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tlong reqval;\n\tu8 currval;\n\n\tif (kstrtol(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\treqval = clamp_val(reqval, 0, param->mask[0]);\n\n\treqval = (reqval & param->mask[0]) << param->shift[0];\n\n\tmutex_lock(&data->update_lock);\n\tcurrval = read_byte(client, param->msb[0]);\n\treqval |= (currval & ~(param->mask[0] << param->shift[0]));\n\tdata->reg[param->msb[0]] = reqval;\n\twrite_byte(client, param->msb[0], reqval);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \nstatic ssize_t show_fan16(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\tu16 regval;\n\n\tmutex_lock(&data->update_lock);\n\tregval = (data->reg[param->msb[0]] << 8) | data->reg[param->lsb[0]];\n\tmutex_unlock(&data->update_lock);\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       (regval == 0 ? -1 : (regval) ==\n\t\t\t0xffff ? 0 : 5400000 / regval));\n}\n\nstatic ssize_t store_fan16(struct device *dev,\n\t\t\t   struct device_attribute *attr, const char *buf,\n\t\t\t   size_t count)\n{\n\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tlong reqval;\n\n\tif (kstrtol(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\t \n\treqval =\n\t    (reqval <= 0 ? 0xffff : clamp_val(5400000 / reqval, 0, 0xfffe));\n\n\tmutex_lock(&data->update_lock);\n\tdata->reg[param->msb[0]] = (reqval >> 8) & 0xff;\n\tdata->reg[param->lsb[0]] = reqval & 0xff;\n\twrite_byte(client, param->msb[0], data->reg[param->msb[0]]);\n\twrite_byte(client, param->lsb[0], data->reg[param->lsb[0]]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\nstatic const int asc7621_in_scaling[] = {\n\t2500, 2250, 3300, 5000, 12000\n};\n\nstatic ssize_t show_in10(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\tu16 regval;\n\tu8 nr = sda->index;\n\n\tmutex_lock(&data->update_lock);\n\tregval = (data->reg[param->msb[0]] << 8) | (data->reg[param->lsb[0]]);\n\tmutex_unlock(&data->update_lock);\n\n\t \n\tregval = (regval >> 6) * asc7621_in_scaling[nr] / (0xc0 << 2);\n\n\treturn sprintf(buf, \"%u\\n\", regval);\n}\n\n \nstatic ssize_t show_in8(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\tu8 nr = sda->index;\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       ((data->reg[param->msb[0]] *\n\t\t\t asc7621_in_scaling[nr]) / 0xc0));\n}\n\nstatic ssize_t store_in8(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tlong reqval;\n\tu8 nr = sda->index;\n\n\tif (kstrtol(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\treqval = clamp_val(reqval, 0, 0xffff);\n\n\treqval = reqval * 0xc0 / asc7621_in_scaling[nr];\n\n\treqval = clamp_val(reqval, 0, 0xff);\n\n\tmutex_lock(&data->update_lock);\n\tdata->reg[param->msb[0]] = reqval;\n\twrite_byte(client, param->msb[0], reqval);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_temp8(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\n\treturn sprintf(buf, \"%d\\n\", ((s8) data->reg[param->msb[0]]) * 1000);\n}\n\nstatic ssize_t store_temp8(struct device *dev,\n\t\t\t   struct device_attribute *attr, const char *buf,\n\t\t\t   size_t count)\n{\n\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tlong reqval;\n\ts8 temp;\n\n\tif (kstrtol(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\treqval = clamp_val(reqval, -127000, 127000);\n\n\ttemp = reqval / 1000;\n\n\tmutex_lock(&data->update_lock);\n\tdata->reg[param->msb[0]] = temp;\n\twrite_byte(client, param->msb[0], temp);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \n\n \nstatic ssize_t show_temp10(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\tu8 msb, lsb;\n\tint temp;\n\n\tmutex_lock(&data->update_lock);\n\tmsb = data->reg[param->msb[0]];\n\tlsb = (data->reg[param->lsb[0]] >> 6) & 0x03;\n\ttemp = (((s8) msb) * 1000) + (lsb * 250);\n\tmutex_unlock(&data->update_lock);\n\n\treturn sprintf(buf, \"%d\\n\", temp);\n}\n\n \nstatic ssize_t show_temp62(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\tu8 regval = data->reg[param->msb[0]];\n\tint temp = ((s8) (regval & 0xfc) * 1000) + ((regval & 0x03) * 250);\n\n\treturn sprintf(buf, \"%d\\n\", temp);\n}\n\nstatic ssize_t store_temp62(struct device *dev,\n\t\t\t    struct device_attribute *attr, const char *buf,\n\t\t\t    size_t count)\n{\n\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tlong reqval, i, f;\n\ts8 temp;\n\n\tif (kstrtol(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\treqval = clamp_val(reqval, -32000, 31750);\n\ti = reqval / 1000;\n\tf = reqval - (i * 1000);\n\ttemp = i << 2;\n\ttemp |= f / 250;\n\n\tmutex_lock(&data->update_lock);\n\tdata->reg[param->msb[0]] = temp;\n\twrite_byte(client, param->msb[0], temp);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \n\nstatic const u32 asc7621_range_map[] = {\n\t2000, 2500, 3330, 4000, 5000, 6670, 8000, 10000,\n\t13330, 16000, 20000, 26670, 32000, 40000, 53330, 80000,\n};\n\nstatic ssize_t show_ap2_temp(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\tlong auto_point1;\n\tu8 regval;\n\tint temp;\n\n\tmutex_lock(&data->update_lock);\n\tauto_point1 = ((s8) data->reg[param->msb[1]]) * 1000;\n\tregval =\n\t    ((data->reg[param->msb[0]] >> param->shift[0]) & param->mask[0]);\n\ttemp = auto_point1 + asc7621_range_map[clamp_val(regval, 0, 15)];\n\tmutex_unlock(&data->update_lock);\n\n\treturn sprintf(buf, \"%d\\n\", temp);\n\n}\n\nstatic ssize_t store_ap2_temp(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tlong reqval, auto_point1;\n\tint i;\n\tu8 currval, newval = 0;\n\n\tif (kstrtol(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tauto_point1 = data->reg[param->msb[1]] * 1000;\n\treqval = clamp_val(reqval, auto_point1 + 2000, auto_point1 + 80000);\n\n\tfor (i = ARRAY_SIZE(asc7621_range_map) - 1; i >= 0; i--) {\n\t\tif (reqval >= auto_point1 + asc7621_range_map[i]) {\n\t\t\tnewval = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnewval = (newval & param->mask[0]) << param->shift[0];\n\tcurrval = read_byte(client, param->msb[0]);\n\tnewval |= (currval & ~(param->mask[0] << param->shift[0]));\n\tdata->reg[param->msb[0]] = newval;\n\twrite_byte(client, param->msb[0], newval);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t show_pwm_ac(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\tu8 config, altbit, regval;\n\tstatic const u8 map[] = {\n\t\t0x01, 0x02, 0x04, 0x1f, 0x00, 0x06, 0x07, 0x10,\n\t\t0x08, 0x0f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f\n\t};\n\n\tmutex_lock(&data->update_lock);\n\tconfig = (data->reg[param->msb[0]] >> param->shift[0]) & param->mask[0];\n\taltbit = (data->reg[param->msb[1]] >> param->shift[1]) & param->mask[1];\n\tregval = config | (altbit << 3);\n\tmutex_unlock(&data->update_lock);\n\n\treturn sprintf(buf, \"%u\\n\", map[clamp_val(regval, 0, 15)]);\n}\n\nstatic ssize_t store_pwm_ac(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tunsigned long reqval;\n\tu8 currval, config, altbit, newval;\n\tstatic const u16 map[] = {\n\t\t0x04, 0x00, 0x01, 0xff, 0x02, 0xff, 0x05, 0x06,\n\t\t0x08, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,\n\t\t0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03,\n\t};\n\n\tif (kstrtoul(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\tif (reqval > 31)\n\t\treturn -EINVAL;\n\n\treqval = map[reqval];\n\tif (reqval == 0xff)\n\t\treturn -EINVAL;\n\n\tconfig = reqval & 0x07;\n\taltbit = (reqval >> 3) & 0x01;\n\n\tconfig = (config & param->mask[0]) << param->shift[0];\n\taltbit = (altbit & param->mask[1]) << param->shift[1];\n\n\tmutex_lock(&data->update_lock);\n\tcurrval = read_byte(client, param->msb[0]);\n\tnewval = config | (currval & ~(param->mask[0] << param->shift[0]));\n\tnewval = altbit | (newval & ~(param->mask[1] << param->shift[1]));\n\tdata->reg[param->msb[0]] = newval;\n\twrite_byte(client, param->msb[0], newval);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t show_pwm_enable(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\tu8 config, altbit, minoff, val, newval;\n\n\tmutex_lock(&data->update_lock);\n\tconfig = (data->reg[param->msb[0]] >> param->shift[0]) & param->mask[0];\n\taltbit = (data->reg[param->msb[1]] >> param->shift[1]) & param->mask[1];\n\tminoff = (data->reg[param->msb[2]] >> param->shift[2]) & param->mask[2];\n\tmutex_unlock(&data->update_lock);\n\n\tval = config | (altbit << 3);\n\n\tif (val == 3 || val >= 10)\n\t\tnewval = 255;\n\telse if (val == 4)\n\t\tnewval = 0;\n\telse if (val == 7)\n\t\tnewval = 1;\n\telse if (minoff == 1)\n\t\tnewval = 2;\n\telse\n\t\tnewval = 3;\n\n\treturn sprintf(buf, \"%u\\n\", newval);\n}\n\nstatic ssize_t store_pwm_enable(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tlong reqval;\n\tu8 currval, config, altbit, newval, minoff = 255;\n\n\tif (kstrtol(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\tswitch (reqval) {\n\tcase 0:\n\t\tnewval = 0x04;\n\t\tbreak;\n\tcase 1:\n\t\tnewval = 0x07;\n\t\tbreak;\n\tcase 2:\n\t\tnewval = 0x00;\n\t\tminoff = 1;\n\t\tbreak;\n\tcase 3:\n\t\tnewval = 0x00;\n\t\tminoff = 0;\n\t\tbreak;\n\tcase 255:\n\t\tnewval = 0x03;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tconfig = newval & 0x07;\n\taltbit = (newval >> 3) & 0x01;\n\n\tmutex_lock(&data->update_lock);\n\tconfig = (config & param->mask[0]) << param->shift[0];\n\taltbit = (altbit & param->mask[1]) << param->shift[1];\n\tcurrval = read_byte(client, param->msb[0]);\n\tnewval = config | (currval & ~(param->mask[0] << param->shift[0]));\n\tnewval = altbit | (newval & ~(param->mask[1] << param->shift[1]));\n\tdata->reg[param->msb[0]] = newval;\n\twrite_byte(client, param->msb[0], newval);\n\tif (minoff < 255) {\n\t\tminoff = (minoff & param->mask[2]) << param->shift[2];\n\t\tcurrval = read_byte(client, param->msb[2]);\n\t\tnewval =\n\t\t    minoff | (currval & ~(param->mask[2] << param->shift[2]));\n\t\tdata->reg[param->msb[2]] = newval;\n\t\twrite_byte(client, param->msb[2], newval);\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic const u32 asc7621_pwm_freq_map[] = {\n\t10, 15, 23, 30, 38, 47, 62, 94,\n\t23000, 24000, 25000, 26000, 27000, 28000, 29000, 30000\n};\n\nstatic ssize_t show_pwm_freq(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\tu8 regval =\n\t    (data->reg[param->msb[0]] >> param->shift[0]) & param->mask[0];\n\n\tregval = clamp_val(regval, 0, 15);\n\n\treturn sprintf(buf, \"%u\\n\", asc7621_pwm_freq_map[regval]);\n}\n\nstatic ssize_t store_pwm_freq(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tunsigned long reqval;\n\tu8 currval, newval = 255;\n\tint i;\n\n\tif (kstrtoul(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(asc7621_pwm_freq_map); i++) {\n\t\tif (reqval == asc7621_pwm_freq_map[i]) {\n\t\t\tnewval = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (newval == 255)\n\t\treturn -EINVAL;\n\n\tnewval = (newval & param->mask[0]) << param->shift[0];\n\n\tmutex_lock(&data->update_lock);\n\tcurrval = read_byte(client, param->msb[0]);\n\tnewval |= (currval & ~(param->mask[0] << param->shift[0]));\n\tdata->reg[param->msb[0]] = newval;\n\twrite_byte(client, param->msb[0], newval);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic const u32 asc7621_pwm_auto_spinup_map[] =  {\n\t0, 100, 250, 400, 700, 1000, 2000, 4000\n};\n\nstatic ssize_t show_pwm_ast(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\tu8 regval =\n\t    (data->reg[param->msb[0]] >> param->shift[0]) & param->mask[0];\n\n\tregval = clamp_val(regval, 0, 7);\n\n\treturn sprintf(buf, \"%u\\n\", asc7621_pwm_auto_spinup_map[regval]);\n\n}\n\nstatic ssize_t store_pwm_ast(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tlong reqval;\n\tu8 currval, newval = 255;\n\tu32 i;\n\n\tif (kstrtol(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(asc7621_pwm_auto_spinup_map); i++) {\n\t\tif (reqval == asc7621_pwm_auto_spinup_map[i]) {\n\t\t\tnewval = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (newval == 255)\n\t\treturn -EINVAL;\n\n\tnewval = (newval & param->mask[0]) << param->shift[0];\n\n\tmutex_lock(&data->update_lock);\n\tcurrval = read_byte(client, param->msb[0]);\n\tnewval |= (currval & ~(param->mask[0] << param->shift[0]));\n\tdata->reg[param->msb[0]] = newval;\n\twrite_byte(client, param->msb[0], newval);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic const u32 asc7621_temp_smoothing_time_map[] = {\n\t35000, 17600, 11800, 7000, 4400, 3000, 1600, 800\n};\n\nstatic ssize_t show_temp_st(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tSETUP_SHOW_DATA_PARAM(dev, attr);\n\tu8 regval =\n\t    (data->reg[param->msb[0]] >> param->shift[0]) & param->mask[0];\n\tregval = clamp_val(regval, 0, 7);\n\n\treturn sprintf(buf, \"%u\\n\", asc7621_temp_smoothing_time_map[regval]);\n}\n\nstatic ssize_t store_temp_st(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tSETUP_STORE_DATA_PARAM(dev, attr);\n\tlong reqval;\n\tu8 currval, newval = 255;\n\tu32 i;\n\n\tif (kstrtol(buf, 10, &reqval))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(asc7621_temp_smoothing_time_map); i++) {\n\t\tif (reqval == asc7621_temp_smoothing_time_map[i]) {\n\t\t\tnewval = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (newval == 255)\n\t\treturn -EINVAL;\n\n\tnewval = (newval & param->mask[0]) << param->shift[0];\n\n\tmutex_lock(&data->update_lock);\n\tcurrval = read_byte(client, param->msb[0]);\n\tnewval |= (currval & ~(param->mask[0] << param->shift[0]));\n\tdata->reg[param->msb[0]] = newval;\n\twrite_byte(client, param->msb[0], newval);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \n\n \n#define VAA(args...) {args}\n\n#define PREAD(name, n, pri, rm, rl, m, s, r) \\\n\t{.sda = SENSOR_ATTR(name, S_IRUGO, show_##r, NULL, n), \\\n\t  .priority = pri, .msb[0] = rm, .lsb[0] = rl, .mask[0] = m, \\\n\t  .shift[0] = s,}\n\n#define PWRITE(name, n, pri, rm, rl, m, s, r) \\\n\t{.sda = SENSOR_ATTR(name, S_IRUGO | S_IWUSR, show_##r, store_##r, n), \\\n\t  .priority = pri, .msb[0] = rm, .lsb[0] = rl, .mask[0] = m, \\\n\t  .shift[0] = s,}\n\n \n#define PWRITEM(name, n, pri, rm, rl, m, s, r) \\\n\t{.sda = SENSOR_ATTR(name, S_IRUGO | S_IWUSR, show_##r, store_##r, n), \\\n\t  .priority = pri, .msb = rm, .lsb = rl, .mask = m, .shift = s,}\n\nstatic struct asc7621_param asc7621_params[] = {\n\tPREAD(in0_input, 0, PRI_HIGH, 0x20, 0x13, 0, 0, in10),\n\tPREAD(in1_input, 1, PRI_HIGH, 0x21, 0x18, 0, 0, in10),\n\tPREAD(in2_input, 2, PRI_HIGH, 0x22, 0x11, 0, 0, in10),\n\tPREAD(in3_input, 3, PRI_HIGH, 0x23, 0x12, 0, 0, in10),\n\tPREAD(in4_input, 4, PRI_HIGH, 0x24, 0x14, 0, 0, in10),\n\n\tPWRITE(in0_min, 0, PRI_LOW, 0x44, 0, 0, 0, in8),\n\tPWRITE(in1_min, 1, PRI_LOW, 0x46, 0, 0, 0, in8),\n\tPWRITE(in2_min, 2, PRI_LOW, 0x48, 0, 0, 0, in8),\n\tPWRITE(in3_min, 3, PRI_LOW, 0x4a, 0, 0, 0, in8),\n\tPWRITE(in4_min, 4, PRI_LOW, 0x4c, 0, 0, 0, in8),\n\n\tPWRITE(in0_max, 0, PRI_LOW, 0x45, 0, 0, 0, in8),\n\tPWRITE(in1_max, 1, PRI_LOW, 0x47, 0, 0, 0, in8),\n\tPWRITE(in2_max, 2, PRI_LOW, 0x49, 0, 0, 0, in8),\n\tPWRITE(in3_max, 3, PRI_LOW, 0x4b, 0, 0, 0, in8),\n\tPWRITE(in4_max, 4, PRI_LOW, 0x4d, 0, 0, 0, in8),\n\n\tPREAD(in0_alarm, 0, PRI_HIGH, 0x41, 0, 0x01, 0, bitmask),\n\tPREAD(in1_alarm, 1, PRI_HIGH, 0x41, 0, 0x01, 1, bitmask),\n\tPREAD(in2_alarm, 2, PRI_HIGH, 0x41, 0, 0x01, 2, bitmask),\n\tPREAD(in3_alarm, 3, PRI_HIGH, 0x41, 0, 0x01, 3, bitmask),\n\tPREAD(in4_alarm, 4, PRI_HIGH, 0x42, 0, 0x01, 0, bitmask),\n\n\tPREAD(fan1_input, 0, PRI_HIGH, 0x29, 0x28, 0, 0, fan16),\n\tPREAD(fan2_input, 1, PRI_HIGH, 0x2b, 0x2a, 0, 0, fan16),\n\tPREAD(fan3_input, 2, PRI_HIGH, 0x2d, 0x2c, 0, 0, fan16),\n\tPREAD(fan4_input, 3, PRI_HIGH, 0x2f, 0x2e, 0, 0, fan16),\n\n\tPWRITE(fan1_min, 0, PRI_LOW, 0x55, 0x54, 0, 0, fan16),\n\tPWRITE(fan2_min, 1, PRI_LOW, 0x57, 0x56, 0, 0, fan16),\n\tPWRITE(fan3_min, 2, PRI_LOW, 0x59, 0x58, 0, 0, fan16),\n\tPWRITE(fan4_min, 3, PRI_LOW, 0x5b, 0x5a, 0, 0, fan16),\n\n\tPREAD(fan1_alarm, 0, PRI_HIGH, 0x42, 0, 0x01, 2, bitmask),\n\tPREAD(fan2_alarm, 1, PRI_HIGH, 0x42, 0, 0x01, 3, bitmask),\n\tPREAD(fan3_alarm, 2, PRI_HIGH, 0x42, 0, 0x01, 4, bitmask),\n\tPREAD(fan4_alarm, 3, PRI_HIGH, 0x42, 0, 0x01, 5, bitmask),\n\n\tPREAD(temp1_input, 0, PRI_HIGH, 0x25, 0x10, 0, 0, temp10),\n\tPREAD(temp2_input, 1, PRI_HIGH, 0x26, 0x15, 0, 0, temp10),\n\tPREAD(temp3_input, 2, PRI_HIGH, 0x27, 0x16, 0, 0, temp10),\n\tPREAD(temp4_input, 3, PRI_HIGH, 0x33, 0x17, 0, 0, temp10),\n\tPREAD(temp5_input, 4, PRI_HIGH, 0xf7, 0xf6, 0, 0, temp10),\n\tPREAD(temp6_input, 5, PRI_HIGH, 0xf9, 0xf8, 0, 0, temp10),\n\tPREAD(temp7_input, 6, PRI_HIGH, 0xfb, 0xfa, 0, 0, temp10),\n\tPREAD(temp8_input, 7, PRI_HIGH, 0xfd, 0xfc, 0, 0, temp10),\n\n\tPWRITE(temp1_min, 0, PRI_LOW, 0x4e, 0, 0, 0, temp8),\n\tPWRITE(temp2_min, 1, PRI_LOW, 0x50, 0, 0, 0, temp8),\n\tPWRITE(temp3_min, 2, PRI_LOW, 0x52, 0, 0, 0, temp8),\n\tPWRITE(temp4_min, 3, PRI_LOW, 0x34, 0, 0, 0, temp8),\n\n\tPWRITE(temp1_max, 0, PRI_LOW, 0x4f, 0, 0, 0, temp8),\n\tPWRITE(temp2_max, 1, PRI_LOW, 0x51, 0, 0, 0, temp8),\n\tPWRITE(temp3_max, 2, PRI_LOW, 0x53, 0, 0, 0, temp8),\n\tPWRITE(temp4_max, 3, PRI_LOW, 0x35, 0, 0, 0, temp8),\n\n\tPREAD(temp1_alarm, 0, PRI_HIGH, 0x41, 0, 0x01, 4, bitmask),\n\tPREAD(temp2_alarm, 1, PRI_HIGH, 0x41, 0, 0x01, 5, bitmask),\n\tPREAD(temp3_alarm, 2, PRI_HIGH, 0x41, 0, 0x01, 6, bitmask),\n\tPREAD(temp4_alarm, 3, PRI_HIGH, 0x43, 0, 0x01, 0, bitmask),\n\n\tPWRITE(temp1_source, 0, PRI_LOW, 0x02, 0, 0x07, 4, bitmask),\n\tPWRITE(temp2_source, 1, PRI_LOW, 0x02, 0, 0x07, 0, bitmask),\n\tPWRITE(temp3_source, 2, PRI_LOW, 0x03, 0, 0x07, 4, bitmask),\n\tPWRITE(temp4_source, 3, PRI_LOW, 0x03, 0, 0x07, 0, bitmask),\n\n\tPWRITE(temp1_smoothing_enable, 0, PRI_LOW, 0x62, 0, 0x01, 3, bitmask),\n\tPWRITE(temp2_smoothing_enable, 1, PRI_LOW, 0x63, 0, 0x01, 7, bitmask),\n\tPWRITE(temp3_smoothing_enable, 2, PRI_LOW, 0x63, 0, 0x01, 3, bitmask),\n\tPWRITE(temp4_smoothing_enable, 3, PRI_LOW, 0x3c, 0, 0x01, 3, bitmask),\n\n\tPWRITE(temp1_smoothing_time, 0, PRI_LOW, 0x62, 0, 0x07, 0, temp_st),\n\tPWRITE(temp2_smoothing_time, 1, PRI_LOW, 0x63, 0, 0x07, 4, temp_st),\n\tPWRITE(temp3_smoothing_time, 2, PRI_LOW, 0x63, 0, 0x07, 0, temp_st),\n\tPWRITE(temp4_smoothing_time, 3, PRI_LOW, 0x3c, 0, 0x07, 0, temp_st),\n\n\tPWRITE(temp1_auto_point1_temp_hyst, 0, PRI_LOW, 0x6d, 0, 0x0f, 4,\n\t       bitmask),\n\tPWRITE(temp2_auto_point1_temp_hyst, 1, PRI_LOW, 0x6d, 0, 0x0f, 0,\n\t       bitmask),\n\tPWRITE(temp3_auto_point1_temp_hyst, 2, PRI_LOW, 0x6e, 0, 0x0f, 4,\n\t       bitmask),\n\tPWRITE(temp4_auto_point1_temp_hyst, 3, PRI_LOW, 0x6e, 0, 0x0f, 0,\n\t       bitmask),\n\n\tPREAD(temp1_auto_point2_temp_hyst, 0, PRI_LOW, 0x6d, 0, 0x0f, 4,\n\t      bitmask),\n\tPREAD(temp2_auto_point2_temp_hyst, 1, PRI_LOW, 0x6d, 0, 0x0f, 0,\n\t      bitmask),\n\tPREAD(temp3_auto_point2_temp_hyst, 2, PRI_LOW, 0x6e, 0, 0x0f, 4,\n\t      bitmask),\n\tPREAD(temp4_auto_point2_temp_hyst, 3, PRI_LOW, 0x6e, 0, 0x0f, 0,\n\t      bitmask),\n\n\tPWRITE(temp1_auto_point1_temp, 0, PRI_LOW, 0x67, 0, 0, 0, temp8),\n\tPWRITE(temp2_auto_point1_temp, 1, PRI_LOW, 0x68, 0, 0, 0, temp8),\n\tPWRITE(temp3_auto_point1_temp, 2, PRI_LOW, 0x69, 0, 0, 0, temp8),\n\tPWRITE(temp4_auto_point1_temp, 3, PRI_LOW, 0x3b, 0, 0, 0, temp8),\n\n\tPWRITEM(temp1_auto_point2_temp, 0, PRI_LOW, VAA(0x5f, 0x67), VAA(0),\n\t\tVAA(0x0f), VAA(4), ap2_temp),\n\tPWRITEM(temp2_auto_point2_temp, 1, PRI_LOW, VAA(0x60, 0x68), VAA(0),\n\t\tVAA(0x0f), VAA(4), ap2_temp),\n\tPWRITEM(temp3_auto_point2_temp, 2, PRI_LOW, VAA(0x61, 0x69), VAA(0),\n\t\tVAA(0x0f), VAA(4), ap2_temp),\n\tPWRITEM(temp4_auto_point2_temp, 3, PRI_LOW, VAA(0x3c, 0x3b), VAA(0),\n\t\tVAA(0x0f), VAA(4), ap2_temp),\n\n\tPWRITE(temp1_crit, 0, PRI_LOW, 0x6a, 0, 0, 0, temp8),\n\tPWRITE(temp2_crit, 1, PRI_LOW, 0x6b, 0, 0, 0, temp8),\n\tPWRITE(temp3_crit, 2, PRI_LOW, 0x6c, 0, 0, 0, temp8),\n\tPWRITE(temp4_crit, 3, PRI_LOW, 0x3d, 0, 0, 0, temp8),\n\n\tPWRITE(temp5_enable, 4, PRI_LOW, 0x0e, 0, 0x01, 0, bitmask),\n\tPWRITE(temp6_enable, 5, PRI_LOW, 0x0e, 0, 0x01, 1, bitmask),\n\tPWRITE(temp7_enable, 6, PRI_LOW, 0x0e, 0, 0x01, 2, bitmask),\n\tPWRITE(temp8_enable, 7, PRI_LOW, 0x0e, 0, 0x01, 3, bitmask),\n\n\tPWRITE(remote1_offset, 0, PRI_LOW, 0x1c, 0, 0, 0, temp62),\n\tPWRITE(remote2_offset, 1, PRI_LOW, 0x1d, 0, 0, 0, temp62),\n\n\tPWRITE(pwm1, 0, PRI_HIGH, 0x30, 0, 0, 0, u8),\n\tPWRITE(pwm2, 1, PRI_HIGH, 0x31, 0, 0, 0, u8),\n\tPWRITE(pwm3, 2, PRI_HIGH, 0x32, 0, 0, 0, u8),\n\n\tPWRITE(pwm1_invert, 0, PRI_LOW, 0x5c, 0, 0x01, 4, bitmask),\n\tPWRITE(pwm2_invert, 1, PRI_LOW, 0x5d, 0, 0x01, 4, bitmask),\n\tPWRITE(pwm3_invert, 2, PRI_LOW, 0x5e, 0, 0x01, 4, bitmask),\n\n\tPWRITEM(pwm1_enable, 0, PRI_LOW, VAA(0x5c, 0x5c, 0x62), VAA(0, 0, 0),\n\t\tVAA(0x07, 0x01, 0x01), VAA(5, 3, 5), pwm_enable),\n\tPWRITEM(pwm2_enable, 1, PRI_LOW, VAA(0x5d, 0x5d, 0x62), VAA(0, 0, 0),\n\t\tVAA(0x07, 0x01, 0x01), VAA(5, 3, 6), pwm_enable),\n\tPWRITEM(pwm3_enable, 2, PRI_LOW, VAA(0x5e, 0x5e, 0x62), VAA(0, 0, 0),\n\t\tVAA(0x07, 0x01, 0x01), VAA(5, 3, 7), pwm_enable),\n\n\tPWRITEM(pwm1_auto_channels, 0, PRI_LOW, VAA(0x5c, 0x5c), VAA(0, 0),\n\t\tVAA(0x07, 0x01), VAA(5, 3), pwm_ac),\n\tPWRITEM(pwm2_auto_channels, 1, PRI_LOW, VAA(0x5d, 0x5d), VAA(0, 0),\n\t\tVAA(0x07, 0x01), VAA(5, 3), pwm_ac),\n\tPWRITEM(pwm3_auto_channels, 2, PRI_LOW, VAA(0x5e, 0x5e), VAA(0, 0),\n\t\tVAA(0x07, 0x01), VAA(5, 3), pwm_ac),\n\n\tPWRITE(pwm1_auto_point1_pwm, 0, PRI_LOW, 0x64, 0, 0, 0, u8),\n\tPWRITE(pwm2_auto_point1_pwm, 1, PRI_LOW, 0x65, 0, 0, 0, u8),\n\tPWRITE(pwm3_auto_point1_pwm, 2, PRI_LOW, 0x66, 0, 0, 0, u8),\n\n\tPWRITE(pwm1_auto_point2_pwm, 0, PRI_LOW, 0x38, 0, 0, 0, u8),\n\tPWRITE(pwm2_auto_point2_pwm, 1, PRI_LOW, 0x39, 0, 0, 0, u8),\n\tPWRITE(pwm3_auto_point2_pwm, 2, PRI_LOW, 0x3a, 0, 0, 0, u8),\n\n\tPWRITE(pwm1_freq, 0, PRI_LOW, 0x5f, 0, 0x0f, 0, pwm_freq),\n\tPWRITE(pwm2_freq, 1, PRI_LOW, 0x60, 0, 0x0f, 0, pwm_freq),\n\tPWRITE(pwm3_freq, 2, PRI_LOW, 0x61, 0, 0x0f, 0, pwm_freq),\n\n\tPREAD(pwm1_auto_zone_assigned, 0, PRI_LOW, 0, 0, 0x03, 2, bitmask),\n\tPREAD(pwm2_auto_zone_assigned, 1, PRI_LOW, 0, 0, 0x03, 4, bitmask),\n\tPREAD(pwm3_auto_zone_assigned, 2, PRI_LOW, 0, 0, 0x03, 6, bitmask),\n\n\tPWRITE(pwm1_auto_spinup_time, 0, PRI_LOW, 0x5c, 0, 0x07, 0, pwm_ast),\n\tPWRITE(pwm2_auto_spinup_time, 1, PRI_LOW, 0x5d, 0, 0x07, 0, pwm_ast),\n\tPWRITE(pwm3_auto_spinup_time, 2, PRI_LOW, 0x5e, 0, 0x07, 0, pwm_ast),\n\n\tPWRITE(peci_enable, 0, PRI_LOW, 0x40, 0, 0x01, 4, bitmask),\n\tPWRITE(peci_avg, 0, PRI_LOW, 0x36, 0, 0x07, 0, bitmask),\n\tPWRITE(peci_domain, 0, PRI_LOW, 0x36, 0, 0x01, 3, bitmask),\n\tPWRITE(peci_legacy, 0, PRI_LOW, 0x36, 0, 0x01, 4, bitmask),\n\tPWRITE(peci_diode, 0, PRI_LOW, 0x0e, 0, 0x07, 4, bitmask),\n\tPWRITE(peci_4domain, 0, PRI_LOW, 0x0e, 0, 0x01, 4, bitmask),\n\n};\n\nstatic struct asc7621_data *asc7621_update_device(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct asc7621_data *data = i2c_get_clientdata(client);\n\tint i;\n\n \n\n\tmutex_lock(&data->update_lock);\n\n\t \n\n\tif (!data->valid ||\n\t    time_after(jiffies, data->last_high_reading + INTERVAL_HIGH)) {\n\n\t\tfor (i = 0; i < ARRAY_SIZE(asc7621_register_priorities); i++) {\n\t\t\tif (asc7621_register_priorities[i] == PRI_HIGH) {\n\t\t\t\tdata->reg[i] =\n\t\t\t\t    i2c_smbus_read_byte_data(client, i) & 0xff;\n\t\t\t}\n\t\t}\n\t\tdata->last_high_reading = jiffies;\n\t}\t\t\t \n\n\t \n\n\tif (!data->valid ||\n\t    time_after(jiffies, data->last_low_reading + INTERVAL_LOW)) {\n\n\t\tfor (i = 0; i < ARRAY_SIZE(asc7621_params); i++) {\n\t\t\tif (asc7621_register_priorities[i] == PRI_LOW) {\n\t\t\t\tdata->reg[i] =\n\t\t\t\t    i2c_smbus_read_byte_data(client, i) & 0xff;\n\t\t\t}\n\t\t}\n\t\tdata->last_low_reading = jiffies;\n\t}\t\t\t \n\n\tdata->valid = true;\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \n\nstatic inline int valid_address_for_chip(int chip_type, int address)\n{\n\tint i;\n\n\tfor (i = 0; asc7621_chips[chip_type].addresses[i] != I2C_CLIENT_END;\n\t     i++) {\n\t\tif (asc7621_chips[chip_type].addresses[i] == address)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void asc7621_init_client(struct i2c_client *client)\n{\n\tint value;\n\n\t \n\n\tvalue = read_byte(client, 0x40);\n\n\tif (value & 0x02) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Client (%d,0x%02x) config is locked.\\n\",\n\t\t\ti2c_adapter_id(client->adapter), client->addr);\n\t}\n\tif (!(value & 0x04)) {\n\t\tdev_err(&client->dev, \"Client (%d,0x%02x) is not ready.\\n\",\n\t\t\ti2c_adapter_id(client->adapter), client->addr);\n\t}\n\n \n\tvalue = (value & ~0x02) | 0x01;\n\twrite_byte(client, 0x40, value & 0xff);\n\n}\n\nstatic int\nasc7621_probe(struct i2c_client *client)\n{\n\tstruct asc7621_data *data;\n\tint i, err;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct asc7621_data),\n\t\t\t    GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\n\t \n\tasc7621_init_client(client);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(asc7621_params); i++) {\n\t\terr =\n\t\t    device_create_file(&client->dev,\n\t\t\t\t       &(asc7621_params[i].sda.dev_attr));\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\t}\n\n\tdata->class_dev = hwmon_device_register(&client->dev);\n\tif (IS_ERR(data->class_dev)) {\n\t\terr = PTR_ERR(data->class_dev);\n\t\tgoto exit_remove;\n\t}\n\n\treturn 0;\n\nexit_remove:\n\tfor (i = 0; i < ARRAY_SIZE(asc7621_params); i++) {\n\t\tdevice_remove_file(&client->dev,\n\t\t\t\t   &(asc7621_params[i].sda.dev_attr));\n\t}\n\n\treturn err;\n}\n\nstatic int asc7621_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint company, verstep, chip_index;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tfor (chip_index = FIRST_CHIP; chip_index <= LAST_CHIP; chip_index++) {\n\n\t\tif (!valid_address_for_chip(chip_index, client->addr))\n\t\t\tcontinue;\n\n\t\tcompany = read_byte(client,\n\t\t\tasc7621_chips[chip_index].company_reg);\n\t\tverstep = read_byte(client,\n\t\t\tasc7621_chips[chip_index].verstep_reg);\n\n\t\tif (company == asc7621_chips[chip_index].company_id &&\n\t\t    verstep == asc7621_chips[chip_index].verstep_id) {\n\t\t\tstrscpy(info->type, asc7621_chips[chip_index].name,\n\t\t\t\tI2C_NAME_SIZE);\n\n\t\t\tdev_info(&adapter->dev, \"Matched %s at 0x%02x\\n\",\n\t\t\t\t asc7621_chips[chip_index].name, client->addr);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic void asc7621_remove(struct i2c_client *client)\n{\n\tstruct asc7621_data *data = i2c_get_clientdata(client);\n\tint i;\n\n\thwmon_device_unregister(data->class_dev);\n\n\tfor (i = 0; i < ARRAY_SIZE(asc7621_params); i++) {\n\t\tdevice_remove_file(&client->dev,\n\t\t\t\t   &(asc7621_params[i].sda.dev_attr));\n\t}\n}\n\nstatic const struct i2c_device_id asc7621_id[] = {\n\t{\"asc7621\", asc7621},\n\t{\"asc7621a\", asc7621a},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, asc7621_id);\n\nstatic struct i2c_driver asc7621_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"asc7621\",\n\t},\n\t.probe = asc7621_probe,\n\t.remove = asc7621_remove,\n\t.id_table = asc7621_id,\n\t.detect = asc7621_detect,\n\t.address_list = normal_i2c,\n};\n\nstatic int __init sm_asc7621_init(void)\n{\n\tint i, j;\n \n\n\tfor (i = 0; i < ARRAY_SIZE(asc7621_params); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(asc7621_params[i].msb); j++)\n\t\t\tasc7621_register_priorities[asc7621_params[i].msb[j]] =\n\t\t\t    asc7621_params[i].priority;\n\t\tfor (j = 0; j < ARRAY_SIZE(asc7621_params[i].lsb); j++)\n\t\t\tasc7621_register_priorities[asc7621_params[i].lsb[j]] =\n\t\t\t    asc7621_params[i].priority;\n\t}\n\treturn i2c_add_driver(&asc7621_driver);\n}\n\nstatic void __exit sm_asc7621_exit(void)\n{\n\ti2c_del_driver(&asc7621_driver);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"George Joseph\");\nMODULE_DESCRIPTION(\"Andigilog aSC7621 and aSC7621a driver\");\n\nmodule_init(sm_asc7621_init);\nmodule_exit(sm_asc7621_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}