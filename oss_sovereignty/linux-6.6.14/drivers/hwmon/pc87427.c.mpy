{
  "module_name": "pc87427.c",
  "hash_id": "cfa7abaf48f32150d9f141ede9681177af2bbb7613009941fa508f2291a45705",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pc87427.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/ioport.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\nstatic unsigned short force_id;\nmodule_param(force_id, ushort, 0);\nMODULE_PARM_DESC(force_id, \"Override the detected device ID\");\n\nstatic struct platform_device *pdev;\n\n#define DRVNAME \"pc87427\"\n\n \nstruct pc87427_data {\n\tstruct device *hwmon_dev;\n\tstruct mutex lock;\n\tint address[2];\n\tconst char *name;\n\n\tunsigned long last_updated;\t \n\tu8 fan_enabled;\t\t\t \n\tu16 fan[8];\t\t\t \n\tu16 fan_min[8];\t\t\t \n\tu8 fan_status[8];\t\t \n\n\tu8 pwm_enabled;\t\t\t \n\tu8 pwm_auto_ok;\t\t\t \n\tu8 pwm_enable[4];\t\t \n\tu8 pwm[4];\t\t\t \n\n\tu8 temp_enabled;\t\t \n\ts16 temp[6];\t\t\t \n\ts8 temp_min[6];\t\t\t \n\ts8 temp_max[6];\t\t\t \n\ts8 temp_crit[6];\t\t \n\tu8 temp_status[6];\t\t \n\tu8 temp_type[6];\t\t \n};\n\nstruct pc87427_sio_data {\n\tunsigned short address[2];\n\tu8 has_fanin;\n\tu8 has_fanout;\n};\n\n \n\n#define SIOREG_LDSEL\t0x07\t \n#define SIOREG_DEVID\t0x20\t \n#define SIOREG_CF2\t0x22\t \n#define SIOREG_CF3\t0x23\t \n#define SIOREG_CF4\t0x24\t \n#define SIOREG_CF5\t0x25\t \n#define SIOREG_CFB\t0x2B\t \n#define SIOREG_CFC\t0x2C\t \n#define SIOREG_CFD\t0x2D\t \n#define SIOREG_ACT\t0x30\t \n#define SIOREG_MAP\t0x50\t \n#define SIOREG_IOBASE\t0x60\t \n\nstatic const u8 logdev[2] = { 0x09, 0x14 };\nstatic const char *logdev_str[2] = { DRVNAME \" FMC\", DRVNAME \" HMC\" };\n#define LD_FAN\t\t0\n#define LD_IN\t\t1\n#define LD_TEMP\t\t1\n\nstatic inline int superio_enter(int sioaddr)\n{\n\tif (!request_muxed_region(sioaddr, 2, DRVNAME))\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic inline void superio_outb(int sioaddr, int reg, int val)\n{\n\toutb(reg, sioaddr);\n\toutb(val, sioaddr + 1);\n}\n\nstatic inline int superio_inb(int sioaddr, int reg)\n{\n\toutb(reg, sioaddr);\n\treturn inb(sioaddr + 1);\n}\n\nstatic inline void superio_exit(int sioaddr)\n{\n\toutb(0x02, sioaddr);\n\toutb(0x02, sioaddr + 1);\n\trelease_region(sioaddr, 2);\n}\n\n \n\n#define REGION_LENGTH\t\t32\n#define PC87427_REG_BANK\t0x0f\n#define BANK_FM(nr)\t\t(nr)\n#define BANK_FT(nr)\t\t(0x08 + (nr))\n#define BANK_FC(nr)\t\t(0x10 + (nr) * 2)\n#define BANK_TM(nr)\t\t(nr)\n#define BANK_VM(nr)\t\t(0x08 + (nr))\n\n \n\n \nstatic inline int pc87427_read8(struct pc87427_data *data, u8 ldi, u8 reg)\n{\n\treturn inb(data->address[ldi] + reg);\n}\n\n \nstatic inline int pc87427_read8_bank(struct pc87427_data *data, u8 ldi,\n\t\t\t\t     u8 bank, u8 reg)\n{\n\toutb(bank, data->address[ldi] + PC87427_REG_BANK);\n\treturn inb(data->address[ldi] + reg);\n}\n\n \nstatic inline void pc87427_write8_bank(struct pc87427_data *data, u8 ldi,\n\t\t\t\t       u8 bank, u8 reg, u8 value)\n{\n\toutb(bank, data->address[ldi] + PC87427_REG_BANK);\n\toutb(value, data->address[ldi] + reg);\n}\n\n \n\n \n#define PC87427_REG_FAN\t\t\t0x12\n#define PC87427_REG_FAN_MIN\t\t0x14\n#define PC87427_REG_FAN_STATUS\t\t0x10\n\n#define FAN_STATUS_STALL\t\t(1 << 3)\n#define FAN_STATUS_LOSPD\t\t(1 << 1)\n#define FAN_STATUS_MONEN\t\t(1 << 0)\n\n \nstatic void pc87427_readall_fan(struct pc87427_data *data, u8 nr)\n{\n\tint iobase = data->address[LD_FAN];\n\n\toutb(BANK_FM(nr), iobase + PC87427_REG_BANK);\n\tdata->fan[nr] = inw(iobase + PC87427_REG_FAN);\n\tdata->fan_min[nr] = inw(iobase + PC87427_REG_FAN_MIN);\n\tdata->fan_status[nr] = inb(iobase + PC87427_REG_FAN_STATUS);\n\t \n\toutb(data->fan_status[nr], iobase + PC87427_REG_FAN_STATUS);\n}\n\n \nstatic inline unsigned long fan_from_reg(u16 reg)\n{\n\treg &= 0xfffc;\n\tif (reg == 0x0000 || reg == 0xfffc)\n\t\treturn 0;\n\treturn 5400000UL / reg;\n}\n\n \nstatic inline u16 fan_to_reg(unsigned long val)\n{\n\tif (val < 83UL)\n\t\treturn 0xffff;\n\tif (val >= 1350000UL)\n\t\treturn 0x0004;\n\treturn ((1350000UL + val / 2) / val) << 2;\n}\n\n \n\n#define PC87427_REG_PWM_ENABLE\t\t0x10\n#define PC87427_REG_PWM_DUTY\t\t0x12\n\n#define PWM_ENABLE_MODE_MASK\t\t(7 << 4)\n#define PWM_ENABLE_CTLEN\t\t(1 << 0)\n\n#define PWM_MODE_MANUAL\t\t\t(0 << 4)\n#define PWM_MODE_AUTO\t\t\t(1 << 4)\n#define PWM_MODE_OFF\t\t\t(2 << 4)\n#define PWM_MODE_ON\t\t\t(7 << 4)\n\n \nstatic void pc87427_readall_pwm(struct pc87427_data *data, u8 nr)\n{\n\tint iobase = data->address[LD_FAN];\n\n\toutb(BANK_FC(nr), iobase + PC87427_REG_BANK);\n\tdata->pwm_enable[nr] = inb(iobase + PC87427_REG_PWM_ENABLE);\n\tdata->pwm[nr] = inb(iobase + PC87427_REG_PWM_DUTY);\n}\n\nstatic inline int pwm_enable_from_reg(u8 reg)\n{\n\tswitch (reg & PWM_ENABLE_MODE_MASK) {\n\tcase PWM_MODE_ON:\n\t\treturn 0;\n\tcase PWM_MODE_MANUAL:\n\tcase PWM_MODE_OFF:\n\t\treturn 1;\n\tcase PWM_MODE_AUTO:\n\t\treturn 2;\n\tdefault:\n\t\treturn -EPROTO;\n\t}\n}\n\nstatic inline u8 pwm_enable_to_reg(unsigned long val, u8 pwmval)\n{\n\tswitch (val) {\n\tdefault:\n\t\treturn PWM_MODE_ON;\n\tcase 1:\n\t\treturn pwmval ? PWM_MODE_MANUAL : PWM_MODE_OFF;\n\tcase 2:\n\t\treturn PWM_MODE_AUTO;\n\t}\n}\n\n \n\n#define PC87427_REG_TEMP_STATUS\t\t0x10\n#define PC87427_REG_TEMP\t\t0x14\n#define PC87427_REG_TEMP_MAX\t\t0x18\n#define PC87427_REG_TEMP_MIN\t\t0x19\n#define PC87427_REG_TEMP_CRIT\t\t0x1a\n#define PC87427_REG_TEMP_TYPE\t\t0x1d\n\n#define TEMP_STATUS_CHANEN\t\t(1 << 0)\n#define TEMP_STATUS_LOWFLG\t\t(1 << 1)\n#define TEMP_STATUS_HIGHFLG\t\t(1 << 2)\n#define TEMP_STATUS_CRITFLG\t\t(1 << 3)\n#define TEMP_STATUS_SENSERR\t\t(1 << 5)\n#define TEMP_TYPE_MASK\t\t\t(3 << 5)\n\n#define TEMP_TYPE_THERMISTOR\t\t(1 << 5)\n#define TEMP_TYPE_REMOTE_DIODE\t\t(2 << 5)\n#define TEMP_TYPE_LOCAL_DIODE\t\t(3 << 5)\n\n \nstatic void pc87427_readall_temp(struct pc87427_data *data, u8 nr)\n{\n\tint iobase = data->address[LD_TEMP];\n\n\toutb(BANK_TM(nr), iobase + PC87427_REG_BANK);\n\tdata->temp[nr] = le16_to_cpu(inw(iobase + PC87427_REG_TEMP));\n\tdata->temp_max[nr] = inb(iobase + PC87427_REG_TEMP_MAX);\n\tdata->temp_min[nr] = inb(iobase + PC87427_REG_TEMP_MIN);\n\tdata->temp_crit[nr] = inb(iobase + PC87427_REG_TEMP_CRIT);\n\tdata->temp_type[nr] = inb(iobase + PC87427_REG_TEMP_TYPE);\n\tdata->temp_status[nr] = inb(iobase + PC87427_REG_TEMP_STATUS);\n\t \n\toutb(data->temp_status[nr], iobase + PC87427_REG_TEMP_STATUS);\n}\n\nstatic inline unsigned int temp_type_from_reg(u8 reg)\n{\n\tswitch (reg & TEMP_TYPE_MASK) {\n\tcase TEMP_TYPE_THERMISTOR:\n\t\treturn 4;\n\tcase TEMP_TYPE_REMOTE_DIODE:\n\tcase TEMP_TYPE_LOCAL_DIODE:\n\t\treturn 3;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic inline long temp_from_reg(s16 reg)\n{\n\treturn reg * 1000 / 256;\n}\n\nstatic inline long temp_from_reg8(s8 reg)\n{\n\treturn reg * 1000;\n}\n\n \n\nstatic struct pc87427_data *pc87427_update_device(struct device *dev)\n{\n\tstruct pc87427_data *data = dev_get_drvdata(dev);\n\tint i;\n\n\tmutex_lock(&data->lock);\n\tif (!time_after(jiffies, data->last_updated + HZ)\n\t && data->last_updated)\n\t\tgoto done;\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tif (!(data->fan_enabled & (1 << i)))\n\t\t\tcontinue;\n\t\tpc87427_readall_fan(data, i);\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (!(data->pwm_enabled & (1 << i)))\n\t\t\tcontinue;\n\t\tpc87427_readall_pwm(data, i);\n\t}\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tif (!(data->temp_enabled & (1 << i)))\n\t\t\tcontinue;\n\t\tpc87427_readall_temp(data, i);\n\t}\n\n\tdata->last_updated = jiffies;\n\ndone:\n\tmutex_unlock(&data->lock);\n\treturn data;\n}\n\nstatic ssize_t fan_input_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%lu\\n\", fan_from_reg(data->fan[nr]));\n}\n\nstatic ssize_t fan_min_show(struct device *dev,\n\t\t\t    struct device_attribute *devattr, char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%lu\\n\", fan_from_reg(data->fan_min[nr]));\n}\n\nstatic ssize_t fan_alarm_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%d\\n\", !!(data->fan_status[nr]\n\t\t\t\t       & FAN_STATUS_LOSPD));\n}\n\nstatic ssize_t fan_fault_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%d\\n\", !!(data->fan_status[nr]\n\t\t\t\t       & FAN_STATUS_STALL));\n}\n\nstatic ssize_t fan_min_store(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct pc87427_data *data = dev_get_drvdata(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tunsigned long val;\n\tint iobase = data->address[LD_FAN];\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\toutb(BANK_FM(nr), iobase + PC87427_REG_BANK);\n\t \n\toutb(0, iobase + PC87427_REG_FAN_STATUS);\n\tdata->fan_min[nr] = fan_to_reg(val);\n\toutw(data->fan_min[nr], iobase + PC87427_REG_FAN_MIN);\n\toutb(FAN_STATUS_MONEN, iobase + PC87427_REG_FAN_STATUS);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan_input, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan_input, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_input, fan_input, 2);\nstatic SENSOR_DEVICE_ATTR_RO(fan4_input, fan_input, 3);\nstatic SENSOR_DEVICE_ATTR_RO(fan5_input, fan_input, 4);\nstatic SENSOR_DEVICE_ATTR_RO(fan6_input, fan_input, 5);\nstatic SENSOR_DEVICE_ATTR_RO(fan7_input, fan_input, 6);\nstatic SENSOR_DEVICE_ATTR_RO(fan8_input, fan_input, 7);\n\nstatic SENSOR_DEVICE_ATTR_RW(fan1_min, fan_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_min, fan_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan3_min, fan_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(fan4_min, fan_min, 3);\nstatic SENSOR_DEVICE_ATTR_RW(fan5_min, fan_min, 4);\nstatic SENSOR_DEVICE_ATTR_RW(fan6_min, fan_min, 5);\nstatic SENSOR_DEVICE_ATTR_RW(fan7_min, fan_min, 6);\nstatic SENSOR_DEVICE_ATTR_RW(fan8_min, fan_min, 7);\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_alarm, fan_alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_alarm, fan_alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_alarm, fan_alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(fan4_alarm, fan_alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(fan5_alarm, fan_alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(fan6_alarm, fan_alarm, 5);\nstatic SENSOR_DEVICE_ATTR_RO(fan7_alarm, fan_alarm, 6);\nstatic SENSOR_DEVICE_ATTR_RO(fan8_alarm, fan_alarm, 7);\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_fault, fan_fault, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_fault, fan_fault, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_fault, fan_fault, 2);\nstatic SENSOR_DEVICE_ATTR_RO(fan4_fault, fan_fault, 3);\nstatic SENSOR_DEVICE_ATTR_RO(fan5_fault, fan_fault, 4);\nstatic SENSOR_DEVICE_ATTR_RO(fan6_fault, fan_fault, 5);\nstatic SENSOR_DEVICE_ATTR_RO(fan7_fault, fan_fault, 6);\nstatic SENSOR_DEVICE_ATTR_RO(fan8_fault, fan_fault, 7);\n\nstatic struct attribute *pc87427_attributes_fan[8][5] = {\n\t{\n\t\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_fan1_fault.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_fan2_fault.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t\t&sensor_dev_attr_fan3_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_fan3_fault.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_fan4_input.dev_attr.attr,\n\t\t&sensor_dev_attr_fan4_min.dev_attr.attr,\n\t\t&sensor_dev_attr_fan4_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_fan4_fault.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_fan5_input.dev_attr.attr,\n\t\t&sensor_dev_attr_fan5_min.dev_attr.attr,\n\t\t&sensor_dev_attr_fan5_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_fan5_fault.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_fan6_input.dev_attr.attr,\n\t\t&sensor_dev_attr_fan6_min.dev_attr.attr,\n\t\t&sensor_dev_attr_fan6_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_fan6_fault.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_fan7_input.dev_attr.attr,\n\t\t&sensor_dev_attr_fan7_min.dev_attr.attr,\n\t\t&sensor_dev_attr_fan7_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_fan7_fault.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_fan8_input.dev_attr.attr,\n\t\t&sensor_dev_attr_fan8_min.dev_attr.attr,\n\t\t&sensor_dev_attr_fan8_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_fan8_fault.dev_attr.attr,\n\t\tNULL\n\t}\n};\n\nstatic const struct attribute_group pc87427_group_fan[8] = {\n\t{ .attrs = pc87427_attributes_fan[0] },\n\t{ .attrs = pc87427_attributes_fan[1] },\n\t{ .attrs = pc87427_attributes_fan[2] },\n\t{ .attrs = pc87427_attributes_fan[3] },\n\t{ .attrs = pc87427_attributes_fan[4] },\n\t{ .attrs = pc87427_attributes_fan[5] },\n\t{ .attrs = pc87427_attributes_fan[6] },\n\t{ .attrs = pc87427_attributes_fan[7] },\n};\n\n \nstatic void update_pwm_enable(struct pc87427_data *data, int nr, u8 mode)\n{\n\tint iobase = data->address[LD_FAN];\n\tdata->pwm_enable[nr] &= ~PWM_ENABLE_MODE_MASK;\n\tdata->pwm_enable[nr] |= mode;\n\toutb(data->pwm_enable[nr], iobase + PC87427_REG_PWM_ENABLE);\n}\n\nstatic ssize_t pwm_enable_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tint pwm_enable;\n\n\tpwm_enable = pwm_enable_from_reg(data->pwm_enable[nr]);\n\tif (pwm_enable < 0)\n\t\treturn pwm_enable;\n\treturn sprintf(buf, \"%d\\n\", pwm_enable);\n}\n\nstatic ssize_t pwm_enable_store(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct pc87427_data *data = dev_get_drvdata(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val) < 0 || val > 2)\n\t\treturn -EINVAL;\n\t \n\tif (val == 2 && !(data->pwm_auto_ok & (1 << nr)))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\tpc87427_readall_pwm(data, nr);\n\tupdate_pwm_enable(data, nr, pwm_enable_to_reg(val, data->pwm[nr]));\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t pwm_show(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%d\\n\", (int)data->pwm[nr]);\n}\n\nstatic ssize_t pwm_store(struct device *dev, struct device_attribute *devattr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct pc87427_data *data = dev_get_drvdata(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tunsigned long val;\n\tint iobase = data->address[LD_FAN];\n\tu8 mode;\n\n\tif (kstrtoul(buf, 10, &val) < 0 || val > 0xff)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\tpc87427_readall_pwm(data, nr);\n\tmode = data->pwm_enable[nr] & PWM_ENABLE_MODE_MASK;\n\tif (mode != PWM_MODE_MANUAL && mode != PWM_MODE_OFF) {\n\t\tdev_notice(dev,\n\t\t\t   \"Can't set PWM%d duty cycle while not in manual mode\\n\",\n\t\t\t   nr + 1);\n\t\tmutex_unlock(&data->lock);\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (mode == PWM_MODE_MANUAL && val == 0) {\n\t\t \n\t\tupdate_pwm_enable(data, nr, PWM_MODE_OFF);\n\t\tmode = PWM_MODE_OFF;\n\t\tdev_dbg(dev, \"Switching PWM%d from %s to %s\\n\", nr + 1,\n\t\t\t\"manual\", \"off\");\n\t} else if (mode == PWM_MODE_OFF && val != 0) {\n\t\t \n\t\tupdate_pwm_enable(data, nr, PWM_MODE_MANUAL);\n\t\tmode = PWM_MODE_MANUAL;\n\t\tdev_dbg(dev, \"Switching PWM%d from %s to %s\\n\", nr + 1,\n\t\t\t\"off\", \"manual\");\n\t}\n\n\tdata->pwm[nr] = val;\n\tif (mode == PWM_MODE_MANUAL)\n\t\toutb(val, iobase + PC87427_REG_PWM_DUTY);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_enable, pwm_enable, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_enable, pwm_enable, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_enable, pwm_enable, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm4_enable, pwm_enable, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1, pwm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2, pwm, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3, pwm, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm4, pwm, 3);\n\nstatic struct attribute *pc87427_attributes_pwm[4][3] = {\n\t{\n\t\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\t\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_pwm4_enable.dev_attr.attr,\n\t\t&sensor_dev_attr_pwm4.dev_attr.attr,\n\t\tNULL\n\t}\n};\n\nstatic const struct attribute_group pc87427_group_pwm[4] = {\n\t{ .attrs = pc87427_attributes_pwm[0] },\n\t{ .attrs = pc87427_attributes_pwm[1] },\n\t{ .attrs = pc87427_attributes_pwm[2] },\n\t{ .attrs = pc87427_attributes_pwm[3] },\n};\n\nstatic ssize_t temp_input_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%ld\\n\", temp_from_reg(data->temp[nr]));\n}\n\nstatic ssize_t temp_min_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%ld\\n\", temp_from_reg8(data->temp_min[nr]));\n}\n\nstatic ssize_t temp_max_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%ld\\n\", temp_from_reg8(data->temp_max[nr]));\n}\n\nstatic ssize_t temp_crit_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%ld\\n\", temp_from_reg8(data->temp_crit[nr]));\n}\n\nstatic ssize_t temp_type_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%u\\n\", temp_type_from_reg(data->temp_type[nr]));\n}\n\nstatic ssize_t temp_min_alarm_show(struct device *dev,\n\t\t\t\t   struct device_attribute *devattr,\n\t\t\t\t   char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%d\\n\", !!(data->temp_status[nr]\n\t\t\t\t       & TEMP_STATUS_LOWFLG));\n}\n\nstatic ssize_t temp_max_alarm_show(struct device *dev,\n\t\t\t\t   struct device_attribute *devattr,\n\t\t\t\t   char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%d\\n\", !!(data->temp_status[nr]\n\t\t\t\t       & TEMP_STATUS_HIGHFLG));\n}\n\nstatic ssize_t temp_crit_alarm_show(struct device *dev,\n\t\t\t\t    struct device_attribute *devattr,\n\t\t\t\t    char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%d\\n\", !!(data->temp_status[nr]\n\t\t\t\t       & TEMP_STATUS_CRITFLG));\n}\n\nstatic ssize_t temp_fault_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tstruct pc87427_data *data = pc87427_update_device(dev);\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\n\treturn sprintf(buf, \"%d\\n\", !!(data->temp_status[nr]\n\t\t\t\t       & TEMP_STATUS_SENSERR));\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp_input, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp_input, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp_input, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_input, temp_input, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp5_input, temp_input, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp6_input, temp_input, 5);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min, temp_min, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_min, temp_min, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_min, temp_min, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_min, temp_min, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp5_min, temp_min, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp6_min, temp_min, 5);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max, temp_max, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_max, temp_max, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_max, temp_max, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_max, temp_max, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp5_max, temp_max, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp6_max, temp_max, 5);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_crit, temp_crit, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_crit, temp_crit, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_crit, temp_crit, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_crit, temp_crit, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp5_crit, temp_crit, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp6_crit, temp_crit, 5);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_type, temp_type, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_type, temp_type, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_type, temp_type, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_type, temp_type, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp5_type, temp_type, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp6_type, temp_type, 5);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_alarm, temp_min_alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_min_alarm, temp_min_alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_min_alarm, temp_min_alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_min_alarm, temp_min_alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp5_min_alarm, temp_min_alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp6_min_alarm, temp_min_alarm, 5);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, temp_max_alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_max_alarm, temp_max_alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_max_alarm, temp_max_alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_max_alarm, temp_max_alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp5_max_alarm, temp_max_alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp6_max_alarm, temp_max_alarm, 5);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_crit_alarm, temp_crit_alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_crit_alarm, temp_crit_alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_crit_alarm, temp_crit_alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_crit_alarm, temp_crit_alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp5_crit_alarm, temp_crit_alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp6_crit_alarm, temp_crit_alarm, 5);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_fault, temp_fault, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_fault, temp_fault, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_fault, temp_fault, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_fault, temp_fault, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp5_fault, temp_fault, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp6_fault, temp_fault, 5);\n\nstatic struct attribute *pc87427_attributes_temp[6][10] = {\n\t{\n\t\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t\t&sensor_dev_attr_temp1_type.dev_attr.attr,\n\t\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp1_crit_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp1_fault.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t\t&sensor_dev_attr_temp2_crit.dev_attr.attr,\n\t\t&sensor_dev_attr_temp2_type.dev_attr.attr,\n\t\t&sensor_dev_attr_temp2_min_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp2_crit_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t\t&sensor_dev_attr_temp3_crit.dev_attr.attr,\n\t\t&sensor_dev_attr_temp3_type.dev_attr.attr,\n\t\t&sensor_dev_attr_temp3_min_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp3_max_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp3_crit_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp3_fault.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_temp4_input.dev_attr.attr,\n\t\t&sensor_dev_attr_temp4_min.dev_attr.attr,\n\t\t&sensor_dev_attr_temp4_max.dev_attr.attr,\n\t\t&sensor_dev_attr_temp4_crit.dev_attr.attr,\n\t\t&sensor_dev_attr_temp4_type.dev_attr.attr,\n\t\t&sensor_dev_attr_temp4_min_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp4_max_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp4_crit_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp4_fault.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_temp5_input.dev_attr.attr,\n\t\t&sensor_dev_attr_temp5_min.dev_attr.attr,\n\t\t&sensor_dev_attr_temp5_max.dev_attr.attr,\n\t\t&sensor_dev_attr_temp5_crit.dev_attr.attr,\n\t\t&sensor_dev_attr_temp5_type.dev_attr.attr,\n\t\t&sensor_dev_attr_temp5_min_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp5_max_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp5_crit_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp5_fault.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_temp6_input.dev_attr.attr,\n\t\t&sensor_dev_attr_temp6_min.dev_attr.attr,\n\t\t&sensor_dev_attr_temp6_max.dev_attr.attr,\n\t\t&sensor_dev_attr_temp6_crit.dev_attr.attr,\n\t\t&sensor_dev_attr_temp6_type.dev_attr.attr,\n\t\t&sensor_dev_attr_temp6_min_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp6_max_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp6_crit_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_temp6_fault.dev_attr.attr,\n\t\tNULL\n\t}\n};\n\nstatic const struct attribute_group pc87427_group_temp[6] = {\n\t{ .attrs = pc87427_attributes_temp[0] },\n\t{ .attrs = pc87427_attributes_temp[1] },\n\t{ .attrs = pc87427_attributes_temp[2] },\n\t{ .attrs = pc87427_attributes_temp[3] },\n\t{ .attrs = pc87427_attributes_temp[4] },\n\t{ .attrs = pc87427_attributes_temp[5] },\n};\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute\n\t\t\t *devattr, char *buf)\n{\n\tstruct pc87427_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", data->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\n\n \n\nstatic int pc87427_request_regions(struct platform_device *pdev,\n\t\t\t\t\t     int count)\n{\n\tstruct resource *res;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tres = platform_get_resource(pdev, IORESOURCE_IO, i);\n\t\tif (!res) {\n\t\t\tdev_err(&pdev->dev, \"Missing resource #%d\\n\", i);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (!devm_request_region(&pdev->dev, res->start,\n\t\t\t\t\t resource_size(res), DRVNAME)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to request region 0x%lx-0x%lx\\n\",\n\t\t\t\t(unsigned long)res->start,\n\t\t\t\t(unsigned long)res->end);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void pc87427_init_device(struct device *dev)\n{\n\tstruct pc87427_sio_data *sio_data = dev_get_platdata(dev);\n\tstruct pc87427_data *data = dev_get_drvdata(dev);\n\tint i;\n\tu8 reg;\n\n\t \n\treg = pc87427_read8(data, LD_FAN, PC87427_REG_BANK);\n\tif (!(reg & 0x80))\n\t\tdev_warn(dev, \"%s module not ready!\\n\", \"FMC\");\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tif (!(sio_data->has_fanin & (1 << i)))\t \n\t\t\tcontinue;\n\t\treg = pc87427_read8_bank(data, LD_FAN, BANK_FM(i),\n\t\t\t\t\t PC87427_REG_FAN_STATUS);\n\t\tif (reg & FAN_STATUS_MONEN)\n\t\t\tdata->fan_enabled |= (1 << i);\n\t}\n\n\tif (!data->fan_enabled) {\n\t\tdev_dbg(dev, \"Enabling monitoring of all fans\\n\");\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (!(sio_data->has_fanin & (1 << i)))\t \n\t\t\t\tcontinue;\n\t\t\tpc87427_write8_bank(data, LD_FAN, BANK_FM(i),\n\t\t\t\t\t    PC87427_REG_FAN_STATUS,\n\t\t\t\t\t    FAN_STATUS_MONEN);\n\t\t}\n\t\tdata->fan_enabled = sio_data->has_fanin;\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (!(sio_data->has_fanout & (1 << i)))\t \n\t\t\tcontinue;\n\t\treg = pc87427_read8_bank(data, LD_FAN, BANK_FC(i),\n\t\t\t\t\t PC87427_REG_PWM_ENABLE);\n\t\tif (reg & PWM_ENABLE_CTLEN)\n\t\t\tdata->pwm_enabled |= (1 << i);\n\n\t\t \n\t\tif ((reg & PWM_ENABLE_MODE_MASK) == PWM_MODE_AUTO) {\n\t\t\tdev_dbg(dev, \"PWM%d is in automatic control mode\\n\",\n\t\t\t\ti + 1);\n\t\t\tdata->pwm_auto_ok |= (1 << i);\n\t\t}\n\t}\n\n\t \n\treg = pc87427_read8(data, LD_TEMP, PC87427_REG_BANK);\n\tif (!(reg & 0x80))\n\t\tdev_warn(dev, \"%s module not ready!\\n\", \"HMC\");\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\treg = pc87427_read8_bank(data, LD_TEMP, BANK_TM(i),\n\t\t\t\t\t PC87427_REG_TEMP_STATUS);\n\t\tif (reg & TEMP_STATUS_CHANEN)\n\t\t\tdata->temp_enabled |= (1 << i);\n\t}\n}\n\nstatic void pc87427_remove_files(struct device *dev)\n{\n\tstruct pc87427_data *data = dev_get_drvdata(dev);\n\tint i;\n\n\tdevice_remove_file(dev, &dev_attr_name);\n\tfor (i = 0; i < 8; i++) {\n\t\tif (!(data->fan_enabled & (1 << i)))\n\t\t\tcontinue;\n\t\tsysfs_remove_group(&dev->kobj, &pc87427_group_fan[i]);\n\t}\n\tfor (i = 0; i < 4; i++) {\n\t\tif (!(data->pwm_enabled & (1 << i)))\n\t\t\tcontinue;\n\t\tsysfs_remove_group(&dev->kobj, &pc87427_group_pwm[i]);\n\t}\n\tfor (i = 0; i < 6; i++) {\n\t\tif (!(data->temp_enabled & (1 << i)))\n\t\t\tcontinue;\n\t\tsysfs_remove_group(&dev->kobj, &pc87427_group_temp[i]);\n\t}\n}\n\nstatic int pc87427_probe(struct platform_device *pdev)\n{\n\tstruct pc87427_sio_data *sio_data = dev_get_platdata(&pdev->dev);\n\tstruct pc87427_data *data;\n\tint i, err, res_count;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct pc87427_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->address[0] = sio_data->address[0];\n\tdata->address[1] = sio_data->address[1];\n\tres_count = (data->address[0] != 0) + (data->address[1] != 0);\n\n\terr = pc87427_request_regions(pdev, res_count);\n\tif (err)\n\t\treturn err;\n\n\tmutex_init(&data->lock);\n\tdata->name = \"pc87427\";\n\tplatform_set_drvdata(pdev, data);\n\tpc87427_init_device(&pdev->dev);\n\n\t \n\terr = device_create_file(&pdev->dev, &dev_attr_name);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (!(data->fan_enabled & (1 << i)))\n\t\t\tcontinue;\n\t\terr = sysfs_create_group(&pdev->dev.kobj,\n\t\t\t\t\t &pc87427_group_fan[i]);\n\t\tif (err)\n\t\t\tgoto exit_remove_files;\n\t}\n\tfor (i = 0; i < 4; i++) {\n\t\tif (!(data->pwm_enabled & (1 << i)))\n\t\t\tcontinue;\n\t\terr = sysfs_create_group(&pdev->dev.kobj,\n\t\t\t\t\t &pc87427_group_pwm[i]);\n\t\tif (err)\n\t\t\tgoto exit_remove_files;\n\t}\n\tfor (i = 0; i < 6; i++) {\n\t\tif (!(data->temp_enabled & (1 << i)))\n\t\t\tcontinue;\n\t\terr = sysfs_create_group(&pdev->dev.kobj,\n\t\t\t\t\t &pc87427_group_temp[i]);\n\t\tif (err)\n\t\t\tgoto exit_remove_files;\n\t}\n\n\tdata->hwmon_dev = hwmon_device_register(&pdev->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tdev_err(&pdev->dev, \"Class registration failed (%d)\\n\", err);\n\t\tgoto exit_remove_files;\n\t}\n\n\treturn 0;\n\nexit_remove_files:\n\tpc87427_remove_files(&pdev->dev);\n\treturn err;\n}\n\nstatic int pc87427_remove(struct platform_device *pdev)\n{\n\tstruct pc87427_data *data = platform_get_drvdata(pdev);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tpc87427_remove_files(&pdev->dev);\n\n\treturn 0;\n}\n\n\nstatic struct platform_driver pc87427_driver = {\n\t.driver = {\n\t\t.name\t= DRVNAME,\n\t},\n\t.probe\t\t= pc87427_probe,\n\t.remove\t\t= pc87427_remove,\n};\n\nstatic int __init pc87427_device_add(const struct pc87427_sio_data *sio_data)\n{\n\tstruct resource res[2] = {\n\t\t{ .flags\t= IORESOURCE_IO },\n\t\t{ .flags\t= IORESOURCE_IO },\n\t};\n\tint err, i, res_count;\n\n\tres_count = 0;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (!sio_data->address[i])\n\t\t\tcontinue;\n\t\tres[res_count].start = sio_data->address[i];\n\t\tres[res_count].end = sio_data->address[i] + REGION_LENGTH - 1;\n\t\tres[res_count].name = logdev_str[i];\n\n\t\terr = acpi_check_resource_conflict(&res[res_count]);\n\t\tif (err)\n\t\t\tgoto exit;\n\n\t\tres_count++;\n\t}\n\n\tpdev = platform_device_alloc(DRVNAME, res[0].start);\n\tif (!pdev) {\n\t\terr = -ENOMEM;\n\t\tpr_err(\"Device allocation failed\\n\");\n\t\tgoto exit;\n\t}\n\n\terr = platform_device_add_resources(pdev, res, res_count);\n\tif (err) {\n\t\tpr_err(\"Device resource addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add_data(pdev, sio_data,\n\t\t\t\t       sizeof(struct pc87427_sio_data));\n\tif (err) {\n\t\tpr_err(\"Platform data allocation failed\\n\");\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n\t\tpr_err(\"Device addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\treturn 0;\n\nexit_device_put:\n\tplatform_device_put(pdev);\nexit:\n\treturn err;\n}\n\nstatic int __init pc87427_find(int sioaddr, struct pc87427_sio_data *sio_data)\n{\n\tu16 val;\n\tu8 cfg, cfg_b;\n\tint i, err;\n\n\terr = superio_enter(sioaddr);\n\tif (err)\n\t\treturn err;\n\n\t \n\tval = force_id ? force_id : superio_inb(sioaddr, SIOREG_DEVID);\n\tif (val != 0xf2) {\t \n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tsio_data->address[i] = 0;\n\t\t \n\t\tsuperio_outb(sioaddr, SIOREG_LDSEL, logdev[i]);\n\n\t\tval = superio_inb(sioaddr, SIOREG_ACT);\n\t\tif (!(val & 0x01)) {\n\t\t\tpr_info(\"Logical device 0x%02x not activated\\n\",\n\t\t\t\tlogdev[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tval = superio_inb(sioaddr, SIOREG_MAP);\n\t\tif (val & 0x01) {\n\t\t\tpr_warn(\"Logical device 0x%02x is memory-mapped, can't use\\n\",\n\t\t\t\tlogdev[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tval = (superio_inb(sioaddr, SIOREG_IOBASE) << 8)\n\t\t    | superio_inb(sioaddr, SIOREG_IOBASE + 1);\n\t\tif (!val) {\n\t\t\tpr_info(\"I/O base address not set for logical device 0x%02x\\n\",\n\t\t\t\tlogdev[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tsio_data->address[i] = val;\n\t}\n\n\t \n\tif (!sio_data->address[0] && !sio_data->address[1]) {\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\tsio_data->has_fanin = (1 << 2) | (1 << 3);\t \n\n\tcfg = superio_inb(sioaddr, SIOREG_CF2);\n\tif (!(cfg & (1 << 3)))\n\t\tsio_data->has_fanin |= (1 << 0);\t \n\tif (!(cfg & (1 << 2)))\n\t\tsio_data->has_fanin |= (1 << 4);\t \n\n\tcfg = superio_inb(sioaddr, SIOREG_CFD);\n\tif (!(cfg & (1 << 0)))\n\t\tsio_data->has_fanin |= (1 << 1);\t \n\n\tcfg = superio_inb(sioaddr, SIOREG_CF4);\n\tif (!(cfg & (1 << 0)))\n\t\tsio_data->has_fanin |= (1 << 7);\t \n\tcfg_b = superio_inb(sioaddr, SIOREG_CFB);\n\tif (!(cfg & (1 << 1)) && (cfg_b & (1 << 3)))\n\t\tsio_data->has_fanin |= (1 << 5);\t \n\tcfg = superio_inb(sioaddr, SIOREG_CF3);\n\tif ((cfg & (1 << 3)) && !(cfg_b & (1 << 5)))\n\t\tsio_data->has_fanin |= (1 << 6);\t \n\n\t \n\tsio_data->has_fanout = (1 << 0);\t\t \n\tif (cfg_b & (1 << 0))\n\t\tsio_data->has_fanout |= (1 << 3);\t \n\n\tcfg = superio_inb(sioaddr, SIOREG_CFC);\n\tif (!(cfg & (1 << 4))) {\n\t\tif (cfg_b & (1 << 1))\n\t\t\tsio_data->has_fanout |= (1 << 1);  \n\t\tif (cfg_b & (1 << 2))\n\t\t\tsio_data->has_fanout |= (1 << 2);  \n\t}\n\n\t \n\tcfg = superio_inb(sioaddr, SIOREG_CF5);\n\tif (cfg & (1 << 6))\n\t\tsio_data->has_fanout |= (1 << 1);\t \n\tif (cfg & (1 << 5))\n\t\tsio_data->has_fanout |= (1 << 2);\t \n\nexit:\n\tsuperio_exit(sioaddr);\n\treturn err;\n}\n\nstatic int __init pc87427_init(void)\n{\n\tint err;\n\tstruct pc87427_sio_data sio_data;\n\n\tif (pc87427_find(0x2e, &sio_data)\n\t && pc87427_find(0x4e, &sio_data))\n\t\treturn -ENODEV;\n\n\terr = platform_driver_register(&pc87427_driver);\n\tif (err)\n\t\tgoto exit;\n\n\t \n\terr = pc87427_device_add(&sio_data);\n\tif (err)\n\t\tgoto exit_driver;\n\n\treturn 0;\n\nexit_driver:\n\tplatform_driver_unregister(&pc87427_driver);\nexit:\n\treturn err;\n}\n\nstatic void __exit pc87427_exit(void)\n{\n\tplatform_device_unregister(pdev);\n\tplatform_driver_unregister(&pc87427_driver);\n}\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"PC87427 hardware monitoring driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(pc87427_init);\nmodule_exit(pc87427_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}