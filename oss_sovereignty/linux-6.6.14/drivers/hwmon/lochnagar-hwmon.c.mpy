{
  "module_name": "lochnagar-hwmon.c",
  "hash_id": "edca8f40a0fa5df1caf69f9c65827e8cedd014183ac36512809ed6b969da9e41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lochnagar-hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/math64.h>\n#include <linux/mfd/lochnagar.h>\n#include <linux/mfd/lochnagar2_regs.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define LN2_MAX_NSAMPLE 1023\n#define LN2_SAMPLE_US   1670\n\n#define LN2_CURR_UNITS  1000\n#define LN2_VOLT_UNITS  1000\n#define LN2_TEMP_UNITS  1000\n#define LN2_PWR_UNITS   1000000\n\nstatic const char * const lochnagar_chan_names[] = {\n\t\"DBVDD1\",\n\t\"1V8 DSP\",\n\t\"1V8 CDC\",\n\t\"VDDCORE DSP\",\n\t\"AVDD 1V8\",\n\t\"SYSVDD\",\n\t\"VDDCORE CDC\",\n\t\"MICVDD\",\n};\n\nstruct lochnagar_hwmon {\n\tstruct regmap *regmap;\n\n\tlong power_nsamples[ARRAY_SIZE(lochnagar_chan_names)];\n\n\t \n\tstruct mutex sensor_lock;\n};\n\nenum lochnagar_measure_mode {\n\tLN2_CURR = 0,\n\tLN2_VOLT,\n\tLN2_TEMP,\n};\n\n \nstatic long float_to_long(u32 data, u32 precision)\n{\n\tu64 man = data & 0x007FFFFF;\n\tint exp = ((data & 0x7F800000) >> 23) - 127 - 23;\n\tbool negative = data & 0x80000000;\n\tlong result;\n\n\tman = (man + (1 << 23)) * precision;\n\n\tif (fls64(man) + exp > (int)sizeof(long) * 8 - 1)\n\t\tresult = LONG_MAX;\n\telse if (exp < 0)\n\t\tresult = (man + (1ull << (-exp - 1))) >> -exp;\n\telse\n\t\tresult = man << exp;\n\n\treturn negative ? -result : result;\n}\n\nstatic int do_measurement(struct regmap *regmap, int chan,\n\t\t\t  enum lochnagar_measure_mode mode, int nsamples)\n{\n\tunsigned int val;\n\tint ret;\n\n\tchan = 1 << (chan + LOCHNAGAR2_IMON_MEASURED_CHANNELS_SHIFT);\n\n\tret = regmap_write(regmap, LOCHNAGAR2_IMON_CTRL1,\n\t\t\t   LOCHNAGAR2_IMON_ENA_MASK | chan | mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(regmap, LOCHNAGAR2_IMON_CTRL2, nsamples);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(regmap, LOCHNAGAR2_IMON_CTRL3,\n\t\t\t   LOCHNAGAR2_IMON_CONFIGURE_MASK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret =  regmap_read_poll_timeout(regmap, LOCHNAGAR2_IMON_CTRL3, val,\n\t\t\t\t\tval & LOCHNAGAR2_IMON_DONE_MASK,\n\t\t\t\t\t1000, 10000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(regmap, LOCHNAGAR2_IMON_CTRL3,\n\t\t\t   LOCHNAGAR2_IMON_MEASURE_MASK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmsleep((nsamples * 3) / 2);\n\n\tret =  regmap_read_poll_timeout(regmap, LOCHNAGAR2_IMON_CTRL3, val,\n\t\t\t\t\tval & LOCHNAGAR2_IMON_DONE_MASK,\n\t\t\t\t\t5000, 200000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_write(regmap, LOCHNAGAR2_IMON_CTRL3, 0);\n}\n\nstatic int request_data(struct regmap *regmap, int chan, u32 *data)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_write(regmap, LOCHNAGAR2_IMON_CTRL4,\n\t\t\t   LOCHNAGAR2_IMON_DATA_REQ_MASK |\n\t\t\t   chan << LOCHNAGAR2_IMON_CH_SEL_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret =  regmap_read_poll_timeout(regmap, LOCHNAGAR2_IMON_CTRL4, val,\n\t\t\t\t\tval & LOCHNAGAR2_IMON_DATA_RDY_MASK,\n\t\t\t\t\t1000, 10000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(regmap, LOCHNAGAR2_IMON_DATA1, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*data = val << 16;\n\n\tret = regmap_read(regmap, LOCHNAGAR2_IMON_DATA2, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*data |= val;\n\n\treturn regmap_write(regmap, LOCHNAGAR2_IMON_CTRL4, 0);\n}\n\nstatic int read_sensor(struct device *dev, int chan,\n\t\t       enum lochnagar_measure_mode mode, int nsamples,\n\t\t       unsigned int precision, long *val)\n{\n\tstruct lochnagar_hwmon *priv = dev_get_drvdata(dev);\n\tstruct regmap *regmap = priv->regmap;\n\tu32 data;\n\tint ret;\n\n\tmutex_lock(&priv->sensor_lock);\n\n\tret = do_measurement(regmap, chan, mode, nsamples);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to perform measurement: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = request_data(regmap, chan, &data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read measurement: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\t*val = float_to_long(data, precision);\n\nerror:\n\tmutex_unlock(&priv->sensor_lock);\n\n\treturn ret;\n}\n\nstatic int read_power(struct device *dev, int chan, long *val)\n{\n\tstruct lochnagar_hwmon *priv = dev_get_drvdata(dev);\n\tint nsamples = priv->power_nsamples[chan];\n\tu64 power;\n\tint ret;\n\n\tif (!strcmp(\"SYSVDD\", lochnagar_chan_names[chan])) {\n\t\tpower = 5 * LN2_PWR_UNITS;\n\t} else {\n\t\tret = read_sensor(dev, chan, LN2_VOLT, 1, LN2_PWR_UNITS, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tpower = abs(*val);\n\t}\n\n\tret = read_sensor(dev, chan, LN2_CURR, nsamples, LN2_PWR_UNITS, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpower *= abs(*val);\n\tpower = DIV_ROUND_CLOSEST_ULL(power, LN2_PWR_UNITS);\n\n\tif (power > LONG_MAX)\n\t\t*val = LONG_MAX;\n\telse\n\t\t*val = power;\n\n\treturn 0;\n}\n\nstatic umode_t lochnagar_is_visible(const void *drvdata,\n\t\t\t\t    enum hwmon_sensor_types type,\n\t\t\t\t    u32 attr, int chan)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tif (!strcmp(\"SYSVDD\", lochnagar_chan_names[chan]))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase hwmon_power:\n\t\tif (attr == hwmon_power_average_interval)\n\t\t\treturn 0644;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0444;\n}\n\nstatic int lochnagar_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t  u32 attr, int chan, long *val)\n{\n\tstruct lochnagar_hwmon *priv = dev_get_drvdata(dev);\n\tint interval;\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\treturn read_sensor(dev, chan, LN2_VOLT, 1, LN2_VOLT_UNITS, val);\n\tcase hwmon_curr:\n\t\treturn read_sensor(dev, chan, LN2_CURR, 1, LN2_CURR_UNITS, val);\n\tcase hwmon_temp:\n\t\treturn read_sensor(dev, chan, LN2_TEMP, 1, LN2_TEMP_UNITS, val);\n\tcase hwmon_power:\n\t\tswitch (attr) {\n\t\tcase hwmon_power_average:\n\t\t\treturn read_power(dev, chan, val);\n\t\tcase hwmon_power_average_interval:\n\t\t\tinterval = priv->power_nsamples[chan] * LN2_SAMPLE_US;\n\t\t\t*val = DIV_ROUND_CLOSEST(interval, 1000);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lochnagar_read_string(struct device *dev,\n\t\t\t\t enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t int chan, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\tcase hwmon_curr:\n\tcase hwmon_power:\n\t\t*str = lochnagar_chan_names[chan];\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lochnagar_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t   u32 attr, int chan, long val)\n{\n\tstruct lochnagar_hwmon *priv = dev_get_drvdata(dev);\n\n\tif (type != hwmon_power || attr != hwmon_power_average_interval)\n\t\treturn -EOPNOTSUPP;\n\n\tval = clamp_t(long, val, 1, (LN2_MAX_NSAMPLE * LN2_SAMPLE_US) / 1000);\n\tval = DIV_ROUND_CLOSEST(val * 1000, LN2_SAMPLE_US);\n\n\tpriv->power_nsamples[chan] = val;\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops lochnagar_ops = {\n\t.is_visible = lochnagar_is_visible,\n\t.read = lochnagar_read,\n\t.read_string = lochnagar_read_string,\n\t.write = lochnagar_write,\n};\n\nstatic const struct hwmon_channel_info * const lochnagar_info[] = {\n\tHWMON_CHANNEL_INFO(temp,  HWMON_T_INPUT),\n\tHWMON_CHANNEL_INFO(in,    HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t\t  HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t\t  HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t\t  HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t\t  HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t\t  HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t\t  HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t\t  HWMON_I_INPUT | HWMON_I_LABEL),\n\tHWMON_CHANNEL_INFO(curr,  HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t\t  HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t\t  HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t\t  HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t\t  HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t\t  HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t\t  HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t\t  HWMON_C_INPUT | HWMON_C_LABEL),\n\tHWMON_CHANNEL_INFO(power, HWMON_P_AVERAGE | HWMON_P_AVERAGE_INTERVAL |\n\t\t\t\t  HWMON_P_LABEL,\n\t\t\t\t  HWMON_P_AVERAGE | HWMON_P_AVERAGE_INTERVAL |\n\t\t\t\t  HWMON_P_LABEL,\n\t\t\t\t  HWMON_P_AVERAGE | HWMON_P_AVERAGE_INTERVAL |\n\t\t\t\t  HWMON_P_LABEL,\n\t\t\t\t  HWMON_P_AVERAGE | HWMON_P_AVERAGE_INTERVAL |\n\t\t\t\t  HWMON_P_LABEL,\n\t\t\t\t  HWMON_P_AVERAGE | HWMON_P_AVERAGE_INTERVAL |\n\t\t\t\t  HWMON_P_LABEL,\n\t\t\t\t  HWMON_P_AVERAGE | HWMON_P_AVERAGE_INTERVAL |\n\t\t\t\t  HWMON_P_LABEL,\n\t\t\t\t  HWMON_P_AVERAGE | HWMON_P_AVERAGE_INTERVAL |\n\t\t\t\t  HWMON_P_LABEL,\n\t\t\t\t  HWMON_P_AVERAGE | HWMON_P_AVERAGE_INTERVAL |\n\t\t\t\t  HWMON_P_LABEL),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info lochnagar_chip_info = {\n\t.ops = &lochnagar_ops,\n\t.info = lochnagar_info,\n};\n\nstatic const struct of_device_id lochnagar_of_match[] = {\n\t{ .compatible = \"cirrus,lochnagar2-hwmon\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lochnagar_of_match);\n\nstatic int lochnagar_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *hwmon_dev;\n\tstruct lochnagar_hwmon *priv;\n\tint i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->sensor_lock);\n\n\tpriv->regmap = dev_get_regmap(dev->parent, NULL);\n\tif (!priv->regmap) {\n\t\tdev_err(dev, \"No register map found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->power_nsamples); i++)\n\t\tpriv->power_nsamples[i] = 96;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, \"Lochnagar\", priv,\n\t\t\t\t\t\t\t &lochnagar_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic struct platform_driver lochnagar_hwmon_driver = {\n\t.driver = {\n\t\t.name = \"lochnagar-hwmon\",\n\t\t.of_match_table = lochnagar_of_match,\n\t},\n\t.probe = lochnagar_hwmon_probe,\n};\nmodule_platform_driver(lochnagar_hwmon_driver);\n\nMODULE_AUTHOR(\"Lucas Tanure <tanureal@opensource.cirrus.com>\");\nMODULE_DESCRIPTION(\"Lochnagar hardware monitoring features\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}