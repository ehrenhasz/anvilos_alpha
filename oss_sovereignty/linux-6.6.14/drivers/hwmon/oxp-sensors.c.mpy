{
  "module_name": "oxp-sensors.c",
  "hash_id": "f78f41b26a9c77b3e1a01afa028f11e8a4e2f82bd343c9eaba3859798469fba8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/oxp-sensors.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/hwmon.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/processor.h>\n\n \nstatic u32 oxp_mutex;\n\n#define ACPI_LOCK_DELAY_MS\t500\n\nstatic bool lock_global_acpi_lock(void)\n{\n\treturn ACPI_SUCCESS(acpi_acquire_global_lock(ACPI_LOCK_DELAY_MS, &oxp_mutex));\n}\n\nstatic bool unlock_global_acpi_lock(void)\n{\n\treturn ACPI_SUCCESS(acpi_release_global_lock(oxp_mutex));\n}\n\nenum oxp_board {\n\taok_zoe_a1 = 1,\n\taya_neo_2,\n\taya_neo_air,\n\taya_neo_air_pro,\n\taya_neo_geek,\n\toxp_mini_amd,\n\toxp_mini_amd_a07,\n\toxp_mini_amd_pro,\n};\n\nstatic enum oxp_board board;\n\n \n#define OXP_SENSOR_FAN_REG\t\t0x76  \n#define OXP_SENSOR_PWM_ENABLE_REG\t0x4A  \n#define OXP_SENSOR_PWM_REG\t\t0x4B  \n\n \n#define OXP_OLD_TURBO_SWITCH_REG\t0x1E\n#define OXP_OLD_TURBO_TAKE_VAL\t\t0x01\n#define OXP_OLD_TURBO_RETURN_VAL\t0x00\n\n#define OXP_TURBO_SWITCH_REG\t\t0xF1\n#define OXP_TURBO_TAKE_VAL\t\t0x40\n#define OXP_TURBO_RETURN_VAL\t\t0x00\n\nstatic const struct dmi_system_id dmi_table[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AOKZOE\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"AOKZOE A1 AR07\"),\n\t\t},\n\t\t.driver_data = (void *)aok_zoe_a1,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AOKZOE\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"AOKZOE A1 Pro\"),\n\t\t},\n\t\t.driver_data = (void *)aok_zoe_a1,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AYANEO\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"AYANEO 2\"),\n\t\t},\n\t\t.driver_data = (void *)aya_neo_2,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AYANEO\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"AIR\"),\n\t\t},\n\t\t.driver_data = (void *)aya_neo_air,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AYANEO\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"AIR Pro\"),\n\t\t},\n\t\t.driver_data = (void *)aya_neo_air_pro,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AYANEO\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"GEEK\"),\n\t\t},\n\t\t.driver_data = (void *)aya_neo_geek,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ONE-NETBOOK\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"ONE XPLAYER\"),\n\t\t},\n\t\t.driver_data = (void *)oxp_mini_amd,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ONE-NETBOOK\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"ONEXPLAYER mini A07\"),\n\t\t},\n\t\t.driver_data = (void *)oxp_mini_amd_a07,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ONE-NETBOOK\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"ONEXPLAYER Mini Pro\"),\n\t\t},\n\t\t.driver_data = (void *)oxp_mini_amd_pro,\n\t},\n\t{},\n};\n\n \nstatic int read_from_ec(u8 reg, int size, long *val)\n{\n\tint i;\n\tint ret;\n\tu8 buffer;\n\n\tif (!lock_global_acpi_lock())\n\t\treturn -EBUSY;\n\n\t*val = 0;\n\tfor (i = 0; i < size; i++) {\n\t\tret = ec_read(reg + i, &buffer);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*val <<= i * 8;\n\t\t*val += buffer;\n\t}\n\n\tif (!unlock_global_acpi_lock())\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int write_to_ec(u8 reg, u8 value)\n{\n\tint ret;\n\n\tif (!lock_global_acpi_lock())\n\t\treturn -EBUSY;\n\n\tret = ec_write(reg, value);\n\n\tif (!unlock_global_acpi_lock())\n\t\treturn -EBUSY;\n\n\treturn ret;\n}\n\n \nstatic int tt_toggle_enable(void)\n{\n\tu8 reg;\n\tu8 val;\n\n\tswitch (board) {\n\tcase oxp_mini_amd_a07:\n\t\treg = OXP_OLD_TURBO_SWITCH_REG;\n\t\tval = OXP_OLD_TURBO_TAKE_VAL;\n\t\tbreak;\n\tcase oxp_mini_amd_pro:\n\tcase aok_zoe_a1:\n\t\treg = OXP_TURBO_SWITCH_REG;\n\t\tval = OXP_TURBO_TAKE_VAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn write_to_ec(reg, val);\n}\n\nstatic int tt_toggle_disable(void)\n{\n\tu8 reg;\n\tu8 val;\n\n\tswitch (board) {\n\tcase oxp_mini_amd_a07:\n\t\treg = OXP_OLD_TURBO_SWITCH_REG;\n\t\tval = OXP_OLD_TURBO_RETURN_VAL;\n\t\tbreak;\n\tcase oxp_mini_amd_pro:\n\tcase aok_zoe_a1:\n\t\treg = OXP_TURBO_SWITCH_REG;\n\t\tval = OXP_TURBO_RETURN_VAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn write_to_ec(reg, val);\n}\n\n \nstatic umode_t tt_toggle_is_visible(struct kobject *kobj,\n\t\t\t\t    struct attribute *attr, int n)\n{\n\tswitch (board) {\n\tcase aok_zoe_a1:\n\tcase oxp_mini_amd_a07:\n\tcase oxp_mini_amd_pro:\n\t\treturn attr->mode;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t tt_toggle_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tint rval;\n\tbool value;\n\n\trval = kstrtobool(buf, &value);\n\tif (rval)\n\t\treturn rval;\n\n\tif (value) {\n\t\trval = tt_toggle_enable();\n\t} else {\n\t\trval = tt_toggle_disable();\n\t}\n\tif (rval)\n\t\treturn rval;\n\n\treturn count;\n}\n\nstatic ssize_t tt_toggle_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tint retval;\n\tu8 reg;\n\tlong val;\n\n\tswitch (board) {\n\tcase oxp_mini_amd_a07:\n\t\treg = OXP_OLD_TURBO_SWITCH_REG;\n\t\tbreak;\n\tcase oxp_mini_amd_pro:\n\tcase aok_zoe_a1:\n\t\treg = OXP_TURBO_SWITCH_REG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tretval = read_from_ec(reg, 1, &val);\n\tif (retval)\n\t\treturn retval;\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!val);\n}\n\nstatic DEVICE_ATTR_RW(tt_toggle);\n\n \nstatic int oxp_pwm_enable(void)\n{\n\treturn write_to_ec(OXP_SENSOR_PWM_ENABLE_REG, 0x01);\n}\n\nstatic int oxp_pwm_disable(void)\n{\n\treturn write_to_ec(OXP_SENSOR_PWM_ENABLE_REG, 0x00);\n}\n\n \nstatic umode_t oxp_ec_hwmon_is_visible(const void *drvdata,\n\t\t\t\t       enum hwmon_sensor_types type, u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\treturn 0444;\n\tcase hwmon_pwm:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int oxp_platform_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel, long *val)\n{\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\treturn read_from_ec(OXP_SENSOR_FAN_REG, 2, val);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\tret = read_from_ec(OXP_SENSOR_PWM_REG, 1, val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tswitch (board) {\n\t\t\tcase aya_neo_2:\n\t\t\tcase aya_neo_air:\n\t\t\tcase aya_neo_air_pro:\n\t\t\tcase aya_neo_geek:\n\t\t\tcase oxp_mini_amd:\n\t\t\tcase oxp_mini_amd_a07:\n\t\t\t\t*val = (*val * 255) / 100;\n\t\t\t\tbreak;\n\t\t\tcase oxp_mini_amd_pro:\n\t\t\tcase aok_zoe_a1:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase hwmon_pwm_enable:\n\t\t\treturn read_from_ec(OXP_SENSOR_PWM_ENABLE_REG, 1, val);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic int oxp_platform_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_enable:\n\t\t\tif (val == 1)\n\t\t\t\treturn oxp_pwm_enable();\n\t\t\telse if (val == 0)\n\t\t\t\treturn oxp_pwm_disable();\n\t\t\treturn -EINVAL;\n\t\tcase hwmon_pwm_input:\n\t\t\tif (val < 0 || val > 255)\n\t\t\t\treturn -EINVAL;\n\t\t\tswitch (board) {\n\t\t\tcase aya_neo_2:\n\t\t\tcase aya_neo_air:\n\t\t\tcase aya_neo_air_pro:\n\t\t\tcase aya_neo_geek:\n\t\t\tcase oxp_mini_amd:\n\t\t\tcase oxp_mini_amd_a07:\n\t\t\t\tval = (val * 100) / 255;\n\t\t\t\tbreak;\n\t\t\tcase aok_zoe_a1:\n\t\t\tcase oxp_mini_amd_pro:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn write_to_ec(OXP_SENSOR_PWM_REG, val);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic const struct hwmon_channel_info * const oxp_platform_sensors[] = {\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE),\n\tNULL,\n};\n\nstatic struct attribute *oxp_ec_attrs[] = {\n\t&dev_attr_tt_toggle.attr,\n\tNULL\n};\n\nstatic struct attribute_group oxp_ec_attribute_group = {\n\t.is_visible = tt_toggle_is_visible,\n\t.attrs = oxp_ec_attrs,\n};\n\nstatic const struct attribute_group *oxp_ec_groups[] = {\n\t&oxp_ec_attribute_group,\n\tNULL\n};\n\nstatic const struct hwmon_ops oxp_ec_hwmon_ops = {\n\t.is_visible = oxp_ec_hwmon_is_visible,\n\t.read = oxp_platform_read,\n\t.write = oxp_platform_write,\n};\n\nstatic const struct hwmon_chip_info oxp_ec_chip_info = {\n\t.ops = &oxp_ec_hwmon_ops,\n\t.info = oxp_platform_sensors,\n};\n\n \nstatic int oxp_platform_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *hwdev;\n\n\thwdev = devm_hwmon_device_register_with_info(dev, \"oxpec\", NULL,\n\t\t\t\t\t\t     &oxp_ec_chip_info, NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwdev);\n}\n\nstatic struct platform_driver oxp_platform_driver = {\n\t.driver = {\n\t\t.name = \"oxp-platform\",\n\t\t.dev_groups = oxp_ec_groups,\n\t},\n\t.probe = oxp_platform_probe,\n};\n\nstatic struct platform_device *oxp_platform_device;\n\nstatic int __init oxp_platform_init(void)\n{\n\tconst struct dmi_system_id *dmi_entry;\n\n\t \n\tdmi_entry = dmi_first_match(dmi_table);\n\tif (!dmi_entry || boot_cpu_data.x86_vendor != X86_VENDOR_AMD)\n\t\treturn -ENODEV;\n\n\tboard = (enum oxp_board)(unsigned long)dmi_entry->driver_data;\n\n\toxp_platform_device =\n\t\tplatform_create_bundle(&oxp_platform_driver,\n\t\t\t\t       oxp_platform_probe, NULL, 0, NULL, 0);\n\n\treturn PTR_ERR_OR_ZERO(oxp_platform_device);\n}\n\nstatic void __exit oxp_platform_exit(void)\n{\n\tplatform_device_unregister(oxp_platform_device);\n\tplatform_driver_unregister(&oxp_platform_driver);\n}\n\nMODULE_DEVICE_TABLE(dmi, dmi_table);\n\nmodule_init(oxp_platform_init);\nmodule_exit(oxp_platform_exit);\n\nMODULE_AUTHOR(\"Joaqu\u00edn Ignacio Aramend\u00eda <samsagax@gmail.com>\");\nMODULE_DESCRIPTION(\"Platform driver that handles EC sensors of OneXPlayer devices\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}