{
  "module_name": "w83627hf.c",
  "hash_id": "4d5a4b713a9a752fb33ba62b712335a451317233e99db51ae33121fa39d46c03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/w83627hf.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon-vid.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/ioport.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n#include \"lm75.h\"\n\nstatic struct platform_device *pdev;\n\n#define DRVNAME \"w83627hf\"\nenum chips { w83627hf, w83627thf, w83697hf, w83637hf, w83687thf };\n\nstruct w83627hf_sio_data {\n\tenum chips type;\n\tint sioaddr;\n};\n\nstatic u8 force_i2c = 0x1f;\nmodule_param(force_i2c, byte, 0);\nMODULE_PARM_DESC(force_i2c,\n\t\t \"Initialize the i2c address of the sensors\");\n\nstatic bool init = 1;\nmodule_param(init, bool, 0);\nMODULE_PARM_DESC(init, \"Set to zero to bypass chip initialization\");\n\nstatic unsigned short force_id;\nmodule_param(force_id, ushort, 0);\nMODULE_PARM_DESC(force_id, \"Override the detected device ID\");\n\n \n#define DEV\t\t\t0x07  \n\n \n#define W83627HF_LD_FDC\t\t0x00\n#define W83627HF_LD_PRT\t\t0x01\n#define W83627HF_LD_UART1\t0x02\n#define W83627HF_LD_UART2\t0x03\n#define W83627HF_LD_KBC\t\t0x05\n#define W83627HF_LD_CIR\t\t0x06  \n#define W83627HF_LD_GAME\t0x07\n#define W83627HF_LD_MIDI\t0x07\n#define W83627HF_LD_GPIO1\t0x07\n#define W83627HF_LD_GPIO5\t0x07  \n#define W83627HF_LD_GPIO2\t0x08\n#define W83627HF_LD_GPIO3\t0x09\n#define W83627HF_LD_GPIO4\t0x09  \n#define W83627HF_LD_ACPI\t0x0a\n#define W83627HF_LD_HWM\t\t0x0b\n\n#define DEVID\t\t\t0x20  \n\n#define W83627THF_GPIO5_EN\t0x30  \n#define W83627THF_GPIO5_IOSR\t0xf3  \n#define W83627THF_GPIO5_DR\t0xf4  \n\n#define W83687THF_VID_EN\t0x29  \n#define W83687THF_VID_CFG\t0xF0  \n#define W83687THF_VID_DATA\t0xF1  \n\nstatic inline void\nsuperio_outb(struct w83627hf_sio_data *sio, int reg, int val)\n{\n\toutb(reg, sio->sioaddr);\n\toutb(val, sio->sioaddr + 1);\n}\n\nstatic inline int\nsuperio_inb(struct w83627hf_sio_data *sio, int reg)\n{\n\toutb(reg, sio->sioaddr);\n\treturn inb(sio->sioaddr + 1);\n}\n\nstatic inline void\nsuperio_select(struct w83627hf_sio_data *sio, int ld)\n{\n\toutb(DEV, sio->sioaddr);\n\toutb(ld,  sio->sioaddr + 1);\n}\n\nstatic inline int\nsuperio_enter(struct w83627hf_sio_data *sio)\n{\n\tif (!request_muxed_region(sio->sioaddr, 2, DRVNAME))\n\t\treturn -EBUSY;\n\n\toutb(0x87, sio->sioaddr);\n\toutb(0x87, sio->sioaddr);\n\n\treturn 0;\n}\n\nstatic inline void\nsuperio_exit(struct w83627hf_sio_data *sio)\n{\n\toutb(0xAA, sio->sioaddr);\n\trelease_region(sio->sioaddr, 2);\n}\n\n#define W627_DEVID 0x52\n#define W627THF_DEVID 0x82\n#define W697_DEVID 0x60\n#define W637_DEVID 0x70\n#define W687THF_DEVID 0x85\n#define WINB_ACT_REG 0x30\n#define WINB_BASE_REG 0x60\n \n\n \n#define WINB_ALIGNMENT\t\t~7\n\n \n#define WINB_REGION_OFFSET\t5\n#define WINB_REGION_SIZE\t2\n\n \n#define W83781D_ADDR_REG_OFFSET 0\n#define W83781D_DATA_REG_OFFSET 1\n\n \n \n#define W83781D_REG_IN_MAX(nr) ((nr < 7) ? (0x2b + (nr) * 2) : \\\n\t\t\t\t\t   (0x554 + (((nr) - 7) * 2)))\n#define W83781D_REG_IN_MIN(nr) ((nr < 7) ? (0x2c + (nr) * 2) : \\\n\t\t\t\t\t   (0x555 + (((nr) - 7) * 2)))\n#define W83781D_REG_IN(nr)     ((nr < 7) ? (0x20 + (nr)) : \\\n\t\t\t\t\t   (0x550 + (nr) - 7))\n\n \n#define W83627HF_REG_FAN_MIN(nr)\t(0x3b + (nr))\n#define W83627HF_REG_FAN(nr)\t\t(0x28 + (nr))\n\n#define W83627HF_REG_TEMP2_CONFIG 0x152\n#define W83627HF_REG_TEMP3_CONFIG 0x252\n \nstatic const u16 w83627hf_reg_temp[]\t\t= { 0x27, 0x150, 0x250 };\nstatic const u16 w83627hf_reg_temp_hyst[]\t= { 0x3A, 0x153, 0x253 };\nstatic const u16 w83627hf_reg_temp_over[]\t= { 0x39, 0x155, 0x255 };\n\n#define W83781D_REG_BANK 0x4E\n\n#define W83781D_REG_CONFIG 0x40\n#define W83781D_REG_ALARM1 0x459\n#define W83781D_REG_ALARM2 0x45A\n#define W83781D_REG_ALARM3 0x45B\n\n#define W83781D_REG_BEEP_CONFIG 0x4D\n#define W83781D_REG_BEEP_INTS1 0x56\n#define W83781D_REG_BEEP_INTS2 0x57\n#define W83781D_REG_BEEP_INTS3 0x453\n\n#define W83781D_REG_VID_FANDIV 0x47\n\n#define W83781D_REG_CHIPID 0x49\n#define W83781D_REG_WCHIPID 0x58\n#define W83781D_REG_CHIPMAN 0x4F\n#define W83781D_REG_PIN 0x4B\n\n#define W83781D_REG_VBAT 0x5D\n\n#define W83627HF_REG_PWM1 0x5A\n#define W83627HF_REG_PWM2 0x5B\n\nstatic const u8 W83627THF_REG_PWM_ENABLE[] = {\n\t0x04,\t\t \n\t0x04,\t\t \n\t0x12,\t\t \n};\nstatic const u8 W83627THF_PWM_ENABLE_SHIFT[] = { 2, 4, 1 };\n\n#define W83627THF_REG_PWM1\t\t0x01\t \n#define W83627THF_REG_PWM2\t\t0x03\t \n#define W83627THF_REG_PWM3\t\t0x11\t \n\n#define W83627THF_REG_VRM_OVT_CFG \t0x18\t \n\nstatic const u8 regpwm_627hf[] = { W83627HF_REG_PWM1, W83627HF_REG_PWM2 };\nstatic const u8 regpwm[] = { W83627THF_REG_PWM1, W83627THF_REG_PWM2,\n                             W83627THF_REG_PWM3 };\n#define W836X7HF_REG_PWM(type, nr) (((type) == w83627hf) ? \\\n\t\t\t\t    regpwm_627hf[nr] : regpwm[nr])\n\n#define W83627HF_REG_PWM_FREQ\t\t0x5C\t \n\n#define W83637HF_REG_PWM_FREQ1\t\t0x00\t \n#define W83637HF_REG_PWM_FREQ2\t\t0x02\t \n#define W83637HF_REG_PWM_FREQ3\t\t0x10\t \n\nstatic const u8 W83637HF_REG_PWM_FREQ[] = { W83637HF_REG_PWM_FREQ1,\n\t\t\t\t\tW83637HF_REG_PWM_FREQ2,\n\t\t\t\t\tW83637HF_REG_PWM_FREQ3 };\n\n#define W83627HF_BASE_PWM_FREQ\t46870\n\n#define W83781D_REG_I2C_ADDR 0x48\n#define W83781D_REG_I2C_SUBADDR 0x4A\n\n \n#define W83781D_REG_SCFG1 0x5D\nstatic const u8 BIT_SCFG1[] = { 0x02, 0x04, 0x08 };\n#define W83781D_REG_SCFG2 0x59\nstatic const u8 BIT_SCFG2[] = { 0x10, 0x20, 0x40 };\n#define W83781D_DEFAULT_BETA 3435\n\n \n#define IN_TO_REG(val)  (clamp_val((((val) + 8) / 16), 0, 255))\n#define IN_FROM_REG(val) ((val) * 16)\n\nstatic inline u8 FAN_TO_REG(long rpm, int div)\n{\n\tif (rpm == 0)\n\t\treturn 255;\n\trpm = clamp_val(rpm, 1, 1000000);\n\treturn clamp_val((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\n}\n\n#define TEMP_MIN (-128000)\n#define TEMP_MAX ( 127000)\n\n \nstatic u8 TEMP_TO_REG(long temp)\n{\n\tint ntemp = clamp_val(temp, TEMP_MIN, TEMP_MAX);\n\tntemp += (ntemp < 0 ? -500 : 500);\n\treturn (u8)(ntemp / 1000);\n}\n\nstatic int TEMP_FROM_REG(u8 reg)\n{\n        return (s8)reg * 1000;\n}\n\n#define FAN_FROM_REG(val,div) ((val)==0?-1:(val)==255?0:1350000/((val)*(div)))\n\n#define PWM_TO_REG(val) (clamp_val((val), 0, 255))\n\nstatic inline unsigned long pwm_freq_from_reg_627hf(u8 reg)\n{\n\tunsigned long freq;\n\tfreq = W83627HF_BASE_PWM_FREQ >> reg;\n\treturn freq;\n}\nstatic inline u8 pwm_freq_to_reg_627hf(unsigned long val)\n{\n\tu8 i;\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (val > (((W83627HF_BASE_PWM_FREQ >> i) +\n\t\t\t    (W83627HF_BASE_PWM_FREQ >> (i+1))) / 2))\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nstatic inline unsigned long pwm_freq_from_reg(u8 reg)\n{\n\t \n\tunsigned long clock = (reg & 0x80) ? 180000UL : 24000000UL;\n\n\treg &= 0x7f;\n\t \n\tif (reg == 0)\n\t\treg++;\n\treturn clock / (reg << 8);\n}\nstatic inline u8 pwm_freq_to_reg(unsigned long val)\n{\n\t \n\tif (val >= 93750)\t \n\t\treturn 0x01;\n\tif (val >= 720)\t \n\t\treturn 24000000UL / (val << 8);\n\tif (val < 6)\t\t \n\t\treturn 0xFF;\n\telse\t\t\t \n\t\treturn 0x80 | (180000UL / (val << 8));\n}\n\n#define BEEP_MASK_FROM_REG(val)\t\t((val) & 0xff7fff)\n#define BEEP_MASK_TO_REG(val)\t\t((val) & 0xff7fff)\n\n#define DIV_FROM_REG(val) (1 << (val))\n\nstatic inline u8 DIV_TO_REG(long val)\n{\n\tint i;\n\tval = clamp_val(val, 1, 128) >> 1;\n\tfor (i = 0; i < 7; i++) {\n\t\tif (val == 0)\n\t\t\tbreak;\n\t\tval >>= 1;\n\t}\n\treturn (u8)i;\n}\n\n \nstruct w83627hf_data {\n\tunsigned short addr;\n\tconst char *name;\n\tstruct device *hwmon_dev;\n\tstruct mutex lock;\n\tenum chips type;\n\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\n\tu8 in[9];\t\t \n\tu8 in_max[9];\t\t \n\tu8 in_min[9];\t\t \n\tu8 fan[3];\t\t \n\tu8 fan_min[3];\t\t \n\tu16 temp[3];\t\t \n\tu16 temp_max[3];\t \n\tu16 temp_max_hyst[3];\t \n\tu8 fan_div[3];\t\t \n\tu8 vid;\t\t\t \n\tu32 alarms;\t\t \n\tu32 beep_mask;\t\t \n\tu8 pwm[3];\t\t \n\tu8 pwm_enable[3];\t \n\tu8 pwm_freq[3];\t\t \n\tu16 sens[3];\t\t \n\tu8 vrm;\n\tu8 vrm_ovt;\t\t \n\n#ifdef CONFIG_PM\n\t \n\tu8 scfg1;\n\tu8 scfg2;\n#endif\n};\n\n \nstatic inline void w83627hf_set_bank(struct w83627hf_data *data, u16 reg)\n{\n\tif ((reg & 0x00f0) == 0x50) {\n\t\toutb_p(W83781D_REG_BANK, data->addr + W83781D_ADDR_REG_OFFSET);\n\t\toutb_p(reg >> 8, data->addr + W83781D_DATA_REG_OFFSET);\n\t}\n}\n\n \nstatic inline void w83627hf_reset_bank(struct w83627hf_data *data, u16 reg)\n{\n\tif (reg & 0xff00) {\n\t\toutb_p(W83781D_REG_BANK, data->addr + W83781D_ADDR_REG_OFFSET);\n\t\toutb_p(0, data->addr + W83781D_DATA_REG_OFFSET);\n\t}\n}\n\nstatic int w83627hf_read_value(struct w83627hf_data *data, u16 reg)\n{\n\tint res, word_sized;\n\n\tmutex_lock(&data->lock);\n\tword_sized = (((reg & 0xff00) == 0x100)\n\t\t   || ((reg & 0xff00) == 0x200))\n\t\t  && (((reg & 0x00ff) == 0x50)\n\t\t   || ((reg & 0x00ff) == 0x53)\n\t\t   || ((reg & 0x00ff) == 0x55));\n\tw83627hf_set_bank(data, reg);\n\toutb_p(reg & 0xff, data->addr + W83781D_ADDR_REG_OFFSET);\n\tres = inb_p(data->addr + W83781D_DATA_REG_OFFSET);\n\tif (word_sized) {\n\t\toutb_p((reg & 0xff) + 1,\n\t\t       data->addr + W83781D_ADDR_REG_OFFSET);\n\t\tres =\n\t\t    (res << 8) + inb_p(data->addr +\n\t\t\t\t       W83781D_DATA_REG_OFFSET);\n\t}\n\tw83627hf_reset_bank(data, reg);\n\tmutex_unlock(&data->lock);\n\treturn res;\n}\n\nstatic int w83627hf_write_value(struct w83627hf_data *data, u16 reg, u16 value)\n{\n\tint word_sized;\n\n\tmutex_lock(&data->lock);\n\tword_sized = (((reg & 0xff00) == 0x100)\n\t\t   || ((reg & 0xff00) == 0x200))\n\t\t  && (((reg & 0x00ff) == 0x53)\n\t\t   || ((reg & 0x00ff) == 0x55));\n\tw83627hf_set_bank(data, reg);\n\toutb_p(reg & 0xff, data->addr + W83781D_ADDR_REG_OFFSET);\n\tif (word_sized) {\n\t\toutb_p(value >> 8,\n\t\t       data->addr + W83781D_DATA_REG_OFFSET);\n\t\toutb_p((reg & 0xff) + 1,\n\t\t       data->addr + W83781D_ADDR_REG_OFFSET);\n\t}\n\toutb_p(value & 0xff,\n\t       data->addr + W83781D_DATA_REG_OFFSET);\n\tw83627hf_reset_bank(data, reg);\n\tmutex_unlock(&data->lock);\n\treturn 0;\n}\n\nstatic void w83627hf_update_fan_div(struct w83627hf_data *data)\n{\n\tint reg;\n\n\treg = w83627hf_read_value(data, W83781D_REG_VID_FANDIV);\n\tdata->fan_div[0] = (reg >> 4) & 0x03;\n\tdata->fan_div[1] = (reg >> 6) & 0x03;\n\tif (data->type != w83697hf) {\n\t\tdata->fan_div[2] = (w83627hf_read_value(data,\n\t\t\t\t       W83781D_REG_PIN) >> 6) & 0x03;\n\t}\n\treg = w83627hf_read_value(data, W83781D_REG_VBAT);\n\tdata->fan_div[0] |= (reg >> 3) & 0x04;\n\tdata->fan_div[1] |= (reg >> 4) & 0x04;\n\tif (data->type != w83697hf)\n\t\tdata->fan_div[2] |= (reg >> 5) & 0x04;\n}\n\nstatic struct w83627hf_data *w83627hf_update_device(struct device *dev)\n{\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tint i, num_temps = (data->type == w83697hf) ? 2 : 3;\n\tint num_pwms = (data->type == w83697hf) ? 2 : 3;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\n\t    || !data->valid) {\n\t\tfor (i = 0; i <= 8; i++) {\n\t\t\t \n\t\t\tif (((data->type == w83697hf) && (i == 1)) ||\n\t\t\t    ((data->type != w83627hf && data->type != w83697hf)\n\t\t\t    && (i == 5 || i == 6)))\n\t\t\t\tcontinue;\n\t\t\tdata->in[i] =\n\t\t\t    w83627hf_read_value(data, W83781D_REG_IN(i));\n\t\t\tdata->in_min[i] =\n\t\t\t    w83627hf_read_value(data,\n\t\t\t\t\t       W83781D_REG_IN_MIN(i));\n\t\t\tdata->in_max[i] =\n\t\t\t    w83627hf_read_value(data,\n\t\t\t\t\t       W83781D_REG_IN_MAX(i));\n\t\t}\n\t\tfor (i = 0; i <= 2; i++) {\n\t\t\tdata->fan[i] =\n\t\t\t    w83627hf_read_value(data, W83627HF_REG_FAN(i));\n\t\t\tdata->fan_min[i] =\n\t\t\t    w83627hf_read_value(data,\n\t\t\t\t\t       W83627HF_REG_FAN_MIN(i));\n\t\t}\n\t\tfor (i = 0; i <= 2; i++) {\n\t\t\tu8 tmp = w83627hf_read_value(data,\n\t\t\t\tW836X7HF_REG_PWM(data->type, i));\n\t\t\t \n\t\t\tif (data->type == w83627thf)\n\t\t\t\ttmp &= 0xf0;\n\t\t\tdata->pwm[i] = tmp;\n\t\t\tif (i == 1 &&\n\t\t\t    (data->type == w83627hf || data->type == w83697hf))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (data->type == w83627hf) {\n\t\t\t\tu8 tmp = w83627hf_read_value(data,\n\t\t\t\t\t\tW83627HF_REG_PWM_FREQ);\n\t\t\t\tdata->pwm_freq[0] = tmp & 0x07;\n\t\t\t\tdata->pwm_freq[1] = (tmp >> 4) & 0x07;\n\t\t} else if (data->type != w83627thf) {\n\t\t\tfor (i = 1; i <= 3; i++) {\n\t\t\t\tdata->pwm_freq[i - 1] =\n\t\t\t\t\tw83627hf_read_value(data,\n\t\t\t\t\t\tW83637HF_REG_PWM_FREQ[i - 1]);\n\t\t\t\tif (i == 2 && (data->type == w83697hf))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (data->type != w83627hf) {\n\t\t\tfor (i = 0; i < num_pwms; i++) {\n\t\t\t\tu8 tmp = w83627hf_read_value(data,\n\t\t\t\t\tW83627THF_REG_PWM_ENABLE[i]);\n\t\t\t\tdata->pwm_enable[i] =\n\t\t\t\t\t((tmp >> W83627THF_PWM_ENABLE_SHIFT[i])\n\t\t\t\t\t& 0x03) + 1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < num_temps; i++) {\n\t\t\tdata->temp[i] = w83627hf_read_value(\n\t\t\t\t\t\tdata, w83627hf_reg_temp[i]);\n\t\t\tdata->temp_max[i] = w83627hf_read_value(\n\t\t\t\t\t\tdata, w83627hf_reg_temp_over[i]);\n\t\t\tdata->temp_max_hyst[i] = w83627hf_read_value(\n\t\t\t\t\t\tdata, w83627hf_reg_temp_hyst[i]);\n\t\t}\n\n\t\tw83627hf_update_fan_div(data);\n\n\t\tdata->alarms =\n\t\t    w83627hf_read_value(data, W83781D_REG_ALARM1) |\n\t\t    (w83627hf_read_value(data, W83781D_REG_ALARM2) << 8) |\n\t\t    (w83627hf_read_value(data, W83781D_REG_ALARM3) << 16);\n\t\ti = w83627hf_read_value(data, W83781D_REG_BEEP_INTS2);\n\t\tdata->beep_mask = (i << 8) |\n\t\t    w83627hf_read_value(data, W83781D_REG_BEEP_INTS1) |\n\t\t    w83627hf_read_value(data, W83781D_REG_BEEP_INTS3) << 16;\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n#ifdef CONFIG_PM\nstatic int w83627hf_suspend(struct device *dev)\n{\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\n\tmutex_lock(&data->update_lock);\n\tdata->scfg1 = w83627hf_read_value(data, W83781D_REG_SCFG1);\n\tdata->scfg2 = w83627hf_read_value(data, W83781D_REG_SCFG2);\n\tmutex_unlock(&data->update_lock);\n\n\treturn 0;\n}\n\nstatic int w83627hf_resume(struct device *dev)\n{\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tint i, num_temps = (data->type == w83697hf) ? 2 : 3;\n\n\t \n\tmutex_lock(&data->update_lock);\n\tfor (i = 0; i <= 8; i++) {\n\t\t \n\t\tif (((data->type == w83697hf) && (i == 1)) ||\n\t\t    ((data->type != w83627hf && data->type != w83697hf)\n\t\t    && (i == 5 || i == 6)))\n\t\t\tcontinue;\n\t\tw83627hf_write_value(data, W83781D_REG_IN_MAX(i),\n\t\t\t\t     data->in_max[i]);\n\t\tw83627hf_write_value(data, W83781D_REG_IN_MIN(i),\n\t\t\t\t     data->in_min[i]);\n\t}\n\tfor (i = 0; i <= 2; i++)\n\t\tw83627hf_write_value(data, W83627HF_REG_FAN_MIN(i),\n\t\t\t\t     data->fan_min[i]);\n\tfor (i = 0; i < num_temps; i++) {\n\t\tw83627hf_write_value(data, w83627hf_reg_temp_over[i],\n\t\t\t\t     data->temp_max[i]);\n\t\tw83627hf_write_value(data, w83627hf_reg_temp_hyst[i],\n\t\t\t\t     data->temp_max_hyst[i]);\n\t}\n\n\t \n\tif (data->type == w83627thf || data->type == w83637hf ||\n\t    data->type == w83687thf)\n\t\tw83627hf_write_value(data, W83627THF_REG_VRM_OVT_CFG,\n\t\t\t\t     data->vrm_ovt);\n\tw83627hf_write_value(data, W83781D_REG_SCFG1, data->scfg1);\n\tw83627hf_write_value(data, W83781D_REG_SCFG2, data->scfg2);\n\n\t \n\tdata->valid = false;\n\tmutex_unlock(&data->update_lock);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops w83627hf_dev_pm_ops = {\n\t.suspend = w83627hf_suspend,\n\t.resume = w83627hf_resume,\n};\n\n#define W83627HF_DEV_PM_OPS\t(&w83627hf_dev_pm_ops)\n#else\n#define W83627HF_DEV_PM_OPS\tNULL\n#endif  \n\nstatic int w83627thf_read_gpio5(struct platform_device *pdev)\n{\n\tstruct w83627hf_sio_data *sio_data = dev_get_platdata(&pdev->dev);\n\tint res = 0xff, sel;\n\n\tif (superio_enter(sio_data)) {\n\t\t \n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Can not read VID data: Failed to enable SuperIO access\\n\");\n\t\treturn res;\n\t}\n\n\tsuperio_select(sio_data, W83627HF_LD_GPIO5);\n\n\tres = 0xff;\n\n\t \n\tif (!(superio_inb(sio_data, W83627THF_GPIO5_EN) & (1<<3))) {\n\t\tdev_dbg(&pdev->dev, \"GPIO5 disabled, no VID function\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tsel = superio_inb(sio_data, W83627THF_GPIO5_IOSR) & 0x3f;\n\tif ((sel & 0x1f) != 0x1f) {\n\t\tdev_dbg(&pdev->dev, \"GPIO5 not configured for VID \"\n\t\t\t\"function\\n\");\n\t\tgoto exit;\n\t}\n\n\tdev_info(&pdev->dev, \"Reading VID from GPIO5\\n\");\n\tres = superio_inb(sio_data, W83627THF_GPIO5_DR) & sel;\n\nexit:\n\tsuperio_exit(sio_data);\n\treturn res;\n}\n\nstatic int w83687thf_read_vid(struct platform_device *pdev)\n{\n\tstruct w83627hf_sio_data *sio_data = dev_get_platdata(&pdev->dev);\n\tint res = 0xff;\n\n\tif (superio_enter(sio_data)) {\n\t\t \n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Can not read VID data: Failed to enable SuperIO access\\n\");\n\t\treturn res;\n\t}\n\n\tsuperio_select(sio_data, W83627HF_LD_HWM);\n\n\t \n\tif (!(superio_inb(sio_data, W83687THF_VID_EN) & (1 << 2))) {\n\t\tdev_dbg(&pdev->dev, \"VID disabled, no VID function\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tif (!(superio_inb(sio_data, W83687THF_VID_CFG) & (1 << 4))) {\n\t\tdev_dbg(&pdev->dev, \"VID configured as output, \"\n\t\t\t\"no VID function\\n\");\n\t\tgoto exit;\n\t}\n\n\tres = superio_inb(sio_data, W83687THF_VID_DATA) & 0x3f;\n\nexit:\n\tsuperio_exit(sio_data);\n\treturn res;\n}\n\nstatic void w83627hf_init_device(struct platform_device *pdev)\n{\n\tstruct w83627hf_data *data = platform_get_drvdata(pdev);\n\tint i;\n\tenum chips type = data->type;\n\tu8 tmp;\n\n\t \n\t \n\t \n\tif (type == w83627hf) {\n\t\tw83627hf_write_value(data, W83781D_REG_I2C_SUBADDR, 0x89);\n\t\tw83627hf_write_value(data, W83781D_REG_I2C_ADDR, force_i2c);\n\t}\n\n\t \n\tif (type == w83627hf || type == w83637hf) {\n\t\tint lo = w83627hf_read_value(data, W83781D_REG_VID_FANDIV);\n\t\tint hi = w83627hf_read_value(data, W83781D_REG_CHIPID);\n\t\tdata->vid = (lo & 0x0f) | ((hi & 0x01) << 4);\n\t} else if (type == w83627thf) {\n\t\tdata->vid = w83627thf_read_gpio5(pdev);\n\t} else if (type == w83687thf) {\n\t\tdata->vid = w83687thf_read_vid(pdev);\n\t}\n\n\t \n\tif (type == w83627thf || type == w83637hf || type == w83687thf) {\n\t\tdata->vrm_ovt =\n\t\t\tw83627hf_read_value(data, W83627THF_REG_VRM_OVT_CFG);\n\t}\n\n\ttmp = w83627hf_read_value(data, W83781D_REG_SCFG1);\n\tfor (i = 1; i <= 3; i++) {\n\t\tif (!(tmp & BIT_SCFG1[i - 1])) {\n\t\t\tdata->sens[i - 1] = 4;\n\t\t} else {\n\t\t\tif (w83627hf_read_value\n\t\t\t    (data,\n\t\t\t     W83781D_REG_SCFG2) & BIT_SCFG2[i - 1])\n\t\t\t\tdata->sens[i - 1] = 1;\n\t\t\telse\n\t\t\t\tdata->sens[i - 1] = 2;\n\t\t}\n\t\tif ((type == w83697hf) && (i == 2))\n\t\t\tbreak;\n\t}\n\n\tif(init) {\n\t\t \n\t\ttmp = w83627hf_read_value(data, W83627HF_REG_TEMP2_CONFIG);\n\t\tif (tmp & 0x01) {\n\t\t\tdev_warn(&pdev->dev, \"Enabling temp2, readings \"\n\t\t\t\t \"might not make sense\\n\");\n\t\t\tw83627hf_write_value(data, W83627HF_REG_TEMP2_CONFIG,\n\t\t\t\ttmp & 0xfe);\n\t\t}\n\n\t\t \n\t\tif (type != w83697hf) {\n\t\t\ttmp = w83627hf_read_value(data,\n\t\t\t\tW83627HF_REG_TEMP3_CONFIG);\n\t\t\tif (tmp & 0x01) {\n\t\t\t\tdev_warn(&pdev->dev, \"Enabling temp3, \"\n\t\t\t\t\t \"readings might not make sense\\n\");\n\t\t\t\tw83627hf_write_value(data,\n\t\t\t\t\tW83627HF_REG_TEMP3_CONFIG, tmp & 0xfe);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tw83627hf_write_value(data, W83781D_REG_CONFIG,\n\t\t\t    (w83627hf_read_value(data,\n\t\t\t\t\t\tW83781D_REG_CONFIG) & 0xf7)\n\t\t\t    | 0x01);\n\n\t \n\ttmp = w83627hf_read_value(data, W83781D_REG_VBAT);\n\tif (!(tmp & 0x01))\n\t\tw83627hf_write_value(data, W83781D_REG_VBAT, tmp | 0x01);\n}\n\n \nstatic ssize_t show_in_0(struct w83627hf_data *data, char *buf, u8 reg)\n{\n\tlong in0;\n\n\tif ((data->vrm_ovt & 0x01) &&\n\t\t(w83627thf == data->type || w83637hf == data->type\n\t\t || w83687thf == data->type))\n\n\t\t \n\t\tin0 = (long)((reg * 488 + 70000 + 50) / 100);\n\telse\n\t\t \n\t\tin0 = (long)IN_FROM_REG(reg);\n\n\treturn sprintf(buf,\"%ld\\n\", in0);\n}\n\nstatic ssize_t in0_input_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn show_in_0(data, buf, data->in[0]);\n}\nstatic DEVICE_ATTR_RO(in0_input);\n\nstatic ssize_t in0_min_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn show_in_0(data, buf, data->in_min[0]);\n}\n\nstatic ssize_t in0_min_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\t\n\tif ((data->vrm_ovt & 0x01) &&\n\t\t(w83627thf == data->type || w83637hf == data->type\n\t\t || w83687thf == data->type))\n\n\t\t \n\t\tdata->in_min[0] =\n\t\t\tclamp_val(((val * 100) - 70000 + 244) / 488, 0, 255);\n\telse\n\t\t \n\t\tdata->in_min[0] = IN_TO_REG(val);\n\n\tw83627hf_write_value(data, W83781D_REG_IN_MIN(0), data->in_min[0]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(in0_min);\n\nstatic ssize_t in0_max_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn show_in_0(data, buf, data->in_max[0]);\n}\n\nstatic ssize_t in0_max_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\tif ((data->vrm_ovt & 0x01) &&\n\t\t(w83627thf == data->type || w83637hf == data->type\n\t\t || w83687thf == data->type))\n\t\t\n\t\t \n\t\tdata->in_max[0] =\n\t\t\tclamp_val(((val * 100) - 70000 + 244) / 488, 0, 255);\n\telse\n\t\t \n\t\tdata->in_max[0] = IN_TO_REG(val);\n\n\tw83627hf_write_value(data, W83781D_REG_IN_MAX(0), data->in_max[0]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(in0_max);\n\nstatic ssize_t\nalarm_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> bitnr) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_alarm, alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_alarm, alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_alarm, alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_alarm, alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_alarm, alarm, 8);\nstatic SENSOR_DEVICE_ATTR_RO(in5_alarm, alarm, 9);\nstatic SENSOR_DEVICE_ATTR_RO(in6_alarm, alarm, 10);\nstatic SENSOR_DEVICE_ATTR_RO(in7_alarm, alarm, 16);\nstatic SENSOR_DEVICE_ATTR_RO(in8_alarm, alarm, 17);\nstatic SENSOR_DEVICE_ATTR_RO(fan1_alarm, alarm, 6);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_alarm, alarm, 7);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_alarm, alarm, 11);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_alarm, alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_alarm, alarm, 5);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_alarm, alarm, 13);\n\nstatic ssize_t\nbeep_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\treturn sprintf(buf, \"%u\\n\", (data->beep_mask >> bitnr) & 1);\n}\n\nstatic ssize_t\nbeep_store(struct device *dev, struct device_attribute *attr, const char *buf,\n\t   size_t count)\n{\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tu8 reg;\n\tunsigned long bit;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &bit);\n\tif (err)\n\t\treturn err;\n\n\tif (bit & ~1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tif (bit)\n\t\tdata->beep_mask |= (1 << bitnr);\n\telse\n\t\tdata->beep_mask &= ~(1 << bitnr);\n\n\tif (bitnr < 8) {\n\t\treg = w83627hf_read_value(data, W83781D_REG_BEEP_INTS1);\n\t\tif (bit)\n\t\t\treg |= (1 << bitnr);\n\t\telse\n\t\t\treg &= ~(1 << bitnr);\n\t\tw83627hf_write_value(data, W83781D_REG_BEEP_INTS1, reg);\n\t} else if (bitnr < 16) {\n\t\treg = w83627hf_read_value(data, W83781D_REG_BEEP_INTS2);\n\t\tif (bit)\n\t\t\treg |= (1 << (bitnr - 8));\n\t\telse\n\t\t\treg &= ~(1 << (bitnr - 8));\n\t\tw83627hf_write_value(data, W83781D_REG_BEEP_INTS2, reg);\n\t} else {\n\t\treg = w83627hf_read_value(data, W83781D_REG_BEEP_INTS3);\n\t\tif (bit)\n\t\t\treg |= (1 << (bitnr - 16));\n\t\telse\n\t\t\treg &= ~(1 << (bitnr - 16));\n\t\tw83627hf_write_value(data, W83781D_REG_BEEP_INTS3, reg);\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(in0_beep, beep, 0);\nstatic SENSOR_DEVICE_ATTR_RW(in1_beep, beep, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in2_beep, beep, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in3_beep, beep, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in4_beep, beep, 8);\nstatic SENSOR_DEVICE_ATTR_RW(in5_beep, beep, 9);\nstatic SENSOR_DEVICE_ATTR_RW(in6_beep, beep, 10);\nstatic SENSOR_DEVICE_ATTR_RW(in7_beep, beep, 16);\nstatic SENSOR_DEVICE_ATTR_RW(in8_beep, beep, 17);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_beep, beep, 6);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_beep, beep, 7);\nstatic SENSOR_DEVICE_ATTR_RW(fan3_beep, beep, 11);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_beep, beep, 4);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_beep, beep, 5);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_beep, beep, 13);\nstatic SENSOR_DEVICE_ATTR_RW(beep_enable, beep, 15);\n\nstatic ssize_t\nin_input_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long)IN_FROM_REG(data->in[nr]));\n}\n\nstatic ssize_t\nin_min_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long)IN_FROM_REG(data->in_min[nr]));\n}\n\nstatic ssize_t\nin_min_store(struct device *dev, struct device_attribute *devattr,\n\t     const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_min[nr] = IN_TO_REG(val);\n\tw83627hf_write_value(data, W83781D_REG_IN_MIN(nr), data->in_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\nin_max_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long)IN_FROM_REG(data->in_max[nr]));\n}\n\nstatic ssize_t\nin_max_store(struct device *dev, struct device_attribute *devattr,\n\t     const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_max[nr] = IN_TO_REG(val);\n\tw83627hf_write_value(data, W83781D_REG_IN_MAX(nr), data->in_max[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, in_input, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in1_min, in_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in1_max, in_max, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, in_input, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in2_min, in_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in2_max, in_max, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, in_input, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in3_min, in_min, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in3_max, in_max, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, in_input, 4);\nstatic SENSOR_DEVICE_ATTR_RW(in4_min, in_min, 4);\nstatic SENSOR_DEVICE_ATTR_RW(in4_max, in_max, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in5_input, in_input, 5);\nstatic SENSOR_DEVICE_ATTR_RW(in5_min, in_min, 5);\nstatic SENSOR_DEVICE_ATTR_RW(in5_max, in_max, 5);\nstatic SENSOR_DEVICE_ATTR_RO(in6_input, in_input, 6);\nstatic SENSOR_DEVICE_ATTR_RW(in6_min, in_min, 6);\nstatic SENSOR_DEVICE_ATTR_RW(in6_max, in_max, 6);\nstatic SENSOR_DEVICE_ATTR_RO(in7_input, in_input, 7);\nstatic SENSOR_DEVICE_ATTR_RW(in7_min, in_min, 7);\nstatic SENSOR_DEVICE_ATTR_RW(in7_max, in_max, 7);\nstatic SENSOR_DEVICE_ATTR_RO(in8_input, in_input, 8);\nstatic SENSOR_DEVICE_ATTR_RW(in8_min, in_min, 8);\nstatic SENSOR_DEVICE_ATTR_RW(in8_max, in_max, 8);\n\nstatic ssize_t\nfan_input_show(struct device *dev, struct device_attribute *devattr,\n\t       char *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", FAN_FROM_REG(data->fan[nr],\n\t\t\t\t(long)DIV_FROM_REG(data->fan_div[nr])));\n}\n\nstatic ssize_t\nfan_min_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", FAN_FROM_REG(data->fan_min[nr],\n\t\t\t\t(long)DIV_FROM_REG(data->fan_div[nr])));\n}\n\nstatic ssize_t\nfan_min_store(struct device *dev, struct device_attribute *devattr,\n\t      const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\n\tw83627hf_write_value(data, W83627HF_REG_FAN_MIN(nr),\n\t\t\t     data->fan_min[nr]);\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan_input, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_min, fan_min, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan_input, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_min, fan_min, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_input, fan_input, 2);\nstatic SENSOR_DEVICE_ATTR_RW(fan3_min, fan_min, 2);\n\nstatic ssize_t\nfan_div_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\",\n\t\t       (long) DIV_FROM_REG(data->fan_div[nr]));\n}\n\n \nstatic ssize_t\nfan_div_store(struct device *dev, struct device_attribute *devattr,\n\t      const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tunsigned long min;\n\tu8 reg;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tmin = FAN_FROM_REG(data->fan_min[nr],\n\t\t\t   DIV_FROM_REG(data->fan_div[nr]));\n\n\tdata->fan_div[nr] = DIV_TO_REG(val);\n\n\treg = (w83627hf_read_value(data, nr==2 ? W83781D_REG_PIN : W83781D_REG_VID_FANDIV)\n\t       & (nr==0 ? 0xcf : 0x3f))\n\t    | ((data->fan_div[nr] & 0x03) << (nr==0 ? 4 : 6));\n\tw83627hf_write_value(data, nr==2 ? W83781D_REG_PIN : W83781D_REG_VID_FANDIV, reg);\n\n\treg = (w83627hf_read_value(data, W83781D_REG_VBAT)\n\t       & ~(1 << (5 + nr)))\n\t    | ((data->fan_div[nr] & 0x04) << (3 + nr));\n\tw83627hf_write_value(data, W83781D_REG_VBAT, reg);\n\n\t \n\tdata->fan_min[nr] = FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\n\tw83627hf_write_value(data, W83627HF_REG_FAN_MIN(nr), data->fan_min[nr]);\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(fan1_div, fan_div, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_div, fan_div, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan3_div, fan_div, 2);\n\nstatic ssize_t\ntemp_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\n\tu16 tmp = data->temp[nr];\n\treturn sprintf(buf, \"%ld\\n\", (nr) ? (long) LM75_TEMP_FROM_REG(tmp)\n\t\t\t\t\t  : (long) TEMP_FROM_REG(tmp));\n}\n\nstatic ssize_t\ntemp_max_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\n\tu16 tmp = data->temp_max[nr];\n\treturn sprintf(buf, \"%ld\\n\", (nr) ? (long) LM75_TEMP_FROM_REG(tmp)\n\t\t\t\t\t  : (long) TEMP_FROM_REG(tmp));\n}\n\nstatic ssize_t\ntemp_max_store(struct device *dev, struct device_attribute *devattr,\n\t       const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tu16 tmp;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\ttmp = (nr) ? LM75_TEMP_TO_REG(val) : TEMP_TO_REG(val);\n\tmutex_lock(&data->update_lock);\n\tdata->temp_max[nr] = tmp;\n\tw83627hf_write_value(data, w83627hf_reg_temp_over[nr], tmp);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\ntemp_max_hyst_show(struct device *dev, struct device_attribute *devattr,\n\t\t   char *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\n\tu16 tmp = data->temp_max_hyst[nr];\n\treturn sprintf(buf, \"%ld\\n\", (nr) ? (long) LM75_TEMP_FROM_REG(tmp)\n\t\t\t\t\t  : (long) TEMP_FROM_REG(tmp));\n}\n\nstatic ssize_t\ntemp_max_hyst_store(struct device *dev, struct device_attribute *devattr,\n\t\t    const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tu16 tmp;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\ttmp = (nr) ? LM75_TEMP_TO_REG(val) : TEMP_TO_REG(val);\n\tmutex_lock(&data->update_lock);\n\tdata->temp_max_hyst[nr] = tmp;\n\tw83627hf_write_value(data, w83627hf_reg_temp_hyst[nr], tmp);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp_max, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max_hyst, temp_max_hyst, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp_max, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max_hyst, temp_max_hyst, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_max, temp_max, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_max_hyst, temp_max_hyst, 2);\n\nstatic ssize_t\ntemp_type_show(struct device *dev, struct device_attribute *devattr,\n\t       char *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long) data->sens[nr]);\n}\n\nstatic ssize_t\ntemp_type_store(struct device *dev, struct device_attribute *devattr,\n\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tu32 tmp;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (val) {\n\tcase 1:\t\t \n\t\ttmp = w83627hf_read_value(data, W83781D_REG_SCFG1);\n\t\tw83627hf_write_value(data, W83781D_REG_SCFG1,\n\t\t\t\t    tmp | BIT_SCFG1[nr]);\n\t\ttmp = w83627hf_read_value(data, W83781D_REG_SCFG2);\n\t\tw83627hf_write_value(data, W83781D_REG_SCFG2,\n\t\t\t\t    tmp | BIT_SCFG2[nr]);\n\t\tdata->sens[nr] = val;\n\t\tbreak;\n\tcase 2:\t\t \n\t\ttmp = w83627hf_read_value(data, W83781D_REG_SCFG1);\n\t\tw83627hf_write_value(data, W83781D_REG_SCFG1,\n\t\t\t\t    tmp | BIT_SCFG1[nr]);\n\t\ttmp = w83627hf_read_value(data, W83781D_REG_SCFG2);\n\t\tw83627hf_write_value(data, W83781D_REG_SCFG2,\n\t\t\t\t    tmp & ~BIT_SCFG2[nr]);\n\t\tdata->sens[nr] = val;\n\t\tbreak;\n\tcase W83781D_DEFAULT_BETA:\n\t\tdev_warn(dev, \"Sensor type %d is deprecated, please use 4 \"\n\t\t\t \"instead\\n\", W83781D_DEFAULT_BETA);\n\t\tfallthrough;\n\tcase 4:\t\t \n\t\ttmp = w83627hf_read_value(data, W83781D_REG_SCFG1);\n\t\tw83627hf_write_value(data, W83781D_REG_SCFG1,\n\t\t\t\t    tmp & ~BIT_SCFG1[nr]);\n\t\tdata->sens[nr] = val;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev,\n\t\t       \"Invalid sensor type %ld; must be 1, 2, or 4\\n\",\n\t\t       (long) val);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_type, temp_type, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_type, temp_type, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_type, temp_type, 2);\n\nstatic ssize_t\nalarms_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long) data->alarms);\n}\nstatic DEVICE_ATTR_RO(alarms);\n\n#define VIN_UNIT_ATTRS(_X_)\t\\\n\t&sensor_dev_attr_in##_X_##_input.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_in##_X_##_min.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_in##_X_##_max.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_in##_X_##_alarm.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_in##_X_##_beep.dev_attr.attr\n\n#define FAN_UNIT_ATTRS(_X_)\t\\\n\t&sensor_dev_attr_fan##_X_##_input.dev_attr.attr,\t\\\n\t&sensor_dev_attr_fan##_X_##_min.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_fan##_X_##_div.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_fan##_X_##_alarm.dev_attr.attr,\t\\\n\t&sensor_dev_attr_fan##_X_##_beep.dev_attr.attr\n\n#define TEMP_UNIT_ATTRS(_X_)\t\\\n\t&sensor_dev_attr_temp##_X_##_input.dev_attr.attr,\t\\\n\t&sensor_dev_attr_temp##_X_##_max.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_temp##_X_##_max_hyst.dev_attr.attr,\t\\\n\t&sensor_dev_attr_temp##_X_##_type.dev_attr.attr,\t\\\n\t&sensor_dev_attr_temp##_X_##_alarm.dev_attr.attr,\t\\\n\t&sensor_dev_attr_temp##_X_##_beep.dev_attr.attr\n\nstatic ssize_t\nbeep_mask_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\",\n\t\t      (long)BEEP_MASK_FROM_REG(data->beep_mask));\n}\n\nstatic ssize_t\nbeep_mask_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tdata->beep_mask = (data->beep_mask & 0x8000)\n\t\t\t| BEEP_MASK_TO_REG(val);\n\tw83627hf_write_value(data, W83781D_REG_BEEP_INTS1,\n\t\t\t    data->beep_mask & 0xff);\n\tw83627hf_write_value(data, W83781D_REG_BEEP_INTS3,\n\t\t\t    ((data->beep_mask) >> 16) & 0xff);\n\tw83627hf_write_value(data, W83781D_REG_BEEP_INTS2,\n\t\t\t    (data->beep_mask >> 8) & 0xff);\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(beep_mask);\n\nstatic ssize_t\npwm_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long) data->pwm[nr]);\n}\n\nstatic ssize_t\npwm_store(struct device *dev, struct device_attribute *devattr,\n\t  const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (data->type == w83627thf) {\n\t\t \n\t\tdata->pwm[nr] = PWM_TO_REG(val) & 0xf0;\n\t\tw83627hf_write_value(data,\n\t\t\t\t     W836X7HF_REG_PWM(data->type, nr),\n\t\t\t\t     data->pwm[nr] |\n\t\t\t\t     (w83627hf_read_value(data,\n\t\t\t\t     W836X7HF_REG_PWM(data->type, nr)) & 0x0f));\n\t} else {\n\t\tdata->pwm[nr] = PWM_TO_REG(val);\n\t\tw83627hf_write_value(data,\n\t\t\t\t     W836X7HF_REG_PWM(data->type, nr),\n\t\t\t\t     data->pwm[nr]);\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1, pwm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2, pwm, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3, pwm, 2);\n\nstatic ssize_t\nname_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", data->name);\n}\n\nstatic DEVICE_ATTR_RO(name);\n\nstatic struct attribute *w83627hf_attributes[] = {\n\t&dev_attr_in0_input.attr,\n\t&dev_attr_in0_min.attr,\n\t&dev_attr_in0_max.attr,\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in0_beep.dev_attr.attr,\n\tVIN_UNIT_ATTRS(2),\n\tVIN_UNIT_ATTRS(3),\n\tVIN_UNIT_ATTRS(4),\n\tVIN_UNIT_ATTRS(7),\n\tVIN_UNIT_ATTRS(8),\n\n\tFAN_UNIT_ATTRS(1),\n\tFAN_UNIT_ATTRS(2),\n\n\tTEMP_UNIT_ATTRS(1),\n\tTEMP_UNIT_ATTRS(2),\n\n\t&dev_attr_alarms.attr,\n\t&sensor_dev_attr_beep_enable.dev_attr.attr,\n\t&dev_attr_beep_mask.attr,\n\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&dev_attr_name.attr,\n\tNULL\n};\n\nstatic const struct attribute_group w83627hf_group = {\n\t.attrs = w83627hf_attributes,\n};\n\nstatic ssize_t\npwm_freq_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\tif (data->type == w83627hf)\n\t\treturn sprintf(buf, \"%ld\\n\",\n\t\t\tpwm_freq_from_reg_627hf(data->pwm_freq[nr]));\n\telse\n\t\treturn sprintf(buf, \"%ld\\n\",\n\t\t\tpwm_freq_from_reg(data->pwm_freq[nr]));\n}\n\nstatic ssize_t\npwm_freq_store(struct device *dev, struct device_attribute *devattr,\n\t       const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tstatic const u8 mask[]={0xF8, 0x8F};\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (data->type == w83627hf) {\n\t\tdata->pwm_freq[nr] = pwm_freq_to_reg_627hf(val);\n\t\tw83627hf_write_value(data, W83627HF_REG_PWM_FREQ,\n\t\t\t\t(data->pwm_freq[nr] << (nr*4)) |\n\t\t\t\t(w83627hf_read_value(data,\n\t\t\t\tW83627HF_REG_PWM_FREQ) & mask[nr]));\n\t} else {\n\t\tdata->pwm_freq[nr] = pwm_freq_to_reg(val);\n\t\tw83627hf_write_value(data, W83637HF_REG_PWM_FREQ[nr],\n\t\t\t\tdata->pwm_freq[nr]);\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_freq, pwm_freq, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_freq, pwm_freq, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_freq, pwm_freq, 2);\n\nstatic ssize_t\ncpu0_vid_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long) vid_from_reg(data->vid, data->vrm));\n}\n\nstatic DEVICE_ATTR_RO(cpu0_vid);\n\nstatic ssize_t\nvrm_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long) data->vrm);\n}\n\nstatic ssize_t\nvrm_store(struct device *dev, struct device_attribute *attr, const char *buf,\n\t  size_t count)\n{\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 255)\n\t\treturn -EINVAL;\n\tdata->vrm = val;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(vrm);\n\nstatic ssize_t\npwm_enable_show(struct device *dev, struct device_attribute *devattr,\n\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = w83627hf_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm_enable[nr]);\n}\n\nstatic ssize_t\npwm_enable_store(struct device *dev, struct device_attribute *devattr,\n\t\t const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(devattr)->index;\n\tstruct w83627hf_data *data = dev_get_drvdata(dev);\n\tu8 reg;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (!val || val > 3)\t \n\t\treturn -EINVAL;\n\tmutex_lock(&data->update_lock);\n\tdata->pwm_enable[nr] = val;\n\treg = w83627hf_read_value(data, W83627THF_REG_PWM_ENABLE[nr]);\n\treg &= ~(0x03 << W83627THF_PWM_ENABLE_SHIFT[nr]);\n\treg |= (val - 1) << W83627THF_PWM_ENABLE_SHIFT[nr];\n\tw83627hf_write_value(data, W83627THF_REG_PWM_ENABLE[nr], reg);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_enable, pwm_enable, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_enable, pwm_enable, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_enable, pwm_enable, 2);\n\nstatic struct attribute *w83627hf_attributes_opt[] = {\n\tVIN_UNIT_ATTRS(1),\n\tVIN_UNIT_ATTRS(5),\n\tVIN_UNIT_ATTRS(6),\n\n\tFAN_UNIT_ATTRS(3),\n\tTEMP_UNIT_ATTRS(3),\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm1_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_freq.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\n\tNULL\n};\n\nstatic const struct attribute_group w83627hf_group_opt = {\n\t.attrs = w83627hf_attributes_opt,\n};\n\nstatic int w83627hf_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct w83627hf_sio_data *sio_data = dev_get_platdata(dev);\n\tstruct w83627hf_data *data;\n\tstruct resource *res;\n\tint err, i;\n\n\tstatic const char *names[] = {\n\t\t\"w83627hf\",\n\t\t\"w83627thf\",\n\t\t\"w83697hf\",\n\t\t\"w83637hf\",\n\t\t\"w83687thf\",\n\t};\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!devm_request_region(dev, res->start, WINB_REGION_SIZE, DRVNAME)) {\n\t\tdev_err(dev, \"Failed to request region 0x%lx-0x%lx\\n\",\n\t\t\t(unsigned long)res->start,\n\t\t\t(unsigned long)(res->start + WINB_REGION_SIZE - 1));\n\t\treturn -EBUSY;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(struct w83627hf_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->addr = res->start;\n\tdata->type = sio_data->type;\n\tdata->name = names[sio_data->type];\n\tmutex_init(&data->lock);\n\tmutex_init(&data->update_lock);\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tw83627hf_init_device(pdev);\n\n\t \n\tfor (i = 0; i <= 2; i++)\n\t\tdata->fan_min[i] = w83627hf_read_value(\n\t\t\t\t\tdata, W83627HF_REG_FAN_MIN(i));\n\tw83627hf_update_fan_div(data);\n\n\t \n\terr = sysfs_create_group(&dev->kobj, &w83627hf_group);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (data->type == w83627hf || data->type == w83697hf)\n\t\tif ((err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in5_input.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in5_min.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in5_max.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in5_alarm.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in5_beep.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in6_input.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in6_min.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in6_max.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in6_alarm.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in6_beep.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_pwm1_freq.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_pwm2_freq.dev_attr)))\n\t\t\tgoto error;\n\n\tif (data->type != w83697hf)\n\t\tif ((err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in1_input.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in1_min.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in1_max.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in1_alarm.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_in1_beep.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_fan3_input.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_fan3_min.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_fan3_div.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_fan3_alarm.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_fan3_beep.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_temp3_input.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_temp3_max.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_temp3_max_hyst.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_temp3_alarm.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_temp3_beep.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_temp3_type.dev_attr)))\n\t\t\tgoto error;\n\n\tif (data->type != w83697hf && data->vid != 0xff) {\n\t\t \n\t\tdata->vrm = vid_which_vrm();\n\n\t\tif ((err = device_create_file(dev, &dev_attr_cpu0_vid))\n\t\t || (err = device_create_file(dev, &dev_attr_vrm)))\n\t\t\tgoto error;\n\t}\n\n\tif (data->type == w83627thf || data->type == w83637hf\n\t    || data->type == w83687thf) {\n\t\terr = device_create_file(dev, &sensor_dev_attr_pwm3.dev_attr);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\tif (data->type == w83637hf || data->type == w83687thf)\n\t\tif ((err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_pwm1_freq.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_pwm2_freq.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_pwm3_freq.dev_attr)))\n\t\t\tgoto error;\n\n\tif (data->type != w83627hf)\n\t\tif ((err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_pwm1_enable.dev_attr))\n\t\t || (err = device_create_file(dev,\n\t\t\t\t&sensor_dev_attr_pwm2_enable.dev_attr)))\n\t\t\tgoto error;\n\n\tif (data->type == w83627thf || data->type == w83637hf\n\t    || data->type == w83687thf) {\n\t\terr = device_create_file(dev,\n\t\t\t\t\t &sensor_dev_attr_pwm3_enable.dev_attr);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\tdata->hwmon_dev = hwmon_device_register(dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\n error:\n\tsysfs_remove_group(&dev->kobj, &w83627hf_group);\n\tsysfs_remove_group(&dev->kobj, &w83627hf_group_opt);\n\treturn err;\n}\n\nstatic int w83627hf_remove(struct platform_device *pdev)\n{\n\tstruct w83627hf_data *data = platform_get_drvdata(pdev);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\n\tsysfs_remove_group(&pdev->dev.kobj, &w83627hf_group);\n\tsysfs_remove_group(&pdev->dev.kobj, &w83627hf_group_opt);\n\n\treturn 0;\n}\n\nstatic struct platform_driver w83627hf_driver = {\n\t.driver = {\n\t\t.name\t= DRVNAME,\n\t\t.pm\t= W83627HF_DEV_PM_OPS,\n\t},\n\t.probe\t\t= w83627hf_probe,\n\t.remove\t\t= w83627hf_remove,\n};\n\nstatic int __init w83627hf_find(int sioaddr, unsigned short *addr,\n\t\t\t\tstruct w83627hf_sio_data *sio_data)\n{\n\tint err;\n\tu16 val;\n\n\tstatic __initconst char *const names[] = {\n\t\t\"W83627HF\",\n\t\t\"W83627THF\",\n\t\t\"W83697HF\",\n\t\t\"W83637HF\",\n\t\t\"W83687THF\",\n\t};\n\n\tsio_data->sioaddr = sioaddr;\n\terr = superio_enter(sio_data);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENODEV;\n\tval = force_id ? force_id : superio_inb(sio_data, DEVID);\n\tswitch (val) {\n\tcase W627_DEVID:\n\t\tsio_data->type = w83627hf;\n\t\tbreak;\n\tcase W627THF_DEVID:\n\t\tsio_data->type = w83627thf;\n\t\tbreak;\n\tcase W697_DEVID:\n\t\tsio_data->type = w83697hf;\n\t\tbreak;\n\tcase W637_DEVID:\n\t\tsio_data->type = w83637hf;\n\t\tbreak;\n\tcase W687THF_DEVID:\n\t\tsio_data->type = w83687thf;\n\t\tbreak;\n\tcase 0xff:\t \n\t\tgoto exit;\n\tdefault:\n\t\tpr_debug(DRVNAME \": Unsupported chip (DEVID=0x%02x)\\n\", val);\n\t\tgoto exit;\n\t}\n\n\tsuperio_select(sio_data, W83627HF_LD_HWM);\n\tval = (superio_inb(sio_data, WINB_BASE_REG) << 8) |\n\t       superio_inb(sio_data, WINB_BASE_REG + 1);\n\t*addr = val & WINB_ALIGNMENT;\n\tif (*addr == 0) {\n\t\tpr_warn(\"Base address not set, skipping\\n\");\n\t\tgoto exit;\n\t}\n\n\tval = superio_inb(sio_data, WINB_ACT_REG);\n\tif (!(val & 0x01)) {\n\t\tpr_warn(\"Enabling HWM logical device\\n\");\n\t\tsuperio_outb(sio_data, WINB_ACT_REG, val | 0x01);\n\t}\n\n\terr = 0;\n\tpr_info(DRVNAME \": Found %s chip at %#x\\n\",\n\t\tnames[sio_data->type], *addr);\n\n exit:\n\tsuperio_exit(sio_data);\n\treturn err;\n}\n\nstatic int __init w83627hf_device_add(unsigned short address,\n\t\t\t\t      const struct w83627hf_sio_data *sio_data)\n{\n\tstruct resource res = {\n\t\t.start\t= address + WINB_REGION_OFFSET,\n\t\t.end\t= address + WINB_REGION_OFFSET + WINB_REGION_SIZE - 1,\n\t\t.name\t= DRVNAME,\n\t\t.flags\t= IORESOURCE_IO,\n\t};\n\tint err;\n\n\terr = acpi_check_resource_conflict(&res);\n\tif (err)\n\t\tgoto exit;\n\n\tpdev = platform_device_alloc(DRVNAME, address);\n\tif (!pdev) {\n\t\terr = -ENOMEM;\n\t\tpr_err(\"Device allocation failed\\n\");\n\t\tgoto exit;\n\t}\n\n\terr = platform_device_add_resources(pdev, &res, 1);\n\tif (err) {\n\t\tpr_err(\"Device resource addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add_data(pdev, sio_data,\n\t\t\t\t       sizeof(struct w83627hf_sio_data));\n\tif (err) {\n\t\tpr_err(\"Platform data allocation failed\\n\");\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n\t\tpr_err(\"Device addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\treturn 0;\n\nexit_device_put:\n\tplatform_device_put(pdev);\nexit:\n\treturn err;\n}\n\nstatic int __init sensors_w83627hf_init(void)\n{\n\tint err;\n\tunsigned short address;\n\tstruct w83627hf_sio_data sio_data;\n\n\tif (w83627hf_find(0x2e, &address, &sio_data)\n\t && w83627hf_find(0x4e, &address, &sio_data))\n\t\treturn -ENODEV;\n\n\terr = platform_driver_register(&w83627hf_driver);\n\tif (err)\n\t\tgoto exit;\n\n\t \n\terr = w83627hf_device_add(address, &sio_data);\n\tif (err)\n\t\tgoto exit_driver;\n\n\treturn 0;\n\nexit_driver:\n\tplatform_driver_unregister(&w83627hf_driver);\nexit:\n\treturn err;\n}\n\nstatic void __exit sensors_w83627hf_exit(void)\n{\n\tplatform_device_unregister(pdev);\n\tplatform_driver_unregister(&w83627hf_driver);\n}\n\nMODULE_AUTHOR(\"Frodo Looijaard <frodol@dds.nl>, \"\n\t      \"Philip Edelbrock <phil@netroedge.com>, \"\n\t      \"and Mark Studebaker <mdsxyz123@yahoo.com>\");\nMODULE_DESCRIPTION(\"W83627HF driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(sensors_w83627hf_init);\nmodule_exit(sensors_w83627hf_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}