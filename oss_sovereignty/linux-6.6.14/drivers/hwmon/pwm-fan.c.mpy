{
  "module_name": "pwm-fan.c",
  "hash_id": "8898ae563f8cad0c31d7ca987c847357ad68d02e53bd13f10525197a00b98ae9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pwm-fan.c",
  "human_readable_source": "\n \n\n#include <linux/hwmon.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sysfs.h>\n#include <linux/thermal.h>\n#include <linux/timer.h>\n\n#define MAX_PWM 255\n\nstruct pwm_fan_tach {\n\tint irq;\n\tatomic_t pulses;\n\tunsigned int rpm;\n\tu8 pulses_per_revolution;\n};\n\nenum pwm_fan_enable_mode {\n\tpwm_off_reg_off,\n\tpwm_disable_reg_enable,\n\tpwm_enable_reg_enable,\n\tpwm_disable_reg_disable,\n};\n\nstruct pwm_fan_ctx {\n\tstruct device *dev;\n\n\tstruct mutex lock;\n\tstruct pwm_device *pwm;\n\tstruct pwm_state pwm_state;\n\tstruct regulator *reg_en;\n\tenum pwm_fan_enable_mode enable_mode;\n\tbool regulator_enabled;\n\tbool enabled;\n\n\tint tach_count;\n\tstruct pwm_fan_tach *tachs;\n\tktime_t sample_start;\n\tstruct timer_list rpm_timer;\n\n\tunsigned int pwm_value;\n\tunsigned int pwm_fan_state;\n\tunsigned int pwm_fan_max_state;\n\tunsigned int *pwm_fan_cooling_levels;\n\tstruct thermal_cooling_device *cdev;\n\n\tstruct hwmon_chip_info info;\n\tstruct hwmon_channel_info fan_channel;\n};\n\n \nstatic irqreturn_t pulse_handler(int irq, void *dev_id)\n{\n\tstruct pwm_fan_tach *tach = dev_id;\n\n\tatomic_inc(&tach->pulses);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sample_timer(struct timer_list *t)\n{\n\tstruct pwm_fan_ctx *ctx = from_timer(ctx, t, rpm_timer);\n\tunsigned int delta = ktime_ms_delta(ktime_get(), ctx->sample_start);\n\tint i;\n\n\tif (delta) {\n\t\tfor (i = 0; i < ctx->tach_count; i++) {\n\t\t\tstruct pwm_fan_tach *tach = &ctx->tachs[i];\n\t\t\tint pulses;\n\n\t\t\tpulses = atomic_read(&tach->pulses);\n\t\t\tatomic_sub(pulses, &tach->pulses);\n\t\t\ttach->rpm = (unsigned int)(pulses * 1000 * 60) /\n\t\t\t\t(tach->pulses_per_revolution * delta);\n\t\t}\n\n\t\tctx->sample_start = ktime_get();\n\t}\n\n\tmod_timer(&ctx->rpm_timer, jiffies + HZ);\n}\n\nstatic void pwm_fan_enable_mode_2_state(int enable_mode,\n\t\t\t\t\tstruct pwm_state *state,\n\t\t\t\t\tbool *enable_regulator)\n{\n\tswitch (enable_mode) {\n\tcase pwm_disable_reg_enable:\n\t\t \n\t\tstate->enabled = false;\n\t\t*enable_regulator = true;\n\t\tbreak;\n\tcase pwm_enable_reg_enable:\n\t\t \n\t\tstate->enabled = true;\n\t\t*enable_regulator = true;\n\t\tbreak;\n\tcase pwm_off_reg_off:\n\tcase pwm_disable_reg_disable:\n\t\t \n\t\tstate->enabled = false;\n\t\t*enable_regulator = false;\n\t}\n}\n\nstatic int pwm_fan_switch_power(struct pwm_fan_ctx *ctx, bool on)\n{\n\tint ret = 0;\n\n\tif (!ctx->reg_en)\n\t\treturn ret;\n\n\tif (!ctx->regulator_enabled && on) {\n\t\tret = regulator_enable(ctx->reg_en);\n\t\tif (ret == 0)\n\t\t\tctx->regulator_enabled = true;\n\t} else if (ctx->regulator_enabled && !on) {\n\t\tret = regulator_disable(ctx->reg_en);\n\t\tif (ret == 0)\n\t\t\tctx->regulator_enabled = false;\n\t}\n\treturn ret;\n}\n\nstatic int pwm_fan_power_on(struct pwm_fan_ctx *ctx)\n{\n\tstruct pwm_state *state = &ctx->pwm_state;\n\tint ret;\n\n\tif (ctx->enabled)\n\t\treturn 0;\n\n\tret = pwm_fan_switch_power(ctx, true);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"failed to enable power supply\\n\");\n\t\treturn ret;\n\t}\n\n\tstate->enabled = true;\n\tret = pwm_apply_state(ctx->pwm, state);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"failed to enable PWM\\n\");\n\t\tgoto disable_regulator;\n\t}\n\n\tctx->enabled = true;\n\n\treturn 0;\n\ndisable_regulator:\n\tpwm_fan_switch_power(ctx, false);\n\treturn ret;\n}\n\nstatic int pwm_fan_power_off(struct pwm_fan_ctx *ctx)\n{\n\tstruct pwm_state *state = &ctx->pwm_state;\n\tbool enable_regulator = false;\n\tint ret;\n\n\tif (!ctx->enabled)\n\t\treturn 0;\n\n\tpwm_fan_enable_mode_2_state(ctx->enable_mode,\n\t\t\t\t    state,\n\t\t\t\t    &enable_regulator);\n\n\tstate->enabled = false;\n\tstate->duty_cycle = 0;\n\tret = pwm_apply_state(ctx->pwm, state);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"failed to disable PWM\\n\");\n\t\treturn ret;\n\t}\n\n\tpwm_fan_switch_power(ctx, enable_regulator);\n\n\tctx->enabled = false;\n\n\treturn 0;\n}\n\nstatic int  __set_pwm(struct pwm_fan_ctx *ctx, unsigned long pwm)\n{\n\tstruct pwm_state *state = &ctx->pwm_state;\n\tunsigned long period;\n\tint ret = 0;\n\n\tif (pwm > 0) {\n\t\tif (ctx->enable_mode == pwm_off_reg_off)\n\t\t\t \n\t\t\treturn 0;\n\n\t\tperiod = state->period;\n\t\tstate->duty_cycle = DIV_ROUND_UP(pwm * (period - 1), MAX_PWM);\n\t\tret = pwm_apply_state(ctx->pwm, state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = pwm_fan_power_on(ctx);\n\t} else {\n\t\tret = pwm_fan_power_off(ctx);\n\t}\n\tif (!ret)\n\t\tctx->pwm_value = pwm;\n\n\treturn ret;\n}\n\nstatic int set_pwm(struct pwm_fan_ctx *ctx, unsigned long pwm)\n{\n\tint ret;\n\n\tmutex_lock(&ctx->lock);\n\tret = __set_pwm(ctx, pwm);\n\tmutex_unlock(&ctx->lock);\n\n\treturn ret;\n}\n\nstatic void pwm_fan_update_state(struct pwm_fan_ctx *ctx, unsigned long pwm)\n{\n\tint i;\n\n\tfor (i = 0; i < ctx->pwm_fan_max_state; ++i)\n\t\tif (pwm < ctx->pwm_fan_cooling_levels[i + 1])\n\t\t\tbreak;\n\n\tctx->pwm_fan_state = i;\n}\n\nstatic int pwm_fan_update_enable(struct pwm_fan_ctx *ctx, long val)\n{\n\tint ret = 0;\n\tint old_val;\n\n\tmutex_lock(&ctx->lock);\n\n\tif (ctx->enable_mode == val)\n\t\tgoto out;\n\n\told_val = ctx->enable_mode;\n\tctx->enable_mode = val;\n\n\tif (val == 0) {\n\t\t \n\t\tif (ctx->enabled)\n\t\t\tret = __set_pwm(ctx, 0);\n\t\telse\n\t\t\tret = pwm_fan_switch_power(ctx, false);\n\t\tif (ret)\n\t\t\tctx->enable_mode = old_val;\n\t\tpwm_fan_update_state(ctx, 0);\n\t} else {\n\t\t \n\t\tif (!ctx->enabled) {\n\t\t\tstruct pwm_state *state = &ctx->pwm_state;\n\t\t\tbool enable_regulator = false;\n\n\t\t\tstate->duty_cycle = 0;\n\t\t\tpwm_fan_enable_mode_2_state(val,\n\t\t\t\t\t\t    state,\n\t\t\t\t\t\t    &enable_regulator);\n\n\t\t\tpwm_apply_state(ctx->pwm, state);\n\t\t\tpwm_fan_switch_power(ctx, enable_regulator);\n\t\t\tpwm_fan_update_state(ctx, 0);\n\t\t}\n\t}\nout:\n\tmutex_unlock(&ctx->lock);\n\n\treturn ret;\n}\n\nstatic int pwm_fan_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long val)\n{\n\tstruct pwm_fan_ctx *ctx = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\tif (val < 0 || val > MAX_PWM)\n\t\t\treturn -EINVAL;\n\t\tret = set_pwm(ctx, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpwm_fan_update_state(ctx, val);\n\t\tbreak;\n\tcase hwmon_pwm_enable:\n\t\tif (val < 0 || val > 3)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = pwm_fan_update_enable(ctx, val);\n\n\t\treturn ret;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int pwm_fan_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct pwm_fan_ctx *ctx = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\t*val = ctx->pwm_value;\n\t\t\treturn 0;\n\t\tcase hwmon_pwm_enable:\n\t\t\t*val = ctx->enable_mode;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EOPNOTSUPP;\n\tcase hwmon_fan:\n\t\t*val = ctx->tachs[channel].rpm;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic umode_t pwm_fan_is_visible(const void *data,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\treturn 0644;\n\n\tcase hwmon_fan:\n\t\treturn 0444;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct hwmon_ops pwm_fan_hwmon_ops = {\n\t.is_visible = pwm_fan_is_visible,\n\t.read = pwm_fan_read,\n\t.write = pwm_fan_write,\n};\n\n \nstatic int pwm_fan_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long *state)\n{\n\tstruct pwm_fan_ctx *ctx = cdev->devdata;\n\n\tif (!ctx)\n\t\treturn -EINVAL;\n\n\t*state = ctx->pwm_fan_max_state;\n\n\treturn 0;\n}\n\nstatic int pwm_fan_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long *state)\n{\n\tstruct pwm_fan_ctx *ctx = cdev->devdata;\n\n\tif (!ctx)\n\t\treturn -EINVAL;\n\n\t*state = ctx->pwm_fan_state;\n\n\treturn 0;\n}\n\nstatic int\npwm_fan_set_cur_state(struct thermal_cooling_device *cdev, unsigned long state)\n{\n\tstruct pwm_fan_ctx *ctx = cdev->devdata;\n\tint ret;\n\n\tif (!ctx || (state > ctx->pwm_fan_max_state))\n\t\treturn -EINVAL;\n\n\tif (state == ctx->pwm_fan_state)\n\t\treturn 0;\n\n\tret = set_pwm(ctx, ctx->pwm_fan_cooling_levels[state]);\n\tif (ret) {\n\t\tdev_err(&cdev->device, \"Cannot set pwm!\\n\");\n\t\treturn ret;\n\t}\n\n\tctx->pwm_fan_state = state;\n\n\treturn ret;\n}\n\nstatic const struct thermal_cooling_device_ops pwm_fan_cooling_ops = {\n\t.get_max_state = pwm_fan_get_max_state,\n\t.get_cur_state = pwm_fan_get_cur_state,\n\t.set_cur_state = pwm_fan_set_cur_state,\n};\n\nstatic int pwm_fan_of_get_cooling_data(struct device *dev,\n\t\t\t\t       struct pwm_fan_ctx *ctx)\n{\n\tstruct device_node *np = dev->of_node;\n\tint num, i, ret;\n\n\tif (!of_property_present(np, \"cooling-levels\"))\n\t\treturn 0;\n\n\tret = of_property_count_u32_elems(np, \"cooling-levels\");\n\tif (ret <= 0) {\n\t\tdev_err(dev, \"Wrong data!\\n\");\n\t\treturn ret ? : -EINVAL;\n\t}\n\n\tnum = ret;\n\tctx->pwm_fan_cooling_levels = devm_kcalloc(dev, num, sizeof(u32),\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (!ctx->pwm_fan_cooling_levels)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32_array(np, \"cooling-levels\",\n\t\t\t\t\t ctx->pwm_fan_cooling_levels, num);\n\tif (ret) {\n\t\tdev_err(dev, \"Property 'cooling-levels' cannot be read!\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (ctx->pwm_fan_cooling_levels[i] > MAX_PWM) {\n\t\t\tdev_err(dev, \"PWM fan state[%d]:%d > %d\\n\", i,\n\t\t\t\tctx->pwm_fan_cooling_levels[i], MAX_PWM);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tctx->pwm_fan_max_state = num - 1;\n\n\treturn 0;\n}\n\nstatic void pwm_fan_cleanup(void *__ctx)\n{\n\tstruct pwm_fan_ctx *ctx = __ctx;\n\n\tdel_timer_sync(&ctx->rpm_timer);\n\t \n\tctx->enable_mode = pwm_disable_reg_disable;\n\tpwm_fan_power_off(ctx);\n}\n\nstatic int pwm_fan_probe(struct platform_device *pdev)\n{\n\tstruct thermal_cooling_device *cdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct pwm_fan_ctx *ctx;\n\tstruct device *hwmon;\n\tint ret;\n\tconst struct hwmon_channel_info **channels;\n\tu32 *fan_channel_config;\n\tint channel_count = 1;\t \n\tint i;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ctx->lock);\n\n\tctx->dev = &pdev->dev;\n\tctx->pwm = devm_pwm_get(dev, NULL);\n\tif (IS_ERR(ctx->pwm))\n\t\treturn dev_err_probe(dev, PTR_ERR(ctx->pwm), \"Could not get PWM\\n\");\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\tctx->reg_en = devm_regulator_get_optional(dev, \"fan\");\n\tif (IS_ERR(ctx->reg_en)) {\n\t\tif (PTR_ERR(ctx->reg_en) != -ENODEV)\n\t\t\treturn PTR_ERR(ctx->reg_en);\n\n\t\tctx->reg_en = NULL;\n\t}\n\n\tpwm_init_state(ctx->pwm, &ctx->pwm_state);\n\n\t \n\tctx->pwm_state.usage_power = true;\n\n\t \n\tif (ctx->pwm_state.period > ULONG_MAX / MAX_PWM + 1) {\n\t\tdev_err(dev, \"Configured period too big\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctx->enable_mode = pwm_disable_reg_enable;\n\n\t \n\tret = set_pwm(ctx, MAX_PWM);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to configure PWM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\ttimer_setup(&ctx->rpm_timer, sample_timer, 0);\n\tret = devm_add_action_or_reset(dev, pwm_fan_cleanup, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->tach_count = platform_irq_count(pdev);\n\tif (ctx->tach_count < 0)\n\t\treturn dev_err_probe(dev, ctx->tach_count,\n\t\t\t\t     \"Could not get number of fan tachometer inputs\\n\");\n\tdev_dbg(dev, \"%d fan tachometer inputs\\n\", ctx->tach_count);\n\n\tif (ctx->tach_count) {\n\t\tchannel_count++;\t \n\n\t\tctx->tachs = devm_kcalloc(dev, ctx->tach_count,\n\t\t\t\t\t  sizeof(struct pwm_fan_tach),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!ctx->tachs)\n\t\t\treturn -ENOMEM;\n\n\t\tctx->fan_channel.type = hwmon_fan;\n\t\tfan_channel_config = devm_kcalloc(dev, ctx->tach_count + 1,\n\t\t\t\t\t\t  sizeof(u32), GFP_KERNEL);\n\t\tif (!fan_channel_config)\n\t\t\treturn -ENOMEM;\n\t\tctx->fan_channel.config = fan_channel_config;\n\t}\n\n\tchannels = devm_kcalloc(dev, channel_count + 1,\n\t\t\t\tsizeof(struct hwmon_channel_info *), GFP_KERNEL);\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\tchannels[0] = HWMON_CHANNEL_INFO(pwm, HWMON_PWM_INPUT | HWMON_PWM_ENABLE);\n\n\tfor (i = 0; i < ctx->tach_count; i++) {\n\t\tstruct pwm_fan_tach *tach = &ctx->tachs[i];\n\t\tu32 ppr = 2;\n\n\t\ttach->irq = platform_get_irq(pdev, i);\n\t\tif (tach->irq == -EPROBE_DEFER)\n\t\t\treturn tach->irq;\n\t\tif (tach->irq > 0) {\n\t\t\tret = devm_request_irq(dev, tach->irq, pulse_handler, 0,\n\t\t\t\t\t       pdev->name, tach);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Failed to request interrupt: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tof_property_read_u32_index(dev->of_node,\n\t\t\t\t\t   \"pulses-per-revolution\",\n\t\t\t\t\t   i,\n\t\t\t\t\t   &ppr);\n\t\ttach->pulses_per_revolution = ppr;\n\t\tif (!tach->pulses_per_revolution) {\n\t\t\tdev_err(dev, \"pulses-per-revolution can't be zero.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfan_channel_config[i] = HWMON_F_INPUT;\n\n\t\tdev_dbg(dev, \"tach%d: irq=%d, pulses_per_revolution=%d\\n\",\n\t\t\ti, tach->irq, tach->pulses_per_revolution);\n\t}\n\n\tif (ctx->tach_count > 0) {\n\t\tctx->sample_start = ktime_get();\n\t\tmod_timer(&ctx->rpm_timer, jiffies + HZ);\n\n\t\tchannels[1] = &ctx->fan_channel;\n\t}\n\n\tctx->info.ops = &pwm_fan_hwmon_ops;\n\tctx->info.info = channels;\n\n\thwmon = devm_hwmon_device_register_with_info(dev, \"pwmfan\",\n\t\t\t\t\t\t     ctx, &ctx->info, NULL);\n\tif (IS_ERR(hwmon)) {\n\t\tdev_err(dev, \"Failed to register hwmon device\\n\");\n\t\treturn PTR_ERR(hwmon);\n\t}\n\n\tret = pwm_fan_of_get_cooling_data(dev, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->pwm_fan_state = ctx->pwm_fan_max_state;\n\tif (IS_ENABLED(CONFIG_THERMAL)) {\n\t\tcdev = devm_thermal_of_cooling_device_register(dev,\n\t\t\tdev->of_node, \"pwm-fan\", ctx, &pwm_fan_cooling_ops);\n\t\tif (IS_ERR(cdev)) {\n\t\t\tret = PTR_ERR(cdev);\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to register pwm-fan as cooling device: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tctx->cdev = cdev;\n\t}\n\n\treturn 0;\n}\n\nstatic void pwm_fan_shutdown(struct platform_device *pdev)\n{\n\tstruct pwm_fan_ctx *ctx = platform_get_drvdata(pdev);\n\n\tpwm_fan_cleanup(ctx);\n}\n\nstatic int pwm_fan_suspend(struct device *dev)\n{\n\tstruct pwm_fan_ctx *ctx = dev_get_drvdata(dev);\n\n\treturn pwm_fan_power_off(ctx);\n}\n\nstatic int pwm_fan_resume(struct device *dev)\n{\n\tstruct pwm_fan_ctx *ctx = dev_get_drvdata(dev);\n\n\treturn set_pwm(ctx, ctx->pwm_value);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pwm_fan_pm, pwm_fan_suspend, pwm_fan_resume);\n\nstatic const struct of_device_id of_pwm_fan_match[] = {\n\t{ .compatible = \"pwm-fan\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_pwm_fan_match);\n\nstatic struct platform_driver pwm_fan_driver = {\n\t.probe\t\t= pwm_fan_probe,\n\t.shutdown\t= pwm_fan_shutdown,\n\t.driver\t= {\n\t\t.name\t\t= \"pwm-fan\",\n\t\t.pm\t\t= pm_sleep_ptr(&pwm_fan_pm),\n\t\t.of_match_table\t= of_pwm_fan_match,\n\t},\n};\n\nmodule_platform_driver(pwm_fan_driver);\n\nMODULE_AUTHOR(\"Kamil Debski <k.debski@samsung.com>\");\nMODULE_ALIAS(\"platform:pwm-fan\");\nMODULE_DESCRIPTION(\"PWM FAN driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}