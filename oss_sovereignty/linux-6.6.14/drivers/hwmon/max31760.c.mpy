{
  "module_name": "max31760.c",
  "hash_id": "76e79cab52cb0a608f6ac77dc281dbc3c08f7c6a3ad1a6ef23d64edc6cb41e0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max31760.c",
  "human_readable_source": "\n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/util_macros.h>\n\n#define REG_CR1\t\t0x00\n#define CR1_HYST\tBIT(5)\n#define CR1_DRV\t\tGENMASK(4, 3)\n#define CR1_TEMP_SRC\tGENMASK(1, 0)\n#define REG_CR2\t\t0x01\n#define CR2_STBY\tBIT(7)\n#define CR2_ALERTS\tBIT(6)\n#define CR2_DFC\t\tBIT(0)\n#define REG_CR3\t\t0x02\n#define REG_PWMR\t0x50\n#define REG_PWMV\t0x51\n#define REG_STATUS\t0x5A\n#define STATUS_ALARM_CRIT(ch)\tBIT(2 + 2 * (ch))\n#define STATUS_ALARM_MAX(ch)\tBIT(3 + 2 * (ch))\n#define STATUS_RDFA\t\tBIT(6)\n\n#define REG_TACH(ch)\t\t(0x52 + (ch) * 2)\n#define REG_TEMP_INPUT(ch)\t(0x56 + (ch) * 2)\n#define REG_TEMP_MAX(ch)\t(0x06 + (ch) * 2)\n#define REG_TEMP_CRIT(ch)\t(0x0A + (ch) * 2)\n\n#define TEMP11_FROM_REG(reg)\t((reg) / 32 * 125)\n#define TEMP11_TO_REG(val)\t(DIV_ROUND_CLOSEST(clamp_val((val), -128000, \\\n\t\t\t\t\t\t\t     127875), 125) * 32)\n\n#define LUT_SIZE\t48\n\n#define REG_LUT(index)\t\t(0x20 + (index))\n\nstruct max31760_state {\n\tstruct regmap *regmap;\n\n\tstruct lut_attribute {\n\t\tchar name[24];\n\t\tstruct sensor_device_attribute sda;\n\t} lut[LUT_SIZE];\n\n\tstruct attribute *attrs[LUT_SIZE + 2];\n\tstruct attribute_group group;\n\tconst struct attribute_group *groups[2];\n};\n\nstatic bool max31760_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg > 0x50;\n}\n\nstatic const struct regmap_config regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x5B,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = max31760_volatile_reg,\n};\n\nstatic const int max31760_pwm_freq[] = {33, 150, 1500, 25000};\n\nstatic int tach_to_rpm(u16 tach)\n{\n\tif (tach == 0)\n\t\ttach = 1;\n\n\treturn 60 * 100000 / tach / 2;\n}\n\nstatic int max31760_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long *val)\n{\n\tstruct max31760_state *state = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tunsigned int reg_temp;\n\ts16 temp;\n\tu8 reg[2];\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_fault:\n\t\t\tret = regmap_read(state->regmap, REG_STATUS, &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = FIELD_GET(STATUS_RDFA, regval);\n\n\t\t\treturn 0;\n\t\tcase hwmon_temp_max_alarm:\n\t\t\tret = regmap_read(state->regmap, REG_STATUS, &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (channel)\n\t\t\t\t*val = FIELD_GET(STATUS_ALARM_MAX(1), regval);\n\t\t\telse\n\t\t\t\t*val = FIELD_GET(STATUS_ALARM_MAX(0), regval);\n\n\t\t\treturn 0;\n\t\tcase hwmon_temp_crit_alarm:\n\t\t\tret = regmap_read(state->regmap, REG_STATUS, &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (channel)\n\t\t\t\t*val = FIELD_GET(STATUS_ALARM_CRIT(1), regval);\n\t\t\telse\n\t\t\t\t*val = FIELD_GET(STATUS_ALARM_CRIT(0), regval);\n\n\t\t\treturn 0;\n\t\tcase hwmon_temp_input:\n\t\t\treg_temp = REG_TEMP_INPUT(channel);\n\t\t\tbreak;\n\t\tcase hwmon_temp_max:\n\t\t\treg_temp = REG_TEMP_MAX(channel);\n\t\t\tbreak;\n\t\tcase hwmon_temp_crit:\n\t\t\treg_temp = REG_TEMP_CRIT(channel);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tret = regmap_bulk_read(state->regmap, reg_temp, reg, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttemp = (reg[0] << 8) | reg[1];\n\n\t\t*val = TEMP11_FROM_REG(temp);\n\n\t\treturn 0;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\tret = regmap_bulk_read(state->regmap, REG_TACH(channel), reg, 2);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = tach_to_rpm(reg[0] * 256 + reg[1]);\n\n\t\t\treturn 0;\n\t\tcase hwmon_fan_fault:\n\t\t\tret = regmap_read(state->regmap, REG_STATUS, &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (channel)\n\t\t\t\t*val = FIELD_GET(BIT(1), regval);\n\t\t\telse\n\t\t\t\t*val = FIELD_GET(BIT(0), regval);\n\n\t\t\treturn 0;\n\t\tcase hwmon_fan_enable:\n\t\t\tret = regmap_read(state->regmap, REG_CR3, &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (channel)\n\t\t\t\t*val = FIELD_GET(BIT(1), regval);\n\t\t\telse\n\t\t\t\t*val = FIELD_GET(BIT(0), regval);\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\tret = regmap_read(state->regmap, REG_PWMV, &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = regval;\n\n\t\t\treturn 0;\n\t\tcase hwmon_pwm_freq:\n\t\t\tret = regmap_read(state->regmap, REG_CR1, &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tregval = FIELD_GET(CR1_DRV, regval);\n\t\t\tif (regval >= ARRAY_SIZE(max31760_pwm_freq))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t*val = max31760_pwm_freq[regval];\n\n\t\t\treturn 0;\n\t\tcase hwmon_pwm_enable:\n\t\t\tret = regmap_read(state->regmap, REG_CR2, &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = 2 - FIELD_GET(CR2_DFC, regval);\n\n\t\t\treturn 0;\n\t\tcase hwmon_pwm_auto_channels_temp:\n\t\t\tret = regmap_read(state->regmap, REG_CR1, &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tswitch (FIELD_GET(CR1_TEMP_SRC, regval)) {\n\t\t\tcase 0:\n\t\t\t\t*val = 2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t*val = 1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\t\t*val = 3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int max31760_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t  u32 attr, int channel, long val)\n{\n\tstruct max31760_state *state = dev_get_drvdata(dev);\n\tunsigned int pwm_index;\n\tunsigned int reg_temp;\n\tint temp;\n\tu8 reg_val[2];\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_max:\n\t\t\treg_temp = REG_TEMP_MAX(channel);\n\t\t\tbreak;\n\t\tcase hwmon_temp_crit:\n\t\t\treg_temp = REG_TEMP_CRIT(channel);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\ttemp = TEMP11_TO_REG(val);\n\t\treg_val[0] = temp >> 8;\n\t\treg_val[1] = temp & 0xFF;\n\n\t\treturn regmap_bulk_write(state->regmap, reg_temp, reg_val, 2);\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_enable:\n\t\t\tif (val == 0)\n\t\t\t\treturn regmap_clear_bits(state->regmap, REG_CR3, BIT(channel));\n\n\t\t\tif (val == 1)\n\t\t\t\treturn regmap_set_bits(state->regmap, REG_CR3, BIT(channel));\n\n\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\tif (val < 0 || val > 255)\n\t\t\t\treturn -EINVAL;\n\n\t\t\treturn regmap_write(state->regmap, REG_PWMR, val);\n\t\tcase hwmon_pwm_enable:\n\t\t\tif (val == 1)\n\t\t\t\treturn regmap_set_bits(state->regmap, REG_CR2, CR2_DFC);\n\n\t\t\tif (val == 2)\n\t\t\t\treturn regmap_clear_bits(state->regmap, REG_CR2, CR2_DFC);\n\n\t\t\treturn -EINVAL;\n\t\tcase hwmon_pwm_freq:\n\t\t\tpwm_index = find_closest(val, max31760_pwm_freq,\n\t\t\t\t\t\t ARRAY_SIZE(max31760_pwm_freq));\n\n\t\t\treturn regmap_update_bits(state->regmap,\n\t\t\t\t\t\t  REG_CR1, CR1_DRV,\n\t\t\t\t\t\t  FIELD_PREP(CR1_DRV, pwm_index));\n\t\tcase hwmon_pwm_auto_channels_temp:\n\t\t\tswitch (val) {\n\t\t\tcase 1:\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tval = 0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tval = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\treturn regmap_update_bits(state->regmap, REG_CR1, CR1_TEMP_SRC, val);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const max31760_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT | HWMON_F_ENABLE),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT | HWMON_T_FAULT |\n\t\t\t   HWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |\n\t\t\t   HWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM | HWMON_T_LABEL),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_ENABLE | HWMON_PWM_FREQ | HWMON_PWM_INPUT |\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP),\n\tNULL\n};\n\nstatic umode_t max31760_is_visible(const void *data,\n\t\t\t\t   enum hwmon_sensor_types type,\n\t\t\t\t   u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_max_alarm:\n\t\tcase hwmon_temp_crit_alarm:\n\t\tcase hwmon_temp_fault:\n\t\tcase hwmon_temp_label:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_max:\n\t\tcase hwmon_temp_crit:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\tcase hwmon_fan_fault:\n\t\t\treturn 0444;\n\t\tcase hwmon_fan_enable:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_enable:\n\t\tcase hwmon_pwm_input:\n\t\tcase hwmon_pwm_freq:\n\t\tcase hwmon_pwm_auto_channels_temp:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int max31760_read_string(struct device *dev,\n\t\t\t\tenum hwmon_sensor_types type,\n\t\t\t\tu32 attr, int channel, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tif (attr != hwmon_temp_label)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t*str = channel ? \"local\" : \"remote\";\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_ops max31760_hwmon_ops = {\n\t.is_visible = max31760_is_visible,\n\t.read = max31760_read,\n\t.write = max31760_write,\n\t.read_string = max31760_read_string\n};\n\nstatic const struct hwmon_chip_info max31760_chip_info = {\n\t.ops = &max31760_hwmon_ops,\n\t.info = max31760_info,\n};\n\nstatic ssize_t lut_show(struct device *dev,\n\t\t\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);\n\tstruct max31760_state *state = dev_get_drvdata(dev);\n\tint ret;\n\tunsigned int regval;\n\n\tret = regmap_read(state->regmap, REG_LUT(sda->index), &regval);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", regval);\n}\n\nstatic ssize_t lut_store(struct device *dev,\n\t\t\t struct device_attribute *devattr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);\n\tstruct max31760_state *state = dev_get_drvdata(dev);\n\tint ret;\n\tu8 pwm;\n\n\tret = kstrtou8(buf, 10, &pwm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(state->regmap, REG_LUT(sda->index), pwm);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t pwm1_auto_point_temp_hyst_show(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct max31760_state *state = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(state->regmap, REG_CR1, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", (1 + (int)FIELD_GET(CR1_HYST, regval)) * 2000);\n}\n\nstatic ssize_t pwm1_auto_point_temp_hyst_store(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       const char *buf,\n\t\t\t\t\t       size_t count)\n{\n\tstruct max31760_state *state = dev_get_drvdata(dev);\n\tunsigned int hyst;\n\tint ret;\n\n\tret = kstrtou32(buf, 10, &hyst);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hyst < 3000)\n\t\tret = regmap_clear_bits(state->regmap, REG_CR1, CR1_HYST);\n\telse\n\t\tret = regmap_set_bits(state->regmap, REG_CR1, CR1_HYST);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(pwm1_auto_point_temp_hyst);\n\nstatic void max31760_create_lut_nodes(struct max31760_state *state)\n{\n\tint i;\n\tstruct sensor_device_attribute *sda;\n\tstruct lut_attribute *lut;\n\n\tfor (i = 0; i < LUT_SIZE; ++i) {\n\t\tlut = &state->lut[i];\n\t\tsda = &lut->sda;\n\n\t\tsnprintf(lut->name, sizeof(lut->name),\n\t\t\t \"pwm1_auto_point%d_pwm\", i + 1);\n\n\t\tsda->dev_attr.attr.mode = 0644;\n\t\tsda->index = i;\n\t\tsda->dev_attr.show = lut_show;\n\t\tsda->dev_attr.store = lut_store;\n\t\tsda->dev_attr.attr.name = lut->name;\n\n\t\tsysfs_attr_init(&sda->dev_attr.attr);\n\n\t\tstate->attrs[i] = &sda->dev_attr.attr;\n\t}\n\n\tstate->attrs[i] = &dev_attr_pwm1_auto_point_temp_hyst.attr;\n\n\tstate->group.attrs = state->attrs;\n\tstate->groups[0] = &state->group;\n}\n\nstatic int max31760_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct max31760_state *state;\n\tstruct device *hwmon_dev;\n\tint ret;\n\n\tstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(state->regmap))\n\t\treturn dev_err_probe(dev,\n\t\t\t\t     PTR_ERR(state->regmap),\n\t\t\t\t     \"regmap initialization failed\\n\");\n\n\tdev_set_drvdata(dev, state);\n\n\t \n\tret = regmap_set_bits(state->regmap, REG_CR2, CR2_ALERTS);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"cannot write register\\n\");\n\n\tmax31760_create_lut_nodes(state);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t state,\n\t\t\t\t\t\t\t &max31760_chip_info,\n\t\t\t\t\t\t\t state->groups);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct of_device_id max31760_of_match[] = {\n\t{.compatible = \"adi,max31760\"},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max31760_of_match);\n\nstatic const struct i2c_device_id max31760_id[] = {\n\t{\"max31760\"},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max31760_id);\n\nstatic int max31760_suspend(struct device *dev)\n{\n\tstruct max31760_state *state = dev_get_drvdata(dev);\n\n\treturn regmap_set_bits(state->regmap, REG_CR2, CR2_STBY);\n}\n\nstatic int max31760_resume(struct device *dev)\n{\n\tstruct max31760_state *state = dev_get_drvdata(dev);\n\n\treturn regmap_clear_bits(state->regmap, REG_CR2, CR2_STBY);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(max31760_pm_ops, max31760_suspend,\n\t\t\t\tmax31760_resume);\n\nstatic struct i2c_driver max31760_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"max31760\",\n\t\t.of_match_table = max31760_of_match,\n\t\t.pm = pm_ptr(&max31760_pm_ops)\n\t},\n\t.probe\t\t= max31760_probe,\n\t.id_table\t= max31760_id\n};\nmodule_i2c_driver(max31760_driver);\n\nMODULE_AUTHOR(\"Ibrahim Tilki <Ibrahim.Tilki@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices MAX31760 Fan Speed Controller\");\nMODULE_SOFTDEP(\"pre: regmap_i2c\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}