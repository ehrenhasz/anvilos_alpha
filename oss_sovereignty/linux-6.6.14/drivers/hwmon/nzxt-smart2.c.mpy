{
  "module_name": "nzxt-smart2.c",
  "hash_id": "42af8af0c147a7ae2020cb151d68735581cf6f89404c55363ce1a7922e25040e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/nzxt-smart2.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/hwmon.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n\n \n#define FAN_CHANNELS 3\n#define FAN_CHANNELS_MAX 8\n\n#define UPDATE_INTERVAL_DEFAULT_MS 1000\n\n \nstatic const char *const fan_label[] = {\n\t\"FAN 1\",\n\t\"FAN 2\",\n\t\"FAN 3\",\n};\n\nstatic const char *const curr_label[] = {\n\t\"FAN 1 Current\",\n\t\"FAN 2 Current\",\n\t\"FAN 3 Current\",\n};\n\nstatic const char *const in_label[] = {\n\t\"FAN 1 Voltage\",\n\t\"FAN 2 Voltage\",\n\t\"FAN 3 Voltage\",\n};\n\nenum {\n\tINPUT_REPORT_ID_FAN_CONFIG = 0x61,\n\tINPUT_REPORT_ID_FAN_STATUS = 0x67,\n};\n\nenum {\n\tFAN_STATUS_REPORT_SPEED = 0x02,\n\tFAN_STATUS_REPORT_VOLTAGE = 0x04,\n};\n\nenum {\n\tFAN_TYPE_NONE = 0,\n\tFAN_TYPE_DC = 1,\n\tFAN_TYPE_PWM = 2,\n};\n\nstruct unknown_static_data {\n\t \n\tu8 unknown1[14];\n} __packed;\n\n \nstruct fan_config_report {\n\t \n\tu8 report_id;\n\t \n\tu8 magic;\n\tstruct unknown_static_data unknown_data;\n\t \n\tu8 fan_type[FAN_CHANNELS_MAX];\n} __packed;\n\n \nstruct fan_status_report {\n\t \n\tu8 report_id;\n\t \n\tu8 type;\n\tstruct unknown_static_data unknown_data;\n\t \n\tu8 fan_type[FAN_CHANNELS_MAX];\n\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\t__le16 fan_rpm[FAN_CHANNELS_MAX];\n\t\t\t \n\t\t\tu8 duty_percent[FAN_CHANNELS_MAX];\n\t\t\t \n\t\t\tu8 duty_percent_dup[FAN_CHANNELS_MAX];\n\t\t\t \n\t\t\tu8 noise_db;\n\t\t} __packed fan_speed;\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\t__le16 fan_in[FAN_CHANNELS_MAX];\n\t\t\t \n\t\t\t__le16 fan_current[FAN_CHANNELS_MAX];\n\t\t} __packed fan_voltage;\n\t} __packed;\n} __packed;\n\n#define OUTPUT_REPORT_SIZE 64\n\nenum {\n\tOUTPUT_REPORT_ID_INIT_COMMAND = 0x60,\n\tOUTPUT_REPORT_ID_SET_FAN_SPEED = 0x62,\n};\n\nenum {\n\tINIT_COMMAND_SET_UPDATE_INTERVAL = 0x02,\n\tINIT_COMMAND_DETECT_FANS = 0x03,\n};\n\n \nstruct set_fan_speed_report {\n\t \n\tu8 report_id;\n\t \n\tu8 magic;\n\t \n\tu8 channel_bit_mask;\n\t \n\tu8 duty_percent[FAN_CHANNELS_MAX];\n} __packed;\n\nstruct drvdata {\n\tstruct hid_device *hid;\n\tstruct device *hwmon;\n\n\tu8 fan_duty_percent[FAN_CHANNELS];\n\tu16 fan_rpm[FAN_CHANNELS];\n\tbool pwm_status_received;\n\n\tu16 fan_in[FAN_CHANNELS];\n\tu16 fan_curr[FAN_CHANNELS];\n\tbool voltage_status_received;\n\n\tu8 fan_type[FAN_CHANNELS];\n\tbool fan_config_received;\n\n\t \n\twait_queue_head_t wq;\n\t \n\tstruct mutex mutex;\n\tlong update_interval;\n\tu8 output_buffer[OUTPUT_REPORT_SIZE];\n};\n\nstatic long scale_pwm_value(long val, long orig_max, long new_max)\n{\n\tif (val <= 0)\n\t\treturn 0;\n\n\t \n\treturn max(1L, DIV_ROUND_CLOSEST(min(val, orig_max) * new_max, orig_max));\n}\n\nstatic void handle_fan_config_report(struct drvdata *drvdata, void *data, int size)\n{\n\tstruct fan_config_report *report = data;\n\tint i;\n\n\tif (size < sizeof(struct fan_config_report))\n\t\treturn;\n\n\tif (report->magic != 0x03)\n\t\treturn;\n\n\tspin_lock(&drvdata->wq.lock);\n\n\tfor (i = 0; i < FAN_CHANNELS; i++)\n\t\tdrvdata->fan_type[i] = report->fan_type[i];\n\n\tdrvdata->fan_config_received = true;\n\twake_up_all_locked(&drvdata->wq);\n\tspin_unlock(&drvdata->wq.lock);\n}\n\nstatic void handle_fan_status_report(struct drvdata *drvdata, void *data, int size)\n{\n\tstruct fan_status_report *report = data;\n\tint i;\n\n\tif (size < sizeof(struct fan_status_report))\n\t\treturn;\n\n\tspin_lock(&drvdata->wq.lock);\n\n\t \n\tif (!drvdata->fan_config_received) {\n\t\tspin_unlock(&drvdata->wq.lock);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < FAN_CHANNELS; i++) {\n\t\tif (drvdata->fan_type[i] == report->fan_type[i])\n\t\t\tcontinue;\n\n\t\t \n\t\thid_warn_once(drvdata->hid,\n\t\t\t      \"Fan %d type changed unexpectedly from %d to %d\",\n\t\t\t      i, drvdata->fan_type[i], report->fan_type[i]);\n\t\tdrvdata->fan_type[i] = report->fan_type[i];\n\t}\n\n\tswitch (report->type) {\n\tcase FAN_STATUS_REPORT_SPEED:\n\t\tfor (i = 0; i < FAN_CHANNELS; i++) {\n\t\t\tdrvdata->fan_rpm[i] =\n\t\t\t\tget_unaligned_le16(&report->fan_speed.fan_rpm[i]);\n\t\t\tdrvdata->fan_duty_percent[i] =\n\t\t\t\treport->fan_speed.duty_percent[i];\n\t\t}\n\n\t\tdrvdata->pwm_status_received = true;\n\t\twake_up_all_locked(&drvdata->wq);\n\t\tbreak;\n\n\tcase FAN_STATUS_REPORT_VOLTAGE:\n\t\tfor (i = 0; i < FAN_CHANNELS; i++) {\n\t\t\tdrvdata->fan_in[i] =\n\t\t\t\tget_unaligned_le16(&report->fan_voltage.fan_in[i]);\n\t\t\tdrvdata->fan_curr[i] =\n\t\t\t\tget_unaligned_le16(&report->fan_voltage.fan_current[i]);\n\t\t}\n\n\t\tdrvdata->voltage_status_received = true;\n\t\twake_up_all_locked(&drvdata->wq);\n\t\tbreak;\n\t}\n\n\tspin_unlock(&drvdata->wq.lock);\n}\n\nstatic umode_t nzxt_smart2_hwmon_is_visible(const void *data,\n\t\t\t\t\t    enum hwmon_sensor_types type,\n\t\t\t\t\t    u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\tcase hwmon_pwm_enable:\n\t\t\treturn 0644;\n\n\t\tdefault:\n\t\t\treturn 0444;\n\t\t}\n\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\treturn 0644;\n\n\t\tdefault:\n\t\t\treturn 0444;\n\t\t}\n\n\tdefault:\n\t\treturn 0444;\n\t}\n}\n\nstatic int nzxt_smart2_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel, long *val)\n{\n\tstruct drvdata *drvdata = dev_get_drvdata(dev);\n\tint res = -EINVAL;\n\n\tif (type == hwmon_chip) {\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\t*val = drvdata->update_interval;\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tspin_lock_irq(&drvdata->wq.lock);\n\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\t \n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_enable:\n\t\t\tres = wait_event_interruptible_locked_irq(drvdata->wq,\n\t\t\t\t\t\t\t\t  drvdata->fan_config_received);\n\t\t\tif (res)\n\t\t\t\tgoto unlock;\n\n\t\t\t*val = drvdata->fan_type[channel] != FAN_TYPE_NONE;\n\t\t\tbreak;\n\n\t\tcase hwmon_pwm_mode:\n\t\t\tres = wait_event_interruptible_locked_irq(drvdata->wq,\n\t\t\t\t\t\t\t\t  drvdata->fan_config_received);\n\t\t\tif (res)\n\t\t\t\tgoto unlock;\n\n\t\t\t*val = drvdata->fan_type[channel] == FAN_TYPE_PWM;\n\t\t\tbreak;\n\n\t\tcase hwmon_pwm_input:\n\t\t\tres = wait_event_interruptible_locked_irq(drvdata->wq,\n\t\t\t\t\t\t\t\t  drvdata->pwm_status_received);\n\t\t\tif (res)\n\t\t\t\tgoto unlock;\n\n\t\t\t*val = scale_pwm_value(drvdata->fan_duty_percent[channel],\n\t\t\t\t\t       100, 255);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_fan:\n\t\t \n\t\tif (attr == hwmon_fan_input) {\n\t\t\tres = wait_event_interruptible_locked_irq(drvdata->wq,\n\t\t\t\t\t\t\t\t  drvdata->pwm_status_received);\n\t\t\tif (res)\n\t\t\t\tgoto unlock;\n\n\t\t\t*val = drvdata->fan_rpm[channel];\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_in:\n\t\tif (attr == hwmon_in_input) {\n\t\t\tres = wait_event_interruptible_locked_irq(drvdata->wq,\n\t\t\t\t\t\t\t\t  drvdata->voltage_status_received);\n\t\t\tif (res)\n\t\t\t\tgoto unlock;\n\n\t\t\t*val = drvdata->fan_in[channel];\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_curr:\n\t\tif (attr == hwmon_curr_input) {\n\t\t\tres = wait_event_interruptible_locked_irq(drvdata->wq,\n\t\t\t\t\t\t\t\t  drvdata->voltage_status_received);\n\t\t\tif (res)\n\t\t\t\tgoto unlock;\n\n\t\t\t*val = drvdata->fan_curr[channel];\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_irq(&drvdata->wq.lock);\n\treturn res;\n}\n\nstatic int send_output_report(struct drvdata *drvdata, const void *data,\n\t\t\t      size_t data_size)\n{\n\tint ret;\n\n\tif (data_size > sizeof(drvdata->output_buffer))\n\t\treturn -EINVAL;\n\n\tmemcpy(drvdata->output_buffer, data, data_size);\n\n\tif (data_size < sizeof(drvdata->output_buffer))\n\t\tmemset(drvdata->output_buffer + data_size, 0,\n\t\t       sizeof(drvdata->output_buffer) - data_size);\n\n\tret = hid_hw_output_report(drvdata->hid, drvdata->output_buffer,\n\t\t\t\t   sizeof(drvdata->output_buffer));\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int set_pwm(struct drvdata *drvdata, int channel, long val)\n{\n\tint ret;\n\tu8 duty_percent = scale_pwm_value(val, 255, 100);\n\n\tstruct set_fan_speed_report report = {\n\t\t.report_id = OUTPUT_REPORT_ID_SET_FAN_SPEED,\n\t\t.magic = 1,\n\t\t.channel_bit_mask = 1 << channel\n\t};\n\n\tret = mutex_lock_interruptible(&drvdata->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\treport.duty_percent[channel] = duty_percent;\n\tret = send_output_report(drvdata, &report, sizeof(report));\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tspin_lock_bh(&drvdata->wq.lock);\n\tdrvdata->fan_duty_percent[channel] = duty_percent;\n\tspin_unlock_bh(&drvdata->wq.lock);\n\nunlock:\n\tmutex_unlock(&drvdata->mutex);\n\treturn ret;\n}\n\n \nstatic int set_pwm_enable(struct drvdata *drvdata, int channel, long val)\n{\n\tlong expected_val;\n\tint res;\n\n\tspin_lock_irq(&drvdata->wq.lock);\n\n\tres = wait_event_interruptible_locked_irq(drvdata->wq,\n\t\t\t\t\t\t  drvdata->fan_config_received);\n\tif (res) {\n\t\tspin_unlock_irq(&drvdata->wq.lock);\n\t\treturn res;\n\t}\n\n\texpected_val = drvdata->fan_type[channel] != FAN_TYPE_NONE;\n\n\tspin_unlock_irq(&drvdata->wq.lock);\n\n\treturn (val == expected_val) ? 0 : -EOPNOTSUPP;\n}\n\n \nstatic u8 update_interval_to_control_byte(long interval)\n{\n\tif (interval <= 250)\n\t\treturn 0;\n\n\treturn clamp_val(1 + DIV_ROUND_CLOSEST(interval - 488, 256), 0, 255);\n}\n\nstatic long control_byte_to_update_interval(u8 control_byte)\n{\n\tif (control_byte == 0)\n\t\treturn 250;\n\n\treturn 488 + (control_byte - 1) * 256;\n}\n\nstatic int set_update_interval(struct drvdata *drvdata, long val)\n{\n\tu8 control = update_interval_to_control_byte(val);\n\tu8 report[] = {\n\t\tOUTPUT_REPORT_ID_INIT_COMMAND,\n\t\tINIT_COMMAND_SET_UPDATE_INTERVAL,\n\t\t0x01,\n\t\t0xe8,\n\t\tcontrol,\n\t\t0x01,\n\t\t0xe8,\n\t\tcontrol,\n\t};\n\tint ret;\n\n\tret = send_output_report(drvdata, report, sizeof(report));\n\tif (ret)\n\t\treturn ret;\n\n\tdrvdata->update_interval = control_byte_to_update_interval(control);\n\treturn 0;\n}\n\nstatic int init_device(struct drvdata *drvdata, long update_interval)\n{\n\tint ret;\n\tstatic const u8 detect_fans_report[] = {\n\t\tOUTPUT_REPORT_ID_INIT_COMMAND,\n\t\tINIT_COMMAND_DETECT_FANS,\n\t};\n\n\tret = send_output_report(drvdata, detect_fans_report,\n\t\t\t\t sizeof(detect_fans_report));\n\tif (ret)\n\t\treturn ret;\n\n\treturn set_update_interval(drvdata, update_interval);\n}\n\nstatic int nzxt_smart2_hwmon_write(struct device *dev,\n\t\t\t\t   enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t   int channel, long val)\n{\n\tstruct drvdata *drvdata = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_enable:\n\t\t\treturn set_pwm_enable(drvdata, channel, val);\n\n\t\tcase hwmon_pwm_input:\n\t\t\treturn set_pwm(drvdata, channel, val);\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\tret = mutex_lock_interruptible(&drvdata->mutex);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = set_update_interval(drvdata, val);\n\n\t\t\tmutex_unlock(&drvdata->mutex);\n\t\t\treturn ret;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nzxt_smart2_hwmon_read_string(struct device *dev,\n\t\t\t\t\t enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t\t int channel, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\t*str = fan_label[channel];\n\t\treturn 0;\n\tcase hwmon_curr:\n\t\t*str = curr_label[channel];\n\t\treturn 0;\n\tcase hwmon_in:\n\t\t*str = in_label[channel];\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct hwmon_ops nzxt_smart2_hwmon_ops = {\n\t.is_visible = nzxt_smart2_hwmon_is_visible,\n\t.read = nzxt_smart2_hwmon_read,\n\t.read_string = nzxt_smart2_hwmon_read_string,\n\t.write = nzxt_smart2_hwmon_write,\n};\n\nstatic const struct hwmon_channel_info * const nzxt_smart2_channel_info[] = {\n\tHWMON_CHANNEL_INFO(fan, HWMON_F_INPUT | HWMON_F_LABEL,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL),\n\tHWMON_CHANNEL_INFO(pwm, HWMON_PWM_INPUT | HWMON_PWM_MODE | HWMON_PWM_ENABLE,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_MODE | HWMON_PWM_ENABLE,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_MODE | HWMON_PWM_ENABLE),\n\tHWMON_CHANNEL_INFO(in, HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL),\n\tHWMON_CHANNEL_INFO(curr, HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL),\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_UPDATE_INTERVAL),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info nzxt_smart2_chip_info = {\n\t.ops = &nzxt_smart2_hwmon_ops,\n\t.info = nzxt_smart2_channel_info,\n};\n\nstatic int nzxt_smart2_hid_raw_event(struct hid_device *hdev,\n\t\t\t\t     struct hid_report *report, u8 *data, int size)\n{\n\tstruct drvdata *drvdata = hid_get_drvdata(hdev);\n\tu8 report_id = *data;\n\n\tswitch (report_id) {\n\tcase INPUT_REPORT_ID_FAN_CONFIG:\n\t\thandle_fan_config_report(drvdata, data, size);\n\t\tbreak;\n\n\tcase INPUT_REPORT_ID_FAN_STATUS:\n\t\thandle_fan_status_report(drvdata, data, size);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused nzxt_smart2_hid_reset_resume(struct hid_device *hdev)\n{\n\tstruct drvdata *drvdata = hid_get_drvdata(hdev);\n\n\t \n\tspin_lock_bh(&drvdata->wq.lock);\n\tdrvdata->fan_config_received = false;\n\tdrvdata->pwm_status_received = false;\n\tdrvdata->voltage_status_received = false;\n\tspin_unlock_bh(&drvdata->wq.lock);\n\n\treturn init_device(drvdata, drvdata->update_interval);\n}\n\nstatic void mutex_fini(void *lock)\n{\n\tmutex_destroy(lock);\n}\n\nstatic int nzxt_smart2_hid_probe(struct hid_device *hdev,\n\t\t\t\t const struct hid_device_id *id)\n{\n\tstruct drvdata *drvdata;\n\tint ret;\n\n\tdrvdata = devm_kzalloc(&hdev->dev, sizeof(struct drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->hid = hdev;\n\thid_set_drvdata(hdev, drvdata);\n\n\tinit_waitqueue_head(&drvdata->wq);\n\n\tmutex_init(&drvdata->mutex);\n\tret = devm_add_action_or_reset(&hdev->dev, mutex_fini, &drvdata->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hid_hw_open(hdev);\n\tif (ret)\n\t\tgoto out_hw_stop;\n\n\thid_device_io_start(hdev);\n\n\tinit_device(drvdata, UPDATE_INTERVAL_DEFAULT_MS);\n\n\tdrvdata->hwmon =\n\t\thwmon_device_register_with_info(&hdev->dev, \"nzxtsmart2\", drvdata,\n\t\t\t\t\t\t&nzxt_smart2_chip_info, NULL);\n\tif (IS_ERR(drvdata->hwmon)) {\n\t\tret = PTR_ERR(drvdata->hwmon);\n\t\tgoto out_hw_close;\n\t}\n\n\treturn 0;\n\nout_hw_close:\n\thid_hw_close(hdev);\n\nout_hw_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void nzxt_smart2_hid_remove(struct hid_device *hdev)\n{\n\tstruct drvdata *drvdata = hid_get_drvdata(hdev);\n\n\thwmon_device_unregister(drvdata->hwmon);\n\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic const struct hid_device_id nzxt_smart2_hid_id_table[] = {\n\t{ HID_USB_DEVICE(0x1e71, 0x2006) },  \n\t{ HID_USB_DEVICE(0x1e71, 0x200d) },  \n\t{ HID_USB_DEVICE(0x1e71, 0x200f) },  \n\t{ HID_USB_DEVICE(0x1e71, 0x2009) },  \n\t{ HID_USB_DEVICE(0x1e71, 0x200e) },  \n\t{ HID_USB_DEVICE(0x1e71, 0x2010) },  \n\t{ HID_USB_DEVICE(0x1e71, 0x2011) },  \n\t{ HID_USB_DEVICE(0x1e71, 0x2019) },  \n\t{},\n};\n\nstatic struct hid_driver nzxt_smart2_hid_driver = {\n\t.name = \"nzxt-smart2\",\n\t.id_table = nzxt_smart2_hid_id_table,\n\t.probe = nzxt_smart2_hid_probe,\n\t.remove = nzxt_smart2_hid_remove,\n\t.raw_event = nzxt_smart2_hid_raw_event,\n#ifdef CONFIG_PM\n\t.reset_resume = nzxt_smart2_hid_reset_resume,\n#endif\n};\n\nstatic int __init nzxt_smart2_init(void)\n{\n\treturn hid_register_driver(&nzxt_smart2_hid_driver);\n}\n\nstatic void __exit nzxt_smart2_exit(void)\n{\n\thid_unregister_driver(&nzxt_smart2_hid_driver);\n}\n\nMODULE_DEVICE_TABLE(hid, nzxt_smart2_hid_id_table);\nMODULE_AUTHOR(\"Aleksandr Mezin <mezin.alexander@gmail.com>\");\nMODULE_DESCRIPTION(\"Driver for NZXT RGB & Fan Controller/Smart Device V2\");\nMODULE_LICENSE(\"GPL\");\n\n \nlate_initcall(nzxt_smart2_init);\nmodule_exit(nzxt_smart2_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}