{
  "module_name": "w83792d.c",
  "hash_id": "8c7cc85884a9af73ee4051a9595be020e0dcb69c651cfaa7606cb73a055ca755",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/w83792d.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/jiffies.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t\tI2C_CLIENT_END };\n\n \n\nstatic unsigned short force_subclients[4];\nmodule_param_array(force_subclients, short, NULL, 0);\nMODULE_PARM_DESC(force_subclients,\n\t\t \"List of subclient addresses: {bus, clientaddr, subclientaddr1, subclientaddr2}\");\n\nstatic bool init;\nmodule_param(init, bool, 0);\nMODULE_PARM_DESC(init, \"Set to one to force chip initialization\");\n\n \nstatic const u8 W83792D_REG_IN[9] = {\n\t0x20,\t \n\t0x21,\t \n\t0x22,\t \n\t0x23,\t \n\t0x24,\t \n\t0x25,\t \n\t0x26,\t \n\t0xB0,\t \n\t0xB1\t \n};\n#define W83792D_REG_LOW_BITS1 0x3E   \n#define W83792D_REG_LOW_BITS2 0x3F   \nstatic const u8 W83792D_REG_IN_MAX[9] = {\n\t0x2B,\t \n\t0x2D,\t \n\t0x2F,\t \n\t0x31,\t \n\t0x33,\t \n\t0x35,\t \n\t0x37,\t \n\t0xB4,\t \n\t0xB6\t \n};\nstatic const u8 W83792D_REG_IN_MIN[9] = {\n\t0x2C,\t \n\t0x2E,\t \n\t0x30,\t \n\t0x32,\t \n\t0x34,\t \n\t0x36,\t \n\t0x38,\t \n\t0xB5,\t \n\t0xB7\t \n};\nstatic const u8 W83792D_REG_FAN[7] = {\n\t0x28,\t \n\t0x29,\t \n\t0x2A,\t \n\t0xB8,\t \n\t0xB9,\t \n\t0xBA,\t \n\t0xBE\t \n};\nstatic const u8 W83792D_REG_FAN_MIN[7] = {\n\t0x3B,\t \n\t0x3C,\t \n\t0x3D,\t \n\t0xBB,\t \n\t0xBC,\t \n\t0xBD,\t \n\t0xBF\t \n};\n#define W83792D_REG_FAN_CFG 0x84\t \nstatic const u8 W83792D_REG_FAN_DIV[4] = {\n\t0x47,\t \n\t0x5B,\t \n\t0x5C,\t \n\t0x9E\t \n};\nstatic const u8 W83792D_REG_PWM[7] = {\n\t0x81,\t \n\t0x83,\t \n\t0x94,\t \n\t0xA3,\t \n\t0xA4,\t \n\t0xA5,\t \n\t0xA6\t \n};\n#define W83792D_REG_BANK\t\t0x4E\n#define W83792D_REG_TEMP2_CONFIG\t0xC2\n#define W83792D_REG_TEMP3_CONFIG\t0xCA\n\nstatic const u8 W83792D_REG_TEMP1[3] = {\n\t0x27,\t \n\t0x39,\t \n\t0x3A,\t \n};\n\nstatic const u8 W83792D_REG_TEMP_ADD[2][6] = {\n\t{ 0xC0,\t\t \n\t  0xC1,\t\t \n\t  0xC5,\t\t \n\t  0xC6,\t\t \n\t  0xC3,\t\t \n\t  0xC4 },\t \n\t{ 0xC8,\t\t \n\t  0xC9,\t\t \n\t  0xCD,\t\t \n\t  0xCE,\t\t \n\t  0xCB,\t\t \n\t  0xCC }\t \n};\n\nstatic const u8 W83792D_REG_THERMAL[3] = {\n\t0x85,\t \n\t0x86,\t \n\t0x96\t \n};\n\nstatic const u8 W83792D_REG_TOLERANCE[3] = {\n\t0x87,\t \n\t0x87,\t \n\t0x97\t \n};\n\nstatic const u8 W83792D_REG_POINTS[3][4] = {\n\t{ 0x85,\t\t \n\t  0xE3,\t\t \n\t  0xE4,\t\t \n\t  0xE5 },\t \n\t{ 0x86,\t\t \n\t  0xE6,\t\t \n\t  0xE7,\t\t \n\t  0xE8 },\t \n\t{ 0x96,\t\t \n\t  0xE9,\t\t \n\t  0xEA,\t\t \n\t  0xEB }\t \n};\n\nstatic const u8 W83792D_REG_LEVELS[3][4] = {\n\t{ 0x88,\t\t \n\t  0x88,\t\t \n\t  0xE0,\t\t \n\t  0xE0 },\t \n\t{ 0x89,\t\t \n\t  0x89,\t\t \n\t  0xE1,\t\t \n\t  0xE1 },\t \n\t{ 0x98,\t\t \n\t  0x98,\t\t \n\t  0xE2,\t\t \n\t  0xE2 }\t \n};\n\n#define W83792D_REG_GPIO_EN\t\t0x1A\n#define W83792D_REG_CONFIG\t\t0x40\n#define W83792D_REG_VID_FANDIV\t\t0x47\n#define W83792D_REG_CHIPID\t\t0x49\n#define W83792D_REG_WCHIPID\t\t0x58\n#define W83792D_REG_CHIPMAN\t\t0x4F\n#define W83792D_REG_PIN\t\t\t0x4B\n#define W83792D_REG_I2C_SUBADDR\t\t0x4A\n\n#define W83792D_REG_ALARM1 0xA9\t\t \n#define W83792D_REG_ALARM2 0xAA\t\t \n#define W83792D_REG_ALARM3 0xAB\t\t \n#define W83792D_REG_CHASSIS 0x42\t \n#define W83792D_REG_CHASSIS_CLR 0x44\t \n\n \n#define W83792D_REG_VID_IN_B\t\t0x17\n\n#define W83792D_REG_VBAT\t\t0x5D\n#define W83792D_REG_I2C_ADDR\t\t0x48\n\n \n#define IN_FROM_REG(nr, val) (((nr) <= 1) ? ((val) * 2) : \\\n\t\t((((nr) == 6) || ((nr) == 7)) ? ((val) * 6) : ((val) * 4)))\n#define IN_TO_REG(nr, val) (((nr) <= 1) ? ((val) / 2) : \\\n\t\t((((nr) == 6) || ((nr) == 7)) ? ((val) / 6) : ((val) / 4)))\n\nstatic inline u8\nFAN_TO_REG(long rpm, int div)\n{\n\tif (rpm == 0)\n\t\treturn 255;\n\trpm = clamp_val(rpm, 1, 1000000);\n\treturn clamp_val((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\n}\n\n#define FAN_FROM_REG(val, div)\t((val) == 0   ? -1 : \\\n\t\t\t\t((val) == 255 ? 0 : \\\n\t\t\t\t\t\t1350000 / ((val) * (div))))\n\n \n#define TEMP1_TO_REG(val)\t(clamp_val(((val) < 0 ? (val) + 0x100 * 1000 \\\n\t\t\t\t\t\t      : (val)) / 1000, 0, 0xff))\n#define TEMP1_FROM_REG(val)\t(((val) & 0x80 ? (val)-0x100 : (val)) * 1000)\n \n#define TEMP_ADD_FROM_REG(val1, val2) \\\n\t((((val1) & 0x80 ? (val1)-0x100 \\\n\t\t: (val1)) * 1000) + ((val2 & 0x80) ? 500 : 0))\n#define TEMP_ADD_TO_REG_HIGH(val) \\\n\t(clamp_val(((val) < 0 ? (val) + 0x100 * 1000 : (val)) / 1000, 0, 0xff))\n#define TEMP_ADD_TO_REG_LOW(val)\t((val%1000) ? 0x80 : 0x00)\n\n#define DIV_FROM_REG(val)\t\t(1 << (val))\n\nstatic inline u8\nDIV_TO_REG(long val)\n{\n\tint i;\n\tval = clamp_val(val, 1, 128) >> 1;\n\tfor (i = 0; i < 7; i++) {\n\t\tif (val == 0)\n\t\t\tbreak;\n\t\tval >>= 1;\n\t}\n\treturn (u8)i;\n}\n\nstruct w83792d_data {\n\tstruct device *hwmon_dev;\n\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\n\tu8 in[9];\t\t \n\tu8 in_max[9];\t\t \n\tu8 in_min[9];\t\t \n\tu16 low_bits;\t\t \n\tu8 fan[7];\t\t \n\tu8 fan_min[7];\t\t \n\tu8 temp1[3];\t\t \n\tu8 temp_add[2][6];\t \n\tu8 fan_div[7];\t\t \n\tu8 pwm[7];\t\t \n\tu8 pwmenable[3];\n\tu32 alarms;\t\t \n\tu8 chassis;\t\t \n\tu8 thermal_cruise[3];\t \n\tu8 tolerance[3];\t \n\tu8 sf2_points[3][4];\t \n\tu8 sf2_levels[3][4];\t \n};\n\nstatic int w83792d_probe(struct i2c_client *client);\nstatic int w83792d_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info);\nstatic void w83792d_remove(struct i2c_client *client);\nstatic struct w83792d_data *w83792d_update_device(struct device *dev);\n\n#ifdef DEBUG\nstatic void w83792d_print_debug(struct w83792d_data *data, struct device *dev);\n#endif\n\nstatic void w83792d_init_client(struct i2c_client *client);\n\nstatic const struct i2c_device_id w83792d_id[] = {\n\t{ \"w83792d\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, w83792d_id);\n\nstatic struct i2c_driver w83792d_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"w83792d\",\n\t},\n\t.probe\t\t= w83792d_probe,\n\t.remove\t\t= w83792d_remove,\n\t.id_table\t= w83792d_id,\n\t.detect\t\t= w83792d_detect,\n\t.address_list\t= normal_i2c,\n};\n\nstatic inline long in_count_from_reg(int nr, struct w83792d_data *data)\n{\n\t \n\treturn (data->in[nr] << 2) | ((data->low_bits >> (2 * nr)) & 0x03);\n}\n\n \nstatic inline int w83792d_read_value(struct i2c_client *client, u8 reg)\n{\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic inline int\nw83792d_write_value(struct i2c_client *client, u8 reg, u8 value)\n{\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\n \nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\",\n\t\t       IN_FROM_REG(nr, in_count_from_reg(nr, data)));\n}\n\n#define show_in_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\t\tchar *buf) \\\n{ \\\n\tstruct sensor_device_attribute *sensor_attr \\\n\t\t= to_sensor_dev_attr(attr); \\\n\tint nr = sensor_attr->index; \\\n\tstruct w83792d_data *data = w83792d_update_device(dev); \\\n\treturn sprintf(buf, \"%ld\\n\", \\\n\t\t       (long)(IN_FROM_REG(nr, data->reg[nr]) * 4)); \\\n}\n\nshow_in_reg(in_min);\nshow_in_reg(in_max);\n\n#define store_in_reg(REG, reg) \\\nstatic ssize_t store_in_##reg(struct device *dev, \\\n\t\t\t\tstruct device_attribute *attr, \\\n\t\t\t\tconst char *buf, size_t count) \\\n{ \\\n\tstruct sensor_device_attribute *sensor_attr \\\n\t\t\t= to_sensor_dev_attr(attr); \\\n\tint nr = sensor_attr->index; \\\n\tstruct i2c_client *client = to_i2c_client(dev); \\\n\tstruct w83792d_data *data = i2c_get_clientdata(client); \\\n\tunsigned long val; \\\n\tint err = kstrtoul(buf, 10, &val); \\\n\tif (err) \\\n\t\treturn err; \\\n\tmutex_lock(&data->update_lock); \\\n\tdata->in_##reg[nr] = clamp_val(IN_TO_REG(nr, val) / 4, 0, 255); \\\n\tw83792d_write_value(client, W83792D_REG_IN_##REG[nr], \\\n\t\t\t    data->in_##reg[nr]); \\\n\tmutex_unlock(&data->update_lock); \\\n\t \\\n\treturn count; \\\n}\nstore_in_reg(MIN, min);\nstore_in_reg(MAX, max);\n\n#define show_fan_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\t\tchar *buf) \\\n{ \\\n\tstruct sensor_device_attribute *sensor_attr \\\n\t\t\t= to_sensor_dev_attr(attr); \\\n\tint nr = sensor_attr->index - 1; \\\n\tstruct w83792d_data *data = w83792d_update_device(dev); \\\n\treturn sprintf(buf, \"%d\\n\", \\\n\t\tFAN_FROM_REG(data->reg[nr], DIV_FROM_REG(data->fan_div[nr]))); \\\n}\n\nshow_fan_reg(fan);\nshow_fan_reg(fan_min);\n\nstatic ssize_t\nstore_fan_min(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index - 1;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\n\tw83792d_write_value(client, W83792D_REG_FAN_MIN[nr],\n\t\t\t\tdata->fan_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_fan_div(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", DIV_FROM_REG(data->fan_div[nr - 1]));\n}\n\n \nstatic ssize_t\nstore_fan_div(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index - 1;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tunsigned long min;\n\t \n\tu8 fan_div_reg = 0;\n\tu8 tmp_fan_div;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmutex_lock(&data->update_lock);\n\tmin = FAN_FROM_REG(data->fan_min[nr],\n\t\t\t   DIV_FROM_REG(data->fan_div[nr]));\n\n\tdata->fan_div[nr] = DIV_TO_REG(val);\n\n\tfan_div_reg = w83792d_read_value(client, W83792D_REG_FAN_DIV[nr >> 1]);\n\tfan_div_reg &= (nr & 0x01) ? 0x8f : 0xf8;\n\ttmp_fan_div = (nr & 0x01) ? (((data->fan_div[nr]) << 4) & 0x70)\n\t\t\t\t\t: ((data->fan_div[nr]) & 0x07);\n\tw83792d_write_value(client, W83792D_REG_FAN_DIV[nr >> 1],\n\t\t\t\t\tfan_div_reg | tmp_fan_div);\n\n\t \n\tdata->fan_min[nr] = FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\n\tw83792d_write_value(client, W83792D_REG_FAN_MIN[nr], data->fan_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\nstatic ssize_t show_temp1(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP1_FROM_REG(data->temp1[nr]));\n}\n\nstatic ssize_t store_temp1(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp1[nr] = TEMP1_TO_REG(val);\n\tw83792d_write_value(client, W83792D_REG_TEMP1[nr],\n\t\tdata->temp1[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\nstatic ssize_t show_temp23(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr\n\t  = to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\",\n\t\t(long)TEMP_ADD_FROM_REG(data->temp_add[nr][index],\n\t\t\tdata->temp_add[nr][index+1]));\n}\n\nstatic ssize_t store_temp23(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr\n\t  = to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_add[nr][index] = TEMP_ADD_TO_REG_HIGH(val);\n\tdata->temp_add[nr][index+1] = TEMP_ADD_TO_REG_LOW(val);\n\tw83792d_write_value(client, W83792D_REG_TEMP_ADD[nr][index],\n\t\tdata->temp_add[nr][index]);\n\tw83792d_write_value(client, W83792D_REG_TEMP_ADD[nr][index+1],\n\t\tdata->temp_add[nr][index+1]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \nstatic ssize_t\nalarms_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->alarms);\n}\n\nstatic ssize_t show_alarm(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (data->alarms >> nr) & 1);\n}\n\nstatic ssize_t\nshow_pwm(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (data->pwm[nr] & 0x0f) << 4);\n}\n\nstatic ssize_t\nshow_pwmenable(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index - 1;\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\tlong pwm_enable_tmp = 1;\n\n\tswitch (data->pwmenable[nr]) {\n\tcase 0:\n\t\tpwm_enable_tmp = 1;  \n\t\tbreak;\n\tcase 1:\n\t\tpwm_enable_tmp = 3;  \n\t\tbreak;\n\tcase 2:\n\t\tpwm_enable_tmp = 2;  \n\t\tbreak;\n\t}\n\n\treturn sprintf(buf, \"%ld\\n\", pwm_enable_tmp);\n}\n\nstatic ssize_t\nstore_pwm(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tval = clamp_val(val, 0, 255) >> 4;\n\n\tmutex_lock(&data->update_lock);\n\tval |= w83792d_read_value(client, W83792D_REG_PWM[nr]) & 0xf0;\n\tdata->pwm[nr] = val;\n\tw83792d_write_value(client, W83792D_REG_PWM[nr], data->pwm[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\nstore_pwmenable(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index - 1;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tu8 fan_cfg_tmp, cfg1_tmp, cfg2_tmp, cfg3_tmp, cfg4_tmp;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val < 1 || val > 3)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (val) {\n\tcase 1:\n\t\tdata->pwmenable[nr] = 0;  \n\t\tbreak;\n\tcase 2:\n\t\tdata->pwmenable[nr] = 2;  \n\t\tbreak;\n\tcase 3:\n\t\tdata->pwmenable[nr] = 1;  \n\t\tbreak;\n\t}\n\tcfg1_tmp = data->pwmenable[0];\n\tcfg2_tmp = (data->pwmenable[1]) << 2;\n\tcfg3_tmp = (data->pwmenable[2]) << 4;\n\tcfg4_tmp = w83792d_read_value(client, W83792D_REG_FAN_CFG) & 0xc0;\n\tfan_cfg_tmp = ((cfg4_tmp | cfg3_tmp) | cfg2_tmp) | cfg1_tmp;\n\tw83792d_write_value(client, W83792D_REG_FAN_CFG, fan_cfg_tmp);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_pwm_mode(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm[nr] >> 7);\n}\n\nstatic ssize_t\nstore_pwm_mode(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm[nr] = w83792d_read_value(client, W83792D_REG_PWM[nr]);\n\tif (val) {\t\t\t \n\t\tdata->pwm[nr] |= 0x80;\n\t} else {\t\t\t \n\t\tdata->pwm[nr] &= 0x7f;\n\t}\n\tw83792d_write_value(client, W83792D_REG_PWM[nr], data->pwm[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\nintrusion0_alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->chassis);\n}\n\nstatic ssize_t\nintrusion0_alarm_store(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tu8 reg;\n\n\tif (kstrtoul(buf, 10, &val) || val != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\treg = w83792d_read_value(client, W83792D_REG_CHASSIS_CLR);\n\tw83792d_write_value(client, W83792D_REG_CHASSIS_CLR, reg | 0x80);\n\tdata->valid = false;\t\t \n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \nstatic ssize_t\nshow_thermal_cruise(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long)data->thermal_cruise[nr-1]);\n}\n\nstatic ssize_t\nstore_thermal_cruise(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index - 1;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tu8 target_tmp = 0, target_mask = 0;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\ttarget_tmp = val;\n\ttarget_tmp = target_tmp & 0x7f;\n\tmutex_lock(&data->update_lock);\n\ttarget_mask = w83792d_read_value(client,\n\t\t\t\t\t W83792D_REG_THERMAL[nr]) & 0x80;\n\tdata->thermal_cruise[nr] = clamp_val(target_tmp, 0, 255);\n\tw83792d_write_value(client, W83792D_REG_THERMAL[nr],\n\t\t(data->thermal_cruise[nr]) | target_mask);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \nstatic ssize_t\nshow_tolerance(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long)data->tolerance[nr-1]);\n}\n\nstatic ssize_t\nstore_tolerance(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index - 1;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tu8 tol_tmp, tol_mask;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\ttol_mask = w83792d_read_value(client,\n\t\tW83792D_REG_TOLERANCE[nr]) & ((nr == 1) ? 0x0f : 0xf0);\n\ttol_tmp = clamp_val(val, 0, 15);\n\ttol_tmp &= 0x0f;\n\tdata->tolerance[nr] = tol_tmp;\n\tif (nr == 1)\n\t\ttol_tmp <<= 4;\n\tw83792d_write_value(client, W83792D_REG_TOLERANCE[nr],\n\t\ttol_mask | tol_tmp);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \nstatic ssize_t\nshow_sf2_point(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr\n\t  = to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long)data->sf2_points[index-1][nr-1]);\n}\n\nstatic ssize_t\nstore_sf2_point(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr\n\t  = to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr - 1;\n\tint index = sensor_attr->index - 1;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tu8 mask_tmp = 0;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->sf2_points[index][nr] = clamp_val(val, 0, 127);\n\tmask_tmp = w83792d_read_value(client,\n\t\t\t\t\tW83792D_REG_POINTS[index][nr]) & 0x80;\n\tw83792d_write_value(client, W83792D_REG_POINTS[index][nr],\n\t\tmask_tmp|data->sf2_points[index][nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_sf2_level(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr\n\t  = to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83792d_data *data = w83792d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t\t(((data->sf2_levels[index-1][nr]) * 100) / 15));\n}\n\nstatic ssize_t\nstore_sf2_level(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr\n\t  = to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index - 1;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tu8 mask_tmp = 0, level_tmp = 0;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->sf2_levels[index][nr] = clamp_val((val * 15) / 100, 0, 15);\n\tmask_tmp = w83792d_read_value(client, W83792D_REG_LEVELS[index][nr])\n\t\t& ((nr == 3) ? 0xf0 : 0x0f);\n\tif (nr == 3)\n\t\tlevel_tmp = data->sf2_levels[index][nr];\n\telse\n\t\tlevel_tmp = data->sf2_levels[index][nr] << 4;\n\tw83792d_write_value(client, W83792D_REG_LEVELS[index][nr],\n\t\t\t    level_tmp | mask_tmp);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n\nstatic int\nw83792d_detect_subclients(struct i2c_client *new_client)\n{\n\tint i, id;\n\tint address = new_client->addr;\n\tu8 val;\n\tstruct i2c_adapter *adapter = new_client->adapter;\n\n\tid = i2c_adapter_id(adapter);\n\tif (force_subclients[0] == id && force_subclients[1] == address) {\n\t\tfor (i = 2; i <= 3; i++) {\n\t\t\tif (force_subclients[i] < 0x48 ||\n\t\t\t    force_subclients[i] > 0x4f) {\n\t\t\t\tdev_err(&new_client->dev,\n\t\t\t\t\t\"invalid subclient address %d; must be 0x48-0x4f\\n\",\n\t\t\t\t\tforce_subclients[i]);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t\tw83792d_write_value(new_client, W83792D_REG_I2C_SUBADDR,\n\t\t\t\t\t(force_subclients[2] & 0x07) |\n\t\t\t\t\t((force_subclients[3] & 0x07) << 4));\n\t}\n\n\tval = w83792d_read_value(new_client, W83792D_REG_I2C_SUBADDR);\n\n\tif (!(val & 0x88) && (val & 0x7) == ((val >> 4) & 0x7)) {\n\t\tdev_err(&new_client->dev,\n\t\t\t\"duplicate addresses 0x%x, use force_subclient\\n\", 0x48 + (val & 0x7));\n\t\treturn -ENODEV;\n\t}\n\n\tif (!(val & 0x08))\n\t\tdevm_i2c_new_dummy_device(&new_client->dev, adapter, 0x48 + (val & 0x7));\n\n\tif (!(val & 0x80))\n\t\tdevm_i2c_new_dummy_device(&new_client->dev, adapter, 0x48 + ((val >> 4) & 0x7));\n\n\treturn 0;\n}\n\nstatic SENSOR_DEVICE_ATTR(in0_input, S_IRUGO, show_in, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(in1_input, S_IRUGO, show_in, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in2_input, S_IRUGO, show_in, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(in3_input, S_IRUGO, show_in, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(in4_input, S_IRUGO, show_in, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(in5_input, S_IRUGO, show_in, NULL, 5);\nstatic SENSOR_DEVICE_ATTR(in6_input, S_IRUGO, show_in, NULL, 6);\nstatic SENSOR_DEVICE_ATTR(in7_input, S_IRUGO, show_in, NULL, 7);\nstatic SENSOR_DEVICE_ATTR(in8_input, S_IRUGO, show_in, NULL, 8);\nstatic SENSOR_DEVICE_ATTR(in0_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_min, store_in_min, 0);\nstatic SENSOR_DEVICE_ATTR(in1_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_min, store_in_min, 1);\nstatic SENSOR_DEVICE_ATTR(in2_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_min, store_in_min, 2);\nstatic SENSOR_DEVICE_ATTR(in3_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_min, store_in_min, 3);\nstatic SENSOR_DEVICE_ATTR(in4_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_min, store_in_min, 4);\nstatic SENSOR_DEVICE_ATTR(in5_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_min, store_in_min, 5);\nstatic SENSOR_DEVICE_ATTR(in6_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_min, store_in_min, 6);\nstatic SENSOR_DEVICE_ATTR(in7_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_min, store_in_min, 7);\nstatic SENSOR_DEVICE_ATTR(in8_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_min, store_in_min, 8);\nstatic SENSOR_DEVICE_ATTR(in0_max, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_max, store_in_max, 0);\nstatic SENSOR_DEVICE_ATTR(in1_max, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_max, store_in_max, 1);\nstatic SENSOR_DEVICE_ATTR(in2_max, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_max, store_in_max, 2);\nstatic SENSOR_DEVICE_ATTR(in3_max, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_max, store_in_max, 3);\nstatic SENSOR_DEVICE_ATTR(in4_max, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_max, store_in_max, 4);\nstatic SENSOR_DEVICE_ATTR(in5_max, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_max, store_in_max, 5);\nstatic SENSOR_DEVICE_ATTR(in6_max, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_max, store_in_max, 6);\nstatic SENSOR_DEVICE_ATTR(in7_max, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_max, store_in_max, 7);\nstatic SENSOR_DEVICE_ATTR(in8_max, S_IWUSR | S_IRUGO,\n\t\t\tshow_in_max, store_in_max, 8);\nstatic SENSOR_DEVICE_ATTR_2(temp1_input, S_IRUGO, show_temp1, NULL, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2(temp2_input, S_IRUGO, show_temp23, NULL, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2(temp3_input, S_IRUGO, show_temp23, NULL, 1, 0);\nstatic SENSOR_DEVICE_ATTR_2(temp1_max, S_IRUGO | S_IWUSR,\n\t\t\tshow_temp1, store_temp1, 0, 1);\nstatic SENSOR_DEVICE_ATTR_2(temp2_max, S_IRUGO | S_IWUSR, show_temp23,\n\t\t\tstore_temp23, 0, 2);\nstatic SENSOR_DEVICE_ATTR_2(temp3_max, S_IRUGO | S_IWUSR, show_temp23,\n\t\t\tstore_temp23, 1, 2);\nstatic SENSOR_DEVICE_ATTR_2(temp1_max_hyst, S_IRUGO | S_IWUSR,\n\t\t\tshow_temp1, store_temp1, 0, 2);\nstatic SENSOR_DEVICE_ATTR_2(temp2_max_hyst, S_IRUGO | S_IWUSR,\n\t\t\tshow_temp23, store_temp23, 0, 4);\nstatic SENSOR_DEVICE_ATTR_2(temp3_max_hyst, S_IRUGO | S_IWUSR,\n\t\t\tshow_temp23, store_temp23, 1, 4);\nstatic DEVICE_ATTR_RO(alarms);\nstatic SENSOR_DEVICE_ATTR(in0_alarm, S_IRUGO, show_alarm, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(in1_alarm, S_IRUGO, show_alarm, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(temp1_alarm, S_IRUGO, show_alarm, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(temp2_alarm, S_IRUGO, show_alarm, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(temp3_alarm, S_IRUGO, show_alarm, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(fan1_alarm, S_IRUGO, show_alarm, NULL, 5);\nstatic SENSOR_DEVICE_ATTR(fan2_alarm, S_IRUGO, show_alarm, NULL, 6);\nstatic SENSOR_DEVICE_ATTR(fan3_alarm, S_IRUGO, show_alarm, NULL, 7);\nstatic SENSOR_DEVICE_ATTR(in2_alarm, S_IRUGO, show_alarm, NULL, 8);\nstatic SENSOR_DEVICE_ATTR(in3_alarm, S_IRUGO, show_alarm, NULL, 9);\nstatic SENSOR_DEVICE_ATTR(in4_alarm, S_IRUGO, show_alarm, NULL, 10);\nstatic SENSOR_DEVICE_ATTR(in5_alarm, S_IRUGO, show_alarm, NULL, 11);\nstatic SENSOR_DEVICE_ATTR(in6_alarm, S_IRUGO, show_alarm, NULL, 12);\nstatic SENSOR_DEVICE_ATTR(fan7_alarm, S_IRUGO, show_alarm, NULL, 15);\nstatic SENSOR_DEVICE_ATTR(in7_alarm, S_IRUGO, show_alarm, NULL, 19);\nstatic SENSOR_DEVICE_ATTR(in8_alarm, S_IRUGO, show_alarm, NULL, 20);\nstatic SENSOR_DEVICE_ATTR(fan4_alarm, S_IRUGO, show_alarm, NULL, 21);\nstatic SENSOR_DEVICE_ATTR(fan5_alarm, S_IRUGO, show_alarm, NULL, 22);\nstatic SENSOR_DEVICE_ATTR(fan6_alarm, S_IRUGO, show_alarm, NULL, 23);\nstatic DEVICE_ATTR_RW(intrusion0_alarm);\nstatic SENSOR_DEVICE_ATTR(pwm1, S_IWUSR | S_IRUGO, show_pwm, store_pwm, 0);\nstatic SENSOR_DEVICE_ATTR(pwm2, S_IWUSR | S_IRUGO, show_pwm, store_pwm, 1);\nstatic SENSOR_DEVICE_ATTR(pwm3, S_IWUSR | S_IRUGO, show_pwm, store_pwm, 2);\nstatic SENSOR_DEVICE_ATTR(pwm4, S_IWUSR | S_IRUGO, show_pwm, store_pwm, 3);\nstatic SENSOR_DEVICE_ATTR(pwm5, S_IWUSR | S_IRUGO, show_pwm, store_pwm, 4);\nstatic SENSOR_DEVICE_ATTR(pwm6, S_IWUSR | S_IRUGO, show_pwm, store_pwm, 5);\nstatic SENSOR_DEVICE_ATTR(pwm7, S_IWUSR | S_IRUGO, show_pwm, store_pwm, 6);\nstatic SENSOR_DEVICE_ATTR(pwm1_enable, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwmenable, store_pwmenable, 1);\nstatic SENSOR_DEVICE_ATTR(pwm2_enable, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwmenable, store_pwmenable, 2);\nstatic SENSOR_DEVICE_ATTR(pwm3_enable, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwmenable, store_pwmenable, 3);\nstatic SENSOR_DEVICE_ATTR(pwm1_mode, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwm_mode, store_pwm_mode, 0);\nstatic SENSOR_DEVICE_ATTR(pwm2_mode, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwm_mode, store_pwm_mode, 1);\nstatic SENSOR_DEVICE_ATTR(pwm3_mode, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwm_mode, store_pwm_mode, 2);\nstatic SENSOR_DEVICE_ATTR(pwm4_mode, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwm_mode, store_pwm_mode, 3);\nstatic SENSOR_DEVICE_ATTR(pwm5_mode, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwm_mode, store_pwm_mode, 4);\nstatic SENSOR_DEVICE_ATTR(pwm6_mode, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwm_mode, store_pwm_mode, 5);\nstatic SENSOR_DEVICE_ATTR(pwm7_mode, S_IWUSR | S_IRUGO,\n\t\t\tshow_pwm_mode, store_pwm_mode, 6);\nstatic SENSOR_DEVICE_ATTR(tolerance1, S_IWUSR | S_IRUGO,\n\t\t\tshow_tolerance, store_tolerance, 1);\nstatic SENSOR_DEVICE_ATTR(tolerance2, S_IWUSR | S_IRUGO,\n\t\t\tshow_tolerance, store_tolerance, 2);\nstatic SENSOR_DEVICE_ATTR(tolerance3, S_IWUSR | S_IRUGO,\n\t\t\tshow_tolerance, store_tolerance, 3);\nstatic SENSOR_DEVICE_ATTR(thermal_cruise1, S_IWUSR | S_IRUGO,\n\t\t\tshow_thermal_cruise, store_thermal_cruise, 1);\nstatic SENSOR_DEVICE_ATTR(thermal_cruise2, S_IWUSR | S_IRUGO,\n\t\t\tshow_thermal_cruise, store_thermal_cruise, 2);\nstatic SENSOR_DEVICE_ATTR(thermal_cruise3, S_IWUSR | S_IRUGO,\n\t\t\tshow_thermal_cruise, store_thermal_cruise, 3);\nstatic SENSOR_DEVICE_ATTR_2(sf2_point1_fan1, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_point, store_sf2_point, 1, 1);\nstatic SENSOR_DEVICE_ATTR_2(sf2_point2_fan1, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_point, store_sf2_point, 2, 1);\nstatic SENSOR_DEVICE_ATTR_2(sf2_point3_fan1, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_point, store_sf2_point, 3, 1);\nstatic SENSOR_DEVICE_ATTR_2(sf2_point4_fan1, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_point, store_sf2_point, 4, 1);\nstatic SENSOR_DEVICE_ATTR_2(sf2_point1_fan2, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_point, store_sf2_point, 1, 2);\nstatic SENSOR_DEVICE_ATTR_2(sf2_point2_fan2, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_point, store_sf2_point, 2, 2);\nstatic SENSOR_DEVICE_ATTR_2(sf2_point3_fan2, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_point, store_sf2_point, 3, 2);\nstatic SENSOR_DEVICE_ATTR_2(sf2_point4_fan2, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_point, store_sf2_point, 4, 2);\nstatic SENSOR_DEVICE_ATTR_2(sf2_point1_fan3, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_point, store_sf2_point, 1, 3);\nstatic SENSOR_DEVICE_ATTR_2(sf2_point2_fan3, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_point, store_sf2_point, 2, 3);\nstatic SENSOR_DEVICE_ATTR_2(sf2_point3_fan3, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_point, store_sf2_point, 3, 3);\nstatic SENSOR_DEVICE_ATTR_2(sf2_point4_fan3, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_point, store_sf2_point, 4, 3);\nstatic SENSOR_DEVICE_ATTR_2(sf2_level1_fan1, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_level, store_sf2_level, 1, 1);\nstatic SENSOR_DEVICE_ATTR_2(sf2_level2_fan1, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_level, store_sf2_level, 2, 1);\nstatic SENSOR_DEVICE_ATTR_2(sf2_level3_fan1, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_level, store_sf2_level, 3, 1);\nstatic SENSOR_DEVICE_ATTR_2(sf2_level1_fan2, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_level, store_sf2_level, 1, 2);\nstatic SENSOR_DEVICE_ATTR_2(sf2_level2_fan2, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_level, store_sf2_level, 2, 2);\nstatic SENSOR_DEVICE_ATTR_2(sf2_level3_fan2, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_level, store_sf2_level, 3, 2);\nstatic SENSOR_DEVICE_ATTR_2(sf2_level1_fan3, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_level, store_sf2_level, 1, 3);\nstatic SENSOR_DEVICE_ATTR_2(sf2_level2_fan3, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_level, store_sf2_level, 2, 3);\nstatic SENSOR_DEVICE_ATTR_2(sf2_level3_fan3, S_IRUGO | S_IWUSR,\n\t\t\tshow_sf2_level, store_sf2_level, 3, 3);\nstatic SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO, show_fan, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(fan2_input, S_IRUGO, show_fan, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(fan3_input, S_IRUGO, show_fan, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(fan4_input, S_IRUGO, show_fan, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(fan5_input, S_IRUGO, show_fan, NULL, 5);\nstatic SENSOR_DEVICE_ATTR(fan6_input, S_IRUGO, show_fan, NULL, 6);\nstatic SENSOR_DEVICE_ATTR(fan7_input, S_IRUGO, show_fan, NULL, 7);\nstatic SENSOR_DEVICE_ATTR(fan1_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_min, store_fan_min, 1);\nstatic SENSOR_DEVICE_ATTR(fan2_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_min, store_fan_min, 2);\nstatic SENSOR_DEVICE_ATTR(fan3_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_min, store_fan_min, 3);\nstatic SENSOR_DEVICE_ATTR(fan4_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_min, store_fan_min, 4);\nstatic SENSOR_DEVICE_ATTR(fan5_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_min, store_fan_min, 5);\nstatic SENSOR_DEVICE_ATTR(fan6_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_min, store_fan_min, 6);\nstatic SENSOR_DEVICE_ATTR(fan7_min, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_min, store_fan_min, 7);\nstatic SENSOR_DEVICE_ATTR(fan1_div, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_div, store_fan_div, 1);\nstatic SENSOR_DEVICE_ATTR(fan2_div, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_div, store_fan_div, 2);\nstatic SENSOR_DEVICE_ATTR(fan3_div, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_div, store_fan_div, 3);\nstatic SENSOR_DEVICE_ATTR(fan4_div, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_div, store_fan_div, 4);\nstatic SENSOR_DEVICE_ATTR(fan5_div, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_div, store_fan_div, 5);\nstatic SENSOR_DEVICE_ATTR(fan6_div, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_div, store_fan_div, 6);\nstatic SENSOR_DEVICE_ATTR(fan7_div, S_IWUSR | S_IRUGO,\n\t\t\tshow_fan_div, store_fan_div, 7);\n\nstatic struct attribute *w83792d_attributes_fan[4][7] = {\n\t{\n\t\t&sensor_dev_attr_fan4_input.dev_attr.attr,\n\t\t&sensor_dev_attr_fan4_min.dev_attr.attr,\n\t\t&sensor_dev_attr_fan4_div.dev_attr.attr,\n\t\t&sensor_dev_attr_fan4_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_pwm4.dev_attr.attr,\n\t\t&sensor_dev_attr_pwm4_mode.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_fan5_input.dev_attr.attr,\n\t\t&sensor_dev_attr_fan5_min.dev_attr.attr,\n\t\t&sensor_dev_attr_fan5_div.dev_attr.attr,\n\t\t&sensor_dev_attr_fan5_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_pwm5.dev_attr.attr,\n\t\t&sensor_dev_attr_pwm5_mode.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_fan6_input.dev_attr.attr,\n\t\t&sensor_dev_attr_fan6_min.dev_attr.attr,\n\t\t&sensor_dev_attr_fan6_div.dev_attr.attr,\n\t\t&sensor_dev_attr_fan6_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_pwm6.dev_attr.attr,\n\t\t&sensor_dev_attr_pwm6_mode.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_fan7_input.dev_attr.attr,\n\t\t&sensor_dev_attr_fan7_min.dev_attr.attr,\n\t\t&sensor_dev_attr_fan7_div.dev_attr.attr,\n\t\t&sensor_dev_attr_fan7_alarm.dev_attr.attr,\n\t\t&sensor_dev_attr_pwm7.dev_attr.attr,\n\t\t&sensor_dev_attr_pwm7_mode.dev_attr.attr,\n\t\tNULL\n\t}\n};\n\nstatic const struct attribute_group w83792d_group_fan[4] = {\n\t{ .attrs = w83792d_attributes_fan[0] },\n\t{ .attrs = w83792d_attributes_fan[1] },\n\t{ .attrs = w83792d_attributes_fan[2] },\n\t{ .attrs = w83792d_attributes_fan[3] },\n};\n\nstatic struct attribute *w83792d_attributes[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_max.dev_attr.attr,\n\t&sensor_dev_attr_in6_min.dev_attr.attr,\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_max.dev_attr.attr,\n\t&sensor_dev_attr_in7_min.dev_attr.attr,\n\t&sensor_dev_attr_in8_input.dev_attr.attr,\n\t&sensor_dev_attr_in8_max.dev_attr.attr,\n\t&sensor_dev_attr_in8_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in5_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in6_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in7_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in8_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_mode.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_mode.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_mode.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\t&dev_attr_alarms.attr,\n\t&dev_attr_intrusion0_alarm.attr,\n\t&sensor_dev_attr_tolerance1.dev_attr.attr,\n\t&sensor_dev_attr_thermal_cruise1.dev_attr.attr,\n\t&sensor_dev_attr_tolerance2.dev_attr.attr,\n\t&sensor_dev_attr_thermal_cruise2.dev_attr.attr,\n\t&sensor_dev_attr_tolerance3.dev_attr.attr,\n\t&sensor_dev_attr_thermal_cruise3.dev_attr.attr,\n\t&sensor_dev_attr_sf2_point1_fan1.dev_attr.attr,\n\t&sensor_dev_attr_sf2_point2_fan1.dev_attr.attr,\n\t&sensor_dev_attr_sf2_point3_fan1.dev_attr.attr,\n\t&sensor_dev_attr_sf2_point4_fan1.dev_attr.attr,\n\t&sensor_dev_attr_sf2_point1_fan2.dev_attr.attr,\n\t&sensor_dev_attr_sf2_point2_fan2.dev_attr.attr,\n\t&sensor_dev_attr_sf2_point3_fan2.dev_attr.attr,\n\t&sensor_dev_attr_sf2_point4_fan2.dev_attr.attr,\n\t&sensor_dev_attr_sf2_point1_fan3.dev_attr.attr,\n\t&sensor_dev_attr_sf2_point2_fan3.dev_attr.attr,\n\t&sensor_dev_attr_sf2_point3_fan3.dev_attr.attr,\n\t&sensor_dev_attr_sf2_point4_fan3.dev_attr.attr,\n\t&sensor_dev_attr_sf2_level1_fan1.dev_attr.attr,\n\t&sensor_dev_attr_sf2_level2_fan1.dev_attr.attr,\n\t&sensor_dev_attr_sf2_level3_fan1.dev_attr.attr,\n\t&sensor_dev_attr_sf2_level1_fan2.dev_attr.attr,\n\t&sensor_dev_attr_sf2_level2_fan2.dev_attr.attr,\n\t&sensor_dev_attr_sf2_level3_fan2.dev_attr.attr,\n\t&sensor_dev_attr_sf2_level1_fan3.dev_attr.attr,\n\t&sensor_dev_attr_sf2_level2_fan3.dev_attr.attr,\n\t&sensor_dev_attr_sf2_level3_fan3.dev_attr.attr,\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_div.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_div.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_div.dev_attr.attr,\n\t&sensor_dev_attr_fan3_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group w83792d_group = {\n\t.attrs = w83792d_attributes,\n};\n\n \nstatic int\nw83792d_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint val1, val2;\n\tunsigned short address = client->addr;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tif (w83792d_read_value(client, W83792D_REG_CONFIG) & 0x80)\n\t\treturn -ENODEV;\n\n\tval1 = w83792d_read_value(client, W83792D_REG_BANK);\n\tval2 = w83792d_read_value(client, W83792D_REG_CHIPMAN);\n\t \n\tif (!(val1 & 0x07)) {   \n\t\tif ((!(val1 & 0x80) && val2 != 0xa3) ||\n\t\t    ((val1 & 0x80) && val2 != 0x5c))\n\t\t\treturn -ENODEV;\n\t}\n\t \n\tif (w83792d_read_value(client, W83792D_REG_I2C_ADDR) != address)\n\t\treturn -ENODEV;\n\n\t \n\tw83792d_write_value(client,\n\t\t\t    W83792D_REG_BANK,\n\t\t\t    (w83792d_read_value(client,\n\t\t\t\tW83792D_REG_BANK) & 0x78) | 0x80);\n\n\t \n\tval1 = w83792d_read_value(client, W83792D_REG_WCHIPID);\n\tval2 = w83792d_read_value(client, W83792D_REG_CHIPMAN);\n\tif (val1 != 0x7a || val2 != 0x5c)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"w83792d\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int\nw83792d_probe(struct i2c_client *client)\n{\n\tstruct w83792d_data *data;\n\tstruct device *dev = &client->dev;\n\tint i, val1, err;\n\n\tdata = devm_kzalloc(dev, sizeof(struct w83792d_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\n\terr = w83792d_detect_subclients(client);\n\tif (err)\n\t\treturn err;\n\n\t \n\tw83792d_init_client(client);\n\n\t \n\tfor (i = 0; i < 7; i++) {\n\t\tdata->fan_min[i] = w83792d_read_value(client,\n\t\t\t\t\tW83792D_REG_FAN_MIN[i]);\n\t}\n\n\t \n\terr = sysfs_create_group(&dev->kobj, &w83792d_group);\n\tif (err)\n\t\treturn err;\n\n\t \n\tval1 = w83792d_read_value(client, W83792D_REG_GPIO_EN);\n\n\tif (!(val1 & 0x40)) {\n\t\terr = sysfs_create_group(&dev->kobj, &w83792d_group_fan[0]);\n\t\tif (err)\n\t\t\tgoto exit_remove_files;\n\t}\n\n\tif (!(val1 & 0x20)) {\n\t\terr = sysfs_create_group(&dev->kobj, &w83792d_group_fan[1]);\n\t\tif (err)\n\t\t\tgoto exit_remove_files;\n\t}\n\n\tval1 = w83792d_read_value(client, W83792D_REG_PIN);\n\tif (val1 & 0x40) {\n\t\terr = sysfs_create_group(&dev->kobj, &w83792d_group_fan[2]);\n\t\tif (err)\n\t\t\tgoto exit_remove_files;\n\t}\n\n\tif (val1 & 0x04) {\n\t\terr = sysfs_create_group(&dev->kobj, &w83792d_group_fan[3]);\n\t\tif (err)\n\t\t\tgoto exit_remove_files;\n\t}\n\n\tdata->hwmon_dev = hwmon_device_register(dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto exit_remove_files;\n\t}\n\n\treturn 0;\n\nexit_remove_files:\n\tsysfs_remove_group(&dev->kobj, &w83792d_group);\n\tfor (i = 0; i < ARRAY_SIZE(w83792d_group_fan); i++)\n\t\tsysfs_remove_group(&dev->kobj, &w83792d_group_fan[i]);\n\treturn err;\n}\n\nstatic void\nw83792d_remove(struct i2c_client *client)\n{\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tint i;\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tsysfs_remove_group(&client->dev.kobj, &w83792d_group);\n\tfor (i = 0; i < ARRAY_SIZE(w83792d_group_fan); i++)\n\t\tsysfs_remove_group(&client->dev.kobj,\n\t\t\t\t   &w83792d_group_fan[i]);\n}\n\nstatic void\nw83792d_init_client(struct i2c_client *client)\n{\n\tu8 temp2_cfg, temp3_cfg, vid_in_b;\n\n\tif (init)\n\t\tw83792d_write_value(client, W83792D_REG_CONFIG, 0x80);\n\n\t \n\tvid_in_b = w83792d_read_value(client, W83792D_REG_VID_IN_B);\n\tw83792d_write_value(client, W83792D_REG_VID_IN_B,\n\t\t\t    vid_in_b & 0xbf);\n\n\ttemp2_cfg = w83792d_read_value(client, W83792D_REG_TEMP2_CONFIG);\n\ttemp3_cfg = w83792d_read_value(client, W83792D_REG_TEMP3_CONFIG);\n\tw83792d_write_value(client, W83792D_REG_TEMP2_CONFIG,\n\t\t\t\ttemp2_cfg & 0xe6);\n\tw83792d_write_value(client, W83792D_REG_TEMP3_CONFIG,\n\t\t\t\ttemp3_cfg & 0xe6);\n\n\t \n\tw83792d_write_value(client, W83792D_REG_CONFIG,\n\t\t\t    (w83792d_read_value(client,\n\t\t\t\t\t\tW83792D_REG_CONFIG) & 0xf7)\n\t\t\t    | 0x01);\n}\n\nstatic struct w83792d_data *w83792d_update_device(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83792d_data *data = i2c_get_clientdata(client);\n\tint i, j;\n\tu8 reg_array_tmp[4], reg_tmp;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after\n\t    (jiffies - data->last_updated, (unsigned long) (HZ * 3))\n\t    || time_before(jiffies, data->last_updated) || !data->valid) {\n\t\tdev_dbg(dev, \"Starting device update\\n\");\n\n\t\t \n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tdata->in[i] = w83792d_read_value(client,\n\t\t\t\t\t\tW83792D_REG_IN[i]);\n\t\t\tdata->in_max[i] = w83792d_read_value(client,\n\t\t\t\t\t\tW83792D_REG_IN_MAX[i]);\n\t\t\tdata->in_min[i] = w83792d_read_value(client,\n\t\t\t\t\t\tW83792D_REG_IN_MIN[i]);\n\t\t}\n\t\tdata->low_bits = w83792d_read_value(client,\n\t\t\t\t\t\tW83792D_REG_LOW_BITS1) +\n\t\t\t\t (w83792d_read_value(client,\n\t\t\t\t\t\tW83792D_REG_LOW_BITS2) << 8);\n\t\tfor (i = 0; i < 7; i++) {\n\t\t\t \n\t\t\tdata->fan[i] = w83792d_read_value(client,\n\t\t\t\t\t\tW83792D_REG_FAN[i]);\n\t\t\tdata->fan_min[i] = w83792d_read_value(client,\n\t\t\t\t\t\tW83792D_REG_FAN_MIN[i]);\n\t\t\t \n\t\t\tdata->pwm[i] = w83792d_read_value(client,\n\t\t\t\t\t\tW83792D_REG_PWM[i]);\n\t\t}\n\n\t\treg_tmp = w83792d_read_value(client, W83792D_REG_FAN_CFG);\n\t\tdata->pwmenable[0] = reg_tmp & 0x03;\n\t\tdata->pwmenable[1] = (reg_tmp>>2) & 0x03;\n\t\tdata->pwmenable[2] = (reg_tmp>>4) & 0x03;\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tdata->temp1[i] = w83792d_read_value(client,\n\t\t\t\t\t\t\tW83792D_REG_TEMP1[i]);\n\t\t}\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; j < 6; j++) {\n\t\t\t\tdata->temp_add[i][j] = w83792d_read_value(\n\t\t\t\t\tclient, W83792D_REG_TEMP_ADD[i][j]);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 4; i++) {\n\t\t\treg_array_tmp[i] = w83792d_read_value(client,\n\t\t\t\t\t\t\tW83792D_REG_FAN_DIV[i]);\n\t\t}\n\t\tdata->fan_div[0] = reg_array_tmp[0] & 0x07;\n\t\tdata->fan_div[1] = (reg_array_tmp[0] >> 4) & 0x07;\n\t\tdata->fan_div[2] = reg_array_tmp[1] & 0x07;\n\t\tdata->fan_div[3] = (reg_array_tmp[1] >> 4) & 0x07;\n\t\tdata->fan_div[4] = reg_array_tmp[2] & 0x07;\n\t\tdata->fan_div[5] = (reg_array_tmp[2] >> 4) & 0x07;\n\t\tdata->fan_div[6] = reg_array_tmp[3] & 0x07;\n\n\t\t \n\t\tdata->alarms = w83792d_read_value(client, W83792D_REG_ALARM1) +\n\t\t\t(w83792d_read_value(client, W83792D_REG_ALARM2) << 8) +\n\t\t\t(w83792d_read_value(client, W83792D_REG_ALARM3) << 16);\n\n\t\t \n\t\tdata->chassis = (w83792d_read_value(client,\n\t\t\tW83792D_REG_CHASSIS) >> 5) & 0x01;\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tdata->thermal_cruise[i] =\n\t\t\t\tw83792d_read_value(client,\n\t\t\t\tW83792D_REG_THERMAL[i]) & 0x7f;\n\t\t}\n\n\t\t \n\t\treg_tmp = w83792d_read_value(client, W83792D_REG_TOLERANCE[0]);\n\t\tdata->tolerance[0] = reg_tmp & 0x0f;\n\t\tdata->tolerance[1] = (reg_tmp >> 4) & 0x0f;\n\t\tdata->tolerance[2] = w83792d_read_value(client,\n\t\t\t\t\tW83792D_REG_TOLERANCE[2]) & 0x0f;\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tdata->sf2_points[i][j]\n\t\t\t\t  = w83792d_read_value(client,\n\t\t\t\t\tW83792D_REG_POINTS[i][j]) & 0x7f;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\treg_tmp = w83792d_read_value(client,\n\t\t\t\t\t\tW83792D_REG_LEVELS[i][0]);\n\t\t\tdata->sf2_levels[i][0] = reg_tmp & 0x0f;\n\t\t\tdata->sf2_levels[i][1] = (reg_tmp >> 4) & 0x0f;\n\t\t\treg_tmp = w83792d_read_value(client,\n\t\t\t\t\t\tW83792D_REG_LEVELS[i][2]);\n\t\t\tdata->sf2_levels[i][2] = (reg_tmp >> 4) & 0x0f;\n\t\t\tdata->sf2_levels[i][3] = reg_tmp & 0x0f;\n\t\t}\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n#ifdef DEBUG\n\tw83792d_print_debug(data, dev);\n#endif\n\n\treturn data;\n}\n\n#ifdef DEBUG\nstatic void w83792d_print_debug(struct w83792d_data *data, struct device *dev)\n{\n\tint i = 0, j = 0;\n\tdev_dbg(dev, \"==========The following is the debug message...========\\n\");\n\tdev_dbg(dev, \"9 set of Voltages: =====>\\n\");\n\tfor (i = 0; i < 9; i++) {\n\t\tdev_dbg(dev, \"vin[%d] is: 0x%x\\n\", i, data->in[i]);\n\t\tdev_dbg(dev, \"vin[%d] max is: 0x%x\\n\", i, data->in_max[i]);\n\t\tdev_dbg(dev, \"vin[%d] min is: 0x%x\\n\", i, data->in_min[i]);\n\t}\n\tdev_dbg(dev, \"Low Bit1 is: 0x%x\\n\", data->low_bits & 0xff);\n\tdev_dbg(dev, \"Low Bit2 is: 0x%x\\n\", data->low_bits >> 8);\n\tdev_dbg(dev, \"7 set of Fan Counts and Duty Cycles: =====>\\n\");\n\tfor (i = 0; i < 7; i++) {\n\t\tdev_dbg(dev, \"fan[%d] is: 0x%x\\n\", i, data->fan[i]);\n\t\tdev_dbg(dev, \"fan[%d] min is: 0x%x\\n\", i, data->fan_min[i]);\n\t\tdev_dbg(dev, \"pwm[%d]     is: 0x%x\\n\", i, data->pwm[i]);\n\t}\n\tdev_dbg(dev, \"3 set of Temperatures: =====>\\n\");\n\tfor (i = 0; i < 3; i++)\n\t\tdev_dbg(dev, \"temp1[%d] is: 0x%x\\n\", i, data->temp1[i]);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tdev_dbg(dev, \"temp_add[%d][%d] is: 0x%x\\n\", i, j,\n\t\t\t\t\t\t\tdata->temp_add[i][j]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < 7; i++)\n\t\tdev_dbg(dev, \"fan_div[%d] is: 0x%x\\n\", i, data->fan_div[i]);\n\n\tdev_dbg(dev, \"==========End of the debug message...================\\n\");\n\tdev_dbg(dev, \"\\n\");\n}\n#endif\n\nmodule_i2c_driver(w83792d_driver);\n\nMODULE_AUTHOR(\"Shane Huang (Winbond)\");\nMODULE_DESCRIPTION(\"W83792AD/D driver for linux-2.6\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}