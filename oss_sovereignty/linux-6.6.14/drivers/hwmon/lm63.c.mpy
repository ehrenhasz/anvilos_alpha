{
  "module_name": "lm63.c",
  "hash_id": "6e18402abff0e8ec6f8ecdbcdecb93afb15304ea382ee231cb008bb94f6a9fe9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lm63.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n\n \n\nstatic const unsigned short normal_i2c[] = { 0x18, 0x4c, 0x4e, I2C_CLIENT_END };\n\n \n\n#define LM63_REG_CONFIG1\t\t0x03\n#define LM63_REG_CONVRATE\t\t0x04\n#define LM63_REG_CONFIG2\t\t0xBF\n#define LM63_REG_CONFIG_FAN\t\t0x4A\n\n#define LM63_REG_TACH_COUNT_MSB\t\t0x47\n#define LM63_REG_TACH_COUNT_LSB\t\t0x46\n#define LM63_REG_TACH_LIMIT_MSB\t\t0x49\n#define LM63_REG_TACH_LIMIT_LSB\t\t0x48\n\n#define LM63_REG_PWM_VALUE\t\t0x4C\n#define LM63_REG_PWM_FREQ\t\t0x4D\n#define LM63_REG_LUT_TEMP_HYST\t\t0x4F\n#define LM63_REG_LUT_TEMP(nr)\t\t(0x50 + 2 * (nr))\n#define LM63_REG_LUT_PWM(nr)\t\t(0x51 + 2 * (nr))\n\n#define LM63_REG_LOCAL_TEMP\t\t0x00\n#define LM63_REG_LOCAL_HIGH\t\t0x05\n\n#define LM63_REG_REMOTE_TEMP_MSB\t0x01\n#define LM63_REG_REMOTE_TEMP_LSB\t0x10\n#define LM63_REG_REMOTE_OFFSET_MSB\t0x11\n#define LM63_REG_REMOTE_OFFSET_LSB\t0x12\n#define LM63_REG_REMOTE_HIGH_MSB\t0x07\n#define LM63_REG_REMOTE_HIGH_LSB\t0x13\n#define LM63_REG_REMOTE_LOW_MSB\t\t0x08\n#define LM63_REG_REMOTE_LOW_LSB\t\t0x14\n#define LM63_REG_REMOTE_TCRIT\t\t0x19\n#define LM63_REG_REMOTE_TCRIT_HYST\t0x21\n\n#define LM63_REG_ALERT_STATUS\t\t0x02\n#define LM63_REG_ALERT_MASK\t\t0x16\n\n#define LM63_REG_MAN_ID\t\t\t0xFE\n#define LM63_REG_CHIP_ID\t\t0xFF\n\n#define LM96163_REG_TRUTHERM\t\t0x30\n#define LM96163_REG_REMOTE_TEMP_U_MSB\t0x31\n#define LM96163_REG_REMOTE_TEMP_U_LSB\t0x32\n#define LM96163_REG_CONFIG_ENHANCED\t0x45\n\n#define LM63_MAX_CONVRATE\t\t9\n\n#define LM63_MAX_CONVRATE_HZ\t\t32\n#define LM96163_MAX_CONVRATE_HZ\t\t26\n\n \n\n#define FAN_FROM_REG(reg)\t((reg) == 0xFFFC || (reg) == 0 ? 0 : \\\n\t\t\t\t 5400000 / (reg))\n#define FAN_TO_REG(val)\t\t((val) <= 82 ? 0xFFFC : \\\n\t\t\t\t (5400000 / (val)) & 0xFFFC)\n#define TEMP8_FROM_REG(reg)\t((reg) * 1000)\n#define TEMP8_TO_REG(val)\tDIV_ROUND_CLOSEST(clamp_val((val), -128000, \\\n\t\t\t\t\t\t\t    127000), 1000)\n#define TEMP8U_TO_REG(val)\tDIV_ROUND_CLOSEST(clamp_val((val), 0, \\\n\t\t\t\t\t\t\t    255000), 1000)\n#define TEMP11_FROM_REG(reg)\t((reg) / 32 * 125)\n#define TEMP11_TO_REG(val)\t(DIV_ROUND_CLOSEST(clamp_val((val), -128000, \\\n\t\t\t\t\t\t\t     127875), 125) * 32)\n#define TEMP11U_TO_REG(val)\t(DIV_ROUND_CLOSEST(clamp_val((val), 0, \\\n\t\t\t\t\t\t\t     255875), 125) * 32)\n#define HYST_TO_REG(val)\tDIV_ROUND_CLOSEST(clamp_val((val), 0, 127000), \\\n\t\t\t\t\t\t  1000)\n\n#define UPDATE_INTERVAL(max, rate) \\\n\t\t\t((1000 << (LM63_MAX_CONVRATE - (rate))) / (max))\n\nenum chips { lm63, lm64, lm96163 };\n\n \n\nstruct lm63_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tconst struct attribute_group *groups[5];\n\tbool valid;  \n\tchar lut_valid;  \n\tunsigned long last_updated;  \n\tunsigned long lut_last_updated;  \n\tenum chips kind;\n\tint temp2_offset;\n\n\tint update_interval;\t \n\tint max_convrate_hz;\n\tint lut_size;\t\t \n\n\t \n\tu8 config, config_fan;\n\tu16 fan[2];\t \n\tu8 pwm1_freq;\n\tu8 pwm1[13];\t \n\ts8 temp8[15];\t \n\ts16 temp11[4];\t \n\tu16 temp11u;\t \n\tu8 temp2_crit_hyst;\n\tu8 lut_temp_hyst;\n\tu8 alarms;\n\tbool pwm_highres;\n\tbool lut_temp_highres;\n\tbool remote_unsigned;  \n\tbool trutherm;\n};\n\nstatic inline int temp8_from_reg(struct lm63_data *data, int nr)\n{\n\tif (data->remote_unsigned)\n\t\treturn TEMP8_FROM_REG((u8)data->temp8[nr]);\n\treturn TEMP8_FROM_REG(data->temp8[nr]);\n}\n\nstatic inline int lut_temp_from_reg(struct lm63_data *data, int nr)\n{\n\treturn data->temp8[nr] * (data->lut_temp_highres ? 500 : 1000);\n}\n\nstatic inline int lut_temp_to_reg(struct lm63_data *data, long val)\n{\n\tval -= data->temp2_offset;\n\tif (data->lut_temp_highres)\n\t\treturn DIV_ROUND_CLOSEST(clamp_val(val, 0, 127500), 500);\n\telse\n\t\treturn DIV_ROUND_CLOSEST(clamp_val(val, 0, 127000), 1000);\n}\n\n \nstatic void lm63_update_lut(struct lm63_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint i;\n\n\tif (time_after(jiffies, data->lut_last_updated + 5 * HZ) ||\n\t    !data->lut_valid) {\n\t\tfor (i = 0; i < data->lut_size; i++) {\n\t\t\tdata->pwm1[1 + i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t    LM63_REG_LUT_PWM(i));\n\t\t\tdata->temp8[3 + i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t     LM63_REG_LUT_TEMP(i));\n\t\t}\n\t\tdata->lut_temp_hyst = i2c_smbus_read_byte_data(client,\n\t\t\t\t      LM63_REG_LUT_TEMP_HYST);\n\n\t\tdata->lut_last_updated = jiffies;\n\t\tdata->lut_valid = 1;\n\t}\n}\n\nstatic struct lm63_data *lm63_update_device(struct device *dev)\n{\n\tstruct lm63_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long next_update;\n\n\tmutex_lock(&data->update_lock);\n\n\tnext_update = data->last_updated +\n\t\t      msecs_to_jiffies(data->update_interval);\n\tif (time_after(jiffies, next_update) || !data->valid) {\n\t\tif (data->config & 0x04) {  \n\t\t\t \n\t\t\tdata->fan[0] = i2c_smbus_read_byte_data(client,\n\t\t\t\t       LM63_REG_TACH_COUNT_LSB) & 0xFC;\n\t\t\tdata->fan[0] |= i2c_smbus_read_byte_data(client,\n\t\t\t\t\tLM63_REG_TACH_COUNT_MSB) << 8;\n\t\t\tdata->fan[1] = (i2c_smbus_read_byte_data(client,\n\t\t\t\t\tLM63_REG_TACH_LIMIT_LSB) & 0xFC)\n\t\t\t\t     | (i2c_smbus_read_byte_data(client,\n\t\t\t\t\tLM63_REG_TACH_LIMIT_MSB) << 8);\n\t\t}\n\n\t\tdata->pwm1_freq = i2c_smbus_read_byte_data(client,\n\t\t\t\t  LM63_REG_PWM_FREQ);\n\t\tif (data->pwm1_freq == 0)\n\t\t\tdata->pwm1_freq = 1;\n\t\tdata->pwm1[0] = i2c_smbus_read_byte_data(client,\n\t\t\t\tLM63_REG_PWM_VALUE);\n\n\t\tdata->temp8[0] = i2c_smbus_read_byte_data(client,\n\t\t\t\t LM63_REG_LOCAL_TEMP);\n\t\tdata->temp8[1] = i2c_smbus_read_byte_data(client,\n\t\t\t\t LM63_REG_LOCAL_HIGH);\n\n\t\t \n\t\tdata->temp11[0] = i2c_smbus_read_byte_data(client,\n\t\t\t\t  LM63_REG_REMOTE_TEMP_MSB) << 8;\n\t\tdata->temp11[0] |= i2c_smbus_read_byte_data(client,\n\t\t\t\t   LM63_REG_REMOTE_TEMP_LSB);\n\t\tdata->temp11[1] = (i2c_smbus_read_byte_data(client,\n\t\t\t\t  LM63_REG_REMOTE_LOW_MSB) << 8)\n\t\t\t\t| i2c_smbus_read_byte_data(client,\n\t\t\t\t  LM63_REG_REMOTE_LOW_LSB);\n\t\tdata->temp11[2] = (i2c_smbus_read_byte_data(client,\n\t\t\t\t  LM63_REG_REMOTE_HIGH_MSB) << 8)\n\t\t\t\t| i2c_smbus_read_byte_data(client,\n\t\t\t\t  LM63_REG_REMOTE_HIGH_LSB);\n\t\tdata->temp11[3] = (i2c_smbus_read_byte_data(client,\n\t\t\t\t  LM63_REG_REMOTE_OFFSET_MSB) << 8)\n\t\t\t\t| i2c_smbus_read_byte_data(client,\n\t\t\t\t  LM63_REG_REMOTE_OFFSET_LSB);\n\n\t\tif (data->kind == lm96163)\n\t\t\tdata->temp11u = (i2c_smbus_read_byte_data(client,\n\t\t\t\t\tLM96163_REG_REMOTE_TEMP_U_MSB) << 8)\n\t\t\t\t      | i2c_smbus_read_byte_data(client,\n\t\t\t\t\tLM96163_REG_REMOTE_TEMP_U_LSB);\n\n\t\tdata->temp8[2] = i2c_smbus_read_byte_data(client,\n\t\t\t\t LM63_REG_REMOTE_TCRIT);\n\t\tdata->temp2_crit_hyst = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tLM63_REG_REMOTE_TCRIT_HYST);\n\n\t\tdata->alarms = i2c_smbus_read_byte_data(client,\n\t\t\t       LM63_REG_ALERT_STATUS) & 0x7F;\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tlm63_update_lut(data);\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \nstatic int lm63_lut_looks_bad(struct device *dev, struct lm63_data *data)\n{\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\tlm63_update_lut(data);\n\n\tfor (i = 1; i < data->lut_size; i++) {\n\t\tif (data->pwm1[1 + i - 1] > data->pwm1[1 + i]\n\t\t || data->temp8[3 + i - 1] > data->temp8[3 + i]) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Lookup table doesn't look sane (check entries %d and %d)\\n\",\n\t\t\t\t i, i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn i == data->lut_size ? 0 : 1;\n}\n\n \n\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm63_data *data = lm63_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", FAN_FROM_REG(data->fan[attr->index]));\n}\n\nstatic ssize_t set_fan(struct device *dev, struct device_attribute *dummy,\n\t\t       const char *buf, size_t count)\n{\n\tstruct lm63_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan[1] = FAN_TO_REG(val);\n\ti2c_smbus_write_byte_data(client, LM63_REG_TACH_LIMIT_LSB,\n\t\t\t\t  data->fan[1] & 0xFF);\n\ti2c_smbus_write_byte_data(client, LM63_REG_TACH_LIMIT_MSB,\n\t\t\t\t  data->fan[1] >> 8);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t show_pwm1(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm63_data *data = lm63_update_device(dev);\n\tint nr = attr->index;\n\tint pwm;\n\n\tif (data->pwm_highres)\n\t\tpwm = data->pwm1[nr];\n\telse\n\t\tpwm = data->pwm1[nr] >= 2 * data->pwm1_freq ?\n\t\t       255 : (data->pwm1[nr] * 255 + data->pwm1_freq) /\n\t\t       (2 * data->pwm1_freq);\n\n\treturn sprintf(buf, \"%d\\n\", pwm);\n}\n\nstatic ssize_t set_pwm1(struct device *dev, struct device_attribute *devattr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm63_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = attr->index;\n\tunsigned long val;\n\tint err;\n\tu8 reg;\n\n\tif (!(data->config_fan & 0x20))  \n\t\treturn -EPERM;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\treg = nr ? LM63_REG_LUT_PWM(nr - 1) : LM63_REG_PWM_VALUE;\n\tval = clamp_val(val, 0, 255);\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm1[nr] = data->pwm_highres ? val :\n\t\t\t(val * data->pwm1_freq * 2 + 127) / 255;\n\ti2c_smbus_write_byte_data(client, reg, data->pwm1[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t pwm1_enable_show(struct device *dev,\n\t\t\t\tstruct device_attribute *dummy, char *buf)\n{\n\tstruct lm63_data *data = lm63_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->config_fan & 0x20 ? 1 : 2);\n}\n\nstatic ssize_t pwm1_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *dummy,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct lm63_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tif (val < 1 || val > 2)\n\t\treturn -EINVAL;\n\n\t \n\tif (val == 2 && lm63_lut_looks_bad(dev, data))\n\t\treturn -EPERM;\n\n\tmutex_lock(&data->update_lock);\n\tdata->config_fan = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t    LM63_REG_CONFIG_FAN);\n\tif (val == 1)\n\t\tdata->config_fan |= 0x20;\n\telse\n\t\tdata->config_fan &= ~0x20;\n\ti2c_smbus_write_byte_data(client, LM63_REG_CONFIG_FAN,\n\t\t\t\t  data->config_fan);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \nstatic ssize_t show_local_temp8(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm63_data *data = lm63_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP8_FROM_REG(data->temp8[attr->index]));\n}\n\nstatic ssize_t show_remote_temp8(struct device *dev,\n\t\t\t\t struct device_attribute *devattr,\n\t\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm63_data *data = lm63_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", temp8_from_reg(data, attr->index)\n\t\t       + data->temp2_offset);\n}\n\nstatic ssize_t show_lut_temp(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm63_data *data = lm63_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", lut_temp_from_reg(data, attr->index)\n\t\t       + data->temp2_offset);\n}\n\nstatic ssize_t set_temp8(struct device *dev, struct device_attribute *devattr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm63_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\tint temp;\n\tu8 reg;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (nr) {\n\tcase 2:\n\t\treg = LM63_REG_REMOTE_TCRIT;\n\t\tif (data->remote_unsigned)\n\t\t\ttemp = TEMP8U_TO_REG(val - data->temp2_offset);\n\t\telse\n\t\t\ttemp = TEMP8_TO_REG(val - data->temp2_offset);\n\t\tbreak;\n\tcase 1:\n\t\treg = LM63_REG_LOCAL_HIGH;\n\t\ttemp = TEMP8_TO_REG(val);\n\t\tbreak;\n\tdefault:\t \n\t\treg = LM63_REG_LUT_TEMP(nr - 3);\n\t\ttemp = lut_temp_to_reg(data, val);\n\t}\n\tdata->temp8[nr] = temp;\n\ti2c_smbus_write_byte_data(client, reg, temp);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t show_temp11(struct device *dev, struct device_attribute *devattr,\n\t\t\t   char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm63_data *data = lm63_update_device(dev);\n\tint nr = attr->index;\n\tint temp;\n\n\tif (!nr) {\n\t\t \n\t\tif (data->temp11u)\n\t\t\ttemp = TEMP11_FROM_REG(data->temp11u);\n\t\telse\n\t\t\ttemp = TEMP11_FROM_REG(data->temp11[nr]);\n\t} else {\n\t\tif (data->remote_unsigned && nr == 2)\n\t\t\ttemp = TEMP11_FROM_REG((u16)data->temp11[nr]);\n\t\telse\n\t\t\ttemp = TEMP11_FROM_REG(data->temp11[nr]);\n\t}\n\treturn sprintf(buf, \"%d\\n\", temp + data->temp2_offset);\n}\n\nstatic ssize_t set_temp11(struct device *dev, struct device_attribute *devattr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstatic const u8 reg[6] = {\n\t\tLM63_REG_REMOTE_LOW_MSB,\n\t\tLM63_REG_REMOTE_LOW_LSB,\n\t\tLM63_REG_REMOTE_HIGH_MSB,\n\t\tLM63_REG_REMOTE_HIGH_LSB,\n\t\tLM63_REG_REMOTE_OFFSET_MSB,\n\t\tLM63_REG_REMOTE_OFFSET_LSB,\n\t};\n\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm63_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\tint nr = attr->index;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tif (data->remote_unsigned && nr == 2)\n\t\tdata->temp11[nr] = TEMP11U_TO_REG(val - data->temp2_offset);\n\telse\n\t\tdata->temp11[nr] = TEMP11_TO_REG(val - data->temp2_offset);\n\n\ti2c_smbus_write_byte_data(client, reg[(nr - 1) * 2],\n\t\t\t\t  data->temp11[nr] >> 8);\n\ti2c_smbus_write_byte_data(client, reg[(nr - 1) * 2 + 1],\n\t\t\t\t  data->temp11[nr] & 0xff);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \nstatic ssize_t temp2_crit_hyst_show(struct device *dev,\n\t\t\t\t    struct device_attribute *dummy, char *buf)\n{\n\tstruct lm63_data *data = lm63_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", temp8_from_reg(data, 2)\n\t\t       + data->temp2_offset\n\t\t       - TEMP8_FROM_REG(data->temp2_crit_hyst));\n}\n\nstatic ssize_t show_lut_temp_hyst(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm63_data *data = lm63_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", lut_temp_from_reg(data, attr->index)\n\t\t       + data->temp2_offset\n\t\t       - TEMP8_FROM_REG(data->lut_temp_hyst));\n}\n\n \nstatic ssize_t temp2_crit_hyst_store(struct device *dev,\n\t\t\t\t     struct device_attribute *dummy,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct lm63_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\tlong hyst;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\thyst = temp8_from_reg(data, 2) + data->temp2_offset - val;\n\ti2c_smbus_write_byte_data(client, LM63_REG_REMOTE_TCRIT_HYST,\n\t\t\t\t  HYST_TO_REG(hyst));\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \nstatic void lm63_set_convrate(struct lm63_data *data, unsigned int interval)\n{\n\tstruct i2c_client *client = data->client;\n\tunsigned int update_interval;\n\tint i;\n\n\t \n\tinterval <<= 6;\n\n\t \n\tupdate_interval = (1 << (LM63_MAX_CONVRATE + 6)) * 1000\n\t  / data->max_convrate_hz;\n\tfor (i = 0; i < LM63_MAX_CONVRATE; i++, update_interval >>= 1)\n\t\tif (interval >= update_interval * 3 / 4)\n\t\t\tbreak;\n\n\ti2c_smbus_write_byte_data(client, LM63_REG_CONVRATE, i);\n\tdata->update_interval = UPDATE_INTERVAL(data->max_convrate_hz, i);\n}\n\nstatic ssize_t update_interval_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct lm63_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", data->update_interval);\n}\n\nstatic ssize_t update_interval_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct lm63_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tlm63_set_convrate(data, clamp_val(val, 0, 100000));\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t temp2_type_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct lm63_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, data->trutherm ? \"1\\n\" : \"2\\n\");\n}\n\nstatic ssize_t temp2_type_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct lm63_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint ret;\n\tu8 reg;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (val != 1 && val != 2)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->trutherm = val == 1;\n\treg = i2c_smbus_read_byte_data(client, LM96163_REG_TRUTHERM) & ~0x02;\n\ti2c_smbus_write_byte_data(client, LM96163_REG_TRUTHERM,\n\t\t\t\t  reg | (data->trutherm ? 0x02 : 0x00));\n\tdata->valid = false;\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *dummy,\n\t\t\t   char *buf)\n{\n\tstruct lm63_data *data = lm63_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", data->alarms);\n}\n\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *devattr,\n\t\t\t  char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm63_data *data = lm63_update_device(dev);\n\tint bitnr = attr->index;\n\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> bitnr) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO, show_fan, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(fan1_min, S_IWUSR | S_IRUGO, show_fan,\n\tset_fan, 1);\n\nstatic SENSOR_DEVICE_ATTR(pwm1, S_IWUSR | S_IRUGO, show_pwm1, set_pwm1, 0);\nstatic DEVICE_ATTR_RW(pwm1_enable);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point1_pwm, S_IWUSR | S_IRUGO,\n\tshow_pwm1, set_pwm1, 1);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point1_temp, S_IWUSR | S_IRUGO,\n\tshow_lut_temp, set_temp8, 3);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point1_temp_hyst, S_IRUGO,\n\tshow_lut_temp_hyst, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point2_pwm, S_IWUSR | S_IRUGO,\n\tshow_pwm1, set_pwm1, 2);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point2_temp, S_IWUSR | S_IRUGO,\n\tshow_lut_temp, set_temp8, 4);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point2_temp_hyst, S_IRUGO,\n\tshow_lut_temp_hyst, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point3_pwm, S_IWUSR | S_IRUGO,\n\tshow_pwm1, set_pwm1, 3);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point3_temp, S_IWUSR | S_IRUGO,\n\tshow_lut_temp, set_temp8, 5);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point3_temp_hyst, S_IRUGO,\n\tshow_lut_temp_hyst, NULL, 5);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point4_pwm, S_IWUSR | S_IRUGO,\n\tshow_pwm1, set_pwm1, 4);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point4_temp, S_IWUSR | S_IRUGO,\n\tshow_lut_temp, set_temp8, 6);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point4_temp_hyst, S_IRUGO,\n\tshow_lut_temp_hyst, NULL, 6);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point5_pwm, S_IWUSR | S_IRUGO,\n\tshow_pwm1, set_pwm1, 5);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point5_temp, S_IWUSR | S_IRUGO,\n\tshow_lut_temp, set_temp8, 7);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point5_temp_hyst, S_IRUGO,\n\tshow_lut_temp_hyst, NULL, 7);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point6_pwm, S_IWUSR | S_IRUGO,\n\tshow_pwm1, set_pwm1, 6);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point6_temp, S_IWUSR | S_IRUGO,\n\tshow_lut_temp, set_temp8, 8);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point6_temp_hyst, S_IRUGO,\n\tshow_lut_temp_hyst, NULL, 8);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point7_pwm, S_IWUSR | S_IRUGO,\n\tshow_pwm1, set_pwm1, 7);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point7_temp, S_IWUSR | S_IRUGO,\n\tshow_lut_temp, set_temp8, 9);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point7_temp_hyst, S_IRUGO,\n\tshow_lut_temp_hyst, NULL, 9);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point8_pwm, S_IWUSR | S_IRUGO,\n\tshow_pwm1, set_pwm1, 8);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point8_temp, S_IWUSR | S_IRUGO,\n\tshow_lut_temp, set_temp8, 10);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point8_temp_hyst, S_IRUGO,\n\tshow_lut_temp_hyst, NULL, 10);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point9_pwm, S_IWUSR | S_IRUGO,\n\tshow_pwm1, set_pwm1, 9);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point9_temp, S_IWUSR | S_IRUGO,\n\tshow_lut_temp, set_temp8, 11);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point9_temp_hyst, S_IRUGO,\n\tshow_lut_temp_hyst, NULL, 11);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point10_pwm, S_IWUSR | S_IRUGO,\n\tshow_pwm1, set_pwm1, 10);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point10_temp, S_IWUSR | S_IRUGO,\n\tshow_lut_temp, set_temp8, 12);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point10_temp_hyst, S_IRUGO,\n\tshow_lut_temp_hyst, NULL, 12);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point11_pwm, S_IWUSR | S_IRUGO,\n\tshow_pwm1, set_pwm1, 11);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point11_temp, S_IWUSR | S_IRUGO,\n\tshow_lut_temp, set_temp8, 13);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point11_temp_hyst, S_IRUGO,\n\tshow_lut_temp_hyst, NULL, 13);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point12_pwm, S_IWUSR | S_IRUGO,\n\tshow_pwm1, set_pwm1, 12);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point12_temp, S_IWUSR | S_IRUGO,\n\tshow_lut_temp, set_temp8, 14);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_point12_temp_hyst, S_IRUGO,\n\tshow_lut_temp_hyst, NULL, 14);\n\nstatic SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_local_temp8, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(temp1_max, S_IWUSR | S_IRUGO, show_local_temp8,\n\tset_temp8, 1);\n\nstatic SENSOR_DEVICE_ATTR(temp2_input, S_IRUGO, show_temp11, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(temp2_min, S_IWUSR | S_IRUGO, show_temp11,\n\tset_temp11, 1);\nstatic SENSOR_DEVICE_ATTR(temp2_max, S_IWUSR | S_IRUGO, show_temp11,\n\tset_temp11, 2);\nstatic SENSOR_DEVICE_ATTR(temp2_offset, S_IWUSR | S_IRUGO, show_temp11,\n\tset_temp11, 3);\nstatic SENSOR_DEVICE_ATTR(temp2_crit, S_IRUGO, show_remote_temp8,\n\tset_temp8, 2);\nstatic DEVICE_ATTR_RW(temp2_crit_hyst);\n\nstatic DEVICE_ATTR_RW(temp2_type);\n\n \nstatic SENSOR_DEVICE_ATTR(fan1_min_alarm, S_IRUGO, show_alarm, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(temp2_crit_alarm, S_IRUGO, show_alarm, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(temp2_fault, S_IRUGO, show_alarm, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(temp2_min_alarm, S_IRUGO, show_alarm, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(temp2_max_alarm, S_IRUGO, show_alarm, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(temp1_max_alarm, S_IRUGO, show_alarm, NULL, 6);\n \nstatic DEVICE_ATTR_RO(alarms);\n\nstatic DEVICE_ATTR_RW(update_interval);\n\nstatic struct attribute *lm63_attributes[] = {\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&dev_attr_pwm1_enable.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point5_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point5_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point5_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point6_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point6_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point6_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point7_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point7_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point7_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point8_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point8_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point8_temp_hyst.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit.dev_attr.attr,\n\t&dev_attr_temp2_crit_hyst.attr,\n\n\t&sensor_dev_attr_temp2_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&dev_attr_alarms.attr,\n\t&dev_attr_update_interval.attr,\n\tNULL\n};\n\nstatic struct attribute *lm63_attributes_temp2_type[] = {\n\t&dev_attr_temp2_type.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lm63_group_temp2_type = {\n\t.attrs = lm63_attributes_temp2_type,\n};\n\nstatic struct attribute *lm63_attributes_extra_lut[] = {\n\t&sensor_dev_attr_pwm1_auto_point9_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point9_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point9_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point10_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point10_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point10_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point11_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point11_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point11_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point12_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point12_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point12_temp_hyst.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lm63_group_extra_lut = {\n\t.attrs = lm63_attributes_extra_lut,\n};\n\n \nstatic umode_t lm63_attribute_mode(struct kobject *kobj,\n\t\t\t\t   struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct lm63_data *data = dev_get_drvdata(dev);\n\n\tif (attr == &sensor_dev_attr_temp2_crit.dev_attr.attr\n\t    && (data->kind == lm64 ||\n\t\t(data->kind == lm96163 && (data->config & 0x02))))\n\t\treturn attr->mode | S_IWUSR;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group lm63_group = {\n\t.is_visible = lm63_attribute_mode,\n\t.attrs = lm63_attributes,\n};\n\nstatic struct attribute *lm63_attributes_fan1[] = {\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\n\t&sensor_dev_attr_fan1_min_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lm63_group_fan1 = {\n\t.attrs = lm63_attributes_fan1,\n};\n\n \n\n \nstatic int lm63_detect(struct i2c_client *client,\n\t\t       struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tu8 man_id, chip_id, reg_config1, reg_config2;\n\tu8 reg_alert_status, reg_alert_mask;\n\tint address = client->addr;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tman_id = i2c_smbus_read_byte_data(client, LM63_REG_MAN_ID);\n\tchip_id = i2c_smbus_read_byte_data(client, LM63_REG_CHIP_ID);\n\n\treg_config1 = i2c_smbus_read_byte_data(client, LM63_REG_CONFIG1);\n\treg_config2 = i2c_smbus_read_byte_data(client, LM63_REG_CONFIG2);\n\treg_alert_status = i2c_smbus_read_byte_data(client,\n\t\t\t   LM63_REG_ALERT_STATUS);\n\treg_alert_mask = i2c_smbus_read_byte_data(client, LM63_REG_ALERT_MASK);\n\n\tif (man_id != 0x01  \n\t || (reg_config1 & 0x18) != 0x00\n\t || (reg_config2 & 0xF8) != 0x00\n\t || (reg_alert_status & 0x20) != 0x00\n\t || (reg_alert_mask & 0xA4) != 0xA4) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"Unsupported chip (man_id=0x%02X, chip_id=0x%02X)\\n\",\n\t\t\tman_id, chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\tif (chip_id == 0x41 && address == 0x4c)\n\t\tstrscpy(info->type, \"lm63\", I2C_NAME_SIZE);\n\telse if (chip_id == 0x51 && (address == 0x18 || address == 0x4e))\n\t\tstrscpy(info->type, \"lm64\", I2C_NAME_SIZE);\n\telse if (chip_id == 0x49 && address == 0x4c)\n\t\tstrscpy(info->type, \"lm96163\", I2C_NAME_SIZE);\n\telse\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstatic void lm63_init_client(struct lm63_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tstruct device *dev = &client->dev;\n\tu8 convrate;\n\n\tdata->config = i2c_smbus_read_byte_data(client, LM63_REG_CONFIG1);\n\tdata->config_fan = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t    LM63_REG_CONFIG_FAN);\n\n\t \n\tif (data->config & 0x40) {  \n\t\tdev_dbg(dev, \"Switching to operational mode\\n\");\n\t\tdata->config &= 0xA7;\n\t\ti2c_smbus_write_byte_data(client, LM63_REG_CONFIG1,\n\t\t\t\t\t  data->config);\n\t}\n\t \n\tif (data->kind == lm64)\n\t\tdata->config |= 0x04;\n\n\t \n\tdata->pwm1_freq = i2c_smbus_read_byte_data(client, LM63_REG_PWM_FREQ);\n\tif (data->pwm1_freq == 0)\n\t\tdata->pwm1_freq = 1;\n\n\tswitch (data->kind) {\n\tcase lm63:\n\tcase lm64:\n\t\tdata->max_convrate_hz = LM63_MAX_CONVRATE_HZ;\n\t\tdata->lut_size = 8;\n\t\tbreak;\n\tcase lm96163:\n\t\tdata->max_convrate_hz = LM96163_MAX_CONVRATE_HZ;\n\t\tdata->lut_size = 12;\n\t\tdata->trutherm\n\t\t  = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t     LM96163_REG_TRUTHERM) & 0x02;\n\t\tbreak;\n\t}\n\tconvrate = i2c_smbus_read_byte_data(client, LM63_REG_CONVRATE);\n\tif (unlikely(convrate > LM63_MAX_CONVRATE))\n\t\tconvrate = LM63_MAX_CONVRATE;\n\tdata->update_interval = UPDATE_INTERVAL(data->max_convrate_hz,\n\t\t\t\t\t\tconvrate);\n\n\t \n\tif (data->kind == lm96163) {\n\t\tu8 config_enhanced\n\t\t  = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t     LM96163_REG_CONFIG_ENHANCED);\n\t\tif (config_enhanced & 0x20)\n\t\t\tdata->lut_temp_highres = true;\n\t\tif ((config_enhanced & 0x10)\n\t\t    && !(data->config_fan & 0x08) && data->pwm1_freq == 8)\n\t\t\tdata->pwm_highres = true;\n\t\tif (config_enhanced & 0x08)\n\t\t\tdata->remote_unsigned = true;\n\t}\n\n\t \n\tif (data->kind == lm63)\n\t\tdev_dbg(dev, \"Alert/tach pin configured for %s\\n\",\n\t\t\t(data->config & 0x04) ? \"tachometer input\" :\n\t\t\t\"alert output\");\n\tdev_dbg(dev, \"PWM clock %s kHz, output frequency %u Hz\\n\",\n\t\t(data->config_fan & 0x08) ? \"1.4\" : \"360\",\n\t\t((data->config_fan & 0x08) ? 700 : 180000) / data->pwm1_freq);\n\tdev_dbg(dev, \"PWM output active %s, %s mode\\n\",\n\t\t(data->config_fan & 0x10) ? \"low\" : \"high\",\n\t\t(data->config_fan & 0x20) ? \"manual\" : \"auto\");\n}\n\nstatic const struct i2c_device_id lm63_id[];\n\nstatic int lm63_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct lm63_data *data;\n\tint groups = 0;\n\n\tdata = devm_kzalloc(dev, sizeof(struct lm63_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tif (client->dev.of_node)\n\t\tdata->kind = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\tdata->kind = i2c_match_id(lm63_id, client)->driver_data;\n\tif (data->kind == lm64)\n\t\tdata->temp2_offset = 16000;\n\n\t \n\tlm63_init_client(data);\n\n\t \n\tdata->groups[groups++] = &lm63_group;\n\tif (data->config & 0x04)\t \n\t\tdata->groups[groups++] = &lm63_group_fan1;\n\n\tif (data->kind == lm96163) {\n\t\tdata->groups[groups++] = &lm63_group_temp2_type;\n\t\tdata->groups[groups++] = &lm63_group_extra_lut;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, data->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\n \n\nstatic const struct i2c_device_id lm63_id[] = {\n\t{ \"lm63\", lm63 },\n\t{ \"lm64\", lm64 },\n\t{ \"lm96163\", lm96163 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm63_id);\n\nstatic const struct of_device_id __maybe_unused lm63_of_match[] = {\n\t{\n\t\t.compatible = \"national,lm63\",\n\t\t.data = (void *)lm63\n\t},\n\t{\n\t\t.compatible = \"national,lm64\",\n\t\t.data = (void *)lm64\n\t},\n\t{\n\t\t.compatible = \"national,lm96163\",\n\t\t.data = (void *)lm96163\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, lm63_of_match);\n\nstatic struct i2c_driver lm63_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"lm63\",\n\t\t.of_match_table = of_match_ptr(lm63_of_match),\n\t},\n\t.probe\t\t= lm63_probe,\n\t.id_table\t= lm63_id,\n\t.detect\t\t= lm63_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(lm63_driver);\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"LM63 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}