{
  "module_name": "tps23861.c",
  "hash_id": "df5ce825060807f3797eccc3d79b4f4c4395ecd46dcd34ceb1221b1eb525f9fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/tps23861.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#define TEMPERATURE\t\t\t0x2c\n#define INPUT_VOLTAGE_LSB\t\t0x2e\n#define INPUT_VOLTAGE_MSB\t\t0x2f\n#define PORT_1_CURRENT_LSB\t\t0x30\n#define PORT_1_CURRENT_MSB\t\t0x31\n#define PORT_1_VOLTAGE_LSB\t\t0x32\n#define PORT_1_VOLTAGE_MSB\t\t0x33\n#define PORT_2_CURRENT_LSB\t\t0x34\n#define PORT_2_CURRENT_MSB\t\t0x35\n#define PORT_2_VOLTAGE_LSB\t\t0x36\n#define PORT_2_VOLTAGE_MSB\t\t0x37\n#define PORT_3_CURRENT_LSB\t\t0x38\n#define PORT_3_CURRENT_MSB\t\t0x39\n#define PORT_3_VOLTAGE_LSB\t\t0x3a\n#define PORT_3_VOLTAGE_MSB\t\t0x3b\n#define PORT_4_CURRENT_LSB\t\t0x3c\n#define PORT_4_CURRENT_MSB\t\t0x3d\n#define PORT_4_VOLTAGE_LSB\t\t0x3e\n#define PORT_4_VOLTAGE_MSB\t\t0x3f\n#define PORT_N_CURRENT_LSB_OFFSET\t0x04\n#define PORT_N_VOLTAGE_LSB_OFFSET\t0x04\n#define VOLTAGE_CURRENT_MASK\t\tGENMASK(13, 0)\n#define PORT_1_RESISTANCE_LSB\t\t0x60\n#define PORT_1_RESISTANCE_MSB\t\t0x61\n#define PORT_2_RESISTANCE_LSB\t\t0x62\n#define PORT_2_RESISTANCE_MSB\t\t0x63\n#define PORT_3_RESISTANCE_LSB\t\t0x64\n#define PORT_3_RESISTANCE_MSB\t\t0x65\n#define PORT_4_RESISTANCE_LSB\t\t0x66\n#define PORT_4_RESISTANCE_MSB\t\t0x67\n#define PORT_N_RESISTANCE_LSB_OFFSET\t0x02\n#define PORT_RESISTANCE_MASK\t\tGENMASK(13, 0)\n#define PORT_RESISTANCE_RSN_MASK\tGENMASK(15, 14)\n#define PORT_RESISTANCE_RSN_OTHER\t0\n#define PORT_RESISTANCE_RSN_LOW\t\t1\n#define PORT_RESISTANCE_RSN_OPEN\t2\n#define PORT_RESISTANCE_RSN_SHORT\t3\n#define PORT_1_STATUS\t\t\t0x0c\n#define PORT_2_STATUS\t\t\t0x0d\n#define PORT_3_STATUS\t\t\t0x0e\n#define PORT_4_STATUS\t\t\t0x0f\n#define PORT_STATUS_CLASS_MASK\t\tGENMASK(7, 4)\n#define PORT_STATUS_DETECT_MASK\t\tGENMASK(3, 0)\n#define PORT_CLASS_UNKNOWN\t\t0\n#define PORT_CLASS_1\t\t\t1\n#define PORT_CLASS_2\t\t\t2\n#define PORT_CLASS_3\t\t\t3\n#define PORT_CLASS_4\t\t\t4\n#define PORT_CLASS_RESERVED\t\t5\n#define PORT_CLASS_0\t\t\t6\n#define PORT_CLASS_OVERCURRENT\t\t7\n#define PORT_CLASS_MISMATCH\t\t8\n#define PORT_DETECT_UNKNOWN\t\t0\n#define PORT_DETECT_SHORT\t\t1\n#define PORT_DETECT_RESERVED\t\t2\n#define PORT_DETECT_RESISTANCE_LOW\t3\n#define PORT_DETECT_RESISTANCE_OK\t4\n#define PORT_DETECT_RESISTANCE_HIGH\t5\n#define PORT_DETECT_OPEN_CIRCUIT\t6\n#define PORT_DETECT_RESERVED_2\t\t7\n#define PORT_DETECT_MOSFET_FAULT\t8\n#define PORT_DETECT_LEGACY\t\t9\n \n#define PORT_DETECT_CAPACITANCE_INVALID_BEYOND\t10\n \n#define PORT_DETECT_CAPACITANCE_INVALID_DELTA\t11\n#define PORT_DETECT_CAPACITANCE_OUT_OF_RANGE\t12\n#define POE_PLUS\t\t\t0x40\n#define OPERATING_MODE\t\t\t0x12\n#define OPERATING_MODE_OFF\t\t0\n#define OPERATING_MODE_MANUAL\t\t1\n#define OPERATING_MODE_SEMI\t\t2\n#define OPERATING_MODE_AUTO\t\t3\n#define OPERATING_MODE_PORT_1_MASK\tGENMASK(1, 0)\n#define OPERATING_MODE_PORT_2_MASK\tGENMASK(3, 2)\n#define OPERATING_MODE_PORT_3_MASK\tGENMASK(5, 4)\n#define OPERATING_MODE_PORT_4_MASK\tGENMASK(7, 6)\n\n#define DETECT_CLASS_RESTART\t\t0x18\n#define POWER_ENABLE\t\t\t0x19\n#define TPS23861_NUM_PORTS\t\t4\n\n#define TPS23861_GENERAL_MASK_1\t\t0x17\n#define TPS23861_CURRENT_SHUNT_MASK\tBIT(0)\n\n#define TEMPERATURE_LSB\t\t\t652  \n#define VOLTAGE_LSB\t\t\t3662  \n#define SHUNT_RESISTOR_DEFAULT\t\t255000  \n#define CURRENT_LSB_250\t\t\t62260  \n#define CURRENT_LSB_255\t\t\t61039  \n#define RESISTANCE_LSB\t\t\t110966  \n#define RESISTANCE_LSB_LOW\t\t157216  \n\nstruct tps23861_data {\n\tstruct regmap *regmap;\n\tu32 shunt_resistor;\n\tstruct i2c_client *client;\n\tstruct dentry *debugfs_dir;\n};\n\nstatic struct regmap_config tps23861_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x6f,\n};\n\nstatic int tps23861_read_temp(struct tps23861_data *data, long *val)\n{\n\tunsigned int regval;\n\tint err;\n\n\terr = regmap_read(data->regmap, TEMPERATURE, &regval);\n\tif (err < 0)\n\t\treturn err;\n\n\t*val = (regval * TEMPERATURE_LSB) - 20000;\n\n\treturn 0;\n}\n\nstatic int tps23861_read_voltage(struct tps23861_data *data, int channel,\n\t\t\t\t long *val)\n{\n\t__le16 regval;\n\tlong raw_val;\n\tint err;\n\n\tif (channel < TPS23861_NUM_PORTS) {\n\t\terr = regmap_bulk_read(data->regmap,\n\t\t\t\t       PORT_1_VOLTAGE_LSB + channel * PORT_N_VOLTAGE_LSB_OFFSET,\n\t\t\t\t       &regval, 2);\n\t} else {\n\t\terr = regmap_bulk_read(data->regmap,\n\t\t\t\t       INPUT_VOLTAGE_LSB,\n\t\t\t\t       &regval, 2);\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\traw_val = le16_to_cpu(regval);\n\t*val = (FIELD_GET(VOLTAGE_CURRENT_MASK, raw_val) * VOLTAGE_LSB) / 1000;\n\n\treturn 0;\n}\n\nstatic int tps23861_read_current(struct tps23861_data *data, int channel,\n\t\t\t\t long *val)\n{\n\tlong raw_val, current_lsb;\n\t__le16 regval;\n\n\tint err;\n\n\tif (data->shunt_resistor == SHUNT_RESISTOR_DEFAULT)\n\t\tcurrent_lsb = CURRENT_LSB_255;\n\telse\n\t\tcurrent_lsb = CURRENT_LSB_250;\n\n\terr = regmap_bulk_read(data->regmap,\n\t\t\t       PORT_1_CURRENT_LSB + channel * PORT_N_CURRENT_LSB_OFFSET,\n\t\t\t       &regval, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\traw_val = le16_to_cpu(regval);\n\t*val = (FIELD_GET(VOLTAGE_CURRENT_MASK, raw_val) * current_lsb) / 1000000;\n\n\treturn 0;\n}\n\nstatic int tps23861_port_disable(struct tps23861_data *data, int channel)\n{\n\tunsigned int regval = 0;\n\tint err;\n\n\tregval |= BIT(channel + 4);\n\terr = regmap_write(data->regmap, POWER_ENABLE, regval);\n\n\treturn err;\n}\n\nstatic int tps23861_port_enable(struct tps23861_data *data, int channel)\n{\n\tunsigned int regval = 0;\n\tint err;\n\n\tregval |= BIT(channel);\n\tregval |= BIT(channel + 4);\n\terr = regmap_write(data->regmap, DETECT_CLASS_RESTART, regval);\n\n\treturn err;\n}\n\nstatic umode_t tps23861_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t   u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_label:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\tcase hwmon_in_label:\n\t\t\treturn 0444;\n\t\tcase hwmon_in_enable:\n\t\t\treturn 0200;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_input:\n\t\tcase hwmon_curr_label:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int tps23861_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t  u32 attr, int channel, long val)\n{\n\tstruct tps23861_data *data = dev_get_drvdata(dev);\n\tint err;\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_enable:\n\t\t\tif (val == 0)\n\t\t\t\terr = tps23861_port_disable(data, channel);\n\t\t\telse if (val == 1)\n\t\t\t\terr = tps23861_port_enable(data, channel);\n\t\t\telse\n\t\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic int tps23861_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long *val)\n{\n\tstruct tps23861_data *data = dev_get_drvdata(dev);\n\tint err;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\terr = tps23861_read_temp(data, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\terr = tps23861_read_voltage(data, channel, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_input:\n\t\t\terr = tps23861_read_current(data, channel, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic const char * const tps23861_port_label[] = {\n\t\"Port1\",\n\t\"Port2\",\n\t\"Port3\",\n\t\"Port4\",\n\t\"Input\",\n};\n\nstatic int tps23861_read_string(struct device *dev,\n\t\t\t\tenum hwmon_sensor_types type,\n\t\t\t\tu32 attr, int channel, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\tcase hwmon_curr:\n\t\t*str = tps23861_port_label[channel];\n\t\tbreak;\n\tcase hwmon_temp:\n\t\t*str = \"Die\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const tps23861_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_ENABLE | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_ENABLE | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_ENABLE | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_ENABLE | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL),\n\tHWMON_CHANNEL_INFO(curr,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL),\n\tNULL\n};\n\nstatic const struct hwmon_ops tps23861_hwmon_ops = {\n\t.is_visible = tps23861_is_visible,\n\t.write = tps23861_write,\n\t.read = tps23861_read,\n\t.read_string = tps23861_read_string,\n};\n\nstatic const struct hwmon_chip_info tps23861_chip_info = {\n\t.ops = &tps23861_hwmon_ops,\n\t.info = tps23861_info,\n};\n\nstatic char *port_operating_mode_string(uint8_t mode_reg, unsigned int port)\n{\n\tunsigned int mode = ~0;\n\n\tif (port < TPS23861_NUM_PORTS)\n\t\tmode = (mode_reg >> (2 * port)) & OPERATING_MODE_PORT_1_MASK;\n\n\tswitch (mode) {\n\tcase OPERATING_MODE_OFF:\n\t\treturn \"Off\";\n\tcase OPERATING_MODE_MANUAL:\n\t\treturn \"Manual\";\n\tcase OPERATING_MODE_SEMI:\n\t\treturn \"Semi-Auto\";\n\tcase OPERATING_MODE_AUTO:\n\t\treturn \"Auto\";\n\tdefault:\n\t\treturn \"Invalid\";\n\t}\n}\n\nstatic char *port_detect_status_string(uint8_t status_reg)\n{\n\tswitch (FIELD_GET(PORT_STATUS_DETECT_MASK, status_reg)) {\n\tcase PORT_DETECT_UNKNOWN:\n\t\treturn \"Unknown device\";\n\tcase PORT_DETECT_SHORT:\n\t\treturn \"Short circuit\";\n\tcase PORT_DETECT_RESISTANCE_LOW:\n\t\treturn \"Too low resistance\";\n\tcase PORT_DETECT_RESISTANCE_OK:\n\t\treturn \"Valid resistance\";\n\tcase PORT_DETECT_RESISTANCE_HIGH:\n\t\treturn \"Too high resistance\";\n\tcase PORT_DETECT_OPEN_CIRCUIT:\n\t\treturn \"Open circuit\";\n\tcase PORT_DETECT_MOSFET_FAULT:\n\t\treturn \"MOSFET fault\";\n\tcase PORT_DETECT_LEGACY:\n\t\treturn \"Legacy device\";\n\tcase PORT_DETECT_CAPACITANCE_INVALID_BEYOND:\n\t\treturn \"Invalid capacitance, beyond clamp voltage\";\n\tcase PORT_DETECT_CAPACITANCE_INVALID_DELTA:\n\t\treturn \"Invalid capacitance, insufficient voltage delta\";\n\tcase PORT_DETECT_CAPACITANCE_OUT_OF_RANGE:\n\t\treturn \"Valid capacitance, outside of legacy range\";\n\tcase PORT_DETECT_RESERVED:\n\tcase PORT_DETECT_RESERVED_2:\n\tdefault:\n\t\treturn \"Invalid\";\n\t}\n}\n\nstatic char *port_class_status_string(uint8_t status_reg)\n{\n\tswitch (FIELD_GET(PORT_STATUS_CLASS_MASK, status_reg)) {\n\tcase PORT_CLASS_UNKNOWN:\n\t\treturn \"Unknown\";\n\tcase PORT_CLASS_RESERVED:\n\tcase PORT_CLASS_0:\n\t\treturn \"0\";\n\tcase PORT_CLASS_1:\n\t\treturn \"1\";\n\tcase PORT_CLASS_2:\n\t\treturn \"2\";\n\tcase PORT_CLASS_3:\n\t\treturn \"3\";\n\tcase PORT_CLASS_4:\n\t\treturn \"4\";\n\tcase PORT_CLASS_OVERCURRENT:\n\t\treturn \"Overcurrent\";\n\tcase PORT_CLASS_MISMATCH:\n\t\treturn \"Mismatch\";\n\tdefault:\n\t\treturn \"Invalid\";\n\t}\n}\n\nstatic char *port_poe_plus_status_string(uint8_t poe_plus, unsigned int port)\n{\n\treturn (BIT(port + 4) & poe_plus) ? \"Yes\" : \"No\";\n}\n\nstatic int tps23861_port_resistance(struct tps23861_data *data, int port)\n{\n\tunsigned int raw_val;\n\t__le16 regval;\n\n\tregmap_bulk_read(data->regmap,\n\t\t\t PORT_1_RESISTANCE_LSB + PORT_N_RESISTANCE_LSB_OFFSET * port,\n\t\t\t &regval,\n\t\t\t 2);\n\n\traw_val = le16_to_cpu(regval);\n\tswitch (FIELD_GET(PORT_RESISTANCE_RSN_MASK, raw_val)) {\n\tcase PORT_RESISTANCE_RSN_OTHER:\n\t\treturn (FIELD_GET(PORT_RESISTANCE_MASK, raw_val) * RESISTANCE_LSB) / 10000;\n\tcase PORT_RESISTANCE_RSN_LOW:\n\t\treturn (FIELD_GET(PORT_RESISTANCE_MASK, raw_val) * RESISTANCE_LSB_LOW) / 10000;\n\tcase PORT_RESISTANCE_RSN_SHORT:\n\tcase PORT_RESISTANCE_RSN_OPEN:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int tps23861_port_status_show(struct seq_file *s, void *data)\n{\n\tstruct tps23861_data *priv = s->private;\n\tunsigned int i, mode, poe_plus, status;\n\n\tregmap_read(priv->regmap, OPERATING_MODE, &mode);\n\tregmap_read(priv->regmap, POE_PLUS, &poe_plus);\n\n\tfor (i = 0; i < TPS23861_NUM_PORTS; i++) {\n\t\tregmap_read(priv->regmap, PORT_1_STATUS + i, &status);\n\n\t\tseq_printf(s, \"Port: \\t\\t%d\\n\", i + 1);\n\t\tseq_printf(s, \"Operating mode: %s\\n\", port_operating_mode_string(mode, i));\n\t\tseq_printf(s, \"Detected: \\t%s\\n\", port_detect_status_string(status));\n\t\tseq_printf(s, \"Class: \\t\\t%s\\n\", port_class_status_string(status));\n\t\tseq_printf(s, \"PoE Plus: \\t%s\\n\", port_poe_plus_status_string(poe_plus, i));\n\t\tseq_printf(s, \"Resistance: \\t%d\\n\", tps23861_port_resistance(priv, i));\n\t\tseq_putc(s, '\\n');\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(tps23861_port_status);\n\nstatic void tps23861_init_debugfs(struct tps23861_data *data,\n\t\t\t\t  struct device *hwmon_dev)\n{\n\tconst char *debugfs_name;\n\n\tdebugfs_name = devm_kasprintf(&data->client->dev, GFP_KERNEL, \"%s-%s\",\n\t\t\t\t      data->client->name, dev_name(hwmon_dev));\n\tif (!debugfs_name)\n\t\treturn;\n\n\tdata->debugfs_dir = debugfs_create_dir(debugfs_name, NULL);\n\n\tdebugfs_create_file(\"port_status\",\n\t\t\t    0400,\n\t\t\t    data->debugfs_dir,\n\t\t\t    data,\n\t\t\t    &tps23861_port_status_fops);\n}\n\nstatic int tps23861_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tps23861_data *data;\n\tstruct device *hwmon_dev;\n\tu32 shunt_resistor;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\ti2c_set_clientdata(client, data);\n\n\tdata->regmap = devm_regmap_init_i2c(client, &tps23861_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\tif (!of_property_read_u32(dev->of_node, \"shunt-resistor-micro-ohms\", &shunt_resistor))\n\t\tdata->shunt_resistor = shunt_resistor;\n\telse\n\t\tdata->shunt_resistor = SHUNT_RESISTOR_DEFAULT;\n\n\tif (data->shunt_resistor == SHUNT_RESISTOR_DEFAULT)\n\t\tregmap_clear_bits(data->regmap,\n\t\t\t\t  TPS23861_GENERAL_MASK_1,\n\t\t\t\t  TPS23861_CURRENT_SHUNT_MASK);\n\telse\n\t\tregmap_set_bits(data->regmap,\n\t\t\t\tTPS23861_GENERAL_MASK_1,\n\t\t\t\tTPS23861_CURRENT_SHUNT_MASK);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data, &tps23861_chip_info,\n\t\t\t\t\t\t\t NULL);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\ttps23861_init_debugfs(data, hwmon_dev);\n\n\treturn 0;\n}\n\nstatic void tps23861_remove(struct i2c_client *client)\n{\n\tstruct tps23861_data *data = i2c_get_clientdata(client);\n\n\tdebugfs_remove_recursive(data->debugfs_dir);\n}\n\nstatic const struct of_device_id __maybe_unused tps23861_of_match[] = {\n\t{ .compatible = \"ti,tps23861\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tps23861_of_match);\n\nstatic struct i2c_driver tps23861_driver = {\n\t.probe\t\t\t= tps23861_probe,\n\t.remove\t\t\t= tps23861_remove,\n\t.driver = {\n\t\t.name\t\t= \"tps23861\",\n\t\t.of_match_table\t= of_match_ptr(tps23861_of_match),\n\t},\n};\nmodule_i2c_driver(tps23861_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Robert Marko <robert.marko@sartura.hr>\");\nMODULE_DESCRIPTION(\"TI TPS23861 PoE PSE\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}