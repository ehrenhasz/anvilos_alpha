{
  "module_name": "lm85.c",
  "hash_id": "8cb66f8ffc3eca7e6cb0d413f8f263fcab1021de9c9b3be2a06a10cc745b4b2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lm85.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-vid.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/util_macros.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x2c, 0x2d, 0x2e, I2C_CLIENT_END };\n\nenum chips {\n\tlm85, lm96000,\n\tadm1027, adt7463, adt7468,\n\temc6d100, emc6d102, emc6d103, emc6d103s\n};\n\n \n\n#define LM85_REG_IN(nr)\t\t\t(0x20 + (nr))\n#define LM85_REG_IN_MIN(nr)\t\t(0x44 + (nr) * 2)\n#define LM85_REG_IN_MAX(nr)\t\t(0x45 + (nr) * 2)\n\n#define LM85_REG_TEMP(nr)\t\t(0x25 + (nr))\n#define LM85_REG_TEMP_MIN(nr)\t\t(0x4e + (nr) * 2)\n#define LM85_REG_TEMP_MAX(nr)\t\t(0x4f + (nr) * 2)\n\n \n#define LM85_REG_FAN(nr)\t\t(0x28 + (nr) * 2)\n#define LM85_REG_FAN_MIN(nr)\t\t(0x54 + (nr) * 2)\n\n#define LM85_REG_PWM(nr)\t\t(0x30 + (nr))\n\n#define LM85_REG_COMPANY\t\t0x3e\n#define LM85_REG_VERSTEP\t\t0x3f\n\n#define ADT7468_REG_CFG5\t\t0x7c\n#define ADT7468_OFF64\t\t\t(1 << 0)\n#define ADT7468_HFPWM\t\t\t(1 << 1)\n#define IS_ADT7468_OFF64(data)\t\t\\\n\t((data)->type == adt7468 && !((data)->cfg5 & ADT7468_OFF64))\n#define IS_ADT7468_HFPWM(data)\t\t\\\n\t((data)->type == adt7468 && !((data)->cfg5 & ADT7468_HFPWM))\n\n \n#define LM85_COMPANY_NATIONAL\t\t0x01\n#define LM85_COMPANY_ANALOG_DEV\t\t0x41\n#define LM85_COMPANY_SMSC\t\t0x5c\n#define LM85_VERSTEP_LM85C\t\t0x60\n#define LM85_VERSTEP_LM85B\t\t0x62\n#define LM85_VERSTEP_LM96000_1\t\t0x68\n#define LM85_VERSTEP_LM96000_2\t\t0x69\n#define LM85_VERSTEP_ADM1027\t\t0x60\n#define LM85_VERSTEP_ADT7463\t\t0x62\n#define LM85_VERSTEP_ADT7463C\t\t0x6A\n#define LM85_VERSTEP_ADT7468_1\t\t0x71\n#define LM85_VERSTEP_ADT7468_2\t\t0x72\n#define LM85_VERSTEP_EMC6D100_A0        0x60\n#define LM85_VERSTEP_EMC6D100_A1        0x61\n#define LM85_VERSTEP_EMC6D102\t\t0x65\n#define LM85_VERSTEP_EMC6D103_A0\t0x68\n#define LM85_VERSTEP_EMC6D103_A1\t0x69\n#define LM85_VERSTEP_EMC6D103S\t\t0x6A\t \n\n#define LM85_REG_CONFIG\t\t\t0x40\n\n#define LM85_REG_ALARM1\t\t\t0x41\n#define LM85_REG_ALARM2\t\t\t0x42\n\n#define LM85_REG_VID\t\t\t0x43\n\n \n#define LM85_REG_AFAN_CONFIG(nr)\t(0x5c + (nr))\n#define LM85_REG_AFAN_RANGE(nr)\t\t(0x5f + (nr))\n#define LM85_REG_AFAN_SPIKE1\t\t0x62\n#define LM85_REG_AFAN_MINPWM(nr)\t(0x64 + (nr))\n#define LM85_REG_AFAN_LIMIT(nr)\t\t(0x67 + (nr))\n#define LM85_REG_AFAN_CRITICAL(nr)\t(0x6a + (nr))\n#define LM85_REG_AFAN_HYST1\t\t0x6d\n#define LM85_REG_AFAN_HYST2\t\t0x6e\n\n#define ADM1027_REG_EXTEND_ADC1\t\t0x76\n#define ADM1027_REG_EXTEND_ADC2\t\t0x77\n\n#define EMC6D100_REG_ALARM3             0x7d\n \n#define EMC6D100_REG_IN(nr)             (0x70 + ((nr) - 5))\n#define EMC6D100_REG_IN_MIN(nr)         (0x73 + ((nr) - 5) * 2)\n#define EMC6D100_REG_IN_MAX(nr)         (0x74 + ((nr) - 5) * 2)\n#define EMC6D102_REG_EXTEND_ADC1\t0x85\n#define EMC6D102_REG_EXTEND_ADC2\t0x86\n#define EMC6D102_REG_EXTEND_ADC3\t0x87\n#define EMC6D102_REG_EXTEND_ADC4\t0x88\n\n \n\n \nstatic const int lm85_scaling[] = {   \n\t2500, 2250, 3300, 5000, 12000,\n\t3300, 1500, 1800  \n};\n#define SCALE(val, from, to)\t(((val) * (to) + ((from) / 2)) / (from))\n\n#define INS_TO_REG(n, val)\t\\\n\t\tSCALE(clamp_val(val, 0, 255 * lm85_scaling[n] / 192), \\\n\t\t      lm85_scaling[n], 192)\n\n#define INSEXT_FROM_REG(n, val, ext)\t\\\n\t\tSCALE(((val) << 4) + (ext), 192 << 4, lm85_scaling[n])\n\n#define INS_FROM_REG(n, val)\tSCALE((val), 192, lm85_scaling[n])\n\n \nstatic inline u16 FAN_TO_REG(unsigned long val)\n{\n\tif (!val)\n\t\treturn 0xffff;\n\treturn clamp_val(5400000 / val, 1, 0xfffe);\n}\n#define FAN_FROM_REG(val)\t((val) == 0 ? -1 : (val) == 0xffff ? 0 : \\\n\t\t\t\t 5400000 / (val))\n\n \n#define TEMP_TO_REG(val)\t\\\n\t\tDIV_ROUND_CLOSEST(clamp_val((val), -127000, 127000), 1000)\n#define TEMPEXT_FROM_REG(val, ext)\t\\\n\t\tSCALE(((val) << 4) + (ext), 16, 1000)\n#define TEMP_FROM_REG(val)\t((val) * 1000)\n\n#define PWM_TO_REG(val)\t\t\tclamp_val(val, 0, 255)\n#define PWM_FROM_REG(val)\t\t(val)\n\n \n\n \nstatic const int lm85_range_map[] = {\n\t2000, 2500, 3300, 4000, 5000, 6600, 8000, 10000,\n\t13300, 16000, 20000, 26600, 32000, 40000, 53300, 80000\n};\n\nstatic int RANGE_TO_REG(long range)\n{\n\treturn find_closest(range, lm85_range_map, ARRAY_SIZE(lm85_range_map));\n}\n#define RANGE_FROM_REG(val)\tlm85_range_map[(val) & 0x0f]\n\n \nstatic const int lm85_freq_map[] = {  \n\t10, 15, 23, 30, 38, 47, 61, 94\n};\n\nstatic const int lm96000_freq_map[] = {  \n\t10, 15, 23, 30, 38, 47, 61, 94,\n\t22500, 24000, 25700, 25700, 27700, 27700, 30000, 30000\n};\n\nstatic const int adm1027_freq_map[] = {  \n\t11, 15, 22, 29, 35, 44, 59, 88\n};\n\nstatic int FREQ_TO_REG(const int *map,\n\t\t       unsigned int map_size, unsigned long freq)\n{\n\treturn find_closest(freq, map, map_size);\n}\n\nstatic int FREQ_FROM_REG(const int *map, unsigned int map_size, u8 reg)\n{\n\treturn map[reg % map_size];\n}\n\n \n\nstatic const int lm85_zone_map[] = { 1, 2, 3, -1, 0, 23, 123, -2 };\n#define ZONE_FROM_REG(val)\tlm85_zone_map[(val) >> 5]\n\nstatic int ZONE_TO_REG(int zone)\n{\n\tint i;\n\n\tfor (i = 0; i <= 7; ++i)\n\t\tif (zone == lm85_zone_map[i])\n\t\t\tbreak;\n\tif (i > 7)    \n\t\ti = 3;   \n\treturn i << 5;\n}\n\n#define HYST_TO_REG(val)\tclamp_val(((val) + 500) / 1000, 0, 15)\n#define HYST_FROM_REG(val)\t((val) * 1000)\n\n \n#define LM85_DATA_INTERVAL  (HZ + HZ / 2)\n#define LM85_CONFIG_INTERVAL  (1 * 60 * HZ)\n\n \nstruct lm85_zone {\n\ts8 limit;\t \n\tu8 hyst;\t \n\tu8 range;\t \n\ts8 critical;\t \n\tu8 max_desired;  \n};\n\nstruct lm85_autofan {\n\tu8 config;\t \n\tu8 min_pwm;\t \n\tu8 min_off;\t \n};\n\n \nstruct lm85_data {\n\tstruct i2c_client *client;\n\tconst struct attribute_group *groups[6];\n\tconst int *freq_map;\n\tunsigned int freq_map_size;\n\n\tenum chips type;\n\n\tbool has_vid5;\t \n\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_reading;\t \n\tunsigned long last_config;\t \n\n\tu8 in[8];\t\t \n\tu8 in_max[8];\t\t \n\tu8 in_min[8];\t\t \n\ts8 temp[3];\t\t \n\ts8 temp_min[3];\t\t \n\ts8 temp_max[3];\t\t \n\tu16 fan[4];\t\t \n\tu16 fan_min[4];\t\t \n\tu8 pwm[3];\t\t \n\tu8 pwm_freq[3];\t\t \n\tu8 temp_ext[3];\t\t \n\tu8 in_ext[8];\t\t \n\tu8 vid;\t\t\t \n\tu8 vrm;\t\t\t \n\tu32 alarms;\t\t \n\tu8 cfg5;\t\t \n\tstruct lm85_autofan autofan[3];\n\tstruct lm85_zone zone[3];\n};\n\nstatic int lm85_read_value(struct i2c_client *client, u8 reg)\n{\n\tint res;\n\n\t \n\tswitch (reg) {\n\tcase LM85_REG_FAN(0):   \n\tcase LM85_REG_FAN(1):\n\tcase LM85_REG_FAN(2):\n\tcase LM85_REG_FAN(3):\n\tcase LM85_REG_FAN_MIN(0):\n\tcase LM85_REG_FAN_MIN(1):\n\tcase LM85_REG_FAN_MIN(2):\n\tcase LM85_REG_FAN_MIN(3):\n\tcase LM85_REG_ALARM1:\t \n\t\tres = i2c_smbus_read_byte_data(client, reg) & 0xff;\n\t\tres |= i2c_smbus_read_byte_data(client, reg + 1) << 8;\n\t\tbreak;\n\tdefault:\t \n\t\tres = i2c_smbus_read_byte_data(client, reg);\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n\nstatic void lm85_write_value(struct i2c_client *client, u8 reg, int value)\n{\n\tswitch (reg) {\n\tcase LM85_REG_FAN(0):   \n\tcase LM85_REG_FAN(1):\n\tcase LM85_REG_FAN(2):\n\tcase LM85_REG_FAN(3):\n\tcase LM85_REG_FAN_MIN(0):\n\tcase LM85_REG_FAN_MIN(1):\n\tcase LM85_REG_FAN_MIN(2):\n\tcase LM85_REG_FAN_MIN(3):\n\t \n\t\ti2c_smbus_write_byte_data(client, reg, value & 0xff);\n\t\ti2c_smbus_write_byte_data(client, reg + 1, value >> 8);\n\t\tbreak;\n\tdefault:\t \n\t\ti2c_smbus_write_byte_data(client, reg, value);\n\t\tbreak;\n\t}\n}\n\nstatic struct lm85_data *lm85_update_device(struct device *dev)\n{\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (!data->valid ||\n\t     time_after(jiffies, data->last_reading + LM85_DATA_INTERVAL)) {\n\t\t \n\t\tdev_dbg(&client->dev, \"Reading sensor values\\n\");\n\n\t\t \n\t\tif (data->type == adm1027 || data->type == adt7463 ||\n\t\t    data->type == adt7468) {\n\t\t\tint ext1 = lm85_read_value(client,\n\t\t\t\t\t\t   ADM1027_REG_EXTEND_ADC1);\n\t\t\tint ext2 =  lm85_read_value(client,\n\t\t\t\t\t\t    ADM1027_REG_EXTEND_ADC2);\n\t\t\tint val = (ext1 << 8) + ext2;\n\n\t\t\tfor (i = 0; i <= 4; i++)\n\t\t\t\tdata->in_ext[i] =\n\t\t\t\t\t((val >> (i * 2)) & 0x03) << 2;\n\n\t\t\tfor (i = 0; i <= 2; i++)\n\t\t\t\tdata->temp_ext[i] =\n\t\t\t\t\t(val >> ((i + 4) * 2)) & 0x0c;\n\t\t}\n\n\t\tdata->vid = lm85_read_value(client, LM85_REG_VID);\n\n\t\tfor (i = 0; i <= 3; ++i) {\n\t\t\tdata->in[i] =\n\t\t\t    lm85_read_value(client, LM85_REG_IN(i));\n\t\t\tdata->fan[i] =\n\t\t\t    lm85_read_value(client, LM85_REG_FAN(i));\n\t\t}\n\n\t\tif (!data->has_vid5)\n\t\t\tdata->in[4] = lm85_read_value(client, LM85_REG_IN(4));\n\n\t\tif (data->type == adt7468)\n\t\t\tdata->cfg5 = lm85_read_value(client, ADT7468_REG_CFG5);\n\n\t\tfor (i = 0; i <= 2; ++i) {\n\t\t\tdata->temp[i] =\n\t\t\t    lm85_read_value(client, LM85_REG_TEMP(i));\n\t\t\tdata->pwm[i] =\n\t\t\t    lm85_read_value(client, LM85_REG_PWM(i));\n\n\t\t\tif (IS_ADT7468_OFF64(data))\n\t\t\t\tdata->temp[i] -= 64;\n\t\t}\n\n\t\tdata->alarms = lm85_read_value(client, LM85_REG_ALARM1);\n\n\t\tif (data->type == emc6d100) {\n\t\t\t \n\t\t\tfor (i = 5; i <= 7; ++i) {\n\t\t\t\tdata->in[i] = lm85_read_value(client,\n\t\t\t\t\t\t\tEMC6D100_REG_IN(i));\n\t\t\t}\n\t\t\t \n\t\t\tdata->alarms |= lm85_read_value(client,\n\t\t\t\t\t\tEMC6D100_REG_ALARM3) << 16;\n\t\t} else if (data->type == emc6d102 || data->type == emc6d103 ||\n\t\t\t   data->type == emc6d103s) {\n\t\t\t \n\t\t\tint ext1 = lm85_read_value(client,\n\t\t\t\t\t\t   EMC6D102_REG_EXTEND_ADC1);\n\t\t\tint ext2 = lm85_read_value(client,\n\t\t\t\t\t\t   EMC6D102_REG_EXTEND_ADC2);\n\t\t\tint ext3 = lm85_read_value(client,\n\t\t\t\t\t\t   EMC6D102_REG_EXTEND_ADC3);\n\t\t\tint ext4 = lm85_read_value(client,\n\t\t\t\t\t\t   EMC6D102_REG_EXTEND_ADC4);\n\t\t\tdata->in_ext[0] = ext3 & 0x0f;\n\t\t\tdata->in_ext[1] = ext4 & 0x0f;\n\t\t\tdata->in_ext[2] = ext4 >> 4;\n\t\t\tdata->in_ext[3] = ext3 >> 4;\n\t\t\tdata->in_ext[4] = ext2 >> 4;\n\n\t\t\tdata->temp_ext[0] = ext1 & 0x0f;\n\t\t\tdata->temp_ext[1] = ext2 & 0x0f;\n\t\t\tdata->temp_ext[2] = ext1 >> 4;\n\t\t}\n\n\t\tdata->last_reading = jiffies;\n\t}   \n\n\tif (!data->valid ||\n\t     time_after(jiffies, data->last_config + LM85_CONFIG_INTERVAL)) {\n\t\t \n\t\tdev_dbg(&client->dev, \"Reading config values\\n\");\n\n\t\tfor (i = 0; i <= 3; ++i) {\n\t\t\tdata->in_min[i] =\n\t\t\t    lm85_read_value(client, LM85_REG_IN_MIN(i));\n\t\t\tdata->in_max[i] =\n\t\t\t    lm85_read_value(client, LM85_REG_IN_MAX(i));\n\t\t\tdata->fan_min[i] =\n\t\t\t    lm85_read_value(client, LM85_REG_FAN_MIN(i));\n\t\t}\n\n\t\tif (!data->has_vid5)  {\n\t\t\tdata->in_min[4] = lm85_read_value(client,\n\t\t\t\t\t  LM85_REG_IN_MIN(4));\n\t\t\tdata->in_max[4] = lm85_read_value(client,\n\t\t\t\t\t  LM85_REG_IN_MAX(4));\n\t\t}\n\n\t\tif (data->type == emc6d100) {\n\t\t\tfor (i = 5; i <= 7; ++i) {\n\t\t\t\tdata->in_min[i] = lm85_read_value(client,\n\t\t\t\t\t\tEMC6D100_REG_IN_MIN(i));\n\t\t\t\tdata->in_max[i] = lm85_read_value(client,\n\t\t\t\t\t\tEMC6D100_REG_IN_MAX(i));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i <= 2; ++i) {\n\t\t\tint val;\n\n\t\t\tdata->temp_min[i] =\n\t\t\t    lm85_read_value(client, LM85_REG_TEMP_MIN(i));\n\t\t\tdata->temp_max[i] =\n\t\t\t    lm85_read_value(client, LM85_REG_TEMP_MAX(i));\n\n\t\t\tdata->autofan[i].config =\n\t\t\t    lm85_read_value(client, LM85_REG_AFAN_CONFIG(i));\n\t\t\tval = lm85_read_value(client, LM85_REG_AFAN_RANGE(i));\n\t\t\tdata->pwm_freq[i] = val % data->freq_map_size;\n\t\t\tdata->zone[i].range = val >> 4;\n\t\t\tdata->autofan[i].min_pwm =\n\t\t\t    lm85_read_value(client, LM85_REG_AFAN_MINPWM(i));\n\t\t\tdata->zone[i].limit =\n\t\t\t    lm85_read_value(client, LM85_REG_AFAN_LIMIT(i));\n\t\t\tdata->zone[i].critical =\n\t\t\t    lm85_read_value(client, LM85_REG_AFAN_CRITICAL(i));\n\n\t\t\tif (IS_ADT7468_OFF64(data)) {\n\t\t\t\tdata->temp_min[i] -= 64;\n\t\t\t\tdata->temp_max[i] -= 64;\n\t\t\t\tdata->zone[i].limit -= 64;\n\t\t\t\tdata->zone[i].critical -= 64;\n\t\t\t}\n\t\t}\n\n\t\tif (data->type != emc6d103s) {\n\t\t\ti = lm85_read_value(client, LM85_REG_AFAN_SPIKE1);\n\t\t\tdata->autofan[0].min_off = (i & 0x20) != 0;\n\t\t\tdata->autofan[1].min_off = (i & 0x40) != 0;\n\t\t\tdata->autofan[2].min_off = (i & 0x80) != 0;\n\n\t\t\ti = lm85_read_value(client, LM85_REG_AFAN_HYST1);\n\t\t\tdata->zone[0].hyst = i >> 4;\n\t\t\tdata->zone[1].hyst = i & 0x0f;\n\n\t\t\ti = lm85_read_value(client, LM85_REG_AFAN_HYST2);\n\t\t\tdata->zone[2].hyst = i >> 4;\n\t\t}\n\n\t\tdata->last_config = jiffies;\n\t}   \n\n\tdata->valid = true;\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \nstatic ssize_t fan_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", FAN_FROM_REG(data->fan[nr]));\n}\n\nstatic ssize_t fan_min_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", FAN_FROM_REG(data->fan_min[nr]));\n}\n\nstatic ssize_t fan_min_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_min[nr] = FAN_TO_REG(val);\n\tlm85_write_value(client, LM85_REG_FAN_MIN(nr), data->fan_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_min, fan_min, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_min, fan_min, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_input, fan, 2);\nstatic SENSOR_DEVICE_ATTR_RW(fan3_min, fan_min, 2);\nstatic SENSOR_DEVICE_ATTR_RO(fan4_input, fan, 3);\nstatic SENSOR_DEVICE_ATTR_RW(fan4_min, fan_min, 3);\n\n \n\nstatic ssize_t cpu0_vid_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct lm85_data *data = lm85_update_device(dev);\n\tint vid;\n\n\tif (data->has_vid5) {\n\t\t \n\t\tvid = vid_from_reg(data->vid & 0x3f, data->vrm);\n\t} else {\n\t\t \n\t\tvid = vid_from_reg(data->vid & 0x1f, data->vrm);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", vid);\n}\n\nstatic DEVICE_ATTR_RO(cpu0_vid);\n\nstatic ssize_t vrm_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long) data->vrm);\n}\n\nstatic ssize_t vrm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tdata->vrm = val;\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(vrm);\n\nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", data->alarms);\n}\n\nstatic DEVICE_ATTR_RO(alarms);\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> nr) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_alarm, alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_alarm, alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_alarm, alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_alarm, alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_alarm, alarm, 8);\nstatic SENSOR_DEVICE_ATTR_RO(in5_alarm, alarm, 18);\nstatic SENSOR_DEVICE_ATTR_RO(in6_alarm, alarm, 16);\nstatic SENSOR_DEVICE_ATTR_RO(in7_alarm, alarm, 17);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_alarm, alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_fault, alarm, 14);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_alarm, alarm, 5);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_alarm, alarm, 6);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_fault, alarm, 15);\nstatic SENSOR_DEVICE_ATTR_RO(fan1_alarm, alarm, 10);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_alarm, alarm, 11);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_alarm, alarm, 12);\nstatic SENSOR_DEVICE_ATTR_RO(fan4_alarm, alarm, 13);\n\n \n\nstatic ssize_t pwm_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", PWM_FROM_REG(data->pwm[nr]));\n}\n\nstatic ssize_t pwm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm[nr] = PWM_TO_REG(val);\n\tlm85_write_value(client, LM85_REG_PWM(nr), data->pwm[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t pwm_enable_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\tint pwm_zone, enable;\n\n\tpwm_zone = ZONE_FROM_REG(data->autofan[nr].config);\n\tswitch (pwm_zone) {\n\tcase -1:\t \n\t\tenable = 0;\n\t\tbreak;\n\tcase 0:\t\t \n\tcase -2:\t \n\t\tenable = 1;\n\t\tbreak;\n\tdefault:\t \n\t\tenable = 2;\n\t}\n\treturn sprintf(buf, \"%d\\n\", enable);\n}\n\nstatic ssize_t pwm_enable_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 config;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tswitch (val) {\n\tcase 0:\n\t\tconfig = 3;\n\t\tbreak;\n\tcase 1:\n\t\tconfig = 7;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tconfig = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&data->update_lock);\n\tdata->autofan[nr].config = lm85_read_value(client,\n\t\tLM85_REG_AFAN_CONFIG(nr));\n\tdata->autofan[nr].config = (data->autofan[nr].config & ~0xe0)\n\t\t| (config << 5);\n\tlm85_write_value(client, LM85_REG_AFAN_CONFIG(nr),\n\t\tdata->autofan[nr].config);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t pwm_freq_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\tint freq;\n\n\tif (IS_ADT7468_HFPWM(data))\n\t\tfreq = 22500;\n\telse\n\t\tfreq = FREQ_FROM_REG(data->freq_map, data->freq_map_size,\n\t\t\t\t     data->pwm_freq[nr]);\n\n\treturn sprintf(buf, \"%d\\n\", freq);\n}\n\nstatic ssize_t pwm_freq_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\t \n\tif (data->type == adt7468 && val >= 11300) {\t \n\t\tdata->cfg5 &= ~ADT7468_HFPWM;\n\t\tlm85_write_value(client, ADT7468_REG_CFG5, data->cfg5);\n\t} else {\t\t\t\t\t \n\t\tdata->pwm_freq[nr] = FREQ_TO_REG(data->freq_map,\n\t\t\t\t\t\t data->freq_map_size, val);\n\t\tlm85_write_value(client, LM85_REG_AFAN_RANGE(nr),\n\t\t\t\t (data->zone[nr].range << 4)\n\t\t\t\t | data->pwm_freq[nr]);\n\t\tif (data->type == adt7468) {\n\t\t\tdata->cfg5 |= ADT7468_HFPWM;\n\t\t\tlm85_write_value(client, ADT7468_REG_CFG5, data->cfg5);\n\t\t}\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1, pwm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_enable, pwm_enable, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_freq, pwm_freq, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2, pwm, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_enable, pwm_enable, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_freq, pwm_freq, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3, pwm, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_enable, pwm_enable, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_freq, pwm_freq, 2);\n\n \n\nstatic ssize_t in_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", INSEXT_FROM_REG(nr, data->in[nr],\n\t\t\t\t\t\t    data->in_ext[nr]));\n}\n\nstatic ssize_t in_min_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", INS_FROM_REG(nr, data->in_min[nr]));\n}\n\nstatic ssize_t in_min_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_min[nr] = INS_TO_REG(nr, val);\n\tlm85_write_value(client, LM85_REG_IN_MIN(nr), data->in_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t in_max_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", INS_FROM_REG(nr, data->in_max[nr]));\n}\n\nstatic ssize_t in_max_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_max[nr] = INS_TO_REG(nr, val);\n\tlm85_write_value(client, LM85_REG_IN_MAX(nr), data->in_max[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_input, in, 0);\nstatic SENSOR_DEVICE_ATTR_RW(in0_min, in_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(in0_max, in_max, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, in, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in1_min, in_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in1_max, in_max, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, in, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in2_min, in_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in2_max, in_max, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, in, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in3_min, in_min, 3);\nstatic SENSOR_DEVICE_ATTR_RW(in3_max, in_max, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, in, 4);\nstatic SENSOR_DEVICE_ATTR_RW(in4_min, in_min, 4);\nstatic SENSOR_DEVICE_ATTR_RW(in4_max, in_max, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in5_input, in, 5);\nstatic SENSOR_DEVICE_ATTR_RW(in5_min, in_min, 5);\nstatic SENSOR_DEVICE_ATTR_RW(in5_max, in_max, 5);\nstatic SENSOR_DEVICE_ATTR_RO(in6_input, in, 6);\nstatic SENSOR_DEVICE_ATTR_RW(in6_min, in_min, 6);\nstatic SENSOR_DEVICE_ATTR_RW(in6_max, in_max, 6);\nstatic SENSOR_DEVICE_ATTR_RO(in7_input, in, 7);\nstatic SENSOR_DEVICE_ATTR_RW(in7_min, in_min, 7);\nstatic SENSOR_DEVICE_ATTR_RW(in7_max, in_max, 7);\n\n \n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMPEXT_FROM_REG(data->temp[nr],\n\t\t\t\t\t\t     data->temp_ext[nr]));\n}\n\nstatic ssize_t temp_min_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_min[nr]));\n}\n\nstatic ssize_t temp_min_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (IS_ADT7468_OFF64(data))\n\t\tval += 64;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_min[nr] = TEMP_TO_REG(val);\n\tlm85_write_value(client, LM85_REG_TEMP_MIN(nr), data->temp_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t temp_max_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_max[nr]));\n}\n\nstatic ssize_t temp_max_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (IS_ADT7468_OFF64(data))\n\t\tval += 64;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_max[nr] = TEMP_TO_REG(val);\n\tlm85_write_value(client, LM85_REG_TEMP_MAX(nr), data->temp_max[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp_max, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_min, temp_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp_max, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_min, temp_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_max, temp_max, 2);\n\n \n\nstatic ssize_t pwm_auto_channels_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", ZONE_FROM_REG(data->autofan[nr].config));\n}\n\nstatic ssize_t pwm_auto_channels_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->autofan[nr].config = (data->autofan[nr].config & (~0xe0))\n\t\t| ZONE_TO_REG(val);\n\tlm85_write_value(client, LM85_REG_AFAN_CONFIG(nr),\n\t\tdata->autofan[nr].config);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t pwm_auto_pwm_min_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", PWM_FROM_REG(data->autofan[nr].min_pwm));\n}\n\nstatic ssize_t pwm_auto_pwm_min_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->autofan[nr].min_pwm = PWM_TO_REG(val);\n\tlm85_write_value(client, LM85_REG_AFAN_MINPWM(nr),\n\t\tdata->autofan[nr].min_pwm);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t pwm_auto_pwm_minctl_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->autofan[nr].min_off);\n}\n\nstatic ssize_t pwm_auto_pwm_minctl_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 tmp;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->autofan[nr].min_off = val;\n\ttmp = lm85_read_value(client, LM85_REG_AFAN_SPIKE1);\n\ttmp &= ~(0x20 << nr);\n\tif (data->autofan[nr].min_off)\n\t\ttmp |= 0x20 << nr;\n\tlm85_write_value(client, LM85_REG_AFAN_SPIKE1, tmp);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_channels, pwm_auto_channels, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_pwm_min, pwm_auto_pwm_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_pwm_minctl, pwm_auto_pwm_minctl, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_channels, pwm_auto_channels, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_pwm_min, pwm_auto_pwm_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_pwm_minctl, pwm_auto_pwm_minctl, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_channels, pwm_auto_channels, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_pwm_min, pwm_auto_pwm_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_pwm_minctl, pwm_auto_pwm_minctl, 2);\n\n \n\nstatic ssize_t temp_auto_temp_off_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->zone[nr].limit) -\n\t\tHYST_FROM_REG(data->zone[nr].hyst));\n}\n\nstatic ssize_t temp_auto_temp_off_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint min;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tmin = TEMP_FROM_REG(data->zone[nr].limit);\n\tdata->zone[nr].hyst = HYST_TO_REG(min - val);\n\tif (nr == 0 || nr == 1) {\n\t\tlm85_write_value(client, LM85_REG_AFAN_HYST1,\n\t\t\t(data->zone[0].hyst << 4)\n\t\t\t| data->zone[1].hyst);\n\t} else {\n\t\tlm85_write_value(client, LM85_REG_AFAN_HYST2,\n\t\t\t(data->zone[2].hyst << 4));\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t temp_auto_temp_min_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->zone[nr].limit));\n}\n\nstatic ssize_t temp_auto_temp_min_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->zone[nr].limit = TEMP_TO_REG(val);\n\tlm85_write_value(client, LM85_REG_AFAN_LIMIT(nr),\n\t\tdata->zone[nr].limit);\n\n \n\tdata->zone[nr].range = RANGE_TO_REG(\n\t\tTEMP_FROM_REG(data->zone[nr].max_desired) -\n\t\tTEMP_FROM_REG(data->zone[nr].limit));\n\tlm85_write_value(client, LM85_REG_AFAN_RANGE(nr),\n\t\t((data->zone[nr].range & 0x0f) << 4)\n\t\t| data->pwm_freq[nr]);\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t temp_auto_temp_max_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->zone[nr].limit) +\n\t\tRANGE_FROM_REG(data->zone[nr].range));\n}\n\nstatic ssize_t temp_auto_temp_max_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint min;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tmin = TEMP_FROM_REG(data->zone[nr].limit);\n\tdata->zone[nr].max_desired = TEMP_TO_REG(val);\n\tdata->zone[nr].range = RANGE_TO_REG(\n\t\tval - min);\n\tlm85_write_value(client, LM85_REG_AFAN_RANGE(nr),\n\t\t((data->zone[nr].range & 0x0f) << 4)\n\t\t| data->pwm_freq[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t temp_auto_temp_crit_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = lm85_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->zone[nr].critical));\n}\n\nstatic ssize_t temp_auto_temp_crit_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct lm85_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->zone[nr].critical = TEMP_TO_REG(val);\n\tlm85_write_value(client, LM85_REG_AFAN_CRITICAL(nr),\n\t\tdata->zone[nr].critical);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_temp_off, temp_auto_temp_off, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_temp_min, temp_auto_temp_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_temp_max, temp_auto_temp_max, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_auto_temp_crit, temp_auto_temp_crit, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_temp_off, temp_auto_temp_off, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_temp_min, temp_auto_temp_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_temp_max, temp_auto_temp_max, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_auto_temp_crit, temp_auto_temp_crit, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_temp_off, temp_auto_temp_off, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_temp_min, temp_auto_temp_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_temp_max, temp_auto_temp_max, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_auto_temp_crit, temp_auto_temp_crit, 2);\n\nstatic struct attribute *lm85_attributes[] = {\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan4_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan4_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan4_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_freq.dev_attr.attr,\n\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp3_fault.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm1_auto_channels.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_channels.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_channels.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_pwm_min.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_pwm_min.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_pwm_min.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_auto_temp_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_temp_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_temp_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_temp_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_temp_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_temp_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_temp_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_temp_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_temp_crit.dev_attr.attr,\n\n\t&dev_attr_vrm.attr,\n\t&dev_attr_cpu0_vid.attr,\n\t&dev_attr_alarms.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lm85_group = {\n\t.attrs = lm85_attributes,\n};\n\nstatic struct attribute *lm85_attributes_minctl[] = {\n\t&sensor_dev_attr_pwm1_auto_pwm_minctl.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_pwm_minctl.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_pwm_minctl.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lm85_group_minctl = {\n\t.attrs = lm85_attributes_minctl,\n};\n\nstatic struct attribute *lm85_attributes_temp_off[] = {\n\t&sensor_dev_attr_temp1_auto_temp_off.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_temp_off.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_temp_off.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lm85_group_temp_off = {\n\t.attrs = lm85_attributes_temp_off,\n};\n\nstatic struct attribute *lm85_attributes_in4[] = {\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lm85_group_in4 = {\n\t.attrs = lm85_attributes_in4,\n};\n\nstatic struct attribute *lm85_attributes_in567[] = {\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in6_min.dev_attr.attr,\n\t&sensor_dev_attr_in7_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\t&sensor_dev_attr_in6_max.dev_attr.attr,\n\t&sensor_dev_attr_in7_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in6_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in7_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lm85_group_in567 = {\n\t.attrs = lm85_attributes_in567,\n};\n\nstatic void lm85_init_client(struct i2c_client *client)\n{\n\tint value;\n\n\t \n\tvalue = lm85_read_value(client, LM85_REG_CONFIG);\n\tif (!(value & 0x01)) {\n\t\tdev_info(&client->dev, \"Starting monitoring\\n\");\n\t\tlm85_write_value(client, LM85_REG_CONFIG, value | 0x01);\n\t}\n\n\t \n\tif (value & 0x02)\n\t\tdev_warn(&client->dev, \"Device configuration is locked\\n\");\n\tif (!(value & 0x04))\n\t\tdev_warn(&client->dev, \"Device is not ready\\n\");\n}\n\nstatic int lm85_is_fake(struct i2c_client *client)\n{\n\t \n\tint i;\n\tu8 in_temp, fan;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tin_temp = i2c_smbus_read_byte_data(client, 0x20 + i);\n\t\tfan = i2c_smbus_read_byte_data(client, 0x28 + i);\n\t\tif (in_temp != 0x00 || fan != 0xff)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int lm85_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint address = client->addr;\n\tconst char *type_name = NULL;\n\tint company, verstep;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\t \n\tcompany = lm85_read_value(client, LM85_REG_COMPANY);\n\tverstep = lm85_read_value(client, LM85_REG_VERSTEP);\n\n\tdev_dbg(&adapter->dev,\n\t\t\"Detecting device at 0x%02x with COMPANY: 0x%02x and VERSTEP: 0x%02x\\n\",\n\t\taddress, company, verstep);\n\n\tif (company == LM85_COMPANY_NATIONAL) {\n\t\tswitch (verstep) {\n\t\tcase LM85_VERSTEP_LM85C:\n\t\t\ttype_name = \"lm85c\";\n\t\t\tbreak;\n\t\tcase LM85_VERSTEP_LM85B:\n\t\t\ttype_name = \"lm85b\";\n\t\t\tbreak;\n\t\tcase LM85_VERSTEP_LM96000_1:\n\t\tcase LM85_VERSTEP_LM96000_2:\n\t\t\t \n\t\t\tif (lm85_is_fake(client)) {\n\t\t\t\tdev_dbg(&adapter->dev,\n\t\t\t\t\t\"Found Winbond WPCD377I, ignoring\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\ttype_name = \"lm96000\";\n\t\t\tbreak;\n\t\t}\n\t} else if (company == LM85_COMPANY_ANALOG_DEV) {\n\t\tswitch (verstep) {\n\t\tcase LM85_VERSTEP_ADM1027:\n\t\t\ttype_name = \"adm1027\";\n\t\t\tbreak;\n\t\tcase LM85_VERSTEP_ADT7463:\n\t\tcase LM85_VERSTEP_ADT7463C:\n\t\t\ttype_name = \"adt7463\";\n\t\t\tbreak;\n\t\tcase LM85_VERSTEP_ADT7468_1:\n\t\tcase LM85_VERSTEP_ADT7468_2:\n\t\t\ttype_name = \"adt7468\";\n\t\t\tbreak;\n\t\t}\n\t} else if (company == LM85_COMPANY_SMSC) {\n\t\tswitch (verstep) {\n\t\tcase LM85_VERSTEP_EMC6D100_A0:\n\t\tcase LM85_VERSTEP_EMC6D100_A1:\n\t\t\t \n\t\t\ttype_name = \"emc6d100\";\n\t\t\tbreak;\n\t\tcase LM85_VERSTEP_EMC6D102:\n\t\t\ttype_name = \"emc6d102\";\n\t\t\tbreak;\n\t\tcase LM85_VERSTEP_EMC6D103_A0:\n\t\tcase LM85_VERSTEP_EMC6D103_A1:\n\t\t\ttype_name = \"emc6d103\";\n\t\t\tbreak;\n\t\tcase LM85_VERSTEP_EMC6D103S:\n\t\t\ttype_name = \"emc6d103s\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!type_name)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, type_name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id lm85_id[];\n\nstatic int lm85_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct lm85_data *data;\n\tint idx = 0;\n\n\tdata = devm_kzalloc(dev, sizeof(struct lm85_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tif (client->dev.of_node)\n\t\tdata->type = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\tdata->type = i2c_match_id(lm85_id, client)->driver_data;\n\tmutex_init(&data->update_lock);\n\n\t \n\tswitch (data->type) {\n\tcase adm1027:\n\tcase adt7463:\n\tcase adt7468:\n\tcase emc6d100:\n\tcase emc6d102:\n\tcase emc6d103:\n\tcase emc6d103s:\n\t\tdata->freq_map = adm1027_freq_map;\n\t\tdata->freq_map_size = ARRAY_SIZE(adm1027_freq_map);\n\t\tbreak;\n\tcase lm96000:\n\t\tdata->freq_map = lm96000_freq_map;\n\t\tdata->freq_map_size = ARRAY_SIZE(lm96000_freq_map);\n\t\tbreak;\n\tdefault:\n\t\tdata->freq_map = lm85_freq_map;\n\t\tdata->freq_map_size = ARRAY_SIZE(lm85_freq_map);\n\t}\n\n\t \n\tdata->vrm = vid_which_vrm();\n\n\t \n\tlm85_init_client(client);\n\n\t \n\tdata->groups[idx++] = &lm85_group;\n\n\t \n\tif (data->type != emc6d103s) {\n\t\tdata->groups[idx++] = &lm85_group_minctl;\n\t\tdata->groups[idx++] = &lm85_group_temp_off;\n\t}\n\n\t \n\tif (data->type == adt7463 || data->type == adt7468) {\n\t\tu8 vid = lm85_read_value(client, LM85_REG_VID);\n\t\tif (vid & 0x80)\n\t\t\tdata->has_vid5 = true;\n\t}\n\n\tif (!data->has_vid5)\n\t\tdata->groups[idx++] = &lm85_group_in4;\n\n\t \n\tif (data->type == emc6d100)\n\t\tdata->groups[idx++] = &lm85_group_in567;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, data->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id lm85_id[] = {\n\t{ \"adm1027\", adm1027 },\n\t{ \"adt7463\", adt7463 },\n\t{ \"adt7468\", adt7468 },\n\t{ \"lm85\", lm85 },\n\t{ \"lm85b\", lm85 },\n\t{ \"lm85c\", lm85 },\n\t{ \"lm96000\", lm96000 },\n\t{ \"emc6d100\", emc6d100 },\n\t{ \"emc6d101\", emc6d100 },\n\t{ \"emc6d102\", emc6d102 },\n\t{ \"emc6d103\", emc6d103 },\n\t{ \"emc6d103s\", emc6d103s },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm85_id);\n\nstatic const struct of_device_id __maybe_unused lm85_of_match[] = {\n\t{\n\t\t.compatible = \"adi,adm1027\",\n\t\t.data = (void *)adm1027\n\t},\n\t{\n\t\t.compatible = \"adi,adt7463\",\n\t\t.data = (void *)adt7463\n\t},\n\t{\n\t\t.compatible = \"adi,adt7468\",\n\t\t.data = (void *)adt7468\n\t},\n\t{\n\t\t.compatible = \"national,lm85\",\n\t\t.data = (void *)lm85\n\t},\n\t{\n\t\t.compatible = \"national,lm85b\",\n\t\t.data = (void *)lm85\n\t},\n\t{\n\t\t.compatible = \"national,lm85c\",\n\t\t.data = (void *)lm85\n\t},\n\t{\n\t\t.compatible = \"ti,lm96000\",\n\t\t.data = (void *)lm96000\n\t},\n\t{\n\t\t.compatible = \"smsc,emc6d100\",\n\t\t.data = (void *)emc6d100\n\t},\n\t{\n\t\t.compatible = \"smsc,emc6d101\",\n\t\t.data = (void *)emc6d100\n\t},\n\t{\n\t\t.compatible = \"smsc,emc6d102\",\n\t\t.data = (void *)emc6d102\n\t},\n\t{\n\t\t.compatible = \"smsc,emc6d103\",\n\t\t.data = (void *)emc6d103\n\t},\n\t{\n\t\t.compatible = \"smsc,emc6d103s\",\n\t\t.data = (void *)emc6d103s\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, lm85_of_match);\n\nstatic struct i2c_driver lm85_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name   = \"lm85\",\n\t\t.of_match_table = of_match_ptr(lm85_of_match),\n\t},\n\t.probe\t\t= lm85_probe,\n\t.id_table\t= lm85_id,\n\t.detect\t\t= lm85_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(lm85_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Philip Pokorny <ppokorny@penguincomputing.com>, \"\n\t\"Margit Schubert-While <margitsw@t-online.de>, \"\n\t\"Justin Thiessen <jthiessen@penguincomputing.com>\");\nMODULE_DESCRIPTION(\"LM85-B, LM85-C driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}