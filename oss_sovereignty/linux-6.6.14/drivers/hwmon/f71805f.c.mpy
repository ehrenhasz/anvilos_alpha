{
  "module_name": "f71805f.c",
  "hash_id": "76a730dfbc171ef056f432add91b9c7cd5ed0a8ccc8cf94e15c1c72deab79baa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/f71805f.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/ioport.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\nstatic unsigned short force_id;\nmodule_param(force_id, ushort, 0);\nMODULE_PARM_DESC(force_id, \"Override the detected device ID\");\n\nstatic struct platform_device *pdev;\n\n#define DRVNAME \"f71805f\"\nenum kinds { f71805f, f71872f };\n\n \n\n#define F71805F_LD_HWM\t\t0x04\n\n#define SIO_REG_LDSEL\t\t0x07\t \n#define SIO_REG_DEVID\t\t0x20\t \n#define SIO_REG_DEVREV\t\t0x22\t \n#define SIO_REG_MANID\t\t0x23\t \n#define SIO_REG_FNSEL1\t\t0x29\t \n#define SIO_REG_ENABLE\t\t0x30\t \n#define SIO_REG_ADDR\t\t0x60\t \n\n#define SIO_FINTEK_ID\t\t0x1934\n#define SIO_F71805F_ID\t\t0x0406\n#define SIO_F71872F_ID\t\t0x0341\n\nstatic inline int\nsuperio_inb(int base, int reg)\n{\n\toutb(reg, base);\n\treturn inb(base + 1);\n}\n\nstatic int\nsuperio_inw(int base, int reg)\n{\n\tint val;\n\toutb(reg++, base);\n\tval = inb(base + 1) << 8;\n\toutb(reg, base);\n\tval |= inb(base + 1);\n\treturn val;\n}\n\nstatic inline void\nsuperio_select(int base, int ld)\n{\n\toutb(SIO_REG_LDSEL, base);\n\toutb(ld, base + 1);\n}\n\nstatic inline int\nsuperio_enter(int base)\n{\n\tif (!request_muxed_region(base, 2, DRVNAME))\n\t\treturn -EBUSY;\n\n\toutb(0x87, base);\n\toutb(0x87, base);\n\n\treturn 0;\n}\n\nstatic inline void\nsuperio_exit(int base)\n{\n\toutb(0xaa, base);\n\trelease_region(base, 2);\n}\n\n \n\n#define REGION_LENGTH\t\t8\n#define ADDR_REG_OFFSET\t\t5\n#define DATA_REG_OFFSET\t\t6\n\n \n\n \n#define F71805F_REG_IN(nr)\t\t(0x10 + (nr))\n#define F71805F_REG_IN_HIGH(nr)\t\t((nr) < 10 ? 0x40 + 2 * (nr) : 0x2E)\n#define F71805F_REG_IN_LOW(nr)\t\t((nr) < 10 ? 0x41 + 2 * (nr) : 0x2F)\n \n#define F71805F_REG_FAN(nr)\t\t(0x20 + 2 * (nr))\n#define F71805F_REG_FAN_LOW(nr)\t\t(0x28 + 2 * (nr))\n#define F71805F_REG_FAN_TARGET(nr)\t(0x69 + 16 * (nr))\n#define F71805F_REG_FAN_CTRL(nr)\t(0x60 + 16 * (nr))\n#define F71805F_REG_PWM_FREQ(nr)\t(0x63 + 16 * (nr))\n#define F71805F_REG_PWM_DUTY(nr)\t(0x6B + 16 * (nr))\n \n#define F71805F_REG_TEMP(nr)\t\t(0x1B + (nr))\n#define F71805F_REG_TEMP_HIGH(nr)\t(0x54 + 2 * (nr))\n#define F71805F_REG_TEMP_HYST(nr)\t(0x55 + 2 * (nr))\n#define F71805F_REG_TEMP_MODE\t\t0x01\n \n \n#define F71805F_REG_PWM_AUTO_POINT_TEMP(pwmnr, apnr) \\\n\t\t\t\t\t(0xA0 + 0x10 * (pwmnr) + (2 - (apnr)))\n#define F71805F_REG_PWM_AUTO_POINT_FAN(pwmnr, apnr) \\\n\t\t\t\t\t(0xA4 + 0x10 * (pwmnr) + \\\n\t\t\t\t\t\t2 * (2 - (apnr)))\n\n#define F71805F_REG_START\t\t0x00\n \n#define F71805F_REG_STATUS(nr)\t\t(0x36 + (nr))\n\n \n#define FAN_CTRL_DC_MODE\t\t0x10\n#define FAN_CTRL_LATCH_FULL\t\t0x08\n#define FAN_CTRL_MODE_MASK\t\t0x03\n#define FAN_CTRL_MODE_SPEED\t\t0x00\n#define FAN_CTRL_MODE_TEMPERATURE\t0x01\n#define FAN_CTRL_MODE_MANUAL\t\t0x02\n\n \n\nstruct f71805f_auto_point {\n\tu8 temp[3];\n\tu16 fan[3];\n};\n\nstruct f71805f_data {\n\tunsigned short addr;\n\tconst char *name;\n\tstruct device *hwmon_dev;\n\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\tunsigned long last_limits;\t \n\n\t \n\tu8 in[11];\n\tu8 in_high[11];\n\tu8 in_low[11];\n\tu16 has_in;\n\tu16 fan[3];\n\tu16 fan_low[3];\n\tu16 fan_target[3];\n\tu8 fan_ctrl[3];\n\tu8 pwm[3];\n\tu8 pwm_freq[3];\n\tu8 temp[3];\n\tu8 temp_high[3];\n\tu8 temp_hyst[3];\n\tu8 temp_mode;\n\tunsigned long alarms;\n\tstruct f71805f_auto_point auto_points[3];\n};\n\nstruct f71805f_sio_data {\n\tenum kinds kind;\n\tu8 fnsel1;\n};\n\nstatic inline long in_from_reg(u8 reg)\n{\n\treturn reg * 8;\n}\n\n \nstatic inline u8 in_to_reg(long val)\n{\n\tif (val <= 0)\n\t\treturn 0;\n\tif (val >= 2016)\n\t\treturn 0xfc;\n\treturn ((val + 16) / 32) << 2;\n}\n\n \nstatic inline long in0_from_reg(u8 reg)\n{\n\treturn reg * 16;\n}\n\nstatic inline u8 in0_to_reg(long val)\n{\n\tif (val <= 0)\n\t\treturn 0;\n\tif (val >= 4032)\n\t\treturn 0xfc;\n\treturn ((val + 32) / 64) << 2;\n}\n\n \nstatic inline long fan_from_reg(u16 reg)\n{\n\treg &= 0xfff;\n\tif (!reg || reg == 0xfff)\n\t\treturn 0;\n\treturn 1500000 / reg;\n}\n\nstatic inline u16 fan_to_reg(long rpm)\n{\n\t \n\tif (rpm < 367)\n\t\treturn 0xfff;\n\treturn 1500000 / rpm;\n}\n\nstatic inline unsigned long pwm_freq_from_reg(u8 reg)\n{\n\tunsigned long clock = (reg & 0x80) ? 48000000UL : 1000000UL;\n\n\treg &= 0x7f;\n\tif (reg == 0)\n\t\treg++;\n\treturn clock / (reg << 8);\n}\n\nstatic inline u8 pwm_freq_to_reg(unsigned long val)\n{\n\tif (val >= 187500)\t \n\t\treturn 0x80;\n\tif (val >= 1475)\t \n\t\treturn 0x80 | (48000000UL / (val << 8));\n\tif (val < 31)\t\t \n\t\treturn 0x7f;\n\telse\t\t\t \n\t\treturn 1000000UL / (val << 8);\n}\n\nstatic inline int pwm_mode_from_reg(u8 reg)\n{\n\treturn !(reg & FAN_CTRL_DC_MODE);\n}\n\nstatic inline long temp_from_reg(u8 reg)\n{\n\treturn reg * 1000;\n}\n\nstatic inline u8 temp_to_reg(long val)\n{\n\tif (val <= 0)\n\t\treturn 0;\n\tif (val >= 1000 * 0xff)\n\t\treturn 0xff;\n\treturn (val + 500) / 1000;\n}\n\n \n\n \nstatic u8 f71805f_read8(struct f71805f_data *data, u8 reg)\n{\n\toutb(reg, data->addr + ADDR_REG_OFFSET);\n\treturn inb(data->addr + DATA_REG_OFFSET);\n}\n\n \nstatic void f71805f_write8(struct f71805f_data *data, u8 reg, u8 val)\n{\n\toutb(reg, data->addr + ADDR_REG_OFFSET);\n\toutb(val, data->addr + DATA_REG_OFFSET);\n}\n\n \nstatic u16 f71805f_read16(struct f71805f_data *data, u8 reg)\n{\n\tu16 val;\n\n\toutb(reg, data->addr + ADDR_REG_OFFSET);\n\tval = inb(data->addr + DATA_REG_OFFSET) << 8;\n\toutb(++reg, data->addr + ADDR_REG_OFFSET);\n\tval |= inb(data->addr + DATA_REG_OFFSET);\n\n\treturn val;\n}\n\n \nstatic void f71805f_write16(struct f71805f_data *data, u8 reg, u16 val)\n{\n\toutb(reg, data->addr + ADDR_REG_OFFSET);\n\toutb(val >> 8, data->addr + DATA_REG_OFFSET);\n\toutb(++reg, data->addr + ADDR_REG_OFFSET);\n\toutb(val & 0xff, data->addr + DATA_REG_OFFSET);\n}\n\nstatic struct f71805f_data *f71805f_update_device(struct device *dev)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tint nr, apnr;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tif (time_after(jiffies, data->last_updated + 60 * HZ)\n\t || !data->valid) {\n\t\tfor (nr = 0; nr < 11; nr++) {\n\t\t\tif (!(data->has_in & (1 << nr)))\n\t\t\t\tcontinue;\n\t\t\tdata->in_high[nr] = f71805f_read8(data,\n\t\t\t\t\t    F71805F_REG_IN_HIGH(nr));\n\t\t\tdata->in_low[nr] = f71805f_read8(data,\n\t\t\t\t\t   F71805F_REG_IN_LOW(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->fan_low[nr] = f71805f_read16(data,\n\t\t\t\t\t    F71805F_REG_FAN_LOW(nr));\n\t\t\tdata->fan_target[nr] = f71805f_read16(data,\n\t\t\t\t\t       F71805F_REG_FAN_TARGET(nr));\n\t\t\tdata->pwm_freq[nr] = f71805f_read8(data,\n\t\t\t\t\t     F71805F_REG_PWM_FREQ(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->temp_high[nr] = f71805f_read8(data,\n\t\t\t\t\t      F71805F_REG_TEMP_HIGH(nr));\n\t\t\tdata->temp_hyst[nr] = f71805f_read8(data,\n\t\t\t\t\t      F71805F_REG_TEMP_HYST(nr));\n\t\t}\n\t\tdata->temp_mode = f71805f_read8(data, F71805F_REG_TEMP_MODE);\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tfor (apnr = 0; apnr < 3; apnr++) {\n\t\t\t\tdata->auto_points[nr].temp[apnr] =\n\t\t\t\t\tf71805f_read8(data,\n\t\t\t\t\tF71805F_REG_PWM_AUTO_POINT_TEMP(nr,\n\t\t\t\t\t\t\t\t\tapnr));\n\t\t\t\tdata->auto_points[nr].fan[apnr] =\n\t\t\t\t\tf71805f_read16(data,\n\t\t\t\t\tF71805F_REG_PWM_AUTO_POINT_FAN(nr,\n\t\t\t\t\t\t\t\t       apnr));\n\t\t\t}\n\t\t}\n\n\t\tdata->last_limits = jiffies;\n\t}\n\n\t \n\tif (time_after(jiffies, data->last_updated + HZ)\n\t || !data->valid) {\n\t\tfor (nr = 0; nr < 11; nr++) {\n\t\t\tif (!(data->has_in & (1 << nr)))\n\t\t\t\tcontinue;\n\t\t\tdata->in[nr] = f71805f_read8(data,\n\t\t\t\t       F71805F_REG_IN(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->fan[nr] = f71805f_read16(data,\n\t\t\t\t\tF71805F_REG_FAN(nr));\n\t\t\tdata->fan_ctrl[nr] = f71805f_read8(data,\n\t\t\t\t\t     F71805F_REG_FAN_CTRL(nr));\n\t\t\tdata->pwm[nr] = f71805f_read8(data,\n\t\t\t\t\tF71805F_REG_PWM_DUTY(nr));\n\t\t}\n\t\tfor (nr = 0; nr < 3; nr++) {\n\t\t\tdata->temp[nr] = f71805f_read8(data,\n\t\t\t\t\t F71805F_REG_TEMP(nr));\n\t\t}\n\t\tdata->alarms = f71805f_read8(data, F71805F_REG_STATUS(0))\n\t\t\t+ (f71805f_read8(data, F71805F_REG_STATUS(1)) << 8)\n\t\t\t+ (f71805f_read8(data, F71805F_REG_STATUS(2)) << 16);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \n\nstatic ssize_t show_in0(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\", in0_from_reg(data->in[nr]));\n}\n\nstatic ssize_t show_in0_max(struct device *dev, struct device_attribute\n\t\t\t    *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\", in0_from_reg(data->in_high[nr]));\n}\n\nstatic ssize_t show_in0_min(struct device *dev, struct device_attribute\n\t\t\t    *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\", in0_from_reg(data->in_low[nr]));\n}\n\nstatic ssize_t set_in0_max(struct device *dev, struct device_attribute\n\t\t\t   *devattr, const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_high[nr] = in0_to_reg(val);\n\tf71805f_write8(data, F71805F_REG_IN_HIGH(nr), data->in_high[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t set_in0_min(struct device *dev, struct device_attribute\n\t\t\t   *devattr, const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_low[nr] = in0_to_reg(val);\n\tf71805f_write8(data, F71805F_REG_IN_LOW(nr), data->in_low[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_in(struct device *dev, struct device_attribute *devattr,\n\t\t       char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\", in_from_reg(data->in[nr]));\n}\n\nstatic ssize_t show_in_max(struct device *dev, struct device_attribute\n\t\t\t   *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\", in_from_reg(data->in_high[nr]));\n}\n\nstatic ssize_t show_in_min(struct device *dev, struct device_attribute\n\t\t\t   *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\", in_from_reg(data->in_low[nr]));\n}\n\nstatic ssize_t set_in_max(struct device *dev, struct device_attribute\n\t\t\t  *devattr, const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_high[nr] = in_to_reg(val);\n\tf71805f_write8(data, F71805F_REG_IN_HIGH(nr), data->in_high[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t set_in_min(struct device *dev, struct device_attribute\n\t\t\t  *devattr, const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->in_low[nr] = in_to_reg(val);\n\tf71805f_write8(data, F71805F_REG_IN_LOW(nr), data->in_low[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\", fan_from_reg(data->fan[nr]));\n}\n\nstatic ssize_t show_fan_min(struct device *dev, struct device_attribute\n\t\t\t    *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\", fan_from_reg(data->fan_low[nr]));\n}\n\nstatic ssize_t show_fan_target(struct device *dev, struct device_attribute\n\t\t\t       *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\", fan_from_reg(data->fan_target[nr]));\n}\n\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute\n\t\t\t   *devattr, const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_low[nr] = fan_to_reg(val);\n\tf71805f_write16(data, F71805F_REG_FAN_LOW(nr), data->fan_low[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t set_fan_target(struct device *dev, struct device_attribute\n\t\t\t      *devattr, const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_target[nr] = fan_to_reg(val);\n\tf71805f_write16(data, F71805F_REG_FAN_TARGET(nr),\n\t\t\tdata->fan_target[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%d\\n\", (int)data->pwm[nr]);\n}\n\nstatic ssize_t show_pwm_enable(struct device *dev, struct device_attribute\n\t\t\t       *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\tint mode;\n\n\tswitch (data->fan_ctrl[nr] & FAN_CTRL_MODE_MASK) {\n\tcase FAN_CTRL_MODE_SPEED:\n\t\tmode = 3;\n\t\tbreak;\n\tcase FAN_CTRL_MODE_TEMPERATURE:\n\t\tmode = 2;\n\t\tbreak;\n\tdefault:  \n\t\tmode = 1;\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", mode);\n}\n\nstatic ssize_t show_pwm_freq(struct device *dev, struct device_attribute\n\t\t\t     *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%lu\\n\", pwm_freq_from_reg(data->pwm_freq[nr]));\n}\n\nstatic ssize_t show_pwm_mode(struct device *dev, struct device_attribute\n\t\t\t     *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%d\\n\", pwm_mode_from_reg(data->fan_ctrl[nr]));\n}\n\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *devattr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm[nr] = val;\n\tf71805f_write8(data, F71805F_REG_PWM_DUTY(nr), data->pwm[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic struct attribute *f71805f_attr_pwm[];\n\nstatic ssize_t set_pwm_enable(struct device *dev, struct device_attribute\n\t\t\t      *devattr, const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\tu8 reg;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val < 1 || val > 3)\n\t\treturn -EINVAL;\n\n\tif (val > 1) {  \n\t\tif (sysfs_chmod_file(&dev->kobj, f71805f_attr_pwm[nr],\n\t\t\t\t     S_IRUGO))\n\t\t\tdev_dbg(dev, \"chmod -w pwm%d failed\\n\", nr + 1);\n\t}\n\n\tmutex_lock(&data->update_lock);\n\treg = f71805f_read8(data, F71805F_REG_FAN_CTRL(nr))\n\t    & ~FAN_CTRL_MODE_MASK;\n\tswitch (val) {\n\tcase 1:\n\t\treg |= FAN_CTRL_MODE_MANUAL;\n\t\tbreak;\n\tcase 2:\n\t\treg |= FAN_CTRL_MODE_TEMPERATURE;\n\t\tbreak;\n\tcase 3:\n\t\treg |= FAN_CTRL_MODE_SPEED;\n\t\tbreak;\n\t}\n\tdata->fan_ctrl[nr] = reg;\n\tf71805f_write8(data, F71805F_REG_FAN_CTRL(nr), reg);\n\tmutex_unlock(&data->update_lock);\n\n\tif (val == 1) {  \n\t\tif (sysfs_chmod_file(&dev->kobj, f71805f_attr_pwm[nr],\n\t\t\t\t     S_IRUGO | S_IWUSR))\n\t\t\tdev_dbg(dev, \"chmod +w pwm%d failed\\n\", nr + 1);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t set_pwm_freq(struct device *dev, struct device_attribute\n\t\t\t    *devattr, const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm_freq[nr] = pwm_freq_to_reg(val);\n\tf71805f_write8(data, F71805F_REG_PWM_FREQ(nr), data->pwm_freq[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_pwm_auto_point_temp(struct device *dev,\n\t\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tint pwmnr = attr->nr;\n\tint apnr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\",\n\t\t       temp_from_reg(data->auto_points[pwmnr].temp[apnr]));\n}\n\nstatic ssize_t set_pwm_auto_point_temp(struct device *dev,\n\t\t\t\t       struct device_attribute *devattr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tint pwmnr = attr->nr;\n\tint apnr = attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->auto_points[pwmnr].temp[apnr] = temp_to_reg(val);\n\tf71805f_write8(data, F71805F_REG_PWM_AUTO_POINT_TEMP(pwmnr, apnr),\n\t\t       data->auto_points[pwmnr].temp[apnr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_pwm_auto_point_fan(struct device *dev,\n\t\t\t\t       struct device_attribute *devattr,\n\t\t\t\t       char *buf)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tint pwmnr = attr->nr;\n\tint apnr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\",\n\t\t       fan_from_reg(data->auto_points[pwmnr].fan[apnr]));\n}\n\nstatic ssize_t set_pwm_auto_point_fan(struct device *dev,\n\t\t\t\t      struct device_attribute *devattr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tint pwmnr = attr->nr;\n\tint apnr = attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->auto_points[pwmnr].fan[apnr] = fan_to_reg(val);\n\tf71805f_write16(data, F71805F_REG_PWM_AUTO_POINT_FAN(pwmnr, apnr),\n\t\t\tdata->auto_points[pwmnr].fan[apnr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\", temp_from_reg(data->temp[nr]));\n}\n\nstatic ssize_t show_temp_max(struct device *dev, struct device_attribute\n\t\t\t     *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\", temp_from_reg(data->temp_high[nr]));\n}\n\nstatic ssize_t show_temp_hyst(struct device *dev, struct device_attribute\n\t\t\t      *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\treturn sprintf(buf, \"%ld\\n\", temp_from_reg(data->temp_hyst[nr]));\n}\n\nstatic ssize_t show_temp_type(struct device *dev, struct device_attribute\n\t\t\t      *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\n\t \n\treturn sprintf(buf, \"%u\\n\", (data->temp_mode & (1 << nr)) ? 3 : 4);\n}\n\nstatic ssize_t set_temp_max(struct device *dev, struct device_attribute\n\t\t\t    *devattr, const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_high[nr] = temp_to_reg(val);\n\tf71805f_write8(data, F71805F_REG_TEMP_HIGH(nr), data->temp_high[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t set_temp_hyst(struct device *dev, struct device_attribute\n\t\t\t     *devattr, const char *buf, size_t count)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_hyst[nr] = temp_to_reg(val);\n\tf71805f_write8(data, F71805F_REG_TEMP_HYST(nr), data->temp_hyst[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t alarms_in_show(struct device *dev, struct device_attribute\n\t\t\t      *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\n\treturn sprintf(buf, \"%lu\\n\", data->alarms & 0x7ff);\n}\n\nstatic ssize_t alarms_fan_show(struct device *dev, struct device_attribute\n\t\t\t       *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\n\treturn sprintf(buf, \"%lu\\n\", (data->alarms >> 16) & 0x07);\n}\n\nstatic ssize_t alarms_temp_show(struct device *dev, struct device_attribute\n\t\t\t\t*devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\n\treturn sprintf(buf, \"%lu\\n\", (data->alarms >> 11) & 0x07);\n}\n\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute\n\t\t\t  *devattr, char *buf)\n{\n\tstruct f71805f_data *data = f71805f_update_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint bitnr = attr->index;\n\n\treturn sprintf(buf, \"%lu\\n\", (data->alarms >> bitnr) & 1);\n}\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute\n\t\t\t *devattr, char *buf)\n{\n\tstruct f71805f_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", data->name);\n}\n\nstatic SENSOR_DEVICE_ATTR(in0_input, S_IRUGO, show_in0, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(in0_max, S_IRUGO | S_IWUSR,\n\t\t\t  show_in0_max, set_in0_max, 0);\nstatic SENSOR_DEVICE_ATTR(in0_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_in0_min, set_in0_min, 0);\nstatic SENSOR_DEVICE_ATTR(in1_input, S_IRUGO, show_in, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in1_max, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_max, set_in_max, 1);\nstatic SENSOR_DEVICE_ATTR(in1_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_min, set_in_min, 1);\nstatic SENSOR_DEVICE_ATTR(in2_input, S_IRUGO, show_in, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(in2_max, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_max, set_in_max, 2);\nstatic SENSOR_DEVICE_ATTR(in2_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_min, set_in_min, 2);\nstatic SENSOR_DEVICE_ATTR(in3_input, S_IRUGO, show_in, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(in3_max, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_max, set_in_max, 3);\nstatic SENSOR_DEVICE_ATTR(in3_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_min, set_in_min, 3);\nstatic SENSOR_DEVICE_ATTR(in4_input, S_IRUGO, show_in, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(in4_max, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_max, set_in_max, 4);\nstatic SENSOR_DEVICE_ATTR(in4_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_min, set_in_min, 4);\nstatic SENSOR_DEVICE_ATTR(in5_input, S_IRUGO, show_in, NULL, 5);\nstatic SENSOR_DEVICE_ATTR(in5_max, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_max, set_in_max, 5);\nstatic SENSOR_DEVICE_ATTR(in5_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_min, set_in_min, 5);\nstatic SENSOR_DEVICE_ATTR(in6_input, S_IRUGO, show_in, NULL, 6);\nstatic SENSOR_DEVICE_ATTR(in6_max, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_max, set_in_max, 6);\nstatic SENSOR_DEVICE_ATTR(in6_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_min, set_in_min, 6);\nstatic SENSOR_DEVICE_ATTR(in7_input, S_IRUGO, show_in, NULL, 7);\nstatic SENSOR_DEVICE_ATTR(in7_max, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_max, set_in_max, 7);\nstatic SENSOR_DEVICE_ATTR(in7_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_min, set_in_min, 7);\nstatic SENSOR_DEVICE_ATTR(in8_input, S_IRUGO, show_in, NULL, 8);\nstatic SENSOR_DEVICE_ATTR(in8_max, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_max, set_in_max, 8);\nstatic SENSOR_DEVICE_ATTR(in8_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_in_min, set_in_min, 8);\nstatic SENSOR_DEVICE_ATTR(in9_input, S_IRUGO, show_in0, NULL, 9);\nstatic SENSOR_DEVICE_ATTR(in9_max, S_IRUGO | S_IWUSR,\n\t\t\t  show_in0_max, set_in0_max, 9);\nstatic SENSOR_DEVICE_ATTR(in9_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_in0_min, set_in0_min, 9);\nstatic SENSOR_DEVICE_ATTR(in10_input, S_IRUGO, show_in0, NULL, 10);\nstatic SENSOR_DEVICE_ATTR(in10_max, S_IRUGO | S_IWUSR,\n\t\t\t  show_in0_max, set_in0_max, 10);\nstatic SENSOR_DEVICE_ATTR(in10_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_in0_min, set_in0_min, 10);\n\nstatic SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO, show_fan, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(fan1_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_fan_min, set_fan_min, 0);\nstatic SENSOR_DEVICE_ATTR(fan1_target, S_IRUGO | S_IWUSR,\n\t\t\t  show_fan_target, set_fan_target, 0);\nstatic SENSOR_DEVICE_ATTR(fan2_input, S_IRUGO, show_fan, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(fan2_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_fan_min, set_fan_min, 1);\nstatic SENSOR_DEVICE_ATTR(fan2_target, S_IRUGO | S_IWUSR,\n\t\t\t  show_fan_target, set_fan_target, 1);\nstatic SENSOR_DEVICE_ATTR(fan3_input, S_IRUGO, show_fan, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(fan3_min, S_IRUGO | S_IWUSR,\n\t\t\t  show_fan_min, set_fan_min, 2);\nstatic SENSOR_DEVICE_ATTR(fan3_target, S_IRUGO | S_IWUSR,\n\t\t\t  show_fan_target, set_fan_target, 2);\n\nstatic SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(temp1_max, S_IRUGO | S_IWUSR,\n\t\t    show_temp_max, set_temp_max, 0);\nstatic SENSOR_DEVICE_ATTR(temp1_max_hyst, S_IRUGO | S_IWUSR,\n\t\t    show_temp_hyst, set_temp_hyst, 0);\nstatic SENSOR_DEVICE_ATTR(temp1_type, S_IRUGO, show_temp_type, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(temp2_input, S_IRUGO, show_temp, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(temp2_max, S_IRUGO | S_IWUSR,\n\t\t    show_temp_max, set_temp_max, 1);\nstatic SENSOR_DEVICE_ATTR(temp2_max_hyst, S_IRUGO | S_IWUSR,\n\t\t    show_temp_hyst, set_temp_hyst, 1);\nstatic SENSOR_DEVICE_ATTR(temp2_type, S_IRUGO, show_temp_type, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(temp3_input, S_IRUGO, show_temp, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(temp3_max, S_IRUGO | S_IWUSR,\n\t\t    show_temp_max, set_temp_max, 2);\nstatic SENSOR_DEVICE_ATTR(temp3_max_hyst, S_IRUGO | S_IWUSR,\n\t\t    show_temp_hyst, set_temp_hyst, 2);\nstatic SENSOR_DEVICE_ATTR(temp3_type, S_IRUGO, show_temp_type, NULL, 2);\n\n \nstatic SENSOR_DEVICE_ATTR(pwm1, S_IRUGO, show_pwm, set_pwm, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1_enable, S_IRUGO | S_IWUSR,\n\t\t\t  show_pwm_enable, set_pwm_enable, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1_freq, S_IRUGO | S_IWUSR,\n\t\t\t  show_pwm_freq, set_pwm_freq, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1_mode, S_IRUGO, show_pwm_mode, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(pwm2, S_IRUGO, show_pwm, set_pwm, 1);\nstatic SENSOR_DEVICE_ATTR(pwm2_enable, S_IRUGO | S_IWUSR,\n\t\t\t  show_pwm_enable, set_pwm_enable, 1);\nstatic SENSOR_DEVICE_ATTR(pwm2_freq, S_IRUGO | S_IWUSR,\n\t\t\t  show_pwm_freq, set_pwm_freq, 1);\nstatic SENSOR_DEVICE_ATTR(pwm2_mode, S_IRUGO, show_pwm_mode, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(pwm3, S_IRUGO, show_pwm, set_pwm, 2);\nstatic SENSOR_DEVICE_ATTR(pwm3_enable, S_IRUGO | S_IWUSR,\n\t\t\t  show_pwm_enable, set_pwm_enable, 2);\nstatic SENSOR_DEVICE_ATTR(pwm3_freq, S_IRUGO | S_IWUSR,\n\t\t\t  show_pwm_freq, set_pwm_freq, 2);\nstatic SENSOR_DEVICE_ATTR(pwm3_mode, S_IRUGO, show_pwm_mode, NULL, 2);\n\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point1_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_temp, set_pwm_auto_point_temp,\n\t\t\t    0, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point1_fan, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_fan, set_pwm_auto_point_fan,\n\t\t\t    0, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point2_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_temp, set_pwm_auto_point_temp,\n\t\t\t    0, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point2_fan, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_fan, set_pwm_auto_point_fan,\n\t\t\t    0, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point3_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_temp, set_pwm_auto_point_temp,\n\t\t\t    0, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point3_fan, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_fan, set_pwm_auto_point_fan,\n\t\t\t    0, 2);\n\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point1_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_temp, set_pwm_auto_point_temp,\n\t\t\t    1, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point1_fan, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_fan, set_pwm_auto_point_fan,\n\t\t\t    1, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point2_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_temp, set_pwm_auto_point_temp,\n\t\t\t    1, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point2_fan, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_fan, set_pwm_auto_point_fan,\n\t\t\t    1, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point3_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_temp, set_pwm_auto_point_temp,\n\t\t\t    1, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point3_fan, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_fan, set_pwm_auto_point_fan,\n\t\t\t    1, 2);\n\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point1_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_temp, set_pwm_auto_point_temp,\n\t\t\t    2, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point1_fan, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_fan, set_pwm_auto_point_fan,\n\t\t\t    2, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point2_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_temp, set_pwm_auto_point_temp,\n\t\t\t    2, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point2_fan, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_fan, set_pwm_auto_point_fan,\n\t\t\t    2, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point3_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_temp, set_pwm_auto_point_temp,\n\t\t\t    2, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point3_fan, S_IRUGO | S_IWUSR,\n\t\t\t    show_pwm_auto_point_fan, set_pwm_auto_point_fan,\n\t\t\t    2, 2);\n\nstatic SENSOR_DEVICE_ATTR(in0_alarm, S_IRUGO, show_alarm, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(in1_alarm, S_IRUGO, show_alarm, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in2_alarm, S_IRUGO, show_alarm, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(in3_alarm, S_IRUGO, show_alarm, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(in4_alarm, S_IRUGO, show_alarm, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(in5_alarm, S_IRUGO, show_alarm, NULL, 5);\nstatic SENSOR_DEVICE_ATTR(in6_alarm, S_IRUGO, show_alarm, NULL, 6);\nstatic SENSOR_DEVICE_ATTR(in7_alarm, S_IRUGO, show_alarm, NULL, 7);\nstatic SENSOR_DEVICE_ATTR(in8_alarm, S_IRUGO, show_alarm, NULL, 8);\nstatic SENSOR_DEVICE_ATTR(in9_alarm, S_IRUGO, show_alarm, NULL, 9);\nstatic SENSOR_DEVICE_ATTR(in10_alarm, S_IRUGO, show_alarm, NULL, 10);\nstatic SENSOR_DEVICE_ATTR(temp1_alarm, S_IRUGO, show_alarm, NULL, 11);\nstatic SENSOR_DEVICE_ATTR(temp2_alarm, S_IRUGO, show_alarm, NULL, 12);\nstatic SENSOR_DEVICE_ATTR(temp3_alarm, S_IRUGO, show_alarm, NULL, 13);\nstatic SENSOR_DEVICE_ATTR(fan1_alarm, S_IRUGO, show_alarm, NULL, 16);\nstatic SENSOR_DEVICE_ATTR(fan2_alarm, S_IRUGO, show_alarm, NULL, 17);\nstatic SENSOR_DEVICE_ATTR(fan3_alarm, S_IRUGO, show_alarm, NULL, 18);\nstatic DEVICE_ATTR_RO(alarms_in);\nstatic DEVICE_ATTR_RO(alarms_fan);\nstatic DEVICE_ATTR_RO(alarms_temp);\n\nstatic DEVICE_ATTR_RO(name);\n\nstatic struct attribute *f71805f_attributes[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_max.dev_attr.attr,\n\t&sensor_dev_attr_in6_min.dev_attr.attr,\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_max.dev_attr.attr,\n\t&sensor_dev_attr_in7_min.dev_attr.attr,\n\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan1_target.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_target.dev_attr.attr,\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan3_target.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_mode.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_mode.dev_attr.attr,\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_mode.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_type.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_type.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp3_type.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_fan.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_fan.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_fan.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point1_fan.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point2_fan.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point3_fan.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point1_fan.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point2_fan.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point3_fan.dev_attr.attr,\n\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in5_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in6_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in7_alarm.dev_attr.attr,\n\t&dev_attr_alarms_in.attr,\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_alarm.dev_attr.attr,\n\t&dev_attr_alarms_temp.attr,\n\t&dev_attr_alarms_fan.attr,\n\n\t&dev_attr_name.attr,\n\tNULL\n};\n\nstatic const struct attribute_group f71805f_group = {\n\t.attrs = f71805f_attributes,\n};\n\nstatic struct attribute *f71805f_attributes_optin[4][5] = {\n\t{\n\t\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_in8_input.dev_attr.attr,\n\t\t&sensor_dev_attr_in8_max.dev_attr.attr,\n\t\t&sensor_dev_attr_in8_min.dev_attr.attr,\n\t\t&sensor_dev_attr_in8_alarm.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_in9_input.dev_attr.attr,\n\t\t&sensor_dev_attr_in9_max.dev_attr.attr,\n\t\t&sensor_dev_attr_in9_min.dev_attr.attr,\n\t\t&sensor_dev_attr_in9_alarm.dev_attr.attr,\n\t\tNULL\n\t}, {\n\t\t&sensor_dev_attr_in10_input.dev_attr.attr,\n\t\t&sensor_dev_attr_in10_max.dev_attr.attr,\n\t\t&sensor_dev_attr_in10_min.dev_attr.attr,\n\t\t&sensor_dev_attr_in10_alarm.dev_attr.attr,\n\t\tNULL\n\t}\n};\n\nstatic const struct attribute_group f71805f_group_optin[4] = {\n\t{ .attrs = f71805f_attributes_optin[0] },\n\t{ .attrs = f71805f_attributes_optin[1] },\n\t{ .attrs = f71805f_attributes_optin[2] },\n\t{ .attrs = f71805f_attributes_optin[3] },\n};\n\n \nstatic struct attribute *f71805f_attributes_pwm_freq[] = {\n\t&sensor_dev_attr_pwm1_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_freq.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group f71805f_group_pwm_freq = {\n\t.attrs = f71805f_attributes_pwm_freq,\n};\n\n \nstatic struct attribute *f71805f_attr_pwm[] = {\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n};\n\n \n\nstatic void f71805f_init_device(struct f71805f_data *data)\n{\n\tu8 reg;\n\tint i;\n\n\treg = f71805f_read8(data, F71805F_REG_START);\n\tif ((reg & 0x41) != 0x01) {\n\t\tpr_debug(\"Starting monitoring operations\\n\");\n\t\tf71805f_write8(data, F71805F_REG_START, (reg | 0x01) & ~0x40);\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tdata->fan_ctrl[i] = f71805f_read8(data,\n\t\t\t\t\t\t  F71805F_REG_FAN_CTRL(i));\n\t\t \n\t\tif (data->fan_ctrl[i] & FAN_CTRL_LATCH_FULL) {\n\t\t\tdata->fan_ctrl[i] &= ~FAN_CTRL_LATCH_FULL;\n\t\t\tf71805f_write8(data, F71805F_REG_FAN_CTRL(i),\n\t\t\t\t       data->fan_ctrl[i]);\n\t\t}\n\t}\n}\n\nstatic int f71805f_probe(struct platform_device *pdev)\n{\n\tstruct f71805f_sio_data *sio_data = dev_get_platdata(&pdev->dev);\n\tstruct f71805f_data *data;\n\tstruct resource *res;\n\tint i, err;\n\n\tstatic const char * const names[] = {\n\t\t\"f71805f\",\n\t\t\"f71872f\",\n\t};\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct f71805f_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!devm_request_region(&pdev->dev, res->start + ADDR_REG_OFFSET, 2,\n\t\t\t\t DRVNAME)) {\n\t\tdev_err(&pdev->dev, \"Failed to request region 0x%lx-0x%lx\\n\",\n\t\t\t(unsigned long)(res->start + ADDR_REG_OFFSET),\n\t\t\t(unsigned long)(res->start + ADDR_REG_OFFSET + 1));\n\t\treturn -EBUSY;\n\t}\n\tdata->addr = res->start;\n\tdata->name = names[sio_data->kind];\n\tmutex_init(&data->update_lock);\n\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tswitch (sio_data->kind) {\n\tcase f71805f:\n\t\tdata->has_in = 0x1ff;\n\t\tbreak;\n\tcase f71872f:\n\t\tdata->has_in = 0x6ef;\n\t\tif (sio_data->fnsel1 & 0x01)\n\t\t\tdata->has_in |= (1 << 4);  \n\t\tif (sio_data->fnsel1 & 0x02)\n\t\t\tdata->has_in |= (1 << 8);  \n\t\tbreak;\n\t}\n\n\t \n\tf71805f_init_device(data);\n\n\t \n\terr = sysfs_create_group(&pdev->dev.kobj, &f71805f_group);\n\tif (err)\n\t\treturn err;\n\tif (data->has_in & (1 << 4)) {  \n\t\terr = sysfs_create_group(&pdev->dev.kobj,\n\t\t\t\t\t &f71805f_group_optin[0]);\n\t\tif (err)\n\t\t\tgoto exit_remove_files;\n\t}\n\tif (data->has_in & (1 << 8)) {  \n\t\terr = sysfs_create_group(&pdev->dev.kobj,\n\t\t\t\t\t &f71805f_group_optin[1]);\n\t\tif (err)\n\t\t\tgoto exit_remove_files;\n\t}\n\tif (data->has_in & (1 << 9)) {  \n\t\terr = sysfs_create_group(&pdev->dev.kobj,\n\t\t\t\t\t &f71805f_group_optin[2]);\n\t\tif (err)\n\t\t\tgoto exit_remove_files;\n\t}\n\tif (data->has_in & (1 << 10)) {  \n\t\terr = sysfs_create_group(&pdev->dev.kobj,\n\t\t\t\t\t &f71805f_group_optin[3]);\n\t\tif (err)\n\t\t\tgoto exit_remove_files;\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\t \n\t\tif (!(data->fan_ctrl[i] & FAN_CTRL_DC_MODE)) {\n\t\t\terr = sysfs_create_file(&pdev->dev.kobj,\n\t\t\t\t\t\tf71805f_attributes_pwm_freq[i]);\n\t\t\tif (err)\n\t\t\t\tgoto exit_remove_files;\n\t\t}\n\t\t \n\t\tif (data->fan_ctrl[i] & FAN_CTRL_MODE_MANUAL) {\n\t\t\terr = sysfs_chmod_file(&pdev->dev.kobj,\n\t\t\t\t\t       f71805f_attr_pwm[i],\n\t\t\t\t\t       S_IRUGO | S_IWUSR);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&pdev->dev, \"chmod +w pwm%d failed\\n\",\n\t\t\t\t\ti + 1);\n\t\t\t\tgoto exit_remove_files;\n\t\t\t}\n\t\t}\n\t}\n\n\tdata->hwmon_dev = hwmon_device_register(&pdev->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tdev_err(&pdev->dev, \"Class registration failed (%d)\\n\", err);\n\t\tgoto exit_remove_files;\n\t}\n\n\treturn 0;\n\nexit_remove_files:\n\tsysfs_remove_group(&pdev->dev.kobj, &f71805f_group);\n\tfor (i = 0; i < 4; i++)\n\t\tsysfs_remove_group(&pdev->dev.kobj, &f71805f_group_optin[i]);\n\tsysfs_remove_group(&pdev->dev.kobj, &f71805f_group_pwm_freq);\n\treturn err;\n}\n\nstatic int f71805f_remove(struct platform_device *pdev)\n{\n\tstruct f71805f_data *data = platform_get_drvdata(pdev);\n\tint i;\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tsysfs_remove_group(&pdev->dev.kobj, &f71805f_group);\n\tfor (i = 0; i < 4; i++)\n\t\tsysfs_remove_group(&pdev->dev.kobj, &f71805f_group_optin[i]);\n\tsysfs_remove_group(&pdev->dev.kobj, &f71805f_group_pwm_freq);\n\n\treturn 0;\n}\n\nstatic struct platform_driver f71805f_driver = {\n\t.driver = {\n\t\t.name\t= DRVNAME,\n\t},\n\t.probe\t\t= f71805f_probe,\n\t.remove\t\t= f71805f_remove,\n};\n\nstatic int __init f71805f_device_add(unsigned short address,\n\t\t\t\t     const struct f71805f_sio_data *sio_data)\n{\n\tstruct resource res = {\n\t\t.start\t= address,\n\t\t.end\t= address + REGION_LENGTH - 1,\n\t\t.flags\t= IORESOURCE_IO,\n\t};\n\tint err;\n\n\tpdev = platform_device_alloc(DRVNAME, address);\n\tif (!pdev) {\n\t\terr = -ENOMEM;\n\t\tpr_err(\"Device allocation failed\\n\");\n\t\tgoto exit;\n\t}\n\n\tres.name = pdev->name;\n\terr = acpi_check_resource_conflict(&res);\n\tif (err)\n\t\tgoto exit_device_put;\n\n\terr = platform_device_add_resources(pdev, &res, 1);\n\tif (err) {\n\t\tpr_err(\"Device resource addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add_data(pdev, sio_data,\n\t\t\t\t       sizeof(struct f71805f_sio_data));\n\tif (err) {\n\t\tpr_err(\"Platform data allocation failed\\n\");\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n\t\tpr_err(\"Device addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\treturn 0;\n\nexit_device_put:\n\tplatform_device_put(pdev);\nexit:\n\treturn err;\n}\n\nstatic int __init f71805f_find(int sioaddr, unsigned short *address,\n\t\t\t       struct f71805f_sio_data *sio_data)\n{\n\tint err;\n\tu16 devid;\n\n\tstatic const char * const names[] = {\n\t\t\"F71805F/FG\",\n\t\t\"F71872F/FG or F71806F/FG\",\n\t};\n\n\terr = superio_enter(sioaddr);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENODEV;\n\tdevid = superio_inw(sioaddr, SIO_REG_MANID);\n\tif (devid != SIO_FINTEK_ID)\n\t\tgoto exit;\n\n\tdevid = force_id ? force_id : superio_inw(sioaddr, SIO_REG_DEVID);\n\tswitch (devid) {\n\tcase SIO_F71805F_ID:\n\t\tsio_data->kind = f71805f;\n\t\tbreak;\n\tcase SIO_F71872F_ID:\n\t\tsio_data->kind = f71872f;\n\t\tsio_data->fnsel1 = superio_inb(sioaddr, SIO_REG_FNSEL1);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"Unsupported Fintek device, skipping\\n\");\n\t\tgoto exit;\n\t}\n\n\tsuperio_select(sioaddr, F71805F_LD_HWM);\n\tif (!(superio_inb(sioaddr, SIO_REG_ENABLE) & 0x01)) {\n\t\tpr_warn(\"Device not activated, skipping\\n\");\n\t\tgoto exit;\n\t}\n\n\t*address = superio_inw(sioaddr, SIO_REG_ADDR);\n\tif (*address == 0) {\n\t\tpr_warn(\"Base address not set, skipping\\n\");\n\t\tgoto exit;\n\t}\n\t*address &= ~(REGION_LENGTH - 1);\t \n\n\terr = 0;\n\tpr_info(\"Found %s chip at %#x, revision %u\\n\",\n\t\tnames[sio_data->kind], *address,\n\t\tsuperio_inb(sioaddr, SIO_REG_DEVREV));\n\nexit:\n\tsuperio_exit(sioaddr);\n\treturn err;\n}\n\nstatic int __init f71805f_init(void)\n{\n\tint err;\n\tunsigned short address;\n\tstruct f71805f_sio_data sio_data;\n\n\tif (f71805f_find(0x2e, &address, &sio_data)\n\t && f71805f_find(0x4e, &address, &sio_data))\n\t\treturn -ENODEV;\n\n\terr = platform_driver_register(&f71805f_driver);\n\tif (err)\n\t\tgoto exit;\n\n\t \n\terr = f71805f_device_add(address, &sio_data);\n\tif (err)\n\t\tgoto exit_driver;\n\n\treturn 0;\n\nexit_driver:\n\tplatform_driver_unregister(&f71805f_driver);\nexit:\n\treturn err;\n}\n\nstatic void __exit f71805f_exit(void)\n{\n\tplatform_device_unregister(pdev);\n\tplatform_driver_unregister(&f71805f_driver);\n}\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"F71805F/F71872F hardware monitoring driver\");\n\nmodule_init(f71805f_init);\nmodule_exit(f71805f_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}