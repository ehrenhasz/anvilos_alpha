{
  "module_name": "w83781d.c",
  "hash_id": "f456581942035406235361f37767db4e5f38183199e236f0055cb9f4b83411b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/w83781d.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-vid.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n\n#ifdef CONFIG_ISA\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#endif\n\n#include \"lm75.h\"\n\n \nstatic const unsigned short normal_i2c[] = { 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,\n\t\t\t\t\t\t0x2e, 0x2f, I2C_CLIENT_END };\n\nenum chips { w83781d, w83782d, w83783s, as99127f };\n\n \nstatic unsigned short force_subclients[4];\nmodule_param_array(force_subclients, short, NULL, 0);\nMODULE_PARM_DESC(force_subclients,\n\t\t \"List of subclient addresses: {bus, clientaddr, subclientaddr1, subclientaddr2}\");\n\nstatic bool reset;\nmodule_param(reset, bool, 0);\nMODULE_PARM_DESC(reset, \"Set to one to reset chip on load\");\n\nstatic bool init = 1;\nmodule_param(init, bool, 0);\nMODULE_PARM_DESC(init, \"Set to zero to bypass chip initialization\");\n\n \n\n \n#define W83781D_EXTENT\t\t\t8\n\n \n#define W83781D_ADDR_REG_OFFSET\t\t5\n#define W83781D_DATA_REG_OFFSET\t\t6\n\n \n \n#define W83781D_REG_IN_MAX(nr)\t\t((nr < 7) ? (0x2b + (nr) * 2) : \\\n\t\t\t\t\t\t    (0x554 + (((nr) - 7) * 2)))\n#define W83781D_REG_IN_MIN(nr)\t\t((nr < 7) ? (0x2c + (nr) * 2) : \\\n\t\t\t\t\t\t    (0x555 + (((nr) - 7) * 2)))\n#define W83781D_REG_IN(nr)\t\t((nr < 7) ? (0x20 + (nr)) : \\\n\t\t\t\t\t\t    (0x550 + (nr) - 7))\n\n \n#define W83781D_REG_FAN_MIN(nr)\t\t(0x3b + (nr))\n#define W83781D_REG_FAN(nr)\t\t(0x28 + (nr))\n\n#define W83781D_REG_BANK\t\t0x4E\n#define W83781D_REG_TEMP2_CONFIG\t0x152\n#define W83781D_REG_TEMP3_CONFIG\t0x252\n \n#define W83781D_REG_TEMP(nr)\t\t((nr == 3) ? (0x0250) : \\\n\t\t\t\t\t((nr == 2) ? (0x0150) : \\\n\t\t\t\t\t\t     (0x27)))\n#define W83781D_REG_TEMP_HYST(nr)\t((nr == 3) ? (0x253) : \\\n\t\t\t\t\t((nr == 2) ? (0x153) : \\\n\t\t\t\t\t\t     (0x3A)))\n#define W83781D_REG_TEMP_OVER(nr)\t((nr == 3) ? (0x255) : \\\n\t\t\t\t\t((nr == 2) ? (0x155) : \\\n\t\t\t\t\t\t     (0x39)))\n\n#define W83781D_REG_CONFIG\t\t0x40\n\n \n#define W83781D_REG_ALARM1\t\t0x41\n#define W83781D_REG_ALARM2\t\t0x42\n\n \n#define W83782D_REG_ALARM1\t\t0x459\n#define W83782D_REG_ALARM2\t\t0x45A\n#define W83782D_REG_ALARM3\t\t0x45B\n\n#define W83781D_REG_BEEP_CONFIG\t\t0x4D\n#define W83781D_REG_BEEP_INTS1\t\t0x56\n#define W83781D_REG_BEEP_INTS2\t\t0x57\n#define W83781D_REG_BEEP_INTS3\t\t0x453\t \n\n#define W83781D_REG_VID_FANDIV\t\t0x47\n\n#define W83781D_REG_CHIPID\t\t0x49\n#define W83781D_REG_WCHIPID\t\t0x58\n#define W83781D_REG_CHIPMAN\t\t0x4F\n#define W83781D_REG_PIN\t\t\t0x4B\n\n \n#define W83781D_REG_VBAT\t\t0x5D\n\n \nstatic const u8 W83781D_REG_PWM[] = { 0x5B, 0x5A, 0x5E, 0x5F };\n#define W83781D_REG_PWMCLK12\t\t0x5C\n#define W83781D_REG_PWMCLK34\t\t0x45C\n\n#define W83781D_REG_I2C_ADDR\t\t0x48\n#define W83781D_REG_I2C_SUBADDR\t\t0x4A\n\n \n \n#define W83781D_REG_SCFG1\t\t0x5D\nstatic const u8 BIT_SCFG1[] = { 0x02, 0x04, 0x08 };\n\n#define W83781D_REG_SCFG2\t\t0x59\nstatic const u8 BIT_SCFG2[] = { 0x10, 0x20, 0x40 };\n\n#define W83781D_DEFAULT_BETA\t\t3435\n\n \n#define IN_TO_REG(val)\t\t\tclamp_val(((val) + 8) / 16, 0, 255)\n#define IN_FROM_REG(val)\t\t((val) * 16)\n\nstatic inline u8\nFAN_TO_REG(long rpm, int div)\n{\n\tif (rpm == 0)\n\t\treturn 255;\n\trpm = clamp_val(rpm, 1, 1000000);\n\treturn clamp_val((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\n}\n\nstatic inline long\nFAN_FROM_REG(u8 val, int div)\n{\n\tif (val == 0)\n\t\treturn -1;\n\tif (val == 255)\n\t\treturn 0;\n\treturn 1350000 / (val * div);\n}\n\n#define TEMP_TO_REG(val)\t\tclamp_val((val) / 1000, -127, 128)\n#define TEMP_FROM_REG(val)\t\t((val) * 1000)\n\n#define BEEP_MASK_FROM_REG(val, type)\t((type) == as99127f ? \\\n\t\t\t\t\t (~(val)) & 0x7fff : (val) & 0xff7fff)\n#define BEEP_MASK_TO_REG(val, type)\t((type) == as99127f ? \\\n\t\t\t\t\t (~(val)) & 0x7fff : (val) & 0xff7fff)\n\n#define DIV_FROM_REG(val)\t\t(1 << (val))\n\nstatic inline u8\nDIV_TO_REG(long val, enum chips type)\n{\n\tint i;\n\tval = clamp_val(val, 1,\n\t\t\t((type == w83781d || type == as99127f) ? 8 : 128)) >> 1;\n\tfor (i = 0; i < 7; i++) {\n\t\tif (val == 0)\n\t\t\tbreak;\n\t\tval >>= 1;\n\t}\n\treturn i;\n}\n\nstruct w83781d_data {\n\tstruct i2c_client *client;\n\tstruct device *hwmon_dev;\n\tstruct mutex lock;\n\tenum chips type;\n\n\t \n\tconst char *name;\n\tint isa_addr;\n\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\n\tstruct i2c_client *lm75[2];\t \n\t \n\n\tu8 in[9];\t\t \n\tu8 in_max[9];\t\t \n\tu8 in_min[9];\t\t \n\tu8 fan[3];\t\t \n\tu8 fan_min[3];\t\t \n\ts8 temp;\t\t \n\ts8 temp_max;\t\t \n\ts8 temp_max_hyst;\t \n\tu16 temp_add[2];\t \n\tu16 temp_max_add[2];\t \n\tu16 temp_max_hyst_add[2];\t \n\tu8 fan_div[3];\t\t \n\tu8 vid;\t\t\t \n\tu32 alarms;\t\t \n\tu32 beep_mask;\t\t \n\tu8 pwm[4];\t\t \n\tu8 pwm2_enable;\t\t \n\tu16 sens[3];\t\t \n\tu8 vrm;\n};\n\nstatic struct w83781d_data *w83781d_data_if_isa(void);\nstatic int w83781d_alias_detect(struct i2c_client *client, u8 chipid);\n\nstatic int w83781d_read_value(struct w83781d_data *data, u16 reg);\nstatic int w83781d_write_value(struct w83781d_data *data, u16 reg, u16 value);\nstatic struct w83781d_data *w83781d_update_device(struct device *dev);\nstatic void w83781d_init_device(struct device *dev);\n\n \n#define show_in_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *da, \\\n\t\tchar *buf) \\\n{ \\\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da); \\\n\tstruct w83781d_data *data = w83781d_update_device(dev); \\\n\treturn sprintf(buf, \"%ld\\n\", \\\n\t\t       (long)IN_FROM_REG(data->reg[attr->index])); \\\n}\nshow_in_reg(in);\nshow_in_reg(in_min);\nshow_in_reg(in_max);\n\n#define store_in_reg(REG, reg) \\\nstatic ssize_t store_in_##reg(struct device *dev, struct device_attribute \\\n\t\t*da, const char *buf, size_t count) \\\n{ \\\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da); \\\n\tstruct w83781d_data *data = dev_get_drvdata(dev); \\\n\tint nr = attr->index; \\\n\tunsigned long val; \\\n\tint err = kstrtoul(buf, 10, &val); \\\n\tif (err) \\\n\t\treturn err; \\\n\tmutex_lock(&data->update_lock); \\\n\tdata->in_##reg[nr] = IN_TO_REG(val); \\\n\tw83781d_write_value(data, W83781D_REG_IN_##REG(nr), \\\n\t\t\t    data->in_##reg[nr]); \\\n\t\\\n\tmutex_unlock(&data->update_lock); \\\n\treturn count; \\\n}\nstore_in_reg(MIN, min);\nstore_in_reg(MAX, max);\n\n#define sysfs_in_offsets(offset) \\\nstatic SENSOR_DEVICE_ATTR(in##offset##_input, S_IRUGO, \\\n\t\tshow_in, NULL, offset); \\\nstatic SENSOR_DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR, \\\n\t\tshow_in_min, store_in_min, offset); \\\nstatic SENSOR_DEVICE_ATTR(in##offset##_max, S_IRUGO | S_IWUSR, \\\n\t\tshow_in_max, store_in_max, offset)\n\nsysfs_in_offsets(0);\nsysfs_in_offsets(1);\nsysfs_in_offsets(2);\nsysfs_in_offsets(3);\nsysfs_in_offsets(4);\nsysfs_in_offsets(5);\nsysfs_in_offsets(6);\nsysfs_in_offsets(7);\nsysfs_in_offsets(8);\n\n#define show_fan_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *da, \\\n\t\tchar *buf) \\\n{ \\\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da); \\\n\tstruct w83781d_data *data = w83781d_update_device(dev); \\\n\treturn sprintf(buf, \"%ld\\n\", \\\n\t\tFAN_FROM_REG(data->reg[attr->index], \\\n\t\t\tDIV_FROM_REG(data->fan_div[attr->index]))); \\\n}\nshow_fan_reg(fan);\nshow_fan_reg(fan_min);\n\nstatic ssize_t\nstore_fan_min(struct device *dev, struct device_attribute *da,\n\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct w83781d_data *data = dev_get_drvdata(dev);\n\tint nr = attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_min[nr] =\n\t    FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\n\tw83781d_write_value(data, W83781D_REG_FAN_MIN(nr),\n\t\t\t    data->fan_min[nr]);\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO, show_fan, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(fan1_min, S_IRUGO | S_IWUSR,\n\t\tshow_fan_min, store_fan_min, 0);\nstatic SENSOR_DEVICE_ATTR(fan2_input, S_IRUGO, show_fan, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(fan2_min, S_IRUGO | S_IWUSR,\n\t\tshow_fan_min, store_fan_min, 1);\nstatic SENSOR_DEVICE_ATTR(fan3_input, S_IRUGO, show_fan, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(fan3_min, S_IRUGO | S_IWUSR,\n\t\tshow_fan_min, store_fan_min, 2);\n\n#define show_temp_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *da, \\\n\t\tchar *buf) \\\n{ \\\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da); \\\n\tstruct w83781d_data *data = w83781d_update_device(dev); \\\n\tint nr = attr->index; \\\n\tif (nr >= 2) {\t  \\\n\t\treturn sprintf(buf, \"%d\\n\", \\\n\t\t\tLM75_TEMP_FROM_REG(data->reg##_add[nr-2])); \\\n\t} else {\t  \\\n\t\treturn sprintf(buf, \"%ld\\n\", (long)TEMP_FROM_REG(data->reg)); \\\n\t} \\\n}\nshow_temp_reg(temp);\nshow_temp_reg(temp_max);\nshow_temp_reg(temp_max_hyst);\n\n#define store_temp_reg(REG, reg) \\\nstatic ssize_t store_temp_##reg(struct device *dev, \\\n\t\tstruct device_attribute *da, const char *buf, size_t count) \\\n{ \\\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da); \\\n\tstruct w83781d_data *data = dev_get_drvdata(dev); \\\n\tint nr = attr->index; \\\n\tlong val; \\\n\tint err = kstrtol(buf, 10, &val); \\\n\tif (err) \\\n\t\treturn err; \\\n\tmutex_lock(&data->update_lock); \\\n\t \\\n\tif (nr >= 2) {\t  \\\n\t\tdata->temp_##reg##_add[nr-2] = LM75_TEMP_TO_REG(val); \\\n\t\tw83781d_write_value(data, W83781D_REG_TEMP_##REG(nr), \\\n\t\t\t\tdata->temp_##reg##_add[nr-2]); \\\n\t} else {\t  \\\n\t\tdata->temp_##reg = TEMP_TO_REG(val); \\\n\t\tw83781d_write_value(data, W83781D_REG_TEMP_##REG(nr), \\\n\t\t\tdata->temp_##reg); \\\n\t} \\\n\t \\\n\tmutex_unlock(&data->update_lock); \\\n\treturn count; \\\n}\nstore_temp_reg(OVER, max);\nstore_temp_reg(HYST, max_hyst);\n\n#define sysfs_temp_offsets(offset) \\\nstatic SENSOR_DEVICE_ATTR(temp##offset##_input, S_IRUGO, \\\n\t\tshow_temp, NULL, offset); \\\nstatic SENSOR_DEVICE_ATTR(temp##offset##_max, S_IRUGO | S_IWUSR, \\\n\t\tshow_temp_max, store_temp_max, offset); \\\nstatic SENSOR_DEVICE_ATTR(temp##offset##_max_hyst, S_IRUGO | S_IWUSR, \\\n\t\tshow_temp_max_hyst, store_temp_max_hyst, offset);\n\nsysfs_temp_offsets(1);\nsysfs_temp_offsets(2);\nsysfs_temp_offsets(3);\n\nstatic ssize_t\ncpu0_vid_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83781d_data *data = w83781d_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long) vid_from_reg(data->vid, data->vrm));\n}\n\nstatic DEVICE_ATTR_RO(cpu0_vid);\n\nstatic ssize_t\nvrm_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83781d_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%ld\\n\", (long) data->vrm);\n}\n\nstatic ssize_t\nvrm_store(struct device *dev, struct device_attribute *attr, const char *buf,\n\t  size_t count)\n{\n\tstruct w83781d_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tdata->vrm = clamp_val(val, 0, 255);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(vrm);\n\nstatic ssize_t\nalarms_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83781d_data *data = w83781d_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", data->alarms);\n}\n\nstatic DEVICE_ATTR_RO(alarms);\n\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct w83781d_data *data = w83781d_update_device(dev);\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> bitnr) & 1);\n}\n\n \nstatic ssize_t show_temp3_alarm(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w83781d_data *data = w83781d_update_device(dev);\n\tint bitnr = (data->type == w83781d) ? 5 : 13;\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> bitnr) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR(in0_alarm, S_IRUGO, show_alarm, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(in1_alarm, S_IRUGO, show_alarm, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in2_alarm, S_IRUGO, show_alarm, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(in3_alarm, S_IRUGO, show_alarm, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(in4_alarm, S_IRUGO, show_alarm, NULL, 8);\nstatic SENSOR_DEVICE_ATTR(in5_alarm, S_IRUGO, show_alarm, NULL, 9);\nstatic SENSOR_DEVICE_ATTR(in6_alarm, S_IRUGO, show_alarm, NULL, 10);\nstatic SENSOR_DEVICE_ATTR(in7_alarm, S_IRUGO, show_alarm, NULL, 16);\nstatic SENSOR_DEVICE_ATTR(in8_alarm, S_IRUGO, show_alarm, NULL, 17);\nstatic SENSOR_DEVICE_ATTR(fan1_alarm, S_IRUGO, show_alarm, NULL, 6);\nstatic SENSOR_DEVICE_ATTR(fan2_alarm, S_IRUGO, show_alarm, NULL, 7);\nstatic SENSOR_DEVICE_ATTR(fan3_alarm, S_IRUGO, show_alarm, NULL, 11);\nstatic SENSOR_DEVICE_ATTR(temp1_alarm, S_IRUGO, show_alarm, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(temp2_alarm, S_IRUGO, show_alarm, NULL, 5);\nstatic SENSOR_DEVICE_ATTR(temp3_alarm, S_IRUGO, show_temp3_alarm, NULL, 0);\n\nstatic ssize_t beep_mask_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct w83781d_data *data = w83781d_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\",\n\t\t       (long)BEEP_MASK_FROM_REG(data->beep_mask, data->type));\n}\n\nstatic ssize_t\nbeep_mask_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct w83781d_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->beep_mask &= 0x8000;  \n\tdata->beep_mask |= BEEP_MASK_TO_REG(val, data->type);\n\tw83781d_write_value(data, W83781D_REG_BEEP_INTS1,\n\t\t\t    data->beep_mask & 0xff);\n\tw83781d_write_value(data, W83781D_REG_BEEP_INTS2,\n\t\t\t    (data->beep_mask >> 8) & 0xff);\n\tif (data->type != w83781d && data->type != as99127f) {\n\t\tw83781d_write_value(data, W83781D_REG_BEEP_INTS3,\n\t\t\t\t    ((data->beep_mask) >> 16) & 0xff);\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(beep_mask);\n\nstatic ssize_t show_beep(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct w83781d_data *data = w83781d_update_device(dev);\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\treturn sprintf(buf, \"%u\\n\", (data->beep_mask >> bitnr) & 1);\n}\n\nstatic ssize_t\nstore_beep(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct w83781d_data *data = dev_get_drvdata(dev);\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tu8 reg;\n\tunsigned long bit;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &bit);\n\tif (err)\n\t\treturn err;\n\n\tif (bit & ~1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tif (bit)\n\t\tdata->beep_mask |= (1 << bitnr);\n\telse\n\t\tdata->beep_mask &= ~(1 << bitnr);\n\n\tif (bitnr < 8) {\n\t\treg = w83781d_read_value(data, W83781D_REG_BEEP_INTS1);\n\t\tif (bit)\n\t\t\treg |= (1 << bitnr);\n\t\telse\n\t\t\treg &= ~(1 << bitnr);\n\t\tw83781d_write_value(data, W83781D_REG_BEEP_INTS1, reg);\n\t} else if (bitnr < 16) {\n\t\treg = w83781d_read_value(data, W83781D_REG_BEEP_INTS2);\n\t\tif (bit)\n\t\t\treg |= (1 << (bitnr - 8));\n\t\telse\n\t\t\treg &= ~(1 << (bitnr - 8));\n\t\tw83781d_write_value(data, W83781D_REG_BEEP_INTS2, reg);\n\t} else {\n\t\treg = w83781d_read_value(data, W83781D_REG_BEEP_INTS3);\n\t\tif (bit)\n\t\t\treg |= (1 << (bitnr - 16));\n\t\telse\n\t\t\treg &= ~(1 << (bitnr - 16));\n\t\tw83781d_write_value(data, W83781D_REG_BEEP_INTS3, reg);\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \nstatic ssize_t show_temp3_beep(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w83781d_data *data = w83781d_update_device(dev);\n\tint bitnr = (data->type == w83781d) ? 5 : 13;\n\treturn sprintf(buf, \"%u\\n\", (data->beep_mask >> bitnr) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR(in0_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 0);\nstatic SENSOR_DEVICE_ATTR(in1_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 1);\nstatic SENSOR_DEVICE_ATTR(in2_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 2);\nstatic SENSOR_DEVICE_ATTR(in3_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 3);\nstatic SENSOR_DEVICE_ATTR(in4_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 8);\nstatic SENSOR_DEVICE_ATTR(in5_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 9);\nstatic SENSOR_DEVICE_ATTR(in6_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 10);\nstatic SENSOR_DEVICE_ATTR(in7_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 16);\nstatic SENSOR_DEVICE_ATTR(in8_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 17);\nstatic SENSOR_DEVICE_ATTR(fan1_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 6);\nstatic SENSOR_DEVICE_ATTR(fan2_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 7);\nstatic SENSOR_DEVICE_ATTR(fan3_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 11);\nstatic SENSOR_DEVICE_ATTR(temp1_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 4);\nstatic SENSOR_DEVICE_ATTR(temp2_beep, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 5);\nstatic SENSOR_DEVICE_ATTR(temp3_beep, S_IRUGO,\n\t\t\tshow_temp3_beep, store_beep, 13);\nstatic SENSOR_DEVICE_ATTR(beep_enable, S_IRUGO | S_IWUSR,\n\t\t\tshow_beep, store_beep, 15);\n\nstatic ssize_t\nshow_fan_div(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct w83781d_data *data = w83781d_update_device(dev);\n\treturn sprintf(buf, \"%ld\\n\",\n\t\t       (long) DIV_FROM_REG(data->fan_div[attr->index]));\n}\n\n \nstatic ssize_t\nstore_fan_div(struct device *dev, struct device_attribute *da,\n\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct w83781d_data *data = dev_get_drvdata(dev);\n\tunsigned long min;\n\tint nr = attr->index;\n\tu8 reg;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tmin = FAN_FROM_REG(data->fan_min[nr],\n\t\t\t   DIV_FROM_REG(data->fan_div[nr]));\n\n\tdata->fan_div[nr] = DIV_TO_REG(val, data->type);\n\n\treg = (w83781d_read_value(data, nr == 2 ?\n\t\t\t\t  W83781D_REG_PIN : W83781D_REG_VID_FANDIV)\n\t\t& (nr == 0 ? 0xcf : 0x3f))\n\t      | ((data->fan_div[nr] & 0x03) << (nr == 0 ? 4 : 6));\n\tw83781d_write_value(data, nr == 2 ?\n\t\t\t    W83781D_REG_PIN : W83781D_REG_VID_FANDIV, reg);\n\n\t \n\tif (data->type != w83781d && data->type != as99127f) {\n\t\treg = (w83781d_read_value(data, W83781D_REG_VBAT)\n\t\t       & ~(1 << (5 + nr)))\n\t\t    | ((data->fan_div[nr] & 0x04) << (3 + nr));\n\t\tw83781d_write_value(data, W83781D_REG_VBAT, reg);\n\t}\n\n\t \n\tdata->fan_min[nr] = FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\n\tw83781d_write_value(data, W83781D_REG_FAN_MIN(nr), data->fan_min[nr]);\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR(fan1_div, S_IRUGO | S_IWUSR,\n\t\tshow_fan_div, store_fan_div, 0);\nstatic SENSOR_DEVICE_ATTR(fan2_div, S_IRUGO | S_IWUSR,\n\t\tshow_fan_div, store_fan_div, 1);\nstatic SENSOR_DEVICE_ATTR(fan3_div, S_IRUGO | S_IWUSR,\n\t\tshow_fan_div, store_fan_div, 2);\n\nstatic ssize_t\nshow_pwm(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct w83781d_data *data = w83781d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (int)data->pwm[attr->index]);\n}\n\nstatic ssize_t\npwm2_enable_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tstruct w83781d_data *data = w83781d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (int)data->pwm2_enable);\n}\n\nstatic ssize_t\nstore_pwm(struct device *dev, struct device_attribute *da, const char *buf,\n\t\tsize_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct w83781d_data *data = dev_get_drvdata(dev);\n\tint nr = attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm[nr] = clamp_val(val, 0, 255);\n\tw83781d_write_value(data, W83781D_REG_PWM[nr], data->pwm[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\npwm2_enable_store(struct device *dev, struct device_attribute *da,\n\t\tconst char *buf, size_t count)\n{\n\tstruct w83781d_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tu32 reg;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\t\treg = w83781d_read_value(data, W83781D_REG_PWMCLK12);\n\t\tw83781d_write_value(data, W83781D_REG_PWMCLK12,\n\t\t\t\t    (reg & 0xf7) | (val << 3));\n\n\t\treg = w83781d_read_value(data, W83781D_REG_BEEP_CONFIG);\n\t\tw83781d_write_value(data, W83781D_REG_BEEP_CONFIG,\n\t\t\t\t    (reg & 0xef) | (!val << 4));\n\n\t\tdata->pwm2_enable = val;\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_unlock(&data->update_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR(pwm1, S_IRUGO | S_IWUSR, show_pwm, store_pwm, 0);\nstatic SENSOR_DEVICE_ATTR(pwm2, S_IRUGO | S_IWUSR, show_pwm, store_pwm, 1);\nstatic SENSOR_DEVICE_ATTR(pwm3, S_IRUGO | S_IWUSR, show_pwm, store_pwm, 2);\nstatic SENSOR_DEVICE_ATTR(pwm4, S_IRUGO | S_IWUSR, show_pwm, store_pwm, 3);\n \nstatic DEVICE_ATTR_RW(pwm2_enable);\n\nstatic ssize_t\nshow_sensor(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct w83781d_data *data = w83781d_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (int)data->sens[attr->index]);\n}\n\nstatic ssize_t\nstore_sensor(struct device *dev, struct device_attribute *da,\n\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct w83781d_data *data = dev_get_drvdata(dev);\n\tint nr = attr->index;\n\tunsigned long val;\n\tu32 tmp;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (val) {\n\tcase 1:\t\t \n\t\ttmp = w83781d_read_value(data, W83781D_REG_SCFG1);\n\t\tw83781d_write_value(data, W83781D_REG_SCFG1,\n\t\t\t\t    tmp | BIT_SCFG1[nr]);\n\t\ttmp = w83781d_read_value(data, W83781D_REG_SCFG2);\n\t\tw83781d_write_value(data, W83781D_REG_SCFG2,\n\t\t\t\t    tmp | BIT_SCFG2[nr]);\n\t\tdata->sens[nr] = val;\n\t\tbreak;\n\tcase 2:\t\t \n\t\ttmp = w83781d_read_value(data, W83781D_REG_SCFG1);\n\t\tw83781d_write_value(data, W83781D_REG_SCFG1,\n\t\t\t\t    tmp | BIT_SCFG1[nr]);\n\t\ttmp = w83781d_read_value(data, W83781D_REG_SCFG2);\n\t\tw83781d_write_value(data, W83781D_REG_SCFG2,\n\t\t\t\t    tmp & ~BIT_SCFG2[nr]);\n\t\tdata->sens[nr] = val;\n\t\tbreak;\n\tcase W83781D_DEFAULT_BETA:\n\t\tdev_warn(dev,\n\t\t\t \"Sensor type %d is deprecated, please use 4 instead\\n\",\n\t\t\t W83781D_DEFAULT_BETA);\n\t\tfallthrough;\n\tcase 4:\t\t \n\t\ttmp = w83781d_read_value(data, W83781D_REG_SCFG1);\n\t\tw83781d_write_value(data, W83781D_REG_SCFG1,\n\t\t\t\t    tmp & ~BIT_SCFG1[nr]);\n\t\tdata->sens[nr] = val;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid sensor type %ld; must be 1, 2, or 4\\n\",\n\t\t       (long) val);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR(temp1_type, S_IRUGO | S_IWUSR,\n\tshow_sensor, store_sensor, 0);\nstatic SENSOR_DEVICE_ATTR(temp2_type, S_IRUGO | S_IWUSR,\n\tshow_sensor, store_sensor, 1);\nstatic SENSOR_DEVICE_ATTR(temp3_type, S_IRUGO | S_IWUSR,\n\tshow_sensor, store_sensor, 2);\n\n \nstatic int\nw83781d_detect_subclients(struct i2c_client *new_client)\n{\n\tint i, val1 = 0, id;\n\tint err;\n\tint address = new_client->addr;\n\tunsigned short sc_addr[2];\n\tstruct i2c_adapter *adapter = new_client->adapter;\n\tstruct w83781d_data *data = i2c_get_clientdata(new_client);\n\tenum chips kind = data->type;\n\tint num_sc = 1;\n\n\tid = i2c_adapter_id(adapter);\n\n\tif (force_subclients[0] == id && force_subclients[1] == address) {\n\t\tfor (i = 2; i <= 3; i++) {\n\t\t\tif (force_subclients[i] < 0x48 ||\n\t\t\t    force_subclients[i] > 0x4f) {\n\t\t\t\tdev_err(&new_client->dev,\n\t\t\t\t\t\"Invalid subclient address %d; must be 0x48-0x4f\\n\",\n\t\t\t\t\tforce_subclients[i]);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto ERROR_SC_1;\n\t\t\t}\n\t\t}\n\t\tw83781d_write_value(data, W83781D_REG_I2C_SUBADDR,\n\t\t\t\t(force_subclients[2] & 0x07) |\n\t\t\t\t((force_subclients[3] & 0x07) << 4));\n\t\tsc_addr[0] = force_subclients[2];\n\t} else {\n\t\tval1 = w83781d_read_value(data, W83781D_REG_I2C_SUBADDR);\n\t\tsc_addr[0] = 0x48 + (val1 & 0x07);\n\t}\n\n\tif (kind != w83783s) {\n\t\tnum_sc = 2;\n\t\tif (force_subclients[0] == id &&\n\t\t    force_subclients[1] == address) {\n\t\t\tsc_addr[1] = force_subclients[3];\n\t\t} else {\n\t\t\tsc_addr[1] = 0x48 + ((val1 >> 4) & 0x07);\n\t\t}\n\t\tif (sc_addr[0] == sc_addr[1]) {\n\t\t\tdev_err(&new_client->dev,\n\t\t\t       \"Duplicate addresses 0x%x for subclients.\\n\",\n\t\t\t       sc_addr[0]);\n\t\t\terr = -EBUSY;\n\t\t\tgoto ERROR_SC_2;\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_sc; i++) {\n\t\tdata->lm75[i] = i2c_new_dummy_device(adapter, sc_addr[i]);\n\t\tif (IS_ERR(data->lm75[i])) {\n\t\t\tdev_err(&new_client->dev,\n\t\t\t\t\"Subclient %d registration at address 0x%x failed.\\n\",\n\t\t\t\ti, sc_addr[i]);\n\t\t\terr = PTR_ERR(data->lm75[i]);\n\t\t\tif (i == 1)\n\t\t\t\tgoto ERROR_SC_3;\n\t\t\tgoto ERROR_SC_2;\n\t\t}\n\t}\n\n\treturn 0;\n\n \nERROR_SC_3:\n\ti2c_unregister_device(data->lm75[0]);\nERROR_SC_2:\nERROR_SC_1:\n\treturn err;\n}\n\n#define IN_UNIT_ATTRS(X)\t\t\t\t\t\\\n\t&sensor_dev_attr_in##X##_input.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_in##X##_min.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_in##X##_max.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_in##X##_alarm.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_in##X##_beep.dev_attr.attr\n\n#define FAN_UNIT_ATTRS(X)\t\t\t\t\t\\\n\t&sensor_dev_attr_fan##X##_input.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_fan##X##_min.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_fan##X##_div.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_fan##X##_alarm.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_fan##X##_beep.dev_attr.attr\n\n#define TEMP_UNIT_ATTRS(X)\t\t\t\t\t\\\n\t&sensor_dev_attr_temp##X##_input.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_temp##X##_max.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_temp##X##_max_hyst.dev_attr.attr,\t\\\n\t&sensor_dev_attr_temp##X##_alarm.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_temp##X##_beep.dev_attr.attr\n\nstatic struct attribute *w83781d_attributes[] = {\n\tIN_UNIT_ATTRS(0),\n\tIN_UNIT_ATTRS(2),\n\tIN_UNIT_ATTRS(3),\n\tIN_UNIT_ATTRS(4),\n\tIN_UNIT_ATTRS(5),\n\tIN_UNIT_ATTRS(6),\n\tFAN_UNIT_ATTRS(1),\n\tFAN_UNIT_ATTRS(2),\n\tFAN_UNIT_ATTRS(3),\n\tTEMP_UNIT_ATTRS(1),\n\tTEMP_UNIT_ATTRS(2),\n\t&dev_attr_cpu0_vid.attr,\n\t&dev_attr_vrm.attr,\n\t&dev_attr_alarms.attr,\n\t&dev_attr_beep_mask.attr,\n\t&sensor_dev_attr_beep_enable.dev_attr.attr,\n\tNULL\n};\nstatic const struct attribute_group w83781d_group = {\n\t.attrs = w83781d_attributes,\n};\n\nstatic struct attribute *w83781d_attributes_in1[] = {\n\tIN_UNIT_ATTRS(1),\n\tNULL\n};\nstatic const struct attribute_group w83781d_group_in1 = {\n\t.attrs = w83781d_attributes_in1,\n};\n\nstatic struct attribute *w83781d_attributes_in78[] = {\n\tIN_UNIT_ATTRS(7),\n\tIN_UNIT_ATTRS(8),\n\tNULL\n};\nstatic const struct attribute_group w83781d_group_in78 = {\n\t.attrs = w83781d_attributes_in78,\n};\n\nstatic struct attribute *w83781d_attributes_temp3[] = {\n\tTEMP_UNIT_ATTRS(3),\n\tNULL\n};\nstatic const struct attribute_group w83781d_group_temp3 = {\n\t.attrs = w83781d_attributes_temp3,\n};\n\nstatic struct attribute *w83781d_attributes_pwm12[] = {\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&dev_attr_pwm2_enable.attr,\n\tNULL\n};\nstatic const struct attribute_group w83781d_group_pwm12 = {\n\t.attrs = w83781d_attributes_pwm12,\n};\n\nstatic struct attribute *w83781d_attributes_pwm34[] = {\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\t&sensor_dev_attr_pwm4.dev_attr.attr,\n\tNULL\n};\nstatic const struct attribute_group w83781d_group_pwm34 = {\n\t.attrs = w83781d_attributes_pwm34,\n};\n\nstatic struct attribute *w83781d_attributes_other[] = {\n\t&sensor_dev_attr_temp1_type.dev_attr.attr,\n\t&sensor_dev_attr_temp2_type.dev_attr.attr,\n\t&sensor_dev_attr_temp3_type.dev_attr.attr,\n\tNULL\n};\nstatic const struct attribute_group w83781d_group_other = {\n\t.attrs = w83781d_attributes_other,\n};\n\n \nstatic int\nw83781d_create_files(struct device *dev, int kind, int is_isa)\n{\n\tint err;\n\n\terr = sysfs_create_group(&dev->kobj, &w83781d_group);\n\tif (err)\n\t\treturn err;\n\n\tif (kind != w83783s) {\n\t\terr = sysfs_create_group(&dev->kobj, &w83781d_group_in1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (kind != as99127f && kind != w83781d && kind != w83783s) {\n\t\terr = sysfs_create_group(&dev->kobj, &w83781d_group_in78);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (kind != w83783s) {\n\t\terr = sysfs_create_group(&dev->kobj, &w83781d_group_temp3);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (kind != w83781d) {\n\t\t\terr = sysfs_chmod_file(&dev->kobj,\n\t\t\t\t&sensor_dev_attr_temp3_alarm.dev_attr.attr,\n\t\t\t\tS_IRUGO | S_IWUSR);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (kind != w83781d && kind != as99127f) {\n\t\terr = sysfs_create_group(&dev->kobj, &w83781d_group_pwm12);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (kind == w83782d && !is_isa) {\n\t\terr = sysfs_create_group(&dev->kobj, &w83781d_group_pwm34);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (kind != as99127f && kind != w83781d) {\n\t\terr = device_create_file(dev,\n\t\t\t\t\t &sensor_dev_attr_temp1_type.dev_attr);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = device_create_file(dev,\n\t\t\t\t\t &sensor_dev_attr_temp2_type.dev_attr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (kind != w83783s) {\n\t\t\terr = device_create_file(dev,\n\t\t\t\t\t&sensor_dev_attr_temp3_type.dev_attr);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nw83781d_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tint val1, val2;\n\tstruct w83781d_data *isa = w83781d_data_if_isa();\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint address = client->addr;\n\tconst char *client_name;\n\tenum vendor { winbond, asus } vendid;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tif (isa)\n\t\tmutex_lock(&isa->update_lock);\n\n\tif (i2c_smbus_read_byte_data(client, W83781D_REG_CONFIG) & 0x80) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"Detection of w83781d chip failed at step 3\\n\");\n\t\tgoto err_nodev;\n\t}\n\n\tval1 = i2c_smbus_read_byte_data(client, W83781D_REG_BANK);\n\tval2 = i2c_smbus_read_byte_data(client, W83781D_REG_CHIPMAN);\n\t \n\tif (!(val1 & 0x07) &&\n\t    ((!(val1 & 0x80) && val2 != 0xa3 && val2 != 0xc3) ||\n\t     ((val1 & 0x80) && val2 != 0x5c && val2 != 0x12))) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"Detection of w83781d chip failed at step 4\\n\");\n\t\tgoto err_nodev;\n\t}\n\t \n\tif ((!(val1 & 0x80) && val2 == 0xa3) ||\n\t    ((val1 & 0x80) && val2 == 0x5c)) {\n\t\tif (i2c_smbus_read_byte_data(client, W83781D_REG_I2C_ADDR)\n\t\t    != address) {\n\t\t\tdev_dbg(&adapter->dev,\n\t\t\t\t\"Detection of w83781d chip failed at step 5\\n\");\n\t\t\tgoto err_nodev;\n\t\t}\n\t}\n\n\t \n\ti2c_smbus_write_byte_data(client, W83781D_REG_BANK,\n\t\t(i2c_smbus_read_byte_data(client, W83781D_REG_BANK)\n\t\t & 0x78) | 0x80);\n\n\t \n\tval2 = i2c_smbus_read_byte_data(client, W83781D_REG_CHIPMAN);\n\tif (val2 == 0x5c)\n\t\tvendid = winbond;\n\telse if (val2 == 0x12)\n\t\tvendid = asus;\n\telse {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"w83781d chip vendor is neither Winbond nor Asus\\n\");\n\t\tgoto err_nodev;\n\t}\n\n\t \n\tval1 = i2c_smbus_read_byte_data(client, W83781D_REG_WCHIPID);\n\tif ((val1 == 0x10 || val1 == 0x11) && vendid == winbond)\n\t\tclient_name = \"w83781d\";\n\telse if (val1 == 0x30 && vendid == winbond)\n\t\tclient_name = \"w83782d\";\n\telse if (val1 == 0x40 && vendid == winbond && address == 0x2d)\n\t\tclient_name = \"w83783s\";\n\telse if (val1 == 0x31)\n\t\tclient_name = \"as99127f\";\n\telse\n\t\tgoto err_nodev;\n\n\tif (val1 <= 0x30 && w83781d_alias_detect(client, val1)) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"Device at 0x%02x appears to be the same as ISA device\\n\",\n\t\t\taddress);\n\t\tgoto err_nodev;\n\t}\n\n\tif (isa)\n\t\tmutex_unlock(&isa->update_lock);\n\n\tstrscpy(info->type, client_name, I2C_NAME_SIZE);\n\n\treturn 0;\n\n err_nodev:\n\tif (isa)\n\t\tmutex_unlock(&isa->update_lock);\n\treturn -ENODEV;\n}\n\nstatic void w83781d_remove_files(struct device *dev)\n{\n\tsysfs_remove_group(&dev->kobj, &w83781d_group);\n\tsysfs_remove_group(&dev->kobj, &w83781d_group_in1);\n\tsysfs_remove_group(&dev->kobj, &w83781d_group_in78);\n\tsysfs_remove_group(&dev->kobj, &w83781d_group_temp3);\n\tsysfs_remove_group(&dev->kobj, &w83781d_group_pwm12);\n\tsysfs_remove_group(&dev->kobj, &w83781d_group_pwm34);\n\tsysfs_remove_group(&dev->kobj, &w83781d_group_other);\n}\n\nstatic const struct i2c_device_id w83781d_ids[];\n\nstatic int w83781d_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct w83781d_data *data;\n\tint err;\n\n\tdata = devm_kzalloc(dev, sizeof(struct w83781d_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->lock);\n\tmutex_init(&data->update_lock);\n\n\tdata->type = i2c_match_id(w83781d_ids, client)->driver_data;\n\tdata->client = client;\n\n\t \n\terr = w83781d_detect_subclients(client);\n\tif (err)\n\t\treturn err;\n\n\t \n\tw83781d_init_device(dev);\n\n\t \n\terr = w83781d_create_files(dev, data->type, 0);\n\tif (err)\n\t\tgoto exit_remove_files;\n\n\tdata->hwmon_dev = hwmon_device_register(dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto exit_remove_files;\n\t}\n\n\treturn 0;\n\n exit_remove_files:\n\tw83781d_remove_files(dev);\n\ti2c_unregister_device(data->lm75[0]);\n\ti2c_unregister_device(data->lm75[1]);\n\treturn err;\n}\n\nstatic void\nw83781d_remove(struct i2c_client *client)\n{\n\tstruct w83781d_data *data = i2c_get_clientdata(client);\n\tstruct device *dev = &client->dev;\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tw83781d_remove_files(dev);\n\n\ti2c_unregister_device(data->lm75[0]);\n\ti2c_unregister_device(data->lm75[1]);\n}\n\nstatic int\nw83781d_read_value_i2c(struct w83781d_data *data, u16 reg)\n{\n\tstruct i2c_client *client = data->client;\n\tint res, bank;\n\tstruct i2c_client *cl;\n\n\tbank = (reg >> 8) & 0x0f;\n\tif (bank > 2)\n\t\t \n\t\ti2c_smbus_write_byte_data(client, W83781D_REG_BANK,\n\t\t\t\t\t  bank);\n\tif (bank == 0 || bank > 2) {\n\t\tres = i2c_smbus_read_byte_data(client, reg & 0xff);\n\t} else {\n\t\t \n\t\tcl = data->lm75[bank - 1];\n\t\t \n\t\tswitch (reg & 0xff) {\n\t\tcase 0x50:\t \n\t\t\tres = i2c_smbus_read_word_swapped(cl, 0);\n\t\t\tbreak;\n\t\tcase 0x52:\t \n\t\t\tres = i2c_smbus_read_byte_data(cl, 1);\n\t\t\tbreak;\n\t\tcase 0x53:\t \n\t\t\tres = i2c_smbus_read_word_swapped(cl, 2);\n\t\t\tbreak;\n\t\tcase 0x55:\t \n\t\tdefault:\n\t\t\tres = i2c_smbus_read_word_swapped(cl, 3);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bank > 2)\n\t\ti2c_smbus_write_byte_data(client, W83781D_REG_BANK, 0);\n\n\treturn res;\n}\n\nstatic int\nw83781d_write_value_i2c(struct w83781d_data *data, u16 reg, u16 value)\n{\n\tstruct i2c_client *client = data->client;\n\tint bank;\n\tstruct i2c_client *cl;\n\n\tbank = (reg >> 8) & 0x0f;\n\tif (bank > 2)\n\t\t \n\t\ti2c_smbus_write_byte_data(client, W83781D_REG_BANK,\n\t\t\t\t\t  bank);\n\tif (bank == 0 || bank > 2) {\n\t\ti2c_smbus_write_byte_data(client, reg & 0xff,\n\t\t\t\t\t  value & 0xff);\n\t} else {\n\t\t \n\t\tcl = data->lm75[bank - 1];\n\t\t \n\t\tswitch (reg & 0xff) {\n\t\tcase 0x52:\t \n\t\t\ti2c_smbus_write_byte_data(cl, 1, value & 0xff);\n\t\t\tbreak;\n\t\tcase 0x53:\t \n\t\t\ti2c_smbus_write_word_swapped(cl, 2, value);\n\t\t\tbreak;\n\t\tcase 0x55:\t \n\t\t\ti2c_smbus_write_word_swapped(cl, 3, value);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bank > 2)\n\t\ti2c_smbus_write_byte_data(client, W83781D_REG_BANK, 0);\n\n\treturn 0;\n}\n\nstatic void\nw83781d_init_device(struct device *dev)\n{\n\tstruct w83781d_data *data = dev_get_drvdata(dev);\n\tint i, p;\n\tint type = data->type;\n\tu8 tmp;\n\n\tif (reset && type != as99127f) {  \n\t\t \n\t\tdev_info(dev,\n\t\t\t \"If reset=1 solved a problem you were having, please report!\\n\");\n\n\t\t \n\t\ti = w83781d_read_value(data, W83781D_REG_BEEP_CONFIG);\n\t\tp = w83781d_read_value(data, W83781D_REG_PWMCLK12);\n\t\t \n\t\tw83781d_write_value(data, W83781D_REG_CONFIG, 0x80);\n\t\t \n\t\tw83781d_write_value(data, W83781D_REG_BEEP_CONFIG, i | 0x80);\n\t\tw83781d_write_value(data, W83781D_REG_PWMCLK12, p);\n\t\t \n\t\tw83781d_write_value(data, W83781D_REG_BEEP_INTS2, 0);\n\t}\n\n\t \n\tif (init && !reset && type != as99127f) {\n\t\ti = w83781d_read_value(data, W83781D_REG_BEEP_CONFIG);\n\t\tw83781d_write_value(data, W83781D_REG_BEEP_CONFIG, i | 0x80);\n\t}\n\n\tdata->vrm = vid_which_vrm();\n\n\tif ((type != w83781d) && (type != as99127f)) {\n\t\ttmp = w83781d_read_value(data, W83781D_REG_SCFG1);\n\t\tfor (i = 1; i <= 3; i++) {\n\t\t\tif (!(tmp & BIT_SCFG1[i - 1])) {\n\t\t\t\tdata->sens[i - 1] = 4;\n\t\t\t} else {\n\t\t\t\tif (w83781d_read_value\n\t\t\t\t    (data,\n\t\t\t\t     W83781D_REG_SCFG2) & BIT_SCFG2[i - 1])\n\t\t\t\t\tdata->sens[i - 1] = 1;\n\t\t\t\telse\n\t\t\t\t\tdata->sens[i - 1] = 2;\n\t\t\t}\n\t\t\tif (type == w83783s && i == 2)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (init && type != as99127f) {\n\t\t \n\t\ttmp = w83781d_read_value(data, W83781D_REG_TEMP2_CONFIG);\n\t\tif (tmp & 0x01) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Enabling temp2, readings might not make sense\\n\");\n\t\t\tw83781d_write_value(data, W83781D_REG_TEMP2_CONFIG,\n\t\t\t\ttmp & 0xfe);\n\t\t}\n\n\t\t \n\t\tif (type != w83783s) {\n\t\t\ttmp = w83781d_read_value(data,\n\t\t\t\tW83781D_REG_TEMP3_CONFIG);\n\t\t\tif (tmp & 0x01) {\n\t\t\t\tdev_warn(dev,\n\t\t\t\t\t \"Enabling temp3, readings might not make sense\\n\");\n\t\t\t\tw83781d_write_value(data,\n\t\t\t\t\tW83781D_REG_TEMP3_CONFIG, tmp & 0xfe);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tw83781d_write_value(data, W83781D_REG_CONFIG,\n\t\t\t    (w83781d_read_value(data,\n\t\t\t\t\t\tW83781D_REG_CONFIG) & 0xf7)\n\t\t\t    | 0x01);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tdata->fan_min[i] = w83781d_read_value(data,\n\t\t\t\t\tW83781D_REG_FAN_MIN(i));\n\t}\n\n\tmutex_init(&data->update_lock);\n}\n\nstatic struct w83781d_data *w83781d_update_device(struct device *dev)\n{\n\tstruct w83781d_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\n\t    || !data->valid) {\n\t\tdev_dbg(dev, \"Starting device update\\n\");\n\n\t\tfor (i = 0; i <= 8; i++) {\n\t\t\tif (data->type == w83783s && i == 1)\n\t\t\t\tcontinue;\t \n\t\t\tdata->in[i] =\n\t\t\t    w83781d_read_value(data, W83781D_REG_IN(i));\n\t\t\tdata->in_min[i] =\n\t\t\t    w83781d_read_value(data, W83781D_REG_IN_MIN(i));\n\t\t\tdata->in_max[i] =\n\t\t\t    w83781d_read_value(data, W83781D_REG_IN_MAX(i));\n\t\t\tif ((data->type != w83782d) && (i == 6))\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tdata->fan[i] =\n\t\t\t    w83781d_read_value(data, W83781D_REG_FAN(i));\n\t\t\tdata->fan_min[i] =\n\t\t\t    w83781d_read_value(data, W83781D_REG_FAN_MIN(i));\n\t\t}\n\t\tif (data->type != w83781d && data->type != as99127f) {\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tdata->pwm[i] =\n\t\t\t\t    w83781d_read_value(data,\n\t\t\t\t\t\t       W83781D_REG_PWM[i]);\n\t\t\t\t \n\t\t\t\tif ((data->type != w83782d || !client)\n\t\t\t\t    && i == 1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tdata->pwm2_enable = (w83781d_read_value(data,\n\t\t\t\t\t     W83781D_REG_PWMCLK12) & 0x08) >> 3;\n\t\t}\n\n\t\tdata->temp = w83781d_read_value(data, W83781D_REG_TEMP(1));\n\t\tdata->temp_max =\n\t\t    w83781d_read_value(data, W83781D_REG_TEMP_OVER(1));\n\t\tdata->temp_max_hyst =\n\t\t    w83781d_read_value(data, W83781D_REG_TEMP_HYST(1));\n\t\tdata->temp_add[0] =\n\t\t    w83781d_read_value(data, W83781D_REG_TEMP(2));\n\t\tdata->temp_max_add[0] =\n\t\t    w83781d_read_value(data, W83781D_REG_TEMP_OVER(2));\n\t\tdata->temp_max_hyst_add[0] =\n\t\t    w83781d_read_value(data, W83781D_REG_TEMP_HYST(2));\n\t\tif (data->type != w83783s) {\n\t\t\tdata->temp_add[1] =\n\t\t\t    w83781d_read_value(data, W83781D_REG_TEMP(3));\n\t\t\tdata->temp_max_add[1] =\n\t\t\t    w83781d_read_value(data,\n\t\t\t\t\t       W83781D_REG_TEMP_OVER(3));\n\t\t\tdata->temp_max_hyst_add[1] =\n\t\t\t    w83781d_read_value(data,\n\t\t\t\t\t       W83781D_REG_TEMP_HYST(3));\n\t\t}\n\t\ti = w83781d_read_value(data, W83781D_REG_VID_FANDIV);\n\t\tdata->vid = i & 0x0f;\n\t\tdata->vid |= (w83781d_read_value(data,\n\t\t\t\t\tW83781D_REG_CHIPID) & 0x01) << 4;\n\t\tdata->fan_div[0] = (i >> 4) & 0x03;\n\t\tdata->fan_div[1] = (i >> 6) & 0x03;\n\t\tdata->fan_div[2] = (w83781d_read_value(data,\n\t\t\t\t\tW83781D_REG_PIN) >> 6) & 0x03;\n\t\tif ((data->type != w83781d) && (data->type != as99127f)) {\n\t\t\ti = w83781d_read_value(data, W83781D_REG_VBAT);\n\t\t\tdata->fan_div[0] |= (i >> 3) & 0x04;\n\t\t\tdata->fan_div[1] |= (i >> 4) & 0x04;\n\t\t\tdata->fan_div[2] |= (i >> 5) & 0x04;\n\t\t}\n\t\tif (data->type == w83782d) {\n\t\t\tdata->alarms = w83781d_read_value(data,\n\t\t\t\t\t\tW83782D_REG_ALARM1)\n\t\t\t\t     | (w83781d_read_value(data,\n\t\t\t\t\t\tW83782D_REG_ALARM2) << 8)\n\t\t\t\t     | (w83781d_read_value(data,\n\t\t\t\t\t\tW83782D_REG_ALARM3) << 16);\n\t\t} else if (data->type == w83783s) {\n\t\t\tdata->alarms = w83781d_read_value(data,\n\t\t\t\t\t\tW83782D_REG_ALARM1)\n\t\t\t\t     | (w83781d_read_value(data,\n\t\t\t\t\t\tW83782D_REG_ALARM2) << 8);\n\t\t} else {\n\t\t\t \n\t\t\tdata->alarms = w83781d_read_value(data,\n\t\t\t\t\t\tW83781D_REG_ALARM1)\n\t\t\t\t     | (w83781d_read_value(data,\n\t\t\t\t\t\tW83781D_REG_ALARM2) << 8);\n\t\t}\n\t\ti = w83781d_read_value(data, W83781D_REG_BEEP_INTS2);\n\t\tdata->beep_mask = (i << 8) +\n\t\t    w83781d_read_value(data, W83781D_REG_BEEP_INTS1);\n\t\tif ((data->type != w83781d) && (data->type != as99127f)) {\n\t\t\tdata->beep_mask |=\n\t\t\t    w83781d_read_value(data,\n\t\t\t\t\t       W83781D_REG_BEEP_INTS3) << 16;\n\t\t}\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\nstatic const struct i2c_device_id w83781d_ids[] = {\n\t{ \"w83781d\", w83781d, },\n\t{ \"w83782d\", w83782d, },\n\t{ \"w83783s\", w83783s, },\n\t{ \"as99127f\", as99127f },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, w83781d_ids);\n\nstatic const struct of_device_id w83781d_of_match[] = {\n\t{ .compatible = \"winbond,w83781d\" },\n\t{ .compatible = \"winbond,w83781g\" },\n\t{ .compatible = \"winbond,w83782d\" },\n\t{ .compatible = \"winbond,w83783s\" },\n\t{ .compatible = \"asus,as99127f\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, w83781d_of_match);\n\nstatic struct i2c_driver w83781d_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"w83781d\",\n\t\t.of_match_table = w83781d_of_match,\n\t},\n\t.probe\t\t= w83781d_probe,\n\t.remove\t\t= w83781d_remove,\n\t.id_table\t= w83781d_ids,\n\t.detect\t\t= w83781d_detect,\n\t.address_list\t= normal_i2c,\n};\n\n \n#ifdef CONFIG_ISA\n\n \nstatic struct platform_device *pdev;\n\nstatic unsigned short isa_address = 0x290;\n\n \nstatic ssize_t\nname_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tstruct w83781d_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%s\\n\", data->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic struct w83781d_data *w83781d_data_if_isa(void)\n{\n\treturn pdev ? platform_get_drvdata(pdev) : NULL;\n}\n\n \nstatic int w83781d_alias_detect(struct i2c_client *client, u8 chipid)\n{\n\tstruct w83781d_data *isa;\n\tint i;\n\n\tif (!pdev)\t \n\t\treturn 0;\n\n\tisa = platform_get_drvdata(pdev);\n\n\tif (w83781d_read_value(isa, W83781D_REG_I2C_ADDR) != client->addr)\n\t\treturn 0;\t \n\tif (w83781d_read_value(isa, W83781D_REG_WCHIPID) != chipid)\n\t\treturn 0;\t \n\n\t \n\tfor (i = 0x2b; i <= 0x3d; i++) {\n\t\tif (w83781d_read_value(isa, i) !=\n\t\t    i2c_smbus_read_byte_data(client, i))\n\t\t\treturn 0;\n\t}\n\tif (w83781d_read_value(isa, W83781D_REG_CONFIG) !=\n\t    i2c_smbus_read_byte_data(client, W83781D_REG_CONFIG))\n\t\treturn 0;\n\tfor (i = 0x43; i <= 0x46; i++) {\n\t\tif (w83781d_read_value(isa, i) !=\n\t\t    i2c_smbus_read_byte_data(client, i))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nw83781d_read_value_isa(struct w83781d_data *data, u16 reg)\n{\n\tint word_sized, res;\n\n\tword_sized = (((reg & 0xff00) == 0x100)\n\t\t      || ((reg & 0xff00) == 0x200))\n\t    && (((reg & 0x00ff) == 0x50)\n\t\t|| ((reg & 0x00ff) == 0x53)\n\t\t|| ((reg & 0x00ff) == 0x55));\n\tif (reg & 0xff00) {\n\t\toutb_p(W83781D_REG_BANK,\n\t\t       data->isa_addr + W83781D_ADDR_REG_OFFSET);\n\t\toutb_p(reg >> 8,\n\t\t       data->isa_addr + W83781D_DATA_REG_OFFSET);\n\t}\n\toutb_p(reg & 0xff, data->isa_addr + W83781D_ADDR_REG_OFFSET);\n\tres = inb_p(data->isa_addr + W83781D_DATA_REG_OFFSET);\n\tif (word_sized) {\n\t\toutb_p((reg & 0xff) + 1,\n\t\t       data->isa_addr + W83781D_ADDR_REG_OFFSET);\n\t\tres =\n\t\t    (res << 8) + inb_p(data->isa_addr +\n\t\t\t\t       W83781D_DATA_REG_OFFSET);\n\t}\n\tif (reg & 0xff00) {\n\t\toutb_p(W83781D_REG_BANK,\n\t\t       data->isa_addr + W83781D_ADDR_REG_OFFSET);\n\t\toutb_p(0, data->isa_addr + W83781D_DATA_REG_OFFSET);\n\t}\n\treturn res;\n}\n\nstatic void\nw83781d_write_value_isa(struct w83781d_data *data, u16 reg, u16 value)\n{\n\tint word_sized;\n\n\tword_sized = (((reg & 0xff00) == 0x100)\n\t\t      || ((reg & 0xff00) == 0x200))\n\t    && (((reg & 0x00ff) == 0x53)\n\t\t|| ((reg & 0x00ff) == 0x55));\n\tif (reg & 0xff00) {\n\t\toutb_p(W83781D_REG_BANK,\n\t\t       data->isa_addr + W83781D_ADDR_REG_OFFSET);\n\t\toutb_p(reg >> 8,\n\t\t       data->isa_addr + W83781D_DATA_REG_OFFSET);\n\t}\n\toutb_p(reg & 0xff, data->isa_addr + W83781D_ADDR_REG_OFFSET);\n\tif (word_sized) {\n\t\toutb_p(value >> 8,\n\t\t       data->isa_addr + W83781D_DATA_REG_OFFSET);\n\t\toutb_p((reg & 0xff) + 1,\n\t\t       data->isa_addr + W83781D_ADDR_REG_OFFSET);\n\t}\n\toutb_p(value & 0xff, data->isa_addr + W83781D_DATA_REG_OFFSET);\n\tif (reg & 0xff00) {\n\t\toutb_p(W83781D_REG_BANK,\n\t\t       data->isa_addr + W83781D_ADDR_REG_OFFSET);\n\t\toutb_p(0, data->isa_addr + W83781D_DATA_REG_OFFSET);\n\t}\n}\n\n \nstatic int\nw83781d_read_value(struct w83781d_data *data, u16 reg)\n{\n\tstruct i2c_client *client = data->client;\n\tint res;\n\n\tmutex_lock(&data->lock);\n\tif (client)\n\t\tres = w83781d_read_value_i2c(data, reg);\n\telse\n\t\tres = w83781d_read_value_isa(data, reg);\n\tmutex_unlock(&data->lock);\n\treturn res;\n}\n\nstatic int\nw83781d_write_value(struct w83781d_data *data, u16 reg, u16 value)\n{\n\tstruct i2c_client *client = data->client;\n\n\tmutex_lock(&data->lock);\n\tif (client)\n\t\tw83781d_write_value_i2c(data, reg, value);\n\telse\n\t\tw83781d_write_value_isa(data, reg, value);\n\tmutex_unlock(&data->lock);\n\treturn 0;\n}\n\nstatic int\nw83781d_isa_probe(struct platform_device *pdev)\n{\n\tint err, reg;\n\tstruct w83781d_data *data;\n\tstruct resource *res;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!devm_request_region(&pdev->dev,\n\t\t\t\t res->start + W83781D_ADDR_REG_OFFSET, 2,\n\t\t\t\t \"w83781d\"))\n\t\treturn -EBUSY;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct w83781d_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&data->lock);\n\tdata->isa_addr = res->start;\n\tplatform_set_drvdata(pdev, data);\n\n\treg = w83781d_read_value(data, W83781D_REG_WCHIPID);\n\tswitch (reg) {\n\tcase 0x30:\n\t\tdata->type = w83782d;\n\t\tdata->name = \"w83782d\";\n\t\tbreak;\n\tdefault:\n\t\tdata->type = w83781d;\n\t\tdata->name = \"w83781d\";\n\t}\n\n\t \n\tw83781d_init_device(&pdev->dev);\n\n\t \n\terr = w83781d_create_files(&pdev->dev, data->type, 1);\n\tif (err)\n\t\tgoto exit_remove_files;\n\n\terr = device_create_file(&pdev->dev, &dev_attr_name);\n\tif (err)\n\t\tgoto exit_remove_files;\n\n\tdata->hwmon_dev = hwmon_device_register(&pdev->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto exit_remove_files;\n\t}\n\n\treturn 0;\n\n exit_remove_files:\n\tw83781d_remove_files(&pdev->dev);\n\tdevice_remove_file(&pdev->dev, &dev_attr_name);\n\treturn err;\n}\n\nstatic int\nw83781d_isa_remove(struct platform_device *pdev)\n{\n\tstruct w83781d_data *data = platform_get_drvdata(pdev);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tw83781d_remove_files(&pdev->dev);\n\tdevice_remove_file(&pdev->dev, &dev_attr_name);\n\n\treturn 0;\n}\n\nstatic struct platform_driver w83781d_isa_driver = {\n\t.driver = {\n\t\t.name = \"w83781d\",\n\t},\n\t.probe = w83781d_isa_probe,\n\t.remove = w83781d_isa_remove,\n};\n\n \nstatic int __init\nw83781d_isa_found(unsigned short address)\n{\n\tint val, save, found = 0;\n\tint port;\n\n\t \n\tfor (port = address; port < address + W83781D_EXTENT; port++) {\n\t\tif (!request_region(port, 1, \"w83781d\")) {\n\t\t\tpr_debug(\"Failed to request port 0x%x\\n\", port);\n\t\t\tgoto release;\n\t\t}\n\t}\n\n#define REALLY_SLOW_IO\n\t \n\tval = inb_p(address + 1);\n\tif (inb_p(address + 2) != val\n\t || inb_p(address + 3) != val\n\t || inb_p(address + 7) != val) {\n\t\tpr_debug(\"Detection failed at step %d\\n\", 1);\n\t\tgoto release;\n\t}\n#undef REALLY_SLOW_IO\n\n\t \n\tsave = inb_p(address + W83781D_ADDR_REG_OFFSET);\n\tif (save & 0x80) {\n\t\tpr_debug(\"Detection failed at step %d\\n\", 2);\n\t\tgoto release;\n\t}\n\tval = ~save & 0x7f;\n\toutb_p(val, address + W83781D_ADDR_REG_OFFSET);\n\tif (inb_p(address + W83781D_ADDR_REG_OFFSET) != (val | 0x80)) {\n\t\toutb_p(save, address + W83781D_ADDR_REG_OFFSET);\n\t\tpr_debug(\"Detection failed at step %d\\n\", 3);\n\t\tgoto release;\n\t}\n\n\t \n\toutb_p(W83781D_REG_CONFIG, address + W83781D_ADDR_REG_OFFSET);\n\tval = inb_p(address + W83781D_DATA_REG_OFFSET);\n\tif (val & 0x80) {\n\t\tpr_debug(\"Detection failed at step %d\\n\", 4);\n\t\tgoto release;\n\t}\n\toutb_p(W83781D_REG_BANK, address + W83781D_ADDR_REG_OFFSET);\n\tsave = inb_p(address + W83781D_DATA_REG_OFFSET);\n\toutb_p(W83781D_REG_CHIPMAN, address + W83781D_ADDR_REG_OFFSET);\n\tval = inb_p(address + W83781D_DATA_REG_OFFSET);\n\tif ((!(save & 0x80) && (val != 0xa3))\n\t || ((save & 0x80) && (val != 0x5c))) {\n\t\tpr_debug(\"Detection failed at step %d\\n\", 5);\n\t\tgoto release;\n\t}\n\toutb_p(W83781D_REG_I2C_ADDR, address + W83781D_ADDR_REG_OFFSET);\n\tval = inb_p(address + W83781D_DATA_REG_OFFSET);\n\tif (val < 0x03 || val > 0x77) {\t \n\t\tpr_debug(\"Detection failed at step %d\\n\", 6);\n\t\tgoto release;\n\t}\n\n\t \n\tif (inb_p(address + W83781D_ADDR_REG_OFFSET) & 0x80) {\n\t\tpr_debug(\"Detection failed at step %d\\n\", 7);\n\t\tgoto release;\n\t}\n\n\t \n\toutb_p(W83781D_REG_BANK, address + W83781D_ADDR_REG_OFFSET);\n\tsave = inb_p(address + W83781D_DATA_REG_OFFSET);\n\toutb_p(save & 0xf8, address + W83781D_DATA_REG_OFFSET);\n\toutb_p(W83781D_REG_WCHIPID, address + W83781D_ADDR_REG_OFFSET);\n\tval = inb_p(address + W83781D_DATA_REG_OFFSET);\n\tif ((val & 0xfe) == 0x10\t \n\t || val == 0x30)\t\t \n\t\tfound = 1;\n\n\tif (found)\n\t\tpr_info(\"Found a %s chip at %#x\\n\",\n\t\t\tval == 0x30 ? \"W83782D\" : \"W83781D\", (int)address);\n\n release:\n\tfor (port--; port >= address; port--)\n\t\trelease_region(port, 1);\n\treturn found;\n}\n\nstatic int __init\nw83781d_isa_device_add(unsigned short address)\n{\n\tstruct resource res = {\n\t\t.start\t= address,\n\t\t.end\t= address + W83781D_EXTENT - 1,\n\t\t.name\t= \"w83781d\",\n\t\t.flags\t= IORESOURCE_IO,\n\t};\n\tint err;\n\n\tpdev = platform_device_alloc(\"w83781d\", address);\n\tif (!pdev) {\n\t\terr = -ENOMEM;\n\t\tpr_err(\"Device allocation failed\\n\");\n\t\tgoto exit;\n\t}\n\n\terr = platform_device_add_resources(pdev, &res, 1);\n\tif (err) {\n\t\tpr_err(\"Device resource addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n\t\tpr_err(\"Device addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\treturn 0;\n\n exit_device_put:\n\tplatform_device_put(pdev);\n exit:\n\tpdev = NULL;\n\treturn err;\n}\n\nstatic int __init\nw83781d_isa_register(void)\n{\n\tint res;\n\n\tif (w83781d_isa_found(isa_address)) {\n\t\tres = platform_driver_register(&w83781d_isa_driver);\n\t\tif (res)\n\t\t\tgoto exit;\n\n\t\t \n\t\tres = w83781d_isa_device_add(isa_address);\n\t\tif (res)\n\t\t\tgoto exit_unreg_isa_driver;\n\t}\n\n\treturn 0;\n\nexit_unreg_isa_driver:\n\tplatform_driver_unregister(&w83781d_isa_driver);\nexit:\n\treturn res;\n}\n\nstatic void\nw83781d_isa_unregister(void)\n{\n\tif (pdev) {\n\t\tplatform_device_unregister(pdev);\n\t\tplatform_driver_unregister(&w83781d_isa_driver);\n\t}\n}\n#else  \n\nstatic struct w83781d_data *w83781d_data_if_isa(void)\n{\n\treturn NULL;\n}\n\nstatic int\nw83781d_alias_detect(struct i2c_client *client, u8 chipid)\n{\n\treturn 0;\n}\n\nstatic int\nw83781d_read_value(struct w83781d_data *data, u16 reg)\n{\n\tint res;\n\n\tmutex_lock(&data->lock);\n\tres = w83781d_read_value_i2c(data, reg);\n\tmutex_unlock(&data->lock);\n\n\treturn res;\n}\n\nstatic int\nw83781d_write_value(struct w83781d_data *data, u16 reg, u16 value)\n{\n\tmutex_lock(&data->lock);\n\tw83781d_write_value_i2c(data, reg, value);\n\tmutex_unlock(&data->lock);\n\n\treturn 0;\n}\n\nstatic int __init\nw83781d_isa_register(void)\n{\n\treturn 0;\n}\n\nstatic void\nw83781d_isa_unregister(void)\n{\n}\n#endif  \n\nstatic int __init\nsensors_w83781d_init(void)\n{\n\tint res;\n\n\t \n\tres = w83781d_isa_register();\n\tif (res)\n\t\tgoto exit;\n\n\tres = i2c_add_driver(&w83781d_driver);\n\tif (res)\n\t\tgoto exit_unreg_isa;\n\n\treturn 0;\n\n exit_unreg_isa:\n\tw83781d_isa_unregister();\n exit:\n\treturn res;\n}\n\nstatic void __exit\nsensors_w83781d_exit(void)\n{\n\tw83781d_isa_unregister();\n\ti2c_del_driver(&w83781d_driver);\n}\n\nMODULE_AUTHOR(\"Frodo Looijaard <frodol@dds.nl>, \"\n\t      \"Philip Edelbrock <phil@netroedge.com>, \"\n\t      \"and Mark Studebaker <mdsxyz123@yahoo.com>\");\nMODULE_DESCRIPTION(\"W83781D driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(sensors_w83781d_init);\nmodule_exit(sensors_w83781d_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}