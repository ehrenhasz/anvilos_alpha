{
  "module_name": "nct6683.c",
  "hash_id": "762bffe4ed106f77320592b9097069c192960569ca50a733cb5887d902bec2bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/nct6683.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\nenum kinds { nct6683, nct6686, nct6687 };\n\nstatic bool force;\nmodule_param(force, bool, 0);\nMODULE_PARM_DESC(force, \"Set to one to enable support for unknown vendors\");\n\nstatic const char * const nct6683_device_names[] = {\n\t\"nct6683\",\n\t\"nct6686\",\n\t\"nct6687\",\n};\n\nstatic const char * const nct6683_chip_names[] = {\n\t\"NCT6683D\",\n\t\"NCT6686D\",\n\t\"NCT6687D\",\n};\n\n#define DRVNAME \"nct6683\"\n\n \n\n#define NCT6683_LD_ACPI\t\t0x0a\n#define NCT6683_LD_HWM\t\t0x0b\n#define NCT6683_LD_VID\t\t0x0d\n\n#define SIO_REG_LDSEL\t\t0x07\t \n#define SIO_REG_DEVID\t\t0x20\t \n#define SIO_REG_ENABLE\t\t0x30\t \n#define SIO_REG_ADDR\t\t0x60\t \n\n#define SIO_NCT6681_ID\t\t0xb270\t \n#define SIO_NCT6683_ID\t\t0xc730\n#define SIO_NCT6686_ID\t\t0xd440\n#define SIO_NCT6687_ID\t\t0xd590\n#define SIO_ID_MASK\t\t0xFFF0\n\nstatic inline void\nsuperio_outb(int ioreg, int reg, int val)\n{\n\toutb(reg, ioreg);\n\toutb(val, ioreg + 1);\n}\n\nstatic inline int\nsuperio_inb(int ioreg, int reg)\n{\n\toutb(reg, ioreg);\n\treturn inb(ioreg + 1);\n}\n\nstatic inline void\nsuperio_select(int ioreg, int ld)\n{\n\toutb(SIO_REG_LDSEL, ioreg);\n\toutb(ld, ioreg + 1);\n}\n\nstatic inline int\nsuperio_enter(int ioreg)\n{\n\t \n\tif (!request_muxed_region(ioreg, 2, DRVNAME))\n\t\treturn -EBUSY;\n\n\toutb(0x87, ioreg);\n\toutb(0x87, ioreg);\n\n\treturn 0;\n}\n\nstatic inline void\nsuperio_exit(int ioreg)\n{\n\toutb(0xaa, ioreg);\n\toutb(0x02, ioreg);\n\toutb(0x02, ioreg + 1);\n\trelease_region(ioreg, 2);\n}\n\n \n\n#define IOREGION_ALIGNMENT\t(~7)\n#define IOREGION_OFFSET\t\t4\t \n#define IOREGION_LENGTH\t\t4\n\n#define EC_PAGE_REG\t\t0\n#define EC_INDEX_REG\t\t1\n#define EC_DATA_REG\t\t2\n#define EC_EVENT_REG\t\t3\n\n \n\n#define NCT6683_NUM_REG_MON\t\t32\n#define NCT6683_NUM_REG_FAN\t\t16\n#define NCT6683_NUM_REG_PWM\t\t8\n\n#define NCT6683_REG_MON(x)\t\t(0x100 + (x) * 2)\n#define NCT6683_REG_FAN_RPM(x)\t\t(0x140 + (x) * 2)\n#define NCT6683_REG_PWM(x)\t\t(0x160 + (x))\n#define NCT6683_REG_PWM_WRITE(x)\t(0xa28 + (x))\n\n#define NCT6683_REG_MON_STS(x)\t\t(0x174 + (x))\n#define NCT6683_REG_IDLE(x)\t\t(0x178 + (x))\n\n#define NCT6683_REG_FAN_STS(x)\t\t(0x17c + (x))\n#define NCT6683_REG_FAN_ERRSTS\t\t0x17e\n#define NCT6683_REG_FAN_INITSTS\t\t0x17f\n\n#define NCT6683_HWM_CFG\t\t\t0x180\n\n#define NCT6683_REG_MON_CFG(x)\t\t(0x1a0 + (x))\n#define NCT6683_REG_FANIN_CFG(x)\t(0x1c0 + (x))\n#define NCT6683_REG_FANOUT_CFG(x)\t(0x1d0 + (x))\n\n#define NCT6683_REG_INTEL_TEMP_MAX(x)\t(0x901 + (x) * 16)\n#define NCT6683_REG_INTEL_TEMP_CRIT(x)\t(0x90d + (x) * 16)\n\n#define NCT6683_REG_TEMP_HYST(x)\t(0x330 + (x))\t\t \n#define NCT6683_REG_TEMP_MAX(x)\t\t(0x350 + (x))\t\t \n#define NCT6683_REG_MON_HIGH(x)\t\t(0x370 + (x) * 2)\t \n#define NCT6683_REG_MON_LOW(x)\t\t(0x371 + (x) * 2)\t \n\n#define NCT6683_REG_FAN_MIN(x)\t\t(0x3b8 + (x) * 2)\t \n\n#define NCT6683_REG_FAN_CFG_CTRL\t0xa01\n#define NCT6683_FAN_CFG_REQ\t\t0x80\n#define NCT6683_FAN_CFG_DONE\t\t0x40\n\n#define NCT6683_REG_CUSTOMER_ID\t\t0x602\n#define NCT6683_CUSTOMER_ID_INTEL\t0x805\n#define NCT6683_CUSTOMER_ID_MITAC\t0xa0e\n#define NCT6683_CUSTOMER_ID_MSI\t\t0x201\n#define NCT6683_CUSTOMER_ID_MSI2\t0x200\n#define NCT6683_CUSTOMER_ID_ASROCK\t\t0xe2c\n#define NCT6683_CUSTOMER_ID_ASROCK2\t0xe1b\n\n#define NCT6683_REG_BUILD_YEAR\t\t0x604\n#define NCT6683_REG_BUILD_MONTH\t\t0x605\n#define NCT6683_REG_BUILD_DAY\t\t0x606\n#define NCT6683_REG_SERIAL\t\t0x607\n#define NCT6683_REG_VERSION_HI\t\t0x608\n#define NCT6683_REG_VERSION_LO\t\t0x609\n\n#define NCT6683_REG_CR_CASEOPEN\t\t0xe8\n#define NCT6683_CR_CASEOPEN_MASK\t(1 << 7)\n\n#define NCT6683_REG_CR_BEEP\t\t0xe0\n#define NCT6683_CR_BEEP_MASK\t\t(1 << 6)\n\nstatic const char *const nct6683_mon_label[] = {\n\tNULL,\t \n\t\"Local\",\n\t\"Diode 0 (curr)\",\n\t\"Diode 1 (curr)\",\n\t\"Diode 2 (curr)\",\n\t\"Diode 0 (volt)\",\n\t\"Diode 1 (volt)\",\n\t\"Diode 2 (volt)\",\n\t\"Thermistor 14\",\n\t\"Thermistor 15\",\n\t\"Thermistor 16\",\n\t\"Thermistor 0\",\n\t\"Thermistor 1\",\n\t\"Thermistor 2\",\n\t\"Thermistor 3\",\n\t\"Thermistor 4\",\n\t\"Thermistor 5\",\t\t \n\t\"Thermistor 6\",\n\t\"Thermistor 7\",\n\t\"Thermistor 8\",\n\t\"Thermistor 9\",\n\t\"Thermistor 10\",\n\t\"Thermistor 11\",\n\t\"Thermistor 12\",\n\t\"Thermistor 13\",\n\tNULL, NULL, NULL, NULL, NULL, NULL, NULL,\n\t\"PECI 0.0\",\t\t \n\t\"PECI 1.0\",\n\t\"PECI 2.0\",\n\t\"PECI 3.0\",\n\t\"PECI 0.1\",\n\t\"PECI 1.1\",\n\t\"PECI 2.1\",\n\t\"PECI 3.1\",\n\t\"PECI DIMM 0\",\n\t\"PECI DIMM 1\",\n\t\"PECI DIMM 2\",\n\t\"PECI DIMM 3\",\n\tNULL, NULL, NULL, NULL,\n\t\"PCH CPU\",\t\t \n\t\"PCH CHIP\",\n\t\"PCH CHIP CPU MAX\",\n\t\"PCH MCH\",\n\t\"PCH DIMM 0\",\n\t\"PCH DIMM 1\",\n\t\"PCH DIMM 2\",\n\t\"PCH DIMM 3\",\n\t\"SMBus 0\",\n\t\"SMBus 1\",\n\t\"SMBus 2\",\n\t\"SMBus 3\",\n\t\"SMBus 4\",\n\t\"SMBus 5\",\n\t\"DIMM 0\",\n\t\"DIMM 1\",\n\t\"DIMM 2\",\t\t \n\t\"DIMM 3\",\n\t\"AMD TSI Addr 90h\",\n\t\"AMD TSI Addr 92h\",\n\t\"AMD TSI Addr 94h\",\n\t\"AMD TSI Addr 96h\",\n\t\"AMD TSI Addr 98h\",\n\t\"AMD TSI Addr 9ah\",\n\t\"AMD TSI Addr 9ch\",\n\t\"AMD TSI Addr 9dh\",\n\tNULL, NULL, NULL, NULL, NULL, NULL,\n\t\"Virtual 0\",\t\t \n\t\"Virtual 1\",\n\t\"Virtual 2\",\n\t\"Virtual 3\",\n\t\"Virtual 4\",\n\t\"Virtual 5\",\n\t\"Virtual 6\",\n\t\"Virtual 7\",\n\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n\t\"VCC\",\t\t\t \n\t\"VSB\",\n\t\"AVSB\",\n\t\"VTT\",\n\t\"VBAT\",\n\t\"VREF\",\n\t\"VIN0\",\n\t\"VIN1\",\n\t\"VIN2\",\n\t\"VIN3\",\n\t\"VIN4\",\n\t\"VIN5\",\n\t\"VIN6\",\n\t\"VIN7\",\n\t\"VIN8\",\n\t\"VIN9\",\n\t\"VIN10\",\n\t\"VIN11\",\n\t\"VIN12\",\n\t\"VIN13\",\n\t\"VIN14\",\n\t\"VIN15\",\n\t\"VIN16\",\n};\n\n#define NUM_MON_LABELS\t\tARRAY_SIZE(nct6683_mon_label)\n#define MON_VOLTAGE_START\t0x60\n\n \n\nstruct nct6683_data {\n\tint addr;\t\t \n\tint sioreg;\t\t \n\tenum kinds kind;\n\tu16 customer_id;\n\n\tstruct device *hwmon_dev;\n\tconst struct attribute_group *groups[6];\n\n\tint temp_num;\t\t\t \n\tu8 temp_index[NCT6683_NUM_REG_MON];\n\tu8 temp_src[NCT6683_NUM_REG_MON];\n\n\tu8 in_num;\t\t\t \n\tu8 in_index[NCT6683_NUM_REG_MON];\n\tu8 in_src[NCT6683_NUM_REG_MON];\n\n\tstruct mutex update_lock;\t \n\tbool valid;\t\t\t \n\tunsigned long last_updated;\t \n\n\t \n\tu8 in[3][NCT6683_NUM_REG_MON];\t \n\n\t \n\ts16 temp_in[NCT6683_NUM_REG_MON];\n\ts8 temp[4][NCT6683_NUM_REG_MON]; \n\n\t \n\tunsigned int rpm[NCT6683_NUM_REG_FAN];\n\tu16 fan_min[NCT6683_NUM_REG_FAN];\n\tu8 fanin_cfg[NCT6683_NUM_REG_FAN];\n\tu8 fanout_cfg[NCT6683_NUM_REG_FAN];\n\tu16 have_fan;\t\t\t \n\n\tu8 have_pwm;\n\tu8 pwm[NCT6683_NUM_REG_PWM];\n\n#ifdef CONFIG_PM\n\t \n\tu8 hwm_cfg;\n#endif\n};\n\nstruct nct6683_sio_data {\n\tint sioreg;\n\tenum kinds kind;\n};\n\nstruct sensor_device_template {\n\tstruct device_attribute dev_attr;\n\tunion {\n\t\tstruct {\n\t\t\tu8 nr;\n\t\t\tu8 index;\n\t\t} s;\n\t\tint index;\n\t} u;\n\tbool s2;\t \n};\n\nstruct sensor_device_attr_u {\n\tunion {\n\t\tstruct sensor_device_attribute a1;\n\t\tstruct sensor_device_attribute_2 a2;\n\t} u;\n\tchar name[32];\n};\n\n#define __TEMPLATE_ATTR(_template, _mode, _show, _store) {\t\\\n\t.attr = {.name = _template, .mode = _mode },\t\t\\\n\t.show\t= _show,\t\t\t\t\t\\\n\t.store\t= _store,\t\t\t\t\t\\\n}\n\n#define SENSOR_DEVICE_TEMPLATE(_template, _mode, _show, _store, _index)\t\\\n\t{ .dev_attr = __TEMPLATE_ATTR(_template, _mode, _show, _store),\t\\\n\t  .u.index = _index,\t\t\t\t\t\t\\\n\t  .s2 = false }\n\n#define SENSOR_DEVICE_TEMPLATE_2(_template, _mode, _show, _store,\t\\\n\t\t\t\t _nr, _index)\t\t\t\t\\\n\t{ .dev_attr = __TEMPLATE_ATTR(_template, _mode, _show, _store),\t\\\n\t  .u.s.index = _index,\t\t\t\t\t\t\\\n\t  .u.s.nr = _nr,\t\t\t\t\t\t\\\n\t  .s2 = true }\n\n#define SENSOR_TEMPLATE(_name, _template, _mode, _show, _store, _index)\t\\\nstatic struct sensor_device_template sensor_dev_template_##_name\t\\\n\t= SENSOR_DEVICE_TEMPLATE(_template, _mode, _show, _store,\t\\\n\t\t\t\t _index)\n\n#define SENSOR_TEMPLATE_2(_name, _template, _mode, _show, _store,\t\\\n\t\t\t  _nr, _index)\t\t\t\t\t\\\nstatic struct sensor_device_template sensor_dev_template_##_name\t\\\n\t= SENSOR_DEVICE_TEMPLATE_2(_template, _mode, _show, _store,\t\\\n\t\t\t\t _nr, _index)\n\nstruct sensor_template_group {\n\tstruct sensor_device_template **templates;\n\tumode_t (*is_visible)(struct kobject *, struct attribute *, int);\n\tint base;\n};\n\nstatic struct attribute_group *\nnct6683_create_attr_group(struct device *dev,\n\t\t\t  const struct sensor_template_group *tg,\n\t\t\t  int repeat)\n{\n\tstruct sensor_device_attribute_2 *a2;\n\tstruct sensor_device_attribute *a;\n\tstruct sensor_device_template **t;\n\tstruct sensor_device_attr_u *su;\n\tstruct attribute_group *group;\n\tstruct attribute **attrs;\n\tint i, count;\n\n\tif (repeat <= 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tt = tg->templates;\n\tfor (count = 0; *t; t++, count++)\n\t\t;\n\n\tif (count == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tgroup = devm_kzalloc(dev, sizeof(*group), GFP_KERNEL);\n\tif (group == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tattrs = devm_kcalloc(dev, repeat * count + 1, sizeof(*attrs),\n\t\t\t     GFP_KERNEL);\n\tif (attrs == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsu = devm_kzalloc(dev, array3_size(repeat, count, sizeof(*su)),\n\t\t\t  GFP_KERNEL);\n\tif (su == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgroup->attrs = attrs;\n\tgroup->is_visible = tg->is_visible;\n\n\tfor (i = 0; i < repeat; i++) {\n\t\tt = tg->templates;\n\t\twhile (*t) {\n\t\t\tsnprintf(su->name, sizeof(su->name),\n\t\t\t\t (*t)->dev_attr.attr.name, tg->base + i);\n\t\t\tif ((*t)->s2) {\n\t\t\t\ta2 = &su->u.a2;\n\t\t\t\tsysfs_attr_init(&a2->dev_attr.attr);\n\t\t\t\ta2->dev_attr.attr.name = su->name;\n\t\t\t\ta2->nr = (*t)->u.s.nr + i;\n\t\t\t\ta2->index = (*t)->u.s.index;\n\t\t\t\ta2->dev_attr.attr.mode =\n\t\t\t\t  (*t)->dev_attr.attr.mode;\n\t\t\t\ta2->dev_attr.show = (*t)->dev_attr.show;\n\t\t\t\ta2->dev_attr.store = (*t)->dev_attr.store;\n\t\t\t\t*attrs = &a2->dev_attr.attr;\n\t\t\t} else {\n\t\t\t\ta = &su->u.a1;\n\t\t\t\tsysfs_attr_init(&a->dev_attr.attr);\n\t\t\t\ta->dev_attr.attr.name = su->name;\n\t\t\t\ta->index = (*t)->u.index + i;\n\t\t\t\ta->dev_attr.attr.mode =\n\t\t\t\t  (*t)->dev_attr.attr.mode;\n\t\t\t\ta->dev_attr.show = (*t)->dev_attr.show;\n\t\t\t\ta->dev_attr.store = (*t)->dev_attr.store;\n\t\t\t\t*attrs = &a->dev_attr.attr;\n\t\t\t}\n\t\t\tattrs++;\n\t\t\tsu++;\n\t\t\tt++;\n\t\t}\n\t}\n\n\treturn group;\n}\n\n \n#define MON_SRC_VCC\t0x60\n#define MON_SRC_VSB\t0x61\n#define MON_SRC_AVSB\t0x62\n#define MON_SRC_VBAT\t0x64\n\nstatic inline long in_from_reg(u16 reg, u8 src)\n{\n\tint scale = 16;\n\n\tif (src == MON_SRC_VCC || src == MON_SRC_VSB || src == MON_SRC_AVSB ||\n\t    src == MON_SRC_VBAT)\n\t\tscale <<= 1;\n\treturn reg * scale;\n}\n\nstatic u16 nct6683_read(struct nct6683_data *data, u16 reg)\n{\n\tint res;\n\n\toutb_p(0xff, data->addr + EC_PAGE_REG);\t\t \n\toutb_p(reg >> 8, data->addr + EC_PAGE_REG);\n\toutb_p(reg & 0xff, data->addr + EC_INDEX_REG);\n\tres = inb_p(data->addr + EC_DATA_REG);\n\treturn res;\n}\n\nstatic u16 nct6683_read16(struct nct6683_data *data, u16 reg)\n{\n\treturn (nct6683_read(data, reg) << 8) | nct6683_read(data, reg + 1);\n}\n\nstatic void nct6683_write(struct nct6683_data *data, u16 reg, u16 value)\n{\n\toutb_p(0xff, data->addr + EC_PAGE_REG);\t\t \n\toutb_p(reg >> 8, data->addr + EC_PAGE_REG);\n\toutb_p(reg & 0xff, data->addr + EC_INDEX_REG);\n\toutb_p(value & 0xff, data->addr + EC_DATA_REG);\n}\n\nstatic int get_in_reg(struct nct6683_data *data, int nr, int index)\n{\n\tint ch = data->in_index[index];\n\tint reg = -EINVAL;\n\n\tswitch (nr) {\n\tcase 0:\n\t\treg = NCT6683_REG_MON(ch);\n\t\tbreak;\n\tcase 1:\n\t\tif (data->customer_id != NCT6683_CUSTOMER_ID_INTEL)\n\t\t\treg = NCT6683_REG_MON_LOW(ch);\n\t\tbreak;\n\tcase 2:\n\t\tif (data->customer_id != NCT6683_CUSTOMER_ID_INTEL)\n\t\t\treg = NCT6683_REG_MON_HIGH(ch);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn reg;\n}\n\nstatic int get_temp_reg(struct nct6683_data *data, int nr, int index)\n{\n\tint ch = data->temp_index[index];\n\tint reg = -EINVAL;\n\n\tswitch (data->customer_id) {\n\tcase NCT6683_CUSTOMER_ID_INTEL:\n\t\tswitch (nr) {\n\t\tdefault:\n\t\tcase 1:\t \n\t\t\treg = NCT6683_REG_INTEL_TEMP_MAX(ch);\n\t\t\tbreak;\n\t\tcase 3:\t \n\t\t\treg = NCT6683_REG_INTEL_TEMP_CRIT(ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NCT6683_CUSTOMER_ID_MITAC:\n\tdefault:\n\t\tswitch (nr) {\n\t\tdefault:\n\t\tcase 0:\t \n\t\t\treg = NCT6683_REG_MON_LOW(ch);\n\t\t\tbreak;\n\t\tcase 1:\t \n\t\t\treg = NCT6683_REG_TEMP_MAX(ch);\n\t\t\tbreak;\n\t\tcase 2:\t \n\t\t\treg = NCT6683_REG_TEMP_HYST(ch);\n\t\t\tbreak;\n\t\tcase 3:\t \n\t\t\treg = NCT6683_REG_MON_HIGH(ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn reg;\n}\n\nstatic void nct6683_update_pwm(struct device *dev)\n{\n\tstruct nct6683_data *data = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < NCT6683_NUM_REG_PWM; i++) {\n\t\tif (!(data->have_pwm & (1 << i)))\n\t\t\tcontinue;\n\t\tdata->pwm[i] = nct6683_read(data, NCT6683_REG_PWM(i));\n\t}\n}\n\nstatic struct nct6683_data *nct6683_update_device(struct device *dev)\n{\n\tstruct nct6683_data *data = dev_get_drvdata(dev);\n\tint i, j;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\n\t\t \n\t\tfor (i = 0; i < data->in_num; i++) {\n\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\tint reg = get_in_reg(data, j, i);\n\n\t\t\t\tif (reg >= 0)\n\t\t\t\t\tdata->in[j][i] =\n\t\t\t\t\t\tnct6683_read(data, reg);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < data->temp_num; i++) {\n\t\t\tu8 ch = data->temp_index[i];\n\n\t\t\tdata->temp_in[i] = nct6683_read16(data,\n\t\t\t\t\t\t\t  NCT6683_REG_MON(ch));\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tint reg = get_temp_reg(data, j, i);\n\n\t\t\t\tif (reg >= 0)\n\t\t\t\t\tdata->temp[j][i] =\n\t\t\t\t\t\tnct6683_read(data, reg);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(data->rpm); i++) {\n\t\t\tif (!(data->have_fan & (1 << i)))\n\t\t\t\tcontinue;\n\n\t\t\tdata->rpm[i] = nct6683_read16(data,\n\t\t\t\t\t\tNCT6683_REG_FAN_RPM(i));\n\t\t\tdata->fan_min[i] = nct6683_read16(data,\n\t\t\t\t\t\tNCT6683_REG_FAN_MIN(i));\n\t\t}\n\n\t\tnct6683_update_pwm(dev);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n}\n\n \nstatic ssize_t\nshow_in_label(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tstruct nct6683_data *data = nct6683_update_device(dev);\n\tint nr = sattr->index;\n\n\treturn sprintf(buf, \"%s\\n\", nct6683_mon_label[data->in_src[nr]]);\n}\n\nstatic ssize_t\nshow_in_reg(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct6683_data *data = nct6683_update_device(dev);\n\tint index = sattr->index;\n\tint nr = sattr->nr;\n\n\treturn sprintf(buf, \"%ld\\n\",\n\t\t       in_from_reg(data->in[index][nr], data->in_index[index]));\n}\n\nstatic umode_t nct6683_in_is_visible(struct kobject *kobj,\n\t\t\t\t     struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct6683_data *data = dev_get_drvdata(dev);\n\tint nr = index % 4;\t \n\n\t \n\tif ((nr == 2 || nr == 3) &&\n\t    data->customer_id == NCT6683_CUSTOMER_ID_INTEL)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nSENSOR_TEMPLATE(in_label, \"in%d_label\", S_IRUGO, show_in_label, NULL, 0);\nSENSOR_TEMPLATE_2(in_input, \"in%d_input\", S_IRUGO, show_in_reg, NULL, 0, 0);\nSENSOR_TEMPLATE_2(in_min, \"in%d_min\", S_IRUGO, show_in_reg, NULL, 0, 1);\nSENSOR_TEMPLATE_2(in_max, \"in%d_max\", S_IRUGO, show_in_reg, NULL, 0, 2);\n\nstatic struct sensor_device_template *nct6683_attributes_in_template[] = {\n\t&sensor_dev_template_in_label,\n\t&sensor_dev_template_in_input,\n\t&sensor_dev_template_in_min,\n\t&sensor_dev_template_in_max,\n\tNULL\n};\n\nstatic const struct sensor_template_group nct6683_in_template_group = {\n\t.templates = nct6683_attributes_in_template,\n\t.is_visible = nct6683_in_is_visible,\n};\n\nstatic ssize_t\nshow_fan(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tstruct nct6683_data *data = nct6683_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", data->rpm[sattr->index]);\n}\n\nstatic ssize_t\nshow_fan_min(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6683_data *data = nct6683_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\n\treturn sprintf(buf, \"%d\\n\", data->fan_min[nr]);\n}\n\nstatic ssize_t\nshow_fan_pulses(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tstruct nct6683_data *data = nct6683_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       ((data->fanin_cfg[sattr->index] >> 5) & 0x03) + 1);\n}\n\nstatic umode_t nct6683_fan_is_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct6683_data *data = dev_get_drvdata(dev);\n\tint fan = index / 3;\t \n\tint nr = index % 3;\t \n\n\tif (!(data->have_fan & (1 << fan)))\n\t\treturn 0;\n\n\t \n\tif (nr == 2 && data->customer_id == NCT6683_CUSTOMER_ID_INTEL)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nSENSOR_TEMPLATE(fan_input, \"fan%d_input\", S_IRUGO, show_fan, NULL, 0);\nSENSOR_TEMPLATE(fan_pulses, \"fan%d_pulses\", S_IRUGO, show_fan_pulses, NULL, 0);\nSENSOR_TEMPLATE(fan_min, \"fan%d_min\", S_IRUGO, show_fan_min, NULL, 0);\n\n \nstatic struct sensor_device_template *nct6683_attributes_fan_template[] = {\n\t&sensor_dev_template_fan_input,\n\t&sensor_dev_template_fan_pulses,\n\t&sensor_dev_template_fan_min,\n\tNULL\n};\n\nstatic const struct sensor_template_group nct6683_fan_template_group = {\n\t.templates = nct6683_attributes_fan_template,\n\t.is_visible = nct6683_fan_is_visible,\n\t.base = 1,\n};\n\nstatic ssize_t\nshow_temp_label(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tstruct nct6683_data *data = nct6683_update_device(dev);\n\tint nr = sattr->index;\n\n\treturn sprintf(buf, \"%s\\n\", nct6683_mon_label[data->temp_src[nr]]);\n}\n\nstatic ssize_t\nshow_temp8(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct6683_data *data = nct6683_update_device(dev);\n\tint index = sattr->index;\n\tint nr = sattr->nr;\n\n\treturn sprintf(buf, \"%d\\n\", data->temp[index][nr] * 1000);\n}\n\nstatic ssize_t\nshow_temp_hyst(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tstruct nct6683_data *data = nct6683_update_device(dev);\n\tint nr = sattr->index;\n\tint temp = data->temp[1][nr] - data->temp[2][nr];\n\n\treturn sprintf(buf, \"%d\\n\", temp * 1000);\n}\n\nstatic ssize_t\nshow_temp16(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tstruct nct6683_data *data = nct6683_update_device(dev);\n\tint index = sattr->index;\n\n\treturn sprintf(buf, \"%d\\n\", (data->temp_in[index] / 128) * 500);\n}\n\n \n\nstatic int get_temp_type(u8 src)\n{\n\tif (src >= 0x02 && src <= 0x07)\n\t\treturn 3;\t \n\telse if (src >= 0x08 && src <= 0x18)\n\t\treturn 4;\t \n\telse if (src >= 0x20 && src <= 0x2b)\n\t\treturn 6;\t \n\telse if (src >= 0x42 && src <= 0x49)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic ssize_t\nshow_temp_type(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6683_data *data = nct6683_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\treturn sprintf(buf, \"%d\\n\", get_temp_type(data->temp_src[nr]));\n}\n\nstatic umode_t nct6683_temp_is_visible(struct kobject *kobj,\n\t\t\t\t       struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct6683_data *data = dev_get_drvdata(dev);\n\tint temp = index / 7;\t \n\tint nr = index % 7;\t \n\n\t \n\tif ((nr == 2 || nr == 4) &&\n\t    data->customer_id == NCT6683_CUSTOMER_ID_INTEL)\n\t\treturn 0;\n\n\tif (nr == 6 && get_temp_type(data->temp_src[temp]) == 0)\n\t\treturn 0;\t\t\t\t \n\n\treturn attr->mode;\n}\n\nSENSOR_TEMPLATE(temp_input, \"temp%d_input\", S_IRUGO, show_temp16, NULL, 0);\nSENSOR_TEMPLATE(temp_label, \"temp%d_label\", S_IRUGO, show_temp_label, NULL, 0);\nSENSOR_TEMPLATE_2(temp_min, \"temp%d_min\", S_IRUGO, show_temp8, NULL, 0, 0);\nSENSOR_TEMPLATE_2(temp_max, \"temp%d_max\", S_IRUGO, show_temp8, NULL, 0, 1);\nSENSOR_TEMPLATE(temp_max_hyst, \"temp%d_max_hyst\", S_IRUGO, show_temp_hyst, NULL,\n\t\t0);\nSENSOR_TEMPLATE_2(temp_crit, \"temp%d_crit\", S_IRUGO, show_temp8, NULL, 0, 3);\nSENSOR_TEMPLATE(temp_type, \"temp%d_type\", S_IRUGO, show_temp_type, NULL, 0);\n\n \nstatic struct sensor_device_template *nct6683_attributes_temp_template[] = {\n\t&sensor_dev_template_temp_input,\n\t&sensor_dev_template_temp_label,\n\t&sensor_dev_template_temp_min,\t\t \n\t&sensor_dev_template_temp_max,\t\t \n\t&sensor_dev_template_temp_max_hyst,\t \n\t&sensor_dev_template_temp_crit,\t\t \n\t&sensor_dev_template_temp_type,\t\t \n\tNULL\n};\n\nstatic const struct sensor_template_group nct6683_temp_template_group = {\n\t.templates = nct6683_attributes_temp_template,\n\t.is_visible = nct6683_temp_is_visible,\n\t.base = 1,\n};\n\nstatic ssize_t\nshow_pwm(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6683_data *data = nct6683_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint index = sattr->index;\n\n\treturn sprintf(buf, \"%d\\n\", data->pwm[index]);\n}\n\nstatic ssize_t\nstore_pwm(struct device *dev, struct device_attribute *attr, const char *buf,\n\t  size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct6683_data *data = dev_get_drvdata(dev);\n\tint index = sattr->index;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val) || val > 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tnct6683_write(data, NCT6683_REG_FAN_CFG_CTRL, NCT6683_FAN_CFG_REQ);\n\tusleep_range(1000, 2000);\n\tnct6683_write(data, NCT6683_REG_PWM_WRITE(index), val);\n\tnct6683_write(data, NCT6683_REG_FAN_CFG_CTRL, NCT6683_FAN_CFG_DONE);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nSENSOR_TEMPLATE(pwm, \"pwm%d\", S_IRUGO, show_pwm, store_pwm, 0);\n\nstatic umode_t nct6683_pwm_is_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct6683_data *data = dev_get_drvdata(dev);\n\tint pwm = index;\t \n\n\tif (!(data->have_pwm & (1 << pwm)))\n\t\treturn 0;\n\n\t \n\tif (data->customer_id == NCT6683_CUSTOMER_ID_MITAC)\n\t\treturn attr->mode | S_IWUSR;\n\n\treturn attr->mode;\n}\n\nstatic struct sensor_device_template *nct6683_attributes_pwm_template[] = {\n\t&sensor_dev_template_pwm,\n\tNULL\n};\n\nstatic const struct sensor_template_group nct6683_pwm_template_group = {\n\t.templates = nct6683_attributes_pwm_template,\n\t.is_visible = nct6683_pwm_is_visible,\n\t.base = 1,\n};\n\nstatic ssize_t\nbeep_enable_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6683_data *data = dev_get_drvdata(dev);\n\tint ret;\n\tu8 reg;\n\n\tmutex_lock(&data->update_lock);\n\n\tret = superio_enter(data->sioreg);\n\tif (ret)\n\t\tgoto error;\n\tsuperio_select(data->sioreg, NCT6683_LD_HWM);\n\treg = superio_inb(data->sioreg, NCT6683_REG_CR_BEEP);\n\tsuperio_exit(data->sioreg);\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn sprintf(buf, \"%u\\n\", !!(reg & NCT6683_CR_BEEP_MASK));\n\nerror:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t\nbeep_enable_store(struct device *dev, struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tstruct nct6683_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tu8 reg;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val) || (val != 0 && val != 1))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\n\tret = superio_enter(data->sioreg);\n\tif (ret) {\n\t\tcount = ret;\n\t\tgoto error;\n\t}\n\n\tsuperio_select(data->sioreg, NCT6683_LD_HWM);\n\treg = superio_inb(data->sioreg, NCT6683_REG_CR_BEEP);\n\tif (val)\n\t\treg |= NCT6683_CR_BEEP_MASK;\n\telse\n\t\treg &= ~NCT6683_CR_BEEP_MASK;\n\tsuperio_outb(data->sioreg, NCT6683_REG_CR_BEEP, reg);\n\tsuperio_exit(data->sioreg);\nerror:\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \n\nstatic ssize_t\nintrusion0_alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct nct6683_data *data = dev_get_drvdata(dev);\n\tint ret;\n\tu8 reg;\n\n\tmutex_lock(&data->update_lock);\n\n\tret = superio_enter(data->sioreg);\n\tif (ret)\n\t\tgoto error;\n\tsuperio_select(data->sioreg, NCT6683_LD_ACPI);\n\treg = superio_inb(data->sioreg, NCT6683_REG_CR_CASEOPEN);\n\tsuperio_exit(data->sioreg);\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn sprintf(buf, \"%u\\n\", !(reg & NCT6683_CR_CASEOPEN_MASK));\n\nerror:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t\nintrusion0_alarm_store(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct nct6683_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tu8 reg;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val) || val != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\n\tret = superio_enter(data->sioreg);\n\tif (ret) {\n\t\tcount = ret;\n\t\tgoto error;\n\t}\n\n\tsuperio_select(data->sioreg, NCT6683_LD_ACPI);\n\treg = superio_inb(data->sioreg, NCT6683_REG_CR_CASEOPEN);\n\treg |= NCT6683_CR_CASEOPEN_MASK;\n\tsuperio_outb(data->sioreg, NCT6683_REG_CR_CASEOPEN, reg);\n\treg &= ~NCT6683_CR_CASEOPEN_MASK;\n\tsuperio_outb(data->sioreg, NCT6683_REG_CR_CASEOPEN, reg);\n\tsuperio_exit(data->sioreg);\n\n\tdata->valid = false;\t \nerror:\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(intrusion0_alarm);\nstatic DEVICE_ATTR_RW(beep_enable);\n\nstatic struct attribute *nct6683_attributes_other[] = {\n\t&dev_attr_intrusion0_alarm.attr,\n\t&dev_attr_beep_enable.attr,\n\tNULL\n};\n\nstatic const struct attribute_group nct6683_group_other = {\n\t.attrs = nct6683_attributes_other,\n};\n\n \nstatic inline void nct6683_init_device(struct nct6683_data *data)\n{\n\tu8 tmp;\n\n\t \n\ttmp = nct6683_read(data, NCT6683_HWM_CFG);\n\tif (!(tmp & 0x80))\n\t\tnct6683_write(data, NCT6683_HWM_CFG, tmp | 0x80);\n}\n\n \nstatic void\nnct6683_setup_fans(struct nct6683_data *data)\n{\n\tint i;\n\tu8 reg;\n\n\tfor (i = 0; i < NCT6683_NUM_REG_FAN; i++) {\n\t\treg = nct6683_read(data, NCT6683_REG_FANIN_CFG(i));\n\t\tif (reg & 0x80)\n\t\t\tdata->have_fan |= 1 << i;\n\t\tdata->fanin_cfg[i] = reg;\n\t}\n\tfor (i = 0; i < NCT6683_NUM_REG_PWM; i++) {\n\t\treg = nct6683_read(data, NCT6683_REG_FANOUT_CFG(i));\n\t\tif (reg & 0x80)\n\t\t\tdata->have_pwm |= 1 << i;\n\t\tdata->fanout_cfg[i] = reg;\n\t}\n}\n\n \n\nstatic void nct6683_setup_sensors(struct nct6683_data *data)\n{\n\tu8 reg;\n\tint i;\n\n\tdata->temp_num = 0;\n\tdata->in_num = 0;\n\tfor (i = 0; i < NCT6683_NUM_REG_MON; i++) {\n\t\treg = nct6683_read(data, NCT6683_REG_MON_CFG(i)) & 0x7f;\n\t\t \n\t\tif (reg >= NUM_MON_LABELS)\n\t\t\tcontinue;\n\t\t \n\t\tif (nct6683_mon_label[reg] == NULL)\n\t\t\tcontinue;\n\t\tif (reg < MON_VOLTAGE_START) {\n\t\t\tdata->temp_index[data->temp_num] = i;\n\t\t\tdata->temp_src[data->temp_num] = reg;\n\t\t\tdata->temp_num++;\n\t\t} else {\n\t\t\tdata->in_index[data->in_num] = i;\n\t\t\tdata->in_src[data->in_num] = reg;\n\t\t\tdata->in_num++;\n\t\t}\n\t}\n}\n\nstatic int nct6683_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct nct6683_sio_data *sio_data = dev->platform_data;\n\tstruct attribute_group *group;\n\tstruct nct6683_data *data;\n\tstruct device *hwmon_dev;\n\tstruct resource *res;\n\tint groups = 0;\n\tchar build[16];\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!devm_request_region(dev, res->start, IOREGION_LENGTH, DRVNAME))\n\t\treturn -EBUSY;\n\n\tdata = devm_kzalloc(dev, sizeof(struct nct6683_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->kind = sio_data->kind;\n\tdata->sioreg = sio_data->sioreg;\n\tdata->addr = res->start;\n\tmutex_init(&data->update_lock);\n\tplatform_set_drvdata(pdev, data);\n\n\tdata->customer_id = nct6683_read16(data, NCT6683_REG_CUSTOMER_ID);\n\n\t \n\tswitch (data->customer_id) {\n\tcase NCT6683_CUSTOMER_ID_INTEL:\n\t\tbreak;\n\tcase NCT6683_CUSTOMER_ID_MITAC:\n\t\tbreak;\n\tcase NCT6683_CUSTOMER_ID_MSI:\n\t\tbreak;\n\tcase NCT6683_CUSTOMER_ID_MSI2:\n\t\tbreak;\n\tcase NCT6683_CUSTOMER_ID_ASROCK:\n\t\tbreak;\n\tcase NCT6683_CUSTOMER_ID_ASROCK2:\n\t\tbreak;\n\tdefault:\n\t\tif (!force)\n\t\t\treturn -ENODEV;\n\t}\n\n\tnct6683_init_device(data);\n\tnct6683_setup_fans(data);\n\tnct6683_setup_sensors(data);\n\n\t \n\n\tif (data->have_pwm) {\n\t\tgroup = nct6683_create_attr_group(dev,\n\t\t\t\t\t\t  &nct6683_pwm_template_group,\n\t\t\t\t\t\t  fls(data->have_pwm));\n\t\tif (IS_ERR(group))\n\t\t\treturn PTR_ERR(group);\n\t\tdata->groups[groups++] = group;\n\t}\n\n\tif (data->in_num) {\n\t\tgroup = nct6683_create_attr_group(dev,\n\t\t\t\t\t\t  &nct6683_in_template_group,\n\t\t\t\t\t\t  data->in_num);\n\t\tif (IS_ERR(group))\n\t\t\treturn PTR_ERR(group);\n\t\tdata->groups[groups++] = group;\n\t}\n\n\tif (data->have_fan) {\n\t\tgroup = nct6683_create_attr_group(dev,\n\t\t\t\t\t\t  &nct6683_fan_template_group,\n\t\t\t\t\t\t  fls(data->have_fan));\n\t\tif (IS_ERR(group))\n\t\t\treturn PTR_ERR(group);\n\t\tdata->groups[groups++] = group;\n\t}\n\n\tif (data->temp_num) {\n\t\tgroup = nct6683_create_attr_group(dev,\n\t\t\t\t\t\t  &nct6683_temp_template_group,\n\t\t\t\t\t\t  data->temp_num);\n\t\tif (IS_ERR(group))\n\t\t\treturn PTR_ERR(group);\n\t\tdata->groups[groups++] = group;\n\t}\n\tdata->groups[groups++] = &nct6683_group_other;\n\n\tif (data->customer_id == NCT6683_CUSTOMER_ID_INTEL)\n\t\tscnprintf(build, sizeof(build), \"%02x/%02x/%02x\",\n\t\t\t  nct6683_read(data, NCT6683_REG_BUILD_MONTH),\n\t\t\t  nct6683_read(data, NCT6683_REG_BUILD_DAY),\n\t\t\t  nct6683_read(data, NCT6683_REG_BUILD_YEAR));\n\telse\n\t\tscnprintf(build, sizeof(build), \"%02d/%02d/%02d\",\n\t\t\t  nct6683_read(data, NCT6683_REG_BUILD_MONTH),\n\t\t\t  nct6683_read(data, NCT6683_REG_BUILD_DAY),\n\t\t\t  nct6683_read(data, NCT6683_REG_BUILD_YEAR));\n\n\tdev_info(dev, \"%s EC firmware version %d.%d build %s\\n\",\n\t\t nct6683_chip_names[data->kind],\n\t\t nct6683_read(data, NCT6683_REG_VERSION_HI),\n\t\t nct6683_read(data, NCT6683_REG_VERSION_LO),\n\t\t build);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev,\n\t\t\tnct6683_device_names[data->kind], data, data->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\n#ifdef CONFIG_PM\nstatic int nct6683_suspend(struct device *dev)\n{\n\tstruct nct6683_data *data = nct6683_update_device(dev);\n\n\tmutex_lock(&data->update_lock);\n\tdata->hwm_cfg = nct6683_read(data, NCT6683_HWM_CFG);\n\tmutex_unlock(&data->update_lock);\n\n\treturn 0;\n}\n\nstatic int nct6683_resume(struct device *dev)\n{\n\tstruct nct6683_data *data = dev_get_drvdata(dev);\n\n\tmutex_lock(&data->update_lock);\n\n\tnct6683_write(data, NCT6683_HWM_CFG, data->hwm_cfg);\n\n\t \n\tdata->valid = false;\n\tmutex_unlock(&data->update_lock);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops nct6683_dev_pm_ops = {\n\t.suspend = nct6683_suspend,\n\t.resume = nct6683_resume,\n\t.freeze = nct6683_suspend,\n\t.restore = nct6683_resume,\n};\n\n#define NCT6683_DEV_PM_OPS\t(&nct6683_dev_pm_ops)\n#else\n#define NCT6683_DEV_PM_OPS\tNULL\n#endif  \n\nstatic struct platform_driver nct6683_driver = {\n\t.driver = {\n\t\t.name\t= DRVNAME,\n\t\t.pm\t= NCT6683_DEV_PM_OPS,\n\t},\n\t.probe\t\t= nct6683_probe,\n};\n\nstatic int __init nct6683_find(int sioaddr, struct nct6683_sio_data *sio_data)\n{\n\tint addr;\n\tu16 val;\n\tint err;\n\n\terr = superio_enter(sioaddr);\n\tif (err)\n\t\treturn err;\n\n\tval = (superio_inb(sioaddr, SIO_REG_DEVID) << 8)\n\t       | superio_inb(sioaddr, SIO_REG_DEVID + 1);\n\n\tswitch (val & SIO_ID_MASK) {\n\tcase SIO_NCT6683_ID:\n\t\tsio_data->kind = nct6683;\n\t\tbreak;\n\tcase SIO_NCT6686_ID:\n\t\tsio_data->kind = nct6686;\n\t\tbreak;\n\tcase SIO_NCT6687_ID:\n\t\tsio_data->kind = nct6687;\n\t\tbreak;\n\tdefault:\n\t\tif (val != 0xffff)\n\t\t\tpr_debug(\"unsupported chip ID: 0x%04x\\n\", val);\n\t\tgoto fail;\n\t}\n\n\t \n\tsuperio_select(sioaddr, NCT6683_LD_HWM);\n\tval = (superio_inb(sioaddr, SIO_REG_ADDR) << 8)\n\t    | superio_inb(sioaddr, SIO_REG_ADDR + 1);\n\taddr = val & IOREGION_ALIGNMENT;\n\tif (addr == 0) {\n\t\tpr_err(\"EC base I/O port unconfigured\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tval = superio_inb(sioaddr, SIO_REG_ENABLE);\n\tif (!(val & 0x01)) {\n\t\tpr_warn(\"Forcibly enabling EC access. Data may be unusable.\\n\");\n\t\tsuperio_outb(sioaddr, SIO_REG_ENABLE, val | 0x01);\n\t}\n\n\tsuperio_exit(sioaddr);\n\tpr_info(\"Found %s or compatible chip at %#x:%#x\\n\",\n\t\tnct6683_chip_names[sio_data->kind], sioaddr, addr);\n\tsio_data->sioreg = sioaddr;\n\n\treturn addr;\n\nfail:\n\tsuperio_exit(sioaddr);\n\treturn -ENODEV;\n}\n\n \nstatic struct platform_device *pdev[2];\n\nstatic int __init sensors_nct6683_init(void)\n{\n\tstruct nct6683_sio_data sio_data;\n\tint sioaddr[2] = { 0x2e, 0x4e };\n\tstruct resource res;\n\tbool found = false;\n\tint address;\n\tint i, err;\n\n\terr = platform_driver_register(&nct6683_driver);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pdev); i++) {\n\t\taddress = nct6683_find(sioaddr[i], &sio_data);\n\t\tif (address <= 0)\n\t\t\tcontinue;\n\n\t\tfound = true;\n\n\t\tpdev[i] = platform_device_alloc(DRVNAME, address);\n\t\tif (!pdev[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit_device_unregister;\n\t\t}\n\n\t\terr = platform_device_add_data(pdev[i], &sio_data,\n\t\t\t\t\t       sizeof(struct nct6683_sio_data));\n\t\tif (err)\n\t\t\tgoto exit_device_put;\n\n\t\tmemset(&res, 0, sizeof(res));\n\t\tres.name = DRVNAME;\n\t\tres.start = address + IOREGION_OFFSET;\n\t\tres.end = address + IOREGION_OFFSET + IOREGION_LENGTH - 1;\n\t\tres.flags = IORESOURCE_IO;\n\n\t\terr = acpi_check_resource_conflict(&res);\n\t\tif (err) {\n\t\t\tplatform_device_put(pdev[i]);\n\t\t\tpdev[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = platform_device_add_resources(pdev[i], &res, 1);\n\t\tif (err)\n\t\t\tgoto exit_device_put;\n\n\t\t \n\t\terr = platform_device_add(pdev[i]);\n\t\tif (err)\n\t\t\tgoto exit_device_put;\n\t}\n\tif (!found) {\n\t\terr = -ENODEV;\n\t\tgoto exit_unregister;\n\t}\n\n\treturn 0;\n\nexit_device_put:\n\tplatform_device_put(pdev[i]);\nexit_device_unregister:\n\twhile (--i >= 0) {\n\t\tif (pdev[i])\n\t\t\tplatform_device_unregister(pdev[i]);\n\t}\nexit_unregister:\n\tplatform_driver_unregister(&nct6683_driver);\n\treturn err;\n}\n\nstatic void __exit sensors_nct6683_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pdev); i++) {\n\t\tif (pdev[i])\n\t\t\tplatform_device_unregister(pdev[i]);\n\t}\n\tplatform_driver_unregister(&nct6683_driver);\n}\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"NCT6683D driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(sensors_nct6683_init);\nmodule_exit(sensors_nct6683_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}