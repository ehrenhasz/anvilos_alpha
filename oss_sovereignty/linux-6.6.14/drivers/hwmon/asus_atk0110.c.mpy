{
  "module_name": "asus_atk0110.c",
  "hash_id": "c96193fd92bec5ac8d114c3633ffdfcbbb3c0ef56be0fe31d56538add22ea533",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/asus_atk0110.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/debugfs.h>\n#include <linux/kernel.h>\n#include <linux/hwmon.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dmi.h>\n#include <linux/jiffies.h>\n#include <linux/err.h>\n#include <linux/acpi.h>\n\n#define ATK_HID \"ATK0110\"\n\nstatic bool new_if;\nmodule_param(new_if, bool, 0);\nMODULE_PARM_DESC(new_if, \"Override detection heuristic and force the use of the new ATK0110 interface\");\n\nstatic const struct dmi_system_id __initconst atk_force_new_if[] = {\n\t{\n\t\t \n\t\t.ident = \"Asus Sabertooth X58\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"SABERTOOTH X58\")\n\t\t}\n\t}, {\n\t\t \n\t\t.ident = \"Asus M5A78L\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"M5A78L\")\n\t\t}\n\t},\n\t{ }\n};\n\n \n#define CACHE_TIME\t\tHZ\n\n#define BOARD_ID\t\t\"MBIF\"\n#define METHOD_ENUMERATE\t\"GGRP\"\n#define METHOD_READ\t\t\"GITM\"\n#define METHOD_WRITE\t\t\"SITM\"\n#define METHOD_OLD_READ_TMP\t\"RTMP\"\n#define METHOD_OLD_READ_VLT\t\"RVLT\"\n#define METHOD_OLD_READ_FAN\t\"RFAN\"\n#define METHOD_OLD_ENUM_TMP\t\"TSIF\"\n#define METHOD_OLD_ENUM_VLT\t\"VSIF\"\n#define METHOD_OLD_ENUM_FAN\t\"FSIF\"\n\n#define ATK_MUX_HWMON\t\t0x00000006ULL\n#define ATK_MUX_MGMT\t\t0x00000011ULL\n\n#define ATK_CLASS_MASK\t\t0xff000000ULL\n#define ATK_CLASS_FREQ_CTL\t0x03000000ULL\n#define ATK_CLASS_FAN_CTL\t0x04000000ULL\n#define ATK_CLASS_HWMON\t\t0x06000000ULL\n#define ATK_CLASS_MGMT\t\t0x11000000ULL\n\n#define ATK_TYPE_MASK\t\t0x00ff0000ULL\n#define HWMON_TYPE_VOLT\t\t0x00020000ULL\n#define HWMON_TYPE_TEMP\t\t0x00030000ULL\n#define HWMON_TYPE_FAN\t\t0x00040000ULL\n\n#define ATK_ELEMENT_ID_MASK\t0x0000ffffULL\n\n#define ATK_EC_ID\t\t0x11060004ULL\n\nenum atk_pack_member {\n\tHWMON_PACK_FLAGS,\n\tHWMON_PACK_NAME,\n\tHWMON_PACK_LIMIT1,\n\tHWMON_PACK_LIMIT2,\n\tHWMON_PACK_ENABLE\n};\n\n \n#define _HWMON_NEW_PACK_SIZE\t7\n#define _HWMON_NEW_PACK_FLAGS\t0\n#define _HWMON_NEW_PACK_NAME\t1\n#define _HWMON_NEW_PACK_UNK1\t2\n#define _HWMON_NEW_PACK_UNK2\t3\n#define _HWMON_NEW_PACK_LIMIT1\t4\n#define _HWMON_NEW_PACK_LIMIT2\t5\n#define _HWMON_NEW_PACK_ENABLE\t6\n\n \n#define _HWMON_OLD_PACK_SIZE\t5\n#define _HWMON_OLD_PACK_FLAGS\t0\n#define _HWMON_OLD_PACK_NAME\t1\n#define _HWMON_OLD_PACK_LIMIT1\t2\n#define _HWMON_OLD_PACK_LIMIT2\t3\n#define _HWMON_OLD_PACK_ENABLE\t4\n\n\nstruct atk_data {\n\tstruct device *hwmon_dev;\n\tacpi_handle atk_handle;\n\tstruct acpi_device *acpi_dev;\n\n\tbool old_interface;\n\n\t \n\tacpi_handle rtmp_handle;\n\tacpi_handle rvlt_handle;\n\tacpi_handle rfan_handle;\n\t \n\tacpi_handle enumerate_handle;\n\tacpi_handle read_handle;\n\tacpi_handle write_handle;\n\n\tbool disable_ec;\n\n\tint voltage_count;\n\tint temperature_count;\n\tint fan_count;\n\tstruct list_head sensor_list;\n\tstruct attribute_group attr_group;\n\tconst struct attribute_group *attr_groups[2];\n\n\tstruct {\n\t\tstruct dentry *root;\n\t\tu32 id;\n\t} debugfs;\n};\n\n\ntypedef ssize_t (*sysfs_show_func)(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf);\n\nstatic const struct acpi_device_id atk_ids[] = {\n\t{ATK_HID, 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, atk_ids);\n\n#define ATTR_NAME_SIZE 16  \n\nstruct atk_sensor_data {\n\tstruct list_head list;\n\tstruct atk_data *data;\n\tstruct device_attribute label_attr;\n\tstruct device_attribute input_attr;\n\tstruct device_attribute limit1_attr;\n\tstruct device_attribute limit2_attr;\n\tchar label_attr_name[ATTR_NAME_SIZE];\n\tchar input_attr_name[ATTR_NAME_SIZE];\n\tchar limit1_attr_name[ATTR_NAME_SIZE];\n\tchar limit2_attr_name[ATTR_NAME_SIZE];\n\tu64 id;\n\tu64 type;\n\tu64 limit1;\n\tu64 limit2;\n\tu64 cached_value;\n\tunsigned long last_updated;  \n\tbool is_valid;\n\tchar const *acpi_name;\n};\n\n \nstruct atk_acpi_ret_buffer {\n\tu32 flags;\n\tu32 value;\n\tu8 data[];\n};\n\n \nstruct atk_acpi_input_buf {\n\tu32 id;\n\tu32 param1;\n\tu32 param2;\n};\n\nstatic int atk_add(struct acpi_device *device);\nstatic void atk_remove(struct acpi_device *device);\nstatic void atk_print_sensor(struct atk_data *data, union acpi_object *obj);\nstatic int atk_read_value(struct atk_sensor_data *sensor, u64 *value);\n\nstatic struct acpi_driver atk_driver = {\n\t.name\t= ATK_HID,\n\t.class\t= \"hwmon\",\n\t.ids\t= atk_ids,\n\t.ops\t= {\n\t\t.add\t= atk_add,\n\t\t.remove\t= atk_remove,\n\t},\n};\n\n#define input_to_atk_sensor(attr) \\\n\tcontainer_of(attr, struct atk_sensor_data, input_attr)\n\n#define label_to_atk_sensor(attr) \\\n\tcontainer_of(attr, struct atk_sensor_data, label_attr)\n\n#define limit1_to_atk_sensor(attr) \\\n\tcontainer_of(attr, struct atk_sensor_data, limit1_attr)\n\n#define limit2_to_atk_sensor(attr) \\\n\tcontainer_of(attr, struct atk_sensor_data, limit2_attr)\n\nstatic ssize_t atk_input_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct atk_sensor_data *s = input_to_atk_sensor(attr);\n\tu64 value;\n\tint err;\n\n\terr = atk_read_value(s, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (s->type == HWMON_TYPE_TEMP)\n\t\t \n\t\tvalue *= 100;\n\n\treturn sprintf(buf, \"%llu\\n\", value);\n}\n\nstatic ssize_t atk_label_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct atk_sensor_data *s = label_to_atk_sensor(attr);\n\n\treturn sprintf(buf, \"%s\\n\", s->acpi_name);\n}\n\nstatic ssize_t atk_limit1_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct atk_sensor_data *s = limit1_to_atk_sensor(attr);\n\tu64 value = s->limit1;\n\n\tif (s->type == HWMON_TYPE_TEMP)\n\t\tvalue *= 100;\n\n\treturn sprintf(buf, \"%lld\\n\", value);\n}\n\nstatic ssize_t atk_limit2_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct atk_sensor_data *s = limit2_to_atk_sensor(attr);\n\tu64 value = s->limit2;\n\n\tif (s->type == HWMON_TYPE_TEMP)\n\t\tvalue *= 100;\n\n\treturn sprintf(buf, \"%lld\\n\", value);\n}\n\nstatic void atk_init_attribute(struct device_attribute *attr, char *name,\n\t\tsysfs_show_func show)\n{\n\tsysfs_attr_init(&attr->attr);\n\tattr->attr.name = name;\n\tattr->attr.mode = 0444;\n\tattr->show = show;\n\tattr->store = NULL;\n}\n\n\nstatic union acpi_object *atk_get_pack_member(struct atk_data *data,\n\t\t\t\t\t\tunion acpi_object *pack,\n\t\t\t\t\t\tenum atk_pack_member m)\n{\n\tbool old_if = data->old_interface;\n\tint offset;\n\n\tswitch (m) {\n\tcase HWMON_PACK_FLAGS:\n\t\toffset = old_if ? _HWMON_OLD_PACK_FLAGS : _HWMON_NEW_PACK_FLAGS;\n\t\tbreak;\n\tcase HWMON_PACK_NAME:\n\t\toffset = old_if ? _HWMON_OLD_PACK_NAME : _HWMON_NEW_PACK_NAME;\n\t\tbreak;\n\tcase HWMON_PACK_LIMIT1:\n\t\toffset = old_if ? _HWMON_OLD_PACK_LIMIT1 :\n\t\t\t\t  _HWMON_NEW_PACK_LIMIT1;\n\t\tbreak;\n\tcase HWMON_PACK_LIMIT2:\n\t\toffset = old_if ? _HWMON_OLD_PACK_LIMIT2 :\n\t\t\t\t  _HWMON_NEW_PACK_LIMIT2;\n\t\tbreak;\n\tcase HWMON_PACK_ENABLE:\n\t\toffset = old_if ? _HWMON_OLD_PACK_ENABLE :\n\t\t\t\t  _HWMON_NEW_PACK_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn &pack->package.elements[offset];\n}\n\n\n \nstatic int validate_hwmon_pack(struct atk_data *data, union acpi_object *obj)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\tunion acpi_object *tmp;\n\tbool old_if = data->old_interface;\n\tint const expected_size = old_if ? _HWMON_OLD_PACK_SIZE :\n\t\t\t\t\t   _HWMON_NEW_PACK_SIZE;\n\n\tif (obj->type != ACPI_TYPE_PACKAGE) {\n\t\tdev_warn(dev, \"Invalid type: %d\\n\", obj->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (obj->package.count != expected_size) {\n\t\tdev_warn(dev, \"Invalid package size: %d, expected: %d\\n\",\n\t\t\t\tobj->package.count, expected_size);\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = atk_get_pack_member(data, obj, HWMON_PACK_FLAGS);\n\tif (tmp->type != ACPI_TYPE_INTEGER) {\n\t\tdev_warn(dev, \"Invalid type (flag): %d\\n\", tmp->type);\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = atk_get_pack_member(data, obj, HWMON_PACK_NAME);\n\tif (tmp->type != ACPI_TYPE_STRING) {\n\t\tdev_warn(dev, \"Invalid type (name): %d\\n\", tmp->type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n#if 0\n\ttmp = &obj->package.elements[HWMON_PACK_UNK1];\n\tif (tmp->type != ACPI_TYPE_INTEGER) {\n\t\tdev_warn(dev, \"Invalid type (unk1): %d\\n\", tmp->type);\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = &obj->package.elements[HWMON_PACK_UNK2];\n\tif (tmp->type != ACPI_TYPE_INTEGER) {\n\t\tdev_warn(dev, \"Invalid type (unk2): %d\\n\", tmp->type);\n\t\treturn -EINVAL;\n\t}\n#endif\n\n\ttmp = atk_get_pack_member(data, obj, HWMON_PACK_LIMIT1);\n\tif (tmp->type != ACPI_TYPE_INTEGER) {\n\t\tdev_warn(dev, \"Invalid type (limit1): %d\\n\", tmp->type);\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = atk_get_pack_member(data, obj, HWMON_PACK_LIMIT2);\n\tif (tmp->type != ACPI_TYPE_INTEGER) {\n\t\tdev_warn(dev, \"Invalid type (limit2): %d\\n\", tmp->type);\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = atk_get_pack_member(data, obj, HWMON_PACK_ENABLE);\n\tif (tmp->type != ACPI_TYPE_INTEGER) {\n\t\tdev_warn(dev, \"Invalid type (enable): %d\\n\", tmp->type);\n\t\treturn -EINVAL;\n\t}\n\n\tatk_print_sensor(data, obj);\n\n\treturn 0;\n}\n\n#ifdef DEBUG\nstatic char const *atk_sensor_type(union acpi_object *flags)\n{\n\tu64 type = flags->integer.value & ATK_TYPE_MASK;\n\tchar const *what;\n\n\tswitch (type) {\n\tcase HWMON_TYPE_VOLT:\n\t\twhat = \"voltage\";\n\t\tbreak;\n\tcase HWMON_TYPE_TEMP:\n\t\twhat = \"temperature\";\n\t\tbreak;\n\tcase HWMON_TYPE_FAN:\n\t\twhat = \"fan\";\n\t\tbreak;\n\tdefault:\n\t\twhat = \"unknown\";\n\t\tbreak;\n\t}\n\n\treturn what;\n}\n#endif\n\nstatic void atk_print_sensor(struct atk_data *data, union acpi_object *obj)\n{\n#ifdef DEBUG\n\tstruct device *dev = &data->acpi_dev->dev;\n\tunion acpi_object *flags;\n\tunion acpi_object *name;\n\tunion acpi_object *limit1;\n\tunion acpi_object *limit2;\n\tunion acpi_object *enable;\n\tchar const *what;\n\n\tflags = atk_get_pack_member(data, obj, HWMON_PACK_FLAGS);\n\tname = atk_get_pack_member(data, obj, HWMON_PACK_NAME);\n\tlimit1 = atk_get_pack_member(data, obj, HWMON_PACK_LIMIT1);\n\tlimit2 = atk_get_pack_member(data, obj, HWMON_PACK_LIMIT2);\n\tenable = atk_get_pack_member(data, obj, HWMON_PACK_ENABLE);\n\n\twhat = atk_sensor_type(flags);\n\n\tdev_dbg(dev, \"%s: %#llx %s [%llu-%llu] %s\\n\", what,\n\t\t\tflags->integer.value,\n\t\t\tname->string.pointer,\n\t\t\tlimit1->integer.value, limit2->integer.value,\n\t\t\tenable->integer.value ? \"enabled\" : \"disabled\");\n#endif\n}\n\nstatic int atk_read_value_old(struct atk_sensor_data *sensor, u64 *value)\n{\n\tstruct atk_data *data = sensor->data;\n\tstruct device *dev = &data->acpi_dev->dev;\n\tstruct acpi_object_list params;\n\tunion acpi_object id;\n\tacpi_status status;\n\tacpi_handle method;\n\n\tswitch (sensor->type) {\n\tcase HWMON_TYPE_VOLT:\n\t\tmethod = data->rvlt_handle;\n\t\tbreak;\n\tcase HWMON_TYPE_TEMP:\n\t\tmethod = data->rtmp_handle;\n\t\tbreak;\n\tcase HWMON_TYPE_FAN:\n\t\tmethod = data->rfan_handle;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tid.type = ACPI_TYPE_INTEGER;\n\tid.integer.value = sensor->id;\n\n\tparams.count = 1;\n\tparams.pointer = &id;\n\n\tstatus = acpi_evaluate_integer(method, NULL, &params, value);\n\tif (status != AE_OK) {\n\t\tdev_warn(dev, \"%s: ACPI exception: %s\\n\", __func__,\n\t\t\t\tacpi_format_exception(status));\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic union acpi_object *atk_ggrp(struct atk_data *data, u16 mux)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\tstruct acpi_buffer buf;\n\tacpi_status ret;\n\tstruct acpi_object_list params;\n\tunion acpi_object id;\n\tunion acpi_object *pack;\n\n\tid.type = ACPI_TYPE_INTEGER;\n\tid.integer.value = mux;\n\tparams.count = 1;\n\tparams.pointer = &id;\n\n\tbuf.length = ACPI_ALLOCATE_BUFFER;\n\tret = acpi_evaluate_object(data->enumerate_handle, NULL, &params, &buf);\n\tif (ret != AE_OK) {\n\t\tdev_err(dev, \"GGRP[%#x] ACPI exception: %s\\n\", mux,\n\t\t\t\tacpi_format_exception(ret));\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tpack = buf.pointer;\n\tif (pack->type != ACPI_TYPE_PACKAGE) {\n\t\t \n\t\tACPI_FREE(pack);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (pack->package.count < 1) {\n\t\tdev_err(dev, \"GGRP[%#x] package is too small\\n\", mux);\n\t\tACPI_FREE(pack);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn pack;\n}\n\nstatic union acpi_object *atk_gitm(struct atk_data *data, u64 id)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\tstruct atk_acpi_input_buf buf;\n\tunion acpi_object tmp;\n\tstruct acpi_object_list params;\n\tstruct acpi_buffer ret;\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tbuf.id = id;\n\tbuf.param1 = 0;\n\tbuf.param2 = 0;\n\n\ttmp.type = ACPI_TYPE_BUFFER;\n\ttmp.buffer.pointer = (u8 *)&buf;\n\ttmp.buffer.length = sizeof(buf);\n\n\tparams.count = 1;\n\tparams.pointer = (void *)&tmp;\n\n\tret.length = ACPI_ALLOCATE_BUFFER;\n\tstatus = acpi_evaluate_object_typed(data->read_handle, NULL, &params,\n\t\t\t&ret, ACPI_TYPE_BUFFER);\n\tif (status != AE_OK) {\n\t\tdev_warn(dev, \"GITM[%#llx] ACPI exception: %s\\n\", id,\n\t\t\t\tacpi_format_exception(status));\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tobj = ret.pointer;\n\n\t \n\tif (obj->buffer.length < 8) {\n\t\tdev_warn(dev, \"Unexpected ASBF length: %u\\n\",\n\t\t\t\tobj->buffer.length);\n\t\tACPI_FREE(obj);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn obj;\n}\n\nstatic union acpi_object *atk_sitm(struct atk_data *data,\n\t\tstruct atk_acpi_input_buf *buf)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\tstruct acpi_object_list params;\n\tunion acpi_object tmp;\n\tstruct acpi_buffer ret;\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\ttmp.type = ACPI_TYPE_BUFFER;\n\ttmp.buffer.pointer = (u8 *)buf;\n\ttmp.buffer.length = sizeof(*buf);\n\n\tparams.count = 1;\n\tparams.pointer = &tmp;\n\n\tret.length = ACPI_ALLOCATE_BUFFER;\n\tstatus = acpi_evaluate_object_typed(data->write_handle, NULL, &params,\n\t\t\t&ret, ACPI_TYPE_BUFFER);\n\tif (status != AE_OK) {\n\t\tdev_warn(dev, \"SITM[%#x] ACPI exception: %s\\n\", buf->id,\n\t\t\t\tacpi_format_exception(status));\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tobj = ret.pointer;\n\n\t \n\tif (obj->buffer.length < 8) {\n\t\tdev_warn(dev, \"Unexpected ASBF length: %u\\n\",\n\t\t\t\tobj->buffer.length);\n\t\tACPI_FREE(obj);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn obj;\n}\n\nstatic int atk_read_value_new(struct atk_sensor_data *sensor, u64 *value)\n{\n\tstruct atk_data *data = sensor->data;\n\tstruct device *dev = &data->acpi_dev->dev;\n\tunion acpi_object *obj;\n\tstruct atk_acpi_ret_buffer *buf;\n\tint err = 0;\n\n\tobj = atk_gitm(data, sensor->id);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tbuf = (struct atk_acpi_ret_buffer *)obj->buffer.pointer;\n\tif (buf->flags == 0) {\n\t\t \n\t\tdev_warn(dev, \"Read failed, sensor = %#llx\\n\", sensor->id);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\t*value = buf->value;\nout:\n\tACPI_FREE(obj);\n\treturn err;\n}\n\nstatic int atk_read_value(struct atk_sensor_data *sensor, u64 *value)\n{\n\tint err;\n\n\tif (!sensor->is_valid ||\n\t    time_after(jiffies, sensor->last_updated + CACHE_TIME)) {\n\t\tif (sensor->data->old_interface)\n\t\t\terr = atk_read_value_old(sensor, value);\n\t\telse\n\t\t\terr = atk_read_value_new(sensor, value);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tsensor->is_valid = true;\n\t\tsensor->last_updated = jiffies;\n\t\tsensor->cached_value = *value;\n\t} else {\n\t\t*value = sensor->cached_value;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int atk_debugfs_gitm_get(void *p, u64 *val)\n{\n\tstruct atk_data *data = p;\n\tunion acpi_object *ret;\n\tstruct atk_acpi_ret_buffer *buf;\n\tint err = 0;\n\n\tif (!data->read_handle)\n\t\treturn -ENODEV;\n\n\tif (!data->debugfs.id)\n\t\treturn -EINVAL;\n\n\tret = atk_gitm(data, data->debugfs.id);\n\tif (IS_ERR(ret))\n\t\treturn PTR_ERR(ret);\n\n\tbuf = (struct atk_acpi_ret_buffer *)ret->buffer.pointer;\n\tif (buf->flags)\n\t\t*val = buf->value;\n\telse\n\t\terr = -EIO;\n\n\tACPI_FREE(ret);\n\treturn err;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(atk_debugfs_gitm, atk_debugfs_gitm_get, NULL,\n\t\t\t \"0x%08llx\\n\");\n\nstatic int atk_acpi_print(char *buf, size_t sz, union acpi_object *obj)\n{\n\tint ret = 0;\n\n\tswitch (obj->type) {\n\tcase ACPI_TYPE_INTEGER:\n\t\tret = snprintf(buf, sz, \"0x%08llx\\n\", obj->integer.value);\n\t\tbreak;\n\tcase ACPI_TYPE_STRING:\n\t\tret = snprintf(buf, sz, \"%s\\n\", obj->string.pointer);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void atk_pack_print(char *buf, size_t sz, union acpi_object *pack)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < pack->package.count; i++) {\n\t\tunion acpi_object *obj = &pack->package.elements[i];\n\n\t\tret = atk_acpi_print(buf, sz, obj);\n\t\tif (ret >= sz)\n\t\t\tbreak;\n\t\tbuf += ret;\n\t\tsz -= ret;\n\t}\n}\n\nstatic int atk_debugfs_ggrp_open(struct inode *inode, struct file *file)\n{\n\tstruct atk_data *data = inode->i_private;\n\tchar *buf = NULL;\n\tunion acpi_object *ret;\n\tu8 cls;\n\tint i;\n\n\tif (!data->enumerate_handle)\n\t\treturn -ENODEV;\n\tif (!data->debugfs.id)\n\t\treturn -EINVAL;\n\n\tcls = (data->debugfs.id & 0xff000000) >> 24;\n\tret = atk_ggrp(data, cls);\n\tif (IS_ERR(ret))\n\t\treturn PTR_ERR(ret);\n\n\tfor (i = 0; i < ret->package.count; i++) {\n\t\tunion acpi_object *pack = &ret->package.elements[i];\n\t\tunion acpi_object *id;\n\n\t\tif (pack->type != ACPI_TYPE_PACKAGE)\n\t\t\tcontinue;\n\t\tif (!pack->package.count)\n\t\t\tcontinue;\n\t\tid = &pack->package.elements[0];\n\t\tif (id->integer.value == data->debugfs.id) {\n\t\t\t \n\t\t\tbuf = kzalloc(512, GFP_KERNEL);\n\t\t\tif (!buf) {\n\t\t\t\tACPI_FREE(ret);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tatk_pack_print(buf, 512, pack);\n\t\t\tbreak;\n\t\t}\n\t}\n\tACPI_FREE(ret);\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tfile->private_data = buf;\n\n\treturn nonseekable_open(inode, file);\n}\n\nstatic ssize_t atk_debugfs_ggrp_read(struct file *file, char __user *buf,\n\t\tsize_t count, loff_t *pos)\n{\n\tchar *str = file->private_data;\n\tsize_t len = strlen(str);\n\n\treturn simple_read_from_buffer(buf, count, pos, str, len);\n}\n\nstatic int atk_debugfs_ggrp_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}\n\nstatic const struct file_operations atk_debugfs_ggrp_fops = {\n\t.read\t\t= atk_debugfs_ggrp_read,\n\t.open\t\t= atk_debugfs_ggrp_open,\n\t.release\t= atk_debugfs_ggrp_release,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic void atk_debugfs_init(struct atk_data *data)\n{\n\tstruct dentry *d;\n\n\tdata->debugfs.id = 0;\n\n\td = debugfs_create_dir(\"asus_atk0110\", NULL);\n\n\tdebugfs_create_x32(\"id\", 0600, d, &data->debugfs.id);\n\tdebugfs_create_file_unsafe(\"gitm\", 0400, d, data, &atk_debugfs_gitm);\n\tdebugfs_create_file(\"ggrp\", 0400, d, data, &atk_debugfs_ggrp_fops);\n\n\tdata->debugfs.root = d;\n}\n\nstatic void atk_debugfs_cleanup(struct atk_data *data)\n{\n\tdebugfs_remove_recursive(data->debugfs.root);\n}\n\n#else  \n\nstatic void atk_debugfs_init(struct atk_data *data)\n{\n}\n\nstatic void atk_debugfs_cleanup(struct atk_data *data)\n{\n}\n#endif\n\nstatic int atk_add_sensor(struct atk_data *data, union acpi_object *obj)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\tunion acpi_object *flags;\n\tunion acpi_object *name;\n\tunion acpi_object *limit1;\n\tunion acpi_object *limit2;\n\tunion acpi_object *enable;\n\tstruct atk_sensor_data *sensor;\n\tchar const *base_name;\n\tchar const *limit1_name;\n\tchar const *limit2_name;\n\tu64 type;\n\tint err;\n\tint *num;\n\tint start;\n\n\tif (obj->type != ACPI_TYPE_PACKAGE) {\n\t\t \n\t\tdev_warn(dev, \"Unknown type for ACPI object: (%d)\\n\",\n\t\t\t\tobj->type);\n\t\treturn -EINVAL;\n\t}\n\n\terr = validate_hwmon_pack(data, obj);\n\tif (err)\n\t\treturn err;\n\n\t \n\ttype = atk_get_pack_member(data, obj, HWMON_PACK_FLAGS)->integer.value\n\t       & ATK_TYPE_MASK;\n\n\tswitch (type) {\n\tcase HWMON_TYPE_VOLT:\n\t\tbase_name = \"in\";\n\t\tlimit1_name = \"min\";\n\t\tlimit2_name = \"max\";\n\t\tnum = &data->voltage_count;\n\t\tstart = 0;\n\t\tbreak;\n\tcase HWMON_TYPE_TEMP:\n\t\tbase_name = \"temp\";\n\t\tlimit1_name = \"max\";\n\t\tlimit2_name = \"crit\";\n\t\tnum = &data->temperature_count;\n\t\tstart = 1;\n\t\tbreak;\n\tcase HWMON_TYPE_FAN:\n\t\tbase_name = \"fan\";\n\t\tlimit1_name = \"min\";\n\t\tlimit2_name = \"max\";\n\t\tnum = &data->fan_count;\n\t\tstart = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"Unknown sensor type: %#llx\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tenable = atk_get_pack_member(data, obj, HWMON_PACK_ENABLE);\n\tif (!enable->integer.value)\n\t\t \n\t\treturn 0;\n\n\tflags = atk_get_pack_member(data, obj, HWMON_PACK_FLAGS);\n\tname = atk_get_pack_member(data, obj, HWMON_PACK_NAME);\n\tlimit1 = atk_get_pack_member(data, obj, HWMON_PACK_LIMIT1);\n\tlimit2 = atk_get_pack_member(data, obj, HWMON_PACK_LIMIT2);\n\n\tsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tsensor->acpi_name = devm_kstrdup(dev, name->string.pointer, GFP_KERNEL);\n\tif (!sensor->acpi_name)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&sensor->list);\n\tsensor->type = type;\n\tsensor->data = data;\n\tsensor->id = flags->integer.value;\n\tsensor->limit1 = limit1->integer.value;\n\tif (data->old_interface)\n\t\tsensor->limit2 = limit2->integer.value;\n\telse\n\t\t \n\t\tsensor->limit2 = sensor->limit1 + limit2->integer.value;\n\n\tsnprintf(sensor->input_attr_name, ATTR_NAME_SIZE,\n\t\t\t\"%s%d_input\", base_name, start + *num);\n\tatk_init_attribute(&sensor->input_attr,\n\t\t\tsensor->input_attr_name,\n\t\t\tatk_input_show);\n\n\tsnprintf(sensor->label_attr_name, ATTR_NAME_SIZE,\n\t\t\t\"%s%d_label\", base_name, start + *num);\n\tatk_init_attribute(&sensor->label_attr,\n\t\t\tsensor->label_attr_name,\n\t\t\tatk_label_show);\n\n\tsnprintf(sensor->limit1_attr_name, ATTR_NAME_SIZE,\n\t\t\t\"%s%d_%s\", base_name, start + *num, limit1_name);\n\tatk_init_attribute(&sensor->limit1_attr,\n\t\t\tsensor->limit1_attr_name,\n\t\t\tatk_limit1_show);\n\n\tsnprintf(sensor->limit2_attr_name, ATTR_NAME_SIZE,\n\t\t\t\"%s%d_%s\", base_name, start + *num, limit2_name);\n\tatk_init_attribute(&sensor->limit2_attr,\n\t\t\tsensor->limit2_attr_name,\n\t\t\tatk_limit2_show);\n\n\tlist_add(&sensor->list, &data->sensor_list);\n\t(*num)++;\n\n\treturn 1;\n}\n\nstatic int atk_enumerate_old_hwmon(struct atk_data *data)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\tstruct acpi_buffer buf;\n\tunion acpi_object *pack;\n\tacpi_status status;\n\tint i, ret;\n\tint count = 0;\n\n\t \n\tbuf.length = ACPI_ALLOCATE_BUFFER;\n\tstatus = acpi_evaluate_object_typed(data->atk_handle,\n\t\t\tMETHOD_OLD_ENUM_VLT, NULL, &buf, ACPI_TYPE_PACKAGE);\n\tif (status != AE_OK) {\n\t\tdev_warn(dev, METHOD_OLD_ENUM_VLT \": ACPI exception: %s\\n\",\n\t\t\t\tacpi_format_exception(status));\n\n\t\treturn -ENODEV;\n\t}\n\n\tpack = buf.pointer;\n\tfor (i = 1; i < pack->package.count; i++) {\n\t\tunion acpi_object *obj = &pack->package.elements[i];\n\n\t\tret = atk_add_sensor(data, obj);\n\t\tif (ret > 0)\n\t\t\tcount++;\n\t}\n\tACPI_FREE(buf.pointer);\n\n\t \n\tbuf.length = ACPI_ALLOCATE_BUFFER;\n\tstatus = acpi_evaluate_object_typed(data->atk_handle,\n\t\t\tMETHOD_OLD_ENUM_TMP, NULL, &buf, ACPI_TYPE_PACKAGE);\n\tif (status != AE_OK) {\n\t\tdev_warn(dev, METHOD_OLD_ENUM_TMP \": ACPI exception: %s\\n\",\n\t\t\t\tacpi_format_exception(status));\n\n\t\treturn -ENODEV;\n\t}\n\n\tpack = buf.pointer;\n\tfor (i = 1; i < pack->package.count; i++) {\n\t\tunion acpi_object *obj = &pack->package.elements[i];\n\n\t\tret = atk_add_sensor(data, obj);\n\t\tif (ret > 0)\n\t\t\tcount++;\n\t}\n\tACPI_FREE(buf.pointer);\n\n\t \n\tbuf.length = ACPI_ALLOCATE_BUFFER;\n\tstatus = acpi_evaluate_object_typed(data->atk_handle,\n\t\t\tMETHOD_OLD_ENUM_FAN, NULL, &buf, ACPI_TYPE_PACKAGE);\n\tif (status != AE_OK) {\n\t\tdev_warn(dev, METHOD_OLD_ENUM_FAN \": ACPI exception: %s\\n\",\n\t\t\t\tacpi_format_exception(status));\n\n\t\treturn -ENODEV;\n\t}\n\n\tpack = buf.pointer;\n\tfor (i = 1; i < pack->package.count; i++) {\n\t\tunion acpi_object *obj = &pack->package.elements[i];\n\n\t\tret = atk_add_sensor(data, obj);\n\t\tif (ret > 0)\n\t\t\tcount++;\n\t}\n\tACPI_FREE(buf.pointer);\n\n\treturn count;\n}\n\nstatic int atk_ec_present(struct atk_data *data)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\tunion acpi_object *pack;\n\tunion acpi_object *ec;\n\tint ret;\n\tint i;\n\n\tpack = atk_ggrp(data, ATK_MUX_MGMT);\n\tif (IS_ERR(pack)) {\n\t\tif (PTR_ERR(pack) == -ENOENT) {\n\t\t\t \n\t\t\tdev_dbg(dev, \"Class %#llx not found\\n\", ATK_MUX_MGMT);\n\t\t\treturn 0;\n\t\t}\n\t\treturn PTR_ERR(pack);\n\t}\n\n\t \n\tec = NULL;\n\tfor (i = 0; i < pack->package.count; i++) {\n\t\tunion acpi_object *obj = &pack->package.elements[i];\n\t\tunion acpi_object *id;\n\n\t\tif (obj->type != ACPI_TYPE_PACKAGE)\n\t\t\tcontinue;\n\n\t\tid = &obj->package.elements[0];\n\t\tif (id->type != ACPI_TYPE_INTEGER)\n\t\t\tcontinue;\n\n\t\tif (id->integer.value == ATK_EC_ID) {\n\t\t\tec = obj;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = (ec != NULL);\n\tif (!ret)\n\t\t \n\t\tdev_dbg(dev, \"EC not found\\n\");\n\n\tACPI_FREE(pack);\n\treturn ret;\n}\n\nstatic int atk_ec_enabled(struct atk_data *data)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\tunion acpi_object *obj;\n\tstruct atk_acpi_ret_buffer *buf;\n\tint err;\n\n\tobj = atk_gitm(data, ATK_EC_ID);\n\tif (IS_ERR(obj)) {\n\t\tdev_err(dev, \"Unable to query EC status\\n\");\n\t\treturn PTR_ERR(obj);\n\t}\n\tbuf = (struct atk_acpi_ret_buffer *)obj->buffer.pointer;\n\n\tif (buf->flags == 0) {\n\t\tdev_err(dev, \"Unable to query EC status\\n\");\n\t\terr = -EIO;\n\t} else {\n\t\terr = (buf->value != 0);\n\t\tdev_dbg(dev, \"EC is %sabled\\n\",\n\t\t\t\terr ? \"en\" : \"dis\");\n\t}\n\n\tACPI_FREE(obj);\n\treturn err;\n}\n\nstatic int atk_ec_ctl(struct atk_data *data, int enable)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\tunion acpi_object *obj;\n\tstruct atk_acpi_input_buf sitm;\n\tstruct atk_acpi_ret_buffer *ec_ret;\n\tint err = 0;\n\n\tsitm.id = ATK_EC_ID;\n\tsitm.param1 = enable;\n\tsitm.param2 = 0;\n\n\tobj = atk_sitm(data, &sitm);\n\tif (IS_ERR(obj)) {\n\t\tdev_err(dev, \"Failed to %sable the EC\\n\",\n\t\t\t\tenable ? \"en\" : \"dis\");\n\t\treturn PTR_ERR(obj);\n\t}\n\tec_ret = (struct atk_acpi_ret_buffer *)obj->buffer.pointer;\n\tif (ec_ret->flags == 0) {\n\t\tdev_err(dev, \"Failed to %sable the EC\\n\",\n\t\t\t\tenable ? \"en\" : \"dis\");\n\t\terr = -EIO;\n\t} else {\n\t\tdev_info(dev, \"EC %sabled\\n\",\n\t\t\t\tenable ? \"en\" : \"dis\");\n\t}\n\n\tACPI_FREE(obj);\n\treturn err;\n}\n\nstatic int atk_enumerate_new_hwmon(struct atk_data *data)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\tunion acpi_object *pack;\n\tint err;\n\tint i;\n\n\terr = atk_ec_present(data);\n\tif (err < 0)\n\t\treturn err;\n\tif (err) {\n\t\terr = atk_ec_enabled(data);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t \n\t\tdata->disable_ec = err;\n\n\t\terr = atk_ec_ctl(data, 1);\n\t\tif (err) {\n\t\t\tdata->disable_ec = false;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"Enumerating hwmon sensors\\n\");\n\n\tpack = atk_ggrp(data, ATK_MUX_HWMON);\n\tif (IS_ERR(pack))\n\t\treturn PTR_ERR(pack);\n\n\tfor (i = 0; i < pack->package.count; i++) {\n\t\tunion acpi_object *obj = &pack->package.elements[i];\n\n\t\tatk_add_sensor(data, obj);\n\t}\n\n\terr = data->voltage_count + data->temperature_count + data->fan_count;\n\n\tACPI_FREE(pack);\n\treturn err;\n}\n\nstatic int atk_init_attribute_groups(struct atk_data *data)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\tstruct atk_sensor_data *s;\n\tstruct attribute **attrs;\n\tint i = 0;\n\tint len = (data->voltage_count + data->temperature_count\n\t\t\t+ data->fan_count) * 4 + 1;\n\n\tattrs = devm_kcalloc(dev, len, sizeof(struct attribute *), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(s, &data->sensor_list, list) {\n\t\tattrs[i++] = &s->input_attr.attr;\n\t\tattrs[i++] = &s->label_attr.attr;\n\t\tattrs[i++] = &s->limit1_attr.attr;\n\t\tattrs[i++] = &s->limit2_attr.attr;\n\t}\n\n\tdata->attr_group.attrs = attrs;\n\tdata->attr_groups[0] = &data->attr_group;\n\n\treturn 0;\n}\n\nstatic int atk_register_hwmon(struct atk_data *data)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\n\tdev_dbg(dev, \"registering hwmon device\\n\");\n\tdata->hwmon_dev = hwmon_device_register_with_groups(dev, \"atk0110\",\n\t\t\t\t\t\t\t    data,\n\t\t\t\t\t\t\t    data->attr_groups);\n\n\treturn PTR_ERR_OR_ZERO(data->hwmon_dev);\n}\n\nstatic int atk_probe_if(struct atk_data *data)\n{\n\tstruct device *dev = &data->acpi_dev->dev;\n\tacpi_handle ret;\n\tacpi_status status;\n\tint err = 0;\n\n\t \n\tstatus = acpi_get_handle(data->atk_handle, METHOD_OLD_READ_TMP, &ret);\n\tif (ACPI_SUCCESS(status))\n\t\tdata->rtmp_handle = ret;\n\telse\n\t\tdev_dbg(dev, \"method \" METHOD_OLD_READ_TMP \" not found: %s\\n\",\n\t\t\t\tacpi_format_exception(status));\n\n\t \n\tstatus = acpi_get_handle(data->atk_handle, METHOD_OLD_READ_VLT, &ret);\n\tif (ACPI_SUCCESS(status))\n\t\tdata->rvlt_handle = ret;\n\telse\n\t\tdev_dbg(dev, \"method \" METHOD_OLD_READ_VLT \" not found: %s\\n\",\n\t\t\t\tacpi_format_exception(status));\n\n\t \n\tstatus = acpi_get_handle(data->atk_handle, METHOD_OLD_READ_FAN, &ret);\n\tif (ACPI_SUCCESS(status))\n\t\tdata->rfan_handle = ret;\n\telse\n\t\tdev_dbg(dev, \"method \" METHOD_OLD_READ_FAN \" not found: %s\\n\",\n\t\t\t\tacpi_format_exception(status));\n\n\t \n\tstatus = acpi_get_handle(data->atk_handle, METHOD_ENUMERATE, &ret);\n\tif (ACPI_SUCCESS(status))\n\t\tdata->enumerate_handle = ret;\n\telse\n\t\tdev_dbg(dev, \"method \" METHOD_ENUMERATE \" not found: %s\\n\",\n\t\t\t\tacpi_format_exception(status));\n\n\t \n\tstatus = acpi_get_handle(data->atk_handle, METHOD_READ, &ret);\n\tif (ACPI_SUCCESS(status))\n\t\tdata->read_handle = ret;\n\telse\n\t\tdev_dbg(dev, \"method \" METHOD_READ \" not found: %s\\n\",\n\t\t\t\tacpi_format_exception(status));\n\n\t \n\tstatus = acpi_get_handle(data->atk_handle, METHOD_WRITE, &ret);\n\tif (ACPI_SUCCESS(status))\n\t\tdata->write_handle = ret;\n\telse\n\t\tdev_dbg(dev, \"method \" METHOD_WRITE \" not found: %s\\n\",\n\t\t\t\t acpi_format_exception(status));\n\n\t \n\tif (new_if)\n\t\tdev_info(dev, \"Overriding interface detection\\n\");\n\tif (data->rtmp_handle &&\n\t\t\tdata->rvlt_handle && data->rfan_handle && !new_if)\n\t\tdata->old_interface = true;\n\telse if (data->enumerate_handle && data->read_handle &&\n\t\t\tdata->write_handle)\n\t\tdata->old_interface = false;\n\telse\n\t\terr = -ENODEV;\n\n\treturn err;\n}\n\nstatic int atk_add(struct acpi_device *device)\n{\n\tacpi_status ret;\n\tint err;\n\tstruct acpi_buffer buf;\n\tunion acpi_object *obj;\n\tstruct atk_data *data;\n\n\tdev_dbg(&device->dev, \"adding...\\n\");\n\n\tdata = devm_kzalloc(&device->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->acpi_dev = device;\n\tdata->atk_handle = device->handle;\n\tINIT_LIST_HEAD(&data->sensor_list);\n\tdata->disable_ec = false;\n\n\tbuf.length = ACPI_ALLOCATE_BUFFER;\n\tret = acpi_evaluate_object_typed(data->atk_handle, BOARD_ID, NULL,\n\t\t\t&buf, ACPI_TYPE_PACKAGE);\n\tif (ret != AE_OK) {\n\t\tdev_dbg(&device->dev, \"atk: method MBIF not found\\n\");\n\t} else {\n\t\tobj = buf.pointer;\n\t\tif (obj->package.count >= 2) {\n\t\t\tunion acpi_object *id = &obj->package.elements[1];\n\t\t\tif (id->type == ACPI_TYPE_STRING)\n\t\t\t\tdev_dbg(&device->dev, \"board ID = %s\\n\",\n\t\t\t\t\tid->string.pointer);\n\t\t}\n\t\tACPI_FREE(buf.pointer);\n\t}\n\n\terr = atk_probe_if(data);\n\tif (err) {\n\t\tdev_err(&device->dev, \"No usable hwmon interface detected\\n\");\n\t\tgoto out;\n\t}\n\n\tif (data->old_interface) {\n\t\tdev_dbg(&device->dev, \"Using old hwmon interface\\n\");\n\t\terr = atk_enumerate_old_hwmon(data);\n\t} else {\n\t\tdev_dbg(&device->dev, \"Using new hwmon interface\\n\");\n\t\terr = atk_enumerate_new_hwmon(data);\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\tif (err == 0) {\n\t\tdev_info(&device->dev,\n\t\t\t \"No usable sensor detected, bailing out\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\terr = atk_init_attribute_groups(data);\n\tif (err)\n\t\tgoto out;\n\terr = atk_register_hwmon(data);\n\tif (err)\n\t\tgoto out;\n\n\tatk_debugfs_init(data);\n\n\tdevice->driver_data = data;\n\treturn 0;\nout:\n\tif (data->disable_ec)\n\t\tatk_ec_ctl(data, 0);\n\treturn err;\n}\n\nstatic void atk_remove(struct acpi_device *device)\n{\n\tstruct atk_data *data = device->driver_data;\n\tdev_dbg(&device->dev, \"removing...\\n\");\n\n\tdevice->driver_data = NULL;\n\n\tatk_debugfs_cleanup(data);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\n\tif (data->disable_ec) {\n\t\tif (atk_ec_ctl(data, 0))\n\t\t\tdev_err(&device->dev, \"Failed to disable EC\\n\");\n\t}\n}\n\nstatic int __init atk0110_init(void)\n{\n\tint ret;\n\n\t \n\tif (!acpi_resources_are_enforced()) {\n\t\tpr_err(\"Resources not safely usable due to acpi_enforce_resources kernel parameter\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (dmi_check_system(atk_force_new_if))\n\t\tnew_if = true;\n\n\tret = acpi_bus_register_driver(&atk_driver);\n\tif (ret)\n\t\tpr_info(\"acpi_bus_register_driver failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void __exit atk0110_exit(void)\n{\n\tacpi_bus_unregister_driver(&atk_driver);\n}\n\nmodule_init(atk0110_init);\nmodule_exit(atk0110_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}