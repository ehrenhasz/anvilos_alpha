{
  "module_name": "it87.c",
  "hash_id": "063e7affdde57be5cfaa492043dbac99b1fb7b5b6253cd44d02f86d4aee0f8f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/it87.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon-vid.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/string.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\n#define DRVNAME \"it87\"\n\nenum chips { it87, it8712, it8716, it8718, it8720, it8721, it8728, it8732,\n\t     it8771, it8772, it8781, it8782, it8783, it8786, it8790,\n\t     it8792, it8603, it8620, it8622, it8628, it87952 };\n\nstatic struct platform_device *it87_pdev[2];\n\n#define\tREG_2E\t0x2e\t \n#define\tREG_4E\t0x4e\t \n\n#define\tDEV\t0x07\t \n#define PME\t0x04\t \n\n \n#define GPIO\t0x07\n\n#define\tDEVID\t0x20\t \n#define\tDEVREV\t0x22\t \n\nstatic inline void __superio_enter(int ioreg)\n{\n\toutb(0x87, ioreg);\n\toutb(0x01, ioreg);\n\toutb(0x55, ioreg);\n\toutb(ioreg == REG_4E ? 0xaa : 0x55, ioreg);\n}\n\nstatic inline int superio_inb(int ioreg, int reg)\n{\n\toutb(reg, ioreg);\n\treturn inb(ioreg + 1);\n}\n\nstatic inline void superio_outb(int ioreg, int reg, int val)\n{\n\toutb(reg, ioreg);\n\toutb(val, ioreg + 1);\n}\n\nstatic int superio_inw(int ioreg, int reg)\n{\n\tint val;\n\n\toutb(reg++, ioreg);\n\tval = inb(ioreg + 1) << 8;\n\toutb(reg, ioreg);\n\tval |= inb(ioreg + 1);\n\treturn val;\n}\n\nstatic inline void superio_select(int ioreg, int ldn)\n{\n\toutb(DEV, ioreg);\n\toutb(ldn, ioreg + 1);\n}\n\nstatic inline int superio_enter(int ioreg)\n{\n\t \n\tif (!request_muxed_region(ioreg, 2, DRVNAME))\n\t\treturn -EBUSY;\n\n\t__superio_enter(ioreg);\n\treturn 0;\n}\n\nstatic inline void superio_exit(int ioreg, bool noexit)\n{\n\tif (!noexit) {\n\t\toutb(0x02, ioreg);\n\t\toutb(0x02, ioreg + 1);\n\t}\n\trelease_region(ioreg, 2);\n}\n\n \n#define IT8712F_DEVID 0x8712\n#define IT8705F_DEVID 0x8705\n#define IT8716F_DEVID 0x8716\n#define IT8718F_DEVID 0x8718\n#define IT8720F_DEVID 0x8720\n#define IT8721F_DEVID 0x8721\n#define IT8726F_DEVID 0x8726\n#define IT8728F_DEVID 0x8728\n#define IT8732F_DEVID 0x8732\n#define IT8792E_DEVID 0x8733\n#define IT8771E_DEVID 0x8771\n#define IT8772E_DEVID 0x8772\n#define IT8781F_DEVID 0x8781\n#define IT8782F_DEVID 0x8782\n#define IT8783E_DEVID 0x8783\n#define IT8786E_DEVID 0x8786\n#define IT8790E_DEVID 0x8790\n#define IT8603E_DEVID 0x8603\n#define IT8620E_DEVID 0x8620\n#define IT8622E_DEVID 0x8622\n#define IT8623E_DEVID 0x8623\n#define IT8628E_DEVID 0x8628\n#define IT87952E_DEVID 0x8695\n\n \n#define IT87_ACT_REG\t0x30\n#define IT87_BASE_REG\t0x60\n#define IT87_SPECIAL_CFG_REG\t0xf3\t \n\n \n#define IT87_SIO_GPIO1_REG\t0x25\n#define IT87_SIO_GPIO2_REG\t0x26\n#define IT87_SIO_GPIO3_REG\t0x27\n#define IT87_SIO_GPIO4_REG\t0x28\n#define IT87_SIO_GPIO5_REG\t0x29\n#define IT87_SIO_PINX1_REG\t0x2a\t \n#define IT87_SIO_PINX2_REG\t0x2c\t \n#define IT87_SIO_SPI_REG\t0xef\t \n#define IT87_SIO_VID_REG\t0xfc\t \n#define IT87_SIO_BEEP_PIN_REG\t0xf6\t \n\n \nstatic unsigned short force_id[2];\nstatic unsigned int force_id_cnt;\n\n \nstatic bool ignore_resource_conflict;\n\n \nstatic bool update_vbat;\n\n \nstatic bool fix_pwm_polarity;\n\n \n\n \n#define IT87_EXTENT 8\n\n \n#define IT87_EC_EXTENT 2\n\n \n#define IT87_EC_OFFSET 5\n\n \n#define IT87_ADDR_REG_OFFSET 0\n#define IT87_DATA_REG_OFFSET 1\n\n \n\n#define IT87_REG_CONFIG        0x00\n\n#define IT87_REG_ALARM1        0x01\n#define IT87_REG_ALARM2        0x02\n#define IT87_REG_ALARM3        0x03\n\n \n#define IT87_REG_VID           0x0a\n\n \n#define IT87_REG_IFSEL         0x0a\n\n \n#define IT87_REG_FAN_DIV       0x0b\n#define IT87_REG_FAN_16BIT     0x0c\n\n \n\nstatic const u8 IT87_REG_FAN[]         = { 0x0d, 0x0e, 0x0f, 0x80, 0x82, 0x4c };\nstatic const u8 IT87_REG_FAN_MIN[]     = { 0x10, 0x11, 0x12, 0x84, 0x86, 0x4e };\nstatic const u8 IT87_REG_FANX[]        = { 0x18, 0x19, 0x1a, 0x81, 0x83, 0x4d };\nstatic const u8 IT87_REG_FANX_MIN[]    = { 0x1b, 0x1c, 0x1d, 0x85, 0x87, 0x4f };\nstatic const u8 IT87_REG_TEMP_OFFSET[] = { 0x56, 0x57, 0x59 };\n\n#define IT87_REG_FAN_MAIN_CTRL 0x13\n#define IT87_REG_FAN_CTL       0x14\nstatic const u8 IT87_REG_PWM[]         = { 0x15, 0x16, 0x17, 0x7f, 0xa7, 0xaf };\nstatic const u8 IT87_REG_PWM_DUTY[]    = { 0x63, 0x6b, 0x73, 0x7b, 0xa3, 0xab };\n\nstatic const u8 IT87_REG_VIN[]\t= { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,\n\t\t\t\t    0x27, 0x28, 0x2f, 0x2c, 0x2d, 0x2e };\n\n#define IT87_REG_TEMP(nr)      (0x29 + (nr))\n\n#define IT87_REG_VIN_MAX(nr)   (0x30 + (nr) * 2)\n#define IT87_REG_VIN_MIN(nr)   (0x31 + (nr) * 2)\n#define IT87_REG_TEMP_HIGH(nr) (0x40 + (nr) * 2)\n#define IT87_REG_TEMP_LOW(nr)  (0x41 + (nr) * 2)\n\n#define IT87_REG_VIN_ENABLE    0x50\n#define IT87_REG_TEMP_ENABLE   0x51\n#define IT87_REG_TEMP_EXTRA    0x55\n#define IT87_REG_BEEP_ENABLE   0x5c\n\n#define IT87_REG_CHIPID        0x58\n\nstatic const u8 IT87_REG_AUTO_BASE[] = { 0x60, 0x68, 0x70, 0x78, 0xa0, 0xa8 };\n\n#define IT87_REG_AUTO_TEMP(nr, i) (IT87_REG_AUTO_BASE[nr] + (i))\n#define IT87_REG_AUTO_PWM(nr, i)  (IT87_REG_AUTO_BASE[nr] + 5 + (i))\n\n#define IT87_REG_TEMP456_ENABLE\t0x77\n\n#define NUM_VIN\t\t\tARRAY_SIZE(IT87_REG_VIN)\n#define NUM_VIN_LIMIT\t\t8\n#define NUM_TEMP\t\t6\n#define NUM_TEMP_OFFSET\t\tARRAY_SIZE(IT87_REG_TEMP_OFFSET)\n#define NUM_TEMP_LIMIT\t\t3\n#define NUM_FAN\t\t\tARRAY_SIZE(IT87_REG_FAN)\n#define NUM_FAN_DIV\t\t3\n#define NUM_PWM\t\t\tARRAY_SIZE(IT87_REG_PWM)\n#define NUM_AUTO_PWM\t\tARRAY_SIZE(IT87_REG_PWM)\n\nstruct it87_devices {\n\tconst char *name;\n\tconst char * const model;\n\tu32 features;\n\tu8 peci_mask;\n\tu8 old_peci_mask;\n\tu8 smbus_bitmap;\t \n\tu8 ec_special_config;\n};\n\n#define FEAT_12MV_ADC\t\tBIT(0)\n#define FEAT_NEWER_AUTOPWM\tBIT(1)\n#define FEAT_OLD_AUTOPWM\tBIT(2)\n#define FEAT_16BIT_FANS\t\tBIT(3)\n#define FEAT_TEMP_OFFSET\tBIT(4)\n#define FEAT_TEMP_PECI\t\tBIT(5)\n#define FEAT_TEMP_OLD_PECI\tBIT(6)\n#define FEAT_FAN16_CONFIG\tBIT(7)\t \n#define FEAT_FIVE_FANS\t\tBIT(8)\t \n#define FEAT_VID\t\tBIT(9)\t \n#define FEAT_IN7_INTERNAL\tBIT(10)\t \n#define FEAT_SIX_FANS\t\tBIT(11)\t \n#define FEAT_10_9MV_ADC\t\tBIT(12)\n#define FEAT_AVCC3\t\tBIT(13)\t \n#define FEAT_FIVE_PWM\t\tBIT(14)\t \n#define FEAT_SIX_PWM\t\tBIT(15)\t \n#define FEAT_PWM_FREQ2\t\tBIT(16)\t \n#define FEAT_SIX_TEMP\t\tBIT(17)\t \n#define FEAT_VIN3_5V\t\tBIT(18)\t \n \n#define FEAT_CONF_NOEXIT\tBIT(19)\t \n#define FEAT_FOUR_FANS\t\tBIT(20)\t \n#define FEAT_FOUR_PWM\t\tBIT(21)\t \n#define FEAT_FOUR_TEMP\t\tBIT(22)\n#define FEAT_FANCTL_ONOFF\tBIT(23)\t \n\nstatic const struct it87_devices it87_devices[] = {\n\t[it87] = {\n\t\t.name = \"it87\",\n\t\t.model = \"IT87F\",\n\t\t.features = FEAT_OLD_AUTOPWM | FEAT_FANCTL_ONOFF,\n\t\t \n\t},\n\t[it8712] = {\n\t\t.name = \"it8712\",\n\t\t.model = \"IT8712F\",\n\t\t.features = FEAT_OLD_AUTOPWM | FEAT_VID | FEAT_FANCTL_ONOFF,\n\t\t \n\t},\n\t[it8716] = {\n\t\t.name = \"it8716\",\n\t\t.model = \"IT8716F\",\n\t\t.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_VID\n\t\t  | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS | FEAT_PWM_FREQ2\n\t\t  | FEAT_FANCTL_ONOFF,\n\t},\n\t[it8718] = {\n\t\t.name = \"it8718\",\n\t\t.model = \"IT8718F\",\n\t\t.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_VID\n\t\t  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS\n\t\t  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,\n\t\t.old_peci_mask = 0x4,\n\t},\n\t[it8720] = {\n\t\t.name = \"it8720\",\n\t\t.model = \"IT8720F\",\n\t\t.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_VID\n\t\t  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS\n\t\t  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,\n\t\t.old_peci_mask = 0x4,\n\t},\n\t[it8721] = {\n\t\t.name = \"it8721\",\n\t\t.model = \"IT8721F\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI\n\t\t  | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS | FEAT_IN7_INTERNAL\n\t\t  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,\n\t\t.peci_mask = 0x05,\n\t\t.old_peci_mask = 0x02,\t \n\t},\n\t[it8728] = {\n\t\t.name = \"it8728\",\n\t\t.model = \"IT8728F\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_FIVE_FANS\n\t\t  | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2\n\t\t  | FEAT_FANCTL_ONOFF,\n\t\t.peci_mask = 0x07,\n\t},\n\t[it8732] = {\n\t\t.name = \"it8732\",\n\t\t.model = \"IT8732F\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI\n\t\t  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_FOUR_FANS\n\t\t  | FEAT_FOUR_PWM | FEAT_FANCTL_ONOFF,\n\t\t.peci_mask = 0x07,\n\t\t.old_peci_mask = 0x02,\t \n\t},\n\t[it8771] = {\n\t\t.name = \"it8771\",\n\t\t.model = \"IT8771E\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL\n\t\t  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t.peci_mask = 0x07,\n\t},\n\t[it8772] = {\n\t\t.name = \"it8772\",\n\t\t.model = \"IT8772E\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL\n\t\t  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t.peci_mask = 0x07,\n\t},\n\t[it8781] = {\n\t\t.name = \"it8781\",\n\t\t.model = \"IT8781F\",\n\t\t.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET\n\t\t  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2\n\t\t  | FEAT_FANCTL_ONOFF,\n\t\t.old_peci_mask = 0x4,\n\t},\n\t[it8782] = {\n\t\t.name = \"it8782\",\n\t\t.model = \"IT8782F\",\n\t\t.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET\n\t\t  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2\n\t\t  | FEAT_FANCTL_ONOFF,\n\t\t.old_peci_mask = 0x4,\n\t},\n\t[it8783] = {\n\t\t.name = \"it8783\",\n\t\t.model = \"IT8783E/F\",\n\t\t.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET\n\t\t  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2\n\t\t  | FEAT_FANCTL_ONOFF,\n\t\t.old_peci_mask = 0x4,\n\t},\n\t[it8786] = {\n\t\t.name = \"it8786\",\n\t\t.model = \"IT8786E\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL\n\t\t  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,\n\t\t.peci_mask = 0x07,\n\t},\n\t[it8790] = {\n\t\t.name = \"it8790\",\n\t\t.model = \"IT8790E\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL\n\t\t  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF | FEAT_CONF_NOEXIT,\n\t\t.peci_mask = 0x07,\n\t},\n\t[it8792] = {\n\t\t.name = \"it8792\",\n\t\t.model = \"IT8792E/IT8795E\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI\n\t\t  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_FANCTL_ONOFF\n\t\t  | FEAT_CONF_NOEXIT,\n\t\t.peci_mask = 0x07,\n\t\t.old_peci_mask = 0x02,\t \n\t},\n\t[it8603] = {\n\t\t.name = \"it8603\",\n\t\t.model = \"IT8603E\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL\n\t\t  | FEAT_AVCC3 | FEAT_PWM_FREQ2,\n\t\t.peci_mask = 0x07,\n\t},\n\t[it8620] = {\n\t\t.name = \"it8620\",\n\t\t.model = \"IT8620E\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_SIX_FANS\n\t\t  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2\n\t\t  | FEAT_SIX_TEMP | FEAT_VIN3_5V | FEAT_FANCTL_ONOFF,\n\t\t.peci_mask = 0x07,\n\t},\n\t[it8622] = {\n\t\t.name = \"it8622\",\n\t\t.model = \"IT8622E\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_FIVE_FANS\n\t\t  | FEAT_FIVE_PWM | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2\n\t\t  | FEAT_AVCC3 | FEAT_VIN3_5V | FEAT_FOUR_TEMP,\n\t\t.peci_mask = 0x07,\n\t\t.smbus_bitmap = BIT(1) | BIT(2),\n\t},\n\t[it8628] = {\n\t\t.name = \"it8628\",\n\t\t.model = \"IT8628E\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_SIX_FANS\n\t\t  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2\n\t\t  | FEAT_SIX_TEMP | FEAT_VIN3_5V | FEAT_FANCTL_ONOFF,\n\t\t.peci_mask = 0x07,\n\t},\n\t[it87952] = {\n\t\t.name = \"it87952\",\n\t\t.model = \"IT87952E\",\n\t\t.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS\n\t\t  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI\n\t\t  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_FANCTL_ONOFF\n\t\t  | FEAT_CONF_NOEXIT,\n\t\t.peci_mask = 0x07,\n\t\t.old_peci_mask = 0x02,\t \n\t},\n};\n\n#define has_16bit_fans(data)\t((data)->features & FEAT_16BIT_FANS)\n#define has_12mv_adc(data)\t((data)->features & FEAT_12MV_ADC)\n#define has_10_9mv_adc(data)\t((data)->features & FEAT_10_9MV_ADC)\n#define has_newer_autopwm(data)\t((data)->features & FEAT_NEWER_AUTOPWM)\n#define has_old_autopwm(data)\t((data)->features & FEAT_OLD_AUTOPWM)\n#define has_temp_offset(data)\t((data)->features & FEAT_TEMP_OFFSET)\n#define has_temp_peci(data, nr)\t(((data)->features & FEAT_TEMP_PECI) && \\\n\t\t\t\t ((data)->peci_mask & BIT(nr)))\n#define has_temp_old_peci(data, nr) \\\n\t\t\t\t(((data)->features & FEAT_TEMP_OLD_PECI) && \\\n\t\t\t\t ((data)->old_peci_mask & BIT(nr)))\n#define has_fan16_config(data)\t((data)->features & FEAT_FAN16_CONFIG)\n#define has_four_fans(data)\t((data)->features & (FEAT_FOUR_FANS | \\\n\t\t\t\t\t\t     FEAT_FIVE_FANS | \\\n\t\t\t\t\t\t     FEAT_SIX_FANS))\n#define has_five_fans(data)\t((data)->features & (FEAT_FIVE_FANS | \\\n\t\t\t\t\t\t     FEAT_SIX_FANS))\n#define has_six_fans(data)\t((data)->features & FEAT_SIX_FANS)\n#define has_vid(data)\t\t((data)->features & FEAT_VID)\n#define has_in7_internal(data)\t((data)->features & FEAT_IN7_INTERNAL)\n#define has_avcc3(data)\t\t((data)->features & FEAT_AVCC3)\n#define has_four_pwm(data)\t((data)->features & (FEAT_FOUR_PWM | \\\n\t\t\t\t\t\t     FEAT_FIVE_PWM | \\\n\t\t\t\t\t\t     FEAT_SIX_PWM))\n#define has_five_pwm(data)\t((data)->features & (FEAT_FIVE_PWM | \\\n\t\t\t\t\t\t     FEAT_SIX_PWM))\n#define has_six_pwm(data)\t((data)->features & FEAT_SIX_PWM)\n#define has_pwm_freq2(data)\t((data)->features & FEAT_PWM_FREQ2)\n#define has_four_temp(data)\t((data)->features & FEAT_FOUR_TEMP)\n#define has_six_temp(data)\t((data)->features & FEAT_SIX_TEMP)\n#define has_vin3_5v(data)\t((data)->features & FEAT_VIN3_5V)\n#define has_conf_noexit(data)\t((data)->features & FEAT_CONF_NOEXIT)\n#define has_scaling(data)\t((data)->features & (FEAT_12MV_ADC | \\\n\t\t\t\t\t\t     FEAT_10_9MV_ADC))\n#define has_fanctl_onoff(data)\t((data)->features & FEAT_FANCTL_ONOFF)\n\nstruct it87_sio_data {\n\tint sioaddr;\n\tenum chips type;\n\t \n\tu8 revision;\n\tu8 vid_value;\n\tu8 beep_pin;\n\tu8 internal;\t \n\tbool need_in7_reroute;\n\t \n\tu16 skip_in;\n\tu8 skip_vid;\n\tu8 skip_fan;\n\tu8 skip_pwm;\n\tu8 skip_temp;\n\tu8 smbus_bitmap;\n\tu8 ec_special_config;\n};\n\n \nstruct it87_data {\n\tconst struct attribute_group *groups[7];\n\tint sioaddr;\n\tenum chips type;\n\tu32 features;\n\tu8 peci_mask;\n\tu8 old_peci_mask;\n\n\tu8 smbus_bitmap;\t \n\tu8 ec_special_config;\t \n\n\tunsigned short addr;\n\tconst char *name;\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\n\tu16 in_scaled;\t\t \n\tu16 in_internal;\t \n\tu16 has_in;\t\t \n\tu8 in[NUM_VIN][3];\t\t \n\tbool need_in7_reroute;\n\tu8 has_fan;\t\t \n\tu16 fan[NUM_FAN][2];\t \n\tu8 has_temp;\t\t \n\ts8 temp[NUM_TEMP][4];\t \n\tu8 sensor;\t\t \n\tu8 extra;\t\t \n\tu8 fan_div[NUM_FAN_DIV]; \n\tbool has_vid;\t\t \n\tu8 vid;\t\t\t \n\tu8 vrm;\n\tu32 alarms;\t\t \n\tbool has_beep;\t\t \n\tu8 beeps;\t\t \n\tu8 fan_main_ctrl;\t \n\tu8 fan_ctl;\t\t \n\n\t \n\tu8 has_pwm;\t\t \n\tu8 pwm_ctrl[NUM_PWM];\t \n\tu8 pwm_duty[NUM_PWM];\t \n\tu8 pwm_temp_map[NUM_PWM]; \n\n\t \n\tu8 auto_pwm[NUM_AUTO_PWM][4];\t \n\ts8 auto_temp[NUM_AUTO_PWM][5];\t \n};\n\n \nstruct it87_dmi_data {\n\tu8 skip_pwm;\t\t \n};\n\n \nstatic struct it87_dmi_data *dmi_data;\n\nstatic int adc_lsb(const struct it87_data *data, int nr)\n{\n\tint lsb;\n\n\tif (has_12mv_adc(data))\n\t\tlsb = 120;\n\telse if (has_10_9mv_adc(data))\n\t\tlsb = 109;\n\telse\n\t\tlsb = 160;\n\tif (data->in_scaled & BIT(nr))\n\t\tlsb <<= 1;\n\treturn lsb;\n}\n\nstatic u8 in_to_reg(const struct it87_data *data, int nr, long val)\n{\n\tval = DIV_ROUND_CLOSEST(val * 10, adc_lsb(data, nr));\n\treturn clamp_val(val, 0, 255);\n}\n\nstatic int in_from_reg(const struct it87_data *data, int nr, int val)\n{\n\treturn DIV_ROUND_CLOSEST(val * adc_lsb(data, nr), 10);\n}\n\nstatic inline u8 FAN_TO_REG(long rpm, int div)\n{\n\tif (rpm == 0)\n\t\treturn 255;\n\trpm = clamp_val(rpm, 1, 1000000);\n\treturn clamp_val((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\n}\n\nstatic inline u16 FAN16_TO_REG(long rpm)\n{\n\tif (rpm == 0)\n\t\treturn 0xffff;\n\treturn clamp_val((1350000 + rpm) / (rpm * 2), 1, 0xfffe);\n}\n\n#define FAN_FROM_REG(val, div) ((val) == 0 ? -1 : (val) == 255 ? 0 : \\\n\t\t\t\t1350000 / ((val) * (div)))\n \n#define FAN16_FROM_REG(val) ((val) == 0 ? -1 : (val) == 0xffff ? 0 : \\\n\t\t\t     1350000 / ((val) * 2))\n\n#define TEMP_TO_REG(val) (clamp_val(((val) < 0 ? (((val) - 500) / 1000) : \\\n\t\t\t\t    ((val) + 500) / 1000), -128, 127))\n#define TEMP_FROM_REG(val) ((val) * 1000)\n\nstatic u8 pwm_to_reg(const struct it87_data *data, long val)\n{\n\tif (has_newer_autopwm(data))\n\t\treturn val;\n\telse\n\t\treturn val >> 1;\n}\n\nstatic int pwm_from_reg(const struct it87_data *data, u8 reg)\n{\n\tif (has_newer_autopwm(data))\n\t\treturn reg;\n\telse\n\t\treturn (reg & 0x7f) << 1;\n}\n\nstatic int DIV_TO_REG(int val)\n{\n\tint answer = 0;\n\n\twhile (answer < 7 && (val >>= 1))\n\t\tanswer++;\n\treturn answer;\n}\n\n#define DIV_FROM_REG(val) BIT(val)\n\n \nstatic const unsigned int pwm_freq[8] = {\n\t48000000,\n\t24000000,\n\t12000000,\n\t8000000,\n\t6000000,\n\t3000000,\n\t1500000,\n\t750000,\n};\n\nstatic int smbus_disable(struct it87_data *data)\n{\n\tint err;\n\n\tif (data->smbus_bitmap) {\n\t\terr = superio_enter(data->sioaddr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tsuperio_select(data->sioaddr, PME);\n\t\tsuperio_outb(data->sioaddr, IT87_SPECIAL_CFG_REG,\n\t\t\t     data->ec_special_config & ~data->smbus_bitmap);\n\t\tsuperio_exit(data->sioaddr, has_conf_noexit(data));\n\t}\n\treturn 0;\n}\n\nstatic int smbus_enable(struct it87_data *data)\n{\n\tint err;\n\n\tif (data->smbus_bitmap) {\n\t\terr = superio_enter(data->sioaddr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tsuperio_select(data->sioaddr, PME);\n\t\tsuperio_outb(data->sioaddr, IT87_SPECIAL_CFG_REG,\n\t\t\t     data->ec_special_config);\n\t\tsuperio_exit(data->sioaddr, has_conf_noexit(data));\n\t}\n\treturn 0;\n}\n\n \nstatic int it87_read_value(struct it87_data *data, u8 reg)\n{\n\toutb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);\n\treturn inb_p(data->addr + IT87_DATA_REG_OFFSET);\n}\n\n \nstatic void it87_write_value(struct it87_data *data, u8 reg, u8 value)\n{\n\toutb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);\n\toutb_p(value, data->addr + IT87_DATA_REG_OFFSET);\n}\n\nstatic void it87_update_pwm_ctrl(struct it87_data *data, int nr)\n{\n\tdata->pwm_ctrl[nr] = it87_read_value(data, IT87_REG_PWM[nr]);\n\tif (has_newer_autopwm(data)) {\n\t\tdata->pwm_temp_map[nr] = data->pwm_ctrl[nr] & 0x03;\n\t\tdata->pwm_duty[nr] = it87_read_value(data,\n\t\t\t\t\t\t     IT87_REG_PWM_DUTY[nr]);\n\t} else {\n\t\tif (data->pwm_ctrl[nr] & 0x80)\t \n\t\t\tdata->pwm_temp_map[nr] = data->pwm_ctrl[nr] & 0x03;\n\t\telse\t\t\t\t \n\t\t\tdata->pwm_duty[nr] = data->pwm_ctrl[nr] & 0x7f;\n\t}\n\n\tif (has_old_autopwm(data)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5 ; i++)\n\t\t\tdata->auto_temp[nr][i] = it87_read_value(data,\n\t\t\t\t\t\tIT87_REG_AUTO_TEMP(nr, i));\n\t\tfor (i = 0; i < 3 ; i++)\n\t\t\tdata->auto_pwm[nr][i] = it87_read_value(data,\n\t\t\t\t\t\tIT87_REG_AUTO_PWM(nr, i));\n\t} else if (has_newer_autopwm(data)) {\n\t\tint i;\n\n\t\t \n\t\tdata->auto_temp[nr][0] =\n\t\t\tit87_read_value(data, IT87_REG_AUTO_TEMP(nr, 5));\n\n\t\tfor (i = 0; i < 3 ; i++)\n\t\t\tdata->auto_temp[nr][i + 1] =\n\t\t\t\tit87_read_value(data,\n\t\t\t\t\t\tIT87_REG_AUTO_TEMP(nr, i));\n\t\t \n\t\tdata->auto_pwm[nr][0] =\n\t\t\tit87_read_value(data, IT87_REG_AUTO_TEMP(nr, 3));\n\t\tdata->auto_pwm[nr][1] =\n\t\t\tit87_read_value(data, IT87_REG_AUTO_TEMP(nr, 4));\n\t}\n}\n\nstatic int it87_lock(struct it87_data *data)\n{\n\tint err;\n\n\tmutex_lock(&data->update_lock);\n\terr = smbus_disable(data);\n\tif (err)\n\t\tmutex_unlock(&data->update_lock);\n\treturn err;\n}\n\nstatic void it87_unlock(struct it87_data *data)\n{\n\tsmbus_enable(data);\n\tmutex_unlock(&data->update_lock);\n}\n\nstatic struct it87_data *it87_update_device(struct device *dev)\n{\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tstruct it87_data *ret = data;\n\tint err;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2) ||\n\t\t       !data->valid) {\n\t\terr = smbus_disable(data);\n\t\tif (err) {\n\t\t\tret = ERR_PTR(err);\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (update_vbat) {\n\t\t\t \n\t\t\tit87_write_value(data, IT87_REG_CONFIG,\n\t\t\t\tit87_read_value(data, IT87_REG_CONFIG) | 0x40);\n\t\t}\n\t\tfor (i = 0; i < NUM_VIN; i++) {\n\t\t\tif (!(data->has_in & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\tdata->in[i][0] =\n\t\t\t\tit87_read_value(data, IT87_REG_VIN[i]);\n\n\t\t\t \n\t\t\tif (i >= NUM_VIN_LIMIT)\n\t\t\t\tcontinue;\n\n\t\t\tdata->in[i][1] =\n\t\t\t\tit87_read_value(data, IT87_REG_VIN_MIN(i));\n\t\t\tdata->in[i][2] =\n\t\t\t\tit87_read_value(data, IT87_REG_VIN_MAX(i));\n\t\t}\n\n\t\tfor (i = 0; i < NUM_FAN; i++) {\n\t\t\t \n\t\t\tif (!(data->has_fan & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\tdata->fan[i][1] =\n\t\t\t\tit87_read_value(data, IT87_REG_FAN_MIN[i]);\n\t\t\tdata->fan[i][0] = it87_read_value(data,\n\t\t\t\t       IT87_REG_FAN[i]);\n\t\t\t \n\t\t\tif (has_16bit_fans(data)) {\n\t\t\t\tdata->fan[i][0] |= it87_read_value(data,\n\t\t\t\t\t\tIT87_REG_FANX[i]) << 8;\n\t\t\t\tdata->fan[i][1] |= it87_read_value(data,\n\t\t\t\t\t\tIT87_REG_FANX_MIN[i]) << 8;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < NUM_TEMP; i++) {\n\t\t\tif (!(data->has_temp & BIT(i)))\n\t\t\t\tcontinue;\n\t\t\tdata->temp[i][0] =\n\t\t\t\tit87_read_value(data, IT87_REG_TEMP(i));\n\n\t\t\tif (has_temp_offset(data) && i < NUM_TEMP_OFFSET)\n\t\t\t\tdata->temp[i][3] =\n\t\t\t\t  it87_read_value(data,\n\t\t\t\t\t\t  IT87_REG_TEMP_OFFSET[i]);\n\n\t\t\tif (i >= NUM_TEMP_LIMIT)\n\t\t\t\tcontinue;\n\n\t\t\tdata->temp[i][1] =\n\t\t\t\tit87_read_value(data, IT87_REG_TEMP_LOW(i));\n\t\t\tdata->temp[i][2] =\n\t\t\t\tit87_read_value(data, IT87_REG_TEMP_HIGH(i));\n\t\t}\n\n\t\t \n\t\tif ((data->has_fan & 0x07) && !has_16bit_fans(data)) {\n\t\t\ti = it87_read_value(data, IT87_REG_FAN_DIV);\n\t\t\tdata->fan_div[0] = i & 0x07;\n\t\t\tdata->fan_div[1] = (i >> 3) & 0x07;\n\t\t\tdata->fan_div[2] = (i & 0x40) ? 3 : 1;\n\t\t}\n\n\t\tdata->alarms =\n\t\t\tit87_read_value(data, IT87_REG_ALARM1) |\n\t\t\t(it87_read_value(data, IT87_REG_ALARM2) << 8) |\n\t\t\t(it87_read_value(data, IT87_REG_ALARM3) << 16);\n\t\tdata->beeps = it87_read_value(data, IT87_REG_BEEP_ENABLE);\n\n\t\tdata->fan_main_ctrl = it87_read_value(data,\n\t\t\t\tIT87_REG_FAN_MAIN_CTRL);\n\t\tdata->fan_ctl = it87_read_value(data, IT87_REG_FAN_CTL);\n\t\tfor (i = 0; i < NUM_PWM; i++) {\n\t\t\tif (!(data->has_pwm & BIT(i)))\n\t\t\t\tcontinue;\n\t\t\tit87_update_pwm_ctrl(data, i);\n\t\t}\n\n\t\tdata->sensor = it87_read_value(data, IT87_REG_TEMP_ENABLE);\n\t\tdata->extra = it87_read_value(data, IT87_REG_TEMP_EXTRA);\n\t\t \n\t\tif (data->type == it8712 || data->type == it8716) {\n\t\t\tdata->vid = it87_read_value(data, IT87_REG_VID);\n\t\t\t \n\t\t\tdata->vid &= 0x3f;\n\t\t}\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t\tsmbus_enable(data);\n\t}\nunlock:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct it87_data *data = it87_update_device(dev);\n\tint index = sattr->index;\n\tint nr = sattr->nr;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", in_from_reg(data, nr, data->in[nr][index]));\n}\n\nstatic ssize_t set_in(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint index = sattr->index;\n\tint nr = sattr->nr;\n\tunsigned long val;\n\tint err;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\tdata->in[nr][index] = in_to_reg(data, nr, val);\n\tit87_write_value(data,\n\t\t\t index == 1 ? IT87_REG_VIN_MIN(nr)\n\t\t\t\t    : IT87_REG_VIN_MAX(nr),\n\t\t\t data->in[nr][index]);\n\tit87_unlock(data);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_2(in0_input, S_IRUGO, show_in, NULL, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2(in0_min, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    0, 1);\nstatic SENSOR_DEVICE_ATTR_2(in0_max, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    0, 2);\n\nstatic SENSOR_DEVICE_ATTR_2(in1_input, S_IRUGO, show_in, NULL, 1, 0);\nstatic SENSOR_DEVICE_ATTR_2(in1_min, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    1, 1);\nstatic SENSOR_DEVICE_ATTR_2(in1_max, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    1, 2);\n\nstatic SENSOR_DEVICE_ATTR_2(in2_input, S_IRUGO, show_in, NULL, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2(in2_min, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    2, 1);\nstatic SENSOR_DEVICE_ATTR_2(in2_max, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    2, 2);\n\nstatic SENSOR_DEVICE_ATTR_2(in3_input, S_IRUGO, show_in, NULL, 3, 0);\nstatic SENSOR_DEVICE_ATTR_2(in3_min, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    3, 1);\nstatic SENSOR_DEVICE_ATTR_2(in3_max, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    3, 2);\n\nstatic SENSOR_DEVICE_ATTR_2(in4_input, S_IRUGO, show_in, NULL, 4, 0);\nstatic SENSOR_DEVICE_ATTR_2(in4_min, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    4, 1);\nstatic SENSOR_DEVICE_ATTR_2(in4_max, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    4, 2);\n\nstatic SENSOR_DEVICE_ATTR_2(in5_input, S_IRUGO, show_in, NULL, 5, 0);\nstatic SENSOR_DEVICE_ATTR_2(in5_min, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    5, 1);\nstatic SENSOR_DEVICE_ATTR_2(in5_max, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    5, 2);\n\nstatic SENSOR_DEVICE_ATTR_2(in6_input, S_IRUGO, show_in, NULL, 6, 0);\nstatic SENSOR_DEVICE_ATTR_2(in6_min, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    6, 1);\nstatic SENSOR_DEVICE_ATTR_2(in6_max, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    6, 2);\n\nstatic SENSOR_DEVICE_ATTR_2(in7_input, S_IRUGO, show_in, NULL, 7, 0);\nstatic SENSOR_DEVICE_ATTR_2(in7_min, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    7, 1);\nstatic SENSOR_DEVICE_ATTR_2(in7_max, S_IRUGO | S_IWUSR, show_in, set_in,\n\t\t\t    7, 2);\n\nstatic SENSOR_DEVICE_ATTR_2(in8_input, S_IRUGO, show_in, NULL, 8, 0);\nstatic SENSOR_DEVICE_ATTR_2(in9_input, S_IRUGO, show_in, NULL, 9, 0);\nstatic SENSOR_DEVICE_ATTR_2(in10_input, S_IRUGO, show_in, NULL, 10, 0);\nstatic SENSOR_DEVICE_ATTR_2(in11_input, S_IRUGO, show_in, NULL, 11, 0);\nstatic SENSOR_DEVICE_ATTR_2(in12_input, S_IRUGO, show_in, NULL, 12, 0);\n\n \nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\tstruct it87_data *data = it87_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp[nr][index]));\n}\n\nstatic ssize_t set_temp(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tlong val;\n\tu8 reg, regval;\n\tint err;\n\n\tif (kstrtol(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\tswitch (index) {\n\tdefault:\n\tcase 1:\n\t\treg = IT87_REG_TEMP_LOW(nr);\n\t\tbreak;\n\tcase 2:\n\t\treg = IT87_REG_TEMP_HIGH(nr);\n\t\tbreak;\n\tcase 3:\n\t\tregval = it87_read_value(data, IT87_REG_BEEP_ENABLE);\n\t\tif (!(regval & 0x80)) {\n\t\t\tregval |= 0x80;\n\t\t\tit87_write_value(data, IT87_REG_BEEP_ENABLE, regval);\n\t\t}\n\t\tdata->valid = false;\n\t\treg = IT87_REG_TEMP_OFFSET[nr];\n\t\tbreak;\n\t}\n\n\tdata->temp[nr][index] = TEMP_TO_REG(val);\n\tit87_write_value(data, reg, data->temp[nr][index]);\n\tit87_unlock(data);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_2(temp1_input, S_IRUGO, show_temp, NULL, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2(temp1_min, S_IRUGO | S_IWUSR, show_temp, set_temp,\n\t\t\t    0, 1);\nstatic SENSOR_DEVICE_ATTR_2(temp1_max, S_IRUGO | S_IWUSR, show_temp, set_temp,\n\t\t\t    0, 2);\nstatic SENSOR_DEVICE_ATTR_2(temp1_offset, S_IRUGO | S_IWUSR, show_temp,\n\t\t\t    set_temp, 0, 3);\nstatic SENSOR_DEVICE_ATTR_2(temp2_input, S_IRUGO, show_temp, NULL, 1, 0);\nstatic SENSOR_DEVICE_ATTR_2(temp2_min, S_IRUGO | S_IWUSR, show_temp, set_temp,\n\t\t\t    1, 1);\nstatic SENSOR_DEVICE_ATTR_2(temp2_max, S_IRUGO | S_IWUSR, show_temp, set_temp,\n\t\t\t    1, 2);\nstatic SENSOR_DEVICE_ATTR_2(temp2_offset, S_IRUGO | S_IWUSR, show_temp,\n\t\t\t    set_temp, 1, 3);\nstatic SENSOR_DEVICE_ATTR_2(temp3_input, S_IRUGO, show_temp, NULL, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2(temp3_min, S_IRUGO | S_IWUSR, show_temp, set_temp,\n\t\t\t    2, 1);\nstatic SENSOR_DEVICE_ATTR_2(temp3_max, S_IRUGO | S_IWUSR, show_temp, set_temp,\n\t\t\t    2, 2);\nstatic SENSOR_DEVICE_ATTR_2(temp3_offset, S_IRUGO | S_IWUSR, show_temp,\n\t\t\t    set_temp, 2, 3);\nstatic SENSOR_DEVICE_ATTR_2(temp4_input, S_IRUGO, show_temp, NULL, 3, 0);\nstatic SENSOR_DEVICE_ATTR_2(temp5_input, S_IRUGO, show_temp, NULL, 4, 0);\nstatic SENSOR_DEVICE_ATTR_2(temp6_input, S_IRUGO, show_temp, NULL, 5, 0);\n\nstatic int get_temp_type(struct it87_data *data, int index)\n{\n\t \n\tu8 reg, extra;\n\tint ttype, type = 0;\n\n\t \n\tttype = 6;\n\tif ((has_temp_peci(data, index)) || data->type == it8721 ||\n\t    data->type == it8720) {\n\t\textra = it87_read_value(data, IT87_REG_IFSEL);\n\t\tif ((extra & 0x70) == 0x40)\n\t\t\tttype = 5;\n\t}\n\n\treg = it87_read_value(data, IT87_REG_TEMP_ENABLE);\n\n\t \n\tswitch (data->type) {\n\tcase it8622:\n\t\tif (!(reg & 0xc0) && index == 3)\n\t\t\ttype = ttype;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (type || index >= 3)\n\t\treturn type;\n\n\textra = it87_read_value(data, IT87_REG_TEMP_EXTRA);\n\n\tif ((has_temp_peci(data, index) && (reg >> 6 == index + 1)) ||\n\t    (has_temp_old_peci(data, index) && (extra & 0x80)))\n\t\ttype = ttype;\t \n\telse if (reg & BIT(index))\n\t\ttype = 3;\t \n\telse if (reg & BIT(index + 3))\n\t\ttype = 4;\t \n\n\treturn type;\n}\n\nstatic ssize_t show_temp_type(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct it87_data *data = it87_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", get_temp_type(data, sensor_attr->index));\n}\n\nstatic ssize_t set_temp_type(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tlong val;\n\tu8 reg, extra;\n\tint err;\n\n\tif (kstrtol(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\treg = it87_read_value(data, IT87_REG_TEMP_ENABLE);\n\treg &= ~(1 << nr);\n\treg &= ~(8 << nr);\n\tif (has_temp_peci(data, nr) && (reg >> 6 == nr + 1 || val == 6))\n\t\treg &= 0x3f;\n\textra = it87_read_value(data, IT87_REG_TEMP_EXTRA);\n\tif (has_temp_old_peci(data, nr) && ((extra & 0x80) || val == 6))\n\t\textra &= 0x7f;\n\tif (val == 2) {\t \n\t\tdev_warn(dev,\n\t\t\t \"Sensor type 2 is deprecated, please use 4 instead\\n\");\n\t\tval = 4;\n\t}\n\t \n\tif (val == 3)\n\t\treg |= 1 << nr;\n\telse if (val == 4)\n\t\treg |= 8 << nr;\n\telse if (has_temp_peci(data, nr) && val == 6)\n\t\treg |= (nr + 1) << 6;\n\telse if (has_temp_old_peci(data, nr) && val == 6)\n\t\textra |= 0x80;\n\telse if (val != 0) {\n\t\tcount = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tdata->sensor = reg;\n\tdata->extra = extra;\n\tit87_write_value(data, IT87_REG_TEMP_ENABLE, data->sensor);\n\tif (has_temp_old_peci(data, nr))\n\t\tit87_write_value(data, IT87_REG_TEMP_EXTRA, data->extra);\n\tdata->valid = false;\t \nunlock:\n\tit87_unlock(data);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR(temp1_type, S_IRUGO | S_IWUSR, show_temp_type,\n\t\t\t  set_temp_type, 0);\nstatic SENSOR_DEVICE_ATTR(temp2_type, S_IRUGO | S_IWUSR, show_temp_type,\n\t\t\t  set_temp_type, 1);\nstatic SENSOR_DEVICE_ATTR(temp3_type, S_IRUGO | S_IWUSR, show_temp_type,\n\t\t\t  set_temp_type, 2);\n\n \n\nstatic int pwm_mode(const struct it87_data *data, int nr)\n{\n\tif (has_fanctl_onoff(data) && nr < 3 &&\n\t    !(data->fan_main_ctrl & BIT(nr)))\n\t\treturn 0;\t\t\t \n\tif (data->pwm_ctrl[nr] & 0x80)\n\t\treturn 2;\t\t\t \n\tif ((!has_fanctl_onoff(data) || nr >= 3) &&\n\t    data->pwm_duty[nr] == pwm_to_reg(data, 0xff))\n\t\treturn 0;\t\t\t \n\n\treturn 1;\t\t\t\t \n}\n\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\tint speed;\n\tstruct it87_data *data = it87_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tspeed = has_16bit_fans(data) ?\n\t\tFAN16_FROM_REG(data->fan[nr][index]) :\n\t\tFAN_FROM_REG(data->fan[nr][index],\n\t\t\t     DIV_FROM_REG(data->fan_div[nr]));\n\treturn sprintf(buf, \"%d\\n\", speed);\n}\n\nstatic ssize_t show_fan_div(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct it87_data *data = it87_update_device(dev);\n\tint nr = sensor_attr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%lu\\n\", DIV_FROM_REG(data->fan_div[nr]));\n}\n\nstatic ssize_t show_pwm_enable(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct it87_data *data = it87_update_device(dev);\n\tint nr = sensor_attr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", pwm_mode(data, nr));\n}\n\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct it87_data *data = it87_update_device(dev);\n\tint nr = sensor_attr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       pwm_from_reg(data, data->pwm_duty[nr]));\n}\n\nstatic ssize_t show_pwm_freq(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct it87_data *data = it87_update_device(dev);\n\tint nr = sensor_attr->index;\n\tunsigned int freq;\n\tint index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (has_pwm_freq2(data) && nr == 1)\n\t\tindex = (data->extra >> 4) & 0x07;\n\telse\n\t\tindex = (data->fan_ctl >> 4) & 0x07;\n\n\tfreq = pwm_freq[index] / (has_newer_autopwm(data) ? 256 : 128);\n\n\treturn sprintf(buf, \"%u\\n\", freq);\n}\n\nstatic ssize_t set_fan(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tlong val;\n\tint err;\n\tu8 reg;\n\n\tif (kstrtol(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\tif (has_16bit_fans(data)) {\n\t\tdata->fan[nr][index] = FAN16_TO_REG(val);\n\t\tit87_write_value(data, IT87_REG_FAN_MIN[nr],\n\t\t\t\t data->fan[nr][index] & 0xff);\n\t\tit87_write_value(data, IT87_REG_FANX_MIN[nr],\n\t\t\t\t data->fan[nr][index] >> 8);\n\t} else {\n\t\treg = it87_read_value(data, IT87_REG_FAN_DIV);\n\t\tswitch (nr) {\n\t\tcase 0:\n\t\t\tdata->fan_div[nr] = reg & 0x07;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdata->fan_div[nr] = (reg >> 3) & 0x07;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata->fan_div[nr] = (reg & 0x40) ? 3 : 1;\n\t\t\tbreak;\n\t\t}\n\t\tdata->fan[nr][index] =\n\t\t  FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\n\t\tit87_write_value(data, IT87_REG_FAN_MIN[nr],\n\t\t\t\t data->fan[nr][index]);\n\t}\n\n\tit87_unlock(data);\n\treturn count;\n}\n\nstatic ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint nr = sensor_attr->index;\n\tunsigned long val;\n\tint min, err;\n\tu8 old;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\told = it87_read_value(data, IT87_REG_FAN_DIV);\n\n\t \n\tmin = FAN_FROM_REG(data->fan[nr][1], DIV_FROM_REG(data->fan_div[nr]));\n\n\tswitch (nr) {\n\tcase 0:\n\tcase 1:\n\t\tdata->fan_div[nr] = DIV_TO_REG(val);\n\t\tbreak;\n\tcase 2:\n\t\tif (val < 8)\n\t\t\tdata->fan_div[nr] = 1;\n\t\telse\n\t\t\tdata->fan_div[nr] = 3;\n\t}\n\tval = old & 0x80;\n\tval |= (data->fan_div[0] & 0x07);\n\tval |= (data->fan_div[1] & 0x07) << 3;\n\tif (data->fan_div[2] == 3)\n\t\tval |= 0x1 << 6;\n\tit87_write_value(data, IT87_REG_FAN_DIV, val);\n\n\t \n\tdata->fan[nr][1] = FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\n\tit87_write_value(data, IT87_REG_FAN_MIN[nr], data->fan[nr][1]);\n\n\tit87_unlock(data);\n\treturn count;\n}\n\n \nstatic int check_trip_points(struct device *dev, int nr)\n{\n\tconst struct it87_data *data = dev_get_drvdata(dev);\n\tint i, err = 0;\n\n\tif (has_old_autopwm(data)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (data->auto_temp[nr][i] > data->auto_temp[nr][i + 1])\n\t\t\t\terr = -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tif (data->auto_pwm[nr][i] > data->auto_pwm[nr][i + 1])\n\t\t\t\terr = -EINVAL;\n\t\t}\n\t} else if (has_newer_autopwm(data)) {\n\t\tfor (i = 1; i < 3; i++) {\n\t\t\tif (data->auto_temp[nr][i] > data->auto_temp[nr][i + 1])\n\t\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\tif (err) {\n\t\tdev_err(dev,\n\t\t\t\"Inconsistent trip points, not switching to automatic mode\\n\");\n\t\tdev_err(dev, \"Adjust the trip points and try again\\n\");\n\t}\n\treturn err;\n}\n\nstatic ssize_t set_pwm_enable(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint nr = sensor_attr->index;\n\tlong val;\n\tint err;\n\n\tif (kstrtol(buf, 10, &val) < 0 || val < 0 || val > 2)\n\t\treturn -EINVAL;\n\n\t \n\tif (val == 2) {\n\t\tif (check_trip_points(dev, nr) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\tif (val == 0) {\n\t\tif (nr < 3 && has_fanctl_onoff(data)) {\n\t\t\tint tmp;\n\t\t\t \n\t\t\ttmp = it87_read_value(data, IT87_REG_FAN_CTL);\n\t\t\tit87_write_value(data, IT87_REG_FAN_CTL, tmp | BIT(nr));\n\t\t\t \n\t\t\tdata->fan_main_ctrl &= ~BIT(nr);\n\t\t\tit87_write_value(data, IT87_REG_FAN_MAIN_CTRL,\n\t\t\t\t\t data->fan_main_ctrl);\n\t\t} else {\n\t\t\tu8 ctrl;\n\n\t\t\t \n\t\t\tdata->pwm_duty[nr] = pwm_to_reg(data, 0xff);\n\t\t\tit87_write_value(data, IT87_REG_PWM_DUTY[nr],\n\t\t\t\t\t data->pwm_duty[nr]);\n\t\t\t \n\t\t\tif (has_newer_autopwm(data)) {\n\t\t\t\tctrl = (data->pwm_ctrl[nr] & 0x7c) |\n\t\t\t\t\tdata->pwm_temp_map[nr];\n\t\t\t} else {\n\t\t\t\tctrl = data->pwm_duty[nr];\n\t\t\t}\n\t\t\tdata->pwm_ctrl[nr] = ctrl;\n\t\t\tit87_write_value(data, IT87_REG_PWM[nr], ctrl);\n\t\t}\n\t} else {\n\t\tu8 ctrl;\n\n\t\tif (has_newer_autopwm(data)) {\n\t\t\tctrl = (data->pwm_ctrl[nr] & 0x7c) |\n\t\t\t\tdata->pwm_temp_map[nr];\n\t\t\tif (val != 1)\n\t\t\t\tctrl |= 0x80;\n\t\t} else {\n\t\t\tctrl = (val == 1 ? data->pwm_duty[nr] : 0x80);\n\t\t}\n\t\tdata->pwm_ctrl[nr] = ctrl;\n\t\tit87_write_value(data, IT87_REG_PWM[nr], ctrl);\n\n\t\tif (has_fanctl_onoff(data) && nr < 3) {\n\t\t\t \n\t\t\tdata->fan_main_ctrl |= BIT(nr);\n\t\t\tit87_write_value(data, IT87_REG_FAN_MAIN_CTRL,\n\t\t\t\t\t data->fan_main_ctrl);\n\t\t}\n\t}\n\n\tit87_unlock(data);\n\treturn count;\n}\n\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint nr = sensor_attr->index;\n\tlong val;\n\tint err;\n\n\tif (kstrtol(buf, 10, &val) < 0 || val < 0 || val > 255)\n\t\treturn -EINVAL;\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\tit87_update_pwm_ctrl(data, nr);\n\tif (has_newer_autopwm(data)) {\n\t\t \n\t\tif (data->pwm_ctrl[nr] & 0x80) {\n\t\t\tcount = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\t\tdata->pwm_duty[nr] = pwm_to_reg(data, val);\n\t\tit87_write_value(data, IT87_REG_PWM_DUTY[nr],\n\t\t\t\t data->pwm_duty[nr]);\n\t} else {\n\t\tdata->pwm_duty[nr] = pwm_to_reg(data, val);\n\t\t \n\t\tif (!(data->pwm_ctrl[nr] & 0x80)) {\n\t\t\tdata->pwm_ctrl[nr] = data->pwm_duty[nr];\n\t\t\tit87_write_value(data, IT87_REG_PWM[nr],\n\t\t\t\t\t data->pwm_ctrl[nr]);\n\t\t}\n\t}\nunlock:\n\tit87_unlock(data);\n\treturn count;\n}\n\nstatic ssize_t set_pwm_freq(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint nr = sensor_attr->index;\n\tunsigned long val;\n\tint err;\n\tint i;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tval = clamp_val(val, 0, 1000000);\n\tval *= has_newer_autopwm(data) ? 256 : 128;\n\n\t \n\tfor (i = 0; i < 7; i++) {\n\t\tif (val > (pwm_freq[i] + pwm_freq[i + 1]) / 2)\n\t\t\tbreak;\n\t}\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\tif (nr == 0) {\n\t\tdata->fan_ctl = it87_read_value(data, IT87_REG_FAN_CTL) & 0x8f;\n\t\tdata->fan_ctl |= i << 4;\n\t\tit87_write_value(data, IT87_REG_FAN_CTL, data->fan_ctl);\n\t} else {\n\t\tdata->extra = it87_read_value(data, IT87_REG_TEMP_EXTRA) & 0x8f;\n\t\tdata->extra |= i << 4;\n\t\tit87_write_value(data, IT87_REG_TEMP_EXTRA, data->extra);\n\t}\n\tit87_unlock(data);\n\n\treturn count;\n}\n\nstatic ssize_t show_pwm_temp_map(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct it87_data *data = it87_update_device(dev);\n\tint nr = sensor_attr->index;\n\tint map;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmap = data->pwm_temp_map[nr];\n\tif (map >= 3)\n\t\tmap = 0;\t \n\tif (nr >= 3)\t\t \n\t\tmap += 3;\n\n\treturn sprintf(buf, \"%d\\n\", (int)BIT(map));\n}\n\nstatic ssize_t set_pwm_temp_map(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint nr = sensor_attr->index;\n\tlong val;\n\tint err;\n\tu8 reg;\n\n\tif (kstrtol(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (nr >= 3)\n\t\tval -= 3;\n\n\tswitch (val) {\n\tcase BIT(0):\n\t\treg = 0x00;\n\t\tbreak;\n\tcase BIT(1):\n\t\treg = 0x01;\n\t\tbreak;\n\tcase BIT(2):\n\t\treg = 0x02;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\tit87_update_pwm_ctrl(data, nr);\n\tdata->pwm_temp_map[nr] = reg;\n\t \n\tif (data->pwm_ctrl[nr] & 0x80) {\n\t\tdata->pwm_ctrl[nr] = (data->pwm_ctrl[nr] & 0xfc) |\n\t\t\t\t\t\tdata->pwm_temp_map[nr];\n\t\tit87_write_value(data, IT87_REG_PWM[nr], data->pwm_ctrl[nr]);\n\t}\n\tit87_unlock(data);\n\treturn count;\n}\n\nstatic ssize_t show_auto_pwm(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct it87_data *data = it87_update_device(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t\t\tto_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint point = sensor_attr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       pwm_from_reg(data, data->auto_pwm[nr][point]));\n}\n\nstatic ssize_t set_auto_pwm(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t\t\tto_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint point = sensor_attr->index;\n\tint regaddr;\n\tlong val;\n\tint err;\n\n\tif (kstrtol(buf, 10, &val) < 0 || val < 0 || val > 255)\n\t\treturn -EINVAL;\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\tdata->auto_pwm[nr][point] = pwm_to_reg(data, val);\n\tif (has_newer_autopwm(data))\n\t\tregaddr = IT87_REG_AUTO_TEMP(nr, 3);\n\telse\n\t\tregaddr = IT87_REG_AUTO_PWM(nr, point);\n\tit87_write_value(data, regaddr, data->auto_pwm[nr][point]);\n\tit87_unlock(data);\n\treturn count;\n}\n\nstatic ssize_t show_auto_pwm_slope(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct it87_data *data = it87_update_device(dev);\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->auto_pwm[nr][1] & 0x7f);\n}\n\nstatic ssize_t set_auto_pwm_slope(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tunsigned long val;\n\tint err;\n\n\tif (kstrtoul(buf, 10, &val) < 0 || val > 127)\n\t\treturn -EINVAL;\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\tdata->auto_pwm[nr][1] = (data->auto_pwm[nr][1] & 0x80) | val;\n\tit87_write_value(data, IT87_REG_AUTO_TEMP(nr, 4),\n\t\t\t data->auto_pwm[nr][1]);\n\tit87_unlock(data);\n\treturn count;\n}\n\nstatic ssize_t show_auto_temp(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct it87_data *data = it87_update_device(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t\t\tto_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint point = sensor_attr->index;\n\tint reg;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (has_old_autopwm(data) || point)\n\t\treg = data->auto_temp[nr][point];\n\telse\n\t\treg = data->auto_temp[nr][1] - (data->auto_temp[nr][0] & 0x1f);\n\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(reg));\n}\n\nstatic ssize_t set_auto_temp(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t\t\tto_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint point = sensor_attr->index;\n\tlong val;\n\tint reg;\n\tint err;\n\n\tif (kstrtol(buf, 10, &val) < 0 || val < -128000 || val > 127000)\n\t\treturn -EINVAL;\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\tif (has_newer_autopwm(data) && !point) {\n\t\treg = data->auto_temp[nr][1] - TEMP_TO_REG(val);\n\t\treg = clamp_val(reg, 0, 0x1f) | (data->auto_temp[nr][0] & 0xe0);\n\t\tdata->auto_temp[nr][0] = reg;\n\t\tit87_write_value(data, IT87_REG_AUTO_TEMP(nr, 5), reg);\n\t} else {\n\t\treg = TEMP_TO_REG(val);\n\t\tdata->auto_temp[nr][point] = reg;\n\t\tif (has_newer_autopwm(data))\n\t\t\tpoint--;\n\t\tit87_write_value(data, IT87_REG_AUTO_TEMP(nr, point), reg);\n\t}\n\tit87_unlock(data);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_2(fan1_input, S_IRUGO, show_fan, NULL, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2(fan1_min, S_IRUGO | S_IWUSR, show_fan, set_fan,\n\t\t\t    0, 1);\nstatic SENSOR_DEVICE_ATTR(fan1_div, S_IRUGO | S_IWUSR, show_fan_div,\n\t\t\t  set_fan_div, 0);\n\nstatic SENSOR_DEVICE_ATTR_2(fan2_input, S_IRUGO, show_fan, NULL, 1, 0);\nstatic SENSOR_DEVICE_ATTR_2(fan2_min, S_IRUGO | S_IWUSR, show_fan, set_fan,\n\t\t\t    1, 1);\nstatic SENSOR_DEVICE_ATTR(fan2_div, S_IRUGO | S_IWUSR, show_fan_div,\n\t\t\t  set_fan_div, 1);\n\nstatic SENSOR_DEVICE_ATTR_2(fan3_input, S_IRUGO, show_fan, NULL, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2(fan3_min, S_IRUGO | S_IWUSR, show_fan, set_fan,\n\t\t\t    2, 1);\nstatic SENSOR_DEVICE_ATTR(fan3_div, S_IRUGO | S_IWUSR, show_fan_div,\n\t\t\t  set_fan_div, 2);\n\nstatic SENSOR_DEVICE_ATTR_2(fan4_input, S_IRUGO, show_fan, NULL, 3, 0);\nstatic SENSOR_DEVICE_ATTR_2(fan4_min, S_IRUGO | S_IWUSR, show_fan, set_fan,\n\t\t\t    3, 1);\n\nstatic SENSOR_DEVICE_ATTR_2(fan5_input, S_IRUGO, show_fan, NULL, 4, 0);\nstatic SENSOR_DEVICE_ATTR_2(fan5_min, S_IRUGO | S_IWUSR, show_fan, set_fan,\n\t\t\t    4, 1);\n\nstatic SENSOR_DEVICE_ATTR_2(fan6_input, S_IRUGO, show_fan, NULL, 5, 0);\nstatic SENSOR_DEVICE_ATTR_2(fan6_min, S_IRUGO | S_IWUSR, show_fan, set_fan,\n\t\t\t    5, 1);\n\nstatic SENSOR_DEVICE_ATTR(pwm1_enable, S_IRUGO | S_IWUSR,\n\t\t\t  show_pwm_enable, set_pwm_enable, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1, S_IRUGO | S_IWUSR, show_pwm, set_pwm, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1_freq, S_IRUGO | S_IWUSR, show_pwm_freq,\n\t\t\t  set_pwm_freq, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_channels_temp, S_IRUGO,\n\t\t\t  show_pwm_temp_map, set_pwm_temp_map, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point1_pwm, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point2_pwm, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 0, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point3_pwm, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 0, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point4_pwm, S_IRUGO,\n\t\t\t    show_auto_pwm, NULL, 0, 3);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point1_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 0, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point1_temp_hyst, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point2_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 0, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point3_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 0, 3);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_point4_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 0, 4);\nstatic SENSOR_DEVICE_ATTR_2(pwm1_auto_start, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 0, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1_auto_slope, S_IRUGO | S_IWUSR,\n\t\t\t  show_auto_pwm_slope, set_auto_pwm_slope, 0);\n\nstatic SENSOR_DEVICE_ATTR(pwm2_enable, S_IRUGO | S_IWUSR,\n\t\t\t  show_pwm_enable, set_pwm_enable, 1);\nstatic SENSOR_DEVICE_ATTR(pwm2, S_IRUGO | S_IWUSR, show_pwm, set_pwm, 1);\nstatic SENSOR_DEVICE_ATTR(pwm2_freq, S_IRUGO, show_pwm_freq, set_pwm_freq, 1);\nstatic SENSOR_DEVICE_ATTR(pwm2_auto_channels_temp, S_IRUGO,\n\t\t\t  show_pwm_temp_map, set_pwm_temp_map, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point1_pwm, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 1, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point2_pwm, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 1, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point3_pwm, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 1, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point4_pwm, S_IRUGO,\n\t\t\t    show_auto_pwm, NULL, 1, 3);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point1_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 1, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point1_temp_hyst, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 1, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point2_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 1, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point3_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 1, 3);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_point4_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 1, 4);\nstatic SENSOR_DEVICE_ATTR_2(pwm2_auto_start, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 1, 0);\nstatic SENSOR_DEVICE_ATTR(pwm2_auto_slope, S_IRUGO | S_IWUSR,\n\t\t\t  show_auto_pwm_slope, set_auto_pwm_slope, 1);\n\nstatic SENSOR_DEVICE_ATTR(pwm3_enable, S_IRUGO | S_IWUSR,\n\t\t\t  show_pwm_enable, set_pwm_enable, 2);\nstatic SENSOR_DEVICE_ATTR(pwm3, S_IRUGO | S_IWUSR, show_pwm, set_pwm, 2);\nstatic SENSOR_DEVICE_ATTR(pwm3_freq, S_IRUGO, show_pwm_freq, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(pwm3_auto_channels_temp, S_IRUGO,\n\t\t\t  show_pwm_temp_map, set_pwm_temp_map, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point1_pwm, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point2_pwm, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 2, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point3_pwm, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 2, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point4_pwm, S_IRUGO,\n\t\t\t    show_auto_pwm, NULL, 2, 3);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point1_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point1_temp_hyst, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point2_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point3_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 3);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_point4_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 4);\nstatic SENSOR_DEVICE_ATTR_2(pwm3_auto_start, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 2, 0);\nstatic SENSOR_DEVICE_ATTR(pwm3_auto_slope, S_IRUGO | S_IWUSR,\n\t\t\t  show_auto_pwm_slope, set_auto_pwm_slope, 2);\n\nstatic SENSOR_DEVICE_ATTR(pwm4_enable, S_IRUGO | S_IWUSR,\n\t\t\t  show_pwm_enable, set_pwm_enable, 3);\nstatic SENSOR_DEVICE_ATTR(pwm4, S_IRUGO | S_IWUSR, show_pwm, set_pwm, 3);\nstatic SENSOR_DEVICE_ATTR(pwm4_freq, S_IRUGO, show_pwm_freq, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(pwm4_auto_channels_temp, S_IRUGO,\n\t\t\t  show_pwm_temp_map, set_pwm_temp_map, 3);\nstatic SENSOR_DEVICE_ATTR_2(pwm4_auto_point1_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm4_auto_point1_temp_hyst, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm4_auto_point2_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm4_auto_point3_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 3);\nstatic SENSOR_DEVICE_ATTR_2(pwm4_auto_start, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 3, 0);\nstatic SENSOR_DEVICE_ATTR(pwm4_auto_slope, S_IRUGO | S_IWUSR,\n\t\t\t  show_auto_pwm_slope, set_auto_pwm_slope, 3);\n\nstatic SENSOR_DEVICE_ATTR(pwm5_enable, S_IRUGO | S_IWUSR,\n\t\t\t  show_pwm_enable, set_pwm_enable, 4);\nstatic SENSOR_DEVICE_ATTR(pwm5, S_IRUGO | S_IWUSR, show_pwm, set_pwm, 4);\nstatic SENSOR_DEVICE_ATTR(pwm5_freq, S_IRUGO, show_pwm_freq, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(pwm5_auto_channels_temp, S_IRUGO,\n\t\t\t  show_pwm_temp_map, set_pwm_temp_map, 4);\nstatic SENSOR_DEVICE_ATTR_2(pwm5_auto_point1_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm5_auto_point1_temp_hyst, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm5_auto_point2_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm5_auto_point3_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 3);\nstatic SENSOR_DEVICE_ATTR_2(pwm5_auto_start, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 4, 0);\nstatic SENSOR_DEVICE_ATTR(pwm5_auto_slope, S_IRUGO | S_IWUSR,\n\t\t\t  show_auto_pwm_slope, set_auto_pwm_slope, 4);\n\nstatic SENSOR_DEVICE_ATTR(pwm6_enable, S_IRUGO | S_IWUSR,\n\t\t\t  show_pwm_enable, set_pwm_enable, 5);\nstatic SENSOR_DEVICE_ATTR(pwm6, S_IRUGO | S_IWUSR, show_pwm, set_pwm, 5);\nstatic SENSOR_DEVICE_ATTR(pwm6_freq, S_IRUGO, show_pwm_freq, NULL, 5);\nstatic SENSOR_DEVICE_ATTR(pwm6_auto_channels_temp, S_IRUGO,\n\t\t\t  show_pwm_temp_map, set_pwm_temp_map, 5);\nstatic SENSOR_DEVICE_ATTR_2(pwm6_auto_point1_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 1);\nstatic SENSOR_DEVICE_ATTR_2(pwm6_auto_point1_temp_hyst, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2(pwm6_auto_point2_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 2);\nstatic SENSOR_DEVICE_ATTR_2(pwm6_auto_point3_temp, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_temp, set_auto_temp, 2, 3);\nstatic SENSOR_DEVICE_ATTR_2(pwm6_auto_start, S_IRUGO | S_IWUSR,\n\t\t\t    show_auto_pwm, set_auto_pwm, 5, 0);\nstatic SENSOR_DEVICE_ATTR(pwm6_auto_slope, S_IRUGO | S_IWUSR,\n\t\t\t  show_auto_pwm_slope, set_auto_pwm_slope, 5);\n\n \nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct it87_data *data = it87_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%u\\n\", data->alarms);\n}\nstatic DEVICE_ATTR_RO(alarms);\n\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct it87_data *data = it87_update_device(dev);\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> bitnr) & 1);\n}\n\nstatic ssize_t clear_intrusion(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint err, config;\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val) < 0 || val != 0)\n\t\treturn -EINVAL;\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\tconfig = it87_read_value(data, IT87_REG_CONFIG);\n\tif (config < 0) {\n\t\tcount = config;\n\t} else {\n\t\tconfig |= BIT(5);\n\t\tit87_write_value(data, IT87_REG_CONFIG, config);\n\t\t \n\t\tdata->valid = false;\n\t}\n\tit87_unlock(data);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR(in0_alarm, S_IRUGO, show_alarm, NULL, 8);\nstatic SENSOR_DEVICE_ATTR(in1_alarm, S_IRUGO, show_alarm, NULL, 9);\nstatic SENSOR_DEVICE_ATTR(in2_alarm, S_IRUGO, show_alarm, NULL, 10);\nstatic SENSOR_DEVICE_ATTR(in3_alarm, S_IRUGO, show_alarm, NULL, 11);\nstatic SENSOR_DEVICE_ATTR(in4_alarm, S_IRUGO, show_alarm, NULL, 12);\nstatic SENSOR_DEVICE_ATTR(in5_alarm, S_IRUGO, show_alarm, NULL, 13);\nstatic SENSOR_DEVICE_ATTR(in6_alarm, S_IRUGO, show_alarm, NULL, 14);\nstatic SENSOR_DEVICE_ATTR(in7_alarm, S_IRUGO, show_alarm, NULL, 15);\nstatic SENSOR_DEVICE_ATTR(fan1_alarm, S_IRUGO, show_alarm, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(fan2_alarm, S_IRUGO, show_alarm, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(fan3_alarm, S_IRUGO, show_alarm, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(fan4_alarm, S_IRUGO, show_alarm, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(fan5_alarm, S_IRUGO, show_alarm, NULL, 6);\nstatic SENSOR_DEVICE_ATTR(fan6_alarm, S_IRUGO, show_alarm, NULL, 7);\nstatic SENSOR_DEVICE_ATTR(temp1_alarm, S_IRUGO, show_alarm, NULL, 16);\nstatic SENSOR_DEVICE_ATTR(temp2_alarm, S_IRUGO, show_alarm, NULL, 17);\nstatic SENSOR_DEVICE_ATTR(temp3_alarm, S_IRUGO, show_alarm, NULL, 18);\nstatic SENSOR_DEVICE_ATTR(intrusion0_alarm, S_IRUGO | S_IWUSR,\n\t\t\t  show_alarm, clear_intrusion, 4);\n\nstatic ssize_t show_beep(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct it87_data *data = it87_update_device(dev);\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%u\\n\", (data->beeps >> bitnr) & 1);\n}\n\nstatic ssize_t set_beep(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tlong val;\n\tint err;\n\n\tif (kstrtol(buf, 10, &val) < 0 || (val != 0 && val != 1))\n\t\treturn -EINVAL;\n\n\terr = it87_lock(data);\n\tif (err)\n\t\treturn err;\n\n\tdata->beeps = it87_read_value(data, IT87_REG_BEEP_ENABLE);\n\tif (val)\n\t\tdata->beeps |= BIT(bitnr);\n\telse\n\t\tdata->beeps &= ~BIT(bitnr);\n\tit87_write_value(data, IT87_REG_BEEP_ENABLE, data->beeps);\n\tit87_unlock(data);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR(in0_beep, S_IRUGO | S_IWUSR,\n\t\t\t  show_beep, set_beep, 1);\nstatic SENSOR_DEVICE_ATTR(in1_beep, S_IRUGO, show_beep, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in2_beep, S_IRUGO, show_beep, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in3_beep, S_IRUGO, show_beep, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in4_beep, S_IRUGO, show_beep, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in5_beep, S_IRUGO, show_beep, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in6_beep, S_IRUGO, show_beep, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in7_beep, S_IRUGO, show_beep, NULL, 1);\n \nstatic SENSOR_DEVICE_ATTR(fan1_beep, S_IRUGO, show_beep, set_beep, 0);\nstatic SENSOR_DEVICE_ATTR(fan2_beep, S_IRUGO, show_beep, set_beep, 0);\nstatic SENSOR_DEVICE_ATTR(fan3_beep, S_IRUGO, show_beep, set_beep, 0);\nstatic SENSOR_DEVICE_ATTR(fan4_beep, S_IRUGO, show_beep, set_beep, 0);\nstatic SENSOR_DEVICE_ATTR(fan5_beep, S_IRUGO, show_beep, set_beep, 0);\nstatic SENSOR_DEVICE_ATTR(fan6_beep, S_IRUGO, show_beep, set_beep, 0);\nstatic SENSOR_DEVICE_ATTR(temp1_beep, S_IRUGO | S_IWUSR,\n\t\t\t  show_beep, set_beep, 2);\nstatic SENSOR_DEVICE_ATTR(temp2_beep, S_IRUGO, show_beep, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(temp3_beep, S_IRUGO, show_beep, NULL, 2);\n\nstatic ssize_t vrm_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", data->vrm);\n}\n\nstatic ssize_t vrm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tdata->vrm = val;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(vrm);\n\nstatic ssize_t cpu0_vid_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct it87_data *data = it87_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%ld\\n\", (long)vid_from_reg(data->vid, data->vrm));\n}\nstatic DEVICE_ATTR_RO(cpu0_vid);\n\nstatic ssize_t show_label(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstatic const char * const labels[] = {\n\t\t\"+5V\",\n\t\t\"5VSB\",\n\t\t\"Vbat\",\n\t\t\"AVCC\",\n\t};\n\tstatic const char * const labels_it8721[] = {\n\t\t\"+3.3V\",\n\t\t\"3VSB\",\n\t\t\"Vbat\",\n\t\t\"+3.3V\",\n\t};\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tconst char *label;\n\n\tif (has_vin3_5v(data) && nr == 0)\n\t\tlabel = labels[0];\n\telse if (has_scaling(data))\n\t\tlabel = labels_it8721[nr];\n\telse\n\t\tlabel = labels[nr];\n\n\treturn sprintf(buf, \"%s\\n\", label);\n}\nstatic SENSOR_DEVICE_ATTR(in3_label, S_IRUGO, show_label, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(in7_label, S_IRUGO, show_label, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in8_label, S_IRUGO, show_label, NULL, 2);\n \nstatic SENSOR_DEVICE_ATTR(in9_label, S_IRUGO, show_label, NULL, 3);\n\nstatic umode_t it87_in_is_visible(struct kobject *kobj,\n\t\t\t\t  struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint i = index / 5;\t \n\tint a = index % 5;\t \n\n\tif (index >= 40) {\t \n\t\ti = index - 40 + 8;\n\t\ta = 0;\n\t}\n\n\tif (!(data->has_in & BIT(i)))\n\t\treturn 0;\n\n\tif (a == 4 && !data->has_beep)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic struct attribute *it87_attributes_in[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in0_beep.dev_attr.attr,\t \n\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_beep.dev_attr.attr,\t \n\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_beep.dev_attr.attr,\t \n\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_beep.dev_attr.attr,\t \n\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in4_beep.dev_attr.attr,\t \n\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in5_beep.dev_attr.attr,\t \n\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_min.dev_attr.attr,\n\t&sensor_dev_attr_in6_max.dev_attr.attr,\n\t&sensor_dev_attr_in6_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in6_beep.dev_attr.attr,\t \n\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_min.dev_attr.attr,\n\t&sensor_dev_attr_in7_max.dev_attr.attr,\n\t&sensor_dev_attr_in7_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in7_beep.dev_attr.attr,\t \n\n\t&sensor_dev_attr_in8_input.dev_attr.attr,\t \n\t&sensor_dev_attr_in9_input.dev_attr.attr,\n\t&sensor_dev_attr_in10_input.dev_attr.attr,\n\t&sensor_dev_attr_in11_input.dev_attr.attr,\n\t&sensor_dev_attr_in12_input.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group it87_group_in = {\n\t.attrs = it87_attributes_in,\n\t.is_visible = it87_in_is_visible,\n};\n\nstatic umode_t it87_temp_is_visible(struct kobject *kobj,\n\t\t\t\t    struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint i = index / 7;\t \n\tint a = index % 7;\t \n\n\tif (index >= 21) {\n\t\ti = index - 21 + 3;\n\t\ta = 0;\n\t}\n\n\tif (!(data->has_temp & BIT(i)))\n\t\treturn 0;\n\n\tif (a == 3) {\n\t\tif (get_temp_type(data, i) == 0)\n\t\t\treturn 0;\n\t\treturn attr->mode;\n\t}\n\n\tif (a == 5 && !has_temp_offset(data))\n\t\treturn 0;\n\n\tif (a == 6 && !data->has_beep)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic struct attribute *it87_attributes_temp[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_type.dev_attr.attr,\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_offset.dev_attr.attr,\t \n\t&sensor_dev_attr_temp1_beep.dev_attr.attr,\t \n\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\t \n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_type.dev_attr.attr,\n\t&sensor_dev_attr_temp2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp2_beep.dev_attr.attr,\n\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\t \n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_type.dev_attr.attr,\n\t&sensor_dev_attr_temp3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp3_beep.dev_attr.attr,\n\n\t&sensor_dev_attr_temp4_input.dev_attr.attr,\t \n\t&sensor_dev_attr_temp5_input.dev_attr.attr,\n\t&sensor_dev_attr_temp6_input.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group it87_group_temp = {\n\t.attrs = it87_attributes_temp,\n\t.is_visible = it87_temp_is_visible,\n};\n\nstatic umode_t it87_is_visible(struct kobject *kobj,\n\t\t\t       struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\n\tif ((index == 2 || index == 3) && !data->has_vid)\n\t\treturn 0;\n\n\tif (index > 3 && !(data->in_internal & BIT(index - 4)))\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic struct attribute *it87_attributes[] = {\n\t&dev_attr_alarms.attr,\n\t&sensor_dev_attr_intrusion0_alarm.dev_attr.attr,\n\t&dev_attr_vrm.attr,\t\t\t\t \n\t&dev_attr_cpu0_vid.attr,\t\t\t \n\t&sensor_dev_attr_in3_label.dev_attr.attr,\t \n\t&sensor_dev_attr_in7_label.dev_attr.attr,\n\t&sensor_dev_attr_in8_label.dev_attr.attr,\n\t&sensor_dev_attr_in9_label.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group it87_group = {\n\t.attrs = it87_attributes,\n\t.is_visible = it87_is_visible,\n};\n\nstatic umode_t it87_fan_is_visible(struct kobject *kobj,\n\t\t\t\t   struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint i = index / 5;\t \n\tint a = index % 5;\t \n\n\tif (index >= 15) {\t \n\t\ti = (index - 15) / 4 + 3;\n\t\ta = (index - 15) % 4;\n\t}\n\n\tif (!(data->has_fan & BIT(i)))\n\t\treturn 0;\n\n\tif (a == 3) {\t\t\t\t \n\t\tif (!data->has_beep)\n\t\t\treturn 0;\n\t\t \n\t\tif (i == __ffs(data->has_fan))\n\t\t\treturn attr->mode | S_IWUSR;\n\t}\n\n\tif (a == 4 && has_16bit_fans(data))\t \n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic struct attribute *it87_attributes_fan[] = {\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan1_beep.dev_attr.attr,\t \n\t&sensor_dev_attr_fan1_div.dev_attr.attr,\t \n\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_beep.dev_attr.attr,\n\t&sensor_dev_attr_fan2_div.dev_attr.attr,\t \n\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan3_beep.dev_attr.attr,\n\t&sensor_dev_attr_fan3_div.dev_attr.attr,\t \n\n\t&sensor_dev_attr_fan4_input.dev_attr.attr,\t \n\t&sensor_dev_attr_fan4_min.dev_attr.attr,\n\t&sensor_dev_attr_fan4_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan4_beep.dev_attr.attr,\n\n\t&sensor_dev_attr_fan5_input.dev_attr.attr,\t \n\t&sensor_dev_attr_fan5_min.dev_attr.attr,\n\t&sensor_dev_attr_fan5_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan5_beep.dev_attr.attr,\n\n\t&sensor_dev_attr_fan6_input.dev_attr.attr,\t \n\t&sensor_dev_attr_fan6_min.dev_attr.attr,\n\t&sensor_dev_attr_fan6_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan6_beep.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group it87_group_fan = {\n\t.attrs = it87_attributes_fan,\n\t.is_visible = it87_fan_is_visible,\n};\n\nstatic umode_t it87_pwm_is_visible(struct kobject *kobj,\n\t\t\t\t   struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint i = index / 4;\t \n\tint a = index % 4;\t \n\n\tif (!(data->has_pwm & BIT(i)))\n\t\treturn 0;\n\n\t \n\tif (a == 3 && (has_old_autopwm(data) || has_newer_autopwm(data)))\n\t\treturn attr->mode | S_IWUSR;\n\n\t \n\tif (has_pwm_freq2(data) && i == 1 && a == 2)\n\t\treturn attr->mode | S_IWUSR;\n\n\treturn attr->mode;\n}\n\nstatic struct attribute *it87_attributes_pwm[] = {\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_channels_temp.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_channels_temp.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_channels_temp.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm4_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm4.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_channels_temp.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm5_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm5.dev_attr.attr,\n\t&sensor_dev_attr_pwm5_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm5_auto_channels_temp.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm6_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm6.dev_attr.attr,\n\t&sensor_dev_attr_pwm6_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm6_auto_channels_temp.dev_attr.attr,\n\n\tNULL\n};\n\nstatic const struct attribute_group it87_group_pwm = {\n\t.attrs = it87_attributes_pwm,\n\t.is_visible = it87_pwm_is_visible,\n};\n\nstatic umode_t it87_auto_pwm_is_visible(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\tint i = index / 11;\t \n\tint a = index % 11;\t \n\n\tif (index >= 33) {\t \n\t\ti = (index - 33) / 6 + 3;\n\t\ta = (index - 33) % 6 + 4;\n\t}\n\n\tif (!(data->has_pwm & BIT(i)))\n\t\treturn 0;\n\n\tif (has_newer_autopwm(data)) {\n\t\tif (a < 4)\t \n\t\t\treturn 0;\n\t\tif (a == 8)\t \n\t\t\treturn 0;\n\t}\n\tif (has_old_autopwm(data)) {\n\t\tif (a >= 9)\t \n\t\t\treturn 0;\n\t}\n\n\treturn attr->mode;\n}\n\nstatic struct attribute *it87_attributes_auto_pwm[] = {\n\t&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_start.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_slope.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm2_auto_point1_pwm.dev_attr.attr,\t \n\t&sensor_dev_attr_pwm2_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point3_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point4_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point4_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_start.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_slope.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm3_auto_point1_pwm.dev_attr.attr,\t \n\t&sensor_dev_attr_pwm3_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point3_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point4_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point4_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_start.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_slope.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm4_auto_point1_temp.dev_attr.attr,\t \n\t&sensor_dev_attr_pwm4_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_start.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_slope.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm5_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm5_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm5_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm5_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm5_auto_start.dev_attr.attr,\n\t&sensor_dev_attr_pwm5_auto_slope.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm6_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm6_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm6_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm6_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm6_auto_start.dev_attr.attr,\n\t&sensor_dev_attr_pwm6_auto_slope.dev_attr.attr,\n\n\tNULL,\n};\n\nstatic const struct attribute_group it87_group_auto_pwm = {\n\t.attrs = it87_attributes_auto_pwm,\n\t.is_visible = it87_auto_pwm_is_visible,\n};\n\n \nstatic int __init it87_find(int sioaddr, unsigned short *address,\n\t\t\t    struct it87_sio_data *sio_data, int chip_cnt)\n{\n\tint err;\n\tu16 chip_type;\n\tconst struct it87_devices *config = NULL;\n\n\terr = superio_enter(sioaddr);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENODEV;\n\tchip_type = superio_inw(sioaddr, DEVID);\n\t \n\tif (chip_type == 0xffff)\n\t\tgoto exit;\n\n\tif (force_id_cnt == 1) {\n\t\t \n\t\tif (force_id[0])\n\t\t\tchip_type = force_id[0];\n\t} else if (force_id[chip_cnt])\n\t\tchip_type = force_id[chip_cnt];\n\n\tswitch (chip_type) {\n\tcase IT8705F_DEVID:\n\t\tsio_data->type = it87;\n\t\tbreak;\n\tcase IT8712F_DEVID:\n\t\tsio_data->type = it8712;\n\t\tbreak;\n\tcase IT8716F_DEVID:\n\tcase IT8726F_DEVID:\n\t\tsio_data->type = it8716;\n\t\tbreak;\n\tcase IT8718F_DEVID:\n\t\tsio_data->type = it8718;\n\t\tbreak;\n\tcase IT8720F_DEVID:\n\t\tsio_data->type = it8720;\n\t\tbreak;\n\tcase IT8721F_DEVID:\n\t\tsio_data->type = it8721;\n\t\tbreak;\n\tcase IT8728F_DEVID:\n\t\tsio_data->type = it8728;\n\t\tbreak;\n\tcase IT8732F_DEVID:\n\t\tsio_data->type = it8732;\n\t\tbreak;\n\tcase IT8792E_DEVID:\n\t\tsio_data->type = it8792;\n\t\tbreak;\n\tcase IT8771E_DEVID:\n\t\tsio_data->type = it8771;\n\t\tbreak;\n\tcase IT8772E_DEVID:\n\t\tsio_data->type = it8772;\n\t\tbreak;\n\tcase IT8781F_DEVID:\n\t\tsio_data->type = it8781;\n\t\tbreak;\n\tcase IT8782F_DEVID:\n\t\tsio_data->type = it8782;\n\t\tbreak;\n\tcase IT8783E_DEVID:\n\t\tsio_data->type = it8783;\n\t\tbreak;\n\tcase IT8786E_DEVID:\n\t\tsio_data->type = it8786;\n\t\tbreak;\n\tcase IT8790E_DEVID:\n\t\tsio_data->type = it8790;\n\t\tbreak;\n\tcase IT8603E_DEVID:\n\tcase IT8623E_DEVID:\n\t\tsio_data->type = it8603;\n\t\tbreak;\n\tcase IT8620E_DEVID:\n\t\tsio_data->type = it8620;\n\t\tbreak;\n\tcase IT8622E_DEVID:\n\t\tsio_data->type = it8622;\n\t\tbreak;\n\tcase IT8628E_DEVID:\n\t\tsio_data->type = it8628;\n\t\tbreak;\n\tcase IT87952E_DEVID:\n\t\tsio_data->type = it87952;\n\t\tbreak;\n\tcase 0xffff:\t \n\t\tgoto exit;\n\tdefault:\n\t\tpr_debug(\"Unsupported chip (DEVID=0x%x)\\n\", chip_type);\n\t\tgoto exit;\n\t}\n\n\tconfig = &it87_devices[sio_data->type];\n\n\tsuperio_select(sioaddr, PME);\n\tif (!(superio_inb(sioaddr, IT87_ACT_REG) & 0x01)) {\n\t\tpr_info(\"Device (chip %s ioreg 0x%x) not activated, skipping\\n\",\n\t\t\tconfig->model, sioaddr);\n\t\tgoto exit;\n\t}\n\n\t*address = superio_inw(sioaddr, IT87_BASE_REG) & ~(IT87_EXTENT - 1);\n\tif (*address == 0) {\n\t\tpr_info(\"Base address not set (chip %s ioreg 0x%x), skipping\\n\",\n\t\t\tconfig->model, sioaddr);\n\t\tgoto exit;\n\t}\n\n\terr = 0;\n\tsio_data->sioaddr = sioaddr;\n\tsio_data->revision = superio_inb(sioaddr, DEVREV) & 0x0f;\n\tpr_info(\"Found %s chip at 0x%x, revision %d\\n\",\n\t\tit87_devices[sio_data->type].model,\n\t\t*address, sio_data->revision);\n\n\t \n\tif (has_in7_internal(config))\n\t\tsio_data->internal |= BIT(1);\n\n\t \n\tsio_data->internal |= BIT(2);\n\n\t \n\tif (has_avcc3(config))\n\t\tsio_data->internal |= BIT(3);  \n\telse\n\t\tsio_data->skip_in |= BIT(9);\n\n\tif (!has_four_pwm(config))\n\t\tsio_data->skip_pwm |= BIT(3) | BIT(4) | BIT(5);\n\telse if (!has_five_pwm(config))\n\t\tsio_data->skip_pwm |= BIT(4) | BIT(5);\n\telse if (!has_six_pwm(config))\n\t\tsio_data->skip_pwm |= BIT(5);\n\n\tif (!has_vid(config))\n\t\tsio_data->skip_vid = 1;\n\n\t \n\tif (sio_data->type == it87) {\n\t\t \n\t\tsuperio_select(sioaddr, 5);\n\t\tsio_data->beep_pin = superio_inb(sioaddr,\n\t\t\t\t\t\t IT87_SIO_BEEP_PIN_REG) & 0x3f;\n\t} else if (sio_data->type == it8783) {\n\t\tint reg25, reg27, reg2a, reg2c, regef;\n\n\t\tsuperio_select(sioaddr, GPIO);\n\n\t\treg25 = superio_inb(sioaddr, IT87_SIO_GPIO1_REG);\n\t\treg27 = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);\n\t\treg2a = superio_inb(sioaddr, IT87_SIO_PINX1_REG);\n\t\treg2c = superio_inb(sioaddr, IT87_SIO_PINX2_REG);\n\t\tregef = superio_inb(sioaddr, IT87_SIO_SPI_REG);\n\n\t\t \n\t\tif ((reg27 & BIT(0)) || !(reg2c & BIT(2)))\n\t\t\tsio_data->skip_fan |= BIT(2);\n\t\tif ((reg25 & BIT(4)) ||\n\t\t    (!(reg2a & BIT(1)) && (regef & BIT(0))))\n\t\t\tsio_data->skip_pwm |= BIT(2);\n\n\t\t \n\t\tif (reg27 & BIT(7))\n\t\t\tsio_data->skip_fan |= BIT(1);\n\t\tif (reg27 & BIT(3))\n\t\t\tsio_data->skip_pwm |= BIT(1);\n\n\t\t \n\t\tif ((reg27 & BIT(0)) || (reg2c & BIT(2)))\n\t\t\tsio_data->skip_in |= BIT(5);  \n\n\t\t \n\t\tif (reg27 & BIT(1))\n\t\t\tsio_data->skip_in |= BIT(6);  \n\n\t\t \n\t\tif (reg27 & BIT(2)) {\n\t\t\t \n\t\t\tif (!(reg2c & BIT(1))) {\n\t\t\t\treg2c |= BIT(1);\n\t\t\t\tsuperio_outb(sioaddr, IT87_SIO_PINX2_REG,\n\t\t\t\t\t     reg2c);\n\t\t\t\tsio_data->need_in7_reroute = true;\n\t\t\t\tpr_notice(\"Routing internal VCCH5V to in7.\\n\");\n\t\t\t}\n\t\t\tpr_notice(\"in7 routed to internal voltage divider, with external pin disabled.\\n\");\n\t\t\tpr_notice(\"Please report if it displays a reasonable voltage.\\n\");\n\t\t}\n\n\t\tif (reg2c & BIT(0))\n\t\t\tsio_data->internal |= BIT(0);\n\t\tif (reg2c & BIT(1))\n\t\t\tsio_data->internal |= BIT(1);\n\n\t\tsio_data->beep_pin = superio_inb(sioaddr,\n\t\t\t\t\t\t IT87_SIO_BEEP_PIN_REG) & 0x3f;\n\t} else if (sio_data->type == it8603) {\n\t\tint reg27, reg29;\n\n\t\tsuperio_select(sioaddr, GPIO);\n\n\t\treg27 = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);\n\n\t\t \n\t\tif (reg27 & BIT(6))\n\t\t\tsio_data->skip_pwm |= BIT(2);\n\t\tif (reg27 & BIT(7))\n\t\t\tsio_data->skip_fan |= BIT(2);\n\n\t\t \n\t\treg29 = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);\n\t\tif (reg29 & BIT(1))\n\t\t\tsio_data->skip_pwm |= BIT(1);\n\t\tif (reg29 & BIT(2))\n\t\t\tsio_data->skip_fan |= BIT(1);\n\n\t\tsio_data->skip_in |= BIT(5);  \n\t\tsio_data->skip_in |= BIT(6);  \n\n\t\tsio_data->beep_pin = superio_inb(sioaddr,\n\t\t\t\t\t\t IT87_SIO_BEEP_PIN_REG) & 0x3f;\n\t} else if (sio_data->type == it8620 || sio_data->type == it8628) {\n\t\tint reg;\n\n\t\tsuperio_select(sioaddr, GPIO);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO1_REG);\n\t\tif (reg & BIT(6))\n\t\t\tsio_data->skip_pwm |= BIT(4);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO2_REG);\n\t\tif (!(reg & BIT(5)))\n\t\t\tsio_data->skip_fan |= BIT(3);\n\t\tif (!(reg & BIT(4)))\n\t\t\tsio_data->skip_fan |= BIT(4);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);\n\t\tif (reg & BIT(6))\n\t\t\tsio_data->skip_pwm |= BIT(2);\n\t\tif (reg & BIT(7))\n\t\t\tsio_data->skip_fan |= BIT(2);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO4_REG);\n\t\tif (reg & BIT(2))\n\t\t\tsio_data->skip_pwm |= BIT(3);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);\n\t\tif (reg & BIT(1))\n\t\t\tsio_data->skip_pwm |= BIT(1);\n\t\tif (reg & BIT(2))\n\t\t\tsio_data->skip_fan |= BIT(1);\n\t\t \n\t\tif (!(reg & BIT(7))) {\n\t\t\tsio_data->skip_pwm |= BIT(5);\n\t\t\tsio_data->skip_fan |= BIT(5);\n\t\t}\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);\n\t\tif (reg & BIT(0))\n\t\t\tsio_data->internal |= BIT(0);\n\t\telse\n\t\t\tsio_data->skip_in |= BIT(9);\n\n\t\tsio_data->beep_pin = superio_inb(sioaddr,\n\t\t\t\t\t\t IT87_SIO_BEEP_PIN_REG) & 0x3f;\n\t} else if (sio_data->type == it8622) {\n\t\tint reg;\n\n\t\tsuperio_select(sioaddr, GPIO);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO1_REG);\n\t\tif (reg & BIT(6))\n\t\t\tsio_data->skip_fan |= BIT(3);\n\t\tif (reg & BIT(5))\n\t\t\tsio_data->skip_pwm |= BIT(3);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);\n\t\tif (reg & BIT(6))\n\t\t\tsio_data->skip_pwm |= BIT(2);\n\t\tif (reg & BIT(7))\n\t\t\tsio_data->skip_fan |= BIT(2);\n\t\tif (reg & BIT(3))\n\t\t\tsio_data->skip_pwm |= BIT(4);\n\t\tif (reg & BIT(1))\n\t\t\tsio_data->skip_fan |= BIT(4);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);\n\t\tif (reg & BIT(1))\n\t\t\tsio_data->skip_pwm |= BIT(1);\n\t\tif (reg & BIT(2))\n\t\t\tsio_data->skip_fan |= BIT(1);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);\n\t\tif (!(reg & BIT(0)))\n\t\t\tsio_data->skip_in |= BIT(9);\n\n\t\tsio_data->beep_pin = superio_inb(sioaddr,\n\t\t\t\t\t\t IT87_SIO_BEEP_PIN_REG) & 0x3f;\n\t} else if (sio_data->type == it8732) {\n\t\tint reg;\n\n\t\tsuperio_select(sioaddr, GPIO);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);\n\t\tif (reg & BIT(1))\n\t\t\tsio_data->skip_pwm |= BIT(1);\n\t\tif (reg & BIT(2))\n\t\t\tsio_data->skip_fan |= BIT(1);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);\n\t\tif (reg & BIT(6))\n\t\t\tsio_data->skip_pwm |= BIT(2);\n\t\tif (reg & BIT(7))\n\t\t\tsio_data->skip_fan |= BIT(2);\n\t\tif (reg & BIT(5))\n\t\t\tsio_data->skip_fan |= BIT(3);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);\n\t\tif (reg & BIT(0))\n\t\t\tsio_data->internal |= BIT(0);\n\n\t\tsio_data->beep_pin = superio_inb(sioaddr,\n\t\t\t\t\t\t IT87_SIO_BEEP_PIN_REG) & 0x3f;\n\t} else {\n\t\tint reg;\n\t\tbool uart6;\n\n\t\tsuperio_select(sioaddr, GPIO);\n\n\t\t \n\t\tif (has_five_fans(config)) {\n\t\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO2_REG);\n\t\t\tswitch (sio_data->type) {\n\t\t\tcase it8718:\n\t\t\t\tif (reg & BIT(5))\n\t\t\t\t\tsio_data->skip_fan |= BIT(3);\n\t\t\t\tif (reg & BIT(4))\n\t\t\t\t\tsio_data->skip_fan |= BIT(4);\n\t\t\t\tbreak;\n\t\t\tcase it8720:\n\t\t\tcase it8721:\n\t\t\tcase it8728:\n\t\t\t\tif (!(reg & BIT(5)))\n\t\t\t\t\tsio_data->skip_fan |= BIT(3);\n\t\t\t\tif (!(reg & BIT(4)))\n\t\t\t\t\tsio_data->skip_fan |= BIT(4);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);\n\t\tif (!sio_data->skip_vid) {\n\t\t\t \n\t\t\tif (reg & 0x0f) {\n\t\t\t\tpr_info(\"VID is disabled (pins used for GPIO)\\n\");\n\t\t\t\tsio_data->skip_vid = 1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (reg & BIT(6))\n\t\t\tsio_data->skip_pwm |= BIT(2);\n\t\tif (reg & BIT(7))\n\t\t\tsio_data->skip_fan |= BIT(2);\n\n\t\t \n\t\treg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);\n\t\tif (reg & BIT(1))\n\t\t\tsio_data->skip_pwm |= BIT(1);\n\t\tif (reg & BIT(2))\n\t\t\tsio_data->skip_fan |= BIT(1);\n\n\t\tif ((sio_data->type == it8718 || sio_data->type == it8720) &&\n\t\t    !(sio_data->skip_vid))\n\t\t\tsio_data->vid_value = superio_inb(sioaddr,\n\t\t\t\t\t\t\t  IT87_SIO_VID_REG);\n\n\t\treg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);\n\n\t\tuart6 = sio_data->type == it8782 && (reg & BIT(2));\n\n\t\t \n\t\tif ((sio_data->type == it8720 || uart6) && !(reg & BIT(1))) {\n\t\t\treg |= BIT(1);\n\t\t\tsuperio_outb(sioaddr, IT87_SIO_PINX2_REG, reg);\n\t\t\tsio_data->need_in7_reroute = true;\n\t\t\tpr_notice(\"Routing internal VCCH5V to in7\\n\");\n\t\t}\n\t\tif (reg & BIT(0))\n\t\t\tsio_data->internal |= BIT(0);\n\t\tif (reg & BIT(1))\n\t\t\tsio_data->internal |= BIT(1);\n\n\t\t \n\t\tif (uart6) {\n\t\t\tsio_data->skip_in |= BIT(5) | BIT(6);\n\t\t\tsio_data->skip_temp |= BIT(2);\n\t\t}\n\n\t\tsio_data->beep_pin = superio_inb(sioaddr,\n\t\t\t\t\t\t IT87_SIO_BEEP_PIN_REG) & 0x3f;\n\t}\n\tif (sio_data->beep_pin)\n\t\tpr_info(\"Beeping is supported\\n\");\n\n\t \n\tif (dmi_data)\n\t\tsio_data->skip_pwm |= dmi_data->skip_pwm;\n\n\tif (config->smbus_bitmap) {\n\t\tu8 reg;\n\n\t\tsuperio_select(sioaddr, PME);\n\t\treg = superio_inb(sioaddr, IT87_SPECIAL_CFG_REG);\n\t\tsio_data->ec_special_config = reg;\n\t\tsio_data->smbus_bitmap = reg & config->smbus_bitmap;\n\t}\n\nexit:\n\tsuperio_exit(sioaddr, config ? has_conf_noexit(config) : false);\n\treturn err;\n}\n\n \nstatic void it87_check_limit_regs(struct it87_data *data)\n{\n\tint i, reg;\n\n\tfor (i = 0; i < NUM_VIN_LIMIT; i++) {\n\t\treg = it87_read_value(data, IT87_REG_VIN_MIN(i));\n\t\tif (reg == 0xff)\n\t\t\tit87_write_value(data, IT87_REG_VIN_MIN(i), 0);\n\t}\n\tfor (i = 0; i < NUM_TEMP_LIMIT; i++) {\n\t\treg = it87_read_value(data, IT87_REG_TEMP_HIGH(i));\n\t\tif (reg == 0xff)\n\t\t\tit87_write_value(data, IT87_REG_TEMP_HIGH(i), 127);\n\t}\n}\n\n \nstatic void it87_check_voltage_monitors_reset(struct it87_data *data)\n{\n\tint reg;\n\n\treg = it87_read_value(data, IT87_REG_VIN_ENABLE);\n\tif ((reg & 0xff) == 0) {\n\t\t \n\t\tit87_write_value(data, IT87_REG_VIN_ENABLE, 0xff);\n\t}\n}\n\n \nstatic void it87_check_tachometers_reset(struct platform_device *pdev)\n{\n\tstruct it87_sio_data *sio_data = dev_get_platdata(&pdev->dev);\n\tstruct it87_data *data = platform_get_drvdata(pdev);\n\tu8 mask, fan_main_ctrl;\n\n\tmask = 0x70 & ~(sio_data->skip_fan << 4);\n\tfan_main_ctrl = it87_read_value(data, IT87_REG_FAN_MAIN_CTRL);\n\tif ((fan_main_ctrl & mask) == 0) {\n\t\t \n\t\tfan_main_ctrl |= mask;\n\t\tit87_write_value(data, IT87_REG_FAN_MAIN_CTRL,\n\t\t\t\t fan_main_ctrl);\n\t}\n}\n\n \nstatic void it87_check_tachometers_16bit_mode(struct platform_device *pdev)\n{\n\tstruct it87_data *data = platform_get_drvdata(pdev);\n\tint reg;\n\n\tif (!has_fan16_config(data))\n\t\treturn;\n\n\treg = it87_read_value(data, IT87_REG_FAN_16BIT);\n\tif (~reg & 0x07 & data->has_fan) {\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"Setting fan1-3 to 16-bit mode\\n\");\n\t\tit87_write_value(data, IT87_REG_FAN_16BIT,\n\t\t\t\t reg | 0x07);\n\t}\n}\n\nstatic void it87_start_monitoring(struct it87_data *data)\n{\n\tit87_write_value(data, IT87_REG_CONFIG,\n\t\t\t (it87_read_value(data, IT87_REG_CONFIG) & 0x3e)\n\t\t\t | (update_vbat ? 0x41 : 0x01));\n}\n\n \nstatic void it87_init_device(struct platform_device *pdev)\n{\n\tstruct it87_sio_data *sio_data = dev_get_platdata(&pdev->dev);\n\tstruct it87_data *data = platform_get_drvdata(pdev);\n\tint tmp, i;\n\n\t \n\tfor (i = 0; i < NUM_AUTO_PWM; i++) {\n\t\tdata->pwm_temp_map[i] = i;\n\t\tdata->pwm_duty[i] = 0x7f;\t \n\t\tdata->auto_pwm[i][3] = 0x7f;\t \n\t}\n\n\tit87_check_limit_regs(data);\n\n\t \n\n\tit87_check_voltage_monitors_reset(data);\n\n\tit87_check_tachometers_reset(pdev);\n\n\tdata->fan_main_ctrl = it87_read_value(data, IT87_REG_FAN_MAIN_CTRL);\n\tdata->has_fan = (data->fan_main_ctrl >> 4) & 0x07;\n\n\tit87_check_tachometers_16bit_mode(pdev);\n\n\t \n\ttmp = it87_read_value(data, IT87_REG_FAN_16BIT);\n\n\tif (has_four_fans(data) && (tmp & BIT(4)))\n\t\tdata->has_fan |= BIT(3);  \n\tif (has_five_fans(data) && (tmp & BIT(5)))\n\t\tdata->has_fan |= BIT(4);  \n\tif (has_six_fans(data) && (tmp & BIT(2)))\n\t\tdata->has_fan |= BIT(5);  \n\n\t \n\tdata->has_fan &= ~sio_data->skip_fan;\n\n\t \n\tif (has_six_pwm(data)) {\n\t\t \n\t\ttmp = it87_read_value(data, IT87_REG_FAN_DIV);\n\t\tif ((tmp & 0xc0) == 0xc0)\n\t\t\tsio_data->skip_pwm |= BIT(4);\n\t\tif (!(tmp & BIT(3)))\n\t\t\tsio_data->skip_pwm |= BIT(5);\n\t}\n\n\tit87_start_monitoring(data);\n}\n\n \nstatic int it87_check_pwm(struct device *dev)\n{\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\t \n\tint tmp = it87_read_value(data, IT87_REG_FAN_CTL);\n\n\tif ((tmp & 0x87) == 0) {\n\t\tif (fix_pwm_polarity) {\n\t\t\t \n\t\t\tint i;\n\t\t\tu8 pwm[3];\n\n\t\t\tfor (i = 0; i < ARRAY_SIZE(pwm); i++)\n\t\t\t\tpwm[i] = it87_read_value(data,\n\t\t\t\t\t\t\t IT87_REG_PWM[i]);\n\n\t\t\t \n\t\t\tif (!((pwm[0] | pwm[1] | pwm[2]) & 0x80)) {\n\t\t\t\tdev_info(dev,\n\t\t\t\t\t \"Reconfiguring PWM to active high polarity\\n\");\n\t\t\t\tit87_write_value(data, IT87_REG_FAN_CTL,\n\t\t\t\t\t\t tmp | 0x87);\n\t\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\t\tit87_write_value(data,\n\t\t\t\t\t\t\t IT87_REG_PWM[i],\n\t\t\t\t\t\t\t 0x7f & ~pwm[i]);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tdev_info(dev,\n\t\t\t\t \"PWM configuration is too broken to be fixed\\n\");\n\t\t}\n\n\t\treturn 0;\n\t} else if (fix_pwm_polarity) {\n\t\tdev_info(dev,\n\t\t\t \"PWM configuration looks sane, won't touch\\n\");\n\t}\n\n\treturn 1;\n}\n\nstatic int it87_probe(struct platform_device *pdev)\n{\n\tstruct it87_data *data;\n\tstruct resource *res;\n\tstruct device *dev = &pdev->dev;\n\tstruct it87_sio_data *sio_data = dev_get_platdata(dev);\n\tint enable_pwm_interface;\n\tstruct device *hwmon_dev;\n\tint err;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!devm_request_region(&pdev->dev, res->start, IT87_EC_EXTENT,\n\t\t\t\t DRVNAME)) {\n\t\tdev_err(dev, \"Failed to request region 0x%lx-0x%lx\\n\",\n\t\t\t(unsigned long)res->start,\n\t\t\t(unsigned long)(res->start + IT87_EC_EXTENT - 1));\n\t\treturn -EBUSY;\n\t}\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct it87_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->addr = res->start;\n\tdata->sioaddr = sio_data->sioaddr;\n\tdata->type = sio_data->type;\n\tdata->smbus_bitmap = sio_data->smbus_bitmap;\n\tdata->ec_special_config = sio_data->ec_special_config;\n\tdata->features = it87_devices[sio_data->type].features;\n\tdata->peci_mask = it87_devices[sio_data->type].peci_mask;\n\tdata->old_peci_mask = it87_devices[sio_data->type].old_peci_mask;\n\t \n\tswitch (data->type) {\n\tcase it87:\n\t\tif (sio_data->revision >= 0x03) {\n\t\t\tdata->features &= ~FEAT_OLD_AUTOPWM;\n\t\t\tdata->features |= FEAT_FAN16_CONFIG | FEAT_16BIT_FANS;\n\t\t}\n\t\tbreak;\n\tcase it8712:\n\t\tif (sio_data->revision >= 0x08) {\n\t\t\tdata->features &= ~FEAT_OLD_AUTOPWM;\n\t\t\tdata->features |= FEAT_FAN16_CONFIG | FEAT_16BIT_FANS |\n\t\t\t\t\t  FEAT_FIVE_FANS;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\tmutex_init(&data->update_lock);\n\n\terr = smbus_disable(data);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif ((it87_read_value(data, IT87_REG_CONFIG) & 0x80) ||\n\t    it87_read_value(data, IT87_REG_CHIPID) != 0x90) {\n\t\tsmbus_enable(data);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tenable_pwm_interface = it87_check_pwm(dev);\n\tif (!enable_pwm_interface)\n\t\tdev_info(dev,\n\t\t\t \"Detected broken BIOS defaults, disabling PWM interface\\n\");\n\n\t \n\tif (has_scaling(data)) {\n\t\tif (sio_data->internal & BIT(0))\n\t\t\tdata->in_scaled |= BIT(3);\t \n\t\tif (sio_data->internal & BIT(1))\n\t\t\tdata->in_scaled |= BIT(7);\t \n\t\tif (sio_data->internal & BIT(2))\n\t\t\tdata->in_scaled |= BIT(8);\t \n\t\tif (sio_data->internal & BIT(3))\n\t\t\tdata->in_scaled |= BIT(9);\t \n\t} else if (sio_data->type == it8781 || sio_data->type == it8782 ||\n\t\t   sio_data->type == it8783) {\n\t\tif (sio_data->internal & BIT(0))\n\t\t\tdata->in_scaled |= BIT(3);\t \n\t\tif (sio_data->internal & BIT(1))\n\t\t\tdata->in_scaled |= BIT(7);\t \n\t}\n\n\tdata->has_temp = 0x07;\n\tif (sio_data->skip_temp & BIT(2)) {\n\t\tif (sio_data->type == it8782 &&\n\t\t    !(it87_read_value(data, IT87_REG_TEMP_EXTRA) & 0x80))\n\t\t\tdata->has_temp &= ~BIT(2);\n\t}\n\n\tdata->in_internal = sio_data->internal;\n\tdata->need_in7_reroute = sio_data->need_in7_reroute;\n\tdata->has_in = 0x3ff & ~sio_data->skip_in;\n\n\tif (has_four_temp(data)) {\n\t\tdata->has_temp |= BIT(3);\n\t} else if (has_six_temp(data)) {\n\t\tu8 reg = it87_read_value(data, IT87_REG_TEMP456_ENABLE);\n\n\t\t \n\t\tif ((reg & 0x03) >= 0x02)\n\t\t\tdata->has_temp |= BIT(3);\n\t\tif (((reg >> 2) & 0x03) >= 0x02)\n\t\t\tdata->has_temp |= BIT(4);\n\t\tif (((reg >> 4) & 0x03) >= 0x02)\n\t\t\tdata->has_temp |= BIT(5);\n\n\t\t \n\t\tif ((reg & 0x03) == 0x01)\n\t\t\tdata->has_in |= BIT(10);\n\t\tif (((reg >> 2) & 0x03) == 0x01)\n\t\t\tdata->has_in |= BIT(11);\n\t\tif (((reg >> 4) & 0x03) == 0x01)\n\t\t\tdata->has_in |= BIT(12);\n\t}\n\n\tdata->has_beep = !!sio_data->beep_pin;\n\n\t \n\tit87_init_device(pdev);\n\n\tsmbus_enable(data);\n\n\tif (!sio_data->skip_vid) {\n\t\tdata->has_vid = true;\n\t\tdata->vrm = vid_which_vrm();\n\t\t \n\t\tdata->vid = sio_data->vid_value;\n\t}\n\n\t \n\tdata->groups[0] = &it87_group;\n\tdata->groups[1] = &it87_group_in;\n\tdata->groups[2] = &it87_group_temp;\n\tdata->groups[3] = &it87_group_fan;\n\n\tif (enable_pwm_interface) {\n\t\tdata->has_pwm = BIT(ARRAY_SIZE(IT87_REG_PWM)) - 1;\n\t\tdata->has_pwm &= ~sio_data->skip_pwm;\n\n\t\tdata->groups[4] = &it87_group_pwm;\n\t\tif (has_old_autopwm(data) || has_newer_autopwm(data))\n\t\t\tdata->groups[5] = &it87_group_auto_pwm;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev,\n\t\t\t\t\tit87_devices[sio_data->type].name,\n\t\t\t\t\tdata, data->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic void it87_resume_sio(struct platform_device *pdev)\n{\n\tstruct it87_data *data = dev_get_drvdata(&pdev->dev);\n\tint err;\n\tint reg2c;\n\n\tif (!data->need_in7_reroute)\n\t\treturn;\n\n\terr = superio_enter(data->sioaddr);\n\tif (err) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Unable to enter Super I/O to reroute in7 (%d)\",\n\t\t\t err);\n\t\treturn;\n\t}\n\n\tsuperio_select(data->sioaddr, GPIO);\n\n\treg2c = superio_inb(data->sioaddr, IT87_SIO_PINX2_REG);\n\tif (!(reg2c & BIT(1))) {\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"Routing internal VCCH5V to in7 again\");\n\n\t\treg2c |= BIT(1);\n\t\tsuperio_outb(data->sioaddr, IT87_SIO_PINX2_REG,\n\t\t\t     reg2c);\n\t}\n\n\tsuperio_exit(data->sioaddr, has_conf_noexit(data));\n}\n\nstatic int it87_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct it87_data *data = dev_get_drvdata(dev);\n\n\tit87_resume_sio(pdev);\n\n\tit87_lock(data);\n\n\tit87_check_pwm(dev);\n\tit87_check_limit_regs(data);\n\tit87_check_voltage_monitors_reset(data);\n\tit87_check_tachometers_reset(pdev);\n\tit87_check_tachometers_16bit_mode(pdev);\n\n\tit87_start_monitoring(data);\n\n\t \n\tdata->valid = false;\n\n\tit87_unlock(data);\n\n\tit87_update_device(dev);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(it87_dev_pm_ops, NULL, it87_resume);\n\nstatic struct platform_driver it87_driver = {\n\t.driver = {\n\t\t.name\t= DRVNAME,\n\t\t.pm     = pm_sleep_ptr(&it87_dev_pm_ops),\n\t},\n\t.probe\t= it87_probe,\n};\n\nstatic int __init it87_device_add(int index, unsigned short address,\n\t\t\t\t  const struct it87_sio_data *sio_data)\n{\n\tstruct platform_device *pdev;\n\tstruct resource res = {\n\t\t.start\t= address + IT87_EC_OFFSET,\n\t\t.end\t= address + IT87_EC_OFFSET + IT87_EC_EXTENT - 1,\n\t\t.name\t= DRVNAME,\n\t\t.flags\t= IORESOURCE_IO,\n\t};\n\tint err;\n\n\terr = acpi_check_resource_conflict(&res);\n\tif (err) {\n\t\tif (!ignore_resource_conflict)\n\t\t\treturn err;\n\t}\n\n\tpdev = platform_device_alloc(DRVNAME, address);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\terr = platform_device_add_resources(pdev, &res, 1);\n\tif (err) {\n\t\tpr_err(\"Device resource addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add_data(pdev, sio_data,\n\t\t\t\t       sizeof(struct it87_sio_data));\n\tif (err) {\n\t\tpr_err(\"Platform data allocation failed\\n\");\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n\t\tpr_err(\"Device addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\tit87_pdev[index] = pdev;\n\treturn 0;\n\nexit_device_put:\n\tplatform_device_put(pdev);\n\treturn err;\n}\n\n \nstatic int it87_dmi_cb(const struct dmi_system_id *dmi_entry)\n{\n\tdmi_data = dmi_entry->driver_data;\n\n\tif (dmi_data && dmi_data->skip_pwm)\n\t\tpr_info(\"Disabling pwm2 due to hardware constraints\\n\");\n\n\treturn 1;\n}\n\n \nstatic int it87_sio_force(const struct dmi_system_id *dmi_entry)\n{\n\t__superio_enter(REG_4E);\n\n\treturn it87_dmi_cb(dmi_entry);\n};\n\n \nstatic struct it87_dmi_data nvidia_fn68pt = {\n\t.skip_pwm = BIT(1),\n};\n\n#define IT87_DMI_MATCH_VND(vendor, name, cb, data) \\\n\t{ \\\n\t\t.callback = cb, \\\n\t\t.matches = { \\\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, vendor), \\\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, name), \\\n\t\t}, \\\n\t\t.driver_data = data, \\\n\t}\n\n#define IT87_DMI_MATCH_GBT(name, cb, data) \\\n\tIT87_DMI_MATCH_VND(\"Gigabyte Technology Co., Ltd.\", name, cb, data)\n\nstatic const struct dmi_system_id it87_dmi_table[] __initconst = {\n\tIT87_DMI_MATCH_GBT(\"AB350\", it87_sio_force, NULL),\n\t\t \n\tIT87_DMI_MATCH_GBT(\"AX370\", it87_sio_force, NULL),\n\t\t \n\tIT87_DMI_MATCH_GBT(\"Z97X-Gaming G1\", it87_sio_force, NULL),\n\t\t \n\tIT87_DMI_MATCH_GBT(\"TRX40 AORUS XTREME\", it87_sio_force, NULL),\n\t\t \n\tIT87_DMI_MATCH_GBT(\"Z390 AORUS ULTRA-CF\", it87_sio_force, NULL),\n\t\t \n\tIT87_DMI_MATCH_GBT(\"B550 AORUS PRO AC\", it87_sio_force, NULL),\n\t\t \n\tIT87_DMI_MATCH_GBT(\"X570 AORUS MASTER\", it87_sio_force, NULL),\n\t\t \n\tIT87_DMI_MATCH_GBT(\"X570 AORUS PRO\", it87_sio_force, NULL),\n\t\t \n\tIT87_DMI_MATCH_GBT(\"X570 AORUS PRO WIFI\", it87_sio_force, NULL),\n\t\t \n\tIT87_DMI_MATCH_GBT(\"X570S AERO G\", it87_sio_force, NULL),\n\t\t \n\tIT87_DMI_MATCH_GBT(\"Z690 AORUS PRO DDR4\", it87_sio_force, NULL),\n\t\t \n\tIT87_DMI_MATCH_GBT(\"Z690 AORUS PRO\", it87_sio_force, NULL),\n\t\t \n\tIT87_DMI_MATCH_VND(\"nVIDIA\", \"FN68PT\", it87_dmi_cb, &nvidia_fn68pt),\n\t{ }\n\n};\nMODULE_DEVICE_TABLE(dmi, it87_dmi_table);\n\nstatic int __init sm_it87_init(void)\n{\n\tint sioaddr[2] = { REG_2E, REG_4E };\n\tstruct it87_sio_data sio_data;\n\tunsigned short isa_address[2];\n\tbool found = false;\n\tint i, err;\n\n\terr = platform_driver_register(&it87_driver);\n\tif (err)\n\t\treturn err;\n\n\tdmi_check_system(it87_dmi_table);\n\n\tfor (i = 0; i < ARRAY_SIZE(sioaddr); i++) {\n\t\tmemset(&sio_data, 0, sizeof(struct it87_sio_data));\n\t\tisa_address[i] = 0;\n\t\terr = it87_find(sioaddr[i], &isa_address[i], &sio_data, i);\n\t\tif (err || isa_address[i] == 0)\n\t\t\tcontinue;\n\t\t \n\t\tif (i && isa_address[i] == isa_address[0])\n\t\t\tbreak;\n\n\t\terr = it87_device_add(i, isa_address[i], &sio_data);\n\t\tif (err)\n\t\t\tgoto exit_dev_unregister;\n\n\t\tfound = true;\n\n\t\t \n\t\tif (sio_data.type == it87)\n\t\t\tbreak;\n\t}\n\n\tif (!found) {\n\t\terr = -ENODEV;\n\t\tgoto exit_unregister;\n\t}\n\treturn 0;\n\nexit_dev_unregister:\n\t \n\tplatform_device_unregister(it87_pdev[0]);\nexit_unregister:\n\tplatform_driver_unregister(&it87_driver);\n\treturn err;\n}\n\nstatic void __exit sm_it87_exit(void)\n{\n\t \n\tplatform_device_unregister(it87_pdev[1]);\n\tplatform_device_unregister(it87_pdev[0]);\n\tplatform_driver_unregister(&it87_driver);\n}\n\nMODULE_AUTHOR(\"Chris Gauthron, Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"IT8705F/IT871xF/IT872xF hardware monitoring driver\");\n\nmodule_param_array(force_id, ushort, &force_id_cnt, 0);\nMODULE_PARM_DESC(force_id, \"Override one or more detected device ID(s)\");\n\nmodule_param(ignore_resource_conflict, bool, 0);\nMODULE_PARM_DESC(ignore_resource_conflict, \"Ignore ACPI resource conflict\");\n\nmodule_param(update_vbat, bool, 0);\nMODULE_PARM_DESC(update_vbat, \"Update vbat if set else return powerup value\");\n\nmodule_param(fix_pwm_polarity, bool, 0);\nMODULE_PARM_DESC(fix_pwm_polarity,\n\t\t \"Force PWM polarity to active high (DANGEROUS)\");\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(sm_it87_init);\nmodule_exit(sm_it87_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}