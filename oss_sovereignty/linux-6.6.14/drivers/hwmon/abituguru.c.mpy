{
  "module_name": "abituguru.c",
  "hash_id": "b37ef67076c016851babf8781058f105e6a1922ff4f13e27206d4d56f57bc510",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/abituguru.c",
  "human_readable_source": "\n \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/dmi.h>\n#include <linux/io.h>\n\n \n#define ABIT_UGURU_ALARM_BANK\t\t\t0x20  \n#define ABIT_UGURU_SENSOR_BANK1\t\t\t0x21  \n#define ABIT_UGURU_FAN_PWM\t\t\t0x24  \n#define ABIT_UGURU_SENSOR_BANK2\t\t\t0x26  \n \n#define ABIT_UGURU_MAX_BANK1_SENSORS\t\t16\n \n \n#define ABIT_UGURU_MAX_BANK2_SENSORS\t\t6\n \n#define ABIT_UGURU_MAX_PWMS\t\t\t5\n \t\t\t      \n#define ABIT_UGURU_TEMP_HIGH_ALARM_ENABLE\t0x01  \n#define ABIT_UGURU_VOLT_HIGH_ALARM_ENABLE\t0x02  \n#define ABIT_UGURU_VOLT_LOW_ALARM_ENABLE\t0x04  \n#define ABIT_UGURU_TEMP_HIGH_ALARM_FLAG\t\t0x10  \n#define ABIT_UGURU_VOLT_HIGH_ALARM_FLAG\t\t0x20  \n#define ABIT_UGURU_VOLT_LOW_ALARM_FLAG\t\t0x40  \n \t\t\t      \n#define ABIT_UGURU_FAN_LOW_ALARM_ENABLE\t\t0x01  \n \n#define ABIT_UGURU_BEEP_ENABLE\t\t\t0x08  \n#define ABIT_UGURU_SHUTDOWN_ENABLE\t\t0x80  \n \n#define ABIT_UGURU_FAN_PWM_ENABLE\t\t0x80  \n \n#define ABIT_UGURU_FAN_MAX\t\t\t15300  \n \n#define ABIT_UGURU_IN_SENSOR\t\t\t0\n#define ABIT_UGURU_TEMP_SENSOR\t\t\t1\n#define ABIT_UGURU_NC\t\t\t\t2\n \n#define ABIT_UGURU_WAIT_TIMEOUT\t\t\t125\n \n#define ABIT_UGURU_WAIT_TIMEOUT_SLEEP\t\t5\n \n#define ABIT_UGURU_READY_TIMEOUT\t\t5\n \n#define ABIT_UGURU_MAX_RETRIES\t\t\t3\n#define ABIT_UGURU_RETRY_DELAY\t\t\t(HZ/5)\n \n#define ABIT_UGURU_MAX_TIMEOUTS\t\t\t2\n \n#define ABIT_UGURU_NAME\t\t\t\t\"abituguru\"\n#define ABIT_UGURU_DEBUG(level, format, arg...)\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (level <= verbose)\t\t\t\\\n\t\t\tpr_debug(format , ## arg);\t\\\n\t} while (0)\n\n \n \n#define ABITUGURU_IN_NAMES_LENGTH\t(11 + 2 * 9 + 2 * 15 + 2 * 22 + 10 + 14)\n \n#define ABITUGURU_TEMP_NAMES_LENGTH\t(13 + 11 + 12 + 13 + 20 + 12 + 16)\n \n#define ABITUGURU_FAN_NAMES_LENGTH\t(11 + 9 + 11 + 18 + 10 + 14)\n \n#define ABITUGURU_PWM_NAMES_LENGTH\t(12 + 24 + 2 * 21 + 2 * 22)\n \n#define ABITUGURU_SYSFS_NAMES_LENGTH\t( \\\n\tABIT_UGURU_MAX_BANK1_SENSORS * ABITUGURU_IN_NAMES_LENGTH + \\\n\tABIT_UGURU_MAX_BANK2_SENSORS * ABITUGURU_FAN_NAMES_LENGTH + \\\n\tABIT_UGURU_MAX_PWMS * ABITUGURU_PWM_NAMES_LENGTH)\n\n \n \n#define ABIT_UGURU_BASE\t\t\t\t0x00E0\n \n#define ABIT_UGURU_CMD\t\t\t\t0x00\n \n#define ABIT_UGURU_DATA\t\t\t\t0x04\n#define ABIT_UGURU_REGION_LENGTH\t\t5\n \n#define ABIT_UGURU_STATUS_WRITE\t\t\t0x00  \n#define ABIT_UGURU_STATUS_READ\t\t\t0x01  \n#define ABIT_UGURU_STATUS_INPUT\t\t\t0x08  \n#define ABIT_UGURU_STATUS_READY\t\t\t0x09  \n\n \n \nstatic const int abituguru_bank1_max_value[2] = { 3494, 255000 };\n \nstatic const u8 abituguru_bank2_min_threshold = 5;\nstatic const u8 abituguru_bank2_max_threshold = 50;\n \nstatic const int abituguru_pwm_settings_multiplier[5] = { 0, 1, 1, 1000, 1000 };\n \nstatic const u8 abituguru_pwm_min[5] = { 0, 170, 170, 25, 25 };\nstatic const u8 abituguru_pwm_max[5] = { 0, 255, 255, 75, 75 };\n\n\n \nstatic bool force;\nmodule_param(force, bool, 0);\nMODULE_PARM_DESC(force, \"Set to one to force detection.\");\nstatic int bank1_types[ABIT_UGURU_MAX_BANK1_SENSORS] = { -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };\nmodule_param_array(bank1_types, int, NULL, 0);\nMODULE_PARM_DESC(bank1_types, \"Bank1 sensortype autodetection override:\\n\"\n\t\"   -1 autodetect\\n\"\n\t\"    0 volt sensor\\n\"\n\t\"    1 temp sensor\\n\"\n\t\"    2 not connected\");\nstatic int fan_sensors;\nmodule_param(fan_sensors, int, 0);\nMODULE_PARM_DESC(fan_sensors, \"Number of fan sensors on the uGuru \"\n\t\"(0 = autodetect)\");\nstatic int pwms;\nmodule_param(pwms, int, 0);\nMODULE_PARM_DESC(pwms, \"Number of PWMs on the uGuru \"\n\t\"(0 = autodetect)\");\n\n \nstatic int verbose = 2;\nmodule_param(verbose, int, 0644);\nMODULE_PARM_DESC(verbose, \"How verbose should the driver be? (0-3):\\n\"\n\t\"   0 normal output\\n\"\n\t\"   1 + verbose error reporting\\n\"\n\t\"   2 + sensors type probing info\\n\"\n\t\"   3 + retryable error reporting\");\n\n\n \nstruct abituguru_data {\n\tstruct device *hwmon_dev;\t \n\tstruct mutex update_lock;\t \n\tunsigned long last_updated;\t \n\tunsigned short addr;\t\t \n\tchar uguru_ready;\t\t \n\tunsigned char update_timeouts;\t \n\n\t \n\tstruct sensor_device_attribute_2 sysfs_attr[\n\t\tABIT_UGURU_MAX_BANK1_SENSORS * 9 +\n\t\tABIT_UGURU_MAX_BANK2_SENSORS * 6 + ABIT_UGURU_MAX_PWMS * 6];\n\t \n\tchar sysfs_names[ABITUGURU_SYSFS_NAMES_LENGTH];\n\n\t \n\t \n\tu8 bank1_sensors[2];\n\tu8 bank1_address[2][ABIT_UGURU_MAX_BANK1_SENSORS];\n\tu8 bank1_value[ABIT_UGURU_MAX_BANK1_SENSORS];\n\t \n\tu8 bank1_settings[ABIT_UGURU_MAX_BANK1_SENSORS][3];\n\t \n\tint bank1_max_value[ABIT_UGURU_MAX_BANK1_SENSORS];\n\n\t \n\tu8 bank2_sensors;  \n\tu8 bank2_value[ABIT_UGURU_MAX_BANK2_SENSORS];\n\tu8 bank2_settings[ABIT_UGURU_MAX_BANK2_SENSORS][2];  \n\n\t \n\tu8 alarms[3];\n\n\t \n\tu8 pwms;  \n\tu8 pwm_settings[ABIT_UGURU_MAX_PWMS][5];\n};\n\nstatic const char *never_happen = \"This should never happen.\";\nstatic const char *report_this =\n\t\"Please report this to the abituguru maintainer (see MAINTAINERS)\";\n\n \nstatic int abituguru_wait(struct abituguru_data *data, u8 state)\n{\n\tint timeout = ABIT_UGURU_WAIT_TIMEOUT;\n\n\twhile (inb_p(data->addr + ABIT_UGURU_DATA) != state) {\n\t\ttimeout--;\n\t\tif (timeout == 0)\n\t\t\treturn -EBUSY;\n\t\t \n\t\tif (timeout <= ABIT_UGURU_WAIT_TIMEOUT_SLEEP)\n\t\t\tmsleep(0);\n\t}\n\treturn 0;\n}\n\n \nstatic int abituguru_ready(struct abituguru_data *data)\n{\n\tint timeout = ABIT_UGURU_READY_TIMEOUT;\n\n\tif (data->uguru_ready)\n\t\treturn 0;\n\n\t \n\toutb(0x00, data->addr + ABIT_UGURU_DATA);\n\n\t \n\tif (abituguru_wait(data, ABIT_UGURU_STATUS_READY)) {\n\t\tABIT_UGURU_DEBUG(1,\n\t\t\t\"timeout exceeded waiting for ready state\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\twhile (inb_p(data->addr + ABIT_UGURU_CMD) != 0xAC) {\n\t\ttimeout--;\n\t\tif (timeout == 0) {\n\t\t\tABIT_UGURU_DEBUG(1,\n\t\t\t   \"CMD reg does not hold 0xAC after ready command\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tmsleep(0);\n\t}\n\n\t \n\ttimeout = ABIT_UGURU_READY_TIMEOUT;\n\twhile (inb_p(data->addr + ABIT_UGURU_DATA) != ABIT_UGURU_STATUS_INPUT) {\n\t\ttimeout--;\n\t\tif (timeout == 0) {\n\t\t\tABIT_UGURU_DEBUG(1,\n\t\t\t\t\"state != more input after ready command\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tmsleep(0);\n\t}\n\n\tdata->uguru_ready = 1;\n\treturn 0;\n}\n\n \nstatic int abituguru_send_address(struct abituguru_data *data,\n\tu8 bank_addr, u8 sensor_addr, int retries)\n{\n\t \n\tint report_errors = retries;\n\n\tfor (;;) {\n\t\t \n\t\tif (abituguru_ready(data) != 0)\n\t\t\treturn -EIO;\n\t\toutb(bank_addr, data->addr + ABIT_UGURU_DATA);\n\t\tdata->uguru_ready = 0;\n\n\t\t \n\t\tif (abituguru_wait(data, ABIT_UGURU_STATUS_INPUT)) {\n\t\t\tif (retries) {\n\t\t\t\tABIT_UGURU_DEBUG(3, \"timeout exceeded \"\n\t\t\t\t\t\"waiting for more input state, %d \"\n\t\t\t\t\t\"tries remaining\\n\", retries);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tschedule_timeout(ABIT_UGURU_RETRY_DELAY);\n\t\t\t\tretries--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (report_errors)\n\t\t\t\tABIT_UGURU_DEBUG(1, \"timeout exceeded \"\n\t\t\t\t\t\"waiting for more input state \"\n\t\t\t\t\t\"(bank: %d)\\n\", (int)bank_addr);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\toutb(sensor_addr, data->addr + ABIT_UGURU_CMD);\n\t\treturn 0;\n\t}\n}\n\n \nstatic int abituguru_read(struct abituguru_data *data,\n\tu8 bank_addr, u8 sensor_addr, u8 *buf, int count, int retries)\n{\n\tint i;\n\n\t \n\ti = abituguru_send_address(data, bank_addr, sensor_addr, retries);\n\tif (i)\n\t\treturn i;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tif (abituguru_wait(data, ABIT_UGURU_STATUS_READ)) {\n\t\t\tABIT_UGURU_DEBUG(retries ? 1 : 3,\n\t\t\t\t\"timeout exceeded waiting for \"\n\t\t\t\t\"read state (bank: %d, sensor: %d)\\n\",\n\t\t\t\t(int)bank_addr, (int)sensor_addr);\n\t\t\tbreak;\n\t\t}\n\t\tbuf[i] = inb(data->addr + ABIT_UGURU_CMD);\n\t}\n\n\t \n\tabituguru_ready(data);\n\n\treturn i;\n}\n\n \nstatic int abituguru_write(struct abituguru_data *data,\n\tu8 bank_addr, u8 sensor_addr, u8 *buf, int count)\n{\n\t \n\tint i, timeout = ABIT_UGURU_READY_TIMEOUT;\n\n\t \n\ti = abituguru_send_address(data, bank_addr, sensor_addr,\n\t\tABIT_UGURU_MAX_RETRIES);\n\tif (i)\n\t\treturn i;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tif (abituguru_wait(data, ABIT_UGURU_STATUS_WRITE)) {\n\t\t\tABIT_UGURU_DEBUG(1, \"timeout exceeded waiting for \"\n\t\t\t\t\"write state (bank: %d, sensor: %d)\\n\",\n\t\t\t\t(int)bank_addr, (int)sensor_addr);\n\t\t\tbreak;\n\t\t}\n\t\toutb(buf[i], data->addr + ABIT_UGURU_CMD);\n\t}\n\n\t \n\tif (abituguru_wait(data, ABIT_UGURU_STATUS_READ)) {\n\t\tABIT_UGURU_DEBUG(1, \"timeout exceeded waiting for read state \"\n\t\t\t\"after write (bank: %d, sensor: %d)\\n\", (int)bank_addr,\n\t\t\t(int)sensor_addr);\n\t\treturn -EIO;\n\t}\n\n\t \n\twhile (inb_p(data->addr + ABIT_UGURU_CMD) != 0xAC) {\n\t\ttimeout--;\n\t\tif (timeout == 0) {\n\t\t\tABIT_UGURU_DEBUG(1, \"CMD reg does not hold 0xAC after \"\n\t\t\t\t\"write (bank: %d, sensor: %d)\\n\",\n\t\t\t\t(int)bank_addr, (int)sensor_addr);\n\t\t\treturn -EIO;\n\t\t}\n\t\tmsleep(0);\n\t}\n\n\t \n\tabituguru_ready(data);\n\n\treturn i;\n}\n\n \nstatic int\nabituguru_detect_bank1_sensor_type(struct abituguru_data *data,\n\t\t\t\t   u8 sensor_addr)\n{\n\tu8 val, test_flag, buf[3];\n\tint i, ret = -ENODEV;  \n\n\t \n\tif (bank1_types[sensor_addr] >= ABIT_UGURU_IN_SENSOR &&\n\t\t\tbank1_types[sensor_addr] <= ABIT_UGURU_NC) {\n\t\tABIT_UGURU_DEBUG(2, \"assuming sensor type %d for bank1 sensor \"\n\t\t\t\"%d because of \\\"bank1_types\\\" module param\\n\",\n\t\t\tbank1_types[sensor_addr], (int)sensor_addr);\n\t\treturn bank1_types[sensor_addr];\n\t}\n\n\t \n\tif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK1, sensor_addr, &val,\n\t\t\t1, ABIT_UGURU_MAX_RETRIES) != 1)\n\t\treturn -ENODEV;\n\n\t \n\tif ((val < 10u) || (val > 250u)) {\n\t\tpr_warn(\"bank1-sensor: %d reading (%d) too close to limits, \"\n\t\t\t\"unable to determine sensor type, skipping sensor\\n\",\n\t\t\t(int)sensor_addr, (int)val);\n\t\t \n\t\treturn ABIT_UGURU_NC;\n\t}\n\n\tABIT_UGURU_DEBUG(2, \"testing bank1 sensor %d\\n\", (int)sensor_addr);\n\t \n\tif (val <= 240u) {\n\t\tbuf[0] = ABIT_UGURU_VOLT_LOW_ALARM_ENABLE;\n\t\tbuf[1] = 245;\n\t\tbuf[2] = 250;\n\t\ttest_flag = ABIT_UGURU_VOLT_LOW_ALARM_FLAG;\n\t} else {\n\t\tbuf[0] = ABIT_UGURU_VOLT_HIGH_ALARM_ENABLE;\n\t\tbuf[1] = 5;\n\t\tbuf[2] = 10;\n\t\ttest_flag = ABIT_UGURU_VOLT_HIGH_ALARM_FLAG;\n\t}\n\n\tif (abituguru_write(data, ABIT_UGURU_SENSOR_BANK1 + 2, sensor_addr,\n\t\t\tbuf, 3) != 3)\n\t\tgoto abituguru_detect_bank1_sensor_type_exit;\n\t \n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tschedule_timeout(HZ/50);\n\t \n\tif (abituguru_read(data, ABIT_UGURU_ALARM_BANK, 0, buf, 3,\n\t\t\tABIT_UGURU_MAX_RETRIES) != 3)\n\t\tgoto abituguru_detect_bank1_sensor_type_exit;\n\tif (buf[sensor_addr/8] & (0x01 << (sensor_addr % 8))) {\n\t\tif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK1 + 1,\n\t\t\t\tsensor_addr, buf, 3,\n\t\t\t\tABIT_UGURU_MAX_RETRIES) != 3)\n\t\t\tgoto abituguru_detect_bank1_sensor_type_exit;\n\t\tif (buf[0] & test_flag) {\n\t\t\tABIT_UGURU_DEBUG(2, \"  found volt sensor\\n\");\n\t\t\tret = ABIT_UGURU_IN_SENSOR;\n\t\t\tgoto abituguru_detect_bank1_sensor_type_exit;\n\t\t} else\n\t\t\tABIT_UGURU_DEBUG(2, \"  alarm raised during volt \"\n\t\t\t\t\"sensor test, but volt range flag not set\\n\");\n\t} else\n\t\tABIT_UGURU_DEBUG(2, \"  alarm not raised during volt sensor \"\n\t\t\t\"test\\n\");\n\n\t \n\tbuf[0] = ABIT_UGURU_TEMP_HIGH_ALARM_ENABLE;\n\tbuf[1] = 5;\n\tbuf[2] = 10;\n\tif (abituguru_write(data, ABIT_UGURU_SENSOR_BANK1 + 2, sensor_addr,\n\t\t\tbuf, 3) != 3)\n\t\tgoto abituguru_detect_bank1_sensor_type_exit;\n\t \n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tschedule_timeout(HZ/20);\n\t \n\tif (abituguru_read(data, ABIT_UGURU_ALARM_BANK, 0, buf, 3,\n\t\t\tABIT_UGURU_MAX_RETRIES) != 3)\n\t\tgoto abituguru_detect_bank1_sensor_type_exit;\n\tif (buf[sensor_addr/8] & (0x01 << (sensor_addr % 8))) {\n\t\tif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK1 + 1,\n\t\t\t\tsensor_addr, buf, 3,\n\t\t\t\tABIT_UGURU_MAX_RETRIES) != 3)\n\t\t\tgoto abituguru_detect_bank1_sensor_type_exit;\n\t\tif (buf[0] & ABIT_UGURU_TEMP_HIGH_ALARM_FLAG) {\n\t\t\tABIT_UGURU_DEBUG(2, \"  found temp sensor\\n\");\n\t\t\tret = ABIT_UGURU_TEMP_SENSOR;\n\t\t\tgoto abituguru_detect_bank1_sensor_type_exit;\n\t\t} else\n\t\t\tABIT_UGURU_DEBUG(2, \"  alarm raised during temp \"\n\t\t\t\t\"sensor test, but temp high flag not set\\n\");\n\t} else\n\t\tABIT_UGURU_DEBUG(2, \"  alarm not raised during temp sensor \"\n\t\t\t\"test\\n\");\n\n\tret = ABIT_UGURU_NC;\nabituguru_detect_bank1_sensor_type_exit:\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tif (abituguru_write(data, ABIT_UGURU_SENSOR_BANK1 + 2,\n\t\t\t\tsensor_addr, data->bank1_settings[sensor_addr],\n\t\t\t\t3) == 3)\n\t\t\tbreak;\n\tif (i == 3) {\n\t\tpr_err(\"Fatal error could not restore original settings. %s %s\\n\",\n\t\t       never_happen, report_this);\n\t\treturn -ENODEV;\n\t}\n\treturn ret;\n}\n\n \nstatic void\nabituguru_detect_no_bank2_sensors(struct abituguru_data *data)\n{\n\tint i;\n\n\tif (fan_sensors > 0 && fan_sensors <= ABIT_UGURU_MAX_BANK2_SENSORS) {\n\t\tdata->bank2_sensors = fan_sensors;\n\t\tABIT_UGURU_DEBUG(2, \"assuming %d fan sensors because of \"\n\t\t\t\"\\\"fan_sensors\\\" module param\\n\",\n\t\t\t(int)data->bank2_sensors);\n\t\treturn;\n\t}\n\n\tABIT_UGURU_DEBUG(2, \"detecting number of fan sensors\\n\");\n\tfor (i = 0; i < ABIT_UGURU_MAX_BANK2_SENSORS; i++) {\n\t\t \n\t\tif (data->bank2_settings[i][0] & ~0xC9) {\n\t\t\tABIT_UGURU_DEBUG(2, \"  bank2 sensor %d does not seem \"\n\t\t\t\t\"to be a fan sensor: settings[0] = %02X\\n\",\n\t\t\t\ti, (unsigned int)data->bank2_settings[i][0]);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (data->bank2_settings[i][1] <\n\t\t\t\tabituguru_bank2_min_threshold) {\n\t\t\tABIT_UGURU_DEBUG(2, \"  bank2 sensor %d does not seem \"\n\t\t\t\t\"to be a fan sensor: the threshold (%d) is \"\n\t\t\t\t\"below the minimum (%d)\\n\", i,\n\t\t\t\t(int)data->bank2_settings[i][1],\n\t\t\t\t(int)abituguru_bank2_min_threshold);\n\t\t\tbreak;\n\t\t}\n\t\tif (data->bank2_settings[i][1] >\n\t\t\t\tabituguru_bank2_max_threshold) {\n\t\t\tABIT_UGURU_DEBUG(2, \"  bank2 sensor %d does not seem \"\n\t\t\t\t\"to be a fan sensor: the threshold (%d) is \"\n\t\t\t\t\"above the maximum (%d)\\n\", i,\n\t\t\t\t(int)data->bank2_settings[i][1],\n\t\t\t\t(int)abituguru_bank2_max_threshold);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdata->bank2_sensors = i;\n\tABIT_UGURU_DEBUG(2, \" found: %d fan sensors\\n\",\n\t\t(int)data->bank2_sensors);\n}\n\nstatic void\nabituguru_detect_no_pwms(struct abituguru_data *data)\n{\n\tint i, j;\n\n\tif (pwms > 0 && pwms <= ABIT_UGURU_MAX_PWMS) {\n\t\tdata->pwms = pwms;\n\t\tABIT_UGURU_DEBUG(2, \"assuming %d PWM outputs because of \"\n\t\t\t\"\\\"pwms\\\" module param\\n\", (int)data->pwms);\n\t\treturn;\n\t}\n\n\tABIT_UGURU_DEBUG(2, \"detecting number of PWM outputs\\n\");\n\tfor (i = 0; i < ABIT_UGURU_MAX_PWMS; i++) {\n\t\t \n\t\tif (data->pwm_settings[i][0] & ~0x8F) {\n\t\t\tABIT_UGURU_DEBUG(2, \"  pwm channel %d does not seem \"\n\t\t\t\t\"to be a pwm channel: settings[0] = %02X\\n\",\n\t\t\t\ti, (unsigned int)data->pwm_settings[i][0]);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < data->bank1_sensors[ABIT_UGURU_TEMP_SENSOR];\n\t\t\t\tj++) {\n\t\t\tif (data->bank1_address[ABIT_UGURU_TEMP_SENSOR][j] ==\n\t\t\t\t\t(data->pwm_settings[i][0] & 0x0F))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == data->bank1_sensors[ABIT_UGURU_TEMP_SENSOR]) {\n\t\t\tABIT_UGURU_DEBUG(2, \"  pwm channel %d does not seem \"\n\t\t\t\t\"to be a pwm channel: %d is not a valid temp \"\n\t\t\t\t\"sensor address\\n\", i,\n\t\t\t\tdata->pwm_settings[i][0] & 0x0F);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (j = 1; j < 5; j++) {\n\t\t\tu8 min;\n\t\t\t \n\t\t\tif ((i == 0) && ((j == 1) || (j == 2)))\n\t\t\t\tmin = 77;\n\t\t\telse\n\t\t\t\tmin = abituguru_pwm_min[j];\n\t\t\tif (data->pwm_settings[i][j] < min) {\n\t\t\t\tABIT_UGURU_DEBUG(2, \"  pwm channel %d does \"\n\t\t\t\t\t\"not seem to be a pwm channel: \"\n\t\t\t\t\t\"setting %d (%d) is below the minimum \"\n\t\t\t\t\t\"value (%d)\\n\", i, j,\n\t\t\t\t\t(int)data->pwm_settings[i][j],\n\t\t\t\t\t(int)min);\n\t\t\t\tgoto abituguru_detect_no_pwms_exit;\n\t\t\t}\n\t\t\tif (data->pwm_settings[i][j] > abituguru_pwm_max[j]) {\n\t\t\t\tABIT_UGURU_DEBUG(2, \"  pwm channel %d does \"\n\t\t\t\t\t\"not seem to be a pwm channel: \"\n\t\t\t\t\t\"setting %d (%d) is above the maximum \"\n\t\t\t\t\t\"value (%d)\\n\", i, j,\n\t\t\t\t\t(int)data->pwm_settings[i][j],\n\t\t\t\t\t(int)abituguru_pwm_max[j]);\n\t\t\t\tgoto abituguru_detect_no_pwms_exit;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (data->pwm_settings[i][1] >= data->pwm_settings[i][2]) {\n\t\t\tABIT_UGURU_DEBUG(2, \"  pwm channel %d does not seem \"\n\t\t\t\t\"to be a pwm channel: min pwm (%d) >= \"\n\t\t\t\t\"max pwm (%d)\\n\", i,\n\t\t\t\t(int)data->pwm_settings[i][1],\n\t\t\t\t(int)data->pwm_settings[i][2]);\n\t\t\tbreak;\n\t\t}\n\t\tif (data->pwm_settings[i][3] >= data->pwm_settings[i][4]) {\n\t\t\tABIT_UGURU_DEBUG(2, \"  pwm channel %d does not seem \"\n\t\t\t\t\"to be a pwm channel: min temp (%d) >= \"\n\t\t\t\t\"max temp (%d)\\n\", i,\n\t\t\t\t(int)data->pwm_settings[i][3],\n\t\t\t\t(int)data->pwm_settings[i][4]);\n\t\t\tbreak;\n\t\t}\n\t}\n\nabituguru_detect_no_pwms_exit:\n\tdata->pwms = i;\n\tABIT_UGURU_DEBUG(2, \" found: %d PWM outputs\\n\", (int)data->pwms);\n}\n\n \nstatic struct abituguru_data *abituguru_update_device(struct device *dev);\n\nstatic ssize_t show_bank1_value(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = abituguru_update_device(dev);\n\tif (!data)\n\t\treturn -EIO;\n\treturn sprintf(buf, \"%d\\n\", (data->bank1_value[attr->index] *\n\t\tdata->bank1_max_value[attr->index] + 128) / 255);\n}\n\nstatic ssize_t show_bank1_setting(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t(data->bank1_settings[attr->index][attr->nr] *\n\t\tdata->bank1_max_value[attr->index] + 128) / 255);\n}\n\nstatic ssize_t show_bank2_value(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = abituguru_update_device(dev);\n\tif (!data)\n\t\treturn -EIO;\n\treturn sprintf(buf, \"%d\\n\", (data->bank2_value[attr->index] *\n\t\tABIT_UGURU_FAN_MAX + 128) / 255);\n}\n\nstatic ssize_t show_bank2_setting(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t(data->bank2_settings[attr->index][attr->nr] *\n\t\tABIT_UGURU_FAN_MAX + 128) / 255);\n}\n\nstatic ssize_t store_bank1_setting(struct device *dev, struct device_attribute\n\t*devattr, const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = count;\n\tval = (val * 255 + data->bank1_max_value[attr->index] / 2) /\n\t\tdata->bank1_max_value[attr->index];\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tif (data->bank1_settings[attr->index][attr->nr] != val) {\n\t\tu8 orig_val = data->bank1_settings[attr->index][attr->nr];\n\t\tdata->bank1_settings[attr->index][attr->nr] = val;\n\t\tif (abituguru_write(data, ABIT_UGURU_SENSOR_BANK1 + 2,\n\t\t\t\tattr->index, data->bank1_settings[attr->index],\n\t\t\t\t3) <= attr->nr) {\n\t\t\tdata->bank1_settings[attr->index][attr->nr] = orig_val;\n\t\t\tret = -EIO;\n\t\t}\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t store_bank2_setting(struct device *dev, struct device_attribute\n\t*devattr, const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = count;\n\tval = (val * 255 + ABIT_UGURU_FAN_MAX / 2) / ABIT_UGURU_FAN_MAX;\n\n\t \n\tif (val < abituguru_bank2_min_threshold ||\n\t\t\tval > abituguru_bank2_max_threshold)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tif (data->bank2_settings[attr->index][attr->nr] != val) {\n\t\tu8 orig_val = data->bank2_settings[attr->index][attr->nr];\n\t\tdata->bank2_settings[attr->index][attr->nr] = val;\n\t\tif (abituguru_write(data, ABIT_UGURU_SENSOR_BANK2 + 2,\n\t\t\t\tattr->index, data->bank2_settings[attr->index],\n\t\t\t\t2) <= attr->nr) {\n\t\t\tdata->bank2_settings[attr->index][attr->nr] = orig_val;\n\t\t\tret = -EIO;\n\t\t}\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t show_bank1_alarm(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = abituguru_update_device(dev);\n\tif (!data)\n\t\treturn -EIO;\n\t \n\tif ((data->alarms[attr->index / 8] & (0x01 << (attr->index % 8))) &&\n\t\t\t(data->bank1_settings[attr->index][0] & attr->nr))\n\t\treturn sprintf(buf, \"1\\n\");\n\telse\n\t\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t show_bank2_alarm(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = abituguru_update_device(dev);\n\tif (!data)\n\t\treturn -EIO;\n\tif (data->alarms[2] & (0x01 << attr->index))\n\t\treturn sprintf(buf, \"1\\n\");\n\telse\n\t\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t show_bank1_mask(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\tif (data->bank1_settings[attr->index][0] & attr->nr)\n\t\treturn sprintf(buf, \"1\\n\");\n\telse\n\t\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t show_bank2_mask(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\tif (data->bank2_settings[attr->index][0] & attr->nr)\n\t\treturn sprintf(buf, \"1\\n\");\n\telse\n\t\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t store_bank1_mask(struct device *dev,\n\tstruct device_attribute *devattr, const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\tssize_t ret;\n\tu8 orig_val;\n\tunsigned long mask;\n\n\tret = kstrtoul(buf, 10, &mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = count;\n\tmutex_lock(&data->update_lock);\n\torig_val = data->bank1_settings[attr->index][0];\n\n\tif (mask)\n\t\tdata->bank1_settings[attr->index][0] |= attr->nr;\n\telse\n\t\tdata->bank1_settings[attr->index][0] &= ~attr->nr;\n\n\tif ((data->bank1_settings[attr->index][0] != orig_val) &&\n\t\t\t(abituguru_write(data,\n\t\t\tABIT_UGURU_SENSOR_BANK1 + 2, attr->index,\n\t\t\tdata->bank1_settings[attr->index], 3) < 1)) {\n\t\tdata->bank1_settings[attr->index][0] = orig_val;\n\t\tret = -EIO;\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t store_bank2_mask(struct device *dev,\n\tstruct device_attribute *devattr, const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\tssize_t ret;\n\tu8 orig_val;\n\tunsigned long mask;\n\n\tret = kstrtoul(buf, 10, &mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = count;\n\tmutex_lock(&data->update_lock);\n\torig_val = data->bank2_settings[attr->index][0];\n\n\tif (mask)\n\t\tdata->bank2_settings[attr->index][0] |= attr->nr;\n\telse\n\t\tdata->bank2_settings[attr->index][0] &= ~attr->nr;\n\n\tif ((data->bank2_settings[attr->index][0] != orig_val) &&\n\t\t\t(abituguru_write(data,\n\t\t\tABIT_UGURU_SENSOR_BANK2 + 2, attr->index,\n\t\t\tdata->bank2_settings[attr->index], 2) < 1)) {\n\t\tdata->bank2_settings[attr->index][0] = orig_val;\n\t\tret = -EIO;\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\n \nstatic ssize_t show_pwm_setting(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm_settings[attr->index][attr->nr] *\n\t\tabituguru_pwm_settings_multiplier[attr->nr]);\n}\n\nstatic ssize_t store_pwm_setting(struct device *dev, struct device_attribute\n\t*devattr, const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\tu8 min;\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = count;\n\tval = (val + abituguru_pwm_settings_multiplier[attr->nr] / 2) /\n\t\t\t\tabituguru_pwm_settings_multiplier[attr->nr];\n\n\t \n\tif ((attr->index == 0) && ((attr->nr == 1) || (attr->nr == 2)))\n\t\tmin = 77;\n\telse\n\t\tmin = abituguru_pwm_min[attr->nr];\n\n\t \n\tif (val < min || val > abituguru_pwm_max[attr->nr])\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\t \n\tif ((attr->nr & 1) &&\n\t\t\t(val >= data->pwm_settings[attr->index][attr->nr + 1]))\n\t\tret = -EINVAL;\n\telse if (!(attr->nr & 1) &&\n\t\t\t(val <= data->pwm_settings[attr->index][attr->nr - 1]))\n\t\tret = -EINVAL;\n\telse if (data->pwm_settings[attr->index][attr->nr] != val) {\n\t\tu8 orig_val = data->pwm_settings[attr->index][attr->nr];\n\t\tdata->pwm_settings[attr->index][attr->nr] = val;\n\t\tif (abituguru_write(data, ABIT_UGURU_FAN_PWM + 1,\n\t\t\t\tattr->index, data->pwm_settings[attr->index],\n\t\t\t\t5) <= attr->nr) {\n\t\t\tdata->pwm_settings[attr->index][attr->nr] =\n\t\t\t\torig_val;\n\t\t\tret = -EIO;\n\t\t}\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t show_pwm_sensor(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\tint i;\n\t \n\tfor (i = 0; i < data->bank1_sensors[ABIT_UGURU_TEMP_SENSOR]; i++)\n\t\tif (data->bank1_address[ABIT_UGURU_TEMP_SENSOR][i] ==\n\t\t\t\t(data->pwm_settings[attr->index][0] & 0x0F))\n\t\t\treturn sprintf(buf, \"%d\\n\", i+1);\n\n\treturn -ENXIO;\n}\n\nstatic ssize_t store_pwm_sensor(struct device *dev, struct device_attribute\n\t*devattr, const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\tssize_t ret;\n\tunsigned long val;\n\tu8 orig_val;\n\tu8 address;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val == 0 || val > data->bank1_sensors[ABIT_UGURU_TEMP_SENSOR])\n\t\treturn -EINVAL;\n\n\tval -= 1;\n\tret = count;\n\tmutex_lock(&data->update_lock);\n\torig_val = data->pwm_settings[attr->index][0];\n\taddress = data->bank1_address[ABIT_UGURU_TEMP_SENSOR][val];\n\tdata->pwm_settings[attr->index][0] &= 0xF0;\n\tdata->pwm_settings[attr->index][0] |= address;\n\tif (data->pwm_settings[attr->index][0] != orig_val) {\n\t\tif (abituguru_write(data, ABIT_UGURU_FAN_PWM + 1, attr->index,\n\t\t\t\t    data->pwm_settings[attr->index], 5) < 1) {\n\t\t\tdata->pwm_settings[attr->index][0] = orig_val;\n\t\t\tret = -EIO;\n\t\t}\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t show_pwm_enable(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\tint res = 0;\n\tif (data->pwm_settings[attr->index][0] & ABIT_UGURU_FAN_PWM_ENABLE)\n\t\tres = 2;\n\treturn sprintf(buf, \"%d\\n\", res);\n}\n\nstatic ssize_t store_pwm_enable(struct device *dev, struct device_attribute\n\t*devattr, const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\tu8 orig_val;\n\tssize_t ret;\n\tunsigned long user_val;\n\n\tret = kstrtoul(buf, 10, &user_val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = count;\n\tmutex_lock(&data->update_lock);\n\torig_val = data->pwm_settings[attr->index][0];\n\tswitch (user_val) {\n\tcase 0:\n\t\tdata->pwm_settings[attr->index][0] &=\n\t\t\t~ABIT_UGURU_FAN_PWM_ENABLE;\n\t\tbreak;\n\tcase 2:\n\t\tdata->pwm_settings[attr->index][0] |= ABIT_UGURU_FAN_PWM_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif ((data->pwm_settings[attr->index][0] != orig_val) &&\n\t\t\t(abituguru_write(data, ABIT_UGURU_FAN_PWM + 1,\n\t\t\tattr->index, data->pwm_settings[attr->index],\n\t\t\t5) < 1)) {\n\t\tdata->pwm_settings[attr->index][0] = orig_val;\n\t\tret = -EIO;\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t show_name(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", ABIT_UGURU_NAME);\n}\n\n \nstatic const\nstruct sensor_device_attribute_2 abituguru_sysfs_bank1_templ[2][9] = {\n\t{\n\tSENSOR_ATTR_2(in%d_input, 0444, show_bank1_value, NULL, 0, 0),\n\tSENSOR_ATTR_2(in%d_min, 0644, show_bank1_setting,\n\t\tstore_bank1_setting, 1, 0),\n\tSENSOR_ATTR_2(in%d_min_alarm, 0444, show_bank1_alarm, NULL,\n\t\tABIT_UGURU_VOLT_LOW_ALARM_FLAG, 0),\n\tSENSOR_ATTR_2(in%d_max, 0644, show_bank1_setting,\n\t\tstore_bank1_setting, 2, 0),\n\tSENSOR_ATTR_2(in%d_max_alarm, 0444, show_bank1_alarm, NULL,\n\t\tABIT_UGURU_VOLT_HIGH_ALARM_FLAG, 0),\n\tSENSOR_ATTR_2(in%d_beep, 0644, show_bank1_mask,\n\t\tstore_bank1_mask, ABIT_UGURU_BEEP_ENABLE, 0),\n\tSENSOR_ATTR_2(in%d_shutdown, 0644, show_bank1_mask,\n\t\tstore_bank1_mask, ABIT_UGURU_SHUTDOWN_ENABLE, 0),\n\tSENSOR_ATTR_2(in%d_min_alarm_enable, 0644, show_bank1_mask,\n\t\tstore_bank1_mask, ABIT_UGURU_VOLT_LOW_ALARM_ENABLE, 0),\n\tSENSOR_ATTR_2(in%d_max_alarm_enable, 0644, show_bank1_mask,\n\t\tstore_bank1_mask, ABIT_UGURU_VOLT_HIGH_ALARM_ENABLE, 0),\n\t}, {\n\tSENSOR_ATTR_2(temp%d_input, 0444, show_bank1_value, NULL, 0, 0),\n\tSENSOR_ATTR_2(temp%d_alarm, 0444, show_bank1_alarm, NULL,\n\t\tABIT_UGURU_TEMP_HIGH_ALARM_FLAG, 0),\n\tSENSOR_ATTR_2(temp%d_max, 0644, show_bank1_setting,\n\t\tstore_bank1_setting, 1, 0),\n\tSENSOR_ATTR_2(temp%d_crit, 0644, show_bank1_setting,\n\t\tstore_bank1_setting, 2, 0),\n\tSENSOR_ATTR_2(temp%d_beep, 0644, show_bank1_mask,\n\t\tstore_bank1_mask, ABIT_UGURU_BEEP_ENABLE, 0),\n\tSENSOR_ATTR_2(temp%d_shutdown, 0644, show_bank1_mask,\n\t\tstore_bank1_mask, ABIT_UGURU_SHUTDOWN_ENABLE, 0),\n\tSENSOR_ATTR_2(temp%d_alarm_enable, 0644, show_bank1_mask,\n\t\tstore_bank1_mask, ABIT_UGURU_TEMP_HIGH_ALARM_ENABLE, 0),\n\t}\n};\n\nstatic const struct sensor_device_attribute_2 abituguru_sysfs_fan_templ[6] = {\n\tSENSOR_ATTR_2(fan%d_input, 0444, show_bank2_value, NULL, 0, 0),\n\tSENSOR_ATTR_2(fan%d_alarm, 0444, show_bank2_alarm, NULL, 0, 0),\n\tSENSOR_ATTR_2(fan%d_min, 0644, show_bank2_setting,\n\t\tstore_bank2_setting, 1, 0),\n\tSENSOR_ATTR_2(fan%d_beep, 0644, show_bank2_mask,\n\t\tstore_bank2_mask, ABIT_UGURU_BEEP_ENABLE, 0),\n\tSENSOR_ATTR_2(fan%d_shutdown, 0644, show_bank2_mask,\n\t\tstore_bank2_mask, ABIT_UGURU_SHUTDOWN_ENABLE, 0),\n\tSENSOR_ATTR_2(fan%d_alarm_enable, 0644, show_bank2_mask,\n\t\tstore_bank2_mask, ABIT_UGURU_FAN_LOW_ALARM_ENABLE, 0),\n};\n\nstatic const struct sensor_device_attribute_2 abituguru_sysfs_pwm_templ[6] = {\n\tSENSOR_ATTR_2(pwm%d_enable, 0644, show_pwm_enable,\n\t\tstore_pwm_enable, 0, 0),\n\tSENSOR_ATTR_2(pwm%d_auto_channels_temp, 0644, show_pwm_sensor,\n\t\tstore_pwm_sensor, 0, 0),\n\tSENSOR_ATTR_2(pwm%d_auto_point1_pwm, 0644, show_pwm_setting,\n\t\tstore_pwm_setting, 1, 0),\n\tSENSOR_ATTR_2(pwm%d_auto_point2_pwm, 0644, show_pwm_setting,\n\t\tstore_pwm_setting, 2, 0),\n\tSENSOR_ATTR_2(pwm%d_auto_point1_temp, 0644, show_pwm_setting,\n\t\tstore_pwm_setting, 3, 0),\n\tSENSOR_ATTR_2(pwm%d_auto_point2_temp, 0644, show_pwm_setting,\n\t\tstore_pwm_setting, 4, 0),\n};\n\nstatic struct sensor_device_attribute_2 abituguru_sysfs_attr[] = {\n\tSENSOR_ATTR_2(name, 0444, show_name, NULL, 0, 0),\n};\n\nstatic int abituguru_probe(struct platform_device *pdev)\n{\n\tstruct abituguru_data *data;\n\tint i, j, used, sysfs_names_free, sysfs_attr_i, res = -ENODEV;\n\tchar *sysfs_filename;\n\n\t \n\tstatic const u8 probe_order[ABIT_UGURU_MAX_BANK1_SENSORS] = {\n\t\t0x00, 0x01, 0x03, 0x04, 0x0A, 0x08, 0x0E, 0x02,\n\t\t0x09, 0x06, 0x05, 0x0B, 0x0F, 0x0D, 0x07, 0x0C };\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct abituguru_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->addr = platform_get_resource(pdev, IORESOURCE_IO, 0)->start;\n\tmutex_init(&data->update_lock);\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tif (inb_p(data->addr + ABIT_UGURU_DATA) == ABIT_UGURU_STATUS_INPUT)\n\t\tdata->uguru_ready = 1;\n\n\t \n\tif (abituguru_read(data, ABIT_UGURU_ALARM_BANK, 0,\n\t\t\tdata->alarms, 3, ABIT_UGURU_MAX_RETRIES) != 3)\n\t\tgoto abituguru_probe_error;\n\n\tfor (i = 0; i < ABIT_UGURU_MAX_BANK1_SENSORS; i++) {\n\t\tif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK1, i,\n\t\t\t\t&data->bank1_value[i], 1,\n\t\t\t\tABIT_UGURU_MAX_RETRIES) != 1)\n\t\t\tgoto abituguru_probe_error;\n\t\tif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK1+1, i,\n\t\t\t\tdata->bank1_settings[i], 3,\n\t\t\t\tABIT_UGURU_MAX_RETRIES) != 3)\n\t\t\tgoto abituguru_probe_error;\n\t}\n\t \n\tfor (i = 0; i < ABIT_UGURU_MAX_BANK2_SENSORS; i++) {\n\t\tif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK2, i,\n\t\t\t\t&data->bank2_value[i], 1,\n\t\t\t\tABIT_UGURU_MAX_RETRIES) != 1)\n\t\t\tgoto abituguru_probe_error;\n\t\tif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK2+1, i,\n\t\t\t\tdata->bank2_settings[i], 2,\n\t\t\t\tABIT_UGURU_MAX_RETRIES) != 2)\n\t\t\tgoto abituguru_probe_error;\n\t}\n\tfor (i = 0; i < ABIT_UGURU_MAX_PWMS; i++) {\n\t\tif (abituguru_read(data, ABIT_UGURU_FAN_PWM, i,\n\t\t\t\tdata->pwm_settings[i], 5,\n\t\t\t\tABIT_UGURU_MAX_RETRIES) != 5)\n\t\t\tgoto abituguru_probe_error;\n\t}\n\tdata->last_updated = jiffies;\n\n\t \n\tsysfs_attr_i = 0;\n\tsysfs_filename = data->sysfs_names;\n\tsysfs_names_free = ABITUGURU_SYSFS_NAMES_LENGTH;\n\tfor (i = 0; i < ABIT_UGURU_MAX_BANK1_SENSORS; i++) {\n\t\tres = abituguru_detect_bank1_sensor_type(data, probe_order[i]);\n\t\tif (res < 0)\n\t\t\tgoto abituguru_probe_error;\n\t\tif (res == ABIT_UGURU_NC)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (j = 0; j < (res ? 7 : 9); j++) {\n\t\t\tused = snprintf(sysfs_filename, sysfs_names_free,\n\t\t\t\tabituguru_sysfs_bank1_templ[res][j].dev_attr.\n\t\t\t\tattr.name, data->bank1_sensors[res] + res)\n\t\t\t\t+ 1;\n\t\t\tdata->sysfs_attr[sysfs_attr_i] =\n\t\t\t\tabituguru_sysfs_bank1_templ[res][j];\n\t\t\tdata->sysfs_attr[sysfs_attr_i].dev_attr.attr.name =\n\t\t\t\tsysfs_filename;\n\t\t\tdata->sysfs_attr[sysfs_attr_i].index = probe_order[i];\n\t\t\tsysfs_filename += used;\n\t\t\tsysfs_names_free -= used;\n\t\t\tsysfs_attr_i++;\n\t\t}\n\t\tdata->bank1_max_value[probe_order[i]] =\n\t\t\tabituguru_bank1_max_value[res];\n\t\tdata->bank1_address[res][data->bank1_sensors[res]] =\n\t\t\tprobe_order[i];\n\t\tdata->bank1_sensors[res]++;\n\t}\n\t \n\tabituguru_detect_no_bank2_sensors(data);\n\tfor (i = 0; i < data->bank2_sensors; i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(abituguru_sysfs_fan_templ); j++) {\n\t\t\tused = snprintf(sysfs_filename, sysfs_names_free,\n\t\t\t\tabituguru_sysfs_fan_templ[j].dev_attr.attr.name,\n\t\t\t\ti + 1) + 1;\n\t\t\tdata->sysfs_attr[sysfs_attr_i] =\n\t\t\t\tabituguru_sysfs_fan_templ[j];\n\t\t\tdata->sysfs_attr[sysfs_attr_i].dev_attr.attr.name =\n\t\t\t\tsysfs_filename;\n\t\t\tdata->sysfs_attr[sysfs_attr_i].index = i;\n\t\t\tsysfs_filename += used;\n\t\t\tsysfs_names_free -= used;\n\t\t\tsysfs_attr_i++;\n\t\t}\n\t}\n\t \n\tabituguru_detect_no_pwms(data);\n\tfor (i = 0; i < data->pwms; i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(abituguru_sysfs_pwm_templ); j++) {\n\t\t\tused = snprintf(sysfs_filename, sysfs_names_free,\n\t\t\t\tabituguru_sysfs_pwm_templ[j].dev_attr.attr.name,\n\t\t\t\ti + 1) + 1;\n\t\t\tdata->sysfs_attr[sysfs_attr_i] =\n\t\t\t\tabituguru_sysfs_pwm_templ[j];\n\t\t\tdata->sysfs_attr[sysfs_attr_i].dev_attr.attr.name =\n\t\t\t\tsysfs_filename;\n\t\t\tdata->sysfs_attr[sysfs_attr_i].index = i;\n\t\t\tsysfs_filename += used;\n\t\t\tsysfs_names_free -= used;\n\t\t\tsysfs_attr_i++;\n\t\t}\n\t}\n\t \n\tif (sysfs_names_free < 0) {\n\t\tpr_err(\"Fatal error ran out of space for sysfs attr names. %s %s\",\n\t\t       never_happen, report_this);\n\t\tres = -ENAMETOOLONG;\n\t\tgoto abituguru_probe_error;\n\t}\n\tpr_info(\"found Abit uGuru\\n\");\n\n\t \n\tfor (i = 0; i < sysfs_attr_i; i++) {\n\t\tres = device_create_file(&pdev->dev,\n\t\t\t\t\t &data->sysfs_attr[i].dev_attr);\n\t\tif (res)\n\t\t\tgoto abituguru_probe_error;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(abituguru_sysfs_attr); i++) {\n\t\tres = device_create_file(&pdev->dev,\n\t\t\t\t\t &abituguru_sysfs_attr[i].dev_attr);\n\t\tif (res)\n\t\t\tgoto abituguru_probe_error;\n\t}\n\n\tdata->hwmon_dev = hwmon_device_register(&pdev->dev);\n\tif (!IS_ERR(data->hwmon_dev))\n\t\treturn 0;  \n\n\tres = PTR_ERR(data->hwmon_dev);\nabituguru_probe_error:\n\tfor (i = 0; data->sysfs_attr[i].dev_attr.attr.name; i++)\n\t\tdevice_remove_file(&pdev->dev, &data->sysfs_attr[i].dev_attr);\n\tfor (i = 0; i < ARRAY_SIZE(abituguru_sysfs_attr); i++)\n\t\tdevice_remove_file(&pdev->dev,\n\t\t\t&abituguru_sysfs_attr[i].dev_attr);\n\treturn res;\n}\n\nstatic int abituguru_remove(struct platform_device *pdev)\n{\n\tint i;\n\tstruct abituguru_data *data = platform_get_drvdata(pdev);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tfor (i = 0; data->sysfs_attr[i].dev_attr.attr.name; i++)\n\t\tdevice_remove_file(&pdev->dev, &data->sysfs_attr[i].dev_attr);\n\tfor (i = 0; i < ARRAY_SIZE(abituguru_sysfs_attr); i++)\n\t\tdevice_remove_file(&pdev->dev,\n\t\t\t&abituguru_sysfs_attr[i].dev_attr);\n\n\treturn 0;\n}\n\nstatic struct abituguru_data *abituguru_update_device(struct device *dev)\n{\n\tint i, err;\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\t \n\tchar success = 1;\n\n\tmutex_lock(&data->update_lock);\n\tif (time_after(jiffies, data->last_updated + HZ)) {\n\t\tsuccess = 0;\n\t\terr = abituguru_read(data, ABIT_UGURU_ALARM_BANK, 0,\n\t\t\t\t     data->alarms, 3, 0);\n\t\tif (err != 3)\n\t\t\tgoto LEAVE_UPDATE;\n\t\tfor (i = 0; i < ABIT_UGURU_MAX_BANK1_SENSORS; i++) {\n\t\t\terr = abituguru_read(data, ABIT_UGURU_SENSOR_BANK1,\n\t\t\t\t\t     i, &data->bank1_value[i], 1, 0);\n\t\t\tif (err != 1)\n\t\t\t\tgoto LEAVE_UPDATE;\n\t\t\terr = abituguru_read(data, ABIT_UGURU_SENSOR_BANK1 + 1,\n\t\t\t\t\t     i, data->bank1_settings[i], 3, 0);\n\t\t\tif (err != 3)\n\t\t\t\tgoto LEAVE_UPDATE;\n\t\t}\n\t\tfor (i = 0; i < data->bank2_sensors; i++) {\n\t\t\terr = abituguru_read(data, ABIT_UGURU_SENSOR_BANK2, i,\n\t\t\t\t\t     &data->bank2_value[i], 1, 0);\n\t\t\tif (err != 1)\n\t\t\t\tgoto LEAVE_UPDATE;\n\t\t}\n\t\t \n\t\tsuccess = 1;\n\t\tdata->update_timeouts = 0;\nLEAVE_UPDATE:\n\t\t \n\t\tif (!success && (err == -EBUSY || err >= 0)) {\n\t\t\t \n\t\t\tif (data->update_timeouts < 255u)\n\t\t\t\tdata->update_timeouts++;\n\t\t\tif (data->update_timeouts <= ABIT_UGURU_MAX_TIMEOUTS) {\n\t\t\t\tABIT_UGURU_DEBUG(3, \"timeout exceeded, will \"\n\t\t\t\t\t\"try again next update\\n\");\n\t\t\t\t \n\t\t\t\tsuccess = 1;\n\t\t\t} else\n\t\t\t\tABIT_UGURU_DEBUG(1, \"timeout exceeded %d \"\n\t\t\t\t\t\"times waiting for more input state\\n\",\n\t\t\t\t\t(int)data->update_timeouts);\n\t\t}\n\t\t \n\t\tif (success)\n\t\t\tdata->last_updated = jiffies;\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\tif (success)\n\t\treturn data;\n\telse\n\t\treturn NULL;\n}\n\nstatic int abituguru_suspend(struct device *dev)\n{\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\t \n\tmutex_lock(&data->update_lock);\n\treturn 0;\n}\n\nstatic int abituguru_resume(struct device *dev)\n{\n\tstruct abituguru_data *data = dev_get_drvdata(dev);\n\t \n\tif (inb_p(data->addr + ABIT_UGURU_DATA) != ABIT_UGURU_STATUS_INPUT)\n\t\tdata->uguru_ready = 0;\n\tmutex_unlock(&data->update_lock);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(abituguru_pm, abituguru_suspend, abituguru_resume);\n\nstatic struct platform_driver abituguru_driver = {\n\t.driver = {\n\t\t.name\t= ABIT_UGURU_NAME,\n\t\t.pm\t= pm_sleep_ptr(&abituguru_pm),\n\t},\n\t.probe\t\t= abituguru_probe,\n\t.remove\t\t= abituguru_remove,\n};\n\nstatic int __init abituguru_detect(void)\n{\n\t \n\tu8 cmd_val = inb_p(ABIT_UGURU_BASE + ABIT_UGURU_CMD);\n\tu8 data_val = inb_p(ABIT_UGURU_BASE + ABIT_UGURU_DATA);\n\tif (((data_val == 0x00) || (data_val == 0x08)) &&\n\t    ((cmd_val == 0x00) || (cmd_val == 0xAC)))\n\t\treturn ABIT_UGURU_BASE;\n\n\tABIT_UGURU_DEBUG(2, \"no Abit uGuru found, data = 0x%02X, cmd = \"\n\t\t\"0x%02X\\n\", (unsigned int)data_val, (unsigned int)cmd_val);\n\n\tif (force) {\n\t\tpr_info(\"Assuming Abit uGuru is present because of \\\"force\\\" parameter\\n\");\n\t\treturn ABIT_UGURU_BASE;\n\t}\n\n\t \n\treturn -ENODEV;\n}\n\nstatic struct platform_device *abituguru_pdev;\n\nstatic int __init abituguru_init(void)\n{\n\tint address, err;\n\tstruct resource res = { .flags = IORESOURCE_IO };\n\tconst char *board_vendor = dmi_get_system_info(DMI_BOARD_VENDOR);\n\n\t \n\tif (!force && (!board_vendor ||\n\t\t\tstrcmp(board_vendor, \"http://www.abit.com.tw/\")))\n\t\treturn -ENODEV;\n\n\taddress = abituguru_detect();\n\tif (address < 0)\n\t\treturn address;\n\n\terr = platform_driver_register(&abituguru_driver);\n\tif (err)\n\t\tgoto exit;\n\n\tabituguru_pdev = platform_device_alloc(ABIT_UGURU_NAME, address);\n\tif (!abituguru_pdev) {\n\t\tpr_err(\"Device allocation failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto exit_driver_unregister;\n\t}\n\n\tres.start = address;\n\tres.end = address + ABIT_UGURU_REGION_LENGTH - 1;\n\tres.name = ABIT_UGURU_NAME;\n\n\terr = platform_device_add_resources(abituguru_pdev, &res, 1);\n\tif (err) {\n\t\tpr_err(\"Device resource addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(abituguru_pdev);\n\tif (err) {\n\t\tpr_err(\"Device addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\treturn 0;\n\nexit_device_put:\n\tplatform_device_put(abituguru_pdev);\nexit_driver_unregister:\n\tplatform_driver_unregister(&abituguru_driver);\nexit:\n\treturn err;\n}\n\nstatic void __exit abituguru_exit(void)\n{\n\tplatform_device_unregister(abituguru_pdev);\n\tplatform_driver_unregister(&abituguru_driver);\n}\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"Abit uGuru Sensor device\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(abituguru_init);\nmodule_exit(abituguru_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}