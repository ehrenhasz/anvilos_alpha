{
  "module_name": "sht15.c",
  "hash_id": "9722f1ddac000a9fa9005957bef3f2d53e9658322ef04d5375de5baac4101a51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/sht15.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/err.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/bitrev.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n\n \n#define SHT15_MEASURE_TEMP\t\t0x03\n#define SHT15_MEASURE_RH\t\t0x05\n#define SHT15_WRITE_STATUS\t\t0x06\n#define SHT15_READ_STATUS\t\t0x07\n#define SHT15_SOFT_RESET\t\t0x1E\n\n \n#define SHT15_TSCKL\t\t\t100\t \n#define SHT15_TSCKH\t\t\t100\t \n#define SHT15_TSU\t\t\t150\t \n#define SHT15_TSRST\t\t\t11\t \n\n \n#define SHT15_STATUS_LOW_RESOLUTION\t0x01\n#define SHT15_STATUS_NO_OTP_RELOAD\t0x02\n#define SHT15_STATUS_HEATER\t\t0x04\n#define SHT15_STATUS_LOW_BATTERY\t0x40\n\n \nenum sht15_chips { sht10, sht11, sht15, sht71, sht75 };\n\n \nenum sht15_state {\n\tSHT15_READING_NOTHING,\n\tSHT15_READING_TEMP,\n\tSHT15_READING_HUMID\n};\n\n \nstruct sht15_temppair {\n\tint vdd;  \n\tint d1;\n};\n\n \nstatic const struct sht15_temppair temppoints[] = {\n\t{ 2500000, -39400 },\n\t{ 3000000, -39600 },\n\t{ 3500000, -39700 },\n\t{ 4000000, -39800 },\n\t{ 5000000, -40100 },\n};\n\n \nstatic const u8 sht15_crc8_table[] = {\n\t0,\t49,\t98,\t83,\t196,\t245,\t166,\t151,\n\t185,\t136,\t219,\t234,\t125,\t76,\t31,\t46,\n\t67,\t114,\t33,\t16,\t135,\t182,\t229,\t212,\n\t250,\t203,\t152,\t169,\t62,\t15,\t92,\t109,\n\t134,\t183,\t228,\t213,\t66,\t115,\t32,\t17,\n\t63,\t14,\t93,\t108,\t251,\t202,\t153,\t168,\n\t197,\t244,\t167,\t150,\t1,\t48,\t99,\t82,\n\t124,\t77,\t30,\t47,\t184,\t137,\t218,\t235,\n\t61,\t12,\t95,\t110,\t249,\t200,\t155,\t170,\n\t132,\t181,\t230,\t215,\t64,\t113,\t34,\t19,\n\t126,\t79,\t28,\t45,\t186,\t139,\t216,\t233,\n\t199,\t246,\t165,\t148,\t3,\t50,\t97,\t80,\n\t187,\t138,\t217,\t232,\t127,\t78,\t29,\t44,\n\t2,\t51,\t96,\t81,\t198,\t247,\t164,\t149,\n\t248,\t201,\t154,\t171,\t60,\t13,\t94,\t111,\n\t65,\t112,\t35,\t18,\t133,\t180,\t231,\t214,\n\t122,\t75,\t24,\t41,\t190,\t143,\t220,\t237,\n\t195,\t242,\t161,\t144,\t7,\t54,\t101,\t84,\n\t57,\t8,\t91,\t106,\t253,\t204,\t159,\t174,\n\t128,\t177,\t226,\t211,\t68,\t117,\t38,\t23,\n\t252,\t205,\t158,\t175,\t56,\t9,\t90,\t107,\n\t69,\t116,\t39,\t22,\t129,\t176,\t227,\t210,\n\t191,\t142,\t221,\t236,\t123,\t74,\t25,\t40,\n\t6,\t55,\t100,\t85,\t194,\t243,\t160,\t145,\n\t71,\t118,\t37,\t20,\t131,\t178,\t225,\t208,\n\t254,\t207,\t156,\t173,\t58,\t11,\t88,\t105,\n\t4,\t53,\t102,\t87,\t192,\t241,\t162,\t147,\n\t189,\t140,\t223,\t238,\t121,\t72,\t27,\t42,\n\t193,\t240,\t163,\t146,\t5,\t52,\t103,\t86,\n\t120,\t73,\t26,\t43,\t188,\t141,\t222,\t239,\n\t130,\t179,\t224,\t209,\t70,\t119,\t36,\t21,\n\t59,\t10,\t89,\t104,\t255,\t206,\t157,\t172\n};\n\n \nstruct sht15_data {\n\tstruct gpio_desc\t\t*sck;\n\tstruct gpio_desc\t\t*data;\n\tstruct work_struct\t\tread_work;\n\twait_queue_head_t\t\twait_queue;\n\tuint16_t\t\t\tval_temp;\n\tuint16_t\t\t\tval_humid;\n\tu8\t\t\t\tval_status;\n\tbool\t\t\t\tchecksum_ok;\n\tbool\t\t\t\tchecksumming;\n\tenum sht15_state\t\tstate;\n\tbool\t\t\t\tmeasurements_valid;\n\tbool\t\t\t\tstatus_valid;\n\tunsigned long\t\t\tlast_measurement;\n\tunsigned long\t\t\tlast_status;\n\tstruct mutex\t\t\tread_lock;\n\tstruct device\t\t\t*dev;\n\tstruct device\t\t\t*hwmon_dev;\n\tstruct regulator\t\t*reg;\n\tstruct notifier_block\t\tnb;\n\tint\t\t\t\tsupply_uv;\n\tbool\t\t\t\tsupply_uv_valid;\n\tstruct work_struct\t\tupdate_supply_work;\n\tatomic_t\t\t\tinterrupt_handled;\n};\n\n \nstatic u8 sht15_crc8(struct sht15_data *data,\n\t\tconst u8 *value,\n\t\tint len)\n{\n\tu8 crc = bitrev8(data->val_status & 0x0F);\n\n\twhile (len--) {\n\t\tcrc = sht15_crc8_table[*value ^ crc];\n\t\tvalue++;\n\t}\n\n\treturn crc;\n}\n\n \nstatic int sht15_connection_reset(struct sht15_data *data)\n{\n\tint i, err;\n\n\terr = gpiod_direction_output(data->data, 1);\n\tif (err)\n\t\treturn err;\n\tndelay(SHT15_TSCKL);\n\tgpiod_set_value(data->sck, 0);\n\tndelay(SHT15_TSCKL);\n\tfor (i = 0; i < 9; ++i) {\n\t\tgpiod_set_value(data->sck, 1);\n\t\tndelay(SHT15_TSCKH);\n\t\tgpiod_set_value(data->sck, 0);\n\t\tndelay(SHT15_TSCKL);\n\t}\n\treturn 0;\n}\n\n \nstatic inline void sht15_send_bit(struct sht15_data *data, int val)\n{\n\tgpiod_set_value(data->data, val);\n\tndelay(SHT15_TSU);\n\tgpiod_set_value(data->sck, 1);\n\tndelay(SHT15_TSCKH);\n\tgpiod_set_value(data->sck, 0);\n\tndelay(SHT15_TSCKL);  \n}\n\n \nstatic int sht15_transmission_start(struct sht15_data *data)\n{\n\tint err;\n\n\t \n\terr = gpiod_direction_output(data->data, 1);\n\tif (err)\n\t\treturn err;\n\tndelay(SHT15_TSU);\n\tgpiod_set_value(data->sck, 0);\n\tndelay(SHT15_TSCKL);\n\tgpiod_set_value(data->sck, 1);\n\tndelay(SHT15_TSCKH);\n\tgpiod_set_value(data->data, 0);\n\tndelay(SHT15_TSU);\n\tgpiod_set_value(data->sck, 0);\n\tndelay(SHT15_TSCKL);\n\tgpiod_set_value(data->sck, 1);\n\tndelay(SHT15_TSCKH);\n\tgpiod_set_value(data->data, 1);\n\tndelay(SHT15_TSU);\n\tgpiod_set_value(data->sck, 0);\n\tndelay(SHT15_TSCKL);\n\treturn 0;\n}\n\n \nstatic void sht15_send_byte(struct sht15_data *data, u8 byte)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tsht15_send_bit(data, !!(byte & 0x80));\n\t\tbyte <<= 1;\n\t}\n}\n\n \nstatic int sht15_wait_for_response(struct sht15_data *data)\n{\n\tint err;\n\n\terr = gpiod_direction_input(data->data);\n\tif (err)\n\t\treturn err;\n\tgpiod_set_value(data->sck, 1);\n\tndelay(SHT15_TSCKH);\n\tif (gpiod_get_value(data->data)) {\n\t\tgpiod_set_value(data->sck, 0);\n\t\tdev_err(data->dev, \"Command not acknowledged\\n\");\n\t\terr = sht15_connection_reset(data);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn -EIO;\n\t}\n\tgpiod_set_value(data->sck, 0);\n\tndelay(SHT15_TSCKL);\n\treturn 0;\n}\n\n \nstatic int sht15_send_cmd(struct sht15_data *data, u8 cmd)\n{\n\tint err;\n\n\terr = sht15_transmission_start(data);\n\tif (err)\n\t\treturn err;\n\tsht15_send_byte(data, cmd);\n\treturn sht15_wait_for_response(data);\n}\n\n \nstatic int sht15_soft_reset(struct sht15_data *data)\n{\n\tint ret;\n\n\tret = sht15_send_cmd(data, SHT15_SOFT_RESET);\n\tif (ret)\n\t\treturn ret;\n\tmsleep(SHT15_TSRST);\n\t \n\tdata->val_status = 0;\n\n\treturn ret;\n}\n\n \nstatic int sht15_ack(struct sht15_data *data)\n{\n\tint err;\n\n\terr = gpiod_direction_output(data->data, 0);\n\tif (err)\n\t\treturn err;\n\tndelay(SHT15_TSU);\n\tgpiod_set_value(data->sck, 1);\n\tndelay(SHT15_TSU);\n\tgpiod_set_value(data->sck, 0);\n\tndelay(SHT15_TSU);\n\tgpiod_set_value(data->data, 1);\n\n\treturn gpiod_direction_input(data->data);\n}\n\n \nstatic int sht15_end_transmission(struct sht15_data *data)\n{\n\tint err;\n\n\terr = gpiod_direction_output(data->data, 1);\n\tif (err)\n\t\treturn err;\n\tndelay(SHT15_TSU);\n\tgpiod_set_value(data->sck, 1);\n\tndelay(SHT15_TSCKH);\n\tgpiod_set_value(data->sck, 0);\n\tndelay(SHT15_TSCKL);\n\treturn 0;\n}\n\n \nstatic u8 sht15_read_byte(struct sht15_data *data)\n{\n\tint i;\n\tu8 byte = 0;\n\n\tfor (i = 0; i < 8; ++i) {\n\t\tbyte <<= 1;\n\t\tgpiod_set_value(data->sck, 1);\n\t\tndelay(SHT15_TSCKH);\n\t\tbyte |= !!gpiod_get_value(data->data);\n\t\tgpiod_set_value(data->sck, 0);\n\t\tndelay(SHT15_TSCKL);\n\t}\n\treturn byte;\n}\n\n \nstatic int sht15_send_status(struct sht15_data *data, u8 status)\n{\n\tint err;\n\n\terr = sht15_send_cmd(data, SHT15_WRITE_STATUS);\n\tif (err)\n\t\treturn err;\n\terr = gpiod_direction_output(data->data, 1);\n\tif (err)\n\t\treturn err;\n\tndelay(SHT15_TSU);\n\tsht15_send_byte(data, status);\n\terr = sht15_wait_for_response(data);\n\tif (err)\n\t\treturn err;\n\n\tdata->val_status = status;\n\treturn 0;\n}\n\n \nstatic int sht15_update_status(struct sht15_data *data)\n{\n\tint ret = 0;\n\tu8 status;\n\tu8 previous_config;\n\tu8 dev_checksum = 0;\n\tu8 checksum_vals[2];\n\tint timeout = HZ;\n\n\tmutex_lock(&data->read_lock);\n\tif (time_after(jiffies, data->last_status + timeout)\n\t\t\t|| !data->status_valid) {\n\t\tret = sht15_send_cmd(data, SHT15_READ_STATUS);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\tstatus = sht15_read_byte(data);\n\n\t\tif (data->checksumming) {\n\t\t\tsht15_ack(data);\n\t\t\tdev_checksum = bitrev8(sht15_read_byte(data));\n\t\t\tchecksum_vals[0] = SHT15_READ_STATUS;\n\t\t\tchecksum_vals[1] = status;\n\t\t\tdata->checksum_ok = (sht15_crc8(data, checksum_vals, 2)\n\t\t\t\t\t== dev_checksum);\n\t\t}\n\n\t\tret = sht15_end_transmission(data);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\t \n\t\tif (data->checksumming && !data->checksum_ok) {\n\t\t\tprevious_config = data->val_status & 0x07;\n\t\t\tret = sht15_soft_reset(data);\n\t\t\tif (ret)\n\t\t\t\tgoto unlock;\n\t\t\tif (previous_config) {\n\t\t\t\tret = sht15_send_status(data, previous_config);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(data->dev,\n\t\t\t\t\t\t\"CRC validation failed, unable \"\n\t\t\t\t\t\t\"to restore device settings\\n\");\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdata->val_status = status;\n\t\tdata->status_valid = true;\n\t\tdata->last_status = jiffies;\n\t}\n\nunlock:\n\tmutex_unlock(&data->read_lock);\n\treturn ret;\n}\n\n \nstatic int sht15_measurement(struct sht15_data *data,\n\t\t\t     int command,\n\t\t\t     int timeout_msecs)\n{\n\tint ret;\n\tu8 previous_config;\n\n\tret = sht15_send_cmd(data, command);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gpiod_direction_input(data->data);\n\tif (ret)\n\t\treturn ret;\n\tatomic_set(&data->interrupt_handled, 0);\n\n\tenable_irq(gpiod_to_irq(data->data));\n\tif (gpiod_get_value(data->data) == 0) {\n\t\tdisable_irq_nosync(gpiod_to_irq(data->data));\n\t\t \n\t\tif (!atomic_read(&data->interrupt_handled))\n\t\t\tschedule_work(&data->read_work);\n\t}\n\tret = wait_event_timeout(data->wait_queue,\n\t\t\t\t (data->state == SHT15_READING_NOTHING),\n\t\t\t\t msecs_to_jiffies(timeout_msecs));\n\tif (data->state != SHT15_READING_NOTHING) {  \n\t\tdata->state = SHT15_READING_NOTHING;\n\t\treturn -EIO;\n\t} else if (ret == 0) {  \n\t\tdisable_irq_nosync(gpiod_to_irq(data->data));\n\t\tret = sht15_connection_reset(data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn -ETIME;\n\t}\n\n\t \n\tif (data->checksumming && !data->checksum_ok) {\n\t\tprevious_config = data->val_status & 0x07;\n\t\tret = sht15_soft_reset(data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (previous_config) {\n\t\t\tret = sht15_send_status(data, previous_config);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(data->dev,\n\t\t\t\t\t\"CRC validation failed, unable \"\n\t\t\t\t\t\"to restore device settings\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sht15_update_measurements(struct sht15_data *data)\n{\n\tint ret = 0;\n\tint timeout = HZ;\n\n\tmutex_lock(&data->read_lock);\n\tif (time_after(jiffies, data->last_measurement + timeout)\n\t    || !data->measurements_valid) {\n\t\tdata->state = SHT15_READING_HUMID;\n\t\tret = sht15_measurement(data, SHT15_MEASURE_RH, 160);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\tdata->state = SHT15_READING_TEMP;\n\t\tret = sht15_measurement(data, SHT15_MEASURE_TEMP, 400);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\tdata->measurements_valid = true;\n\t\tdata->last_measurement = jiffies;\n\t}\n\nunlock:\n\tmutex_unlock(&data->read_lock);\n\treturn ret;\n}\n\n \nstatic inline int sht15_calc_temp(struct sht15_data *data)\n{\n\tint d1 = temppoints[0].d1;\n\tint d2 = (data->val_status & SHT15_STATUS_LOW_RESOLUTION) ? 40 : 10;\n\tint i;\n\n\tfor (i = ARRAY_SIZE(temppoints) - 1; i > 0; i--)\n\t\t \n\t\tif (data->supply_uv > temppoints[i - 1].vdd) {\n\t\t\td1 = (data->supply_uv - temppoints[i - 1].vdd)\n\t\t\t\t* (temppoints[i].d1 - temppoints[i - 1].d1)\n\t\t\t\t/ (temppoints[i].vdd - temppoints[i - 1].vdd)\n\t\t\t\t+ temppoints[i - 1].d1;\n\t\t\tbreak;\n\t\t}\n\n\treturn data->val_temp * d2 + d1;\n}\n\n \nstatic inline int sht15_calc_humid(struct sht15_data *data)\n{\n\tint rh_linear;  \n\tint temp = sht15_calc_temp(data);\n\tint c2, c3;\n\tint t2;\n\tconst int c1 = -4;\n\n\tif (data->val_status & SHT15_STATUS_LOW_RESOLUTION) {\n\t\tc2 = 648000;  \n\t\tc3 = -7200;   \n\t\tt2 = 1280;\n\t} else {\n\t\tc2 = 40500;   \n\t\tc3 = -28;     \n\t\tt2 = 80;\n\t}\n\n\trh_linear = c1 * 1000\n\t\t+ c2 * data->val_humid / 1000\n\t\t+ (data->val_humid * data->val_humid * c3) / 10000;\n\treturn (temp - 25000) * (10000 + t2 * data->val_humid)\n\t\t/ 1000000 + rh_linear;\n}\n\n \nstatic ssize_t sht15_status_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct sht15_data *data = dev_get_drvdata(dev);\n\tu8 bit = to_sensor_dev_attr(attr)->index;\n\n\tret = sht15_update_status(data);\n\n\treturn ret ? ret : sprintf(buf, \"%d\\n\", !!(data->val_status & bit));\n}\n\n \nstatic ssize_t sht15_status_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tint ret;\n\tstruct sht15_data *data = dev_get_drvdata(dev);\n\tlong value;\n\tu8 status;\n\n\tif (kstrtol(buf, 10, &value))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->read_lock);\n\tstatus = data->val_status & 0x07;\n\tif (!!value)\n\t\tstatus |= SHT15_STATUS_HEATER;\n\telse\n\t\tstatus &= ~SHT15_STATUS_HEATER;\n\n\tret = sht15_send_status(data, status);\n\tmutex_unlock(&data->read_lock);\n\n\treturn ret ? ret : count;\n}\n\n \nstatic ssize_t sht15_temp_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct sht15_data *data = dev_get_drvdata(dev);\n\n\t \n\tret = sht15_update_measurements(data);\n\n\treturn ret ? ret : sprintf(buf, \"%d\\n\",\n\t\t\t\t   sht15_calc_temp(data));\n}\n\n \nstatic ssize_t sht15_humidity_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct sht15_data *data = dev_get_drvdata(dev);\n\n\tret = sht15_update_measurements(data);\n\n\treturn ret ? ret : sprintf(buf, \"%d\\n\", sht15_calc_humid(data));\n}\n\nstatic ssize_t name_show(struct device *dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\treturn sprintf(buf, \"%s\\n\", pdev->name);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, sht15_temp, 0);\nstatic SENSOR_DEVICE_ATTR_RO(humidity1_input, sht15_humidity, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_fault, sht15_status,\n\t\t\t     SHT15_STATUS_LOW_BATTERY);\nstatic SENSOR_DEVICE_ATTR_RO(humidity1_fault, sht15_status,\n\t\t\t     SHT15_STATUS_LOW_BATTERY);\nstatic SENSOR_DEVICE_ATTR_RW(heater_enable, sht15_status, SHT15_STATUS_HEATER);\nstatic DEVICE_ATTR_RO(name);\nstatic struct attribute *sht15_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_humidity1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_fault.dev_attr.attr,\n\t&sensor_dev_attr_humidity1_fault.dev_attr.attr,\n\t&sensor_dev_attr_heater_enable.dev_attr.attr,\n\t&dev_attr_name.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group sht15_attr_group = {\n\t.attrs = sht15_attrs,\n};\n\nstatic irqreturn_t sht15_interrupt_fired(int irq, void *d)\n{\n\tstruct sht15_data *data = d;\n\n\t \n\tdisable_irq_nosync(irq);\n\tatomic_inc(&data->interrupt_handled);\n\t \n\tif (data->state != SHT15_READING_NOTHING)\n\t\tschedule_work(&data->read_work);\n\treturn IRQ_HANDLED;\n}\n\nstatic void sht15_bh_read_data(struct work_struct *work_s)\n{\n\tuint16_t val = 0;\n\tu8 dev_checksum = 0;\n\tu8 checksum_vals[3];\n\tstruct sht15_data *data\n\t\t= container_of(work_s, struct sht15_data,\n\t\t\t       read_work);\n\n\t \n\tif (gpiod_get_value(data->data)) {\n\t\t \n\t\tatomic_set(&data->interrupt_handled, 0);\n\t\tenable_irq(gpiod_to_irq(data->data));\n\t\t \n\t\tif (gpiod_get_value(data->data)\n\t\t    || atomic_read(&data->interrupt_handled))\n\t\t\treturn;\n\t}\n\n\t \n\tval = sht15_read_byte(data);\n\tval <<= 8;\n\tif (sht15_ack(data))\n\t\tgoto wakeup;\n\tval |= sht15_read_byte(data);\n\n\tif (data->checksumming) {\n\t\t \n\t\tif (sht15_ack(data))\n\t\t\tgoto wakeup;\n\t\tdev_checksum = bitrev8(sht15_read_byte(data));\n\t\tchecksum_vals[0] = (data->state == SHT15_READING_TEMP) ?\n\t\t\tSHT15_MEASURE_TEMP : SHT15_MEASURE_RH;\n\t\tchecksum_vals[1] = (u8) (val >> 8);\n\t\tchecksum_vals[2] = (u8) val;\n\t\tdata->checksum_ok\n\t\t\t= (sht15_crc8(data, checksum_vals, 3) == dev_checksum);\n\t}\n\n\t \n\tif (sht15_end_transmission(data))\n\t\tgoto wakeup;\n\n\tswitch (data->state) {\n\tcase SHT15_READING_TEMP:\n\t\tdata->val_temp = val;\n\t\tbreak;\n\tcase SHT15_READING_HUMID:\n\t\tdata->val_humid = val;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdata->state = SHT15_READING_NOTHING;\nwakeup:\n\twake_up(&data->wait_queue);\n}\n\nstatic void sht15_update_voltage(struct work_struct *work_s)\n{\n\tstruct sht15_data *data\n\t\t= container_of(work_s, struct sht15_data,\n\t\t\t       update_supply_work);\n\tdata->supply_uv = regulator_get_voltage(data->reg);\n}\n\n \nstatic int sht15_invalidate_voltage(struct notifier_block *nb,\n\t\t\t\t    unsigned long event,\n\t\t\t\t    void *ignored)\n{\n\tstruct sht15_data *data = container_of(nb, struct sht15_data, nb);\n\n\tif (event == REGULATOR_EVENT_VOLTAGE_CHANGE)\n\t\tdata->supply_uv_valid = false;\n\tschedule_work(&data->update_supply_work);\n\n\treturn NOTIFY_OK;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id sht15_dt_match[] = {\n\t{ .compatible = \"sensirion,sht15\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sht15_dt_match);\n#endif\n\nstatic int sht15_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct sht15_data *data;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&data->read_work, sht15_bh_read_data);\n\tINIT_WORK(&data->update_supply_work, sht15_update_voltage);\n\tplatform_set_drvdata(pdev, data);\n\tmutex_init(&data->read_lock);\n\tdata->dev = &pdev->dev;\n\tinit_waitqueue_head(&data->wait_queue);\n\n\t \n\tdata->reg = devm_regulator_get_optional(data->dev, \"vcc\");\n\tif (!IS_ERR(data->reg)) {\n\t\tint voltage;\n\n\t\tvoltage = regulator_get_voltage(data->reg);\n\t\tif (voltage)\n\t\t\tdata->supply_uv = voltage;\n\n\t\tret = regulator_enable(data->reg);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to enable regulator: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tdata->nb.notifier_call = &sht15_invalidate_voltage;\n\t\tret = regulator_register_notifier(data->reg, &data->nb);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"regulator notifier request failed\\n\");\n\t\t\tregulator_disable(data->reg);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tdata->sck = devm_gpiod_get(&pdev->dev, \"clk\", GPIOD_OUT_LOW);\n\tif (IS_ERR(data->sck)) {\n\t\tret = PTR_ERR(data->sck);\n\t\tdev_err(&pdev->dev, \"clock line GPIO request failed\\n\");\n\t\tgoto err_release_reg;\n\t}\n\tdata->data = devm_gpiod_get(&pdev->dev, \"data\", GPIOD_IN);\n\tif (IS_ERR(data->data)) {\n\t\tret = PTR_ERR(data->data);\n\t\tdev_err(&pdev->dev, \"data line GPIO request failed\\n\");\n\t\tgoto err_release_reg;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, gpiod_to_irq(data->data),\n\t\t\t       sht15_interrupt_fired,\n\t\t\t       IRQF_TRIGGER_FALLING,\n\t\t\t       \"sht15 data\",\n\t\t\t       data);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to get irq for data line\\n\");\n\t\tgoto err_release_reg;\n\t}\n\tdisable_irq_nosync(gpiod_to_irq(data->data));\n\tret = sht15_connection_reset(data);\n\tif (ret)\n\t\tgoto err_release_reg;\n\tret = sht15_soft_reset(data);\n\tif (ret)\n\t\tgoto err_release_reg;\n\n\tret = sysfs_create_group(&pdev->dev.kobj, &sht15_attr_group);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"sysfs create failed\\n\");\n\t\tgoto err_release_reg;\n\t}\n\n\tdata->hwmon_dev = hwmon_device_register(data->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\tret = PTR_ERR(data->hwmon_dev);\n\t\tgoto err_release_sysfs_group;\n\t}\n\n\treturn 0;\n\nerr_release_sysfs_group:\n\tsysfs_remove_group(&pdev->dev.kobj, &sht15_attr_group);\nerr_release_reg:\n\tif (!IS_ERR(data->reg)) {\n\t\tregulator_unregister_notifier(data->reg, &data->nb);\n\t\tregulator_disable(data->reg);\n\t}\n\treturn ret;\n}\n\nstatic int sht15_remove(struct platform_device *pdev)\n{\n\tstruct sht15_data *data = platform_get_drvdata(pdev);\n\tint ret;\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tsysfs_remove_group(&pdev->dev.kobj, &sht15_attr_group);\n\n\tret = sht15_soft_reset(data);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Failed to reset device (%pe)\\n\", ERR_PTR(ret));\n\n\tif (!IS_ERR(data->reg)) {\n\t\tregulator_unregister_notifier(data->reg, &data->nb);\n\t\tregulator_disable(data->reg);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id sht15_device_ids[] = {\n\t{ \"sht10\", sht10 },\n\t{ \"sht11\", sht11 },\n\t{ \"sht15\", sht15 },\n\t{ \"sht71\", sht71 },\n\t{ \"sht75\", sht75 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, sht15_device_ids);\n\nstatic struct platform_driver sht15_driver = {\n\t.driver = {\n\t\t.name = \"sht15\",\n\t\t.of_match_table = of_match_ptr(sht15_dt_match),\n\t},\n\t.probe = sht15_probe,\n\t.remove = sht15_remove,\n\t.id_table = sht15_device_ids,\n};\nmodule_platform_driver(sht15_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Sensirion SHT15 temperature and humidity sensor driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}