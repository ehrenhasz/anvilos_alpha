{
  "module_name": "gpio-fan.c",
  "hash_id": "838795cdadbf671b4c1002c6b5d2d4b5c69516a6c9f572441b861537834e9fa6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/gpio-fan.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/kstrtox.h>\n#include <linux/mutex.h>\n#include <linux/hwmon.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/thermal.h>\n\nstruct gpio_fan_speed {\n\tint rpm;\n\tint ctrl_val;\n};\n\nstruct gpio_fan_data {\n\tstruct device\t\t*dev;\n\tstruct device\t\t*hwmon_dev;\n\t \n\tstruct thermal_cooling_device *cdev;\n\tstruct mutex\t\tlock;  \n\tint\t\t\tnum_gpios;\n\tstruct gpio_desc\t**gpios;\n\tint\t\t\tnum_speed;\n\tstruct gpio_fan_speed\t*speed;\n\tint\t\t\tspeed_index;\n\tint\t\t\tresume_speed;\n\tbool\t\t\tpwm_enable;\n\tstruct gpio_desc\t*alarm_gpio;\n\tstruct work_struct\talarm_work;\n};\n\n \n\nstatic void fan_alarm_notify(struct work_struct *ws)\n{\n\tstruct gpio_fan_data *fan_data =\n\t\tcontainer_of(ws, struct gpio_fan_data, alarm_work);\n\n\tsysfs_notify(&fan_data->hwmon_dev->kobj, NULL, \"fan1_alarm\");\n\tkobject_uevent(&fan_data->hwmon_dev->kobj, KOBJ_CHANGE);\n}\n\nstatic irqreturn_t fan_alarm_irq_handler(int irq, void *dev_id)\n{\n\tstruct gpio_fan_data *fan_data = dev_id;\n\n\tschedule_work(&fan_data->alarm_work);\n\n\treturn IRQ_NONE;\n}\n\nstatic ssize_t fan1_alarm_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       gpiod_get_value_cansleep(fan_data->alarm_gpio));\n}\n\nstatic DEVICE_ATTR_RO(fan1_alarm);\n\nstatic int fan_alarm_init(struct gpio_fan_data *fan_data)\n{\n\tint alarm_irq;\n\tstruct device *dev = fan_data->dev;\n\n\t \n\talarm_irq = gpiod_to_irq(fan_data->alarm_gpio);\n\tif (alarm_irq <= 0)\n\t\treturn 0;\n\n\tINIT_WORK(&fan_data->alarm_work, fan_alarm_notify);\n\tirq_set_irq_type(alarm_irq, IRQ_TYPE_EDGE_BOTH);\n\treturn devm_request_irq(dev, alarm_irq, fan_alarm_irq_handler,\n\t\t\t\tIRQF_SHARED, \"GPIO fan alarm\", fan_data);\n}\n\n \n\n \nstatic void __set_fan_ctrl(struct gpio_fan_data *fan_data, int ctrl_val)\n{\n\tint i;\n\n\tfor (i = 0; i < fan_data->num_gpios; i++)\n\t\tgpiod_set_value_cansleep(fan_data->gpios[i],\n\t\t\t\t\t (ctrl_val >> i) & 1);\n}\n\nstatic int __get_fan_ctrl(struct gpio_fan_data *fan_data)\n{\n\tint i;\n\tint ctrl_val = 0;\n\n\tfor (i = 0; i < fan_data->num_gpios; i++) {\n\t\tint value;\n\n\t\tvalue = gpiod_get_value_cansleep(fan_data->gpios[i]);\n\t\tctrl_val |= (value << i);\n\t}\n\treturn ctrl_val;\n}\n\n \nstatic void set_fan_speed(struct gpio_fan_data *fan_data, int speed_index)\n{\n\tif (fan_data->speed_index == speed_index)\n\t\treturn;\n\n\t__set_fan_ctrl(fan_data, fan_data->speed[speed_index].ctrl_val);\n\tfan_data->speed_index = speed_index;\n}\n\nstatic int get_fan_speed_index(struct gpio_fan_data *fan_data)\n{\n\tint ctrl_val = __get_fan_ctrl(fan_data);\n\tint i;\n\n\tfor (i = 0; i < fan_data->num_speed; i++)\n\t\tif (fan_data->speed[i].ctrl_val == ctrl_val)\n\t\t\treturn i;\n\n\tdev_warn(fan_data->dev,\n\t\t \"missing speed array entry for GPIO value 0x%x\\n\", ctrl_val);\n\n\treturn -ENODEV;\n}\n\nstatic int rpm_to_speed_index(struct gpio_fan_data *fan_data, unsigned long rpm)\n{\n\tstruct gpio_fan_speed *speed = fan_data->speed;\n\tint i;\n\n\tfor (i = 0; i < fan_data->num_speed; i++)\n\t\tif (speed[i].rpm >= rpm)\n\t\t\treturn i;\n\n\treturn fan_data->num_speed - 1;\n}\n\nstatic ssize_t pwm1_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\n\tu8 pwm = fan_data->speed_index * 255 / (fan_data->num_speed - 1);\n\n\treturn sprintf(buf, \"%d\\n\", pwm);\n}\n\nstatic ssize_t pwm1_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\n\tunsigned long pwm;\n\tint speed_index;\n\tint ret = count;\n\n\tif (kstrtoul(buf, 10, &pwm) || pwm > 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&fan_data->lock);\n\n\tif (!fan_data->pwm_enable) {\n\t\tret = -EPERM;\n\t\tgoto exit_unlock;\n\t}\n\n\tspeed_index = DIV_ROUND_UP(pwm * (fan_data->num_speed - 1), 255);\n\tset_fan_speed(fan_data, speed_index);\n\nexit_unlock:\n\tmutex_unlock(&fan_data->lock);\n\n\treturn ret;\n}\n\nstatic ssize_t pwm1_enable_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", fan_data->pwm_enable);\n}\n\nstatic ssize_t pwm1_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val) || val > 1)\n\t\treturn -EINVAL;\n\n\tif (fan_data->pwm_enable == val)\n\t\treturn count;\n\n\tmutex_lock(&fan_data->lock);\n\n\tfan_data->pwm_enable = val;\n\n\t \n\tif (val == 0)\n\t\tset_fan_speed(fan_data, fan_data->num_speed - 1);\n\n\tmutex_unlock(&fan_data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t pwm1_mode_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t fan1_min_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", fan_data->speed[0].rpm);\n}\n\nstatic ssize_t fan1_max_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       fan_data->speed[fan_data->num_speed - 1].rpm);\n}\n\nstatic ssize_t fan1_input_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", fan_data->speed[fan_data->speed_index].rpm);\n}\n\nstatic ssize_t set_rpm(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\n\tunsigned long rpm;\n\tint ret = count;\n\n\tif (kstrtoul(buf, 10, &rpm))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&fan_data->lock);\n\n\tif (!fan_data->pwm_enable) {\n\t\tret = -EPERM;\n\t\tgoto exit_unlock;\n\t}\n\n\tset_fan_speed(fan_data, rpm_to_speed_index(fan_data, rpm));\n\nexit_unlock:\n\tmutex_unlock(&fan_data->lock);\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RW(pwm1);\nstatic DEVICE_ATTR_RW(pwm1_enable);\nstatic DEVICE_ATTR_RO(pwm1_mode);\nstatic DEVICE_ATTR_RO(fan1_min);\nstatic DEVICE_ATTR_RO(fan1_max);\nstatic DEVICE_ATTR_RO(fan1_input);\nstatic DEVICE_ATTR(fan1_target, 0644, fan1_input_show, set_rpm);\n\nstatic umode_t gpio_fan_is_visible(struct kobject *kobj,\n\t\t\t\t   struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct gpio_fan_data *data = dev_get_drvdata(dev);\n\n\tif (index == 0 && !data->alarm_gpio)\n\t\treturn 0;\n\tif (index > 0 && !data->gpios)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic struct attribute *gpio_fan_attributes[] = {\n\t&dev_attr_fan1_alarm.attr,\t\t \n\t&dev_attr_pwm1.attr,\t\t\t \n\t&dev_attr_pwm1_enable.attr,\n\t&dev_attr_pwm1_mode.attr,\n\t&dev_attr_fan1_input.attr,\n\t&dev_attr_fan1_target.attr,\n\t&dev_attr_fan1_min.attr,\n\t&dev_attr_fan1_max.attr,\n\tNULL\n};\n\nstatic const struct attribute_group gpio_fan_group = {\n\t.attrs = gpio_fan_attributes,\n\t.is_visible = gpio_fan_is_visible,\n};\n\nstatic const struct attribute_group *gpio_fan_groups[] = {\n\t&gpio_fan_group,\n\tNULL\n};\n\nstatic int fan_ctrl_init(struct gpio_fan_data *fan_data)\n{\n\tint num_gpios = fan_data->num_gpios;\n\tstruct gpio_desc **gpios = fan_data->gpios;\n\tint i, err;\n\n\tfor (i = 0; i < num_gpios; i++) {\n\t\t \n\t\terr = gpiod_direction_output(gpios[i],\n\t\t\t\t\tgpiod_get_value_cansleep(gpios[i]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfan_data->pwm_enable = true;  \n\tfan_data->speed_index = get_fan_speed_index(fan_data);\n\tif (fan_data->speed_index < 0)\n\t\treturn fan_data->speed_index;\n\n\treturn 0;\n}\n\nstatic int gpio_fan_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t  unsigned long *state)\n{\n\tstruct gpio_fan_data *fan_data = cdev->devdata;\n\n\tif (!fan_data)\n\t\treturn -EINVAL;\n\n\t*state = fan_data->num_speed - 1;\n\treturn 0;\n}\n\nstatic int gpio_fan_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t  unsigned long *state)\n{\n\tstruct gpio_fan_data *fan_data = cdev->devdata;\n\n\tif (!fan_data)\n\t\treturn -EINVAL;\n\n\t*state = fan_data->speed_index;\n\treturn 0;\n}\n\nstatic int gpio_fan_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t  unsigned long state)\n{\n\tstruct gpio_fan_data *fan_data = cdev->devdata;\n\n\tif (!fan_data)\n\t\treturn -EINVAL;\n\n\tif (state >= fan_data->num_speed)\n\t\treturn -EINVAL;\n\n\tset_fan_speed(fan_data, state);\n\treturn 0;\n}\n\nstatic const struct thermal_cooling_device_ops gpio_fan_cool_ops = {\n\t.get_max_state = gpio_fan_get_max_state,\n\t.get_cur_state = gpio_fan_get_cur_state,\n\t.set_cur_state = gpio_fan_set_cur_state,\n};\n\n \nstatic int gpio_fan_get_of_data(struct gpio_fan_data *fan_data)\n{\n\tstruct gpio_fan_speed *speed;\n\tstruct device *dev = fan_data->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct gpio_desc **gpios;\n\tunsigned i;\n\tu32 u;\n\tstruct property *prop;\n\tconst __be32 *p;\n\n\t \n\tfan_data->alarm_gpio = devm_gpiod_get_optional(dev, \"alarm\", GPIOD_IN);\n\tif (IS_ERR(fan_data->alarm_gpio))\n\t\treturn PTR_ERR(fan_data->alarm_gpio);\n\n\t \n\tfan_data->num_gpios = gpiod_count(dev, NULL);\n\tif (fan_data->num_gpios <= 0) {\n\t\tif (fan_data->alarm_gpio)\n\t\t\treturn 0;\n\t\tdev_err(dev, \"DT properties empty / missing\");\n\t\treturn -ENODEV;\n\t}\n\tgpios = devm_kcalloc(dev,\n\t\t\t     fan_data->num_gpios, sizeof(struct gpio_desc *),\n\t\t\t     GFP_KERNEL);\n\tif (!gpios)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < fan_data->num_gpios; i++) {\n\t\tgpios[i] = devm_gpiod_get_index(dev, NULL, i, GPIOD_ASIS);\n\t\tif (IS_ERR(gpios[i]))\n\t\t\treturn PTR_ERR(gpios[i]);\n\t}\n\tfan_data->gpios = gpios;\n\n\t \n\tprop = of_find_property(np, \"gpio-fan,speed-map\", &i);\n\tif (!prop) {\n\t\tdev_err(dev, \"gpio-fan,speed-map DT property missing\");\n\t\treturn -ENODEV;\n\t}\n\ti = i / sizeof(u32);\n\tif (i == 0 || i & 1) {\n\t\tdev_err(dev, \"gpio-fan,speed-map contains zero/odd number of entries\");\n\t\treturn -ENODEV;\n\t}\n\tfan_data->num_speed = i / 2;\n\n\t \n\tspeed = devm_kcalloc(dev,\n\t\t\tfan_data->num_speed, sizeof(struct gpio_fan_speed),\n\t\t\tGFP_KERNEL);\n\tif (!speed)\n\t\treturn -ENOMEM;\n\tp = NULL;\n\tfor (i = 0; i < fan_data->num_speed; i++) {\n\t\tp = of_prop_next_u32(prop, p, &u);\n\t\tif (!p)\n\t\t\treturn -ENODEV;\n\t\tspeed[i].rpm = u;\n\t\tp = of_prop_next_u32(prop, p, &u);\n\t\tif (!p)\n\t\t\treturn -ENODEV;\n\t\tspeed[i].ctrl_val = u;\n\t}\n\tfan_data->speed = speed;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_gpio_fan_match[] = {\n\t{ .compatible = \"gpio-fan\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_gpio_fan_match);\n\nstatic void gpio_fan_stop(void *data)\n{\n\tset_fan_speed(data, 0);\n}\n\nstatic int gpio_fan_probe(struct platform_device *pdev)\n{\n\tint err;\n\tstruct gpio_fan_data *fan_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\n\tfan_data = devm_kzalloc(dev, sizeof(struct gpio_fan_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!fan_data)\n\t\treturn -ENOMEM;\n\n\tfan_data->dev = dev;\n\terr = gpio_fan_get_of_data(fan_data);\n\tif (err)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, fan_data);\n\tmutex_init(&fan_data->lock);\n\n\t \n\tif (fan_data->gpios && fan_data->num_gpios > 0) {\n\t\tif (!fan_data->speed || fan_data->num_speed <= 1)\n\t\t\treturn -EINVAL;\n\t\terr = fan_ctrl_init(fan_data);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = devm_add_action_or_reset(dev, gpio_fan_stop, fan_data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfan_data->hwmon_dev =\n\t\tdevm_hwmon_device_register_with_groups(dev,\n\t\t\t\t\t\t       \"gpio_fan\", fan_data,\n\t\t\t\t\t\t       gpio_fan_groups);\n\tif (IS_ERR(fan_data->hwmon_dev))\n\t\treturn PTR_ERR(fan_data->hwmon_dev);\n\n\t \n\tif (fan_data->alarm_gpio) {\n\t\terr = fan_alarm_init(fan_data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfan_data->cdev = devm_thermal_of_cooling_device_register(dev, np,\n\t\t\t\t\"gpio-fan\", fan_data, &gpio_fan_cool_ops);\n\n\tdev_info(dev, \"GPIO fan initialized\\n\");\n\n\treturn 0;\n}\n\nstatic void gpio_fan_shutdown(struct platform_device *pdev)\n{\n\tstruct gpio_fan_data *fan_data = platform_get_drvdata(pdev);\n\n\tif (fan_data->gpios)\n\t\tset_fan_speed(fan_data, 0);\n}\n\nstatic int gpio_fan_suspend(struct device *dev)\n{\n\tstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\n\n\tif (fan_data->gpios) {\n\t\tfan_data->resume_speed = fan_data->speed_index;\n\t\tset_fan_speed(fan_data, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int gpio_fan_resume(struct device *dev)\n{\n\tstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\n\n\tif (fan_data->gpios)\n\t\tset_fan_speed(fan_data, fan_data->resume_speed);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(gpio_fan_pm, gpio_fan_suspend, gpio_fan_resume);\n\nstatic struct platform_driver gpio_fan_driver = {\n\t.probe\t\t= gpio_fan_probe,\n\t.shutdown\t= gpio_fan_shutdown,\n\t.driver\t= {\n\t\t.name\t= \"gpio-fan\",\n\t\t.pm\t= pm_sleep_ptr(&gpio_fan_pm),\n\t\t.of_match_table = of_gpio_fan_match,\n\t},\n};\n\nmodule_platform_driver(gpio_fan_driver);\n\nMODULE_AUTHOR(\"Simon Guinot <sguinot@lacie.com>\");\nMODULE_DESCRIPTION(\"GPIO FAN driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:gpio-fan\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}