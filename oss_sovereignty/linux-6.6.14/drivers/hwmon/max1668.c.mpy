{
  "module_name": "max1668.c",
  "hash_id": "6b9563ef75be99092af47990a3da779fac777e4c080ef67fe112399588dc009e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max1668.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n\n \nstatic const unsigned short max1668_addr_list[] = {\n\t0x18, 0x19, 0x1a, 0x29, 0x2a, 0x2b, 0x4c, 0x4d, 0x4e, I2C_CLIENT_END };\n\n \n\n#define MAX1668_REG_TEMP(nr)\t(nr)\n#define MAX1668_REG_STAT1\t0x05\n#define MAX1668_REG_STAT2\t0x06\n#define MAX1668_REG_MAN_ID\t0xfe\n#define MAX1668_REG_DEV_ID\t0xff\n\n \n\n \n#define MAX1668_REG_LIMH_WR(nr)\t(0x13 + 2 * (nr))\n \n#define MAX1668_REG_LIML_WR(nr)\t(0x14 + 2 * (nr))\n \n#define MAX1668_REG_LIMH_RD(nr)\t(0x08 + 2 * (nr))\n \n#define MAX1668_REG_LIML_RD(nr)\t(0x09 + 2 * (nr))\n\n \n#define MAN_ID_MAXIM\t\t0x4d\n#define DEV_ID_MAX1668\t\t0x3\n#define DEV_ID_MAX1805\t\t0x5\n#define DEV_ID_MAX1989\t\t0xb\n\n \nstatic bool read_only;\nmodule_param(read_only, bool, 0);\nMODULE_PARM_DESC(read_only, \"Don't set any values, read only mode\");\n\nenum chips { max1668, max1805, max1989 };\n\nstruct max1668_data {\n\tstruct i2c_client *client;\n\tconst struct attribute_group *groups[3];\n\tenum chips type;\n\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\n\t \n\ts8 temp_max[5];\n\ts8 temp_min[5];\n\ts8 temp[5];\n\tu16 alarms;\n};\n\nstatic struct max1668_data *max1668_update_device(struct device *dev)\n{\n\tstruct max1668_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tstruct max1668_data *ret = data;\n\ts32 val;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (data->valid && !time_after(jiffies,\n\t\t\tdata->last_updated + HZ + HZ / 2))\n\t\tgoto abort;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tval = i2c_smbus_read_byte_data(client, MAX1668_REG_TEMP(i));\n\t\tif (unlikely(val < 0)) {\n\t\t\tret = ERR_PTR(val);\n\t\t\tgoto abort;\n\t\t}\n\t\tdata->temp[i] = (s8) val;\n\n\t\tval = i2c_smbus_read_byte_data(client, MAX1668_REG_LIMH_RD(i));\n\t\tif (unlikely(val < 0)) {\n\t\t\tret = ERR_PTR(val);\n\t\t\tgoto abort;\n\t\t}\n\t\tdata->temp_max[i] = (s8) val;\n\n\t\tval = i2c_smbus_read_byte_data(client, MAX1668_REG_LIML_RD(i));\n\t\tif (unlikely(val < 0)) {\n\t\t\tret = ERR_PTR(val);\n\t\t\tgoto abort;\n\t\t}\n\t\tdata->temp_min[i] = (s8) val;\n\t}\n\n\tval = i2c_smbus_read_byte_data(client, MAX1668_REG_STAT1);\n\tif (unlikely(val < 0)) {\n\t\tret = ERR_PTR(val);\n\t\tgoto abort;\n\t}\n\tdata->alarms = val << 8;\n\n\tval = i2c_smbus_read_byte_data(client, MAX1668_REG_STAT2);\n\tif (unlikely(val < 0)) {\n\t\tret = ERR_PTR(val);\n\t\tgoto abort;\n\t}\n\tdata->alarms |= val;\n\n\tdata->last_updated = jiffies;\n\tdata->valid = true;\nabort:\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t show_temp(struct device *dev,\n\t\t\t struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct max1668_data *data = max1668_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->temp[index] * 1000);\n}\n\nstatic ssize_t show_temp_max(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct max1668_data *data = max1668_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->temp_max[index] * 1000);\n}\n\nstatic ssize_t show_temp_min(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct max1668_data *data = max1668_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->temp_min[index] * 1000);\n}\n\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint index = to_sensor_dev_attr(attr)->index;\n\tstruct max1668_data *data = max1668_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> index) & 0x1);\n}\n\nstatic ssize_t show_fault(struct device *dev,\n\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct max1668_data *data = max1668_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       (data->alarms & (1 << 12)) && data->temp[index] == 127);\n}\n\nstatic ssize_t set_temp_max(struct device *dev,\n\t\t\t    struct device_attribute *devattr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct max1668_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_max[index] = clamp_val(temp/1000, -128, 127);\n\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tMAX1668_REG_LIMH_WR(index),\n\t\t\t\t\tdata->temp_max[index]);\n\tif (ret < 0)\n\t\tcount = ret;\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t set_temp_min(struct device *dev,\n\t\t\t    struct device_attribute *devattr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint index = to_sensor_dev_attr(devattr)->index;\n\tstruct max1668_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_min[index] = clamp_val(temp/1000, -128, 127);\n\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tMAX1668_REG_LIML_WR(index),\n\t\t\t\t\tdata->temp_min[index]);\n\tif (ret < 0)\n\t\tcount = ret;\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(temp1_max, S_IRUGO, show_temp_max,\n\t\t\t\tset_temp_max, 0);\nstatic SENSOR_DEVICE_ATTR(temp1_min, S_IRUGO, show_temp_min,\n\t\t\t\tset_temp_min, 0);\nstatic SENSOR_DEVICE_ATTR(temp2_input, S_IRUGO, show_temp, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(temp2_max, S_IRUGO, show_temp_max,\n\t\t\t\tset_temp_max, 1);\nstatic SENSOR_DEVICE_ATTR(temp2_min, S_IRUGO, show_temp_min,\n\t\t\t\tset_temp_min, 1);\nstatic SENSOR_DEVICE_ATTR(temp3_input, S_IRUGO, show_temp, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(temp3_max, S_IRUGO, show_temp_max,\n\t\t\t\tset_temp_max, 2);\nstatic SENSOR_DEVICE_ATTR(temp3_min, S_IRUGO, show_temp_min,\n\t\t\t\tset_temp_min, 2);\nstatic SENSOR_DEVICE_ATTR(temp4_input, S_IRUGO, show_temp, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(temp4_max, S_IRUGO, show_temp_max,\n\t\t\t\tset_temp_max, 3);\nstatic SENSOR_DEVICE_ATTR(temp4_min, S_IRUGO, show_temp_min,\n\t\t\t\tset_temp_min, 3);\nstatic SENSOR_DEVICE_ATTR(temp5_input, S_IRUGO, show_temp, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(temp5_max, S_IRUGO, show_temp_max,\n\t\t\t\tset_temp_max, 4);\nstatic SENSOR_DEVICE_ATTR(temp5_min, S_IRUGO, show_temp_min,\n\t\t\t\tset_temp_min, 4);\n\nstatic SENSOR_DEVICE_ATTR(temp1_max_alarm, S_IRUGO, show_alarm, NULL, 14);\nstatic SENSOR_DEVICE_ATTR(temp1_min_alarm, S_IRUGO, show_alarm, NULL, 13);\nstatic SENSOR_DEVICE_ATTR(temp2_min_alarm, S_IRUGO, show_alarm, NULL, 7);\nstatic SENSOR_DEVICE_ATTR(temp2_max_alarm, S_IRUGO, show_alarm, NULL, 6);\nstatic SENSOR_DEVICE_ATTR(temp3_min_alarm, S_IRUGO, show_alarm, NULL, 5);\nstatic SENSOR_DEVICE_ATTR(temp3_max_alarm, S_IRUGO, show_alarm, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(temp4_min_alarm, S_IRUGO, show_alarm, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(temp4_max_alarm, S_IRUGO, show_alarm, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(temp5_min_alarm, S_IRUGO, show_alarm, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(temp5_max_alarm, S_IRUGO, show_alarm, NULL, 0);\n\nstatic SENSOR_DEVICE_ATTR(temp2_fault, S_IRUGO, show_fault, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(temp3_fault, S_IRUGO, show_fault, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(temp4_fault, S_IRUGO, show_fault, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(temp5_fault, S_IRUGO, show_fault, NULL, 4);\n\n \nstatic struct attribute *max1668_attribute_common[] = {\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp3_fault.dev_attr.attr,\n\tNULL\n};\n\n \nstatic struct attribute *max1668_attribute_unique[] = {\n\t&sensor_dev_attr_temp4_max.dev_attr.attr,\n\t&sensor_dev_attr_temp4_min.dev_attr.attr,\n\t&sensor_dev_attr_temp4_input.dev_attr.attr,\n\t&sensor_dev_attr_temp5_max.dev_attr.attr,\n\t&sensor_dev_attr_temp5_min.dev_attr.attr,\n\t&sensor_dev_attr_temp5_input.dev_attr.attr,\n\n\t&sensor_dev_attr_temp4_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp4_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp5_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp5_min_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_temp4_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp5_fault.dev_attr.attr,\n\tNULL\n};\n\nstatic umode_t max1668_attribute_mode(struct kobject *kobj,\n\t\t\t\t     struct attribute *attr, int index)\n{\n\tumode_t ret = S_IRUGO;\n\tif (read_only)\n\t\treturn ret;\n\tif (attr == &sensor_dev_attr_temp1_max.dev_attr.attr ||\n\t    attr == &sensor_dev_attr_temp2_max.dev_attr.attr ||\n\t    attr == &sensor_dev_attr_temp3_max.dev_attr.attr ||\n\t    attr == &sensor_dev_attr_temp4_max.dev_attr.attr ||\n\t    attr == &sensor_dev_attr_temp5_max.dev_attr.attr ||\n\t    attr == &sensor_dev_attr_temp1_min.dev_attr.attr ||\n\t    attr == &sensor_dev_attr_temp2_min.dev_attr.attr ||\n\t    attr == &sensor_dev_attr_temp3_min.dev_attr.attr ||\n\t    attr == &sensor_dev_attr_temp4_min.dev_attr.attr ||\n\t    attr == &sensor_dev_attr_temp5_min.dev_attr.attr)\n\t\tret |= S_IWUSR;\n\treturn ret;\n}\n\nstatic const struct attribute_group max1668_group_common = {\n\t.attrs = max1668_attribute_common,\n\t.is_visible = max1668_attribute_mode\n};\n\nstatic const struct attribute_group max1668_group_unique = {\n\t.attrs = max1668_attribute_unique,\n\t.is_visible = max1668_attribute_mode\n};\n\n \nstatic int max1668_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tconst char *type_name;\n\tint man_id, dev_id;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tman_id = i2c_smbus_read_byte_data(client, MAX1668_REG_MAN_ID);\n\tif (man_id != MAN_ID_MAXIM)\n\t\treturn -ENODEV;\n\n\tdev_id = i2c_smbus_read_byte_data(client, MAX1668_REG_DEV_ID);\n\tif (dev_id < 0)\n\t\treturn -ENODEV;\n\n\ttype_name = NULL;\n\tif (dev_id == DEV_ID_MAX1668)\n\t\ttype_name = \"max1668\";\n\telse if (dev_id == DEV_ID_MAX1805)\n\t\ttype_name = \"max1805\";\n\telse if (dev_id == DEV_ID_MAX1989)\n\t\ttype_name = \"max1989\";\n\n\tif (!type_name)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, type_name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max1668_id[];\n\nstatic int max1668_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct max1668_data *data;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(struct max1668_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tdata->type = i2c_match_id(max1668_id, client)->driver_data;\n\tmutex_init(&data->update_lock);\n\n\t \n\tdata->groups[0] = &max1668_group_common;\n\tif (data->type == max1668 || data->type == max1989)\n\t\tdata->groups[1] = &max1668_group_unique;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, data->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id max1668_id[] = {\n\t{ \"max1668\", max1668 },\n\t{ \"max1805\", max1805 },\n\t{ \"max1989\", max1989 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max1668_id);\n\n \nstatic struct i2c_driver max1668_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t  .name\t= \"max1668\",\n\t\t  },\n\t.probe = max1668_probe,\n\t.id_table = max1668_id,\n\t.detect\t= max1668_detect,\n\t.address_list = max1668_addr_list,\n};\n\nmodule_i2c_driver(max1668_driver);\n\nMODULE_AUTHOR(\"David George <david.george@ska.ac.za>\");\nMODULE_DESCRIPTION(\"MAX1668 remote temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}