{
  "module_name": "emc2103.c",
  "hash_id": "0f421c852820baa696c8f4f17a9d318d13010190d3bdfdfc4f1bd19a96200bde",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/emc2103.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x2E, I2C_CLIENT_END };\n\nstatic const u8 REG_TEMP[4] = { 0x00, 0x02, 0x04, 0x06 };\nstatic const u8 REG_TEMP_MIN[4] = { 0x3c, 0x38, 0x39, 0x3a };\nstatic const u8 REG_TEMP_MAX[4] = { 0x34, 0x30, 0x31, 0x32 };\n\n#define REG_CONF1\t\t0x20\n#define REG_TEMP_MAX_ALARM\t0x24\n#define REG_TEMP_MIN_ALARM\t0x25\n#define REG_FAN_CONF1\t\t0x42\n#define REG_FAN_TARGET_LO\t0x4c\n#define REG_FAN_TARGET_HI\t0x4d\n#define REG_FAN_TACH_HI\t\t0x4e\n#define REG_FAN_TACH_LO\t\t0x4f\n#define REG_PRODUCT_ID\t\t0xfd\n#define REG_MFG_ID\t\t0xfe\n\n \n#define FAN_RPM_FACTOR\t\t3932160\n\n \nstatic int apd = -1;\nmodule_param(apd, bint, 0);\nMODULE_PARM_DESC(apd, \"Set to zero to disable anti-parallel diode mode\");\n\nstruct temperature {\n\ts8\tdegrees;\n\tu8\tfraction;\t \n};\n\nstruct emc2103_data {\n\tstruct i2c_client\t*client;\n\tconst struct\t\tattribute_group *groups[4];\n\tstruct mutex\t\tupdate_lock;\n\tbool\t\t\tvalid;\t\t \n\tbool\t\t\tfan_rpm_control;\n\tint\t\t\ttemp_count;\t \n\tunsigned long\t\tlast_updated;\t \n\tstruct temperature\ttemp[4];\t \n\ts8\t\t\ttemp_min[4];\t \n\ts8\t\t\ttemp_max[4];     \n\tu8\t\t\ttemp_min_alarm;\n\tu8\t\t\ttemp_max_alarm;\n\tu8\t\t\tfan_multiplier;\n\tu16\t\t\tfan_tach;\n\tu16\t\t\tfan_target;\n};\n\nstatic int read_u8_from_i2c(struct i2c_client *client, u8 i2c_reg, u8 *output)\n{\n\tint status = i2c_smbus_read_byte_data(client, i2c_reg);\n\tif (status < 0) {\n\t\tdev_warn(&client->dev, \"reg 0x%02x, err %d\\n\",\n\t\t\ti2c_reg, status);\n\t} else {\n\t\t*output = status;\n\t}\n\treturn status;\n}\n\nstatic void read_temp_from_i2c(struct i2c_client *client, u8 i2c_reg,\n\t\t\t       struct temperature *temp)\n{\n\tu8 degrees, fractional;\n\n\tif (read_u8_from_i2c(client, i2c_reg, &degrees) < 0)\n\t\treturn;\n\n\tif (read_u8_from_i2c(client, i2c_reg + 1, &fractional) < 0)\n\t\treturn;\n\n\ttemp->degrees = degrees;\n\ttemp->fraction = (fractional & 0xe0) >> 5;\n}\n\nstatic void read_fan_from_i2c(struct i2c_client *client, u16 *output,\n\t\t\t      u8 hi_addr, u8 lo_addr)\n{\n\tu8 high_byte, lo_byte;\n\n\tif (read_u8_from_i2c(client, hi_addr, &high_byte) < 0)\n\t\treturn;\n\n\tif (read_u8_from_i2c(client, lo_addr, &lo_byte) < 0)\n\t\treturn;\n\n\t*output = ((u16)high_byte << 5) | (lo_byte >> 3);\n}\n\nstatic void write_fan_target_to_i2c(struct i2c_client *client, u16 new_target)\n{\n\tu8 high_byte = (new_target & 0x1fe0) >> 5;\n\tu8 low_byte = (new_target & 0x001f) << 3;\n\ti2c_smbus_write_byte_data(client, REG_FAN_TARGET_LO, low_byte);\n\ti2c_smbus_write_byte_data(client, REG_FAN_TARGET_HI, high_byte);\n}\n\nstatic void read_fan_config_from_i2c(struct i2c_client *client)\n\n{\n\tstruct emc2103_data *data = i2c_get_clientdata(client);\n\tu8 conf1;\n\n\tif (read_u8_from_i2c(client, REG_FAN_CONF1, &conf1) < 0)\n\t\treturn;\n\n\tdata->fan_multiplier = 1 << ((conf1 & 0x60) >> 5);\n\tdata->fan_rpm_control = (conf1 & 0x80) != 0;\n}\n\nstatic struct emc2103_data *emc2103_update_device(struct device *dev)\n{\n\tstruct emc2103_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\n\t    || !data->valid) {\n\t\tint i;\n\n\t\tfor (i = 0; i < data->temp_count; i++) {\n\t\t\tread_temp_from_i2c(client, REG_TEMP[i], &data->temp[i]);\n\t\t\tread_u8_from_i2c(client, REG_TEMP_MIN[i],\n\t\t\t\t&data->temp_min[i]);\n\t\t\tread_u8_from_i2c(client, REG_TEMP_MAX[i],\n\t\t\t\t&data->temp_max[i]);\n\t\t}\n\n\t\tread_u8_from_i2c(client, REG_TEMP_MIN_ALARM,\n\t\t\t&data->temp_min_alarm);\n\t\tread_u8_from_i2c(client, REG_TEMP_MAX_ALARM,\n\t\t\t&data->temp_max_alarm);\n\n\t\tread_fan_from_i2c(client, &data->fan_tach,\n\t\t\tREG_FAN_TACH_HI, REG_FAN_TACH_LO);\n\t\tread_fan_from_i2c(client, &data->fan_target,\n\t\t\tREG_FAN_TARGET_HI, REG_FAN_TARGET_LO);\n\t\tread_fan_config_from_i2c(client);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\nstatic ssize_t\ntemp_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\tint millidegrees = data->temp[nr].degrees * 1000\n\t\t+ data->temp[nr].fraction * 125;\n\treturn sprintf(buf, \"%d\\n\", millidegrees);\n}\n\nstatic ssize_t\ntemp_min_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\tint millidegrees = data->temp_min[nr] * 1000;\n\treturn sprintf(buf, \"%d\\n\", millidegrees);\n}\n\nstatic ssize_t\ntemp_max_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\tint millidegrees = data->temp_max[nr] * 1000;\n\treturn sprintf(buf, \"%d\\n\", millidegrees);\n}\n\nstatic ssize_t\ntemp_fault_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\tbool fault = (data->temp[nr].degrees == -128);\n\treturn sprintf(buf, \"%d\\n\", fault ? 1 : 0);\n}\n\nstatic ssize_t\ntemp_min_alarm_show(struct device *dev, struct device_attribute *da,\n\t\t    char *buf)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\tbool alarm = data->temp_min_alarm & (1 << nr);\n\treturn sprintf(buf, \"%d\\n\", alarm ? 1 : 0);\n}\n\nstatic ssize_t\ntemp_max_alarm_show(struct device *dev, struct device_attribute *da,\n\t\t    char *buf)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\tbool alarm = data->temp_max_alarm & (1 << nr);\n\treturn sprintf(buf, \"%d\\n\", alarm ? 1 : 0);\n}\n\nstatic ssize_t temp_min_store(struct device *dev, struct device_attribute *da,\n\t\t\t      const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct emc2103_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\n\tint result = kstrtol(buf, 10, &val);\n\tif (result < 0)\n\t\treturn result;\n\n\tval = DIV_ROUND_CLOSEST(clamp_val(val, -63000, 127000), 1000);\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_min[nr] = val;\n\ti2c_smbus_write_byte_data(client, REG_TEMP_MIN[nr], val);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t temp_max_store(struct device *dev, struct device_attribute *da,\n\t\t\t      const char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(da)->index;\n\tstruct emc2103_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\n\tint result = kstrtol(buf, 10, &val);\n\tif (result < 0)\n\t\treturn result;\n\n\tval = DIV_ROUND_CLOSEST(clamp_val(val, -63000, 127000), 1000);\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_max[nr] = val;\n\ti2c_smbus_write_byte_data(client, REG_TEMP_MAX[nr], val);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\nfan1_input_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\tint rpm = 0;\n\tif (data->fan_tach != 0)\n\t\trpm = (FAN_RPM_FACTOR * data->fan_multiplier) / data->fan_tach;\n\treturn sprintf(buf, \"%d\\n\", rpm);\n}\n\nstatic ssize_t\nfan1_div_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\tint fan_div = 8 / data->fan_multiplier;\n\treturn sprintf(buf, \"%d\\n\", fan_div);\n}\n\n \nstatic ssize_t fan1_div_store(struct device *dev, struct device_attribute *da,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\tstruct i2c_client *client = data->client;\n\tint new_range_bits, old_div = 8 / data->fan_multiplier;\n\tlong new_div;\n\n\tint status = kstrtol(buf, 10, &new_div);\n\tif (status < 0)\n\t\treturn status;\n\n\tif (new_div == old_div)  \n\t\treturn count;\n\n\tswitch (new_div) {\n\tcase 1:\n\t\tnew_range_bits = 3;\n\t\tbreak;\n\tcase 2:\n\t\tnew_range_bits = 2;\n\t\tbreak;\n\tcase 4:\n\t\tnew_range_bits = 1;\n\t\tbreak;\n\tcase 8:\n\t\tnew_range_bits = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&data->update_lock);\n\n\tstatus = i2c_smbus_read_byte_data(client, REG_FAN_CONF1);\n\tif (status < 0) {\n\t\tdev_dbg(&client->dev, \"reg 0x%02x, err %d\\n\",\n\t\t\tREG_FAN_CONF1, status);\n\t\tmutex_unlock(&data->update_lock);\n\t\treturn status;\n\t}\n\tstatus &= 0x9F;\n\tstatus |= (new_range_bits << 5);\n\ti2c_smbus_write_byte_data(client, REG_FAN_CONF1, status);\n\n\tdata->fan_multiplier = 8 / new_div;\n\n\t \n\tif ((data->fan_target & 0x1fe0) != 0x1fe0) {\n\t\tu16 new_target = (data->fan_target * old_div) / new_div;\n\t\tdata->fan_target = min(new_target, (u16)0x1fff);\n\t\twrite_fan_target_to_i2c(client, data->fan_target);\n\t}\n\n\t \n\tdata->valid = false;\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\nfan1_target_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\tint rpm = 0;\n\n\t \n\tif ((data->fan_target != 0) && ((data->fan_target & 0x1fe0) != 0x1fe0))\n\t\trpm = (FAN_RPM_FACTOR * data->fan_multiplier)\n\t\t\t/ data->fan_target;\n\n\treturn sprintf(buf, \"%d\\n\", rpm);\n}\n\nstatic ssize_t fan1_target_store(struct device *dev,\n\t\t\t\t struct device_attribute *da, const char *buf,\n\t\t\t\t size_t count)\n{\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long rpm_target;\n\n\tint result = kstrtoul(buf, 10, &rpm_target);\n\tif (result < 0)\n\t\treturn result;\n\n\t \n\trpm_target = clamp_val(rpm_target, 0, 16384);\n\n\tmutex_lock(&data->update_lock);\n\n\tif (rpm_target == 0)\n\t\tdata->fan_target = 0x1fff;\n\telse\n\t\tdata->fan_target = clamp_val(\n\t\t\t(FAN_RPM_FACTOR * data->fan_multiplier) / rpm_target,\n\t\t\t0, 0x1fff);\n\n\twrite_fan_target_to_i2c(client, data->fan_target);\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\nfan1_fault_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\tbool fault = ((data->fan_tach & 0x1fe0) == 0x1fe0);\n\treturn sprintf(buf, \"%d\\n\", fault ? 1 : 0);\n}\n\nstatic ssize_t\npwm1_enable_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\tstruct emc2103_data *data = emc2103_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->fan_rpm_control ? 3 : 0);\n}\n\nstatic ssize_t pwm1_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *da, const char *buf,\n\t\t\t\t size_t count)\n{\n\tstruct emc2103_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong new_value;\n\tu8 conf_reg;\n\n\tint result = kstrtol(buf, 10, &new_value);\n\tif (result < 0)\n\t\treturn result;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (new_value) {\n\tcase 0:\n\t\tdata->fan_rpm_control = false;\n\t\tbreak;\n\tcase 3:\n\t\tdata->fan_rpm_control = true;\n\t\tbreak;\n\tdefault:\n\t\tcount = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tresult = read_u8_from_i2c(client, REG_FAN_CONF1, &conf_reg);\n\tif (result < 0) {\n\t\tcount = result;\n\t\tgoto err;\n\t}\n\n\tif (data->fan_rpm_control)\n\t\tconf_reg |= 0x80;\n\telse\n\t\tconf_reg &= ~0x80;\n\n\ti2c_smbus_write_byte_data(client, REG_FAN_CONF1, conf_reg);\nerr:\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp_max, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_fault, temp_fault, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_alarm, temp_min_alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, temp_max_alarm, 0);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_min, temp_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp_max, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_fault, temp_fault, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_min_alarm, temp_min_alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_max_alarm, temp_max_alarm, 1);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_min, temp_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_max, temp_max, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_fault, temp_fault, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_min_alarm, temp_min_alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_max_alarm, temp_max_alarm, 2);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp4_input, temp, 3);\nstatic SENSOR_DEVICE_ATTR_RW(temp4_min, temp_min, 3);\nstatic SENSOR_DEVICE_ATTR_RW(temp4_max, temp_max, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_fault, temp_fault, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_min_alarm, temp_min_alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_max_alarm, temp_max_alarm, 3);\n\nstatic DEVICE_ATTR_RO(fan1_input);\nstatic DEVICE_ATTR_RW(fan1_div);\nstatic DEVICE_ATTR_RW(fan1_target);\nstatic DEVICE_ATTR_RO(fan1_fault);\n\nstatic DEVICE_ATTR_RW(pwm1_enable);\n\n \nstatic struct attribute *emc2103_attributes[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,\n\t&dev_attr_fan1_input.attr,\n\t&dev_attr_fan1_div.attr,\n\t&dev_attr_fan1_target.attr,\n\t&dev_attr_fan1_fault.attr,\n\t&dev_attr_pwm1_enable.attr,\n\tNULL\n};\n\n \nstatic struct attribute *emc2103_attributes_temp3[] = {\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max_alarm.dev_attr.attr,\n\tNULL\n};\n\n \nstatic struct attribute *emc2103_attributes_temp4[] = {\n\t&sensor_dev_attr_temp4_input.dev_attr.attr,\n\t&sensor_dev_attr_temp4_min.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max.dev_attr.attr,\n\t&sensor_dev_attr_temp4_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp4_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group emc2103_group = {\n\t.attrs = emc2103_attributes,\n};\n\nstatic const struct attribute_group emc2103_temp3_group = {\n\t.attrs = emc2103_attributes_temp3,\n};\n\nstatic const struct attribute_group emc2103_temp4_group = {\n\t.attrs = emc2103_attributes_temp4,\n};\n\nstatic int\nemc2103_probe(struct i2c_client *client)\n{\n\tstruct emc2103_data *data;\n\tstruct device *hwmon_dev;\n\tint status, idx = 0;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct emc2103_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tstatus = i2c_smbus_read_byte_data(client, REG_PRODUCT_ID);\n\tif (status == 0x24) {\n\t\t \n\t\tdata->temp_count = 2;\n\t} else {\n\t\t \n\t\tstatus = i2c_smbus_read_byte_data(client, REG_CONF1);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&client->dev, \"reg 0x%02x, err %d\\n\", REG_CONF1,\n\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\n\t\t \n\t\tdata->temp_count = (status & 0x01) ? 4 : 3;\n\n\t\t \n\t\tif (apd == 0) {\n\t\t\t \n\t\t\tdata->temp_count = 3;\n\t\t\tstatus &= ~(0x01);\n\t\t\ti2c_smbus_write_byte_data(client, REG_CONF1, status);\n\t\t} else if (apd == 1) {\n\t\t\t \n\t\t\tdata->temp_count = 4;\n\t\t\tstatus |= 0x01;\n\t\t\ti2c_smbus_write_byte_data(client, REG_CONF1, status);\n\t\t}\n\t}\n\n\t \n\tdata->groups[idx++] = &emc2103_group;\n\tif (data->temp_count >= 3)\n\t\tdata->groups[idx++] = &emc2103_temp3_group;\n\tif (data->temp_count == 4)\n\t\tdata->groups[idx++] = &emc2103_temp4_group;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(&client->dev,\n\t\t\t\t\t\t\t   client->name, data,\n\t\t\t\t\t\t\t   data->groups);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdev_info(&client->dev, \"%s: sensor '%s'\\n\",\n\t\t dev_name(hwmon_dev), client->name);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id emc2103_ids[] = {\n\t{ \"emc2103\", 0, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, emc2103_ids);\n\n \nstatic int\nemc2103_detect(struct i2c_client *new_client, struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = new_client->adapter;\n\tint manufacturer, product;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tmanufacturer = i2c_smbus_read_byte_data(new_client, REG_MFG_ID);\n\tif (manufacturer != 0x5D)\n\t\treturn -ENODEV;\n\n\tproduct = i2c_smbus_read_byte_data(new_client, REG_PRODUCT_ID);\n\tif ((product != 0x24) && (product != 0x26))\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"emc2103\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic struct i2c_driver emc2103_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"emc2103\",\n\t},\n\t.probe\t\t= emc2103_probe,\n\t.id_table\t= emc2103_ids,\n\t.detect\t\t= emc2103_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(emc2103_driver);\n\nMODULE_AUTHOR(\"Steve Glendinning <steve.glendinning@shawell.net>\");\nMODULE_DESCRIPTION(\"SMSC EMC2103 hwmon driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}