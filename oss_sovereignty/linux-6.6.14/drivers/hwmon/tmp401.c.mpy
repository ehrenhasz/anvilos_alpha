{
  "module_name": "tmp401.c",
  "hash_id": "a3cff6278b2b904b305051700781c68139399d0519653ba49fa2666498a3cfea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/tmp401.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x48, 0x49, 0x4a, 0x4c, 0x4d,\n\t0x4e, 0x4f, I2C_CLIENT_END };\n\nenum chips { tmp401, tmp411, tmp431, tmp432, tmp435 };\n\n \n#define TMP401_STATUS\t\t\t\t0x02\n#define TMP401_CONFIG\t\t\t\t0x03\n#define TMP401_CONVERSION_RATE\t\t\t0x04\n#define TMP4XX_N_FACTOR_REG\t\t\t0x18\n#define TMP43X_BETA_RANGE\t\t\t0x25\n#define TMP401_TEMP_CRIT_HYST\t\t\t0x21\n#define TMP401_MANUFACTURER_ID_REG\t\t0xFE\n#define TMP401_DEVICE_ID_REG\t\t\t0xFF\n\nstatic const u8 TMP401_TEMP_MSB[7][3] = {\n\t{ 0x00, 0x01, 0x23 },\t \n\t{ 0x06, 0x08, 0x16 },\t \n\t{ 0x05, 0x07, 0x15 },\t \n\t{ 0x20, 0x19, 0x1a },\t \n\t{ 0x30, 0x34, 0x00 },\t \n\t{ 0x32, 0xf6, 0x00 },\t \n};\n\n \nstatic const u8 TMP432_STATUS_REG[] = {\n\t0x1b, 0x36, 0x35, 0x37 };\n\n \n#define TMP401_CONFIG_RANGE\t\t\tBIT(2)\n#define TMP401_CONFIG_SHUTDOWN\t\t\tBIT(6)\n#define TMP401_STATUS_LOCAL_CRIT\t\tBIT(0)\n#define TMP401_STATUS_REMOTE_CRIT\t\tBIT(1)\n#define TMP401_STATUS_REMOTE_OPEN\t\tBIT(2)\n#define TMP401_STATUS_REMOTE_LOW\t\tBIT(3)\n#define TMP401_STATUS_REMOTE_HIGH\t\tBIT(4)\n#define TMP401_STATUS_LOCAL_LOW\t\t\tBIT(5)\n#define TMP401_STATUS_LOCAL_HIGH\t\tBIT(6)\n\n \n#define TMP432_STATUS_LOCAL\t\t\tBIT(0)\n#define TMP432_STATUS_REMOTE1\t\t\tBIT(1)\n#define TMP432_STATUS_REMOTE2\t\t\tBIT(2)\n\n \n#define TMP401_MANUFACTURER_ID\t\t\t0x55\n#define TMP401_DEVICE_ID\t\t\t0x11\n#define TMP411A_DEVICE_ID\t\t\t0x12\n#define TMP411B_DEVICE_ID\t\t\t0x13\n#define TMP411C_DEVICE_ID\t\t\t0x10\n#define TMP431_DEVICE_ID\t\t\t0x31\n#define TMP432_DEVICE_ID\t\t\t0x32\n#define TMP435_DEVICE_ID\t\t\t0x35\n\n \n\nstatic const struct i2c_device_id tmp401_id[] = {\n\t{ \"tmp401\", tmp401 },\n\t{ \"tmp411\", tmp411 },\n\t{ \"tmp431\", tmp431 },\n\t{ \"tmp432\", tmp432 },\n\t{ \"tmp435\", tmp435 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tmp401_id);\n\n \n\nstruct tmp401_data {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct mutex update_lock;\n\tenum chips kind;\n\n\tbool extended_range;\n\n\t \n\tu32 chip_channel_config[4];\n\tstruct hwmon_channel_info chip_info;\n\tu32 temp_channel_config[4];\n\tstruct hwmon_channel_info temp_info;\n\tconst struct hwmon_channel_info *info[3];\n\tstruct hwmon_chip_info chip;\n};\n\n \n\nstatic bool tmp401_regmap_is_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0:\t\t\t \n\tcase 1:\t\t\t \n\tcase 2:\t\t\t \n\tcase 0x10:\t\t \n\tcase 0x15:\t\t \n\tcase 0x1b:\t\t \n\tcase 0x23 ... 0x24:\t \n\tcase 0x30 ... 0x37:\t \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int tmp401_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct tmp401_data *data = context;\n\tstruct i2c_client *client = data->client;\n\tint regval;\n\n\tswitch (reg) {\n\tcase 0:\t\t\t \n\tcase 1:\t\t\t \n\tcase 5:\t\t\t \n\tcase 6:\t\t\t \n\tcase 7:\t\t\t \n\tcase 8:\t\t\t \n\tcase 0x15:\t\t \n\tcase 0x16:\t\t \n\tcase 0x23:\t\t \n\tcase 0x30:\t\t \n\tcase 0x32:\t\t \n\tcase 0x34:\t\t \n\tcase 0xf6:\t\t \n\t\t \n\t\tif (reg == 0xf6)\n\t\t\treg = 0x36;\n\t\tregval = i2c_smbus_read_word_swapped(client, reg);\n\t\tif (regval < 0)\n\t\t\treturn regval;\n\t\t*val = regval;\n\t\tbreak;\n\tcase 0x19:\t\t \n\tcase 0x1a:\n\tcase 0x20:\n\t\tregval = i2c_smbus_read_byte_data(client, reg);\n\t\tif (regval < 0)\n\t\t\treturn regval;\n\t\t*val = regval << 8;\n\t\tbreak;\n\tcase 0x1b:\n\tcase 0x35 ... 0x37:\n\t\tif (data->kind == tmp432) {\n\t\t\tregval = i2c_smbus_read_byte_data(client, reg);\n\t\t\tif (regval < 0)\n\t\t\t\treturn regval;\n\t\t\t*val = regval;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tregval = i2c_smbus_read_byte_data(client, TMP401_STATUS);\n\t\tif (regval < 0)\n\t\t\treturn regval;\n\t\t*val = 0;\n\t\tswitch (reg) {\n\t\tcase 0x1b:\t \n\t\t\tif (regval & TMP401_STATUS_REMOTE_OPEN)\n\t\t\t\t*val |= BIT(1);\n\t\t\tbreak;\n\t\tcase 0x35:\t \n\t\t\tif (regval & TMP401_STATUS_LOCAL_HIGH)\n\t\t\t\t*val |= BIT(0);\n\t\t\tif (regval & TMP401_STATUS_REMOTE_HIGH)\n\t\t\t\t*val |= BIT(1);\n\t\t\tbreak;\n\t\tcase 0x36:\t \n\t\t\tif (regval & TMP401_STATUS_LOCAL_LOW)\n\t\t\t\t*val |= BIT(0);\n\t\t\tif (regval & TMP401_STATUS_REMOTE_LOW)\n\t\t\t\t*val |= BIT(1);\n\t\t\tbreak;\n\t\tcase 0x37:\t \n\t\t\tif (regval & TMP401_STATUS_LOCAL_CRIT)\n\t\t\t\t*val |= BIT(0);\n\t\t\tif (regval & TMP401_STATUS_REMOTE_CRIT)\n\t\t\t\t*val |= BIT(1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tregval = i2c_smbus_read_byte_data(client, reg);\n\t\tif (regval < 0)\n\t\t\treturn regval;\n\t\t*val = regval;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int tmp401_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct tmp401_data *data = context;\n\tstruct i2c_client *client = data->client;\n\n\tswitch (reg) {\n\tcase 0x05:\t\t \n\tcase 0x06:\t\t \n\tcase 0x07:\t\t \n\tcase 0x08:\t\t \n\t\treg += 6;\t \n\t\tfallthrough;\n\tcase 0x15:\t\t \n\tcase 0x16:\t\t \n\t\treturn i2c_smbus_write_word_swapped(client, reg, val);\n\tcase 0x19:\t\t \n\tcase 0x1a:\n\tcase 0x20:\n\t\treturn i2c_smbus_write_byte_data(client, reg, val >> 8);\n\tcase TMP401_CONVERSION_RATE:\n\tcase TMP401_CONFIG:\n\t\treg += 6;\t \n\t\tfallthrough;\n\tdefault:\n\t\treturn i2c_smbus_write_byte_data(client, reg, val);\n\t}\n}\n\nstatic const struct regmap_config tmp401_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = tmp401_regmap_is_volatile,\n\t.reg_read = tmp401_reg_read,\n\t.reg_write = tmp401_reg_write,\n};\n\n \n\nstatic int tmp401_register_to_temp(u16 reg, bool extended)\n{\n\tint temp = reg;\n\n\tif (extended)\n\t\ttemp -= 64 * 256;\n\n\treturn DIV_ROUND_CLOSEST(temp * 125, 32);\n}\n\nstatic u16 tmp401_temp_to_register(long temp, bool extended, int zbits)\n{\n\tif (extended) {\n\t\ttemp = clamp_val(temp, -64000, 191000);\n\t\ttemp += 64000;\n\t} else {\n\t\ttemp = clamp_val(temp, 0, 127000);\n\t}\n\n\treturn DIV_ROUND_CLOSEST(temp * (1 << (8 - zbits)), 1000) << zbits;\n}\n\n \n\nstatic const u8 tmp401_temp_reg_index[] = {\n\t[hwmon_temp_input] = 0,\n\t[hwmon_temp_min] = 1,\n\t[hwmon_temp_max] = 2,\n\t[hwmon_temp_crit] = 3,\n\t[hwmon_temp_lowest] = 4,\n\t[hwmon_temp_highest] = 5,\n};\n\nstatic const u8 tmp401_status_reg_index[] = {\n\t[hwmon_temp_fault] = 0,\n\t[hwmon_temp_min_alarm] = 1,\n\t[hwmon_temp_max_alarm] = 2,\n\t[hwmon_temp_crit_alarm] = 3,\n};\n\nstatic int tmp401_temp_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct tmp401_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int regval;\n\tint reg, ret;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_min:\n\tcase hwmon_temp_max:\n\tcase hwmon_temp_crit:\n\tcase hwmon_temp_lowest:\n\tcase hwmon_temp_highest:\n\t\treg = TMP401_TEMP_MSB[tmp401_temp_reg_index[attr]][channel];\n\t\tret = regmap_read(regmap, reg, &regval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = tmp401_register_to_temp(regval, data->extended_range);\n\t\tbreak;\n\tcase hwmon_temp_crit_hyst:\n\t\tmutex_lock(&data->update_lock);\n\t\treg = TMP401_TEMP_MSB[3][channel];\n\t\tret = regmap_read(regmap, reg, &regval);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t\t*val = tmp401_register_to_temp(regval, data->extended_range);\n\t\tret = regmap_read(regmap, TMP401_TEMP_CRIT_HYST, &regval);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t\t*val -= regval * 1000;\nunlock:\n\t\tmutex_unlock(&data->update_lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase hwmon_temp_fault:\n\tcase hwmon_temp_min_alarm:\n\tcase hwmon_temp_max_alarm:\n\tcase hwmon_temp_crit_alarm:\n\t\treg = TMP432_STATUS_REG[tmp401_status_reg_index[attr]];\n\t\tret = regmap_read(regmap, reg, &regval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = !!(regval & BIT(channel));\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int tmp401_temp_write(struct device *dev, u32 attr, int channel,\n\t\t\t     long val)\n{\n\tstruct tmp401_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int regval;\n\tint reg, ret, temp;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (attr) {\n\tcase hwmon_temp_min:\n\tcase hwmon_temp_max:\n\tcase hwmon_temp_crit:\n\t\treg = TMP401_TEMP_MSB[tmp401_temp_reg_index[attr]][channel];\n\t\tregval = tmp401_temp_to_register(val, data->extended_range,\n\t\t\t\t\t\t attr == hwmon_temp_crit ? 8 : 4);\n\t\tret = regmap_write(regmap, reg, regval);\n\t\tbreak;\n\tcase hwmon_temp_crit_hyst:\n\t\tif (data->extended_range)\n\t\t\tval = clamp_val(val, -64000, 191000);\n\t\telse\n\t\t\tval = clamp_val(val, 0, 127000);\n\n\t\treg = TMP401_TEMP_MSB[3][channel];\n\t\tret = regmap_read(regmap, reg, &regval);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\ttemp = tmp401_register_to_temp(regval, data->extended_range);\n\t\tval = clamp_val(val, temp - 255000, temp);\n\t\tregval = ((temp - val) + 500) / 1000;\n\t\tret = regmap_write(regmap, TMP401_TEMP_CRIT_HYST, regval);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic int tmp401_chip_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct tmp401_data *data = dev_get_drvdata(dev);\n\tu32 regval;\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\tret = regmap_read(data->regmap, TMP401_CONVERSION_RATE, &regval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = (1 << (7 - regval)) * 125;\n\t\tbreak;\n\tcase hwmon_chip_temp_reset_history:\n\t\t*val = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int tmp401_set_convrate(struct regmap *regmap, long val)\n{\n\tint rate;\n\n\t \n\tval = clamp_val(val, 125, 16000);\n\trate = 7 - __fls(val * 4 / (125 * 3));\n\treturn regmap_write(regmap, TMP401_CONVERSION_RATE, rate);\n}\n\nstatic int tmp401_chip_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct tmp401_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tint err;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\terr = tmp401_set_convrate(regmap, val);\n\t\tbreak;\n\tcase hwmon_chip_temp_reset_history:\n\t\tif (val != 1) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\terr = regmap_write(regmap, 0x30, 0);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn err;\n}\n\nstatic int tmp401_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn tmp401_chip_read(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn tmp401_temp_read(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int tmp401_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn tmp401_chip_write(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn tmp401_temp_write(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t tmp401_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\tcase hwmon_chip_temp_reset_history:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_min_alarm:\n\t\tcase hwmon_temp_max_alarm:\n\t\tcase hwmon_temp_crit_alarm:\n\t\tcase hwmon_temp_fault:\n\t\tcase hwmon_temp_lowest:\n\t\tcase hwmon_temp_highest:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_min:\n\t\tcase hwmon_temp_max:\n\t\tcase hwmon_temp_crit:\n\t\tcase hwmon_temp_crit_hyst:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_ops tmp401_ops = {\n\t.is_visible = tmp401_is_visible,\n\t.read = tmp401_read,\n\t.write = tmp401_write,\n};\n\n \n\nstatic int tmp401_init_client(struct tmp401_data *data)\n{\n\tstruct regmap *regmap = data->regmap;\n\tu32 config, config_orig;\n\tint ret;\n\tu32 val = 0;\n\ts32 nfactor = 0;\n\n\t \n\tret = regmap_write(regmap, TMP401_CONVERSION_RATE, 5);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(regmap, TMP401_CONFIG, &config);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tconfig_orig = config;\n\tconfig &= ~TMP401_CONFIG_SHUTDOWN;\n\n\tif (of_property_read_bool(data->client->dev.of_node, \"ti,extended-range-enable\")) {\n\t\t \n\t\tconfig |= TMP401_CONFIG_RANGE;\n\t}\n\n\tdata->extended_range = !!(config & TMP401_CONFIG_RANGE);\n\n\tif (config != config_orig) {\n\t\tret = regmap_write(regmap, TMP401_CONFIG, config);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(data->client->dev.of_node, \"ti,n-factor\", &nfactor);\n\tif (!ret) {\n\t\tif (data->kind == tmp401) {\n\t\t\tdev_err(&data->client->dev, \"ti,tmp401 does not support n-factor correction\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nfactor < -128 || nfactor > 127) {\n\t\t\tdev_err(&data->client->dev, \"n-factor is invalid (%d)\\n\", nfactor);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = regmap_write(regmap, TMP4XX_N_FACTOR_REG, (unsigned int)nfactor);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(data->client->dev.of_node, \"ti,beta-compensation\", &val);\n\tif (!ret) {\n\t\tif (data->kind == tmp401 || data->kind == tmp411) {\n\t\t\tdev_err(&data->client->dev, \"ti,tmp401 or ti,tmp411 does not support beta compensation\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val > 15) {\n\t\t\tdev_err(&data->client->dev, \"beta-compensation is invalid (%u)\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = regmap_write(regmap, TMP43X_BETA_RANGE, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tmp401_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info)\n{\n\tenum chips kind;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tu8 reg;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\treg = i2c_smbus_read_byte_data(client, TMP401_MANUFACTURER_ID_REG);\n\tif (reg != TMP401_MANUFACTURER_ID)\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_byte_data(client, TMP401_DEVICE_ID_REG);\n\n\tswitch (reg) {\n\tcase TMP401_DEVICE_ID:\n\t\tif (client->addr != 0x4c)\n\t\t\treturn -ENODEV;\n\t\tkind = tmp401;\n\t\tbreak;\n\tcase TMP411A_DEVICE_ID:\n\t\tif (client->addr != 0x4c)\n\t\t\treturn -ENODEV;\n\t\tkind = tmp411;\n\t\tbreak;\n\tcase TMP411B_DEVICE_ID:\n\t\tif (client->addr != 0x4d)\n\t\t\treturn -ENODEV;\n\t\tkind = tmp411;\n\t\tbreak;\n\tcase TMP411C_DEVICE_ID:\n\t\tif (client->addr != 0x4e)\n\t\t\treturn -ENODEV;\n\t\tkind = tmp411;\n\t\tbreak;\n\tcase TMP431_DEVICE_ID:\n\t\tif (client->addr != 0x4c && client->addr != 0x4d)\n\t\t\treturn -ENODEV;\n\t\tkind = tmp431;\n\t\tbreak;\n\tcase TMP432_DEVICE_ID:\n\t\tif (client->addr != 0x4c && client->addr != 0x4d)\n\t\t\treturn -ENODEV;\n\t\tkind = tmp432;\n\t\tbreak;\n\tcase TMP435_DEVICE_ID:\n\t\tkind = tmp435;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\treg = i2c_smbus_read_byte_data(client, TMP401_CONFIG);\n\tif (reg & 0x1b)\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_byte_data(client, TMP401_CONVERSION_RATE);\n\t \n\tif (reg > 15)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, tmp401_id[kind].name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int tmp401_probe(struct i2c_client *client)\n{\n\tstatic const char * const names[] = {\n\t\t\"TMP401\", \"TMP411\", \"TMP431\", \"TMP432\", \"TMP435\"\n\t};\n\tstruct device *dev = &client->dev;\n\tstruct hwmon_channel_info *info;\n\tstruct device *hwmon_dev;\n\tstruct tmp401_data *data;\n\tint status;\n\n\tdata = devm_kzalloc(dev, sizeof(struct tmp401_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\tdata->kind = i2c_match_id(tmp401_id, client)->driver_data;\n\n\tdata->regmap = devm_regmap_init(dev, NULL, data, &tmp401_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\t \n\tdata->chip.ops = &tmp401_ops;\n\tdata->chip.info = data->info;\n\n\tdata->info[0] = &data->chip_info;\n\tdata->info[1] = &data->temp_info;\n\n\tinfo = &data->chip_info;\n\tinfo->type = hwmon_chip;\n\tinfo->config = data->chip_channel_config;\n\n\tdata->chip_channel_config[0] = HWMON_C_UPDATE_INTERVAL;\n\n\tinfo = &data->temp_info;\n\tinfo->type = hwmon_temp;\n\tinfo->config = data->temp_channel_config;\n\n\tdata->temp_channel_config[0] = HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |\n\t\tHWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MIN_ALARM |\n\t\tHWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM;\n\tdata->temp_channel_config[1] = HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |\n\t\tHWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MIN_ALARM |\n\t\tHWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM | HWMON_T_FAULT;\n\n\tif (data->kind == tmp411) {\n\t\tdata->temp_channel_config[0] |= HWMON_T_HIGHEST | HWMON_T_LOWEST;\n\t\tdata->temp_channel_config[1] |= HWMON_T_HIGHEST | HWMON_T_LOWEST;\n\t\tdata->chip_channel_config[0] |= HWMON_C_TEMP_RESET_HISTORY;\n\t}\n\n\tif (data->kind == tmp432) {\n\t\tdata->temp_channel_config[2] = HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |\n\t\t\tHWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MIN_ALARM |\n\t\t\tHWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM | HWMON_T_FAULT;\n\t}\n\n\t \n\tstatus = tmp401_init_client(data);\n\tif (status < 0)\n\t\treturn status;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name, data,\n\t\t\t\t\t\t\t &data->chip, NULL);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdev_info(dev, \"Detected TI %s chip\\n\", names[data->kind]);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused tmp4xx_of_match[] = {\n\t{ .compatible = \"ti,tmp401\", },\n\t{ .compatible = \"ti,tmp411\", },\n\t{ .compatible = \"ti,tmp431\", },\n\t{ .compatible = \"ti,tmp432\", },\n\t{ .compatible = \"ti,tmp435\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tmp4xx_of_match);\n\nstatic struct i2c_driver tmp401_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"tmp401\",\n\t\t.of_match_table = of_match_ptr(tmp4xx_of_match),\n\t},\n\t.probe\t\t= tmp401_probe,\n\t.id_table\t= tmp401_id,\n\t.detect\t\t= tmp401_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(tmp401_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments TMP401 temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}