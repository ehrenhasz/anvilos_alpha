{
  "module_name": "common.c",
  "hash_id": "b4d847fd7872606dbd9a34ff1d4be6c31291c2c613fd7bbe5c56c135ada577f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/occ/common.c",
  "human_readable_source": "\n\n\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/sysfs.h>\n#include <asm/unaligned.h>\n\n#include \"common.h\"\n\n#define EXTN_FLAG_SENSOR_ID\t\tBIT(7)\n\n#define OCC_ERROR_COUNT_THRESHOLD\t2\t \n\n#define OCC_STATE_SAFE\t\t\t4\n#define OCC_SAFE_TIMEOUT\t\tmsecs_to_jiffies(60000)  \n\n#define OCC_UPDATE_FREQUENCY\t\tmsecs_to_jiffies(1000)\n\n#define OCC_TEMP_SENSOR_FAULT\t\t0xFF\n\n#define OCC_FRU_TYPE_VRM\t\t3\n\n \n\nstruct temp_sensor_1 {\n\tu16 sensor_id;\n\tu16 value;\n} __packed;\n\nstruct temp_sensor_2 {\n\tu32 sensor_id;\n\tu8 fru_type;\n\tu8 value;\n} __packed;\n\nstruct temp_sensor_10 {\n\tu32 sensor_id;\n\tu8 fru_type;\n\tu8 value;\n\tu8 throttle;\n\tu8 reserved;\n} __packed;\n\nstruct freq_sensor_1 {\n\tu16 sensor_id;\n\tu16 value;\n} __packed;\n\nstruct freq_sensor_2 {\n\tu32 sensor_id;\n\tu16 value;\n} __packed;\n\nstruct power_sensor_1 {\n\tu16 sensor_id;\n\tu32 update_tag;\n\tu32 accumulator;\n\tu16 value;\n} __packed;\n\nstruct power_sensor_2 {\n\tu32 sensor_id;\n\tu8 function_id;\n\tu8 apss_channel;\n\tu16 reserved;\n\tu32 update_tag;\n\tu64 accumulator;\n\tu16 value;\n} __packed;\n\nstruct power_sensor_data {\n\tu16 value;\n\tu32 update_tag;\n\tu64 accumulator;\n} __packed;\n\nstruct power_sensor_data_and_time {\n\tu16 update_time;\n\tu16 value;\n\tu32 update_tag;\n\tu64 accumulator;\n} __packed;\n\nstruct power_sensor_a0 {\n\tu32 sensor_id;\n\tstruct power_sensor_data_and_time system;\n\tu32 reserved;\n\tstruct power_sensor_data_and_time proc;\n\tstruct power_sensor_data vdd;\n\tstruct power_sensor_data vdn;\n} __packed;\n\nstruct caps_sensor_2 {\n\tu16 cap;\n\tu16 system_power;\n\tu16 n_cap;\n\tu16 max;\n\tu16 min;\n\tu16 user;\n\tu8 user_source;\n} __packed;\n\nstruct caps_sensor_3 {\n\tu16 cap;\n\tu16 system_power;\n\tu16 n_cap;\n\tu16 max;\n\tu16 hard_min;\n\tu16 soft_min;\n\tu16 user;\n\tu8 user_source;\n} __packed;\n\nstruct extended_sensor {\n\tunion {\n\t\tu8 name[4];\n\t\tu32 sensor_id;\n\t};\n\tu8 flags;\n\tu8 reserved;\n\tu8 data[6];\n} __packed;\n\nstatic int occ_poll(struct occ *occ)\n{\n\tint rc;\n\tu8 cmd[7];\n\tstruct occ_poll_response_header *header;\n\n\t \n\tcmd[0] = 0;\t\t\t \n\tcmd[1] = 0;\t\t\t \n\tcmd[2] = 0;\t\t\t \n\tcmd[3] = 1;\t\t\t \n\tcmd[4] = occ->poll_cmd_data;\t \n\tcmd[5] = 0;\t\t\t \n\tcmd[6] = 0;\t\t\t \n\n\t \n\trc = occ->send_cmd(occ, cmd, sizeof(cmd), &occ->resp, sizeof(occ->resp));\n\tif (rc) {\n\t\tocc->last_error = rc;\n\t\tif (occ->error_count++ > OCC_ERROR_COUNT_THRESHOLD)\n\t\t\tocc->error = rc;\n\n\t\tgoto done;\n\t}\n\n\t \n\tocc->error_count = 0;\n\tocc->last_error = 0;\n\tocc->error = 0;\n\n\t \n\theader = (struct occ_poll_response_header *)occ->resp.data;\n\tif (header->occ_state == OCC_STATE_SAFE) {\n\t\tif (occ->last_safe) {\n\t\t\tif (time_after(jiffies,\n\t\t\t\t       occ->last_safe + OCC_SAFE_TIMEOUT))\n\t\t\t\tocc->error = -EHOSTDOWN;\n\t\t} else {\n\t\t\tocc->last_safe = jiffies;\n\t\t}\n\t} else {\n\t\tocc->last_safe = 0;\n\t}\n\ndone:\n\tocc_sysfs_poll_done(occ);\n\treturn rc;\n}\n\nstatic int occ_set_user_power_cap(struct occ *occ, u16 user_power_cap)\n{\n\tint rc;\n\tu8 cmd[8];\n\tu8 resp[8];\n\t__be16 user_power_cap_be = cpu_to_be16(user_power_cap);\n\n\tcmd[0] = 0;\t \n\tcmd[1] = 0x22;\t \n\tcmd[2] = 0;\t \n\tcmd[3] = 2;\t \n\n\tmemcpy(&cmd[4], &user_power_cap_be, 2);\n\n\tcmd[6] = 0;\t \n\tcmd[7] = 0;\t \n\n\trc = mutex_lock_interruptible(&occ->lock);\n\tif (rc)\n\t\treturn rc;\n\n\trc = occ->send_cmd(occ, cmd, sizeof(cmd), resp, sizeof(resp));\n\n\tmutex_unlock(&occ->lock);\n\n\treturn rc;\n}\n\nint occ_update_response(struct occ *occ)\n{\n\tint rc = mutex_lock_interruptible(&occ->lock);\n\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (time_after(jiffies, occ->next_update)) {\n\t\trc = occ_poll(occ);\n\t\tocc->next_update = jiffies + OCC_UPDATE_FREQUENCY;\n\t} else {\n\t\trc = occ->last_error;\n\t}\n\n\tmutex_unlock(&occ->lock);\n\treturn rc;\n}\n\nstatic ssize_t occ_show_temp_1(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tint rc;\n\tu32 val = 0;\n\tstruct temp_sensor_1 *temp;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\trc = occ_update_response(occ);\n\tif (rc)\n\t\treturn rc;\n\n\ttemp = ((struct temp_sensor_1 *)sensors->temp.data) + sattr->index;\n\n\tswitch (sattr->nr) {\n\tcase 0:\n\t\tval = get_unaligned_be16(&temp->sensor_id);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tif (temp->value == 0xFFFF)\n\t\t\treturn -EREMOTEIO;\n\t\tval = get_unaligned_be16(&temp->value) * 1000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t occ_show_temp_2(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tint rc;\n\tu32 val = 0;\n\tstruct temp_sensor_2 *temp;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\trc = occ_update_response(occ);\n\tif (rc)\n\t\treturn rc;\n\n\ttemp = ((struct temp_sensor_2 *)sensors->temp.data) + sattr->index;\n\n\tswitch (sattr->nr) {\n\tcase 0:\n\t\tval = get_unaligned_be32(&temp->sensor_id);\n\t\tbreak;\n\tcase 1:\n\t\tval = temp->value;\n\t\tif (val == OCC_TEMP_SENSOR_FAULT)\n\t\t\treturn -EREMOTEIO;\n\n\t\t \n\t\tif (temp->fru_type != OCC_FRU_TYPE_VRM) {\n\t\t\t \n\t\t\tif (val == 0)\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tval *= 1000;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tval = temp->fru_type;\n\t\tbreak;\n\tcase 3:\n\t\tval = temp->value == OCC_TEMP_SENSOR_FAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t occ_show_temp_10(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint rc;\n\tu32 val = 0;\n\tstruct temp_sensor_10 *temp;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\trc = occ_update_response(occ);\n\tif (rc)\n\t\treturn rc;\n\n\ttemp = ((struct temp_sensor_10 *)sensors->temp.data) + sattr->index;\n\n\tswitch (sattr->nr) {\n\tcase 0:\n\t\tval = get_unaligned_be32(&temp->sensor_id);\n\t\tbreak;\n\tcase 1:\n\t\tval = temp->value;\n\t\tif (val == OCC_TEMP_SENSOR_FAULT)\n\t\t\treturn -EREMOTEIO;\n\n\t\t \n\t\tif (val == 0)\n\t\t\treturn -EAGAIN;\n\n\t\tval *= 1000;\n\t\tbreak;\n\tcase 2:\n\t\tval = temp->fru_type;\n\t\tbreak;\n\tcase 3:\n\t\tval = temp->value == OCC_TEMP_SENSOR_FAULT;\n\t\tbreak;\n\tcase 4:\n\t\tval = temp->throttle * 1000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t occ_show_freq_1(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tint rc;\n\tu16 val = 0;\n\tstruct freq_sensor_1 *freq;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\trc = occ_update_response(occ);\n\tif (rc)\n\t\treturn rc;\n\n\tfreq = ((struct freq_sensor_1 *)sensors->freq.data) + sattr->index;\n\n\tswitch (sattr->nr) {\n\tcase 0:\n\t\tval = get_unaligned_be16(&freq->sensor_id);\n\t\tbreak;\n\tcase 1:\n\t\tval = get_unaligned_be16(&freq->value);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t occ_show_freq_2(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tint rc;\n\tu32 val = 0;\n\tstruct freq_sensor_2 *freq;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\trc = occ_update_response(occ);\n\tif (rc)\n\t\treturn rc;\n\n\tfreq = ((struct freq_sensor_2 *)sensors->freq.data) + sattr->index;\n\n\tswitch (sattr->nr) {\n\tcase 0:\n\t\tval = get_unaligned_be32(&freq->sensor_id);\n\t\tbreak;\n\tcase 1:\n\t\tval = get_unaligned_be16(&freq->value);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t occ_show_power_1(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint rc;\n\tu64 val = 0;\n\tstruct power_sensor_1 *power;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\trc = occ_update_response(occ);\n\tif (rc)\n\t\treturn rc;\n\n\tpower = ((struct power_sensor_1 *)sensors->power.data) + sattr->index;\n\n\tswitch (sattr->nr) {\n\tcase 0:\n\t\tval = get_unaligned_be16(&power->sensor_id);\n\t\tbreak;\n\tcase 1:\n\t\tval = get_unaligned_be32(&power->accumulator) /\n\t\t\tget_unaligned_be32(&power->update_tag);\n\t\tval *= 1000000ULL;\n\t\tbreak;\n\tcase 2:\n\t\tval = (u64)get_unaligned_be32(&power->update_tag) *\n\t\t\t   occ->powr_sample_time_us;\n\t\tbreak;\n\tcase 3:\n\t\tval = get_unaligned_be16(&power->value) * 1000000ULL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%llu\\n\", val);\n}\n\nstatic u64 occ_get_powr_avg(u64 *accum, u32 *samples)\n{\n\tu64 divisor = get_unaligned_be32(samples);\n\n\treturn (divisor == 0) ? 0 :\n\t\tdiv64_u64(get_unaligned_be64(accum) * 1000000ULL, divisor);\n}\n\nstatic ssize_t occ_show_power_2(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint rc;\n\tu64 val = 0;\n\tstruct power_sensor_2 *power;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\trc = occ_update_response(occ);\n\tif (rc)\n\t\treturn rc;\n\n\tpower = ((struct power_sensor_2 *)sensors->power.data) + sattr->index;\n\n\tswitch (sattr->nr) {\n\tcase 0:\n\t\treturn sysfs_emit(buf, \"%u_%u_%u\\n\",\n\t\t\t\t  get_unaligned_be32(&power->sensor_id),\n\t\t\t\t  power->function_id, power->apss_channel);\n\tcase 1:\n\t\tval = occ_get_powr_avg(&power->accumulator,\n\t\t\t\t       &power->update_tag);\n\t\tbreak;\n\tcase 2:\n\t\tval = (u64)get_unaligned_be32(&power->update_tag) *\n\t\t\t   occ->powr_sample_time_us;\n\t\tbreak;\n\tcase 3:\n\t\tval = get_unaligned_be16(&power->value) * 1000000ULL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%llu\\n\", val);\n}\n\nstatic ssize_t occ_show_power_a0(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tint rc;\n\tu64 val = 0;\n\tstruct power_sensor_a0 *power;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\trc = occ_update_response(occ);\n\tif (rc)\n\t\treturn rc;\n\n\tpower = ((struct power_sensor_a0 *)sensors->power.data) + sattr->index;\n\n\tswitch (sattr->nr) {\n\tcase 0:\n\t\treturn sysfs_emit(buf, \"%u_system\\n\",\n\t\t\t\t  get_unaligned_be32(&power->sensor_id));\n\tcase 1:\n\t\tval = occ_get_powr_avg(&power->system.accumulator,\n\t\t\t\t       &power->system.update_tag);\n\t\tbreak;\n\tcase 2:\n\t\tval = (u64)get_unaligned_be32(&power->system.update_tag) *\n\t\t\t   occ->powr_sample_time_us;\n\t\tbreak;\n\tcase 3:\n\t\tval = get_unaligned_be16(&power->system.value) * 1000000ULL;\n\t\tbreak;\n\tcase 4:\n\t\treturn sysfs_emit(buf, \"%u_proc\\n\",\n\t\t\t\t  get_unaligned_be32(&power->sensor_id));\n\tcase 5:\n\t\tval = occ_get_powr_avg(&power->proc.accumulator,\n\t\t\t\t       &power->proc.update_tag);\n\t\tbreak;\n\tcase 6:\n\t\tval = (u64)get_unaligned_be32(&power->proc.update_tag) *\n\t\t\t   occ->powr_sample_time_us;\n\t\tbreak;\n\tcase 7:\n\t\tval = get_unaligned_be16(&power->proc.value) * 1000000ULL;\n\t\tbreak;\n\tcase 8:\n\t\treturn sysfs_emit(buf, \"%u_vdd\\n\",\n\t\t\t\t  get_unaligned_be32(&power->sensor_id));\n\tcase 9:\n\t\tval = occ_get_powr_avg(&power->vdd.accumulator,\n\t\t\t\t       &power->vdd.update_tag);\n\t\tbreak;\n\tcase 10:\n\t\tval = (u64)get_unaligned_be32(&power->vdd.update_tag) *\n\t\t\t   occ->powr_sample_time_us;\n\t\tbreak;\n\tcase 11:\n\t\tval = get_unaligned_be16(&power->vdd.value) * 1000000ULL;\n\t\tbreak;\n\tcase 12:\n\t\treturn sysfs_emit(buf, \"%u_vdn\\n\",\n\t\t\t\t  get_unaligned_be32(&power->sensor_id));\n\tcase 13:\n\t\tval = occ_get_powr_avg(&power->vdn.accumulator,\n\t\t\t\t       &power->vdn.update_tag);\n\t\tbreak;\n\tcase 14:\n\t\tval = (u64)get_unaligned_be32(&power->vdn.update_tag) *\n\t\t\t   occ->powr_sample_time_us;\n\t\tbreak;\n\tcase 15:\n\t\tval = get_unaligned_be16(&power->vdn.value) * 1000000ULL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%llu\\n\", val);\n}\n\nstatic ssize_t occ_show_caps_1_2(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tint rc;\n\tu64 val = 0;\n\tstruct caps_sensor_2 *caps;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\trc = occ_update_response(occ);\n\tif (rc)\n\t\treturn rc;\n\n\tcaps = ((struct caps_sensor_2 *)sensors->caps.data) + sattr->index;\n\n\tswitch (sattr->nr) {\n\tcase 0:\n\t\treturn sysfs_emit(buf, \"system\\n\");\n\tcase 1:\n\t\tval = get_unaligned_be16(&caps->cap) * 1000000ULL;\n\t\tbreak;\n\tcase 2:\n\t\tval = get_unaligned_be16(&caps->system_power) * 1000000ULL;\n\t\tbreak;\n\tcase 3:\n\t\tval = get_unaligned_be16(&caps->n_cap) * 1000000ULL;\n\t\tbreak;\n\tcase 4:\n\t\tval = get_unaligned_be16(&caps->max) * 1000000ULL;\n\t\tbreak;\n\tcase 5:\n\t\tval = get_unaligned_be16(&caps->min) * 1000000ULL;\n\t\tbreak;\n\tcase 6:\n\t\tval = get_unaligned_be16(&caps->user) * 1000000ULL;\n\t\tbreak;\n\tcase 7:\n\t\tif (occ->sensors.caps.version == 1)\n\t\t\treturn -EINVAL;\n\n\t\tval = caps->user_source;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%llu\\n\", val);\n}\n\nstatic ssize_t occ_show_caps_3(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tint rc;\n\tu64 val = 0;\n\tstruct caps_sensor_3 *caps;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\trc = occ_update_response(occ);\n\tif (rc)\n\t\treturn rc;\n\n\tcaps = ((struct caps_sensor_3 *)sensors->caps.data) + sattr->index;\n\n\tswitch (sattr->nr) {\n\tcase 0:\n\t\treturn sysfs_emit(buf, \"system\\n\");\n\tcase 1:\n\t\tval = get_unaligned_be16(&caps->cap) * 1000000ULL;\n\t\tbreak;\n\tcase 2:\n\t\tval = get_unaligned_be16(&caps->system_power) * 1000000ULL;\n\t\tbreak;\n\tcase 3:\n\t\tval = get_unaligned_be16(&caps->n_cap) * 1000000ULL;\n\t\tbreak;\n\tcase 4:\n\t\tval = get_unaligned_be16(&caps->max) * 1000000ULL;\n\t\tbreak;\n\tcase 5:\n\t\tval = get_unaligned_be16(&caps->hard_min) * 1000000ULL;\n\t\tbreak;\n\tcase 6:\n\t\tval = get_unaligned_be16(&caps->user) * 1000000ULL;\n\t\tbreak;\n\tcase 7:\n\t\tval = caps->user_source;\n\t\tbreak;\n\tcase 8:\n\t\tval = get_unaligned_be16(&caps->soft_min) * 1000000ULL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%llu\\n\", val);\n}\n\nstatic ssize_t occ_store_caps_user(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint rc;\n\tu16 user_power_cap;\n\tunsigned long long value;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\n\trc = kstrtoull(buf, 0, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tuser_power_cap = div64_u64(value, 1000000ULL);  \n\n\trc = occ_set_user_power_cap(occ, user_power_cap);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic ssize_t occ_show_extended(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tint rc;\n\tstruct extended_sensor *extn;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\trc = occ_update_response(occ);\n\tif (rc)\n\t\treturn rc;\n\n\textn = ((struct extended_sensor *)sensors->extended.data) +\n\t\tsattr->index;\n\n\tswitch (sattr->nr) {\n\tcase 0:\n\t\tif (extn->flags & EXTN_FLAG_SENSOR_ID) {\n\t\t\trc = sysfs_emit(buf, \"%u\",\n\t\t\t\t\tget_unaligned_be32(&extn->sensor_id));\n\t\t} else {\n\t\t\trc = sysfs_emit(buf, \"%4phN\\n\", extn->name);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\trc = sysfs_emit(buf, \"%02x\\n\", extn->flags);\n\t\tbreak;\n\tcase 2:\n\t\trc = sysfs_emit(buf, \"%6phN\\n\", extn->data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn rc;\n}\n\n \n#define ATTR_OCC(_name, _mode, _show, _store) {\t\t\t\t\\\n\t.attr\t= {\t\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.mode = VERIFY_OCTAL_PERMISSIONS(_mode),\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.show\t= _show,\t\t\t\t\t\t\\\n\t.store\t= _store,\t\t\t\t\t\t\\\n}\n\n#define SENSOR_ATTR_OCC(_name, _mode, _show, _store, _nr, _index) {\t\\\n\t.dev_attr\t= ATTR_OCC(_name, _mode, _show, _store),\t\\\n\t.index\t\t= _index,\t\t\t\t\t\\\n\t.nr\t\t= _nr,\t\t\t\t\t\t\\\n}\n\n#define OCC_INIT_ATTR(_name, _mode, _show, _store, _nr, _index)\t\t\\\n\t((struct sensor_device_attribute_2)\t\t\t\t\\\n\t\tSENSOR_ATTR_OCC(_name, _mode, _show, _store, _nr, _index))\n\n \nstatic int occ_setup_sensor_attrs(struct occ *occ)\n{\n\tunsigned int i, s, num_attrs = 0;\n\tstruct device *dev = occ->bus_dev;\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct occ_attribute *attr;\n\tstruct temp_sensor_2 *temp;\n\tssize_t (*show_temp)(struct device *, struct device_attribute *,\n\t\t\t     char *) = occ_show_temp_1;\n\tssize_t (*show_freq)(struct device *, struct device_attribute *,\n\t\t\t     char *) = occ_show_freq_1;\n\tssize_t (*show_power)(struct device *, struct device_attribute *,\n\t\t\t      char *) = occ_show_power_1;\n\tssize_t (*show_caps)(struct device *, struct device_attribute *,\n\t\t\t     char *) = occ_show_caps_1_2;\n\n\tswitch (sensors->temp.version) {\n\tcase 1:\n\t\tnum_attrs += (sensors->temp.num_sensors * 2);\n\t\tbreak;\n\tcase 2:\n\t\tnum_attrs += (sensors->temp.num_sensors * 4);\n\t\tshow_temp = occ_show_temp_2;\n\t\tbreak;\n\tcase 0x10:\n\t\tnum_attrs += (sensors->temp.num_sensors * 5);\n\t\tshow_temp = occ_show_temp_10;\n\t\tbreak;\n\tdefault:\n\t\tsensors->temp.num_sensors = 0;\n\t}\n\n\tswitch (sensors->freq.version) {\n\tcase 2:\n\t\tshow_freq = occ_show_freq_2;\n\t\tfallthrough;\n\tcase 1:\n\t\tnum_attrs += (sensors->freq.num_sensors * 2);\n\t\tbreak;\n\tdefault:\n\t\tsensors->freq.num_sensors = 0;\n\t}\n\n\tswitch (sensors->power.version) {\n\tcase 2:\n\t\tshow_power = occ_show_power_2;\n\t\tfallthrough;\n\tcase 1:\n\t\tnum_attrs += (sensors->power.num_sensors * 4);\n\t\tbreak;\n\tcase 0xA0:\n\t\tnum_attrs += (sensors->power.num_sensors * 16);\n\t\tshow_power = occ_show_power_a0;\n\t\tbreak;\n\tdefault:\n\t\tsensors->power.num_sensors = 0;\n\t}\n\n\tswitch (sensors->caps.version) {\n\tcase 1:\n\t\tnum_attrs += (sensors->caps.num_sensors * 7);\n\t\tbreak;\n\tcase 2:\n\t\tnum_attrs += (sensors->caps.num_sensors * 8);\n\t\tbreak;\n\tcase 3:\n\t\tshow_caps = occ_show_caps_3;\n\t\tnum_attrs += (sensors->caps.num_sensors * 9);\n\t\tbreak;\n\tdefault:\n\t\tsensors->caps.num_sensors = 0;\n\t}\n\n\tswitch (sensors->extended.version) {\n\tcase 1:\n\t\tnum_attrs += (sensors->extended.num_sensors * 3);\n\t\tbreak;\n\tdefault:\n\t\tsensors->extended.num_sensors = 0;\n\t}\n\n\tocc->attrs = devm_kzalloc(dev, sizeof(*occ->attrs) * num_attrs,\n\t\t\t\t  GFP_KERNEL);\n\tif (!occ->attrs)\n\t\treturn -ENOMEM;\n\n\t \n\tocc->group.attrs = devm_kzalloc(dev, sizeof(*occ->group.attrs) *\n\t\t\t\t\tnum_attrs + 1, GFP_KERNEL);\n\tif (!occ->group.attrs)\n\t\treturn -ENOMEM;\n\n\tattr = occ->attrs;\n\n\tfor (i = 0; i < sensors->temp.num_sensors; ++i) {\n\t\ts = i + 1;\n\t\ttemp = ((struct temp_sensor_2 *)sensors->temp.data) + i;\n\n\t\tsnprintf(attr->name, sizeof(attr->name), \"temp%d_label\", s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444, show_temp, NULL,\n\t\t\t\t\t     0, i);\n\t\tattr++;\n\n\t\tif (sensors->temp.version == 2 &&\n\t\t    temp->fru_type == OCC_FRU_TYPE_VRM) {\n\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t \"temp%d_alarm\", s);\n\t\t} else {\n\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t \"temp%d_input\", s);\n\t\t}\n\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444, show_temp, NULL,\n\t\t\t\t\t     1, i);\n\t\tattr++;\n\n\t\tif (sensors->temp.version > 1) {\n\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t \"temp%d_fru_type\", s);\n\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t     show_temp, NULL, 2, i);\n\t\t\tattr++;\n\n\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t \"temp%d_fault\", s);\n\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t     show_temp, NULL, 3, i);\n\t\t\tattr++;\n\n\t\t\tif (sensors->temp.version == 0x10) {\n\t\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t\t \"temp%d_max\", s);\n\t\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t\t     show_temp, NULL,\n\t\t\t\t\t\t\t     4, i);\n\t\t\t\tattr++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < sensors->freq.num_sensors; ++i) {\n\t\ts = i + 1;\n\n\t\tsnprintf(attr->name, sizeof(attr->name), \"freq%d_label\", s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444, show_freq, NULL,\n\t\t\t\t\t     0, i);\n\t\tattr++;\n\n\t\tsnprintf(attr->name, sizeof(attr->name), \"freq%d_input\", s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444, show_freq, NULL,\n\t\t\t\t\t     1, i);\n\t\tattr++;\n\t}\n\n\tif (sensors->power.version == 0xA0) {\n\t\t \n\t\tfor (i = 0; i < sensors->power.num_sensors; ++i) {\n\t\t\tunsigned int j;\n\t\t\tunsigned int nr = 0;\n\n\t\t\ts = (i * 4) + 1;\n\n\t\t\tfor (j = 0; j < 4; ++j) {\n\t\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t\t \"power%d_label\", s);\n\t\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t\t     show_power, NULL,\n\t\t\t\t\t\t\t     nr++, i);\n\t\t\t\tattr++;\n\n\t\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t\t \"power%d_average\", s);\n\t\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t\t     show_power, NULL,\n\t\t\t\t\t\t\t     nr++, i);\n\t\t\t\tattr++;\n\n\t\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t\t \"power%d_average_interval\", s);\n\t\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t\t     show_power, NULL,\n\t\t\t\t\t\t\t     nr++, i);\n\t\t\t\tattr++;\n\n\t\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t\t \"power%d_input\", s);\n\t\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t\t     show_power, NULL,\n\t\t\t\t\t\t\t     nr++, i);\n\t\t\t\tattr++;\n\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\n\t\ts = (sensors->power.num_sensors * 4) + 1;\n\t} else {\n\t\tfor (i = 0; i < sensors->power.num_sensors; ++i) {\n\t\t\ts = i + 1;\n\n\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t \"power%d_label\", s);\n\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t     show_power, NULL, 0, i);\n\t\t\tattr++;\n\n\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t \"power%d_average\", s);\n\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t     show_power, NULL, 1, i);\n\t\t\tattr++;\n\n\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t \"power%d_average_interval\", s);\n\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t     show_power, NULL, 2, i);\n\t\t\tattr++;\n\n\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t \"power%d_input\", s);\n\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t     show_power, NULL, 3, i);\n\t\t\tattr++;\n\t\t}\n\n\t\ts = sensors->power.num_sensors + 1;\n\t}\n\n\tif (sensors->caps.num_sensors >= 1) {\n\t\tsnprintf(attr->name, sizeof(attr->name), \"power%d_label\", s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444, show_caps, NULL,\n\t\t\t\t\t     0, 0);\n\t\tattr++;\n\n\t\tsnprintf(attr->name, sizeof(attr->name), \"power%d_cap\", s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444, show_caps, NULL,\n\t\t\t\t\t     1, 0);\n\t\tattr++;\n\n\t\tsnprintf(attr->name, sizeof(attr->name), \"power%d_input\", s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444, show_caps, NULL,\n\t\t\t\t\t     2, 0);\n\t\tattr++;\n\n\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t \"power%d_cap_not_redundant\", s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444, show_caps, NULL,\n\t\t\t\t\t     3, 0);\n\t\tattr++;\n\n\t\tsnprintf(attr->name, sizeof(attr->name), \"power%d_cap_max\", s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444, show_caps, NULL,\n\t\t\t\t\t     4, 0);\n\t\tattr++;\n\n\t\tsnprintf(attr->name, sizeof(attr->name), \"power%d_cap_min\", s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444, show_caps, NULL,\n\t\t\t\t\t     5, 0);\n\t\tattr++;\n\n\t\tsnprintf(attr->name, sizeof(attr->name), \"power%d_cap_user\",\n\t\t\t s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0644, show_caps,\n\t\t\t\t\t     occ_store_caps_user, 6, 0);\n\t\tattr++;\n\n\t\tif (sensors->caps.version > 1) {\n\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t \"power%d_cap_user_source\", s);\n\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t     show_caps, NULL, 7, 0);\n\t\t\tattr++;\n\n\t\t\tif (sensors->caps.version > 2) {\n\t\t\t\tsnprintf(attr->name, sizeof(attr->name),\n\t\t\t\t\t \"power%d_cap_min_soft\", s);\n\t\t\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t\t\t     show_caps, NULL,\n\t\t\t\t\t\t\t     8, 0);\n\t\t\t\tattr++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < sensors->extended.num_sensors; ++i) {\n\t\ts = i + 1;\n\n\t\tsnprintf(attr->name, sizeof(attr->name), \"extn%d_label\", s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t     occ_show_extended, NULL, 0, i);\n\t\tattr++;\n\n\t\tsnprintf(attr->name, sizeof(attr->name), \"extn%d_flags\", s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t     occ_show_extended, NULL, 1, i);\n\t\tattr++;\n\n\t\tsnprintf(attr->name, sizeof(attr->name), \"extn%d_input\", s);\n\t\tattr->sensor = OCC_INIT_ATTR(attr->name, 0444,\n\t\t\t\t\t     occ_show_extended, NULL, 2, i);\n\t\tattr++;\n\t}\n\n\t \n\tfor (i = 0; i < num_attrs; ++i) {\n\t\tsysfs_attr_init(&occ->attrs[i].sensor.dev_attr.attr);\n\t\tocc->group.attrs[i] = &occ->attrs[i].sensor.dev_attr.attr;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void occ_parse_poll_response(struct occ *occ)\n{\n\tunsigned int i, old_offset, offset = 0, size = 0;\n\tstruct occ_sensor *sensor;\n\tstruct occ_sensors *sensors = &occ->sensors;\n\tstruct occ_response *resp = &occ->resp;\n\tstruct occ_poll_response *poll =\n\t\t(struct occ_poll_response *)&resp->data[0];\n\tstruct occ_poll_response_header *header = &poll->header;\n\tstruct occ_sensor_data_block *block = &poll->block;\n\n\tdev_info(occ->bus_dev, \"OCC found, code level: %.16s\\n\",\n\t\t header->occ_code_level);\n\n\tfor (i = 0; i < header->num_sensor_data_blocks; ++i) {\n\t\tblock = (struct occ_sensor_data_block *)((u8 *)block + offset);\n\t\told_offset = offset;\n\t\toffset = (block->header.num_sensors *\n\t\t\t  block->header.sensor_length) + sizeof(block->header);\n\t\tsize += offset;\n\n\t\t \n\t\tif ((size + sizeof(*header)) >= OCC_RESP_DATA_BYTES) {\n\t\t\tdev_warn(occ->bus_dev, \"exceeded response buffer\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tdev_dbg(occ->bus_dev, \" %04x..%04x: %.4s (%d sensors)\\n\",\n\t\t\told_offset, offset - 1, block->header.eye_catcher,\n\t\t\tblock->header.num_sensors);\n\n\t\t \n\t\tif (strncmp(block->header.eye_catcher, \"TEMP\", 4) == 0)\n\t\t\tsensor = &sensors->temp;\n\t\telse if (strncmp(block->header.eye_catcher, \"FREQ\", 4) == 0)\n\t\t\tsensor = &sensors->freq;\n\t\telse if (strncmp(block->header.eye_catcher, \"POWR\", 4) == 0)\n\t\t\tsensor = &sensors->power;\n\t\telse if (strncmp(block->header.eye_catcher, \"CAPS\", 4) == 0)\n\t\t\tsensor = &sensors->caps;\n\t\telse if (strncmp(block->header.eye_catcher, \"EXTN\", 4) == 0)\n\t\t\tsensor = &sensors->extended;\n\t\telse {\n\t\t\tdev_warn(occ->bus_dev, \"sensor not supported %.4s\\n\",\n\t\t\t\t block->header.eye_catcher);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsensor->num_sensors = block->header.num_sensors;\n\t\tsensor->version = block->header.sensor_format;\n\t\tsensor->data = &block->data;\n\t}\n\n\tdev_dbg(occ->bus_dev, \"Max resp size: %u+%zd=%zd\\n\", size,\n\t\tsizeof(*header), size + sizeof(*header));\n}\n\nint occ_active(struct occ *occ, bool active)\n{\n\tint rc = mutex_lock_interruptible(&occ->lock);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (active) {\n\t\tif (occ->active) {\n\t\t\trc = -EALREADY;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tocc->error_count = 0;\n\t\tocc->last_safe = 0;\n\n\t\trc = occ_poll(occ);\n\t\tif (rc < 0) {\n\t\t\tdev_err(occ->bus_dev,\n\t\t\t\t\"failed to get OCC poll response=%02x: %d\\n\",\n\t\t\t\tocc->resp.return_status, rc);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tocc->active = true;\n\t\tocc->next_update = jiffies + OCC_UPDATE_FREQUENCY;\n\t\tocc_parse_poll_response(occ);\n\n\t\trc = occ_setup_sensor_attrs(occ);\n\t\tif (rc) {\n\t\t\tdev_err(occ->bus_dev,\n\t\t\t\t\"failed to setup sensor attrs: %d\\n\", rc);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tocc->hwmon = hwmon_device_register_with_groups(occ->bus_dev,\n\t\t\t\t\t\t\t       \"occ\", occ,\n\t\t\t\t\t\t\t       occ->groups);\n\t\tif (IS_ERR(occ->hwmon)) {\n\t\t\trc = PTR_ERR(occ->hwmon);\n\t\t\tocc->hwmon = NULL;\n\t\t\tdev_err(occ->bus_dev,\n\t\t\t\t\"failed to register hwmon device: %d\\n\", rc);\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tif (!occ->active) {\n\t\t\trc = -EALREADY;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (occ->hwmon)\n\t\t\thwmon_device_unregister(occ->hwmon);\n\t\tocc->active = false;\n\t\tocc->hwmon = NULL;\n\t}\n\nunlock:\n\tmutex_unlock(&occ->lock);\n\treturn rc;\n}\n\nint occ_setup(struct occ *occ)\n{\n\tint rc;\n\n\tmutex_init(&occ->lock);\n\tocc->groups[0] = &occ->group;\n\n\trc = occ_setup_sysfs(occ);\n\tif (rc) {\n\t\tdev_err(occ->bus_dev, \"failed to setup sysfs: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (!device_property_read_bool(occ->bus_dev, \"ibm,no-poll-on-init\")) {\n\t\trc = occ_active(occ, true);\n\t\tif (rc)\n\t\t\tocc_shutdown_sysfs(occ);\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(occ_setup);\n\nvoid occ_shutdown(struct occ *occ)\n{\n\tmutex_lock(&occ->lock);\n\n\tocc_shutdown_sysfs(occ);\n\n\tif (occ->hwmon)\n\t\thwmon_device_unregister(occ->hwmon);\n\tocc->hwmon = NULL;\n\n\tmutex_unlock(&occ->lock);\n}\nEXPORT_SYMBOL_GPL(occ_shutdown);\n\nMODULE_AUTHOR(\"Eddie James <eajames@linux.ibm.com>\");\nMODULE_DESCRIPTION(\"Common OCC hwmon code\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}