{
  "module_name": "sysfs.c",
  "hash_id": "ad291e505dc5612afeb019ded22e48ed436d3faf9eeef2c49785d45b7c786660",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/occ/sysfs.c",
  "human_readable_source": "\n\n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/sysfs.h>\n\n#include \"common.h\"\n\n \n#define OCC_STAT_MASTER\t\t\tBIT(7)\n\n \n#define OCC_EXT_STAT_DVFS_OT\t\tBIT(7)\n#define OCC_EXT_STAT_DVFS_POWER\t\tBIT(6)\n#define OCC_EXT_STAT_MEM_THROTTLE\tBIT(5)\n#define OCC_EXT_STAT_QUICK_DROP\t\tBIT(4)\n#define OCC_EXT_STAT_DVFS_VDD\t\tBIT(3)\n#define OCC_EXT_STAT_GPU_THROTTLE\tGENMASK(2, 0)\n\nstatic ssize_t occ_active_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tint rc;\n\tbool active;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\n\trc = kstrtobool(buf, &active);\n\tif (rc)\n\t\treturn rc;\n\n\trc = occ_active(occ, active);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic ssize_t occ_sysfs_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tint rc;\n\tint val = 0;\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_poll_response_header *header;\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\n\tif (occ->active) {\n\t\trc = occ_update_response(occ);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\theader = (struct occ_poll_response_header *)occ->resp.data;\n\n\t\tswitch (sattr->index) {\n\t\tcase 0:\n\t\t\tval = !!(header->status & OCC_STAT_MASTER);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tval = 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = !!(header->ext_status & OCC_EXT_STAT_DVFS_OT);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = !!(header->ext_status & OCC_EXT_STAT_DVFS_POWER);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = !!(header->ext_status &\n\t\t\t\t OCC_EXT_STAT_MEM_THROTTLE);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tval = !!(header->ext_status & OCC_EXT_STAT_QUICK_DROP);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tval = header->occ_state;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tif (header->status & OCC_STAT_MASTER)\n\t\t\t\tval = hweight8(header->occs_present);\n\t\t\telse\n\t\t\t\tval = 1;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = header->ips_status;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tval = header->mode;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tval = !!(header->ext_status & OCC_EXT_STAT_DVFS_VDD);\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tval = header->ext_status & OCC_EXT_STAT_GPU_THROTTLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (sattr->index == 1)\n\t\t\tval = 0;\n\t\telse if (sattr->index <= 11)\n\t\t\tval = -ENODATA;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t occ_error_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct occ *occ = dev_get_drvdata(dev);\n\n\tocc_update_response(occ);\n\n\treturn sysfs_emit(buf, \"%d\\n\", occ->error);\n}\n\nstatic SENSOR_DEVICE_ATTR(occ_master, 0444, occ_sysfs_show, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(occ_active, 0644, occ_sysfs_show, occ_active_store,\n\t\t\t  1);\nstatic SENSOR_DEVICE_ATTR(occ_dvfs_overtemp, 0444, occ_sysfs_show, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(occ_dvfs_power, 0444, occ_sysfs_show, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(occ_mem_throttle, 0444, occ_sysfs_show, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(occ_quick_pwr_drop, 0444, occ_sysfs_show, NULL, 5);\nstatic SENSOR_DEVICE_ATTR(occ_state, 0444, occ_sysfs_show, NULL, 6);\nstatic SENSOR_DEVICE_ATTR(occs_present, 0444, occ_sysfs_show, NULL, 7);\nstatic SENSOR_DEVICE_ATTR(occ_ips_status, 0444, occ_sysfs_show, NULL, 8);\nstatic SENSOR_DEVICE_ATTR(occ_mode, 0444, occ_sysfs_show, NULL, 9);\nstatic SENSOR_DEVICE_ATTR(occ_dvfs_vdd, 0444, occ_sysfs_show, NULL, 10);\nstatic SENSOR_DEVICE_ATTR(occ_gpu_throttle, 0444, occ_sysfs_show, NULL, 11);\nstatic DEVICE_ATTR_RO(occ_error);\n\nstatic struct attribute *occ_attributes[] = {\n\t&sensor_dev_attr_occ_master.dev_attr.attr,\n\t&sensor_dev_attr_occ_active.dev_attr.attr,\n\t&sensor_dev_attr_occ_dvfs_overtemp.dev_attr.attr,\n\t&sensor_dev_attr_occ_dvfs_power.dev_attr.attr,\n\t&sensor_dev_attr_occ_mem_throttle.dev_attr.attr,\n\t&sensor_dev_attr_occ_quick_pwr_drop.dev_attr.attr,\n\t&sensor_dev_attr_occ_state.dev_attr.attr,\n\t&sensor_dev_attr_occs_present.dev_attr.attr,\n\t&sensor_dev_attr_occ_ips_status.dev_attr.attr,\n\t&sensor_dev_attr_occ_mode.dev_attr.attr,\n\t&sensor_dev_attr_occ_dvfs_vdd.dev_attr.attr,\n\t&sensor_dev_attr_occ_gpu_throttle.dev_attr.attr,\n\t&dev_attr_occ_error.attr,\n\tNULL\n};\n\nstatic const struct attribute_group occ_sysfs = {\n\t.attrs = occ_attributes,\n};\n\nvoid occ_sysfs_poll_done(struct occ *occ)\n{\n\tconst char *name;\n\tstruct occ_poll_response_header *header =\n\t\t(struct occ_poll_response_header *)occ->resp.data;\n\n\t \n\tif (!occ->active)\n\t\tgoto done;\n\n\tif ((header->status & OCC_STAT_MASTER) !=\n\t    (occ->prev_stat & OCC_STAT_MASTER)) {\n\t\tname = sensor_dev_attr_occ_master.dev_attr.attr.name;\n\t\tsysfs_notify(&occ->bus_dev->kobj, NULL, name);\n\t}\n\n\tif ((header->ext_status & OCC_EXT_STAT_DVFS_OT) !=\n\t    (occ->prev_ext_stat & OCC_EXT_STAT_DVFS_OT)) {\n\t\tname = sensor_dev_attr_occ_dvfs_overtemp.dev_attr.attr.name;\n\t\tsysfs_notify(&occ->bus_dev->kobj, NULL, name);\n\t}\n\n\tif ((header->ext_status & OCC_EXT_STAT_DVFS_POWER) !=\n\t    (occ->prev_ext_stat & OCC_EXT_STAT_DVFS_POWER)) {\n\t\tname = sensor_dev_attr_occ_dvfs_power.dev_attr.attr.name;\n\t\tsysfs_notify(&occ->bus_dev->kobj, NULL, name);\n\t}\n\n\tif ((header->ext_status & OCC_EXT_STAT_MEM_THROTTLE) !=\n\t    (occ->prev_ext_stat & OCC_EXT_STAT_MEM_THROTTLE)) {\n\t\tname = sensor_dev_attr_occ_mem_throttle.dev_attr.attr.name;\n\t\tsysfs_notify(&occ->bus_dev->kobj, NULL, name);\n\t}\n\n\tif ((header->ext_status & OCC_EXT_STAT_QUICK_DROP) !=\n\t    (occ->prev_ext_stat & OCC_EXT_STAT_QUICK_DROP)) {\n\t\tname = sensor_dev_attr_occ_quick_pwr_drop.dev_attr.attr.name;\n\t\tsysfs_notify(&occ->bus_dev->kobj, NULL, name);\n\t}\n\n\tif ((header->ext_status & OCC_EXT_STAT_DVFS_VDD) !=\n\t    (occ->prev_ext_stat & OCC_EXT_STAT_DVFS_VDD)) {\n\t\tname = sensor_dev_attr_occ_dvfs_vdd.dev_attr.attr.name;\n\t\tsysfs_notify(&occ->bus_dev->kobj, NULL, name);\n\t}\n\n\tif ((header->ext_status & OCC_EXT_STAT_GPU_THROTTLE) !=\n\t    (occ->prev_ext_stat & OCC_EXT_STAT_GPU_THROTTLE)) {\n\t\tname = sensor_dev_attr_occ_gpu_throttle.dev_attr.attr.name;\n\t\tsysfs_notify(&occ->bus_dev->kobj, NULL, name);\n\t}\n\n\tif ((header->status & OCC_STAT_MASTER) &&\n\t    header->occs_present != occ->prev_occs_present) {\n\t\tname = sensor_dev_attr_occs_present.dev_attr.attr.name;\n\t\tsysfs_notify(&occ->bus_dev->kobj, NULL, name);\n\t}\n\n\tif (header->ips_status != occ->prev_ips_status) {\n\t\tname = sensor_dev_attr_occ_ips_status.dev_attr.attr.name;\n\t\tsysfs_notify(&occ->bus_dev->kobj, NULL, name);\n\t}\n\n\tif (header->mode != occ->prev_mode) {\n\t\tname = sensor_dev_attr_occ_mode.dev_attr.attr.name;\n\t\tsysfs_notify(&occ->bus_dev->kobj, NULL, name);\n\t}\n\n\tif (occ->error && occ->error != occ->prev_error) {\n\t\tname = dev_attr_occ_error.attr.name;\n\t\tsysfs_notify(&occ->bus_dev->kobj, NULL, name);\n\t}\n\n\t \n\ndone:\n\tocc->prev_error = occ->error;\n\tocc->prev_stat = header->status;\n\tocc->prev_ext_stat = header->ext_status;\n\tocc->prev_occs_present = header->occs_present;\n\tocc->prev_ips_status = header->ips_status;\n\tocc->prev_mode = header->mode;\n}\n\nint occ_setup_sysfs(struct occ *occ)\n{\n\treturn sysfs_create_group(&occ->bus_dev->kobj, &occ_sysfs);\n}\n\nvoid occ_shutdown_sysfs(struct occ *occ)\n{\n\tsysfs_remove_group(&occ->bus_dev->kobj, &occ_sysfs);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}