{
  "module_name": "p9_sbe.c",
  "hash_id": "7a91f311898de3438215cdc5f0c5e55e3150b3caef5ce2ba64379e9625088833",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/occ/p9_sbe.c",
  "human_readable_source": "\n\n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/fsi-occ.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n\n#include \"common.h\"\n\n#define OCC_CHECKSUM_RETRIES\t3\n\nstruct p9_sbe_occ {\n\tstruct occ occ;\n\tbool sbe_error;\n\tvoid *ffdc;\n\tsize_t ffdc_len;\n\tsize_t ffdc_size;\n\tstruct mutex sbe_error_lock;\t \n\tstruct device *sbe;\n};\n\n#define to_p9_sbe_occ(x)\tcontainer_of((x), struct p9_sbe_occ, occ)\n\nstatic ssize_t ffdc_read(struct file *filp, struct kobject *kobj,\n\t\t\t struct bin_attribute *battr, char *buf, loff_t pos,\n\t\t\t size_t count)\n{\n\tssize_t rc = 0;\n\tstruct occ *occ = dev_get_drvdata(kobj_to_dev(kobj));\n\tstruct p9_sbe_occ *ctx = to_p9_sbe_occ(occ);\n\n\tmutex_lock(&ctx->sbe_error_lock);\n\tif (ctx->sbe_error) {\n\t\trc = memory_read_from_buffer(buf, count, &pos, ctx->ffdc,\n\t\t\t\t\t     ctx->ffdc_len);\n\t\tif (pos >= ctx->ffdc_len)\n\t\t\tctx->sbe_error = false;\n\t}\n\tmutex_unlock(&ctx->sbe_error_lock);\n\n\treturn rc;\n}\nstatic BIN_ATTR_RO(ffdc, OCC_MAX_RESP_WORDS * 4);\n\nstatic bool p9_sbe_occ_save_ffdc(struct p9_sbe_occ *ctx, const void *resp,\n\t\t\t\t size_t resp_len)\n{\n\tbool notify = false;\n\n\tmutex_lock(&ctx->sbe_error_lock);\n\tif (!ctx->sbe_error) {\n\t\tif (resp_len > ctx->ffdc_size) {\n\t\t\tkvfree(ctx->ffdc);\n\t\t\tctx->ffdc = kvmalloc(resp_len, GFP_KERNEL);\n\t\t\tif (!ctx->ffdc) {\n\t\t\t\tctx->ffdc_len = 0;\n\t\t\t\tctx->ffdc_size = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tctx->ffdc_size = resp_len;\n\t\t}\n\n\t\tnotify = true;\n\t\tctx->sbe_error = true;\n\t\tctx->ffdc_len = resp_len;\n\t\tmemcpy(ctx->ffdc, resp, resp_len);\n\t}\n\ndone:\n\tmutex_unlock(&ctx->sbe_error_lock);\n\treturn notify;\n}\n\nstatic int p9_sbe_occ_send_cmd(struct occ *occ, u8 *cmd, size_t len,\n\t\t\t       void *resp, size_t resp_len)\n{\n\tsize_t original_resp_len = resp_len;\n\tstruct p9_sbe_occ *ctx = to_p9_sbe_occ(occ);\n\tint rc, i;\n\n\tfor (i = 0; i < OCC_CHECKSUM_RETRIES; ++i) {\n\t\trc = fsi_occ_submit(ctx->sbe, cmd, len, resp, &resp_len);\n\t\tif (rc >= 0)\n\t\t\tbreak;\n\t\tif (resp_len) {\n\t\t\tif (p9_sbe_occ_save_ffdc(ctx, resp, resp_len))\n\t\t\t\tsysfs_notify(&occ->bus_dev->kobj, NULL,\n\t\t\t\t\t     bin_attr_ffdc.attr.name);\n\t\t\treturn rc;\n\t\t}\n\t\tif (rc != -EBADE)\n\t\t\treturn rc;\n\t\tresp_len = original_resp_len;\n\t}\n\n\tswitch (((struct occ_response *)resp)->return_status) {\n\tcase OCC_RESP_CMD_IN_PRG:\n\t\trc = -ETIMEDOUT;\n\t\tbreak;\n\tcase OCC_RESP_SUCCESS:\n\t\trc = 0;\n\t\tbreak;\n\tcase OCC_RESP_CMD_INVAL:\n\tcase OCC_RESP_CMD_LEN_INVAL:\n\tcase OCC_RESP_DATA_INVAL:\n\tcase OCC_RESP_CHKSUM_ERR:\n\t\trc = -EINVAL;\n\t\tbreak;\n\tcase OCC_RESP_INT_ERR:\n\tcase OCC_RESP_BAD_STATE:\n\tcase OCC_RESP_CRIT_EXCEPT:\n\tcase OCC_RESP_CRIT_INIT:\n\tcase OCC_RESP_CRIT_WATCHDOG:\n\tcase OCC_RESP_CRIT_OCB:\n\tcase OCC_RESP_CRIT_HW:\n\t\trc = -EREMOTEIO;\n\t\tbreak;\n\tdefault:\n\t\trc = -EPROTO;\n\t}\n\n\treturn rc;\n}\n\nstatic int p9_sbe_occ_probe(struct platform_device *pdev)\n{\n\tint rc;\n\tstruct occ *occ;\n\tstruct p9_sbe_occ *ctx = devm_kzalloc(&pdev->dev, sizeof(*ctx),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ctx->sbe_error_lock);\n\n\tctx->sbe = pdev->dev.parent;\n\tocc = &ctx->occ;\n\tocc->bus_dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, occ);\n\n\tocc->powr_sample_time_us = 500;\n\tocc->poll_cmd_data = 0x20;\t\t \n\tocc->send_cmd = p9_sbe_occ_send_cmd;\n\n\trc = occ_setup(occ);\n\tif (rc == -ESHUTDOWN)\n\t\trc = -ENODEV;\t \n\n\tif (!rc) {\n\t\trc = device_create_bin_file(occ->bus_dev, &bin_attr_ffdc);\n\t\tif (rc) {\n\t\t\tdev_warn(occ->bus_dev,\n\t\t\t\t \"failed to create SBE error ffdc file\\n\");\n\t\t\trc = 0;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int p9_sbe_occ_remove(struct platform_device *pdev)\n{\n\tstruct occ *occ = platform_get_drvdata(pdev);\n\tstruct p9_sbe_occ *ctx = to_p9_sbe_occ(occ);\n\n\tdevice_remove_bin_file(occ->bus_dev, &bin_attr_ffdc);\n\n\tctx->sbe = NULL;\n\tocc_shutdown(occ);\n\n\tkvfree(ctx->ffdc);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id p9_sbe_occ_of_match[] = {\n\t{ .compatible = \"ibm,p9-occ-hwmon\" },\n\t{ .compatible = \"ibm,p10-occ-hwmon\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, p9_sbe_occ_of_match);\n\nstatic struct platform_driver p9_sbe_occ_driver = {\n\t.driver = {\n\t\t.name = \"occ-hwmon\",\n\t\t.of_match_table = p9_sbe_occ_of_match,\n\t},\n\t.probe\t= p9_sbe_occ_probe,\n\t.remove = p9_sbe_occ_remove,\n};\n\nmodule_platform_driver(p9_sbe_occ_driver);\n\nMODULE_AUTHOR(\"Eddie James <eajames@linux.ibm.com>\");\nMODULE_DESCRIPTION(\"BMC P9 OCC hwmon driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}