{
  "module_name": "p8_i2c.c",
  "hash_id": "69a4d5eaa9ee2b3f51aebfa31d06806beada6c2683ea012a18c11f4ae3245d3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/occ/p8_i2c.c",
  "human_readable_source": "\n\n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/fsi-occ.h>\n#include <linux/i2c.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <asm/unaligned.h>\n\n#include \"common.h\"\n\n#define OCC_TIMEOUT_MS\t\t\t1000\n#define OCC_CMD_IN_PRG_WAIT_MS\t\t50\n\n \n#define OCB_DATA1\t\t\t0x6B035\n#define OCB_ADDR\t\t\t0x6B070\n#define OCB_DATA3\t\t\t0x6B075\n\n \n#define OCC_SRAM_ADDR_CMD\t\t0xFFFF6000\n#define OCC_SRAM_ADDR_RESP\t\t0xFFFF7000\n\n#define OCC_DATA_ATTN\t\t\t0x20010000\n\nstruct p8_i2c_occ {\n\tstruct occ occ;\n\tstruct i2c_client *client;\n};\n\n#define to_p8_i2c_occ(x)\tcontainer_of((x), struct p8_i2c_occ, occ)\n\nstatic int p8_i2c_occ_getscom(struct i2c_client *client, u32 address, u8 *data)\n{\n\tssize_t rc;\n\t__be64 buf;\n\tstruct i2c_msg msgs[2];\n\n\t \n\taddress <<= 1;\n\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].flags = client->flags & I2C_M_TEN;\n\tmsgs[0].len = sizeof(u32);\n\t \n\tmsgs[0].buf = (char *)&address;\n\n\t \n\tmsgs[1].addr = client->addr;\n\tmsgs[1].flags = (client->flags & I2C_M_TEN) | I2C_M_RD;\n\tmsgs[1].len = sizeof(u64);\n\tmsgs[1].buf = (char *)&buf;\n\n\trc = i2c_transfer(client->adapter, msgs, 2);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*(u64 *)data = be64_to_cpu(buf);\n\n\treturn 0;\n}\n\nstatic int p8_i2c_occ_putscom(struct i2c_client *client, u32 address, u8 *data)\n{\n\tu32 buf[3];\n\tssize_t rc;\n\n\t \n\taddress <<= 1;\n\n\t \n\tbuf[0] = address;\n\tmemcpy(&buf[1], &data[4], sizeof(u32));\n\tmemcpy(&buf[2], data, sizeof(u32));\n\n\trc = i2c_master_send(client, (const char *)buf, sizeof(buf));\n\tif (rc < 0)\n\t\treturn rc;\n\telse if (rc != sizeof(buf))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int p8_i2c_occ_putscom_u32(struct i2c_client *client, u32 address,\n\t\t\t\t  u32 data0, u32 data1)\n{\n\tu8 buf[8];\n\n\tmemcpy(buf, &data0, 4);\n\tmemcpy(buf + 4, &data1, 4);\n\n\treturn p8_i2c_occ_putscom(client, address, buf);\n}\n\nstatic int p8_i2c_occ_putscom_be(struct i2c_client *client, u32 address,\n\t\t\t\t u8 *data, size_t len)\n{\n\t__be32 data0 = 0, data1 = 0;\n\n\tmemcpy(&data0, data, min_t(size_t, len, 4));\n\tif (len > 4) {\n\t\tlen -= 4;\n\t\tmemcpy(&data1, data + 4, min_t(size_t, len, 4));\n\t}\n\n\treturn p8_i2c_occ_putscom_u32(client, address, be32_to_cpu(data0),\n\t\t\t\t      be32_to_cpu(data1));\n}\n\nstatic int p8_i2c_occ_send_cmd(struct occ *occ, u8 *cmd, size_t len,\n\t\t\t       void *resp, size_t resp_len)\n{\n\tint i, rc;\n\tunsigned long start;\n\tu16 data_length;\n\tconst unsigned long timeout = msecs_to_jiffies(OCC_TIMEOUT_MS);\n\tconst long wait_time = msecs_to_jiffies(OCC_CMD_IN_PRG_WAIT_MS);\n\tstruct p8_i2c_occ *ctx = to_p8_i2c_occ(occ);\n\tstruct i2c_client *client = ctx->client;\n\tstruct occ_response *or = (struct occ_response *)resp;\n\n\tstart = jiffies;\n\n\t \n\trc = p8_i2c_occ_putscom_u32(client, OCB_ADDR, OCC_SRAM_ADDR_CMD, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = p8_i2c_occ_putscom_be(client, OCB_DATA3, cmd, len);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = p8_i2c_occ_putscom_u32(client, OCB_DATA1, OCC_DATA_ATTN, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tdo {\n\t\t \n\t\trc = p8_i2c_occ_putscom_u32(client, OCB_ADDR,\n\t\t\t\t\t    OCC_SRAM_ADDR_RESP, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = p8_i2c_occ_getscom(client, OCB_DATA3, (u8 *)resp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (or->return_status == OCC_RESP_CMD_IN_PRG) {\n\t\t\trc = -EALREADY;\n\n\t\t\tif (time_after(jiffies, start + timeout))\n\t\t\t\tbreak;\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(wait_time);\n\t\t}\n\t} while (rc);\n\n\t \n\tswitch (or->return_status) {\n\tcase OCC_RESP_CMD_IN_PRG:\n\t\trc = -ETIMEDOUT;\n\t\tbreak;\n\tcase OCC_RESP_SUCCESS:\n\t\trc = 0;\n\t\tbreak;\n\tcase OCC_RESP_CMD_INVAL:\n\tcase OCC_RESP_CMD_LEN_INVAL:\n\tcase OCC_RESP_DATA_INVAL:\n\tcase OCC_RESP_CHKSUM_ERR:\n\t\trc = -EINVAL;\n\t\tbreak;\n\tcase OCC_RESP_INT_ERR:\n\tcase OCC_RESP_BAD_STATE:\n\tcase OCC_RESP_CRIT_EXCEPT:\n\tcase OCC_RESP_CRIT_INIT:\n\tcase OCC_RESP_CRIT_WATCHDOG:\n\tcase OCC_RESP_CRIT_OCB:\n\tcase OCC_RESP_CRIT_HW:\n\t\trc = -EREMOTEIO;\n\t\tbreak;\n\tdefault:\n\t\trc = -EPROTO;\n\t}\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\tdata_length = get_unaligned_be16(&or->data_length);\n\tif ((data_length + 7) > resp_len)\n\t\treturn -EMSGSIZE;\n\n\t \n\tfor (i = 8; i < data_length + 7; i += 8) {\n\t\trc = p8_i2c_occ_getscom(client, OCB_DATA3, ((u8 *)resp) + i);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int p8_i2c_occ_probe(struct i2c_client *client)\n{\n\tstruct occ *occ;\n\tstruct p8_i2c_occ *ctx = devm_kzalloc(&client->dev, sizeof(*ctx),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->client = client;\n\tocc = &ctx->occ;\n\tocc->bus_dev = &client->dev;\n\tdev_set_drvdata(&client->dev, occ);\n\n\tocc->powr_sample_time_us = 250;\n\tocc->poll_cmd_data = 0x10;\t\t \n\tocc->send_cmd = p8_i2c_occ_send_cmd;\n\n\treturn occ_setup(occ);\n}\n\nstatic void p8_i2c_occ_remove(struct i2c_client *client)\n{\n\tstruct occ *occ = dev_get_drvdata(&client->dev);\n\n\tocc_shutdown(occ);\n}\n\nstatic const struct of_device_id p8_i2c_occ_of_match[] = {\n\t{ .compatible = \"ibm,p8-occ-hwmon\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, p8_i2c_occ_of_match);\n\nstatic struct i2c_driver p8_i2c_occ_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"occ-hwmon\",\n\t\t.of_match_table = p8_i2c_occ_of_match,\n\t},\n\t.probe = p8_i2c_occ_probe,\n\t.remove = p8_i2c_occ_remove,\n};\n\nmodule_i2c_driver(p8_i2c_occ_driver);\n\nMODULE_AUTHOR(\"Eddie James <eajames@linux.ibm.com>\");\nMODULE_DESCRIPTION(\"BMC P8 OCC hwmon driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}