{
  "module_name": "fam15h_power.c",
  "hash_id": "847485af813093070e337dc40ce93ad7f01a7f24f8aaa74aba87490733439364",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/fam15h_power.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <asm/processor.h>\n#include <asm/msr.h>\n\nMODULE_DESCRIPTION(\"AMD Family 15h CPU processor power monitor\");\nMODULE_AUTHOR(\"Andreas Herrmann <herrmann.der.user@googlemail.com>\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define REG_NORTHBRIDGE_CAP\t\t0xe8\n\n \n#define REG_PROCESSOR_TDP\t\t0x1b8\n\n \n#define REG_TDP_RUNNING_AVERAGE\t\t0xe0\n#define REG_TDP_LIMIT3\t\t\t0xe8\n\n#define FAM15H_MIN_NUM_ATTRS\t\t2\n#define FAM15H_NUM_GROUPS\t\t2\n#define MAX_CUS\t\t\t\t8\n\n \n#define MAX_INTERVAL\t\t\t1000\n\n#define PCI_DEVICE_ID_AMD_15H_M70H_NB_F4 0x15b4\n\nstruct fam15h_power_data {\n\tstruct pci_dev *pdev;\n\tunsigned int tdp_to_watts;\n\tunsigned int base_tdp;\n\tunsigned int processor_pwr_watts;\n\tunsigned int cpu_pwr_sample_ratio;\n\tconst struct attribute_group *groups[FAM15H_NUM_GROUPS];\n\tstruct attribute_group group;\n\t \n\tu64 max_cu_acc_power;\n\t \n\tu64 cu_acc_power[MAX_CUS];\n\t \n\tu64 cpu_sw_pwr_ptsc[MAX_CUS];\n\t \n\tint cu_on[MAX_CUS];\n\tunsigned long power_period;\n};\n\nstatic bool is_carrizo_or_later(void)\n{\n\treturn boot_cpu_data.x86 == 0x15 && boot_cpu_data.x86_model >= 0x60;\n}\n\nstatic ssize_t power1_input_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tu32 val, tdp_limit, running_avg_range;\n\ts32 running_avg_capture;\n\tu64 curr_pwr_watts;\n\tstruct fam15h_power_data *data = dev_get_drvdata(dev);\n\tstruct pci_dev *f4 = data->pdev;\n\n\tpci_bus_read_config_dword(f4->bus, PCI_DEVFN(PCI_SLOT(f4->devfn), 5),\n\t\t\t\t  REG_TDP_RUNNING_AVERAGE, &val);\n\n\t \n\tif (is_carrizo_or_later()) {\n\t\trunning_avg_capture = val >> 4;\n\t\trunning_avg_capture = sign_extend32(running_avg_capture, 27);\n\t} else {\n\t\trunning_avg_capture = (val >> 4) & 0x3fffff;\n\t\trunning_avg_capture = sign_extend32(running_avg_capture, 21);\n\t}\n\n\trunning_avg_range = (val & 0xf) + 1;\n\n\tpci_bus_read_config_dword(f4->bus, PCI_DEVFN(PCI_SLOT(f4->devfn), 5),\n\t\t\t\t  REG_TDP_LIMIT3, &val);\n\n\t \n\tif (is_carrizo_or_later())\n\t\ttdp_limit = val >> 16;\n\telse\n\t\ttdp_limit = (val >> 16) & 0x1fff;\n\n\tcurr_pwr_watts = ((u64)(tdp_limit +\n\t\t\t\tdata->base_tdp)) << running_avg_range;\n\tcurr_pwr_watts -= running_avg_capture;\n\tcurr_pwr_watts *= data->tdp_to_watts;\n\n\t \n\tcurr_pwr_watts = (curr_pwr_watts * 15625) >> (10 + running_avg_range);\n\treturn sprintf(buf, \"%u\\n\", (unsigned int) curr_pwr_watts);\n}\nstatic DEVICE_ATTR_RO(power1_input);\n\nstatic ssize_t power1_crit_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fam15h_power_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", data->processor_pwr_watts);\n}\nstatic DEVICE_ATTR_RO(power1_crit);\n\nstatic void do_read_registers_on_cu(void *_data)\n{\n\tstruct fam15h_power_data *data = _data;\n\tint cpu, cu;\n\n\tcpu = smp_processor_id();\n\n\t \n\tcu = cpu_data(cpu).cpu_core_id;\n\n\trdmsrl_safe(MSR_F15H_CU_PWR_ACCUMULATOR, &data->cu_acc_power[cu]);\n\trdmsrl_safe(MSR_F15H_PTSC, &data->cpu_sw_pwr_ptsc[cu]);\n\n\tdata->cu_on[cu] = 1;\n}\n\n \nstatic int read_registers(struct fam15h_power_data *data)\n{\n\tint core, this_core;\n\tcpumask_var_t mask;\n\tint ret, cpu;\n\n\tret = zalloc_cpumask_var(&mask, GFP_KERNEL);\n\tif (!ret)\n\t\treturn -ENOMEM;\n\n\tmemset(data->cu_on, 0, sizeof(int) * MAX_CUS);\n\n\tcpus_read_lock();\n\n\t \n\tcore = -1;\n\n\tfor_each_online_cpu(cpu) {\n\t\tthis_core = topology_core_id(cpu);\n\n\t\tif (this_core == core)\n\t\t\tcontinue;\n\n\t\tcore = this_core;\n\n\t\t \n\t\tcpumask_set_cpu(cpumask_any(topology_sibling_cpumask(cpu)), mask);\n\t}\n\n\ton_each_cpu_mask(mask, do_read_registers_on_cu, data, true);\n\n\tcpus_read_unlock();\n\tfree_cpumask_var(mask);\n\n\treturn 0;\n}\n\nstatic ssize_t power1_average_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct fam15h_power_data *data = dev_get_drvdata(dev);\n\tu64 prev_cu_acc_power[MAX_CUS], prev_ptsc[MAX_CUS],\n\t    jdelta[MAX_CUS];\n\tu64 tdelta, avg_acc;\n\tint cu, cu_num, ret;\n\tsigned long leftover;\n\n\t \n\tcu_num = boot_cpu_data.x86_max_cores;\n\n\tret = read_registers(data);\n\tif (ret)\n\t\treturn 0;\n\n\tfor (cu = 0; cu < cu_num; cu++) {\n\t\tprev_cu_acc_power[cu] = data->cu_acc_power[cu];\n\t\tprev_ptsc[cu] = data->cpu_sw_pwr_ptsc[cu];\n\t}\n\n\tleftover = schedule_timeout_interruptible(msecs_to_jiffies(data->power_period));\n\tif (leftover)\n\t\treturn 0;\n\n\tret = read_registers(data);\n\tif (ret)\n\t\treturn 0;\n\n\tfor (cu = 0, avg_acc = 0; cu < cu_num; cu++) {\n\t\t \n\t\tif (data->cu_on[cu] == 0)\n\t\t\tcontinue;\n\n\t\tif (data->cu_acc_power[cu] < prev_cu_acc_power[cu]) {\n\t\t\tjdelta[cu] = data->max_cu_acc_power + data->cu_acc_power[cu];\n\t\t\tjdelta[cu] -= prev_cu_acc_power[cu];\n\t\t} else {\n\t\t\tjdelta[cu] = data->cu_acc_power[cu] - prev_cu_acc_power[cu];\n\t\t}\n\t\ttdelta = data->cpu_sw_pwr_ptsc[cu] - prev_ptsc[cu];\n\t\tjdelta[cu] *= data->cpu_pwr_sample_ratio * 1000;\n\t\tdo_div(jdelta[cu], tdelta);\n\n\t\t \n\t\tavg_acc += jdelta[cu];\n\t}\n\n\treturn sprintf(buf, \"%llu\\n\", (unsigned long long)avg_acc);\n}\nstatic DEVICE_ATTR_RO(power1_average);\n\nstatic ssize_t power1_average_interval_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct fam15h_power_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lu\\n\", data->power_period);\n}\n\nstatic ssize_t power1_average_interval_store(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct fam15h_power_data *data = dev_get_drvdata(dev);\n\tunsigned long temp;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &temp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (temp > MAX_INTERVAL)\n\t\treturn -EINVAL;\n\n\t \n\tif (temp <= 0)\n\t\treturn -EINVAL;\n\n\tdata->power_period = temp;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(power1_average_interval);\n\nstatic int fam15h_power_init_attrs(struct pci_dev *pdev,\n\t\t\t\t   struct fam15h_power_data *data)\n{\n\tint n = FAM15H_MIN_NUM_ATTRS;\n\tstruct attribute **fam15h_power_attrs;\n\tstruct cpuinfo_x86 *c = &boot_cpu_data;\n\n\tif (c->x86 == 0x15 &&\n\t    (c->x86_model <= 0xf ||\n\t     (c->x86_model >= 0x60 && c->x86_model <= 0x7f)))\n\t\tn += 1;\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_ACC_POWER))\n\t\tn += 2;\n\n\tfam15h_power_attrs = devm_kcalloc(&pdev->dev, n,\n\t\t\t\t\t  sizeof(*fam15h_power_attrs),\n\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!fam15h_power_attrs)\n\t\treturn -ENOMEM;\n\n\tn = 0;\n\tfam15h_power_attrs[n++] = &dev_attr_power1_crit.attr;\n\tif (c->x86 == 0x15 &&\n\t    (c->x86_model <= 0xf ||\n\t     (c->x86_model >= 0x60 && c->x86_model <= 0x7f)))\n\t\tfam15h_power_attrs[n++] = &dev_attr_power1_input.attr;\n\n\tif (boot_cpu_has(X86_FEATURE_ACC_POWER)) {\n\t\tfam15h_power_attrs[n++] = &dev_attr_power1_average.attr;\n\t\tfam15h_power_attrs[n++] = &dev_attr_power1_average_interval.attr;\n\t}\n\n\tdata->group.attrs = fam15h_power_attrs;\n\n\treturn 0;\n}\n\nstatic bool should_load_on_this_node(struct pci_dev *f4)\n{\n\tu32 val;\n\n\tpci_bus_read_config_dword(f4->bus, PCI_DEVFN(PCI_SLOT(f4->devfn), 3),\n\t\t\t\t  REG_NORTHBRIDGE_CAP, &val);\n\tif ((val & BIT(29)) && ((val >> 30) & 3))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic const struct pci_device_id affected_device[] = {\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_NB_F4) },\n\t{ 0 }\n};\n\nstatic void tweak_runavg_range(struct pci_dev *pdev)\n{\n\tu32 val;\n\n\t \n\tif (!pci_match_id(affected_device, pdev))\n\t\treturn;\n\n\tpci_bus_read_config_dword(pdev->bus,\n\t\tPCI_DEVFN(PCI_SLOT(pdev->devfn), 5),\n\t\tREG_TDP_RUNNING_AVERAGE, &val);\n\tif ((val & 0xf) != 0xe)\n\t\treturn;\n\n\tval &= ~0xf;\n\tval |=  0x9;\n\tpci_bus_write_config_dword(pdev->bus,\n\t\tPCI_DEVFN(PCI_SLOT(pdev->devfn), 5),\n\t\tREG_TDP_RUNNING_AVERAGE, val);\n}\n\n#ifdef CONFIG_PM\nstatic int fam15h_power_resume(struct pci_dev *pdev)\n{\n\ttweak_runavg_range(pdev);\n\treturn 0;\n}\n#else\n#define fam15h_power_resume NULL\n#endif\n\nstatic int fam15h_power_init_data(struct pci_dev *f4,\n\t\t\t\t  struct fam15h_power_data *data)\n{\n\tu32 val;\n\tu64 tmp;\n\tint ret;\n\n\tpci_read_config_dword(f4, REG_PROCESSOR_TDP, &val);\n\tdata->base_tdp = val >> 16;\n\ttmp = val & 0xffff;\n\n\tpci_bus_read_config_dword(f4->bus, PCI_DEVFN(PCI_SLOT(f4->devfn), 5),\n\t\t\t\t  REG_TDP_LIMIT3, &val);\n\n\tdata->tdp_to_watts = ((val & 0x3ff) << 6) | ((val >> 10) & 0x3f);\n\ttmp *= data->tdp_to_watts;\n\n\t \n\tif ((tmp >> 16) >= 256)\n\t\tdev_warn(&f4->dev,\n\t\t\t \"Bogus value for ProcessorPwrWatts (processor_pwr_watts>=%u)\\n\",\n\t\t\t (unsigned int) (tmp >> 16));\n\n\t \n\tdata->processor_pwr_watts = (tmp * 15625) >> 10;\n\n\tret = fam15h_power_init_attrs(f4, data);\n\tif (ret)\n\t\treturn ret;\n\n\n\t \n\tif (!boot_cpu_has(X86_FEATURE_ACC_POWER))\n\t\treturn 0;\n\n\t \n\tdata->cpu_pwr_sample_ratio = cpuid_ecx(0x80000007);\n\n\tif (rdmsrl_safe(MSR_F15H_CU_MAX_PWR_ACCUMULATOR, &tmp)) {\n\t\tpr_err(\"Failed to read max compute unit power accumulator MSR\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata->max_cu_acc_power = tmp;\n\n\t \n\tdata->power_period = 10;\n\n\treturn read_registers(data);\n}\n\nstatic int fam15h_power_probe(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *id)\n{\n\tstruct fam15h_power_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct device *hwmon_dev;\n\tint ret;\n\n\t \n\ttweak_runavg_range(pdev);\n\n\tif (!should_load_on_this_node(pdev))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(struct fam15h_power_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = fam15h_power_init_data(pdev, data);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->pdev = pdev;\n\n\tdata->groups[0] = &data->group;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, \"fam15h_power\",\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   &data->groups[0]);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct pci_device_id fam15h_power_id_table[] = {\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_NB_F4) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M30H_NB_F4) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F4) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M70H_NB_F4) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_NB_F4) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F4) },\n\t{}\n};\nMODULE_DEVICE_TABLE(pci, fam15h_power_id_table);\n\nstatic struct pci_driver fam15h_power_driver = {\n\t.name = \"fam15h_power\",\n\t.id_table = fam15h_power_id_table,\n\t.probe = fam15h_power_probe,\n\t.resume = fam15h_power_resume,\n};\n\nmodule_pci_driver(fam15h_power_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}