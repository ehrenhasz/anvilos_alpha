{
  "module_name": "adm9240.c",
  "hash_id": "65e5b27994dbc46748b637078897f2a16894ce71adea3ab231100e07ada785f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adm9240.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-vid.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\tI2C_CLIENT_END };\n\nenum chips { adm9240, ds1780, lm81 };\n\n \n#define ADM9240_REG_MAN_ID\t\t0x3e\n#define ADM9240_REG_DIE_REV\t\t0x3f\n#define ADM9240_REG_CONFIG\t\t0x40\n\n#define ADM9240_REG_IN(nr)\t\t(0x20 + (nr))    \n#define ADM9240_REG_IN_MAX(nr)\t\t(0x2b + (nr) * 2)\n#define ADM9240_REG_IN_MIN(nr)\t\t(0x2c + (nr) * 2)\n#define ADM9240_REG_FAN(nr)\t\t(0x28 + (nr))    \n#define ADM9240_REG_FAN_MIN(nr)\t\t(0x3b + (nr))\n#define ADM9240_REG_INT(nr)\t\t(0x41 + (nr))\n#define ADM9240_REG_INT_MASK(nr)\t(0x43 + (nr))\n#define ADM9240_REG_TEMP\t\t0x27\n#define ADM9240_REG_TEMP_MAX(nr)\t(0x39 + (nr))  \n#define ADM9240_REG_ANALOG_OUT\t\t0x19\n#define ADM9240_REG_CHASSIS_CLEAR\t0x46\n#define ADM9240_REG_VID_FAN_DIV\t\t0x47\n#define ADM9240_REG_I2C_ADDR\t\t0x48\n#define ADM9240_REG_VID4\t\t0x49\n#define ADM9240_REG_TEMP_CONF\t\t0x4b\n\n \nstatic inline int SCALE(long val, int mul, int div)\n{\n\tif (val < 0)\n\t\treturn (val * mul - div / 2) / div;\n\telse\n\t\treturn (val * mul + div / 2) / div;\n}\n\n \nstatic const u16 nom_mv[] = { 2500, 2700, 3300, 5000, 12000, 2700 };\n\nstatic inline unsigned int IN_FROM_REG(u8 reg, int n)\n{\n\treturn SCALE(reg, nom_mv[n], 192);\n}\n\nstatic inline u8 IN_TO_REG(unsigned long val, int n)\n{\n\tval = clamp_val(val, 0, nom_mv[n] * 255 / 192);\n\treturn SCALE(val, 192, nom_mv[n]);\n}\n\n \nstatic inline s8 TEMP_TO_REG(long val)\n{\n\tval = clamp_val(val, -40000, 127000);\n\treturn SCALE(val, 1, 1000);\n}\n\n \nstatic inline unsigned int FAN_FROM_REG(u8 reg, u8 div)\n{\n\tif (!reg)  \n\t\treturn -1;\n\n\tif (reg == 255)\n\t\treturn 0;\n\n\treturn SCALE(1350000, 1, reg * div);\n}\n\n \nstatic inline u8 AOUT_TO_REG(unsigned long val)\n{\n\tval = clamp_val(val, 0, 1250);\n\treturn SCALE(val, 255, 1250);\n}\n\nstatic inline unsigned int AOUT_FROM_REG(u8 reg)\n{\n\treturn SCALE(reg, 1250, 255);\n}\n\n \nstruct adm9240_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct mutex update_lock;\n\n\tu8 fan_div[2];\t\t \n\tu8 vrm;\t\t\t \n};\n\n \nstatic int adm9240_write_fan_div(struct adm9240_data *data, int channel, u8 fan_div)\n{\n\tunsigned int reg, old, shift = (channel + 2) * 2;\n\tint err;\n\n\terr = regmap_read(data->regmap, ADM9240_REG_VID_FAN_DIV, &reg);\n\tif (err < 0)\n\t\treturn err;\n\told = (reg >> shift) & 3;\n\treg &= ~(3 << shift);\n\treg |= (fan_div << shift);\n\terr = regmap_write(data->regmap, ADM9240_REG_VID_FAN_DIV, reg);\n\tif (err < 0)\n\t\treturn err;\n\tdev_dbg(data->dev,\n\t\t\"fan%d clock divider changed from %lu to %lu\\n\",\n\t\tchannel + 1, BIT(old), BIT(fan_div));\n\n\treturn 0;\n}\n\n \nstatic int adm9240_fan_min_write(struct adm9240_data *data, int channel, long val)\n{\n\tu8 new_div;\n\tu8 fan_min;\n\tint err;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (!val) {\n\t\tfan_min = 255;\n\t\tnew_div = data->fan_div[channel];\n\n\t\tdev_dbg(data->dev, \"fan%u low limit set disabled\\n\", channel + 1);\n\t} else if (val < 1350000 / (8 * 254)) {\n\t\tnew_div = 3;\n\t\tfan_min = 254;\n\n\t\tdev_dbg(data->dev, \"fan%u low limit set minimum %u\\n\",\n\t\t\tchannel + 1, FAN_FROM_REG(254, BIT(new_div)));\n\t} else {\n\t\tunsigned int new_min = 1350000 / val;\n\n\t\tnew_div = 0;\n\t\twhile (new_min > 192 && new_div < 3) {\n\t\t\tnew_div++;\n\t\t\tnew_min /= 2;\n\t\t}\n\t\tif (!new_min)  \n\t\t\tnew_min++;\n\n\t\tfan_min = new_min;\n\n\t\tdev_dbg(data->dev, \"fan%u low limit set fan speed %u\\n\",\n\t\t\tchannel + 1, FAN_FROM_REG(new_min, BIT(new_div)));\n\t}\n\n\tif (new_div != data->fan_div[channel]) {\n\t\tdata->fan_div[channel] = new_div;\n\t\tadm9240_write_fan_div(data, channel, new_div);\n\t}\n\terr = regmap_write(data->regmap, ADM9240_REG_FAN_MIN(channel), fan_min);\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn err;\n}\n\nstatic ssize_t cpu0_vid_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct adm9240_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err;\n\tu8 vid;\n\n\terr = regmap_read(data->regmap, ADM9240_REG_VID_FAN_DIV, &regval);\n\tif (err < 0)\n\t\treturn err;\n\tvid = regval & 0x0f;\n\terr = regmap_read(data->regmap, ADM9240_REG_VID4, &regval);\n\tif (err < 0)\n\t\treturn err;\n\tvid |= (regval & 1) << 4;\n\treturn sprintf(buf, \"%d\\n\", vid_from_reg(vid, data->vrm));\n}\nstatic DEVICE_ATTR_RO(cpu0_vid);\n\nstatic ssize_t aout_output_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct adm9240_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err;\n\n\terr = regmap_read(data->regmap, ADM9240_REG_ANALOG_OUT, &regval);\n\tif (err)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%d\\n\", AOUT_FROM_REG(regval));\n}\n\nstatic ssize_t aout_output_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct adm9240_data *data = dev_get_drvdata(dev);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(data->regmap, ADM9240_REG_ANALOG_OUT, AOUT_TO_REG(val));\n\treturn err < 0 ? err : count;\n}\nstatic DEVICE_ATTR_RW(aout_output);\n\nstatic struct attribute *adm9240_attrs[] = {\n\t&dev_attr_aout_output.attr,\n\t&dev_attr_cpu0_vid.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(adm9240);\n\n \n\n \nstatic int adm9240_detect(struct i2c_client *new_client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = new_client->adapter;\n\tconst char *name = \"\";\n\tint address = new_client->addr;\n\tu8 man_id, die_rev;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tif (i2c_smbus_read_byte_data(new_client, ADM9240_REG_I2C_ADDR) != address)\n\t\treturn -ENODEV;\n\n\t \n\tman_id = i2c_smbus_read_byte_data(new_client, ADM9240_REG_MAN_ID);\n\tif (man_id == 0x23)\n\t\tname = \"adm9240\";\n\telse if (man_id == 0xda)\n\t\tname = \"ds1780\";\n\telse if (man_id == 0x01)\n\t\tname = \"lm81\";\n\telse\n\t\treturn -ENODEV;\n\n\t \n\tdie_rev = i2c_smbus_read_byte_data(new_client, ADM9240_REG_DIE_REV);\n\tdev_info(&adapter->dev, \"found %s revision %u\\n\",\n\t\t man_id == 0x23 ? \"ADM9240\" :\n\t\t man_id == 0xda ? \"DS1780\" : \"LM81\", die_rev);\n\n\tstrscpy(info->type, name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int adm9240_init_client(struct adm9240_data *data)\n{\n\tunsigned int regval;\n\tu8 conf, mode;\n\tint err;\n\n\terr = regmap_raw_read(data->regmap, ADM9240_REG_CONFIG, &conf, 1);\n\tif (err < 0)\n\t\treturn err;\n\terr = regmap_raw_read(data->regmap, ADM9240_REG_TEMP_CONF, &mode, 1);\n\tif (err < 0)\n\t\treturn err;\n\tmode &= 3;\n\n\tdata->vrm = vid_which_vrm();  \n\n\tdev_info(data->dev, \"Using VRM: %d.%d\\n\", data->vrm / 10,\n\t\t data->vrm % 10);\n\n\tif (conf & 1) {  \n\n\t\tdev_info(data->dev, \"status: config 0x%02x mode %u\\n\",\n\t\t\t conf, mode);\n\n\t} else {  \n\t\tint i;\n\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\terr = regmap_write(data->regmap,\n\t\t\t\t\t   ADM9240_REG_IN_MIN(i), 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\terr = regmap_write(data->regmap,\n\t\t\t\t\t   ADM9240_REG_IN_MAX(i), 255);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\terr = regmap_write(data->regmap,\n\t\t\t\t\t   ADM9240_REG_FAN_MIN(i), 255);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\terr = regmap_write(data->regmap,\n\t\t\t\t\t   ADM9240_REG_TEMP_MAX(i), 127);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\terr = regmap_write(data->regmap, ADM9240_REG_CONFIG, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdev_info(data->dev,\n\t\t\t \"cold start: config was 0x%02x mode %u\\n\", conf, mode);\n\t}\n\n\t \n\terr = regmap_read(data->regmap, ADM9240_REG_VID_FAN_DIV, &regval);\n\tif (err < 0)\n\t\treturn err;\n\tdata->fan_div[0] = (regval >> 4) & 3;\n\tdata->fan_div[1] = (regval >> 6) & 3;\n\treturn 0;\n}\n\nstatic int adm9240_chip_read(struct device *dev, u32 attr, long *val)\n{\n\tstruct adm9240_data *data = dev_get_drvdata(dev);\n\tu8 regs[2];\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_chip_alarms:\n\t\terr = regmap_bulk_read(data->regmap, ADM9240_REG_INT(0), &regs, 2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = regs[0] | regs[1] << 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int adm9240_intrusion_read(struct device *dev, u32 attr, long *val)\n{\n\tstruct adm9240_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_intrusion_alarm:\n\t\terr = regmap_read(data->regmap, ADM9240_REG_INT(1), &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = !!(regval & BIT(4));\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int adm9240_intrusion_write(struct device *dev, u32 attr, long val)\n{\n\tstruct adm9240_data *data = dev_get_drvdata(dev);\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_intrusion_alarm:\n\t\tif (val)\n\t\t\treturn -EINVAL;\n\t\terr = regmap_write(data->regmap, ADM9240_REG_CHASSIS_CLEAR, 0x80);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdev_dbg(data->dev, \"chassis intrusion latch cleared\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int adm9240_in_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct adm9240_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint reg;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\treg = ADM9240_REG_IN(channel);\n\t\tbreak;\n\tcase hwmon_in_min:\n\t\treg = ADM9240_REG_IN_MIN(channel);\n\t\tbreak;\n\tcase hwmon_in_max:\n\t\treg = ADM9240_REG_IN_MAX(channel);\n\t\tbreak;\n\tcase hwmon_in_alarm:\n\t\tif (channel < 4) {\n\t\t\treg = ADM9240_REG_INT(0);\n\t\t} else {\n\t\t\treg = ADM9240_REG_INT(1);\n\t\t\tchannel -= 4;\n\t\t}\n\t\terr = regmap_read(data->regmap, reg, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = !!(regval & BIT(channel));\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\terr = regmap_read(data->regmap, reg, &regval);\n\tif (err < 0)\n\t\treturn err;\n\t*val = IN_FROM_REG(regval, channel);\n\treturn 0;\n}\n\nstatic int adm9240_in_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct adm9240_data *data = dev_get_drvdata(dev);\n\tint reg;\n\n\tswitch (attr) {\n\tcase hwmon_in_min:\n\t\treg = ADM9240_REG_IN_MIN(channel);\n\t\tbreak;\n\tcase hwmon_in_max:\n\t\treg = ADM9240_REG_IN_MAX(channel);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn regmap_write(data->regmap, reg, IN_TO_REG(val, channel));\n}\n\nstatic int adm9240_fan_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct adm9240_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\t\tmutex_lock(&data->update_lock);\n\t\terr = regmap_read(data->regmap, ADM9240_REG_FAN(channel), &regval);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&data->update_lock);\n\t\t\treturn err;\n\t\t}\n\t\tif (regval == 255 && data->fan_div[channel] < 3) {\n\t\t\t \n\t\t\terr = adm9240_write_fan_div(data, channel,\n\t\t\t\t\t\t    ++data->fan_div[channel]);\n\t\t\tif (err) {\n\t\t\t\tmutex_unlock(&data->update_lock);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\t*val = FAN_FROM_REG(regval, BIT(data->fan_div[channel]));\n\t\tmutex_unlock(&data->update_lock);\n\t\tbreak;\n\tcase hwmon_fan_div:\n\t\t*val = BIT(data->fan_div[channel]);\n\t\tbreak;\n\tcase hwmon_fan_min:\n\t\terr = regmap_read(data->regmap, ADM9240_REG_FAN_MIN(channel), &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = FAN_FROM_REG(regval, BIT(data->fan_div[channel]));\n\t\tbreak;\n\tcase hwmon_fan_alarm:\n\t\terr = regmap_read(data->regmap, ADM9240_REG_INT(0), &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = !!(regval & BIT(channel + 6));\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int adm9240_fan_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct adm9240_data *data = dev_get_drvdata(dev);\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_fan_min:\n\t\terr = adm9240_fan_min_write(data, channel, val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int adm9240_temp_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct adm9240_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err, temp;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\terr = regmap_read(data->regmap, ADM9240_REG_TEMP, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\ttemp = regval << 1;\n\t\terr = regmap_read(data->regmap, ADM9240_REG_TEMP_CONF, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\ttemp |= regval >> 7;\n\t\t*val = sign_extend32(temp, 8) * 500;\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\terr = regmap_read(data->regmap, ADM9240_REG_TEMP_MAX(0), &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = (s8)regval * 1000;\n\t\tbreak;\n\tcase hwmon_temp_max_hyst:\n\t\terr = regmap_read(data->regmap, ADM9240_REG_TEMP_MAX(1), &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = (s8)regval * 1000;\n\t\tbreak;\n\tcase hwmon_temp_alarm:\n\t\terr = regmap_read(data->regmap, ADM9240_REG_INT(0), &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = !!(regval & BIT(4));\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int adm9240_temp_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct adm9240_data *data = dev_get_drvdata(dev);\n\tint reg;\n\n\tswitch (attr) {\n\tcase hwmon_temp_max:\n\t\treg = ADM9240_REG_TEMP_MAX(0);\n\t\tbreak;\n\tcase hwmon_temp_max_hyst:\n\t\treg = ADM9240_REG_TEMP_MAX(1);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn regmap_write(data->regmap, reg, TEMP_TO_REG(val));\n}\n\nstatic int adm9240_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\tint channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn adm9240_chip_read(dev, attr, val);\n\tcase hwmon_intrusion:\n\t\treturn adm9240_intrusion_read(dev, attr, val);\n\tcase hwmon_in:\n\t\treturn adm9240_in_read(dev, attr, channel, val);\n\tcase hwmon_fan:\n\t\treturn adm9240_fan_read(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn adm9240_temp_read(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int adm9240_write(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_intrusion:\n\t\treturn adm9240_intrusion_write(dev, attr, val);\n\tcase hwmon_in:\n\t\treturn adm9240_in_write(dev, attr, channel, val);\n\tcase hwmon_fan:\n\t\treturn adm9240_fan_write(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn adm9240_temp_write(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t adm9240_is_visible(const void *_data, enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tumode_t mode = 0;\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_alarms:\n\t\t\tmode = 0444;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_intrusion:\n\t\tswitch (attr) {\n\t\tcase hwmon_intrusion_alarm:\n\t\t\tmode = 0644;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp:\n\t\tcase hwmon_temp_alarm:\n\t\t\tmode = 0444;\n\t\t\tbreak;\n\t\tcase hwmon_temp_max:\n\t\tcase hwmon_temp_max_hyst:\n\t\t\tmode = 0644;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\tcase hwmon_fan_div:\n\t\tcase hwmon_fan_alarm:\n\t\t\tmode = 0444;\n\t\t\tbreak;\n\t\tcase hwmon_fan_min:\n\t\t\tmode = 0644;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\tcase hwmon_in_alarm:\n\t\t\tmode = 0444;\n\t\t\tbreak;\n\t\tcase hwmon_in_min:\n\t\tcase hwmon_in_max:\n\t\t\tmode = 0644;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn mode;\n}\n\nstatic const struct hwmon_ops adm9240_hwmon_ops = {\n\t.is_visible = adm9240_is_visible,\n\t.read = adm9240_read,\n\t.write = adm9240_write,\n};\n\nstatic const struct hwmon_channel_info * const adm9240_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_ALARMS),\n\tHWMON_CHANNEL_INFO(intrusion, HWMON_INTRUSION_ALARM),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST | HWMON_T_ALARM),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM),\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_DIV | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_DIV | HWMON_F_ALARM),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info adm9240_chip_info = {\n\t.ops = &adm9240_hwmon_ops,\n\t.info = adm9240_info,\n};\n\nstatic bool adm9240_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ADM9240_REG_IN(0) ... ADM9240_REG_IN(5):\n\tcase ADM9240_REG_FAN(0) ... ADM9240_REG_FAN(1):\n\tcase ADM9240_REG_INT(0) ... ADM9240_REG_INT(1):\n\tcase ADM9240_REG_TEMP:\n\tcase ADM9240_REG_TEMP_CONF:\n\tcase ADM9240_REG_VID_FAN_DIV:\n\tcase ADM9240_REG_VID4:\n\tcase ADM9240_REG_ANALOG_OUT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config adm9240_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.use_single_read = true,\n\t.use_single_write = true,\n\t.volatile_reg = adm9240_volatile_reg,\n};\n\nstatic int adm9240_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct adm9240_data *data;\n\tint err;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->dev = dev;\n\tmutex_init(&data->update_lock);\n\tdata->regmap = devm_regmap_init_i2c(client, &adm9240_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\terr = adm9240_init_client(data);\n\tif (err < 0)\n\t\treturn err;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name, data,\n\t\t\t\t\t\t\t &adm9240_chip_info,\n\t\t\t\t\t\t\t adm9240_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id adm9240_id[] = {\n\t{ \"adm9240\", adm9240 },\n\t{ \"ds1780\", ds1780 },\n\t{ \"lm81\", lm81 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adm9240_id);\n\nstatic struct i2c_driver adm9240_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"adm9240\",\n\t},\n\t.probe\t\t= adm9240_probe,\n\t.id_table\t= adm9240_id,\n\t.detect\t\t= adm9240_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(adm9240_driver);\n\nMODULE_AUTHOR(\"Michiel Rook <michiel@grendelproject.nl>, \"\n\t\t\"Grant Coady <gcoady.lk@gmail.com> and others\");\nMODULE_DESCRIPTION(\"ADM9240/DS1780/LM81 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}