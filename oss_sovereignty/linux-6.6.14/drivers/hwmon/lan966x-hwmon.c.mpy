{
  "module_name": "lan966x-hwmon.c",
  "hash_id": "1d50c56894ce8b9be156aa06ca660a46d65251e646528dde45d97a2d171555d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lan966x-hwmon.c",
  "human_readable_source": "\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/hwmon.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/polynomial.h>\n#include <linux/regmap.h>\n\n \n\nstatic const struct polynomial poly_N_to_temp = {\n\t.terms = {\n\t\t{4,  -34627, 1000, 1},\n\t\t{3,  110230, 1000, 1},\n\t\t{2, -191650, 1000, 1},\n\t\t{1,  306040, 1000, 1},\n\t\t{0,  -56197,    1, 1}\n\t}\n};\n\n#define PVT_SENSOR_CTRL\t\t0x0  \n#define PVT_SENSOR_CFG\t\t0x4\n#define   SENSOR_CFG_CLK_CFG\t\tGENMASK(27, 20)\n#define   SENSOR_CFG_TRIM_VAL\t\tGENMASK(13, 9)\n#define   SENSOR_CFG_SAMPLE_ENA\t\tBIT(8)\n#define   SENSOR_CFG_START_CAPTURE\tBIT(7)\n#define   SENSOR_CFG_CONTINIOUS_MODE\tBIT(6)\n#define   SENSOR_CFG_PSAMPLE_ENA\tGENMASK(1, 0)\n#define PVT_SENSOR_STAT\t\t0x8\n#define   SENSOR_STAT_DATA_VALID\tBIT(10)\n#define   SENSOR_STAT_DATA\t\tGENMASK(9, 0)\n\n#define FAN_CFG\t\t\t0x0\n#define   FAN_CFG_DUTY_CYCLE\t\tGENMASK(23, 16)\n#define   INV_POL\t\t\tBIT(3)\n#define   GATE_ENA\t\t\tBIT(2)\n#define   PWM_OPEN_COL_ENA\t\tBIT(1)\n#define   FAN_STAT_CFG\t\t\tBIT(0)\n#define FAN_PWM_FREQ\t\t0x4\n#define   FAN_PWM_CYC_10US\t\tGENMASK(25, 15)\n#define   FAN_PWM_FREQ_FREQ\t\tGENMASK(14, 0)\n#define FAN_CNT\t\t\t0xc\n#define   FAN_CNT_DATA\t\t\tGENMASK(15, 0)\n\n#define LAN966X_PVT_CLK\t\t1200000  \n\nstruct lan966x_hwmon {\n\tstruct regmap *regmap_pvt;\n\tstruct regmap *regmap_fan;\n\tstruct clk *clk;\n\tunsigned long clk_rate;\n};\n\nstatic int lan966x_hwmon_read_temp(struct device *dev, long *val)\n{\n\tstruct lan966x_hwmon *hwmon = dev_get_drvdata(dev);\n\tunsigned int data;\n\tint ret;\n\n\tret = regmap_read(hwmon->regmap_pvt, PVT_SENSOR_STAT, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(data & SENSOR_STAT_DATA_VALID))\n\t\treturn -ENODATA;\n\n\t*val = polynomial_calc(&poly_N_to_temp,\n\t\t\t       FIELD_GET(SENSOR_STAT_DATA, data));\n\n\treturn 0;\n}\n\nstatic int lan966x_hwmon_read_fan(struct device *dev, long *val)\n{\n\tstruct lan966x_hwmon *hwmon = dev_get_drvdata(dev);\n\tunsigned int data;\n\tint ret;\n\n\tret = regmap_read(hwmon->regmap_fan, FAN_CNT, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t*val = FIELD_GET(FAN_CNT_DATA, data) * 60 / 2;\n\n\treturn 0;\n}\n\nstatic int lan966x_hwmon_read_pwm(struct device *dev, long *val)\n{\n\tstruct lan966x_hwmon *hwmon = dev_get_drvdata(dev);\n\tunsigned int data;\n\tint ret;\n\n\tret = regmap_read(hwmon->regmap_fan, FAN_CFG, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = FIELD_GET(FAN_CFG_DUTY_CYCLE, data);\n\n\treturn 0;\n}\n\nstatic int lan966x_hwmon_read_pwm_freq(struct device *dev, long *val)\n{\n\tstruct lan966x_hwmon *hwmon = dev_get_drvdata(dev);\n\tunsigned long tmp;\n\tunsigned int data;\n\tint ret;\n\n\tret = regmap_read(hwmon->regmap_fan, FAN_PWM_FREQ, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdata = FIELD_GET(FAN_PWM_FREQ_FREQ, data) + 1;\n\ttmp = DIV_ROUND_CLOSEST(hwmon->clk_rate, 256);\n\t*val = DIV_ROUND_CLOSEST(tmp, data);\n\n\treturn 0;\n}\n\nstatic int lan966x_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn lan966x_hwmon_read_temp(dev, val);\n\tcase hwmon_fan:\n\t\treturn lan966x_hwmon_read_fan(dev, val);\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\treturn lan966x_hwmon_read_pwm(dev, val);\n\t\tcase hwmon_pwm_freq:\n\t\t\treturn lan966x_hwmon_read_pwm_freq(dev, val);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lan966x_hwmon_write_pwm(struct device *dev, long val)\n{\n\tstruct lan966x_hwmon *hwmon = dev_get_drvdata(dev);\n\n\tif (val < 0 || val > 255)\n\t\treturn -EINVAL;\n\n\treturn regmap_update_bits(hwmon->regmap_fan, FAN_CFG,\n\t\t\t\t  FAN_CFG_DUTY_CYCLE,\n\t\t\t\t  FIELD_PREP(FAN_CFG_DUTY_CYCLE, val));\n}\n\nstatic int lan966x_hwmon_write_pwm_freq(struct device *dev, long val)\n{\n\tstruct lan966x_hwmon *hwmon = dev_get_drvdata(dev);\n\n\tif (val <= 0)\n\t\treturn -EINVAL;\n\n\tval = DIV_ROUND_CLOSEST(hwmon->clk_rate, val);\n\tval = DIV_ROUND_CLOSEST(val, 256) - 1;\n\tval = clamp_val(val, 0, FAN_PWM_FREQ_FREQ);\n\n\treturn regmap_update_bits(hwmon->regmap_fan, FAN_PWM_FREQ,\n\t\t\t\t  FAN_PWM_FREQ_FREQ,\n\t\t\t\t  FIELD_PREP(FAN_PWM_FREQ_FREQ, val));\n}\n\nstatic int lan966x_hwmon_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t       u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\treturn lan966x_hwmon_write_pwm(dev, val);\n\t\tcase hwmon_pwm_freq:\n\t\t\treturn lan966x_hwmon_write_pwm_freq(dev, val);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t lan966x_hwmon_is_visible(const void *data,\n\t\t\t\t\tenum hwmon_sensor_types type,\n\t\t\t\t\tu32 attr, int channel)\n{\n\tumode_t mode = 0;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\tmode = 0444;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\tmode = 0444;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\tcase hwmon_pwm_freq:\n\t\t\tmode = 0644;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n\nstatic const struct hwmon_channel_info * const lan966x_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT),\n\tHWMON_CHANNEL_INFO(fan, HWMON_F_INPUT),\n\tHWMON_CHANNEL_INFO(pwm, HWMON_PWM_INPUT | HWMON_PWM_FREQ),\n\tNULL\n};\n\nstatic const struct hwmon_ops lan966x_hwmon_ops = {\n\t.is_visible = lan966x_hwmon_is_visible,\n\t.read = lan966x_hwmon_read,\n\t.write = lan966x_hwmon_write,\n};\n\nstatic const struct hwmon_chip_info lan966x_hwmon_chip_info = {\n\t.ops = &lan966x_hwmon_ops,\n\t.info = lan966x_hwmon_info,\n};\n\nstatic void lan966x_hwmon_disable(void *data)\n{\n\tstruct lan966x_hwmon *hwmon = data;\n\n\tregmap_update_bits(hwmon->regmap_pvt, PVT_SENSOR_CFG,\n\t\t\t   SENSOR_CFG_SAMPLE_ENA | SENSOR_CFG_CONTINIOUS_MODE,\n\t\t\t   0);\n}\n\nstatic int lan966x_hwmon_enable(struct device *dev,\n\t\t\t\tstruct lan966x_hwmon *hwmon)\n{\n\tunsigned int mask = SENSOR_CFG_CLK_CFG |\n\t\t\t    SENSOR_CFG_SAMPLE_ENA |\n\t\t\t    SENSOR_CFG_START_CAPTURE |\n\t\t\t    SENSOR_CFG_CONTINIOUS_MODE |\n\t\t\t    SENSOR_CFG_PSAMPLE_ENA;\n\tunsigned int val;\n\tunsigned int div;\n\tint ret;\n\n\t \n\tval = SENSOR_CFG_SAMPLE_ENA | SENSOR_CFG_CONTINIOUS_MODE;\n\n\t \n\tdiv = DIV_ROUND_CLOSEST(hwmon->clk_rate, LAN966X_PVT_CLK);\n\tval |= FIELD_PREP(SENSOR_CFG_CLK_CFG, div);\n\n\tret = regmap_update_bits(hwmon->regmap_pvt, PVT_SENSOR_CFG,\n\t\t\t\t mask, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, lan966x_hwmon_disable, hwmon);\n}\n\nstatic struct regmap *lan966x_init_regmap(struct platform_device *pdev,\n\t\t\t\t\t  const char *name)\n{\n\tstruct regmap_config regmap_config = {\n\t\t.reg_bits = 32,\n\t\t.reg_stride = 4,\n\t\t.val_bits = 32,\n\t};\n\tvoid __iomem *base;\n\n\tbase = devm_platform_ioremap_resource_byname(pdev, name);\n\tif (IS_ERR(base))\n\t\treturn ERR_CAST(base);\n\n\tregmap_config.name = name;\n\n\treturn devm_regmap_init_mmio(&pdev->dev, base, &regmap_config);\n}\n\nstatic int lan966x_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct lan966x_hwmon *hwmon;\n\tstruct device *hwmon_dev;\n\tint ret;\n\n\thwmon = devm_kzalloc(dev, sizeof(*hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn -ENOMEM;\n\n\thwmon->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(hwmon->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(hwmon->clk),\n\t\t\t\t     \"failed to get clock\\n\");\n\n\thwmon->clk_rate = clk_get_rate(hwmon->clk);\n\n\thwmon->regmap_pvt = lan966x_init_regmap(pdev, \"pvt\");\n\tif (IS_ERR(hwmon->regmap_pvt))\n\t\treturn dev_err_probe(dev, PTR_ERR(hwmon->regmap_pvt),\n\t\t\t\t     \"failed to get regmap for PVT registers\\n\");\n\n\thwmon->regmap_fan = lan966x_init_regmap(pdev, \"fan\");\n\tif (IS_ERR(hwmon->regmap_fan))\n\t\treturn dev_err_probe(dev, PTR_ERR(hwmon->regmap_fan),\n\t\t\t\t     \"failed to get regmap for fan registers\\n\");\n\n\tret = lan966x_hwmon_enable(dev, hwmon);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to enable sensor\\n\");\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&pdev->dev,\n\t\t\t\t\"lan966x_hwmon\", hwmon,\n\t\t\t\t&lan966x_hwmon_chip_info, NULL);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn dev_err_probe(dev, PTR_ERR(hwmon_dev),\n\t\t\t\t     \"failed to register hwmon device\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id lan966x_hwmon_of_match[] = {\n\t{ .compatible = \"microchip,lan9668-hwmon\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lan966x_hwmon_of_match);\n\nstatic struct platform_driver lan966x_hwmon_driver = {\n\t.probe = lan966x_hwmon_probe,\n\t.driver = {\n\t\t.name = \"lan966x-hwmon\",\n\t\t.of_match_table = lan966x_hwmon_of_match,\n\t},\n};\nmodule_platform_driver(lan966x_hwmon_driver);\n\nMODULE_DESCRIPTION(\"LAN966x Hardware Monitoring Driver\");\nMODULE_AUTHOR(\"Michael Walle <michael@walle.cc>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}