{
  "module_name": "max197.c",
  "hash_id": "1a112280a08411b3737da14cba9cd8d6dd134675620462526df1c484102ec916",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max197.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/max197.h>\n\n#define MAX199_LIMIT\t4000\t\t \n#define MAX197_LIMIT\t10000\t\t \n\n#define MAX197_NUM_CH\t8\t\t \n\n \n#define MAX197_BIP\t(1 << 3)\t \n#define MAX197_RNG\t(1 << 4)\t \n\n#define MAX197_SCALE\t12207\t\t \n\n \nenum max197_chips { max197, max199 };\n\n \nstruct max197_data {\n\tstruct max197_platform_data *pdata;\n\tstruct device *hwmon_dev;\n\tstruct mutex lock;\n\tint limit;\n\tbool scale;\n\tu8 ctrl_bytes[MAX197_NUM_CH];\n};\n\nstatic inline void max197_set_unipolarity(struct max197_data *data, int channel)\n{\n\tdata->ctrl_bytes[channel] &= ~MAX197_BIP;\n}\n\nstatic inline void max197_set_bipolarity(struct max197_data *data, int channel)\n{\n\tdata->ctrl_bytes[channel] |= MAX197_BIP;\n}\n\nstatic inline void max197_set_half_range(struct max197_data *data, int channel)\n{\n\tdata->ctrl_bytes[channel] &= ~MAX197_RNG;\n}\n\nstatic inline void max197_set_full_range(struct max197_data *data, int channel)\n{\n\tdata->ctrl_bytes[channel] |= MAX197_RNG;\n}\n\nstatic inline bool max197_is_bipolar(struct max197_data *data, int channel)\n{\n\treturn data->ctrl_bytes[channel] & MAX197_BIP;\n}\n\nstatic inline bool max197_is_full_range(struct max197_data *data, int channel)\n{\n\treturn data->ctrl_bytes[channel] & MAX197_RNG;\n}\n\n \nstatic ssize_t max197_show_range(struct device *dev,\n\t\t\t\t struct device_attribute *devattr, char *buf)\n{\n\tstruct max197_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tint channel = attr->index;\n\tbool is_min = attr->nr;\n\tint range;\n\n\tif (mutex_lock_interruptible(&data->lock))\n\t\treturn -ERESTARTSYS;\n\n\trange = max197_is_full_range(data, channel) ?\n\t\tdata->limit : data->limit / 2;\n\tif (is_min) {\n\t\tif (max197_is_bipolar(data, channel))\n\t\t\trange = -range;\n\t\telse\n\t\t\trange = 0;\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn sprintf(buf, \"%d\\n\", range);\n}\n\n \nstatic ssize_t max197_store_range(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct max197_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tint channel = attr->index;\n\tbool is_min = attr->nr;\n\tlong value;\n\tint half = data->limit / 2;\n\tint full = data->limit;\n\n\tif (kstrtol(buf, 10, &value))\n\t\treturn -EINVAL;\n\n\tif (is_min) {\n\t\tif (value <= -full)\n\t\t\tvalue = -full;\n\t\telse if (value < 0)\n\t\t\tvalue = -half;\n\t\telse\n\t\t\tvalue = 0;\n\t} else {\n\t\tif (value >= full)\n\t\t\tvalue = full;\n\t\telse\n\t\t\tvalue = half;\n\t}\n\n\tif (mutex_lock_interruptible(&data->lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (value == 0) {\n\t\t \n\t\tmax197_set_unipolarity(data, channel);\n\t} else if (value == -half) {\n\t\tmax197_set_bipolarity(data, channel);\n\t\tmax197_set_half_range(data, channel);\n\t} else if (value == -full) {\n\t\tmax197_set_bipolarity(data, channel);\n\t\tmax197_set_full_range(data, channel);\n\t} else if (value == half) {\n\t\t \n\t\tmax197_set_half_range(data, channel);\n\t} else if (value == full) {\n\t\t \n\t\tmax197_set_full_range(data, channel);\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\n \nstatic ssize_t max197_show_input(struct device *dev,\n\t\t\t\t struct device_attribute *devattr,\n\t\t\t\t char *buf)\n{\n\tstruct max197_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tint channel = attr->index;\n\ts32 value;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&data->lock))\n\t\treturn -ERESTARTSYS;\n\n\tret = data->pdata->convert(data->ctrl_bytes[channel]);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"conversion failed\\n\");\n\t\tgoto unlock;\n\t}\n\tvalue = ret;\n\n\t \n\tif (data->scale) {\n\t\tvalue *= MAX197_SCALE;\n\t\tif (max197_is_full_range(data, channel))\n\t\t\tvalue *= 2;\n\t\tvalue /= 10000;\n\t}\n\n\tret = sprintf(buf, \"%d\\n\", value);\n\nunlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\treturn sprintf(buf, \"%s\\n\", pdev->name);\n}\n\n#define MAX197_SENSOR_DEVICE_ATTR_CH(chan)\t\t\t\t\\\n\tstatic SENSOR_DEVICE_ATTR(in##chan##_input, S_IRUGO,\t\t\\\n\t\t\t\t  max197_show_input, NULL, chan);\t\\\n\tstatic SENSOR_DEVICE_ATTR_2(in##chan##_min, S_IRUGO | S_IWUSR,\t\\\n\t\t\t\t    max197_show_range,\t\t\t\\\n\t\t\t\t    max197_store_range,\t\t\t\\\n\t\t\t\t    true, chan);\t\t\t\\\n\tstatic SENSOR_DEVICE_ATTR_2(in##chan##_max, S_IRUGO | S_IWUSR,\t\\\n\t\t\t\t    max197_show_range,\t\t\t\\\n\t\t\t\t    max197_store_range,\t\t\t\\\n\t\t\t\t    false, chan)\n\n#define MAX197_SENSOR_DEV_ATTR_IN(chan)\t\t\t\t\t\\\n\t&sensor_dev_attr_in##chan##_input.dev_attr.attr,\t\t\\\n\t&sensor_dev_attr_in##chan##_max.dev_attr.attr,\t\t\t\\\n\t&sensor_dev_attr_in##chan##_min.dev_attr.attr\n\nstatic DEVICE_ATTR_RO(name);\n\nMAX197_SENSOR_DEVICE_ATTR_CH(0);\nMAX197_SENSOR_DEVICE_ATTR_CH(1);\nMAX197_SENSOR_DEVICE_ATTR_CH(2);\nMAX197_SENSOR_DEVICE_ATTR_CH(3);\nMAX197_SENSOR_DEVICE_ATTR_CH(4);\nMAX197_SENSOR_DEVICE_ATTR_CH(5);\nMAX197_SENSOR_DEVICE_ATTR_CH(6);\nMAX197_SENSOR_DEVICE_ATTR_CH(7);\n\nstatic const struct attribute_group max197_sysfs_group = {\n\t.attrs = (struct attribute *[]) {\n\t\t&dev_attr_name.attr,\n\t\tMAX197_SENSOR_DEV_ATTR_IN(0),\n\t\tMAX197_SENSOR_DEV_ATTR_IN(1),\n\t\tMAX197_SENSOR_DEV_ATTR_IN(2),\n\t\tMAX197_SENSOR_DEV_ATTR_IN(3),\n\t\tMAX197_SENSOR_DEV_ATTR_IN(4),\n\t\tMAX197_SENSOR_DEV_ATTR_IN(5),\n\t\tMAX197_SENSOR_DEV_ATTR_IN(6),\n\t\tMAX197_SENSOR_DEV_ATTR_IN(7),\n\t\tNULL\n\t},\n};\n\nstatic int max197_probe(struct platform_device *pdev)\n{\n\tint ch, ret;\n\tstruct max197_data *data;\n\tstruct max197_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tenum max197_chips chip = platform_get_device_id(pdev)->driver_data;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&pdev->dev, \"no platform data supplied\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->convert == NULL) {\n\t\tdev_err(&pdev->dev, \"no convert function supplied\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct max197_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->pdata = pdata;\n\tmutex_init(&data->lock);\n\n\tif (chip == max197) {\n\t\tdata->limit = MAX197_LIMIT;\n\t\tdata->scale = true;\n\t} else {\n\t\tdata->limit = MAX199_LIMIT;\n\t\tdata->scale = false;\n\t}\n\n\tfor (ch = 0; ch < MAX197_NUM_CH; ch++)\n\t\tdata->ctrl_bytes[ch] = (u8) ch;\n\n\tplatform_set_drvdata(pdev, data);\n\n\tret = sysfs_create_group(&pdev->dev.kobj, &max197_sysfs_group);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"sysfs create group failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->hwmon_dev = hwmon_device_register(&pdev->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\tret = PTR_ERR(data->hwmon_dev);\n\t\tdev_err(&pdev->dev, \"hwmon device register failed\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tsysfs_remove_group(&pdev->dev.kobj, &max197_sysfs_group);\n\treturn ret;\n}\n\nstatic int max197_remove(struct platform_device *pdev)\n{\n\tstruct max197_data *data = platform_get_drvdata(pdev);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tsysfs_remove_group(&pdev->dev.kobj, &max197_sysfs_group);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id max197_device_ids[] = {\n\t{ \"max197\", max197 },\n\t{ \"max199\", max199 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, max197_device_ids);\n\nstatic struct platform_driver max197_driver = {\n\t.driver = {\n\t\t.name = \"max197\",\n\t},\n\t.probe = max197_probe,\n\t.remove = max197_remove,\n\t.id_table = max197_device_ids,\n};\nmodule_platform_driver(max197_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Savoir-faire Linux Inc. <kernel@savoirfairelinux.com>\");\nMODULE_DESCRIPTION(\"Maxim MAX197 A/D Converter driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}