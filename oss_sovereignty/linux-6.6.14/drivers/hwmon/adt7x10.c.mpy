{
  "module_name": "adt7x10.c",
  "hash_id": "b1bc0bab82f8cea55a6c5b95907cf755e6b9be4057ca74f642625f357806233f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adt7x10.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/hwmon.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/regmap.h>\n\n#include \"adt7x10.h\"\n\n \n#define ADT7X10_STAT_T_LOW\t\t(1 << 4)\n#define ADT7X10_STAT_T_HIGH\t\t(1 << 5)\n#define ADT7X10_STAT_T_CRIT\t\t(1 << 6)\n#define ADT7X10_STAT_NOT_RDY\t\t(1 << 7)\n\n \n#define ADT7X10_FAULT_QUEUE_MASK\t(1 << 0 | 1 << 1)\n#define ADT7X10_CT_POLARITY\t\t(1 << 2)\n#define ADT7X10_INT_POLARITY\t\t(1 << 3)\n#define ADT7X10_EVENT_MODE\t\t(1 << 4)\n#define ADT7X10_MODE_MASK\t\t(1 << 5 | 1 << 6)\n#define ADT7X10_FULL\t\t\t(0 << 5 | 0 << 6)\n#define ADT7X10_PD\t\t\t(1 << 5 | 1 << 6)\n#define ADT7X10_RESOLUTION\t\t(1 << 7)\n\n \n#define ADT7X10_T13_VALUE_MASK\t\t0xFFF8\n#define ADT7X10_T_HYST_MASK\t\t0xF\n\n \n#define ADT7X10_TEMP_MIN (-55000)\n#define ADT7X10_TEMP_MAX 150000\n\n \nstruct adt7x10_data {\n\tstruct regmap\t\t*regmap;\n\tstruct mutex\t\tupdate_lock;\n\tu8\t\t\tconfig;\n\tu8\t\t\toldconfig;\n\tbool\t\t\tvalid;\t\t \n};\n\nenum {\n\tadt7x10_temperature = 0,\n\tadt7x10_t_alarm_high,\n\tadt7x10_t_alarm_low,\n\tadt7x10_t_crit,\n};\n\nstatic const u8 ADT7X10_REG_TEMP[] = {\n\t[adt7x10_temperature] = ADT7X10_TEMPERATURE,\t\t \n\t[adt7x10_t_alarm_high] = ADT7X10_T_ALARM_HIGH,\t\t \n\t[adt7x10_t_alarm_low] = ADT7X10_T_ALARM_LOW,\t\t \n\t[adt7x10_t_crit] = ADT7X10_T_CRIT,\t\t\t \n};\n\nstatic irqreturn_t adt7x10_irq_handler(int irq, void *private)\n{\n\tstruct device *dev = private;\n\tstruct adt7x10_data *d = dev_get_drvdata(dev);\n\tunsigned int status;\n\tint ret;\n\n\tret = regmap_read(d->regmap, ADT7X10_STATUS, &status);\n\tif (ret < 0)\n\t\treturn IRQ_HANDLED;\n\n\tif (status & ADT7X10_STAT_T_HIGH)\n\t\thwmon_notify_event(dev, hwmon_temp, hwmon_temp_max_alarm, 0);\n\tif (status & ADT7X10_STAT_T_LOW)\n\t\thwmon_notify_event(dev, hwmon_temp, hwmon_temp_min_alarm, 0);\n\tif (status & ADT7X10_STAT_T_CRIT)\n\t\thwmon_notify_event(dev, hwmon_temp, hwmon_temp_crit_alarm, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adt7x10_temp_ready(struct regmap *regmap)\n{\n\tunsigned int status;\n\tint i, ret;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tret = regmap_read(regmap, ADT7X10_STATUS, &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!(status & ADT7X10_STAT_NOT_RDY))\n\t\t\treturn 0;\n\t\tmsleep(60);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic s16 ADT7X10_TEMP_TO_REG(long temp)\n{\n\treturn DIV_ROUND_CLOSEST(clamp_val(temp, ADT7X10_TEMP_MIN,\n\t\t\t\t\t   ADT7X10_TEMP_MAX) * 128, 1000);\n}\n\nstatic int ADT7X10_REG_TO_TEMP(struct adt7x10_data *data, s16 reg)\n{\n\t \n\tif (!(data->config & ADT7X10_RESOLUTION))\n\t\treg &= ADT7X10_T13_VALUE_MASK;\n\t \n\treturn DIV_ROUND_CLOSEST(reg * 1000, 128);\n}\n\n \n\nstatic int adt7x10_temp_read(struct adt7x10_data *data, int index, long *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tmutex_lock(&data->update_lock);\n\tif (index == adt7x10_temperature && !data->valid) {\n\t\t \n\t\tret = adt7x10_temp_ready(data->regmap);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&data->update_lock);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->valid = true;\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\tret = regmap_read(data->regmap, ADT7X10_REG_TEMP[index], &regval);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = ADT7X10_REG_TO_TEMP(data, regval);\n\treturn 0;\n}\n\nstatic int adt7x10_temp_write(struct adt7x10_data *data, int index, long temp)\n{\n\tint ret;\n\n\tmutex_lock(&data->update_lock);\n\tret = regmap_write(data->regmap, ADT7X10_REG_TEMP[index],\n\t\t\t   ADT7X10_TEMP_TO_REG(temp));\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic int adt7x10_hyst_read(struct adt7x10_data *data, int index, long *val)\n{\n\tint hyst, temp, ret;\n\n\tmutex_lock(&data->update_lock);\n\tret = regmap_read(data->regmap, ADT7X10_T_HYST, &hyst);\n\tif (ret) {\n\t\tmutex_unlock(&data->update_lock);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(data->regmap, ADT7X10_REG_TEMP[index], &temp);\n\tmutex_unlock(&data->update_lock);\n\tif (ret)\n\t\treturn ret;\n\n\thyst = (hyst & ADT7X10_T_HYST_MASK) * 1000;\n\n\t \n\t \n\tif (index == adt7x10_t_alarm_low)\n\t\thyst = -hyst;\n\n\t*val = ADT7X10_REG_TO_TEMP(data, temp) - hyst;\n\treturn 0;\n}\n\nstatic int adt7x10_hyst_write(struct adt7x10_data *data, long hyst)\n{\n\tunsigned int regval;\n\tint limit, ret;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tret = regmap_read(data->regmap, ADT7X10_T_ALARM_HIGH, &regval);\n\tif (ret < 0)\n\t\tgoto abort;\n\n\tlimit = ADT7X10_REG_TO_TEMP(data, regval);\n\n\thyst = clamp_val(hyst, ADT7X10_TEMP_MIN, ADT7X10_TEMP_MAX);\n\tregval = clamp_val(DIV_ROUND_CLOSEST(limit - hyst, 1000), 0,\n\t\t\t   ADT7X10_T_HYST_MASK);\n\tret = regmap_write(data->regmap, ADT7X10_T_HYST, regval);\nabort:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic int adt7x10_alarm_read(struct adt7x10_data *data, int index, long *val)\n{\n\tunsigned int status;\n\tint ret;\n\n\tret = regmap_read(data->regmap, ADT7X10_STATUS, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = !!(status & index);\n\n\treturn 0;\n}\n\nstatic umode_t adt7x10_is_visible(const void *data,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_temp_max:\n\tcase hwmon_temp_min:\n\tcase hwmon_temp_crit:\n\tcase hwmon_temp_max_hyst:\n\t\treturn 0644;\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_min_alarm:\n\tcase hwmon_temp_max_alarm:\n\tcase hwmon_temp_crit_alarm:\n\tcase hwmon_temp_min_hyst:\n\tcase hwmon_temp_crit_hyst:\n\t\treturn 0444;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int adt7x10_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct adt7x10_data *data = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treturn adt7x10_temp_read(data, adt7x10_temperature, val);\n\tcase hwmon_temp_max:\n\t\treturn adt7x10_temp_read(data, adt7x10_t_alarm_high, val);\n\tcase hwmon_temp_min:\n\t\treturn adt7x10_temp_read(data, adt7x10_t_alarm_low, val);\n\tcase hwmon_temp_crit:\n\t\treturn adt7x10_temp_read(data, adt7x10_t_crit, val);\n\tcase hwmon_temp_max_hyst:\n\t\treturn adt7x10_hyst_read(data, adt7x10_t_alarm_high, val);\n\tcase hwmon_temp_min_hyst:\n\t\treturn adt7x10_hyst_read(data, adt7x10_t_alarm_low, val);\n\tcase hwmon_temp_crit_hyst:\n\t\treturn adt7x10_hyst_read(data, adt7x10_t_crit, val);\n\tcase hwmon_temp_min_alarm:\n\t\treturn adt7x10_alarm_read(data, ADT7X10_STAT_T_LOW, val);\n\tcase hwmon_temp_max_alarm:\n\t\treturn adt7x10_alarm_read(data, ADT7X10_STAT_T_HIGH, val);\n\tcase hwmon_temp_crit_alarm:\n\t\treturn adt7x10_alarm_read(data, ADT7X10_STAT_T_CRIT, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int adt7x10_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long val)\n{\n\tstruct adt7x10_data *data = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_temp_max:\n\t\treturn adt7x10_temp_write(data, adt7x10_t_alarm_high, val);\n\tcase hwmon_temp_min:\n\t\treturn adt7x10_temp_write(data, adt7x10_t_alarm_low, val);\n\tcase hwmon_temp_crit:\n\t\treturn adt7x10_temp_write(data, adt7x10_t_crit, val);\n\tcase hwmon_temp_max_hyst:\n\t\treturn adt7x10_hyst_write(data, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const adt7x10_info[] = {\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t   HWMON_T_CRIT | HWMON_T_MAX_HYST | HWMON_T_MIN_HYST |\n\t\t\t   HWMON_T_CRIT_HYST | HWMON_T_MIN_ALARM |\n\t\t\t   HWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM),\n\tNULL,\n};\n\nstatic const struct hwmon_ops adt7x10_hwmon_ops = {\n\t.is_visible = adt7x10_is_visible,\n\t.read = adt7x10_read,\n\t.write = adt7x10_write,\n};\n\nstatic const struct hwmon_chip_info adt7x10_chip_info = {\n\t.ops = &adt7x10_hwmon_ops,\n\t.info = adt7x10_info,\n};\n\nstatic void adt7x10_restore_config(void *private)\n{\n\tstruct adt7x10_data *data = private;\n\n\tregmap_write(data->regmap, ADT7X10_CONFIG, data->oldconfig);\n}\n\nint adt7x10_probe(struct device *dev, const char *name, int irq,\n\t\t  struct regmap *regmap)\n{\n\tstruct adt7x10_data *data;\n\tunsigned int config;\n\tstruct device *hdev;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = regmap;\n\n\tdev_set_drvdata(dev, data);\n\tmutex_init(&data->update_lock);\n\n\t \n\tret = regmap_read(regmap, ADT7X10_CONFIG, &config);\n\tif (ret < 0) {\n\t\tdev_dbg(dev, \"Can't read config? %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdata->oldconfig = config;\n\n\t \n\tdata->config = data->oldconfig;\n\tdata->config &= ~(ADT7X10_MODE_MASK | ADT7X10_CT_POLARITY |\n\t\t\tADT7X10_INT_POLARITY);\n\tdata->config |= ADT7X10_FULL | ADT7X10_RESOLUTION | ADT7X10_EVENT_MODE;\n\n\tif (data->config != data->oldconfig) {\n\t\tret = regmap_write(regmap, ADT7X10_CONFIG, data->config);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = devm_add_action_or_reset(dev, adt7x10_restore_config, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tdev_dbg(dev, \"Config %02x\\n\", data->config);\n\n\thdev = devm_hwmon_device_register_with_info(dev, name, data,\n\t\t\t\t\t\t    &adt7x10_chip_info, NULL);\n\tif (IS_ERR(hdev))\n\t\treturn PTR_ERR(hdev);\n\n\tif (irq > 0) {\n\t\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t\t\tadt7x10_irq_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(dev), hdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adt7x10_probe);\n\nstatic int adt7x10_suspend(struct device *dev)\n{\n\tstruct adt7x10_data *data = dev_get_drvdata(dev);\n\n\treturn regmap_write(data->regmap, ADT7X10_CONFIG,\n\t\t\t    data->config | ADT7X10_PD);\n}\n\nstatic int adt7x10_resume(struct device *dev)\n{\n\tstruct adt7x10_data *data = dev_get_drvdata(dev);\n\n\treturn regmap_write(data->regmap, ADT7X10_CONFIG, data->config);\n}\n\nEXPORT_SIMPLE_DEV_PM_OPS(adt7x10_dev_pm_ops, adt7x10_suspend, adt7x10_resume);\n\nMODULE_AUTHOR(\"Hartmut Knaack\");\nMODULE_DESCRIPTION(\"ADT7410/ADT7420, ADT7310/ADT7320 common code\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}