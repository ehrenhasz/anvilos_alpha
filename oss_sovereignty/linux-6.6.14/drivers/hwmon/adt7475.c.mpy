{
  "module_name": "adt7475.c",
  "hash_id": "797903c58be4d3d7663f561aadff0d932ff706dea0fae30b20374f9ad2c61db0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adt7475.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon-vid.h>\n#include <linux/err.h>\n#include <linux/jiffies.h>\n#include <linux/of.h>\n#include <linux/util_macros.h>\n\n \n\n#define INPUT\t\t0\n#define MIN\t\t1\n#define MAX\t\t2\n#define CONTROL\t\t3\n#define OFFSET\t\t3\n#define AUTOMIN\t\t4\n#define THERM\t\t5\n#define HYSTERSIS\t6\n\n \n\n#define ALARM\t\t9\n#define FAULT\t\t10\n\n \n\n#define REG_DEVREV2\t\t0x12\t \n\n#define REG_VTT\t\t\t0x1E\t \n#define REG_EXTEND3\t\t0x1F\t \n\n#define REG_VOLTAGE_BASE\t0x20\n#define REG_TEMP_BASE\t\t0x25\n#define REG_TACH_BASE\t\t0x28\n#define REG_PWM_BASE\t\t0x30\n#define REG_PWM_MAX_BASE\t0x38\n\n#define REG_DEVID\t\t0x3D\n#define REG_VENDID\t\t0x3E\n#define REG_DEVID2\t\t0x3F\n\n#define REG_CONFIG1\t\t0x40\n\n#define REG_STATUS1\t\t0x41\n#define REG_STATUS2\t\t0x42\n\n#define REG_VID\t\t\t0x43\t \n\n#define REG_VOLTAGE_MIN_BASE\t0x44\n#define REG_VOLTAGE_MAX_BASE\t0x45\n\n#define REG_TEMP_MIN_BASE\t0x4E\n#define REG_TEMP_MAX_BASE\t0x4F\n\n#define REG_TACH_MIN_BASE\t0x54\n\n#define REG_PWM_CONFIG_BASE\t0x5C\n\n#define REG_TEMP_TRANGE_BASE\t0x5F\n\n#define REG_ENHANCE_ACOUSTICS1\t0x62\n#define REG_ENHANCE_ACOUSTICS2\t0x63\n\n#define REG_PWM_MIN_BASE\t0x64\n\n#define REG_TEMP_TMIN_BASE\t0x67\n#define REG_TEMP_THERM_BASE\t0x6A\n\n#define REG_REMOTE1_HYSTERSIS\t0x6D\n#define REG_REMOTE2_HYSTERSIS\t0x6E\n\n#define REG_TEMP_OFFSET_BASE\t0x70\n\n#define REG_CONFIG2\t\t0x73\n\n#define REG_EXTEND1\t\t0x76\n#define REG_EXTEND2\t\t0x77\n\n#define REG_CONFIG3\t\t0x78\n#define REG_CONFIG5\t\t0x7C\n#define REG_CONFIG4\t\t0x7D\n\n#define REG_STATUS4\t\t0x81\t \n\n#define REG_VTT_MIN\t\t0x84\t \n#define REG_VTT_MAX\t\t0x86\t \n\n#define VID_VIDSEL\t\t0x80\t \n\n#define CONFIG2_ATTN\t\t0x20\n\n#define CONFIG3_SMBALERT\t0x01\n#define CONFIG3_THERM\t\t0x02\n\n#define CONFIG4_PINFUNC\t\t0x03\n#define CONFIG4_THERM\t\t0x01\n#define CONFIG4_SMBALERT\t0x02\n#define CONFIG4_MAXDUTY\t\t0x08\n#define CONFIG4_ATTN_IN10\t0x30\n#define CONFIG4_ATTN_IN43\t0xC0\n\n#define CONFIG5_TWOSCOMP\t0x01\n#define CONFIG5_TEMPOFFSET\t0x02\n#define CONFIG5_VIDGPIO\t\t0x10\t \n\n \n\n#define ADT7475_VOLTAGE_COUNT\t5\t \n#define ADT7475_TEMP_COUNT\t3\n#define ADT7475_TACH_COUNT\t4\n#define ADT7475_PWM_COUNT\t3\n\n \n\n#define adt7475_read(reg) i2c_smbus_read_byte_data(client, (reg))\n\n \n\n#define TACH_REG(idx) (REG_TACH_BASE + ((idx) * 2))\n#define TACH_MIN_REG(idx) (REG_TACH_MIN_BASE + ((idx) * 2))\n\n#define PWM_REG(idx) (REG_PWM_BASE + (idx))\n#define PWM_MAX_REG(idx) (REG_PWM_MAX_BASE + (idx))\n#define PWM_MIN_REG(idx) (REG_PWM_MIN_BASE + (idx))\n#define PWM_CONFIG_REG(idx) (REG_PWM_CONFIG_BASE + (idx))\n\n#define VOLTAGE_REG(idx) (REG_VOLTAGE_BASE + (idx))\n#define VOLTAGE_MIN_REG(idx) (REG_VOLTAGE_MIN_BASE + ((idx) * 2))\n#define VOLTAGE_MAX_REG(idx) (REG_VOLTAGE_MAX_BASE + ((idx) * 2))\n\n#define TEMP_REG(idx) (REG_TEMP_BASE + (idx))\n#define TEMP_MIN_REG(idx) (REG_TEMP_MIN_BASE + ((idx) * 2))\n#define TEMP_MAX_REG(idx) (REG_TEMP_MAX_BASE + ((idx) * 2))\n#define TEMP_TMIN_REG(idx) (REG_TEMP_TMIN_BASE + (idx))\n#define TEMP_THERM_REG(idx) (REG_TEMP_THERM_BASE + (idx))\n#define TEMP_OFFSET_REG(idx) (REG_TEMP_OFFSET_BASE + (idx))\n#define TEMP_TRANGE_REG(idx) (REG_TEMP_TRANGE_BASE + (idx))\n\nstatic const unsigned short normal_i2c[] = { 0x2c, 0x2d, 0x2e, I2C_CLIENT_END };\n\nenum chips { adt7473, adt7475, adt7476, adt7490 };\n\nstatic const struct i2c_device_id adt7475_id[] = {\n\t{ \"adt7473\", adt7473 },\n\t{ \"adt7475\", adt7475 },\n\t{ \"adt7476\", adt7476 },\n\t{ \"adt7490\", adt7490 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adt7475_id);\n\nstatic const struct of_device_id __maybe_unused adt7475_of_match[] = {\n\t{\n\t\t.compatible = \"adi,adt7473\",\n\t\t.data = (void *)adt7473\n\t},\n\t{\n\t\t.compatible = \"adi,adt7475\",\n\t\t.data = (void *)adt7475\n\t},\n\t{\n\t\t.compatible = \"adi,adt7476\",\n\t\t.data = (void *)adt7476\n\t},\n\t{\n\t\t.compatible = \"adi,adt7490\",\n\t\t.data = (void *)adt7490\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, adt7475_of_match);\n\nstruct adt7475_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\n\tunsigned long measure_updated;\n\tbool valid;\n\n\tu8 config2;\n\tu8 config4;\n\tu8 config5;\n\tu8 has_voltage;\n\tu8 bypass_attn;\t\t \n\tu8 has_pwm2:1;\n\tu8 has_fan4:1;\n\tu8 has_vid:1;\n\tu32 alarms;\n\tu16 voltage[3][6];\n\tu16 temp[7][3];\n\tu16 tach[2][4];\n\tu8 pwm[4][3];\n\tu8 range[3];\n\tu8 pwmctl[3];\n\tu8 pwmchan[3];\n\tu8 enh_acoustics[2];\n\n\tu8 vid;\n\tu8 vrm;\n\tconst struct attribute_group *groups[9];\n};\n\nstatic struct i2c_driver adt7475_driver;\nstatic struct adt7475_data *adt7475_update_device(struct device *dev);\nstatic void adt7475_read_hystersis(struct i2c_client *client);\nstatic void adt7475_read_pwm(struct i2c_client *client, int index);\n\n \n\nstatic inline u16 temp2reg(struct adt7475_data *data, long val)\n{\n\tu16 ret;\n\n\tif (!(data->config5 & CONFIG5_TWOSCOMP)) {\n\t\tval = clamp_val(val, -64000, 191000);\n\t\tret = (val + 64500) / 1000;\n\t} else {\n\t\tval = clamp_val(val, -128000, 127000);\n\t\tif (val < -500)\n\t\t\tret = (256500 + val) / 1000;\n\t\telse\n\t\t\tret = (val + 500) / 1000;\n\t}\n\n\treturn ret << 2;\n}\n\n \n\nstatic inline int reg2temp(struct adt7475_data *data, u16 reg)\n{\n\tif (data->config5 & CONFIG5_TWOSCOMP) {\n\t\tif (reg >= 512)\n\t\t\treturn (reg - 1024) * 250;\n\t\telse\n\t\t\treturn reg * 250;\n\t} else\n\t\treturn (reg - 256) * 250;\n}\n\nstatic inline int tach2rpm(u16 tach)\n{\n\tif (tach == 0 || tach == 0xFFFF)\n\t\treturn 0;\n\n\treturn (90000 * 60) / tach;\n}\n\nstatic inline u16 rpm2tach(unsigned long rpm)\n{\n\tif (rpm == 0)\n\t\treturn 0;\n\n\treturn clamp_val((90000 * 60) / rpm, 1, 0xFFFF);\n}\n\n \nstatic const int adt7473_in_scaling[ADT7475_VOLTAGE_COUNT + 1][2] = {\n\t{ 45, 94 },\t \n\t{ 175, 525 },\t \n\t{ 68, 71 },\t \n\t{ 93, 47 },\t \n\t{ 120, 20 },\t \n\t{ 45, 45 },\t \n};\n\nstatic inline int reg2volt(int channel, u16 reg, u8 bypass_attn)\n{\n\tconst int *r = adt7473_in_scaling[channel];\n\n\tif (bypass_attn & (1 << channel))\n\t\treturn DIV_ROUND_CLOSEST(reg * 2250, 1024);\n\treturn DIV_ROUND_CLOSEST(reg * (r[0] + r[1]) * 2250, r[1] * 1024);\n}\n\nstatic inline u16 volt2reg(int channel, long volt, u8 bypass_attn)\n{\n\tconst int *r = adt7473_in_scaling[channel];\n\tlong reg;\n\n\tif (bypass_attn & (1 << channel))\n\t\treg = DIV_ROUND_CLOSEST(volt * 1024, 2250);\n\telse\n\t\treg = DIV_ROUND_CLOSEST(volt * r[1] * 1024,\n\t\t\t\t\t(r[0] + r[1]) * 2250);\n\treturn clamp_val(reg, 0, 1023) & (0xff << 2);\n}\n\nstatic int adt7475_read_word(struct i2c_client *client, int reg)\n{\n\tint val1, val2;\n\n\tval1 = i2c_smbus_read_byte_data(client, reg);\n\tif (val1 < 0)\n\t\treturn val1;\n\tval2 = i2c_smbus_read_byte_data(client, reg + 1);\n\tif (val2 < 0)\n\t\treturn val2;\n\n\treturn val1 | (val2 << 8);\n}\n\nstatic void adt7475_write_word(struct i2c_client *client, int reg, u16 val)\n{\n\ti2c_smbus_write_byte_data(client, reg + 1, val >> 8);\n\ti2c_smbus_write_byte_data(client, reg, val & 0xFF);\n}\n\nstatic ssize_t voltage_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct adt7475_data *data = adt7475_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tunsigned short val;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tswitch (sattr->nr) {\n\tcase ALARM:\n\t\treturn sprintf(buf, \"%d\\n\",\n\t\t\t       (data->alarms >> sattr->index) & 1);\n\tdefault:\n\t\tval = data->voltage[sattr->nr][sattr->index];\n\t\treturn sprintf(buf, \"%d\\n\",\n\t\t\t       reg2volt(sattr->index, val, data->bypass_attn));\n\t}\n}\n\nstatic ssize_t voltage_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned char reg;\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\n\tdata->voltage[sattr->nr][sattr->index] =\n\t\t\t\tvolt2reg(sattr->index, val, data->bypass_attn);\n\n\tif (sattr->index < ADT7475_VOLTAGE_COUNT) {\n\t\tif (sattr->nr == MIN)\n\t\t\treg = VOLTAGE_MIN_REG(sattr->index);\n\t\telse\n\t\t\treg = VOLTAGE_MAX_REG(sattr->index);\n\t} else {\n\t\tif (sattr->nr == MIN)\n\t\t\treg = REG_VTT_MIN;\n\t\telse\n\t\t\treg = REG_VTT_MAX;\n\t}\n\n\ti2c_smbus_write_byte_data(client, reg,\n\t\t\t\t  data->voltage[sattr->nr][sattr->index] >> 2);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct adt7475_data *data = adt7475_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint out;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tswitch (sattr->nr) {\n\tcase HYSTERSIS:\n\t\tmutex_lock(&data->lock);\n\t\tout = data->temp[sattr->nr][sattr->index];\n\t\tif (sattr->index != 1)\n\t\t\tout = (out >> 4) & 0xF;\n\t\telse\n\t\t\tout = (out & 0xF);\n\t\t \n\t\tout = reg2temp(data, data->temp[THERM][sattr->index]) -\n\t\t\tout * 1000;\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\n\tcase OFFSET:\n\t\t \n\t\tmutex_lock(&data->lock);\n\t\tout = (s8)data->temp[sattr->nr][sattr->index];\n\t\tif (data->config5 & CONFIG5_TEMPOFFSET)\n\t\t\tout *= 1000;\n\t\telse\n\t\t\tout *= 500;\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\n\tcase ALARM:\n\t\tout = (data->alarms >> (sattr->index + 4)) & 1;\n\t\tbreak;\n\n\tcase FAULT:\n\t\t \n\t\tout = !!(data->alarms & (sattr->index ? 0x8000 : 0x4000));\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tout = reg2temp(data, data->temp[sattr->nr][sattr->index]);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", out);\n}\n\nstatic ssize_t temp_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned char reg = 0;\n\tu8 out;\n\tint temp;\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\n\t \n\tdata->config5 = adt7475_read(REG_CONFIG5);\n\n\tswitch (sattr->nr) {\n\tcase OFFSET:\n\t\tif (data->config5 & CONFIG5_TEMPOFFSET) {\n\t\t\tval = clamp_val(val, -63000, 127000);\n\t\t\tout = data->temp[OFFSET][sattr->index] = val / 1000;\n\t\t} else {\n\t\t\tval = clamp_val(val, -63000, 64000);\n\t\t\tout = data->temp[OFFSET][sattr->index] = val / 500;\n\t\t}\n\t\tbreak;\n\n\tcase HYSTERSIS:\n\t\t \n\n\t\t \n\t\tdata->temp[THERM][sattr->index] =\n\t\t\tadt7475_read(TEMP_THERM_REG(sattr->index)) << 2;\n\t\tadt7475_read_hystersis(client);\n\n\t\ttemp = reg2temp(data, data->temp[THERM][sattr->index]);\n\t\tval = clamp_val(val, temp - 15000, temp);\n\t\tval = (temp - val) / 1000;\n\n\t\tif (sattr->index != 1) {\n\t\t\tdata->temp[HYSTERSIS][sattr->index] &= 0x0F;\n\t\t\tdata->temp[HYSTERSIS][sattr->index] |= (val & 0xF) << 4;\n\t\t} else {\n\t\t\tdata->temp[HYSTERSIS][sattr->index] &= 0xF0;\n\t\t\tdata->temp[HYSTERSIS][sattr->index] |= (val & 0xF);\n\t\t}\n\n\t\tout = data->temp[HYSTERSIS][sattr->index];\n\t\tbreak;\n\n\tdefault:\n\t\tdata->temp[sattr->nr][sattr->index] = temp2reg(data, val);\n\n\t\t \n\t\tout = (u8) (data->temp[sattr->nr][sattr->index] >> 2);\n\t}\n\n\tswitch (sattr->nr) {\n\tcase MIN:\n\t\treg = TEMP_MIN_REG(sattr->index);\n\t\tbreak;\n\tcase MAX:\n\t\treg = TEMP_MAX_REG(sattr->index);\n\t\tbreak;\n\tcase OFFSET:\n\t\treg = TEMP_OFFSET_REG(sattr->index);\n\t\tbreak;\n\tcase AUTOMIN:\n\t\treg = TEMP_TMIN_REG(sattr->index);\n\t\tbreak;\n\tcase THERM:\n\t\treg = TEMP_THERM_REG(sattr->index);\n\t\tbreak;\n\tcase HYSTERSIS:\n\t\tif (sattr->index != 2)\n\t\t\treg = REG_REMOTE1_HYSTERSIS;\n\t\telse\n\t\t\treg = REG_REMOTE2_HYSTERSIS;\n\n\t\tbreak;\n\t}\n\n\ti2c_smbus_write_byte_data(client, reg, out);\n\n\tmutex_unlock(&data->lock);\n\treturn count;\n}\n\n \nstatic const int ad7475_st_map[] = {\n\t37500, 18800, 12500, 7500, 4700, 3100, 1600, 800,\n};\n\nstatic ssize_t temp_st_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tlong val;\n\n\tswitch (sattr->index) {\n\tcase 0:\n\t\tval = data->enh_acoustics[0] & 0xf;\n\t\tbreak;\n\tcase 1:\n\t\tval = data->enh_acoustics[1] & 0xf;\n\t\tbreak;\n\tcase 2:\n\tdefault:\n\t\tval = (data->enh_acoustics[1] >> 4) & 0xf;\n\t\tbreak;\n\t}\n\n\tif (val & 0x8)\n\t\treturn sprintf(buf, \"%d\\n\", ad7475_st_map[val & 0x7]);\n\telse\n\t\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t temp_st_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned char reg;\n\tint shift, idx;\n\tulong val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tswitch (sattr->index) {\n\tcase 0:\n\t\treg = REG_ENHANCE_ACOUSTICS1;\n\t\tshift = 0;\n\t\tidx = 0;\n\t\tbreak;\n\tcase 1:\n\t\treg = REG_ENHANCE_ACOUSTICS2;\n\t\tshift = 0;\n\t\tidx = 1;\n\t\tbreak;\n\tcase 2:\n\tdefault:\n\t\treg = REG_ENHANCE_ACOUSTICS2;\n\t\tshift = 4;\n\t\tidx = 1;\n\t\tbreak;\n\t}\n\n\tif (val > 0) {\n\t\tval = find_closest_descending(val, ad7475_st_map,\n\t\t\t\t\t      ARRAY_SIZE(ad7475_st_map));\n\t\tval |= 0x8;\n\t}\n\n\tmutex_lock(&data->lock);\n\n\tdata->enh_acoustics[idx] &= ~(0xf << shift);\n\tdata->enh_acoustics[idx] |= (val << shift);\n\n\ti2c_smbus_write_byte_data(client, reg, data->enh_acoustics[idx]);\n\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\n \nstatic const int autorange_table[] = {\n\t2000, 2500, 3330, 4000, 5000, 6670, 8000,\n\t10000, 13330, 16000, 20000, 26670, 32000, 40000,\n\t53330, 80000\n};\n\nstatic ssize_t point2_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct adt7475_data *data = adt7475_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint out, val;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmutex_lock(&data->lock);\n\tout = (data->range[sattr->index] >> 4) & 0x0F;\n\tval = reg2temp(data, data->temp[AUTOMIN][sattr->index]);\n\tmutex_unlock(&data->lock);\n\n\treturn sprintf(buf, \"%d\\n\", val + autorange_table[out]);\n}\n\nstatic ssize_t point2_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint temp;\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\n\t \n\tdata->config5 = adt7475_read(REG_CONFIG5);\n\tdata->temp[AUTOMIN][sattr->index] =\n\t\tadt7475_read(TEMP_TMIN_REG(sattr->index)) << 2;\n\tdata->range[sattr->index] =\n\t\tadt7475_read(TEMP_TRANGE_REG(sattr->index));\n\n\t \n\ttemp = reg2temp(data, data->temp[AUTOMIN][sattr->index]);\n\tval = clamp_val(val, temp + autorange_table[0],\n\t\ttemp + autorange_table[ARRAY_SIZE(autorange_table) - 1]);\n\tval -= temp;\n\n\t \n\tval = find_closest(val, autorange_table, ARRAY_SIZE(autorange_table));\n\n\tdata->range[sattr->index] &= ~0xF0;\n\tdata->range[sattr->index] |= val << 4;\n\n\ti2c_smbus_write_byte_data(client, TEMP_TRANGE_REG(sattr->index),\n\t\t\t\t  data->range[sattr->index]);\n\n\tmutex_unlock(&data->lock);\n\treturn count;\n}\n\nstatic ssize_t tach_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct adt7475_data *data = adt7475_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint out;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (sattr->nr == ALARM)\n\t\tout = (data->alarms >> (sattr->index + 10)) & 1;\n\telse\n\t\tout = tach2rpm(data->tach[sattr->nr][sattr->index]);\n\n\treturn sprintf(buf, \"%d\\n\", out);\n}\n\nstatic ssize_t tach_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\n\tdata->tach[MIN][sattr->index] = rpm2tach(val);\n\n\tadt7475_write_word(client, TACH_MIN_REG(sattr->index),\n\t\t\t   data->tach[MIN][sattr->index]);\n\n\tmutex_unlock(&data->lock);\n\treturn count;\n}\n\nstatic ssize_t pwm_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct adt7475_data *data = adt7475_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->pwm[sattr->nr][sattr->index]);\n}\n\nstatic ssize_t pwmchan_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct adt7475_data *data = adt7475_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->pwmchan[sattr->index]);\n}\n\nstatic ssize_t pwmctrl_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct adt7475_data *data = adt7475_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->pwmctl[sattr->index]);\n}\n\nstatic ssize_t pwm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned char reg = 0;\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\n\tswitch (sattr->nr) {\n\tcase INPUT:\n\t\t \n\t\tdata->pwm[CONTROL][sattr->index] =\n\t\t\tadt7475_read(PWM_CONFIG_REG(sattr->index));\n\n\t\t \n\t\tif (((data->pwm[CONTROL][sattr->index] >> 5) & 7) != 7) {\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn count;\n\t\t}\n\n\t\treg = PWM_REG(sattr->index);\n\t\tbreak;\n\n\tcase MIN:\n\t\treg = PWM_MIN_REG(sattr->index);\n\t\tbreak;\n\n\tcase MAX:\n\t\treg = PWM_MAX_REG(sattr->index);\n\t\tbreak;\n\t}\n\n\tdata->pwm[sattr->nr][sattr->index] = clamp_val(val, 0, 0xFF);\n\ti2c_smbus_write_byte_data(client, reg,\n\t\t\t\t  data->pwm[sattr->nr][sattr->index]);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t stall_disable_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\n\tu8 mask = BIT(5 + sattr->index);\n\n\treturn sprintf(buf, \"%d\\n\", !!(data->enh_acoustics[0] & mask));\n}\n\nstatic ssize_t stall_disable_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tu8 mask = BIT(5 + sattr->index);\n\n\tif (kstrtol(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\n\tdata->enh_acoustics[0] &= ~mask;\n\tif (val)\n\t\tdata->enh_acoustics[0] |= mask;\n\n\ti2c_smbus_write_byte_data(client, REG_ENHANCE_ACOUSTICS1,\n\t\t\t\t  data->enh_acoustics[0]);\n\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\n \n\nstatic int hw_set_pwm(struct i2c_client *client, int index,\n\t\t      unsigned int pwmctl, unsigned int pwmchan)\n{\n\tstruct adt7475_data *data = i2c_get_clientdata(client);\n\tlong val = 0;\n\n\tswitch (pwmctl) {\n\tcase 0:\n\t\tval = 0x03;\t \n\t\tbreak;\n\tcase 1:\n\t\tval = 0x07;\t \n\t\tbreak;\n\tcase 2:\n\t\tswitch (pwmchan) {\n\t\tcase 1:\n\t\t\t \n\t\t\tval = 0x00;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tval = 0x01;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t \n\t\t\tval = 0x02;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t \n\t\t\tval = 0x05;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\t \n\t\t\tval = 0x06;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdata->pwmctl[index] = pwmctl;\n\tdata->pwmchan[index] = pwmchan;\n\n\tdata->pwm[CONTROL][index] &= ~0xE0;\n\tdata->pwm[CONTROL][index] |= (val & 7) << 5;\n\n\ti2c_smbus_write_byte_data(client, PWM_CONFIG_REG(index),\n\t\t\t\t  data->pwm[CONTROL][index]);\n\n\treturn 0;\n}\n\nstatic ssize_t pwmchan_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint r;\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\t \n\tadt7475_read_pwm(client, sattr->index);\n\tr = hw_set_pwm(client, sattr->index, data->pwmctl[sattr->index], val);\n\tif (r)\n\t\tcount = r;\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t pwmctrl_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint r;\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\t \n\tadt7475_read_pwm(client, sattr->index);\n\tr = hw_set_pwm(client, sattr->index, val, data->pwmchan[sattr->index]);\n\tif (r)\n\t\tcount = r;\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\n \nstatic const int pwmfreq_table[] = {\n\t11, 14, 22, 29, 35, 44, 58, 88, 22500\n};\n\nstatic ssize_t pwmfreq_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct adt7475_data *data = adt7475_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint idx;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\tidx = clamp_val(data->range[sattr->index] & 0xf, 0,\n\t\t\tARRAY_SIZE(pwmfreq_table) - 1);\n\n\treturn sprintf(buf, \"%d\\n\", pwmfreq_table[idx]);\n}\n\nstatic ssize_t pwmfreq_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint out;\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tout = find_closest(val, pwmfreq_table, ARRAY_SIZE(pwmfreq_table));\n\n\tmutex_lock(&data->lock);\n\n\tdata->range[sattr->index] =\n\t\tadt7475_read(TEMP_TRANGE_REG(sattr->index));\n\tdata->range[sattr->index] &= ~0xf;\n\tdata->range[sattr->index] |= out;\n\n\ti2c_smbus_write_byte_data(client, TEMP_TRANGE_REG(sattr->index),\n\t\t\t\t  data->range[sattr->index]);\n\n\tmutex_unlock(&data->lock);\n\treturn count;\n}\n\nstatic ssize_t pwm_use_point2_pwm_at_crit_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct adt7475_data *data = adt7475_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", !!(data->config4 & CONFIG4_MAXDUTY));\n}\n\nstatic ssize_t pwm_use_point2_pwm_at_crit_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val))\n\t\treturn -EINVAL;\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\tdata->config4 = i2c_smbus_read_byte_data(client, REG_CONFIG4);\n\tif (val)\n\t\tdata->config4 |= CONFIG4_MAXDUTY;\n\telse\n\t\tdata->config4 &= ~CONFIG4_MAXDUTY;\n\ti2c_smbus_write_byte_data(client, REG_CONFIG4, data->config4);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t vrm_show(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", (int)data->vrm);\n}\n\nstatic ssize_t vrm_store(struct device *dev, struct device_attribute *devattr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val))\n\t\treturn -EINVAL;\n\tif (val < 0 || val > 255)\n\t\treturn -EINVAL;\n\tdata->vrm = val;\n\n\treturn count;\n}\n\nstatic ssize_t cpu0_vid_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct adt7475_data *data = adt7475_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", vid_from_reg(data->vid, data->vrm));\n}\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in0_input, voltage, INPUT, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in0_max, voltage, MAX, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in0_min, voltage, MIN, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(in0_alarm, voltage, ALARM, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(in1_input, voltage, INPUT, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in1_max, voltage, MAX, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in1_min, voltage, MIN, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(in1_alarm, voltage, ALARM, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(in2_input, voltage, INPUT, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_max, voltage, MAX, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_min, voltage, MIN, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(in2_alarm, voltage, ALARM, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(in3_input, voltage, INPUT, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_max, voltage, MAX, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_min, voltage, MIN, 3);\nstatic SENSOR_DEVICE_ATTR_2_RO(in3_alarm, voltage, ALARM, 3);\nstatic SENSOR_DEVICE_ATTR_2_RO(in4_input, voltage, INPUT, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_max, voltage, MAX, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_min, voltage, MIN, 4);\nstatic SENSOR_DEVICE_ATTR_2_RO(in4_alarm, voltage, ALARM, 8);\nstatic SENSOR_DEVICE_ATTR_2_RO(in5_input, voltage, INPUT, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(in5_max, voltage, MAX, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(in5_min, voltage, MIN, 5);\nstatic SENSOR_DEVICE_ATTR_2_RO(in5_alarm, voltage, ALARM, 31);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_input, temp, INPUT, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_alarm, temp, ALARM, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_fault, temp, FAULT, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_max, temp, MAX, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_min, temp, MIN, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_offset, temp, OFFSET, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_point1_temp, temp, AUTOMIN, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_auto_point2_temp, point2, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_crit, temp, THERM, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_crit_hyst, temp, HYSTERSIS, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_smoothing, temp_st, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp2_input, temp, INPUT, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp2_alarm, temp, ALARM, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_max, temp, MAX, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_min, temp, MIN, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_offset, temp, OFFSET, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_point1_temp, temp, AUTOMIN, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_auto_point2_temp, point2, 0, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_crit, temp, THERM, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_crit_hyst, temp, HYSTERSIS, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_smoothing, temp_st, 0, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_input, temp, INPUT, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_alarm, temp, ALARM, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_fault, temp, FAULT, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_max, temp, MAX, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_min, temp, MIN, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_offset, temp, OFFSET, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_point1_temp, temp, AUTOMIN, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_auto_point2_temp, point2, 0, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_crit, temp, THERM, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_crit_hyst, temp, HYSTERSIS, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_smoothing, temp_st, 0, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan1_input, tach, INPUT, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan1_min, tach, MIN, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan1_alarm, tach, ALARM, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan2_input, tach, INPUT, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan2_min, tach, MIN, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan2_alarm, tach, ALARM, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan3_input, tach, INPUT, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan3_min, tach, MIN, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan3_alarm, tach, ALARM, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan4_input, tach, INPUT, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan4_min, tach, MIN, 3);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan4_alarm, tach, ALARM, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1, pwm, INPUT, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_freq, pwmfreq, INPUT, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_enable, pwmctrl, INPUT, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_channels_temp, pwmchan, INPUT, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point1_pwm, pwm, MIN, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point2_pwm, pwm, MAX, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_stall_disable, stall_disable, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2, pwm, INPUT, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_freq, pwmfreq, INPUT, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_enable, pwmctrl, INPUT, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_channels_temp, pwmchan, INPUT, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point1_pwm, pwm, MIN, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point2_pwm, pwm, MAX, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_stall_disable, stall_disable, 0, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3, pwm, INPUT, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_freq, pwmfreq, INPUT, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_enable, pwmctrl, INPUT, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_channels_temp, pwmchan, INPUT, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point1_pwm, pwm, MIN, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point2_pwm, pwm, MAX, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_stall_disable, stall_disable, 0, 2);\n\n \nstatic DEVICE_ATTR_RW(pwm_use_point2_pwm_at_crit);\n\nstatic DEVICE_ATTR_RW(vrm);\nstatic DEVICE_ATTR_RO(cpu0_vid);\n\nstatic struct attribute *adt7475_attrs[] = {\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_smoothing.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp2_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_smoothing.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp3_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp3_smoothing.dev_attr.attr,\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_channels_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_stall_disable.dev_attr.attr,\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_channels_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_stall_disable.dev_attr.attr,\n\t&dev_attr_pwm_use_point2_pwm_at_crit.attr,\n\tNULL,\n};\n\nstatic struct attribute *fan4_attrs[] = {\n\t&sensor_dev_attr_fan4_input.dev_attr.attr,\n\t&sensor_dev_attr_fan4_min.dev_attr.attr,\n\t&sensor_dev_attr_fan4_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic struct attribute *pwm2_attrs[] = {\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_channels_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_stall_disable.dev_attr.attr,\n\tNULL\n};\n\nstatic struct attribute *in0_attrs[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic struct attribute *in3_attrs[] = {\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic struct attribute *in4_attrs[] = {\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic struct attribute *in5_attrs[] = {\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic struct attribute *vid_attrs[] = {\n\t&dev_attr_cpu0_vid.attr,\n\t&dev_attr_vrm.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adt7475_attr_group = { .attrs = adt7475_attrs };\nstatic const struct attribute_group fan4_attr_group = { .attrs = fan4_attrs };\nstatic const struct attribute_group pwm2_attr_group = { .attrs = pwm2_attrs };\nstatic const struct attribute_group in0_attr_group = { .attrs = in0_attrs };\nstatic const struct attribute_group in3_attr_group = { .attrs = in3_attrs };\nstatic const struct attribute_group in4_attr_group = { .attrs = in4_attrs };\nstatic const struct attribute_group in5_attr_group = { .attrs = in5_attrs };\nstatic const struct attribute_group vid_attr_group = { .attrs = vid_attrs };\n\nstatic int adt7475_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint vendid, devid, devid2;\n\tconst char *name;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tvendid = adt7475_read(REG_VENDID);\n\tdevid2 = adt7475_read(REG_DEVID2);\n\tif (vendid != 0x41 ||\t\t \n\t    (devid2 & 0xf8) != 0x68)\n\t\treturn -ENODEV;\n\n\tdevid = adt7475_read(REG_DEVID);\n\tif (devid == 0x73)\n\t\tname = \"adt7473\";\n\telse if (devid == 0x75 && client->addr == 0x2e)\n\t\tname = \"adt7475\";\n\telse if (devid == 0x76)\n\t\tname = \"adt7476\";\n\telse if ((devid2 & 0xfc) == 0x6c)\n\t\tname = \"adt7490\";\n\telse {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"Couldn't detect an ADT7473/75/76/90 part at \"\n\t\t\t\"0x%02x\\n\", (unsigned int)client->addr);\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int adt7475_update_limits(struct i2c_client *client)\n{\n\tstruct adt7475_data *data = i2c_get_clientdata(client);\n\tint i;\n\tint ret;\n\n\tret = adt7475_read(REG_CONFIG4);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->config4 = ret;\n\n\tret = adt7475_read(REG_CONFIG5);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->config5 = ret;\n\n\tfor (i = 0; i < ADT7475_VOLTAGE_COUNT; i++) {\n\t\tif (!(data->has_voltage & (1 << i)))\n\t\t\tcontinue;\n\t\t \n\t\tret = adt7475_read(VOLTAGE_MIN_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->voltage[MIN][i] = ret << 2;\n\n\t\tret = adt7475_read(VOLTAGE_MAX_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->voltage[MAX][i] = ret << 2;\n\t}\n\n\tif (data->has_voltage & (1 << 5)) {\n\t\tret = adt7475_read(REG_VTT_MIN);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->voltage[MIN][5] = ret << 2;\n\n\t\tret = adt7475_read(REG_VTT_MAX);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->voltage[MAX][5] = ret << 2;\n\t}\n\n\tfor (i = 0; i < ADT7475_TEMP_COUNT; i++) {\n\t\t \n\t\tret = adt7475_read(TEMP_MIN_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->temp[MIN][i] = ret << 2;\n\n\t\tret = adt7475_read(TEMP_MAX_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->temp[MAX][i] = ret << 2;\n\n\t\tret = adt7475_read(TEMP_TMIN_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->temp[AUTOMIN][i] = ret << 2;\n\n\t\tret = adt7475_read(TEMP_THERM_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->temp[THERM][i] = ret << 2;\n\n\t\tret = adt7475_read(TEMP_OFFSET_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->temp[OFFSET][i] = ret;\n\t}\n\tadt7475_read_hystersis(client);\n\n\tfor (i = 0; i < ADT7475_TACH_COUNT; i++) {\n\t\tif (i == 3 && !data->has_fan4)\n\t\t\tcontinue;\n\t\tret = adt7475_read_word(client, TACH_MIN_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->tach[MIN][i] = ret;\n\t}\n\n\tfor (i = 0; i < ADT7475_PWM_COUNT; i++) {\n\t\tif (i == 1 && !data->has_pwm2)\n\t\t\tcontinue;\n\t\tret = adt7475_read(PWM_MAX_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->pwm[MAX][i] = ret;\n\n\t\tret = adt7475_read(PWM_MIN_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->pwm[MIN][i] = ret;\n\t\t \n\t\tadt7475_read_pwm(client, i);\n\t}\n\n\tret = adt7475_read(TEMP_TRANGE_REG(0));\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->range[0] = ret;\n\n\tret = adt7475_read(TEMP_TRANGE_REG(1));\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->range[1] = ret;\n\n\tret = adt7475_read(TEMP_TRANGE_REG(2));\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->range[2] = ret;\n\n\treturn 0;\n}\n\nstatic int load_config3(const struct i2c_client *client, const char *propname)\n{\n\tconst char *function;\n\tu8 config3;\n\tint ret;\n\n\tret = device_property_read_string(&client->dev, propname, &function);\n\tif (!ret) {\n\t\tret = adt7475_read(REG_CONFIG3);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tconfig3 = ret & ~CONFIG3_SMBALERT;\n\t\tif (!strcmp(\"pwm2\", function))\n\t\t\t;\n\t\telse if (!strcmp(\"smbalert#\", function))\n\t\t\tconfig3 |= CONFIG3_SMBALERT;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\treturn i2c_smbus_write_byte_data(client, REG_CONFIG3, config3);\n\t}\n\n\treturn 0;\n}\n\nstatic int load_config4(const struct i2c_client *client, const char *propname)\n{\n\tconst char *function;\n\tu8 config4;\n\tint ret;\n\n\tret = device_property_read_string(&client->dev, propname, &function);\n\tif (!ret) {\n\t\tret = adt7475_read(REG_CONFIG4);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tconfig4 = ret & ~CONFIG4_PINFUNC;\n\n\t\tif (!strcmp(\"tach4\", function))\n\t\t\t;\n\t\telse if (!strcmp(\"therm#\", function))\n\t\t\tconfig4 |= CONFIG4_THERM;\n\t\telse if (!strcmp(\"smbalert#\", function))\n\t\t\tconfig4 |= CONFIG4_SMBALERT;\n\t\telse if (!strcmp(\"gpio\", function))\n\t\t\tconfig4 |= CONFIG4_PINFUNC;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\treturn i2c_smbus_write_byte_data(client, REG_CONFIG4, config4);\n\t}\n\n\treturn 0;\n}\n\nstatic int load_config(const struct i2c_client *client, enum chips chip)\n{\n\tint err;\n\tconst char *prop1, *prop2;\n\n\tswitch (chip) {\n\tcase adt7473:\n\tcase adt7475:\n\t\tprop1 = \"adi,pin5-function\";\n\t\tprop2 = \"adi,pin9-function\";\n\t\tbreak;\n\tcase adt7476:\n\tcase adt7490:\n\t\tprop1 = \"adi,pin10-function\";\n\t\tprop2 = \"adi,pin14-function\";\n\t\tbreak;\n\t}\n\n\terr = load_config3(client, prop1);\n\tif (err) {\n\t\tdev_err(&client->dev, \"failed to configure %s\\n\", prop1);\n\t\treturn err;\n\t}\n\n\terr = load_config4(client, prop2);\n\tif (err) {\n\t\tdev_err(&client->dev, \"failed to configure %s\\n\", prop2);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_property_bit(const struct i2c_client *client, char *property,\n\t\t\t    u8 *config, u8 bit_index)\n{\n\tu32 prop_value = 0;\n\tint ret = device_property_read_u32(&client->dev, property,\n\t\t\t\t\t   &prop_value);\n\n\tif (!ret) {\n\t\tif (prop_value)\n\t\t\t*config |= (1 << bit_index);\n\t\telse\n\t\t\t*config &= ~(1 << bit_index);\n\t}\n\n\treturn ret;\n}\n\nstatic int load_attenuators(const struct i2c_client *client, enum chips chip,\n\t\t\t    struct adt7475_data *data)\n{\n\tswitch (chip) {\n\tcase adt7476:\n\tcase adt7490:\n\t\tset_property_bit(client, \"adi,bypass-attenuator-in0\",\n\t\t\t\t &data->config4, 4);\n\t\tset_property_bit(client, \"adi,bypass-attenuator-in1\",\n\t\t\t\t &data->config4, 5);\n\t\tset_property_bit(client, \"adi,bypass-attenuator-in3\",\n\t\t\t\t &data->config4, 6);\n\t\tset_property_bit(client, \"adi,bypass-attenuator-in4\",\n\t\t\t\t &data->config4, 7);\n\n\t\treturn i2c_smbus_write_byte_data(client, REG_CONFIG4,\n\t\t\t\t\t\t data->config4);\n\tcase adt7473:\n\tcase adt7475:\n\t\tset_property_bit(client, \"adi,bypass-attenuator-in1\",\n\t\t\t\t &data->config2, 5);\n\n\t\treturn i2c_smbus_write_byte_data(client, REG_CONFIG2,\n\t\t\t\t\t\t data->config2);\n\t}\n\n\treturn 0;\n}\n\nstatic int adt7475_set_pwm_polarity(struct i2c_client *client)\n{\n\tu32 states[ADT7475_PWM_COUNT];\n\tint ret, i;\n\tu8 val;\n\n\tret = device_property_read_u32_array(&client->dev,\n\t\t\t\t\t     \"adi,pwm-active-state\", states,\n\t\t\t\t\t     ARRAY_SIZE(states));\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ADT7475_PWM_COUNT; i++) {\n\t\tret = adt7475_read(PWM_CONFIG_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tval = ret;\n\t\tif (states[i])\n\t\t\tval &= ~BIT(4);\n\t\telse\n\t\t\tval |= BIT(4);\n\n\t\tret = i2c_smbus_write_byte_data(client, PWM_CONFIG_REG(i), val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int adt7475_probe(struct i2c_client *client)\n{\n\tenum chips chip;\n\tstatic const char * const names[] = {\n\t\t[adt7473] = \"ADT7473\",\n\t\t[adt7475] = \"ADT7475\",\n\t\t[adt7476] = \"ADT7476\",\n\t\t[adt7490] = \"ADT7490\",\n\t};\n\n\tstruct adt7475_data *data;\n\tstruct device *hwmon_dev;\n\tint i, ret = 0, revision, group_num = 0;\n\tu8 config3;\n\tconst struct i2c_device_id *id = i2c_match_id(adt7475_id, client);\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&data->lock);\n\tdata->client = client;\n\ti2c_set_clientdata(client, data);\n\n\tif (client->dev.of_node)\n\t\tchip = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\tchip = id->driver_data;\n\n\t \n\tswitch (chip) {\n\tcase adt7476:\n\t\tdata->has_voltage = 0x0e;\t \n\t\trevision = adt7475_read(REG_DEVID2) & 0x07;\n\t\tbreak;\n\tcase adt7490:\n\t\tdata->has_voltage = 0x3e;\t \n\t\trevision = adt7475_read(REG_DEVID2) & 0x03;\n\t\tif (revision == 0x03)\n\t\t\trevision += adt7475_read(REG_DEVREV2);\n\t\tbreak;\n\tdefault:\n\t\tdata->has_voltage = 0x06;\t \n\t\trevision = adt7475_read(REG_DEVID2) & 0x07;\n\t}\n\n\tret = load_config(client, chip);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig3 = adt7475_read(REG_CONFIG3);\n\t \n\tif (!(config3 & CONFIG3_SMBALERT))\n\t\tdata->has_pwm2 = 1;\n\t \n\tif (id->driver_data == adt7473 && revision >= 1)\n\t\tdata->has_pwm2 = !data->has_pwm2;\n\n\tdata->config4 = adt7475_read(REG_CONFIG4);\n\t \n\tif ((data->config4 & CONFIG4_PINFUNC) == 0x0)\n\t\tdata->has_fan4 = 1;\n\n\t \n\tif (id->driver_data == adt7490) {\n\t\tif ((data->config4 & CONFIG4_PINFUNC) == 0x1 &&\n\t\t    !(config3 & CONFIG3_THERM))\n\t\t\tdata->has_fan4 = 1;\n\t}\n\tif (id->driver_data == adt7476 || id->driver_data == adt7490) {\n\t\tif (!(config3 & CONFIG3_THERM) ||\n\t\t    (data->config4 & CONFIG4_PINFUNC) == 0x1)\n\t\t\tdata->has_voltage |= (1 << 0);\t\t \n\t}\n\n\t \n\tif (id->driver_data == adt7476) {\n\t\tu8 vid = adt7475_read(REG_VID);\n\t\tif (!(vid & VID_VIDSEL))\n\t\t\tdata->has_voltage |= (1 << 4);\t\t \n\n\t\tdata->has_vid = !(adt7475_read(REG_CONFIG5) & CONFIG5_VIDGPIO);\n\t}\n\n\t \n\tdata->config2 = adt7475_read(REG_CONFIG2);\n\tret = load_attenuators(client, chip, data);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"Error configuring attenuator bypass\\n\");\n\n\tif (data->config2 & CONFIG2_ATTN) {\n\t\tdata->bypass_attn = (0x3 << 3) | 0x3;\n\t} else {\n\t\tdata->bypass_attn = ((data->config4 & CONFIG4_ATTN_IN10) >> 4) |\n\t\t\t\t    ((data->config4 & CONFIG4_ATTN_IN43) >> 3);\n\t}\n\tdata->bypass_attn &= data->has_voltage;\n\n\t \n\tfor (i = 0; i < ADT7475_PWM_COUNT; i++)\n\t\tadt7475_read_pwm(client, i);\n\n\tret = adt7475_set_pwm_polarity(client);\n\tif (ret && ret != -EINVAL)\n\t\tdev_warn(&client->dev, \"Error configuring pwm polarity\\n\");\n\n\t \n\tswitch (chip) {\n\tcase adt7475:\n\tcase adt7476:\n\t\ti2c_smbus_write_byte_data(client, REG_CONFIG1,\n\t\t\t\t\t  adt7475_read(REG_CONFIG1) | 0x01);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdata->groups[group_num++] = &adt7475_attr_group;\n\n\t \n\tif (data->has_fan4) {\n\t\tdata->groups[group_num++] = &fan4_attr_group;\n\t}\n\tif (data->has_pwm2) {\n\t\tdata->groups[group_num++] = &pwm2_attr_group;\n\t}\n\tif (data->has_voltage & (1 << 0)) {\n\t\tdata->groups[group_num++] = &in0_attr_group;\n\t}\n\tif (data->has_voltage & (1 << 3)) {\n\t\tdata->groups[group_num++] = &in3_attr_group;\n\t}\n\tif (data->has_voltage & (1 << 4)) {\n\t\tdata->groups[group_num++] = &in4_attr_group;\n\t}\n\tif (data->has_voltage & (1 << 5)) {\n\t\tdata->groups[group_num++] = &in5_attr_group;\n\t}\n\tif (data->has_vid) {\n\t\tdata->vrm = vid_which_vrm();\n\t\tdata->groups[group_num] = &vid_attr_group;\n\t}\n\n\t \n\thwmon_dev = devm_hwmon_device_register_with_groups(&client->dev,\n\t\t\t\t\t\t\t   client->name, data,\n\t\t\t\t\t\t\t   data->groups);\n\n\tif (IS_ERR(hwmon_dev)) {\n\t\tret = PTR_ERR(hwmon_dev);\n\t\treturn ret;\n\t}\n\n\tdev_info(&client->dev, \"%s device, revision %d\\n\",\n\t\t names[id->driver_data], revision);\n\tif ((data->has_voltage & 0x11) || data->has_fan4 || data->has_pwm2)\n\t\tdev_info(&client->dev, \"Optional features:%s%s%s%s%s\\n\",\n\t\t\t (data->has_voltage & (1 << 0)) ? \" in0\" : \"\",\n\t\t\t (data->has_voltage & (1 << 4)) ? \" in4\" : \"\",\n\t\t\t data->has_fan4 ? \" fan4\" : \"\",\n\t\t\t data->has_pwm2 ? \" pwm2\" : \"\",\n\t\t\t data->has_vid ? \" vid\" : \"\");\n\tif (data->bypass_attn)\n\t\tdev_info(&client->dev, \"Bypassing attenuators on:%s%s%s%s\\n\",\n\t\t\t (data->bypass_attn & (1 << 0)) ? \" in0\" : \"\",\n\t\t\t (data->bypass_attn & (1 << 1)) ? \" in1\" : \"\",\n\t\t\t (data->bypass_attn & (1 << 3)) ? \" in3\" : \"\",\n\t\t\t (data->bypass_attn & (1 << 4)) ? \" in4\" : \"\");\n\n\t \n\tret = adt7475_update_limits(client);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic struct i2c_driver adt7475_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"adt7475\",\n\t\t.of_match_table = of_match_ptr(adt7475_of_match),\n\t},\n\t.probe\t\t= adt7475_probe,\n\t.id_table\t= adt7475_id,\n\t.detect\t\t= adt7475_detect,\n\t.address_list\t= normal_i2c,\n};\n\nstatic void adt7475_read_hystersis(struct i2c_client *client)\n{\n\tstruct adt7475_data *data = i2c_get_clientdata(client);\n\n\tdata->temp[HYSTERSIS][0] = (u16) adt7475_read(REG_REMOTE1_HYSTERSIS);\n\tdata->temp[HYSTERSIS][1] = data->temp[HYSTERSIS][0];\n\tdata->temp[HYSTERSIS][2] = (u16) adt7475_read(REG_REMOTE2_HYSTERSIS);\n}\n\nstatic void adt7475_read_pwm(struct i2c_client *client, int index)\n{\n\tstruct adt7475_data *data = i2c_get_clientdata(client);\n\tunsigned int v;\n\n\tdata->pwm[CONTROL][index] = adt7475_read(PWM_CONFIG_REG(index));\n\n\t \n\tv = (data->pwm[CONTROL][index] >> 5) & 7;\n\n\tif (v == 3)\n\t\tdata->pwmctl[index] = 0;\n\telse if (v == 7)\n\t\tdata->pwmctl[index] = 1;\n\telse if (v == 4) {\n\t\t \n\t\tdata->pwm[INPUT][index] = 0;\n\t\tdata->pwm[CONTROL][index] &= ~0xE0;\n\t\tdata->pwm[CONTROL][index] |= (7 << 5);\n\n\t\ti2c_smbus_write_byte_data(client, PWM_CONFIG_REG(index),\n\t\t\t\t\t  data->pwm[INPUT][index]);\n\n\t\ti2c_smbus_write_byte_data(client, PWM_CONFIG_REG(index),\n\t\t\t\t\t  data->pwm[CONTROL][index]);\n\n\t\tdata->pwmctl[index] = 1;\n\t} else {\n\t\tdata->pwmctl[index] = 2;\n\n\t\tswitch (v) {\n\t\tcase 0:\n\t\t\tdata->pwmchan[index] = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdata->pwmchan[index] = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata->pwmchan[index] = 4;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tdata->pwmchan[index] = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdata->pwmchan[index] = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int adt7475_update_measure(struct device *dev)\n{\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu16 ext;\n\tint i;\n\tint ret;\n\n\tret = adt7475_read(REG_STATUS2);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->alarms = ret << 8;\n\n\tret = adt7475_read(REG_STATUS1);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->alarms |= ret;\n\n\tret = adt7475_read(REG_EXTEND2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\text = (ret << 8);\n\n\tret = adt7475_read(REG_EXTEND1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\text |= ret;\n\n\tfor (i = 0; i < ADT7475_VOLTAGE_COUNT; i++) {\n\t\tif (!(data->has_voltage & (1 << i)))\n\t\t\tcontinue;\n\t\tret = adt7475_read(VOLTAGE_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->voltage[INPUT][i] =\n\t\t\t(ret << 2) |\n\t\t\t((ext >> (i * 2)) & 3);\n\t}\n\n\tfor (i = 0; i < ADT7475_TEMP_COUNT; i++) {\n\t\tret = adt7475_read(TEMP_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->temp[INPUT][i] =\n\t\t\t(ret << 2) |\n\t\t\t((ext >> ((i + 5) * 2)) & 3);\n\t}\n\n\tif (data->has_voltage & (1 << 5)) {\n\t\tret = adt7475_read(REG_STATUS4);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->alarms |= ret << 24;\n\n\t\tret = adt7475_read(REG_EXTEND3);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\text = ret;\n\n\t\tret = adt7475_read(REG_VTT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->voltage[INPUT][5] = ret << 2 |\n\t\t\t((ext >> 4) & 3);\n\t}\n\n\tfor (i = 0; i < ADT7475_TACH_COUNT; i++) {\n\t\tif (i == 3 && !data->has_fan4)\n\t\t\tcontinue;\n\t\tret = adt7475_read_word(client, TACH_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->tach[INPUT][i] = ret;\n\t}\n\n\t \n\tfor (i = 0; i < ADT7475_PWM_COUNT; i++) {\n\t\tif (i == 1 && !data->has_pwm2)\n\t\t\tcontinue;\n\t\tret = adt7475_read(PWM_REG(i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->pwm[INPUT][i] = ret;\n\t}\n\n\tif (data->has_vid) {\n\t\tret = adt7475_read(REG_VID);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->vid = ret & 0x3f;\n\t}\n\n\treturn 0;\n}\n\nstatic struct adt7475_data *adt7475_update_device(struct device *dev)\n{\n\tstruct adt7475_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\t \n\tif (time_after(jiffies, data->measure_updated + HZ * 2) ||\n\t    !data->valid) {\n\t\tret = adt7475_update_measure(dev);\n\t\tif (ret) {\n\t\t\tdata->valid = false;\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t\tdata->measure_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn data;\n}\n\nmodule_i2c_driver(adt7475_driver);\n\nMODULE_AUTHOR(\"Advanced Micro Devices, Inc\");\nMODULE_DESCRIPTION(\"adt7475 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}