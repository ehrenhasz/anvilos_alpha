{
  "module_name": "adt7470.c",
  "hash_id": "64926c934e21fafe747ae0a8e08ee15500c00654d4179ab9dadb705556b20abe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adt7470.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/log2.h>\n#include <linux/kthread.h>\n#include <linux/regmap.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/util_macros.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x2C, 0x2E, 0x2F, I2C_CLIENT_END };\n\n \n#define ADT7470_REG_BASE_ADDR\t\t\t0x20\n#define ADT7470_REG_TEMP_BASE_ADDR\t\t0x20\n#define ADT7470_REG_TEMP_MAX_ADDR\t\t0x29\n#define ADT7470_REG_FAN_BASE_ADDR\t\t0x2A\n#define ADT7470_REG_FAN_MAX_ADDR\t\t0x31\n#define ADT7470_REG_PWM_BASE_ADDR\t\t0x32\n#define ADT7470_REG_PWM_MAX_ADDR\t\t0x35\n#define ADT7470_REG_PWM_MAX_BASE_ADDR\t\t0x38\n#define ADT7470_REG_PWM_MAX_MAX_ADDR\t\t0x3B\n#define ADT7470_REG_CFG\t\t\t\t0x40\n#define\t\tADT7470_STRT_MASK\t\t0x01\n#define\t\tADT7470_TEST_MASK\t\t0x02\n#define\t\tADT7470_FSPD_MASK\t\t0x04\n#define\t\tADT7470_T05_STB_MASK\t\t0x80\n#define ADT7470_REG_ALARM1\t\t\t0x41\n#define\t\tADT7470_R1T_ALARM\t\t0x01\n#define\t\tADT7470_R2T_ALARM\t\t0x02\n#define\t\tADT7470_R3T_ALARM\t\t0x04\n#define\t\tADT7470_R4T_ALARM\t\t0x08\n#define\t\tADT7470_R5T_ALARM\t\t0x10\n#define\t\tADT7470_R6T_ALARM\t\t0x20\n#define\t\tADT7470_R7T_ALARM\t\t0x40\n#define\t\tADT7470_OOL_ALARM\t\t0x80\n#define ADT7470_REG_ALARM2\t\t\t0x42\n#define\t\tADT7470_R8T_ALARM\t\t0x01\n#define\t\tADT7470_R9T_ALARM\t\t0x02\n#define\t\tADT7470_R10T_ALARM\t\t0x04\n#define\t\tADT7470_FAN1_ALARM\t\t0x10\n#define\t\tADT7470_FAN2_ALARM\t\t0x20\n#define\t\tADT7470_FAN3_ALARM\t\t0x40\n#define\t\tADT7470_FAN4_ALARM\t\t0x80\n#define ADT7470_REG_TEMP_LIMITS_BASE_ADDR\t0x44\n#define ADT7470_REG_TEMP_LIMITS_MAX_ADDR\t0x57\n#define ADT7470_REG_FAN_MIN_BASE_ADDR\t\t0x58\n#define ADT7470_REG_FAN_MIN_MAX_ADDR\t\t0x5F\n#define ADT7470_REG_FAN_MAX_BASE_ADDR\t\t0x60\n#define ADT7470_REG_FAN_MAX_MAX_ADDR\t\t0x67\n#define ADT7470_REG_PWM_CFG_BASE_ADDR\t\t0x68\n#define ADT7470_REG_PWM12_CFG\t\t\t0x68\n#define\t\tADT7470_PWM2_AUTO_MASK\t\t0x40\n#define\t\tADT7470_PWM1_AUTO_MASK\t\t0x80\n#define\t\tADT7470_PWM_AUTO_MASK\t\t0xC0\n#define ADT7470_REG_PWM34_CFG\t\t\t0x69\n#define\t\tADT7470_PWM3_AUTO_MASK\t\t0x40\n#define\t\tADT7470_PWM4_AUTO_MASK\t\t0x80\n#define\tADT7470_REG_PWM_MIN_BASE_ADDR\t\t0x6A\n#define ADT7470_REG_PWM_MIN_MAX_ADDR\t\t0x6D\n#define ADT7470_REG_PWM_TEMP_MIN_BASE_ADDR\t0x6E\n#define ADT7470_REG_PWM_TEMP_MIN_MAX_ADDR\t0x71\n#define ADT7470_REG_CFG_2\t\t\t0x74\n#define ADT7470_REG_ACOUSTICS12\t\t\t0x75\n#define ADT7470_REG_ACOUSTICS34\t\t\t0x76\n#define ADT7470_REG_DEVICE\t\t\t0x3D\n#define ADT7470_REG_VENDOR\t\t\t0x3E\n#define ADT7470_REG_REVISION\t\t\t0x3F\n#define ADT7470_REG_ALARM1_MASK\t\t\t0x72\n#define ADT7470_REG_ALARM2_MASK\t\t\t0x73\n#define ADT7470_REG_PWM_AUTO_TEMP_BASE_ADDR\t0x7C\n#define ADT7470_REG_PWM_AUTO_TEMP_MAX_ADDR\t0x7D\n#define ADT7470_REG_MAX_ADDR\t\t\t0x81\n\n#define ADT7470_TEMP_COUNT\t10\n#define ADT7470_TEMP_REG(x)\t(ADT7470_REG_TEMP_BASE_ADDR + (x))\n#define ADT7470_TEMP_MIN_REG(x) (ADT7470_REG_TEMP_LIMITS_BASE_ADDR + ((x) * 2))\n#define ADT7470_TEMP_MAX_REG(x) (ADT7470_REG_TEMP_LIMITS_BASE_ADDR + \\\n\t\t\t\t((x) * 2) + 1)\n\n#define ADT7470_FAN_COUNT\t4\n#define ADT7470_REG_FAN(x)\t(ADT7470_REG_FAN_BASE_ADDR + ((x) * 2))\n#define ADT7470_REG_FAN_MIN(x)\t(ADT7470_REG_FAN_MIN_BASE_ADDR + ((x) * 2))\n#define ADT7470_REG_FAN_MAX(x)\t(ADT7470_REG_FAN_MAX_BASE_ADDR + ((x) * 2))\n\n#define ADT7470_PWM_COUNT\t4\n#define ADT7470_REG_PWM(x)\t(ADT7470_REG_PWM_BASE_ADDR + (x))\n#define ADT7470_REG_PWM_MAX(x)\t(ADT7470_REG_PWM_MAX_BASE_ADDR + (x))\n#define ADT7470_REG_PWM_MIN(x)\t(ADT7470_REG_PWM_MIN_BASE_ADDR + (x))\n#define ADT7470_REG_PWM_TMIN(x)\t(ADT7470_REG_PWM_TEMP_MIN_BASE_ADDR + (x))\n#define ADT7470_REG_PWM_CFG(x)\t(ADT7470_REG_PWM_CFG_BASE_ADDR + ((x) / 2))\n#define ADT7470_REG_PWM_AUTO_TEMP(x)\t(ADT7470_REG_PWM_AUTO_TEMP_BASE_ADDR + \\\n\t\t\t\t\t((x) / 2))\n\n#define ALARM2(x)\t\t((x) << 8)\n\n#define ADT7470_VENDOR\t\t0x41\n#define ADT7470_DEVICE\t\t0x70\n \n#define ADT7470_REVISION\t0x02\n\n \n#define ADT7470_PWM_ALL_TEMPS\t0x3FF\n\n \n#define SENSOR_REFRESH_INTERVAL\t(5 * HZ)\n\n \n#define LIMIT_REFRESH_INTERVAL\t(60 * HZ)\n\n \n#define TEMP_COLLECTION_TIME\t2000\n\n \n#define AUTO_UPDATE_INTERVAL\t2000\n\n \n#define FAN_PERIOD_TO_RPM(x)\t((90000 * 60) / (x))\n#define FAN_RPM_TO_PERIOD\tFAN_PERIOD_TO_RPM\n#define FAN_PERIOD_INVALID\t65535\n#define FAN_DATA_VALID(x)\t((x) && (x) != FAN_PERIOD_INVALID)\n\n \n#define ADT7470_CFG_LF\t\t0x40\n#define ADT7470_FREQ_MASK\t0x70\n#define ADT7470_FREQ_SHIFT\t4\n\nstruct adt7470_data {\n\tstruct regmap\t\t*regmap;\n\tstruct mutex\t\tlock;\n\tchar\t\t\tsensors_valid;\n\tchar\t\t\tlimits_valid;\n\tunsigned long\t\tsensors_last_updated;\t \n\tunsigned long\t\tlimits_last_updated;\t \n\n\tint\t\t\tnum_temp_sensors;\t \n\tint\t\t\ttemperatures_probed;\n\n\ts8\t\t\ttemp[ADT7470_TEMP_COUNT];\n\ts8\t\t\ttemp_min[ADT7470_TEMP_COUNT];\n\ts8\t\t\ttemp_max[ADT7470_TEMP_COUNT];\n\tu16\t\t\tfan[ADT7470_FAN_COUNT];\n\tu16\t\t\tfan_min[ADT7470_FAN_COUNT];\n\tu16\t\t\tfan_max[ADT7470_FAN_COUNT];\n\tu16\t\t\talarm;\n\tu16\t\t\talarms_mask;\n\tu8\t\t\tforce_pwm_max;\n\tu8\t\t\tpwm[ADT7470_PWM_COUNT];\n\tu8\t\t\tpwm_max[ADT7470_PWM_COUNT];\n\tu8\t\t\tpwm_automatic[ADT7470_PWM_COUNT];\n\tu8\t\t\tpwm_min[ADT7470_PWM_COUNT];\n\ts8\t\t\tpwm_tmin[ADT7470_PWM_COUNT];\n\tu8\t\t\tpwm_auto_temp[ADT7470_PWM_COUNT];\n\n\tstruct task_struct\t*auto_update;\n\tunsigned int\t\tauto_update_interval;\n};\n\n \nstatic inline int adt7470_read_word_data(struct adt7470_data *data, unsigned int reg,\n\t\t\t\t\t unsigned int *val)\n{\n\tu8 regval[2];\n\tint err;\n\n\terr = regmap_bulk_read(data->regmap, reg, &regval, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\t*val = regval[0] | (regval[1] << 8);\n\n\treturn 0;\n}\n\nstatic inline int adt7470_write_word_data(struct adt7470_data *data, unsigned int reg,\n\t\t\t\t\t  unsigned int val)\n{\n\tu8 regval[2];\n\n\tregval[0] = val & 0xFF;\n\tregval[1] = val >> 8;\n\n\treturn regmap_bulk_write(data->regmap, reg, &regval, 2);\n}\n\n \nstatic int adt7470_read_temperatures(struct adt7470_data *data)\n{\n\tunsigned long res;\n\tunsigned int pwm_cfg[2];\n\tint err;\n\tint i;\n\tu8 pwm[ADT7470_FAN_COUNT];\n\n\t \n\terr = regmap_read(data->regmap, ADT7470_REG_PWM_CFG(0), &pwm_cfg[0]);\n\tif (err < 0)\n\t\treturn err;\n\terr = regmap_read(data->regmap, ADT7470_REG_PWM_CFG(2), &pwm_cfg[1]);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = regmap_bulk_read(data->regmap, ADT7470_REG_PWM(0), &pwm[0],\n\t\t\t       ADT7470_PWM_COUNT);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = regmap_update_bits(data->regmap, ADT7470_REG_PWM_CFG(0),\n\t\t\t\t ADT7470_PWM_AUTO_MASK, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = regmap_update_bits(data->regmap, ADT7470_REG_PWM_CFG(2),\n\t\t\t\t ADT7470_PWM_AUTO_MASK, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = regmap_bulk_write(data->regmap, ADT7470_REG_PWM(0), &pwm[0],\n\t\t\t\tADT7470_PWM_COUNT);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = regmap_update_bits(data->regmap, ADT7470_REG_CFG,\n\t\t\t\t ADT7470_T05_STB_MASK, ADT7470_T05_STB_MASK);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tres = msleep_interruptible((data->num_temp_sensors >= 0 ?\n\t\t\t\t    data->num_temp_sensors * 200 :\n\t\t\t\t    TEMP_COLLECTION_TIME));\n\n\t \n\terr = regmap_update_bits(data->regmap, ADT7470_REG_CFG,\n\t\t\t\t ADT7470_T05_STB_MASK, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = regmap_write(data->regmap, ADT7470_REG_PWM_CFG(0), pwm_cfg[0]);\n\tif (err < 0)\n\t\treturn err;\n\terr = regmap_write(data->regmap, ADT7470_REG_PWM_CFG(2), pwm_cfg[1]);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (res)\n\t\treturn -EAGAIN;\n\n\t \n\tif (data->num_temp_sensors >= 0)\n\t\treturn 0;\n\n\terr = regmap_bulk_read(data->regmap, ADT7470_TEMP_REG(0), &data->temp[0],\n\t\t\t       ADT7470_TEMP_COUNT);\n\tif (err < 0)\n\t\treturn err;\n\tfor (i = 0; i < ADT7470_TEMP_COUNT; i++) {\n\t\tif (data->temp[i])\n\t\t\tdata->num_temp_sensors = i + 1;\n\t}\n\tdata->temperatures_probed = 1;\n\treturn 0;\n}\n\nstatic int adt7470_update_thread(void *p)\n{\n\tstruct i2c_client *client = p;\n\tstruct adt7470_data *data = i2c_get_clientdata(client);\n\n\twhile (!kthread_should_stop()) {\n\t\tmutex_lock(&data->lock);\n\t\tadt7470_read_temperatures(data);\n\t\tmutex_unlock(&data->lock);\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(data->auto_update_interval));\n\t}\n\n\treturn 0;\n}\n\nstatic int adt7470_update_sensors(struct adt7470_data *data)\n{\n\tunsigned int val;\n\tint err;\n\tint i;\n\n\tif (!data->temperatures_probed)\n\t\terr = adt7470_read_temperatures(data);\n\telse\n\t\terr = regmap_bulk_read(data->regmap, ADT7470_TEMP_REG(0), &data->temp[0],\n\t\t\t\t       ADT7470_TEMP_COUNT);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < ADT7470_FAN_COUNT; i++) {\n\t\terr = adt7470_read_word_data(data, ADT7470_REG_FAN(i), &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->fan[i] =\tval;\n\t}\n\n\terr = regmap_bulk_read(data->regmap, ADT7470_REG_PWM(0), &data->pwm[0], ADT7470_PWM_COUNT);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < ADT7470_PWM_COUNT; i++) {\n\t\tunsigned int mask;\n\n\t\tif (i % 2)\n\t\t\tmask = ADT7470_PWM2_AUTO_MASK;\n\t\telse\n\t\t\tmask = ADT7470_PWM1_AUTO_MASK;\n\n\t\terr = regmap_read(data->regmap, ADT7470_REG_PWM_CFG(i), &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->pwm_automatic[i] = !!(val & mask);\n\n\t\terr = regmap_read(data->regmap, ADT7470_REG_PWM_AUTO_TEMP(i), &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!(i % 2))\n\t\t\tdata->pwm_auto_temp[i] = val >> 4;\n\t\telse\n\t\t\tdata->pwm_auto_temp[i] = val & 0xF;\n\t}\n\n\terr = regmap_read(data->regmap, ADT7470_REG_CFG, &val);\n\tif (err < 0)\n\t\treturn err;\n\tdata->force_pwm_max = !!(val & ADT7470_FSPD_MASK);\n\n\terr = regmap_read(data->regmap, ADT7470_REG_ALARM1, &val);\n\tif (err < 0)\n\t\treturn err;\n\tdata->alarm = val;\n\tif (data->alarm & ADT7470_OOL_ALARM) {\n\t\terr = regmap_read(data->regmap, ADT7470_REG_ALARM2, &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->alarm |= ALARM2(val);\n\t}\n\n\terr = adt7470_read_word_data(data, ADT7470_REG_ALARM1_MASK, &val);\n\tif (err < 0)\n\t\treturn err;\n\tdata->alarms_mask = val;\n\n\treturn 0;\n}\n\nstatic int adt7470_update_limits(struct adt7470_data *data)\n{\n\tunsigned int val;\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < ADT7470_TEMP_COUNT; i++) {\n\t\terr = regmap_read(data->regmap, ADT7470_TEMP_MIN_REG(i), &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->temp_min[i] = (s8)val;\n\t\terr = regmap_read(data->regmap, ADT7470_TEMP_MAX_REG(i), &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->temp_max[i] = (s8)val;\n\t}\n\n\tfor (i = 0; i < ADT7470_FAN_COUNT; i++) {\n\t\terr = adt7470_read_word_data(data, ADT7470_REG_FAN_MIN(i), &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->fan_min[i] = val;\n\t\terr = adt7470_read_word_data(data, ADT7470_REG_FAN_MAX(i), &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->fan_max[i] = val;\n\t}\n\n\tfor (i = 0; i < ADT7470_PWM_COUNT; i++) {\n\t\terr = regmap_read(data->regmap, ADT7470_REG_PWM_MAX(i), &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->pwm_max[i] = val;\n\t\terr = regmap_read(data->regmap, ADT7470_REG_PWM_MIN(i), &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->pwm_min[i] = val;\n\t\terr = regmap_read(data->regmap, ADT7470_REG_PWM_TMIN(i), &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->pwm_tmin[i] = (s8)val;\n\t}\n\n\treturn 0;\n}\n\nstatic struct adt7470_data *adt7470_update_device(struct device *dev)\n{\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tunsigned long local_jiffies = jiffies;\n\tint need_sensors = 1;\n\tint need_limits = 1;\n\tint err;\n\n\t \n\tif (time_before(local_jiffies, data->sensors_last_updated +\n\t\t\tSENSOR_REFRESH_INTERVAL) &&\n\t    data->sensors_valid)\n\t\tneed_sensors = 0;\n\n\tif (time_before(local_jiffies, data->limits_last_updated +\n\t\t\tLIMIT_REFRESH_INTERVAL) &&\n\t    data->limits_valid)\n\t\tneed_limits = 0;\n\n\tif (!need_sensors && !need_limits)\n\t\treturn data;\n\n\tmutex_lock(&data->lock);\n\tif (need_sensors) {\n\t\terr = adt7470_update_sensors(data);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tdata->sensors_last_updated = local_jiffies;\n\t\tdata->sensors_valid = 1;\n\t}\n\n\tif (need_limits) {\n\t\terr = adt7470_update_limits(data);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tdata->limits_last_updated = local_jiffies;\n\t\tdata->limits_valid = 1;\n\t}\nout:\n\tmutex_unlock(&data->lock);\n\n\treturn err < 0 ? ERR_PTR(err) : data;\n}\n\nstatic ssize_t auto_update_interval_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *devattr,\n\t\t\t\t\t char *buf)\n{\n\tstruct adt7470_data *data = adt7470_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->auto_update_interval);\n}\n\nstatic ssize_t auto_update_interval_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *devattr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, 0, 60000);\n\n\tmutex_lock(&data->lock);\n\tdata->auto_update_interval = temp;\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t num_temp_sensors_show(struct device *dev,\n\t\t\t\t     struct device_attribute *devattr,\n\t\t\t\t     char *buf)\n{\n\tstruct adt7470_data *data = adt7470_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->num_temp_sensors);\n}\n\nstatic ssize_t num_temp_sensors_store(struct device *dev,\n\t\t\t\t      struct device_attribute *devattr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tlong temp;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, -1, 10);\n\n\tmutex_lock(&data->lock);\n\tdata->num_temp_sensors = temp;\n\tif (temp < 0)\n\t\tdata->temperatures_probed = 0;\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic int adt7470_temp_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct adt7470_data *data = adt7470_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\t*val = 1000 * data->temp[channel];\n\t\tbreak;\n\tcase hwmon_temp_min:\n\t\t*val = 1000 * data->temp_min[channel];\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\t*val = 1000 * data->temp_max[channel];\n\t\tbreak;\n\tcase hwmon_temp_alarm:\n\t\t*val = !!(data->alarm & channel);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int adt7470_temp_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tint err;\n\n\tval = clamp_val(val, -128000, 127000);\n\tval = DIV_ROUND_CLOSEST(val, 1000);\n\n\tswitch (attr) {\n\tcase hwmon_temp_min:\n\t\tmutex_lock(&data->lock);\n\t\tdata->temp_min[channel] = val;\n\t\terr = regmap_write(data->regmap, ADT7470_TEMP_MIN_REG(channel), val);\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\tmutex_lock(&data->lock);\n\t\tdata->temp_max[channel] = val;\n\t\terr = regmap_write(data->regmap, ADT7470_TEMP_MAX_REG(channel), val);\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic ssize_t alarm_mask_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tstruct adt7470_data *data = adt7470_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%x\\n\", data->alarms_mask);\n}\n\nstatic ssize_t alarm_mask_store(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tlong mask;\n\tint err;\n\n\tif (kstrtoul(buf, 0, &mask))\n\t\treturn -EINVAL;\n\n\tif (mask & ~0xffff)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\tdata->alarms_mask = mask;\n\terr = adt7470_write_word_data(data, ADT7470_REG_ALARM1_MASK, mask);\n\tmutex_unlock(&data->lock);\n\n\treturn err < 0 ? err : count;\n}\n\nstatic int adt7470_fan_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct adt7470_data *data = adt7470_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\t\tif (FAN_DATA_VALID(data->fan[channel]))\n\t\t\t*val = FAN_PERIOD_TO_RPM(data->fan[channel]);\n\t\telse\n\t\t\t*val = 0;\n\t\tbreak;\n\tcase hwmon_fan_min:\n\t\tif (FAN_DATA_VALID(data->fan_min[channel]))\n\t\t\t*val = FAN_PERIOD_TO_RPM(data->fan_min[channel]);\n\t\telse\n\t\t\t*val = 0;\n\t\tbreak;\n\tcase hwmon_fan_max:\n\t\tif (FAN_DATA_VALID(data->fan_max[channel]))\n\t\t\t*val = FAN_PERIOD_TO_RPM(data->fan_max[channel]);\n\t\telse\n\t\t\t*val = 0;\n\t\tbreak;\n\tcase hwmon_fan_alarm:\n\t\t*val = !!(data->alarm & (1 << (12 + channel)));\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int adt7470_fan_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tint err;\n\n\tif (val <= 0)\n\t\treturn -EINVAL;\n\n\tval = FAN_RPM_TO_PERIOD(val);\n\tval = clamp_val(val, 1, 65534);\n\n\tswitch (attr) {\n\tcase hwmon_fan_min:\n\t\tmutex_lock(&data->lock);\n\t\tdata->fan_min[channel] = val;\n\t\terr = adt7470_write_word_data(data, ADT7470_REG_FAN_MIN(channel), val);\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tcase hwmon_fan_max:\n\t\tmutex_lock(&data->lock);\n\t\tdata->fan_max[channel] = val;\n\t\terr = adt7470_write_word_data(data, ADT7470_REG_FAN_MAX(channel), val);\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic ssize_t force_pwm_max_show(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\tstruct adt7470_data *data = adt7470_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->force_pwm_max);\n}\n\nstatic ssize_t force_pwm_max_store(struct device *dev,\n\t\t\t\t   struct device_attribute *devattr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tlong temp;\n\tint err;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\tdata->force_pwm_max = temp;\n\terr = regmap_update_bits(data->regmap, ADT7470_REG_CFG,\n\t\t\t\t ADT7470_FSPD_MASK,\n\t\t\t\t temp ? ADT7470_FSPD_MASK : 0);\n\tmutex_unlock(&data->lock);\n\n\treturn err < 0 ? err : count;\n}\n\n \nstatic const int adt7470_freq_map[] = {\n\t11, 15, 22, 29, 35, 44, 59, 88, 1400, 22500\n};\n\nstatic int pwm1_freq_get(struct device *dev)\n{\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tunsigned int cfg_reg_1, cfg_reg_2;\n\tint index;\n\tint err;\n\n\tmutex_lock(&data->lock);\n\terr = regmap_read(data->regmap, ADT7470_REG_CFG, &cfg_reg_1);\n\tif (err < 0)\n\t\tgoto out;\n\terr = regmap_read(data->regmap, ADT7470_REG_CFG_2, &cfg_reg_2);\n\tif (err < 0)\n\t\tgoto out;\n\tmutex_unlock(&data->lock);\n\n\tindex = (cfg_reg_2 & ADT7470_FREQ_MASK) >> ADT7470_FREQ_SHIFT;\n\tif (!(cfg_reg_1 & ADT7470_CFG_LF))\n\t\tindex += 8;\n\tif (index >= ARRAY_SIZE(adt7470_freq_map))\n\t\tindex = ARRAY_SIZE(adt7470_freq_map) - 1;\n\n\treturn adt7470_freq_map[index];\n\nout:\n\tmutex_unlock(&data->lock);\n\treturn err;\n}\n\nstatic int adt7470_pwm_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct adt7470_data *data = adt7470_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\t*val = data->pwm[channel];\n\t\tbreak;\n\tcase hwmon_pwm_enable:\n\t\t*val = 1 + data->pwm_automatic[channel];\n\t\tbreak;\n\tcase hwmon_pwm_freq:\n\t\t*val = pwm1_freq_get(dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int pwm1_freq_set(struct device *dev, long freq)\n{\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tunsigned int low_freq = ADT7470_CFG_LF;\n\tint index;\n\tint err;\n\n\t \n\tindex = find_closest(freq, adt7470_freq_map,\n\t\t\t     ARRAY_SIZE(adt7470_freq_map));\n\n\tif (index >= 8) {\n\t\tindex -= 8;\n\t\tlow_freq = 0;\n\t}\n\n\tmutex_lock(&data->lock);\n\t \n\terr = regmap_update_bits(data->regmap, ADT7470_REG_CFG,\n\t\t\t\t ADT7470_CFG_LF, low_freq);\n\tif (err < 0)\n\t\tgoto out;\n\n\t \n\terr = regmap_update_bits(data->regmap, ADT7470_REG_CFG_2,\n\t\t\t\t ADT7470_FREQ_MASK,\n\t\t\t\t index << ADT7470_FREQ_SHIFT);\nout:\n\tmutex_unlock(&data->lock);\n\n\treturn err;\n}\n\nstatic int adt7470_pwm_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tunsigned int pwm_auto_reg_mask;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\tval = clamp_val(val, 0, 255);\n\t\tmutex_lock(&data->lock);\n\t\tdata->pwm[channel] = val;\n\t\terr = regmap_write(data->regmap, ADT7470_REG_PWM(channel),\n\t\t\t\t   data->pwm[channel]);\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tcase hwmon_pwm_enable:\n\t\tif (channel % 2)\n\t\t\tpwm_auto_reg_mask = ADT7470_PWM2_AUTO_MASK;\n\t\telse\n\t\t\tpwm_auto_reg_mask = ADT7470_PWM1_AUTO_MASK;\n\n\t\tif (val != 2 && val != 1)\n\t\t\treturn -EINVAL;\n\t\tval--;\n\n\t\tmutex_lock(&data->lock);\n\t\tdata->pwm_automatic[channel] = val;\n\t\terr = regmap_update_bits(data->regmap, ADT7470_REG_PWM_CFG(channel),\n\t\t\t\t\t pwm_auto_reg_mask,\n\t\t\t\t\t val ? pwm_auto_reg_mask : 0);\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tcase hwmon_pwm_freq:\n\t\terr = pwm1_freq_set(dev, val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic ssize_t pwm_max_show(struct device *dev,\n\t\t\t    struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7470_data *data = adt7470_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->pwm_max[attr->index]);\n}\n\nstatic ssize_t pwm_max_store(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tlong temp;\n\tint err;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, 0, 255);\n\n\tmutex_lock(&data->lock);\n\tdata->pwm_max[attr->index] = temp;\n\terr = regmap_write(data->regmap, ADT7470_REG_PWM_MAX(attr->index),\n\t\t\t   temp);\n\tmutex_unlock(&data->lock);\n\n\treturn err < 0 ? err : count;\n}\n\nstatic ssize_t pwm_min_show(struct device *dev,\n\t\t\t    struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7470_data *data = adt7470_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->pwm_min[attr->index]);\n}\n\nstatic ssize_t pwm_min_store(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tlong temp;\n\tint err;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, 0, 255);\n\n\tmutex_lock(&data->lock);\n\tdata->pwm_min[attr->index] = temp;\n\terr = regmap_write(data->regmap, ADT7470_REG_PWM_MIN(attr->index),\n\t\t\t   temp);\n\tmutex_unlock(&data->lock);\n\n\treturn err < 0 ? err : count;\n}\n\nstatic ssize_t pwm_tmax_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7470_data *data = adt7470_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t \n\treturn sprintf(buf, \"%d\\n\", 1000 * (20 + data->pwm_tmin[attr->index]));\n}\n\nstatic ssize_t pwm_tmin_show(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7470_data *data = adt7470_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", 1000 * data->pwm_tmin[attr->index]);\n}\n\nstatic ssize_t pwm_tmin_store(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tlong temp;\n\tint err;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = clamp_val(temp, -128000, 127000);\n\ttemp = DIV_ROUND_CLOSEST(temp, 1000);\n\n\tmutex_lock(&data->lock);\n\tdata->pwm_tmin[attr->index] = temp;\n\terr = regmap_write(data->regmap, ADT7470_REG_PWM_TMIN(attr->index),\n\t\t\t   temp);\n\tmutex_unlock(&data->lock);\n\n\treturn err < 0 ? err : count;\n}\n\nstatic ssize_t pwm_auto_temp_show(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7470_data *data = adt7470_update_device(dev);\n\tu8 ctrl;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tctrl = data->pwm_auto_temp[attr->index];\n\tif (ctrl)\n\t\treturn sprintf(buf, \"%d\\n\", 1 << (ctrl - 1));\n\telse\n\t\treturn sprintf(buf, \"%d\\n\", ADT7470_PWM_ALL_TEMPS);\n}\n\nstatic int cvt_auto_temp(int input)\n{\n\tif (input == ADT7470_PWM_ALL_TEMPS)\n\t\treturn 0;\n\tif (input < 1 || !is_power_of_2(input))\n\t\treturn -EINVAL;\n\treturn ilog2(input) + 1;\n}\n\nstatic ssize_t pwm_auto_temp_store(struct device *dev,\n\t\t\t\t   struct device_attribute *devattr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adt7470_data *data = dev_get_drvdata(dev);\n\tint pwm_auto_reg = ADT7470_REG_PWM_AUTO_TEMP(attr->index);\n\tunsigned int mask, val;\n\tlong temp;\n\tint err;\n\n\tif (kstrtol(buf, 10, &temp))\n\t\treturn -EINVAL;\n\n\ttemp = cvt_auto_temp(temp);\n\tif (temp < 0)\n\t\treturn temp;\n\n\tmutex_lock(&data->lock);\n\tdata->pwm_automatic[attr->index] = temp;\n\n\tif (!(attr->index % 2)) {\n\t\tmask = 0xF0;\n\t\tval = (temp << 4) & 0xF0;\n\t} else {\n\t\tmask = 0x0F;\n\t\tval = temp & 0x0F;\n\t}\n\n\terr = regmap_update_bits(data->regmap, pwm_auto_reg, mask, val);\n\tmutex_unlock(&data->lock);\n\n\treturn err < 0 ? err : count;\n}\n\nstatic DEVICE_ATTR_RW(alarm_mask);\nstatic DEVICE_ATTR_RW(num_temp_sensors);\nstatic DEVICE_ATTR_RW(auto_update_interval);\n\nstatic SENSOR_DEVICE_ATTR_RW(force_pwm_max, force_pwm_max, 0);\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point1_pwm, pwm_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_point1_pwm, pwm_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_point1_pwm, pwm_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm4_auto_point1_pwm, pwm_min, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point2_pwm, pwm_max, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_point2_pwm, pwm_max, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_point2_pwm, pwm_max, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm4_auto_point2_pwm, pwm_max, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point1_temp, pwm_tmin, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_point1_temp, pwm_tmin, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_point1_temp, pwm_tmin, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm4_auto_point1_temp, pwm_tmin, 3);\n\nstatic SENSOR_DEVICE_ATTR_RO(pwm1_auto_point2_temp, pwm_tmax, 0);\nstatic SENSOR_DEVICE_ATTR_RO(pwm2_auto_point2_temp, pwm_tmax, 1);\nstatic SENSOR_DEVICE_ATTR_RO(pwm3_auto_point2_temp, pwm_tmax, 2);\nstatic SENSOR_DEVICE_ATTR_RO(pwm4_auto_point2_temp, pwm_tmax, 3);\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_channels_temp, pwm_auto_temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_channels_temp, pwm_auto_temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_channels_temp, pwm_auto_temp, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm4_auto_channels_temp, pwm_auto_temp, 3);\n\nstatic struct attribute *adt7470_attrs[] = {\n\t&dev_attr_alarm_mask.attr,\n\t&dev_attr_num_temp_sensors.attr,\n\t&dev_attr_auto_update_interval.attr,\n\t&sensor_dev_attr_force_pwm_max.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_channels_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_channels_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_channels_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_auto_channels_temp.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(adt7470);\n\nstatic int adt7470_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\tint channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn adt7470_temp_read(dev, attr, channel, val);\n\tcase hwmon_fan:\n\t\treturn adt7470_fan_read(dev, attr, channel, val);\n\tcase hwmon_pwm:\n\t\treturn adt7470_pwm_read(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int adt7470_write(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn adt7470_temp_write(dev, attr, channel, val);\n\tcase hwmon_fan:\n\t\treturn adt7470_fan_write(dev, attr, channel, val);\n\tcase hwmon_pwm:\n\t\treturn adt7470_pwm_write(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t adt7470_is_visible(const void *_data, enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tumode_t mode = 0;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp:\n\t\tcase hwmon_temp_alarm:\n\t\t\tmode = 0444;\n\t\t\tbreak;\n\t\tcase hwmon_temp_min:\n\t\tcase hwmon_temp_max:\n\t\t\tmode = 0644;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\tcase hwmon_fan_alarm:\n\t\t\tmode = 0444;\n\t\t\tbreak;\n\t\tcase hwmon_fan_min:\n\t\tcase hwmon_fan_max:\n\t\t\tmode = 0644;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\tcase hwmon_pwm_enable:\n\t\t\tmode = 0644;\n\t\t\tbreak;\n\t\tcase hwmon_pwm_freq:\n\t\t\tif (channel == 0)\n\t\t\t\tmode = 0644;\n\t\t\telse\n\t\t\t\tmode = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n\nstatic const struct hwmon_ops adt7470_hwmon_ops = {\n\t.is_visible = adt7470_is_visible,\n\t.read = adt7470_read,\n\t.write = adt7470_write,\n};\n\nstatic const struct hwmon_channel_info * const adt7470_info[] = {\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX | HWMON_T_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX | HWMON_T_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX | HWMON_T_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX | HWMON_T_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX | HWMON_T_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX | HWMON_T_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX | HWMON_T_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX | HWMON_T_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX | HWMON_T_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX | HWMON_T_ALARM),\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_MAX | HWMON_F_DIV | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_MAX | HWMON_F_DIV | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_MAX | HWMON_F_DIV | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_MAX | HWMON_F_DIV | HWMON_F_ALARM),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE | HWMON_PWM_FREQ,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info adt7470_chip_info = {\n\t.ops = &adt7470_hwmon_ops,\n\t.info = adt7470_info,\n};\n\n \nstatic int adt7470_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint vendor, device, revision;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tvendor = i2c_smbus_read_byte_data(client, ADT7470_REG_VENDOR);\n\tif (vendor != ADT7470_VENDOR)\n\t\treturn -ENODEV;\n\n\tdevice = i2c_smbus_read_byte_data(client, ADT7470_REG_DEVICE);\n\tif (device != ADT7470_DEVICE)\n\t\treturn -ENODEV;\n\n\trevision = i2c_smbus_read_byte_data(client, ADT7470_REG_REVISION);\n\tif (revision != ADT7470_REVISION)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"adt7470\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config adt7470_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int adt7470_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct adt7470_data *data;\n\tstruct device *hwmon_dev;\n\tint err;\n\n\tdata = devm_kzalloc(dev, sizeof(struct adt7470_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->num_temp_sensors = -1;\n\tdata->auto_update_interval = AUTO_UPDATE_INTERVAL;\n\tdata->regmap = devm_regmap_init_i2c(client, &adt7470_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->lock);\n\n\tdev_info(&client->dev, \"%s chip found\\n\", client->name);\n\n\t \n\terr = regmap_update_bits(data->regmap, ADT7470_REG_CFG,\n\t\t\t\t ADT7470_STRT_MASK | ADT7470_TEST_MASK,\n\t\t\t\t ADT7470_STRT_MASK | ADT7470_TEST_MASK);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name, data,\n\t\t\t\t\t\t\t &adt7470_chip_info,\n\t\t\t\t\t\t\t adt7470_groups);\n\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdata->auto_update = kthread_run(adt7470_update_thread, client, \"%s\",\n\t\t\t\t\tdev_name(hwmon_dev));\n\tif (IS_ERR(data->auto_update))\n\t\treturn PTR_ERR(data->auto_update);\n\n\treturn 0;\n}\n\nstatic void adt7470_remove(struct i2c_client *client)\n{\n\tstruct adt7470_data *data = i2c_get_clientdata(client);\n\n\tkthread_stop(data->auto_update);\n}\n\nstatic const struct i2c_device_id adt7470_id[] = {\n\t{ \"adt7470\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adt7470_id);\n\nstatic struct i2c_driver adt7470_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"adt7470\",\n\t},\n\t.probe\t\t= adt7470_probe,\n\t.remove\t\t= adt7470_remove,\n\t.id_table\t= adt7470_id,\n\t.detect\t\t= adt7470_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(adt7470_driver);\n\nMODULE_AUTHOR(\"Darrick J. Wong <darrick.wong@oracle.com>\");\nMODULE_DESCRIPTION(\"ADT7470 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}