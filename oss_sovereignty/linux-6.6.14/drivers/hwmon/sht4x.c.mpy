{
  "module_name": "sht4x.c",
  "hash_id": "9860dfaa2de7ec3ad73b2b0496cd0923a3341f48e26e4188b6f05d6cdd0460c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/sht4x.c",
  "human_readable_source": "\n\n \n\n#include <linux/crc8.h>\n#include <linux/delay.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\n \n#define SHT4X_MIN_POLL_INTERVAL\t2000\n\n \n#define SHT4X_MEAS_DELAY_HPM\t8200\t \n#define SHT4X_DELAY_EXTRA\t10000\n\n \n#define SHT4X_CMD_MEASURE_HPM\t0b11111101\n#define SHT4X_CMD_RESET\t\t0b10010100\n\n#define SHT4X_CMD_LEN\t\t1\n#define SHT4X_CRC8_LEN\t\t1\n#define SHT4X_WORD_LEN\t\t2\n#define SHT4X_RESPONSE_LENGTH\t6\n#define SHT4X_CRC8_POLYNOMIAL\t0x31\n#define SHT4X_CRC8_INIT\t\t0xff\n#define SHT4X_MIN_TEMPERATURE\t-45000\n#define SHT4X_MAX_TEMPERATURE\t125000\n#define SHT4X_MIN_HUMIDITY\t0\n#define SHT4X_MAX_HUMIDITY\t100000\n\nDECLARE_CRC8_TABLE(sht4x_crc8_table);\n\n \nstruct sht4x_data {\n\tstruct i2c_client\t*client;\n\tstruct mutex\t\tlock;\t \n\tbool\t\t\tvalid;\t \n\tlong\t\t\tupdate_interval;\t \n\tlong\t\t\tlast_updated;\t \n\ts32\t\t\ttemperature;\n\ts32\t\t\thumidity;\n};\n\n \nstatic int sht4x_read_values(struct sht4x_data *data)\n{\n\tint ret = 0;\n\tu16 t_ticks, rh_ticks;\n\tunsigned long next_update;\n\tstruct i2c_client *client = data->client;\n\tu8 crc;\n\tu8 cmd[SHT4X_CMD_LEN] = {SHT4X_CMD_MEASURE_HPM};\n\tu8 raw_data[SHT4X_RESPONSE_LENGTH];\n\n\tmutex_lock(&data->lock);\n\tnext_update = data->last_updated +\n\t\t      msecs_to_jiffies(data->update_interval);\n\n\tif (data->valid && time_before_eq(jiffies, next_update))\n\t\tgoto unlock;\n\n\tret = i2c_master_send(client, cmd, SHT4X_CMD_LEN);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tusleep_range(SHT4X_MEAS_DELAY_HPM, SHT4X_MEAS_DELAY_HPM + SHT4X_DELAY_EXTRA);\n\n\tret = i2c_master_recv(client, raw_data, SHT4X_RESPONSE_LENGTH);\n\tif (ret != SHT4X_RESPONSE_LENGTH) {\n\t\tif (ret >= 0)\n\t\t\tret = -ENODATA;\n\t\tgoto unlock;\n\t}\n\n\tt_ticks = raw_data[0] << 8 | raw_data[1];\n\trh_ticks = raw_data[3] << 8 | raw_data[4];\n\n\tcrc = crc8(sht4x_crc8_table, &raw_data[0], SHT4X_WORD_LEN, CRC8_INIT_VALUE);\n\tif (crc != raw_data[2]) {\n\t\tdev_err(&client->dev, \"data integrity check failed\\n\");\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tcrc = crc8(sht4x_crc8_table, &raw_data[3], SHT4X_WORD_LEN, CRC8_INIT_VALUE);\n\tif (crc != raw_data[5]) {\n\t\tdev_err(&client->dev, \"data integrity check failed\\n\");\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tdata->temperature = ((21875 * (int32_t)t_ticks) >> 13) - 45000;\n\tdata->humidity = ((15625 * (int32_t)rh_ticks) >> 13) - 6000;\n\tdata->last_updated = jiffies;\n\tdata->valid = true;\n\tret = 0;\n\nunlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic ssize_t sht4x_interval_write(struct sht4x_data *data, long val)\n{\n\tdata->update_interval = clamp_val(val, SHT4X_MIN_POLL_INTERVAL, INT_MAX);\n\n\treturn 0;\n}\n\n \nstatic size_t sht4x_interval_read(struct sht4x_data *data, long *val)\n{\n\t*val = data->update_interval;\n\treturn 0;\n}\n\n \nstatic int sht4x_temperature1_read(struct sht4x_data *data, long *val)\n{\n\tint ret;\n\n\tret = sht4x_read_values(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = data->temperature;\n\n\treturn 0;\n}\n\n \nstatic int sht4x_humidity1_read(struct sht4x_data *data, long *val)\n{\n\tint ret;\n\n\tret = sht4x_read_values(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = data->humidity;\n\n\treturn 0;\n}\n\nstatic umode_t sht4x_hwmon_visible(const void *data,\n\t\t\t\t   enum hwmon_sensor_types type,\n\t\t\t\t   u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\tcase hwmon_humidity:\n\t\treturn 0444;\n\tcase hwmon_chip:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int sht4x_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t    u32 attr, int channel, long *val)\n{\n\tstruct sht4x_data *data = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn sht4x_temperature1_read(data, val);\n\tcase hwmon_humidity:\n\t\treturn sht4x_humidity1_read(data, val);\n\tcase hwmon_chip:\n\t\treturn sht4x_interval_read(data, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int sht4x_hwmon_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel, long val)\n{\n\tstruct sht4x_data *data = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn sht4x_interval_write(data, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const sht4x_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT),\n\tHWMON_CHANNEL_INFO(humidity, HWMON_H_INPUT),\n\tNULL,\n};\n\nstatic const struct hwmon_ops sht4x_hwmon_ops = {\n\t.is_visible = sht4x_hwmon_visible,\n\t.read = sht4x_hwmon_read,\n\t.write = sht4x_hwmon_write,\n};\n\nstatic const struct hwmon_chip_info sht4x_chip_info = {\n\t.ops = &sht4x_hwmon_ops,\n\t.info = sht4x_info,\n};\n\nstatic int sht4x_probe(struct i2c_client *client)\n{\n\tstruct device *device = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct sht4x_data *data;\n\tu8 cmd[] = {SHT4X_CMD_RESET};\n\tint ret;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -EOPNOTSUPP;\n\n\tdata = devm_kzalloc(device, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->update_interval = SHT4X_MIN_POLL_INTERVAL;\n\tdata->client = client;\n\n\tmutex_init(&data->lock);\n\n\tcrc8_populate_msb(sht4x_crc8_table, SHT4X_CRC8_POLYNOMIAL);\n\n\tret = i2c_master_send(client, cmd, SHT4X_CMD_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != SHT4X_CMD_LEN)\n\t\treturn -EIO;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(device,\n\t\t\t\t\t\t\t client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &sht4x_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id sht4x_id[] = {\n\t{ \"sht4x\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, sht4x_id);\n\nstatic const struct of_device_id sht4x_of_match[] = {\n\t{ .compatible = \"sensirion,sht4x\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sht4x_of_match);\n\nstatic struct i2c_driver sht4x_driver = {\n\t.driver = {\n\t\t.name = \"sht4x\",\n\t\t.of_match_table = sht4x_of_match,\n\t},\n\t.probe\t\t= sht4x_probe,\n\t.id_table\t= sht4x_id,\n};\n\nmodule_i2c_driver(sht4x_driver);\n\nMODULE_AUTHOR(\"Navin Sankar Velliangiri <navin@linumiz.com>\");\nMODULE_DESCRIPTION(\"Sensirion SHT4x humidity and temperature sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}