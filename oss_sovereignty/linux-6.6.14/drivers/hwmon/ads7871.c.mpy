{
  "module_name": "ads7871.c",
  "hash_id": "1d09658114e3e6dfd2bf61cae214a0a47f14d47c3550fa00b5dd8953ca119938",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ads7871.c",
  "human_readable_source": "\n \n\n \n \n#define REG_LS_BYTE\t0  \n#define REG_MS_BYTE\t1  \n#define REG_PGA_VALID\t2  \n#define REG_AD_CONTROL\t3  \n#define REG_GAIN_MUX\t4  \n#define REG_IO_STATE\t5  \n#define REG_IO_CONTROL\t6  \n#define REG_OSC_CONTROL\t7  \n#define REG_SER_CONTROL 24  \n#define REG_ID\t\t31  \n\n \n \n#define INST_MODE_BM\t(1 << 7)\n#define INST_READ_BM\t(1 << 6)\n#define INST_16BIT_BM\t(1 << 5)\n\n \n \n#define MUX_CNV_BV\t7\n#define MUX_CNV_BM\t(1 << MUX_CNV_BV)\n#define MUX_M3_BM\t(1 << 3)  \n#define MUX_G_BV\t4  \n\n \n \n#define OSC_OSCR_BM\t(1 << 5)\n#define OSC_OSCE_BM\t(1 << 4)\n#define OSC_REFE_BM\t(1 << 3)\n#define OSC_BUFE_BM\t(1 << 2)\n#define OSC_R2V_BM\t(1 << 1)\n#define OSC_RBG_BM\t(1 << 0)\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/spi/spi.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n\n#define DEVICE_NAME\t\"ads7871\"\n\nstruct ads7871_data {\n\tstruct spi_device *spi;\n};\n\nstatic int ads7871_read_reg8(struct spi_device *spi, int reg)\n{\n\tint ret;\n\treg = reg | INST_READ_BM;\n\tret = spi_w8r8(spi, reg);\n\treturn ret;\n}\n\nstatic int ads7871_read_reg16(struct spi_device *spi, int reg)\n{\n\tint ret;\n\treg = reg | INST_READ_BM | INST_16BIT_BM;\n\tret = spi_w8r16(spi, reg);\n\treturn ret;\n}\n\nstatic int ads7871_write_reg8(struct spi_device *spi, int reg, u8 val)\n{\n\tu8 tmp[2] = {reg, val};\n\treturn spi_write(spi, tmp, sizeof(tmp));\n}\n\nstatic ssize_t voltage_show(struct device *dev, struct device_attribute *da,\n\t\t\t    char *buf)\n{\n\tstruct ads7871_data *pdata = dev_get_drvdata(dev);\n\tstruct spi_device *spi = pdata->spi;\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tint ret, val, i = 0;\n\tuint8_t channel, mux_cnv;\n\n\tchannel = attr->index;\n\t \n\t \n\t \n\tads7871_write_reg8(spi, REG_GAIN_MUX,\n\t\t(MUX_CNV_BM | MUX_M3_BM | channel));\n\n\tret = ads7871_read_reg8(spi, REG_GAIN_MUX);\n\tmux_cnv = ((ret & MUX_CNV_BM) >> MUX_CNV_BV);\n\t \n\twhile ((i < 2) && mux_cnv) {\n\t\ti++;\n\t\tret = ads7871_read_reg8(spi, REG_GAIN_MUX);\n\t\tmux_cnv = ((ret & MUX_CNV_BM) >> MUX_CNV_BV);\n\t\tmsleep_interruptible(1);\n\t}\n\n\tif (mux_cnv == 0) {\n\t\tval = ads7871_read_reg16(spi, REG_LS_BYTE);\n\t\t \n\t\tval = ((val >> 2) * 25000) / 8192;\n\t\treturn sprintf(buf, \"%d\\n\", val);\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_input, voltage, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, voltage, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, voltage, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, voltage, 3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, voltage, 4);\nstatic SENSOR_DEVICE_ATTR_RO(in5_input, voltage, 5);\nstatic SENSOR_DEVICE_ATTR_RO(in6_input, voltage, 6);\nstatic SENSOR_DEVICE_ATTR_RO(in7_input, voltage, 7);\n\nstatic struct attribute *ads7871_attrs[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(ads7871);\n\nstatic int ads7871_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tint ret;\n\tuint8_t val;\n\tstruct ads7871_data *pdata;\n\tstruct device *hwmon_dev;\n\n\t \n\tspi->mode = (SPI_MODE_0);\n\tspi->bits_per_word = 8;\n\tspi_setup(spi);\n\n\tads7871_write_reg8(spi, REG_SER_CONTROL, 0);\n\tads7871_write_reg8(spi, REG_AD_CONTROL, 0);\n\n\tval = (OSC_OSCR_BM | OSC_OSCE_BM | OSC_REFE_BM | OSC_BUFE_BM);\n\tads7871_write_reg8(spi, REG_OSC_CONTROL, val);\n\tret = ads7871_read_reg8(spi, REG_OSC_CONTROL);\n\n\tdev_dbg(dev, \"REG_OSC_CONTROL write:%x, read:%x\\n\", val, ret);\n\t \n\tif (val != ret)\n\t\treturn -ENODEV;\n\n\tpdata = devm_kzalloc(dev, sizeof(struct ads7871_data), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->spi = spi;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, spi->modalias,\n\t\t\t\t\t\t\t   pdata,\n\t\t\t\t\t\t\t   ads7871_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic struct spi_driver ads7871_driver = {\n\t.driver = {\n\t\t.name = DEVICE_NAME,\n\t},\n\t.probe = ads7871_probe,\n};\n\nmodule_spi_driver(ads7871_driver);\n\nMODULE_AUTHOR(\"Paul Thomas <pthomas8589@gmail.com>\");\nMODULE_DESCRIPTION(\"TI ADS7871 A/D driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}