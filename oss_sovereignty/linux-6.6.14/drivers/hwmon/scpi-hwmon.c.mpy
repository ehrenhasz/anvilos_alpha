{
  "module_name": "scpi-hwmon.c",
  "hash_id": "a7486aab97478911d3923e61a4209b13b0d5fd574d34c025f6a76dd82b930bac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/scpi-hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/hwmon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/scpi_protocol.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/thermal.h>\n\nstruct sensor_data {\n\tunsigned int scale;\n\tstruct scpi_sensor_info info;\n\tstruct device_attribute dev_attr_input;\n\tstruct device_attribute dev_attr_label;\n\tchar input[20];\n\tchar label[20];\n};\n\nstruct scpi_thermal_zone {\n\tint sensor_id;\n\tstruct scpi_sensors *scpi_sensors;\n};\n\nstruct scpi_sensors {\n\tstruct scpi_ops *scpi_ops;\n\tstruct sensor_data *data;\n\tstruct list_head thermal_zones;\n\tstruct attribute **attrs;\n\tstruct attribute_group group;\n\tconst struct attribute_group *groups[2];\n};\n\nstatic const u32 gxbb_scpi_scale[] = {\n\t[TEMPERATURE]\t= 1,\t\t \n\t[VOLTAGE]\t= 1000,\t\t \n\t[CURRENT]\t= 1000,\t\t \n\t[POWER]\t\t= 1000000,\t \n\t[ENERGY]\t= 1000000,\t \n};\n\nstatic const u32 scpi_scale[] = {\n\t[TEMPERATURE]\t= 1000,\t\t \n\t[VOLTAGE]\t= 1000,\t\t \n\t[CURRENT]\t= 1000,\t\t \n\t[POWER]\t\t= 1000000,\t \n\t[ENERGY]\t= 1000000,\t \n};\n\nstatic void scpi_scale_reading(u64 *value, struct sensor_data *sensor)\n{\n\tif (scpi_scale[sensor->info.class] != sensor->scale) {\n\t\t*value *= scpi_scale[sensor->info.class];\n\t\tdo_div(*value, sensor->scale);\n\t}\n}\n\nstatic int scpi_read_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct scpi_thermal_zone *zone = thermal_zone_device_priv(tz);\n\tstruct scpi_sensors *scpi_sensors = zone->scpi_sensors;\n\tstruct scpi_ops *scpi_ops = scpi_sensors->scpi_ops;\n\tstruct sensor_data *sensor = &scpi_sensors->data[zone->sensor_id];\n\tu64 value;\n\tint ret;\n\n\tret = scpi_ops->sensor_get_value(sensor->info.sensor_id, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tscpi_scale_reading(&value, sensor);\n\n\t*temp = value;\n\treturn 0;\n}\n\n \nstatic ssize_t\nscpi_show_sensor(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scpi_sensors *scpi_sensors = dev_get_drvdata(dev);\n\tstruct scpi_ops *scpi_ops = scpi_sensors->scpi_ops;\n\tstruct sensor_data *sensor;\n\tu64 value;\n\tint ret;\n\n\tsensor = container_of(attr, struct sensor_data, dev_attr_input);\n\n\tret = scpi_ops->sensor_get_value(sensor->info.sensor_id, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tscpi_scale_reading(&value, sensor);\n\n\t \n\tif (sensor->info.class == TEMPERATURE)\n\t\treturn sprintf(buf, \"%lld\\n\", (s64)value);\n\n\treturn sprintf(buf, \"%llu\\n\", value);\n}\n\nstatic ssize_t\nscpi_show_label(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_data *sensor;\n\n\tsensor = container_of(attr, struct sensor_data, dev_attr_label);\n\n\treturn sprintf(buf, \"%s\\n\", sensor->info.name);\n}\n\nstatic const struct thermal_zone_device_ops scpi_sensor_ops = {\n\t.get_temp = scpi_read_temp,\n};\n\nstatic const struct of_device_id scpi_of_match[] = {\n\t{.compatible = \"arm,scpi-sensors\", .data = &scpi_scale},\n\t{.compatible = \"amlogic,meson-gxbb-scpi-sensors\", .data = &gxbb_scpi_scale},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, scpi_of_match);\n\nstatic int scpi_hwmon_probe(struct platform_device *pdev)\n{\n\tu16 nr_sensors, i;\n\tconst u32 *scale;\n\tint num_temp = 0, num_volt = 0, num_current = 0, num_power = 0;\n\tint num_energy = 0;\n\tstruct scpi_ops *scpi_ops;\n\tstruct device *hwdev, *dev = &pdev->dev;\n\tstruct scpi_sensors *scpi_sensors;\n\tint idx, ret;\n\n\tscpi_ops = get_scpi_ops();\n\tif (!scpi_ops)\n\t\treturn -EPROBE_DEFER;\n\n\tret = scpi_ops->sensor_get_capability(&nr_sensors);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!nr_sensors)\n\t\treturn -ENODEV;\n\n\tscpi_sensors = devm_kzalloc(dev, sizeof(*scpi_sensors), GFP_KERNEL);\n\tif (!scpi_sensors)\n\t\treturn -ENOMEM;\n\n\tscpi_sensors->data = devm_kcalloc(dev, nr_sensors,\n\t\t\t\t   sizeof(*scpi_sensors->data), GFP_KERNEL);\n\tif (!scpi_sensors->data)\n\t\treturn -ENOMEM;\n\n\tscpi_sensors->attrs = devm_kcalloc(dev, (nr_sensors * 2) + 1,\n\t\t\t\t   sizeof(*scpi_sensors->attrs), GFP_KERNEL);\n\tif (!scpi_sensors->attrs)\n\t\treturn -ENOMEM;\n\n\tscpi_sensors->scpi_ops = scpi_ops;\n\n\tscale = of_device_get_match_data(&pdev->dev);\n\tif (!scale) {\n\t\tdev_err(&pdev->dev, \"Unable to initialize scpi-hwmon data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0, idx = 0; i < nr_sensors; i++) {\n\t\tstruct sensor_data *sensor = &scpi_sensors->data[idx];\n\n\t\tret = scpi_ops->sensor_get_info(i, &sensor->info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (sensor->info.class) {\n\t\tcase TEMPERATURE:\n\t\t\tsnprintf(sensor->input, sizeof(sensor->input),\n\t\t\t\t \"temp%d_input\", num_temp + 1);\n\t\t\tsnprintf(sensor->label, sizeof(sensor->input),\n\t\t\t\t \"temp%d_label\", num_temp + 1);\n\t\t\tnum_temp++;\n\t\t\tbreak;\n\t\tcase VOLTAGE:\n\t\t\tsnprintf(sensor->input, sizeof(sensor->input),\n\t\t\t\t \"in%d_input\", num_volt);\n\t\t\tsnprintf(sensor->label, sizeof(sensor->input),\n\t\t\t\t \"in%d_label\", num_volt);\n\t\t\tnum_volt++;\n\t\t\tbreak;\n\t\tcase CURRENT:\n\t\t\tsnprintf(sensor->input, sizeof(sensor->input),\n\t\t\t\t \"curr%d_input\", num_current + 1);\n\t\t\tsnprintf(sensor->label, sizeof(sensor->input),\n\t\t\t\t \"curr%d_label\", num_current + 1);\n\t\t\tnum_current++;\n\t\t\tbreak;\n\t\tcase POWER:\n\t\t\tsnprintf(sensor->input, sizeof(sensor->input),\n\t\t\t\t \"power%d_input\", num_power + 1);\n\t\t\tsnprintf(sensor->label, sizeof(sensor->input),\n\t\t\t\t \"power%d_label\", num_power + 1);\n\t\t\tnum_power++;\n\t\t\tbreak;\n\t\tcase ENERGY:\n\t\t\tsnprintf(sensor->input, sizeof(sensor->input),\n\t\t\t\t \"energy%d_input\", num_energy + 1);\n\t\t\tsnprintf(sensor->label, sizeof(sensor->input),\n\t\t\t\t \"energy%d_label\", num_energy + 1);\n\t\t\tnum_energy++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tsensor->scale = scale[sensor->info.class];\n\n\t\tsensor->dev_attr_input.attr.mode = 0444;\n\t\tsensor->dev_attr_input.show = scpi_show_sensor;\n\t\tsensor->dev_attr_input.attr.name = sensor->input;\n\n\t\tsensor->dev_attr_label.attr.mode = 0444;\n\t\tsensor->dev_attr_label.show = scpi_show_label;\n\t\tsensor->dev_attr_label.attr.name = sensor->label;\n\n\t\tscpi_sensors->attrs[idx << 1] = &sensor->dev_attr_input.attr;\n\t\tscpi_sensors->attrs[(idx << 1) + 1] = &sensor->dev_attr_label.attr;\n\n\t\tsysfs_attr_init(scpi_sensors->attrs[idx << 1]);\n\t\tsysfs_attr_init(scpi_sensors->attrs[(idx << 1) + 1]);\n\t\tidx++;\n\t}\n\n\tscpi_sensors->group.attrs = scpi_sensors->attrs;\n\tscpi_sensors->groups[0] = &scpi_sensors->group;\n\n\tplatform_set_drvdata(pdev, scpi_sensors);\n\n\thwdev = devm_hwmon_device_register_with_groups(dev,\n\t\t\t\"scpi_sensors\", scpi_sensors, scpi_sensors->groups);\n\n\tif (IS_ERR(hwdev))\n\t\treturn PTR_ERR(hwdev);\n\n\t \n\tINIT_LIST_HEAD(&scpi_sensors->thermal_zones);\n\tfor (i = 0; i < nr_sensors; i++) {\n\t\tstruct sensor_data *sensor = &scpi_sensors->data[i];\n\t\tstruct thermal_zone_device *z;\n\t\tstruct scpi_thermal_zone *zone;\n\n\t\tif (sensor->info.class != TEMPERATURE)\n\t\t\tcontinue;\n\n\t\tzone = devm_kzalloc(dev, sizeof(*zone), GFP_KERNEL);\n\t\tif (!zone)\n\t\t\treturn -ENOMEM;\n\n\t\tzone->sensor_id = i;\n\t\tzone->scpi_sensors = scpi_sensors;\n\t\tz = devm_thermal_of_zone_register(dev,\n\t\t\t\t\t\t  sensor->info.sensor_id,\n\t\t\t\t\t\t  zone,\n\t\t\t\t\t\t  &scpi_sensor_ops);\n\t\t \n\t\tif (IS_ERR(z))\n\t\t\tdevm_kfree(dev, zone);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver scpi_hwmon_platdrv = {\n\t.driver = {\n\t\t.name\t= \"scpi-hwmon\",\n\t\t.of_match_table = scpi_of_match,\n\t},\n\t.probe\t\t= scpi_hwmon_probe,\n};\nmodule_platform_driver(scpi_hwmon_platdrv);\n\nMODULE_AUTHOR(\"Punit Agrawal <punit.agrawal@arm.com>\");\nMODULE_DESCRIPTION(\"ARM SCPI HWMON interface driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}