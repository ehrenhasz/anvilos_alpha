{
  "module_name": "w83627ehf.c",
  "hash_id": "38492b1914df45dbffc428fa59103cc5d030f61e988f22b0fe5c6aaedf3d9289",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/w83627ehf.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon-vid.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n#include \"lm75.h\"\n\nenum kinds {\n\tw83627ehf, w83627dhg, w83627dhg_p, w83627uhg,\n\tw83667hg, w83667hg_b,\n};\n\n \nstatic const char * const w83627ehf_device_names[] = {\n\t\"w83627ehf\",\n\t\"w83627dhg\",\n\t\"w83627dhg\",\n\t\"w83627uhg\",\n\t\"w83667hg\",\n\t\"w83667hg\",\n};\n\nstatic unsigned short force_id;\nmodule_param(force_id, ushort, 0);\nMODULE_PARM_DESC(force_id, \"Override the detected device ID\");\n\n#define DRVNAME \"w83627ehf\"\n\n \n\n#define W83627EHF_LD_HWM\t0x0b\n#define W83667HG_LD_VID\t\t0x0d\n\n#define SIO_REG_LDSEL\t\t0x07\t \n#define SIO_REG_DEVID\t\t0x20\t \n#define SIO_REG_EN_VRM10\t0x2C\t \n#define SIO_REG_ENABLE\t\t0x30\t \n#define SIO_REG_ADDR\t\t0x60\t \n#define SIO_REG_VID_CTRL\t0xF0\t \n#define SIO_REG_VID_DATA\t0xF1\t \n\n#define SIO_W83627EHF_ID\t0x8850\n#define SIO_W83627EHG_ID\t0x8860\n#define SIO_W83627DHG_ID\t0xa020\n#define SIO_W83627DHG_P_ID\t0xb070\n#define SIO_W83627UHG_ID\t0xa230\n#define SIO_W83667HG_ID\t\t0xa510\n#define SIO_W83667HG_B_ID\t0xb350\n#define SIO_ID_MASK\t\t0xFFF0\n\nstatic inline void\nsuperio_outb(int ioreg, int reg, int val)\n{\n\toutb(reg, ioreg);\n\toutb(val, ioreg + 1);\n}\n\nstatic inline int\nsuperio_inb(int ioreg, int reg)\n{\n\toutb(reg, ioreg);\n\treturn inb(ioreg + 1);\n}\n\nstatic inline void\nsuperio_select(int ioreg, int ld)\n{\n\toutb(SIO_REG_LDSEL, ioreg);\n\toutb(ld, ioreg + 1);\n}\n\nstatic inline int\nsuperio_enter(int ioreg)\n{\n\tif (!request_muxed_region(ioreg, 2, DRVNAME))\n\t\treturn -EBUSY;\n\n\toutb(0x87, ioreg);\n\toutb(0x87, ioreg);\n\n\treturn 0;\n}\n\nstatic inline void\nsuperio_exit(int ioreg)\n{\n\toutb(0xaa, ioreg);\n\toutb(0x02, ioreg);\n\toutb(0x02, ioreg + 1);\n\trelease_region(ioreg, 2);\n}\n\n \n\n#define IOREGION_ALIGNMENT\t(~7)\n#define IOREGION_OFFSET\t\t5\n#define IOREGION_LENGTH\t\t2\n#define ADDR_REG_OFFSET\t\t0\n#define DATA_REG_OFFSET\t\t1\n\n#define W83627EHF_REG_BANK\t\t0x4E\n#define W83627EHF_REG_CONFIG\t\t0x40\n\n \n\nstatic const u16 W83627EHF_REG_FAN[] = { 0x28, 0x29, 0x2a, 0x3f, 0x553 };\nstatic const u16 W83627EHF_REG_FAN_MIN[] = { 0x3b, 0x3c, 0x3d, 0x3e, 0x55c };\n\n \n#define W83627EHF_REG_IN_MAX(nr)\t((nr < 7) ? (0x2b + (nr) * 2) : \\\n\t\t\t\t\t (0x554 + (((nr) - 7) * 2)))\n#define W83627EHF_REG_IN_MIN(nr)\t((nr < 7) ? (0x2c + (nr) * 2) : \\\n\t\t\t\t\t (0x555 + (((nr) - 7) * 2)))\n#define W83627EHF_REG_IN(nr)\t\t((nr < 7) ? (0x20 + (nr)) : \\\n\t\t\t\t\t (0x550 + (nr) - 7))\n\nstatic const u16 W83627EHF_REG_TEMP[] = { 0x27, 0x150, 0x250, 0x7e };\nstatic const u16 W83627EHF_REG_TEMP_HYST[] = { 0x3a, 0x153, 0x253, 0 };\nstatic const u16 W83627EHF_REG_TEMP_OVER[] = { 0x39, 0x155, 0x255, 0 };\nstatic const u16 W83627EHF_REG_TEMP_CONFIG[] = { 0, 0x152, 0x252, 0 };\n\n \n#define W83627EHF_REG_FANDIV1\t\t0x47\n#define W83627EHF_REG_FANDIV2\t\t0x4B\n#define W83627EHF_REG_VBAT\t\t0x5D\n#define W83627EHF_REG_DIODE\t\t0x59\n#define W83627EHF_REG_SMI_OVT\t\t0x4C\n\n#define W83627EHF_REG_ALARM1\t\t0x459\n#define W83627EHF_REG_ALARM2\t\t0x45A\n#define W83627EHF_REG_ALARM3\t\t0x45B\n\n#define W83627EHF_REG_CASEOPEN_DET\t0x42  \n#define W83627EHF_REG_CASEOPEN_CLR\t0x46  \n\n \n#define W83627EHF_REG_FAN_STEPUP_TIME 0x0f\n#define W83627EHF_REG_FAN_STEPDOWN_TIME 0x0e\n\n \nstatic const u8 W83627EHF_REG_PWM_ENABLE[] = {\n\t0x04,\t\t\t \n\t0x04,\t\t\t \n\t0x12,\t\t\t \n\t0x62,\t\t\t \n};\n\nstatic const u8 W83627EHF_PWM_MODE_SHIFT[] = { 0, 1, 0, 6 };\nstatic const u8 W83627EHF_PWM_ENABLE_SHIFT[] = { 2, 4, 1, 4 };\n\n \nstatic const u16 W83627EHF_REG_PWM[] = { 0x01, 0x03, 0x11, 0x61 };\nstatic const u16 W83627EHF_REG_TARGET[] = { 0x05, 0x06, 0x13, 0x63 };\nstatic const u8 W83627EHF_REG_TOLERANCE[] = { 0x07, 0x07, 0x14, 0x62 };\n\n \nstatic const u16 W83627EHF_REG_FAN_START_OUTPUT[] = { 0x0a, 0x0b, 0x16, 0x65 };\nstatic const u16 W83627EHF_REG_FAN_STOP_OUTPUT[] = { 0x08, 0x09, 0x15, 0x64 };\nstatic const u16 W83627EHF_REG_FAN_STOP_TIME[] = { 0x0c, 0x0d, 0x17, 0x66 };\n\nstatic const u16 W83627EHF_REG_FAN_MAX_OUTPUT_COMMON[]\n\t\t\t\t\t\t= { 0xff, 0x67, 0xff, 0x69 };\nstatic const u16 W83627EHF_REG_FAN_STEP_OUTPUT_COMMON[]\n\t\t\t\t\t\t= { 0xff, 0x68, 0xff, 0x6a };\n\nstatic const u16 W83627EHF_REG_FAN_MAX_OUTPUT_W83667_B[] = { 0x67, 0x69, 0x6b };\nstatic const u16 W83627EHF_REG_FAN_STEP_OUTPUT_W83667_B[]\n\t\t\t\t\t\t= { 0x68, 0x6a, 0x6c };\n\nstatic const u16 W83627EHF_REG_TEMP_OFFSET[] = { 0x454, 0x455, 0x456 };\n\nstatic const char *const w83667hg_b_temp_label[] = {\n\t\"SYSTIN\",\n\t\"CPUTIN\",\n\t\"AUXTIN\",\n\t\"AMDTSI\",\n\t\"PECI Agent 1\",\n\t\"PECI Agent 2\",\n\t\"PECI Agent 3\",\n\t\"PECI Agent 4\"\n};\n\n#define NUM_REG_TEMP\tARRAY_SIZE(W83627EHF_REG_TEMP)\n\nstatic int is_word_sized(u16 reg)\n{\n\treturn ((((reg & 0xff00) == 0x100\n\t      || (reg & 0xff00) == 0x200)\n\t     && ((reg & 0x00ff) == 0x50\n\t      || (reg & 0x00ff) == 0x53\n\t      || (reg & 0x00ff) == 0x55))\n\t     || (reg & 0xfff0) == 0x630\n\t     || reg == 0x640 || reg == 0x642\n\t     || ((reg & 0xfff0) == 0x650\n\t\t && (reg & 0x000f) >= 0x06)\n\t     || reg == 0x73 || reg == 0x75 || reg == 0x77\n\t\t);\n}\n\n \n\n \nstatic inline unsigned int step_time_from_reg(u8 reg, u8 mode)\n{\n\treturn mode ? 100 * reg : 400 * reg;\n}\n\nstatic inline u8 step_time_to_reg(unsigned int msec, u8 mode)\n{\n\treturn clamp_val((mode ? (msec + 50) / 100 : (msec + 200) / 400),\n\t\t\t 1, 255);\n}\n\nstatic unsigned int fan_from_reg8(u16 reg, unsigned int divreg)\n{\n\tif (reg == 0 || reg == 255)\n\t\treturn 0;\n\treturn 1350000U / (reg << divreg);\n}\n\nstatic inline unsigned int\ndiv_from_reg(u8 reg)\n{\n\treturn 1 << reg;\n}\n\n \nstatic const u16 scale_in_common[10] = {\n\t800, 800, 1600, 1600, 800, 800, 800, 1600, 1600, 800\n};\nstatic const u16 scale_in_w83627uhg[9] = {\n\t800, 800, 3328, 3424, 800, 800, 0, 3328, 3400\n};\n\nstatic inline long in_from_reg(u8 reg, u8 nr, const u16 *scale_in)\n{\n\treturn DIV_ROUND_CLOSEST(reg * scale_in[nr], 100);\n}\n\nstatic inline u8 in_to_reg(u32 val, u8 nr, const u16 *scale_in)\n{\n\treturn clamp_val(DIV_ROUND_CLOSEST(val * 100, scale_in[nr]), 0, 255);\n}\n\n \n\nstruct w83627ehf_data {\n\tint addr;\t \n\tconst char *name;\n\n\tstruct mutex lock;\n\n\tu16 reg_temp[NUM_REG_TEMP];\n\tu16 reg_temp_over[NUM_REG_TEMP];\n\tu16 reg_temp_hyst[NUM_REG_TEMP];\n\tu16 reg_temp_config[NUM_REG_TEMP];\n\tu8 temp_src[NUM_REG_TEMP];\n\tconst char * const *temp_label;\n\n\tconst u16 *REG_FAN_MAX_OUTPUT;\n\tconst u16 *REG_FAN_STEP_OUTPUT;\n\tconst u16 *scale_in;\n\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\n\t \n\tu8 bank;\t\t \n\tu8 in_num;\t\t \n\tu8 in[10];\t\t \n\tu8 in_max[10];\t\t \n\tu8 in_min[10];\t\t \n\tunsigned int rpm[5];\n\tu16 fan_min[5];\n\tu8 fan_div[5];\n\tu8 has_fan;\t\t \n\tu8 has_fan_min;\t\t \n\tu8 temp_type[3];\n\ts8 temp_offset[3];\n\ts16 temp[9];\n\ts16 temp_max[9];\n\ts16 temp_max_hyst[9];\n\tu32 alarms;\n\tu8 caseopen;\n\n\tu8 pwm_mode[4];  \n\tu8 pwm_enable[4];  \n\tu8 pwm_enable_orig[4];\t \n\tu8 pwm_num;\t\t \n\tu8 pwm[4];\n\tu8 target_temp[4];\n\tu8 tolerance[4];\n\n\tu8 fan_start_output[4];  \n\tu8 fan_stop_output[4];  \n\tu8 fan_stop_time[4];  \n\tu8 fan_max_output[4];  \n\tu8 fan_step_output[4];  \n\n\tu8 vid;\n\tu8 vrm;\n\n\tu16 have_temp;\n\tu16 have_temp_offset;\n\tu8 in6_skip:1;\n\tu8 temp3_val_only:1;\n\tu8 have_vid:1;\n\n\t \n\tu8 vbat;\n\tu8 fandiv1;\n\tu8 fandiv2;\n};\n\nstruct w83627ehf_sio_data {\n\tint sioreg;\n\tenum kinds kind;\n};\n\n \nstatic inline void w83627ehf_set_bank(struct w83627ehf_data *data, u16 reg)\n{\n\tu8 bank = reg >> 8;\n\tif (data->bank != bank) {\n\t\toutb_p(W83627EHF_REG_BANK, data->addr + ADDR_REG_OFFSET);\n\t\toutb_p(bank, data->addr + DATA_REG_OFFSET);\n\t\tdata->bank = bank;\n\t}\n}\n\nstatic u16 w83627ehf_read_value(struct w83627ehf_data *data, u16 reg)\n{\n\tint res, word_sized = is_word_sized(reg);\n\n\tmutex_lock(&data->lock);\n\n\tw83627ehf_set_bank(data, reg);\n\toutb_p(reg & 0xff, data->addr + ADDR_REG_OFFSET);\n\tres = inb_p(data->addr + DATA_REG_OFFSET);\n\tif (word_sized) {\n\t\toutb_p((reg & 0xff) + 1,\n\t\t       data->addr + ADDR_REG_OFFSET);\n\t\tres = (res << 8) + inb_p(data->addr + DATA_REG_OFFSET);\n\t}\n\n\tmutex_unlock(&data->lock);\n\treturn res;\n}\n\nstatic int w83627ehf_write_value(struct w83627ehf_data *data, u16 reg,\n\t\t\t\t u16 value)\n{\n\tint word_sized = is_word_sized(reg);\n\n\tmutex_lock(&data->lock);\n\n\tw83627ehf_set_bank(data, reg);\n\toutb_p(reg & 0xff, data->addr + ADDR_REG_OFFSET);\n\tif (word_sized) {\n\t\toutb_p(value >> 8, data->addr + DATA_REG_OFFSET);\n\t\toutb_p((reg & 0xff) + 1,\n\t\t       data->addr + ADDR_REG_OFFSET);\n\t}\n\toutb_p(value & 0xff, data->addr + DATA_REG_OFFSET);\n\n\tmutex_unlock(&data->lock);\n\treturn 0;\n}\n\n \nstatic u16 w83627ehf_read_temp(struct w83627ehf_data *data, u16 reg)\n{\n\tu16 res;\n\n\tres = w83627ehf_read_value(data, reg);\n\tif (!is_word_sized(reg))\n\t\tres <<= 8;\n\n\treturn res;\n}\n\nstatic int w83627ehf_write_temp(struct w83627ehf_data *data, u16 reg,\n\t\t\t\t       u16 value)\n{\n\tif (!is_word_sized(reg))\n\t\tvalue >>= 8;\n\treturn w83627ehf_write_value(data, reg, value);\n}\n\n \nstatic void w83627ehf_write_fan_div(struct w83627ehf_data *data, int nr)\n{\n\tu8 reg;\n\n\tswitch (nr) {\n\tcase 0:\n\t\treg = (w83627ehf_read_value(data, W83627EHF_REG_FANDIV1) & 0xcf)\n\t\t    | ((data->fan_div[0] & 0x03) << 4);\n\t\t \n\t\treg |= (data->has_fan & (1 << 4)) ? 1 : 0;\n\t\tw83627ehf_write_value(data, W83627EHF_REG_FANDIV1, reg);\n\t\treg = (w83627ehf_read_value(data, W83627EHF_REG_VBAT) & 0xdf)\n\t\t    | ((data->fan_div[0] & 0x04) << 3);\n\t\tw83627ehf_write_value(data, W83627EHF_REG_VBAT, reg);\n\t\tbreak;\n\tcase 1:\n\t\treg = (w83627ehf_read_value(data, W83627EHF_REG_FANDIV1) & 0x3f)\n\t\t    | ((data->fan_div[1] & 0x03) << 6);\n\t\t \n\t\treg |= (data->has_fan & (1 << 4)) ? 1 : 0;\n\t\tw83627ehf_write_value(data, W83627EHF_REG_FANDIV1, reg);\n\t\treg = (w83627ehf_read_value(data, W83627EHF_REG_VBAT) & 0xbf)\n\t\t    | ((data->fan_div[1] & 0x04) << 4);\n\t\tw83627ehf_write_value(data, W83627EHF_REG_VBAT, reg);\n\t\tbreak;\n\tcase 2:\n\t\treg = (w83627ehf_read_value(data, W83627EHF_REG_FANDIV2) & 0x3f)\n\t\t    | ((data->fan_div[2] & 0x03) << 6);\n\t\tw83627ehf_write_value(data, W83627EHF_REG_FANDIV2, reg);\n\t\treg = (w83627ehf_read_value(data, W83627EHF_REG_VBAT) & 0x7f)\n\t\t    | ((data->fan_div[2] & 0x04) << 5);\n\t\tw83627ehf_write_value(data, W83627EHF_REG_VBAT, reg);\n\t\tbreak;\n\tcase 3:\n\t\treg = (w83627ehf_read_value(data, W83627EHF_REG_DIODE) & 0xfc)\n\t\t    | (data->fan_div[3] & 0x03);\n\t\tw83627ehf_write_value(data, W83627EHF_REG_DIODE, reg);\n\t\treg = (w83627ehf_read_value(data, W83627EHF_REG_SMI_OVT) & 0x7f)\n\t\t    | ((data->fan_div[3] & 0x04) << 5);\n\t\tw83627ehf_write_value(data, W83627EHF_REG_SMI_OVT, reg);\n\t\tbreak;\n\tcase 4:\n\t\treg = (w83627ehf_read_value(data, W83627EHF_REG_DIODE) & 0x73)\n\t\t    | ((data->fan_div[4] & 0x03) << 2)\n\t\t    | ((data->fan_div[4] & 0x04) << 5);\n\t\tw83627ehf_write_value(data, W83627EHF_REG_DIODE, reg);\n\t\tbreak;\n\t}\n}\n\nstatic void w83627ehf_update_fan_div(struct w83627ehf_data *data)\n{\n\tint i;\n\n\ti = w83627ehf_read_value(data, W83627EHF_REG_FANDIV1);\n\tdata->fan_div[0] = (i >> 4) & 0x03;\n\tdata->fan_div[1] = (i >> 6) & 0x03;\n\ti = w83627ehf_read_value(data, W83627EHF_REG_FANDIV2);\n\tdata->fan_div[2] = (i >> 6) & 0x03;\n\ti = w83627ehf_read_value(data, W83627EHF_REG_VBAT);\n\tdata->fan_div[0] |= (i >> 3) & 0x04;\n\tdata->fan_div[1] |= (i >> 4) & 0x04;\n\tdata->fan_div[2] |= (i >> 5) & 0x04;\n\tif (data->has_fan & ((1 << 3) | (1 << 4))) {\n\t\ti = w83627ehf_read_value(data, W83627EHF_REG_DIODE);\n\t\tdata->fan_div[3] = i & 0x03;\n\t\tdata->fan_div[4] = ((i >> 2) & 0x03)\n\t\t\t\t | ((i >> 5) & 0x04);\n\t}\n\tif (data->has_fan & (1 << 3)) {\n\t\ti = w83627ehf_read_value(data, W83627EHF_REG_SMI_OVT);\n\t\tdata->fan_div[3] |= (i >> 5) & 0x04;\n\t}\n}\n\nstatic void w83627ehf_update_pwm(struct w83627ehf_data *data)\n{\n\tint i;\n\tint pwmcfg = 0, tolerance = 0;  \n\n\tfor (i = 0; i < data->pwm_num; i++) {\n\t\tif (!(data->has_fan & (1 << i)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (i != 1) {\n\t\t\tpwmcfg = w83627ehf_read_value(data,\n\t\t\t\t\tW83627EHF_REG_PWM_ENABLE[i]);\n\t\t\ttolerance = w83627ehf_read_value(data,\n\t\t\t\t\tW83627EHF_REG_TOLERANCE[i]);\n\t\t}\n\t\tdata->pwm_mode[i] =\n\t\t\t((pwmcfg >> W83627EHF_PWM_MODE_SHIFT[i]) & 1) ? 0 : 1;\n\t\tdata->pwm_enable[i] = ((pwmcfg >> W83627EHF_PWM_ENABLE_SHIFT[i])\n\t\t\t\t       & 3) + 1;\n\t\tdata->pwm[i] = w83627ehf_read_value(data, W83627EHF_REG_PWM[i]);\n\n\t\tdata->tolerance[i] = (tolerance >> (i == 1 ? 4 : 0)) & 0x0f;\n\t}\n}\n\nstatic struct w83627ehf_data *w83627ehf_update_device(struct device *dev)\n{\n\tstruct w83627ehf_data *data = dev_get_drvdata(dev);\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ/2)\n\t || !data->valid) {\n\t\t \n\t\tw83627ehf_update_fan_div(data);\n\n\t\t \n\t\tfor (i = 0; i < data->in_num; i++) {\n\t\t\tif ((i == 6) && data->in6_skip)\n\t\t\t\tcontinue;\n\n\t\t\tdata->in[i] = w83627ehf_read_value(data,\n\t\t\t\t      W83627EHF_REG_IN(i));\n\t\t\tdata->in_min[i] = w83627ehf_read_value(data,\n\t\t\t\t\t  W83627EHF_REG_IN_MIN(i));\n\t\t\tdata->in_max[i] = w83627ehf_read_value(data,\n\t\t\t\t\t  W83627EHF_REG_IN_MAX(i));\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tu16 reg;\n\n\t\t\tif (!(data->has_fan & (1 << i)))\n\t\t\t\tcontinue;\n\n\t\t\treg = w83627ehf_read_value(data, W83627EHF_REG_FAN[i]);\n\t\t\tdata->rpm[i] = fan_from_reg8(reg, data->fan_div[i]);\n\n\t\t\tif (data->has_fan_min & (1 << i))\n\t\t\t\tdata->fan_min[i] = w83627ehf_read_value(data,\n\t\t\t\t\t   W83627EHF_REG_FAN_MIN[i]);\n\n\t\t\t \n\t\t\tif (reg >= 0xff && data->fan_div[i] < 0x07) {\n\t\t\t\tdev_dbg(dev,\n\t\t\t\t\t\"Increasing fan%d clock divider from %u to %u\\n\",\n\t\t\t\t\ti + 1, div_from_reg(data->fan_div[i]),\n\t\t\t\t\tdiv_from_reg(data->fan_div[i] + 1));\n\t\t\t\tdata->fan_div[i]++;\n\t\t\t\tw83627ehf_write_fan_div(data, i);\n\t\t\t\t \n\t\t\t\tif ((data->has_fan_min & (1 << i))\n\t\t\t\t && data->fan_min[i] >= 2\n\t\t\t\t && data->fan_min[i] != 255)\n\t\t\t\t\tw83627ehf_write_value(data,\n\t\t\t\t\t\tW83627EHF_REG_FAN_MIN[i],\n\t\t\t\t\t\t(data->fan_min[i] /= 2));\n\t\t\t}\n\t\t}\n\n\t\tw83627ehf_update_pwm(data);\n\n\t\tfor (i = 0; i < data->pwm_num; i++) {\n\t\t\tif (!(data->has_fan & (1 << i)))\n\t\t\t\tcontinue;\n\n\t\t\tdata->fan_start_output[i] =\n\t\t\t  w83627ehf_read_value(data,\n\t\t\t\t\t     W83627EHF_REG_FAN_START_OUTPUT[i]);\n\t\t\tdata->fan_stop_output[i] =\n\t\t\t  w83627ehf_read_value(data,\n\t\t\t\t\t     W83627EHF_REG_FAN_STOP_OUTPUT[i]);\n\t\t\tdata->fan_stop_time[i] =\n\t\t\t  w83627ehf_read_value(data,\n\t\t\t\t\t       W83627EHF_REG_FAN_STOP_TIME[i]);\n\n\t\t\tif (data->REG_FAN_MAX_OUTPUT &&\n\t\t\t    data->REG_FAN_MAX_OUTPUT[i] != 0xff)\n\t\t\t\tdata->fan_max_output[i] =\n\t\t\t\t  w83627ehf_read_value(data,\n\t\t\t\t\t\tdata->REG_FAN_MAX_OUTPUT[i]);\n\n\t\t\tif (data->REG_FAN_STEP_OUTPUT &&\n\t\t\t    data->REG_FAN_STEP_OUTPUT[i] != 0xff)\n\t\t\t\tdata->fan_step_output[i] =\n\t\t\t\t  w83627ehf_read_value(data,\n\t\t\t\t\t\tdata->REG_FAN_STEP_OUTPUT[i]);\n\n\t\t\tdata->target_temp[i] =\n\t\t\t\tw83627ehf_read_value(data,\n\t\t\t\t\tW83627EHF_REG_TARGET[i]) &\n\t\t\t\t\t(data->pwm_mode[i] == 1 ? 0x7f : 0xff);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < NUM_REG_TEMP; i++) {\n\t\t\tif (!(data->have_temp & (1 << i)))\n\t\t\t\tcontinue;\n\t\t\tdata->temp[i] = w83627ehf_read_temp(data,\n\t\t\t\t\t\tdata->reg_temp[i]);\n\t\t\tif (data->reg_temp_over[i])\n\t\t\t\tdata->temp_max[i]\n\t\t\t\t  = w83627ehf_read_temp(data,\n\t\t\t\t\t\tdata->reg_temp_over[i]);\n\t\t\tif (data->reg_temp_hyst[i])\n\t\t\t\tdata->temp_max_hyst[i]\n\t\t\t\t  = w83627ehf_read_temp(data,\n\t\t\t\t\t\tdata->reg_temp_hyst[i]);\n\t\t\tif (i > 2)\n\t\t\t\tcontinue;\n\t\t\tif (data->have_temp_offset & (1 << i))\n\t\t\t\tdata->temp_offset[i]\n\t\t\t\t  = w83627ehf_read_value(data,\n\t\t\t\t\t\tW83627EHF_REG_TEMP_OFFSET[i]);\n\t\t}\n\n\t\tdata->alarms = w83627ehf_read_value(data,\n\t\t\t\t\tW83627EHF_REG_ALARM1) |\n\t\t\t       (w83627ehf_read_value(data,\n\t\t\t\t\tW83627EHF_REG_ALARM2) << 8) |\n\t\t\t       (w83627ehf_read_value(data,\n\t\t\t\t\tW83627EHF_REG_ALARM3) << 16);\n\n\t\tdata->caseopen = w83627ehf_read_value(data,\n\t\t\t\t\t\tW83627EHF_REG_CASEOPEN_DET);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n}\n\n#define store_in_reg(REG, reg) \\\nstatic int \\\nstore_in_##reg(struct device *dev, struct w83627ehf_data *data, int channel, \\\n\t       long val) \\\n{ \\\n\tif (val < 0) \\\n\t\treturn -EINVAL; \\\n\tmutex_lock(&data->update_lock); \\\n\tdata->in_##reg[channel] = in_to_reg(val, channel, data->scale_in); \\\n\tw83627ehf_write_value(data, W83627EHF_REG_IN_##REG(channel), \\\n\t\t\t      data->in_##reg[channel]); \\\n\tmutex_unlock(&data->update_lock); \\\n\treturn 0; \\\n}\n\nstore_in_reg(MIN, min)\nstore_in_reg(MAX, max)\n\nstatic int\nstore_fan_min(struct device *dev, struct w83627ehf_data *data, int channel,\n\t      long val)\n{\n\tunsigned int reg;\n\tu8 new_div;\n\n\tif (val < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tif (!val) {\n\t\t \n\t\tdata->fan_min[channel] = 255;\n\t\tnew_div = data->fan_div[channel];  \n\t\tdev_info(dev, \"fan%u low limit and alarm disabled\\n\",\n\t\t\t channel + 1);\n\t} else if ((reg = 1350000U / val) >= 128 * 255) {\n\t\t \n\t\tdata->fan_min[channel] = 254;\n\t\tnew_div = 7;  \n\t\tdev_warn(dev,\n\t\t\t \"fan%u low limit %lu below minimum %u, set to minimum\\n\",\n\t\t\t channel + 1, val, fan_from_reg8(254, 7));\n\t} else if (!reg) {\n\t\t \n\t\tdata->fan_min[channel] = 1;\n\t\tnew_div = 0;  \n\t\tdev_warn(dev,\n\t\t\t \"fan%u low limit %lu above maximum %u, set to maximum\\n\",\n\t\t\t channel + 1, val, fan_from_reg8(1, 0));\n\t} else {\n\t\t \n\t\tnew_div = 0;\n\t\twhile (reg > 192 && new_div < 7) {\n\t\t\treg >>= 1;\n\t\t\tnew_div++;\n\t\t}\n\t\tdata->fan_min[channel] = reg;\n\t}\n\n\t \n\tif (new_div != data->fan_div[channel]) {\n\t\tdev_dbg(dev, \"fan%u clock divider changed from %u to %u\\n\",\n\t\t\tchannel + 1, div_from_reg(data->fan_div[channel]),\n\t\t\tdiv_from_reg(new_div));\n\t\tdata->fan_div[channel] = new_div;\n\t\tw83627ehf_write_fan_div(data, channel);\n\t\t \n\t\tdata->last_updated = jiffies;\n\t}\n\n\tw83627ehf_write_value(data, W83627EHF_REG_FAN_MIN[channel],\n\t\t\t      data->fan_min[channel]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn 0;\n}\n\n#define store_temp_reg(addr, reg) \\\nstatic int \\\nstore_##reg(struct device *dev, struct w83627ehf_data *data, int channel, \\\n\t    long val) \\\n{ \\\n\tmutex_lock(&data->update_lock); \\\n\tdata->reg[channel] = LM75_TEMP_TO_REG(val); \\\n\tw83627ehf_write_temp(data, data->addr[channel], data->reg[channel]); \\\n\tmutex_unlock(&data->update_lock); \\\n\treturn 0; \\\n}\nstore_temp_reg(reg_temp_over, temp_max);\nstore_temp_reg(reg_temp_hyst, temp_max_hyst);\n\nstatic int\nstore_temp_offset(struct device *dev, struct w83627ehf_data *data, int channel,\n\t\t  long val)\n{\n\tval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), -128, 127);\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_offset[channel] = val;\n\tw83627ehf_write_value(data, W83627EHF_REG_TEMP_OFFSET[channel], val);\n\tmutex_unlock(&data->update_lock);\n\treturn 0;\n}\n\nstatic int\nstore_pwm_mode(struct device *dev, struct w83627ehf_data *data, int channel,\n\t       long val)\n{\n\tu16 reg;\n\n\tif (val < 0 || val > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\treg = w83627ehf_read_value(data, W83627EHF_REG_PWM_ENABLE[channel]);\n\tdata->pwm_mode[channel] = val;\n\treg &= ~(1 << W83627EHF_PWM_MODE_SHIFT[channel]);\n\tif (!val)\n\t\treg |= 1 << W83627EHF_PWM_MODE_SHIFT[channel];\n\tw83627ehf_write_value(data, W83627EHF_REG_PWM_ENABLE[channel], reg);\n\tmutex_unlock(&data->update_lock);\n\treturn 0;\n}\n\nstatic int\nstore_pwm(struct device *dev, struct w83627ehf_data *data, int channel,\n\t  long val)\n{\n\tval = clamp_val(val, 0, 255);\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm[channel] = val;\n\tw83627ehf_write_value(data, W83627EHF_REG_PWM[channel], val);\n\tmutex_unlock(&data->update_lock);\n\treturn 0;\n}\n\nstatic int\nstore_pwm_enable(struct device *dev, struct w83627ehf_data *data, int channel,\n\t\t long val)\n{\n\tu16 reg;\n\n\tif (!val || val < 0 ||\n\t    (val > 4 && val != data->pwm_enable_orig[channel]))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm_enable[channel] = val;\n\treg = w83627ehf_read_value(data,\n\t\t\t\t   W83627EHF_REG_PWM_ENABLE[channel]);\n\treg &= ~(0x03 << W83627EHF_PWM_ENABLE_SHIFT[channel]);\n\treg |= (val - 1) << W83627EHF_PWM_ENABLE_SHIFT[channel];\n\tw83627ehf_write_value(data, W83627EHF_REG_PWM_ENABLE[channel],\n\t\t\t      reg);\n\tmutex_unlock(&data->update_lock);\n\treturn 0;\n}\n\n#define show_tol_temp(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\t\t\tchar *buf) \\\n{ \\\n\tstruct w83627ehf_data *data = w83627ehf_update_device(dev->parent); \\\n\tstruct sensor_device_attribute *sensor_attr = \\\n\t\tto_sensor_dev_attr(attr); \\\n\tint nr = sensor_attr->index; \\\n\treturn sprintf(buf, \"%d\\n\", data->reg[nr] * 1000); \\\n}\n\nshow_tol_temp(tolerance)\nshow_tol_temp(target_temp)\n\nstatic ssize_t\nstore_target_temp(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct w83627ehf_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), 0, 127);\n\n\tmutex_lock(&data->update_lock);\n\tdata->target_temp[nr] = val;\n\tw83627ehf_write_value(data, W83627EHF_REG_TARGET[nr], val);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\nstore_tolerance(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct w83627ehf_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\n\tint nr = sensor_attr->index;\n\tu16 reg;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), 0, 15);\n\n\tmutex_lock(&data->update_lock);\n\treg = w83627ehf_read_value(data, W83627EHF_REG_TOLERANCE[nr]);\n\tif (nr == 1)\n\t\treg = (reg & 0x0f) | (val << 4);\n\telse\n\t\treg = (reg & 0xf0) | val;\n\tw83627ehf_write_value(data, W83627EHF_REG_TOLERANCE[nr], reg);\n\tdata->tolerance[nr] = val;\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR(pwm1_target, 0644, show_target_temp,\n\t    store_target_temp, 0);\nstatic SENSOR_DEVICE_ATTR(pwm2_target, 0644, show_target_temp,\n\t    store_target_temp, 1);\nstatic SENSOR_DEVICE_ATTR(pwm3_target, 0644, show_target_temp,\n\t    store_target_temp, 2);\nstatic SENSOR_DEVICE_ATTR(pwm4_target, 0644, show_target_temp,\n\t    store_target_temp, 3);\n\nstatic SENSOR_DEVICE_ATTR(pwm1_tolerance, 0644, show_tolerance,\n\t    store_tolerance, 0);\nstatic SENSOR_DEVICE_ATTR(pwm2_tolerance, 0644, show_tolerance,\n\t    store_tolerance, 1);\nstatic SENSOR_DEVICE_ATTR(pwm3_tolerance, 0644, show_tolerance,\n\t    store_tolerance, 2);\nstatic SENSOR_DEVICE_ATTR(pwm4_tolerance, 0644, show_tolerance,\n\t    store_tolerance, 3);\n\n \n\n#define fan_functions(reg, REG) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\t       char *buf) \\\n{ \\\n\tstruct w83627ehf_data *data = w83627ehf_update_device(dev->parent); \\\n\tstruct sensor_device_attribute *sensor_attr = \\\n\t\tto_sensor_dev_attr(attr); \\\n\tint nr = sensor_attr->index; \\\n\treturn sprintf(buf, \"%d\\n\", data->reg[nr]); \\\n} \\\nstatic ssize_t \\\nstore_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\t\t    const char *buf, size_t count) \\\n{ \\\n\tstruct w83627ehf_data *data = dev_get_drvdata(dev); \\\n\tstruct sensor_device_attribute *sensor_attr = \\\n\t\tto_sensor_dev_attr(attr); \\\n\tint nr = sensor_attr->index; \\\n\tunsigned long val; \\\n\tint err; \\\n\terr = kstrtoul(buf, 10, &val); \\\n\tif (err < 0) \\\n\t\treturn err; \\\n\tval = clamp_val(val, 1, 255); \\\n\tmutex_lock(&data->update_lock); \\\n\tdata->reg[nr] = val; \\\n\tw83627ehf_write_value(data, REG[nr], val); \\\n\tmutex_unlock(&data->update_lock); \\\n\treturn count; \\\n}\n\nfan_functions(fan_start_output, W83627EHF_REG_FAN_START_OUTPUT)\nfan_functions(fan_stop_output, W83627EHF_REG_FAN_STOP_OUTPUT)\nfan_functions(fan_max_output, data->REG_FAN_MAX_OUTPUT)\nfan_functions(fan_step_output, data->REG_FAN_STEP_OUTPUT)\n\n#define fan_time_functions(reg, REG) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\t\t\tchar *buf) \\\n{ \\\n\tstruct w83627ehf_data *data = w83627ehf_update_device(dev->parent); \\\n\tstruct sensor_device_attribute *sensor_attr = \\\n\t\tto_sensor_dev_attr(attr); \\\n\tint nr = sensor_attr->index; \\\n\treturn sprintf(buf, \"%d\\n\", \\\n\t\t\tstep_time_from_reg(data->reg[nr], \\\n\t\t\t\t\t   data->pwm_mode[nr])); \\\n} \\\n\\\nstatic ssize_t \\\nstore_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\t\tconst char *buf, size_t count) \\\n{ \\\n\tstruct w83627ehf_data *data = dev_get_drvdata(dev); \\\n\tstruct sensor_device_attribute *sensor_attr = \\\n\t\tto_sensor_dev_attr(attr); \\\n\tint nr = sensor_attr->index; \\\n\tunsigned long val; \\\n\tint err; \\\n\terr = kstrtoul(buf, 10, &val); \\\n\tif (err < 0) \\\n\t\treturn err; \\\n\tval = step_time_to_reg(val, data->pwm_mode[nr]); \\\n\tmutex_lock(&data->update_lock); \\\n\tdata->reg[nr] = val; \\\n\tw83627ehf_write_value(data, REG[nr], val); \\\n\tmutex_unlock(&data->update_lock); \\\n\treturn count; \\\n} \\\n\nfan_time_functions(fan_stop_time, W83627EHF_REG_FAN_STOP_TIME)\n\nstatic SENSOR_DEVICE_ATTR(pwm4_stop_time, 0644, show_fan_stop_time,\n\t    store_fan_stop_time, 3);\nstatic SENSOR_DEVICE_ATTR(pwm4_start_output, 0644, show_fan_start_output,\n\t    store_fan_start_output, 3);\nstatic SENSOR_DEVICE_ATTR(pwm4_stop_output, 0644, show_fan_stop_output,\n\t    store_fan_stop_output, 3);\nstatic SENSOR_DEVICE_ATTR(pwm4_max_output, 0644, show_fan_max_output,\n\t    store_fan_max_output, 3);\nstatic SENSOR_DEVICE_ATTR(pwm4_step_output, 0644, show_fan_step_output,\n\t    store_fan_step_output, 3);\n\nstatic SENSOR_DEVICE_ATTR(pwm3_stop_time, 0644, show_fan_stop_time,\n\t    store_fan_stop_time, 2);\nstatic SENSOR_DEVICE_ATTR(pwm3_start_output, 0644, show_fan_start_output,\n\t    store_fan_start_output, 2);\nstatic SENSOR_DEVICE_ATTR(pwm3_stop_output, 0644, show_fan_stop_output,\n\t\t    store_fan_stop_output, 2);\n\nstatic SENSOR_DEVICE_ATTR(pwm1_stop_time, 0644, show_fan_stop_time,\n\t    store_fan_stop_time, 0);\nstatic SENSOR_DEVICE_ATTR(pwm2_stop_time, 0644, show_fan_stop_time,\n\t    store_fan_stop_time, 1);\nstatic SENSOR_DEVICE_ATTR(pwm1_start_output, 0644, show_fan_start_output,\n\t    store_fan_start_output, 0);\nstatic SENSOR_DEVICE_ATTR(pwm2_start_output, 0644, show_fan_start_output,\n\t    store_fan_start_output, 1);\nstatic SENSOR_DEVICE_ATTR(pwm1_stop_output, 0644, show_fan_stop_output,\n\t    store_fan_stop_output, 0);\nstatic SENSOR_DEVICE_ATTR(pwm2_stop_output, 0644, show_fan_stop_output,\n\t    store_fan_stop_output, 1);\n\n\n \nstatic SENSOR_DEVICE_ATTR(pwm1_max_output, 0644, show_fan_max_output,\n\t    store_fan_max_output, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1_step_output, 0644, show_fan_step_output,\n\t    store_fan_step_output, 0);\nstatic SENSOR_DEVICE_ATTR(pwm2_max_output, 0644, show_fan_max_output,\n\t    store_fan_max_output, 1);\nstatic SENSOR_DEVICE_ATTR(pwm2_step_output, 0644, show_fan_step_output,\n\t    store_fan_step_output, 1);\nstatic SENSOR_DEVICE_ATTR(pwm3_max_output, 0644, show_fan_max_output,\n\t    store_fan_max_output, 2);\nstatic SENSOR_DEVICE_ATTR(pwm3_step_output, 0644, show_fan_step_output,\n\t    store_fan_step_output, 2);\n\nstatic ssize_t\ncpu0_vid_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83627ehf_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", vid_from_reg(data->vid, data->vrm));\n}\nstatic DEVICE_ATTR_RO(cpu0_vid);\n\n\n \nstatic int\nclear_caseopen(struct device *dev, struct w83627ehf_data *data, int channel,\n\t       long val)\n{\n\tconst u16 mask = 0x80;\n\tu16 reg;\n\n\tif (val != 0 || channel != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\treg = w83627ehf_read_value(data, W83627EHF_REG_CASEOPEN_CLR);\n\tw83627ehf_write_value(data, W83627EHF_REG_CASEOPEN_CLR, reg | mask);\n\tw83627ehf_write_value(data, W83627EHF_REG_CASEOPEN_CLR, reg & ~mask);\n\tdata->valid = false;\t \n\tmutex_unlock(&data->update_lock);\n\n\treturn 0;\n}\n\nstatic umode_t w83627ehf_attrs_visible(struct kobject *kobj,\n\t\t\t\t       struct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct w83627ehf_data *data = dev_get_drvdata(dev);\n\tstruct device_attribute *devattr;\n\tstruct sensor_device_attribute *sda;\n\n\tdevattr = container_of(a, struct device_attribute, attr);\n\n\t \n\tif (devattr->show == cpu0_vid_show && data->have_vid)\n\t\treturn a->mode;\n\n\tsda = (struct sensor_device_attribute *)devattr;\n\n\tif (sda->index < 2 &&\n\t\t(devattr->show == show_fan_stop_time ||\n\t\t devattr->show == show_fan_start_output ||\n\t\t devattr->show == show_fan_stop_output))\n\t\treturn a->mode;\n\n\tif (sda->index < 3 &&\n\t\t(devattr->show == show_fan_max_output ||\n\t\t devattr->show == show_fan_step_output) &&\n\t\tdata->REG_FAN_STEP_OUTPUT &&\n\t\tdata->REG_FAN_STEP_OUTPUT[sda->index] != 0xff)\n\t\treturn a->mode;\n\n\t \n\tif (sda->index == 2 &&\n\t\t(data->has_fan & (1 << 2)) && data->pwm_num >= 3 &&\n\t\t(devattr->show == show_fan_stop_time ||\n\t\t devattr->show == show_fan_start_output ||\n\t\t devattr->show == show_fan_stop_output))\n\t\treturn a->mode;\n\n\tif (sda->index == 3 &&\n\t\t(data->has_fan & (1 << 3)) && data->pwm_num >= 4 &&\n\t\t(devattr->show == show_fan_stop_time ||\n\t\t devattr->show == show_fan_start_output ||\n\t\t devattr->show == show_fan_stop_output ||\n\t\t devattr->show == show_fan_max_output ||\n\t\t devattr->show == show_fan_step_output))\n\t\treturn a->mode;\n\n\tif ((devattr->show == show_target_temp ||\n\t    devattr->show == show_tolerance) &&\n\t    (data->has_fan & (1 << sda->index)) &&\n\t    sda->index < data->pwm_num)\n\t\treturn a->mode;\n\n\treturn 0;\n}\n\n \nstatic struct attribute *w83627ehf_attrs[] = {\n\n\t&sensor_dev_attr_pwm1_stop_time.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_start_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_stop_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_max_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_step_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_target.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_tolerance.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm2_stop_time.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_start_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_stop_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_max_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_step_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_target.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_tolerance.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm3_stop_time.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_start_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_stop_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_max_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_step_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_target.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_tolerance.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm4_stop_time.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_start_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_stop_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_max_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_step_output.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_target.dev_attr.attr,\n\t&sensor_dev_attr_pwm4_tolerance.dev_attr.attr,\n\n\t&dev_attr_cpu0_vid.attr,\n\tNULL\n};\n\nstatic const struct attribute_group w83627ehf_group = {\n\t.attrs = w83627ehf_attrs,\n\t.is_visible = w83627ehf_attrs_visible,\n};\n\nstatic const struct attribute_group *w83627ehf_groups[] = {\n\t&w83627ehf_group,\n\tNULL\n};\n\n \n\n \nstatic inline void w83627ehf_init_device(struct w83627ehf_data *data,\n\t\t\t\t\t\t   enum kinds kind)\n{\n\tint i;\n\tu8 tmp, diode;\n\n\t \n\ttmp = w83627ehf_read_value(data, W83627EHF_REG_CONFIG);\n\tif (!(tmp & 0x01))\n\t\tw83627ehf_write_value(data, W83627EHF_REG_CONFIG,\n\t\t\t\t      tmp | 0x01);\n\n\t \n\tfor (i = 0; i < NUM_REG_TEMP; i++) {\n\t\tif (!(data->have_temp & (1 << i)))\n\t\t\tcontinue;\n\t\tif (!data->reg_temp_config[i])\n\t\t\tcontinue;\n\t\ttmp = w83627ehf_read_value(data,\n\t\t\t\t\t   data->reg_temp_config[i]);\n\t\tif (tmp & 0x01)\n\t\t\tw83627ehf_write_value(data,\n\t\t\t\t\t      data->reg_temp_config[i],\n\t\t\t\t\t      tmp & 0xfe);\n\t}\n\n\t \n\ttmp = w83627ehf_read_value(data, W83627EHF_REG_VBAT);\n\tif (!(tmp & 0x01))\n\t\tw83627ehf_write_value(data, W83627EHF_REG_VBAT, tmp | 0x01);\n\n\t \n\tswitch (kind) {\n\tcase w83627ehf:\n\t\tdiode = w83627ehf_read_value(data, W83627EHF_REG_DIODE);\n\t\tbreak;\n\tcase w83627uhg:\n\t\tdiode = 0x00;\n\t\tbreak;\n\tdefault:\n\t\tdiode = 0x70;\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\tconst char *label = NULL;\n\n\t\tif (data->temp_label)\n\t\t\tlabel = data->temp_label[data->temp_src[i]];\n\n\t\t \n\t\tif (label && strncmp(label, \"PECI\", 4) == 0)\n\t\t\tdata->temp_type[i] = 6;\n\t\telse if (label && strncmp(label, \"AMD\", 3) == 0)\n\t\t\tdata->temp_type[i] = 5;\n\t\telse if ((tmp & (0x02 << i)))\n\t\t\tdata->temp_type[i] = (diode & (0x10 << i)) ? 1 : 3;\n\t\telse\n\t\t\tdata->temp_type[i] = 4;  \n\t}\n}\n\nstatic void\nw83627ehf_set_temp_reg_ehf(struct w83627ehf_data *data, int n_temp)\n{\n\tint i;\n\n\tfor (i = 0; i < n_temp; i++) {\n\t\tdata->reg_temp[i] = W83627EHF_REG_TEMP[i];\n\t\tdata->reg_temp_over[i] = W83627EHF_REG_TEMP_OVER[i];\n\t\tdata->reg_temp_hyst[i] = W83627EHF_REG_TEMP_HYST[i];\n\t\tdata->reg_temp_config[i] = W83627EHF_REG_TEMP_CONFIG[i];\n\t}\n}\n\nstatic void\nw83627ehf_check_fan_inputs(const struct w83627ehf_sio_data *sio_data,\n\t\t\t   struct w83627ehf_data *data)\n{\n\tint fan3pin, fan4pin, fan5pin, regval;\n\n\t \n\tif (sio_data->kind == w83627uhg) {\n\t\tdata->has_fan = 0x03;  \n\t\tdata->has_fan_min = 0x03;\n\t\treturn;\n\t}\n\n\t \n\tif (sio_data->kind == w83667hg || sio_data->kind == w83667hg_b) {\n\t\tfan3pin = 1;\n\t\tfan4pin = superio_inb(sio_data->sioreg, 0x27) & 0x40;\n\t\tfan5pin = superio_inb(sio_data->sioreg, 0x27) & 0x20;\n\t} else {\n\t\tfan3pin = 1;\n\t\tfan4pin = !(superio_inb(sio_data->sioreg, 0x29) & 0x06);\n\t\tfan5pin = !(superio_inb(sio_data->sioreg, 0x24) & 0x02);\n\t}\n\n\tdata->has_fan = data->has_fan_min = 0x03;  \n\tdata->has_fan |= (fan3pin << 2);\n\tdata->has_fan_min |= (fan3pin << 2);\n\n\t \n\tregval = w83627ehf_read_value(data, W83627EHF_REG_FANDIV1);\n\tif ((regval & (1 << 2)) && fan4pin) {\n\t\tdata->has_fan |= (1 << 3);\n\t\tdata->has_fan_min |= (1 << 3);\n\t}\n\tif (!(regval & (1 << 1)) && fan5pin) {\n\t\tdata->has_fan |= (1 << 4);\n\t\tdata->has_fan_min |= (1 << 4);\n\t}\n}\n\nstatic umode_t\nw83627ehf_is_visible(const void *drvdata, enum hwmon_sensor_types type,\n\t\t     u32 attr, int channel)\n{\n\tconst struct w83627ehf_data *data = drvdata;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\t \n\t\tif (!(data->have_temp & (1 << channel)))\n\t\t\treturn 0;\n\t\tif (attr == hwmon_temp_input)\n\t\t\treturn 0444;\n\t\tif (attr == hwmon_temp_label) {\n\t\t\tif (data->temp_label)\n\t\t\t\treturn 0444;\n\t\t\treturn 0;\n\t\t}\n\t\tif (channel == 2 && data->temp3_val_only)\n\t\t\treturn 0;\n\t\tif (attr == hwmon_temp_max) {\n\t\t\tif (data->reg_temp_over[channel])\n\t\t\t\treturn 0644;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (attr == hwmon_temp_max_hyst) {\n\t\t\tif (data->reg_temp_hyst[channel])\n\t\t\t\treturn 0644;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (channel > 2)\n\t\t\treturn 0;\n\t\tif (attr == hwmon_temp_alarm || attr == hwmon_temp_type)\n\t\t\treturn 0444;\n\t\tif (attr == hwmon_temp_offset) {\n\t\t\tif (data->have_temp_offset & (1 << channel))\n\t\t\t\treturn 0644;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_fan:\n\t\t \n\t\tif (!(data->has_fan & (1 << channel)))\n\t\t\treturn 0;\n\t\tif (attr == hwmon_fan_input || attr == hwmon_fan_alarm)\n\t\t\treturn 0444;\n\t\tif (attr == hwmon_fan_div) {\n\t\t\treturn 0444;\n\t\t}\n\t\tif (attr == hwmon_fan_min) {\n\t\t\tif (data->has_fan_min & (1 << channel))\n\t\t\t\treturn 0644;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_in:\n\t\t \n\t\tif (channel >= data->in_num)\n\t\t\treturn 0;\n\t\tif (channel == 6 && data->in6_skip)\n\t\t\treturn 0;\n\t\tif (attr == hwmon_in_alarm || attr == hwmon_in_input)\n\t\t\treturn 0444;\n\t\tif (attr == hwmon_in_min || attr == hwmon_in_max)\n\t\t\treturn 0644;\n\t\tbreak;\n\n\tcase hwmon_pwm:\n\t\t \n\t\tif (!(data->has_fan & (1 << channel)) ||\n\t\t    channel >= data->pwm_num)\n\t\t\treturn 0;\n\t\tif (attr == hwmon_pwm_mode || attr == hwmon_pwm_enable ||\n\t\t    attr == hwmon_pwm_input)\n\t\t\treturn 0644;\n\t\tbreak;\n\n\tcase hwmon_intrusion:\n\t\treturn 0644;\n\n\tdefault:  \n\t\treturn 0;\n\t}\n\n\treturn 0;  \n}\n\nstatic int\nw83627ehf_do_read_temp(struct w83627ehf_data *data, u32 attr,\n\t\t       int channel, long *val)\n{\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\t*val = LM75_TEMP_FROM_REG(data->temp[channel]);\n\t\treturn 0;\n\tcase hwmon_temp_max:\n\t\t*val = LM75_TEMP_FROM_REG(data->temp_max[channel]);\n\t\treturn 0;\n\tcase hwmon_temp_max_hyst:\n\t\t*val = LM75_TEMP_FROM_REG(data->temp_max_hyst[channel]);\n\t\treturn 0;\n\tcase hwmon_temp_offset:\n\t\t*val = data->temp_offset[channel] * 1000;\n\t\treturn 0;\n\tcase hwmon_temp_type:\n\t\t*val = (int)data->temp_type[channel];\n\t\treturn 0;\n\tcase hwmon_temp_alarm:\n\t\tif (channel < 3) {\n\t\t\tint bit[] = { 4, 5, 13 };\n\t\t\t*val = (data->alarms >> bit[channel]) & 1;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nw83627ehf_do_read_in(struct w83627ehf_data *data, u32 attr,\n\t\t     int channel, long *val)\n{\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\t*val = in_from_reg(data->in[channel], channel, data->scale_in);\n\t\treturn 0;\n\tcase hwmon_in_min:\n\t\t*val = in_from_reg(data->in_min[channel], channel,\n\t\t\t\t   data->scale_in);\n\t\treturn 0;\n\tcase hwmon_in_max:\n\t\t*val = in_from_reg(data->in_max[channel], channel,\n\t\t\t\t   data->scale_in);\n\t\treturn 0;\n\tcase hwmon_in_alarm:\n\t\tif (channel < 10) {\n\t\t\tint bit[] = { 0, 1, 2, 3, 8, 21, 20, 16, 17, 19 };\n\t\t\t*val = (data->alarms >> bit[channel]) & 1;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nw83627ehf_do_read_fan(struct w83627ehf_data *data, u32 attr,\n\t\t      int channel, long *val)\n{\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\t\t*val = data->rpm[channel];\n\t\treturn 0;\n\tcase hwmon_fan_min:\n\t\t*val = fan_from_reg8(data->fan_min[channel],\n\t\t\t\t     data->fan_div[channel]);\n\t\treturn 0;\n\tcase hwmon_fan_div:\n\t\t*val = div_from_reg(data->fan_div[channel]);\n\t\treturn 0;\n\tcase hwmon_fan_alarm:\n\t\tif (channel < 5) {\n\t\t\tint bit[] = { 6, 7, 11, 10, 23 };\n\t\t\t*val = (data->alarms >> bit[channel]) & 1;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nw83627ehf_do_read_pwm(struct w83627ehf_data *data, u32 attr,\n\t\t      int channel, long *val)\n{\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\t*val = data->pwm[channel];\n\t\treturn 0;\n\tcase hwmon_pwm_enable:\n\t\t*val = data->pwm_enable[channel];\n\t\treturn 0;\n\tcase hwmon_pwm_mode:\n\t\t*val = data->pwm_enable[channel];\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nw83627ehf_do_read_intrusion(struct w83627ehf_data *data, u32 attr,\n\t\t\t    int channel, long *val)\n{\n\tif (attr != hwmon_intrusion_alarm || channel != 0)\n\t\treturn -EOPNOTSUPP;  \n\n\t*val = !!(data->caseopen & 0x10);\n\treturn 0;\n}\n\nstatic int\nw83627ehf_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct w83627ehf_data *data = w83627ehf_update_device(dev->parent);\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\treturn w83627ehf_do_read_fan(data, attr, channel, val);\n\n\tcase hwmon_in:\n\t\treturn w83627ehf_do_read_in(data, attr, channel, val);\n\n\tcase hwmon_pwm:\n\t\treturn w83627ehf_do_read_pwm(data, attr, channel, val);\n\n\tcase hwmon_temp:\n\t\treturn w83627ehf_do_read_temp(data, attr, channel, val);\n\n\tcase hwmon_intrusion:\n\t\treturn w83627ehf_do_read_intrusion(data, attr, channel, val);\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nw83627ehf_read_string(struct device *dev, enum hwmon_sensor_types type,\n\t\t      u32 attr, int channel, const char **str)\n{\n\tstruct w83627ehf_data *data = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tif (attr == hwmon_temp_label) {\n\t\t\t*str = data->temp_label[data->temp_src[channel]];\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nw83627ehf_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long val)\n{\n\tstruct w83627ehf_data *data = dev_get_drvdata(dev);\n\n\tif (type == hwmon_in && attr == hwmon_in_min)\n\t\treturn store_in_min(dev, data, channel, val);\n\tif (type == hwmon_in && attr == hwmon_in_max)\n\t\treturn store_in_max(dev, data, channel, val);\n\n\tif (type == hwmon_fan && attr == hwmon_fan_min)\n\t\treturn store_fan_min(dev, data, channel, val);\n\n\tif (type == hwmon_temp && attr == hwmon_temp_max)\n\t\treturn store_temp_max(dev, data, channel, val);\n\tif (type == hwmon_temp && attr == hwmon_temp_max_hyst)\n\t\treturn store_temp_max_hyst(dev, data, channel, val);\n\tif (type == hwmon_temp && attr == hwmon_temp_offset)\n\t\treturn store_temp_offset(dev, data, channel, val);\n\n\tif (type == hwmon_pwm && attr == hwmon_pwm_mode)\n\t\treturn store_pwm_mode(dev, data, channel, val);\n\tif (type == hwmon_pwm && attr == hwmon_pwm_enable)\n\t\treturn store_pwm_enable(dev, data, channel, val);\n\tif (type == hwmon_pwm && attr == hwmon_pwm_input)\n\t\treturn store_pwm(dev, data, channel, val);\n\n\tif (type == hwmon_intrusion && attr == hwmon_intrusion_alarm)\n\t\treturn clear_caseopen(dev, data, channel, val);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct hwmon_ops w83627ehf_ops = {\n\t.is_visible = w83627ehf_is_visible,\n\t.read = w83627ehf_read,\n\t.read_string = w83627ehf_read_string,\n\t.write = w83627ehf_write,\n};\n\nstatic const struct hwmon_channel_info * const w83627ehf_info[] = {\n\tHWMON_CHANNEL_INFO(fan,\n\t\tHWMON_F_ALARM | HWMON_F_DIV | HWMON_F_INPUT | HWMON_F_MIN,\n\t\tHWMON_F_ALARM | HWMON_F_DIV | HWMON_F_INPUT | HWMON_F_MIN,\n\t\tHWMON_F_ALARM | HWMON_F_DIV | HWMON_F_INPUT | HWMON_F_MIN,\n\t\tHWMON_F_ALARM | HWMON_F_DIV | HWMON_F_INPUT | HWMON_F_MIN,\n\t\tHWMON_F_ALARM | HWMON_F_DIV | HWMON_F_INPUT | HWMON_F_MIN),\n\tHWMON_CHANNEL_INFO(in,\n\t\tHWMON_I_ALARM | HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_MIN,\n\t\tHWMON_I_ALARM | HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_MIN,\n\t\tHWMON_I_ALARM | HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_MIN,\n\t\tHWMON_I_ALARM | HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_MIN,\n\t\tHWMON_I_ALARM | HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_MIN,\n\t\tHWMON_I_ALARM | HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_MIN,\n\t\tHWMON_I_ALARM | HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_MIN,\n\t\tHWMON_I_ALARM | HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_MIN,\n\t\tHWMON_I_ALARM | HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_MIN,\n\t\tHWMON_I_ALARM | HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_MIN),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\tHWMON_PWM_ENABLE | HWMON_PWM_INPUT | HWMON_PWM_MODE,\n\t\tHWMON_PWM_ENABLE | HWMON_PWM_INPUT | HWMON_PWM_MODE,\n\t\tHWMON_PWM_ENABLE | HWMON_PWM_INPUT | HWMON_PWM_MODE,\n\t\tHWMON_PWM_ENABLE | HWMON_PWM_INPUT | HWMON_PWM_MODE),\n\tHWMON_CHANNEL_INFO(temp,\n\t\tHWMON_T_ALARM | HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_MAX |\n\t\t\tHWMON_T_MAX_HYST | HWMON_T_OFFSET | HWMON_T_TYPE,\n\t\tHWMON_T_ALARM | HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_MAX |\n\t\t\tHWMON_T_MAX_HYST | HWMON_T_OFFSET | HWMON_T_TYPE,\n\t\tHWMON_T_ALARM | HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_MAX |\n\t\t\tHWMON_T_MAX_HYST | HWMON_T_OFFSET | HWMON_T_TYPE,\n\t\tHWMON_T_ALARM | HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_MAX |\n\t\t\tHWMON_T_MAX_HYST | HWMON_T_OFFSET | HWMON_T_TYPE,\n\t\tHWMON_T_ALARM | HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_MAX |\n\t\t\tHWMON_T_MAX_HYST | HWMON_T_OFFSET | HWMON_T_TYPE,\n\t\tHWMON_T_ALARM | HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_MAX |\n\t\t\tHWMON_T_MAX_HYST | HWMON_T_OFFSET | HWMON_T_TYPE,\n\t\tHWMON_T_ALARM | HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_MAX |\n\t\t\tHWMON_T_MAX_HYST | HWMON_T_OFFSET | HWMON_T_TYPE,\n\t\tHWMON_T_ALARM | HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_MAX |\n\t\t\tHWMON_T_MAX_HYST | HWMON_T_OFFSET | HWMON_T_TYPE,\n\t\tHWMON_T_ALARM | HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_MAX |\n\t\t\tHWMON_T_MAX_HYST | HWMON_T_OFFSET | HWMON_T_TYPE),\n\tHWMON_CHANNEL_INFO(intrusion,\n\t\tHWMON_INTRUSION_ALARM),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info w83627ehf_chip_info = {\n\t.ops = &w83627ehf_ops,\n\t.info = w83627ehf_info,\n};\n\nstatic int __init w83627ehf_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct w83627ehf_sio_data *sio_data = dev_get_platdata(dev);\n\tstruct w83627ehf_data *data;\n\tstruct resource *res;\n\tu8 en_vrm10;\n\tint i, err = 0;\n\tstruct device *hwmon_dev;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!devm_request_region(dev, res->start, IOREGION_LENGTH, DRVNAME))\n\t\treturn -EBUSY;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->addr = res->start;\n\tmutex_init(&data->lock);\n\tmutex_init(&data->update_lock);\n\tdata->name = w83627ehf_device_names[sio_data->kind];\n\tdata->bank = 0xff;\t\t \n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tdata->in_num = (sio_data->kind == w83627ehf) ? 10 : 9;\n\t \n\tswitch (sio_data->kind) {\n\tdefault:\n\t\tdata->pwm_num = 4;\n\t\tbreak;\n\tcase w83667hg:\n\tcase w83667hg_b:\n\t\tdata->pwm_num = 3;\n\t\tbreak;\n\tcase w83627uhg:\n\t\tdata->pwm_num = 2;\n\t\tbreak;\n\t}\n\n\t \n\tdata->have_temp = 0x07;\n\n\t \n\tif (sio_data->kind == w83667hg_b) {\n\t\tu8 reg;\n\n\t\tw83627ehf_set_temp_reg_ehf(data, 4);\n\n\t\t \n\t\treg = w83627ehf_read_value(data, 0x4a);\n\t\tdata->temp_src[0] = reg >> 5;\n\t\treg = w83627ehf_read_value(data, 0x49);\n\t\tdata->temp_src[1] = reg & 0x07;\n\t\tdata->temp_src[2] = (reg >> 4) & 0x07;\n\n\t\t \n\t\treg = w83627ehf_read_value(data, 0x7d);\n\t\treg &= 0x07;\n\t\tif (reg != data->temp_src[0] && reg != data->temp_src[1]\n\t\t    && reg != data->temp_src[2]) {\n\t\t\tdata->temp_src[3] = reg;\n\t\t\tdata->have_temp |= 1 << 3;\n\t\t}\n\n\t\t \n\t\treg = w83627ehf_read_value(data, W83627EHF_REG_TEMP_CONFIG[2]);\n\t\tif (data->temp_src[2] == 2 && (reg & 0x01))\n\t\t\tdata->have_temp &= ~(1 << 2);\n\n\t\tif ((data->temp_src[2] == 2 && (data->have_temp & (1 << 2)))\n\t\t    || (data->temp_src[3] == 2 && (data->have_temp & (1 << 3))))\n\t\t\tdata->in6_skip = 1;\n\n\t\tdata->temp_label = w83667hg_b_temp_label;\n\t\tdata->have_temp_offset = data->have_temp & 0x07;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (data->temp_src[i] > 2)\n\t\t\t\tdata->have_temp_offset &= ~(1 << i);\n\t\t}\n\t} else if (sio_data->kind == w83627uhg) {\n\t\tu8 reg;\n\n\t\tw83627ehf_set_temp_reg_ehf(data, 3);\n\n\t\t \n\t\tdata->temp_src[0] = 0;\t \n\t\treg = w83627ehf_read_value(data, 0x49) & 0x07;\n\t\t \n\t\tif (reg == 0)\n\t\t\tdata->temp_src[1] = 1;\n\t\telse if (reg >= 2 && reg <= 5)\n\t\t\tdata->temp_src[1] = reg + 2;\n\t\telse\t \n\t\t\tdata->have_temp &= ~(1 << 1);\n\t\treg = w83627ehf_read_value(data, 0x4a);\n\t\tdata->temp_src[2] = reg >> 5;\n\n\t\t \n\t\tif (data->temp_src[2] == 2 || data->temp_src[2] == 3 ||\n\t\t    data->temp_src[2] == data->temp_src[0] ||\n\t\t    ((data->have_temp & (1 << 1)) &&\n\t\t     data->temp_src[2] == data->temp_src[1]))\n\t\t\tdata->have_temp &= ~(1 << 2);\n\t\telse\n\t\t\tdata->temp3_val_only = 1;\t \n\n\t\tdata->in6_skip = 1;\t\t\t \n\n\t\tdata->temp_label = w83667hg_b_temp_label;\n\t\tdata->have_temp_offset = data->have_temp & 0x03;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (data->temp_src[i] > 1)\n\t\t\t\tdata->have_temp_offset &= ~(1 << i);\n\t\t}\n\t} else {\n\t\tw83627ehf_set_temp_reg_ehf(data, 3);\n\n\t\t \n\n\t\tif (sio_data->kind == w83667hg) {\n\t\t\tu8 reg;\n\n\t\t\t \n\t\t\treg = w83627ehf_read_value(data,\n\t\t\t\t\t\tW83627EHF_REG_TEMP_CONFIG[2]);\n\t\t\tif (reg & 0x01)\n\t\t\t\tdata->have_temp &= ~(1 << 2);\n\t\t\telse\n\t\t\t\tdata->in6_skip = 1;\n\t\t}\n\t\tdata->have_temp_offset = data->have_temp & 0x07;\n\t}\n\n\tif (sio_data->kind == w83667hg_b) {\n\t\tdata->REG_FAN_MAX_OUTPUT =\n\t\t  W83627EHF_REG_FAN_MAX_OUTPUT_W83667_B;\n\t\tdata->REG_FAN_STEP_OUTPUT =\n\t\t  W83627EHF_REG_FAN_STEP_OUTPUT_W83667_B;\n\t} else {\n\t\tdata->REG_FAN_MAX_OUTPUT =\n\t\t  W83627EHF_REG_FAN_MAX_OUTPUT_COMMON;\n\t\tdata->REG_FAN_STEP_OUTPUT =\n\t\t  W83627EHF_REG_FAN_STEP_OUTPUT_COMMON;\n\t}\n\n\t \n\tif (sio_data->kind == w83627uhg)\n\t\tdata->scale_in = scale_in_w83627uhg;\n\telse\n\t\tdata->scale_in = scale_in_common;\n\n\t \n\tw83627ehf_init_device(data, sio_data->kind);\n\n\tdata->vrm = vid_which_vrm();\n\n\terr = superio_enter(sio_data->sioreg);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (sio_data->kind == w83667hg || sio_data->kind == w83667hg_b) {\n\t\t \n\t\tsuperio_select(sio_data->sioreg, W83667HG_LD_VID);\n\t\tdata->vid = superio_inb(sio_data->sioreg, 0xe3);\n\t\tdata->have_vid = true;\n\t} else if (sio_data->kind != w83627uhg) {\n\t\tsuperio_select(sio_data->sioreg, W83627EHF_LD_HWM);\n\t\tif (superio_inb(sio_data->sioreg, SIO_REG_VID_CTRL) & 0x80) {\n\t\t\t \n\t\t\tif (sio_data->kind == w83627ehf) {\n\t\t\t\ten_vrm10 = superio_inb(sio_data->sioreg,\n\t\t\t\t\t\t       SIO_REG_EN_VRM10);\n\t\t\t\tif ((en_vrm10 & 0x08) && data->vrm == 90) {\n\t\t\t\t\tdev_warn(dev,\n\t\t\t\t\t\t \"Setting VID input voltage to TTL\\n\");\n\t\t\t\t\tsuperio_outb(sio_data->sioreg,\n\t\t\t\t\t\t     SIO_REG_EN_VRM10,\n\t\t\t\t\t\t     en_vrm10 & ~0x08);\n\t\t\t\t} else if (!(en_vrm10 & 0x08)\n\t\t\t\t\t   && data->vrm == 100) {\n\t\t\t\t\tdev_warn(dev,\n\t\t\t\t\t\t \"Setting VID input voltage to VRM10\\n\");\n\t\t\t\t\tsuperio_outb(sio_data->sioreg,\n\t\t\t\t\t\t     SIO_REG_EN_VRM10,\n\t\t\t\t\t\t     en_vrm10 | 0x08);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdata->vid = superio_inb(sio_data->sioreg,\n\t\t\t\t\t\tSIO_REG_VID_DATA);\n\t\t\tif (sio_data->kind == w83627ehf)  \n\t\t\t\tdata->vid &= 0x3f;\n\t\t\tdata->have_vid = true;\n\t\t} else {\n\t\t\tdev_info(dev,\n\t\t\t\t \"VID pins in output mode, CPU VID not available\\n\");\n\t\t}\n\t}\n\n\tw83627ehf_check_fan_inputs(sio_data, data);\n\n\tsuperio_exit(sio_data->sioreg);\n\n\t \n\tw83627ehf_update_fan_div(data);\n\n\t \n\tw83627ehf_update_pwm(data);\n\tfor (i = 0; i < data->pwm_num; i++)\n\t\tdata->pwm_enable_orig[i] = data->pwm_enable[i];\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&pdev->dev,\n\t\t\t\t\t\t\t data->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &w83627ehf_chip_info,\n\t\t\t\t\t\t\t w83627ehf_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic int w83627ehf_suspend(struct device *dev)\n{\n\tstruct w83627ehf_data *data = w83627ehf_update_device(dev);\n\n\tmutex_lock(&data->update_lock);\n\tdata->vbat = w83627ehf_read_value(data, W83627EHF_REG_VBAT);\n\tmutex_unlock(&data->update_lock);\n\n\treturn 0;\n}\n\nstatic int w83627ehf_resume(struct device *dev)\n{\n\tstruct w83627ehf_data *data = dev_get_drvdata(dev);\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\tdata->bank = 0xff;\t\t \n\n\t \n\tfor (i = 0; i < data->in_num; i++) {\n\t\tif ((i == 6) && data->in6_skip)\n\t\t\tcontinue;\n\n\t\tw83627ehf_write_value(data, W83627EHF_REG_IN_MIN(i),\n\t\t\t\t      data->in_min[i]);\n\t\tw83627ehf_write_value(data, W83627EHF_REG_IN_MAX(i),\n\t\t\t\t      data->in_max[i]);\n\t}\n\n\tfor (i = 0; i < 5; i++) {\n\t\tif (!(data->has_fan_min & (1 << i)))\n\t\t\tcontinue;\n\n\t\tw83627ehf_write_value(data, W83627EHF_REG_FAN_MIN[i],\n\t\t\t\t      data->fan_min[i]);\n\t}\n\n\tfor (i = 0; i < NUM_REG_TEMP; i++) {\n\t\tif (!(data->have_temp & (1 << i)))\n\t\t\tcontinue;\n\n\t\tif (data->reg_temp_over[i])\n\t\t\tw83627ehf_write_temp(data, data->reg_temp_over[i],\n\t\t\t\t\t     data->temp_max[i]);\n\t\tif (data->reg_temp_hyst[i])\n\t\t\tw83627ehf_write_temp(data, data->reg_temp_hyst[i],\n\t\t\t\t\t     data->temp_max_hyst[i]);\n\t\tif (i > 2)\n\t\t\tcontinue;\n\t\tif (data->have_temp_offset & (1 << i))\n\t\t\tw83627ehf_write_value(data,\n\t\t\t\t\t      W83627EHF_REG_TEMP_OFFSET[i],\n\t\t\t\t\t      data->temp_offset[i]);\n\t}\n\n\t \n\tw83627ehf_write_value(data, W83627EHF_REG_VBAT, data->vbat);\n\n\t \n\tdata->valid = false;\n\tmutex_unlock(&data->update_lock);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(w83627ehf_dev_pm_ops, w83627ehf_suspend, w83627ehf_resume);\n\nstatic struct platform_driver w83627ehf_driver = {\n\t.driver = {\n\t\t.name\t= DRVNAME,\n\t\t.pm\t= pm_sleep_ptr(&w83627ehf_dev_pm_ops),\n\t},\n};\n\n \nstatic int __init w83627ehf_find(int sioaddr, unsigned short *addr,\n\t\t\t\t struct w83627ehf_sio_data *sio_data)\n{\n\tstatic const char sio_name_W83627EHF[] __initconst = \"W83627EHF\";\n\tstatic const char sio_name_W83627EHG[] __initconst = \"W83627EHG\";\n\tstatic const char sio_name_W83627DHG[] __initconst = \"W83627DHG\";\n\tstatic const char sio_name_W83627DHG_P[] __initconst = \"W83627DHG-P\";\n\tstatic const char sio_name_W83627UHG[] __initconst = \"W83627UHG\";\n\tstatic const char sio_name_W83667HG[] __initconst = \"W83667HG\";\n\tstatic const char sio_name_W83667HG_B[] __initconst = \"W83667HG-B\";\n\n\tu16 val;\n\tconst char *sio_name;\n\tint err;\n\n\terr = superio_enter(sioaddr);\n\tif (err)\n\t\treturn err;\n\n\tif (force_id)\n\t\tval = force_id;\n\telse\n\t\tval = (superio_inb(sioaddr, SIO_REG_DEVID) << 8)\n\t\t    | superio_inb(sioaddr, SIO_REG_DEVID + 1);\n\tswitch (val & SIO_ID_MASK) {\n\tcase SIO_W83627EHF_ID:\n\t\tsio_data->kind = w83627ehf;\n\t\tsio_name = sio_name_W83627EHF;\n\t\tbreak;\n\tcase SIO_W83627EHG_ID:\n\t\tsio_data->kind = w83627ehf;\n\t\tsio_name = sio_name_W83627EHG;\n\t\tbreak;\n\tcase SIO_W83627DHG_ID:\n\t\tsio_data->kind = w83627dhg;\n\t\tsio_name = sio_name_W83627DHG;\n\t\tbreak;\n\tcase SIO_W83627DHG_P_ID:\n\t\tsio_data->kind = w83627dhg_p;\n\t\tsio_name = sio_name_W83627DHG_P;\n\t\tbreak;\n\tcase SIO_W83627UHG_ID:\n\t\tsio_data->kind = w83627uhg;\n\t\tsio_name = sio_name_W83627UHG;\n\t\tbreak;\n\tcase SIO_W83667HG_ID:\n\t\tsio_data->kind = w83667hg;\n\t\tsio_name = sio_name_W83667HG;\n\t\tbreak;\n\tcase SIO_W83667HG_B_ID:\n\t\tsio_data->kind = w83667hg_b;\n\t\tsio_name = sio_name_W83667HG_B;\n\t\tbreak;\n\tdefault:\n\t\tif (val != 0xffff)\n\t\t\tpr_debug(\"unsupported chip ID: 0x%04x\\n\", val);\n\t\tsuperio_exit(sioaddr);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsuperio_select(sioaddr, W83627EHF_LD_HWM);\n\tval = (superio_inb(sioaddr, SIO_REG_ADDR) << 8)\n\t    | superio_inb(sioaddr, SIO_REG_ADDR + 1);\n\t*addr = val & IOREGION_ALIGNMENT;\n\tif (*addr == 0) {\n\t\tpr_err(\"Refusing to enable a Super-I/O device with a base I/O port 0\\n\");\n\t\tsuperio_exit(sioaddr);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tval = superio_inb(sioaddr, SIO_REG_ENABLE);\n\tif (!(val & 0x01)) {\n\t\tpr_warn(\"Forcibly enabling Super-I/O. Sensor is probably unusable.\\n\");\n\t\tsuperio_outb(sioaddr, SIO_REG_ENABLE, val | 0x01);\n\t}\n\n\tsuperio_exit(sioaddr);\n\tpr_info(\"Found %s chip at %#x\\n\", sio_name, *addr);\n\tsio_data->sioreg = sioaddr;\n\n\treturn 0;\n}\n\n \nstatic struct platform_device *pdev;\n\nstatic int __init sensors_w83627ehf_init(void)\n{\n\tint err;\n\tunsigned short address;\n\tstruct resource res = {\n\t\t.name\t= DRVNAME,\n\t\t.flags\t= IORESOURCE_IO,\n\t};\n\tstruct w83627ehf_sio_data sio_data;\n\n\t \n\tif (w83627ehf_find(0x2e, &address, &sio_data) &&\n\t    w83627ehf_find(0x4e, &address, &sio_data))\n\t\treturn -ENODEV;\n\n\tres.start = address + IOREGION_OFFSET;\n\tres.end = address + IOREGION_OFFSET + IOREGION_LENGTH - 1;\n\n\terr = acpi_check_resource_conflict(&res);\n\tif (err)\n\t\treturn err;\n\n\tpdev = platform_create_bundle(&w83627ehf_driver, w83627ehf_probe, &res, 1, &sio_data,\n\t\t\t\t      sizeof(struct w83627ehf_sio_data));\n\n\treturn PTR_ERR_OR_ZERO(pdev);\n}\n\nstatic void __exit sensors_w83627ehf_exit(void)\n{\n\tplatform_device_unregister(pdev);\n\tplatform_driver_unregister(&w83627ehf_driver);\n}\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"W83627EHF driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(sensors_w83627ehf_init);\nmodule_exit(sensors_w83627ehf_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}