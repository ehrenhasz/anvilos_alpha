{
  "module_name": "sfctemp.c",
  "hash_id": "508e521e410b10219a1944a02b0bb55ee65605111d042248164ba10a3abf22fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/sfctemp.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/hwmon.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n \n#define SFCTEMP_RSTN\tBIT(0)\n\n \n#define SFCTEMP_PD\tBIT(1)\n\n \n#define SFCTEMP_RUN\tBIT(2)\n\n \n#define SFCTEMP_DOUT_POS\t16\n#define SFCTEMP_DOUT_MSK\tGENMASK(27, 16)\n\n \n#define SFCTEMP_Y1000\t237500L\n#define SFCTEMP_Z\t4094L\n#define SFCTEMP_K1000\t81100L\n\nstruct sfctemp {\n\t \n\tstruct mutex lock;\n\tvoid __iomem *regs;\n\tstruct clk *clk_sense;\n\tstruct clk *clk_bus;\n\tstruct reset_control *rst_sense;\n\tstruct reset_control *rst_bus;\n\tbool enabled;\n};\n\nstatic void sfctemp_power_up(struct sfctemp *sfctemp)\n{\n\t \n\twritel(SFCTEMP_PD, sfctemp->regs);\n\tudelay(1);\n\n\twritel(0, sfctemp->regs);\n\t \n\tusleep_range(60, 200);\n\n\t \n\twritel(SFCTEMP_RSTN, sfctemp->regs);\n\tudelay(1);  \n}\n\nstatic void sfctemp_power_down(struct sfctemp *sfctemp)\n{\n\twritel(SFCTEMP_PD, sfctemp->regs);\n}\n\nstatic void sfctemp_run(struct sfctemp *sfctemp)\n{\n\twritel(SFCTEMP_RSTN | SFCTEMP_RUN, sfctemp->regs);\n\tudelay(1);\n}\n\nstatic void sfctemp_stop(struct sfctemp *sfctemp)\n{\n\twritel(SFCTEMP_RSTN, sfctemp->regs);\n}\n\nstatic int sfctemp_enable(struct sfctemp *sfctemp)\n{\n\tint ret = 0;\n\n\tmutex_lock(&sfctemp->lock);\n\tif (sfctemp->enabled)\n\t\tgoto done;\n\n\tret = clk_prepare_enable(sfctemp->clk_bus);\n\tif (ret)\n\t\tgoto err;\n\tret = reset_control_deassert(sfctemp->rst_bus);\n\tif (ret)\n\t\tgoto err_disable_bus;\n\n\tret = clk_prepare_enable(sfctemp->clk_sense);\n\tif (ret)\n\t\tgoto err_assert_bus;\n\tret = reset_control_deassert(sfctemp->rst_sense);\n\tif (ret)\n\t\tgoto err_disable_sense;\n\n\tsfctemp_power_up(sfctemp);\n\tsfctemp_run(sfctemp);\n\tsfctemp->enabled = true;\ndone:\n\tmutex_unlock(&sfctemp->lock);\n\treturn ret;\n\nerr_disable_sense:\n\tclk_disable_unprepare(sfctemp->clk_sense);\nerr_assert_bus:\n\treset_control_assert(sfctemp->rst_bus);\nerr_disable_bus:\n\tclk_disable_unprepare(sfctemp->clk_bus);\nerr:\n\tmutex_unlock(&sfctemp->lock);\n\treturn ret;\n}\n\nstatic int sfctemp_disable(struct sfctemp *sfctemp)\n{\n\tmutex_lock(&sfctemp->lock);\n\tif (!sfctemp->enabled)\n\t\tgoto done;\n\n\tsfctemp_stop(sfctemp);\n\tsfctemp_power_down(sfctemp);\n\treset_control_assert(sfctemp->rst_sense);\n\tclk_disable_unprepare(sfctemp->clk_sense);\n\treset_control_assert(sfctemp->rst_bus);\n\tclk_disable_unprepare(sfctemp->clk_bus);\n\tsfctemp->enabled = false;\ndone:\n\tmutex_unlock(&sfctemp->lock);\n\treturn 0;\n}\n\nstatic void sfctemp_disable_action(void *data)\n{\n\tsfctemp_disable(data);\n}\n\nstatic int sfctemp_convert(struct sfctemp *sfctemp, long *val)\n{\n\tint ret;\n\n\tmutex_lock(&sfctemp->lock);\n\tif (!sfctemp->enabled) {\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t}\n\n\t \n\t*val = (long)((readl(sfctemp->regs) & SFCTEMP_DOUT_MSK) >> SFCTEMP_DOUT_POS)\n\t\t* SFCTEMP_Y1000 / SFCTEMP_Z - SFCTEMP_K1000;\n\n\tret = 0;\nout:\n\tmutex_unlock(&sfctemp->lock);\n\treturn ret;\n}\n\nstatic umode_t sfctemp_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_enable:\n\t\t\treturn 0644;\n\t\tcase hwmon_temp_input:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int sfctemp_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct sfctemp *sfctemp = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_enable:\n\t\t\t*val = sfctemp->enabled;\n\t\t\treturn 0;\n\t\tcase hwmon_temp_input:\n\t\t\treturn sfctemp_convert(sfctemp, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sfctemp_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long val)\n{\n\tstruct sfctemp *sfctemp = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_enable:\n\t\t\tif (val == 0)\n\t\t\t\treturn sfctemp_disable(sfctemp);\n\t\t\tif (val == 1)\n\t\t\t\treturn sfctemp_enable(sfctemp);\n\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct hwmon_channel_info *sfctemp_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_ENABLE | HWMON_T_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops sfctemp_hwmon_ops = {\n\t.is_visible = sfctemp_is_visible,\n\t.read = sfctemp_read,\n\t.write = sfctemp_write,\n};\n\nstatic const struct hwmon_chip_info sfctemp_chip_info = {\n\t.ops = &sfctemp_hwmon_ops,\n\t.info = sfctemp_info,\n};\n\nstatic int sfctemp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *hwmon_dev;\n\tstruct sfctemp *sfctemp;\n\tint ret;\n\n\tsfctemp = devm_kzalloc(dev, sizeof(*sfctemp), GFP_KERNEL);\n\tif (!sfctemp)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, sfctemp);\n\tmutex_init(&sfctemp->lock);\n\n\tsfctemp->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sfctemp->regs))\n\t\treturn PTR_ERR(sfctemp->regs);\n\n\tsfctemp->clk_sense = devm_clk_get(dev, \"sense\");\n\tif (IS_ERR(sfctemp->clk_sense))\n\t\treturn dev_err_probe(dev, PTR_ERR(sfctemp->clk_sense),\n\t\t\t\t     \"error getting sense clock\\n\");\n\n\tsfctemp->clk_bus = devm_clk_get(dev, \"bus\");\n\tif (IS_ERR(sfctemp->clk_bus))\n\t\treturn dev_err_probe(dev, PTR_ERR(sfctemp->clk_bus),\n\t\t\t\t     \"error getting bus clock\\n\");\n\n\tsfctemp->rst_sense = devm_reset_control_get_exclusive(dev, \"sense\");\n\tif (IS_ERR(sfctemp->rst_sense))\n\t\treturn dev_err_probe(dev, PTR_ERR(sfctemp->rst_sense),\n\t\t\t\t     \"error getting sense reset\\n\");\n\n\tsfctemp->rst_bus = devm_reset_control_get_exclusive(dev, \"bus\");\n\tif (IS_ERR(sfctemp->rst_bus))\n\t\treturn dev_err_probe(dev, PTR_ERR(sfctemp->rst_bus),\n\t\t\t\t     \"error getting busreset\\n\");\n\n\tret = reset_control_assert(sfctemp->rst_sense);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"error asserting sense reset\\n\");\n\n\tret = reset_control_assert(sfctemp->rst_bus);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"error asserting bus reset\\n\");\n\n\tret = devm_add_action(dev, sfctemp_disable_action, sfctemp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sfctemp_enable(sfctemp);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"error enabling temperature sensor\\n\");\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, \"sfctemp\", sfctemp,\n\t\t\t\t\t\t\t &sfctemp_chip_info, NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct of_device_id sfctemp_of_match[] = {\n\t{ .compatible = \"starfive,jh7100-temp\" },\n\t{ .compatible = \"starfive,jh7110-temp\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sfctemp_of_match);\n\nstatic struct platform_driver sfctemp_driver = {\n\t.probe  = sfctemp_probe,\n\t.driver = {\n\t\t.name = \"sfctemp\",\n\t\t.of_match_table = sfctemp_of_match,\n\t},\n};\nmodule_platform_driver(sfctemp_driver);\n\nMODULE_AUTHOR(\"Emil Renner Berthing\");\nMODULE_DESCRIPTION(\"StarFive JH71x0 temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}