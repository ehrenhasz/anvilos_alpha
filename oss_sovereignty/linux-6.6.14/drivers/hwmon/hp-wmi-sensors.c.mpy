{
  "module_name": "hp-wmi-sensors.c",
  "hash_id": "6f1820282ec3ce4e02a9e312bbc456b9c4b4421e2492edfbdbef01328384f3e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/hp-wmi-sensors.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/debugfs.h>\n#include <linux/hwmon.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/units.h>\n#include <linux/wmi.h>\n\n#define HP_WMI_EVENT_NAMESPACE\t\t\"root\\\\WMI\"\n#define HP_WMI_EVENT_CLASS\t\t\"HPBIOS_BIOSEvent\"\n#define HP_WMI_EVENT_GUID\t\t\"95F24279-4D7B-4334-9387-ACCDC67EF61C\"\n#define HP_WMI_NUMERIC_SENSOR_GUID\t\"8F1F6435-9F42-42C8-BADC-0E9424F20C9A\"\n#define HP_WMI_PLATFORM_EVENTS_GUID\t\"41227C2D-80E1-423F-8B8E-87E32755A0EB\"\n\n \n\n#define HP_WMI_PATTERN_SYS_TEMP\t\t\"Chassis Thermal Index\"\n#define HP_WMI_PATTERN_SYS_TEMP2\t\"System Ambient Temperature\"\n#define HP_WMI_PATTERN_CPU_TEMP\t\t\"CPU Thermal Index\"\n#define HP_WMI_PATTERN_CPU_TEMP2\t\"CPU Temperature\"\n#define HP_WMI_PATTERN_TEMP_SENSOR\t\"Thermal Index\"\n#define HP_WMI_PATTERN_TEMP_ALARM\t\"Thermal Critical\"\n#define HP_WMI_PATTERN_INTRUSION_ALARM\t\"Hood Intrusion\"\n#define HP_WMI_PATTERN_FAN_ALARM\t\"Stall\"\n#define HP_WMI_PATTERN_TEMP\t\t\"Temperature\"\n#define HP_WMI_PATTERN_CPU\t\t\"CPU\"\n\n \n\n#define HP_WMI_MAX_STR_SIZE\t\t128U\n#define HP_WMI_MAX_PROPERTIES\t\t32U\n#define HP_WMI_MAX_INSTANCES\t\t32U\n\nenum hp_wmi_type {\n\tHP_WMI_TYPE_OTHER\t\t\t= 1,\n\tHP_WMI_TYPE_TEMPERATURE\t\t\t= 2,\n\tHP_WMI_TYPE_VOLTAGE\t\t\t= 3,\n\tHP_WMI_TYPE_CURRENT\t\t\t= 4,\n\tHP_WMI_TYPE_AIR_FLOW\t\t\t= 12,\n\tHP_WMI_TYPE_INTRUSION\t\t\t= 0xabadb01,  \n};\n\nenum hp_wmi_category {\n\tHP_WMI_CATEGORY_SENSOR\t\t\t= 3,\n};\n\nenum hp_wmi_severity {\n\tHP_WMI_SEVERITY_UNKNOWN\t\t\t= 0,\n\tHP_WMI_SEVERITY_OK\t\t\t= 5,\n\tHP_WMI_SEVERITY_DEGRADED_WARNING\t= 10,\n\tHP_WMI_SEVERITY_MINOR_FAILURE\t\t= 15,\n\tHP_WMI_SEVERITY_MAJOR_FAILURE\t\t= 20,\n\tHP_WMI_SEVERITY_CRITICAL_FAILURE\t= 25,\n\tHP_WMI_SEVERITY_NON_RECOVERABLE_ERROR\t= 30,\n};\n\nenum hp_wmi_status {\n\tHP_WMI_STATUS_OK\t\t\t= 2,\n\tHP_WMI_STATUS_DEGRADED\t\t\t= 3,\n\tHP_WMI_STATUS_STRESSED\t\t\t= 4,\n\tHP_WMI_STATUS_PREDICTIVE_FAILURE\t= 5,\n\tHP_WMI_STATUS_ERROR\t\t\t= 6,\n\tHP_WMI_STATUS_NON_RECOVERABLE_ERROR\t= 7,\n\tHP_WMI_STATUS_NO_CONTACT\t\t= 12,\n\tHP_WMI_STATUS_LOST_COMMUNICATION\t= 13,\n\tHP_WMI_STATUS_ABORTED\t\t\t= 14,\n\tHP_WMI_STATUS_SUPPORTING_ENTITY_IN_ERROR = 16,\n\n\t \n\tHP_WMI_STATUS_COMPLETED\t\t\t= 17,\n};\n\nenum hp_wmi_units {\n\tHP_WMI_UNITS_OTHER\t\t\t= 1,\n\tHP_WMI_UNITS_DEGREES_C\t\t\t= 2,\n\tHP_WMI_UNITS_DEGREES_F\t\t\t= 3,\n\tHP_WMI_UNITS_DEGREES_K\t\t\t= 4,\n\tHP_WMI_UNITS_VOLTS\t\t\t= 5,\n\tHP_WMI_UNITS_AMPS\t\t\t= 6,\n\tHP_WMI_UNITS_RPM\t\t\t= 19,\n};\n\nenum hp_wmi_property {\n\tHP_WMI_PROPERTY_NAME\t\t\t= 0,\n\tHP_WMI_PROPERTY_DESCRIPTION\t\t= 1,\n\tHP_WMI_PROPERTY_SENSOR_TYPE\t\t= 2,\n\tHP_WMI_PROPERTY_OTHER_SENSOR_TYPE\t= 3,\n\tHP_WMI_PROPERTY_OPERATIONAL_STATUS\t= 4,\n\tHP_WMI_PROPERTY_SIZE\t\t\t= 5,\n\tHP_WMI_PROPERTY_POSSIBLE_STATES\t\t= 6,\n\tHP_WMI_PROPERTY_CURRENT_STATE\t\t= 7,\n\tHP_WMI_PROPERTY_BASE_UNITS\t\t= 8,\n\tHP_WMI_PROPERTY_UNIT_MODIFIER\t\t= 9,\n\tHP_WMI_PROPERTY_CURRENT_READING\t\t= 10,\n\tHP_WMI_PROPERTY_RATE_UNITS\t\t= 11,\n};\n\nstatic const acpi_object_type hp_wmi_property_map[] = {\n\t[HP_WMI_PROPERTY_NAME]\t\t\t= ACPI_TYPE_STRING,\n\t[HP_WMI_PROPERTY_DESCRIPTION]\t\t= ACPI_TYPE_STRING,\n\t[HP_WMI_PROPERTY_SENSOR_TYPE]\t\t= ACPI_TYPE_INTEGER,\n\t[HP_WMI_PROPERTY_OTHER_SENSOR_TYPE]\t= ACPI_TYPE_STRING,\n\t[HP_WMI_PROPERTY_OPERATIONAL_STATUS]\t= ACPI_TYPE_INTEGER,\n\t[HP_WMI_PROPERTY_SIZE]\t\t\t= ACPI_TYPE_INTEGER,\n\t[HP_WMI_PROPERTY_POSSIBLE_STATES]\t= ACPI_TYPE_STRING,\n\t[HP_WMI_PROPERTY_CURRENT_STATE]\t\t= ACPI_TYPE_STRING,\n\t[HP_WMI_PROPERTY_BASE_UNITS]\t\t= ACPI_TYPE_INTEGER,\n\t[HP_WMI_PROPERTY_UNIT_MODIFIER]\t\t= ACPI_TYPE_INTEGER,\n\t[HP_WMI_PROPERTY_CURRENT_READING]\t= ACPI_TYPE_INTEGER,\n\t[HP_WMI_PROPERTY_RATE_UNITS]\t\t= ACPI_TYPE_INTEGER,\n};\n\nenum hp_wmi_platform_events_property {\n\tHP_WMI_PLATFORM_EVENTS_PROPERTY_NAME\t\t    = 0,\n\tHP_WMI_PLATFORM_EVENTS_PROPERTY_DESCRIPTION\t    = 1,\n\tHP_WMI_PLATFORM_EVENTS_PROPERTY_SOURCE_NAMESPACE    = 2,\n\tHP_WMI_PLATFORM_EVENTS_PROPERTY_SOURCE_CLASS\t    = 3,\n\tHP_WMI_PLATFORM_EVENTS_PROPERTY_CATEGORY\t    = 4,\n\tHP_WMI_PLATFORM_EVENTS_PROPERTY_POSSIBLE_SEVERITY   = 5,\n\tHP_WMI_PLATFORM_EVENTS_PROPERTY_POSSIBLE_STATUS\t    = 6,\n};\n\nstatic const acpi_object_type hp_wmi_platform_events_property_map[] = {\n\t[HP_WMI_PLATFORM_EVENTS_PROPERTY_NAME]\t\t    = ACPI_TYPE_STRING,\n\t[HP_WMI_PLATFORM_EVENTS_PROPERTY_DESCRIPTION]\t    = ACPI_TYPE_STRING,\n\t[HP_WMI_PLATFORM_EVENTS_PROPERTY_SOURCE_NAMESPACE]  = ACPI_TYPE_STRING,\n\t[HP_WMI_PLATFORM_EVENTS_PROPERTY_SOURCE_CLASS]\t    = ACPI_TYPE_STRING,\n\t[HP_WMI_PLATFORM_EVENTS_PROPERTY_CATEGORY]\t    = ACPI_TYPE_INTEGER,\n\t[HP_WMI_PLATFORM_EVENTS_PROPERTY_POSSIBLE_SEVERITY] = ACPI_TYPE_INTEGER,\n\t[HP_WMI_PLATFORM_EVENTS_PROPERTY_POSSIBLE_STATUS]   = ACPI_TYPE_INTEGER,\n};\n\nenum hp_wmi_event_property {\n\tHP_WMI_EVENT_PROPERTY_NAME\t\t= 0,\n\tHP_WMI_EVENT_PROPERTY_DESCRIPTION\t= 1,\n\tHP_WMI_EVENT_PROPERTY_CATEGORY\t\t= 2,\n\tHP_WMI_EVENT_PROPERTY_SEVERITY\t\t= 3,\n\tHP_WMI_EVENT_PROPERTY_STATUS\t\t= 4,\n};\n\nstatic const acpi_object_type hp_wmi_event_property_map[] = {\n\t[HP_WMI_EVENT_PROPERTY_NAME]\t\t= ACPI_TYPE_STRING,\n\t[HP_WMI_EVENT_PROPERTY_DESCRIPTION]\t= ACPI_TYPE_STRING,\n\t[HP_WMI_EVENT_PROPERTY_CATEGORY]\t= ACPI_TYPE_INTEGER,\n\t[HP_WMI_EVENT_PROPERTY_SEVERITY]\t= ACPI_TYPE_INTEGER,\n\t[HP_WMI_EVENT_PROPERTY_STATUS]\t\t= ACPI_TYPE_INTEGER,\n};\n\nstatic const enum hwmon_sensor_types hp_wmi_hwmon_type_map[] = {\n\t[HP_WMI_TYPE_TEMPERATURE]\t\t= hwmon_temp,\n\t[HP_WMI_TYPE_VOLTAGE]\t\t\t= hwmon_in,\n\t[HP_WMI_TYPE_CURRENT]\t\t\t= hwmon_curr,\n\t[HP_WMI_TYPE_AIR_FLOW]\t\t\t= hwmon_fan,\n};\n\nstatic const u32 hp_wmi_hwmon_attributes[hwmon_max] = {\n\t[hwmon_chip]\t  = HWMON_C_REGISTER_TZ,\n\t[hwmon_temp]\t  = HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_FAULT,\n\t[hwmon_in]\t  = HWMON_I_INPUT | HWMON_I_LABEL,\n\t[hwmon_curr]\t  = HWMON_C_INPUT | HWMON_C_LABEL,\n\t[hwmon_fan]\t  = HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_FAULT,\n\t[hwmon_intrusion] = HWMON_INTRUSION_ALARM,\n};\n\n \nstruct hp_wmi_numeric_sensor {\n\tconst char *name;\n\tconst char *description;\n\tu32 sensor_type;\n\tconst char *other_sensor_type;\t \n\tu32 operational_status;\n\tu8 size;\t\t\t \n\tconst char **possible_states;\n\tconst char *current_state;\n\tu32 base_units;\n\ts32 unit_modifier;\n\tu32 current_reading;\n\tu32 rate_units;\n};\n\n \nstruct hp_wmi_platform_events {\n\tconst char *name;\n\tconst char *description;\n\tconst char *source_namespace;\n\tconst char *source_class;\n\tu32 category;\n\tu32 possible_severity;\n\tu32 possible_status;\n};\n\n \nstruct hp_wmi_event {\n\tconst char *name;\n\tconst char *description;\n\tu32 category;\n};\n\n \nstruct hp_wmi_info {\n\tstruct hp_wmi_numeric_sensor nsensor;\n\tu8 instance;\n\tvoid *state;\t\t\t \n\tbool has_alarm;\n\tbool alarm;\n\tenum hwmon_sensor_types type;\n\tlong cached_val;\n\tunsigned long last_updated;\t \n\n};\n\n \nstruct hp_wmi_sensors {\n\tstruct wmi_device *wdev;\n\tstruct hp_wmi_info **info_map[hwmon_max];\n\tu8 channel_count[hwmon_max];\n\tbool has_intrusion;\n\tbool intrusion;\n\n\tstruct mutex lock;\t \n};\n\n \nstatic char *hp_wmi_strdup(struct device *dev, const char *src)\n{\n\tchar *dst;\n\tsize_t len;\n\n\tlen = strnlen(src, HP_WMI_MAX_STR_SIZE - 1);\n\n\tdst = devm_kmalloc(dev, (len + 1) * sizeof(*dst), GFP_KERNEL);\n\tif (!dst)\n\t\treturn NULL;\n\n\tstrscpy(dst, src, len + 1);\n\n\treturn dst;\n}\n\n \nstatic union acpi_object *hp_wmi_get_wobj(const char *guid, u8 instance)\n{\n\tstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status err;\n\n\terr = wmi_query_block(guid, instance, &out);\n\tif (ACPI_FAILURE(err))\n\t\treturn NULL;\n\n\treturn out.pointer;\n}\n\n \nstatic u8 hp_wmi_wobj_instance_count(const char *guid)\n{\n\tint count;\n\n\tcount = wmi_instance_count(guid);\n\n\treturn clamp(count, 0, (int)HP_WMI_MAX_INSTANCES);\n}\n\nstatic int check_wobj(const union acpi_object *wobj,\n\t\t      const acpi_object_type property_map[], int last_prop)\n{\n\tacpi_object_type type = wobj->type;\n\tacpi_object_type valid_type;\n\tunion acpi_object *elements;\n\tu32 elem_count;\n\tint prop;\n\n\tif (type != ACPI_TYPE_PACKAGE)\n\t\treturn -EINVAL;\n\n\telem_count = wobj->package.count;\n\tif (elem_count != last_prop + 1)\n\t\treturn -EINVAL;\n\n\telements = wobj->package.elements;\n\tfor (prop = 0; prop <= last_prop; prop++) {\n\t\ttype = elements[prop].type;\n\t\tvalid_type = property_map[prop];\n\t\tif (type != valid_type)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int extract_acpi_value(struct device *dev,\n\t\t\t      union acpi_object *element,\n\t\t\t      acpi_object_type type,\n\t\t\t      u32 *out_value, char **out_string)\n{\n\tswitch (type) {\n\tcase ACPI_TYPE_INTEGER:\n\t\t*out_value = element->integer.value;\n\t\tbreak;\n\n\tcase ACPI_TYPE_STRING:\n\t\t*out_string = hp_wmi_strdup(dev, strim(element->string.pointer));\n\t\tif (!*out_string)\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int check_numeric_sensor_wobj(const union acpi_object *wobj,\n\t\t\t\t     u8 *out_size, bool *out_is_new)\n{\n\tacpi_object_type type = wobj->type;\n\tint prop = HP_WMI_PROPERTY_NAME;\n\tacpi_object_type valid_type;\n\tunion acpi_object *elements;\n\tu32 elem_count;\n\tint last_prop;\n\tbool is_new;\n\tu8 count;\n\tu32 j;\n\tu32 i;\n\n\tif (type != ACPI_TYPE_PACKAGE)\n\t\treturn -EINVAL;\n\n\t \n\telements = wobj->package.elements;\n\n\telem_count = wobj->package.count;\n\tif (elem_count <= HP_WMI_PROPERTY_SIZE ||\n\t    elem_count > HP_WMI_MAX_PROPERTIES)\n\t\treturn -EINVAL;\n\n\ttype = elements[HP_WMI_PROPERTY_SIZE].type;\n\tswitch (type) {\n\tcase ACPI_TYPE_INTEGER:\n\t\tis_new = true;\n\t\tlast_prop = HP_WMI_PROPERTY_RATE_UNITS;\n\t\tbreak;\n\n\tcase ACPI_TYPE_STRING:\n\t\tis_new = false;\n\t\tlast_prop = HP_WMI_PROPERTY_CURRENT_READING;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (elem_count < last_prop - !is_new + 1)\n\t\treturn -EINVAL;\n\n\tcount = elem_count - (last_prop - !is_new);\n\n\tfor (i = 0; i < elem_count && prop <= last_prop; i++, prop++) {\n\t\ttype = elements[i].type;\n\t\tvalid_type = hp_wmi_property_map[prop];\n\t\tif (type != valid_type)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (prop) {\n\t\tcase HP_WMI_PROPERTY_OPERATIONAL_STATUS:\n\t\t\t \n\t\t\tif (!is_new)\n\t\t\t\tprop = HP_WMI_PROPERTY_CURRENT_STATE - 1;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_SIZE:\n\t\t\t \n\t\t\tif (count != elements[i].integer.value)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_POSSIBLE_STATES:\n\t\t\t \n\t\t\tfor (j = 0; i + 1 < elem_count && j + 1 < count; j++) {\n\t\t\t\ttype = elements[++i].type;\n\t\t\t\tif (type != valid_type)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!is_new)\n\t\t\t\tprop = HP_WMI_PROPERTY_BASE_UNITS - 1;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_CURRENT_STATE:\n\t\t\t \n\t\t\tif (!is_new)\n\t\t\t\tprop = HP_WMI_PROPERTY_POSSIBLE_STATES - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (prop != last_prop + 1)\n\t\treturn -EINVAL;\n\n\t*out_size = count;\n\t*out_is_new = is_new;\n\n\treturn 0;\n}\n\nstatic int\nnumeric_sensor_is_connected(const struct hp_wmi_numeric_sensor *nsensor)\n{\n\tu32 operational_status = nsensor->operational_status;\n\n\treturn operational_status != HP_WMI_STATUS_NO_CONTACT;\n}\n\nstatic int numeric_sensor_has_fault(const struct hp_wmi_numeric_sensor *nsensor)\n{\n\tu32 operational_status = nsensor->operational_status;\n\n\tswitch (operational_status) {\n\tcase HP_WMI_STATUS_DEGRADED:\n\tcase HP_WMI_STATUS_STRESSED:\t\t \n\tcase HP_WMI_STATUS_PREDICTIVE_FAILURE:\t \n\tcase HP_WMI_STATUS_ERROR:\n\tcase HP_WMI_STATUS_NON_RECOVERABLE_ERROR:\n\tcase HP_WMI_STATUS_NO_CONTACT:\n\tcase HP_WMI_STATUS_LOST_COMMUNICATION:\n\tcase HP_WMI_STATUS_ABORTED:\n\tcase HP_WMI_STATUS_SUPPORTING_ENTITY_IN_ERROR:\n\n\t \n\tcase HP_WMI_STATUS_COMPLETED + HP_WMI_STATUS_DEGRADED:\n\tcase HP_WMI_STATUS_COMPLETED + HP_WMI_STATUS_ERROR:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic long scale_numeric_sensor(const struct hp_wmi_numeric_sensor *nsensor)\n{\n\tu32 current_reading = nsensor->current_reading;\n\ts32 unit_modifier = nsensor->unit_modifier;\n\tu32 sensor_type = nsensor->sensor_type;\n\tu32 base_units = nsensor->base_units;\n\ts32 target_modifier;\n\tlong val;\n\n\t \n\ttarget_modifier = sensor_type == HP_WMI_TYPE_AIR_FLOW ? 0 : -3;\n\n\tval = current_reading;\n\n\tfor (; unit_modifier < target_modifier; unit_modifier++)\n\t\tval = DIV_ROUND_CLOSEST(val, 10);\n\n\tfor (; unit_modifier > target_modifier; unit_modifier--) {\n\t\tif (val > LONG_MAX / 10) {\n\t\t\tval = LONG_MAX;\n\t\t\tbreak;\n\t\t}\n\t\tval *= 10;\n\t}\n\n\tif (sensor_type == HP_WMI_TYPE_TEMPERATURE) {\n\t\tswitch (base_units) {\n\t\tcase HP_WMI_UNITS_DEGREES_F:\n\t\t\tval -= MILLI * 32;\n\t\t\tval = val <= LONG_MAX / 5 ?\n\t\t\t\t      DIV_ROUND_CLOSEST(val * 5, 9) :\n\t\t\t\t      DIV_ROUND_CLOSEST(val, 9) * 5;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_UNITS_DEGREES_K:\n\t\t\tval = milli_kelvin_to_millicelsius(val);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn val;\n}\n\n \nstatic int classify_numeric_sensor(const struct hp_wmi_numeric_sensor *nsensor)\n{\n\tu32 sensor_type = nsensor->sensor_type;\n\tu32 base_units = nsensor->base_units;\n\tconst char *name = nsensor->name;\n\n\tswitch (sensor_type) {\n\tcase HP_WMI_TYPE_TEMPERATURE:\n\t\t \n\t\tif ((base_units == HP_WMI_UNITS_OTHER &&\n\t\t     strstr(name, HP_WMI_PATTERN_TEMP_SENSOR)) ||\n\t\t    base_units == HP_WMI_UNITS_DEGREES_C ||\n\t\t    base_units == HP_WMI_UNITS_DEGREES_F ||\n\t\t    base_units == HP_WMI_UNITS_DEGREES_K)\n\t\t\treturn HP_WMI_TYPE_TEMPERATURE;\n\t\tbreak;\n\n\tcase HP_WMI_TYPE_VOLTAGE:\n\t\tif (base_units == HP_WMI_UNITS_VOLTS)\n\t\t\treturn HP_WMI_TYPE_VOLTAGE;\n\t\tbreak;\n\n\tcase HP_WMI_TYPE_CURRENT:\n\t\tif (base_units == HP_WMI_UNITS_AMPS)\n\t\t\treturn HP_WMI_TYPE_CURRENT;\n\t\tbreak;\n\n\tcase HP_WMI_TYPE_AIR_FLOW:\n\t\t \n\t\tif (base_units == HP_WMI_UNITS_RPM)\n\t\t\treturn HP_WMI_TYPE_AIR_FLOW;\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\npopulate_numeric_sensor_from_wobj(struct device *dev,\n\t\t\t\t  struct hp_wmi_numeric_sensor *nsensor,\n\t\t\t\t  union acpi_object *wobj, bool *out_is_new)\n{\n\tint last_prop = HP_WMI_PROPERTY_RATE_UNITS;\n\tint prop = HP_WMI_PROPERTY_NAME;\n\tconst char **possible_states;\n\tunion acpi_object *element;\n\tacpi_object_type type;\n\tchar *string;\n\tbool is_new;\n\tu32 value;\n\tu8 size;\n\tint err;\n\n\terr = check_numeric_sensor_wobj(wobj, &size, &is_new);\n\tif (err)\n\t\treturn err;\n\n\tpossible_states = devm_kcalloc(dev, size, sizeof(*possible_states),\n\t\t\t\t       GFP_KERNEL);\n\tif (!possible_states)\n\t\treturn -ENOMEM;\n\n\telement = wobj->package.elements;\n\tnsensor->possible_states = possible_states;\n\tnsensor->size = size;\n\n\tif (!is_new)\n\t\tlast_prop = HP_WMI_PROPERTY_CURRENT_READING;\n\n\tfor (; prop <= last_prop; prop++) {\n\t\ttype = hp_wmi_property_map[prop];\n\n\t\terr = extract_acpi_value(dev, element, type, &value, &string);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\telement++;\n\n\t\tswitch (prop) {\n\t\tcase HP_WMI_PROPERTY_NAME:\n\t\t\tnsensor->name = string;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_DESCRIPTION:\n\t\t\tnsensor->description = string;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_SENSOR_TYPE:\n\t\t\tif (value > HP_WMI_TYPE_AIR_FLOW)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnsensor->sensor_type = value;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_OTHER_SENSOR_TYPE:\n\t\t\tnsensor->other_sensor_type = string;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_OPERATIONAL_STATUS:\n\t\t\tnsensor->operational_status = value;\n\n\t\t\t \n\t\t\tif (!is_new)\n\t\t\t\tprop = HP_WMI_PROPERTY_CURRENT_STATE - 1;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_SIZE:\n\t\t\tbreak;\t\t\t \n\n\t\tcase HP_WMI_PROPERTY_POSSIBLE_STATES:\n\t\t\t*possible_states++ = string;\n\t\t\tif (--size)\n\t\t\t\tprop--;\n\n\t\t\t \n\t\t\tif (!is_new && !size)\n\t\t\t\tprop = HP_WMI_PROPERTY_BASE_UNITS - 1;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_CURRENT_STATE:\n\t\t\tnsensor->current_state = string;\n\n\t\t\t \n\t\t\tif (!is_new)\n\t\t\t\tprop = HP_WMI_PROPERTY_POSSIBLE_STATES - 1;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_BASE_UNITS:\n\t\t\tnsensor->base_units = value;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_UNIT_MODIFIER:\n\t\t\t \n\t\t\tnsensor->unit_modifier = (s32)value;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_CURRENT_READING:\n\t\t\tnsensor->current_reading = value;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PROPERTY_RATE_UNITS:\n\t\t\tnsensor->rate_units = value;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t*out_is_new = is_new;\n\n\treturn 0;\n}\n\n \nstatic void\nupdate_numeric_sensor_from_wobj(struct device *dev,\n\t\t\t\tstruct hp_wmi_numeric_sensor *nsensor,\n\t\t\t\tconst union acpi_object *wobj)\n{\n\tconst union acpi_object *elements;\n\tconst union acpi_object *element;\n\tconst char *string;\n\tbool is_new;\n\tint offset;\n\tu8 size;\n\tint err;\n\n\terr = check_numeric_sensor_wobj(wobj, &size, &is_new);\n\tif (err)\n\t\treturn;\n\n\telements = wobj->package.elements;\n\n\telement = &elements[HP_WMI_PROPERTY_OPERATIONAL_STATUS];\n\tnsensor->operational_status = element->integer.value;\n\n\t \n\toffset = is_new ? size - 1 : -2;\n\n\telement = &elements[HP_WMI_PROPERTY_CURRENT_STATE + offset];\n\tstring = strim(element->string.pointer);\n\n\tif (strcmp(string, nsensor->current_state)) {\n\t\tdevm_kfree(dev, nsensor->current_state);\n\t\tnsensor->current_state = hp_wmi_strdup(dev, string);\n\t}\n\n\t \n\tif (!is_new)\n\t\toffset = (int)size - 2;\t \n\n\telement = &elements[HP_WMI_PROPERTY_UNIT_MODIFIER + offset];\n\tnsensor->unit_modifier = (s32)element->integer.value;\n\n\telement = &elements[HP_WMI_PROPERTY_CURRENT_READING + offset];\n\tnsensor->current_reading = element->integer.value;\n}\n\n \nstatic int check_platform_events_wobj(const union acpi_object *wobj)\n{\n\treturn check_wobj(wobj, hp_wmi_platform_events_property_map,\n\t\t\t  HP_WMI_PLATFORM_EVENTS_PROPERTY_POSSIBLE_STATUS);\n}\n\nstatic int\npopulate_platform_events_from_wobj(struct device *dev,\n\t\t\t\t   struct hp_wmi_platform_events *pevents,\n\t\t\t\t   union acpi_object *wobj)\n{\n\tint last_prop = HP_WMI_PLATFORM_EVENTS_PROPERTY_POSSIBLE_STATUS;\n\tint prop = HP_WMI_PLATFORM_EVENTS_PROPERTY_NAME;\n\tunion acpi_object *element;\n\tacpi_object_type type;\n\tchar *string;\n\tu32 value;\n\tint err;\n\n\terr = check_platform_events_wobj(wobj);\n\tif (err)\n\t\treturn err;\n\n\telement = wobj->package.elements;\n\n\tfor (; prop <= last_prop; prop++, element++) {\n\t\ttype = hp_wmi_platform_events_property_map[prop];\n\n\t\terr = extract_acpi_value(dev, element, type, &value, &string);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tswitch (prop) {\n\t\tcase HP_WMI_PLATFORM_EVENTS_PROPERTY_NAME:\n\t\t\tpevents->name = string;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PLATFORM_EVENTS_PROPERTY_DESCRIPTION:\n\t\t\tpevents->description = string;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PLATFORM_EVENTS_PROPERTY_SOURCE_NAMESPACE:\n\t\t\tif (strcasecmp(HP_WMI_EVENT_NAMESPACE, string))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tpevents->source_namespace = string;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PLATFORM_EVENTS_PROPERTY_SOURCE_CLASS:\n\t\t\tif (strcasecmp(HP_WMI_EVENT_CLASS, string))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tpevents->source_class = string;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PLATFORM_EVENTS_PROPERTY_CATEGORY:\n\t\t\tpevents->category = value;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PLATFORM_EVENTS_PROPERTY_POSSIBLE_SEVERITY:\n\t\t\tpevents->possible_severity = value;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_PLATFORM_EVENTS_PROPERTY_POSSIBLE_STATUS:\n\t\t\tpevents->possible_status = value;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int check_event_wobj(const union acpi_object *wobj)\n{\n\treturn check_wobj(wobj, hp_wmi_event_property_map,\n\t\t\t  HP_WMI_EVENT_PROPERTY_STATUS);\n}\n\nstatic int populate_event_from_wobj(struct hp_wmi_event *event,\n\t\t\t\t    union acpi_object *wobj)\n{\n\tint prop = HP_WMI_EVENT_PROPERTY_NAME;\n\tunion acpi_object *element;\n\tint err;\n\n\terr = check_event_wobj(wobj);\n\tif (err)\n\t\treturn err;\n\n\telement = wobj->package.elements;\n\n\t \n\n\tfor (; prop <= HP_WMI_EVENT_PROPERTY_CATEGORY; prop++, element++) {\n\t\tswitch (prop) {\n\t\tcase HP_WMI_EVENT_PROPERTY_NAME:\n\t\t\tevent->name = strim(element->string.pointer);\n\t\t\tbreak;\n\n\t\tcase HP_WMI_EVENT_PROPERTY_DESCRIPTION:\n\t\t\tevent->description = strim(element->string.pointer);\n\t\t\tbreak;\n\n\t\tcase HP_WMI_EVENT_PROPERTY_CATEGORY:\n\t\t\tevent->category = element->integer.value;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int classify_event(const char *event_name, u32 category)\n{\n\tif (category != HP_WMI_CATEGORY_SENSOR)\n\t\treturn -EINVAL;\n\n\t \n\tif (strstr(event_name, HP_WMI_PATTERN_FAN_ALARM))\n\t\treturn HP_WMI_TYPE_AIR_FLOW;\n\n\t \n\tif (!strcmp(event_name, HP_WMI_PATTERN_INTRUSION_ALARM))\n\t\treturn HP_WMI_TYPE_INTRUSION;\n\n\t \n\tif (!strcmp(event_name, HP_WMI_PATTERN_TEMP_ALARM))\n\t\treturn HP_WMI_TYPE_TEMPERATURE;\n\n\treturn -EINVAL;\n}\n\n \nstatic void interpret_info(struct hp_wmi_info *info)\n{\n\tconst struct hp_wmi_numeric_sensor *nsensor = &info->nsensor;\n\n\tinfo->cached_val = scale_numeric_sensor(nsensor);\n\tinfo->last_updated = jiffies;\n}\n\n \nstatic int hp_wmi_update_info(struct hp_wmi_sensors *state,\n\t\t\t      struct hp_wmi_info *info)\n{\n\tstruct hp_wmi_numeric_sensor *nsensor = &info->nsensor;\n\tstruct device *dev = &state->wdev->dev;\n\tconst union acpi_object *wobj;\n\tu8 instance = info->instance;\n\tint ret = 0;\n\n\tif (time_after(jiffies, info->last_updated + HZ)) {\n\t\tmutex_lock(&state->lock);\n\n\t\twobj = hp_wmi_get_wobj(HP_WMI_NUMERIC_SENSOR_GUID, instance);\n\t\tif (!wobj) {\n\t\t\tret = -EIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tupdate_numeric_sensor_from_wobj(dev, nsensor, wobj);\n\n\t\tinterpret_info(info);\n\n\t\tkfree(wobj);\n\nout_unlock:\n\t\tmutex_unlock(&state->lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int basic_string_show(struct seq_file *seqf, void *ignored)\n{\n\tconst char *str = seqf->private;\n\n\tseq_printf(seqf, \"%s\\n\", str);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(basic_string);\n\nstatic int fungible_show(struct seq_file *seqf, enum hp_wmi_property prop)\n{\n\tstruct hp_wmi_numeric_sensor *nsensor;\n\tstruct hp_wmi_sensors *state;\n\tstruct hp_wmi_info *info;\n\tint err;\n\n\tinfo = seqf->private;\n\tstate = info->state;\n\tnsensor = &info->nsensor;\n\n\terr = hp_wmi_update_info(state, info);\n\tif (err)\n\t\treturn err;\n\n\tswitch (prop) {\n\tcase HP_WMI_PROPERTY_OPERATIONAL_STATUS:\n\t\tseq_printf(seqf, \"%u\\n\", nsensor->operational_status);\n\t\tbreak;\n\n\tcase HP_WMI_PROPERTY_CURRENT_STATE:\n\t\tseq_printf(seqf, \"%s\\n\", nsensor->current_state);\n\t\tbreak;\n\n\tcase HP_WMI_PROPERTY_UNIT_MODIFIER:\n\t\tseq_printf(seqf, \"%d\\n\", nsensor->unit_modifier);\n\t\tbreak;\n\n\tcase HP_WMI_PROPERTY_CURRENT_READING:\n\t\tseq_printf(seqf, \"%u\\n\", nsensor->current_reading);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int operational_status_show(struct seq_file *seqf, void *ignored)\n{\n\treturn fungible_show(seqf, HP_WMI_PROPERTY_OPERATIONAL_STATUS);\n}\nDEFINE_SHOW_ATTRIBUTE(operational_status);\n\nstatic int current_state_show(struct seq_file *seqf, void *ignored)\n{\n\treturn fungible_show(seqf, HP_WMI_PROPERTY_CURRENT_STATE);\n}\nDEFINE_SHOW_ATTRIBUTE(current_state);\n\nstatic int possible_states_show(struct seq_file *seqf, void *ignored)\n{\n\tstruct hp_wmi_numeric_sensor *nsensor = seqf->private;\n\tu8 i;\n\n\tfor (i = 0; i < nsensor->size; i++)\n\t\tseq_printf(seqf, \"%s%s\", i ? \",\" : \"\",\n\t\t\t   nsensor->possible_states[i]);\n\n\tseq_puts(seqf, \"\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(possible_states);\n\nstatic int unit_modifier_show(struct seq_file *seqf, void *ignored)\n{\n\treturn fungible_show(seqf, HP_WMI_PROPERTY_UNIT_MODIFIER);\n}\nDEFINE_SHOW_ATTRIBUTE(unit_modifier);\n\nstatic int current_reading_show(struct seq_file *seqf, void *ignored)\n{\n\treturn fungible_show(seqf, HP_WMI_PROPERTY_CURRENT_READING);\n}\nDEFINE_SHOW_ATTRIBUTE(current_reading);\n\n \nstatic void hp_wmi_devm_debugfs_remove(void *res)\n{\n\tdebugfs_remove_recursive(res);\n}\n\n \nstatic void hp_wmi_debugfs_init(struct device *dev, struct hp_wmi_info *info,\n\t\t\t\tstruct hp_wmi_platform_events *pevents,\n\t\t\t\tu8 icount, u8 pcount, bool is_new)\n{\n\tstruct hp_wmi_numeric_sensor *nsensor;\n\tchar buf[HP_WMI_MAX_STR_SIZE];\n\tstruct dentry *debugfs;\n\tstruct dentry *entries;\n\tstruct dentry *dir;\n\tint err;\n\tu8 i;\n\n\t \n\tscnprintf(buf, sizeof(buf), \"hp-wmi-sensors-%u\", dev->id);\n\n\tdebugfs = debugfs_create_dir(buf, NULL);\n\tif (IS_ERR(debugfs))\n\t\treturn;\n\n\terr = devm_add_action_or_reset(dev, hp_wmi_devm_debugfs_remove,\n\t\t\t\t       debugfs);\n\tif (err)\n\t\treturn;\n\n\tentries = debugfs_create_dir(\"sensor\", debugfs);\n\n\tfor (i = 0; i < icount; i++, info++) {\n\t\tnsensor = &info->nsensor;\n\n\t\tscnprintf(buf, sizeof(buf), \"%u\", i);\n\t\tdir = debugfs_create_dir(buf, entries);\n\n\t\tdebugfs_create_file(\"name\", 0444, dir,\n\t\t\t\t    (void *)nsensor->name,\n\t\t\t\t    &basic_string_fops);\n\n\t\tdebugfs_create_file(\"description\", 0444, dir,\n\t\t\t\t    (void *)nsensor->description,\n\t\t\t\t    &basic_string_fops);\n\n\t\tdebugfs_create_u32(\"sensor_type\", 0444, dir,\n\t\t\t\t   &nsensor->sensor_type);\n\n\t\tdebugfs_create_file(\"other_sensor_type\", 0444, dir,\n\t\t\t\t    (void *)nsensor->other_sensor_type,\n\t\t\t\t    &basic_string_fops);\n\n\t\tdebugfs_create_file(\"operational_status\", 0444, dir,\n\t\t\t\t    info, &operational_status_fops);\n\n\t\tdebugfs_create_file(\"possible_states\", 0444, dir,\n\t\t\t\t    nsensor, &possible_states_fops);\n\n\t\tdebugfs_create_file(\"current_state\", 0444, dir,\n\t\t\t\t    info, &current_state_fops);\n\n\t\tdebugfs_create_u32(\"base_units\", 0444, dir,\n\t\t\t\t   &nsensor->base_units);\n\n\t\tdebugfs_create_file(\"unit_modifier\", 0444, dir,\n\t\t\t\t    info, &unit_modifier_fops);\n\n\t\tdebugfs_create_file(\"current_reading\", 0444, dir,\n\t\t\t\t    info, &current_reading_fops);\n\n\t\tif (is_new)\n\t\t\tdebugfs_create_u32(\"rate_units\", 0444, dir,\n\t\t\t\t\t   &nsensor->rate_units);\n\t}\n\n\tif (!pcount)\n\t\treturn;\n\n\tentries = debugfs_create_dir(\"platform_events\", debugfs);\n\n\tfor (i = 0; i < pcount; i++, pevents++) {\n\t\tscnprintf(buf, sizeof(buf), \"%u\", i);\n\t\tdir = debugfs_create_dir(buf, entries);\n\n\t\tdebugfs_create_file(\"name\", 0444, dir,\n\t\t\t\t    (void *)pevents->name,\n\t\t\t\t    &basic_string_fops);\n\n\t\tdebugfs_create_file(\"description\", 0444, dir,\n\t\t\t\t    (void *)pevents->description,\n\t\t\t\t    &basic_string_fops);\n\n\t\tdebugfs_create_file(\"source_namespace\", 0444, dir,\n\t\t\t\t    (void *)pevents->source_namespace,\n\t\t\t\t    &basic_string_fops);\n\n\t\tdebugfs_create_file(\"source_class\", 0444, dir,\n\t\t\t\t    (void *)pevents->source_class,\n\t\t\t\t    &basic_string_fops);\n\n\t\tdebugfs_create_u32(\"category\", 0444, dir,\n\t\t\t\t   &pevents->category);\n\n\t\tdebugfs_create_u32(\"possible_severity\", 0444, dir,\n\t\t\t\t   &pevents->possible_severity);\n\n\t\tdebugfs_create_u32(\"possible_status\", 0444, dir,\n\t\t\t\t   &pevents->possible_status);\n\t}\n}\n\nstatic umode_t hp_wmi_hwmon_is_visible(const void *drvdata,\n\t\t\t\t       enum hwmon_sensor_types type,\n\t\t\t\t       u32 attr, int channel)\n{\n\tconst struct hp_wmi_sensors *state = drvdata;\n\tconst struct hp_wmi_info *info;\n\n\tif (type == hwmon_intrusion)\n\t\treturn state->has_intrusion ? 0644 : 0;\n\n\tif (!state->info_map[type] || !state->info_map[type][channel])\n\t\treturn 0;\n\n\tinfo = state->info_map[type][channel];\n\n\tif ((type == hwmon_temp && attr == hwmon_temp_alarm) ||\n\t    (type == hwmon_fan  && attr == hwmon_fan_alarm))\n\t\treturn info->has_alarm ? 0444 : 0;\n\n\treturn 0444;\n}\n\nstatic int hp_wmi_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel, long *out_val)\n{\n\tstruct hp_wmi_sensors *state = dev_get_drvdata(dev);\n\tconst struct hp_wmi_numeric_sensor *nsensor;\n\tstruct hp_wmi_info *info;\n\tint err;\n\n\tif (type == hwmon_intrusion) {\n\t\t*out_val = state->intrusion ? 1 : 0;\n\n\t\treturn 0;\n\t}\n\n\tinfo = state->info_map[type][channel];\n\n\tif ((type == hwmon_temp && attr == hwmon_temp_alarm) ||\n\t    (type == hwmon_fan  && attr == hwmon_fan_alarm)) {\n\t\t*out_val = info->alarm ? 1 : 0;\n\t\tinfo->alarm = false;\n\n\t\treturn 0;\n\t}\n\n\tnsensor = &info->nsensor;\n\n\terr = hp_wmi_update_info(state, info);\n\tif (err)\n\t\treturn err;\n\n\tif ((type == hwmon_temp && attr == hwmon_temp_fault) ||\n\t    (type == hwmon_fan  && attr == hwmon_fan_fault))\n\t\t*out_val = numeric_sensor_has_fault(nsensor);\n\telse\n\t\t*out_val = info->cached_val;\n\n\treturn 0;\n}\n\nstatic int hp_wmi_hwmon_read_string(struct device *dev,\n\t\t\t\t    enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t    int channel, const char **out_str)\n{\n\tconst struct hp_wmi_sensors *state = dev_get_drvdata(dev);\n\tconst struct hp_wmi_info *info;\n\n\tinfo = state->info_map[type][channel];\n\t*out_str = info->nsensor.name;\n\n\treturn 0;\n}\n\nstatic int hp_wmi_hwmon_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel, long val)\n{\n\tstruct hp_wmi_sensors *state = dev_get_drvdata(dev);\n\n\tif (val)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->lock);\n\n\tstate->intrusion = false;\n\n\tmutex_unlock(&state->lock);\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops hp_wmi_hwmon_ops = {\n\t.is_visible  = hp_wmi_hwmon_is_visible,\n\t.read\t     = hp_wmi_hwmon_read,\n\t.read_string = hp_wmi_hwmon_read_string,\n\t.write\t     = hp_wmi_hwmon_write,\n};\n\nstatic struct hwmon_chip_info hp_wmi_chip_info = {\n\t.ops         = &hp_wmi_hwmon_ops,\n\t.info        = NULL,\n};\n\nstatic struct hp_wmi_info *match_fan_event(struct hp_wmi_sensors *state,\n\t\t\t\t\t   const char *event_description)\n{\n\tstruct hp_wmi_info **ptr_info = state->info_map[hwmon_fan];\n\tu8 fan_count = state->channel_count[hwmon_fan];\n\tstruct hp_wmi_info *info;\n\tconst char *name;\n\tu8 i;\n\n\t \n\n\tfor (i = 0; i < fan_count; i++, ptr_info++) {\n\t\tinfo = *ptr_info;\n\t\tname = info->nsensor.name;\n\n\t\tif (strstr(event_description, name))\n\t\t\treturn info;\n\t}\n\n\treturn NULL;\n}\n\nstatic u8 match_temp_events(struct hp_wmi_sensors *state,\n\t\t\t    const char *event_description,\n\t\t\t    struct hp_wmi_info *temp_info[])\n{\n\tstruct hp_wmi_info **ptr_info = state->info_map[hwmon_temp];\n\tu8 temp_count = state->channel_count[hwmon_temp];\n\tstruct hp_wmi_info *info;\n\tconst char *name;\n\tu8 count = 0;\n\tbool is_cpu;\n\tbool is_sys;\n\tu8 i;\n\n\t \n\n\tis_cpu = !strcmp(event_description, HP_WMI_PATTERN_CPU_TEMP);\n\tis_sys = !strcmp(event_description, HP_WMI_PATTERN_SYS_TEMP);\n\tif (!is_cpu && !is_sys)\n\t\treturn 0;\n\n\t \n\n\tfor (i = 0; i < temp_count; i++, ptr_info++) {\n\t\tinfo = *ptr_info;\n\t\tname = info->nsensor.name;\n\n\t\tif ((is_cpu && (!strcmp(name, HP_WMI_PATTERN_CPU_TEMP) ||\n\t\t\t\t!strcmp(name, HP_WMI_PATTERN_CPU_TEMP2))) ||\n\t\t    (is_sys && (!strcmp(name, HP_WMI_PATTERN_SYS_TEMP) ||\n\t\t\t\t!strcmp(name, HP_WMI_PATTERN_SYS_TEMP2)))) {\n\t\t\ttemp_info[0] = info;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (is_cpu && (strstr(name, HP_WMI_PATTERN_CPU) &&\n\t\t\t       strstr(name, HP_WMI_PATTERN_TEMP)))\n\t\t\ttemp_info[count++] = info;\n\t}\n\n\treturn count;\n}\n\n \nstatic void hp_wmi_devm_notify_remove(void *ignored)\n{\n\twmi_remove_notify_handler(HP_WMI_EVENT_GUID);\n}\n\n \nstatic void hp_wmi_notify(u32 value, void *context)\n{\n\tstruct hp_wmi_info *temp_info[HP_WMI_MAX_INSTANCES] = {};\n\tstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct hp_wmi_sensors *state = context;\n\tstruct device *dev = &state->wdev->dev;\n\tstruct hp_wmi_info *fan_info;\n\tstruct hp_wmi_event event;\n\tunion acpi_object *wobj;\n\tacpi_status err;\n\tint event_type;\n\tu8 count;\n\n\t \n\n\tmutex_lock(&state->lock);\n\n\terr = wmi_get_event_data(value, &out);\n\tif (ACPI_FAILURE(err))\n\t\tgoto out_unlock;\n\n\twobj = out.pointer;\n\n\terr = populate_event_from_wobj(&event, wobj);\n\tif (err) {\n\t\tdev_warn(dev, \"Bad event data (ACPI type %d)\\n\", wobj->type);\n\t\tgoto out_free_wobj;\n\t}\n\n\tevent_type = classify_event(event.name, event.category);\n\tswitch (event_type) {\n\tcase HP_WMI_TYPE_AIR_FLOW:\n\t\tfan_info = match_fan_event(state, event.description);\n\t\tif (fan_info)\n\t\t\tfan_info->alarm = true;\n\t\tbreak;\n\n\tcase HP_WMI_TYPE_INTRUSION:\n\t\tstate->intrusion = true;\n\t\tbreak;\n\n\tcase HP_WMI_TYPE_TEMPERATURE:\n\t\tcount = match_temp_events(state, event.description, temp_info);\n\t\twhile (count)\n\t\t\ttemp_info[--count]->alarm = true;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\nout_free_wobj:\n\tkfree(wobj);\n\nout_unlock:\n\tmutex_unlock(&state->lock);\n}\n\nstatic int init_platform_events(struct device *dev,\n\t\t\t\tstruct hp_wmi_platform_events **out_pevents,\n\t\t\t\tu8 *out_pcount)\n{\n\tstruct hp_wmi_platform_events *pevents_arr;\n\tstruct hp_wmi_platform_events *pevents;\n\tunion acpi_object *wobj;\n\tu8 count;\n\tint err;\n\tu8 i;\n\n\tcount = hp_wmi_wobj_instance_count(HP_WMI_PLATFORM_EVENTS_GUID);\n\tif (!count) {\n\t\t*out_pcount = 0;\n\n\t\tdev_dbg(dev, \"No platform events\\n\");\n\n\t\treturn 0;\n\t}\n\n\tpevents_arr = devm_kcalloc(dev, count, sizeof(*pevents), GFP_KERNEL);\n\tif (!pevents_arr)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, pevents = pevents_arr; i < count; i++, pevents++) {\n\t\twobj = hp_wmi_get_wobj(HP_WMI_PLATFORM_EVENTS_GUID, i);\n\t\tif (!wobj)\n\t\t\treturn -EIO;\n\n\t\terr = populate_platform_events_from_wobj(dev, pevents, wobj);\n\n\t\tkfree(wobj);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t*out_pevents = pevents_arr;\n\t*out_pcount = count;\n\n\tdev_dbg(dev, \"Found %u platform events\\n\", count);\n\n\treturn 0;\n}\n\nstatic int init_numeric_sensors(struct hp_wmi_sensors *state,\n\t\t\t\tstruct hp_wmi_info *connected[],\n\t\t\t\tstruct hp_wmi_info **out_info,\n\t\t\t\tu8 *out_icount, u8 *out_count,\n\t\t\t\tbool *out_is_new)\n{\n\tstruct hp_wmi_info ***info_map = state->info_map;\n\tu8 *channel_count = state->channel_count;\n\tstruct device *dev = &state->wdev->dev;\n\tstruct hp_wmi_numeric_sensor *nsensor;\n\tu8 channel_index[hwmon_max] = {};\n\tenum hwmon_sensor_types type;\n\tstruct hp_wmi_info *info_arr;\n\tstruct hp_wmi_info *info;\n\tunion acpi_object *wobj;\n\tu8 count = 0;\n\tbool is_new;\n\tu8 icount;\n\tint wtype;\n\tint err;\n\tu8 c;\n\tu8 i;\n\n\ticount = hp_wmi_wobj_instance_count(HP_WMI_NUMERIC_SENSOR_GUID);\n\tif (!icount)\n\t\treturn -ENODATA;\n\n\tinfo_arr = devm_kcalloc(dev, icount, sizeof(*info), GFP_KERNEL);\n\tif (!info_arr)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, info = info_arr; i < icount; i++, info++) {\n\t\twobj = hp_wmi_get_wobj(HP_WMI_NUMERIC_SENSOR_GUID, i);\n\t\tif (!wobj)\n\t\t\treturn -EIO;\n\n\t\tinfo->instance = i;\n\t\tinfo->state = state;\n\t\tnsensor = &info->nsensor;\n\n\t\terr = populate_numeric_sensor_from_wobj(dev, nsensor, wobj,\n\t\t\t\t\t\t\t&is_new);\n\n\t\tkfree(wobj);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!numeric_sensor_is_connected(nsensor))\n\t\t\tcontinue;\n\n\t\twtype = classify_numeric_sensor(nsensor);\n\t\tif (wtype < 0)\n\t\t\tcontinue;\n\n\t\ttype = hp_wmi_hwmon_type_map[wtype];\n\n\t\tchannel_count[type]++;\n\n\t\tinfo->type = type;\n\n\t\tinterpret_info(info);\n\n\t\tconnected[count++] = info;\n\t}\n\n\tdev_dbg(dev, \"Found %u sensors (%u connected)\\n\", i, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tinfo = connected[i];\n\t\ttype = info->type;\n\t\tc = channel_index[type]++;\n\n\t\tif (!info_map[type]) {\n\t\t\tinfo_map[type] = devm_kcalloc(dev, channel_count[type],\n\t\t\t\t\t\t      sizeof(*info_map),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!info_map[type])\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tinfo_map[type][c] = info;\n\t}\n\n\t*out_info = info_arr;\n\t*out_icount = icount;\n\t*out_count = count;\n\t*out_is_new = is_new;\n\n\treturn 0;\n}\n\nstatic bool find_event_attributes(struct hp_wmi_sensors *state,\n\t\t\t\t  struct hp_wmi_platform_events *pevents,\n\t\t\t\t  u8 pevents_count)\n{\n\t \n\n\tstruct hp_wmi_info *temp_info[HP_WMI_MAX_INSTANCES] = {};\n\tconst char *event_description;\n\tstruct hp_wmi_info *fan_info;\n\tbool has_events = false;\n\tconst char *event_name;\n\tu32 event_category;\n\tint event_type;\n\tu8 count;\n\tu8 i;\n\n\tfor (i = 0; i < pevents_count; i++, pevents++) {\n\t\tevent_name = pevents->name;\n\t\tevent_description = pevents->description;\n\t\tevent_category = pevents->category;\n\n\t\tevent_type = classify_event(event_name, event_category);\n\t\tswitch (event_type) {\n\t\tcase HP_WMI_TYPE_AIR_FLOW:\n\t\t\tfan_info = match_fan_event(state, event_description);\n\t\t\tif (!fan_info)\n\t\t\t\tbreak;\n\n\t\t\tfan_info->has_alarm = true;\n\t\t\thas_events = true;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_TYPE_INTRUSION:\n\t\t\tstate->has_intrusion = true;\n\t\t\thas_events = true;\n\t\t\tbreak;\n\n\t\tcase HP_WMI_TYPE_TEMPERATURE:\n\t\t\tcount = match_temp_events(state, event_description,\n\t\t\t\t\t\t  temp_info);\n\t\t\tif (!count)\n\t\t\t\tbreak;\n\n\t\t\twhile (count)\n\t\t\t\ttemp_info[--count]->has_alarm = true;\n\t\t\thas_events = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn has_events;\n}\n\nstatic int make_chip_info(struct hp_wmi_sensors *state, bool has_events)\n{\n\tconst struct hwmon_channel_info **ptr_channel_info;\n\tstruct hp_wmi_info ***info_map = state->info_map;\n\tu8 *channel_count = state->channel_count;\n\tstruct hwmon_channel_info *channel_info;\n\tstruct device *dev = &state->wdev->dev;\n\tenum hwmon_sensor_types type;\n\tu8 type_count = 0;\n\tu32 *config;\n\tu32 attr;\n\tu8 count;\n\tu8 i;\n\n\tif (channel_count[hwmon_temp])\n\t\tchannel_count[hwmon_chip] = 1;\n\n\tif (has_events && state->has_intrusion)\n\t\tchannel_count[hwmon_intrusion] = 1;\n\n\tfor (type = hwmon_chip; type < hwmon_max; type++)\n\t\tif (channel_count[type])\n\t\t\ttype_count++;\n\n\tchannel_info = devm_kcalloc(dev, type_count,\n\t\t\t\t    sizeof(*channel_info), GFP_KERNEL);\n\tif (!channel_info)\n\t\treturn -ENOMEM;\n\n\tptr_channel_info = devm_kcalloc(dev, type_count + 1,\n\t\t\t\t\tsizeof(*ptr_channel_info), GFP_KERNEL);\n\tif (!ptr_channel_info)\n\t\treturn -ENOMEM;\n\n\thp_wmi_chip_info.info = ptr_channel_info;\n\n\tfor (type = hwmon_chip; type < hwmon_max; type++) {\n\t\tcount = channel_count[type];\n\t\tif (!count)\n\t\t\tcontinue;\n\n\t\tconfig = devm_kcalloc(dev, count + 1,\n\t\t\t\t      sizeof(*config), GFP_KERNEL);\n\t\tif (!config)\n\t\t\treturn -ENOMEM;\n\n\t\tattr = hp_wmi_hwmon_attributes[type];\n\t\tchannel_info->type = type;\n\t\tchannel_info->config = config;\n\t\tmemset32(config, attr, count);\n\n\t\t*ptr_channel_info++ = channel_info++;\n\n\t\tif (!has_events || (type != hwmon_temp && type != hwmon_fan))\n\t\t\tcontinue;\n\n\t\tattr = type == hwmon_temp ? HWMON_T_ALARM : HWMON_F_ALARM;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\tif (info_map[type][i]->has_alarm)\n\t\t\t\tconfig[i] |= attr;\n\t}\n\n\treturn 0;\n}\n\nstatic bool add_event_handler(struct hp_wmi_sensors *state)\n{\n\tstruct device *dev = &state->wdev->dev;\n\tint err;\n\n\terr = wmi_install_notify_handler(HP_WMI_EVENT_GUID,\n\t\t\t\t\t hp_wmi_notify, state);\n\tif (err) {\n\t\tdev_info(dev, \"Failed to subscribe to WMI event\\n\");\n\t\treturn false;\n\t}\n\n\terr = devm_add_action_or_reset(dev, hp_wmi_devm_notify_remove, NULL);\n\tif (err)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int hp_wmi_sensors_init(struct hp_wmi_sensors *state)\n{\n\tstruct hp_wmi_info *connected[HP_WMI_MAX_INSTANCES];\n\tstruct hp_wmi_platform_events *pevents = NULL;\n\tstruct device *dev = &state->wdev->dev;\n\tstruct hp_wmi_info *info;\n\tstruct device *hwdev;\n\tbool has_events;\n\tbool is_new;\n\tu8 icount;\n\tu8 pcount;\n\tu8 count;\n\tint err;\n\n\terr = init_platform_events(dev, &pevents, &pcount);\n\tif (err)\n\t\treturn err;\n\n\terr = init_numeric_sensors(state, connected, &info,\n\t\t\t\t   &icount, &count, &is_new);\n\tif (err)\n\t\treturn err;\n\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\thp_wmi_debugfs_init(dev, info, pevents, icount, pcount, is_new);\n\n\tif (!count)\n\t\treturn 0;\t \n\n\thas_events = find_event_attributes(state, pevents, pcount);\n\n\t \n\tif (has_events && !add_event_handler(state))\n\t\thas_events = false;\n\n\terr = make_chip_info(state, has_events);\n\tif (err)\n\t\treturn err;\n\n\thwdev = devm_hwmon_device_register_with_info(dev, \"hp_wmi_sensors\",\n\t\t\t\t\t\t     state, &hp_wmi_chip_info,\n\t\t\t\t\t\t     NULL);\n\treturn PTR_ERR_OR_ZERO(hwdev);\n}\n\nstatic int hp_wmi_sensors_probe(struct wmi_device *wdev, const void *context)\n{\n\tstruct device *dev = &wdev->dev;\n\tstruct hp_wmi_sensors *state;\n\n\tstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->wdev = wdev;\n\n\tmutex_init(&state->lock);\n\n\tdev_set_drvdata(dev, state);\n\n\treturn hp_wmi_sensors_init(state);\n}\n\nstatic const struct wmi_device_id hp_wmi_sensors_id_table[] = {\n\t{ HP_WMI_NUMERIC_SENSOR_GUID, NULL },\n\t{},\n};\n\nstatic struct wmi_driver hp_wmi_sensors_driver = {\n\t.driver   = { .name = \"hp-wmi-sensors\" },\n\t.id_table = hp_wmi_sensors_id_table,\n\t.probe    = hp_wmi_sensors_probe,\n};\nmodule_wmi_driver(hp_wmi_sensors_driver);\n\nMODULE_AUTHOR(\"James Seo <james@equiv.tech>\");\nMODULE_DESCRIPTION(\"HP WMI Sensors driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}