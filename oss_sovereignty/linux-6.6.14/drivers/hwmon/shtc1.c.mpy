{
  "module_name": "shtc1.c",
  "hash_id": "c4a0bb73cacf895f869d3b1cd65ba859f561c9e6b4695166b9a32dd774cb7490",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/shtc1.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/platform_data/shtc1.h>\n#include <linux/of.h>\n\n \nstatic const unsigned char shtc1_cmd_measure_blocking_hpm[]    = { 0x7C, 0xA2 };\nstatic const unsigned char shtc1_cmd_measure_nonblocking_hpm[] = { 0x78, 0x66 };\n\n \nstatic const unsigned char shtc1_cmd_measure_blocking_lpm[]    = { 0x64, 0x58 };\nstatic const unsigned char shtc1_cmd_measure_nonblocking_lpm[] = { 0x60, 0x9c };\n\n \nstatic const unsigned char shtc1_cmd_read_id_reg[]             = { 0xef, 0xc8 };\n\n \n#define SHTC3_ID      0x0807\n#define SHTC3_ID_MASK 0x083f\n#define SHTC1_ID      0x0007\n#define SHTC1_ID_MASK 0x003f\n\n \n#define SHTC1_NONBLOCKING_WAIT_TIME_HPM  14400\n#define SHTC1_NONBLOCKING_WAIT_TIME_LPM   1000\n#define SHTC3_NONBLOCKING_WAIT_TIME_HPM  12100\n#define SHTC3_NONBLOCKING_WAIT_TIME_LPM    800\n\n#define SHTC1_CMD_LENGTH      2\n#define SHTC1_RESPONSE_LENGTH 6\n\nenum shtcx_chips {\n\tshtc1,\n\tshtc3,\n};\n\nstruct shtc1_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tbool valid;\n\tunsigned long last_updated;  \n\n\tconst unsigned char *command;\n\tunsigned int nonblocking_wait_time;  \n\n\tstruct shtc1_platform_data setup;\n\tenum shtcx_chips chip;\n\n\tint temperature;  \n\tint humidity;  \n};\n\nstatic int shtc1_update_values(struct i2c_client *client,\n\t\t\t       struct shtc1_data *data,\n\t\t\t       char *buf, int bufsize)\n{\n\tint ret = i2c_master_send(client, data->command, SHTC1_CMD_LENGTH);\n\tif (ret != SHTC1_CMD_LENGTH) {\n\t\tdev_err(&client->dev, \"failed to send command: %d\\n\", ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\t \n\tif (!data->setup.blocking_io)\n\t\tusleep_range(data->nonblocking_wait_time,\n\t\t\t     data->nonblocking_wait_time + 1000);\n\n\tret = i2c_master_recv(client, buf, bufsize);\n\tif (ret != bufsize) {\n\t\tdev_err(&client->dev, \"failed to read values: %d\\n\", ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct shtc1_data *shtc1_update_client(struct device *dev)\n{\n\tstruct shtc1_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned char buf[SHTC1_RESPONSE_LENGTH];\n\tint val;\n\tint ret = 0;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ / 10) || !data->valid) {\n\t\tret = shtc1_update_values(client, data, buf, sizeof(buf));\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tval = be16_to_cpup((__be16 *)buf);\n\t\tdata->temperature = ((21875 * val) >> 13) - 45000;\n\t\tval = be16_to_cpup((__be16 *)(buf + 3));\n\t\tdata->humidity = ((12500 * val) >> 13);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\nout:\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret == 0 ? data : ERR_PTR(ret);\n}\n\nstatic ssize_t temp1_input_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct shtc1_data *data = shtc1_update_client(dev);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->temperature);\n}\n\nstatic ssize_t humidity1_input_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct shtc1_data *data = shtc1_update_client(dev);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->humidity);\n}\n\nstatic DEVICE_ATTR_RO(temp1_input);\nstatic DEVICE_ATTR_RO(humidity1_input);\n\nstatic struct attribute *shtc1_attrs[] = {\n\t&dev_attr_temp1_input.attr,\n\t&dev_attr_humidity1_input.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(shtc1);\n\nstatic void shtc1_select_command(struct shtc1_data *data)\n{\n\tif (data->setup.high_precision) {\n\t\tdata->command = data->setup.blocking_io ?\n\t\t\t\tshtc1_cmd_measure_blocking_hpm :\n\t\t\t\tshtc1_cmd_measure_nonblocking_hpm;\n\t\tdata->nonblocking_wait_time = (data->chip == shtc1) ?\n\t\t\t\tSHTC1_NONBLOCKING_WAIT_TIME_HPM :\n\t\t\t\tSHTC3_NONBLOCKING_WAIT_TIME_HPM;\n\t} else {\n\t\tdata->command = data->setup.blocking_io ?\n\t\t\t\tshtc1_cmd_measure_blocking_lpm :\n\t\t\t\tshtc1_cmd_measure_nonblocking_lpm;\n\t\tdata->nonblocking_wait_time = (data->chip == shtc1) ?\n\t\t\t\tSHTC1_NONBLOCKING_WAIT_TIME_LPM :\n\t\t\t\tSHTC3_NONBLOCKING_WAIT_TIME_LPM;\n\t}\n}\n\nstatic const struct i2c_device_id shtc1_id[];\n\nstatic int shtc1_probe(struct i2c_client *client)\n{\n\tint ret;\n\tu16 id_reg;\n\tchar id_reg_buf[2];\n\tstruct shtc1_data *data;\n\tstruct device *hwmon_dev;\n\tenum shtcx_chips chip = i2c_match_id(shtc1_id, client)->driver_data;\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = dev->of_node;\n\n\tif (!i2c_check_functionality(adap, I2C_FUNC_I2C)) {\n\t\tdev_err(dev, \"plain i2c transactions not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = i2c_master_send(client, shtc1_cmd_read_id_reg, SHTC1_CMD_LENGTH);\n\tif (ret != SHTC1_CMD_LENGTH) {\n\t\tdev_err(dev, \"could not send read_id_reg command: %d\\n\", ret);\n\t\treturn ret < 0 ? ret : -ENODEV;\n\t}\n\tret = i2c_master_recv(client, id_reg_buf, sizeof(id_reg_buf));\n\tif (ret != sizeof(id_reg_buf)) {\n\t\tdev_err(dev, \"could not read ID register: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\tid_reg = be16_to_cpup((__be16 *)id_reg_buf);\n\tif (chip == shtc3) {\n\t\tif ((id_reg & SHTC3_ID_MASK) != SHTC3_ID) {\n\t\t\tdev_err(dev, \"SHTC3 ID register does not match\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else if ((id_reg & SHTC1_ID_MASK) != SHTC1_ID) {\n\t\tdev_err(dev, \"SHTC1 ID register does not match\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->setup.blocking_io = false;\n\tdata->setup.high_precision = true;\n\tdata->client = client;\n\tdata->chip = chip;\n\n\tif (np) {\n\t\tdata->setup.blocking_io = of_property_read_bool(np, \"sensirion,blocking-io\");\n\t\tdata->setup.high_precision = !of_property_read_bool(np, \"sensicon,low-precision\");\n\t} else {\n\t\tif (client->dev.platform_data)\n\t\t\tdata->setup = *(struct shtc1_platform_data *)dev->platform_data;\n\t}\n\n\tshtc1_select_command(data);\n\tmutex_init(&data->update_lock);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev,\n\t\t\t\t\t\t\t   client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   shtc1_groups);\n\tif (IS_ERR(hwmon_dev))\n\t\tdev_dbg(dev, \"unable to register hwmon device\\n\");\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\n \nstatic const struct i2c_device_id shtc1_id[] = {\n\t{ \"shtc1\", shtc1 },\n\t{ \"shtw1\", shtc1 },\n\t{ \"shtc3\", shtc3 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, shtc1_id);\n\nstatic const struct of_device_id shtc1_of_match[] = {\n\t{ .compatible = \"sensirion,shtc1\" },\n\t{ .compatible = \"sensirion,shtw1\" },\n\t{ .compatible = \"sensirion,shtc3\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, shtc1_of_match);\n\nstatic struct i2c_driver shtc1_i2c_driver = {\n\t.driver = {\n\t\t.name = \"shtc1\",\n\t\t.of_match_table = shtc1_of_match,\n\t},\n\t.probe        = shtc1_probe,\n\t.id_table     = shtc1_id,\n};\n\nmodule_i2c_driver(shtc1_i2c_driver);\n\nMODULE_AUTHOR(\"Johannes Winkelmann <johannes.winkelmann@sensirion.com>\");\nMODULE_DESCRIPTION(\"Sensirion SHTC1 humidity and temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}