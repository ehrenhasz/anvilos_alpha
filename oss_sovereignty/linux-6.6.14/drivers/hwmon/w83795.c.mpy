{
  "module_name": "w83795.c",
  "hash_id": "b96f27bea88a1ac3b5d7a1690ba28fdb5c8713edf4fa053facc3c05c62b762c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/w83795.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/jiffies.h>\n#include <linux/util_macros.h>\n\n \nstatic const unsigned short normal_i2c[] = {\n\t0x2c, 0x2d, 0x2e, 0x2f, I2C_CLIENT_END\n};\n\n\nstatic bool reset;\nmodule_param(reset, bool, 0);\nMODULE_PARM_DESC(reset, \"Set to 1 to reset chip, not recommended\");\n\n\n#define W83795_REG_BANKSEL\t\t0x00\n#define W83795_REG_VENDORID\t\t0xfd\n#define W83795_REG_CHIPID\t\t0xfe\n#define W83795_REG_DEVICEID\t\t0xfb\n#define W83795_REG_DEVICEID_A\t\t0xff\n\n#define W83795_REG_I2C_ADDR\t\t0xfc\n#define W83795_REG_CONFIG\t\t0x01\n#define W83795_REG_CONFIG_CONFIG48\t0x04\n#define W83795_REG_CONFIG_START\t0x01\n\n \n#define W83795_REG_VOLT_CTRL1\t\t0x02\n#define W83795_REG_VOLT_CTRL2\t\t0x03\n#define W83795_REG_TEMP_CTRL1\t\t0x04\n#define W83795_REG_TEMP_CTRL2\t\t0x05\n#define W83795_REG_FANIN_CTRL1\t\t0x06\n#define W83795_REG_FANIN_CTRL2\t\t0x07\n#define W83795_REG_VMIGB_CTRL\t\t0x08\n\n#define TEMP_READ\t\t\t0\n#define TEMP_CRIT\t\t\t1\n#define TEMP_CRIT_HYST\t\t\t2\n#define TEMP_WARN\t\t\t3\n#define TEMP_WARN_HYST\t\t\t4\n \nstatic const u16 W83795_REG_TEMP[][5] = {\n\t{0x21, 0x96, 0x97, 0x98, 0x99},\t \n\t{0x22, 0x9a, 0x9b, 0x9c, 0x9d},\t \n\t{0x23, 0x9e, 0x9f, 0xa0, 0xa1},\t \n\t{0x24, 0xa2, 0xa3, 0xa4, 0xa5},\t \n\t{0x1f, 0xa6, 0xa7, 0xa8, 0xa9},\t \n\t{0x20, 0xaa, 0xab, 0xac, 0xad},\t \n};\n\n#define IN_READ\t\t\t\t0\n#define IN_MAX\t\t\t\t1\n#define IN_LOW\t\t\t\t2\nstatic const u16 W83795_REG_IN[][3] = {\n\t \n\t{0x10, 0x70, 0x71},\t \n\t{0x11, 0x72, 0x73},\t \n\t{0x12, 0x74, 0x75},\t \n\t{0x13, 0x76, 0x77},\t \n\t{0x14, 0x78, 0x79},\t \n\t{0x15, 0x7a, 0x7b},\t \n\t{0x16, 0x7c, 0x7d},\t \n\t{0x17, 0x7e, 0x7f},\t \n\t{0x18, 0x80, 0x81},\t \n\t{0x19, 0x82, 0x83},\t \n\t{0x1A, 0x84, 0x85},\t \n\t{0x1B, 0x86, 0x87},\t \n\t{0x1C, 0x88, 0x89},\t \n\t{0x1D, 0x8a, 0x8b},\t \n\t{0x1E, 0x8c, 0x8d},\t \n\t{0x1F, 0xa6, 0xa7},\t \n\t{0x20, 0xaa, 0xab},\t \n\t{0x21, 0x96, 0x97},\t \n\t{0x22, 0x9a, 0x9b},\t \n\t{0x23, 0x9e, 0x9f},\t \n\t{0x24, 0xa2, 0xa3},\t \n};\n#define W83795_REG_VRLSB\t\t0x3C\n\nstatic const u8 W83795_REG_IN_HL_LSB[] = {\n\t0x8e,\t \n\t0x90,\t \n\t0x92,\t \n\t0x94,\t \n\t0xa8,\t \n\t0xac,\t \n\t0x98,\t \n\t0x9c,\t \n\t0xa0,\t \n\t0xa4,\t \n};\n\n#define IN_LSB_REG(index, type) \\\n\t(((type) == 1) ? W83795_REG_IN_HL_LSB[(index)] \\\n\t: (W83795_REG_IN_HL_LSB[(index)] + 1))\n\n#define IN_LSB_SHIFT\t\t\t0\n#define IN_LSB_IDX\t\t\t1\nstatic const u8 IN_LSB_SHIFT_IDX[][2] = {\n\t \n\t{0x00, 0x00},\t \n\t{0x02, 0x00},\t \n\t{0x04, 0x00},\t \n\t{0x06, 0x00},\t \n\t{0x00, 0x01},\t \n\t{0x02, 0x01},\t \n\t{0x04, 0x01},\t \n\t{0x06, 0x01},\t \n\t{0x00, 0x02},\t \n\t{0x02, 0x02},\t \n\t{0x04, 0x02},\t \n\t{0x00, 0x03},\t \n\t{0x02, 0x03},\t \n\t{0x04, 0x03},\t \n\t{0x06, 0x03},\t \n\t{0x06, 0x04},\t \n\t{0x06, 0x05},\t \n\t{0x06, 0x06},\t \n\t{0x06, 0x07},\t \n\t{0x06, 0x08},\t \n\t{0x06, 0x09},\t \n};\n\n\n#define W83795_REG_FAN(index)\t\t(0x2E + (index))\n#define W83795_REG_FAN_MIN_HL(index)\t(0xB6 + (index))\n#define W83795_REG_FAN_MIN_LSB(index)\t(0xC4 + (index) / 2)\n#define W83795_REG_FAN_MIN_LSB_SHIFT(index) \\\n\t(((index) & 1) ? 4 : 0)\n\n#define W83795_REG_VID_CTRL\t\t0x6A\n\n#define W83795_REG_ALARM_CTRL\t\t0x40\n#define ALARM_CTRL_RTSACS\t\t(1 << 7)\n#define W83795_REG_ALARM(index)\t\t(0x41 + (index))\n#define W83795_REG_CLR_CHASSIS\t\t0x4D\n#define W83795_REG_BEEP(index)\t\t(0x50 + (index))\n\n#define W83795_REG_OVT_CFG\t\t0x58\n#define OVT_CFG_SEL\t\t\t(1 << 7)\n\n\n#define W83795_REG_FCMS1\t\t0x201\n#define W83795_REG_FCMS2\t\t0x208\n#define W83795_REG_TFMR(index)\t\t(0x202 + (index))\n#define W83795_REG_FOMC\t\t\t0x20F\n\n#define W83795_REG_TSS(index)\t\t(0x209 + (index))\n\n#define TSS_MAP_RESERVED\t\t0xff\nstatic const u8 tss_map[4][6] = {\n\t{ 0,  1,  2,  3,  4,  5},\n\t{ 6,  7,  8,  9,  0,  1},\n\t{10, 11, 12, 13,  2,  3},\n\t{ 4,  5,  4,  5, TSS_MAP_RESERVED, TSS_MAP_RESERVED},\n};\n\n#define PWM_OUTPUT\t\t\t0\n#define PWM_FREQ\t\t\t1\n#define PWM_START\t\t\t2\n#define PWM_NONSTOP\t\t\t3\n#define PWM_STOP_TIME\t\t\t4\n#define W83795_REG_PWM(index, nr)\t(0x210 + (nr) * 8 + (index))\n\n#define W83795_REG_FTSH(index)\t\t(0x240 + (index) * 2)\n#define W83795_REG_FTSL(index)\t\t(0x241 + (index) * 2)\n#define W83795_REG_TFTS\t\t\t0x250\n\n#define TEMP_PWM_TTTI\t\t\t0\n#define TEMP_PWM_CTFS\t\t\t1\n#define TEMP_PWM_HCT\t\t\t2\n#define TEMP_PWM_HOT\t\t\t3\n#define W83795_REG_TTTI(index)\t\t(0x260 + (index))\n#define W83795_REG_CTFS(index)\t\t(0x268 + (index))\n#define W83795_REG_HT(index)\t\t(0x270 + (index))\n\n#define SF4_TEMP\t\t\t0\n#define SF4_PWM\t\t\t\t1\n#define W83795_REG_SF4_TEMP(temp_num, index) \\\n\t(0x280 + 0x10 * (temp_num) + (index))\n#define W83795_REG_SF4_PWM(temp_num, index) \\\n\t(0x288 + 0x10 * (temp_num) + (index))\n\n#define W83795_REG_DTSC\t\t\t0x301\n#define W83795_REG_DTSE\t\t\t0x302\n#define W83795_REG_DTS(index)\t\t(0x26 + (index))\n#define W83795_REG_PECI_TBASE(index)\t(0x320 + (index))\n\n#define DTS_CRIT\t\t\t0\n#define DTS_CRIT_HYST\t\t\t1\n#define DTS_WARN\t\t\t2\n#define DTS_WARN_HYST\t\t\t3\n#define W83795_REG_DTS_EXT(index)\t(0xB2 + (index))\n\n#define SETUP_PWM_DEFAULT\t\t0\n#define SETUP_PWM_UPTIME\t\t1\n#define SETUP_PWM_DOWNTIME\t\t2\n#define W83795_REG_SETUP_PWM(index)    (0x20C + (index))\n\nstatic inline u16 in_from_reg(u8 index, u16 val)\n{\n\t \n\tif (index >= 12 && index <= 14)\n\t\treturn val * 6;\n\telse\n\t\treturn val * 2;\n}\n\nstatic inline u16 in_to_reg(u8 index, u16 val)\n{\n\tif (index >= 12 && index <= 14)\n\t\treturn val / 6;\n\telse\n\t\treturn val / 2;\n}\n\nstatic inline unsigned long fan_from_reg(u16 val)\n{\n\tif ((val == 0xfff) || (val == 0))\n\t\treturn 0;\n\treturn 1350000UL / val;\n}\n\nstatic inline u16 fan_to_reg(long rpm)\n{\n\tif (rpm <= 0)\n\t\treturn 0x0fff;\n\treturn clamp_val((1350000 + (rpm >> 1)) / rpm, 1, 0xffe);\n}\n\nstatic inline unsigned long time_from_reg(u8 reg)\n{\n\treturn reg * 100;\n}\n\nstatic inline u8 time_to_reg(unsigned long val)\n{\n\treturn clamp_val((val + 50) / 100, 0, 0xff);\n}\n\nstatic inline long temp_from_reg(s8 reg)\n{\n\treturn reg * 1000;\n}\n\nstatic inline s8 temp_to_reg(long val, s8 min, s8 max)\n{\n\treturn clamp_val(val / 1000, min, max);\n}\n\nstatic const u16 pwm_freq_cksel0[16] = {\n\t1024, 512, 341, 256, 205, 171, 146, 128,\n\t85, 64, 32, 16, 8, 4, 2, 1\n};\n\nstatic unsigned int pwm_freq_from_reg(u8 reg, u16 clkin)\n{\n\tunsigned long base_clock;\n\n\tif (reg & 0x80) {\n\t\tbase_clock = clkin * 1000 / ((clkin == 48000) ? 384 : 256);\n\t\treturn base_clock / ((reg & 0x7f) + 1);\n\t} else\n\t\treturn pwm_freq_cksel0[reg & 0x0f];\n}\n\nstatic u8 pwm_freq_to_reg(unsigned long val, u16 clkin)\n{\n\tunsigned long base_clock;\n\tu8 reg0, reg1;\n\tunsigned long best0, best1;\n\n\t \n\treg0 = find_closest_descending(val, pwm_freq_cksel0,\n\t\t\t\t       ARRAY_SIZE(pwm_freq_cksel0));\n\tif (val < 375)\t \n\t\treturn reg0;\n\tbest0 = pwm_freq_cksel0[reg0];\n\n\t \n\tbase_clock = clkin * 1000 / ((clkin == 48000) ? 384 : 256);\n\treg1 = clamp_val(DIV_ROUND_CLOSEST(base_clock, val), 1, 128);\n\tbest1 = base_clock / reg1;\n\treg1 = 0x80 | (reg1 - 1);\n\n\t \n\tif (abs(val - best0) > abs(val - best1))\n\t\treturn reg1;\n\telse\n\t\treturn reg0;\n}\n\nenum chip_types {w83795g, w83795adg};\n\nstruct w83795_data {\n\tstruct device *hwmon_dev;\n\tstruct mutex update_lock;\n\tunsigned long last_updated;\t \n\tenum chip_types chip_type;\n\n\tu8 bank;\n\n\tu32 has_in;\t\t \n\tu8 has_dyn_in;\t\t \n\tu16 in[21][3];\t\t \n\tu8 in_lsb[10][3];\t \n\tu8 has_gain;\t\t \n\n\tu16 has_fan;\t\t \n\tu16 fan[14];\t\t \n\tu16 fan_min[14];\t \n\n\tu8 has_temp;\t\t \n\ts8 temp[6][5];\t\t \n\tu8 temp_read_vrlsb[6];\n\tu8 temp_mode;\t\t \n\tu8 temp_src[3];\t\t \n\n\tu8 enable_dts;\t\t \n\tu8 has_dts;\t\t \n\ts8 dts[8];\t\t \n\tu8 dts_read_vrlsb[8];\t \n\ts8 dts_ext[4];\t\t \n\n\tu8 has_pwm;\t\t \n\tu8 pwm[8][5];\t\t \n\tu16 clkin;\t\t \n\tu8 pwm_fcms[2];\t\t \n\tu8 pwm_tfmr[6];\t\t \n\tu8 pwm_fomc;\t\t \n\n\tu16 target_speed[8];\t \n\tu8 tol_speed;\t\t \n\tu8 pwm_temp[6][4];\t \n\tu8 sf4_reg[6][2][7];\t \n\n\tu8 setup_pwm[3];\t \n\n\tu8 alarms[6];\t\t \n\tu8 enable_beep;\n\tu8 beeps[6];\t\t \n\n\tbool valid;\n\tchar valid_limits;\n\tchar valid_pwm_config;\n};\n\n \n\n \nstatic int w83795_set_bank(struct i2c_client *client, u8 bank)\n{\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tint err;\n\n\t \n\tif ((data->bank & 0x07) == bank)\n\t\treturn 0;\n\n\t \n\tbank |= data->bank & ~0x07;\n\terr = i2c_smbus_write_byte_data(client, W83795_REG_BANKSEL, bank);\n\tif (err < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to set bank to %d, err %d\\n\",\n\t\t\t(int)bank, err);\n\t\treturn err;\n\t}\n\tdata->bank = bank;\n\n\treturn 0;\n}\n\n \nstatic u8 w83795_read(struct i2c_client *client, u16 reg)\n{\n\tint err;\n\n\terr = w83795_set_bank(client, reg >> 8);\n\tif (err < 0)\n\t\treturn 0x00;\t \n\n\terr = i2c_smbus_read_byte_data(client, reg & 0xff);\n\tif (err < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to read from register 0x%03x, err %d\\n\",\n\t\t\t(int)reg, err);\n\t\treturn 0x00;\t \n\t}\n\treturn err;\n}\n\n \nstatic int w83795_write(struct i2c_client *client, u16 reg, u8 value)\n{\n\tint err;\n\n\terr = w83795_set_bank(client, reg >> 8);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = i2c_smbus_write_byte_data(client, reg & 0xff, value);\n\tif (err < 0)\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to write to register 0x%03x, err %d\\n\",\n\t\t\t(int)reg, err);\n\treturn err;\n}\n\nstatic void w83795_update_limits(struct i2c_client *client)\n{\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tint i, limit;\n\tu8 lsb;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->in); i++) {\n\t\tif (!(data->has_in & (1 << i)))\n\t\t\tcontinue;\n\t\tdata->in[i][IN_MAX] =\n\t\t\tw83795_read(client, W83795_REG_IN[i][IN_MAX]);\n\t\tdata->in[i][IN_LOW] =\n\t\t\tw83795_read(client, W83795_REG_IN[i][IN_LOW]);\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(data->in_lsb); i++) {\n\t\tif ((i == 2 && data->chip_type == w83795adg) ||\n\t\t    (i >= 4 && !(data->has_in & (1 << (i + 11)))))\n\t\t\tcontinue;\n\t\tdata->in_lsb[i][IN_MAX] =\n\t\t\tw83795_read(client, IN_LSB_REG(i, IN_MAX));\n\t\tdata->in_lsb[i][IN_LOW] =\n\t\t\tw83795_read(client, IN_LSB_REG(i, IN_LOW));\n\t}\n\n\t \n\tlsb = 0;  \n\tfor (i = 0; i < ARRAY_SIZE(data->fan); i++) {\n\t\t \n\t\tif ((i & 1) == 0 && (data->has_fan & (3 << i)))\n\t\t\tlsb = w83795_read(client, W83795_REG_FAN_MIN_LSB(i));\n\n\t\tif (!(data->has_fan & (1 << i)))\n\t\t\tcontinue;\n\t\tdata->fan_min[i] =\n\t\t\tw83795_read(client, W83795_REG_FAN_MIN_HL(i)) << 4;\n\t\tdata->fan_min[i] |=\n\t\t\t(lsb >> W83795_REG_FAN_MIN_LSB_SHIFT(i)) & 0x0F;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->temp); i++) {\n\t\tif (!(data->has_temp & (1 << i)))\n\t\t\tcontinue;\n\t\tfor (limit = TEMP_CRIT; limit <= TEMP_WARN_HYST; limit++)\n\t\t\tdata->temp[i][limit] =\n\t\t\t\tw83795_read(client, W83795_REG_TEMP[i][limit]);\n\t}\n\n\t \n\tif (data->enable_dts) {\n\t\tfor (limit = DTS_CRIT; limit <= DTS_WARN_HYST; limit++)\n\t\t\tdata->dts_ext[limit] =\n\t\t\t\tw83795_read(client, W83795_REG_DTS_EXT(limit));\n\t}\n\n\t \n\tif (data->enable_beep) {\n\t\tfor (i = 0; i < ARRAY_SIZE(data->beeps); i++)\n\t\t\tdata->beeps[i] =\n\t\t\t\tw83795_read(client, W83795_REG_BEEP(i));\n\t}\n\n\tdata->valid_limits = 1;\n}\n\nstatic struct w83795_data *w83795_update_pwm_config(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tint i, tmp;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (data->valid_pwm_config)\n\t\tgoto END;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->temp_src); i++)\n\t\tdata->temp_src[i] = w83795_read(client, W83795_REG_TSS(i));\n\n\t \n\tdata->pwm_fcms[0] = w83795_read(client, W83795_REG_FCMS1);\n\tdata->pwm_fcms[1] = w83795_read(client, W83795_REG_FCMS2);\n\tfor (i = 0; i < ARRAY_SIZE(data->pwm_tfmr); i++)\n\t\tdata->pwm_tfmr[i] = w83795_read(client, W83795_REG_TFMR(i));\n\tdata->pwm_fomc = w83795_read(client, W83795_REG_FOMC);\n\tfor (i = 0; i < data->has_pwm; i++) {\n\t\tfor (tmp = PWM_FREQ; tmp <= PWM_STOP_TIME; tmp++)\n\t\t\tdata->pwm[i][tmp] =\n\t\t\t\tw83795_read(client, W83795_REG_PWM(i, tmp));\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(data->target_speed); i++) {\n\t\tdata->target_speed[i] =\n\t\t\tw83795_read(client, W83795_REG_FTSH(i)) << 4;\n\t\tdata->target_speed[i] |=\n\t\t\tw83795_read(client, W83795_REG_FTSL(i)) >> 4;\n\t}\n\tdata->tol_speed = w83795_read(client, W83795_REG_TFTS) & 0x3f;\n\n\tfor (i = 0; i < ARRAY_SIZE(data->pwm_temp); i++) {\n\t\tdata->pwm_temp[i][TEMP_PWM_TTTI] =\n\t\t\tw83795_read(client, W83795_REG_TTTI(i)) & 0x7f;\n\t\tdata->pwm_temp[i][TEMP_PWM_CTFS] =\n\t\t\tw83795_read(client, W83795_REG_CTFS(i));\n\t\ttmp = w83795_read(client, W83795_REG_HT(i));\n\t\tdata->pwm_temp[i][TEMP_PWM_HCT] = tmp >> 4;\n\t\tdata->pwm_temp[i][TEMP_PWM_HOT] = tmp & 0x0f;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->sf4_reg); i++) {\n\t\tfor (tmp = 0; tmp < 7; tmp++) {\n\t\t\tdata->sf4_reg[i][SF4_TEMP][tmp] =\n\t\t\t\tw83795_read(client,\n\t\t\t\t\t    W83795_REG_SF4_TEMP(i, tmp));\n\t\t\tdata->sf4_reg[i][SF4_PWM][tmp] =\n\t\t\t\tw83795_read(client, W83795_REG_SF4_PWM(i, tmp));\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->setup_pwm); i++)\n\t\tdata->setup_pwm[i] =\n\t\t\tw83795_read(client, W83795_REG_SETUP_PWM(i));\n\n\tdata->valid_pwm_config = 1;\n\nEND:\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n}\n\nstatic struct w83795_data *w83795_update_device(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tu16 tmp;\n\tu8 intrusion;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (!data->valid_limits)\n\t\tw83795_update_limits(client);\n\n\tif (!(time_after(jiffies, data->last_updated + HZ * 2)\n\t      || !data->valid))\n\t\tgoto END;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->in); i++) {\n\t\tif (!(data->has_in & (1 << i)))\n\t\t\tcontinue;\n\t\ttmp = w83795_read(client, W83795_REG_IN[i][IN_READ]) << 2;\n\t\ttmp |= w83795_read(client, W83795_REG_VRLSB) >> 6;\n\t\tdata->in[i][IN_READ] = tmp;\n\t}\n\n\t \n\tif (data->has_dyn_in) {\n\t\tu8 lsb_max = w83795_read(client, IN_LSB_REG(0, IN_MAX));\n\t\tu8 lsb_low = w83795_read(client, IN_LSB_REG(0, IN_LOW));\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (!(data->has_dyn_in & (1 << i)))\n\t\t\t\tcontinue;\n\t\t\tdata->in[i][IN_MAX] =\n\t\t\t\tw83795_read(client, W83795_REG_IN[i][IN_MAX]);\n\t\t\tdata->in[i][IN_LOW] =\n\t\t\t\tw83795_read(client, W83795_REG_IN[i][IN_LOW]);\n\t\t\tdata->in_lsb[i][IN_MAX] = (lsb_max >> (2 * i)) & 0x03;\n\t\t\tdata->in_lsb[i][IN_LOW] = (lsb_low >> (2 * i)) & 0x03;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->fan); i++) {\n\t\tif (!(data->has_fan & (1 << i)))\n\t\t\tcontinue;\n\t\tdata->fan[i] = w83795_read(client, W83795_REG_FAN(i)) << 4;\n\t\tdata->fan[i] |= w83795_read(client, W83795_REG_VRLSB) >> 4;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->temp); i++) {\n\t\tdata->temp[i][TEMP_READ] =\n\t\t\tw83795_read(client, W83795_REG_TEMP[i][TEMP_READ]);\n\t\tdata->temp_read_vrlsb[i] =\n\t\t\tw83795_read(client, W83795_REG_VRLSB);\n\t}\n\n\t \n\tif (data->enable_dts) {\n\t\tfor (i = 0; i < ARRAY_SIZE(data->dts); i++) {\n\t\t\tif (!(data->has_dts & (1 << i)))\n\t\t\t\tcontinue;\n\t\t\tdata->dts[i] =\n\t\t\t\tw83795_read(client, W83795_REG_DTS(i));\n\t\t\tdata->dts_read_vrlsb[i] =\n\t\t\t\tw83795_read(client, W83795_REG_VRLSB);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < data->has_pwm; i++) {\n\t\tdata->pwm[i][PWM_OUTPUT] =\n\t\t    w83795_read(client, W83795_REG_PWM(i, PWM_OUTPUT));\n\t}\n\n\t \n\ttmp = w83795_read(client, W83795_REG_ALARM_CTRL);\n\t \n\tif (tmp & ALARM_CTRL_RTSACS)\n\t\tw83795_write(client, W83795_REG_ALARM_CTRL,\n\t\t\t     tmp & ~ALARM_CTRL_RTSACS);\n\tintrusion = w83795_read(client, W83795_REG_ALARM(5)) & (1 << 6);\n\t \n\tw83795_write(client, W83795_REG_ALARM_CTRL, tmp | ALARM_CTRL_RTSACS);\n\tfor (i = 0; i < ARRAY_SIZE(data->alarms); i++)\n\t\tdata->alarms[i] = w83795_read(client, W83795_REG_ALARM(i));\n\tdata->alarms[5] |= intrusion;\n\t \n\tif (!(tmp & ALARM_CTRL_RTSACS))\n\t\tw83795_write(client, W83795_REG_ALARM_CTRL,\n\t\t\t     tmp & ~ALARM_CTRL_RTSACS);\n\n\tdata->last_updated = jiffies;\n\tdata->valid = true;\n\nEND:\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n}\n\n \n\n#define ALARM_STATUS      0\n#define BEEP_ENABLE       1\nstatic ssize_t\nshow_alarm_beep(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83795_data *data = w83795_update_device(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index >> 3;\n\tint bit = sensor_attr->index & 0x07;\n\tu8 val;\n\n\tif (nr == ALARM_STATUS)\n\t\tval = (data->alarms[index] >> bit) & 1;\n\telse\t\t \n\t\tval = (data->beeps[index] >> bit) & 1;\n\n\treturn sprintf(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t\nstore_beep(struct device *dev, struct device_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint index = sensor_attr->index >> 3;\n\tint shift = sensor_attr->index & 0x07;\n\tu8 beep_bit = 1 << shift;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->beeps[index] = w83795_read(client, W83795_REG_BEEP(index));\n\tdata->beeps[index] &= ~beep_bit;\n\tdata->beeps[index] |= val << shift;\n\tw83795_write(client, W83795_REG_BEEP(index), data->beeps[index]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \nstatic ssize_t\nstore_chassis_clear(struct device *dev,\n\t\t    struct device_attribute *attr, const char *buf,\n\t\t    size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val) < 0 || val != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tval = w83795_read(client, W83795_REG_CLR_CHASSIS);\n\tval |= 0x80;\n\tw83795_write(client, W83795_REG_CLR_CHASSIS, val);\n\n\t \n\tw83795_read(client, W83795_REG_ALARM(5));\n\tdata->valid = false;\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n#define FAN_INPUT     0\n#define FAN_MIN       1\nstatic ssize_t\nshow_fan(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83795_data *data = w83795_update_device(dev);\n\tu16 val;\n\n\tif (nr == FAN_INPUT)\n\t\tval = data->fan[index] & 0x0fff;\n\telse\n\t\tval = data->fan_min[index] & 0x0fff;\n\n\treturn sprintf(buf, \"%lu\\n\", fan_from_reg(val));\n}\n\nstatic ssize_t\nstore_fan_min(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint index = sensor_attr->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\tval = fan_to_reg(val);\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_min[index] = val;\n\tw83795_write(client, W83795_REG_FAN_MIN_HL(index), (val >> 4) & 0xff);\n\tval &= 0x0f;\n\tif (index & 1) {\n\t\tval <<= 4;\n\t\tval |= w83795_read(client, W83795_REG_FAN_MIN_LSB(index))\n\t\t       & 0x0f;\n\t} else {\n\t\tval |= w83795_read(client, W83795_REG_FAN_MIN_LSB(index))\n\t\t       & 0xf0;\n\t}\n\tw83795_write(client, W83795_REG_FAN_MIN_LSB(index), val & 0xff);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_pwm(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83795_data *data;\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tunsigned int val;\n\n\tdata = nr == PWM_OUTPUT ? w83795_update_device(dev)\n\t\t\t\t: w83795_update_pwm_config(dev);\n\n\tswitch (nr) {\n\tcase PWM_STOP_TIME:\n\t\tval = time_from_reg(data->pwm[index][nr]);\n\t\tbreak;\n\tcase PWM_FREQ:\n\t\tval = pwm_freq_from_reg(data->pwm[index][nr], data->clkin);\n\t\tbreak;\n\tdefault:\n\t\tval = data->pwm[index][nr];\n\t\tbreak;\n\t}\n\n\treturn sprintf(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t\nstore_pwm(struct device *dev, struct device_attribute *attr,\n\t  const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (nr) {\n\tcase PWM_STOP_TIME:\n\t\tval = time_to_reg(val);\n\t\tbreak;\n\tcase PWM_FREQ:\n\t\tval = pwm_freq_to_reg(val, data->clkin);\n\t\tbreak;\n\tdefault:\n\t\tval = clamp_val(val, 0, 0xff);\n\t\tbreak;\n\t}\n\tw83795_write(client, W83795_REG_PWM(index, nr), val);\n\tdata->pwm[index][nr] = val;\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\nshow_pwm_enable(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tstruct w83795_data *data = w83795_update_pwm_config(dev);\n\tint index = sensor_attr->index;\n\tu8 tmp;\n\n\t \n\tif (data->pwm_fcms[0] & (1 << index)) {\n\t\ttmp = 2;\n\t\tgoto out;\n\t}\n\t \n\tfor (tmp = 0; tmp < 6; tmp++) {\n\t\tif (data->pwm_tfmr[tmp] & (1 << index)) {\n\t\t\ttmp = 3;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\ttmp = 1;\n\nout:\n\treturn sprintf(buf, \"%u\\n\", tmp);\n}\n\nstatic ssize_t\nstore_pwm_enable(struct device *dev, struct device_attribute *attr,\n\t  const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = w83795_update_pwm_config(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint index = sensor_attr->index;\n\tunsigned long val;\n\tint i;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\tif (val < 1 || val > 2)\n\t\treturn -EINVAL;\n\n#ifndef CONFIG_SENSORS_W83795_FANCTRL\n\tif (val > 1) {\n\t\tdev_warn(dev, \"Automatic fan speed control support disabled\\n\");\n\t\tdev_warn(dev, \"Build with CONFIG_SENSORS_W83795_FANCTRL=y if you want it\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n#endif\n\n\tmutex_lock(&data->update_lock);\n\tswitch (val) {\n\tcase 1:\n\t\t \n\t\tdata->pwm_fcms[0] &= ~(1 << index);\n\t\tw83795_write(client, W83795_REG_FCMS1, data->pwm_fcms[0]);\n\t\t \n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tdata->pwm_tfmr[i] &= ~(1 << index);\n\t\t\tw83795_write(client, W83795_REG_TFMR(i),\n\t\t\t\tdata->pwm_tfmr[i]);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tdata->pwm_fcms[0] |= (1 << index);\n\t\tw83795_write(client, W83795_REG_FCMS1, data->pwm_fcms[0]);\n\t\tbreak;\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t\nshow_pwm_mode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83795_data *data = w83795_update_pwm_config(dev);\n\tint index = to_sensor_dev_attr_2(attr)->index;\n\tunsigned int mode;\n\n\tif (data->pwm_fomc & (1 << index))\n\t\tmode = 0;\t \n\telse\n\t\tmode = 1;\t \n\n\treturn sprintf(buf, \"%u\\n\", mode);\n}\n\n \nstatic int w83795_tss_useful(const struct w83795_data *data, int tsrc)\n{\n\tint useful = 0, i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (tss_map[i][tsrc] == TSS_MAP_RESERVED)\n\t\t\tcontinue;\n\t\tif (tss_map[i][tsrc] < 6)\t \n\t\t\tuseful += (data->has_temp >> tss_map[i][tsrc]) & 1;\n\t\telse\t\t\t\t \n\t\t\tuseful += (data->has_dts >> (tss_map[i][tsrc] - 6)) & 1;\n\t}\n\n\treturn useful;\n}\n\nstatic ssize_t\nshow_temp_src(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tstruct w83795_data *data = w83795_update_pwm_config(dev);\n\tint index = sensor_attr->index;\n\tu8 tmp = data->temp_src[index / 2];\n\n\tif (index & 1)\n\t\ttmp >>= 4;\t \n\telse\n\t\ttmp &= 0x0f;\t \n\n\t \n\tif (tmp >= 4 || tss_map[tmp][index] == TSS_MAP_RESERVED)\n\t\treturn -EINVAL;\t\t \n\n\treturn sprintf(buf, \"%u\\n\", (unsigned int)tss_map[tmp][index] + 1);\n}\n\nstatic ssize_t\nstore_temp_src(struct device *dev, struct device_attribute *attr,\n\t  const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = w83795_update_pwm_config(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint index = sensor_attr->index;\n\tint tmp;\n\tunsigned long channel;\n\tu8 val = index / 2;\n\n\tif (kstrtoul(buf, 10, &channel) < 0 ||\n\t    channel < 1 || channel > 14)\n\t\treturn -EINVAL;\n\n\t \n\tfor (tmp = 0; tmp < 4; tmp++) {\n\t\tif (tss_map[tmp][index] == channel - 1)\n\t\t\tbreak;\n\t}\n\tif (tmp == 4)\t \n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tif (index & 1) {\n\t\ttmp <<= 4;\n\t\tdata->temp_src[val] &= 0x0f;\n\t} else {\n\t\tdata->temp_src[val] &= 0xf0;\n\t}\n\tdata->temp_src[val] |= tmp;\n\tw83795_write(client, W83795_REG_TSS(val), data->temp_src[val]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n#define TEMP_PWM_ENABLE   0\n#define TEMP_PWM_FAN_MAP  1\nstatic ssize_t\nshow_temp_pwm_enable(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct w83795_data *data = w83795_update_pwm_config(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tu8 tmp = 0xff;\n\n\tswitch (nr) {\n\tcase TEMP_PWM_ENABLE:\n\t\ttmp = (data->pwm_fcms[1] >> index) & 1;\n\t\tif (tmp)\n\t\t\ttmp = 4;\n\t\telse\n\t\t\ttmp = 3;\n\t\tbreak;\n\tcase TEMP_PWM_FAN_MAP:\n\t\ttmp = data->pwm_tfmr[index];\n\t\tbreak;\n\t}\n\n\treturn sprintf(buf, \"%u\\n\", tmp);\n}\n\nstatic ssize_t\nstore_temp_pwm_enable(struct device *dev, struct device_attribute *attr,\n\t  const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = w83795_update_pwm_config(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tunsigned long tmp;\n\n\tif (kstrtoul(buf, 10, &tmp) < 0)\n\t\treturn -EINVAL;\n\n\tswitch (nr) {\n\tcase TEMP_PWM_ENABLE:\n\t\tif (tmp != 3 && tmp != 4)\n\t\t\treturn -EINVAL;\n\t\ttmp -= 3;\n\t\tmutex_lock(&data->update_lock);\n\t\tdata->pwm_fcms[1] &= ~(1 << index);\n\t\tdata->pwm_fcms[1] |= tmp << index;\n\t\tw83795_write(client, W83795_REG_FCMS2, data->pwm_fcms[1]);\n\t\tmutex_unlock(&data->update_lock);\n\t\tbreak;\n\tcase TEMP_PWM_FAN_MAP:\n\t\tmutex_lock(&data->update_lock);\n\t\ttmp = clamp_val(tmp, 0, 0xff);\n\t\tw83795_write(client, W83795_REG_TFMR(index), tmp);\n\t\tdata->pwm_tfmr[index] = tmp;\n\t\tmutex_unlock(&data->update_lock);\n\t\tbreak;\n\t}\n\treturn count;\n}\n\n#define FANIN_TARGET   0\n#define FANIN_TOL      1\nstatic ssize_t\nshow_fanin(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83795_data *data = w83795_update_pwm_config(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tu16 tmp = 0;\n\n\tswitch (nr) {\n\tcase FANIN_TARGET:\n\t\ttmp = fan_from_reg(data->target_speed[index]);\n\t\tbreak;\n\tcase FANIN_TOL:\n\t\ttmp = data->tol_speed;\n\t\tbreak;\n\t}\n\n\treturn sprintf(buf, \"%u\\n\", tmp);\n}\n\nstatic ssize_t\nstore_fanin(struct device *dev, struct device_attribute *attr,\n\t  const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (nr) {\n\tcase FANIN_TARGET:\n\t\tval = fan_to_reg(clamp_val(val, 0, 0xfff));\n\t\tw83795_write(client, W83795_REG_FTSH(index), val >> 4);\n\t\tw83795_write(client, W83795_REG_FTSL(index), (val << 4) & 0xf0);\n\t\tdata->target_speed[index] = val;\n\t\tbreak;\n\tcase FANIN_TOL:\n\t\tval = clamp_val(val, 0, 0x3f);\n\t\tw83795_write(client, W83795_REG_TFTS, val);\n\t\tdata->tol_speed = val;\n\t\tbreak;\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n\nstatic ssize_t\nshow_temp_pwm(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83795_data *data = w83795_update_pwm_config(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tlong tmp = temp_from_reg(data->pwm_temp[index][nr]);\n\n\treturn sprintf(buf, \"%ld\\n\", tmp);\n}\n\nstatic ssize_t\nstore_temp_pwm(struct device *dev, struct device_attribute *attr,\n\t  const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tunsigned long val;\n\tu8 tmp;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\tval /= 1000;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (nr) {\n\tcase TEMP_PWM_TTTI:\n\t\tval = clamp_val(val, 0, 0x7f);\n\t\tw83795_write(client, W83795_REG_TTTI(index), val);\n\t\tbreak;\n\tcase TEMP_PWM_CTFS:\n\t\tval = clamp_val(val, 0, 0x7f);\n\t\tw83795_write(client, W83795_REG_CTFS(index), val);\n\t\tbreak;\n\tcase TEMP_PWM_HCT:\n\t\tval = clamp_val(val, 0, 0x0f);\n\t\ttmp = w83795_read(client, W83795_REG_HT(index));\n\t\ttmp &= 0x0f;\n\t\ttmp |= (val << 4) & 0xf0;\n\t\tw83795_write(client, W83795_REG_HT(index), tmp);\n\t\tbreak;\n\tcase TEMP_PWM_HOT:\n\t\tval = clamp_val(val, 0, 0x0f);\n\t\ttmp = w83795_read(client, W83795_REG_HT(index));\n\t\ttmp &= 0xf0;\n\t\ttmp |= val & 0x0f;\n\t\tw83795_write(client, W83795_REG_HT(index), tmp);\n\t\tbreak;\n\t}\n\tdata->pwm_temp[index][nr] = val;\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_sf4_pwm(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83795_data *data = w83795_update_pwm_config(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\n\treturn sprintf(buf, \"%u\\n\", data->sf4_reg[index][SF4_PWM][nr]);\n}\n\nstatic ssize_t\nstore_sf4_pwm(struct device *dev, struct device_attribute *attr,\n\t  const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tw83795_write(client, W83795_REG_SF4_PWM(index, nr), val);\n\tdata->sf4_reg[index][SF4_PWM][nr] = val;\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_sf4_temp(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83795_data *data = w83795_update_pwm_config(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t(data->sf4_reg[index][SF4_TEMP][nr]) * 1000);\n}\n\nstatic ssize_t\nstore_sf4_temp(struct device *dev, struct device_attribute *attr,\n\t  const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\tval /= 1000;\n\n\tmutex_lock(&data->update_lock);\n\tw83795_write(client, W83795_REG_SF4_TEMP(index, nr), val);\n\tdata->sf4_reg[index][SF4_TEMP][nr] = val;\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n\nstatic ssize_t\nshow_temp(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83795_data *data = w83795_update_device(dev);\n\tlong temp = temp_from_reg(data->temp[index][nr]);\n\n\tif (nr == TEMP_READ)\n\t\ttemp += (data->temp_read_vrlsb[index] >> 6) * 250;\n\treturn sprintf(buf, \"%ld\\n\", temp);\n}\n\nstatic ssize_t\nstore_temp(struct device *dev, struct device_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tlong tmp;\n\n\tif (kstrtol(buf, 10, &tmp) < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp[index][nr] = temp_to_reg(tmp, -128, 127);\n\tw83795_write(client, W83795_REG_TEMP[index][nr], data->temp[index][nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n\nstatic ssize_t\nshow_dts_mode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83795_data *data = dev_get_drvdata(dev);\n\tint tmp;\n\n\tif (data->enable_dts & 2)\n\t\ttmp = 5;\n\telse\n\t\ttmp = 6;\n\n\treturn sprintf(buf, \"%d\\n\", tmp);\n}\n\nstatic ssize_t\nshow_dts(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint index = sensor_attr->index;\n\tstruct w83795_data *data = w83795_update_device(dev);\n\tlong temp = temp_from_reg(data->dts[index]);\n\n\ttemp += (data->dts_read_vrlsb[index] >> 6) * 250;\n\treturn sprintf(buf, \"%ld\\n\", temp);\n}\n\nstatic ssize_t\nshow_dts_ext(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tstruct w83795_data *data = dev_get_drvdata(dev);\n\tlong temp = temp_from_reg(data->dts_ext[nr]);\n\n\treturn sprintf(buf, \"%ld\\n\", temp);\n}\n\nstatic ssize_t\nstore_dts_ext(struct device *dev, struct device_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tlong tmp;\n\n\tif (kstrtol(buf, 10, &tmp) < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->dts_ext[nr] = temp_to_reg(tmp, -128, 127);\n\tw83795_write(client, W83795_REG_DTS_EXT(nr), data->dts_ext[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n\nstatic ssize_t\nshow_temp_mode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w83795_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint index = sensor_attr->index;\n\tint tmp;\n\n\tif (data->temp_mode & (1 << index))\n\t\ttmp = 3;\t \n\telse\n\t\ttmp = 4;\t \n\n\treturn sprintf(buf, \"%d\\n\", tmp);\n}\n\n \nstatic ssize_t\nstore_temp_mode(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint index = sensor_attr->index;\n\tint reg_shift;\n\tunsigned long val;\n\tu8 tmp;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\tif ((val != 4) && (val != 3))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tif (val == 3) {\n\t\t \n\t\tval = 0x01;\n\t\tdata->temp_mode |= 1 << index;\n\t} else if (val == 4) {\n\t\t \n\t\tval = 0x03;\n\t\tdata->temp_mode &= ~(1 << index);\n\t}\n\n\treg_shift = 2 * index;\n\ttmp = w83795_read(client, W83795_REG_TEMP_CTRL2);\n\ttmp &= ~(0x03 << reg_shift);\n\ttmp |= val << reg_shift;\n\tw83795_write(client, W83795_REG_TEMP_CTRL2, tmp);\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n\n \nstatic ssize_t\nshow_in(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct w83795_data *data = w83795_update_device(dev);\n\tu16 val = data->in[index][nr];\n\tu8 lsb_idx;\n\n\tswitch (nr) {\n\tcase IN_READ:\n\t\t \n\t\tif ((index >= 17) &&\n\t\t    !((data->has_gain >> (index - 17)) & 1))\n\t\t\tval *= 8;\n\t\tbreak;\n\tcase IN_MAX:\n\tcase IN_LOW:\n\t\tlsb_idx = IN_LSB_SHIFT_IDX[index][IN_LSB_IDX];\n\t\tval <<= 2;\n\t\tval |= (data->in_lsb[lsb_idx][nr] >>\n\t\t\tIN_LSB_SHIFT_IDX[index][IN_LSB_SHIFT]) & 0x03;\n\t\tif ((index >= 17) &&\n\t\t    !((data->has_gain >> (index - 17)) & 1))\n\t\t\tval *= 8;\n\t\tbreak;\n\t}\n\tval = in_from_reg(index, val);\n\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t\nstore_in(struct device *dev, struct device_attribute *attr,\n\t const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tint index = sensor_attr->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tu8 tmp;\n\tu8 lsb_idx;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\tval = in_to_reg(index, val);\n\n\tif ((index >= 17) &&\n\t    !((data->has_gain >> (index - 17)) & 1))\n\t\tval /= 8;\n\tval = clamp_val(val, 0, 0x3FF);\n\tmutex_lock(&data->update_lock);\n\n\tlsb_idx = IN_LSB_SHIFT_IDX[index][IN_LSB_IDX];\n\ttmp = w83795_read(client, IN_LSB_REG(lsb_idx, nr));\n\ttmp &= ~(0x03 << IN_LSB_SHIFT_IDX[index][IN_LSB_SHIFT]);\n\ttmp |= (val & 0x03) << IN_LSB_SHIFT_IDX[index][IN_LSB_SHIFT];\n\tw83795_write(client, IN_LSB_REG(lsb_idx, nr), tmp);\n\tdata->in_lsb[lsb_idx][nr] = tmp;\n\n\ttmp = (val >> 2) & 0xff;\n\tw83795_write(client, W83795_REG_IN[index][nr], tmp);\n\tdata->in[index][nr] = tmp;\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n\n#ifdef CONFIG_SENSORS_W83795_FANCTRL\nstatic ssize_t\nshow_sf_setup(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tstruct w83795_data *data = w83795_update_pwm_config(dev);\n\tu16 val = data->setup_pwm[nr];\n\n\tswitch (nr) {\n\tcase SETUP_PWM_UPTIME:\n\tcase SETUP_PWM_DOWNTIME:\n\t\tval = time_from_reg(val);\n\t\tbreak;\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t\nstore_sf_setup(struct device *dev, struct device_attribute *attr,\n\t const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sensor_attr =\n\t    to_sensor_dev_attr_2(attr);\n\tint nr = sensor_attr->nr;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tswitch (nr) {\n\tcase SETUP_PWM_DEFAULT:\n\t\tval = clamp_val(val, 0, 0xff);\n\t\tbreak;\n\tcase SETUP_PWM_UPTIME:\n\tcase SETUP_PWM_DOWNTIME:\n\t\tval = time_to_reg(val);\n\t\tif (val == 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_lock(&data->update_lock);\n\tdata->setup_pwm[nr] = val;\n\tw83795_write(client, W83795_REG_SETUP_PWM(nr), val);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n#endif\n\n\n#define NOT_USED\t\t\t-1\n\n \n#define SENSOR_ATTR_IN(index) {\t\t\t\t\t\t\\\n\tSENSOR_ATTR_2(in##index##_input, S_IRUGO, show_in, NULL,\t\\\n\t\tIN_READ, index), \\\n\tSENSOR_ATTR_2(in##index##_max, S_IRUGO | S_IWUSR, show_in,\t\\\n\t\tstore_in, IN_MAX, index),\t\t\t\t\\\n\tSENSOR_ATTR_2(in##index##_min, S_IRUGO | S_IWUSR, show_in,\t\\\n\t\tstore_in, IN_LOW, index),\t\t\t\t\\\n\tSENSOR_ATTR_2(in##index##_alarm, S_IRUGO, show_alarm_beep,\t\\\n\t\tNULL, ALARM_STATUS, index + ((index > 14) ? 1 : 0)), \\\n\tSENSOR_ATTR_2(in##index##_beep, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_alarm_beep, store_beep, BEEP_ENABLE,\t\t\\\n\t\tindex + ((index > 14) ? 1 : 0)) }\n\n \n#define SENSOR_ATTR_FAN(index) {\t\t\t\t\t\\\n\tSENSOR_ATTR_2(fan##index##_input, S_IRUGO, show_fan,\t\t\\\n\t\tNULL, FAN_INPUT, index - 1), \\\n\tSENSOR_ATTR_2(fan##index##_min, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_fan, store_fan_min, FAN_MIN, index - 1),\t\\\n\tSENSOR_ATTR_2(fan##index##_alarm, S_IRUGO, show_alarm_beep,\t\\\n\t\tNULL, ALARM_STATUS, index + 31),\t\t\t\\\n\tSENSOR_ATTR_2(fan##index##_beep, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_alarm_beep, store_beep, BEEP_ENABLE, index + 31) }\n\n#define SENSOR_ATTR_PWM(index) {\t\t\t\t\t\\\n\tSENSOR_ATTR_2(pwm##index, S_IWUSR | S_IRUGO, show_pwm,\t\t\\\n\t\tstore_pwm, PWM_OUTPUT, index - 1),\t\t\t\\\n\tSENSOR_ATTR_2(pwm##index##_enable, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_pwm_enable, store_pwm_enable, NOT_USED, index - 1), \\\n\tSENSOR_ATTR_2(pwm##index##_mode, S_IRUGO,\t\t\t\\\n\t\tshow_pwm_mode, NULL, NOT_USED, index - 1),\t\t\\\n\tSENSOR_ATTR_2(pwm##index##_freq, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_pwm, store_pwm, PWM_FREQ, index - 1),\t\t\\\n\tSENSOR_ATTR_2(pwm##index##_nonstop, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_pwm, store_pwm, PWM_NONSTOP, index - 1),\t\t\\\n\tSENSOR_ATTR_2(pwm##index##_start, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_pwm, store_pwm, PWM_START, index - 1),\t\t\\\n\tSENSOR_ATTR_2(pwm##index##_stop_time, S_IWUSR | S_IRUGO,\t\\\n\t\tshow_pwm, store_pwm, PWM_STOP_TIME, index - 1),\t \\\n\tSENSOR_ATTR_2(fan##index##_target, S_IWUSR | S_IRUGO, \\\n\t\tshow_fanin, store_fanin, FANIN_TARGET, index - 1) }\n\n \n#define SENSOR_ATTR_DTS(index) {\t\t\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_type, S_IRUGO ,\t\t\\\n\t\tshow_dts_mode, NULL, NOT_USED, index - 7),\t\\\n\tSENSOR_ATTR_2(temp##index##_input, S_IRUGO, show_dts,\t\t\\\n\t\tNULL, NOT_USED, index - 7),\t\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_crit, S_IRUGO | S_IWUSR, show_dts_ext, \\\n\t\tstore_dts_ext, DTS_CRIT, NOT_USED),\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_crit_hyst, S_IRUGO | S_IWUSR,\t\\\n\t\tshow_dts_ext, store_dts_ext, DTS_CRIT_HYST, NOT_USED),\t\\\n\tSENSOR_ATTR_2(temp##index##_max, S_IRUGO | S_IWUSR, show_dts_ext, \\\n\t\tstore_dts_ext, DTS_WARN, NOT_USED),\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_max_hyst, S_IRUGO | S_IWUSR,\t\\\n\t\tshow_dts_ext, store_dts_ext, DTS_WARN_HYST, NOT_USED),\t\\\n\tSENSOR_ATTR_2(temp##index##_alarm, S_IRUGO,\t\t\t\\\n\t\tshow_alarm_beep, NULL, ALARM_STATUS, index + 17),\t\\\n\tSENSOR_ATTR_2(temp##index##_beep, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_alarm_beep, store_beep, BEEP_ENABLE, index + 17) }\n\n \n#define SENSOR_ATTR_TEMP(index) {\t\t\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_type, S_IRUGO | (index < 5 ? S_IWUSR : 0), \\\n\t\tshow_temp_mode, store_temp_mode, NOT_USED, index - 1),\t\\\n\tSENSOR_ATTR_2(temp##index##_input, S_IRUGO, show_temp,\t\t\\\n\t\tNULL, TEMP_READ, index - 1),\t\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_crit, S_IRUGO | S_IWUSR, show_temp,\t\\\n\t\tstore_temp, TEMP_CRIT, index - 1),\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_crit_hyst, S_IRUGO | S_IWUSR,\t\\\n\t\tshow_temp, store_temp, TEMP_CRIT_HYST, index - 1),\t\\\n\tSENSOR_ATTR_2(temp##index##_max, S_IRUGO | S_IWUSR, show_temp,\t\\\n\t\tstore_temp, TEMP_WARN, index - 1),\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_max_hyst, S_IRUGO | S_IWUSR,\t\\\n\t\tshow_temp, store_temp, TEMP_WARN_HYST, index - 1),\t\\\n\tSENSOR_ATTR_2(temp##index##_alarm, S_IRUGO,\t\t\t\\\n\t\tshow_alarm_beep, NULL, ALARM_STATUS,\t\t\t\\\n\t\tindex + (index > 4 ? 11 : 17)),\t\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_beep, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_alarm_beep, store_beep, BEEP_ENABLE,\t\t\\\n\t\tindex + (index > 4 ? 11 : 17)),\t\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_pwm_enable, S_IWUSR | S_IRUGO,\t\\\n\t\tshow_temp_pwm_enable, store_temp_pwm_enable,\t\t\\\n\t\tTEMP_PWM_ENABLE, index - 1),\t\t\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_channels_pwm, S_IWUSR | S_IRUGO, \\\n\t\tshow_temp_pwm_enable, store_temp_pwm_enable,\t\t\\\n\t\tTEMP_PWM_FAN_MAP, index - 1),\t\t\t\t\\\n\tSENSOR_ATTR_2(thermal_cruise##index, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_temp_pwm, store_temp_pwm, TEMP_PWM_TTTI, index - 1), \\\n\tSENSOR_ATTR_2(temp##index##_warn, S_IWUSR | S_IRUGO,\t\t\\\n\t\tshow_temp_pwm, store_temp_pwm, TEMP_PWM_CTFS, index - 1), \\\n\tSENSOR_ATTR_2(temp##index##_warn_hyst, S_IWUSR | S_IRUGO,\t\\\n\t\tshow_temp_pwm, store_temp_pwm, TEMP_PWM_HCT, index - 1), \\\n\tSENSOR_ATTR_2(temp##index##_operation_hyst, S_IWUSR | S_IRUGO,\t\\\n\t\tshow_temp_pwm, store_temp_pwm, TEMP_PWM_HOT, index - 1), \\\n\tSENSOR_ATTR_2(temp##index##_auto_point1_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf4_pwm, store_sf4_pwm, 0, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point2_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf4_pwm, store_sf4_pwm, 1, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point3_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf4_pwm, store_sf4_pwm, 2, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point4_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf4_pwm, store_sf4_pwm, 3, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point5_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf4_pwm, store_sf4_pwm, 4, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point6_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf4_pwm, store_sf4_pwm, 5, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point7_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_sf4_pwm, store_sf4_pwm, 6, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point1_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf4_temp, store_sf4_temp, 0, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point2_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf4_temp, store_sf4_temp, 1, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point3_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf4_temp, store_sf4_temp, 2, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point4_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf4_temp, store_sf4_temp, 3, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point5_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf4_temp, store_sf4_temp, 4, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point6_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf4_temp, store_sf4_temp, 5, index - 1),\t\t\\\n\tSENSOR_ATTR_2(temp##index##_auto_point7_temp, S_IRUGO | S_IWUSR,\\\n\t\tshow_sf4_temp, store_sf4_temp, 6, index - 1) }\n\n\nstatic struct sensor_device_attribute_2 w83795_in[][5] = {\n\tSENSOR_ATTR_IN(0),\n\tSENSOR_ATTR_IN(1),\n\tSENSOR_ATTR_IN(2),\n\tSENSOR_ATTR_IN(3),\n\tSENSOR_ATTR_IN(4),\n\tSENSOR_ATTR_IN(5),\n\tSENSOR_ATTR_IN(6),\n\tSENSOR_ATTR_IN(7),\n\tSENSOR_ATTR_IN(8),\n\tSENSOR_ATTR_IN(9),\n\tSENSOR_ATTR_IN(10),\n\tSENSOR_ATTR_IN(11),\n\tSENSOR_ATTR_IN(12),\n\tSENSOR_ATTR_IN(13),\n\tSENSOR_ATTR_IN(14),\n\tSENSOR_ATTR_IN(15),\n\tSENSOR_ATTR_IN(16),\n\tSENSOR_ATTR_IN(17),\n\tSENSOR_ATTR_IN(18),\n\tSENSOR_ATTR_IN(19),\n\tSENSOR_ATTR_IN(20),\n};\n\nstatic const struct sensor_device_attribute_2 w83795_fan[][4] = {\n\tSENSOR_ATTR_FAN(1),\n\tSENSOR_ATTR_FAN(2),\n\tSENSOR_ATTR_FAN(3),\n\tSENSOR_ATTR_FAN(4),\n\tSENSOR_ATTR_FAN(5),\n\tSENSOR_ATTR_FAN(6),\n\tSENSOR_ATTR_FAN(7),\n\tSENSOR_ATTR_FAN(8),\n\tSENSOR_ATTR_FAN(9),\n\tSENSOR_ATTR_FAN(10),\n\tSENSOR_ATTR_FAN(11),\n\tSENSOR_ATTR_FAN(12),\n\tSENSOR_ATTR_FAN(13),\n\tSENSOR_ATTR_FAN(14),\n};\n\nstatic const struct sensor_device_attribute_2 w83795_temp[][28] = {\n\tSENSOR_ATTR_TEMP(1),\n\tSENSOR_ATTR_TEMP(2),\n\tSENSOR_ATTR_TEMP(3),\n\tSENSOR_ATTR_TEMP(4),\n\tSENSOR_ATTR_TEMP(5),\n\tSENSOR_ATTR_TEMP(6),\n};\n\nstatic const struct sensor_device_attribute_2 w83795_dts[][8] = {\n\tSENSOR_ATTR_DTS(7),\n\tSENSOR_ATTR_DTS(8),\n\tSENSOR_ATTR_DTS(9),\n\tSENSOR_ATTR_DTS(10),\n\tSENSOR_ATTR_DTS(11),\n\tSENSOR_ATTR_DTS(12),\n\tSENSOR_ATTR_DTS(13),\n\tSENSOR_ATTR_DTS(14),\n};\n\nstatic const struct sensor_device_attribute_2 w83795_pwm[][8] = {\n\tSENSOR_ATTR_PWM(1),\n\tSENSOR_ATTR_PWM(2),\n\tSENSOR_ATTR_PWM(3),\n\tSENSOR_ATTR_PWM(4),\n\tSENSOR_ATTR_PWM(5),\n\tSENSOR_ATTR_PWM(6),\n\tSENSOR_ATTR_PWM(7),\n\tSENSOR_ATTR_PWM(8),\n};\n\nstatic const struct sensor_device_attribute_2 w83795_tss[6] = {\n\tSENSOR_ATTR_2(temp1_source_sel, S_IWUSR | S_IRUGO,\n\t\t      show_temp_src, store_temp_src, NOT_USED, 0),\n\tSENSOR_ATTR_2(temp2_source_sel, S_IWUSR | S_IRUGO,\n\t\t      show_temp_src, store_temp_src, NOT_USED, 1),\n\tSENSOR_ATTR_2(temp3_source_sel, S_IWUSR | S_IRUGO,\n\t\t      show_temp_src, store_temp_src, NOT_USED, 2),\n\tSENSOR_ATTR_2(temp4_source_sel, S_IWUSR | S_IRUGO,\n\t\t      show_temp_src, store_temp_src, NOT_USED, 3),\n\tSENSOR_ATTR_2(temp5_source_sel, S_IWUSR | S_IRUGO,\n\t\t      show_temp_src, store_temp_src, NOT_USED, 4),\n\tSENSOR_ATTR_2(temp6_source_sel, S_IWUSR | S_IRUGO,\n\t\t      show_temp_src, store_temp_src, NOT_USED, 5),\n};\n\nstatic const struct sensor_device_attribute_2 sda_single_files[] = {\n\tSENSOR_ATTR_2(intrusion0_alarm, S_IWUSR | S_IRUGO, show_alarm_beep,\n\t\t      store_chassis_clear, ALARM_STATUS, 46),\n#ifdef CONFIG_SENSORS_W83795_FANCTRL\n\tSENSOR_ATTR_2(speed_cruise_tolerance, S_IWUSR | S_IRUGO, show_fanin,\n\t\tstore_fanin, FANIN_TOL, NOT_USED),\n\tSENSOR_ATTR_2(pwm_default, S_IWUSR | S_IRUGO, show_sf_setup,\n\t\t      store_sf_setup, SETUP_PWM_DEFAULT, NOT_USED),\n\tSENSOR_ATTR_2(pwm_uptime, S_IWUSR | S_IRUGO, show_sf_setup,\n\t\t      store_sf_setup, SETUP_PWM_UPTIME, NOT_USED),\n\tSENSOR_ATTR_2(pwm_downtime, S_IWUSR | S_IRUGO, show_sf_setup,\n\t\t      store_sf_setup, SETUP_PWM_DOWNTIME, NOT_USED),\n#endif\n};\n\nstatic const struct sensor_device_attribute_2 sda_beep_files[] = {\n\tSENSOR_ATTR_2(intrusion0_beep, S_IWUSR | S_IRUGO, show_alarm_beep,\n\t\t      store_beep, BEEP_ENABLE, 46),\n\tSENSOR_ATTR_2(beep_enable, S_IWUSR | S_IRUGO, show_alarm_beep,\n\t\t      store_beep, BEEP_ENABLE, 47),\n};\n\n \n\nstatic void w83795_init_client(struct i2c_client *client)\n{\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tstatic const u16 clkin[4] = {\t \n\t\t14318, 24000, 33333, 48000\n\t};\n\tu8 config;\n\n\tif (reset)\n\t\tw83795_write(client, W83795_REG_CONFIG, 0x80);\n\n\t \n\tconfig = w83795_read(client, W83795_REG_CONFIG);\n\tif (!(config & W83795_REG_CONFIG_START)) {\n\t\tdev_info(&client->dev, \"Enabling monitoring operations\\n\");\n\t\tw83795_write(client, W83795_REG_CONFIG,\n\t\t\t     config | W83795_REG_CONFIG_START);\n\t}\n\n\tdata->clkin = clkin[(config >> 3) & 0x3];\n\tdev_dbg(&client->dev, \"clkin = %u kHz\\n\", data->clkin);\n}\n\nstatic int w83795_get_device_id(struct i2c_client *client)\n{\n\tint device_id;\n\n\tdevice_id = i2c_smbus_read_byte_data(client, W83795_REG_DEVICEID);\n\n\t \n\tif (device_id < 0 || (device_id & 0xf0) != 0x50) {\n\t\tint alt_id;\n\n\t\talt_id = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t  W83795_REG_DEVICEID_A);\n\t\tif (alt_id == 0x50)\n\t\t\tdevice_id = alt_id;\n\t}\n\n\treturn device_id;\n}\n\n \nstatic int w83795_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info)\n{\n\tint bank, vendor_id, device_id, expected, i2c_addr, config;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tunsigned short address = client->addr;\n\tconst char *chip_name;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\tbank = i2c_smbus_read_byte_data(client, W83795_REG_BANKSEL);\n\tif (bank < 0 || (bank & 0x7c)) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"w83795: Detection failed at addr 0x%02hx, check %s\\n\",\n\t\t\taddress, \"bank\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tvendor_id = i2c_smbus_read_byte_data(client, W83795_REG_VENDORID);\n\texpected = bank & 0x80 ? 0x5c : 0xa3;\n\tif (vendor_id != expected) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"w83795: Detection failed at addr 0x%02hx, check %s\\n\",\n\t\t\taddress, \"vendor id\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdevice_id = w83795_get_device_id(client) |\n\t\t    (i2c_smbus_read_byte_data(client, W83795_REG_CHIPID) << 8);\n\tif ((device_id >> 4) != 0x795) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"w83795: Detection failed at addr 0x%02hx, check %s\\n\",\n\t\t\taddress, \"device id\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif ((bank & 0x07) == 0) {\n\t\ti2c_addr = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t    W83795_REG_I2C_ADDR);\n\t\tif ((i2c_addr & 0x7f) != address) {\n\t\t\tdev_dbg(&adapter->dev,\n\t\t\t\t\"w83795: Detection failed at addr 0x%02hx, \"\n\t\t\t\t\"check %s\\n\", address, \"i2c addr\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tif ((bank & 0x07) != 0)\n\t\ti2c_smbus_write_byte_data(client, W83795_REG_BANKSEL,\n\t\t\t\t\t  bank & ~0x07);\n\tconfig = i2c_smbus_read_byte_data(client, W83795_REG_CONFIG);\n\tif (config & W83795_REG_CONFIG_CONFIG48)\n\t\tchip_name = \"w83795adg\";\n\telse\n\t\tchip_name = \"w83795g\";\n\n\tstrscpy(info->type, chip_name, I2C_NAME_SIZE);\n\tdev_info(&adapter->dev, \"Found %s rev. %c at 0x%02hx\\n\", chip_name,\n\t\t 'A' + (device_id & 0xf), address);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SENSORS_W83795_FANCTRL\n#define NUM_PWM_ATTRIBUTES\tARRAY_SIZE(w83795_pwm[0])\n#define NUM_TEMP_ATTRIBUTES\tARRAY_SIZE(w83795_temp[0])\n#else\n#define NUM_PWM_ATTRIBUTES\t4\n#define NUM_TEMP_ATTRIBUTES\t8\n#endif\n\nstatic int w83795_handle_files(struct device *dev, int (*fn)(struct device *,\n\t\t\t       const struct device_attribute *))\n{\n\tstruct w83795_data *data = dev_get_drvdata(dev);\n\tint err, i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(w83795_in); i++) {\n\t\tif (!(data->has_in & (1 << i)))\n\t\t\tcontinue;\n\t\tfor (j = 0; j < ARRAY_SIZE(w83795_in[0]); j++) {\n\t\t\tif (j == 4 && !data->enable_beep)\n\t\t\t\tcontinue;\n\t\t\terr = fn(dev, &w83795_in[i][j].dev_attr);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(w83795_fan); i++) {\n\t\tif (!(data->has_fan & (1 << i)))\n\t\t\tcontinue;\n\t\tfor (j = 0; j < ARRAY_SIZE(w83795_fan[0]); j++) {\n\t\t\tif (j == 3 && !data->enable_beep)\n\t\t\t\tcontinue;\n\t\t\terr = fn(dev, &w83795_fan[i][j].dev_attr);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(w83795_tss); i++) {\n\t\tj = w83795_tss_useful(data, i);\n\t\tif (!j)\n\t\t\tcontinue;\n\t\terr = fn(dev, &w83795_tss[i].dev_attr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sda_single_files); i++) {\n\t\terr = fn(dev, &sda_single_files[i].dev_attr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data->enable_beep) {\n\t\tfor (i = 0; i < ARRAY_SIZE(sda_beep_files); i++) {\n\t\t\terr = fn(dev, &sda_beep_files[i].dev_attr);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tfor (i = 0; i < data->has_pwm; i++) {\n\t\tfor (j = 0; j < NUM_PWM_ATTRIBUTES; j++) {\n\t\t\terr = fn(dev, &w83795_pwm[i][j].dev_attr);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(w83795_temp); i++) {\n\t\tif (!(data->has_temp & (1 << i)))\n\t\t\tcontinue;\n\t\tfor (j = 0; j < NUM_TEMP_ATTRIBUTES; j++) {\n\t\t\tif (j == 7 && !data->enable_beep)\n\t\t\t\tcontinue;\n\t\t\terr = fn(dev, &w83795_temp[i][j].dev_attr);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (data->enable_dts) {\n\t\tfor (i = 0; i < ARRAY_SIZE(w83795_dts); i++) {\n\t\t\tif (!(data->has_dts & (1 << i)))\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < ARRAY_SIZE(w83795_dts[0]); j++) {\n\t\t\t\tif (j == 7 && !data->enable_beep)\n\t\t\t\t\tcontinue;\n\t\t\t\terr = fn(dev, &w83795_dts[i][j].dev_attr);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int device_remove_file_wrapper(struct device *dev,\n\t\t\t\t      const struct device_attribute *attr)\n{\n\tdevice_remove_file(dev, attr);\n\treturn 0;\n}\n\nstatic void w83795_check_dynamic_in_limits(struct i2c_client *client)\n{\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\tu8 vid_ctl;\n\tint i, err_max, err_min;\n\n\tvid_ctl = w83795_read(client, W83795_REG_VID_CTRL);\n\n\t \n\tif ((vid_ctl & 0x07) == 0x00 || (vid_ctl & 0x07) == 0x07)\n\t\treturn;\n\n\tdata->has_dyn_in = (vid_ctl >> 3) & 0x07;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (!(data->has_dyn_in & (1 << i)))\n\t\t\tcontinue;\n\n\t\t \n\t\terr_max = sysfs_chmod_file(&client->dev.kobj,\n\t\t\t\t\t   &w83795_in[i][2].dev_attr.attr,\n\t\t\t\t\t   S_IRUGO);\n\t\terr_min = sysfs_chmod_file(&client->dev.kobj,\n\t\t\t\t\t   &w83795_in[i][3].dev_attr.attr,\n\t\t\t\t\t   S_IRUGO);\n\t\tif (err_max || err_min)\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"Failed to set in%d limits read-only (%d, %d)\\n\",\n\t\t\t\t i, err_max, err_min);\n\t\telse\n\t\t\tdev_info(&client->dev,\n\t\t\t\t \"in%d limits set dynamically from VID\\n\", i);\n\t}\n}\n\n \nstatic void w83795_apply_temp_config(struct w83795_data *data, u8 config,\n\t\t\t\t     int temp_chan, int in_chan)\n{\n\t \n\tswitch (config) {\n\tcase 0x2:  \n\t\tdata->has_in |= 1 << in_chan;\n\t\tbreak;\n\tcase 0x1:  \n\t\tif (temp_chan >= 4)\n\t\t\tbreak;\n\t\tdata->temp_mode |= 1 << temp_chan;\n\t\tfallthrough;\n\tcase 0x3:  \n\t\tdata->has_temp |= 1 << temp_chan;\n\t\tbreak;\n\t}\n}\n\nstatic const struct i2c_device_id w83795_id[];\n\nstatic int w83795_probe(struct i2c_client *client)\n{\n\tint i;\n\tu8 tmp;\n\tstruct device *dev = &client->dev;\n\tstruct w83795_data *data;\n\tint err;\n\n\tdata = devm_kzalloc(dev, sizeof(struct w83795_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tdata->chip_type = i2c_match_id(w83795_id, client)->driver_data;\n\tdata->bank = i2c_smbus_read_byte_data(client, W83795_REG_BANKSEL);\n\tmutex_init(&data->update_lock);\n\n\t \n\tw83795_init_client(client);\n\n\t \n\tdata->has_in = w83795_read(client, W83795_REG_VOLT_CTRL1)\n\t\t     | (w83795_read(client, W83795_REG_VOLT_CTRL2) << 8);\n\tdata->has_fan = w83795_read(client, W83795_REG_FANIN_CTRL1)\n\t\t      | (w83795_read(client, W83795_REG_FANIN_CTRL2) << 8);\n\n\t \n\ttmp = w83795_read(client, W83795_REG_TEMP_CTRL1);\n\tif (tmp & 0x20)\n\t\tdata->enable_dts = 1;\n\tw83795_apply_temp_config(data, (tmp >> 2) & 0x3, 5, 16);\n\tw83795_apply_temp_config(data, tmp & 0x3, 4, 15);\n\ttmp = w83795_read(client, W83795_REG_TEMP_CTRL2);\n\tw83795_apply_temp_config(data, tmp >> 6, 3, 20);\n\tw83795_apply_temp_config(data, (tmp >> 4) & 0x3, 2, 19);\n\tw83795_apply_temp_config(data, (tmp >> 2) & 0x3, 1, 18);\n\tw83795_apply_temp_config(data, tmp & 0x3, 0, 17);\n\n\t \n\tif (data->enable_dts) {\n\t\tif (1 & w83795_read(client, W83795_REG_DTSC))\n\t\t\tdata->enable_dts |= 2;\n\t\tdata->has_dts = w83795_read(client, W83795_REG_DTSE);\n\t}\n\n\t \n\tif (data->enable_dts == 1) {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (!(data->has_dts & (1 << i)))\n\t\t\t\tcontinue;\n\t\t\ttmp = w83795_read(client, W83795_REG_PECI_TBASE(i));\n\t\t\tdev_info(&client->dev,\n\t\t\t\t \"PECI agent %d Tbase temperature: %u\\n\",\n\t\t\t\t i + 1, (unsigned int)tmp & 0x7f);\n\t\t}\n\t}\n\n\tdata->has_gain = w83795_read(client, W83795_REG_VMIGB_CTRL) & 0x0f;\n\n\t \n\tif (data->chip_type == w83795g)\n\t\tdata->has_pwm = 8;\n\telse\n\t\tdata->has_pwm = 2;\n\n\t \n\tif (data->chip_type == w83795g) {\n\t\t \n\t\tdata->enable_beep = 1;\n\t} else {\n\t\t \n\t\ttmp = w83795_read(client, W83795_REG_OVT_CFG);\n\t\tif ((tmp & OVT_CFG_SEL) == 0)\n\t\t\tdata->enable_beep = 1;\n\t}\n\n\terr = w83795_handle_files(dev, device_create_file);\n\tif (err)\n\t\tgoto exit_remove;\n\n\tif (data->chip_type == w83795g)\n\t\tw83795_check_dynamic_in_limits(client);\n\n\tdata->hwmon_dev = hwmon_device_register(dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto exit_remove;\n\t}\n\n\treturn 0;\n\nexit_remove:\n\tw83795_handle_files(dev, device_remove_file_wrapper);\n\treturn err;\n}\n\nstatic void w83795_remove(struct i2c_client *client)\n{\n\tstruct w83795_data *data = i2c_get_clientdata(client);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tw83795_handle_files(&client->dev, device_remove_file_wrapper);\n}\n\n\nstatic const struct i2c_device_id w83795_id[] = {\n\t{ \"w83795g\", w83795g },\n\t{ \"w83795adg\", w83795adg },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, w83795_id);\n\nstatic struct i2c_driver w83795_driver = {\n\t.driver = {\n\t\t   .name = \"w83795\",\n\t},\n\t.probe\t\t= w83795_probe,\n\t.remove\t\t= w83795_remove,\n\t.id_table\t= w83795_id,\n\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.detect\t\t= w83795_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(w83795_driver);\n\nMODULE_AUTHOR(\"Wei Song, Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"W83795G/ADG hardware monitoring driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}