{
  "module_name": "nct7802.c",
  "hash_id": "05537d960e577dc36a6e890b04a50f21ce32b0a6cede3900d66b54e7a7059d9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/nct7802.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define DRVNAME \"nct7802\"\n\nstatic const u8 REG_VOLTAGE[5] = { 0x09, 0x0a, 0x0c, 0x0d, 0x0e };\n\nstatic const u8 REG_VOLTAGE_LIMIT_LSB[2][5] = {\n\t{ 0x46, 0x00, 0x40, 0x42, 0x44 },\n\t{ 0x45, 0x00, 0x3f, 0x41, 0x43 },\n};\n\nstatic const u8 REG_VOLTAGE_LIMIT_MSB[5] = { 0x48, 0x00, 0x47, 0x47, 0x48 };\n\nstatic const u8 REG_VOLTAGE_LIMIT_MSB_SHIFT[2][5] = {\n\t{ 0, 0, 4, 0, 4 },\n\t{ 2, 0, 6, 2, 6 },\n};\n\n#define REG_BANK\t\t0x00\n#define REG_TEMP_LSB\t\t0x05\n#define REG_TEMP_PECI_LSB\t0x08\n#define REG_VOLTAGE_LOW\t\t0x0f\n#define REG_FANCOUNT_LOW\t0x13\n#define REG_START\t\t0x21\n#define REG_MODE\t\t0x22  \n#define REG_PECI_ENABLE\t\t0x23\n#define REG_FAN_ENABLE\t\t0x24\n#define REG_VMON_ENABLE\t\t0x25\n#define REG_PWM(x)\t\t(0x60 + (x))\n#define REG_SMARTFAN_EN(x)      (0x64 + (x) / 2)\n#define SMARTFAN_EN_SHIFT(x)    ((x) % 2 * 4)\n#define REG_VENDOR_ID\t\t0xfd\n#define REG_CHIP_ID\t\t0xfe\n#define REG_VERSION_ID\t\t0xff\n\n \n#define RTD_MODE_CURRENT\t0x1\n#define RTD_MODE_THERMISTOR\t0x2\n#define RTD_MODE_VOLTAGE\t0x3\n\n#define MODE_RTD_MASK\t\t0x3\n#define MODE_LTD_EN\t\t0x40\n\n \n#define MODE_BIT_OFFSET_RTD(index) ((index) * 2)\n\n \n\nstruct nct7802_data {\n\tstruct regmap *regmap;\n\tstruct mutex access_lock;  \n\tu8 in_status;\n\tstruct mutex in_alarm_lock;\n};\n\nstatic ssize_t temp_type_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tunsigned int mode;\n\tint ret;\n\n\tret = regmap_read(data->regmap, REG_MODE, &mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%u\\n\", (mode >> (2 * sattr->index) & 3) + 2);\n}\n\nstatic ssize_t temp_type_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tunsigned int type;\n\tint err;\n\n\terr = kstrtouint(buf, 0, &type);\n\tif (err < 0)\n\t\treturn err;\n\tif (sattr->index == 2 && type != 4)  \n\t\treturn -EINVAL;\n\tif (type < 3 || type > 4)\n\t\treturn -EINVAL;\n\terr = regmap_update_bits(data->regmap, REG_MODE,\n\t\t\t3 << 2 * sattr->index, (type - 2) << 2 * sattr->index);\n\treturn err ? : count;\n}\n\nstatic ssize_t pwm_mode_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint ret;\n\n\tif (sattr->index > 1)\n\t\treturn sprintf(buf, \"1\\n\");\n\n\tret = regmap_read(data->regmap, 0x5E, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%u\\n\", !(regval & (1 << sattr->index)));\n}\n\nstatic ssize_t pwm_show(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint ret;\n\n\tif (!attr->index)\n\t\treturn sprintf(buf, \"255\\n\");\n\n\tret = regmap_read(data->regmap, attr->index, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t pwm_store(struct device *dev, struct device_attribute *devattr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tint err;\n\tu8 val;\n\n\terr = kstrtou8(buf, 0, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = regmap_write(data->regmap, attr->index, val);\n\treturn err ? : count;\n}\n\nstatic ssize_t pwm_enable_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tunsigned int reg, enabled;\n\tint ret;\n\n\tret = regmap_read(data->regmap, REG_SMARTFAN_EN(sattr->index), &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\tenabled = reg >> SMARTFAN_EN_SHIFT(sattr->index) & 1;\n\treturn sprintf(buf, \"%u\\n\", enabled + 1);\n}\n\nstatic ssize_t pwm_enable_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tu8 val;\n\tint ret;\n\n\tret = kstrtou8(buf, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (val < 1 || val > 2)\n\t\treturn -EINVAL;\n\tret = regmap_update_bits(data->regmap, REG_SMARTFAN_EN(sattr->index),\n\t\t\t\t 1 << SMARTFAN_EN_SHIFT(sattr->index),\n\t\t\t\t (val - 1) << SMARTFAN_EN_SHIFT(sattr->index));\n\treturn ret ? : count;\n}\n\nstatic int nct7802_read_temp(struct nct7802_data *data,\n\t\t\t     u8 reg_temp, u8 reg_temp_low, int *temp)\n{\n\tunsigned int t1, t2 = 0;\n\tint err;\n\n\t*temp = 0;\n\n\tmutex_lock(&data->access_lock);\n\terr = regmap_read(data->regmap, reg_temp, &t1);\n\tif (err < 0)\n\t\tgoto abort;\n\tt1 <<= 8;\n\tif (reg_temp_low) {\t \n\t\terr = regmap_read(data->regmap, reg_temp_low, &t2);\n\t\tif (err < 0)\n\t\t\tgoto abort;\n\t}\n\tt1 |= t2 & 0xe0;\n\t*temp = (s16)t1 / 32 * 125;\nabort:\n\tmutex_unlock(&data->access_lock);\n\treturn err;\n}\n\nstatic int nct7802_read_fan(struct nct7802_data *data, u8 reg_fan)\n{\n\tunsigned int f1, f2;\n\tint ret;\n\n\tmutex_lock(&data->access_lock);\n\tret = regmap_read(data->regmap, reg_fan, &f1);\n\tif (ret < 0)\n\t\tgoto abort;\n\tret = regmap_read(data->regmap, REG_FANCOUNT_LOW, &f2);\n\tif (ret < 0)\n\t\tgoto abort;\n\tret = (f1 << 5) | (f2 >> 3);\n\t \n\tif (ret == 0x1fff)\t \n\t\tret = 0;\n\telse if (ret)\n\t\tret = DIV_ROUND_CLOSEST(1350000U, ret);\nabort:\n\tmutex_unlock(&data->access_lock);\n\treturn ret;\n}\n\nstatic int nct7802_read_fan_min(struct nct7802_data *data, u8 reg_fan_low,\n\t\t\t\tu8 reg_fan_high)\n{\n\tunsigned int f1, f2;\n\tint ret;\n\n\tmutex_lock(&data->access_lock);\n\tret = regmap_read(data->regmap, reg_fan_low, &f1);\n\tif (ret < 0)\n\t\tgoto abort;\n\tret = regmap_read(data->regmap, reg_fan_high, &f2);\n\tif (ret < 0)\n\t\tgoto abort;\n\tret = f1 | ((f2 & 0xf8) << 5);\n\t \n\tif (ret == 0x1fff)\t \n\t\tret = 0;\n\telse if (ret)\n\t\tret = DIV_ROUND_CLOSEST(1350000U, ret);\n\telse\n\t\tret = 1350000U;\nabort:\n\tmutex_unlock(&data->access_lock);\n\treturn ret;\n}\n\nstatic int nct7802_write_fan_min(struct nct7802_data *data, u8 reg_fan_low,\n\t\t\t\t u8 reg_fan_high, unsigned long limit)\n{\n\tint err;\n\n\tif (limit)\n\t\tlimit = DIV_ROUND_CLOSEST(1350000U, limit);\n\telse\n\t\tlimit = 0x1fff;\n\tlimit = clamp_val(limit, 0, 0x1fff);\n\n\tmutex_lock(&data->access_lock);\n\terr = regmap_write(data->regmap, reg_fan_low, limit & 0xff);\n\tif (err < 0)\n\t\tgoto abort;\n\n\terr = regmap_write(data->regmap, reg_fan_high, (limit & 0x1f00) >> 5);\nabort:\n\tmutex_unlock(&data->access_lock);\n\treturn err;\n}\n\nstatic u8 nct7802_vmul[] = { 4, 2, 2, 2, 2 };\n\nstatic int nct7802_read_voltage(struct nct7802_data *data, int nr, int index)\n{\n\tunsigned int v1, v2;\n\tint ret;\n\n\tmutex_lock(&data->access_lock);\n\tif (index == 0) {\t \n\t\tret = regmap_read(data->regmap, REG_VOLTAGE[nr], &v1);\n\t\tif (ret < 0)\n\t\t\tgoto abort;\n\t\tret = regmap_read(data->regmap, REG_VOLTAGE_LOW, &v2);\n\t\tif (ret < 0)\n\t\t\tgoto abort;\n\t\tret = ((v1 << 2) | (v2 >> 6)) * nct7802_vmul[nr];\n\t}  else {\t \n\t\tint shift = 8 - REG_VOLTAGE_LIMIT_MSB_SHIFT[index - 1][nr];\n\n\t\tret = regmap_read(data->regmap,\n\t\t\t\t  REG_VOLTAGE_LIMIT_LSB[index - 1][nr], &v1);\n\t\tif (ret < 0)\n\t\t\tgoto abort;\n\t\tret = regmap_read(data->regmap, REG_VOLTAGE_LIMIT_MSB[nr],\n\t\t\t\t  &v2);\n\t\tif (ret < 0)\n\t\t\tgoto abort;\n\t\tret = (v1 | ((v2 << shift) & 0x300)) * nct7802_vmul[nr];\n\t}\nabort:\n\tmutex_unlock(&data->access_lock);\n\treturn ret;\n}\n\nstatic int nct7802_write_voltage(struct nct7802_data *data, int nr, int index,\n\t\t\t\t unsigned long voltage)\n{\n\tint shift = 8 - REG_VOLTAGE_LIMIT_MSB_SHIFT[index - 1][nr];\n\tint err;\n\n\tvoltage = clamp_val(voltage, 0, 0x3ff * nct7802_vmul[nr]);\n\tvoltage = DIV_ROUND_CLOSEST(voltage, nct7802_vmul[nr]);\n\n\tmutex_lock(&data->access_lock);\n\terr = regmap_write(data->regmap,\n\t\t\t   REG_VOLTAGE_LIMIT_LSB[index - 1][nr],\n\t\t\t   voltage & 0xff);\n\tif (err < 0)\n\t\tgoto abort;\n\n\terr = regmap_update_bits(data->regmap, REG_VOLTAGE_LIMIT_MSB[nr],\n\t\t\t\t 0x0300 >> shift, (voltage & 0x0300) >> shift);\nabort:\n\tmutex_unlock(&data->access_lock);\n\treturn err;\n}\n\nstatic ssize_t in_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tint voltage;\n\n\tvoltage = nct7802_read_voltage(data, sattr->nr, sattr->index);\n\tif (voltage < 0)\n\t\treturn voltage;\n\n\treturn sprintf(buf, \"%d\\n\", voltage);\n}\n\nstatic ssize_t in_store(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tint index = sattr->index;\n\tint nr = sattr->nr;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nct7802_write_voltage(data, nr, index, val);\n\treturn err ? : count;\n}\n\nstatic ssize_t in_alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tint volt, min, max, ret;\n\tunsigned int val;\n\n\tmutex_lock(&data->in_alarm_lock);\n\n\t \n\tret = regmap_read(data->regmap, 0x1e, &val);  \n\tif (ret < 0)\n\t\tgoto abort;\n\n\t \n\tdata->in_status &= ~((val & 0x0f) << 4);\n\n\t \n\tif (!(data->in_status & (0x10 << sattr->index))) {\n\t\tret = nct7802_read_voltage(data, sattr->nr, 0);\n\t\tif (ret < 0)\n\t\t\tgoto abort;\n\t\tvolt = ret;\n\n\t\tret = nct7802_read_voltage(data, sattr->nr, 1);\n\t\tif (ret < 0)\n\t\t\tgoto abort;\n\t\tmin = ret;\n\n\t\tret = nct7802_read_voltage(data, sattr->nr, 2);\n\t\tif (ret < 0)\n\t\t\tgoto abort;\n\t\tmax = ret;\n\n\t\tif (volt < min || volt > max)\n\t\t\tdata->in_status |= (1 << sattr->index);\n\t\telse\n\t\t\tdata->in_status &= ~(1 << sattr->index);\n\n\t\tdata->in_status |= 0x10 << sattr->index;\n\t}\n\n\tret = sprintf(buf, \"%u\\n\", !!(data->in_status & (1 << sattr->index)));\nabort:\n\tmutex_unlock(&data->in_alarm_lock);\n\treturn ret;\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint err, temp;\n\n\terr = nct7802_read_temp(data, sattr->nr, sattr->index, &temp);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%d\\n\", temp);\n}\n\nstatic ssize_t temp_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tint nr = sattr->nr;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = DIV_ROUND_CLOSEST(clamp_val(val, -128000, 127000), 1000);\n\n\terr = regmap_write(data->regmap, nr, val & 0xff);\n\treturn err ? : count;\n}\n\nstatic ssize_t fan_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tint speed;\n\n\tspeed = nct7802_read_fan(data, sattr->index);\n\tif (speed < 0)\n\t\treturn speed;\n\n\treturn sprintf(buf, \"%d\\n\", speed);\n}\n\nstatic ssize_t fan_min_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tint speed;\n\n\tspeed = nct7802_read_fan_min(data, sattr->nr, sattr->index);\n\tif (speed < 0)\n\t\treturn speed;\n\n\treturn sprintf(buf, \"%d\\n\", speed);\n}\n\nstatic ssize_t fan_min_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nct7802_write_fan_min(data, sattr->nr, sattr->index, val);\n\treturn err ? : count;\n}\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint bit = sattr->index;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(data->regmap, sattr->nr, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%u\\n\", !!(val & (1 << bit)));\n}\n\nstatic ssize_t\nbeep_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err;\n\n\terr = regmap_read(data->regmap, sattr->nr, &regval);\n\tif (err)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%u\\n\", !!(regval & (1 << sattr->index)));\n}\n\nstatic ssize_t\nbeep_store(struct device *dev, struct device_attribute *attr, const char *buf,\n\t   size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\terr = regmap_update_bits(data->regmap, sattr->nr, 1 << sattr->index,\n\t\t\t\t val ? 1 << sattr->index : 0);\n\treturn err ? : count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_type, temp_type, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_input, temp, 0x01, REG_TEMP_LSB);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_min, temp, 0x31, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_max, temp, 0x30, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_crit, temp, 0x3a, 0);\n\nstatic SENSOR_DEVICE_ATTR_RW(temp2_type, temp_type, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp2_input, temp, 0x02, REG_TEMP_LSB);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_min, temp, 0x33, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_max, temp, 0x32, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_crit, temp, 0x3b, 0);\n\nstatic SENSOR_DEVICE_ATTR_RW(temp3_type, temp_type, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_input, temp, 0x03, REG_TEMP_LSB);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_min, temp, 0x35, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_max, temp, 0x34, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_crit, temp, 0x3c, 0);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(temp4_input, temp, 0x04, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp4_min, temp, 0x37, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp4_max, temp, 0x36, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp4_crit, temp, 0x3d, 0);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(temp5_input, temp, 0x06, REG_TEMP_PECI_LSB);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp5_min, temp, 0x39, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp5_max, temp, 0x38, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp5_crit, temp, 0x3e, 0);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(temp6_input, temp, 0x07, REG_TEMP_PECI_LSB);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_min_alarm, alarm, 0x18, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp2_min_alarm, alarm, 0x18, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_min_alarm, alarm, 0x18, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp4_min_alarm, alarm, 0x18, 3);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp5_min_alarm, alarm, 0x18, 4);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_max_alarm, alarm, 0x19, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp2_max_alarm, alarm, 0x19, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_max_alarm, alarm, 0x19, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp4_max_alarm, alarm, 0x19, 3);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp5_max_alarm, alarm, 0x19, 4);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_crit_alarm, alarm, 0x1b, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp2_crit_alarm, alarm, 0x1b, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_crit_alarm, alarm, 0x1b, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp4_crit_alarm, alarm, 0x1b, 3);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp5_crit_alarm, alarm, 0x1b, 4);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_fault, alarm, 0x17, 0);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp2_fault, alarm, 0x17, 1);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_fault, alarm, 0x17, 2);\n\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_beep, beep, 0x5c, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_beep, beep, 0x5c, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_beep, beep, 0x5c, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp4_beep, beep, 0x5c, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp5_beep, beep, 0x5c, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp6_beep, beep, 0x5c, 5);\n\nstatic struct attribute *nct7802_temp_attrs[] = {\n\t&sensor_dev_attr_temp1_type.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp1_beep.dev_attr.attr,\n\n\t&sensor_dev_attr_temp2_type.dev_attr.attr,\t\t \n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp2_beep.dev_attr.attr,\n\n\t&sensor_dev_attr_temp3_type.dev_attr.attr,\t\t \n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp3_beep.dev_attr.attr,\n\n\t&sensor_dev_attr_temp4_input.dev_attr.attr,\t\t \n\t&sensor_dev_attr_temp4_min.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max.dev_attr.attr,\n\t&sensor_dev_attr_temp4_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp4_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp4_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp4_beep.dev_attr.attr,\n\n\t&sensor_dev_attr_temp5_input.dev_attr.attr,\t\t \n\t&sensor_dev_attr_temp5_min.dev_attr.attr,\n\t&sensor_dev_attr_temp5_max.dev_attr.attr,\n\t&sensor_dev_attr_temp5_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp5_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp5_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp5_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp5_beep.dev_attr.attr,\n\n\t&sensor_dev_attr_temp6_input.dev_attr.attr,\t\t \n\t&sensor_dev_attr_temp6_beep.dev_attr.attr,\n\n\tNULL\n};\n\nstatic umode_t nct7802_temp_is_visible(struct kobject *kobj,\n\t\t\t\t       struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tunsigned int reg;\n\tint err;\n\n\terr = regmap_read(data->regmap, REG_MODE, &reg);\n\tif (err < 0)\n\t\treturn 0;\n\n\tif (index < 10 &&\n\t    (reg & 03) != 0x01 && (reg & 0x03) != 0x02)\t\t \n\t\treturn 0;\n\n\tif (index >= 10 && index < 20 &&\n\t    (reg & 0x0c) != 0x04 && (reg & 0x0c) != 0x08)\t \n\t\treturn 0;\n\tif (index >= 20 && index < 30 && (reg & 0x30) != 0x20)\t \n\t\treturn 0;\n\n\tif (index >= 30 && index < 38)\t\t\t\t \n\t\treturn attr->mode;\n\n\terr = regmap_read(data->regmap, REG_PECI_ENABLE, &reg);\n\tif (err < 0)\n\t\treturn 0;\n\n\tif (index >= 38 && index < 46 && !(reg & 0x01))\t\t \n\t\treturn 0;\n\n\tif (index >= 46 && !(reg & 0x02))\t\t\t \n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group nct7802_temp_group = {\n\t.attrs = nct7802_temp_attrs,\n\t.is_visible = nct7802_temp_is_visible,\n};\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in0_input, in, 0, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in0_min, in, 0, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in0_max, in, 0, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(in0_alarm, in_alarm, 0, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(in0_beep, beep, 0x5a, 3);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in1_input, in, 1, 0);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in2_input, in, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_min, in, 2, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_max, in, 2, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(in2_alarm, in_alarm, 2, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_beep, beep, 0x5a, 0);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in3_input, in, 3, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_min, in, 3, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_max, in, 3, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(in3_alarm, in_alarm, 3, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_beep, beep, 0x5a, 1);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in4_input, in, 4, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_min, in, 4, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_max, in, 4, 2);\nstatic SENSOR_DEVICE_ATTR_2_RO(in4_alarm, in_alarm, 4, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_beep, beep, 0x5a, 2);\n\nstatic struct attribute *nct7802_in_attrs[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in0_beep.dev_attr.attr,\n\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\t \n\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\t \n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_beep.dev_attr.attr,\n\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\t \n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_beep.dev_attr.attr,\n\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\t \n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in4_beep.dev_attr.attr,\n\n\tNULL,\n};\n\nstatic umode_t nct7802_in_is_visible(struct kobject *kobj,\n\t\t\t\t     struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tunsigned int reg;\n\tint err;\n\n\tif (index < 6)\t\t\t\t\t\t \n\t\treturn attr->mode;\n\n\terr = regmap_read(data->regmap, REG_MODE, &reg);\n\tif (err < 0)\n\t\treturn 0;\n\n\tif (index >= 6 && index < 11 && (reg & 0x03) != 0x03)\t \n\t\treturn 0;\n\tif (index >= 11 && index < 16 && (reg & 0x0c) != 0x0c)\t \n\t\treturn 0;\n\tif (index >= 16 && (reg & 0x30) != 0x30)\t\t \n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group nct7802_in_group = {\n\t.attrs = nct7802_in_attrs,\n\t.is_visible = nct7802_in_is_visible,\n};\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan, 0x10);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan1_min, fan_min, 0x49, 0x4c);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan1_alarm, alarm, 0x1a, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan1_beep, beep, 0x5b, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan, 0x11);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan2_min, fan_min, 0x4a, 0x4d);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan2_alarm, alarm, 0x1a, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan2_beep, beep, 0x5b, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_input, fan, 0x12);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan3_min, fan_min, 0x4b, 0x4e);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan3_alarm, alarm, 0x1a, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan3_beep, beep, 0x5b, 2);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(pwm1_mode, pwm_mode, 0);\nstatic SENSOR_DEVICE_ATTR_RO(pwm2_mode, pwm_mode, 1);\nstatic SENSOR_DEVICE_ATTR_RO(pwm3_mode, pwm_mode, 2);\n\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm1, pwm, REG_PWM(0));\nstatic SENSOR_DEVICE_ATTR_RW(pwm2, pwm, REG_PWM(1));\nstatic SENSOR_DEVICE_ATTR_RW(pwm3, pwm, REG_PWM(2));\n\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm1_enable, pwm_enable, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_enable, pwm_enable, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_enable, pwm_enable, 2);\n\nstatic struct attribute *nct7802_fan_attrs[] = {\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan1_beep.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_beep.dev_attr.attr,\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan3_beep.dev_attr.attr,\n\n\tNULL\n};\n\nstatic umode_t nct7802_fan_is_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct7802_data *data = dev_get_drvdata(dev);\n\tint fan = index / 4;\t \n\tunsigned int reg;\n\tint err;\n\n\terr = regmap_read(data->regmap, REG_FAN_ENABLE, &reg);\n\tif (err < 0 || !(reg & (1 << fan)))\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group nct7802_fan_group = {\n\t.attrs = nct7802_fan_attrs,\n\t.is_visible = nct7802_fan_is_visible,\n};\n\nstatic struct attribute *nct7802_pwm_attrs[] = {\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_mode.dev_attr.attr,\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_mode.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_mode.dev_attr.attr,\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group nct7802_pwm_group = {\n\t.attrs = nct7802_pwm_attrs,\n};\n\n \nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point1_temp, temp, 0x80, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point2_temp, temp, 0x81, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point3_temp, temp, 0x82, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point4_temp, temp, 0x83, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point5_temp, temp, 0x84, 0);\n\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point1_pwm, pwm, 0x85);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point2_pwm, pwm, 0x86);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point3_pwm, pwm, 0x87);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_auto_point4_pwm, pwm, 0x88);\nstatic SENSOR_DEVICE_ATTR_RO(pwm1_auto_point5_pwm, pwm, 0);\n\n \nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point1_temp, temp, 0x90, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point2_temp, temp, 0x91, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point3_temp, temp, 0x92, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point4_temp, temp, 0x93, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point5_temp, temp, 0x94, 0);\n\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_point1_pwm, pwm, 0x95);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_point2_pwm, pwm, 0x96);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_point3_pwm, pwm, 0x97);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_auto_point4_pwm, pwm, 0x98);\nstatic SENSOR_DEVICE_ATTR_RO(pwm2_auto_point5_pwm, pwm, 0);\n\n \nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point1_temp, temp, 0xA0, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point2_temp, temp, 0xA1, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point3_temp, temp, 0xA2, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point4_temp, temp, 0xA3, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point5_temp, temp, 0xA4, 0);\n\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_point1_pwm, pwm, 0xA5);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_point2_pwm, pwm, 0xA6);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_point3_pwm, pwm, 0xA7);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_auto_point4_pwm, pwm, 0xA8);\nstatic SENSOR_DEVICE_ATTR_RO(pwm3_auto_point5_pwm, pwm, 0);\n\nstatic struct attribute *nct7802_auto_point_attrs[] = {\n\t&sensor_dev_attr_pwm1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point5_temp.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point5_pwm.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm2_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point4_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point5_temp.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm2_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point3_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point4_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point5_pwm.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm3_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point4_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point5_temp.dev_attr.attr,\n\n\t&sensor_dev_attr_pwm3_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point3_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point4_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point5_pwm.dev_attr.attr,\n\n\tNULL\n};\n\nstatic const struct attribute_group nct7802_auto_point_group = {\n\t.attrs = nct7802_auto_point_attrs,\n};\n\nstatic const struct attribute_group *nct7802_groups[] = {\n\t&nct7802_temp_group,\n\t&nct7802_in_group,\n\t&nct7802_fan_group,\n\t&nct7802_pwm_group,\n\t&nct7802_auto_point_group,\n\tNULL\n};\n\nstatic int nct7802_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tint reg;\n\n\t \n\treg = i2c_smbus_read_byte_data(client, REG_BANK);\n\tif (reg != 0x00)\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_byte_data(client, REG_VENDOR_ID);\n\tif (reg != 0x50)\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_byte_data(client, REG_CHIP_ID);\n\tif (reg != 0xc3)\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_byte_data(client, REG_VERSION_ID);\n\tif (reg < 0 || (reg & 0xf0) != 0x20)\n\t\treturn -ENODEV;\n\n\t \n\treg = i2c_smbus_read_byte_data(client, REG_TEMP_LSB);\n\tif (reg < 0 || (reg & 0x1f))\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_byte_data(client, REG_TEMP_PECI_LSB);\n\tif (reg < 0 || (reg & 0x3f))\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_byte_data(client, REG_VOLTAGE_LOW);\n\tif (reg < 0 || (reg & 0x3f))\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"nct7802\", I2C_NAME_SIZE);\n\treturn 0;\n}\n\nstatic bool nct7802_regmap_is_volatile(struct device *dev, unsigned int reg)\n{\n\treturn (reg != REG_BANK && reg <= 0x20) ||\n\t\t(reg >= REG_PWM(0) && reg <= REG_PWM(2));\n}\n\nstatic const struct regmap_config nct7802_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = nct7802_regmap_is_volatile,\n};\n\nstatic int nct7802_get_channel_config(struct device *dev,\n\t\t\t\t      struct device_node *node, u8 *mode_mask,\n\t\t\t\t      u8 *mode_val)\n{\n\tu32 reg;\n\tconst char *type_str, *md_str;\n\tu8 md;\n\n\tif (!node->name || of_node_cmp(node->name, \"channel\"))\n\t\treturn 0;\n\n\tif (of_property_read_u32(node, \"reg\", &reg)) {\n\t\tdev_err(dev, \"Could not read reg value for '%s'\\n\",\n\t\t\tnode->full_name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (reg > 3) {\n\t\tdev_err(dev, \"Invalid reg (%u) in '%s'\\n\", reg,\n\t\t\tnode->full_name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (reg == 0) {\n\t\tif (!of_device_is_available(node))\n\t\t\t*mode_val &= ~MODE_LTD_EN;\n\t\telse\n\t\t\t*mode_val |= MODE_LTD_EN;\n\t\t*mode_mask |= MODE_LTD_EN;\n\t\treturn 0;\n\t}\n\n\t \n\n\tif (!of_device_is_available(node)) {\n\t\t*mode_val &= ~(MODE_RTD_MASK << MODE_BIT_OFFSET_RTD(reg - 1));\n\t\t*mode_mask |= MODE_RTD_MASK << MODE_BIT_OFFSET_RTD(reg - 1);\n\t\treturn 0;\n\t}\n\n\tif (of_property_read_string(node, \"sensor-type\", &type_str)) {\n\t\tdev_err(dev, \"No type for '%s'\\n\", node->full_name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!strcmp(type_str, \"voltage\")) {\n\t\t*mode_val |= (RTD_MODE_VOLTAGE & MODE_RTD_MASK)\n\t\t\t     << MODE_BIT_OFFSET_RTD(reg - 1);\n\t\t*mode_mask |= MODE_RTD_MASK << MODE_BIT_OFFSET_RTD(reg - 1);\n\t\treturn 0;\n\t}\n\n\tif (strcmp(type_str, \"temperature\")) {\n\t\tdev_err(dev, \"Invalid type '%s' for '%s'\\n\", type_str,\n\t\t\tnode->full_name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (reg == 3) {\n\t\t \n\t\tmd = RTD_MODE_THERMISTOR;\n\t} else {\n\t\tif (of_property_read_string(node, \"temperature-mode\",\n\t\t\t\t\t    &md_str)) {\n\t\t\tdev_err(dev, \"No mode for '%s'\\n\", node->full_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!strcmp(md_str, \"thermal-diode\"))\n\t\t\tmd = RTD_MODE_CURRENT;\n\t\telse if (!strcmp(md_str, \"thermistor\"))\n\t\t\tmd = RTD_MODE_THERMISTOR;\n\t\telse {\n\t\t\tdev_err(dev, \"Invalid mode '%s' for '%s'\\n\", md_str,\n\t\t\t\tnode->full_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t*mode_val |= (md & MODE_RTD_MASK) << MODE_BIT_OFFSET_RTD(reg - 1);\n\t*mode_mask |= MODE_RTD_MASK << MODE_BIT_OFFSET_RTD(reg - 1);\n\n\treturn 0;\n}\n\nstatic int nct7802_configure_channels(struct device *dev,\n\t\t\t\t      struct nct7802_data *data)\n{\n\t \n\tu8 mode_mask = MODE_LTD_EN, mode_val = MODE_LTD_EN;\n\tstruct device_node *node;\n\tint err;\n\n\tif (dev->of_node) {\n\t\tfor_each_child_of_node(dev->of_node, node) {\n\t\t\terr = nct7802_get_channel_config(dev, node, &mode_mask,\n\t\t\t\t\t\t\t &mode_val);\n\t\t\tif (err) {\n\t\t\t\tof_node_put(node);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn regmap_update_bits(data->regmap, REG_MODE, mode_mask, mode_val);\n}\n\nstatic int nct7802_init_chip(struct device *dev, struct nct7802_data *data)\n{\n\tint err;\n\n\t \n\terr = regmap_update_bits(data->regmap, REG_START, 0x01, 0x01);\n\tif (err)\n\t\treturn err;\n\n\terr = nct7802_configure_channels(dev, data);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn regmap_update_bits(data->regmap, REG_VMON_ENABLE, 0x03, 0x03);\n}\n\nstatic int nct7802_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct nct7802_data *data;\n\tstruct device *hwmon_dev;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &nct7802_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\tmutex_init(&data->access_lock);\n\tmutex_init(&data->in_alarm_lock);\n\n\tret = nct7802_init_chip(dev, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   nct7802_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const unsigned short nct7802_address_list[] = {\n\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, I2C_CLIENT_END\n};\n\nstatic const struct i2c_device_id nct7802_idtable[] = {\n\t{ \"nct7802\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, nct7802_idtable);\n\nstatic struct i2c_driver nct7802_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = DRVNAME,\n\t},\n\t.detect = nct7802_detect,\n\t.probe = nct7802_probe,\n\t.id_table = nct7802_idtable,\n\t.address_list = nct7802_address_list,\n};\n\nmodule_i2c_driver(nct7802_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"NCT7802Y Hardware Monitoring Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}