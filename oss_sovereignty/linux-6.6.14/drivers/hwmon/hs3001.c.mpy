{
  "module_name": "hs3001.c",
  "hash_id": "2a949663c75c1d9b4933db402bd513080ca0dceb384c4b40de7b0150f00f2764",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/hs3001.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n \n#define HS3001_WAKEUP_TIME\t100\t \n#define HS3001_8BIT_RESOLUTION\t550\t \n#define HS3001_10BIT_RESOLUTION\t1310\t \n#define HS3001_12BIT_RESOLUTION\t4500\t \n#define HS3001_14BIT_RESOLUTION\t16900\t \n\n#define HS3001_RESPONSE_LENGTH\t4\n\n#define HS3001_FIXPOINT_ARITH\t1000U\n\n#define HS3001_MASK_HUMIDITY_0X3FFF\tGENMASK(13, 0)\n#define HS3001_MASK_STATUS_0XC0\tGENMASK(7, 6)\n\n \n#define HS3001_DATA_VALID\t0x00\t \n#define HS3001_DATA_STALE\t0x01\t \n\nstruct hs3001_data {\n\tstruct i2c_client *client;\n\tstruct mutex i2c_lock;  \n\tu32 wait_time;\t\t \n\tint temperature;\t \n\tu32 humidity;\t\t \n};\n\nstatic int hs3001_extract_temperature(u16 raw)\n{\n\t \n\tu32 temp = (raw >> 2) * HS3001_FIXPOINT_ARITH * 165;\n\n\ttemp /= (1 << 14) - 1;\n\n\treturn (int)temp - 40 * HS3001_FIXPOINT_ARITH;\n}\n\nstatic u32 hs3001_extract_humidity(u16 raw)\n{\n\tu32 hum = (raw & HS3001_MASK_HUMIDITY_0X3FFF) * HS3001_FIXPOINT_ARITH * 100;\n\n\treturn hum /= (1 << 14) - 1;\n}\n\nstatic int hs3001_data_fetch_command(struct i2c_client *client,\n\t\t\t\t     struct hs3001_data *data)\n{\n\tint ret;\n\tu8 buf[HS3001_RESPONSE_LENGTH];\n\tu8 hs3001_status;\n\n\tret = i2c_master_recv(client, buf, HS3001_RESPONSE_LENGTH);\n\tif (ret != HS3001_RESPONSE_LENGTH) {\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Error in i2c communication. Error code: %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ths3001_status = FIELD_GET(HS3001_MASK_STATUS_0XC0, buf[0]);\n\tif (hs3001_status == HS3001_DATA_STALE) {\n\t\tdev_dbg(&client->dev, \"Sensor busy.\\n\");\n\t\treturn -EBUSY;\n\t}\n\tif (hs3001_status != HS3001_DATA_VALID) {\n\t\tdev_dbg(&client->dev, \"Data invalid.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdata->humidity =\n\t\ths3001_extract_humidity(be16_to_cpup((__be16 *)&buf[0]));\n\tdata->temperature =\n\t\ths3001_extract_temperature(be16_to_cpup((__be16 *)&buf[2]));\n\n\treturn 0;\n}\n\nstatic umode_t hs3001_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel)\n{\n\t \n\treturn 0444;\n}\n\nstatic int hs3001_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long *val)\n{\n\tstruct hs3001_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tmutex_lock(&data->i2c_lock);\n\tret = i2c_master_send(client, NULL, 0);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->i2c_lock);\n\t\treturn ret;\n\t}\n\n\t \n\tfsleep(data->wait_time);\n\n\tret = hs3001_data_fetch_command(client, data);\n\tmutex_unlock(&data->i2c_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\t*val = data->temperature;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase hwmon_humidity:\n\t\tswitch (attr) {\n\t\tcase hwmon_humidity_input:\n\t\t\t*val = data->humidity;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info *hs3001_info[] = {\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT),\n\tHWMON_CHANNEL_INFO(humidity, HWMON_H_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops hs3001_hwmon_ops = {\n\t.is_visible = hs3001_is_visible,\n\t.read = hs3001_read,\n};\n\nstatic const struct hwmon_chip_info hs3001_chip_info = {\n\t.ops = &hs3001_hwmon_ops,\n\t.info = hs3001_info,\n};\n\n \nstatic const struct i2c_device_id hs3001_ids[] = {\n\t{ \"hs3001\", 0 },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(i2c, hs3001_ids);\n\nstatic const struct of_device_id hs3001_of_match[] = {\n\t{.compatible = \"renesas,hs3001\"},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, hs3001_of_match);\n\nstatic int hs3001_probe(struct i2c_client *client)\n{\n\tstruct hs3001_data *data;\n\tstruct device *hwmon_dev;\n\tstruct device *dev = &client->dev;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -EOPNOTSUPP;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\n\t \n\tdata->wait_time = (HS3001_WAKEUP_TIME + HS3001_14BIT_RESOLUTION +\n\t\t\t   HS3001_14BIT_RESOLUTION);\n\n\tmutex_init(&data->i2c_lock);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev,\n\t\t\t\t\t\t\t client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &hs3001_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\tif (IS_ERR(hwmon_dev))\n\t\treturn dev_err_probe(dev, PTR_ERR(hwmon_dev),\n\t\t\t\t     \"Unable to register hwmon device.\\n\");\n\n\treturn 0;\n}\n\nstatic struct i2c_driver hs3001_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"hs3001\",\n\t\t   .of_match_table = hs3001_of_match,\n\t},\n\t.probe = hs3001_probe,\n\t.id_table = hs3001_ids,\n};\n\nmodule_i2c_driver(hs3001_i2c_driver);\n\nMODULE_AUTHOR(\"Andre Werner <andre.werner@systec-electronic.com>\");\nMODULE_DESCRIPTION(\"HS3001 humidity and temperature sensor base driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}