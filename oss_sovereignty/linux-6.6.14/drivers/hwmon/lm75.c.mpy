{
  "module_name": "lm75.c",
  "hash_id": "7508f389378b588d70140d2b2c9edd5a4b2cead32940b46b71f8baa97bd1c954",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lm75.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/util_macros.h>\n#include <linux/regulator/consumer.h>\n#include \"lm75.h\"\n\n \n\nenum lm75_type {\t\t \n\tadt75,\n\tat30ts74,\n\tds1775,\n\tds75,\n\tds7505,\n\tg751,\n\tlm75,\n\tlm75a,\n\tlm75b,\n\tmax6625,\n\tmax6626,\n\tmax31725,\n\tmcp980x,\n\tpct2075,\n\tstds75,\n\tstlm75,\n\ttcn75,\n\ttmp100,\n\ttmp101,\n\ttmp105,\n\ttmp112,\n\ttmp175,\n\ttmp275,\n\ttmp75,\n\ttmp75b,\n\ttmp75c,\n\ttmp1075,\n};\n\n \n\nstruct lm75_params {\n\tu8\t\t\tset_mask;\n\tu8\t\t\tclr_mask;\n\tu8\t\t\tdefault_resolution;\n\tu8\t\t\tresolution_limits;\n\tconst u8\t\t*resolutions;\n\tunsigned int\t\tdefault_sample_time;\n\tu8\t\t\tnum_sample_times;\n\tconst unsigned int\t*sample_times;\n};\n\n \nstatic const unsigned short normal_i2c[] = { 0x48, 0x49, 0x4a, 0x4b, 0x4c,\n\t\t\t\t\t0x4d, 0x4e, 0x4f, I2C_CLIENT_END };\n\n \n#define LM75_REG_TEMP\t\t0x00\n#define LM75_REG_CONF\t\t0x01\n#define LM75_REG_HYST\t\t0x02\n#define LM75_REG_MAX\t\t0x03\n#define PCT2075_REG_IDLE\t0x04\n\n \nstruct lm75_data {\n\tstruct i2c_client\t\t*client;\n\tstruct regmap\t\t\t*regmap;\n\tstruct regulator\t\t*vs;\n\tu8\t\t\t\torig_conf;\n\tu8\t\t\t\tcurrent_conf;\n\tu8\t\t\t\tresolution;\t \n\tunsigned int\t\t\tsample_time;\t \n\tenum lm75_type\t\t\tkind;\n\tconst struct lm75_params\t*params;\n};\n\n \n\nstatic const u8 lm75_sample_set_masks[] = { 0 << 5, 1 << 5, 2 << 5, 3 << 5 };\n\n#define LM75_SAMPLE_CLEAR_MASK\t(3 << 5)\n\n \nstatic const struct lm75_params device_params[] = {\n\t[adt75] = {\n\t\t.clr_mask = 1 << 5,\t \n\t\t.default_resolution = 12,\n\t\t.default_sample_time = MSEC_PER_SEC / 10,\n\t},\n\t[at30ts74] = {\n\t\t.set_mask = 3 << 5,\t \n\t\t.default_resolution = 12,\n\t\t.default_sample_time = 200,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 25, 50, 100, 200 },\n\t\t.resolutions = (u8 []) {9, 10, 11, 12 },\n\t},\n\t[ds1775] = {\n\t\t.clr_mask = 3 << 5,\n\t\t.set_mask = 2 << 5,\t \n\t\t.default_resolution = 11,\n\t\t.default_sample_time = 500,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 125, 250, 500, 1000 },\n\t\t.resolutions = (u8 []) {9, 10, 11, 12 },\n\t},\n\t[ds75] = {\n\t\t.clr_mask = 3 << 5,\n\t\t.set_mask = 2 << 5,\t \n\t\t.default_resolution = 11,\n\t\t.default_sample_time = 600,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 150, 300, 600, 1200 },\n\t\t.resolutions = (u8 []) {9, 10, 11, 12 },\n\t},\n\t[stds75] = {\n\t\t.clr_mask = 3 << 5,\n\t\t.set_mask = 2 << 5,\t \n\t\t.default_resolution = 11,\n\t\t.default_sample_time = 600,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 150, 300, 600, 1200 },\n\t\t.resolutions = (u8 []) {9, 10, 11, 12 },\n\t},\n\t[stlm75] = {\n\t\t.default_resolution = 9,\n\t\t.default_sample_time = MSEC_PER_SEC / 6,\n\t},\n\t[ds7505] = {\n\t\t.set_mask = 3 << 5,\t \n\t\t.default_resolution = 12,\n\t\t.default_sample_time = 200,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 25, 50, 100, 200 },\n\t\t.resolutions = (u8 []) {9, 10, 11, 12 },\n\t},\n\t[g751] = {\n\t\t.default_resolution = 9,\n\t\t.default_sample_time = MSEC_PER_SEC / 10,\n\t},\n\t[lm75] = {\n\t\t.default_resolution = 9,\n\t\t.default_sample_time = MSEC_PER_SEC / 10,\n\t},\n\t[lm75a] = {\n\t\t.default_resolution = 9,\n\t\t.default_sample_time = MSEC_PER_SEC / 10,\n\t},\n\t[lm75b] = {\n\t\t.default_resolution = 11,\n\t\t.default_sample_time = MSEC_PER_SEC / 10,\n\t},\n\t[max6625] = {\n\t\t.default_resolution = 9,\n\t\t.default_sample_time = MSEC_PER_SEC / 7,\n\t},\n\t[max6626] = {\n\t\t.default_resolution = 12,\n\t\t.default_sample_time = MSEC_PER_SEC / 7,\n\t\t.resolution_limits = 9,\n\t},\n\t[max31725] = {\n\t\t.default_resolution = 16,\n\t\t.default_sample_time = MSEC_PER_SEC / 20,\n\t},\n\t[tcn75] = {\n\t\t.default_resolution = 9,\n\t\t.default_sample_time = MSEC_PER_SEC / 18,\n\t},\n\t[pct2075] = {\n\t\t.default_resolution = 11,\n\t\t.default_sample_time = MSEC_PER_SEC / 10,\n\t\t.num_sample_times = 31,\n\t\t.sample_times = (unsigned int []){ 100, 200, 300, 400, 500, 600,\n\t\t700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700,\n\t\t1800, 1900, 2000, 2100, 2200, 2300, 2400, 2500, 2600, 2700,\n\t\t2800, 2900, 3000, 3100 },\n\t},\n\t[mcp980x] = {\n\t\t.set_mask = 3 << 5,\t \n\t\t.clr_mask = 1 << 7,\t \n\t\t.default_resolution = 12,\n\t\t.resolution_limits = 9,\n\t\t.default_sample_time = 240,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 30, 60, 120, 240 },\n\t\t.resolutions = (u8 []) {9, 10, 11, 12 },\n\t},\n\t[tmp100] = {\n\t\t.set_mask = 3 << 5,\t \n\t\t.clr_mask = 1 << 7,\t \n\t\t.default_resolution = 12,\n\t\t.default_sample_time = 320,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 40, 80, 160, 320 },\n\t\t.resolutions = (u8 []) {9, 10, 11, 12 },\n\t},\n\t[tmp101] = {\n\t\t.set_mask = 3 << 5,\t \n\t\t.clr_mask = 1 << 7,\t \n\t\t.default_resolution = 12,\n\t\t.default_sample_time = 320,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 40, 80, 160, 320 },\n\t\t.resolutions = (u8 []) {9, 10, 11, 12 },\n\t},\n\t[tmp105] = {\n\t\t.set_mask = 3 << 5,\t \n\t\t.clr_mask = 1 << 7,\t \n\t\t.default_resolution = 12,\n\t\t.default_sample_time = 220,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 28, 55, 110, 220 },\n\t\t.resolutions = (u8 []) {9, 10, 11, 12 },\n\t},\n\t[tmp112] = {\n\t\t.set_mask = 3 << 5,\t \n\t\t.clr_mask = 1 << 7,\t \n\t\t.default_resolution = 12,\n\t\t.default_sample_time = 125,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 125, 250, 1000, 4000 },\n\t},\n\t[tmp175] = {\n\t\t.set_mask = 3 << 5,\t \n\t\t.clr_mask = 1 << 7,\t \n\t\t.default_resolution = 12,\n\t\t.default_sample_time = 220,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 28, 55, 110, 220 },\n\t\t.resolutions = (u8 []) {9, 10, 11, 12 },\n\t},\n\t[tmp275] = {\n\t\t.set_mask = 3 << 5,\t \n\t\t.clr_mask = 1 << 7,\t \n\t\t.default_resolution = 12,\n\t\t.default_sample_time = 220,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 28, 55, 110, 220 },\n\t\t.resolutions = (u8 []) {9, 10, 11, 12 },\n\t},\n\t[tmp75] = {\n\t\t.set_mask = 3 << 5,\t \n\t\t.clr_mask = 1 << 7,\t \n\t\t.default_resolution = 12,\n\t\t.default_sample_time = 220,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 28, 55, 110, 220 },\n\t\t.resolutions = (u8 []) {9, 10, 11, 12 },\n\t},\n\t[tmp75b] = {  \n\t\t.clr_mask = 1 << 7 | 3 << 5,\n\t\t.default_resolution = 12,\n\t\t.default_sample_time = MSEC_PER_SEC / 37,\n\t\t.sample_times = (unsigned int []){ MSEC_PER_SEC / 37,\n\t\t\tMSEC_PER_SEC / 18,\n\t\t\tMSEC_PER_SEC / 9, MSEC_PER_SEC / 4 },\n\t\t.num_sample_times = 4,\n\t},\n\t[tmp75c] = {\n\t\t.clr_mask = 1 << 5,\t \n\t\t.default_resolution = 12,\n\t\t.default_sample_time = MSEC_PER_SEC / 12,\n\t},\n\t[tmp1075] = {  \n\t\t.clr_mask = 1 << 5 | 1 << 6 | 1 << 7,\n\t\t.default_resolution = 12,\n\t\t.default_sample_time = 28,\n\t\t.num_sample_times = 4,\n\t\t.sample_times = (unsigned int []){ 28, 55, 110, 220 },\n\t}\n};\n\nstatic inline long lm75_reg_to_mc(s16 temp, u8 resolution)\n{\n\treturn ((temp >> (16 - resolution)) * 1000) >> (resolution - 8);\n}\n\nstatic int lm75_write_config(struct lm75_data *data, u8 set_mask,\n\t\t\t     u8 clr_mask)\n{\n\tu8 value;\n\n\tclr_mask |= LM75_SHUTDOWN;\n\tvalue = data->current_conf & ~clr_mask;\n\tvalue |= set_mask;\n\n\tif (data->current_conf != value) {\n\t\ts32 err;\n\n\t\terr = i2c_smbus_write_byte_data(data->client, LM75_REG_CONF,\n\t\t\t\t\t\tvalue);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata->current_conf = value;\n\t}\n\treturn 0;\n}\n\nstatic int lm75_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t     u32 attr, int channel, long *val)\n{\n\tstruct lm75_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err, reg;\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\t*val = data->sample_time;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\treg = LM75_REG_TEMP;\n\t\t\tbreak;\n\t\tcase hwmon_temp_max:\n\t\t\treg = LM75_REG_MAX;\n\t\t\tbreak;\n\t\tcase hwmon_temp_max_hyst:\n\t\t\treg = LM75_REG_HYST;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = regmap_read(data->regmap, reg, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*val = lm75_reg_to_mc(regval, data->resolution);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int lm75_write_temp(struct device *dev, u32 attr, long temp)\n{\n\tstruct lm75_data *data = dev_get_drvdata(dev);\n\tu8 resolution;\n\tint reg;\n\n\tswitch (attr) {\n\tcase hwmon_temp_max:\n\t\treg = LM75_REG_MAX;\n\t\tbreak;\n\tcase hwmon_temp_max_hyst:\n\t\treg = LM75_REG_HYST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (data->params->resolution_limits)\n\t\tresolution = data->params->resolution_limits;\n\telse\n\t\tresolution = data->resolution;\n\n\ttemp = clamp_val(temp, LM75_TEMP_MIN, LM75_TEMP_MAX);\n\ttemp = DIV_ROUND_CLOSEST(temp  << (resolution - 8),\n\t\t\t\t 1000) << (16 - resolution);\n\n\treturn regmap_write(data->regmap, reg, (u16)temp);\n}\n\nstatic int lm75_update_interval(struct device *dev, long val)\n{\n\tstruct lm75_data *data = dev_get_drvdata(dev);\n\tunsigned int reg;\n\tu8 index;\n\ts32 err;\n\n\tindex = find_closest(val, data->params->sample_times,\n\t\t\t     (int)data->params->num_sample_times);\n\n\tswitch (data->kind) {\n\tdefault:\n\t\terr = lm75_write_config(data, lm75_sample_set_masks[index],\n\t\t\t\t\tLM75_SAMPLE_CLEAR_MASK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdata->sample_time = data->params->sample_times[index];\n\t\tif (data->params->resolutions)\n\t\t\tdata->resolution = data->params->resolutions[index];\n\t\tbreak;\n\tcase tmp112:\n\t\terr = regmap_read(data->regmap, LM75_REG_CONF, &reg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\treg &= ~0x00c0;\n\t\treg |= (3 - index) << 6;\n\t\terr = regmap_write(data->regmap, LM75_REG_CONF, reg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->sample_time = data->params->sample_times[index];\n\t\tbreak;\n\tcase pct2075:\n\t\terr = i2c_smbus_write_byte_data(data->client, PCT2075_REG_IDLE,\n\t\t\t\t\t\tindex + 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata->sample_time = data->params->sample_times[index];\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int lm75_write_chip(struct device *dev, u32 attr, long val)\n{\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\treturn lm75_update_interval(dev, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int lm75_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t      u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn lm75_write_chip(dev, attr, val);\n\tcase hwmon_temp:\n\t\treturn lm75_write_temp(dev, attr, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic umode_t lm75_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t       u32 attr, int channel)\n{\n\tconst struct lm75_data *config_data = data;\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\tif (config_data->params->num_sample_times > 1)\n\t\t\t\treturn 0644;\n\t\t\treturn 0444;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_max:\n\t\tcase hwmon_temp_max_hyst:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const lm75_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ | HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST),\n\tNULL\n};\n\nstatic const struct hwmon_ops lm75_hwmon_ops = {\n\t.is_visible = lm75_is_visible,\n\t.read = lm75_read,\n\t.write = lm75_write,\n};\n\nstatic const struct hwmon_chip_info lm75_chip_info = {\n\t.ops = &lm75_hwmon_ops,\n\t.info = lm75_info,\n};\n\nstatic bool lm75_is_writeable_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg != LM75_REG_TEMP;\n}\n\nstatic bool lm75_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg == LM75_REG_TEMP || reg == LM75_REG_CONF;\n}\n\nstatic const struct regmap_config lm75_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = PCT2075_REG_IDLE,\n\t.writeable_reg = lm75_is_writeable_reg,\n\t.volatile_reg = lm75_is_volatile_reg,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic void lm75_disable_regulator(void *data)\n{\n\tstruct lm75_data *lm75 = data;\n\n\tregulator_disable(lm75->vs);\n}\n\nstatic void lm75_remove(void *data)\n{\n\tstruct lm75_data *lm75 = data;\n\tstruct i2c_client *client = lm75->client;\n\n\ti2c_smbus_write_byte_data(client, LM75_REG_CONF, lm75->orig_conf);\n}\n\nstatic const struct i2c_device_id lm75_ids[];\n\nstatic int lm75_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct lm75_data *data;\n\tint status, err;\n\tenum lm75_type kind;\n\n\tif (client->dev.of_node)\n\t\tkind = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\tkind = i2c_match_id(lm75_ids, client)->driver_data;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\tI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EIO;\n\n\tdata = devm_kzalloc(dev, sizeof(struct lm75_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tdata->kind = kind;\n\n\tdata->vs = devm_regulator_get(dev, \"vs\");\n\tif (IS_ERR(data->vs))\n\t\treturn PTR_ERR(data->vs);\n\n\tdata->regmap = devm_regmap_init_i2c(client, &lm75_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\t \n\n\tdata->params = &device_params[data->kind];\n\n\t \n\tdata->sample_time = data->params->default_sample_time;\n\tdata->resolution = data->params->default_resolution;\n\n\t \n\terr = regulator_enable(data->vs);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable regulator: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_add_action_or_reset(dev, lm75_disable_regulator, data);\n\tif (err)\n\t\treturn err;\n\n\t \n\tstatus = i2c_smbus_read_byte_data(client, LM75_REG_CONF);\n\tif (status < 0) {\n\t\tdev_dbg(dev, \"Can't read config? %d\\n\", status);\n\t\treturn status;\n\t}\n\tdata->orig_conf = status;\n\tdata->current_conf = status;\n\n\terr = lm75_write_config(data, data->params->set_mask,\n\t\t\t\tdata->params->clr_mask);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_add_action_or_reset(dev, lm75_remove, data);\n\tif (err)\n\t\treturn err;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data, &lm75_chip_info,\n\t\t\t\t\t\t\t NULL);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdev_info(dev, \"%s: sensor '%s'\\n\", dev_name(hwmon_dev), client->name);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id lm75_ids[] = {\n\t{ \"adt75\", adt75, },\n\t{ \"at30ts74\", at30ts74, },\n\t{ \"ds1775\", ds1775, },\n\t{ \"ds75\", ds75, },\n\t{ \"ds7505\", ds7505, },\n\t{ \"g751\", g751, },\n\t{ \"lm75\", lm75, },\n\t{ \"lm75a\", lm75a, },\n\t{ \"lm75b\", lm75b, },\n\t{ \"max6625\", max6625, },\n\t{ \"max6626\", max6626, },\n\t{ \"max31725\", max31725, },\n\t{ \"max31726\", max31725, },\n\t{ \"mcp980x\", mcp980x, },\n\t{ \"pct2075\", pct2075, },\n\t{ \"stds75\", stds75, },\n\t{ \"stlm75\", stlm75, },\n\t{ \"tcn75\", tcn75, },\n\t{ \"tmp100\", tmp100, },\n\t{ \"tmp101\", tmp101, },\n\t{ \"tmp105\", tmp105, },\n\t{ \"tmp112\", tmp112, },\n\t{ \"tmp175\", tmp175, },\n\t{ \"tmp275\", tmp275, },\n\t{ \"tmp75\", tmp75, },\n\t{ \"tmp75b\", tmp75b, },\n\t{ \"tmp75c\", tmp75c, },\n\t{ \"tmp1075\", tmp1075, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, lm75_ids);\n\nstatic const struct of_device_id __maybe_unused lm75_of_match[] = {\n\t{\n\t\t.compatible = \"adi,adt75\",\n\t\t.data = (void *)adt75\n\t},\n\t{\n\t\t.compatible = \"atmel,at30ts74\",\n\t\t.data = (void *)at30ts74\n\t},\n\t{\n\t\t.compatible = \"dallas,ds1775\",\n\t\t.data = (void *)ds1775\n\t},\n\t{\n\t\t.compatible = \"dallas,ds75\",\n\t\t.data = (void *)ds75\n\t},\n\t{\n\t\t.compatible = \"dallas,ds7505\",\n\t\t.data = (void *)ds7505\n\t},\n\t{\n\t\t.compatible = \"gmt,g751\",\n\t\t.data = (void *)g751\n\t},\n\t{\n\t\t.compatible = \"national,lm75\",\n\t\t.data = (void *)lm75\n\t},\n\t{\n\t\t.compatible = \"national,lm75a\",\n\t\t.data = (void *)lm75a\n\t},\n\t{\n\t\t.compatible = \"national,lm75b\",\n\t\t.data = (void *)lm75b\n\t},\n\t{\n\t\t.compatible = \"maxim,max6625\",\n\t\t.data = (void *)max6625\n\t},\n\t{\n\t\t.compatible = \"maxim,max6626\",\n\t\t.data = (void *)max6626\n\t},\n\t{\n\t\t.compatible = \"maxim,max31725\",\n\t\t.data = (void *)max31725\n\t},\n\t{\n\t\t.compatible = \"maxim,max31726\",\n\t\t.data = (void *)max31725\n\t},\n\t{\n\t\t.compatible = \"maxim,mcp980x\",\n\t\t.data = (void *)mcp980x\n\t},\n\t{\n\t\t.compatible = \"nxp,pct2075\",\n\t\t.data = (void *)pct2075\n\t},\n\t{\n\t\t.compatible = \"st,stds75\",\n\t\t.data = (void *)stds75\n\t},\n\t{\n\t\t.compatible = \"st,stlm75\",\n\t\t.data = (void *)stlm75\n\t},\n\t{\n\t\t.compatible = \"microchip,tcn75\",\n\t\t.data = (void *)tcn75\n\t},\n\t{\n\t\t.compatible = \"ti,tmp100\",\n\t\t.data = (void *)tmp100\n\t},\n\t{\n\t\t.compatible = \"ti,tmp101\",\n\t\t.data = (void *)tmp101\n\t},\n\t{\n\t\t.compatible = \"ti,tmp105\",\n\t\t.data = (void *)tmp105\n\t},\n\t{\n\t\t.compatible = \"ti,tmp112\",\n\t\t.data = (void *)tmp112\n\t},\n\t{\n\t\t.compatible = \"ti,tmp175\",\n\t\t.data = (void *)tmp175\n\t},\n\t{\n\t\t.compatible = \"ti,tmp275\",\n\t\t.data = (void *)tmp275\n\t},\n\t{\n\t\t.compatible = \"ti,tmp75\",\n\t\t.data = (void *)tmp75\n\t},\n\t{\n\t\t.compatible = \"ti,tmp75b\",\n\t\t.data = (void *)tmp75b\n\t},\n\t{\n\t\t.compatible = \"ti,tmp75c\",\n\t\t.data = (void *)tmp75c\n\t},\n\t{\n\t\t.compatible = \"ti,tmp1075\",\n\t\t.data = (void *)tmp1075\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, lm75_of_match);\n\n#define LM75A_ID 0xA1\n\n \nstatic int lm75_detect(struct i2c_client *new_client,\n\t\t       struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = new_client->adapter;\n\tint i;\n\tint conf, hyst, os;\n\tbool is_lm75a = 0;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\t \n\n\t \n\tconf = i2c_smbus_read_byte_data(new_client, 1);\n\tif (conf & 0xe0)\n\t\treturn -ENODEV;\n\n\t \n\tif (i2c_smbus_read_byte_data(new_client, 7) == LM75A_ID) {\n\t\t \n\t\tif (i2c_smbus_read_byte_data(new_client, 4) != 0xff\n\t\t || i2c_smbus_read_byte_data(new_client, 5) != 0xff\n\t\t || i2c_smbus_read_byte_data(new_client, 6) != 0xff)\n\t\t\treturn -ENODEV;\n\t\tis_lm75a = 1;\n\t\thyst = i2c_smbus_read_byte_data(new_client, 2);\n\t\tos = i2c_smbus_read_byte_data(new_client, 3);\n\t} else {  \n\t\t \n\t\thyst = i2c_smbus_read_byte_data(new_client, 2);\n\t\tif (i2c_smbus_read_byte_data(new_client, 4) != hyst\n\t\t || i2c_smbus_read_byte_data(new_client, 5) != hyst\n\t\t || i2c_smbus_read_byte_data(new_client, 6) != hyst\n\t\t || i2c_smbus_read_byte_data(new_client, 7) != hyst)\n\t\t\treturn -ENODEV;\n\t\tos = i2c_smbus_read_byte_data(new_client, 3);\n\t\tif (i2c_smbus_read_byte_data(new_client, 4) != os\n\t\t || i2c_smbus_read_byte_data(new_client, 5) != os\n\t\t || i2c_smbus_read_byte_data(new_client, 6) != os\n\t\t || i2c_smbus_read_byte_data(new_client, 7) != os)\n\t\t\treturn -ENODEV;\n\t}\n\t \n\tif (hyst == 0 && os == 0)\n\t\treturn -ENODEV;\n\n\t \n\tfor (i = 8; i <= 248; i += 40) {\n\t\tif (i2c_smbus_read_byte_data(new_client, i + 1) != conf\n\t\t || i2c_smbus_read_byte_data(new_client, i + 2) != hyst\n\t\t || i2c_smbus_read_byte_data(new_client, i + 3) != os)\n\t\t\treturn -ENODEV;\n\t\tif (is_lm75a && i2c_smbus_read_byte_data(new_client, i + 7)\n\t\t\t\t!= LM75A_ID)\n\t\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, is_lm75a ? \"lm75a\" : \"lm75\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int lm75_suspend(struct device *dev)\n{\n\tint status;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tstatus = i2c_smbus_read_byte_data(client, LM75_REG_CONF);\n\tif (status < 0) {\n\t\tdev_dbg(&client->dev, \"Can't read config? %d\\n\", status);\n\t\treturn status;\n\t}\n\tstatus = status | LM75_SHUTDOWN;\n\ti2c_smbus_write_byte_data(client, LM75_REG_CONF, status);\n\treturn 0;\n}\n\nstatic int lm75_resume(struct device *dev)\n{\n\tint status;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tstatus = i2c_smbus_read_byte_data(client, LM75_REG_CONF);\n\tif (status < 0) {\n\t\tdev_dbg(&client->dev, \"Can't read config? %d\\n\", status);\n\t\treturn status;\n\t}\n\tstatus = status & ~LM75_SHUTDOWN;\n\ti2c_smbus_write_byte_data(client, LM75_REG_CONF, status);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops lm75_dev_pm_ops = {\n\t.suspend\t= lm75_suspend,\n\t.resume\t\t= lm75_resume,\n};\n#define LM75_DEV_PM_OPS (&lm75_dev_pm_ops)\n#else\n#define LM75_DEV_PM_OPS NULL\n#endif  \n\nstatic struct i2c_driver lm75_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"lm75\",\n\t\t.of_match_table = of_match_ptr(lm75_of_match),\n\t\t.pm\t= LM75_DEV_PM_OPS,\n\t},\n\t.probe\t\t= lm75_probe,\n\t.id_table\t= lm75_ids,\n\t.detect\t\t= lm75_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(lm75_driver);\n\nMODULE_AUTHOR(\"Frodo Looijaard <frodol@dds.nl>\");\nMODULE_DESCRIPTION(\"LM75 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}