{
  "module_name": "ad7414.c",
  "hash_id": "c398e9de1766516a7ddefad08ab6ac6172245678c8384f67d71f6db8f280ed97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ad7414.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n\n\n \n#define AD7414_REG_TEMP\t\t0x00\n#define AD7414_REG_CONF\t\t0x01\n#define AD7414_REG_T_HIGH\t0x02\n#define AD7414_REG_T_LOW\t0x03\n\nstatic u8 AD7414_REG_LIMIT[] = { AD7414_REG_T_HIGH, AD7414_REG_T_LOW };\n\nstruct ad7414_data {\n\tstruct i2c_client\t*client;\n\tstruct mutex\t\tlock;\t \n\tbool\t\t\tvalid;\t \n\tunsigned long\t\tnext_update;\t \n\ts16\t\t\ttemp_input;\t \n\ts8\t\t\ttemps[ARRAY_SIZE(AD7414_REG_LIMIT)];\n};\n\n \nstatic inline int ad7414_temp_from_reg(s16 reg)\n{\n\t \n\treturn ((int)reg / 64) * 250;\n}\n\nstatic inline int ad7414_read(struct i2c_client *client, u8 reg)\n{\n\tif (reg == AD7414_REG_TEMP)\n\t\treturn i2c_smbus_read_word_swapped(client, reg);\n\telse\n\t\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic inline int ad7414_write(struct i2c_client *client, u8 reg, u8 value)\n{\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic struct ad7414_data *ad7414_update_device(struct device *dev)\n{\n\tstruct ad7414_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tmutex_lock(&data->lock);\n\n\tif (time_after(jiffies, data->next_update) || !data->valid) {\n\t\tint value, i;\n\n\t\tdev_dbg(&client->dev, \"starting ad7414 update\\n\");\n\n\t\tvalue = ad7414_read(client, AD7414_REG_TEMP);\n\t\tif (value < 0)\n\t\t\tdev_dbg(&client->dev, \"AD7414_REG_TEMP err %d\\n\",\n\t\t\t\tvalue);\n\t\telse\n\t\t\tdata->temp_input = value;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(AD7414_REG_LIMIT); ++i) {\n\t\t\tvalue = ad7414_read(client, AD7414_REG_LIMIT[i]);\n\t\t\tif (value < 0)\n\t\t\t\tdev_dbg(&client->dev, \"AD7414 reg %d err %d\\n\",\n\t\t\t\t\tAD7414_REG_LIMIT[i], value);\n\t\t\telse\n\t\t\t\tdata->temps[i] = value;\n\t\t}\n\n\t\tdata->next_update = jiffies + HZ + HZ / 2;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn data;\n}\n\nstatic ssize_t temp_input_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct ad7414_data *data = ad7414_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", ad7414_temp_from_reg(data->temp_input));\n}\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp_input, 0);\n\nstatic ssize_t max_min_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tint index = to_sensor_dev_attr(attr)->index;\n\tstruct ad7414_data *data = ad7414_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->temps[index] * 1000);\n}\n\nstatic ssize_t max_min_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct ad7414_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint index = to_sensor_dev_attr(attr)->index;\n\tu8 reg = AD7414_REG_LIMIT[index];\n\tlong temp;\n\tint ret = kstrtol(buf, 10, &temp);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttemp = clamp_val(temp, -40000, 85000);\n\ttemp = (temp + (temp < 0 ? -500 : 500)) / 1000;\n\n\tmutex_lock(&data->lock);\n\tdata->temps[index] = temp;\n\tad7414_write(client, reg, temp);\n\tmutex_unlock(&data->lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, max_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, max_min, 1);\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tstruct ad7414_data *data = ad7414_update_device(dev);\n\tint value = (data->temp_input >> bitnr) & 1;\n\treturn sprintf(buf, \"%d\\n\", value);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_alarm, alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, alarm, 4);\n\nstatic struct attribute *ad7414_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(ad7414);\n\nstatic int ad7414_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ad7414_data *data;\n\tstruct device *hwmon_dev;\n\tint conf;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_READ_WORD_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tdata = devm_kzalloc(dev, sizeof(struct ad7414_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tdev_info(&client->dev, \"chip found\\n\");\n\n\t \n\tconf = i2c_smbus_read_byte_data(client, AD7414_REG_CONF);\n\tif (conf < 0)\n\t\tdev_warn(dev, \"ad7414_probe unable to read config register.\\n\");\n\telse {\n\t\tconf &= ~(1 << 7);\n\t\ti2c_smbus_write_byte_data(client, AD7414_REG_CONF, conf);\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev,\n\t\t\t\t\t\t\t   client->name,\n\t\t\t\t\t\t\t   data, ad7414_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id ad7414_id[] = {\n\t{ \"ad7414\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ad7414_id);\n\nstatic const struct of_device_id __maybe_unused ad7414_of_match[] = {\n\t{ .compatible = \"ad,ad7414\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ad7414_of_match);\n\nstatic struct i2c_driver ad7414_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7414\",\n\t\t.of_match_table = of_match_ptr(ad7414_of_match),\n\t},\n\t.probe = ad7414_probe,\n\t.id_table = ad7414_id,\n};\n\nmodule_i2c_driver(ad7414_driver);\n\nMODULE_AUTHOR(\"Stefan Roese <sr at denx.de>, \"\n\t      \"Frank Edelhaeuser <frank.edelhaeuser at spansion.com>\");\n\nMODULE_DESCRIPTION(\"AD7414 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}