{
  "module_name": "acpi_power_meter.c",
  "hash_id": "e94405b0f59bbcdc37da5c7386e81546f1162ecf29edc1e0659a76efc0e2c1e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/acpi_power_meter.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/dmi.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/err.h>\n#include <linux/acpi.h>\n\n#define ACPI_POWER_METER_NAME\t\t\"power_meter\"\n#define ACPI_POWER_METER_DEVICE_NAME\t\"Power Meter\"\n#define ACPI_POWER_METER_CLASS\t\t\"pwr_meter_resource\"\n\n#define NUM_SENSORS\t\t\t17\n\n#define POWER_METER_CAN_MEASURE\t(1 << 0)\n#define POWER_METER_CAN_TRIP\t(1 << 1)\n#define POWER_METER_CAN_CAP\t(1 << 2)\n#define POWER_METER_CAN_NOTIFY\t(1 << 3)\n#define POWER_METER_IS_BATTERY\t(1 << 8)\n#define UNKNOWN_HYSTERESIS\t0xFFFFFFFF\n#define UNKNOWN_POWER\t\t0xFFFFFFFF\n\n#define METER_NOTIFY_CONFIG\t0x80\n#define METER_NOTIFY_TRIP\t0x81\n#define METER_NOTIFY_CAP\t0x82\n#define METER_NOTIFY_CAPPING\t0x83\n#define METER_NOTIFY_INTERVAL\t0x84\n\n#define POWER_AVERAGE_NAME\t\"power1_average\"\n#define POWER_CAP_NAME\t\t\"power1_cap\"\n#define POWER_AVG_INTERVAL_NAME\t\"power1_average_interval\"\n#define POWER_ALARM_NAME\t\"power1_alarm\"\n\nstatic int cap_in_hardware;\nstatic bool force_cap_on;\n\nstatic int can_cap_in_hardware(void)\n{\n\treturn force_cap_on || cap_in_hardware;\n}\n\nstatic const struct acpi_device_id power_meter_ids[] = {\n\t{\"ACPI000D\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, power_meter_ids);\n\nstruct acpi_power_meter_capabilities {\n\tu64\t\tflags;\n\tu64\t\tunits;\n\tu64\t\ttype;\n\tu64\t\taccuracy;\n\tu64\t\tsampling_time;\n\tu64\t\tmin_avg_interval;\n\tu64\t\tmax_avg_interval;\n\tu64\t\thysteresis;\n\tu64\t\tconfigurable_cap;\n\tu64\t\tmin_cap;\n\tu64\t\tmax_cap;\n};\n\nstruct acpi_power_meter_resource {\n\tstruct acpi_device\t*acpi_dev;\n\tacpi_bus_id\t\tname;\n\tstruct mutex\t\tlock;\n\tstruct device\t\t*hwmon_dev;\n\tstruct acpi_power_meter_capabilities\tcaps;\n\tacpi_string\t\tmodel_number;\n\tacpi_string\t\tserial_number;\n\tacpi_string\t\toem_info;\n\tu64\t\tpower;\n\tu64\t\tcap;\n\tu64\t\tavg_interval;\n\tint\t\t\tsensors_valid;\n\tunsigned long\t\tsensors_last_updated;\n\tstruct sensor_device_attribute\tsensors[NUM_SENSORS];\n\tint\t\t\tnum_sensors;\n\ts64\t\t\ttrip[2];\n\tint\t\t\tnum_domain_devices;\n\tstruct acpi_device\t**domain_devices;\n\tstruct kobject\t\t*holders_dir;\n};\n\nstruct sensor_template {\n\tchar *label;\n\tssize_t (*show)(struct device *dev,\n\t\t\tstruct device_attribute *devattr,\n\t\t\tchar *buf);\n\tssize_t (*set)(struct device *dev,\n\t\t       struct device_attribute *devattr,\n\t\t       const char *buf, size_t count);\n\tint index;\n};\n\n \nstatic int update_avg_interval(struct acpi_power_meter_resource *resource)\n{\n\tunsigned long long data;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(resource->acpi_dev->handle, \"_GAI\",\n\t\t\t\t       NULL, &data);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(resource->acpi_dev->handle, \"_GAI\",\n\t\t\t\t\t     status);\n\t\treturn -ENODEV;\n\t}\n\n\tresource->avg_interval = data;\n\treturn 0;\n}\n\nstatic ssize_t show_avg_interval(struct device *dev,\n\t\t\t\t struct device_attribute *devattr,\n\t\t\t\t char *buf)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\n\n\tmutex_lock(&resource->lock);\n\tupdate_avg_interval(resource);\n\tmutex_unlock(&resource->lock);\n\n\treturn sprintf(buf, \"%llu\\n\", resource->avg_interval);\n}\n\nstatic ssize_t set_avg_interval(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\n\tunion acpi_object arg0 = { ACPI_TYPE_INTEGER };\n\tstruct acpi_object_list args = { 1, &arg0 };\n\tint res;\n\tunsigned long temp;\n\tunsigned long long data;\n\tacpi_status status;\n\n\tres = kstrtoul(buf, 10, &temp);\n\tif (res)\n\t\treturn res;\n\n\tif (temp > resource->caps.max_avg_interval ||\n\t    temp < resource->caps.min_avg_interval)\n\t\treturn -EINVAL;\n\targ0.integer.value = temp;\n\n\tmutex_lock(&resource->lock);\n\tstatus = acpi_evaluate_integer(resource->acpi_dev->handle, \"_PAI\",\n\t\t\t\t       &args, &data);\n\tif (ACPI_SUCCESS(status))\n\t\tresource->avg_interval = temp;\n\tmutex_unlock(&resource->lock);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(resource->acpi_dev->handle, \"_PAI\",\n\t\t\t\t\t     status);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (data)\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\n \nstatic int update_cap(struct acpi_power_meter_resource *resource)\n{\n\tunsigned long long data;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(resource->acpi_dev->handle, \"_GHL\",\n\t\t\t\t       NULL, &data);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(resource->acpi_dev->handle, \"_GHL\",\n\t\t\t\t\t     status);\n\t\treturn -ENODEV;\n\t}\n\n\tresource->cap = data;\n\treturn 0;\n}\n\nstatic ssize_t show_cap(struct device *dev,\n\t\t\tstruct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\n\n\tmutex_lock(&resource->lock);\n\tupdate_cap(resource);\n\tmutex_unlock(&resource->lock);\n\n\treturn sprintf(buf, \"%llu\\n\", resource->cap * 1000);\n}\n\nstatic ssize_t set_cap(struct device *dev, struct device_attribute *devattr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\n\tunion acpi_object arg0 = { ACPI_TYPE_INTEGER };\n\tstruct acpi_object_list args = { 1, &arg0 };\n\tint res;\n\tunsigned long temp;\n\tunsigned long long data;\n\tacpi_status status;\n\n\tres = kstrtoul(buf, 10, &temp);\n\tif (res)\n\t\treturn res;\n\n\ttemp = DIV_ROUND_CLOSEST(temp, 1000);\n\tif (temp > resource->caps.max_cap || temp < resource->caps.min_cap)\n\t\treturn -EINVAL;\n\targ0.integer.value = temp;\n\n\tmutex_lock(&resource->lock);\n\tstatus = acpi_evaluate_integer(resource->acpi_dev->handle, \"_SHL\",\n\t\t\t\t       &args, &data);\n\tif (ACPI_SUCCESS(status))\n\t\tresource->cap = temp;\n\tmutex_unlock(&resource->lock);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(resource->acpi_dev->handle, \"_SHL\",\n\t\t\t\t\t     status);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (data)\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\n \nstatic int set_acpi_trip(struct acpi_power_meter_resource *resource)\n{\n\tunion acpi_object arg_objs[] = {\n\t\t{ACPI_TYPE_INTEGER},\n\t\t{ACPI_TYPE_INTEGER}\n\t};\n\tstruct acpi_object_list args = { 2, arg_objs };\n\tunsigned long long data;\n\tacpi_status status;\n\n\t \n\tif (resource->trip[0] < 0 || resource->trip[1] < 0)\n\t\treturn 0;\n\n\t \n\targ_objs[0].integer.value = resource->trip[1];\n\targ_objs[1].integer.value = resource->trip[0];\n\n\tstatus = acpi_evaluate_integer(resource->acpi_dev->handle, \"_PTP\",\n\t\t\t\t       &args, &data);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(resource->acpi_dev->handle, \"_PTP\",\n\t\t\t\t\t     status);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (data)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic ssize_t set_trip(struct device *dev, struct device_attribute *devattr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\n\tint res;\n\tunsigned long temp;\n\n\tres = kstrtoul(buf, 10, &temp);\n\tif (res)\n\t\treturn res;\n\n\ttemp = DIV_ROUND_CLOSEST(temp, 1000);\n\n\tmutex_lock(&resource->lock);\n\tresource->trip[attr->index - 7] = temp;\n\tres = set_acpi_trip(resource);\n\tmutex_unlock(&resource->lock);\n\n\tif (res)\n\t\treturn res;\n\n\treturn count;\n}\n\n \nstatic int update_meter(struct acpi_power_meter_resource *resource)\n{\n\tunsigned long long data;\n\tacpi_status status;\n\tunsigned long local_jiffies = jiffies;\n\n\tif (time_before(local_jiffies, resource->sensors_last_updated +\n\t\t\tmsecs_to_jiffies(resource->caps.sampling_time)) &&\n\t\t\tresource->sensors_valid)\n\t\treturn 0;\n\n\tstatus = acpi_evaluate_integer(resource->acpi_dev->handle, \"_PMM\",\n\t\t\t\t       NULL, &data);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(resource->acpi_dev->handle, \"_PMM\",\n\t\t\t\t\t     status);\n\t\treturn -ENODEV;\n\t}\n\n\tresource->power = data;\n\tresource->sensors_valid = 1;\n\tresource->sensors_last_updated = jiffies;\n\treturn 0;\n}\n\nstatic ssize_t show_power(struct device *dev,\n\t\t\t  struct device_attribute *devattr,\n\t\t\t  char *buf)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\n\n\tmutex_lock(&resource->lock);\n\tupdate_meter(resource);\n\tmutex_unlock(&resource->lock);\n\n\tif (resource->power == UNKNOWN_POWER)\n\t\treturn -ENODATA;\n\n\treturn sprintf(buf, \"%llu\\n\", resource->power * 1000);\n}\n\n \nstatic ssize_t show_str(struct device *dev,\n\t\t\tstruct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\n\tacpi_string val;\n\tint ret;\n\n\tmutex_lock(&resource->lock);\n\tswitch (attr->index) {\n\tcase 0:\n\t\tval = resource->model_number;\n\t\tbreak;\n\tcase 1:\n\t\tval = resource->serial_number;\n\t\tbreak;\n\tcase 2:\n\t\tval = resource->oem_info;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Implementation error: unexpected attribute index %d\\n\",\n\t\t     attr->index);\n\t\tval = \"\";\n\t\tbreak;\n\t}\n\tret = sprintf(buf, \"%s\\n\", val);\n\tmutex_unlock(&resource->lock);\n\treturn ret;\n}\n\nstatic ssize_t show_val(struct device *dev,\n\t\t\tstruct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\n\tu64 val = 0;\n\n\tswitch (attr->index) {\n\tcase 0:\n\t\tval = resource->caps.min_avg_interval;\n\t\tbreak;\n\tcase 1:\n\t\tval = resource->caps.max_avg_interval;\n\t\tbreak;\n\tcase 2:\n\t\tval = resource->caps.min_cap * 1000;\n\t\tbreak;\n\tcase 3:\n\t\tval = resource->caps.max_cap * 1000;\n\t\tbreak;\n\tcase 4:\n\t\tif (resource->caps.hysteresis == UNKNOWN_HYSTERESIS)\n\t\t\treturn sprintf(buf, \"unknown\\n\");\n\n\t\tval = resource->caps.hysteresis * 1000;\n\t\tbreak;\n\tcase 5:\n\t\tif (resource->caps.flags & POWER_METER_IS_BATTERY)\n\t\t\tval = 1;\n\t\telse\n\t\t\tval = 0;\n\t\tbreak;\n\tcase 6:\n\t\tif (resource->power > resource->cap)\n\t\t\tval = 1;\n\t\telse\n\t\t\tval = 0;\n\t\tbreak;\n\tcase 7:\n\tcase 8:\n\t\tif (resource->trip[attr->index - 7] < 0)\n\t\t\treturn sprintf(buf, \"unknown\\n\");\n\n\t\tval = resource->trip[attr->index - 7] * 1000;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Implementation error: unexpected attribute index %d\\n\",\n\t\t     attr->index);\n\t\tbreak;\n\t}\n\n\treturn sprintf(buf, \"%llu\\n\", val);\n}\n\nstatic ssize_t show_accuracy(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     char *buf)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\n\tunsigned int acc = resource->caps.accuracy;\n\n\treturn sprintf(buf, \"%u.%u%%\\n\", acc / 1000, acc % 1000);\n}\n\nstatic ssize_t show_name(struct device *dev,\n\t\t\t struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", ACPI_POWER_METER_NAME);\n}\n\n#define RO_SENSOR_TEMPLATE(_label, _show, _index)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.label = _label,\t\t\t\\\n\t\t.show  = _show,\t\t\t\t\\\n\t\t.index = _index,\t\t\t\\\n\t}\n\n#define RW_SENSOR_TEMPLATE(_label, _show, _set, _index)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.label = _label,\t\t\t\\\n\t\t.show  = _show,\t\t\t\t\\\n\t\t.set   = _set,\t\t\t\t\\\n\t\t.index = _index,\t\t\t\\\n\t}\n\n \nstatic struct sensor_template meter_attrs[] = {\n\tRO_SENSOR_TEMPLATE(POWER_AVERAGE_NAME, show_power, 0),\n\tRO_SENSOR_TEMPLATE(\"power1_accuracy\", show_accuracy, 0),\n\tRO_SENSOR_TEMPLATE(\"power1_average_interval_min\", show_val, 0),\n\tRO_SENSOR_TEMPLATE(\"power1_average_interval_max\", show_val, 1),\n\tRO_SENSOR_TEMPLATE(\"power1_is_battery\", show_val, 5),\n\tRW_SENSOR_TEMPLATE(POWER_AVG_INTERVAL_NAME, show_avg_interval,\n\t\t\t   set_avg_interval, 0),\n\t{},\n};\n\nstatic struct sensor_template misc_cap_attrs[] = {\n\tRO_SENSOR_TEMPLATE(\"power1_cap_min\", show_val, 2),\n\tRO_SENSOR_TEMPLATE(\"power1_cap_max\", show_val, 3),\n\tRO_SENSOR_TEMPLATE(\"power1_cap_hyst\", show_val, 4),\n\tRO_SENSOR_TEMPLATE(POWER_ALARM_NAME, show_val, 6),\n\t{},\n};\n\nstatic struct sensor_template ro_cap_attrs[] = {\n\tRO_SENSOR_TEMPLATE(POWER_CAP_NAME, show_cap, 0),\n\t{},\n};\n\nstatic struct sensor_template rw_cap_attrs[] = {\n\tRW_SENSOR_TEMPLATE(POWER_CAP_NAME, show_cap, set_cap, 0),\n\t{},\n};\n\nstatic struct sensor_template trip_attrs[] = {\n\tRW_SENSOR_TEMPLATE(\"power1_average_min\", show_val, set_trip, 7),\n\tRW_SENSOR_TEMPLATE(\"power1_average_max\", show_val, set_trip, 8),\n\t{},\n};\n\nstatic struct sensor_template misc_attrs[] = {\n\tRO_SENSOR_TEMPLATE(\"name\", show_name, 0),\n\tRO_SENSOR_TEMPLATE(\"power1_model_number\", show_str, 0),\n\tRO_SENSOR_TEMPLATE(\"power1_oem_info\", show_str, 2),\n\tRO_SENSOR_TEMPLATE(\"power1_serial_number\", show_str, 1),\n\t{},\n};\n\n#undef RO_SENSOR_TEMPLATE\n#undef RW_SENSOR_TEMPLATE\n\n \nstatic void remove_domain_devices(struct acpi_power_meter_resource *resource)\n{\n\tint i;\n\n\tif (!resource->num_domain_devices)\n\t\treturn;\n\n\tfor (i = 0; i < resource->num_domain_devices; i++) {\n\t\tstruct acpi_device *obj = resource->domain_devices[i];\n\n\t\tif (!obj)\n\t\t\tcontinue;\n\n\t\tsysfs_remove_link(resource->holders_dir,\n\t\t\t\t  kobject_name(&obj->dev.kobj));\n\t\tacpi_dev_put(obj);\n\t}\n\n\tkfree(resource->domain_devices);\n\tkobject_put(resource->holders_dir);\n\tresource->num_domain_devices = 0;\n}\n\nstatic int read_domain_devices(struct acpi_power_meter_resource *resource)\n{\n\tint res = 0;\n\tint i;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *pss;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_object(resource->acpi_dev->handle, \"_PMD\", NULL,\n\t\t\t\t      &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(resource->acpi_dev->handle, \"_PMD\",\n\t\t\t\t\t     status);\n\t\treturn -ENODEV;\n\t}\n\n\tpss = buffer.pointer;\n\tif (!pss ||\n\t    pss->type != ACPI_TYPE_PACKAGE) {\n\t\tdev_err(&resource->acpi_dev->dev, ACPI_POWER_METER_NAME\n\t\t\t\"Invalid _PMD data\\n\");\n\t\tres = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tif (!pss->package.count)\n\t\tgoto end;\n\n\tresource->domain_devices = kcalloc(pss->package.count,\n\t\t\t\t\t   sizeof(struct acpi_device *),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!resource->domain_devices) {\n\t\tres = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tresource->holders_dir = kobject_create_and_add(\"measures\",\n\t\t\t\t\t\t       &resource->acpi_dev->dev.kobj);\n\tif (!resource->holders_dir) {\n\t\tres = -ENOMEM;\n\t\tgoto exit_free;\n\t}\n\n\tresource->num_domain_devices = pss->package.count;\n\n\tfor (i = 0; i < pss->package.count; i++) {\n\t\tstruct acpi_device *obj;\n\t\tunion acpi_object *element = &pss->package.elements[i];\n\n\t\t \n\t\tif (element->type != ACPI_TYPE_LOCAL_REFERENCE)\n\t\t\tcontinue;\n\n\t\t \n\t\tobj = acpi_get_acpi_dev(element->reference.handle);\n\t\tresource->domain_devices[i] = obj;\n\t\tif (!obj)\n\t\t\tcontinue;\n\n\t\tres = sysfs_create_link(resource->holders_dir, &obj->dev.kobj,\n\t\t\t\t\tkobject_name(&obj->dev.kobj));\n\t\tif (res) {\n\t\t\tacpi_dev_put(obj);\n\t\t\tresource->domain_devices[i] = NULL;\n\t\t}\n\t}\n\n\tres = 0;\n\tgoto end;\n\nexit_free:\n\tkfree(resource->domain_devices);\nend:\n\tkfree(buffer.pointer);\n\treturn res;\n}\n\n \nstatic int register_attrs(struct acpi_power_meter_resource *resource,\n\t\t\t  struct sensor_template *attrs)\n{\n\tstruct device *dev = &resource->acpi_dev->dev;\n\tstruct sensor_device_attribute *sensors =\n\t\t&resource->sensors[resource->num_sensors];\n\tint res = 0;\n\n\twhile (attrs->label) {\n\t\tsensors->dev_attr.attr.name = attrs->label;\n\t\tsensors->dev_attr.attr.mode = 0444;\n\t\tsensors->dev_attr.show = attrs->show;\n\t\tsensors->index = attrs->index;\n\n\t\tif (attrs->set) {\n\t\t\tsensors->dev_attr.attr.mode |= 0200;\n\t\t\tsensors->dev_attr.store = attrs->set;\n\t\t}\n\n\t\tsysfs_attr_init(&sensors->dev_attr.attr);\n\t\tres = device_create_file(dev, &sensors->dev_attr);\n\t\tif (res) {\n\t\t\tsensors->dev_attr.attr.name = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\tsensors++;\n\t\tresource->num_sensors++;\n\t\tattrs++;\n\t}\n\nerror:\n\treturn res;\n}\n\nstatic void remove_attrs(struct acpi_power_meter_resource *resource)\n{\n\tint i;\n\n\tfor (i = 0; i < resource->num_sensors; i++) {\n\t\tif (!resource->sensors[i].dev_attr.attr.name)\n\t\t\tcontinue;\n\t\tdevice_remove_file(&resource->acpi_dev->dev,\n\t\t\t\t   &resource->sensors[i].dev_attr);\n\t}\n\n\tremove_domain_devices(resource);\n\n\tresource->num_sensors = 0;\n}\n\nstatic int setup_attrs(struct acpi_power_meter_resource *resource)\n{\n\tint res = 0;\n\n\tres = read_domain_devices(resource);\n\tif (res)\n\t\treturn res;\n\n\tif (resource->caps.flags & POWER_METER_CAN_MEASURE) {\n\t\tres = register_attrs(resource, meter_attrs);\n\t\tif (res)\n\t\t\tgoto error;\n\t}\n\n\tif (resource->caps.flags & POWER_METER_CAN_CAP) {\n\t\tif (!can_cap_in_hardware()) {\n\t\t\tdev_warn(&resource->acpi_dev->dev,\n\t\t\t\t \"Ignoring unsafe software power cap!\\n\");\n\t\t\tgoto skip_unsafe_cap;\n\t\t}\n\n\t\tif (resource->caps.configurable_cap)\n\t\t\tres = register_attrs(resource, rw_cap_attrs);\n\t\telse\n\t\t\tres = register_attrs(resource, ro_cap_attrs);\n\n\t\tif (res)\n\t\t\tgoto error;\n\n\t\tres = register_attrs(resource, misc_cap_attrs);\n\t\tif (res)\n\t\t\tgoto error;\n\t}\n\nskip_unsafe_cap:\n\tif (resource->caps.flags & POWER_METER_CAN_TRIP) {\n\t\tres = register_attrs(resource, trip_attrs);\n\t\tif (res)\n\t\t\tgoto error;\n\t}\n\n\tres = register_attrs(resource, misc_attrs);\n\tif (res)\n\t\tgoto error;\n\n\treturn res;\nerror:\n\tremove_attrs(resource);\n\treturn res;\n}\n\nstatic void free_capabilities(struct acpi_power_meter_resource *resource)\n{\n\tacpi_string *str;\n\tint i;\n\n\tstr = &resource->model_number;\n\tfor (i = 0; i < 3; i++, str++) {\n\t\tkfree(*str);\n\t\t*str = NULL;\n\t}\n}\n\nstatic int read_capabilities(struct acpi_power_meter_resource *resource)\n{\n\tint res = 0;\n\tint i;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_buffer state = { 0, NULL };\n\tstruct acpi_buffer format = { sizeof(\"NNNNNNNNNNN\"), \"NNNNNNNNNNN\" };\n\tunion acpi_object *pss;\n\tacpi_string *str;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_object(resource->acpi_dev->handle, \"_PMC\", NULL,\n\t\t\t\t      &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(resource->acpi_dev->handle, \"_PMC\",\n\t\t\t\t\t     status);\n\t\treturn -ENODEV;\n\t}\n\n\tpss = buffer.pointer;\n\tif (!pss ||\n\t    pss->type != ACPI_TYPE_PACKAGE ||\n\t    pss->package.count != 14) {\n\t\tdev_err(&resource->acpi_dev->dev, ACPI_POWER_METER_NAME\n\t\t\t\"Invalid _PMC data\\n\");\n\t\tres = -EFAULT;\n\t\tgoto end;\n\t}\n\n\t \n\tstate.length = sizeof(struct acpi_power_meter_capabilities);\n\tstate.pointer = &resource->caps;\n\n\tstatus = acpi_extract_package(pss, &format, &state);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&resource->acpi_dev->dev, ACPI_POWER_METER_NAME\n\t\t\t\"_PMC package parsing failed: %s\\n\",\n\t\t\tacpi_format_exception(status));\n\t\tres = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tif (resource->caps.units) {\n\t\tdev_err(&resource->acpi_dev->dev, ACPI_POWER_METER_NAME\n\t\t\t\"Unknown units %llu.\\n\",\n\t\t\tresource->caps.units);\n\t\tres = -EINVAL;\n\t\tgoto end;\n\t}\n\n\t \n\tstr = &resource->model_number;\n\n\tfor (i = 11; i < 14; i++) {\n\t\tunion acpi_object *element = &pss->package.elements[i];\n\n\t\tif (element->type != ACPI_TYPE_STRING) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t*str = kcalloc(element->string.length + 1, sizeof(u8),\n\t\t\t       GFP_KERNEL);\n\t\tif (!*str) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tstrncpy(*str, element->string.pointer, element->string.length);\n\t\tstr++;\n\t}\n\n\tdev_info(&resource->acpi_dev->dev, \"Found ACPI power meter.\\n\");\n\tgoto end;\nerror:\n\tfree_capabilities(resource);\nend:\n\tkfree(buffer.pointer);\n\treturn res;\n}\n\n \nstatic void acpi_power_meter_notify(struct acpi_device *device, u32 event)\n{\n\tstruct acpi_power_meter_resource *resource;\n\tint res;\n\n\tif (!device || !acpi_driver_data(device))\n\t\treturn;\n\n\tresource = acpi_driver_data(device);\n\n\tswitch (event) {\n\tcase METER_NOTIFY_CONFIG:\n\t\tmutex_lock(&resource->lock);\n\t\tfree_capabilities(resource);\n\t\tres = read_capabilities(resource);\n\t\tmutex_unlock(&resource->lock);\n\t\tif (res)\n\t\t\tbreak;\n\n\t\tremove_attrs(resource);\n\t\tsetup_attrs(resource);\n\t\tbreak;\n\tcase METER_NOTIFY_TRIP:\n\t\tsysfs_notify(&device->dev.kobj, NULL, POWER_AVERAGE_NAME);\n\t\tbreak;\n\tcase METER_NOTIFY_CAP:\n\t\tsysfs_notify(&device->dev.kobj, NULL, POWER_CAP_NAME);\n\t\tbreak;\n\tcase METER_NOTIFY_INTERVAL:\n\t\tsysfs_notify(&device->dev.kobj, NULL, POWER_AVG_INTERVAL_NAME);\n\t\tbreak;\n\tcase METER_NOTIFY_CAPPING:\n\t\tsysfs_notify(&device->dev.kobj, NULL, POWER_ALARM_NAME);\n\t\tdev_info(&device->dev, \"Capping in progress.\\n\");\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unexpected event %d\\n\", event);\n\t\tbreak;\n\t}\n\n\tacpi_bus_generate_netlink_event(ACPI_POWER_METER_CLASS,\n\t\t\t\t\tdev_name(&device->dev), event, 0);\n}\n\nstatic int acpi_power_meter_add(struct acpi_device *device)\n{\n\tint res;\n\tstruct acpi_power_meter_resource *resource;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tresource = kzalloc(sizeof(*resource), GFP_KERNEL);\n\tif (!resource)\n\t\treturn -ENOMEM;\n\n\tresource->sensors_valid = 0;\n\tresource->acpi_dev = device;\n\tmutex_init(&resource->lock);\n\tstrcpy(acpi_device_name(device), ACPI_POWER_METER_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_POWER_METER_CLASS);\n\tdevice->driver_data = resource;\n\n\tres = read_capabilities(resource);\n\tif (res)\n\t\tgoto exit_free;\n\n\tresource->trip[0] = -1;\n\tresource->trip[1] = -1;\n\n\tres = setup_attrs(resource);\n\tif (res)\n\t\tgoto exit_free_capability;\n\n\tresource->hwmon_dev = hwmon_device_register(&device->dev);\n\tif (IS_ERR(resource->hwmon_dev)) {\n\t\tres = PTR_ERR(resource->hwmon_dev);\n\t\tgoto exit_remove;\n\t}\n\n\tres = 0;\n\tgoto exit;\n\nexit_remove:\n\tremove_attrs(resource);\nexit_free_capability:\n\tfree_capabilities(resource);\nexit_free:\n\tkfree(resource);\nexit:\n\treturn res;\n}\n\nstatic void acpi_power_meter_remove(struct acpi_device *device)\n{\n\tstruct acpi_power_meter_resource *resource;\n\n\tif (!device || !acpi_driver_data(device))\n\t\treturn;\n\n\tresource = acpi_driver_data(device);\n\thwmon_device_unregister(resource->hwmon_dev);\n\n\tremove_attrs(resource);\n\tfree_capabilities(resource);\n\n\tkfree(resource);\n}\n\nstatic int acpi_power_meter_resume(struct device *dev)\n{\n\tstruct acpi_power_meter_resource *resource;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tresource = acpi_driver_data(to_acpi_device(dev));\n\tif (!resource)\n\t\treturn -EINVAL;\n\n\tfree_capabilities(resource);\n\tread_capabilities(resource);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(acpi_power_meter_pm, NULL,\n\t\t\t\tacpi_power_meter_resume);\n\nstatic struct acpi_driver acpi_power_meter_driver = {\n\t.name = \"power_meter\",\n\t.class = ACPI_POWER_METER_CLASS,\n\t.ids = power_meter_ids,\n\t.ops = {\n\t\t.add = acpi_power_meter_add,\n\t\t.remove = acpi_power_meter_remove,\n\t\t.notify = acpi_power_meter_notify,\n\t\t},\n\t.drv.pm = pm_sleep_ptr(&acpi_power_meter_pm),\n};\n\n \nstatic int __init enable_cap_knobs(const struct dmi_system_id *d)\n{\n\tcap_in_hardware = 1;\n\treturn 0;\n}\n\nstatic const struct dmi_system_id pm_dmi_table[] __initconst = {\n\t{\n\t\tenable_cap_knobs, \"IBM Active Energy Manager\",\n\t\t{\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"IBM\")\n\t\t},\n\t},\n\t{}\n};\n\nstatic int __init acpi_power_meter_init(void)\n{\n\tint result;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\tdmi_check_system(pm_dmi_table);\n\n\tresult = acpi_bus_register_driver(&acpi_power_meter_driver);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn 0;\n}\n\nstatic void __exit acpi_power_meter_exit(void)\n{\n\tacpi_bus_unregister_driver(&acpi_power_meter_driver);\n}\n\nMODULE_AUTHOR(\"Darrick J. Wong <darrick.wong@oracle.com>\");\nMODULE_DESCRIPTION(\"ACPI 4.0 power meter driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(force_cap_on, bool, 0644);\nMODULE_PARM_DESC(force_cap_on, \"Enable power cap even it is unsafe to do so.\");\n\nmodule_init(acpi_power_meter_init);\nmodule_exit(acpi_power_meter_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}