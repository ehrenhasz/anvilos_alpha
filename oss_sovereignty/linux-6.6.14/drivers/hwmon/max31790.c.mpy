{
  "module_name": "max31790.c",
  "hash_id": "cbc973a46790585f84454e8829df9c9252e049cf06a21d6bd1fad0f09abf4fe5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max31790.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n \n#define MAX31790_REG_GLOBAL_CONFIG\t0x00\n#define MAX31790_REG_FAN_CONFIG(ch)\t(0x02 + (ch))\n#define MAX31790_REG_FAN_DYNAMICS(ch)\t(0x08 + (ch))\n#define MAX31790_REG_FAN_FAULT_STATUS2\t0x10\n#define MAX31790_REG_FAN_FAULT_STATUS1\t0x11\n#define MAX31790_REG_TACH_COUNT(ch)\t(0x18 + (ch) * 2)\n#define MAX31790_REG_PWM_DUTY_CYCLE(ch)\t(0x30 + (ch) * 2)\n#define MAX31790_REG_PWMOUT(ch)\t\t(0x40 + (ch) * 2)\n#define MAX31790_REG_TARGET_COUNT(ch)\t(0x50 + (ch) * 2)\n\n \n#define MAX31790_FAN_CFG_RPM_MODE\t0x80\n#define MAX31790_FAN_CFG_CTRL_MON\t0x10\n#define MAX31790_FAN_CFG_TACH_INPUT_EN\t0x08\n#define MAX31790_FAN_CFG_TACH_INPUT\t0x01\n\n \n#define MAX31790_FAN_DYN_SR_SHIFT\t5\n#define MAX31790_FAN_DYN_SR_MASK\t0xE0\n#define SR_FROM_REG(reg)\t\t(((reg) & MAX31790_FAN_DYN_SR_MASK) \\\n\t\t\t\t\t >> MAX31790_FAN_DYN_SR_SHIFT)\n\n#define FAN_RPM_MIN\t\t\t120\n#define FAN_RPM_MAX\t\t\t7864320\n\n#define FAN_COUNT_REG_MAX\t\t0xffe0\n\n#define RPM_FROM_REG(reg, sr)\t\t(((reg) >> 4) ? \\\n\t\t\t\t\t ((60 * (sr) * 8192) / ((reg) >> 4)) : \\\n\t\t\t\t\t FAN_RPM_MAX)\n#define RPM_TO_REG(rpm, sr)\t\t((60 * (sr) * 8192) / ((rpm) * 2))\n\n#define NR_CHANNEL\t\t\t6\n\n \nstruct max31790_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tbool valid;  \n\tunsigned long last_updated;  \n\n\t \n\tu8 fan_config[NR_CHANNEL];\n\tu8 fan_dynamics[NR_CHANNEL];\n\tu16 fault_status;\n\tu16 tach[NR_CHANNEL * 2];\n\tu16 pwm[NR_CHANNEL];\n\tu16 target_count[NR_CHANNEL];\n};\n\nstatic struct max31790_data *max31790_update_device(struct device *dev)\n{\n\tstruct max31790_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tstruct max31790_data *ret = data;\n\tint i;\n\tint rv;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\n\t\trv = i2c_smbus_read_byte_data(client,\n\t\t\t\tMAX31790_REG_FAN_FAULT_STATUS1);\n\t\tif (rv < 0)\n\t\t\tgoto abort;\n\t\tdata->fault_status |= rv & 0x3F;\n\n\t\trv = i2c_smbus_read_byte_data(client,\n\t\t\t\tMAX31790_REG_FAN_FAULT_STATUS2);\n\t\tif (rv < 0)\n\t\t\tgoto abort;\n\t\tdata->fault_status |= (rv & 0x3F) << 6;\n\n\t\tfor (i = 0; i < NR_CHANNEL; i++) {\n\t\t\trv = i2c_smbus_read_word_swapped(client,\n\t\t\t\t\tMAX31790_REG_TACH_COUNT(i));\n\t\t\tif (rv < 0)\n\t\t\t\tgoto abort;\n\t\t\tdata->tach[i] = rv;\n\n\t\t\tif (data->fan_config[i]\n\t\t\t    & MAX31790_FAN_CFG_TACH_INPUT) {\n\t\t\t\trv = i2c_smbus_read_word_swapped(client,\n\t\t\t\t\tMAX31790_REG_TACH_COUNT(NR_CHANNEL\n\t\t\t\t\t\t\t\t+ i));\n\t\t\t\tif (rv < 0)\n\t\t\t\t\tgoto abort;\n\t\t\t\tdata->tach[NR_CHANNEL + i] = rv;\n\t\t\t} else {\n\t\t\t\trv = i2c_smbus_read_word_swapped(client,\n\t\t\t\t\t\tMAX31790_REG_PWM_DUTY_CYCLE(i));\n\t\t\t\tif (rv < 0)\n\t\t\t\t\tgoto abort;\n\t\t\t\tdata->pwm[i] = rv;\n\n\t\t\t\trv = i2c_smbus_read_word_swapped(client,\n\t\t\t\t\t\tMAX31790_REG_TARGET_COUNT(i));\n\t\t\t\tif (rv < 0)\n\t\t\t\t\tgoto abort;\n\t\t\t\tdata->target_count[i] = rv;\n\t\t\t}\n\t\t}\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\tgoto done;\n\nabort:\n\tdata->valid = false;\n\tret = ERR_PTR(rv);\n\ndone:\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\nstatic const u8 tach_period[8] = { 1, 2, 4, 8, 16, 32, 32, 32 };\n\nstatic u8 get_tach_period(u8 fan_dynamics)\n{\n\treturn tach_period[SR_FROM_REG(fan_dynamics)];\n}\n\nstatic u8 bits_for_tach_period(int rpm)\n{\n\tu8 bits;\n\n\tif (rpm < 500)\n\t\tbits = 0x0;\n\telse if (rpm < 1000)\n\t\tbits = 0x1;\n\telse if (rpm < 2000)\n\t\tbits = 0x2;\n\telse if (rpm < 4000)\n\t\tbits = 0x3;\n\telse if (rpm < 8000)\n\t\tbits = 0x4;\n\telse\n\t\tbits = 0x5;\n\n\treturn bits;\n}\n\nstatic int max31790_read_fan(struct device *dev, u32 attr, int channel,\n\t\t\t     long *val)\n{\n\tstruct max31790_data *data = max31790_update_device(dev);\n\tint sr, rpm;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\t\tsr = get_tach_period(data->fan_dynamics[channel % NR_CHANNEL]);\n\t\tif (data->tach[channel] == FAN_COUNT_REG_MAX)\n\t\t\trpm = 0;\n\t\telse\n\t\t\trpm = RPM_FROM_REG(data->tach[channel], sr);\n\t\t*val = rpm;\n\t\treturn 0;\n\tcase hwmon_fan_target:\n\t\tsr = get_tach_period(data->fan_dynamics[channel]);\n\t\trpm = RPM_FROM_REG(data->target_count[channel], sr);\n\t\t*val = rpm;\n\t\treturn 0;\n\tcase hwmon_fan_fault:\n\t\tmutex_lock(&data->update_lock);\n\t\t*val = !!(data->fault_status & (1 << channel));\n\t\tdata->fault_status &= ~(1 << channel);\n\t\t \n\t\tif (*val) {\n\t\t\tint reg = MAX31790_REG_TARGET_COUNT(channel % NR_CHANNEL);\n\n\t\t\ti2c_smbus_write_byte_data(data->client, reg,\n\t\t\t\t\t\t  data->target_count[channel % NR_CHANNEL] >> 8);\n\t\t}\n\t\tmutex_unlock(&data->update_lock);\n\t\treturn 0;\n\tcase hwmon_fan_enable:\n\t\t*val = !!(data->fan_config[channel] & MAX31790_FAN_CFG_TACH_INPUT_EN);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int max31790_write_fan(struct device *dev, u32 attr, int channel,\n\t\t\t      long val)\n{\n\tstruct max31790_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint target_count;\n\tint err = 0;\n\tu8 bits, fan_config;\n\tint sr;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (attr) {\n\tcase hwmon_fan_target:\n\t\tval = clamp_val(val, FAN_RPM_MIN, FAN_RPM_MAX);\n\t\tbits = bits_for_tach_period(val);\n\t\tdata->fan_dynamics[channel] =\n\t\t\t((data->fan_dynamics[channel] &\n\t\t\t  ~MAX31790_FAN_DYN_SR_MASK) |\n\t\t\t (bits << MAX31790_FAN_DYN_SR_SHIFT));\n\t\terr = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tMAX31790_REG_FAN_DYNAMICS(channel),\n\t\t\t\t\tdata->fan_dynamics[channel]);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tsr = get_tach_period(data->fan_dynamics[channel]);\n\t\ttarget_count = RPM_TO_REG(val, sr);\n\t\ttarget_count = clamp_val(target_count, 0x1, 0x7FF);\n\n\t\tdata->target_count[channel] = target_count << 5;\n\n\t\terr = i2c_smbus_write_word_swapped(client,\n\t\t\t\t\tMAX31790_REG_TARGET_COUNT(channel),\n\t\t\t\t\tdata->target_count[channel]);\n\t\tbreak;\n\tcase hwmon_fan_enable:\n\t\tfan_config = data->fan_config[channel];\n\t\tif (val == 0) {\n\t\t\tfan_config &= ~MAX31790_FAN_CFG_TACH_INPUT_EN;\n\t\t} else if (val == 1) {\n\t\t\tfan_config |= MAX31790_FAN_CFG_TACH_INPUT_EN;\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (fan_config != data->fan_config[channel]) {\n\t\t\terr = i2c_smbus_write_byte_data(client, MAX31790_REG_FAN_CONFIG(channel),\n\t\t\t\t\t\t\tfan_config);\n\t\t\tif (!err)\n\t\t\t\tdata->fan_config[channel] = fan_config;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn err;\n}\n\nstatic umode_t max31790_fan_is_visible(const void *_data, u32 attr, int channel)\n{\n\tconst struct max31790_data *data = _data;\n\tu8 fan_config = data->fan_config[channel % NR_CHANNEL];\n\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\tcase hwmon_fan_fault:\n\t\tif (channel < NR_CHANNEL ||\n\t\t    (fan_config & MAX31790_FAN_CFG_TACH_INPUT))\n\t\t\treturn 0444;\n\t\treturn 0;\n\tcase hwmon_fan_target:\n\t\tif (channel < NR_CHANNEL &&\n\t\t    !(fan_config & MAX31790_FAN_CFG_TACH_INPUT))\n\t\t\treturn 0644;\n\t\treturn 0;\n\tcase hwmon_fan_enable:\n\t\tif (channel < NR_CHANNEL)\n\t\t\treturn 0644;\n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int max31790_read_pwm(struct device *dev, u32 attr, int channel,\n\t\t\t     long *val)\n{\n\tstruct max31790_data *data = max31790_update_device(dev);\n\tu8 fan_config;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tfan_config = data->fan_config[channel];\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\t*val = data->pwm[channel] >> 8;\n\t\treturn 0;\n\tcase hwmon_pwm_enable:\n\t\tif (fan_config & MAX31790_FAN_CFG_CTRL_MON)\n\t\t\t*val = 0;\n\t\telse if (fan_config & MAX31790_FAN_CFG_RPM_MODE)\n\t\t\t*val = 2;\n\t\telse\n\t\t\t*val = 1;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int max31790_write_pwm(struct device *dev, u32 attr, int channel,\n\t\t\t      long val)\n{\n\tstruct max31790_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 fan_config;\n\tint err = 0;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\tif (val < 0 || val > 255) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdata->valid = false;\n\t\terr = i2c_smbus_write_word_swapped(client,\n\t\t\t\t\t\t   MAX31790_REG_PWMOUT(channel),\n\t\t\t\t\t\t   val << 8);\n\t\tbreak;\n\tcase hwmon_pwm_enable:\n\t\tfan_config = data->fan_config[channel];\n\t\tif (val == 0) {\n\t\t\tfan_config |= MAX31790_FAN_CFG_CTRL_MON;\n\t\t\t \n\t\t\tfan_config &= ~MAX31790_FAN_CFG_RPM_MODE;\n\t\t} else if (val == 1) {\n\t\t\tfan_config &= ~(MAX31790_FAN_CFG_CTRL_MON | MAX31790_FAN_CFG_RPM_MODE);\n\t\t} else if (val == 2) {\n\t\t\tfan_config &= ~MAX31790_FAN_CFG_CTRL_MON;\n\t\t\t \n\t\t\tfan_config |= (MAX31790_FAN_CFG_RPM_MODE | MAX31790_FAN_CFG_TACH_INPUT_EN);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (fan_config != data->fan_config[channel]) {\n\t\t\terr = i2c_smbus_write_byte_data(client, MAX31790_REG_FAN_CONFIG(channel),\n\t\t\t\t\t\t\tfan_config);\n\t\t\tif (!err)\n\t\t\t\tdata->fan_config[channel] = fan_config;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn err;\n}\n\nstatic umode_t max31790_pwm_is_visible(const void *_data, u32 attr, int channel)\n{\n\tconst struct max31790_data *data = _data;\n\tu8 fan_config = data->fan_config[channel];\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\tcase hwmon_pwm_enable:\n\t\tif (!(fan_config & MAX31790_FAN_CFG_TACH_INPUT))\n\t\t\treturn 0644;\n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int max31790_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\treturn max31790_read_fan(dev, attr, channel, val);\n\tcase hwmon_pwm:\n\t\treturn max31790_read_pwm(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int max31790_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t  u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\treturn max31790_write_fan(dev, attr, channel, val);\n\tcase hwmon_pwm:\n\t\treturn max31790_write_pwm(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t max31790_is_visible(const void *data,\n\t\t\t\t   enum hwmon_sensor_types type,\n\t\t\t\t   u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\treturn max31790_fan_is_visible(data, attr, channel);\n\tcase hwmon_pwm:\n\t\treturn max31790_pwm_is_visible(data, attr, channel);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const max31790_info[] = {\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_TARGET | HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_INPUT | HWMON_F_TARGET | HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_INPUT | HWMON_F_TARGET | HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_INPUT | HWMON_F_TARGET | HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_INPUT | HWMON_F_TARGET | HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_INPUT | HWMON_F_TARGET | HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE),\n\tNULL\n};\n\nstatic const struct hwmon_ops max31790_hwmon_ops = {\n\t.is_visible = max31790_is_visible,\n\t.read = max31790_read,\n\t.write = max31790_write,\n};\n\nstatic const struct hwmon_chip_info max31790_chip_info = {\n\t.ops = &max31790_hwmon_ops,\n\t.info = max31790_info,\n};\n\nstatic int max31790_init_client(struct i2c_client *client,\n\t\t\t\tstruct max31790_data *data)\n{\n\tint i, rv;\n\n\tfor (i = 0; i < NR_CHANNEL; i++) {\n\t\trv = i2c_smbus_read_byte_data(client,\n\t\t\t\tMAX31790_REG_FAN_CONFIG(i));\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t\tdata->fan_config[i] = rv;\n\n\t\trv = i2c_smbus_read_byte_data(client,\n\t\t\t\tMAX31790_REG_FAN_DYNAMICS(i));\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t\tdata->fan_dynamics[i] = rv;\n\t}\n\n\treturn 0;\n}\n\nstatic int max31790_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &client->dev;\n\tstruct max31790_data *data;\n\tstruct device *hwmon_dev;\n\tint err;\n\n\tif (!i2c_check_functionality(adapter,\n\t\t\tI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(struct max31790_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\terr = max31790_init_client(client, data);\n\tif (err)\n\t\treturn err;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &max31790_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id max31790_id[] = {\n\t{ \"max31790\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max31790_id);\n\nstatic struct i2c_driver max31790_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.probe\t\t= max31790_probe,\n\t.driver = {\n\t\t.name\t= \"max31790\",\n\t},\n\t.id_table\t= max31790_id,\n};\n\nmodule_i2c_driver(max31790_driver);\n\nMODULE_AUTHOR(\"Il Han <corone.il.han@gmail.com>\");\nMODULE_DESCRIPTION(\"MAX31790 sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}