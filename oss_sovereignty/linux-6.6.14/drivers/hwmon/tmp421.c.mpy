{
  "module_name": "tmp421.c",
  "hash_id": "f46ae77894efcd2aff2fcc6554d8b633b0d0295a38f2719fc2f3a63521a55980",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/tmp421.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/sysfs.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x2a, 0x4c, 0x4d, 0x4e, 0x4f,\n\t\t\t\t\t     I2C_CLIENT_END };\n\nenum chips { tmp421, tmp422, tmp423, tmp441, tmp442 };\n\n#define MAX_CHANNELS\t\t\t\t4\n \n#define TMP421_STATUS_REG\t\t\t0x08\n#define TMP421_CONFIG_REG_1\t\t\t0x09\n#define TMP421_CONFIG_REG_2\t\t\t0x0A\n#define TMP421_CONFIG_REG_REN(x)\t\t(BIT(3 + (x)))\n#define TMP421_CONFIG_REG_REN_MASK\t\tGENMASK(6, 3)\n#define TMP421_CONVERSION_RATE_REG\t\t0x0B\n#define TMP421_N_FACTOR_REG_1\t\t\t0x21\n#define TMP421_MANUFACTURER_ID_REG\t\t0xFE\n#define TMP421_DEVICE_ID_REG\t\t\t0xFF\n\nstatic const u8 TMP421_TEMP_MSB[MAX_CHANNELS]\t= { 0x00, 0x01, 0x02, 0x03 };\nstatic const u8 TMP421_TEMP_LSB[MAX_CHANNELS]\t= { 0x10, 0x11, 0x12, 0x13 };\n\n \n#define TMP421_CONFIG_SHUTDOWN\t\t\t0x40\n#define TMP421_CONFIG_RANGE\t\t\t0x04\n\n \n#define TMP421_MANUFACTURER_ID\t\t\t0x55\n#define TMP421_DEVICE_ID\t\t\t0x21\n#define TMP422_DEVICE_ID\t\t\t0x22\n#define TMP423_DEVICE_ID\t\t\t0x23\n#define TMP441_DEVICE_ID\t\t\t0x41\n#define TMP442_DEVICE_ID\t\t\t0x42\n\nstatic const struct i2c_device_id tmp421_id[] = {\n\t{ \"tmp421\", 2 },\n\t{ \"tmp422\", 3 },\n\t{ \"tmp423\", 4 },\n\t{ \"tmp441\", 2 },\n\t{ \"tmp442\", 3 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tmp421_id);\n\nstatic const struct of_device_id __maybe_unused tmp421_of_match[] = {\n\t{\n\t\t.compatible = \"ti,tmp421\",\n\t\t.data = (void *)2\n\t},\n\t{\n\t\t.compatible = \"ti,tmp422\",\n\t\t.data = (void *)3\n\t},\n\t{\n\t\t.compatible = \"ti,tmp423\",\n\t\t.data = (void *)4\n\t},\n\t{\n\t\t.compatible = \"ti,tmp441\",\n\t\t.data = (void *)2\n\t},\n\t{\n\t\t.compatible = \"ti,tmp442\",\n\t\t.data = (void *)3\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tmp421_of_match);\n\nstruct tmp421_channel {\n\tconst char *label;\n\tbool enabled;\n\ts16 temp;\n};\n\nstruct tmp421_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tu32 temp_config[MAX_CHANNELS + 1];\n\tstruct hwmon_channel_info temp_info;\n\tconst struct hwmon_channel_info *info[2];\n\tstruct hwmon_chip_info chip;\n\tbool valid;\n\tunsigned long last_updated;\n\tunsigned long channels;\n\tu8 config;\n\tstruct tmp421_channel channel[MAX_CHANNELS];\n};\n\nstatic int temp_from_raw(u16 reg, bool extended)\n{\n\t \n\tint temp = reg & ~0xf;\n\n\tif (extended)\n\t\ttemp = temp - 64 * 256;\n\telse\n\t\ttemp = (s16)temp;\n\n\treturn DIV_ROUND_CLOSEST(temp * 1000, 256);\n}\n\nstatic int tmp421_update_device(struct tmp421_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + (HZ / 2)) ||\n\t    !data->valid) {\n\t\tret = i2c_smbus_read_byte_data(client, TMP421_CONFIG_REG_1);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t\tdata->config = ret;\n\n\t\tfor (i = 0; i < data->channels; i++) {\n\t\t\tret = i2c_smbus_read_byte_data(client, TMP421_TEMP_MSB[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t\tdata->channel[i].temp = ret << 8;\n\n\t\t\tret = i2c_smbus_read_byte_data(client, TMP421_TEMP_LSB[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t\tdata->channel[i].temp |= ret;\n\t\t}\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\nexit:\n\tmutex_unlock(&data->update_lock);\n\n\tif (ret < 0) {\n\t\tdata->valid = false;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tmp421_enable_channels(struct tmp421_data *data)\n{\n\tint err;\n\tstruct i2c_client *client = data->client;\n\tstruct device *dev = &client->dev;\n\tint old = i2c_smbus_read_byte_data(client, TMP421_CONFIG_REG_2);\n\tint new, i;\n\n\tif (old < 0) {\n\t\tdev_err(dev, \"error reading register, can't disable channels\\n\");\n\t\treturn old;\n\t}\n\n\tnew = old & ~TMP421_CONFIG_REG_REN_MASK;\n\tfor (i = 0; i < data->channels; i++)\n\t\tif (data->channel[i].enabled)\n\t\t\tnew |= TMP421_CONFIG_REG_REN(i);\n\n\tif (new == old)\n\t\treturn 0;\n\n\terr = i2c_smbus_write_byte_data(client, TMP421_CONFIG_REG_2, new);\n\tif (err < 0)\n\t\tdev_err(dev, \"error writing register, can't disable channels\\n\");\n\n\treturn err;\n}\n\nstatic int tmp421_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long *val)\n{\n\tstruct tmp421_data *tmp421 = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tret = tmp421_update_device(tmp421);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tif (!tmp421->channel[channel].enabled)\n\t\t\treturn -ENODATA;\n\t\t*val = temp_from_raw(tmp421->channel[channel].temp,\n\t\t\t\t     tmp421->config & TMP421_CONFIG_RANGE);\n\t\treturn 0;\n\tcase hwmon_temp_fault:\n\t\tif (!tmp421->channel[channel].enabled)\n\t\t\treturn -ENODATA;\n\t\t \n\t\t*val = !!(tmp421->channel[channel].temp & 0x03);\n\t\treturn 0;\n\tcase hwmon_temp_enable:\n\t\t*val = tmp421->channel[channel].enabled;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n}\n\nstatic int tmp421_read_string(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel, const char **str)\n{\n\tstruct tmp421_data *data = dev_get_drvdata(dev);\n\n\t*str = data->channel[channel].label;\n\n\treturn 0;\n}\n\nstatic int tmp421_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long val)\n{\n\tstruct tmp421_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_temp_enable:\n\t\tdata->channel[channel].enabled = val;\n\t\tret = tmp421_enable_channels(data);\n\t\tbreak;\n\tdefault:\n\t    ret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic umode_t tmp421_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_temp_fault:\n\tcase hwmon_temp_input:\n\t\treturn 0444;\n\tcase hwmon_temp_label:\n\t\treturn 0444;\n\tcase hwmon_temp_enable:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int tmp421_init_client(struct tmp421_data *data)\n{\n\tint config, config_orig;\n\tstruct i2c_client *client = data->client;\n\n\t \n\ti2c_smbus_write_byte_data(client, TMP421_CONVERSION_RATE_REG, 0x05);\n\n\t \n\tconfig = i2c_smbus_read_byte_data(client, TMP421_CONFIG_REG_1);\n\tif (config < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Could not read configuration register (%d)\\n\", config);\n\t\treturn config;\n\t}\n\n\tconfig_orig = config;\n\tconfig &= ~TMP421_CONFIG_SHUTDOWN;\n\n\tif (config != config_orig) {\n\t\tdev_info(&client->dev, \"Enable monitoring chip\\n\");\n\t\ti2c_smbus_write_byte_data(client, TMP421_CONFIG_REG_1, config);\n\t}\n\n\treturn tmp421_enable_channels(data);\n}\n\nstatic int tmp421_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info)\n{\n\tenum chips kind;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstatic const char * const names[] = {\n\t\t\"TMP421\", \"TMP422\", \"TMP423\",\n\t\t\"TMP441\", \"TMP442\"\n\t};\n\tint addr = client->addr;\n\tu8 reg;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_byte_data(client, TMP421_MANUFACTURER_ID_REG);\n\tif (reg != TMP421_MANUFACTURER_ID)\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_byte_data(client, TMP421_CONVERSION_RATE_REG);\n\tif (reg & 0xf8)\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_byte_data(client, TMP421_STATUS_REG);\n\tif (reg & 0x7f)\n\t\treturn -ENODEV;\n\n\treg = i2c_smbus_read_byte_data(client, TMP421_DEVICE_ID_REG);\n\tswitch (reg) {\n\tcase TMP421_DEVICE_ID:\n\t\tkind = tmp421;\n\t\tbreak;\n\tcase TMP422_DEVICE_ID:\n\t\tif (addr == 0x2a)\n\t\t\treturn -ENODEV;\n\t\tkind = tmp422;\n\t\tbreak;\n\tcase TMP423_DEVICE_ID:\n\t\tif (addr != 0x4c && addr != 0x4d)\n\t\t\treturn -ENODEV;\n\t\tkind = tmp423;\n\t\tbreak;\n\tcase TMP441_DEVICE_ID:\n\t\tkind = tmp441;\n\t\tbreak;\n\tcase TMP442_DEVICE_ID:\n\t\tif (addr != 0x4c && addr != 0x4d)\n\t\t\treturn -ENODEV;\n\t\tkind = tmp442;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, tmp421_id[kind].name, I2C_NAME_SIZE);\n\tdev_info(&adapter->dev, \"Detected TI %s chip at 0x%02x\\n\",\n\t\t names[kind], client->addr);\n\n\treturn 0;\n}\n\nstatic int tmp421_probe_child_from_dt(struct i2c_client *client,\n\t\t\t\t      struct device_node *child,\n\t\t\t\t      struct tmp421_data *data)\n\n{\n\tstruct device *dev = &client->dev;\n\tu32 i;\n\ts32 val;\n\tint err;\n\n\terr = of_property_read_u32(child, \"reg\", &i);\n\tif (err) {\n\t\tdev_err(dev, \"missing reg property of %pOFn\\n\", child);\n\t\treturn err;\n\t}\n\n\tif (i >= data->channels) {\n\t\tdev_err(dev, \"invalid reg %d of %pOFn\\n\", i, child);\n\t\treturn -EINVAL;\n\t}\n\n\tof_property_read_string(child, \"label\", &data->channel[i].label);\n\tif (data->channel[i].label)\n\t\tdata->temp_config[i] |= HWMON_T_LABEL;\n\n\tdata->channel[i].enabled = of_device_is_available(child);\n\n\terr = of_property_read_s32(child, \"ti,n-factor\", &val);\n\tif (!err) {\n\t\tif (i == 0) {\n\t\t\tdev_err(dev, \"n-factor can't be set for internal channel\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (val > 127 || val < -128) {\n\t\t\tdev_err(dev, \"n-factor for channel %d invalid (%d)\\n\",\n\t\t\t\ti, val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ti2c_smbus_write_byte_data(client, TMP421_N_FACTOR_REG_1 + i - 1,\n\t\t\t\t\t  val);\n\t}\n\n\treturn 0;\n}\n\nstatic int tmp421_probe_from_dt(struct i2c_client *client, struct tmp421_data *data)\n{\n\tstruct device *dev = &client->dev;\n\tconst struct device_node *np = dev->of_node;\n\tstruct device_node *child;\n\tint err;\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (strcmp(child->name, \"channel\"))\n\t\t\tcontinue;\n\n\t\terr = tmp421_probe_child_from_dt(client, child, data);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops tmp421_ops = {\n\t.is_visible = tmp421_is_visible,\n\t.read = tmp421_read,\n\t.read_string = tmp421_read_string,\n\t.write = tmp421_write,\n};\n\nstatic int tmp421_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct tmp421_data *data;\n\tint i, err;\n\n\tdata = devm_kzalloc(dev, sizeof(struct tmp421_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&data->update_lock);\n\tif (client->dev.of_node)\n\t\tdata->channels = (unsigned long)\n\t\t\tof_device_get_match_data(&client->dev);\n\telse\n\t\tdata->channels = i2c_match_id(tmp421_id, client)->driver_data;\n\tdata->client = client;\n\n\tfor (i = 0; i < data->channels; i++) {\n\t\tdata->temp_config[i] = HWMON_T_INPUT | HWMON_T_FAULT | HWMON_T_ENABLE;\n\t\tdata->channel[i].enabled = true;\n\t}\n\n\terr = tmp421_probe_from_dt(client, data);\n\tif (err)\n\t\treturn err;\n\n\terr = tmp421_init_client(data);\n\tif (err)\n\t\treturn err;\n\n\tdata->chip.ops = &tmp421_ops;\n\tdata->chip.info = data->info;\n\n\tdata->info[0] = &data->temp_info;\n\n\tdata->temp_info.type = hwmon_temp;\n\tdata->temp_info.config = data->temp_config;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &data->chip,\n\t\t\t\t\t\t\t NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic struct i2c_driver tmp421_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"tmp421\",\n\t\t.of_match_table = of_match_ptr(tmp421_of_match),\n\t},\n\t.probe = tmp421_probe,\n\t.id_table = tmp421_id,\n\t.detect = tmp421_detect,\n\t.address_list = normal_i2c,\n};\n\nmodule_i2c_driver(tmp421_driver);\n\nMODULE_AUTHOR(\"Andre Prendel <andre.prendel@gmx.de>\");\nMODULE_DESCRIPTION(\"Texas Instruments TMP421/422/423/441/442 temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}