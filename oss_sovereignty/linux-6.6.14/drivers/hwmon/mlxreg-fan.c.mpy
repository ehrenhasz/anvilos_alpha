{
  "module_name": "mlxreg-fan.c",
  "hash_id": "699bbcf7d60b693dc4f684676f9954615af3df6e084914145266ee6e6948cd3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/mlxreg-fan.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/hwmon.h>\n#include <linux/module.h>\n#include <linux/platform_data/mlxreg.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/thermal.h>\n\n#define MLXREG_FAN_MAX_TACHO\t\t24\n#define MLXREG_FAN_MAX_PWM\t\t4\n#define MLXREG_FAN_PWM_NOT_CONNECTED\t0xff\n#define MLXREG_FAN_MAX_STATE\t\t10\n#define MLXREG_FAN_MIN_DUTY\t\t51\t \n#define MLXREG_FAN_MAX_DUTY\t\t255\t \n#define MLXREG_FAN_SPEED_MIN_LEVEL\t\t2\t \n#define MLXREG_FAN_TACHO_SAMPLES_PER_PULSE_DEF\t44\n#define MLXREG_FAN_TACHO_DIV_MIN\t\t283\n#define MLXREG_FAN_TACHO_DIV_DEF\t\t(MLXREG_FAN_TACHO_DIV_MIN * 4)\n#define MLXREG_FAN_TACHO_DIV_SCALE_MAX\t64\n \n#define MLXREG_FAN_GET_RPM(rval, d, s)\t(DIV_ROUND_CLOSEST(15000000 * 100, \\\n\t\t\t\t\t ((rval) + (s)) * (d)))\n#define MLXREG_FAN_GET_FAULT(val, mask) ((val) == (mask))\n#define MLXREG_FAN_PWM_DUTY2STATE(duty)\t(DIV_ROUND_CLOSEST((duty) *\t\\\n\t\t\t\t\t MLXREG_FAN_MAX_STATE,\t\t\\\n\t\t\t\t\t MLXREG_FAN_MAX_DUTY))\n#define MLXREG_FAN_PWM_STATE2DUTY(stat)\t(DIV_ROUND_CLOSEST((stat) *\t\\\n\t\t\t\t\t MLXREG_FAN_MAX_DUTY,\t\t\\\n\t\t\t\t\t MLXREG_FAN_MAX_STATE))\n\nstruct mlxreg_fan;\n\n \nstruct mlxreg_fan_tacho {\n\tbool connected;\n\tu32 reg;\n\tu32 mask;\n\tu32 prsnt;\n};\n\n \nstruct mlxreg_fan_pwm {\n\tstruct mlxreg_fan *fan;\n\tbool connected;\n\tu32 reg;\n\tunsigned long last_hwmon_state;\n\tunsigned long last_thermal_state;\n\tstruct thermal_cooling_device *cdev;\n};\n\n \nstruct mlxreg_fan {\n\tstruct device *dev;\n\tvoid *regmap;\n\tstruct mlxreg_core_platform_data *pdata;\n\tstruct mlxreg_fan_tacho tacho[MLXREG_FAN_MAX_TACHO];\n\tstruct mlxreg_fan_pwm pwm[MLXREG_FAN_MAX_PWM];\n\tint tachos_per_drwr;\n\tint samples;\n\tint divider;\n};\n\nstatic int mlxreg_fan_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t    unsigned long state);\n\nstatic int\nmlxreg_fan_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\tint channel, long *val)\n{\n\tstruct mlxreg_fan *fan = dev_get_drvdata(dev);\n\tstruct mlxreg_fan_tacho *tacho;\n\tstruct mlxreg_fan_pwm *pwm;\n\tu32 regval;\n\tint err;\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\ttacho = &fan->tacho[channel];\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\t \n\t\t\tif (tacho->prsnt && fan->tachos_per_drwr) {\n\t\t\t\terr = regmap_read(fan->regmap, tacho->prsnt, &regval);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t \n\t\t\t\tif (BIT(channel / fan->tachos_per_drwr) & regval) {\n\t\t\t\t\t \n\t\t\t\t\t*val = 0;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr = regmap_read(fan->regmap, tacho->reg, &regval);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (MLXREG_FAN_GET_FAULT(regval, tacho->mask)) {\n\t\t\t\t \n\t\t\t\t*val = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t*val = MLXREG_FAN_GET_RPM(regval, fan->divider,\n\t\t\t\t\t\t  fan->samples);\n\t\t\tbreak;\n\n\t\tcase hwmon_fan_fault:\n\t\t\terr = regmap_read(fan->regmap, tacho->reg, &regval);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t*val = MLXREG_FAN_GET_FAULT(regval, tacho->mask);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_pwm:\n\t\tpwm = &fan->pwm[channel];\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\terr = regmap_read(fan->regmap, pwm->reg, &regval);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t*val = regval;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmlxreg_fan_write(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t int channel, long val)\n{\n\tstruct mlxreg_fan *fan = dev_get_drvdata(dev);\n\tstruct mlxreg_fan_pwm *pwm;\n\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\tif (val < MLXREG_FAN_MIN_DUTY ||\n\t\t\t    val > MLXREG_FAN_MAX_DUTY)\n\t\t\t\treturn -EINVAL;\n\t\t\tpwm = &fan->pwm[channel];\n\t\t\t \n\t\t\tif (IS_REACHABLE(CONFIG_THERMAL)) {\n\t\t\t\tpwm->last_hwmon_state = MLXREG_FAN_PWM_DUTY2STATE(val);\n\t\t\t\t \n\t\t\t\tif (pwm->last_hwmon_state >= pwm->last_thermal_state)\n\t\t\t\t\treturn mlxreg_fan_set_cur_state(pwm->cdev,\n\t\t\t\t\t\t\t\t\tpwm->last_hwmon_state);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn regmap_write(fan->regmap, pwm->reg, val);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic umode_t\nmlxreg_fan_is_visible(const void *data, enum hwmon_sensor_types type, u32 attr,\n\t\t      int channel)\n{\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\tif (!(((struct mlxreg_fan *)data)->tacho[channel].connected))\n\t\t\treturn 0;\n\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\tcase hwmon_fan_fault:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_pwm:\n\t\tif (!(((struct mlxreg_fan *)data)->pwm[channel].connected))\n\t\t\treturn 0;\n\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic char *mlxreg_fan_name[] = {\n\t\"mlxreg_fan\",\n\t\"mlxreg_fan1\",\n\t\"mlxreg_fan2\",\n\t\"mlxreg_fan3\",\n};\n\nstatic const struct hwmon_channel_info * const mlxreg_fan_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops mlxreg_fan_hwmon_hwmon_ops = {\n\t.is_visible = mlxreg_fan_is_visible,\n\t.read = mlxreg_fan_read,\n\t.write = mlxreg_fan_write,\n};\n\nstatic const struct hwmon_chip_info mlxreg_fan_hwmon_chip_info = {\n\t.ops = &mlxreg_fan_hwmon_hwmon_ops,\n\t.info = mlxreg_fan_hwmon_info,\n};\n\nstatic int mlxreg_fan_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t    unsigned long *state)\n{\n\t*state = MLXREG_FAN_MAX_STATE;\n\treturn 0;\n}\n\nstatic int mlxreg_fan_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t    unsigned long *state)\n\n{\n\tstruct mlxreg_fan_pwm *pwm = cdev->devdata;\n\tstruct mlxreg_fan *fan = pwm->fan;\n\tu32 regval;\n\tint err;\n\n\terr = regmap_read(fan->regmap, pwm->reg, &regval);\n\tif (err) {\n\t\tdev_err(fan->dev, \"Failed to query PWM duty\\n\");\n\t\treturn err;\n\t}\n\n\t*state = MLXREG_FAN_PWM_DUTY2STATE(regval);\n\n\treturn 0;\n}\n\nstatic int mlxreg_fan_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t    unsigned long state)\n\n{\n\tstruct mlxreg_fan_pwm *pwm = cdev->devdata;\n\tstruct mlxreg_fan *fan = pwm->fan;\n\tint err;\n\n\tif (state > MLXREG_FAN_MAX_STATE)\n\t\treturn -EINVAL;\n\n\t \n\tpwm->last_thermal_state = state;\n\n\tstate = max_t(unsigned long, state, pwm->last_hwmon_state);\n\terr = regmap_write(fan->regmap, pwm->reg,\n\t\t\t   MLXREG_FAN_PWM_STATE2DUTY(state));\n\tif (err) {\n\t\tdev_err(fan->dev, \"Failed to write PWM duty\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic const struct thermal_cooling_device_ops mlxreg_fan_cooling_ops = {\n\t.get_max_state\t= mlxreg_fan_get_max_state,\n\t.get_cur_state\t= mlxreg_fan_get_cur_state,\n\t.set_cur_state\t= mlxreg_fan_set_cur_state,\n};\n\nstatic int mlxreg_fan_connect_verify(struct mlxreg_fan *fan,\n\t\t\t\t     struct mlxreg_core_data *data)\n{\n\tu32 regval;\n\tint err;\n\n\terr = regmap_read(fan->regmap, data->capability, &regval);\n\tif (err) {\n\t\tdev_err(fan->dev, \"Failed to query capability register 0x%08x\\n\",\n\t\t\tdata->capability);\n\t\treturn err;\n\t}\n\n\treturn !!(regval & data->bit);\n}\n\nstatic int mlxreg_pwm_connect_verify(struct mlxreg_fan *fan,\n\t\t\t\t     struct mlxreg_core_data *data)\n{\n\tu32 regval;\n\tint err;\n\n\terr = regmap_read(fan->regmap, data->reg, &regval);\n\tif (err) {\n\t\tdev_err(fan->dev, \"Failed to query pwm register 0x%08x\\n\",\n\t\t\tdata->reg);\n\t\treturn err;\n\t}\n\n\treturn regval != MLXREG_FAN_PWM_NOT_CONNECTED;\n}\n\nstatic int mlxreg_fan_speed_divider_get(struct mlxreg_fan *fan,\n\t\t\t\t\tstruct mlxreg_core_data *data)\n{\n\tu32 regval;\n\tint err;\n\n\terr = regmap_read(fan->regmap, data->capability, &regval);\n\tif (err) {\n\t\tdev_err(fan->dev, \"Failed to query capability register 0x%08x\\n\",\n\t\t\tdata->capability);\n\t\treturn err;\n\t}\n\n\t \n\tif (regval > 0 && regval <= MLXREG_FAN_TACHO_DIV_SCALE_MAX)\n\t\tfan->divider = regval * MLXREG_FAN_TACHO_DIV_MIN;\n\n\treturn 0;\n}\n\nstatic int mlxreg_fan_config(struct mlxreg_fan *fan,\n\t\t\t     struct mlxreg_core_platform_data *pdata)\n{\n\tint tacho_num = 0, tacho_avail = 0, pwm_num = 0, i;\n\tstruct mlxreg_core_data *data = pdata->data;\n\tbool configured = false;\n\tint err;\n\n\tfan->samples = MLXREG_FAN_TACHO_SAMPLES_PER_PULSE_DEF;\n\tfan->divider = MLXREG_FAN_TACHO_DIV_DEF;\n\tfor (i = 0; i < pdata->counter; i++, data++) {\n\t\tif (strnstr(data->label, \"tacho\", sizeof(data->label))) {\n\t\t\tif (tacho_num == MLXREG_FAN_MAX_TACHO) {\n\t\t\t\tdev_err(fan->dev, \"too many tacho entries: %s\\n\",\n\t\t\t\t\tdata->label);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (data->capability) {\n\t\t\t\terr = mlxreg_fan_connect_verify(fan, data);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\telse if (!err) {\n\t\t\t\t\ttacho_num++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfan->tacho[tacho_num].reg = data->reg;\n\t\t\tfan->tacho[tacho_num].mask = data->mask;\n\t\t\tfan->tacho[tacho_num].prsnt = data->reg_prsnt;\n\t\t\tfan->tacho[tacho_num++].connected = true;\n\t\t\ttacho_avail++;\n\t\t} else if (strnstr(data->label, \"pwm\", sizeof(data->label))) {\n\t\t\tif (pwm_num == MLXREG_FAN_MAX_TACHO) {\n\t\t\t\tdev_err(fan->dev, \"too many pwm entries: %s\\n\",\n\t\t\t\t\tdata->label);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (pwm_num) {\n\t\t\t\terr = mlxreg_pwm_connect_verify(fan, data);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\telse if (!err)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfan->pwm[pwm_num].reg = data->reg;\n\t\t\tfan->pwm[pwm_num].connected = true;\n\t\t\tpwm_num++;\n\t\t} else if (strnstr(data->label, \"conf\", sizeof(data->label))) {\n\t\t\tif (configured) {\n\t\t\t\tdev_err(fan->dev, \"duplicate conf entry: %s\\n\",\n\t\t\t\t\tdata->label);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tif (!data->mask && !data->bit && !data->capability) {\n\t\t\t\tdev_err(fan->dev, \"invalid conf entry params: %s\\n\",\n\t\t\t\t\tdata->label);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (data->capability) {\n\t\t\t\terr = mlxreg_fan_speed_divider_get(fan, data);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\tif (data->mask)\n\t\t\t\t\tfan->samples = data->mask;\n\t\t\t\tif (data->bit)\n\t\t\t\t\tfan->divider = data->bit;\n\t\t\t}\n\t\t\tconfigured = true;\n\t\t} else {\n\t\t\tdev_err(fan->dev, \"invalid label: %s\\n\", data->label);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (pdata->capability) {\n\t\tint drwr_avail;\n\t\tu32 regval;\n\n\t\t \n\t\terr = regmap_read(fan->regmap, pdata->capability, &regval);\n\t\tif (err) {\n\t\t\tdev_err(fan->dev, \"Failed to query capability register 0x%08x\\n\",\n\t\t\t\tpdata->capability);\n\t\t\treturn err;\n\t\t}\n\n\t\tdrwr_avail = hweight32(regval);\n\t\tif (!tacho_avail || !drwr_avail || tacho_avail < drwr_avail) {\n\t\t\tdev_err(fan->dev, \"Configuration is invalid: drawers num %d tachos num %d\\n\",\n\t\t\t\tdrwr_avail, tacho_avail);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tfan->tachos_per_drwr = tacho_avail / drwr_avail;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxreg_fan_cooling_config(struct device *dev, struct mlxreg_fan *fan)\n{\n\tint i;\n\n\tfor (i = 0; i < MLXREG_FAN_MAX_PWM; i++) {\n\t\tstruct mlxreg_fan_pwm *pwm = &fan->pwm[i];\n\n\t\tif (!pwm->connected)\n\t\t\tcontinue;\n\t\tpwm->fan = fan;\n\t\tpwm->cdev = devm_thermal_of_cooling_device_register(dev, NULL, mlxreg_fan_name[i],\n\t\t\t\t\t\t\t\t    pwm, &mlxreg_fan_cooling_ops);\n\t\tif (IS_ERR(pwm->cdev)) {\n\t\t\tdev_err(dev, \"Failed to register cooling device\\n\");\n\t\t\treturn PTR_ERR(pwm->cdev);\n\t\t}\n\n\t\t \n\t\tpwm->last_hwmon_state = MLXREG_FAN_PWM_DUTY2STATE(MLXREG_FAN_MIN_DUTY);\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxreg_fan_probe(struct platform_device *pdev)\n{\n\tstruct mlxreg_core_platform_data *pdata;\n\tstruct device *dev = &pdev->dev;\n\tstruct mlxreg_fan *fan;\n\tstruct device *hwm;\n\tint err;\n\n\tpdata = dev_get_platdata(dev);\n\tif (!pdata) {\n\t\tdev_err(dev, \"Failed to get platform data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfan = devm_kzalloc(dev, sizeof(*fan), GFP_KERNEL);\n\tif (!fan)\n\t\treturn -ENOMEM;\n\n\tfan->dev = dev;\n\tfan->regmap = pdata->regmap;\n\n\terr = mlxreg_fan_config(fan, pdata);\n\tif (err)\n\t\treturn err;\n\n\thwm = devm_hwmon_device_register_with_info(dev, \"mlxreg_fan\",\n\t\t\t\t\t\t   fan,\n\t\t\t\t\t\t   &mlxreg_fan_hwmon_chip_info,\n\t\t\t\t\t\t   NULL);\n\tif (IS_ERR(hwm)) {\n\t\tdev_err(dev, \"Failed to register hwmon device\\n\");\n\t\treturn PTR_ERR(hwm);\n\t}\n\n\tif (IS_REACHABLE(CONFIG_THERMAL))\n\t\terr = mlxreg_fan_cooling_config(dev, fan);\n\n\treturn err;\n}\n\nstatic struct platform_driver mlxreg_fan_driver = {\n\t.driver = {\n\t    .name = \"mlxreg-fan\",\n\t},\n\t.probe = mlxreg_fan_probe,\n};\n\nmodule_platform_driver(mlxreg_fan_driver);\n\nMODULE_AUTHOR(\"Vadim Pasternak <vadimp@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox FAN driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mlxreg-fan\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}