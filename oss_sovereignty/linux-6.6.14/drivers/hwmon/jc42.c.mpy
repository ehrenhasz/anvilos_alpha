{
  "module_name": "jc42.c",
  "hash_id": "8a06bd36a4dc088ed59ce19e78811c3cd38e9d50272b8ba8922c43b4f096bd94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/jc42.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n \nstatic const unsigned short normal_i2c[] = {\n\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, I2C_CLIENT_END };\n\n \n#define JC42_REG_CAP\t\t0x00\n#define JC42_REG_CONFIG\t\t0x01\n#define JC42_REG_TEMP_UPPER\t0x02\n#define JC42_REG_TEMP_LOWER\t0x03\n#define JC42_REG_TEMP_CRITICAL\t0x04\n#define JC42_REG_TEMP\t\t0x05\n#define JC42_REG_MANID\t\t0x06\n#define JC42_REG_DEVICEID\t0x07\n#define JC42_REG_SMBUS\t\t0x22  \n\n \n#define JC42_ALARM_CRIT\t\tBIT(15)\n#define JC42_ALARM_MAX\t\tBIT(14)\n#define JC42_ALARM_MIN\t\tBIT(13)\n\n \n#define JC42_CFG_CRIT_ONLY\tBIT(2)\n#define JC42_CFG_TCRIT_LOCK\tBIT(6)\n#define JC42_CFG_EVENT_LOCK\tBIT(7)\n#define JC42_CFG_SHUTDOWN\tBIT(8)\n#define JC42_CFG_HYST_MASK\tGENMASK(10, 9)\n\n \n#define JC42_CAP_RANGE\t\tBIT(2)\n\n \n#define ADT_MANID\t\t0x11d4   \n#define ATMEL_MANID\t\t0x001f   \n#define ATMEL_MANID2\t\t0x1114\t \n#define MAX_MANID\t\t0x004d   \n#define IDT_MANID\t\t0x00b3   \n#define MCP_MANID\t\t0x0054   \n#define NXP_MANID\t\t0x1131   \n#define ONS_MANID\t\t0x1b09   \n#define STM_MANID\t\t0x104a   \n#define GT_MANID\t\t0x1c68\t \n#define GT_MANID2\t\t0x132d\t \n#define SI_MANID\t\t0x1c85\t \n\n \n#define SMBUS_STMOUT\t\tBIT(7)   \n\n \n\n \n#define ADT7408_DEVID\t\t0x0801\n#define ADT7408_DEVID_MASK\t0xffff\n\n \n#define AT30TS00_DEVID\t\t0x8201\n#define AT30TS00_DEVID_MASK\t0xffff\n\n#define AT30TSE004_DEVID\t0x2200\n#define AT30TSE004_DEVID_MASK\t0xffff\n\n \n#define GT30TS00_DEVID\t\t0x2200\n#define GT30TS00_DEVID_MASK\t0xff00\n\n#define GT34TS02_DEVID\t\t0x3300\n#define GT34TS02_DEVID_MASK\t0xff00\n\n \n#define TSE2004_DEVID\t\t0x2200\n#define TSE2004_DEVID_MASK\t0xff00\n\n#define TS3000_DEVID\t\t0x2900   \n#define TS3000_DEVID_MASK\t0xff00\n\n#define TS3001_DEVID\t\t0x3000\n#define TS3001_DEVID_MASK\t0xff00\n\n \n#define MAX6604_DEVID\t\t0x3e00\n#define MAX6604_DEVID_MASK\t0xffff\n\n \n#define MCP9804_DEVID\t\t0x0200\n#define MCP9804_DEVID_MASK\t0xfffc\n\n#define MCP9808_DEVID\t\t0x0400\n#define MCP9808_DEVID_MASK\t0xfffc\n\n#define MCP98242_DEVID\t\t0x2000\n#define MCP98242_DEVID_MASK\t0xfffc\n\n#define MCP98243_DEVID\t\t0x2100\n#define MCP98243_DEVID_MASK\t0xfffc\n\n#define MCP98244_DEVID\t\t0x2200\n#define MCP98244_DEVID_MASK\t0xfffc\n\n#define MCP9843_DEVID\t\t0x0000\t \n#define MCP9843_DEVID_MASK\t0xfffe\n\n \n#define SE97_DEVID\t\t0xa200\n#define SE97_DEVID_MASK\t\t0xfffc\n\n#define SE98_DEVID\t\t0xa100\n#define SE98_DEVID_MASK\t\t0xfffc\n\n \n#define CAT6095_DEVID\t\t0x0800\t \n#define CAT6095_DEVID_MASK\t0xffe0\n\n#define CAT34TS02C_DEVID\t0x0a00\n#define CAT34TS02C_DEVID_MASK\t0xfff0\n\n#define CAT34TS04_DEVID\t\t0x2200\n#define CAT34TS04_DEVID_MASK\t0xfff0\n\n#define N34TS04_DEVID\t\t0x2230\n#define N34TS04_DEVID_MASK\t0xfff0\n\n \n#define STTS424_DEVID\t\t0x0101\n#define STTS424_DEVID_MASK\t0xffff\n\n#define STTS424E_DEVID\t\t0x0000\n#define STTS424E_DEVID_MASK\t0xfffe\n\n#define STTS2002_DEVID\t\t0x0300\n#define STTS2002_DEVID_MASK\t0xffff\n\n#define STTS2004_DEVID\t\t0x2201\n#define STTS2004_DEVID_MASK\t0xffff\n\n#define STTS3000_DEVID\t\t0x0200\n#define STTS3000_DEVID_MASK\t0xffff\n\n \n#define S34TS04A_DEVID\t\t0x2221\n#define S34TS04A_DEVID_MASK\t0xffff\n\nstatic u16 jc42_hysteresis[] = { 0, 1500, 3000, 6000 };\n\nstruct jc42_chips {\n\tu16 manid;\n\tu16 devid;\n\tu16 devid_mask;\n};\n\nstatic struct jc42_chips jc42_chips[] = {\n\t{ ADT_MANID, ADT7408_DEVID, ADT7408_DEVID_MASK },\n\t{ ATMEL_MANID, AT30TS00_DEVID, AT30TS00_DEVID_MASK },\n\t{ ATMEL_MANID2, AT30TSE004_DEVID, AT30TSE004_DEVID_MASK },\n\t{ GT_MANID, GT30TS00_DEVID, GT30TS00_DEVID_MASK },\n\t{ GT_MANID2, GT34TS02_DEVID, GT34TS02_DEVID_MASK },\n\t{ IDT_MANID, TSE2004_DEVID, TSE2004_DEVID_MASK },\n\t{ IDT_MANID, TS3000_DEVID, TS3000_DEVID_MASK },\n\t{ IDT_MANID, TS3001_DEVID, TS3001_DEVID_MASK },\n\t{ MAX_MANID, MAX6604_DEVID, MAX6604_DEVID_MASK },\n\t{ MCP_MANID, MCP9804_DEVID, MCP9804_DEVID_MASK },\n\t{ MCP_MANID, MCP9808_DEVID, MCP9808_DEVID_MASK },\n\t{ MCP_MANID, MCP98242_DEVID, MCP98242_DEVID_MASK },\n\t{ MCP_MANID, MCP98243_DEVID, MCP98243_DEVID_MASK },\n\t{ MCP_MANID, MCP98244_DEVID, MCP98244_DEVID_MASK },\n\t{ MCP_MANID, MCP9843_DEVID, MCP9843_DEVID_MASK },\n\t{ NXP_MANID, SE97_DEVID, SE97_DEVID_MASK },\n\t{ ONS_MANID, CAT6095_DEVID, CAT6095_DEVID_MASK },\n\t{ ONS_MANID, CAT34TS02C_DEVID, CAT34TS02C_DEVID_MASK },\n\t{ ONS_MANID, CAT34TS04_DEVID, CAT34TS04_DEVID_MASK },\n\t{ ONS_MANID, N34TS04_DEVID, N34TS04_DEVID_MASK },\n\t{ NXP_MANID, SE98_DEVID, SE98_DEVID_MASK },\n\t{ SI_MANID,  S34TS04A_DEVID, S34TS04A_DEVID_MASK },\n\t{ STM_MANID, STTS424_DEVID, STTS424_DEVID_MASK },\n\t{ STM_MANID, STTS424E_DEVID, STTS424E_DEVID_MASK },\n\t{ STM_MANID, STTS2002_DEVID, STTS2002_DEVID_MASK },\n\t{ STM_MANID, STTS2004_DEVID, STTS2004_DEVID_MASK },\n\t{ STM_MANID, STTS3000_DEVID, STTS3000_DEVID_MASK },\n};\n\n \nstruct jc42_data {\n\tstruct mutex\tupdate_lock;\t \n\tstruct regmap\t*regmap;\n\tbool\t\textended;\t \n\tbool\t\tvalid;\n\tu16\t\torig_config;\t \n\tu16\t\tconfig;\t\t \n};\n\n#define JC42_TEMP_MIN_EXTENDED\t(-40000)\n#define JC42_TEMP_MIN\t\t0\n#define JC42_TEMP_MAX\t\t125000\n\nstatic u16 jc42_temp_to_reg(long temp, bool extended)\n{\n\tint ntemp = clamp_val(temp,\n\t\t\t      extended ? JC42_TEMP_MIN_EXTENDED :\n\t\t\t      JC42_TEMP_MIN, JC42_TEMP_MAX);\n\n\t \n\treturn (ntemp * 2 / 125) & 0x1fff;\n}\n\nstatic int jc42_temp_from_reg(s16 reg)\n{\n\treg = sign_extend32(reg, 12);\n\n\t \n\treturn reg * 125 / 2;\n}\n\nstatic int jc42_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t     u32 attr, int channel, long *val)\n{\n\tstruct jc42_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint ret, temp, hyst;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tret = regmap_read(data->regmap, JC42_REG_TEMP, &regval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*val = jc42_temp_from_reg(regval);\n\t\tbreak;\n\tcase hwmon_temp_min:\n\t\tret = regmap_read(data->regmap, JC42_REG_TEMP_LOWER, &regval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*val = jc42_temp_from_reg(regval);\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\tret = regmap_read(data->regmap, JC42_REG_TEMP_UPPER, &regval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*val = jc42_temp_from_reg(regval);\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\tret = regmap_read(data->regmap, JC42_REG_TEMP_CRITICAL,\n\t\t\t\t  &regval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*val = jc42_temp_from_reg(regval);\n\t\tbreak;\n\tcase hwmon_temp_max_hyst:\n\t\tret = regmap_read(data->regmap, JC42_REG_TEMP_UPPER, &regval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\ttemp = jc42_temp_from_reg(regval);\n\t\thyst = jc42_hysteresis[FIELD_GET(JC42_CFG_HYST_MASK,\n\t\t\t\t\t\t data->config)];\n\t\t*val = temp - hyst;\n\t\tbreak;\n\tcase hwmon_temp_crit_hyst:\n\t\tret = regmap_read(data->regmap, JC42_REG_TEMP_CRITICAL,\n\t\t\t\t  &regval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\ttemp = jc42_temp_from_reg(regval);\n\t\thyst = jc42_hysteresis[FIELD_GET(JC42_CFG_HYST_MASK,\n\t\t\t\t\t\t data->config)];\n\t\t*val = temp - hyst;\n\t\tbreak;\n\tcase hwmon_temp_min_alarm:\n\t\tret = regmap_read(data->regmap, JC42_REG_TEMP, &regval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*val = FIELD_GET(JC42_ALARM_MIN, regval);\n\t\tbreak;\n\tcase hwmon_temp_max_alarm:\n\t\tret = regmap_read(data->regmap, JC42_REG_TEMP, &regval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*val = FIELD_GET(JC42_ALARM_MAX, regval);\n\t\tbreak;\n\tcase hwmon_temp_crit_alarm:\n\t\tret = regmap_read(data->regmap, JC42_REG_TEMP, &regval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*val = FIELD_GET(JC42_ALARM_CRIT, regval);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\nstatic int jc42_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t      u32 attr, int channel, long val)\n{\n\tstruct jc42_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint diff, hyst;\n\tint ret;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (attr) {\n\tcase hwmon_temp_min:\n\t\tret = regmap_write(data->regmap, JC42_REG_TEMP_LOWER,\n\t\t\t\t   jc42_temp_to_reg(val, data->extended));\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\tret = regmap_write(data->regmap, JC42_REG_TEMP_UPPER,\n\t\t\t\t   jc42_temp_to_reg(val, data->extended));\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\tret = regmap_write(data->regmap, JC42_REG_TEMP_CRITICAL,\n\t\t\t\t   jc42_temp_to_reg(val, data->extended));\n\t\tbreak;\n\tcase hwmon_temp_crit_hyst:\n\t\tret = regmap_read(data->regmap, JC42_REG_TEMP_CRITICAL,\n\t\t\t\t  &regval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tval = clamp_val(val, (data->extended ? JC42_TEMP_MIN_EXTENDED\n\t\t\t\t\t\t     : JC42_TEMP_MIN) - 6000,\n\t\t\t\tJC42_TEMP_MAX);\n\t\tdiff = jc42_temp_from_reg(regval) - val;\n\t\thyst = 0;\n\t\tif (diff > 0) {\n\t\t\tif (diff < 2250)\n\t\t\t\thyst = 1;\t \n\t\t\telse if (diff < 4500)\n\t\t\t\thyst = 2;\t \n\t\t\telse\n\t\t\t\thyst = 3;\t \n\t\t}\n\t\tdata->config = (data->config & ~JC42_CFG_HYST_MASK) |\n\t\t\t\tFIELD_PREP(JC42_CFG_HYST_MASK, hyst);\n\t\tret = regmap_write(data->regmap, JC42_REG_CONFIG,\n\t\t\t\t   data->config);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\nstatic umode_t jc42_is_visible(const void *_data, enum hwmon_sensor_types type,\n\t\t\t       u32 attr, int channel)\n{\n\tconst struct jc42_data *data = _data;\n\tunsigned int config = data->config;\n\tumode_t mode = 0444;\n\n\tswitch (attr) {\n\tcase hwmon_temp_min:\n\tcase hwmon_temp_max:\n\t\tif (!(config & JC42_CFG_EVENT_LOCK))\n\t\t\tmode |= 0200;\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\tif (!(config & JC42_CFG_TCRIT_LOCK))\n\t\t\tmode |= 0200;\n\t\tbreak;\n\tcase hwmon_temp_crit_hyst:\n\t\tif (!(config & (JC42_CFG_EVENT_LOCK | JC42_CFG_TCRIT_LOCK)))\n\t\t\tmode |= 0200;\n\t\tbreak;\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_max_hyst:\n\tcase hwmon_temp_min_alarm:\n\tcase hwmon_temp_max_alarm:\n\tcase hwmon_temp_crit_alarm:\n\t\tbreak;\n\tdefault:\n\t\tmode = 0;\n\t\tbreak;\n\t}\n\treturn mode;\n}\n\n \nstatic int jc42_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint i, config, cap, manid, devid;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tcap = i2c_smbus_read_word_swapped(client, JC42_REG_CAP);\n\tconfig = i2c_smbus_read_word_swapped(client, JC42_REG_CONFIG);\n\tmanid = i2c_smbus_read_word_swapped(client, JC42_REG_MANID);\n\tdevid = i2c_smbus_read_word_swapped(client, JC42_REG_DEVICEID);\n\n\tif (cap < 0 || config < 0 || manid < 0 || devid < 0)\n\t\treturn -ENODEV;\n\n\tif ((cap & 0xff00) || (config & 0xf800))\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < ARRAY_SIZE(jc42_chips); i++) {\n\t\tstruct jc42_chips *chip = &jc42_chips[i];\n\t\tif (manid == chip->manid &&\n\t\t    (devid & chip->devid_mask) == chip->devid) {\n\t\t\tstrscpy(info->type, \"jc42\", I2C_NAME_SIZE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENODEV;\n}\n\nstatic const struct hwmon_channel_info * const jc42_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ | HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |\n\t\t\t   HWMON_T_CRIT | HWMON_T_MAX_HYST |\n\t\t\t   HWMON_T_CRIT_HYST | HWMON_T_MIN_ALARM |\n\t\t\t   HWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM),\n\tNULL\n};\n\nstatic const struct hwmon_ops jc42_hwmon_ops = {\n\t.is_visible = jc42_is_visible,\n\t.read = jc42_read,\n\t.write = jc42_write,\n};\n\nstatic const struct hwmon_chip_info jc42_chip_info = {\n\t.ops = &jc42_hwmon_ops,\n\t.info = jc42_info,\n};\n\nstatic bool jc42_readable_reg(struct device *dev, unsigned int reg)\n{\n\treturn (reg >= JC42_REG_CAP && reg <= JC42_REG_DEVICEID) ||\n\t\treg == JC42_REG_SMBUS;\n}\n\nstatic bool jc42_writable_reg(struct device *dev, unsigned int reg)\n{\n\treturn (reg >= JC42_REG_CONFIG && reg <= JC42_REG_TEMP_CRITICAL) ||\n\t\treg == JC42_REG_SMBUS;\n}\n\nstatic bool jc42_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg == JC42_REG_CONFIG || reg == JC42_REG_TEMP;\n}\n\nstatic const struct regmap_config jc42_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\t.max_register = JC42_REG_SMBUS,\n\t.writeable_reg = jc42_writable_reg,\n\t.readable_reg = jc42_readable_reg,\n\t.volatile_reg = jc42_volatile_reg,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int jc42_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tunsigned int config, cap;\n\tstruct jc42_data *data;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(struct jc42_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &jc42_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\n\tret = regmap_read(data->regmap, JC42_REG_CAP, &cap);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->extended = !!(cap & JC42_CAP_RANGE);\n\n\tif (device_property_read_bool(dev, \"smbus-timeout-disable\")) {\n\t\t \n\t\tret = regmap_set_bits(data->regmap, JC42_REG_SMBUS,\n\t\t\t\t      SMBUS_STMOUT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_read(data->regmap, JC42_REG_CONFIG, &config);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->orig_config = config;\n\tif (config & JC42_CFG_SHUTDOWN) {\n\t\tconfig &= ~JC42_CFG_SHUTDOWN;\n\t\tregmap_write(data->regmap, JC42_REG_CONFIG, config);\n\t}\n\tdata->config = config;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, \"jc42\",\n\t\t\t\t\t\t\t data, &jc42_chip_info,\n\t\t\t\t\t\t\t NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic void jc42_remove(struct i2c_client *client)\n{\n\tstruct jc42_data *data = i2c_get_clientdata(client);\n\n\t \n\tif ((data->config & ~JC42_CFG_HYST_MASK) !=\n\t    (data->orig_config & ~JC42_CFG_HYST_MASK)) {\n\t\tint config;\n\n\t\tconfig = (data->orig_config & ~JC42_CFG_HYST_MASK)\n\t\t  | (data->config & JC42_CFG_HYST_MASK);\n\t\tregmap_write(data->regmap, JC42_REG_CONFIG, config);\n\t}\n}\n\n#ifdef CONFIG_PM\n\nstatic int jc42_suspend(struct device *dev)\n{\n\tstruct jc42_data *data = dev_get_drvdata(dev);\n\n\tdata->config |= JC42_CFG_SHUTDOWN;\n\tregmap_write(data->regmap, JC42_REG_CONFIG, data->config);\n\n\tregcache_cache_only(data->regmap, true);\n\tregcache_mark_dirty(data->regmap);\n\n\treturn 0;\n}\n\nstatic int jc42_resume(struct device *dev)\n{\n\tstruct jc42_data *data = dev_get_drvdata(dev);\n\n\tregcache_cache_only(data->regmap, false);\n\n\tdata->config &= ~JC42_CFG_SHUTDOWN;\n\tregmap_write(data->regmap, JC42_REG_CONFIG, data->config);\n\n\t \n\treturn regcache_sync(data->regmap);\n}\n\nstatic const struct dev_pm_ops jc42_dev_pm_ops = {\n\t.suspend = jc42_suspend,\n\t.resume = jc42_resume,\n};\n\n#define JC42_DEV_PM_OPS (&jc42_dev_pm_ops)\n#else\n#define JC42_DEV_PM_OPS NULL\n#endif  \n\nstatic const struct i2c_device_id jc42_id[] = {\n\t{ \"jc42\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, jc42_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id jc42_of_ids[] = {\n\t{ .compatible = \"jedec,jc-42.4-temp\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, jc42_of_ids);\n#endif\n\nstatic struct i2c_driver jc42_driver = {\n\t.class\t\t= I2C_CLASS_SPD | I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"jc42\",\n\t\t.pm = JC42_DEV_PM_OPS,\n\t\t.of_match_table = of_match_ptr(jc42_of_ids),\n\t},\n\t.probe\t\t= jc42_probe,\n\t.remove\t\t= jc42_remove,\n\t.id_table\t= jc42_id,\n\t.detect\t\t= jc42_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(jc42_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"JC42 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}