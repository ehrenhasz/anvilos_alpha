{
  "module_name": "da9055-hwmon.c",
  "hash_id": "68c84bd0dd8813b3e90d1a8092b0671d798c2b6b5be6b4cb0981ba540c029d55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/da9055-hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/completion.h>\n\n#include <linux/mfd/da9055/core.h>\n#include <linux/mfd/da9055/reg.h>\n\n#define DA9055_ADCIN_DIV\t102\n#define DA9055_VSYS_DIV\t85\n\n#define DA9055_ADC_VSYS\t0\n#define DA9055_ADC_ADCIN1\t1\n#define DA9055_ADC_ADCIN2\t2\n#define DA9055_ADC_ADCIN3\t3\n#define DA9055_ADC_TJUNC\t4\n\nstruct da9055_hwmon {\n\tstruct da9055\t*da9055;\n\tstruct mutex\thwmon_lock;\n\tstruct mutex\tirq_lock;\n\tstruct completion done;\n};\n\nstatic const char * const input_names[] = {\n\t[DA9055_ADC_VSYS]\t= \"VSYS\",\n\t[DA9055_ADC_ADCIN1]\t= \"ADC IN1\",\n\t[DA9055_ADC_ADCIN2]\t= \"ADC IN2\",\n\t[DA9055_ADC_ADCIN3]\t= \"ADC IN3\",\n\t[DA9055_ADC_TJUNC]\t= \"CHIP TEMP\",\n};\n\nstatic const u8 chan_mux[DA9055_ADC_TJUNC + 1] = {\n\t[DA9055_ADC_VSYS]\t= DA9055_ADC_MUX_VSYS,\n\t[DA9055_ADC_ADCIN1]\t= DA9055_ADC_MUX_ADCIN1,\n\t[DA9055_ADC_ADCIN2]\t= DA9055_ADC_MUX_ADCIN2,\n\t[DA9055_ADC_ADCIN3]\t= DA9055_ADC_MUX_ADCIN3,\n\t[DA9055_ADC_TJUNC]\t= DA9055_ADC_MUX_T_SENSE,\n};\n\nstatic int da9055_adc_manual_read(struct da9055_hwmon *hwmon,\n\t\t\t\t\tunsigned char channel)\n{\n\tint ret;\n\tunsigned short calc_data;\n\tunsigned short data;\n\tunsigned char mux_sel;\n\tstruct da9055 *da9055 = hwmon->da9055;\n\n\tif (channel > DA9055_ADC_TJUNC)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hwmon->irq_lock);\n\n\t \n\tmux_sel = chan_mux[channel] | DA9055_ADC_MAN_CONV;\n\n\tret = da9055_reg_write(da9055, DA9055_REG_ADC_MAN, mux_sel);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tif (!wait_for_completion_timeout(&hwmon->done,\n\t\t\t\t\tmsecs_to_jiffies(500))) {\n\t\tdev_err(da9055->dev,\n\t\t\t\"timeout waiting for ADC conversion interrupt\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\n\tret = da9055_reg_read(da9055, DA9055_REG_ADC_RES_H);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tcalc_data = (unsigned short)ret;\n\tdata = calc_data << 2;\n\n\tret = da9055_reg_read(da9055, DA9055_REG_ADC_RES_L);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tcalc_data = (unsigned short)(ret & DA9055_ADC_LSB_MASK);\n\tdata |= calc_data;\n\n\tret = data;\n\nerr:\n\tmutex_unlock(&hwmon->irq_lock);\n\treturn ret;\n}\n\nstatic irqreturn_t da9055_auxadc_irq(int irq, void *irq_data)\n{\n\tstruct da9055_hwmon *hwmon = irq_data;\n\n\tcomplete(&hwmon->done);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic inline int volt_reg_to_mv(int value, int channel)\n{\n\tif (channel == DA9055_ADC_VSYS)\n\t\treturn DIV_ROUND_CLOSEST(value * 1000, DA9055_VSYS_DIV) + 2500;\n\telse\n\t\treturn DIV_ROUND_CLOSEST(value * 1000, DA9055_ADCIN_DIV);\n}\n\nstatic int da9055_enable_auto_mode(struct da9055 *da9055, int channel)\n{\n\n\treturn da9055_reg_update(da9055, DA9055_REG_ADC_CONT, 1 << channel,\n\t\t\t\t1 << channel);\n\n}\n\nstatic int da9055_disable_auto_mode(struct da9055 *da9055, int channel)\n{\n\n\treturn da9055_reg_update(da9055, DA9055_REG_ADC_CONT, 1 << channel, 0);\n}\n\nstatic ssize_t da9055_auto_ch_show(struct device *dev,\n\t\t\t\t   struct device_attribute *devattr,\n\t\t\t\t   char *buf)\n{\n\tstruct da9055_hwmon *hwmon = dev_get_drvdata(dev);\n\tint ret, adc;\n\tint channel = to_sensor_dev_attr(devattr)->index;\n\n\tmutex_lock(&hwmon->hwmon_lock);\n\n\tret = da9055_enable_auto_mode(hwmon->da9055, channel);\n\tif (ret < 0)\n\t\tgoto hwmon_err;\n\n\tusleep_range(10000, 10500);\n\n\tadc = da9055_reg_read(hwmon->da9055, DA9055_REG_VSYS_RES + channel);\n\tif (adc < 0) {\n\t\tret = adc;\n\t\tgoto hwmon_err_release;\n\t}\n\n\tret = da9055_disable_auto_mode(hwmon->da9055, channel);\n\tif (ret < 0)\n\t\tgoto hwmon_err;\n\n\tmutex_unlock(&hwmon->hwmon_lock);\n\n\treturn sprintf(buf, \"%d\\n\", volt_reg_to_mv(adc, channel));\n\nhwmon_err_release:\n\tda9055_disable_auto_mode(hwmon->da9055, channel);\nhwmon_err:\n\tmutex_unlock(&hwmon->hwmon_lock);\n\treturn ret;\n}\n\nstatic ssize_t da9055_tjunc_show(struct device *dev,\n\t\t\t\t struct device_attribute *devattr, char *buf)\n{\n\tstruct da9055_hwmon *hwmon = dev_get_drvdata(dev);\n\tint tjunc;\n\tint toffset;\n\n\ttjunc = da9055_adc_manual_read(hwmon, DA9055_ADC_TJUNC);\n\tif (tjunc < 0)\n\t\treturn tjunc;\n\n\ttoffset = da9055_reg_read(hwmon->da9055, DA9055_REG_T_OFFSET);\n\tif (toffset < 0)\n\t\treturn toffset;\n\n\t \n\treturn sprintf(buf, \"%d\\n\", DIV_ROUND_CLOSEST(-4084 * (tjunc - toffset)\n\t\t\t\t\t\t\t+ 3076332, 10000));\n}\n\nstatic ssize_t label_show(struct device *dev,\n\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       input_names[to_sensor_dev_attr(devattr)->index]);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_input, da9055_auto_ch, DA9055_ADC_VSYS);\nstatic SENSOR_DEVICE_ATTR_RO(in0_label, label, DA9055_ADC_VSYS);\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, da9055_auto_ch, DA9055_ADC_ADCIN1);\nstatic SENSOR_DEVICE_ATTR_RO(in1_label, label, DA9055_ADC_ADCIN1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, da9055_auto_ch, DA9055_ADC_ADCIN2);\nstatic SENSOR_DEVICE_ATTR_RO(in2_label, label, DA9055_ADC_ADCIN2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, da9055_auto_ch, DA9055_ADC_ADCIN3);\nstatic SENSOR_DEVICE_ATTR_RO(in3_label, label, DA9055_ADC_ADCIN3);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, da9055_tjunc, DA9055_ADC_TJUNC);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_label, label, DA9055_ADC_TJUNC);\n\nstatic struct attribute *da9055_attrs[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_label.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_label.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_label.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_label.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_label.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(da9055);\n\nstatic int da9055_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct da9055_hwmon *hwmon;\n\tstruct device *hwmon_dev;\n\tint hwmon_irq, ret;\n\n\thwmon = devm_kzalloc(dev, sizeof(struct da9055_hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&hwmon->hwmon_lock);\n\tmutex_init(&hwmon->irq_lock);\n\n\tinit_completion(&hwmon->done);\n\thwmon->da9055 = dev_get_drvdata(pdev->dev.parent);\n\n\thwmon_irq = platform_get_irq_byname(pdev, \"HWMON\");\n\tif (hwmon_irq < 0)\n\t\treturn hwmon_irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, hwmon_irq,\n\t\t\t\t\tNULL, da9055_auxadc_irq,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"adc-irq\", hwmon);\n\tif (ret != 0) {\n\t\tdev_err(hwmon->da9055->dev, \"DA9055 ADC IRQ failed ret=%d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, \"da9055\",\n\t\t\t\t\t\t\t   hwmon,\n\t\t\t\t\t\t\t   da9055_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic struct platform_driver da9055_hwmon_driver = {\n\t.probe = da9055_hwmon_probe,\n\t.driver = {\n\t\t.name = \"da9055-hwmon\",\n\t},\n};\n\nmodule_platform_driver(da9055_hwmon_driver);\n\nMODULE_AUTHOR(\"David Dajun Chen <dchen@diasemi.com>\");\nMODULE_DESCRIPTION(\"DA9055 HWMON driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9055-hwmon\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}