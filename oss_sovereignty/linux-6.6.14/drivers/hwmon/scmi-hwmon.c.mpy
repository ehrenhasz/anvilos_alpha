{
  "module_name": "scmi-hwmon.c",
  "hash_id": "060d6e40d4e836d1764e65c30366267f604c6c4a85ae7865be0b7872fed1bd7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/scmi-hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/hwmon.h>\n#include <linux/module.h>\n#include <linux/scmi_protocol.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/thermal.h>\n\nstatic const struct scmi_sensor_proto_ops *sensor_ops;\n\nstruct scmi_sensors {\n\tconst struct scmi_protocol_handle *ph;\n\tconst struct scmi_sensor_info **info[hwmon_max];\n};\n\nstruct scmi_thermal_sensor {\n\tconst struct scmi_protocol_handle *ph;\n\tconst struct scmi_sensor_info *info;\n};\n\nstatic inline u64 __pow10(u8 x)\n{\n\tu64 r = 1;\n\n\twhile (x--)\n\t\tr *= 10;\n\n\treturn r;\n}\n\nstatic int scmi_hwmon_scale(const struct scmi_sensor_info *sensor, u64 *value)\n{\n\tint scale = sensor->scale;\n\tu64 f;\n\n\tswitch (sensor->type) {\n\tcase TEMPERATURE_C:\n\tcase VOLTAGE:\n\tcase CURRENT:\n\t\tscale += 3;\n\t\tbreak;\n\tcase POWER:\n\tcase ENERGY:\n\t\tscale += 6;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (scale == 0)\n\t\treturn 0;\n\n\tif (abs(scale) > 19)\n\t\treturn -E2BIG;\n\n\tf = __pow10(abs(scale));\n\tif (scale > 0)\n\t\t*value *= f;\n\telse\n\t\t*value = div64_u64(*value, f);\n\n\treturn 0;\n}\n\nstatic int scmi_hwmon_read_scaled_value(const struct scmi_protocol_handle *ph,\n\t\t\t\t\tconst struct scmi_sensor_info *sensor,\n\t\t\t\t\tlong *val)\n{\n\tint ret;\n\tu64 value;\n\n\tret = sensor_ops->reading_get(ph, sensor->id, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tret = scmi_hwmon_scale(sensor, &value);\n\tif (!ret)\n\t\t*val = value;\n\n\treturn ret;\n}\n\nstatic int scmi_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t   u32 attr, int channel, long *val)\n{\n\tconst struct scmi_sensor_info *sensor;\n\tstruct scmi_sensors *scmi_sensors = dev_get_drvdata(dev);\n\n\tsensor = *(scmi_sensors->info[type] + channel);\n\n\treturn scmi_hwmon_read_scaled_value(scmi_sensors->ph, sensor, val);\n}\n\nstatic int\nscmi_hwmon_read_string(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, const char **str)\n{\n\tconst struct scmi_sensor_info *sensor;\n\tstruct scmi_sensors *scmi_sensors = dev_get_drvdata(dev);\n\n\tsensor = *(scmi_sensors->info[type] + channel);\n\t*str = sensor->name;\n\n\treturn 0;\n}\n\nstatic umode_t\nscmi_hwmon_is_visible(const void *drvdata, enum hwmon_sensor_types type,\n\t\t      u32 attr, int channel)\n{\n\tconst struct scmi_sensor_info *sensor;\n\tconst struct scmi_sensors *scmi_sensors = drvdata;\n\n\tsensor = *(scmi_sensors->info[type] + channel);\n\tif (sensor)\n\t\treturn 0444;\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops scmi_hwmon_ops = {\n\t.is_visible = scmi_hwmon_is_visible,\n\t.read = scmi_hwmon_read,\n\t.read_string = scmi_hwmon_read_string,\n};\n\nstatic struct hwmon_chip_info scmi_chip_info = {\n\t.ops = &scmi_hwmon_ops,\n\t.info = NULL,\n};\n\nstatic int scmi_hwmon_thermal_get_temp(struct thermal_zone_device *tz,\n\t\t\t\t       int *temp)\n{\n\tint ret;\n\tlong value;\n\tstruct scmi_thermal_sensor *th_sensor = thermal_zone_device_priv(tz);\n\n\tret = scmi_hwmon_read_scaled_value(th_sensor->ph, th_sensor->info,\n\t\t\t\t\t   &value);\n\tif (!ret)\n\t\t*temp = value;\n\n\treturn ret;\n}\n\nstatic const struct thermal_zone_device_ops scmi_hwmon_thermal_ops = {\n\t.get_temp = scmi_hwmon_thermal_get_temp,\n};\n\nstatic int scmi_hwmon_add_chan_info(struct hwmon_channel_info *scmi_hwmon_chan,\n\t\t\t\t    struct device *dev, int num,\n\t\t\t\t    enum hwmon_sensor_types type, u32 config)\n{\n\tint i;\n\tu32 *cfg = devm_kcalloc(dev, num + 1, sizeof(*cfg), GFP_KERNEL);\n\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tscmi_hwmon_chan->type = type;\n\tscmi_hwmon_chan->config = cfg;\n\tfor (i = 0; i < num; i++, cfg++)\n\t\t*cfg = config;\n\n\treturn 0;\n}\n\nstatic enum hwmon_sensor_types scmi_types[] = {\n\t[TEMPERATURE_C] = hwmon_temp,\n\t[VOLTAGE] = hwmon_in,\n\t[CURRENT] = hwmon_curr,\n\t[POWER] = hwmon_power,\n\t[ENERGY] = hwmon_energy,\n};\n\nstatic u32 hwmon_attributes[hwmon_max] = {\n\t[hwmon_temp] = HWMON_T_INPUT | HWMON_T_LABEL,\n\t[hwmon_in] = HWMON_I_INPUT | HWMON_I_LABEL,\n\t[hwmon_curr] = HWMON_C_INPUT | HWMON_C_LABEL,\n\t[hwmon_power] = HWMON_P_INPUT | HWMON_P_LABEL,\n\t[hwmon_energy] = HWMON_E_INPUT | HWMON_E_LABEL,\n};\n\nstatic int scmi_thermal_sensor_register(struct device *dev,\n\t\t\t\t\tconst struct scmi_protocol_handle *ph,\n\t\t\t\t\tconst struct scmi_sensor_info *sensor)\n{\n\tstruct scmi_thermal_sensor *th_sensor;\n\tstruct thermal_zone_device *tzd;\n\n\tth_sensor = devm_kzalloc(dev, sizeof(*th_sensor), GFP_KERNEL);\n\tif (!th_sensor)\n\t\treturn -ENOMEM;\n\n\tth_sensor->ph = ph;\n\tth_sensor->info = sensor;\n\n\t \n\ttzd = devm_thermal_of_zone_register(dev, th_sensor->info->id, th_sensor,\n\t\t\t\t\t    &scmi_hwmon_thermal_ops);\n\tif (IS_ERR(tzd)) {\n\t\tdevm_kfree(dev, th_sensor);\n\n\t\tif (PTR_ERR(tzd) != -ENODEV)\n\t\t\treturn PTR_ERR(tzd);\n\n\t\tdev_dbg(dev, \"Sensor '%s' not attached to any thermal zone.\\n\",\n\t\t\tsensor->name);\n\t} else {\n\t\tdev_dbg(dev, \"Sensor '%s' attached to thermal zone ID:%d\\n\",\n\t\t\tsensor->name, thermal_zone_device_id(tzd));\n\t}\n\n\treturn 0;\n}\n\nstatic int scmi_hwmon_probe(struct scmi_device *sdev)\n{\n\tint i, idx;\n\tu16 nr_sensors;\n\tenum hwmon_sensor_types type;\n\tstruct scmi_sensors *scmi_sensors;\n\tconst struct scmi_sensor_info *sensor;\n\tint nr_count[hwmon_max] = {0}, nr_types = 0, nr_count_temp = 0;\n\tconst struct hwmon_chip_info *chip_info;\n\tstruct device *hwdev, *dev = &sdev->dev;\n\tstruct hwmon_channel_info *scmi_hwmon_chan;\n\tconst struct hwmon_channel_info **ptr_scmi_ci;\n\tconst struct scmi_handle *handle = sdev->handle;\n\tstruct scmi_protocol_handle *ph;\n\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tsensor_ops = handle->devm_protocol_get(sdev, SCMI_PROTOCOL_SENSOR, &ph);\n\tif (IS_ERR(sensor_ops))\n\t\treturn PTR_ERR(sensor_ops);\n\n\tnr_sensors = sensor_ops->count_get(ph);\n\tif (!nr_sensors)\n\t\treturn -EIO;\n\n\tscmi_sensors = devm_kzalloc(dev, sizeof(*scmi_sensors), GFP_KERNEL);\n\tif (!scmi_sensors)\n\t\treturn -ENOMEM;\n\n\tscmi_sensors->ph = ph;\n\n\tfor (i = 0; i < nr_sensors; i++) {\n\t\tsensor = sensor_ops->info_get(ph, i);\n\t\tif (!sensor)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sensor->type) {\n\t\tcase TEMPERATURE_C:\n\t\tcase VOLTAGE:\n\t\tcase CURRENT:\n\t\tcase POWER:\n\t\tcase ENERGY:\n\t\t\ttype = scmi_types[sensor->type];\n\t\t\tif (!nr_count[type])\n\t\t\t\tnr_types++;\n\t\t\tnr_count[type]++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (nr_count[hwmon_temp])\n\t\tnr_count_temp = nr_count[hwmon_temp];\n\n\tscmi_hwmon_chan = devm_kcalloc(dev, nr_types, sizeof(*scmi_hwmon_chan),\n\t\t\t\t       GFP_KERNEL);\n\tif (!scmi_hwmon_chan)\n\t\treturn -ENOMEM;\n\n\tptr_scmi_ci = devm_kcalloc(dev, nr_types + 1, sizeof(*ptr_scmi_ci),\n\t\t\t\t   GFP_KERNEL);\n\tif (!ptr_scmi_ci)\n\t\treturn -ENOMEM;\n\n\tscmi_chip_info.info = ptr_scmi_ci;\n\tchip_info = &scmi_chip_info;\n\n\tfor (type = 0; type < hwmon_max; type++) {\n\t\tif (!nr_count[type])\n\t\t\tcontinue;\n\n\t\tscmi_hwmon_add_chan_info(scmi_hwmon_chan, dev, nr_count[type],\n\t\t\t\t\t type, hwmon_attributes[type]);\n\t\t*ptr_scmi_ci++ = scmi_hwmon_chan++;\n\n\t\tscmi_sensors->info[type] =\n\t\t\tdevm_kcalloc(dev, nr_count[type],\n\t\t\t\t     sizeof(*scmi_sensors->info), GFP_KERNEL);\n\t\tif (!scmi_sensors->info[type])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = nr_sensors - 1; i >= 0 ; i--) {\n\t\tsensor = sensor_ops->info_get(ph, i);\n\t\tif (!sensor)\n\t\t\tcontinue;\n\n\t\tswitch (sensor->type) {\n\t\tcase TEMPERATURE_C:\n\t\tcase VOLTAGE:\n\t\tcase CURRENT:\n\t\tcase POWER:\n\t\tcase ENERGY:\n\t\t\ttype = scmi_types[sensor->type];\n\t\t\tidx = --nr_count[type];\n\t\t\t*(scmi_sensors->info[type] + idx) = sensor;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thwdev = devm_hwmon_device_register_with_info(dev, \"scmi_sensors\",\n\t\t\t\t\t\t     scmi_sensors, chip_info,\n\t\t\t\t\t\t     NULL);\n\tif (IS_ERR(hwdev))\n\t\treturn PTR_ERR(hwdev);\n\n\tfor (i = 0; i < nr_count_temp; i++) {\n\t\tint ret;\n\n\t\tsensor = *(scmi_sensors->info[hwmon_temp] + i);\n\t\tif (!sensor)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = scmi_thermal_sensor_register(dev, ph, sensor);\n\t\tif (ret) {\n\t\t\tif (ret == -ENOMEM)\n\t\t\t\treturn ret;\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Thermal zone misconfigured for %s. err=%d\\n\",\n\t\t\t\t sensor->name, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct scmi_device_id scmi_id_table[] = {\n\t{ SCMI_PROTOCOL_SENSOR, \"hwmon\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(scmi, scmi_id_table);\n\nstatic struct scmi_driver scmi_hwmon_drv = {\n\t.name\t\t= \"scmi-hwmon\",\n\t.probe\t\t= scmi_hwmon_probe,\n\t.id_table\t= scmi_id_table,\n};\nmodule_scmi_driver(scmi_hwmon_drv);\n\nMODULE_AUTHOR(\"Sudeep Holla <sudeep.holla@arm.com>\");\nMODULE_DESCRIPTION(\"ARM SCMI HWMON interface driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}