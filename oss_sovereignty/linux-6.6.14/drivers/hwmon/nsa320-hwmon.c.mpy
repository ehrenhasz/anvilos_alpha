{
  "module_name": "nsa320-hwmon.c",
  "hash_id": "3e08e243d988e400b7624a1cc277951ad28b0f6f561e231f25ff4417ae11791d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/nsa320-hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n \n#define MAGIC_NUMBER 0x55\n\n \n\nstruct nsa320_hwmon {\n\tstruct mutex\t\tupdate_lock;\t \n\tunsigned long\t\tlast_updated;\t \n\tunsigned long\t\tmcu_data;\n\tstruct gpio_desc\t*act;\n\tstruct gpio_desc\t*clk;\n\tstruct gpio_desc\t*data;\n};\n\nenum nsa320_inputs {\n\tNSA320_TEMP = 0,\n\tNSA320_FAN = 1,\n};\n\nstatic const char * const nsa320_input_names[] = {\n\t[NSA320_TEMP] = \"System Temperature\",\n\t[NSA320_FAN] = \"Chassis Fan\",\n};\n\n \nstatic s32 nsa320_hwmon_update(struct device *dev)\n{\n\tu32 mcu_data;\n\tu32 mask;\n\tstruct nsa320_hwmon *hwmon = dev_get_drvdata(dev);\n\n\tmutex_lock(&hwmon->update_lock);\n\n\tmcu_data = hwmon->mcu_data;\n\n\tif (time_after(jiffies, hwmon->last_updated + HZ) || mcu_data == 0) {\n\t\tgpiod_set_value(hwmon->act, 1);\n\t\tmsleep(100);\n\n\t\tmcu_data = 0;\n\t\tfor (mask = BIT(31); mask; mask >>= 1) {\n\t\t\tgpiod_set_value(hwmon->clk, 0);\n\t\t\tusleep_range(100, 200);\n\t\t\tgpiod_set_value(hwmon->clk, 1);\n\t\t\tusleep_range(100, 200);\n\t\t\tif (gpiod_get_value(hwmon->data))\n\t\t\t\tmcu_data |= mask;\n\t\t}\n\n\t\tgpiod_set_value(hwmon->act, 0);\n\t\tdev_dbg(dev, \"Read raw MCU data %08x\\n\", mcu_data);\n\n\t\tif ((mcu_data >> 24) != MAGIC_NUMBER) {\n\t\t\tdev_dbg(dev, \"Read invalid MCU data %08x\\n\", mcu_data);\n\t\t\tmcu_data = -EIO;\n\t\t} else {\n\t\t\thwmon->mcu_data = mcu_data;\n\t\t\thwmon->last_updated = jiffies;\n\t\t}\n\t}\n\n\tmutex_unlock(&hwmon->update_lock);\n\n\treturn mcu_data;\n}\n\nstatic ssize_t label_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint channel = to_sensor_dev_attr(attr)->index;\n\n\treturn sprintf(buf, \"%s\\n\", nsa320_input_names[channel]);\n}\n\nstatic ssize_t temp1_input_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\ts32 mcu_data = nsa320_hwmon_update(dev);\n\n\tif (mcu_data < 0)\n\t\treturn mcu_data;\n\n\treturn sprintf(buf, \"%d\\n\", (mcu_data & 0xffff) * 100);\n}\n\nstatic ssize_t fan1_input_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\ts32 mcu_data = nsa320_hwmon_update(dev);\n\n\tif (mcu_data < 0)\n\t\treturn mcu_data;\n\n\treturn sprintf(buf, \"%d\\n\", ((mcu_data & 0xff0000) >> 16) * 100);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_label, label, NSA320_TEMP);\nstatic DEVICE_ATTR_RO(temp1_input);\nstatic SENSOR_DEVICE_ATTR_RO(fan1_label, label, NSA320_FAN);\nstatic DEVICE_ATTR_RO(fan1_input);\n\nstatic struct attribute *nsa320_attrs[] = {\n\t&sensor_dev_attr_temp1_label.dev_attr.attr,\n\t&dev_attr_temp1_input.attr,\n\t&sensor_dev_attr_fan1_label.dev_attr.attr,\n\t&dev_attr_fan1_input.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(nsa320);\n\nstatic const struct of_device_id of_nsa320_hwmon_match[] = {\n\t{ .compatible = \"zyxel,nsa320-mcu\", },\n\t{ },\n};\n\nstatic int nsa320_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct nsa320_hwmon\t*hwmon;\n\tstruct device\t\t*classdev;\n\n\thwmon = devm_kzalloc(&pdev->dev, sizeof(*hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn -ENOMEM;\n\n\t \n\thwmon->act = devm_gpiod_get(&pdev->dev, \"act\", GPIOD_OUT_LOW);\n\tif (IS_ERR(hwmon->act))\n\t\treturn PTR_ERR(hwmon->act);\n\n\thwmon->clk = devm_gpiod_get(&pdev->dev, \"clk\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(hwmon->clk))\n\t\treturn PTR_ERR(hwmon->clk);\n\n\thwmon->data = devm_gpiod_get(&pdev->dev, \"data\", GPIOD_IN);\n\tif (IS_ERR(hwmon->data))\n\t\treturn PTR_ERR(hwmon->data);\n\n\tmutex_init(&hwmon->update_lock);\n\n\tclassdev = devm_hwmon_device_register_with_groups(&pdev->dev,\n\t\t\t\t\t\"nsa320\", hwmon, nsa320_groups);\n\n\treturn PTR_ERR_OR_ZERO(classdev);\n\n}\n\n \n\nstatic struct platform_driver nsa320_hwmon_driver = {\n\t.probe = nsa320_hwmon_probe,\n\t.driver = {\n\t\t.name = \"nsa320-hwmon\",\n\t\t.of_match_table = of_nsa320_hwmon_match,\n\t},\n};\n\nmodule_platform_driver(nsa320_hwmon_driver);\n\nMODULE_DEVICE_TABLE(of, of_nsa320_hwmon_match);\nMODULE_AUTHOR(\"Peter Schildmann <linux@schildmann.info>\");\nMODULE_AUTHOR(\"Adam Baker <linux@baker-net.org.uk>\");\nMODULE_DESCRIPTION(\"NSA320 Hardware Monitoring\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:nsa320-hwmon\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}