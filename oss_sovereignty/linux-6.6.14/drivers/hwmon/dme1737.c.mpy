{
  "module_name": "dme1737.c",
  "hash_id": "bf4fadf49d019d325c60374c708db05d0ca5dd24797fc085cbfd340df08f3dc9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/dme1737.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon-vid.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\n \nstatic struct platform_device *pdev;\n\n \nstatic bool force_start;\nmodule_param(force_start, bool, 0);\nMODULE_PARM_DESC(force_start, \"Force the chip to start monitoring inputs\");\n\nstatic unsigned short force_id;\nmodule_param(force_id, ushort, 0);\nMODULE_PARM_DESC(force_id, \"Override the detected device ID\");\n\nstatic bool probe_all_addr;\nmodule_param(probe_all_addr, bool, 0);\nMODULE_PARM_DESC(probe_all_addr,\n\t\t \"Include probing of non-standard LPC addresses\");\n\n \nstatic const unsigned short normal_i2c[] = {0x2c, 0x2d, 0x2e, I2C_CLIENT_END};\n\nenum chips { dme1737, sch5027, sch311x, sch5127 };\n\n#define\tDO_REPORT \"Please report to the driver maintainer.\"\n\n \n\n \n#define DME1737_REG_IN(ix)\t\t((ix) < 5 ? 0x20 + (ix) : \\\n\t\t\t\t\t (ix) < 7 ? 0x94 + (ix) : \\\n\t\t\t\t\t\t    0x1f)\n#define DME1737_REG_IN_MIN(ix)\t\t((ix) < 5 ? 0x44 + (ix) * 2 \\\n\t\t\t\t\t\t  : 0x91 + (ix) * 2)\n#define DME1737_REG_IN_MAX(ix)\t\t((ix) < 5 ? 0x45 + (ix) * 2 \\\n\t\t\t\t\t\t  : 0x92 + (ix) * 2)\n\n \n#define DME1737_REG_TEMP(ix)\t\t(0x25 + (ix))\n#define DME1737_REG_TEMP_MIN(ix)\t(0x4e + (ix) * 2)\n#define DME1737_REG_TEMP_MAX(ix)\t(0x4f + (ix) * 2)\n#define DME1737_REG_TEMP_OFFSET(ix)\t((ix) == 0 ? 0x1f \\\n\t\t\t\t\t\t   : 0x1c + (ix))\n\n \n#define DME1737_REG_IN_TEMP_LSB(ix)\t(0x84 + (ix))\nstatic const u8 DME1737_REG_IN_LSB[] = {3, 4, 4, 3, 2, 0, 0, 5};\nstatic const u8 DME1737_REG_IN_LSB_SHL[] = {4, 4, 0, 0, 0, 0, 4, 4};\nstatic const u8 DME1737_REG_TEMP_LSB[] = {1, 2, 1};\nstatic const u8 DME1737_REG_TEMP_LSB_SHL[] = {4, 4, 0};\n\n \n#define DME1737_REG_FAN(ix)\t\t((ix) < 4 ? 0x28 + (ix) * 2 \\\n\t\t\t\t\t\t  : 0xa1 + (ix) * 2)\n#define DME1737_REG_FAN_MIN(ix)\t\t((ix) < 4 ? 0x54 + (ix) * 2 \\\n\t\t\t\t\t\t  : 0xa5 + (ix) * 2)\n#define DME1737_REG_FAN_OPT(ix)\t\t((ix) < 4 ? 0x90 + (ix) \\\n\t\t\t\t\t\t  : 0xb2 + (ix))\n#define DME1737_REG_FAN_MAX(ix)\t\t(0xb4 + (ix))  \n\n \n#define DME1737_REG_PWM(ix)\t\t((ix) < 3 ? 0x30 + (ix) \\\n\t\t\t\t\t\t  : 0xa1 + (ix))\n#define DME1737_REG_PWM_CONFIG(ix)\t(0x5c + (ix))  \n#define DME1737_REG_PWM_MIN(ix)\t\t(0x64 + (ix))  \n#define DME1737_REG_PWM_FREQ(ix)\t((ix) < 3 ? 0x5f + (ix) \\\n\t\t\t\t\t\t  : 0xa3 + (ix))\n \n#define DME1737_REG_PWM_RR(ix)\t\t(0x62 + (ix))  \n\n \n#define DME1737_REG_ZONE_LOW(ix)\t(0x67 + (ix))\n#define DME1737_REG_ZONE_ABS(ix)\t(0x6a + (ix))\n \n#define DME1737_REG_ZONE_HYST(ix)\t(0x6d + (ix))\n\n \n#define DME1737_REG_ALARM1\t\t0x41\n#define DME1737_REG_ALARM2\t\t0x42\n#define DME1737_REG_ALARM3\t\t0x83\nstatic const u8 DME1737_BIT_ALARM_IN[] = {0, 1, 2, 3, 8, 16, 17, 18};\nstatic const u8 DME1737_BIT_ALARM_TEMP[] = {4, 5, 6};\nstatic const u8 DME1737_BIT_ALARM_FAN[] = {10, 11, 12, 13, 22, 23};\n\n \n#define DME1737_REG_DEVICE\t\t0x3d\n#define DME1737_REG_COMPANY\t\t0x3e\n#define DME1737_REG_VERSTEP\t\t0x3f\n#define DME1737_REG_CONFIG\t\t0x40\n#define DME1737_REG_CONFIG2\t\t0x7f\n#define DME1737_REG_VID\t\t\t0x43\n#define DME1737_REG_TACH_PWM\t\t0x81\n\n \n\n \n#define DME1737_COMPANY_SMSC\t0x5c\n#define DME1737_VERSTEP\t\t0x88\n#define DME1737_VERSTEP_MASK\t0xf8\n#define SCH311X_DEVICE\t\t0x8c\n#define SCH5027_VERSTEP\t\t0x69\n#define SCH5127_DEVICE\t\t0x8e\n\n \n#define DME1737_ID_1\t0x77\n#define DME1737_ID_2\t0x78\n#define SCH3112_ID\t0x7c\n#define SCH3114_ID\t0x7d\n#define SCH3116_ID\t0x7f\n#define SCH5027_ID\t0x89\n#define SCH5127_ID\t0x86\n\n \n#define DME1737_EXTENT\t2\n\n \n#define HAS_TEMP_OFFSET\t\t(1 << 0)\t\t \n#define HAS_VID\t\t\t(1 << 1)\t\t \n#define HAS_ZONE3\t\t(1 << 2)\t\t \n#define HAS_ZONE_HYST\t\t(1 << 3)\t\t \n#define HAS_PWM_MIN\t\t(1 << 4)\t\t \n#define HAS_FAN(ix)\t\t(1 << ((ix) + 5))\t \n#define HAS_PWM(ix)\t\t(1 << ((ix) + 11))\t \n#define HAS_IN7\t\t\t(1 << 17)\t\t \n\n \n\nstruct dme1737_data {\n\tstruct i2c_client *client;\t \n\tstruct device *hwmon_dev;\n\tconst char *name;\n\tunsigned int addr;\t\t \n\n\tstruct mutex update_lock;\n\tbool valid;\t\t\t \n\tunsigned long last_update;\t \n\tunsigned long last_vbat;\t \n\tenum chips type;\n\tconst int *in_nominal;\t\t \n\n\tu8 vid;\n\tu8 pwm_rr_en;\n\tu32 has_features;\n\n\t \n\tu16 in[8];\n\tu8  in_min[8];\n\tu8  in_max[8];\n\ts16 temp[3];\n\ts8  temp_min[3];\n\ts8  temp_max[3];\n\ts8  temp_offset[3];\n\tu8  config;\n\tu8  config2;\n\tu8  vrm;\n\tu16 fan[6];\n\tu16 fan_min[6];\n\tu8  fan_max[2];\n\tu8  fan_opt[6];\n\tu8  pwm[6];\n\tu8  pwm_min[3];\n\tu8  pwm_config[3];\n\tu8  pwm_acz[3];\n\tu8  pwm_freq[6];\n\tu8  pwm_rr[2];\n\ts8  zone_low[3];\n\ts8  zone_abs[3];\n\tu8  zone_hyst[2];\n\tu32 alarms;\n};\n\n \nstatic const int IN_NOMINAL_DME1737[] = {5000, 2250, 3300, 5000, 12000, 3300,\n\t\t\t\t\t 3300};\nstatic const int IN_NOMINAL_SCH311x[] = {2500, 1500, 3300, 5000, 12000, 3300,\n\t\t\t\t\t 3300};\nstatic const int IN_NOMINAL_SCH5027[] = {5000, 2250, 3300, 1125, 1125, 3300,\n\t\t\t\t\t 3300};\nstatic const int IN_NOMINAL_SCH5127[] = {2500, 2250, 3300, 1125, 1125, 3300,\n\t\t\t\t\t 3300, 1500};\n#define IN_NOMINAL(type)\t((type) == sch311x ? IN_NOMINAL_SCH311x : \\\n\t\t\t\t (type) == sch5027 ? IN_NOMINAL_SCH5027 : \\\n\t\t\t\t (type) == sch5127 ? IN_NOMINAL_SCH5127 : \\\n\t\t\t\t IN_NOMINAL_DME1737)\n\n \nstatic inline int IN_FROM_REG(int reg, int nominal, int res)\n{\n\treturn (reg * nominal + (3 << (res - 3))) / (3 << (res - 2));\n}\n\nstatic inline int IN_TO_REG(long val, int nominal)\n{\n\tval = clamp_val(val, 0, 255 * nominal / 192);\n\treturn DIV_ROUND_CLOSEST(val * 192, nominal);\n}\n\n \nstatic inline int TEMP_FROM_REG(int reg, int res)\n{\n\treturn (reg * 1000) >> (res - 8);\n}\n\nstatic inline int TEMP_TO_REG(long val)\n{\n\tval = clamp_val(val, -128000, 127000);\n\treturn DIV_ROUND_CLOSEST(val, 1000);\n}\n\n \nstatic const int TEMP_RANGE[] = {2000, 2500, 3333, 4000, 5000, 6666, 8000,\n\t\t\t\t 10000, 13333, 16000, 20000, 26666, 32000,\n\t\t\t\t 40000, 53333, 80000};\n\nstatic inline int TEMP_RANGE_FROM_REG(int reg)\n{\n\treturn TEMP_RANGE[(reg >> 4) & 0x0f];\n}\n\nstatic int TEMP_RANGE_TO_REG(long val, int reg)\n{\n\tint i;\n\n\tfor (i = 15; i > 0; i--) {\n\t\tif (val > (TEMP_RANGE[i] + TEMP_RANGE[i - 1] + 1) / 2)\n\t\t\tbreak;\n\t}\n\n\treturn (reg & 0x0f) | (i << 4);\n}\n\n \nstatic inline int TEMP_HYST_FROM_REG(int reg, int ix)\n{\n\treturn (((ix == 1) ? reg : reg >> 4) & 0x0f) * 1000;\n}\n\nstatic inline int TEMP_HYST_TO_REG(int temp, long hyst, int ix, int reg)\n{\n\thyst = clamp_val(hyst, temp - 15000, temp);\n\thyst = DIV_ROUND_CLOSEST(temp - hyst, 1000);\n\n\treturn (ix == 1) ? (reg & 0xf0) | hyst : (reg & 0x0f) | (hyst << 4);\n}\n\n \nstatic inline int FAN_FROM_REG(int reg, int tpc)\n{\n\tif (tpc)\n\t\treturn tpc * reg;\n\telse\n\t\treturn (reg == 0 || reg == 0xffff) ? 0 : 90000 * 60 / reg;\n}\n\nstatic inline int FAN_TO_REG(long val, int tpc)\n{\n\tif (tpc) {\n\t\treturn clamp_val(val / tpc, 0, 0xffff);\n\t} else {\n\t\treturn (val <= 0) ? 0xffff :\n\t\t\tclamp_val(90000 * 60 / val, 0, 0xfffe);\n\t}\n}\n\n \nstatic inline int FAN_TPC_FROM_REG(int reg)\n{\n\treturn (reg & 0x20) ? 0 : 60 >> (reg & 0x03);\n}\n\n \nstatic inline int FAN_TYPE_FROM_REG(int reg)\n{\n\tint edge = (reg >> 1) & 0x03;\n\n\treturn (edge > 0) ? 1 << (edge - 1) : 0;\n}\n\nstatic inline int FAN_TYPE_TO_REG(long val, int reg)\n{\n\tint edge = (val == 4) ? 3 : val;\n\n\treturn (reg & 0xf9) | (edge << 1);\n}\n\n \nstatic const int FAN_MAX[] = {0x54, 0x38, 0x2a, 0x21, 0x1c, 0x18, 0x15, 0x12,\n\t\t\t      0x11, 0x0f, 0x0e};\n\nstatic int FAN_MAX_FROM_REG(int reg)\n{\n\tint i;\n\n\tfor (i = 10; i > 0; i--) {\n\t\tif (reg == FAN_MAX[i])\n\t\t\tbreak;\n\t}\n\n\treturn 1000 + i * 500;\n}\n\nstatic int FAN_MAX_TO_REG(long val)\n{\n\tint i;\n\n\tfor (i = 10; i > 0; i--) {\n\t\tif (val > (1000 + (i - 1) * 500))\n\t\t\tbreak;\n\t}\n\n\treturn FAN_MAX[i];\n}\n\n \nstatic inline int PWM_EN_FROM_REG(int reg)\n{\n\tstatic const int en[] = {2, 2, 2, 0, -1, 2, 2, 1};\n\n\treturn en[(reg >> 5) & 0x07];\n}\n\nstatic inline int PWM_EN_TO_REG(int val, int reg)\n{\n\tint en = (val == 1) ? 7 : 3;\n\n\treturn (reg & 0x1f) | ((en & 0x07) << 5);\n}\n\n \nstatic inline int PWM_ACZ_FROM_REG(int reg)\n{\n\tstatic const int acz[] = {1, 2, 4, 0, 0, 6, 7, 0};\n\n\treturn acz[(reg >> 5) & 0x07];\n}\n\nstatic inline int PWM_ACZ_TO_REG(long val, int reg)\n{\n\tint acz = (val == 4) ? 2 : val - 1;\n\n\treturn (reg & 0x1f) | ((acz & 0x07) << 5);\n}\n\n \nstatic const int PWM_FREQ[] = {11, 15, 22, 29, 35, 44, 59, 88,\n\t\t\t       15000, 20000, 30000, 25000, 0, 0, 0, 0};\n\nstatic inline int PWM_FREQ_FROM_REG(int reg)\n{\n\treturn PWM_FREQ[reg & 0x0f];\n}\n\nstatic int PWM_FREQ_TO_REG(long val, int reg)\n{\n\tint i;\n\n\t \n\tif (val > 27500) {\n\t\ti = 10;\n\t} else if (val > 22500) {\n\t\ti = 11;\n\t} else {\n\t\tfor (i = 9; i > 0; i--) {\n\t\t\tif (val > (PWM_FREQ[i] + PWM_FREQ[i - 1] + 1) / 2)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (reg & 0xf0) | i;\n}\n\n \nstatic const u8 PWM_RR[] = {206, 104, 69, 41, 26, 18, 10, 5};\n\nstatic inline int PWM_RR_FROM_REG(int reg, int ix)\n{\n\tint rr = (ix == 1) ? reg >> 4 : reg;\n\n\treturn (rr & 0x08) ? PWM_RR[rr & 0x07] : 0;\n}\n\nstatic int PWM_RR_TO_REG(long val, int ix, int reg)\n{\n\tint i;\n\n\tfor (i = 0; i < 7; i++) {\n\t\tif (val > (PWM_RR[i] + PWM_RR[i + 1] + 1) / 2)\n\t\t\tbreak;\n\t}\n\n\treturn (ix == 1) ? (reg & 0x8f) | (i << 4) : (reg & 0xf8) | i;\n}\n\n \nstatic inline int PWM_RR_EN_FROM_REG(int reg, int ix)\n{\n\treturn PWM_RR_FROM_REG(reg, ix) ? 1 : 0;\n}\n\nstatic inline int PWM_RR_EN_TO_REG(long val, int ix, int reg)\n{\n\tint en = (ix == 1) ? 0x80 : 0x08;\n\n\treturn val ? reg | en : reg & ~en;\n}\n\n \nstatic inline int PWM_OFF_FROM_REG(int reg, int ix)\n{\n\treturn (reg >> (ix + 5)) & 0x01;\n}\n\nstatic inline int PWM_OFF_TO_REG(int val, int ix, int reg)\n{\n\treturn (reg & ~(1 << (ix + 5))) | ((val & 0x01) << (ix + 5));\n}\n\n \n\nstatic u8 dme1737_read(const struct dme1737_data *data, u8 reg)\n{\n\tstruct i2c_client *client = data->client;\n\ts32 val;\n\n\tif (client) {  \n\t\tval = i2c_smbus_read_byte_data(client, reg);\n\n\t\tif (val < 0) {\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"Read from register 0x%02x failed! %s\\n\",\n\t\t\t\t reg, DO_REPORT);\n\t\t}\n\t} else {  \n\t\toutb(reg, data->addr);\n\t\tval = inb(data->addr + 1);\n\t}\n\n\treturn val;\n}\n\nstatic s32 dme1737_write(const struct dme1737_data *data, u8 reg, u8 val)\n{\n\tstruct i2c_client *client = data->client;\n\ts32 res = 0;\n\n\tif (client) {  \n\t\tres = i2c_smbus_write_byte_data(client, reg, val);\n\n\t\tif (res < 0) {\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"Write to register 0x%02x failed! %s\\n\",\n\t\t\t\t reg, DO_REPORT);\n\t\t}\n\t} else {  \n\t\toutb(reg, data->addr);\n\t\toutb(val, data->addr + 1);\n\t}\n\n\treturn res;\n}\n\nstatic struct dme1737_data *dme1737_update_device(struct device *dev)\n{\n\tstruct dme1737_data *data = dev_get_drvdata(dev);\n\tint ix;\n\tu8 lsb[6];\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tif (time_after(jiffies, data->last_vbat + 600 * HZ) || !data->valid) {\n\t\tdme1737_write(data, DME1737_REG_CONFIG, dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_CONFIG) | 0x10);\n\t\tdata->last_vbat = jiffies;\n\t}\n\n\t \n\tif (time_after(jiffies, data->last_update + HZ) || !data->valid) {\n\t\tif (data->has_features & HAS_VID) {\n\t\t\tdata->vid = dme1737_read(data, DME1737_REG_VID) &\n\t\t\t\t0x3f;\n\t\t}\n\n\t\t \n\t\tfor (ix = 0; ix < ARRAY_SIZE(data->in); ix++) {\n\t\t\t \n\t\t\tif (ix == 7 && !(data->has_features & HAS_IN7))\n\t\t\t\tcontinue;\n\t\t\tdata->in[ix] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_IN(ix)) << 8;\n\t\t\tdata->in_min[ix] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_IN_MIN(ix));\n\t\t\tdata->in_max[ix] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_IN_MAX(ix));\n\t\t}\n\n\t\t \n\t\tfor (ix = 0; ix < ARRAY_SIZE(data->temp); ix++) {\n\t\t\t \n\t\t\tdata->temp[ix] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_TEMP(ix)) << 8;\n\t\t\tdata->temp_min[ix] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_TEMP_MIN(ix));\n\t\t\tdata->temp_max[ix] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_TEMP_MAX(ix));\n\t\t\tif (data->has_features & HAS_TEMP_OFFSET) {\n\t\t\t\tdata->temp_offset[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_TEMP_OFFSET(ix));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (ix = 0; ix < ARRAY_SIZE(lsb); ix++) {\n\t\t\tif (ix == 5 && !(data->has_features & HAS_IN7))\n\t\t\t\tcontinue;\n\t\t\tlsb[ix] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_IN_TEMP_LSB(ix));\n\t\t}\n\t\tfor (ix = 0; ix < ARRAY_SIZE(data->in); ix++) {\n\t\t\tif (ix == 7 && !(data->has_features & HAS_IN7))\n\t\t\t\tcontinue;\n\t\t\tdata->in[ix] |= (lsb[DME1737_REG_IN_LSB[ix]] <<\n\t\t\t\t\tDME1737_REG_IN_LSB_SHL[ix]) & 0xf0;\n\t\t}\n\t\tfor (ix = 0; ix < ARRAY_SIZE(data->temp); ix++) {\n\t\t\tdata->temp[ix] |= (lsb[DME1737_REG_TEMP_LSB[ix]] <<\n\t\t\t\t\tDME1737_REG_TEMP_LSB_SHL[ix]) & 0xf0;\n\t\t}\n\n\t\t \n\t\tfor (ix = 0; ix < ARRAY_SIZE(data->fan); ix++) {\n\t\t\t \n\t\t\tif (!(data->has_features & HAS_FAN(ix)))\n\t\t\t\tcontinue;\n\t\t\tdata->fan[ix] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_FAN(ix));\n\t\t\tdata->fan[ix] |= dme1737_read(data,\n\t\t\t\t\tDME1737_REG_FAN(ix) + 1) << 8;\n\t\t\tdata->fan_min[ix] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_FAN_MIN(ix));\n\t\t\tdata->fan_min[ix] |= dme1737_read(data,\n\t\t\t\t\tDME1737_REG_FAN_MIN(ix) + 1) << 8;\n\t\t\tdata->fan_opt[ix] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_FAN_OPT(ix));\n\t\t\t \n\t\t\tif (ix > 3) {\n\t\t\t\tdata->fan_max[ix - 4] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_FAN_MAX(ix));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (ix = 0; ix < ARRAY_SIZE(data->pwm); ix++) {\n\t\t\t \n\t\t\tif (!(data->has_features & HAS_PWM(ix)))\n\t\t\t\tcontinue;\n\t\t\tdata->pwm[ix] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_PWM(ix));\n\t\t\tdata->pwm_freq[ix] = dme1737_read(data,\n\t\t\t\t\tDME1737_REG_PWM_FREQ(ix));\n\t\t\t \n\t\t\tif (ix < 3) {\n\t\t\t\tdata->pwm_config[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_CONFIG(ix));\n\t\t\t\tdata->pwm_min[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_MIN(ix));\n\t\t\t}\n\t\t}\n\t\tfor (ix = 0; ix < ARRAY_SIZE(data->pwm_rr); ix++) {\n\t\t\tdata->pwm_rr[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_RR(ix));\n\t\t}\n\n\t\t \n\t\tfor (ix = 0; ix < ARRAY_SIZE(data->zone_low); ix++) {\n\t\t\t \n\t\t\tif ((ix == 2) && !(data->has_features & HAS_ZONE3))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif ((ix == 1) && (data->type == sch5127)) {\n\t\t\t\tdata->zone_low[1] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_ZONE_LOW(2));\n\t\t\t\tdata->zone_abs[1] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_ZONE_ABS(2));\n\t\t\t} else {\n\t\t\t\tdata->zone_low[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_ZONE_LOW(ix));\n\t\t\t\tdata->zone_abs[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_ZONE_ABS(ix));\n\t\t\t}\n\t\t}\n\t\tif (data->has_features & HAS_ZONE_HYST) {\n\t\t\tfor (ix = 0; ix < ARRAY_SIZE(data->zone_hyst); ix++) {\n\t\t\t\tdata->zone_hyst[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_ZONE_HYST(ix));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdata->alarms = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_ALARM1);\n\t\t \n\t\tif (data->alarms & 0x80) {\n\t\t\tdata->alarms |= dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_ALARM2) << 8;\n\t\t\tdata->alarms |= dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_ALARM3) << 16;\n\t\t}\n\n\t\t \n\t\tif (!data->client) {\n\t\t\tif (data->alarms & 0xff0000)\n\t\t\t\tdme1737_write(data, DME1737_REG_ALARM3, 0xff);\n\t\t\tif (data->alarms & 0xff00)\n\t\t\t\tdme1737_write(data, DME1737_REG_ALARM2, 0xff);\n\t\t\tif (data->alarms & 0xff)\n\t\t\t\tdme1737_write(data, DME1737_REG_ALARM1, 0xff);\n\t\t}\n\n\t\tdata->last_update = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \n\n#define SYS_IN_INPUT\t0\n#define SYS_IN_MIN\t1\n#define SYS_IN_MAX\t2\n#define SYS_IN_ALARM\t3\n\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct dme1737_data *data = dme1737_update_device(dev);\n\tstruct sensor_device_attribute_2\n\t\t*sensor_attr_2 = to_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tint res;\n\n\tswitch (fn) {\n\tcase SYS_IN_INPUT:\n\t\tres = IN_FROM_REG(data->in[ix], data->in_nominal[ix], 16);\n\t\tbreak;\n\tcase SYS_IN_MIN:\n\t\tres = IN_FROM_REG(data->in_min[ix], data->in_nominal[ix], 8);\n\t\tbreak;\n\tcase SYS_IN_MAX:\n\t\tres = IN_FROM_REG(data->in_max[ix], data->in_nominal[ix], 8);\n\t\tbreak;\n\tcase SYS_IN_ALARM:\n\t\tres = (data->alarms >> DME1737_BIT_ALARM_IN[ix]) & 0x01;\n\t\tbreak;\n\tdefault:\n\t\tres = 0;\n\t\tdev_dbg(dev, \"Unknown function %d.\\n\", fn);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", res);\n}\n\nstatic ssize_t set_in(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct dme1737_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2\n\t\t*sensor_attr_2 = to_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (fn) {\n\tcase SYS_IN_MIN:\n\t\tdata->in_min[ix] = IN_TO_REG(val, data->in_nominal[ix]);\n\t\tdme1737_write(data, DME1737_REG_IN_MIN(ix),\n\t\t\t      data->in_min[ix]);\n\t\tbreak;\n\tcase SYS_IN_MAX:\n\t\tdata->in_max[ix] = IN_TO_REG(val, data->in_nominal[ix]);\n\t\tdme1737_write(data, DME1737_REG_IN_MAX(ix),\n\t\t\t      data->in_max[ix]);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown function %d.\\n\", fn);\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\n#define SYS_TEMP_INPUT\t\t\t0\n#define SYS_TEMP_MIN\t\t\t1\n#define SYS_TEMP_MAX\t\t\t2\n#define SYS_TEMP_OFFSET\t\t\t3\n#define SYS_TEMP_ALARM\t\t\t4\n#define SYS_TEMP_FAULT\t\t\t5\n\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct dme1737_data *data = dme1737_update_device(dev);\n\tstruct sensor_device_attribute_2\n\t\t*sensor_attr_2 = to_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tint res;\n\n\tswitch (fn) {\n\tcase SYS_TEMP_INPUT:\n\t\tres = TEMP_FROM_REG(data->temp[ix], 16);\n\t\tbreak;\n\tcase SYS_TEMP_MIN:\n\t\tres = TEMP_FROM_REG(data->temp_min[ix], 8);\n\t\tbreak;\n\tcase SYS_TEMP_MAX:\n\t\tres = TEMP_FROM_REG(data->temp_max[ix], 8);\n\t\tbreak;\n\tcase SYS_TEMP_OFFSET:\n\t\tres = TEMP_FROM_REG(data->temp_offset[ix], 8);\n\t\tbreak;\n\tcase SYS_TEMP_ALARM:\n\t\tres = (data->alarms >> DME1737_BIT_ALARM_TEMP[ix]) & 0x01;\n\t\tbreak;\n\tcase SYS_TEMP_FAULT:\n\t\tres = (((u16)data->temp[ix] & 0xff00) == 0x8000);\n\t\tbreak;\n\tdefault:\n\t\tres = 0;\n\t\tdev_dbg(dev, \"Unknown function %d.\\n\", fn);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", res);\n}\n\nstatic ssize_t set_temp(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct dme1737_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2\n\t\t*sensor_attr_2 = to_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (fn) {\n\tcase SYS_TEMP_MIN:\n\t\tdata->temp_min[ix] = TEMP_TO_REG(val);\n\t\tdme1737_write(data, DME1737_REG_TEMP_MIN(ix),\n\t\t\t      data->temp_min[ix]);\n\t\tbreak;\n\tcase SYS_TEMP_MAX:\n\t\tdata->temp_max[ix] = TEMP_TO_REG(val);\n\t\tdme1737_write(data, DME1737_REG_TEMP_MAX(ix),\n\t\t\t      data->temp_max[ix]);\n\t\tbreak;\n\tcase SYS_TEMP_OFFSET:\n\t\tdata->temp_offset[ix] = TEMP_TO_REG(val);\n\t\tdme1737_write(data, DME1737_REG_TEMP_OFFSET(ix),\n\t\t\t      data->temp_offset[ix]);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown function %d.\\n\", fn);\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\n#define SYS_ZONE_AUTO_CHANNELS_TEMP\t0\n#define SYS_ZONE_AUTO_POINT1_TEMP_HYST\t1\n#define SYS_ZONE_AUTO_POINT1_TEMP\t2\n#define SYS_ZONE_AUTO_POINT2_TEMP\t3\n#define SYS_ZONE_AUTO_POINT3_TEMP\t4\n\nstatic ssize_t show_zone(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct dme1737_data *data = dme1737_update_device(dev);\n\tstruct sensor_device_attribute_2\n\t\t*sensor_attr_2 = to_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tint res;\n\n\tswitch (fn) {\n\tcase SYS_ZONE_AUTO_CHANNELS_TEMP:\n\t\t \n\t\tif ((ix == 1) && (data->config2 & 0x02))\n\t\t\tres = 4;\n\t\telse\n\t\t\tres = 1 << ix;\n\t\tbreak;\n\tcase SYS_ZONE_AUTO_POINT1_TEMP_HYST:\n\t\tres = TEMP_FROM_REG(data->zone_low[ix], 8) -\n\t\t      TEMP_HYST_FROM_REG(data->zone_hyst[ix == 2], ix);\n\t\tbreak;\n\tcase SYS_ZONE_AUTO_POINT1_TEMP:\n\t\tres = TEMP_FROM_REG(data->zone_low[ix], 8);\n\t\tbreak;\n\tcase SYS_ZONE_AUTO_POINT2_TEMP:\n\t\t \n\t\tres = TEMP_FROM_REG(data->zone_low[ix], 8) +\n\t\t      TEMP_RANGE_FROM_REG(data->pwm_freq[ix]);\n\t\tbreak;\n\tcase SYS_ZONE_AUTO_POINT3_TEMP:\n\t\tres = TEMP_FROM_REG(data->zone_abs[ix], 8);\n\t\tbreak;\n\tdefault:\n\t\tres = 0;\n\t\tdev_dbg(dev, \"Unknown function %d.\\n\", fn);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", res);\n}\n\nstatic ssize_t set_zone(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct dme1737_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2\n\t\t*sensor_attr_2 = to_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tlong val;\n\tint temp;\n\tint err;\n\tu8 reg;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (fn) {\n\tcase SYS_ZONE_AUTO_POINT1_TEMP_HYST:\n\t\t \n\t\tdata->zone_low[ix] = dme1737_read(data,\n\t\t\t\t\t\t  DME1737_REG_ZONE_LOW(ix));\n\t\t \n\t\ttemp = TEMP_FROM_REG(data->zone_low[ix], 8);\n\t\treg = dme1737_read(data, DME1737_REG_ZONE_HYST(ix == 2));\n\t\tdata->zone_hyst[ix == 2] = TEMP_HYST_TO_REG(temp, val, ix, reg);\n\t\tdme1737_write(data, DME1737_REG_ZONE_HYST(ix == 2),\n\t\t\t      data->zone_hyst[ix == 2]);\n\t\tbreak;\n\tcase SYS_ZONE_AUTO_POINT1_TEMP:\n\t\tdata->zone_low[ix] = TEMP_TO_REG(val);\n\t\tdme1737_write(data, DME1737_REG_ZONE_LOW(ix),\n\t\t\t      data->zone_low[ix]);\n\t\tbreak;\n\tcase SYS_ZONE_AUTO_POINT2_TEMP:\n\t\t \n\t\tdata->zone_low[ix] = dme1737_read(data,\n\t\t\t\t\t\t  DME1737_REG_ZONE_LOW(ix));\n\t\t \n\t\ttemp = TEMP_FROM_REG(data->zone_low[ix], 8);\n\t\tval = clamp_val(val, temp, temp + 80000);\n\t\treg = dme1737_read(data, DME1737_REG_PWM_FREQ(ix));\n\t\tdata->pwm_freq[ix] = TEMP_RANGE_TO_REG(val - temp, reg);\n\t\tdme1737_write(data, DME1737_REG_PWM_FREQ(ix),\n\t\t\t      data->pwm_freq[ix]);\n\t\tbreak;\n\tcase SYS_ZONE_AUTO_POINT3_TEMP:\n\t\tdata->zone_abs[ix] = TEMP_TO_REG(val);\n\t\tdme1737_write(data, DME1737_REG_ZONE_ABS(ix),\n\t\t\t      data->zone_abs[ix]);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown function %d.\\n\", fn);\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\n#define SYS_FAN_INPUT\t0\n#define SYS_FAN_MIN\t1\n#define SYS_FAN_MAX\t2\n#define SYS_FAN_ALARM\t3\n#define SYS_FAN_TYPE\t4\n\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct dme1737_data *data = dme1737_update_device(dev);\n\tstruct sensor_device_attribute_2\n\t\t*sensor_attr_2 = to_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tint res;\n\n\tswitch (fn) {\n\tcase SYS_FAN_INPUT:\n\t\tres = FAN_FROM_REG(data->fan[ix],\n\t\t\t\t   ix < 4 ? 0 :\n\t\t\t\t   FAN_TPC_FROM_REG(data->fan_opt[ix]));\n\t\tbreak;\n\tcase SYS_FAN_MIN:\n\t\tres = FAN_FROM_REG(data->fan_min[ix],\n\t\t\t\t   ix < 4 ? 0 :\n\t\t\t\t   FAN_TPC_FROM_REG(data->fan_opt[ix]));\n\t\tbreak;\n\tcase SYS_FAN_MAX:\n\t\t \n\t\tres = FAN_MAX_FROM_REG(data->fan_max[ix - 4]);\n\t\tbreak;\n\tcase SYS_FAN_ALARM:\n\t\tres = (data->alarms >> DME1737_BIT_ALARM_FAN[ix]) & 0x01;\n\t\tbreak;\n\tcase SYS_FAN_TYPE:\n\t\t \n\t\tres = FAN_TYPE_FROM_REG(data->fan_opt[ix]);\n\t\tbreak;\n\tdefault:\n\t\tres = 0;\n\t\tdev_dbg(dev, \"Unknown function %d.\\n\", fn);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", res);\n}\n\nstatic ssize_t set_fan(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct dme1737_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2\n\t\t*sensor_attr_2 = to_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (fn) {\n\tcase SYS_FAN_MIN:\n\t\tif (ix < 4) {\n\t\t\tdata->fan_min[ix] = FAN_TO_REG(val, 0);\n\t\t} else {\n\t\t\t \n\t\t\tdata->fan_opt[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_FAN_OPT(ix));\n\t\t\t \n\t\t\tdata->fan_min[ix] = FAN_TO_REG(val,\n\t\t\t\t\tFAN_TPC_FROM_REG(data->fan_opt[ix]));\n\t\t}\n\t\tdme1737_write(data, DME1737_REG_FAN_MIN(ix),\n\t\t\t      data->fan_min[ix] & 0xff);\n\t\tdme1737_write(data, DME1737_REG_FAN_MIN(ix) + 1,\n\t\t\t      data->fan_min[ix] >> 8);\n\t\tbreak;\n\tcase SYS_FAN_MAX:\n\t\t \n\t\tdata->fan_max[ix - 4] = FAN_MAX_TO_REG(val);\n\t\tdme1737_write(data, DME1737_REG_FAN_MAX(ix),\n\t\t\t      data->fan_max[ix - 4]);\n\t\tbreak;\n\tcase SYS_FAN_TYPE:\n\t\t \n\t\tif (!(val == 1 || val == 2 || val == 4)) {\n\t\t\tcount = -EINVAL;\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Fan type value %ld not supported. Choose one of 1, 2, or 4.\\n\",\n\t\t\t\t val);\n\t\t\tgoto exit;\n\t\t}\n\t\tdata->fan_opt[ix] = FAN_TYPE_TO_REG(val, dme1737_read(data,\n\t\t\t\t\tDME1737_REG_FAN_OPT(ix)));\n\t\tdme1737_write(data, DME1737_REG_FAN_OPT(ix),\n\t\t\t      data->fan_opt[ix]);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown function %d.\\n\", fn);\n\t}\nexit:\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\n#define SYS_PWM\t\t\t\t0\n#define SYS_PWM_FREQ\t\t\t1\n#define SYS_PWM_ENABLE\t\t\t2\n#define SYS_PWM_RAMP_RATE\t\t3\n#define SYS_PWM_AUTO_CHANNELS_ZONE\t4\n#define SYS_PWM_AUTO_PWM_MIN\t\t5\n#define SYS_PWM_AUTO_POINT1_PWM\t\t6\n#define SYS_PWM_AUTO_POINT2_PWM\t\t7\n\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct dme1737_data *data = dme1737_update_device(dev);\n\tstruct sensor_device_attribute_2\n\t\t*sensor_attr_2 = to_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tint res;\n\n\tswitch (fn) {\n\tcase SYS_PWM:\n\t\tif (PWM_EN_FROM_REG(data->pwm_config[ix]) == 0)\n\t\t\tres = 255;\n\t\telse\n\t\t\tres = data->pwm[ix];\n\t\tbreak;\n\tcase SYS_PWM_FREQ:\n\t\tres = PWM_FREQ_FROM_REG(data->pwm_freq[ix]);\n\t\tbreak;\n\tcase SYS_PWM_ENABLE:\n\t\tif (ix >= 3)\n\t\t\tres = 1;  \n\t\telse\n\t\t\tres = PWM_EN_FROM_REG(data->pwm_config[ix]);\n\t\tbreak;\n\tcase SYS_PWM_RAMP_RATE:\n\t\t \n\t\tres = PWM_RR_FROM_REG(data->pwm_rr[ix > 0], ix);\n\t\tbreak;\n\tcase SYS_PWM_AUTO_CHANNELS_ZONE:\n\t\t \n\t\tif (PWM_EN_FROM_REG(data->pwm_config[ix]) == 2)\n\t\t\tres = PWM_ACZ_FROM_REG(data->pwm_config[ix]);\n\t\telse\n\t\t\tres = data->pwm_acz[ix];\n\t\tbreak;\n\tcase SYS_PWM_AUTO_PWM_MIN:\n\t\t \n\t\tif (PWM_OFF_FROM_REG(data->pwm_rr[0], ix))\n\t\t\tres = data->pwm_min[ix];\n\t\telse\n\t\t\tres = 0;\n\t\tbreak;\n\tcase SYS_PWM_AUTO_POINT1_PWM:\n\t\t \n\t\tres = data->pwm_min[ix];\n\t\tbreak;\n\tcase SYS_PWM_AUTO_POINT2_PWM:\n\t\t \n\t\tres = 255;  \n\t\tbreak;\n\tdefault:\n\t\tres = 0;\n\t\tdev_dbg(dev, \"Unknown function %d.\\n\", fn);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", res);\n}\n\nstatic struct attribute *dme1737_pwm_chmod_attr[];\nstatic void dme1737_chmod_file(struct device*, struct attribute*, umode_t);\n\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct dme1737_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2\n\t\t*sensor_attr_2 = to_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (fn) {\n\tcase SYS_PWM:\n\t\tdata->pwm[ix] = clamp_val(val, 0, 255);\n\t\tdme1737_write(data, DME1737_REG_PWM(ix), data->pwm[ix]);\n\t\tbreak;\n\tcase SYS_PWM_FREQ:\n\t\tdata->pwm_freq[ix] = PWM_FREQ_TO_REG(val, dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_FREQ(ix)));\n\t\tdme1737_write(data, DME1737_REG_PWM_FREQ(ix),\n\t\t\t      data->pwm_freq[ix]);\n\t\tbreak;\n\tcase SYS_PWM_ENABLE:\n\t\t \n\t\tif (val < 0 || val > 2) {\n\t\t\tcount = -EINVAL;\n\t\t\tdev_warn(dev,\n\t\t\t\t \"PWM enable %ld not supported. Choose one of 0, 1, or 2.\\n\",\n\t\t\t\t val);\n\t\t\tgoto exit;\n\t\t}\n\t\t \n\t\tdata->pwm_config[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_CONFIG(ix));\n\t\tif (val == PWM_EN_FROM_REG(data->pwm_config[ix])) {\n\t\t\t \n\t\t\tgoto exit;\n\t\t}\n\t\t \n\t\tif (PWM_EN_FROM_REG(data->pwm_config[ix]) == 2) {\n\t\t\t \n\t\t\tdata->pwm_acz[ix] = PWM_ACZ_FROM_REG(\n\t\t\t\t\t\t\tdata->pwm_config[ix]);\n\t\t\t \n\t\t\tdata->pwm_rr[ix > 0] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_RR(ix > 0));\n\t\t\tdata->pwm_rr_en &= ~(1 << ix);\n\t\t\tif (PWM_RR_EN_FROM_REG(data->pwm_rr[ix > 0], ix)) {\n\t\t\t\tdata->pwm_rr_en |= (1 << ix);\n\t\t\t\tdata->pwm_rr[ix > 0] = PWM_RR_EN_TO_REG(0, ix,\n\t\t\t\t\t\t\tdata->pwm_rr[ix > 0]);\n\t\t\t\tdme1737_write(data,\n\t\t\t\t\t      DME1737_REG_PWM_RR(ix > 0),\n\t\t\t\t\t      data->pwm_rr[ix > 0]);\n\t\t\t}\n\t\t}\n\t\t \n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\t \n\t\t\tdme1737_chmod_file(dev, dme1737_pwm_chmod_attr[ix],\n\t\t\t\t\t   S_IRUGO);\n\t\t\t \n\t\t\tdata->pwm_config[ix] = PWM_EN_TO_REG(0,\n\t\t\t\t\t\t\tdata->pwm_config[ix]);\n\t\t\tdme1737_write(data, DME1737_REG_PWM_CONFIG(ix),\n\t\t\t\t      data->pwm_config[ix]);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tdata->pwm_config[ix] = PWM_EN_TO_REG(1,\n\t\t\t\t\t\t\tdata->pwm_config[ix]);\n\t\t\tdme1737_write(data, DME1737_REG_PWM_CONFIG(ix),\n\t\t\t\t      data->pwm_config[ix]);\n\t\t\t \n\t\t\tdme1737_chmod_file(dev, dme1737_pwm_chmod_attr[ix],\n\t\t\t\t\t   S_IRUGO | S_IWUSR);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tdme1737_chmod_file(dev, dme1737_pwm_chmod_attr[ix],\n\t\t\t\t\t   S_IRUGO);\n\t\t\t \n\t\t\tdata->pwm_config[ix] = PWM_ACZ_TO_REG(\n\t\t\t\t\t\t\tdata->pwm_acz[ix],\n\t\t\t\t\t\t\tdata->pwm_config[ix]);\n\t\t\tdme1737_write(data, DME1737_REG_PWM_CONFIG(ix),\n\t\t\t\t      data->pwm_config[ix]);\n\t\t\t \n\t\t\tif (data->pwm_rr_en & (1 << ix)) {\n\t\t\t\tdata->pwm_rr[ix > 0] = PWM_RR_EN_TO_REG(1, ix,\n\t\t\t\t\t\tdme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_RR(ix > 0)));\n\t\t\t\tdme1737_write(data,\n\t\t\t\t\t      DME1737_REG_PWM_RR(ix > 0),\n\t\t\t\t\t      data->pwm_rr[ix > 0]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SYS_PWM_RAMP_RATE:\n\t\t \n\t\t \n\t\tdata->pwm_config[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_CONFIG(ix));\n\t\tdata->pwm_rr[ix > 0] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_RR(ix > 0));\n\t\t \n\t\tif (val > 0) {\n\t\t\tdata->pwm_rr[ix > 0] = PWM_RR_TO_REG(val, ix,\n\t\t\t\t\t\t\tdata->pwm_rr[ix > 0]);\n\t\t}\n\t\t \n\t\tif (PWM_EN_FROM_REG(data->pwm_config[ix]) == 2) {\n\t\t\tdata->pwm_rr[ix > 0] = PWM_RR_EN_TO_REG(val > 0, ix,\n\t\t\t\t\t\t\tdata->pwm_rr[ix > 0]);\n\t\t}\n\t\tdme1737_write(data, DME1737_REG_PWM_RR(ix > 0),\n\t\t\t      data->pwm_rr[ix > 0]);\n\t\tbreak;\n\tcase SYS_PWM_AUTO_CHANNELS_ZONE:\n\t\t \n\t\tif (!(val == 1 || val == 2 || val == 4 ||\n\t\t      val == 6 || val == 7)) {\n\t\t\tcount = -EINVAL;\n\t\t\tdev_warn(dev,\n\t\t\t\t \"PWM auto channels zone %ld not supported. Choose one of 1, 2, 4, 6, \"\n\t\t\t\t \"or 7.\\n\", val);\n\t\t\tgoto exit;\n\t\t}\n\t\t \n\t\tdata->pwm_config[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_CONFIG(ix));\n\t\tif (PWM_EN_FROM_REG(data->pwm_config[ix]) == 2) {\n\t\t\t \n\t\t\tdata->pwm_config[ix] = PWM_ACZ_TO_REG(val,\n\t\t\t\t\t\tdata->pwm_config[ix]);\n\t\t\tdme1737_write(data, DME1737_REG_PWM_CONFIG(ix),\n\t\t\t\t      data->pwm_config[ix]);\n\t\t} else {\n\t\t\t \n\t\t\tdata->pwm_acz[ix] = val;\n\t\t}\n\t\tbreak;\n\tcase SYS_PWM_AUTO_PWM_MIN:\n\t\t \n\t\t \n\t\tdata->pwm_min[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_MIN(ix));\n\t\t \n\t\tif (val > ((data->pwm_min[ix] + 1) / 2)) {\n\t\t\tdata->pwm_rr[0] = PWM_OFF_TO_REG(1, ix,\n\t\t\t\t\t\tdme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_RR(0)));\n\t\t} else {\n\t\t\tdata->pwm_rr[0] = PWM_OFF_TO_REG(0, ix,\n\t\t\t\t\t\tdme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_RR(0)));\n\t\t}\n\t\tdme1737_write(data, DME1737_REG_PWM_RR(0),\n\t\t\t      data->pwm_rr[0]);\n\t\tbreak;\n\tcase SYS_PWM_AUTO_POINT1_PWM:\n\t\t \n\t\tdata->pwm_min[ix] = clamp_val(val, 0, 255);\n\t\tdme1737_write(data, DME1737_REG_PWM_MIN(ix),\n\t\t\t      data->pwm_min[ix]);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown function %d.\\n\", fn);\n\t}\nexit:\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\nstatic ssize_t vrm_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct dme1737_data *data = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"%d\\n\", data->vrm);\n}\n\nstatic ssize_t vrm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct dme1737_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tdata->vrm = val;\n\treturn count;\n}\n\nstatic ssize_t cpu0_vid_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct dme1737_data *data = dme1737_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", vid_from_reg(data->vid, data->vrm));\n}\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct dme1737_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", data->name);\n}\n\n \n\n \n\n#define SENSOR_DEVICE_ATTR_IN(ix) \\\nstatic SENSOR_DEVICE_ATTR_2(in##ix##_input, S_IRUGO, \\\n\tshow_in, NULL, SYS_IN_INPUT, ix); \\\nstatic SENSOR_DEVICE_ATTR_2(in##ix##_min, S_IRUGO | S_IWUSR, \\\n\tshow_in, set_in, SYS_IN_MIN, ix); \\\nstatic SENSOR_DEVICE_ATTR_2(in##ix##_max, S_IRUGO | S_IWUSR, \\\n\tshow_in, set_in, SYS_IN_MAX, ix); \\\nstatic SENSOR_DEVICE_ATTR_2(in##ix##_alarm, S_IRUGO, \\\n\tshow_in, NULL, SYS_IN_ALARM, ix)\n\nSENSOR_DEVICE_ATTR_IN(0);\nSENSOR_DEVICE_ATTR_IN(1);\nSENSOR_DEVICE_ATTR_IN(2);\nSENSOR_DEVICE_ATTR_IN(3);\nSENSOR_DEVICE_ATTR_IN(4);\nSENSOR_DEVICE_ATTR_IN(5);\nSENSOR_DEVICE_ATTR_IN(6);\nSENSOR_DEVICE_ATTR_IN(7);\n\n \n\n#define SENSOR_DEVICE_ATTR_TEMP(ix) \\\nstatic SENSOR_DEVICE_ATTR_2(temp##ix##_input, S_IRUGO, \\\n\tshow_temp, NULL, SYS_TEMP_INPUT, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(temp##ix##_min, S_IRUGO | S_IWUSR, \\\n\tshow_temp, set_temp, SYS_TEMP_MIN, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(temp##ix##_max, S_IRUGO | S_IWUSR, \\\n\tshow_temp, set_temp, SYS_TEMP_MAX, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(temp##ix##_offset, S_IRUGO, \\\n\tshow_temp, set_temp, SYS_TEMP_OFFSET, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(temp##ix##_alarm, S_IRUGO, \\\n\tshow_temp, NULL, SYS_TEMP_ALARM, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(temp##ix##_fault, S_IRUGO, \\\n\tshow_temp, NULL, SYS_TEMP_FAULT, ix-1)\n\nSENSOR_DEVICE_ATTR_TEMP(1);\nSENSOR_DEVICE_ATTR_TEMP(2);\nSENSOR_DEVICE_ATTR_TEMP(3);\n\n \n\n#define SENSOR_DEVICE_ATTR_ZONE(ix) \\\nstatic SENSOR_DEVICE_ATTR_2(zone##ix##_auto_channels_temp, S_IRUGO, \\\n\tshow_zone, NULL, SYS_ZONE_AUTO_CHANNELS_TEMP, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(zone##ix##_auto_point1_temp_hyst, S_IRUGO, \\\n\tshow_zone, set_zone, SYS_ZONE_AUTO_POINT1_TEMP_HYST, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(zone##ix##_auto_point1_temp, S_IRUGO, \\\n\tshow_zone, set_zone, SYS_ZONE_AUTO_POINT1_TEMP, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(zone##ix##_auto_point2_temp, S_IRUGO, \\\n\tshow_zone, set_zone, SYS_ZONE_AUTO_POINT2_TEMP, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(zone##ix##_auto_point3_temp, S_IRUGO, \\\n\tshow_zone, set_zone, SYS_ZONE_AUTO_POINT3_TEMP, ix-1)\n\nSENSOR_DEVICE_ATTR_ZONE(1);\nSENSOR_DEVICE_ATTR_ZONE(2);\nSENSOR_DEVICE_ATTR_ZONE(3);\n\n \n\n#define SENSOR_DEVICE_ATTR_FAN_1TO4(ix) \\\nstatic SENSOR_DEVICE_ATTR_2(fan##ix##_input, S_IRUGO, \\\n\tshow_fan, NULL, SYS_FAN_INPUT, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(fan##ix##_min, S_IRUGO | S_IWUSR, \\\n\tshow_fan, set_fan, SYS_FAN_MIN, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(fan##ix##_alarm, S_IRUGO, \\\n\tshow_fan, NULL, SYS_FAN_ALARM, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(fan##ix##_type, S_IRUGO | S_IWUSR, \\\n\tshow_fan, set_fan, SYS_FAN_TYPE, ix-1)\n\nSENSOR_DEVICE_ATTR_FAN_1TO4(1);\nSENSOR_DEVICE_ATTR_FAN_1TO4(2);\nSENSOR_DEVICE_ATTR_FAN_1TO4(3);\nSENSOR_DEVICE_ATTR_FAN_1TO4(4);\n\n \n\n#define SENSOR_DEVICE_ATTR_FAN_5TO6(ix) \\\nstatic SENSOR_DEVICE_ATTR_2(fan##ix##_input, S_IRUGO, \\\n\tshow_fan, NULL, SYS_FAN_INPUT, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(fan##ix##_min, S_IRUGO | S_IWUSR, \\\n\tshow_fan, set_fan, SYS_FAN_MIN, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(fan##ix##_alarm, S_IRUGO, \\\n\tshow_fan, NULL, SYS_FAN_ALARM, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(fan##ix##_max, S_IRUGO | S_IWUSR, \\\n\tshow_fan, set_fan, SYS_FAN_MAX, ix-1)\n\nSENSOR_DEVICE_ATTR_FAN_5TO6(5);\nSENSOR_DEVICE_ATTR_FAN_5TO6(6);\n\n \n\n#define SENSOR_DEVICE_ATTR_PWM_1TO3(ix) \\\nstatic SENSOR_DEVICE_ATTR_2(pwm##ix, S_IRUGO, \\\n\tshow_pwm, set_pwm, SYS_PWM, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(pwm##ix##_freq, S_IRUGO, \\\n\tshow_pwm, set_pwm, SYS_PWM_FREQ, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(pwm##ix##_enable, S_IRUGO, \\\n\tshow_pwm, set_pwm, SYS_PWM_ENABLE, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(pwm##ix##_ramp_rate, S_IRUGO, \\\n\tshow_pwm, set_pwm, SYS_PWM_RAMP_RATE, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(pwm##ix##_auto_channels_zone, S_IRUGO, \\\n\tshow_pwm, set_pwm, SYS_PWM_AUTO_CHANNELS_ZONE, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(pwm##ix##_auto_pwm_min, S_IRUGO, \\\n\tshow_pwm, set_pwm, SYS_PWM_AUTO_PWM_MIN, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(pwm##ix##_auto_point1_pwm, S_IRUGO, \\\n\tshow_pwm, set_pwm, SYS_PWM_AUTO_POINT1_PWM, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(pwm##ix##_auto_point2_pwm, S_IRUGO, \\\n\tshow_pwm, NULL, SYS_PWM_AUTO_POINT2_PWM, ix-1)\n\nSENSOR_DEVICE_ATTR_PWM_1TO3(1);\nSENSOR_DEVICE_ATTR_PWM_1TO3(2);\nSENSOR_DEVICE_ATTR_PWM_1TO3(3);\n\n \n\n#define SENSOR_DEVICE_ATTR_PWM_5TO6(ix) \\\nstatic SENSOR_DEVICE_ATTR_2(pwm##ix, S_IRUGO, \\\n\tshow_pwm, set_pwm, SYS_PWM, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(pwm##ix##_freq, S_IRUGO, \\\n\tshow_pwm, set_pwm, SYS_PWM_FREQ, ix-1); \\\nstatic SENSOR_DEVICE_ATTR_2(pwm##ix##_enable, S_IRUGO, \\\n\tshow_pwm, NULL, SYS_PWM_ENABLE, ix-1)\n\nSENSOR_DEVICE_ATTR_PWM_5TO6(5);\nSENSOR_DEVICE_ATTR_PWM_5TO6(6);\n\n \n\nstatic DEVICE_ATTR_RW(vrm);\nstatic DEVICE_ATTR_RO(cpu0_vid);\nstatic DEVICE_ATTR_RO(name);    \n\n \nstatic struct attribute *dme1737_attr[] = {\n\t \n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_min.dev_attr.attr,\n\t&sensor_dev_attr_in6_max.dev_attr.attr,\n\t&sensor_dev_attr_in6_alarm.dev_attr.attr,\n\t \n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_fault.dev_attr.attr,\n\t \n\t&sensor_dev_attr_zone1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone1_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone1_auto_channels_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone2_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone2_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone2_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone2_auto_channels_temp.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dme1737_group = {\n\t.attrs = dme1737_attr,\n};\n\n \nstatic struct attribute *dme1737_temp_offset_attr[] = {\n\t&sensor_dev_attr_temp1_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp2_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp3_offset.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dme1737_temp_offset_group = {\n\t.attrs = dme1737_temp_offset_attr,\n};\n\n \nstatic struct attribute *dme1737_vid_attr[] = {\n\t&dev_attr_vrm.attr,\n\t&dev_attr_cpu0_vid.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dme1737_vid_group = {\n\t.attrs = dme1737_vid_attr,\n};\n\n \nstatic struct attribute *dme1737_zone3_attr[] = {\n\t&sensor_dev_attr_zone3_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone3_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone3_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone3_auto_channels_temp.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dme1737_zone3_group = {\n\t.attrs = dme1737_zone3_attr,\n};\n\n\n \nstatic struct attribute *dme1737_zone_hyst_attr[] = {\n\t&sensor_dev_attr_zone1_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_zone2_auto_point1_temp_hyst.dev_attr.attr,\n\t&sensor_dev_attr_zone3_auto_point1_temp_hyst.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dme1737_zone_hyst_group = {\n\t.attrs = dme1737_zone_hyst_attr,\n};\n\n \nstatic struct attribute *dme1737_in7_attr[] = {\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_min.dev_attr.attr,\n\t&sensor_dev_attr_in7_max.dev_attr.attr,\n\t&sensor_dev_attr_in7_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dme1737_in7_group = {\n\t.attrs = dme1737_in7_attr,\n};\n\n \nstatic struct attribute *dme1737_pwm1_attr[] = {\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_ramp_rate.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_channels_zone.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_pwm2_attr[] = {\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_ramp_rate.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_channels_zone.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point2_pwm.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_pwm3_attr[] = {\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_ramp_rate.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_channels_zone.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point2_pwm.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_pwm5_attr[] = {\n\t&sensor_dev_attr_pwm5.dev_attr.attr,\n\t&sensor_dev_attr_pwm5_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm5_enable.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_pwm6_attr[] = {\n\t&sensor_dev_attr_pwm6.dev_attr.attr,\n\t&sensor_dev_attr_pwm6_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm6_enable.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dme1737_pwm_group[] = {\n\t{ .attrs = dme1737_pwm1_attr },\n\t{ .attrs = dme1737_pwm2_attr },\n\t{ .attrs = dme1737_pwm3_attr },\n\t{ .attrs = NULL },\n\t{ .attrs = dme1737_pwm5_attr },\n\t{ .attrs = dme1737_pwm6_attr },\n};\n\n \nstatic struct attribute *dme1737_auto_pwm_min_attr[] = {\n\t&sensor_dev_attr_pwm1_auto_pwm_min.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_pwm_min.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_pwm_min.dev_attr.attr,\n};\n\n \nstatic struct attribute *dme1737_fan1_attr[] = {\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan1_type.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_fan2_attr[] = {\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_type.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_fan3_attr[] = {\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan3_type.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_fan4_attr[] = {\n\t&sensor_dev_attr_fan4_input.dev_attr.attr,\n\t&sensor_dev_attr_fan4_min.dev_attr.attr,\n\t&sensor_dev_attr_fan4_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan4_type.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_fan5_attr[] = {\n\t&sensor_dev_attr_fan5_input.dev_attr.attr,\n\t&sensor_dev_attr_fan5_min.dev_attr.attr,\n\t&sensor_dev_attr_fan5_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan5_max.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_fan6_attr[] = {\n\t&sensor_dev_attr_fan6_input.dev_attr.attr,\n\t&sensor_dev_attr_fan6_min.dev_attr.attr,\n\t&sensor_dev_attr_fan6_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan6_max.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dme1737_fan_group[] = {\n\t{ .attrs = dme1737_fan1_attr },\n\t{ .attrs = dme1737_fan2_attr },\n\t{ .attrs = dme1737_fan3_attr },\n\t{ .attrs = dme1737_fan4_attr },\n\t{ .attrs = dme1737_fan5_attr },\n\t{ .attrs = dme1737_fan6_attr },\n};\n\n \nstatic struct attribute *dme1737_zone_chmod_attr[] = {\n\t&sensor_dev_attr_zone1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone1_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone2_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone2_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone2_auto_point3_temp.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dme1737_zone_chmod_group = {\n\t.attrs = dme1737_zone_chmod_attr,\n};\n\n\n \nstatic struct attribute *dme1737_zone3_chmod_attr[] = {\n\t&sensor_dev_attr_zone3_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone3_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_zone3_auto_point3_temp.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dme1737_zone3_chmod_group = {\n\t.attrs = dme1737_zone3_chmod_attr,\n};\n\n \nstatic struct attribute *dme1737_pwm1_chmod_attr[] = {\n\t&sensor_dev_attr_pwm1_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_ramp_rate.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_channels_zone.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_pwm2_chmod_attr[] = {\n\t&sensor_dev_attr_pwm2_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_ramp_rate.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_channels_zone.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point1_pwm.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_pwm3_chmod_attr[] = {\n\t&sensor_dev_attr_pwm3_freq.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_ramp_rate.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_channels_zone.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point1_pwm.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_pwm5_chmod_attr[] = {\n\t&sensor_dev_attr_pwm5.dev_attr.attr,\n\t&sensor_dev_attr_pwm5_freq.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute *dme1737_pwm6_chmod_attr[] = {\n\t&sensor_dev_attr_pwm6.dev_attr.attr,\n\t&sensor_dev_attr_pwm6_freq.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dme1737_pwm_chmod_group[] = {\n\t{ .attrs = dme1737_pwm1_chmod_attr },\n\t{ .attrs = dme1737_pwm2_chmod_attr },\n\t{ .attrs = dme1737_pwm3_chmod_attr },\n\t{ .attrs = NULL },\n\t{ .attrs = dme1737_pwm5_chmod_attr },\n\t{ .attrs = dme1737_pwm6_chmod_attr },\n};\n\n \nstatic struct attribute *dme1737_pwm_chmod_attr[] = {\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n};\n\n \n\nstatic inline void dme1737_sio_enter(int sio_cip)\n{\n\toutb(0x55, sio_cip);\n}\n\nstatic inline void dme1737_sio_exit(int sio_cip)\n{\n\toutb(0xaa, sio_cip);\n}\n\nstatic inline int dme1737_sio_inb(int sio_cip, int reg)\n{\n\toutb(reg, sio_cip);\n\treturn inb(sio_cip + 1);\n}\n\nstatic inline void dme1737_sio_outb(int sio_cip, int reg, int val)\n{\n\toutb(reg, sio_cip);\n\toutb(val, sio_cip + 1);\n}\n\n \n\nstatic int dme1737_i2c_get_features(int, struct dme1737_data*);\n\nstatic void dme1737_chmod_file(struct device *dev,\n\t\t\t       struct attribute *attr, umode_t mode)\n{\n\tif (sysfs_chmod_file(&dev->kobj, attr, mode)) {\n\t\tdev_warn(dev, \"Failed to change permissions of %s.\\n\",\n\t\t\t attr->name);\n\t}\n}\n\nstatic void dme1737_chmod_group(struct device *dev,\n\t\t\t\tconst struct attribute_group *group,\n\t\t\t\tumode_t mode)\n{\n\tstruct attribute **attr;\n\n\tfor (attr = group->attrs; *attr; attr++)\n\t\tdme1737_chmod_file(dev, *attr, mode);\n}\n\nstatic void dme1737_remove_files(struct device *dev)\n{\n\tstruct dme1737_data *data = dev_get_drvdata(dev);\n\tint ix;\n\n\tfor (ix = 0; ix < ARRAY_SIZE(dme1737_fan_group); ix++) {\n\t\tif (data->has_features & HAS_FAN(ix)) {\n\t\t\tsysfs_remove_group(&dev->kobj,\n\t\t\t\t\t   &dme1737_fan_group[ix]);\n\t\t}\n\t}\n\n\tfor (ix = 0; ix < ARRAY_SIZE(dme1737_pwm_group); ix++) {\n\t\tif (data->has_features & HAS_PWM(ix)) {\n\t\t\tsysfs_remove_group(&dev->kobj,\n\t\t\t\t\t   &dme1737_pwm_group[ix]);\n\t\t\tif ((data->has_features & HAS_PWM_MIN) && ix < 3) {\n\t\t\t\tsysfs_remove_file(&dev->kobj,\n\t\t\t\t\t\tdme1737_auto_pwm_min_attr[ix]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (data->has_features & HAS_TEMP_OFFSET)\n\t\tsysfs_remove_group(&dev->kobj, &dme1737_temp_offset_group);\n\tif (data->has_features & HAS_VID)\n\t\tsysfs_remove_group(&dev->kobj, &dme1737_vid_group);\n\tif (data->has_features & HAS_ZONE3)\n\t\tsysfs_remove_group(&dev->kobj, &dme1737_zone3_group);\n\tif (data->has_features & HAS_ZONE_HYST)\n\t\tsysfs_remove_group(&dev->kobj, &dme1737_zone_hyst_group);\n\tif (data->has_features & HAS_IN7)\n\t\tsysfs_remove_group(&dev->kobj, &dme1737_in7_group);\n\tsysfs_remove_group(&dev->kobj, &dme1737_group);\n\n\tif (!data->client)\n\t\tsysfs_remove_file(&dev->kobj, &dev_attr_name.attr);\n}\n\nstatic int dme1737_create_files(struct device *dev)\n{\n\tstruct dme1737_data *data = dev_get_drvdata(dev);\n\tint err, ix;\n\n\t \n\tif (!data->client) {\n\t\terr = sysfs_create_file(&dev->kobj, &dev_attr_name.attr);\n\t\tif (err)\n\t\t\tgoto exit;\n\t}\n\n\t \n\terr = sysfs_create_group(&dev->kobj, &dme1737_group);\n\tif (err)\n\t\tgoto exit_remove;\n\n\t \n\tif (data->has_features & HAS_TEMP_OFFSET) {\n\t\terr = sysfs_create_group(&dev->kobj,\n\t\t\t\t\t &dme1737_temp_offset_group);\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\t}\n\tif (data->has_features & HAS_VID) {\n\t\terr = sysfs_create_group(&dev->kobj, &dme1737_vid_group);\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\t}\n\tif (data->has_features & HAS_ZONE3) {\n\t\terr = sysfs_create_group(&dev->kobj, &dme1737_zone3_group);\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\t}\n\tif (data->has_features & HAS_ZONE_HYST) {\n\t\terr = sysfs_create_group(&dev->kobj, &dme1737_zone_hyst_group);\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\t}\n\tif (data->has_features & HAS_IN7) {\n\t\terr = sysfs_create_group(&dev->kobj, &dme1737_in7_group);\n\t\tif (err)\n\t\t\tgoto exit_remove;\n\t}\n\n\t \n\tfor (ix = 0; ix < ARRAY_SIZE(dme1737_fan_group); ix++) {\n\t\tif (data->has_features & HAS_FAN(ix)) {\n\t\t\terr = sysfs_create_group(&dev->kobj,\n\t\t\t\t\t\t &dme1737_fan_group[ix]);\n\t\t\tif (err)\n\t\t\t\tgoto exit_remove;\n\t\t}\n\t}\n\n\t \n\tfor (ix = 0; ix < ARRAY_SIZE(dme1737_pwm_group); ix++) {\n\t\tif (data->has_features & HAS_PWM(ix)) {\n\t\t\terr = sysfs_create_group(&dev->kobj,\n\t\t\t\t\t\t &dme1737_pwm_group[ix]);\n\t\t\tif (err)\n\t\t\t\tgoto exit_remove;\n\t\t\tif ((data->has_features & HAS_PWM_MIN) && (ix < 3)) {\n\t\t\t\terr = sysfs_create_file(&dev->kobj,\n\t\t\t\t\t\tdme1737_auto_pwm_min_attr[ix]);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto exit_remove;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (data->config & 0x02) {\n\t\tdev_info(dev,\n\t\t\t \"Device is locked. Some attributes will be read-only.\\n\");\n\t} else {\n\t\t \n\t\tdme1737_chmod_group(dev, &dme1737_zone_chmod_group,\n\t\t\t\t    S_IRUGO | S_IWUSR);\n\n\t\t \n\t\tif (data->has_features & HAS_TEMP_OFFSET) {\n\t\t\tdme1737_chmod_group(dev, &dme1737_temp_offset_group,\n\t\t\t\t\t    S_IRUGO | S_IWUSR);\n\t\t}\n\t\tif (data->has_features & HAS_ZONE3) {\n\t\t\tdme1737_chmod_group(dev, &dme1737_zone3_chmod_group,\n\t\t\t\t\t    S_IRUGO | S_IWUSR);\n\t\t}\n\t\tif (data->has_features & HAS_ZONE_HYST) {\n\t\t\tdme1737_chmod_group(dev, &dme1737_zone_hyst_group,\n\t\t\t\t\t    S_IRUGO | S_IWUSR);\n\t\t}\n\n\t\t \n\t\tfor (ix = 0; ix < ARRAY_SIZE(dme1737_pwm_chmod_group); ix++) {\n\t\t\tif (data->has_features & HAS_PWM(ix)) {\n\t\t\t\tdme1737_chmod_group(dev,\n\t\t\t\t\t\t&dme1737_pwm_chmod_group[ix],\n\t\t\t\t\t\tS_IRUGO | S_IWUSR);\n\t\t\t\tif ((data->has_features & HAS_PWM_MIN) &&\n\t\t\t\t    ix < 3) {\n\t\t\t\t\tdme1737_chmod_file(dev,\n\t\t\t\t\t\tdme1737_auto_pwm_min_attr[ix],\n\t\t\t\t\t\tS_IRUGO | S_IWUSR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (ix = 0; ix < 3; ix++) {\n\t\t\tif ((data->has_features & HAS_PWM(ix)) &&\n\t\t\t    (PWM_EN_FROM_REG(data->pwm_config[ix]) == 1)) {\n\t\t\t\tdme1737_chmod_file(dev,\n\t\t\t\t\t\tdme1737_pwm_chmod_attr[ix],\n\t\t\t\t\t\tS_IRUGO | S_IWUSR);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nexit_remove:\n\tdme1737_remove_files(dev);\nexit:\n\treturn err;\n}\n\nstatic int dme1737_init_device(struct device *dev)\n{\n\tstruct dme1737_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ix;\n\tu8 reg;\n\n\t \n\tdata->in_nominal = IN_NOMINAL(data->type);\n\n\tdata->config = dme1737_read(data, DME1737_REG_CONFIG);\n\t \n\tif (!(data->config & 0x01)) {\n\t\tif (!force_start) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Device is not monitoring. Use the force_start load parameter to override.\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t \n\t\tdata->config |= 0x01;\n\t\tdme1737_write(data, DME1737_REG_CONFIG, data->config);\n\t}\n\t \n\tif (!(data->config & 0x04)) {\n\t\tdev_err(dev, \"Device is not ready.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (client) {    \n\t\tdata->config2 = dme1737_read(data, DME1737_REG_CONFIG2);\n\t\t \n\t\tif (data->config2 & 0x04)\n\t\t\tdata->has_features |= HAS_FAN(2);\n\n\t\t \n\t\tif (client->addr == 0x2e)\n\t\t\tdata->has_features |= HAS_FAN(3) | HAS_PWM(2);\n\n\t\t \n\t\tif (dme1737_i2c_get_features(0x2e, data) &&\n\t\t    dme1737_i2c_get_features(0x4e, data)) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Failed to query Super-IO for optional features.\\n\");\n\t\t}\n\t}\n\n\t \n\tdata->has_features |= HAS_FAN(0) | HAS_FAN(1) | HAS_PWM(0) | HAS_PWM(1);\n\n\t \n\tswitch (data->type) {\n\tcase dme1737:\n\t\tdata->has_features |= HAS_TEMP_OFFSET | HAS_VID | HAS_ZONE3 |\n\t\t\tHAS_ZONE_HYST | HAS_PWM_MIN;\n\t\tbreak;\n\tcase sch311x:\n\t\tdata->has_features |= HAS_TEMP_OFFSET | HAS_ZONE3 |\n\t\t\tHAS_ZONE_HYST | HAS_PWM_MIN | HAS_FAN(2) | HAS_PWM(2);\n\t\tbreak;\n\tcase sch5027:\n\t\tdata->has_features |= HAS_ZONE3;\n\t\tbreak;\n\tcase sch5127:\n\t\tdata->has_features |= HAS_FAN(2) | HAS_PWM(2) | HAS_IN7;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_info(dev,\n\t\t \"Optional features: pwm3=%s, pwm5=%s, pwm6=%s, fan3=%s, fan4=%s, fan5=%s, fan6=%s.\\n\",\n\t\t (data->has_features & HAS_PWM(2)) ? \"yes\" : \"no\",\n\t\t (data->has_features & HAS_PWM(4)) ? \"yes\" : \"no\",\n\t\t (data->has_features & HAS_PWM(5)) ? \"yes\" : \"no\",\n\t\t (data->has_features & HAS_FAN(2)) ? \"yes\" : \"no\",\n\t\t (data->has_features & HAS_FAN(3)) ? \"yes\" : \"no\",\n\t\t (data->has_features & HAS_FAN(4)) ? \"yes\" : \"no\",\n\t\t (data->has_features & HAS_FAN(5)) ? \"yes\" : \"no\");\n\n\treg = dme1737_read(data, DME1737_REG_TACH_PWM);\n\t \n\tif (client && reg != 0xa4) {    \n\t\tdev_warn(dev,\n\t\t\t \"Non-standard fan to pwm mapping: fan1->pwm%d, fan2->pwm%d, fan3->pwm%d, fan4->pwm%d. %s\\n\",\n\t\t\t (reg & 0x03) + 1, ((reg >> 2) & 0x03) + 1,\n\t\t\t ((reg >> 4) & 0x03) + 1, ((reg >> 6) & 0x03) + 1,\n\t\t\t DO_REPORT);\n\t} else if (!client && reg != 0x24) {    \n\t\tdev_warn(dev,\n\t\t\t \"Non-standard fan to pwm mapping: fan1->pwm%d, fan2->pwm%d, fan3->pwm%d. %s\\n\",\n\t\t\t (reg & 0x03) + 1, ((reg >> 2) & 0x03) + 1,\n\t\t\t ((reg >> 4) & 0x03) + 1, DO_REPORT);\n\t}\n\n\t \n\tif (!(data->config & 0x02)) {\n\t\tfor (ix = 0; ix < 3; ix++) {\n\t\t\tdata->pwm_config[ix] = dme1737_read(data,\n\t\t\t\t\t\tDME1737_REG_PWM_CONFIG(ix));\n\t\t\tif ((data->has_features & HAS_PWM(ix)) &&\n\t\t\t    (PWM_EN_FROM_REG(data->pwm_config[ix]) == -1)) {\n\t\t\t\tdev_info(dev,\n\t\t\t\t\t \"Switching pwm%d to manual mode.\\n\",\n\t\t\t\t\t ix + 1);\n\t\t\t\tdata->pwm_config[ix] = PWM_EN_TO_REG(1,\n\t\t\t\t\t\t\tdata->pwm_config[ix]);\n\t\t\t\tdme1737_write(data, DME1737_REG_PWM(ix), 0);\n\t\t\t\tdme1737_write(data,\n\t\t\t\t\t      DME1737_REG_PWM_CONFIG(ix),\n\t\t\t\t\t      data->pwm_config[ix]);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tdata->pwm_acz[0] = 1;\t \n\tdata->pwm_acz[1] = 2;\t \n\tdata->pwm_acz[2] = 4;\t \n\n\t \n\tif (data->has_features & HAS_VID)\n\t\tdata->vrm = vid_which_vrm();\n\n\treturn 0;\n}\n\n \n\nstatic struct i2c_driver dme1737_i2c_driver;\n\nstatic int dme1737_i2c_get_features(int sio_cip, struct dme1737_data *data)\n{\n\tint err = 0, reg;\n\tu16 addr;\n\n\tdme1737_sio_enter(sio_cip);\n\n\t \n\treg = force_id ? force_id : dme1737_sio_inb(sio_cip, 0x20);\n\tif (!(reg == DME1737_ID_1 || reg == DME1737_ID_2 ||\n\t      reg == SCH5027_ID)) {\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\tdme1737_sio_outb(sio_cip, 0x07, 0x0a);\n\n\t \n\taddr = (dme1737_sio_inb(sio_cip, 0x60) << 8) |\n\t\tdme1737_sio_inb(sio_cip, 0x61);\n\tif (!addr) {\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\tif ((inb(addr + 0x43) & 0x0c) == 0x08)  \n\t\tdata->has_features |= HAS_FAN(5);\n\tif ((inb(addr + 0x44) & 0x0c) == 0x08)  \n\t\tdata->has_features |= HAS_PWM(5);\n\tif ((inb(addr + 0x45) & 0x0c) == 0x08)  \n\t\tdata->has_features |= HAS_FAN(4);\n\tif ((inb(addr + 0x46) & 0x0c) == 0x08)  \n\t\tdata->has_features |= HAS_PWM(4);\n\nexit:\n\tdme1737_sio_exit(sio_cip);\n\n\treturn err;\n}\n\n \nstatic int dme1737_i2c_detect(struct i2c_client *client,\n\t\t\t      struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &adapter->dev;\n\tu8 company, verstep = 0;\n\tconst char *name;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tcompany = i2c_smbus_read_byte_data(client, DME1737_REG_COMPANY);\n\tverstep = i2c_smbus_read_byte_data(client, DME1737_REG_VERSTEP);\n\n\tif (company == DME1737_COMPANY_SMSC &&\n\t    verstep == SCH5027_VERSTEP) {\n\t\tname = \"sch5027\";\n\t} else if (company == DME1737_COMPANY_SMSC &&\n\t\t   (verstep & DME1737_VERSTEP_MASK) == DME1737_VERSTEP) {\n\t\tname = \"dme1737\";\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(dev, \"Found a %s chip at 0x%02x (rev 0x%02x).\\n\",\n\t\t verstep == SCH5027_VERSTEP ? \"SCH5027\" : \"DME1737\",\n\t\t client->addr, verstep);\n\tstrscpy(info->type, name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id dme1737_id[];\n\nstatic int dme1737_i2c_probe(struct i2c_client *client)\n{\n\tstruct dme1737_data *data;\n\tstruct device *dev = &client->dev;\n\tint err;\n\n\tdata = devm_kzalloc(dev, sizeof(struct dme1737_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tdata->type = i2c_match_id(dme1737_id, client)->driver_data;\n\tdata->client = client;\n\tdata->name = client->name;\n\tmutex_init(&data->update_lock);\n\n\t \n\terr = dme1737_init_device(dev);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to initialize device.\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = dme1737_create_files(dev);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to create sysfs files.\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tdata->hwmon_dev = hwmon_device_register(dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\tdev_err(dev, \"Failed to register device.\\n\");\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto exit_remove;\n\t}\n\n\treturn 0;\n\nexit_remove:\n\tdme1737_remove_files(dev);\n\treturn err;\n}\n\nstatic void dme1737_i2c_remove(struct i2c_client *client)\n{\n\tstruct dme1737_data *data = i2c_get_clientdata(client);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tdme1737_remove_files(&client->dev);\n}\n\nstatic const struct i2c_device_id dme1737_id[] = {\n\t{ \"dme1737\", dme1737 },\n\t{ \"sch5027\", sch5027 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, dme1737_id);\n\nstatic struct i2c_driver dme1737_i2c_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"dme1737\",\n\t},\n\t.probe = dme1737_i2c_probe,\n\t.remove = dme1737_i2c_remove,\n\t.id_table = dme1737_id,\n\t.detect = dme1737_i2c_detect,\n\t.address_list = normal_i2c,\n};\n\n \n\nstatic int __init dme1737_isa_detect(int sio_cip, unsigned short *addr)\n{\n\tint err = 0, reg;\n\tunsigned short base_addr;\n\n\tdme1737_sio_enter(sio_cip);\n\n\t \n\treg = force_id ? force_id : dme1737_sio_inb(sio_cip, 0x20);\n\tif (!(reg == SCH3112_ID || reg == SCH3114_ID || reg == SCH3116_ID ||\n\t      reg == SCH5127_ID)) {\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\tdme1737_sio_outb(sio_cip, 0x07, 0x0a);\n\n\t \n\tbase_addr = (dme1737_sio_inb(sio_cip, 0x60) << 8) |\n\t\t     dme1737_sio_inb(sio_cip, 0x61);\n\tif (!base_addr) {\n\t\tpr_err(\"Base address not set\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\t*addr = base_addr + 0x70;\n\nexit:\n\tdme1737_sio_exit(sio_cip);\n\treturn err;\n}\n\nstatic int __init dme1737_isa_device_add(unsigned short addr)\n{\n\tstruct resource res = {\n\t\t.start\t= addr,\n\t\t.end\t= addr + DME1737_EXTENT - 1,\n\t\t.name\t= \"dme1737\",\n\t\t.flags\t= IORESOURCE_IO,\n\t};\n\tint err;\n\n\terr = acpi_check_resource_conflict(&res);\n\tif (err)\n\t\tgoto exit;\n\n\tpdev = platform_device_alloc(\"dme1737\", addr);\n\tif (!pdev) {\n\t\tpr_err(\"Failed to allocate device\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\terr = platform_device_add_resources(pdev, &res, 1);\n\tif (err) {\n\t\tpr_err(\"Failed to add device resource (err = %d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n\t\tpr_err(\"Failed to add device (err = %d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\treturn 0;\n\nexit_device_put:\n\tplatform_device_put(pdev);\n\tpdev = NULL;\nexit:\n\treturn err;\n}\n\nstatic int dme1737_isa_probe(struct platform_device *pdev)\n{\n\tu8 company, device;\n\tstruct resource *res;\n\tstruct dme1737_data *data;\n\tstruct device *dev = &pdev->dev;\n\tint err;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!devm_request_region(dev, res->start, DME1737_EXTENT, \"dme1737\")) {\n\t\tdev_err(dev, \"Failed to request region 0x%04x-0x%04x.\\n\",\n\t\t\t(unsigned short)res->start,\n\t\t\t(unsigned short)res->start + DME1737_EXTENT - 1);\n\t\treturn -EBUSY;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(struct dme1737_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->addr = res->start;\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tswitch (force_id) {\n\tcase SCH3112_ID:\n\tcase SCH3114_ID:\n\tcase SCH3116_ID:\n\t\tdata->type = sch311x;\n\t\tbreak;\n\tcase SCH5127_ID:\n\t\tdata->type = sch5127;\n\t\tbreak;\n\tdefault:\n\t\tcompany = dme1737_read(data, DME1737_REG_COMPANY);\n\t\tdevice = dme1737_read(data, DME1737_REG_DEVICE);\n\n\t\tif ((company == DME1737_COMPANY_SMSC) &&\n\t\t    (device == SCH311X_DEVICE)) {\n\t\t\tdata->type = sch311x;\n\t\t} else if ((company == DME1737_COMPANY_SMSC) &&\n\t\t\t   (device == SCH5127_DEVICE)) {\n\t\t\tdata->type = sch5127;\n\t\t} else {\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (data->type == sch5127)\n\t\tdata->name = \"sch5127\";\n\telse\n\t\tdata->name = \"sch311x\";\n\n\t \n\tmutex_init(&data->update_lock);\n\n\tdev_info(dev, \"Found a %s chip at 0x%04x\\n\",\n\t\t data->type == sch5127 ? \"SCH5127\" : \"SCH311x\", data->addr);\n\n\t \n\terr = dme1737_init_device(dev);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to initialize device.\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = dme1737_create_files(dev);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to create sysfs files.\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tdata->hwmon_dev = hwmon_device_register(dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\tdev_err(dev, \"Failed to register device.\\n\");\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto exit_remove_files;\n\t}\n\n\treturn 0;\n\nexit_remove_files:\n\tdme1737_remove_files(dev);\n\treturn err;\n}\n\nstatic int dme1737_isa_remove(struct platform_device *pdev)\n{\n\tstruct dme1737_data *data = platform_get_drvdata(pdev);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tdme1737_remove_files(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver dme1737_isa_driver = {\n\t.driver = {\n\t\t.name = \"dme1737\",\n\t},\n\t.probe = dme1737_isa_probe,\n\t.remove = dme1737_isa_remove,\n};\n\n \n\nstatic int __init dme1737_init(void)\n{\n\tint err;\n\tunsigned short addr;\n\n\terr = i2c_add_driver(&dme1737_i2c_driver);\n\tif (err)\n\t\tgoto exit;\n\n\tif (dme1737_isa_detect(0x2e, &addr) &&\n\t    dme1737_isa_detect(0x4e, &addr) &&\n\t    (!probe_all_addr ||\n\t     (dme1737_isa_detect(0x162e, &addr) &&\n\t      dme1737_isa_detect(0x164e, &addr)))) {\n\t\t \n\t\treturn 0;\n\t}\n\n\terr = platform_driver_register(&dme1737_isa_driver);\n\tif (err)\n\t\tgoto exit_del_i2c_driver;\n\n\t \n\terr = dme1737_isa_device_add(addr);\n\tif (err)\n\t\tgoto exit_del_isa_driver;\n\n\treturn 0;\n\nexit_del_isa_driver:\n\tplatform_driver_unregister(&dme1737_isa_driver);\nexit_del_i2c_driver:\n\ti2c_del_driver(&dme1737_i2c_driver);\nexit:\n\treturn err;\n}\n\nstatic void __exit dme1737_exit(void)\n{\n\tif (pdev) {\n\t\tplatform_device_unregister(pdev);\n\t\tplatform_driver_unregister(&dme1737_isa_driver);\n\t}\n\n\ti2c_del_driver(&dme1737_i2c_driver);\n}\n\nMODULE_AUTHOR(\"Juerg Haefliger <juergh@gmail.com>\");\nMODULE_DESCRIPTION(\"DME1737 sensors\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(dme1737_init);\nmodule_exit(dme1737_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}