{
  "module_name": "lineage-pem.c",
  "hash_id": "01e271c70ddf8366a96200e00e67954e94ab83d88ba19f33539f67f5e875766d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lineage-pem.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n\n \n\n \n#define PEM_OPERATION\t\t0x01\n#define PEM_CLEAR_INFO_FLAGS\t0x03\n#define PEM_VOUT_COMMAND\t0x21\n#define PEM_VOUT_OV_FAULT_LIMIT\t0x40\n#define PEM_READ_DATA_STRING\t0xd0\n#define PEM_READ_INPUT_STRING\t0xdc\n#define PEM_READ_FIRMWARE_REV\t0xdd\n#define PEM_READ_RUN_TIMER\t0xde\n#define PEM_FAN_HI_SPEED\t0xdf\n#define PEM_FAN_NORMAL_SPEED\t0xe0\n#define PEM_READ_FAN_SPEED\t0xe1\n\n \n#define PEM_DATA_STATUS_2\t0\n#define PEM_DATA_STATUS_1\t1\n#define PEM_DATA_ALARM_2\t2\n#define PEM_DATA_ALARM_1\t3\n#define PEM_DATA_VOUT_LSB\t4\n#define PEM_DATA_VOUT_MSB\t5\n#define PEM_DATA_CURRENT\t6\n#define PEM_DATA_TEMP\t\t7\n\n \n#define PEM_DATA_TEMP_MAX\t10\n#define PEM_DATA_TEMP_CRIT\t11\n\n \n#define PEM_INPUT_VOLTAGE\t0\n#define PEM_INPUT_POWER_LSB\t1\n#define PEM_INPUT_POWER_MSB\t2\n\n \n#define PEM_FAN_ADJUSTMENT\t0\n#define PEM_FAN_FAN1\t\t1\n#define PEM_FAN_FAN2\t\t2\n#define PEM_FAN_FAN3\t\t3\n\n \n#define STS1_OUTPUT_ON\t\t(1 << 0)\n#define STS1_LEDS_FLASHING\t(1 << 1)\n#define STS1_EXT_FAULT\t\t(1 << 2)\n#define STS1_SERVICE_LED_ON\t(1 << 3)\n#define STS1_SHUTDOWN_OCCURRED\t(1 << 4)\n#define STS1_INT_FAULT\t\t(1 << 5)\n#define STS1_ISOLATION_TEST_OK\t(1 << 6)\n\n#define STS2_ENABLE_PIN_HI\t(1 << 0)\n#define STS2_DATA_OUT_RANGE\t(1 << 1)\n#define STS2_RESTARTED_OK\t(1 << 1)\n#define STS2_ISOLATION_TEST_FAIL (1 << 3)\n#define STS2_HIGH_POWER_CAP\t(1 << 4)\n#define STS2_INVALID_INSTR\t(1 << 5)\n#define STS2_WILL_RESTART\t(1 << 6)\n#define STS2_PEC_ERR\t\t(1 << 7)\n\n \n#define ALRM1_VIN_OUT_LIMIT\t(1 << 0)\n#define ALRM1_VOUT_OUT_LIMIT\t(1 << 1)\n#define ALRM1_OV_VOLT_SHUTDOWN\t(1 << 2)\n#define ALRM1_VIN_OVERCURRENT\t(1 << 3)\n#define ALRM1_TEMP_WARNING\t(1 << 4)\n#define ALRM1_TEMP_SHUTDOWN\t(1 << 5)\n#define ALRM1_PRIMARY_FAULT\t(1 << 6)\n#define ALRM1_POWER_LIMIT\t(1 << 7)\n\n#define ALRM2_5V_OUT_LIMIT\t(1 << 1)\n#define ALRM2_TEMP_FAULT\t(1 << 2)\n#define ALRM2_OV_LOW\t\t(1 << 3)\n#define ALRM2_DCDC_TEMP_HIGH\t(1 << 4)\n#define ALRM2_PRI_TEMP_HIGH\t(1 << 5)\n#define ALRM2_NO_PRIMARY\t(1 << 6)\n#define ALRM2_FAN_FAULT\t\t(1 << 7)\n\n#define FIRMWARE_REV_LEN\t4\n#define DATA_STRING_LEN\t\t9\n#define INPUT_STRING_LEN\t5\t \n#define FAN_SPEED_LEN\t\t5\n\nstruct pem_data {\n\tstruct i2c_client *client;\n\tconst struct attribute_group *groups[4];\n\n\tstruct mutex update_lock;\n\tbool valid;\n\tbool fans_supported;\n\tint input_length;\n\tunsigned long last_updated;\t \n\n\tu8 firmware_rev[FIRMWARE_REV_LEN];\n\tu8 data_string[DATA_STRING_LEN];\n\tu8 input_string[INPUT_STRING_LEN];\n\tu8 fan_speed[FAN_SPEED_LEN];\n};\n\nstatic int pem_read_block(struct i2c_client *client, u8 command, u8 *data,\n\t\t\t  int data_len)\n{\n\tu8 block_buffer[I2C_SMBUS_BLOCK_MAX];\n\tint result;\n\n\tresult = i2c_smbus_read_block_data(client, command, block_buffer);\n\tif (unlikely(result < 0))\n\t\tgoto abort;\n\tif (unlikely(result == 0xff || result != data_len)) {\n\t\tresult = -EIO;\n\t\tgoto abort;\n\t}\n\tmemcpy(data, block_buffer, data_len);\n\tresult = 0;\nabort:\n\treturn result;\n}\n\nstatic struct pem_data *pem_update_device(struct device *dev)\n{\n\tstruct pem_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tstruct pem_data *ret = data;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\n\t\tint result;\n\n\t\t \n\t\tresult = pem_read_block(client, PEM_READ_DATA_STRING,\n\t\t\t\t\tdata->data_string,\n\t\t\t\t\tsizeof(data->data_string));\n\t\tif (unlikely(result < 0)) {\n\t\t\tret = ERR_PTR(result);\n\t\t\tgoto abort;\n\t\t}\n\n\t\t \n\t\tif (data->input_length) {\n\t\t\tresult = pem_read_block(client, PEM_READ_INPUT_STRING,\n\t\t\t\t\t\tdata->input_string,\n\t\t\t\t\t\tdata->input_length);\n\t\t\tif (unlikely(result < 0)) {\n\t\t\t\tret = ERR_PTR(result);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (data->fans_supported) {\n\t\t\tresult = pem_read_block(client, PEM_READ_FAN_SPEED,\n\t\t\t\t\t\tdata->fan_speed,\n\t\t\t\t\t\tsizeof(data->fan_speed));\n\t\t\tif (unlikely(result < 0)) {\n\t\t\t\tret = ERR_PTR(result);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\n\t\ti2c_smbus_write_byte(client, PEM_CLEAR_INFO_FLAGS);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\nabort:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic long pem_get_data(u8 *data, int len, int index)\n{\n\tlong val;\n\n\tswitch (index) {\n\tcase PEM_DATA_VOUT_LSB:\n\t\tval = (data[index] + (data[index+1] << 8)) * 5 / 2;\n\t\tbreak;\n\tcase PEM_DATA_CURRENT:\n\t\tval = data[index] * 200;\n\t\tbreak;\n\tcase PEM_DATA_TEMP:\n\t\tval = data[index] * 1000;\n\t\tbreak;\n\tcase PEM_DATA_TEMP_MAX:\n\t\tval = 97 * 1000;\t \n\t\tbreak;\n\tcase PEM_DATA_TEMP_CRIT:\n\t\tval = 107 * 1000;\t \n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tval = 0;\n\t}\n\treturn val;\n}\n\nstatic long pem_get_input(u8 *data, int len, int index)\n{\n\tlong val;\n\n\tswitch (index) {\n\tcase PEM_INPUT_VOLTAGE:\n\t\tif (len == INPUT_STRING_LEN)\n\t\t\tval = (data[index] + (data[index+1] << 8) - 75) * 1000;\n\t\telse\n\t\t\tval = (data[index] - 75) * 1000;\n\t\tbreak;\n\tcase PEM_INPUT_POWER_LSB:\n\t\tif (len == INPUT_STRING_LEN)\n\t\t\tindex++;\n\t\tval = (data[index] + (data[index+1] << 8)) * 1000000L;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tval = 0;\n\t}\n\treturn val;\n}\n\nstatic long pem_get_fan(u8 *data, int len, int index)\n{\n\tlong val;\n\n\tswitch (index) {\n\tcase PEM_FAN_FAN1:\n\tcase PEM_FAN_FAN2:\n\tcase PEM_FAN_FAN3:\n\t\tval = data[index] * 100;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tval = 0;\n\t}\n\treturn val;\n}\n\n \nstatic ssize_t pem_bool_show(struct device *dev, struct device_attribute *da,\n\t\t\t     char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(da);\n\tstruct pem_data *data = pem_update_device(dev);\n\tu8 status;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tstatus = data->data_string[attr->nr] & attr->index;\n\treturn sysfs_emit(buf, \"%d\\n\", !!status);\n}\n\nstatic ssize_t pem_data_show(struct device *dev, struct device_attribute *da,\n\t\t\t     char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct pem_data *data = pem_update_device(dev);\n\tlong value;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tvalue = pem_get_data(data->data_string, sizeof(data->data_string),\n\t\t\t     attr->index);\n\n\treturn sysfs_emit(buf, \"%ld\\n\", value);\n}\n\nstatic ssize_t pem_input_show(struct device *dev, struct device_attribute *da,\n\t\t\t      char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct pem_data *data = pem_update_device(dev);\n\tlong value;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tvalue = pem_get_input(data->input_string, sizeof(data->input_string),\n\t\t\t      attr->index);\n\n\treturn sysfs_emit(buf, \"%ld\\n\", value);\n}\n\nstatic ssize_t pem_fan_show(struct device *dev, struct device_attribute *da,\n\t\t\t    char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct pem_data *data = pem_update_device(dev);\n\tlong value;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tvalue = pem_get_fan(data->fan_speed, sizeof(data->fan_speed),\n\t\t\t    attr->index);\n\n\treturn sysfs_emit(buf, \"%ld\\n\", value);\n}\n\n \nstatic SENSOR_DEVICE_ATTR_RO(in1_input, pem_data, PEM_DATA_VOUT_LSB);\nstatic SENSOR_DEVICE_ATTR_2_RO(in1_alarm, pem_bool, PEM_DATA_ALARM_1,\n\t\t\t       ALRM1_VOUT_OUT_LIMIT);\nstatic SENSOR_DEVICE_ATTR_2_RO(in1_crit_alarm, pem_bool, PEM_DATA_ALARM_1,\n\t\t\t       ALRM1_OV_VOLT_SHUTDOWN);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, pem_input, PEM_INPUT_VOLTAGE);\nstatic SENSOR_DEVICE_ATTR_2_RO(in2_alarm, pem_bool, PEM_DATA_ALARM_1,\n\t\t\t       ALRM1_VIN_OUT_LIMIT | ALRM1_PRIMARY_FAULT);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(curr1_input, pem_data, PEM_DATA_CURRENT);\nstatic SENSOR_DEVICE_ATTR_2_RO(curr1_alarm, pem_bool, PEM_DATA_ALARM_1,\n\t\t\t       ALRM1_VIN_OVERCURRENT);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(power1_input, pem_input, PEM_INPUT_POWER_LSB);\nstatic SENSOR_DEVICE_ATTR_2_RO(power1_alarm, pem_bool, PEM_DATA_ALARM_1,\n\t\t\t       ALRM1_POWER_LIMIT);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, pem_fan, PEM_FAN_FAN1);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, pem_fan, PEM_FAN_FAN2);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_input, pem_fan, PEM_FAN_FAN3);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan1_alarm, pem_bool, PEM_DATA_ALARM_2,\n\t\t\t       ALRM2_FAN_FAULT);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, pem_data, PEM_DATA_TEMP);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max, pem_data, PEM_DATA_TEMP_MAX);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_crit, pem_data, PEM_DATA_TEMP_CRIT);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_alarm, pem_bool, PEM_DATA_ALARM_1,\n\t\t\t       ALRM1_TEMP_WARNING);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_crit_alarm, pem_bool, PEM_DATA_ALARM_1,\n\t\t\t       ALRM1_TEMP_SHUTDOWN);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_fault, pem_bool, PEM_DATA_ALARM_2,\n\t\t\t       ALRM2_TEMP_FAULT);\n\nstatic struct attribute *pem_attributes[] = {\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_curr1_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_power1_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_fault.dev_attr.attr,\n\n\tNULL,\n};\n\nstatic const struct attribute_group pem_group = {\n\t.attrs = pem_attributes,\n};\n\nstatic struct attribute *pem_input_attributes[] = {\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_curr1_input.dev_attr.attr,\n\t&sensor_dev_attr_power1_input.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group pem_input_group = {\n\t.attrs = pem_input_attributes,\n};\n\nstatic struct attribute *pem_fan_attributes[] = {\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group pem_fan_group = {\n\t.attrs = pem_fan_attributes,\n};\n\nstatic int pem_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct pem_data *data;\n\tint ret, idx = 0;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BLOCK_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_WRITE_BYTE))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tret = pem_read_block(client, PEM_READ_FIRMWARE_REV,\n\t\t\t     data->firmware_rev, sizeof(data->firmware_rev));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte(client, PEM_CLEAR_INFO_FLAGS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(dev, \"Firmware revision %d.%d.%d\\n\",\n\t\t data->firmware_rev[0], data->firmware_rev[1],\n\t\t data->firmware_rev[2]);\n\n\t \n\tdata->groups[idx++] = &pem_group;\n\n\t \n\tret = pem_read_block(client, PEM_READ_INPUT_STRING,\n\t\t\t     data->input_string,\n\t\t\t     sizeof(data->input_string) - 1);\n\tif (!ret && (data->input_string[0] || data->input_string[1] ||\n\t\t     data->input_string[2]))\n\t\tdata->input_length = sizeof(data->input_string) - 1;\n\telse if (ret < 0) {\n\t\t \n\t\tret = pem_read_block(client, PEM_READ_INPUT_STRING,\n\t\t\t\t    data->input_string,\n\t\t\t\t    sizeof(data->input_string));\n\t\tif (!ret && (data->input_string[0] || data->input_string[1] ||\n\t\t\t    data->input_string[2] || data->input_string[3]))\n\t\t\tdata->input_length = sizeof(data->input_string);\n\t}\n\n\tif (data->input_length)\n\t\tdata->groups[idx++] = &pem_input_group;\n\n\t \n\tret = pem_read_block(client, PEM_READ_FAN_SPEED,\n\t\t\t     data->fan_speed,\n\t\t\t     sizeof(data->fan_speed));\n\tif (!ret && (data->fan_speed[0] || data->fan_speed[1] ||\n\t\t     data->fan_speed[2] || data->fan_speed[3])) {\n\t\tdata->fans_supported = true;\n\t\tdata->groups[idx++] = &pem_fan_group;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, data->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id pem_id[] = {\n\t{\"lineage_pem\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, pem_id);\n\nstatic struct i2c_driver pem_driver = {\n\t.driver = {\n\t\t   .name = \"lineage_pem\",\n\t\t   },\n\t.probe = pem_probe,\n\t.id_table = pem_id,\n};\n\nmodule_i2c_driver(pem_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"Lineage CPL PEM hardware monitoring driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}