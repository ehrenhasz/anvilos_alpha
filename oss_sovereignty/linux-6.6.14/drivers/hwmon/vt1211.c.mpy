{
  "module_name": "vt1211.c",
  "hash_id": "1001372b5b273214e19ae74ef9f46a0cda981212f08e734cbe1c856dbc6c6cce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/vt1211.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon-vid.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/ioport.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\nstatic int uch_config = -1;\nmodule_param(uch_config, int, 0);\nMODULE_PARM_DESC(uch_config, \"Initialize the universal channel configuration\");\n\nstatic int int_mode = -1;\nmodule_param(int_mode, int, 0);\nMODULE_PARM_DESC(int_mode, \"Force the temperature interrupt mode\");\n\nstatic unsigned short force_id;\nmodule_param(force_id, ushort, 0);\nMODULE_PARM_DESC(force_id, \"Override the detected device ID\");\n\nstatic struct platform_device *pdev;\n\n#define DRVNAME \"vt1211\"\n\n \n\n \n#define VT1211_REG_IN(ix)\t\t(0x21 + (ix))\n#define VT1211_REG_IN_MIN(ix)\t\t((ix) == 0 ? 0x3e : 0x2a + 2 * (ix))\n#define VT1211_REG_IN_MAX(ix)\t\t((ix) == 0 ? 0x3d : 0x29 + 2 * (ix))\n\n \nstatic u8 regtemp[]\t= {0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25};\nstatic u8 regtempmax[]\t= {0x39, 0x1d, 0x3d, 0x2b, 0x2d, 0x2f, 0x31};\nstatic u8 regtemphyst[]\t= {0x3a, 0x1e, 0x3e, 0x2c, 0x2e, 0x30, 0x32};\n\n \n#define VT1211_REG_FAN(ix)\t\t(0x29 + (ix))\n#define VT1211_REG_FAN_MIN(ix)\t\t(0x3b + (ix))\n#define VT1211_REG_FAN_DIV\t\t 0x47\n\n \n \n#define VT1211_REG_PWM(ix)\t\t(0x60 + (ix))\n#define VT1211_REG_PWM_CLK\t\t 0x50\n#define VT1211_REG_PWM_CTL\t\t 0x51\n#define VT1211_REG_PWM_AUTO_TEMP(ap)\t(0x55 - (ap))\n#define VT1211_REG_PWM_AUTO_PWM(ix, ap)\t(0x58 + 2 * (ix) - (ap))\n\n \n#define VT1211_REG_CONFIG\t\t0x40\n#define VT1211_REG_ALARM1\t\t0x41\n#define VT1211_REG_ALARM2\t\t0x42\n#define VT1211_REG_VID\t\t\t0x45\n#define VT1211_REG_UCH_CONFIG\t\t0x4a\n#define VT1211_REG_TEMP1_CONFIG\t\t0x4b\n#define VT1211_REG_TEMP2_CONFIG\t\t0x4c\n\n \nstatic const u8 bitalarmin[]\t= {11, 0, 1, 3, 8, 2, 9};\nstatic const u8 bitalarmtemp[]\t= {4, 15, 11, 0, 1, 3, 8};\nstatic const u8 bitalarmfan[]\t= {6, 7};\n\n \n\nstruct vt1211_data {\n\tunsigned short addr;\n\tconst char *name;\n\tstruct device *hwmon_dev;\n\n\tstruct mutex update_lock;\n\tbool valid;\t\t\t \n\tunsigned long last_updated;\t \n\n\t \n\tu8  in[6];\n\tu8  in_max[6];\n\tu8  in_min[6];\n\tu8  temp[7];\n\tu8  temp_max[7];\n\tu8  temp_hyst[7];\n\tu8  fan[2];\n\tu8  fan_min[2];\n\tu8  fan_div[2];\n\tu8  fan_ctl;\n\tu8  pwm[2];\n\tu8  pwm_ctl[2];\n\tu8  pwm_clk;\n\tu8  pwm_auto_temp[4];\n\tu8  pwm_auto_pwm[2][4];\n\tu8  vid;\t\t \n\tu8  vrm;\n\tu8  uch_config;\t\t \n\tu16 alarms;\n};\n\n \n#define ISVOLT(ix, uch_config)\t((ix) > 4 ? 1 : \\\n\t\t\t\t !(((uch_config) >> ((ix) + 2)) & 1))\n\n \n#define ISTEMP(ix, uch_config)\t((ix) < 2 ? 1 : \\\n\t\t\t\t ((uch_config) >> (ix)) & 1)\n\n \n#define IN_FROM_REG(ix, reg)\t((reg) < 3 ? 0 : (ix) == 5 ? \\\n\t\t\t\t (((reg) - 3) * 15882 + 479) / 958 : \\\n\t\t\t\t (((reg) - 3) * 10000 + 479) / 958)\n#define IN_TO_REG(ix, val)\t(clamp_val((ix) == 5 ? \\\n\t\t\t\t ((val) * 958 + 7941) / 15882 + 3 : \\\n\t\t\t\t ((val) * 958 + 5000) / 10000 + 3, 0, 255))\n\n \n#define TEMP_FROM_REG(ix, reg)\t((ix) == 0 ? (reg) * 1000 : \\\n\t\t\t\t (ix) == 1 ? (reg) < 51 ? 0 : \\\n\t\t\t\t ((reg) - 51) * 1000 : \\\n\t\t\t\t ((253 - (reg)) * 2200 + 105) / 210)\n#define TEMP_TO_REG(ix, val)\tclamp_val( \\\n\t\t\t\t ((ix) == 0 ? ((val) + 500) / 1000 : \\\n\t\t\t\t  (ix) == 1 ? ((val) + 500) / 1000 + 51 : \\\n\t\t\t\t  253 - ((val) * 210 + 1100) / 2200), 0, 255)\n\n#define DIV_FROM_REG(reg)\t(1 << (reg))\n\n#define RPM_FROM_REG(reg, div)\t(((reg) == 0) || ((reg) == 255) ? 0 : \\\n\t\t\t\t 1310720 / (reg) / DIV_FROM_REG(div))\n#define RPM_TO_REG(val, div)\t((val) == 0 ? 255 : \\\n\t\t\t\t clamp_val((1310720 / (val) / \\\n\t\t\t\t DIV_FROM_REG(div)), 1, 254))\n\n \n\n \n#define SIO_REG_CIP1\t\t0x2e\n#define SIO_REG_CIP2\t\t0x4e\n\n \n#define SIO_VT1211_LDN\t\t0x07\t \n#define SIO_VT1211_DEVID\t0x20\t \n#define SIO_VT1211_DEVREV\t0x21\t \n#define SIO_VT1211_ACTIVE\t0x30\t \n#define SIO_VT1211_BADDR\t0x60\t \n#define SIO_VT1211_ID\t\t0x3c\t \n\n \n#define SIO_VT1211_LDN_HWMON\t0x0b\t \n\nstatic inline int superio_inb(int sio_cip, int reg)\n{\n\toutb(reg, sio_cip);\n\treturn inb(sio_cip + 1);\n}\n\nstatic inline void superio_select(int sio_cip, int ldn)\n{\n\toutb(SIO_VT1211_LDN, sio_cip);\n\toutb(ldn, sio_cip + 1);\n}\n\nstatic inline int superio_enter(int sio_cip)\n{\n\tif (!request_muxed_region(sio_cip, 2, DRVNAME))\n\t\treturn -EBUSY;\n\n\toutb(0x87, sio_cip);\n\toutb(0x87, sio_cip);\n\n\treturn 0;\n}\n\nstatic inline void superio_exit(int sio_cip)\n{\n\toutb(0xaa, sio_cip);\n\trelease_region(sio_cip, 2);\n}\n\n \n\nstatic inline u8 vt1211_read8(struct vt1211_data *data, u8 reg)\n{\n\treturn inb(data->addr + reg);\n}\n\nstatic inline void vt1211_write8(struct vt1211_data *data, u8 reg, u8 val)\n{\n\toutb(val, data->addr + reg);\n}\n\nstatic struct vt1211_data *vt1211_update_device(struct device *dev)\n{\n\tstruct vt1211_data *data = dev_get_drvdata(dev);\n\tint ix, val;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\n\t\t \n\t\tdata->vid = vt1211_read8(data, VT1211_REG_VID) & 0x1f;\n\n\t\t \n\t\tfor (ix = 0; ix < ARRAY_SIZE(data->in); ix++) {\n\t\t\tif (ISVOLT(ix, data->uch_config)) {\n\t\t\t\tdata->in[ix] = vt1211_read8(data,\n\t\t\t\t\t\tVT1211_REG_IN(ix));\n\t\t\t\tdata->in_min[ix] = vt1211_read8(data,\n\t\t\t\t\t\tVT1211_REG_IN_MIN(ix));\n\t\t\t\tdata->in_max[ix] = vt1211_read8(data,\n\t\t\t\t\t\tVT1211_REG_IN_MAX(ix));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (ix = 0; ix < ARRAY_SIZE(data->temp); ix++) {\n\t\t\tif (ISTEMP(ix, data->uch_config)) {\n\t\t\t\tdata->temp[ix] = vt1211_read8(data,\n\t\t\t\t\t\tregtemp[ix]);\n\t\t\t\tdata->temp_max[ix] = vt1211_read8(data,\n\t\t\t\t\t\tregtempmax[ix]);\n\t\t\t\tdata->temp_hyst[ix] = vt1211_read8(data,\n\t\t\t\t\t\tregtemphyst[ix]);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (ix = 0; ix < ARRAY_SIZE(data->fan); ix++) {\n\t\t\tdata->fan[ix] = vt1211_read8(data,\n\t\t\t\t\t\tVT1211_REG_FAN(ix));\n\t\t\tdata->fan_min[ix] = vt1211_read8(data,\n\t\t\t\t\t\tVT1211_REG_FAN_MIN(ix));\n\t\t\tdata->pwm[ix] = vt1211_read8(data,\n\t\t\t\t\t\tVT1211_REG_PWM(ix));\n\t\t}\n\t\tval = vt1211_read8(data, VT1211_REG_FAN_DIV);\n\t\tdata->fan_div[0] = (val >> 4) & 3;\n\t\tdata->fan_div[1] = (val >> 6) & 3;\n\t\tdata->fan_ctl = val & 0xf;\n\n\t\tval = vt1211_read8(data, VT1211_REG_PWM_CTL);\n\t\tdata->pwm_ctl[0] = val & 0xf;\n\t\tdata->pwm_ctl[1] = (val >> 4) & 0xf;\n\n\t\tdata->pwm_clk = vt1211_read8(data, VT1211_REG_PWM_CLK);\n\n\t\t \n\t\tdata->pwm_auto_pwm[0][1] = vt1211_read8(data,\n\t\t\t\t\t\tVT1211_REG_PWM_AUTO_PWM(0, 1));\n\t\tdata->pwm_auto_pwm[0][2] = vt1211_read8(data,\n\t\t\t\t\t\tVT1211_REG_PWM_AUTO_PWM(0, 2));\n\t\tdata->pwm_auto_pwm[1][1] = vt1211_read8(data,\n\t\t\t\t\t\tVT1211_REG_PWM_AUTO_PWM(1, 1));\n\t\tdata->pwm_auto_pwm[1][2] = vt1211_read8(data,\n\t\t\t\t\t\tVT1211_REG_PWM_AUTO_PWM(1, 2));\n\t\tfor (ix = 0; ix < ARRAY_SIZE(data->pwm_auto_temp); ix++) {\n\t\t\tdata->pwm_auto_temp[ix] = vt1211_read8(data,\n\t\t\t\t\t\tVT1211_REG_PWM_AUTO_TEMP(ix));\n\t\t}\n\n\t\t \n\t\tdata->alarms = (vt1211_read8(data, VT1211_REG_ALARM2) << 8) |\n\t\t\t\tvt1211_read8(data, VT1211_REG_ALARM1);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \n\n#define SHOW_IN_INPUT\t0\n#define SHOW_SET_IN_MIN\t1\n#define SHOW_SET_IN_MAX\t2\n#define SHOW_IN_ALARM\t3\n\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct vt1211_data *data = vt1211_update_device(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr_2 =\n\t\t\t\t\t\tto_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tint res;\n\n\tswitch (fn) {\n\tcase SHOW_IN_INPUT:\n\t\tres = IN_FROM_REG(ix, data->in[ix]);\n\t\tbreak;\n\tcase SHOW_SET_IN_MIN:\n\t\tres = IN_FROM_REG(ix, data->in_min[ix]);\n\t\tbreak;\n\tcase SHOW_SET_IN_MAX:\n\t\tres = IN_FROM_REG(ix, data->in_max[ix]);\n\t\tbreak;\n\tcase SHOW_IN_ALARM:\n\t\tres = (data->alarms >> bitalarmin[ix]) & 1;\n\t\tbreak;\n\tdefault:\n\t\tres = 0;\n\t\tdev_dbg(dev, \"Unknown attr fetch (%d)\\n\", fn);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", res);\n}\n\nstatic ssize_t set_in(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct vt1211_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr_2 =\n\t\t\t\t\t\tto_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (fn) {\n\tcase SHOW_SET_IN_MIN:\n\t\tdata->in_min[ix] = IN_TO_REG(ix, val);\n\t\tvt1211_write8(data, VT1211_REG_IN_MIN(ix), data->in_min[ix]);\n\t\tbreak;\n\tcase SHOW_SET_IN_MAX:\n\t\tdata->in_max[ix] = IN_TO_REG(ix, val);\n\t\tvt1211_write8(data, VT1211_REG_IN_MAX(ix), data->in_max[ix]);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown attr fetch (%d)\\n\", fn);\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\n#define SHOW_TEMP_INPUT\t\t0\n#define SHOW_SET_TEMP_MAX\t1\n#define SHOW_SET_TEMP_MAX_HYST\t2\n#define SHOW_TEMP_ALARM\t\t3\n\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct vt1211_data *data = vt1211_update_device(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr_2 =\n\t\t\t\t\t\tto_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tint res;\n\n\tswitch (fn) {\n\tcase SHOW_TEMP_INPUT:\n\t\tres = TEMP_FROM_REG(ix, data->temp[ix]);\n\t\tbreak;\n\tcase SHOW_SET_TEMP_MAX:\n\t\tres = TEMP_FROM_REG(ix, data->temp_max[ix]);\n\t\tbreak;\n\tcase SHOW_SET_TEMP_MAX_HYST:\n\t\tres = TEMP_FROM_REG(ix, data->temp_hyst[ix]);\n\t\tbreak;\n\tcase SHOW_TEMP_ALARM:\n\t\tres = (data->alarms >> bitalarmtemp[ix]) & 1;\n\t\tbreak;\n\tdefault:\n\t\tres = 0;\n\t\tdev_dbg(dev, \"Unknown attr fetch (%d)\\n\", fn);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", res);\n}\n\nstatic ssize_t set_temp(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct vt1211_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr_2 =\n\t\t\t\t\t\tto_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (fn) {\n\tcase SHOW_SET_TEMP_MAX:\n\t\tdata->temp_max[ix] = TEMP_TO_REG(ix, val);\n\t\tvt1211_write8(data, regtempmax[ix],\n\t\t\t      data->temp_max[ix]);\n\t\tbreak;\n\tcase SHOW_SET_TEMP_MAX_HYST:\n\t\tdata->temp_hyst[ix] = TEMP_TO_REG(ix, val);\n\t\tvt1211_write8(data, regtemphyst[ix],\n\t\t\t      data->temp_hyst[ix]);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown attr fetch (%d)\\n\", fn);\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\n#define SHOW_FAN_INPUT\t\t0\n#define SHOW_SET_FAN_MIN\t1\n#define SHOW_SET_FAN_DIV\t2\n#define SHOW_FAN_ALARM\t\t3\n\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct vt1211_data *data = vt1211_update_device(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr_2 =\n\t\t\t\t\t\tto_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tint res;\n\n\tswitch (fn) {\n\tcase SHOW_FAN_INPUT:\n\t\tres = RPM_FROM_REG(data->fan[ix], data->fan_div[ix]);\n\t\tbreak;\n\tcase SHOW_SET_FAN_MIN:\n\t\tres = RPM_FROM_REG(data->fan_min[ix], data->fan_div[ix]);\n\t\tbreak;\n\tcase SHOW_SET_FAN_DIV:\n\t\tres = DIV_FROM_REG(data->fan_div[ix]);\n\t\tbreak;\n\tcase SHOW_FAN_ALARM:\n\t\tres = (data->alarms >> bitalarmfan[ix]) & 1;\n\t\tbreak;\n\tdefault:\n\t\tres = 0;\n\t\tdev_dbg(dev, \"Unknown attr fetch (%d)\\n\", fn);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", res);\n}\n\nstatic ssize_t set_fan(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct vt1211_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr_2 =\n\t\t\t\t\t\tto_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tint reg;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\treg = vt1211_read8(data, VT1211_REG_FAN_DIV);\n\tdata->fan_div[0] = (reg >> 4) & 3;\n\tdata->fan_div[1] = (reg >> 6) & 3;\n\tdata->fan_ctl = reg & 0xf;\n\n\tswitch (fn) {\n\tcase SHOW_SET_FAN_MIN:\n\t\tdata->fan_min[ix] = RPM_TO_REG(val, data->fan_div[ix]);\n\t\tvt1211_write8(data, VT1211_REG_FAN_MIN(ix),\n\t\t\t      data->fan_min[ix]);\n\t\tbreak;\n\tcase SHOW_SET_FAN_DIV:\n\t\tswitch (val) {\n\t\tcase 1:\n\t\t\tdata->fan_div[ix] = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata->fan_div[ix] = 1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdata->fan_div[ix] = 2;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tdata->fan_div[ix] = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcount = -EINVAL;\n\t\t\tdev_warn(dev,\n\t\t\t\t \"fan div value %ld not supported. Choose one of 1, 2, 4, or 8.\\n\",\n\t\t\t\t val);\n\t\t\tgoto EXIT;\n\t\t}\n\t\tvt1211_write8(data, VT1211_REG_FAN_DIV,\n\t\t\t      ((data->fan_div[1] << 6) |\n\t\t\t       (data->fan_div[0] << 4) |\n\t\t\t\tdata->fan_ctl));\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown attr fetch (%d)\\n\", fn);\n\t}\n\nEXIT:\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \n\n#define SHOW_PWM\t\t\t0\n#define SHOW_SET_PWM_ENABLE\t\t1\n#define SHOW_SET_PWM_FREQ\t\t2\n#define SHOW_SET_PWM_AUTO_CHANNELS_TEMP\t3\n\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct vt1211_data *data = vt1211_update_device(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr_2 =\n\t\t\t\t\t\tto_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tint res;\n\n\tswitch (fn) {\n\tcase SHOW_PWM:\n\t\tres = data->pwm[ix];\n\t\tbreak;\n\tcase SHOW_SET_PWM_ENABLE:\n\t\tres = ((data->pwm_ctl[ix] >> 3) & 1) ? 2 : 0;\n\t\tbreak;\n\tcase SHOW_SET_PWM_FREQ:\n\t\tres = 90000 >> (data->pwm_clk & 7);\n\t\tbreak;\n\tcase SHOW_SET_PWM_AUTO_CHANNELS_TEMP:\n\t\tres = (data->pwm_ctl[ix] & 7) + 1;\n\t\tbreak;\n\tdefault:\n\t\tres = 0;\n\t\tdev_dbg(dev, \"Unknown attr fetch (%d)\\n\", fn);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", res);\n}\n\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct vt1211_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr_2 =\n\t\t\t\t\t\tto_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint fn = sensor_attr_2->nr;\n\tint tmp, reg;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (fn) {\n\tcase SHOW_SET_PWM_ENABLE:\n\t\t \n\t\treg = vt1211_read8(data, VT1211_REG_FAN_DIV);\n\t\tdata->fan_div[0] = (reg >> 4) & 3;\n\t\tdata->fan_div[1] = (reg >> 6) & 3;\n\t\tdata->fan_ctl = reg & 0xf;\n\t\treg = vt1211_read8(data, VT1211_REG_PWM_CTL);\n\t\tdata->pwm_ctl[0] = reg & 0xf;\n\t\tdata->pwm_ctl[1] = (reg >> 4) & 0xf;\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\tdata->pwm_ctl[ix] &= 7;\n\t\t\t \n\t\t\tif ((data->pwm_ctl[ix ^ 1] & 1) == 0)\n\t\t\t\tdata->fan_ctl &= 0xe;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata->pwm_ctl[ix] |= 8;\n\t\t\tdata->fan_ctl |= 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcount = -EINVAL;\n\t\t\tdev_warn(dev,\n\t\t\t\t \"pwm mode %ld not supported. Choose one of 0 or 2.\\n\",\n\t\t\t\t val);\n\t\t\tgoto EXIT;\n\t\t}\n\t\tvt1211_write8(data, VT1211_REG_PWM_CTL,\n\t\t\t      ((data->pwm_ctl[1] << 4) |\n\t\t\t\tdata->pwm_ctl[0]));\n\t\tvt1211_write8(data, VT1211_REG_FAN_DIV,\n\t\t\t      ((data->fan_div[1] << 6) |\n\t\t\t       (data->fan_div[0] << 4) |\n\t\t\t\tdata->fan_ctl));\n\t\tbreak;\n\tcase SHOW_SET_PWM_FREQ:\n\t\tval = 135000 / clamp_val(val, 135000 >> 7, 135000);\n\t\t \n\t\ttmp = 0;\n\t\tfor (val >>= 1; val > 0; val >>= 1)\n\t\t\ttmp++;\n\t\t \n\t\treg = vt1211_read8(data, VT1211_REG_PWM_CLK);\n\t\tdata->pwm_clk = (reg & 0xf8) | tmp;\n\t\tvt1211_write8(data, VT1211_REG_PWM_CLK, data->pwm_clk);\n\t\tbreak;\n\tcase SHOW_SET_PWM_AUTO_CHANNELS_TEMP:\n\t\tif (val < 1 || val > 7) {\n\t\t\tcount = -EINVAL;\n\t\t\tdev_warn(dev,\n\t\t\t\t \"temp channel %ld not supported. Choose a value between 1 and 7.\\n\",\n\t\t\t\t val);\n\t\t\tgoto EXIT;\n\t\t}\n\t\tif (!ISTEMP(val - 1, data->uch_config)) {\n\t\t\tcount = -EINVAL;\n\t\t\tdev_warn(dev, \"temp channel %ld is not available.\\n\",\n\t\t\t\t val);\n\t\t\tgoto EXIT;\n\t\t}\n\t\t \n\t\treg = vt1211_read8(data, VT1211_REG_PWM_CTL);\n\t\tdata->pwm_ctl[0] = reg & 0xf;\n\t\tdata->pwm_ctl[1] = (reg >> 4) & 0xf;\n\t\tdata->pwm_ctl[ix] = (data->pwm_ctl[ix] & 8) | (val - 1);\n\t\tvt1211_write8(data, VT1211_REG_PWM_CTL,\n\t\t\t      ((data->pwm_ctl[1] << 4) | data->pwm_ctl[0]));\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown attr fetch (%d)\\n\", fn);\n\t}\n\nEXIT:\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \n\n \n\nstatic ssize_t show_pwm_auto_point_temp(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct vt1211_data *data = vt1211_update_device(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr_2 =\n\t\t\t\t\t\tto_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint ap = sensor_attr_2->nr;\n\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->pwm_ctl[ix] & 7,\n\t\t       data->pwm_auto_temp[ap]));\n}\n\nstatic ssize_t set_pwm_auto_point_temp(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct vt1211_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr_2 =\n\t\t\t\t\t\tto_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint ap = sensor_attr_2->nr;\n\tint reg;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\treg = vt1211_read8(data, VT1211_REG_PWM_CTL);\n\tdata->pwm_ctl[0] = reg & 0xf;\n\tdata->pwm_ctl[1] = (reg >> 4) & 0xf;\n\n\tdata->pwm_auto_temp[ap] = TEMP_TO_REG(data->pwm_ctl[ix] & 7, val);\n\tvt1211_write8(data, VT1211_REG_PWM_AUTO_TEMP(ap),\n\t\t      data->pwm_auto_temp[ap]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\nstatic ssize_t show_pwm_auto_point_pwm(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct vt1211_data *data = vt1211_update_device(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr_2 =\n\t\t\t\t\t\tto_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint ap = sensor_attr_2->nr;\n\n\treturn sprintf(buf, \"%d\\n\", data->pwm_auto_pwm[ix][ap]);\n}\n\nstatic ssize_t set_pwm_auto_point_pwm(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct vt1211_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sensor_attr_2 =\n\t\t\t\t\t\tto_sensor_dev_attr_2(attr);\n\tint ix = sensor_attr_2->index;\n\tint ap = sensor_attr_2->nr;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm_auto_pwm[ix][ap] = clamp_val(val, 0, 255);\n\tvt1211_write8(data, VT1211_REG_PWM_AUTO_PWM(ix, ap),\n\t\t      data->pwm_auto_pwm[ix][ap]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\nstatic ssize_t show_vrm(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct vt1211_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", data->vrm);\n}\n\nstatic ssize_t set_vrm(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct vt1211_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tdata->vrm = val;\n\n\treturn count;\n}\n\nstatic ssize_t show_vid(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct vt1211_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", vid_from_reg(data->vid, data->vrm));\n}\n\nstatic ssize_t show_name(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct vt1211_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", data->name);\n}\n\nstatic ssize_t show_alarms(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct vt1211_data *data = vt1211_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", data->alarms);\n}\n\n \n\n#define SENSOR_ATTR_IN(ix) \\\n{\tSENSOR_ATTR_2(in##ix##_input, S_IRUGO, \\\n\t\tshow_in, NULL, SHOW_IN_INPUT, ix), \\\n\tSENSOR_ATTR_2(in##ix##_min, S_IRUGO | S_IWUSR, \\\n\t\tshow_in, set_in, SHOW_SET_IN_MIN, ix), \\\n\tSENSOR_ATTR_2(in##ix##_max, S_IRUGO | S_IWUSR, \\\n\t\tshow_in, set_in, SHOW_SET_IN_MAX, ix), \\\n\tSENSOR_ATTR_2(in##ix##_alarm, S_IRUGO, \\\n\t\tshow_in, NULL, SHOW_IN_ALARM, ix) \\\n}\n\nstatic struct sensor_device_attribute_2 vt1211_sysfs_in[][4] = {\n\tSENSOR_ATTR_IN(0),\n\tSENSOR_ATTR_IN(1),\n\tSENSOR_ATTR_IN(2),\n\tSENSOR_ATTR_IN(3),\n\tSENSOR_ATTR_IN(4),\n\tSENSOR_ATTR_IN(5)\n};\n\n#define IN_UNIT_ATTRS(X)\t\t\t\\\n{\t&vt1211_sysfs_in[X][0].dev_attr.attr,\t\\\n\t&vt1211_sysfs_in[X][1].dev_attr.attr,\t\\\n\t&vt1211_sysfs_in[X][2].dev_attr.attr,\t\\\n\t&vt1211_sysfs_in[X][3].dev_attr.attr,\t\\\n\tNULL\t\t\t\t\t\\\n}\n\nstatic struct attribute *vt1211_in_attr[][5] = {\n\tIN_UNIT_ATTRS(0),\n\tIN_UNIT_ATTRS(1),\n\tIN_UNIT_ATTRS(2),\n\tIN_UNIT_ATTRS(3),\n\tIN_UNIT_ATTRS(4),\n\tIN_UNIT_ATTRS(5)\n};\n\nstatic const struct attribute_group vt1211_in_attr_group[] = {\n\t{ .attrs = vt1211_in_attr[0] },\n\t{ .attrs = vt1211_in_attr[1] },\n\t{ .attrs = vt1211_in_attr[2] },\n\t{ .attrs = vt1211_in_attr[3] },\n\t{ .attrs = vt1211_in_attr[4] },\n\t{ .attrs = vt1211_in_attr[5] }\n};\n\n#define SENSOR_ATTR_TEMP(ix) \\\n{\tSENSOR_ATTR_2(temp##ix##_input, S_IRUGO, \\\n\t\tshow_temp, NULL, SHOW_TEMP_INPUT, ix-1), \\\n\tSENSOR_ATTR_2(temp##ix##_max, S_IRUGO | S_IWUSR, \\\n\t\tshow_temp, set_temp, SHOW_SET_TEMP_MAX, ix-1), \\\n\tSENSOR_ATTR_2(temp##ix##_max_hyst, S_IRUGO | S_IWUSR, \\\n\t\tshow_temp, set_temp, SHOW_SET_TEMP_MAX_HYST, ix-1), \\\n\tSENSOR_ATTR_2(temp##ix##_alarm, S_IRUGO, \\\n\t\tshow_temp, NULL, SHOW_TEMP_ALARM, ix-1) \\\n}\n\nstatic struct sensor_device_attribute_2 vt1211_sysfs_temp[][4] = {\n\tSENSOR_ATTR_TEMP(1),\n\tSENSOR_ATTR_TEMP(2),\n\tSENSOR_ATTR_TEMP(3),\n\tSENSOR_ATTR_TEMP(4),\n\tSENSOR_ATTR_TEMP(5),\n\tSENSOR_ATTR_TEMP(6),\n\tSENSOR_ATTR_TEMP(7),\n};\n\n#define TEMP_UNIT_ATTRS(X)\t\t\t\\\n{\t&vt1211_sysfs_temp[X][0].dev_attr.attr,\t\\\n\t&vt1211_sysfs_temp[X][1].dev_attr.attr,\t\\\n\t&vt1211_sysfs_temp[X][2].dev_attr.attr,\t\\\n\t&vt1211_sysfs_temp[X][3].dev_attr.attr,\t\\\n\tNULL\t\t\t\t\t\\\n}\n\nstatic struct attribute *vt1211_temp_attr[][5] = {\n\tTEMP_UNIT_ATTRS(0),\n\tTEMP_UNIT_ATTRS(1),\n\tTEMP_UNIT_ATTRS(2),\n\tTEMP_UNIT_ATTRS(3),\n\tTEMP_UNIT_ATTRS(4),\n\tTEMP_UNIT_ATTRS(5),\n\tTEMP_UNIT_ATTRS(6)\n};\n\nstatic const struct attribute_group vt1211_temp_attr_group[] = {\n\t{ .attrs = vt1211_temp_attr[0] },\n\t{ .attrs = vt1211_temp_attr[1] },\n\t{ .attrs = vt1211_temp_attr[2] },\n\t{ .attrs = vt1211_temp_attr[3] },\n\t{ .attrs = vt1211_temp_attr[4] },\n\t{ .attrs = vt1211_temp_attr[5] },\n\t{ .attrs = vt1211_temp_attr[6] }\n};\n\n#define SENSOR_ATTR_FAN(ix) \\\n\tSENSOR_ATTR_2(fan##ix##_input, S_IRUGO, \\\n\t\tshow_fan, NULL, SHOW_FAN_INPUT, ix-1), \\\n\tSENSOR_ATTR_2(fan##ix##_min, S_IRUGO | S_IWUSR, \\\n\t\tshow_fan, set_fan, SHOW_SET_FAN_MIN, ix-1), \\\n\tSENSOR_ATTR_2(fan##ix##_div, S_IRUGO | S_IWUSR, \\\n\t\tshow_fan, set_fan, SHOW_SET_FAN_DIV, ix-1), \\\n\tSENSOR_ATTR_2(fan##ix##_alarm, S_IRUGO, \\\n\t\tshow_fan, NULL, SHOW_FAN_ALARM, ix-1)\n\n#define SENSOR_ATTR_PWM(ix) \\\n\tSENSOR_ATTR_2(pwm##ix, S_IRUGO, \\\n\t\tshow_pwm, NULL, SHOW_PWM, ix-1), \\\n\tSENSOR_ATTR_2(pwm##ix##_enable, S_IRUGO | S_IWUSR, \\\n\t\tshow_pwm, set_pwm, SHOW_SET_PWM_ENABLE, ix-1), \\\n\tSENSOR_ATTR_2(pwm##ix##_auto_channels_temp, S_IRUGO | S_IWUSR, \\\n\t\tshow_pwm, set_pwm, SHOW_SET_PWM_AUTO_CHANNELS_TEMP, ix-1)\n\n#define SENSOR_ATTR_PWM_FREQ(ix) \\\n\tSENSOR_ATTR_2(pwm##ix##_freq, S_IRUGO | S_IWUSR, \\\n\t\tshow_pwm, set_pwm, SHOW_SET_PWM_FREQ, ix-1)\n\n#define SENSOR_ATTR_PWM_FREQ_RO(ix) \\\n\tSENSOR_ATTR_2(pwm##ix##_freq, S_IRUGO, \\\n\t\tshow_pwm, NULL, SHOW_SET_PWM_FREQ, ix-1)\n\n#define SENSOR_ATTR_PWM_AUTO_POINT_TEMP(ix, ap) \\\n\tSENSOR_ATTR_2(pwm##ix##_auto_point##ap##_temp, S_IRUGO | S_IWUSR, \\\n\t\tshow_pwm_auto_point_temp, set_pwm_auto_point_temp, \\\n\t\tap-1, ix-1)\n\n#define SENSOR_ATTR_PWM_AUTO_POINT_TEMP_RO(ix, ap) \\\n\tSENSOR_ATTR_2(pwm##ix##_auto_point##ap##_temp, S_IRUGO, \\\n\t\tshow_pwm_auto_point_temp, NULL, \\\n\t\tap-1, ix-1)\n\n#define SENSOR_ATTR_PWM_AUTO_POINT_PWM(ix, ap) \\\n\tSENSOR_ATTR_2(pwm##ix##_auto_point##ap##_pwm, S_IRUGO | S_IWUSR, \\\n\t\tshow_pwm_auto_point_pwm, set_pwm_auto_point_pwm, \\\n\t\tap-1, ix-1)\n\n#define SENSOR_ATTR_PWM_AUTO_POINT_PWM_RO(ix, ap) \\\n\tSENSOR_ATTR_2(pwm##ix##_auto_point##ap##_pwm, S_IRUGO, \\\n\t\tshow_pwm_auto_point_pwm, NULL, \\\n\t\tap-1, ix-1)\n\nstatic struct sensor_device_attribute_2 vt1211_sysfs_fan_pwm[] = {\n\tSENSOR_ATTR_FAN(1),\n\tSENSOR_ATTR_FAN(2),\n\tSENSOR_ATTR_PWM(1),\n\tSENSOR_ATTR_PWM(2),\n\tSENSOR_ATTR_PWM_FREQ(1),\n\tSENSOR_ATTR_PWM_FREQ_RO(2),\n\tSENSOR_ATTR_PWM_AUTO_POINT_TEMP(1, 1),\n\tSENSOR_ATTR_PWM_AUTO_POINT_TEMP(1, 2),\n\tSENSOR_ATTR_PWM_AUTO_POINT_TEMP(1, 3),\n\tSENSOR_ATTR_PWM_AUTO_POINT_TEMP(1, 4),\n\tSENSOR_ATTR_PWM_AUTO_POINT_TEMP_RO(2, 1),\n\tSENSOR_ATTR_PWM_AUTO_POINT_TEMP_RO(2, 2),\n\tSENSOR_ATTR_PWM_AUTO_POINT_TEMP_RO(2, 3),\n\tSENSOR_ATTR_PWM_AUTO_POINT_TEMP_RO(2, 4),\n\tSENSOR_ATTR_PWM_AUTO_POINT_PWM_RO(1, 1),\n\tSENSOR_ATTR_PWM_AUTO_POINT_PWM(1, 2),\n\tSENSOR_ATTR_PWM_AUTO_POINT_PWM(1, 3),\n\tSENSOR_ATTR_PWM_AUTO_POINT_PWM_RO(1, 4),\n\tSENSOR_ATTR_PWM_AUTO_POINT_PWM_RO(2, 1),\n\tSENSOR_ATTR_PWM_AUTO_POINT_PWM(2, 2),\n\tSENSOR_ATTR_PWM_AUTO_POINT_PWM(2, 3),\n\tSENSOR_ATTR_PWM_AUTO_POINT_PWM_RO(2, 4),\n};\n\nstatic struct device_attribute vt1211_sysfs_misc[] = {\n\t__ATTR(vrm, S_IRUGO | S_IWUSR, show_vrm, set_vrm),\n\t__ATTR(cpu0_vid, S_IRUGO, show_vid, NULL),\n\t__ATTR(name, S_IRUGO, show_name, NULL),\n\t__ATTR(alarms, S_IRUGO, show_alarms, NULL),\n};\n\n \n\nstatic void vt1211_init_device(struct vt1211_data *data)\n{\n\t \n\tdata->vrm = vid_which_vrm();\n\n\t \n\tdata->uch_config = vt1211_read8(data, VT1211_REG_UCH_CONFIG);\n\tif (uch_config > -1) {\n\t\tdata->uch_config = (data->uch_config & 0x83) |\n\t\t\t\t   (uch_config << 2);\n\t\tvt1211_write8(data, VT1211_REG_UCH_CONFIG, data->uch_config);\n\t}\n\n\t \n\tif (int_mode == 0) {\n\t\tvt1211_write8(data, VT1211_REG_TEMP1_CONFIG, 0);\n\t\tvt1211_write8(data, VT1211_REG_TEMP2_CONFIG, 0);\n\t}\n\n\t \n\tdata->pwm_auto_pwm[0][3] = 255;\n\tdata->pwm_auto_pwm[1][3] = 255;\n}\n\nstatic void vt1211_remove_sysfs(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vt1211_in_attr_group); i++)\n\t\tsysfs_remove_group(&dev->kobj, &vt1211_in_attr_group[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(vt1211_temp_attr_group); i++)\n\t\tsysfs_remove_group(&dev->kobj, &vt1211_temp_attr_group[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(vt1211_sysfs_fan_pwm); i++) {\n\t\tdevice_remove_file(dev,\n\t\t\t&vt1211_sysfs_fan_pwm[i].dev_attr);\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(vt1211_sysfs_misc); i++)\n\t\tdevice_remove_file(dev, &vt1211_sysfs_misc[i]);\n}\n\nstatic int vt1211_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct vt1211_data *data;\n\tstruct resource *res;\n\tint i, err;\n\n\tdata = devm_kzalloc(dev, sizeof(struct vt1211_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!devm_request_region(dev, res->start, resource_size(res),\n\t\t\t\t DRVNAME)) {\n\t\tdev_err(dev, \"Failed to request region 0x%lx-0x%lx\\n\",\n\t\t\t(unsigned long)res->start, (unsigned long)res->end);\n\t\treturn -EBUSY;\n\t}\n\tdata->addr = res->start;\n\tdata->name = DRVNAME;\n\tmutex_init(&data->update_lock);\n\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tvt1211_init_device(data);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vt1211_in_attr_group); i++) {\n\t\tif (ISVOLT(i, data->uch_config)) {\n\t\t\terr = sysfs_create_group(&dev->kobj,\n\t\t\t\t\t\t &vt1211_in_attr_group[i]);\n\t\t\tif (err)\n\t\t\t\tgoto EXIT_DEV_REMOVE;\n\t\t}\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(vt1211_temp_attr_group); i++) {\n\t\tif (ISTEMP(i, data->uch_config)) {\n\t\t\terr = sysfs_create_group(&dev->kobj,\n\t\t\t\t\t\t &vt1211_temp_attr_group[i]);\n\t\t\tif (err)\n\t\t\t\tgoto EXIT_DEV_REMOVE;\n\t\t}\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(vt1211_sysfs_fan_pwm); i++) {\n\t\terr = device_create_file(dev,\n\t\t\t&vt1211_sysfs_fan_pwm[i].dev_attr);\n\t\tif (err)\n\t\t\tgoto EXIT_DEV_REMOVE;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(vt1211_sysfs_misc); i++) {\n\t\terr = device_create_file(dev,\n\t\t       &vt1211_sysfs_misc[i]);\n\t\tif (err)\n\t\t\tgoto EXIT_DEV_REMOVE;\n\t}\n\n\t \n\tdata->hwmon_dev = hwmon_device_register(dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tdev_err(dev, \"Class registration failed (%d)\\n\", err);\n\t\tgoto EXIT_DEV_REMOVE_SILENT;\n\t}\n\n\treturn 0;\n\nEXIT_DEV_REMOVE:\n\tdev_err(dev, \"Sysfs interface creation failed (%d)\\n\", err);\nEXIT_DEV_REMOVE_SILENT:\n\tvt1211_remove_sysfs(pdev);\n\treturn err;\n}\n\nstatic int vt1211_remove(struct platform_device *pdev)\n{\n\tstruct vt1211_data *data = platform_get_drvdata(pdev);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tvt1211_remove_sysfs(pdev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver vt1211_driver = {\n\t.driver = {\n\t\t.name  = DRVNAME,\n\t},\n\t.probe  = vt1211_probe,\n\t.remove = vt1211_remove,\n};\n\nstatic int __init vt1211_device_add(unsigned short address)\n{\n\tstruct resource res = {\n\t\t.start\t= address,\n\t\t.end\t= address + 0x7f,\n\t\t.flags\t= IORESOURCE_IO,\n\t};\n\tint err;\n\n\tpdev = platform_device_alloc(DRVNAME, address);\n\tif (!pdev) {\n\t\terr = -ENOMEM;\n\t\tpr_err(\"Device allocation failed (%d)\\n\", err);\n\t\tgoto EXIT;\n\t}\n\n\tres.name = pdev->name;\n\terr = acpi_check_resource_conflict(&res);\n\tif (err)\n\t\tgoto EXIT_DEV_PUT;\n\n\terr = platform_device_add_resources(pdev, &res, 1);\n\tif (err) {\n\t\tpr_err(\"Device resource addition failed (%d)\\n\", err);\n\t\tgoto EXIT_DEV_PUT;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n\t\tpr_err(\"Device addition failed (%d)\\n\", err);\n\t\tgoto EXIT_DEV_PUT;\n\t}\n\n\treturn 0;\n\nEXIT_DEV_PUT:\n\tplatform_device_put(pdev);\nEXIT:\n\treturn err;\n}\n\nstatic int __init vt1211_find(int sio_cip, unsigned short *address)\n{\n\tint err;\n\tint devid;\n\n\terr = superio_enter(sio_cip);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENODEV;\n\tdevid = force_id ? force_id : superio_inb(sio_cip, SIO_VT1211_DEVID);\n\tif (devid != SIO_VT1211_ID)\n\t\tgoto EXIT;\n\n\tsuperio_select(sio_cip, SIO_VT1211_LDN_HWMON);\n\n\tif ((superio_inb(sio_cip, SIO_VT1211_ACTIVE) & 1) == 0) {\n\t\tpr_warn(\"HW monitor is disabled, skipping\\n\");\n\t\tgoto EXIT;\n\t}\n\n\t*address = ((superio_inb(sio_cip, SIO_VT1211_BADDR) << 8) |\n\t\t    (superio_inb(sio_cip, SIO_VT1211_BADDR + 1))) & 0xff00;\n\tif (*address == 0) {\n\t\tpr_warn(\"Base address is not set, skipping\\n\");\n\t\tgoto EXIT;\n\t}\n\n\terr = 0;\n\tpr_info(\"Found VT1211 chip at 0x%04x, revision %u\\n\",\n\t\t*address, superio_inb(sio_cip, SIO_VT1211_DEVREV));\n\nEXIT:\n\tsuperio_exit(sio_cip);\n\treturn err;\n}\n\nstatic int __init vt1211_init(void)\n{\n\tint err;\n\tunsigned short address = 0;\n\n\terr = vt1211_find(SIO_REG_CIP1, &address);\n\tif (err) {\n\t\terr = vt1211_find(SIO_REG_CIP2, &address);\n\t\tif (err)\n\t\t\tgoto EXIT;\n\t}\n\n\tif ((uch_config < -1) || (uch_config > 31)) {\n\t\terr = -EINVAL;\n\t\tpr_warn(\"Invalid UCH configuration %d. Choose a value between 0 and 31.\\n\",\n\t\t\tuch_config);\n\t\tgoto EXIT;\n\t}\n\n\tif ((int_mode < -1) || (int_mode > 0)) {\n\t\terr = -EINVAL;\n\t\tpr_warn(\"Invalid interrupt mode %d. Only mode 0 is supported.\\n\",\n\t\t\tint_mode);\n\t\tgoto EXIT;\n\t}\n\n\terr = platform_driver_register(&vt1211_driver);\n\tif (err)\n\t\tgoto EXIT;\n\n\t \n\terr = vt1211_device_add(address);\n\tif (err)\n\t\tgoto EXIT_DRV_UNREGISTER;\n\n\treturn 0;\n\nEXIT_DRV_UNREGISTER:\n\tplatform_driver_unregister(&vt1211_driver);\nEXIT:\n\treturn err;\n}\n\nstatic void __exit vt1211_exit(void)\n{\n\tplatform_device_unregister(pdev);\n\tplatform_driver_unregister(&vt1211_driver);\n}\n\nMODULE_AUTHOR(\"Juerg Haefliger <juergh@gmail.com>\");\nMODULE_DESCRIPTION(\"VT1211 sensors\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(vt1211_init);\nmodule_exit(vt1211_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}