{
  "module_name": "gl518sm.c",
  "hash_id": "4664b2eb78726238e4bd73c072725e4fe2b09ddacbf90d78b3b84263e0d52a55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/gl518sm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x2c, 0x2d, I2C_CLIENT_END };\n\nenum chips { gl518sm_r00, gl518sm_r80 };\n\n \n\n \n#define GL518_REG_CHIP_ID\t0x00\n#define GL518_REG_REVISION\t0x01\n#define GL518_REG_VENDOR_ID\t0x02\n#define GL518_REG_CONF\t\t0x03\n#define GL518_REG_TEMP_IN\t0x04\n#define GL518_REG_TEMP_MAX\t0x05\n#define GL518_REG_TEMP_HYST\t0x06\n#define GL518_REG_FAN_COUNT\t0x07\n#define GL518_REG_FAN_LIMIT\t0x08\n#define GL518_REG_VIN1_LIMIT\t0x09\n#define GL518_REG_VIN2_LIMIT\t0x0a\n#define GL518_REG_VIN3_LIMIT\t0x0b\n#define GL518_REG_VDD_LIMIT\t0x0c\n#define GL518_REG_VIN3\t\t0x0d\n#define GL518_REG_MISC\t\t0x0f\n#define GL518_REG_ALARM\t\t0x10\n#define GL518_REG_MASK\t\t0x11\n#define GL518_REG_INT\t\t0x12\n#define GL518_REG_VIN2\t\t0x13\n#define GL518_REG_VIN1\t\t0x14\n#define GL518_REG_VDD\t\t0x15\n\n\n \n\n#define RAW_FROM_REG(val)\tval\n\n#define BOOL_FROM_REG(val)\t((val) ? 0 : 1)\n#define BOOL_TO_REG(val)\t((val) ? 0 : 1)\n\n#define TEMP_CLAMP(val)\t\tclamp_val(val, -119000, 136000)\n#define TEMP_TO_REG(val)\t(DIV_ROUND_CLOSEST(TEMP_CLAMP(val), 1000) + 119)\n#define TEMP_FROM_REG(val)\t(((val) - 119) * 1000)\n\nstatic inline u8 FAN_TO_REG(long rpm, int div)\n{\n\tlong rpmdiv;\n\tif (rpm == 0)\n\t\treturn 0;\n\trpmdiv = clamp_val(rpm, 1, 960000) * div;\n\treturn clamp_val((480000 + rpmdiv / 2) / rpmdiv, 1, 255);\n}\n#define FAN_FROM_REG(val, div)\t((val) == 0 ? 0 : (480000 / ((val) * (div))))\n\n#define IN_CLAMP(val)\t\tclamp_val(val, 0, 255 * 19)\n#define IN_TO_REG(val)\t\tDIV_ROUND_CLOSEST(IN_CLAMP(val), 19)\n#define IN_FROM_REG(val)\t((val) * 19)\n\n#define VDD_CLAMP(val)\t\tclamp_val(val, 0, 255 * 95 / 4)\n#define VDD_TO_REG(val)\t\tDIV_ROUND_CLOSEST(VDD_CLAMP(val) * 4, 95)\n#define VDD_FROM_REG(val)\tDIV_ROUND_CLOSEST((val) * 95, 4)\n\n#define DIV_FROM_REG(val)\t(1 << (val))\n\n#define BEEP_MASK_TO_REG(val)\t((val) & 0x7f & data->alarm_mask)\n#define BEEP_MASK_FROM_REG(val)\t((val) & 0x7f)\n\n \nstruct gl518_data {\n\tstruct i2c_client *client;\n\tconst struct attribute_group *groups[3];\n\tenum chips type;\n\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\n\tu8 voltage_in[4];\t \n\tu8 voltage_min[4];\t \n\tu8 voltage_max[4];\t \n\tu8 fan_in[2];\n\tu8 fan_min[2];\n\tu8 fan_div[2];\t\t \n\tu8 fan_auto1;\t\t \n\tu8 temp_in;\t\t \n\tu8 temp_max;\t\t \n\tu8 temp_hyst;\t\t \n\tu8 alarms;\t\t \n\tu8 alarm_mask;\n\tu8 beep_mask;\t\t \n\tu8 beep_enable;\t\t \n};\n\n \nstatic int gl518_read_value(struct i2c_client *client, u8 reg)\n{\n\tif ((reg >= 0x07) && (reg <= 0x0c))\n\t\treturn i2c_smbus_read_word_swapped(client, reg);\n\telse\n\t\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic int gl518_write_value(struct i2c_client *client, u8 reg, u16 value)\n{\n\tif ((reg >= 0x07) && (reg <= 0x0c))\n\t\treturn i2c_smbus_write_word_swapped(client, reg, value);\n\telse\n\t\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic struct gl518_data *gl518_update_device(struct device *dev)\n{\n\tstruct gl518_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint val;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\n\t    || !data->valid) {\n\t\tdev_dbg(&client->dev, \"Starting gl518 update\\n\");\n\n\t\tdata->alarms = gl518_read_value(client, GL518_REG_INT);\n\t\tdata->beep_mask = gl518_read_value(client, GL518_REG_ALARM);\n\n\t\tval = gl518_read_value(client, GL518_REG_VDD_LIMIT);\n\t\tdata->voltage_min[0] = val & 0xff;\n\t\tdata->voltage_max[0] = (val >> 8) & 0xff;\n\t\tval = gl518_read_value(client, GL518_REG_VIN1_LIMIT);\n\t\tdata->voltage_min[1] = val & 0xff;\n\t\tdata->voltage_max[1] = (val >> 8) & 0xff;\n\t\tval = gl518_read_value(client, GL518_REG_VIN2_LIMIT);\n\t\tdata->voltage_min[2] = val & 0xff;\n\t\tdata->voltage_max[2] = (val >> 8) & 0xff;\n\t\tval = gl518_read_value(client, GL518_REG_VIN3_LIMIT);\n\t\tdata->voltage_min[3] = val & 0xff;\n\t\tdata->voltage_max[3] = (val >> 8) & 0xff;\n\n\t\tval = gl518_read_value(client, GL518_REG_FAN_COUNT);\n\t\tdata->fan_in[0] = (val >> 8) & 0xff;\n\t\tdata->fan_in[1] = val & 0xff;\n\n\t\tval = gl518_read_value(client, GL518_REG_FAN_LIMIT);\n\t\tdata->fan_min[0] = (val >> 8) & 0xff;\n\t\tdata->fan_min[1] = val & 0xff;\n\n\t\tdata->temp_in = gl518_read_value(client, GL518_REG_TEMP_IN);\n\t\tdata->temp_max =\n\t\t    gl518_read_value(client, GL518_REG_TEMP_MAX);\n\t\tdata->temp_hyst =\n\t\t    gl518_read_value(client, GL518_REG_TEMP_HYST);\n\n\t\tval = gl518_read_value(client, GL518_REG_MISC);\n\t\tdata->fan_div[0] = (val >> 6) & 0x03;\n\t\tdata->fan_div[1] = (val >> 4) & 0x03;\n\t\tdata->fan_auto1  = (val >> 3) & 0x01;\n\n\t\tdata->alarms &= data->alarm_mask;\n\n\t\tval = gl518_read_value(client, GL518_REG_CONF);\n\t\tdata->beep_enable = (val >> 2) & 1;\n\n\t\tif (data->type != gl518sm_r00) {\n\t\t\tdata->voltage_in[0] =\n\t\t\t    gl518_read_value(client, GL518_REG_VDD);\n\t\t\tdata->voltage_in[1] =\n\t\t\t    gl518_read_value(client, GL518_REG_VIN1);\n\t\t\tdata->voltage_in[2] =\n\t\t\t    gl518_read_value(client, GL518_REG_VIN2);\n\t\t}\n\t\tdata->voltage_in[3] =\n\t\t    gl518_read_value(client, GL518_REG_VIN3);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \n\n#define show(type, suffix, value)\t\t\t\t\t\\\nstatic ssize_t show_##suffix(struct device *dev,\t\t\t\\\n\t\t\t     struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gl518_data *data = gl518_update_device(dev);\t\t\\\n\treturn sprintf(buf, \"%d\\n\", type##_FROM_REG(data->value));\t\\\n}\n\nshow(TEMP, temp_input1, temp_in);\nshow(TEMP, temp_max1, temp_max);\nshow(TEMP, temp_hyst1, temp_hyst);\nshow(BOOL, fan_auto1, fan_auto1);\nshow(VDD, in_input0, voltage_in[0]);\nshow(IN, in_input1, voltage_in[1]);\nshow(IN, in_input2, voltage_in[2]);\nshow(IN, in_input3, voltage_in[3]);\nshow(VDD, in_min0, voltage_min[0]);\nshow(IN, in_min1, voltage_min[1]);\nshow(IN, in_min2, voltage_min[2]);\nshow(IN, in_min3, voltage_min[3]);\nshow(VDD, in_max0, voltage_max[0]);\nshow(IN, in_max1, voltage_max[1]);\nshow(IN, in_max2, voltage_max[2]);\nshow(IN, in_max3, voltage_max[3]);\nshow(RAW, alarms, alarms);\nshow(BOOL, beep_enable, beep_enable);\nshow(BEEP_MASK, beep_mask, beep_mask);\n\nstatic ssize_t fan_input_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct gl518_data *data = gl518_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", FAN_FROM_REG(data->fan_in[nr],\n\t\t\t\t\tDIV_FROM_REG(data->fan_div[nr])));\n}\n\nstatic ssize_t fan_min_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct gl518_data *data = gl518_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", FAN_FROM_REG(data->fan_min[nr],\n\t\t\t\t\tDIV_FROM_REG(data->fan_div[nr])));\n}\n\nstatic ssize_t fan_div_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct gl518_data *data = gl518_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", DIV_FROM_REG(data->fan_div[nr]));\n}\n\n#define set(type, suffix, value, reg)\t\t\t\t\t\\\nstatic ssize_t set_##suffix(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    const char *buf, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gl518_data *data = dev_get_drvdata(dev);\t\t\t\\\n\tstruct i2c_client *client = data->client;\t\t\t\\\n\tlong val;\t\t\t\t\t\t\t\\\n\tint err = kstrtol(buf, 10, &val);\t\t\t\t\\\n\tif (err)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&data->update_lock);\t\t\t\t\t\\\n\tdata->value = type##_TO_REG(val);\t\t\t\t\\\n\tgl518_write_value(client, reg, data->value);\t\t\t\\\n\tmutex_unlock(&data->update_lock);\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define set_bits(type, suffix, value, reg, mask, shift)\t\t\t\\\nstatic ssize_t set_##suffix(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    const char *buf, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gl518_data *data = dev_get_drvdata(dev);\t\t\t\\\n\tstruct i2c_client *client = data->client;\t\t\t\\\n\tint regvalue;\t\t\t\t\t\t\t\\\n\tunsigned long val;\t\t\t\t\t\t\\\n\tint err = kstrtoul(buf, 10, &val);\t\t\t\t\\\n\tif (err)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&data->update_lock);\t\t\t\t\t\\\n\tregvalue = gl518_read_value(client, reg);\t\t\t\\\n\tdata->value = type##_TO_REG(val);\t\t\t\t\\\n\tregvalue = (regvalue & ~mask) | (data->value << shift);\t\t\\\n\tgl518_write_value(client, reg, regvalue);\t\t\t\\\n\tmutex_unlock(&data->update_lock);\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define set_low(type, suffix, value, reg)\t\t\t\t\\\n\tset_bits(type, suffix, value, reg, 0x00ff, 0)\n#define set_high(type, suffix, value, reg)\t\t\t\t\\\n\tset_bits(type, suffix, value, reg, 0xff00, 8)\n\nset(TEMP, temp_max1, temp_max, GL518_REG_TEMP_MAX);\nset(TEMP, temp_hyst1, temp_hyst, GL518_REG_TEMP_HYST);\nset_bits(BOOL, fan_auto1, fan_auto1, GL518_REG_MISC, 0x08, 3);\nset_low(VDD, in_min0, voltage_min[0], GL518_REG_VDD_LIMIT);\nset_low(IN, in_min1, voltage_min[1], GL518_REG_VIN1_LIMIT);\nset_low(IN, in_min2, voltage_min[2], GL518_REG_VIN2_LIMIT);\nset_low(IN, in_min3, voltage_min[3], GL518_REG_VIN3_LIMIT);\nset_high(VDD, in_max0, voltage_max[0], GL518_REG_VDD_LIMIT);\nset_high(IN, in_max1, voltage_max[1], GL518_REG_VIN1_LIMIT);\nset_high(IN, in_max2, voltage_max[2], GL518_REG_VIN2_LIMIT);\nset_high(IN, in_max3, voltage_max[3], GL518_REG_VIN3_LIMIT);\nset_bits(BOOL, beep_enable, beep_enable, GL518_REG_CONF, 0x04, 2);\nset(BEEP_MASK, beep_mask, beep_mask, GL518_REG_ALARM);\n\nstatic ssize_t fan_min_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct gl518_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tint regvalue;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tregvalue = gl518_read_value(client, GL518_REG_FAN_LIMIT);\n\tdata->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\n\tregvalue = (regvalue & (0xff << (8 * nr)))\n\t\t | (data->fan_min[nr] << (8 * (1 - nr)));\n\tgl518_write_value(client, GL518_REG_FAN_LIMIT, regvalue);\n\n\tdata->beep_mask = gl518_read_value(client, GL518_REG_ALARM);\n\tif (data->fan_min[nr] == 0)\n\t\tdata->alarm_mask &= ~(0x20 << nr);\n\telse\n\t\tdata->alarm_mask |= (0x20 << nr);\n\tdata->beep_mask &= data->alarm_mask;\n\tgl518_write_value(client, GL518_REG_ALARM, data->beep_mask);\n\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t fan_div_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct gl518_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tint regvalue;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tswitch (val) {\n\tcase 1:\n\t\tval = 0;\n\t\tbreak;\n\tcase 2:\n\t\tval = 1;\n\t\tbreak;\n\tcase 4:\n\t\tval = 2;\n\t\tbreak;\n\tcase 8:\n\t\tval = 3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev,\n\t\t\t\"Invalid fan clock divider %lu, choose one of 1, 2, 4 or 8\\n\",\n\t\t\tval);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&data->update_lock);\n\tregvalue = gl518_read_value(client, GL518_REG_MISC);\n\tdata->fan_div[nr] = val;\n\tregvalue = (regvalue & ~(0xc0 >> (2 * nr)))\n\t\t | (data->fan_div[nr] << (6 - 2 * nr));\n\tgl518_write_value(client, GL518_REG_MISC, regvalue);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(temp1_input, 0444, show_temp_input1, NULL);\nstatic DEVICE_ATTR(temp1_max, 0644, show_temp_max1, set_temp_max1);\nstatic DEVICE_ATTR(temp1_max_hyst, 0644,\n\t\t   show_temp_hyst1, set_temp_hyst1);\nstatic DEVICE_ATTR(fan1_auto, 0644, show_fan_auto1, set_fan_auto1);\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan_input, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan_input, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_min, fan_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_min, fan_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_div, fan_div, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_div, fan_div, 1);\nstatic DEVICE_ATTR(in0_input, 0444, show_in_input0, NULL);\nstatic DEVICE_ATTR(in1_input, 0444, show_in_input1, NULL);\nstatic DEVICE_ATTR(in2_input, 0444, show_in_input2, NULL);\nstatic DEVICE_ATTR(in3_input, 0444, show_in_input3, NULL);\nstatic DEVICE_ATTR(in0_min, 0644, show_in_min0, set_in_min0);\nstatic DEVICE_ATTR(in1_min, 0644, show_in_min1, set_in_min1);\nstatic DEVICE_ATTR(in2_min, 0644, show_in_min2, set_in_min2);\nstatic DEVICE_ATTR(in3_min, 0644, show_in_min3, set_in_min3);\nstatic DEVICE_ATTR(in0_max, 0644, show_in_max0, set_in_max0);\nstatic DEVICE_ATTR(in1_max, 0644, show_in_max1, set_in_max1);\nstatic DEVICE_ATTR(in2_max, 0644, show_in_max2, set_in_max2);\nstatic DEVICE_ATTR(in3_max, 0644, show_in_max3, set_in_max3);\nstatic DEVICE_ATTR(alarms, 0444, show_alarms, NULL);\nstatic DEVICE_ATTR(beep_enable, 0644,\n\t\t   show_beep_enable, set_beep_enable);\nstatic DEVICE_ATTR(beep_mask, 0644,\n\t\t   show_beep_mask, set_beep_mask);\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tstruct gl518_data *data = gl518_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> bitnr) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(in0_alarm, alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_alarm, alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_alarm, alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_alarm, alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_alarm, alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(fan1_alarm, alarm, 5);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_alarm, alarm, 6);\n\nstatic ssize_t beep_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tstruct gl518_data *data = gl518_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", (data->beep_mask >> bitnr) & 1);\n}\n\nstatic ssize_t beep_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct gl518_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tunsigned long bit;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &bit);\n\tif (err)\n\t\treturn err;\n\n\tif (bit & ~1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->beep_mask = gl518_read_value(client, GL518_REG_ALARM);\n\tif (bit)\n\t\tdata->beep_mask |= (1 << bitnr);\n\telse\n\t\tdata->beep_mask &= ~(1 << bitnr);\n\tgl518_write_value(client, GL518_REG_ALARM, data->beep_mask);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(in0_beep, beep, 0);\nstatic SENSOR_DEVICE_ATTR_RW(in1_beep, beep, 1);\nstatic SENSOR_DEVICE_ATTR_RW(in2_beep, beep, 2);\nstatic SENSOR_DEVICE_ATTR_RW(in3_beep, beep, 3);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_beep, beep, 4);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_beep, beep, 5);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_beep, beep, 6);\n\nstatic struct attribute *gl518_attributes[] = {\n\t&dev_attr_in3_input.attr,\n\t&dev_attr_in0_min.attr,\n\t&dev_attr_in1_min.attr,\n\t&dev_attr_in2_min.attr,\n\t&dev_attr_in3_min.attr,\n\t&dev_attr_in0_max.attr,\n\t&dev_attr_in1_max.attr,\n\t&dev_attr_in2_max.attr,\n\t&dev_attr_in3_max.attr,\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in0_beep.dev_attr.attr,\n\t&sensor_dev_attr_in1_beep.dev_attr.attr,\n\t&sensor_dev_attr_in2_beep.dev_attr.attr,\n\t&sensor_dev_attr_in3_beep.dev_attr.attr,\n\n\t&dev_attr_fan1_auto.attr,\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_div.dev_attr.attr,\n\t&sensor_dev_attr_fan2_div.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan1_beep.dev_attr.attr,\n\t&sensor_dev_attr_fan2_beep.dev_attr.attr,\n\n\t&dev_attr_temp1_input.attr,\n\t&dev_attr_temp1_max.attr,\n\t&dev_attr_temp1_max_hyst.attr,\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_beep.dev_attr.attr,\n\n\t&dev_attr_alarms.attr,\n\t&dev_attr_beep_enable.attr,\n\t&dev_attr_beep_mask.attr,\n\tNULL\n};\n\nstatic const struct attribute_group gl518_group = {\n\t.attrs = gl518_attributes,\n};\n\nstatic struct attribute *gl518_attributes_r80[] = {\n\t&dev_attr_in0_input.attr,\n\t&dev_attr_in1_input.attr,\n\t&dev_attr_in2_input.attr,\n\tNULL\n};\n\nstatic const struct attribute_group gl518_group_r80 = {\n\t.attrs = gl518_attributes_r80,\n};\n\n \n\n \nstatic int gl518_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint rev;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tif ((gl518_read_value(client, GL518_REG_CHIP_ID) != 0x80)\n\t || (gl518_read_value(client, GL518_REG_CONF) & 0x80))\n\t\treturn -ENODEV;\n\n\t \n\trev = gl518_read_value(client, GL518_REG_REVISION);\n\tif (rev != 0x00 && rev != 0x80)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"gl518sm\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\n \nstatic void gl518_init_client(struct i2c_client *client)\n{\n\t \n\tu8 regvalue = gl518_read_value(client, GL518_REG_CONF) & 0x7f;\n\n\t \n\tgl518_write_value(client, GL518_REG_CONF, (regvalue &= 0x37));\n\n\t \n\tgl518_write_value(client, GL518_REG_MASK, 0x00);\n\n\t \n\tgl518_write_value(client, GL518_REG_CONF, 0x20 | regvalue);\n\tgl518_write_value(client, GL518_REG_CONF, 0x40 | regvalue);\n}\n\nstatic int gl518_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct gl518_data *data;\n\tint revision;\n\n\tdata = devm_kzalloc(dev, sizeof(struct gl518_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\trevision = gl518_read_value(client, GL518_REG_REVISION);\n\tdata->type = revision == 0x80 ? gl518sm_r80 : gl518sm_r00;\n\tmutex_init(&data->update_lock);\n\n\t \n\tdata->alarm_mask = 0xff;\n\tgl518_init_client(client);\n\n\t \n\tdata->groups[0] = &gl518_group;\n\tif (data->type == gl518sm_r80)\n\t\tdata->groups[1] = &gl518_group_r80;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, data->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id gl518_id[] = {\n\t{ \"gl518sm\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, gl518_id);\n\nstatic struct i2c_driver gl518_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"gl518sm\",\n\t},\n\t.probe\t\t= gl518_probe,\n\t.id_table\t= gl518_id,\n\t.detect\t\t= gl518_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(gl518_driver);\n\nMODULE_AUTHOR(\"Frodo Looijaard <frodol@dds.nl>, \"\n\t\"Kyosti Malkki <kmalkki@cc.hut.fi> and \"\n\t\"Hong-Gunn Chew <hglinux@gunnet.org>\");\nMODULE_DESCRIPTION(\"GL518SM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}