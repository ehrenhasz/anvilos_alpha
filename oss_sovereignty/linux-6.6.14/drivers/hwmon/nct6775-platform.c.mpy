{
  "module_name": "nct6775-platform.c",
  "hash_id": "77838adc04392de15460f7e37bd73df8be6f8e9ea7ced66c687f7f64a90df031",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/nct6775-platform.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon-vid.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include \"nct6775.h\"\n\nenum sensor_access { access_direct, access_asuswmi };\n\nstatic const char * const nct6775_sio_names[] __initconst = {\n\t\"NCT6106D\",\n\t\"NCT6116D\",\n\t\"NCT6775F\",\n\t\"NCT6776D/F\",\n\t\"NCT6779D\",\n\t\"NCT6791D\",\n\t\"NCT6792D\",\n\t\"NCT6793D\",\n\t\"NCT6795D\",\n\t\"NCT6796D\",\n\t\"NCT6797D\",\n\t\"NCT6798D\",\n\t\"NCT6796D-S/NCT6799D-R\",\n};\n\nstatic unsigned short force_id;\nmodule_param(force_id, ushort, 0);\nMODULE_PARM_DESC(force_id, \"Override the detected device ID\");\n\nstatic unsigned short fan_debounce;\nmodule_param(fan_debounce, ushort, 0);\nMODULE_PARM_DESC(fan_debounce, \"Enable debouncing for fan RPM signal\");\n\n#define DRVNAME \"nct6775\"\n\n#define NCT6775_PORT_CHIPID\t0x58\n\n \n\n#define IOREGION_ALIGNMENT\t(~7)\n#define IOREGION_OFFSET\t\t5\n#define IOREGION_LENGTH\t\t2\n#define ADDR_REG_OFFSET\t\t0\n#define DATA_REG_OFFSET\t\t1\n\n \n\n#define NCT6775_LD_ACPI\t\t0x0a\n#define NCT6775_LD_HWM\t\t0x0b\n#define NCT6775_LD_VID\t\t0x0d\n#define NCT6775_LD_12\t\t0x12\n\n#define SIO_REG_LDSEL\t\t0x07\t \n#define SIO_REG_DEVID\t\t0x20\t \n#define SIO_REG_ENABLE\t\t0x30\t \n#define SIO_REG_ADDR\t\t0x60\t \n\n#define SIO_NCT6106_ID\t\t0xc450\n#define SIO_NCT6116_ID\t\t0xd280\n#define SIO_NCT6775_ID\t\t0xb470\n#define SIO_NCT6776_ID\t\t0xc330\n#define SIO_NCT6779_ID\t\t0xc560\n#define SIO_NCT6791_ID\t\t0xc800\n#define SIO_NCT6792_ID\t\t0xc910\n#define SIO_NCT6793_ID\t\t0xd120\n#define SIO_NCT6795_ID\t\t0xd350\n#define SIO_NCT6796_ID\t\t0xd420\n#define SIO_NCT6797_ID\t\t0xd450\n#define SIO_NCT6798_ID\t\t0xd428\n#define SIO_NCT6799_ID\t\t0xd800\n#define SIO_ID_MASK\t\t0xFFF8\n\n \n#define NCT6775_REG_CR_FAN_DEBOUNCE\t0xf0\n\nstruct nct6775_sio_data {\n\tint sioreg;\n\tint ld;\n\tenum kinds kind;\n\tenum sensor_access access;\n\n\t \n\tvoid (*sio_outb)(struct nct6775_sio_data *sio_data, int reg, int val);\n\tint (*sio_inb)(struct nct6775_sio_data *sio_data, int reg);\n\tvoid (*sio_select)(struct nct6775_sio_data *sio_data, int ld);\n\tint (*sio_enter)(struct nct6775_sio_data *sio_data);\n\tvoid (*sio_exit)(struct nct6775_sio_data *sio_data);\n};\n\n#define ASUSWMI_METHOD\t\t\t\"WMBD\"\n#define ASUSWMI_METHODID_RSIO\t\t0x5253494F\n#define ASUSWMI_METHODID_WSIO\t\t0x5753494F\n#define ASUSWMI_METHODID_RHWM\t\t0x5248574D\n#define ASUSWMI_METHODID_WHWM\t\t0x5748574D\n#define ASUSWMI_UNSUPPORTED_METHOD\t0xFFFFFFFE\n#define ASUSWMI_DEVICE_HID\t\t\"PNP0C14\"\n#define ASUSWMI_DEVICE_UID\t\t\"ASUSWMI\"\n#define ASUSMSI_DEVICE_UID\t\t\"AsusMbSwInterface\"\n\n#if IS_ENABLED(CONFIG_ACPI)\n \nstatic struct acpi_device *asus_acpi_dev;\n#endif\n\nstatic int nct6775_asuswmi_evaluate_method(u32 method_id, u8 bank, u8 reg, u8 val, u32 *retval)\n{\n#if IS_ENABLED(CONFIG_ACPI)\n\tacpi_handle handle = acpi_device_handle(asus_acpi_dev);\n\tu32 args = bank | (reg << 8) | (val << 16);\n\tstruct acpi_object_list input;\n\tunion acpi_object params[3];\n\tunsigned long long result;\n\tacpi_status status;\n\n\tparams[0].type = ACPI_TYPE_INTEGER;\n\tparams[0].integer.value = 0;\n\tparams[1].type = ACPI_TYPE_INTEGER;\n\tparams[1].integer.value = method_id;\n\tparams[2].type = ACPI_TYPE_BUFFER;\n\tparams[2].buffer.length = sizeof(args);\n\tparams[2].buffer.pointer = (void *)&args;\n\tinput.count = 3;\n\tinput.pointer = params;\n\n\tstatus = acpi_evaluate_integer(handle, ASUSWMI_METHOD, &input, &result);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tif (retval)\n\t\t*retval = result;\n\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic inline int nct6775_asuswmi_write(u8 bank, u8 reg, u8 val)\n{\n\treturn nct6775_asuswmi_evaluate_method(ASUSWMI_METHODID_WHWM, bank,\n\t\t\t\t\t      reg, val, NULL);\n}\n\nstatic inline int nct6775_asuswmi_read(u8 bank, u8 reg, u8 *val)\n{\n\tu32 ret, tmp = 0;\n\n\tret = nct6775_asuswmi_evaluate_method(ASUSWMI_METHODID_RHWM, bank,\n\t\t\t\t\t      reg, 0, &tmp);\n\t*val = tmp;\n\treturn ret;\n}\n\nstatic int superio_wmi_inb(struct nct6775_sio_data *sio_data, int reg)\n{\n\tint tmp = 0;\n\n\tnct6775_asuswmi_evaluate_method(ASUSWMI_METHODID_RSIO, sio_data->ld,\n\t\t\t\t\treg, 0, &tmp);\n\treturn tmp;\n}\n\nstatic void superio_wmi_outb(struct nct6775_sio_data *sio_data, int reg, int val)\n{\n\tnct6775_asuswmi_evaluate_method(ASUSWMI_METHODID_WSIO, sio_data->ld,\n\t\t\t\t\treg, val, NULL);\n}\n\nstatic void superio_wmi_select(struct nct6775_sio_data *sio_data, int ld)\n{\n\tsio_data->ld = ld;\n}\n\nstatic int superio_wmi_enter(struct nct6775_sio_data *sio_data)\n{\n\treturn 0;\n}\n\nstatic void superio_wmi_exit(struct nct6775_sio_data *sio_data)\n{\n}\n\nstatic void superio_outb(struct nct6775_sio_data *sio_data, int reg, int val)\n{\n\tint ioreg = sio_data->sioreg;\n\n\toutb(reg, ioreg);\n\toutb(val, ioreg + 1);\n}\n\nstatic int superio_inb(struct nct6775_sio_data *sio_data, int reg)\n{\n\tint ioreg = sio_data->sioreg;\n\n\toutb(reg, ioreg);\n\treturn inb(ioreg + 1);\n}\n\nstatic void superio_select(struct nct6775_sio_data *sio_data, int ld)\n{\n\tint ioreg = sio_data->sioreg;\n\n\toutb(SIO_REG_LDSEL, ioreg);\n\toutb(ld, ioreg + 1);\n}\n\nstatic int superio_enter(struct nct6775_sio_data *sio_data)\n{\n\tint ioreg = sio_data->sioreg;\n\n\t \n\tif (!request_muxed_region(ioreg, 2, DRVNAME))\n\t\treturn -EBUSY;\n\n\toutb(0x87, ioreg);\n\toutb(0x87, ioreg);\n\n\treturn 0;\n}\n\nstatic void superio_exit(struct nct6775_sio_data *sio_data)\n{\n\tint ioreg = sio_data->sioreg;\n\n\toutb(0xaa, ioreg);\n\toutb(0x02, ioreg);\n\toutb(0x02, ioreg + 1);\n\trelease_region(ioreg, 2);\n}\n\nstatic inline void nct6775_wmi_set_bank(struct nct6775_data *data, u16 reg)\n{\n\tu8 bank = reg >> 8;\n\n\tdata->bank = bank;\n}\n\nstatic int nct6775_wmi_reg_read(void *ctx, unsigned int reg, unsigned int *val)\n{\n\tstruct nct6775_data *data = ctx;\n\tint err, word_sized = nct6775_reg_is_word_sized(data, reg);\n\tu8 tmp = 0;\n\tu16 res;\n\n\tnct6775_wmi_set_bank(data, reg);\n\n\terr = nct6775_asuswmi_read(data->bank, reg & 0xff, &tmp);\n\tif (err)\n\t\treturn err;\n\n\tres = tmp;\n\tif (word_sized) {\n\t\terr = nct6775_asuswmi_read(data->bank, (reg & 0xff) + 1, &tmp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tres = (res << 8) + tmp;\n\t}\n\t*val = res;\n\treturn 0;\n}\n\nstatic int nct6775_wmi_reg_write(void *ctx, unsigned int reg, unsigned int value)\n{\n\tstruct nct6775_data *data = ctx;\n\tint res, word_sized = nct6775_reg_is_word_sized(data, reg);\n\n\tnct6775_wmi_set_bank(data, reg);\n\n\tif (word_sized) {\n\t\tres = nct6775_asuswmi_write(data->bank, reg & 0xff, value >> 8);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tres = nct6775_asuswmi_write(data->bank, (reg & 0xff) + 1, value);\n\t} else {\n\t\tres = nct6775_asuswmi_write(data->bank, reg & 0xff, value);\n\t}\n\n\treturn res;\n}\n\n \nstatic inline void nct6775_set_bank(struct nct6775_data *data, u16 reg)\n{\n\tu8 bank = reg >> 8;\n\n\tif (data->bank != bank) {\n\t\toutb_p(NCT6775_REG_BANK, data->addr + ADDR_REG_OFFSET);\n\t\toutb_p(bank, data->addr + DATA_REG_OFFSET);\n\t\tdata->bank = bank;\n\t}\n}\n\nstatic int nct6775_reg_read(void *ctx, unsigned int reg, unsigned int *val)\n{\n\tstruct nct6775_data *data = ctx;\n\tint word_sized = nct6775_reg_is_word_sized(data, reg);\n\n\tnct6775_set_bank(data, reg);\n\toutb_p(reg & 0xff, data->addr + ADDR_REG_OFFSET);\n\t*val = inb_p(data->addr + DATA_REG_OFFSET);\n\tif (word_sized) {\n\t\toutb_p((reg & 0xff) + 1,\n\t\t       data->addr + ADDR_REG_OFFSET);\n\t\t*val = (*val << 8) + inb_p(data->addr + DATA_REG_OFFSET);\n\t}\n\treturn 0;\n}\n\nstatic int nct6775_reg_write(void *ctx, unsigned int reg, unsigned int value)\n{\n\tstruct nct6775_data *data = ctx;\n\tint word_sized = nct6775_reg_is_word_sized(data, reg);\n\n\tnct6775_set_bank(data, reg);\n\toutb_p(reg & 0xff, data->addr + ADDR_REG_OFFSET);\n\tif (word_sized) {\n\t\toutb_p(value >> 8, data->addr + DATA_REG_OFFSET);\n\t\toutb_p((reg & 0xff) + 1,\n\t\t       data->addr + ADDR_REG_OFFSET);\n\t}\n\toutb_p(value & 0xff, data->addr + DATA_REG_OFFSET);\n\treturn 0;\n}\n\nstatic void nct6791_enable_io_mapping(struct nct6775_sio_data *sio_data)\n{\n\tint val;\n\n\tval = sio_data->sio_inb(sio_data, NCT6791_REG_HM_IO_SPACE_LOCK_ENABLE);\n\tif (val & 0x10) {\n\t\tpr_info(\"Enabling hardware monitor logical device mappings.\\n\");\n\t\tsio_data->sio_outb(sio_data, NCT6791_REG_HM_IO_SPACE_LOCK_ENABLE,\n\t\t\t       val & ~0x10);\n\t}\n}\n\nstatic int nct6775_suspend(struct device *dev)\n{\n\tint err;\n\tu16 tmp;\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmutex_lock(&data->update_lock);\n\terr = nct6775_read_value(data, data->REG_VBAT, &tmp);\n\tif (err)\n\t\tgoto out;\n\tdata->vbat = tmp;\n\tif (data->kind == nct6775) {\n\t\terr = nct6775_read_value(data, NCT6775_REG_FANDIV1, &tmp);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tdata->fandiv1 = tmp;\n\n\t\terr = nct6775_read_value(data, NCT6775_REG_FANDIV2, &tmp);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tdata->fandiv2 = tmp;\n\t}\nout:\n\tmutex_unlock(&data->update_lock);\n\n\treturn err;\n}\n\nstatic int nct6775_resume(struct device *dev)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct nct6775_sio_data *sio_data = dev_get_platdata(dev);\n\tint i, j, err = 0;\n\tu8 reg;\n\n\tmutex_lock(&data->update_lock);\n\tdata->bank = 0xff;\t\t \n\n\terr = sio_data->sio_enter(sio_data);\n\tif (err)\n\t\tgoto abort;\n\n\tsio_data->sio_select(sio_data, NCT6775_LD_HWM);\n\treg = sio_data->sio_inb(sio_data, SIO_REG_ENABLE);\n\tif (reg != data->sio_reg_enable)\n\t\tsio_data->sio_outb(sio_data, SIO_REG_ENABLE, data->sio_reg_enable);\n\n\tif (data->kind == nct6791 || data->kind == nct6792 ||\n\t    data->kind == nct6793 || data->kind == nct6795 ||\n\t    data->kind == nct6796 || data->kind == nct6797 ||\n\t    data->kind == nct6798 || data->kind == nct6799)\n\t\tnct6791_enable_io_mapping(sio_data);\n\n\tsio_data->sio_exit(sio_data);\n\n\t \n\tfor (i = 0; i < data->in_num; i++) {\n\t\tif (!(data->have_in & BIT(i)))\n\t\t\tcontinue;\n\n\t\terr = nct6775_write_value(data, data->REG_IN_MINMAX[0][i], data->in[i][1]);\n\t\tif (err)\n\t\t\tgoto abort;\n\t\terr = nct6775_write_value(data, data->REG_IN_MINMAX[1][i], data->in[i][2]);\n\t\tif (err)\n\t\t\tgoto abort;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data->fan_min); i++) {\n\t\tif (!(data->has_fan_min & BIT(i)))\n\t\t\tcontinue;\n\n\t\terr = nct6775_write_value(data, data->REG_FAN_MIN[i], data->fan_min[i]);\n\t\tif (err)\n\t\t\tgoto abort;\n\t}\n\n\tfor (i = 0; i < NUM_TEMP; i++) {\n\t\tif (!(data->have_temp & BIT(i)))\n\t\t\tcontinue;\n\n\t\tfor (j = 1; j < ARRAY_SIZE(data->reg_temp); j++)\n\t\t\tif (data->reg_temp[j][i]) {\n\t\t\t\terr = nct6775_write_temp(data, data->reg_temp[j][i],\n\t\t\t\t\t\t\t data->temp[j][i]);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto abort;\n\t\t\t}\n\t}\n\n\t \n\terr = nct6775_write_value(data, data->REG_VBAT, data->vbat);\n\tif (err)\n\t\tgoto abort;\n\tif (data->kind == nct6775) {\n\t\terr = nct6775_write_value(data, NCT6775_REG_FANDIV1, data->fandiv1);\n\t\tif (err)\n\t\t\tgoto abort;\n\t\terr = nct6775_write_value(data, NCT6775_REG_FANDIV2, data->fandiv2);\n\t}\n\nabort:\n\t \n\tdata->valid = false;\n\tmutex_unlock(&data->update_lock);\n\n\treturn err;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(nct6775_dev_pm_ops, nct6775_suspend, nct6775_resume);\n\nstatic void\nnct6775_check_fan_inputs(struct nct6775_data *data, struct nct6775_sio_data *sio_data)\n{\n\tbool fan3pin = false, fan4pin = false, fan4min = false;\n\tbool fan5pin = false, fan6pin = false, fan7pin = false;\n\tbool pwm3pin = false, pwm4pin = false, pwm5pin = false;\n\tbool pwm6pin = false, pwm7pin = false;\n\n\t \n\tsio_data->sio_select(sio_data, NCT6775_LD_HWM);\n\tdata->sio_reg_enable = sio_data->sio_inb(sio_data, SIO_REG_ENABLE);\n\n\t \n\tif (data->kind == nct6775) {\n\t\tint cr2c = sio_data->sio_inb(sio_data, 0x2c);\n\n\t\tfan3pin = cr2c & BIT(6);\n\t\tpwm3pin = cr2c & BIT(7);\n\n\t\t \n\t\tfan4pin = !(sio_data->sio_inb(sio_data, 0x2A) & 0x80);\n\t} else if (data->kind == nct6776) {\n\t\tbool gpok = sio_data->sio_inb(sio_data, 0x27) & 0x80;\n\t\tconst char *board_vendor, *board_name;\n\n\t\tboard_vendor = dmi_get_system_info(DMI_BOARD_VENDOR);\n\t\tboard_name = dmi_get_system_info(DMI_BOARD_NAME);\n\n\t\tif (board_name && board_vendor &&\n\t\t    !strcmp(board_vendor, \"ASRock\")) {\n\t\t\t \n\t\t\tif (!strcmp(board_name, \"Z77 Pro4-M\")) {\n\t\t\t\tif ((data->sio_reg_enable & 0xe0) != 0xe0) {\n\t\t\t\t\tdata->sio_reg_enable |= 0xe0;\n\t\t\t\t\tsio_data->sio_outb(sio_data, SIO_REG_ENABLE,\n\t\t\t\t\t\t     data->sio_reg_enable);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (data->sio_reg_enable & 0x80)\n\t\t\tfan3pin = gpok;\n\t\telse\n\t\t\tfan3pin = !(sio_data->sio_inb(sio_data, 0x24) & 0x40);\n\n\t\tif (data->sio_reg_enable & 0x40)\n\t\t\tfan4pin = gpok;\n\t\telse\n\t\t\tfan4pin = sio_data->sio_inb(sio_data, 0x1C) & 0x01;\n\n\t\tif (data->sio_reg_enable & 0x20)\n\t\t\tfan5pin = gpok;\n\t\telse\n\t\t\tfan5pin = sio_data->sio_inb(sio_data, 0x1C) & 0x02;\n\n\t\tfan4min = fan4pin;\n\t\tpwm3pin = fan3pin;\n\t} else if (data->kind == nct6106) {\n\t\tint cr24 = sio_data->sio_inb(sio_data, 0x24);\n\n\t\tfan3pin = !(cr24 & 0x80);\n\t\tpwm3pin = cr24 & 0x08;\n\t} else if (data->kind == nct6116) {\n\t\tint cr1a = sio_data->sio_inb(sio_data, 0x1a);\n\t\tint cr1b = sio_data->sio_inb(sio_data, 0x1b);\n\t\tint cr24 = sio_data->sio_inb(sio_data, 0x24);\n\t\tint cr2a = sio_data->sio_inb(sio_data, 0x2a);\n\t\tint cr2b = sio_data->sio_inb(sio_data, 0x2b);\n\t\tint cr2f = sio_data->sio_inb(sio_data, 0x2f);\n\n\t\tfan3pin = !(cr2b & 0x10);\n\t\tfan4pin = (cr2b & 0x80) ||\t\t\t\n\t\t\t(!(cr2f & 0x10) && (cr1a & 0x04));\t\n\t\tfan5pin = (cr2b & 0x80) ||\t\t\t\n\t\t\t(!(cr1b & 0x03) && (cr2a & 0x02));\t\n\n\t\tpwm3pin = fan3pin && (cr24 & 0x08);\n\t\tpwm4pin = fan4pin;\n\t\tpwm5pin = fan5pin;\n\t} else {\n\t\t \n\t\tint cr1a = sio_data->sio_inb(sio_data, 0x1a);\n\t\tint cr1b = sio_data->sio_inb(sio_data, 0x1b);\n\t\tint cr1c = sio_data->sio_inb(sio_data, 0x1c);\n\t\tint cr1d = sio_data->sio_inb(sio_data, 0x1d);\n\t\tint cr2a = sio_data->sio_inb(sio_data, 0x2a);\n\t\tint cr2b = sio_data->sio_inb(sio_data, 0x2b);\n\t\tint cr2d = sio_data->sio_inb(sio_data, 0x2d);\n\t\tint cr2f = sio_data->sio_inb(sio_data, 0x2f);\n\t\tbool vsb_ctl_en = cr2f & BIT(0);\n\t\tbool dsw_en = cr2f & BIT(3);\n\t\tbool ddr4_en = cr2f & BIT(4);\n\t\tbool as_seq1_en = cr2f & BIT(7);\n\t\tint cre0;\n\t\tint cre6;\n\t\tint creb;\n\t\tint cred;\n\n\t\tcre6 = sio_data->sio_inb(sio_data, 0xe6);\n\n\t\tsio_data->sio_select(sio_data, NCT6775_LD_12);\n\t\tcre0 = sio_data->sio_inb(sio_data, 0xe0);\n\t\tcreb = sio_data->sio_inb(sio_data, 0xeb);\n\t\tcred = sio_data->sio_inb(sio_data, 0xed);\n\n\t\tfan3pin = !(cr1c & BIT(5));\n\t\tfan4pin = !(cr1c & BIT(6));\n\t\tfan5pin = !(cr1c & BIT(7));\n\n\t\tpwm3pin = !(cr1c & BIT(0));\n\t\tpwm4pin = !(cr1c & BIT(1));\n\t\tpwm5pin = !(cr1c & BIT(2));\n\n\t\tswitch (data->kind) {\n\t\tcase nct6791:\n\t\t\tfan6pin = cr2d & BIT(1);\n\t\t\tpwm6pin = cr2d & BIT(0);\n\t\t\tbreak;\n\t\tcase nct6792:\n\t\t\tfan6pin = !dsw_en && (cr2d & BIT(1));\n\t\t\tpwm6pin = !dsw_en && (cr2d & BIT(0));\n\t\t\tbreak;\n\t\tcase nct6793:\n\t\t\tfan5pin |= cr1b & BIT(5);\n\t\t\tfan5pin |= creb & BIT(5);\n\n\t\t\tfan6pin = !dsw_en && (cr2d & BIT(1));\n\t\t\tfan6pin |= creb & BIT(3);\n\n\t\t\tpwm5pin |= cr2d & BIT(7);\n\t\t\tpwm5pin |= (creb & BIT(4)) && !(cr2a & BIT(0));\n\n\t\t\tpwm6pin = !dsw_en && (cr2d & BIT(0));\n\t\t\tpwm6pin |= creb & BIT(2);\n\t\t\tbreak;\n\t\tcase nct6795:\n\t\t\tfan5pin |= cr1b & BIT(5);\n\t\t\tfan5pin |= creb & BIT(5);\n\n\t\t\tfan6pin = (cr2a & BIT(4)) &&\n\t\t\t\t\t(!dsw_en || (cred & BIT(4)));\n\t\t\tfan6pin |= creb & BIT(3);\n\n\t\t\tpwm5pin |= cr2d & BIT(7);\n\t\t\tpwm5pin |= (creb & BIT(4)) && !(cr2a & BIT(0));\n\n\t\t\tpwm6pin = (cr2a & BIT(3)) && (cred & BIT(2));\n\t\t\tpwm6pin |= creb & BIT(2);\n\t\t\tbreak;\n\t\tcase nct6796:\n\t\t\tfan5pin |= cr1b & BIT(5);\n\t\t\tfan5pin |= (cre0 & BIT(3)) && !(cr1b & BIT(0));\n\t\t\tfan5pin |= creb & BIT(5);\n\n\t\t\tfan6pin = (cr2a & BIT(4)) &&\n\t\t\t\t\t(!dsw_en || (cred & BIT(4)));\n\t\t\tfan6pin |= creb & BIT(3);\n\n\t\t\tfan7pin = !(cr2b & BIT(2));\n\n\t\t\tpwm5pin |= cr2d & BIT(7);\n\t\t\tpwm5pin |= (cre0 & BIT(4)) && !(cr1b & BIT(0));\n\t\t\tpwm5pin |= (creb & BIT(4)) && !(cr2a & BIT(0));\n\n\t\t\tpwm6pin = (cr2a & BIT(3)) && (cred & BIT(2));\n\t\t\tpwm6pin |= creb & BIT(2);\n\n\t\t\tpwm7pin = !(cr1d & (BIT(2) | BIT(3)));\n\t\t\tbreak;\n\t\tcase nct6797:\n\t\t\tfan5pin |= !ddr4_en && (cr1b & BIT(5));\n\t\t\tfan5pin |= creb & BIT(5);\n\n\t\t\tfan6pin = cr2a & BIT(4);\n\t\t\tfan6pin |= creb & BIT(3);\n\n\t\t\tfan7pin = cr1a & BIT(1);\n\n\t\t\tpwm5pin |= (creb & BIT(4)) && !(cr2a & BIT(0));\n\t\t\tpwm5pin |= !ddr4_en && (cr2d & BIT(7));\n\n\t\t\tpwm6pin = creb & BIT(2);\n\t\t\tpwm6pin |= cred & BIT(2);\n\n\t\t\tpwm7pin = cr1d & BIT(4);\n\t\t\tbreak;\n\t\tcase nct6798:\n\t\t\tfan6pin = !(cr1b & BIT(0)) && (cre0 & BIT(3));\n\t\t\tfan6pin |= cr2a & BIT(4);\n\t\t\tfan6pin |= creb & BIT(5);\n\n\t\t\tfan7pin = cr1b & BIT(5);\n\t\t\tfan7pin |= !(cr2b & BIT(2));\n\t\t\tfan7pin |= creb & BIT(3);\n\n\t\t\tpwm6pin = !(cr1b & BIT(0)) && (cre0 & BIT(4));\n\t\t\tpwm6pin |= !(cred & BIT(2)) && (cr2a & BIT(3));\n\t\t\tpwm6pin |= (creb & BIT(4)) && !(cr2a & BIT(0));\n\n\t\t\tpwm7pin = !(cr1d & (BIT(2) | BIT(3)));\n\t\t\tpwm7pin |= cr2d & BIT(7);\n\t\t\tpwm7pin |= creb & BIT(2);\n\t\t\tbreak;\n\t\tcase nct6799:\n\t\t\tfan4pin = cr1c & BIT(6);\n\t\t\tfan5pin = cr1c & BIT(7);\n\n\t\t\tfan6pin = !(cr1b & BIT(0)) && (cre0 & BIT(3));\n\t\t\tfan6pin |= cre6 & BIT(5);\n\t\t\tfan6pin |= creb & BIT(5);\n\t\t\tfan6pin |= !as_seq1_en && (cr2a & BIT(4));\n\n\t\t\tfan7pin = cr1b & BIT(5);\n\t\t\tfan7pin |= !vsb_ctl_en && !(cr2b & BIT(2));\n\t\t\tfan7pin |= creb & BIT(3);\n\n\t\t\tpwm6pin = !(cr1b & BIT(0)) && (cre0 & BIT(4));\n\t\t\tpwm6pin |= !as_seq1_en && !(cred & BIT(2)) && (cr2a & BIT(3));\n\t\t\tpwm6pin |= (creb & BIT(4)) && !(cr2a & BIT(0));\n\t\t\tpwm6pin |= cre6 & BIT(3);\n\n\t\t\tpwm7pin = !vsb_ctl_en && !(cr1d & (BIT(2) | BIT(3)));\n\t\t\tpwm7pin |= creb & BIT(2);\n\t\t\tpwm7pin |= cr2d & BIT(7);\n\n\t\t\tbreak;\n\t\tdefault:\t \n\t\t\tbreak;\n\t\t}\n\n\t\tfan4min = fan4pin;\n\t}\n\n\t \n\tdata->has_fan = 0x03 | (fan3pin << 2) | (fan4pin << 3) |\n\t\t(fan5pin << 4) | (fan6pin << 5) | (fan7pin << 6);\n\tdata->has_fan_min = 0x03 | (fan3pin << 2) | (fan4min << 3) |\n\t\t(fan5pin << 4) | (fan6pin << 5) | (fan7pin << 6);\n\tdata->has_pwm = 0x03 | (pwm3pin << 2) | (pwm4pin << 3) |\n\t\t(pwm5pin << 4) | (pwm6pin << 5) | (pwm7pin << 6);\n}\n\nstatic ssize_t\ncpu0_vid_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", vid_from_reg(data->vid, data->vrm));\n}\n\nstatic DEVICE_ATTR_RO(cpu0_vid);\n\n \n\nstatic const u8 NCT6775_REG_CR_CASEOPEN_CLR[] = { 0xe6, 0xee };\nstatic const u8 NCT6775_CR_CASEOPEN_CLR_MASK[] = { 0x20, 0x01 };\n\nstatic ssize_t\nclear_caseopen(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct nct6775_sio_data *sio_data = data->driver_data;\n\tint nr = to_sensor_dev_attr(attr)->index - INTRUSION_ALARM_BASE;\n\tunsigned long val;\n\tu8 reg;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val) || val != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tret = sio_data->sio_enter(sio_data);\n\tif (ret) {\n\t\tcount = ret;\n\t\tgoto error;\n\t}\n\n\tsio_data->sio_select(sio_data, NCT6775_LD_ACPI);\n\treg = sio_data->sio_inb(sio_data, NCT6775_REG_CR_CASEOPEN_CLR[nr]);\n\treg |= NCT6775_CR_CASEOPEN_CLR_MASK[nr];\n\tsio_data->sio_outb(sio_data, NCT6775_REG_CR_CASEOPEN_CLR[nr], reg);\n\treg &= ~NCT6775_CR_CASEOPEN_CLR_MASK[nr];\n\tsio_data->sio_outb(sio_data, NCT6775_REG_CR_CASEOPEN_CLR[nr], reg);\n\tsio_data->sio_exit(sio_data);\n\n\tdata->valid = false;\t \nerror:\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR(intrusion0_alarm, 0644, nct6775_show_alarm,\n\t\t\t  clear_caseopen, INTRUSION_ALARM_BASE);\nstatic SENSOR_DEVICE_ATTR(intrusion1_alarm, 0644, nct6775_show_alarm,\n\t\t\t  clear_caseopen, INTRUSION_ALARM_BASE + 1);\nstatic SENSOR_DEVICE_ATTR(intrusion0_beep, 0644, nct6775_show_beep,\n\t\t\t  nct6775_store_beep, INTRUSION_ALARM_BASE);\nstatic SENSOR_DEVICE_ATTR(intrusion1_beep, 0644, nct6775_show_beep,\n\t\t\t  nct6775_store_beep, INTRUSION_ALARM_BASE + 1);\nstatic SENSOR_DEVICE_ATTR(beep_enable, 0644, nct6775_show_beep,\n\t\t\t  nct6775_store_beep, BEEP_ENABLE_BASE);\n\nstatic umode_t nct6775_other_is_visible(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\n\tif (index == 0 && !data->have_vid)\n\t\treturn 0;\n\n\tif (index == 1 || index == 2) {\n\t\tif (data->ALARM_BITS[INTRUSION_ALARM_BASE + index - 1] < 0)\n\t\t\treturn 0;\n\t}\n\n\tif (index == 3 || index == 4) {\n\t\tif (data->BEEP_BITS[INTRUSION_ALARM_BASE + index - 3] < 0)\n\t\t\treturn 0;\n\t}\n\n\treturn nct6775_attr_mode(data, attr);\n}\n\n \nstatic struct attribute *nct6775_attributes_other[] = {\n\t&dev_attr_cpu0_vid.attr,\t\t\t\t \n\t&sensor_dev_attr_intrusion0_alarm.dev_attr.attr,\t \n\t&sensor_dev_attr_intrusion1_alarm.dev_attr.attr,\t \n\t&sensor_dev_attr_intrusion0_beep.dev_attr.attr,\t\t \n\t&sensor_dev_attr_intrusion1_beep.dev_attr.attr,\t\t \n\t&sensor_dev_attr_beep_enable.dev_attr.attr,\t\t \n\n\tNULL\n};\n\nstatic const struct attribute_group nct6775_group_other = {\n\t.attrs = nct6775_attributes_other,\n\t.is_visible = nct6775_other_is_visible,\n};\n\nstatic int nct6775_platform_probe_init(struct nct6775_data *data)\n{\n\tint err;\n\tu8 cr2a;\n\tstruct nct6775_sio_data *sio_data = data->driver_data;\n\n\terr = sio_data->sio_enter(sio_data);\n\tif (err)\n\t\treturn err;\n\n\tcr2a = sio_data->sio_inb(sio_data, 0x2a);\n\tswitch (data->kind) {\n\tcase nct6775:\n\t\tdata->have_vid = (cr2a & 0x40);\n\t\tbreak;\n\tcase nct6776:\n\t\tdata->have_vid = (cr2a & 0x60) == 0x40;\n\t\tbreak;\n\tcase nct6106:\n\tcase nct6116:\n\tcase nct6779:\n\tcase nct6791:\n\tcase nct6792:\n\tcase nct6793:\n\tcase nct6795:\n\tcase nct6796:\n\tcase nct6797:\n\tcase nct6798:\n\tcase nct6799:\n\t\tbreak;\n\t}\n\n\t \n\tif (data->have_vid) {\n\t\tsio_data->sio_select(sio_data, NCT6775_LD_VID);\n\t\tdata->vid = sio_data->sio_inb(sio_data, 0xe3);\n\t\tdata->vrm = vid_which_vrm();\n\t}\n\n\tif (fan_debounce) {\n\t\tu8 tmp;\n\n\t\tsio_data->sio_select(sio_data, NCT6775_LD_HWM);\n\t\ttmp = sio_data->sio_inb(sio_data,\n\t\t\t\t    NCT6775_REG_CR_FAN_DEBOUNCE);\n\t\tswitch (data->kind) {\n\t\tcase nct6106:\n\t\tcase nct6116:\n\t\t\ttmp |= 0xe0;\n\t\t\tbreak;\n\t\tcase nct6775:\n\t\t\ttmp |= 0x1e;\n\t\t\tbreak;\n\t\tcase nct6776:\n\t\tcase nct6779:\n\t\t\ttmp |= 0x3e;\n\t\t\tbreak;\n\t\tcase nct6791:\n\t\tcase nct6792:\n\t\tcase nct6793:\n\t\tcase nct6795:\n\t\tcase nct6796:\n\t\tcase nct6797:\n\t\tcase nct6798:\n\t\tcase nct6799:\n\t\t\ttmp |= 0x7e;\n\t\t\tbreak;\n\t\t}\n\t\tsio_data->sio_outb(sio_data, NCT6775_REG_CR_FAN_DEBOUNCE,\n\t\t\t     tmp);\n\t\tpr_info(\"Enabled fan debounce for chip %s\\n\", data->name);\n\t}\n\n\tnct6775_check_fan_inputs(data, sio_data);\n\n\tsio_data->sio_exit(sio_data);\n\n\treturn nct6775_add_attr_group(data, &nct6775_group_other);\n}\n\nstatic const struct regmap_config nct6775_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.reg_read = nct6775_reg_read,\n\t.reg_write = nct6775_reg_write,\n};\n\nstatic const struct regmap_config nct6775_wmi_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.reg_read = nct6775_wmi_reg_read,\n\t.reg_write = nct6775_wmi_reg_write,\n};\n\nstatic int nct6775_platform_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct nct6775_sio_data *sio_data = dev_get_platdata(dev);\n\tstruct nct6775_data *data;\n\tstruct resource *res;\n\tconst struct regmap_config *regmapcfg;\n\n\tif (sio_data->access == access_direct) {\n\t\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\t\tif (!devm_request_region(&pdev->dev, res->start, IOREGION_LENGTH, DRVNAME))\n\t\t\treturn -EBUSY;\n\t}\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->kind = sio_data->kind;\n\tdata->sioreg = sio_data->sioreg;\n\n\tif (sio_data->access == access_direct) {\n\t\tdata->addr = res->start;\n\t\tregmapcfg = &nct6775_regmap_config;\n\t} else {\n\t\tregmapcfg = &nct6775_wmi_regmap_config;\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\tdata->driver_data = sio_data;\n\tdata->driver_init = nct6775_platform_probe_init;\n\n\treturn nct6775_probe(&pdev->dev, data, regmapcfg);\n}\n\nstatic struct platform_driver nct6775_driver = {\n\t.driver = {\n\t\t.name\t= DRVNAME,\n\t\t.pm\t= pm_sleep_ptr(&nct6775_dev_pm_ops),\n\t},\n\t.probe\t\t= nct6775_platform_probe,\n};\n\n \nstatic int __init nct6775_find(int sioaddr, struct nct6775_sio_data *sio_data)\n{\n\tu16 val;\n\tint err;\n\tint addr;\n\n\tsio_data->access = access_direct;\n\tsio_data->sioreg = sioaddr;\n\n\terr = sio_data->sio_enter(sio_data);\n\tif (err)\n\t\treturn err;\n\n\tval = (sio_data->sio_inb(sio_data, SIO_REG_DEVID) << 8) |\n\t\tsio_data->sio_inb(sio_data, SIO_REG_DEVID + 1);\n\tif (force_id && val != 0xffff)\n\t\tval = force_id;\n\n\tswitch (val & SIO_ID_MASK) {\n\tcase SIO_NCT6106_ID:\n\t\tsio_data->kind = nct6106;\n\t\tbreak;\n\tcase SIO_NCT6116_ID:\n\t\tsio_data->kind = nct6116;\n\t\tbreak;\n\tcase SIO_NCT6775_ID:\n\t\tsio_data->kind = nct6775;\n\t\tbreak;\n\tcase SIO_NCT6776_ID:\n\t\tsio_data->kind = nct6776;\n\t\tbreak;\n\tcase SIO_NCT6779_ID:\n\t\tsio_data->kind = nct6779;\n\t\tbreak;\n\tcase SIO_NCT6791_ID:\n\t\tsio_data->kind = nct6791;\n\t\tbreak;\n\tcase SIO_NCT6792_ID:\n\t\tsio_data->kind = nct6792;\n\t\tbreak;\n\tcase SIO_NCT6793_ID:\n\t\tsio_data->kind = nct6793;\n\t\tbreak;\n\tcase SIO_NCT6795_ID:\n\t\tsio_data->kind = nct6795;\n\t\tbreak;\n\tcase SIO_NCT6796_ID:\n\t\tsio_data->kind = nct6796;\n\t\tbreak;\n\tcase SIO_NCT6797_ID:\n\t\tsio_data->kind = nct6797;\n\t\tbreak;\n\tcase SIO_NCT6798_ID:\n\t\tsio_data->kind = nct6798;\n\t\tbreak;\n\tcase SIO_NCT6799_ID:\n\t\tsio_data->kind = nct6799;\n\t\tbreak;\n\tdefault:\n\t\tif (val != 0xffff)\n\t\t\tpr_debug(\"unsupported chip ID: 0x%04x\\n\", val);\n\t\tsio_data->sio_exit(sio_data);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsio_data->sio_select(sio_data, NCT6775_LD_HWM);\n\tval = (sio_data->sio_inb(sio_data, SIO_REG_ADDR) << 8)\n\t    | sio_data->sio_inb(sio_data, SIO_REG_ADDR + 1);\n\taddr = val & IOREGION_ALIGNMENT;\n\tif (addr == 0) {\n\t\tpr_err(\"Refusing to enable a Super-I/O device with a base I/O port 0\\n\");\n\t\tsio_data->sio_exit(sio_data);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tval = sio_data->sio_inb(sio_data, SIO_REG_ENABLE);\n\tif (!(val & 0x01)) {\n\t\tpr_warn(\"Forcibly enabling Super-I/O. Sensor is probably unusable.\\n\");\n\t\tsio_data->sio_outb(sio_data, SIO_REG_ENABLE, val | 0x01);\n\t}\n\n\tif (sio_data->kind == nct6791 || sio_data->kind == nct6792 ||\n\t    sio_data->kind == nct6793 || sio_data->kind == nct6795 ||\n\t    sio_data->kind == nct6796 || sio_data->kind == nct6797 ||\n\t    sio_data->kind == nct6798 || sio_data->kind == nct6799)\n\t\tnct6791_enable_io_mapping(sio_data);\n\n\tsio_data->sio_exit(sio_data);\n\tpr_info(\"Found %s or compatible chip at %#x:%#x\\n\",\n\t\tnct6775_sio_names[sio_data->kind], sioaddr, addr);\n\n\treturn addr;\n}\n\n \nstatic struct platform_device *pdev[2];\n\nstatic const char * const asus_wmi_boards[] = {\n\t\"B360M-BASALT\",\n\t\"B360M-D3H\",\n\t\"EX-B360M-V\",\n\t\"EX-B360M-V3\",\n\t\"EX-B360M-V5\",\n\t\"EX-B460M-V5\",\n\t\"EX-H410M-V3\",\n\t\"PRIME A520M-A\",\n\t\"PRIME A520M-A II\",\n\t\"PRIME A520M-E\",\n\t\"PRIME A520M-K\",\n\t\"PRIME B360-PLUS\",\n\t\"PRIME B360M-A\",\n\t\"PRIME B360M-C\",\n\t\"PRIME B360M-D\",\n\t\"PRIME B360M-K\",\n\t\"PRIME B460-PLUS\",\n\t\"PRIME B460I-PLUS\",\n\t\"PRIME B460M-A\",\n\t\"PRIME B460M-A R2.0\",\n\t\"PRIME B460M-K\",\n\t\"PRIME B550-PLUS\",\n\t\"PRIME B550-PLUS AC-HES\",\n\t\"PRIME B550M-A\",\n\t\"PRIME B550M-A (WI-FI)\",\n\t\"PRIME B550M-A AC\",\n\t\"PRIME B550M-A WIFI II\",\n\t\"PRIME B550M-K\",\n\t\"PRIME H310-PLUS\",\n\t\"PRIME H310I-PLUS\",\n\t\"PRIME H310M-A\",\n\t\"PRIME H310M-C\",\n\t\"PRIME H310M-D\",\n\t\"PRIME H310M-DASH\",\n\t\"PRIME H310M-E\",\n\t\"PRIME H310M-E/BR\",\n\t\"PRIME H310M-F\",\n\t\"PRIME H310M-K\",\n\t\"PRIME H310T\",\n\t\"PRIME H370-A\",\n\t\"PRIME H370-PLUS\",\n\t\"PRIME H370M-PLUS\",\n\t\"PRIME H410I-PLUS\",\n\t\"PRIME H410M-A\",\n\t\"PRIME H410M-D\",\n\t\"PRIME H410M-E\",\n\t\"PRIME H410M-F\",\n\t\"PRIME H410M-K\",\n\t\"PRIME H410M-K R2.0\",\n\t\"PRIME H410M-R\",\n\t\"PRIME H470-PLUS\",\n\t\"PRIME H470M-PLUS\",\n\t\"PRIME H510M-K R2.0\",\n\t\"PRIME Q370M-C\",\n\t\"PRIME X570-P\",\n\t\"PRIME X570-PRO\",\n\t\"PRIME Z390-A\",\n\t\"PRIME Z390-A/H10\",\n\t\"PRIME Z390-P\",\n\t\"PRIME Z390M-PLUS\",\n\t\"PRIME Z490-A\",\n\t\"PRIME Z490-P\",\n\t\"PRIME Z490-V\",\n\t\"PRIME Z490M-PLUS\",\n\t\"PRO B460M-C\",\n\t\"PRO H410M-C\",\n\t\"PRO H410T\",\n\t\"PRO Q470M-C\",\n\t\"Pro A520M-C\",\n\t\"Pro A520M-C II\",\n\t\"Pro B550M-C\",\n\t\"Pro WS X570-ACE\",\n\t\"ProArt B550-CREATOR\",\n\t\"ProArt X570-CREATOR WIFI\",\n\t\"ProArt Z490-CREATOR 10G\",\n\t\"ROG CROSSHAIR VIII DARK HERO\",\n\t\"ROG CROSSHAIR VIII EXTREME\",\n\t\"ROG CROSSHAIR VIII FORMULA\",\n\t\"ROG CROSSHAIR VIII HERO\",\n\t\"ROG CROSSHAIR VIII HERO (WI-FI)\",\n\t\"ROG CROSSHAIR VIII IMPACT\",\n\t\"ROG MAXIMUS XI APEX\",\n\t\"ROG MAXIMUS XI CODE\",\n\t\"ROG MAXIMUS XI EXTREME\",\n\t\"ROG MAXIMUS XI FORMULA\",\n\t\"ROG MAXIMUS XI GENE\",\n\t\"ROG MAXIMUS XI HERO\",\n\t\"ROG MAXIMUS XI HERO (WI-FI)\",\n\t\"ROG MAXIMUS XII APEX\",\n\t\"ROG MAXIMUS XII EXTREME\",\n\t\"ROG MAXIMUS XII FORMULA\",\n\t\"ROG MAXIMUS XII HERO (WI-FI)\",\n\t\"ROG STRIX B360-F GAMING\",\n\t\"ROG STRIX B360-G GAMING\",\n\t\"ROG STRIX B360-H GAMING\",\n\t\"ROG STRIX B360-H GAMING/OPTANE\",\n\t\"ROG STRIX B360-I GAMING\",\n\t\"ROG STRIX B460-F GAMING\",\n\t\"ROG STRIX B460-G GAMING\",\n\t\"ROG STRIX B460-H GAMING\",\n\t\"ROG STRIX B460-I GAMING\",\n\t\"ROG STRIX B550-A GAMING\",\n\t\"ROG STRIX B550-E GAMING\",\n\t\"ROG STRIX B550-F GAMING\",\n\t\"ROG STRIX B550-F GAMING (WI-FI)\",\n\t\"ROG STRIX B550-F GAMING WIFI II\",\n\t\"ROG STRIX B550-I GAMING\",\n\t\"ROG STRIX B550-XE GAMING WIFI\",\n\t\"ROG STRIX H370-F GAMING\",\n\t\"ROG STRIX H370-I GAMING\",\n\t\"ROG STRIX H470-I GAMING\",\n\t\"ROG STRIX X570-E GAMING\",\n\t\"ROG STRIX X570-E GAMING WIFI II\",\n\t\"ROG STRIX X570-F GAMING\",\n\t\"ROG STRIX X570-I GAMING\",\n\t\"ROG STRIX Z390-E GAMING\",\n\t\"ROG STRIX Z390-F GAMING\",\n\t\"ROG STRIX Z390-H GAMING\",\n\t\"ROG STRIX Z390-I GAMING\",\n\t\"ROG STRIX Z490-A GAMING\",\n\t\"ROG STRIX Z490-E GAMING\",\n\t\"ROG STRIX Z490-F GAMING\",\n\t\"ROG STRIX Z490-G GAMING\",\n\t\"ROG STRIX Z490-G GAMING (WI-FI)\",\n\t\"ROG STRIX Z490-H GAMING\",\n\t\"ROG STRIX Z490-I GAMING\",\n\t\"TUF B360-PLUS GAMING\",\n\t\"TUF B360-PRO GAMING\",\n\t\"TUF B360-PRO GAMING (WI-FI)\",\n\t\"TUF B360M-E GAMING\",\n\t\"TUF B360M-PLUS GAMING\",\n\t\"TUF B360M-PLUS GAMING S\",\n\t\"TUF B360M-PLUS GAMING/BR\",\n\t\"TUF GAMING A520M-PLUS\",\n\t\"TUF GAMING A520M-PLUS II\",\n\t\"TUF GAMING A520M-PLUS WIFI\",\n\t\"TUF GAMING B460-PLUS\",\n\t\"TUF GAMING B460-PRO (WI-FI)\",\n\t\"TUF GAMING B460M-PLUS\",\n\t\"TUF GAMING B460M-PLUS (WI-FI)\",\n\t\"TUF GAMING B460M-PRO\",\n\t\"TUF GAMING B550-PLUS\",\n\t\"TUF GAMING B550-PLUS (WI-FI)\",\n\t\"TUF GAMING B550-PLUS WIFI II\",\n\t\"TUF GAMING B550-PRO\",\n\t\"TUF GAMING B550M ZAKU (WI-FI)\",\n\t\"TUF GAMING B550M-E\",\n\t\"TUF GAMING B550M-E WIFI\",\n\t\"TUF GAMING B550M-PLUS\",\n\t\"TUF GAMING B550M-PLUS (WI-FI)\",\n\t\"TUF GAMING B550M-PLUS WIFI II\",\n\t\"TUF GAMING H470-PRO\",\n\t\"TUF GAMING H470-PRO (WI-FI)\",\n\t\"TUF GAMING X570-PLUS\",\n\t\"TUF GAMING X570-PLUS (WI-FI)\",\n\t\"TUF GAMING X570-PLUS_BR\",\n\t\"TUF GAMING X570-PRO (WI-FI)\",\n\t\"TUF GAMING X570-PRO WIFI II\",\n\t\"TUF GAMING Z490-PLUS\",\n\t\"TUF GAMING Z490-PLUS (WI-FI)\",\n\t\"TUF H310-PLUS GAMING\",\n\t\"TUF H310M-PLUS GAMING\",\n\t\"TUF H310M-PLUS GAMING/BR\",\n\t\"TUF H370-PRO GAMING\",\n\t\"TUF H370-PRO GAMING (WI-FI)\",\n\t\"TUF Z390-PLUS GAMING\",\n\t\"TUF Z390-PLUS GAMING (WI-FI)\",\n\t\"TUF Z390-PRO GAMING\",\n\t\"TUF Z390M-PRO GAMING\",\n\t\"TUF Z390M-PRO GAMING (WI-FI)\",\n\t\"WS Z390 PRO\",\n\t\"Z490-GUNDAM (WI-FI)\",\n};\n\nstatic const char * const asus_msi_boards[] = {\n\t\"B560M-P\",\n\t\"EX-B560M-V5\",\n\t\"EX-B660M-V5 D4\",\n\t\"EX-B660M-V5 PRO D4\",\n\t\"EX-B760M-V5 D4\",\n\t\"EX-H510M-V3\",\n\t\"EX-H610M-V3 D4\",\n\t\"PRIME A620M-A\",\n\t\"PRIME B560-PLUS\",\n\t\"PRIME B560-PLUS AC-HES\",\n\t\"PRIME B560M-A\",\n\t\"PRIME B560M-A AC\",\n\t\"PRIME B560M-K\",\n\t\"PRIME B650-PLUS\",\n\t\"PRIME B650M-A\",\n\t\"PRIME B650M-A AX\",\n\t\"PRIME B650M-A AX II\",\n\t\"PRIME B650M-A II\",\n\t\"PRIME B650M-A WIFI\",\n\t\"PRIME B650M-A WIFI II\",\n\t\"PRIME B660-PLUS D4\",\n\t\"PRIME B660M-A AC D4\",\n\t\"PRIME B660M-A D4\",\n\t\"PRIME B660M-A WIFI D4\",\n\t\"PRIME B760-PLUS\",\n\t\"PRIME B760-PLUS D4\",\n\t\"PRIME B760M-A\",\n\t\"PRIME B760M-A AX D4\",\n\t\"PRIME B760M-A D4\",\n\t\"PRIME B760M-A WIFI\",\n\t\"PRIME B760M-A WIFI D4\",\n\t\"PRIME B760M-AJ D4\",\n\t\"PRIME B760M-K D4\",\n\t\"PRIME H510M-A\",\n\t\"PRIME H510M-A WIFI\",\n\t\"PRIME H510M-D\",\n\t\"PRIME H510M-E\",\n\t\"PRIME H510M-F\",\n\t\"PRIME H510M-K\",\n\t\"PRIME H510M-R\",\n\t\"PRIME H510T2/CSM\",\n\t\"PRIME H570-PLUS\",\n\t\"PRIME H570M-PLUS\",\n\t\"PRIME H610I-PLUS D4\",\n\t\"PRIME H610M-A D4\",\n\t\"PRIME H610M-A WIFI D4\",\n\t\"PRIME H610M-D D4\",\n\t\"PRIME H610M-E D4\",\n\t\"PRIME H610M-F D4\",\n\t\"PRIME H610M-K D4\",\n\t\"PRIME H610M-R D4\",\n\t\"PRIME H670-PLUS D4\",\n\t\"PRIME H770-PLUS D4\",\n\t\"PRIME X670-P\",\n\t\"PRIME X670-P WIFI\",\n\t\"PRIME X670E-PRO WIFI\",\n\t\"PRIME Z590-A\",\n\t\"PRIME Z590-P\",\n\t\"PRIME Z590-P WIFI\",\n\t\"PRIME Z590-V\",\n\t\"PRIME Z590M-PLUS\",\n\t\"PRIME Z690-A\",\n\t\"PRIME Z690-P\",\n\t\"PRIME Z690-P D4\",\n\t\"PRIME Z690-P WIFI\",\n\t\"PRIME Z690-P WIFI D4\",\n\t\"PRIME Z690M-PLUS D4\",\n\t\"PRIME Z790-A WIFI\",\n\t\"PRIME Z790-P\",\n\t\"PRIME Z790-P D4\",\n\t\"PRIME Z790-P WIFI\",\n\t\"PRIME Z790-P WIFI D4\",\n\t\"PRIME Z790M-PLUS\",\n\t\"PRIME Z790M-PLUS D4\",\n\t\"Pro B560M-C\",\n\t\"Pro B560M-CT\",\n\t\"Pro B660M-C\",\n\t\"Pro B660M-C D4\",\n\t\"Pro B760M-C\",\n\t\"Pro B760M-CT\",\n\t\"Pro H510M-C\",\n\t\"Pro H510M-CT\",\n\t\"Pro H610M-C\",\n\t\"Pro H610M-C D4\",\n\t\"Pro H610M-CT D4\",\n\t\"Pro H610T D4\",\n\t\"Pro Q670M-C\",\n\t\"Pro WS W680-ACE\",\n\t\"Pro WS W680-ACE IPMI\",\n\t\"Pro WS W790-ACE\",\n\t\"Pro WS W790E-SAGE SE\",\n\t\"ProArt B650-CREATOR\",\n\t\"ProArt B660-CREATOR D4\",\n\t\"ProArt B760-CREATOR D4\",\n\t\"ProArt X670E-CREATOR WIFI\",\n\t\"ProArt Z690-CREATOR WIFI\",\n\t\"ProArt Z790-CREATOR WIFI\",\n\t\"ROG CROSSHAIR X670E EXTREME\",\n\t\"ROG CROSSHAIR X670E GENE\",\n\t\"ROG CROSSHAIR X670E HERO\",\n\t\"ROG MAXIMUS XIII APEX\",\n\t\"ROG MAXIMUS XIII EXTREME\",\n\t\"ROG MAXIMUS XIII EXTREME GLACIAL\",\n\t\"ROG MAXIMUS XIII HERO\",\n\t\"ROG MAXIMUS Z690 APEX\",\n\t\"ROG MAXIMUS Z690 EXTREME\",\n\t\"ROG MAXIMUS Z690 EXTREME GLACIAL\",\n\t\"ROG MAXIMUS Z690 FORMULA\",\n\t\"ROG MAXIMUS Z690 HERO\",\n\t\"ROG MAXIMUS Z690 HERO EVA\",\n\t\"ROG MAXIMUS Z790 APEX\",\n\t\"ROG MAXIMUS Z790 EXTREME\",\n\t\"ROG MAXIMUS Z790 HERO\",\n\t\"ROG STRIX B560-A GAMING WIFI\",\n\t\"ROG STRIX B560-E GAMING WIFI\",\n\t\"ROG STRIX B560-F GAMING WIFI\",\n\t\"ROG STRIX B560-G GAMING WIFI\",\n\t\"ROG STRIX B560-I GAMING WIFI\",\n\t\"ROG STRIX B650-A GAMING WIFI\",\n\t\"ROG STRIX B650E-E GAMING WIFI\",\n\t\"ROG STRIX B650E-F GAMING WIFI\",\n\t\"ROG STRIX B650E-I GAMING WIFI\",\n\t\"ROG STRIX B660-A GAMING WIFI\",\n\t\"ROG STRIX B660-A GAMING WIFI D4\",\n\t\"ROG STRIX B660-F GAMING WIFI\",\n\t\"ROG STRIX B660-G GAMING WIFI\",\n\t\"ROG STRIX B660-I GAMING WIFI\",\n\t\"ROG STRIX B760-A GAMING WIFI\",\n\t\"ROG STRIX B760-A GAMING WIFI D4\",\n\t\"ROG STRIX B760-F GAMING WIFI\",\n\t\"ROG STRIX B760-G GAMING WIFI\",\n\t\"ROG STRIX B760-G GAMING WIFI D4\",\n\t\"ROG STRIX B760-I GAMING WIFI\",\n\t\"ROG STRIX X670E-A GAMING WIFI\",\n\t\"ROG STRIX X670E-E GAMING WIFI\",\n\t\"ROG STRIX X670E-F GAMING WIFI\",\n\t\"ROG STRIX X670E-I GAMING WIFI\",\n\t\"ROG STRIX Z590-A GAMING WIFI\",\n\t\"ROG STRIX Z590-A GAMING WIFI II\",\n\t\"ROG STRIX Z590-E GAMING WIFI\",\n\t\"ROG STRIX Z590-F GAMING WIFI\",\n\t\"ROG STRIX Z590-I GAMING WIFI\",\n\t\"ROG STRIX Z690-A GAMING WIFI\",\n\t\"ROG STRIX Z690-A GAMING WIFI D4\",\n\t\"ROG STRIX Z690-E GAMING WIFI\",\n\t\"ROG STRIX Z690-F GAMING WIFI\",\n\t\"ROG STRIX Z690-G GAMING WIFI\",\n\t\"ROG STRIX Z690-I GAMING WIFI\",\n\t\"ROG STRIX Z790-A GAMING WIFI\",\n\t\"ROG STRIX Z790-A GAMING WIFI D4\",\n\t\"ROG STRIX Z790-E GAMING WIFI\",\n\t\"ROG STRIX Z790-F GAMING WIFI\",\n\t\"ROG STRIX Z790-H GAMING WIFI\",\n\t\"ROG STRIX Z790-I GAMING WIFI\",\n\t\"TUF GAMING A620M-PLUS\",\n\t\"TUF GAMING A620M-PLUS WIFI\",\n\t\"TUF GAMING B560-PLUS WIFI\",\n\t\"TUF GAMING B560M-E\",\n\t\"TUF GAMING B560M-PLUS\",\n\t\"TUF GAMING B560M-PLUS WIFI\",\n\t\"TUF GAMING B650-PLUS\",\n\t\"TUF GAMING B650-PLUS WIFI\",\n\t\"TUF GAMING B650M-PLUS\",\n\t\"TUF GAMING B650M-PLUS WIFI\",\n\t\"TUF GAMING B660-PLUS WIFI D4\",\n\t\"TUF GAMING B660M-E D4\",\n\t\"TUF GAMING B660M-PLUS D4\",\n\t\"TUF GAMING B660M-PLUS WIFI\",\n\t\"TUF GAMING B660M-PLUS WIFI D4\",\n\t\"TUF GAMING B760-PLUS WIFI\",\n\t\"TUF GAMING B760-PLUS WIFI D4\",\n\t\"TUF GAMING B760M-BTF WIFI D4\",\n\t\"TUF GAMING B760M-E D4\",\n\t\"TUF GAMING B760M-PLUS\",\n\t\"TUF GAMING B760M-PLUS D4\",\n\t\"TUF GAMING B760M-PLUS WIFI\",\n\t\"TUF GAMING B760M-PLUS WIFI D4\",\n\t\"TUF GAMING H570-PRO\",\n\t\"TUF GAMING H570-PRO WIFI\",\n\t\"TUF GAMING H670-PRO WIFI D4\",\n\t\"TUF GAMING H770-PRO WIFI\",\n\t\"TUF GAMING X670E-PLUS\",\n\t\"TUF GAMING X670E-PLUS WIFI\",\n\t\"TUF GAMING Z590-PLUS\",\n\t\"TUF GAMING Z590-PLUS WIFI\",\n\t\"TUF GAMING Z690-PLUS\",\n\t\"TUF GAMING Z690-PLUS D4\",\n\t\"TUF GAMING Z690-PLUS WIFI\",\n\t\"TUF GAMING Z690-PLUS WIFI D4\",\n\t\"TUF GAMING Z790-PLUS D4\",\n\t\"TUF GAMING Z790-PLUS WIFI\",\n\t\"TUF GAMING Z790-PLUS WIFI D4\",\n\t\"Z590 WIFI GUNDAM EDITION\",\n};\n\n#if IS_ENABLED(CONFIG_ACPI)\n \nstatic int nct6775_asuswmi_device_match(struct device *dev, void *data)\n{\n\tstruct acpi_device *adev = to_acpi_device(dev);\n\tconst char *uid = acpi_device_uid(adev);\n\tconst char *hid = acpi_device_hid(adev);\n\n\tif (hid && !strcmp(hid, ASUSWMI_DEVICE_HID) && uid && !strcmp(uid, data)) {\n\t\tasus_acpi_dev = adev;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic enum sensor_access nct6775_determine_access(const char *device_uid)\n{\n#if IS_ENABLED(CONFIG_ACPI)\n\tu8 tmp;\n\n\tacpi_bus_for_each_dev(nct6775_asuswmi_device_match, (void *)device_uid);\n\tif (!asus_acpi_dev)\n\t\treturn access_direct;\n\n\t \n\tif (!nct6775_asuswmi_read(0, NCT6775_PORT_CHIPID, &tmp) && tmp) {\n\t\tpr_debug(\"Using Asus WMBD method of %s to access %#x chip.\\n\", device_uid, tmp);\n\t\treturn access_asuswmi;\n\t}\n#endif\n\n\treturn access_direct;\n}\n\nstatic int __init sensors_nct6775_platform_init(void)\n{\n\tint i, err;\n\tbool found = false;\n\tint address;\n\tstruct resource res;\n\tstruct nct6775_sio_data sio_data;\n\tint sioaddr[2] = { 0x2e, 0x4e };\n\tenum sensor_access access = access_direct;\n\tconst char *board_vendor, *board_name;\n\n\terr = platform_driver_register(&nct6775_driver);\n\tif (err)\n\t\treturn err;\n\n\tboard_vendor = dmi_get_system_info(DMI_BOARD_VENDOR);\n\tboard_name = dmi_get_system_info(DMI_BOARD_NAME);\n\n\tif (board_name && board_vendor &&\n\t    !strcmp(board_vendor, \"ASUSTeK COMPUTER INC.\")) {\n\t\terr = match_string(asus_wmi_boards, ARRAY_SIZE(asus_wmi_boards),\n\t\t\t\t   board_name);\n\t\tif (err >= 0)\n\t\t\taccess = nct6775_determine_access(ASUSWMI_DEVICE_UID);\n\n\t\terr = match_string(asus_msi_boards, ARRAY_SIZE(asus_msi_boards),\n\t\t\t\t   board_name);\n\t\tif (err >= 0)\n\t\t\taccess = nct6775_determine_access(ASUSMSI_DEVICE_UID);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pdev); i++) {\n\t\tsio_data.sio_outb = superio_outb;\n\t\tsio_data.sio_inb = superio_inb;\n\t\tsio_data.sio_select = superio_select;\n\t\tsio_data.sio_enter = superio_enter;\n\t\tsio_data.sio_exit = superio_exit;\n\n\t\taddress = nct6775_find(sioaddr[i], &sio_data);\n\t\tif (address <= 0)\n\t\t\tcontinue;\n\n\t\tfound = true;\n\n\t\tsio_data.access = access;\n\n\t\tif (access == access_asuswmi) {\n\t\t\tsio_data.sio_outb = superio_wmi_outb;\n\t\t\tsio_data.sio_inb = superio_wmi_inb;\n\t\t\tsio_data.sio_select = superio_wmi_select;\n\t\t\tsio_data.sio_enter = superio_wmi_enter;\n\t\t\tsio_data.sio_exit = superio_wmi_exit;\n\t\t}\n\n\t\tpdev[i] = platform_device_alloc(DRVNAME, address);\n\t\tif (!pdev[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit_device_unregister;\n\t\t}\n\n\t\terr = platform_device_add_data(pdev[i], &sio_data,\n\t\t\t\t\t       sizeof(struct nct6775_sio_data));\n\t\tif (err)\n\t\t\tgoto exit_device_put;\n\n\t\tif (sio_data.access == access_direct) {\n\t\t\tmemset(&res, 0, sizeof(res));\n\t\t\tres.name = DRVNAME;\n\t\t\tres.start = address + IOREGION_OFFSET;\n\t\t\tres.end = address + IOREGION_OFFSET + IOREGION_LENGTH - 1;\n\t\t\tres.flags = IORESOURCE_IO;\n\n\t\t\terr = acpi_check_resource_conflict(&res);\n\t\t\tif (err) {\n\t\t\t\tplatform_device_put(pdev[i]);\n\t\t\t\tpdev[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = platform_device_add_resources(pdev[i], &res, 1);\n\t\t\tif (err)\n\t\t\t\tgoto exit_device_put;\n\t\t}\n\n\t\t \n\t\terr = platform_device_add(pdev[i]);\n\t\tif (err)\n\t\t\tgoto exit_device_put;\n\t}\n\tif (!found) {\n\t\terr = -ENODEV;\n\t\tgoto exit_unregister;\n\t}\n\n\treturn 0;\n\nexit_device_put:\n\tplatform_device_put(pdev[i]);\nexit_device_unregister:\n\twhile (i--)\n\t\tplatform_device_unregister(pdev[i]);\nexit_unregister:\n\tplatform_driver_unregister(&nct6775_driver);\n\treturn err;\n}\n\nstatic void __exit sensors_nct6775_platform_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pdev); i++)\n\t\tplatform_device_unregister(pdev[i]);\n\tplatform_driver_unregister(&nct6775_driver);\n}\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"Platform driver for NCT6775F and compatible chips\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(HWMON_NCT6775);\n\nmodule_init(sensors_nct6775_platform_init);\nmodule_exit(sensors_nct6775_platform_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}