{
  "module_name": "atxp1.c",
  "hash_id": "1ac16b5dd4aee848c96099e373dd64075c6be61b7bcb2d66eabe65923fd01f84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/atxp1.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-vid.h>\n#include <linux/err.h>\n#include <linux/kstrtox.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"System voltages control via Attansic ATXP1\");\nMODULE_VERSION(\"0.6.3\");\nMODULE_AUTHOR(\"Sebastian Witt <se.witt@gmx.net>\");\n\n#define ATXP1_VID\t0x00\n#define ATXP1_CVID\t0x01\n#define ATXP1_GPIO1\t0x06\n#define ATXP1_GPIO2\t0x0a\n#define ATXP1_VIDENA\t0x20\n#define ATXP1_VIDMASK\t0x1f\n#define ATXP1_GPIO1MASK\t0x0f\n\nstruct atxp1_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tunsigned long last_updated;\n\tbool valid;\n\tstruct {\n\t\tu8 vid;\t\t \n\t\tu8 cpu_vid;  \n\t\tu8 gpio1;    \n\t\tu8 gpio2;    \n\t} reg;\n\tu8 vrm;\t\t\t \n};\n\nstatic struct atxp1_data *atxp1_update_device(struct device *dev)\n{\n\tstruct atxp1_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\n\n\t\t \n\t\tdata->reg.vid = i2c_smbus_read_byte_data(client, ATXP1_VID);\n\t\tdata->reg.cpu_vid = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t\t     ATXP1_CVID);\n\t\tdata->reg.gpio1 = i2c_smbus_read_byte_data(client, ATXP1_GPIO1);\n\t\tdata->reg.gpio2 = i2c_smbus_read_byte_data(client, ATXP1_GPIO2);\n\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \nstatic ssize_t cpu0_vid_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint size;\n\tstruct atxp1_data *data;\n\n\tdata = atxp1_update_device(dev);\n\n\tsize = sprintf(buf, \"%d\\n\", vid_from_reg(data->reg.vid & ATXP1_VIDMASK,\n\t\t\t\t\t\t data->vrm));\n\n\treturn size;\n}\n\nstatic ssize_t cpu0_vid_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct atxp1_data *data = atxp1_update_device(dev);\n\tstruct i2c_client *client = data->client;\n\tint vid, cvid;\n\tunsigned long vcore;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &vcore);\n\tif (err)\n\t\treturn err;\n\n\tvcore /= 25;\n\tvcore *= 25;\n\n\t \n\tvid = vid_to_reg(vcore, data->vrm);\n\tif (vid < 0) {\n\t\tdev_err(dev, \"VID calculation failed.\\n\");\n\t\treturn vid;\n\t}\n\n\t \n\tif (data->reg.vid & ATXP1_VIDENA)\n\t\tcvid = data->reg.vid & ATXP1_VIDMASK;\n\telse\n\t\tcvid = data->reg.cpu_vid;\n\n\t \n\tif (vid == cvid)\n\t\treturn count;\n\n\tdev_dbg(dev, \"Setting VCore to %d mV (0x%02x)\\n\", (int)vcore, vid);\n\n\t \n\tif (cvid > vid) {\n\t\tfor (; cvid >= vid; cvid--)\n\t\t\ti2c_smbus_write_byte_data(client,\n\t\t\t\t\t\tATXP1_VID, cvid | ATXP1_VIDENA);\n\t} else {\n\t\tfor (; cvid <= vid; cvid++)\n\t\t\ti2c_smbus_write_byte_data(client,\n\t\t\t\t\t\tATXP1_VID, cvid | ATXP1_VIDENA);\n\t}\n\n\tdata->valid = false;\n\n\treturn count;\n}\n\n \nstatic DEVICE_ATTR_RW(cpu0_vid);\n\n \nstatic ssize_t gpio1_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint size;\n\tstruct atxp1_data *data;\n\n\tdata = atxp1_update_device(dev);\n\n\tsize = sprintf(buf, \"0x%02x\\n\", data->reg.gpio1 & ATXP1_GPIO1MASK);\n\n\treturn size;\n}\n\nstatic ssize_t gpio1_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct atxp1_data *data = atxp1_update_device(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long value;\n\tint err;\n\n\terr = kstrtoul(buf, 16, &value);\n\tif (err)\n\t\treturn err;\n\n\tvalue &= ATXP1_GPIO1MASK;\n\n\tif (value != (data->reg.gpio1 & ATXP1_GPIO1MASK)) {\n\t\tdev_info(dev, \"Writing 0x%x to GPIO1.\\n\", (unsigned int)value);\n\n\t\ti2c_smbus_write_byte_data(client, ATXP1_GPIO1, value);\n\n\t\tdata->valid = false;\n\t}\n\n\treturn count;\n}\n\n \nstatic DEVICE_ATTR_RW(gpio1);\n\n \nstatic ssize_t gpio2_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint size;\n\tstruct atxp1_data *data;\n\n\tdata = atxp1_update_device(dev);\n\n\tsize = sprintf(buf, \"0x%02x\\n\", data->reg.gpio2);\n\n\treturn size;\n}\n\nstatic ssize_t gpio2_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct atxp1_data *data = atxp1_update_device(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long value;\n\tint err;\n\n\terr = kstrtoul(buf, 16, &value);\n\tif (err)\n\t\treturn err;\n\tvalue &= 0xff;\n\n\tif (value != data->reg.gpio2) {\n\t\tdev_info(dev, \"Writing 0x%x to GPIO1.\\n\", (unsigned int)value);\n\n\t\ti2c_smbus_write_byte_data(client, ATXP1_GPIO2, value);\n\n\t\tdata->valid = false;\n\t}\n\n\treturn count;\n}\n\n \nstatic DEVICE_ATTR_RW(gpio2);\n\nstatic struct attribute *atxp1_attrs[] = {\n\t&dev_attr_gpio1.attr,\n\t&dev_attr_gpio2.attr,\n\t&dev_attr_cpu0_vid.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(atxp1);\n\nstatic int atxp1_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct atxp1_data *data;\n\tstruct device *hwmon_dev;\n\n\tdata = devm_kzalloc(dev, sizeof(struct atxp1_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tdata->vrm = vid_which_vrm();\n\tif (data->vrm != 90 && data->vrm != 91) {\n\t\tdev_err(dev, \"atxp1: Not supporting VRM %d.%d\\n\",\n\t\t\tdata->vrm / 10, data->vrm % 10);\n\t\treturn -ENODEV;\n\t}\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   atxp1_groups);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdev_info(dev, \"Using VRM: %d.%d\\n\", data->vrm / 10, data->vrm % 10);\n\n\treturn 0;\n};\n\nstatic const struct i2c_device_id atxp1_id[] = {\n\t{ \"atxp1\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, atxp1_id);\n\nstatic struct i2c_driver atxp1_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"atxp1\",\n\t},\n\t.probe\t\t= atxp1_probe,\n\t.id_table\t= atxp1_id,\n};\n\nmodule_i2c_driver(atxp1_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}