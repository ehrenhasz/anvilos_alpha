{
  "module_name": "adcxx.c",
  "hash_id": "42b55256f3b3aecff5ffaaa5e85cfe5f7a67c390a82f0df76cf741c897dad3c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adcxx.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/sysfs.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/mutex.h>\n#include <linux/mod_devicetable.h>\n#include <linux/spi/spi.h>\n\n#define DRVNAME\t\t\"adcxx\"\n\nstruct adcxx {\n\tstruct device *hwmon_dev;\n\tstruct mutex lock;\n\tu32 channels;\n\tu32 reference;  \n};\n\n \nstatic ssize_t adcxx_show(struct device *dev,\n\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct adcxx *adc = spi_get_drvdata(spi);\n\tu8 tx_buf[2];\n\tu8 rx_buf[2];\n\tint status;\n\tu32 value;\n\n\tif (mutex_lock_interruptible(&adc->lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (adc->channels == 1) {\n\t\tstatus = spi_read(spi, rx_buf, sizeof(rx_buf));\n\t} else {\n\t\ttx_buf[0] = attr->index << 3;  \n\t\tstatus = spi_write_then_read(spi, tx_buf, sizeof(tx_buf),\n\t\t\t\t\t\trx_buf, sizeof(rx_buf));\n\t}\n\tif (status < 0) {\n\t\tdev_warn(dev, \"SPI synch. transfer failed with status %d\\n\",\n\t\t\t\tstatus);\n\t\tgoto out;\n\t}\n\n\tvalue = (rx_buf[0] << 8) + rx_buf[1];\n\tdev_dbg(dev, \"raw value = 0x%x\\n\", value);\n\n\tvalue = value * adc->reference >> 12;\n\tstatus = sprintf(buf, \"%d\\n\", value);\nout:\n\tmutex_unlock(&adc->lock);\n\treturn status;\n}\n\nstatic ssize_t adcxx_min_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\t \n\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t adcxx_max_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct adcxx *adc = spi_get_drvdata(spi);\n\tu32 reference;\n\n\tif (mutex_lock_interruptible(&adc->lock))\n\t\treturn -ERESTARTSYS;\n\n\treference = adc->reference;\n\n\tmutex_unlock(&adc->lock);\n\n\treturn sprintf(buf, \"%d\\n\", reference);\n}\n\nstatic ssize_t adcxx_max_store(struct device *dev,\n\t\t\t       struct device_attribute *devattr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct adcxx *adc = spi_get_drvdata(spi);\n\tunsigned long value;\n\n\tif (kstrtoul(buf, 10, &value))\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&adc->lock))\n\t\treturn -ERESTARTSYS;\n\n\tadc->reference = value;\n\n\tmutex_unlock(&adc->lock);\n\n\treturn count;\n}\n\nstatic ssize_t adcxx_name_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", to_spi_device(dev)->modalias);\n}\n\nstatic struct sensor_device_attribute ad_input[] = {\n\tSENSOR_ATTR_RO(name, adcxx_name, 0),\n\tSENSOR_ATTR_RO(in_min, adcxx_min, 0),\n\tSENSOR_ATTR_RW(in_max, adcxx_max, 0),\n\tSENSOR_ATTR_RO(in0_input, adcxx, 0),\n\tSENSOR_ATTR_RO(in1_input, adcxx, 1),\n\tSENSOR_ATTR_RO(in2_input, adcxx, 2),\n\tSENSOR_ATTR_RO(in3_input, adcxx, 3),\n\tSENSOR_ATTR_RO(in4_input, adcxx, 4),\n\tSENSOR_ATTR_RO(in5_input, adcxx, 5),\n\tSENSOR_ATTR_RO(in6_input, adcxx, 6),\n\tSENSOR_ATTR_RO(in7_input, adcxx, 7),\n};\n\n \n\nstatic int adcxx_probe(struct spi_device *spi)\n{\n\tint channels = spi_get_device_id(spi)->driver_data;\n\tstruct adcxx *adc;\n\tint status;\n\tint i;\n\n\tadc = devm_kzalloc(&spi->dev, sizeof(*adc), GFP_KERNEL);\n\tif (!adc)\n\t\treturn -ENOMEM;\n\n\t \n\tadc->reference = 3300;\n\tadc->channels = channels;\n\tmutex_init(&adc->lock);\n\n\tmutex_lock(&adc->lock);\n\n\tspi_set_drvdata(spi, adc);\n\n\tfor (i = 0; i < 3 + adc->channels; i++) {\n\t\tstatus = device_create_file(&spi->dev, &ad_input[i].dev_attr);\n\t\tif (status) {\n\t\t\tdev_err(&spi->dev, \"device_create_file failed.\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tadc->hwmon_dev = hwmon_device_register(&spi->dev);\n\tif (IS_ERR(adc->hwmon_dev)) {\n\t\tdev_err(&spi->dev, \"hwmon_device_register failed.\\n\");\n\t\tstatus = PTR_ERR(adc->hwmon_dev);\n\t\tgoto out_err;\n\t}\n\n\tmutex_unlock(&adc->lock);\n\treturn 0;\n\nout_err:\n\tfor (i--; i >= 0; i--)\n\t\tdevice_remove_file(&spi->dev, &ad_input[i].dev_attr);\n\n\tmutex_unlock(&adc->lock);\n\treturn status;\n}\n\nstatic void adcxx_remove(struct spi_device *spi)\n{\n\tstruct adcxx *adc = spi_get_drvdata(spi);\n\tint i;\n\n\tmutex_lock(&adc->lock);\n\thwmon_device_unregister(adc->hwmon_dev);\n\tfor (i = 0; i < 3 + adc->channels; i++)\n\t\tdevice_remove_file(&spi->dev, &ad_input[i].dev_attr);\n\n\tmutex_unlock(&adc->lock);\n}\n\nstatic const struct spi_device_id adcxx_ids[] = {\n\t{ \"adcxx1s\", 1 },\n\t{ \"adcxx2s\", 2 },\n\t{ \"adcxx4s\", 4 },\n\t{ \"adcxx8s\", 8 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, adcxx_ids);\n\nstatic struct spi_driver adcxx_driver = {\n\t.driver = {\n\t\t.name\t= \"adcxx\",\n\t},\n\t.id_table = adcxx_ids,\n\t.probe\t= adcxx_probe,\n\t.remove\t= adcxx_remove,\n};\n\nmodule_spi_driver(adcxx_driver);\n\nMODULE_AUTHOR(\"Marc Pignat\");\nMODULE_DESCRIPTION(\"National Semiconductor adcxx8sxxx Linux driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}