{
  "module_name": "npcm750-pwm-fan.c",
  "hash_id": "e11d4b64ed76a7fb9cd3b0d30a4dfc1add155679a629b5e3fcc1f4c1fb0711e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/npcm750-pwm-fan.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/sysfs.h>\n#include <linux/thermal.h>\n\n \n#define NPCM7XX_PWM_REG_BASE(base, n)    ((base) + ((n) * 0x1000L))\n\n#define NPCM7XX_PWM_REG_PR(base, n)\t(NPCM7XX_PWM_REG_BASE(base, n) + 0x00)\n#define NPCM7XX_PWM_REG_CSR(base, n)\t(NPCM7XX_PWM_REG_BASE(base, n) + 0x04)\n#define NPCM7XX_PWM_REG_CR(base, n)\t(NPCM7XX_PWM_REG_BASE(base, n) + 0x08)\n#define NPCM7XX_PWM_REG_CNRx(base, n, ch) \\\n\t\t\t(NPCM7XX_PWM_REG_BASE(base, n) + 0x0C + (12 * (ch)))\n#define NPCM7XX_PWM_REG_CMRx(base, n, ch) \\\n\t\t\t(NPCM7XX_PWM_REG_BASE(base, n) + 0x10 + (12 * (ch)))\n#define NPCM7XX_PWM_REG_PDRx(base, n, ch) \\\n\t\t\t(NPCM7XX_PWM_REG_BASE(base, n) + 0x14 + (12 * (ch)))\n#define NPCM7XX_PWM_REG_PIER(base, n)\t(NPCM7XX_PWM_REG_BASE(base, n) + 0x3C)\n#define NPCM7XX_PWM_REG_PIIR(base, n)\t(NPCM7XX_PWM_REG_BASE(base, n) + 0x40)\n\n#define NPCM7XX_PWM_CTRL_CH0_MODE_BIT\t\tBIT(3)\n#define NPCM7XX_PWM_CTRL_CH1_MODE_BIT\t\tBIT(11)\n#define NPCM7XX_PWM_CTRL_CH2_MODE_BIT\t\tBIT(15)\n#define NPCM7XX_PWM_CTRL_CH3_MODE_BIT\t\tBIT(19)\n\n#define NPCM7XX_PWM_CTRL_CH0_INV_BIT\t\tBIT(2)\n#define NPCM7XX_PWM_CTRL_CH1_INV_BIT\t\tBIT(10)\n#define NPCM7XX_PWM_CTRL_CH2_INV_BIT\t\tBIT(14)\n#define NPCM7XX_PWM_CTRL_CH3_INV_BIT\t\tBIT(18)\n\n#define NPCM7XX_PWM_CTRL_CH0_EN_BIT\t\tBIT(0)\n#define NPCM7XX_PWM_CTRL_CH1_EN_BIT\t\tBIT(8)\n#define NPCM7XX_PWM_CTRL_CH2_EN_BIT\t\tBIT(12)\n#define NPCM7XX_PWM_CTRL_CH3_EN_BIT\t\tBIT(16)\n\n \n#define NPCM7XX_PWM_MAX_CHN_NUM\t\t\t8\n#define NPCM7XX_PWM_MAX_CHN_NUM_IN_A_MODULE\t4\n#define NPCM7XX_PWM_MAX_MODULES                 2\n\n \n#define NPCM7XX_PWM_COUNTER_DEFAULT_NUM\t\t255\n#define NPCM7XX_PWM_CMR_DEFAULT_NUM\t\t255\n#define NPCM7XX_PWM_CMR_MAX\t\t\t255\n\n \n#define NPCM7XX_PWM_PRESCALE2_DEFAULT_CH0\t0x4\n#define NPCM7XX_PWM_PRESCALE2_DEFAULT_CH1\t0x40\n#define NPCM7XX_PWM_PRESCALE2_DEFAULT_CH2\t0x400\n#define NPCM7XX_PWM_PRESCALE2_DEFAULT_CH3\t0x4000\n\n#define PWM_OUTPUT_FREQ_25KHZ\t\t\t25000\n#define PWN_CNT_DEFAULT\t\t\t\t256\n#define MIN_PRESCALE1\t\t\t\t2\n#define NPCM7XX_PWM_PRESCALE_SHIFT_CH01\t\t8\n\n#define NPCM7XX_PWM_PRESCALE2_DEFAULT\t(NPCM7XX_PWM_PRESCALE2_DEFAULT_CH0 | \\\n\t\t\t\t\tNPCM7XX_PWM_PRESCALE2_DEFAULT_CH1 | \\\n\t\t\t\t\tNPCM7XX_PWM_PRESCALE2_DEFAULT_CH2 | \\\n\t\t\t\t\tNPCM7XX_PWM_PRESCALE2_DEFAULT_CH3)\n\n#define NPCM7XX_PWM_CTRL_MODE_DEFAULT\t(NPCM7XX_PWM_CTRL_CH0_MODE_BIT | \\\n\t\t\t\t\tNPCM7XX_PWM_CTRL_CH1_MODE_BIT | \\\n\t\t\t\t\tNPCM7XX_PWM_CTRL_CH2_MODE_BIT | \\\n\t\t\t\t\tNPCM7XX_PWM_CTRL_CH3_MODE_BIT)\n\n \n#define NPCM7XX_FAN_REG_BASE(base, n)\t((base) + ((n) * 0x1000L))\n\n#define NPCM7XX_FAN_REG_TCNT1(base, n)    (NPCM7XX_FAN_REG_BASE(base, n) + 0x00)\n#define NPCM7XX_FAN_REG_TCRA(base, n)     (NPCM7XX_FAN_REG_BASE(base, n) + 0x02)\n#define NPCM7XX_FAN_REG_TCRB(base, n)     (NPCM7XX_FAN_REG_BASE(base, n) + 0x04)\n#define NPCM7XX_FAN_REG_TCNT2(base, n)    (NPCM7XX_FAN_REG_BASE(base, n) + 0x06)\n#define NPCM7XX_FAN_REG_TPRSC(base, n)    (NPCM7XX_FAN_REG_BASE(base, n) + 0x08)\n#define NPCM7XX_FAN_REG_TCKC(base, n)     (NPCM7XX_FAN_REG_BASE(base, n) + 0x0A)\n#define NPCM7XX_FAN_REG_TMCTRL(base, n)   (NPCM7XX_FAN_REG_BASE(base, n) + 0x0C)\n#define NPCM7XX_FAN_REG_TICTRL(base, n)   (NPCM7XX_FAN_REG_BASE(base, n) + 0x0E)\n#define NPCM7XX_FAN_REG_TICLR(base, n)    (NPCM7XX_FAN_REG_BASE(base, n) + 0x10)\n#define NPCM7XX_FAN_REG_TIEN(base, n)     (NPCM7XX_FAN_REG_BASE(base, n) + 0x12)\n#define NPCM7XX_FAN_REG_TCPA(base, n)     (NPCM7XX_FAN_REG_BASE(base, n) + 0x14)\n#define NPCM7XX_FAN_REG_TCPB(base, n)     (NPCM7XX_FAN_REG_BASE(base, n) + 0x16)\n#define NPCM7XX_FAN_REG_TCPCFG(base, n)   (NPCM7XX_FAN_REG_BASE(base, n) + 0x18)\n#define NPCM7XX_FAN_REG_TINASEL(base, n)  (NPCM7XX_FAN_REG_BASE(base, n) + 0x1A)\n#define NPCM7XX_FAN_REG_TINBSEL(base, n)  (NPCM7XX_FAN_REG_BASE(base, n) + 0x1C)\n\n#define NPCM7XX_FAN_TCKC_CLKX_NONE\t0\n#define NPCM7XX_FAN_TCKC_CLK1_APB\tBIT(0)\n#define NPCM7XX_FAN_TCKC_CLK2_APB\tBIT(3)\n\n#define NPCM7XX_FAN_TMCTRL_TBEN\t\tBIT(6)\n#define NPCM7XX_FAN_TMCTRL_TAEN\t\tBIT(5)\n#define NPCM7XX_FAN_TMCTRL_TBEDG\tBIT(4)\n#define NPCM7XX_FAN_TMCTRL_TAEDG\tBIT(3)\n#define NPCM7XX_FAN_TMCTRL_MODE_5\tBIT(2)\n\n#define NPCM7XX_FAN_TICLR_CLEAR_ALL\tGENMASK(5, 0)\n#define NPCM7XX_FAN_TICLR_TFCLR\t\tBIT(5)\n#define NPCM7XX_FAN_TICLR_TECLR\t\tBIT(4)\n#define NPCM7XX_FAN_TICLR_TDCLR\t\tBIT(3)\n#define NPCM7XX_FAN_TICLR_TCCLR\t\tBIT(2)\n#define NPCM7XX_FAN_TICLR_TBCLR\t\tBIT(1)\n#define NPCM7XX_FAN_TICLR_TACLR\t\tBIT(0)\n\n#define NPCM7XX_FAN_TIEN_ENABLE_ALL\tGENMASK(5, 0)\n#define NPCM7XX_FAN_TIEN_TFIEN\t\tBIT(5)\n#define NPCM7XX_FAN_TIEN_TEIEN\t\tBIT(4)\n#define NPCM7XX_FAN_TIEN_TDIEN\t\tBIT(3)\n#define NPCM7XX_FAN_TIEN_TCIEN\t\tBIT(2)\n#define NPCM7XX_FAN_TIEN_TBIEN\t\tBIT(1)\n#define NPCM7XX_FAN_TIEN_TAIEN\t\tBIT(0)\n\n#define NPCM7XX_FAN_TICTRL_TFPND\tBIT(5)\n#define NPCM7XX_FAN_TICTRL_TEPND\tBIT(4)\n#define NPCM7XX_FAN_TICTRL_TDPND\tBIT(3)\n#define NPCM7XX_FAN_TICTRL_TCPND\tBIT(2)\n#define NPCM7XX_FAN_TICTRL_TBPND\tBIT(1)\n#define NPCM7XX_FAN_TICTRL_TAPND\tBIT(0)\n\n#define NPCM7XX_FAN_TCPCFG_HIBEN\tBIT(7)\n#define NPCM7XX_FAN_TCPCFG_EQBEN\tBIT(6)\n#define NPCM7XX_FAN_TCPCFG_LOBEN\tBIT(5)\n#define NPCM7XX_FAN_TCPCFG_CPBSEL\tBIT(4)\n#define NPCM7XX_FAN_TCPCFG_HIAEN\tBIT(3)\n#define NPCM7XX_FAN_TCPCFG_EQAEN\tBIT(2)\n#define NPCM7XX_FAN_TCPCFG_LOAEN\tBIT(1)\n#define NPCM7XX_FAN_TCPCFG_CPASEL\tBIT(0)\n\n \n \n#define NPCM7XX_FAN_MAX_MODULE\t\t\t8\n#define NPCM7XX_FAN_MAX_CHN_NUM_IN_A_MODULE\t2\n#define NPCM7XX_FAN_MAX_CHN_NUM\t\t\t16\n\n \n#define NPCM7XX_FAN_TIMEOUT\t0x5000\n#define NPCM7XX_FAN_TCNT\t0xFFFF\n#define NPCM7XX_FAN_TCPA\t(NPCM7XX_FAN_TCNT - NPCM7XX_FAN_TIMEOUT)\n#define NPCM7XX_FAN_TCPB\t(NPCM7XX_FAN_TCNT - NPCM7XX_FAN_TIMEOUT)\n\n#define NPCM7XX_FAN_POLL_TIMER_200MS\t\t\t200\n#define NPCM7XX_FAN_DEFAULT_PULSE_PER_REVOLUTION\t2\n#define NPCM7XX_FAN_TINASEL_FANIN_DEFAULT\t\t0\n#define NPCM7XX_FAN_CLK_PRESCALE\t\t\t255\n\n#define NPCM7XX_FAN_CMPA\t\t\t\t0\n#define NPCM7XX_FAN_CMPB\t\t\t\t1\n\n \n#define NPCM7XX_FAN_INPUT(fan, cmp)\t\t(((fan) << 1) + (cmp))\n\n \n#define FAN_DISABLE\t\t\t\t0xFF\n#define FAN_INIT\t\t\t\t0x00\n#define FAN_PREPARE_TO_GET_FIRST_CAPTURE\t0x01\n#define FAN_ENOUGH_SAMPLE\t\t\t0x02\n\nstruct npcm7xx_fan_dev {\n\tu8 fan_st_flg;\n\tu8 fan_pls_per_rev;\n\tu16 fan_cnt;\n\tu32 fan_cnt_tmp;\n};\n\nstruct npcm7xx_cooling_device {\n\tchar name[THERMAL_NAME_LENGTH];\n\tstruct npcm7xx_pwm_fan_data *data;\n\tstruct thermal_cooling_device *tcdev;\n\tint pwm_port;\n\tu8 *cooling_levels;\n\tu8 max_state;\n\tu8 cur_state;\n};\n\nstruct npcm7xx_pwm_fan_data {\n\tvoid __iomem *pwm_base;\n\tvoid __iomem *fan_base;\n\tunsigned long pwm_clk_freq;\n\tunsigned long fan_clk_freq;\n\tstruct clk *pwm_clk;\n\tstruct clk *fan_clk;\n\tstruct mutex pwm_lock[NPCM7XX_PWM_MAX_MODULES];\n\tspinlock_t fan_lock[NPCM7XX_FAN_MAX_MODULE];\n\tint fan_irq[NPCM7XX_FAN_MAX_MODULE];\n\tbool pwm_present[NPCM7XX_PWM_MAX_CHN_NUM];\n\tbool fan_present[NPCM7XX_FAN_MAX_CHN_NUM];\n\tu32 input_clk_freq;\n\tstruct timer_list fan_timer;\n\tstruct npcm7xx_fan_dev fan_dev[NPCM7XX_FAN_MAX_CHN_NUM];\n\tstruct npcm7xx_cooling_device *cdev[NPCM7XX_PWM_MAX_CHN_NUM];\n\tu8 fan_select;\n};\n\nstatic int npcm7xx_pwm_config_set(struct npcm7xx_pwm_fan_data *data,\n\t\t\t\t  int channel, u16 val)\n{\n\tu32 pwm_ch = (channel % NPCM7XX_PWM_MAX_CHN_NUM_IN_A_MODULE);\n\tu32 module = (channel / NPCM7XX_PWM_MAX_CHN_NUM_IN_A_MODULE);\n\tu32 tmp_buf, ctrl_en_bit, env_bit;\n\n\t \n\tmutex_lock(&data->pwm_lock[module]);\n\n\t \n\tiowrite32(val, NPCM7XX_PWM_REG_CMRx(data->pwm_base, module, pwm_ch));\n\ttmp_buf = ioread32(NPCM7XX_PWM_REG_CR(data->pwm_base, module));\n\n\tswitch (pwm_ch) {\n\tcase 0:\n\t\tctrl_en_bit = NPCM7XX_PWM_CTRL_CH0_EN_BIT;\n\t\tenv_bit = NPCM7XX_PWM_CTRL_CH0_INV_BIT;\n\t\tbreak;\n\tcase 1:\n\t\tctrl_en_bit = NPCM7XX_PWM_CTRL_CH1_EN_BIT;\n\t\tenv_bit = NPCM7XX_PWM_CTRL_CH1_INV_BIT;\n\t\tbreak;\n\tcase 2:\n\t\tctrl_en_bit = NPCM7XX_PWM_CTRL_CH2_EN_BIT;\n\t\tenv_bit = NPCM7XX_PWM_CTRL_CH2_INV_BIT;\n\t\tbreak;\n\tcase 3:\n\t\tctrl_en_bit = NPCM7XX_PWM_CTRL_CH3_EN_BIT;\n\t\tenv_bit = NPCM7XX_PWM_CTRL_CH3_INV_BIT;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&data->pwm_lock[module]);\n\t\treturn -ENODEV;\n\t}\n\n\tif (val == 0) {\n\t\t \n\t\ttmp_buf &= ~ctrl_en_bit;\n\t\ttmp_buf |= env_bit;\n\t} else {\n\t\t \n\t\ttmp_buf |= ctrl_en_bit;\n\t\ttmp_buf &= ~env_bit;\n\t}\n\n\tiowrite32(tmp_buf, NPCM7XX_PWM_REG_CR(data->pwm_base, module));\n\tmutex_unlock(&data->pwm_lock[module]);\n\n\treturn 0;\n}\n\nstatic inline void npcm7xx_fan_start_capture(struct npcm7xx_pwm_fan_data *data,\n\t\t\t\t\t     u8 fan, u8 cmp)\n{\n\tu8 fan_id;\n\tu8 reg_mode;\n\tu8 reg_int;\n\tunsigned long flags;\n\n\tfan_id = NPCM7XX_FAN_INPUT(fan, cmp);\n\n\t \n\tif (data->fan_dev[fan_id].fan_st_flg != FAN_DISABLE) {\n\t\t \n\t\tspin_lock_irqsave(&data->fan_lock[fan], flags);\n\n\t\tdata->fan_dev[fan_id].fan_st_flg = FAN_INIT;\n\t\treg_int = ioread8(NPCM7XX_FAN_REG_TIEN(data->fan_base, fan));\n\n\t\t \n\t\tif (cmp == NPCM7XX_FAN_CMPA) {\n\t\t\t \n\t\t\tiowrite8(reg_int | (NPCM7XX_FAN_TIEN_TAIEN |\n\t\t\t\t\t    NPCM7XX_FAN_TIEN_TEIEN),\n\t\t\t\t NPCM7XX_FAN_REG_TIEN(data->fan_base, fan));\n\n\t\t\treg_mode = NPCM7XX_FAN_TCKC_CLK1_APB\n\t\t\t\t| ioread8(NPCM7XX_FAN_REG_TCKC(data->fan_base,\n\t\t\t\t\t\t\t       fan));\n\n\t\t\t \n\t\t\tiowrite8(reg_mode, NPCM7XX_FAN_REG_TCKC(data->fan_base,\n\t\t\t\t\t\t\t\tfan));\n\t\t} else {\n\t\t\t \n\t\t\tiowrite8(reg_int | (NPCM7XX_FAN_TIEN_TBIEN |\n\t\t\t\t\t    NPCM7XX_FAN_TIEN_TFIEN),\n\t\t\t\t NPCM7XX_FAN_REG_TIEN(data->fan_base, fan));\n\n\t\t\treg_mode =\n\t\t\t\tNPCM7XX_FAN_TCKC_CLK2_APB\n\t\t\t\t| ioread8(NPCM7XX_FAN_REG_TCKC(data->fan_base,\n\t\t\t\t\t\t\t       fan));\n\n\t\t\t \n\t\t\tiowrite8(reg_mode,\n\t\t\t\t NPCM7XX_FAN_REG_TCKC(data->fan_base, fan));\n\t\t}\n\n\t\tspin_unlock_irqrestore(&data->fan_lock[fan], flags);\n\t}\n}\n\n \nstatic void npcm7xx_fan_polling(struct timer_list *t)\n{\n\tstruct npcm7xx_pwm_fan_data *data;\n\tint i;\n\n\tdata = from_timer(data, t, fan_timer);\n\n\t \n\tfor (i = data->fan_select; i < NPCM7XX_FAN_MAX_MODULE;\n\t      i = i + 4) {\n\t\t \n\t\tiowrite8(NPCM7XX_FAN_TICLR_CLEAR_ALL,\n\t\t\t NPCM7XX_FAN_REG_TICLR(data->fan_base, i));\n\n\t\tif (data->fan_present[i * 2]) {\n\t\t\tiowrite16(NPCM7XX_FAN_TCNT,\n\t\t\t\t  NPCM7XX_FAN_REG_TCNT1(data->fan_base, i));\n\t\t\tnpcm7xx_fan_start_capture(data, i, NPCM7XX_FAN_CMPA);\n\t\t}\n\t\tif (data->fan_present[(i * 2) + 1]) {\n\t\t\tiowrite16(NPCM7XX_FAN_TCNT,\n\t\t\t\t  NPCM7XX_FAN_REG_TCNT2(data->fan_base, i));\n\t\t\tnpcm7xx_fan_start_capture(data, i, NPCM7XX_FAN_CMPB);\n\t\t}\n\t}\n\n\tdata->fan_select++;\n\tdata->fan_select &= 0x3;\n\n\t \n\tdata->fan_timer.expires = jiffies +\n\t\tmsecs_to_jiffies(NPCM7XX_FAN_POLL_TIMER_200MS);\n\tadd_timer(&data->fan_timer);\n}\n\nstatic inline void npcm7xx_fan_compute(struct npcm7xx_pwm_fan_data *data,\n\t\t\t\t       u8 fan, u8 cmp, u8 fan_id, u8 flag_int,\n\t\t\t\t       u8 flag_mode, u8 flag_clear)\n{\n\tu8  reg_int;\n\tu8  reg_mode;\n\tu16 fan_cap;\n\n\tif (cmp == NPCM7XX_FAN_CMPA)\n\t\tfan_cap = ioread16(NPCM7XX_FAN_REG_TCRA(data->fan_base, fan));\n\telse\n\t\tfan_cap = ioread16(NPCM7XX_FAN_REG_TCRB(data->fan_base, fan));\n\n\t \n\tiowrite8(flag_clear, NPCM7XX_FAN_REG_TICLR(data->fan_base, fan));\n\n\tif (data->fan_dev[fan_id].fan_st_flg == FAN_INIT) {\n\t\t \n\t\tdata->fan_dev[fan_id].fan_st_flg =\n\t\t\tFAN_PREPARE_TO_GET_FIRST_CAPTURE;\n\n\t\t \n\t\tdata->fan_dev[fan_id].fan_cnt_tmp = 0;\n\t} else if (data->fan_dev[fan_id].fan_st_flg < FAN_ENOUGH_SAMPLE) {\n\t\t \n\t\tdata->fan_dev[fan_id].fan_cnt_tmp +=\n\t\t\t(NPCM7XX_FAN_TCNT - fan_cap);\n\n\t\tdata->fan_dev[fan_id].fan_st_flg++;\n\t} else {\n\t\t \n\t\tif (data->fan_dev[fan_id].fan_st_flg == FAN_ENOUGH_SAMPLE) {\n\t\t\tdata->fan_dev[fan_id].fan_cnt_tmp +=\n\t\t\t\t(NPCM7XX_FAN_TCNT - fan_cap);\n\n\t\t\t \n\t\t\tdata->fan_dev[fan_id].fan_cnt =\n\t\t\t\tdata->fan_dev[fan_id].fan_cnt_tmp /\n\t\t\t\tFAN_ENOUGH_SAMPLE;\n\n\t\t\tdata->fan_dev[fan_id].fan_st_flg = FAN_INIT;\n\t\t}\n\n\t\treg_int =  ioread8(NPCM7XX_FAN_REG_TIEN(data->fan_base, fan));\n\n\t\t \n\t\tiowrite8((reg_int & ~flag_int),\n\t\t\t NPCM7XX_FAN_REG_TIEN(data->fan_base, fan));\n\t\treg_mode =  ioread8(NPCM7XX_FAN_REG_TCKC(data->fan_base, fan));\n\n\t\t \n\t\tiowrite8((reg_mode & ~flag_mode),\n\t\t\t NPCM7XX_FAN_REG_TCKC(data->fan_base, fan));\n\t}\n}\n\nstatic inline void npcm7xx_check_cmp(struct npcm7xx_pwm_fan_data *data,\n\t\t\t\t     u8 fan, u8 cmp, u8 flag)\n{\n\tu8 reg_int;\n\tu8 reg_mode;\n\tu8 flag_timeout;\n\tu8 flag_cap;\n\tu8 flag_clear;\n\tu8 flag_int;\n\tu8 flag_mode;\n\tu8 fan_id;\n\n\tfan_id = NPCM7XX_FAN_INPUT(fan, cmp);\n\n\tif (cmp == NPCM7XX_FAN_CMPA) {\n\t\tflag_cap = NPCM7XX_FAN_TICTRL_TAPND;\n\t\tflag_timeout = NPCM7XX_FAN_TICTRL_TEPND;\n\t\tflag_int = NPCM7XX_FAN_TIEN_TAIEN | NPCM7XX_FAN_TIEN_TEIEN;\n\t\tflag_mode = NPCM7XX_FAN_TCKC_CLK1_APB;\n\t\tflag_clear = NPCM7XX_FAN_TICLR_TACLR | NPCM7XX_FAN_TICLR_TECLR;\n\t} else {\n\t\tflag_cap = NPCM7XX_FAN_TICTRL_TBPND;\n\t\tflag_timeout = NPCM7XX_FAN_TICTRL_TFPND;\n\t\tflag_int = NPCM7XX_FAN_TIEN_TBIEN | NPCM7XX_FAN_TIEN_TFIEN;\n\t\tflag_mode = NPCM7XX_FAN_TCKC_CLK2_APB;\n\t\tflag_clear = NPCM7XX_FAN_TICLR_TBCLR | NPCM7XX_FAN_TICLR_TFCLR;\n\t}\n\n\tif (flag & flag_timeout) {\n\t\treg_int =  ioread8(NPCM7XX_FAN_REG_TIEN(data->fan_base, fan));\n\n\t\t \n\t\tiowrite8((reg_int & ~flag_int),\n\t\t\t NPCM7XX_FAN_REG_TIEN(data->fan_base, fan));\n\n\t\t \n\t\tiowrite8(flag_clear,\n\t\t\t NPCM7XX_FAN_REG_TICLR(data->fan_base, fan));\n\n\t\treg_mode =  ioread8(NPCM7XX_FAN_REG_TCKC(data->fan_base, fan));\n\n\t\t \n\t\tiowrite8((reg_mode & ~flag_mode),\n\t\t\t NPCM7XX_FAN_REG_TCKC(data->fan_base, fan));\n\n\t\t \n\t\tdata->fan_dev[fan_id].fan_cnt = 0;\n\t} else {\n\t     \n\t\tif (flag & flag_cap)\n\t\t\tnpcm7xx_fan_compute(data, fan, cmp, fan_id, flag_int,\n\t\t\t\t\t    flag_mode, flag_clear);\n\t}\n}\n\nstatic irqreturn_t npcm7xx_fan_isr(int irq, void *dev_id)\n{\n\tstruct npcm7xx_pwm_fan_data *data = dev_id;\n\tunsigned long flags;\n\tint module;\n\tu8 flag;\n\n\tmodule = irq - data->fan_irq[0];\n\tspin_lock_irqsave(&data->fan_lock[module], flags);\n\n\tflag = ioread8(NPCM7XX_FAN_REG_TICTRL(data->fan_base, module));\n\tif (flag > 0) {\n\t\tnpcm7xx_check_cmp(data, module, NPCM7XX_FAN_CMPA, flag);\n\t\tnpcm7xx_check_cmp(data, module, NPCM7XX_FAN_CMPB, flag);\n\t\tspin_unlock_irqrestore(&data->fan_lock[module], flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_unlock_irqrestore(&data->fan_lock[module], flags);\n\n\treturn IRQ_NONE;\n}\n\nstatic int npcm7xx_read_pwm(struct device *dev, u32 attr, int channel,\n\t\t\t    long *val)\n{\n\tstruct npcm7xx_pwm_fan_data *data = dev_get_drvdata(dev);\n\tu32 pmw_ch = (channel % NPCM7XX_PWM_MAX_CHN_NUM_IN_A_MODULE);\n\tu32 module = (channel / NPCM7XX_PWM_MAX_CHN_NUM_IN_A_MODULE);\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\t*val = ioread32\n\t\t\t(NPCM7XX_PWM_REG_CMRx(data->pwm_base, module, pmw_ch));\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int npcm7xx_write_pwm(struct device *dev, u32 attr, int channel,\n\t\t\t     long val)\n{\n\tstruct npcm7xx_pwm_fan_data *data = dev_get_drvdata(dev);\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\tif (val < 0 || val > NPCM7XX_PWM_CMR_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = npcm7xx_pwm_config_set(data, channel, (u16)val);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic umode_t npcm7xx_pwm_is_visible(const void *_data, u32 attr, int channel)\n{\n\tconst struct npcm7xx_pwm_fan_data *data = _data;\n\n\tif (!data->pwm_present[channel])\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int npcm7xx_read_fan(struct device *dev, u32 attr, int channel,\n\t\t\t    long *val)\n{\n\tstruct npcm7xx_pwm_fan_data *data = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\t\t*val = 0;\n\t\tif (data->fan_dev[channel].fan_cnt <= 0)\n\t\t\treturn data->fan_dev[channel].fan_cnt;\n\n\t\t \n\t\tif (data->fan_dev[channel].fan_cnt > 0 &&\n\t\t    data->fan_dev[channel].fan_pls_per_rev > 0)\n\t\t\t*val = ((data->input_clk_freq * 60) /\n\t\t\t\t(data->fan_dev[channel].fan_cnt *\n\t\t\t\t data->fan_dev[channel].fan_pls_per_rev));\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t npcm7xx_fan_is_visible(const void *_data, u32 attr, int channel)\n{\n\tconst struct npcm7xx_pwm_fan_data *data = _data;\n\n\tif (!data->fan_present[channel])\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int npcm7xx_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\treturn npcm7xx_read_pwm(dev, attr, channel, val);\n\tcase hwmon_fan:\n\t\treturn npcm7xx_read_fan(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int npcm7xx_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\treturn npcm7xx_write_pwm(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t npcm7xx_is_visible(const void *data,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\treturn npcm7xx_pwm_is_visible(data, attr, channel);\n\tcase hwmon_fan:\n\t\treturn npcm7xx_fan_is_visible(data, attr, channel);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const npcm7xx_info[] = {\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT),\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT,\n\t\t\t   HWMON_F_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops npcm7xx_hwmon_ops = {\n\t.is_visible = npcm7xx_is_visible,\n\t.read = npcm7xx_read,\n\t.write = npcm7xx_write,\n};\n\nstatic const struct hwmon_chip_info npcm7xx_chip_info = {\n\t.ops = &npcm7xx_hwmon_ops,\n\t.info = npcm7xx_info,\n};\n\nstatic u32 npcm7xx_pwm_init(struct npcm7xx_pwm_fan_data *data)\n{\n\tint m, ch;\n\tu32 prescale_val, output_freq;\n\n\tdata->pwm_clk_freq = clk_get_rate(data->pwm_clk);\n\n\t \n\toutput_freq = data->pwm_clk_freq / PWN_CNT_DEFAULT;\n\tprescale_val = DIV_ROUND_CLOSEST(output_freq, PWM_OUTPUT_FREQ_25KHZ);\n\n\t \n\tif (prescale_val < MIN_PRESCALE1)\n\t\tprescale_val = MIN_PRESCALE1;\n\t \n\tprescale_val--;\n\n\t \n\tprescale_val |= (prescale_val << NPCM7XX_PWM_PRESCALE_SHIFT_CH01);\n\n\tfor (m = 0; m < NPCM7XX_PWM_MAX_MODULES  ; m++) {\n\t\tiowrite32(prescale_val, NPCM7XX_PWM_REG_PR(data->pwm_base, m));\n\t\tiowrite32(NPCM7XX_PWM_PRESCALE2_DEFAULT,\n\t\t\t  NPCM7XX_PWM_REG_CSR(data->pwm_base, m));\n\t\tiowrite32(NPCM7XX_PWM_CTRL_MODE_DEFAULT,\n\t\t\t  NPCM7XX_PWM_REG_CR(data->pwm_base, m));\n\n\t\tfor (ch = 0; ch < NPCM7XX_PWM_MAX_CHN_NUM_IN_A_MODULE; ch++) {\n\t\t\tiowrite32(NPCM7XX_PWM_COUNTER_DEFAULT_NUM,\n\t\t\t\t  NPCM7XX_PWM_REG_CNRx(data->pwm_base, m, ch));\n\t\t}\n\t}\n\n\treturn output_freq / ((prescale_val & 0xf) + 1);\n}\n\nstatic void npcm7xx_fan_init(struct npcm7xx_pwm_fan_data *data)\n{\n\tint md;\n\tint ch;\n\tint i;\n\tu32 apb_clk_freq;\n\n\tfor (md = 0; md < NPCM7XX_FAN_MAX_MODULE; md++) {\n\t\t \n\t\tiowrite8(NPCM7XX_FAN_TCKC_CLKX_NONE,\n\t\t\t NPCM7XX_FAN_REG_TCKC(data->fan_base, md));\n\n\t\t \n\t\tiowrite8(0x00, NPCM7XX_FAN_REG_TIEN(data->fan_base, md));\n\n\t\t \n\t\tiowrite8(NPCM7XX_FAN_TICLR_CLEAR_ALL,\n\t\t\t NPCM7XX_FAN_REG_TICLR(data->fan_base, md));\n\n\t\t \n\t\tiowrite8(NPCM7XX_FAN_CLK_PRESCALE,\n\t\t\t NPCM7XX_FAN_REG_TPRSC(data->fan_base, md));\n\n\t\t \n\t\tiowrite8((NPCM7XX_FAN_TMCTRL_MODE_5 | NPCM7XX_FAN_TMCTRL_TBEN |\n\t\t\t  NPCM7XX_FAN_TMCTRL_TAEN),\n\t\t\t NPCM7XX_FAN_REG_TMCTRL(data->fan_base, md));\n\n\t\t \n\t\tiowrite16(NPCM7XX_FAN_TCNT,\n\t\t\t  NPCM7XX_FAN_REG_TCNT1(data->fan_base, md));\n\t\tiowrite16(NPCM7XX_FAN_TCNT,\n\t\t\t  NPCM7XX_FAN_REG_TCNT2(data->fan_base, md));\n\n\t\t \n\t\tiowrite8((NPCM7XX_FAN_TCPCFG_EQAEN | NPCM7XX_FAN_TCPCFG_EQBEN),\n\t\t\t NPCM7XX_FAN_REG_TCPCFG(data->fan_base, md));\n\n\t\t \n\t\tiowrite16(NPCM7XX_FAN_TCPA,\n\t\t\t  NPCM7XX_FAN_REG_TCPA(data->fan_base, md));\n\t\tiowrite16(NPCM7XX_FAN_TCPB,\n\t\t\t  NPCM7XX_FAN_REG_TCPB(data->fan_base, md));\n\n\t\t \n\t\tiowrite8(NPCM7XX_FAN_TINASEL_FANIN_DEFAULT,\n\t\t\t NPCM7XX_FAN_REG_TINASEL(data->fan_base, md));\n\t\tiowrite8(NPCM7XX_FAN_TINASEL_FANIN_DEFAULT,\n\t\t\t NPCM7XX_FAN_REG_TINBSEL(data->fan_base, md));\n\n\t\tfor (i = 0; i < NPCM7XX_FAN_MAX_CHN_NUM_IN_A_MODULE; i++) {\n\t\t\tch = md * NPCM7XX_FAN_MAX_CHN_NUM_IN_A_MODULE + i;\n\t\t\tdata->fan_dev[ch].fan_st_flg = FAN_DISABLE;\n\t\t\tdata->fan_dev[ch].fan_pls_per_rev =\n\t\t\t\tNPCM7XX_FAN_DEFAULT_PULSE_PER_REVOLUTION;\n\t\t\tdata->fan_dev[ch].fan_cnt = 0;\n\t\t}\n\t}\n\n\tapb_clk_freq = clk_get_rate(data->fan_clk);\n\n\t \n\tdata->input_clk_freq = apb_clk_freq / (NPCM7XX_FAN_CLK_PRESCALE + 1);\n}\n\nstatic int\nnpcm7xx_pwm_cz_get_max_state(struct thermal_cooling_device *tcdev,\n\t\t\t     unsigned long *state)\n{\n\tstruct npcm7xx_cooling_device *cdev = tcdev->devdata;\n\n\t*state = cdev->max_state;\n\n\treturn 0;\n}\n\nstatic int\nnpcm7xx_pwm_cz_get_cur_state(struct thermal_cooling_device *tcdev,\n\t\t\t     unsigned long *state)\n{\n\tstruct npcm7xx_cooling_device *cdev = tcdev->devdata;\n\n\t*state = cdev->cur_state;\n\n\treturn 0;\n}\n\nstatic int\nnpcm7xx_pwm_cz_set_cur_state(struct thermal_cooling_device *tcdev,\n\t\t\t     unsigned long state)\n{\n\tstruct npcm7xx_cooling_device *cdev = tcdev->devdata;\n\tint ret;\n\n\tif (state > cdev->max_state)\n\t\treturn -EINVAL;\n\n\tcdev->cur_state = state;\n\tret = npcm7xx_pwm_config_set(cdev->data, cdev->pwm_port,\n\t\t\t\t     cdev->cooling_levels[cdev->cur_state]);\n\n\treturn ret;\n}\n\nstatic const struct thermal_cooling_device_ops npcm7xx_pwm_cool_ops = {\n\t.get_max_state = npcm7xx_pwm_cz_get_max_state,\n\t.get_cur_state = npcm7xx_pwm_cz_get_cur_state,\n\t.set_cur_state = npcm7xx_pwm_cz_set_cur_state,\n};\n\nstatic int npcm7xx_create_pwm_cooling(struct device *dev,\n\t\t\t\t      struct device_node *child,\n\t\t\t\t      struct npcm7xx_pwm_fan_data *data,\n\t\t\t\t      u32 pwm_port, u8 num_levels)\n{\n\tint ret;\n\tstruct npcm7xx_cooling_device *cdev;\n\n\tcdev = devm_kzalloc(dev, sizeof(*cdev), GFP_KERNEL);\n\tif (!cdev)\n\t\treturn -ENOMEM;\n\n\tcdev->cooling_levels = devm_kzalloc(dev, num_levels, GFP_KERNEL);\n\tif (!cdev->cooling_levels)\n\t\treturn -ENOMEM;\n\n\tcdev->max_state = num_levels - 1;\n\tret = of_property_read_u8_array(child, \"cooling-levels\",\n\t\t\t\t\tcdev->cooling_levels,\n\t\t\t\t\tnum_levels);\n\tif (ret) {\n\t\tdev_err(dev, \"Property 'cooling-levels' cannot be read.\\n\");\n\t\treturn ret;\n\t}\n\tsnprintf(cdev->name, THERMAL_NAME_LENGTH, \"%pOFn%d\", child,\n\t\t pwm_port);\n\n\tcdev->tcdev = devm_thermal_of_cooling_device_register(dev, child,\n\t\t\t\tcdev->name, cdev, &npcm7xx_pwm_cool_ops);\n\tif (IS_ERR(cdev->tcdev))\n\t\treturn PTR_ERR(cdev->tcdev);\n\n\tcdev->data = data;\n\tcdev->pwm_port = pwm_port;\n\n\tdata->cdev[pwm_port] = cdev;\n\n\treturn 0;\n}\n\nstatic int npcm7xx_en_pwm_fan(struct device *dev,\n\t\t\t      struct device_node *child,\n\t\t\t      struct npcm7xx_pwm_fan_data *data)\n{\n\tu8 *fan_ch;\n\tu32 pwm_port;\n\tint ret, fan_cnt;\n\tu8 index, ch;\n\n\tret = of_property_read_u32(child, \"reg\", &pwm_port);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->pwm_present[pwm_port] = true;\n\tret = npcm7xx_pwm_config_set(data, pwm_port,\n\t\t\t\t     NPCM7XX_PWM_CMR_DEFAULT_NUM);\n\n\tret = of_property_count_u8_elems(child, \"cooling-levels\");\n\tif (ret > 0) {\n\t\tret = npcm7xx_create_pwm_cooling(dev, child, data, pwm_port,\n\t\t\t\t\t\t ret);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfan_cnt = of_property_count_u8_elems(child, \"fan-tach-ch\");\n\tif (fan_cnt < 1)\n\t\treturn -EINVAL;\n\n\tfan_ch = devm_kcalloc(dev, fan_cnt, sizeof(*fan_ch), GFP_KERNEL);\n\tif (!fan_ch)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u8_array(child, \"fan-tach-ch\", fan_ch, fan_cnt);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (ch = 0; ch < fan_cnt; ch++) {\n\t\tindex = fan_ch[ch];\n\t\tdata->fan_present[index] = true;\n\t\tdata->fan_dev[index].fan_st_flg = FAN_INIT;\n\t}\n\n\treturn 0;\n}\n\nstatic int npcm7xx_pwm_fan_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np, *child;\n\tstruct npcm7xx_pwm_fan_data *data;\n\tstruct resource *res;\n\tstruct device *hwmon;\n\tchar name[20];\n\tint ret, cnt;\n\tu32 output_freq;\n\tu32 i;\n\n\tnp = dev->of_node;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"pwm\");\n\tif (!res) {\n\t\tdev_err(dev, \"pwm resource not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata->pwm_base = devm_ioremap_resource(dev, res);\n\tdev_dbg(dev, \"pwm base resource is %pR\\n\", res);\n\tif (IS_ERR(data->pwm_base))\n\t\treturn PTR_ERR(data->pwm_base);\n\n\tdata->pwm_clk = devm_clk_get(dev, \"pwm\");\n\tif (IS_ERR(data->pwm_clk)) {\n\t\tdev_err(dev, \"couldn't get pwm clock\\n\");\n\t\treturn PTR_ERR(data->pwm_clk);\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"fan\");\n\tif (!res) {\n\t\tdev_err(dev, \"fan resource not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata->fan_base = devm_ioremap_resource(dev, res);\n\tdev_dbg(dev, \"fan base resource is %pR\\n\", res);\n\tif (IS_ERR(data->fan_base))\n\t\treturn PTR_ERR(data->fan_base);\n\n\tdata->fan_clk = devm_clk_get(dev, \"fan\");\n\tif (IS_ERR(data->fan_clk)) {\n\t\tdev_err(dev, \"couldn't get fan clock\\n\");\n\t\treturn PTR_ERR(data->fan_clk);\n\t}\n\n\toutput_freq = npcm7xx_pwm_init(data);\n\tnpcm7xx_fan_init(data);\n\n\tfor (cnt = 0; cnt < NPCM7XX_PWM_MAX_MODULES  ; cnt++)\n\t\tmutex_init(&data->pwm_lock[cnt]);\n\n\tfor (i = 0; i < NPCM7XX_FAN_MAX_MODULE; i++) {\n\t\tspin_lock_init(&data->fan_lock[i]);\n\n\t\tdata->fan_irq[i] = platform_get_irq(pdev, i);\n\t\tif (data->fan_irq[i] < 0)\n\t\t\treturn data->fan_irq[i];\n\n\t\tsprintf(name, \"NPCM7XX-FAN-MD%d\", i);\n\t\tret = devm_request_irq(dev, data->fan_irq[i], npcm7xx_fan_isr,\n\t\t\t\t       0, name, (void *)data);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"register IRQ fan%d failed\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_child_of_node(np, child) {\n\t\tret = npcm7xx_en_pwm_fan(dev, child, data);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"enable pwm and fan failed\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\thwmon = devm_hwmon_device_register_with_info(dev, \"npcm7xx_pwm_fan\",\n\t\t\t\t\t\t     data, &npcm7xx_chip_info,\n\t\t\t\t\t\t     NULL);\n\tif (IS_ERR(hwmon)) {\n\t\tdev_err(dev, \"unable to register hwmon device\\n\");\n\t\treturn PTR_ERR(hwmon);\n\t}\n\n\tfor (i = 0; i < NPCM7XX_FAN_MAX_CHN_NUM; i++) {\n\t\tif (data->fan_present[i]) {\n\t\t\t \n\t\t\tdata->fan_timer.expires = jiffies +\n\t\t\t\tmsecs_to_jiffies(NPCM7XX_FAN_POLL_TIMER_200MS);\n\t\t\ttimer_setup(&data->fan_timer,\n\t\t\t\t    npcm7xx_fan_polling, 0);\n\t\t\tadd_timer(&data->fan_timer);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpr_info(\"NPCM7XX PWM-FAN Driver probed, output Freq %dHz[PWM], input Freq %dHz[FAN]\\n\",\n\t\toutput_freq, data->input_clk_freq);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_pwm_fan_match_table[] = {\n\t{ .compatible = \"nuvoton,npcm750-pwm-fan\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_pwm_fan_match_table);\n\nstatic struct platform_driver npcm7xx_pwm_fan_driver = {\n\t.probe\t\t= npcm7xx_pwm_fan_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"npcm7xx_pwm_fan\",\n\t\t.of_match_table = of_pwm_fan_match_table,\n\t},\n};\n\nmodule_platform_driver(npcm7xx_pwm_fan_driver);\n\nMODULE_DESCRIPTION(\"Nuvoton NPCM7XX PWM and Fan Tacho driver\");\nMODULE_AUTHOR(\"Tomer Maimon <tomer.maimon@nuvoton.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}