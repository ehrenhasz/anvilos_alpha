{
  "module_name": "asb100.c",
  "hash_id": "c2c3c01ed53cdc4510cd2e733e92150700f91dd04baa750b60962816070dd311",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/asb100.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon-vid.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include \"lm75.h\"\n\n \nstatic const unsigned short normal_i2c[] = { 0x2d, I2C_CLIENT_END };\n\nstatic unsigned short force_subclients[4];\nmodule_param_array(force_subclients, short, NULL, 0);\nMODULE_PARM_DESC(force_subclients,\n\t\"List of subclient addresses: {bus, clientaddr, subclientaddr1, subclientaddr2}\");\n\n \n#define ASB100_REG_IN(nr)\t(0x20 + (nr))\n#define ASB100_REG_IN_MAX(nr)\t(0x2b + (nr * 2))\n#define ASB100_REG_IN_MIN(nr)\t(0x2c + (nr * 2))\n\n \n#define ASB100_REG_FAN(nr)\t(0x28 + (nr))\n#define ASB100_REG_FAN_MIN(nr)\t(0x3b + (nr))\n\n \nstatic const u16 asb100_reg_temp[]\t= {0, 0x27, 0x150, 0x250, 0x17};\nstatic const u16 asb100_reg_temp_max[]\t= {0, 0x39, 0x155, 0x255, 0x18};\nstatic const u16 asb100_reg_temp_hyst[]\t= {0, 0x3a, 0x153, 0x253, 0x19};\n\n#define ASB100_REG_TEMP(nr) (asb100_reg_temp[nr])\n#define ASB100_REG_TEMP_MAX(nr) (asb100_reg_temp_max[nr])\n#define ASB100_REG_TEMP_HYST(nr) (asb100_reg_temp_hyst[nr])\n\n#define ASB100_REG_TEMP2_CONFIG\t0x0152\n#define ASB100_REG_TEMP3_CONFIG\t0x0252\n\n\n#define ASB100_REG_CONFIG\t0x40\n#define ASB100_REG_ALARM1\t0x41\n#define ASB100_REG_ALARM2\t0x42\n#define ASB100_REG_SMIM1\t0x43\n#define ASB100_REG_SMIM2\t0x44\n#define ASB100_REG_VID_FANDIV\t0x47\n#define ASB100_REG_I2C_ADDR\t0x48\n#define ASB100_REG_CHIPID\t0x49\n#define ASB100_REG_I2C_SUBADDR\t0x4a\n#define ASB100_REG_PIN\t\t0x4b\n#define ASB100_REG_IRQ\t\t0x4c\n#define ASB100_REG_BANK\t\t0x4e\n#define ASB100_REG_CHIPMAN\t0x4f\n\n#define ASB100_REG_WCHIPID\t0x58\n\n \n#define ASB100_REG_PWM1\t\t0x59\n\n \n\n \n#define ASB100_IN_MIN\t\t0\n#define ASB100_IN_MAX\t\t4080\n\n \nstatic u8 IN_TO_REG(unsigned val)\n{\n\tunsigned nval = clamp_val(val, ASB100_IN_MIN, ASB100_IN_MAX);\n\treturn (nval + 8) / 16;\n}\n\nstatic unsigned IN_FROM_REG(u8 reg)\n{\n\treturn reg * 16;\n}\n\nstatic u8 FAN_TO_REG(long rpm, int div)\n{\n\tif (rpm == -1)\n\t\treturn 0;\n\tif (rpm == 0)\n\t\treturn 255;\n\trpm = clamp_val(rpm, 1, 1000000);\n\treturn clamp_val((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\n}\n\nstatic int FAN_FROM_REG(u8 val, int div)\n{\n\treturn val == 0 ? -1 : val == 255 ? 0 : 1350000 / (val * div);\n}\n\n \n#define ASB100_TEMP_MIN\t\t-128000\n#define ASB100_TEMP_MAX\t\t127000\n\n \nstatic u8 TEMP_TO_REG(long temp)\n{\n\tint ntemp = clamp_val(temp, ASB100_TEMP_MIN, ASB100_TEMP_MAX);\n\tntemp += (ntemp < 0 ? -500 : 500);\n\treturn (u8)(ntemp / 1000);\n}\n\nstatic int TEMP_FROM_REG(u8 reg)\n{\n\treturn (s8)reg * 1000;\n}\n\n \nstatic u8 ASB100_PWM_TO_REG(int pwm)\n{\n\tpwm = clamp_val(pwm, 0, 255);\n\treturn (u8)(pwm / 16);\n}\n\nstatic int ASB100_PWM_FROM_REG(u8 reg)\n{\n\treturn reg * 16;\n}\n\n#define DIV_FROM_REG(val) (1 << (val))\n\n \nstatic u8 DIV_TO_REG(long val)\n{\n\treturn val == 8 ? 3 : val == 4 ? 2 : val == 1 ? 0 : 1;\n}\n\n \nstruct asb100_data {\n\tstruct device *hwmon_dev;\n\tstruct mutex lock;\n\n\tstruct mutex update_lock;\n\tunsigned long last_updated;\t \n\n\t \n\tstruct i2c_client *lm75[2];\n\n\tbool valid;\t\t \n\tu8 in[7];\t\t \n\tu8 in_max[7];\t\t \n\tu8 in_min[7];\t\t \n\tu8 fan[3];\t\t \n\tu8 fan_min[3];\t\t \n\tu16 temp[4];\t\t \n\tu16 temp_max[4];\t \n\tu16 temp_hyst[4];\t \n\tu8 fan_div[3];\t\t \n\tu8 pwm;\t\t\t \n\tu8 vid;\t\t\t \n\tu32 alarms;\t\t \n\tu8 vrm;\n};\n\nstatic int asb100_read_value(struct i2c_client *client, u16 reg);\nstatic void asb100_write_value(struct i2c_client *client, u16 reg, u16 val);\n\nstatic int asb100_probe(struct i2c_client *client);\nstatic int asb100_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info);\nstatic void asb100_remove(struct i2c_client *client);\nstatic struct asb100_data *asb100_update_device(struct device *dev);\nstatic void asb100_init_client(struct i2c_client *client);\n\nstatic const struct i2c_device_id asb100_id[] = {\n\t{ \"asb100\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, asb100_id);\n\nstatic struct i2c_driver asb100_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"asb100\",\n\t},\n\t.probe\t\t= asb100_probe,\n\t.remove\t\t= asb100_remove,\n\t.id_table\t= asb100_id,\n\t.detect\t\t= asb100_detect,\n\t.address_list\t= normal_i2c,\n};\n\n \n#define show_in_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\tchar *buf) \\\n{ \\\n\tint nr = to_sensor_dev_attr(attr)->index; \\\n\tstruct asb100_data *data = asb100_update_device(dev); \\\n\treturn sprintf(buf, \"%d\\n\", IN_FROM_REG(data->reg[nr])); \\\n}\n\nshow_in_reg(in)\nshow_in_reg(in_min)\nshow_in_reg(in_max)\n\n#define set_in_reg(REG, reg) \\\nstatic ssize_t set_in_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\tconst char *buf, size_t count) \\\n{ \\\n\tint nr = to_sensor_dev_attr(attr)->index; \\\n\tstruct i2c_client *client = to_i2c_client(dev); \\\n\tstruct asb100_data *data = i2c_get_clientdata(client); \\\n\tunsigned long val; \\\n\tint err = kstrtoul(buf, 10, &val); \\\n\tif (err) \\\n\t\treturn err; \\\n\tmutex_lock(&data->update_lock); \\\n\tdata->in_##reg[nr] = IN_TO_REG(val); \\\n\tasb100_write_value(client, ASB100_REG_IN_##REG(nr), \\\n\t\tdata->in_##reg[nr]); \\\n\tmutex_unlock(&data->update_lock); \\\n\treturn count; \\\n}\n\nset_in_reg(MIN, min)\nset_in_reg(MAX, max)\n\n#define sysfs_in(offset) \\\nstatic SENSOR_DEVICE_ATTR(in##offset##_input, S_IRUGO, \\\n\t\tshow_in, NULL, offset); \\\nstatic SENSOR_DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR, \\\n\t\tshow_in_min, set_in_min, offset); \\\nstatic SENSOR_DEVICE_ATTR(in##offset##_max, S_IRUGO | S_IWUSR, \\\n\t\tshow_in_max, set_in_max, offset)\n\nsysfs_in(0);\nsysfs_in(1);\nsysfs_in(2);\nsysfs_in(3);\nsysfs_in(4);\nsysfs_in(5);\nsysfs_in(6);\n\n \nstatic ssize_t show_fan(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct asb100_data *data = asb100_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", FAN_FROM_REG(data->fan[nr],\n\t\tDIV_FROM_REG(data->fan_div[nr])));\n}\n\nstatic ssize_t show_fan_min(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct asb100_data *data = asb100_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", FAN_FROM_REG(data->fan_min[nr],\n\t\tDIV_FROM_REG(data->fan_div[nr])));\n}\n\nstatic ssize_t show_fan_div(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct asb100_data *data = asb100_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", DIV_FROM_REG(data->fan_div[nr]));\n}\n\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct asb100_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\n\tasb100_write_value(client, ASB100_REG_FAN_MIN(nr), data->fan_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \nstatic ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct asb100_data *data = i2c_get_clientdata(client);\n\tunsigned long min;\n\tint reg;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\n\tmin = FAN_FROM_REG(data->fan_min[nr],\n\t\t\tDIV_FROM_REG(data->fan_div[nr]));\n\tdata->fan_div[nr] = DIV_TO_REG(val);\n\n\tswitch (nr) {\n\tcase 0:\t \n\t\treg = asb100_read_value(client, ASB100_REG_VID_FANDIV);\n\t\treg = (reg & 0xcf) | (data->fan_div[0] << 4);\n\t\tasb100_write_value(client, ASB100_REG_VID_FANDIV, reg);\n\t\tbreak;\n\n\tcase 1:\t \n\t\treg = asb100_read_value(client, ASB100_REG_VID_FANDIV);\n\t\treg = (reg & 0x3f) | (data->fan_div[1] << 6);\n\t\tasb100_write_value(client, ASB100_REG_VID_FANDIV, reg);\n\t\tbreak;\n\n\tcase 2:\t \n\t\treg = asb100_read_value(client, ASB100_REG_PIN);\n\t\treg = (reg & 0x3f) | (data->fan_div[2] << 6);\n\t\tasb100_write_value(client, ASB100_REG_PIN, reg);\n\t\tbreak;\n\t}\n\n\tdata->fan_min[nr] =\n\t\tFAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\n\tasb100_write_value(client, ASB100_REG_FAN_MIN(nr), data->fan_min[nr]);\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n#define sysfs_fan(offset) \\\nstatic SENSOR_DEVICE_ATTR(fan##offset##_input, S_IRUGO, \\\n\t\tshow_fan, NULL, offset - 1); \\\nstatic SENSOR_DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR, \\\n\t\tshow_fan_min, set_fan_min, offset - 1); \\\nstatic SENSOR_DEVICE_ATTR(fan##offset##_div, S_IRUGO | S_IWUSR, \\\n\t\tshow_fan_div, set_fan_div, offset - 1)\n\nsysfs_fan(1);\nsysfs_fan(2);\nsysfs_fan(3);\n\n \nstatic int sprintf_temp_from_reg(u16 reg, char *buf, int nr)\n{\n\tint ret = 0;\n\n\tswitch (nr) {\n\tcase 1: case 2:\n\t\tret = sprintf(buf, \"%d\\n\", LM75_TEMP_FROM_REG(reg));\n\t\tbreak;\n\tcase 0: case 3: default:\n\t\tret = sprintf(buf, \"%d\\n\", TEMP_FROM_REG(reg));\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n#define show_temp_reg(reg) \\\nstatic ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\tchar *buf) \\\n{ \\\n\tint nr = to_sensor_dev_attr(attr)->index; \\\n\tstruct asb100_data *data = asb100_update_device(dev); \\\n\treturn sprintf_temp_from_reg(data->reg[nr], buf, nr); \\\n}\n\nshow_temp_reg(temp);\nshow_temp_reg(temp_max);\nshow_temp_reg(temp_hyst);\n\n#define set_temp_reg(REG, reg) \\\nstatic ssize_t set_##reg(struct device *dev, struct device_attribute *attr, \\\n\t\tconst char *buf, size_t count) \\\n{ \\\n\tint nr = to_sensor_dev_attr(attr)->index; \\\n\tstruct i2c_client *client = to_i2c_client(dev); \\\n\tstruct asb100_data *data = i2c_get_clientdata(client); \\\n\tlong val; \\\n\tint err = kstrtol(buf, 10, &val); \\\n\tif (err) \\\n\t\treturn err; \\\n\tmutex_lock(&data->update_lock); \\\n\tswitch (nr) { \\\n\tcase 1: case 2: \\\n\t\tdata->reg[nr] = LM75_TEMP_TO_REG(val); \\\n\t\tbreak; \\\n\tcase 0: case 3: default: \\\n\t\tdata->reg[nr] = TEMP_TO_REG(val); \\\n\t\tbreak; \\\n\t} \\\n\tasb100_write_value(client, ASB100_REG_TEMP_##REG(nr+1), \\\n\t\t\tdata->reg[nr]); \\\n\tmutex_unlock(&data->update_lock); \\\n\treturn count; \\\n}\n\nset_temp_reg(MAX, temp_max);\nset_temp_reg(HYST, temp_hyst);\n\n#define sysfs_temp(num) \\\nstatic SENSOR_DEVICE_ATTR(temp##num##_input, S_IRUGO, \\\n\t\tshow_temp, NULL, num - 1); \\\nstatic SENSOR_DEVICE_ATTR(temp##num##_max, S_IRUGO | S_IWUSR, \\\n\t\tshow_temp_max, set_temp_max, num - 1); \\\nstatic SENSOR_DEVICE_ATTR(temp##num##_max_hyst, S_IRUGO | S_IWUSR, \\\n\t\tshow_temp_hyst, set_temp_hyst, num - 1)\n\nsysfs_temp(1);\nsysfs_temp(2);\nsysfs_temp(3);\nsysfs_temp(4);\n\n \nstatic ssize_t cpu0_vid_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct asb100_data *data = asb100_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", vid_from_reg(data->vid, data->vrm));\n}\n\nstatic DEVICE_ATTR_RO(cpu0_vid);\n\n \nstatic ssize_t vrm_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct asb100_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", data->vrm);\n}\n\nstatic ssize_t vrm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct asb100_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tdata->vrm = val;\n\treturn count;\n}\n\n \nstatic DEVICE_ATTR_RW(vrm);\n\nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct asb100_data *data = asb100_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", data->alarms);\n}\n\nstatic DEVICE_ATTR_RO(alarms);\n\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tstruct asb100_data *data = asb100_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> bitnr) & 1);\n}\nstatic SENSOR_DEVICE_ATTR(in0_alarm, S_IRUGO, show_alarm, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(in1_alarm, S_IRUGO, show_alarm, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(in2_alarm, S_IRUGO, show_alarm, NULL, 2);\nstatic SENSOR_DEVICE_ATTR(in3_alarm, S_IRUGO, show_alarm, NULL, 3);\nstatic SENSOR_DEVICE_ATTR(in4_alarm, S_IRUGO, show_alarm, NULL, 8);\nstatic SENSOR_DEVICE_ATTR(fan1_alarm, S_IRUGO, show_alarm, NULL, 6);\nstatic SENSOR_DEVICE_ATTR(fan2_alarm, S_IRUGO, show_alarm, NULL, 7);\nstatic SENSOR_DEVICE_ATTR(fan3_alarm, S_IRUGO, show_alarm, NULL, 11);\nstatic SENSOR_DEVICE_ATTR(temp1_alarm, S_IRUGO, show_alarm, NULL, 4);\nstatic SENSOR_DEVICE_ATTR(temp2_alarm, S_IRUGO, show_alarm, NULL, 5);\nstatic SENSOR_DEVICE_ATTR(temp3_alarm, S_IRUGO, show_alarm, NULL, 13);\n\n \nstatic ssize_t pwm1_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct asb100_data *data = asb100_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", ASB100_PWM_FROM_REG(data->pwm & 0x0f));\n}\n\nstatic ssize_t pwm1_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct asb100_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm &= 0x80;  \n\tdata->pwm |= (0x0f & ASB100_PWM_TO_REG(val));\n\tasb100_write_value(client, ASB100_REG_PWM1, data->pwm);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t pwm1_enable_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct asb100_data *data = asb100_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (data->pwm & 0x80) ? 1 : 0);\n}\n\nstatic ssize_t pwm1_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct asb100_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm &= 0x0f;  \n\tdata->pwm |= (val ? 0x80 : 0x00);\n\tasb100_write_value(client, ASB100_REG_PWM1, data->pwm);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(pwm1);\nstatic DEVICE_ATTR_RW(pwm1_enable);\n\nstatic struct attribute *asb100_attributes[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_min.dev_attr.attr,\n\t&sensor_dev_attr_in6_max.dev_attr.attr,\n\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_div.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_div.dev_attr.attr,\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_div.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp4_input.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max_hyst.dev_attr.attr,\n\n\t&sensor_dev_attr_in0_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in4_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan3_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_alarm.dev_attr.attr,\n\n\t&dev_attr_cpu0_vid.attr,\n\t&dev_attr_vrm.attr,\n\t&dev_attr_alarms.attr,\n\t&dev_attr_pwm1.attr,\n\t&dev_attr_pwm1_enable.attr,\n\n\tNULL\n};\n\nstatic const struct attribute_group asb100_group = {\n\t.attrs = asb100_attributes,\n};\n\nstatic int asb100_detect_subclients(struct i2c_client *client)\n{\n\tint i, id, err;\n\tint address = client->addr;\n\tunsigned short sc_addr[2];\n\tstruct asb100_data *data = i2c_get_clientdata(client);\n\tstruct i2c_adapter *adapter = client->adapter;\n\n\tid = i2c_adapter_id(adapter);\n\n\tif (force_subclients[0] == id && force_subclients[1] == address) {\n\t\tfor (i = 2; i <= 3; i++) {\n\t\t\tif (force_subclients[i] < 0x48 ||\n\t\t\t    force_subclients[i] > 0x4f) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"invalid subclient address %d; must be 0x48-0x4f\\n\",\n\t\t\t\t\tforce_subclients[i]);\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto ERROR_SC_2;\n\t\t\t}\n\t\t}\n\t\tasb100_write_value(client, ASB100_REG_I2C_SUBADDR,\n\t\t\t\t\t(force_subclients[2] & 0x07) |\n\t\t\t\t\t((force_subclients[3] & 0x07) << 4));\n\t\tsc_addr[0] = force_subclients[2];\n\t\tsc_addr[1] = force_subclients[3];\n\t} else {\n\t\tint val = asb100_read_value(client, ASB100_REG_I2C_SUBADDR);\n\t\tsc_addr[0] = 0x48 + (val & 0x07);\n\t\tsc_addr[1] = 0x48 + ((val >> 4) & 0x07);\n\t}\n\n\tif (sc_addr[0] == sc_addr[1]) {\n\t\tdev_err(&client->dev,\n\t\t\t\"duplicate addresses 0x%x for subclients\\n\",\n\t\t\tsc_addr[0]);\n\t\terr = -ENODEV;\n\t\tgoto ERROR_SC_2;\n\t}\n\n\tdata->lm75[0] = i2c_new_dummy_device(adapter, sc_addr[0]);\n\tif (IS_ERR(data->lm75[0])) {\n\t\tdev_err(&client->dev,\n\t\t\t\"subclient %d registration at address 0x%x failed.\\n\",\n\t\t\t1, sc_addr[0]);\n\t\terr = PTR_ERR(data->lm75[0]);\n\t\tgoto ERROR_SC_2;\n\t}\n\n\tdata->lm75[1] = i2c_new_dummy_device(adapter, sc_addr[1]);\n\tif (IS_ERR(data->lm75[1])) {\n\t\tdev_err(&client->dev,\n\t\t\t\"subclient %d registration at address 0x%x failed.\\n\",\n\t\t\t2, sc_addr[1]);\n\t\terr = PTR_ERR(data->lm75[1]);\n\t\tgoto ERROR_SC_3;\n\t}\n\n\treturn 0;\n\n \nERROR_SC_3:\n\ti2c_unregister_device(data->lm75[0]);\nERROR_SC_2:\n\treturn err;\n}\n\n \nstatic int asb100_detect(struct i2c_client *client,\n\t\t\t struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint val1, val2;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tpr_debug(\"detect failed, smbus byte data not supported!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tval1 = i2c_smbus_read_byte_data(client, ASB100_REG_BANK);\n\tval2 = i2c_smbus_read_byte_data(client, ASB100_REG_CHIPMAN);\n\n\t \n\tif ((!(val1 & 0x07)) &&\n\t\t\t \n\t\t\t(((!(val1 & 0x80)) && (val2 != 0x94)) ||\n\t\t\t \n\t\t\t((val1 & 0x80) && (val2 != 0x06)))) {\n\t\tpr_debug(\"detect failed, bad chip id 0x%02x!\\n\", val2);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\ti2c_smbus_write_byte_data(client, ASB100_REG_BANK,\n\t\t(i2c_smbus_read_byte_data(client, ASB100_REG_BANK) & 0x78)\n\t\t| 0x80);\n\n\t \n\tval1 = i2c_smbus_read_byte_data(client, ASB100_REG_WCHIPID);\n\tval2 = i2c_smbus_read_byte_data(client, ASB100_REG_CHIPMAN);\n\n\tif (val1 != 0x31 || val2 != 0x06)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"asb100\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int asb100_probe(struct i2c_client *client)\n{\n\tint err;\n\tstruct asb100_data *data;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct asb100_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->lock);\n\tmutex_init(&data->update_lock);\n\n\t \n\terr = asb100_detect_subclients(client);\n\tif (err)\n\t\treturn err;\n\n\t \n\tasb100_init_client(client);\n\n\t \n\tdata->fan_min[0] = asb100_read_value(client, ASB100_REG_FAN_MIN(0));\n\tdata->fan_min[1] = asb100_read_value(client, ASB100_REG_FAN_MIN(1));\n\tdata->fan_min[2] = asb100_read_value(client, ASB100_REG_FAN_MIN(2));\n\n\t \n\terr = sysfs_create_group(&client->dev.kobj, &asb100_group);\n\tif (err)\n\t\tgoto ERROR3;\n\n\tdata->hwmon_dev = hwmon_device_register(&client->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto ERROR4;\n\t}\n\n\treturn 0;\n\nERROR4:\n\tsysfs_remove_group(&client->dev.kobj, &asb100_group);\nERROR3:\n\ti2c_unregister_device(data->lm75[1]);\n\ti2c_unregister_device(data->lm75[0]);\n\treturn err;\n}\n\nstatic void asb100_remove(struct i2c_client *client)\n{\n\tstruct asb100_data *data = i2c_get_clientdata(client);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tsysfs_remove_group(&client->dev.kobj, &asb100_group);\n\n\ti2c_unregister_device(data->lm75[1]);\n\ti2c_unregister_device(data->lm75[0]);\n}\n\n \nstatic int asb100_read_value(struct i2c_client *client, u16 reg)\n{\n\tstruct asb100_data *data = i2c_get_clientdata(client);\n\tstruct i2c_client *cl;\n\tint res, bank;\n\n\tmutex_lock(&data->lock);\n\n\tbank = (reg >> 8) & 0x0f;\n\tif (bank > 2)\n\t\t \n\t\ti2c_smbus_write_byte_data(client, ASB100_REG_BANK, bank);\n\n\tif (bank == 0 || bank > 2) {\n\t\tres = i2c_smbus_read_byte_data(client, reg & 0xff);\n\t} else {\n\t\t \n\t\tcl = data->lm75[bank - 1];\n\n\t\t \n\t\tswitch (reg & 0xff) {\n\t\tcase 0x50:  \n\t\t\tres = i2c_smbus_read_word_swapped(cl, 0);\n\t\t\tbreak;\n\t\tcase 0x52:  \n\t\t\tres = i2c_smbus_read_byte_data(cl, 1);\n\t\t\tbreak;\n\t\tcase 0x53:  \n\t\t\tres = i2c_smbus_read_word_swapped(cl, 2);\n\t\t\tbreak;\n\t\tcase 0x55:  \n\t\tdefault:\n\t\t\tres = i2c_smbus_read_word_swapped(cl, 3);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bank > 2)\n\t\ti2c_smbus_write_byte_data(client, ASB100_REG_BANK, 0);\n\n\tmutex_unlock(&data->lock);\n\n\treturn res;\n}\n\nstatic void asb100_write_value(struct i2c_client *client, u16 reg, u16 value)\n{\n\tstruct asb100_data *data = i2c_get_clientdata(client);\n\tstruct i2c_client *cl;\n\tint bank;\n\n\tmutex_lock(&data->lock);\n\n\tbank = (reg >> 8) & 0x0f;\n\tif (bank > 2)\n\t\t \n\t\ti2c_smbus_write_byte_data(client, ASB100_REG_BANK, bank);\n\n\tif (bank == 0 || bank > 2) {\n\t\ti2c_smbus_write_byte_data(client, reg & 0xff, value & 0xff);\n\t} else {\n\t\t \n\t\tcl = data->lm75[bank - 1];\n\n\t\t \n\t\tswitch (reg & 0xff) {\n\t\tcase 0x52:  \n\t\t\ti2c_smbus_write_byte_data(cl, 1, value & 0xff);\n\t\t\tbreak;\n\t\tcase 0x53:  \n\t\t\ti2c_smbus_write_word_swapped(cl, 2, value);\n\t\t\tbreak;\n\t\tcase 0x55:  \n\t\t\ti2c_smbus_write_word_swapped(cl, 3, value);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bank > 2)\n\t\ti2c_smbus_write_byte_data(client, ASB100_REG_BANK, 0);\n\n\tmutex_unlock(&data->lock);\n}\n\nstatic void asb100_init_client(struct i2c_client *client)\n{\n\tstruct asb100_data *data = i2c_get_clientdata(client);\n\n\tdata->vrm = vid_which_vrm();\n\n\t \n\tasb100_write_value(client, ASB100_REG_CONFIG,\n\t\t(asb100_read_value(client, ASB100_REG_CONFIG) & 0xf7) | 0x01);\n}\n\nstatic struct asb100_data *asb100_update_device(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct asb100_data *data = i2c_get_clientdata(client);\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\n\t\t|| !data->valid) {\n\n\t\tdev_dbg(&client->dev, \"starting device update...\\n\");\n\n\t\t \n\t\tfor (i = 0; i < 7; i++) {\n\t\t\tdata->in[i] = asb100_read_value(client,\n\t\t\t\tASB100_REG_IN(i));\n\t\t\tdata->in_min[i] = asb100_read_value(client,\n\t\t\t\tASB100_REG_IN_MIN(i));\n\t\t\tdata->in_max[i] = asb100_read_value(client,\n\t\t\t\tASB100_REG_IN_MAX(i));\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tdata->fan[i] = asb100_read_value(client,\n\t\t\t\t\tASB100_REG_FAN(i));\n\t\t\tdata->fan_min[i] = asb100_read_value(client,\n\t\t\t\t\tASB100_REG_FAN_MIN(i));\n\t\t}\n\n\t\t \n\t\tfor (i = 1; i <= 4; i++) {\n\t\t\tdata->temp[i-1] = asb100_read_value(client,\n\t\t\t\t\tASB100_REG_TEMP(i));\n\t\t\tdata->temp_max[i-1] = asb100_read_value(client,\n\t\t\t\t\tASB100_REG_TEMP_MAX(i));\n\t\t\tdata->temp_hyst[i-1] = asb100_read_value(client,\n\t\t\t\t\tASB100_REG_TEMP_HYST(i));\n\t\t}\n\n\t\t \n\t\ti = asb100_read_value(client, ASB100_REG_VID_FANDIV);\n\t\tdata->vid = i & 0x0f;\n\t\tdata->vid |= (asb100_read_value(client,\n\t\t\t\tASB100_REG_CHIPID) & 0x01) << 4;\n\t\tdata->fan_div[0] = (i >> 4) & 0x03;\n\t\tdata->fan_div[1] = (i >> 6) & 0x03;\n\t\tdata->fan_div[2] = (asb100_read_value(client,\n\t\t\t\tASB100_REG_PIN) >> 6) & 0x03;\n\n\t\t \n\t\tdata->pwm = asb100_read_value(client, ASB100_REG_PWM1);\n\n\t\t \n\t\tdata->alarms = asb100_read_value(client, ASB100_REG_ALARM1) +\n\t\t\t(asb100_read_value(client, ASB100_REG_ALARM2) << 8);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\n\t\tdev_dbg(&client->dev, \"... device update complete\\n\");\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\nmodule_i2c_driver(asb100_driver);\n\nMODULE_AUTHOR(\"Mark M. Hoffman <mhoffman@lightlink.com>\");\nMODULE_DESCRIPTION(\"ASB100 Bach driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}