{
  "module_name": "k8temp.c",
  "hash_id": "5dea5c53aaaa35d8579d8a3edfcef76a4e5d790ea41b9cc9b8ba8b4696335928",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/k8temp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/hwmon.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <asm/processor.h>\n\n#define TEMP_FROM_REG(val)\t(((((val) >> 16) & 0xff) - 49) * 1000)\n#define REG_TEMP\t0xe4\n#define SEL_PLACE\t0x40\n#define SEL_CORE\t0x04\n\nstruct k8temp_data {\n\tstruct mutex update_lock;\n\n\t \n\tu8 sensorsp;\t\t \n\tu8 swap_core_select;     \n\tu32 temp_offset;\n};\n\nstatic const struct pci_device_id k8temp_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB_MISC) },\n\t{ 0 },\n};\nMODULE_DEVICE_TABLE(pci, k8temp_ids);\n\nstatic int is_rev_g_desktop(u8 model)\n{\n\tu32 brandidx;\n\n\tif (model < 0x69)\n\t\treturn 0;\n\n\tif (model == 0xc1 || model == 0x6c || model == 0x7c)\n\t\treturn 0;\n\n\t \n\tbrandidx = cpuid_ebx(0x80000001);\n\tbrandidx = (brandidx >> 9) & 0x1f;\n\n\t \n\tif ((model == 0x6f || model == 0x7f) &&\n\t    (brandidx == 0x7 || brandidx == 0x9 || brandidx == 0xc))\n\t\treturn 0;\n\n\t \n\tif (model == 0x6b &&\n\t    (brandidx == 0xb || brandidx == 0xc))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic umode_t\nk8temp_is_visible(const void *drvdata, enum hwmon_sensor_types type,\n\t\t  u32 attr, int channel)\n{\n\tconst struct k8temp_data *data = drvdata;\n\n\tif ((channel & 1) && !(data->sensorsp & SEL_PLACE))\n\t\treturn 0;\n\n\tif ((channel & 2) && !(data->sensorsp & SEL_CORE))\n\t\treturn 0;\n\n\treturn 0444;\n}\n\nstatic int\nk8temp_read(struct device *dev, enum hwmon_sensor_types type,\n\t    u32 attr, int channel, long *val)\n{\n\tstruct k8temp_data *data = dev_get_drvdata(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->parent);\n\tint core, place;\n\tu32 temp;\n\tu8 tmp;\n\n\tcore = (channel >> 1) & 1;\n\tplace = channel & 1;\n\n\tcore ^= data->swap_core_select;\n\n\tmutex_lock(&data->update_lock);\n\tpci_read_config_byte(pdev, REG_TEMP, &tmp);\n\ttmp &= ~(SEL_PLACE | SEL_CORE);\n\tif (core)\n\t\ttmp |= SEL_CORE;\n\tif (place)\n\t\ttmp |= SEL_PLACE;\n\tpci_write_config_byte(pdev, REG_TEMP, tmp);\n\tpci_read_config_dword(pdev, REG_TEMP, &temp);\n\tmutex_unlock(&data->update_lock);\n\n\t*val = TEMP_FROM_REG(temp) + data->temp_offset;\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops k8temp_ops = {\n\t.is_visible = k8temp_is_visible,\n\t.read = k8temp_read,\n};\n\nstatic const struct hwmon_channel_info * const k8temp_info[] = {\n\tHWMON_CHANNEL_INFO(temp,\n\t\tHWMON_T_INPUT, HWMON_T_INPUT, HWMON_T_INPUT, HWMON_T_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info k8temp_chip_info = {\n\t.ops = &k8temp_ops,\n\t.info = k8temp_info,\n};\n\nstatic int k8temp_probe(struct pci_dev *pdev,\n\t\t\t\t  const struct pci_device_id *id)\n{\n\tu8 scfg;\n\tu32 temp;\n\tu8 model, stepping;\n\tstruct k8temp_data *data;\n\tstruct device *hwmon_dev;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct k8temp_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmodel = boot_cpu_data.x86_model;\n\tstepping = boot_cpu_data.x86_stepping;\n\n\t \n\tif ((model == 4 && stepping == 0) ||\n\t    (model == 5 && stepping <= 1))\n\t\treturn -ENODEV;\n\n\t \n\tif (model >= 0x40) {\n\t\tdata->swap_core_select = 1;\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Temperature readouts might be wrong - check erratum #141\\n\");\n\t}\n\n\t \n\tif (is_rev_g_desktop(model))\n\t\tdata->temp_offset = 21000;\n\n\tpci_read_config_byte(pdev, REG_TEMP, &scfg);\n\tscfg &= ~(SEL_PLACE | SEL_CORE);\t \n\tpci_write_config_byte(pdev, REG_TEMP, scfg);\n\tpci_read_config_byte(pdev, REG_TEMP, &scfg);\n\n\tif (scfg & (SEL_PLACE | SEL_CORE)) {\n\t\tdev_err(&pdev->dev, \"Configuration bit(s) stuck at 1!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tscfg |= (SEL_PLACE | SEL_CORE);\n\tpci_write_config_byte(pdev, REG_TEMP, scfg);\n\n\t \n\tpci_read_config_byte(pdev, REG_TEMP, &data->sensorsp);\n\n\tif (data->sensorsp & SEL_PLACE) {\n\t\tscfg &= ~SEL_CORE;\t \n\t\tpci_write_config_byte(pdev, REG_TEMP, scfg);\n\t\tpci_read_config_dword(pdev, REG_TEMP, &temp);\n\t\tscfg |= SEL_CORE;\t \n\t\tif (!((temp >> 16) & 0xff))  \n\t\t\tdata->sensorsp &= ~SEL_PLACE;\n\t}\n\n\tif (data->sensorsp & SEL_CORE) {\n\t\tscfg &= ~SEL_PLACE;\t \n\t\tpci_write_config_byte(pdev, REG_TEMP, scfg);\n\t\tpci_read_config_dword(pdev, REG_TEMP, &temp);\n\t\tif (!((temp >> 16) & 0xff))  \n\t\t\tdata->sensorsp &= ~SEL_CORE;\n\t}\n\n\tmutex_init(&data->update_lock);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&pdev->dev,\n\t\t\t\t\t\t\t \"k8temp\",\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &k8temp_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic struct pci_driver k8temp_driver = {\n\t.name = \"k8temp\",\n\t.id_table = k8temp_ids,\n\t.probe = k8temp_probe,\n};\n\nmodule_pci_driver(k8temp_driver);\n\nMODULE_AUTHOR(\"Rudolf Marek <r.marek@assembler.cz>\");\nMODULE_DESCRIPTION(\"AMD K8 core temperature monitor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}