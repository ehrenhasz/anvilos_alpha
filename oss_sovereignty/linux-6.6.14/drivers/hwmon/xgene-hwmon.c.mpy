{
  "module_name": "xgene-hwmon.c",
  "hash_id": "7ff4ec50de90eb6959a09978e7c111c48091c8b85975475ca31f43c44608c7f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/xgene-hwmon.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/dma-mapping.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/kfifo.h>\n#include <linux/mailbox_controller.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <acpi/pcc.h>\n\n \n#define MSG_TYPE_DBG\t\t\t0\n#define MSG_TYPE_ERR\t\t\t7\n#define MSG_TYPE_PWRMGMT\t\t9\n\n#define MSG_TYPE(v)\t\t\t(((v) & 0xF0000000) >> 28)\n#define MSG_TYPE_SET(v)\t\t\t(((v) << 28) & 0xF0000000)\n#define MSG_SUBTYPE(v)\t\t\t(((v) & 0x0F000000) >> 24)\n#define MSG_SUBTYPE_SET(v)\t\t(((v) << 24) & 0x0F000000)\n\n#define DBG_SUBTYPE_SENSOR_READ\t\t4\n#define SENSOR_RD_MSG\t\t\t0x04FFE902\n#define SENSOR_RD_EN_ADDR(a)\t\t((a) & 0x000FFFFF)\n#define PMD_PWR_REG\t\t\t0x20\n#define PMD_PWR_MW_REG\t\t\t0x26\n#define SOC_PWR_REG\t\t\t0x21\n#define SOC_PWR_MW_REG\t\t\t0x27\n#define SOC_TEMP_REG\t\t\t0x10\n\n#define TEMP_NEGATIVE_BIT\t\t8\n#define SENSOR_INVALID_DATA\t\tBIT(15)\n\n#define PWRMGMT_SUBTYPE_TPC\t\t1\n#define TPC_ALARM\t\t\t2\n#define TPC_GET_ALARM\t\t\t3\n#define TPC_CMD(v)\t\t\t(((v) & 0x00FF0000) >> 16)\n#define TPC_CMD_SET(v)\t\t\t(((v) << 16) & 0x00FF0000)\n#define TPC_EN_MSG(hndl, cmd, type) \\\n\t(MSG_TYPE_SET(MSG_TYPE_PWRMGMT) | \\\n\tMSG_SUBTYPE_SET(hndl) | TPC_CMD_SET(cmd) | type)\n\n \n#define PCC_SIGNATURE_MASK\t\t0x50424300\n#define PCCC_GENERATE_DB_INT\t\tBIT(15)\n#define PCCS_CMD_COMPLETE\t\tBIT(0)\n#define PCCS_SCI_DOORBEL\t\tBIT(1)\n#define PCCS_PLATFORM_NOTIFICATION\tBIT(3)\n \n#define PCC_NUM_RETRIES\t\t\t500\n\n#define ASYNC_MSG_FIFO_SIZE\t\t16\n#define MBOX_OP_TIMEOUTMS\t\t1000\n\n#define WATT_TO_mWATT(x)\t\t((x) * 1000)\n#define mWATT_TO_uWATT(x)\t\t((x) * 1000)\n#define CELSIUS_TO_mCELSIUS(x)\t\t((x) * 1000)\n\n#define to_xgene_hwmon_dev(cl)\t\t\\\n\tcontainer_of(cl, struct xgene_hwmon_dev, mbox_client)\n\nenum xgene_hwmon_version {\n\tXGENE_HWMON_V1 = 0,\n\tXGENE_HWMON_V2 = 1,\n};\n\nstruct slimpro_resp_msg {\n\tu32 msg;\n\tu32 param1;\n\tu32 param2;\n} __packed;\n\nstruct xgene_hwmon_dev {\n\tstruct device\t\t*dev;\n\tstruct mbox_chan\t*mbox_chan;\n\tstruct pcc_mbox_chan\t*pcc_chan;\n\tstruct mbox_client\tmbox_client;\n\tint\t\t\tmbox_idx;\n\n\tspinlock_t\t\tkfifo_lock;\n\tstruct mutex\t\trd_mutex;\n\tstruct completion\trd_complete;\n\tint\t\t\tresp_pending;\n\tstruct slimpro_resp_msg sync_msg;\n\n\tstruct work_struct\tworkq;\n\tstruct kfifo_rec_ptr_1\tasync_msg_fifo;\n\n\tstruct device\t\t*hwmon_dev;\n\tbool\t\t\ttemp_critical_alarm;\n\n\tphys_addr_t\t\tcomm_base_addr;\n\tvoid\t\t\t*pcc_comm_addr;\n\tu64\t\t\tusecs_lat;\n};\n\n \nstatic u16 xgene_word_tst_and_clr(u16 *addr, u16 mask)\n{\n\tu16 ret, val;\n\n\tval = le16_to_cpu(READ_ONCE(*addr));\n\tret = val & mask;\n\tval &= ~mask;\n\tWRITE_ONCE(*addr, cpu_to_le16(val));\n\n\treturn ret;\n}\n\nstatic int xgene_hwmon_pcc_rd(struct xgene_hwmon_dev *ctx, u32 *msg)\n{\n\tstruct acpi_pcct_shared_memory *generic_comm_base = ctx->pcc_comm_addr;\n\tu32 *ptr = (void *)(generic_comm_base + 1);\n\tint rc, i;\n\tu16 val;\n\n\tmutex_lock(&ctx->rd_mutex);\n\tinit_completion(&ctx->rd_complete);\n\tctx->resp_pending = true;\n\n\t \n\tWRITE_ONCE(generic_comm_base->signature,\n\t\t   cpu_to_le32(PCC_SIGNATURE_MASK | ctx->mbox_idx));\n\n\t \n\tWRITE_ONCE(generic_comm_base->command,\n\t\t   cpu_to_le16(MSG_TYPE(msg[0]) | PCCC_GENERATE_DB_INT));\n\n\t \n\tval = le16_to_cpu(READ_ONCE(generic_comm_base->status));\n\tval &= ~PCCS_CMD_COMPLETE;\n\tWRITE_ONCE(generic_comm_base->status, cpu_to_le16(val));\n\n\t \n\tfor (i = 0; i < sizeof(struct slimpro_resp_msg) / 4; i++)\n\t\tWRITE_ONCE(ptr[i], cpu_to_le32(msg[i]));\n\n\t \n\trc = mbox_send_message(ctx->mbox_chan, msg);\n\tif (rc < 0) {\n\t\tdev_err(ctx->dev, \"Mailbox send error %d\\n\", rc);\n\t\tgoto err;\n\t}\n\tif (!wait_for_completion_timeout(&ctx->rd_complete,\n\t\t\t\t\t usecs_to_jiffies(ctx->usecs_lat))) {\n\t\tdev_err(ctx->dev, \"Mailbox operation timed out\\n\");\n\t\trc = -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\n\t \n\tif (MSG_TYPE(ctx->sync_msg.msg) == MSG_TYPE_ERR) {\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmsg[0] = ctx->sync_msg.msg;\n\tmsg[1] = ctx->sync_msg.param1;\n\tmsg[2] = ctx->sync_msg.param2;\n\nerr:\n\tmbox_chan_txdone(ctx->mbox_chan, 0);\n\tctx->resp_pending = false;\n\tmutex_unlock(&ctx->rd_mutex);\n\treturn rc;\n}\n\nstatic int xgene_hwmon_rd(struct xgene_hwmon_dev *ctx, u32 *msg)\n{\n\tint rc;\n\n\tmutex_lock(&ctx->rd_mutex);\n\tinit_completion(&ctx->rd_complete);\n\tctx->resp_pending = true;\n\n\trc = mbox_send_message(ctx->mbox_chan, msg);\n\tif (rc < 0) {\n\t\tdev_err(ctx->dev, \"Mailbox send error %d\\n\", rc);\n\t\tgoto err;\n\t}\n\n\tif (!wait_for_completion_timeout(&ctx->rd_complete,\n\t\t\t\t\t msecs_to_jiffies(MBOX_OP_TIMEOUTMS))) {\n\t\tdev_err(ctx->dev, \"Mailbox operation timed out\\n\");\n\t\trc = -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\n\t \n\tif (MSG_TYPE(ctx->sync_msg.msg) == MSG_TYPE_ERR) {\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmsg[0] = ctx->sync_msg.msg;\n\tmsg[1] = ctx->sync_msg.param1;\n\tmsg[2] = ctx->sync_msg.param2;\n\nerr:\n\tctx->resp_pending = false;\n\tmutex_unlock(&ctx->rd_mutex);\n\treturn rc;\n}\n\nstatic int xgene_hwmon_reg_map_rd(struct xgene_hwmon_dev *ctx, u32 addr,\n\t\t\t\t  u32 *data)\n{\n\tu32 msg[3];\n\tint rc;\n\n\tmsg[0] = SENSOR_RD_MSG;\n\tmsg[1] = SENSOR_RD_EN_ADDR(addr);\n\tmsg[2] = 0;\n\n\tif (acpi_disabled)\n\t\trc = xgene_hwmon_rd(ctx, msg);\n\telse\n\t\trc = xgene_hwmon_pcc_rd(ctx, msg);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (msg[1] & SENSOR_INVALID_DATA)\n\t\treturn -ENODATA;\n\n\t*data = msg[1];\n\n\treturn rc;\n}\n\nstatic int xgene_hwmon_get_notification_msg(struct xgene_hwmon_dev *ctx,\n\t\t\t\t\t    u32 *amsg)\n{\n\tu32 msg[3];\n\tint rc;\n\n\tmsg[0] = TPC_EN_MSG(PWRMGMT_SUBTYPE_TPC, TPC_GET_ALARM, 0);\n\tmsg[1] = 0;\n\tmsg[2] = 0;\n\n\trc = xgene_hwmon_pcc_rd(ctx, msg);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tamsg[0] = msg[0];\n\tamsg[1] = msg[1];\n\tamsg[2] = msg[2];\n\n\treturn rc;\n}\n\nstatic int xgene_hwmon_get_cpu_pwr(struct xgene_hwmon_dev *ctx, u32 *val)\n{\n\tu32 watt, mwatt;\n\tint rc;\n\n\trc = xgene_hwmon_reg_map_rd(ctx, PMD_PWR_REG, &watt);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = xgene_hwmon_reg_map_rd(ctx, PMD_PWR_MW_REG, &mwatt);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*val = WATT_TO_mWATT(watt) + mwatt;\n\treturn 0;\n}\n\nstatic int xgene_hwmon_get_io_pwr(struct xgene_hwmon_dev *ctx, u32 *val)\n{\n\tu32 watt, mwatt;\n\tint rc;\n\n\trc = xgene_hwmon_reg_map_rd(ctx, SOC_PWR_REG, &watt);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = xgene_hwmon_reg_map_rd(ctx, SOC_PWR_MW_REG, &mwatt);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*val = WATT_TO_mWATT(watt) + mwatt;\n\treturn 0;\n}\n\nstatic int xgene_hwmon_get_temp(struct xgene_hwmon_dev *ctx, u32 *val)\n{\n\treturn xgene_hwmon_reg_map_rd(ctx, SOC_TEMP_REG, val);\n}\n\n \nstatic ssize_t temp1_input_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct xgene_hwmon_dev *ctx = dev_get_drvdata(dev);\n\tint rc, temp;\n\tu32 val;\n\n\trc = xgene_hwmon_get_temp(ctx, &val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttemp = sign_extend32(val, TEMP_NEGATIVE_BIT);\n\n\treturn sysfs_emit(buf, \"%d\\n\", CELSIUS_TO_mCELSIUS(temp));\n}\n\nstatic ssize_t temp1_label_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn sysfs_emit(buf, \"SoC Temperature\\n\");\n}\n\nstatic ssize_t temp1_critical_alarm_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *devattr,\n\t\t\t\t\t char *buf)\n{\n\tstruct xgene_hwmon_dev *ctx = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ctx->temp_critical_alarm);\n}\n\nstatic ssize_t power1_label_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"CPU power\\n\");\n}\n\nstatic ssize_t power2_label_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"IO power\\n\");\n}\n\nstatic ssize_t power1_input_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct xgene_hwmon_dev *ctx = dev_get_drvdata(dev);\n\tu32 val;\n\tint rc;\n\n\trc = xgene_hwmon_get_cpu_pwr(ctx, &val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn sysfs_emit(buf, \"%u\\n\", mWATT_TO_uWATT(val));\n}\n\nstatic ssize_t power2_input_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct xgene_hwmon_dev *ctx = dev_get_drvdata(dev);\n\tu32 val;\n\tint rc;\n\n\trc = xgene_hwmon_get_io_pwr(ctx, &val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn sysfs_emit(buf, \"%u\\n\", mWATT_TO_uWATT(val));\n}\n\nstatic DEVICE_ATTR_RO(temp1_label);\nstatic DEVICE_ATTR_RO(temp1_input);\nstatic DEVICE_ATTR_RO(temp1_critical_alarm);\nstatic DEVICE_ATTR_RO(power1_label);\nstatic DEVICE_ATTR_RO(power1_input);\nstatic DEVICE_ATTR_RO(power2_label);\nstatic DEVICE_ATTR_RO(power2_input);\n\nstatic struct attribute *xgene_hwmon_attrs[] = {\n\t&dev_attr_temp1_label.attr,\n\t&dev_attr_temp1_input.attr,\n\t&dev_attr_temp1_critical_alarm.attr,\n\t&dev_attr_power1_label.attr,\n\t&dev_attr_power1_input.attr,\n\t&dev_attr_power2_label.attr,\n\t&dev_attr_power2_input.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(xgene_hwmon);\n\nstatic int xgene_hwmon_tpc_alarm(struct xgene_hwmon_dev *ctx,\n\t\t\t\t struct slimpro_resp_msg *amsg)\n{\n\tctx->temp_critical_alarm = !!amsg->param2;\n\tsysfs_notify(&ctx->dev->kobj, NULL, \"temp1_critical_alarm\");\n\n\treturn 0;\n}\n\nstatic void xgene_hwmon_process_pwrmsg(struct xgene_hwmon_dev *ctx,\n\t\t\t\t       struct slimpro_resp_msg *amsg)\n{\n\tif ((MSG_SUBTYPE(amsg->msg) == PWRMGMT_SUBTYPE_TPC) &&\n\t    (TPC_CMD(amsg->msg) == TPC_ALARM))\n\t\txgene_hwmon_tpc_alarm(ctx, amsg);\n}\n\n \nstatic void xgene_hwmon_evt_work(struct work_struct *work)\n{\n\tstruct slimpro_resp_msg amsg;\n\tstruct xgene_hwmon_dev *ctx;\n\tint ret;\n\n\tctx = container_of(work, struct xgene_hwmon_dev, workq);\n\twhile (kfifo_out_spinlocked(&ctx->async_msg_fifo, &amsg,\n\t\t\t\t    sizeof(struct slimpro_resp_msg),\n\t\t\t\t    &ctx->kfifo_lock)) {\n\t\t \n\t\tif (!acpi_disabled) {\n\t\t\tret = xgene_hwmon_get_notification_msg(ctx,\n\t\t\t\t\t\t\t       (u32 *)&amsg);\n\t\t\tif (ret < 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (MSG_TYPE(amsg.msg) == MSG_TYPE_PWRMGMT)\n\t\t\txgene_hwmon_process_pwrmsg(ctx, &amsg);\n\t}\n}\n\nstatic int xgene_hwmon_rx_ready(struct xgene_hwmon_dev *ctx, void *msg)\n{\n\tif (IS_ERR_OR_NULL(ctx->hwmon_dev) && !ctx->resp_pending) {\n\t\t \n\t\tkfifo_in_spinlocked(&ctx->async_msg_fifo, msg,\n\t\t\t\t    sizeof(struct slimpro_resp_msg),\n\t\t\t\t    &ctx->kfifo_lock);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void xgene_hwmon_rx_cb(struct mbox_client *cl, void *msg)\n{\n\tstruct xgene_hwmon_dev *ctx = to_xgene_hwmon_dev(cl);\n\n\t \n\tif (xgene_hwmon_rx_ready(ctx, msg) < 0)\n\t\treturn;\n\n\t \n\n\t \n\tif (ctx->resp_pending &&\n\t    ((MSG_TYPE(((u32 *)msg)[0]) == MSG_TYPE_ERR) ||\n\t     (MSG_TYPE(((u32 *)msg)[0]) == MSG_TYPE_DBG &&\n\t      MSG_SUBTYPE(((u32 *)msg)[0]) == DBG_SUBTYPE_SENSOR_READ) ||\n\t     (MSG_TYPE(((u32 *)msg)[0]) == MSG_TYPE_PWRMGMT &&\n\t      MSG_SUBTYPE(((u32 *)msg)[0]) == PWRMGMT_SUBTYPE_TPC &&\n\t      TPC_CMD(((u32 *)msg)[0]) == TPC_ALARM))) {\n\t\tctx->sync_msg.msg = ((u32 *)msg)[0];\n\t\tctx->sync_msg.param1 = ((u32 *)msg)[1];\n\t\tctx->sync_msg.param2 = ((u32 *)msg)[2];\n\n\t\t \n\t\tcomplete(&ctx->rd_complete);\n\n\t\treturn;\n\t}\n\n\t \n\tkfifo_in_spinlocked(&ctx->async_msg_fifo, msg,\n\t\t\t    sizeof(struct slimpro_resp_msg), &ctx->kfifo_lock);\n\t \n\tschedule_work(&ctx->workq);\n}\n\n \nstatic void xgene_hwmon_pcc_rx_cb(struct mbox_client *cl, void *msg)\n{\n\tstruct xgene_hwmon_dev *ctx = to_xgene_hwmon_dev(cl);\n\tstruct acpi_pcct_shared_memory *generic_comm_base = ctx->pcc_comm_addr;\n\tstruct slimpro_resp_msg amsg;\n\n\t \n\tif (xgene_hwmon_rx_ready(ctx, &amsg) < 0)\n\t\treturn;\n\n\tmsg = generic_comm_base + 1;\n\t \n\tif (!xgene_word_tst_and_clr(&generic_comm_base->status,\n\t\t\t\t    PCCS_SCI_DOORBEL))\n\t\treturn;\n\n\t \n\n\t \n\tif (ctx->resp_pending &&\n\t    ((MSG_TYPE(((u32 *)msg)[0]) == MSG_TYPE_ERR) ||\n\t     (MSG_TYPE(((u32 *)msg)[0]) == MSG_TYPE_DBG &&\n\t      MSG_SUBTYPE(((u32 *)msg)[0]) == DBG_SUBTYPE_SENSOR_READ) ||\n\t     (MSG_TYPE(((u32 *)msg)[0]) == MSG_TYPE_PWRMGMT &&\n\t      MSG_SUBTYPE(((u32 *)msg)[0]) == PWRMGMT_SUBTYPE_TPC &&\n\t      TPC_CMD(((u32 *)msg)[0]) == TPC_ALARM))) {\n\t\t \n\t\tif (xgene_word_tst_and_clr(&generic_comm_base->status,\n\t\t\t\t\t   PCCS_CMD_COMPLETE)) {\n\t\t\tctx->sync_msg.msg = ((u32 *)msg)[0];\n\t\t\tctx->sync_msg.param1 = ((u32 *)msg)[1];\n\t\t\tctx->sync_msg.param2 = ((u32 *)msg)[2];\n\n\t\t\t \n\t\t\tcomplete(&ctx->rd_complete);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\n\t \n\tkfifo_in_spinlocked(&ctx->async_msg_fifo, &amsg,\n\t\t\t    sizeof(struct slimpro_resp_msg), &ctx->kfifo_lock);\n\t \n\tschedule_work(&ctx->workq);\n}\n\nstatic void xgene_hwmon_tx_done(struct mbox_client *cl, void *msg, int ret)\n{\n\tif (ret) {\n\t\tdev_dbg(cl->dev, \"TX did not complete: CMD sent:%x, ret:%d\\n\",\n\t\t\t*(u16 *)msg, ret);\n\t} else {\n\t\tdev_dbg(cl->dev, \"TX completed. CMD sent:%x, ret:%d\\n\",\n\t\t\t*(u16 *)msg, ret);\n\t}\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id xgene_hwmon_acpi_match[] = {\n\t{\"APMC0D29\", XGENE_HWMON_V1},\n\t{\"APMC0D8A\", XGENE_HWMON_V2},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, xgene_hwmon_acpi_match);\n#endif\n\nstatic int xgene_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct xgene_hwmon_dev *ctx;\n\tstruct mbox_client *cl;\n\tint rc;\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ctx);\n\tcl = &ctx->mbox_client;\n\n\tspin_lock_init(&ctx->kfifo_lock);\n\tmutex_init(&ctx->rd_mutex);\n\n\trc = kfifo_alloc(&ctx->async_msg_fifo,\n\t\t\t sizeof(struct slimpro_resp_msg) * ASYNC_MSG_FIFO_SIZE,\n\t\t\t GFP_KERNEL);\n\tif (rc)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ctx->workq, xgene_hwmon_evt_work);\n\n\t \n\tcl->dev = &pdev->dev;\n\tcl->tx_done = xgene_hwmon_tx_done;\n\tcl->tx_block = false;\n\tcl->tx_tout = MBOX_OP_TIMEOUTMS;\n\tcl->knows_txdone = false;\n\tif (acpi_disabled) {\n\t\tcl->rx_callback = xgene_hwmon_rx_cb;\n\t\tctx->mbox_chan = mbox_request_channel(cl, 0);\n\t\tif (IS_ERR(ctx->mbox_chan)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"SLIMpro mailbox channel request failed\\n\");\n\t\t\trc = -ENODEV;\n\t\t\tgoto out_mbox_free;\n\t\t}\n\t} else {\n\t\tstruct pcc_mbox_chan *pcc_chan;\n\t\tconst struct acpi_device_id *acpi_id;\n\t\tint version;\n\n\t\tacpi_id = acpi_match_device(pdev->dev.driver->acpi_match_table,\n\t\t\t\t\t    &pdev->dev);\n\t\tif (!acpi_id) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_mbox_free;\n\t\t}\n\n\t\tversion = (int)acpi_id->driver_data;\n\n\t\tif (device_property_read_u32(&pdev->dev, \"pcc-channel\",\n\t\t\t\t\t     &ctx->mbox_idx)) {\n\t\t\tdev_err(&pdev->dev, \"no pcc-channel property\\n\");\n\t\t\trc = -ENODEV;\n\t\t\tgoto out_mbox_free;\n\t\t}\n\n\t\tcl->rx_callback = xgene_hwmon_pcc_rx_cb;\n\t\tpcc_chan = pcc_mbox_request_channel(cl, ctx->mbox_idx);\n\t\tif (IS_ERR(pcc_chan)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"PPC channel request failed\\n\");\n\t\t\trc = -ENODEV;\n\t\t\tgoto out_mbox_free;\n\t\t}\n\n\t\tctx->pcc_chan = pcc_chan;\n\t\tctx->mbox_chan = pcc_chan->mchan;\n\n\t\tif (!ctx->mbox_chan->mbox->txdone_irq) {\n\t\t\tdev_err(&pdev->dev, \"PCC IRQ not supported\\n\");\n\t\t\trc = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tctx->comm_base_addr = pcc_chan->shmem_base_addr;\n\t\tif (ctx->comm_base_addr) {\n\t\t\tif (version == XGENE_HWMON_V2)\n\t\t\t\tctx->pcc_comm_addr = (void __force *)devm_ioremap(&pdev->dev,\n\t\t\t\t\t\t\t\t  ctx->comm_base_addr,\n\t\t\t\t\t\t\t\t  pcc_chan->shmem_size);\n\t\t\telse\n\t\t\t\tctx->pcc_comm_addr = devm_memremap(&pdev->dev,\n\t\t\t\t\t\t\t\t   ctx->comm_base_addr,\n\t\t\t\t\t\t\t\t   pcc_chan->shmem_size,\n\t\t\t\t\t\t\t\t   MEMREMAP_WB);\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"Failed to get PCC comm region\\n\");\n\t\t\trc = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ctx->pcc_comm_addr) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to ioremap PCC comm region\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tctx->usecs_lat = PCC_NUM_RETRIES * pcc_chan->latency;\n\t}\n\n\tctx->hwmon_dev = hwmon_device_register_with_groups(ctx->dev,\n\t\t\t\t\t\t\t   \"apm_xgene\",\n\t\t\t\t\t\t\t   ctx,\n\t\t\t\t\t\t\t   xgene_hwmon_groups);\n\tif (IS_ERR(ctx->hwmon_dev)) {\n\t\tdev_err(&pdev->dev, \"Failed to register HW monitor device\\n\");\n\t\trc = PTR_ERR(ctx->hwmon_dev);\n\t\tgoto out;\n\t}\n\n\t \n\tschedule_work(&ctx->workq);\n\n\tdev_info(&pdev->dev, \"APM X-Gene SoC HW monitor driver registered\\n\");\n\n\treturn 0;\n\nout:\n\tif (acpi_disabled)\n\t\tmbox_free_channel(ctx->mbox_chan);\n\telse\n\t\tpcc_mbox_free_channel(ctx->pcc_chan);\nout_mbox_free:\n\tkfifo_free(&ctx->async_msg_fifo);\n\n\treturn rc;\n}\n\nstatic int xgene_hwmon_remove(struct platform_device *pdev)\n{\n\tstruct xgene_hwmon_dev *ctx = platform_get_drvdata(pdev);\n\n\tcancel_work_sync(&ctx->workq);\n\thwmon_device_unregister(ctx->hwmon_dev);\n\tkfifo_free(&ctx->async_msg_fifo);\n\tif (acpi_disabled)\n\t\tmbox_free_channel(ctx->mbox_chan);\n\telse\n\t\tpcc_mbox_free_channel(ctx->pcc_chan);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id xgene_hwmon_of_match[] = {\n\t{.compatible = \"apm,xgene-slimpro-hwmon\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, xgene_hwmon_of_match);\n\nstatic struct platform_driver xgene_hwmon_driver = {\n\t.probe = xgene_hwmon_probe,\n\t.remove = xgene_hwmon_remove,\n\t.driver = {\n\t\t.name = \"xgene-slimpro-hwmon\",\n\t\t.of_match_table = xgene_hwmon_of_match,\n\t\t.acpi_match_table = ACPI_PTR(xgene_hwmon_acpi_match),\n\t},\n};\nmodule_platform_driver(xgene_hwmon_driver);\n\nMODULE_DESCRIPTION(\"APM X-Gene SoC hardware monitor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}