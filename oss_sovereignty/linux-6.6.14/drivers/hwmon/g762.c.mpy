{
  "module_name": "g762.c",
  "hash_id": "c6c58a8443c29648af881b973feb72fd33de5e614ac1cd141ffdf91a0f82a97a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/g762.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/platform_data/g762.h>\n\n#define DRVNAME \"g762\"\n\nstatic const struct i2c_device_id g762_id[] = {\n\t{ \"g762\", 0 },\n\t{ \"g763\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, g762_id);\n\nenum g762_regs {\n\tG762_REG_SET_CNT  = 0x00,\n\tG762_REG_ACT_CNT  = 0x01,\n\tG762_REG_FAN_STA  = 0x02,\n\tG762_REG_SET_OUT  = 0x03,\n\tG762_REG_FAN_CMD1 = 0x04,\n\tG762_REG_FAN_CMD2 = 0x05,\n};\n\n \n#define G762_REG_FAN_CMD1_DET_FAN_FAIL  0x80  \n#define G762_REG_FAN_CMD1_DET_FAN_OOC   0x40  \n#define G762_REG_FAN_CMD1_OUT_MODE      0x20  \n#define G762_REG_FAN_CMD1_FAN_MODE      0x10  \n#define G762_REG_FAN_CMD1_CLK_DIV_ID1   0x08  \n#define G762_REG_FAN_CMD1_CLK_DIV_ID0   0x04\n#define G762_REG_FAN_CMD1_PWM_POLARITY  0x02  \n#define G762_REG_FAN_CMD1_PULSE_PER_REV 0x01  \n\n#define G762_REG_FAN_CMD2_GEAR_MODE_1   0x08  \n#define G762_REG_FAN_CMD2_GEAR_MODE_0   0x04\n#define G762_REG_FAN_CMD2_FAN_STARTV_1  0x02  \n#define G762_REG_FAN_CMD2_FAN_STARTV_0  0x01\n\n#define G762_REG_FAN_STA_FAIL           0x02  \n#define G762_REG_FAN_STA_OOC            0x01  \n\n \n#define G762_OUT_MODE_PWM            1\n#define G762_OUT_MODE_DC             0\n\n#define G762_FAN_MODE_CLOSED_LOOP    2\n#define G762_FAN_MODE_OPEN_LOOP      1\n\n#define G762_PWM_POLARITY_NEGATIVE   1\n#define G762_PWM_POLARITY_POSITIVE   0\n\n \n#define G762_UPDATE_INTERVAL    HZ\n\n \n#define G762_PULSE_FROM_REG(reg) \\\n\t((((reg) & G762_REG_FAN_CMD1_PULSE_PER_REV) + 1) << 1)\n\n \n#define G762_CLKDIV_FROM_REG(reg) \\\n\t(1 << (((reg) & (G762_REG_FAN_CMD1_CLK_DIV_ID0 |\t\\\n\t\t\t G762_REG_FAN_CMD1_CLK_DIV_ID1)) >> 2))\n\n \n#define G762_GEARMULT_FROM_REG(reg) \\\n\t(1 << (((reg) & (G762_REG_FAN_CMD2_GEAR_MODE_0 |\t\\\n\t\t\t G762_REG_FAN_CMD2_GEAR_MODE_1)) >> 2))\n\nstruct g762_data {\n\tstruct i2c_client *client;\n\tstruct clk *clk;\n\n\t \n\tstruct mutex update_lock;\n\n\t \n\tu32 clk_freq;\n\n\t \n\tbool valid;\n\tunsigned long last_updated;  \n\n\tu8 set_cnt;   \n\tu8 act_cnt;   \n\tu8 fan_sta;   \n\tu8 set_out;   \n\tu8 fan_cmd1;  \n\tu8 fan_cmd2;  \n};\n\n \nstatic inline unsigned int rpm_from_cnt(u8 cnt, u32 clk_freq, u16 p,\n\t\t\t\t\tu8 clk_div, u8 gear_mult)\n{\n\tif (cnt == 0xff)   \n\t\treturn 0;\n\n\treturn (clk_freq * 30 * gear_mult) / ((cnt ? cnt : 1) * p * clk_div);\n}\n\n \nstatic inline unsigned char cnt_from_rpm(unsigned long rpm, u32 clk_freq, u16 p,\n\t\t\t\t\t u8 clk_div, u8 gear_mult)\n{\n\tunsigned long f1 = clk_freq * 30 * gear_mult;\n\tunsigned long f2 = p * clk_div;\n\n\tif (!rpm)\t \n\t\treturn 0xff;\n\n\trpm = clamp_val(rpm, f1 / (255 * f2), ULONG_MAX / f2);\n\treturn DIV_ROUND_CLOSEST(f1, rpm * f2);\n}\n\n \nstatic struct g762_data *g762_update_client(struct device *dev)\n{\n\tstruct g762_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret = 0;\n\n\tmutex_lock(&data->update_lock);\n\tif (time_before(jiffies, data->last_updated + G762_UPDATE_INTERVAL) &&\n\t    likely(data->valid))\n\t\tgoto out;\n\n\tret = i2c_smbus_read_byte_data(client, G762_REG_SET_CNT);\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->set_cnt = ret;\n\n\tret = i2c_smbus_read_byte_data(client, G762_REG_ACT_CNT);\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->act_cnt = ret;\n\n\tret = i2c_smbus_read_byte_data(client, G762_REG_FAN_STA);\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->fan_sta = ret;\n\n\tret = i2c_smbus_read_byte_data(client, G762_REG_SET_OUT);\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->set_out = ret;\n\n\tret = i2c_smbus_read_byte_data(client, G762_REG_FAN_CMD1);\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->fan_cmd1 = ret;\n\n\tret = i2c_smbus_read_byte_data(client, G762_REG_FAN_CMD2);\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->fan_cmd2 = ret;\n\n\tdata->last_updated = jiffies;\n\tdata->valid = true;\n out:\n\tmutex_unlock(&data->update_lock);\n\n\tif (ret < 0)  \n\t\tdata = ERR_PTR(ret);\n\n\treturn data;\n}\n\n \n\n \nstatic int do_set_clk_freq(struct device *dev, unsigned long val)\n{\n\tstruct g762_data *data = dev_get_drvdata(dev);\n\n\tif (val > 0xffffff)\n\t\treturn -EINVAL;\n\tif (!val)\n\t\tval = 32768;\n\n\tdata->clk_freq = val;\n\n\treturn 0;\n}\n\n \nstatic int do_set_pwm_mode(struct device *dev, unsigned long val)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\tint ret;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmutex_lock(&data->update_lock);\n\tswitch (val) {\n\tcase G762_OUT_MODE_PWM:\n\t\tdata->fan_cmd1 |=  G762_REG_FAN_CMD1_OUT_MODE;\n\t\tbreak;\n\tcase G762_OUT_MODE_DC:\n\t\tdata->fan_cmd1 &= ~G762_REG_FAN_CMD1_OUT_MODE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = i2c_smbus_write_byte_data(data->client, G762_REG_FAN_CMD1,\n\t\t\t\t\tdata->fan_cmd1);\n\tdata->valid = false;\n out:\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\n \nstatic int do_set_fan_div(struct device *dev, unsigned long val)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\tint ret;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmutex_lock(&data->update_lock);\n\tswitch (val) {\n\tcase 1:\n\t\tdata->fan_cmd1 &= ~G762_REG_FAN_CMD1_CLK_DIV_ID0;\n\t\tdata->fan_cmd1 &= ~G762_REG_FAN_CMD1_CLK_DIV_ID1;\n\t\tbreak;\n\tcase 2:\n\t\tdata->fan_cmd1 |=  G762_REG_FAN_CMD1_CLK_DIV_ID0;\n\t\tdata->fan_cmd1 &= ~G762_REG_FAN_CMD1_CLK_DIV_ID1;\n\t\tbreak;\n\tcase 4:\n\t\tdata->fan_cmd1 &= ~G762_REG_FAN_CMD1_CLK_DIV_ID0;\n\t\tdata->fan_cmd1 |=  G762_REG_FAN_CMD1_CLK_DIV_ID1;\n\t\tbreak;\n\tcase 8:\n\t\tdata->fan_cmd1 |=  G762_REG_FAN_CMD1_CLK_DIV_ID0;\n\t\tdata->fan_cmd1 |=  G762_REG_FAN_CMD1_CLK_DIV_ID1;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = i2c_smbus_write_byte_data(data->client, G762_REG_FAN_CMD1,\n\t\t\t\t\tdata->fan_cmd1);\n\tdata->valid = false;\n out:\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\n \nstatic int do_set_fan_gear_mode(struct device *dev, unsigned long val)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\tint ret;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmutex_lock(&data->update_lock);\n\tswitch (val) {\n\tcase 0:\n\t\tdata->fan_cmd2 &= ~G762_REG_FAN_CMD2_GEAR_MODE_0;\n\t\tdata->fan_cmd2 &= ~G762_REG_FAN_CMD2_GEAR_MODE_1;\n\t\tbreak;\n\tcase 1:\n\t\tdata->fan_cmd2 |=  G762_REG_FAN_CMD2_GEAR_MODE_0;\n\t\tdata->fan_cmd2 &= ~G762_REG_FAN_CMD2_GEAR_MODE_1;\n\t\tbreak;\n\tcase 2:\n\t\tdata->fan_cmd2 &= ~G762_REG_FAN_CMD2_GEAR_MODE_0;\n\t\tdata->fan_cmd2 |=  G762_REG_FAN_CMD2_GEAR_MODE_1;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = i2c_smbus_write_byte_data(data->client, G762_REG_FAN_CMD2,\n\t\t\t\t\tdata->fan_cmd2);\n\tdata->valid = false;\n out:\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\n \nstatic int do_set_fan_pulses(struct device *dev, unsigned long val)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\tint ret;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmutex_lock(&data->update_lock);\n\tswitch (val) {\n\tcase 2:\n\t\tdata->fan_cmd1 &= ~G762_REG_FAN_CMD1_PULSE_PER_REV;\n\t\tbreak;\n\tcase 4:\n\t\tdata->fan_cmd1 |=  G762_REG_FAN_CMD1_PULSE_PER_REV;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = i2c_smbus_write_byte_data(data->client, G762_REG_FAN_CMD1,\n\t\t\t\t\tdata->fan_cmd1);\n\tdata->valid = false;\n out:\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\n \nstatic int do_set_pwm_enable(struct device *dev, unsigned long val)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\tint ret;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmutex_lock(&data->update_lock);\n\tswitch (val) {\n\tcase G762_FAN_MODE_CLOSED_LOOP:\n\t\tdata->fan_cmd1 |=  G762_REG_FAN_CMD1_FAN_MODE;\n\t\tbreak;\n\tcase G762_FAN_MODE_OPEN_LOOP:\n\t\tdata->fan_cmd1 &= ~G762_REG_FAN_CMD1_FAN_MODE;\n\t\t \n\t\tif (data->set_cnt == 0xff)\n\t\t\ti2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t\t  G762_REG_SET_CNT, 254);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = i2c_smbus_write_byte_data(data->client, G762_REG_FAN_CMD1,\n\t\t\t\t\tdata->fan_cmd1);\n\tdata->valid = false;\n out:\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\n \nstatic int do_set_pwm_polarity(struct device *dev, unsigned long val)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\tint ret;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmutex_lock(&data->update_lock);\n\tswitch (val) {\n\tcase G762_PWM_POLARITY_POSITIVE:\n\t\tdata->fan_cmd1 &= ~G762_REG_FAN_CMD1_PWM_POLARITY;\n\t\tbreak;\n\tcase G762_PWM_POLARITY_NEGATIVE:\n\t\tdata->fan_cmd1 |=  G762_REG_FAN_CMD1_PWM_POLARITY;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = i2c_smbus_write_byte_data(data->client, G762_REG_FAN_CMD1,\n\t\t\t\t\tdata->fan_cmd1);\n\tdata->valid = false;\n out:\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\n \nstatic int do_set_pwm(struct device *dev, unsigned long val)\n{\n\tstruct g762_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tret = i2c_smbus_write_byte_data(client, G762_REG_SET_OUT, val);\n\tdata->valid = false;\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\n \nstatic int do_set_fan_target(struct device *dev, unsigned long val)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\tint ret;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmutex_lock(&data->update_lock);\n\tdata->set_cnt = cnt_from_rpm(val, data->clk_freq,\n\t\t\t\t     G762_PULSE_FROM_REG(data->fan_cmd1),\n\t\t\t\t     G762_CLKDIV_FROM_REG(data->fan_cmd1),\n\t\t\t\t     G762_GEARMULT_FROM_REG(data->fan_cmd2));\n\tret = i2c_smbus_write_byte_data(data->client, G762_REG_SET_CNT,\n\t\t\t\t\tdata->set_cnt);\n\tdata->valid = false;\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\n \nstatic int do_set_fan_startv(struct device *dev, unsigned long val)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\tint ret;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmutex_lock(&data->update_lock);\n\tswitch (val) {\n\tcase 0:\n\t\tdata->fan_cmd2 &= ~G762_REG_FAN_CMD2_FAN_STARTV_0;\n\t\tdata->fan_cmd2 &= ~G762_REG_FAN_CMD2_FAN_STARTV_1;\n\t\tbreak;\n\tcase 1:\n\t\tdata->fan_cmd2 |=  G762_REG_FAN_CMD2_FAN_STARTV_0;\n\t\tdata->fan_cmd2 &= ~G762_REG_FAN_CMD2_FAN_STARTV_1;\n\t\tbreak;\n\tcase 2:\n\t\tdata->fan_cmd2 &= ~G762_REG_FAN_CMD2_FAN_STARTV_0;\n\t\tdata->fan_cmd2 |=  G762_REG_FAN_CMD2_FAN_STARTV_1;\n\t\tbreak;\n\tcase 3:\n\t\tdata->fan_cmd2 |=  G762_REG_FAN_CMD2_FAN_STARTV_0;\n\t\tdata->fan_cmd2 |=  G762_REG_FAN_CMD2_FAN_STARTV_1;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = i2c_smbus_write_byte_data(data->client, G762_REG_FAN_CMD2,\n\t\t\t\t\tdata->fan_cmd2);\n\tdata->valid = false;\n out:\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\n \n\n#ifdef CONFIG_OF\nstatic const struct of_device_id g762_dt_match[] = {\n\t{ .compatible = \"gmt,g762\" },\n\t{ .compatible = \"gmt,g763\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, g762_dt_match);\n\n \nstatic void g762_of_clock_disable(void *data)\n{\n\tstruct g762_data *g762 = data;\n\n\tclk_disable_unprepare(g762->clk);\n\tclk_put(g762->clk);\n}\n\nstatic int g762_of_clock_enable(struct i2c_client *client)\n{\n\tstruct g762_data *data;\n\tunsigned long clk_freq;\n\tstruct clk *clk;\n\tint ret;\n\n\tif (!client->dev.of_node)\n\t\treturn 0;\n\n\tclk = of_clk_get(client->dev.of_node, 0);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&client->dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to enable clock\\n\");\n\t\tgoto clk_put;\n\t}\n\n\tclk_freq = clk_get_rate(clk);\n\tret = do_set_clk_freq(&client->dev, clk_freq);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"invalid clock freq %lu\\n\", clk_freq);\n\t\tgoto clk_unprep;\n\t}\n\n\tdata = i2c_get_clientdata(client);\n\tdata->clk = clk;\n\n\tret = devm_add_action(&client->dev, g762_of_clock_disable, data);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to add disable clock action\\n\");\n\t\tgoto clk_unprep;\n\t}\n\n\treturn 0;\n\n clk_unprep:\n\tclk_disable_unprepare(clk);\n\n clk_put:\n\tclk_put(clk);\n\n\treturn ret;\n}\n\nstatic int g762_of_prop_import_one(struct i2c_client *client,\n\t\t\t\t   const char *pname,\n\t\t\t\t   int (*psetter)(struct device *dev,\n\t\t\t\t\t\t  unsigned long val))\n{\n\tint ret;\n\tu32 pval;\n\n\tif (of_property_read_u32(client->dev.of_node, pname, &pval))\n\t\treturn 0;\n\n\tdev_dbg(&client->dev, \"found %s (%d)\\n\", pname, pval);\n\tret = (*psetter)(&client->dev, pval);\n\tif (ret)\n\t\tdev_err(&client->dev, \"unable to set %s (%d)\\n\", pname, pval);\n\n\treturn ret;\n}\n\nstatic int g762_of_prop_import(struct i2c_client *client)\n{\n\tint ret;\n\n\tif (!client->dev.of_node)\n\t\treturn 0;\n\n\tret = g762_of_prop_import_one(client, \"fan_gear_mode\",\n\t\t\t\t      do_set_fan_gear_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = g762_of_prop_import_one(client, \"pwm_polarity\",\n\t\t\t\t      do_set_pwm_polarity);\n\tif (ret)\n\t\treturn ret;\n\n\treturn g762_of_prop_import_one(client, \"fan_startv\",\n\t\t\t\t       do_set_fan_startv);\n}\n\n#else\nstatic int g762_of_prop_import(struct i2c_client *client)\n{\n\treturn 0;\n}\n\nstatic int g762_of_clock_enable(struct i2c_client *client)\n{\n\treturn 0;\n}\n#endif\n\n \n\nstatic int g762_pdata_prop_import(struct i2c_client *client)\n{\n\tstruct g762_platform_data *pdata = dev_get_platdata(&client->dev);\n\tint ret;\n\n\tif (!pdata)\n\t\treturn 0;\n\n\tret = do_set_fan_gear_mode(&client->dev, pdata->fan_gear_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = do_set_pwm_polarity(&client->dev, pdata->pwm_polarity);\n\tif (ret)\n\t\treturn ret;\n\n\tret = do_set_fan_startv(&client->dev, pdata->fan_startv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn do_set_clk_freq(&client->dev, pdata->clk_freq);\n}\n\n \n\n \nstatic ssize_t fan1_input_show(struct device *dev,\n\t\t\t       struct device_attribute *da, char *buf)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\tunsigned int rpm = 0;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmutex_lock(&data->update_lock);\n\t \n\tif (data->fan_sta & G762_REG_FAN_STA_OOC) {\n\t\trpm = rpm_from_cnt(data->act_cnt, data->clk_freq,\n\t\t\t\t   G762_PULSE_FROM_REG(data->fan_cmd1),\n\t\t\t\t   G762_CLKDIV_FROM_REG(data->fan_cmd1),\n\t\t\t\t   G762_GEARMULT_FROM_REG(data->fan_cmd2));\n\t}\n\tmutex_unlock(&data->update_lock);\n\n\treturn sprintf(buf, \"%u\\n\", rpm);\n}\n\n \nstatic ssize_t pwm1_mode_show(struct device *dev, struct device_attribute *da,\n\t\t\t      char *buf)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       !!(data->fan_cmd1 & G762_REG_FAN_CMD1_OUT_MODE));\n}\n\nstatic ssize_t pwm1_mode_store(struct device *dev,\n\t\t\t       struct device_attribute *da, const char *buf,\n\t\t\t       size_t count)\n{\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tret = do_set_pwm_mode(dev, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\n \nstatic ssize_t fan1_div_show(struct device *dev, struct device_attribute *da,\n\t\t\t     char *buf)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", G762_CLKDIV_FROM_REG(data->fan_cmd1));\n}\n\nstatic ssize_t fan1_div_store(struct device *dev, struct device_attribute *da,\n\t\t\t      const char *buf, size_t count)\n{\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tret = do_set_fan_div(dev, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\n \nstatic ssize_t fan1_pulses_show(struct device *dev,\n\t\t\t\tstruct device_attribute *da, char *buf)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", G762_PULSE_FROM_REG(data->fan_cmd1));\n}\n\nstatic ssize_t fan1_pulses_store(struct device *dev,\n\t\t\t\t struct device_attribute *da, const char *buf,\n\t\t\t\t size_t count)\n{\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tret = do_set_fan_pulses(dev, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\n \nstatic ssize_t pwm1_enable_show(struct device *dev,\n\t\t\t\tstruct device_attribute *da, char *buf)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       (!!(data->fan_cmd1 & G762_REG_FAN_CMD1_FAN_MODE)) + 1);\n}\n\nstatic ssize_t pwm1_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *da, const char *buf,\n\t\t\t\t size_t count)\n{\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tret = do_set_pwm_enable(dev, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\n \nstatic ssize_t pwm1_show(struct device *dev, struct device_attribute *da,\n\t\t\t char *buf)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->set_out);\n}\n\nstatic ssize_t pwm1_store(struct device *dev, struct device_attribute *da,\n\t\t\t  const char *buf, size_t count)\n{\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tret = do_set_pwm(dev, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\n \nstatic ssize_t fan1_target_show(struct device *dev,\n\t\t\t\tstruct device_attribute *da, char *buf)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\tunsigned int rpm;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tmutex_lock(&data->update_lock);\n\trpm = rpm_from_cnt(data->set_cnt, data->clk_freq,\n\t\t\t   G762_PULSE_FROM_REG(data->fan_cmd1),\n\t\t\t   G762_CLKDIV_FROM_REG(data->fan_cmd1),\n\t\t\t   G762_GEARMULT_FROM_REG(data->fan_cmd2));\n\tmutex_unlock(&data->update_lock);\n\n\treturn sprintf(buf, \"%u\\n\", rpm);\n}\n\nstatic ssize_t fan1_target_store(struct device *dev,\n\t\t\t\t struct device_attribute *da, const char *buf,\n\t\t\t\t size_t count)\n{\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tret = do_set_fan_target(dev, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\n \nstatic ssize_t fan1_fault_show(struct device *dev, struct device_attribute *da,\n\t\t\t       char *buf)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%u\\n\", !!(data->fan_sta & G762_REG_FAN_STA_FAIL));\n}\n\n \nstatic ssize_t fan1_alarm_show(struct device *dev,\n\t\t\t       struct device_attribute *da, char *buf)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%u\\n\", !(data->fan_sta & G762_REG_FAN_STA_OOC));\n}\n\nstatic DEVICE_ATTR_RW(pwm1);\nstatic DEVICE_ATTR_RW(pwm1_mode);\nstatic DEVICE_ATTR_RW(pwm1_enable);\nstatic DEVICE_ATTR_RO(fan1_input);\nstatic DEVICE_ATTR_RO(fan1_alarm);\nstatic DEVICE_ATTR_RO(fan1_fault);\nstatic DEVICE_ATTR_RW(fan1_target);\nstatic DEVICE_ATTR_RW(fan1_div);\nstatic DEVICE_ATTR_RW(fan1_pulses);\n\n \nstatic struct attribute *g762_attrs[] = {\n\t&dev_attr_fan1_input.attr,\n\t&dev_attr_fan1_alarm.attr,\n\t&dev_attr_fan1_fault.attr,\n\t&dev_attr_fan1_target.attr,\n\t&dev_attr_fan1_div.attr,\n\t&dev_attr_fan1_pulses.attr,\n\t&dev_attr_pwm1.attr,\n\t&dev_attr_pwm1_mode.attr,\n\t&dev_attr_pwm1_enable.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(g762);\n\n \nstatic inline int g762_fan_init(struct device *dev)\n{\n\tstruct g762_data *data = g762_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tdata->fan_cmd1 |= G762_REG_FAN_CMD1_DET_FAN_FAIL;\n\tdata->fan_cmd1 |= G762_REG_FAN_CMD1_DET_FAN_OOC;\n\tdata->valid = false;\n\n\treturn i2c_smbus_write_byte_data(data->client, G762_REG_FAN_CMD1,\n\t\t\t\t\t data->fan_cmd1);\n}\n\nstatic int g762_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct g762_data *data;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(struct g762_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tret = g762_fan_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = g762_of_clock_enable(client);\n\tif (ret)\n\t\treturn ret;\n\tret = g762_of_prop_import(client);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = g762_pdata_prop_import(client);\n\tif (ret)\n\t\treturn ret;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t    data, g762_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic struct i2c_driver g762_driver = {\n\t.driver = {\n\t\t.name = DRVNAME,\n\t\t.of_match_table = of_match_ptr(g762_dt_match),\n\t},\n\t.probe = g762_probe,\n\t.id_table = g762_id,\n};\n\nmodule_i2c_driver(g762_driver);\n\nMODULE_AUTHOR(\"Arnaud EBALARD <arno@natisbad.org>\");\nMODULE_DESCRIPTION(\"GMT G762/G763 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}