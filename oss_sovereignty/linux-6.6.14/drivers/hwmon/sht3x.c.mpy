{
  "module_name": "sht3x.c",
  "hash_id": "ff83632b082257437d4f3d63a4160c2aa1f818d7140abc2fddb80b33ba055e3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/sht3x.c",
  "human_readable_source": "\n \n\n#include <asm/page.h>\n#include <linux/crc8.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n\n \nstatic const unsigned char sht3x_cmd_measure_single_hpm[] = { 0x24, 0x00 };\n\n \nstatic const unsigned char sht3x_cmd_measure_single_mpm[] = { 0x24, 0x0b };\n\n \nstatic const unsigned char sht3x_cmd_measure_single_lpm[] = { 0x24, 0x16 };\n\n \nstatic const unsigned char sht3x_cmd_measure_periodic_mode[]   = { 0xe0, 0x00 };\nstatic const unsigned char sht3x_cmd_break[]                   = { 0x30, 0x93 };\n\n \nstatic const unsigned char sht3x_cmd_heater_on[]               = { 0x30, 0x6d };\nstatic const unsigned char sht3x_cmd_heater_off[]              = { 0x30, 0x66 };\n\n \nstatic const unsigned char sht3x_cmd_read_status_reg[]         = { 0xf3, 0x2d };\nstatic const unsigned char sht3x_cmd_clear_status_reg[]        = { 0x30, 0x41 };\n\n \n#define SHT3X_SINGLE_WAIT_TIME_HPM  15000\n#define SHT3X_SINGLE_WAIT_TIME_MPM   6000\n#define SHT3X_SINGLE_WAIT_TIME_LPM   4000\n\n#define SHT3X_WORD_LEN         2\n#define SHT3X_CMD_LENGTH       2\n#define SHT3X_CRC8_LEN         1\n#define SHT3X_RESPONSE_LENGTH  6\n#define SHT3X_CRC8_POLYNOMIAL  0x31\n#define SHT3X_CRC8_INIT        0xFF\n#define SHT3X_MIN_TEMPERATURE  -45000\n#define SHT3X_MAX_TEMPERATURE  130000\n#define SHT3X_MIN_HUMIDITY     0\n#define SHT3X_MAX_HUMIDITY     100000\n\nenum sht3x_chips {\n\tsht3x,\n\tsts3x,\n};\n\nenum sht3x_limits {\n\tlimit_max = 0,\n\tlimit_max_hyst,\n\tlimit_min,\n\tlimit_min_hyst,\n};\n\nenum sht3x_repeatability {\n\tlow_repeatability,\n\tmedium_repeatability,\n\thigh_repeatability,\n};\n\nDECLARE_CRC8_TABLE(sht3x_crc8_table);\n\n \nstatic const char periodic_measure_commands_hpm[][SHT3X_CMD_LENGTH] = {\n\t \n\t{0x20, 0x32},\n\t \n\t{0x21, 0x30},\n\t \n\t{0x22, 0x36},\n\t \n\t{0x23, 0x34},\n\t \n\t{0x27, 0x37},\n};\n\n \nstatic const char periodic_measure_commands_mpm[][SHT3X_CMD_LENGTH] = {\n\t \n\t{0x20, 0x24},\n\t \n\t{0x21, 0x26},\n\t \n\t{0x22, 0x20},\n\t \n\t{0x23, 0x22},\n\t \n\t{0x27, 0x21},\n};\n\n \nstatic const char periodic_measure_commands_lpm[][SHT3X_CMD_LENGTH] = {\n\t \n\t{0x20, 0x2f},\n\t \n\t{0x21, 0x2d},\n\t \n\t{0x22, 0x2b},\n\t \n\t{0x23, 0x29},\n\t \n\t{0x27, 0x2a},\n};\n\nstruct sht3x_limit_commands {\n\tconst char read_command[SHT3X_CMD_LENGTH];\n\tconst char write_command[SHT3X_CMD_LENGTH];\n};\n\nstatic const struct sht3x_limit_commands limit_commands[] = {\n\t \n\t[limit_max] = { {0xe1, 0x1f}, {0x61, 0x1d} },\n\t \n\t[limit_max_hyst] = { {0xe1, 0x14}, {0x61, 0x16} },\n\t \n\t[limit_min] = { {0xe1, 0x02}, {0x61, 0x00} },\n\t \n\t[limit_min_hyst] = { {0xe1, 0x09}, {0x61, 0x0B} },\n};\n\n#define SHT3X_NUM_LIMIT_CMD  ARRAY_SIZE(limit_commands)\n\nstatic const u16 mode_to_update_interval[] = {\n\t   0,\n\t2000,\n\t1000,\n\t 500,\n\t 250,\n\t 100,\n};\n\nstatic const struct hwmon_channel_info * const sht3x_channel_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT | HWMON_T_MIN |\n\t\t\t\tHWMON_T_MIN_HYST | HWMON_T_MAX |\n\t\t\t\tHWMON_T_MAX_HYST | HWMON_T_ALARM),\n\tHWMON_CHANNEL_INFO(humidity, HWMON_H_INPUT | HWMON_H_MIN |\n\t\t\t\tHWMON_H_MIN_HYST | HWMON_H_MAX |\n\t\t\t\tHWMON_H_MAX_HYST | HWMON_H_ALARM),\n\tNULL,\n};\n\nstruct sht3x_data {\n\tstruct i2c_client *client;\n\tenum sht3x_chips chip_id;\n\tstruct mutex i2c_lock;  \n\tstruct mutex data_lock;  \n\n\tu8 mode;\n\tconst unsigned char *command;\n\tu32 wait_time;\t\t\t \n\tunsigned long last_update;\t \n\tenum sht3x_repeatability repeatability;\n\n\t \n\tint temperature;\n\tint temperature_limits[SHT3X_NUM_LIMIT_CMD];\n\tu32 humidity;\n\tu32 humidity_limits[SHT3X_NUM_LIMIT_CMD];\n};\n\nstatic u8 get_mode_from_update_interval(u16 value)\n{\n\tsize_t index;\n\tu8 number_of_modes = ARRAY_SIZE(mode_to_update_interval);\n\n\tif (value == 0)\n\t\treturn 0;\n\n\t \n\tfor (index = 1; index < number_of_modes; index++) {\n\t\tif (mode_to_update_interval[index] <= value)\n\t\t\treturn index;\n\t}\n\n\treturn number_of_modes - 1;\n}\n\nstatic int sht3x_read_from_command(struct i2c_client *client,\n\t\t\t\t   struct sht3x_data *data,\n\t\t\t\t   const char *command,\n\t\t\t\t   char *buf, int length, u32 wait_time)\n{\n\tint ret;\n\n\tmutex_lock(&data->i2c_lock);\n\tret = i2c_master_send(client, command, SHT3X_CMD_LENGTH);\n\n\tif (ret != SHT3X_CMD_LENGTH) {\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto out;\n\t}\n\n\tif (wait_time)\n\t\tusleep_range(wait_time, wait_time + 1000);\n\n\tret = i2c_master_recv(client, buf, length);\n\tif (ret != length) {\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tmutex_unlock(&data->i2c_lock);\n\treturn ret;\n}\n\nstatic int sht3x_extract_temperature(u16 raw)\n{\n\t \n\treturn ((21875 * (int)raw) >> 13) - 45000;\n}\n\nstatic u32 sht3x_extract_humidity(u16 raw)\n{\n\t \n\treturn (12500 * (u32)raw) >> 13;\n}\n\nstatic struct sht3x_data *sht3x_update_client(struct device *dev)\n{\n\tstruct sht3x_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu16 interval_ms = mode_to_update_interval[data->mode];\n\tunsigned long interval_jiffies = msecs_to_jiffies(interval_ms);\n\tunsigned char buf[SHT3X_RESPONSE_LENGTH];\n\tu16 val;\n\tint ret = 0;\n\n\tmutex_lock(&data->data_lock);\n\t \n\tif (time_after(jiffies, data->last_update + interval_jiffies)) {\n\t\tret = sht3x_read_from_command(client, data, data->command, buf,\n\t\t\t\t\t      sizeof(buf), data->wait_time);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tval = be16_to_cpup((__be16 *)buf);\n\t\tdata->temperature = sht3x_extract_temperature(val);\n\t\tval = be16_to_cpup((__be16 *)(buf + 3));\n\t\tdata->humidity = sht3x_extract_humidity(val);\n\t\tdata->last_update = jiffies;\n\t}\n\nout:\n\tmutex_unlock(&data->data_lock);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn data;\n}\n\nstatic int temp1_input_read(struct device *dev)\n{\n\tstruct sht3x_data *data = sht3x_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn data->temperature;\n}\n\nstatic int humidity1_input_read(struct device *dev)\n{\n\tstruct sht3x_data *data = sht3x_update_client(dev);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn data->humidity;\n}\n\n \nstatic int limits_update(struct sht3x_data *data)\n{\n\tint ret;\n\tu8 index;\n\tint temperature;\n\tu32 humidity;\n\tu16 raw;\n\tchar buffer[SHT3X_RESPONSE_LENGTH];\n\tconst struct sht3x_limit_commands *commands;\n\tstruct i2c_client *client = data->client;\n\n\tfor (index = 0; index < SHT3X_NUM_LIMIT_CMD; index++) {\n\t\tcommands = &limit_commands[index];\n\t\tret = sht3x_read_from_command(client, data,\n\t\t\t\t\t      commands->read_command, buffer,\n\t\t\t\t\t      SHT3X_RESPONSE_LENGTH, 0);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\traw = be16_to_cpup((__be16 *)buffer);\n\t\ttemperature = sht3x_extract_temperature((raw & 0x01ff) << 7);\n\t\thumidity = sht3x_extract_humidity(raw & 0xfe00);\n\t\tdata->temperature_limits[index] = temperature;\n\t\tdata->humidity_limits[index] = humidity;\n\t}\n\n\treturn ret;\n}\n\nstatic int temp1_limit_read(struct device *dev, int index)\n{\n\tstruct sht3x_data *data = dev_get_drvdata(dev);\n\n\treturn data->temperature_limits[index];\n}\n\nstatic int humidity1_limit_read(struct device *dev, int index)\n{\n\tstruct sht3x_data *data = dev_get_drvdata(dev);\n\n\treturn data->humidity_limits[index];\n}\n\n \nstatic size_t limit_write(struct device *dev,\n\t\t\t  u8 index,\n\t\t\t  int temperature,\n\t\t\t  u32 humidity)\n{\n\tchar buffer[SHT3X_CMD_LENGTH + SHT3X_WORD_LEN + SHT3X_CRC8_LEN];\n\tchar *position = buffer;\n\tint ret;\n\tu16 raw;\n\tstruct sht3x_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tconst struct sht3x_limit_commands *commands;\n\n\tcommands = &limit_commands[index];\n\n\tmemcpy(position, commands->write_command, SHT3X_CMD_LENGTH);\n\tposition += SHT3X_CMD_LENGTH;\n\t \n\traw = ((u32)(temperature + 45000) * 24543) >> (16 + 7);\n\traw |= ((humidity * 42950) >> 16) & 0xfe00;\n\n\t*((__be16 *)position) = cpu_to_be16(raw);\n\tposition += SHT3X_WORD_LEN;\n\t*position = crc8(sht3x_crc8_table,\n\t\t\t position - SHT3X_WORD_LEN,\n\t\t\t SHT3X_WORD_LEN,\n\t\t\t SHT3X_CRC8_INIT);\n\n\tmutex_lock(&data->i2c_lock);\n\tret = i2c_master_send(client, buffer, sizeof(buffer));\n\tmutex_unlock(&data->i2c_lock);\n\n\tif (ret != sizeof(buffer))\n\t\treturn ret < 0 ? ret : -EIO;\n\n\tdata->temperature_limits[index] = temperature;\n\tdata->humidity_limits[index] = humidity;\n\n\treturn 0;\n}\n\nstatic int temp1_limit_write(struct device *dev, int index, int val)\n{\n\tint temperature;\n\tint ret;\n\tstruct sht3x_data *data = dev_get_drvdata(dev);\n\n\ttemperature = clamp_val(val, SHT3X_MIN_TEMPERATURE,\n\t\t\t\tSHT3X_MAX_TEMPERATURE);\n\tmutex_lock(&data->data_lock);\n\tret = limit_write(dev, index, temperature,\n\t\t\t  data->humidity_limits[index]);\n\tmutex_unlock(&data->data_lock);\n\n\treturn ret;\n}\n\nstatic int humidity1_limit_write(struct device *dev, int index, int val)\n{\n\tu32 humidity;\n\tint ret;\n\tstruct sht3x_data *data = dev_get_drvdata(dev);\n\n\thumidity = clamp_val(val, SHT3X_MIN_HUMIDITY, SHT3X_MAX_HUMIDITY);\n\tmutex_lock(&data->data_lock);\n\tret = limit_write(dev, index, data->temperature_limits[index],\n\t\t\t  humidity);\n\tmutex_unlock(&data->data_lock);\n\n\treturn ret;\n}\n\nstatic void sht3x_select_command(struct sht3x_data *data)\n{\n\t \n\tif (data->mode > 0) {\n\t\tdata->command = sht3x_cmd_measure_periodic_mode;\n\t\tdata->wait_time = 0;\n\t} else {\n\t\tif (data->repeatability == high_repeatability) {\n\t\t\tdata->command = sht3x_cmd_measure_single_hpm;\n\t\t\tdata->wait_time = SHT3X_SINGLE_WAIT_TIME_HPM;\n\t\t} else if (data->repeatability ==  medium_repeatability) {\n\t\t\tdata->command = sht3x_cmd_measure_single_mpm;\n\t\t\tdata->wait_time = SHT3X_SINGLE_WAIT_TIME_MPM;\n\t\t} else {\n\t\t\tdata->command = sht3x_cmd_measure_single_lpm;\n\t\t\tdata->wait_time = SHT3X_SINGLE_WAIT_TIME_LPM;\n\t\t}\n\t}\n}\n\nstatic int status_register_read(struct device *dev,\n\t\t\t\tchar *buffer, int length)\n{\n\tint ret;\n\tstruct sht3x_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tret = sht3x_read_from_command(client, data, sht3x_cmd_read_status_reg,\n\t\t\t\t      buffer, length, 0);\n\n\treturn ret;\n}\n\nstatic int temp1_alarm_read(struct device *dev)\n{\n\tchar buffer[SHT3X_WORD_LEN + SHT3X_CRC8_LEN];\n\tint ret;\n\n\tret = status_register_read(dev, buffer,\n\t\t\t\t   SHT3X_WORD_LEN + SHT3X_CRC8_LEN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(buffer[0] & 0x04);\n}\n\nstatic int humidity1_alarm_read(struct device *dev)\n{\n\tchar buffer[SHT3X_WORD_LEN + SHT3X_CRC8_LEN];\n\tint ret;\n\n\tret = status_register_read(dev, buffer,\n\t\t\t\t   SHT3X_WORD_LEN + SHT3X_CRC8_LEN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(buffer[0] & 0x08);\n}\n\nstatic ssize_t heater_enable_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tchar buffer[SHT3X_WORD_LEN + SHT3X_CRC8_LEN];\n\tint ret;\n\n\tret = status_register_read(dev, buffer,\n\t\t\t\t   SHT3X_WORD_LEN + SHT3X_CRC8_LEN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!(buffer[0] & 0x20));\n}\n\nstatic ssize_t heater_enable_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf,\n\t\t\t\t   size_t count)\n{\n\tstruct sht3x_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\tbool status;\n\n\tret = kstrtobool(buf, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&data->i2c_lock);\n\n\tif (status)\n\t\tret = i2c_master_send(client, (char *)&sht3x_cmd_heater_on,\n\t\t\t\t      SHT3X_CMD_LENGTH);\n\telse\n\t\tret = i2c_master_send(client, (char *)&sht3x_cmd_heater_off,\n\t\t\t\t      SHT3X_CMD_LENGTH);\n\n\tmutex_unlock(&data->i2c_lock);\n\n\treturn ret;\n}\n\nstatic int update_interval_read(struct device *dev)\n{\n\tstruct sht3x_data *data = dev_get_drvdata(dev);\n\n\treturn mode_to_update_interval[data->mode];\n}\n\nstatic int update_interval_write(struct device *dev, int val)\n{\n\tu8 mode;\n\tint ret;\n\tconst char *command;\n\tstruct sht3x_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tmode = get_mode_from_update_interval(val);\n\n\tmutex_lock(&data->data_lock);\n\t \n\tif (mode == data->mode) {\n\t\tmutex_unlock(&data->data_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&data->i2c_lock);\n\t \n\tif (data->mode > 0) {\n\t\tret = i2c_master_send(client, sht3x_cmd_break,\n\t\t\t\t      SHT3X_CMD_LENGTH);\n\t\tif (ret != SHT3X_CMD_LENGTH)\n\t\t\tgoto out;\n\t\tdata->mode = 0;\n\t}\n\n\tif (mode > 0) {\n\t\tif (data->repeatability == high_repeatability)\n\t\t\tcommand = periodic_measure_commands_hpm[mode - 1];\n\t\telse if (data->repeatability == medium_repeatability)\n\t\t\tcommand = periodic_measure_commands_mpm[mode - 1];\n\t\telse\n\t\t\tcommand = periodic_measure_commands_lpm[mode - 1];\n\n\t\t \n\t\tret = i2c_master_send(client, command, SHT3X_CMD_LENGTH);\n\t\tif (ret != SHT3X_CMD_LENGTH)\n\t\t\tgoto out;\n\t}\n\n\t \n\tdata->mode = mode;\n\tsht3x_select_command(data);\n\nout:\n\tmutex_unlock(&data->i2c_lock);\n\tmutex_unlock(&data->data_lock);\n\tif (ret != SHT3X_CMD_LENGTH)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic ssize_t repeatability_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct sht3x_data *data = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", data->repeatability);\n}\n\nstatic ssize_t repeatability_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf,\n\t\t\t\t   size_t count)\n{\n\tint ret;\n\tu8 val;\n\n\tstruct sht3x_data *data = dev_get_drvdata(dev);\n\n\tret = kstrtou8(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 2)\n\t\treturn -EINVAL;\n\n\tdata->repeatability = val;\n\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(heater_enable, heater_enable, 0);\nstatic SENSOR_DEVICE_ATTR_RW(repeatability, repeatability, 0);\n\nstatic struct attribute *sht3x_attrs[] = {\n\t&sensor_dev_attr_heater_enable.dev_attr.attr,\n\t&sensor_dev_attr_repeatability.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(sht3x);\n\nstatic umode_t sht3x_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\tu32 attr, int channel)\n{\n\tconst struct sht3x_data *chip_data = data;\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_max:\n\t\tcase hwmon_temp_max_hyst:\n\t\tcase hwmon_temp_min:\n\t\tcase hwmon_temp_min_hyst:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_humidity:\n\t\tif (chip_data->chip_id == sts3x)\n\t\t\tbreak;\n\t\tswitch (attr) {\n\t\tcase hwmon_humidity_input:\n\t\tcase hwmon_humidity_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_humidity_max:\n\t\tcase hwmon_humidity_max_hyst:\n\t\tcase hwmon_humidity_min:\n\t\tcase hwmon_humidity_min_hyst:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sht3x_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t      u32 attr, int channel, long *val)\n{\n\tenum sht3x_limits index;\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\t*val = update_interval_read(dev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\t*val = temp1_input_read(dev);\n\t\t\tbreak;\n\t\tcase hwmon_temp_alarm:\n\t\t\t*val = temp1_alarm_read(dev);\n\t\t\tbreak;\n\t\tcase hwmon_temp_max:\n\t\t\tindex = limit_max;\n\t\t\t*val = temp1_limit_read(dev, index);\n\t\t\tbreak;\n\t\tcase hwmon_temp_max_hyst:\n\t\t\tindex = limit_max_hyst;\n\t\t\t*val = temp1_limit_read(dev, index);\n\t\t\tbreak;\n\t\tcase hwmon_temp_min:\n\t\t\tindex = limit_min;\n\t\t\t*val = temp1_limit_read(dev, index);\n\t\t\tbreak;\n\t\tcase hwmon_temp_min_hyst:\n\t\t\tindex = limit_min_hyst;\n\t\t\t*val = temp1_limit_read(dev, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase hwmon_humidity:\n\t\tswitch (attr) {\n\t\tcase hwmon_humidity_input:\n\t\t\t*val = humidity1_input_read(dev);\n\t\t\tbreak;\n\t\tcase hwmon_humidity_alarm:\n\t\t\t*val = humidity1_alarm_read(dev);\n\t\t\tbreak;\n\t\tcase hwmon_humidity_max:\n\t\t\tindex = limit_max;\n\t\t\t*val = humidity1_limit_read(dev, index);\n\t\t\tbreak;\n\t\tcase hwmon_humidity_max_hyst:\n\t\t\tindex = limit_max_hyst;\n\t\t\t*val = humidity1_limit_read(dev, index);\n\t\t\tbreak;\n\t\tcase hwmon_humidity_min:\n\t\t\tindex = limit_min;\n\t\t\t*val = humidity1_limit_read(dev, index);\n\t\t\tbreak;\n\t\tcase hwmon_humidity_min_hyst:\n\t\t\tindex = limit_min_hyst;\n\t\t\t*val = humidity1_limit_read(dev, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int sht3x_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long val)\n{\n\tenum sht3x_limits index;\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\treturn update_interval_write(dev, val);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_max:\n\t\t\tindex = limit_max;\n\t\t\tbreak;\n\t\tcase hwmon_temp_max_hyst:\n\t\t\tindex = limit_max_hyst;\n\t\t\tbreak;\n\t\tcase hwmon_temp_min:\n\t\t\tindex = limit_min;\n\t\t\tbreak;\n\t\tcase hwmon_temp_min_hyst:\n\t\t\tindex = limit_min_hyst;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\treturn temp1_limit_write(dev, index, val);\n\tcase hwmon_humidity:\n\t\tswitch (attr) {\n\t\tcase hwmon_humidity_max:\n\t\t\tindex = limit_max;\n\t\t\tbreak;\n\t\tcase hwmon_humidity_max_hyst:\n\t\t\tindex = limit_max_hyst;\n\t\t\tbreak;\n\t\tcase hwmon_humidity_min:\n\t\t\tindex = limit_min;\n\t\t\tbreak;\n\t\tcase hwmon_humidity_min_hyst:\n\t\t\tindex = limit_min_hyst;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\treturn humidity1_limit_write(dev, index, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_ops sht3x_ops = {\n\t.is_visible = sht3x_is_visible,\n\t.read = sht3x_read,\n\t.write = sht3x_write,\n};\n\nstatic const struct hwmon_chip_info sht3x_chip_info = {\n\t.ops = &sht3x_ops,\n\t.info = sht3x_channel_info,\n};\n\n \nstatic const struct i2c_device_id sht3x_ids[] = {\n\t{\"sht3x\", sht3x},\n\t{\"sts3x\", sts3x},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, sht3x_ids);\n\nstatic int sht3x_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct sht3x_data *data;\n\tstruct device *hwmon_dev;\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct device *dev = &client->dev;\n\n\t \n\tif (!i2c_check_functionality(adap, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tret = i2c_master_send(client, sht3x_cmd_clear_status_reg,\n\t\t\t      SHT3X_CMD_LENGTH);\n\tif (ret != SHT3X_CMD_LENGTH)\n\t\treturn ret < 0 ? ret : -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->repeatability = high_repeatability;\n\tdata->mode = 0;\n\tdata->last_update = jiffies - msecs_to_jiffies(3000);\n\tdata->client = client;\n\tdata->chip_id = i2c_match_id(sht3x_ids, client)->driver_data;\n\tcrc8_populate_msb(sht3x_crc8_table, SHT3X_CRC8_POLYNOMIAL);\n\n\tsht3x_select_command(data);\n\n\tmutex_init(&data->i2c_lock);\n\tmutex_init(&data->data_lock);\n\n\t \n\tusleep_range(500, 600);\n\n\tret = limits_update(data);\n\tif (ret)\n\t\treturn ret;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev,\n\t\t\t\t\t\t\t client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &sht3x_chip_info,\n\t\t\t\t\t\t\t sht3x_groups);\n\n\tif (IS_ERR(hwmon_dev))\n\t\tdev_dbg(dev, \"unable to register hwmon device\\n\");\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic struct i2c_driver sht3x_i2c_driver = {\n\t.driver.name = \"sht3x\",\n\t.probe       = sht3x_probe,\n\t.id_table    = sht3x_ids,\n};\n\nmodule_i2c_driver(sht3x_i2c_driver);\n\nMODULE_AUTHOR(\"David Frey <david.frey@sensirion.com>\");\nMODULE_AUTHOR(\"Pascal Sachs <pascal.sachs@sensirion.com>\");\nMODULE_DESCRIPTION(\"Sensirion SHT3x humidity and temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}