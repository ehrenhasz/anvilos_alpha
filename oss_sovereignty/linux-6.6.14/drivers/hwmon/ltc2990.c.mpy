{
  "module_name": "ltc2990.c",
  "hash_id": "0939c67308fe435e9fe7883bb8251452daeea5e2d92f2937d978cd7034594298",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ltc2990.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n\n#define LTC2990_STATUS\t0x00\n#define LTC2990_CONTROL\t0x01\n#define LTC2990_TRIGGER\t0x02\n#define LTC2990_TINT_MSB\t0x04\n#define LTC2990_V1_MSB\t0x06\n#define LTC2990_V2_MSB\t0x08\n#define LTC2990_V3_MSB\t0x0A\n#define LTC2990_V4_MSB\t0x0C\n#define LTC2990_VCC_MSB\t0x0E\n\n#define LTC2990_IN0\tBIT(0)\n#define LTC2990_IN1\tBIT(1)\n#define LTC2990_IN2\tBIT(2)\n#define LTC2990_IN3\tBIT(3)\n#define LTC2990_IN4\tBIT(4)\n#define LTC2990_CURR1\tBIT(5)\n#define LTC2990_CURR2\tBIT(6)\n#define LTC2990_TEMP1\tBIT(7)\n#define LTC2990_TEMP2\tBIT(8)\n#define LTC2990_TEMP3\tBIT(9)\n#define LTC2990_NONE\t0\n#define LTC2990_ALL\tGENMASK(9, 0)\n\n#define LTC2990_MODE0_SHIFT\t0\n#define LTC2990_MODE0_MASK\tGENMASK(2, 0)\n#define LTC2990_MODE1_SHIFT\t3\n#define LTC2990_MODE1_MASK\tGENMASK(1, 0)\n\n \nstatic const int ltc2990_attrs_ena_0[] = {\n\tLTC2990_IN1 | LTC2990_IN2 | LTC2990_TEMP3,\n\tLTC2990_CURR1 | LTC2990_TEMP3,\n\tLTC2990_CURR1 | LTC2990_IN3 | LTC2990_IN4,\n\tLTC2990_TEMP2 | LTC2990_IN3 | LTC2990_IN4,\n\tLTC2990_TEMP2 | LTC2990_CURR2,\n\tLTC2990_TEMP2 | LTC2990_TEMP3,\n\tLTC2990_CURR1 | LTC2990_CURR2,\n\tLTC2990_IN1 | LTC2990_IN2 | LTC2990_IN3 | LTC2990_IN4\n};\n\n \nstatic const int ltc2990_attrs_ena_1[] = {\n\tLTC2990_NONE,\n\tLTC2990_TEMP2 | LTC2990_IN1 | LTC2990_CURR1,\n\tLTC2990_TEMP3 | LTC2990_IN3 | LTC2990_CURR2,\n\tLTC2990_ALL\n};\n\nstruct ltc2990_data {\n\tstruct i2c_client *i2c;\n\tu32 mode[2];\n};\n\n \nstatic int ltc2990_get_value(struct i2c_client *i2c, int index, int *result)\n{\n\tint val;\n\tu8 reg;\n\n\tswitch (index) {\n\tcase LTC2990_IN0:\n\t\treg = LTC2990_VCC_MSB;\n\t\tbreak;\n\tcase LTC2990_IN1:\n\tcase LTC2990_CURR1:\n\tcase LTC2990_TEMP2:\n\t\treg = LTC2990_V1_MSB;\n\t\tbreak;\n\tcase LTC2990_IN2:\n\t\treg = LTC2990_V2_MSB;\n\t\tbreak;\n\tcase LTC2990_IN3:\n\tcase LTC2990_CURR2:\n\tcase LTC2990_TEMP3:\n\t\treg = LTC2990_V3_MSB;\n\t\tbreak;\n\tcase LTC2990_IN4:\n\t\treg = LTC2990_V4_MSB;\n\t\tbreak;\n\tcase LTC2990_TEMP1:\n\t\treg = LTC2990_TINT_MSB;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = i2c_smbus_read_word_swapped(i2c, reg);\n\tif (unlikely(val < 0))\n\t\treturn val;\n\n\tswitch (index) {\n\tcase LTC2990_TEMP1:\n\tcase LTC2990_TEMP2:\n\tcase LTC2990_TEMP3:\n\t\t \n\t\t*result = sign_extend32(val, 12) * 1000 / 16;\n\t\tbreak;\n\tcase LTC2990_CURR1:\n\tcase LTC2990_CURR2:\n\t\t  \n\t\t*result = sign_extend32(val, 14) * 1942 / 100;\n\t\tbreak;\n\tcase LTC2990_IN0:\n\t\t \n\t\t*result = sign_extend32(val, 14) * 30518 / (100 * 1000) + 2500;\n\t\tbreak;\n\tcase LTC2990_IN1:\n\tcase LTC2990_IN2:\n\tcase LTC2990_IN3:\n\tcase LTC2990_IN4:\n\t\t \n\t\t*result = sign_extend32(val, 14) * 30518 / (100 * 1000);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;  \n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t ltc2990_value_show(struct device *dev,\n\t\t\t\t  struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ltc2990_data *data = dev_get_drvdata(dev);\n\tint value;\n\tint ret;\n\n\tret = ltc2990_get_value(data->i2c, attr->index, &value);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\nstatic umode_t ltc2990_attrs_visible(struct kobject *kobj,\n\t\t\t\t     struct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct ltc2990_data *data = dev_get_drvdata(dev);\n\tstruct device_attribute *da =\n\t\t\tcontainer_of(a, struct device_attribute, attr);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\n\tint attrs_mask = LTC2990_IN0 | LTC2990_TEMP1 |\n\t\t\t (ltc2990_attrs_ena_0[data->mode[0]] &\n\t\t\t  ltc2990_attrs_ena_1[data->mode[1]]);\n\n\tif (attr->index & attrs_mask)\n\t\treturn a->mode;\n\n\treturn 0;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, ltc2990_value, LTC2990_TEMP1);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, ltc2990_value, LTC2990_TEMP2);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, ltc2990_value, LTC2990_TEMP3);\nstatic SENSOR_DEVICE_ATTR_RO(curr1_input, ltc2990_value, LTC2990_CURR1);\nstatic SENSOR_DEVICE_ATTR_RO(curr2_input, ltc2990_value, LTC2990_CURR2);\nstatic SENSOR_DEVICE_ATTR_RO(in0_input, ltc2990_value, LTC2990_IN0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, ltc2990_value, LTC2990_IN1);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, ltc2990_value, LTC2990_IN2);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, ltc2990_value, LTC2990_IN3);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, ltc2990_value, LTC2990_IN4);\n\nstatic struct attribute *ltc2990_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_curr1_input.dev_attr.attr,\n\t&sensor_dev_attr_curr2_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ltc2990_group = {\n\t.attrs = ltc2990_attrs,\n\t.is_visible = ltc2990_attrs_visible,\n};\n__ATTRIBUTE_GROUPS(ltc2990);\n\nstatic int ltc2990_i2c_probe(struct i2c_client *i2c)\n{\n\tint ret;\n\tstruct device *hwmon_dev;\n\tstruct ltc2990_data *data;\n\n\tif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&i2c->dev, sizeof(struct ltc2990_data), GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn -ENOMEM;\n\n\tdata->i2c = i2c;\n\n\tif (dev_fwnode(&i2c->dev)) {\n\t\tret = device_property_read_u32_array(&i2c->dev,\n\t\t\t\t\t\t     \"lltc,meas-mode\",\n\t\t\t\t\t\t     data->mode, 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (data->mode[0] & ~LTC2990_MODE0_MASK ||\n\t\t    data->mode[1] & ~LTC2990_MODE1_MASK)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tret = i2c_smbus_read_byte_data(i2c, LTC2990_CONTROL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata->mode[0] = ret >> LTC2990_MODE0_SHIFT & LTC2990_MODE0_MASK;\n\t\tdata->mode[1] = ret >> LTC2990_MODE1_SHIFT & LTC2990_MODE1_MASK;\n\t}\n\n\t \n\tret = i2c_smbus_write_byte_data(i2c, LTC2990_CONTROL,\n\t\t\t\t\tdata->mode[0] << LTC2990_MODE0_SHIFT |\n\t\t\t\t\tdata->mode[1] << LTC2990_MODE1_SHIFT);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Error: Failed to set control mode.\\n\");\n\t\treturn ret;\n\t}\n\t \n\tret = i2c_smbus_write_byte_data(i2c, LTC2990_TRIGGER, 1);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Error: Failed to start acquisition.\\n\");\n\t\treturn ret;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(&i2c->dev,\n\t\t\t\t\t\t\t   i2c->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   ltc2990_groups);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id ltc2990_i2c_id[] = {\n\t{ \"ltc2990\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ltc2990_i2c_id);\n\nstatic struct i2c_driver ltc2990_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ltc2990\",\n\t},\n\t.probe = ltc2990_i2c_probe,\n\t.id_table = ltc2990_i2c_id,\n};\n\nmodule_i2c_driver(ltc2990_i2c_driver);\n\nMODULE_DESCRIPTION(\"LTC2990 Sensor Driver\");\nMODULE_AUTHOR(\"Topic Embedded Products\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}