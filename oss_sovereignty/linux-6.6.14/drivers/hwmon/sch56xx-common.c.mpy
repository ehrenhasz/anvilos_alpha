{
  "module_name": "sch56xx-common.c",
  "hash_id": "3f9d5492734824915352c92e7421e7a382af279f5e06555a9789d901c9fd9dd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/sch56xx-common.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/watchdog.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include \"sch56xx-common.h\"\n\n \nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n#define SIO_SCH56XX_LD_EM\t0x0C\t \n#define SIO_UNLOCK_KEY\t\t0x55\t \n#define SIO_LOCK_KEY\t\t0xAA\t \n\n#define SIO_REG_LDSEL\t\t0x07\t \n#define SIO_REG_DEVID\t\t0x20\t \n#define SIO_REG_ENABLE\t\t0x30\t \n#define SIO_REG_ADDR\t\t0x66\t \n\n#define SIO_SCH5627_ID\t\t0xC6\t \n#define SIO_SCH5636_ID\t\t0xC7\t \n\n#define REGION_LENGTH\t\t10\n\n#define SCH56XX_CMD_READ\t0x02\n#define SCH56XX_CMD_WRITE\t0x03\n\n \n#define SCH56XX_REG_WDOG_PRESET\t\t0x58B\n#define SCH56XX_REG_WDOG_CONTROL\t0x58C\n#define SCH56XX_WDOG_TIME_BASE_SEC\t0x01\n#define SCH56XX_REG_WDOG_OUTPUT_ENABLE\t0x58E\n#define SCH56XX_WDOG_OUTPUT_ENABLE\t0x02\n\nstruct sch56xx_watchdog_data {\n\tu16 addr;\n\tstruct mutex *io_lock;\n\tstruct watchdog_info wdinfo;\n\tstruct watchdog_device wddev;\n\tu8 watchdog_preset;\n\tu8 watchdog_control;\n\tu8 watchdog_output_enable;\n};\n\nstatic struct platform_device *sch56xx_pdev;\n\n \nstatic inline int superio_inb(int base, int reg)\n{\n\toutb(reg, base);\n\treturn inb(base + 1);\n}\n\nstatic inline int superio_enter(int base)\n{\n\t \n\tif (!request_muxed_region(base, 2, \"sch56xx\")) {\n\t\tpr_err(\"I/O address 0x%04x already in use\\n\", base);\n\t\treturn -EBUSY;\n\t}\n\n\toutb(SIO_UNLOCK_KEY, base);\n\n\treturn 0;\n}\n\nstatic inline void superio_select(int base, int ld)\n{\n\toutb(SIO_REG_LDSEL, base);\n\toutb(ld, base + 1);\n}\n\nstatic inline void superio_exit(int base)\n{\n\toutb(SIO_LOCK_KEY, base);\n\trelease_region(base, 2);\n}\n\nstatic int sch56xx_send_cmd(u16 addr, u8 cmd, u16 reg, u8 v)\n{\n\tu8 val;\n\tint i;\n\t \n\tconst int max_busy_polls = 64;\n\tconst int max_lazy_polls = 32;\n\n\t \n\tval = inb(addr + 1);\n\toutb(val, addr + 1);\n\n\t \n\toutb(0x00, addr + 2);\n\toutb(0x80, addr + 3);\n\n\t \n\toutb(cmd, addr + 4);  \n\toutb(0x01, addr + 5);  \n\toutb(0x04, addr + 2);  \n\n\t \n\tif (cmd == SCH56XX_CMD_WRITE)\n\t\toutb(v, addr + 4);\n\n\t \n\toutb(reg & 0xff, addr + 6);\n\toutb(reg >> 8, addr + 7);\n\n\t \n\toutb(0x01, addr);  \n\n\t \n\tfor (i = 0; i < max_busy_polls + max_lazy_polls; i++) {\n\t\tif (i >= max_busy_polls)\n\t\t\tusleep_range(1000, 2000);\n\t\t \n\t\tval = inb(addr + 8);\n\t\t \n\t\tif (val)\n\t\t\toutb(val, addr + 8);\n\t\t \n\t\tif (val & 0x01)\n\t\t\tbreak;\n\t}\n\tif (i == max_busy_polls + max_lazy_polls) {\n\t\tpr_err(\"Max retries exceeded reading virtual register 0x%04hx (%d)\\n\",\n\t\t       reg, 1);\n\t\treturn -EIO;\n\t}\n\n\t \n\tfor (i = 0; i < max_busy_polls; i++) {\n\t\t \n\t\tval = inb(addr + 1);\n\t\t \n\t\tif (val == 0x01)\n\t\t\tbreak;\n\n\t\tif (i == 0)\n\t\t\tpr_warn(\"EC reports: 0x%02x reading virtual register 0x%04hx\\n\",\n\t\t\t\t(unsigned int)val, reg);\n\t}\n\tif (i == max_busy_polls) {\n\t\tpr_err(\"Max retries exceeded reading virtual register 0x%04hx (%d)\\n\",\n\t\t       reg, 2);\n\t\treturn -EIO;\n\t}\n\n\t \n\n\t \n\tif (cmd == SCH56XX_CMD_READ)\n\t\treturn inb(addr + 4);\n\n\treturn 0;\n}\n\nint sch56xx_read_virtual_reg(u16 addr, u16 reg)\n{\n\treturn sch56xx_send_cmd(addr, SCH56XX_CMD_READ, reg, 0);\n}\nEXPORT_SYMBOL(sch56xx_read_virtual_reg);\n\nint sch56xx_write_virtual_reg(u16 addr, u16 reg, u8 val)\n{\n\treturn sch56xx_send_cmd(addr, SCH56XX_CMD_WRITE, reg, val);\n}\nEXPORT_SYMBOL(sch56xx_write_virtual_reg);\n\nint sch56xx_read_virtual_reg16(u16 addr, u16 reg)\n{\n\tint lsb, msb;\n\n\t \n\tlsb = sch56xx_read_virtual_reg(addr, reg);\n\tif (lsb < 0)\n\t\treturn lsb;\n\n\tmsb = sch56xx_read_virtual_reg(addr, reg + 1);\n\tif (msb < 0)\n\t\treturn msb;\n\n\treturn lsb | (msb << 8);\n}\nEXPORT_SYMBOL(sch56xx_read_virtual_reg16);\n\nint sch56xx_read_virtual_reg12(u16 addr, u16 msb_reg, u16 lsn_reg,\n\t\t\t       int high_nibble)\n{\n\tint msb, lsn;\n\n\t \n\tmsb = sch56xx_read_virtual_reg(addr, msb_reg);\n\tif (msb < 0)\n\t\treturn msb;\n\n\tlsn = sch56xx_read_virtual_reg(addr, lsn_reg);\n\tif (lsn < 0)\n\t\treturn lsn;\n\n\tif (high_nibble)\n\t\treturn (msb << 4) | (lsn >> 4);\n\telse\n\t\treturn (msb << 4) | (lsn & 0x0f);\n}\nEXPORT_SYMBOL(sch56xx_read_virtual_reg12);\n\n \n\nstatic int watchdog_set_timeout(struct watchdog_device *wddev,\n\t\t\t\tunsigned int timeout)\n{\n\tstruct sch56xx_watchdog_data *data = watchdog_get_drvdata(wddev);\n\tunsigned int resolution;\n\tu8 control;\n\tint ret;\n\n\t \n\tif (timeout <= 255)\n\t\tresolution = 1;\n\telse\n\t\tresolution = 60;\n\n\tif (timeout < resolution || timeout > (resolution * 255))\n\t\treturn -EINVAL;\n\n\tif (resolution == 1)\n\t\tcontrol = data->watchdog_control | SCH56XX_WDOG_TIME_BASE_SEC;\n\telse\n\t\tcontrol = data->watchdog_control & ~SCH56XX_WDOG_TIME_BASE_SEC;\n\n\tif (data->watchdog_control != control) {\n\t\tmutex_lock(data->io_lock);\n\t\tret = sch56xx_write_virtual_reg(data->addr,\n\t\t\t\t\t\tSCH56XX_REG_WDOG_CONTROL,\n\t\t\t\t\t\tcontrol);\n\t\tmutex_unlock(data->io_lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata->watchdog_control = control;\n\t}\n\n\t \n\tdata->watchdog_preset = DIV_ROUND_UP(timeout, resolution);\n\twddev->timeout = data->watchdog_preset * resolution;\n\n\treturn 0;\n}\n\nstatic int watchdog_start(struct watchdog_device *wddev)\n{\n\tstruct sch56xx_watchdog_data *data = watchdog_get_drvdata(wddev);\n\tint ret;\n\tu8 val;\n\n\t \n\n\tmutex_lock(data->io_lock);\n\n\t \n\tret = sch56xx_write_virtual_reg(data->addr, SCH56XX_REG_WDOG_PRESET,\n\t\t\t\t\tdata->watchdog_preset);\n\tif (ret)\n\t\tgoto leave;\n\n\t \n\tval = data->watchdog_output_enable | SCH56XX_WDOG_OUTPUT_ENABLE;\n\tret = sch56xx_write_virtual_reg(data->addr,\n\t\t\t\t\tSCH56XX_REG_WDOG_OUTPUT_ENABLE, val);\n\tif (ret)\n\t\tgoto leave;\n\n\tdata->watchdog_output_enable = val;\n\n\t \n\tval = inb(data->addr + 9);\n\tif (val & 0x01)\n\t\toutb(0x01, data->addr + 9);\n\nleave:\n\tmutex_unlock(data->io_lock);\n\treturn ret;\n}\n\nstatic int watchdog_trigger(struct watchdog_device *wddev)\n{\n\tstruct sch56xx_watchdog_data *data = watchdog_get_drvdata(wddev);\n\tint ret;\n\n\t \n\tmutex_lock(data->io_lock);\n\tret = sch56xx_write_virtual_reg(data->addr, SCH56XX_REG_WDOG_PRESET,\n\t\t\t\t\tdata->watchdog_preset);\n\tmutex_unlock(data->io_lock);\n\n\treturn ret;\n}\n\nstatic int watchdog_stop(struct watchdog_device *wddev)\n{\n\tstruct sch56xx_watchdog_data *data = watchdog_get_drvdata(wddev);\n\tint ret = 0;\n\tu8 val;\n\n\tval = data->watchdog_output_enable & ~SCH56XX_WDOG_OUTPUT_ENABLE;\n\tmutex_lock(data->io_lock);\n\tret = sch56xx_write_virtual_reg(data->addr,\n\t\t\t\t\tSCH56XX_REG_WDOG_OUTPUT_ENABLE, val);\n\tmutex_unlock(data->io_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->watchdog_output_enable = val;\n\treturn 0;\n}\n\nstatic const struct watchdog_ops watchdog_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= watchdog_start,\n\t.stop\t\t= watchdog_stop,\n\t.ping\t\t= watchdog_trigger,\n\t.set_timeout\t= watchdog_set_timeout,\n};\n\nvoid sch56xx_watchdog_register(struct device *parent, u16 addr, u32 revision,\n\t\t\t       struct mutex *io_lock, int check_enabled)\n{\n\tstruct sch56xx_watchdog_data *data;\n\tint err, control, output_enable;\n\n\t \n\tmutex_lock(io_lock);\n\tcontrol =\n\t\tsch56xx_read_virtual_reg(addr, SCH56XX_REG_WDOG_CONTROL);\n\toutput_enable =\n\t\tsch56xx_read_virtual_reg(addr, SCH56XX_REG_WDOG_OUTPUT_ENABLE);\n\tmutex_unlock(io_lock);\n\n\tif (control < 0)\n\t\treturn;\n\tif (output_enable < 0)\n\t\treturn;\n\tif (check_enabled && !(output_enable & SCH56XX_WDOG_OUTPUT_ENABLE)) {\n\t\tpr_warn(\"Watchdog not enabled by BIOS, not registering\\n\");\n\t\treturn;\n\t}\n\n\tdata = devm_kzalloc(parent, sizeof(struct sch56xx_watchdog_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\tdata->addr = addr;\n\tdata->io_lock = io_lock;\n\n\tstrscpy(data->wdinfo.identity, \"sch56xx watchdog\", sizeof(data->wdinfo.identity));\n\tdata->wdinfo.firmware_version = revision;\n\tdata->wdinfo.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT;\n\tif (!nowayout)\n\t\tdata->wdinfo.options |= WDIOF_MAGICCLOSE;\n\n\tdata->wddev.info = &data->wdinfo;\n\tdata->wddev.ops = &watchdog_ops;\n\tdata->wddev.parent = parent;\n\tdata->wddev.timeout = 60;\n\tdata->wddev.min_timeout = 1;\n\tdata->wddev.max_timeout = 255 * 60;\n\twatchdog_set_nowayout(&data->wddev, nowayout);\n\tif (output_enable & SCH56XX_WDOG_OUTPUT_ENABLE)\n\t\tset_bit(WDOG_HW_RUNNING, &data->wddev.status);\n\n\t \n\tif (control & SCH56XX_WDOG_TIME_BASE_SEC)\n\t\tdata->watchdog_preset = 60;  \n\telse\n\t\tdata->watchdog_preset = 1;  \n\n\tdata->watchdog_control = control;\n\tdata->watchdog_output_enable = output_enable;\n\n\twatchdog_set_drvdata(&data->wddev, data);\n\terr = devm_watchdog_register_device(parent, &data->wddev);\n\tif (err) {\n\t\tpr_err(\"Registering watchdog chardev: %d\\n\", err);\n\t\tdevm_kfree(parent, data);\n\t}\n}\nEXPORT_SYMBOL(sch56xx_watchdog_register);\n\n \n\nstatic int __init sch56xx_find(int sioaddr, const char **name)\n{\n\tu8 devid;\n\tunsigned short address;\n\tint err;\n\n\terr = superio_enter(sioaddr);\n\tif (err)\n\t\treturn err;\n\n\tdevid = superio_inb(sioaddr, SIO_REG_DEVID);\n\tswitch (devid) {\n\tcase SIO_SCH5627_ID:\n\t\t*name = \"sch5627\";\n\t\tbreak;\n\tcase SIO_SCH5636_ID:\n\t\t*name = \"sch5636\";\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Unsupported device id: 0x%02x\\n\",\n\t\t\t (unsigned int)devid);\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tsuperio_select(sioaddr, SIO_SCH56XX_LD_EM);\n\n\tif (!(superio_inb(sioaddr, SIO_REG_ENABLE) & 0x01)) {\n\t\tpr_warn(\"Device not activated\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\taddress = superio_inb(sioaddr, SIO_REG_ADDR) |\n\t\t   superio_inb(sioaddr, SIO_REG_ADDR + 1) << 8;\n\tif (address == 0) {\n\t\tpr_warn(\"Base address not set\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\terr = address;\n\nexit:\n\tsuperio_exit(sioaddr);\n\treturn err;\n}\n\nstatic int __init sch56xx_device_add(int address, const char *name)\n{\n\tstruct resource res = {\n\t\t.start\t= address,\n\t\t.end\t= address + REGION_LENGTH - 1,\n\t\t.name\t= name,\n\t\t.flags\t= IORESOURCE_IO,\n\t};\n\tint err;\n\n\terr = acpi_check_resource_conflict(&res);\n\tif (err)\n\t\treturn err;\n\n\tsch56xx_pdev = platform_device_register_simple(name, -1, &res, 1);\n\n\treturn PTR_ERR_OR_ZERO(sch56xx_pdev);\n}\n\nstatic int __init sch56xx_init(void)\n{\n\tint address;\n\tconst char *name = NULL;\n\n\taddress = sch56xx_find(0x4e, &name);\n\tif (address < 0)\n\t\taddress = sch56xx_find(0x2e, &name);\n\tif (address < 0)\n\t\treturn address;\n\n\treturn sch56xx_device_add(address, name);\n}\n\nstatic void __exit sch56xx_exit(void)\n{\n\tplatform_device_unregister(sch56xx_pdev);\n}\n\nMODULE_DESCRIPTION(\"SMSC SCH56xx Hardware Monitoring Common Code\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(sch56xx_init);\nmodule_exit(sch56xx_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}