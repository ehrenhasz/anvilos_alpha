{
  "module_name": "max31722.c",
  "hash_id": "e8c403b8ba6b66feb5e4c4a156a85cf0887987132ae241ba7e2d4015e7128c99",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max31722.c",
  "human_readable_source": "\n \n\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n\n#define MAX31722_REG_CFG\t\t\t\t0x00\n#define MAX31722_REG_TEMP_LSB\t\t\t\t0x01\n\n#define MAX31722_MODE_CONTINUOUS\t\t\t0x00\n#define MAX31722_MODE_STANDBY\t\t\t\t0x01\n#define MAX31722_MODE_MASK\t\t\t\t0xFE\n#define MAX31722_RESOLUTION_12BIT\t\t\t0x06\n#define MAX31722_WRITE_MASK\t\t\t\t0x80\n\nstruct max31722_data {\n\tstruct device *hwmon_dev;\n\tstruct spi_device *spi_device;\n\tu8 mode;\n};\n\nstatic int max31722_set_mode(struct max31722_data *data, u8 mode)\n{\n\tint ret;\n\tstruct spi_device *spi = data->spi_device;\n\tu8 buf[2] = {\n\t\tMAX31722_REG_CFG | MAX31722_WRITE_MASK,\n\t\t(data->mode & MAX31722_MODE_MASK) | mode\n\t};\n\n\tret = spi_write(spi, &buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"failed to set sensor mode.\\n\");\n\t\treturn ret;\n\t}\n\tdata->mode = (data->mode & MAX31722_MODE_MASK) | mode;\n\n\treturn 0;\n}\n\nstatic ssize_t max31722_temp_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tssize_t ret;\n\tstruct max31722_data *data = dev_get_drvdata(dev);\n\n\tret = spi_w8r16(data->spi_device, MAX31722_REG_TEMP_LSB);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\treturn sprintf(buf, \"%d\\n\", (s16)le16_to_cpu(ret) * 125 / 32);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, max31722_temp, 0);\n\nstatic struct attribute *max31722_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(max31722);\n\nstatic int max31722_probe(struct spi_device *spi)\n{\n\tint ret;\n\tstruct max31722_data *data;\n\n\tdata = devm_kzalloc(&spi->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, data);\n\tdata->spi_device = spi;\n\t \n\tdata->mode = MAX31722_MODE_CONTINUOUS | MAX31722_RESOLUTION_12BIT;\n\tret = max31722_set_mode(data, MAX31722_MODE_CONTINUOUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->hwmon_dev = hwmon_device_register_with_groups(&spi->dev,\n\t\t\t\t\t\t\t    spi->modalias,\n\t\t\t\t\t\t\t    data,\n\t\t\t\t\t\t\t    max31722_groups);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\tmax31722_set_mode(data, MAX31722_MODE_STANDBY);\n\t\treturn PTR_ERR(data->hwmon_dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void max31722_remove(struct spi_device *spi)\n{\n\tstruct max31722_data *data = spi_get_drvdata(spi);\n\tint ret;\n\n\thwmon_device_unregister(data->hwmon_dev);\n\n\tret = max31722_set_mode(data, MAX31722_MODE_STANDBY);\n\tif (ret)\n\t\t \n\t\tdev_warn(&spi->dev, \"Failed to put device in stand-by mode\\n\");\n}\n\nstatic int max31722_suspend(struct device *dev)\n{\n\tstruct spi_device *spi_device = to_spi_device(dev);\n\tstruct max31722_data *data = spi_get_drvdata(spi_device);\n\n\treturn max31722_set_mode(data, MAX31722_MODE_STANDBY);\n}\n\nstatic int max31722_resume(struct device *dev)\n{\n\tstruct spi_device *spi_device = to_spi_device(dev);\n\tstruct max31722_data *data = spi_get_drvdata(spi_device);\n\n\treturn max31722_set_mode(data, MAX31722_MODE_CONTINUOUS);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(max31722_pm_ops, max31722_suspend, max31722_resume);\n\nstatic const struct spi_device_id max31722_spi_id[] = {\n\t{\"max31722\", 0},\n\t{\"max31723\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, max31722_spi_id);\n\nstatic struct spi_driver max31722_driver = {\n\t.driver = {\n\t\t.name = \"max31722\",\n\t\t.pm = pm_sleep_ptr(&max31722_pm_ops),\n\t},\n\t.probe =            max31722_probe,\n\t.remove =           max31722_remove,\n\t.id_table =         max31722_spi_id,\n};\n\nmodule_spi_driver(max31722_driver);\n\nMODULE_AUTHOR(\"Tiberiu Breana <tiberiu.a.breana@intel.com>\");\nMODULE_DESCRIPTION(\"max31722 sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}