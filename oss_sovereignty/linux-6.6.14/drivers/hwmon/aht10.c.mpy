{
  "module_name": "aht10.c",
  "hash_id": "c26339a1faa0caed69092d7f8f6b83e03d6094ee9bcc365b691531905fca34b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/aht10.c",
  "human_readable_source": "\n\n \n\n#include <linux/delay.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/crc8.h>\n\n#define AHT10_MEAS_SIZE\t\t6\n\n#define AHT20_MEAS_SIZE\t\t7\n#define AHT20_CRC8_POLY\t\t0x31\n\n \n#define AHT10_DEFAULT_MIN_POLL_INTERVAL\t2000\n#define AHT10_MIN_POLL_INTERVAL\t\t2000\n\n \n#define AHT10_MEAS_DELAY\t80000\n#define AHT10_CMD_DELAY\t\t350000\n#define AHT10_DELAY_EXTRA\t100000\n\n \n#define AHT10_CMD_INIT\t0b11100001\n#define AHT10_CMD_MEAS\t0b10101100\n#define AHT10_CMD_RST\t0b10111010\n\n \n#define AHT10_CAL_ENABLED\tBIT(3)\n#define AHT10_BUSY\t\tBIT(7)\n#define AHT10_MODE_NOR\t\t(BIT(5) | BIT(6))\n#define AHT10_MODE_CYC\t\tBIT(5)\n#define AHT10_MODE_CMD\t\tBIT(6)\n\n#define AHT10_MAX_POLL_INTERVAL_LEN\t30\n\nenum aht10_variant { aht10, aht20 };\n\nstatic const struct i2c_device_id aht10_id[] = {\n\t{ \"aht10\", aht10 },\n\t{ \"aht20\", aht20 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, aht10_id);\n\n \n\nstruct aht10_data {\n\tstruct i2c_client *client;\n\t \n\tstruct mutex lock;\n\tktime_t min_poll_interval;\n\tktime_t previous_poll_time;\n\tint temperature;\n\tint humidity;\n\tbool crc8;\n\tunsigned int meas_size;\n};\n\n \nstatic int aht10_init(struct aht10_data *data)\n{\n\tconst u8 cmd_init[] = {AHT10_CMD_INIT, AHT10_CAL_ENABLED | AHT10_MODE_CYC,\n\t\t\t       0x00};\n\tint res;\n\tu8 status;\n\tstruct i2c_client *client = data->client;\n\n\tres = i2c_master_send(client, cmd_init, 3);\n\tif (res < 0)\n\t\treturn res;\n\n\tusleep_range(AHT10_CMD_DELAY, AHT10_CMD_DELAY +\n\t\t     AHT10_DELAY_EXTRA);\n\n\tres = i2c_master_recv(client, &status, 1);\n\tif (res != 1)\n\t\treturn -ENODATA;\n\n\tif (status & AHT10_BUSY)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n \nstatic int aht10_polltime_expired(struct aht10_data *data)\n{\n\tktime_t current_time = ktime_get_boottime();\n\tktime_t difference = ktime_sub(current_time, data->previous_poll_time);\n\n\treturn ktime_after(difference, data->min_poll_interval);\n}\n\nDECLARE_CRC8_TABLE(crc8_table);\n\n \nstatic int crc8_check(u8 *raw_data, int count)\n{\n\t \n\treturn crc8(crc8_table, raw_data, count, CRC8_INIT_VALUE);\n}\n\n \nstatic int aht10_read_values(struct aht10_data *data)\n{\n\tconst u8 cmd_meas[] = {AHT10_CMD_MEAS, 0x33, 0x00};\n\tu32 temp, hum;\n\tint res;\n\tu8 raw_data[AHT20_MEAS_SIZE];\n\tstruct i2c_client *client = data->client;\n\n\tmutex_lock(&data->lock);\n\tif (!aht10_polltime_expired(data)) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn 0;\n\t}\n\n\tres = i2c_master_send(client, cmd_meas, sizeof(cmd_meas));\n\tif (res < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn res;\n\t}\n\n\tusleep_range(AHT10_MEAS_DELAY, AHT10_MEAS_DELAY + AHT10_DELAY_EXTRA);\n\n\tres = i2c_master_recv(client, raw_data, data->meas_size);\n\tif (res != data->meas_size) {\n\t\tmutex_unlock(&data->lock);\n\t\tif (res >= 0)\n\t\t\treturn -ENODATA;\n\t\treturn res;\n\t}\n\n\tif (data->crc8 && crc8_check(raw_data, data->meas_size)) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn -EIO;\n\t}\n\n\thum =   ((u32)raw_data[1] << 12u) |\n\t\t((u32)raw_data[2] << 4u) |\n\t\t((raw_data[3] & 0xF0u) >> 4u);\n\n\ttemp =  ((u32)(raw_data[3] & 0x0Fu) << 16u) |\n\t\t((u32)raw_data[4] << 8u) |\n\t\traw_data[5];\n\n\ttemp = ((temp * 625) >> 15u) * 10;\n\thum = ((hum * 625) >> 16u) * 10;\n\n\tdata->temperature = (int)temp - 50000;\n\tdata->humidity = hum;\n\tdata->previous_poll_time = ktime_get_boottime();\n\n\tmutex_unlock(&data->lock);\n\treturn 0;\n}\n\n \nstatic ssize_t aht10_interval_write(struct aht10_data *data,\n\t\t\t\t    long val)\n{\n\tdata->min_poll_interval = ms_to_ktime(clamp_val(val, 2000, LONG_MAX));\n\treturn 0;\n}\n\n \nstatic ssize_t aht10_interval_read(struct aht10_data *data,\n\t\t\t\t   long *val)\n{\n\t*val = ktime_to_ms(data->min_poll_interval);\n\treturn 0;\n}\n\n \nstatic int aht10_temperature1_read(struct aht10_data *data, long *val)\n{\n\tint res;\n\n\tres = aht10_read_values(data);\n\tif (res < 0)\n\t\treturn res;\n\n\t*val = data->temperature;\n\treturn 0;\n}\n\n \nstatic int aht10_humidity1_read(struct aht10_data *data, long *val)\n{\n\tint res;\n\n\tres = aht10_read_values(data);\n\tif (res < 0)\n\t\treturn res;\n\n\t*val = data->humidity;\n\treturn 0;\n}\n\nstatic umode_t aht10_hwmon_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t   u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\tcase hwmon_humidity:\n\t\treturn 0444;\n\tcase hwmon_chip:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int aht10_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t    u32 attr, int channel, long *val)\n{\n\tstruct aht10_data *data = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn aht10_temperature1_read(data, val);\n\tcase hwmon_humidity:\n\t\treturn aht10_humidity1_read(data, val);\n\tcase hwmon_chip:\n\t\treturn aht10_interval_read(data, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int aht10_hwmon_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel, long val)\n{\n\tstruct aht10_data *data = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn aht10_interval_write(data, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const aht10_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT),\n\tHWMON_CHANNEL_INFO(humidity, HWMON_H_INPUT),\n\tNULL,\n};\n\nstatic const struct hwmon_ops aht10_hwmon_ops = {\n\t.is_visible = aht10_hwmon_visible,\n\t.read = aht10_hwmon_read,\n\t.write = aht10_hwmon_write,\n};\n\nstatic const struct hwmon_chip_info aht10_chip_info = {\n\t.ops = &aht10_hwmon_ops,\n\t.info = aht10_info,\n};\n\nstatic int aht10_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_match_id(aht10_id, client);\n\tenum aht10_variant variant = id->driver_data;\n\tstruct device *device = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct aht10_data *data;\n\tint res;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENOENT;\n\n\tdata = devm_kzalloc(device, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->min_poll_interval = ms_to_ktime(AHT10_DEFAULT_MIN_POLL_INTERVAL);\n\tdata->client = client;\n\n\tswitch (variant) {\n\tcase aht20:\n\t\tdata->meas_size = AHT20_MEAS_SIZE;\n\t\tdata->crc8 = true;\n\t\tcrc8_populate_msb(crc8_table, AHT20_CRC8_POLY);\n\t\tbreak;\n\tdefault:\n\t\tdata->meas_size = AHT10_MEAS_SIZE;\n\t\tbreak;\n\t}\n\n\tmutex_init(&data->lock);\n\n\tres = aht10_init(data);\n\tif (res < 0)\n\t\treturn res;\n\n\tres = aht10_read_values(data);\n\tif (res < 0)\n\t\treturn res;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(device,\n\t\t\t\t\t\t\t client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &aht10_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic struct i2c_driver aht10_driver = {\n\t.driver = {\n\t\t.name = \"aht10\",\n\t},\n\t.probe      = aht10_probe,\n\t.id_table   = aht10_id,\n};\n\nmodule_i2c_driver(aht10_driver);\n\nMODULE_AUTHOR(\"Johannes Cornelis Draaijer <jcdra1@gmail.com>\");\nMODULE_DESCRIPTION(\"AHT10/AHT20 Temperature and Humidity sensor driver\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}