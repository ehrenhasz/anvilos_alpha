{
  "module_name": "ad7418.c",
  "hash_id": "7004198078120f2f6d27cac8ea2a7546da5a717831299f00a5d842692d2a58d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ad7418.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include \"lm75.h\"\n\n#define DRV_VERSION \"0.4\"\n\nenum chips { ad7416, ad7417, ad7418 };\n\n \n#define AD7418_REG_TEMP_IN\t0x00\n#define AD7418_REG_CONF\t\t0x01\n#define AD7418_REG_TEMP_HYST\t0x02\n#define AD7418_REG_TEMP_OS\t0x03\n#define AD7418_REG_ADC\t\t0x04\n#define AD7418_REG_CONF2\t0x05\n\n#define AD7418_REG_ADC_CH(x)\t((x) << 5)\n#define AD7418_CH_TEMP\t\tAD7418_REG_ADC_CH(0)\n\nstatic const u8 AD7418_REG_TEMP[] = { AD7418_REG_TEMP_IN,\n\t\t\t\t\tAD7418_REG_TEMP_HYST,\n\t\t\t\t\tAD7418_REG_TEMP_OS };\n\nstruct ad7418_data {\n\tstruct i2c_client\t*client;\n\tenum chips\t\ttype;\n\tstruct mutex\t\tlock;\n\tint\t\t\tadc_max;\t \n\tbool\t\t\tvalid;\n\tunsigned long\t\tlast_updated;\t \n\ts16\t\t\ttemp[3];\t \n\tu16\t\t\tin[4];\n};\n\nstatic int ad7418_update_device(struct device *dev)\n{\n\tstruct ad7418_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\ts32 val;\n\n\tmutex_lock(&data->lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\n\t\t|| !data->valid) {\n\t\tu8 cfg;\n\t\tint i, ch;\n\n\t\t \n\t\tval = i2c_smbus_read_byte_data(client, AD7418_REG_CONF);\n\t\tif (val < 0)\n\t\t\tgoto abort;\n\n\t\tcfg = val;\n\t\tcfg &= 0x1F;\n\n\t\tval = i2c_smbus_write_byte_data(client, AD7418_REG_CONF,\n\t\t\t\t\t\tcfg | AD7418_CH_TEMP);\n\t\tif (val < 0)\n\t\t\tgoto abort;\n\n\t\tudelay(30);\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tval = i2c_smbus_read_word_swapped(client,\n\t\t\t\t\t\t\t  AD7418_REG_TEMP[i]);\n\t\t\tif (val < 0)\n\t\t\t\tgoto abort;\n\n\t\t\tdata->temp[i] = val;\n\t\t}\n\n\t\tfor (i = 0, ch = 4; i < data->adc_max; i++, ch--) {\n\t\t\tval = i2c_smbus_write_byte_data(client, AD7418_REG_CONF,\n\t\t\t\t\tcfg | AD7418_REG_ADC_CH(ch));\n\t\t\tif (val < 0)\n\t\t\t\tgoto abort;\n\n\t\t\tudelay(15);\n\t\t\tval = i2c_smbus_read_word_swapped(client,\n\t\t\t\t\t\t\t  AD7418_REG_ADC);\n\t\t\tif (val < 0)\n\t\t\t\tgoto abort;\n\n\t\t\tdata->in[data->adc_max - 1 - i] = val;\n\t\t}\n\n\t\t \n\t\tval = i2c_smbus_write_word_swapped(client, AD7418_REG_CONF,\n\t\t\t\t\t\t   cfg);\n\t\tif (val < 0)\n\t\t\tgoto abort;\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->lock);\n\treturn 0;\n\nabort:\n\tdata->valid = false;\n\tmutex_unlock(&data->lock);\n\treturn val;\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct ad7418_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = ad7418_update_device(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\tLM75_TEMP_FROM_REG(data->temp[attr->index]));\n}\n\nstatic ssize_t adc_show(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct ad7418_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = ad7418_update_device(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t((data->in[attr->index] >> 6) * 2500 + 512) / 1024);\n}\n\nstatic ssize_t temp_store(struct device *dev,\n\t\t\t  struct device_attribute *devattr, const char *buf,\n\t\t\t  size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct ad7418_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong temp;\n\tint ret = kstrtol(buf, 10, &temp);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&data->lock);\n\tdata->temp[attr->index] = LM75_TEMP_TO_REG(temp);\n\ti2c_smbus_write_word_swapped(client,\n\t\t\t\t     AD7418_REG_TEMP[attr->index],\n\t\t\t\t     data->temp[attr->index]);\n\tmutex_unlock(&data->lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max_hyst, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp, 2);\n\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, adc, 0);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, adc, 1);\nstatic SENSOR_DEVICE_ATTR_RO(in3_input, adc, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in4_input, adc, 3);\n\nstatic struct attribute *ad7416_attrs[] = {\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(ad7416);\n\nstatic struct attribute *ad7417_attrs[] = {\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(ad7417);\n\nstatic struct attribute *ad7418_attrs[] = {\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(ad7418);\n\nstatic void ad7418_init_client(struct i2c_client *client)\n{\n\tstruct ad7418_data *data = i2c_get_clientdata(client);\n\n\tint reg = i2c_smbus_read_byte_data(client, AD7418_REG_CONF);\n\tif (reg < 0) {\n\t\tdev_err(&client->dev, \"cannot read configuration register\\n\");\n\t} else {\n\t\tdev_info(&client->dev, \"configuring for mode 1\\n\");\n\t\ti2c_smbus_write_byte_data(client, AD7418_REG_CONF, reg & 0xfe);\n\n\t\tif (data->type == ad7417 || data->type == ad7418)\n\t\t\ti2c_smbus_write_byte_data(client,\n\t\t\t\t\t\tAD7418_REG_CONF2, 0x00);\n\t}\n}\n\nstatic const struct i2c_device_id ad7418_id[];\n\nstatic int ad7418_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct ad7418_data *data;\n\tstruct device *hwmon_dev;\n\tconst struct attribute_group **attr_groups = NULL;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t\tI2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tdata = devm_kzalloc(dev, sizeof(struct ad7418_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\n\tmutex_init(&data->lock);\n\tdata->client = client;\n\tif (dev->of_node)\n\t\tdata->type = (uintptr_t)of_device_get_match_data(dev);\n\telse\n\t\tdata->type = i2c_match_id(ad7418_id, client)->driver_data;\n\n\tswitch (data->type) {\n\tcase ad7416:\n\t\tdata->adc_max = 0;\n\t\tattr_groups = ad7416_groups;\n\t\tbreak;\n\n\tcase ad7417:\n\t\tdata->adc_max = 4;\n\t\tattr_groups = ad7417_groups;\n\t\tbreak;\n\n\tcase ad7418:\n\t\tdata->adc_max = 1;\n\t\tattr_groups = ad7418_groups;\n\t\tbreak;\n\t}\n\n\tdev_info(dev, \"%s chip found\\n\", client->name);\n\n\t \n\tad7418_init_client(client);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev,\n\t\t\t\t\t\t\t   client->name,\n\t\t\t\t\t\t\t   data, attr_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id ad7418_id[] = {\n\t{ \"ad7416\", ad7416 },\n\t{ \"ad7417\", ad7417 },\n\t{ \"ad7418\", ad7418 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ad7418_id);\n\nstatic const struct of_device_id ad7418_dt_ids[] = {\n\t{ .compatible = \"adi,ad7416\", .data = (void *)ad7416, },\n\t{ .compatible = \"adi,ad7417\", .data = (void *)ad7417, },\n\t{ .compatible = \"adi,ad7418\", .data = (void *)ad7418, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ad7418_dt_ids);\n\nstatic struct i2c_driver ad7418_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7418\",\n\t\t.of_match_table = ad7418_dt_ids,\n\t},\n\t.probe\t\t= ad7418_probe,\n\t.id_table\t= ad7418_id,\n};\n\nmodule_i2c_driver(ad7418_driver);\n\nMODULE_AUTHOR(\"Alessandro Zummo <a.zummo@towertech.it>\");\nMODULE_DESCRIPTION(\"AD7416/17/18 driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}