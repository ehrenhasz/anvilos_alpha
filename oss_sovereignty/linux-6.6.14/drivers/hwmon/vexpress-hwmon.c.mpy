{
  "module_name": "vexpress-hwmon.c",
  "hash_id": "454a5c08da68da72d59686c707d7de5aa363a48f88a0e88844d3d11b487f6805",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/vexpress-hwmon.c",
  "human_readable_source": "\n \n\n#define DRVNAME \"vexpress-hwmon\"\n#define pr_fmt(fmt) DRVNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/vexpress.h>\n\nstruct vexpress_hwmon_data {\n\tstruct device *hwmon_dev;\n\tstruct regmap *reg;\n};\n\nstatic ssize_t vexpress_hwmon_label_show(struct device *dev,\n\t\tstruct device_attribute *dev_attr, char *buffer)\n{\n\tconst char *label = of_get_property(dev->of_node, \"label\", NULL);\n\n\treturn sysfs_emit(buffer, \"%s\\n\", label);\n}\n\nstatic ssize_t vexpress_hwmon_u32_show(struct device *dev,\n\t\tstruct device_attribute *dev_attr, char *buffer)\n{\n\tstruct vexpress_hwmon_data *data = dev_get_drvdata(dev);\n\tint err;\n\tu32 value;\n\n\terr = regmap_read(data->reg, 0, &value);\n\tif (err)\n\t\treturn err;\n\n\treturn sysfs_emit(buffer, \"%u\\n\", value /\n\t\t\t  to_sensor_dev_attr(dev_attr)->index);\n}\n\nstatic ssize_t vexpress_hwmon_u64_show(struct device *dev,\n\t\tstruct device_attribute *dev_attr, char *buffer)\n{\n\tstruct vexpress_hwmon_data *data = dev_get_drvdata(dev);\n\tint err;\n\tu32 value_hi, value_lo;\n\n\terr = regmap_read(data->reg, 0, &value_lo);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_read(data->reg, 1, &value_hi);\n\tif (err)\n\t\treturn err;\n\n\treturn sysfs_emit(buffer, \"%llu\\n\",\n\t\t\t  div_u64(((u64)value_hi << 32) | value_lo,\n\t\t\t\t  to_sensor_dev_attr(dev_attr)->index));\n}\n\nstatic umode_t vexpress_hwmon_attr_is_visible(struct kobject *kobj,\n\t\tstruct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct device_attribute *dev_attr = container_of(attr,\n\t\t\t\tstruct device_attribute, attr);\n\n\tif (dev_attr->show == vexpress_hwmon_label_show &&\n\t\t\t!of_get_property(dev->of_node, \"label\", NULL))\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstruct vexpress_hwmon_type {\n\tconst char *name;\n\tconst struct attribute_group **attr_groups;\n};\n\n#if !defined(CONFIG_REGULATOR_VEXPRESS)\nstatic DEVICE_ATTR(in1_label, 0444, vexpress_hwmon_label_show, NULL);\nstatic SENSOR_DEVICE_ATTR_RO(in1_input, vexpress_hwmon_u32, 1000);\nstatic struct attribute *vexpress_hwmon_attrs_volt[] = {\n\t&dev_attr_in1_label.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute_group vexpress_hwmon_group_volt = {\n\t.is_visible = vexpress_hwmon_attr_is_visible,\n\t.attrs = vexpress_hwmon_attrs_volt,\n};\nstatic struct vexpress_hwmon_type vexpress_hwmon_volt = {\n\t.name = \"vexpress_volt\",\n\t.attr_groups = (const struct attribute_group *[]) {\n\t\t&vexpress_hwmon_group_volt,\n\t\tNULL,\n\t},\n};\n#endif\n\nstatic DEVICE_ATTR(curr1_label, 0444, vexpress_hwmon_label_show, NULL);\nstatic SENSOR_DEVICE_ATTR_RO(curr1_input, vexpress_hwmon_u32, 1000);\nstatic struct attribute *vexpress_hwmon_attrs_amp[] = {\n\t&dev_attr_curr1_label.attr,\n\t&sensor_dev_attr_curr1_input.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute_group vexpress_hwmon_group_amp = {\n\t.is_visible = vexpress_hwmon_attr_is_visible,\n\t.attrs = vexpress_hwmon_attrs_amp,\n};\nstatic struct vexpress_hwmon_type vexpress_hwmon_amp = {\n\t.name = \"vexpress_amp\",\n\t.attr_groups = (const struct attribute_group *[]) {\n\t\t&vexpress_hwmon_group_amp,\n\t\tNULL\n\t},\n};\n\nstatic DEVICE_ATTR(temp1_label, 0444, vexpress_hwmon_label_show, NULL);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, vexpress_hwmon_u32, 1000);\nstatic struct attribute *vexpress_hwmon_attrs_temp[] = {\n\t&dev_attr_temp1_label.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute_group vexpress_hwmon_group_temp = {\n\t.is_visible = vexpress_hwmon_attr_is_visible,\n\t.attrs = vexpress_hwmon_attrs_temp,\n};\nstatic struct vexpress_hwmon_type vexpress_hwmon_temp = {\n\t.name = \"vexpress_temp\",\n\t.attr_groups = (const struct attribute_group *[]) {\n\t\t&vexpress_hwmon_group_temp,\n\t\tNULL\n\t},\n};\n\nstatic DEVICE_ATTR(power1_label, 0444, vexpress_hwmon_label_show, NULL);\nstatic SENSOR_DEVICE_ATTR_RO(power1_input, vexpress_hwmon_u32, 1);\nstatic struct attribute *vexpress_hwmon_attrs_power[] = {\n\t&dev_attr_power1_label.attr,\n\t&sensor_dev_attr_power1_input.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute_group vexpress_hwmon_group_power = {\n\t.is_visible = vexpress_hwmon_attr_is_visible,\n\t.attrs = vexpress_hwmon_attrs_power,\n};\nstatic struct vexpress_hwmon_type vexpress_hwmon_power = {\n\t.name = \"vexpress_power\",\n\t.attr_groups = (const struct attribute_group *[]) {\n\t\t&vexpress_hwmon_group_power,\n\t\tNULL\n\t},\n};\n\nstatic DEVICE_ATTR(energy1_label, 0444, vexpress_hwmon_label_show, NULL);\nstatic SENSOR_DEVICE_ATTR_RO(energy1_input, vexpress_hwmon_u64, 1);\nstatic struct attribute *vexpress_hwmon_attrs_energy[] = {\n\t&dev_attr_energy1_label.attr,\n\t&sensor_dev_attr_energy1_input.dev_attr.attr,\n\tNULL\n};\nstatic struct attribute_group vexpress_hwmon_group_energy = {\n\t.is_visible = vexpress_hwmon_attr_is_visible,\n\t.attrs = vexpress_hwmon_attrs_energy,\n};\nstatic struct vexpress_hwmon_type vexpress_hwmon_energy = {\n\t.name = \"vexpress_energy\",\n\t.attr_groups = (const struct attribute_group *[]) {\n\t\t&vexpress_hwmon_group_energy,\n\t\tNULL\n\t},\n};\n\nstatic const struct of_device_id vexpress_hwmon_of_match[] = {\n#if !defined(CONFIG_REGULATOR_VEXPRESS)\n\t{\n\t\t.compatible = \"arm,vexpress-volt\",\n\t\t.data = &vexpress_hwmon_volt,\n\t},\n#endif\n\t{\n\t\t.compatible = \"arm,vexpress-amp\",\n\t\t.data = &vexpress_hwmon_amp,\n\t}, {\n\t\t.compatible = \"arm,vexpress-temp\",\n\t\t.data = &vexpress_hwmon_temp,\n\t}, {\n\t\t.compatible = \"arm,vexpress-power\",\n\t\t.data = &vexpress_hwmon_power,\n\t}, {\n\t\t.compatible = \"arm,vexpress-energy\",\n\t\t.data = &vexpress_hwmon_energy,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, vexpress_hwmon_of_match);\n\nstatic int vexpress_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct vexpress_hwmon_data *data;\n\tconst struct vexpress_hwmon_type *type;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, data);\n\n\ttype = of_device_get_match_data(&pdev->dev);\n\tif (!type)\n\t\treturn -ENODEV;\n\n\tdata->reg = devm_regmap_init_vexpress_config(&pdev->dev);\n\tif (IS_ERR(data->reg))\n\t\treturn PTR_ERR(data->reg);\n\n\tdata->hwmon_dev = devm_hwmon_device_register_with_groups(&pdev->dev,\n\t\t\ttype->name, data, type->attr_groups);\n\n\treturn PTR_ERR_OR_ZERO(data->hwmon_dev);\n}\n\nstatic struct platform_driver vexpress_hwmon_driver = {\n\t.probe = vexpress_hwmon_probe,\n\t.driver\t= {\n\t\t.name = DRVNAME,\n\t\t.of_match_table = vexpress_hwmon_of_match,\n\t},\n};\n\nmodule_platform_driver(vexpress_hwmon_driver);\n\nMODULE_AUTHOR(\"Pawel Moll <pawel.moll@arm.com>\");\nMODULE_DESCRIPTION(\"Versatile Express hwmon sensors driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:vexpress-hwmon\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}