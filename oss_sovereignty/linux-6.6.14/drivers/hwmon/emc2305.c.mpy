{
  "module_name": "emc2305.c",
  "hash_id": "05a33fb6fbb2970d01252b53b8141e6350f505c87fff22dab4ee663e84495c19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/emc2305.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/platform_data/emc2305.h>\n#include <linux/thermal.h>\n\nstatic const unsigned short\nemc2305_normal_i2c[] = { 0x27, 0x2c, 0x2d, 0x2e, 0x2f, 0x4c, 0x4d, I2C_CLIENT_END };\n\n#define EMC2305_REG_DRIVE_FAIL_STATUS\t0x27\n#define EMC2305_REG_VENDOR\t\t0xfe\n#define EMC2305_FAN_MAX\t\t\t0xff\n#define EMC2305_FAN_MIN\t\t\t0x00\n#define EMC2305_FAN_MAX_STATE\t\t10\n#define EMC2305_DEVICE\t\t\t0x34\n#define EMC2305_VENDOR\t\t\t0x5d\n#define EMC2305_REG_PRODUCT_ID\t\t0xfd\n#define EMC2305_TACH_REGS_UNUSE_BITS\t3\n#define EMC2305_TACH_CNT_MULTIPLIER\t0x02\n#define EMC2305_TACH_RANGE_MIN\t\t480\n\n#define EMC2305_PWM_DUTY2STATE(duty, max_state, pwm_max) \\\n\tDIV_ROUND_CLOSEST((duty) * (max_state), (pwm_max))\n#define EMC2305_PWM_STATE2DUTY(state, max_state, pwm_max) \\\n\tDIV_ROUND_CLOSEST((state) * (pwm_max), (max_state))\n\n \n#define EMC2305_RPM_FACTOR\t\t3932160\n\n#define EMC2305_REG_FAN_DRIVE(n)\t(0x30 + 0x10 * (n))\n#define EMC2305_REG_FAN_MIN_DRIVE(n)\t(0x38 + 0x10 * (n))\n#define EMC2305_REG_FAN_TACH(n)\t\t(0x3e + 0x10 * (n))\n\nenum emc230x_product_id {\n\tEMC2305 = 0x34,\n\tEMC2303 = 0x35,\n\tEMC2302 = 0x36,\n\tEMC2301 = 0x37,\n};\n\nstatic const struct i2c_device_id emc2305_ids[] = {\n\t{ \"emc2305\", 0 },\n\t{ \"emc2303\", 0 },\n\t{ \"emc2302\", 0 },\n\t{ \"emc2301\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, emc2305_ids);\n\n \nstruct emc2305_cdev_data {\n\tstruct thermal_cooling_device *cdev;\n\tunsigned int cur_state;\n\tunsigned long last_hwmon_state;\n\tunsigned long last_thermal_state;\n};\n\n \nstruct emc2305_data {\n\tstruct i2c_client *client;\n\tstruct device *hwmon_dev;\n\tu8 max_state;\n\tu8 pwm_num;\n\tbool pwm_separate;\n\tu8 pwm_min[EMC2305_PWM_MAX];\n\tstruct emc2305_cdev_data cdev_data[EMC2305_PWM_MAX];\n};\n\nstatic char *emc2305_fan_name[] = {\n\t\"emc2305_fan\",\n\t\"emc2305_fan1\",\n\t\"emc2305_fan2\",\n\t\"emc2305_fan3\",\n\t\"emc2305_fan4\",\n\t\"emc2305_fan5\",\n};\n\nstatic void emc2305_unset_tz(struct device *dev);\n\nstatic int emc2305_get_max_channel(const struct emc2305_data *data)\n{\n\treturn data->pwm_num;\n}\n\nstatic int emc2305_get_cdev_idx(struct thermal_cooling_device *cdev)\n{\n\tstruct emc2305_data *data = cdev->devdata;\n\tsize_t len = strlen(cdev->type);\n\tint ret;\n\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (!data->pwm_separate)\n\t\treturn 0;\n\n\tret = cdev->type[len - 1];\n\tswitch (ret) {\n\tcase '1' ... '5':\n\t\treturn ret - '1';\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int emc2305_get_cur_state(struct thermal_cooling_device *cdev, unsigned long *state)\n{\n\tint cdev_idx;\n\tstruct emc2305_data *data = cdev->devdata;\n\n\tcdev_idx = emc2305_get_cdev_idx(cdev);\n\tif (cdev_idx < 0)\n\t\treturn cdev_idx;\n\n\t*state = data->cdev_data[cdev_idx].cur_state;\n\treturn 0;\n}\n\nstatic int emc2305_get_max_state(struct thermal_cooling_device *cdev, unsigned long *state)\n{\n\tstruct emc2305_data *data = cdev->devdata;\n\t*state = data->max_state;\n\treturn 0;\n}\n\nstatic int __emc2305_set_cur_state(struct emc2305_data *data, int cdev_idx, unsigned long state)\n{\n\tint ret;\n\tstruct i2c_client *client = data->client;\n\tu8 val, i;\n\n\tstate = max_t(unsigned long, state, data->cdev_data[cdev_idx].last_hwmon_state);\n\n\tval = EMC2305_PWM_STATE2DUTY(state, data->max_state, EMC2305_FAN_MAX);\n\n\tdata->cdev_data[cdev_idx].cur_state = state;\n\tif (data->pwm_separate) {\n\t\tret = i2c_smbus_write_byte_data(client, EMC2305_REG_FAN_DRIVE(cdev_idx), val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tfor (i = 0; i < data->pwm_num; i++) {\n\t\t\tret = i2c_smbus_write_byte_data(client, EMC2305_REG_FAN_DRIVE(i), val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int emc2305_set_cur_state(struct thermal_cooling_device *cdev, unsigned long state)\n{\n\tint cdev_idx, ret;\n\tstruct emc2305_data *data = cdev->devdata;\n\n\tif (state > data->max_state)\n\t\treturn -EINVAL;\n\n\tcdev_idx =  emc2305_get_cdev_idx(cdev);\n\tif (cdev_idx < 0)\n\t\treturn cdev_idx;\n\n\t \n\tdata->cdev_data[cdev_idx].last_thermal_state = state;\n\tret = __emc2305_set_cur_state(data, cdev_idx, state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct thermal_cooling_device_ops emc2305_cooling_ops = {\n\t.get_max_state = emc2305_get_max_state,\n\t.get_cur_state = emc2305_get_cur_state,\n\t.set_cur_state = emc2305_set_cur_state,\n};\n\nstatic int emc2305_show_fault(struct device *dev, int channel)\n{\n\tstruct emc2305_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint status_reg;\n\n\tstatus_reg = i2c_smbus_read_byte_data(client, EMC2305_REG_DRIVE_FAIL_STATUS);\n\tif (status_reg < 0)\n\t\treturn status_reg;\n\n\treturn status_reg & (1 << channel) ? 1 : 0;\n}\n\nstatic int emc2305_show_fan(struct device *dev, int channel)\n{\n\tstruct emc2305_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tret = i2c_smbus_read_word_swapped(client, EMC2305_REG_FAN_TACH(channel));\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = ret >> EMC2305_TACH_REGS_UNUSE_BITS;\n\tret = EMC2305_RPM_FACTOR / ret;\n\tif (ret <= EMC2305_TACH_RANGE_MIN)\n\t\treturn 0;\n\n\treturn ret * EMC2305_TACH_CNT_MULTIPLIER;\n}\n\nstatic int emc2305_show_pwm(struct device *dev, int channel)\n{\n\tstruct emc2305_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\treturn i2c_smbus_read_byte_data(client, EMC2305_REG_FAN_DRIVE(channel));\n}\n\nstatic int emc2305_set_pwm(struct device *dev, long val, int channel)\n{\n\tstruct emc2305_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tif (val < data->pwm_min[channel] || val > EMC2305_FAN_MAX)\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_write_byte_data(client, EMC2305_REG_FAN_DRIVE(channel), val);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->cdev_data[channel].cur_state = EMC2305_PWM_DUTY2STATE(val, data->max_state,\n\t\t\t\t\t\t\t\t    EMC2305_FAN_MAX);\n\treturn 0;\n}\n\nstatic int emc2305_set_single_tz(struct device *dev, int idx)\n{\n\tstruct emc2305_data *data = dev_get_drvdata(dev);\n\tlong pwm;\n\tint i, cdev_idx, ret;\n\n\tcdev_idx = (idx) ? idx - 1 : 0;\n\tpwm = data->pwm_min[cdev_idx];\n\n\tdata->cdev_data[cdev_idx].cdev =\n\t\tthermal_cooling_device_register(emc2305_fan_name[idx], data,\n\t\t\t\t\t\t&emc2305_cooling_ops);\n\n\tif (IS_ERR(data->cdev_data[cdev_idx].cdev)) {\n\t\tdev_err(dev, \"Failed to register cooling device %s\\n\", emc2305_fan_name[idx]);\n\t\treturn PTR_ERR(data->cdev_data[cdev_idx].cdev);\n\t}\n\t \n\tif (data->pwm_separate) {\n\t\tret = emc2305_set_pwm(dev, pwm, cdev_idx);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tfor (i = 0; i < data->pwm_num; i++) {\n\t\t\tret = emc2305_set_pwm(dev, pwm, i);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tdata->cdev_data[cdev_idx].cur_state =\n\t\tEMC2305_PWM_DUTY2STATE(data->pwm_min[cdev_idx], data->max_state,\n\t\t\t\t       EMC2305_FAN_MAX);\n\tdata->cdev_data[cdev_idx].last_hwmon_state =\n\t\tEMC2305_PWM_DUTY2STATE(data->pwm_min[cdev_idx], data->max_state,\n\t\t\t\t       EMC2305_FAN_MAX);\n\treturn 0;\n}\n\nstatic int emc2305_set_tz(struct device *dev)\n{\n\tstruct emc2305_data *data = dev_get_drvdata(dev);\n\tint i, ret;\n\n\tif (!data->pwm_separate)\n\t\treturn emc2305_set_single_tz(dev, 0);\n\n\tfor (i = 0; i < data->pwm_num; i++) {\n\t\tret = emc2305_set_single_tz(dev, i + 1);\n\t\tif (ret)\n\t\t\tgoto thermal_cooling_device_register_fail;\n\t}\n\treturn 0;\n\nthermal_cooling_device_register_fail:\n\temc2305_unset_tz(dev);\n\treturn ret;\n}\n\nstatic void emc2305_unset_tz(struct device *dev)\n{\n\tstruct emc2305_data *data = dev_get_drvdata(dev);\n\tint i;\n\n\t \n\tfor (i = 0; i < EMC2305_PWM_MAX; i++)\n\t\tif (data->cdev_data[i].cdev)\n\t\t\tthermal_cooling_device_unregister(data->cdev_data[i].cdev);\n}\n\nstatic umode_t\nemc2305_is_visible(const void *data, enum hwmon_sensor_types type, u32 attr, int channel)\n{\n\tint max_channel = emc2305_get_max_channel(data);\n\n\t \n\tif (channel >= max_channel)\n\t\treturn 0;\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\treturn 0444;\n\t\tcase hwmon_fan_fault:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n};\n\nstatic int\nemc2305_write(struct device *dev, enum hwmon_sensor_types type, u32 attr, int channel, long val)\n{\n\tstruct emc2305_data *data = dev_get_drvdata(dev);\n\tint cdev_idx;\n\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\t \n\t\t\tif (IS_REACHABLE(CONFIG_THERMAL)) {\n\t\t\t\tif (data->pwm_separate)\n\t\t\t\t\tcdev_idx = channel;\n\t\t\t\telse\n\t\t\t\t\tcdev_idx = 0;\n\t\t\t\tdata->cdev_data[cdev_idx].last_hwmon_state =\n\t\t\t\t\tEMC2305_PWM_DUTY2STATE(val, data->max_state,\n\t\t\t\t\t\t\t       EMC2305_FAN_MAX);\n\t\t\t\t \n\t\t\t\tif (data->cdev_data[cdev_idx].last_hwmon_state >=\n\t\t\t\t    data->cdev_data[cdev_idx].last_thermal_state)\n\t\t\t\t\treturn __emc2305_set_cur_state(data, cdev_idx,\n\t\t\t\t\t\t\tdata->cdev_data[cdev_idx].last_hwmon_state);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn emc2305_set_pwm(dev, val, channel);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n};\n\nstatic int\nemc2305_read(struct device *dev, enum hwmon_sensor_types type, u32 attr, int channel, long *val)\n{\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\tret = emc2305_show_fan(dev, channel);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\treturn 0;\n\t\tcase hwmon_fan_fault:\n\t\t\tret = emc2305_show_fault(dev, channel);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\tret = emc2305_show_pwm(dev, channel);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n};\n\nstatic const struct hwmon_ops emc2305_ops = {\n\t.is_visible = emc2305_is_visible,\n\t.read = emc2305_read,\n\t.write = emc2305_write,\n};\n\nstatic const struct hwmon_channel_info * const emc2305_info[] = {\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_FAULT),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info emc2305_chip_info = {\n\t.ops = &emc2305_ops,\n\t.info = emc2305_info,\n};\n\nstatic int emc2305_identify(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct emc2305_data *data = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, EMC2305_REG_PRODUCT_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret) {\n\tcase EMC2305:\n\t\tdata->pwm_num = 5;\n\t\tbreak;\n\tcase EMC2303:\n\t\tdata->pwm_num = 3;\n\t\tbreak;\n\tcase EMC2302:\n\t\tdata->pwm_num = 2;\n\t\tbreak;\n\tcase EMC2301:\n\t\tdata->pwm_num = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int emc2305_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &client->dev;\n\tstruct emc2305_data *data;\n\tstruct emc2305_platform_data *pdata;\n\tint vendor;\n\tint ret;\n\tint i;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tvendor = i2c_smbus_read_byte_data(client, EMC2305_REG_VENDOR);\n\tif (vendor != EMC2305_VENDOR)\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tdata->client = client;\n\n\tret = emc2305_identify(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpdata = dev_get_platdata(&client->dev);\n\tif (pdata) {\n\t\tif (!pdata->max_state || pdata->max_state > EMC2305_FAN_MAX_STATE)\n\t\t\treturn -EINVAL;\n\t\tdata->max_state = pdata->max_state;\n\t\t \n\t\tif (!pdata->pwm_num || pdata->pwm_num > EMC2305_PWM_MAX)\n\t\t\treturn -EINVAL;\n\t\tdata->pwm_num = pdata->pwm_num;\n\t\tdata->pwm_separate = pdata->pwm_separate;\n\t\tfor (i = 0; i < EMC2305_PWM_MAX; i++)\n\t\t\tdata->pwm_min[i] = pdata->pwm_min[i];\n\t} else {\n\t\tdata->max_state = EMC2305_FAN_MAX_STATE;\n\t\tdata->pwm_separate = false;\n\t\tfor (i = 0; i < EMC2305_PWM_MAX; i++)\n\t\t\tdata->pwm_min[i] = EMC2305_FAN_MIN;\n\t}\n\n\tdata->hwmon_dev = devm_hwmon_device_register_with_info(dev, \"emc2305\", data,\n\t\t\t\t\t\t\t       &emc2305_chip_info, NULL);\n\tif (IS_ERR(data->hwmon_dev))\n\t\treturn PTR_ERR(data->hwmon_dev);\n\n\tif (IS_REACHABLE(CONFIG_THERMAL)) {\n\t\tret = emc2305_set_tz(dev);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < data->pwm_num; i++) {\n\t\tret = i2c_smbus_write_byte_data(client, EMC2305_REG_FAN_MIN_DRIVE(i),\n\t\t\t\t\t\tdata->pwm_min[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void emc2305_remove(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\n\tif (IS_REACHABLE(CONFIG_THERMAL))\n\t\temc2305_unset_tz(dev);\n}\n\nstatic struct i2c_driver emc2305_driver = {\n\t.class  = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"emc2305\",\n\t},\n\t.probe = emc2305_probe,\n\t.remove\t  = emc2305_remove,\n\t.id_table = emc2305_ids,\n\t.address_list = emc2305_normal_i2c,\n};\n\nmodule_i2c_driver(emc2305_driver);\n\nMODULE_AUTHOR(\"Nvidia\");\nMODULE_DESCRIPTION(\"Microchip EMC2305 fan controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}