{
  "module_name": "hwmon-vid.c",
  "hash_id": "75d335f21c4d84c8a08f21e937068f0208428884253f260140ade2f4ecf5ce2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/hwmon-vid.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/hwmon-vid.h>\n\n \n\n \nint vid_from_reg(int val, u8 vrm)\n{\n\tint vid;\n\n\tswitch (vrm) {\n\n\tcase 100:\t\t \n\t\t \n\t\tval &= 0x3f;\n\t\tif ((val & 0x1f) == 0x1f)\n\t\t\treturn 0;\n\t\tif ((val & 0x1f) <= 0x09 || val == 0x0a)\n\t\t\tvid = 1087500 - (val & 0x1f) * 25000;\n\t\telse\n\t\t\tvid = 1862500 - (val & 0x1f) * 25000;\n\t\tif (val & 0x20)\n\t\t\tvid -= 12500;\n\t\treturn (vid + 500) / 1000;\n\n\tcase 110:\t\t \n\t\t\t\t \n\t\tval &= 0xff;\n\t\tif (val < 0x02 || val > 0xb2)\n\t\t\treturn 0;\n\t\treturn (1600000 - (val - 2) * 6250 + 500) / 1000;\n\n\tcase 24:\t\t \n\t\tval &= 0x1f;\n\t\tif (val == 0x1f)\n\t\t\treturn 0;\n\t\tfallthrough;\n\tcase 25:\t\t \n\t\tval &= 0x3f;\n\t\treturn (val < 32) ? 1550 - 25 * val\n\t\t\t: 775 - (25 * (val - 31)) / 2;\n\n\tcase 26:\t\t \n\t\tval &= 0x7f;\n\t\tif (val >= 0x7c)\n\t\t\treturn 0;\n\t\treturn DIV_ROUND_CLOSEST(15500 - 125 * val, 10);\n\n\tcase 91:\t\t \n\tcase 90:\t\t \n\t\tval &= 0x1f;\n\t\treturn val == 0x1f ? 0 :\n\t\t\t\t     1850 - val * 25;\n\n\tcase 85:\t\t \n\t\tval &= 0x1f;\n\t\treturn (val & 0x10  ? 25 : 0) +\n\t\t       ((val & 0x0f) > 0x04 ? 2050 : 1250) -\n\t\t       ((val & 0x0f) * 50);\n\n\tcase 84:\t\t \n\t\tval &= 0x0f;\n\t\tfallthrough;\n\tcase 82:\t\t \n\t\tval &= 0x1f;\n\t\treturn val == 0x1f ? 0 :\n\t\t       val & 0x10  ? 5100 - (val) * 100 :\n\t\t\t\t     2050 - (val) * 50;\n\tcase 17:\t\t \n\t\tval &= 0x1f;\n\t\treturn val & 0x10 ? 975 - (val & 0xF) * 25 :\n\t\t\t\t    1750 - val * 50;\n\tcase 13:\n\tcase 131:\n\t\tval &= 0x3f;\n\t\t \n\t\tif (vrm == 131 && val == 0x3f)\n\t\t\tval++;\n\t\treturn 1708 - val * 16;\n\tcase 14:\t\t \n\t\t\t\t \n\t\tval &= 0x7f;\n\t\treturn val > 0x77 ? 0 : (1500000 - (val * 12500) + 500) / 1000;\n\tdefault:\t\t \n\t\tif (vrm)\n\t\t\tpr_warn(\"Requested unsupported VRM version (%u)\\n\",\n\t\t\t\t(unsigned int)vrm);\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(vid_from_reg);\n\n \n\nstruct vrm_model {\n\tu8 vendor;\n\tu8 family;\n\tu8 model_from;\n\tu8 model_to;\n\tu8 stepping_to;\n\tu8 vrm_type;\n};\n\n#define ANY 0xFF\n\n#ifdef CONFIG_X86\n\n \n\nstatic struct vrm_model vrm_models[] = {\n\t{X86_VENDOR_AMD, 0x6, 0x0, ANY, ANY, 90},\t \n\t{X86_VENDOR_AMD, 0xF, 0x0, 0x3F, ANY, 24},\t \n\t \n\t{X86_VENDOR_AMD, 0xF, 0x40, 0x7F, ANY, 24},\t \n\t{X86_VENDOR_AMD, 0xF, 0x80, ANY, ANY, 25},\t \n\t{X86_VENDOR_AMD, 0x10, 0x0, ANY, ANY, 25},\t \n\t{X86_VENDOR_AMD, 0x11, 0x0, ANY, ANY, 26},\t \n\t{X86_VENDOR_AMD, 0x12, 0x0, ANY, ANY, 26},\t \n\t{X86_VENDOR_AMD, 0x14, 0x0, ANY, ANY, 26},\t \n\t{X86_VENDOR_AMD, 0x15, 0x0, ANY, ANY, 26},\t \n\n\t{X86_VENDOR_INTEL, 0x6, 0x0, 0x6, ANY, 82},\t \n\t{X86_VENDOR_INTEL, 0x6, 0x7, 0x7, ANY, 84},\t \n\t{X86_VENDOR_INTEL, 0x6, 0x8, 0x8, ANY, 82},\t \n\t{X86_VENDOR_INTEL, 0x6, 0x9, 0x9, ANY, 13},\t \n\t{X86_VENDOR_INTEL, 0x6, 0xA, 0xA, ANY, 82},\t \n\t{X86_VENDOR_INTEL, 0x6, 0xB, 0xB, ANY, 85},\t \n\t{X86_VENDOR_INTEL, 0x6, 0xD, 0xD, ANY, 13},\t \n\t{X86_VENDOR_INTEL, 0x6, 0xE, 0xE, ANY, 14},\t \n\t{X86_VENDOR_INTEL, 0x6, 0xF, ANY, ANY, 110},\t \n\t{X86_VENDOR_INTEL, 0xF, 0x0, 0x0, ANY, 90},\t \n\t{X86_VENDOR_INTEL, 0xF, 0x1, 0x1, ANY, 90},\t \n\t{X86_VENDOR_INTEL, 0xF, 0x2, 0x2, ANY, 90},\t \n\t{X86_VENDOR_INTEL, 0xF, 0x3, ANY, ANY, 100},\t \n\n\t{X86_VENDOR_CENTAUR, 0x6, 0x7, 0x7, ANY, 85},\t \n\t{X86_VENDOR_CENTAUR, 0x6, 0x8, 0x8, 0x7, 85},\t \n\t{X86_VENDOR_CENTAUR, 0x6, 0x9, 0x9, 0x7, 85},\t \n\t{X86_VENDOR_CENTAUR, 0x6, 0x9, 0x9, ANY, 17},\t \n\t{X86_VENDOR_CENTAUR, 0x6, 0xA, 0xA, 0x7, 0},\t \n\t{X86_VENDOR_CENTAUR, 0x6, 0xA, 0xA, ANY, 13},\t \n\t{X86_VENDOR_CENTAUR, 0x6, 0xD, 0xD, ANY, 134},\t \n};\n\n \nstatic u8 get_via_model_d_vrm(void)\n{\n\tunsigned int vid, brand, __maybe_unused dummy;\n\tstatic const char *brands[4] = {\n\t\t\"C7-M\", \"C7\", \"Eden\", \"C7-D\"\n\t};\n\n\trdmsr(0x198, dummy, vid);\n\tvid &= 0xff;\n\n\trdmsr(0x1154, brand, dummy);\n\tbrand = ((brand >> 4) ^ (brand >> 2)) & 0x03;\n\n\tif (vid > 0x3f) {\n\t\tpr_info(\"Using %d-bit VID table for VIA %s CPU\\n\",\n\t\t\t7, brands[brand]);\n\t\treturn 14;\n\t} else {\n\t\tpr_info(\"Using %d-bit VID table for VIA %s CPU\\n\",\n\t\t\t6, brands[brand]);\n\t\t \n\t\treturn brand == 2 ? 131 : 13;\n\t}\n}\n\nstatic u8 find_vrm(u8 family, u8 model, u8 stepping, u8 vendor)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vrm_models); i++) {\n\t\tif (vendor == vrm_models[i].vendor &&\n\t\t    family == vrm_models[i].family &&\n\t\t    model >= vrm_models[i].model_from &&\n\t\t    model <= vrm_models[i].model_to &&\n\t\t    stepping <= vrm_models[i].stepping_to)\n\t\t\treturn vrm_models[i].vrm_type;\n\t}\n\n\treturn 0;\n}\n\nu8 vid_which_vrm(void)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(0);\n\tu8 vrm_ret;\n\n\tif (c->x86 < 6)\t\t \n\t\treturn 0;\t \n\n\tvrm_ret = find_vrm(c->x86, c->x86_model, c->x86_stepping, c->x86_vendor);\n\tif (vrm_ret == 134)\n\t\tvrm_ret = get_via_model_d_vrm();\n\tif (vrm_ret == 0)\n\t\tpr_info(\"Unknown VRM version of your x86 CPU\\n\");\n\treturn vrm_ret;\n}\n\n \n#else\nu8 vid_which_vrm(void)\n{\n\tpr_info(\"Unknown VRM version of your CPU\\n\");\n\treturn 0;\n}\n#endif\nEXPORT_SYMBOL(vid_which_vrm);\n\nMODULE_AUTHOR(\"Rudolf Marek <r.marek@assembler.cz>\");\n\nMODULE_DESCRIPTION(\"hwmon-vid driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}