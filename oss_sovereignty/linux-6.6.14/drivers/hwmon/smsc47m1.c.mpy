{
  "module_name": "smsc47m1.c",
  "hash_id": "40f6a03e32bf49979c0686817d59f9f3c88a52802674715c1670d9e8ec53a62f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/smsc47m1.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\nstatic unsigned short force_id;\nmodule_param(force_id, ushort, 0);\nMODULE_PARM_DESC(force_id, \"Override the detected device ID\");\n\nstatic struct platform_device *pdev;\n\n#define DRVNAME \"smsc47m1\"\nenum chips { smsc47m1, smsc47m2 };\n\n \n\n#define REG\t0x2e\t \n#define VAL\t0x2f\t \n\nstatic inline void\nsuperio_outb(int reg, int val)\n{\n\toutb(reg, REG);\n\toutb(val, VAL);\n}\n\nstatic inline int\nsuperio_inb(int reg)\n{\n\toutb(reg, REG);\n\treturn inb(VAL);\n}\n\n \n#define superio_select() superio_outb(0x07, 0x0A)\n\nstatic inline int\nsuperio_enter(void)\n{\n\tif (!request_muxed_region(REG, 2, DRVNAME))\n\t\treturn -EBUSY;\n\n\toutb(0x55, REG);\n\treturn 0;\n}\n\nstatic inline void\nsuperio_exit(void)\n{\n\toutb(0xAA, REG);\n\trelease_region(REG, 2);\n}\n\n#define SUPERIO_REG_ACT\t\t0x30\n#define SUPERIO_REG_BASE\t0x60\n#define SUPERIO_REG_DEVID\t0x20\n#define SUPERIO_REG_DEVREV\t0x21\n\n \n\n#define SMSC_EXTENT\t\t0x80\n\n \n#define SMSC47M1_REG_ALARM\t\t0x04\n#define SMSC47M1_REG_TPIN(nr)\t\t(0x34 - (nr))\n#define SMSC47M1_REG_PPIN(nr)\t\t(0x36 - (nr))\n#define SMSC47M1_REG_FANDIV\t\t0x58\n\nstatic const u8 SMSC47M1_REG_FAN[3]\t\t= { 0x59, 0x5a, 0x6b };\nstatic const u8 SMSC47M1_REG_FAN_PRELOAD[3]\t= { 0x5b, 0x5c, 0x6c };\nstatic const u8 SMSC47M1_REG_PWM[3]\t\t= { 0x56, 0x57, 0x69 };\n\n#define SMSC47M2_REG_ALARM6\t\t0x09\n#define SMSC47M2_REG_TPIN1\t\t0x38\n#define SMSC47M2_REG_TPIN2\t\t0x37\n#define SMSC47M2_REG_TPIN3\t\t0x2d\n#define SMSC47M2_REG_PPIN3\t\t0x2c\n#define SMSC47M2_REG_FANDIV3\t\t0x6a\n\n#define MIN_FROM_REG(reg, div)\t\t((reg) >= 192 ? 0 : \\\n\t\t\t\t\t 983040 / ((192 - (reg)) * (div)))\n#define FAN_FROM_REG(reg, div, preload)\t((reg) <= (preload) || (reg) == 255 ? \\\n\t\t\t\t\t 0 : \\\n\t\t\t\t\t 983040 / (((reg) - (preload)) * (div)))\n#define DIV_FROM_REG(reg)\t\t(1 << (reg))\n#define PWM_FROM_REG(reg)\t\t(((reg) & 0x7E) << 1)\n#define PWM_EN_FROM_REG(reg)\t\t((~(reg)) & 0x01)\n#define PWM_TO_REG(reg)\t\t\t(((reg) >> 1) & 0x7E)\n\nstruct smsc47m1_data {\n\tunsigned short addr;\n\tconst char *name;\n\tenum chips type;\n\tstruct device *hwmon_dev;\n\n\tstruct mutex update_lock;\n\tunsigned long last_updated;\t \n\n\tu8 fan[3];\t\t \n\tu8 fan_preload[3];\t \n\tu8 fan_div[3];\t\t \n\tu8 alarms;\t\t \n\tu8 pwm[3];\t\t \n};\n\nstruct smsc47m1_sio_data {\n\tenum chips type;\n\tu8 activate;\t\t \n};\n\nstatic inline int smsc47m1_read_value(struct smsc47m1_data *data, u8 reg)\n{\n\treturn inb_p(data->addr + reg);\n}\n\nstatic inline void smsc47m1_write_value(struct smsc47m1_data *data, u8 reg,\n\t\tu8 value)\n{\n\toutb_p(value, data->addr + reg);\n}\n\nstatic struct smsc47m1_data *smsc47m1_update_device(struct device *dev,\n\t\tint init)\n{\n\tstruct smsc47m1_data *data = dev_get_drvdata(dev);\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2) || init) {\n\t\tint i, fan_nr;\n\t\tfan_nr = data->type == smsc47m2 ? 3 : 2;\n\n\t\tfor (i = 0; i < fan_nr; i++) {\n\t\t\tdata->fan[i] = smsc47m1_read_value(data,\n\t\t\t\t       SMSC47M1_REG_FAN[i]);\n\t\t\tdata->fan_preload[i] = smsc47m1_read_value(data,\n\t\t\t\t\t       SMSC47M1_REG_FAN_PRELOAD[i]);\n\t\t\tdata->pwm[i] = smsc47m1_read_value(data,\n\t\t\t\t       SMSC47M1_REG_PWM[i]);\n\t\t}\n\n\t\ti = smsc47m1_read_value(data, SMSC47M1_REG_FANDIV);\n\t\tdata->fan_div[0] = (i >> 4) & 0x03;\n\t\tdata->fan_div[1] = i >> 6;\n\n\t\tdata->alarms = smsc47m1_read_value(data,\n\t\t\t       SMSC47M1_REG_ALARM) >> 6;\n\t\t \n\t\tif (data->alarms)\n\t\t\tsmsc47m1_write_value(data, SMSC47M1_REG_ALARM, 0xC0);\n\n\t\tif (fan_nr >= 3) {\n\t\t\tdata->fan_div[2] = (smsc47m1_read_value(data,\n\t\t\t\t\t    SMSC47M2_REG_FANDIV3) >> 4) & 0x03;\n\t\t\tdata->alarms |= (smsc47m1_read_value(data,\n\t\t\t\t\t SMSC47M2_REG_ALARM6) & 0x40) >> 4;\n\t\t\t \n\t\t\tif (data->alarms & 0x04)\n\t\t\t\tsmsc47m1_write_value(data,\n\t\t\t\t\t\t     SMSC47M2_REG_ALARM6,\n\t\t\t\t\t\t     0x40);\n\t\t}\n\n\t\tdata->last_updated = jiffies;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\treturn data;\n}\n\nstatic ssize_t fan_show(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\n\tint nr = attr->index;\n\t \n\tint rpm = (data->pwm[nr] & 0x7F) == 0x00 ? 0 :\n\t\t  FAN_FROM_REG(data->fan[nr],\n\t\t\t       DIV_FROM_REG(data->fan_div[nr]),\n\t\t\t       data->fan_preload[nr]);\n\treturn sprintf(buf, \"%d\\n\", rpm);\n}\n\nstatic ssize_t fan_min_show(struct device *dev,\n\t\t\t    struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\n\tint nr = attr->index;\n\tint rpm = MIN_FROM_REG(data->fan_preload[nr],\n\t\t\t       DIV_FROM_REG(data->fan_div[nr]));\n\treturn sprintf(buf, \"%d\\n\", rpm);\n}\n\nstatic ssize_t fan_div_show(struct device *dev,\n\t\t\t    struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\n\treturn sprintf(buf, \"%d\\n\", DIV_FROM_REG(data->fan_div[attr->index]));\n}\n\nstatic ssize_t fan_alarm_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tint bitnr = to_sensor_dev_attr(devattr)->index;\n\tstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> bitnr) & 1);\n}\n\nstatic ssize_t pwm_show(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\n\treturn sprintf(buf, \"%d\\n\", PWM_FROM_REG(data->pwm[attr->index]));\n}\n\nstatic ssize_t pwm_en_show(struct device *dev,\n\t\t\t   struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\n\treturn sprintf(buf, \"%d\\n\", PWM_EN_FROM_REG(data->pwm[attr->index]));\n}\n\nstatic ssize_t alarms_show(struct device *dev,\n\t\t\t   struct device_attribute *devattr, char *buf)\n{\n\tstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\n\treturn sprintf(buf, \"%d\\n\", data->alarms);\n}\n\nstatic ssize_t fan_min_store(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct smsc47m1_data *data = dev_get_drvdata(dev);\n\tint nr = attr->index;\n\tlong rpmdiv;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\trpmdiv = val * DIV_FROM_REG(data->fan_div[nr]);\n\n\tif (983040 > 192 * rpmdiv || 2 * rpmdiv > 983040) {\n\t\tmutex_unlock(&data->update_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tdata->fan_preload[nr] = 192 - ((983040 + rpmdiv / 2) / rpmdiv);\n\tsmsc47m1_write_value(data, SMSC47M1_REG_FAN_PRELOAD[nr],\n\t\t\t     data->fan_preload[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \nstatic ssize_t fan_div_store(struct device *dev,\n\t\t\t     struct device_attribute *devattr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct smsc47m1_data *data = dev_get_drvdata(dev);\n\tint nr = attr->index;\n\tlong new_div;\n\tint err;\n\tlong tmp;\n\tu8 old_div = DIV_FROM_REG(data->fan_div[nr]);\n\n\terr = kstrtol(buf, 10, &new_div);\n\tif (err)\n\t\treturn err;\n\n\tif (new_div == old_div)  \n\t\treturn count;\n\n\tmutex_lock(&data->update_lock);\n\tswitch (new_div) {\n\tcase 1:\n\t\tdata->fan_div[nr] = 0;\n\t\tbreak;\n\tcase 2:\n\t\tdata->fan_div[nr] = 1;\n\t\tbreak;\n\tcase 4:\n\t\tdata->fan_div[nr] = 2;\n\t\tbreak;\n\tcase 8:\n\t\tdata->fan_div[nr] = 3;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&data->update_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (nr) {\n\tcase 0:\n\tcase 1:\n\t\ttmp = smsc47m1_read_value(data, SMSC47M1_REG_FANDIV)\n\t\t      & ~(0x03 << (4 + 2 * nr));\n\t\ttmp |= data->fan_div[nr] << (4 + 2 * nr);\n\t\tsmsc47m1_write_value(data, SMSC47M1_REG_FANDIV, tmp);\n\t\tbreak;\n\tcase 2:\n\t\ttmp = smsc47m1_read_value(data, SMSC47M2_REG_FANDIV3) & 0xCF;\n\t\ttmp |= data->fan_div[2] << 4;\n\t\tsmsc47m1_write_value(data, SMSC47M2_REG_FANDIV3, tmp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t \n\ttmp = 192 - (old_div * (192 - data->fan_preload[nr])\n\t\t     + new_div / 2) / new_div;\n\tdata->fan_preload[nr] = clamp_val(tmp, 0, 191);\n\tsmsc47m1_write_value(data, SMSC47M1_REG_FAN_PRELOAD[nr],\n\t\t\t     data->fan_preload[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t pwm_store(struct device *dev, struct device_attribute *devattr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct smsc47m1_data *data = dev_get_drvdata(dev);\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val < 0 || val > 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm[nr] &= 0x81;  \n\tdata->pwm[nr] |= PWM_TO_REG(val);\n\tsmsc47m1_write_value(data, SMSC47M1_REG_PWM[nr],\n\t\t\t     data->pwm[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t pwm_en_store(struct device *dev,\n\t\t\t    struct device_attribute *devattr, const char *buf,\n\t\t\t    size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct smsc47m1_data *data = dev_get_drvdata(dev);\n\tint nr = attr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm[nr] &= 0xFE;  \n\tdata->pwm[nr] |= !val;\n\tsmsc47m1_write_value(data, SMSC47M1_REG_PWM[nr],\n\t\t\t     data->pwm[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_min, fan_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_div, fan_div, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan1_alarm, fan_alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1, pwm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm1_enable, pwm_en, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_min, fan_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_div, fan_div, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_alarm, fan_alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2, pwm, 1);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2_enable, pwm_en, 1);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_input, fan, 2);\nstatic SENSOR_DEVICE_ATTR_RW(fan3_min, fan_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(fan3_div, fan_div, 2);\nstatic SENSOR_DEVICE_ATTR_RO(fan3_alarm, fan_alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3, pwm, 2);\nstatic SENSOR_DEVICE_ATTR_RW(pwm3_enable, pwm_en, 2);\n\nstatic DEVICE_ATTR_RO(alarms);\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute\n\t\t\t *devattr, char *buf)\n{\n\tstruct smsc47m1_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", data->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic struct attribute *smsc47m1_attributes_fan1[] = {\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_div.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group smsc47m1_group_fan1 = {\n\t.attrs = smsc47m1_attributes_fan1,\n};\n\nstatic struct attribute *smsc47m1_attributes_fan2[] = {\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_div.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group smsc47m1_group_fan2 = {\n\t.attrs = smsc47m1_attributes_fan2,\n};\n\nstatic struct attribute *smsc47m1_attributes_fan3[] = {\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_div.dev_attr.attr,\n\t&sensor_dev_attr_fan3_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group smsc47m1_group_fan3 = {\n\t.attrs = smsc47m1_attributes_fan3,\n};\n\nstatic struct attribute *smsc47m1_attributes_pwm1[] = {\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group smsc47m1_group_pwm1 = {\n\t.attrs = smsc47m1_attributes_pwm1,\n};\n\nstatic struct attribute *smsc47m1_attributes_pwm2[] = {\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group smsc47m1_group_pwm2 = {\n\t.attrs = smsc47m1_attributes_pwm2,\n};\n\nstatic struct attribute *smsc47m1_attributes_pwm3[] = {\n\t&sensor_dev_attr_pwm3.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group smsc47m1_group_pwm3 = {\n\t.attrs = smsc47m1_attributes_pwm3,\n};\n\nstatic struct attribute *smsc47m1_attributes[] = {\n\t&dev_attr_alarms.attr,\n\t&dev_attr_name.attr,\n\tNULL\n};\n\nstatic const struct attribute_group smsc47m1_group = {\n\t.attrs = smsc47m1_attributes,\n};\n\nstatic int __init smsc47m1_find(struct smsc47m1_sio_data *sio_data)\n{\n\tu8 val;\n\tunsigned short addr;\n\tint err;\n\n\terr = superio_enter();\n\tif (err)\n\t\treturn err;\n\n\tval = force_id ? force_id : superio_inb(SUPERIO_REG_DEVID);\n\n\t \n\tswitch (val) {\n\tcase 0x51:\n\t\tpr_info(\"Found SMSC LPC47B27x\\n\");\n\t\tsio_data->type = smsc47m1;\n\t\tbreak;\n\tcase 0x59:\n\t\tpr_info(\"Found SMSC LPC47M10x/LPC47M112/LPC47M13x\\n\");\n\t\tsio_data->type = smsc47m1;\n\t\tbreak;\n\tcase 0x5F:\n\t\tpr_info(\"Found SMSC LPC47M14x\\n\");\n\t\tsio_data->type = smsc47m1;\n\t\tbreak;\n\tcase 0x60:\n\t\tpr_info(\"Found SMSC LPC47M15x/LPC47M192/LPC47M997\\n\");\n\t\tsio_data->type = smsc47m1;\n\t\tbreak;\n\tcase 0x6B:\n\t\tif (superio_inb(SUPERIO_REG_DEVREV) & 0x80) {\n\t\t\tpr_debug(\"Found SMSC LPC47M233, unsupported\\n\");\n\t\t\tsuperio_exit();\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tpr_info(\"Found SMSC LPC47M292\\n\");\n\t\tsio_data->type = smsc47m2;\n\t\tbreak;\n\tdefault:\n\t\tsuperio_exit();\n\t\treturn -ENODEV;\n\t}\n\n\tsuperio_select();\n\taddr = (superio_inb(SUPERIO_REG_BASE) << 8)\n\t      |  superio_inb(SUPERIO_REG_BASE + 1);\n\tif (addr == 0) {\n\t\tpr_info(\"Device address not set, will not use\\n\");\n\t\tsuperio_exit();\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsio_data->activate = superio_inb(SUPERIO_REG_ACT);\n\tif ((sio_data->activate & 0x01) == 0) {\n\t\tpr_info(\"Enabling device\\n\");\n\t\tsuperio_outb(SUPERIO_REG_ACT, sio_data->activate | 0x01);\n\t}\n\n\tsuperio_exit();\n\treturn addr;\n}\n\n \nstatic void smsc47m1_restore(const struct smsc47m1_sio_data *sio_data)\n{\n\tif ((sio_data->activate & 0x01) == 0) {\n\t\tif (!superio_enter()) {\n\t\t\tsuperio_select();\n\t\t\tpr_info(\"Disabling device\\n\");\n\t\t\tsuperio_outb(SUPERIO_REG_ACT, sio_data->activate);\n\t\t\tsuperio_exit();\n\t\t} else {\n\t\t\tpr_warn(\"Failed to disable device\\n\");\n\t\t}\n\t}\n}\n\n#define CHECK\t\t1\n#define REQUEST\t\t2\n\n \nstatic int __init smsc47m1_handle_resources(unsigned short address,\n\t\t\t\t\t    enum chips type, int action,\n\t\t\t\t\t    struct device *dev)\n{\n\tstatic const u8 ports_m1[] = {\n\t\t \n\t\t0x04, 1,\n\t\t0x33, 4,\n\t\t0x56, 7,\n\t};\n\n\tstatic const u8 ports_m2[] = {\n\t\t \n\t\t0x04, 1,\n\t\t0x09, 1,\n\t\t0x2c, 2,\n\t\t0x35, 4,\n\t\t0x56, 7,\n\t\t0x69, 4,\n\t};\n\n\tint i, ports_size, err;\n\tconst u8 *ports;\n\n\tswitch (type) {\n\tcase smsc47m1:\n\tdefault:\n\t\tports = ports_m1;\n\t\tports_size = ARRAY_SIZE(ports_m1);\n\t\tbreak;\n\tcase smsc47m2:\n\t\tports = ports_m2;\n\t\tports_size = ARRAY_SIZE(ports_m2);\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i + 1 < ports_size; i += 2) {\n\t\tunsigned short start = address + ports[i];\n\t\tunsigned short len = ports[i + 1];\n\n\t\tswitch (action) {\n\t\tcase CHECK:\n\t\t\t \n\t\t\terr = acpi_check_region(start, len, DRVNAME);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase REQUEST:\n\t\t\t \n\t\t\tif (!devm_request_region(dev, start, len, DRVNAME)) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Region 0x%x-0x%x already in use!\\n\",\n\t\t\t\t\tstart, start + len);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void smsc47m1_remove_files(struct device *dev)\n{\n\tsysfs_remove_group(&dev->kobj, &smsc47m1_group);\n\tsysfs_remove_group(&dev->kobj, &smsc47m1_group_fan1);\n\tsysfs_remove_group(&dev->kobj, &smsc47m1_group_fan2);\n\tsysfs_remove_group(&dev->kobj, &smsc47m1_group_fan3);\n\tsysfs_remove_group(&dev->kobj, &smsc47m1_group_pwm1);\n\tsysfs_remove_group(&dev->kobj, &smsc47m1_group_pwm2);\n\tsysfs_remove_group(&dev->kobj, &smsc47m1_group_pwm3);\n}\n\nstatic int __init smsc47m1_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct smsc47m1_sio_data *sio_data = dev_get_platdata(dev);\n\tstruct smsc47m1_data *data;\n\tstruct resource *res;\n\tint err;\n\tint fan1, fan2, fan3, pwm1, pwm2, pwm3;\n\n\tstatic const char * const names[] = {\n\t\t\"smsc47m1\",\n\t\t\"smsc47m2\",\n\t};\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\terr = smsc47m1_handle_resources(res->start, sio_data->type,\n\t\t\t\t\tREQUEST, dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata = devm_kzalloc(dev, sizeof(struct smsc47m1_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->addr = res->start;\n\tdata->type = sio_data->type;\n\tdata->name = names[sio_data->type];\n\tmutex_init(&data->update_lock);\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tpwm1 = (smsc47m1_read_value(data, SMSC47M1_REG_PPIN(0)) & 0x05)\n\t       == 0x04;\n\tpwm2 = (smsc47m1_read_value(data, SMSC47M1_REG_PPIN(1)) & 0x05)\n\t       == 0x04;\n\tif (data->type == smsc47m2) {\n\t\tfan1 = (smsc47m1_read_value(data, SMSC47M2_REG_TPIN1)\n\t\t\t& 0x0d) == 0x09;\n\t\tfan2 = (smsc47m1_read_value(data, SMSC47M2_REG_TPIN2)\n\t\t\t& 0x0d) == 0x09;\n\t\tfan3 = (smsc47m1_read_value(data, SMSC47M2_REG_TPIN3)\n\t\t\t& 0x0d) == 0x0d;\n\t\tpwm3 = (smsc47m1_read_value(data, SMSC47M2_REG_PPIN3)\n\t\t\t& 0x0d) == 0x08;\n\t} else {\n\t\tfan1 = (smsc47m1_read_value(data, SMSC47M1_REG_TPIN(0))\n\t\t\t& 0x05) == 0x05;\n\t\tfan2 = (smsc47m1_read_value(data, SMSC47M1_REG_TPIN(1))\n\t\t\t& 0x05) == 0x05;\n\t\tfan3 = 0;\n\t\tpwm3 = 0;\n\t}\n\tif (!(fan1 || fan2 || fan3 || pwm1 || pwm2 || pwm3)) {\n\t\tdev_warn(dev, \"Device not configured, will not use\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsmsc47m1_update_device(dev, 1);\n\n\t \n\tif (fan1) {\n\t\terr = sysfs_create_group(&dev->kobj,\n\t\t\t\t\t &smsc47m1_group_fan1);\n\t\tif (err)\n\t\t\tgoto error_remove_files;\n\t} else\n\t\tdev_dbg(dev, \"Fan 1 not enabled by hardware, skipping\\n\");\n\n\tif (fan2) {\n\t\terr = sysfs_create_group(&dev->kobj,\n\t\t\t\t\t &smsc47m1_group_fan2);\n\t\tif (err)\n\t\t\tgoto error_remove_files;\n\t} else\n\t\tdev_dbg(dev, \"Fan 2 not enabled by hardware, skipping\\n\");\n\n\tif (fan3) {\n\t\terr = sysfs_create_group(&dev->kobj,\n\t\t\t\t\t &smsc47m1_group_fan3);\n\t\tif (err)\n\t\t\tgoto error_remove_files;\n\t} else if (data->type == smsc47m2)\n\t\tdev_dbg(dev, \"Fan 3 not enabled by hardware, skipping\\n\");\n\n\tif (pwm1) {\n\t\terr = sysfs_create_group(&dev->kobj,\n\t\t\t\t\t &smsc47m1_group_pwm1);\n\t\tif (err)\n\t\t\tgoto error_remove_files;\n\t} else\n\t\tdev_dbg(dev, \"PWM 1 not enabled by hardware, skipping\\n\");\n\n\tif (pwm2) {\n\t\terr = sysfs_create_group(&dev->kobj,\n\t\t\t\t\t &smsc47m1_group_pwm2);\n\t\tif (err)\n\t\t\tgoto error_remove_files;\n\t} else\n\t\tdev_dbg(dev, \"PWM 2 not enabled by hardware, skipping\\n\");\n\n\tif (pwm3) {\n\t\terr = sysfs_create_group(&dev->kobj,\n\t\t\t\t\t &smsc47m1_group_pwm3);\n\t\tif (err)\n\t\t\tgoto error_remove_files;\n\t} else if (data->type == smsc47m2)\n\t\tdev_dbg(dev, \"PWM 3 not enabled by hardware, skipping\\n\");\n\n\terr = sysfs_create_group(&dev->kobj, &smsc47m1_group);\n\tif (err)\n\t\tgoto error_remove_files;\n\n\tdata->hwmon_dev = hwmon_device_register(dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto error_remove_files;\n\t}\n\n\treturn 0;\n\nerror_remove_files:\n\tsmsc47m1_remove_files(dev);\n\treturn err;\n}\n\nstatic int __exit smsc47m1_remove(struct platform_device *pdev)\n{\n\tstruct smsc47m1_data *data = platform_get_drvdata(pdev);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tsmsc47m1_remove_files(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver smsc47m1_driver = {\n\t.driver = {\n\t\t.name\t= DRVNAME,\n\t},\n\t.remove\t\t= __exit_p(smsc47m1_remove),\n};\n\nstatic int __init smsc47m1_device_add(unsigned short address,\n\t\t\t\t      const struct smsc47m1_sio_data *sio_data)\n{\n\tstruct resource res = {\n\t\t.start\t= address,\n\t\t.end\t= address + SMSC_EXTENT - 1,\n\t\t.name\t= DRVNAME,\n\t\t.flags\t= IORESOURCE_IO,\n\t};\n\tint err;\n\n\terr = smsc47m1_handle_resources(address, sio_data->type, CHECK, NULL);\n\tif (err)\n\t\tgoto exit;\n\n\tpdev = platform_device_alloc(DRVNAME, address);\n\tif (!pdev) {\n\t\terr = -ENOMEM;\n\t\tpr_err(\"Device allocation failed\\n\");\n\t\tgoto exit;\n\t}\n\n\terr = platform_device_add_resources(pdev, &res, 1);\n\tif (err) {\n\t\tpr_err(\"Device resource addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add_data(pdev, sio_data,\n\t\t\t\t       sizeof(struct smsc47m1_sio_data));\n\tif (err) {\n\t\tpr_err(\"Platform data allocation failed\\n\");\n\t\tgoto exit_device_put;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err) {\n\t\tpr_err(\"Device addition failed (%d)\\n\", err);\n\t\tgoto exit_device_put;\n\t}\n\n\treturn 0;\n\nexit_device_put:\n\tplatform_device_put(pdev);\nexit:\n\treturn err;\n}\n\nstatic int __init sm_smsc47m1_init(void)\n{\n\tint err;\n\tunsigned short address;\n\tstruct smsc47m1_sio_data sio_data;\n\n\terr = smsc47m1_find(&sio_data);\n\tif (err < 0)\n\t\treturn err;\n\taddress = err;\n\n\t \n\terr = smsc47m1_device_add(address, &sio_data);\n\tif (err)\n\t\treturn err;\n\n\terr = platform_driver_probe(&smsc47m1_driver, smsc47m1_probe);\n\tif (err)\n\t\tgoto exit_device;\n\n\treturn 0;\n\nexit_device:\n\tplatform_device_unregister(pdev);\n\tsmsc47m1_restore(&sio_data);\n\treturn err;\n}\n\nstatic void __exit sm_smsc47m1_exit(void)\n{\n\tplatform_driver_unregister(&smsc47m1_driver);\n\tsmsc47m1_restore(dev_get_platdata(&pdev->dev));\n\tplatform_device_unregister(pdev);\n}\n\nMODULE_AUTHOR(\"Mark D. Studebaker <mdsxyz123@yahoo.com>\");\nMODULE_DESCRIPTION(\"SMSC LPC47M1xx fan sensors driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(sm_smsc47m1_init);\nmodule_exit(sm_smsc47m1_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}