{
  "module_name": "ltc4215.c",
  "hash_id": "b99ae621a9e621be0515deb1cb4bc2ae047d94eda1a394d6072636455d184388",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ltc4215.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n\n \nenum ltc4215_cmd {\n\tLTC4215_CONTROL\t\t\t= 0x00,  \n\tLTC4215_ALERT\t\t\t= 0x01,  \n\tLTC4215_STATUS\t\t\t= 0x02,  \n\tLTC4215_FAULT\t\t\t= 0x03,  \n\tLTC4215_SENSE\t\t\t= 0x04,  \n\tLTC4215_SOURCE\t\t\t= 0x05,  \n\tLTC4215_ADIN\t\t\t= 0x06,  \n};\n\nstruct ltc4215_data {\n\tstruct i2c_client *client;\n\n\tstruct mutex update_lock;\n\tbool valid;\n\tunsigned long last_updated;  \n\n\t \n\tu8 regs[7];\n};\n\nstatic struct ltc4215_data *ltc4215_update_device(struct device *dev)\n{\n\tstruct ltc4215_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\ts32 val;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\t \n\tif (time_after(jiffies, data->last_updated + HZ / 10) || !data->valid) {\n\n\t\tdev_dbg(&client->dev, \"Starting ltc4215 update\\n\");\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(data->regs); i++) {\n\t\t\tval = i2c_smbus_read_byte_data(client, i);\n\t\t\tif (unlikely(val < 0))\n\t\t\t\tdata->regs[i] = 0;\n\t\t\telse\n\t\t\t\tdata->regs[i] = val;\n\t\t}\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \nstatic int ltc4215_get_voltage(struct device *dev, u8 reg)\n{\n\tstruct ltc4215_data *data = ltc4215_update_device(dev);\n\tconst u8 regval = data->regs[reg];\n\tu32 voltage = 0;\n\n\tswitch (reg) {\n\tcase LTC4215_SENSE:\n\t\t \n\t\tvoltage = regval * 151 / 1000;\n\t\tbreak;\n\tcase LTC4215_SOURCE:\n\t\t \n\t\tvoltage = regval * 605 / 10;\n\t\tbreak;\n\tcase LTC4215_ADIN:\n\t\t \n\t\tvoltage = regval * 482 * 125 / 1000;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn voltage;\n}\n\n \nstatic unsigned int ltc4215_get_current(struct device *dev)\n{\n\tstruct ltc4215_data *data = ltc4215_update_device(dev);\n\n\t \n\n\t \n\tconst unsigned int voltage = data->regs[LTC4215_SENSE] * 151;\n\n\t \n\tconst unsigned int curr = voltage / 4;\n\n\treturn curr;\n}\n\nstatic ssize_t ltc4215_voltage_show(struct device *dev,\n\t\t\t\t    struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tconst int voltage = ltc4215_get_voltage(dev, attr->index);\n\n\treturn sysfs_emit(buf, \"%d\\n\", voltage);\n}\n\nstatic ssize_t ltc4215_current_show(struct device *dev,\n\t\t\t\t    struct device_attribute *da, char *buf)\n{\n\tconst unsigned int curr = ltc4215_get_current(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", curr);\n}\n\nstatic ssize_t ltc4215_power_show(struct device *dev,\n\t\t\t\t  struct device_attribute *da, char *buf)\n{\n\tconst unsigned int curr = ltc4215_get_current(dev);\n\tconst int output_voltage = ltc4215_get_voltage(dev, LTC4215_ADIN);\n\n\t \n\tconst unsigned int power = abs(output_voltage * curr);\n\n\treturn sysfs_emit(buf, \"%u\\n\", power);\n}\n\nstatic ssize_t ltc4215_alarm_show(struct device *dev,\n\t\t\t\t  struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ltc4215_data *data = ltc4215_update_device(dev);\n\tconst u8 reg = data->regs[LTC4215_STATUS];\n\tconst u32 mask = attr->index;\n\n\treturn sysfs_emit(buf, \"%u\\n\", !!(reg & mask));\n}\n\n \n\n \n\n \nstatic SENSOR_DEVICE_ATTR_RO(curr1_input, ltc4215_current, 0);\nstatic SENSOR_DEVICE_ATTR_RO(curr1_max_alarm, ltc4215_alarm, 1 << 2);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(power1_input, ltc4215_power, 0);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(in1_input, ltc4215_voltage, LTC4215_ADIN);\nstatic SENSOR_DEVICE_ATTR_RO(in1_max_alarm, ltc4215_alarm, 1 << 0);\nstatic SENSOR_DEVICE_ATTR_RO(in1_min_alarm, ltc4215_alarm, 1 << 1);\n\n \nstatic SENSOR_DEVICE_ATTR_RO(in2_input, ltc4215_voltage, LTC4215_SOURCE);\nstatic SENSOR_DEVICE_ATTR_RO(in2_min_alarm, ltc4215_alarm, 1 << 3);\n\n \nstatic struct attribute *ltc4215_attrs[] = {\n\t&sensor_dev_attr_curr1_input.dev_attr.attr,\n\t&sensor_dev_attr_curr1_max_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_power1_input.dev_attr.attr,\n\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_in1_min_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_min_alarm.dev_attr.attr,\n\n\tNULL,\n};\nATTRIBUTE_GROUPS(ltc4215);\n\nstatic int ltc4215_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &client->dev;\n\tstruct ltc4215_data *data;\n\tstruct device *hwmon_dev;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\ti2c_smbus_write_byte_data(client, LTC4215_FAULT, 0x00);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   ltc4215_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id ltc4215_id[] = {\n\t{ \"ltc4215\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ltc4215_id);\n\n \nstatic struct i2c_driver ltc4215_driver = {\n\t.driver = {\n\t\t.name\t= \"ltc4215\",\n\t},\n\t.probe\t\t= ltc4215_probe,\n\t.id_table\t= ltc4215_id,\n};\n\nmodule_i2c_driver(ltc4215_driver);\n\nMODULE_AUTHOR(\"Ira W. Snyder <iws@ovro.caltech.edu>\");\nMODULE_DESCRIPTION(\"LTC4215 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}