{
  "module_name": "applesmc.c",
  "hash_id": "ee86a203ad9c32151d3c07e6567a96d5ffc8ab0d526223534ada0cabc3b8c3ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/applesmc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/dmi.h>\n#include <linux/mutex.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/io.h>\n#include <linux/leds.h>\n#include <linux/hwmon.h>\n#include <linux/workqueue.h>\n#include <linux/err.h>\n#include <linux/bits.h>\n\n \n#define APPLESMC_DATA_PORT\t0x300\n \n#define APPLESMC_CMD_PORT\t0x304\n\n#define APPLESMC_NR_PORTS\t32  \n\n#define APPLESMC_MAX_DATA_LENGTH 32\n\n \n#define SMC_STATUS_AWAITING_DATA  BIT(0)  \n#define SMC_STATUS_IB_CLOSED      BIT(1)  \n#define SMC_STATUS_BUSY           BIT(2)  \n\n \n#define APPLESMC_MIN_WAIT      0x0008\n\n#define APPLESMC_READ_CMD\t0x10\n#define APPLESMC_WRITE_CMD\t0x11\n#define APPLESMC_GET_KEY_BY_INDEX_CMD\t0x12\n#define APPLESMC_GET_KEY_TYPE_CMD\t0x13\n\n#define KEY_COUNT_KEY\t\t\"#KEY\"  \n\n#define LIGHT_SENSOR_LEFT_KEY\t\"ALV0\"  \n#define LIGHT_SENSOR_RIGHT_KEY\t\"ALV1\"  \n#define BACKLIGHT_KEY\t\t\"LKSB\"  \n\n#define CLAMSHELL_KEY\t\t\"MSLD\"  \n\n#define MOTION_SENSOR_X_KEY\t\"MO_X\"  \n#define MOTION_SENSOR_Y_KEY\t\"MO_Y\"  \n#define MOTION_SENSOR_Z_KEY\t\"MO_Z\"  \n#define MOTION_SENSOR_KEY\t\"MOCN\"  \n\n#define FANS_COUNT\t\t\"FNum\"  \n#define FANS_MANUAL\t\t\"FS! \"  \n#define FAN_ID_FMT\t\t\"F%dID\"  \n\n#define TEMP_SENSOR_TYPE\t\"sp78\"\n\n \nstatic const char *const fan_speed_fmt[] = {\n\t\"F%dAc\",\t\t \n\t\"F%dMn\",\t\t \n\t\"F%dMx\",\t\t \n\t\"F%dSf\",\t\t \n\t\"F%dTg\",\t\t \n};\n\n#define INIT_TIMEOUT_MSECS\t5000\t \n#define INIT_WAIT_MSECS\t\t50\t \n\n#define APPLESMC_POLL_INTERVAL\t50\t \n#define APPLESMC_INPUT_FUZZ\t4\t \n#define APPLESMC_INPUT_FLAT\t4\n\n#define to_index(attr) (to_sensor_dev_attr(attr)->index & 0xffff)\n#define to_option(attr) (to_sensor_dev_attr(attr)->index >> 16)\n\n \nstruct applesmc_dev_attr {\n\tstruct sensor_device_attribute sda;\t \n\tchar name[32];\t\t\t\t \n};\n\n \nstruct applesmc_node_group {\n\tchar *format;\t\t\t\t \n\tvoid *show;\t\t\t\t \n\tvoid *store;\t\t\t\t \n\tint option;\t\t\t\t \n\tstruct applesmc_dev_attr *nodes;\t \n};\n\n \nstruct applesmc_entry {\n\tchar key[5];\t\t \n\tu8 valid;\t\t \n\tu8 len;\t\t\t \n\tchar type[5];\t\t \n\tu8 flags;\t\t \n};\n\n \nstatic struct applesmc_registers {\n\tstruct mutex mutex;\t\t \n\tunsigned int key_count;\t\t \n\tunsigned int fan_count;\t\t \n\tunsigned int temp_count;\t \n\tunsigned int temp_begin;\t \n\tunsigned int temp_end;\t\t \n\tunsigned int index_count;\t \n\tint num_light_sensors;\t\t \n\tbool has_accelerometer;\t\t \n\tbool has_key_backlight;\t\t \n\tbool init_complete;\t\t \n\tstruct applesmc_entry *cache;\t \n\tconst char **index;\t\t \n} smcreg = {\n\t.mutex = __MUTEX_INITIALIZER(smcreg.mutex),\n};\n\nstatic const int debug;\nstatic struct platform_device *pdev;\nstatic s16 rest_x;\nstatic s16 rest_y;\nstatic u8 backlight_state[2];\n\nstatic struct device *hwmon_dev;\nstatic struct input_dev *applesmc_idev;\n\n \nstatic unsigned int key_at_index;\n\nstatic struct workqueue_struct *applesmc_led_wq;\n\n \n\nstatic int wait_status(u8 val, u8 mask)\n{\n\tu8 status;\n\tint us;\n\tint i;\n\n\tus = APPLESMC_MIN_WAIT;\n\tfor (i = 0; i < 24 ; i++) {\n\t\tstatus = inb(APPLESMC_CMD_PORT);\n\t\tif ((status & mask) == val)\n\t\t\treturn 0;\n\t\tusleep_range(us, us * 2);\n\t\tif (i > 9)\n\t\t\tus <<= 1;\n\t}\n\treturn -EIO;\n}\n\n \n\nstatic int send_byte(u8 cmd, u16 port)\n{\n\tint status;\n\n\tstatus = wait_status(0, SMC_STATUS_IB_CLOSED);\n\tif (status)\n\t\treturn status;\n\t \n\tstatus = wait_status(SMC_STATUS_BUSY, SMC_STATUS_BUSY);\n\tif (status)\n\t\treturn status;\n\n\toutb(cmd, port);\n\treturn 0;\n}\n\n \n\nstatic int send_command(u8 cmd)\n{\n\tint ret;\n\n\tret = wait_status(0, SMC_STATUS_IB_CLOSED);\n\tif (ret)\n\t\treturn ret;\n\toutb(cmd, APPLESMC_CMD_PORT);\n\treturn 0;\n}\n\n \n\nstatic int smc_sane(void)\n{\n\tint ret;\n\n\tret = wait_status(0, SMC_STATUS_BUSY);\n\tif (!ret)\n\t\treturn ret;\n\tret = send_command(APPLESMC_READ_CMD);\n\tif (ret)\n\t\treturn ret;\n\treturn wait_status(0, SMC_STATUS_BUSY);\n}\n\nstatic int send_argument(const char *key)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (send_byte(key[i], APPLESMC_DATA_PORT))\n\t\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int read_smc(u8 cmd, const char *key, u8 *buffer, u8 len)\n{\n\tu8 status, data = 0;\n\tint i;\n\tint ret;\n\n\tret = smc_sane();\n\tif (ret)\n\t\treturn ret;\n\n\tif (send_command(cmd) || send_argument(key)) {\n\t\tpr_warn(\"%.4s: read arg fail\\n\", key);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (send_byte(len, APPLESMC_DATA_PORT)) {\n\t\tpr_warn(\"%.4s: read len fail\\n\", key);\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (wait_status(SMC_STATUS_AWAITING_DATA | SMC_STATUS_BUSY,\n\t\t\t\tSMC_STATUS_AWAITING_DATA | SMC_STATUS_BUSY)) {\n\t\t\tpr_warn(\"%.4s: read data[%d] fail\\n\", key, i);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbuffer[i] = inb(APPLESMC_DATA_PORT);\n\t}\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tudelay(APPLESMC_MIN_WAIT);\n\t\tstatus = inb(APPLESMC_CMD_PORT);\n\t\tif (!(status & SMC_STATUS_AWAITING_DATA))\n\t\t\tbreak;\n\t\tdata = inb(APPLESMC_DATA_PORT);\n\t}\n\tif (i)\n\t\tpr_warn(\"flushed %d bytes, last value is: %d\\n\", i, data);\n\n\treturn wait_status(0, SMC_STATUS_BUSY);\n}\n\nstatic int write_smc(u8 cmd, const char *key, const u8 *buffer, u8 len)\n{\n\tint i;\n\tint ret;\n\n\tret = smc_sane();\n\tif (ret)\n\t\treturn ret;\n\n\tif (send_command(cmd) || send_argument(key)) {\n\t\tpr_warn(\"%s: write arg fail\\n\", key);\n\t\treturn -EIO;\n\t}\n\n\tif (send_byte(len, APPLESMC_DATA_PORT)) {\n\t\tpr_warn(\"%.4s: write len fail\\n\", key);\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (send_byte(buffer[i], APPLESMC_DATA_PORT)) {\n\t\t\tpr_warn(\"%s: write data fail\\n\", key);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn wait_status(0, SMC_STATUS_BUSY);\n}\n\nstatic int read_register_count(unsigned int *count)\n{\n\t__be32 be;\n\tint ret;\n\n\tret = read_smc(APPLESMC_READ_CMD, KEY_COUNT_KEY, (u8 *)&be, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t*count = be32_to_cpu(be);\n\treturn 0;\n}\n\n \n\nstatic int applesmc_read_entry(const struct applesmc_entry *entry,\n\t\t\t       u8 *buf, u8 len)\n{\n\tint ret;\n\n\tif (entry->len != len)\n\t\treturn -EINVAL;\n\tmutex_lock(&smcreg.mutex);\n\tret = read_smc(APPLESMC_READ_CMD, entry->key, buf, len);\n\tmutex_unlock(&smcreg.mutex);\n\n\treturn ret;\n}\n\nstatic int applesmc_write_entry(const struct applesmc_entry *entry,\n\t\t\t\tconst u8 *buf, u8 len)\n{\n\tint ret;\n\n\tif (entry->len != len)\n\t\treturn -EINVAL;\n\tmutex_lock(&smcreg.mutex);\n\tret = write_smc(APPLESMC_WRITE_CMD, entry->key, buf, len);\n\tmutex_unlock(&smcreg.mutex);\n\treturn ret;\n}\n\nstatic const struct applesmc_entry *applesmc_get_entry_by_index(int index)\n{\n\tstruct applesmc_entry *cache = &smcreg.cache[index];\n\tu8 key[4], info[6];\n\t__be32 be;\n\tint ret = 0;\n\n\tif (cache->valid)\n\t\treturn cache;\n\n\tmutex_lock(&smcreg.mutex);\n\n\tif (cache->valid)\n\t\tgoto out;\n\tbe = cpu_to_be32(index);\n\tret = read_smc(APPLESMC_GET_KEY_BY_INDEX_CMD, (u8 *)&be, key, 4);\n\tif (ret)\n\t\tgoto out;\n\tret = read_smc(APPLESMC_GET_KEY_TYPE_CMD, key, info, 6);\n\tif (ret)\n\t\tgoto out;\n\n\tmemcpy(cache->key, key, 4);\n\tcache->len = info[0];\n\tmemcpy(cache->type, &info[1], 4);\n\tcache->flags = info[5];\n\tcache->valid = true;\n\nout:\n\tmutex_unlock(&smcreg.mutex);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\treturn cache;\n}\n\nstatic int applesmc_get_lower_bound(unsigned int *lo, const char *key)\n{\n\tint begin = 0, end = smcreg.key_count;\n\tconst struct applesmc_entry *entry;\n\n\twhile (begin != end) {\n\t\tint middle = begin + (end - begin) / 2;\n\t\tentry = applesmc_get_entry_by_index(middle);\n\t\tif (IS_ERR(entry)) {\n\t\t\t*lo = 0;\n\t\t\treturn PTR_ERR(entry);\n\t\t}\n\t\tif (strcmp(entry->key, key) < 0)\n\t\t\tbegin = middle + 1;\n\t\telse\n\t\t\tend = middle;\n\t}\n\n\t*lo = begin;\n\treturn 0;\n}\n\nstatic int applesmc_get_upper_bound(unsigned int *hi, const char *key)\n{\n\tint begin = 0, end = smcreg.key_count;\n\tconst struct applesmc_entry *entry;\n\n\twhile (begin != end) {\n\t\tint middle = begin + (end - begin) / 2;\n\t\tentry = applesmc_get_entry_by_index(middle);\n\t\tif (IS_ERR(entry)) {\n\t\t\t*hi = smcreg.key_count;\n\t\t\treturn PTR_ERR(entry);\n\t\t}\n\t\tif (strcmp(key, entry->key) < 0)\n\t\t\tend = middle;\n\t\telse\n\t\t\tbegin = middle + 1;\n\t}\n\n\t*hi = begin;\n\treturn 0;\n}\n\nstatic const struct applesmc_entry *applesmc_get_entry_by_key(const char *key)\n{\n\tint begin, end;\n\tint ret;\n\n\tret = applesmc_get_lower_bound(&begin, key);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tret = applesmc_get_upper_bound(&end, key);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tif (end - begin != 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn applesmc_get_entry_by_index(begin);\n}\n\nstatic int applesmc_read_key(const char *key, u8 *buffer, u8 len)\n{\n\tconst struct applesmc_entry *entry;\n\n\tentry = applesmc_get_entry_by_key(key);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\n\treturn applesmc_read_entry(entry, buffer, len);\n}\n\nstatic int applesmc_write_key(const char *key, const u8 *buffer, u8 len)\n{\n\tconst struct applesmc_entry *entry;\n\n\tentry = applesmc_get_entry_by_key(key);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\n\treturn applesmc_write_entry(entry, buffer, len);\n}\n\nstatic int applesmc_has_key(const char *key, bool *value)\n{\n\tconst struct applesmc_entry *entry;\n\n\tentry = applesmc_get_entry_by_key(key);\n\tif (IS_ERR(entry) && PTR_ERR(entry) != -EINVAL)\n\t\treturn PTR_ERR(entry);\n\n\t*value = !IS_ERR(entry);\n\treturn 0;\n}\n\n \nstatic int applesmc_read_s16(const char *key, s16 *value)\n{\n\tu8 buffer[2];\n\tint ret;\n\n\tret = applesmc_read_key(key, buffer, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t*value = ((s16)buffer[0] << 8) | buffer[1];\n\treturn 0;\n}\n\n \nstatic void applesmc_device_init(void)\n{\n\tint total;\n\tu8 buffer[2];\n\n\tif (!smcreg.has_accelerometer)\n\t\treturn;\n\n\tfor (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {\n\t\tif (!applesmc_read_key(MOTION_SENSOR_KEY, buffer, 2) &&\n\t\t\t\t(buffer[0] != 0x00 || buffer[1] != 0x00))\n\t\t\treturn;\n\t\tbuffer[0] = 0xe0;\n\t\tbuffer[1] = 0x00;\n\t\tapplesmc_write_key(MOTION_SENSOR_KEY, buffer, 2);\n\t\tmsleep(INIT_WAIT_MSECS);\n\t}\n\n\tpr_warn(\"failed to init the device\\n\");\n}\n\nstatic int applesmc_init_index(struct applesmc_registers *s)\n{\n\tconst struct applesmc_entry *entry;\n\tunsigned int i;\n\n\tif (s->index)\n\t\treturn 0;\n\n\ts->index = kcalloc(s->temp_count, sizeof(s->index[0]), GFP_KERNEL);\n\tif (!s->index)\n\t\treturn -ENOMEM;\n\n\tfor (i = s->temp_begin; i < s->temp_end; i++) {\n\t\tentry = applesmc_get_entry_by_index(i);\n\t\tif (IS_ERR(entry))\n\t\t\tcontinue;\n\t\tif (strcmp(entry->type, TEMP_SENSOR_TYPE))\n\t\t\tcontinue;\n\t\ts->index[s->index_count++] = entry->key;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int applesmc_init_smcreg_try(void)\n{\n\tstruct applesmc_registers *s = &smcreg;\n\tbool left_light_sensor = false, right_light_sensor = false;\n\tunsigned int count;\n\tu8 tmp[1];\n\tint ret;\n\n\tif (s->init_complete)\n\t\treturn 0;\n\n\tret = read_register_count(&count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (s->cache && s->key_count != count) {\n\t\tpr_warn(\"key count changed from %d to %d\\n\",\n\t\t\ts->key_count, count);\n\t\tkfree(s->cache);\n\t\ts->cache = NULL;\n\t}\n\ts->key_count = count;\n\n\tif (!s->cache)\n\t\ts->cache = kcalloc(s->key_count, sizeof(*s->cache), GFP_KERNEL);\n\tif (!s->cache)\n\t\treturn -ENOMEM;\n\n\tret = applesmc_read_key(FANS_COUNT, tmp, 1);\n\tif (ret)\n\t\treturn ret;\n\ts->fan_count = tmp[0];\n\tif (s->fan_count > 10)\n\t\ts->fan_count = 10;\n\n\tret = applesmc_get_lower_bound(&s->temp_begin, \"T\");\n\tif (ret)\n\t\treturn ret;\n\tret = applesmc_get_lower_bound(&s->temp_end, \"U\");\n\tif (ret)\n\t\treturn ret;\n\ts->temp_count = s->temp_end - s->temp_begin;\n\n\tret = applesmc_init_index(s);\n\tif (ret)\n\t\treturn ret;\n\n\tret = applesmc_has_key(LIGHT_SENSOR_LEFT_KEY, &left_light_sensor);\n\tif (ret)\n\t\treturn ret;\n\tret = applesmc_has_key(LIGHT_SENSOR_RIGHT_KEY, &right_light_sensor);\n\tif (ret)\n\t\treturn ret;\n\tret = applesmc_has_key(MOTION_SENSOR_KEY, &s->has_accelerometer);\n\tif (ret)\n\t\treturn ret;\n\tret = applesmc_has_key(BACKLIGHT_KEY, &s->has_key_backlight);\n\tif (ret)\n\t\treturn ret;\n\n\ts->num_light_sensors = left_light_sensor + right_light_sensor;\n\ts->init_complete = true;\n\n\tpr_info(\"key=%d fan=%d temp=%d index=%d acc=%d lux=%d kbd=%d\\n\",\n\t       s->key_count, s->fan_count, s->temp_count, s->index_count,\n\t       s->has_accelerometer,\n\t       s->num_light_sensors,\n\t       s->has_key_backlight);\n\n\treturn 0;\n}\n\nstatic void applesmc_destroy_smcreg(void)\n{\n\tkfree(smcreg.index);\n\tsmcreg.index = NULL;\n\tkfree(smcreg.cache);\n\tsmcreg.cache = NULL;\n\tsmcreg.init_complete = false;\n}\n\n \nstatic int applesmc_init_smcreg(void)\n{\n\tint ms, ret;\n\n\tfor (ms = 0; ms < INIT_TIMEOUT_MSECS; ms += INIT_WAIT_MSECS) {\n\t\tret = applesmc_init_smcreg_try();\n\t\tif (!ret) {\n\t\t\tif (ms)\n\t\t\t\tpr_info(\"init_smcreg() took %d ms\\n\", ms);\n\t\t\treturn 0;\n\t\t}\n\t\tmsleep(INIT_WAIT_MSECS);\n\t}\n\n\tapplesmc_destroy_smcreg();\n\n\treturn ret;\n}\n\n \nstatic int applesmc_probe(struct platform_device *dev)\n{\n\tint ret;\n\n\tret = applesmc_init_smcreg();\n\tif (ret)\n\t\treturn ret;\n\n\tapplesmc_device_init();\n\n\treturn 0;\n}\n\n \nstatic int applesmc_pm_resume(struct device *dev)\n{\n\tif (smcreg.has_key_backlight)\n\t\tapplesmc_write_key(BACKLIGHT_KEY, backlight_state, 2);\n\treturn 0;\n}\n\n \nstatic int applesmc_pm_restore(struct device *dev)\n{\n\tapplesmc_device_init();\n\treturn applesmc_pm_resume(dev);\n}\n\nstatic const struct dev_pm_ops applesmc_pm_ops = {\n\t.resume = applesmc_pm_resume,\n\t.restore = applesmc_pm_restore,\n};\n\nstatic struct platform_driver applesmc_driver = {\n\t.probe = applesmc_probe,\n\t.driver\t= {\n\t\t.name = \"applesmc\",\n\t\t.pm = &applesmc_pm_ops,\n\t},\n};\n\n \nstatic void applesmc_calibrate(void)\n{\n\tapplesmc_read_s16(MOTION_SENSOR_X_KEY, &rest_x);\n\tapplesmc_read_s16(MOTION_SENSOR_Y_KEY, &rest_y);\n\trest_x = -rest_x;\n}\n\nstatic void applesmc_idev_poll(struct input_dev *idev)\n{\n\ts16 x, y;\n\n\tif (applesmc_read_s16(MOTION_SENSOR_X_KEY, &x))\n\t\treturn;\n\tif (applesmc_read_s16(MOTION_SENSOR_Y_KEY, &y))\n\t\treturn;\n\n\tx = -x;\n\tinput_report_abs(idev, ABS_X, x - rest_x);\n\tinput_report_abs(idev, ABS_Y, y - rest_y);\n\tinput_sync(idev);\n}\n\n \n\nstatic ssize_t applesmc_name_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"applesmc\\n\");\n}\n\nstatic ssize_t applesmc_position_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\ts16 x, y, z;\n\n\tret = applesmc_read_s16(MOTION_SENSOR_X_KEY, &x);\n\tif (ret)\n\t\tgoto out;\n\tret = applesmc_read_s16(MOTION_SENSOR_Y_KEY, &y);\n\tif (ret)\n\t\tgoto out;\n\tret = applesmc_read_s16(MOTION_SENSOR_Z_KEY, &z);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"(%d,%d,%d)\\n\", x, y, z);\n}\n\nstatic ssize_t applesmc_light_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *sysfsbuf)\n{\n\tconst struct applesmc_entry *entry;\n\tstatic int data_length;\n\tint ret;\n\tu8 left = 0, right = 0;\n\tu8 buffer[10];\n\n\tif (!data_length) {\n\t\tentry = applesmc_get_entry_by_key(LIGHT_SENSOR_LEFT_KEY);\n\t\tif (IS_ERR(entry))\n\t\t\treturn PTR_ERR(entry);\n\t\tif (entry->len > 10)\n\t\t\treturn -ENXIO;\n\t\tdata_length = entry->len;\n\t\tpr_info(\"light sensor data length set to %d\\n\", data_length);\n\t}\n\n\tret = applesmc_read_key(LIGHT_SENSOR_LEFT_KEY, buffer, data_length);\n\tif (ret)\n\t\tgoto out;\n\t \n\tif (data_length == 10) {\n\t\tleft = be16_to_cpu(*(__be16 *)(buffer + 6)) >> 2;\n\t\tgoto out;\n\t}\n\tleft = buffer[2];\n\n\tret = applesmc_read_key(LIGHT_SENSOR_RIGHT_KEY, buffer, data_length);\n\tif (ret)\n\t\tgoto out;\n\tright = buffer[2];\n\nout:\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(sysfsbuf, \"(%d,%d)\\n\", left, right);\n}\n\n \nstatic ssize_t applesmc_show_sensor_label(struct device *dev,\n\t\t\tstruct device_attribute *devattr, char *sysfsbuf)\n{\n\tconst char *key = smcreg.index[to_index(devattr)];\n\n\treturn sysfs_emit(sysfsbuf, \"%s\\n\", key);\n}\n\n \nstatic ssize_t applesmc_show_temperature(struct device *dev,\n\t\t\tstruct device_attribute *devattr, char *sysfsbuf)\n{\n\tconst char *key = smcreg.index[to_index(devattr)];\n\tint ret;\n\ts16 value;\n\tint temp;\n\n\tret = applesmc_read_s16(key, &value);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp = 250 * (value >> 6);\n\n\treturn sysfs_emit(sysfsbuf, \"%d\\n\", temp);\n}\n\nstatic ssize_t applesmc_show_fan_speed(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *sysfsbuf)\n{\n\tint ret;\n\tunsigned int speed = 0;\n\tchar newkey[5];\n\tu8 buffer[2];\n\n\tscnprintf(newkey, sizeof(newkey), fan_speed_fmt[to_option(attr)],\n\t\t  to_index(attr));\n\n\tret = applesmc_read_key(newkey, buffer, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tspeed = ((buffer[0] << 8 | buffer[1]) >> 2);\n\treturn sysfs_emit(sysfsbuf, \"%u\\n\", speed);\n}\n\nstatic ssize_t applesmc_store_fan_speed(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *sysfsbuf, size_t count)\n{\n\tint ret;\n\tunsigned long speed;\n\tchar newkey[5];\n\tu8 buffer[2];\n\n\tif (kstrtoul(sysfsbuf, 10, &speed) < 0 || speed >= 0x4000)\n\t\treturn -EINVAL;\t\t \n\n\tscnprintf(newkey, sizeof(newkey), fan_speed_fmt[to_option(attr)],\n\t\t  to_index(attr));\n\n\tbuffer[0] = (speed >> 6) & 0xff;\n\tbuffer[1] = (speed << 2) & 0xff;\n\tret = applesmc_write_key(newkey, buffer, 2);\n\n\tif (ret)\n\t\treturn ret;\n\telse\n\t\treturn count;\n}\n\nstatic ssize_t applesmc_show_fan_manual(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *sysfsbuf)\n{\n\tint ret;\n\tu16 manual = 0;\n\tu8 buffer[2];\n\n\tret = applesmc_read_key(FANS_MANUAL, buffer, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tmanual = ((buffer[0] << 8 | buffer[1]) >> to_index(attr)) & 0x01;\n\treturn sysfs_emit(sysfsbuf, \"%d\\n\", manual);\n}\n\nstatic ssize_t applesmc_store_fan_manual(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *sysfsbuf, size_t count)\n{\n\tint ret;\n\tu8 buffer[2];\n\tunsigned long input;\n\tu16 val;\n\n\tif (kstrtoul(sysfsbuf, 10, &input) < 0)\n\t\treturn -EINVAL;\n\n\tret = applesmc_read_key(FANS_MANUAL, buffer, 2);\n\tif (ret)\n\t\tgoto out;\n\n\tval = (buffer[0] << 8 | buffer[1]);\n\n\tif (input)\n\t\tval = val | (0x01 << to_index(attr));\n\telse\n\t\tval = val & ~(0x01 << to_index(attr));\n\n\tbuffer[0] = (val >> 8) & 0xFF;\n\tbuffer[1] = val & 0xFF;\n\n\tret = applesmc_write_key(FANS_MANUAL, buffer, 2);\n\nout:\n\tif (ret)\n\t\treturn ret;\n\telse\n\t\treturn count;\n}\n\nstatic ssize_t applesmc_show_fan_position(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *sysfsbuf)\n{\n\tint ret;\n\tchar newkey[5];\n\tu8 buffer[17];\n\n\tscnprintf(newkey, sizeof(newkey), FAN_ID_FMT, to_index(attr));\n\n\tret = applesmc_read_key(newkey, buffer, 16);\n\tbuffer[16] = 0;\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(sysfsbuf, \"%s\\n\", buffer + 4);\n}\n\nstatic ssize_t applesmc_calibrate_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *sysfsbuf)\n{\n\treturn sysfs_emit(sysfsbuf, \"(%d,%d)\\n\", rest_x, rest_y);\n}\n\nstatic ssize_t applesmc_calibrate_store(struct device *dev,\n\tstruct device_attribute *attr, const char *sysfsbuf, size_t count)\n{\n\tapplesmc_calibrate();\n\n\treturn count;\n}\n\nstatic void applesmc_backlight_set(struct work_struct *work)\n{\n\tapplesmc_write_key(BACKLIGHT_KEY, backlight_state, 2);\n}\nstatic DECLARE_WORK(backlight_work, &applesmc_backlight_set);\n\nstatic void applesmc_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\t\tenum led_brightness value)\n{\n\tint ret;\n\n\tbacklight_state[0] = value;\n\tret = queue_work(applesmc_led_wq, &backlight_work);\n\n\tif (debug && (!ret))\n\t\tdev_dbg(led_cdev->dev, \"work was already on the queue.\\n\");\n}\n\nstatic ssize_t applesmc_key_count_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *sysfsbuf)\n{\n\tint ret;\n\tu8 buffer[4];\n\tu32 count;\n\n\tret = applesmc_read_key(KEY_COUNT_KEY, buffer, 4);\n\tif (ret)\n\t\treturn ret;\n\n\tcount = ((u32)buffer[0]<<24) + ((u32)buffer[1]<<16) +\n\t\t\t\t\t\t((u32)buffer[2]<<8) + buffer[3];\n\treturn sysfs_emit(sysfsbuf, \"%d\\n\", count);\n}\n\nstatic ssize_t applesmc_key_at_index_read_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *sysfsbuf)\n{\n\tconst struct applesmc_entry *entry;\n\tint ret;\n\n\tentry = applesmc_get_entry_by_index(key_at_index);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\tret = applesmc_read_entry(entry, sysfsbuf, entry->len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn entry->len;\n}\n\nstatic ssize_t applesmc_key_at_index_data_length_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *sysfsbuf)\n{\n\tconst struct applesmc_entry *entry;\n\n\tentry = applesmc_get_entry_by_index(key_at_index);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\n\treturn sysfs_emit(sysfsbuf, \"%d\\n\", entry->len);\n}\n\nstatic ssize_t applesmc_key_at_index_type_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *sysfsbuf)\n{\n\tconst struct applesmc_entry *entry;\n\n\tentry = applesmc_get_entry_by_index(key_at_index);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\n\treturn sysfs_emit(sysfsbuf, \"%s\\n\", entry->type);\n}\n\nstatic ssize_t applesmc_key_at_index_name_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *sysfsbuf)\n{\n\tconst struct applesmc_entry *entry;\n\n\tentry = applesmc_get_entry_by_index(key_at_index);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\n\treturn sysfs_emit(sysfsbuf, \"%s\\n\", entry->key);\n}\n\nstatic ssize_t applesmc_key_at_index_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *sysfsbuf)\n{\n\treturn sysfs_emit(sysfsbuf, \"%d\\n\", key_at_index);\n}\n\nstatic ssize_t applesmc_key_at_index_store(struct device *dev,\n\tstruct device_attribute *attr, const char *sysfsbuf, size_t count)\n{\n\tunsigned long newkey;\n\n\tif (kstrtoul(sysfsbuf, 10, &newkey) < 0\n\t    || newkey >= smcreg.key_count)\n\t\treturn -EINVAL;\n\n\tkey_at_index = newkey;\n\treturn count;\n}\n\nstatic struct led_classdev applesmc_backlight = {\n\t.name\t\t\t= \"smc::kbd_backlight\",\n\t.default_trigger\t= \"nand-disk\",\n\t.brightness_set\t\t= applesmc_brightness_set,\n};\n\nstatic struct applesmc_node_group info_group[] = {\n\t{ \"name\", applesmc_name_show },\n\t{ \"key_count\", applesmc_key_count_show },\n\t{ \"key_at_index\", applesmc_key_at_index_show, applesmc_key_at_index_store },\n\t{ \"key_at_index_name\", applesmc_key_at_index_name_show },\n\t{ \"key_at_index_type\", applesmc_key_at_index_type_show },\n\t{ \"key_at_index_data_length\", applesmc_key_at_index_data_length_show },\n\t{ \"key_at_index_data\", applesmc_key_at_index_read_show },\n\t{ }\n};\n\nstatic struct applesmc_node_group accelerometer_group[] = {\n\t{ \"position\", applesmc_position_show },\n\t{ \"calibrate\", applesmc_calibrate_show, applesmc_calibrate_store },\n\t{ }\n};\n\nstatic struct applesmc_node_group light_sensor_group[] = {\n\t{ \"light\", applesmc_light_show },\n\t{ }\n};\n\nstatic struct applesmc_node_group fan_group[] = {\n\t{ \"fan%d_label\", applesmc_show_fan_position },\n\t{ \"fan%d_input\", applesmc_show_fan_speed, NULL, 0 },\n\t{ \"fan%d_min\", applesmc_show_fan_speed, applesmc_store_fan_speed, 1 },\n\t{ \"fan%d_max\", applesmc_show_fan_speed, NULL, 2 },\n\t{ \"fan%d_safe\", applesmc_show_fan_speed, NULL, 3 },\n\t{ \"fan%d_output\", applesmc_show_fan_speed, applesmc_store_fan_speed, 4 },\n\t{ \"fan%d_manual\", applesmc_show_fan_manual, applesmc_store_fan_manual },\n\t{ }\n};\n\nstatic struct applesmc_node_group temp_group[] = {\n\t{ \"temp%d_label\", applesmc_show_sensor_label },\n\t{ \"temp%d_input\", applesmc_show_temperature },\n\t{ }\n};\n\n \n\n \nstatic void applesmc_destroy_nodes(struct applesmc_node_group *groups)\n{\n\tstruct applesmc_node_group *grp;\n\tstruct applesmc_dev_attr *node;\n\n\tfor (grp = groups; grp->nodes; grp++) {\n\t\tfor (node = grp->nodes; node->sda.dev_attr.attr.name; node++)\n\t\t\tsysfs_remove_file(&pdev->dev.kobj,\n\t\t\t\t\t  &node->sda.dev_attr.attr);\n\t\tkfree(grp->nodes);\n\t\tgrp->nodes = NULL;\n\t}\n}\n\n \nstatic int applesmc_create_nodes(struct applesmc_node_group *groups, int num)\n{\n\tstruct applesmc_node_group *grp;\n\tstruct applesmc_dev_attr *node;\n\tstruct attribute *attr;\n\tint ret, i;\n\n\tfor (grp = groups; grp->format; grp++) {\n\t\tgrp->nodes = kcalloc(num + 1, sizeof(*node), GFP_KERNEL);\n\t\tif (!grp->nodes) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tnode = &grp->nodes[i];\n\t\t\tscnprintf(node->name, sizeof(node->name), grp->format,\n\t\t\t\t  i + 1);\n\t\t\tnode->sda.index = (grp->option << 16) | (i & 0xffff);\n\t\t\tnode->sda.dev_attr.show = grp->show;\n\t\t\tnode->sda.dev_attr.store = grp->store;\n\t\t\tattr = &node->sda.dev_attr.attr;\n\t\t\tsysfs_attr_init(attr);\n\t\t\tattr->name = node->name;\n\t\t\tattr->mode = 0444 | (grp->store ? 0200 : 0);\n\t\t\tret = sysfs_create_file(&pdev->dev.kobj, attr);\n\t\t\tif (ret) {\n\t\t\t\tattr->name = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\nout:\n\tapplesmc_destroy_nodes(groups);\n\treturn ret;\n}\n\n \nstatic int applesmc_create_accelerometer(void)\n{\n\tint ret;\n\n\tif (!smcreg.has_accelerometer)\n\t\treturn 0;\n\n\tret = applesmc_create_nodes(accelerometer_group, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tapplesmc_idev = input_allocate_device();\n\tif (!applesmc_idev) {\n\t\tret = -ENOMEM;\n\t\tgoto out_sysfs;\n\t}\n\n\t \n\tapplesmc_calibrate();\n\n\t \n\tapplesmc_idev->name = \"applesmc\";\n\tapplesmc_idev->id.bustype = BUS_HOST;\n\tapplesmc_idev->dev.parent = &pdev->dev;\n\tinput_set_abs_params(applesmc_idev, ABS_X,\n\t\t\t-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);\n\tinput_set_abs_params(applesmc_idev, ABS_Y,\n\t\t\t-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);\n\n\tret = input_setup_polling(applesmc_idev, applesmc_idev_poll);\n\tif (ret)\n\t\tgoto out_idev;\n\n\tinput_set_poll_interval(applesmc_idev, APPLESMC_POLL_INTERVAL);\n\n\tret = input_register_device(applesmc_idev);\n\tif (ret)\n\t\tgoto out_idev;\n\n\treturn 0;\n\nout_idev:\n\tinput_free_device(applesmc_idev);\n\nout_sysfs:\n\tapplesmc_destroy_nodes(accelerometer_group);\n\nout:\n\tpr_warn(\"driver init failed (ret=%d)!\\n\", ret);\n\treturn ret;\n}\n\n \nstatic void applesmc_release_accelerometer(void)\n{\n\tif (!smcreg.has_accelerometer)\n\t\treturn;\n\tinput_unregister_device(applesmc_idev);\n\tapplesmc_destroy_nodes(accelerometer_group);\n}\n\nstatic int applesmc_create_light_sensor(void)\n{\n\tif (!smcreg.num_light_sensors)\n\t\treturn 0;\n\treturn applesmc_create_nodes(light_sensor_group, 1);\n}\n\nstatic void applesmc_release_light_sensor(void)\n{\n\tif (!smcreg.num_light_sensors)\n\t\treturn;\n\tapplesmc_destroy_nodes(light_sensor_group);\n}\n\nstatic int applesmc_create_key_backlight(void)\n{\n\tif (!smcreg.has_key_backlight)\n\t\treturn 0;\n\tapplesmc_led_wq = create_singlethread_workqueue(\"applesmc-led\");\n\tif (!applesmc_led_wq)\n\t\treturn -ENOMEM;\n\treturn led_classdev_register(&pdev->dev, &applesmc_backlight);\n}\n\nstatic void applesmc_release_key_backlight(void)\n{\n\tif (!smcreg.has_key_backlight)\n\t\treturn;\n\tled_classdev_unregister(&applesmc_backlight);\n\tdestroy_workqueue(applesmc_led_wq);\n}\n\nstatic int applesmc_dmi_match(const struct dmi_system_id *id)\n{\n\treturn 1;\n}\n\n \nstatic const struct dmi_system_id applesmc_whitelist[] __initconst = {\n\t{ applesmc_dmi_match, \"Apple MacBook Air\", {\n\t  DMI_MATCH(DMI_BOARD_VENDOR, \"Apple\"),\n\t  DMI_MATCH(DMI_PRODUCT_NAME, \"MacBookAir\") },\n\t},\n\t{ applesmc_dmi_match, \"Apple MacBook Pro\", {\n\t  DMI_MATCH(DMI_BOARD_VENDOR, \"Apple\"),\n\t  DMI_MATCH(DMI_PRODUCT_NAME, \"MacBookPro\") },\n\t},\n\t{ applesmc_dmi_match, \"Apple MacBook\", {\n\t  DMI_MATCH(DMI_BOARD_VENDOR, \"Apple\"),\n\t  DMI_MATCH(DMI_PRODUCT_NAME, \"MacBook\") },\n\t},\n\t{ applesmc_dmi_match, \"Apple Macmini\", {\n\t  DMI_MATCH(DMI_BOARD_VENDOR, \"Apple\"),\n\t  DMI_MATCH(DMI_PRODUCT_NAME, \"Macmini\") },\n\t},\n\t{ applesmc_dmi_match, \"Apple MacPro\", {\n\t  DMI_MATCH(DMI_BOARD_VENDOR, \"Apple\"),\n\t  DMI_MATCH(DMI_PRODUCT_NAME, \"MacPro\") },\n\t},\n\t{ applesmc_dmi_match, \"Apple iMac\", {\n\t  DMI_MATCH(DMI_BOARD_VENDOR, \"Apple\"),\n\t  DMI_MATCH(DMI_PRODUCT_NAME, \"iMac\") },\n\t},\n\t{ applesmc_dmi_match, \"Apple Xserve\", {\n\t  DMI_MATCH(DMI_BOARD_VENDOR, \"Apple\"),\n\t  DMI_MATCH(DMI_PRODUCT_NAME, \"Xserve\") },\n\t},\n\t{ .ident = NULL }\n};\n\nstatic int __init applesmc_init(void)\n{\n\tint ret;\n\n\tif (!dmi_check_system(applesmc_whitelist)) {\n\t\tpr_warn(\"supported laptop not found!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!request_region(APPLESMC_DATA_PORT, APPLESMC_NR_PORTS,\n\t\t\t\t\t\t\t\t\"applesmc\")) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tret = platform_driver_register(&applesmc_driver);\n\tif (ret)\n\t\tgoto out_region;\n\n\tpdev = platform_device_register_simple(\"applesmc\", APPLESMC_DATA_PORT,\n\t\t\t\t\t       NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\tret = PTR_ERR(pdev);\n\t\tgoto out_driver;\n\t}\n\n\t \n\tret = applesmc_init_smcreg();\n\tif (ret)\n\t\tgoto out_device;\n\n\tret = applesmc_create_nodes(info_group, 1);\n\tif (ret)\n\t\tgoto out_smcreg;\n\n\tret = applesmc_create_nodes(fan_group, smcreg.fan_count);\n\tif (ret)\n\t\tgoto out_info;\n\n\tret = applesmc_create_nodes(temp_group, smcreg.index_count);\n\tif (ret)\n\t\tgoto out_fans;\n\n\tret = applesmc_create_accelerometer();\n\tif (ret)\n\t\tgoto out_temperature;\n\n\tret = applesmc_create_light_sensor();\n\tif (ret)\n\t\tgoto out_accelerometer;\n\n\tret = applesmc_create_key_backlight();\n\tif (ret)\n\t\tgoto out_light_sysfs;\n\n\thwmon_dev = hwmon_device_register(&pdev->dev);\n\tif (IS_ERR(hwmon_dev)) {\n\t\tret = PTR_ERR(hwmon_dev);\n\t\tgoto out_light_ledclass;\n\t}\n\n\treturn 0;\n\nout_light_ledclass:\n\tapplesmc_release_key_backlight();\nout_light_sysfs:\n\tapplesmc_release_light_sensor();\nout_accelerometer:\n\tapplesmc_release_accelerometer();\nout_temperature:\n\tapplesmc_destroy_nodes(temp_group);\nout_fans:\n\tapplesmc_destroy_nodes(fan_group);\nout_info:\n\tapplesmc_destroy_nodes(info_group);\nout_smcreg:\n\tapplesmc_destroy_smcreg();\nout_device:\n\tplatform_device_unregister(pdev);\nout_driver:\n\tplatform_driver_unregister(&applesmc_driver);\nout_region:\n\trelease_region(APPLESMC_DATA_PORT, APPLESMC_NR_PORTS);\nout:\n\tpr_warn(\"driver init failed (ret=%d)!\\n\", ret);\n\treturn ret;\n}\n\nstatic void __exit applesmc_exit(void)\n{\n\thwmon_device_unregister(hwmon_dev);\n\tapplesmc_release_key_backlight();\n\tapplesmc_release_light_sensor();\n\tapplesmc_release_accelerometer();\n\tapplesmc_destroy_nodes(temp_group);\n\tapplesmc_destroy_nodes(fan_group);\n\tapplesmc_destroy_nodes(info_group);\n\tapplesmc_destroy_smcreg();\n\tplatform_device_unregister(pdev);\n\tplatform_driver_unregister(&applesmc_driver);\n\trelease_region(APPLESMC_DATA_PORT, APPLESMC_NR_PORTS);\n}\n\nmodule_init(applesmc_init);\nmodule_exit(applesmc_exit);\n\nMODULE_AUTHOR(\"Nicolas Boichat\");\nMODULE_DESCRIPTION(\"Apple SMC\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(dmi, applesmc_whitelist);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}