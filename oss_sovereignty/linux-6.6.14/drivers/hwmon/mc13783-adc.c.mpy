{
  "module_name": "mc13783-adc.c",
  "hash_id": "2ec4c6f8d1532e5bd2442d56a4f19aa0fd99b163e84cfdbef7b14b17edaf0b25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/mc13783-adc.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/mc13xxx.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/hwmon.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/err.h>\n\n#define DRIVER_NAME\t\"mc13783-adc\"\n\n \n#define MC13783_ADC_16CHANS\t1\n#define MC13783_ADC_BPDIV2\t2\n\nstruct mc13783_adc_priv {\n\tstruct mc13xxx *mc13xxx;\n\tstruct device *hwmon_dev;\n\tchar name[PLATFORM_NAME_SIZE];\n};\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct mc13783_adc_priv *priv = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", priv->name);\n}\n\nstatic int mc13783_adc_read(struct device *dev,\n\t\tstruct device_attribute *devattr, unsigned int *val)\n{\n\tstruct mc13783_adc_priv *priv = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tunsigned int channel = attr->index;\n\tunsigned int sample[4];\n\tint ret;\n\n\tret = mc13xxx_adc_do_conversion(priv->mc13xxx,\n\t\t\tMC13XXX_ADC_MODE_MULT_CHAN,\n\t\t\tchannel, 0, 0, sample);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (channel >= 16)\n\t\tchannel = 7;\n\n\tchannel &= 0x7;\n\n\t*val = (sample[channel % 4] >> (channel > 3 ? 14 : 2)) & 0x3ff;\n\n\treturn 0;\n}\n\nstatic ssize_t mc13783_adc_bp_show(struct device *dev,\n\t\t\t\t   struct device_attribute *devattr,\n\t\t\t\t   char *buf)\n{\n\tunsigned val;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tkernel_ulong_t driver_data = platform_get_device_id(pdev)->driver_data;\n\tint ret = mc13783_adc_read(dev, devattr, &val);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (driver_data & MC13783_ADC_BPDIV2)\n\t\tval = DIV_ROUND_CLOSEST(val * 9, 2);\n\telse\n\t\t \n\t\tval = DIV_ROUND_CLOSEST(val * 9, 4) + 2400;\n\n\treturn sprintf(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t mc13783_adc_gp_show(struct device *dev,\n\t\t\t\t   struct device_attribute *devattr,\n\t\t\t\t   char *buf)\n{\n\tunsigned val;\n\tint ret = mc13783_adc_read(dev, devattr, &val);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = DIV_ROUND_CLOSEST(val * 9, 4);\n\n\treturn sprintf(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t mc13783_adc_uid_show(struct device *dev,\n\t\t\t\t    struct device_attribute *devattr,\n\t\t\t\t    char *buf)\n{\n\tunsigned int val;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tkernel_ulong_t driver_data = platform_get_device_id(pdev)->driver_data;\n\tint ret = mc13783_adc_read(dev, devattr, &val);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (driver_data & MC13783_ADC_BPDIV2)\n\t\t \n\t\tval = DIV_ROUND_CLOSEST(val * 4800, 1024);\n\telse\n\t\t \n\t\tval = DIV_ROUND_CLOSEST(val * 2555, 1024);\n\n\treturn sprintf(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t mc13783_adc_temp_show(struct device *dev,\n\t\t\t\t     struct device_attribute *devattr,\n\t\t\t\t     char *buf)\n{\n\tunsigned int val;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tkernel_ulong_t driver_data = platform_get_device_id(pdev)->driver_data;\n\tint ret = mc13783_adc_read(dev, devattr, &val);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (driver_data & MC13783_ADC_BPDIV2) {\n\t\t \n\t\tret = DIV_ROUND_CLOSEST(-2635920 + val * 4244, 10);\n\t} else {\n\t\t \n\t\tret = 346480 - 1140 * val;\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", ret);\n}\n\nstatic DEVICE_ATTR_RO(name);\nstatic SENSOR_DEVICE_ATTR_RO(in2_input, mc13783_adc_bp, 2);\nstatic SENSOR_DEVICE_ATTR_RO(in5_input, mc13783_adc_gp, 5);\nstatic SENSOR_DEVICE_ATTR_RO(in6_input, mc13783_adc_gp, 6);\nstatic SENSOR_DEVICE_ATTR_RO(in7_input, mc13783_adc_gp, 7);\nstatic SENSOR_DEVICE_ATTR_RO(in8_input, mc13783_adc_gp, 8);\nstatic SENSOR_DEVICE_ATTR_RO(in9_input, mc13783_adc_gp, 9);\nstatic SENSOR_DEVICE_ATTR_RO(in10_input, mc13783_adc_gp, 10);\nstatic SENSOR_DEVICE_ATTR_RO(in11_input, mc13783_adc_gp, 11);\nstatic SENSOR_DEVICE_ATTR_RO(in12_input, mc13783_adc_gp, 12);\nstatic SENSOR_DEVICE_ATTR_RO(in13_input, mc13783_adc_gp, 13);\nstatic SENSOR_DEVICE_ATTR_RO(in14_input, mc13783_adc_gp, 14);\nstatic SENSOR_DEVICE_ATTR_RO(in15_input, mc13783_adc_gp, 15);\nstatic SENSOR_DEVICE_ATTR_RO(in16_input, mc13783_adc_uid, 16);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, mc13783_adc_temp, 17);\n\nstatic struct attribute *mc13783_attr_base[] = {\n\t&dev_attr_name.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in6_input.dev_attr.attr,\n\t&sensor_dev_attr_in7_input.dev_attr.attr,\n\t&sensor_dev_attr_in16_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mc13783_group_base = {\n\t.attrs = mc13783_attr_base,\n};\n\n \nstatic struct attribute *mc13783_attr_16chans[] = {\n\t&sensor_dev_attr_in8_input.dev_attr.attr,\n\t&sensor_dev_attr_in9_input.dev_attr.attr,\n\t&sensor_dev_attr_in10_input.dev_attr.attr,\n\t&sensor_dev_attr_in11_input.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mc13783_group_16chans = {\n\t.attrs = mc13783_attr_16chans,\n};\n\n \nstatic struct attribute *mc13783_attr_ts[] = {\n\t&sensor_dev_attr_in12_input.dev_attr.attr,\n\t&sensor_dev_attr_in13_input.dev_attr.attr,\n\t&sensor_dev_attr_in14_input.dev_attr.attr,\n\t&sensor_dev_attr_in15_input.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mc13783_group_ts = {\n\t.attrs = mc13783_attr_ts,\n};\n\nstatic int mc13783_adc_use_touchscreen(struct platform_device *pdev)\n{\n\tstruct mc13783_adc_priv *priv = platform_get_drvdata(pdev);\n\tunsigned flags = mc13xxx_get_flags(priv->mc13xxx);\n\n\treturn flags & MC13XXX_USE_TOUCHSCREEN;\n}\n\nstatic int __init mc13783_adc_probe(struct platform_device *pdev)\n{\n\tstruct mc13783_adc_priv *priv;\n\tint ret;\n\tconst struct platform_device_id *id = platform_get_device_id(pdev);\n\tchar *dash;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->mc13xxx = dev_get_drvdata(pdev->dev.parent);\n\tsnprintf(priv->name, ARRAY_SIZE(priv->name), \"%s\", id->name);\n\tdash = strchr(priv->name, '-');\n\tif (dash)\n\t\t*dash = '\\0';\n\n\tplatform_set_drvdata(pdev, priv);\n\n\t \n\tret = sysfs_create_group(&pdev->dev.kobj, &mc13783_group_base);\n\tif (ret)\n\t\treturn ret;\n\n\tif (id->driver_data & MC13783_ADC_16CHANS) {\n\t\tret = sysfs_create_group(&pdev->dev.kobj,\n\t\t\t\t&mc13783_group_16chans);\n\t\tif (ret)\n\t\t\tgoto out_err_create_16chans;\n\t}\n\n\tif (!mc13783_adc_use_touchscreen(pdev)) {\n\t\tret = sysfs_create_group(&pdev->dev.kobj, &mc13783_group_ts);\n\t\tif (ret)\n\t\t\tgoto out_err_create_ts;\n\t}\n\n\tpriv->hwmon_dev = hwmon_device_register(&pdev->dev);\n\tif (IS_ERR(priv->hwmon_dev)) {\n\t\tret = PTR_ERR(priv->hwmon_dev);\n\t\tdev_err(&pdev->dev,\n\t\t\t\t\"hwmon_device_register failed with %d.\\n\", ret);\n\t\tgoto out_err_register;\n\t}\n\n\treturn 0;\n\nout_err_register:\n\n\tif (!mc13783_adc_use_touchscreen(pdev))\n\t\tsysfs_remove_group(&pdev->dev.kobj, &mc13783_group_ts);\nout_err_create_ts:\n\n\tif (id->driver_data & MC13783_ADC_16CHANS)\n\t\tsysfs_remove_group(&pdev->dev.kobj, &mc13783_group_16chans);\nout_err_create_16chans:\n\n\tsysfs_remove_group(&pdev->dev.kobj, &mc13783_group_base);\n\treturn ret;\n}\n\nstatic int mc13783_adc_remove(struct platform_device *pdev)\n{\n\tstruct mc13783_adc_priv *priv = platform_get_drvdata(pdev);\n\tkernel_ulong_t driver_data = platform_get_device_id(pdev)->driver_data;\n\n\thwmon_device_unregister(priv->hwmon_dev);\n\n\tif (!mc13783_adc_use_touchscreen(pdev))\n\t\tsysfs_remove_group(&pdev->dev.kobj, &mc13783_group_ts);\n\n\tif (driver_data & MC13783_ADC_16CHANS)\n\t\tsysfs_remove_group(&pdev->dev.kobj, &mc13783_group_16chans);\n\n\tsysfs_remove_group(&pdev->dev.kobj, &mc13783_group_base);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id mc13783_adc_idtable[] = {\n\t{\n\t\t.name = \"mc13783-adc\",\n\t\t.driver_data = MC13783_ADC_16CHANS,\n\t}, {\n\t\t.name = \"mc13892-adc\",\n\t\t.driver_data = MC13783_ADC_BPDIV2,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(platform, mc13783_adc_idtable);\n\nstatic struct platform_driver mc13783_adc_driver = {\n\t.remove\t\t= mc13783_adc_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t},\n\t.id_table\t= mc13783_adc_idtable,\n};\n\nmodule_platform_driver_probe(mc13783_adc_driver, mc13783_adc_probe);\n\nMODULE_DESCRIPTION(\"MC13783 ADC driver\");\nMODULE_AUTHOR(\"Luotao Fu <l.fu@pengutronix.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}