{
  "module_name": "w83773g.c",
  "hash_id": "9662e1322d9917d37f25381dd114d93e7d5b8af2e3c85bdad666c9652ca2779d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/w83773g.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n \n#define W83773_CHANNELS\t\t\t\t3\n\n \n#define W83773_CONVERSION_RATE_REG_READ\t\t0x04\n#define W83773_CONVERSION_RATE_REG_WRITE\t0x0A\n#define W83773_MANUFACTURER_ID_REG\t\t0xFE\n#define W83773_LOCAL_TEMP\t\t\t0x00\n\nstatic const u8 W83773_STATUS[2] = { 0x02, 0x17 };\n\nstatic const u8 W83773_TEMP_LSB[2] = { 0x10, 0x25 };\nstatic const u8 W83773_TEMP_MSB[2] = { 0x01, 0x24 };\n\nstatic const u8 W83773_OFFSET_LSB[2] = { 0x12, 0x16 };\nstatic const u8 W83773_OFFSET_MSB[2] = { 0x11, 0x15 };\n\n \nstatic const struct i2c_device_id w83773_id[] = {\n\t{ \"w83773g\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, w83773_id);\n\nstatic const struct of_device_id __maybe_unused w83773_of_match[] = {\n\t{\n\t\t.compatible = \"nuvoton,w83773g\"\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, w83773_of_match);\n\nstatic inline long temp_of_local(s8 reg)\n{\n\treturn reg * 1000;\n}\n\nstatic inline long temp_of_remote(s8 hb, u8 lb)\n{\n\treturn (hb << 3 | lb >> 5) * 125;\n}\n\nstatic int get_local_temp(struct regmap *regmap, long *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(regmap, W83773_LOCAL_TEMP, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = temp_of_local(regval);\n\treturn 0;\n}\n\nstatic int get_remote_temp(struct regmap *regmap, int index, long *val)\n{\n\tunsigned int regval_high;\n\tunsigned int regval_low;\n\tint ret;\n\n\tret = regmap_read(regmap, W83773_TEMP_MSB[index], &regval_high);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(regmap, W83773_TEMP_LSB[index], &regval_low);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = temp_of_remote(regval_high, regval_low);\n\treturn 0;\n}\n\nstatic int get_fault(struct regmap *regmap, int index, long *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(regmap, W83773_STATUS[index], &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = (regval & 0x04) >> 2;\n\treturn 0;\n}\n\nstatic int get_offset(struct regmap *regmap, int index, long *val)\n{\n\tunsigned int regval_high;\n\tunsigned int regval_low;\n\tint ret;\n\n\tret = regmap_read(regmap, W83773_OFFSET_MSB[index], &regval_high);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(regmap, W83773_OFFSET_LSB[index], &regval_low);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = temp_of_remote(regval_high, regval_low);\n\treturn 0;\n}\n\nstatic int set_offset(struct regmap *regmap, int index, long val)\n{\n\tint ret;\n\tu8 high_byte;\n\tu8 low_byte;\n\n\tval = clamp_val(val, -127825, 127825);\n\t \n\tval /= 125;\n\thigh_byte = val >> 3;\n\tlow_byte = (val & 0x07) << 5;\n\n\tret = regmap_write(regmap, W83773_OFFSET_MSB[index], high_byte);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_write(regmap, W83773_OFFSET_LSB[index], low_byte);\n}\n\nstatic int get_update_interval(struct regmap *regmap, long *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(regmap, W83773_CONVERSION_RATE_REG_READ, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = 16000 >> regval;\n\treturn 0;\n}\n\nstatic int set_update_interval(struct regmap *regmap, long val)\n{\n\tint rate;\n\n\t \n\tval = clamp_val(val, 62, 16000) * 10;\n\trate = 8 - __fls((val * 8 / (625 * 7)));\n\treturn regmap_write(regmap, W83773_CONVERSION_RATE_REG_WRITE, rate);\n}\n\nstatic int w83773_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long *val)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\n\tif (type == hwmon_chip) {\n\t\tif (attr == hwmon_chip_update_interval)\n\t\t\treturn get_update_interval(regmap, val);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tif (channel == 0)\n\t\t\treturn get_local_temp(regmap, val);\n\t\treturn get_remote_temp(regmap, channel - 1, val);\n\tcase hwmon_temp_fault:\n\t\treturn get_fault(regmap, channel - 1, val);\n\tcase hwmon_temp_offset:\n\t\treturn get_offset(regmap, channel - 1, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int w83773_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long val)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\n\tif (type == hwmon_chip && attr == hwmon_chip_update_interval)\n\t\treturn set_update_interval(regmap, val);\n\n\tif (type == hwmon_temp && attr == hwmon_temp_offset)\n\t\treturn set_offset(regmap, channel - 1, val);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic umode_t w83773_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_fault:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_offset:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const w83773_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ | HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_FAULT | HWMON_T_OFFSET,\n\t\t\t   HWMON_T_INPUT | HWMON_T_FAULT | HWMON_T_OFFSET),\n\tNULL\n};\n\nstatic const struct hwmon_ops w83773_ops = {\n\t.is_visible = w83773_is_visible,\n\t.read = w83773_read,\n\t.write = w83773_write,\n};\n\nstatic const struct hwmon_chip_info w83773_chip_info = {\n\t.ops = &w83773_ops,\n\t.info = w83773_info,\n};\n\nstatic const struct regmap_config w83773_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int w83773_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tregmap = devm_regmap_init_i2c(client, &w83773_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\t \n\tret = regmap_write(regmap, W83773_CONVERSION_RATE_REG_WRITE, 0x05);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"error writing config rate register\\n\");\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(client, regmap);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev,\n\t\t\t\t\t\t\t client->name,\n\t\t\t\t\t\t\t regmap,\n\t\t\t\t\t\t\t &w83773_chip_info,\n\t\t\t\t\t\t\t NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic struct i2c_driver w83773_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"w83773g\",\n\t\t.of_match_table = of_match_ptr(w83773_of_match),\n\t},\n\t.probe = w83773_probe,\n\t.id_table = w83773_id,\n};\n\nmodule_i2c_driver(w83773_driver);\n\nMODULE_AUTHOR(\"Lei YU <mine260309@gmail.com>\");\nMODULE_DESCRIPTION(\"W83773G temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}