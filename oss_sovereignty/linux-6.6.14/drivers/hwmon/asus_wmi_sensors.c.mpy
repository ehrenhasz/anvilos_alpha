{
  "module_name": "asus_wmi_sensors.c",
  "hash_id": "286bab4a9f47219814dd6148e25c4893e4b2ad8cb15894160fcd2bafaf3e7242",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/asus_wmi_sensors.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/hwmon.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/units.h>\n#include <linux/wmi.h>\n\n#define ASUSWMI_MONITORING_GUID\t\t\"466747A0-70EC-11DE-8A39-0800200C9A66\"\n#define ASUSWMI_METHODID_GET_VALUE\t0x52574543  \n#define ASUSWMI_METHODID_UPDATE_BUFFER\t0x51574543  \n#define ASUSWMI_METHODID_GET_INFO\t0x50574543  \n#define ASUSWMI_METHODID_GET_NUMBER\t0x50574572  \n#define ASUSWMI_METHODID_GET_VERSION\t0x50574574  \n\n#define ASUS_WMI_MAX_STR_SIZE\t\t32\n\n#define DMI_EXACT_MATCH_ASUS_BOARD_NAME(name) {\t\t\t\t\t\\\n\t.matches = {\t\t\t\t\t\t\t\t\\\n\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK COMPUTER INC.\"),\t\\\n\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, name),\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\t\\\n}\n\nstatic const struct dmi_system_id asus_wmi_dmi_table[] = {\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"PRIME X399-A\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"PRIME X470-PRO\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG CROSSHAIR VI EXTREME\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"CROSSHAIR VI HERO\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG CROSSHAIR VI HERO (WI-FI AC)\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG CROSSHAIR VII HERO\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG CROSSHAIR VII HERO (WI-FI)\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX B450-E GAMING\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX B450-F GAMING\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX B450-F GAMING II\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX B450-I GAMING\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX X399-E GAMING\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX X470-F GAMING\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG STRIX X470-I GAMING\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG ZENITH EXTREME\"),\n\tDMI_EXACT_MATCH_ASUS_BOARD_NAME(\"ROG ZENITH EXTREME ALPHA\"),\n\t{}\n};\nMODULE_DEVICE_TABLE(dmi, asus_wmi_dmi_table);\n\nenum asus_wmi_sensor_class {\n\tVOLTAGE\t\t= 0x0,\n\tTEMPERATURE_C\t= 0x1,\n\tFAN_RPM\t\t= 0x2,\n\tCURRENT\t\t= 0x3,\n\tWATER_FLOW\t= 0x4,\n};\n\nenum asus_wmi_location {\n\tCPU\t\t= 0x0,\n\tCPU_SOC\t\t= 0x1,\n\tDRAM\t\t= 0x2,\n\tMOTHERBOARD\t= 0x3,\n\tCHIPSET\t\t= 0x4,\n\tAUX\t\t= 0x5,\n\tVRM\t\t= 0x6,\n\tCOOLER\t\t= 0x7\n};\n\nenum asus_wmi_type {\n\tSIGNED_INT\t= 0x0,\n\tUNSIGNED_INT\t= 0x1,\n\tSCALED\t\t= 0x3,\n};\n\nenum asus_wmi_source {\n\tSIO\t\t= 0x1,\n\tEC\t\t= 0x2\n};\n\nstatic enum hwmon_sensor_types asus_data_types[] = {\n\t[VOLTAGE]\t= hwmon_in,\n\t[TEMPERATURE_C]\t= hwmon_temp,\n\t[FAN_RPM]\t= hwmon_fan,\n\t[CURRENT]\t= hwmon_curr,\n\t[WATER_FLOW]\t= hwmon_fan,\n};\n\nstatic u32 hwmon_attributes[hwmon_max] = {\n\t[hwmon_chip]\t= HWMON_C_REGISTER_TZ,\n\t[hwmon_temp]\t= HWMON_T_INPUT | HWMON_T_LABEL,\n\t[hwmon_in]\t= HWMON_I_INPUT | HWMON_I_LABEL,\n\t[hwmon_curr]\t= HWMON_C_INPUT | HWMON_C_LABEL,\n\t[hwmon_fan]\t= HWMON_F_INPUT | HWMON_F_LABEL,\n};\n\n \nstruct asus_wmi_sensor_info {\n\tu32 id;\n\tint data_type;\n\tint location;\n\tchar name[ASUS_WMI_MAX_STR_SIZE];\n\tint source;\n\tint type;\n\tlong cached_value;\n};\n\nstruct asus_wmi_wmi_info {\n\tunsigned long source_last_updated[3];\t \n\tint sensor_count;\n\n\tconst struct asus_wmi_sensor_info **info[hwmon_max];\n\tstruct asus_wmi_sensor_info **info_by_id;\n};\n\nstruct asus_wmi_sensors {\n\tstruct asus_wmi_wmi_info wmi;\n\t \n\tstruct mutex lock;\n};\n\n \nstatic int asus_wmi_call_method(u32 method_id, u32 *args, struct acpi_buffer *output)\n{\n\tstruct acpi_buffer input = {(acpi_size) sizeof(*args), args };\n\tacpi_status status;\n\n\tstatus = wmi_evaluate_method(ASUSWMI_MONITORING_GUID, 0,\n\t\t\t\t     method_id, &input, output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int asus_wmi_get_version(u32 *version)\n{\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tu32 args[] = {0, 0, 0};\n\tunion acpi_object *obj;\n\tint err;\n\n\terr = asus_wmi_call_method(ASUSWMI_METHODID_GET_VERSION, args, &output);\n\tif (err)\n\t\treturn err;\n\n\tobj = output.pointer;\n\tif (!obj)\n\t\treturn -EIO;\n\n\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\terr = -EIO;\n\t\tgoto out_free_obj;\n\t}\n\n\terr = 0;\n\t*version = obj->integer.value;\n\nout_free_obj:\n\tACPI_FREE(obj);\n\treturn err;\n}\n\n \nstatic int asus_wmi_get_item_count(u32 *count)\n{\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tu32 args[] = {0, 0, 0};\n\tunion acpi_object *obj;\n\tint err;\n\n\terr = asus_wmi_call_method(ASUSWMI_METHODID_GET_NUMBER, args, &output);\n\tif (err)\n\t\treturn err;\n\n\tobj = output.pointer;\n\tif (!obj)\n\t\treturn -EIO;\n\n\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\terr = -EIO;\n\t\tgoto out_free_obj;\n\t}\n\n\terr = 0;\n\t*count = obj->integer.value;\n\nout_free_obj:\n\tACPI_FREE(obj);\n\treturn err;\n}\n\nstatic int asus_wmi_hwmon_add_chan_info(struct hwmon_channel_info *asus_wmi_hwmon_chan,\n\t\t\t\t\tstruct device *dev, int num,\n\t\t\t\t\tenum hwmon_sensor_types type, u32 config)\n{\n\tu32 *cfg;\n\n\tcfg = devm_kcalloc(dev, num + 1, sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tasus_wmi_hwmon_chan->type = type;\n\tasus_wmi_hwmon_chan->config = cfg;\n\tmemset32(cfg, config, num);\n\n\treturn 0;\n}\n\n \nstatic int asus_wmi_sensor_info(int index, struct asus_wmi_sensor_info *s)\n{\n\tunion acpi_object name_obj, data_type_obj, location_obj, source_obj, type_obj;\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tu32 args[] = {index, 0};\n\tunion acpi_object *obj;\n\tint err;\n\n\terr = asus_wmi_call_method(ASUSWMI_METHODID_GET_INFO, args, &output);\n\tif (err)\n\t\treturn err;\n\n\ts->id = index;\n\n\tobj = output.pointer;\n\tif (!obj)\n\t\treturn -EIO;\n\n\tif (obj->type != ACPI_TYPE_PACKAGE) {\n\t\terr = -EIO;\n\t\tgoto out_free_obj;\n\t}\n\n\tif (obj->package.count != 5) {\n\t\terr = -EIO;\n\t\tgoto out_free_obj;\n\t}\n\n\tname_obj = obj->package.elements[0];\n\tif (name_obj.type != ACPI_TYPE_STRING) {\n\t\terr = -EIO;\n\t\tgoto out_free_obj;\n\t}\n\n\tstrncpy(s->name, name_obj.string.pointer, sizeof(s->name) - 1);\n\n\tdata_type_obj = obj->package.elements[1];\n\tif (data_type_obj.type != ACPI_TYPE_INTEGER) {\n\t\terr = -EIO;\n\t\tgoto out_free_obj;\n\t}\n\n\ts->data_type = data_type_obj.integer.value;\n\n\tlocation_obj = obj->package.elements[2];\n\tif (location_obj.type != ACPI_TYPE_INTEGER) {\n\t\terr = -EIO;\n\t\tgoto out_free_obj;\n\t}\n\n\ts->location = location_obj.integer.value;\n\n\tsource_obj = obj->package.elements[3];\n\tif (source_obj.type != ACPI_TYPE_INTEGER) {\n\t\terr = -EIO;\n\t\tgoto out_free_obj;\n\t}\n\n\ts->source = source_obj.integer.value;\n\n\ttype_obj = obj->package.elements[4];\n\tif (type_obj.type != ACPI_TYPE_INTEGER) {\n\t\terr = -EIO;\n\t\tgoto out_free_obj;\n\t}\n\n\terr = 0;\n\ts->type = type_obj.integer.value;\n\nout_free_obj:\n\tACPI_FREE(obj);\n\treturn err;\n}\n\nstatic int asus_wmi_update_buffer(int source)\n{\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tu32 args[] = {source, 0};\n\n\treturn asus_wmi_call_method(ASUSWMI_METHODID_UPDATE_BUFFER, args, &output);\n}\n\nstatic int asus_wmi_get_sensor_value(u8 index, long *value)\n{\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tu32 args[] = {index, 0};\n\tunion acpi_object *obj;\n\tint err;\n\n\terr = asus_wmi_call_method(ASUSWMI_METHODID_GET_VALUE, args, &output);\n\tif (err)\n\t\treturn err;\n\n\tobj = output.pointer;\n\tif (!obj)\n\t\treturn -EIO;\n\n\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\terr = -EIO;\n\t\tgoto out_free_obj;\n\t}\n\n\terr = 0;\n\t*value = obj->integer.value;\n\nout_free_obj:\n\tACPI_FREE(obj);\n\treturn err;\n}\n\nstatic int asus_wmi_update_values_for_source(u8 source, struct asus_wmi_sensors *sensor_data)\n{\n\tstruct asus_wmi_sensor_info *sensor;\n\tlong value = 0;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < sensor_data->wmi.sensor_count; i++) {\n\t\tsensor = sensor_data->wmi.info_by_id[i];\n\t\tif (sensor && sensor->source == source) {\n\t\t\tret = asus_wmi_get_sensor_value(sensor->id, &value);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsensor->cached_value = value;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int asus_wmi_scale_sensor_value(u32 value, int data_type)\n{\n\t \n\tswitch (data_type) {\n\tcase VOLTAGE:\n\t\t \n\t\treturn DIV_ROUND_CLOSEST(value,  KILO);\n\tcase TEMPERATURE_C:\n\t\t \n\t\treturn value * MILLIDEGREE_PER_DEGREE;\n\tcase CURRENT:\n\t\t \n\t\treturn value * MILLI;\n\t}\n\treturn value;\n}\n\nstatic int asus_wmi_get_cached_value_or_update(const struct asus_wmi_sensor_info *sensor,\n\t\t\t\t\t       struct asus_wmi_sensors *sensor_data,\n\t\t\t\t\t       u32 *value)\n{\n\tint ret = 0;\n\n\tmutex_lock(&sensor_data->lock);\n\n\tif (time_after(jiffies, sensor_data->wmi.source_last_updated[sensor->source] + HZ)) {\n\t\tret = asus_wmi_update_buffer(sensor->source);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tret = asus_wmi_update_values_for_source(sensor->source, sensor_data);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tsensor_data->wmi.source_last_updated[sensor->source] = jiffies;\n\t}\n\n\t*value = sensor->cached_value;\n\nunlock:\n\tmutex_unlock(&sensor_data->lock);\n\n\treturn ret;\n}\n\n \nstatic int asus_wmi_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t       u32 attr, int channel, long *val)\n{\n\tconst struct asus_wmi_sensor_info *sensor;\n\tu32 value = 0;\n\tint ret;\n\n\tstruct asus_wmi_sensors *sensor_data = dev_get_drvdata(dev);\n\n\tsensor = *(sensor_data->wmi.info[type] + channel);\n\n\tret = asus_wmi_get_cached_value_or_update(sensor, sensor_data, &value);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = asus_wmi_scale_sensor_value(value, sensor->data_type);\n\n\treturn ret;\n}\n\nstatic int asus_wmi_hwmon_read_string(struct device *dev,\n\t\t\t\t      enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t      int channel, const char **str)\n{\n\tstruct asus_wmi_sensors *sensor_data = dev_get_drvdata(dev);\n\tconst struct asus_wmi_sensor_info *sensor;\n\n\tsensor = *(sensor_data->wmi.info[type] + channel);\n\t*str = sensor->name;\n\n\treturn 0;\n}\n\nstatic umode_t asus_wmi_hwmon_is_visible(const void *drvdata,\n\t\t\t\t\t enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t\t int channel)\n{\n\tconst struct asus_wmi_sensors *sensor_data = drvdata;\n\tconst struct asus_wmi_sensor_info *sensor;\n\n\tsensor = *(sensor_data->wmi.info[type] + channel);\n\tif (sensor)\n\t\treturn 0444;\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops asus_wmi_hwmon_ops = {\n\t.is_visible = asus_wmi_hwmon_is_visible,\n\t.read = asus_wmi_hwmon_read,\n\t.read_string = asus_wmi_hwmon_read_string,\n};\n\nstatic struct hwmon_chip_info asus_wmi_chip_info = {\n\t.ops = &asus_wmi_hwmon_ops,\n\t.info = NULL,\n};\n\nstatic int asus_wmi_configure_sensor_setup(struct device *dev,\n\t\t\t\t\t   struct asus_wmi_sensors *sensor_data)\n{\n\tconst struct hwmon_channel_info **ptr_asus_wmi_ci;\n\tstruct hwmon_channel_info *asus_wmi_hwmon_chan;\n\tint nr_count[hwmon_max] = {}, nr_types = 0;\n\tstruct asus_wmi_sensor_info *temp_sensor;\n\tconst struct hwmon_chip_info *chip_info;\n\tenum hwmon_sensor_types type;\n\tstruct device *hwdev;\n\tint i, idx;\n\tint err;\n\n\tfor (i = 0; i < sensor_data->wmi.sensor_count; i++) {\n\t\tstruct asus_wmi_sensor_info sensor;\n\n\t\terr = asus_wmi_sensor_info(i, &sensor);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tswitch (sensor.data_type) {\n\t\tcase TEMPERATURE_C:\n\t\tcase VOLTAGE:\n\t\tcase CURRENT:\n\t\tcase FAN_RPM:\n\t\tcase WATER_FLOW:\n\t\t\ttype = asus_data_types[sensor.data_type];\n\t\t\tif (!nr_count[type])\n\t\t\t\tnr_types++;\n\t\t\tnr_count[type]++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (nr_count[hwmon_temp])\n\t\tnr_count[hwmon_chip]++, nr_types++;\n\n\tasus_wmi_hwmon_chan = devm_kcalloc(dev, nr_types,\n\t\t\t\t\t   sizeof(*asus_wmi_hwmon_chan),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!asus_wmi_hwmon_chan)\n\t\treturn -ENOMEM;\n\n\tptr_asus_wmi_ci = devm_kcalloc(dev, nr_types + 1,\n\t\t\t\t       sizeof(*ptr_asus_wmi_ci), GFP_KERNEL);\n\tif (!ptr_asus_wmi_ci)\n\t\treturn -ENOMEM;\n\n\tasus_wmi_chip_info.info = ptr_asus_wmi_ci;\n\tchip_info = &asus_wmi_chip_info;\n\n\tsensor_data->wmi.info_by_id = devm_kcalloc(dev, sensor_data->wmi.sensor_count,\n\t\t\t\t\t\t   sizeof(*sensor_data->wmi.info_by_id),\n\t\t\t\t\t\t   GFP_KERNEL);\n\n\tif (!sensor_data->wmi.info_by_id)\n\t\treturn -ENOMEM;\n\n\tfor (type = 0; type < hwmon_max; type++) {\n\t\tif (!nr_count[type])\n\t\t\tcontinue;\n\n\t\terr = asus_wmi_hwmon_add_chan_info(asus_wmi_hwmon_chan, dev,\n\t\t\t\t\t\t   nr_count[type], type,\n\t\t\t\t\t\t   hwmon_attributes[type]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*ptr_asus_wmi_ci++ = asus_wmi_hwmon_chan++;\n\n\t\tsensor_data->wmi.info[type] = devm_kcalloc(dev,\n\t\t\t\t\t\t\t   nr_count[type],\n\t\t\t\t\t\t\t   sizeof(*sensor_data->wmi.info),\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!sensor_data->wmi.info[type])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = sensor_data->wmi.sensor_count - 1; i >= 0; i--) {\n\t\ttemp_sensor = devm_kzalloc(dev, sizeof(*temp_sensor), GFP_KERNEL);\n\t\tif (!temp_sensor)\n\t\t\treturn -ENOMEM;\n\n\t\terr = asus_wmi_sensor_info(i, temp_sensor);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tswitch (temp_sensor->data_type) {\n\t\tcase TEMPERATURE_C:\n\t\tcase VOLTAGE:\n\t\tcase CURRENT:\n\t\tcase FAN_RPM:\n\t\tcase WATER_FLOW:\n\t\t\ttype = asus_data_types[temp_sensor->data_type];\n\t\t\tidx = --nr_count[type];\n\t\t\t*(sensor_data->wmi.info[type] + idx) = temp_sensor;\n\t\t\tsensor_data->wmi.info_by_id[i] = temp_sensor;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"board has %d sensors\",\n\t\tsensor_data->wmi.sensor_count);\n\n\thwdev = devm_hwmon_device_register_with_info(dev, \"asus_wmi_sensors\",\n\t\t\t\t\t\t     sensor_data, chip_info, NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwdev);\n}\n\nstatic int asus_wmi_probe(struct wmi_device *wdev, const void *context)\n{\n\tstruct asus_wmi_sensors *sensor_data;\n\tstruct device *dev = &wdev->dev;\n\tu32 version = 0;\n\n\tif (!dmi_check_system(asus_wmi_dmi_table))\n\t\treturn -ENODEV;\n\n\tsensor_data = devm_kzalloc(dev, sizeof(*sensor_data), GFP_KERNEL);\n\tif (!sensor_data)\n\t\treturn -ENOMEM;\n\n\tif (asus_wmi_get_version(&version))\n\t\treturn -ENODEV;\n\n\tif (asus_wmi_get_item_count(&sensor_data->wmi.sensor_count))\n\t\treturn -ENODEV;\n\n\tif (sensor_data->wmi.sensor_count  <= 0 || version < 2) {\n\t\tdev_info(dev, \"version: %u with %d sensors is unsupported\\n\",\n\t\t\t version, sensor_data->wmi.sensor_count);\n\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_init(&sensor_data->lock);\n\n\tdev_set_drvdata(dev, sensor_data);\n\n\treturn asus_wmi_configure_sensor_setup(dev, sensor_data);\n}\n\nstatic const struct wmi_device_id asus_wmi_id_table[] = {\n\t{ ASUSWMI_MONITORING_GUID, NULL },\n\t{ }\n};\n\nstatic struct wmi_driver asus_sensors_wmi_driver = {\n\t.driver = {\n\t\t.name = \"asus_wmi_sensors\",\n\t},\n\t.id_table = asus_wmi_id_table,\n\t.probe = asus_wmi_probe,\n};\nmodule_wmi_driver(asus_sensors_wmi_driver);\n\nMODULE_AUTHOR(\"Ed Brindley <kernel@maidavale.org>\");\nMODULE_DESCRIPTION(\"Asus WMI Sensors Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}