{
  "module_name": "nct6775.h",
  "hash_id": "0c452d56e18319f21c3942f4f9fb6a026774cbe129112ff2e64ca160c6942af3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/nct6775.h",
  "human_readable_source": " \n#ifndef __HWMON_NCT6775_H__\n#define __HWMON_NCT6775_H__\n\n#include <linux/types.h>\n\nenum kinds { nct6106, nct6116, nct6775, nct6776, nct6779, nct6791, nct6792,\n\t     nct6793, nct6795, nct6796, nct6797, nct6798, nct6799 };\nenum pwm_enable { off, manual, thermal_cruise, speed_cruise, sf3, sf4 };\n\n#define NUM_TEMP\t12\t \n#define NUM_TEMP_FIXED\t6\t \n#define NUM_TSI_TEMP\t8\t \n\n#define NUM_REG_ALARM\t7\t \n#define NUM_REG_BEEP\t5\t \n\n#define NUM_FAN\t\t7\n#define NUM_IN\t\t18\n\nstruct nct6775_data {\n\tint addr;\t \n\tint sioreg;\t \n\tenum kinds kind;\n\tconst char *name;\n\n\tconst struct attribute_group *groups[7];\n\tu8 num_groups;\n\n\tu16 reg_temp[5][NUM_TEMP];  \n\tu8 temp_src[NUM_TEMP];\n\tu16 reg_temp_config[NUM_TEMP];\n\tconst char * const *temp_label;\n\tu32 temp_mask;\n\tu32 virt_temp_mask;\n\n\tu16 REG_CONFIG;\n\tu16 REG_VBAT;\n\tu16 REG_DIODE;\n\tu8 DIODE_MASK;\n\n\tconst s8 *ALARM_BITS;\n\tconst s8 *BEEP_BITS;\n\n\tconst u16 *REG_VIN;\n\tconst u16 *REG_IN_MINMAX[2];\n\n\tconst u16 *REG_TARGET;\n\tconst u16 *REG_FAN;\n\tconst u16 *REG_FAN_MODE;\n\tconst u16 *REG_FAN_MIN;\n\tconst u16 *REG_FAN_PULSES;\n\tconst u16 *FAN_PULSE_SHIFT;\n\tconst u16 *REG_FAN_TIME[3];\n\n\tconst u16 *REG_TOLERANCE_H;\n\n\tconst u8 *REG_PWM_MODE;\n\tconst u8 *PWM_MODE_MASK;\n\n\tconst u16 *REG_PWM[7];\t \n\tconst u16 *REG_PWM_READ;\n\n\tconst u16 *REG_CRITICAL_PWM_ENABLE;\n\tu8 CRITICAL_PWM_ENABLE_MASK;\n\tconst u16 *REG_CRITICAL_PWM;\n\n\tconst u16 *REG_AUTO_TEMP;\n\tconst u16 *REG_AUTO_PWM;\n\n\tconst u16 *REG_CRITICAL_TEMP;\n\tconst u16 *REG_CRITICAL_TEMP_TOLERANCE;\n\n\tconst u16 *REG_TEMP_SOURCE;\t \n\tconst u16 *REG_TEMP_SEL;\n\tconst u16 *REG_WEIGHT_TEMP_SEL;\n\tconst u16 *REG_WEIGHT_TEMP[3];\t \n\n\tconst u16 *REG_TEMP_OFFSET;\n\n\tconst u16 *REG_ALARM;\n\tconst u16 *REG_BEEP;\n\n\tconst u16 *REG_TSI_TEMP;\n\n\tunsigned int (*fan_from_reg)(u16 reg, unsigned int divreg);\n\tunsigned int (*fan_from_reg_min)(u16 reg, unsigned int divreg);\n\n\tstruct mutex update_lock;\n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\n\t \n\tu8 bank;\t\t \n\tu8 in_num;\t\t \n\tu8 in[NUM_IN][3];\t \n\tconst u16 *scale_in;\t \n\tunsigned int rpm[NUM_FAN];\n\tu16 fan_min[NUM_FAN];\n\tu8 fan_pulses[NUM_FAN];\n\tu8 fan_div[NUM_FAN];\n\tu8 has_pwm;\n\tu8 has_fan;\t\t \n\tu8 has_fan_min;\t\t \n\tbool has_fan_div;\n\n\tu8 num_temp_alarms;\t \n\tu8 num_temp_beeps;\t \n\tu8 temp_fixed_num;\t \n\tu8 temp_type[NUM_TEMP_FIXED];\n\ts8 temp_offset[NUM_TEMP_FIXED];\n\ts16 temp[5][NUM_TEMP];  \n\ts16 tsi_temp[NUM_TSI_TEMP];\n\tu64 alarms;\n\tu64 beeps;\n\n\tu8 pwm_num;\t \n\tu8 pwm_mode[NUM_FAN];\t \n\tenum pwm_enable pwm_enable[NUM_FAN];\n\t\t\t \n\tu8 pwm[7][NUM_FAN];\t \n\n\tu8 target_temp[NUM_FAN];\n\tu8 target_temp_mask;\n\tu32 target_speed[NUM_FAN];\n\tu32 target_speed_tolerance[NUM_FAN];\n\tu8 speed_tolerance_limit;\n\n\tu8 temp_tolerance[2][NUM_FAN];\n\tu8 tolerance_mask;\n\n\tu8 fan_time[3][NUM_FAN];  \n\n\t \n\tint auto_pwm_num;\n\tu8 auto_pwm[NUM_FAN][7];\n\tu8 auto_temp[NUM_FAN][7];\n\tu8 pwm_temp_sel[NUM_FAN];\n\tu8 pwm_weight_temp_sel[NUM_FAN];\n\tu8 weight_temp[3][NUM_FAN];\t \n\n\tu8 vid;\n\tu8 vrm;\n\n\tbool have_vid;\n\n\tu16 have_temp;\n\tu16 have_temp_fixed;\n\tu16 have_tsi_temp;\n\tu32 have_in;\n\n\t \n\tu8 vbat;\n\tu8 fandiv1;\n\tu8 fandiv2;\n\tu8 sio_reg_enable;\n\n\tstruct regmap *regmap;\n\tbool read_only;\n\n\t \n\tint (*driver_init)(struct nct6775_data *data);\n\tvoid *driver_data;\n};\n\nstatic inline int nct6775_read_value(struct nct6775_data *data, u16 reg, u16 *value)\n{\n\tunsigned int tmp;\n\tint ret = regmap_read(data->regmap, reg, &tmp);\n\n\tif (!ret)\n\t\t*value = tmp;\n\treturn ret;\n}\n\nstatic inline int nct6775_write_value(struct nct6775_data *data, u16 reg, u16 value)\n{\n\treturn regmap_write(data->regmap, reg, value);\n}\n\nstruct nct6775_data *nct6775_update_device(struct device *dev);\n\nbool nct6775_reg_is_word_sized(struct nct6775_data *data, u16 reg);\nint nct6775_probe(struct device *dev, struct nct6775_data *data,\n\t\t  const struct regmap_config *regmapcfg);\n\nssize_t nct6775_show_alarm(struct device *dev, struct device_attribute *attr, char *buf);\nssize_t nct6775_show_beep(struct device *dev, struct device_attribute *attr, char *buf);\nssize_t nct6775_store_beep(struct device *dev, struct device_attribute *attr, const char *buf,\n\t\t\t   size_t count);\n\nstatic inline int nct6775_write_temp(struct nct6775_data *data, u16 reg, u16 value)\n{\n\tif (!nct6775_reg_is_word_sized(data, reg))\n\t\tvalue >>= 8;\n\treturn nct6775_write_value(data, reg, value);\n}\n\nstatic inline umode_t nct6775_attr_mode(struct nct6775_data *data, struct attribute *attr)\n{\n\treturn data->read_only ? (attr->mode & ~0222) : attr->mode;\n}\n\nstatic inline int\nnct6775_add_attr_group(struct nct6775_data *data, const struct attribute_group *group)\n{\n\t \n\tif (data->num_groups == ARRAY_SIZE(data->groups) - 1)\n\t\treturn -ENOBUFS;\n\n\tdata->groups[data->num_groups++] = group;\n\treturn 0;\n}\n\n#define NCT6775_REG_BANK\t0x4E\n#define NCT6775_REG_CONFIG\t0x40\n\n#define NCT6775_REG_FANDIV1\t\t0x506\n#define NCT6775_REG_FANDIV2\t\t0x507\n\n#define NCT6791_REG_HM_IO_SPACE_LOCK_ENABLE\t0x28\n\n \n#define VIN_ALARM_BASE\t\t 0\n#define FAN_ALARM_BASE\t\t24\n#define TEMP_ALARM_BASE\t\t36\n#define INTRUSION_ALARM_BASE\t48\n#define BEEP_ENABLE_BASE\t50\n\n#define NUM_ALARM_BITS\t\t(INTRUSION_ALARM_BASE + 4)\n#define NUM_BEEP_BITS\t\t(BEEP_ENABLE_BASE + 1)\n\n \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}