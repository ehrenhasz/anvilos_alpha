{
  "module_name": "powr1220.c",
  "hash_id": "ef25e27d09752df593bab2106b188f7e99b409e90e7f031176ab32fbc767e56f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/powr1220.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n\n#define ADC_STEP_MV\t\t\t2\n#define ADC_MAX_LOW_MEASUREMENT_MV\t2000\n\nenum powr1xxx_chips { powr1014, powr1220 };\n\nenum powr1220_regs {\n\tVMON_STATUS0,\n\tVMON_STATUS1,\n\tVMON_STATUS2,\n\tOUTPUT_STATUS0,\n\tOUTPUT_STATUS1,\n\tOUTPUT_STATUS2,\n\tINPUT_STATUS,\n\tADC_VALUE_LOW,\n\tADC_VALUE_HIGH,\n\tADC_MUX,\n\tUES_BYTE0,\n\tUES_BYTE1,\n\tUES_BYTE2,\n\tUES_BYTE3,\n\tGP_OUTPUT1,\n\tGP_OUTPUT2,\n\tGP_OUTPUT3,\n\tINPUT_VALUE,\n\tRESET,\n\tTRIM1_TRIM,\n\tTRIM2_TRIM,\n\tTRIM3_TRIM,\n\tTRIM4_TRIM,\n\tTRIM5_TRIM,\n\tTRIM6_TRIM,\n\tTRIM7_TRIM,\n\tTRIM8_TRIM,\n\tMAX_POWR1220_REGS\n};\n\nenum powr1220_adc_values {\n\tVMON1,\n\tVMON2,\n\tVMON3,\n\tVMON4,\n\tVMON5,\n\tVMON6,\n\tVMON7,\n\tVMON8,\n\tVMON9,\n\tVMON10,\n\tVMON11,\n\tVMON12,\n\tVCCA,\n\tVCCINP,\n\tMAX_POWR1220_ADC_VALUES\n};\n\nstruct powr1220_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tu8 max_channels;\n\tbool adc_valid[MAX_POWR1220_ADC_VALUES];\n\t  \n\tunsigned long adc_last_updated[MAX_POWR1220_ADC_VALUES];\n\n\t \n\tint adc_maxes[MAX_POWR1220_ADC_VALUES];\n\tint adc_values[MAX_POWR1220_ADC_VALUES];\n};\n\nstatic const char * const input_names[] = {\n\t[VMON1]    = \"vmon1\",\n\t[VMON2]    = \"vmon2\",\n\t[VMON3]    = \"vmon3\",\n\t[VMON4]    = \"vmon4\",\n\t[VMON5]    = \"vmon5\",\n\t[VMON6]    = \"vmon6\",\n\t[VMON7]    = \"vmon7\",\n\t[VMON8]    = \"vmon8\",\n\t[VMON9]    = \"vmon9\",\n\t[VMON10]   = \"vmon10\",\n\t[VMON11]   = \"vmon11\",\n\t[VMON12]   = \"vmon12\",\n\t[VCCA]     = \"vcca\",\n\t[VCCINP]   = \"vccinp\",\n};\n\n \nstatic int powr1220_read_adc(struct device *dev, int ch_num)\n{\n\tstruct powr1220_data *data = dev_get_drvdata(dev);\n\tint reading;\n\tint result;\n\tint adc_range = 0;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->adc_last_updated[ch_num] + HZ) ||\n\t    !data->adc_valid[ch_num]) {\n\t\t \n\t\tif (data->adc_maxes[ch_num] > ADC_MAX_LOW_MEASUREMENT_MV ||\n\t\t    data->adc_maxes[ch_num] == 0)\n\t\t\tadc_range = 1 << 4;\n\n\t\t \n\t\tresult = i2c_smbus_write_byte_data(data->client, ADC_MUX,\n\t\t\t\t\t\t   adc_range | ch_num);\n\t\tif (result)\n\t\t\tgoto exit;\n\n\t\t \n\t\tudelay(200);\n\n\t\t \n\t\tresult = i2c_smbus_read_byte_data(data->client, ADC_VALUE_LOW);\n\t\tif (result < 0)\n\t\t\tgoto exit;\n\n\t\treading = result >> 4;\n\n\t\t \n\t\tresult = i2c_smbus_read_byte_data(data->client, ADC_VALUE_HIGH);\n\t\tif (result < 0)\n\t\t\tgoto exit;\n\n\t\treading |= result << 4;\n\n\t\t \n\t\treading *= ADC_STEP_MV;\n\t\tdata->adc_values[ch_num] = reading;\n\t\tdata->adc_valid[ch_num] = true;\n\t\tdata->adc_last_updated[ch_num] = jiffies;\n\t\tresult = reading;\n\n\t\tif (reading > data->adc_maxes[ch_num])\n\t\t\tdata->adc_maxes[ch_num] = reading;\n\t} else {\n\t\tresult = data->adc_values[ch_num];\n\t}\n\nexit:\n\tmutex_unlock(&data->update_lock);\n\n\treturn result;\n}\n\nstatic umode_t\npowr1220_is_visible(const void *data, enum hwmon_sensor_types type, u32\n\t\t    attr, int channel)\n{\n\tstruct powr1220_data *chip_data = (struct powr1220_data *)data;\n\n\tif (channel >= chip_data->max_channels)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\tcase hwmon_in_highest:\n\t\tcase hwmon_in_label:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\npowr1220_read_string(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t     int channel, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_label:\n\t\t\t*str = input_names[channel];\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\npowr1220_read(struct device *dev, enum hwmon_sensor_types type, u32\n\t      attr, int channel, long *val)\n{\n\tstruct powr1220_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\tret = powr1220_read_adc(dev, channel);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\tbreak;\n\t\tcase hwmon_in_highest:\n\t\t\t*val = data->adc_maxes[channel];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n}\n\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const powr1220_info[] = {\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_HIGHEST | HWMON_I_LABEL),\n\n\tNULL\n};\n\nstatic const struct hwmon_ops powr1220_hwmon_ops = {\n\t.read = powr1220_read,\n\t.read_string = powr1220_read_string,\n\t.is_visible = powr1220_is_visible,\n};\n\nstatic const struct hwmon_chip_info powr1220_chip_info = {\n\t.ops = &powr1220_hwmon_ops,\n\t.info = powr1220_info,\n};\n\nstatic const struct i2c_device_id powr1220_ids[];\n\nstatic int powr1220_probe(struct i2c_client *client)\n{\n\tstruct powr1220_data *data;\n\tstruct device *hwmon_dev;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tswitch (i2c_match_id(powr1220_ids, client)->driver_data) {\n\tcase powr1014:\n\t\tdata->max_channels = 10;\n\t\tbreak;\n\tdefault:\n\t\tdata->max_channels = 12;\n\t\tbreak;\n\t}\n\n\tmutex_init(&data->update_lock);\n\tdata->client = client;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&client->dev,\n\t\t\t\t\t\t\t client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &powr1220_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id powr1220_ids[] = {\n\t{ \"powr1014\", powr1014, },\n\t{ \"powr1220\", powr1220, },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, powr1220_ids);\n\nstatic struct i2c_driver powr1220_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"powr1220\",\n\t},\n\t.probe\t\t= powr1220_probe,\n\t.id_table\t= powr1220_ids,\n};\n\nmodule_i2c_driver(powr1220_driver);\n\nMODULE_AUTHOR(\"Scott Kanowitz\");\nMODULE_DESCRIPTION(\"POWR1220 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}