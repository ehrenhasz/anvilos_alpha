{
  "module_name": "ltc2992.c",
  "hash_id": "2c8bbbcfb4bc158ad784f4387d0ff02df920c76e1fd3e4d9e82b4ec9e009e5ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ltc2992.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n#define LTC2992_CTRLB\t\t\t0x01\n#define LTC2992_FAULT1\t\t\t0x03\n#define LTC2992_POWER1\t\t\t0x05\n#define LTC2992_POWER1_MAX\t\t0x08\n#define LTC2992_POWER1_MIN\t\t0x0B\n#define LTC2992_POWER1_MAX_THRESH\t0x0E\n#define LTC2992_POWER1_MIN_THRESH\t0x11\n#define LTC2992_DSENSE1\t\t\t0x14\n#define LTC2992_DSENSE1_MAX\t\t0x16\n#define LTC2992_DSENSE1_MIN\t\t0x18\n#define LTC2992_DSENSE1_MAX_THRESH\t0x1A\n#define LTC2992_DSENSE1_MIN_THRESH\t0x1C\n#define LTC2992_SENSE1\t\t\t0x1E\n#define LTC2992_SENSE1_MAX\t\t0x20\n#define LTC2992_SENSE1_MIN\t\t0x22\n#define LTC2992_SENSE1_MAX_THRESH\t0x24\n#define LTC2992_SENSE1_MIN_THRESH\t0x26\n#define LTC2992_G1\t\t\t0x28\n#define LTC2992_G1_MAX\t\t\t0x2A\n#define LTC2992_G1_MIN\t\t\t0x2C\n#define LTC2992_G1_MAX_THRESH\t\t0x2E\n#define LTC2992_G1_MIN_THRESH\t\t0x30\n#define LTC2992_FAULT2\t\t\t0x35\n#define LTC2992_G2\t\t\t0x5A\n#define LTC2992_G2_MAX\t\t\t0x5C\n#define LTC2992_G2_MIN\t\t\t0x5E\n#define LTC2992_G2_MAX_THRESH\t\t0x60\n#define LTC2992_G2_MIN_THRESH\t\t0x62\n#define LTC2992_G3\t\t\t0x64\n#define LTC2992_G3_MAX\t\t\t0x66\n#define LTC2992_G3_MIN\t\t\t0x68\n#define LTC2992_G3_MAX_THRESH\t\t0x6A\n#define LTC2992_G3_MIN_THRESH\t\t0x6C\n#define LTC2992_G4\t\t\t0x6E\n#define LTC2992_G4_MAX\t\t\t0x70\n#define LTC2992_G4_MIN\t\t\t0x72\n#define LTC2992_G4_MAX_THRESH\t\t0x74\n#define LTC2992_G4_MIN_THRESH\t\t0x76\n#define LTC2992_FAULT3\t\t\t0x92\n#define LTC2992_GPIO_STATUS\t\t0x95\n#define LTC2992_GPIO_IO_CTRL\t\t0x96\n#define LTC2992_GPIO_CTRL\t\t0x97\n\n#define LTC2992_POWER(x)\t\t(LTC2992_POWER1 + ((x) * 0x32))\n#define LTC2992_POWER_MAX(x)\t\t(LTC2992_POWER1_MAX + ((x) * 0x32))\n#define LTC2992_POWER_MIN(x)\t\t(LTC2992_POWER1_MIN + ((x) * 0x32))\n#define LTC2992_POWER_MAX_THRESH(x)\t(LTC2992_POWER1_MAX_THRESH + ((x) * 0x32))\n#define LTC2992_POWER_MIN_THRESH(x)\t(LTC2992_POWER1_MIN_THRESH + ((x) * 0x32))\n#define LTC2992_DSENSE(x)\t\t(LTC2992_DSENSE1 + ((x) * 0x32))\n#define LTC2992_DSENSE_MAX(x)\t\t(LTC2992_DSENSE1_MAX + ((x) * 0x32))\n#define LTC2992_DSENSE_MIN(x)\t\t(LTC2992_DSENSE1_MIN + ((x) * 0x32))\n#define LTC2992_DSENSE_MAX_THRESH(x)\t(LTC2992_DSENSE1_MAX_THRESH + ((x) * 0x32))\n#define LTC2992_DSENSE_MIN_THRESH(x)\t(LTC2992_DSENSE1_MIN_THRESH + ((x) * 0x32))\n#define LTC2992_SENSE(x)\t\t(LTC2992_SENSE1 + ((x) * 0x32))\n#define LTC2992_SENSE_MAX(x)\t\t(LTC2992_SENSE1_MAX + ((x) * 0x32))\n#define LTC2992_SENSE_MIN(x)\t\t(LTC2992_SENSE1_MIN + ((x) * 0x32))\n#define LTC2992_SENSE_MAX_THRESH(x)\t(LTC2992_SENSE1_MAX_THRESH + ((x) * 0x32))\n#define LTC2992_SENSE_MIN_THRESH(x)\t(LTC2992_SENSE1_MIN_THRESH + ((x) * 0x32))\n#define LTC2992_POWER_FAULT(x)\t\t(LTC2992_FAULT1 + ((x) * 0x32))\n#define LTC2992_SENSE_FAULT(x)\t\t(LTC2992_FAULT1 + ((x) * 0x32))\n#define LTC2992_DSENSE_FAULT(x)\t\t(LTC2992_FAULT1 + ((x) * 0x32))\n\n \n#define LTC2992_RESET_HISTORY\t\tBIT(3)\n\n \n#define LTC2992_POWER_FAULT_MSK(x)\t(BIT(6) << (x))\n#define LTC2992_DSENSE_FAULT_MSK(x)\t(BIT(4) << (x))\n#define LTC2992_SENSE_FAULT_MSK(x)\t(BIT(2) << (x))\n\n \n#define LTC2992_GPIO1_FAULT_MSK(x)\t(BIT(0) << (x))\n\n \n#define LTC2992_GPIO2_FAULT_MSK(x)\t(BIT(0) << (x))\n\n \n#define LTC2992_GPIO3_FAULT_MSK(x)\t(BIT(6) << (x))\n#define LTC2992_GPIO4_FAULT_MSK(x)\t(BIT(4) << (x))\n\n#define LTC2992_IADC_NANOV_LSB\t\t12500\n#define LTC2992_VADC_UV_LSB\t\t25000\n#define LTC2992_VADC_GPIO_UV_LSB\t500\n\n#define LTC2992_GPIO_NR\t\t4\n#define LTC2992_GPIO1_BIT\t7\n#define LTC2992_GPIO2_BIT\t6\n#define LTC2992_GPIO3_BIT\t0\n#define LTC2992_GPIO4_BIT\t6\n#define LTC2992_GPIO_BIT(x)\t(LTC2992_GPIO_NR - (x) - 1)\n\nstruct ltc2992_state {\n\tstruct i2c_client\t\t*client;\n\tstruct gpio_chip\t\tgc;\n\tstruct mutex\t\t\tgpio_mutex;  \n\tconst char\t\t\t*gpio_names[LTC2992_GPIO_NR];\n\tstruct regmap\t\t\t*regmap;\n\tu32\t\t\t\tr_sense_uohm[2];\n};\n\nstruct ltc2992_gpio_regs {\n\tu8\tdata;\n\tu8\tmax;\n\tu8\tmin;\n\tu8\tmax_thresh;\n\tu8\tmin_thresh;\n\tu8\talarm;\n\tu8\tmin_alarm_msk;\n\tu8\tmax_alarm_msk;\n\tu8\tctrl;\n\tu8\tctrl_bit;\n};\n\nstatic const struct ltc2992_gpio_regs ltc2992_gpio_addr_map[] = {\n\t{\n\t\t.data = LTC2992_G1,\n\t\t.max = LTC2992_G1_MAX,\n\t\t.min = LTC2992_G1_MIN,\n\t\t.max_thresh = LTC2992_G1_MAX_THRESH,\n\t\t.min_thresh = LTC2992_G1_MIN_THRESH,\n\t\t.alarm = LTC2992_FAULT1,\n\t\t.min_alarm_msk = LTC2992_GPIO1_FAULT_MSK(0),\n\t\t.max_alarm_msk = LTC2992_GPIO1_FAULT_MSK(1),\n\t\t.ctrl = LTC2992_GPIO_IO_CTRL,\n\t\t.ctrl_bit = LTC2992_GPIO1_BIT,\n\t},\n\t{\n\t\t.data = LTC2992_G2,\n\t\t.max = LTC2992_G2_MAX,\n\t\t.min = LTC2992_G2_MIN,\n\t\t.max_thresh = LTC2992_G2_MAX_THRESH,\n\t\t.min_thresh = LTC2992_G2_MIN_THRESH,\n\t\t.alarm = LTC2992_FAULT2,\n\t\t.min_alarm_msk = LTC2992_GPIO2_FAULT_MSK(0),\n\t\t.max_alarm_msk = LTC2992_GPIO2_FAULT_MSK(1),\n\t\t.ctrl = LTC2992_GPIO_IO_CTRL,\n\t\t.ctrl_bit = LTC2992_GPIO2_BIT,\n\t},\n\t{\n\t\t.data = LTC2992_G3,\n\t\t.max = LTC2992_G3_MAX,\n\t\t.min = LTC2992_G3_MIN,\n\t\t.max_thresh = LTC2992_G3_MAX_THRESH,\n\t\t.min_thresh = LTC2992_G3_MIN_THRESH,\n\t\t.alarm = LTC2992_FAULT3,\n\t\t.min_alarm_msk = LTC2992_GPIO3_FAULT_MSK(0),\n\t\t.max_alarm_msk = LTC2992_GPIO3_FAULT_MSK(1),\n\t\t.ctrl = LTC2992_GPIO_IO_CTRL,\n\t\t.ctrl_bit = LTC2992_GPIO3_BIT,\n\t},\n\t{\n\t\t.data = LTC2992_G4,\n\t\t.max = LTC2992_G4_MAX,\n\t\t.min = LTC2992_G4_MIN,\n\t\t.max_thresh = LTC2992_G4_MAX_THRESH,\n\t\t.min_thresh = LTC2992_G4_MIN_THRESH,\n\t\t.alarm = LTC2992_FAULT3,\n\t\t.min_alarm_msk = LTC2992_GPIO4_FAULT_MSK(0),\n\t\t.max_alarm_msk = LTC2992_GPIO4_FAULT_MSK(1),\n\t\t.ctrl = LTC2992_GPIO_CTRL,\n\t\t.ctrl_bit = LTC2992_GPIO4_BIT,\n\t},\n};\n\nstatic const char *ltc2992_gpio_names[LTC2992_GPIO_NR] = {\n\t\"GPIO1\", \"GPIO2\", \"GPIO3\", \"GPIO4\",\n};\n\nstatic int ltc2992_read_reg(struct ltc2992_state *st, u8 addr, const u8 reg_len)\n{\n\tu8 regvals[4];\n\tint val;\n\tint ret;\n\tint i;\n\n\tret = regmap_bulk_read(st->regmap, addr, regvals, reg_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = 0;\n\tfor (i = 0; i < reg_len; i++)\n\t\tval |= regvals[reg_len - i - 1] << (i * 8);\n\n\treturn val;\n}\n\nstatic int ltc2992_write_reg(struct ltc2992_state *st, u8 addr, const u8 reg_len, u32 val)\n{\n\tu8 regvals[4];\n\tint i;\n\n\tfor (i = 0; i < reg_len; i++)\n\t\tregvals[reg_len - i - 1] = (val >> (i * 8)) & 0xFF;\n\n\treturn regmap_bulk_write(st->regmap, addr, regvals, reg_len);\n}\n\nstatic int ltc2992_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct ltc2992_state *st = gpiochip_get_data(chip);\n\tunsigned long gpio_status;\n\tint reg;\n\n\tmutex_lock(&st->gpio_mutex);\n\treg = ltc2992_read_reg(st, LTC2992_GPIO_STATUS, 1);\n\tmutex_unlock(&st->gpio_mutex);\n\n\tif (reg < 0)\n\t\treturn reg;\n\n\tgpio_status = reg;\n\n\treturn !test_bit(LTC2992_GPIO_BIT(offset), &gpio_status);\n}\n\nstatic int ltc2992_gpio_get_multiple(struct gpio_chip *chip, unsigned long *mask,\n\t\t\t\t     unsigned long *bits)\n{\n\tstruct ltc2992_state *st = gpiochip_get_data(chip);\n\tunsigned long gpio_status;\n\tunsigned int gpio_nr;\n\tint reg;\n\n\tmutex_lock(&st->gpio_mutex);\n\treg = ltc2992_read_reg(st, LTC2992_GPIO_STATUS, 1);\n\tmutex_unlock(&st->gpio_mutex);\n\n\tif (reg < 0)\n\t\treturn reg;\n\n\tgpio_status = reg;\n\n\tfor_each_set_bit(gpio_nr, mask, LTC2992_GPIO_NR) {\n\t\tif (test_bit(LTC2992_GPIO_BIT(gpio_nr), &gpio_status))\n\t\t\tset_bit(gpio_nr, bits);\n\t}\n\n\treturn 0;\n}\n\nstatic void ltc2992_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct ltc2992_state *st = gpiochip_get_data(chip);\n\tunsigned long gpio_ctrl;\n\tint reg;\n\n\tmutex_lock(&st->gpio_mutex);\n\treg = ltc2992_read_reg(st, ltc2992_gpio_addr_map[offset].ctrl, 1);\n\tif (reg < 0) {\n\t\tmutex_unlock(&st->gpio_mutex);\n\t\treturn;\n\t}\n\n\tgpio_ctrl = reg;\n\tassign_bit(ltc2992_gpio_addr_map[offset].ctrl_bit, &gpio_ctrl, value);\n\n\tltc2992_write_reg(st, ltc2992_gpio_addr_map[offset].ctrl, 1, gpio_ctrl);\n\tmutex_unlock(&st->gpio_mutex);\n}\n\nstatic void ltc2992_gpio_set_multiple(struct gpio_chip *chip, unsigned long *mask,\n\t\t\t\t      unsigned long *bits)\n{\n\tstruct ltc2992_state *st = gpiochip_get_data(chip);\n\tunsigned long gpio_ctrl_io = 0;\n\tunsigned long gpio_ctrl = 0;\n\tunsigned int gpio_nr;\n\n\tfor_each_set_bit(gpio_nr, mask, LTC2992_GPIO_NR) {\n\t\tif (gpio_nr < 3)\n\t\t\tassign_bit(ltc2992_gpio_addr_map[gpio_nr].ctrl_bit, &gpio_ctrl_io, true);\n\n\t\tif (gpio_nr == 3)\n\t\t\tassign_bit(ltc2992_gpio_addr_map[gpio_nr].ctrl_bit, &gpio_ctrl, true);\n\t}\n\n\tmutex_lock(&st->gpio_mutex);\n\tltc2992_write_reg(st, LTC2992_GPIO_IO_CTRL, 1, gpio_ctrl_io);\n\tltc2992_write_reg(st, LTC2992_GPIO_CTRL, 1, gpio_ctrl);\n\tmutex_unlock(&st->gpio_mutex);\n}\n\nstatic int ltc2992_config_gpio(struct ltc2992_state *st)\n{\n\tconst char *name = dev_name(&st->client->dev);\n\tchar *gpio_name;\n\tint ret;\n\tint i;\n\n\tret = ltc2992_write_reg(st, LTC2992_GPIO_IO_CTRL, 1, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_init(&st->gpio_mutex);\n\n\tfor (i = 0; i < ARRAY_SIZE(st->gpio_names); i++) {\n\t\tgpio_name = devm_kasprintf(&st->client->dev, GFP_KERNEL, \"ltc2992-%x-%s\",\n\t\t\t\t\t   st->client->addr, ltc2992_gpio_names[i]);\n\t\tif (!gpio_name)\n\t\t\treturn -ENOMEM;\n\n\t\tst->gpio_names[i] = gpio_name;\n\t}\n\n\tst->gc.label = name;\n\tst->gc.parent = &st->client->dev;\n\tst->gc.owner = THIS_MODULE;\n\tst->gc.can_sleep = true;\n\tst->gc.base = -1;\n\tst->gc.names = st->gpio_names;\n\tst->gc.ngpio = ARRAY_SIZE(st->gpio_names);\n\tst->gc.get = ltc2992_gpio_get;\n\tst->gc.get_multiple = ltc2992_gpio_get_multiple;\n\tst->gc.set = ltc2992_gpio_set;\n\tst->gc.set_multiple = ltc2992_gpio_set_multiple;\n\n\tret = devm_gpiochip_add_data(&st->client->dev, &st->gc, st);\n\tif (ret)\n\t\tdev_err(&st->client->dev, \"GPIO registering failed (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic umode_t ltc2992_is_visible(const void *data, enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t  int channel)\n{\n\tconst struct ltc2992_state *st = data;\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_in_reset_history:\n\t\t\treturn 0200;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\tcase hwmon_in_lowest:\n\t\tcase hwmon_in_highest:\n\t\tcase hwmon_in_min_alarm:\n\t\tcase hwmon_in_max_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_in_min:\n\t\tcase hwmon_in_max:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_input:\n\t\tcase hwmon_curr_lowest:\n\t\tcase hwmon_curr_highest:\n\t\tcase hwmon_curr_min_alarm:\n\t\tcase hwmon_curr_max_alarm:\n\t\t\tif (st->r_sense_uohm[channel])\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase hwmon_curr_min:\n\t\tcase hwmon_curr_max:\n\t\t\tif (st->r_sense_uohm[channel])\n\t\t\t\treturn 0644;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_power:\n\t\tswitch (attr) {\n\t\tcase hwmon_power_input:\n\t\tcase hwmon_power_input_lowest:\n\t\tcase hwmon_power_input_highest:\n\t\tcase hwmon_power_min_alarm:\n\t\tcase hwmon_power_max_alarm:\n\t\t\tif (st->r_sense_uohm[channel])\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase hwmon_power_min:\n\t\tcase hwmon_power_max:\n\t\t\tif (st->r_sense_uohm[channel])\n\t\t\t\treturn 0644;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ltc2992_get_voltage(struct ltc2992_state *st, u32 reg, u32 scale, long *val)\n{\n\tint reg_val;\n\n\treg_val = ltc2992_read_reg(st, reg, 2);\n\tif (reg_val < 0)\n\t\treturn reg_val;\n\n\treg_val = reg_val >> 4;\n\t*val = DIV_ROUND_CLOSEST(reg_val * scale, 1000);\n\n\treturn 0;\n}\n\nstatic int ltc2992_set_voltage(struct ltc2992_state *st, u32 reg, u32 scale, long val)\n{\n\tval = DIV_ROUND_CLOSEST(val * 1000, scale);\n\tval = val << 4;\n\n\treturn ltc2992_write_reg(st, reg, 2, val);\n}\n\nstatic int ltc2992_read_gpio_alarm(struct ltc2992_state *st, int nr_gpio, u32 attr, long *val)\n{\n\tint reg_val;\n\tu32 mask;\n\n\tif (attr == hwmon_in_max_alarm)\n\t\tmask = ltc2992_gpio_addr_map[nr_gpio].max_alarm_msk;\n\telse\n\t\tmask = ltc2992_gpio_addr_map[nr_gpio].min_alarm_msk;\n\n\treg_val = ltc2992_read_reg(st, ltc2992_gpio_addr_map[nr_gpio].alarm, 1);\n\tif (reg_val < 0)\n\t\treturn reg_val;\n\n\t*val = !!(reg_val & mask);\n\treg_val &= ~mask;\n\n\treturn ltc2992_write_reg(st, ltc2992_gpio_addr_map[nr_gpio].alarm, 1, reg_val);\n}\n\nstatic int ltc2992_read_gpios_in(struct device *dev, u32 attr, int nr_gpio, long *val)\n{\n\tstruct ltc2992_state *st = dev_get_drvdata(dev);\n\tu32 reg;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\treg = ltc2992_gpio_addr_map[nr_gpio].data;\n\t\tbreak;\n\tcase hwmon_in_lowest:\n\t\treg = ltc2992_gpio_addr_map[nr_gpio].min;\n\t\tbreak;\n\tcase hwmon_in_highest:\n\t\treg = ltc2992_gpio_addr_map[nr_gpio].max;\n\t\tbreak;\n\tcase hwmon_in_min:\n\t\treg = ltc2992_gpio_addr_map[nr_gpio].min_thresh;\n\t\tbreak;\n\tcase hwmon_in_max:\n\t\treg = ltc2992_gpio_addr_map[nr_gpio].max_thresh;\n\t\tbreak;\n\tcase hwmon_in_min_alarm:\n\tcase hwmon_in_max_alarm:\n\t\treturn ltc2992_read_gpio_alarm(st, nr_gpio, attr, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ltc2992_get_voltage(st, reg, LTC2992_VADC_GPIO_UV_LSB, val);\n}\n\nstatic int ltc2992_read_in_alarm(struct ltc2992_state *st, int channel, long *val, u32 attr)\n{\n\tint reg_val;\n\tu32 mask;\n\n\tif (attr == hwmon_in_max_alarm)\n\t\tmask = LTC2992_SENSE_FAULT_MSK(1);\n\telse\n\t\tmask = LTC2992_SENSE_FAULT_MSK(0);\n\n\treg_val = ltc2992_read_reg(st, LTC2992_SENSE_FAULT(channel), 1);\n\tif (reg_val < 0)\n\t\treturn reg_val;\n\n\t*val = !!(reg_val & mask);\n\treg_val &= ~mask;\n\n\treturn ltc2992_write_reg(st, LTC2992_SENSE_FAULT(channel), 1, reg_val);\n}\n\nstatic int ltc2992_read_in(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct ltc2992_state *st = dev_get_drvdata(dev);\n\tu32 reg;\n\n\tif (channel > 1)\n\t\treturn ltc2992_read_gpios_in(dev, attr, channel - 2, val);\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\treg = LTC2992_SENSE(channel);\n\t\tbreak;\n\tcase hwmon_in_lowest:\n\t\treg = LTC2992_SENSE_MIN(channel);\n\t\tbreak;\n\tcase hwmon_in_highest:\n\t\treg = LTC2992_SENSE_MAX(channel);\n\t\tbreak;\n\tcase hwmon_in_min:\n\t\treg = LTC2992_SENSE_MIN_THRESH(channel);\n\t\tbreak;\n\tcase hwmon_in_max:\n\t\treg = LTC2992_SENSE_MAX_THRESH(channel);\n\t\tbreak;\n\tcase hwmon_in_min_alarm:\n\tcase hwmon_in_max_alarm:\n\t\treturn ltc2992_read_in_alarm(st, channel, val, attr);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ltc2992_get_voltage(st, reg, LTC2992_VADC_UV_LSB, val);\n}\n\nstatic int ltc2992_get_current(struct ltc2992_state *st, u32 reg, u32 channel, long *val)\n{\n\tint reg_val;\n\n\treg_val = ltc2992_read_reg(st, reg, 2);\n\tif (reg_val < 0)\n\t\treturn reg_val;\n\n\treg_val = reg_val >> 4;\n\t*val = DIV_ROUND_CLOSEST(reg_val * LTC2992_IADC_NANOV_LSB, st->r_sense_uohm[channel]);\n\n\treturn 0;\n}\n\nstatic int ltc2992_set_current(struct ltc2992_state *st, u32 reg, u32 channel, long val)\n{\n\tu32 reg_val;\n\n\treg_val = DIV_ROUND_CLOSEST(val * st->r_sense_uohm[channel], LTC2992_IADC_NANOV_LSB);\n\treg_val = reg_val << 4;\n\n\treturn ltc2992_write_reg(st, reg, 2, reg_val);\n}\n\nstatic int ltc2992_read_curr_alarm(struct ltc2992_state *st, int channel, long *val, u32 attr)\n{\n\tint reg_val;\n\tu32 mask;\n\n\tif (attr == hwmon_curr_max_alarm)\n\t\tmask = LTC2992_DSENSE_FAULT_MSK(1);\n\telse\n\t\tmask = LTC2992_DSENSE_FAULT_MSK(0);\n\n\treg_val = ltc2992_read_reg(st, LTC2992_DSENSE_FAULT(channel), 1);\n\tif (reg_val < 0)\n\t\treturn reg_val;\n\n\t*val = !!(reg_val & mask);\n\n\treg_val &= ~mask;\n\treturn ltc2992_write_reg(st, LTC2992_DSENSE_FAULT(channel), 1, reg_val);\n}\n\nstatic int ltc2992_read_curr(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct ltc2992_state *st = dev_get_drvdata(dev);\n\tu32 reg;\n\n\tswitch (attr) {\n\tcase hwmon_curr_input:\n\t\treg = LTC2992_DSENSE(channel);\n\t\tbreak;\n\tcase hwmon_curr_lowest:\n\t\treg = LTC2992_DSENSE_MIN(channel);\n\t\tbreak;\n\tcase hwmon_curr_highest:\n\t\treg = LTC2992_DSENSE_MAX(channel);\n\t\tbreak;\n\tcase hwmon_curr_min:\n\t\treg = LTC2992_DSENSE_MIN_THRESH(channel);\n\t\tbreak;\n\tcase hwmon_curr_max:\n\t\treg = LTC2992_DSENSE_MAX_THRESH(channel);\n\t\tbreak;\n\tcase hwmon_curr_min_alarm:\n\tcase hwmon_curr_max_alarm:\n\t\treturn ltc2992_read_curr_alarm(st, channel, val, attr);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ltc2992_get_current(st, reg, channel, val);\n}\n\nstatic int ltc2992_get_power(struct ltc2992_state *st, u32 reg, u32 channel, long *val)\n{\n\tint reg_val;\n\n\treg_val = ltc2992_read_reg(st, reg, 3);\n\tif (reg_val < 0)\n\t\treturn reg_val;\n\n\t*val = mul_u64_u32_div(reg_val, LTC2992_VADC_UV_LSB * LTC2992_IADC_NANOV_LSB,\n\t\t\t       st->r_sense_uohm[channel] * 1000);\n\n\treturn 0;\n}\n\nstatic int ltc2992_set_power(struct ltc2992_state *st, u32 reg, u32 channel, long val)\n{\n\tu32 reg_val;\n\n\treg_val = mul_u64_u32_div(val, st->r_sense_uohm[channel] * 1000,\n\t\t\t\t  LTC2992_VADC_UV_LSB * LTC2992_IADC_NANOV_LSB);\n\n\treturn ltc2992_write_reg(st, reg, 3, reg_val);\n}\n\nstatic int ltc2992_read_power_alarm(struct ltc2992_state *st, int channel, long *val, u32 attr)\n{\n\tint reg_val;\n\tu32 mask;\n\n\tif (attr == hwmon_power_max_alarm)\n\t\tmask = LTC2992_POWER_FAULT_MSK(1);\n\telse\n\t\tmask = LTC2992_POWER_FAULT_MSK(0);\n\n\treg_val = ltc2992_read_reg(st, LTC2992_POWER_FAULT(channel), 1);\n\tif (reg_val < 0)\n\t\treturn reg_val;\n\n\t*val = !!(reg_val & mask);\n\treg_val &= ~mask;\n\n\treturn ltc2992_write_reg(st, LTC2992_POWER_FAULT(channel), 1, reg_val);\n}\n\nstatic int ltc2992_read_power(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct ltc2992_state *st = dev_get_drvdata(dev);\n\tu32 reg;\n\n\tswitch (attr) {\n\tcase hwmon_power_input:\n\t\treg = LTC2992_POWER(channel);\n\t\tbreak;\n\tcase hwmon_power_input_lowest:\n\t\treg = LTC2992_POWER_MIN(channel);\n\t\tbreak;\n\tcase hwmon_power_input_highest:\n\t\treg = LTC2992_POWER_MAX(channel);\n\t\tbreak;\n\tcase hwmon_power_min:\n\t\treg = LTC2992_POWER_MIN_THRESH(channel);\n\t\tbreak;\n\tcase hwmon_power_max:\n\t\treg = LTC2992_POWER_MAX_THRESH(channel);\n\t\tbreak;\n\tcase hwmon_power_min_alarm:\n\tcase hwmon_power_max_alarm:\n\t\treturn ltc2992_read_power_alarm(st, channel, val, attr);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ltc2992_get_power(st, reg, channel, val);\n}\n\nstatic int ltc2992_read(struct device *dev, enum hwmon_sensor_types type, u32 attr, int channel,\n\t\t\tlong *val)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\treturn ltc2992_read_in(dev, attr, channel, val);\n\tcase hwmon_curr:\n\t\treturn ltc2992_read_curr(dev, attr, channel, val);\n\tcase hwmon_power:\n\t\treturn ltc2992_read_power(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ltc2992_write_curr(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct ltc2992_state *st = dev_get_drvdata(dev);\n\tu32 reg;\n\n\tswitch (attr) {\n\tcase hwmon_curr_min:\n\t\treg = LTC2992_DSENSE_MIN_THRESH(channel);\n\t\tbreak;\n\tcase hwmon_curr_max:\n\t\treg = LTC2992_DSENSE_MAX_THRESH(channel);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ltc2992_set_current(st, reg, channel, val);\n}\n\nstatic int ltc2992_write_gpios_in(struct device *dev, u32 attr, int nr_gpio, long val)\n{\n\tstruct ltc2992_state *st = dev_get_drvdata(dev);\n\tu32 reg;\n\n\tswitch (attr) {\n\tcase hwmon_in_min:\n\t\treg = ltc2992_gpio_addr_map[nr_gpio].min_thresh;\n\t\tbreak;\n\tcase hwmon_in_max:\n\t\treg = ltc2992_gpio_addr_map[nr_gpio].max_thresh;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ltc2992_set_voltage(st, reg, LTC2992_VADC_GPIO_UV_LSB, val);\n}\n\nstatic int ltc2992_write_in(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct ltc2992_state *st = dev_get_drvdata(dev);\n\tu32 reg;\n\n\tif (channel > 1)\n\t\treturn ltc2992_write_gpios_in(dev, attr, channel - 2, val);\n\n\tswitch (attr) {\n\tcase hwmon_in_min:\n\t\treg = LTC2992_SENSE_MIN_THRESH(channel);\n\t\tbreak;\n\tcase hwmon_in_max:\n\t\treg = LTC2992_SENSE_MAX_THRESH(channel);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ltc2992_set_voltage(st, reg, LTC2992_VADC_UV_LSB, val);\n}\n\nstatic int ltc2992_write_power(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct ltc2992_state *st = dev_get_drvdata(dev);\n\tu32 reg;\n\n\tswitch (attr) {\n\tcase hwmon_power_min:\n\t\treg = LTC2992_POWER_MIN_THRESH(channel);\n\t\tbreak;\n\tcase hwmon_power_max:\n\t\treg = LTC2992_POWER_MAX_THRESH(channel);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ltc2992_set_power(st, reg, channel, val);\n}\n\nstatic int ltc2992_write_chip(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct ltc2992_state *st = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_chip_in_reset_history:\n\t\treturn regmap_update_bits(st->regmap, LTC2992_CTRLB, LTC2992_RESET_HISTORY,\n\t\t\t\t\t  LTC2992_RESET_HISTORY);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ltc2992_write(struct device *dev, enum hwmon_sensor_types type, u32 attr, int channel,\n\t\t\t long val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn ltc2992_write_chip(dev, attr, channel, val);\n\tcase hwmon_in:\n\t\treturn ltc2992_write_in(dev, attr, channel, val);\n\tcase hwmon_curr:\n\t\treturn ltc2992_write_curr(dev, attr, channel, val);\n\tcase hwmon_power:\n\t\treturn ltc2992_write_power(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_ops ltc2992_hwmon_ops = {\n\t.is_visible = ltc2992_is_visible,\n\t.read = ltc2992_read,\n\t.write = ltc2992_write,\n};\n\nstatic const struct hwmon_channel_info * const ltc2992_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_IN_RESET_HISTORY),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LOWEST | HWMON_I_HIGHEST | HWMON_I_MIN |\n\t\t\t   HWMON_I_MAX | HWMON_I_MIN_ALARM | HWMON_I_MAX_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LOWEST | HWMON_I_HIGHEST | HWMON_I_MIN |\n\t\t\t   HWMON_I_MAX | HWMON_I_MIN_ALARM | HWMON_I_MAX_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LOWEST | HWMON_I_HIGHEST | HWMON_I_MIN |\n\t\t\t   HWMON_I_MAX | HWMON_I_MIN_ALARM | HWMON_I_MAX_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LOWEST | HWMON_I_HIGHEST | HWMON_I_MIN |\n\t\t\t   HWMON_I_MAX | HWMON_I_MIN_ALARM | HWMON_I_MAX_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LOWEST | HWMON_I_HIGHEST | HWMON_I_MIN |\n\t\t\t   HWMON_I_MAX | HWMON_I_MIN_ALARM | HWMON_I_MAX_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LOWEST | HWMON_I_HIGHEST | HWMON_I_MIN |\n\t\t\t   HWMON_I_MAX | HWMON_I_MIN_ALARM | HWMON_I_MAX_ALARM),\n\tHWMON_CHANNEL_INFO(curr,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LOWEST | HWMON_C_HIGHEST | HWMON_C_MIN |\n\t\t\t   HWMON_C_MAX | HWMON_C_MIN_ALARM | HWMON_C_MAX_ALARM,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LOWEST | HWMON_C_HIGHEST | HWMON_C_MIN |\n\t\t\t   HWMON_C_MAX | HWMON_C_MIN_ALARM | HWMON_C_MAX_ALARM),\n\tHWMON_CHANNEL_INFO(power,\n\t\t\t   HWMON_P_INPUT | HWMON_P_INPUT_LOWEST | HWMON_P_INPUT_HIGHEST |\n\t\t\t   HWMON_P_MIN | HWMON_P_MAX | HWMON_P_MIN_ALARM | HWMON_P_MAX_ALARM,\n\t\t\t   HWMON_P_INPUT | HWMON_P_INPUT_LOWEST | HWMON_P_INPUT_HIGHEST |\n\t\t\t   HWMON_P_MIN | HWMON_P_MAX | HWMON_P_MIN_ALARM | HWMON_P_MAX_ALARM),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info ltc2992_chip_info = {\n\t.ops = &ltc2992_hwmon_ops,\n\t.info = ltc2992_info,\n};\n\nstatic const struct regmap_config ltc2992_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xE8,\n};\n\nstatic int ltc2992_parse_dt(struct ltc2992_state *st)\n{\n\tstruct fwnode_handle *fwnode;\n\tstruct fwnode_handle *child;\n\tu32 addr;\n\tu32 val;\n\tint ret;\n\n\tfwnode = dev_fwnode(&st->client->dev);\n\n\tfwnode_for_each_available_child_node(fwnode, child) {\n\t\tret = fwnode_property_read_u32(child, \"reg\", &addr);\n\t\tif (ret < 0) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (addr > 1) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = fwnode_property_read_u32(child, \"shunt-resistor-micro-ohms\", &val);\n\t\tif (!ret)\n\t\t\tst->r_sense_uohm[addr] = val;\n\t}\n\n\treturn 0;\n}\n\nstatic int ltc2992_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *hwmon_dev;\n\tstruct ltc2992_state *st;\n\tint ret;\n\n\tst = devm_kzalloc(&client->dev, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->client = client;\n\tst->regmap = devm_regmap_init_i2c(client, &ltc2992_regmap_config);\n\tif (IS_ERR(st->regmap))\n\t\treturn PTR_ERR(st->regmap);\n\n\tret = ltc2992_parse_dt(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ltc2992_config_gpio(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&client->dev, client->name, st,\n\t\t\t\t\t\t\t &ltc2992_chip_info, NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct of_device_id ltc2992_of_match[] = {\n\t{ .compatible = \"adi,ltc2992\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ltc2992_of_match);\n\nstatic const struct i2c_device_id ltc2992_i2c_id[] = {\n\t{\"ltc2992\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ltc2992_i2c_id);\n\nstatic struct i2c_driver ltc2992_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ltc2992\",\n\t\t.of_match_table = ltc2992_of_match,\n\t},\n\t.probe = ltc2992_i2c_probe,\n\t.id_table = ltc2992_i2c_id,\n};\n\nmodule_i2c_driver(ltc2992_i2c_driver);\n\nMODULE_AUTHOR(\"Alexandru Tachici <alexandru.tachici@analog.com>\");\nMODULE_DESCRIPTION(\"Hwmon driver for Linear Technology 2992\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}