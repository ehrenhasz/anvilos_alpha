{
  "module_name": "tmp102.c",
  "hash_id": "cc66990d83f94b5a8ef3000260cbc25bf1bcb5a521fdd761d23e06a277b1292a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/tmp102.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/jiffies.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n\n#define\tDRIVER_NAME \"tmp102\"\n\n#define\tTMP102_TEMP_REG\t\t\t0x00\n#define\tTMP102_CONF_REG\t\t\t0x01\n \n#define\t\tTMP102_CONF_SD\t\t0x0100\n#define\t\tTMP102_CONF_TM\t\t0x0200\n#define\t\tTMP102_CONF_POL\t\t0x0400\n#define\t\tTMP102_CONF_F0\t\t0x0800\n#define\t\tTMP102_CONF_F1\t\t0x1000\n#define\t\tTMP102_CONF_R0\t\t0x2000\n#define\t\tTMP102_CONF_R1\t\t0x4000\n#define\t\tTMP102_CONF_OS\t\t0x8000\n#define\t\tTMP102_CONF_EM\t\t0x0010\n#define\t\tTMP102_CONF_AL\t\t0x0020\n#define\t\tTMP102_CONF_CR0\t\t0x0040\n#define\t\tTMP102_CONF_CR1\t\t0x0080\n#define\tTMP102_TLOW_REG\t\t\t0x02\n#define\tTMP102_THIGH_REG\t\t0x03\n\n#define TMP102_CONFREG_MASK\t(TMP102_CONF_SD | TMP102_CONF_TM | \\\n\t\t\t\t TMP102_CONF_POL | TMP102_CONF_F0 | \\\n\t\t\t\t TMP102_CONF_F1 | TMP102_CONF_OS | \\\n\t\t\t\t TMP102_CONF_EM | TMP102_CONF_AL | \\\n\t\t\t\t TMP102_CONF_CR0 | TMP102_CONF_CR1)\n\n#define TMP102_CONFIG_CLEAR\t(TMP102_CONF_SD | TMP102_CONF_OS | \\\n\t\t\t\t TMP102_CONF_CR0)\n#define TMP102_CONFIG_SET\t(TMP102_CONF_TM | TMP102_CONF_EM | \\\n\t\t\t\t TMP102_CONF_CR1)\n\n#define CONVERSION_TIME_MS\t\t35\t \n\nstruct tmp102 {\n\tstruct regmap *regmap;\n\tu16 config_orig;\n\tunsigned long ready_time;\n};\n\n \nstatic inline int tmp102_reg_to_mC(s16 val)\n{\n\treturn ((val & ~0x01) * 1000) / 128;\n}\n\n \nstatic inline u16 tmp102_mC_to_reg(int val)\n{\n\treturn (val * 128) / 1000;\n}\n\nstatic int tmp102_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long *temp)\n{\n\tstruct tmp102 *tmp102 = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err, reg;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\t \n\t\tif (time_before(jiffies, tmp102->ready_time)) {\n\t\t\tdev_dbg(dev, \"%s: Conversion not ready yet..\\n\", __func__);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\treg = TMP102_TEMP_REG;\n\t\tbreak;\n\tcase hwmon_temp_max_hyst:\n\t\treg = TMP102_TLOW_REG;\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\treg = TMP102_THIGH_REG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = regmap_read(tmp102->regmap, reg, &regval);\n\tif (err < 0)\n\t\treturn err;\n\t*temp = tmp102_reg_to_mC(regval);\n\n\treturn 0;\n}\n\nstatic int tmp102_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long temp)\n{\n\tstruct tmp102 *tmp102 = dev_get_drvdata(dev);\n\tint reg;\n\n\tswitch (attr) {\n\tcase hwmon_temp_max_hyst:\n\t\treg = TMP102_TLOW_REG;\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\treg = TMP102_THIGH_REG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\ttemp = clamp_val(temp, -256000, 255000);\n\treturn regmap_write(tmp102->regmap, reg, tmp102_mC_to_reg(temp));\n}\n\nstatic umode_t tmp102_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel)\n{\n\tif (type != hwmon_temp)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treturn 0444;\n\tcase hwmon_temp_max_hyst:\n\tcase hwmon_temp_max:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const tmp102_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST),\n\tNULL\n};\n\nstatic const struct hwmon_ops tmp102_hwmon_ops = {\n\t.is_visible = tmp102_is_visible,\n\t.read = tmp102_read,\n\t.write = tmp102_write,\n};\n\nstatic const struct hwmon_chip_info tmp102_chip_info = {\n\t.ops = &tmp102_hwmon_ops,\n\t.info = tmp102_info,\n};\n\nstatic void tmp102_restore_config(void *data)\n{\n\tstruct tmp102 *tmp102 = data;\n\n\tregmap_write(tmp102->regmap, TMP102_CONF_REG, tmp102->config_orig);\n}\n\nstatic bool tmp102_is_writeable_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg != TMP102_TEMP_REG;\n}\n\nstatic bool tmp102_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg == TMP102_TEMP_REG;\n}\n\nstatic const struct regmap_config tmp102_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = TMP102_THIGH_REG,\n\t.writeable_reg = tmp102_is_writeable_reg,\n\t.volatile_reg = tmp102_is_volatile_reg,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int tmp102_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct tmp102 *tmp102;\n\tunsigned int regval;\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA)) {\n\t\tdev_err(dev,\n\t\t\t\"adapter doesn't support SMBus word transactions\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttmp102 = devm_kzalloc(dev, sizeof(*tmp102), GFP_KERNEL);\n\tif (!tmp102)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, tmp102);\n\n\ttmp102->regmap = devm_regmap_init_i2c(client, &tmp102_regmap_config);\n\tif (IS_ERR(tmp102->regmap))\n\t\treturn PTR_ERR(tmp102->regmap);\n\n\terr = regmap_read(tmp102->regmap, TMP102_CONF_REG, &regval);\n\tif (err < 0) {\n\t\tdev_err(dev, \"error reading config register\\n\");\n\t\treturn err;\n\t}\n\n\tif ((regval & ~TMP102_CONFREG_MASK) !=\n\t    (TMP102_CONF_R0 | TMP102_CONF_R1)) {\n\t\tdev_err(dev, \"unexpected config register value\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttmp102->config_orig = regval;\n\n\terr = devm_add_action_or_reset(dev, tmp102_restore_config, tmp102);\n\tif (err)\n\t\treturn err;\n\n\tregval &= ~TMP102_CONFIG_CLEAR;\n\tregval |= TMP102_CONFIG_SET;\n\n\terr = regmap_write(tmp102->regmap, TMP102_CONF_REG, regval);\n\tif (err < 0) {\n\t\tdev_err(dev, \"error writing config register\\n\");\n\t\treturn err;\n\t}\n\n\t \n\ttmp102->ready_time = jiffies + msecs_to_jiffies(CONVERSION_TIME_MS);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t tmp102,\n\t\t\t\t\t\t\t &tmp102_chip_info,\n\t\t\t\t\t\t\t NULL);\n\tif (IS_ERR(hwmon_dev)) {\n\t\tdev_dbg(dev, \"unable to register hwmon device\\n\");\n\t\treturn PTR_ERR(hwmon_dev);\n\t}\n\tdev_info(dev, \"initialized\\n\");\n\n\treturn 0;\n}\n\nstatic int tmp102_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct tmp102 *tmp102 = i2c_get_clientdata(client);\n\n\treturn regmap_update_bits(tmp102->regmap, TMP102_CONF_REG,\n\t\t\t\t  TMP102_CONF_SD, TMP102_CONF_SD);\n}\n\nstatic int tmp102_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct tmp102 *tmp102 = i2c_get_clientdata(client);\n\tint err;\n\n\terr = regmap_update_bits(tmp102->regmap, TMP102_CONF_REG,\n\t\t\t\t TMP102_CONF_SD, 0);\n\n\ttmp102->ready_time = jiffies + msecs_to_jiffies(CONVERSION_TIME_MS);\n\n\treturn err;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tmp102_dev_pm_ops, tmp102_suspend, tmp102_resume);\n\nstatic const struct i2c_device_id tmp102_id[] = {\n\t{ \"tmp102\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tmp102_id);\n\nstatic const struct of_device_id __maybe_unused tmp102_of_match[] = {\n\t{ .compatible = \"ti,tmp102\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tmp102_of_match);\n\nstatic struct i2c_driver tmp102_driver = {\n\t.driver.name\t= DRIVER_NAME,\n\t.driver.of_match_table = of_match_ptr(tmp102_of_match),\n\t.driver.pm\t= pm_sleep_ptr(&tmp102_dev_pm_ops),\n\t.probe\t\t= tmp102_probe,\n\t.id_table\t= tmp102_id,\n};\n\nmodule_i2c_driver(tmp102_driver);\n\nMODULE_AUTHOR(\"Steven King <sfking@fdwdc.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments TMP102 temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}