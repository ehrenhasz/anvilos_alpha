{
  "module_name": "nct7904.c",
  "hash_id": "2c70e5ed75ebedbc7742d9d37163f0c49d80af03abd2cb97c9eab5ac42cdc6e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/nct7904.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/hwmon.h>\n#include <linux/watchdog.h>\n\n#define VENDOR_ID_REG\t\t0x7A\t \n#define NUVOTON_ID\t\t0x50\n#define CHIP_ID_REG\t\t0x7B\t \n#define NCT7904_ID\t\t0xC5\n#define DEVICE_ID_REG\t\t0x7C\t \n\n#define BANK_SEL_REG\t\t0xFF\n#define BANK_0\t\t\t0x00\n#define BANK_1\t\t\t0x01\n#define BANK_2\t\t\t0x02\n#define BANK_3\t\t\t0x03\n#define BANK_4\t\t\t0x04\n#define BANK_MAX\t\t0x04\n\n#define FANIN_MAX\t\t12\t \n#define VSEN_MAX\t\t21\t \n#define FANCTL_MAX\t\t4\t \n#define TCPU_MAX\t\t8\t \n#define TEMP_MAX\t\t4\t \n#define SMI_STS_MAX\t\t10\t \n\n#define VT_ADC_CTRL0_REG\t0x20\t \n#define VT_ADC_CTRL1_REG\t0x21\t \n#define VT_ADC_CTRL2_REG\t0x22\t \n#define FANIN_CTRL0_REG\t\t0x24\n#define FANIN_CTRL1_REG\t\t0x25\n#define DTS_T_CTRL0_REG\t\t0x26\n#define DTS_T_CTRL1_REG\t\t0x27\n#define VT_ADC_MD_REG\t\t0x2E\n\n#define VSEN1_HV_LL_REG\t\t0x02\t \n#define VSEN1_LV_LL_REG\t\t0x03\t \n#define VSEN1_HV_HL_REG\t\t0x00\t \n#define VSEN1_LV_HL_REG\t\t0x01\t \n#define SMI_STS1_REG\t\t0xC1\t \n#define SMI_STS3_REG\t\t0xC3\t \n#define SMI_STS5_REG\t\t0xC5\t \n#define SMI_STS7_REG\t\t0xC7\t \n#define SMI_STS8_REG\t\t0xC8\t \n\n#define VSEN1_HV_REG\t\t0x40\t \n#define TEMP_CH1_HV_REG\t\t0x42\t \n#define LTD_HV_REG\t\t0x62\t \n#define LTD_HV_HL_REG\t\t0x44\t \n#define LTD_LV_HL_REG\t\t0x45\t \n#define LTD_HV_LL_REG\t\t0x46\t \n#define LTD_LV_LL_REG\t\t0x47\t \n#define TEMP_CH1_CH_REG\t\t0x05\t \n#define TEMP_CH1_W_REG\t\t0x06\t \n#define TEMP_CH1_WH_REG\t\t0x07\t \n#define TEMP_CH1_C_REG\t\t0x04\t \n#define DTS_T_CPU1_C_REG\t0x90\t \n#define DTS_T_CPU1_CH_REG\t0x91\t \n#define DTS_T_CPU1_W_REG\t0x92\t \n#define DTS_T_CPU1_WH_REG\t0x93\t \n#define FANIN1_HV_REG\t\t0x80\t \n#define FANIN1_HV_HL_REG\t0x60\t \n#define FANIN1_LV_HL_REG\t0x61\t \n#define T_CPU1_HV_REG\t\t0xA0\t \n\n#define PRTS_REG\t\t0x03\t \n#define PFE_REG\t\t\t0x00\t \n#define TSI_CTRL_REG\t\t0x50\t \n#define FANCTL1_FMR_REG\t\t0x00\t \n#define FANCTL1_OUT_REG\t\t0x10\t \n\n#define WDT_LOCK_REG\t\t0xE0\t \n#define WDT_EN_REG\t\t0xE1\t \n#define WDT_STS_REG\t\t0xE2\t \n#define WDT_TIMER_REG\t\t0xE3\t \n#define WDT_SOFT_EN\t\t0x55\t \n#define WDT_SOFT_DIS\t\t0xAA\t \n\n#define VOLT_MONITOR_MODE\t0x0\n#define THERMAL_DIODE_MODE\t0x1\n#define THERMISTOR_MODE\t\t0x3\n\n#define ENABLE_TSI\tBIT(1)\n\n#define WATCHDOG_TIMEOUT\t1\t \n\n \n#define MIN_TIMEOUT\t\t(1 * 60)\n#define MAX_TIMEOUT\t\t(255 * 60)\n\nstatic int timeout;\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in minutes. 1 <= timeout <= 255, default=\"\n\t\t\t__MODULE_STRING(WATCHDOG_TIMEOUT) \".\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic const unsigned short normal_i2c[] = {\n\t0x2d, 0x2e, I2C_CLIENT_END\n};\n\nstruct nct7904_data {\n\tstruct i2c_client *client;\n\tstruct watchdog_device wdt;\n\tstruct mutex bank_lock;\n\tint bank_sel;\n\tu32 fanin_mask;\n\tu32 vsen_mask;\n\tu32 tcpu_mask;\n\tu8 fan_mode[FANCTL_MAX];\n\tu8 enable_dts;\n\tu8 has_dts;\n\tu8 temp_mode;  \n\tu8 fan_alarm[2];\n\tu8 vsen_alarm[3];\n};\n\n \nstatic int nct7904_bank_lock(struct nct7904_data *data, unsigned int bank)\n{\n\tint ret;\n\n\tmutex_lock(&data->bank_lock);\n\tif (data->bank_sel == bank)\n\t\treturn 0;\n\tret = i2c_smbus_write_byte_data(data->client, BANK_SEL_REG, bank);\n\tif (ret == 0)\n\t\tdata->bank_sel = bank;\n\telse\n\t\tdata->bank_sel = -1;\n\treturn ret;\n}\n\nstatic inline void nct7904_bank_release(struct nct7904_data *data)\n{\n\tmutex_unlock(&data->bank_lock);\n}\n\n \nstatic int nct7904_read_reg(struct nct7904_data *data,\n\t\t\t    unsigned int bank, unsigned int reg)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tret = nct7904_bank_lock(data, bank);\n\tif (ret == 0)\n\t\tret = i2c_smbus_read_byte_data(client, reg);\n\n\tnct7904_bank_release(data);\n\treturn ret;\n}\n\n \nstatic int nct7904_read_reg16(struct nct7904_data *data,\n\t\t\t      unsigned int bank, unsigned int reg)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret, hi;\n\n\tret = nct7904_bank_lock(data, bank);\n\tif (ret == 0) {\n\t\tret = i2c_smbus_read_byte_data(client, reg);\n\t\tif (ret >= 0) {\n\t\t\thi = ret;\n\t\t\tret = i2c_smbus_read_byte_data(client, reg + 1);\n\t\t\tif (ret >= 0)\n\t\t\t\tret |= hi << 8;\n\t\t}\n\t}\n\n\tnct7904_bank_release(data);\n\treturn ret;\n}\n\n \nstatic int nct7904_write_reg(struct nct7904_data *data,\n\t\t\t     unsigned int bank, unsigned int reg, u8 val)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tret = nct7904_bank_lock(data, bank);\n\tif (ret == 0)\n\t\tret = i2c_smbus_write_byte_data(client, reg, val);\n\n\tnct7904_bank_release(data);\n\treturn ret;\n}\n\nstatic int nct7904_read_fan(struct device *dev, u32 attr, int channel,\n\t\t\t    long *val)\n{\n\tstruct nct7904_data *data = dev_get_drvdata(dev);\n\tunsigned int cnt, rpm;\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\t\tret = nct7904_read_reg16(data, BANK_0,\n\t\t\t\t\t FANIN1_HV_REG + channel * 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcnt = ((ret & 0xff00) >> 3) | (ret & 0x1f);\n\t\tif (cnt == 0 || cnt == 0x1fff)\n\t\t\trpm = 0;\n\t\telse\n\t\t\trpm = 1350000 / cnt;\n\t\t*val = rpm;\n\t\treturn 0;\n\tcase hwmon_fan_min:\n\t\tret = nct7904_read_reg16(data, BANK_1,\n\t\t\t\t\t FANIN1_HV_HL_REG + channel * 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcnt = ((ret & 0xff00) >> 3) | (ret & 0x1f);\n\t\tif (cnt == 0 || cnt == 0x1fff)\n\t\t\trpm = 0;\n\t\telse\n\t\t\trpm = 1350000 / cnt;\n\t\t*val = rpm;\n\t\treturn 0;\n\tcase hwmon_fan_alarm:\n\t\tret = nct7904_read_reg(data, BANK_0,\n\t\t\t\t       SMI_STS5_REG + (channel >> 3));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!data->fan_alarm[channel >> 3])\n\t\t\tdata->fan_alarm[channel >> 3] = ret & 0xff;\n\t\telse\n\t\t\t \n\t\t\tdata->fan_alarm[channel >> 3] |= (ret & 0xff);\n\t\t*val = (data->fan_alarm[channel >> 3] >> (channel & 0x07)) & 1;\n\t\t \n\t\tif (*val)\n\t\t\tdata->fan_alarm[channel >> 3] ^= 1 << (channel & 0x07);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t nct7904_fan_is_visible(const void *_data, u32 attr, int channel)\n{\n\tconst struct nct7904_data *data = _data;\n\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\tcase hwmon_fan_alarm:\n\t\tif (data->fanin_mask & (1 << channel))\n\t\t\treturn 0444;\n\t\tbreak;\n\tcase hwmon_fan_min:\n\t\tif (data->fanin_mask & (1 << channel))\n\t\t\treturn 0644;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 nct7904_chan_to_index[] = {\n\t0,\t \n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t18, 19, 20, 16\n};\n\nstatic int nct7904_read_in(struct device *dev, u32 attr, int channel,\n\t\t\t   long *val)\n{\n\tstruct nct7904_data *data = dev_get_drvdata(dev);\n\tint ret, volt, index;\n\n\tindex = nct7904_chan_to_index[channel];\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\tret = nct7904_read_reg16(data, BANK_0,\n\t\t\t\t\t VSEN1_HV_REG + index * 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tvolt = ((ret & 0xff00) >> 5) | (ret & 0x7);\n\t\tif (index < 14)\n\t\t\tvolt *= 2;  \n\t\telse\n\t\t\tvolt *= 6;  \n\t\t*val = volt;\n\t\treturn 0;\n\tcase hwmon_in_min:\n\t\tret = nct7904_read_reg16(data, BANK_1,\n\t\t\t\t\t VSEN1_HV_LL_REG + index * 4);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tvolt = ((ret & 0xff00) >> 5) | (ret & 0x7);\n\t\tif (index < 14)\n\t\t\tvolt *= 2;  \n\t\telse\n\t\t\tvolt *= 6;  \n\t\t*val = volt;\n\t\treturn 0;\n\tcase hwmon_in_max:\n\t\tret = nct7904_read_reg16(data, BANK_1,\n\t\t\t\t\t VSEN1_HV_HL_REG + index * 4);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tvolt = ((ret & 0xff00) >> 5) | (ret & 0x7);\n\t\tif (index < 14)\n\t\t\tvolt *= 2;  \n\t\telse\n\t\t\tvolt *= 6;  \n\t\t*val = volt;\n\t\treturn 0;\n\tcase hwmon_in_alarm:\n\t\tret = nct7904_read_reg(data, BANK_0,\n\t\t\t\t       SMI_STS1_REG + (index >> 3));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!data->vsen_alarm[index >> 3])\n\t\t\tdata->vsen_alarm[index >> 3] = ret & 0xff;\n\t\telse\n\t\t\t \n\t\t\tdata->vsen_alarm[index >> 3] |= (ret & 0xff);\n\t\t*val = (data->vsen_alarm[index >> 3] >> (index & 0x07)) & 1;\n\t\t \n\t\tif (*val)\n\t\t\tdata->vsen_alarm[index >> 3] ^= 1 << (index & 0x07);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t nct7904_in_is_visible(const void *_data, u32 attr, int channel)\n{\n\tconst struct nct7904_data *data = _data;\n\tint index = nct7904_chan_to_index[channel];\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\tcase hwmon_in_alarm:\n\t\tif (channel > 0 && (data->vsen_mask & BIT(index)))\n\t\t\treturn 0444;\n\t\tbreak;\n\tcase hwmon_in_min:\n\tcase hwmon_in_max:\n\t\tif (channel > 0 && (data->vsen_mask & BIT(index)))\n\t\t\treturn 0644;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int nct7904_read_temp(struct device *dev, u32 attr, int channel,\n\t\t\t     long *val)\n{\n\tstruct nct7904_data *data = dev_get_drvdata(dev);\n\tint ret, temp;\n\tunsigned int reg1, reg2, reg3;\n\ts8 temps;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tif (channel == 4)\n\t\t\tret = nct7904_read_reg16(data, BANK_0, LTD_HV_REG);\n\t\telse if (channel < 5)\n\t\t\tret = nct7904_read_reg16(data, BANK_0,\n\t\t\t\t\t\t TEMP_CH1_HV_REG + channel * 4);\n\t\telse\n\t\t\tret = nct7904_read_reg16(data, BANK_0,\n\t\t\t\t\t\t T_CPU1_HV_REG + (channel - 5)\n\t\t\t\t\t\t * 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ttemp = ((ret & 0xff00) >> 5) | (ret & 0x7);\n\t\t*val = sign_extend32(temp, 10) * 125;\n\t\treturn 0;\n\tcase hwmon_temp_alarm:\n\t\tif (channel == 4) {\n\t\t\tret = nct7904_read_reg(data, BANK_0,\n\t\t\t\t\t       SMI_STS3_REG);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = (ret >> 1) & 1;\n\t\t} else if (channel < 4) {\n\t\t\tret = nct7904_read_reg(data, BANK_0,\n\t\t\t\t\t       SMI_STS1_REG);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = (ret >> (((channel * 2) + 1) & 0x07)) & 1;\n\t\t} else {\n\t\t\tif ((channel - 5) < 4) {\n\t\t\t\tret = nct7904_read_reg(data, BANK_0,\n\t\t\t\t\t\t       SMI_STS7_REG +\n\t\t\t\t\t\t       ((channel - 5) >> 3));\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\t*val = (ret >> ((channel - 5) & 0x07)) & 1;\n\t\t\t} else {\n\t\t\t\tret = nct7904_read_reg(data, BANK_0,\n\t\t\t\t\t\t       SMI_STS8_REG +\n\t\t\t\t\t\t       ((channel - 5) >> 3));\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\t*val = (ret >> (((channel - 5) & 0x07) - 4))\n\t\t\t\t\t\t\t& 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\tcase hwmon_temp_type:\n\t\tif (channel < 5) {\n\t\t\tif ((data->tcpu_mask >> channel) & 0x01) {\n\t\t\t\tif ((data->temp_mode >> channel) & 0x01)\n\t\t\t\t\t*val = 3;  \n\t\t\t\telse\n\t\t\t\t\t*val = 4;  \n\t\t\t} else {\n\t\t\t\t*val = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((data->has_dts >> (channel - 5)) & 0x01) {\n\t\t\t\tif (data->enable_dts & ENABLE_TSI)\n\t\t\t\t\t*val = 5;  \n\t\t\t\telse\n\t\t\t\t\t*val = 6;  \n\t\t\t} else {\n\t\t\t\t*val = 0;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\tcase hwmon_temp_max:\n\t\treg1 = LTD_HV_LL_REG;\n\t\treg2 = TEMP_CH1_W_REG;\n\t\treg3 = DTS_T_CPU1_W_REG;\n\t\tbreak;\n\tcase hwmon_temp_max_hyst:\n\t\treg1 = LTD_LV_LL_REG;\n\t\treg2 = TEMP_CH1_WH_REG;\n\t\treg3 = DTS_T_CPU1_WH_REG;\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\treg1 = LTD_HV_HL_REG;\n\t\treg2 = TEMP_CH1_C_REG;\n\t\treg3 = DTS_T_CPU1_C_REG;\n\t\tbreak;\n\tcase hwmon_temp_crit_hyst:\n\t\treg1 = LTD_LV_HL_REG;\n\t\treg2 = TEMP_CH1_CH_REG;\n\t\treg3 = DTS_T_CPU1_CH_REG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (channel == 4)\n\t\tret = nct7904_read_reg(data, BANK_1, reg1);\n\telse if (channel < 5)\n\t\tret = nct7904_read_reg(data, BANK_1,\n\t\t\t\t       reg2 + channel * 8);\n\telse\n\t\tret = nct7904_read_reg(data, BANK_1,\n\t\t\t\t       reg3 + (channel - 5) * 4);\n\n\tif (ret < 0)\n\t\treturn ret;\n\ttemps = ret;\n\t*val = temps * 1000;\n\treturn 0;\n}\n\nstatic umode_t nct7904_temp_is_visible(const void *_data, u32 attr, int channel)\n{\n\tconst struct nct7904_data *data = _data;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_alarm:\n\tcase hwmon_temp_type:\n\t\tif (channel < 5) {\n\t\t\tif (data->tcpu_mask & BIT(channel))\n\t\t\t\treturn 0444;\n\t\t} else {\n\t\t\tif (data->has_dts & BIT(channel - 5))\n\t\t\t\treturn 0444;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp_max:\n\tcase hwmon_temp_max_hyst:\n\tcase hwmon_temp_crit:\n\tcase hwmon_temp_crit_hyst:\n\t\tif (channel < 5) {\n\t\t\tif (data->tcpu_mask & BIT(channel))\n\t\t\t\treturn 0644;\n\t\t} else {\n\t\t\tif (data->has_dts & BIT(channel - 5))\n\t\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int nct7904_read_pwm(struct device *dev, u32 attr, int channel,\n\t\t\t    long *val)\n{\n\tstruct nct7904_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\tret = nct7904_read_reg(data, BANK_3, FANCTL1_OUT_REG + channel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn 0;\n\tcase hwmon_pwm_enable:\n\t\tret = nct7904_read_reg(data, BANK_3, FANCTL1_FMR_REG + channel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret ? 2 : 1;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int nct7904_write_temp(struct device *dev, u32 attr, int channel,\n\t\t\t      long val)\n{\n\tstruct nct7904_data *data = dev_get_drvdata(dev);\n\tint ret;\n\tunsigned int reg1, reg2, reg3;\n\n\tval = clamp_val(val / 1000, -128, 127);\n\n\tswitch (attr) {\n\tcase hwmon_temp_max:\n\t\treg1 = LTD_HV_LL_REG;\n\t\treg2 = TEMP_CH1_W_REG;\n\t\treg3 = DTS_T_CPU1_W_REG;\n\t\tbreak;\n\tcase hwmon_temp_max_hyst:\n\t\treg1 = LTD_LV_LL_REG;\n\t\treg2 = TEMP_CH1_WH_REG;\n\t\treg3 = DTS_T_CPU1_WH_REG;\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\treg1 = LTD_HV_HL_REG;\n\t\treg2 = TEMP_CH1_C_REG;\n\t\treg3 = DTS_T_CPU1_C_REG;\n\t\tbreak;\n\tcase hwmon_temp_crit_hyst:\n\t\treg1 = LTD_LV_HL_REG;\n\t\treg2 = TEMP_CH1_CH_REG;\n\t\treg3 = DTS_T_CPU1_CH_REG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (channel == 4)\n\t\tret = nct7904_write_reg(data, BANK_1, reg1, val);\n\telse if (channel < 5)\n\t\tret = nct7904_write_reg(data, BANK_1,\n\t\t\t\t\treg2 + channel * 8, val);\n\telse\n\t\tret = nct7904_write_reg(data, BANK_1,\n\t\t\t\t\treg3 + (channel - 5) * 4, val);\n\n\treturn ret;\n}\n\nstatic int nct7904_write_fan(struct device *dev, u32 attr, int channel,\n\t\t\t     long val)\n{\n\tstruct nct7904_data *data = dev_get_drvdata(dev);\n\tint ret;\n\tu8 tmp;\n\n\tswitch (attr) {\n\tcase hwmon_fan_min:\n\t\tif (val <= 0)\n\t\t\treturn -EINVAL;\n\n\t\tval = clamp_val(DIV_ROUND_CLOSEST(1350000, val), 1, 0x1fff);\n\t\ttmp = (val >> 5) & 0xff;\n\t\tret = nct7904_write_reg(data, BANK_1,\n\t\t\t\t\tFANIN1_HV_HL_REG + channel * 2, tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ttmp = val & 0x1f;\n\t\tret = nct7904_write_reg(data, BANK_1,\n\t\t\t\t\tFANIN1_LV_HL_REG + channel * 2, tmp);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int nct7904_write_in(struct device *dev, u32 attr, int channel,\n\t\t\t    long val)\n{\n\tstruct nct7904_data *data = dev_get_drvdata(dev);\n\tint ret, index, tmp;\n\n\tindex = nct7904_chan_to_index[channel];\n\n\tif (index < 14)\n\t\tval = val / 2;  \n\telse\n\t\tval = val / 6;  \n\n\tval = clamp_val(val, 0, 0x7ff);\n\n\tswitch (attr) {\n\tcase hwmon_in_min:\n\t\ttmp = nct7904_read_reg(data, BANK_1,\n\t\t\t\t       VSEN1_LV_LL_REG + index * 4);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t\ttmp &= ~0x7;\n\t\ttmp |= val & 0x7;\n\t\tret = nct7904_write_reg(data, BANK_1,\n\t\t\t\t\tVSEN1_LV_LL_REG + index * 4, tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ttmp = nct7904_read_reg(data, BANK_1,\n\t\t\t\t       VSEN1_HV_LL_REG + index * 4);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t\ttmp = (val >> 3) & 0xff;\n\t\tret = nct7904_write_reg(data, BANK_1,\n\t\t\t\t\tVSEN1_HV_LL_REG + index * 4, tmp);\n\t\treturn ret;\n\tcase hwmon_in_max:\n\t\ttmp = nct7904_read_reg(data, BANK_1,\n\t\t\t\t       VSEN1_LV_HL_REG + index * 4);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t\ttmp &= ~0x7;\n\t\ttmp |= val & 0x7;\n\t\tret = nct7904_write_reg(data, BANK_1,\n\t\t\t\t\tVSEN1_LV_HL_REG + index * 4, tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ttmp = nct7904_read_reg(data, BANK_1,\n\t\t\t\t       VSEN1_HV_HL_REG + index * 4);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t\ttmp = (val >> 3) & 0xff;\n\t\tret = nct7904_write_reg(data, BANK_1,\n\t\t\t\t\tVSEN1_HV_HL_REG + index * 4, tmp);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int nct7904_write_pwm(struct device *dev, u32 attr, int channel,\n\t\t\t     long val)\n{\n\tstruct nct7904_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\tif (val < 0 || val > 255)\n\t\t\treturn -EINVAL;\n\t\tret = nct7904_write_reg(data, BANK_3, FANCTL1_OUT_REG + channel,\n\t\t\t\t\tval);\n\t\treturn ret;\n\tcase hwmon_pwm_enable:\n\t\tif (val < 1 || val > 2 ||\n\t\t    (val == 2 && !data->fan_mode[channel]))\n\t\t\treturn -EINVAL;\n\t\tret = nct7904_write_reg(data, BANK_3, FANCTL1_FMR_REG + channel,\n\t\t\t\t\tval == 2 ? data->fan_mode[channel] : 0);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t nct7904_pwm_is_visible(const void *_data, u32 attr, int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\tcase hwmon_pwm_enable:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int nct7904_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\treturn nct7904_read_in(dev, attr, channel, val);\n\tcase hwmon_fan:\n\t\treturn nct7904_read_fan(dev, attr, channel, val);\n\tcase hwmon_pwm:\n\t\treturn nct7904_read_pwm(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn nct7904_read_temp(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int nct7904_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\treturn nct7904_write_in(dev, attr, channel, val);\n\tcase hwmon_fan:\n\t\treturn nct7904_write_fan(dev, attr, channel, val);\n\tcase hwmon_pwm:\n\t\treturn nct7904_write_pwm(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn nct7904_write_temp(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t nct7904_is_visible(const void *data,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\treturn nct7904_in_is_visible(data, attr, channel);\n\tcase hwmon_fan:\n\t\treturn nct7904_fan_is_visible(data, attr, channel);\n\tcase hwmon_pwm:\n\t\treturn nct7904_pwm_is_visible(data, attr, channel);\n\tcase hwmon_temp:\n\t\treturn nct7904_temp_is_visible(data, attr, channel);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic int nct7904_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\n\tif (!i2c_check_functionality(adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_BYTE |\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tif (i2c_smbus_read_byte_data(client, VENDOR_ID_REG) != NUVOTON_ID ||\n\t    i2c_smbus_read_byte_data(client, CHIP_ID_REG) != NCT7904_ID ||\n\t    (i2c_smbus_read_byte_data(client, DEVICE_ID_REG) & 0xf0) != 0x50 ||\n\t    (i2c_smbus_read_byte_data(client, BANK_SEL_REG) & 0xf8) != 0x00)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"nct7904\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const nct7904_info[] = {\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t    \n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM),\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_ALARM,\n\t\t\t   HWMON_F_INPUT | HWMON_F_MIN | HWMON_F_ALARM),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_MAX |\n\t\t\t   HWMON_T_MAX_HYST | HWMON_T_TYPE | HWMON_T_CRIT |\n\t\t\t   HWMON_T_CRIT_HYST),\n\tNULL\n};\n\nstatic const struct hwmon_ops nct7904_hwmon_ops = {\n\t.is_visible = nct7904_is_visible,\n\t.read = nct7904_read,\n\t.write = nct7904_write,\n};\n\nstatic const struct hwmon_chip_info nct7904_chip_info = {\n\t.ops = &nct7904_hwmon_ops,\n\t.info = nct7904_info,\n};\n\n \nstatic int nct7904_wdt_start(struct watchdog_device *wdt)\n{\n\tstruct nct7904_data *data = watchdog_get_drvdata(wdt);\n\n\t \n\treturn nct7904_write_reg(data, BANK_0, WDT_LOCK_REG, WDT_SOFT_EN);\n}\n\nstatic int nct7904_wdt_stop(struct watchdog_device *wdt)\n{\n\tstruct nct7904_data *data = watchdog_get_drvdata(wdt);\n\n\treturn nct7904_write_reg(data, BANK_0, WDT_LOCK_REG, WDT_SOFT_DIS);\n}\n\nstatic int nct7904_wdt_set_timeout(struct watchdog_device *wdt,\n\t\t\t\t   unsigned int timeout)\n{\n\tstruct nct7904_data *data = watchdog_get_drvdata(wdt);\n\t \n\twdt->timeout = timeout / 60 * 60;\n\n\treturn nct7904_write_reg(data, BANK_0, WDT_TIMER_REG,\n\t\t\t\t wdt->timeout / 60);\n}\n\nstatic int nct7904_wdt_ping(struct watchdog_device *wdt)\n{\n\t \n\tstruct nct7904_data *data = watchdog_get_drvdata(wdt);\n\tint ret;\n\n\t \n\tret = nct7904_write_reg(data, BANK_0, WDT_LOCK_REG, WDT_SOFT_DIS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = nct7904_write_reg(data, BANK_0, WDT_TIMER_REG, wdt->timeout / 60);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn nct7904_write_reg(data, BANK_0, WDT_LOCK_REG, WDT_SOFT_EN);\n}\n\nstatic unsigned int nct7904_wdt_get_timeleft(struct watchdog_device *wdt)\n{\n\tstruct nct7904_data *data = watchdog_get_drvdata(wdt);\n\tint ret;\n\n\tret = nct7904_read_reg(data, BANK_0, WDT_TIMER_REG);\n\tif (ret < 0)\n\t\treturn 0;\n\n\treturn ret * 60;\n}\n\nstatic const struct watchdog_info nct7904_wdt_info = {\n\t.options\t= WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\n\t\t\t\tWDIOF_MAGICCLOSE,\n\t.identity\t= \"nct7904 watchdog\",\n};\n\nstatic const struct watchdog_ops nct7904_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= nct7904_wdt_start,\n\t.stop\t\t= nct7904_wdt_stop,\n\t.ping\t\t= nct7904_wdt_ping,\n\t.set_timeout\t= nct7904_wdt_set_timeout,\n\t.get_timeleft\t= nct7904_wdt_get_timeleft,\n};\n\nstatic int nct7904_probe(struct i2c_client *client)\n{\n\tstruct nct7904_data *data;\n\tstruct device *hwmon_dev;\n\tstruct device *dev = &client->dev;\n\tint ret, i;\n\tu32 mask;\n\tu8 val, bit;\n\n\tdata = devm_kzalloc(dev, sizeof(struct nct7904_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->bank_lock);\n\tdata->bank_sel = -1;\n\n\t \n\t \n\tret = nct7904_read_reg16(data, BANK_0, FANIN_CTRL0_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->fanin_mask = (ret >> 8) | ((ret & 0xff) << 8);\n\n\t \n\tmask = 0;\n\tret = nct7904_read_reg16(data, BANK_0, VT_ADC_CTRL0_REG);\n\tif (ret >= 0)\n\t\tmask = (ret >> 8) | ((ret & 0xff) << 8);\n\tret = nct7904_read_reg(data, BANK_0, VT_ADC_CTRL2_REG);\n\tif (ret >= 0)\n\t\tmask |= (ret << 16);\n\tdata->vsen_mask = mask;\n\n\t \n\tret = nct7904_read_reg(data, BANK_0, VT_ADC_CTRL0_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((ret & 0x6) == 0x6)\n\t\tdata->tcpu_mask |= 1;  \n\tif ((ret & 0x18) == 0x18)\n\t\tdata->tcpu_mask |= 2;  \n\tif ((ret & 0x20) == 0x20)\n\t\tdata->tcpu_mask |= 4;  \n\tif ((ret & 0x80) == 0x80)\n\t\tdata->tcpu_mask |= 8;  \n\n\t \n\tret = nct7904_read_reg(data, BANK_0, VT_ADC_CTRL2_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\tif ((ret & 0x02) == 0x02)\n\t\tdata->tcpu_mask |= 0x10;\n\n\t \n\tret = nct7904_read_reg(data, BANK_0, VT_ADC_MD_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->temp_mode = 0;\n\tfor (i = 0; i < 4; i++) {\n\t\tval = (ret >> (i * 2)) & 0x03;\n\t\tbit = (1 << i);\n\t\tif (val == VOLT_MONITOR_MODE) {\n\t\t\tdata->tcpu_mask &= ~bit;\n\t\t} else if (val == THERMAL_DIODE_MODE && i < 2) {\n\t\t\tdata->temp_mode |= bit;\n\t\t\tdata->vsen_mask &= ~(0x06 << (i * 2));\n\t\t} else if (val == THERMISTOR_MODE) {\n\t\t\tdata->vsen_mask &= ~(0x02 << (i * 2));\n\t\t} else {\n\t\t\t \n\t\t\tdata->tcpu_mask &= ~bit;\n\t\t\tdata->vsen_mask &= ~(0x06 << (i * 2));\n\t\t}\n\t}\n\n\t \n\tret = nct7904_read_reg(data, BANK_2, PFE_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret & 0x80) {\n\t\tdata->enable_dts = 1;  \n\t} else {\n\t\tret = nct7904_read_reg(data, BANK_2, TSI_CTRL_REG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret & 0x80)\n\t\t\tdata->enable_dts = 0x3;  \n\t}\n\n\t \n\tif (data->enable_dts) {\n\t\tret = nct7904_read_reg(data, BANK_0, DTS_T_CTRL0_REG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->has_dts = ret & 0xF;\n\t\tif (data->enable_dts & ENABLE_TSI) {\n\t\t\tret = nct7904_read_reg(data, BANK_0, DTS_T_CTRL1_REG);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tdata->has_dts |= (ret & 0xF) << 4;\n\t\t}\n\t}\n\n\tfor (i = 0; i < FANCTL_MAX; i++) {\n\t\tret = nct7904_read_reg(data, BANK_3, FANCTL1_FMR_REG + i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->fan_mode[i] = ret;\n\t}\n\n\t \n\tfor (i = 0; i < SMI_STS_MAX; i++) {\n\t\tret = nct7904_read_reg(data, BANK_0, SMI_STS1_REG + i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\thwmon_dev =\n\t\tdevm_hwmon_device_register_with_info(dev, client->name, data,\n\t\t\t\t\t\t     &nct7904_chip_info, NULL);\n\tret = PTR_ERR_OR_ZERO(hwmon_dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdata->wdt.ops = &nct7904_wdt_ops;\n\tdata->wdt.info = &nct7904_wdt_info;\n\n\tdata->wdt.timeout = WATCHDOG_TIMEOUT * 60;  \n\tdata->wdt.min_timeout = MIN_TIMEOUT;\n\tdata->wdt.max_timeout = MAX_TIMEOUT;\n\tdata->wdt.parent = &client->dev;\n\n\twatchdog_init_timeout(&data->wdt, timeout * 60, &client->dev);\n\twatchdog_set_nowayout(&data->wdt, nowayout);\n\twatchdog_set_drvdata(&data->wdt, data);\n\n\twatchdog_stop_on_unregister(&data->wdt);\n\n\treturn devm_watchdog_register_device(dev, &data->wdt);\n}\n\nstatic const struct i2c_device_id nct7904_id[] = {\n\t{\"nct7904\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, nct7904_id);\n\nstatic struct i2c_driver nct7904_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"nct7904\",\n\t},\n\t.probe = nct7904_probe,\n\t.id_table = nct7904_id,\n\t.detect = nct7904_detect,\n\t.address_list = normal_i2c,\n};\n\nmodule_i2c_driver(nct7904_driver);\n\nMODULE_AUTHOR(\"Vadim V. Vlasov <vvlasov@dev.rtsoft.ru>\");\nMODULE_DESCRIPTION(\"Hwmon driver for NUVOTON NCT7904\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}