{
  "module_name": "lm92.c",
  "hash_id": "78dde9dc2d646f1bf323c9a85ce6cce6a93d9255eeb7df60b221d240dc195602",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lm92.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/jiffies.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x48, 0x49, 0x4a, 0x4b,\n\t\t\t\t\t\tI2C_CLIENT_END };\nenum chips { lm92, max6635 };\n\n \n#define LM92_REG_CONFIG\t\t\t0x01  \n#define LM92_REG_TEMP\t\t\t0x00  \n#define LM92_REG_TEMP_HYST\t\t0x02  \n#define LM92_REG_TEMP_CRIT\t\t0x03  \n#define LM92_REG_TEMP_LOW\t\t0x04  \n#define LM92_REG_TEMP_HIGH\t\t0x05  \n#define LM92_REG_MAN_ID\t\t\t0x07  \n\n \nstatic inline int TEMP_FROM_REG(s16 reg)\n{\n\treturn reg / 8 * 625 / 10;\n}\n\nstatic inline s16 TEMP_TO_REG(long val)\n{\n\tval = clamp_val(val, -60000, 160000);\n\treturn val * 10 / 625 * 8;\n}\n\n \nstatic inline u8 ALARMS_FROM_REG(s16 reg)\n{\n\treturn reg & 0x0007;\n}\n\nenum temp_index {\n\tt_input,\n\tt_crit,\n\tt_min,\n\tt_max,\n\tt_hyst,\n\tt_num_regs\n};\n\nstatic const u8 regs[t_num_regs] = {\n\t[t_input] = LM92_REG_TEMP,\n\t[t_crit] = LM92_REG_TEMP_CRIT,\n\t[t_min] = LM92_REG_TEMP_LOW,\n\t[t_max] = LM92_REG_TEMP_HIGH,\n\t[t_hyst] = LM92_REG_TEMP_HYST,\n};\n\n \nstruct lm92_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tbool valid;  \n\tunsigned long last_updated;  \n\n\t \n\ts16 temp[t_num_regs];\t \n};\n\n \n\nstatic struct lm92_data *lm92_update_device(struct device *dev)\n{\n\tstruct lm92_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ) ||\n\t    !data->valid) {\n\t\tdev_dbg(&client->dev, \"Updating lm92 data\\n\");\n\t\tfor (i = 0; i < t_num_regs; i++) {\n\t\t\tdata->temp[i] =\n\t\t\t\ti2c_smbus_read_word_swapped(client, regs[i]);\n\t\t}\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm92_data *data = lm92_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp[attr->index]));\n}\n\nstatic ssize_t temp_store(struct device *dev,\n\t\t\t  struct device_attribute *devattr, const char *buf,\n\t\t\t  size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm92_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp[nr] = TEMP_TO_REG(val);\n\ti2c_smbus_write_word_swapped(client, regs[nr], data->temp[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t temp_hyst_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm92_data *data = lm92_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp[attr->index])\n\t\t       - TEMP_FROM_REG(data->temp[t_hyst]));\n}\n\nstatic ssize_t temp1_min_hyst_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct lm92_data *data = lm92_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp[t_min])\n\t\t       + TEMP_FROM_REG(data->temp[t_hyst]));\n}\n\nstatic ssize_t temp_hyst_store(struct device *dev,\n\t\t\t       struct device_attribute *devattr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm92_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tval = clamp_val(val, -120000, 220000);\n\tmutex_lock(&data->update_lock);\n\tdata->temp[t_hyst] =\n\t\tTEMP_TO_REG(TEMP_FROM_REG(data->temp[attr->index]) - val);\n\ti2c_smbus_write_word_swapped(client, LM92_REG_TEMP_HYST,\n\t\t\t\t     data->temp[t_hyst]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct lm92_data *data = lm92_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", ALARMS_FROM_REG(data->temp[t_input]));\n}\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tstruct lm92_data *data = lm92_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (data->temp[t_input] >> bitnr) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, t_input);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_crit, temp, t_crit);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_crit_hyst, temp_hyst, t_crit);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp, t_min);\nstatic DEVICE_ATTR_RO(temp1_min_hyst);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp, t_max);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_hyst, temp_hyst, t_max);\nstatic DEVICE_ATTR_RO(alarms);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_crit_alarm, alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_alarm, alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, alarm, 1);\n\n \n\nstatic void lm92_init_client(struct i2c_client *client)\n{\n\tu8 config;\n\n\t \n\tconfig = i2c_smbus_read_byte_data(client, LM92_REG_CONFIG);\n\tif (config & 0x01)\n\t\ti2c_smbus_write_byte_data(client, LM92_REG_CONFIG,\n\t\t\t\t\t  config & 0xFE);\n}\n\nstatic struct attribute *lm92_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&dev_attr_temp1_min_hyst.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,\n\t&dev_attr_alarms.attr,\n\t&sensor_dev_attr_temp1_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(lm92);\n\n \nstatic int lm92_detect(struct i2c_client *new_client,\n\t\t       struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = new_client->adapter;\n\tu8 config;\n\tu16 man_id;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA\n\t\t\t\t\t    | I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tconfig = i2c_smbus_read_byte_data(new_client, LM92_REG_CONFIG);\n\tman_id = i2c_smbus_read_word_data(new_client, LM92_REG_MAN_ID);\n\n\tif ((config & 0xe0) == 0x00 && man_id == 0x0180)\n\t\tpr_info(\"lm92: Found National Semiconductor LM92 chip\\n\");\n\telse\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"lm92\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int lm92_probe(struct i2c_client *new_client)\n{\n\tstruct device *hwmon_dev;\n\tstruct lm92_data *data;\n\n\tdata = devm_kzalloc(&new_client->dev, sizeof(struct lm92_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = new_client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tlm92_init_client(new_client);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(&new_client->dev,\n\t\t\t\t\t\t\t   new_client->name,\n\t\t\t\t\t\t\t   data, lm92_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\n \n\nstatic const struct i2c_device_id lm92_id[] = {\n\t{ \"lm92\", lm92 },\n\t{ \"max6635\", max6635 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm92_id);\n\nstatic struct i2c_driver lm92_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"lm92\",\n\t},\n\t.probe\t\t= lm92_probe,\n\t.id_table\t= lm92_id,\n\t.detect\t\t= lm92_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(lm92_driver);\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"LM92/MAX6635 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}