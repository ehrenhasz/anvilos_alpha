{
  "module_name": "lm95241.c",
  "hash_id": "be9f98a65735d7df62933c3367cdda702b1bb18d06e9901d5050b49bde73aebc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lm95241.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/hwmon.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\n#define DEVNAME \"lm95241\"\n\nstatic const unsigned short normal_i2c[] = {\n\t0x19, 0x2a, 0x2b, I2C_CLIENT_END };\n\n \n#define LM95241_REG_R_MAN_ID\t\t0xFE\n#define LM95241_REG_R_CHIP_ID\t\t0xFF\n#define LM95241_REG_R_STATUS\t\t0x02\n#define LM95241_REG_RW_CONFIG\t\t0x03\n#define LM95241_REG_RW_REM_FILTER\t0x06\n#define LM95241_REG_RW_TRUTHERM\t\t0x07\n#define LM95241_REG_W_ONE_SHOT\t\t0x0F\n#define LM95241_REG_R_LOCAL_TEMPH\t0x10\n#define LM95241_REG_R_REMOTE1_TEMPH\t0x11\n#define LM95241_REG_R_REMOTE2_TEMPH\t0x12\n#define LM95241_REG_R_LOCAL_TEMPL\t0x20\n#define LM95241_REG_R_REMOTE1_TEMPL\t0x21\n#define LM95241_REG_R_REMOTE2_TEMPL\t0x22\n#define LM95241_REG_RW_REMOTE_MODEL\t0x30\n\n \n#define CFG_STOP\tBIT(6)\n#define CFG_CR0076\t0x00\n#define CFG_CR0182\tBIT(4)\n#define CFG_CR1000\tBIT(5)\n#define CFG_CR2700\t(BIT(4) | BIT(5))\n#define CFG_CRMASK\t(BIT(4) | BIT(5))\n#define R1MS_MASK\tBIT(0)\n#define R2MS_MASK\tBIT(2)\n#define R1DF_MASK\tBIT(1)\n#define R2DF_MASK\tBIT(2)\n#define R1FE_MASK\tBIT(0)\n#define R2FE_MASK\tBIT(2)\n#define R1DM\t\tBIT(0)\n#define R2DM\t\tBIT(1)\n#define TT1_SHIFT\t0\n#define TT2_SHIFT\t4\n#define TT_OFF\t\t0\n#define TT_ON\t\t1\n#define TT_MASK\t\t7\n#define NATSEMI_MAN_ID\t0x01\n#define LM95231_CHIP_ID\t0xA1\n#define LM95241_CHIP_ID\t0xA4\n\nstatic const u8 lm95241_reg_address[] = {\n\tLM95241_REG_R_LOCAL_TEMPH,\n\tLM95241_REG_R_LOCAL_TEMPL,\n\tLM95241_REG_R_REMOTE1_TEMPH,\n\tLM95241_REG_R_REMOTE1_TEMPL,\n\tLM95241_REG_R_REMOTE2_TEMPH,\n\tLM95241_REG_R_REMOTE2_TEMPL\n};\n\n \nstruct lm95241_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tunsigned long last_updated;\t \n\tunsigned long interval;\t\t \n\tbool valid;\t\t \n\t \n\tu8 temp[ARRAY_SIZE(lm95241_reg_address)];\n\tu8 status, config, model, trutherm;\n};\n\n \nstatic int temp_from_reg_signed(u8 val_h, u8 val_l)\n{\n\ts16 val_hl = (val_h << 8) | val_l;\n\treturn val_hl * 1000 / 256;\n}\n\nstatic int temp_from_reg_unsigned(u8 val_h, u8 val_l)\n{\n\tu16 val_hl = (val_h << 8) | val_l;\n\treturn val_hl * 1000 / 256;\n}\n\nstatic struct lm95241_data *lm95241_update_device(struct device *dev)\n{\n\tstruct lm95241_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated\n\t\t       + msecs_to_jiffies(data->interval)) ||\n\t    !data->valid) {\n\t\tint i;\n\n\t\tdev_dbg(dev, \"Updating lm95241 data.\\n\");\n\t\tfor (i = 0; i < ARRAY_SIZE(lm95241_reg_address); i++)\n\t\t\tdata->temp[i]\n\t\t\t  = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t     lm95241_reg_address[i]);\n\n\t\tdata->status = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t\tLM95241_REG_R_STATUS);\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\nstatic int lm95241_read_chip(struct device *dev, u32 attr, int channel,\n\t\t\t     long *val)\n{\n\tstruct lm95241_data *data = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\t*val = data->interval;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lm95241_read_temp(struct device *dev, u32 attr, int channel,\n\t\t\t     long *val)\n{\n\tstruct lm95241_data *data = lm95241_update_device(dev);\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tif (!channel || (data->config & BIT(channel - 1)))\n\t\t\t*val = temp_from_reg_signed(data->temp[channel * 2],\n\t\t\t\t\t\tdata->temp[channel * 2 + 1]);\n\t\telse\n\t\t\t*val = temp_from_reg_unsigned(data->temp[channel * 2],\n\t\t\t\t\t\tdata->temp[channel * 2 + 1]);\n\t\treturn 0;\n\tcase hwmon_temp_min:\n\t\tif (channel == 1)\n\t\t\t*val = (data->config & R1DF_MASK) ? -128000 : 0;\n\t\telse\n\t\t\t*val = (data->config & R2DF_MASK) ? -128000 : 0;\n\t\treturn 0;\n\tcase hwmon_temp_max:\n\t\tif (channel == 1)\n\t\t\t*val = (data->config & R1DF_MASK) ? 127875 : 255875;\n\t\telse\n\t\t\t*val = (data->config & R2DF_MASK) ? 127875 : 255875;\n\t\treturn 0;\n\tcase hwmon_temp_type:\n\t\tif (channel == 1)\n\t\t\t*val = (data->model & R1MS_MASK) ? 1 : 2;\n\t\telse\n\t\t\t*val = (data->model & R2MS_MASK) ? 1 : 2;\n\t\treturn 0;\n\tcase hwmon_temp_fault:\n\t\tif (channel == 1)\n\t\t\t*val = !!(data->status & R1DM);\n\t\telse\n\t\t\t*val = !!(data->status & R2DM);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lm95241_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn lm95241_read_chip(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn lm95241_read_temp(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lm95241_write_chip(struct device *dev, u32 attr, int channel,\n\t\t\t      long val)\n{\n\tstruct lm95241_data *data = dev_get_drvdata(dev);\n\tint convrate;\n\tu8 config;\n\tint ret;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\tconfig = data->config & ~CFG_CRMASK;\n\t\tif (val < 130) {\n\t\t\tconvrate = 76;\n\t\t\tconfig |= CFG_CR0076;\n\t\t} else if (val < 590) {\n\t\t\tconvrate = 182;\n\t\t\tconfig |= CFG_CR0182;\n\t\t} else if (val < 1850) {\n\t\t\tconvrate = 1000;\n\t\t\tconfig |= CFG_CR1000;\n\t\t} else {\n\t\t\tconvrate = 2700;\n\t\t\tconfig |= CFG_CR2700;\n\t\t}\n\t\tdata->interval = convrate;\n\t\tdata->config = config;\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t\tLM95241_REG_RW_CONFIG, config);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic int lm95241_write_temp(struct device *dev, u32 attr, int channel,\n\t\t\t      long val)\n{\n\tstruct lm95241_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (attr) {\n\tcase hwmon_temp_min:\n\t\tif (channel == 1) {\n\t\t\tif (val < 0)\n\t\t\t\tdata->config |= R1DF_MASK;\n\t\t\telse\n\t\t\t\tdata->config &= ~R1DF_MASK;\n\t\t} else {\n\t\t\tif (val < 0)\n\t\t\t\tdata->config |= R2DF_MASK;\n\t\t\telse\n\t\t\t\tdata->config &= ~R2DF_MASK;\n\t\t}\n\t\tdata->valid = false;\n\t\tret = i2c_smbus_write_byte_data(client, LM95241_REG_RW_CONFIG,\n\t\t\t\t\t\tdata->config);\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\tif (channel == 1) {\n\t\t\tif (val <= 127875)\n\t\t\t\tdata->config |= R1DF_MASK;\n\t\t\telse\n\t\t\t\tdata->config &= ~R1DF_MASK;\n\t\t} else {\n\t\t\tif (val <= 127875)\n\t\t\t\tdata->config |= R2DF_MASK;\n\t\t\telse\n\t\t\t\tdata->config &= ~R2DF_MASK;\n\t\t}\n\t\tdata->valid = false;\n\t\tret = i2c_smbus_write_byte_data(client, LM95241_REG_RW_CONFIG,\n\t\t\t\t\t\tdata->config);\n\t\tbreak;\n\tcase hwmon_temp_type:\n\t\tif (val != 1 && val != 2) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (channel == 1) {\n\t\t\tdata->trutherm &= ~(TT_MASK << TT1_SHIFT);\n\t\t\tif (val == 1) {\n\t\t\t\tdata->model |= R1MS_MASK;\n\t\t\t\tdata->trutherm |= (TT_ON << TT1_SHIFT);\n\t\t\t} else {\n\t\t\t\tdata->model &= ~R1MS_MASK;\n\t\t\t\tdata->trutherm |= (TT_OFF << TT1_SHIFT);\n\t\t\t}\n\t\t} else {\n\t\t\tdata->trutherm &= ~(TT_MASK << TT2_SHIFT);\n\t\t\tif (val == 1) {\n\t\t\t\tdata->model |= R2MS_MASK;\n\t\t\t\tdata->trutherm |= (TT_ON << TT2_SHIFT);\n\t\t\t} else {\n\t\t\t\tdata->model &= ~R2MS_MASK;\n\t\t\t\tdata->trutherm |= (TT_OFF << TT2_SHIFT);\n\t\t\t}\n\t\t}\n\t\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\tLM95241_REG_RW_REMOTE_MODEL,\n\t\t\t\t\t\tdata->model);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = i2c_smbus_write_byte_data(client, LM95241_REG_RW_TRUTHERM,\n\t\t\t\t\t\tdata->trutherm);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\nstatic int lm95241_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn lm95241_write_chip(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn lm95241_write_temp(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t lm95241_is_visible(const void *data,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_update_interval:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_fault:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_min:\n\t\tcase hwmon_temp_max:\n\t\tcase hwmon_temp_type:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int lm95241_detect(struct i2c_client *new_client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = new_client->adapter;\n\tconst char *name;\n\tint mfg_id, chip_id;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tmfg_id = i2c_smbus_read_byte_data(new_client, LM95241_REG_R_MAN_ID);\n\tif (mfg_id != NATSEMI_MAN_ID)\n\t\treturn -ENODEV;\n\n\tchip_id = i2c_smbus_read_byte_data(new_client, LM95241_REG_R_CHIP_ID);\n\tswitch (chip_id) {\n\tcase LM95231_CHIP_ID:\n\t\tname = \"lm95231\";\n\t\tbreak;\n\tcase LM95241_CHIP_ID:\n\t\tname = \"lm95241\";\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tstrscpy(info->type, name, I2C_NAME_SIZE);\n\treturn 0;\n}\n\nstatic void lm95241_init_client(struct i2c_client *client,\n\t\t\t\tstruct lm95241_data *data)\n{\n\tdata->interval = 1000;\n\tdata->config = CFG_CR1000;\n\tdata->trutherm = (TT_OFF << TT1_SHIFT) | (TT_OFF << TT2_SHIFT);\n\n\ti2c_smbus_write_byte_data(client, LM95241_REG_RW_CONFIG, data->config);\n\ti2c_smbus_write_byte_data(client, LM95241_REG_RW_REM_FILTER,\n\t\t\t\t  R1FE_MASK | R2FE_MASK);\n\ti2c_smbus_write_byte_data(client, LM95241_REG_RW_TRUTHERM,\n\t\t\t\t  data->trutherm);\n\ti2c_smbus_write_byte_data(client, LM95241_REG_RW_REMOTE_MODEL,\n\t\t\t\t  data->model);\n}\n\nstatic const struct hwmon_channel_info * const lm95241_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t   HWMON_T_TYPE | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t   HWMON_T_TYPE | HWMON_T_FAULT),\n\tNULL\n};\n\nstatic const struct hwmon_ops lm95241_hwmon_ops = {\n\t.is_visible = lm95241_is_visible,\n\t.read = lm95241_read,\n\t.write = lm95241_write,\n};\n\nstatic const struct hwmon_chip_info lm95241_chip_info = {\n\t.ops = &lm95241_hwmon_ops,\n\t.info = lm95241_info,\n};\n\nstatic int lm95241_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct lm95241_data *data;\n\tstruct device *hwmon_dev;\n\n\tdata = devm_kzalloc(dev, sizeof(struct lm95241_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tlm95241_init_client(client, data);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   &lm95241_chip_info,\n\t\t\t\t\t\t\t   NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\n \nstatic const struct i2c_device_id lm95241_id[] = {\n\t{ \"lm95231\", 0 },\n\t{ \"lm95241\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm95241_id);\n\nstatic struct i2c_driver lm95241_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= DEVNAME,\n\t},\n\t.probe\t\t= lm95241_probe,\n\t.id_table\t= lm95241_id,\n\t.detect\t\t= lm95241_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(lm95241_driver);\n\nMODULE_AUTHOR(\"Davide Rizzo <elpa.rizzo@gmail.com>\");\nMODULE_DESCRIPTION(\"LM95231/LM95241 sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}