{
  "module_name": "stts751.c",
  "hash_id": "d096ed54ebfea2c6fb257913fe44eedc4c4ff702a24c7a5c703fb378c9956f37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/stts751.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/util_macros.h>\n\n#define DEVNAME \"stts751\"\n\nstatic const unsigned short normal_i2c[] = {\n\t0x48, 0x49, 0x38, 0x39,   \n\t0x4A, 0x4B, 0x3A, 0x3B,   \n\tI2C_CLIENT_END };\n\n#define STTS751_REG_TEMP_H\t0x00\n#define STTS751_REG_STATUS\t0x01\n#define STTS751_STATUS_TRIPT\tBIT(0)\n#define STTS751_STATUS_TRIPL\tBIT(5)\n#define STTS751_STATUS_TRIPH\tBIT(6)\n#define STTS751_REG_TEMP_L\t0x02\n#define STTS751_REG_CONF\t0x03\n#define STTS751_CONF_RES_MASK\t0x0C\n#define STTS751_CONF_RES_SHIFT  2\n#define STTS751_CONF_EVENT_DIS  BIT(7)\n#define STTS751_CONF_STOP\tBIT(6)\n#define STTS751_REG_RATE\t0x04\n#define STTS751_REG_HLIM_H\t0x05\n#define STTS751_REG_HLIM_L\t0x06\n#define STTS751_REG_LLIM_H\t0x07\n#define STTS751_REG_LLIM_L\t0x08\n#define STTS751_REG_TLIM\t0x20\n#define STTS751_REG_HYST\t0x21\n#define STTS751_REG_SMBUS_TO\t0x22\n\n#define STTS751_REG_PROD_ID\t0xFD\n#define STTS751_REG_MAN_ID\t0xFE\n#define STTS751_REG_REV_ID\t0xFF\n\n#define STTS751_0_PROD_ID\t0x00\n#define STTS751_1_PROD_ID\t0x01\n#define ST_MAN_ID\t\t0x53\n\n \nstatic const int stts751_intervals[] = {\n\t16000, 8000, 4000, 2000, 1000, 500, 250, 125, 63, 31\n};\n\nstatic const struct i2c_device_id stts751_id[] = {\n\t{ \"stts751\", 0 },\n\t{ }\n};\n\nstatic const struct of_device_id __maybe_unused stts751_of_match[] = {\n\t{ .compatible = \"stts751\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, stts751_of_match);\n\nstruct stts751_priv {\n\tstruct device *dev;\n\tstruct i2c_client *client;\n\tstruct mutex access_lock;\n\tu8 interval;\n\tint res;\n\tint event_max, event_min;\n\tint therm;\n\tint hyst;\n\tbool smbus_timeout;\n\tint temp;\n\tunsigned long last_update, last_alert_update;\n\tu8 config;\n\tbool min_alert, max_alert, therm_trip;\n\tbool data_valid, alert_valid;\n\tbool notify_max, notify_min;\n};\n\n \nstatic int stts751_to_deg(s16 hw_val)\n{\n\treturn hw_val * 125 / 32;\n}\n\nstatic s32 stts751_to_hw(int val)\n{\n\treturn DIV_ROUND_CLOSEST(val, 125) * 32;\n}\n\nstatic int stts751_adjust_resolution(struct stts751_priv *priv)\n{\n\tu8 res;\n\n\tswitch (priv->interval) {\n\tcase 9:\n\t\t \n\t\tres = 0;\n\t\tbreak;\n\tcase 8:\n\t\t \n\t\tres = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tres = 3;\n\t\tbreak;\n\t}\n\n\tif (priv->res == res)\n\t\treturn 0;\n\n\tpriv->config &= ~STTS751_CONF_RES_MASK;\n\tpriv->config |= res << STTS751_CONF_RES_SHIFT;\n\tdev_dbg(&priv->client->dev, \"setting res %d. config %x\",\n\t\tres, priv->config);\n\tpriv->res = res;\n\n\treturn i2c_smbus_write_byte_data(priv->client,\n\t\t\t\tSTTS751_REG_CONF, priv->config);\n}\n\nstatic int stts751_update_temp(struct stts751_priv *priv)\n{\n\ts32 integer1, integer2, frac;\n\n\t \n\tinteger1 = i2c_smbus_read_byte_data(priv->client, STTS751_REG_TEMP_H);\n\tif (integer1 < 0) {\n\t\tdev_dbg(&priv->client->dev,\n\t\t\t\"I2C read failed (temp H). ret: %x\\n\", integer1);\n\t\treturn integer1;\n\t}\n\n\tfrac = i2c_smbus_read_byte_data(priv->client, STTS751_REG_TEMP_L);\n\tif (frac < 0) {\n\t\tdev_dbg(&priv->client->dev,\n\t\t\t\"I2C read failed (temp L). ret: %x\\n\", frac);\n\t\treturn frac;\n\t}\n\n\tinteger2 = i2c_smbus_read_byte_data(priv->client, STTS751_REG_TEMP_H);\n\tif (integer2 < 0) {\n\t\tdev_dbg(&priv->client->dev,\n\t\t\t\"I2C 2nd read failed (temp H). ret: %x\\n\", integer2);\n\t\treturn integer2;\n\t}\n\n\tif (integer1 != integer2) {\n\t\tfrac = i2c_smbus_read_byte_data(priv->client,\n\t\t\t\t\t\tSTTS751_REG_TEMP_L);\n\t\tif (frac < 0) {\n\t\t\tdev_dbg(&priv->client->dev,\n\t\t\t\t\"I2C 2nd read failed (temp L). ret: %x\\n\",\n\t\t\t\tfrac);\n\t\t\treturn frac;\n\t\t}\n\t}\n\n\tpriv->temp = stts751_to_deg((integer1 << 8) | frac);\n\treturn 0;\n}\n\nstatic int stts751_set_temp_reg16(struct stts751_priv *priv, int temp,\n\t\t\t\t  u8 hreg, u8 lreg)\n{\n\ts32 hwval;\n\tint ret;\n\n\thwval = stts751_to_hw(temp);\n\n\tret = i2c_smbus_write_byte_data(priv->client, hreg, hwval >> 8);\n\tif (ret)\n\t\treturn ret;\n\n\treturn i2c_smbus_write_byte_data(priv->client, lreg, hwval & 0xff);\n}\n\nstatic int stts751_set_temp_reg8(struct stts751_priv *priv, int temp, u8 reg)\n{\n\ts32 hwval;\n\n\thwval = stts751_to_hw(temp);\n\treturn i2c_smbus_write_byte_data(priv->client, reg, hwval >> 8);\n}\n\nstatic int stts751_read_reg16(struct stts751_priv *priv, int *temp,\n\t\t\t      u8 hreg, u8 lreg)\n{\n\tint integer, frac;\n\n\tinteger = i2c_smbus_read_byte_data(priv->client, hreg);\n\tif (integer < 0)\n\t\treturn integer;\n\n\tfrac = i2c_smbus_read_byte_data(priv->client, lreg);\n\tif (frac < 0)\n\t\treturn frac;\n\n\t*temp = stts751_to_deg((integer << 8) | frac);\n\n\treturn 0;\n}\n\nstatic int stts751_read_reg8(struct stts751_priv *priv, int *temp, u8 reg)\n{\n\tint integer;\n\n\tinteger = i2c_smbus_read_byte_data(priv->client, reg);\n\tif (integer < 0)\n\t\treturn integer;\n\n\t*temp = stts751_to_deg(integer << 8);\n\n\treturn 0;\n}\n\n \nstatic int stts751_update_alert(struct stts751_priv *priv)\n{\n\tint ret;\n\tbool conv_done;\n\tint cache_time = msecs_to_jiffies(stts751_intervals[priv->interval]);\n\n\t \n\tcache_time += cache_time / 10;\n\n\tret = i2c_smbus_read_byte_data(priv->client, STTS751_REG_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(&priv->client->dev, \"status reg %x\\n\", ret);\n\tconv_done = ret & (STTS751_STATUS_TRIPH | STTS751_STATUS_TRIPL);\n\t \n\tif (time_after(jiffies,\tpriv->last_alert_update + cache_time) ||\n\t    conv_done || !priv->alert_valid) {\n\t\tpriv->max_alert = false;\n\t\tpriv->min_alert = false;\n\t\tpriv->alert_valid = true;\n\t\tpriv->last_alert_update = jiffies;\n\t\tdev_dbg(&priv->client->dev, \"invalidating alert cache\\n\");\n\t}\n\n\tpriv->max_alert |= !!(ret & STTS751_STATUS_TRIPH);\n\tpriv->min_alert |= !!(ret & STTS751_STATUS_TRIPL);\n\tpriv->therm_trip = !!(ret & STTS751_STATUS_TRIPT);\n\n\tdev_dbg(&priv->client->dev, \"max_alert: %d, min_alert: %d, therm_trip: %d\\n\",\n\t\tpriv->max_alert, priv->min_alert, priv->therm_trip);\n\n\treturn 0;\n}\n\nstatic void stts751_alert(struct i2c_client *client,\n\t\t\t  enum i2c_alert_protocol type, unsigned int data)\n{\n\tint ret;\n\tstruct stts751_priv *priv = i2c_get_clientdata(client);\n\n\tif (type != I2C_PROTOCOL_SMBUS_ALERT)\n\t\treturn;\n\n\tdev_dbg(&client->dev, \"alert!\");\n\n\tmutex_lock(&priv->access_lock);\n\tret = stts751_update_alert(priv);\n\tif (ret < 0) {\n\t\t \n\t\tpriv->max_alert = true;\n\t\tpriv->min_alert = true;\n\n\t\tdev_warn(priv->dev,\n\t\t\t \"Alert received, but can't communicate to the device. Triggering all alarms!\");\n\t}\n\n\tif (priv->max_alert) {\n\t\tif (priv->notify_max)\n\t\t\tdev_notice(priv->dev, \"got alert for HIGH temperature\");\n\t\tpriv->notify_max = false;\n\n\t\t \n\t\tsysfs_notify(&priv->dev->kobj, NULL, \"temp1_max_alarm\");\n\t}\n\n\tif (priv->min_alert) {\n\t\tif (priv->notify_min)\n\t\t\tdev_notice(priv->dev, \"got alert for LOW temperature\");\n\t\tpriv->notify_min = false;\n\n\t\t \n\t\tsysfs_notify(&priv->dev->kobj, NULL, \"temp1_min_alarm\");\n\t}\n\n\tif (priv->min_alert || priv->max_alert)\n\t\tkobject_uevent(&priv->dev->kobj, KOBJ_CHANGE);\n\n\tmutex_unlock(&priv->access_lock);\n}\n\nstatic int stts751_update(struct stts751_priv *priv)\n{\n\tint ret;\n\tint cache_time = msecs_to_jiffies(stts751_intervals[priv->interval]);\n\n\tif (time_after(jiffies,\tpriv->last_update + cache_time) ||\n\t    !priv->data_valid) {\n\t\tret = stts751_update_temp(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = stts751_update_alert(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpriv->data_valid = true;\n\t\tpriv->last_update = jiffies;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t max_alarm_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\tmutex_lock(&priv->access_lock);\n\tret = stts751_update(priv);\n\tif (!ret)\n\t\tpriv->notify_max = true;\n\tmutex_unlock(&priv->access_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", priv->max_alert);\n}\n\nstatic ssize_t min_alarm_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\tmutex_lock(&priv->access_lock);\n\tret = stts751_update(priv);\n\tif (!ret)\n\t\tpriv->notify_min = true;\n\tmutex_unlock(&priv->access_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", priv->min_alert);\n}\n\nstatic ssize_t input_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint ret;\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\tmutex_lock(&priv->access_lock);\n\tret = stts751_update(priv);\n\tmutex_unlock(&priv->access_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", priv->temp);\n}\n\nstatic ssize_t therm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", priv->therm);\n}\n\nstatic ssize_t therm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tint ret;\n\tlong temp;\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\tif (kstrtol(buf, 10, &temp) < 0)\n\t\treturn -EINVAL;\n\n\t \n\ttemp = clamp_val(temp, -64000, 127937);\n\tmutex_lock(&priv->access_lock);\n\tret = stts751_set_temp_reg8(priv, temp, STTS751_REG_TLIM);\n\tif (ret)\n\t\tgoto exit;\n\n\tdev_dbg(&priv->client->dev, \"setting therm %ld\", temp);\n\n\t \n\tpriv->hyst = temp - (priv->therm - priv->hyst);\n\tpriv->therm = temp;\n\nexit:\n\tmutex_unlock(&priv->access_lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t hyst_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", priv->hyst);\n}\n\nstatic ssize_t hyst_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tint ret;\n\tlong temp;\n\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\tif (kstrtol(buf, 10, &temp) < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->access_lock);\n\t \n\ttemp = clamp_val(temp, -64000, priv->therm);\n\tpriv->hyst = temp;\n\tdev_dbg(&priv->client->dev, \"setting hyst %ld\", temp);\n\ttemp = priv->therm - temp;\n\tret = stts751_set_temp_reg8(priv, temp, STTS751_REG_HYST);\n\tmutex_unlock(&priv->access_lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t therm_trip_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\tmutex_lock(&priv->access_lock);\n\tret = stts751_update(priv);\n\tmutex_unlock(&priv->access_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", priv->therm_trip);\n}\n\nstatic ssize_t max_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", priv->event_max);\n}\n\nstatic ssize_t max_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tint ret;\n\tlong temp;\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\tif (kstrtol(buf, 10, &temp) < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->access_lock);\n\t \n\ttemp = clamp_val(temp, priv->event_min, 127937);\n\tret = stts751_set_temp_reg16(priv, temp,\n\t\t\t\t     STTS751_REG_HLIM_H, STTS751_REG_HLIM_L);\n\tif (ret)\n\t\tgoto exit;\n\n\tdev_dbg(&priv->client->dev, \"setting event max %ld\", temp);\n\tpriv->event_max = temp;\n\tret = count;\nexit:\n\tmutex_unlock(&priv->access_lock);\n\treturn ret;\n}\n\nstatic ssize_t min_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", priv->event_min);\n}\n\nstatic ssize_t min_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tint ret;\n\tlong temp;\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\tif (kstrtol(buf, 10, &temp) < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->access_lock);\n\t \n\ttemp = clamp_val(temp, -64000, priv->event_max);\n\tret = stts751_set_temp_reg16(priv, temp,\n\t\t\t\t     STTS751_REG_LLIM_H, STTS751_REG_LLIM_L);\n\tif (ret)\n\t\tgoto exit;\n\n\tdev_dbg(&priv->client->dev, \"setting event min %ld\", temp);\n\tpriv->event_min = temp;\n\tret = count;\nexit:\n\tmutex_unlock(&priv->access_lock);\n\treturn ret;\n}\n\nstatic ssize_t interval_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  stts751_intervals[priv->interval]);\n}\n\nstatic ssize_t interval_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tunsigned long val;\n\tint idx;\n\tint ret = count;\n\tstruct stts751_priv *priv = dev_get_drvdata(dev);\n\n\tif (kstrtoul(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tidx = find_closest_descending(val, stts751_intervals,\n\t\t\t\t      ARRAY_SIZE(stts751_intervals));\n\n\tdev_dbg(&priv->client->dev, \"setting interval. req:%lu, idx: %d, val: %d\",\n\t\tval, idx, stts751_intervals[idx]);\n\n\tmutex_lock(&priv->access_lock);\n\tif (priv->interval == idx)\n\t\tgoto exit;\n\n\t \n\n\t \n\tif (priv->interval < idx) {\n\t\tdev_dbg(&priv->client->dev, \"lower resolution, then modify convrate\");\n\t\tpriv->interval = idx;\n\t\tret = stts751_adjust_resolution(priv);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tret = i2c_smbus_write_byte_data(priv->client, STTS751_REG_RATE, idx);\n\tif (ret)\n\t\tgoto exit;\n\t \n\tif (priv->interval != idx) {\n\t\tdev_dbg(&priv->client->dev, \"modify convrate, then raise resolution\");\n\t\tpriv->interval = idx;\n\t\tret = stts751_adjust_resolution(priv);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\tret = count;\nexit:\n\tmutex_unlock(&priv->access_lock);\n\n\treturn ret;\n}\n\nstatic int stts751_detect(struct i2c_client *new_client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = new_client->adapter;\n\tconst char *name;\n\tint tmp;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\ttmp = i2c_smbus_read_byte_data(new_client, STTS751_REG_MAN_ID);\n\tif (tmp != ST_MAN_ID)\n\t\treturn -ENODEV;\n\n\t \n\ttmp = i2c_smbus_read_byte_data(new_client, STTS751_REG_TEMP_L);\n\tif (tmp & 0xf)\n\t\treturn -ENODEV;\n\n\ttmp = i2c_smbus_read_byte_data(new_client, STTS751_REG_HLIM_L);\n\tif (tmp & 0xf)\n\t\treturn -ENODEV;\n\n\ttmp = i2c_smbus_read_byte_data(new_client, STTS751_REG_LLIM_L);\n\tif (tmp & 0xf)\n\t\treturn -ENODEV;\n\n\t \n\ttmp = i2c_smbus_read_byte_data(new_client, STTS751_REG_SMBUS_TO);\n\tif (tmp & 0x7f)\n\t\treturn -ENODEV;\n\n\ttmp = i2c_smbus_read_byte_data(new_client, STTS751_REG_PROD_ID);\n\n\tswitch (tmp) {\n\tcase STTS751_0_PROD_ID:\n\t\tname = \"STTS751-0\";\n\t\tbreak;\n\tcase STTS751_1_PROD_ID:\n\t\tname = \"STTS751-1\";\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(&new_client->dev, \"Chip %s detected\", name);\n\n\tstrscpy(info->type, stts751_id[0].name, I2C_NAME_SIZE);\n\treturn 0;\n}\n\nstatic int stts751_read_chip_config(struct stts751_priv *priv)\n{\n\tint ret;\n\tint tmp;\n\n\tret = i2c_smbus_read_byte_data(priv->client, STTS751_REG_CONF);\n\tif (ret < 0)\n\t\treturn ret;\n\tpriv->config = ret;\n\tpriv->res = (ret & STTS751_CONF_RES_MASK) >> STTS751_CONF_RES_SHIFT;\n\n\tret = i2c_smbus_read_byte_data(priv->client, STTS751_REG_RATE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret >= ARRAY_SIZE(stts751_intervals)) {\n\t\tdev_err(priv->dev, \"Unrecognized conversion rate 0x%x\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\tpriv->interval = ret;\n\n\tret = stts751_read_reg16(priv, &priv->event_max,\n\t\t\t\t STTS751_REG_HLIM_H, STTS751_REG_HLIM_L);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stts751_read_reg16(priv, &priv->event_min,\n\t\t\t\t STTS751_REG_LLIM_H, STTS751_REG_LLIM_L);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stts751_read_reg8(priv, &priv->therm, STTS751_REG_TLIM);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stts751_read_reg8(priv, &tmp, STTS751_REG_HYST);\n\tif (ret)\n\t\treturn ret;\n\tpriv->hyst = priv->therm - tmp;\n\n\treturn 0;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, input, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, max, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_alarm, min_alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, max_alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_crit, therm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_crit_hyst, hyst, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_crit_alarm, therm_trip, 0);\nstatic SENSOR_DEVICE_ATTR_RW(update_interval, interval, 0);\n\nstatic struct attribute *stts751_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_update_interval.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(stts751);\n\nstatic int stts751_probe(struct i2c_client *client)\n{\n\tstruct stts751_priv *priv;\n\tint ret;\n\tbool smbus_nto;\n\tint rev_id;\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->client = client;\n\tpriv->notify_max = true;\n\tpriv->notify_min = true;\n\ti2c_set_clientdata(client, priv);\n\tmutex_init(&priv->access_lock);\n\n\tif (device_property_present(&client->dev,\n\t\t\t\t    \"smbus-timeout-disable\")) {\n\t\tsmbus_nto = device_property_read_bool(&client->dev,\n\t\t\t\t\t\t      \"smbus-timeout-disable\");\n\n\t\tret = i2c_smbus_write_byte_data(client,\tSTTS751_REG_SMBUS_TO,\n\t\t\t\t\t\tsmbus_nto ? 0 : 0x80);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\trev_id = i2c_smbus_read_byte_data(client, STTS751_REG_REV_ID);\n\tif (rev_id < 0)\n\t\treturn -ENODEV;\n\tif (rev_id != 0x1) {\n\t\tdev_dbg(&client->dev, \"Chip revision 0x%x is untested\\n\",\n\t\t\trev_id);\n\t}\n\n\tret = stts751_read_chip_config(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->config &= ~(STTS751_CONF_STOP | STTS751_CONF_EVENT_DIS);\n\tret = i2c_smbus_write_byte_data(client,\tSTTS751_REG_CONF, priv->config);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->dev = devm_hwmon_device_register_with_groups(&client->dev,\n\t\t\t\t\t\t\tclient->name, priv,\n\t\t\t\t\t\t\tstts751_groups);\n\treturn PTR_ERR_OR_ZERO(priv->dev);\n}\n\nMODULE_DEVICE_TABLE(i2c, stts751_id);\n\nstatic struct i2c_driver stts751_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= DEVNAME,\n\t\t.of_match_table = of_match_ptr(stts751_of_match),\n\t},\n\t.probe\t\t= stts751_probe,\n\t.id_table\t= stts751_id,\n\t.detect\t\t= stts751_detect,\n\t.alert\t\t= stts751_alert,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(stts751_driver);\n\nMODULE_AUTHOR(\"Andrea Merello <andrea.merello@gmail.com>\");\nMODULE_DESCRIPTION(\"STTS751 sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}