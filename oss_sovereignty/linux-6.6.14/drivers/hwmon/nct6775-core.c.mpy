{
  "module_name": "nct6775-core.c",
  "hash_id": "b2e3b0b6b8f8db9a5c9179500bd3a7dd2d6fe1f382694c0d65d5240a0cc29e1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/nct6775-core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/nospec.h>\n#include <linux/regmap.h>\n#include \"lm75.h\"\n#include \"nct6775.h\"\n\n#undef DEFAULT_SYMBOL_NAMESPACE\n#define DEFAULT_SYMBOL_NAMESPACE HWMON_NCT6775\n\n#define USE_ALTERNATE\n\n \nstatic const char * const nct6775_device_names[] = {\n\t\"nct6106\",\n\t\"nct6116\",\n\t\"nct6775\",\n\t\"nct6776\",\n\t\"nct6779\",\n\t\"nct6791\",\n\t\"nct6792\",\n\t\"nct6793\",\n\t\"nct6795\",\n\t\"nct6796\",\n\t\"nct6797\",\n\t\"nct6798\",\n\t\"nct6799\",\n};\n\n \n\n \n\nstatic const u16 NCT6775_REG_IN_MAX[] = {\n\t0x2b, 0x2d, 0x2f, 0x31, 0x33, 0x35, 0x37, 0x554, 0x556, 0x558, 0x55a,\n\t0x55c, 0x55e, 0x560, 0x562, 0x564, 0x570, 0x572 };\nstatic const u16 NCT6775_REG_IN_MIN[] = {\n\t0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x555, 0x557, 0x559, 0x55b,\n\t0x55d, 0x55f, 0x561, 0x563, 0x565, 0x571, 0x573 };\nstatic const u16 NCT6775_REG_IN[] = {\n\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x550, 0x551, 0x552\n};\n\n#define NCT6775_REG_VBAT\t\t0x5D\n#define NCT6775_REG_DIODE\t\t0x5E\n#define NCT6775_DIODE_MASK\t\t0x02\n\nstatic const u16 NCT6775_REG_ALARM[NUM_REG_ALARM] = { 0x459, 0x45A, 0x45B };\n\nstatic const s8 NCT6775_ALARM_BITS[NUM_ALARM_BITS] = {\n\t 0,  1,  2,  3,  8, 21, 20, 16, 17, -1, -1, -1,\t   \n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t 6,  7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t 4,  5, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t12, -1,\t\t\t\t\t\t   \n};\n\nstatic const u16 NCT6775_REG_BEEP[NUM_REG_BEEP] = { 0x56, 0x57, 0x453, 0x4e };\n\nstatic const s8 NCT6775_BEEP_BITS[NUM_BEEP_BITS] = {\n\t 0,  1,  2,  3,  8,  9, 10, 16, 17, -1, -1, -1,\t   \n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t 6,  7, 11, 28, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t 4,  5, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t12, -1, 21\t\t\t\t\t   \n};\n\n \nstatic const u8 NCT6775_REG_PWM_MODE[] = { 0x04, 0x04, 0x12 };\nstatic const u8 NCT6775_PWM_MODE_MASK[] = { 0x01, 0x02, 0x01 };\n\n \n\nstatic const u16 NCT6775_REG_TARGET[] = {\n\t0x101, 0x201, 0x301, 0x801, 0x901, 0xa01, 0xb01 };\nstatic const u16 NCT6775_REG_FAN_MODE[] = {\n\t0x102, 0x202, 0x302, 0x802, 0x902, 0xa02, 0xb02 };\nstatic const u16 NCT6775_REG_FAN_STEP_DOWN_TIME[] = {\n\t0x103, 0x203, 0x303, 0x803, 0x903, 0xa03, 0xb03 };\nstatic const u16 NCT6775_REG_FAN_STEP_UP_TIME[] = {\n\t0x104, 0x204, 0x304, 0x804, 0x904, 0xa04, 0xb04 };\nstatic const u16 NCT6775_REG_FAN_STOP_OUTPUT[] = {\n\t0x105, 0x205, 0x305, 0x805, 0x905, 0xa05, 0xb05 };\nstatic const u16 NCT6775_REG_FAN_START_OUTPUT[] = {\n\t0x106, 0x206, 0x306, 0x806, 0x906, 0xa06, 0xb06 };\nstatic const u16 NCT6775_REG_FAN_MAX_OUTPUT[] = { 0x10a, 0x20a, 0x30a };\nstatic const u16 NCT6775_REG_FAN_STEP_OUTPUT[] = { 0x10b, 0x20b, 0x30b };\n\nstatic const u16 NCT6775_REG_FAN_STOP_TIME[] = {\n\t0x107, 0x207, 0x307, 0x807, 0x907, 0xa07, 0xb07 };\nstatic const u16 NCT6775_REG_PWM[] = {\n\t0x109, 0x209, 0x309, 0x809, 0x909, 0xa09, 0xb09 };\nstatic const u16 NCT6775_REG_PWM_READ[] = {\n\t0x01, 0x03, 0x11, 0x13, 0x15, 0xa09, 0xb09 };\n\nstatic const u16 NCT6775_REG_FAN[] = { 0x630, 0x632, 0x634, 0x636, 0x638 };\nstatic const u16 NCT6775_REG_FAN_MIN[] = { 0x3b, 0x3c, 0x3d };\nstatic const u16 NCT6775_REG_FAN_PULSES[NUM_FAN] = {\n\t0x641, 0x642, 0x643, 0x644 };\nstatic const u16 NCT6775_FAN_PULSE_SHIFT[NUM_FAN] = { };\n\nstatic const u16 NCT6775_REG_TEMP[] = {\n\t0x27, 0x150, 0x250, 0x62b, 0x62c, 0x62d };\n\nstatic const u16 NCT6775_REG_TEMP_MON[] = { 0x73, 0x75, 0x77 };\n\nstatic const u16 NCT6775_REG_TEMP_CONFIG[ARRAY_SIZE(NCT6775_REG_TEMP)] = {\n\t0, 0x152, 0x252, 0x628, 0x629, 0x62A };\nstatic const u16 NCT6775_REG_TEMP_HYST[ARRAY_SIZE(NCT6775_REG_TEMP)] = {\n\t0x3a, 0x153, 0x253, 0x673, 0x678, 0x67D };\nstatic const u16 NCT6775_REG_TEMP_OVER[ARRAY_SIZE(NCT6775_REG_TEMP)] = {\n\t0x39, 0x155, 0x255, 0x672, 0x677, 0x67C };\n\nstatic const u16 NCT6775_REG_TEMP_SOURCE[ARRAY_SIZE(NCT6775_REG_TEMP)] = {\n\t0x621, 0x622, 0x623, 0x624, 0x625, 0x626 };\n\nstatic const u16 NCT6775_REG_TEMP_SEL[] = {\n\t0x100, 0x200, 0x300, 0x800, 0x900, 0xa00, 0xb00 };\n\nstatic const u16 NCT6775_REG_WEIGHT_TEMP_SEL[] = {\n\t0x139, 0x239, 0x339, 0x839, 0x939, 0xa39 };\nstatic const u16 NCT6775_REG_WEIGHT_TEMP_STEP[] = {\n\t0x13a, 0x23a, 0x33a, 0x83a, 0x93a, 0xa3a };\nstatic const u16 NCT6775_REG_WEIGHT_TEMP_STEP_TOL[] = {\n\t0x13b, 0x23b, 0x33b, 0x83b, 0x93b, 0xa3b };\nstatic const u16 NCT6775_REG_WEIGHT_DUTY_STEP[] = {\n\t0x13c, 0x23c, 0x33c, 0x83c, 0x93c, 0xa3c };\nstatic const u16 NCT6775_REG_WEIGHT_TEMP_BASE[] = {\n\t0x13d, 0x23d, 0x33d, 0x83d, 0x93d, 0xa3d };\n\nstatic const u16 NCT6775_REG_TEMP_OFFSET[] = { 0x454, 0x455, 0x456 };\n\nstatic const u16 NCT6775_REG_AUTO_TEMP[] = {\n\t0x121, 0x221, 0x321, 0x821, 0x921, 0xa21, 0xb21 };\nstatic const u16 NCT6775_REG_AUTO_PWM[] = {\n\t0x127, 0x227, 0x327, 0x827, 0x927, 0xa27, 0xb27 };\n\n#define NCT6775_AUTO_TEMP(data, nr, p)\t((data)->REG_AUTO_TEMP[nr] + (p))\n#define NCT6775_AUTO_PWM(data, nr, p)\t((data)->REG_AUTO_PWM[nr] + (p))\n\nstatic const u16 NCT6775_REG_CRITICAL_ENAB[] = { 0x134, 0x234, 0x334 };\n\nstatic const u16 NCT6775_REG_CRITICAL_TEMP[] = {\n\t0x135, 0x235, 0x335, 0x835, 0x935, 0xa35, 0xb35 };\nstatic const u16 NCT6775_REG_CRITICAL_TEMP_TOLERANCE[] = {\n\t0x138, 0x238, 0x338, 0x838, 0x938, 0xa38, 0xb38 };\n\nstatic const char *const nct6775_temp_label[] = {\n\t\"\",\n\t\"SYSTIN\",\n\t\"CPUTIN\",\n\t\"AUXTIN\",\n\t\"AMD SB-TSI\",\n\t\"PECI Agent 0\",\n\t\"PECI Agent 1\",\n\t\"PECI Agent 2\",\n\t\"PECI Agent 3\",\n\t\"PECI Agent 4\",\n\t\"PECI Agent 5\",\n\t\"PECI Agent 6\",\n\t\"PECI Agent 7\",\n\t\"PCH_CHIP_CPU_MAX_TEMP\",\n\t\"PCH_CHIP_TEMP\",\n\t\"PCH_CPU_TEMP\",\n\t\"PCH_MCH_TEMP\",\n\t\"PCH_DIM0_TEMP\",\n\t\"PCH_DIM1_TEMP\",\n\t\"PCH_DIM2_TEMP\",\n\t\"PCH_DIM3_TEMP\"\n};\n\n#define NCT6775_TEMP_MASK\t0x001ffffe\n#define NCT6775_VIRT_TEMP_MASK\t0x00000000\n\nstatic const u16 NCT6775_REG_TEMP_ALTERNATE[32] = {\n\t[13] = 0x661,\n\t[14] = 0x662,\n\t[15] = 0x664,\n};\n\nstatic const u16 NCT6775_REG_TEMP_CRIT[32] = {\n\t[4] = 0xa00,\n\t[5] = 0xa01,\n\t[6] = 0xa02,\n\t[7] = 0xa03,\n\t[8] = 0xa04,\n\t[9] = 0xa05,\n\t[10] = 0xa06,\n\t[11] = 0xa07\n};\n\nstatic const u16 NCT6775_REG_TSI_TEMP[] = { 0x669 };\n\n \n\n \n#define NCT6776_REG_FAN_STEP_UP_TIME NCT6775_REG_FAN_STEP_DOWN_TIME\n#define NCT6776_REG_FAN_STEP_DOWN_TIME NCT6775_REG_FAN_STEP_UP_TIME\n\nstatic const s8 NCT6776_ALARM_BITS[NUM_ALARM_BITS] = {\n\t 0,  1,  2,  3,  8, 21, 20, 16, 17, -1, -1, -1,\t   \n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t 6,  7, 11, 10, 23, -1, -1, -1, -1, -1, -1, -1,\t   \n\t 4,  5, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t12,  9,\t\t\t\t\t\t   \n};\n\n \nstatic const u16 NCT6776_REG_BEEP[NUM_REG_BEEP] = { 0xb2, 0xb3, 0xb4, 0xb5, 0xbf };\n\nstatic const s8 NCT6776_BEEP_BITS[NUM_BEEP_BITS] = {\n\t 0,  1,  2,  3,  4,  5,  6,  7,  8, -1, -1, -1,\t   \n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t25, 26, 27, 28, 29, -1, -1, -1, -1, -1, -1, -1,\t   \n\t16, 17, 18, 19, 20, 21, -1, -1, -1, -1, -1, -1,\t   \n\t30, 31, 24\t\t\t\t\t   \n};\n\nstatic const u16 NCT6776_REG_TOLERANCE_H[] = {\n\t0x10c, 0x20c, 0x30c, 0x80c, 0x90c, 0xa0c, 0xb0c };\n\nstatic const u8 NCT6776_REG_PWM_MODE[] = { 0x04, 0, 0, 0, 0, 0 };\nstatic const u8 NCT6776_PWM_MODE_MASK[] = { 0x01, 0, 0, 0, 0, 0 };\n\nstatic const u16 NCT6776_REG_FAN_MIN[] = {\n\t0x63a, 0x63c, 0x63e, 0x640, 0x642, 0x64a, 0x64c };\nstatic const u16 NCT6776_REG_FAN_PULSES[NUM_FAN] = {\n\t0x644, 0x645, 0x646, 0x647, 0x648, 0x649 };\n\nstatic const u16 NCT6776_REG_WEIGHT_DUTY_BASE[] = {\n\t0x13e, 0x23e, 0x33e, 0x83e, 0x93e, 0xa3e };\n\nstatic const u16 NCT6776_REG_TEMP_CONFIG[ARRAY_SIZE(NCT6775_REG_TEMP)] = {\n\t0x18, 0x152, 0x252, 0x628, 0x629, 0x62A };\n\nstatic const char *const nct6776_temp_label[] = {\n\t\"\",\n\t\"SYSTIN\",\n\t\"CPUTIN\",\n\t\"AUXTIN\",\n\t\"SMBUSMASTER 0\",\n\t\"SMBUSMASTER 1\",\n\t\"SMBUSMASTER 2\",\n\t\"SMBUSMASTER 3\",\n\t\"SMBUSMASTER 4\",\n\t\"SMBUSMASTER 5\",\n\t\"SMBUSMASTER 6\",\n\t\"SMBUSMASTER 7\",\n\t\"PECI Agent 0\",\n\t\"PECI Agent 1\",\n\t\"PCH_CHIP_CPU_MAX_TEMP\",\n\t\"PCH_CHIP_TEMP\",\n\t\"PCH_CPU_TEMP\",\n\t\"PCH_MCH_TEMP\",\n\t\"PCH_DIM0_TEMP\",\n\t\"PCH_DIM1_TEMP\",\n\t\"PCH_DIM2_TEMP\",\n\t\"PCH_DIM3_TEMP\",\n\t\"BYTE_TEMP\"\n};\n\n#define NCT6776_TEMP_MASK\t0x007ffffe\n#define NCT6776_VIRT_TEMP_MASK\t0x00000000\n\nstatic const u16 NCT6776_REG_TEMP_ALTERNATE[32] = {\n\t[14] = 0x401,\n\t[15] = 0x402,\n\t[16] = 0x404,\n};\n\nstatic const u16 NCT6776_REG_TEMP_CRIT[32] = {\n\t[11] = 0x709,\n\t[12] = 0x70a,\n};\n\nstatic const u16 NCT6776_REG_TSI_TEMP[] = {\n\t0x409, 0x40b, 0x40d, 0x40f, 0x411, 0x413, 0x415, 0x417 };\n\n \n\n \nstatic const u16 NCT6779_REG_IN[] = {\n\t0x480, 0x481, 0x482, 0x483, 0x484, 0x485, 0x486, 0x487,\n\t0x488, 0x489, 0x48a, 0x48b, 0x48c, 0x48d, 0x48e, 0x48f,\n\t0x470, 0x471};\n\nstatic const u16 NCT6779_REG_ALARM[NUM_REG_ALARM] = {\n\t0x459, 0x45A, 0x45B, 0x568 };\n\nstatic const s8 NCT6779_ALARM_BITS[NUM_ALARM_BITS] = {\n\t 0,  1,  2,  3,  8, 21, 20, 16, 17, 24, 25, 26,\t   \n\t27, 28, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t 6,  7, 11, 10, 23, -1, -1, -1, -1, -1, -1, -1,\t   \n\t 4,  5, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t12,  9,\t\t\t\t\t\t   \n};\n\nstatic const s8 NCT6779_BEEP_BITS[NUM_BEEP_BITS] = {\n\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,\t   \n\t12, 13, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t25, 26, 27, 28, 29, -1, -1, -1, -1, -1, -1, -1,\t   \n\t16, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t30, 31, 24\t\t\t\t\t   \n};\n\nstatic const u16 NCT6779_REG_FAN[] = {\n\t0x4c0, 0x4c2, 0x4c4, 0x4c6, 0x4c8, 0x4ca, 0x4ce };\nstatic const u16 NCT6779_REG_FAN_PULSES[NUM_FAN] = {\n\t0x644, 0x645, 0x646, 0x647, 0x648, 0x649, 0x64f };\n\nstatic const u16 NCT6779_REG_CRITICAL_PWM_ENABLE[] = {\n\t0x136, 0x236, 0x336, 0x836, 0x936, 0xa36, 0xb36 };\n#define NCT6779_CRITICAL_PWM_ENABLE_MASK\t0x01\nstatic const u16 NCT6779_REG_CRITICAL_PWM[] = {\n\t0x137, 0x237, 0x337, 0x837, 0x937, 0xa37, 0xb37 };\n\nstatic const u16 NCT6779_REG_TEMP[] = { 0x27, 0x150 };\nstatic const u16 NCT6779_REG_TEMP_MON[] = { 0x73, 0x75, 0x77, 0x79, 0x7b };\nstatic const u16 NCT6779_REG_TEMP_CONFIG[ARRAY_SIZE(NCT6779_REG_TEMP)] = {\n\t0x18, 0x152 };\nstatic const u16 NCT6779_REG_TEMP_HYST[ARRAY_SIZE(NCT6779_REG_TEMP)] = {\n\t0x3a, 0x153 };\nstatic const u16 NCT6779_REG_TEMP_OVER[ARRAY_SIZE(NCT6779_REG_TEMP)] = {\n\t0x39, 0x155 };\n\nstatic const u16 NCT6779_REG_TEMP_OFFSET[] = {\n\t0x454, 0x455, 0x456, 0x44a, 0x44b, 0x44c, 0x44d, 0x449 };\n\nstatic const char *const nct6779_temp_label[] = {\n\t\"\",\n\t\"SYSTIN\",\n\t\"CPUTIN\",\n\t\"AUXTIN0\",\n\t\"AUXTIN1\",\n\t\"AUXTIN2\",\n\t\"AUXTIN3\",\n\t\"\",\n\t\"SMBUSMASTER 0\",\n\t\"SMBUSMASTER 1\",\n\t\"SMBUSMASTER 2\",\n\t\"SMBUSMASTER 3\",\n\t\"SMBUSMASTER 4\",\n\t\"SMBUSMASTER 5\",\n\t\"SMBUSMASTER 6\",\n\t\"SMBUSMASTER 7\",\n\t\"PECI Agent 0\",\n\t\"PECI Agent 1\",\n\t\"PCH_CHIP_CPU_MAX_TEMP\",\n\t\"PCH_CHIP_TEMP\",\n\t\"PCH_CPU_TEMP\",\n\t\"PCH_MCH_TEMP\",\n\t\"PCH_DIM0_TEMP\",\n\t\"PCH_DIM1_TEMP\",\n\t\"PCH_DIM2_TEMP\",\n\t\"PCH_DIM3_TEMP\",\n\t\"BYTE_TEMP\",\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"Virtual_TEMP\"\n};\n\n#define NCT6779_TEMP_MASK\t0x07ffff7e\n#define NCT6779_VIRT_TEMP_MASK\t0x00000000\n#define NCT6791_TEMP_MASK\t0x87ffff7e\n#define NCT6791_VIRT_TEMP_MASK\t0x80000000\n\nstatic const u16 NCT6779_REG_TEMP_ALTERNATE[32]\n\t= { 0x490, 0x491, 0x492, 0x493, 0x494, 0x495, 0, 0,\n\t    0, 0, 0, 0, 0, 0, 0, 0,\n\t    0, 0x400, 0x401, 0x402, 0x404, 0x405, 0x406, 0x407,\n\t    0x408, 0 };\n\nstatic const u16 NCT6779_REG_TEMP_CRIT[32] = {\n\t[15] = 0x709,\n\t[16] = 0x70a,\n};\n\n \n\nstatic const u16 NCT6791_REG_WEIGHT_TEMP_SEL[NUM_FAN] = { 0, 0x239 };\nstatic const u16 NCT6791_REG_WEIGHT_TEMP_STEP[NUM_FAN] = { 0, 0x23a };\nstatic const u16 NCT6791_REG_WEIGHT_TEMP_STEP_TOL[NUM_FAN] = { 0, 0x23b };\nstatic const u16 NCT6791_REG_WEIGHT_DUTY_STEP[NUM_FAN] = { 0, 0x23c };\nstatic const u16 NCT6791_REG_WEIGHT_TEMP_BASE[NUM_FAN] = { 0, 0x23d };\nstatic const u16 NCT6791_REG_WEIGHT_DUTY_BASE[NUM_FAN] = { 0, 0x23e };\n\nstatic const u16 NCT6791_REG_ALARM[NUM_REG_ALARM] = {\n\t0x459, 0x45A, 0x45B, 0x568, 0x45D };\n\nstatic const s8 NCT6791_ALARM_BITS[NUM_ALARM_BITS] = {\n\t 0,  1,  2,  3,  8, 21, 20, 16, 17, 24, 25, 26,\t   \n\t27, 28, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t 6,  7, 11, 10, 23, 33, -1, -1, -1, -1, -1, -1,\t   \n\t 4,  5, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t12,  9,\t\t\t\t\t\t   \n};\n\n \n\nstatic const u16 NCT6792_REG_TEMP_MON[] = {\n\t0x73, 0x75, 0x77, 0x79, 0x7b, 0x7d };\nstatic const u16 NCT6792_REG_BEEP[NUM_REG_BEEP] = {\n\t0xb2, 0xb3, 0xb4, 0xb5, 0xbf };\n\nstatic const char *const nct6792_temp_label[] = {\n\t\"\",\n\t\"SYSTIN\",\n\t\"CPUTIN\",\n\t\"AUXTIN0\",\n\t\"AUXTIN1\",\n\t\"AUXTIN2\",\n\t\"AUXTIN3\",\n\t\"\",\n\t\"SMBUSMASTER 0\",\n\t\"SMBUSMASTER 1\",\n\t\"SMBUSMASTER 2\",\n\t\"SMBUSMASTER 3\",\n\t\"SMBUSMASTER 4\",\n\t\"SMBUSMASTER 5\",\n\t\"SMBUSMASTER 6\",\n\t\"SMBUSMASTER 7\",\n\t\"PECI Agent 0\",\n\t\"PECI Agent 1\",\n\t\"PCH_CHIP_CPU_MAX_TEMP\",\n\t\"PCH_CHIP_TEMP\",\n\t\"PCH_CPU_TEMP\",\n\t\"PCH_MCH_TEMP\",\n\t\"PCH_DIM0_TEMP\",\n\t\"PCH_DIM1_TEMP\",\n\t\"PCH_DIM2_TEMP\",\n\t\"PCH_DIM3_TEMP\",\n\t\"BYTE_TEMP\",\n\t\"PECI Agent 0 Calibration\",\n\t\"PECI Agent 1 Calibration\",\n\t\"\",\n\t\"\",\n\t\"Virtual_TEMP\"\n};\n\n#define NCT6792_TEMP_MASK\t0x9fffff7e\n#define NCT6792_VIRT_TEMP_MASK\t0x80000000\n\nstatic const char *const nct6793_temp_label[] = {\n\t\"\",\n\t\"SYSTIN\",\n\t\"CPUTIN\",\n\t\"AUXTIN0\",\n\t\"AUXTIN1\",\n\t\"AUXTIN2\",\n\t\"AUXTIN3\",\n\t\"\",\n\t\"SMBUSMASTER 0\",\n\t\"SMBUSMASTER 1\",\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"PECI Agent 0\",\n\t\"PECI Agent 1\",\n\t\"PCH_CHIP_CPU_MAX_TEMP\",\n\t\"PCH_CHIP_TEMP\",\n\t\"PCH_CPU_TEMP\",\n\t\"PCH_MCH_TEMP\",\n\t\"Agent0 Dimm0 \",\n\t\"Agent0 Dimm1\",\n\t\"Agent1 Dimm0\",\n\t\"Agent1 Dimm1\",\n\t\"BYTE_TEMP0\",\n\t\"BYTE_TEMP1\",\n\t\"PECI Agent 0 Calibration\",\n\t\"PECI Agent 1 Calibration\",\n\t\"\",\n\t\"Virtual_TEMP\"\n};\n\n#define NCT6793_TEMP_MASK\t0xbfff037e\n#define NCT6793_VIRT_TEMP_MASK\t0x80000000\n\nstatic const char *const nct6795_temp_label[] = {\n\t\"\",\n\t\"SYSTIN\",\n\t\"CPUTIN\",\n\t\"AUXTIN0\",\n\t\"AUXTIN1\",\n\t\"AUXTIN2\",\n\t\"AUXTIN3\",\n\t\"\",\n\t\"SMBUSMASTER 0\",\n\t\"SMBUSMASTER 1\",\n\t\"SMBUSMASTER 2\",\n\t\"SMBUSMASTER 3\",\n\t\"SMBUSMASTER 4\",\n\t\"SMBUSMASTER 5\",\n\t\"SMBUSMASTER 6\",\n\t\"SMBUSMASTER 7\",\n\t\"PECI Agent 0\",\n\t\"PECI Agent 1\",\n\t\"PCH_CHIP_CPU_MAX_TEMP\",\n\t\"PCH_CHIP_TEMP\",\n\t\"PCH_CPU_TEMP\",\n\t\"PCH_MCH_TEMP\",\n\t\"Agent0 Dimm0\",\n\t\"Agent0 Dimm1\",\n\t\"Agent1 Dimm0\",\n\t\"Agent1 Dimm1\",\n\t\"BYTE_TEMP0\",\n\t\"BYTE_TEMP1\",\n\t\"PECI Agent 0 Calibration\",\n\t\"PECI Agent 1 Calibration\",\n\t\"\",\n\t\"Virtual_TEMP\"\n};\n\n#define NCT6795_TEMP_MASK\t0xbfffff7e\n#define NCT6795_VIRT_TEMP_MASK\t0x80000000\n\nstatic const char *const nct6796_temp_label[] = {\n\t\"\",\n\t\"SYSTIN\",\n\t\"CPUTIN\",\n\t\"AUXTIN0\",\n\t\"AUXTIN1\",\n\t\"AUXTIN2\",\n\t\"AUXTIN3\",\n\t\"AUXTIN4\",\n\t\"SMBUSMASTER 0\",\n\t\"SMBUSMASTER 1\",\n\t\"Virtual_TEMP\",\n\t\"Virtual_TEMP\",\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"PECI Agent 0\",\n\t\"PECI Agent 1\",\n\t\"PCH_CHIP_CPU_MAX_TEMP\",\n\t\"PCH_CHIP_TEMP\",\n\t\"PCH_CPU_TEMP\",\n\t\"PCH_MCH_TEMP\",\n\t\"Agent0 Dimm0\",\n\t\"Agent0 Dimm1\",\n\t\"Agent1 Dimm0\",\n\t\"Agent1 Dimm1\",\n\t\"BYTE_TEMP0\",\n\t\"BYTE_TEMP1\",\n\t\"PECI Agent 0 Calibration\",\n\t\"PECI Agent 1 Calibration\",\n\t\"\",\n\t\"Virtual_TEMP\"\n};\n\n#define NCT6796_TEMP_MASK\t0xbfff0ffe\n#define NCT6796_VIRT_TEMP_MASK\t0x80000c00\n\nstatic const u16 NCT6796_REG_TSI_TEMP[] = { 0x409, 0x40b };\n\nstatic const u16 NCT6798_REG_TEMP[] = {\n\t0x27, 0x150, 0x670, 0x672, 0x674, 0x676, 0x678, 0x67a};\n\nstatic const u16 NCT6798_REG_TEMP_SOURCE[] = {\n\t0x621, 0x622, 0xc26, 0xc27, 0xc28, 0xc29, 0xc2a, 0xc2b };\n\nstatic const u16 NCT6798_REG_TEMP_MON[] = {\n\t0x73, 0x75, 0x77, 0x79, 0x7b, 0x7d, 0x4a0 };\nstatic const u16 NCT6798_REG_TEMP_OVER[] = {\n\t0x39, 0x155, 0xc1a, 0xc1b, 0xc1c, 0xc1d, 0xc1e, 0xc1f };\nstatic const u16 NCT6798_REG_TEMP_HYST[] = {\n\t0x3a, 0x153, 0xc20, 0xc21, 0xc22, 0xc23, 0xc24, 0xc25 };\n\nstatic const u16 NCT6798_REG_TEMP_CRIT[32] = {\n\t0x135, 0x235, 0x335, 0x835, 0x935, 0xa35, 0xb35, 0 };\n\nstatic const u16 NCT6798_REG_TEMP_ALTERNATE[32] = {\n\t0x490, 0x491, 0x492, 0x493, 0x494, 0x495, 0x496, 0,\n\t0, 0, 0, 0, 0x4a2, 0, 0, 0,\n\t0, 0x400, 0x401, 0x402, 0x404, 0x405, 0x406, 0x407,\n\t0x408, 0x419, 0x41a, 0x4f4, 0x4f5 };\n\nstatic const char *const nct6798_temp_label[] = {\n\t\"\",\n\t\"SYSTIN\",\n\t\"CPUTIN\",\n\t\"AUXTIN0\",\n\t\"AUXTIN1\",\n\t\"AUXTIN2\",\n\t\"AUXTIN3\",\n\t\"AUXTIN4\",\n\t\"SMBUSMASTER 0\",\n\t\"SMBUSMASTER 1\",\n\t\"Virtual_TEMP\",\n\t\"Virtual_TEMP\",\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"PECI Agent 0\",\n\t\"PECI Agent 1\",\n\t\"PCH_CHIP_CPU_MAX_TEMP\",\n\t\"PCH_CHIP_TEMP\",\n\t\"PCH_CPU_TEMP\",\n\t\"PCH_MCH_TEMP\",\n\t\"Agent0 Dimm0\",\n\t\"Agent0 Dimm1\",\n\t\"Agent1 Dimm0\",\n\t\"Agent1 Dimm1\",\n\t\"BYTE_TEMP0\",\n\t\"BYTE_TEMP1\",\n\t\"PECI Agent 0 Calibration\",\t \n\t\"PECI Agent 1 Calibration\",\t \n\t\"\",\n\t\"Virtual_TEMP\"\n};\n\n#define NCT6798_TEMP_MASK\t0xbfff0ffe\n#define NCT6798_VIRT_TEMP_MASK\t0x80000c00\n\nstatic const u16 NCT6799_REG_ALARM[NUM_REG_ALARM] = {\n\t0x459, 0x45A, 0x45B, 0x568, 0x45D, 0xc01 };\n\nstatic const s8 NCT6799_ALARM_BITS[NUM_ALARM_BITS] = {\n\t 0,  1,  2,  3,  8, -1, 20, 16, 17, 24, 25, 26,\t   \n\t27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1,\t   \n\t 6,  7, 11, 10, 23, 33, -1, -1, -1, -1, -1, -1,\t   \n\t 4,  5, 40, 41, 42, 43, 44, -1, -1, -1, -1, -1,\t   \n\t12,  9,\t\t\t\t\t\t   \n};\n\nstatic const s8 NCT6799_BEEP_BITS[NUM_BEEP_BITS] = {\n\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,\t   \n\t12, 13, 14, 15, 34, 35, -1, -1, -1, -1, -1, -1,\t   \n\t25, 26, 27, 28, 29, -1, -1, -1, -1, -1, -1, -1,\t   \n\t16, 17, 18, 19, 20, 21, 22, 23, -1, -1, -1, -1,\t   \n\t30, 31, 24\t\t\t\t\t   \n};\n\n \nstatic const char *const nct6799_temp_label[] = {\n\t\"\",\n\t\"SYSTIN\",\n\t\"CPUTIN\",\n\t\"AUXTIN0\",\n\t\"AUXTIN1\",\n\t\"AUXTIN2\",\n\t\"AUXTIN3\",\n\t\"AUXTIN4\",\n\t\"SMBUSMASTER 0\",\n\t\"SMBUSMASTER 1\",\n\t\"Virtual_TEMP\",\n\t\"Virtual_TEMP\",\n\t\"\",\n\t\"AUXTIN5\",\n\t\"\",\n\t\"\",\n\t\"PECI Agent 0\",\n\t\"PECI Agent 1\",\n\t\"PCH_CHIP_CPU_MAX_TEMP\",\n\t\"PCH_CHIP_TEMP\",\n\t\"PCH_CPU_TEMP\",\n\t\"PCH_MCH_TEMP\",\n\t\"Agent0 Dimm0\",\n\t\"Agent0 Dimm1\",\n\t\"Agent1 Dimm0\",\n\t\"Agent1 Dimm1\",\n\t\"BYTE_TEMP0\",\n\t\"BYTE_TEMP1\",\n\t\"PECI/TSI Agent 0 Calibration\",\n\t\"PECI/TSI Agent 1 Calibration\",\n\t\"\",\n\t\"Virtual_TEMP\"\n};\n\n#define NCT6799_TEMP_MASK\t0xbfff2ffe\n#define NCT6799_VIRT_TEMP_MASK\t0x80000c00\n\n \n\n#define NCT6106_REG_VBAT\t0x318\n#define NCT6106_REG_DIODE\t0x319\n#define NCT6106_DIODE_MASK\t0x01\n\nstatic const u16 NCT6106_REG_IN_MAX[] = {\n\t0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9e, 0xa0, 0xa2 };\nstatic const u16 NCT6106_REG_IN_MIN[] = {\n\t0x91, 0x93, 0x95, 0x97, 0x99, 0x9b, 0x9f, 0xa1, 0xa3 };\nstatic const u16 NCT6106_REG_IN[] = {\n\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x07, 0x08, 0x09 };\n\nstatic const u16 NCT6106_REG_TEMP[] = { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15 };\nstatic const u16 NCT6106_REG_TEMP_MON[] = { 0x18, 0x19, 0x1a };\nstatic const u16 NCT6106_REG_TEMP_HYST[] = {\n\t0xc3, 0xc7, 0xcb, 0xcf, 0xd3, 0xd7 };\nstatic const u16 NCT6106_REG_TEMP_OVER[] = {\n\t0xc2, 0xc6, 0xca, 0xce, 0xd2, 0xd6 };\nstatic const u16 NCT6106_REG_TEMP_CRIT_L[] = {\n\t0xc0, 0xc4, 0xc8, 0xcc, 0xd0, 0xd4 };\nstatic const u16 NCT6106_REG_TEMP_CRIT_H[] = {\n\t0xc1, 0xc5, 0xc9, 0xcf, 0xd1, 0xd5 };\nstatic const u16 NCT6106_REG_TEMP_OFFSET[] = { 0x311, 0x312, 0x313 };\nstatic const u16 NCT6106_REG_TEMP_CONFIG[] = {\n\t0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc };\n\nstatic const u16 NCT6106_REG_FAN[] = { 0x20, 0x22, 0x24 };\nstatic const u16 NCT6106_REG_FAN_MIN[] = { 0xe0, 0xe2, 0xe4 };\nstatic const u16 NCT6106_REG_FAN_PULSES[] = { 0xf6, 0xf6, 0xf6 };\nstatic const u16 NCT6106_FAN_PULSE_SHIFT[] = { 0, 2, 4 };\n\nstatic const u8 NCT6106_REG_PWM_MODE[] = { 0xf3, 0xf3, 0xf3 };\nstatic const u8 NCT6106_PWM_MODE_MASK[] = { 0x01, 0x02, 0x04 };\nstatic const u16 NCT6106_REG_PWM_READ[] = { 0x4a, 0x4b, 0x4c };\nstatic const u16 NCT6106_REG_FAN_MODE[] = { 0x113, 0x123, 0x133 };\nstatic const u16 NCT6106_REG_TEMP_SOURCE[] = {\n\t0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5 };\n\nstatic const u16 NCT6106_REG_CRITICAL_TEMP[] = { 0x11a, 0x12a, 0x13a };\nstatic const u16 NCT6106_REG_CRITICAL_TEMP_TOLERANCE[] = {\n\t0x11b, 0x12b, 0x13b };\n\nstatic const u16 NCT6106_REG_CRITICAL_PWM_ENABLE[] = { 0x11c, 0x12c, 0x13c };\n#define NCT6106_CRITICAL_PWM_ENABLE_MASK\t0x10\nstatic const u16 NCT6106_REG_CRITICAL_PWM[] = { 0x11d, 0x12d, 0x13d };\n\nstatic const u16 NCT6106_REG_FAN_STEP_UP_TIME[] = { 0x114, 0x124, 0x134 };\nstatic const u16 NCT6106_REG_FAN_STEP_DOWN_TIME[] = { 0x115, 0x125, 0x135 };\nstatic const u16 NCT6106_REG_FAN_STOP_OUTPUT[] = { 0x116, 0x126, 0x136 };\nstatic const u16 NCT6106_REG_FAN_START_OUTPUT[] = { 0x117, 0x127, 0x137 };\nstatic const u16 NCT6106_REG_FAN_STOP_TIME[] = { 0x118, 0x128, 0x138 };\nstatic const u16 NCT6106_REG_TOLERANCE_H[] = { 0x112, 0x122, 0x132 };\n\nstatic const u16 NCT6106_REG_TARGET[] = { 0x111, 0x121, 0x131 };\n\nstatic const u16 NCT6106_REG_WEIGHT_TEMP_SEL[] = { 0x168, 0x178, 0x188 };\nstatic const u16 NCT6106_REG_WEIGHT_TEMP_STEP[] = { 0x169, 0x179, 0x189 };\nstatic const u16 NCT6106_REG_WEIGHT_TEMP_STEP_TOL[] = { 0x16a, 0x17a, 0x18a };\nstatic const u16 NCT6106_REG_WEIGHT_DUTY_STEP[] = { 0x16b, 0x17b, 0x18b };\nstatic const u16 NCT6106_REG_WEIGHT_TEMP_BASE[] = { 0x16c, 0x17c, 0x18c };\nstatic const u16 NCT6106_REG_WEIGHT_DUTY_BASE[] = { 0x16d, 0x17d, 0x18d };\n\nstatic const u16 NCT6106_REG_AUTO_TEMP[] = { 0x160, 0x170, 0x180 };\nstatic const u16 NCT6106_REG_AUTO_PWM[] = { 0x164, 0x174, 0x184 };\n\nstatic const u16 NCT6106_REG_ALARM[NUM_REG_ALARM] = {\n\t0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d };\n\nstatic const s8 NCT6106_ALARM_BITS[NUM_ALARM_BITS] = {\n\t 0,  1,  2,  3,  4,  5,  7,  8,  9, -1, -1, -1,\t   \n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t32, 33, 34, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t16, 17, 18, 19, 20, 21, -1, -1, -1, -1, -1, -1,\t   \n\t48, -1,\t\t\t\t\t\t   \n};\n\nstatic const u16 NCT6106_REG_BEEP[NUM_REG_BEEP] = {\n\t0x3c0, 0x3c1, 0x3c2, 0x3c3, 0x3c4 };\n\nstatic const s8 NCT6106_BEEP_BITS[NUM_BEEP_BITS] = {\n\t 0,  1,  2,  3,  4,  5,  7,  8,  9, 10, 11, 12,\t   \n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t24, 25, 26, 27, 28, -1, -1, -1, -1, -1, -1, -1,\t   \n\t16, 17, 18, 19, 20, 21, -1, -1, -1, -1, -1, -1,\t   \n\t34, -1, 32\t\t\t\t\t   \n};\n\nstatic const u16 NCT6106_REG_TEMP_ALTERNATE[32] = {\n\t[14] = 0x51,\n\t[15] = 0x52,\n\t[16] = 0x54,\n};\n\nstatic const u16 NCT6106_REG_TEMP_CRIT[32] = {\n\t[11] = 0x204,\n\t[12] = 0x205,\n};\n\nstatic const u16 NCT6106_REG_TSI_TEMP[] = { 0x59, 0x5b, 0x5d, 0x5f, 0x61, 0x63, 0x65, 0x67 };\n\n \n\nstatic const u16 NCT6116_REG_FAN[] = { 0x20, 0x22, 0x24, 0x26, 0x28 };\nstatic const u16 NCT6116_REG_FAN_MIN[] = { 0xe0, 0xe2, 0xe4, 0xe6, 0xe8 };\nstatic const u16 NCT6116_REG_FAN_PULSES[] = { 0xf6, 0xf6, 0xf6, 0xf6, 0xf5 };\nstatic const u16 NCT6116_FAN_PULSE_SHIFT[] = { 0, 2, 4, 6, 6 };\n\nstatic const u16 NCT6116_REG_PWM[] = { 0x119, 0x129, 0x139, 0x199, 0x1a9 };\nstatic const u16 NCT6116_REG_FAN_MODE[] = { 0x113, 0x123, 0x133, 0x193, 0x1a3 };\nstatic const u16 NCT6116_REG_TEMP_SEL[] = { 0x110, 0x120, 0x130, 0x190, 0x1a0 };\nstatic const u16 NCT6116_REG_TEMP_SOURCE[] = {\n\t0xb0, 0xb1, 0xb2 };\n\nstatic const u16 NCT6116_REG_CRITICAL_TEMP[] = {\n\t0x11a, 0x12a, 0x13a, 0x19a, 0x1aa };\nstatic const u16 NCT6116_REG_CRITICAL_TEMP_TOLERANCE[] = {\n\t0x11b, 0x12b, 0x13b, 0x19b, 0x1ab };\n\nstatic const u16 NCT6116_REG_CRITICAL_PWM_ENABLE[] = {\n\t0x11c, 0x12c, 0x13c, 0x19c, 0x1ac };\nstatic const u16 NCT6116_REG_CRITICAL_PWM[] = {\n\t0x11d, 0x12d, 0x13d, 0x19d, 0x1ad };\n\nstatic const u16 NCT6116_REG_FAN_STEP_UP_TIME[] = {\n\t0x114, 0x124, 0x134, 0x194, 0x1a4 };\nstatic const u16 NCT6116_REG_FAN_STEP_DOWN_TIME[] = {\n\t0x115, 0x125, 0x135, 0x195, 0x1a5 };\nstatic const u16 NCT6116_REG_FAN_STOP_OUTPUT[] = {\n\t0x116, 0x126, 0x136, 0x196, 0x1a6 };\nstatic const u16 NCT6116_REG_FAN_START_OUTPUT[] = {\n\t0x117, 0x127, 0x137, 0x197, 0x1a7 };\nstatic const u16 NCT6116_REG_FAN_STOP_TIME[] = {\n\t0x118, 0x128, 0x138, 0x198, 0x1a8 };\nstatic const u16 NCT6116_REG_TOLERANCE_H[] = {\n\t0x112, 0x122, 0x132, 0x192, 0x1a2 };\n\nstatic const u16 NCT6116_REG_TARGET[] = {\n\t0x111, 0x121, 0x131, 0x191, 0x1a1 };\n\nstatic const u16 NCT6116_REG_AUTO_TEMP[] = {\n\t0x160, 0x170, 0x180, 0x1d0, 0x1e0 };\nstatic const u16 NCT6116_REG_AUTO_PWM[] = {\n\t0x164, 0x174, 0x184, 0x1d4, 0x1e4 };\n\nstatic const s8 NCT6116_ALARM_BITS[NUM_ALARM_BITS] = {\n\t 0,  1,  2,  3,  4,  5,  7,  8,  9, -1, -1, -1,\t   \n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t32, 33, 34, 35, 36, -1, -1, -1, -1, -1, -1, -1,\t   \n\t16, 17, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t48, -1,\t\t\t\t\t\t   \n};\n\nstatic const s8 NCT6116_BEEP_BITS[NUM_BEEP_BITS] = {\n\t 0,  1,  2,  3,  4,  5,  7,  8,  9, 10, 11, 12,\t   \n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t24, 25, 26, 27, 28, -1, -1, -1, -1, -1, -1, -1,\t   \n\t16, 17, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1,\t   \n\t34, -1, 32\t\t\t\t\t   \n};\n\nstatic const u16 NCT6116_REG_TSI_TEMP[] = { 0x59, 0x5b };\n\nstatic enum pwm_enable reg_to_pwm_enable(int pwm, int mode)\n{\n\tif (mode == 0 && pwm == 255)\n\t\treturn off;\n\treturn mode + 1;\n}\n\nstatic int pwm_enable_to_reg(enum pwm_enable mode)\n{\n\tif (mode == off)\n\t\treturn 0;\n\treturn mode - 1;\n}\n\n \n\n \nstatic unsigned int step_time_from_reg(u8 reg, u8 mode)\n{\n\treturn mode ? 400 * reg : 100 * reg;\n}\n\nstatic u8 step_time_to_reg(unsigned int msec, u8 mode)\n{\n\treturn clamp_val((mode ? (msec + 200) / 400 :\n\t\t\t\t\t(msec + 50) / 100), 1, 255);\n}\n\nstatic unsigned int fan_from_reg8(u16 reg, unsigned int divreg)\n{\n\tif (reg == 0 || reg == 255)\n\t\treturn 0;\n\treturn 1350000U / (reg << divreg);\n}\n\nstatic unsigned int fan_from_reg13(u16 reg, unsigned int divreg)\n{\n\tif ((reg & 0xff1f) == 0xff1f)\n\t\treturn 0;\n\n\treg = (reg & 0x1f) | ((reg & 0xff00) >> 3);\n\n\tif (reg == 0)\n\t\treturn 0;\n\n\treturn 1350000U / reg;\n}\n\nstatic unsigned int fan_from_reg16(u16 reg, unsigned int divreg)\n{\n\tif (reg == 0 || reg == 0xffff)\n\t\treturn 0;\n\n\t \n\treturn 1350000U / (reg << divreg);\n}\n\nstatic unsigned int fan_from_reg_rpm(u16 reg, unsigned int divreg)\n{\n\treturn reg;\n}\n\nstatic u16 fan_to_reg(u32 fan, unsigned int divreg)\n{\n\tif (!fan)\n\t\treturn 0;\n\n\treturn (1350000U / fan) >> divreg;\n}\n\nstatic inline unsigned int\ndiv_from_reg(u8 reg)\n{\n\treturn BIT(reg);\n}\n\n \nstatic const u16 scale_in[15] = {\n\t800, 800, 1600, 1600, 800, 800, 800, 1600, 1600, 800, 800, 800, 800,\n\t800, 800\n};\n\n \nstatic const u16 scale_in_6798[NUM_IN] = {\n\t800, 800, 1600, 1600, 800, 800, 800, 1600, 1600, 1600, 1600, 1600, 800,\n\t800, 800,  800, 1600, 800\n};\n\nstatic inline long in_from_reg(u8 reg, u8 nr, const u16 *scales)\n{\n\treturn DIV_ROUND_CLOSEST(reg * scales[nr], 100);\n}\n\nstatic inline u8 in_to_reg(u32 val, u8 nr, const u16 *scales)\n{\n\treturn clamp_val(DIV_ROUND_CLOSEST(val * 100, scales[nr]), 0, 255);\n}\n\n \nstatic inline unsigned int tsi_temp_from_reg(unsigned int reg)\n{\n\treturn (reg >> 5) * 125;\n}\n\n \n\nstruct sensor_device_template {\n\tstruct device_attribute dev_attr;\n\tunion {\n\t\tstruct {\n\t\t\tu8 nr;\n\t\t\tu8 index;\n\t\t} s;\n\t\tint index;\n\t} u;\n\tbool s2;\t \n};\n\nstruct sensor_device_attr_u {\n\tunion {\n\t\tstruct sensor_device_attribute a1;\n\t\tstruct sensor_device_attribute_2 a2;\n\t} u;\n\tchar name[32];\n};\n\n#define __TEMPLATE_ATTR(_template, _mode, _show, _store) {\t\\\n\t.attr = {.name = _template, .mode = _mode },\t\t\\\n\t.show\t= _show,\t\t\t\t\t\\\n\t.store\t= _store,\t\t\t\t\t\\\n}\n\n#define SENSOR_DEVICE_TEMPLATE(_template, _mode, _show, _store, _index)\t\\\n\t{ .dev_attr = __TEMPLATE_ATTR(_template, _mode, _show, _store),\t\\\n\t  .u.index = _index,\t\t\t\t\t\t\\\n\t  .s2 = false }\n\n#define SENSOR_DEVICE_TEMPLATE_2(_template, _mode, _show, _store,\t\\\n\t\t\t\t _nr, _index)\t\t\t\t\\\n\t{ .dev_attr = __TEMPLATE_ATTR(_template, _mode, _show, _store),\t\\\n\t  .u.s.index = _index,\t\t\t\t\t\t\\\n\t  .u.s.nr = _nr,\t\t\t\t\t\t\\\n\t  .s2 = true }\n\n#define SENSOR_TEMPLATE(_name, _template, _mode, _show, _store, _index)\t\\\nstatic struct sensor_device_template sensor_dev_template_##_name\t\\\n\t= SENSOR_DEVICE_TEMPLATE(_template, _mode, _show, _store,\t\\\n\t\t\t\t _index)\n\n#define SENSOR_TEMPLATE_2(_name, _template, _mode, _show, _store,\t\\\n\t\t\t  _nr, _index)\t\t\t\t\t\\\nstatic struct sensor_device_template sensor_dev_template_##_name\t\\\n\t= SENSOR_DEVICE_TEMPLATE_2(_template, _mode, _show, _store,\t\\\n\t\t\t\t _nr, _index)\n\nstruct sensor_template_group {\n\tstruct sensor_device_template **templates;\n\tumode_t (*is_visible)(struct kobject *, struct attribute *, int);\n\tint base;\n};\n\nstatic int nct6775_add_template_attr_group(struct device *dev, struct nct6775_data *data,\n\t\t\t\t\t   const struct sensor_template_group *tg, int repeat)\n{\n\tstruct attribute_group *group;\n\tstruct sensor_device_attr_u *su;\n\tstruct sensor_device_attribute *a;\n\tstruct sensor_device_attribute_2 *a2;\n\tstruct attribute **attrs;\n\tstruct sensor_device_template **t;\n\tint i, count;\n\n\tif (repeat <= 0)\n\t\treturn -EINVAL;\n\n\tt = tg->templates;\n\tfor (count = 0; *t; t++, count++)\n\t\t;\n\n\tif (count == 0)\n\t\treturn -EINVAL;\n\n\tgroup = devm_kzalloc(dev, sizeof(*group), GFP_KERNEL);\n\tif (group == NULL)\n\t\treturn -ENOMEM;\n\n\tattrs = devm_kcalloc(dev, repeat * count + 1, sizeof(*attrs),\n\t\t\t     GFP_KERNEL);\n\tif (attrs == NULL)\n\t\treturn -ENOMEM;\n\n\tsu = devm_kzalloc(dev, array3_size(repeat, count, sizeof(*su)),\n\t\t\t       GFP_KERNEL);\n\tif (su == NULL)\n\t\treturn -ENOMEM;\n\n\tgroup->attrs = attrs;\n\tgroup->is_visible = tg->is_visible;\n\n\tfor (i = 0; i < repeat; i++) {\n\t\tt = tg->templates;\n\t\twhile (*t != NULL) {\n\t\t\tsnprintf(su->name, sizeof(su->name),\n\t\t\t\t (*t)->dev_attr.attr.name, tg->base + i);\n\t\t\tif ((*t)->s2) {\n\t\t\t\ta2 = &su->u.a2;\n\t\t\t\tsysfs_attr_init(&a2->dev_attr.attr);\n\t\t\t\ta2->dev_attr.attr.name = su->name;\n\t\t\t\ta2->nr = (*t)->u.s.nr + i;\n\t\t\t\ta2->index = (*t)->u.s.index;\n\t\t\t\ta2->dev_attr.attr.mode =\n\t\t\t\t  (*t)->dev_attr.attr.mode;\n\t\t\t\ta2->dev_attr.show = (*t)->dev_attr.show;\n\t\t\t\ta2->dev_attr.store = (*t)->dev_attr.store;\n\t\t\t\t*attrs = &a2->dev_attr.attr;\n\t\t\t} else {\n\t\t\t\ta = &su->u.a1;\n\t\t\t\tsysfs_attr_init(&a->dev_attr.attr);\n\t\t\t\ta->dev_attr.attr.name = su->name;\n\t\t\t\ta->index = (*t)->u.index + i;\n\t\t\t\ta->dev_attr.attr.mode =\n\t\t\t\t  (*t)->dev_attr.attr.mode;\n\t\t\t\ta->dev_attr.show = (*t)->dev_attr.show;\n\t\t\t\ta->dev_attr.store = (*t)->dev_attr.store;\n\t\t\t\t*attrs = &a->dev_attr.attr;\n\t\t\t}\n\t\t\tattrs++;\n\t\t\tsu++;\n\t\t\tt++;\n\t\t}\n\t}\n\n\treturn nct6775_add_attr_group(data, group);\n}\n\nbool nct6775_reg_is_word_sized(struct nct6775_data *data, u16 reg)\n{\n\tswitch (data->kind) {\n\tcase nct6106:\n\t\treturn reg == 0x20 || reg == 0x22 || reg == 0x24 ||\n\t\t  (reg >= 0x59 && reg < 0x69 && (reg & 1)) ||\n\t\t  reg == 0xe0 || reg == 0xe2 || reg == 0xe4 ||\n\t\t  reg == 0x111 || reg == 0x121 || reg == 0x131;\n\tcase nct6116:\n\t\treturn reg == 0x20 || reg == 0x22 || reg == 0x24 ||\n\t\t  reg == 0x26 || reg == 0x28 || reg == 0x59 || reg == 0x5b ||\n\t\t  reg == 0xe0 || reg == 0xe2 || reg == 0xe4 || reg == 0xe6 ||\n\t\t  reg == 0xe8 || reg == 0x111 || reg == 0x121 || reg == 0x131 ||\n\t\t  reg == 0x191 || reg == 0x1a1;\n\tcase nct6775:\n\t\treturn (((reg & 0xff00) == 0x100 ||\n\t\t    (reg & 0xff00) == 0x200) &&\n\t\t   ((reg & 0x00ff) == 0x50 ||\n\t\t    (reg & 0x00ff) == 0x53 ||\n\t\t    (reg & 0x00ff) == 0x55)) ||\n\t\t  (reg & 0xfff0) == 0x630 ||\n\t\t  reg == 0x640 || reg == 0x642 ||\n\t\t  reg == 0x662 || reg == 0x669 ||\n\t\t  ((reg & 0xfff0) == 0x650 && (reg & 0x000f) >= 0x06) ||\n\t\t  reg == 0x73 || reg == 0x75 || reg == 0x77;\n\tcase nct6776:\n\t\treturn (((reg & 0xff00) == 0x100 ||\n\t\t    (reg & 0xff00) == 0x200) &&\n\t\t   ((reg & 0x00ff) == 0x50 ||\n\t\t    (reg & 0x00ff) == 0x53 ||\n\t\t    (reg & 0x00ff) == 0x55)) ||\n\t\t  (reg & 0xfff0) == 0x630 ||\n\t\t  reg == 0x402 ||\n\t\t  (reg >= 0x409 && reg < 0x419 && (reg & 1)) ||\n\t\t  reg == 0x640 || reg == 0x642 ||\n\t\t  ((reg & 0xfff0) == 0x650 && (reg & 0x000f) >= 0x06) ||\n\t\t  reg == 0x73 || reg == 0x75 || reg == 0x77;\n\tcase nct6779:\n\tcase nct6791:\n\tcase nct6792:\n\tcase nct6793:\n\tcase nct6795:\n\tcase nct6796:\n\tcase nct6797:\n\tcase nct6798:\n\tcase nct6799:\n\t\treturn reg == 0x150 || reg == 0x153 || reg == 0x155 ||\n\t\t  (reg & 0xfff0) == 0x4c0 ||\n\t\t  reg == 0x402 ||\n\t\t  (reg >= 0x409 && reg < 0x419 && (reg & 1)) ||\n\t\t  reg == 0x63a || reg == 0x63c || reg == 0x63e ||\n\t\t  reg == 0x640 || reg == 0x642 || reg == 0x64a ||\n\t\t  reg == 0x64c ||\n\t\t  reg == 0x73 || reg == 0x75 || reg == 0x77 || reg == 0x79 ||\n\t\t  reg == 0x7b || reg == 0x7d;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(nct6775_reg_is_word_sized);\n\n \nstatic int nct6775_read_temp(struct nct6775_data *data, u16 reg, u16 *val)\n{\n\tint err;\n\n\terr = nct6775_read_value(data, reg, val);\n\tif (err)\n\t\treturn err;\n\n\tif (!nct6775_reg_is_word_sized(data, reg))\n\t\t*val <<= 8;\n\n\treturn 0;\n}\n\n \nstatic int nct6775_write_fan_div(struct nct6775_data *data, int nr)\n{\n\tu16 reg;\n\tint err;\n\tu16 fandiv_reg = nr < 2 ? NCT6775_REG_FANDIV1 : NCT6775_REG_FANDIV2;\n\tunsigned int oddshift = (nr & 1) * 4;  \n\n\terr = nct6775_read_value(data, fandiv_reg, &reg);\n\tif (err)\n\t\treturn err;\n\treg &= 0x70 >> oddshift;\n\treg |= (data->fan_div[nr] & 0x7) << oddshift;\n\treturn nct6775_write_value(data, fandiv_reg, reg);\n}\n\nstatic int nct6775_write_fan_div_common(struct nct6775_data *data, int nr)\n{\n\tif (data->kind == nct6775)\n\t\treturn nct6775_write_fan_div(data, nr);\n\treturn 0;\n}\n\nstatic int nct6775_update_fan_div(struct nct6775_data *data)\n{\n\tint err;\n\tu16 i;\n\n\terr = nct6775_read_value(data, NCT6775_REG_FANDIV1, &i);\n\tif (err)\n\t\treturn err;\n\tdata->fan_div[0] = i & 0x7;\n\tdata->fan_div[1] = (i & 0x70) >> 4;\n\terr = nct6775_read_value(data, NCT6775_REG_FANDIV2, &i);\n\tif (err)\n\t\treturn err;\n\tdata->fan_div[2] = i & 0x7;\n\tif (data->has_fan & BIT(3))\n\t\tdata->fan_div[3] = (i & 0x70) >> 4;\n\n\treturn 0;\n}\n\nstatic int nct6775_update_fan_div_common(struct nct6775_data *data)\n{\n\tif (data->kind == nct6775)\n\t\treturn nct6775_update_fan_div(data);\n\treturn 0;\n}\n\nstatic int nct6775_init_fan_div(struct nct6775_data *data)\n{\n\tint i, err;\n\n\terr = nct6775_update_fan_div_common(data);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->fan_div); i++) {\n\t\tif (!(data->has_fan & BIT(i)))\n\t\t\tcontinue;\n\t\tif (data->fan_div[i] == 0) {\n\t\t\tdata->fan_div[i] = 7;\n\t\t\terr = nct6775_write_fan_div_common(data, i);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int nct6775_init_fan_common(struct device *dev,\n\t\t\t\t   struct nct6775_data *data)\n{\n\tint i, err;\n\tu16 reg;\n\n\tif (data->has_fan_div) {\n\t\terr = nct6775_init_fan_div(data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->fan_min); i++) {\n\t\tif (data->has_fan_min & BIT(i)) {\n\t\t\terr = nct6775_read_value(data, data->REG_FAN_MIN[i], &reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (!reg) {\n\t\t\t\terr = nct6775_write_value(data, data->REG_FAN_MIN[i],\n\t\t\t\t\t\t\t  data->has_fan_div ? 0xff : 0xff1f);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int nct6775_select_fan_div(struct device *dev,\n\t\t\t\t  struct nct6775_data *data, int nr, u16 reg)\n{\n\tint err;\n\tu8 fan_div = data->fan_div[nr];\n\tu16 fan_min;\n\n\tif (!data->has_fan_div)\n\t\treturn 0;\n\n\t \n\tif (reg == 0x00 && fan_div < 0x07)\n\t\tfan_div++;\n\telse if (reg != 0x00 && reg < 0x30 && fan_div > 0)\n\t\tfan_div--;\n\n\tif (fan_div != data->fan_div[nr]) {\n\t\tdev_dbg(dev, \"Modifying fan%d clock divider from %u to %u\\n\",\n\t\t\tnr + 1, div_from_reg(data->fan_div[nr]),\n\t\t\tdiv_from_reg(fan_div));\n\n\t\t \n\t\tif (data->has_fan_min & BIT(nr)) {\n\t\t\tfan_min = data->fan_min[nr];\n\t\t\tif (fan_div > data->fan_div[nr]) {\n\t\t\t\tif (fan_min != 255 && fan_min > 1)\n\t\t\t\t\tfan_min >>= 1;\n\t\t\t} else {\n\t\t\t\tif (fan_min != 255) {\n\t\t\t\t\tfan_min <<= 1;\n\t\t\t\t\tif (fan_min > 254)\n\t\t\t\t\t\tfan_min = 254;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fan_min != data->fan_min[nr]) {\n\t\t\t\tdata->fan_min[nr] = fan_min;\n\t\t\t\terr = nct6775_write_value(data, data->REG_FAN_MIN[nr], fan_min);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tdata->fan_div[nr] = fan_div;\n\t\terr = nct6775_write_fan_div_common(data, nr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int nct6775_update_pwm(struct device *dev)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tint i, j, err;\n\tu16 fanmodecfg, reg;\n\tbool duty_is_dc;\n\n\tfor (i = 0; i < data->pwm_num; i++) {\n\t\tif (!(data->has_pwm & BIT(i)))\n\t\t\tcontinue;\n\n\t\terr = nct6775_read_value(data, data->REG_PWM_MODE[i], &reg);\n\t\tif (err)\n\t\t\treturn err;\n\t\tduty_is_dc = data->REG_PWM_MODE[i] && (reg & data->PWM_MODE_MASK[i]);\n\t\tdata->pwm_mode[i] = !duty_is_dc;\n\n\t\terr = nct6775_read_value(data, data->REG_FAN_MODE[i], &fanmodecfg);\n\t\tif (err)\n\t\t\treturn err;\n\t\tfor (j = 0; j < ARRAY_SIZE(data->REG_PWM); j++) {\n\t\t\tif (data->REG_PWM[j] && data->REG_PWM[j][i]) {\n\t\t\t\terr = nct6775_read_value(data, data->REG_PWM[j][i], &reg);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tdata->pwm[j][i] = reg;\n\t\t\t}\n\t\t}\n\n\t\tdata->pwm_enable[i] = reg_to_pwm_enable(data->pwm[0][i],\n\t\t\t\t\t\t\t(fanmodecfg >> 4) & 7);\n\n\t\tif (!data->temp_tolerance[0][i] ||\n\t\t    data->pwm_enable[i] != speed_cruise)\n\t\t\tdata->temp_tolerance[0][i] = fanmodecfg & 0x0f;\n\t\tif (!data->target_speed_tolerance[i] ||\n\t\t    data->pwm_enable[i] == speed_cruise) {\n\t\t\tu8 t = fanmodecfg & 0x0f;\n\n\t\t\tif (data->REG_TOLERANCE_H) {\n\t\t\t\terr = nct6775_read_value(data, data->REG_TOLERANCE_H[i], &reg);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tt |= (reg & 0x70) >> 1;\n\t\t\t}\n\t\t\tdata->target_speed_tolerance[i] = t;\n\t\t}\n\n\t\terr = nct6775_read_value(data, data->REG_CRITICAL_TEMP_TOLERANCE[i], &reg);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata->temp_tolerance[1][i] = reg;\n\n\t\terr = nct6775_read_value(data, data->REG_TEMP_SEL[i], &reg);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata->pwm_temp_sel[i] = reg & 0x1f;\n\t\t \n\t\tif (reg & 0x80)\n\t\t\tdata->pwm[2][i] = 0;\n\n\t\tif (!data->REG_WEIGHT_TEMP_SEL[i])\n\t\t\tcontinue;\n\n\t\terr = nct6775_read_value(data, data->REG_WEIGHT_TEMP_SEL[i], &reg);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata->pwm_weight_temp_sel[i] = reg & 0x1f;\n\t\t \n\t\tif (!(reg & 0x80))\n\t\t\tdata->pwm_weight_temp_sel[i] = 0;\n\n\t\t \n\t\tfor (j = 0; j < ARRAY_SIZE(data->weight_temp); j++) {\n\t\t\terr = nct6775_read_value(data, data->REG_WEIGHT_TEMP[j][i], &reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdata->weight_temp[j][i] = reg;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int nct6775_update_pwm_limits(struct device *dev)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tint i, j, err;\n\tu16 reg, reg_t;\n\n\tfor (i = 0; i < data->pwm_num; i++) {\n\t\tif (!(data->has_pwm & BIT(i)))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(data->fan_time); j++) {\n\t\t\terr = nct6775_read_value(data, data->REG_FAN_TIME[j][i], &reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdata->fan_time[j][i] = reg;\n\t\t}\n\n\t\terr = nct6775_read_value(data, data->REG_TARGET[i], &reg_t);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (!data->target_temp[i] ||\n\t\t    data->pwm_enable[i] == thermal_cruise)\n\t\t\tdata->target_temp[i] = reg_t & data->target_temp_mask;\n\t\tif (!data->target_speed[i] ||\n\t\t    data->pwm_enable[i] == speed_cruise) {\n\t\t\tif (data->REG_TOLERANCE_H) {\n\t\t\t\terr = nct6775_read_value(data, data->REG_TOLERANCE_H[i], &reg);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\treg_t |= (reg & 0x0f) << 8;\n\t\t\t}\n\t\t\tdata->target_speed[i] = reg_t;\n\t\t}\n\n\t\tfor (j = 0; j < data->auto_pwm_num; j++) {\n\t\t\terr = nct6775_read_value(data, NCT6775_AUTO_PWM(data, i, j), &reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdata->auto_pwm[i][j] = reg;\n\n\t\t\terr = nct6775_read_value(data, NCT6775_AUTO_TEMP(data, i, j), &reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdata->auto_temp[i][j] = reg;\n\t\t}\n\n\t\t \n\t\terr = nct6775_read_value(data, data->REG_CRITICAL_TEMP[i], &reg);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata->auto_temp[i][data->auto_pwm_num] = reg;\n\n\t\tswitch (data->kind) {\n\t\tcase nct6775:\n\t\t\terr = nct6775_read_value(data, NCT6775_REG_CRITICAL_ENAB[i], &reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdata->auto_pwm[i][data->auto_pwm_num] =\n\t\t\t\t\t\t(reg & 0x02) ? 0xff : 0x00;\n\t\t\tbreak;\n\t\tcase nct6776:\n\t\t\tdata->auto_pwm[i][data->auto_pwm_num] = 0xff;\n\t\t\tbreak;\n\t\tcase nct6106:\n\t\tcase nct6116:\n\t\tcase nct6779:\n\t\tcase nct6791:\n\t\tcase nct6792:\n\t\tcase nct6793:\n\t\tcase nct6795:\n\t\tcase nct6796:\n\t\tcase nct6797:\n\t\tcase nct6798:\n\t\tcase nct6799:\n\t\t\terr = nct6775_read_value(data, data->REG_CRITICAL_PWM_ENABLE[i], &reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (reg & data->CRITICAL_PWM_ENABLE_MASK) {\n\t\t\t\terr = nct6775_read_value(data, data->REG_CRITICAL_PWM[i], &reg);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\treg = 0xff;\n\t\t\t}\n\t\t\tdata->auto_pwm[i][data->auto_pwm_num] = reg;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct nct6775_data *nct6775_update_device(struct device *dev)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tint i, j, err = 0;\n\tu16 reg;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\n\t    || !data->valid) {\n\t\t \n\t\terr = nct6775_update_fan_div_common(data);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tfor (i = 0; i < data->in_num; i++) {\n\t\t\tif (!(data->have_in & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\terr = nct6775_read_value(data, data->REG_VIN[i], &reg);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tdata->in[i][0] = reg;\n\n\t\t\terr = nct6775_read_value(data, data->REG_IN_MINMAX[0][i], &reg);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tdata->in[i][1] = reg;\n\n\t\t\terr = nct6775_read_value(data, data->REG_IN_MINMAX[1][i], &reg);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tdata->in[i][2] = reg;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(data->rpm); i++) {\n\t\t\tif (!(data->has_fan & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\terr = nct6775_read_value(data, data->REG_FAN[i], &reg);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tdata->rpm[i] = data->fan_from_reg(reg,\n\t\t\t\t\t\t\t  data->fan_div[i]);\n\n\t\t\tif (data->has_fan_min & BIT(i)) {\n\t\t\t\tu16 tmp;\n\n\t\t\t\terr = nct6775_read_value(data, data->REG_FAN_MIN[i], &tmp);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tdata->fan_min[i] = tmp;\n\t\t\t}\n\n\t\t\tif (data->REG_FAN_PULSES[i]) {\n\t\t\t\tu16 tmp;\n\n\t\t\t\terr = nct6775_read_value(data, data->REG_FAN_PULSES[i], &tmp);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tdata->fan_pulses[i] = (tmp >> data->FAN_PULSE_SHIFT[i]) & 0x03;\n\t\t\t}\n\n\t\t\terr = nct6775_select_fan_div(dev, data, i, reg);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\terr = nct6775_update_pwm(dev);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = nct6775_update_pwm_limits(dev);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tfor (i = 0; i < NUM_TEMP; i++) {\n\t\t\tif (!(data->have_temp & BIT(i)))\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < ARRAY_SIZE(data->reg_temp); j++) {\n\t\t\t\tif (data->reg_temp[j][i]) {\n\t\t\t\t\terr = nct6775_read_temp(data, data->reg_temp[j][i], &reg);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tdata->temp[j][i] = reg;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i >= NUM_TEMP_FIXED ||\n\t\t\t    !(data->have_temp_fixed & BIT(i)))\n\t\t\t\tcontinue;\n\t\t\terr = nct6775_read_value(data, data->REG_TEMP_OFFSET[i], &reg);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tdata->temp_offset[i] = reg;\n\t\t}\n\n\t\tfor (i = 0; i < NUM_TSI_TEMP; i++) {\n\t\t\tif (!(data->have_tsi_temp & BIT(i)))\n\t\t\t\tcontinue;\n\t\t\terr = nct6775_read_value(data, data->REG_TSI_TEMP[i], &reg);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tdata->tsi_temp[i] = reg;\n\t\t}\n\n\t\tdata->alarms = 0;\n\t\tfor (i = 0; i < NUM_REG_ALARM; i++) {\n\t\t\tu16 alarm;\n\n\t\t\tif (!data->REG_ALARM[i])\n\t\t\t\tcontinue;\n\t\t\terr = nct6775_read_value(data, data->REG_ALARM[i], &alarm);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tdata->alarms |= ((u64)alarm) << (i << 3);\n\t\t}\n\n\t\tdata->beeps = 0;\n\t\tfor (i = 0; i < NUM_REG_BEEP; i++) {\n\t\t\tu16 beep;\n\n\t\t\tif (!data->REG_BEEP[i])\n\t\t\t\tcontinue;\n\t\t\terr = nct6775_read_value(data, data->REG_BEEP[i], &beep);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tdata->beeps |= ((u64)beep) << (i << 3);\n\t\t}\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\nout:\n\tmutex_unlock(&data->update_lock);\n\treturn err ? ERR_PTR(err) : data;\n}\nEXPORT_SYMBOL_GPL(nct6775_update_device);\n\n \nstatic ssize_t\nshow_in_reg(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint index = sattr->index;\n\tint nr = sattr->nr;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%ld\\n\",\n\t\t       in_from_reg(data->in[nr][index], nr, data->scale_in));\n}\n\nstatic ssize_t\nstore_in_reg(struct device *dev, struct device_attribute *attr, const char *buf,\n\t     size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint index = sattr->index;\n\tint nr = sattr->nr;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\tmutex_lock(&data->update_lock);\n\tdata->in[nr][index] = in_to_reg(val, nr, data->scale_in);\n\terr = nct6775_write_value(data, data->REG_IN_MINMAX[index - 1][nr], data->in[nr][index]);\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\nssize_t\nnct6775_show_alarm(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tnr = data->ALARM_BITS[sattr->index];\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       (unsigned int)((data->alarms >> nr) & 0x01));\n}\nEXPORT_SYMBOL_GPL(nct6775_show_alarm);\n\nstatic int find_temp_source(struct nct6775_data *data, int index, int count)\n{\n\tint source = data->temp_src[index];\n\tint nr, err;\n\n\tfor (nr = 0; nr < count; nr++) {\n\t\tu16 src;\n\n\t\terr = nct6775_read_value(data, data->REG_TEMP_SOURCE[nr], &src);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif ((src & 0x1f) == source)\n\t\t\treturn nr;\n\t}\n\treturn -ENODEV;\n}\n\nstatic ssize_t\nshow_temp_alarm(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tunsigned int alarm = 0;\n\tint nr;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t \n\tnr = find_temp_source(data, sattr->index, data->num_temp_alarms);\n\tif (nr >= 0) {\n\t\tint bit = data->ALARM_BITS[nr + TEMP_ALARM_BASE];\n\n\t\talarm = (data->alarms >> bit) & 0x01;\n\t}\n\treturn sprintf(buf, \"%u\\n\", alarm);\n}\n\nssize_t\nnct6775_show_beep(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tint nr;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tnr = data->BEEP_BITS[sattr->index];\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       (unsigned int)((data->beeps >> nr) & 0x01));\n}\nEXPORT_SYMBOL_GPL(nct6775_show_beep);\n\nssize_t\nnct6775_store_beep(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tint nr = data->BEEP_BITS[sattr->index];\n\tint regindex = nr >> 3;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tif (val)\n\t\tdata->beeps |= (1ULL << nr);\n\telse\n\t\tdata->beeps &= ~(1ULL << nr);\n\terr = nct6775_write_value(data, data->REG_BEEP[regindex],\n\t\t\t\t  (data->beeps >> (regindex << 3)) & 0xff);\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\nEXPORT_SYMBOL_GPL(nct6775_store_beep);\n\nstatic ssize_t\nshow_temp_beep(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tunsigned int beep = 0;\n\tint nr;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t \n\tnr = find_temp_source(data, sattr->index, data->num_temp_beeps);\n\tif (nr >= 0) {\n\t\tint bit = data->BEEP_BITS[nr + TEMP_ALARM_BASE];\n\n\t\tbeep = (data->beeps >> bit) & 0x01;\n\t}\n\treturn sprintf(buf, \"%u\\n\", beep);\n}\n\nstatic ssize_t\nstore_temp_beep(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tint nr, bit, regindex;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tnr = find_temp_source(data, sattr->index, data->num_temp_beeps);\n\tif (nr < 0)\n\t\treturn nr;\n\n\tbit = data->BEEP_BITS[nr + TEMP_ALARM_BASE];\n\tregindex = bit >> 3;\n\n\tmutex_lock(&data->update_lock);\n\tif (val)\n\t\tdata->beeps |= (1ULL << bit);\n\telse\n\t\tdata->beeps &= ~(1ULL << bit);\n\terr = nct6775_write_value(data, data->REG_BEEP[regindex],\n\t\t\t\t  (data->beeps >> (regindex << 3)) & 0xff);\n\tmutex_unlock(&data->update_lock);\n\n\treturn err ? : count;\n}\n\nstatic umode_t nct6775_in_is_visible(struct kobject *kobj,\n\t\t\t\t     struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tint in = index / 5;\t \n\tint nr = index % 5;\t \n\n\tif (nr == 1 && data->ALARM_BITS[in] == -1)\n\t\treturn 0;\n\n\tif (!(data->have_in & BIT(in)))\n\t\treturn 0;\n\n\treturn nct6775_attr_mode(data, attr);\n}\n\nSENSOR_TEMPLATE_2(in_input, \"in%d_input\", 0444, show_in_reg, NULL, 0, 0);\nSENSOR_TEMPLATE(in_alarm, \"in%d_alarm\", 0444, nct6775_show_alarm, NULL, 0);\nSENSOR_TEMPLATE(in_beep, \"in%d_beep\", 0644, nct6775_show_beep, nct6775_store_beep, 0);\nSENSOR_TEMPLATE_2(in_min, \"in%d_min\", 0644, show_in_reg, store_in_reg, 0, 1);\nSENSOR_TEMPLATE_2(in_max, \"in%d_max\", 0644, show_in_reg, store_in_reg, 0, 2);\n\n \nstatic struct sensor_device_template *nct6775_attributes_in_template[] = {\n\t&sensor_dev_template_in_input,\n\t&sensor_dev_template_in_alarm,\n\t&sensor_dev_template_in_beep,\n\t&sensor_dev_template_in_min,\n\t&sensor_dev_template_in_max,\n\tNULL\n};\n\nstatic const struct sensor_template_group nct6775_in_template_group = {\n\t.templates = nct6775_attributes_in_template,\n\t.is_visible = nct6775_in_is_visible,\n};\n\nstatic ssize_t\nshow_fan(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->rpm[nr]);\n}\n\nstatic ssize_t\nshow_fan_min(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       data->fan_from_reg_min(data->fan_min[nr],\n\t\t\t\t\t      data->fan_div[nr]));\n}\n\nstatic ssize_t\nshow_fan_div(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%u\\n\", div_from_reg(data->fan_div[nr]));\n}\n\nstatic ssize_t\nstore_fan_min(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tunsigned long val;\n\tunsigned int reg;\n\tu8 new_div;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tif (!data->has_fan_div) {\n\t\t \n\t\tif (!val) {\n\t\t\tval = 0xff1f;\n\t\t} else {\n\t\t\tif (val > 1350000U)\n\t\t\t\tval = 135000U;\n\t\t\tval = 1350000U / val;\n\t\t\tval = (val & 0x1f) | ((val << 3) & 0xff00);\n\t\t}\n\t\tdata->fan_min[nr] = val;\n\t\tgoto write_min;\t \n\t}\n\tif (!val) {\n\t\t \n\t\tdata->fan_min[nr] = 255;\n\t\tnew_div = data->fan_div[nr];  \n\t\tdev_info(dev, \"fan%u low limit and alarm disabled\\n\", nr + 1);\n\t\tgoto write_div;\n\t}\n\treg = 1350000U / val;\n\tif (reg >= 128 * 255) {\n\t\t \n\t\tdata->fan_min[nr] = 254;\n\t\tnew_div = 7;  \n\t\tdev_warn(dev,\n\t\t\t \"fan%u low limit %lu below minimum %u, set to minimum\\n\",\n\t\t\t nr + 1, val, data->fan_from_reg_min(254, 7));\n\t} else if (!reg) {\n\t\t \n\t\tdata->fan_min[nr] = 1;\n\t\tnew_div = 0;  \n\t\tdev_warn(dev,\n\t\t\t \"fan%u low limit %lu above maximum %u, set to maximum\\n\",\n\t\t\t nr + 1, val, data->fan_from_reg_min(1, 0));\n\t} else {\n\t\t \n\t\tnew_div = 0;\n\t\twhile (reg > 192 && new_div < 7) {\n\t\t\treg >>= 1;\n\t\t\tnew_div++;\n\t\t}\n\t\tdata->fan_min[nr] = reg;\n\t}\n\nwrite_div:\n\t \n\tif (new_div != data->fan_div[nr]) {\n\t\tdev_dbg(dev, \"fan%u clock divider changed from %u to %u\\n\",\n\t\t\tnr + 1, div_from_reg(data->fan_div[nr]),\n\t\t\tdiv_from_reg(new_div));\n\t\tdata->fan_div[nr] = new_div;\n\t\terr = nct6775_write_fan_div_common(data, nr);\n\t\tif (err)\n\t\t\tgoto write_min;\n\t\t \n\t\tdata->last_updated = jiffies;\n\t}\n\nwrite_min:\n\terr = nct6775_write_value(data, data->REG_FAN_MIN[nr], data->fan_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn err ? : count;\n}\n\nstatic ssize_t\nshow_fan_pulses(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint p;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tp = data->fan_pulses[sattr->index];\n\treturn sprintf(buf, \"%d\\n\", p ? : 4);\n}\n\nstatic ssize_t\nstore_fan_pulses(struct device *dev, struct device_attribute *attr,\n\t\t const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tunsigned long val;\n\tint err;\n\tu16 reg;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val > 4)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan_pulses[nr] = val & 3;\n\terr = nct6775_read_value(data, data->REG_FAN_PULSES[nr], &reg);\n\tif (err)\n\t\tgoto out;\n\treg &= ~(0x03 << data->FAN_PULSE_SHIFT[nr]);\n\treg |= (val & 3) << data->FAN_PULSE_SHIFT[nr];\n\terr = nct6775_write_value(data, data->REG_FAN_PULSES[nr], reg);\nout:\n\tmutex_unlock(&data->update_lock);\n\n\treturn err ? : count;\n}\n\nstatic umode_t nct6775_fan_is_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tint fan = index / 6;\t \n\tint nr = index % 6;\t \n\n\tif (!(data->has_fan & BIT(fan)))\n\t\treturn 0;\n\n\tif (nr == 1 && data->ALARM_BITS[FAN_ALARM_BASE + fan] == -1)\n\t\treturn 0;\n\tif (nr == 2 && data->BEEP_BITS[FAN_ALARM_BASE + fan] == -1)\n\t\treturn 0;\n\tif (nr == 3 && !data->REG_FAN_PULSES[fan])\n\t\treturn 0;\n\tif (nr == 4 && !(data->has_fan_min & BIT(fan)))\n\t\treturn 0;\n\tif (nr == 5 && data->kind != nct6775)\n\t\treturn 0;\n\n\treturn nct6775_attr_mode(data, attr);\n}\n\nSENSOR_TEMPLATE(fan_input, \"fan%d_input\", 0444, show_fan, NULL, 0);\nSENSOR_TEMPLATE(fan_alarm, \"fan%d_alarm\", 0444, nct6775_show_alarm, NULL, FAN_ALARM_BASE);\nSENSOR_TEMPLATE(fan_beep, \"fan%d_beep\", 0644, nct6775_show_beep,\n\t\tnct6775_store_beep, FAN_ALARM_BASE);\nSENSOR_TEMPLATE(fan_pulses, \"fan%d_pulses\", 0644, show_fan_pulses, store_fan_pulses, 0);\nSENSOR_TEMPLATE(fan_min, \"fan%d_min\", 0644, show_fan_min, store_fan_min, 0);\nSENSOR_TEMPLATE(fan_div, \"fan%d_div\", 0444, show_fan_div, NULL, 0);\n\n \nstatic struct sensor_device_template *nct6775_attributes_fan_template[] = {\n\t&sensor_dev_template_fan_input,\n\t&sensor_dev_template_fan_alarm,\t \n\t&sensor_dev_template_fan_beep,\t \n\t&sensor_dev_template_fan_pulses,\n\t&sensor_dev_template_fan_min,\t \n\t&sensor_dev_template_fan_div,\t \n\tNULL\n};\n\nstatic const struct sensor_template_group nct6775_fan_template_group = {\n\t.templates = nct6775_attributes_fan_template,\n\t.is_visible = nct6775_fan_is_visible,\n\t.base = 1,\n};\n\nstatic ssize_t\nshow_temp_label(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%s\\n\", data->temp_label[data->temp_src[nr]]);\n}\n\nstatic ssize_t\nshow_temp(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", LM75_TEMP_FROM_REG(data->temp[index][nr]));\n}\n\nstatic ssize_t\nstore_temp(struct device *dev, struct device_attribute *attr, const char *buf,\n\t   size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\tint err;\n\tlong val;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp[index][nr] = LM75_TEMP_TO_REG(val);\n\terr = nct6775_write_temp(data, data->reg_temp[index][nr], data->temp[index][nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\nstatic ssize_t\nshow_temp_offset(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->temp_offset[sattr->index] * 1000);\n}\n\nstatic ssize_t\nstore_temp_offset(struct device *dev, struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), -128, 127);\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_offset[nr] = val;\n\terr = nct6775_write_value(data, data->REG_TEMP_OFFSET[nr], val);\n\tmutex_unlock(&data->update_lock);\n\n\treturn err ? : count;\n}\n\nstatic ssize_t\nshow_temp_type(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", (int)data->temp_type[nr]);\n}\n\nstatic ssize_t\nstore_temp_type(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tunsigned long val;\n\tint err;\n\tu8 vbit, dbit;\n\tu16 vbat, diode;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val != 1 && val != 3 && val != 4)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\n\tdata->temp_type[nr] = val;\n\tvbit = 0x02 << nr;\n\tdbit = data->DIODE_MASK << nr;\n\n\terr = nct6775_read_value(data, data->REG_VBAT, &vbat);\n\tif (err)\n\t\tgoto out;\n\tvbat &= ~vbit;\n\n\terr = nct6775_read_value(data, data->REG_DIODE, &diode);\n\tif (err)\n\t\tgoto out;\n\tdiode &= ~dbit;\n\n\tswitch (val) {\n\tcase 1:\t \n\t\tvbat |= vbit;\n\t\tdiode |= dbit;\n\t\tbreak;\n\tcase 3:  \n\t\tvbat |= dbit;\n\t\tbreak;\n\tcase 4:\t \n\t\tbreak;\n\t}\n\terr = nct6775_write_value(data, data->REG_VBAT, vbat);\n\tif (err)\n\t\tgoto out;\n\terr = nct6775_write_value(data, data->REG_DIODE, diode);\nout:\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\nstatic umode_t nct6775_temp_is_visible(struct kobject *kobj,\n\t\t\t\t       struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tint temp = index / 10;\t \n\tint nr = index % 10;\t \n\n\tif (!(data->have_temp & BIT(temp)))\n\t\treturn 0;\n\n\tif (nr == 1 && !data->temp_label)\n\t\treturn 0;\n\n\tif (nr == 2 && find_temp_source(data, temp, data->num_temp_alarms) < 0)\n\t\treturn 0;\t\t\t\t \n\n\tif (nr == 3 && find_temp_source(data, temp, data->num_temp_beeps) < 0)\n\t\treturn 0;\t\t\t\t \n\n\tif (nr == 4 && !data->reg_temp[1][temp])\t \n\t\treturn 0;\n\n\tif (nr == 5 && !data->reg_temp[2][temp])\t \n\t\treturn 0;\n\n\tif (nr == 6 && !data->reg_temp[3][temp])\t \n\t\treturn 0;\n\n\tif (nr == 7 && !data->reg_temp[4][temp])\t \n\t\treturn 0;\n\n\t \n\tif (nr > 7 && !(data->have_temp_fixed & BIT(temp)))\n\t\treturn 0;\n\n\treturn nct6775_attr_mode(data, attr);\n}\n\nSENSOR_TEMPLATE_2(temp_input, \"temp%d_input\", 0444, show_temp, NULL, 0, 0);\nSENSOR_TEMPLATE(temp_label, \"temp%d_label\", 0444, show_temp_label, NULL, 0);\nSENSOR_TEMPLATE_2(temp_max, \"temp%d_max\", 0644, show_temp, store_temp, 0, 1);\nSENSOR_TEMPLATE_2(temp_max_hyst, \"temp%d_max_hyst\", 0644, show_temp, store_temp, 0, 2);\nSENSOR_TEMPLATE_2(temp_crit, \"temp%d_crit\", 0644, show_temp, store_temp, 0, 3);\nSENSOR_TEMPLATE_2(temp_lcrit, \"temp%d_lcrit\", 0644, show_temp, store_temp, 0, 4);\nSENSOR_TEMPLATE(temp_offset, \"temp%d_offset\", 0644, show_temp_offset, store_temp_offset, 0);\nSENSOR_TEMPLATE(temp_type, \"temp%d_type\", 0644, show_temp_type, store_temp_type, 0);\nSENSOR_TEMPLATE(temp_alarm, \"temp%d_alarm\", 0444, show_temp_alarm, NULL, 0);\nSENSOR_TEMPLATE(temp_beep, \"temp%d_beep\", 0644, show_temp_beep, store_temp_beep, 0);\n\n \nstatic struct sensor_device_template *nct6775_attributes_temp_template[] = {\n\t&sensor_dev_template_temp_input,\n\t&sensor_dev_template_temp_label,\n\t&sensor_dev_template_temp_alarm,\t \n\t&sensor_dev_template_temp_beep,\t\t \n\t&sensor_dev_template_temp_max,\t\t \n\t&sensor_dev_template_temp_max_hyst,\t \n\t&sensor_dev_template_temp_crit,\t\t \n\t&sensor_dev_template_temp_lcrit,\t \n\t&sensor_dev_template_temp_offset,\t \n\t&sensor_dev_template_temp_type,\t\t \n\tNULL\n};\n\nstatic const struct sensor_template_group nct6775_temp_template_group = {\n\t.templates = nct6775_attributes_temp_template,\n\t.is_visible = nct6775_temp_is_visible,\n\t.base = 1,\n};\n\nstatic ssize_t show_tsi_temp(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sysfs_emit(buf, \"%u\\n\", tsi_temp_from_reg(data->tsi_temp[sattr->index]));\n}\n\nstatic ssize_t show_tsi_temp_label(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\n\treturn sysfs_emit(buf, \"TSI%d_TEMP\\n\", sattr->index);\n}\n\nSENSOR_TEMPLATE(tsi_temp_input, \"temp%d_input\", 0444, show_tsi_temp, NULL, 0);\nSENSOR_TEMPLATE(tsi_temp_label, \"temp%d_label\", 0444, show_tsi_temp_label, NULL, 0);\n\nstatic umode_t nct6775_tsi_temp_is_visible(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t\t       int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tint temp = index / 2;\n\n\treturn (data->have_tsi_temp & BIT(temp)) ? nct6775_attr_mode(data, attr) : 0;\n}\n\n \nstatic struct sensor_device_template *nct6775_tsi_temp_template[] = {\n\t&sensor_dev_template_tsi_temp_input,\n\t&sensor_dev_template_tsi_temp_label,\n\tNULL\n};\n\nstatic ssize_t\nshow_pwm_mode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->pwm_mode[sattr->index]);\n}\n\nstatic ssize_t\nstore_pwm_mode(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tunsigned long val;\n\tint err;\n\tu16 reg;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (data->REG_PWM_MODE[nr] == 0) {\n\t\tif (!val)\n\t\t\treturn -EINVAL;\n\t\treturn count;\n\t}\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm_mode[nr] = val;\n\terr = nct6775_read_value(data, data->REG_PWM_MODE[nr], &reg);\n\tif (err)\n\t\tgoto out;\n\treg &= ~data->PWM_MODE_MASK[nr];\n\tif (!val)\n\t\treg |= data->PWM_MODE_MASK[nr];\n\terr = nct6775_write_value(data, data->REG_PWM_MODE[nr], reg);\nout:\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\nstatic ssize_t\nshow_pwm(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\tint err;\n\tu16 pwm;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t \n\tif (index == 0 && data->pwm_enable[nr] > manual) {\n\t\terr = nct6775_read_value(data, data->REG_PWM_READ[nr], &pwm);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tpwm = data->pwm[index][nr];\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", pwm);\n}\n\nstatic ssize_t\nstore_pwm(struct device *dev, struct device_attribute *attr, const char *buf,\n\t  size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\tunsigned long val;\n\tint minval[7] = { 0, 1, 1, data->pwm[2][nr], 0, 0, 0 };\n\tint maxval[7]\n\t  = { 255, 255, data->pwm[3][nr] ? : 255, 255, 255, 255, 255 };\n\tint err;\n\tu16 reg;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\tval = clamp_val(val, minval[index], maxval[index]);\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm[index][nr] = val;\n\terr = nct6775_write_value(data, data->REG_PWM[index][nr], val);\n\tif (err)\n\t\tgoto out;\n\tif (index == 2)\t{  \n\t\terr = nct6775_read_value(data, data->REG_TEMP_SEL[nr], &reg);\n\t\tif (err)\n\t\t\tgoto out;\n\t\treg &= 0x7f;\n\t\tif (val)\n\t\t\treg |= 0x80;\n\t\terr = nct6775_write_value(data, data->REG_TEMP_SEL[nr], reg);\n\t}\nout:\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\n \nstatic int check_trip_points(struct nct6775_data *data, int nr)\n{\n\tint i;\n\n\tfor (i = 0; i < data->auto_pwm_num - 1; i++) {\n\t\tif (data->auto_temp[nr][i] > data->auto_temp[nr][i + 1])\n\t\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < data->auto_pwm_num - 1; i++) {\n\t\tif (data->auto_pwm[nr][i] > data->auto_pwm[nr][i + 1])\n\t\t\treturn -EINVAL;\n\t}\n\t \n\tif (data->auto_pwm[nr][data->auto_pwm_num]) {\n\t\tif (data->auto_temp[nr][data->auto_pwm_num - 1] >\n\t\t\t\tdata->auto_temp[nr][data->auto_pwm_num] ||\n\t\t    data->auto_pwm[nr][data->auto_pwm_num - 1] >\n\t\t\t\tdata->auto_pwm[nr][data->auto_pwm_num])\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int pwm_update_registers(struct nct6775_data *data, int nr)\n{\n\tu16 reg;\n\tint err;\n\n\tswitch (data->pwm_enable[nr]) {\n\tcase off:\n\tcase manual:\n\t\tbreak;\n\tcase speed_cruise:\n\t\terr = nct6775_read_value(data, data->REG_FAN_MODE[nr], &reg);\n\t\tif (err)\n\t\t\treturn err;\n\t\treg = (reg & ~data->tolerance_mask) |\n\t\t  (data->target_speed_tolerance[nr] & data->tolerance_mask);\n\t\terr = nct6775_write_value(data, data->REG_FAN_MODE[nr], reg);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = nct6775_write_value(data, data->REG_TARGET[nr],\n\t\t\t\t\t  data->target_speed[nr] & 0xff);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (data->REG_TOLERANCE_H) {\n\t\t\treg = (data->target_speed[nr] >> 8) & 0x0f;\n\t\t\treg |= (data->target_speed_tolerance[nr] & 0x38) << 1;\n\t\t\terr = nct6775_write_value(data, data->REG_TOLERANCE_H[nr], reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase thermal_cruise:\n\t\terr = nct6775_write_value(data, data->REG_TARGET[nr], data->target_temp[nr]);\n\t\tif (err)\n\t\t\treturn err;\n\t\tfallthrough;\n\tdefault:\n\t\terr = nct6775_read_value(data, data->REG_FAN_MODE[nr], &reg);\n\t\tif (err)\n\t\t\treturn err;\n\t\treg = (reg & ~data->tolerance_mask) |\n\t\t  data->temp_tolerance[0][nr];\n\t\terr = nct6775_write_value(data, data->REG_FAN_MODE[nr], reg);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t\nshow_pwm_enable(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->pwm_enable[sattr->index]);\n}\n\nstatic ssize_t\nstore_pwm_enable(struct device *dev, struct device_attribute *attr,\n\t\t const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tunsigned long val;\n\tint err;\n\tu16 reg;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val > sf4)\n\t\treturn -EINVAL;\n\n\tif (val == sf3 && data->kind != nct6775)\n\t\treturn -EINVAL;\n\n\tif (val == sf4 && check_trip_points(data, nr)) {\n\t\tdev_err(dev, \"Inconsistent trip points, not switching to SmartFan IV mode\\n\");\n\t\tdev_err(dev, \"Adjust trip points and try again\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&data->update_lock);\n\tdata->pwm_enable[nr] = val;\n\tif (val == off) {\n\t\t \n\t\tdata->pwm[0][nr] = 255;\n\t\terr = nct6775_write_value(data, data->REG_PWM[0][nr], 255);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = pwm_update_registers(data, nr);\n\tif (err)\n\t\tgoto out;\n\terr = nct6775_read_value(data, data->REG_FAN_MODE[nr], &reg);\n\tif (err)\n\t\tgoto out;\n\treg &= 0x0f;\n\treg |= pwm_enable_to_reg(val) << 4;\n\terr = nct6775_write_value(data, data->REG_FAN_MODE[nr], reg);\nout:\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\nstatic ssize_t\nshow_pwm_temp_sel_common(struct nct6775_data *data, char *buf, int src)\n{\n\tint i, sel = 0;\n\n\tfor (i = 0; i < NUM_TEMP; i++) {\n\t\tif (!(data->have_temp & BIT(i)))\n\t\t\tcontinue;\n\t\tif (src == data->temp_src[i]) {\n\t\t\tsel = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", sel);\n}\n\nstatic ssize_t\nshow_pwm_temp_sel(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint index = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn show_pwm_temp_sel_common(data, buf, data->pwm_temp_sel[index]);\n}\n\nstatic ssize_t\nstore_pwm_temp_sel(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tunsigned long val;\n\tint err, src;\n\tu16 reg;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\tif (val == 0 || val > NUM_TEMP)\n\t\treturn -EINVAL;\n\tif (!(data->have_temp & BIT(val - 1)) || !data->temp_src[val - 1])\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tsrc = data->temp_src[val - 1];\n\tdata->pwm_temp_sel[nr] = src;\n\terr = nct6775_read_value(data, data->REG_TEMP_SEL[nr], &reg);\n\tif (err)\n\t\tgoto out;\n\treg &= 0xe0;\n\treg |= src;\n\terr = nct6775_write_value(data, data->REG_TEMP_SEL[nr], reg);\nout:\n\tmutex_unlock(&data->update_lock);\n\n\treturn err ? : count;\n}\n\nstatic ssize_t\nshow_pwm_weight_temp_sel(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint index = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn show_pwm_temp_sel_common(data, buf,\n\t\t\t\t\tdata->pwm_weight_temp_sel[index]);\n}\n\nstatic ssize_t\nstore_pwm_weight_temp_sel(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tunsigned long val;\n\tint err, src;\n\tu16 reg;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\tif (val > NUM_TEMP)\n\t\treturn -EINVAL;\n\tval = array_index_nospec(val, NUM_TEMP + 1);\n\tif (val && (!(data->have_temp & BIT(val - 1)) ||\n\t\t    !data->temp_src[val - 1]))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tif (val) {\n\t\tsrc = data->temp_src[val - 1];\n\t\tdata->pwm_weight_temp_sel[nr] = src;\n\t\terr = nct6775_read_value(data, data->REG_WEIGHT_TEMP_SEL[nr], &reg);\n\t\tif (err)\n\t\t\tgoto out;\n\t\treg &= 0xe0;\n\t\treg |= (src | 0x80);\n\t\terr = nct6775_write_value(data, data->REG_WEIGHT_TEMP_SEL[nr], reg);\n\t} else {\n\t\tdata->pwm_weight_temp_sel[nr] = 0;\n\t\terr = nct6775_read_value(data, data->REG_WEIGHT_TEMP_SEL[nr], &reg);\n\t\tif (err)\n\t\t\tgoto out;\n\t\treg &= 0x7f;\n\t\terr = nct6775_write_value(data, data->REG_WEIGHT_TEMP_SEL[nr], reg);\n\t}\nout:\n\tmutex_unlock(&data->update_lock);\n\n\treturn err ? : count;\n}\n\nstatic ssize_t\nshow_target_temp(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->target_temp[sattr->index] * 1000);\n}\n\nstatic ssize_t\nstore_target_temp(struct device *dev, struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), 0,\n\t\t\tdata->target_temp_mask);\n\n\tmutex_lock(&data->update_lock);\n\tdata->target_temp[nr] = val;\n\terr = pwm_update_registers(data, nr);\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\nstatic ssize_t\nshow_target_speed(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       fan_from_reg16(data->target_speed[nr],\n\t\t\t\t      data->fan_div[nr]));\n}\n\nstatic ssize_t\nstore_target_speed(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tunsigned long val;\n\tint err;\n\tu16 speed;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = clamp_val(val, 0, 1350000U);\n\tspeed = fan_to_reg(val, data->fan_div[nr]);\n\n\tmutex_lock(&data->update_lock);\n\tdata->target_speed[nr] = speed;\n\terr = pwm_update_registers(data, nr);\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\nstatic ssize_t\nshow_temp_tolerance(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->temp_tolerance[index][nr] * 1000);\n}\n\nstatic ssize_t\nstore_temp_tolerance(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), 0, data->tolerance_mask);\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_tolerance[index][nr] = val;\n\tif (index)\n\t\terr = pwm_update_registers(data, nr);\n\telse\n\t\terr = nct6775_write_value(data, data->REG_CRITICAL_TEMP_TOLERANCE[nr], val);\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\n \nstatic ssize_t\nshow_speed_tolerance(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tint target, tolerance = 0;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\ttarget = data->target_speed[nr];\n\n\tif (target) {\n\t\tint low = target - data->target_speed_tolerance[nr];\n\t\tint high = target + data->target_speed_tolerance[nr];\n\n\t\tif (low <= 0)\n\t\t\tlow = 1;\n\t\tif (high > 0xffff)\n\t\t\thigh = 0xffff;\n\t\tif (high < low)\n\t\t\thigh = low;\n\n\t\ttolerance = (fan_from_reg16(low, data->fan_div[nr])\n\t\t\t     - fan_from_reg16(high, data->fan_div[nr])) / 2;\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", tolerance);\n}\n\nstatic ssize_t\nstore_speed_tolerance(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tint nr = sattr->index;\n\tunsigned long val;\n\tint err;\n\tint low, high;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\thigh = fan_from_reg16(data->target_speed[nr], data->fan_div[nr]) + val;\n\tlow = fan_from_reg16(data->target_speed[nr], data->fan_div[nr]) - val;\n\tif (low <= 0)\n\t\tlow = 1;\n\tif (high < low)\n\t\thigh = low;\n\n\tval = (fan_to_reg(low, data->fan_div[nr]) -\n\t       fan_to_reg(high, data->fan_div[nr])) / 2;\n\n\t \n\tval = clamp_val(val, 0, data->speed_tolerance_limit);\n\n\tmutex_lock(&data->update_lock);\n\tdata->target_speed_tolerance[nr] = val;\n\terr = pwm_update_registers(data, nr);\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\nSENSOR_TEMPLATE_2(pwm, \"pwm%d\", 0644, show_pwm, store_pwm, 0, 0);\nSENSOR_TEMPLATE(pwm_mode, \"pwm%d_mode\", 0644, show_pwm_mode, store_pwm_mode, 0);\nSENSOR_TEMPLATE(pwm_enable, \"pwm%d_enable\", 0644, show_pwm_enable, store_pwm_enable, 0);\nSENSOR_TEMPLATE(pwm_temp_sel, \"pwm%d_temp_sel\", 0644, show_pwm_temp_sel, store_pwm_temp_sel, 0);\nSENSOR_TEMPLATE(pwm_target_temp, \"pwm%d_target_temp\", 0644, show_target_temp, store_target_temp, 0);\nSENSOR_TEMPLATE(fan_target, \"fan%d_target\", 0644, show_target_speed, store_target_speed, 0);\nSENSOR_TEMPLATE(fan_tolerance, \"fan%d_tolerance\", 0644, show_speed_tolerance,\n\t\tstore_speed_tolerance, 0);\n\n \n\nstatic ssize_t\nshow_weight_temp(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->weight_temp[index][nr] * 1000);\n}\n\nstatic ssize_t\nstore_weight_temp(struct device *dev, struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), 0, 255);\n\n\tmutex_lock(&data->update_lock);\n\tdata->weight_temp[index][nr] = val;\n\terr = nct6775_write_value(data, data->REG_WEIGHT_TEMP[index][nr], val);\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\nSENSOR_TEMPLATE(pwm_weight_temp_sel, \"pwm%d_weight_temp_sel\", 0644,\n\t\tshow_pwm_weight_temp_sel, store_pwm_weight_temp_sel, 0);\nSENSOR_TEMPLATE_2(pwm_weight_temp_step, \"pwm%d_weight_temp_step\",\n\t\t  0644, show_weight_temp, store_weight_temp, 0, 0);\nSENSOR_TEMPLATE_2(pwm_weight_temp_step_tol, \"pwm%d_weight_temp_step_tol\",\n\t\t  0644, show_weight_temp, store_weight_temp, 0, 1);\nSENSOR_TEMPLATE_2(pwm_weight_temp_step_base, \"pwm%d_weight_temp_step_base\",\n\t\t  0644, show_weight_temp, store_weight_temp, 0, 2);\nSENSOR_TEMPLATE_2(pwm_weight_duty_step, \"pwm%d_weight_duty_step\", 0644, show_pwm, store_pwm, 0, 5);\nSENSOR_TEMPLATE_2(pwm_weight_duty_base, \"pwm%d_weight_duty_base\", 0644, show_pwm, store_pwm, 0, 6);\n\nstatic ssize_t\nshow_fan_time(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       step_time_from_reg(data->fan_time[index][nr],\n\t\t\t\t\t  data->pwm_mode[nr]));\n}\n\nstatic ssize_t\nstore_fan_time(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint index = sattr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = step_time_to_reg(val, data->pwm_mode[nr]);\n\tmutex_lock(&data->update_lock);\n\tdata->fan_time[index][nr] = val;\n\terr = nct6775_write_value(data, data->REG_FAN_TIME[index][nr], val);\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\nstatic ssize_t\nshow_auto_pwm(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn sprintf(buf, \"%d\\n\", data->auto_pwm[sattr->nr][sattr->index]);\n}\n\nstatic ssize_t\nstore_auto_pwm(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint point = sattr->index;\n\tunsigned long val;\n\tint err;\n\tu16 reg;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tif (point == data->auto_pwm_num) {\n\t\tif (data->kind != nct6775 && !val)\n\t\t\treturn -EINVAL;\n\t\tif (data->kind != nct6779 && val)\n\t\t\tval = 0xff;\n\t}\n\n\tmutex_lock(&data->update_lock);\n\tdata->auto_pwm[nr][point] = val;\n\tif (point < data->auto_pwm_num) {\n\t\terr = nct6775_write_value(data, NCT6775_AUTO_PWM(data, nr, point),\n\t\t\t\t\t  data->auto_pwm[nr][point]);\n\t} else {\n\t\tswitch (data->kind) {\n\t\tcase nct6775:\n\t\t\t \n\t\t\terr = nct6775_read_value(data, NCT6775_REG_CRITICAL_ENAB[nr], &reg);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (val)\n\t\t\t\treg |= 0x02;\n\t\t\telse\n\t\t\t\treg &= ~0x02;\n\t\t\terr = nct6775_write_value(data, NCT6775_REG_CRITICAL_ENAB[nr], reg);\n\t\t\tbreak;\n\t\tcase nct6776:\n\t\t\tbreak;  \n\t\tcase nct6106:\n\t\tcase nct6116:\n\t\tcase nct6779:\n\t\tcase nct6791:\n\t\tcase nct6792:\n\t\tcase nct6793:\n\t\tcase nct6795:\n\t\tcase nct6796:\n\t\tcase nct6797:\n\t\tcase nct6798:\n\t\tcase nct6799:\n\t\t\terr = nct6775_write_value(data, data->REG_CRITICAL_PWM[nr], val);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\terr = nct6775_read_value(data, data->REG_CRITICAL_PWM_ENABLE[nr], &reg);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (val == 255)\n\t\t\t\treg &= ~data->CRITICAL_PWM_ENABLE_MASK;\n\t\t\telse\n\t\t\t\treg |= data->CRITICAL_PWM_ENABLE_MASK;\n\t\t\terr = nct6775_write_value(data, data->REG_CRITICAL_PWM_ENABLE[nr], reg);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\nstatic ssize_t\nshow_auto_temp(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nct6775_data *data = nct6775_update_device(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint point = sattr->index;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t \n\treturn sprintf(buf, \"%d\\n\", data->auto_temp[nr][point] * 1000);\n}\n\nstatic ssize_t\nstore_auto_temp(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tint nr = sattr->nr;\n\tint point = sattr->index;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tif (val > 255000)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tdata->auto_temp[nr][point] = DIV_ROUND_CLOSEST(val, 1000);\n\tif (point < data->auto_pwm_num) {\n\t\terr = nct6775_write_value(data, NCT6775_AUTO_TEMP(data, nr, point),\n\t\t\t\t\t  data->auto_temp[nr][point]);\n\t} else {\n\t\terr = nct6775_write_value(data, data->REG_CRITICAL_TEMP[nr],\n\t\t\t\t\t  data->auto_temp[nr][point]);\n\t}\n\tmutex_unlock(&data->update_lock);\n\treturn err ? : count;\n}\n\nstatic umode_t nct6775_pwm_is_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct nct6775_data *data = dev_get_drvdata(dev);\n\tint pwm = index / 36;\t \n\tint nr = index % 36;\t \n\n\tif (!(data->has_pwm & BIT(pwm)))\n\t\treturn 0;\n\n\tif ((nr >= 14 && nr <= 18) || nr == 21)    \n\t\tif (!data->REG_WEIGHT_TEMP_SEL[pwm])\n\t\t\treturn 0;\n\tif (nr == 19 && data->REG_PWM[3] == NULL)  \n\t\treturn 0;\n\tif (nr == 20 && data->REG_PWM[4] == NULL)  \n\t\treturn 0;\n\tif (nr == 21 && data->REG_PWM[6] == NULL)  \n\t\treturn 0;\n\n\tif (nr >= 22 && nr <= 35) {\t\t \n\t\tint api = (nr - 22) / 2;\t \n\n\t\tif (api > data->auto_pwm_num)\n\t\t\treturn 0;\n\t}\n\treturn nct6775_attr_mode(data, attr);\n}\n\nSENSOR_TEMPLATE_2(pwm_stop_time, \"pwm%d_stop_time\", 0644, show_fan_time, store_fan_time, 0, 0);\nSENSOR_TEMPLATE_2(pwm_step_up_time, \"pwm%d_step_up_time\", 0644,\n\t\t  show_fan_time, store_fan_time, 0, 1);\nSENSOR_TEMPLATE_2(pwm_step_down_time, \"pwm%d_step_down_time\", 0644,\n\t\t  show_fan_time, store_fan_time, 0, 2);\nSENSOR_TEMPLATE_2(pwm_start, \"pwm%d_start\", 0644, show_pwm, store_pwm, 0, 1);\nSENSOR_TEMPLATE_2(pwm_floor, \"pwm%d_floor\", 0644, show_pwm, store_pwm, 0, 2);\nSENSOR_TEMPLATE_2(pwm_temp_tolerance, \"pwm%d_temp_tolerance\", 0644,\n\t\t  show_temp_tolerance, store_temp_tolerance, 0, 0);\nSENSOR_TEMPLATE_2(pwm_crit_temp_tolerance, \"pwm%d_crit_temp_tolerance\",\n\t\t  0644, show_temp_tolerance, store_temp_tolerance, 0, 1);\n\nSENSOR_TEMPLATE_2(pwm_max, \"pwm%d_max\", 0644, show_pwm, store_pwm, 0, 3);\n\nSENSOR_TEMPLATE_2(pwm_step, \"pwm%d_step\", 0644, show_pwm, store_pwm, 0, 4);\n\nSENSOR_TEMPLATE_2(pwm_auto_point1_pwm, \"pwm%d_auto_point1_pwm\",\n\t\t  0644, show_auto_pwm, store_auto_pwm, 0, 0);\nSENSOR_TEMPLATE_2(pwm_auto_point1_temp, \"pwm%d_auto_point1_temp\",\n\t\t  0644, show_auto_temp, store_auto_temp, 0, 0);\n\nSENSOR_TEMPLATE_2(pwm_auto_point2_pwm, \"pwm%d_auto_point2_pwm\",\n\t\t  0644, show_auto_pwm, store_auto_pwm, 0, 1);\nSENSOR_TEMPLATE_2(pwm_auto_point2_temp, \"pwm%d_auto_point2_temp\",\n\t\t  0644, show_auto_temp, store_auto_temp, 0, 1);\n\nSENSOR_TEMPLATE_2(pwm_auto_point3_pwm, \"pwm%d_auto_point3_pwm\",\n\t\t  0644, show_auto_pwm, store_auto_pwm, 0, 2);\nSENSOR_TEMPLATE_2(pwm_auto_point3_temp, \"pwm%d_auto_point3_temp\",\n\t\t  0644, show_auto_temp, store_auto_temp, 0, 2);\n\nSENSOR_TEMPLATE_2(pwm_auto_point4_pwm, \"pwm%d_auto_point4_pwm\",\n\t\t  0644, show_auto_pwm, store_auto_pwm, 0, 3);\nSENSOR_TEMPLATE_2(pwm_auto_point4_temp, \"pwm%d_auto_point4_temp\",\n\t\t  0644, show_auto_temp, store_auto_temp, 0, 3);\n\nSENSOR_TEMPLATE_2(pwm_auto_point5_pwm, \"pwm%d_auto_point5_pwm\",\n\t\t  0644, show_auto_pwm, store_auto_pwm, 0, 4);\nSENSOR_TEMPLATE_2(pwm_auto_point5_temp, \"pwm%d_auto_point5_temp\",\n\t\t  0644, show_auto_temp, store_auto_temp, 0, 4);\n\nSENSOR_TEMPLATE_2(pwm_auto_point6_pwm, \"pwm%d_auto_point6_pwm\",\n\t\t  0644, show_auto_pwm, store_auto_pwm, 0, 5);\nSENSOR_TEMPLATE_2(pwm_auto_point6_temp, \"pwm%d_auto_point6_temp\",\n\t\t  0644, show_auto_temp, store_auto_temp, 0, 5);\n\nSENSOR_TEMPLATE_2(pwm_auto_point7_pwm, \"pwm%d_auto_point7_pwm\",\n\t\t  0644, show_auto_pwm, store_auto_pwm, 0, 6);\nSENSOR_TEMPLATE_2(pwm_auto_point7_temp, \"pwm%d_auto_point7_temp\",\n\t\t  0644, show_auto_temp, store_auto_temp, 0, 6);\n\n \nstatic struct sensor_device_template *nct6775_attributes_pwm_template[] = {\n\t&sensor_dev_template_pwm,\n\t&sensor_dev_template_pwm_mode,\n\t&sensor_dev_template_pwm_enable,\n\t&sensor_dev_template_pwm_temp_sel,\n\t&sensor_dev_template_pwm_temp_tolerance,\n\t&sensor_dev_template_pwm_crit_temp_tolerance,\n\t&sensor_dev_template_pwm_target_temp,\n\t&sensor_dev_template_fan_target,\n\t&sensor_dev_template_fan_tolerance,\n\t&sensor_dev_template_pwm_stop_time,\n\t&sensor_dev_template_pwm_step_up_time,\n\t&sensor_dev_template_pwm_step_down_time,\n\t&sensor_dev_template_pwm_start,\n\t&sensor_dev_template_pwm_floor,\n\t&sensor_dev_template_pwm_weight_temp_sel,\t \n\t&sensor_dev_template_pwm_weight_temp_step,\n\t&sensor_dev_template_pwm_weight_temp_step_tol,\n\t&sensor_dev_template_pwm_weight_temp_step_base,\n\t&sensor_dev_template_pwm_weight_duty_step,\t \n\t&sensor_dev_template_pwm_max,\t\t\t \n\t&sensor_dev_template_pwm_step,\t\t\t \n\t&sensor_dev_template_pwm_weight_duty_base,\t \n\t&sensor_dev_template_pwm_auto_point1_pwm,\t \n\t&sensor_dev_template_pwm_auto_point1_temp,\n\t&sensor_dev_template_pwm_auto_point2_pwm,\n\t&sensor_dev_template_pwm_auto_point2_temp,\n\t&sensor_dev_template_pwm_auto_point3_pwm,\n\t&sensor_dev_template_pwm_auto_point3_temp,\n\t&sensor_dev_template_pwm_auto_point4_pwm,\n\t&sensor_dev_template_pwm_auto_point4_temp,\n\t&sensor_dev_template_pwm_auto_point5_pwm,\n\t&sensor_dev_template_pwm_auto_point5_temp,\n\t&sensor_dev_template_pwm_auto_point6_pwm,\n\t&sensor_dev_template_pwm_auto_point6_temp,\n\t&sensor_dev_template_pwm_auto_point7_pwm,\n\t&sensor_dev_template_pwm_auto_point7_temp,\t \n\n\tNULL\n};\n\nstatic const struct sensor_template_group nct6775_pwm_template_group = {\n\t.templates = nct6775_attributes_pwm_template,\n\t.is_visible = nct6775_pwm_is_visible,\n\t.base = 1,\n};\n\nstatic inline int nct6775_init_device(struct nct6775_data *data)\n{\n\tint i, err;\n\tu16 tmp, diode;\n\n\t \n\tif (data->REG_CONFIG) {\n\t\terr = nct6775_read_value(data, data->REG_CONFIG, &tmp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!(tmp & 0x01)) {\n\t\t\terr = nct6775_write_value(data, data->REG_CONFIG, tmp | 0x01);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < NUM_TEMP; i++) {\n\t\tif (!(data->have_temp & BIT(i)))\n\t\t\tcontinue;\n\t\tif (!data->reg_temp_config[i])\n\t\t\tcontinue;\n\t\terr = nct6775_read_value(data, data->reg_temp_config[i], &tmp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (tmp & 0x01) {\n\t\t\terr = nct6775_write_value(data, data->reg_temp_config[i], tmp & 0xfe);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = nct6775_read_value(data, data->REG_VBAT, &tmp);\n\tif (err)\n\t\treturn err;\n\tif (!(tmp & 0x01)) {\n\t\terr = nct6775_write_value(data, data->REG_VBAT, tmp | 0x01);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = nct6775_read_value(data, data->REG_DIODE, &diode);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < data->temp_fixed_num; i++) {\n\t\tif (!(data->have_temp_fixed & BIT(i)))\n\t\t\tcontinue;\n\t\tif ((tmp & (data->DIODE_MASK << i)))\t \n\t\t\tdata->temp_type[i]\n\t\t\t  = 3 - ((diode >> i) & data->DIODE_MASK);\n\t\telse\t\t\t\t \n\t\t\tdata->temp_type[i] = 4;\n\t}\n\n\treturn 0;\n}\n\nstatic int add_temp_sensors(struct nct6775_data *data, const u16 *regp,\n\t\t\t    int *available, int *mask)\n{\n\tint i, err;\n\tu16 src;\n\n\tfor (i = 0; i < data->pwm_num && *available; i++) {\n\t\tint index;\n\n\t\tif (!regp[i])\n\t\t\tcontinue;\n\t\terr = nct6775_read_value(data, regp[i], &src);\n\t\tif (err)\n\t\t\treturn err;\n\t\tsrc &= 0x1f;\n\t\tif (!src || (*mask & BIT(src)))\n\t\t\tcontinue;\n\t\tif (!(data->temp_mask & BIT(src)))\n\t\t\tcontinue;\n\n\t\tindex = __ffs(*available);\n\t\terr = nct6775_write_value(data, data->REG_TEMP_SOURCE[index], src);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*available &= ~BIT(index);\n\t\t*mask |= BIT(src);\n\t}\n\n\treturn 0;\n}\n\nint nct6775_probe(struct device *dev, struct nct6775_data *data,\n\t\t  const struct regmap_config *regmapcfg)\n{\n\tint i, s, err = 0;\n\tint mask, available;\n\tu16 src;\n\tconst u16 *reg_temp, *reg_temp_over, *reg_temp_hyst, *reg_temp_config;\n\tconst u16 *reg_temp_mon, *reg_temp_alternate, *reg_temp_crit;\n\tconst u16 *reg_temp_crit_l = NULL, *reg_temp_crit_h = NULL;\n\tint num_reg_temp, num_reg_temp_mon, num_reg_tsi_temp;\n\tstruct device *hwmon_dev;\n\tstruct sensor_template_group tsi_temp_tg;\n\n\tdata->regmap = devm_regmap_init(dev, NULL, data, regmapcfg);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\tmutex_init(&data->update_lock);\n\tdata->name = nct6775_device_names[data->kind];\n\tdata->bank = 0xff;\t\t \n\tdata->scale_in = scale_in;\n\n\tswitch (data->kind) {\n\tcase nct6106:\n\t\tdata->in_num = 9;\n\t\tdata->pwm_num = 3;\n\t\tdata->auto_pwm_num = 4;\n\t\tdata->temp_fixed_num = 3;\n\t\tdata->num_temp_alarms = 6;\n\t\tdata->num_temp_beeps = 6;\n\n\t\tdata->fan_from_reg = fan_from_reg13;\n\t\tdata->fan_from_reg_min = fan_from_reg13;\n\n\t\tdata->temp_label = nct6776_temp_label;\n\t\tdata->temp_mask = NCT6776_TEMP_MASK;\n\t\tdata->virt_temp_mask = NCT6776_VIRT_TEMP_MASK;\n\n\t\tdata->REG_VBAT = NCT6106_REG_VBAT;\n\t\tdata->REG_DIODE = NCT6106_REG_DIODE;\n\t\tdata->DIODE_MASK = NCT6106_DIODE_MASK;\n\t\tdata->REG_VIN = NCT6106_REG_IN;\n\t\tdata->REG_IN_MINMAX[0] = NCT6106_REG_IN_MIN;\n\t\tdata->REG_IN_MINMAX[1] = NCT6106_REG_IN_MAX;\n\t\tdata->REG_TARGET = NCT6106_REG_TARGET;\n\t\tdata->REG_FAN = NCT6106_REG_FAN;\n\t\tdata->REG_FAN_MODE = NCT6106_REG_FAN_MODE;\n\t\tdata->REG_FAN_MIN = NCT6106_REG_FAN_MIN;\n\t\tdata->REG_FAN_PULSES = NCT6106_REG_FAN_PULSES;\n\t\tdata->FAN_PULSE_SHIFT = NCT6106_FAN_PULSE_SHIFT;\n\t\tdata->REG_FAN_TIME[0] = NCT6106_REG_FAN_STOP_TIME;\n\t\tdata->REG_FAN_TIME[1] = NCT6106_REG_FAN_STEP_UP_TIME;\n\t\tdata->REG_FAN_TIME[2] = NCT6106_REG_FAN_STEP_DOWN_TIME;\n\t\tdata->REG_TOLERANCE_H = NCT6106_REG_TOLERANCE_H;\n\t\tdata->REG_PWM[0] = NCT6116_REG_PWM;\n\t\tdata->REG_PWM[1] = NCT6106_REG_FAN_START_OUTPUT;\n\t\tdata->REG_PWM[2] = NCT6106_REG_FAN_STOP_OUTPUT;\n\t\tdata->REG_PWM[5] = NCT6106_REG_WEIGHT_DUTY_STEP;\n\t\tdata->REG_PWM[6] = NCT6106_REG_WEIGHT_DUTY_BASE;\n\t\tdata->REG_PWM_READ = NCT6106_REG_PWM_READ;\n\t\tdata->REG_PWM_MODE = NCT6106_REG_PWM_MODE;\n\t\tdata->PWM_MODE_MASK = NCT6106_PWM_MODE_MASK;\n\t\tdata->REG_AUTO_TEMP = NCT6106_REG_AUTO_TEMP;\n\t\tdata->REG_AUTO_PWM = NCT6106_REG_AUTO_PWM;\n\t\tdata->REG_CRITICAL_TEMP = NCT6106_REG_CRITICAL_TEMP;\n\t\tdata->REG_CRITICAL_TEMP_TOLERANCE\n\t\t  = NCT6106_REG_CRITICAL_TEMP_TOLERANCE;\n\t\tdata->REG_CRITICAL_PWM_ENABLE = NCT6106_REG_CRITICAL_PWM_ENABLE;\n\t\tdata->CRITICAL_PWM_ENABLE_MASK\n\t\t  = NCT6106_CRITICAL_PWM_ENABLE_MASK;\n\t\tdata->REG_CRITICAL_PWM = NCT6106_REG_CRITICAL_PWM;\n\t\tdata->REG_TEMP_OFFSET = NCT6106_REG_TEMP_OFFSET;\n\t\tdata->REG_TEMP_SOURCE = NCT6106_REG_TEMP_SOURCE;\n\t\tdata->REG_TEMP_SEL = NCT6116_REG_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP_SEL = NCT6106_REG_WEIGHT_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP[0] = NCT6106_REG_WEIGHT_TEMP_STEP;\n\t\tdata->REG_WEIGHT_TEMP[1] = NCT6106_REG_WEIGHT_TEMP_STEP_TOL;\n\t\tdata->REG_WEIGHT_TEMP[2] = NCT6106_REG_WEIGHT_TEMP_BASE;\n\t\tdata->REG_ALARM = NCT6106_REG_ALARM;\n\t\tdata->ALARM_BITS = NCT6106_ALARM_BITS;\n\t\tdata->REG_BEEP = NCT6106_REG_BEEP;\n\t\tdata->BEEP_BITS = NCT6106_BEEP_BITS;\n\t\tdata->REG_TSI_TEMP = NCT6106_REG_TSI_TEMP;\n\n\t\treg_temp = NCT6106_REG_TEMP;\n\t\treg_temp_mon = NCT6106_REG_TEMP_MON;\n\t\tnum_reg_temp = ARRAY_SIZE(NCT6106_REG_TEMP);\n\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6106_REG_TEMP_MON);\n\t\tnum_reg_tsi_temp = ARRAY_SIZE(NCT6106_REG_TSI_TEMP);\n\t\treg_temp_over = NCT6106_REG_TEMP_OVER;\n\t\treg_temp_hyst = NCT6106_REG_TEMP_HYST;\n\t\treg_temp_config = NCT6106_REG_TEMP_CONFIG;\n\t\treg_temp_alternate = NCT6106_REG_TEMP_ALTERNATE;\n\t\treg_temp_crit = NCT6106_REG_TEMP_CRIT;\n\t\treg_temp_crit_l = NCT6106_REG_TEMP_CRIT_L;\n\t\treg_temp_crit_h = NCT6106_REG_TEMP_CRIT_H;\n\n\t\tbreak;\n\tcase nct6116:\n\t\tdata->in_num = 9;\n\t\tdata->pwm_num = 3;\n\t\tdata->auto_pwm_num = 4;\n\t\tdata->temp_fixed_num = 3;\n\t\tdata->num_temp_alarms = 3;\n\t\tdata->num_temp_beeps = 3;\n\n\t\tdata->fan_from_reg = fan_from_reg13;\n\t\tdata->fan_from_reg_min = fan_from_reg13;\n\n\t\tdata->temp_label = nct6776_temp_label;\n\t\tdata->temp_mask = NCT6776_TEMP_MASK;\n\t\tdata->virt_temp_mask = NCT6776_VIRT_TEMP_MASK;\n\n\t\tdata->REG_VBAT = NCT6106_REG_VBAT;\n\t\tdata->REG_DIODE = NCT6106_REG_DIODE;\n\t\tdata->DIODE_MASK = NCT6106_DIODE_MASK;\n\t\tdata->REG_VIN = NCT6106_REG_IN;\n\t\tdata->REG_IN_MINMAX[0] = NCT6106_REG_IN_MIN;\n\t\tdata->REG_IN_MINMAX[1] = NCT6106_REG_IN_MAX;\n\t\tdata->REG_TARGET = NCT6116_REG_TARGET;\n\t\tdata->REG_FAN = NCT6116_REG_FAN;\n\t\tdata->REG_FAN_MODE = NCT6116_REG_FAN_MODE;\n\t\tdata->REG_FAN_MIN = NCT6116_REG_FAN_MIN;\n\t\tdata->REG_FAN_PULSES = NCT6116_REG_FAN_PULSES;\n\t\tdata->FAN_PULSE_SHIFT = NCT6116_FAN_PULSE_SHIFT;\n\t\tdata->REG_FAN_TIME[0] = NCT6116_REG_FAN_STOP_TIME;\n\t\tdata->REG_FAN_TIME[1] = NCT6116_REG_FAN_STEP_UP_TIME;\n\t\tdata->REG_FAN_TIME[2] = NCT6116_REG_FAN_STEP_DOWN_TIME;\n\t\tdata->REG_TOLERANCE_H = NCT6116_REG_TOLERANCE_H;\n\t\tdata->REG_PWM[0] = NCT6116_REG_PWM;\n\t\tdata->REG_PWM[1] = NCT6116_REG_FAN_START_OUTPUT;\n\t\tdata->REG_PWM[2] = NCT6116_REG_FAN_STOP_OUTPUT;\n\t\tdata->REG_PWM[5] = NCT6106_REG_WEIGHT_DUTY_STEP;\n\t\tdata->REG_PWM[6] = NCT6106_REG_WEIGHT_DUTY_BASE;\n\t\tdata->REG_PWM_READ = NCT6106_REG_PWM_READ;\n\t\tdata->REG_PWM_MODE = NCT6106_REG_PWM_MODE;\n\t\tdata->PWM_MODE_MASK = NCT6106_PWM_MODE_MASK;\n\t\tdata->REG_AUTO_TEMP = NCT6116_REG_AUTO_TEMP;\n\t\tdata->REG_AUTO_PWM = NCT6116_REG_AUTO_PWM;\n\t\tdata->REG_CRITICAL_TEMP = NCT6116_REG_CRITICAL_TEMP;\n\t\tdata->REG_CRITICAL_TEMP_TOLERANCE\n\t\t  = NCT6116_REG_CRITICAL_TEMP_TOLERANCE;\n\t\tdata->REG_CRITICAL_PWM_ENABLE = NCT6116_REG_CRITICAL_PWM_ENABLE;\n\t\tdata->CRITICAL_PWM_ENABLE_MASK\n\t\t  = NCT6106_CRITICAL_PWM_ENABLE_MASK;\n\t\tdata->REG_CRITICAL_PWM = NCT6116_REG_CRITICAL_PWM;\n\t\tdata->REG_TEMP_OFFSET = NCT6106_REG_TEMP_OFFSET;\n\t\tdata->REG_TEMP_SOURCE = NCT6116_REG_TEMP_SOURCE;\n\t\tdata->REG_TEMP_SEL = NCT6116_REG_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP_SEL = NCT6106_REG_WEIGHT_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP[0] = NCT6106_REG_WEIGHT_TEMP_STEP;\n\t\tdata->REG_WEIGHT_TEMP[1] = NCT6106_REG_WEIGHT_TEMP_STEP_TOL;\n\t\tdata->REG_WEIGHT_TEMP[2] = NCT6106_REG_WEIGHT_TEMP_BASE;\n\t\tdata->REG_ALARM = NCT6106_REG_ALARM;\n\t\tdata->ALARM_BITS = NCT6116_ALARM_BITS;\n\t\tdata->REG_BEEP = NCT6106_REG_BEEP;\n\t\tdata->BEEP_BITS = NCT6116_BEEP_BITS;\n\t\tdata->REG_TSI_TEMP = NCT6116_REG_TSI_TEMP;\n\n\t\treg_temp = NCT6106_REG_TEMP;\n\t\treg_temp_mon = NCT6106_REG_TEMP_MON;\n\t\tnum_reg_temp = ARRAY_SIZE(NCT6106_REG_TEMP);\n\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6106_REG_TEMP_MON);\n\t\tnum_reg_tsi_temp = ARRAY_SIZE(NCT6116_REG_TSI_TEMP);\n\t\treg_temp_over = NCT6106_REG_TEMP_OVER;\n\t\treg_temp_hyst = NCT6106_REG_TEMP_HYST;\n\t\treg_temp_config = NCT6106_REG_TEMP_CONFIG;\n\t\treg_temp_alternate = NCT6106_REG_TEMP_ALTERNATE;\n\t\treg_temp_crit = NCT6106_REG_TEMP_CRIT;\n\t\treg_temp_crit_l = NCT6106_REG_TEMP_CRIT_L;\n\t\treg_temp_crit_h = NCT6106_REG_TEMP_CRIT_H;\n\n\t\tbreak;\n\tcase nct6775:\n\t\tdata->in_num = 9;\n\t\tdata->pwm_num = 3;\n\t\tdata->auto_pwm_num = 6;\n\t\tdata->has_fan_div = true;\n\t\tdata->temp_fixed_num = 3;\n\t\tdata->num_temp_alarms = 3;\n\t\tdata->num_temp_beeps = 3;\n\n\t\tdata->ALARM_BITS = NCT6775_ALARM_BITS;\n\t\tdata->BEEP_BITS = NCT6775_BEEP_BITS;\n\n\t\tdata->fan_from_reg = fan_from_reg16;\n\t\tdata->fan_from_reg_min = fan_from_reg8;\n\t\tdata->target_temp_mask = 0x7f;\n\t\tdata->tolerance_mask = 0x0f;\n\t\tdata->speed_tolerance_limit = 15;\n\n\t\tdata->temp_label = nct6775_temp_label;\n\t\tdata->temp_mask = NCT6775_TEMP_MASK;\n\t\tdata->virt_temp_mask = NCT6775_VIRT_TEMP_MASK;\n\n\t\tdata->REG_CONFIG = NCT6775_REG_CONFIG;\n\t\tdata->REG_VBAT = NCT6775_REG_VBAT;\n\t\tdata->REG_DIODE = NCT6775_REG_DIODE;\n\t\tdata->DIODE_MASK = NCT6775_DIODE_MASK;\n\t\tdata->REG_VIN = NCT6775_REG_IN;\n\t\tdata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\n\t\tdata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\n\t\tdata->REG_TARGET = NCT6775_REG_TARGET;\n\t\tdata->REG_FAN = NCT6775_REG_FAN;\n\t\tdata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\n\t\tdata->REG_FAN_MIN = NCT6775_REG_FAN_MIN;\n\t\tdata->REG_FAN_PULSES = NCT6775_REG_FAN_PULSES;\n\t\tdata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\n\t\tdata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\n\t\tdata->REG_FAN_TIME[1] = NCT6775_REG_FAN_STEP_UP_TIME;\n\t\tdata->REG_FAN_TIME[2] = NCT6775_REG_FAN_STEP_DOWN_TIME;\n\t\tdata->REG_PWM[0] = NCT6775_REG_PWM;\n\t\tdata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\n\t\tdata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\n\t\tdata->REG_PWM[3] = NCT6775_REG_FAN_MAX_OUTPUT;\n\t\tdata->REG_PWM[4] = NCT6775_REG_FAN_STEP_OUTPUT;\n\t\tdata->REG_PWM[5] = NCT6775_REG_WEIGHT_DUTY_STEP;\n\t\tdata->REG_PWM_READ = NCT6775_REG_PWM_READ;\n\t\tdata->REG_PWM_MODE = NCT6775_REG_PWM_MODE;\n\t\tdata->PWM_MODE_MASK = NCT6775_PWM_MODE_MASK;\n\t\tdata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\n\t\tdata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\n\t\tdata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\n\t\tdata->REG_CRITICAL_TEMP_TOLERANCE\n\t\t  = NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\n\t\tdata->REG_TEMP_OFFSET = NCT6775_REG_TEMP_OFFSET;\n\t\tdata->REG_TEMP_SOURCE = NCT6775_REG_TEMP_SOURCE;\n\t\tdata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP_SEL = NCT6775_REG_WEIGHT_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP[0] = NCT6775_REG_WEIGHT_TEMP_STEP;\n\t\tdata->REG_WEIGHT_TEMP[1] = NCT6775_REG_WEIGHT_TEMP_STEP_TOL;\n\t\tdata->REG_WEIGHT_TEMP[2] = NCT6775_REG_WEIGHT_TEMP_BASE;\n\t\tdata->REG_ALARM = NCT6775_REG_ALARM;\n\t\tdata->REG_BEEP = NCT6775_REG_BEEP;\n\t\tdata->REG_TSI_TEMP = NCT6775_REG_TSI_TEMP;\n\n\t\treg_temp = NCT6775_REG_TEMP;\n\t\treg_temp_mon = NCT6775_REG_TEMP_MON;\n\t\tnum_reg_temp = ARRAY_SIZE(NCT6775_REG_TEMP);\n\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6775_REG_TEMP_MON);\n\t\tnum_reg_tsi_temp = ARRAY_SIZE(NCT6775_REG_TSI_TEMP);\n\t\treg_temp_over = NCT6775_REG_TEMP_OVER;\n\t\treg_temp_hyst = NCT6775_REG_TEMP_HYST;\n\t\treg_temp_config = NCT6775_REG_TEMP_CONFIG;\n\t\treg_temp_alternate = NCT6775_REG_TEMP_ALTERNATE;\n\t\treg_temp_crit = NCT6775_REG_TEMP_CRIT;\n\n\t\tbreak;\n\tcase nct6776:\n\t\tdata->in_num = 9;\n\t\tdata->pwm_num = 3;\n\t\tdata->auto_pwm_num = 4;\n\t\tdata->has_fan_div = false;\n\t\tdata->temp_fixed_num = 3;\n\t\tdata->num_temp_alarms = 3;\n\t\tdata->num_temp_beeps = 6;\n\n\t\tdata->ALARM_BITS = NCT6776_ALARM_BITS;\n\t\tdata->BEEP_BITS = NCT6776_BEEP_BITS;\n\n\t\tdata->fan_from_reg = fan_from_reg13;\n\t\tdata->fan_from_reg_min = fan_from_reg13;\n\t\tdata->target_temp_mask = 0xff;\n\t\tdata->tolerance_mask = 0x07;\n\t\tdata->speed_tolerance_limit = 63;\n\n\t\tdata->temp_label = nct6776_temp_label;\n\t\tdata->temp_mask = NCT6776_TEMP_MASK;\n\t\tdata->virt_temp_mask = NCT6776_VIRT_TEMP_MASK;\n\n\t\tdata->REG_CONFIG = NCT6775_REG_CONFIG;\n\t\tdata->REG_VBAT = NCT6775_REG_VBAT;\n\t\tdata->REG_DIODE = NCT6775_REG_DIODE;\n\t\tdata->DIODE_MASK = NCT6775_DIODE_MASK;\n\t\tdata->REG_VIN = NCT6775_REG_IN;\n\t\tdata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\n\t\tdata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\n\t\tdata->REG_TARGET = NCT6775_REG_TARGET;\n\t\tdata->REG_FAN = NCT6775_REG_FAN;\n\t\tdata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\n\t\tdata->REG_FAN_MIN = NCT6776_REG_FAN_MIN;\n\t\tdata->REG_FAN_PULSES = NCT6776_REG_FAN_PULSES;\n\t\tdata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\n\t\tdata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\n\t\tdata->REG_FAN_TIME[1] = NCT6776_REG_FAN_STEP_UP_TIME;\n\t\tdata->REG_FAN_TIME[2] = NCT6776_REG_FAN_STEP_DOWN_TIME;\n\t\tdata->REG_TOLERANCE_H = NCT6776_REG_TOLERANCE_H;\n\t\tdata->REG_PWM[0] = NCT6775_REG_PWM;\n\t\tdata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\n\t\tdata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\n\t\tdata->REG_PWM[5] = NCT6775_REG_WEIGHT_DUTY_STEP;\n\t\tdata->REG_PWM[6] = NCT6776_REG_WEIGHT_DUTY_BASE;\n\t\tdata->REG_PWM_READ = NCT6775_REG_PWM_READ;\n\t\tdata->REG_PWM_MODE = NCT6776_REG_PWM_MODE;\n\t\tdata->PWM_MODE_MASK = NCT6776_PWM_MODE_MASK;\n\t\tdata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\n\t\tdata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\n\t\tdata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\n\t\tdata->REG_CRITICAL_TEMP_TOLERANCE\n\t\t  = NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\n\t\tdata->REG_TEMP_OFFSET = NCT6775_REG_TEMP_OFFSET;\n\t\tdata->REG_TEMP_SOURCE = NCT6775_REG_TEMP_SOURCE;\n\t\tdata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP_SEL = NCT6775_REG_WEIGHT_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP[0] = NCT6775_REG_WEIGHT_TEMP_STEP;\n\t\tdata->REG_WEIGHT_TEMP[1] = NCT6775_REG_WEIGHT_TEMP_STEP_TOL;\n\t\tdata->REG_WEIGHT_TEMP[2] = NCT6775_REG_WEIGHT_TEMP_BASE;\n\t\tdata->REG_ALARM = NCT6775_REG_ALARM;\n\t\tdata->REG_BEEP = NCT6776_REG_BEEP;\n\t\tdata->REG_TSI_TEMP = NCT6776_REG_TSI_TEMP;\n\n\t\treg_temp = NCT6775_REG_TEMP;\n\t\treg_temp_mon = NCT6775_REG_TEMP_MON;\n\t\tnum_reg_temp = ARRAY_SIZE(NCT6775_REG_TEMP);\n\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6775_REG_TEMP_MON);\n\t\tnum_reg_tsi_temp = ARRAY_SIZE(NCT6776_REG_TSI_TEMP);\n\t\treg_temp_over = NCT6775_REG_TEMP_OVER;\n\t\treg_temp_hyst = NCT6775_REG_TEMP_HYST;\n\t\treg_temp_config = NCT6776_REG_TEMP_CONFIG;\n\t\treg_temp_alternate = NCT6776_REG_TEMP_ALTERNATE;\n\t\treg_temp_crit = NCT6776_REG_TEMP_CRIT;\n\n\t\tbreak;\n\tcase nct6779:\n\t\tdata->in_num = 15;\n\t\tdata->pwm_num = 5;\n\t\tdata->auto_pwm_num = 4;\n\t\tdata->has_fan_div = false;\n\t\tdata->temp_fixed_num = 6;\n\t\tdata->num_temp_alarms = 2;\n\t\tdata->num_temp_beeps = 2;\n\n\t\tdata->ALARM_BITS = NCT6779_ALARM_BITS;\n\t\tdata->BEEP_BITS = NCT6779_BEEP_BITS;\n\n\t\tdata->fan_from_reg = fan_from_reg_rpm;\n\t\tdata->fan_from_reg_min = fan_from_reg13;\n\t\tdata->target_temp_mask = 0xff;\n\t\tdata->tolerance_mask = 0x07;\n\t\tdata->speed_tolerance_limit = 63;\n\n\t\tdata->temp_label = nct6779_temp_label;\n\t\tdata->temp_mask = NCT6779_TEMP_MASK;\n\t\tdata->virt_temp_mask = NCT6779_VIRT_TEMP_MASK;\n\n\t\tdata->REG_CONFIG = NCT6775_REG_CONFIG;\n\t\tdata->REG_VBAT = NCT6775_REG_VBAT;\n\t\tdata->REG_DIODE = NCT6775_REG_DIODE;\n\t\tdata->DIODE_MASK = NCT6775_DIODE_MASK;\n\t\tdata->REG_VIN = NCT6779_REG_IN;\n\t\tdata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\n\t\tdata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\n\t\tdata->REG_TARGET = NCT6775_REG_TARGET;\n\t\tdata->REG_FAN = NCT6779_REG_FAN;\n\t\tdata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\n\t\tdata->REG_FAN_MIN = NCT6776_REG_FAN_MIN;\n\t\tdata->REG_FAN_PULSES = NCT6779_REG_FAN_PULSES;\n\t\tdata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\n\t\tdata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\n\t\tdata->REG_FAN_TIME[1] = NCT6776_REG_FAN_STEP_UP_TIME;\n\t\tdata->REG_FAN_TIME[2] = NCT6776_REG_FAN_STEP_DOWN_TIME;\n\t\tdata->REG_TOLERANCE_H = NCT6776_REG_TOLERANCE_H;\n\t\tdata->REG_PWM[0] = NCT6775_REG_PWM;\n\t\tdata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\n\t\tdata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\n\t\tdata->REG_PWM[5] = NCT6775_REG_WEIGHT_DUTY_STEP;\n\t\tdata->REG_PWM[6] = NCT6776_REG_WEIGHT_DUTY_BASE;\n\t\tdata->REG_PWM_READ = NCT6775_REG_PWM_READ;\n\t\tdata->REG_PWM_MODE = NCT6776_REG_PWM_MODE;\n\t\tdata->PWM_MODE_MASK = NCT6776_PWM_MODE_MASK;\n\t\tdata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\n\t\tdata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\n\t\tdata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\n\t\tdata->REG_CRITICAL_TEMP_TOLERANCE\n\t\t  = NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\n\t\tdata->REG_CRITICAL_PWM_ENABLE = NCT6779_REG_CRITICAL_PWM_ENABLE;\n\t\tdata->CRITICAL_PWM_ENABLE_MASK\n\t\t  = NCT6779_CRITICAL_PWM_ENABLE_MASK;\n\t\tdata->REG_CRITICAL_PWM = NCT6779_REG_CRITICAL_PWM;\n\t\tdata->REG_TEMP_OFFSET = NCT6779_REG_TEMP_OFFSET;\n\t\tdata->REG_TEMP_SOURCE = NCT6775_REG_TEMP_SOURCE;\n\t\tdata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP_SEL = NCT6775_REG_WEIGHT_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP[0] = NCT6775_REG_WEIGHT_TEMP_STEP;\n\t\tdata->REG_WEIGHT_TEMP[1] = NCT6775_REG_WEIGHT_TEMP_STEP_TOL;\n\t\tdata->REG_WEIGHT_TEMP[2] = NCT6775_REG_WEIGHT_TEMP_BASE;\n\t\tdata->REG_ALARM = NCT6779_REG_ALARM;\n\t\tdata->REG_BEEP = NCT6776_REG_BEEP;\n\t\tdata->REG_TSI_TEMP = NCT6776_REG_TSI_TEMP;\n\n\t\treg_temp = NCT6779_REG_TEMP;\n\t\treg_temp_mon = NCT6779_REG_TEMP_MON;\n\t\tnum_reg_temp = ARRAY_SIZE(NCT6779_REG_TEMP);\n\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6779_REG_TEMP_MON);\n\t\tnum_reg_tsi_temp = ARRAY_SIZE(NCT6776_REG_TSI_TEMP);\n\t\treg_temp_over = NCT6779_REG_TEMP_OVER;\n\t\treg_temp_hyst = NCT6779_REG_TEMP_HYST;\n\t\treg_temp_config = NCT6779_REG_TEMP_CONFIG;\n\t\treg_temp_alternate = NCT6779_REG_TEMP_ALTERNATE;\n\t\treg_temp_crit = NCT6779_REG_TEMP_CRIT;\n\n\t\tbreak;\n\tcase nct6791:\n\tcase nct6792:\n\tcase nct6793:\n\tcase nct6795:\n\tcase nct6796:\n\tcase nct6797:\n\t\tdata->in_num = 15;\n\t\tdata->pwm_num = (data->kind == nct6796 ||\n\t\t\t\t data->kind == nct6797) ? 7 : 6;\n\t\tdata->auto_pwm_num = 4;\n\t\tdata->has_fan_div = false;\n\t\tdata->temp_fixed_num = 6;\n\t\tdata->num_temp_alarms = 2;\n\t\tdata->num_temp_beeps = 2;\n\n\t\tdata->ALARM_BITS = NCT6791_ALARM_BITS;\n\t\tdata->BEEP_BITS = NCT6779_BEEP_BITS;\n\n\t\tdata->fan_from_reg = fan_from_reg_rpm;\n\t\tdata->fan_from_reg_min = fan_from_reg13;\n\t\tdata->target_temp_mask = 0xff;\n\t\tdata->tolerance_mask = 0x07;\n\t\tdata->speed_tolerance_limit = 63;\n\n\t\tswitch (data->kind) {\n\t\tdefault:\n\t\tcase nct6791:\n\t\t\tdata->temp_label = nct6779_temp_label;\n\t\t\tdata->temp_mask = NCT6791_TEMP_MASK;\n\t\t\tdata->virt_temp_mask = NCT6791_VIRT_TEMP_MASK;\n\t\t\tbreak;\n\t\tcase nct6792:\n\t\t\tdata->temp_label = nct6792_temp_label;\n\t\t\tdata->temp_mask = NCT6792_TEMP_MASK;\n\t\t\tdata->virt_temp_mask = NCT6792_VIRT_TEMP_MASK;\n\t\t\tbreak;\n\t\tcase nct6793:\n\t\t\tdata->temp_label = nct6793_temp_label;\n\t\t\tdata->temp_mask = NCT6793_TEMP_MASK;\n\t\t\tdata->virt_temp_mask = NCT6793_VIRT_TEMP_MASK;\n\t\t\tbreak;\n\t\tcase nct6795:\n\t\tcase nct6797:\n\t\t\tdata->temp_label = nct6795_temp_label;\n\t\t\tdata->temp_mask = NCT6795_TEMP_MASK;\n\t\t\tdata->virt_temp_mask = NCT6795_VIRT_TEMP_MASK;\n\t\t\tbreak;\n\t\tcase nct6796:\n\t\t\tdata->temp_label = nct6796_temp_label;\n\t\t\tdata->temp_mask = NCT6796_TEMP_MASK;\n\t\t\tdata->virt_temp_mask = NCT6796_VIRT_TEMP_MASK;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->REG_CONFIG = NCT6775_REG_CONFIG;\n\t\tdata->REG_VBAT = NCT6775_REG_VBAT;\n\t\tdata->REG_DIODE = NCT6775_REG_DIODE;\n\t\tdata->DIODE_MASK = NCT6775_DIODE_MASK;\n\t\tdata->REG_VIN = NCT6779_REG_IN;\n\t\tdata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\n\t\tdata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\n\t\tdata->REG_TARGET = NCT6775_REG_TARGET;\n\t\tdata->REG_FAN = NCT6779_REG_FAN;\n\t\tdata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\n\t\tdata->REG_FAN_MIN = NCT6776_REG_FAN_MIN;\n\t\tdata->REG_FAN_PULSES = NCT6779_REG_FAN_PULSES;\n\t\tdata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\n\t\tdata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\n\t\tdata->REG_FAN_TIME[1] = NCT6776_REG_FAN_STEP_UP_TIME;\n\t\tdata->REG_FAN_TIME[2] = NCT6776_REG_FAN_STEP_DOWN_TIME;\n\t\tdata->REG_TOLERANCE_H = NCT6776_REG_TOLERANCE_H;\n\t\tdata->REG_PWM[0] = NCT6775_REG_PWM;\n\t\tdata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\n\t\tdata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\n\t\tdata->REG_PWM[5] = NCT6791_REG_WEIGHT_DUTY_STEP;\n\t\tdata->REG_PWM[6] = NCT6791_REG_WEIGHT_DUTY_BASE;\n\t\tdata->REG_PWM_READ = NCT6775_REG_PWM_READ;\n\t\tdata->REG_PWM_MODE = NCT6776_REG_PWM_MODE;\n\t\tdata->PWM_MODE_MASK = NCT6776_PWM_MODE_MASK;\n\t\tdata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\n\t\tdata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\n\t\tdata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\n\t\tdata->REG_CRITICAL_TEMP_TOLERANCE\n\t\t  = NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\n\t\tdata->REG_CRITICAL_PWM_ENABLE = NCT6779_REG_CRITICAL_PWM_ENABLE;\n\t\tdata->CRITICAL_PWM_ENABLE_MASK\n\t\t  = NCT6779_CRITICAL_PWM_ENABLE_MASK;\n\t\tdata->REG_CRITICAL_PWM = NCT6779_REG_CRITICAL_PWM;\n\t\tdata->REG_TEMP_OFFSET = NCT6779_REG_TEMP_OFFSET;\n\t\tdata->REG_TEMP_SOURCE = NCT6775_REG_TEMP_SOURCE;\n\t\tdata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP_SEL = NCT6791_REG_WEIGHT_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP[0] = NCT6791_REG_WEIGHT_TEMP_STEP;\n\t\tdata->REG_WEIGHT_TEMP[1] = NCT6791_REG_WEIGHT_TEMP_STEP_TOL;\n\t\tdata->REG_WEIGHT_TEMP[2] = NCT6791_REG_WEIGHT_TEMP_BASE;\n\t\tdata->REG_ALARM = NCT6791_REG_ALARM;\n\t\tif (data->kind == nct6791)\n\t\t\tdata->REG_BEEP = NCT6776_REG_BEEP;\n\t\telse\n\t\t\tdata->REG_BEEP = NCT6792_REG_BEEP;\n\t\tswitch (data->kind) {\n\t\tcase nct6791:\n\t\tcase nct6792:\n\t\tcase nct6793:\n\t\t\tdata->REG_TSI_TEMP = NCT6776_REG_TSI_TEMP;\n\t\t\tnum_reg_tsi_temp = ARRAY_SIZE(NCT6776_REG_TSI_TEMP);\n\t\t\tbreak;\n\t\tcase nct6795:\n\t\tcase nct6796:\n\t\tcase nct6797:\n\t\t\tdata->REG_TSI_TEMP = NCT6796_REG_TSI_TEMP;\n\t\t\tnum_reg_tsi_temp = ARRAY_SIZE(NCT6796_REG_TSI_TEMP);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnum_reg_tsi_temp = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\treg_temp = NCT6779_REG_TEMP;\n\t\tnum_reg_temp = ARRAY_SIZE(NCT6779_REG_TEMP);\n\t\tif (data->kind == nct6791) {\n\t\t\treg_temp_mon = NCT6779_REG_TEMP_MON;\n\t\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6779_REG_TEMP_MON);\n\t\t} else {\n\t\t\treg_temp_mon = NCT6792_REG_TEMP_MON;\n\t\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6792_REG_TEMP_MON);\n\t\t}\n\t\treg_temp_over = NCT6779_REG_TEMP_OVER;\n\t\treg_temp_hyst = NCT6779_REG_TEMP_HYST;\n\t\treg_temp_config = NCT6779_REG_TEMP_CONFIG;\n\t\treg_temp_alternate = NCT6779_REG_TEMP_ALTERNATE;\n\t\treg_temp_crit = NCT6779_REG_TEMP_CRIT;\n\n\t\tbreak;\n\tcase nct6798:\n\tcase nct6799:\n\t\tdata->in_num = data->kind == nct6799 ? 18 : 15;\n\t\tdata->scale_in = scale_in_6798;\n\t\tdata->pwm_num = 7;\n\t\tdata->auto_pwm_num = 4;\n\t\tdata->has_fan_div = false;\n\t\tdata->temp_fixed_num = 6;\n\t\tdata->num_temp_alarms = 7;\n\t\tdata->num_temp_beeps = 8;\n\n\t\tdata->ALARM_BITS = NCT6799_ALARM_BITS;\n\t\tdata->BEEP_BITS = NCT6799_BEEP_BITS;\n\n\t\tdata->fan_from_reg = fan_from_reg_rpm;\n\t\tdata->fan_from_reg_min = fan_from_reg13;\n\t\tdata->target_temp_mask = 0xff;\n\t\tdata->tolerance_mask = 0x07;\n\t\tdata->speed_tolerance_limit = 63;\n\n\t\tswitch (data->kind) {\n\t\tdefault:\n\t\tcase nct6798:\n\t\t\tdata->temp_label = nct6798_temp_label;\n\t\t\tdata->temp_mask = NCT6798_TEMP_MASK;\n\t\t\tdata->virt_temp_mask = NCT6798_VIRT_TEMP_MASK;\n\t\t\tbreak;\n\t\tcase nct6799:\n\t\t\tdata->temp_label = nct6799_temp_label;\n\t\t\tdata->temp_mask = NCT6799_TEMP_MASK;\n\t\t\tdata->virt_temp_mask = NCT6799_VIRT_TEMP_MASK;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->REG_CONFIG = NCT6775_REG_CONFIG;\n\t\tdata->REG_VBAT = NCT6775_REG_VBAT;\n\t\tdata->REG_DIODE = NCT6775_REG_DIODE;\n\t\tdata->DIODE_MASK = NCT6775_DIODE_MASK;\n\t\tdata->REG_VIN = NCT6779_REG_IN;\n\t\tdata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\n\t\tdata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\n\t\tdata->REG_TARGET = NCT6775_REG_TARGET;\n\t\tdata->REG_FAN = NCT6779_REG_FAN;\n\t\tdata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\n\t\tdata->REG_FAN_MIN = NCT6776_REG_FAN_MIN;\n\t\tdata->REG_FAN_PULSES = NCT6779_REG_FAN_PULSES;\n\t\tdata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\n\t\tdata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\n\t\tdata->REG_FAN_TIME[1] = NCT6776_REG_FAN_STEP_UP_TIME;\n\t\tdata->REG_FAN_TIME[2] = NCT6776_REG_FAN_STEP_DOWN_TIME;\n\t\tdata->REG_TOLERANCE_H = NCT6776_REG_TOLERANCE_H;\n\t\tdata->REG_PWM[0] = NCT6775_REG_PWM;\n\t\tdata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\n\t\tdata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\n\t\tdata->REG_PWM[5] = NCT6791_REG_WEIGHT_DUTY_STEP;\n\t\tdata->REG_PWM[6] = NCT6791_REG_WEIGHT_DUTY_BASE;\n\t\tdata->REG_PWM_READ = NCT6775_REG_PWM_READ;\n\t\tdata->REG_PWM_MODE = NCT6776_REG_PWM_MODE;\n\t\tdata->PWM_MODE_MASK = NCT6776_PWM_MODE_MASK;\n\t\tdata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\n\t\tdata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\n\t\tdata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\n\t\tdata->REG_CRITICAL_TEMP_TOLERANCE = NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\n\t\tdata->REG_CRITICAL_PWM_ENABLE = NCT6779_REG_CRITICAL_PWM_ENABLE;\n\t\tdata->CRITICAL_PWM_ENABLE_MASK = NCT6779_CRITICAL_PWM_ENABLE_MASK;\n\t\tdata->REG_CRITICAL_PWM = NCT6779_REG_CRITICAL_PWM;\n\t\tdata->REG_TEMP_OFFSET = NCT6779_REG_TEMP_OFFSET;\n\t\tdata->REG_TEMP_SOURCE = NCT6798_REG_TEMP_SOURCE;\n\t\tdata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP_SEL = NCT6791_REG_WEIGHT_TEMP_SEL;\n\t\tdata->REG_WEIGHT_TEMP[0] = NCT6791_REG_WEIGHT_TEMP_STEP;\n\t\tdata->REG_WEIGHT_TEMP[1] = NCT6791_REG_WEIGHT_TEMP_STEP_TOL;\n\t\tdata->REG_WEIGHT_TEMP[2] = NCT6791_REG_WEIGHT_TEMP_BASE;\n\t\tdata->REG_ALARM = NCT6799_REG_ALARM;\n\t\tdata->REG_BEEP = NCT6792_REG_BEEP;\n\t\tdata->REG_TSI_TEMP = NCT6796_REG_TSI_TEMP;\n\t\tnum_reg_tsi_temp = ARRAY_SIZE(NCT6796_REG_TSI_TEMP);\n\n\t\treg_temp = NCT6798_REG_TEMP;\n\t\tnum_reg_temp = ARRAY_SIZE(NCT6798_REG_TEMP);\n\t\treg_temp_mon = NCT6798_REG_TEMP_MON;\n\t\tnum_reg_temp_mon = ARRAY_SIZE(NCT6798_REG_TEMP_MON);\n\t\treg_temp_over = NCT6798_REG_TEMP_OVER;\n\t\treg_temp_hyst = NCT6798_REG_TEMP_HYST;\n\t\treg_temp_config = NCT6779_REG_TEMP_CONFIG;\n\t\treg_temp_alternate = NCT6798_REG_TEMP_ALTERNATE;\n\t\treg_temp_crit = NCT6798_REG_TEMP_CRIT;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\tdata->have_in = BIT(data->in_num) - 1;\n\tdata->have_temp = 0;\n\n\t \n\tmask = 0;\n\tavailable = 0;\n\tfor (i = 0; i < num_reg_temp; i++) {\n\t\tif (reg_temp[i] == 0)\n\t\t\tcontinue;\n\n\t\terr = nct6775_read_value(data, data->REG_TEMP_SOURCE[i], &src);\n\t\tif (err)\n\t\t\treturn err;\n\t\tsrc &= 0x1f;\n\t\tif (!src || (mask & BIT(src)))\n\t\t\tavailable |= BIT(i);\n\n\t\tmask |= BIT(src);\n\t}\n\n\t \n\terr = add_temp_sensors(data, data->REG_TEMP_SEL, &available, &mask);\n\tif (err)\n\t\treturn err;\n\terr = add_temp_sensors(data, data->REG_WEIGHT_TEMP_SEL, &available, &mask);\n\tif (err)\n\t\treturn err;\n\n\tmask = 0;\n\ts = NUM_TEMP_FIXED;\t \n\tfor (i = 0; i < num_reg_temp; i++) {\n\t\tif (reg_temp[i] == 0)\n\t\t\tcontinue;\n\n\t\terr = nct6775_read_value(data, data->REG_TEMP_SOURCE[i], &src);\n\t\tif (err)\n\t\t\treturn err;\n\t\tsrc &= 0x1f;\n\t\tif (!src || (mask & BIT(src)))\n\t\t\tcontinue;\n\n\t\tif (!(data->temp_mask & BIT(src))) {\n\t\t\tdev_info(dev,\n\t\t\t\t \"Invalid temperature source %d at index %d, source register 0x%x, temp register 0x%x\\n\",\n\t\t\t\t src, i, data->REG_TEMP_SOURCE[i], reg_temp[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmask |= BIT(src);\n\n\t\t \n\t\tif (src <= data->temp_fixed_num) {\n\t\t\tdata->have_temp |= BIT(src - 1);\n\t\t\tdata->have_temp_fixed |= BIT(src - 1);\n\t\t\tdata->reg_temp[0][src - 1] = reg_temp[i];\n\t\t\tdata->reg_temp[1][src - 1] = reg_temp_over[i];\n\t\t\tdata->reg_temp[2][src - 1] = reg_temp_hyst[i];\n\t\t\tif (reg_temp_crit_h && reg_temp_crit_h[i])\n\t\t\t\tdata->reg_temp[3][src - 1] = reg_temp_crit_h[i];\n\t\t\telse if (reg_temp_crit[src - 1])\n\t\t\t\tdata->reg_temp[3][src - 1]\n\t\t\t\t  = reg_temp_crit[src - 1];\n\t\t\tif (reg_temp_crit_l && reg_temp_crit_l[i])\n\t\t\t\tdata->reg_temp[4][src - 1] = reg_temp_crit_l[i];\n\t\t\tdata->reg_temp_config[src - 1] = reg_temp_config[i];\n\t\t\tdata->temp_src[src - 1] = src;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (s >= NUM_TEMP)\n\t\t\tcontinue;\n\n\t\t \n\t\tdata->have_temp |= BIT(s);\n\t\tdata->reg_temp[0][s] = reg_temp[i];\n\t\tdata->reg_temp[1][s] = reg_temp_over[i];\n\t\tdata->reg_temp[2][s] = reg_temp_hyst[i];\n\t\tdata->reg_temp_config[s] = reg_temp_config[i];\n\t\tif (reg_temp_crit_h && reg_temp_crit_h[i])\n\t\t\tdata->reg_temp[3][s] = reg_temp_crit_h[i];\n\t\telse if (reg_temp_crit[src - 1])\n\t\t\tdata->reg_temp[3][s] = reg_temp_crit[src - 1];\n\t\tif (reg_temp_crit_l && reg_temp_crit_l[i])\n\t\t\tdata->reg_temp[4][s] = reg_temp_crit_l[i];\n\n\t\tdata->temp_src[s] = src;\n\t\ts++;\n\t}\n\n\t \n\tfor (i = 0; i < num_reg_temp_mon; i++) {\n\t\tif (reg_temp_mon[i] == 0)\n\t\t\tcontinue;\n\n\t\terr = nct6775_read_value(data, data->REG_TEMP_SEL[i], &src);\n\t\tif (err)\n\t\t\treturn err;\n\t\tsrc &= 0x1f;\n\t\tif (!src)\n\t\t\tcontinue;\n\n\t\tif (!(data->temp_mask & BIT(src))) {\n\t\t\tdev_info(dev,\n\t\t\t\t \"Invalid temperature source %d at index %d, source register 0x%x, temp register 0x%x\\n\",\n\t\t\t\t src, i, data->REG_TEMP_SEL[i],\n\t\t\t\t reg_temp_mon[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!(data->virt_temp_mask & BIT(src))) {\n\t\t\tif (mask & BIT(src))\n\t\t\t\tcontinue;\n\t\t\tmask |= BIT(src);\n\t\t}\n\n\t\t \n\t\tif (src <= data->temp_fixed_num) {\n\t\t\tif (data->have_temp & BIT(src - 1))\n\t\t\t\tcontinue;\n\t\t\tdata->have_temp |= BIT(src - 1);\n\t\t\tdata->have_temp_fixed |= BIT(src - 1);\n\t\t\tdata->reg_temp[0][src - 1] = reg_temp_mon[i];\n\t\t\tdata->temp_src[src - 1] = src;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (s >= NUM_TEMP)\n\t\t\tcontinue;\n\n\t\t \n\t\tdata->have_temp |= BIT(s);\n\t\tdata->reg_temp[0][s] = reg_temp_mon[i];\n\t\tdata->temp_src[s] = src;\n\t\ts++;\n\t}\n\n#ifdef USE_ALTERNATE\n\t \n\tfor (i = 0; i < 31; i++) {\n\t\tif (!(data->temp_mask & BIT(i + 1)))\n\t\t\tcontinue;\n\t\tif (!reg_temp_alternate[i])\n\t\t\tcontinue;\n\t\tif (mask & BIT(i + 1))\n\t\t\tcontinue;\n\t\tif (i < data->temp_fixed_num) {\n\t\t\tif (data->have_temp & BIT(i))\n\t\t\t\tcontinue;\n\t\t\tdata->have_temp |= BIT(i);\n\t\t\tdata->have_temp_fixed |= BIT(i);\n\t\t\tdata->reg_temp[0][i] = reg_temp_alternate[i];\n\t\t\tif (i < num_reg_temp) {\n\t\t\t\tdata->reg_temp[1][i] = reg_temp_over[i];\n\t\t\t\tdata->reg_temp[2][i] = reg_temp_hyst[i];\n\t\t\t}\n\t\t\tdata->temp_src[i] = i + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (s >= NUM_TEMP)\t \n\t\t\tbreak;\n\n\t\tdata->have_temp |= BIT(s);\n\t\tdata->reg_temp[0][s] = reg_temp_alternate[i];\n\t\tdata->temp_src[s] = i + 1;\n\t\ts++;\n\t}\n#endif  \n\n\t \n\tfor (i = 0; i < num_reg_tsi_temp; i++) {\n\t\tu16 tmp;\n\n\t\terr = nct6775_read_value(data, data->REG_TSI_TEMP[i], &tmp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (tmp)\n\t\t\tdata->have_tsi_temp |= BIT(i);\n\t}\n\n\t \n\terr = nct6775_init_device(data);\n\tif (err)\n\t\treturn err;\n\n\tif (data->driver_init) {\n\t\terr = data->driver_init(data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = nct6775_init_fan_common(dev, data);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = nct6775_add_template_attr_group(dev, data, &nct6775_pwm_template_group,\n\t\t\t\t\t      data->pwm_num);\n\tif (err)\n\t\treturn err;\n\n\terr = nct6775_add_template_attr_group(dev, data, &nct6775_in_template_group,\n\t\t\t\t\t      fls(data->have_in));\n\tif (err)\n\t\treturn err;\n\n\terr = nct6775_add_template_attr_group(dev, data, &nct6775_fan_template_group,\n\t\t\t\t\t      fls(data->has_fan));\n\tif (err)\n\t\treturn err;\n\n\terr = nct6775_add_template_attr_group(dev, data, &nct6775_temp_template_group,\n\t\t\t\t\t      fls(data->have_temp));\n\tif (err)\n\t\treturn err;\n\n\tif (data->have_tsi_temp) {\n\t\ttsi_temp_tg.templates = nct6775_tsi_temp_template;\n\t\ttsi_temp_tg.is_visible = nct6775_tsi_temp_is_visible;\n\t\ttsi_temp_tg.base = fls(data->have_temp) + 1;\n\t\terr = nct6775_add_template_attr_group(dev, data, &tsi_temp_tg,\n\t\t\t\t\t\t      fls(data->have_tsi_temp));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, data->name,\n\t\t\t\t\t\t\t   data, data->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\nEXPORT_SYMBOL_GPL(nct6775_probe);\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"Core driver for NCT6775F and compatible chips\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}