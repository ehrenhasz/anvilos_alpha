{
  "module_name": "max6642.c",
  "hash_id": "7c077892d3b81707484a30ba99f526e16294b9419ca160ef53662de4f6f7c1fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max6642.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n\nstatic const unsigned short normal_i2c[] = {\n\t0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, I2C_CLIENT_END };\n\n \n\n#define MAX6642_REG_R_MAN_ID\t\t0xFE\n#define MAX6642_REG_R_CONFIG\t\t0x03\n#define MAX6642_REG_W_CONFIG\t\t0x09\n#define MAX6642_REG_R_STATUS\t\t0x02\n#define MAX6642_REG_R_LOCAL_TEMP\t0x00\n#define MAX6642_REG_R_LOCAL_TEMPL\t0x11\n#define MAX6642_REG_R_LOCAL_HIGH\t0x05\n#define MAX6642_REG_W_LOCAL_HIGH\t0x0B\n#define MAX6642_REG_R_REMOTE_TEMP\t0x01\n#define MAX6642_REG_R_REMOTE_TEMPL\t0x10\n#define MAX6642_REG_R_REMOTE_HIGH\t0x07\n#define MAX6642_REG_W_REMOTE_HIGH\t0x0D\n\n \n\nstatic int temp_from_reg10(int val)\n{\n\treturn val * 250;\n}\n\nstatic int temp_from_reg(int val)\n{\n\treturn val * 1000;\n}\n\nstatic int temp_to_reg(int val)\n{\n\treturn val / 1000;\n}\n\n \n\nstruct max6642_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tbool valid;  \n\tunsigned long last_updated;  \n\n\t \n\tu16 temp_input[2];  \n\tu16 temp_high[2];  \n\tu8 alarms;\n};\n\n \n\nstatic void max6642_init_client(struct max6642_data *data,\n\t\t\t\tstruct i2c_client *client)\n{\n\tu8 config;\n\n\t \n\tconfig = i2c_smbus_read_byte_data(client, MAX6642_REG_R_CONFIG);\n\tif (config & 0x40)\n\t\ti2c_smbus_write_byte_data(client, MAX6642_REG_W_CONFIG,\n\t\t\t\t\t  config & 0xBF);  \n\n\tdata->temp_high[0] = i2c_smbus_read_byte_data(client,\n\t\t\t\tMAX6642_REG_R_LOCAL_HIGH);\n\tdata->temp_high[1] = i2c_smbus_read_byte_data(client,\n\t\t\t\tMAX6642_REG_R_REMOTE_HIGH);\n}\n\n \nstatic int max6642_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tu8 reg_config, reg_status, man_id;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tman_id = i2c_smbus_read_byte_data(client, MAX6642_REG_R_MAN_ID);\n\tif (man_id != 0x4D)\n\t\treturn -ENODEV;\n\n\t \n\tif (i2c_smbus_read_byte_data(client, 0x04) != 0x4D\n\t    || i2c_smbus_read_byte_data(client, 0x06) != 0x4D\n\t    || i2c_smbus_read_byte_data(client, 0xff) != 0x4D)\n\t\treturn -ENODEV;\n\n\t \n\treg_config = i2c_smbus_read_byte_data(client, MAX6642_REG_R_CONFIG);\n\tif ((reg_config & 0x0f) != 0x00)\n\t\treturn -ENODEV;\n\n\t \n\tif (i2c_smbus_read_byte_data(client, 0x04) != reg_config\n\t    || i2c_smbus_read_byte_data(client, 0x06) != reg_config\n\t    || i2c_smbus_read_byte_data(client, 0xff) != reg_config)\n\t\treturn -ENODEV;\n\n\treg_status = i2c_smbus_read_byte_data(client, MAX6642_REG_R_STATUS);\n\tif ((reg_status & 0x2b) != 0x00)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"max6642\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic struct max6642_data *max6642_update_device(struct device *dev)\n{\n\tstruct max6642_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu16 val, tmp;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\n\t\tdev_dbg(dev, \"Updating max6642 data.\\n\");\n\t\tval = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tMAX6642_REG_R_LOCAL_TEMPL);\n\t\ttmp = (val >> 6) & 3;\n\t\tval = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tMAX6642_REG_R_LOCAL_TEMP);\n\t\tval = (val << 2) | tmp;\n\t\tdata->temp_input[0] = val;\n\t\tval = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tMAX6642_REG_R_REMOTE_TEMPL);\n\t\ttmp = (val >> 6) & 3;\n\t\tval = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tMAX6642_REG_R_REMOTE_TEMP);\n\t\tval = (val << 2) | tmp;\n\t\tdata->temp_input[1] = val;\n\t\tdata->alarms = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tMAX6642_REG_R_STATUS);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \n\nstatic ssize_t temp_max10_show(struct device *dev,\n\t\t\t       struct device_attribute *dev_attr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(dev_attr);\n\tstruct max6642_data *data = max6642_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       temp_from_reg10(data->temp_input[attr->index]));\n}\n\nstatic ssize_t temp_max_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr2 = to_sensor_dev_attr_2(attr);\n\tstruct max6642_data *data = max6642_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", temp_from_reg(data->temp_high[attr2->nr]));\n}\n\nstatic ssize_t temp_max_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct sensor_device_attribute_2 *attr2 = to_sensor_dev_attr_2(attr);\n\tstruct max6642_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp_high[attr2->nr] = clamp_val(temp_to_reg(val), 0, 255);\n\ti2c_smbus_write_byte_data(data->client, attr2->index,\n\t\t\t\t  data->temp_high[attr2->nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tstruct max6642_data *data = max6642_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (data->alarms >> bitnr) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp_max10, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp_max10, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_max, temp_max, 0,\n\t\t\t       MAX6642_REG_W_LOCAL_HIGH);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_max, temp_max, 1,\n\t\t\t       MAX6642_REG_W_REMOTE_HIGH);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_fault, alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, alarm, 6);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_max_alarm, alarm, 4);\n\nstatic struct attribute *max6642_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(max6642);\n\nstatic int max6642_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct max6642_data *data;\n\tstruct device *hwmon_dev;\n\n\tdata = devm_kzalloc(dev, sizeof(struct max6642_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tmax6642_init_client(data, client);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(&client->dev,\n\t\t\t\t\t\t\t   client->name, data,\n\t\t\t\t\t\t\t   max6642_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\n \n\nstatic const struct i2c_device_id max6642_id[] = {\n\t{ \"max6642\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max6642_id);\n\nstatic struct i2c_driver max6642_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"max6642\",\n\t},\n\t.probe\t\t= max6642_probe,\n\t.id_table\t= max6642_id,\n\t.detect\t\t= max6642_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(max6642_driver);\n\nMODULE_AUTHOR(\"Per Dalen <per.dalen@appeartv.com>\");\nMODULE_DESCRIPTION(\"MAX6642 sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}