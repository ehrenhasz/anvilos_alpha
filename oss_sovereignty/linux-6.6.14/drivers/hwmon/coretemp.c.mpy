{
  "module_name": "coretemp.c",
  "hash_id": "6826a0e246d3d02d4ead4776dfc08eafe417414632643930d0def2780df12837",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/coretemp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/hwmon.h>\n#include <linux/sysfs.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/platform_device.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <asm/cpu_device_id.h>\n#include <linux/sched/isolation.h>\n\n#define DRVNAME\t\"coretemp\"\n\n \nstatic int force_tjmax;\nmodule_param_named(tjmax, force_tjmax, int, 0444);\nMODULE_PARM_DESC(tjmax, \"TjMax value in degrees Celsius\");\n\n#define PKG_SYSFS_ATTR_NO\t1\t \n#define BASE_SYSFS_ATTR_NO\t2\t \n#define NUM_REAL_CORES\t\t128\t \n#define CORETEMP_NAME_LENGTH\t28\t \n#define MAX_CORE_ATTRS\t\t4\t \n#define TOTAL_ATTRS\t\t(MAX_CORE_ATTRS + 1)\n#define MAX_CORE_DATA\t\t(NUM_REAL_CORES + BASE_SYSFS_ATTR_NO)\n\n#ifdef CONFIG_SMP\n#define for_each_sibling(i, cpu) \\\n\tfor_each_cpu(i, topology_sibling_cpumask(cpu))\n#else\n#define for_each_sibling(i, cpu)\tfor (i = 0; false; )\n#endif\n\n \nstruct temp_data {\n\tint temp;\n\tint tjmax;\n\tunsigned long last_updated;\n\tunsigned int cpu;\n\tu32 cpu_core_id;\n\tu32 status_reg;\n\tint attr_size;\n\tbool is_pkg_data;\n\tstruct sensor_device_attribute sd_attrs[TOTAL_ATTRS];\n\tchar attr_name[TOTAL_ATTRS][CORETEMP_NAME_LENGTH];\n\tstruct attribute *attrs[TOTAL_ATTRS + 1];\n\tstruct attribute_group attr_group;\n\tstruct mutex update_lock;\n};\n\n \nstruct platform_data {\n\tstruct device\t\t*hwmon_dev;\n\tu16\t\t\tpkg_id;\n\tu16\t\t\tcpu_map[NUM_REAL_CORES];\n\tstruct ida\t\tida;\n\tstruct cpumask\t\tcpumask;\n\tstruct temp_data\t*core_data[MAX_CORE_DATA];\n\tstruct device_attribute name_attr;\n};\n\nstruct tjmax_pci {\n\tunsigned int device;\n\tint tjmax;\n};\n\nstatic const struct tjmax_pci tjmax_pci_table[] = {\n\t{ 0x0708, 110000 },\t \n\t{ 0x0c72, 102000 },\t \n\t{ 0x0c73, 95000 },\t \n\t{ 0x0c75, 95000 },\t \n};\n\nstruct tjmax {\n\tchar const *id;\n\tint tjmax;\n};\n\nstatic const struct tjmax tjmax_table[] = {\n\t{ \"CPU  230\", 100000 },\t\t \n\t{ \"CPU  330\", 125000 },\t\t \n};\n\nstruct tjmax_model {\n\tu8 model;\n\tu8 mask;\n\tint tjmax;\n};\n\n#define ANY 0xff\n\nstatic const struct tjmax_model tjmax_model_table[] = {\n\t{ 0x1c, 10, 100000 },\t \n\t{ 0x1c, ANY, 90000 },\t \n\t{ 0x26, ANY, 90000 },\t \n\t{ 0x27, ANY, 90000 },\t \n\t{ 0x35, ANY, 90000 },\t \n\t{ 0x36, ANY, 100000 },\t \n};\n\nstatic int adjust_tjmax(struct cpuinfo_x86 *c, u32 id, struct device *dev)\n{\n\t \n\n\tint tjmax = 100000;\n\tint tjmax_ee = 85000;\n\tint usemsr_ee = 1;\n\tint err;\n\tu32 eax, edx;\n\tint i;\n\tu16 devfn = PCI_DEVFN(0, 0);\n\tstruct pci_dev *host_bridge = pci_get_domain_bus_and_slot(0, 0, devfn);\n\n\t \n\tif (host_bridge && host_bridge->vendor == PCI_VENDOR_ID_INTEL) {\n\t\tfor (i = 0; i < ARRAY_SIZE(tjmax_pci_table); i++) {\n\t\t\tif (host_bridge->device == tjmax_pci_table[i].device) {\n\t\t\t\tpci_dev_put(host_bridge);\n\t\t\t\treturn tjmax_pci_table[i].tjmax;\n\t\t\t}\n\t\t}\n\t}\n\tpci_dev_put(host_bridge);\n\n\tfor (i = 0; i < ARRAY_SIZE(tjmax_table); i++) {\n\t\tif (strstr(c->x86_model_id, tjmax_table[i].id))\n\t\t\treturn tjmax_table[i].tjmax;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tjmax_model_table); i++) {\n\t\tconst struct tjmax_model *tm = &tjmax_model_table[i];\n\t\tif (c->x86_model == tm->model &&\n\t\t    (tm->mask == ANY || c->x86_stepping == tm->mask))\n\t\t\treturn tm->tjmax;\n\t}\n\n\t \n\n\tif (c->x86_model == 0xf && c->x86_stepping < 4)\n\t\tusemsr_ee = 0;\n\n\tif (c->x86_model > 0xe && usemsr_ee) {\n\t\tu8 platform_id;\n\n\t\t \n\t\terr = rdmsr_safe_on_cpu(id, 0x17, &eax, &edx);\n\t\tif (err) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Unable to access MSR 0x17, assuming desktop\"\n\t\t\t\t \" CPU\\n\");\n\t\t\tusemsr_ee = 0;\n\t\t} else if (c->x86_model < 0x17 && !(eax & 0x10000000)) {\n\t\t\t \n\t\t\tusemsr_ee = 0;\n\t\t} else {\n\t\t\t \n\t\t\tplatform_id = (edx >> 18) & 0x7;\n\n\t\t\t \n\t\t\tif (c->x86_model == 0x17 &&\n\t\t\t    (platform_id == 5 || platform_id == 7)) {\n\t\t\t\t \n\t\t\t\ttjmax_ee = 90000;\n\t\t\t\ttjmax = 105000;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (usemsr_ee) {\n\t\terr = rdmsr_safe_on_cpu(id, 0xee, &eax, &edx);\n\t\tif (err) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Unable to access MSR 0xEE, for Tjmax, left\"\n\t\t\t\t \" at default\\n\");\n\t\t} else if (eax & 0x40000000) {\n\t\t\ttjmax = tjmax_ee;\n\t\t}\n\t} else if (tjmax == 100000) {\n\t\t \n\t\tdev_warn(dev, \"Using relative temperature scale!\\n\");\n\t}\n\n\treturn tjmax;\n}\n\nstatic bool cpu_has_tjmax(struct cpuinfo_x86 *c)\n{\n\tu8 model = c->x86_model;\n\n\treturn model > 0xe &&\n\t       model != 0x1c &&\n\t       model != 0x26 &&\n\t       model != 0x27 &&\n\t       model != 0x35 &&\n\t       model != 0x36;\n}\n\nstatic int get_tjmax(struct temp_data *tdata, struct device *dev)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(tdata->cpu);\n\tint err;\n\tu32 eax, edx;\n\tu32 val;\n\n\t \n\tif (tdata->tjmax)\n\t\treturn tdata->tjmax;\n\n\t \n\terr = rdmsr_safe_on_cpu(tdata->cpu, MSR_IA32_TEMPERATURE_TARGET, &eax, &edx);\n\tif (err) {\n\t\tif (cpu_has_tjmax(c))\n\t\t\tdev_warn(dev, \"Unable to read TjMax from CPU %u\\n\", tdata->cpu);\n\t} else {\n\t\tval = (eax >> 16) & 0xff;\n\t\tif (val)\n\t\t\treturn val * 1000;\n\t}\n\n\tif (force_tjmax) {\n\t\tdev_notice(dev, \"TjMax forced to %d degrees C by user\\n\",\n\t\t\t   force_tjmax);\n\t\ttdata->tjmax = force_tjmax * 1000;\n\t} else {\n\t\t \n\t\ttdata->tjmax = adjust_tjmax(c, tdata->cpu, dev);\n\t}\n\treturn tdata->tjmax;\n}\n\nstatic int get_ttarget(struct temp_data *tdata, struct device *dev)\n{\n\tu32 eax, edx;\n\tint tjmax, ttarget_offset, ret;\n\n\t \n\tif (tdata->tjmax)\n\t\treturn -ENODEV;\n\n\tret = rdmsr_safe_on_cpu(tdata->cpu, MSR_IA32_TEMPERATURE_TARGET, &eax, &edx);\n\tif (ret)\n\t\treturn ret;\n\n\ttjmax = (eax >> 16) & 0xff;\n\n\t \n\tttarget_offset = (eax >> 8) & 0xff;\n\n\treturn (tjmax - ttarget_offset) * 1000;\n}\n\n \nstatic int max_zones __read_mostly;\n \nstatic struct platform_device **zone_devices;\n\nstatic ssize_t show_label(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct platform_data *pdata = dev_get_drvdata(dev);\n\tstruct temp_data *tdata = pdata->core_data[attr->index];\n\n\tif (tdata->is_pkg_data)\n\t\treturn sprintf(buf, \"Package id %u\\n\", pdata->pkg_id);\n\n\treturn sprintf(buf, \"Core %u\\n\", tdata->cpu_core_id);\n}\n\nstatic ssize_t show_crit_alarm(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr, char *buf)\n{\n\tu32 eax, edx;\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct platform_data *pdata = dev_get_drvdata(dev);\n\tstruct temp_data *tdata = pdata->core_data[attr->index];\n\n\tmutex_lock(&tdata->update_lock);\n\trdmsr_on_cpu(tdata->cpu, tdata->status_reg, &eax, &edx);\n\tmutex_unlock(&tdata->update_lock);\n\n\treturn sprintf(buf, \"%d\\n\", (eax >> 5) & 1);\n}\n\nstatic ssize_t show_tjmax(struct device *dev,\n\t\t\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct platform_data *pdata = dev_get_drvdata(dev);\n\tstruct temp_data *tdata = pdata->core_data[attr->index];\n\tint tjmax;\n\n\tmutex_lock(&tdata->update_lock);\n\ttjmax = get_tjmax(tdata, dev);\n\tmutex_unlock(&tdata->update_lock);\n\n\treturn sprintf(buf, \"%d\\n\", tjmax);\n}\n\nstatic ssize_t show_ttarget(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct platform_data *pdata = dev_get_drvdata(dev);\n\tstruct temp_data *tdata = pdata->core_data[attr->index];\n\tint ttarget;\n\n\tmutex_lock(&tdata->update_lock);\n\tttarget = get_ttarget(tdata, dev);\n\tmutex_unlock(&tdata->update_lock);\n\n\tif (ttarget < 0)\n\t\treturn ttarget;\n\treturn sprintf(buf, \"%d\\n\", ttarget);\n}\n\nstatic ssize_t show_temp(struct device *dev,\n\t\t\tstruct device_attribute *devattr, char *buf)\n{\n\tu32 eax, edx;\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct platform_data *pdata = dev_get_drvdata(dev);\n\tstruct temp_data *tdata = pdata->core_data[attr->index];\n\tint tjmax;\n\n\tmutex_lock(&tdata->update_lock);\n\n\ttjmax = get_tjmax(tdata, dev);\n\t \n\tif (time_after(jiffies, tdata->last_updated + HZ)) {\n\t\trdmsr_on_cpu(tdata->cpu, tdata->status_reg, &eax, &edx);\n\t\t \n\t\ttdata->temp = tjmax - ((eax >> 16) & 0x7f) * 1000;\n\t\ttdata->last_updated = jiffies;\n\t}\n\n\tmutex_unlock(&tdata->update_lock);\n\treturn sprintf(buf, \"%d\\n\", tdata->temp);\n}\n\nstatic int create_core_attrs(struct temp_data *tdata, struct device *dev,\n\t\t\t     int attr_no)\n{\n\tint i;\n\tstatic ssize_t (*const rd_ptr[TOTAL_ATTRS]) (struct device *dev,\n\t\t\tstruct device_attribute *devattr, char *buf) = {\n\t\t\tshow_label, show_crit_alarm, show_temp, show_tjmax,\n\t\t\tshow_ttarget };\n\tstatic const char *const suffixes[TOTAL_ATTRS] = {\n\t\t\"label\", \"crit_alarm\", \"input\", \"crit\", \"max\"\n\t};\n\n\tfor (i = 0; i < tdata->attr_size; i++) {\n\t\tsnprintf(tdata->attr_name[i], CORETEMP_NAME_LENGTH,\n\t\t\t \"temp%d_%s\", attr_no, suffixes[i]);\n\t\tsysfs_attr_init(&tdata->sd_attrs[i].dev_attr.attr);\n\t\ttdata->sd_attrs[i].dev_attr.attr.name = tdata->attr_name[i];\n\t\ttdata->sd_attrs[i].dev_attr.attr.mode = 0444;\n\t\ttdata->sd_attrs[i].dev_attr.show = rd_ptr[i];\n\t\ttdata->sd_attrs[i].index = attr_no;\n\t\ttdata->attrs[i] = &tdata->sd_attrs[i].dev_attr.attr;\n\t}\n\ttdata->attr_group.attrs = tdata->attrs;\n\treturn sysfs_create_group(&dev->kobj, &tdata->attr_group);\n}\n\n\nstatic int chk_ucode_version(unsigned int cpu)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\n\t \n\tif (c->x86_model == 0xe && c->x86_stepping < 0xc && c->microcode < 0x39) {\n\t\tpr_err(\"Errata AE18 not fixed, update BIOS or microcode of the CPU!\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic struct platform_device *coretemp_get_pdev(unsigned int cpu)\n{\n\tint id = topology_logical_die_id(cpu);\n\n\tif (id >= 0 && id < max_zones)\n\t\treturn zone_devices[id];\n\treturn NULL;\n}\n\nstatic struct temp_data *init_temp_data(unsigned int cpu, int pkg_flag)\n{\n\tstruct temp_data *tdata;\n\n\ttdata = kzalloc(sizeof(struct temp_data), GFP_KERNEL);\n\tif (!tdata)\n\t\treturn NULL;\n\n\ttdata->status_reg = pkg_flag ? MSR_IA32_PACKAGE_THERM_STATUS :\n\t\t\t\t\t\t\tMSR_IA32_THERM_STATUS;\n\ttdata->is_pkg_data = pkg_flag;\n\ttdata->cpu = cpu;\n\ttdata->cpu_core_id = topology_core_id(cpu);\n\ttdata->attr_size = MAX_CORE_ATTRS;\n\tmutex_init(&tdata->update_lock);\n\treturn tdata;\n}\n\nstatic int create_core_data(struct platform_device *pdev, unsigned int cpu,\n\t\t\t    int pkg_flag)\n{\n\tstruct temp_data *tdata;\n\tstruct platform_data *pdata = platform_get_drvdata(pdev);\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\tu32 eax, edx;\n\tint err, index, attr_no;\n\n\tif (!housekeeping_cpu(cpu, HK_TYPE_MISC))\n\t\treturn 0;\n\n\t \n\tif (pkg_flag) {\n\t\tattr_no = PKG_SYSFS_ATTR_NO;\n\t} else {\n\t\tindex = ida_alloc(&pdata->ida, GFP_KERNEL);\n\t\tif (index < 0)\n\t\t\treturn index;\n\t\tpdata->cpu_map[index] = topology_core_id(cpu);\n\t\tattr_no = index + BASE_SYSFS_ATTR_NO;\n\t}\n\n\tif (attr_no > MAX_CORE_DATA - 1) {\n\t\terr = -ERANGE;\n\t\tgoto ida_free;\n\t}\n\n\ttdata = init_temp_data(cpu, pkg_flag);\n\tif (!tdata) {\n\t\terr = -ENOMEM;\n\t\tgoto ida_free;\n\t}\n\n\t \n\terr = rdmsr_safe_on_cpu(cpu, tdata->status_reg, &eax, &edx);\n\tif (err)\n\t\tgoto exit_free;\n\n\t \n\tget_tjmax(tdata, &pdev->dev);\n\n\t \n\tif (c->x86_model > 0xe && c->x86_model != 0x1c)\n\t\tif (get_ttarget(tdata, &pdev->dev) >= 0)\n\t\t\ttdata->attr_size++;\n\n\tpdata->core_data[attr_no] = tdata;\n\n\t \n\terr = create_core_attrs(tdata, pdata->hwmon_dev, attr_no);\n\tif (err)\n\t\tgoto exit_free;\n\n\treturn 0;\nexit_free:\n\tpdata->core_data[attr_no] = NULL;\n\tkfree(tdata);\nida_free:\n\tif (!pkg_flag)\n\t\tida_free(&pdata->ida, index);\n\treturn err;\n}\n\nstatic void\ncoretemp_add_core(struct platform_device *pdev, unsigned int cpu, int pkg_flag)\n{\n\tif (create_core_data(pdev, cpu, pkg_flag))\n\t\tdev_err(&pdev->dev, \"Adding Core %u failed\\n\", cpu);\n}\n\nstatic void coretemp_remove_core(struct platform_data *pdata, int indx)\n{\n\tstruct temp_data *tdata = pdata->core_data[indx];\n\n\t \n\tif (!tdata)\n\t\treturn;\n\n\t \n\tsysfs_remove_group(&pdata->hwmon_dev->kobj, &tdata->attr_group);\n\n\tkfree(pdata->core_data[indx]);\n\tpdata->core_data[indx] = NULL;\n\n\tif (indx >= BASE_SYSFS_ATTR_NO)\n\t\tida_free(&pdata->ida, indx - BASE_SYSFS_ATTR_NO);\n}\n\nstatic int coretemp_device_add(int zoneid)\n{\n\tstruct platform_device *pdev;\n\tstruct platform_data *pdata;\n\tint err;\n\n\t \n\tpdata = kzalloc(sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->pkg_id = zoneid;\n\tida_init(&pdata->ida);\n\n\tpdev = platform_device_alloc(DRVNAME, zoneid);\n\tif (!pdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_pdata;\n\t}\n\n\terr = platform_device_add(pdev);\n\tif (err)\n\t\tgoto err_put_dev;\n\n\tplatform_set_drvdata(pdev, pdata);\n\tzone_devices[zoneid] = pdev;\n\treturn 0;\n\nerr_put_dev:\n\tplatform_device_put(pdev);\nerr_free_pdata:\n\tkfree(pdata);\n\treturn err;\n}\n\nstatic void coretemp_device_remove(int zoneid)\n{\n\tstruct platform_device *pdev = zone_devices[zoneid];\n\tstruct platform_data *pdata = platform_get_drvdata(pdev);\n\n\tida_destroy(&pdata->ida);\n\tkfree(pdata);\n\tplatform_device_unregister(pdev);\n}\n\nstatic int coretemp_cpu_online(unsigned int cpu)\n{\n\tstruct platform_device *pdev = coretemp_get_pdev(cpu);\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\tstruct platform_data *pdata;\n\n\t \n\tif (cpuhp_tasks_frozen)\n\t\treturn 0;\n\n\t \n\tif (!cpu_has(c, X86_FEATURE_DTHERM))\n\t\treturn -ENODEV;\n\n\tpdata = platform_get_drvdata(pdev);\n\tif (!pdata->hwmon_dev) {\n\t\tstruct device *hwmon;\n\n\t\t \n\t\tif (chk_ucode_version(cpu))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\thwmon = hwmon_device_register_with_groups(&pdev->dev, DRVNAME,\n\t\t\t\t\t\t\t  pdata, NULL);\n\t\tif (IS_ERR(hwmon))\n\t\t\treturn PTR_ERR(hwmon);\n\t\tpdata->hwmon_dev = hwmon;\n\n\t\t \n\t\tif (cpu_has(c, X86_FEATURE_PTS))\n\t\t\tcoretemp_add_core(pdev, cpu, 1);\n\t}\n\n\t \n\tif (!cpumask_intersects(&pdata->cpumask, topology_sibling_cpumask(cpu)))\n\t\tcoretemp_add_core(pdev, cpu, 0);\n\n\tcpumask_set_cpu(cpu, &pdata->cpumask);\n\treturn 0;\n}\n\nstatic int coretemp_cpu_offline(unsigned int cpu)\n{\n\tstruct platform_device *pdev = coretemp_get_pdev(cpu);\n\tstruct platform_data *pd;\n\tstruct temp_data *tdata;\n\tint i, indx = -1, target;\n\n\t \n\tif (cpuhp_tasks_frozen)\n\t\treturn 0;\n\n\t \n\tpd = platform_get_drvdata(pdev);\n\tif (!pd->hwmon_dev)\n\t\treturn 0;\n\n\tfor (i = 0; i < NUM_REAL_CORES; i++) {\n\t\tif (pd->cpu_map[i] == topology_core_id(cpu)) {\n\t\t\tindx = i + BASE_SYSFS_ATTR_NO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (indx < 0)\n\t\treturn 0;\n\n\ttdata = pd->core_data[indx];\n\n\tcpumask_clear_cpu(cpu, &pd->cpumask);\n\n\t \n\ttarget = cpumask_any_and(&pd->cpumask, topology_sibling_cpumask(cpu));\n\tif (target >= nr_cpu_ids) {\n\t\tcoretemp_remove_core(pd, indx);\n\t} else if (tdata && tdata->cpu == cpu) {\n\t\tmutex_lock(&tdata->update_lock);\n\t\ttdata->cpu = target;\n\t\tmutex_unlock(&tdata->update_lock);\n\t}\n\n\t \n\ttdata = pd->core_data[PKG_SYSFS_ATTR_NO];\n\tif (cpumask_empty(&pd->cpumask)) {\n\t\tif (tdata)\n\t\t\tcoretemp_remove_core(pd, PKG_SYSFS_ATTR_NO);\n\t\thwmon_device_unregister(pd->hwmon_dev);\n\t\tpd->hwmon_dev = NULL;\n\t\treturn 0;\n\t}\n\n\t \n\tif (tdata && tdata->cpu == cpu) {\n\t\ttarget = cpumask_first(&pd->cpumask);\n\t\tmutex_lock(&tdata->update_lock);\n\t\ttdata->cpu = target;\n\t\tmutex_unlock(&tdata->update_lock);\n\t}\n\treturn 0;\n}\nstatic const struct x86_cpu_id __initconst coretemp_ids[] = {\n\tX86_MATCH_VENDOR_FEATURE(INTEL, X86_FEATURE_DTHERM, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, coretemp_ids);\n\nstatic enum cpuhp_state coretemp_hp_online;\n\nstatic int __init coretemp_init(void)\n{\n\tint i, err;\n\n\t \n\tif (!x86_match_cpu(coretemp_ids))\n\t\treturn -ENODEV;\n\n\tmax_zones = topology_max_packages() * topology_max_die_per_package();\n\tzone_devices = kcalloc(max_zones, sizeof(struct platform_device *),\n\t\t\t      GFP_KERNEL);\n\tif (!zone_devices)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < max_zones; i++) {\n\t\terr = coretemp_device_add(i);\n\t\tif (err)\n\t\t\tgoto outzone;\n\t}\n\n\terr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"hwmon/coretemp:online\",\n\t\t\t\tcoretemp_cpu_online, coretemp_cpu_offline);\n\tif (err < 0)\n\t\tgoto outzone;\n\tcoretemp_hp_online = err;\n\treturn 0;\n\noutzone:\n\twhile (i--)\n\t\tcoretemp_device_remove(i);\n\tkfree(zone_devices);\n\treturn err;\n}\nmodule_init(coretemp_init)\n\nstatic void __exit coretemp_exit(void)\n{\n\tint i;\n\n\tcpuhp_remove_state(coretemp_hp_online);\n\tfor (i = 0; i < max_zones; i++)\n\t\tcoretemp_device_remove(i);\n\tkfree(zone_devices);\n}\nmodule_exit(coretemp_exit)\n\nMODULE_AUTHOR(\"Rudolf Marek <r.marek@assembler.cz>\");\nMODULE_DESCRIPTION(\"Intel Core temperature monitor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}