{
  "module_name": "ina238.c",
  "hash_id": "37cf45c391f8c20aa133c9037451f970428c8bd0ec95da2cb12e94813d33fce4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ina238.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#include <linux/platform_data/ina2xx.h>\n\n \n#define INA238_CONFIG\t\t\t0x0\n#define INA238_ADC_CONFIG\t\t0x1\n#define INA238_SHUNT_CALIBRATION\t0x2\n#define INA238_SHUNT_VOLTAGE\t\t0x4\n#define INA238_BUS_VOLTAGE\t\t0x5\n#define INA238_DIE_TEMP\t\t\t0x6\n#define INA238_CURRENT\t\t\t0x7\n#define INA238_POWER\t\t\t0x8\n#define INA238_DIAG_ALERT\t\t0xb\n#define INA238_SHUNT_OVER_VOLTAGE\t0xc\n#define INA238_SHUNT_UNDER_VOLTAGE\t0xd\n#define INA238_BUS_OVER_VOLTAGE\t\t0xe\n#define INA238_BUS_UNDER_VOLTAGE\t0xf\n#define INA238_TEMP_LIMIT\t\t0x10\n#define INA238_POWER_LIMIT\t\t0x11\n#define INA238_DEVICE_ID\t\t0x3f\n\n#define INA238_CONFIG_ADCRANGE\t\tBIT(4)\n\n#define INA238_DIAG_ALERT_TMPOL\t\tBIT(7)\n#define INA238_DIAG_ALERT_SHNTOL\tBIT(6)\n#define INA238_DIAG_ALERT_SHNTUL\tBIT(5)\n#define INA238_DIAG_ALERT_BUSOL\t\tBIT(4)\n#define INA238_DIAG_ALERT_BUSUL\t\tBIT(3)\n#define INA238_DIAG_ALERT_POL\t\tBIT(2)\n\n#define INA238_REGISTERS\t\t0x11\n\n#define INA238_RSHUNT_DEFAULT\t\t10000  \n\n \n#define INA238_CONFIG_DEFAULT\t\t0\n \n#define INA238_ADC_CONFIG_DEFAULT\t0xfb6a\n \n#define INA238_DIAG_ALERT_DEFAULT\t0x2000\n \n#define INA238_CALIBRATION_VALUE\t16384\n#define INA238_FIXED_SHUNT\t\t20000\n\n#define INA238_SHUNT_VOLTAGE_LSB\t5  \n#define INA238_BUS_VOLTAGE_LSB\t\t3125  \n#define INA238_DIE_TEMP_LSB\t\t125  \n\nstatic struct regmap_config ina238_regmap_config = {\n\t.max_register = INA238_REGISTERS,\n\t.reg_bits = 8,\n\t.val_bits = 16,\n};\n\nstruct ina238_data {\n\tstruct i2c_client *client;\n\tstruct mutex config_lock;\n\tstruct regmap *regmap;\n\tu32 rshunt;\n\tint gain;\n};\n\nstatic int ina238_read_reg24(const struct i2c_client *client, u8 reg, u32 *val)\n{\n\tu8 data[3];\n\tint err;\n\n\t \n\terr = i2c_smbus_read_i2c_block_data(client, reg, 3, data);\n\tif (err < 0)\n\t\treturn err;\n\tif (err != 3)\n\t\treturn -EIO;\n\t*val = (data[0] << 16) | (data[1] << 8) | data[2];\n\n\treturn 0;\n}\n\nstatic int ina238_read_in(struct device *dev, u32 attr, int channel,\n\t\t\t  long *val)\n{\n\tstruct ina238_data *data = dev_get_drvdata(dev);\n\tint reg, mask;\n\tint regval;\n\tint err;\n\n\tswitch (channel) {\n\tcase 0:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\treg = INA238_SHUNT_VOLTAGE;\n\t\t\tbreak;\n\t\tcase hwmon_in_max:\n\t\t\treg = INA238_SHUNT_OVER_VOLTAGE;\n\t\t\tbreak;\n\t\tcase hwmon_in_min:\n\t\t\treg = INA238_SHUNT_UNDER_VOLTAGE;\n\t\t\tbreak;\n\t\tcase hwmon_in_max_alarm:\n\t\t\treg = INA238_DIAG_ALERT;\n\t\t\tmask = INA238_DIAG_ALERT_SHNTOL;\n\t\t\tbreak;\n\t\tcase hwmon_in_min_alarm:\n\t\t\treg = INA238_DIAG_ALERT;\n\t\t\tmask = INA238_DIAG_ALERT_SHNTUL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\treg = INA238_BUS_VOLTAGE;\n\t\t\tbreak;\n\t\tcase hwmon_in_max:\n\t\t\treg = INA238_BUS_OVER_VOLTAGE;\n\t\t\tbreak;\n\t\tcase hwmon_in_min:\n\t\t\treg = INA238_BUS_UNDER_VOLTAGE;\n\t\t\tbreak;\n\t\tcase hwmon_in_max_alarm:\n\t\t\treg = INA238_DIAG_ALERT;\n\t\t\tmask = INA238_DIAG_ALERT_BUSOL;\n\t\t\tbreak;\n\t\tcase hwmon_in_min_alarm:\n\t\t\treg = INA238_DIAG_ALERT;\n\t\t\tmask = INA238_DIAG_ALERT_BUSUL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = regmap_read(data->regmap, reg, &regval);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\tcase hwmon_in_max:\n\tcase hwmon_in_min:\n\t\t \n\t\tregval = (s16)regval;\n\t\tif (channel == 0)\n\t\t\t \n\t\t\t*val = (regval * INA238_SHUNT_VOLTAGE_LSB) /\n\t\t\t       (1000 * (4 - data->gain + 1));\n\t\telse\n\t\t\t*val = (regval * INA238_BUS_VOLTAGE_LSB) / 1000;\n\t\tbreak;\n\tcase hwmon_in_max_alarm:\n\tcase hwmon_in_min_alarm:\n\t\t*val = !!(regval & mask);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ina238_write_in(struct device *dev, u32 attr, int channel,\n\t\t\t   long val)\n{\n\tstruct ina238_data *data = dev_get_drvdata(dev);\n\tint regval;\n\n\tif (attr != hwmon_in_max && attr != hwmon_in_min)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tswitch (channel) {\n\tcase 0:\n\t\t \n\t\tregval = clamp_val(val, -163, 163);\n\t\tregval = (regval * 1000 * (4 - data->gain + 1)) /\n\t\t\t INA238_SHUNT_VOLTAGE_LSB;\n\t\tregval = clamp_val(regval, S16_MIN, S16_MAX);\n\n\t\tswitch (attr) {\n\t\tcase hwmon_in_max:\n\t\t\treturn regmap_write(data->regmap,\n\t\t\t\t\t    INA238_SHUNT_OVER_VOLTAGE, regval);\n\t\tcase hwmon_in_min:\n\t\t\treturn regmap_write(data->regmap,\n\t\t\t\t\t    INA238_SHUNT_UNDER_VOLTAGE, regval);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tcase 1:\n\t\t \n\t\tregval = clamp_val(val, 0, 102396);\n\t\tregval = (regval * 1000) / INA238_BUS_VOLTAGE_LSB;\n\t\tregval = clamp_val(regval, 0, S16_MAX);\n\n\t\tswitch (attr) {\n\t\tcase hwmon_in_max:\n\t\t\treturn regmap_write(data->regmap,\n\t\t\t\t\t    INA238_BUS_OVER_VOLTAGE, regval);\n\t\tcase hwmon_in_min:\n\t\t\treturn regmap_write(data->regmap,\n\t\t\t\t\t    INA238_BUS_UNDER_VOLTAGE, regval);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ina238_read_current(struct device *dev, u32 attr, long *val)\n{\n\tstruct ina238_data *data = dev_get_drvdata(dev);\n\tint regval;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_curr_input:\n\t\terr = regmap_read(data->regmap, INA238_CURRENT, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\t*val = div_s64((s16)regval * INA238_FIXED_SHUNT * data->gain,\n\t\t\t       data->rshunt * 4);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ina238_read_power(struct device *dev, u32 attr, long *val)\n{\n\tstruct ina238_data *data = dev_get_drvdata(dev);\n\tlong long power;\n\tint regval;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_power_input:\n\t\terr = ina238_read_reg24(data->client, INA238_POWER, &regval);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tpower = div_u64(regval * 1000ULL * INA238_FIXED_SHUNT *\n\t\t\t\tdata->gain, 20 * data->rshunt);\n\t\t \n\t\t*val = clamp_val(power, 0, LONG_MAX);\n\t\tbreak;\n\tcase hwmon_power_max:\n\t\terr = regmap_read(data->regmap, INA238_POWER_LIMIT, &regval);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tpower = div_u64((regval << 8) * 1000ULL * INA238_FIXED_SHUNT *\n\t\t\t       data->gain, 20 * data->rshunt);\n\t\t \n\t\t*val = clamp_val(power, 0, LONG_MAX);\n\t\tbreak;\n\tcase hwmon_power_max_alarm:\n\t\terr = regmap_read(data->regmap, INA238_DIAG_ALERT, &regval);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*val = !!(regval & INA238_DIAG_ALERT_POL);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ina238_write_power(struct device *dev, u32 attr, long val)\n{\n\tstruct ina238_data *data = dev_get_drvdata(dev);\n\tlong regval;\n\n\tif (attr != hwmon_power_max)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tregval = clamp_val(val, 0, LONG_MAX);\n\tregval = div_u64(val * 20ULL * data->rshunt,\n\t\t\t 1000ULL * INA238_FIXED_SHUNT * data->gain);\n\tregval = clamp_val(regval >> 8, 0, U16_MAX);\n\n\treturn regmap_write(data->regmap, INA238_POWER_LIMIT, regval);\n}\n\nstatic int ina238_read_temp(struct device *dev, u32 attr, long *val)\n{\n\tstruct ina238_data *data = dev_get_drvdata(dev);\n\tint regval;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\terr = regmap_read(data->regmap, INA238_DIE_TEMP, &regval);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\t*val = ((s16)regval >> 4) * INA238_DIE_TEMP_LSB;\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\terr = regmap_read(data->regmap, INA238_TEMP_LIMIT, &regval);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\t*val = ((s16)regval >> 4) * INA238_DIE_TEMP_LSB;\n\t\tbreak;\n\tcase hwmon_temp_max_alarm:\n\t\terr = regmap_read(data->regmap, INA238_DIAG_ALERT, &regval);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*val = !!(regval & INA238_DIAG_ALERT_TMPOL);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ina238_write_temp(struct device *dev, u32 attr, long val)\n{\n\tstruct ina238_data *data = dev_get_drvdata(dev);\n\tint regval;\n\n\tif (attr != hwmon_temp_max)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tregval = (val / INA238_DIE_TEMP_LSB) << 4;\n\tregval = clamp_val(regval, S16_MIN, S16_MAX) & 0xfff0;\n\n\treturn regmap_write(data->regmap, INA238_TEMP_LIMIT, regval);\n}\n\nstatic int ina238_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\treturn ina238_read_in(dev, attr, channel, val);\n\tcase hwmon_curr:\n\t\treturn ina238_read_current(dev, attr, val);\n\tcase hwmon_power:\n\t\treturn ina238_read_power(dev, attr, val);\n\tcase hwmon_temp:\n\t\treturn ina238_read_temp(dev, attr, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int ina238_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long val)\n{\n\tstruct ina238_data *data = dev_get_drvdata(dev);\n\tint err;\n\n\tmutex_lock(&data->config_lock);\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\terr = ina238_write_in(dev, attr, channel, val);\n\t\tbreak;\n\tcase hwmon_power:\n\t\terr = ina238_write_power(dev, attr, val);\n\t\tbreak;\n\tcase hwmon_temp:\n\t\terr = ina238_write_temp(dev, attr, val);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->config_lock);\n\treturn err;\n}\n\nstatic umode_t ina238_is_visible(const void *drvdata,\n\t\t\t\t enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\tcase hwmon_in_max_alarm:\n\t\tcase hwmon_in_min_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_in_max:\n\t\tcase hwmon_in_min:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_input:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_power:\n\t\tswitch (attr) {\n\t\tcase hwmon_power_input:\n\t\tcase hwmon_power_max_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_power_max:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_max_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_max:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n#define INA238_HWMON_IN_CONFIG (HWMON_I_INPUT | \\\n\t\t\t\tHWMON_I_MAX | HWMON_I_MAX_ALARM | \\\n\t\t\t\tHWMON_I_MIN | HWMON_I_MIN_ALARM)\n\nstatic const struct hwmon_channel_info * const ina238_info[] = {\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t    \n\t\t\t   INA238_HWMON_IN_CONFIG,\n\t\t\t    \n\t\t\t   INA238_HWMON_IN_CONFIG),\n\tHWMON_CHANNEL_INFO(curr,\n\t\t\t    \n\t\t\t   HWMON_C_INPUT),\n\tHWMON_CHANNEL_INFO(power,\n\t\t\t    \n\t\t\t   HWMON_P_INPUT | HWMON_P_MAX | HWMON_P_MAX_ALARM),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t    \n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_ALARM),\n\tNULL\n};\n\nstatic const struct hwmon_ops ina238_hwmon_ops = {\n\t.is_visible = ina238_is_visible,\n\t.read = ina238_read,\n\t.write = ina238_write,\n};\n\nstatic const struct hwmon_chip_info ina238_chip_info = {\n\t.ops = &ina238_hwmon_ops,\n\t.info = ina238_info,\n};\n\nstatic int ina238_probe(struct i2c_client *client)\n{\n\tstruct ina2xx_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct ina238_data *data;\n\tint config;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->config_lock);\n\n\tdata->regmap = devm_regmap_init_i2c(client, &ina238_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\t \n\tdata->rshunt = INA238_RSHUNT_DEFAULT;\n\tif (device_property_read_u32(dev, \"shunt-resistor\", &data->rshunt) < 0 && pdata)\n\t\tdata->rshunt = pdata->shunt_uohms;\n\tif (data->rshunt == 0) {\n\t\tdev_err(dev, \"invalid shunt resister value %u\\n\", data->rshunt);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (device_property_read_u32(dev, \"ti,shunt-gain\", &data->gain) < 0)\n\t\tdata->gain = 4;  \n\tif (data->gain != 1 && data->gain != 4) {\n\t\tdev_err(dev, \"invalid shunt gain value %u\\n\", data->gain);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tconfig = INA238_CONFIG_DEFAULT;\n\tif (data->gain == 1)\n\t\tconfig |= INA238_CONFIG_ADCRANGE;  \n\tret = regmap_write(data->regmap, INA238_CONFIG, config);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error configuring the device: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = regmap_write(data->regmap, INA238_ADC_CONFIG,\n\t\t\t   INA238_ADC_CONFIG_DEFAULT);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error configuring the device: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = regmap_write(data->regmap, INA238_SHUNT_CALIBRATION,\n\t\t\t   INA238_CALIBRATION_VALUE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error configuring the device: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = regmap_write(data->regmap, INA238_DIAG_ALERT,\n\t\t\t   INA238_DIAG_ALERT_DEFAULT);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error configuring the device: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name, data,\n\t\t\t\t\t\t\t &ina238_chip_info,\n\t\t\t\t\t\t\t NULL);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdev_info(dev, \"power monitor %s (Rshunt = %u uOhm, gain = %u)\\n\",\n\t\t client->name, data->rshunt, data->gain);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id ina238_id[] = {\n\t{ \"ina238\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ina238_id);\n\nstatic const struct of_device_id __maybe_unused ina238_of_match[] = {\n\t{ .compatible = \"ti,ina238\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ina238_of_match);\n\nstatic struct i2c_driver ina238_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"ina238\",\n\t\t.of_match_table = of_match_ptr(ina238_of_match),\n\t},\n\t.probe\t\t= ina238_probe,\n\t.id_table\t= ina238_id,\n};\n\nmodule_i2c_driver(ina238_driver);\n\nMODULE_AUTHOR(\"Nathan Rossi <nathan.rossi@digi.com>\");\nMODULE_DESCRIPTION(\"ina238 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}