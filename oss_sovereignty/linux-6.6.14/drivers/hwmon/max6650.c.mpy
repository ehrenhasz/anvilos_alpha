{
  "module_name": "max6650.c",
  "hash_id": "2776d6079e63251f28425b83a6a320ce2b4fe98adcd8a6f2e3d16eb6ffe48f66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max6650.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/of_device.h>\n#include <linux/thermal.h>\n\n \n\n \nstatic int fan_voltage;\n \nstatic int prescaler;\n \nstatic int clock = 254000;\n\nmodule_param(fan_voltage, int, 0444);\nmodule_param(prescaler, int, 0444);\nmodule_param(clock, int, 0444);\n\n \n\n#define MAX6650_REG_SPEED\t0x00\n#define MAX6650_REG_CONFIG\t0x02\n#define MAX6650_REG_GPIO_DEF\t0x04\n#define MAX6650_REG_DAC\t\t0x06\n#define MAX6650_REG_ALARM_EN\t0x08\n#define MAX6650_REG_ALARM\t0x0A\n#define MAX6650_REG_TACH0\t0x0C\n#define MAX6650_REG_TACH1\t0x0E\n#define MAX6650_REG_TACH2\t0x10\n#define MAX6650_REG_TACH3\t0x12\n#define MAX6650_REG_GPIO_STAT\t0x14\n#define MAX6650_REG_COUNT\t0x16\n\n \n\n#define MAX6650_CFG_V12\t\t\t0x08\n#define MAX6650_CFG_PRESCALER_MASK\t0x07\n#define MAX6650_CFG_PRESCALER_2\t\t0x01\n#define MAX6650_CFG_PRESCALER_4\t\t0x02\n#define MAX6650_CFG_PRESCALER_8\t\t0x03\n#define MAX6650_CFG_PRESCALER_16\t0x04\n#define MAX6650_CFG_MODE_MASK\t\t0x30\n#define MAX6650_CFG_MODE_ON\t\t0x00\n#define MAX6650_CFG_MODE_OFF\t\t0x10\n#define MAX6650_CFG_MODE_CLOSED_LOOP\t0x20\n#define MAX6650_CFG_MODE_OPEN_LOOP\t0x30\n#define MAX6650_COUNT_MASK\t\t0x03\n\n \n\n#define MAX6650_ALRM_MAX\t0x01\n#define MAX6650_ALRM_MIN\t0x02\n#define MAX6650_ALRM_TACH\t0x04\n#define MAX6650_ALRM_GPIO1\t0x08\n#define MAX6650_ALRM_GPIO2\t0x10\n\n \n#define FAN_RPM_MIN 240\n#define FAN_RPM_MAX 30000\n\n#define DIV_FROM_REG(reg)\t(1 << ((reg) & 7))\n#define DAC_LIMIT(v12)\t\t((v12) ? 180 : 76)\n\n \n\nstruct max6650_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;  \n\tint nr_fans;\n\tbool valid;  \n\tunsigned long last_updated;  \n\n\t \n\tu8 speed;\n\tu8 config;\n\tu8 tach[4];\n\tu8 count;\n\tu8 dac;\n\tu8 alarm;\n\tu8 alarm_en;\n\tunsigned long cooling_dev_state;\n};\n\nstatic const u8 tach_reg[] = {\n\tMAX6650_REG_TACH0,\n\tMAX6650_REG_TACH1,\n\tMAX6650_REG_TACH2,\n\tMAX6650_REG_TACH3,\n};\n\nstatic const struct of_device_id __maybe_unused max6650_dt_match[] = {\n\t{\n\t\t.compatible = \"maxim,max6650\",\n\t\t.data = (void *)1\n\t},\n\t{\n\t\t.compatible = \"maxim,max6651\",\n\t\t.data = (void *)4\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, max6650_dt_match);\n\nstatic int dac_to_pwm(int dac, bool v12)\n{\n\t \n\treturn clamp_val(255 - (255 * dac) / DAC_LIMIT(v12), 0, 255);\n}\n\nstatic u8 pwm_to_dac(unsigned int pwm, bool v12)\n{\n\tint limit = DAC_LIMIT(v12);\n\n\treturn limit - (limit * pwm) / 255;\n}\n\nstatic struct max6650_data *max6650_update_device(struct device *dev)\n{\n\tstruct max6650_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint reg, err = 0;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\n\t\tfor (i = 0; i < data->nr_fans; i++) {\n\t\t\treg = i2c_smbus_read_byte_data(client, tach_reg[i]);\n\t\t\tif (reg < 0) {\n\t\t\t\terr = reg;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tdata->tach[i] = reg;\n\t\t}\n\n\t\t \n\t\treg = i2c_smbus_read_byte_data(client, MAX6650_REG_ALARM);\n\t\tif (reg < 0) {\n\t\t\terr = reg;\n\t\t\tgoto error;\n\t\t}\n\t\tdata->alarm |= reg;\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\nerror:\n\tmutex_unlock(&data->update_lock);\n\tif (err)\n\t\tdata = ERR_PTR(err);\n\treturn data;\n}\n\n \nstatic int max6650_set_operating_mode(struct max6650_data *data, u8 mode)\n{\n\tint result;\n\tu8 config = data->config;\n\n\tif (mode == (config & MAX6650_CFG_MODE_MASK))\n\t\treturn 0;\n\n\tconfig = (config & ~MAX6650_CFG_MODE_MASK) | mode;\n\n\tresult = i2c_smbus_write_byte_data(data->client, MAX6650_REG_CONFIG,\n\t\t\t\t\t   config);\n\tif (result < 0)\n\t\treturn result;\n\n\tdata->config = config;\n\n\treturn 0;\n}\n\n \n\nstatic int max6650_set_target(struct max6650_data *data, unsigned long rpm)\n{\n\tint kscale, ktach;\n\n\tif (rpm == 0)\n\t\treturn max6650_set_operating_mode(data, MAX6650_CFG_MODE_OFF);\n\n\trpm = clamp_val(rpm, FAN_RPM_MIN, FAN_RPM_MAX);\n\n\t \n\n\tkscale = DIV_FROM_REG(data->config);\n\tktach = ((clock * kscale) / (256 * rpm / 60)) - 1;\n\tif (ktach < 0)\n\t\tktach = 0;\n\tif (ktach > 255)\n\t\tktach = 255;\n\tdata->speed = ktach;\n\n\treturn i2c_smbus_write_byte_data(data->client, MAX6650_REG_SPEED,\n\t\t\t\t\t data->speed);\n}\n\n \n\nstatic ssize_t alarm_show(struct device *dev,\n\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct max6650_data *data = max6650_update_device(dev);\n\tbool alarm;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\talarm = data->alarm & attr->index;\n\tif (alarm) {\n\t\tmutex_lock(&data->update_lock);\n\t\tdata->alarm &= ~attr->index;\n\t\tdata->valid = false;\n\t\tmutex_unlock(&data->update_lock);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", alarm);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(gpio1_alarm, alarm, MAX6650_ALRM_GPIO1);\nstatic SENSOR_DEVICE_ATTR_RO(gpio2_alarm, alarm, MAX6650_ALRM_GPIO2);\n\nstatic umode_t max6650_attrs_visible(struct kobject *kobj, struct attribute *a,\n\t\t\t\t     int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct max6650_data *data = dev_get_drvdata(dev);\n\tstruct device_attribute *devattr;\n\n\t \n\n\tdevattr = container_of(a, struct device_attribute, attr);\n\tif (devattr == &sensor_dev_attr_gpio1_alarm.dev_attr ||\n\t    devattr == &sensor_dev_attr_gpio2_alarm.dev_attr) {\n\t\tif (!(data->alarm_en & to_sensor_dev_attr(devattr)->index))\n\t\t\treturn 0;\n\t}\n\n\treturn a->mode;\n}\n\nstatic struct attribute *max6650_attrs[] = {\n\t&sensor_dev_attr_gpio1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_gpio2_alarm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group max6650_group = {\n\t.attrs = max6650_attrs,\n\t.is_visible = max6650_attrs_visible,\n};\n\nstatic const struct attribute_group *max6650_groups[] = {\n\t&max6650_group,\n\tNULL\n};\n\nstatic int max6650_init_client(struct max6650_data *data,\n\t\t\t       struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tint reg;\n\tint err;\n\tu32 voltage;\n\tu32 prescale;\n\tu32 target_rpm;\n\n\tif (of_property_read_u32(dev->of_node, \"maxim,fan-microvolt\",\n\t\t\t\t &voltage))\n\t\tvoltage = fan_voltage;\n\telse\n\t\tvoltage /= 1000000;  \n\tif (of_property_read_u32(dev->of_node, \"maxim,fan-prescale\",\n\t\t\t\t &prescale))\n\t\tprescale = prescaler;\n\n\treg = i2c_smbus_read_byte_data(client, MAX6650_REG_CONFIG);\n\tif (reg < 0) {\n\t\tdev_err(dev, \"Error reading config register, aborting.\\n\");\n\t\treturn reg;\n\t}\n\n\tswitch (voltage) {\n\tcase 0:\n\t\tbreak;\n\tcase 5:\n\t\treg &= ~MAX6650_CFG_V12;\n\t\tbreak;\n\tcase 12:\n\t\treg |= MAX6650_CFG_V12;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"illegal value for fan_voltage (%d)\\n\", voltage);\n\t}\n\n\tswitch (prescale) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~MAX6650_CFG_PRESCALER_MASK;\n\t\tbreak;\n\tcase 2:\n\t\treg = (reg & ~MAX6650_CFG_PRESCALER_MASK)\n\t\t\t | MAX6650_CFG_PRESCALER_2;\n\t\tbreak;\n\tcase  4:\n\t\treg = (reg & ~MAX6650_CFG_PRESCALER_MASK)\n\t\t\t | MAX6650_CFG_PRESCALER_4;\n\t\tbreak;\n\tcase  8:\n\t\treg = (reg & ~MAX6650_CFG_PRESCALER_MASK)\n\t\t\t | MAX6650_CFG_PRESCALER_8;\n\t\tbreak;\n\tcase 16:\n\t\treg = (reg & ~MAX6650_CFG_PRESCALER_MASK)\n\t\t\t | MAX6650_CFG_PRESCALER_16;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"illegal value for prescaler (%d)\\n\", prescale);\n\t}\n\n\tdev_info(dev, \"Fan voltage: %dV, prescaler: %d.\\n\",\n\t\t (reg & MAX6650_CFG_V12) ? 12 : 5,\n\t\t 1 << (reg & MAX6650_CFG_PRESCALER_MASK));\n\n\terr = i2c_smbus_write_byte_data(client, MAX6650_REG_CONFIG, reg);\n\tif (err) {\n\t\tdev_err(dev, \"Config write error, aborting.\\n\");\n\t\treturn err;\n\t}\n\tdata->config = reg;\n\n\treg = i2c_smbus_read_byte_data(client, MAX6650_REG_SPEED);\n\tif (reg < 0) {\n\t\tdev_err(dev, \"Failed to read speed register, aborting.\\n\");\n\t\treturn reg;\n\t}\n\tdata->speed = reg;\n\n\treg = i2c_smbus_read_byte_data(client, MAX6650_REG_DAC);\n\tif (reg < 0) {\n\t\tdev_err(dev, \"Failed to read DAC register, aborting.\\n\");\n\t\treturn reg;\n\t}\n\tdata->dac = reg;\n\n\treg = i2c_smbus_read_byte_data(client, MAX6650_REG_COUNT);\n\tif (reg < 0) {\n\t\tdev_err(dev, \"Failed to read count register, aborting.\\n\");\n\t\treturn reg;\n\t}\n\tdata->count = reg;\n\n\treg = i2c_smbus_read_byte_data(client, MAX6650_REG_ALARM_EN);\n\tif (reg < 0) {\n\t\tdev_err(dev, \"Failed to read alarm configuration, aborting.\\n\");\n\t\treturn reg;\n\t}\n\tdata->alarm_en = reg;\n\n\tif (!of_property_read_u32(client->dev.of_node, \"maxim,fan-target-rpm\",\n\t\t\t\t  &target_rpm)) {\n\t\tmax6650_set_target(data, target_rpm);\n\t\tmax6650_set_operating_mode(data, MAX6650_CFG_MODE_CLOSED_LOOP);\n\t}\n\n\treturn 0;\n}\n\nstatic int max6650_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long *state)\n{\n\t*state = 255;\n\n\treturn 0;\n}\n\nstatic int max6650_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long *state)\n{\n\tstruct max6650_data *data = cdev->devdata;\n\n\t*state = data->cooling_dev_state;\n\n\treturn 0;\n}\n\nstatic int max6650_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long state)\n{\n\tstruct max6650_data *data = cdev->devdata;\n\tstruct i2c_client *client = data->client;\n\tint err;\n\n\tstate = clamp_val(state, 0, 255);\n\n\tmutex_lock(&data->update_lock);\n\n\tdata->dac = pwm_to_dac(state, data->config & MAX6650_CFG_V12);\n\terr = i2c_smbus_write_byte_data(client, MAX6650_REG_DAC, data->dac);\n\tif (!err) {\n\t\tmax6650_set_operating_mode(data, state ?\n\t\t\t\t\t   MAX6650_CFG_MODE_OPEN_LOOP :\n\t\t\t\t\t   MAX6650_CFG_MODE_OFF);\n\t\tdata->cooling_dev_state = state;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn err;\n}\n\nstatic const struct thermal_cooling_device_ops max6650_cooling_ops = {\n\t.get_max_state = max6650_get_max_state,\n\t.get_cur_state = max6650_get_cur_state,\n\t.set_cur_state = max6650_set_cur_state,\n};\n\nstatic int max6650_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct max6650_data *data = max6650_update_device(dev);\n\tint mode;\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\t*val = dac_to_pwm(data->dac,\n\t\t\t\t\t  data->config & MAX6650_CFG_V12);\n\t\t\tbreak;\n\t\tcase hwmon_pwm_enable:\n\t\t\t \n\t\t\tmode = (data->config & MAX6650_CFG_MODE_MASK) >> 4;\n\t\t\t*val = (4 - mode) & 3;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\t \n\t\t\t*val = DIV_ROUND_CLOSEST(data->tach[channel] * 120,\n\t\t\t\t\t\t DIV_FROM_REG(data->count));\n\t\t\tbreak;\n\t\tcase hwmon_fan_div:\n\t\t\t*val = DIV_FROM_REG(data->count);\n\t\t\tbreak;\n\t\tcase hwmon_fan_target:\n\t\t\t \n\t\t\t*val = 60 * DIV_FROM_REG(data->config) * clock /\n\t\t\t\t(256 * (data->speed + 1));\n\t\t\tbreak;\n\t\tcase hwmon_fan_min_alarm:\n\t\t\t*val = !!(data->alarm & MAX6650_ALRM_MIN);\n\t\t\tdata->alarm &= ~MAX6650_ALRM_MIN;\n\t\t\tdata->valid = false;\n\t\t\tbreak;\n\t\tcase hwmon_fan_max_alarm:\n\t\t\t*val = !!(data->alarm & MAX6650_ALRM_MAX);\n\t\t\tdata->alarm &= ~MAX6650_ALRM_MAX;\n\t\t\tdata->valid = false;\n\t\t\tbreak;\n\t\tcase hwmon_fan_fault:\n\t\t\t*val = !!(data->alarm & MAX6650_ALRM_TACH);\n\t\t\tdata->alarm &= ~MAX6650_ALRM_TACH;\n\t\t\tdata->valid = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic const u8 max6650_pwm_modes[] = {\n\tMAX6650_CFG_MODE_ON,\n\tMAX6650_CFG_MODE_OPEN_LOOP,\n\tMAX6650_CFG_MODE_CLOSED_LOOP,\n\tMAX6650_CFG_MODE_OFF,\n};\n\nstatic int max6650_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long val)\n{\n\tstruct max6650_data *data = dev_get_drvdata(dev);\n\tint ret = 0;\n\tu8 reg;\n\n\tmutex_lock(&data->update_lock);\n\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\treg = pwm_to_dac(clamp_val(val, 0, 255),\n\t\t\t\t\t data->config & MAX6650_CFG_V12);\n\t\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t\t\tMAX6650_REG_DAC, reg);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tdata->dac = reg;\n\t\t\tbreak;\n\t\tcase hwmon_pwm_enable:\n\t\t\tif (val < 0 || val >= ARRAY_SIZE(max6650_pwm_modes)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = max6650_set_operating_mode(data,\n\t\t\t\t\t\tmax6650_pwm_modes[val]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_div:\n\t\t\tswitch (val) {\n\t\t\tcase 1:\n\t\t\t\treg = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\treg = 1;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\treg = 2;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\treg = 3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t\t\tMAX6650_REG_COUNT, reg);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tdata->count = reg;\n\t\t\tbreak;\n\t\tcase hwmon_fan_target:\n\t\t\tif (val < 0) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = max6650_set_target(data, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\nerror:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic umode_t max6650_is_visible(const void *_data,\n\t\t\t\t  enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t  int channel)\n{\n\tconst struct max6650_data *data = _data;\n\n\tif (channel && (channel >= data->nr_fans || type != hwmon_fan))\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\treturn 0444;\n\t\tcase hwmon_fan_target:\n\t\tcase hwmon_fan_div:\n\t\t\treturn 0644;\n\t\tcase hwmon_fan_min_alarm:\n\t\t\tif (data->alarm_en & MAX6650_ALRM_MIN)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase hwmon_fan_max_alarm:\n\t\t\tif (data->alarm_en & MAX6650_ALRM_MAX)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase hwmon_fan_fault:\n\t\t\tif (data->alarm_en & MAX6650_ALRM_TACH)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\tcase hwmon_pwm_enable:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const max6650_info[] = {\n\tHWMON_CHANNEL_INFO(fan, HWMON_F_INPUT | HWMON_F_TARGET | HWMON_F_DIV |\n\t\t\t   HWMON_F_MIN_ALARM | HWMON_F_MAX_ALARM |\n\t\t\t   HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT, HWMON_F_INPUT, HWMON_F_INPUT),\n\tHWMON_CHANNEL_INFO(pwm, HWMON_PWM_INPUT | HWMON_PWM_ENABLE),\n\tNULL\n};\n\nstatic const struct hwmon_ops max6650_hwmon_ops = {\n\t.read = max6650_read,\n\t.write = max6650_write,\n\t.is_visible = max6650_is_visible,\n};\n\nstatic const struct hwmon_chip_info max6650_chip_info = {\n\t.ops = &max6650_hwmon_ops,\n\t.info = max6650_info,\n};\n\nstatic const struct i2c_device_id max6650_id[];\n\nstatic int max6650_probe(struct i2c_client *client)\n{\n\tstruct thermal_cooling_device *cooling_dev;\n\tstruct device *dev = &client->dev;\n\tconst struct of_device_id *of_id =\n\t\tof_match_device(of_match_ptr(max6650_dt_match), dev);\n\tstruct max6650_data *data;\n\tstruct device *hwmon_dev;\n\tint err;\n\n\tdata = devm_kzalloc(dev, sizeof(struct max6650_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\tdata->nr_fans = of_id ? (int)(uintptr_t)of_id->data :\n\t\t\t\ti2c_match_id(max6650_id, client)->driver_data;\n\n\t \n\terr = max6650_init_client(data, client);\n\tif (err)\n\t\treturn err;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev,\n\t\t\t\t\t\t\t client->name, data,\n\t\t\t\t\t\t\t &max6650_chip_info,\n\t\t\t\t\t\t\t max6650_groups);\n\terr = PTR_ERR_OR_ZERO(hwmon_dev);\n\tif (err)\n\t\treturn err;\n\n\tif (IS_ENABLED(CONFIG_THERMAL)) {\n\t\tcooling_dev = devm_thermal_of_cooling_device_register(dev,\n\t\t\t\t\t\tdev->of_node, client->name,\n\t\t\t\t\t\tdata, &max6650_cooling_ops);\n\t\tif (IS_ERR(cooling_dev)) {\n\t\t\tdev_warn(dev, \"thermal cooling device register failed: %ld\\n\",\n\t\t\t\t PTR_ERR(cooling_dev));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max6650_id[] = {\n\t{ \"max6650\", 1 },\n\t{ \"max6651\", 4 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max6650_id);\n\nstatic struct i2c_driver max6650_driver = {\n\t.driver = {\n\t\t.name\t= \"max6650\",\n\t\t.of_match_table = of_match_ptr(max6650_dt_match),\n\t},\n\t.probe\t\t= max6650_probe,\n\t.id_table\t= max6650_id,\n};\n\nmodule_i2c_driver(max6650_driver);\n\nMODULE_AUTHOR(\"Hans J. Koch\");\nMODULE_DESCRIPTION(\"MAX6650 sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}