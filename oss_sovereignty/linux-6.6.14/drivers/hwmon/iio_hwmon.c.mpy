{
  "module_name": "iio_hwmon.c",
  "hash_id": "0b3f53d077d751c1b5c4cc22b34718c05e018b8ab344422168272a33c03785bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/iio_hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/iio/consumer.h>\n#include <linux/iio/types.h>\n\n \nstruct iio_hwmon_state {\n\tstruct iio_channel *channels;\n\tint num_channels;\n\tstruct attribute_group attr_group;\n\tconst struct attribute_group *groups[2];\n\tstruct attribute **attrs;\n};\n\n \nstatic ssize_t iio_hwmon_read_val(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tint result;\n\tint ret;\n\tstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\n\tstruct iio_hwmon_state *state = dev_get_drvdata(dev);\n\tstruct iio_channel *chan = &state->channels[sattr->index];\n\tenum iio_chan_type type;\n\n\tret = iio_read_channel_processed(chan, &result);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iio_get_channel_type(chan, &type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (type == IIO_POWER)\n\t\tresult *= 1000;  \n\n\treturn sprintf(buf, \"%d\\n\", result);\n}\n\nstatic int iio_hwmon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_hwmon_state *st;\n\tstruct sensor_device_attribute *a;\n\tint ret, i;\n\tint in_i = 1, temp_i = 1, curr_i = 1, humidity_i = 1, power_i = 1;\n\tenum iio_chan_type type;\n\tstruct iio_channel *channels;\n\tstruct device *hwmon_dev;\n\tchar *sname;\n\n\tchannels = devm_iio_channel_get_all(dev);\n\tif (IS_ERR(channels)) {\n\t\tret = PTR_ERR(channels);\n\t\tif (ret == -ENODEV)\n\t\t\tret = -EPROBE_DEFER;\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to get channels\\n\");\n\t}\n\n\tst = devm_kzalloc(dev, sizeof(*st), GFP_KERNEL);\n\tif (st == NULL)\n\t\treturn -ENOMEM;\n\n\tst->channels = channels;\n\n\t \n\twhile (st->channels[st->num_channels].indio_dev)\n\t\tst->num_channels++;\n\n\tst->attrs = devm_kcalloc(dev,\n\t\t\t\t st->num_channels + 1, sizeof(*st->attrs),\n\t\t\t\t GFP_KERNEL);\n\tif (st->attrs == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < st->num_channels; i++) {\n\t\tconst char *prefix;\n\t\tint n;\n\n\t\ta = devm_kzalloc(dev, sizeof(*a), GFP_KERNEL);\n\t\tif (a == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tsysfs_attr_init(&a->dev_attr.attr);\n\t\tret = iio_get_channel_type(&st->channels[i], &type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tswitch (type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tn = in_i++;\n\t\t\tprefix = \"in\";\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\tn = temp_i++;\n\t\t\tprefix = \"temp\";\n\t\t\tbreak;\n\t\tcase IIO_CURRENT:\n\t\t\tn = curr_i++;\n\t\t\tprefix = \"curr\";\n\t\t\tbreak;\n\t\tcase IIO_POWER:\n\t\t\tn = power_i++;\n\t\t\tprefix = \"power\";\n\t\t\tbreak;\n\t\tcase IIO_HUMIDITYRELATIVE:\n\t\t\tn = humidity_i++;\n\t\t\tprefix = \"humidity\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ta->dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t       \"%s%d_input\",\n\t\t\t\t\t\t       prefix, n);\n\t\tif (a->dev_attr.attr.name == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\ta->dev_attr.show = iio_hwmon_read_val;\n\t\ta->dev_attr.attr.mode = 0444;\n\t\ta->index = i;\n\t\tst->attrs[i] = &a->dev_attr.attr;\n\t}\n\n\tst->attr_group.attrs = st->attrs;\n\tst->groups[0] = &st->attr_group;\n\n\tif (dev_fwnode(dev)) {\n\t\tsname = devm_kasprintf(dev, GFP_KERNEL, \"%pfwP\", dev_fwnode(dev));\n\t\tif (!sname)\n\t\t\treturn -ENOMEM;\n\t\tstrreplace(sname, '-', '_');\n\t} else {\n\t\tsname = \"iio_hwmon\";\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, sname, st,\n\t\t\t\t\t\t\t   st->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct of_device_id iio_hwmon_of_match[] = {\n\t{ .compatible = \"iio-hwmon\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, iio_hwmon_of_match);\n\nstatic struct platform_driver iio_hwmon_driver = {\n\t.driver = {\n\t\t.name = \"iio_hwmon\",\n\t\t.of_match_table = iio_hwmon_of_match,\n\t},\n\t.probe = iio_hwmon_probe,\n};\n\nmodule_platform_driver(iio_hwmon_driver);\n\nMODULE_AUTHOR(\"Jonathan Cameron <jic23@kernel.org>\");\nMODULE_DESCRIPTION(\"IIO to hwmon driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}