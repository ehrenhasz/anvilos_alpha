{
  "module_name": "lm77.c",
  "hash_id": "6374c9114a2353a37c5119ed65bbb4950231c2157906bdae3b07ffc95b981a38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lm77.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x48, 0x49, 0x4a, 0x4b,\n\t\t\t\t\t\tI2C_CLIENT_END };\n\n \n#define LM77_REG_TEMP\t\t0x00\n#define LM77_REG_CONF\t\t0x01\n#define LM77_REG_TEMP_HYST\t0x02\n#define LM77_REG_TEMP_CRIT\t0x03\n#define LM77_REG_TEMP_MIN\t0x04\n#define LM77_REG_TEMP_MAX\t0x05\n\nenum temp_index {\n\tt_input = 0,\n\tt_crit,\n\tt_min,\n\tt_max,\n\tt_hyst,\n\tt_num_temp\n};\n\nstatic const u8 temp_regs[t_num_temp] = {\n\t[t_input] = LM77_REG_TEMP,\n\t[t_min] = LM77_REG_TEMP_MIN,\n\t[t_max] = LM77_REG_TEMP_MAX,\n\t[t_crit] = LM77_REG_TEMP_CRIT,\n\t[t_hyst] = LM77_REG_TEMP_HYST,\n};\n\n \nstruct lm77_data {\n\tstruct i2c_client\t*client;\n\tstruct mutex\t\tupdate_lock;\n\tbool\t\t\tvalid;\n\tunsigned long\t\tlast_updated;\t \n\tint\t\t\ttemp[t_num_temp];  \n\tu8\t\t\talarms;\n};\n\n \n#define LM77_TEMP_MIN (-55000)\n#define LM77_TEMP_MAX 125000\n\n \nstatic inline s16 LM77_TEMP_TO_REG(int temp)\n{\n\treturn (temp / 500) * 8;\n}\n\nstatic inline int LM77_TEMP_FROM_REG(s16 reg)\n{\n\treturn (reg / 8) * 500;\n}\n\n \nstatic u16 lm77_read_value(struct i2c_client *client, u8 reg)\n{\n\tif (reg == LM77_REG_CONF)\n\t\treturn i2c_smbus_read_byte_data(client, reg);\n\telse\n\t\treturn i2c_smbus_read_word_swapped(client, reg);\n}\n\nstatic int lm77_write_value(struct i2c_client *client, u8 reg, u16 value)\n{\n\tif (reg == LM77_REG_CONF)\n\t\treturn i2c_smbus_write_byte_data(client, reg, value);\n\telse\n\t\treturn i2c_smbus_write_word_swapped(client, reg, value);\n}\n\nstatic struct lm77_data *lm77_update_device(struct device *dev)\n{\n\tstruct lm77_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\n\t    || !data->valid) {\n\t\tdev_dbg(&client->dev, \"Starting lm77 update\\n\");\n\t\tfor (i = 0; i < t_num_temp; i++) {\n\t\t\tdata->temp[i] =\n\t\t\t  LM77_TEMP_FROM_REG(lm77_read_value(client,\n\t\t\t\t\t\t\t     temp_regs[i]));\n\t\t}\n\t\tdata->alarms =\n\t\t\tlm77_read_value(client, LM77_REG_TEMP) & 0x0007;\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm77_data *data = lm77_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", data->temp[attr->index]);\n}\n\nstatic ssize_t temp_hyst_show(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm77_data *data = lm77_update_device(dev);\n\tint nr = attr->index;\n\tint temp;\n\n\ttemp = nr == t_min ? data->temp[nr] + data->temp[t_hyst] :\n\t\t\t     data->temp[nr] - data->temp[t_hyst];\n\n\treturn sprintf(buf, \"%d\\n\", temp);\n}\n\nstatic ssize_t temp_store(struct device *dev,\n\t\t\t  struct device_attribute *devattr, const char *buf,\n\t\t\t  size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct lm77_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = attr->index;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tval = clamp_val(val, LM77_TEMP_MIN, LM77_TEMP_MAX);\n\tmutex_lock(&data->update_lock);\n\tdata->temp[nr] = val;\n\tlm77_write_value(client, temp_regs[nr], LM77_TEMP_TO_REG(val));\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\n \nstatic ssize_t temp_hyst_store(struct device *dev,\n\t\t\t       struct device_attribute *devattr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct lm77_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tval = clamp_val(data->temp[t_crit] - val, LM77_TEMP_MIN, LM77_TEMP_MAX);\n\tdata->temp[t_hyst] = val;\n\tlm77_write_value(client, LM77_REG_TEMP_HYST,\n\t\t\t LM77_TEMP_TO_REG(data->temp[t_hyst]));\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tstruct lm77_data *data = lm77_update_device(dev);\n\treturn sprintf(buf, \"%u\\n\", (data->alarms >> bitnr) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, t_input);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_crit, temp, t_crit);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp, t_min);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp, t_max);\n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_crit_hyst, temp_hyst, t_crit);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_hyst, temp_hyst, t_min);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_hyst, temp_hyst, t_max);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_crit_alarm, alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_alarm, alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, alarm, 1);\n\nstatic struct attribute *lm77_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(lm77);\n\n \nstatic int lm77_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint i, cur, conf, hyst, crit, min, max;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\t \n\n\t \n\tcur = i2c_smbus_read_word_data(client, 0);\n\tconf = i2c_smbus_read_byte_data(client, 1);\n\thyst = i2c_smbus_read_word_data(client, 2);\n\tcrit = i2c_smbus_read_word_data(client, 3);\n\tmin = i2c_smbus_read_word_data(client, 4);\n\tmax = i2c_smbus_read_word_data(client, 5);\n\tfor (i = 8; i <= 0xff; i += 8) {\n\t\tif (i2c_smbus_read_byte_data(client, i + 1) != conf\n\t\t || i2c_smbus_read_word_data(client, i + 2) != hyst\n\t\t || i2c_smbus_read_word_data(client, i + 3) != crit\n\t\t || i2c_smbus_read_word_data(client, i + 4) != min\n\t\t || i2c_smbus_read_word_data(client, i + 5) != max)\n\t\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (((cur & 0x00f0) != 0xf0 && (cur & 0x00f0) != 0x0)\n\t || ((hyst & 0x00f0) != 0xf0 && (hyst & 0x00f0) != 0x0)\n\t || ((crit & 0x00f0) != 0xf0 && (crit & 0x00f0) != 0x0)\n\t || ((min & 0x00f0) != 0xf0 && (min & 0x00f0) != 0x0)\n\t || ((max & 0x00f0) != 0xf0 && (max & 0x00f0) != 0x0))\n\t\treturn -ENODEV;\n\n\t \n\tif (conf & 0xe0)\n\t\treturn -ENODEV;\n\n\t \n\tcur = i2c_smbus_read_word_data(client, 0);\n\tif (i2c_smbus_read_word_data(client, 6) != cur\n\t || i2c_smbus_read_word_data(client, 7) != cur)\n\t\treturn -ENODEV;\n\thyst = i2c_smbus_read_word_data(client, 2);\n\tif (i2c_smbus_read_word_data(client, 6) != hyst\n\t || i2c_smbus_read_word_data(client, 7) != hyst)\n\t\treturn -ENODEV;\n\tmin = i2c_smbus_read_word_data(client, 4);\n\tif (i2c_smbus_read_word_data(client, 6) != min\n\t || i2c_smbus_read_word_data(client, 7) != min)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"lm77\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic void lm77_init_client(struct i2c_client *client)\n{\n\t \n\tint conf = lm77_read_value(client, LM77_REG_CONF);\n\tif (conf & 1)\n\t\tlm77_write_value(client, LM77_REG_CONF, conf & 0xfe);\n}\n\nstatic int lm77_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct lm77_data *data;\n\n\tdata = devm_kzalloc(dev, sizeof(struct lm77_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tlm77_init_client(client);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, lm77_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id lm77_id[] = {\n\t{ \"lm77\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm77_id);\n\n \nstatic struct i2c_driver lm77_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"lm77\",\n\t},\n\t.probe\t\t= lm77_probe,\n\t.id_table\t= lm77_id,\n\t.detect\t\t= lm77_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(lm77_driver);\n\nMODULE_AUTHOR(\"Andras BALI <drewie@freemail.hu>\");\nMODULE_DESCRIPTION(\"LM77 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}