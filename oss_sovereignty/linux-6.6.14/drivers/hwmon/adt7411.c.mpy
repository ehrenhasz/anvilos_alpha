{
  "module_name": "adt7411.c",
  "hash_id": "8278070664435f3b06d28e46a77624cee96bb5a5e5baf921d70fe3f486298111",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adt7411.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/slab.h>\n\n#define ADT7411_REG_STAT_1\t\t\t0x00\n#define ADT7411_STAT_1_INT_TEMP_HIGH\t\tBIT(0)\n#define ADT7411_STAT_1_INT_TEMP_LOW\t\tBIT(1)\n#define ADT7411_STAT_1_EXT_TEMP_HIGH_AIN1\tBIT(2)\n#define ADT7411_STAT_1_EXT_TEMP_LOW\t\tBIT(3)\n#define ADT7411_STAT_1_EXT_TEMP_FAULT\t\tBIT(4)\n#define ADT7411_STAT_1_AIN2\t\t\tBIT(5)\n#define ADT7411_STAT_1_AIN3\t\t\tBIT(6)\n#define ADT7411_STAT_1_AIN4\t\t\tBIT(7)\n#define ADT7411_REG_STAT_2\t\t\t0x01\n#define ADT7411_STAT_2_AIN5\t\t\tBIT(0)\n#define ADT7411_STAT_2_AIN6\t\t\tBIT(1)\n#define ADT7411_STAT_2_AIN7\t\t\tBIT(2)\n#define ADT7411_STAT_2_AIN8\t\t\tBIT(3)\n#define ADT7411_STAT_2_VDD\t\t\tBIT(4)\n#define ADT7411_REG_INT_TEMP_VDD_LSB\t\t0x03\n#define ADT7411_REG_EXT_TEMP_AIN14_LSB\t\t0x04\n#define ADT7411_REG_VDD_MSB\t\t\t0x06\n#define ADT7411_REG_INT_TEMP_MSB\t\t0x07\n#define ADT7411_REG_EXT_TEMP_AIN1_MSB\t\t0x08\n\n#define ADT7411_REG_CFG1\t\t\t0x18\n#define ADT7411_CFG1_START_MONITOR\t\tBIT(0)\n#define ADT7411_CFG1_RESERVED_BIT1\t\tBIT(1)\n#define ADT7411_CFG1_EXT_TDM\t\t\tBIT(2)\n#define ADT7411_CFG1_RESERVED_BIT3\t\tBIT(3)\n\n#define ADT7411_REG_CFG2\t\t\t0x19\n#define ADT7411_CFG2_DISABLE_AVG\t\tBIT(5)\n\n#define ADT7411_REG_CFG3\t\t\t0x1a\n#define ADT7411_CFG3_ADC_CLK_225\t\tBIT(0)\n#define ADT7411_CFG3_RESERVED_BIT1\t\tBIT(1)\n#define ADT7411_CFG3_RESERVED_BIT2\t\tBIT(2)\n#define ADT7411_CFG3_RESERVED_BIT3\t\tBIT(3)\n#define ADT7411_CFG3_REF_VDD\t\t\tBIT(4)\n\n#define ADT7411_REG_VDD_HIGH\t\t\t0x23\n#define ADT7411_REG_VDD_LOW\t\t\t0x24\n#define ADT7411_REG_TEMP_HIGH(nr)\t\t(0x25 + 2 * (nr))\n#define ADT7411_REG_TEMP_LOW(nr)\t\t(0x26 + 2 * (nr))\n#define ADT7411_REG_IN_HIGH(nr)\t\t((nr) > 1 \\\n\t\t\t\t\t\t  ? 0x2b + 2 * ((nr)-2) \\\n\t\t\t\t\t\t  : 0x27)\n#define ADT7411_REG_IN_LOW(nr)\t\t\t((nr) > 1 \\\n\t\t\t\t\t\t  ? 0x2c + 2 * ((nr)-2) \\\n\t\t\t\t\t\t  : 0x28)\n\n#define ADT7411_REG_DEVICE_ID\t\t\t0x4d\n#define ADT7411_REG_MANUFACTURER_ID\t\t0x4e\n\n#define ADT7411_DEVICE_ID\t\t\t0x2\n#define ADT7411_MANUFACTURER_ID\t\t\t0x41\n\nstatic const unsigned short normal_i2c[] = { 0x48, 0x4a, 0x4b, I2C_CLIENT_END };\n\nstatic const u8 adt7411_in_alarm_reg[] = {\n\tADT7411_REG_STAT_2,\n\tADT7411_REG_STAT_1,\n\tADT7411_REG_STAT_1,\n\tADT7411_REG_STAT_1,\n\tADT7411_REG_STAT_1,\n\tADT7411_REG_STAT_2,\n\tADT7411_REG_STAT_2,\n\tADT7411_REG_STAT_2,\n\tADT7411_REG_STAT_2,\n};\n\nstatic const u8 adt7411_in_alarm_bits[] = {\n\tADT7411_STAT_2_VDD,\n\tADT7411_STAT_1_EXT_TEMP_HIGH_AIN1,\n\tADT7411_STAT_1_AIN2,\n\tADT7411_STAT_1_AIN3,\n\tADT7411_STAT_1_AIN4,\n\tADT7411_STAT_2_AIN5,\n\tADT7411_STAT_2_AIN6,\n\tADT7411_STAT_2_AIN7,\n\tADT7411_STAT_2_AIN8,\n};\n\nstruct adt7411_data {\n\tstruct mutex device_lock;\t \n\tstruct mutex update_lock;\n\tunsigned long next_update;\n\tlong vref_cached;\n\tstruct i2c_client *client;\n\tbool use_ext_temp;\n};\n\n \nstatic int adt7411_read_10_bit(struct i2c_client *client, u8 lsb_reg,\n\t\t\t\tu8 msb_reg, u8 lsb_shift)\n{\n\tstruct adt7411_data *data = i2c_get_clientdata(client);\n\tint val, tmp;\n\n\tmutex_lock(&data->device_lock);\n\n\tval = i2c_smbus_read_byte_data(client, lsb_reg);\n\tif (val < 0)\n\t\tgoto exit_unlock;\n\n\ttmp = (val >> lsb_shift) & 3;\n\tval = i2c_smbus_read_byte_data(client, msb_reg);\n\n\tif (val >= 0)\n\t\tval = (val << 2) | tmp;\n\n exit_unlock:\n\tmutex_unlock(&data->device_lock);\n\n\treturn val;\n}\n\nstatic int adt7411_modify_bit(struct i2c_client *client, u8 reg, u8 bit,\n\t\t\t\tbool flag)\n{\n\tstruct adt7411_data *data = i2c_get_clientdata(client);\n\tint ret, val;\n\n\tmutex_lock(&data->device_lock);\n\n\tret = i2c_smbus_read_byte_data(client, reg);\n\tif (ret < 0)\n\t\tgoto exit_unlock;\n\n\tif (flag)\n\t\tval = ret | bit;\n\telse\n\t\tval = ret & ~bit;\n\n\tret = i2c_smbus_write_byte_data(client, reg, val);\n\n exit_unlock:\n\tmutex_unlock(&data->device_lock);\n\treturn ret;\n}\n\nstatic ssize_t adt7411_show_bit(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr2 = to_sensor_dev_attr_2(attr);\n\tstruct adt7411_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret = i2c_smbus_read_byte_data(client, attr2->index);\n\n\treturn ret < 0 ? ret : sprintf(buf, \"%u\\n\", !!(ret & attr2->nr));\n}\n\nstatic ssize_t adt7411_set_bit(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct sensor_device_attribute_2 *s_attr2 = to_sensor_dev_attr_2(attr);\n\tstruct adt7411_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\tunsigned long flag;\n\n\tret = kstrtoul(buf, 0, &flag);\n\tif (ret || flag > 1)\n\t\treturn -EINVAL;\n\n\tret = adt7411_modify_bit(client, s_attr2->index, s_attr2->nr, flag);\n\n\t \n\tmutex_lock(&data->update_lock);\n\tdata->next_update = jiffies;\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret < 0 ? ret : count;\n}\n\n#define ADT7411_BIT_ATTR(__name, __reg, __bit) \\\n\tSENSOR_DEVICE_ATTR_2(__name, S_IRUGO | S_IWUSR, adt7411_show_bit, \\\n\tadt7411_set_bit, __bit, __reg)\n\nstatic ADT7411_BIT_ATTR(no_average, ADT7411_REG_CFG2, ADT7411_CFG2_DISABLE_AVG);\nstatic ADT7411_BIT_ATTR(fast_sampling, ADT7411_REG_CFG3, ADT7411_CFG3_ADC_CLK_225);\nstatic ADT7411_BIT_ATTR(adc_ref_vdd, ADT7411_REG_CFG3, ADT7411_CFG3_REF_VDD);\n\nstatic struct attribute *adt7411_attrs[] = {\n\t&sensor_dev_attr_no_average.dev_attr.attr,\n\t&sensor_dev_attr_fast_sampling.dev_attr.attr,\n\t&sensor_dev_attr_adc_ref_vdd.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(adt7411);\n\nstatic int adt7411_read_in_alarm(struct device *dev, int channel, long *val)\n{\n\tstruct adt7411_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, adt7411_in_alarm_reg[channel]);\n\tif (ret < 0)\n\t\treturn ret;\n\t*val = !!(ret & adt7411_in_alarm_bits[channel]);\n\treturn 0;\n}\n\nstatic int adt7411_read_in_vdd(struct device *dev, u32 attr, long *val)\n{\n\tstruct adt7411_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\tret = adt7411_read_10_bit(client, ADT7411_REG_INT_TEMP_VDD_LSB,\n\t\t\t\t\t  ADT7411_REG_VDD_MSB, 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret * 7000 / 1024;\n\t\treturn 0;\n\tcase hwmon_in_min:\n\t\tret = i2c_smbus_read_byte_data(client, ADT7411_REG_VDD_LOW);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret * 7000 / 256;\n\t\treturn 0;\n\tcase hwmon_in_max:\n\t\tret = i2c_smbus_read_byte_data(client, ADT7411_REG_VDD_HIGH);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret * 7000 / 256;\n\t\treturn 0;\n\tcase hwmon_in_alarm:\n\t\treturn adt7411_read_in_alarm(dev, 0, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int adt7411_update_vref(struct device *dev)\n{\n\tstruct adt7411_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint val;\n\n\tif (time_after_eq(jiffies, data->next_update)) {\n\t\tval = i2c_smbus_read_byte_data(client, ADT7411_REG_CFG3);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tif (val & ADT7411_CFG3_REF_VDD) {\n\t\t\tval = adt7411_read_in_vdd(dev, hwmon_in_input,\n\t\t\t\t\t\t  &data->vref_cached);\n\t\t\tif (val < 0)\n\t\t\t\treturn val;\n\t\t} else {\n\t\t\tdata->vref_cached = 2250;\n\t\t}\n\n\t\tdata->next_update = jiffies + HZ;\n\t}\n\n\treturn 0;\n}\n\nstatic int adt7411_read_in_chan(struct device *dev, u32 attr, int channel,\n\t\t\t\tlong *val)\n{\n\tstruct adt7411_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\tint ret;\n\tint reg, lsb_reg, lsb_shift;\n\tint nr = channel - 1;\n\n\tmutex_lock(&data->update_lock);\n\tret = adt7411_update_vref(dev);\n\tif (ret < 0)\n\t\tgoto exit_unlock;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\tlsb_reg = ADT7411_REG_EXT_TEMP_AIN14_LSB + (nr >> 2);\n\t\tlsb_shift = 2 * (nr & 0x03);\n\t\tret = adt7411_read_10_bit(client, lsb_reg,\n\t\t\t\t\t  ADT7411_REG_EXT_TEMP_AIN1_MSB + nr,\n\t\t\t\t\t  lsb_shift);\n\t\tif (ret < 0)\n\t\t\tgoto exit_unlock;\n\t\t*val = ret * data->vref_cached / 1024;\n\t\tret = 0;\n\t\tbreak;\n\tcase hwmon_in_min:\n\tcase hwmon_in_max:\n\t\treg = (attr == hwmon_in_min)\n\t\t\t? ADT7411_REG_IN_LOW(channel)\n\t\t\t: ADT7411_REG_IN_HIGH(channel);\n\t\tret = i2c_smbus_read_byte_data(client, reg);\n\t\tif (ret < 0)\n\t\t\tgoto exit_unlock;\n\t\t*val = ret * data->vref_cached / 256;\n\t\tret = 0;\n\t\tbreak;\n\tcase hwmon_in_alarm:\n\t\tret = adt7411_read_in_alarm(dev, channel, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n exit_unlock:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic int adt7411_read_in(struct device *dev, u32 attr, int channel,\n\t\t\t   long *val)\n{\n\tif (channel == 0)\n\t\treturn adt7411_read_in_vdd(dev, attr, val);\n\telse\n\t\treturn adt7411_read_in_chan(dev, attr, channel, val);\n}\n\n\nstatic int adt7411_read_temp_alarm(struct device *dev, u32 attr, int channel,\n\t\t\t\t   long *val)\n{\n\tstruct adt7411_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret, bit;\n\n\tret = i2c_smbus_read_byte_data(client, ADT7411_REG_STAT_1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (attr) {\n\tcase hwmon_temp_min_alarm:\n\t\tbit = channel ? ADT7411_STAT_1_EXT_TEMP_LOW\n\t\t\t      : ADT7411_STAT_1_INT_TEMP_LOW;\n\t\tbreak;\n\tcase hwmon_temp_max_alarm:\n\t\tbit = channel ? ADT7411_STAT_1_EXT_TEMP_HIGH_AIN1\n\t\t\t      : ADT7411_STAT_1_INT_TEMP_HIGH;\n\t\tbreak;\n\tcase hwmon_temp_fault:\n\t\tbit = ADT7411_STAT_1_EXT_TEMP_FAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*val = !!(ret & bit);\n\treturn 0;\n}\n\nstatic int adt7411_read_temp(struct device *dev, u32 attr, int channel,\n\t\t\t     long *val)\n{\n\tstruct adt7411_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret, reg, regl, regh;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tregl = channel ? ADT7411_REG_EXT_TEMP_AIN14_LSB :\n\t\t\t\t ADT7411_REG_INT_TEMP_VDD_LSB;\n\t\tregh = channel ? ADT7411_REG_EXT_TEMP_AIN1_MSB :\n\t\t\t\t ADT7411_REG_INT_TEMP_MSB;\n\t\tret = adt7411_read_10_bit(client, regl, regh, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ret & 0x200 ? ret - 0x400 : ret;  \n\t\t*val = ret * 250;\n\t\treturn 0;\n\tcase hwmon_temp_min:\n\tcase hwmon_temp_max:\n\t\treg = (attr == hwmon_temp_min)\n\t\t\t? ADT7411_REG_TEMP_LOW(channel)\n\t\t\t: ADT7411_REG_TEMP_HIGH(channel);\n\t\tret = i2c_smbus_read_byte_data(client, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ret & 0x80 ? ret - 0x100 : ret;  \n\t\t*val = ret * 1000;\n\t\treturn 0;\n\tcase hwmon_temp_min_alarm:\n\tcase hwmon_temp_max_alarm:\n\tcase hwmon_temp_fault:\n\t\treturn adt7411_read_temp_alarm(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int adt7411_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\treturn adt7411_read_in(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn adt7411_read_temp(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int adt7411_write_in_vdd(struct device *dev, u32 attr, long val)\n{\n\tstruct adt7411_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint reg;\n\n\tval = clamp_val(val, 0, 255 * 7000 / 256);\n\tval = DIV_ROUND_CLOSEST(val * 256, 7000);\n\n\tswitch (attr) {\n\tcase hwmon_in_min:\n\t\treg = ADT7411_REG_VDD_LOW;\n\t\tbreak;\n\tcase hwmon_in_max:\n\t\treg = ADT7411_REG_VDD_HIGH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn i2c_smbus_write_byte_data(client, reg, val);\n}\n\nstatic int adt7411_write_in_chan(struct device *dev, u32 attr, int channel,\n\t\t\t\t long val)\n{\n\tstruct adt7411_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret, reg;\n\n\tmutex_lock(&data->update_lock);\n\tret = adt7411_update_vref(dev);\n\tif (ret < 0)\n\t\tgoto exit_unlock;\n\tval = clamp_val(val, 0, 255 * data->vref_cached / 256);\n\tval = DIV_ROUND_CLOSEST(val * 256, data->vref_cached);\n\n\tswitch (attr) {\n\tcase hwmon_in_min:\n\t\treg = ADT7411_REG_IN_LOW(channel);\n\t\tbreak;\n\tcase hwmon_in_max:\n\t\treg = ADT7411_REG_IN_HIGH(channel);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tgoto exit_unlock;\n\t}\n\n\tret = i2c_smbus_write_byte_data(client, reg, val);\n exit_unlock:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic int adt7411_write_in(struct device *dev, u32 attr, int channel,\n\t\t\t    long val)\n{\n\tif (channel == 0)\n\t\treturn adt7411_write_in_vdd(dev, attr, val);\n\telse\n\t\treturn adt7411_write_in_chan(dev, attr, channel, val);\n}\n\nstatic int adt7411_write_temp(struct device *dev, u32 attr, int channel,\n\t\t\t      long val)\n{\n\tstruct adt7411_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint reg;\n\n\tval = clamp_val(val, -128000, 127000);\n\tval = DIV_ROUND_CLOSEST(val, 1000);\n\n\tswitch (attr) {\n\tcase hwmon_temp_min:\n\t\treg = ADT7411_REG_TEMP_LOW(channel);\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\treg = ADT7411_REG_TEMP_HIGH(channel);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn i2c_smbus_write_byte_data(client, reg, val);\n}\n\nstatic int adt7411_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\treturn adt7411_write_in(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn adt7411_write_temp(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t adt7411_is_visible(const void *_data,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tconst struct adt7411_data *data = _data;\n\tbool visible;\n\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tvisible = channel == 0 || channel >= 3 || !data->use_ext_temp;\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\tcase hwmon_in_alarm:\n\t\t\treturn visible ? S_IRUGO : 0;\n\t\tcase hwmon_in_min:\n\t\tcase hwmon_in_max:\n\t\t\treturn visible ? S_IRUGO | S_IWUSR : 0;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tvisible = channel == 0 || data->use_ext_temp;\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_min_alarm:\n\t\tcase hwmon_temp_max_alarm:\n\t\tcase hwmon_temp_fault:\n\t\t\treturn visible ? S_IRUGO : 0;\n\t\tcase hwmon_temp_min:\n\t\tcase hwmon_temp_max:\n\t\t\treturn visible ? S_IRUGO | S_IWUSR : 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int adt7411_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tint val;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tval = i2c_smbus_read_byte_data(client, ADT7411_REG_MANUFACTURER_ID);\n\tif (val < 0 || val != ADT7411_MANUFACTURER_ID) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Wrong manufacturer ID. Got %d, expected %d\\n\",\n\t\t\tval, ADT7411_MANUFACTURER_ID);\n\t\treturn -ENODEV;\n\t}\n\n\tval = i2c_smbus_read_byte_data(client, ADT7411_REG_DEVICE_ID);\n\tif (val < 0 || val != ADT7411_DEVICE_ID) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Wrong device ID. Got %d, expected %d\\n\",\n\t\t\tval, ADT7411_DEVICE_ID);\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, \"adt7411\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int adt7411_init_device(struct adt7411_data *data)\n{\n\tint ret;\n\tu8 val;\n\n\tret = i2c_smbus_read_byte_data(data->client, ADT7411_REG_CFG3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval = ret;\n\tval &= ~(ADT7411_CFG3_RESERVED_BIT1 | ADT7411_CFG3_RESERVED_BIT2);\n\tval |= ADT7411_CFG3_RESERVED_BIT3;\n\n\tret = i2c_smbus_write_byte_data(data->client, ADT7411_REG_CFG3, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, ADT7411_REG_CFG1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->use_ext_temp = ret & ADT7411_CFG1_EXT_TDM;\n\n\t \n\tval = ret;\n\tval &= ~ADT7411_CFG1_RESERVED_BIT1;\n\tval |= ADT7411_CFG1_RESERVED_BIT3;\n\n\t \n\tval |= ADT7411_CFG1_START_MONITOR;\n\n\treturn i2c_smbus_write_byte_data(data->client, ADT7411_REG_CFG1, val);\n}\n\nstatic const struct hwmon_channel_info * const adt7411_info[] = {\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX | HWMON_I_ALARM),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MIN_ALARM |\n\t\t\t   HWMON_T_MAX | HWMON_T_MAX_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MIN_ALARM |\n\t\t\t   HWMON_T_MAX | HWMON_T_MAX_ALARM | HWMON_T_FAULT),\n\tNULL\n};\n\nstatic const struct hwmon_ops adt7411_hwmon_ops = {\n\t.is_visible = adt7411_is_visible,\n\t.read = adt7411_read,\n\t.write = adt7411_write,\n};\n\nstatic const struct hwmon_chip_info adt7411_chip_info = {\n\t.ops = &adt7411_hwmon_ops,\n\t.info = adt7411_info,\n};\n\nstatic int adt7411_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct adt7411_data *data;\n\tstruct device *hwmon_dev;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tdata->client = client;\n\tmutex_init(&data->device_lock);\n\tmutex_init(&data->update_lock);\n\n\tret = adt7411_init_device(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdata->next_update = jiffies;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &adt7411_chip_info,\n\t\t\t\t\t\t\t adt7411_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id adt7411_id[] = {\n\t{ \"adt7411\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adt7411_id);\n\nstatic struct i2c_driver adt7411_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"adt7411\",\n\t},\n\t.probe = adt7411_probe,\n\t.id_table = adt7411_id,\n\t.detect = adt7411_detect,\n\t.address_list = normal_i2c,\n\t.class = I2C_CLASS_HWMON,\n};\n\nmodule_i2c_driver(adt7411_driver);\n\nMODULE_AUTHOR(\"Sascha Hauer, Wolfram Sang <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"ADT7411 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}