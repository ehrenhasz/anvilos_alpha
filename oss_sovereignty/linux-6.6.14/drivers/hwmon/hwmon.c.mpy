{
  "module_name": "hwmon.c",
  "hash_id": "232738b3999b553da099e631e194cc6b07b1af64c18b62bc8c8dd941d0627c4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/hwmon.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gfp.h>\n#include <linux/hwmon.h>\n#include <linux/idr.h>\n#include <linux/kstrtox.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/thermal.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/hwmon.h>\n\n#define HWMON_ID_PREFIX \"hwmon\"\n#define HWMON_ID_FORMAT HWMON_ID_PREFIX \"%d\"\n\nstruct hwmon_device {\n\tconst char *name;\n\tconst char *label;\n\tstruct device dev;\n\tconst struct hwmon_chip_info *chip;\n\tstruct list_head tzdata;\n\tstruct attribute_group group;\n\tconst struct attribute_group **groups;\n};\n\n#define to_hwmon_device(d) container_of(d, struct hwmon_device, dev)\n\n#define MAX_SYSFS_ATTR_NAME_LENGTH\t32\n\nstruct hwmon_device_attribute {\n\tstruct device_attribute dev_attr;\n\tconst struct hwmon_ops *ops;\n\tenum hwmon_sensor_types type;\n\tu32 attr;\n\tint index;\n\tchar name[MAX_SYSFS_ATTR_NAME_LENGTH];\n};\n\n#define to_hwmon_attr(d) \\\n\tcontainer_of(d, struct hwmon_device_attribute, dev_attr)\n#define to_dev_attr(a) container_of(a, struct device_attribute, attr)\n\n \nstruct hwmon_thermal_data {\n\tstruct list_head node;\t\t \n\tstruct device *dev;\t\t \n\tint index;\t\t\t \n\tstruct thermal_zone_device *tzd; \n};\n\nstatic ssize_t\nname_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", to_hwmon_device(dev)->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t\nlabel_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", to_hwmon_device(dev)->label);\n}\nstatic DEVICE_ATTR_RO(label);\n\nstatic struct attribute *hwmon_dev_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_label.attr,\n\tNULL\n};\n\nstatic umode_t hwmon_dev_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct hwmon_device *hdev = to_hwmon_device(dev);\n\n\tif (attr == &dev_attr_name.attr && hdev->name == NULL)\n\t\treturn 0;\n\n\tif (attr == &dev_attr_label.attr && hdev->label == NULL)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group hwmon_dev_attr_group = {\n\t.attrs\t\t= hwmon_dev_attrs,\n\t.is_visible\t= hwmon_dev_attr_is_visible,\n};\n\nstatic const struct attribute_group *hwmon_dev_attr_groups[] = {\n\t&hwmon_dev_attr_group,\n\tNULL\n};\n\nstatic void hwmon_free_attrs(struct attribute **attrs)\n{\n\tint i;\n\n\tfor (i = 0; attrs[i]; i++) {\n\t\tstruct device_attribute *dattr = to_dev_attr(attrs[i]);\n\t\tstruct hwmon_device_attribute *hattr = to_hwmon_attr(dattr);\n\n\t\tkfree(hattr);\n\t}\n\tkfree(attrs);\n}\n\nstatic void hwmon_dev_release(struct device *dev)\n{\n\tstruct hwmon_device *hwdev = to_hwmon_device(dev);\n\n\tif (hwdev->group.attrs)\n\t\thwmon_free_attrs(hwdev->group.attrs);\n\tkfree(hwdev->groups);\n\tkfree(hwdev->label);\n\tkfree(hwdev);\n}\n\nstatic struct class hwmon_class = {\n\t.name = \"hwmon\",\n\t.dev_groups = hwmon_dev_attr_groups,\n\t.dev_release = hwmon_dev_release,\n};\n\nstatic DEFINE_IDA(hwmon_ida);\n\n \n\n \n#ifdef CONFIG_THERMAL_OF\nstatic int hwmon_thermal_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct hwmon_thermal_data *tdata = thermal_zone_device_priv(tz);\n\tstruct hwmon_device *hwdev = to_hwmon_device(tdata->dev);\n\tint ret;\n\tlong t;\n\n\tret = hwdev->chip->ops->read(tdata->dev, hwmon_temp, hwmon_temp_input,\n\t\t\t\t     tdata->index, &t);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*temp = t;\n\n\treturn 0;\n}\n\nstatic int hwmon_thermal_set_trips(struct thermal_zone_device *tz, int low, int high)\n{\n\tstruct hwmon_thermal_data *tdata = thermal_zone_device_priv(tz);\n\tstruct hwmon_device *hwdev = to_hwmon_device(tdata->dev);\n\tconst struct hwmon_chip_info *chip = hwdev->chip;\n\tconst struct hwmon_channel_info * const *info = chip->info;\n\tunsigned int i;\n\tint err;\n\n\tif (!chip->ops->write)\n\t\treturn 0;\n\n\tfor (i = 0; info[i] && info[i]->type != hwmon_temp; i++)\n\t\tcontinue;\n\n\tif (!info[i])\n\t\treturn 0;\n\n\tif (info[i]->config[tdata->index] & HWMON_T_MIN) {\n\t\terr = chip->ops->write(tdata->dev, hwmon_temp,\n\t\t\t\t       hwmon_temp_min, tdata->index, low);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t}\n\n\tif (info[i]->config[tdata->index] & HWMON_T_MAX) {\n\t\terr = chip->ops->write(tdata->dev, hwmon_temp,\n\t\t\t\t       hwmon_temp_max, tdata->index, high);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops hwmon_thermal_ops = {\n\t.get_temp = hwmon_thermal_get_temp,\n\t.set_trips = hwmon_thermal_set_trips,\n};\n\nstatic void hwmon_thermal_remove_sensor(void *data)\n{\n\tlist_del(data);\n}\n\nstatic int hwmon_thermal_add_sensor(struct device *dev, int index)\n{\n\tstruct hwmon_device *hwdev = to_hwmon_device(dev);\n\tstruct hwmon_thermal_data *tdata;\n\tstruct thermal_zone_device *tzd;\n\tint err;\n\n\ttdata = devm_kzalloc(dev, sizeof(*tdata), GFP_KERNEL);\n\tif (!tdata)\n\t\treturn -ENOMEM;\n\n\ttdata->dev = dev;\n\ttdata->index = index;\n\n\ttzd = devm_thermal_of_zone_register(dev, index, tdata,\n\t\t\t\t\t    &hwmon_thermal_ops);\n\tif (IS_ERR(tzd)) {\n\t\tif (PTR_ERR(tzd) != -ENODEV)\n\t\t\treturn PTR_ERR(tzd);\n\t\tdev_info(dev, \"temp%d_input not attached to any thermal zone\\n\",\n\t\t\t index + 1);\n\t\tdevm_kfree(dev, tdata);\n\t\treturn 0;\n\t}\n\n\terr = devm_add_action(dev, hwmon_thermal_remove_sensor, &tdata->node);\n\tif (err)\n\t\treturn err;\n\n\ttdata->tzd = tzd;\n\tlist_add(&tdata->node, &hwdev->tzdata);\n\n\treturn 0;\n}\n\nstatic int hwmon_thermal_register_sensors(struct device *dev)\n{\n\tstruct hwmon_device *hwdev = to_hwmon_device(dev);\n\tconst struct hwmon_chip_info *chip = hwdev->chip;\n\tconst struct hwmon_channel_info * const *info = chip->info;\n\tvoid *drvdata = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 1; info[i]; i++) {\n\t\tint j;\n\n\t\tif (info[i]->type != hwmon_temp)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; info[i]->config[j]; j++) {\n\t\t\tint err;\n\n\t\t\tif (!(info[i]->config[j] & HWMON_T_INPUT) ||\n\t\t\t    !chip->ops->is_visible(drvdata, hwmon_temp,\n\t\t\t\t\t\t   hwmon_temp_input, j))\n\t\t\t\tcontinue;\n\n\t\t\terr = hwmon_thermal_add_sensor(dev, j);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void hwmon_thermal_notify(struct device *dev, int index)\n{\n\tstruct hwmon_device *hwdev = to_hwmon_device(dev);\n\tstruct hwmon_thermal_data *tzdata;\n\n\tlist_for_each_entry(tzdata, &hwdev->tzdata, node) {\n\t\tif (tzdata->index == index) {\n\t\t\tthermal_zone_device_update(tzdata->tzd,\n\t\t\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\t\t}\n\t}\n}\n\n#else\nstatic int hwmon_thermal_register_sensors(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic void hwmon_thermal_notify(struct device *dev, int index) { }\n\n#endif  \n\nstatic int hwmon_attr_base(enum hwmon_sensor_types type)\n{\n\tif (type == hwmon_in || type == hwmon_intrusion)\n\t\treturn 0;\n\treturn 1;\n}\n\n \n\nstatic ssize_t hwmon_attr_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tstruct hwmon_device_attribute *hattr = to_hwmon_attr(devattr);\n\tlong val;\n\tint ret;\n\n\tret = hattr->ops->read(dev, hattr->type, hattr->attr, hattr->index,\n\t\t\t       &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttrace_hwmon_attr_show(hattr->index + hwmon_attr_base(hattr->type),\n\t\t\t      hattr->name, val);\n\n\treturn sprintf(buf, \"%ld\\n\", val);\n}\n\nstatic ssize_t hwmon_attr_show_string(struct device *dev,\n\t\t\t\t      struct device_attribute *devattr,\n\t\t\t\t      char *buf)\n{\n\tstruct hwmon_device_attribute *hattr = to_hwmon_attr(devattr);\n\tenum hwmon_sensor_types type = hattr->type;\n\tconst char *s;\n\tint ret;\n\n\tret = hattr->ops->read_string(dev, hattr->type, hattr->attr,\n\t\t\t\t      hattr->index, &s);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttrace_hwmon_attr_show_string(hattr->index + hwmon_attr_base(type),\n\t\t\t\t     hattr->name, s);\n\n\treturn sprintf(buf, \"%s\\n\", s);\n}\n\nstatic ssize_t hwmon_attr_store(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hwmon_device_attribute *hattr = to_hwmon_attr(devattr);\n\tlong val;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = hattr->ops->write(dev, hattr->type, hattr->attr, hattr->index,\n\t\t\t\tval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttrace_hwmon_attr_store(hattr->index + hwmon_attr_base(hattr->type),\n\t\t\t       hattr->name, val);\n\n\treturn count;\n}\n\nstatic bool is_string_attr(enum hwmon_sensor_types type, u32 attr)\n{\n\treturn (type == hwmon_temp && attr == hwmon_temp_label) ||\n\t       (type == hwmon_in && attr == hwmon_in_label) ||\n\t       (type == hwmon_curr && attr == hwmon_curr_label) ||\n\t       (type == hwmon_power && attr == hwmon_power_label) ||\n\t       (type == hwmon_energy && attr == hwmon_energy_label) ||\n\t       (type == hwmon_humidity && attr == hwmon_humidity_label) ||\n\t       (type == hwmon_fan && attr == hwmon_fan_label);\n}\n\nstatic struct attribute *hwmon_genattr(const void *drvdata,\n\t\t\t\t       enum hwmon_sensor_types type,\n\t\t\t\t       u32 attr,\n\t\t\t\t       int index,\n\t\t\t\t       const char *template,\n\t\t\t\t       const struct hwmon_ops *ops)\n{\n\tstruct hwmon_device_attribute *hattr;\n\tstruct device_attribute *dattr;\n\tstruct attribute *a;\n\tumode_t mode;\n\tconst char *name;\n\tbool is_string = is_string_attr(type, attr);\n\n\t \n\tif (!template)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tmode = ops->is_visible(drvdata, type, attr, index);\n\tif (!mode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif ((mode & 0444) && ((is_string && !ops->read_string) ||\n\t\t\t\t (!is_string && !ops->read)))\n\t\treturn ERR_PTR(-EINVAL);\n\tif ((mode & 0222) && !ops->write)\n\t\treturn ERR_PTR(-EINVAL);\n\n\thattr = kzalloc(sizeof(*hattr), GFP_KERNEL);\n\tif (!hattr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (type == hwmon_chip) {\n\t\tname = template;\n\t} else {\n\t\tscnprintf(hattr->name, sizeof(hattr->name), template,\n\t\t\t  index + hwmon_attr_base(type));\n\t\tname = hattr->name;\n\t}\n\n\thattr->type = type;\n\thattr->attr = attr;\n\thattr->index = index;\n\thattr->ops = ops;\n\n\tdattr = &hattr->dev_attr;\n\tdattr->show = is_string ? hwmon_attr_show_string : hwmon_attr_show;\n\tdattr->store = hwmon_attr_store;\n\n\ta = &dattr->attr;\n\tsysfs_attr_init(a);\n\ta->name = name;\n\ta->mode = mode;\n\n\treturn a;\n}\n\n \nstatic const char * const hwmon_chip_attrs[] = {\n\t[hwmon_chip_temp_reset_history] = \"temp_reset_history\",\n\t[hwmon_chip_in_reset_history] = \"in_reset_history\",\n\t[hwmon_chip_curr_reset_history] = \"curr_reset_history\",\n\t[hwmon_chip_power_reset_history] = \"power_reset_history\",\n\t[hwmon_chip_update_interval] = \"update_interval\",\n\t[hwmon_chip_alarms] = \"alarms\",\n\t[hwmon_chip_samples] = \"samples\",\n\t[hwmon_chip_curr_samples] = \"curr_samples\",\n\t[hwmon_chip_in_samples] = \"in_samples\",\n\t[hwmon_chip_power_samples] = \"power_samples\",\n\t[hwmon_chip_temp_samples] = \"temp_samples\",\n\t[hwmon_chip_beep_enable] = \"beep_enable\",\n};\n\nstatic const char * const hwmon_temp_attr_templates[] = {\n\t[hwmon_temp_enable] = \"temp%d_enable\",\n\t[hwmon_temp_input] = \"temp%d_input\",\n\t[hwmon_temp_type] = \"temp%d_type\",\n\t[hwmon_temp_lcrit] = \"temp%d_lcrit\",\n\t[hwmon_temp_lcrit_hyst] = \"temp%d_lcrit_hyst\",\n\t[hwmon_temp_min] = \"temp%d_min\",\n\t[hwmon_temp_min_hyst] = \"temp%d_min_hyst\",\n\t[hwmon_temp_max] = \"temp%d_max\",\n\t[hwmon_temp_max_hyst] = \"temp%d_max_hyst\",\n\t[hwmon_temp_crit] = \"temp%d_crit\",\n\t[hwmon_temp_crit_hyst] = \"temp%d_crit_hyst\",\n\t[hwmon_temp_emergency] = \"temp%d_emergency\",\n\t[hwmon_temp_emergency_hyst] = \"temp%d_emergency_hyst\",\n\t[hwmon_temp_alarm] = \"temp%d_alarm\",\n\t[hwmon_temp_lcrit_alarm] = \"temp%d_lcrit_alarm\",\n\t[hwmon_temp_min_alarm] = \"temp%d_min_alarm\",\n\t[hwmon_temp_max_alarm] = \"temp%d_max_alarm\",\n\t[hwmon_temp_crit_alarm] = \"temp%d_crit_alarm\",\n\t[hwmon_temp_emergency_alarm] = \"temp%d_emergency_alarm\",\n\t[hwmon_temp_fault] = \"temp%d_fault\",\n\t[hwmon_temp_offset] = \"temp%d_offset\",\n\t[hwmon_temp_label] = \"temp%d_label\",\n\t[hwmon_temp_lowest] = \"temp%d_lowest\",\n\t[hwmon_temp_highest] = \"temp%d_highest\",\n\t[hwmon_temp_reset_history] = \"temp%d_reset_history\",\n\t[hwmon_temp_rated_min] = \"temp%d_rated_min\",\n\t[hwmon_temp_rated_max] = \"temp%d_rated_max\",\n\t[hwmon_temp_beep] = \"temp%d_beep\",\n};\n\nstatic const char * const hwmon_in_attr_templates[] = {\n\t[hwmon_in_enable] = \"in%d_enable\",\n\t[hwmon_in_input] = \"in%d_input\",\n\t[hwmon_in_min] = \"in%d_min\",\n\t[hwmon_in_max] = \"in%d_max\",\n\t[hwmon_in_lcrit] = \"in%d_lcrit\",\n\t[hwmon_in_crit] = \"in%d_crit\",\n\t[hwmon_in_average] = \"in%d_average\",\n\t[hwmon_in_lowest] = \"in%d_lowest\",\n\t[hwmon_in_highest] = \"in%d_highest\",\n\t[hwmon_in_reset_history] = \"in%d_reset_history\",\n\t[hwmon_in_label] = \"in%d_label\",\n\t[hwmon_in_alarm] = \"in%d_alarm\",\n\t[hwmon_in_min_alarm] = \"in%d_min_alarm\",\n\t[hwmon_in_max_alarm] = \"in%d_max_alarm\",\n\t[hwmon_in_lcrit_alarm] = \"in%d_lcrit_alarm\",\n\t[hwmon_in_crit_alarm] = \"in%d_crit_alarm\",\n\t[hwmon_in_rated_min] = \"in%d_rated_min\",\n\t[hwmon_in_rated_max] = \"in%d_rated_max\",\n\t[hwmon_in_beep] = \"in%d_beep\",\n};\n\nstatic const char * const hwmon_curr_attr_templates[] = {\n\t[hwmon_curr_enable] = \"curr%d_enable\",\n\t[hwmon_curr_input] = \"curr%d_input\",\n\t[hwmon_curr_min] = \"curr%d_min\",\n\t[hwmon_curr_max] = \"curr%d_max\",\n\t[hwmon_curr_lcrit] = \"curr%d_lcrit\",\n\t[hwmon_curr_crit] = \"curr%d_crit\",\n\t[hwmon_curr_average] = \"curr%d_average\",\n\t[hwmon_curr_lowest] = \"curr%d_lowest\",\n\t[hwmon_curr_highest] = \"curr%d_highest\",\n\t[hwmon_curr_reset_history] = \"curr%d_reset_history\",\n\t[hwmon_curr_label] = \"curr%d_label\",\n\t[hwmon_curr_alarm] = \"curr%d_alarm\",\n\t[hwmon_curr_min_alarm] = \"curr%d_min_alarm\",\n\t[hwmon_curr_max_alarm] = \"curr%d_max_alarm\",\n\t[hwmon_curr_lcrit_alarm] = \"curr%d_lcrit_alarm\",\n\t[hwmon_curr_crit_alarm] = \"curr%d_crit_alarm\",\n\t[hwmon_curr_rated_min] = \"curr%d_rated_min\",\n\t[hwmon_curr_rated_max] = \"curr%d_rated_max\",\n\t[hwmon_curr_beep] = \"curr%d_beep\",\n};\n\nstatic const char * const hwmon_power_attr_templates[] = {\n\t[hwmon_power_enable] = \"power%d_enable\",\n\t[hwmon_power_average] = \"power%d_average\",\n\t[hwmon_power_average_interval] = \"power%d_average_interval\",\n\t[hwmon_power_average_interval_max] = \"power%d_interval_max\",\n\t[hwmon_power_average_interval_min] = \"power%d_interval_min\",\n\t[hwmon_power_average_highest] = \"power%d_average_highest\",\n\t[hwmon_power_average_lowest] = \"power%d_average_lowest\",\n\t[hwmon_power_average_max] = \"power%d_average_max\",\n\t[hwmon_power_average_min] = \"power%d_average_min\",\n\t[hwmon_power_input] = \"power%d_input\",\n\t[hwmon_power_input_highest] = \"power%d_input_highest\",\n\t[hwmon_power_input_lowest] = \"power%d_input_lowest\",\n\t[hwmon_power_reset_history] = \"power%d_reset_history\",\n\t[hwmon_power_accuracy] = \"power%d_accuracy\",\n\t[hwmon_power_cap] = \"power%d_cap\",\n\t[hwmon_power_cap_hyst] = \"power%d_cap_hyst\",\n\t[hwmon_power_cap_max] = \"power%d_cap_max\",\n\t[hwmon_power_cap_min] = \"power%d_cap_min\",\n\t[hwmon_power_min] = \"power%d_min\",\n\t[hwmon_power_max] = \"power%d_max\",\n\t[hwmon_power_lcrit] = \"power%d_lcrit\",\n\t[hwmon_power_crit] = \"power%d_crit\",\n\t[hwmon_power_label] = \"power%d_label\",\n\t[hwmon_power_alarm] = \"power%d_alarm\",\n\t[hwmon_power_cap_alarm] = \"power%d_cap_alarm\",\n\t[hwmon_power_min_alarm] = \"power%d_min_alarm\",\n\t[hwmon_power_max_alarm] = \"power%d_max_alarm\",\n\t[hwmon_power_lcrit_alarm] = \"power%d_lcrit_alarm\",\n\t[hwmon_power_crit_alarm] = \"power%d_crit_alarm\",\n\t[hwmon_power_rated_min] = \"power%d_rated_min\",\n\t[hwmon_power_rated_max] = \"power%d_rated_max\",\n};\n\nstatic const char * const hwmon_energy_attr_templates[] = {\n\t[hwmon_energy_enable] = \"energy%d_enable\",\n\t[hwmon_energy_input] = \"energy%d_input\",\n\t[hwmon_energy_label] = \"energy%d_label\",\n};\n\nstatic const char * const hwmon_humidity_attr_templates[] = {\n\t[hwmon_humidity_enable] = \"humidity%d_enable\",\n\t[hwmon_humidity_input] = \"humidity%d_input\",\n\t[hwmon_humidity_label] = \"humidity%d_label\",\n\t[hwmon_humidity_min] = \"humidity%d_min\",\n\t[hwmon_humidity_min_hyst] = \"humidity%d_min_hyst\",\n\t[hwmon_humidity_max] = \"humidity%d_max\",\n\t[hwmon_humidity_max_hyst] = \"humidity%d_max_hyst\",\n\t[hwmon_humidity_alarm] = \"humidity%d_alarm\",\n\t[hwmon_humidity_fault] = \"humidity%d_fault\",\n\t[hwmon_humidity_rated_min] = \"humidity%d_rated_min\",\n\t[hwmon_humidity_rated_max] = \"humidity%d_rated_max\",\n};\n\nstatic const char * const hwmon_fan_attr_templates[] = {\n\t[hwmon_fan_enable] = \"fan%d_enable\",\n\t[hwmon_fan_input] = \"fan%d_input\",\n\t[hwmon_fan_label] = \"fan%d_label\",\n\t[hwmon_fan_min] = \"fan%d_min\",\n\t[hwmon_fan_max] = \"fan%d_max\",\n\t[hwmon_fan_div] = \"fan%d_div\",\n\t[hwmon_fan_pulses] = \"fan%d_pulses\",\n\t[hwmon_fan_target] = \"fan%d_target\",\n\t[hwmon_fan_alarm] = \"fan%d_alarm\",\n\t[hwmon_fan_min_alarm] = \"fan%d_min_alarm\",\n\t[hwmon_fan_max_alarm] = \"fan%d_max_alarm\",\n\t[hwmon_fan_fault] = \"fan%d_fault\",\n\t[hwmon_fan_beep] = \"fan%d_beep\",\n};\n\nstatic const char * const hwmon_pwm_attr_templates[] = {\n\t[hwmon_pwm_input] = \"pwm%d\",\n\t[hwmon_pwm_enable] = \"pwm%d_enable\",\n\t[hwmon_pwm_mode] = \"pwm%d_mode\",\n\t[hwmon_pwm_freq] = \"pwm%d_freq\",\n\t[hwmon_pwm_auto_channels_temp] = \"pwm%d_auto_channels_temp\",\n};\n\nstatic const char * const hwmon_intrusion_attr_templates[] = {\n\t[hwmon_intrusion_alarm] = \"intrusion%d_alarm\",\n\t[hwmon_intrusion_beep]  = \"intrusion%d_beep\",\n};\n\nstatic const char * const *__templates[] = {\n\t[hwmon_chip] = hwmon_chip_attrs,\n\t[hwmon_temp] = hwmon_temp_attr_templates,\n\t[hwmon_in] = hwmon_in_attr_templates,\n\t[hwmon_curr] = hwmon_curr_attr_templates,\n\t[hwmon_power] = hwmon_power_attr_templates,\n\t[hwmon_energy] = hwmon_energy_attr_templates,\n\t[hwmon_humidity] = hwmon_humidity_attr_templates,\n\t[hwmon_fan] = hwmon_fan_attr_templates,\n\t[hwmon_pwm] = hwmon_pwm_attr_templates,\n\t[hwmon_intrusion] = hwmon_intrusion_attr_templates,\n};\n\nstatic const int __templates_size[] = {\n\t[hwmon_chip] = ARRAY_SIZE(hwmon_chip_attrs),\n\t[hwmon_temp] = ARRAY_SIZE(hwmon_temp_attr_templates),\n\t[hwmon_in] = ARRAY_SIZE(hwmon_in_attr_templates),\n\t[hwmon_curr] = ARRAY_SIZE(hwmon_curr_attr_templates),\n\t[hwmon_power] = ARRAY_SIZE(hwmon_power_attr_templates),\n\t[hwmon_energy] = ARRAY_SIZE(hwmon_energy_attr_templates),\n\t[hwmon_humidity] = ARRAY_SIZE(hwmon_humidity_attr_templates),\n\t[hwmon_fan] = ARRAY_SIZE(hwmon_fan_attr_templates),\n\t[hwmon_pwm] = ARRAY_SIZE(hwmon_pwm_attr_templates),\n\t[hwmon_intrusion] = ARRAY_SIZE(hwmon_intrusion_attr_templates),\n};\n\nint hwmon_notify_event(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel)\n{\n\tchar event[MAX_SYSFS_ATTR_NAME_LENGTH + 5];\n\tchar sattr[MAX_SYSFS_ATTR_NAME_LENGTH];\n\tchar *envp[] = { event, NULL };\n\tconst char * const *templates;\n\tconst char *template;\n\tint base;\n\n\tif (type >= ARRAY_SIZE(__templates))\n\t\treturn -EINVAL;\n\tif (attr >= __templates_size[type])\n\t\treturn -EINVAL;\n\n\ttemplates = __templates[type];\n\ttemplate = templates[attr];\n\n\tbase = hwmon_attr_base(type);\n\n\tscnprintf(sattr, MAX_SYSFS_ATTR_NAME_LENGTH, template, base + channel);\n\tscnprintf(event, sizeof(event), \"NAME=%s\", sattr);\n\tsysfs_notify(&dev->kobj, NULL, sattr);\n\tkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);\n\n\tif (type == hwmon_temp)\n\t\thwmon_thermal_notify(dev, channel);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hwmon_notify_event);\n\nstatic int hwmon_num_channel_attrs(const struct hwmon_channel_info *info)\n{\n\tint i, n;\n\n\tfor (i = n = 0; info->config[i]; i++)\n\t\tn += hweight32(info->config[i]);\n\n\treturn n;\n}\n\nstatic int hwmon_genattrs(const void *drvdata,\n\t\t\t  struct attribute **attrs,\n\t\t\t  const struct hwmon_ops *ops,\n\t\t\t  const struct hwmon_channel_info *info)\n{\n\tconst char * const *templates;\n\tint template_size;\n\tint i, aindex = 0;\n\n\tif (info->type >= ARRAY_SIZE(__templates))\n\t\treturn -EINVAL;\n\n\ttemplates = __templates[info->type];\n\ttemplate_size = __templates_size[info->type];\n\n\tfor (i = 0; info->config[i]; i++) {\n\t\tu32 attr_mask = info->config[i];\n\t\tu32 attr;\n\n\t\twhile (attr_mask) {\n\t\t\tstruct attribute *a;\n\n\t\t\tattr = __ffs(attr_mask);\n\t\t\tattr_mask &= ~BIT(attr);\n\t\t\tif (attr >= template_size)\n\t\t\t\treturn -EINVAL;\n\t\t\ta = hwmon_genattr(drvdata, info->type, attr, i,\n\t\t\t\t\t  templates[attr], ops);\n\t\t\tif (IS_ERR(a)) {\n\t\t\t\tif (PTR_ERR(a) != -ENOENT)\n\t\t\t\t\treturn PTR_ERR(a);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tattrs[aindex++] = a;\n\t\t}\n\t}\n\treturn aindex;\n}\n\nstatic struct attribute **\n__hwmon_create_attrs(const void *drvdata, const struct hwmon_chip_info *chip)\n{\n\tint ret, i, aindex = 0, nattrs = 0;\n\tstruct attribute **attrs;\n\n\tfor (i = 0; chip->info[i]; i++)\n\t\tnattrs += hwmon_num_channel_attrs(chip->info[i]);\n\n\tif (nattrs == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tattrs = kcalloc(nattrs + 1, sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; chip->info[i]; i++) {\n\t\tret = hwmon_genattrs(drvdata, &attrs[aindex], chip->ops,\n\t\t\t\t     chip->info[i]);\n\t\tif (ret < 0) {\n\t\t\thwmon_free_attrs(attrs);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t\taindex += ret;\n\t}\n\n\treturn attrs;\n}\n\nstatic struct device *\n__hwmon_device_register(struct device *dev, const char *name, void *drvdata,\n\t\t\tconst struct hwmon_chip_info *chip,\n\t\t\tconst struct attribute_group **groups)\n{\n\tstruct hwmon_device *hwdev;\n\tconst char *label;\n\tstruct device *hdev;\n\tstruct device *tdev = dev;\n\tint i, err, id;\n\n\t \n\tif (name && (!strlen(name) || strpbrk(name, \"-* \\t\\n\")))\n\t\tdev_warn(dev,\n\t\t\t \"hwmon: '%s' is not a valid name attribute, please fix\\n\",\n\t\t\t name);\n\n\tid = ida_alloc(&hwmon_ida, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn ERR_PTR(id);\n\n\thwdev = kzalloc(sizeof(*hwdev), GFP_KERNEL);\n\tif (hwdev == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto ida_remove;\n\t}\n\n\thdev = &hwdev->dev;\n\n\tif (chip) {\n\t\tstruct attribute **attrs;\n\t\tint ngroups = 2;  \n\n\t\tif (groups)\n\t\t\tfor (i = 0; groups[i]; i++)\n\t\t\t\tngroups++;\n\n\t\thwdev->groups = kcalloc(ngroups, sizeof(*groups), GFP_KERNEL);\n\t\tif (!hwdev->groups) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_hwmon;\n\t\t}\n\n\t\tattrs = __hwmon_create_attrs(drvdata, chip);\n\t\tif (IS_ERR(attrs)) {\n\t\t\terr = PTR_ERR(attrs);\n\t\t\tgoto free_hwmon;\n\t\t}\n\n\t\thwdev->group.attrs = attrs;\n\t\tngroups = 0;\n\t\thwdev->groups[ngroups++] = &hwdev->group;\n\n\t\tif (groups) {\n\t\t\tfor (i = 0; groups[i]; i++)\n\t\t\t\thwdev->groups[ngroups++] = groups[i];\n\t\t}\n\n\t\thdev->groups = hwdev->groups;\n\t} else {\n\t\thdev->groups = groups;\n\t}\n\n\tif (dev && device_property_present(dev, \"label\")) {\n\t\terr = device_property_read_string(dev, \"label\", &label);\n\t\tif (err < 0)\n\t\t\tgoto free_hwmon;\n\n\t\thwdev->label = kstrdup(label, GFP_KERNEL);\n\t\tif (hwdev->label == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_hwmon;\n\t\t}\n\t}\n\n\thwdev->name = name;\n\thdev->class = &hwmon_class;\n\thdev->parent = dev;\n\twhile (tdev && !tdev->of_node)\n\t\ttdev = tdev->parent;\n\thdev->of_node = tdev ? tdev->of_node : NULL;\n\thwdev->chip = chip;\n\tdev_set_drvdata(hdev, drvdata);\n\tdev_set_name(hdev, HWMON_ID_FORMAT, id);\n\terr = device_register(hdev);\n\tif (err) {\n\t\tput_device(hdev);\n\t\tgoto ida_remove;\n\t}\n\n\tINIT_LIST_HEAD(&hwdev->tzdata);\n\n\tif (hdev->of_node && chip && chip->ops->read &&\n\t    chip->info[0]->type == hwmon_chip &&\n\t    (chip->info[0]->config[0] & HWMON_C_REGISTER_TZ)) {\n\t\terr = hwmon_thermal_register_sensors(hdev);\n\t\tif (err) {\n\t\t\tdevice_unregister(hdev);\n\t\t\t \n\t\t\tgoto ida_remove;\n\t\t}\n\t}\n\n\treturn hdev;\n\nfree_hwmon:\n\thwmon_dev_release(hdev);\nida_remove:\n\tida_free(&hwmon_ida, id);\n\treturn ERR_PTR(err);\n}\n\n \nstruct device *\nhwmon_device_register_with_groups(struct device *dev, const char *name,\n\t\t\t\t  void *drvdata,\n\t\t\t\t  const struct attribute_group **groups)\n{\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn __hwmon_device_register(dev, name, drvdata, NULL, groups);\n}\nEXPORT_SYMBOL_GPL(hwmon_device_register_with_groups);\n\n \nstruct device *\nhwmon_device_register_with_info(struct device *dev, const char *name,\n\t\t\t\tvoid *drvdata,\n\t\t\t\tconst struct hwmon_chip_info *chip,\n\t\t\t\tconst struct attribute_group **extra_groups)\n{\n\tif (!dev || !name || !chip)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!chip->ops || !chip->ops->is_visible || !chip->info)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn __hwmon_device_register(dev, name, drvdata, chip, extra_groups);\n}\nEXPORT_SYMBOL_GPL(hwmon_device_register_with_info);\n\n \nstruct device *\nhwmon_device_register_for_thermal(struct device *dev, const char *name,\n\t\t\t\t  void *drvdata)\n{\n\tif (!name || !dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn __hwmon_device_register(dev, name, drvdata, NULL, NULL);\n}\nEXPORT_SYMBOL_NS_GPL(hwmon_device_register_for_thermal, HWMON_THERMAL);\n\n \nstruct device *hwmon_device_register(struct device *dev)\n{\n\tdev_warn(dev,\n\t\t \"hwmon_device_register() is deprecated. Please convert the driver to use hwmon_device_register_with_info().\\n\");\n\n\treturn __hwmon_device_register(dev, NULL, NULL, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(hwmon_device_register);\n\n \nvoid hwmon_device_unregister(struct device *dev)\n{\n\tint id;\n\n\tif (likely(sscanf(dev_name(dev), HWMON_ID_FORMAT, &id) == 1)) {\n\t\tdevice_unregister(dev);\n\t\tida_free(&hwmon_ida, id);\n\t} else\n\t\tdev_dbg(dev->parent,\n\t\t\t\"hwmon_device_unregister() failed: bad class ID!\\n\");\n}\nEXPORT_SYMBOL_GPL(hwmon_device_unregister);\n\nstatic void devm_hwmon_release(struct device *dev, void *res)\n{\n\tstruct device *hwdev = *(struct device **)res;\n\n\thwmon_device_unregister(hwdev);\n}\n\n \nstruct device *\ndevm_hwmon_device_register_with_groups(struct device *dev, const char *name,\n\t\t\t\t       void *drvdata,\n\t\t\t\t       const struct attribute_group **groups)\n{\n\tstruct device **ptr, *hwdev;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tptr = devres_alloc(devm_hwmon_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thwdev = hwmon_device_register_with_groups(dev, name, drvdata, groups);\n\tif (IS_ERR(hwdev))\n\t\tgoto error;\n\n\t*ptr = hwdev;\n\tdevres_add(dev, ptr);\n\treturn hwdev;\n\nerror:\n\tdevres_free(ptr);\n\treturn hwdev;\n}\nEXPORT_SYMBOL_GPL(devm_hwmon_device_register_with_groups);\n\n \nstruct device *\ndevm_hwmon_device_register_with_info(struct device *dev, const char *name,\n\t\t\t\t     void *drvdata,\n\t\t\t\t     const struct hwmon_chip_info *chip,\n\t\t\t\t     const struct attribute_group **extra_groups)\n{\n\tstruct device **ptr, *hwdev;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tptr = devres_alloc(devm_hwmon_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thwdev = hwmon_device_register_with_info(dev, name, drvdata, chip,\n\t\t\t\t\t\textra_groups);\n\tif (IS_ERR(hwdev))\n\t\tgoto error;\n\n\t*ptr = hwdev;\n\tdevres_add(dev, ptr);\n\n\treturn hwdev;\n\nerror:\n\tdevres_free(ptr);\n\treturn hwdev;\n}\nEXPORT_SYMBOL_GPL(devm_hwmon_device_register_with_info);\n\nstatic int devm_hwmon_match(struct device *dev, void *res, void *data)\n{\n\tstruct device **hwdev = res;\n\n\treturn *hwdev == data;\n}\n\n \nvoid devm_hwmon_device_unregister(struct device *dev)\n{\n\tWARN_ON(devres_release(dev, devm_hwmon_release, devm_hwmon_match, dev));\n}\nEXPORT_SYMBOL_GPL(devm_hwmon_device_unregister);\n\nstatic char *__hwmon_sanitize_name(struct device *dev, const char *old_name)\n{\n\tchar *name, *p;\n\n\tif (dev)\n\t\tname = devm_kstrdup(dev, old_name, GFP_KERNEL);\n\telse\n\t\tname = kstrdup(old_name, GFP_KERNEL);\n\tif (!name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (p = name; *p; p++)\n\t\tif (hwmon_is_bad_char(*p))\n\t\t\t*p = '_';\n\n\treturn name;\n}\n\n \nchar *hwmon_sanitize_name(const char *name)\n{\n\treturn __hwmon_sanitize_name(NULL, name);\n}\nEXPORT_SYMBOL_GPL(hwmon_sanitize_name);\n\n \nchar *devm_hwmon_sanitize_name(struct device *dev, const char *name)\n{\n\tif (!dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn __hwmon_sanitize_name(dev, name);\n}\nEXPORT_SYMBOL_GPL(devm_hwmon_sanitize_name);\n\nstatic void __init hwmon_pci_quirks(void)\n{\n#if defined CONFIG_X86 && defined CONFIG_PCI\n\tstruct pci_dev *sb;\n\tu16 base;\n\tu8 enable;\n\n\t \n\tsb = pci_get_device(PCI_VENDOR_ID_ATI, 0x436c, NULL);\n\tif (sb) {\n\t\tif (sb->subsystem_vendor == 0x1462 &&\t \n\t\t    sb->subsystem_device == 0x0031) {\t \n\t\t\tpci_read_config_byte(sb, 0x48, &enable);\n\t\t\tpci_read_config_word(sb, 0x64, &base);\n\n\t\t\tif (base == 0 && !(enable & BIT(2))) {\n\t\t\t\tdev_info(&sb->dev,\n\t\t\t\t\t \"Opening wide generic port at 0x295\\n\");\n\t\t\t\tpci_write_config_word(sb, 0x64, 0x295);\n\t\t\t\tpci_write_config_byte(sb, 0x48,\n\t\t\t\t\t\t      enable | BIT(2));\n\t\t\t}\n\t\t}\n\t\tpci_dev_put(sb);\n\t}\n#endif\n}\n\nstatic int __init hwmon_init(void)\n{\n\tint err;\n\n\thwmon_pci_quirks();\n\n\terr = class_register(&hwmon_class);\n\tif (err) {\n\t\tpr_err(\"couldn't register hwmon sysfs class\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void __exit hwmon_exit(void)\n{\n\tclass_unregister(&hwmon_class);\n}\n\nsubsys_initcall(hwmon_init);\nmodule_exit(hwmon_exit);\n\nMODULE_AUTHOR(\"Mark M. Hoffman <mhoffman@lightlink.com>\");\nMODULE_DESCRIPTION(\"hardware monitoring sysfs/class support\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}