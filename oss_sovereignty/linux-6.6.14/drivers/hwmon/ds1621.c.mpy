{
  "module_name": "ds1621.c",
  "hash_id": "dcbfd72df313f7a186edea9c73be8dd0bf87e7c270e951c69333c6d365611d40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ds1621.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/kernel.h>\n\n \nenum chips { ds1621, ds1625, ds1631, ds1721, ds1731 };\n\n \nstatic int polarity = -1;\nmodule_param(polarity, int, 0);\nMODULE_PARM_DESC(polarity, \"Output's polarity: 0 = active high, 1 = active low\");\n\n \n#define DS1621_REG_CONFIG_NVB\t\t0x10\n#define DS1621_REG_CONFIG_RESOL\t\t0x0C\n#define DS1621_REG_CONFIG_POLARITY\t0x02\n#define DS1621_REG_CONFIG_1SHOT\t\t0x01\n#define DS1621_REG_CONFIG_DONE\t\t0x80\n\n#define DS1621_REG_CONFIG_RESOL_SHIFT\t2\n\n \nstatic const unsigned short ds1721_convrates[] = {\n\t94,\t \n\t188,\t \n\t375,\t \n\t750,\t \n};\n\n#define DS1621_CONVERSION_MAX\t750\n#define DS1625_CONVERSION_MAX\t500\n\n#define DS1621_TEMP_MAX\t125000\n#define DS1621_TEMP_MIN\t(-55000)\n\n \nstatic const u8 DS1621_REG_TEMP[3] = {\n\t0xAA,\t\t \n\t0xA2,\t\t \n\t0xA1,\t\t \n};\n#define DS1621_REG_CONF\t\t\t0xAC  \n#define DS1621_COM_START\t\t0xEE  \n#define DS1721_COM_START\t\t0x51  \n#define DS1621_COM_STOP\t\t\t0x22  \n\n \n#define DS1621_ALARM_TEMP_HIGH\t\t0x40\n#define DS1621_ALARM_TEMP_LOW\t\t0x20\n\n \n#define ALARMS_FROM_REG(val) ((val) & \\\n\t\t\t(DS1621_ALARM_TEMP_HIGH | DS1621_ALARM_TEMP_LOW))\n\n \nstruct ds1621_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tbool valid;\t\t\t \n\tunsigned long last_updated;\t \n\tenum chips kind;\t\t \n\n\tu16 temp[3];\t\t\t \n\tu8 conf;\t\t\t \n\tu8 zbits;\t\t\t \n\tu16 update_interval;\t\t \n};\n\nstatic inline int DS1621_TEMP_FROM_REG(u16 reg)\n{\n\treturn DIV_ROUND_CLOSEST(((s16)reg / 16) * 625, 10);\n}\n\n \nstatic inline u16 DS1621_TEMP_TO_REG(long temp, u8 zbits)\n{\n\ttemp = clamp_val(temp, DS1621_TEMP_MIN, DS1621_TEMP_MAX);\n\ttemp = DIV_ROUND_CLOSEST(temp * (1 << (8 - zbits)), 1000) << zbits;\n\treturn temp;\n}\n\nstatic void ds1621_init_client(struct ds1621_data *data,\n\t\t\t       struct i2c_client *client)\n{\n\tu8 conf, new_conf, sreg, resol;\n\n\tnew_conf = conf = i2c_smbus_read_byte_data(client, DS1621_REG_CONF);\n\t \n\tnew_conf &= ~DS1621_REG_CONFIG_1SHOT;\n\n\t \n\tif (polarity == 0)\n\t\tnew_conf &= ~DS1621_REG_CONFIG_POLARITY;\n\telse if (polarity == 1)\n\t\tnew_conf |= DS1621_REG_CONFIG_POLARITY;\n\n\tif (conf != new_conf)\n\t\ti2c_smbus_write_byte_data(client, DS1621_REG_CONF, new_conf);\n\n\tswitch (data->kind) {\n\tcase ds1625:\n\t\tdata->update_interval = DS1625_CONVERSION_MAX;\n\t\tdata->zbits = 7;\n\t\tsreg = DS1621_COM_START;\n\t\tbreak;\n\tcase ds1631:\n\tcase ds1721:\n\tcase ds1731:\n\t\tresol = (new_conf & DS1621_REG_CONFIG_RESOL) >>\n\t\t\t DS1621_REG_CONFIG_RESOL_SHIFT;\n\t\tdata->update_interval = ds1721_convrates[resol];\n\t\tdata->zbits = 7 - resol;\n\t\tsreg = DS1721_COM_START;\n\t\tbreak;\n\tdefault:\n\t\tdata->update_interval = DS1621_CONVERSION_MAX;\n\t\tdata->zbits = 7;\n\t\tsreg = DS1621_COM_START;\n\t\tbreak;\n\t}\n\n\t \n\ti2c_smbus_write_byte(client, sreg);\n}\n\nstatic struct ds1621_data *ds1621_update_client(struct device *dev)\n{\n\tstruct ds1621_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tu8 new_conf;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + data->update_interval) ||\n\t    !data->valid) {\n\t\tint i;\n\n\t\tdev_dbg(&client->dev, \"Starting ds1621 update\\n\");\n\n\t\tdata->conf = i2c_smbus_read_byte_data(client, DS1621_REG_CONF);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(data->temp); i++)\n\t\t\tdata->temp[i] = i2c_smbus_read_word_swapped(client,\n\t\t\t\t\t\t\t DS1621_REG_TEMP[i]);\n\n\t\t \n\t\tnew_conf = data->conf;\n\t\tif (data->temp[0] > data->temp[1])\t \n\t\t\tnew_conf &= ~DS1621_ALARM_TEMP_LOW;\n\t\tif (data->temp[0] < data->temp[2])\t \n\t\t\tnew_conf &= ~DS1621_ALARM_TEMP_HIGH;\n\t\tif (data->conf != new_conf)\n\t\t\ti2c_smbus_write_byte_data(client, DS1621_REG_CONF,\n\t\t\t\t\t\t  new_conf);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *da,\n\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ds1621_data *data = ds1621_update_client(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       DS1621_TEMP_FROM_REG(data->temp[attr->index]));\n}\n\nstatic ssize_t temp_store(struct device *dev, struct device_attribute *da,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ds1621_data *data = dev_get_drvdata(dev);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp[attr->index] = DS1621_TEMP_TO_REG(val, data->zbits);\n\ti2c_smbus_write_word_swapped(data->client, DS1621_REG_TEMP[attr->index],\n\t\t\t\t     data->temp[attr->index]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *da,\n\t\t\t   char *buf)\n{\n\tstruct ds1621_data *data = ds1621_update_client(dev);\n\treturn sprintf(buf, \"%d\\n\", ALARMS_FROM_REG(data->conf));\n}\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *da,\n\t\t\t  char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct ds1621_data *data = ds1621_update_client(dev);\n\treturn sprintf(buf, \"%d\\n\", !!(data->conf & attr->index));\n}\n\nstatic ssize_t update_interval_show(struct device *dev,\n\t\t\t\t    struct device_attribute *da, char *buf)\n{\n\tstruct ds1621_data *data = dev_get_drvdata(dev);\n\treturn sysfs_emit(buf, \"%hu\\n\", data->update_interval);\n}\n\nstatic ssize_t update_interval_store(struct device *dev,\n\t\t\t\t     struct device_attribute *da,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ds1621_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long convrate;\n\ts32 err;\n\tint resol = 0;\n\n\terr = kstrtoul(buf, 10, &convrate);\n\tif (err)\n\t\treturn err;\n\n\t \n\twhile (resol < (ARRAY_SIZE(ds1721_convrates) - 1) &&\n\t       convrate > ds1721_convrates[resol])\n\t\tresol++;\n\n\tmutex_lock(&data->update_lock);\n\tdata->conf = i2c_smbus_read_byte_data(client, DS1621_REG_CONF);\n\tdata->conf &= ~DS1621_REG_CONFIG_RESOL;\n\tdata->conf |= (resol << DS1621_REG_CONFIG_RESOL_SHIFT);\n\ti2c_smbus_write_byte_data(client, DS1621_REG_CONF, data->conf);\n\tdata->update_interval = ds1721_convrates[resol];\n\tdata->zbits = 7 - resol;\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RO(alarms);\nstatic DEVICE_ATTR_RW(update_interval);\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_alarm, alarm, DS1621_ALARM_TEMP_LOW);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, alarm, DS1621_ALARM_TEMP_HIGH);\n\nstatic struct attribute *ds1621_attributes[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&dev_attr_alarms.attr,\n\t&dev_attr_update_interval.attr,\n\tNULL\n};\n\nstatic umode_t ds1621_attribute_visible(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct ds1621_data *data = dev_get_drvdata(dev);\n\n\tif (attr == &dev_attr_update_interval.attr)\n\t\tif (data->kind == ds1621 || data->kind == ds1625)\n\t\t\t \n\t\t\treturn 0;\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group ds1621_group = {\n\t.attrs = ds1621_attributes,\n\t.is_visible = ds1621_attribute_visible\n};\n__ATTRIBUTE_GROUPS(ds1621);\n\nstatic const struct i2c_device_id ds1621_id[];\n\nstatic int ds1621_probe(struct i2c_client *client)\n{\n\tstruct ds1621_data *data;\n\tstruct device *hwmon_dev;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct ds1621_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&data->update_lock);\n\n\tdata->kind = i2c_match_id(ds1621_id, client)->driver_data;\n\tdata->client = client;\n\n\t \n\tds1621_init_client(data, client);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(&client->dev,\n\t\t\t\t\t\t\t   client->name, data,\n\t\t\t\t\t\t\t   ds1621_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id ds1621_id[] = {\n\t{ \"ds1621\", ds1621 },\n\t{ \"ds1625\", ds1625 },\n\t{ \"ds1631\", ds1631 },\n\t{ \"ds1721\", ds1721 },\n\t{ \"ds1731\", ds1731 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ds1621_id);\n\n \nstatic struct i2c_driver ds1621_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"ds1621\",\n\t},\n\t.probe\t\t= ds1621_probe,\n\t.id_table\t= ds1621_id,\n};\n\nmodule_i2c_driver(ds1621_driver);\n\nMODULE_AUTHOR(\"Christian W. Zuckschwerdt <zany@triq.net>\");\nMODULE_DESCRIPTION(\"DS1621 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}