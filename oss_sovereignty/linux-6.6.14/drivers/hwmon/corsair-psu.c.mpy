{
  "module_name": "corsair-psu.c",
  "hash_id": "ec43176cf4669b2a554b22d07ab986d6610590ec25f7f13ef9a9c64cedde3727",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/corsair-psu.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/errno.h>\n#include <linux/hid.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n \n\n#define DRIVER_NAME\t\t\"corsair-psu\"\n\n#define REPLY_SIZE\t\t24  \n#define CMD_BUFFER_SIZE\t\t64\n#define CMD_TIMEOUT_MS\t\t250\n#define SECONDS_PER_HOUR\t(60 * 60)\n#define SECONDS_PER_DAY\t\t(SECONDS_PER_HOUR * 24)\n#define RAIL_COUNT\t\t3  \n#define TEMP_COUNT\t\t2\n#define OCP_MULTI_RAIL\t\t0x02\n\n#define PSU_CMD_SELECT_RAIL\t0x00  \n#define PSU_CMD_FAN_PWM\t\t0x3B  \n#define PSU_CMD_RAIL_VOLTS_HCRIT 0x40\n#define PSU_CMD_RAIL_VOLTS_LCRIT 0x44\n#define PSU_CMD_RAIL_AMPS_HCRIT\t0x46\n#define PSU_CMD_TEMP_HCRIT\t0x4F\n#define PSU_CMD_IN_VOLTS\t0x88\n#define PSU_CMD_IN_AMPS\t\t0x89\n#define PSU_CMD_RAIL_VOLTS\t0x8B\n#define PSU_CMD_RAIL_AMPS\t0x8C\n#define PSU_CMD_TEMP0\t\t0x8D\n#define PSU_CMD_TEMP1\t\t0x8E\n#define PSU_CMD_FAN\t\t0x90\n#define PSU_CMD_RAIL_WATTS\t0x96\n#define PSU_CMD_VEND_STR\t0x99\n#define PSU_CMD_PROD_STR\t0x9A\n#define PSU_CMD_TOTAL_UPTIME\t0xD1\n#define PSU_CMD_UPTIME\t\t0xD2\n#define PSU_CMD_OCPMODE\t\t0xD8\n#define PSU_CMD_TOTAL_WATTS\t0xEE\n#define PSU_CMD_FAN_PWM_ENABLE\t0xF0\n#define PSU_CMD_INIT\t\t0xFE\n\n#define L_IN_VOLTS\t\t\"v_in\"\n#define L_OUT_VOLTS_12V\t\t\"v_out +12v\"\n#define L_OUT_VOLTS_5V\t\t\"v_out +5v\"\n#define L_OUT_VOLTS_3_3V\t\"v_out +3.3v\"\n#define L_IN_AMPS\t\t\"curr in\"\n#define L_AMPS_12V\t\t\"curr +12v\"\n#define L_AMPS_5V\t\t\"curr +5v\"\n#define L_AMPS_3_3V\t\t\"curr +3.3v\"\n#define L_FAN\t\t\t\"psu fan\"\n#define L_TEMP0\t\t\t\"vrm temp\"\n#define L_TEMP1\t\t\t\"case temp\"\n#define L_WATTS\t\t\t\"power total\"\n#define L_WATTS_12V\t\t\"power +12v\"\n#define L_WATTS_5V\t\t\"power +5v\"\n#define L_WATTS_3_3V\t\t\"power +3.3v\"\n\nstatic const char *const label_watts[] = {\n\tL_WATTS,\n\tL_WATTS_12V,\n\tL_WATTS_5V,\n\tL_WATTS_3_3V\n};\n\nstatic const char *const label_volts[] = {\n\tL_IN_VOLTS,\n\tL_OUT_VOLTS_12V,\n\tL_OUT_VOLTS_5V,\n\tL_OUT_VOLTS_3_3V\n};\n\nstatic const char *const label_amps[] = {\n\tL_IN_AMPS,\n\tL_AMPS_12V,\n\tL_AMPS_5V,\n\tL_AMPS_3_3V\n};\n\nstruct corsairpsu_data {\n\tstruct hid_device *hdev;\n\tstruct device *hwmon_dev;\n\tstruct dentry *debugfs;\n\tstruct completion wait_completion;\n\tstruct mutex lock;  \n\tu8 *cmd_buffer;\n\tchar vendor[REPLY_SIZE];\n\tchar product[REPLY_SIZE];\n\tlong temp_crit[TEMP_COUNT];\n\tlong in_crit[RAIL_COUNT];\n\tlong in_lcrit[RAIL_COUNT];\n\tlong curr_crit[RAIL_COUNT];\n\tu8 temp_crit_support;\n\tu8 in_crit_support;\n\tu8 in_lcrit_support;\n\tu8 curr_crit_support;\n\tbool in_curr_cmd_support;  \n};\n\n \nstatic int corsairpsu_linear11_to_int(const u16 val, const int scale)\n{\n\tconst int exp = ((s16)val) >> 11;\n\tconst int mant = (((s16)(val & 0x7ff)) << 5) >> 5;\n\tconst int result = mant * scale;\n\n\treturn (exp >= 0) ? (result << exp) : (result >> -exp);\n}\n\n \nstatic int corsairpsu_dutycycle_to_pwm(const long dutycycle)\n{\n\tconst int result = (256 << 16) / 100;\n\n\treturn (result * dutycycle) >> 16;\n}\n\nstatic int corsairpsu_usb_cmd(struct corsairpsu_data *priv, u8 p0, u8 p1, u8 p2, void *data)\n{\n\tunsigned long time;\n\tint ret;\n\n\tmemset(priv->cmd_buffer, 0, CMD_BUFFER_SIZE);\n\tpriv->cmd_buffer[0] = p0;\n\tpriv->cmd_buffer[1] = p1;\n\tpriv->cmd_buffer[2] = p2;\n\n\treinit_completion(&priv->wait_completion);\n\n\tret = hid_hw_output_report(priv->hdev, priv->cmd_buffer, CMD_BUFFER_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttime = wait_for_completion_timeout(&priv->wait_completion,\n\t\t\t\t\t   msecs_to_jiffies(CMD_TIMEOUT_MS));\n\tif (!time)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tif (p0 != priv->cmd_buffer[0] || p1 != priv->cmd_buffer[1])\n\t\treturn -EOPNOTSUPP;\n\n\tif (data)\n\t\tmemcpy(data, priv->cmd_buffer + 2, REPLY_SIZE);\n\n\treturn 0;\n}\n\nstatic int corsairpsu_init(struct corsairpsu_data *priv)\n{\n\t \n\treturn corsairpsu_usb_cmd(priv, PSU_CMD_INIT, 3, 0, NULL);\n}\n\nstatic int corsairpsu_fwinfo(struct corsairpsu_data *priv)\n{\n\tint ret;\n\n\tret = corsairpsu_usb_cmd(priv, 3, PSU_CMD_VEND_STR, 0, priv->vendor);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = corsairpsu_usb_cmd(priv, 3, PSU_CMD_PROD_STR, 0, priv->product);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int corsairpsu_request(struct corsairpsu_data *priv, u8 cmd, u8 rail, void *data)\n{\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tswitch (cmd) {\n\tcase PSU_CMD_RAIL_VOLTS_HCRIT:\n\tcase PSU_CMD_RAIL_VOLTS_LCRIT:\n\tcase PSU_CMD_RAIL_AMPS_HCRIT:\n\tcase PSU_CMD_RAIL_VOLTS:\n\tcase PSU_CMD_RAIL_AMPS:\n\tcase PSU_CMD_RAIL_WATTS:\n\t\tret = corsairpsu_usb_cmd(priv, 2, PSU_CMD_SELECT_RAIL, rail, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto cmd_fail;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = corsairpsu_usb_cmd(priv, 3, cmd, 0, data);\n\ncmd_fail:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int corsairpsu_get_value(struct corsairpsu_data *priv, u8 cmd, u8 rail, long *val)\n{\n\tu8 data[REPLY_SIZE];\n\tlong tmp;\n\tint ret;\n\n\tret = corsairpsu_request(priv, cmd, rail, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ttmp = ((long)data[3] << 24) + (data[2] << 16) + (data[1] << 8) + data[0];\n\tswitch (cmd) {\n\tcase PSU_CMD_RAIL_VOLTS_HCRIT:\n\tcase PSU_CMD_RAIL_VOLTS_LCRIT:\n\tcase PSU_CMD_RAIL_AMPS_HCRIT:\n\tcase PSU_CMD_TEMP_HCRIT:\n\tcase PSU_CMD_IN_VOLTS:\n\tcase PSU_CMD_IN_AMPS:\n\tcase PSU_CMD_RAIL_VOLTS:\n\tcase PSU_CMD_RAIL_AMPS:\n\tcase PSU_CMD_TEMP0:\n\tcase PSU_CMD_TEMP1:\n\t\t*val = corsairpsu_linear11_to_int(tmp & 0xFFFF, 1000);\n\t\tbreak;\n\tcase PSU_CMD_FAN:\n\t\t*val = corsairpsu_linear11_to_int(tmp & 0xFFFF, 1);\n\t\tbreak;\n\tcase PSU_CMD_FAN_PWM_ENABLE:\n\t\t*val = corsairpsu_linear11_to_int(tmp & 0xFFFF, 1);\n\t\t \n\t\tif (*val == 0)\n\t\t\t*val = 2;\n\t\tbreak;\n\tcase PSU_CMD_FAN_PWM:\n\t\t*val = corsairpsu_linear11_to_int(tmp & 0xFFFF, 1);\n\t\t*val = corsairpsu_dutycycle_to_pwm(*val);\n\t\tbreak;\n\tcase PSU_CMD_RAIL_WATTS:\n\tcase PSU_CMD_TOTAL_WATTS:\n\t\t*val = corsairpsu_linear11_to_int(tmp & 0xFFFF, 1000000);\n\t\tbreak;\n\tcase PSU_CMD_TOTAL_UPTIME:\n\tcase PSU_CMD_UPTIME:\n\tcase PSU_CMD_OCPMODE:\n\t\t*val = tmp;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void corsairpsu_get_criticals(struct corsairpsu_data *priv)\n{\n\tlong tmp;\n\tint rail;\n\n\tfor (rail = 0; rail < TEMP_COUNT; ++rail) {\n\t\tif (!corsairpsu_get_value(priv, PSU_CMD_TEMP_HCRIT, rail, &tmp)) {\n\t\t\tpriv->temp_crit_support |= BIT(rail);\n\t\t\tpriv->temp_crit[rail] = tmp;\n\t\t}\n\t}\n\n\tfor (rail = 0; rail < RAIL_COUNT; ++rail) {\n\t\tif (!corsairpsu_get_value(priv, PSU_CMD_RAIL_VOLTS_HCRIT, rail, &tmp)) {\n\t\t\tpriv->in_crit_support |= BIT(rail);\n\t\t\tpriv->in_crit[rail] = tmp;\n\t\t}\n\n\t\tif (!corsairpsu_get_value(priv, PSU_CMD_RAIL_VOLTS_LCRIT, rail, &tmp)) {\n\t\t\tpriv->in_lcrit_support |= BIT(rail);\n\t\t\tpriv->in_lcrit[rail] = tmp;\n\t\t}\n\n\t\tif (!corsairpsu_get_value(priv, PSU_CMD_RAIL_AMPS_HCRIT, rail, &tmp)) {\n\t\t\tpriv->curr_crit_support |= BIT(rail);\n\t\t\tpriv->curr_crit[rail] = tmp;\n\t\t}\n\t}\n}\n\nstatic void corsairpsu_check_cmd_support(struct corsairpsu_data *priv)\n{\n\tlong tmp;\n\n\tpriv->in_curr_cmd_support = !corsairpsu_get_value(priv, PSU_CMD_IN_AMPS, 0, &tmp);\n}\n\nstatic umode_t corsairpsu_hwmon_temp_is_visible(const struct corsairpsu_data *priv, u32 attr,\n\t\t\t\t\t\tint channel)\n{\n\tumode_t res = 0444;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_label:\n\tcase hwmon_temp_crit:\n\t\tif (channel > 0 && !(priv->temp_crit_support & BIT(channel - 1)))\n\t\t\tres = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n\nstatic umode_t corsairpsu_hwmon_fan_is_visible(const struct corsairpsu_data *priv, u32 attr,\n\t\t\t\t\t       int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\tcase hwmon_fan_label:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t corsairpsu_hwmon_pwm_is_visible(const struct corsairpsu_data *priv, u32 attr,\n\t\t\t\t\t       int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\tcase hwmon_pwm_enable:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t corsairpsu_hwmon_power_is_visible(const struct corsairpsu_data *priv, u32 attr,\n\t\t\t\t\t\t int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_power_input:\n\tcase hwmon_power_label:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t corsairpsu_hwmon_in_is_visible(const struct corsairpsu_data *priv, u32 attr,\n\t\t\t\t\t      int channel)\n{\n\tumode_t res = 0444;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\tcase hwmon_in_label:\n\tcase hwmon_in_crit:\n\t\tif (channel > 0 && !(priv->in_crit_support & BIT(channel - 1)))\n\t\t\tres = 0;\n\t\tbreak;\n\tcase hwmon_in_lcrit:\n\t\tif (channel > 0 && !(priv->in_lcrit_support & BIT(channel - 1)))\n\t\t\tres = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n\nstatic umode_t corsairpsu_hwmon_curr_is_visible(const struct corsairpsu_data *priv, u32 attr,\n\t\t\t\t\t\tint channel)\n{\n\tumode_t res = 0444;\n\n\tswitch (attr) {\n\tcase hwmon_curr_input:\n\t\tif (channel == 0 && !priv->in_curr_cmd_support)\n\t\t\tres = 0;\n\t\tbreak;\n\tcase hwmon_curr_label:\n\tcase hwmon_curr_crit:\n\t\tif (channel > 0 && !(priv->curr_crit_support & BIT(channel - 1)))\n\t\t\tres = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n\nstatic umode_t corsairpsu_hwmon_ops_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t\t       u32 attr, int channel)\n{\n\tconst struct corsairpsu_data *priv = data;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn corsairpsu_hwmon_temp_is_visible(priv, attr, channel);\n\tcase hwmon_fan:\n\t\treturn corsairpsu_hwmon_fan_is_visible(priv, attr, channel);\n\tcase hwmon_pwm:\n\t\treturn corsairpsu_hwmon_pwm_is_visible(priv, attr, channel);\n\tcase hwmon_power:\n\t\treturn corsairpsu_hwmon_power_is_visible(priv, attr, channel);\n\tcase hwmon_in:\n\t\treturn corsairpsu_hwmon_in_is_visible(priv, attr, channel);\n\tcase hwmon_curr:\n\t\treturn corsairpsu_hwmon_curr_is_visible(priv, attr, channel);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int corsairpsu_hwmon_temp_read(struct corsairpsu_data *priv, u32 attr, int channel,\n\t\t\t\t      long *val)\n{\n\tint err = -EOPNOTSUPP;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treturn corsairpsu_get_value(priv, channel ? PSU_CMD_TEMP1 : PSU_CMD_TEMP0,\n\t\t\t\t\t    channel, val);\n\tcase hwmon_temp_crit:\n\t\t*val = priv->temp_crit[channel];\n\t\terr = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int corsairpsu_hwmon_pwm_read(struct corsairpsu_data *priv, u32 attr, int channel, long *val)\n{\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\treturn corsairpsu_get_value(priv, PSU_CMD_FAN_PWM, 0, val);\n\tcase hwmon_pwm_enable:\n\t\treturn corsairpsu_get_value(priv, PSU_CMD_FAN_PWM_ENABLE, 0, val);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int corsairpsu_hwmon_power_read(struct corsairpsu_data *priv, u32 attr, int channel,\n\t\t\t\t       long *val)\n{\n\tif (attr == hwmon_power_input) {\n\t\tswitch (channel) {\n\t\tcase 0:\n\t\t\treturn corsairpsu_get_value(priv, PSU_CMD_TOTAL_WATTS, 0, val);\n\t\tcase 1 ... 3:\n\t\t\treturn corsairpsu_get_value(priv, PSU_CMD_RAIL_WATTS, channel - 1, val);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int corsairpsu_hwmon_in_read(struct corsairpsu_data *priv, u32 attr, int channel, long *val)\n{\n\tint err = -EOPNOTSUPP;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\tswitch (channel) {\n\t\tcase 0:\n\t\t\treturn corsairpsu_get_value(priv, PSU_CMD_IN_VOLTS, 0, val);\n\t\tcase 1 ... 3:\n\t\t\treturn corsairpsu_get_value(priv, PSU_CMD_RAIL_VOLTS, channel - 1, val);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in_crit:\n\t\t*val = priv->in_crit[channel - 1];\n\t\terr = 0;\n\t\tbreak;\n\tcase hwmon_in_lcrit:\n\t\t*val = priv->in_lcrit[channel - 1];\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int corsairpsu_hwmon_curr_read(struct corsairpsu_data *priv, u32 attr, int channel,\n\t\t\t\t      long *val)\n{\n\tint err = -EOPNOTSUPP;\n\n\tswitch (attr) {\n\tcase hwmon_curr_input:\n\t\tswitch (channel) {\n\t\tcase 0:\n\t\t\treturn corsairpsu_get_value(priv, PSU_CMD_IN_AMPS, 0, val);\n\t\tcase 1 ... 3:\n\t\t\treturn corsairpsu_get_value(priv, PSU_CMD_RAIL_AMPS, channel - 1, val);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_curr_crit:\n\t\t*val = priv->curr_crit[channel - 1];\n\t\terr = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int corsairpsu_hwmon_ops_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t     int channel, long *val)\n{\n\tstruct corsairpsu_data *priv = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn corsairpsu_hwmon_temp_read(priv, attr, channel, val);\n\tcase hwmon_fan:\n\t\tif (attr == hwmon_fan_input)\n\t\t\treturn corsairpsu_get_value(priv, PSU_CMD_FAN, 0, val);\n\t\treturn -EOPNOTSUPP;\n\tcase hwmon_pwm:\n\t\treturn corsairpsu_hwmon_pwm_read(priv, attr, channel, val);\n\tcase hwmon_power:\n\t\treturn corsairpsu_hwmon_power_read(priv, attr, channel, val);\n\tcase hwmon_in:\n\t\treturn corsairpsu_hwmon_in_read(priv, attr, channel, val);\n\tcase hwmon_curr:\n\t\treturn corsairpsu_hwmon_curr_read(priv, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int corsairpsu_hwmon_ops_read_string(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t\t\t    u32 attr, int channel, const char **str)\n{\n\tif (type == hwmon_temp && attr == hwmon_temp_label) {\n\t\t*str = channel ? L_TEMP1 : L_TEMP0;\n\t\treturn 0;\n\t} else if (type == hwmon_fan && attr == hwmon_fan_label) {\n\t\t*str = L_FAN;\n\t\treturn 0;\n\t} else if (type == hwmon_power && attr == hwmon_power_label && channel < 4) {\n\t\t*str = label_watts[channel];\n\t\treturn 0;\n\t} else if (type == hwmon_in && attr == hwmon_in_label && channel < 4) {\n\t\t*str = label_volts[channel];\n\t\treturn 0;\n\t} else if (type == hwmon_curr && attr == hwmon_curr_label && channel < 4) {\n\t\t*str = label_amps[channel];\n\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct hwmon_ops corsairpsu_hwmon_ops = {\n\t.is_visible\t= corsairpsu_hwmon_ops_is_visible,\n\t.read\t\t= corsairpsu_hwmon_ops_read,\n\t.read_string\t= corsairpsu_hwmon_ops_read_string,\n};\n\nstatic const struct hwmon_channel_info *const corsairpsu_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_CRIT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_CRIT),\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE),\n\tHWMON_CHANNEL_INFO(power,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL | HWMON_I_LCRIT | HWMON_I_CRIT,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL | HWMON_I_LCRIT | HWMON_I_CRIT,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL | HWMON_I_LCRIT | HWMON_I_CRIT),\n\tHWMON_CHANNEL_INFO(curr,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL | HWMON_C_CRIT,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL | HWMON_C_CRIT,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL | HWMON_C_CRIT),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info corsairpsu_chip_info = {\n\t.ops\t= &corsairpsu_hwmon_ops,\n\t.info\t= corsairpsu_info,\n};\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic void print_uptime(struct seq_file *seqf, u8 cmd)\n{\n\tstruct corsairpsu_data *priv = seqf->private;\n\tlong val;\n\tint ret;\n\n\tret = corsairpsu_get_value(priv, cmd, 0, &val);\n\tif (ret < 0) {\n\t\tseq_puts(seqf, \"N/A\\n\");\n\t\treturn;\n\t}\n\n\tif (val > SECONDS_PER_DAY) {\n\t\tseq_printf(seqf, \"%ld day(s), %02ld:%02ld:%02ld\\n\", val / SECONDS_PER_DAY,\n\t\t\t   val % SECONDS_PER_DAY / SECONDS_PER_HOUR, val % SECONDS_PER_HOUR / 60,\n\t\t\t   val % 60);\n\t\treturn;\n\t}\n\n\tseq_printf(seqf, \"%02ld:%02ld:%02ld\\n\", val % SECONDS_PER_DAY / SECONDS_PER_HOUR,\n\t\t   val % SECONDS_PER_HOUR / 60, val % 60);\n}\n\nstatic int uptime_show(struct seq_file *seqf, void *unused)\n{\n\tprint_uptime(seqf, PSU_CMD_UPTIME);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(uptime);\n\nstatic int uptime_total_show(struct seq_file *seqf, void *unused)\n{\n\tprint_uptime(seqf, PSU_CMD_TOTAL_UPTIME);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(uptime_total);\n\nstatic int vendor_show(struct seq_file *seqf, void *unused)\n{\n\tstruct corsairpsu_data *priv = seqf->private;\n\n\tseq_printf(seqf, \"%s\\n\", priv->vendor);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(vendor);\n\nstatic int product_show(struct seq_file *seqf, void *unused)\n{\n\tstruct corsairpsu_data *priv = seqf->private;\n\n\tseq_printf(seqf, \"%s\\n\", priv->product);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(product);\n\nstatic int ocpmode_show(struct seq_file *seqf, void *unused)\n{\n\tstruct corsairpsu_data *priv = seqf->private;\n\tlong val;\n\tint ret;\n\n\t \n\tret = corsairpsu_get_value(priv, PSU_CMD_OCPMODE, 0, &val);\n\tif (ret < 0)\n\t\tseq_puts(seqf, \"N/A\\n\");\n\telse\n\t\tseq_printf(seqf, \"%s\\n\", (val == OCP_MULTI_RAIL) ? \"multi rail\" : \"single rail\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ocpmode);\n\nstatic void corsairpsu_debugfs_init(struct corsairpsu_data *priv)\n{\n\tchar name[32];\n\n\tscnprintf(name, sizeof(name), \"%s-%s\", DRIVER_NAME, dev_name(&priv->hdev->dev));\n\n\tpriv->debugfs = debugfs_create_dir(name, NULL);\n\tdebugfs_create_file(\"uptime\", 0444, priv->debugfs, priv, &uptime_fops);\n\tdebugfs_create_file(\"uptime_total\", 0444, priv->debugfs, priv, &uptime_total_fops);\n\tdebugfs_create_file(\"vendor\", 0444, priv->debugfs, priv, &vendor_fops);\n\tdebugfs_create_file(\"product\", 0444, priv->debugfs, priv, &product_fops);\n\tdebugfs_create_file(\"ocpmode\", 0444, priv->debugfs, priv, &ocpmode_fops);\n}\n\n#else\n\nstatic void corsairpsu_debugfs_init(struct corsairpsu_data *priv)\n{\n}\n\n#endif\n\nstatic int corsairpsu_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct corsairpsu_data *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&hdev->dev, sizeof(struct corsairpsu_data), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->cmd_buffer = devm_kmalloc(&hdev->dev, CMD_BUFFER_SIZE, GFP_KERNEL);\n\tif (!priv->cmd_buffer)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hid_hw_open(hdev);\n\tif (ret)\n\t\tgoto fail_and_stop;\n\n\tpriv->hdev = hdev;\n\thid_set_drvdata(hdev, priv);\n\tmutex_init(&priv->lock);\n\tinit_completion(&priv->wait_completion);\n\n\thid_device_io_start(hdev);\n\n\tret = corsairpsu_init(priv);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"unable to initialize device (%d)\\n\", ret);\n\t\tgoto fail_and_stop;\n\t}\n\n\tret = corsairpsu_fwinfo(priv);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"unable to query firmware (%d)\\n\", ret);\n\t\tgoto fail_and_stop;\n\t}\n\n\tcorsairpsu_get_criticals(priv);\n\tcorsairpsu_check_cmd_support(priv);\n\n\tpriv->hwmon_dev = hwmon_device_register_with_info(&hdev->dev, \"corsairpsu\", priv,\n\t\t\t\t\t\t\t  &corsairpsu_chip_info, NULL);\n\n\tif (IS_ERR(priv->hwmon_dev)) {\n\t\tret = PTR_ERR(priv->hwmon_dev);\n\t\tgoto fail_and_close;\n\t}\n\n\tcorsairpsu_debugfs_init(priv);\n\n\treturn 0;\n\nfail_and_close:\n\thid_hw_close(hdev);\nfail_and_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void corsairpsu_remove(struct hid_device *hdev)\n{\n\tstruct corsairpsu_data *priv = hid_get_drvdata(hdev);\n\n\tdebugfs_remove_recursive(priv->debugfs);\n\thwmon_device_unregister(priv->hwmon_dev);\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic int corsairpsu_raw_event(struct hid_device *hdev, struct hid_report *report, u8 *data,\n\t\t\t\tint size)\n{\n\tstruct corsairpsu_data *priv = hid_get_drvdata(hdev);\n\n\tif (completion_done(&priv->wait_completion))\n\t\treturn 0;\n\n\tmemcpy(priv->cmd_buffer, data, min(CMD_BUFFER_SIZE, size));\n\tcomplete(&priv->wait_completion);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int corsairpsu_resume(struct hid_device *hdev)\n{\n\tstruct corsairpsu_data *priv = hid_get_drvdata(hdev);\n\n\t \n\treturn corsairpsu_init(priv);\n}\n#endif\n\nstatic const struct hid_device_id corsairpsu_idtable[] = {\n\t{ HID_USB_DEVICE(0x1b1c, 0x1c03) },  \n\t{ HID_USB_DEVICE(0x1b1c, 0x1c04) },  \n\t{ HID_USB_DEVICE(0x1b1c, 0x1c05) },  \n\t{ HID_USB_DEVICE(0x1b1c, 0x1c06) },  \n\t{ HID_USB_DEVICE(0x1b1c, 0x1c07) },  \n\t{ HID_USB_DEVICE(0x1b1c, 0x1c08) },  \n\t{ HID_USB_DEVICE(0x1b1c, 0x1c09) },  \n\t{ HID_USB_DEVICE(0x1b1c, 0x1c0a) },  \n\t{ HID_USB_DEVICE(0x1b1c, 0x1c0b) },  \n\t{ HID_USB_DEVICE(0x1b1c, 0x1c0c) },  \n\t{ HID_USB_DEVICE(0x1b1c, 0x1c0d) },  \n\t{ HID_USB_DEVICE(0x1b1c, 0x1c1e) },  \n\t{ HID_USB_DEVICE(0x1b1c, 0x1c1f) },  \n\t{ },\n};\nMODULE_DEVICE_TABLE(hid, corsairpsu_idtable);\n\nstatic struct hid_driver corsairpsu_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.id_table\t= corsairpsu_idtable,\n\t.probe\t\t= corsairpsu_probe,\n\t.remove\t\t= corsairpsu_remove,\n\t.raw_event\t= corsairpsu_raw_event,\n#ifdef CONFIG_PM\n\t.resume\t\t= corsairpsu_resume,\n\t.reset_resume\t= corsairpsu_resume,\n#endif\n};\n\nstatic int __init corsair_init(void)\n{\n\treturn hid_register_driver(&corsairpsu_driver);\n}\n\nstatic void __exit corsair_exit(void)\n{\n\thid_unregister_driver(&corsairpsu_driver);\n}\n\n \nlate_initcall(corsair_init);\nmodule_exit(corsair_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Wilken Gottwalt <wilken.gottwalt@posteo.net>\");\nMODULE_DESCRIPTION(\"Linux driver for Corsair power supplies with HID sensors interface\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}