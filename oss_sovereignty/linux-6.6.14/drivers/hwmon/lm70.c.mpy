{
  "module_name": "lm70.c",
  "hash_id": "243dd6e2384d79624cb71e81d4d7a4f0941c094047629dc1f4f5c8421395dd71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lm70.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/sysfs.h>\n#include <linux/hwmon.h>\n#include <linux/mutex.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n\n#define DRVNAME\t\t\"lm70\"\n\n#define LM70_CHIP_LM70\t\t0\t \n#define LM70_CHIP_TMP121\t1\t \n#define LM70_CHIP_LM71\t\t2\t \n#define LM70_CHIP_LM74\t\t3\t \n#define LM70_CHIP_TMP122\t4\t \n#define LM70_CHIP_TMP125\t5\t \n\nstruct lm70 {\n\tstruct spi_device *spi;\n\tstruct mutex lock;\n\tunsigned int chip;\n};\n\n \nstatic ssize_t temp1_input_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lm70 *p_lm70 = dev_get_drvdata(dev);\n\tstruct spi_device *spi = p_lm70->spi;\n\tint status, val = 0;\n\tu8 rxbuf[2];\n\ts16 raw = 0;\n\n\tif (mutex_lock_interruptible(&p_lm70->lock))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tstatus = spi_write_then_read(spi, NULL, 0, &rxbuf[0], 2);\n\tif (status < 0) {\n\t\tdev_warn(dev, \"spi_write_then_read failed with status %d\\n\",\n\t\t\t status);\n\t\tgoto out;\n\t}\n\traw = (rxbuf[0] << 8) + rxbuf[1];\n\tdev_dbg(dev, \"rxbuf[0] : 0x%02x rxbuf[1] : 0x%02x raw=0x%04x\\n\",\n\t\trxbuf[0], rxbuf[1], raw);\n\n\t \n\tswitch (p_lm70->chip) {\n\tcase LM70_CHIP_LM70:\n\t\tval = ((int)raw / 32) * 250;\n\t\tbreak;\n\n\tcase LM70_CHIP_TMP121:\n\tcase LM70_CHIP_TMP122:\n\tcase LM70_CHIP_LM74:\n\t\tval = ((int)raw / 8) * 625 / 10;\n\t\tbreak;\n\n\tcase LM70_CHIP_LM71:\n\t\tval = ((int)raw / 4) * 3125 / 100;\n\t\tbreak;\n\n\tcase LM70_CHIP_TMP125:\n\t\tval = (sign_extend32(raw, 14) / 32) * 250;\n\t\tbreak;\n\t}\n\n\tstatus = sprintf(buf, \"%d\\n\", val);  \nout:\n\tmutex_unlock(&p_lm70->lock);\n\treturn status;\n}\n\nstatic DEVICE_ATTR_RO(temp1_input);\n\nstatic struct attribute *lm70_attrs[] = {\n\t&dev_attr_temp1_input.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(lm70);\n\n \n\n#ifdef CONFIG_OF\nstatic const struct of_device_id lm70_of_ids[] = {\n\t{\n\t\t.compatible = \"ti,lm70\",\n\t\t.data = (void *) LM70_CHIP_LM70,\n\t},\n\t{\n\t\t.compatible = \"ti,tmp121\",\n\t\t.data = (void *) LM70_CHIP_TMP121,\n\t},\n\t{\n\t\t.compatible = \"ti,tmp122\",\n\t\t.data = (void *) LM70_CHIP_TMP122,\n\t},\n\t{\n\t\t.compatible = \"ti,tmp125\",\n\t\t.data = (void *) LM70_CHIP_TMP125,\n\t},\n\t{\n\t\t.compatible = \"ti,lm71\",\n\t\t.data = (void *) LM70_CHIP_LM71,\n\t},\n\t{\n\t\t.compatible = \"ti,lm74\",\n\t\t.data = (void *) LM70_CHIP_LM74,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, lm70_of_ids);\n#endif\n\nstatic int lm70_probe(struct spi_device *spi)\n{\n\tstruct device *hwmon_dev;\n\tstruct lm70 *p_lm70;\n\tint chip;\n\n\tif (dev_fwnode(&spi->dev))\n\t\tchip = (int)(uintptr_t)device_get_match_data(&spi->dev);\n\telse\n\t\tchip = spi_get_device_id(spi)->driver_data;\n\n\n\t \n\tif ((spi->mode & SPI_MODE_X_MASK) != SPI_MODE_0)\n\t\treturn -EINVAL;\n\n\t \n\n\tp_lm70 = devm_kzalloc(&spi->dev, sizeof(*p_lm70), GFP_KERNEL);\n\tif (!p_lm70)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&p_lm70->lock);\n\tp_lm70->chip = chip;\n\tp_lm70->spi = spi;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(&spi->dev,\n\t\t\t\t\t\t\t   spi->modalias,\n\t\t\t\t\t\t\t   p_lm70, lm70_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct spi_device_id lm70_ids[] = {\n\t{ \"lm70\",   LM70_CHIP_LM70 },\n\t{ \"tmp121\", LM70_CHIP_TMP121 },\n\t{ \"tmp122\", LM70_CHIP_TMP122 },\n\t{ \"tmp125\", LM70_CHIP_TMP125 },\n\t{ \"lm71\",   LM70_CHIP_LM71 },\n\t{ \"lm74\",   LM70_CHIP_LM74 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, lm70_ids);\n\nstatic struct spi_driver lm70_driver = {\n\t.driver = {\n\t\t.name\t= \"lm70\",\n\t\t.of_match_table\t= of_match_ptr(lm70_of_ids),\n\t},\n\t.id_table = lm70_ids,\n\t.probe\t= lm70_probe,\n};\n\nmodule_spi_driver(lm70_driver);\n\nMODULE_AUTHOR(\"Kaiwan N Billimoria\");\nMODULE_DESCRIPTION(\"NS LM70 and compatibles Linux driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}