{
  "module_name": "ibmpex.c",
  "hash_id": "becc03c6afea8f399ceee295b84e607ddb4e127780bf2f6632b4183b0e034491",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ibmpex.c",
  "human_readable_source": "\n \n\n#include <linux/ipmi.h>\n#include <linux/module.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\n#define REFRESH_INTERVAL\t(2 * HZ)\n#define DRVNAME\t\t\t\"ibmpex\"\n\n#define PEX_GET_VERSION\t\t1\n#define PEX_GET_SENSOR_COUNT\t2\n#define PEX_GET_SENSOR_NAME\t3\n#define PEX_RESET_HIGH_LOW\t4\n#define PEX_GET_SENSOR_DATA\t6\n\n#define PEX_NET_FUNCTION\t0x3A\n#define PEX_COMMAND\t\t0x3C\n\nstatic inline u16 extract_value(const char *data, int offset)\n{\n\treturn be16_to_cpup((__be16 *)&data[offset]);\n}\n\n#define TEMP_SENSOR\t\t1\n#define POWER_SENSOR\t\t2\n\n#define PEX_SENSOR_TYPE_LEN\t3\nstatic u8 const power_sensor_sig[] = {0x70, 0x77, 0x72};\nstatic u8 const temp_sensor_sig[]  = {0x74, 0x65, 0x6D};\n\n#define PEX_MULT_LEN\t\t2\nstatic u8 const watt_sensor_sig[]  = {0x41, 0x43};\n\n#define PEX_NUM_SENSOR_FUNCS\t3\nstatic const char * const sensor_name_suffixes[] = {\n\t\"\",\n\t\"_lowest\",\n\t\"_highest\"\n};\n\nstatic void ibmpex_msg_handler(struct ipmi_recv_msg *msg, void *user_msg_data);\nstatic void ibmpex_register_bmc(int iface, struct device *dev);\nstatic void ibmpex_bmc_gone(int iface);\n\nstruct ibmpex_sensor_data {\n\tint\t\t\tin_use;\n\ts16\t\t\tvalues[PEX_NUM_SENSOR_FUNCS];\n\tint\t\t\tmultiplier;\n\n\tstruct sensor_device_attribute_2\tattr[PEX_NUM_SENSOR_FUNCS];\n};\n\nstruct ibmpex_bmc_data {\n\tstruct list_head\tlist;\n\tstruct device\t\t*hwmon_dev;\n\tstruct device\t\t*bmc_device;\n\tstruct mutex\t\tlock;\n\tbool\t\t\tvalid;\n\tunsigned long\t\tlast_updated;\t \n\n\tstruct ipmi_addr\taddress;\n\tstruct completion\tread_complete;\n\tstruct ipmi_user\t*user;\n\tint\t\t\tinterface;\n\n\tstruct kernel_ipmi_msg\ttx_message;\n\tunsigned char\t\ttx_msg_data[IPMI_MAX_MSG_LENGTH];\n\tlong\t\t\ttx_msgid;\n\n\tunsigned char\t\trx_msg_data[IPMI_MAX_MSG_LENGTH];\n\tunsigned long\t\trx_msg_len;\n\tunsigned char\t\trx_result;\n\tint\t\t\trx_recv_type;\n\n\tunsigned char\t\tsensor_major;\n\tunsigned char\t\tsensor_minor;\n\n\tunsigned char\t\tnum_sensors;\n\tstruct ibmpex_sensor_data\t*sensors;\n};\n\nstruct ibmpex_driver_data {\n\tstruct list_head\tbmc_data;\n\tstruct ipmi_smi_watcher\tbmc_events;\n\tstruct ipmi_user_hndl\tipmi_hndlrs;\n};\n\nstatic struct ibmpex_driver_data driver_data = {\n\t.bmc_data = LIST_HEAD_INIT(driver_data.bmc_data),\n\t.bmc_events = {\n\t\t.owner = THIS_MODULE,\n\t\t.new_smi = ibmpex_register_bmc,\n\t\t.smi_gone = ibmpex_bmc_gone,\n\t},\n\t.ipmi_hndlrs = {\n\t\t.ipmi_recv_hndl = ibmpex_msg_handler,\n\t},\n};\n\nstatic int ibmpex_send_message(struct ibmpex_bmc_data *data)\n{\n\tint err;\n\n\terr = ipmi_validate_addr(&data->address, sizeof(data->address));\n\tif (err)\n\t\tgoto out;\n\n\tdata->tx_msgid++;\n\terr = ipmi_request_settime(data->user, &data->address, data->tx_msgid,\n\t\t\t\t   &data->tx_message, data, 0, 0, 0);\n\tif (err)\n\t\tgoto out1;\n\n\treturn 0;\nout1:\n\tdev_err(data->bmc_device, \"request_settime=%x\\n\", err);\n\treturn err;\nout:\n\tdev_err(data->bmc_device, \"validate_addr=%x\\n\", err);\n\treturn err;\n}\n\nstatic int ibmpex_ver_check(struct ibmpex_bmc_data *data)\n{\n\tdata->tx_msg_data[0] = PEX_GET_VERSION;\n\tdata->tx_message.data_len = 1;\n\tibmpex_send_message(data);\n\n\twait_for_completion(&data->read_complete);\n\n\tif (data->rx_result || data->rx_msg_len != 6)\n\t\treturn -ENOENT;\n\n\tdata->sensor_major = data->rx_msg_data[0];\n\tdata->sensor_minor = data->rx_msg_data[1];\n\n\tdev_info(data->bmc_device,\n\t\t \"Found BMC with sensor interface v%d.%d %d-%02d-%02d on interface %d\\n\",\n\t\t data->sensor_major,\n\t\t data->sensor_minor,\n\t\t extract_value(data->rx_msg_data, 2),\n\t\t data->rx_msg_data[4],\n\t\t data->rx_msg_data[5],\n\t\t data->interface);\n\n\treturn 0;\n}\n\nstatic int ibmpex_query_sensor_count(struct ibmpex_bmc_data *data)\n{\n\tdata->tx_msg_data[0] = PEX_GET_SENSOR_COUNT;\n\tdata->tx_message.data_len = 1;\n\tibmpex_send_message(data);\n\n\twait_for_completion(&data->read_complete);\n\n\tif (data->rx_result || data->rx_msg_len != 1)\n\t\treturn -ENOENT;\n\n\treturn data->rx_msg_data[0];\n}\n\nstatic int ibmpex_query_sensor_name(struct ibmpex_bmc_data *data, int sensor)\n{\n\tdata->tx_msg_data[0] = PEX_GET_SENSOR_NAME;\n\tdata->tx_msg_data[1] = sensor;\n\tdata->tx_message.data_len = 2;\n\tibmpex_send_message(data);\n\n\twait_for_completion(&data->read_complete);\n\n\tif (data->rx_result || data->rx_msg_len < 1)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic int ibmpex_query_sensor_data(struct ibmpex_bmc_data *data, int sensor)\n{\n\tdata->tx_msg_data[0] = PEX_GET_SENSOR_DATA;\n\tdata->tx_msg_data[1] = sensor;\n\tdata->tx_message.data_len = 2;\n\tibmpex_send_message(data);\n\n\twait_for_completion(&data->read_complete);\n\n\tif (data->rx_result || data->rx_msg_len < 26) {\n\t\tdev_err(data->bmc_device, \"Error reading sensor %d.\\n\",\n\t\t\tsensor);\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\nstatic int ibmpex_reset_high_low_data(struct ibmpex_bmc_data *data)\n{\n\tdata->tx_msg_data[0] = PEX_RESET_HIGH_LOW;\n\tdata->tx_message.data_len = 1;\n\tibmpex_send_message(data);\n\n\twait_for_completion(&data->read_complete);\n\n\treturn 0;\n}\n\nstatic void ibmpex_update_device(struct ibmpex_bmc_data *data)\n{\n\tint i, err;\n\n\tmutex_lock(&data->lock);\n\tif (time_before(jiffies, data->last_updated + REFRESH_INTERVAL) &&\n\t    data->valid)\n\t\tgoto out;\n\n\tfor (i = 0; i < data->num_sensors; i++) {\n\t\tif (!data->sensors[i].in_use)\n\t\t\tcontinue;\n\t\terr = ibmpex_query_sensor_data(data, i);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tdata->sensors[i].values[0] =\n\t\t\textract_value(data->rx_msg_data, 16);\n\t\tdata->sensors[i].values[1] =\n\t\t\textract_value(data->rx_msg_data, 18);\n\t\tdata->sensors[i].values[2] =\n\t\t\textract_value(data->rx_msg_data, 20);\n\t}\n\n\tdata->last_updated = jiffies;\n\tdata->valid = true;\n\nout:\n\tmutex_unlock(&data->lock);\n}\n\nstatic struct ibmpex_bmc_data *get_bmc_data(int iface)\n{\n\tstruct ibmpex_bmc_data *p, *next;\n\n\tlist_for_each_entry_safe(p, next, &driver_data.bmc_data, list)\n\t\tif (p->interface == iface)\n\t\t\treturn p;\n\n\treturn NULL;\n}\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", DRVNAME);\n}\nstatic SENSOR_DEVICE_ATTR_RO(name, name, 0);\n\nstatic ssize_t ibmpex_show_sensor(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr,\n\t\t\t\t  char *buf)\n{\n\tstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\n\tstruct ibmpex_bmc_data *data = dev_get_drvdata(dev);\n\tint mult = data->sensors[attr->index].multiplier;\n\tibmpex_update_device(data);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       data->sensors[attr->index].values[attr->nr] * mult);\n}\n\nstatic ssize_t ibmpex_high_low_store(struct device *dev,\n\t\t\t\t     struct device_attribute *devattr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ibmpex_bmc_data *data = dev_get_drvdata(dev);\n\n\tibmpex_reset_high_low_data(data);\n\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_WO(reset_high_low, ibmpex_high_low, 0);\n\nstatic int is_power_sensor(const char *sensor_id, int len)\n{\n\tif (len < PEX_SENSOR_TYPE_LEN)\n\t\treturn 0;\n\n\tif (!memcmp(sensor_id, power_sensor_sig, PEX_SENSOR_TYPE_LEN))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int is_temp_sensor(const char *sensor_id, int len)\n{\n\tif (len < PEX_SENSOR_TYPE_LEN)\n\t\treturn 0;\n\n\tif (!memcmp(sensor_id, temp_sensor_sig, PEX_SENSOR_TYPE_LEN))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int power_sensor_multiplier(struct ibmpex_bmc_data *data,\n\t\t\t\t   const char *sensor_id, int len)\n{\n\tint i;\n\n\tif (data->sensor_major == 2)\n\t\treturn 1000000;\n\n\tfor (i = PEX_SENSOR_TYPE_LEN; i < len - 1; i++)\n\t\tif (!memcmp(&sensor_id[i], watt_sensor_sig, PEX_MULT_LEN))\n\t\t\treturn 1000000;\n\n\treturn 100000;\n}\n\nstatic int create_sensor(struct ibmpex_bmc_data *data, int type,\n\t\t\t int counter, int sensor, int func)\n{\n\tint err;\n\tchar *n;\n\n\tn = kmalloc(32, GFP_KERNEL);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\tif (type == TEMP_SENSOR)\n\t\tsprintf(n, \"temp%d_input%s\",\n\t\t\tcounter, sensor_name_suffixes[func]);\n\telse if (type == POWER_SENSOR)\n\t\tsprintf(n, \"power%d_average%s\",\n\t\t\tcounter, sensor_name_suffixes[func]);\n\n\tsysfs_attr_init(&data->sensors[sensor].attr[func].dev_attr.attr);\n\tdata->sensors[sensor].attr[func].dev_attr.attr.name = n;\n\tdata->sensors[sensor].attr[func].dev_attr.attr.mode = 0444;\n\tdata->sensors[sensor].attr[func].dev_attr.show = ibmpex_show_sensor;\n\tdata->sensors[sensor].attr[func].index = sensor;\n\tdata->sensors[sensor].attr[func].nr = func;\n\n\terr = device_create_file(data->bmc_device,\n\t\t\t\t &data->sensors[sensor].attr[func].dev_attr);\n\tif (err) {\n\t\tdata->sensors[sensor].attr[func].dev_attr.attr.name = NULL;\n\t\tkfree(n);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int ibmpex_find_sensors(struct ibmpex_bmc_data *data)\n{\n\tint i, j, err;\n\tint sensor_type;\n\tint sensor_counter;\n\tint num_power = 0;\n\tint num_temp = 0;\n\n\terr = ibmpex_query_sensor_count(data);\n\tif (err <= 0)\n\t\treturn -ENOENT;\n\tdata->num_sensors = err;\n\n\tdata->sensors = kcalloc(data->num_sensors, sizeof(*data->sensors),\n\t\t\t\tGFP_KERNEL);\n\tif (!data->sensors)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < data->num_sensors; i++) {\n\t\terr = ibmpex_query_sensor_name(data, i);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tif (is_power_sensor(data->rx_msg_data, data->rx_msg_len)) {\n\t\t\tsensor_type = POWER_SENSOR;\n\t\t\tnum_power++;\n\t\t\tsensor_counter = num_power;\n\t\t\tdata->sensors[i].multiplier =\n\t\t\t\tpower_sensor_multiplier(data,\n\t\t\t\t\t\t\tdata->rx_msg_data,\n\t\t\t\t\t\t\tdata->rx_msg_len);\n\t\t} else if (is_temp_sensor(data->rx_msg_data,\n\t\t\t\t\t  data->rx_msg_len)) {\n\t\t\tsensor_type = TEMP_SENSOR;\n\t\t\tnum_temp++;\n\t\t\tsensor_counter = num_temp;\n\t\t\tdata->sensors[i].multiplier = 1000;\n\t\t} else\n\t\t\tcontinue;\n\n\t\tdata->sensors[i].in_use = 1;\n\n\t\t \n\t\tfor (j = 0; j < PEX_NUM_SENSOR_FUNCS; j++) {\n\t\t\terr = create_sensor(data, sensor_type, sensor_counter,\n\t\t\t\t\t    i, j);\n\t\t\tif (err)\n\t\t\t\tgoto exit_remove;\n\t\t}\n\t}\n\n\terr = device_create_file(data->bmc_device,\n\t\t\t&sensor_dev_attr_reset_high_low.dev_attr);\n\tif (err)\n\t\tgoto exit_remove;\n\n\terr = device_create_file(data->bmc_device,\n\t\t\t&sensor_dev_attr_name.dev_attr);\n\tif (err)\n\t\tgoto exit_remove;\n\n\treturn 0;\n\nexit_remove:\n\tdevice_remove_file(data->bmc_device,\n\t\t\t   &sensor_dev_attr_reset_high_low.dev_attr);\n\tdevice_remove_file(data->bmc_device, &sensor_dev_attr_name.dev_attr);\n\tfor (i = 0; i < data->num_sensors; i++)\n\t\tfor (j = 0; j < PEX_NUM_SENSOR_FUNCS; j++) {\n\t\t\tif (!data->sensors[i].attr[j].dev_attr.attr.name)\n\t\t\t\tcontinue;\n\t\t\tdevice_remove_file(data->bmc_device,\n\t\t\t\t&data->sensors[i].attr[j].dev_attr);\n\t\t\tkfree(data->sensors[i].attr[j].dev_attr.attr.name);\n\t\t}\n\n\tkfree(data->sensors);\n\treturn err;\n}\n\nstatic void ibmpex_register_bmc(int iface, struct device *dev)\n{\n\tstruct ibmpex_bmc_data *data;\n\tint err;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\tdata->address.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tdata->address.channel = IPMI_BMC_CHANNEL;\n\tdata->address.data[0] = 0;\n\tdata->interface = iface;\n\tdata->bmc_device = dev;\n\n\t \n\terr = ipmi_create_user(data->interface, &driver_data.ipmi_hndlrs,\n\t\t\t       data, &data->user);\n\tif (err < 0) {\n\t\tdev_err(dev,\n\t\t\t\"Unable to register user with IPMI interface %d\\n\",\n\t\t\tdata->interface);\n\t\tgoto out;\n\t}\n\n\tmutex_init(&data->lock);\n\n\t \n\tdata->tx_msgid = 0;\n\tinit_completion(&data->read_complete);\n\tdata->tx_message.netfn = PEX_NET_FUNCTION;\n\tdata->tx_message.cmd = PEX_COMMAND;\n\tdata->tx_message.data = data->tx_msg_data;\n\n\t \n\terr = ibmpex_ver_check(data);\n\tif (err)\n\t\tgoto out_user;\n\n\t \n\tdata->hwmon_dev = hwmon_device_register(data->bmc_device);\n\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\tdev_err(data->bmc_device,\n\t\t\t\"Unable to register hwmon device for IPMI interface %d\\n\",\n\t\t\tdata->interface);\n\t\tgoto out_user;\n\t}\n\n\t \n\tdev_set_drvdata(dev, data);\n\tlist_add_tail(&data->list, &driver_data.bmc_data);\n\n\t \n\terr = ibmpex_find_sensors(data);\n\tif (err) {\n\t\tdev_err(data->bmc_device, \"Error %d finding sensors\\n\", err);\n\t\tgoto out_register;\n\t}\n\n\treturn;\n\nout_register:\n\tlist_del(&data->list);\n\thwmon_device_unregister(data->hwmon_dev);\nout_user:\n\tipmi_destroy_user(data->user);\nout:\n\tkfree(data);\n}\n\nstatic void ibmpex_bmc_delete(struct ibmpex_bmc_data *data)\n{\n\tint i, j;\n\n\tdevice_remove_file(data->bmc_device,\n\t\t\t   &sensor_dev_attr_reset_high_low.dev_attr);\n\tdevice_remove_file(data->bmc_device, &sensor_dev_attr_name.dev_attr);\n\tfor (i = 0; i < data->num_sensors; i++)\n\t\tfor (j = 0; j < PEX_NUM_SENSOR_FUNCS; j++) {\n\t\t\tif (!data->sensors[i].attr[j].dev_attr.attr.name)\n\t\t\t\tcontinue;\n\t\t\tdevice_remove_file(data->bmc_device,\n\t\t\t\t&data->sensors[i].attr[j].dev_attr);\n\t\t\tkfree(data->sensors[i].attr[j].dev_attr.attr.name);\n\t\t}\n\n\tlist_del(&data->list);\n\tdev_set_drvdata(data->bmc_device, NULL);\n\thwmon_device_unregister(data->hwmon_dev);\n\tipmi_destroy_user(data->user);\n\tkfree(data->sensors);\n\tkfree(data);\n}\n\nstatic void ibmpex_bmc_gone(int iface)\n{\n\tstruct ibmpex_bmc_data *data = get_bmc_data(iface);\n\n\tif (!data)\n\t\treturn;\n\n\tibmpex_bmc_delete(data);\n}\n\nstatic void ibmpex_msg_handler(struct ipmi_recv_msg *msg, void *user_msg_data)\n{\n\tstruct ibmpex_bmc_data *data = user_msg_data;\n\n\tif (msg->msgid != data->tx_msgid) {\n\t\tdev_err(data->bmc_device,\n\t\t\t\"Mismatch between received msgid (%02x) and transmitted msgid (%02x)!\\n\",\n\t\t\t(int)msg->msgid,\n\t\t\t(int)data->tx_msgid);\n\t\tipmi_free_recv_msg(msg);\n\t\treturn;\n\t}\n\n\tdata->rx_recv_type = msg->recv_type;\n\tif (msg->msg.data_len > 0)\n\t\tdata->rx_result = msg->msg.data[0];\n\telse\n\t\tdata->rx_result = IPMI_UNKNOWN_ERR_COMPLETION_CODE;\n\n\tif (msg->msg.data_len > 1) {\n\t\tdata->rx_msg_len = msg->msg.data_len - 1;\n\t\tmemcpy(data->rx_msg_data, msg->msg.data + 1, data->rx_msg_len);\n\t} else\n\t\tdata->rx_msg_len = 0;\n\n\tipmi_free_recv_msg(msg);\n\tcomplete(&data->read_complete);\n}\n\nstatic int __init ibmpex_init(void)\n{\n\treturn ipmi_smi_watcher_register(&driver_data.bmc_events);\n}\n\nstatic void __exit ibmpex_exit(void)\n{\n\tstruct ibmpex_bmc_data *p, *next;\n\n\tipmi_smi_watcher_unregister(&driver_data.bmc_events);\n\tlist_for_each_entry_safe(p, next, &driver_data.bmc_data, list)\n\t\tibmpex_bmc_delete(p);\n}\n\nMODULE_AUTHOR(\"Darrick J. Wong <darrick.wong@oracle.com>\");\nMODULE_DESCRIPTION(\"IBM PowerExecutive power/temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(ibmpex_init);\nmodule_exit(ibmpex_exit);\n\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMSystemx3350-*\");\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMSystemx3550-*\");\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMSystemx3650-*\");\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMSystemx3655-*\");\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMSystemx3755-*\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}