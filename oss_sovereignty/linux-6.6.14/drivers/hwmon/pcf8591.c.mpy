{
  "module_name": "pcf8591.c",
  "hash_id": "b81e98bbb0ff16c3acf013b960fcec5e0078937bfb66274ff4bc4eb34041c867",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pcf8591.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/kstrtox.h>\n\n \n\nstatic int input_mode;\nmodule_param(input_mode, int, 0);\nMODULE_PARM_DESC(input_mode,\n\t\"Analog input mode:\\n\"\n\t\" 0 = four single ended inputs\\n\"\n\t\" 1 = three differential inputs\\n\"\n\t\" 2 = single ended and differential mixed\\n\"\n\t\" 3 = two differential inputs\\n\");\n\n \n\n \n#define PCF8591_CONTROL_AOEF\t\t0x40\n\n \n#define PCF8591_CONTROL_AIP_MASK\t0x30\n\n \n#define PCF8591_CONTROL_AINC\t\t0x04\n\n \n#define PCF8591_CONTROL_AICH_MASK\t0x03\n\n \n#define PCF8591_INIT_CONTROL\t((input_mode << 4) | PCF8591_CONTROL_AOEF)\n#define PCF8591_INIT_AOUT\t0\t \n\n \n#define REG_TO_SIGNED(reg)\t(((reg) & 0x80) ? ((reg) - 256) : (reg))\n\nstruct pcf8591_data {\n\tstruct device *hwmon_dev;\n\tstruct mutex update_lock;\n\n\tu8 control;\n\tu8 aout;\n};\n\nstatic void pcf8591_init_client(struct i2c_client *client);\nstatic int pcf8591_read_channel(struct device *dev, int channel);\n\n \n#define show_in_channel(channel)\t\t\t\t\t\\\nstatic ssize_t show_in##channel##_input(struct device *dev,\t\t\\\n\t\t\t\t\tstruct device_attribute *attr,\t\\\n\t\t\t\t\tchar *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%d\\n\", pcf8591_read_channel(dev, channel));\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(in##channel##_input, S_IRUGO,\t\t\t\\\n\t\t   show_in##channel##_input, NULL);\n\nshow_in_channel(0);\nshow_in_channel(1);\nshow_in_channel(2);\nshow_in_channel(3);\n\nstatic ssize_t out0_output_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct pcf8591_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\treturn sprintf(buf, \"%d\\n\", data->aout * 10);\n}\n\nstatic ssize_t out0_output_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tunsigned long val;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pcf8591_data *data = i2c_get_clientdata(client);\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tval /= 10;\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tdata->aout = val;\n\ti2c_smbus_write_byte_data(client, data->control, data->aout);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(out0_output);\n\nstatic ssize_t out0_enable_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct pcf8591_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\treturn sprintf(buf, \"%u\\n\", !(!(data->control & PCF8591_CONTROL_AOEF)));\n}\n\nstatic ssize_t out0_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pcf8591_data *data = i2c_get_clientdata(client);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tif (val)\n\t\tdata->control |= PCF8591_CONTROL_AOEF;\n\telse\n\t\tdata->control &= ~PCF8591_CONTROL_AOEF;\n\ti2c_smbus_write_byte(client, data->control);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(out0_enable);\n\nstatic struct attribute *pcf8591_attributes[] = {\n\t&dev_attr_out0_enable.attr,\n\t&dev_attr_out0_output.attr,\n\t&dev_attr_in0_input.attr,\n\t&dev_attr_in1_input.attr,\n\tNULL\n};\n\nstatic const struct attribute_group pcf8591_attr_group = {\n\t.attrs = pcf8591_attributes,\n};\n\nstatic struct attribute *pcf8591_attributes_opt[] = {\n\t&dev_attr_in2_input.attr,\n\t&dev_attr_in3_input.attr,\n\tNULL\n};\n\nstatic const struct attribute_group pcf8591_attr_group_opt = {\n\t.attrs = pcf8591_attributes_opt,\n};\n\n \n\nstatic int pcf8591_probe(struct i2c_client *client)\n{\n\tstruct pcf8591_data *data;\n\tint err;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct pcf8591_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\n\t \n\tpcf8591_init_client(client);\n\n\t \n\terr = sysfs_create_group(&client->dev.kobj, &pcf8591_attr_group);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (input_mode != 3) {\n\t\terr = device_create_file(&client->dev, &dev_attr_in2_input);\n\t\tif (err)\n\t\t\tgoto exit_sysfs_remove;\n\t}\n\n\t \n\tif (input_mode == 0) {\n\t\terr = device_create_file(&client->dev, &dev_attr_in3_input);\n\t\tif (err)\n\t\t\tgoto exit_sysfs_remove;\n\t}\n\n\tdata->hwmon_dev = hwmon_device_register(&client->dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto exit_sysfs_remove;\n\t}\n\n\treturn 0;\n\nexit_sysfs_remove:\n\tsysfs_remove_group(&client->dev.kobj, &pcf8591_attr_group_opt);\n\tsysfs_remove_group(&client->dev.kobj, &pcf8591_attr_group);\n\treturn err;\n}\n\nstatic void pcf8591_remove(struct i2c_client *client)\n{\n\tstruct pcf8591_data *data = i2c_get_clientdata(client);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tsysfs_remove_group(&client->dev.kobj, &pcf8591_attr_group_opt);\n\tsysfs_remove_group(&client->dev.kobj, &pcf8591_attr_group);\n}\n\n \nstatic void pcf8591_init_client(struct i2c_client *client)\n{\n\tstruct pcf8591_data *data = i2c_get_clientdata(client);\n\tdata->control = PCF8591_INIT_CONTROL;\n\tdata->aout = PCF8591_INIT_AOUT;\n\n\ti2c_smbus_write_byte_data(client, data->control, data->aout);\n\n\t \n\ti2c_smbus_read_byte(client);\n}\n\nstatic int pcf8591_read_channel(struct device *dev, int channel)\n{\n\tu8 value;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pcf8591_data *data = i2c_get_clientdata(client);\n\n\tmutex_lock(&data->update_lock);\n\n\tif ((data->control & PCF8591_CONTROL_AICH_MASK) != channel) {\n\t\tdata->control = (data->control & ~PCF8591_CONTROL_AICH_MASK)\n\t\t\t      | channel;\n\t\ti2c_smbus_write_byte(client, data->control);\n\n\t\t \n\t\ti2c_smbus_read_byte(client);\n\t}\n\tvalue = i2c_smbus_read_byte(client);\n\n\tmutex_unlock(&data->update_lock);\n\n\tif ((channel == 2 && input_mode == 2) ||\n\t    (channel != 3 && (input_mode == 1 || input_mode == 3)))\n\t\treturn 10 * REG_TO_SIGNED(value);\n\telse\n\t\treturn 10 * value;\n}\n\nstatic const struct i2c_device_id pcf8591_id[] = {\n\t{ \"pcf8591\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pcf8591_id);\n\nstatic struct i2c_driver pcf8591_driver = {\n\t.driver = {\n\t\t.name\t= \"pcf8591\",\n\t},\n\t.probe\t\t= pcf8591_probe,\n\t.remove\t\t= pcf8591_remove,\n\t.id_table\t= pcf8591_id,\n};\n\nstatic int __init pcf8591_init(void)\n{\n\tif (input_mode < 0 || input_mode > 3) {\n\t\tpr_warn(\"invalid input_mode (%d)\\n\", input_mode);\n\t\tinput_mode = 0;\n\t}\n\treturn i2c_add_driver(&pcf8591_driver);\n}\n\nstatic void __exit pcf8591_exit(void)\n{\n\ti2c_del_driver(&pcf8591_driver);\n}\n\nMODULE_AUTHOR(\"Aurelien Jarno <aurelien@aurel32.net>\");\nMODULE_DESCRIPTION(\"PCF8591 driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(pcf8591_init);\nmodule_exit(pcf8591_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}