{
  "module_name": "tmp513.c",
  "hash_id": "4870baf21d91e50a1d8993d5f400fe32f2d246b17eeb6f5a27e1394b4bad4129",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/tmp513.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/util_macros.h>\n\n\n#define TMP51X_SHUNT_CONFIG\t\t0x00\n#define TMP51X_TEMP_CONFIG\t\t0x01\n#define TMP51X_STATUS\t\t\t0x02\n#define TMP51X_SMBUS_ALERT\t\t0x03\n#define TMP51X_SHUNT_CURRENT_RESULT\t0x04\n#define TMP51X_BUS_VOLTAGE_RESULT\t0x05\n#define TMP51X_POWER_RESULT\t\t0x06\n#define TMP51X_BUS_CURRENT_RESULT\t0x07\n#define TMP51X_LOCAL_TEMP_RESULT\t0x08\n#define TMP51X_REMOTE_TEMP_RESULT_1\t0x09\n#define TMP51X_REMOTE_TEMP_RESULT_2\t0x0A\n#define TMP51X_SHUNT_CURRENT_H_LIMIT\t0x0C\n#define TMP51X_SHUNT_CURRENT_L_LIMIT\t0x0D\n#define TMP51X_BUS_VOLTAGE_H_LIMIT\t0x0E\n#define TMP51X_BUS_VOLTAGE_L_LIMIT\t0x0F\n#define TMP51X_POWER_LIMIT\t\t0x10\n#define TMP51X_LOCAL_TEMP_LIMIT\t0x11\n#define TMP51X_REMOTE_TEMP_LIMIT_1\t0x12\n#define TMP51X_REMOTE_TEMP_LIMIT_2\t0x13\n#define TMP51X_SHUNT_CALIBRATION\t0x15\n#define TMP51X_N_FACTOR_AND_HYST_1\t0x16\n#define TMP51X_N_FACTOR_2\t\t0x17\n#define TMP51X_MAN_ID_REG\t\t0xFE\n#define TMP51X_DEVICE_ID_REG\t\t0xFF\n\n\n#define TMP513_REMOTE_TEMP_RESULT_3\t0x0B\n#define TMP513_REMOTE_TEMP_LIMIT_3\t0x14\n#define TMP513_N_FACTOR_3\t\t0x18\n\n\n#define TMP51X_MANUFACTURER_ID\t\t0x55FF\n\n#define TMP512_DEVICE_ID\t\t0x22FF\n#define TMP513_DEVICE_ID\t\t0x23FF\n\n\n#define TMP51X_SHUNT_CONFIG_DEFAULT\t0x399F\n#define TMP51X_SHUNT_VALUE_DEFAULT\t1000\n#define TMP51X_VBUS_RANGE_DEFAULT\tTMP51X_VBUS_RANGE_32V\n#define TMP51X_PGA_DEFAULT\t\t8\n#define TMP51X_MAX_REGISTER_ADDR\t0xFF\n\n#define TMP512_TEMP_CONFIG_DEFAULT\t0xBF80\n#define TMP513_TEMP_CONFIG_DEFAULT\t0xFF80\n\n\n#define CURRENT_SENSE_VOLTAGE_320_MASK\t0x1800\n#define CURRENT_SENSE_VOLTAGE_160_MASK\t0x1000\n#define CURRENT_SENSE_VOLTAGE_80_MASK\t0x0800\n#define CURRENT_SENSE_VOLTAGE_40_MASK\t0\n\n#define TMP51X_BUS_VOLTAGE_MASK\t\t0x2000\n#define TMP51X_NFACTOR_MASK\t\t0xFF00\n#define TMP51X_HYST_MASK\t\t0x00FF\n\n#define TMP51X_BUS_VOLTAGE_SHIFT\t3\n#define TMP51X_TEMP_SHIFT\t\t3\n\n\n#define TMP51X_SHUNT_CURRENT_H_LIMIT_POS\t15\n#define TMP51X_SHUNT_CURRENT_L_LIMIT_POS\t14\n#define TMP51X_BUS_VOLTAGE_H_LIMIT_POS\t\t13\n#define TMP51X_BUS_VOLTAGE_L_LIMIT_POS\t\t12\n#define TMP51X_POWER_LIMIT_POS\t\t\t11\n#define TMP51X_LOCAL_TEMP_LIMIT_POS\t\t10\n#define TMP51X_REMOTE_TEMP_LIMIT_1_POS\t\t9\n#define TMP51X_REMOTE_TEMP_LIMIT_2_POS\t\t8\n#define TMP513_REMOTE_TEMP_LIMIT_3_POS\t\t7\n\n#define TMP51X_VBUS_RANGE_32V\t\t32000000\n#define TMP51X_VBUS_RANGE_16V\t\t16000000\n\n\n#define MAX_BUS_VOLTAGE_32_LIMIT\t32764\n#define MAX_BUS_VOLTAGE_16_LIMIT\t16382\n\n\n#define MAX_TEMP_LIMIT\t\t\t125000\n#define MIN_TEMP_LIMIT\t\t\t-40000\n\n#define MAX_TEMP_HYST\t\t\t127500\n\nstatic const u8 TMP51X_TEMP_INPUT[4] = {\n\tTMP51X_LOCAL_TEMP_RESULT,\n\tTMP51X_REMOTE_TEMP_RESULT_1,\n\tTMP51X_REMOTE_TEMP_RESULT_2,\n\tTMP513_REMOTE_TEMP_RESULT_3\n};\n\nstatic const u8 TMP51X_TEMP_CRIT[4] = {\n\tTMP51X_LOCAL_TEMP_LIMIT,\n\tTMP51X_REMOTE_TEMP_LIMIT_1,\n\tTMP51X_REMOTE_TEMP_LIMIT_2,\n\tTMP513_REMOTE_TEMP_LIMIT_3\n};\n\nstatic const u8 TMP51X_TEMP_CRIT_ALARM[4] = {\n\tTMP51X_LOCAL_TEMP_LIMIT_POS,\n\tTMP51X_REMOTE_TEMP_LIMIT_1_POS,\n\tTMP51X_REMOTE_TEMP_LIMIT_2_POS,\n\tTMP513_REMOTE_TEMP_LIMIT_3_POS\n};\n\nstatic const u8 TMP51X_TEMP_CRIT_HYST[4] = {\n\tTMP51X_N_FACTOR_AND_HYST_1,\n\tTMP51X_N_FACTOR_AND_HYST_1,\n\tTMP51X_N_FACTOR_AND_HYST_1,\n\tTMP51X_N_FACTOR_AND_HYST_1\n};\n\nstatic const u8 TMP51X_CURR_INPUT[2] = {\n\tTMP51X_SHUNT_CURRENT_RESULT,\n\tTMP51X_BUS_CURRENT_RESULT\n};\n\nstatic struct regmap_config tmp51x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = TMP51X_MAX_REGISTER_ADDR,\n};\n\nenum tmp51x_ids {\n\ttmp512, tmp513\n};\n\nstruct tmp51x_data {\n\tu16 shunt_config;\n\tu16 pga_gain;\n\tu32 vbus_range_uvolt;\n\n\tu16 temp_config;\n\tu32 nfactor[3];\n\n\tu32 shunt_uohms;\n\n\tu32 curr_lsb_ua;\n\tu32 pwr_lsb_uw;\n\n\tenum tmp51x_ids id;\n\tstruct regmap *regmap;\n};\n\n\nstatic inline u8 tmp51x_get_pga_shift(struct tmp51x_data *data)\n{\n\treturn 5 - ffs(data->pga_gain);\n}\n\nstatic int tmp51x_get_value(struct tmp51x_data *data, u8 reg, u8 pos,\n\t\t\t    unsigned int regval, long *val)\n{\n\tswitch (reg) {\n\tcase TMP51X_STATUS:\n\t\t*val = (regval >> pos) & 1;\n\t\tbreak;\n\tcase TMP51X_SHUNT_CURRENT_RESULT:\n\tcase TMP51X_SHUNT_CURRENT_H_LIMIT:\n\tcase TMP51X_SHUNT_CURRENT_L_LIMIT:\n\t\t \n\t\t*val = sign_extend32(regval, 17 - tmp51x_get_pga_shift(data));\n\t\t*val = DIV_ROUND_CLOSEST(*val * 10000, data->shunt_uohms);\n\t\tbreak;\n\tcase TMP51X_BUS_VOLTAGE_RESULT:\n\tcase TMP51X_BUS_VOLTAGE_H_LIMIT:\n\tcase TMP51X_BUS_VOLTAGE_L_LIMIT:\n\t\t\n\t\t*val = (regval >> TMP51X_BUS_VOLTAGE_SHIFT) * 4;\n\t\tbreak;\n\tcase TMP51X_POWER_RESULT:\n\tcase TMP51X_POWER_LIMIT:\n\t\t\n\t\t*val = regval * data->pwr_lsb_uw;\n\t\tbreak;\n\tcase TMP51X_BUS_CURRENT_RESULT:\n\t\t\n\t\t*val = sign_extend32(regval, 16) * data->curr_lsb_ua;\n\t\t*val = DIV_ROUND_CLOSEST(*val, 1000);\n\t\tbreak;\n\tcase TMP51X_LOCAL_TEMP_RESULT:\n\tcase TMP51X_REMOTE_TEMP_RESULT_1:\n\tcase TMP51X_REMOTE_TEMP_RESULT_2:\n\tcase TMP513_REMOTE_TEMP_RESULT_3:\n\tcase TMP51X_LOCAL_TEMP_LIMIT:\n\tcase TMP51X_REMOTE_TEMP_LIMIT_1:\n\tcase TMP51X_REMOTE_TEMP_LIMIT_2:\n\tcase TMP513_REMOTE_TEMP_LIMIT_3:\n\t\t\n\t\t*val = sign_extend32(regval, 16) >> TMP51X_TEMP_SHIFT;\n\t\t*val = DIV_ROUND_CLOSEST(*val * 625, 10);\n\t\tbreak;\n\tcase TMP51X_N_FACTOR_AND_HYST_1:\n\t\t\n\t\t*val = (regval & TMP51X_HYST_MASK) * 500;\n\t\tbreak;\n\tdefault:\n\t\t\n\t\tWARN_ON_ONCE(1);\n\t\t*val = 0;\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int tmp51x_set_value(struct tmp51x_data *data, u8 reg, long val)\n{\n\tint regval, max_val;\n\tu32 mask = 0;\n\n\tswitch (reg) {\n\tcase TMP51X_SHUNT_CURRENT_H_LIMIT:\n\tcase TMP51X_SHUNT_CURRENT_L_LIMIT:\n\t\t \n\t\tval = DIV_ROUND_CLOSEST(val * data->shunt_uohms, 10000);\n\t\tmax_val = U16_MAX >> tmp51x_get_pga_shift(data);\n\t\tregval = clamp_val(val, -max_val, max_val);\n\t\tbreak;\n\tcase TMP51X_BUS_VOLTAGE_H_LIMIT:\n\tcase TMP51X_BUS_VOLTAGE_L_LIMIT:\n\t\t\n\t\tmax_val = (data->vbus_range_uvolt == TMP51X_VBUS_RANGE_32V) ?\n\t\t\tMAX_BUS_VOLTAGE_32_LIMIT : MAX_BUS_VOLTAGE_16_LIMIT;\n\n\t\tval = clamp_val(DIV_ROUND_CLOSEST(val, 4), 0, max_val);\n\t\tregval = val << TMP51X_BUS_VOLTAGE_SHIFT;\n\t\tbreak;\n\tcase TMP51X_POWER_LIMIT:\n\t\tregval = clamp_val(DIV_ROUND_CLOSEST(val, data->pwr_lsb_uw), 0,\n\t\t\t\t   U16_MAX);\n\t\tbreak;\n\tcase TMP51X_LOCAL_TEMP_LIMIT:\n\tcase TMP51X_REMOTE_TEMP_LIMIT_1:\n\tcase TMP51X_REMOTE_TEMP_LIMIT_2:\n\tcase TMP513_REMOTE_TEMP_LIMIT_3:\n\t\t\n\t\tval = clamp_val(val, MIN_TEMP_LIMIT, MAX_TEMP_LIMIT);\n\t\tregval = DIV_ROUND_CLOSEST(val * 10, 625) << TMP51X_TEMP_SHIFT;\n\t\tbreak;\n\tcase TMP51X_N_FACTOR_AND_HYST_1:\n\t\t\n\t\tval = clamp_val(val, 0, MAX_TEMP_HYST);\n\t\tregval = DIV_ROUND_CLOSEST(val, 500);\n\t\tmask = TMP51X_HYST_MASK;\n\t\tbreak;\n\tdefault:\n\t\t\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (mask == 0)\n\t\treturn regmap_write(data->regmap, reg, regval);\n\telse\n\t\treturn regmap_update_bits(data->regmap, reg, mask, regval);\n}\n\nstatic u8 tmp51x_get_reg(enum hwmon_sensor_types type, u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\treturn TMP51X_TEMP_INPUT[channel];\n\t\tcase hwmon_temp_crit_alarm:\n\t\t\treturn TMP51X_STATUS;\n\t\tcase hwmon_temp_crit:\n\t\t\treturn TMP51X_TEMP_CRIT[channel];\n\t\tcase hwmon_temp_crit_hyst:\n\t\t\treturn TMP51X_TEMP_CRIT_HYST[channel];\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\treturn TMP51X_BUS_VOLTAGE_RESULT;\n\t\tcase hwmon_in_lcrit_alarm:\n\t\tcase hwmon_in_crit_alarm:\n\t\t\treturn TMP51X_STATUS;\n\t\tcase hwmon_in_lcrit:\n\t\t\treturn TMP51X_BUS_VOLTAGE_L_LIMIT;\n\t\tcase hwmon_in_crit:\n\t\t\treturn TMP51X_BUS_VOLTAGE_H_LIMIT;\n\t\t}\n\t\tbreak;\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_input:\n\t\t\treturn TMP51X_CURR_INPUT[channel];\n\t\tcase hwmon_curr_lcrit_alarm:\n\t\tcase hwmon_curr_crit_alarm:\n\t\t\treturn TMP51X_STATUS;\n\t\tcase hwmon_curr_lcrit:\n\t\t\treturn TMP51X_SHUNT_CURRENT_L_LIMIT;\n\t\tcase hwmon_curr_crit:\n\t\t\treturn TMP51X_SHUNT_CURRENT_H_LIMIT;\n\t\t}\n\t\tbreak;\n\tcase hwmon_power:\n\t\tswitch (attr) {\n\t\tcase hwmon_power_input:\n\t\t\treturn TMP51X_POWER_RESULT;\n\t\tcase hwmon_power_crit_alarm:\n\t\t\treturn TMP51X_STATUS;\n\t\tcase hwmon_power_crit:\n\t\t\treturn TMP51X_POWER_LIMIT;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 tmp51x_get_status_pos(enum hwmon_sensor_types type, u32 attr,\n\t\t\t\tint channel)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_crit_alarm:\n\t\t\treturn TMP51X_TEMP_CRIT_ALARM[channel];\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_lcrit_alarm:\n\t\t\treturn TMP51X_BUS_VOLTAGE_L_LIMIT_POS;\n\t\tcase hwmon_in_crit_alarm:\n\t\t\treturn TMP51X_BUS_VOLTAGE_H_LIMIT_POS;\n\t\t}\n\t\tbreak;\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_lcrit_alarm:\n\t\t\treturn TMP51X_SHUNT_CURRENT_L_LIMIT_POS;\n\t\tcase hwmon_curr_crit_alarm:\n\t\t\treturn TMP51X_SHUNT_CURRENT_H_LIMIT_POS;\n\t\t}\n\t\tbreak;\n\tcase hwmon_power:\n\t\tswitch (attr) {\n\t\tcase hwmon_power_crit_alarm:\n\t\t\treturn TMP51X_POWER_LIMIT_POS;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tmp51x_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long *val)\n{\n\tstruct tmp51x_data *data = dev_get_drvdata(dev);\n\tint ret;\n\tu32 regval;\n\tu8 pos = 0, reg = 0;\n\n\treg = tmp51x_get_reg(type, attr, channel);\n\tif (reg == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (reg == TMP51X_STATUS)\n\t\tpos = tmp51x_get_status_pos(type, attr, channel);\n\n\tret = regmap_read(data->regmap, reg, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn tmp51x_get_value(data, reg, pos, regval, val);\n}\n\nstatic int tmp51x_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long val)\n{\n\tu8 reg = 0;\n\n\treg = tmp51x_get_reg(type, attr, channel);\n\tif (reg == 0)\n\t\treturn -EOPNOTSUPP;\n\n\treturn tmp51x_set_value(dev_get_drvdata(dev), reg, val);\n}\n\nstatic umode_t tmp51x_is_visible(const void *_data,\n\t\t\t\t enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t int channel)\n{\n\tconst struct tmp51x_data *data = _data;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tif (data->id == tmp512 && channel == 3)\n\t\t\treturn 0;\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_crit_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_crit:\n\t\t\treturn 0644;\n\t\tcase hwmon_temp_crit_hyst:\n\t\t\tif (channel == 0)\n\t\t\t\treturn 0644;\n\t\t\treturn 0444;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\tcase hwmon_in_lcrit_alarm:\n\t\tcase hwmon_in_crit_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_in_lcrit:\n\t\tcase hwmon_in_crit:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tcase hwmon_curr:\n\t\tif (!data->shunt_uohms)\n\t\t\treturn 0;\n\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_input:\n\t\tcase hwmon_curr_lcrit_alarm:\n\t\tcase hwmon_curr_crit_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_curr_lcrit:\n\t\tcase hwmon_curr_crit:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tcase hwmon_power:\n\t\tif (!data->shunt_uohms)\n\t\t\treturn 0;\n\n\t\tswitch (attr) {\n\t\tcase hwmon_power_input:\n\t\tcase hwmon_power_crit_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_power_crit:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const tmp51x_info[] = {\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_CRIT_ALARM |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_CRIT_ALARM |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_CRIT_ALARM |\n\t\t\t   HWMON_T_CRIT_HYST,\n\t\t\t   HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_CRIT_ALARM |\n\t\t\t   HWMON_T_CRIT_HYST),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LCRIT | HWMON_I_LCRIT_ALARM |\n\t\t\t   HWMON_I_CRIT | HWMON_I_CRIT_ALARM),\n\tHWMON_CHANNEL_INFO(curr,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LCRIT | HWMON_C_LCRIT_ALARM |\n\t\t\t   HWMON_C_CRIT | HWMON_C_CRIT_ALARM,\n\t\t\t   HWMON_C_INPUT),\n\tHWMON_CHANNEL_INFO(power,\n\t\t\t   HWMON_P_INPUT | HWMON_P_CRIT | HWMON_P_CRIT_ALARM),\n\tNULL\n};\n\nstatic const struct hwmon_ops tmp51x_hwmon_ops = {\n\t.is_visible = tmp51x_is_visible,\n\t.read = tmp51x_read,\n\t.write = tmp51x_write,\n};\n\nstatic const struct hwmon_chip_info tmp51x_chip_info = {\n\t.ops = &tmp51x_hwmon_ops,\n\t.info = tmp51x_info,\n};\n\n \nstatic int tmp51x_calibrate(struct tmp51x_data *data)\n{\n\tint vshunt_max = data->pga_gain * 40;\n\tu64 max_curr_ma;\n\tu32 div;\n\n\t \n\tif (data->shunt_uohms == 0)\n\t\treturn regmap_write(data->regmap, TMP51X_SHUNT_CALIBRATION, 0);\n\n\tmax_curr_ma = DIV_ROUND_CLOSEST_ULL(vshunt_max * 1000 * 1000,\n\t\t\t\t\t    data->shunt_uohms);\n\n\t \n\tdata->curr_lsb_ua = DIV_ROUND_CLOSEST_ULL(max_curr_ma * 1000, 32767);\n\tdata->pwr_lsb_uw = 20 * data->curr_lsb_ua;\n\n\tdiv = DIV_ROUND_CLOSEST_ULL(data->curr_lsb_ua * data->shunt_uohms,\n\t\t\t\t    1000 * 1000);\n\n\treturn regmap_write(data->regmap, TMP51X_SHUNT_CALIBRATION,\n\t\t\t    DIV_ROUND_CLOSEST(40960, div));\n}\n\n \nstatic int tmp51x_init(struct tmp51x_data *data)\n{\n\tunsigned int regval;\n\tint ret = regmap_write(data->regmap, TMP51X_SHUNT_CONFIG,\n\t\t\t       data->shunt_config);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(data->regmap, TMP51X_TEMP_CONFIG, data->temp_config);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t\n\tret = regmap_update_bits(data->regmap, TMP51X_N_FACTOR_AND_HYST_1,\n\t\t\t\t TMP51X_NFACTOR_MASK, data->nfactor[0] << 8);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(data->regmap, TMP51X_N_FACTOR_2,\n\t\t\t   data->nfactor[1] << 8);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (data->id == tmp513) {\n\t\tret = regmap_write(data->regmap, TMP513_N_FACTOR_3,\n\t\t\t\t   data->nfactor[2] << 8);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = tmp51x_calibrate(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t\n\treturn regmap_read(data->regmap, TMP51X_STATUS, &regval);\n}\n\nstatic const struct i2c_device_id tmp51x_id[] = {\n\t{ \"tmp512\", tmp512 },\n\t{ \"tmp513\", tmp513 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tmp51x_id);\n\nstatic const struct of_device_id tmp51x_of_match[] = {\n\t{\n\t\t.compatible = \"ti,tmp512\",\n\t\t.data = (void *)tmp512\n\t},\n\t{\n\t\t.compatible = \"ti,tmp513\",\n\t\t.data = (void *)tmp513\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tmp51x_of_match);\n\nstatic int tmp51x_vbus_range_to_reg(struct device *dev,\n\t\t\t\t    struct tmp51x_data *data)\n{\n\tif (data->vbus_range_uvolt == TMP51X_VBUS_RANGE_32V) {\n\t\tdata->shunt_config |= TMP51X_BUS_VOLTAGE_MASK;\n\t} else if (data->vbus_range_uvolt == TMP51X_VBUS_RANGE_16V) {\n\t\tdata->shunt_config &= ~TMP51X_BUS_VOLTAGE_MASK;\n\t} else {\n\t\tdev_err(dev, \"ti,bus-range-microvolt is invalid: %u\\n\",\n\t\t\tdata->vbus_range_uvolt);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int tmp51x_pga_gain_to_reg(struct device *dev, struct tmp51x_data *data)\n{\n\tif (data->pga_gain == 8) {\n\t\tdata->shunt_config |= CURRENT_SENSE_VOLTAGE_320_MASK;\n\t} else if (data->pga_gain == 4) {\n\t\tdata->shunt_config |= CURRENT_SENSE_VOLTAGE_160_MASK;\n\t} else if (data->pga_gain == 2) {\n\t\tdata->shunt_config |= CURRENT_SENSE_VOLTAGE_80_MASK;\n\t} else if (data->pga_gain == 1) {\n\t\tdata->shunt_config |= CURRENT_SENSE_VOLTAGE_40_MASK;\n\t} else {\n\t\tdev_err(dev, \"ti,pga-gain is invalid: %u\\n\", data->pga_gain);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int tmp51x_read_properties(struct device *dev, struct tmp51x_data *data)\n{\n\tint ret;\n\tu32 nfactor[3];\n\tu32 val;\n\n\tret = device_property_read_u32(dev, \"shunt-resistor-micro-ohms\", &val);\n\tdata->shunt_uohms = (ret >= 0) ? val : TMP51X_SHUNT_VALUE_DEFAULT;\n\n\tret = device_property_read_u32(dev, \"ti,bus-range-microvolt\", &val);\n\tdata->vbus_range_uvolt = (ret >= 0) ? val : TMP51X_VBUS_RANGE_DEFAULT;\n\tret = tmp51x_vbus_range_to_reg(dev, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = device_property_read_u32(dev, \"ti,pga-gain\", &val);\n\tdata->pga_gain = (ret >= 0) ? val : TMP51X_PGA_DEFAULT;\n\tret = tmp51x_pga_gain_to_reg(dev, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = device_property_read_u32_array(dev, \"ti,nfactor\", nfactor,\n\t\t\t\t\t    (data->id == tmp513) ? 3 : 2);\n\tif (ret >= 0)\n\t\tmemcpy(data->nfactor, nfactor, (data->id == tmp513) ? 3 : 2);\n\n\t\n\tif (data->shunt_uohms > data->pga_gain * 40 * 1000 * 1000) {\n\t\tdev_err(dev, \"shunt-resistor: %u too big for pga_gain: %u\\n\",\n\t\t\tdata->shunt_uohms, data->pga_gain);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void tmp51x_use_default(struct tmp51x_data *data)\n{\n\tdata->vbus_range_uvolt = TMP51X_VBUS_RANGE_DEFAULT;\n\tdata->pga_gain = TMP51X_PGA_DEFAULT;\n\tdata->shunt_uohms = TMP51X_SHUNT_VALUE_DEFAULT;\n}\n\nstatic int tmp51x_configure(struct device *dev, struct tmp51x_data *data)\n{\n\tdata->shunt_config = TMP51X_SHUNT_CONFIG_DEFAULT;\n\tdata->temp_config = (data->id == tmp513) ?\n\t\t\tTMP513_TEMP_CONFIG_DEFAULT : TMP512_TEMP_CONFIG_DEFAULT;\n\n\tif (dev->of_node)\n\t\treturn tmp51x_read_properties(dev, data);\n\n\ttmp51x_use_default(data);\n\n\treturn 0;\n}\n\nstatic int tmp51x_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tmp51x_data *data;\n\tstruct device *hwmon_dev;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->id = (uintptr_t)i2c_get_match_data(client);\n\n\tret = tmp51x_configure(dev, data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error configuring the device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata->regmap = devm_regmap_init_i2c(client, &tmp51x_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\tret = tmp51x_init(data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error configuring the device: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &tmp51x_chip_info,\n\t\t\t\t\t\t\t NULL);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdev_dbg(dev, \"power monitor %s\\n\", client->name);\n\n\treturn 0;\n}\n\nstatic struct i2c_driver tmp51x_driver = {\n\t.driver = {\n\t\t.name\t= \"tmp51x\",\n\t\t.of_match_table = tmp51x_of_match,\n\t},\n\t.probe\t\t= tmp51x_probe,\n\t.id_table\t= tmp51x_id,\n};\n\nmodule_i2c_driver(tmp51x_driver);\n\nMODULE_AUTHOR(\"Eric Tremblay <etremblay@distechcontrols.com>\");\nMODULE_DESCRIPTION(\"tmp51x driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}