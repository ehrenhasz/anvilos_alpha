{
  "module_name": "gxp-fan-ctrl.c",
  "hash_id": "e3d5352596954467017810fb96ce589ac67a1663a18c072c11cfe11c2dcc1e6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/gxp-fan-ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n\n#define OFS_FAN_INST\t0  \n#define OFS_FAN_FAIL\t2  \n#define OFS_SEVSTAT\t0  \n#define POWER_BIT\t24\n\nstruct gxp_fan_ctrl_drvdata {\n\tvoid __iomem\t*base;\n\tvoid __iomem\t*plreg;\n\tvoid __iomem\t*fn2;\n};\n\nstatic bool fan_installed(struct device *dev, int fan)\n{\n\tstruct gxp_fan_ctrl_drvdata *drvdata = dev_get_drvdata(dev);\n\tu8 val;\n\n\tval = readb(drvdata->plreg + OFS_FAN_INST);\n\n\treturn !!(val & BIT(fan));\n}\n\nstatic long fan_failed(struct device *dev, int fan)\n{\n\tstruct gxp_fan_ctrl_drvdata *drvdata = dev_get_drvdata(dev);\n\tu8 val;\n\n\tval = readb(drvdata->plreg + OFS_FAN_FAIL);\n\n\treturn !!(val & BIT(fan));\n}\n\nstatic long fan_enabled(struct device *dev, int fan)\n{\n\tstruct gxp_fan_ctrl_drvdata *drvdata = dev_get_drvdata(dev);\n\tu32 val;\n\n\t \n\tval = readl(drvdata->fn2 + OFS_SEVSTAT);\n\n\treturn !!((val & BIT(POWER_BIT)) && fan_installed(dev, fan));\n}\n\nstatic int gxp_pwm_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct gxp_fan_ctrl_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\tif (val > 255 || val < 0)\n\t\t\treturn -EINVAL;\n\t\twriteb(val, drvdata->base + channel);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int gxp_fan_ctrl_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\treturn gxp_pwm_write(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int gxp_fan_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tswitch (attr) {\n\tcase hwmon_fan_enable:\n\t\t*val = fan_enabled(dev, channel);\n\t\treturn 0;\n\tcase hwmon_fan_fault:\n\t\t*val = fan_failed(dev, channel);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int gxp_pwm_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct gxp_fan_ctrl_drvdata *drvdata = dev_get_drvdata(dev);\n\tu32 reg;\n\n\t \n\n\treg = readl(drvdata->fn2 + OFS_SEVSTAT);\n\n\tif (reg & BIT(POWER_BIT))\n\t\t*val = fan_installed(dev, channel) ? readb(drvdata->base + channel) : 0;\n\telse\n\t\t*val = 0;\n\n\treturn 0;\n}\n\nstatic int gxp_fan_ctrl_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\treturn gxp_fan_read(dev, attr, channel, val);\n\tcase hwmon_pwm:\n\t\treturn gxp_pwm_read(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t gxp_fan_ctrl_is_visible(const void *_data,\n\t\t\t\t       enum hwmon_sensor_types type,\n\t\t\t\t       u32 attr, int channel)\n{\n\tumode_t mode = 0;\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_enable:\n\t\tcase hwmon_fan_fault:\n\t\t\tmode = 0444;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\tmode = 0644;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n\nstatic const struct hwmon_ops gxp_fan_ctrl_ops = {\n\t.is_visible = gxp_fan_ctrl_is_visible,\n\t.read = gxp_fan_ctrl_read,\n\t.write = gxp_fan_ctrl_write,\n};\n\nstatic const struct hwmon_channel_info * const gxp_fan_ctrl_info[] = {\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_FAULT | HWMON_F_ENABLE,\n\t\t\t   HWMON_F_FAULT | HWMON_F_ENABLE),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info gxp_fan_ctrl_chip_info = {\n\t.ops = &gxp_fan_ctrl_ops,\n\t.info = gxp_fan_ctrl_info,\n\n};\n\nstatic int gxp_fan_ctrl_probe(struct platform_device *pdev)\n{\n\tstruct gxp_fan_ctrl_drvdata *drvdata;\n\tstruct device *dev = &pdev->dev;\n\tstruct device *hwmon_dev;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(struct gxp_fan_ctrl_drvdata),\n\t\t\t       GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(drvdata->base))\n\t\treturn dev_err_probe(dev, PTR_ERR(drvdata->base),\n\t\t\t\t     \"failed to map base\\n\");\n\n\tdrvdata->plreg = devm_platform_ioremap_resource_byname(pdev,\n\t\t\t\t\t\t\t       \"pl\");\n\tif (IS_ERR(drvdata->plreg))\n\t\treturn dev_err_probe(dev, PTR_ERR(drvdata->plreg),\n\t\t\t\t     \"failed to map plreg\\n\");\n\n\tdrvdata->fn2 = devm_platform_ioremap_resource_byname(pdev,\n\t\t\t\t\t\t\t     \"fn2\");\n\tif (IS_ERR(drvdata->fn2))\n\t\treturn dev_err_probe(dev, PTR_ERR(drvdata->fn2),\n\t\t\t\t     \"failed to map fn2\\n\");\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&pdev->dev,\n\t\t\t\t\t\t\t \"hpe_gxp_fan_ctrl\",\n\t\t\t\t\t\t\t drvdata,\n\t\t\t\t\t\t\t &gxp_fan_ctrl_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct of_device_id gxp_fan_ctrl_of_match[] = {\n\t{ .compatible = \"hpe,gxp-fan-ctrl\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, gxp_fan_ctrl_of_match);\n\nstatic struct platform_driver gxp_fan_ctrl_driver = {\n\t.probe\t\t= gxp_fan_ctrl_probe,\n\t.driver = {\n\t\t.name\t= \"gxp-fan-ctrl\",\n\t\t.of_match_table = gxp_fan_ctrl_of_match,\n\t},\n};\nmodule_platform_driver(gxp_fan_ctrl_driver);\n\nMODULE_AUTHOR(\"Nick Hawkins <nick.hawkins@hpe.com>\");\nMODULE_DESCRIPTION(\"HPE GXP fan controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}