{
  "module_name": "ftsteutates.c",
  "hash_id": "6f1d9905a3642a8113fe6c92f5237d891a72f672bed3163979c1a81a1593b39e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ftsteutates.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/watchdog.h>\n\n#define FTS_DEVICE_ID_REG\t\t0x0000\n#define FTS_DEVICE_REVISION_REG\t\t0x0001\n#define FTS_DEVICE_STATUS_REG\t\t0x0004\n#define FTS_SATELLITE_STATUS_REG\t0x0005\n#define FTS_EVENT_STATUS_REG\t\t0x0006\n#define FTS_GLOBAL_CONTROL_REG\t\t0x0007\n\n#define FTS_DEVICE_DETECT_REG_1\t\t0x0C\n#define FTS_DEVICE_DETECT_REG_2\t\t0x0D\n#define FTS_DEVICE_DETECT_REG_3\t\t0x0E\n\n#define FTS_SENSOR_EVENT_REG\t\t0x0010\n\n#define FTS_FAN_EVENT_REG\t\t0x0014\n#define FTS_FAN_PRESENT_REG\t\t0x0015\n\n#define FTS_POWER_ON_TIME_COUNTER_A\t0x007A\n#define FTS_POWER_ON_TIME_COUNTER_B\t0x007B\n#define FTS_POWER_ON_TIME_COUNTER_C\t0x007C\n\n#define FTS_PAGE_SELECT_REG\t\t0x007F\n\n#define FTS_WATCHDOG_TIME_PRESET\t0x000B\n#define FTS_WATCHDOG_CONTROL\t\t0x5081\n\n#define FTS_NO_FAN_SENSORS\t\t0x08\n#define FTS_NO_TEMP_SENSORS\t\t0x10\n#define FTS_NO_VOLT_SENSORS\t\t0x04\n\n#define FTS_FAN_SOURCE_INVALID\t\t0xff\n\nstatic const unsigned short normal_i2c[] = { 0x73, I2C_CLIENT_END };\n\nstatic const struct i2c_device_id fts_id[] = {\n\t{ \"ftsteutates\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, fts_id);\n\nenum WATCHDOG_RESOLUTION {\n\tseconds = 1,\n\tminutes = 60\n};\n\nstruct fts_data {\n\tstruct i2c_client *client;\n\t \n\tstruct mutex update_lock;\n\t \n\tstruct mutex access_lock;\n\tunsigned long last_updated;  \n\tstruct watchdog_device wdd;\n\tenum WATCHDOG_RESOLUTION resolution;\n\tbool valid;  \n\n\tu8 volt[FTS_NO_VOLT_SENSORS];\n\n\tu8 temp_input[FTS_NO_TEMP_SENSORS];\n\tu8 temp_alarm;\n\n\tu8 fan_present;\n\tu8 fan_input[FTS_NO_FAN_SENSORS];  \n\tu8 fan_source[FTS_NO_FAN_SENSORS];\n\tu8 fan_alarm;\n};\n\n#define FTS_REG_FAN_INPUT(idx) ((idx) + 0x20)\n#define FTS_REG_FAN_SOURCE(idx) ((idx) + 0x30)\n#define FTS_REG_FAN_CONTROL(idx) (((idx) << 16) + 0x4881)\n\n#define FTS_REG_TEMP_INPUT(idx) ((idx) + 0x40)\n#define FTS_REG_TEMP_CONTROL(idx) (((idx) << 16) + 0x0681)\n\n#define FTS_REG_VOLT(idx) ((idx) + 0x18)\n\n \n \n \nstatic int fts_read_byte(struct i2c_client *client, unsigned short reg)\n{\n\tint ret;\n\tunsigned char page = reg >> 8;\n\tstruct fts_data *data = dev_get_drvdata(&client->dev);\n\n\tmutex_lock(&data->access_lock);\n\n\tdev_dbg(&client->dev, \"page select - page: 0x%.02x\\n\", page);\n\tret = i2c_smbus_write_byte_data(client, FTS_PAGE_SELECT_REG, page);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treg &= 0xFF;\n\tret = i2c_smbus_read_byte_data(client, reg);\n\tdev_dbg(&client->dev, \"read - reg: 0x%.02x: val: 0x%.02x\\n\", reg, ret);\n\nerror:\n\tmutex_unlock(&data->access_lock);\n\treturn ret;\n}\n\nstatic int fts_write_byte(struct i2c_client *client, unsigned short reg,\n\t\t\t  unsigned char value)\n{\n\tint ret;\n\tunsigned char page = reg >> 8;\n\tstruct fts_data *data = dev_get_drvdata(&client->dev);\n\n\tmutex_lock(&data->access_lock);\n\n\tdev_dbg(&client->dev, \"page select - page: 0x%.02x\\n\", page);\n\tret = i2c_smbus_write_byte_data(client, FTS_PAGE_SELECT_REG, page);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treg &= 0xFF;\n\tdev_dbg(&client->dev,\n\t\t\"write - reg: 0x%.02x: val: 0x%.02x\\n\", reg, value);\n\tret = i2c_smbus_write_byte_data(client, reg, value);\n\nerror:\n\tmutex_unlock(&data->access_lock);\n\treturn ret;\n}\n\n \n \n \nstatic int fts_update_device(struct fts_data *data)\n{\n\tint i;\n\tint err = 0;\n\n\tmutex_lock(&data->update_lock);\n\tif (!time_after(jiffies, data->last_updated + 2 * HZ) && data->valid)\n\t\tgoto exit;\n\n\terr = fts_read_byte(data->client, FTS_DEVICE_STATUS_REG);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tdata->valid = !!(err & 0x02);  \n\tif (unlikely(!data->valid)) {\n\t\terr = -EAGAIN;\n\t\tgoto exit;\n\t}\n\n\terr = fts_read_byte(data->client, FTS_FAN_PRESENT_REG);\n\tif (err < 0)\n\t\tgoto exit;\n\tdata->fan_present = err;\n\n\terr = fts_read_byte(data->client, FTS_FAN_EVENT_REG);\n\tif (err < 0)\n\t\tgoto exit;\n\tdata->fan_alarm = err;\n\n\tfor (i = 0; i < FTS_NO_FAN_SENSORS; i++) {\n\t\tif (data->fan_present & BIT(i)) {\n\t\t\terr = fts_read_byte(data->client, FTS_REG_FAN_INPUT(i));\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t\tdata->fan_input[i] = err;\n\n\t\t\terr = fts_read_byte(data->client,\n\t\t\t\t\t    FTS_REG_FAN_SOURCE(i));\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t\tdata->fan_source[i] = err;\n\t\t} else {\n\t\t\tdata->fan_input[i] = 0;\n\t\t\tdata->fan_source[i] = FTS_FAN_SOURCE_INVALID;\n\t\t}\n\t}\n\n\terr = fts_read_byte(data->client, FTS_SENSOR_EVENT_REG);\n\tif (err < 0)\n\t\tgoto exit;\n\tdata->temp_alarm = err;\n\n\tfor (i = 0; i < FTS_NO_TEMP_SENSORS; i++) {\n\t\terr = fts_read_byte(data->client, FTS_REG_TEMP_INPUT(i));\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\t\tdata->temp_input[i] = err;\n\t}\n\n\tfor (i = 0; i < FTS_NO_VOLT_SENSORS; i++) {\n\t\terr = fts_read_byte(data->client, FTS_REG_VOLT(i));\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\t\tdata->volt[i] = err;\n\t}\n\tdata->last_updated = jiffies;\n\terr = 0;\nexit:\n\tmutex_unlock(&data->update_lock);\n\treturn err;\n}\n\n \n \n \nstatic int fts_wd_set_resolution(struct fts_data *data,\n\t\t\t\t enum WATCHDOG_RESOLUTION resolution)\n{\n\tint ret;\n\n\tif (data->resolution == resolution)\n\t\treturn 0;\n\n\tret = fts_read_byte(data->client, FTS_WATCHDOG_CONTROL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((resolution == seconds && ret & BIT(1)) ||\n\t    (resolution == minutes && (ret & BIT(1)) == 0)) {\n\t\tdata->resolution = resolution;\n\t\treturn 0;\n\t}\n\n\tif (resolution == seconds)\n\t\tret |= BIT(1);\n\telse\n\t\tret &= ~BIT(1);\n\n\tret = fts_write_byte(data->client, FTS_WATCHDOG_CONTROL, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->resolution = resolution;\n\treturn ret;\n}\n\nstatic int fts_wd_set_timeout(struct watchdog_device *wdd, unsigned int timeout)\n{\n\tstruct fts_data *data;\n\tenum WATCHDOG_RESOLUTION resolution = seconds;\n\tint ret;\n\n\tdata = watchdog_get_drvdata(wdd);\n\t \n\tif (timeout > 0xFF) {\n\t\ttimeout = DIV_ROUND_UP(timeout, 60) * 60;\n\t\tresolution = minutes;\n\t}\n\n\tret = fts_wd_set_resolution(data, resolution);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twdd->timeout = timeout;\n\treturn 0;\n}\n\nstatic int fts_wd_start(struct watchdog_device *wdd)\n{\n\tstruct fts_data *data = watchdog_get_drvdata(wdd);\n\n\treturn fts_write_byte(data->client, FTS_WATCHDOG_TIME_PRESET,\n\t\t\t      wdd->timeout / (u8)data->resolution);\n}\n\nstatic int fts_wd_stop(struct watchdog_device *wdd)\n{\n\tstruct fts_data *data;\n\n\tdata = watchdog_get_drvdata(wdd);\n\treturn fts_write_byte(data->client, FTS_WATCHDOG_TIME_PRESET, 0);\n}\n\nstatic const struct watchdog_info fts_wd_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"FTS Teutates Hardware Watchdog\",\n};\n\nstatic const struct watchdog_ops fts_wd_ops = {\n\t.owner = THIS_MODULE,\n\t.start = fts_wd_start,\n\t.stop = fts_wd_stop,\n\t.set_timeout = fts_wd_set_timeout,\n};\n\nstatic int fts_watchdog_init(struct fts_data *data)\n{\n\tint timeout, ret;\n\n\twatchdog_set_drvdata(&data->wdd, data);\n\n\ttimeout = fts_read_byte(data->client, FTS_WATCHDOG_TIME_PRESET);\n\tif (timeout < 0)\n\t\treturn timeout;\n\n\t \n\tif (timeout == 0) {\n\t\tret = fts_wd_set_resolution(data, seconds);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->wdd.timeout = 60;\n\t} else {\n\t\tret = fts_read_byte(data->client, FTS_WATCHDOG_CONTROL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata->resolution = ret & BIT(1) ? seconds : minutes;\n\t\tdata->wdd.timeout = timeout * (u8)data->resolution;\n\t\tset_bit(WDOG_HW_RUNNING, &data->wdd.status);\n\t}\n\n\t \n\tdata->wdd.info = &fts_wd_info;\n\tdata->wdd.ops = &fts_wd_ops;\n\tdata->wdd.parent = &data->client->dev;\n\tdata->wdd.min_timeout = 1;\n\n\t \n\tdata->wdd.max_hw_heartbeat_ms = 0xFF * 60 * MSEC_PER_SEC;\n\n\treturn devm_watchdog_register_device(&data->client->dev, &data->wdd);\n}\n\nstatic umode_t fts_is_visible(const void *devdata, enum hwmon_sensor_types type, u32 attr,\n\t\t\t      int channel)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_fault:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_alarm:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\tcase hwmon_fan_fault:\n\t\t\treturn 0444;\n\t\tcase hwmon_fan_alarm:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\tcase hwmon_in:\n\t\treturn 0444;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int fts_read(struct device *dev, enum hwmon_sensor_types type, u32 attr, int channel,\n\t\t    long *val)\n{\n\tstruct fts_data *data = dev_get_drvdata(dev);\n\tint ret = fts_update_device(data);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\t*val = (data->temp_input[channel] - 64) * 1000;\n\n\t\t\treturn 0;\n\t\tcase hwmon_temp_alarm:\n\t\t\t*val = !!(data->temp_alarm & BIT(channel));\n\n\t\t\treturn 0;\n\t\tcase hwmon_temp_fault:\n\t\t\t ;\n\t\t\t*val = (data->temp_input[channel] == 0);\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\t*val = data->fan_input[channel] * 60;\n\n\t\t\treturn 0;\n\t\tcase hwmon_fan_alarm:\n\t\t\t*val = !!(data->fan_alarm & BIT(channel));\n\n\t\t\treturn 0;\n\t\tcase hwmon_fan_fault:\n\t\t\t*val = !(data->fan_present & BIT(channel));\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_auto_channels_temp:\n\t\t\tif (data->fan_source[channel] == FTS_FAN_SOURCE_INVALID)\n\t\t\t\t*val = 0;\n\t\t\telse\n\t\t\t\t*val = BIT(data->fan_source[channel]);\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\t*val = DIV_ROUND_CLOSEST(data->volt[channel] * 3300, 255);\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int fts_write(struct device *dev, enum hwmon_sensor_types type, u32 attr, int channel,\n\t\t     long val)\n{\n\tstruct fts_data *data = dev_get_drvdata(dev);\n\tint ret = fts_update_device(data);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_alarm:\n\t\t\tif (val)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmutex_lock(&data->update_lock);\n\t\t\tret = fts_read_byte(data->client, FTS_REG_TEMP_CONTROL(channel));\n\t\t\tif (ret >= 0)\n\t\t\t\tret = fts_write_byte(data->client, FTS_REG_TEMP_CONTROL(channel),\n\t\t\t\t\t\t     ret | 0x1);\n\t\t\tif (ret >= 0)\n\t\t\t\tdata->valid = false;\n\n\t\t\tmutex_unlock(&data->update_lock);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_alarm:\n\t\t\tif (val)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmutex_lock(&data->update_lock);\n\t\t\tret = fts_read_byte(data->client, FTS_REG_FAN_CONTROL(channel));\n\t\t\tif (ret >= 0)\n\t\t\t\tret = fts_write_byte(data->client, FTS_REG_FAN_CONTROL(channel),\n\t\t\t\t\t\t     ret | 0x1);\n\t\t\tif (ret >= 0)\n\t\t\t\tdata->valid = false;\n\n\t\t\tmutex_unlock(&data->update_lock);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct hwmon_ops fts_ops = {\n\t.is_visible = fts_is_visible,\n\t.read = fts_read,\n\t.write = fts_write,\n};\n\nstatic const struct hwmon_channel_info * const fts_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_ALARM | HWMON_T_FAULT\n\t\t\t   ),\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_ALARM | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_ALARM | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_ALARM | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_ALARM | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_ALARM | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_ALARM | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_ALARM | HWMON_F_FAULT,\n\t\t\t   HWMON_F_INPUT | HWMON_F_ALARM | HWMON_F_FAULT\n\t\t\t   ),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP,\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP,\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP,\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP,\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP,\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP,\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP,\n\t\t\t   HWMON_PWM_AUTO_CHANNELS_TEMP\n\t\t\t   ),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT,\n\t\t\t   HWMON_I_INPUT,\n\t\t\t   HWMON_I_INPUT,\n\t\t\t   HWMON_I_INPUT\n\t\t\t   ),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info fts_chip_info = {\n\t.ops = &fts_ops,\n\t.info = fts_info,\n};\n\n \n \n \nstatic int fts_detect(struct i2c_client *client,\n\t\t      struct i2c_board_info *info)\n{\n\tint val;\n\n\t \n\tval = i2c_smbus_read_byte_data(client, FTS_DEVICE_REVISION_REG);\n\tif (val < 0x2b)\n\t\treturn -ENODEV;\n\n\t \n\tval = i2c_smbus_read_byte_data(client, FTS_DEVICE_DETECT_REG_1);\n\tif (val != 0x17)\n\t\treturn -ENODEV;\n\n\tval = i2c_smbus_read_byte_data(client, FTS_DEVICE_DETECT_REG_2);\n\tif (val != 0x34)\n\t\treturn -ENODEV;\n\n\tval = i2c_smbus_read_byte_data(client, FTS_DEVICE_DETECT_REG_3);\n\tif (val != 0x54)\n\t\treturn -ENODEV;\n\n\t \n\tval = i2c_smbus_read_byte_data(client, FTS_DEVICE_ID_REG);\n\tif (val != 0x11)\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, fts_id[0].name, I2C_NAME_SIZE);\n\tinfo->flags = 0;\n\treturn 0;\n}\n\nstatic int fts_probe(struct i2c_client *client)\n{\n\tu8 revision;\n\tstruct fts_data *data;\n\tint err;\n\ts8 deviceid;\n\tstruct device *hwmon_dev;\n\n\tif (client->addr != 0x73)\n\t\treturn -ENODEV;\n\n\t \n\tdeviceid = i2c_smbus_read_byte_data(client, FTS_DEVICE_ID_REG);\n\tif (deviceid > 0 && (deviceid & 0xF0) == 0x10) {\n\t\tswitch (deviceid & 0x0F) {\n\t\tcase 0x01:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&client->dev,\n\t\t\t\t\"No Baseboard Management Controller\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tdev_dbg(&client->dev, \"No fujitsu board\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct fts_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&data->update_lock);\n\tmutex_init(&data->access_lock);\n\tdata->client = client;\n\tdev_set_drvdata(&client->dev, data);\n\n\terr = i2c_smbus_read_byte_data(client, FTS_DEVICE_REVISION_REG);\n\tif (err < 0)\n\t\treturn err;\n\trevision = err;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&client->dev, \"ftsteutates\", data,\n\t\t\t\t\t\t\t &fts_chip_info, NULL);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\terr = fts_watchdog_init(data);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(&client->dev, \"Detected FTS Teutates chip, revision: %d.%d\\n\",\n\t\t (revision & 0xF0) >> 4, revision & 0x0F);\n\treturn 0;\n}\n\n \n \n \nstatic struct i2c_driver fts_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"ftsteutates\",\n\t},\n\t.id_table = fts_id,\n\t.probe = fts_probe,\n\t.detect = fts_detect,\n\t.address_list = normal_i2c,\n};\n\nmodule_i2c_driver(fts_driver);\n\nMODULE_AUTHOR(\"Thilo Cestonaro <thilo.cestonaro@ts.fujitsu.com>\");\nMODULE_DESCRIPTION(\"FTS Teutates driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}