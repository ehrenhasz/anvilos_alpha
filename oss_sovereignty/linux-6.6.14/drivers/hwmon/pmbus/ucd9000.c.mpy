{
  "module_name": "ucd9000.c",
  "hash_id": "7ad334024eb67af0860dd917dc7d7805da30ac8d4ee1535804d9036dafdb1eb2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/ucd9000.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/pmbus.h>\n#include <linux/gpio/driver.h>\n#include <linux/timekeeping.h>\n#include \"pmbus.h\"\n\nenum chips { ucd9000, ucd90120, ucd90124, ucd90160, ucd90320, ucd9090,\n\t     ucd90910 };\n\n#define UCD9000_MONITOR_CONFIG\t\t0xd5\n#define UCD9000_NUM_PAGES\t\t0xd6\n#define UCD9000_FAN_CONFIG_INDEX\t0xe7\n#define UCD9000_FAN_CONFIG\t\t0xe8\n#define UCD9000_MFR_STATUS\t\t0xf3\n#define UCD9000_GPIO_SELECT\t\t0xfa\n#define UCD9000_GPIO_CONFIG\t\t0xfb\n#define UCD9000_DEVICE_ID\t\t0xfd\n\n \n#define UCD9000_GPIO_CONFIG_ENABLE\tBIT(0)\n#define UCD9000_GPIO_CONFIG_OUT_ENABLE\tBIT(1)\n#define UCD9000_GPIO_CONFIG_OUT_VALUE\tBIT(2)\n#define UCD9000_GPIO_CONFIG_STATUS\tBIT(3)\n#define UCD9000_GPIO_INPUT\t\t0\n#define UCD9000_GPIO_OUTPUT\t\t1\n\n#define UCD9000_MON_TYPE(x)\t(((x) >> 5) & 0x07)\n#define UCD9000_MON_PAGE(x)\t((x) & 0x1f)\n\n#define UCD9000_MON_VOLTAGE\t1\n#define UCD9000_MON_TEMPERATURE\t2\n#define UCD9000_MON_CURRENT\t3\n#define UCD9000_MON_VOLTAGE_HW\t4\n\n#define UCD9000_NUM_FAN\t\t4\n\n#define UCD9000_GPIO_NAME_LEN\t16\n#define UCD9090_NUM_GPIOS\t23\n#define UCD901XX_NUM_GPIOS\t26\n#define UCD90320_NUM_GPIOS\t84\n#define UCD90910_NUM_GPIOS\t26\n\n#define UCD9000_DEBUGFS_NAME_LEN\t24\n#define UCD9000_GPI_COUNT\t\t8\n#define UCD90320_GPI_COUNT\t\t32\n\nstruct ucd9000_data {\n\tu8 fan_data[UCD9000_NUM_FAN][I2C_SMBUS_BLOCK_MAX];\n\tstruct pmbus_driver_info info;\n#ifdef CONFIG_GPIOLIB\n\tstruct gpio_chip gpio;\n#endif\n\tstruct dentry *debugfs;\n\tktime_t write_time;\n};\n#define to_ucd9000_data(_info) container_of(_info, struct ucd9000_data, info)\n\nstruct ucd9000_debugfs_entry {\n\tstruct i2c_client *client;\n\tu8 index;\n};\n\n \n#define UCD90320_WAIT_DELAY_US 250\n\nstatic inline void ucd90320_wait(const struct ucd9000_data *data)\n{\n\ts64 delta = ktime_us_delta(ktime_get(), data->write_time);\n\n\tif (delta < UCD90320_WAIT_DELAY_US)\n\t\tudelay(UCD90320_WAIT_DELAY_US - delta);\n}\n\nstatic int ucd90320_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t   int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct ucd9000_data *data = to_ucd9000_data(info);\n\n\tif (reg >= PMBUS_VIRT_BASE)\n\t\treturn -ENXIO;\n\n\tucd90320_wait(data);\n\treturn pmbus_read_word_data(client, page, phase, reg);\n}\n\nstatic int ucd90320_read_byte_data(struct i2c_client *client, int page, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct ucd9000_data *data = to_ucd9000_data(info);\n\n\tucd90320_wait(data);\n\treturn pmbus_read_byte_data(client, page, reg);\n}\n\nstatic int ucd90320_write_word_data(struct i2c_client *client, int page,\n\t\t\t\t    int reg, u16 word)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct ucd9000_data *data = to_ucd9000_data(info);\n\tint ret;\n\n\tucd90320_wait(data);\n\tret = pmbus_write_word_data(client, page, reg, word);\n\tdata->write_time = ktime_get();\n\n\treturn ret;\n}\n\nstatic int ucd90320_write_byte(struct i2c_client *client, int page, u8 value)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct ucd9000_data *data = to_ucd9000_data(info);\n\tint ret;\n\n\tucd90320_wait(data);\n\tret = pmbus_write_byte(client, page, value);\n\tdata->write_time = ktime_get();\n\n\treturn ret;\n}\n\nstatic int ucd9000_get_fan_config(struct i2c_client *client, int fan)\n{\n\tint fan_config = 0;\n\tstruct ucd9000_data *data\n\t  = to_ucd9000_data(pmbus_get_driver_info(client));\n\n\tif (data->fan_data[fan][3] & 1)\n\t\tfan_config |= PB_FAN_2_INSTALLED;    \n\n\t \n\tfan_config |= (data->fan_data[fan][3] & 0x06) >> 1;\n\n\treturn fan_config;\n}\n\nstatic int ucd9000_read_byte_data(struct i2c_client *client, int page, int reg)\n{\n\tint ret = 0;\n\tint fan_config;\n\n\tswitch (reg) {\n\tcase PMBUS_FAN_CONFIG_12:\n\t\tif (page > 0)\n\t\t\treturn -ENXIO;\n\n\t\tret = ucd9000_get_fan_config(client, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tfan_config = ret << 4;\n\t\tret = ucd9000_get_fan_config(client, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tfan_config |= ret;\n\t\tret = fan_config;\n\t\tbreak;\n\tcase PMBUS_FAN_CONFIG_34:\n\t\tif (page > 0)\n\t\t\treturn -ENXIO;\n\n\t\tret = ucd9000_get_fan_config(client, 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tfan_config = ret << 4;\n\t\tret = ucd9000_get_fan_config(client, 3);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tfan_config |= ret;\n\t\tret = fan_config;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct i2c_device_id ucd9000_id[] = {\n\t{\"ucd9000\", ucd9000},\n\t{\"ucd90120\", ucd90120},\n\t{\"ucd90124\", ucd90124},\n\t{\"ucd90160\", ucd90160},\n\t{\"ucd90320\", ucd90320},\n\t{\"ucd9090\", ucd9090},\n\t{\"ucd90910\", ucd90910},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ucd9000_id);\n\nstatic const struct of_device_id __maybe_unused ucd9000_of_match[] = {\n\t{\n\t\t.compatible = \"ti,ucd9000\",\n\t\t.data = (void *)ucd9000\n\t},\n\t{\n\t\t.compatible = \"ti,ucd90120\",\n\t\t.data = (void *)ucd90120\n\t},\n\t{\n\t\t.compatible = \"ti,ucd90124\",\n\t\t.data = (void *)ucd90124\n\t},\n\t{\n\t\t.compatible = \"ti,ucd90160\",\n\t\t.data = (void *)ucd90160\n\t},\n\t{\n\t\t.compatible = \"ti,ucd90320\",\n\t\t.data = (void *)ucd90320\n\t},\n\t{\n\t\t.compatible = \"ti,ucd9090\",\n\t\t.data = (void *)ucd9090\n\t},\n\t{\n\t\t.compatible = \"ti,ucd90910\",\n\t\t.data = (void *)ucd90910\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ucd9000_of_match);\n\n#ifdef CONFIG_GPIOLIB\nstatic int ucd9000_gpio_read_config(struct i2c_client *client,\n\t\t\t\t    unsigned int offset)\n{\n\tint ret;\n\n\t \n\tret = i2c_smbus_write_byte_data(client, UCD9000_GPIO_SELECT, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_read_byte_data(client, UCD9000_GPIO_CONFIG);\n}\n\nstatic int ucd9000_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct i2c_client *client  = gpiochip_get_data(gc);\n\tint ret;\n\n\tret = ucd9000_gpio_read_config(client, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(ret & UCD9000_GPIO_CONFIG_STATUS);\n}\n\nstatic void ucd9000_gpio_set(struct gpio_chip *gc, unsigned int offset,\n\t\t\t     int value)\n{\n\tstruct i2c_client *client = gpiochip_get_data(gc);\n\tint ret;\n\n\tret = ucd9000_gpio_read_config(client, offset);\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"failed to read GPIO %d config: %d\\n\",\n\t\t\toffset, ret);\n\t\treturn;\n\t}\n\n\tif (value) {\n\t\tif (ret & UCD9000_GPIO_CONFIG_STATUS)\n\t\t\treturn;\n\n\t\tret |= UCD9000_GPIO_CONFIG_STATUS;\n\t} else {\n\t\tif (!(ret & UCD9000_GPIO_CONFIG_STATUS))\n\t\t\treturn;\n\n\t\tret &= ~UCD9000_GPIO_CONFIG_STATUS;\n\t}\n\n\tret |= UCD9000_GPIO_CONFIG_ENABLE;\n\n\t \n\tret = i2c_smbus_write_byte_data(client, UCD9000_GPIO_CONFIG, ret);\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"Failed to write GPIO %d config: %d\\n\",\n\t\t\toffset, ret);\n\t\treturn;\n\t}\n\n\tret &= ~UCD9000_GPIO_CONFIG_ENABLE;\n\n\tret = i2c_smbus_write_byte_data(client, UCD9000_GPIO_CONFIG, ret);\n\tif (ret < 0)\n\t\tdev_dbg(&client->dev, \"Failed to write GPIO %d config: %d\\n\",\n\t\t\toffset, ret);\n}\n\nstatic int ucd9000_gpio_get_direction(struct gpio_chip *gc,\n\t\t\t\t      unsigned int offset)\n{\n\tstruct i2c_client *client = gpiochip_get_data(gc);\n\tint ret;\n\n\tret = ucd9000_gpio_read_config(client, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !(ret & UCD9000_GPIO_CONFIG_OUT_ENABLE);\n}\n\nstatic int ucd9000_gpio_set_direction(struct gpio_chip *gc,\n\t\t\t\t      unsigned int offset, bool direction_out,\n\t\t\t\t      int requested_out)\n{\n\tstruct i2c_client *client = gpiochip_get_data(gc);\n\tint ret, config, out_val;\n\n\tret = ucd9000_gpio_read_config(client, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (direction_out) {\n\t\tout_val = requested_out ? UCD9000_GPIO_CONFIG_OUT_VALUE : 0;\n\n\t\tif (ret & UCD9000_GPIO_CONFIG_OUT_ENABLE) {\n\t\t\tif ((ret & UCD9000_GPIO_CONFIG_OUT_VALUE) == out_val)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tret |= UCD9000_GPIO_CONFIG_OUT_ENABLE;\n\t\t}\n\n\t\tif (out_val)\n\t\t\tret |= UCD9000_GPIO_CONFIG_OUT_VALUE;\n\t\telse\n\t\t\tret &= ~UCD9000_GPIO_CONFIG_OUT_VALUE;\n\n\t} else {\n\t\tif (!(ret & UCD9000_GPIO_CONFIG_OUT_ENABLE))\n\t\t\treturn 0;\n\n\t\tret &= ~UCD9000_GPIO_CONFIG_OUT_ENABLE;\n\t}\n\n\tret |= UCD9000_GPIO_CONFIG_ENABLE;\n\tconfig = ret;\n\n\t \n\tret = i2c_smbus_write_byte_data(client, UCD9000_GPIO_CONFIG, config);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tconfig &= ~UCD9000_GPIO_CONFIG_ENABLE;\n\n\treturn i2c_smbus_write_byte_data(client, UCD9000_GPIO_CONFIG, config);\n}\n\nstatic int ucd9000_gpio_direction_input(struct gpio_chip *gc,\n\t\t\t\t\tunsigned int offset)\n{\n\treturn ucd9000_gpio_set_direction(gc, offset, UCD9000_GPIO_INPUT, 0);\n}\n\nstatic int ucd9000_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\t unsigned int offset, int val)\n{\n\treturn ucd9000_gpio_set_direction(gc, offset, UCD9000_GPIO_OUTPUT,\n\t\t\t\t\t  val);\n}\n\nstatic void ucd9000_probe_gpio(struct i2c_client *client,\n\t\t\t       const struct i2c_device_id *mid,\n\t\t\t       struct ucd9000_data *data)\n{\n\tint rc;\n\n\tswitch (mid->driver_data) {\n\tcase ucd9090:\n\t\tdata->gpio.ngpio = UCD9090_NUM_GPIOS;\n\t\tbreak;\n\tcase ucd90120:\n\tcase ucd90124:\n\tcase ucd90160:\n\t\tdata->gpio.ngpio = UCD901XX_NUM_GPIOS;\n\t\tbreak;\n\tcase ucd90320:\n\t\tdata->gpio.ngpio = UCD90320_NUM_GPIOS;\n\t\tbreak;\n\tcase ucd90910:\n\t\tdata->gpio.ngpio = UCD90910_NUM_GPIOS;\n\t\tbreak;\n\tdefault:\n\t\treturn;  \n\t}\n\n\t \n\tdata->gpio.label = client->name;\n\tdata->gpio.get_direction = ucd9000_gpio_get_direction;\n\tdata->gpio.direction_input = ucd9000_gpio_direction_input;\n\tdata->gpio.direction_output = ucd9000_gpio_direction_output;\n\tdata->gpio.get = ucd9000_gpio_get;\n\tdata->gpio.set = ucd9000_gpio_set;\n\tdata->gpio.can_sleep = true;\n\tdata->gpio.base = -1;\n\tdata->gpio.parent = &client->dev;\n\n\trc = devm_gpiochip_add_data(&client->dev, &data->gpio, client);\n\tif (rc)\n\t\tdev_warn(&client->dev, \"Could not add gpiochip: %d\\n\", rc);\n}\n#else\nstatic void ucd9000_probe_gpio(struct i2c_client *client,\n\t\t\t       const struct i2c_device_id *mid,\n\t\t\t       struct ucd9000_data *data)\n{\n}\n#endif  \n\n#ifdef CONFIG_DEBUG_FS\nstatic int ucd9000_get_mfr_status(struct i2c_client *client, u8 *buffer)\n{\n\tint ret = pmbus_set_page(client, 0, 0xff);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_read_block_data(client, UCD9000_MFR_STATUS, buffer);\n}\n\nstatic int ucd9000_debugfs_show_mfr_status_bit(void *data, u64 *val)\n{\n\tstruct ucd9000_debugfs_entry *entry = data;\n\tstruct i2c_client *client = entry->client;\n\tu8 buffer[I2C_SMBUS_BLOCK_MAX];\n\tint ret, i;\n\n\tret = ucd9000_get_mfr_status(client, buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ti = ret - 3 - entry->index / 8;\n\tif (i >= 0)\n\t\t*val = !!(buffer[i] & BIT(entry->index % 8));\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(ucd9000_debugfs_mfr_status_bit,\n\t\t\t ucd9000_debugfs_show_mfr_status_bit, NULL, \"%1lld\\n\");\n\nstatic ssize_t ucd9000_debugfs_read_mfr_status(struct file *file,\n\t\t\t\t\t       char __user *buf, size_t count,\n\t\t\t\t\t       loff_t *ppos)\n{\n\tstruct i2c_client *client = file->private_data;\n\tu8 buffer[I2C_SMBUS_BLOCK_MAX];\n\tchar str[(I2C_SMBUS_BLOCK_MAX * 2) + 2];\n\tchar *res;\n\tint rc;\n\n\trc = ucd9000_get_mfr_status(client, buffer);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tres = bin2hex(str, buffer, min(rc, I2C_SMBUS_BLOCK_MAX));\n\t*res++ = '\\n';\n\t*res = 0;\n\n\treturn simple_read_from_buffer(buf, count, ppos, str, res - str);\n}\n\nstatic const struct file_operations ucd9000_debugfs_show_mfr_status_fops = {\n\t.llseek = noop_llseek,\n\t.read = ucd9000_debugfs_read_mfr_status,\n\t.open = simple_open,\n};\n\nstatic int ucd9000_init_debugfs(struct i2c_client *client,\n\t\t\t\tconst struct i2c_device_id *mid,\n\t\t\t\tstruct ucd9000_data *data)\n{\n\tstruct dentry *debugfs;\n\tstruct ucd9000_debugfs_entry *entries;\n\tint i, gpi_count;\n\tchar name[UCD9000_DEBUGFS_NAME_LEN];\n\n\tdebugfs = pmbus_get_debugfs_dir(client);\n\tif (!debugfs)\n\t\treturn -ENOENT;\n\n\tdata->debugfs = debugfs_create_dir(client->name, debugfs);\n\n\t \n\tif (mid->driver_data == ucd9090 || mid->driver_data == ucd90160 ||\n\t    mid->driver_data == ucd90320 || mid->driver_data == ucd90910) {\n\t\tgpi_count = mid->driver_data == ucd90320 ? UCD90320_GPI_COUNT\n\t\t\t\t\t\t\t : UCD9000_GPI_COUNT;\n\t\tentries = devm_kcalloc(&client->dev,\n\t\t\t\t       gpi_count, sizeof(*entries),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < gpi_count; i++) {\n\t\t\tentries[i].client = client;\n\t\t\tentries[i].index = i;\n\t\t\tscnprintf(name, UCD9000_DEBUGFS_NAME_LEN,\n\t\t\t\t  \"gpi%d_alarm\", i + 1);\n\t\t\tdebugfs_create_file(name, 0444, data->debugfs,\n\t\t\t\t\t    &entries[i],\n\t\t\t\t\t    &ucd9000_debugfs_mfr_status_bit);\n\t\t}\n\t}\n\n\tscnprintf(name, UCD9000_DEBUGFS_NAME_LEN, \"mfr_status\");\n\tdebugfs_create_file(name, 0444, data->debugfs, client,\n\t\t\t    &ucd9000_debugfs_show_mfr_status_fops);\n\n\treturn 0;\n}\n#else\nstatic int ucd9000_init_debugfs(struct i2c_client *client,\n\t\t\t\tconst struct i2c_device_id *mid,\n\t\t\t\tstruct ucd9000_data *data)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int ucd9000_probe(struct i2c_client *client)\n{\n\tu8 block_buffer[I2C_SMBUS_BLOCK_MAX + 1];\n\tstruct ucd9000_data *data;\n\tstruct pmbus_driver_info *info;\n\tconst struct i2c_device_id *mid;\n\tenum chips chip;\n\tint i, ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_BLOCK_DATA))\n\t\treturn -ENODEV;\n\n\tret = i2c_smbus_read_block_data(client, UCD9000_DEVICE_ID,\n\t\t\t\t\tblock_buffer);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to read device ID\\n\");\n\t\treturn ret;\n\t}\n\tblock_buffer[ret] = '\\0';\n\tdev_info(&client->dev, \"Device ID %s\\n\", block_buffer);\n\n\tfor (mid = ucd9000_id; mid->name[0]; mid++) {\n\t\tif (!strncasecmp(mid->name, block_buffer, strlen(mid->name)))\n\t\t\tbreak;\n\t}\n\tif (!mid->name[0]) {\n\t\tdev_err(&client->dev, \"Unsupported device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (client->dev.of_node)\n\t\tchip = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\tchip = mid->driver_data;\n\n\tif (chip != ucd9000 && strcmp(client->name, mid->name) != 0)\n\t\tdev_notice(&client->dev,\n\t\t\t   \"Device mismatch: Configured %s, detected %s\\n\",\n\t\t\t   client->name, mid->name);\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct ucd9000_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tinfo = &data->info;\n\n\tret = i2c_smbus_read_byte_data(client, UCD9000_NUM_PAGES);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to read number of active pages\\n\");\n\t\treturn ret;\n\t}\n\tinfo->pages = ret;\n\tif (!info->pages) {\n\t\tdev_err(&client->dev, \"No pages configured\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tinfo->func[0] = PMBUS_HAVE_TEMP;\n\n\t \n\tret = i2c_smbus_read_block_data(client, UCD9000_MONITOR_CONFIG,\n\t\t\t\t\tblock_buffer);\n\tif (ret <= 0) {\n\t\tdev_err(&client->dev, \"Failed to read configuration data\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfor (i = 0; i < ret; i++) {\n\t\tint page = UCD9000_MON_PAGE(block_buffer[i]);\n\n\t\tif (page >= info->pages)\n\t\t\tcontinue;\n\n\t\tswitch (UCD9000_MON_TYPE(block_buffer[i])) {\n\t\tcase UCD9000_MON_VOLTAGE:\n\t\tcase UCD9000_MON_VOLTAGE_HW:\n\t\t\tinfo->func[page] |= PMBUS_HAVE_VOUT\n\t\t\t  | PMBUS_HAVE_STATUS_VOUT;\n\t\t\tbreak;\n\t\tcase UCD9000_MON_TEMPERATURE:\n\t\t\tinfo->func[page] |= PMBUS_HAVE_TEMP2\n\t\t\t  | PMBUS_HAVE_STATUS_TEMP;\n\t\t\tbreak;\n\t\tcase UCD9000_MON_CURRENT:\n\t\t\tinfo->func[page] |= PMBUS_HAVE_IOUT\n\t\t\t  | PMBUS_HAVE_STATUS_IOUT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (mid->driver_data == ucd90124) {\n\t\tfor (i = 0; i < UCD9000_NUM_FAN; i++) {\n\t\t\ti2c_smbus_write_byte_data(client,\n\t\t\t\t\t\t  UCD9000_FAN_CONFIG_INDEX, i);\n\t\t\tret = i2c_smbus_read_block_data(client,\n\t\t\t\t\t\t\tUCD9000_FAN_CONFIG,\n\t\t\t\t\t\t\tdata->fan_data[i]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\ti2c_smbus_write_byte_data(client, UCD9000_FAN_CONFIG_INDEX, 0);\n\n\t\tinfo->read_byte_data = ucd9000_read_byte_data;\n\t\tinfo->func[0] |= PMBUS_HAVE_FAN12 | PMBUS_HAVE_STATUS_FAN12\n\t\t  | PMBUS_HAVE_FAN34 | PMBUS_HAVE_STATUS_FAN34;\n\t} else if (mid->driver_data == ucd90320) {\n\t\tinfo->read_byte_data = ucd90320_read_byte_data;\n\t\tinfo->read_word_data = ucd90320_read_word_data;\n\t\tinfo->write_byte = ucd90320_write_byte;\n\t\tinfo->write_word_data = ucd90320_write_word_data;\n\t}\n\n\tucd9000_probe_gpio(client, mid, data);\n\n\tret = pmbus_do_probe(client, info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ucd9000_init_debugfs(client, mid, data);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"Failed to register debugfs: %d\\n\",\n\t\t\t ret);\n\n\treturn 0;\n}\n\n \nstatic struct i2c_driver ucd9000_driver = {\n\t.driver = {\n\t\t.name = \"ucd9000\",\n\t\t.of_match_table = of_match_ptr(ucd9000_of_match),\n\t},\n\t.probe = ucd9000_probe,\n\t.id_table = ucd9000_id,\n};\n\nmodule_i2c_driver(ucd9000_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck\");\nMODULE_DESCRIPTION(\"PMBus driver for TI UCD90xxx\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}