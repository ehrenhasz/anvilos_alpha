{
  "module_name": "pim4328.c",
  "hash_id": "3a0f7ce26964e444fac31b661e23f346a746a9b8f7824c3b57597f895bff3053",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/pim4328.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pmbus.h>\n#include <linux/slab.h>\n#include \"pmbus.h\"\n\nenum chips { pim4006, pim4328, pim4820 };\n\nstruct pim4328_data {\n\tenum chips id;\n\tstruct pmbus_driver_info info;\n};\n\n#define to_pim4328_data(x)  container_of(x, struct pim4328_data, info)\n\n \n#define PIM4328_MFR_READ_VINA\t\t0xd3\n#define PIM4328_MFR_READ_VINB\t\t0xd4\n\n \n#define PIM4328_MFR_READ_IINA\t\t0xd6\n#define PIM4328_MFR_READ_IINB\t\t0xd7\n#define PIM4328_MFR_FET_CHECKSTATUS\t0xd9\n\n \n#define PIM4328_MFR_STATUS_BITS\t\t0xd5\n\n \n#define PIM4328_MFR_READ_STATUS\t\t0xd0\n\nstatic const struct i2c_device_id pim4328_id[] = {\n\t{\"bmr455\", pim4328},\n\t{\"pim4006\", pim4006},\n\t{\"pim4106\", pim4006},\n\t{\"pim4206\", pim4006},\n\t{\"pim4306\", pim4006},\n\t{\"pim4328\", pim4328},\n\t{\"pim4406\", pim4006},\n\t{\"pim4820\", pim4820},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, pim4328_id);\n\nstatic int pim4328_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t  int phase, int reg)\n{\n\tint ret;\n\n\tif (page > 0)\n\t\treturn -ENXIO;\n\n\tif (phase == 0xff)\n\t\treturn -ENODATA;\n\n\tswitch (reg) {\n\tcase PMBUS_READ_VIN:\n\t\tret = pmbus_read_word_data(client, page, phase,\n\t\t\t\t\t   phase == 0 ? PIM4328_MFR_READ_VINA\n\t\t\t\t\t\t      : PIM4328_MFR_READ_VINB);\n\t\tbreak;\n\tcase PMBUS_READ_IIN:\n\t\tret = pmbus_read_word_data(client, page, phase,\n\t\t\t\t\t   phase == 0 ? PIM4328_MFR_READ_IINA\n\t\t\t\t\t\t      : PIM4328_MFR_READ_IINB);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t}\n\n\treturn ret;\n}\n\nstatic int pim4328_read_byte_data(struct i2c_client *client, int page, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct pim4328_data *data = to_pim4328_data(info);\n\tint ret, status;\n\n\tif (page > 0)\n\t\treturn -ENXIO;\n\n\tswitch (reg) {\n\tcase PMBUS_STATUS_BYTE:\n\t\tret = pmbus_read_byte_data(client, page, PMBUS_STATUS_BYTE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (data->id == pim4006) {\n\t\t\tstatus = pmbus_read_word_data(client, page, 0xff,\n\t\t\t\t\t\t      PIM4328_MFR_FET_CHECKSTATUS);\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\t\t\tif (status & 0x0630)  \n\t\t\t\tret |= PB_STATUS_VIN_UV;\n\t\t} else if (data->id == pim4328) {\n\t\t\tstatus = pmbus_read_byte_data(client, page,\n\t\t\t\t\t\t      PIM4328_MFR_STATUS_BITS);\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\t\t\tif (status & 0x04)  \n\t\t\t\tret |= PB_STATUS_VIN_UV;\n\t\t\tif (status & 0x40)  \n\t\t\t\tret |= PB_STATUS_NONE_ABOVE;\n\t\t} else if (data->id == pim4820) {\n\t\t\tstatus = pmbus_read_byte_data(client, page,\n\t\t\t\t\t\t      PIM4328_MFR_READ_STATUS);\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\t\t\tif (status & 0x05)  \n\t\t\t\tret |= PB_STATUS_NONE_ABOVE;\n\t\t\tif (status & 0x1a)  \n\t\t\t\tret |= PB_STATUS_VIN_UV;\n\t\t\tif (status & 0x40)  \n\t\t\t\tret |= PB_STATUS_TEMPERATURE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t}\n\n\treturn ret;\n}\n\nstatic int pim4328_probe(struct i2c_client *client)\n{\n\tint status;\n\tu8 device_id[I2C_SMBUS_BLOCK_MAX + 1];\n\tconst struct i2c_device_id *mid;\n\tstruct pim4328_data *data;\n\tstruct pmbus_driver_info *info;\n\tstruct pmbus_platform_data *pdata;\n\tstruct device *dev = &client->dev;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_BLOCK_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct pim4328_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tstatus = i2c_smbus_read_block_data(client, PMBUS_MFR_MODEL, device_id);\n\tif (status < 0) {\n\t\tdev_err(&client->dev, \"Failed to read Manufacturer Model\\n\");\n\t\treturn status;\n\t}\n\tfor (mid = pim4328_id; mid->name[0]; mid++) {\n\t\tif (!strncasecmp(mid->name, device_id, strlen(mid->name)))\n\t\t\tbreak;\n\t}\n\tif (!mid->name[0]) {\n\t\tdev_err(&client->dev, \"Unsupported device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (strcmp(client->name, mid->name))\n\t\tdev_notice(&client->dev,\n\t\t\t   \"Device mismatch: Configured %s, detected %s\\n\",\n\t\t\t   client->name, mid->name);\n\n\tdata->id = mid->driver_data;\n\tinfo = &data->info;\n\tinfo->pages = 1;\n\tinfo->read_byte_data = pim4328_read_byte_data;\n\tinfo->read_word_data = pim4328_read_word_data;\n\n\tpdata = devm_kzalloc(dev, sizeof(struct pmbus_platform_data),\n\t\t\t     GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\tdev->platform_data = pdata;\n\tpdata->flags = PMBUS_NO_CAPABILITY | PMBUS_NO_WRITE_PROTECT;\n\n\tswitch (data->id) {\n\tcase pim4006:\n\t\tinfo->phases[0] = 2;\n\t\tinfo->func[0] = PMBUS_PHASE_VIRTUAL | PMBUS_HAVE_VIN\n\t\t\t| PMBUS_HAVE_TEMP | PMBUS_HAVE_IOUT;\n\t\tinfo->pfunc[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_IIN;\n\t\tinfo->pfunc[1] = PMBUS_HAVE_VIN | PMBUS_HAVE_IIN;\n\t\tbreak;\n\tcase pim4328:\n\t\tinfo->phases[0] = 2;\n\t\tinfo->func[0] = PMBUS_PHASE_VIRTUAL\n\t\t\t| PMBUS_HAVE_VCAP | PMBUS_HAVE_VIN\n\t\t\t| PMBUS_HAVE_TEMP | PMBUS_HAVE_IOUT;\n\t\tinfo->pfunc[0] = PMBUS_HAVE_VIN;\n\t\tinfo->pfunc[1] = PMBUS_HAVE_VIN;\n\t\tinfo->format[PSC_VOLTAGE_IN] = direct;\n\t\tinfo->format[PSC_TEMPERATURE] = direct;\n\t\tinfo->format[PSC_CURRENT_OUT] = direct;\n\t\tpdata->flags |= PMBUS_USE_COEFFICIENTS_CMD;\n\t\tbreak;\n\tcase pim4820:\n\t\tinfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_TEMP\n\t\t\t| PMBUS_HAVE_IIN;\n\t\tinfo->format[PSC_VOLTAGE_IN] = direct;\n\t\tinfo->format[PSC_TEMPERATURE] = direct;\n\t\tinfo->format[PSC_CURRENT_IN] = direct;\n\t\tpdata->flags |= PMBUS_USE_COEFFICIENTS_CMD;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\treturn pmbus_do_probe(client, info);\n}\n\nstatic struct i2c_driver pim4328_driver = {\n\t.driver = {\n\t\t   .name = \"pim4328\",\n\t\t   },\n\t.probe = pim4328_probe,\n\t.id_table = pim4328_id,\n};\n\nmodule_i2c_driver(pim4328_driver);\n\nMODULE_AUTHOR(\"Erik Rosen <erik.rosen@metormote.com>\");\nMODULE_DESCRIPTION(\"PMBus driver for PIM4006, PIM4328, PIM4820 power interface modules\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}