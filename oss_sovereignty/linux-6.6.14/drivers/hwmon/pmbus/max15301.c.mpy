{
  "module_name": "max15301.c",
  "hash_id": "c6c5d59dec720905be277c61ee5eb289a3939ab7a7eb96c158ac0c76a5fbcb2d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/max15301.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/ktime.h>\n#include <linux/delay.h>\n#include <linux/pmbus.h>\n#include \"pmbus.h\"\n\nstatic const struct i2c_device_id max15301_id[] = {\n\t{\"bmr461\", 0},\n\t{\"max15301\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, max15301_id);\n\nstruct max15301_data {\n\tint id;\n\tktime_t access;\t\t \n\tint delay;\t\t \n\tstruct pmbus_driver_info info;\n};\n\n#define to_max15301_data(x)  container_of(x, struct max15301_data, info)\n\n#define MAX15301_WAIT_TIME\t\t100\t \n\nstatic ushort delay = MAX15301_WAIT_TIME;\nmodule_param(delay, ushort, 0644);\nMODULE_PARM_DESC(delay, \"Delay between chip accesses in us\");\n\nstatic struct max15301_data max15301_data = {\n\t.info = {\n\t\t.pages = 1,\n\t\t.func[0] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\n\t\t\t| PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\n\t\t\t| PMBUS_HAVE_TEMP | PMBUS_HAVE_TEMP2\n\t\t\t| PMBUS_HAVE_STATUS_TEMP\n\t\t\t| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT,\n\t}\n};\n\n \nstatic inline void max15301_wait(const struct max15301_data *data)\n{\n\tif (data->delay) {\n\t\ts64 delta = ktime_us_delta(ktime_get(), data->access);\n\n\t\tif (delta < data->delay)\n\t\t\tudelay(data->delay - delta);\n\t}\n}\n\nstatic int max15301_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t   int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct max15301_data *data = to_max15301_data(info);\n\tint ret;\n\n\tif (page > 0)\n\t\treturn -ENXIO;\n\n\tif (reg >= PMBUS_VIRT_BASE)\n\t\treturn -ENXIO;\n\n\tmax15301_wait(data);\n\tret = pmbus_read_word_data(client, page, phase, reg);\n\tdata->access = ktime_get();\n\n\treturn ret;\n}\n\nstatic int max15301_read_byte_data(struct i2c_client *client, int page, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct max15301_data *data = to_max15301_data(info);\n\tint ret;\n\n\tif (page > 0)\n\t\treturn -ENXIO;\n\n\tmax15301_wait(data);\n\tret = pmbus_read_byte_data(client, page, reg);\n\tdata->access = ktime_get();\n\n\treturn ret;\n}\n\nstatic int max15301_write_word_data(struct i2c_client *client, int page, int reg,\n\t\t\t\t    u16 word)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct max15301_data *data = to_max15301_data(info);\n\tint ret;\n\n\tif (page > 0)\n\t\treturn -ENXIO;\n\n\tif (reg >= PMBUS_VIRT_BASE)\n\t\treturn -ENXIO;\n\n\tmax15301_wait(data);\n\tret = pmbus_write_word_data(client, page, reg, word);\n\tdata->access = ktime_get();\n\n\treturn ret;\n}\n\nstatic int max15301_write_byte(struct i2c_client *client, int page, u8 value)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct max15301_data *data = to_max15301_data(info);\n\tint ret;\n\n\tif (page > 0)\n\t\treturn -ENXIO;\n\n\tmax15301_wait(data);\n\tret = pmbus_write_byte(client, page, value);\n\tdata->access = ktime_get();\n\n\treturn ret;\n}\n\nstatic int max15301_probe(struct i2c_client *client)\n{\n\tint status;\n\tu8 device_id[I2C_SMBUS_BLOCK_MAX + 1];\n\tconst struct i2c_device_id *mid;\n\tstruct pmbus_driver_info *info = &max15301_data.info;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_BLOCK_DATA))\n\t\treturn -ENODEV;\n\n\tstatus = i2c_smbus_read_block_data(client, PMBUS_IC_DEVICE_ID, device_id);\n\tif (status < 0) {\n\t\tdev_err(&client->dev, \"Failed to read Device Id\\n\");\n\t\treturn status;\n\t}\n\tfor (mid = max15301_id; mid->name[0]; mid++) {\n\t\tif (!strncasecmp(mid->name, device_id, strlen(mid->name)))\n\t\t\tbreak;\n\t}\n\tif (!mid->name[0]) {\n\t\tdev_err(&client->dev, \"Unsupported device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmax15301_data.delay = delay;\n\n\tinfo->read_byte_data = max15301_read_byte_data;\n\tinfo->read_word_data = max15301_read_word_data;\n\tinfo->write_byte = max15301_write_byte;\n\tinfo->write_word_data = max15301_write_word_data;\n\n\treturn pmbus_do_probe(client, info);\n}\n\nstatic struct i2c_driver max15301_driver = {\n\t.driver = {\n\t\t   .name = \"max15301\",\n\t\t   },\n\t.probe = max15301_probe,\n\t.id_table = max15301_id,\n};\n\nmodule_i2c_driver(max15301_driver);\n\nMODULE_AUTHOR(\"Erik Rosen <erik.rosen@metormote.com>\");\nMODULE_DESCRIPTION(\"PMBus driver for Maxim MAX15301\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}