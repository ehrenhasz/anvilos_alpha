{
  "module_name": "ucd9200.c",
  "hash_id": "3568039f4e934db056eba9e77e196f060fa4275212dd6d4d80830c0bcb80f601",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/ucd9200.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/pmbus.h>\n#include \"pmbus.h\"\n\n#define UCD9200_PHASE_INFO\t0xd2\n#define UCD9200_DEVICE_ID\t0xfd\n\nenum chips { ucd9200, ucd9220, ucd9222, ucd9224, ucd9240, ucd9244, ucd9246,\n\t     ucd9248 };\n\nstatic const struct i2c_device_id ucd9200_id[] = {\n\t{\"ucd9200\", ucd9200},\n\t{\"ucd9220\", ucd9220},\n\t{\"ucd9222\", ucd9222},\n\t{\"ucd9224\", ucd9224},\n\t{\"ucd9240\", ucd9240},\n\t{\"ucd9244\", ucd9244},\n\t{\"ucd9246\", ucd9246},\n\t{\"ucd9248\", ucd9248},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ucd9200_id);\n\nstatic const struct of_device_id __maybe_unused ucd9200_of_match[] = {\n\t{\n\t\t.compatible = \"ti,cd9200\",\n\t\t.data = (void *)ucd9200\n\t},\n\t{\n\t\t.compatible = \"ti,cd9220\",\n\t\t.data = (void *)ucd9220\n\t},\n\t{\n\t\t.compatible = \"ti,cd9222\",\n\t\t.data = (void *)ucd9222\n\t},\n\t{\n\t\t.compatible = \"ti,cd9224\",\n\t\t.data = (void *)ucd9224\n\t},\n\t{\n\t\t.compatible = \"ti,cd9240\",\n\t\t.data = (void *)ucd9240\n\t},\n\t{\n\t\t.compatible = \"ti,cd9244\",\n\t\t.data = (void *)ucd9244\n\t},\n\t{\n\t\t.compatible = \"ti,cd9246\",\n\t\t.data = (void *)ucd9246\n\t},\n\t{\n\t\t.compatible = \"ti,cd9248\",\n\t\t.data = (void *)ucd9248\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ucd9200_of_match);\n\nstatic int ucd9200_probe(struct i2c_client *client)\n{\n\tu8 block_buffer[I2C_SMBUS_BLOCK_MAX + 1];\n\tstruct pmbus_driver_info *info;\n\tconst struct i2c_device_id *mid;\n\tenum chips chip;\n\tint i, j, ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_BLOCK_DATA))\n\t\treturn -ENODEV;\n\n\tret = i2c_smbus_read_block_data(client, UCD9200_DEVICE_ID,\n\t\t\t\t\tblock_buffer);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to read device ID\\n\");\n\t\treturn ret;\n\t}\n\tblock_buffer[ret] = '\\0';\n\tdev_info(&client->dev, \"Device ID %s\\n\", block_buffer);\n\n\tfor (mid = ucd9200_id; mid->name[0]; mid++) {\n\t\tif (!strncasecmp(mid->name, block_buffer, strlen(mid->name)))\n\t\t\tbreak;\n\t}\n\tif (!mid->name[0]) {\n\t\tdev_err(&client->dev, \"Unsupported device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (client->dev.of_node)\n\t\tchip = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\tchip = mid->driver_data;\n\n\tif (chip != ucd9200 && strcmp(client->name, mid->name) != 0)\n\t\tdev_notice(&client->dev,\n\t\t\t   \"Device mismatch: Configured %s, detected %s\\n\",\n\t\t\t   client->name, mid->name);\n\n\tinfo = devm_kzalloc(&client->dev, sizeof(struct pmbus_driver_info),\n\t\t\t    GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tret = i2c_smbus_read_block_data(client, UCD9200_PHASE_INFO,\n\t\t\t\t\tblock_buffer);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to read phase information\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tinfo->pages = 0;\n\tfor (i = 0; i < ret; i++) {\n\t\tif (!block_buffer[i])\n\t\t\tbreak;\n\t\tinfo->pages++;\n\t}\n\tif (!info->pages) {\n\t\tdev_err(&client->dev, \"No rails configured\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdev_info(&client->dev, \"%d rails configured\\n\", info->pages);\n\n\t \n\tfor (i = 0; i < info->pages; i++) {\n\t\t \n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, i);\n\t\t\tif (ret < 0)\n\t\t\t\tcontinue;\n\t\t\tret = i2c_smbus_write_byte_data(client, PMBUS_PHASE,\n\t\t\t\t\t\t\t0xff);\n\t\t\tif (ret < 0)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to initialize PHASE registers\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (info->pages > 1)\n\t\ti2c_smbus_write_byte_data(client, PMBUS_PAGE, 0);\n\n\tinfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT |\n\t\t\tPMBUS_HAVE_IIN | PMBUS_HAVE_PIN |\n\t\t\tPMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT |\n\t\t\tPMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT |\n\t\t\tPMBUS_HAVE_POUT | PMBUS_HAVE_TEMP |\n\t\t\tPMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\n\n\tfor (i = 1; i < info->pages; i++)\n\t\tinfo->func[i] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT |\n\t\t\tPMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT |\n\t\t\tPMBUS_HAVE_POUT |\n\t\t\tPMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\n\n\t \n\tif (mid->driver_data == ucd9240)\n\t\tinfo->func[0] |= PMBUS_HAVE_FAN12 | PMBUS_HAVE_STATUS_FAN12;\n\n\treturn pmbus_do_probe(client, info);\n}\n\n \nstatic struct i2c_driver ucd9200_driver = {\n\t.driver = {\n\t\t.name = \"ucd9200\",\n\t\t.of_match_table = of_match_ptr(ucd9200_of_match),\n\t},\n\t.probe = ucd9200_probe,\n\t.id_table = ucd9200_id,\n};\n\nmodule_i2c_driver(ucd9200_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck\");\nMODULE_DESCRIPTION(\"PMBus driver for TI UCD922x, UCD924x\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}