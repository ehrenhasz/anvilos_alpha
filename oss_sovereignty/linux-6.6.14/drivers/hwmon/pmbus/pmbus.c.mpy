{
  "module_name": "pmbus.c",
  "hash_id": "8a41fad873e44e20558e0a3383d2abc313abd4cf2568a7c42afa2c8b3ec5f4dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/pmbus.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/i2c.h>\n#include <linux/pmbus.h>\n#include \"pmbus.h\"\n\nstruct pmbus_device_info {\n\tint pages;\n\tu32 flags;\n};\n\nstatic const struct i2c_device_id pmbus_id[];\n\n \nstatic void pmbus_find_sensor_groups(struct i2c_client *client,\n\t\t\t\t     struct pmbus_driver_info *info)\n{\n\tint page;\n\n\t \n\tif (pmbus_check_word_register(client, 0, PMBUS_READ_VIN))\n\t\tinfo->func[0] |= PMBUS_HAVE_VIN;\n\tif (pmbus_check_word_register(client, 0, PMBUS_READ_VCAP))\n\t\tinfo->func[0] |= PMBUS_HAVE_VCAP;\n\tif (pmbus_check_word_register(client, 0, PMBUS_READ_IIN))\n\t\tinfo->func[0] |= PMBUS_HAVE_IIN;\n\tif (pmbus_check_word_register(client, 0, PMBUS_READ_PIN))\n\t\tinfo->func[0] |= PMBUS_HAVE_PIN;\n\tif (info->func[0]\n\t    && pmbus_check_byte_register(client, 0, PMBUS_STATUS_INPUT))\n\t\tinfo->func[0] |= PMBUS_HAVE_STATUS_INPUT;\n\tif (pmbus_check_byte_register(client, 0, PMBUS_FAN_CONFIG_12) &&\n\t    pmbus_check_word_register(client, 0, PMBUS_READ_FAN_SPEED_1)) {\n\t\tinfo->func[0] |= PMBUS_HAVE_FAN12;\n\t\tif (pmbus_check_byte_register(client, 0, PMBUS_STATUS_FAN_12))\n\t\t\tinfo->func[0] |= PMBUS_HAVE_STATUS_FAN12;\n\t}\n\tif (pmbus_check_byte_register(client, 0, PMBUS_FAN_CONFIG_34) &&\n\t    pmbus_check_word_register(client, 0, PMBUS_READ_FAN_SPEED_3)) {\n\t\tinfo->func[0] |= PMBUS_HAVE_FAN34;\n\t\tif (pmbus_check_byte_register(client, 0, PMBUS_STATUS_FAN_34))\n\t\t\tinfo->func[0] |= PMBUS_HAVE_STATUS_FAN34;\n\t}\n\tif (pmbus_check_word_register(client, 0, PMBUS_READ_TEMPERATURE_1))\n\t\tinfo->func[0] |= PMBUS_HAVE_TEMP;\n\tif (pmbus_check_word_register(client, 0, PMBUS_READ_TEMPERATURE_2))\n\t\tinfo->func[0] |= PMBUS_HAVE_TEMP2;\n\tif (pmbus_check_word_register(client, 0, PMBUS_READ_TEMPERATURE_3))\n\t\tinfo->func[0] |= PMBUS_HAVE_TEMP3;\n\tif (info->func[0] & (PMBUS_HAVE_TEMP | PMBUS_HAVE_TEMP2\n\t\t\t     | PMBUS_HAVE_TEMP3)\n\t    && pmbus_check_byte_register(client, 0,\n\t\t\t\t\t PMBUS_STATUS_TEMPERATURE))\n\t\t\tinfo->func[0] |= PMBUS_HAVE_STATUS_TEMP;\n\n\t \n\tfor (page = 0; page < info->pages; page++) {\n\t\tif (pmbus_check_word_register(client, page, PMBUS_READ_VOUT)) {\n\t\t\tinfo->func[page] |= PMBUS_HAVE_VOUT;\n\t\t\tif (pmbus_check_byte_register(client, page,\n\t\t\t\t\t\t      PMBUS_STATUS_VOUT))\n\t\t\t\tinfo->func[page] |= PMBUS_HAVE_STATUS_VOUT;\n\t\t}\n\t\tif (pmbus_check_word_register(client, page, PMBUS_READ_IOUT)) {\n\t\t\tinfo->func[page] |= PMBUS_HAVE_IOUT;\n\t\t\tif (pmbus_check_byte_register(client, 0,\n\t\t\t\t\t\t      PMBUS_STATUS_IOUT))\n\t\t\t\tinfo->func[page] |= PMBUS_HAVE_STATUS_IOUT;\n\t\t}\n\t\tif (pmbus_check_word_register(client, page, PMBUS_READ_POUT))\n\t\t\tinfo->func[page] |= PMBUS_HAVE_POUT;\n\t}\n}\n\n \nstatic int pmbus_identify(struct i2c_client *client,\n\t\t\t  struct pmbus_driver_info *info)\n{\n\tint ret = 0;\n\n\tif (!info->pages) {\n\t\t \n\t\tif (pmbus_check_byte_register(client, 0, PMBUS_PAGE)) {\n\t\t\tint page;\n\n\t\t\tfor (page = 1; page < PMBUS_PAGES; page++) {\n\t\t\t\tif (pmbus_set_page(client, page, 0xff) < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpmbus_set_page(client, 0, 0xff);\n\t\t\tinfo->pages = page;\n\t\t} else {\n\t\t\tinfo->pages = 1;\n\t\t}\n\n\t\tpmbus_clear_faults(client);\n\t}\n\n\tif (pmbus_check_byte_register(client, 0, PMBUS_VOUT_MODE)) {\n\t\tint vout_mode, i;\n\n\t\tvout_mode = pmbus_read_byte_data(client, 0, PMBUS_VOUT_MODE);\n\t\tif (vout_mode >= 0 && vout_mode != 0xff) {\n\t\t\tswitch (vout_mode >> 5) {\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tinfo->format[PSC_VOLTAGE_OUT] = vid;\n\t\t\t\tfor (i = 0; i < info->pages; i++)\n\t\t\t\t\tinfo->vrm_version[i] = vr11;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tinfo->format[PSC_VOLTAGE_OUT] = direct;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -ENODEV;\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (info->format[PSC_VOLTAGE_OUT] == direct) {\n\t\tret = -ENODEV;\n\t\tgoto abort;\n\t}\n\n\t \n\tpmbus_find_sensor_groups(client, info);\nabort:\n\treturn ret;\n}\n\nstatic int pmbus_probe(struct i2c_client *client)\n{\n\tstruct pmbus_driver_info *info;\n\tstruct pmbus_platform_data *pdata = NULL;\n\tstruct device *dev = &client->dev;\n\tstruct pmbus_device_info *device_info;\n\n\tinfo = devm_kzalloc(dev, sizeof(struct pmbus_driver_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tdevice_info = (struct pmbus_device_info *)i2c_match_id(pmbus_id, client)->driver_data;\n\tif (device_info->flags) {\n\t\tpdata = devm_kzalloc(dev, sizeof(struct pmbus_platform_data),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tpdata->flags = device_info->flags;\n\t}\n\n\tinfo->pages = device_info->pages;\n\tinfo->identify = pmbus_identify;\n\tdev->platform_data = pdata;\n\n\treturn pmbus_do_probe(client, info);\n}\n\nstatic const struct pmbus_device_info pmbus_info_one = {\n\t.pages = 1,\n\t.flags = 0\n};\n\nstatic const struct pmbus_device_info pmbus_info_zero = {\n\t.pages = 0,\n\t.flags = 0\n};\n\nstatic const struct pmbus_device_info pmbus_info_one_skip = {\n\t.pages = 1,\n\t.flags = PMBUS_SKIP_STATUS_CHECK\n};\n\nstatic const struct pmbus_device_info pmbus_info_one_status = {\n\t.pages = 1,\n\t.flags = PMBUS_READ_STATUS_AFTER_FAILED_CHECK\n};\n\n \nstatic const struct i2c_device_id pmbus_id[] = {\n\t{\"adp4000\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"bmr310\", (kernel_ulong_t)&pmbus_info_one_status},\n\t{\"bmr453\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"bmr454\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"bmr456\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"bmr457\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"bmr458\", (kernel_ulong_t)&pmbus_info_one_status},\n\t{\"bmr480\", (kernel_ulong_t)&pmbus_info_one_status},\n\t{\"bmr490\", (kernel_ulong_t)&pmbus_info_one_status},\n\t{\"bmr491\", (kernel_ulong_t)&pmbus_info_one_status},\n\t{\"bmr492\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"dps460\", (kernel_ulong_t)&pmbus_info_one_skip},\n\t{\"dps650ab\", (kernel_ulong_t)&pmbus_info_one_skip},\n\t{\"dps800\", (kernel_ulong_t)&pmbus_info_one_skip},\n\t{\"max20796\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"mdt040\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"ncp4200\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"ncp4208\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"pdt003\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"pdt006\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"pdt012\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"pmbus\", (kernel_ulong_t)&pmbus_info_zero},\n\t{\"sgd009\", (kernel_ulong_t)&pmbus_info_one_skip},\n\t{\"tps40400\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"tps544b20\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"tps544b25\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"tps544c20\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"tps544c25\", (kernel_ulong_t)&pmbus_info_one},\n\t{\"udt020\", (kernel_ulong_t)&pmbus_info_one},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, pmbus_id);\n\n \nstatic struct i2c_driver pmbus_driver = {\n\t.driver = {\n\t\t   .name = \"pmbus\",\n\t\t   },\n\t.probe = pmbus_probe,\n\t.id_table = pmbus_id,\n};\n\nmodule_i2c_driver(pmbus_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck\");\nMODULE_DESCRIPTION(\"Generic PMBus driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}