{
  "module_name": "adm1275.c",
  "hash_id": "dcba2a426f44b22456b1aacbff5fa9418e4e3c703b1a654662b8e54f055e783a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/adm1275.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/log2.h>\n#include \"pmbus.h\"\n\nenum chips { adm1075, adm1272, adm1275, adm1276, adm1278, adm1293, adm1294 };\n\n#define ADM1275_MFR_STATUS_IOUT_WARN2\tBIT(0)\n#define ADM1293_MFR_STATUS_VAUX_UV_WARN\tBIT(5)\n#define ADM1293_MFR_STATUS_VAUX_OV_WARN\tBIT(6)\n\n#define ADM1275_PEAK_IOUT\t\t0xd0\n#define ADM1275_PEAK_VIN\t\t0xd1\n#define ADM1275_PEAK_VOUT\t\t0xd2\n#define ADM1275_PMON_CONTROL\t\t0xd3\n#define ADM1275_PMON_CONFIG\t\t0xd4\n\n#define ADM1275_CONVERT_EN\t\tBIT(0)\n\n#define ADM1275_VIN_VOUT_SELECT\t\tBIT(6)\n#define ADM1275_VRANGE\t\t\tBIT(5)\n#define ADM1075_IRANGE_50\t\tBIT(4)\n#define ADM1075_IRANGE_25\t\tBIT(3)\n#define ADM1075_IRANGE_MASK\t\t(BIT(3) | BIT(4))\n\n#define ADM1272_IRANGE\t\t\tBIT(0)\n\n#define ADM1278_TSFILT\t\t\tBIT(15)\n#define ADM1278_TEMP1_EN\t\tBIT(3)\n#define ADM1278_VIN_EN\t\t\tBIT(2)\n#define ADM1278_VOUT_EN\t\t\tBIT(1)\n\n#define ADM1278_PMON_DEFCONFIG\t\t(ADM1278_VOUT_EN | ADM1278_TEMP1_EN | ADM1278_TSFILT)\n\n#define ADM1293_IRANGE_25\t\t0\n#define ADM1293_IRANGE_50\t\tBIT(6)\n#define ADM1293_IRANGE_100\t\tBIT(7)\n#define ADM1293_IRANGE_200\t\t(BIT(6) | BIT(7))\n#define ADM1293_IRANGE_MASK\t\t(BIT(6) | BIT(7))\n\n#define ADM1293_VIN_SEL_012\t\tBIT(2)\n#define ADM1293_VIN_SEL_074\t\tBIT(3)\n#define ADM1293_VIN_SEL_210\t\t(BIT(2) | BIT(3))\n#define ADM1293_VIN_SEL_MASK\t\t(BIT(2) | BIT(3))\n\n#define ADM1293_VAUX_EN\t\t\tBIT(1)\n\n#define ADM1278_PEAK_TEMP\t\t0xd7\n#define ADM1275_IOUT_WARN2_LIMIT\t0xd7\n#define ADM1275_DEVICE_CONFIG\t\t0xd8\n\n#define ADM1275_IOUT_WARN2_SELECT\tBIT(4)\n\n#define ADM1276_PEAK_PIN\t\t0xda\n#define ADM1075_READ_VAUX\t\t0xdd\n#define ADM1075_VAUX_OV_WARN_LIMIT\t0xde\n#define ADM1075_VAUX_UV_WARN_LIMIT\t0xdf\n#define ADM1293_IOUT_MIN\t\t0xe3\n#define ADM1293_PIN_MIN\t\t\t0xe4\n#define ADM1075_VAUX_STATUS\t\t0xf6\n\n#define ADM1075_VAUX_OV_WARN\t\tBIT(7)\n#define ADM1075_VAUX_UV_WARN\t\tBIT(6)\n\n#define ADM1275_VI_AVG_SHIFT\t\t0\n#define ADM1275_VI_AVG_MASK\t\tGENMASK(ADM1275_VI_AVG_SHIFT + 2, \\\n\t\t\t\t\t\tADM1275_VI_AVG_SHIFT)\n#define ADM1275_SAMPLES_AVG_MAX\t\t128\n\n#define ADM1278_PWR_AVG_SHIFT\t\t11\n#define ADM1278_PWR_AVG_MASK\t\tGENMASK(ADM1278_PWR_AVG_SHIFT + 2, \\\n\t\t\t\t\t\tADM1278_PWR_AVG_SHIFT)\n#define ADM1278_VI_AVG_SHIFT\t\t8\n#define ADM1278_VI_AVG_MASK\t\tGENMASK(ADM1278_VI_AVG_SHIFT + 2, \\\n\t\t\t\t\t\tADM1278_VI_AVG_SHIFT)\n\nstruct adm1275_data {\n\tint id;\n\tbool have_oc_fault;\n\tbool have_uc_fault;\n\tbool have_vout;\n\tbool have_vaux_status;\n\tbool have_mfr_vaux_status;\n\tbool have_iout_min;\n\tbool have_pin_min;\n\tbool have_pin_max;\n\tbool have_temp_max;\n\tbool have_power_sampling;\n\tstruct pmbus_driver_info info;\n};\n\n#define to_adm1275_data(x)  container_of(x, struct adm1275_data, info)\n\nstruct coefficients {\n\ts16 m;\n\ts16 b;\n\ts16 R;\n};\n\nstatic const struct coefficients adm1075_coefficients[] = {\n\t[0] = { 27169, 0, -1 },\t\t \n\t[1] = { 806, 20475, -1 },\t \n\t[2] = { 404, 20475, -1 },\t \n\t[3] = { 8549, 0, -1 },\t\t \n\t[4] = { 4279, 0, -1 },\t\t \n};\n\nstatic const struct coefficients adm1272_coefficients[] = {\n\t[0] = { 6770, 0, -2 },\t\t \n\t[1] = { 4062, 0, -2 },\t\t \n\t[2] = { 1326, 20480, -1 },\t \n\t[3] = { 663, 20480, -1 },\t \n\t[4] = { 3512, 0, -2 },\t\t \n\t[5] = { 21071, 0, -3 },\t\t \n\t[6] = { 17561, 0, -3 },\t\t \n\t[7] = { 10535, 0, -3 },\t\t \n\t[8] = { 42, 31871, -1 },\t \n\n};\n\nstatic const struct coefficients adm1275_coefficients[] = {\n\t[0] = { 19199, 0, -2 },\t\t \n\t[1] = { 6720, 0, -1 },\t\t \n\t[2] = { 807, 20475, -1 },\t \n};\n\nstatic const struct coefficients adm1276_coefficients[] = {\n\t[0] = { 19199, 0, -2 },\t\t \n\t[1] = { 6720, 0, -1 },\t\t \n\t[2] = { 807, 20475, -1 },\t \n\t[3] = { 6043, 0, -2 },\t\t \n\t[4] = { 2115, 0, -1 },\t\t \n};\n\nstatic const struct coefficients adm1278_coefficients[] = {\n\t[0] = { 19599, 0, -2 },\t\t \n\t[1] = { 800, 20475, -1 },\t \n\t[2] = { 6123, 0, -2 },\t\t \n\t[3] = { 42, 31880, -1 },\t \n};\n\nstatic const struct coefficients adm1293_coefficients[] = {\n\t[0] = { 3333, -1, 0 },\t\t \n\t[1] = { 5552, -5, -1 },\t\t \n\t[2] = { 19604, -50, -2 },\t \n\t[3] = { 8000, -100, -2 },\t \n\t[4] = { 4000, -100, -2 },\t \n\t[5] = { 20000, -1000, -3 },\t \n\t[6] = { 10000, -1000, -3 },\t \n\t[7] = { 10417, 0, -1 },\t\t \n\t[8] = { 5208, 0, -1 },\t\t \n\t[9] = { 26042, 0, -2 },\t\t \n\t[10] = { 13021, 0, -2 },\t \n\t[11] = { 17351, 0, -2 },\t \n\t[12] = { 8676, 0, -2 },\t\t \n\t[13] = { 4338, 0, -2 },\t\t \n\t[14] = { 21689, 0, -3 },\t \n\t[15] = { 6126, 0, -2 },\t\t \n\t[16] = { 30631, 0, -3 },\t \n\t[17] = { 15316, 0, -3 },\t \n\t[18] = { 7658, 0, -3 },\t\t \n};\n\nstatic int adm1275_read_samples(const struct adm1275_data *data,\n\t\t\t\tstruct i2c_client *client, bool is_power)\n{\n\tint shift, ret;\n\tu16 mask;\n\n\t \n\tif (data->have_power_sampling) {\n\t\tret = i2c_smbus_read_word_data(client, ADM1275_PMON_CONFIG);\n\t\tmask = is_power ? ADM1278_PWR_AVG_MASK : ADM1278_VI_AVG_MASK;\n\t\tshift = is_power ? ADM1278_PWR_AVG_SHIFT : ADM1278_VI_AVG_SHIFT;\n\t} else {\n\t\tret = i2c_smbus_read_byte_data(client, ADM1275_PMON_CONFIG);\n\t\tmask = ADM1275_VI_AVG_MASK;\n\t\tshift = ADM1275_VI_AVG_SHIFT;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (ret & mask) >> shift;\n}\n\nstatic int adm1275_write_pmon_config(const struct adm1275_data *data,\n\t\t\t\t     struct i2c_client *client, u16 word)\n{\n\tint ret, ret2;\n\n\tret = i2c_smbus_write_byte_data(client, ADM1275_PMON_CONTROL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data->have_power_sampling)\n\t\tret = i2c_smbus_write_word_data(client, ADM1275_PMON_CONFIG,\n\t\t\t\t\t\tword);\n\telse\n\t\tret = i2c_smbus_write_byte_data(client, ADM1275_PMON_CONFIG,\n\t\t\t\t\t\tword);\n\n\t \n\tret2 = i2c_smbus_write_byte_data(client, ADM1275_PMON_CONTROL,\n\t\t\t\t\t ADM1275_CONVERT_EN);\n\tif (!ret)\n\t\tret = ret2;\n\n\treturn ret;\n}\n\nstatic int adm1275_write_samples(const struct adm1275_data *data,\n\t\t\t\t struct i2c_client *client,\n\t\t\t\t bool is_power, u16 word)\n{\n\tint shift, ret;\n\tu16 mask;\n\n\tif (data->have_power_sampling) {\n\t\tret = i2c_smbus_read_word_data(client, ADM1275_PMON_CONFIG);\n\t\tmask = is_power ? ADM1278_PWR_AVG_MASK : ADM1278_VI_AVG_MASK;\n\t\tshift = is_power ? ADM1278_PWR_AVG_SHIFT : ADM1278_VI_AVG_SHIFT;\n\t} else {\n\t\tret = i2c_smbus_read_byte_data(client, ADM1275_PMON_CONFIG);\n\t\tmask = ADM1275_VI_AVG_MASK;\n\t\tshift = ADM1275_VI_AVG_SHIFT;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\tword = (ret & ~mask) | ((word << shift) & mask);\n\n\treturn adm1275_write_pmon_config(data, client, word);\n}\n\nstatic int adm1275_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t  int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tconst struct adm1275_data *data = to_adm1275_data(info);\n\tint ret = 0;\n\n\tif (page > 0)\n\t\treturn -ENXIO;\n\n\tswitch (reg) {\n\tcase PMBUS_IOUT_UC_FAULT_LIMIT:\n\t\tif (!data->have_uc_fault)\n\t\t\treturn -ENXIO;\n\t\tret = pmbus_read_word_data(client, 0, 0xff,\n\t\t\t\t\t   ADM1275_IOUT_WARN2_LIMIT);\n\t\tbreak;\n\tcase PMBUS_IOUT_OC_FAULT_LIMIT:\n\t\tif (!data->have_oc_fault)\n\t\t\treturn -ENXIO;\n\t\tret = pmbus_read_word_data(client, 0, 0xff,\n\t\t\t\t\t   ADM1275_IOUT_WARN2_LIMIT);\n\t\tbreak;\n\tcase PMBUS_VOUT_OV_WARN_LIMIT:\n\t\tif (data->have_vout)\n\t\t\treturn -ENODATA;\n\t\tret = pmbus_read_word_data(client, 0, 0xff,\n\t\t\t\t\t   ADM1075_VAUX_OV_WARN_LIMIT);\n\t\tbreak;\n\tcase PMBUS_VOUT_UV_WARN_LIMIT:\n\t\tif (data->have_vout)\n\t\t\treturn -ENODATA;\n\t\tret = pmbus_read_word_data(client, 0, 0xff,\n\t\t\t\t\t   ADM1075_VAUX_UV_WARN_LIMIT);\n\t\tbreak;\n\tcase PMBUS_READ_VOUT:\n\t\tif (data->have_vout)\n\t\t\treturn -ENODATA;\n\t\tret = pmbus_read_word_data(client, 0, 0xff,\n\t\t\t\t\t   ADM1075_READ_VAUX);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_IOUT_MIN:\n\t\tif (!data->have_iout_min)\n\t\t\treturn -ENXIO;\n\t\tret = pmbus_read_word_data(client, 0, 0xff,\n\t\t\t\t\t   ADM1293_IOUT_MIN);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_IOUT_MAX:\n\t\tret = pmbus_read_word_data(client, 0, 0xff,\n\t\t\t\t\t   ADM1275_PEAK_IOUT);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_VOUT_MAX:\n\t\tret = pmbus_read_word_data(client, 0, 0xff,\n\t\t\t\t\t   ADM1275_PEAK_VOUT);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_VIN_MAX:\n\t\tret = pmbus_read_word_data(client, 0, 0xff,\n\t\t\t\t\t   ADM1275_PEAK_VIN);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_PIN_MIN:\n\t\tif (!data->have_pin_min)\n\t\t\treturn -ENXIO;\n\t\tret = pmbus_read_word_data(client, 0, 0xff,\n\t\t\t\t\t   ADM1293_PIN_MIN);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_PIN_MAX:\n\t\tif (!data->have_pin_max)\n\t\t\treturn -ENXIO;\n\t\tret = pmbus_read_word_data(client, 0, 0xff,\n\t\t\t\t\t   ADM1276_PEAK_PIN);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_TEMP_MAX:\n\t\tif (!data->have_temp_max)\n\t\t\treturn -ENXIO;\n\t\tret = pmbus_read_word_data(client, 0, 0xff,\n\t\t\t\t\t   ADM1278_PEAK_TEMP);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_IOUT_HISTORY:\n\tcase PMBUS_VIRT_RESET_VOUT_HISTORY:\n\tcase PMBUS_VIRT_RESET_VIN_HISTORY:\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_PIN_HISTORY:\n\t\tif (!data->have_pin_max)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_TEMP_HISTORY:\n\t\tif (!data->have_temp_max)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase PMBUS_VIRT_POWER_SAMPLES:\n\t\tif (!data->have_power_sampling)\n\t\t\treturn -ENXIO;\n\t\tret = adm1275_read_samples(data, client, true);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = BIT(ret);\n\t\tbreak;\n\tcase PMBUS_VIRT_IN_SAMPLES:\n\tcase PMBUS_VIRT_CURR_SAMPLES:\n\t\tret = adm1275_read_samples(data, client, false);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = BIT(ret);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int adm1275_write_word_data(struct i2c_client *client, int page, int reg,\n\t\t\t\t   u16 word)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tconst struct adm1275_data *data = to_adm1275_data(info);\n\tint ret;\n\n\tif (page > 0)\n\t\treturn -ENXIO;\n\n\tswitch (reg) {\n\tcase PMBUS_IOUT_UC_FAULT_LIMIT:\n\tcase PMBUS_IOUT_OC_FAULT_LIMIT:\n\t\tret = pmbus_write_word_data(client, 0, ADM1275_IOUT_WARN2_LIMIT,\n\t\t\t\t\t    word);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_IOUT_HISTORY:\n\t\tret = pmbus_write_word_data(client, 0, ADM1275_PEAK_IOUT, 0);\n\t\tif (!ret && data->have_iout_min)\n\t\t\tret = pmbus_write_word_data(client, 0,\n\t\t\t\t\t\t    ADM1293_IOUT_MIN, 0);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_VOUT_HISTORY:\n\t\tret = pmbus_write_word_data(client, 0, ADM1275_PEAK_VOUT, 0);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_VIN_HISTORY:\n\t\tret = pmbus_write_word_data(client, 0, ADM1275_PEAK_VIN, 0);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_PIN_HISTORY:\n\t\tret = pmbus_write_word_data(client, 0, ADM1276_PEAK_PIN, 0);\n\t\tif (!ret && data->have_pin_min)\n\t\t\tret = pmbus_write_word_data(client, 0,\n\t\t\t\t\t\t    ADM1293_PIN_MIN, 0);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_TEMP_HISTORY:\n\t\tret = pmbus_write_word_data(client, 0, ADM1278_PEAK_TEMP, 0);\n\t\tbreak;\n\tcase PMBUS_VIRT_POWER_SAMPLES:\n\t\tif (!data->have_power_sampling)\n\t\t\treturn -ENXIO;\n\t\tword = clamp_val(word, 1, ADM1275_SAMPLES_AVG_MAX);\n\t\tret = adm1275_write_samples(data, client, true, ilog2(word));\n\t\tbreak;\n\tcase PMBUS_VIRT_IN_SAMPLES:\n\tcase PMBUS_VIRT_CURR_SAMPLES:\n\t\tword = clamp_val(word, 1, ADM1275_SAMPLES_AVG_MAX);\n\t\tret = adm1275_write_samples(data, client, false, ilog2(word));\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int adm1275_read_byte_data(struct i2c_client *client, int page, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tconst struct adm1275_data *data = to_adm1275_data(info);\n\tint mfr_status, ret;\n\n\tif (page > 0)\n\t\treturn -ENXIO;\n\n\tswitch (reg) {\n\tcase PMBUS_STATUS_IOUT:\n\t\tret = pmbus_read_byte_data(client, page, PMBUS_STATUS_IOUT);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (!data->have_oc_fault && !data->have_uc_fault)\n\t\t\tbreak;\n\t\tmfr_status = pmbus_read_byte_data(client, page,\n\t\t\t\t\t\t  PMBUS_STATUS_MFR_SPECIFIC);\n\t\tif (mfr_status < 0)\n\t\t\treturn mfr_status;\n\t\tif (mfr_status & ADM1275_MFR_STATUS_IOUT_WARN2) {\n\t\t\tret |= data->have_oc_fault ?\n\t\t\t  PB_IOUT_OC_FAULT : PB_IOUT_UC_FAULT;\n\t\t}\n\t\tbreak;\n\tcase PMBUS_STATUS_VOUT:\n\t\tif (data->have_vout)\n\t\t\treturn -ENODATA;\n\t\tret = 0;\n\t\tif (data->have_vaux_status) {\n\t\t\tmfr_status = pmbus_read_byte_data(client, 0,\n\t\t\t\t\t\t\t  ADM1075_VAUX_STATUS);\n\t\t\tif (mfr_status < 0)\n\t\t\t\treturn mfr_status;\n\t\t\tif (mfr_status & ADM1075_VAUX_OV_WARN)\n\t\t\t\tret |= PB_VOLTAGE_OV_WARNING;\n\t\t\tif (mfr_status & ADM1075_VAUX_UV_WARN)\n\t\t\t\tret |= PB_VOLTAGE_UV_WARNING;\n\t\t} else if (data->have_mfr_vaux_status) {\n\t\t\tmfr_status = pmbus_read_byte_data(client, page,\n\t\t\t\t\t\tPMBUS_STATUS_MFR_SPECIFIC);\n\t\t\tif (mfr_status < 0)\n\t\t\t\treturn mfr_status;\n\t\t\tif (mfr_status & ADM1293_MFR_STATUS_VAUX_OV_WARN)\n\t\t\t\tret |= PB_VOLTAGE_OV_WARNING;\n\t\t\tif (mfr_status & ADM1293_MFR_STATUS_VAUX_UV_WARN)\n\t\t\t\tret |= PB_VOLTAGE_UV_WARNING;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct i2c_device_id adm1275_id[] = {\n\t{ \"adm1075\", adm1075 },\n\t{ \"adm1272\", adm1272 },\n\t{ \"adm1275\", adm1275 },\n\t{ \"adm1276\", adm1276 },\n\t{ \"adm1278\", adm1278 },\n\t{ \"adm1293\", adm1293 },\n\t{ \"adm1294\", adm1294 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adm1275_id);\n\n \nstatic int adm1275_enable_vout_temp(struct adm1275_data *data,\n\t\t\t\t    struct i2c_client *client, int config)\n{\n\tint ret;\n\n\tif ((config & ADM1278_PMON_DEFCONFIG) != ADM1278_PMON_DEFCONFIG) {\n\t\tconfig |= ADM1278_PMON_DEFCONFIG;\n\t\tret = adm1275_write_pmon_config(data, client, config);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"Failed to enable VOUT/TEMP1 monitoring\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int adm1275_probe(struct i2c_client *client)\n{\n\ts32 (*config_read_fn)(const struct i2c_client *client, u8 reg);\n\tu8 block_buffer[I2C_SMBUS_BLOCK_MAX + 1];\n\tint config, device_config;\n\tint ret;\n\tstruct pmbus_driver_info *info;\n\tstruct adm1275_data *data;\n\tconst struct i2c_device_id *mid;\n\tconst struct coefficients *coefficients;\n\tint vindex = -1, voindex = -1, cindex = -1, pindex = -1;\n\tint tindex = -1;\n\tu32 shunt;\n\tu32 avg;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_BLOCK_DATA))\n\t\treturn -ENODEV;\n\n\tret = i2c_smbus_read_block_data(client, PMBUS_MFR_ID, block_buffer);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to read Manufacturer ID\\n\");\n\t\treturn ret;\n\t}\n\tif (ret != 3 || strncmp(block_buffer, \"ADI\", 3)) {\n\t\tdev_err(&client->dev, \"Unsupported Manufacturer ID\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = i2c_smbus_read_block_data(client, PMBUS_MFR_MODEL, block_buffer);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to read Manufacturer Model\\n\");\n\t\treturn ret;\n\t}\n\tfor (mid = adm1275_id; mid->name[0]; mid++) {\n\t\tif (!strncasecmp(mid->name, block_buffer, strlen(mid->name)))\n\t\t\tbreak;\n\t}\n\tif (!mid->name[0]) {\n\t\tdev_err(&client->dev, \"Unsupported device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (strcmp(client->name, mid->name) != 0)\n\t\tdev_notice(&client->dev,\n\t\t\t   \"Device mismatch: Configured %s, detected %s\\n\",\n\t\t\t   client->name, mid->name);\n\n\tif (mid->driver_data == adm1272 || mid->driver_data == adm1278 ||\n\t    mid->driver_data == adm1293 || mid->driver_data == adm1294)\n\t\tconfig_read_fn = i2c_smbus_read_word_data;\n\telse\n\t\tconfig_read_fn = i2c_smbus_read_byte_data;\n\tconfig = config_read_fn(client, ADM1275_PMON_CONFIG);\n\tif (config < 0)\n\t\treturn config;\n\n\tdevice_config = config_read_fn(client, ADM1275_DEVICE_CONFIG);\n\tif (device_config < 0)\n\t\treturn device_config;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct adm1275_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (of_property_read_u32(client->dev.of_node,\n\t\t\t\t \"shunt-resistor-micro-ohms\", &shunt))\n\t\tshunt = 1000;  \n\n\tif (shunt == 0)\n\t\treturn -EINVAL;\n\n\tdata->id = mid->driver_data;\n\n\tinfo = &data->info;\n\n\tinfo->pages = 1;\n\tinfo->format[PSC_VOLTAGE_IN] = direct;\n\tinfo->format[PSC_VOLTAGE_OUT] = direct;\n\tinfo->format[PSC_CURRENT_OUT] = direct;\n\tinfo->format[PSC_POWER] = direct;\n\tinfo->format[PSC_TEMPERATURE] = direct;\n\tinfo->func[0] = PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT |\n\t\t\tPMBUS_HAVE_SAMPLES;\n\n\tinfo->read_word_data = adm1275_read_word_data;\n\tinfo->read_byte_data = adm1275_read_byte_data;\n\tinfo->write_word_data = adm1275_write_word_data;\n\n\tswitch (data->id) {\n\tcase adm1075:\n\t\tif (device_config & ADM1275_IOUT_WARN2_SELECT)\n\t\t\tdata->have_oc_fault = true;\n\t\telse\n\t\t\tdata->have_uc_fault = true;\n\t\tdata->have_pin_max = true;\n\t\tdata->have_vaux_status = true;\n\n\t\tcoefficients = adm1075_coefficients;\n\t\tvindex = 0;\n\t\tswitch (config & ADM1075_IRANGE_MASK) {\n\t\tcase ADM1075_IRANGE_25:\n\t\t\tcindex = 1;\n\t\t\tpindex = 3;\n\t\t\tbreak;\n\t\tcase ADM1075_IRANGE_50:\n\t\t\tcindex = 2;\n\t\t\tpindex = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&client->dev, \"Invalid input current range\");\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->func[0] |= PMBUS_HAVE_VIN | PMBUS_HAVE_PIN\n\t\t  | PMBUS_HAVE_STATUS_INPUT;\n\t\tif (config & ADM1275_VIN_VOUT_SELECT)\n\t\t\tinfo->func[0] |=\n\t\t\t  PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT;\n\t\tbreak;\n\tcase adm1272:\n\t\tdata->have_vout = true;\n\t\tdata->have_pin_max = true;\n\t\tdata->have_temp_max = true;\n\t\tdata->have_power_sampling = true;\n\n\t\tcoefficients = adm1272_coefficients;\n\t\tvindex = (config & ADM1275_VRANGE) ? 1 : 0;\n\t\tcindex = (config & ADM1272_IRANGE) ? 3 : 2;\n\t\t \n\t\tswitch (config & (ADM1275_VRANGE | ADM1272_IRANGE)) {\n\t\tcase 0:\n\t\tdefault:\n\t\t\tpindex = 4;\n\t\t\tbreak;\n\t\tcase ADM1275_VRANGE:\n\t\t\tpindex = 5;\n\t\t\tbreak;\n\t\tcase ADM1272_IRANGE:\n\t\t\tpindex = 6;\n\t\t\tbreak;\n\t\tcase ADM1275_VRANGE | ADM1272_IRANGE:\n\t\t\tpindex = 7;\n\t\t\tbreak;\n\t\t}\n\t\ttindex = 8;\n\n\t\tinfo->func[0] |= PMBUS_HAVE_PIN | PMBUS_HAVE_STATUS_INPUT |\n\t\t\tPMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT |\n\t\t\tPMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\n\n\t\tret = adm1275_enable_vout_temp(data, client, config);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (config & ADM1278_VIN_EN)\n\t\t\tinfo->func[0] |= PMBUS_HAVE_VIN;\n\t\tbreak;\n\tcase adm1275:\n\t\tif (device_config & ADM1275_IOUT_WARN2_SELECT)\n\t\t\tdata->have_oc_fault = true;\n\t\telse\n\t\t\tdata->have_uc_fault = true;\n\t\tdata->have_vout = true;\n\n\t\tcoefficients = adm1275_coefficients;\n\t\tvindex = (config & ADM1275_VRANGE) ? 0 : 1;\n\t\tcindex = 2;\n\n\t\tif (config & ADM1275_VIN_VOUT_SELECT)\n\t\t\tinfo->func[0] |=\n\t\t\t  PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT;\n\t\telse\n\t\t\tinfo->func[0] |=\n\t\t\t  PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT;\n\t\tbreak;\n\tcase adm1276:\n\t\tif (device_config & ADM1275_IOUT_WARN2_SELECT)\n\t\t\tdata->have_oc_fault = true;\n\t\telse\n\t\t\tdata->have_uc_fault = true;\n\t\tdata->have_vout = true;\n\t\tdata->have_pin_max = true;\n\n\t\tcoefficients = adm1276_coefficients;\n\t\tvindex = (config & ADM1275_VRANGE) ? 0 : 1;\n\t\tcindex = 2;\n\t\tpindex = (config & ADM1275_VRANGE) ? 3 : 4;\n\n\t\tinfo->func[0] |= PMBUS_HAVE_VIN | PMBUS_HAVE_PIN\n\t\t  | PMBUS_HAVE_STATUS_INPUT;\n\t\tif (config & ADM1275_VIN_VOUT_SELECT)\n\t\t\tinfo->func[0] |=\n\t\t\t  PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT;\n\t\tbreak;\n\tcase adm1278:\n\t\tdata->have_vout = true;\n\t\tdata->have_pin_max = true;\n\t\tdata->have_temp_max = true;\n\t\tdata->have_power_sampling = true;\n\n\t\tcoefficients = adm1278_coefficients;\n\t\tvindex = 0;\n\t\tcindex = 1;\n\t\tpindex = 2;\n\t\ttindex = 3;\n\n\t\tinfo->func[0] |= PMBUS_HAVE_PIN | PMBUS_HAVE_STATUS_INPUT |\n\t\t\tPMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT |\n\t\t\tPMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\n\n\t\tret = adm1275_enable_vout_temp(data, client, config);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (config & ADM1278_VIN_EN)\n\t\t\tinfo->func[0] |= PMBUS_HAVE_VIN;\n\t\tbreak;\n\tcase adm1293:\n\tcase adm1294:\n\t\tdata->have_iout_min = true;\n\t\tdata->have_pin_min = true;\n\t\tdata->have_pin_max = true;\n\t\tdata->have_mfr_vaux_status = true;\n\t\tdata->have_power_sampling = true;\n\n\t\tcoefficients = adm1293_coefficients;\n\n\t\tvoindex = 0;\n\t\tswitch (config & ADM1293_VIN_SEL_MASK) {\n\t\tcase ADM1293_VIN_SEL_012:\t \n\t\t\tvindex = 0;\n\t\t\tbreak;\n\t\tcase ADM1293_VIN_SEL_074:\t \n\t\t\tvindex = 1;\n\t\t\tbreak;\n\t\tcase ADM1293_VIN_SEL_210:\t \n\t\t\tvindex = 2;\n\t\t\tbreak;\n\t\tdefault:\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (config & ADM1293_IRANGE_MASK) {\n\t\tcase ADM1293_IRANGE_25:\n\t\t\tcindex = 3;\n\t\t\tbreak;\n\t\tcase ADM1293_IRANGE_50:\n\t\t\tcindex = 4;\n\t\t\tbreak;\n\t\tcase ADM1293_IRANGE_100:\n\t\t\tcindex = 5;\n\t\t\tbreak;\n\t\tcase ADM1293_IRANGE_200:\n\t\t\tcindex = 6;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (vindex >= 0)\n\t\t\tpindex = 7 + vindex * 4 + (cindex - 3);\n\n\t\tif (config & ADM1293_VAUX_EN)\n\t\t\tinfo->func[0] |=\n\t\t\t\tPMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT;\n\n\t\tinfo->func[0] |= PMBUS_HAVE_PIN |\n\t\t\tPMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT;\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"Unsupported device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (data->have_power_sampling &&\n\t    of_property_read_u32(client->dev.of_node,\n\t\t\t\t \"adi,power-sample-average\", &avg) == 0) {\n\t\tif (!avg || avg > ADM1275_SAMPLES_AVG_MAX ||\n\t\t    BIT(__fls(avg)) != avg) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid number of power samples\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = adm1275_write_samples(data, client, true, ilog2(avg));\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Setting power sample averaging failed with error %d\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (of_property_read_u32(client->dev.of_node,\n\t\t\t\t\"adi,volt-curr-sample-average\", &avg) == 0) {\n\t\tif (!avg || avg > ADM1275_SAMPLES_AVG_MAX ||\n\t\t    BIT(__fls(avg)) != avg) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid number of voltage/current samples\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = adm1275_write_samples(data, client, false, ilog2(avg));\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Setting voltage and current sample averaging failed with error %d\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (voindex < 0)\n\t\tvoindex = vindex;\n\tif (vindex >= 0) {\n\t\tinfo->m[PSC_VOLTAGE_IN] = coefficients[vindex].m;\n\t\tinfo->b[PSC_VOLTAGE_IN] = coefficients[vindex].b;\n\t\tinfo->R[PSC_VOLTAGE_IN] = coefficients[vindex].R;\n\t}\n\tif (voindex >= 0) {\n\t\tinfo->m[PSC_VOLTAGE_OUT] = coefficients[voindex].m;\n\t\tinfo->b[PSC_VOLTAGE_OUT] = coefficients[voindex].b;\n\t\tinfo->R[PSC_VOLTAGE_OUT] = coefficients[voindex].R;\n\t}\n\tif (cindex >= 0) {\n\t\t \n\t\tinfo->m[PSC_CURRENT_OUT] =\n\t\t\tcoefficients[cindex].m * shunt / 1000;\n\t\tinfo->b[PSC_CURRENT_OUT] = coefficients[cindex].b;\n\t\tinfo->R[PSC_CURRENT_OUT] = coefficients[cindex].R;\n\t}\n\tif (pindex >= 0) {\n\t\tinfo->m[PSC_POWER] =\n\t\t\tcoefficients[pindex].m * shunt / 1000;\n\t\tinfo->b[PSC_POWER] = coefficients[pindex].b;\n\t\tinfo->R[PSC_POWER] = coefficients[pindex].R;\n\t}\n\tif (tindex >= 0) {\n\t\tinfo->m[PSC_TEMPERATURE] = coefficients[tindex].m;\n\t\tinfo->b[PSC_TEMPERATURE] = coefficients[tindex].b;\n\t\tinfo->R[PSC_TEMPERATURE] = coefficients[tindex].R;\n\t}\n\n\treturn pmbus_do_probe(client, info);\n}\n\nstatic struct i2c_driver adm1275_driver = {\n\t.driver = {\n\t\t   .name = \"adm1275\",\n\t\t   },\n\t.probe = adm1275_probe,\n\t.id_table = adm1275_id,\n};\n\nmodule_i2c_driver(adm1275_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck\");\nMODULE_DESCRIPTION(\"PMBus driver for Analog Devices ADM1275 and compatibles\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}