{
  "module_name": "ltc2978.c",
  "hash_id": "03124234c63cf4e17f63fe95d8b3044940c06096441c70fccc63fbd9e75395c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/ltc2978.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/regulator/driver.h>\n#include \"pmbus.h\"\n\nenum chips {\n\t \n\tltc2972, ltc2974, ltc2975, ltc2977, ltc2978, ltc2979, ltc2980,\n\t \n\tltc3880, ltc3882, ltc3883, ltc3884, ltc3886, ltc3887, ltc3889, ltc7132, ltc7880,\n\t \n\tltm2987, ltm4664, ltm4675, ltm4676, ltm4677, ltm4678, ltm4680, ltm4686,\n\tltm4700,\n};\n\n \n#define LTC2978_MFR_VOUT_PEAK\t\t0xdd\n#define LTC2978_MFR_VIN_PEAK\t\t0xde\n#define LTC2978_MFR_TEMPERATURE_PEAK\t0xdf\n#define LTC2978_MFR_SPECIAL_ID\t\t0xe7\t \n#define LTC2978_MFR_COMMON\t\t0xef\n\n \n#define LTC2978_MFR_VOUT_MIN\t\t0xfb\n#define LTC2978_MFR_VIN_MIN\t\t0xfc\n#define LTC2978_MFR_TEMPERATURE_MIN\t0xfd\n\n \n#define LTC2974_MFR_IOUT_PEAK\t\t0xd7\n#define LTC2974_MFR_IOUT_MIN\t\t0xd8\n\n \n#define LTC3880_MFR_IOUT_PEAK\t\t0xd7\n#define LTC3880_MFR_CLEAR_PEAKS\t\t0xe3\n#define LTC3880_MFR_TEMPERATURE2_PEAK\t0xf4\n\n \n#define LTC3883_MFR_IIN_PEAK\t\t0xe1\n\n \n#define LTC2975_MFR_IIN_PEAK\t\t0xc4\n#define LTC2975_MFR_IIN_MIN\t\t0xc5\n#define LTC2975_MFR_PIN_PEAK\t\t0xc6\n#define LTC2975_MFR_PIN_MIN\t\t0xc7\n\n#define LTC2978_ID_MASK\t\t\t0xfff0\n\n#define LTC2972_ID\t\t\t0x0310\n#define LTC2974_ID\t\t\t0x0210\n#define LTC2975_ID\t\t\t0x0220\n#define LTC2977_ID\t\t\t0x0130\n#define LTC2978_ID_REV1\t\t\t0x0110\t \n#define LTC2978_ID_REV2\t\t\t0x0120\n#define LTC2979_ID_A\t\t\t0x8060\n#define LTC2979_ID_B\t\t\t0x8070\n#define LTC2980_ID_A\t\t\t0x8030\t \n#define LTC2980_ID_B\t\t\t0x8040\n#define LTC3880_ID\t\t\t0x4020\n#define LTC3882_ID\t\t\t0x4200\n#define LTC3882_ID_D1\t\t\t0x4240\t \n#define LTC3883_ID\t\t\t0x4300\n#define LTC3884_ID\t\t\t0x4C00\n#define LTC3886_ID\t\t\t0x4600\n#define LTC3887_ID\t\t\t0x4700\n#define LTC3889_ID\t\t\t0x4900\n#define LTC7132_ID\t\t\t0x4CE0\n#define LTC7880_ID\t\t\t0x49E0\n#define LTM2987_ID_A\t\t\t0x8010\t \n#define LTM2987_ID_B\t\t\t0x8020\n#define LTM4664_ID\t\t\t0x4120\n#define LTM4675_ID\t\t\t0x47a0\n#define LTM4676_ID_REV1\t\t\t0x4400\n#define LTM4676_ID_REV2\t\t\t0x4480\n#define LTM4676A_ID\t\t\t0x47e0\n#define LTM4677_ID_REV1\t\t\t0x47B0\n#define LTM4677_ID_REV2\t\t\t0x47D0\n#define LTM4678_ID_REV1\t\t\t0x4100\n#define LTM4678_ID_REV2\t\t\t0x4110\n#define LTM4680_ID\t\t\t0x4140\n#define LTM4686_ID\t\t\t0x4770\n#define LTM4700_ID\t\t\t0x4130\n\n#define LTC2972_NUM_PAGES\t\t2\n#define LTC2974_NUM_PAGES\t\t4\n#define LTC2978_NUM_PAGES\t\t8\n#define LTC3880_NUM_PAGES\t\t2\n#define LTC3883_NUM_PAGES\t\t1\n\n#define LTC_POLL_TIMEOUT\t\t100\t \n\n#define LTC_NOT_BUSY\t\t\tBIT(6)\n#define LTC_NOT_PENDING\t\t\tBIT(5)\n\n \n\nstruct ltc2978_data {\n\tenum chips id;\n\tu16 vin_min, vin_max;\n\tu16 temp_min[LTC2974_NUM_PAGES], temp_max[LTC2974_NUM_PAGES];\n\tu16 vout_min[LTC2978_NUM_PAGES], vout_max[LTC2978_NUM_PAGES];\n\tu16 iout_min[LTC2974_NUM_PAGES], iout_max[LTC2974_NUM_PAGES];\n\tu16 iin_min, iin_max;\n\tu16 pin_min, pin_max;\n\tu16 temp2_max;\n\tstruct pmbus_driver_info info;\n\tu32 features;\n};\n#define to_ltc2978_data(x)  container_of(x, struct ltc2978_data, info)\n\n#define FEAT_CLEAR_PEAKS\tBIT(0)\n#define FEAT_NEEDS_POLLING\tBIT(1)\n\n#define has_clear_peaks(d)\t((d)->features & FEAT_CLEAR_PEAKS)\n#define needs_polling(d)\t((d)->features & FEAT_NEEDS_POLLING)\n\nstatic int ltc_wait_ready(struct i2c_client *client)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(LTC_POLL_TIMEOUT);\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct ltc2978_data *data = to_ltc2978_data(info);\n\tint status;\n\tu8 mask;\n\n\tif (!needs_polling(data))\n\t\treturn 0;\n\n\t \n\tmask = LTC_NOT_BUSY;\n\tif (data->id != ltc3883)\n\t\tmask |= LTC_NOT_PENDING;\n\n\tdo {\n\t\tstatus = pmbus_read_byte_data(client, 0, LTC2978_MFR_COMMON);\n\t\tif (status == -EBADMSG || status == -ENXIO) {\n\t\t\t \n\t\t\tusleep_range(50, 100);\n\t\t\tcontinue;\n\t\t}\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tif ((status & mask) == mask)\n\t\t\treturn 0;\n\n\t\tusleep_range(50, 100);\n\t} while (time_before(jiffies, timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int ltc_read_word_data(struct i2c_client *client, int page, int phase,\n\t\t\t      int reg)\n{\n\tint ret;\n\n\tret = ltc_wait_ready(client);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn pmbus_read_word_data(client, page, 0xff, reg);\n}\n\nstatic int ltc_read_byte_data(struct i2c_client *client, int page, int reg)\n{\n\tint ret;\n\n\tret = ltc_wait_ready(client);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn pmbus_read_byte_data(client, page, reg);\n}\n\nstatic int ltc_write_byte_data(struct i2c_client *client, int page, int reg, u8 value)\n{\n\tint ret;\n\n\tret = ltc_wait_ready(client);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn pmbus_write_byte_data(client, page, reg, value);\n}\n\nstatic int ltc_write_byte(struct i2c_client *client, int page, u8 byte)\n{\n\tint ret;\n\n\tret = ltc_wait_ready(client);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn pmbus_write_byte(client, page, byte);\n}\n\nstatic inline int lin11_to_val(int data)\n{\n\ts16 e = ((s16)data) >> 11;\n\ts32 m = (((s16)(data << 5)) >> 5);\n\n\t \n\te += 6;\n\treturn (e < 0 ? m >> -e : m << e);\n}\n\nstatic int ltc_get_max(struct ltc2978_data *data, struct i2c_client *client,\n\t\t       int page, int reg, u16 *pmax)\n{\n\tint ret;\n\n\tret = ltc_read_word_data(client, page, 0xff, reg);\n\tif (ret >= 0) {\n\t\tif (lin11_to_val(ret) > lin11_to_val(*pmax))\n\t\t\t*pmax = ret;\n\t\tret = *pmax;\n\t}\n\treturn ret;\n}\n\nstatic int ltc_get_min(struct ltc2978_data *data, struct i2c_client *client,\n\t\t       int page, int reg, u16 *pmin)\n{\n\tint ret;\n\n\tret = ltc_read_word_data(client, page, 0xff, reg);\n\tif (ret >= 0) {\n\t\tif (lin11_to_val(ret) < lin11_to_val(*pmin))\n\t\t\t*pmin = ret;\n\t\tret = *pmin;\n\t}\n\treturn ret;\n}\n\nstatic int ltc2978_read_word_data_common(struct i2c_client *client, int page,\n\t\t\t\t\t int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct ltc2978_data *data = to_ltc2978_data(info);\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_READ_VIN_MAX:\n\t\tret = ltc_get_max(data, client, page, LTC2978_MFR_VIN_PEAK,\n\t\t\t\t  &data->vin_max);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_VOUT_MAX:\n\t\tret = ltc_read_word_data(client, page, 0xff,\n\t\t\t\t\t LTC2978_MFR_VOUT_PEAK);\n\t\tif (ret >= 0) {\n\t\t\t \n\t\t\tif (ret > data->vout_max[page])\n\t\t\t\tdata->vout_max[page] = ret;\n\t\t\tret = data->vout_max[page];\n\t\t}\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_TEMP_MAX:\n\t\tret = ltc_get_max(data, client, page,\n\t\t\t\t  LTC2978_MFR_TEMPERATURE_PEAK,\n\t\t\t\t  &data->temp_max[page]);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_VOUT_HISTORY:\n\tcase PMBUS_VIRT_RESET_VIN_HISTORY:\n\tcase PMBUS_VIRT_RESET_TEMP_HISTORY:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = ltc_wait_ready(client);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ltc2978_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t  int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct ltc2978_data *data = to_ltc2978_data(info);\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_READ_VIN_MIN:\n\t\tret = ltc_get_min(data, client, page, LTC2978_MFR_VIN_MIN,\n\t\t\t\t  &data->vin_min);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_VOUT_MIN:\n\t\tret = ltc_read_word_data(client, page, phase,\n\t\t\t\t\t LTC2978_MFR_VOUT_MIN);\n\t\tif (ret >= 0) {\n\t\t\t \n\t\t\tif (data->vout_max[page] && ret > data->vout_max[page])\n\t\t\t\tret = data->vout_max[page];\n\t\t\tif (ret < data->vout_min[page])\n\t\t\t\tdata->vout_min[page] = ret;\n\t\t\tret = data->vout_min[page];\n\t\t}\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_TEMP_MIN:\n\t\tret = ltc_get_min(data, client, page,\n\t\t\t\t  LTC2978_MFR_TEMPERATURE_MIN,\n\t\t\t\t  &data->temp_min[page]);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_IOUT_MAX:\n\tcase PMBUS_VIRT_RESET_IOUT_HISTORY:\n\tcase PMBUS_VIRT_READ_TEMP2_MAX:\n\tcase PMBUS_VIRT_RESET_TEMP2_HISTORY:\n\t\tret = -ENXIO;\n\t\tbreak;\n\tdefault:\n\t\tret = ltc2978_read_word_data_common(client, page, reg);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ltc2974_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t  int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct ltc2978_data *data = to_ltc2978_data(info);\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_READ_IOUT_MAX:\n\t\tret = ltc_get_max(data, client, page, LTC2974_MFR_IOUT_PEAK,\n\t\t\t\t  &data->iout_max[page]);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_IOUT_MIN:\n\t\tret = ltc_get_min(data, client, page, LTC2974_MFR_IOUT_MIN,\n\t\t\t\t  &data->iout_min[page]);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_IOUT_HISTORY:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = ltc2978_read_word_data(client, page, phase, reg);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ltc2975_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t  int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct ltc2978_data *data = to_ltc2978_data(info);\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_READ_IIN_MAX:\n\t\tret = ltc_get_max(data, client, page, LTC2975_MFR_IIN_PEAK,\n\t\t\t\t  &data->iin_max);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_IIN_MIN:\n\t\tret = ltc_get_min(data, client, page, LTC2975_MFR_IIN_MIN,\n\t\t\t\t  &data->iin_min);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_PIN_MAX:\n\t\tret = ltc_get_max(data, client, page, LTC2975_MFR_PIN_PEAK,\n\t\t\t\t  &data->pin_max);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_PIN_MIN:\n\t\tret = ltc_get_min(data, client, page, LTC2975_MFR_PIN_MIN,\n\t\t\t\t  &data->pin_min);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_IIN_HISTORY:\n\tcase PMBUS_VIRT_RESET_PIN_HISTORY:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = ltc2978_read_word_data(client, page, phase, reg);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ltc3880_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t  int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct ltc2978_data *data = to_ltc2978_data(info);\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_READ_IOUT_MAX:\n\t\tret = ltc_get_max(data, client, page, LTC3880_MFR_IOUT_PEAK,\n\t\t\t\t  &data->iout_max[page]);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_TEMP2_MAX:\n\t\tret = ltc_get_max(data, client, page,\n\t\t\t\t  LTC3880_MFR_TEMPERATURE2_PEAK,\n\t\t\t\t  &data->temp2_max);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_VIN_MIN:\n\tcase PMBUS_VIRT_READ_VOUT_MIN:\n\tcase PMBUS_VIRT_READ_TEMP_MIN:\n\t\tret = -ENXIO;\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_IOUT_HISTORY:\n\tcase PMBUS_VIRT_RESET_TEMP2_HISTORY:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = ltc2978_read_word_data_common(client, page, reg);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ltc3883_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t  int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct ltc2978_data *data = to_ltc2978_data(info);\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_READ_IIN_MAX:\n\t\tret = ltc_get_max(data, client, page, LTC3883_MFR_IIN_PEAK,\n\t\t\t\t  &data->iin_max);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_IIN_HISTORY:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = ltc3880_read_word_data(client, page, phase, reg);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ltc2978_clear_peaks(struct ltc2978_data *data,\n\t\t\t       struct i2c_client *client, int page)\n{\n\tint ret;\n\n\tif (has_clear_peaks(data))\n\t\tret = ltc_write_byte(client, 0, LTC3880_MFR_CLEAR_PEAKS);\n\telse\n\t\tret = ltc_write_byte(client, page, PMBUS_CLEAR_FAULTS);\n\n\treturn ret;\n}\n\nstatic int ltc2978_write_word_data(struct i2c_client *client, int page,\n\t\t\t\t    int reg, u16 word)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct ltc2978_data *data = to_ltc2978_data(info);\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_RESET_IIN_HISTORY:\n\t\tdata->iin_max = 0x7c00;\n\t\tdata->iin_min = 0x7bff;\n\t\tret = ltc2978_clear_peaks(data, client, 0);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_PIN_HISTORY:\n\t\tdata->pin_max = 0x7c00;\n\t\tdata->pin_min = 0x7bff;\n\t\tret = ltc2978_clear_peaks(data, client, 0);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_IOUT_HISTORY:\n\t\tdata->iout_max[page] = 0x7c00;\n\t\tdata->iout_min[page] = 0xfbff;\n\t\tret = ltc2978_clear_peaks(data, client, page);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_TEMP2_HISTORY:\n\t\tdata->temp2_max = 0x7c00;\n\t\tret = ltc2978_clear_peaks(data, client, page);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_VOUT_HISTORY:\n\t\tdata->vout_min[page] = 0xffff;\n\t\tdata->vout_max[page] = 0;\n\t\tret = ltc2978_clear_peaks(data, client, page);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_VIN_HISTORY:\n\t\tdata->vin_min = 0x7bff;\n\t\tdata->vin_max = 0x7c00;\n\t\tret = ltc2978_clear_peaks(data, client, page);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_TEMP_HISTORY:\n\t\tdata->temp_min[page] = 0x7bff;\n\t\tdata->temp_max[page] = 0x7c00;\n\t\tret = ltc2978_clear_peaks(data, client, page);\n\t\tbreak;\n\tdefault:\n\t\tret = ltc_wait_ready(client);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct i2c_device_id ltc2978_id[] = {\n\t{\"ltc2972\", ltc2972},\n\t{\"ltc2974\", ltc2974},\n\t{\"ltc2975\", ltc2975},\n\t{\"ltc2977\", ltc2977},\n\t{\"ltc2978\", ltc2978},\n\t{\"ltc2979\", ltc2979},\n\t{\"ltc2980\", ltc2980},\n\t{\"ltc3880\", ltc3880},\n\t{\"ltc3882\", ltc3882},\n\t{\"ltc3883\", ltc3883},\n\t{\"ltc3884\", ltc3884},\n\t{\"ltc3886\", ltc3886},\n\t{\"ltc3887\", ltc3887},\n\t{\"ltc3889\", ltc3889},\n\t{\"ltc7132\", ltc7132},\n\t{\"ltc7880\", ltc7880},\n\t{\"ltm2987\", ltm2987},\n\t{\"ltm4664\", ltm4664},\n\t{\"ltm4675\", ltm4675},\n\t{\"ltm4676\", ltm4676},\n\t{\"ltm4677\", ltm4677},\n\t{\"ltm4678\", ltm4678},\n\t{\"ltm4680\", ltm4680},\n\t{\"ltm4686\", ltm4686},\n\t{\"ltm4700\", ltm4700},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ltc2978_id);\n\n#if IS_ENABLED(CONFIG_SENSORS_LTC2978_REGULATOR)\n#define LTC2978_ADC_RES\t0xFFFF\n#define LTC2978_N_ADC\t122\n#define LTC2978_MAX_UV\t(LTC2978_ADC_RES * LTC2978_N_ADC)\n#define LTC2978_UV_STEP\t1000\n#define LTC2978_N_VOLTAGES\t((LTC2978_MAX_UV / LTC2978_UV_STEP) + 1)\n\nstatic const struct regulator_desc ltc2978_reg_desc[] = {\n\tPMBUS_REGULATOR_STEP(\"vout\", 0, LTC2978_N_VOLTAGES, LTC2978_UV_STEP, 0),\n\tPMBUS_REGULATOR_STEP(\"vout\", 1, LTC2978_N_VOLTAGES, LTC2978_UV_STEP, 0),\n\tPMBUS_REGULATOR_STEP(\"vout\", 2, LTC2978_N_VOLTAGES, LTC2978_UV_STEP, 0),\n\tPMBUS_REGULATOR_STEP(\"vout\", 3, LTC2978_N_VOLTAGES, LTC2978_UV_STEP, 0),\n\tPMBUS_REGULATOR_STEP(\"vout\", 4, LTC2978_N_VOLTAGES, LTC2978_UV_STEP, 0),\n\tPMBUS_REGULATOR_STEP(\"vout\", 5, LTC2978_N_VOLTAGES, LTC2978_UV_STEP, 0),\n\tPMBUS_REGULATOR_STEP(\"vout\", 6, LTC2978_N_VOLTAGES, LTC2978_UV_STEP, 0),\n\tPMBUS_REGULATOR_STEP(\"vout\", 7, LTC2978_N_VOLTAGES, LTC2978_UV_STEP, 0),\n};\n\nstatic const struct regulator_desc ltc2978_reg_desc_default[] = {\n\tPMBUS_REGULATOR(\"vout\", 0),\n\tPMBUS_REGULATOR(\"vout\", 1),\n\tPMBUS_REGULATOR(\"vout\", 2),\n\tPMBUS_REGULATOR(\"vout\", 3),\n\tPMBUS_REGULATOR(\"vout\", 4),\n\tPMBUS_REGULATOR(\"vout\", 5),\n\tPMBUS_REGULATOR(\"vout\", 6),\n\tPMBUS_REGULATOR(\"vout\", 7),\n};\n#endif  \n\nstatic int ltc2978_get_id(struct i2c_client *client)\n{\n\tint chip_id;\n\n\tchip_id = i2c_smbus_read_word_data(client, LTC2978_MFR_SPECIAL_ID);\n\tif (chip_id < 0) {\n\t\tconst struct i2c_device_id *id;\n\t\tu8 buf[I2C_SMBUS_BLOCK_MAX];\n\t\tint ret;\n\n\t\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t\t     I2C_FUNC_SMBUS_READ_BLOCK_DATA))\n\t\t\treturn -ENODEV;\n\n\t\tret = i2c_smbus_read_block_data(client, PMBUS_MFR_ID, buf);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret < 3 || strncmp(buf, \"LTC\", 3))\n\t\t\treturn -ENODEV;\n\n\t\tret = i2c_smbus_read_block_data(client, PMBUS_MFR_MODEL, buf);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tfor (id = &ltc2978_id[0]; strlen(id->name); id++) {\n\t\t\tif (!strncasecmp(id->name, buf, strlen(id->name)))\n\t\t\t\treturn (int)id->driver_data;\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\n\tchip_id &= LTC2978_ID_MASK;\n\n\tif (chip_id == LTC2972_ID)\n\t\treturn ltc2972;\n\telse if (chip_id == LTC2974_ID)\n\t\treturn ltc2974;\n\telse if (chip_id == LTC2975_ID)\n\t\treturn ltc2975;\n\telse if (chip_id == LTC2977_ID)\n\t\treturn ltc2977;\n\telse if (chip_id == LTC2978_ID_REV1 || chip_id == LTC2978_ID_REV2)\n\t\treturn ltc2978;\n\telse if (chip_id == LTC2979_ID_A || chip_id == LTC2979_ID_B)\n\t\treturn ltc2979;\n\telse if (chip_id == LTC2980_ID_A || chip_id == LTC2980_ID_B)\n\t\treturn ltc2980;\n\telse if (chip_id == LTC3880_ID)\n\t\treturn ltc3880;\n\telse if (chip_id == LTC3882_ID || chip_id == LTC3882_ID_D1)\n\t\treturn ltc3882;\n\telse if (chip_id == LTC3883_ID)\n\t\treturn ltc3883;\n\telse if (chip_id == LTC3884_ID)\n\t\treturn ltc3884;\n\telse if (chip_id == LTC3886_ID)\n\t\treturn ltc3886;\n\telse if (chip_id == LTC3887_ID)\n\t\treturn ltc3887;\n\telse if (chip_id == LTC3889_ID)\n\t\treturn ltc3889;\n\telse if (chip_id == LTC7132_ID)\n\t\treturn ltc7132;\n\telse if (chip_id == LTC7880_ID)\n\t\treturn ltc7880;\n\telse if (chip_id == LTM2987_ID_A || chip_id == LTM2987_ID_B)\n\t\treturn ltm2987;\n\telse if (chip_id == LTM4664_ID)\n\t\treturn ltm4664;\n\telse if (chip_id == LTM4675_ID)\n\t\treturn ltm4675;\n\telse if (chip_id == LTM4676_ID_REV1 || chip_id == LTM4676_ID_REV2 ||\n\t\t chip_id == LTM4676A_ID)\n\t\treturn ltm4676;\n\telse if (chip_id == LTM4677_ID_REV1 || chip_id == LTM4677_ID_REV2)\n\t\treturn ltm4677;\n\telse if (chip_id == LTM4678_ID_REV1 || chip_id == LTM4678_ID_REV2)\n\t\treturn ltm4678;\n\telse if (chip_id == LTM4680_ID)\n\t\treturn ltm4680;\n\telse if (chip_id == LTM4686_ID)\n\t\treturn ltm4686;\n\telse if (chip_id == LTM4700_ID)\n\t\treturn ltm4700;\n\n\tdev_err(&client->dev, \"Unsupported chip ID 0x%x\\n\", chip_id);\n\treturn -ENODEV;\n}\n\nstatic int ltc2978_probe(struct i2c_client *client)\n{\n\tint i, chip_id;\n\tstruct ltc2978_data *data;\n\tstruct pmbus_driver_info *info;\n\tconst struct i2c_device_id *id;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct ltc2978_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tchip_id = ltc2978_get_id(client);\n\tif (chip_id < 0)\n\t\treturn chip_id;\n\n\tdata->id = chip_id;\n\tid = i2c_match_id(ltc2978_id, client);\n\tif (data->id != id->driver_data)\n\t\tdev_warn(&client->dev,\n\t\t\t \"Device mismatch: Configured %s (%d), detected %d\\n\",\n\t\t\t id->name,\n\t\t\t (int) id->driver_data,\n\t\t\t chip_id);\n\n\tinfo = &data->info;\n\tinfo->write_word_data = ltc2978_write_word_data;\n\tinfo->write_byte = ltc_write_byte;\n\tinfo->write_byte_data = ltc_write_byte_data;\n\tinfo->read_word_data = ltc_read_word_data;\n\tinfo->read_byte_data = ltc_read_byte_data;\n\n\tdata->vin_min = 0x7bff;\n\tdata->vin_max = 0x7c00;\n\tfor (i = 0; i < ARRAY_SIZE(data->vout_min); i++)\n\t\tdata->vout_min[i] = 0xffff;\n\tfor (i = 0; i < ARRAY_SIZE(data->iout_min); i++)\n\t\tdata->iout_min[i] = 0xfbff;\n\tfor (i = 0; i < ARRAY_SIZE(data->iout_max); i++)\n\t\tdata->iout_max[i] = 0x7c00;\n\tfor (i = 0; i < ARRAY_SIZE(data->temp_min); i++)\n\t\tdata->temp_min[i] = 0x7bff;\n\tfor (i = 0; i < ARRAY_SIZE(data->temp_max); i++)\n\t\tdata->temp_max[i] = 0x7c00;\n\tdata->temp2_max = 0x7c00;\n\n\tswitch (data->id) {\n\tcase ltc2972:\n\t\tinfo->read_word_data = ltc2975_read_word_data;\n\t\tinfo->pages = LTC2972_NUM_PAGES;\n\t\tinfo->func[0] = PMBUS_HAVE_IIN | PMBUS_HAVE_PIN\n\t\t  | PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\n\t\t  | PMBUS_HAVE_TEMP2;\n\t\tfor (i = 0; i < info->pages; i++) {\n\t\t\tinfo->func[i] |= PMBUS_HAVE_VOUT\n\t\t\t  | PMBUS_HAVE_STATUS_VOUT | PMBUS_HAVE_POUT\n\t\t\t  | PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP\n\t\t\t  | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT;\n\t\t}\n\t\tbreak;\n\tcase ltc2974:\n\t\tinfo->read_word_data = ltc2974_read_word_data;\n\t\tinfo->pages = LTC2974_NUM_PAGES;\n\t\tinfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\n\t\t  | PMBUS_HAVE_TEMP2;\n\t\tfor (i = 0; i < info->pages; i++) {\n\t\t\tinfo->func[i] |= PMBUS_HAVE_VOUT\n\t\t\t  | PMBUS_HAVE_STATUS_VOUT | PMBUS_HAVE_POUT\n\t\t\t  | PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP\n\t\t\t  | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT;\n\t\t}\n\t\tbreak;\n\tcase ltc2975:\n\t\tinfo->read_word_data = ltc2975_read_word_data;\n\t\tinfo->pages = LTC2974_NUM_PAGES;\n\t\tinfo->func[0] = PMBUS_HAVE_IIN | PMBUS_HAVE_PIN\n\t\t  | PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\n\t\t  | PMBUS_HAVE_TEMP2;\n\t\tfor (i = 0; i < info->pages; i++) {\n\t\t\tinfo->func[i] |= PMBUS_HAVE_VOUT\n\t\t\t  | PMBUS_HAVE_STATUS_VOUT | PMBUS_HAVE_POUT\n\t\t\t  | PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP\n\t\t\t  | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT;\n\t\t}\n\t\tbreak;\n\n\tcase ltc2977:\n\tcase ltc2978:\n\tcase ltc2979:\n\tcase ltc2980:\n\tcase ltm2987:\n\t\tinfo->read_word_data = ltc2978_read_word_data;\n\t\tinfo->pages = LTC2978_NUM_PAGES;\n\t\tinfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\n\t\t  | PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\n\t\t  | PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\n\t\tfor (i = 1; i < LTC2978_NUM_PAGES; i++) {\n\t\t\tinfo->func[i] = PMBUS_HAVE_VOUT\n\t\t\t  | PMBUS_HAVE_STATUS_VOUT;\n\t\t}\n\t\tbreak;\n\tcase ltc3880:\n\tcase ltc3887:\n\tcase ltm4675:\n\tcase ltm4676:\n\tcase ltm4677:\n\tcase ltm4686:\n\t\tdata->features |= FEAT_CLEAR_PEAKS | FEAT_NEEDS_POLLING;\n\t\tinfo->read_word_data = ltc3880_read_word_data;\n\t\tinfo->pages = LTC3880_NUM_PAGES;\n\t\tinfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_IIN\n\t\t  | PMBUS_HAVE_STATUS_INPUT\n\t\t  | PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\n\t\t  | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\n\t\t  | PMBUS_HAVE_POUT | PMBUS_HAVE_TEMP\n\t\t  | PMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\n\t\tinfo->func[1] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\n\t\t  | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\n\t\t  | PMBUS_HAVE_POUT\n\t\t  | PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\n\t\tbreak;\n\tcase ltc3882:\n\t\tdata->features |= FEAT_CLEAR_PEAKS | FEAT_NEEDS_POLLING;\n\t\tinfo->read_word_data = ltc3880_read_word_data;\n\t\tinfo->pages = LTC3880_NUM_PAGES;\n\t\tinfo->func[0] = PMBUS_HAVE_VIN\n\t\t  | PMBUS_HAVE_STATUS_INPUT\n\t\t  | PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\n\t\t  | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\n\t\t  | PMBUS_HAVE_POUT | PMBUS_HAVE_TEMP\n\t\t  | PMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\n\t\tinfo->func[1] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\n\t\t  | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\n\t\t  | PMBUS_HAVE_POUT\n\t\t  | PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\n\t\tbreak;\n\tcase ltc3883:\n\t\tdata->features |= FEAT_CLEAR_PEAKS | FEAT_NEEDS_POLLING;\n\t\tinfo->read_word_data = ltc3883_read_word_data;\n\t\tinfo->pages = LTC3883_NUM_PAGES;\n\t\tinfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_IIN\n\t\t  | PMBUS_HAVE_STATUS_INPUT\n\t\t  | PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\n\t\t  | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\n\t\t  | PMBUS_HAVE_PIN | PMBUS_HAVE_POUT | PMBUS_HAVE_TEMP\n\t\t  | PMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\n\t\tbreak;\n\tcase ltc3884:\n\tcase ltc3886:\n\tcase ltc3889:\n\tcase ltc7132:\n\tcase ltc7880:\n\tcase ltm4664:\n\tcase ltm4678:\n\tcase ltm4680:\n\tcase ltm4700:\n\t\tdata->features |= FEAT_CLEAR_PEAKS | FEAT_NEEDS_POLLING;\n\t\tinfo->read_word_data = ltc3883_read_word_data;\n\t\tinfo->pages = LTC3880_NUM_PAGES;\n\t\tinfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_IIN\n\t\t  | PMBUS_HAVE_STATUS_INPUT\n\t\t  | PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\n\t\t  | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\n\t\t  | PMBUS_HAVE_PIN | PMBUS_HAVE_POUT | PMBUS_HAVE_TEMP\n\t\t  | PMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\n\t\tinfo->func[1] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\n\t\t  | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\n\t\t  | PMBUS_HAVE_POUT\n\t\t  | PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n#if IS_ENABLED(CONFIG_SENSORS_LTC2978_REGULATOR)\n\tinfo->num_regulators = info->pages;\n\tswitch (data->id) {\n\tcase ltc2972:\n\tcase ltc2974:\n\tcase ltc2975:\n\tcase ltc2977:\n\tcase ltc2978:\n\tcase ltc2979:\n\tcase ltc2980:\n\tcase ltm2987:\n\t\tinfo->reg_desc = ltc2978_reg_desc;\n\t\tif (info->num_regulators > ARRAY_SIZE(ltc2978_reg_desc)) {\n\t\t\tdev_warn(&client->dev, \"num_regulators too large!\");\n\t\t\tinfo->num_regulators = ARRAY_SIZE(ltc2978_reg_desc);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tinfo->reg_desc = ltc2978_reg_desc_default;\n\t\tif (info->num_regulators > ARRAY_SIZE(ltc2978_reg_desc_default)) {\n\t\t\tdev_warn(&client->dev, \"num_regulators too large!\");\n\t\t\tinfo->num_regulators =\n\t\t\t    ARRAY_SIZE(ltc2978_reg_desc_default);\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\n\treturn pmbus_do_probe(client, info);\n}\n\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ltc2978_of_match[] = {\n\t{ .compatible = \"lltc,ltc2972\" },\n\t{ .compatible = \"lltc,ltc2974\" },\n\t{ .compatible = \"lltc,ltc2975\" },\n\t{ .compatible = \"lltc,ltc2977\" },\n\t{ .compatible = \"lltc,ltc2978\" },\n\t{ .compatible = \"lltc,ltc2979\" },\n\t{ .compatible = \"lltc,ltc2980\" },\n\t{ .compatible = \"lltc,ltc3880\" },\n\t{ .compatible = \"lltc,ltc3882\" },\n\t{ .compatible = \"lltc,ltc3883\" },\n\t{ .compatible = \"lltc,ltc3884\" },\n\t{ .compatible = \"lltc,ltc3886\" },\n\t{ .compatible = \"lltc,ltc3887\" },\n\t{ .compatible = \"lltc,ltc3889\" },\n\t{ .compatible = \"lltc,ltc7132\" },\n\t{ .compatible = \"lltc,ltc7880\" },\n\t{ .compatible = \"lltc,ltm2987\" },\n\t{ .compatible = \"lltc,ltm4664\" },\n\t{ .compatible = \"lltc,ltm4675\" },\n\t{ .compatible = \"lltc,ltm4676\" },\n\t{ .compatible = \"lltc,ltm4677\" },\n\t{ .compatible = \"lltc,ltm4678\" },\n\t{ .compatible = \"lltc,ltm4680\" },\n\t{ .compatible = \"lltc,ltm4686\" },\n\t{ .compatible = \"lltc,ltm4700\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ltc2978_of_match);\n#endif\n\nstatic struct i2c_driver ltc2978_driver = {\n\t.driver = {\n\t\t   .name = \"ltc2978\",\n\t\t   .of_match_table = of_match_ptr(ltc2978_of_match),\n\t\t   },\n\t.probe = ltc2978_probe,\n\t.id_table = ltc2978_id,\n};\n\nmodule_i2c_driver(ltc2978_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck\");\nMODULE_DESCRIPTION(\"PMBus driver for LTC2978 and compatible chips\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}