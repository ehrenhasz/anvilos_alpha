{
  "module_name": "mp2975.c",
  "hash_id": "8ce4a0459cd72585ad9a079b8326fa8721deb6243cd7dc2971e1c05031ac6622",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/mp2975.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include \"pmbus.h\"\n\n \n#define MP2975_MFR_APS_HYS_R2\t\t0x0d\n#define MP2975_MFR_SLOPE_TRIM3\t\t0x1d\n#define MP2975_MFR_VR_MULTI_CONFIG_R1\t0x0d\n#define MP2975_MFR_VR_MULTI_CONFIG_R2\t0x1d\n#define MP2975_MFR_APS_DECAY_ADV\t0x56\n#define MP2975_MFR_DC_LOOP_CTRL\t\t0x59\n#define MP2975_MFR_OCP_UCP_PHASE_SET\t0x65\n#define MP2975_MFR_VR_CONFIG1\t\t0x68\n#define MP2975_MFR_READ_CS1_2\t\t0x82\n#define MP2975_MFR_READ_CS3_4\t\t0x83\n#define MP2975_MFR_READ_CS5_6\t\t0x84\n#define MP2975_MFR_READ_CS7_8\t\t0x85\n#define MP2975_MFR_READ_CS9_10\t\t0x86\n#define MP2975_MFR_READ_CS11_12\t\t0x87\n#define MP2975_MFR_READ_IOUT_PK\t\t0x90\n#define MP2975_MFR_READ_POUT_PK\t\t0x91\n#define MP2975_MFR_READ_VREF_R1\t\t0xa1\n#define MP2975_MFR_READ_VREF_R2\t\t0xa3\n#define MP2975_MFR_OVP_TH_SET\t\t0xe5\n#define MP2975_MFR_UVP_SET\t\t0xe6\n\n#define MP2973_MFR_RESO_SET\t\t0xc7\n\n#define MP2975_VOUT_FORMAT\t\tBIT(15)\n#define MP2975_VID_STEP_SEL_R1\t\tBIT(4)\n#define MP2975_IMVP9_EN_R1\t\tBIT(13)\n#define MP2975_VID_STEP_SEL_R2\t\tBIT(3)\n#define MP2975_IMVP9_EN_R2\t\tBIT(12)\n#define MP2975_PRT_THRES_DIV_OV_EN\tBIT(14)\n#define MP2975_DRMOS_KCS\t\tGENMASK(13, 12)\n#define MP2975_PROT_DEV_OV_OFF\t\t10\n#define MP2975_PROT_DEV_OV_ON\t\t5\n#define MP2975_SENSE_AMPL\t\tBIT(11)\n#define MP2975_SENSE_AMPL_UNIT\t\t1\n#define MP2975_SENSE_AMPL_HALF\t\t2\n#define MP2975_VIN_UV_LIMIT_UNIT\t8\n\n#define MP2973_VOUT_FORMAT_R1\t\tGENMASK(7, 6)\n#define MP2973_VOUT_FORMAT_R2\t\tGENMASK(4, 3)\n#define MP2973_VOUT_FORMAT_DIRECT_R1\tBIT(7)\n#define MP2973_VOUT_FORMAT_LINEAR_R1\tBIT(6)\n#define MP2973_VOUT_FORMAT_DIRECT_R2\tBIT(4)\n#define MP2973_VOUT_FORMAT_LINEAR_R2\tBIT(3)\n\n#define MP2973_MFR_VR_MULTI_CONFIG_R1\t0x0d\n#define MP2973_MFR_VR_MULTI_CONFIG_R2\t0x1d\n#define MP2973_VID_STEP_SEL_R1\t\tBIT(4)\n#define MP2973_IMVP9_EN_R1\t\tBIT(14)\n#define MP2973_VID_STEP_SEL_R2\t\tBIT(3)\n#define MP2973_IMVP9_EN_R2\t\tBIT(13)\n\n#define MP2973_MFR_OCP_TOTAL_SET\t0x5f\n#define MP2973_OCP_TOTAL_CUR_MASK\tGENMASK(6, 0)\n#define MP2973_MFR_OCP_LEVEL_RES\tBIT(15)\n\n#define MP2973_MFR_READ_IOUT_PK\t\t0x90\n#define MP2973_MFR_READ_POUT_PK\t\t0x91\n\n#define MP2975_MAX_PHASE_RAIL1\t8\n#define MP2975_MAX_PHASE_RAIL2\t4\n\n#define MP2973_MAX_PHASE_RAIL1\t14\n#define MP2973_MAX_PHASE_RAIL2\t6\n\n#define MP2971_MAX_PHASE_RAIL1\t8\n#define MP2971_MAX_PHASE_RAIL2\t3\n\n#define MP2975_PAGE_NUM\t\t2\n\n#define MP2975_RAIL2_FUNC\t(PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT | \\\n\t\t\t\t PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT | \\\n\t\t\t\t PMBUS_HAVE_POUT | PMBUS_PHASE_VIRTUAL)\n\nenum chips {\n\tmp2971, mp2973, mp2975\n};\n\nstatic const int mp2975_max_phases[][MP2975_PAGE_NUM] = {\n\t[mp2975] = { MP2975_MAX_PHASE_RAIL1, MP2975_MAX_PHASE_RAIL2 },\n\t[mp2973] = { MP2973_MAX_PHASE_RAIL1, MP2973_MAX_PHASE_RAIL2 },\n\t[mp2971] = { MP2971_MAX_PHASE_RAIL1, MP2971_MAX_PHASE_RAIL2 },\n};\n\nstruct mp2975_data {\n\tstruct pmbus_driver_info info;\n\tenum chips chip_id;\n\tint vout_scale;\n\tint max_phases[MP2975_PAGE_NUM];\n\tint vid_step[MP2975_PAGE_NUM];\n\tint vref[MP2975_PAGE_NUM];\n\tint vref_off[MP2975_PAGE_NUM];\n\tint vout_max[MP2975_PAGE_NUM];\n\tint vout_ov_fixed[MP2975_PAGE_NUM];\n\tint curr_sense_gain[MP2975_PAGE_NUM];\n};\n\nstatic const struct i2c_device_id mp2975_id[] = {\n\t{\"mp2971\", mp2971},\n\t{\"mp2973\", mp2973},\n\t{\"mp2975\", mp2975},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, mp2975_id);\n\nstatic const struct regulator_desc __maybe_unused mp2975_reg_desc[] = {\n\tPMBUS_REGULATOR(\"vout\", 0),\n\tPMBUS_REGULATOR(\"vout\", 1),\n};\n\n#define to_mp2975_data(x)  container_of(x, struct mp2975_data, info)\n\nstatic int\nmp2975_read_word_helper(struct i2c_client *client, int page, int phase, u8 reg,\n\t\t\tu16 mask)\n{\n\tint ret = pmbus_read_word_data(client, page, phase, reg);\n\n\treturn (ret > 0) ? ret & mask : ret;\n}\n\nstatic int\nmp2975_vid2direct(int vrf, int val)\n{\n\tswitch (vrf) {\n\tcase vr12:\n\t\tif (val >= 0x01)\n\t\t\treturn 250 + (val - 1) * 5;\n\t\tbreak;\n\tcase vr13:\n\t\tif (val >= 0x01)\n\t\t\treturn 500 + (val - 1) * 10;\n\t\tbreak;\n\tcase imvp9:\n\t\tif (val >= 0x01)\n\t\t\treturn 200 + (val - 1) * 10;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#define MAX_LIN_MANTISSA\t(1023 * 1000)\n#define MIN_LIN_MANTISSA\t(511 * 1000)\n\n \nstatic u16 mp2975_data2reg_linear11(s64 val)\n{\n\ts16 exponent = 0, mantissa;\n\tbool negative = false;\n\n\t \n\tif (val == 0)\n\t\treturn 0;\n\n\t \n\twhile (val >= MAX_LIN_MANTISSA && exponent < 15) {\n\t\texponent++;\n\t\tval >>= 1;\n\t}\n\t \n\twhile (val < MIN_LIN_MANTISSA && exponent > -15) {\n\t\texponent--;\n\t\tval <<= 1;\n\t}\n\n\t \n\tmantissa = clamp_val(DIV_ROUND_CLOSEST_ULL(val, 1000), 0, 0x3ff);\n\n\t \n\tif (negative)\n\t\tmantissa = -mantissa;\n\n\t \n\treturn (mantissa & 0x7ff) | ((exponent << 11) & 0xf800);\n}\n\nstatic int\nmp2975_read_phase(struct i2c_client *client, struct mp2975_data *data,\n\t\t  int page, int phase, u8 reg)\n{\n\tint ph_curr, ret;\n\n\tret = pmbus_read_word_data(client, page, phase, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!((phase + 1) % MP2975_PAGE_NUM))\n\t\tret >>= 8;\n\tret &= 0xff;\n\n\t \n\tph_curr = ret * 100 - 9800;\n\n\t \n\tret = pmbus_read_word_data(client, page, phase, PMBUS_READ_IOUT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn max_t(int, DIV_ROUND_CLOSEST(ret, data->info.phases[page]),\n\t\t     DIV_ROUND_CLOSEST(ph_curr, data->curr_sense_gain[page]));\n}\n\nstatic int\nmp2975_read_phases(struct i2c_client *client, struct mp2975_data *data,\n\t\t   int page, int phase)\n{\n\tint ret;\n\n\tif (page) {\n\t\tswitch (phase) {\n\t\tcase 0 ... 1:\n\t\t\tret = mp2975_read_phase(client, data, page, phase,\n\t\t\t\t\t\tMP2975_MFR_READ_CS7_8);\n\t\t\tbreak;\n\t\tcase 2 ... 3:\n\t\t\tret = mp2975_read_phase(client, data, page, phase,\n\t\t\t\t\t\tMP2975_MFR_READ_CS9_10);\n\t\t\tbreak;\n\t\tcase 4 ... 5:\n\t\t\tret = mp2975_read_phase(client, data, page, phase,\n\t\t\t\t\t\tMP2975_MFR_READ_CS11_12);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODATA;\n\t\t}\n\t} else {\n\t\tswitch (phase) {\n\t\tcase 0 ... 1:\n\t\t\tret = mp2975_read_phase(client, data, page, phase,\n\t\t\t\t\t\tMP2975_MFR_READ_CS1_2);\n\t\t\tbreak;\n\t\tcase 2 ... 3:\n\t\t\tret = mp2975_read_phase(client, data, page, phase,\n\t\t\t\t\t\tMP2975_MFR_READ_CS3_4);\n\t\t\tbreak;\n\t\tcase 4 ... 5:\n\t\t\tret = mp2975_read_phase(client, data, page, phase,\n\t\t\t\t\t\tMP2975_MFR_READ_CS5_6);\n\t\t\tbreak;\n\t\tcase 6 ... 7:\n\t\t\tret = mp2975_read_phase(client, data, page, phase,\n\t\t\t\t\t\tMP2975_MFR_READ_CS7_8);\n\t\t\tbreak;\n\t\tcase 8 ... 9:\n\t\t\tret = mp2975_read_phase(client, data, page, phase,\n\t\t\t\t\t\tMP2975_MFR_READ_CS9_10);\n\t\t\tbreak;\n\t\tcase 10 ... 11:\n\t\t\tret = mp2975_read_phase(client, data, page, phase,\n\t\t\t\t\t\tMP2975_MFR_READ_CS11_12);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int mp2973_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct mp2975_data *data = to_mp2975_data(info);\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_STATUS_WORD:\n\t\t \n\t\tret = pmbus_read_word_data(client, page, phase, reg);\n\t\tret ^= PB_STATUS_POWER_GOOD_N;\n\t\tbreak;\n\tcase PMBUS_OT_FAULT_LIMIT:\n\t\tret = mp2975_read_word_helper(client, page, phase, reg,\n\t\t\t\t\t      GENMASK(7, 0));\n\t\tbreak;\n\tcase PMBUS_VIN_OV_FAULT_LIMIT:\n\t\tret = mp2975_read_word_helper(client, page, phase, reg,\n\t\t\t\t\t      GENMASK(7, 0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = DIV_ROUND_CLOSEST(ret, MP2975_VIN_UV_LIMIT_UNIT);\n\t\tbreak;\n\tcase PMBUS_VOUT_OV_FAULT_LIMIT:\n\t\t \n\t\tret = mp2975_read_word_helper(client, page, phase,\n\t\t\t\t\t      MP2975_MFR_OVP_TH_SET,\n\t\t\t\t\t      GENMASK(2, 0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = data->vout_max[page] + 50 * (ret + 1);\n\t\tbreak;\n\tcase PMBUS_VOUT_UV_FAULT_LIMIT:\n\t\tret = mp2975_read_word_helper(client, page, phase, reg,\n\t\t\t\t\t      GENMASK(8, 0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = mp2975_vid2direct(info->vrm_version[page], ret);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_POUT_MAX:\n\t\tret = pmbus_read_word_data(client, page, phase,\n\t\t\t\t\t   MP2973_MFR_READ_POUT_PK);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_IOUT_MAX:\n\t\tret = pmbus_read_word_data(client, page, phase,\n\t\t\t\t\t   MP2973_MFR_READ_IOUT_PK);\n\t\tbreak;\n\tcase PMBUS_IOUT_OC_FAULT_LIMIT:\n\t\tret = mp2975_read_word_helper(client, page, phase,\n\t\t\t\t\t      MP2973_MFR_OCP_TOTAL_SET,\n\t\t\t\t\t      GENMASK(15, 0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret & MP2973_MFR_OCP_LEVEL_RES)\n\t\t\tret = 2 * (ret & MP2973_OCP_TOTAL_CUR_MASK);\n\t\telse\n\t\t\tret = ret & MP2973_OCP_TOTAL_CUR_MASK;\n\n\t\tret = mp2975_data2reg_linear11(ret * info->phases[page] * 1000);\n\t\tbreak;\n\tcase PMBUS_UT_WARN_LIMIT:\n\tcase PMBUS_UT_FAULT_LIMIT:\n\tcase PMBUS_VIN_UV_WARN_LIMIT:\n\tcase PMBUS_VIN_UV_FAULT_LIMIT:\n\tcase PMBUS_VOUT_UV_WARN_LIMIT:\n\tcase PMBUS_VOUT_OV_WARN_LIMIT:\n\tcase PMBUS_VIN_OV_WARN_LIMIT:\n\tcase PMBUS_IIN_OC_FAULT_LIMIT:\n\tcase PMBUS_IOUT_OC_LV_FAULT_LIMIT:\n\tcase PMBUS_IOUT_OC_WARN_LIMIT:\n\tcase PMBUS_IOUT_UC_FAULT_LIMIT:\n\tcase PMBUS_POUT_OP_FAULT_LIMIT:\n\tcase PMBUS_POUT_OP_WARN_LIMIT:\n\tcase PMBUS_PIN_OP_WARN_LIMIT:\n\t\treturn -ENXIO;\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n\n\treturn ret;\n}\n\nstatic int mp2975_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct mp2975_data *data = to_mp2975_data(info);\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_OT_FAULT_LIMIT:\n\t\tret = mp2975_read_word_helper(client, page, phase, reg,\n\t\t\t\t\t      GENMASK(7, 0));\n\t\tbreak;\n\tcase PMBUS_VIN_OV_FAULT_LIMIT:\n\t\tret = mp2975_read_word_helper(client, page, phase, reg,\n\t\t\t\t\t      GENMASK(7, 0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = DIV_ROUND_CLOSEST(ret, MP2975_VIN_UV_LIMIT_UNIT);\n\t\tbreak;\n\tcase PMBUS_VOUT_OV_FAULT_LIMIT:\n\t\t \n\t\tret = mp2975_read_word_helper(client, page, phase,\n\t\t\t\t\t      MP2975_MFR_OVP_TH_SET,\n\t\t\t\t\t      GENMASK(2, 0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = min_t(int, data->vout_max[page] + 50 * (ret + 1),\n\t\t\t    data->vout_ov_fixed[page]);\n\t\tbreak;\n\tcase PMBUS_VOUT_UV_FAULT_LIMIT:\n\t\tret = mp2975_read_word_helper(client, page, phase,\n\t\t\t\t\t      MP2975_MFR_UVP_SET,\n\t\t\t\t\t      GENMASK(2, 0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = DIV_ROUND_CLOSEST(data->vref[page] * 10 - 50 *\n\t\t\t\t\t(ret + 1) * data->vout_scale, 10);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_POUT_MAX:\n\t\tret = mp2975_read_word_helper(client, page, phase,\n\t\t\t\t\t      MP2975_MFR_READ_POUT_PK,\n\t\t\t\t\t      GENMASK(12, 0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = DIV_ROUND_CLOSEST(ret, 4);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_IOUT_MAX:\n\t\tret = mp2975_read_word_helper(client, page, phase,\n\t\t\t\t\t      MP2975_MFR_READ_IOUT_PK,\n\t\t\t\t\t      GENMASK(12, 0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = DIV_ROUND_CLOSEST(ret, 4);\n\t\tbreak;\n\tcase PMBUS_READ_IOUT:\n\t\tret = mp2975_read_phases(client, data, page, phase);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tcase PMBUS_UT_WARN_LIMIT:\n\tcase PMBUS_UT_FAULT_LIMIT:\n\tcase PMBUS_VIN_UV_WARN_LIMIT:\n\tcase PMBUS_VIN_UV_FAULT_LIMIT:\n\tcase PMBUS_VOUT_UV_WARN_LIMIT:\n\tcase PMBUS_VOUT_OV_WARN_LIMIT:\n\tcase PMBUS_VIN_OV_WARN_LIMIT:\n\tcase PMBUS_IIN_OC_FAULT_LIMIT:\n\tcase PMBUS_IOUT_OC_LV_FAULT_LIMIT:\n\tcase PMBUS_IIN_OC_WARN_LIMIT:\n\tcase PMBUS_IOUT_OC_WARN_LIMIT:\n\tcase PMBUS_IOUT_OC_FAULT_LIMIT:\n\tcase PMBUS_IOUT_UC_FAULT_LIMIT:\n\tcase PMBUS_POUT_OP_FAULT_LIMIT:\n\tcase PMBUS_POUT_OP_WARN_LIMIT:\n\tcase PMBUS_PIN_OP_WARN_LIMIT:\n\t\treturn -ENXIO;\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n\n\treturn ret;\n}\n\nstatic int mp2975_identify_multiphase_rail2(struct i2c_client *client,\n\t\t\t\t\t    struct mp2975_data *data)\n{\n\tint ret;\n\n\t \n\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_word_data(client, MP2975_MFR_VR_MULTI_CONFIG_R2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= GENMASK(2, 0);\n\treturn (ret >= data->max_phases[1]) ? data->max_phases[1] : ret;\n}\n\nstatic void mp2975_set_phase_rail1(struct pmbus_driver_info *info)\n{\n\tint i;\n\n\tfor (i = 0 ; i < info->phases[0]; i++)\n\t\tinfo->pfunc[i] = PMBUS_HAVE_IOUT;\n}\n\nstatic void\nmp2975_set_phase_rail2(struct pmbus_driver_info *info, int num_phases)\n{\n\tint i;\n\n\t \n\tfor (i = 1; i <= num_phases; i++)\n\t\tinfo->pfunc[MP2975_MAX_PHASE_RAIL1 - i] = PMBUS_HAVE_IOUT;\n}\n\nstatic int\nmp2975_identify_multiphase(struct i2c_client *client, struct mp2975_data *data,\n\t\t\t   struct pmbus_driver_info *info)\n{\n\tint num_phases2, ret;\n\n\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = i2c_smbus_read_word_data(client, MP2975_MFR_VR_MULTI_CONFIG_R1);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tinfo->phases[0] = ret & GENMASK(3, 0);\n\n\t \n\tif (info->phases[0] > data->max_phases[0])\n\t\treturn -EINVAL;\n\n\tif (data->chip_id == mp2975) {\n\t\tmp2975_set_phase_rail1(info);\n\t\tnum_phases2 = min(data->max_phases[0] - info->phases[0],\n\t\t\t\t  data->max_phases[1]);\n\t\tif (info->phases[1] && info->phases[1] <= num_phases2)\n\t\t\tmp2975_set_phase_rail2(info, num_phases2);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmp2975_identify_vid(struct i2c_client *client, struct mp2975_data *data,\n\t\t    struct pmbus_driver_info *info, u32 reg, int page,\n\t\t    u32 imvp_bit, u32 vr_bit)\n{\n\tint ret;\n\n\t \n\tret = i2c_smbus_read_word_data(client, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & imvp_bit) {\n\t\tinfo->vrm_version[page] = imvp9;\n\t\tdata->vid_step[page] = MP2975_PROT_DEV_OV_OFF;\n\t} else if (ret & vr_bit) {\n\t\tinfo->vrm_version[page] = vr12;\n\t\tdata->vid_step[page] = MP2975_PROT_DEV_OV_ON;\n\t} else {\n\t\tinfo->vrm_version[page] = vr13;\n\t\tdata->vid_step[page] = MP2975_PROT_DEV_OV_OFF;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmp2975_identify_rails_vid(struct i2c_client *client, struct mp2975_data *data,\n\t\t\t  struct pmbus_driver_info *info)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = mp2975_identify_vid(client, data, info,\n\t\t\t\t  MP2975_MFR_VR_MULTI_CONFIG_R1, 0,\n\t\t\t\t  MP2975_IMVP9_EN_R1, MP2975_VID_STEP_SEL_R1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (info->phases[1])\n\t\tret = mp2975_identify_vid(client, data, info,\n\t\t\t\t\t  MP2975_MFR_VR_MULTI_CONFIG_R2, 1,\n\t\t\t\t\t  MP2975_IMVP9_EN_R2,\n\t\t\t\t\t  MP2975_VID_STEP_SEL_R2);\n\n\treturn ret;\n}\n\nstatic int\nmp2973_identify_rails_vid(struct i2c_client *client, struct mp2975_data *data,\n\t\t\t  struct pmbus_driver_info *info)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = mp2975_identify_vid(client, data, info,\n\t\t\t\t  MP2973_MFR_VR_MULTI_CONFIG_R1, 0,\n\t\t\t\t  MP2973_IMVP9_EN_R1, MP2973_VID_STEP_SEL_R1);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (info->phases[1])\n\t\tret = mp2975_identify_vid(client, data, info,\n\t\t\t\t\t  MP2973_MFR_VR_MULTI_CONFIG_R2, 1,\n\t\t\t\t\t  MP2973_IMVP9_EN_R2,\n\t\t\t\t\t  MP2973_VID_STEP_SEL_R2);\n\n\treturn ret;\n}\n\nstatic int\nmp2975_current_sense_gain_get(struct i2c_client *client,\n\t\t\t      struct mp2975_data *data)\n{\n\tint i, ret;\n\n\t \n\tfor (i = 0 ; i < data->info.pages; i++) {\n\t\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = i2c_smbus_read_word_data(client,\n\t\t\t\t\t       MP2975_MFR_VR_CONFIG1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tswitch ((ret & MP2975_DRMOS_KCS) >> 12) {\n\t\tcase 0:\n\t\t\tdata->curr_sense_gain[i] = 50;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdata->curr_sense_gain[i] = 85;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata->curr_sense_gain[i] = 97;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata->curr_sense_gain[i] = 100;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmp2975_vref_get(struct i2c_client *client, struct mp2975_data *data,\n\t\tstruct pmbus_driver_info *info)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, 3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = i2c_smbus_read_word_data(client, MP2975_MFR_READ_VREF_R1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->vref[0] = ret * data->vid_step[0];\n\n\t \n\tif (data->info.pages == MP2975_PAGE_NUM) {\n\t\tret = i2c_smbus_read_word_data(client, MP2975_MFR_READ_VREF_R2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata->vref[1] = ret * data->vid_step[1];\n\t}\n\treturn 0;\n}\n\nstatic int\nmp2975_vref_offset_get(struct i2c_client *client, struct mp2975_data *data,\n\t\t       int page)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_word_data(client, MP2975_MFR_OVP_TH_SET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch ((ret & GENMASK(5, 3)) >> 3) {\n\tcase 1:\n\t\tdata->vref_off[page] = 140;\n\t\tbreak;\n\tcase 2:\n\t\tdata->vref_off[page] = 220;\n\t\tbreak;\n\tcase 4:\n\t\tdata->vref_off[page] = 400;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int\nmp2975_vout_max_get(struct i2c_client *client, struct mp2975_data *data,\n\t\t    struct pmbus_driver_info *info, int page)\n{\n\tint ret;\n\n\t \n\tret = i2c_smbus_read_word_data(client, PMBUS_VOUT_MAX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->vout_max[page] = mp2975_vid2direct(info->vrm_version[page], ret &\n\t\t\t\t\t\t GENMASK(8, 0));\n\treturn 0;\n}\n\nstatic int\nmp2975_set_vout_format(struct i2c_client *client,\n\t\t       struct mp2975_data *data, int page)\n{\n\tint ret, i;\n\n\t \n\tif (data->chip_id == mp2975) {\n\t\tret = i2c_smbus_read_word_data(client, MP2975_MFR_DC_LOOP_CTRL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret & MP2975_VOUT_FORMAT) {\n\t\t\tret &= ~MP2975_VOUT_FORMAT;\n\t\t\tret = i2c_smbus_write_word_data(client, MP2975_MFR_DC_LOOP_CTRL, ret);\n\t\t}\n\t} else {\n\t\tret = i2c_smbus_read_word_data(client, MP2973_MFR_RESO_SET);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti = ret;\n\n\t\tif (page == 0) {\n\t\t\ti &= ~MP2973_VOUT_FORMAT_R1;\n\t\t\ti |= MP2973_VOUT_FORMAT_DIRECT_R1;\n\t\t} else {\n\t\t\ti &= ~MP2973_VOUT_FORMAT_R2;\n\t\t\ti |= MP2973_VOUT_FORMAT_DIRECT_R2;\n\t\t}\n\t\tif (i != ret)\n\t\t\tret = i2c_smbus_write_word_data(client, MP2973_MFR_RESO_SET, i);\n\t}\n\treturn ret;\n}\n\nstatic int\nmp2975_vout_ov_scale_get(struct i2c_client *client, struct mp2975_data *data,\n\t\t\t struct pmbus_driver_info *info)\n{\n\tint thres_dev, sense_ampl, ret;\n\n\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = i2c_smbus_read_word_data(client, MP2975_MFR_APS_DECAY_ADV);\n\tif (ret < 0)\n\t\treturn ret;\n\tthres_dev = ret & MP2975_PRT_THRES_DIV_OV_EN ? MP2975_PROT_DEV_OV_ON :\n\t\t\t\t\t\t       MP2975_PROT_DEV_OV_OFF;\n\n\t \n\tret = i2c_smbus_read_word_data(client, PMBUS_VOUT_SCALE_LOOP);\n\tif (ret < 0)\n\t\treturn ret;\n\tsense_ampl = ret & MP2975_SENSE_AMPL ? MP2975_SENSE_AMPL_HALF :\n\t\t\t\t\t       MP2975_SENSE_AMPL_UNIT;\n\n\tdata->vout_scale = sense_ampl * thres_dev;\n\n\treturn 0;\n}\n\nstatic int\nmp2975_vout_per_rail_config_get(struct i2c_client *client,\n\t\t\t\tstruct mp2975_data *data,\n\t\t\t\tstruct pmbus_driver_info *info)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < data->info.pages; i++) {\n\t\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, i);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = mp2975_set_vout_format(client, data, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = mp2975_vout_max_get(client, data, info, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (data->chip_id != mp2975)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = mp2975_vref_offset_get(client, data, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tdata->vout_ov_fixed[i] = data->vref[i] +\n\t\t\t\t\t DIV_ROUND_CLOSEST(data->vref_off[i] *\n\t\t\t\t\t\t\t   data->vout_scale,\n\t\t\t\t\t\t\t   10);\n\t}\n\n\treturn 0;\n}\n\nstatic struct pmbus_driver_info mp2975_info = {\n\t.pages = 1,\n\t.format[PSC_VOLTAGE_IN] = linear,\n\t.format[PSC_VOLTAGE_OUT] = direct,\n\t.format[PSC_TEMPERATURE] = direct,\n\t.format[PSC_CURRENT_IN] = linear,\n\t.format[PSC_CURRENT_OUT] = direct,\n\t.format[PSC_POWER] = direct,\n\t.m[PSC_TEMPERATURE] = 1,\n\t.m[PSC_VOLTAGE_OUT] = 1,\n\t.R[PSC_VOLTAGE_OUT] = 3,\n\t.m[PSC_CURRENT_OUT] = 1,\n\t.m[PSC_POWER] = 1,\n\t.func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT |\n\t\tPMBUS_HAVE_IIN | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT |\n\t\tPMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP | PMBUS_HAVE_POUT |\n\t\tPMBUS_HAVE_PIN | PMBUS_HAVE_STATUS_INPUT | PMBUS_PHASE_VIRTUAL,\n\t.read_word_data = mp2975_read_word_data,\n#if IS_ENABLED(CONFIG_SENSORS_MP2975_REGULATOR)\n\t.num_regulators = 1,\n\t.reg_desc = mp2975_reg_desc,\n#endif\n};\n\nstatic struct pmbus_driver_info mp2973_info = {\n\t.pages = 1,\n\t.format[PSC_VOLTAGE_IN] = linear,\n\t.format[PSC_VOLTAGE_OUT] = direct,\n\t.format[PSC_TEMPERATURE] = linear,\n\t.format[PSC_CURRENT_IN] = linear,\n\t.format[PSC_CURRENT_OUT] = linear,\n\t.format[PSC_POWER] = linear,\n\t.m[PSC_VOLTAGE_OUT] = 1,\n\t.R[PSC_VOLTAGE_OUT] = 3,\n\t.func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT |\n\t\tPMBUS_HAVE_IIN | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT |\n\t\tPMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP | PMBUS_HAVE_POUT |\n\t\tPMBUS_HAVE_PIN | PMBUS_HAVE_STATUS_INPUT,\n\t.read_word_data = mp2973_read_word_data,\n#if IS_ENABLED(CONFIG_SENSORS_MP2975_REGULATOR)\n\t.num_regulators = 1,\n\t.reg_desc = mp2975_reg_desc,\n#endif\n};\n\nstatic int mp2975_probe(struct i2c_client *client)\n{\n\tstruct pmbus_driver_info *info;\n\tstruct mp2975_data *data;\n\tint ret;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct mp2975_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (client->dev.of_node)\n\t\tdata->chip_id = (enum chips)(unsigned long)of_device_get_match_data(&client->dev);\n\telse\n\t\tdata->chip_id = i2c_match_id(mp2975_id, client)->driver_data;\n\n\tmemcpy(data->max_phases, mp2975_max_phases[data->chip_id],\n\t       sizeof(data->max_phases));\n\n\tif (data->chip_id == mp2975)\n\t\tmemcpy(&data->info, &mp2975_info, sizeof(*info));\n\telse\n\t\tmemcpy(&data->info, &mp2973_info, sizeof(*info));\n\n\tinfo = &data->info;\n\n\t \n\tret = mp2975_identify_multiphase_rail2(client, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret) {\n\t\t \n\t\tdata->info.pages = MP2975_PAGE_NUM;\n\t\tdata->info.phases[1] = ret;\n\t\tdata->info.func[1] = MP2975_RAIL2_FUNC;\n\t\tif (IS_ENABLED(CONFIG_SENSORS_MP2975_REGULATOR))\n\t\t\tdata->info.num_regulators = MP2975_PAGE_NUM;\n\t}\n\n\t \n\tret = mp2975_identify_multiphase(client, data, info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data->chip_id == mp2975) {\n\t\t \n\t\tret = mp2975_identify_rails_vid(client, data, info);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = mp2975_current_sense_gain_get(client, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = mp2975_vref_get(client, data, info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = mp2975_vout_ov_scale_get(client, data, info);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tret = mp2973_identify_rails_vid(client, data, info);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = mp2975_vout_per_rail_config_get(client, data, info);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pmbus_do_probe(client, info);\n}\n\nstatic const struct of_device_id __maybe_unused mp2975_of_match[] = {\n\t{.compatible = \"mps,mp2971\", .data = (void *)mp2971},\n\t{.compatible = \"mps,mp2973\", .data = (void *)mp2973},\n\t{.compatible = \"mps,mp2975\", .data = (void *)mp2975},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mp2975_of_match);\n\nstatic struct i2c_driver mp2975_driver = {\n\t.driver = {\n\t\t.name = \"mp2975\",\n\t\t.of_match_table = of_match_ptr(mp2975_of_match),\n\t},\n\t.probe = mp2975_probe,\n\t.id_table = mp2975_id,\n};\n\nmodule_i2c_driver(mp2975_driver);\n\nMODULE_AUTHOR(\"Vadim Pasternak <vadimp@nvidia.com>\");\nMODULE_DESCRIPTION(\"PMBus driver for MPS MP2975 device\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}