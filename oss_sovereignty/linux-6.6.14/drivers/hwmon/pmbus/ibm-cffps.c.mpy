{
  "module_name": "ibm-cffps.c",
  "hash_id": "77878879e8015cd8f58af09e8814bc5dfa77b2b652a602090e2e800257a243e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/ibm-cffps.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/i2c.h>\n#include <linux/jiffies.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/pmbus.h>\n\n#include \"pmbus.h\"\n\n#define CFFPS_CCIN_CMD\t\t\t\t0xBD\n#define CFFPS_FW_CMD\t\t\t\t0xFA\n#define CFFPS1_FW_NUM_BYTES\t\t\t4\n#define CFFPS2_FW_NUM_WORDS\t\t\t3\n#define CFFPS_SYS_CONFIG_CMD\t\t\t0xDA\n#define CFFPS_12VCS_VOUT_CMD\t\t\t0xDE\n\n#define CFFPS_INPUT_HISTORY_CMD\t\t\t0xD6\n#define CFFPS_INPUT_HISTORY_SIZE\t\t101\n\n#define CFFPS_CCIN_REVISION\t\t\tGENMASK(7, 0)\n#define CFFPS_CCIN_REVISION_LEGACY\t\t 0xde\n#define CFFPS_CCIN_VERSION\t\t\tGENMASK(15, 8)\n#define CFFPS_CCIN_VERSION_1\t\t\t 0x2b\n#define CFFPS_CCIN_VERSION_2\t\t\t 0x2e\n#define CFFPS_CCIN_VERSION_3\t\t\t 0x51\n\n \n#define CFFPS_MFR_FAN_FAULT\t\t\tBIT(0)\n#define CFFPS_MFR_THERMAL_FAULT\t\t\tBIT(1)\n#define CFFPS_MFR_OV_FAULT\t\t\tBIT(2)\n#define CFFPS_MFR_UV_FAULT\t\t\tBIT(3)\n#define CFFPS_MFR_PS_KILL\t\t\tBIT(4)\n#define CFFPS_MFR_OC_FAULT\t\t\tBIT(5)\n#define CFFPS_MFR_VAUX_FAULT\t\t\tBIT(6)\n#define CFFPS_MFR_CURRENT_SHARE_WARNING\t\tBIT(7)\n\n#define CFFPS_LED_BLINK\t\t\t\t(BIT(0) | BIT(6))\n#define CFFPS_LED_ON\t\t\t\t(BIT(1) | BIT(6))\n#define CFFPS_LED_OFF\t\t\t\t(BIT(2) | BIT(6))\n#define CFFPS_BLINK_RATE_MS\t\t\t250\n\nenum {\n\tCFFPS_DEBUGFS_MAX_POWER_OUT = 0,\n\tCFFPS_DEBUGFS_CCIN,\n\tCFFPS_DEBUGFS_FW,\n\tCFFPS_DEBUGFS_ON_OFF_CONFIG,\n\tCFFPS_DEBUGFS_NUM_ENTRIES\n};\n\nenum versions { cffps1, cffps2, cffps_unknown };\n\nstruct ibm_cffps {\n\tenum versions version;\n\tstruct i2c_client *client;\n\n\tu8 input_history[CFFPS_INPUT_HISTORY_SIZE];\n\n\tint debugfs_entries[CFFPS_DEBUGFS_NUM_ENTRIES];\n\n\tchar led_name[32];\n\tu8 led_state;\n\tstruct led_classdev led;\n};\n\n#define to_psu(x, y) container_of((x), struct ibm_cffps, debugfs_entries[(y)])\n\nstatic ssize_t ibm_cffps_debugfs_read_input_history(struct file *file, char __user *buf,\n\t\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tint rc;\n\tu8 cmd = CFFPS_INPUT_HISTORY_CMD;\n\tstruct ibm_cffps *psu = file->private_data;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = psu->client->addr,\n\t\t\t.flags = psu->client->flags,\n\t\t\t.len = 1,\n\t\t\t.buf = &cmd,\n\t\t}, {\n\t\t\t.addr = psu->client->addr,\n\t\t\t.flags = psu->client->flags | I2C_M_RD,\n\t\t\t.len = CFFPS_INPUT_HISTORY_SIZE,\n\t\t\t.buf = psu->input_history,\n\t\t},\n\t};\n\n\tif (!*ppos) {\n\t\trc = pmbus_lock_interruptible(psu->client);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = pmbus_set_page(psu->client, 0, 0xff);\n\t\tif (rc) {\n\t\t\tpmbus_unlock(psu->client);\n\t\t\treturn rc;\n\t\t}\n\n\t\t \n\t\trc = i2c_transfer(psu->client->adapter, msg, 2);\n\t\tpmbus_unlock(psu->client);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn simple_read_from_buffer(buf, count, ppos,\n\t\t\t\t       psu->input_history + 1,\n\t\t\t\t       psu->input_history[0]);\n}\n\nstatic const struct file_operations ibm_cffps_input_history_fops = {\n\t.llseek = noop_llseek,\n\t.read = ibm_cffps_debugfs_read_input_history,\n\t.open = simple_open,\n};\n\nstatic ssize_t ibm_cffps_debugfs_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tint i, rc;\n\tint *idxp = file->private_data;\n\tint idx = *idxp;\n\tstruct ibm_cffps *psu = to_psu(idxp, idx);\n\tchar data[I2C_SMBUS_BLOCK_MAX + 2] = { 0 };\n\n\trc = pmbus_lock_interruptible(psu->client);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pmbus_set_page(psu->client, 0, 0xff);\n\tif (rc)\n\t\tgoto unlock;\n\n\tswitch (idx) {\n\tcase CFFPS_DEBUGFS_MAX_POWER_OUT:\n\t\tif (psu->version == cffps1)\n\t\t\trc = i2c_smbus_read_word_swapped(psu->client, PMBUS_MFR_POUT_MAX);\n\t\telse\n\t\t\trc = i2c_smbus_read_word_data(psu->client, PMBUS_MFR_POUT_MAX);\n\t\tif (rc >= 0)\n\t\t\trc = snprintf(data, I2C_SMBUS_BLOCK_MAX, \"%d\", rc);\n\t\tbreak;\n\tcase CFFPS_DEBUGFS_CCIN:\n\t\trc = i2c_smbus_read_word_swapped(psu->client, CFFPS_CCIN_CMD);\n\t\tif (rc >= 0)\n\t\t\trc = snprintf(data, 5, \"%04X\", rc);\n\t\tbreak;\n\tcase CFFPS_DEBUGFS_FW:\n\t\tswitch (psu->version) {\n\t\tcase cffps1:\n\t\t\tfor (i = 0; i < CFFPS1_FW_NUM_BYTES; ++i) {\n\t\t\t\trc = i2c_smbus_read_byte_data(psu->client, CFFPS_FW_CMD + i);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\tgoto unlock;\n\n\t\t\t\tsnprintf(&data[i * 2], 3, \"%02X\", rc);\n\t\t\t}\n\n\t\t\trc = i * 2;\n\t\t\tbreak;\n\t\tcase cffps2:\n\t\t\tfor (i = 0; i < CFFPS2_FW_NUM_WORDS; ++i) {\n\t\t\t\trc = i2c_smbus_read_word_data(psu->client, CFFPS_FW_CMD + i);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\tgoto unlock;\n\n\t\t\t\tsnprintf(&data[i * 4], 5, \"%04X\", rc);\n\t\t\t}\n\n\t\t\trc = i * 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CFFPS_DEBUGFS_ON_OFF_CONFIG:\n\t\trc = i2c_smbus_read_byte_data(psu->client, PMBUS_ON_OFF_CONFIG);\n\t\tif (rc >= 0)\n\t\t\trc = snprintf(data, 3, \"%02x\", rc);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\tpmbus_unlock(psu->client);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tdata[rc] = '\\n';\n\trc += 2;\n\n\treturn simple_read_from_buffer(buf, count, ppos, data, rc);\n}\n\nstatic ssize_t ibm_cffps_debugfs_write(struct file *file,\n\t\t\t\t       const char __user *buf, size_t count,\n\t\t\t\t       loff_t *ppos)\n{\n\tu8 data;\n\tssize_t rc;\n\tint *idxp = file->private_data;\n\tint idx = *idxp;\n\tstruct ibm_cffps *psu = to_psu(idxp, idx);\n\n\tswitch (idx) {\n\tcase CFFPS_DEBUGFS_ON_OFF_CONFIG:\n\t\trc = simple_write_to_buffer(&data, 1, ppos, buf, count);\n\t\tif (rc <= 0)\n\t\t\treturn rc;\n\n\t\trc = pmbus_lock_interruptible(psu->client);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = pmbus_set_page(psu->client, 0, 0xff);\n\t\tif (rc) {\n\t\t\tpmbus_unlock(psu->client);\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = i2c_smbus_write_byte_data(psu->client, PMBUS_ON_OFF_CONFIG, data);\n\t\tpmbus_unlock(psu->client);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nstatic const struct file_operations ibm_cffps_fops = {\n\t.llseek = noop_llseek,\n\t.read = ibm_cffps_debugfs_read,\n\t.write = ibm_cffps_debugfs_write,\n\t.open = simple_open,\n};\n\nstatic int ibm_cffps_read_byte_data(struct i2c_client *client, int page,\n\t\t\t\t    int reg)\n{\n\tint rc, mfr;\n\n\tswitch (reg) {\n\tcase PMBUS_STATUS_VOUT:\n\tcase PMBUS_STATUS_IOUT:\n\tcase PMBUS_STATUS_TEMPERATURE:\n\tcase PMBUS_STATUS_FAN_12:\n\t\trc = pmbus_read_byte_data(client, page, reg);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tmfr = pmbus_read_byte_data(client, page,\n\t\t\t\t\t   PMBUS_STATUS_MFR_SPECIFIC);\n\t\tif (mfr < 0)\n\t\t\t \n\t\t\treturn rc;\n\n\t\t \n\t\tif (reg == PMBUS_STATUS_FAN_12) {\n\t\t\tif (mfr & CFFPS_MFR_FAN_FAULT)\n\t\t\t\trc |= PB_FAN_FAN1_FAULT;\n\t\t} else if (reg == PMBUS_STATUS_TEMPERATURE) {\n\t\t\tif (mfr & CFFPS_MFR_THERMAL_FAULT)\n\t\t\t\trc |= PB_TEMP_OT_FAULT;\n\t\t} else if (reg == PMBUS_STATUS_VOUT) {\n\t\t\tif (mfr & (CFFPS_MFR_OV_FAULT | CFFPS_MFR_VAUX_FAULT))\n\t\t\t\trc |= PB_VOLTAGE_OV_FAULT;\n\t\t\tif (mfr & CFFPS_MFR_UV_FAULT)\n\t\t\t\trc |= PB_VOLTAGE_UV_FAULT;\n\t\t} else if (reg == PMBUS_STATUS_IOUT) {\n\t\t\tif (mfr & CFFPS_MFR_OC_FAULT)\n\t\t\t\trc |= PB_IOUT_OC_FAULT;\n\t\t\tif (mfr & CFFPS_MFR_CURRENT_SHARE_WARNING)\n\t\t\t\trc |= PB_CURRENT_SHARE_FAULT;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -ENODATA;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int ibm_cffps_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t    int phase, int reg)\n{\n\tint rc, mfr;\n\n\tswitch (reg) {\n\tcase PMBUS_STATUS_WORD:\n\t\trc = pmbus_read_word_data(client, page, phase, reg);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tmfr = pmbus_read_byte_data(client, page,\n\t\t\t\t\t   PMBUS_STATUS_MFR_SPECIFIC);\n\t\tif (mfr < 0)\n\t\t\t \n\t\t\treturn rc;\n\n\t\tif (mfr & CFFPS_MFR_PS_KILL)\n\t\t\trc |= PB_STATUS_OFF;\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_VMON:\n\t\trc = pmbus_read_word_data(client, page, phase,\n\t\t\t\t\t  CFFPS_12VCS_VOUT_CMD);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENODATA;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int ibm_cffps_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tint rc;\n\tu8 next_led_state;\n\tstruct ibm_cffps *psu = container_of(led_cdev, struct ibm_cffps, led);\n\n\tif (brightness == LED_OFF) {\n\t\tnext_led_state = CFFPS_LED_OFF;\n\t} else {\n\t\tbrightness = LED_FULL;\n\n\t\tif (psu->led_state != CFFPS_LED_BLINK)\n\t\t\tnext_led_state = CFFPS_LED_ON;\n\t\telse\n\t\t\tnext_led_state = CFFPS_LED_BLINK;\n\t}\n\n\tdev_dbg(&psu->client->dev, \"LED brightness set: %d. Command: %d.\\n\",\n\t\tbrightness, next_led_state);\n\n\trc = pmbus_lock_interruptible(psu->client);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pmbus_set_page(psu->client, 0, 0xff);\n\tif (rc) {\n\t\tpmbus_unlock(psu->client);\n\t\treturn rc;\n\t}\n\n\trc = i2c_smbus_write_byte_data(psu->client, CFFPS_SYS_CONFIG_CMD,\n\t\t\t\t       next_led_state);\n\tpmbus_unlock(psu->client);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tpsu->led_state = next_led_state;\n\tled_cdev->brightness = brightness;\n\n\treturn 0;\n}\n\nstatic int ibm_cffps_led_blink_set(struct led_classdev *led_cdev,\n\t\t\t\t   unsigned long *delay_on,\n\t\t\t\t   unsigned long *delay_off)\n{\n\tint rc;\n\tstruct ibm_cffps *psu = container_of(led_cdev, struct ibm_cffps, led);\n\n\tdev_dbg(&psu->client->dev, \"LED blink set.\\n\");\n\n\trc = pmbus_lock_interruptible(psu->client);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pmbus_set_page(psu->client, 0, 0xff);\n\tif (rc) {\n\t\tpmbus_unlock(psu->client);\n\t\treturn rc;\n\t}\n\n\trc = i2c_smbus_write_byte_data(psu->client, CFFPS_SYS_CONFIG_CMD,\n\t\t\t\t       CFFPS_LED_BLINK);\n\tpmbus_unlock(psu->client);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tpsu->led_state = CFFPS_LED_BLINK;\n\tled_cdev->brightness = LED_FULL;\n\t*delay_on = CFFPS_BLINK_RATE_MS;\n\t*delay_off = CFFPS_BLINK_RATE_MS;\n\n\treturn 0;\n}\n\nstatic void ibm_cffps_create_led_class(struct ibm_cffps *psu)\n{\n\tint rc;\n\tstruct i2c_client *client = psu->client;\n\tstruct device *dev = &client->dev;\n\n\tsnprintf(psu->led_name, sizeof(psu->led_name), \"%s-%02x\", client->name,\n\t\t client->addr);\n\tpsu->led.name = psu->led_name;\n\tpsu->led.max_brightness = LED_FULL;\n\tpsu->led.brightness_set_blocking = ibm_cffps_led_brightness_set;\n\tpsu->led.blink_set = ibm_cffps_led_blink_set;\n\n\trc = devm_led_classdev_register(dev, &psu->led);\n\tif (rc)\n\t\tdev_warn(dev, \"failed to register led class: %d\\n\", rc);\n\telse\n\t\ti2c_smbus_write_byte_data(client, CFFPS_SYS_CONFIG_CMD,\n\t\t\t\t\t  CFFPS_LED_OFF);\n}\n\nstatic struct pmbus_driver_info ibm_cffps_info[] = {\n\t[cffps1] = {\n\t\t.pages = 1,\n\t\t.func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_VOUT | PMBUS_HAVE_IOUT |\n\t\t\tPMBUS_HAVE_PIN | PMBUS_HAVE_FAN12 | PMBUS_HAVE_TEMP |\n\t\t\tPMBUS_HAVE_TEMP2 | PMBUS_HAVE_TEMP3 |\n\t\t\tPMBUS_HAVE_STATUS_VOUT | PMBUS_HAVE_STATUS_IOUT |\n\t\t\tPMBUS_HAVE_STATUS_INPUT | PMBUS_HAVE_STATUS_TEMP |\n\t\t\tPMBUS_HAVE_STATUS_FAN12,\n\t\t.read_byte_data = ibm_cffps_read_byte_data,\n\t\t.read_word_data = ibm_cffps_read_word_data,\n\t},\n\t[cffps2] = {\n\t\t.pages = 2,\n\t\t.func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_VOUT | PMBUS_HAVE_IOUT |\n\t\t\tPMBUS_HAVE_PIN | PMBUS_HAVE_FAN12 | PMBUS_HAVE_TEMP |\n\t\t\tPMBUS_HAVE_TEMP2 | PMBUS_HAVE_TEMP3 |\n\t\t\tPMBUS_HAVE_STATUS_VOUT | PMBUS_HAVE_STATUS_IOUT |\n\t\t\tPMBUS_HAVE_STATUS_INPUT | PMBUS_HAVE_STATUS_TEMP |\n\t\t\tPMBUS_HAVE_STATUS_FAN12 | PMBUS_HAVE_VMON,\n\t\t.func[1] = PMBUS_HAVE_VIN | PMBUS_HAVE_VOUT | PMBUS_HAVE_IOUT |\n\t\t\tPMBUS_HAVE_PIN | PMBUS_HAVE_TEMP | PMBUS_HAVE_TEMP2 |\n\t\t\tPMBUS_HAVE_TEMP3 | PMBUS_HAVE_STATUS_VOUT |\n\t\t\tPMBUS_HAVE_STATUS_IOUT | PMBUS_HAVE_STATUS_INPUT |\n\t\t\tPMBUS_HAVE_STATUS_TEMP,\n\t\t.read_byte_data = ibm_cffps_read_byte_data,\n\t\t.read_word_data = ibm_cffps_read_word_data,\n\t},\n};\n\nstatic struct pmbus_platform_data ibm_cffps_pdata = {\n\t.flags = PMBUS_SKIP_STATUS_CHECK | PMBUS_NO_CAPABILITY,\n};\n\nstatic const struct i2c_device_id ibm_cffps_id[] = {\n\t{ \"ibm_cffps1\", cffps1 },\n\t{ \"ibm_cffps2\", cffps2 },\n\t{ \"ibm_cffps\", cffps_unknown },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ibm_cffps_id);\n\nstatic int ibm_cffps_probe(struct i2c_client *client)\n{\n\tint i, rc;\n\tenum versions vs = cffps_unknown;\n\tstruct dentry *debugfs;\n\tstruct ibm_cffps *psu;\n\tconst void *md = of_device_get_match_data(&client->dev);\n\tconst struct i2c_device_id *id;\n\n\tif (md) {\n\t\tvs = (uintptr_t)md;\n\t} else {\n\t\tid = i2c_match_id(ibm_cffps_id, client);\n\t\tif (id)\n\t\t\tvs = (enum versions)id->driver_data;\n\t}\n\n\tif (vs == cffps_unknown) {\n\t\tu16 ccin_revision = 0;\n\t\tu16 ccin_version = CFFPS_CCIN_VERSION_1;\n\t\tint ccin = i2c_smbus_read_word_swapped(client, CFFPS_CCIN_CMD);\n\t\tchar mfg_id[I2C_SMBUS_BLOCK_MAX + 2] = { 0 };\n\n\t\tif (ccin > 0) {\n\t\t\tccin_revision = FIELD_GET(CFFPS_CCIN_REVISION, ccin);\n\t\t\tccin_version = FIELD_GET(CFFPS_CCIN_VERSION, ccin);\n\t\t}\n\n\t\trc = i2c_smbus_read_block_data(client, PMBUS_MFR_ID, mfg_id);\n\t\tif (rc < 0) {\n\t\t\tdev_err(&client->dev, \"Failed to read Manufacturer ID\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tswitch (ccin_version) {\n\t\tdefault:\n\t\tcase CFFPS_CCIN_VERSION_1:\n\t\t\tif ((strncmp(mfg_id, \"ACBE\", 4) == 0) ||\n\t\t\t\t     (strncmp(mfg_id, \"ARTE\", 4) == 0))\n\t\t\t\tvs = cffps1;\n\t\t\telse\n\t\t\t\tvs = cffps2;\n\t\t\tbreak;\n\t\tcase CFFPS_CCIN_VERSION_2:\n\t\t\tvs = cffps2;\n\t\t\tbreak;\n\t\tcase CFFPS_CCIN_VERSION_3:\n\t\t\tif (ccin_revision == CFFPS_CCIN_REVISION_LEGACY)\n\t\t\t\tvs = cffps1;\n\t\t\telse\n\t\t\t\tvs = cffps2;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsnprintf(client->name, I2C_NAME_SIZE, \"cffps%d\", vs + 1);\n\t}\n\n\tclient->dev.platform_data = &ibm_cffps_pdata;\n\trc = pmbus_do_probe(client, &ibm_cffps_info[vs]);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpsu = devm_kzalloc(&client->dev, sizeof(*psu), GFP_KERNEL);\n\tif (!psu)\n\t\treturn 0;\n\n\tpsu->version = vs;\n\tpsu->client = client;\n\n\tibm_cffps_create_led_class(psu);\n\n\t \n\tdebugfs = pmbus_get_debugfs_dir(client);\n\tif (!debugfs)\n\t\treturn 0;\n\n\tfor (i = 0; i < CFFPS_DEBUGFS_NUM_ENTRIES; ++i)\n\t\tpsu->debugfs_entries[i] = i;\n\n\tdebugfs_create_file(\"input_history\", 0444, debugfs, psu, &ibm_cffps_input_history_fops);\n\tdebugfs_create_file(\"max_power_out\", 0444, debugfs,\n\t\t\t    &psu->debugfs_entries[CFFPS_DEBUGFS_MAX_POWER_OUT],\n\t\t\t    &ibm_cffps_fops);\n\tdebugfs_create_file(\"ccin\", 0444, debugfs,\n\t\t\t    &psu->debugfs_entries[CFFPS_DEBUGFS_CCIN],\n\t\t\t    &ibm_cffps_fops);\n\tdebugfs_create_file(\"fw_version\", 0444, debugfs,\n\t\t\t    &psu->debugfs_entries[CFFPS_DEBUGFS_FW],\n\t\t\t    &ibm_cffps_fops);\n\tdebugfs_create_file(\"on_off_config\", 0644, debugfs,\n\t\t\t    &psu->debugfs_entries[CFFPS_DEBUGFS_ON_OFF_CONFIG],\n\t\t\t    &ibm_cffps_fops);\n\n\t \n\tdebugfs_create_symlink(client->name, debugfs, \".\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ibm_cffps_of_match[] = {\n\t{\n\t\t.compatible = \"ibm,cffps1\",\n\t\t.data = (void *)cffps1\n\t},\n\t{\n\t\t.compatible = \"ibm,cffps2\",\n\t\t.data = (void *)cffps2\n\t},\n\t{\n\t\t.compatible = \"ibm,cffps\",\n\t\t.data = (void *)cffps_unknown\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ibm_cffps_of_match);\n\nstatic struct i2c_driver ibm_cffps_driver = {\n\t.driver = {\n\t\t.name = \"ibm-cffps\",\n\t\t.of_match_table = ibm_cffps_of_match,\n\t},\n\t.probe = ibm_cffps_probe,\n\t.id_table = ibm_cffps_id,\n};\n\nmodule_i2c_driver(ibm_cffps_driver);\n\nMODULE_AUTHOR(\"Eddie James\");\nMODULE_DESCRIPTION(\"PMBus driver for IBM Common Form Factor power supplies\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}