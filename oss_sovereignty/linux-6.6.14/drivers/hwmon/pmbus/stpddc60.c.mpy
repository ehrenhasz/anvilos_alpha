{
  "module_name": "stpddc60.c",
  "hash_id": "4ec732e40dbecd84040ebfb46535342afe44e8b10a19540b9853c7af794c61d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/stpddc60.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/pmbus.h>\n#include \"pmbus.h\"\n\n#define STPDDC60_MFR_READ_VOUT\t\t0xd2\n#define STPDDC60_MFR_OV_LIMIT_OFFSET\t0xe5\n#define STPDDC60_MFR_UV_LIMIT_OFFSET\t0xe6\n\nstatic const struct i2c_device_id stpddc60_id[] = {\n\t{\"stpddc60\", 0},\n\t{\"bmr481\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, stpddc60_id);\n\nstatic struct pmbus_driver_info stpddc60_info = {\n\t.pages = 1,\n\t.func[0] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\n\t\t| PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\n\t\t| PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP\n\t\t| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\n\t\t| PMBUS_HAVE_POUT,\n};\n\n \nstatic u8 stpddc60_get_offset(int vout, u16 limit, bool over)\n{\n\tint offset;\n\tlong v, l;\n\n\tv = 250 + (vout - 1) * 5;  \n\tl = (limit * 1000L) >> 8;  \n\n\tif (over == (l < v))\n\t\treturn 0;\n\n\toffset = DIV_ROUND_CLOSEST(abs(l - v), 50);\n\n\tif (offset > 0)\n\t\toffset--;\n\n\treturn clamp_val(offset, 0, 7);\n}\n\n \nstatic u16 stpddc60_adjust_linear(u16 word, s16 fixed)\n{\n\ts16 e, m, d;\n\n\te = ((s16)word) >> 11;\n\tm = ((s16)((word & 0x7ff) << 5)) >> 5;\n\td = e - fixed;\n\n\tif (d >= 0)\n\t\tm <<= d;\n\telse\n\t\tm >>= -d;\n\n\treturn clamp_val(m, 0, 0x3ff) | ((fixed << 11) & 0xf800);\n}\n\n \nstatic int stpddc60_read_byte_data(struct i2c_client *client, int page, int reg)\n{\n\tint ret;\n\n\tif (page > 0)\n\t\treturn -ENXIO;\n\n\tswitch (reg) {\n\tcase PMBUS_VOUT_MODE:\n\t\tret = 0x18;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int stpddc60_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t   int phase, int reg)\n{\n\tint ret;\n\n\tif (page > 0)\n\t\treturn -ENXIO;\n\n\tswitch (reg) {\n\tcase PMBUS_READ_VOUT:\n\t\tret = pmbus_read_word_data(client, page, phase,\n\t\t\t\t\t   STPDDC60_MFR_READ_VOUT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret &= 0x7ff;\n\t\tbreak;\n\tcase PMBUS_VOUT_OV_FAULT_LIMIT:\n\tcase PMBUS_VOUT_UV_FAULT_LIMIT:\n\t\tret = pmbus_read_word_data(client, page, phase, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret &= 0x7ff;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int stpddc60_write_word_data(struct i2c_client *client, int page,\n\t\t\t\t    int reg, u16 word)\n{\n\tint ret;\n\tu8 offset;\n\n\tif (page > 0)\n\t\treturn -ENXIO;\n\n\tswitch (reg) {\n\tcase PMBUS_VOUT_OV_FAULT_LIMIT:\n\t\tret = pmbus_read_word_data(client, page, 0xff,\n\t\t\t\t\t   PMBUS_VOUT_COMMAND);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = stpddc60_get_offset(ret, word, true);\n\t\tret = pmbus_write_byte_data(client, page,\n\t\t\t\t\t    STPDDC60_MFR_OV_LIMIT_OFFSET,\n\t\t\t\t\t    offset);\n\t\tbreak;\n\tcase PMBUS_VOUT_UV_FAULT_LIMIT:\n\t\tret = pmbus_read_word_data(client, page, 0xff,\n\t\t\t\t\t   PMBUS_VOUT_COMMAND);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = stpddc60_get_offset(ret, word, false);\n\t\tret = pmbus_write_byte_data(client, page,\n\t\t\t\t\t    STPDDC60_MFR_UV_LIMIT_OFFSET,\n\t\t\t\t\t    offset);\n\t\tbreak;\n\tcase PMBUS_VIN_OV_FAULT_LIMIT:\n\tcase PMBUS_VIN_UV_FAULT_LIMIT:\n\tcase PMBUS_OT_FAULT_LIMIT:\n\tcase PMBUS_OT_WARN_LIMIT:\n\tcase PMBUS_IOUT_OC_FAULT_LIMIT:\n\tcase PMBUS_IOUT_OC_WARN_LIMIT:\n\tcase PMBUS_POUT_OP_FAULT_LIMIT:\n\t\tret = pmbus_read_word_data(client, page, 0xff, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tword = stpddc60_adjust_linear(word, ret >> 11);\n\t\tret = pmbus_write_word_data(client, page, reg, word);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int stpddc60_probe(struct i2c_client *client)\n{\n\tint status;\n\tu8 device_id[I2C_SMBUS_BLOCK_MAX + 1];\n\tconst struct i2c_device_id *mid;\n\tstruct pmbus_driver_info *info = &stpddc60_info;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_BLOCK_DATA))\n\t\treturn -ENODEV;\n\n\tstatus = i2c_smbus_read_block_data(client, PMBUS_MFR_MODEL, device_id);\n\tif (status < 0) {\n\t\tdev_err(&client->dev, \"Failed to read Manufacturer Model\\n\");\n\t\treturn status;\n\t}\n\tfor (mid = stpddc60_id; mid->name[0]; mid++) {\n\t\tif (!strncasecmp(mid->name, device_id, strlen(mid->name)))\n\t\t\tbreak;\n\t}\n\tif (!mid->name[0]) {\n\t\tdev_err(&client->dev, \"Unsupported device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tinfo->read_byte_data = stpddc60_read_byte_data;\n\tinfo->read_word_data = stpddc60_read_word_data;\n\tinfo->write_word_data = stpddc60_write_word_data;\n\n\tstatus = pmbus_do_probe(client, info);\n\tif (status < 0)\n\t\treturn status;\n\n\tpmbus_set_update(client, PMBUS_VOUT_OV_FAULT_LIMIT, true);\n\tpmbus_set_update(client, PMBUS_VOUT_UV_FAULT_LIMIT, true);\n\n\treturn 0;\n}\n\nstatic struct i2c_driver stpddc60_driver = {\n\t.driver = {\n\t\t   .name = \"stpddc60\",\n\t\t   },\n\t.probe = stpddc60_probe,\n\t.id_table = stpddc60_id,\n};\n\nmodule_i2c_driver(stpddc60_driver);\n\nMODULE_AUTHOR(\"Erik Rosen <erik.rosen@metormote.com>\");\nMODULE_DESCRIPTION(\"PMBus driver for ST STPDDC60\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}