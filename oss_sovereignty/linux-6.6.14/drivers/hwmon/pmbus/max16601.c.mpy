{
  "module_name": "max16601.c",
  "hash_id": "b1f09d954e989a3ef2273a12b397f5b1a55f120127aa89208f8026867d6a30f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/max16601.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"pmbus.h\"\n\nenum chips { max16508, max16600, max16601, max16602 };\n\n#define REG_DEFAULT_NUM_POP\t0xc4\n#define REG_SETPT_DVID\t\t0xd1\n#define  DAC_10MV_MODE\t\tBIT(4)\n#define REG_IOUT_AVG_PK\t\t0xee\n#define REG_IIN_SENSOR\t\t0xf1\n#define REG_TOTAL_INPUT_POWER\t0xf2\n#define REG_PHASE_ID\t\t0xf3\n#define  CORE_RAIL_INDICATOR\tBIT(7)\n#define REG_PHASE_REPORTING\t0xf4\n\n#define MAX16601_NUM_PHASES\t8\n\nstruct max16601_data {\n\tenum chips id;\n\tstruct pmbus_driver_info info;\n\tstruct i2c_client *vsa;\n\tint iout_avg_pkg;\n};\n\n#define to_max16601_data(x) container_of(x, struct max16601_data, info)\n\nstatic int max16601_read_byte(struct i2c_client *client, int page, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct max16601_data *data = to_max16601_data(info);\n\n\tif (page > 0) {\n\t\tif (page == 2)\t \n\t\t\treturn i2c_smbus_read_byte_data(data->vsa, reg);\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn -ENODATA;\n}\n\nstatic int max16601_read_word(struct i2c_client *client, int page, int phase,\n\t\t\t      int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct max16601_data *data = to_max16601_data(info);\n\tu8 buf[I2C_SMBUS_BLOCK_MAX + 1];\n\tint ret;\n\n\tswitch (page) {\n\tcase 0:\t\t \n\t\tif (phase == 0xff)\n\t\t\treturn -ENODATA;\n\t\tswitch (reg) {\n\t\tcase PMBUS_READ_IIN:\n\t\tcase PMBUS_READ_IOUT:\n\t\tcase PMBUS_READ_TEMPERATURE_1:\n\t\t\tret = i2c_smbus_write_byte_data(client, REG_PHASE_ID,\n\t\t\t\t\t\t\tphase);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = i2c_smbus_read_block_data(client,\n\t\t\t\t\t\t\tREG_PHASE_REPORTING,\n\t\t\t\t\t\t\tbuf);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret < 6)\n\t\t\t\treturn -EIO;\n\t\t\tswitch (reg) {\n\t\t\tcase PMBUS_READ_TEMPERATURE_1:\n\t\t\t\treturn buf[1] << 8 | buf[0];\n\t\t\tcase PMBUS_READ_IOUT:\n\t\t\t\treturn buf[3] << 8 | buf[2];\n\t\t\tcase PMBUS_READ_IIN:\n\t\t\t\treturn buf[5] << 8 | buf[4];\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn -EOPNOTSUPP;\n\tcase 1:\t\t \n\t\tswitch (reg) {\n\t\tcase PMBUS_READ_IIN:\n\t\t\treturn i2c_smbus_read_word_data(client, REG_IIN_SENSOR);\n\t\tcase PMBUS_READ_PIN:\n\t\t\treturn i2c_smbus_read_word_data(client,\n\t\t\t\t\t\t\tREG_TOTAL_INPUT_POWER);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn -EOPNOTSUPP;\n\tcase 2:\t\t \n\t\tswitch (reg) {\n\t\tcase PMBUS_VIRT_READ_IOUT_MAX:\n\t\t\tret = i2c_smbus_read_word_data(data->vsa,\n\t\t\t\t\t\t       REG_IOUT_AVG_PK);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (sign_extend32(ret, 10) >\n\t\t\t    sign_extend32(data->iout_avg_pkg, 10))\n\t\t\t\tdata->iout_avg_pkg = ret;\n\t\t\treturn data->iout_avg_pkg;\n\t\tcase PMBUS_VIRT_RESET_IOUT_HISTORY:\n\t\t\treturn 0;\n\t\tcase PMBUS_IOUT_OC_FAULT_LIMIT:\n\t\tcase PMBUS_IOUT_OC_WARN_LIMIT:\n\t\tcase PMBUS_OT_FAULT_LIMIT:\n\t\tcase PMBUS_OT_WARN_LIMIT:\n\t\tcase PMBUS_READ_IIN:\n\t\tcase PMBUS_READ_IOUT:\n\t\tcase PMBUS_READ_TEMPERATURE_1:\n\t\tcase PMBUS_STATUS_WORD:\n\t\t\treturn i2c_smbus_read_word_data(data->vsa, reg);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int max16601_write_byte(struct i2c_client *client, int page, u8 reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct max16601_data *data = to_max16601_data(info);\n\n\tif (page == 2) {\n\t\tif (reg == PMBUS_CLEAR_FAULTS)\n\t\t\treturn i2c_smbus_write_byte(data->vsa, reg);\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn -ENODATA;\n}\n\nstatic int max16601_write_word(struct i2c_client *client, int page, int reg,\n\t\t\t       u16 value)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct max16601_data *data = to_max16601_data(info);\n\n\tswitch (page) {\n\tcase 0:\t\t \n\t\treturn -ENODATA;\n\tcase 1:\t\t \n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\tcase 2:\t\t \n\t\tswitch (reg) {\n\t\tcase PMBUS_VIRT_RESET_IOUT_HISTORY:\n\t\t\tdata->iout_avg_pkg = 0xfc00;\n\t\t\treturn 0;\n\t\tcase PMBUS_IOUT_OC_FAULT_LIMIT:\n\t\tcase PMBUS_IOUT_OC_WARN_LIMIT:\n\t\tcase PMBUS_OT_FAULT_LIMIT:\n\t\tcase PMBUS_OT_WARN_LIMIT:\n\t\t\treturn i2c_smbus_write_word_data(data->vsa, reg, value);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n}\n\nstatic int max16601_identify(struct i2c_client *client,\n\t\t\t     struct pmbus_driver_info *info)\n{\n\tstruct max16601_data *data = to_max16601_data(info);\n\tint reg;\n\n\treg = i2c_smbus_read_byte_data(client, REG_SETPT_DVID);\n\tif (reg < 0)\n\t\treturn reg;\n\tif (reg & DAC_10MV_MODE)\n\t\tinfo->vrm_version[0] = vr13;\n\telse\n\t\tinfo->vrm_version[0] = vr12;\n\n\tif (data->id != max16600 && data->id != max16601 && data->id != max16602)\n\t\treturn 0;\n\n\treg = i2c_smbus_read_byte_data(client, REG_DEFAULT_NUM_POP);\n\tif (reg < 0)\n\t\treturn reg;\n\n\t \n\treg &= 0x0f;\n\tif (reg && reg <= MAX16601_NUM_PHASES)\n\t\tinfo->phases[0] = reg;\n\n\treturn 0;\n}\n\nstatic struct pmbus_driver_info max16601_info = {\n\t.pages = 3,\n\t.format[PSC_VOLTAGE_IN] = linear,\n\t.format[PSC_VOLTAGE_OUT] = vid,\n\t.format[PSC_CURRENT_IN] = linear,\n\t.format[PSC_CURRENT_OUT] = linear,\n\t.format[PSC_TEMPERATURE] = linear,\n\t.format[PSC_POWER] = linear,\n\t.func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_IIN | PMBUS_HAVE_PIN |\n\t\tPMBUS_HAVE_STATUS_INPUT |\n\t\tPMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT |\n\t\tPMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT |\n\t\tPMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP |\n\t\tPMBUS_HAVE_POUT | PMBUS_PAGE_VIRTUAL | PMBUS_PHASE_VIRTUAL,\n\t.func[1] = PMBUS_HAVE_IIN | PMBUS_HAVE_PIN | PMBUS_PAGE_VIRTUAL,\n\t.func[2] = PMBUS_HAVE_IIN | PMBUS_HAVE_STATUS_INPUT |\n\t\tPMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT |\n\t\tPMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP | PMBUS_PAGE_VIRTUAL,\n\t.phases[0] = MAX16601_NUM_PHASES,\n\t.pfunc[0] = PMBUS_HAVE_IIN | PMBUS_HAVE_IOUT | PMBUS_HAVE_TEMP,\n\t.pfunc[1] = PMBUS_HAVE_IIN | PMBUS_HAVE_IOUT,\n\t.pfunc[2] = PMBUS_HAVE_IIN | PMBUS_HAVE_IOUT | PMBUS_HAVE_TEMP,\n\t.pfunc[3] = PMBUS_HAVE_IIN | PMBUS_HAVE_IOUT,\n\t.pfunc[4] = PMBUS_HAVE_IIN | PMBUS_HAVE_IOUT | PMBUS_HAVE_TEMP,\n\t.pfunc[5] = PMBUS_HAVE_IIN | PMBUS_HAVE_IOUT,\n\t.pfunc[6] = PMBUS_HAVE_IIN | PMBUS_HAVE_IOUT | PMBUS_HAVE_TEMP,\n\t.pfunc[7] = PMBUS_HAVE_IIN | PMBUS_HAVE_IOUT,\n\t.identify = max16601_identify,\n\t.read_byte_data = max16601_read_byte,\n\t.read_word_data = max16601_read_word,\n\t.write_byte = max16601_write_byte,\n\t.write_word_data = max16601_write_word,\n};\n\nstatic void max16601_remove(void *_data)\n{\n\tstruct max16601_data *data = _data;\n\n\ti2c_unregister_device(data->vsa);\n}\n\nstatic const struct i2c_device_id max16601_id[] = {\n\t{\"max16508\", max16508},\n\t{\"max16600\", max16600},\n\t{\"max16601\", max16601},\n\t{\"max16602\", max16602},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, max16601_id);\n\nstatic int max16601_get_id(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tu8 buf[I2C_SMBUS_BLOCK_MAX + 1];\n\tenum chips id;\n\tint ret;\n\n\tret = i2c_smbus_read_block_data(client, PMBUS_IC_DEVICE_ID, buf);\n\tif (ret < 0 || ret < 11)\n\t\treturn -ENODEV;\n\n\t \n\tif (!strncmp(buf, \"MAX16500\", 8) || !strncmp(buf, \"MAX16508\", 8)) {\n\t\tid = max16508;\n\t} else if (!strncmp(buf, \"MAX16600\", 8)) {\n\t\tid = max16600;\n\t} else if (!strncmp(buf, \"MAX16601\", 8)) {\n\t\tid = max16601;\n\t} else if (!strncmp(buf, \"MAX16602\", 8)) {\n\t\tid = max16602;\n\t} else {\n\t\tbuf[ret] = '\\0';\n\t\tdev_err(dev, \"Unsupported chip '%s'\\n\", buf);\n\t\treturn -ENODEV;\n\t}\n\treturn id;\n}\n\nstatic int max16601_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tconst struct i2c_device_id *id;\n\tstruct max16601_data *data;\n\tint ret, chip_id;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_READ_BLOCK_DATA))\n\t\treturn -ENODEV;\n\n\tchip_id = max16601_get_id(client);\n\tif (chip_id < 0)\n\t\treturn chip_id;\n\n\tid = i2c_match_id(max16601_id, client);\n\tif (chip_id != id->driver_data)\n\t\tdev_warn(&client->dev,\n\t\t\t \"Device mismatch: Configured %s (%d), detected %d\\n\",\n\t\t\t id->name, (int) id->driver_data, chip_id);\n\n\tret = i2c_smbus_read_byte_data(client, REG_PHASE_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!(ret & CORE_RAIL_INDICATOR)) {\n\t\tdev_err(dev,\n\t\t\t\"Driver must be instantiated on CORE rail I2C address\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->id = chip_id;\n\tdata->iout_avg_pkg = 0xfc00;\n\tdata->vsa = i2c_new_dummy_device(client->adapter, client->addr + 1);\n\tif (IS_ERR(data->vsa)) {\n\t\tdev_err(dev, \"Failed to register VSA client\\n\");\n\t\treturn PTR_ERR(data->vsa);\n\t}\n\tret = devm_add_action_or_reset(dev, max16601_remove, data);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->info = max16601_info;\n\n\treturn pmbus_do_probe(client, &data->info);\n}\n\nstatic struct i2c_driver max16601_driver = {\n\t.driver = {\n\t\t   .name = \"max16601\",\n\t\t   },\n\t.probe = max16601_probe,\n\t.id_table = max16601_id,\n};\n\nmodule_i2c_driver(max16601_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"PMBus driver for Maxim MAX16601\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}