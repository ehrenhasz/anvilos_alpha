{
  "module_name": "pli1209bc.c",
  "hash_id": "3d72fc815236d3158ca088aa8c5ff2bfc6b9926121177f02968131fa8efd95a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/pli1209bc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/pmbus.h>\n#include <linux/regulator/driver.h>\n#include \"pmbus.h\"\n\n \nstatic struct pmbus_platform_data pli1209bc_plat_data = {\n\t.flags = PMBUS_NO_CAPABILITY,\n};\n\nstatic int pli1209bc_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t    int phase, int reg)\n{\n\tint data;\n\n\tswitch (reg) {\n\t \n\tcase PMBUS_READ_POUT:\n\t\tdata = pmbus_read_word_data(client, page, phase, reg);\n\t\tif (data < 0)\n\t\t\treturn data;\n\t\tdata = sign_extend32(data, 15) * 10;\n\t\treturn clamp_val(data, -32768, 32767) & 0xffff;\n\t \n\tcase PMBUS_READ_VOUT:\n\tcase PMBUS_READ_TEMPERATURE_1:\n\t\tdata = pmbus_read_word_data(client, page, phase,\n\t\t\t\t\t    PMBUS_STATUS_WORD);\n\t\tif (data < 0)\n\t\t\treturn data;\n\t\tif (data & PB_STATUS_POWER_GOOD_N)\n\t\t\treturn 0;\n\t\treturn pmbus_read_word_data(client, page, phase, reg);\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n}\n\nstatic int pli1209bc_write_byte(struct i2c_client *client, int page, u8 reg)\n{\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_CLEAR_FAULTS:\n\t\tret = pmbus_write_byte(client, page, reg);\n\t\t \n\t\tusleep_range(250, 300);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_SENSORS_PLI1209BC_REGULATOR)\nstatic const struct regulator_desc pli1209bc_reg_desc = {\n\t.name = \"vout2\",\n\t.id = 1,\n\t.of_match = of_match_ptr(\"vout2\"),\n\t.regulators_node = of_match_ptr(\"regulators\"),\n\t.ops = &pmbus_regulator_ops,\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n};\n#endif\n\nstatic struct pmbus_driver_info pli1209bc_info = {\n\t.pages = 2,\n\t.format[PSC_VOLTAGE_IN] = direct,\n\t.format[PSC_VOLTAGE_OUT] = direct,\n\t.format[PSC_CURRENT_IN] = direct,\n\t.format[PSC_CURRENT_OUT] = direct,\n\t.format[PSC_POWER] = direct,\n\t.format[PSC_TEMPERATURE] = direct,\n\t.m[PSC_VOLTAGE_IN] = 1,\n\t.b[PSC_VOLTAGE_IN] = 0,\n\t.R[PSC_VOLTAGE_IN] = 1,\n\t.m[PSC_VOLTAGE_OUT] = 1,\n\t.b[PSC_VOLTAGE_OUT] = 0,\n\t.R[PSC_VOLTAGE_OUT] = 1,\n\t.m[PSC_CURRENT_IN] = 1,\n\t.b[PSC_CURRENT_IN] = 0,\n\t.R[PSC_CURRENT_IN] = 3,\n\t.m[PSC_CURRENT_OUT] = 1,\n\t.b[PSC_CURRENT_OUT] = 0,\n\t.R[PSC_CURRENT_OUT] = 2,\n\t.m[PSC_POWER] = 1,\n\t.b[PSC_POWER] = 0,\n\t.R[PSC_POWER] = 1,\n\t.m[PSC_TEMPERATURE] = 1,\n\t.b[PSC_TEMPERATURE] = 0,\n\t.R[PSC_TEMPERATURE] = 0,\n\t \n\t.func[1] = PMBUS_HAVE_VIN | PMBUS_HAVE_VOUT\n\t    | PMBUS_HAVE_IIN | PMBUS_HAVE_IOUT\n\t    | PMBUS_HAVE_PIN | PMBUS_HAVE_POUT\n\t    | PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP\n\t    | PMBUS_HAVE_STATUS_IOUT | PMBUS_HAVE_STATUS_INPUT,\n\t.read_word_data = pli1209bc_read_word_data,\n\t.write_byte = pli1209bc_write_byte,\n#if IS_ENABLED(CONFIG_SENSORS_PLI1209BC_REGULATOR)\n\t.num_regulators = 1,\n\t.reg_desc = &pli1209bc_reg_desc,\n#endif\n};\n\nstatic int pli1209bc_probe(struct i2c_client *client)\n{\n\tclient->dev.platform_data = &pli1209bc_plat_data;\n\treturn pmbus_do_probe(client, &pli1209bc_info);\n}\n\nstatic const struct i2c_device_id pli1209bc_id[] = {\n\t{\"pli1209bc\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, pli1209bc_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pli1209bc_of_match[] = {\n\t{ .compatible = \"vicor,pli1209bc\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pli1209bc_of_match);\n#endif\n\nstatic struct i2c_driver pli1209bc_driver = {\n\t.driver = {\n\t\t   .name = \"pli1209bc\",\n\t\t   .of_match_table = of_match_ptr(pli1209bc_of_match),\n\t\t   },\n\t.probe = pli1209bc_probe,\n\t.id_table = pli1209bc_id,\n};\n\nmodule_i2c_driver(pli1209bc_driver);\n\nMODULE_AUTHOR(\"Marcello Sylvester Bauer <sylv@sylv.io>\");\nMODULE_DESCRIPTION(\"PMBus driver for Vicor PLI1209BC\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}