{
  "module_name": "max31785.c",
  "hash_id": "492a903dd8f58f086ea27b758bb0ee97465ae2ba0f5c811a3fc3f0eaa17af48f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/max31785.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include \"pmbus.h\"\n\nenum max31785_regs {\n\tMFR_REVISION\t\t= 0x9b,\n\tMFR_FAN_CONFIG\t\t= 0xf1,\n};\n\n#define MAX31785\t\t\t0x3030\n#define MAX31785A\t\t\t0x3040\n#define MAX31785B\t\t\t0x3061\n\n#define MFR_FAN_CONFIG_DUAL_TACH\tBIT(12)\n\n#define MAX31785_NR_PAGES\t\t23\n#define MAX31785_NR_FAN_PAGES\t\t6\n\nstatic int max31785_read_byte_data(struct i2c_client *client, int page,\n\t\t\t\t   int reg)\n{\n\tif (page < MAX31785_NR_PAGES)\n\t\treturn -ENODATA;\n\n\tswitch (reg) {\n\tcase PMBUS_VOUT_MODE:\n\t\treturn -ENOTSUPP;\n\tcase PMBUS_FAN_CONFIG_12:\n\t\treturn pmbus_read_byte_data(client, page - MAX31785_NR_PAGES,\n\t\t\t\t\t    reg);\n\t}\n\n\treturn -ENODATA;\n}\n\nstatic int max31785_write_byte(struct i2c_client *client, int page, u8 value)\n{\n\tif (page < MAX31785_NR_PAGES)\n\t\treturn -ENODATA;\n\n\treturn -ENOTSUPP;\n}\n\nstatic int max31785_read_long_data(struct i2c_client *client, int page,\n\t\t\t\t   int reg, u32 *data)\n{\n\tunsigned char cmdbuf[1];\n\tunsigned char rspbuf[4];\n\tint rc;\n\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(cmdbuf),\n\t\t\t.buf = cmdbuf,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(rspbuf),\n\t\t\t.buf = rspbuf,\n\t\t},\n\t};\n\n\tcmdbuf[0] = reg;\n\n\trc = pmbus_set_page(client, page, 0xff);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*data = (rspbuf[0] << (0 * 8)) | (rspbuf[1] << (1 * 8)) |\n\t\t(rspbuf[2] << (2 * 8)) | (rspbuf[3] << (3 * 8));\n\n\treturn rc;\n}\n\nstatic int max31785_get_pwm(struct i2c_client *client, int page)\n{\n\tint rv;\n\n\trv = pmbus_get_fan_rate_device(client, page, 0, percent);\n\tif (rv < 0)\n\t\treturn rv;\n\telse if (rv >= 0x8000)\n\t\treturn 0;\n\telse if (rv >= 0x2711)\n\t\treturn 0x2710;\n\n\treturn rv;\n}\n\nstatic int max31785_get_pwm_mode(struct i2c_client *client, int page)\n{\n\tint config;\n\tint command;\n\n\tconfig = pmbus_read_byte_data(client, page, PMBUS_FAN_CONFIG_12);\n\tif (config < 0)\n\t\treturn config;\n\n\tcommand = pmbus_read_word_data(client, page, 0xff, PMBUS_FAN_COMMAND_1);\n\tif (command < 0)\n\t\treturn command;\n\n\tif (config & PB_FAN_1_RPM)\n\t\treturn (command >= 0x8000) ? 3 : 2;\n\n\tif (command >= 0x8000)\n\t\treturn 3;\n\telse if (command >= 0x2711)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int max31785_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t   int phase, int reg)\n{\n\tu32 val;\n\tint rv;\n\n\tswitch (reg) {\n\tcase PMBUS_READ_FAN_SPEED_1:\n\t\tif (page < MAX31785_NR_PAGES)\n\t\t\treturn -ENODATA;\n\n\t\trv = max31785_read_long_data(client, page - MAX31785_NR_PAGES,\n\t\t\t\t\t     reg, &val);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\n\t\trv = (val >> 16) & 0xffff;\n\t\tbreak;\n\tcase PMBUS_FAN_COMMAND_1:\n\t\t \n\t\trv = (page >= MAX31785_NR_PAGES) ? -ENOTSUPP : -ENODATA;\n\t\tbreak;\n\tcase PMBUS_VIRT_PWM_1:\n\t\trv = max31785_get_pwm(client, page);\n\t\tbreak;\n\tcase PMBUS_VIRT_PWM_ENABLE_1:\n\t\trv = max31785_get_pwm_mode(client, page);\n\t\tbreak;\n\tdefault:\n\t\trv = -ENODATA;\n\t\tbreak;\n\t}\n\n\treturn rv;\n}\n\nstatic inline u32 max31785_scale_pwm(u32 sensor_val)\n{\n\t \n\treturn (sensor_val * 100) / 255;\n}\n\nstatic int max31785_pwm_enable(struct i2c_client *client, int page,\n\t\t\t\t    u16 word)\n{\n\tint config = 0;\n\tint rate;\n\n\tswitch (word) {\n\tcase 0:\n\t\trate = 0x7fff;\n\t\tbreak;\n\tcase 1:\n\t\trate = pmbus_get_fan_rate_cached(client, page, 0, percent);\n\t\tif (rate < 0)\n\t\t\treturn rate;\n\t\trate = max31785_scale_pwm(rate);\n\t\tbreak;\n\tcase 2:\n\t\tconfig = PB_FAN_1_RPM;\n\t\trate = pmbus_get_fan_rate_cached(client, page, 0, rpm);\n\t\tif (rate < 0)\n\t\t\treturn rate;\n\t\tbreak;\n\tcase 3:\n\t\trate = 0xffff;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn pmbus_update_fan(client, page, 0, config, PB_FAN_1_RPM, rate);\n}\n\nstatic int max31785_write_word_data(struct i2c_client *client, int page,\n\t\t\t\t    int reg, u16 word)\n{\n\tswitch (reg) {\n\tcase PMBUS_VIRT_PWM_1:\n\t\treturn pmbus_update_fan(client, page, 0, 0, PB_FAN_1_RPM,\n\t\t\t\t\tmax31785_scale_pwm(word));\n\tcase PMBUS_VIRT_PWM_ENABLE_1:\n\t\treturn max31785_pwm_enable(client, page, word);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENODATA;\n}\n\n#define MAX31785_FAN_FUNCS \\\n\t(PMBUS_HAVE_FAN12 | PMBUS_HAVE_STATUS_FAN12 | PMBUS_HAVE_PWM12)\n\n#define MAX31785_TEMP_FUNCS \\\n\t(PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP)\n\n#define MAX31785_VOUT_FUNCS \\\n\t(PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT)\n\nstatic const struct pmbus_driver_info max31785_info = {\n\t.pages = MAX31785_NR_PAGES,\n\n\t.write_word_data = max31785_write_word_data,\n\t.read_byte_data = max31785_read_byte_data,\n\t.read_word_data = max31785_read_word_data,\n\t.write_byte = max31785_write_byte,\n\n\t \n\t.format[PSC_FAN] = direct,\n\t.m[PSC_FAN] = 1,\n\t.b[PSC_FAN] = 0,\n\t.R[PSC_FAN] = 0,\n\t \n\t.format[PSC_PWM] = direct,\n\t.m[PSC_PWM] = 1,\n\t.b[PSC_PWM] = 0,\n\t.R[PSC_PWM] = 2,\n\t.func[0] = MAX31785_FAN_FUNCS,\n\t.func[1] = MAX31785_FAN_FUNCS,\n\t.func[2] = MAX31785_FAN_FUNCS,\n\t.func[3] = MAX31785_FAN_FUNCS,\n\t.func[4] = MAX31785_FAN_FUNCS,\n\t.func[5] = MAX31785_FAN_FUNCS,\n\n\t.format[PSC_TEMPERATURE] = direct,\n\t.m[PSC_TEMPERATURE] = 1,\n\t.b[PSC_TEMPERATURE] = 0,\n\t.R[PSC_TEMPERATURE] = 2,\n\t.func[6]  = MAX31785_TEMP_FUNCS,\n\t.func[7]  = MAX31785_TEMP_FUNCS,\n\t.func[8]  = MAX31785_TEMP_FUNCS,\n\t.func[9]  = MAX31785_TEMP_FUNCS,\n\t.func[10] = MAX31785_TEMP_FUNCS,\n\t.func[11] = MAX31785_TEMP_FUNCS,\n\t.func[12] = MAX31785_TEMP_FUNCS,\n\t.func[13] = MAX31785_TEMP_FUNCS,\n\t.func[14] = MAX31785_TEMP_FUNCS,\n\t.func[15] = MAX31785_TEMP_FUNCS,\n\t.func[16] = MAX31785_TEMP_FUNCS,\n\n\t.format[PSC_VOLTAGE_OUT] = direct,\n\t.m[PSC_VOLTAGE_OUT] = 1,\n\t.b[PSC_VOLTAGE_OUT] = 0,\n\t.R[PSC_VOLTAGE_OUT] = 0,\n\t.func[17] = MAX31785_VOUT_FUNCS,\n\t.func[18] = MAX31785_VOUT_FUNCS,\n\t.func[19] = MAX31785_VOUT_FUNCS,\n\t.func[20] = MAX31785_VOUT_FUNCS,\n\t.func[21] = MAX31785_VOUT_FUNCS,\n\t.func[22] = MAX31785_VOUT_FUNCS,\n};\n\nstatic int max31785_configure_dual_tach(struct i2c_client *client,\n\t\t\t\t\tstruct pmbus_driver_info *info)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < MAX31785_NR_FAN_PAGES; i++) {\n\t\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = i2c_smbus_read_word_data(client, MFR_FAN_CONFIG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret & MFR_FAN_CONFIG_DUAL_TACH) {\n\t\t\tint virtual = MAX31785_NR_PAGES + i;\n\n\t\t\tinfo->pages = virtual + 1;\n\t\t\tinfo->func[virtual] |= PMBUS_HAVE_FAN12;\n\t\t\tinfo->func[virtual] |= PMBUS_PAGE_VIRTUAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int max31785_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct pmbus_driver_info *info;\n\tbool dual_tach = false;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tinfo = devm_kzalloc(dev, sizeof(struct pmbus_driver_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\t*info = max31785_info;\n\n\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, 255);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_word_data(client, MFR_REVISION);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == MAX31785A || ret == MAX31785B) {\n\t\tdual_tach = true;\n\t} else if (ret == MAX31785) {\n\t\tif (!strcmp(\"max31785a\", client->name) ||\n\t\t    !strcmp(\"max31785b\", client->name))\n\t\t\tdev_warn(dev, \"Expected max31785a/b, found max31785: cannot provide secondary tachometer readings\\n\");\n\t} else {\n\t\tdev_err(dev, \"Unrecognized MAX31785 revision: %x\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\tif (dual_tach) {\n\t\tret = max31785_configure_dual_tach(client, info);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn pmbus_do_probe(client, info);\n}\n\nstatic const struct i2c_device_id max31785_id[] = {\n\t{ \"max31785\", 0 },\n\t{ \"max31785a\", 0 },\n\t{ \"max31785b\", 0 },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(i2c, max31785_id);\n\nstatic const struct of_device_id max31785_of_match[] = {\n\t{ .compatible = \"maxim,max31785\" },\n\t{ .compatible = \"maxim,max31785a\" },\n\t{ .compatible = \"maxim,max31785b\" },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, max31785_of_match);\n\nstatic struct i2c_driver max31785_driver = {\n\t.driver = {\n\t\t.name = \"max31785\",\n\t\t.of_match_table = max31785_of_match,\n\t},\n\t.probe = max31785_probe,\n\t.id_table = max31785_id,\n};\n\nmodule_i2c_driver(max31785_driver);\n\nMODULE_AUTHOR(\"Andrew Jeffery <andrew@aj.id.au>\");\nMODULE_DESCRIPTION(\"PMBus driver for the Maxim MAX31785\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}