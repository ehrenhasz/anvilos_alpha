{
  "module_name": "adm1266.c",
  "hash_id": "7da19db21273f5ce7c0a01b62bc5175251b4d9cb826f4684da03b38ecc179bd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/adm1266.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/crc8.h>\n#include <linux/debugfs.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/i2c-smbus.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/nvmem-provider.h>\n#include \"pmbus.h\"\n#include <linux/slab.h>\n#include <linux/timekeeping.h>\n\n#define ADM1266_BLACKBOX_CONFIG\t0xD3\n#define ADM1266_PDIO_CONFIG\t0xD4\n#define ADM1266_READ_STATE\t0xD9\n#define ADM1266_READ_BLACKBOX\t0xDE\n#define ADM1266_SET_RTC\t\t0xDF\n#define ADM1266_GPIO_CONFIG\t0xE1\n#define ADM1266_BLACKBOX_INFO\t0xE6\n#define ADM1266_PDIO_STATUS\t0xE9\n#define ADM1266_GPIO_STATUS\t0xEA\n\n \n#define ADM1266_GPIO_NR\t\t\t9\n#define ADM1266_GPIO_FUNCTIONS(x)\tFIELD_GET(BIT(0), x)\n#define ADM1266_GPIO_INPUT_EN(x)\tFIELD_GET(BIT(2), x)\n#define ADM1266_GPIO_OUTPUT_EN(x)\tFIELD_GET(BIT(3), x)\n#define ADM1266_GPIO_OPEN_DRAIN(x)\tFIELD_GET(BIT(4), x)\n\n \n#define ADM1266_PDIO_NR\t\t\t16\n#define ADM1266_PDIO_PIN_CFG(x)\t\tFIELD_GET(GENMASK(15, 13), x)\n#define ADM1266_PDIO_GLITCH_FILT(x)\tFIELD_GET(GENMASK(12, 9), x)\n#define ADM1266_PDIO_OUT_CFG(x)\t\tFIELD_GET(GENMASK(2, 0), x)\n\n#define ADM1266_BLACKBOX_OFFSET\t\t0\n#define ADM1266_BLACKBOX_SIZE\t\t64\n\n#define ADM1266_PMBUS_BLOCK_MAX\t\t255\n\nstruct adm1266_data {\n\tstruct pmbus_driver_info info;\n\tstruct gpio_chip gc;\n\tconst char *gpio_names[ADM1266_GPIO_NR + ADM1266_PDIO_NR];\n\tstruct i2c_client *client;\n\tstruct dentry *debugfs_dir;\n\tstruct nvmem_config nvmem_config;\n\tstruct nvmem_device *nvmem;\n\tu8 *dev_mem;\n\tstruct mutex buf_mutex;\n\tu8 write_buf[ADM1266_PMBUS_BLOCK_MAX + 1] ____cacheline_aligned;\n\tu8 read_buf[ADM1266_PMBUS_BLOCK_MAX + 1] ____cacheline_aligned;\n};\n\nstatic const struct nvmem_cell_info adm1266_nvmem_cells[] = {\n\t{\n\t\t.name           = \"blackbox\",\n\t\t.offset         = ADM1266_BLACKBOX_OFFSET,\n\t\t.bytes          = 2048,\n\t},\n};\n\nDECLARE_CRC8_TABLE(pmbus_crc_table);\n\n \nstatic int adm1266_pmbus_block_xfer(struct adm1266_data *data, u8 cmd, u8 w_len, u8 *data_w,\n\t\t\t\t    u8 *data_r)\n{\n\tstruct i2c_client *client = data->client;\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_DMA_SAFE,\n\t\t\t.buf = data->write_buf,\n\t\t\t.len = w_len + 2,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD | I2C_M_DMA_SAFE,\n\t\t\t.buf = data->read_buf,\n\t\t\t.len = ADM1266_PMBUS_BLOCK_MAX + 2,\n\t\t}\n\t};\n\tu8 addr;\n\tu8 crc;\n\tint ret;\n\n\tmutex_lock(&data->buf_mutex);\n\n\tmsgs[0].buf[0] = cmd;\n\tmsgs[0].buf[1] = w_len;\n\tmemcpy(&msgs[0].buf[2], data_w, w_len);\n\n\tret = i2c_transfer(client->adapter, msgs, 2);\n\tif (ret != 2) {\n\t\tif (ret >= 0)\n\t\t\tret = -EPROTO;\n\n\t\tmutex_unlock(&data->buf_mutex);\n\n\t\treturn ret;\n\t}\n\n\tif (client->flags & I2C_CLIENT_PEC) {\n\t\taddr = i2c_8bit_addr_from_msg(&msgs[0]);\n\t\tcrc = crc8(pmbus_crc_table, &addr, 1, 0);\n\t\tcrc = crc8(pmbus_crc_table, msgs[0].buf,  msgs[0].len, crc);\n\n\t\taddr = i2c_8bit_addr_from_msg(&msgs[1]);\n\t\tcrc = crc8(pmbus_crc_table, &addr, 1, crc);\n\t\tcrc = crc8(pmbus_crc_table, msgs[1].buf,  msgs[1].buf[0] + 1, crc);\n\n\t\tif (crc != msgs[1].buf[msgs[1].buf[0] + 1]) {\n\t\t\tmutex_unlock(&data->buf_mutex);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t}\n\n\tmemcpy(data_r, &msgs[1].buf[1], msgs[1].buf[0]);\n\n\tret = msgs[1].buf[0];\n\tmutex_unlock(&data->buf_mutex);\n\n\treturn ret;\n}\n\nstatic const unsigned int adm1266_gpio_mapping[ADM1266_GPIO_NR][2] = {\n\t{1, 0},\n\t{2, 1},\n\t{3, 2},\n\t{4, 8},\n\t{5, 9},\n\t{6, 10},\n\t{7, 11},\n\t{8, 6},\n\t{9, 7},\n};\n\nstatic const char *adm1266_names[ADM1266_GPIO_NR + ADM1266_PDIO_NR] = {\n\t\"GPIO1\", \"GPIO2\", \"GPIO3\", \"GPIO4\", \"GPIO5\", \"GPIO6\", \"GPIO7\", \"GPIO8\",\n\t\"GPIO9\", \"PDIO1\", \"PDIO2\", \"PDIO3\", \"PDIO4\", \"PDIO5\", \"PDIO6\",\n\t\"PDIO7\", \"PDIO8\", \"PDIO9\", \"PDIO10\", \"PDIO11\", \"PDIO12\", \"PDIO13\",\n\t\"PDIO14\", \"PDIO15\", \"PDIO16\",\n};\n\nstatic int adm1266_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct adm1266_data *data = gpiochip_get_data(chip);\n\tu8 read_buf[I2C_SMBUS_BLOCK_MAX + 1];\n\tunsigned long pins_status;\n\tunsigned int pmbus_cmd;\n\tint ret;\n\n\tif (offset < ADM1266_GPIO_NR)\n\t\tpmbus_cmd = ADM1266_GPIO_STATUS;\n\telse\n\t\tpmbus_cmd = ADM1266_PDIO_STATUS;\n\n\tret = i2c_smbus_read_block_data(data->client, pmbus_cmd, read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpins_status = read_buf[0] + (read_buf[1] << 8);\n\tif (offset < ADM1266_GPIO_NR)\n\t\treturn test_bit(adm1266_gpio_mapping[offset][1], &pins_status);\n\n\treturn test_bit(offset - ADM1266_GPIO_NR, &pins_status);\n}\n\nstatic int adm1266_gpio_get_multiple(struct gpio_chip *chip, unsigned long *mask,\n\t\t\t\t     unsigned long *bits)\n{\n\tstruct adm1266_data *data = gpiochip_get_data(chip);\n\tu8 read_buf[ADM1266_PMBUS_BLOCK_MAX + 1];\n\tunsigned long status;\n\tunsigned int gpio_nr;\n\tint ret;\n\n\tret = i2c_smbus_read_block_data(data->client, ADM1266_GPIO_STATUS, read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstatus = read_buf[0] + (read_buf[1] << 8);\n\n\t*bits = 0;\n\tfor_each_set_bit(gpio_nr, mask, ADM1266_GPIO_NR) {\n\t\tif (test_bit(adm1266_gpio_mapping[gpio_nr][1], &status))\n\t\t\tset_bit(gpio_nr, bits);\n\t}\n\n\tret = i2c_smbus_read_block_data(data->client, ADM1266_PDIO_STATUS, read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstatus = read_buf[0] + (read_buf[1] << 8);\n\n\t*bits = 0;\n\tfor_each_set_bit_from(gpio_nr, mask, ADM1266_GPIO_NR + ADM1266_PDIO_STATUS) {\n\t\tif (test_bit(gpio_nr - ADM1266_GPIO_NR, &status))\n\t\t\tset_bit(gpio_nr, bits);\n\t}\n\n\treturn 0;\n}\n\nstatic void adm1266_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tstruct adm1266_data *data = gpiochip_get_data(chip);\n\tu8 read_buf[ADM1266_PMBUS_BLOCK_MAX + 1];\n\tunsigned long gpio_config;\n\tunsigned long pdio_config;\n\tunsigned long pin_cfg;\n\tu8 write_cmd;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ADM1266_GPIO_NR; i++) {\n\t\twrite_cmd = adm1266_gpio_mapping[i][1];\n\t\tret = adm1266_pmbus_block_xfer(data, ADM1266_GPIO_CONFIG, 1, &write_cmd, read_buf);\n\t\tif (ret != 2)\n\t\t\treturn;\n\n\t\tgpio_config = read_buf[0];\n\t\tseq_puts(s, adm1266_names[i]);\n\n\t\tseq_puts(s, \" ( \");\n\t\tif (!ADM1266_GPIO_FUNCTIONS(gpio_config)) {\n\t\t\tseq_puts(s, \"high-Z )\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (ADM1266_GPIO_INPUT_EN(gpio_config))\n\t\t\tseq_puts(s, \"input \");\n\t\tif (ADM1266_GPIO_OUTPUT_EN(gpio_config))\n\t\t\tseq_puts(s, \"output \");\n\t\tif (ADM1266_GPIO_OPEN_DRAIN(gpio_config))\n\t\t\tseq_puts(s, \"open-drain )\\n\");\n\t\telse\n\t\t\tseq_puts(s, \"push-pull )\\n\");\n\t}\n\n\twrite_cmd = 0xFF;\n\tret = adm1266_pmbus_block_xfer(data, ADM1266_PDIO_CONFIG, 1, &write_cmd, read_buf);\n\tif (ret != 32)\n\t\treturn;\n\n\tfor (i = 0; i < ADM1266_PDIO_NR; i++) {\n\t\tseq_puts(s, adm1266_names[ADM1266_GPIO_NR + i]);\n\n\t\tpdio_config = read_buf[2 * i];\n\t\tpdio_config += (read_buf[2 * i + 1] << 8);\n\t\tpin_cfg = ADM1266_PDIO_PIN_CFG(pdio_config);\n\n\t\tseq_puts(s, \" ( \");\n\t\tif (!pin_cfg || pin_cfg > 5) {\n\t\t\tseq_puts(s, \"high-Z )\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pin_cfg & BIT(0))\n\t\t\tseq_puts(s, \"output \");\n\n\t\tif (pin_cfg & BIT(1))\n\t\t\tseq_puts(s, \"input \");\n\n\t\tseq_puts(s, \")\\n\");\n\t}\n}\n\nstatic int adm1266_config_gpio(struct adm1266_data *data)\n{\n\tconst char *name = dev_name(&data->client->dev);\n\tchar *gpio_name;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(data->gpio_names); i++) {\n\t\tgpio_name = devm_kasprintf(&data->client->dev, GFP_KERNEL, \"adm1266-%x-%s\",\n\t\t\t\t\t   data->client->addr, adm1266_names[i]);\n\t\tif (!gpio_name)\n\t\t\treturn -ENOMEM;\n\n\t\tdata->gpio_names[i] = gpio_name;\n\t}\n\n\tdata->gc.label = name;\n\tdata->gc.parent = &data->client->dev;\n\tdata->gc.owner = THIS_MODULE;\n\tdata->gc.can_sleep = true;\n\tdata->gc.base = -1;\n\tdata->gc.names = data->gpio_names;\n\tdata->gc.ngpio = ARRAY_SIZE(data->gpio_names);\n\tdata->gc.get = adm1266_gpio_get;\n\tdata->gc.get_multiple = adm1266_gpio_get_multiple;\n\tdata->gc.dbg_show = adm1266_gpio_dbg_show;\n\n\tret = devm_gpiochip_add_data(&data->client->dev, &data->gc, data);\n\tif (ret)\n\t\tdev_err(&data->client->dev, \"GPIO registering failed (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int adm1266_state_read(struct seq_file *s, void *pdata)\n{\n\tstruct device *dev = s->private;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint ret;\n\n\tret = i2c_smbus_read_word_data(client, ADM1266_READ_STATE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tseq_printf(s, \"%d\\n\", ret);\n\n\treturn 0;\n}\n\nstatic void adm1266_init_debugfs(struct adm1266_data *data)\n{\n\tstruct dentry *root;\n\n\troot = pmbus_get_debugfs_dir(data->client);\n\tif (!root)\n\t\treturn;\n\n\tdata->debugfs_dir = debugfs_create_dir(data->client->name, root);\n\n\tdebugfs_create_devm_seqfile(&data->client->dev, \"sequencer_state\", data->debugfs_dir,\n\t\t\t\t    adm1266_state_read);\n}\n\nstatic int adm1266_nvmem_read_blackbox(struct adm1266_data *data, u8 *read_buff)\n{\n\tint record_count;\n\tchar index;\n\tu8 buf[5];\n\tint ret;\n\n\tret = i2c_smbus_read_block_data(data->client, ADM1266_BLACKBOX_INFO, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != 4)\n\t\treturn -EIO;\n\n\trecord_count = buf[3];\n\n\tfor (index = 0; index < record_count; index++) {\n\t\tret = adm1266_pmbus_block_xfer(data, ADM1266_READ_BLACKBOX, 1, &index, read_buff);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret != ADM1266_BLACKBOX_SIZE)\n\t\t\treturn -EIO;\n\n\t\tread_buff += ADM1266_BLACKBOX_SIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic int adm1266_nvmem_read(void *priv, unsigned int offset, void *val, size_t bytes)\n{\n\tstruct adm1266_data *data = priv;\n\tint ret;\n\n\tif (offset + bytes > data->nvmem_config.size)\n\t\treturn -EINVAL;\n\n\tif (offset == 0) {\n\t\tmemset(data->dev_mem, 0, data->nvmem_config.size);\n\n\t\tret = adm1266_nvmem_read_blackbox(data, data->dev_mem);\n\t\tif (ret) {\n\t\t\tdev_err(&data->client->dev, \"Could not read blackbox!\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmemcpy(val, data->dev_mem + offset, bytes);\n\n\treturn 0;\n}\n\nstatic int adm1266_config_nvmem(struct adm1266_data *data)\n{\n\tdata->nvmem_config.name = dev_name(&data->client->dev);\n\tdata->nvmem_config.dev = &data->client->dev;\n\tdata->nvmem_config.root_only = true;\n\tdata->nvmem_config.read_only = true;\n\tdata->nvmem_config.owner = THIS_MODULE;\n\tdata->nvmem_config.reg_read = adm1266_nvmem_read;\n\tdata->nvmem_config.cells = adm1266_nvmem_cells;\n\tdata->nvmem_config.ncells = ARRAY_SIZE(adm1266_nvmem_cells);\n\tdata->nvmem_config.priv = data;\n\tdata->nvmem_config.stride = 1;\n\tdata->nvmem_config.word_size = 1;\n\tdata->nvmem_config.size = adm1266_nvmem_cells[0].bytes;\n\n\tdata->dev_mem = devm_kzalloc(&data->client->dev, data->nvmem_config.size, GFP_KERNEL);\n\tif (!data->dev_mem)\n\t\treturn -ENOMEM;\n\n\tdata->nvmem = devm_nvmem_register(&data->client->dev, &data->nvmem_config);\n\tif (IS_ERR(data->nvmem)) {\n\t\tdev_err(&data->client->dev, \"Could not register nvmem!\");\n\t\treturn PTR_ERR(data->nvmem);\n\t}\n\n\treturn 0;\n}\n\nstatic int adm1266_set_rtc(struct adm1266_data *data)\n{\n\ttime64_t kt;\n\tchar write_buf[6];\n\tint i;\n\n\tkt = ktime_get_seconds();\n\n\tmemset(write_buf, 0, sizeof(write_buf));\n\n\tfor (i = 0; i < 4; i++)\n\t\twrite_buf[2 + i] = (kt >> (i * 8)) & 0xFF;\n\n\treturn i2c_smbus_write_block_data(data->client, ADM1266_SET_RTC, sizeof(write_buf),\n\t\t\t\t\t  write_buf);\n}\n\nstatic int adm1266_probe(struct i2c_client *client)\n{\n\tstruct adm1266_data *data;\n\tint ret;\n\tint i;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct adm1266_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tdata->info.pages = 17;\n\tdata->info.format[PSC_VOLTAGE_OUT] = linear;\n\tfor (i = 0; i < data->info.pages; i++)\n\t\tdata->info.func[i] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT;\n\n\tcrc8_populate_msb(pmbus_crc_table, 0x7);\n\tmutex_init(&data->buf_mutex);\n\n\tret = adm1266_config_gpio(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adm1266_set_rtc(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adm1266_config_nvmem(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pmbus_do_probe(client, &data->info);\n\tif (ret)\n\t\treturn ret;\n\n\tadm1266_init_debugfs(data);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id adm1266_of_match[] = {\n\t{ .compatible = \"adi,adm1266\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adm1266_of_match);\n\nstatic const struct i2c_device_id adm1266_id[] = {\n\t{ \"adm1266\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adm1266_id);\n\nstatic struct i2c_driver adm1266_driver = {\n\t.driver = {\n\t\t   .name = \"adm1266\",\n\t\t   .of_match_table = adm1266_of_match,\n\t\t  },\n\t.probe = adm1266_probe,\n\t.id_table = adm1266_id,\n};\n\nmodule_i2c_driver(adm1266_driver);\n\nMODULE_AUTHOR(\"Alexandru Tachici <alexandru.tachici@analog.com>\");\nMODULE_DESCRIPTION(\"PMBus driver for Analog Devices ADM1266\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}