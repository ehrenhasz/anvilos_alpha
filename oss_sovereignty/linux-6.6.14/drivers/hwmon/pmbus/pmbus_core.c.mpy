{
  "module_name": "pmbus_core.c",
  "hash_id": "078d0be7ec85e79b4f7f730c6e07f87e9ee5ff5b49c5577f903abd97b0d75beb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/pmbus_core.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/pmbus.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/of.h>\n#include <linux/thermal.h>\n#include \"pmbus.h\"\n\n \n#define PMBUS_ATTR_ALLOC_SIZE\t32\n#define PMBUS_NAME_SIZE\t\t24\n\nstruct pmbus_sensor {\n\tstruct pmbus_sensor *next;\n\tchar name[PMBUS_NAME_SIZE];\t \n\tstruct device_attribute attribute;\n\tu8 page;\t\t \n\tu8 phase;\t\t \n\tu16 reg;\t\t \n\tenum pmbus_sensor_classes class;\t \n\tbool update;\t\t \n\tbool convert;\t\t \n\tint data;\t\t \n};\n#define to_pmbus_sensor(_attr) \\\n\tcontainer_of(_attr, struct pmbus_sensor, attribute)\n\nstruct pmbus_boolean {\n\tchar name[PMBUS_NAME_SIZE];\t \n\tstruct sensor_device_attribute attribute;\n\tstruct pmbus_sensor *s1;\n\tstruct pmbus_sensor *s2;\n};\n#define to_pmbus_boolean(_attr) \\\n\tcontainer_of(_attr, struct pmbus_boolean, attribute)\n\nstruct pmbus_label {\n\tchar name[PMBUS_NAME_SIZE];\t \n\tstruct device_attribute attribute;\n\tchar label[PMBUS_NAME_SIZE];\t \n};\n#define to_pmbus_label(_attr) \\\n\tcontainer_of(_attr, struct pmbus_label, attribute)\n\n \n\n#define PB_STATUS_MASK\t0xffff\n#define PB_REG_SHIFT\t16\n#define PB_REG_MASK\t0x3ff\n#define PB_PAGE_SHIFT\t26\n#define PB_PAGE_MASK\t0x3f\n\n#define pb_reg_to_index(page, reg, mask)\t(((page) << PB_PAGE_SHIFT) | \\\n\t\t\t\t\t\t ((reg) << PB_REG_SHIFT) | (mask))\n\n#define pb_index_to_page(index)\t\t\t(((index) >> PB_PAGE_SHIFT) & PB_PAGE_MASK)\n#define pb_index_to_reg(index)\t\t\t(((index) >> PB_REG_SHIFT) & PB_REG_MASK)\n#define pb_index_to_mask(index)\t\t\t((index) & PB_STATUS_MASK)\n\nstruct pmbus_data {\n\tstruct device *dev;\n\tstruct device *hwmon_dev;\n\tstruct regulator_dev **rdevs;\n\n\tu32 flags;\t\t \n\n\tint exponent[PMBUS_PAGES];\n\t\t\t\t \n\n\tconst struct pmbus_driver_info *info;\n\n\tint max_attributes;\n\tint num_attributes;\n\tstruct attribute_group group;\n\tconst struct attribute_group **groups;\n\tstruct dentry *debugfs;\t\t \n\n\tstruct pmbus_sensor *sensors;\n\n\tstruct mutex update_lock;\n\n\tbool has_status_word;\t\t \n\tint (*read_status)(struct i2c_client *client, int page);\n\n\ts16 currpage;\t \n\ts16 currphase;\t \n\n\tint vout_low[PMBUS_PAGES];\t \n\tint vout_high[PMBUS_PAGES];\t \n};\n\nstruct pmbus_debugfs_entry {\n\tstruct i2c_client *client;\n\tu8 page;\n\tu8 reg;\n};\n\nstatic const int pmbus_fan_rpm_mask[] = {\n\tPB_FAN_1_RPM,\n\tPB_FAN_2_RPM,\n\tPB_FAN_1_RPM,\n\tPB_FAN_2_RPM,\n};\n\nstatic const int pmbus_fan_config_registers[] = {\n\tPMBUS_FAN_CONFIG_12,\n\tPMBUS_FAN_CONFIG_12,\n\tPMBUS_FAN_CONFIG_34,\n\tPMBUS_FAN_CONFIG_34\n};\n\nstatic const int pmbus_fan_command_registers[] = {\n\tPMBUS_FAN_COMMAND_1,\n\tPMBUS_FAN_COMMAND_2,\n\tPMBUS_FAN_COMMAND_3,\n\tPMBUS_FAN_COMMAND_4,\n};\n\nvoid pmbus_clear_cache(struct i2c_client *client)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tstruct pmbus_sensor *sensor;\n\n\tfor (sensor = data->sensors; sensor; sensor = sensor->next)\n\t\tsensor->data = -ENODATA;\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_clear_cache, PMBUS);\n\nvoid pmbus_set_update(struct i2c_client *client, u8 reg, bool update)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tstruct pmbus_sensor *sensor;\n\n\tfor (sensor = data->sensors; sensor; sensor = sensor->next)\n\t\tif (sensor->reg == reg)\n\t\t\tsensor->update = update;\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_set_update, PMBUS);\n\nint pmbus_set_page(struct i2c_client *client, int page, int phase)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tint rv;\n\n\tif (page < 0)\n\t\treturn 0;\n\n\tif (!(data->info->func[page] & PMBUS_PAGE_VIRTUAL) &&\n\t    data->info->pages > 1 && page != data->currpage) {\n\t\trv = i2c_smbus_write_byte_data(client, PMBUS_PAGE, page);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\n\t\trv = i2c_smbus_read_byte_data(client, PMBUS_PAGE);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\n\t\tif (rv != page)\n\t\t\treturn -EIO;\n\t}\n\tdata->currpage = page;\n\n\tif (data->info->phases[page] && data->currphase != phase &&\n\t    !(data->info->func[page] & PMBUS_PHASE_VIRTUAL)) {\n\t\trv = i2c_smbus_write_byte_data(client, PMBUS_PHASE,\n\t\t\t\t\t       phase);\n\t\tif (rv)\n\t\t\treturn rv;\n\t}\n\tdata->currphase = phase;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_set_page, PMBUS);\n\nint pmbus_write_byte(struct i2c_client *client, int page, u8 value)\n{\n\tint rv;\n\n\trv = pmbus_set_page(client, page, 0xff);\n\tif (rv < 0)\n\t\treturn rv;\n\n\treturn i2c_smbus_write_byte(client, value);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_write_byte, PMBUS);\n\n \nstatic int _pmbus_write_byte(struct i2c_client *client, int page, u8 value)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tconst struct pmbus_driver_info *info = data->info;\n\tint status;\n\n\tif (info->write_byte) {\n\t\tstatus = info->write_byte(client, page, value);\n\t\tif (status != -ENODATA)\n\t\t\treturn status;\n\t}\n\treturn pmbus_write_byte(client, page, value);\n}\n\nint pmbus_write_word_data(struct i2c_client *client, int page, u8 reg,\n\t\t\t  u16 word)\n{\n\tint rv;\n\n\trv = pmbus_set_page(client, page, 0xff);\n\tif (rv < 0)\n\t\treturn rv;\n\n\treturn i2c_smbus_write_word_data(client, reg, word);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_write_word_data, PMBUS);\n\n\nstatic int pmbus_write_virt_reg(struct i2c_client *client, int page, int reg,\n\t\t\t\tu16 word)\n{\n\tint bit;\n\tint id;\n\tint rv;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_FAN_TARGET_1 ... PMBUS_VIRT_FAN_TARGET_4:\n\t\tid = reg - PMBUS_VIRT_FAN_TARGET_1;\n\t\tbit = pmbus_fan_rpm_mask[id];\n\t\trv = pmbus_update_fan(client, page, id, bit, bit, word);\n\t\tbreak;\n\tdefault:\n\t\trv = -ENXIO;\n\t\tbreak;\n\t}\n\n\treturn rv;\n}\n\n \nstatic int _pmbus_write_word_data(struct i2c_client *client, int page, int reg,\n\t\t\t\t  u16 word)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tconst struct pmbus_driver_info *info = data->info;\n\tint status;\n\n\tif (info->write_word_data) {\n\t\tstatus = info->write_word_data(client, page, reg, word);\n\t\tif (status != -ENODATA)\n\t\t\treturn status;\n\t}\n\n\tif (reg >= PMBUS_VIRT_BASE)\n\t\treturn pmbus_write_virt_reg(client, page, reg, word);\n\n\treturn pmbus_write_word_data(client, page, reg, word);\n}\n\n \nstatic int _pmbus_write_byte_data(struct i2c_client *client, int page, int reg, u8 value)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tconst struct pmbus_driver_info *info = data->info;\n\tint status;\n\n\tif (info->write_byte_data) {\n\t\tstatus = info->write_byte_data(client, page, reg, value);\n\t\tif (status != -ENODATA)\n\t\t\treturn status;\n\t}\n\treturn pmbus_write_byte_data(client, page, reg, value);\n}\n\n \nstatic int _pmbus_read_byte_data(struct i2c_client *client, int page, int reg)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tconst struct pmbus_driver_info *info = data->info;\n\tint status;\n\n\tif (info->read_byte_data) {\n\t\tstatus = info->read_byte_data(client, page, reg);\n\t\tif (status != -ENODATA)\n\t\t\treturn status;\n\t}\n\treturn pmbus_read_byte_data(client, page, reg);\n}\n\nint pmbus_update_fan(struct i2c_client *client, int page, int id,\n\t\t     u8 config, u8 mask, u16 command)\n{\n\tint from;\n\tint rv;\n\tu8 to;\n\n\tfrom = _pmbus_read_byte_data(client, page,\n\t\t\t\t    pmbus_fan_config_registers[id]);\n\tif (from < 0)\n\t\treturn from;\n\n\tto = (from & ~mask) | (config & mask);\n\tif (to != from) {\n\t\trv = _pmbus_write_byte_data(client, page,\n\t\t\t\t\t   pmbus_fan_config_registers[id], to);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t}\n\n\treturn _pmbus_write_word_data(client, page,\n\t\t\t\t      pmbus_fan_command_registers[id], command);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_update_fan, PMBUS);\n\nint pmbus_read_word_data(struct i2c_client *client, int page, int phase, u8 reg)\n{\n\tint rv;\n\n\trv = pmbus_set_page(client, page, phase);\n\tif (rv < 0)\n\t\treturn rv;\n\n\treturn i2c_smbus_read_word_data(client, reg);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_read_word_data, PMBUS);\n\nstatic int pmbus_read_virt_reg(struct i2c_client *client, int page, int reg)\n{\n\tint rv;\n\tint id;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_FAN_TARGET_1 ... PMBUS_VIRT_FAN_TARGET_4:\n\t\tid = reg - PMBUS_VIRT_FAN_TARGET_1;\n\t\trv = pmbus_get_fan_rate_device(client, page, id, rpm);\n\t\tbreak;\n\tdefault:\n\t\trv = -ENXIO;\n\t\tbreak;\n\t}\n\n\treturn rv;\n}\n\n \nstatic int _pmbus_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t int phase, int reg)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tconst struct pmbus_driver_info *info = data->info;\n\tint status;\n\n\tif (info->read_word_data) {\n\t\tstatus = info->read_word_data(client, page, phase, reg);\n\t\tif (status != -ENODATA)\n\t\t\treturn status;\n\t}\n\n\tif (reg >= PMBUS_VIRT_BASE)\n\t\treturn pmbus_read_virt_reg(client, page, reg);\n\n\treturn pmbus_read_word_data(client, page, phase, reg);\n}\n\n \nstatic int __pmbus_read_word_data(struct i2c_client *client, int page, int reg)\n{\n\treturn _pmbus_read_word_data(client, page, 0xff, reg);\n}\n\nint pmbus_read_byte_data(struct i2c_client *client, int page, u8 reg)\n{\n\tint rv;\n\n\trv = pmbus_set_page(client, page, 0xff);\n\tif (rv < 0)\n\t\treturn rv;\n\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_read_byte_data, PMBUS);\n\nint pmbus_write_byte_data(struct i2c_client *client, int page, u8 reg, u8 value)\n{\n\tint rv;\n\n\trv = pmbus_set_page(client, page, 0xff);\n\tif (rv < 0)\n\t\treturn rv;\n\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_write_byte_data, PMBUS);\n\nint pmbus_update_byte_data(struct i2c_client *client, int page, u8 reg,\n\t\t\t   u8 mask, u8 value)\n{\n\tunsigned int tmp;\n\tint rv;\n\n\trv = _pmbus_read_byte_data(client, page, reg);\n\tif (rv < 0)\n\t\treturn rv;\n\n\ttmp = (rv & ~mask) | (value & mask);\n\n\tif (tmp != rv)\n\t\trv = _pmbus_write_byte_data(client, page, reg, tmp);\n\n\treturn rv;\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_update_byte_data, PMBUS);\n\nstatic int pmbus_read_block_data(struct i2c_client *client, int page, u8 reg,\n\t\t\t\t char *data_buf)\n{\n\tint rv;\n\n\trv = pmbus_set_page(client, page, 0xff);\n\tif (rv < 0)\n\t\treturn rv;\n\n\treturn i2c_smbus_read_block_data(client, reg, data_buf);\n}\n\nstatic struct pmbus_sensor *pmbus_find_sensor(struct pmbus_data *data, int page,\n\t\t\t\t\t      int reg)\n{\n\tstruct pmbus_sensor *sensor;\n\n\tfor (sensor = data->sensors; sensor; sensor = sensor->next) {\n\t\tif (sensor->page == page && sensor->reg == reg)\n\t\t\treturn sensor;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int pmbus_get_fan_rate(struct i2c_client *client, int page, int id,\n\t\t\t      enum pmbus_fan_mode mode,\n\t\t\t      bool from_cache)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tbool want_rpm, have_rpm;\n\tstruct pmbus_sensor *s;\n\tint config;\n\tint reg;\n\n\twant_rpm = (mode == rpm);\n\n\tif (from_cache) {\n\t\treg = want_rpm ? PMBUS_VIRT_FAN_TARGET_1 : PMBUS_VIRT_PWM_1;\n\t\ts = pmbus_find_sensor(data, page, reg + id);\n\t\tif (IS_ERR(s))\n\t\t\treturn PTR_ERR(s);\n\n\t\treturn s->data;\n\t}\n\n\tconfig = _pmbus_read_byte_data(client, page,\n\t\t\t\t      pmbus_fan_config_registers[id]);\n\tif (config < 0)\n\t\treturn config;\n\n\thave_rpm = !!(config & pmbus_fan_rpm_mask[id]);\n\tif (want_rpm == have_rpm)\n\t\treturn pmbus_read_word_data(client, page, 0xff,\n\t\t\t\t\t    pmbus_fan_command_registers[id]);\n\n\t \n\treturn 0;\n}\n\nint pmbus_get_fan_rate_device(struct i2c_client *client, int page, int id,\n\t\t\t      enum pmbus_fan_mode mode)\n{\n\treturn pmbus_get_fan_rate(client, page, id, mode, false);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_get_fan_rate_device, PMBUS);\n\nint pmbus_get_fan_rate_cached(struct i2c_client *client, int page, int id,\n\t\t\t      enum pmbus_fan_mode mode)\n{\n\treturn pmbus_get_fan_rate(client, page, id, mode, true);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_get_fan_rate_cached, PMBUS);\n\nstatic void pmbus_clear_fault_page(struct i2c_client *client, int page)\n{\n\t_pmbus_write_byte(client, page, PMBUS_CLEAR_FAULTS);\n}\n\nvoid pmbus_clear_faults(struct i2c_client *client)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tint i;\n\n\tfor (i = 0; i < data->info->pages; i++)\n\t\tpmbus_clear_fault_page(client, i);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_clear_faults, PMBUS);\n\nstatic int pmbus_check_status_cml(struct i2c_client *client)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tint status, status2;\n\n\tstatus = data->read_status(client, -1);\n\tif (status < 0 || (status & PB_STATUS_CML)) {\n\t\tstatus2 = _pmbus_read_byte_data(client, -1, PMBUS_STATUS_CML);\n\t\tif (status2 < 0 || (status2 & PB_CML_FAULT_INVALID_COMMAND))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic bool pmbus_check_register(struct i2c_client *client,\n\t\t\t\t int (*func)(struct i2c_client *client,\n\t\t\t\t\t     int page, int reg),\n\t\t\t\t int page, int reg)\n{\n\tint rv;\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\n\trv = func(client, page, reg);\n\tif (rv >= 0 && !(data->flags & PMBUS_SKIP_STATUS_CHECK))\n\t\trv = pmbus_check_status_cml(client);\n\tif (rv < 0 && (data->flags & PMBUS_READ_STATUS_AFTER_FAILED_CHECK))\n\t\tdata->read_status(client, -1);\n\tif (reg < PMBUS_VIRT_BASE)\n\t\tpmbus_clear_fault_page(client, -1);\n\treturn rv >= 0;\n}\n\nstatic bool pmbus_check_status_register(struct i2c_client *client, int page)\n{\n\tint status;\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\n\tstatus = data->read_status(client, page);\n\tif (status >= 0 && !(data->flags & PMBUS_SKIP_STATUS_CHECK) &&\n\t    (status & PB_STATUS_CML)) {\n\t\tstatus = _pmbus_read_byte_data(client, -1, PMBUS_STATUS_CML);\n\t\tif (status < 0 || (status & PB_CML_FAULT_INVALID_COMMAND))\n\t\t\tstatus = -EIO;\n\t}\n\n\tpmbus_clear_fault_page(client, -1);\n\treturn status >= 0;\n}\n\nbool pmbus_check_byte_register(struct i2c_client *client, int page, int reg)\n{\n\treturn pmbus_check_register(client, _pmbus_read_byte_data, page, reg);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_check_byte_register, PMBUS);\n\nbool pmbus_check_word_register(struct i2c_client *client, int page, int reg)\n{\n\treturn pmbus_check_register(client, __pmbus_read_word_data, page, reg);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_check_word_register, PMBUS);\n\nstatic bool __maybe_unused pmbus_check_block_register(struct i2c_client *client,\n\t\t\t\t\t\t      int page, int reg)\n{\n\tint rv;\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tchar data_buf[I2C_SMBUS_BLOCK_MAX + 2];\n\n\trv = pmbus_read_block_data(client, page, reg, data_buf);\n\tif (rv >= 0 && !(data->flags & PMBUS_SKIP_STATUS_CHECK))\n\t\trv = pmbus_check_status_cml(client);\n\tif (rv < 0 && (data->flags & PMBUS_READ_STATUS_AFTER_FAILED_CHECK))\n\t\tdata->read_status(client, -1);\n\tpmbus_clear_fault_page(client, -1);\n\treturn rv >= 0;\n}\n\nconst struct pmbus_driver_info *pmbus_get_driver_info(struct i2c_client *client)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\n\treturn data->info;\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_get_driver_info, PMBUS);\n\nstatic int pmbus_get_status(struct i2c_client *client, int page, int reg)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tint status;\n\n\tswitch (reg) {\n\tcase PMBUS_STATUS_WORD:\n\t\tstatus = data->read_status(client, page);\n\t\tbreak;\n\tdefault:\n\t\tstatus = _pmbus_read_byte_data(client, page, reg);\n\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tpmbus_clear_faults(client);\n\treturn status;\n}\n\nstatic void pmbus_update_sensor_data(struct i2c_client *client, struct pmbus_sensor *sensor)\n{\n\tif (sensor->data < 0 || sensor->update)\n\t\tsensor->data = _pmbus_read_word_data(client, sensor->page,\n\t\t\t\t\t\t     sensor->phase, sensor->reg);\n}\n\n \nstatic long pmbus_reg2data_ieee754(struct pmbus_data *data,\n\t\t\t\t   struct pmbus_sensor *sensor)\n{\n\tint exponent;\n\tbool sign;\n\tlong val;\n\n\t \n\tsign = sensor->data & 0x8000;\n\texponent = (sensor->data >> 10) & 0x1f;\n\tval = sensor->data & 0x3ff;\n\n\tif (exponent == 0) {\t\t\t \n\t\texponent = -(14 + 10);\n\t} else if (exponent ==  0x1f) {\t\t \n\t\texponent = 0;\n\t\tval = 65504;\n\t} else {\n\t\texponent -= (15 + 10);\t\t \n\t\tval |= 0x400;\n\t}\n\n\t \n\tif (sensor->class != PSC_FAN)\n\t\tval = val * 1000L;\n\n\t \n\tif (sensor->class == PSC_POWER)\n\t\tval = val * 1000L;\n\n\tif (exponent >= 0)\n\t\tval <<= exponent;\n\telse\n\t\tval >>= -exponent;\n\n\tif (sign)\n\t\tval = -val;\n\n\treturn val;\n}\n\n \nstatic s64 pmbus_reg2data_linear(struct pmbus_data *data,\n\t\t\t\t struct pmbus_sensor *sensor)\n{\n\ts16 exponent;\n\ts32 mantissa;\n\ts64 val;\n\n\tif (sensor->class == PSC_VOLTAGE_OUT) {\t \n\t\texponent = data->exponent[sensor->page];\n\t\tmantissa = (u16) sensor->data;\n\t} else {\t\t\t\t \n\t\texponent = ((s16)sensor->data) >> 11;\n\t\tmantissa = ((s16)((sensor->data & 0x7ff) << 5)) >> 5;\n\t}\n\n\tval = mantissa;\n\n\t \n\tif (sensor->class != PSC_FAN)\n\t\tval = val * 1000LL;\n\n\t \n\tif (sensor->class == PSC_POWER)\n\t\tval = val * 1000LL;\n\n\tif (exponent >= 0)\n\t\tval <<= exponent;\n\telse\n\t\tval >>= -exponent;\n\n\treturn val;\n}\n\n \nstatic s64 pmbus_reg2data_direct(struct pmbus_data *data,\n\t\t\t\t struct pmbus_sensor *sensor)\n{\n\ts64 b, val = (s16)sensor->data;\n\ts32 m, R;\n\n\tm = data->info->m[sensor->class];\n\tb = data->info->b[sensor->class];\n\tR = data->info->R[sensor->class];\n\n\tif (m == 0)\n\t\treturn 0;\n\n\t \n\tR = -R;\n\t \n\tif (!(sensor->class == PSC_FAN || sensor->class == PSC_PWM)) {\n\t\tR += 3;\n\t\tb *= 1000;\n\t}\n\n\t \n\tif (sensor->class == PSC_POWER) {\n\t\tR += 3;\n\t\tb *= 1000;\n\t}\n\n\twhile (R > 0) {\n\t\tval *= 10;\n\t\tR--;\n\t}\n\twhile (R < 0) {\n\t\tval = div_s64(val + 5LL, 10L);   \n\t\tR++;\n\t}\n\n\tval = div_s64(val - b, m);\n\treturn val;\n}\n\n \nstatic s64 pmbus_reg2data_vid(struct pmbus_data *data,\n\t\t\t      struct pmbus_sensor *sensor)\n{\n\tlong val = sensor->data;\n\tlong rv = 0;\n\n\tswitch (data->info->vrm_version[sensor->page]) {\n\tcase vr11:\n\t\tif (val >= 0x02 && val <= 0xb2)\n\t\t\trv = DIV_ROUND_CLOSEST(160000 - (val - 2) * 625, 100);\n\t\tbreak;\n\tcase vr12:\n\t\tif (val >= 0x01)\n\t\t\trv = 250 + (val - 1) * 5;\n\t\tbreak;\n\tcase vr13:\n\t\tif (val >= 0x01)\n\t\t\trv = 500 + (val - 1) * 10;\n\t\tbreak;\n\tcase imvp9:\n\t\tif (val >= 0x01)\n\t\t\trv = 200 + (val - 1) * 10;\n\t\tbreak;\n\tcase amd625mv:\n\t\tif (val >= 0x0 && val <= 0xd8)\n\t\t\trv = DIV_ROUND_CLOSEST(155000 - val * 625, 100);\n\t\tbreak;\n\t}\n\treturn rv;\n}\n\nstatic s64 pmbus_reg2data(struct pmbus_data *data, struct pmbus_sensor *sensor)\n{\n\ts64 val;\n\n\tif (!sensor->convert)\n\t\treturn sensor->data;\n\n\tswitch (data->info->format[sensor->class]) {\n\tcase direct:\n\t\tval = pmbus_reg2data_direct(data, sensor);\n\t\tbreak;\n\tcase vid:\n\t\tval = pmbus_reg2data_vid(data, sensor);\n\t\tbreak;\n\tcase ieee754:\n\t\tval = pmbus_reg2data_ieee754(data, sensor);\n\t\tbreak;\n\tcase linear:\n\tdefault:\n\t\tval = pmbus_reg2data_linear(data, sensor);\n\t\tbreak;\n\t}\n\treturn val;\n}\n\n#define MAX_IEEE_MANTISSA\t(0x7ff * 1000)\n#define MIN_IEEE_MANTISSA\t(0x400 * 1000)\n\nstatic u16 pmbus_data2reg_ieee754(struct pmbus_data *data,\n\t\t\t\t  struct pmbus_sensor *sensor, long val)\n{\n\tu16 exponent = (15 + 10);\n\tlong mantissa;\n\tu16 sign = 0;\n\n\t \n\tif (val == 0)\n\t\treturn 0;\n\n\tif (val < 0) {\n\t\tsign = 0x8000;\n\t\tval = -val;\n\t}\n\n\t \n\tif (sensor->class == PSC_POWER)\n\t\tval = DIV_ROUND_CLOSEST(val, 1000L);\n\n\t \n\tif (sensor->class == PSC_FAN)\n\t\tval = val * 1000;\n\n\t \n\twhile (val > MAX_IEEE_MANTISSA && exponent < 30) {\n\t\texponent++;\n\t\tval >>= 1;\n\t}\n\t \n\twhile (val < MIN_IEEE_MANTISSA && exponent > 1) {\n\t\texponent--;\n\t\tval <<= 1;\n\t}\n\n\t \n\tmantissa = DIV_ROUND_CLOSEST(val, 1000);\n\n\t \n\tif (mantissa > 0x7ff)\n\t\tmantissa = 0x7ff;\n\telse if (mantissa < 0x400)\n\t\tmantissa = 0x400;\n\n\t \n\treturn sign | (mantissa & 0x3ff) | ((exponent << 10) & 0x7c00);\n}\n\n#define MAX_LIN_MANTISSA\t(1023 * 1000)\n#define MIN_LIN_MANTISSA\t(511 * 1000)\n\nstatic u16 pmbus_data2reg_linear(struct pmbus_data *data,\n\t\t\t\t struct pmbus_sensor *sensor, s64 val)\n{\n\ts16 exponent = 0, mantissa;\n\tbool negative = false;\n\n\t \n\tif (val == 0)\n\t\treturn 0;\n\n\tif (sensor->class == PSC_VOLTAGE_OUT) {\n\t\t \n\t\tif (val < 0)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (data->exponent[sensor->page] < 0)\n\t\t\tval <<= -data->exponent[sensor->page];\n\t\telse\n\t\t\tval >>= data->exponent[sensor->page];\n\t\tval = DIV_ROUND_CLOSEST_ULL(val, 1000);\n\t\treturn clamp_val(val, 0, 0xffff);\n\t}\n\n\tif (val < 0) {\n\t\tnegative = true;\n\t\tval = -val;\n\t}\n\n\t \n\tif (sensor->class == PSC_POWER)\n\t\tval = DIV_ROUND_CLOSEST_ULL(val, 1000);\n\n\t \n\tif (sensor->class == PSC_FAN)\n\t\tval = val * 1000LL;\n\n\t \n\twhile (val >= MAX_LIN_MANTISSA && exponent < 15) {\n\t\texponent++;\n\t\tval >>= 1;\n\t}\n\t \n\twhile (val < MIN_LIN_MANTISSA && exponent > -15) {\n\t\texponent--;\n\t\tval <<= 1;\n\t}\n\n\t \n\tmantissa = clamp_val(DIV_ROUND_CLOSEST_ULL(val, 1000), 0, 0x3ff);\n\n\t \n\tif (negative)\n\t\tmantissa = -mantissa;\n\n\t \n\treturn (mantissa & 0x7ff) | ((exponent << 11) & 0xf800);\n}\n\nstatic u16 pmbus_data2reg_direct(struct pmbus_data *data,\n\t\t\t\t struct pmbus_sensor *sensor, s64 val)\n{\n\ts64 b;\n\ts32 m, R;\n\n\tm = data->info->m[sensor->class];\n\tb = data->info->b[sensor->class];\n\tR = data->info->R[sensor->class];\n\n\t \n\tif (sensor->class == PSC_POWER) {\n\t\tR -= 3;\n\t\tb *= 1000;\n\t}\n\n\t \n\tif (!(sensor->class == PSC_FAN || sensor->class == PSC_PWM)) {\n\t\tR -= 3;\t\t \n\t\tb *= 1000;\n\t}\n\tval = val * m + b;\n\n\twhile (R > 0) {\n\t\tval *= 10;\n\t\tR--;\n\t}\n\twhile (R < 0) {\n\t\tval = div_s64(val + 5LL, 10L);   \n\t\tR++;\n\t}\n\n\treturn (u16)clamp_val(val, S16_MIN, S16_MAX);\n}\n\nstatic u16 pmbus_data2reg_vid(struct pmbus_data *data,\n\t\t\t      struct pmbus_sensor *sensor, s64 val)\n{\n\tval = clamp_val(val, 500, 1600);\n\n\treturn 2 + DIV_ROUND_CLOSEST_ULL((1600LL - val) * 100LL, 625);\n}\n\nstatic u16 pmbus_data2reg(struct pmbus_data *data,\n\t\t\t  struct pmbus_sensor *sensor, s64 val)\n{\n\tu16 regval;\n\n\tif (!sensor->convert)\n\t\treturn val;\n\n\tswitch (data->info->format[sensor->class]) {\n\tcase direct:\n\t\tregval = pmbus_data2reg_direct(data, sensor, val);\n\t\tbreak;\n\tcase vid:\n\t\tregval = pmbus_data2reg_vid(data, sensor, val);\n\t\tbreak;\n\tcase ieee754:\n\t\tregval = pmbus_data2reg_ieee754(data, sensor, val);\n\t\tbreak;\n\tcase linear:\n\tdefault:\n\t\tregval = pmbus_data2reg_linear(data, sensor, val);\n\t\tbreak;\n\t}\n\treturn regval;\n}\n\n \nstatic int pmbus_get_boolean(struct i2c_client *client, struct pmbus_boolean *b,\n\t\t\t     int index)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tstruct pmbus_sensor *s1 = b->s1;\n\tstruct pmbus_sensor *s2 = b->s2;\n\tu16 mask = pb_index_to_mask(index);\n\tu8 page = pb_index_to_page(index);\n\tu16 reg = pb_index_to_reg(index);\n\tint ret, status;\n\tu16 regval;\n\n\tmutex_lock(&data->update_lock);\n\tstatus = pmbus_get_status(client, page, reg);\n\tif (status < 0) {\n\t\tret = status;\n\t\tgoto unlock;\n\t}\n\n\tif (s1)\n\t\tpmbus_update_sensor_data(client, s1);\n\tif (s2)\n\t\tpmbus_update_sensor_data(client, s2);\n\n\tregval = status & mask;\n\tif (regval) {\n\t\tret = _pmbus_write_byte_data(client, page, reg, regval);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\tif (s1 && s2) {\n\t\ts64 v1, v2;\n\n\t\tif (s1->data < 0) {\n\t\t\tret = s1->data;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (s2->data < 0) {\n\t\t\tret = s2->data;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tv1 = pmbus_reg2data(data, s1);\n\t\tv2 = pmbus_reg2data(data, s2);\n\t\tret = !!(regval && v1 >= v2);\n\t} else {\n\t\tret = !!regval;\n\t}\nunlock:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t pmbus_show_boolean(struct device *dev,\n\t\t\t\t  struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct pmbus_boolean *boolean = to_pmbus_boolean(attr);\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tint val;\n\n\tval = pmbus_get_boolean(client, boolean, attr->index);\n\tif (val < 0)\n\t\treturn val;\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t pmbus_show_sensor(struct device *dev,\n\t\t\t\t struct device_attribute *devattr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct pmbus_sensor *sensor = to_pmbus_sensor(devattr);\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tssize_t ret;\n\n\tmutex_lock(&data->update_lock);\n\tpmbus_update_sensor_data(client, sensor);\n\tif (sensor->data < 0)\n\t\tret = sensor->data;\n\telse\n\t\tret = sysfs_emit(buf, \"%lld\\n\", pmbus_reg2data(data, sensor));\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic ssize_t pmbus_set_sensor(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tstruct pmbus_sensor *sensor = to_pmbus_sensor(devattr);\n\tssize_t rv = count;\n\ts64 val;\n\tint ret;\n\tu16 regval;\n\n\tif (kstrtos64(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tregval = pmbus_data2reg(data, sensor, val);\n\tret = _pmbus_write_word_data(client, sensor->page, sensor->reg, regval);\n\tif (ret < 0)\n\t\trv = ret;\n\telse\n\t\tsensor->data = -ENODATA;\n\tmutex_unlock(&data->update_lock);\n\treturn rv;\n}\n\nstatic ssize_t pmbus_show_label(struct device *dev,\n\t\t\t\tstruct device_attribute *da, char *buf)\n{\n\tstruct pmbus_label *label = to_pmbus_label(da);\n\n\treturn sysfs_emit(buf, \"%s\\n\", label->label);\n}\n\nstatic int pmbus_add_attribute(struct pmbus_data *data, struct attribute *attr)\n{\n\tif (data->num_attributes >= data->max_attributes - 1) {\n\t\tint new_max_attrs = data->max_attributes + PMBUS_ATTR_ALLOC_SIZE;\n\t\tvoid *new_attrs = devm_krealloc_array(data->dev, data->group.attrs,\n\t\t\t\t\t\t      new_max_attrs, sizeof(void *),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!new_attrs)\n\t\t\treturn -ENOMEM;\n\t\tdata->group.attrs = new_attrs;\n\t\tdata->max_attributes = new_max_attrs;\n\t}\n\n\tdata->group.attrs[data->num_attributes++] = attr;\n\tdata->group.attrs[data->num_attributes] = NULL;\n\treturn 0;\n}\n\nstatic void pmbus_dev_attr_init(struct device_attribute *dev_attr,\n\t\t\t\tconst char *name,\n\t\t\t\tumode_t mode,\n\t\t\t\tssize_t (*show)(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf),\n\t\t\t\tssize_t (*store)(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t const char *buf, size_t count))\n{\n\tsysfs_attr_init(&dev_attr->attr);\n\tdev_attr->attr.name = name;\n\tdev_attr->attr.mode = mode;\n\tdev_attr->show = show;\n\tdev_attr->store = store;\n}\n\nstatic void pmbus_attr_init(struct sensor_device_attribute *a,\n\t\t\t    const char *name,\n\t\t\t    umode_t mode,\n\t\t\t    ssize_t (*show)(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf),\n\t\t\t    ssize_t (*store)(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count),\n\t\t\t    int idx)\n{\n\tpmbus_dev_attr_init(&a->dev_attr, name, mode, show, store);\n\ta->index = idx;\n}\n\nstatic int pmbus_add_boolean(struct pmbus_data *data,\n\t\t\t     const char *name, const char *type, int seq,\n\t\t\t     struct pmbus_sensor *s1,\n\t\t\t     struct pmbus_sensor *s2,\n\t\t\t     u8 page, u16 reg, u16 mask)\n{\n\tstruct pmbus_boolean *boolean;\n\tstruct sensor_device_attribute *a;\n\n\tif (WARN((s1 && !s2) || (!s1 && s2), \"Bad s1/s2 parameters\\n\"))\n\t\treturn -EINVAL;\n\n\tboolean = devm_kzalloc(data->dev, sizeof(*boolean), GFP_KERNEL);\n\tif (!boolean)\n\t\treturn -ENOMEM;\n\n\ta = &boolean->attribute;\n\n\tsnprintf(boolean->name, sizeof(boolean->name), \"%s%d_%s\",\n\t\t name, seq, type);\n\tboolean->s1 = s1;\n\tboolean->s2 = s2;\n\tpmbus_attr_init(a, boolean->name, 0444, pmbus_show_boolean, NULL,\n\t\t\tpb_reg_to_index(page, reg, mask));\n\n\treturn pmbus_add_attribute(data, &a->dev_attr.attr);\n}\n\n \nstruct pmbus_thermal_data {\n\tstruct pmbus_data *pmbus_data;\n\tstruct pmbus_sensor *sensor;\n};\n\nstatic int pmbus_thermal_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct pmbus_thermal_data *tdata = thermal_zone_device_priv(tz);\n\tstruct pmbus_sensor *sensor = tdata->sensor;\n\tstruct pmbus_data *pmbus_data = tdata->pmbus_data;\n\tstruct i2c_client *client = to_i2c_client(pmbus_data->dev);\n\tstruct device *dev = pmbus_data->hwmon_dev;\n\tint ret = 0;\n\n\tif (!dev) {\n\t\t \n\t\t*temp = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&pmbus_data->update_lock);\n\tpmbus_update_sensor_data(client, sensor);\n\tif (sensor->data < 0)\n\t\tret = sensor->data;\n\telse\n\t\t*temp = (int)pmbus_reg2data(pmbus_data, sensor);\n\tmutex_unlock(&pmbus_data->update_lock);\n\n\treturn ret;\n}\n\nstatic const struct thermal_zone_device_ops pmbus_thermal_ops = {\n\t.get_temp = pmbus_thermal_get_temp,\n};\n\nstatic int pmbus_thermal_add_sensor(struct pmbus_data *pmbus_data,\n\t\t\t\t    struct pmbus_sensor *sensor, int index)\n{\n\tstruct device *dev = pmbus_data->dev;\n\tstruct pmbus_thermal_data *tdata;\n\tstruct thermal_zone_device *tzd;\n\n\ttdata = devm_kzalloc(dev, sizeof(*tdata), GFP_KERNEL);\n\tif (!tdata)\n\t\treturn -ENOMEM;\n\n\ttdata->sensor = sensor;\n\ttdata->pmbus_data = pmbus_data;\n\n\ttzd = devm_thermal_of_zone_register(dev, index, tdata,\n\t\t\t\t\t    &pmbus_thermal_ops);\n\t \n\tif (IS_ERR(tzd) && (PTR_ERR(tzd) != -ENODEV))\n\t\treturn PTR_ERR(tzd);\n\n\treturn 0;\n}\n\nstatic struct pmbus_sensor *pmbus_add_sensor(struct pmbus_data *data,\n\t\t\t\t\t     const char *name, const char *type,\n\t\t\t\t\t     int seq, int page, int phase,\n\t\t\t\t\t     int reg,\n\t\t\t\t\t     enum pmbus_sensor_classes class,\n\t\t\t\t\t     bool update, bool readonly,\n\t\t\t\t\t     bool convert)\n{\n\tstruct pmbus_sensor *sensor;\n\tstruct device_attribute *a;\n\n\tsensor = devm_kzalloc(data->dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn NULL;\n\ta = &sensor->attribute;\n\n\tif (type)\n\t\tsnprintf(sensor->name, sizeof(sensor->name), \"%s%d_%s\",\n\t\t\t name, seq, type);\n\telse\n\t\tsnprintf(sensor->name, sizeof(sensor->name), \"%s%d\",\n\t\t\t name, seq);\n\n\tif (data->flags & PMBUS_WRITE_PROTECTED)\n\t\treadonly = true;\n\n\tsensor->page = page;\n\tsensor->phase = phase;\n\tsensor->reg = reg;\n\tsensor->class = class;\n\tsensor->update = update;\n\tsensor->convert = convert;\n\tsensor->data = -ENODATA;\n\tpmbus_dev_attr_init(a, sensor->name,\n\t\t\t    readonly ? 0444 : 0644,\n\t\t\t    pmbus_show_sensor, pmbus_set_sensor);\n\n\tif (pmbus_add_attribute(data, &a->attr))\n\t\treturn NULL;\n\n\tsensor->next = data->sensors;\n\tdata->sensors = sensor;\n\n\t \n\tif (class == PSC_TEMPERATURE && strcmp(type, \"input\") == 0)\n\t\tpmbus_thermal_add_sensor(data, sensor, seq);\n\n\treturn sensor;\n}\n\nstatic int pmbus_add_label(struct pmbus_data *data,\n\t\t\t   const char *name, int seq,\n\t\t\t   const char *lstring, int index, int phase)\n{\n\tstruct pmbus_label *label;\n\tstruct device_attribute *a;\n\n\tlabel = devm_kzalloc(data->dev, sizeof(*label), GFP_KERNEL);\n\tif (!label)\n\t\treturn -ENOMEM;\n\n\ta = &label->attribute;\n\n\tsnprintf(label->name, sizeof(label->name), \"%s%d_label\", name, seq);\n\tif (!index) {\n\t\tif (phase == 0xff)\n\t\t\tstrncpy(label->label, lstring,\n\t\t\t\tsizeof(label->label) - 1);\n\t\telse\n\t\t\tsnprintf(label->label, sizeof(label->label), \"%s.%d\",\n\t\t\t\t lstring, phase);\n\t} else {\n\t\tif (phase == 0xff)\n\t\t\tsnprintf(label->label, sizeof(label->label), \"%s%d\",\n\t\t\t\t lstring, index);\n\t\telse\n\t\t\tsnprintf(label->label, sizeof(label->label), \"%s%d.%d\",\n\t\t\t\t lstring, index, phase);\n\t}\n\n\tpmbus_dev_attr_init(a, label->name, 0444, pmbus_show_label, NULL);\n\treturn pmbus_add_attribute(data, &a->attr);\n}\n\n \n\n \nstruct pmbus_limit_attr {\n\tu16 reg;\t\t \n\tu16 sbit;\t\t \n\tbool update;\t\t \n\tbool low;\t\t \n\tconst char *attr;\t \n\tconst char *alarm;\t \n};\n\n \nstruct pmbus_sensor_attr {\n\tu16 reg;\t\t\t \n\tu16 gbit;\t\t\t \n\tu8 nlimit;\t\t\t \n\tenum pmbus_sensor_classes class; \n\tconst char *label;\t\t \n\tbool paged;\t\t\t \n\tbool update;\t\t\t \n\tbool compare;\t\t\t \n\tu32 func;\t\t\t \n\tu32 sfunc;\t\t\t \n\tint sreg;\t\t\t \n\tconst struct pmbus_limit_attr *limit; \n};\n\n \nstatic int pmbus_add_limit_attrs(struct i2c_client *client,\n\t\t\t\t struct pmbus_data *data,\n\t\t\t\t const struct pmbus_driver_info *info,\n\t\t\t\t const char *name, int index, int page,\n\t\t\t\t struct pmbus_sensor *base,\n\t\t\t\t const struct pmbus_sensor_attr *attr)\n{\n\tconst struct pmbus_limit_attr *l = attr->limit;\n\tint nlimit = attr->nlimit;\n\tint have_alarm = 0;\n\tint i, ret;\n\tstruct pmbus_sensor *curr;\n\n\tfor (i = 0; i < nlimit; i++) {\n\t\tif (pmbus_check_word_register(client, page, l->reg)) {\n\t\t\tcurr = pmbus_add_sensor(data, name, l->attr, index,\n\t\t\t\t\t\tpage, 0xff, l->reg, attr->class,\n\t\t\t\t\t\tattr->update || l->update,\n\t\t\t\t\t\tfalse, true);\n\t\t\tif (!curr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (l->sbit && (info->func[page] & attr->sfunc)) {\n\t\t\t\tret = pmbus_add_boolean(data, name,\n\t\t\t\t\tl->alarm, index,\n\t\t\t\t\tattr->compare ?  l->low ? curr : base\n\t\t\t\t\t\t      : NULL,\n\t\t\t\t\tattr->compare ? l->low ? base : curr\n\t\t\t\t\t\t      : NULL,\n\t\t\t\t\tpage, attr->sreg, l->sbit);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\thave_alarm = 1;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn have_alarm;\n}\n\nstatic int pmbus_add_sensor_attrs_one(struct i2c_client *client,\n\t\t\t\t      struct pmbus_data *data,\n\t\t\t\t      const struct pmbus_driver_info *info,\n\t\t\t\t      const char *name,\n\t\t\t\t      int index, int page, int phase,\n\t\t\t\t      const struct pmbus_sensor_attr *attr,\n\t\t\t\t      bool paged)\n{\n\tstruct pmbus_sensor *base;\n\tbool upper = !!(attr->gbit & 0xff00);\t \n\tint ret;\n\n\tif (attr->label) {\n\t\tret = pmbus_add_label(data, name, index, attr->label,\n\t\t\t\t      paged ? page + 1 : 0, phase);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbase = pmbus_add_sensor(data, name, \"input\", index, page, phase,\n\t\t\t\tattr->reg, attr->class, true, true, true);\n\tif (!base)\n\t\treturn -ENOMEM;\n\t \n\tif (attr->sfunc && phase == 0xff) {\n\t\tret = pmbus_add_limit_attrs(client, data, info, name,\n\t\t\t\t\t    index, page, base, attr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tif (!ret && attr->gbit &&\n\t\t    (!upper || data->has_status_word) &&\n\t\t    pmbus_check_status_register(client, page)) {\n\t\t\tret = pmbus_add_boolean(data, name, \"alarm\", index,\n\t\t\t\t\t\tNULL, NULL,\n\t\t\t\t\t\tpage, PMBUS_STATUS_WORD,\n\t\t\t\t\t\tattr->gbit);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic bool pmbus_sensor_is_paged(const struct pmbus_driver_info *info,\n\t\t\t\t  const struct pmbus_sensor_attr *attr)\n{\n\tint p;\n\n\tif (attr->paged)\n\t\treturn true;\n\n\t \n\tfor (p = 1; p < info->pages; p++) {\n\t\tif (info->func[p] & attr->func)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int pmbus_add_sensor_attrs(struct i2c_client *client,\n\t\t\t\t  struct pmbus_data *data,\n\t\t\t\t  const char *name,\n\t\t\t\t  const struct pmbus_sensor_attr *attrs,\n\t\t\t\t  int nattrs)\n{\n\tconst struct pmbus_driver_info *info = data->info;\n\tint index, i;\n\tint ret;\n\n\tindex = 1;\n\tfor (i = 0; i < nattrs; i++) {\n\t\tint page, pages;\n\t\tbool paged = pmbus_sensor_is_paged(info, attrs);\n\n\t\tpages = paged ? info->pages : 1;\n\t\tfor (page = 0; page < pages; page++) {\n\t\t\tif (info->func[page] & attrs->func) {\n\t\t\t\tret = pmbus_add_sensor_attrs_one(client, data, info,\n\t\t\t\t\t\t\t\t name, index, page,\n\t\t\t\t\t\t\t\t 0xff, attrs, paged);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tif (info->phases[page]) {\n\t\t\t\tint phase;\n\n\t\t\t\tfor (phase = 0; phase < info->phases[page];\n\t\t\t\t     phase++) {\n\t\t\t\t\tif (!(info->pfunc[phase] & attrs->func))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tret = pmbus_add_sensor_attrs_one(client,\n\t\t\t\t\t\tdata, info, name, index, page,\n\t\t\t\t\t\tphase, attrs, paged);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tattrs++;\n\t}\n\treturn 0;\n}\n\nstatic const struct pmbus_limit_attr vin_limit_attrs[] = {\n\t{\n\t\t.reg = PMBUS_VIN_UV_WARN_LIMIT,\n\t\t.attr = \"min\",\n\t\t.alarm = \"min_alarm\",\n\t\t.sbit = PB_VOLTAGE_UV_WARNING,\n\t}, {\n\t\t.reg = PMBUS_VIN_UV_FAULT_LIMIT,\n\t\t.attr = \"lcrit\",\n\t\t.alarm = \"lcrit_alarm\",\n\t\t.sbit = PB_VOLTAGE_UV_FAULT | PB_VOLTAGE_VIN_OFF,\n\t}, {\n\t\t.reg = PMBUS_VIN_OV_WARN_LIMIT,\n\t\t.attr = \"max\",\n\t\t.alarm = \"max_alarm\",\n\t\t.sbit = PB_VOLTAGE_OV_WARNING,\n\t}, {\n\t\t.reg = PMBUS_VIN_OV_FAULT_LIMIT,\n\t\t.attr = \"crit\",\n\t\t.alarm = \"crit_alarm\",\n\t\t.sbit = PB_VOLTAGE_OV_FAULT,\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_VIN_AVG,\n\t\t.update = true,\n\t\t.attr = \"average\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_VIN_MIN,\n\t\t.update = true,\n\t\t.attr = \"lowest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_VIN_MAX,\n\t\t.update = true,\n\t\t.attr = \"highest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_RESET_VIN_HISTORY,\n\t\t.attr = \"reset_history\",\n\t}, {\n\t\t.reg = PMBUS_MFR_VIN_MIN,\n\t\t.attr = \"rated_min\",\n\t}, {\n\t\t.reg = PMBUS_MFR_VIN_MAX,\n\t\t.attr = \"rated_max\",\n\t},\n};\n\nstatic const struct pmbus_limit_attr vmon_limit_attrs[] = {\n\t{\n\t\t.reg = PMBUS_VIRT_VMON_UV_WARN_LIMIT,\n\t\t.attr = \"min\",\n\t\t.alarm = \"min_alarm\",\n\t\t.sbit = PB_VOLTAGE_UV_WARNING,\n\t}, {\n\t\t.reg = PMBUS_VIRT_VMON_UV_FAULT_LIMIT,\n\t\t.attr = \"lcrit\",\n\t\t.alarm = \"lcrit_alarm\",\n\t\t.sbit = PB_VOLTAGE_UV_FAULT,\n\t}, {\n\t\t.reg = PMBUS_VIRT_VMON_OV_WARN_LIMIT,\n\t\t.attr = \"max\",\n\t\t.alarm = \"max_alarm\",\n\t\t.sbit = PB_VOLTAGE_OV_WARNING,\n\t}, {\n\t\t.reg = PMBUS_VIRT_VMON_OV_FAULT_LIMIT,\n\t\t.attr = \"crit\",\n\t\t.alarm = \"crit_alarm\",\n\t\t.sbit = PB_VOLTAGE_OV_FAULT,\n\t}\n};\n\nstatic const struct pmbus_limit_attr vout_limit_attrs[] = {\n\t{\n\t\t.reg = PMBUS_VOUT_UV_WARN_LIMIT,\n\t\t.attr = \"min\",\n\t\t.alarm = \"min_alarm\",\n\t\t.sbit = PB_VOLTAGE_UV_WARNING,\n\t}, {\n\t\t.reg = PMBUS_VOUT_UV_FAULT_LIMIT,\n\t\t.attr = \"lcrit\",\n\t\t.alarm = \"lcrit_alarm\",\n\t\t.sbit = PB_VOLTAGE_UV_FAULT,\n\t}, {\n\t\t.reg = PMBUS_VOUT_OV_WARN_LIMIT,\n\t\t.attr = \"max\",\n\t\t.alarm = \"max_alarm\",\n\t\t.sbit = PB_VOLTAGE_OV_WARNING,\n\t}, {\n\t\t.reg = PMBUS_VOUT_OV_FAULT_LIMIT,\n\t\t.attr = \"crit\",\n\t\t.alarm = \"crit_alarm\",\n\t\t.sbit = PB_VOLTAGE_OV_FAULT,\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_VOUT_AVG,\n\t\t.update = true,\n\t\t.attr = \"average\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_VOUT_MIN,\n\t\t.update = true,\n\t\t.attr = \"lowest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_VOUT_MAX,\n\t\t.update = true,\n\t\t.attr = \"highest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_RESET_VOUT_HISTORY,\n\t\t.attr = \"reset_history\",\n\t}, {\n\t\t.reg = PMBUS_MFR_VOUT_MIN,\n\t\t.attr = \"rated_min\",\n\t}, {\n\t\t.reg = PMBUS_MFR_VOUT_MAX,\n\t\t.attr = \"rated_max\",\n\t},\n};\n\nstatic const struct pmbus_sensor_attr voltage_attributes[] = {\n\t{\n\t\t.reg = PMBUS_READ_VIN,\n\t\t.class = PSC_VOLTAGE_IN,\n\t\t.label = \"vin\",\n\t\t.func = PMBUS_HAVE_VIN,\n\t\t.sfunc = PMBUS_HAVE_STATUS_INPUT,\n\t\t.sreg = PMBUS_STATUS_INPUT,\n\t\t.gbit = PB_STATUS_VIN_UV,\n\t\t.limit = vin_limit_attrs,\n\t\t.nlimit = ARRAY_SIZE(vin_limit_attrs),\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_VMON,\n\t\t.class = PSC_VOLTAGE_IN,\n\t\t.label = \"vmon\",\n\t\t.func = PMBUS_HAVE_VMON,\n\t\t.sfunc = PMBUS_HAVE_STATUS_VMON,\n\t\t.sreg = PMBUS_VIRT_STATUS_VMON,\n\t\t.limit = vmon_limit_attrs,\n\t\t.nlimit = ARRAY_SIZE(vmon_limit_attrs),\n\t}, {\n\t\t.reg = PMBUS_READ_VCAP,\n\t\t.class = PSC_VOLTAGE_IN,\n\t\t.label = \"vcap\",\n\t\t.func = PMBUS_HAVE_VCAP,\n\t}, {\n\t\t.reg = PMBUS_READ_VOUT,\n\t\t.class = PSC_VOLTAGE_OUT,\n\t\t.label = \"vout\",\n\t\t.paged = true,\n\t\t.func = PMBUS_HAVE_VOUT,\n\t\t.sfunc = PMBUS_HAVE_STATUS_VOUT,\n\t\t.sreg = PMBUS_STATUS_VOUT,\n\t\t.gbit = PB_STATUS_VOUT_OV,\n\t\t.limit = vout_limit_attrs,\n\t\t.nlimit = ARRAY_SIZE(vout_limit_attrs),\n\t}\n};\n\n \n\nstatic const struct pmbus_limit_attr iin_limit_attrs[] = {\n\t{\n\t\t.reg = PMBUS_IIN_OC_WARN_LIMIT,\n\t\t.attr = \"max\",\n\t\t.alarm = \"max_alarm\",\n\t\t.sbit = PB_IIN_OC_WARNING,\n\t}, {\n\t\t.reg = PMBUS_IIN_OC_FAULT_LIMIT,\n\t\t.attr = \"crit\",\n\t\t.alarm = \"crit_alarm\",\n\t\t.sbit = PB_IIN_OC_FAULT,\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_IIN_AVG,\n\t\t.update = true,\n\t\t.attr = \"average\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_IIN_MIN,\n\t\t.update = true,\n\t\t.attr = \"lowest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_IIN_MAX,\n\t\t.update = true,\n\t\t.attr = \"highest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_RESET_IIN_HISTORY,\n\t\t.attr = \"reset_history\",\n\t}, {\n\t\t.reg = PMBUS_MFR_IIN_MAX,\n\t\t.attr = \"rated_max\",\n\t},\n};\n\nstatic const struct pmbus_limit_attr iout_limit_attrs[] = {\n\t{\n\t\t.reg = PMBUS_IOUT_OC_WARN_LIMIT,\n\t\t.attr = \"max\",\n\t\t.alarm = \"max_alarm\",\n\t\t.sbit = PB_IOUT_OC_WARNING,\n\t}, {\n\t\t.reg = PMBUS_IOUT_UC_FAULT_LIMIT,\n\t\t.attr = \"lcrit\",\n\t\t.alarm = \"lcrit_alarm\",\n\t\t.sbit = PB_IOUT_UC_FAULT,\n\t}, {\n\t\t.reg = PMBUS_IOUT_OC_FAULT_LIMIT,\n\t\t.attr = \"crit\",\n\t\t.alarm = \"crit_alarm\",\n\t\t.sbit = PB_IOUT_OC_FAULT,\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_IOUT_AVG,\n\t\t.update = true,\n\t\t.attr = \"average\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_IOUT_MIN,\n\t\t.update = true,\n\t\t.attr = \"lowest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_IOUT_MAX,\n\t\t.update = true,\n\t\t.attr = \"highest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_RESET_IOUT_HISTORY,\n\t\t.attr = \"reset_history\",\n\t}, {\n\t\t.reg = PMBUS_MFR_IOUT_MAX,\n\t\t.attr = \"rated_max\",\n\t},\n};\n\nstatic const struct pmbus_sensor_attr current_attributes[] = {\n\t{\n\t\t.reg = PMBUS_READ_IIN,\n\t\t.class = PSC_CURRENT_IN,\n\t\t.label = \"iin\",\n\t\t.func = PMBUS_HAVE_IIN,\n\t\t.sfunc = PMBUS_HAVE_STATUS_INPUT,\n\t\t.sreg = PMBUS_STATUS_INPUT,\n\t\t.gbit = PB_STATUS_INPUT,\n\t\t.limit = iin_limit_attrs,\n\t\t.nlimit = ARRAY_SIZE(iin_limit_attrs),\n\t}, {\n\t\t.reg = PMBUS_READ_IOUT,\n\t\t.class = PSC_CURRENT_OUT,\n\t\t.label = \"iout\",\n\t\t.paged = true,\n\t\t.func = PMBUS_HAVE_IOUT,\n\t\t.sfunc = PMBUS_HAVE_STATUS_IOUT,\n\t\t.sreg = PMBUS_STATUS_IOUT,\n\t\t.gbit = PB_STATUS_IOUT_OC,\n\t\t.limit = iout_limit_attrs,\n\t\t.nlimit = ARRAY_SIZE(iout_limit_attrs),\n\t}\n};\n\n \n\nstatic const struct pmbus_limit_attr pin_limit_attrs[] = {\n\t{\n\t\t.reg = PMBUS_PIN_OP_WARN_LIMIT,\n\t\t.attr = \"max\",\n\t\t.alarm = \"alarm\",\n\t\t.sbit = PB_PIN_OP_WARNING,\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_PIN_AVG,\n\t\t.update = true,\n\t\t.attr = \"average\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_PIN_MIN,\n\t\t.update = true,\n\t\t.attr = \"input_lowest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_PIN_MAX,\n\t\t.update = true,\n\t\t.attr = \"input_highest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_RESET_PIN_HISTORY,\n\t\t.attr = \"reset_history\",\n\t}, {\n\t\t.reg = PMBUS_MFR_PIN_MAX,\n\t\t.attr = \"rated_max\",\n\t},\n};\n\nstatic const struct pmbus_limit_attr pout_limit_attrs[] = {\n\t{\n\t\t.reg = PMBUS_POUT_MAX,\n\t\t.attr = \"cap\",\n\t\t.alarm = \"cap_alarm\",\n\t\t.sbit = PB_POWER_LIMITING,\n\t}, {\n\t\t.reg = PMBUS_POUT_OP_WARN_LIMIT,\n\t\t.attr = \"max\",\n\t\t.alarm = \"max_alarm\",\n\t\t.sbit = PB_POUT_OP_WARNING,\n\t}, {\n\t\t.reg = PMBUS_POUT_OP_FAULT_LIMIT,\n\t\t.attr = \"crit\",\n\t\t.alarm = \"crit_alarm\",\n\t\t.sbit = PB_POUT_OP_FAULT,\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_POUT_AVG,\n\t\t.update = true,\n\t\t.attr = \"average\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_POUT_MIN,\n\t\t.update = true,\n\t\t.attr = \"input_lowest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_POUT_MAX,\n\t\t.update = true,\n\t\t.attr = \"input_highest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_RESET_POUT_HISTORY,\n\t\t.attr = \"reset_history\",\n\t}, {\n\t\t.reg = PMBUS_MFR_POUT_MAX,\n\t\t.attr = \"rated_max\",\n\t},\n};\n\nstatic const struct pmbus_sensor_attr power_attributes[] = {\n\t{\n\t\t.reg = PMBUS_READ_PIN,\n\t\t.class = PSC_POWER,\n\t\t.label = \"pin\",\n\t\t.func = PMBUS_HAVE_PIN,\n\t\t.sfunc = PMBUS_HAVE_STATUS_INPUT,\n\t\t.sreg = PMBUS_STATUS_INPUT,\n\t\t.gbit = PB_STATUS_INPUT,\n\t\t.limit = pin_limit_attrs,\n\t\t.nlimit = ARRAY_SIZE(pin_limit_attrs),\n\t}, {\n\t\t.reg = PMBUS_READ_POUT,\n\t\t.class = PSC_POWER,\n\t\t.label = \"pout\",\n\t\t.paged = true,\n\t\t.func = PMBUS_HAVE_POUT,\n\t\t.sfunc = PMBUS_HAVE_STATUS_IOUT,\n\t\t.sreg = PMBUS_STATUS_IOUT,\n\t\t.limit = pout_limit_attrs,\n\t\t.nlimit = ARRAY_SIZE(pout_limit_attrs),\n\t}\n};\n\n \n\nstatic const struct pmbus_limit_attr temp_limit_attrs[] = {\n\t{\n\t\t.reg = PMBUS_UT_WARN_LIMIT,\n\t\t.low = true,\n\t\t.attr = \"min\",\n\t\t.alarm = \"min_alarm\",\n\t\t.sbit = PB_TEMP_UT_WARNING,\n\t}, {\n\t\t.reg = PMBUS_UT_FAULT_LIMIT,\n\t\t.low = true,\n\t\t.attr = \"lcrit\",\n\t\t.alarm = \"lcrit_alarm\",\n\t\t.sbit = PB_TEMP_UT_FAULT,\n\t}, {\n\t\t.reg = PMBUS_OT_WARN_LIMIT,\n\t\t.attr = \"max\",\n\t\t.alarm = \"max_alarm\",\n\t\t.sbit = PB_TEMP_OT_WARNING,\n\t}, {\n\t\t.reg = PMBUS_OT_FAULT_LIMIT,\n\t\t.attr = \"crit\",\n\t\t.alarm = \"crit_alarm\",\n\t\t.sbit = PB_TEMP_OT_FAULT,\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_TEMP_MIN,\n\t\t.attr = \"lowest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_TEMP_AVG,\n\t\t.attr = \"average\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_TEMP_MAX,\n\t\t.attr = \"highest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_RESET_TEMP_HISTORY,\n\t\t.attr = \"reset_history\",\n\t}, {\n\t\t.reg = PMBUS_MFR_MAX_TEMP_1,\n\t\t.attr = \"rated_max\",\n\t},\n};\n\nstatic const struct pmbus_limit_attr temp_limit_attrs2[] = {\n\t{\n\t\t.reg = PMBUS_UT_WARN_LIMIT,\n\t\t.low = true,\n\t\t.attr = \"min\",\n\t\t.alarm = \"min_alarm\",\n\t\t.sbit = PB_TEMP_UT_WARNING,\n\t}, {\n\t\t.reg = PMBUS_UT_FAULT_LIMIT,\n\t\t.low = true,\n\t\t.attr = \"lcrit\",\n\t\t.alarm = \"lcrit_alarm\",\n\t\t.sbit = PB_TEMP_UT_FAULT,\n\t}, {\n\t\t.reg = PMBUS_OT_WARN_LIMIT,\n\t\t.attr = \"max\",\n\t\t.alarm = \"max_alarm\",\n\t\t.sbit = PB_TEMP_OT_WARNING,\n\t}, {\n\t\t.reg = PMBUS_OT_FAULT_LIMIT,\n\t\t.attr = \"crit\",\n\t\t.alarm = \"crit_alarm\",\n\t\t.sbit = PB_TEMP_OT_FAULT,\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_TEMP2_MIN,\n\t\t.attr = \"lowest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_TEMP2_AVG,\n\t\t.attr = \"average\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_READ_TEMP2_MAX,\n\t\t.attr = \"highest\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_RESET_TEMP2_HISTORY,\n\t\t.attr = \"reset_history\",\n\t}, {\n\t\t.reg = PMBUS_MFR_MAX_TEMP_2,\n\t\t.attr = \"rated_max\",\n\t},\n};\n\nstatic const struct pmbus_limit_attr temp_limit_attrs3[] = {\n\t{\n\t\t.reg = PMBUS_UT_WARN_LIMIT,\n\t\t.low = true,\n\t\t.attr = \"min\",\n\t\t.alarm = \"min_alarm\",\n\t\t.sbit = PB_TEMP_UT_WARNING,\n\t}, {\n\t\t.reg = PMBUS_UT_FAULT_LIMIT,\n\t\t.low = true,\n\t\t.attr = \"lcrit\",\n\t\t.alarm = \"lcrit_alarm\",\n\t\t.sbit = PB_TEMP_UT_FAULT,\n\t}, {\n\t\t.reg = PMBUS_OT_WARN_LIMIT,\n\t\t.attr = \"max\",\n\t\t.alarm = \"max_alarm\",\n\t\t.sbit = PB_TEMP_OT_WARNING,\n\t}, {\n\t\t.reg = PMBUS_OT_FAULT_LIMIT,\n\t\t.attr = \"crit\",\n\t\t.alarm = \"crit_alarm\",\n\t\t.sbit = PB_TEMP_OT_FAULT,\n\t}, {\n\t\t.reg = PMBUS_MFR_MAX_TEMP_3,\n\t\t.attr = \"rated_max\",\n\t},\n};\n\nstatic const struct pmbus_sensor_attr temp_attributes[] = {\n\t{\n\t\t.reg = PMBUS_READ_TEMPERATURE_1,\n\t\t.class = PSC_TEMPERATURE,\n\t\t.paged = true,\n\t\t.update = true,\n\t\t.compare = true,\n\t\t.func = PMBUS_HAVE_TEMP,\n\t\t.sfunc = PMBUS_HAVE_STATUS_TEMP,\n\t\t.sreg = PMBUS_STATUS_TEMPERATURE,\n\t\t.gbit = PB_STATUS_TEMPERATURE,\n\t\t.limit = temp_limit_attrs,\n\t\t.nlimit = ARRAY_SIZE(temp_limit_attrs),\n\t}, {\n\t\t.reg = PMBUS_READ_TEMPERATURE_2,\n\t\t.class = PSC_TEMPERATURE,\n\t\t.paged = true,\n\t\t.update = true,\n\t\t.compare = true,\n\t\t.func = PMBUS_HAVE_TEMP2,\n\t\t.sfunc = PMBUS_HAVE_STATUS_TEMP,\n\t\t.sreg = PMBUS_STATUS_TEMPERATURE,\n\t\t.gbit = PB_STATUS_TEMPERATURE,\n\t\t.limit = temp_limit_attrs2,\n\t\t.nlimit = ARRAY_SIZE(temp_limit_attrs2),\n\t}, {\n\t\t.reg = PMBUS_READ_TEMPERATURE_3,\n\t\t.class = PSC_TEMPERATURE,\n\t\t.paged = true,\n\t\t.update = true,\n\t\t.compare = true,\n\t\t.func = PMBUS_HAVE_TEMP3,\n\t\t.sfunc = PMBUS_HAVE_STATUS_TEMP,\n\t\t.sreg = PMBUS_STATUS_TEMPERATURE,\n\t\t.gbit = PB_STATUS_TEMPERATURE,\n\t\t.limit = temp_limit_attrs3,\n\t\t.nlimit = ARRAY_SIZE(temp_limit_attrs3),\n\t}\n};\n\nstatic const int pmbus_fan_registers[] = {\n\tPMBUS_READ_FAN_SPEED_1,\n\tPMBUS_READ_FAN_SPEED_2,\n\tPMBUS_READ_FAN_SPEED_3,\n\tPMBUS_READ_FAN_SPEED_4\n};\n\nstatic const int pmbus_fan_status_registers[] = {\n\tPMBUS_STATUS_FAN_12,\n\tPMBUS_STATUS_FAN_12,\n\tPMBUS_STATUS_FAN_34,\n\tPMBUS_STATUS_FAN_34\n};\n\nstatic const u32 pmbus_fan_flags[] = {\n\tPMBUS_HAVE_FAN12,\n\tPMBUS_HAVE_FAN12,\n\tPMBUS_HAVE_FAN34,\n\tPMBUS_HAVE_FAN34\n};\n\nstatic const u32 pmbus_fan_status_flags[] = {\n\tPMBUS_HAVE_STATUS_FAN12,\n\tPMBUS_HAVE_STATUS_FAN12,\n\tPMBUS_HAVE_STATUS_FAN34,\n\tPMBUS_HAVE_STATUS_FAN34\n};\n\n \n\n \nstatic int pmbus_add_fan_ctrl(struct i2c_client *client,\n\t\tstruct pmbus_data *data, int index, int page, int id,\n\t\tu8 config)\n{\n\tstruct pmbus_sensor *sensor;\n\n\tsensor = pmbus_add_sensor(data, \"fan\", \"target\", index, page,\n\t\t\t\t  0xff, PMBUS_VIRT_FAN_TARGET_1 + id, PSC_FAN,\n\t\t\t\t  false, false, true);\n\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tif (!((data->info->func[page] & PMBUS_HAVE_PWM12) ||\n\t\t\t(data->info->func[page] & PMBUS_HAVE_PWM34)))\n\t\treturn 0;\n\n\tsensor = pmbus_add_sensor(data, \"pwm\", NULL, index, page,\n\t\t\t\t  0xff, PMBUS_VIRT_PWM_1 + id, PSC_PWM,\n\t\t\t\t  false, false, true);\n\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tsensor = pmbus_add_sensor(data, \"pwm\", \"enable\", index, page,\n\t\t\t\t  0xff, PMBUS_VIRT_PWM_ENABLE_1 + id, PSC_PWM,\n\t\t\t\t  true, false, false);\n\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int pmbus_add_fan_attributes(struct i2c_client *client,\n\t\t\t\t    struct pmbus_data *data)\n{\n\tconst struct pmbus_driver_info *info = data->info;\n\tint index = 1;\n\tint page;\n\tint ret;\n\n\tfor (page = 0; page < info->pages; page++) {\n\t\tint f;\n\n\t\tfor (f = 0; f < ARRAY_SIZE(pmbus_fan_registers); f++) {\n\t\t\tint regval;\n\n\t\t\tif (!(info->func[page] & pmbus_fan_flags[f]))\n\t\t\t\tbreak;\n\n\t\t\tif (!pmbus_check_word_register(client, page,\n\t\t\t\t\t\t       pmbus_fan_registers[f]))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tregval = _pmbus_read_byte_data(client, page,\n\t\t\t\tpmbus_fan_config_registers[f]);\n\t\t\tif (regval < 0 ||\n\t\t\t    (!(regval & (PB_FAN_1_INSTALLED >> ((f & 1) * 4)))))\n\t\t\t\tcontinue;\n\n\t\t\tif (pmbus_add_sensor(data, \"fan\", \"input\", index,\n\t\t\t\t\t     page, 0xff, pmbus_fan_registers[f],\n\t\t\t\t\t     PSC_FAN, true, true, true) == NULL)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t \n\t\t\tif (pmbus_check_word_register(client, page,\n\t\t\t\t\tpmbus_fan_command_registers[f])) {\n\t\t\t\tret = pmbus_add_fan_ctrl(client, data, index,\n\t\t\t\t\t\t\t page, f, regval);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((info->func[page] & pmbus_fan_status_flags[f]) &&\n\t\t\t    pmbus_check_byte_register(client,\n\t\t\t\t\tpage, pmbus_fan_status_registers[f])) {\n\t\t\t\tint reg;\n\n\t\t\t\tif (f > 1)\t \n\t\t\t\t\treg = PMBUS_STATUS_FAN_34;\n\t\t\t\telse\n\t\t\t\t\treg = PMBUS_STATUS_FAN_12;\n\t\t\t\tret = pmbus_add_boolean(data, \"fan\",\n\t\t\t\t\t\"alarm\", index, NULL, NULL, page, reg,\n\t\t\t\t\tPB_FAN_FAN1_WARNING >> (f & 1));\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = pmbus_add_boolean(data, \"fan\",\n\t\t\t\t\t\"fault\", index, NULL, NULL, page, reg,\n\t\t\t\t\tPB_FAN_FAN1_FAULT >> (f & 1));\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstruct pmbus_samples_attr {\n\tint reg;\n\tchar *name;\n};\n\nstruct pmbus_samples_reg {\n\tint page;\n\tstruct pmbus_samples_attr *attr;\n\tstruct device_attribute dev_attr;\n};\n\nstatic struct pmbus_samples_attr pmbus_samples_registers[] = {\n\t{\n\t\t.reg = PMBUS_VIRT_SAMPLES,\n\t\t.name = \"samples\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_IN_SAMPLES,\n\t\t.name = \"in_samples\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_CURR_SAMPLES,\n\t\t.name = \"curr_samples\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_POWER_SAMPLES,\n\t\t.name = \"power_samples\",\n\t}, {\n\t\t.reg = PMBUS_VIRT_TEMP_SAMPLES,\n\t\t.name = \"temp_samples\",\n\t}\n};\n\n#define to_samples_reg(x) container_of(x, struct pmbus_samples_reg, dev_attr)\n\nstatic ssize_t pmbus_show_samples(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr, char *buf)\n{\n\tint val;\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct pmbus_samples_reg *reg = to_samples_reg(devattr);\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\n\tmutex_lock(&data->update_lock);\n\tval = _pmbus_read_word_data(client, reg->page, 0xff, reg->attr->reg);\n\tmutex_unlock(&data->update_lock);\n\tif (val < 0)\n\t\treturn val;\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t pmbus_set_samples(struct device *dev,\n\t\t\t\t struct device_attribute *devattr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tint ret;\n\tlong val;\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct pmbus_samples_reg *reg = to_samples_reg(devattr);\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\n\tif (kstrtol(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tret = _pmbus_write_word_data(client, reg->page, reg->attr->reg, val);\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret ? : count;\n}\n\nstatic int pmbus_add_samples_attr(struct pmbus_data *data, int page,\n\t\t\t\t  struct pmbus_samples_attr *attr)\n{\n\tstruct pmbus_samples_reg *reg;\n\n\treg = devm_kzalloc(data->dev, sizeof(*reg), GFP_KERNEL);\n\tif (!reg)\n\t\treturn -ENOMEM;\n\n\treg->attr = attr;\n\treg->page = page;\n\n\tpmbus_dev_attr_init(&reg->dev_attr, attr->name, 0644,\n\t\t\t    pmbus_show_samples, pmbus_set_samples);\n\n\treturn pmbus_add_attribute(data, &reg->dev_attr.attr);\n}\n\nstatic int pmbus_add_samples_attributes(struct i2c_client *client,\n\t\t\t\t\tstruct pmbus_data *data)\n{\n\tconst struct pmbus_driver_info *info = data->info;\n\tint s;\n\n\tif (!(info->func[0] & PMBUS_HAVE_SAMPLES))\n\t\treturn 0;\n\n\tfor (s = 0; s < ARRAY_SIZE(pmbus_samples_registers); s++) {\n\t\tstruct pmbus_samples_attr *attr;\n\t\tint ret;\n\n\t\tattr = &pmbus_samples_registers[s];\n\t\tif (!pmbus_check_word_register(client, 0, attr->reg))\n\t\t\tcontinue;\n\n\t\tret = pmbus_add_samples_attr(data, 0, attr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int pmbus_find_attributes(struct i2c_client *client,\n\t\t\t\t struct pmbus_data *data)\n{\n\tint ret;\n\n\t \n\tret = pmbus_add_sensor_attrs(client, data, \"in\", voltage_attributes,\n\t\t\t\t     ARRAY_SIZE(voltage_attributes));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = pmbus_add_sensor_attrs(client, data, \"curr\", current_attributes,\n\t\t\t\t     ARRAY_SIZE(current_attributes));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = pmbus_add_sensor_attrs(client, data, \"power\", power_attributes,\n\t\t\t\t     ARRAY_SIZE(power_attributes));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = pmbus_add_sensor_attrs(client, data, \"temp\", temp_attributes,\n\t\t\t\t     ARRAY_SIZE(temp_attributes));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = pmbus_add_fan_attributes(client, data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pmbus_add_samples_attributes(client, data);\n\treturn ret;\n}\n\n \nstruct pmbus_class_attr_map {\n\tenum pmbus_sensor_classes class;\n\tint nattr;\n\tconst struct pmbus_sensor_attr *attr;\n};\n\nstatic const struct pmbus_class_attr_map class_attr_map[] = {\n\t{\n\t\t.class = PSC_VOLTAGE_IN,\n\t\t.attr = voltage_attributes,\n\t\t.nattr = ARRAY_SIZE(voltage_attributes),\n\t}, {\n\t\t.class = PSC_VOLTAGE_OUT,\n\t\t.attr = voltage_attributes,\n\t\t.nattr = ARRAY_SIZE(voltage_attributes),\n\t}, {\n\t\t.class = PSC_CURRENT_IN,\n\t\t.attr = current_attributes,\n\t\t.nattr = ARRAY_SIZE(current_attributes),\n\t}, {\n\t\t.class = PSC_CURRENT_OUT,\n\t\t.attr = current_attributes,\n\t\t.nattr = ARRAY_SIZE(current_attributes),\n\t}, {\n\t\t.class = PSC_POWER,\n\t\t.attr = power_attributes,\n\t\t.nattr = ARRAY_SIZE(power_attributes),\n\t}, {\n\t\t.class = PSC_TEMPERATURE,\n\t\t.attr = temp_attributes,\n\t\t.nattr = ARRAY_SIZE(temp_attributes),\n\t}\n};\n\n \nstatic int pmbus_read_coefficients(struct i2c_client *client,\n\t\t\t\t   struct pmbus_driver_info *info,\n\t\t\t\t   const struct pmbus_sensor_attr *attr)\n{\n\tint rv;\n\tunion i2c_smbus_data data;\n\tenum pmbus_sensor_classes class = attr->class;\n\ts8 R;\n\ts16 m, b;\n\n\tdata.block[0] = 2;\n\tdata.block[1] = attr->reg;\n\tdata.block[2] = 0x01;\n\n\trv = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t    I2C_SMBUS_WRITE, PMBUS_COEFFICIENTS,\n\t\t\t    I2C_SMBUS_BLOCK_PROC_CALL, &data);\n\n\tif (rv < 0)\n\t\treturn rv;\n\n\tif (data.block[0] != 5)\n\t\treturn -EIO;\n\n\tm = data.block[1] | (data.block[2] << 8);\n\tb = data.block[3] | (data.block[4] << 8);\n\tR = data.block[5];\n\tinfo->m[class] = m;\n\tinfo->b[class] = b;\n\tinfo->R[class] = R;\n\n\treturn rv;\n}\n\nstatic int pmbus_init_coefficients(struct i2c_client *client,\n\t\t\t\t   struct pmbus_driver_info *info)\n{\n\tint i, n, ret = -EINVAL;\n\tconst struct pmbus_class_attr_map *map;\n\tconst struct pmbus_sensor_attr *attr;\n\n\tfor (i = 0; i < ARRAY_SIZE(class_attr_map); i++) {\n\t\tmap = &class_attr_map[i];\n\t\tif (info->format[map->class] != direct)\n\t\t\tcontinue;\n\t\tfor (n = 0; n < map->nattr; n++) {\n\t\t\tattr = &map->attr[n];\n\t\t\tif (map->class != attr->class)\n\t\t\t\tcontinue;\n\t\t\tret = pmbus_read_coefficients(client, info, attr);\n\t\t\tif (ret >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"No coefficients found for sensor class %d\\n\",\n\t\t\t\tmap->class);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pmbus_identify_common(struct i2c_client *client,\n\t\t\t\t struct pmbus_data *data, int page)\n{\n\tint vout_mode = -1;\n\n\tif (pmbus_check_byte_register(client, page, PMBUS_VOUT_MODE))\n\t\tvout_mode = _pmbus_read_byte_data(client, page,\n\t\t\t\t\t\t  PMBUS_VOUT_MODE);\n\tif (vout_mode >= 0 && vout_mode != 0xff) {\n\t\t \n\t\tswitch (vout_mode >> 5) {\n\t\tcase 0:\t \n\t\t\tif (data->info->format[PSC_VOLTAGE_OUT] != linear)\n\t\t\t\treturn -ENODEV;\n\n\t\t\tdata->exponent[page] = ((s8)(vout_mode << 3)) >> 3;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tif (data->info->format[PSC_VOLTAGE_OUT] != vid)\n\t\t\t\treturn -ENODEV;\n\t\t\tbreak;\n\t\tcase 2:\t \n\t\t\tif (data->info->format[PSC_VOLTAGE_OUT] != direct)\n\t\t\t\treturn -ENODEV;\n\t\t\tbreak;\n\t\tcase 3:\t \n\t\t\tif (data->info->format[PSC_VOLTAGE_OUT] != ieee754)\n\t\t\t\treturn -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pmbus_read_status_byte(struct i2c_client *client, int page)\n{\n\treturn _pmbus_read_byte_data(client, page, PMBUS_STATUS_BYTE);\n}\n\nstatic int pmbus_read_status_word(struct i2c_client *client, int page)\n{\n\treturn _pmbus_read_word_data(client, page, 0xff, PMBUS_STATUS_WORD);\n}\n\n \n\nstatic ssize_t pec_show(struct device *dev, struct device_attribute *dummy,\n\t\t\tchar *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!(client->flags & I2C_CLIENT_PEC));\n}\n\nstatic ssize_t pec_store(struct device *dev, struct device_attribute *dummy,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tbool enable;\n\tint err;\n\n\terr = kstrtobool(buf, &enable);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (enable)\n\t\tclient->flags |= I2C_CLIENT_PEC;\n\telse\n\t\tclient->flags &= ~I2C_CLIENT_PEC;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(pec);\n\nstatic void pmbus_remove_pec(void *dev)\n{\n\tdevice_remove_file(dev, &dev_attr_pec);\n}\n\nstatic int pmbus_init_common(struct i2c_client *client, struct pmbus_data *data,\n\t\t\t     struct pmbus_driver_info *info)\n{\n\tstruct device *dev = &client->dev;\n\tint page, ret;\n\n\t \n\tclient->flags &= ~I2C_CLIENT_PEC;\n\n\t \n\tif (!(data->flags & PMBUS_NO_CAPABILITY)) {\n\t\tret = i2c_smbus_read_byte_data(client, PMBUS_CAPABILITY);\n\t\tif (ret >= 0 && (ret & PB_CAPABILITY_ERROR_CHECK)) {\n\t\t\tif (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_PEC))\n\t\t\t\tclient->flags |= I2C_CLIENT_PEC;\n\t\t}\n\t}\n\n\t \n\tdata->read_status = pmbus_read_status_word;\n\tret = i2c_smbus_read_word_data(client, PMBUS_STATUS_WORD);\n\tif (ret < 0 || ret == 0xffff) {\n\t\tdata->read_status = pmbus_read_status_byte;\n\t\tret = i2c_smbus_read_byte_data(client, PMBUS_STATUS_BYTE);\n\t\tif (ret < 0 || ret == 0xff) {\n\t\t\tdev_err(dev, \"PMBus status register not found\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tdata->has_status_word = true;\n\t}\n\n\t \n\tif (!(data->flags & PMBUS_NO_WRITE_PROTECT)) {\n\t\tret = i2c_smbus_read_byte_data(client, PMBUS_WRITE_PROTECT);\n\t\tif (ret > 0 && (ret & PB_WP_ANY))\n\t\t\tdata->flags |= PMBUS_WRITE_PROTECTED | PMBUS_SKIP_STATUS_CHECK;\n\t}\n\n\tif (data->info->pages)\n\t\tpmbus_clear_faults(client);\n\telse\n\t\tpmbus_clear_fault_page(client, -1);\n\n\tif (info->identify) {\n\t\tret = (*info->identify)(client, info);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Chip identification failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (info->pages <= 0 || info->pages > PMBUS_PAGES) {\n\t\tdev_err(dev, \"Bad number of PMBus pages: %d\\n\", info->pages);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (page = 0; page < info->pages; page++) {\n\t\tret = pmbus_identify_common(client, data, page);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to identify chip capabilities\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (data->flags & PMBUS_USE_COEFFICIENTS_CMD) {\n\t\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t\t     I2C_FUNC_SMBUS_BLOCK_PROC_CALL))\n\t\t\treturn -ENODEV;\n\n\t\tret = pmbus_init_coefficients(client, info);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (client->flags & I2C_CLIENT_PEC) {\n\t\t \n\t\tret = device_create_file(dev, &dev_attr_pec);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = devm_add_action_or_reset(dev, pmbus_remove_pec, dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstruct pmbus_status_assoc {\n\tint pflag, rflag, eflag;\n};\n\n \nstruct pmbus_status_category {\n\tint func;\n\tint reg;\n\tconst struct pmbus_status_assoc *bits;  \n};\n\nstatic const struct pmbus_status_category __maybe_unused pmbus_status_flag_map[] = {\n\t{\n\t\t.func = PMBUS_HAVE_STATUS_VOUT,\n\t\t.reg = PMBUS_STATUS_VOUT,\n\t\t.bits = (const struct pmbus_status_assoc[]) {\n\t\t\t{ PB_VOLTAGE_UV_WARNING, REGULATOR_ERROR_UNDER_VOLTAGE_WARN,\n\t\t\tREGULATOR_EVENT_UNDER_VOLTAGE_WARN },\n\t\t\t{ PB_VOLTAGE_UV_FAULT,   REGULATOR_ERROR_UNDER_VOLTAGE,\n\t\t\tREGULATOR_EVENT_UNDER_VOLTAGE },\n\t\t\t{ PB_VOLTAGE_OV_WARNING, REGULATOR_ERROR_OVER_VOLTAGE_WARN,\n\t\t\tREGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t\t\t{ PB_VOLTAGE_OV_FAULT,   REGULATOR_ERROR_REGULATION_OUT,\n\t\t\tREGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t\t\t{ },\n\t\t},\n\t}, {\n\t\t.func = PMBUS_HAVE_STATUS_IOUT,\n\t\t.reg = PMBUS_STATUS_IOUT,\n\t\t.bits = (const struct pmbus_status_assoc[]) {\n\t\t\t{ PB_IOUT_OC_WARNING,   REGULATOR_ERROR_OVER_CURRENT_WARN,\n\t\t\tREGULATOR_EVENT_OVER_CURRENT_WARN },\n\t\t\t{ PB_IOUT_OC_FAULT,     REGULATOR_ERROR_OVER_CURRENT,\n\t\t\tREGULATOR_EVENT_OVER_CURRENT },\n\t\t\t{ PB_IOUT_OC_LV_FAULT,  REGULATOR_ERROR_OVER_CURRENT,\n\t\t\tREGULATOR_EVENT_OVER_CURRENT },\n\t\t\t{ },\n\t\t},\n\t}, {\n\t\t.func = PMBUS_HAVE_STATUS_TEMP,\n\t\t.reg = PMBUS_STATUS_TEMPERATURE,\n\t\t.bits = (const struct pmbus_status_assoc[]) {\n\t\t\t{ PB_TEMP_OT_WARNING,    REGULATOR_ERROR_OVER_TEMP_WARN,\n\t\t\tREGULATOR_EVENT_OVER_TEMP_WARN },\n\t\t\t{ PB_TEMP_OT_FAULT,      REGULATOR_ERROR_OVER_TEMP,\n\t\t\tREGULATOR_EVENT_OVER_TEMP },\n\t\t\t{ },\n\t\t},\n\t},\n};\n\nstatic int _pmbus_is_enabled(struct i2c_client *client, u8 page)\n{\n\tint ret;\n\n\tret = _pmbus_read_byte_data(client, page, PMBUS_OPERATION);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(ret & PB_OPERATION_CONTROL_ON);\n}\n\nstatic int __maybe_unused pmbus_is_enabled(struct i2c_client *client, u8 page)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tint ret;\n\n\tmutex_lock(&data->update_lock);\n\tret = _pmbus_is_enabled(client, page);\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\n#define to_dev_attr(_dev_attr) \\\n\tcontainer_of(_dev_attr, struct device_attribute, attr)\n\nstatic void pmbus_notify(struct pmbus_data *data, int page, int reg, int flags)\n{\n\tint i;\n\n\tfor (i = 0; i < data->num_attributes; i++) {\n\t\tstruct device_attribute *da = to_dev_attr(data->group.attrs[i]);\n\t\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\t\tint index = attr->index;\n\t\tu16 smask = pb_index_to_mask(index);\n\t\tu8 spage = pb_index_to_page(index);\n\t\tu16 sreg = pb_index_to_reg(index);\n\n\t\tif (reg == sreg && page == spage && (smask & flags)) {\n\t\t\tdev_dbg(data->dev, \"sysfs notify: %s\", da->attr.name);\n\t\t\tsysfs_notify(&data->dev->kobj, NULL, da->attr.name);\n\t\t\tkobject_uevent(&data->dev->kobj, KOBJ_CHANGE);\n\t\t\tflags &= ~smask;\n\t\t}\n\n\t\tif (!flags)\n\t\t\tbreak;\n\t}\n}\n\nstatic int _pmbus_get_flags(struct pmbus_data *data, u8 page, unsigned int *flags,\n\t\t\t   unsigned int *event, bool notify)\n{\n\tint i, status;\n\tconst struct pmbus_status_category *cat;\n\tconst struct pmbus_status_assoc *bit;\n\tstruct device *dev = data->dev;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint func = data->info->func[page];\n\n\t*flags = 0;\n\t*event = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(pmbus_status_flag_map); i++) {\n\t\tcat = &pmbus_status_flag_map[i];\n\t\tif (!(func & cat->func))\n\t\t\tcontinue;\n\n\t\tstatus = _pmbus_read_byte_data(client, page, cat->reg);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tfor (bit = cat->bits; bit->pflag; bit++)\n\t\t\tif (status & bit->pflag) {\n\t\t\t\t*flags |= bit->rflag;\n\t\t\t\t*event |= bit->eflag;\n\t\t\t}\n\n\t\tif (notify && status)\n\t\t\tpmbus_notify(data, page, cat->reg, status);\n\n\t}\n\n\t \n\tstatus = pmbus_get_status(client, page, PMBUS_STATUS_WORD);\n\tif (status < 0)\n\t\treturn status;\n\n\tif (_pmbus_is_enabled(client, page)) {\n\t\tif (status & PB_STATUS_OFF) {\n\t\t\t*flags |= REGULATOR_ERROR_FAIL;\n\t\t\t*event |= REGULATOR_EVENT_FAIL;\n\t\t}\n\n\t\tif (status & PB_STATUS_POWER_GOOD_N) {\n\t\t\t*flags |= REGULATOR_ERROR_REGULATION_OUT;\n\t\t\t*event |= REGULATOR_EVENT_REGULATION_OUT;\n\t\t}\n\t}\n\t \n\tif (status & PB_STATUS_IOUT_OC) {\n\t\t*flags |= REGULATOR_ERROR_OVER_CURRENT;\n\t\t*event |= REGULATOR_EVENT_OVER_CURRENT;\n\t}\n\tif (status & PB_STATUS_VOUT_OV) {\n\t\t*flags |= REGULATOR_ERROR_REGULATION_OUT;\n\t\t*event |= REGULATOR_EVENT_FAIL;\n\t}\n\n\t \n\tif (!(*flags & (REGULATOR_ERROR_OVER_TEMP | REGULATOR_ERROR_OVER_TEMP_WARN)) &&\n\t    (status & PB_STATUS_TEMPERATURE)) {\n\t\t*flags |= REGULATOR_ERROR_OVER_TEMP_WARN;\n\t\t*event |= REGULATOR_EVENT_OVER_TEMP_WARN;\n\t}\n\n\n\treturn 0;\n}\n\nstatic int __maybe_unused pmbus_get_flags(struct pmbus_data *data, u8 page, unsigned int *flags,\n\t\t\t\t\t  unsigned int *event, bool notify)\n{\n\tint ret;\n\n\tmutex_lock(&data->update_lock);\n\tret = _pmbus_get_flags(data, page, flags, event, notify);\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_REGULATOR)\nstatic int pmbus_regulator_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct device *dev = rdev_get_dev(rdev);\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\n\treturn pmbus_is_enabled(client, rdev_get_id(rdev));\n}\n\nstatic int _pmbus_regulator_on_off(struct regulator_dev *rdev, bool enable)\n{\n\tstruct device *dev = rdev_get_dev(rdev);\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tu8 page = rdev_get_id(rdev);\n\tint ret;\n\n\tmutex_lock(&data->update_lock);\n\tret = pmbus_update_byte_data(client, page, PMBUS_OPERATION,\n\t\t\t\t     PB_OPERATION_CONTROL_ON,\n\t\t\t\t     enable ? PB_OPERATION_CONTROL_ON : 0);\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\nstatic int pmbus_regulator_enable(struct regulator_dev *rdev)\n{\n\treturn _pmbus_regulator_on_off(rdev, 1);\n}\n\nstatic int pmbus_regulator_disable(struct regulator_dev *rdev)\n{\n\treturn _pmbus_regulator_on_off(rdev, 0);\n}\n\nstatic int pmbus_regulator_get_error_flags(struct regulator_dev *rdev, unsigned int *flags)\n{\n\tstruct device *dev = rdev_get_dev(rdev);\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tint event;\n\n\treturn pmbus_get_flags(data, rdev_get_id(rdev), flags, &event, false);\n}\n\nstatic int pmbus_regulator_get_status(struct regulator_dev *rdev)\n{\n\tstruct device *dev = rdev_get_dev(rdev);\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tu8 page = rdev_get_id(rdev);\n\tint status, ret;\n\tint event;\n\n\tmutex_lock(&data->update_lock);\n\tstatus = pmbus_get_status(client, page, PMBUS_STATUS_WORD);\n\tif (status < 0) {\n\t\tret = status;\n\t\tgoto unlock;\n\t}\n\n\tif (status & PB_STATUS_OFF) {\n\t\tret = REGULATOR_STATUS_OFF;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (!(status & PB_STATUS_POWER_GOOD_N)) {\n\t\tret = REGULATOR_STATUS_ON;\n\t\tgoto unlock;\n\t}\n\n\tret = _pmbus_get_flags(data, rdev_get_id(rdev), &status, &event, false);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (status & (REGULATOR_ERROR_UNDER_VOLTAGE | REGULATOR_ERROR_OVER_CURRENT |\n\t   REGULATOR_ERROR_REGULATION_OUT | REGULATOR_ERROR_FAIL | REGULATOR_ERROR_OVER_TEMP)) {\n\t\tret = REGULATOR_STATUS_ERROR;\n\t\tgoto unlock;\n\t}\n\n\tret = REGULATOR_STATUS_UNDEFINED;\n\nunlock:\n\tmutex_unlock(&data->update_lock);\n\treturn ret;\n}\n\nstatic int pmbus_regulator_get_low_margin(struct i2c_client *client, int page)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tstruct pmbus_sensor s = {\n\t\t.page = page,\n\t\t.class = PSC_VOLTAGE_OUT,\n\t\t.convert = true,\n\t\t.data = -1,\n\t};\n\n\tif (data->vout_low[page] < 0) {\n\t\tif (pmbus_check_word_register(client, page, PMBUS_MFR_VOUT_MIN))\n\t\t\ts.data = _pmbus_read_word_data(client, page, 0xff,\n\t\t\t\t\t\t       PMBUS_MFR_VOUT_MIN);\n\t\tif (s.data < 0) {\n\t\t\ts.data = _pmbus_read_word_data(client, page, 0xff,\n\t\t\t\t\t\t       PMBUS_VOUT_MARGIN_LOW);\n\t\t\tif (s.data < 0)\n\t\t\t\treturn s.data;\n\t\t}\n\t\tdata->vout_low[page] = pmbus_reg2data(data, &s);\n\t}\n\n\treturn data->vout_low[page];\n}\n\nstatic int pmbus_regulator_get_high_margin(struct i2c_client *client, int page)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tstruct pmbus_sensor s = {\n\t\t.page = page,\n\t\t.class = PSC_VOLTAGE_OUT,\n\t\t.convert = true,\n\t\t.data = -1,\n\t};\n\n\tif (data->vout_high[page] < 0) {\n\t\tif (pmbus_check_word_register(client, page, PMBUS_MFR_VOUT_MAX))\n\t\t\ts.data = _pmbus_read_word_data(client, page, 0xff,\n\t\t\t\t\t\t       PMBUS_MFR_VOUT_MAX);\n\t\tif (s.data < 0) {\n\t\t\ts.data = _pmbus_read_word_data(client, page, 0xff,\n\t\t\t\t\t\t       PMBUS_VOUT_MARGIN_HIGH);\n\t\t\tif (s.data < 0)\n\t\t\t\treturn s.data;\n\t\t}\n\t\tdata->vout_high[page] = pmbus_reg2data(data, &s);\n\t}\n\n\treturn data->vout_high[page];\n}\n\nstatic int pmbus_regulator_get_voltage(struct regulator_dev *rdev)\n{\n\tstruct device *dev = rdev_get_dev(rdev);\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tstruct pmbus_sensor s = {\n\t\t.page = rdev_get_id(rdev),\n\t\t.class = PSC_VOLTAGE_OUT,\n\t\t.convert = true,\n\t};\n\n\ts.data = _pmbus_read_word_data(client, s.page, 0xff, PMBUS_READ_VOUT);\n\tif (s.data < 0)\n\t\treturn s.data;\n\n\treturn (int)pmbus_reg2data(data, &s) * 1000;  \n}\n\nstatic int pmbus_regulator_set_voltage(struct regulator_dev *rdev, int min_uv,\n\t\t\t\t       int max_uv, unsigned int *selector)\n{\n\tstruct device *dev = rdev_get_dev(rdev);\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\tstruct pmbus_sensor s = {\n\t\t.page = rdev_get_id(rdev),\n\t\t.class = PSC_VOLTAGE_OUT,\n\t\t.convert = true,\n\t\t.data = -1,\n\t};\n\tint val = DIV_ROUND_CLOSEST(min_uv, 1000);  \n\tint low, high;\n\n\t*selector = 0;\n\n\tlow = pmbus_regulator_get_low_margin(client, s.page);\n\tif (low < 0)\n\t\treturn low;\n\n\thigh = pmbus_regulator_get_high_margin(client, s.page);\n\tif (high < 0)\n\t\treturn high;\n\n\t \n\tif (low > val)\n\t\tval = low;\n\tif (high < val)\n\t\tval = high;\n\n\tval = pmbus_data2reg(data, &s, val);\n\n\treturn _pmbus_write_word_data(client, s.page, PMBUS_VOUT_COMMAND, (u16)val);\n}\n\nstatic int pmbus_regulator_list_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t unsigned int selector)\n{\n\tstruct device *dev = rdev_get_dev(rdev);\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tint val, low, high;\n\n\tif (selector >= rdev->desc->n_voltages ||\n\t    selector < rdev->desc->linear_min_sel)\n\t\treturn -EINVAL;\n\n\tselector -= rdev->desc->linear_min_sel;\n\tval = DIV_ROUND_CLOSEST(rdev->desc->min_uV +\n\t\t\t\t(rdev->desc->uV_step * selector), 1000);  \n\n\tlow = pmbus_regulator_get_low_margin(client, rdev_get_id(rdev));\n\tif (low < 0)\n\t\treturn low;\n\n\thigh = pmbus_regulator_get_high_margin(client, rdev_get_id(rdev));\n\tif (high < 0)\n\t\treturn high;\n\n\tif (val >= low && val <= high)\n\t\treturn val * 1000;  \n\n\treturn 0;\n}\n\nconst struct regulator_ops pmbus_regulator_ops = {\n\t.enable = pmbus_regulator_enable,\n\t.disable = pmbus_regulator_disable,\n\t.is_enabled = pmbus_regulator_is_enabled,\n\t.get_error_flags = pmbus_regulator_get_error_flags,\n\t.get_status = pmbus_regulator_get_status,\n\t.get_voltage = pmbus_regulator_get_voltage,\n\t.set_voltage = pmbus_regulator_set_voltage,\n\t.list_voltage = pmbus_regulator_list_voltage,\n};\nEXPORT_SYMBOL_NS_GPL(pmbus_regulator_ops, PMBUS);\n\nstatic int pmbus_regulator_register(struct pmbus_data *data)\n{\n\tstruct device *dev = data->dev;\n\tconst struct pmbus_driver_info *info = data->info;\n\tconst struct pmbus_platform_data *pdata = dev_get_platdata(dev);\n\tint i;\n\n\tdata->rdevs = devm_kzalloc(dev, sizeof(struct regulator_dev *) * info->num_regulators,\n\t\t\t\t   GFP_KERNEL);\n\tif (!data->rdevs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < info->num_regulators; i++) {\n\t\tstruct regulator_config config = { };\n\n\t\tconfig.dev = dev;\n\t\tconfig.driver_data = data;\n\n\t\tif (pdata && pdata->reg_init_data)\n\t\t\tconfig.init_data = &pdata->reg_init_data[i];\n\n\t\tdata->rdevs[i] = devm_regulator_register(dev, &info->reg_desc[i],\n\t\t\t\t\t\t\t &config);\n\t\tif (IS_ERR(data->rdevs[i]))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(data->rdevs[i]),\n\t\t\t\t\t     \"Failed to register %s regulator\\n\",\n\t\t\t\t\t     info->reg_desc[i].name);\n\t}\n\n\treturn 0;\n}\n\nstatic int pmbus_regulator_notify(struct pmbus_data *data, int page, int event)\n{\n\t\tint j;\n\n\t\tfor (j = 0; j < data->info->num_regulators; j++) {\n\t\t\tif (page == rdev_get_id(data->rdevs[j])) {\n\t\t\t\tregulator_notifier_call_chain(data->rdevs[j], event, NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n}\n#else\nstatic int pmbus_regulator_register(struct pmbus_data *data)\n{\n\treturn 0;\n}\n\nstatic int pmbus_regulator_notify(struct pmbus_data *data, int page, int event)\n{\n\t\treturn 0;\n}\n#endif\n\nstatic int pmbus_write_smbalert_mask(struct i2c_client *client, u8 page, u8 reg, u8 val)\n{\n\treturn pmbus_write_word_data(client, page, PMBUS_SMBALERT_MASK, reg | (val << 8));\n}\n\nstatic irqreturn_t pmbus_fault_handler(int irq, void *pdata)\n{\n\tstruct pmbus_data *data = pdata;\n\tstruct i2c_client *client = to_i2c_client(data->dev);\n\n\tint i, status, event;\n\tmutex_lock(&data->update_lock);\n\tfor (i = 0; i < data->info->pages; i++) {\n\t\t_pmbus_get_flags(data, i, &status, &event, true);\n\n\t\tif (event)\n\t\t\tpmbus_regulator_notify(data, i, event);\n\t}\n\n\tpmbus_clear_faults(client);\n\tmutex_unlock(&data->update_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pmbus_irq_setup(struct i2c_client *client, struct pmbus_data *data)\n{\n\tstruct device *dev = &client->dev;\n\tconst struct pmbus_status_category *cat;\n\tconst struct pmbus_status_assoc *bit;\n\tint i, j, err, func;\n\tu8 mask;\n\n\tstatic const u8 misc_status[] = {PMBUS_STATUS_CML, PMBUS_STATUS_OTHER,\n\t\t\t\t\t PMBUS_STATUS_MFR_SPECIFIC, PMBUS_STATUS_FAN_12,\n\t\t\t\t\t PMBUS_STATUS_FAN_34};\n\n\tif (!client->irq)\n\t\treturn 0;\n\n\tfor (i = 0; i < data->info->pages; i++) {\n\t\tfunc = data->info->func[i];\n\n\t\tfor (j = 0; j < ARRAY_SIZE(pmbus_status_flag_map); j++) {\n\t\t\tcat = &pmbus_status_flag_map[j];\n\t\t\tif (!(func & cat->func))\n\t\t\t\tcontinue;\n\t\t\tmask = 0;\n\t\t\tfor (bit = cat->bits; bit->pflag; bit++)\n\t\t\t\tmask |= bit->pflag;\n\n\t\t\terr = pmbus_write_smbalert_mask(client, i, cat->reg, ~mask);\n\t\t\tif (err)\n\t\t\t\tdev_dbg_once(dev, \"Failed to set smbalert for reg 0x%02x\\n\",\n\t\t\t\t\t     cat->reg);\n\t\t}\n\n\t\tfor (j = 0; j < ARRAY_SIZE(misc_status); j++)\n\t\t\tpmbus_write_smbalert_mask(client, i, misc_status[j], 0xff);\n\t}\n\n\t \n\terr = devm_request_threaded_irq(dev, client->irq, NULL, pmbus_fault_handler,\n\t\t\t\t\tIRQF_ONESHOT, \"pmbus-irq\", data);\n\tif (err) {\n\t\tdev_err(dev, \"failed to request an irq %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct dentry *pmbus_debugfs_dir;\t \n\n#if IS_ENABLED(CONFIG_DEBUG_FS)\nstatic int pmbus_debugfs_get(void *data, u64 *val)\n{\n\tint rc;\n\tstruct pmbus_debugfs_entry *entry = data;\n\tstruct pmbus_data *pdata = i2c_get_clientdata(entry->client);\n\n\trc = mutex_lock_interruptible(&pdata->update_lock);\n\tif (rc)\n\t\treturn rc;\n\trc = _pmbus_read_byte_data(entry->client, entry->page, entry->reg);\n\tmutex_unlock(&pdata->update_lock);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*val = rc;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(pmbus_debugfs_ops, pmbus_debugfs_get, NULL,\n\t\t\t \"0x%02llx\\n\");\n\nstatic int pmbus_debugfs_get_status(void *data, u64 *val)\n{\n\tint rc;\n\tstruct pmbus_debugfs_entry *entry = data;\n\tstruct pmbus_data *pdata = i2c_get_clientdata(entry->client);\n\n\trc = mutex_lock_interruptible(&pdata->update_lock);\n\tif (rc)\n\t\treturn rc;\n\trc = pdata->read_status(entry->client, entry->page);\n\tmutex_unlock(&pdata->update_lock);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*val = rc;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(pmbus_debugfs_ops_status, pmbus_debugfs_get_status,\n\t\t\t NULL, \"0x%04llx\\n\");\n\nstatic ssize_t pmbus_debugfs_mfr_read(struct file *file, char __user *buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tint rc;\n\tstruct pmbus_debugfs_entry *entry = file->private_data;\n\tstruct pmbus_data *pdata = i2c_get_clientdata(entry->client);\n\tchar data[I2C_SMBUS_BLOCK_MAX + 2] = { 0 };\n\n\trc = mutex_lock_interruptible(&pdata->update_lock);\n\tif (rc)\n\t\treturn rc;\n\trc = pmbus_read_block_data(entry->client, entry->page, entry->reg,\n\t\t\t\t   data);\n\tmutex_unlock(&pdata->update_lock);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tdata[rc] = '\\n';\n\n\t \n\trc += 1;\n\n\treturn simple_read_from_buffer(buf, count, ppos, data, rc);\n}\n\nstatic const struct file_operations pmbus_debugfs_ops_mfr = {\n\t.llseek = noop_llseek,\n\t.read = pmbus_debugfs_mfr_read,\n\t.write = NULL,\n\t.open = simple_open,\n};\n\nstatic void pmbus_remove_debugfs(void *data)\n{\n\tstruct dentry *entry = data;\n\n\tdebugfs_remove_recursive(entry);\n}\n\nstatic int pmbus_init_debugfs(struct i2c_client *client,\n\t\t\t      struct pmbus_data *data)\n{\n\tint i, idx = 0;\n\tchar name[PMBUS_NAME_SIZE];\n\tstruct pmbus_debugfs_entry *entries;\n\n\tif (!pmbus_debugfs_dir)\n\t\treturn -ENODEV;\n\n\t \n\tdata->debugfs = debugfs_create_dir(dev_name(data->hwmon_dev),\n\t\t\t\t\t   pmbus_debugfs_dir);\n\tif (IS_ERR_OR_NULL(data->debugfs)) {\n\t\tdata->debugfs = NULL;\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tentries = devm_kcalloc(data->dev,\n\t\t\t       6 + data->info->pages * 10, sizeof(*entries),\n\t\t\t       GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\t \n\tif (pmbus_check_block_register(client, 0, PMBUS_MFR_ID)) {\n\t\tentries[idx].client = client;\n\t\tentries[idx].page = 0;\n\t\tentries[idx].reg = PMBUS_MFR_ID;\n\t\tdebugfs_create_file(\"mfr_id\", 0444, data->debugfs,\n\t\t\t\t    &entries[idx++],\n\t\t\t\t    &pmbus_debugfs_ops_mfr);\n\t}\n\n\tif (pmbus_check_block_register(client, 0, PMBUS_MFR_MODEL)) {\n\t\tentries[idx].client = client;\n\t\tentries[idx].page = 0;\n\t\tentries[idx].reg = PMBUS_MFR_MODEL;\n\t\tdebugfs_create_file(\"mfr_model\", 0444, data->debugfs,\n\t\t\t\t    &entries[idx++],\n\t\t\t\t    &pmbus_debugfs_ops_mfr);\n\t}\n\n\tif (pmbus_check_block_register(client, 0, PMBUS_MFR_REVISION)) {\n\t\tentries[idx].client = client;\n\t\tentries[idx].page = 0;\n\t\tentries[idx].reg = PMBUS_MFR_REVISION;\n\t\tdebugfs_create_file(\"mfr_revision\", 0444, data->debugfs,\n\t\t\t\t    &entries[idx++],\n\t\t\t\t    &pmbus_debugfs_ops_mfr);\n\t}\n\n\tif (pmbus_check_block_register(client, 0, PMBUS_MFR_LOCATION)) {\n\t\tentries[idx].client = client;\n\t\tentries[idx].page = 0;\n\t\tentries[idx].reg = PMBUS_MFR_LOCATION;\n\t\tdebugfs_create_file(\"mfr_location\", 0444, data->debugfs,\n\t\t\t\t    &entries[idx++],\n\t\t\t\t    &pmbus_debugfs_ops_mfr);\n\t}\n\n\tif (pmbus_check_block_register(client, 0, PMBUS_MFR_DATE)) {\n\t\tentries[idx].client = client;\n\t\tentries[idx].page = 0;\n\t\tentries[idx].reg = PMBUS_MFR_DATE;\n\t\tdebugfs_create_file(\"mfr_date\", 0444, data->debugfs,\n\t\t\t\t    &entries[idx++],\n\t\t\t\t    &pmbus_debugfs_ops_mfr);\n\t}\n\n\tif (pmbus_check_block_register(client, 0, PMBUS_MFR_SERIAL)) {\n\t\tentries[idx].client = client;\n\t\tentries[idx].page = 0;\n\t\tentries[idx].reg = PMBUS_MFR_SERIAL;\n\t\tdebugfs_create_file(\"mfr_serial\", 0444, data->debugfs,\n\t\t\t\t    &entries[idx++],\n\t\t\t\t    &pmbus_debugfs_ops_mfr);\n\t}\n\n\t \n\tfor (i = 0; i < data->info->pages; ++i) {\n\t\t \n\t\tif (!i || pmbus_check_status_register(client, i)) {\n\t\t\t \n\t\t\tentries[idx].client = client;\n\t\t\tentries[idx].page = i;\n\t\t\tscnprintf(name, PMBUS_NAME_SIZE, \"status%d\", i);\n\t\t\tdebugfs_create_file(name, 0444, data->debugfs,\n\t\t\t\t\t    &entries[idx++],\n\t\t\t\t\t    &pmbus_debugfs_ops_status);\n\t\t}\n\n\t\tif (data->info->func[i] & PMBUS_HAVE_STATUS_VOUT) {\n\t\t\tentries[idx].client = client;\n\t\t\tentries[idx].page = i;\n\t\t\tentries[idx].reg = PMBUS_STATUS_VOUT;\n\t\t\tscnprintf(name, PMBUS_NAME_SIZE, \"status%d_vout\", i);\n\t\t\tdebugfs_create_file(name, 0444, data->debugfs,\n\t\t\t\t\t    &entries[idx++],\n\t\t\t\t\t    &pmbus_debugfs_ops);\n\t\t}\n\n\t\tif (data->info->func[i] & PMBUS_HAVE_STATUS_IOUT) {\n\t\t\tentries[idx].client = client;\n\t\t\tentries[idx].page = i;\n\t\t\tentries[idx].reg = PMBUS_STATUS_IOUT;\n\t\t\tscnprintf(name, PMBUS_NAME_SIZE, \"status%d_iout\", i);\n\t\t\tdebugfs_create_file(name, 0444, data->debugfs,\n\t\t\t\t\t    &entries[idx++],\n\t\t\t\t\t    &pmbus_debugfs_ops);\n\t\t}\n\n\t\tif (data->info->func[i] & PMBUS_HAVE_STATUS_INPUT) {\n\t\t\tentries[idx].client = client;\n\t\t\tentries[idx].page = i;\n\t\t\tentries[idx].reg = PMBUS_STATUS_INPUT;\n\t\t\tscnprintf(name, PMBUS_NAME_SIZE, \"status%d_input\", i);\n\t\t\tdebugfs_create_file(name, 0444, data->debugfs,\n\t\t\t\t\t    &entries[idx++],\n\t\t\t\t\t    &pmbus_debugfs_ops);\n\t\t}\n\n\t\tif (data->info->func[i] & PMBUS_HAVE_STATUS_TEMP) {\n\t\t\tentries[idx].client = client;\n\t\t\tentries[idx].page = i;\n\t\t\tentries[idx].reg = PMBUS_STATUS_TEMPERATURE;\n\t\t\tscnprintf(name, PMBUS_NAME_SIZE, \"status%d_temp\", i);\n\t\t\tdebugfs_create_file(name, 0444, data->debugfs,\n\t\t\t\t\t    &entries[idx++],\n\t\t\t\t\t    &pmbus_debugfs_ops);\n\t\t}\n\n\t\tif (pmbus_check_byte_register(client, i, PMBUS_STATUS_CML)) {\n\t\t\tentries[idx].client = client;\n\t\t\tentries[idx].page = i;\n\t\t\tentries[idx].reg = PMBUS_STATUS_CML;\n\t\t\tscnprintf(name, PMBUS_NAME_SIZE, \"status%d_cml\", i);\n\t\t\tdebugfs_create_file(name, 0444, data->debugfs,\n\t\t\t\t\t    &entries[idx++],\n\t\t\t\t\t    &pmbus_debugfs_ops);\n\t\t}\n\n\t\tif (pmbus_check_byte_register(client, i, PMBUS_STATUS_OTHER)) {\n\t\t\tentries[idx].client = client;\n\t\t\tentries[idx].page = i;\n\t\t\tentries[idx].reg = PMBUS_STATUS_OTHER;\n\t\t\tscnprintf(name, PMBUS_NAME_SIZE, \"status%d_other\", i);\n\t\t\tdebugfs_create_file(name, 0444, data->debugfs,\n\t\t\t\t\t    &entries[idx++],\n\t\t\t\t\t    &pmbus_debugfs_ops);\n\t\t}\n\n\t\tif (pmbus_check_byte_register(client, i,\n\t\t\t\t\t      PMBUS_STATUS_MFR_SPECIFIC)) {\n\t\t\tentries[idx].client = client;\n\t\t\tentries[idx].page = i;\n\t\t\tentries[idx].reg = PMBUS_STATUS_MFR_SPECIFIC;\n\t\t\tscnprintf(name, PMBUS_NAME_SIZE, \"status%d_mfr\", i);\n\t\t\tdebugfs_create_file(name, 0444, data->debugfs,\n\t\t\t\t\t    &entries[idx++],\n\t\t\t\t\t    &pmbus_debugfs_ops);\n\t\t}\n\n\t\tif (data->info->func[i] & PMBUS_HAVE_STATUS_FAN12) {\n\t\t\tentries[idx].client = client;\n\t\t\tentries[idx].page = i;\n\t\t\tentries[idx].reg = PMBUS_STATUS_FAN_12;\n\t\t\tscnprintf(name, PMBUS_NAME_SIZE, \"status%d_fan12\", i);\n\t\t\tdebugfs_create_file(name, 0444, data->debugfs,\n\t\t\t\t\t    &entries[idx++],\n\t\t\t\t\t    &pmbus_debugfs_ops);\n\t\t}\n\n\t\tif (data->info->func[i] & PMBUS_HAVE_STATUS_FAN34) {\n\t\t\tentries[idx].client = client;\n\t\t\tentries[idx].page = i;\n\t\t\tentries[idx].reg = PMBUS_STATUS_FAN_34;\n\t\t\tscnprintf(name, PMBUS_NAME_SIZE, \"status%d_fan34\", i);\n\t\t\tdebugfs_create_file(name, 0444, data->debugfs,\n\t\t\t\t\t    &entries[idx++],\n\t\t\t\t\t    &pmbus_debugfs_ops);\n\t\t}\n\t}\n\n\treturn devm_add_action_or_reset(data->dev,\n\t\t\t\t\tpmbus_remove_debugfs, data->debugfs);\n}\n#else\nstatic int pmbus_init_debugfs(struct i2c_client *client,\n\t\t\t      struct pmbus_data *data)\n{\n\treturn 0;\n}\n#endif\t \n\nint pmbus_do_probe(struct i2c_client *client, struct pmbus_driver_info *info)\n{\n\tstruct device *dev = &client->dev;\n\tconst struct pmbus_platform_data *pdata = dev_get_platdata(dev);\n\tstruct pmbus_data *data;\n\tsize_t groups_num = 0;\n\tint ret;\n\tint i;\n\tchar *name;\n\n\tif (!info)\n\t\treturn -ENODEV;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WRITE_BYTE\n\t\t\t\t     | I2C_FUNC_SMBUS_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (info->groups)\n\t\twhile (info->groups[groups_num])\n\t\t\tgroups_num++;\n\n\tdata->groups = devm_kcalloc(dev, groups_num + 2, sizeof(void *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!data->groups)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\tdata->dev = dev;\n\n\tif (pdata)\n\t\tdata->flags = pdata->flags;\n\tdata->info = info;\n\tdata->currpage = -1;\n\tdata->currphase = -1;\n\n\tfor (i = 0; i < ARRAY_SIZE(data->vout_low); i++) {\n\t\tdata->vout_low[i] = -1;\n\t\tdata->vout_high[i] = -1;\n\t}\n\n\tret = pmbus_init_common(client, data, info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pmbus_find_attributes(client, data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!data->num_attributes) {\n\t\tdev_err(dev, \"No attributes found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tname = devm_kstrdup(dev, client->name, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tstrreplace(name, '-', '_');\n\n\tdata->groups[0] = &data->group;\n\tmemcpy(data->groups + 1, info->groups, sizeof(void *) * groups_num);\n\tdata->hwmon_dev = devm_hwmon_device_register_with_groups(dev,\n\t\t\t\t\tname, data, data->groups);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\tdev_err(dev, \"Failed to register hwmon device\\n\");\n\t\treturn PTR_ERR(data->hwmon_dev);\n\t}\n\n\tret = pmbus_regulator_register(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pmbus_irq_setup(client, data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pmbus_init_debugfs(client, data);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to register debugfs\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_do_probe, PMBUS);\n\nstruct dentry *pmbus_get_debugfs_dir(struct i2c_client *client)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\n\treturn data->debugfs;\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_get_debugfs_dir, PMBUS);\n\nint pmbus_lock_interruptible(struct i2c_client *client)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\n\treturn mutex_lock_interruptible(&data->update_lock);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_lock_interruptible, PMBUS);\n\nvoid pmbus_unlock(struct i2c_client *client)\n{\n\tstruct pmbus_data *data = i2c_get_clientdata(client);\n\n\tmutex_unlock(&data->update_lock);\n}\nEXPORT_SYMBOL_NS_GPL(pmbus_unlock, PMBUS);\n\nstatic int __init pmbus_core_init(void)\n{\n\tpmbus_debugfs_dir = debugfs_create_dir(\"pmbus\", NULL);\n\tif (IS_ERR(pmbus_debugfs_dir))\n\t\tpmbus_debugfs_dir = NULL;\n\n\treturn 0;\n}\n\nstatic void __exit pmbus_core_exit(void)\n{\n\tdebugfs_remove_recursive(pmbus_debugfs_dir);\n}\n\nmodule_init(pmbus_core_init);\nmodule_exit(pmbus_core_exit);\n\nMODULE_AUTHOR(\"Guenter Roeck\");\nMODULE_DESCRIPTION(\"PMBus core driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}