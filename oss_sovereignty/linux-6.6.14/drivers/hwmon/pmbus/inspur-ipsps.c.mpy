{
  "module_name": "inspur-ipsps.c",
  "hash_id": "9d4763edcf96255ed21d6c1bc816ef3460824729d0be9ae68d71e6513aa0d8da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/inspur-ipsps.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/pmbus.h>\n#include <linux/hwmon-sysfs.h>\n\n#include \"pmbus.h\"\n\n#define IPSPS_REG_VENDOR_ID\t0x99\n#define IPSPS_REG_MODEL\t\t0x9A\n#define IPSPS_REG_FW_VERSION\t0x9B\n#define IPSPS_REG_PN\t\t0x9C\n#define IPSPS_REG_SN\t\t0x9E\n#define IPSPS_REG_HW_VERSION\t0xB0\n#define IPSPS_REG_MODE\t\t0xFC\n\n#define MODE_ACTIVE\t\t0x55\n#define MODE_STANDBY\t\t0x0E\n#define MODE_REDUNDANCY\t\t0x00\n\n#define MODE_ACTIVE_STRING\t\t\"active\"\n#define MODE_STANDBY_STRING\t\t\"standby\"\n#define MODE_REDUNDANCY_STRING\t\t\"redundancy\"\n\nenum ipsps_index {\n\tvendor,\n\tmodel,\n\tfw_version,\n\tpart_number,\n\tserial_number,\n\thw_version,\n\tmode,\n\tnum_regs,\n};\n\nstatic const u8 ipsps_regs[num_regs] = {\n\t[vendor] = IPSPS_REG_VENDOR_ID,\n\t[model] = IPSPS_REG_MODEL,\n\t[fw_version] = IPSPS_REG_FW_VERSION,\n\t[part_number] = IPSPS_REG_PN,\n\t[serial_number] = IPSPS_REG_SN,\n\t[hw_version] = IPSPS_REG_HW_VERSION,\n\t[mode] = IPSPS_REG_MODE,\n};\n\nstatic ssize_t ipsps_string_show(struct device *dev,\n\t\t\t\t struct device_attribute *devattr,\n\t\t\t\t char *buf)\n{\n\tu8 reg;\n\tint rc;\n\tchar *p;\n\tchar data[I2C_SMBUS_BLOCK_MAX + 1];\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\n\treg = ipsps_regs[attr->index];\n\trc = i2c_smbus_read_block_data(client, reg, data);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tp = memscan(data, '#', rc);\n\t*p = '\\0';\n\n\treturn sysfs_emit(buf, \"%s\\n\", data);\n}\n\nstatic ssize_t ipsps_fw_version_show(struct device *dev,\n\t\t\t\t     struct device_attribute *devattr,\n\t\t\t\t     char *buf)\n{\n\tu8 reg;\n\tint rc;\n\tu8 data[I2C_SMBUS_BLOCK_MAX] = { 0 };\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\n\treg = ipsps_regs[attr->index];\n\trc = i2c_smbus_read_block_data(client, reg, data);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (rc != 6)\n\t\treturn -EPROTO;\n\n\treturn sysfs_emit(buf, \"%u.%02u%u-%u.%02u\\n\",\n\t\t\t  data[1], data[2] , data[3] ,\n\t\t\t  data[4], data[5] );\n}\n\nstatic ssize_t ipsps_mode_show(struct device *dev,\n\t\t\t       struct device_attribute *devattr, char *buf)\n{\n\tu8 reg;\n\tint rc;\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\n\treg = ipsps_regs[attr->index];\n\trc = i2c_smbus_read_byte_data(client, reg);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tswitch (rc) {\n\tcase MODE_ACTIVE:\n\t\treturn sysfs_emit(buf, \"[%s] %s %s\\n\",\n\t\t\t\t  MODE_ACTIVE_STRING,\n\t\t\t\t  MODE_STANDBY_STRING, MODE_REDUNDANCY_STRING);\n\tcase MODE_STANDBY:\n\t\treturn sysfs_emit(buf, \"%s [%s] %s\\n\",\n\t\t\t\t  MODE_ACTIVE_STRING,\n\t\t\t\t  MODE_STANDBY_STRING, MODE_REDUNDANCY_STRING);\n\tcase MODE_REDUNDANCY:\n\t\treturn sysfs_emit(buf, \"%s %s [%s]\\n\",\n\t\t\t\t  MODE_ACTIVE_STRING,\n\t\t\t\t  MODE_STANDBY_STRING, MODE_REDUNDANCY_STRING);\n\tdefault:\n\t\treturn sysfs_emit(buf, \"unspecified\\n\");\n\t}\n}\n\nstatic ssize_t ipsps_mode_store(struct device *dev,\n\t\t\t\tstruct device_attribute *devattr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tu8 reg;\n\tint rc;\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\n\treg = ipsps_regs[attr->index];\n\tif (sysfs_streq(MODE_STANDBY_STRING, buf)) {\n\t\trc = i2c_smbus_write_byte_data(client, reg,\n\t\t\t\t\t       MODE_STANDBY);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn count;\n\t} else if (sysfs_streq(MODE_ACTIVE_STRING, buf)) {\n\t\trc = i2c_smbus_write_byte_data(client, reg,\n\t\t\t\t\t       MODE_ACTIVE);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn count;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(vendor, ipsps_string, vendor);\nstatic SENSOR_DEVICE_ATTR_RO(model, ipsps_string, model);\nstatic SENSOR_DEVICE_ATTR_RO(part_number, ipsps_string, part_number);\nstatic SENSOR_DEVICE_ATTR_RO(serial_number, ipsps_string, serial_number);\nstatic SENSOR_DEVICE_ATTR_RO(hw_version, ipsps_string, hw_version);\nstatic SENSOR_DEVICE_ATTR_RO(fw_version, ipsps_fw_version, fw_version);\nstatic SENSOR_DEVICE_ATTR_RW(mode, ipsps_mode, mode);\n\nstatic struct attribute *ipsps_attrs[] = {\n\t&sensor_dev_attr_vendor.dev_attr.attr,\n\t&sensor_dev_attr_model.dev_attr.attr,\n\t&sensor_dev_attr_part_number.dev_attr.attr,\n\t&sensor_dev_attr_serial_number.dev_attr.attr,\n\t&sensor_dev_attr_hw_version.dev_attr.attr,\n\t&sensor_dev_attr_fw_version.dev_attr.attr,\n\t&sensor_dev_attr_mode.dev_attr.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(ipsps);\n\nstatic struct pmbus_driver_info ipsps_info = {\n\t.pages = 1,\n\t.func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_VOUT | PMBUS_HAVE_IOUT |\n\t\tPMBUS_HAVE_IIN | PMBUS_HAVE_POUT | PMBUS_HAVE_PIN |\n\t\tPMBUS_HAVE_FAN12 | PMBUS_HAVE_TEMP | PMBUS_HAVE_TEMP2 |\n\t\tPMBUS_HAVE_TEMP3 | PMBUS_HAVE_STATUS_VOUT |\n\t\tPMBUS_HAVE_STATUS_IOUT | PMBUS_HAVE_STATUS_INPUT |\n\t\tPMBUS_HAVE_STATUS_TEMP | PMBUS_HAVE_STATUS_FAN12,\n\t.groups = ipsps_groups,\n};\n\nstatic struct pmbus_platform_data ipsps_pdata = {\n\t.flags = PMBUS_SKIP_STATUS_CHECK,\n};\n\nstatic int ipsps_probe(struct i2c_client *client)\n{\n\tclient->dev.platform_data = &ipsps_pdata;\n\treturn pmbus_do_probe(client, &ipsps_info);\n}\n\nstatic const struct i2c_device_id ipsps_id[] = {\n\t{ \"ipsps1\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ipsps_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ipsps_of_match[] = {\n\t{ .compatible = \"inspur,ipsps1\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ipsps_of_match);\n#endif\n\nstatic struct i2c_driver ipsps_driver = {\n\t.driver = {\n\t\t.name = \"inspur-ipsps\",\n\t\t.of_match_table = of_match_ptr(ipsps_of_match),\n\t},\n\t.probe = ipsps_probe,\n\t.id_table = ipsps_id,\n};\n\nmodule_i2c_driver(ipsps_driver);\n\nMODULE_AUTHOR(\"John Wang\");\nMODULE_DESCRIPTION(\"PMBus driver for Inspur Power System power supplies\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}