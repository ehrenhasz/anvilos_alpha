{
  "module_name": "fsp-3y.c",
  "hash_id": "2b65c5f80f808f2f8962173450e56d047a73a500294af9b6ca09f515b6c179a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/fsp-3y.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include \"pmbus.h\"\n\n#define YM2151_PAGE_12V_LOG\t0x00\n#define YM2151_PAGE_12V_REAL\t0x00\n#define YM2151_PAGE_5VSB_LOG\t0x01\n#define YM2151_PAGE_5VSB_REAL\t0x20\n#define YH5151E_PAGE_12V_LOG\t0x00\n#define YH5151E_PAGE_12V_REAL\t0x00\n#define YH5151E_PAGE_5V_LOG\t0x01\n#define YH5151E_PAGE_5V_REAL\t0x10\n#define YH5151E_PAGE_3V3_LOG\t0x02\n#define YH5151E_PAGE_3V3_REAL\t0x11\n\nenum chips {\n\tym2151e,\n\tyh5151e\n};\n\nstruct fsp3y_data {\n\tstruct pmbus_driver_info info;\n\tint chip;\n\tint page;\n\n\tbool vout_linear_11;\n};\n\n#define to_fsp3y_data(x) container_of(x, struct fsp3y_data, info)\n\nstatic int page_log_to_page_real(int page_log, enum chips chip)\n{\n\tswitch (chip) {\n\tcase ym2151e:\n\t\tswitch (page_log) {\n\t\tcase YM2151_PAGE_12V_LOG:\n\t\t\treturn YM2151_PAGE_12V_REAL;\n\t\tcase YM2151_PAGE_5VSB_LOG:\n\t\t\treturn YM2151_PAGE_5VSB_REAL;\n\t\t}\n\t\treturn -EINVAL;\n\tcase yh5151e:\n\t\tswitch (page_log) {\n\t\tcase YH5151E_PAGE_12V_LOG:\n\t\t\treturn YH5151E_PAGE_12V_REAL;\n\t\tcase YH5151E_PAGE_5V_LOG:\n\t\t\treturn YH5151E_PAGE_5V_REAL;\n\t\tcase YH5151E_PAGE_3V3_LOG:\n\t\t\treturn YH5151E_PAGE_3V3_REAL;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int set_page(struct i2c_client *client, int page_log)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct fsp3y_data *data = to_fsp3y_data(info);\n\tint rv;\n\tint page_real;\n\n\tif (page_log < 0)\n\t\treturn 0;\n\n\tpage_real = page_log_to_page_real(page_log, data->chip);\n\tif (page_real < 0)\n\t\treturn page_real;\n\n\tif (data->page != page_real) {\n\t\trv = i2c_smbus_write_byte_data(client, PMBUS_PAGE, page_real);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\n\t\tdata->page = page_real;\n\n\t\t \n\t\tusleep_range(20000, 30000);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsp3y_read_byte_data(struct i2c_client *client, int page, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct fsp3y_data *data = to_fsp3y_data(info);\n\tint rv;\n\n\t \n\tif (data->vout_linear_11 && reg == PMBUS_VOUT_MODE)\n\t\treturn 0x1A;\n\n\trv = set_page(client, page);\n\tif (rv < 0)\n\t\treturn rv;\n\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic int fsp3y_read_word_data(struct i2c_client *client, int page, int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct fsp3y_data *data = to_fsp3y_data(info);\n\tint rv;\n\n\t \n\tswitch (reg) {\n\tcase PMBUS_READ_FAN_SPEED_1:\n\tcase PMBUS_READ_IIN:\n\tcase PMBUS_READ_IOUT:\n\tcase PMBUS_READ_PIN:\n\tcase PMBUS_READ_POUT:\n\tcase PMBUS_READ_TEMPERATURE_1:\n\tcase PMBUS_READ_TEMPERATURE_2:\n\tcase PMBUS_READ_TEMPERATURE_3:\n\tcase PMBUS_READ_VIN:\n\tcase PMBUS_READ_VOUT:\n\tcase PMBUS_STATUS_WORD:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\trv = set_page(client, page);\n\tif (rv < 0)\n\t\treturn rv;\n\n\trv = i2c_smbus_read_word_data(client, reg);\n\tif (rv < 0)\n\t\treturn rv;\n\n\t \n\tif (data->vout_linear_11 && reg == PMBUS_READ_VOUT)\n\t\trv = sign_extend32(rv, 10) & 0xffff;\n\n\treturn rv;\n}\n\nstatic struct pmbus_driver_info fsp3y_info[] = {\n\t[ym2151e] = {\n\t\t.pages = 2,\n\t\t.func[YM2151_PAGE_12V_LOG] =\n\t\t\tPMBUS_HAVE_VOUT | PMBUS_HAVE_IOUT |\n\t\t\tPMBUS_HAVE_PIN | PMBUS_HAVE_POUT  |\n\t\t\tPMBUS_HAVE_TEMP | PMBUS_HAVE_TEMP2 |\n\t\t\tPMBUS_HAVE_VIN | PMBUS_HAVE_IIN |\n\t\t\tPMBUS_HAVE_FAN12,\n\t\t.func[YM2151_PAGE_5VSB_LOG] =\n\t\t\tPMBUS_HAVE_VOUT | PMBUS_HAVE_IOUT,\n\t\t.read_word_data = fsp3y_read_word_data,\n\t\t.read_byte_data = fsp3y_read_byte_data,\n\t},\n\t[yh5151e] = {\n\t\t.pages = 3,\n\t\t.func[YH5151E_PAGE_12V_LOG] =\n\t\t\tPMBUS_HAVE_VOUT | PMBUS_HAVE_IOUT |\n\t\t\tPMBUS_HAVE_POUT  |\n\t\t\tPMBUS_HAVE_TEMP | PMBUS_HAVE_TEMP2 | PMBUS_HAVE_TEMP3,\n\t\t.func[YH5151E_PAGE_5V_LOG] =\n\t\t\tPMBUS_HAVE_VOUT | PMBUS_HAVE_IOUT |\n\t\t\tPMBUS_HAVE_POUT,\n\t\t.func[YH5151E_PAGE_3V3_LOG] =\n\t\t\tPMBUS_HAVE_VOUT | PMBUS_HAVE_IOUT |\n\t\t\tPMBUS_HAVE_POUT,\n\t\t.read_word_data = fsp3y_read_word_data,\n\t\t.read_byte_data = fsp3y_read_byte_data,\n\t}\n};\n\nstatic int fsp3y_detect(struct i2c_client *client)\n{\n\tint rv;\n\tu8 buf[I2C_SMBUS_BLOCK_MAX + 1];\n\n\trv = i2c_smbus_read_block_data(client, PMBUS_MFR_MODEL, buf);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tbuf[rv] = '\\0';\n\n\tif (rv == 8) {\n\t\tif (!strcmp(buf, \"YM-2151E\"))\n\t\t\treturn ym2151e;\n\t\telse if (!strcmp(buf, \"YH-5151E\"))\n\t\t\treturn yh5151e;\n\t}\n\n\tdev_err(&client->dev, \"Unsupported model %.*s\\n\", rv, buf);\n\treturn -ENODEV;\n}\n\nstatic const struct i2c_device_id fsp3y_id[] = {\n\t{\"ym2151e\", ym2151e},\n\t{\"yh5151e\", yh5151e},\n\t{ }\n};\n\nstatic int fsp3y_probe(struct i2c_client *client)\n{\n\tstruct fsp3y_data *data;\n\tconst struct i2c_device_id *id;\n\tint rv;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct fsp3y_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->chip = fsp3y_detect(client);\n\tif (data->chip < 0)\n\t\treturn data->chip;\n\n\tid = i2c_match_id(fsp3y_id, client);\n\tif (data->chip != id->driver_data)\n\t\tdev_warn(&client->dev, \"Device mismatch: Configured %s (%d), detected %d\\n\",\n\t\t\t id->name, (int)id->driver_data, data->chip);\n\n\trv = i2c_smbus_read_byte_data(client, PMBUS_PAGE);\n\tif (rv < 0)\n\t\treturn rv;\n\tdata->page = rv;\n\n\tdata->info = fsp3y_info[data->chip];\n\n\t \n\tdata->vout_linear_11 = false;\n\tif (data->chip == yh5151e) {\n\t\trv = i2c_smbus_read_byte_data(client, PMBUS_VOUT_MODE);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\n\t\tif (rv == 0xFF)\n\t\t\tdata->vout_linear_11 = true;\n\t}\n\n\treturn pmbus_do_probe(client, &data->info);\n}\n\nMODULE_DEVICE_TABLE(i2c, fsp3y_id);\n\nstatic struct i2c_driver fsp3y_driver = {\n\t.driver = {\n\t\t   .name = \"fsp3y\",\n\t\t   },\n\t.probe = fsp3y_probe,\n\t.id_table = fsp3y_id\n};\n\nmodule_i2c_driver(fsp3y_driver);\n\nMODULE_AUTHOR(\"V\u00e1clav Kubern\u00e1t\");\nMODULE_DESCRIPTION(\"PMBus driver for FSP/3Y-Power power supplies\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}