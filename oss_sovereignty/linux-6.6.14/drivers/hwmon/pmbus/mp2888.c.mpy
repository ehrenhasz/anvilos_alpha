{
  "module_name": "mp2888.c",
  "hash_id": "860e5ef7e6d005f16248bcb3e9a57427d45f41b484765eda27ab8ef933c97da1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/mp2888.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include \"pmbus.h\"\n\n \n#define MP2888_MFR_SYS_CONFIG\t0x44\n#define MP2888_MFR_READ_CS1_2\t0x73\n#define MP2888_MFR_READ_CS3_4\t0x74\n#define MP2888_MFR_READ_CS5_6\t0x75\n#define MP2888_MFR_READ_CS7_8\t0x76\n#define MP2888_MFR_READ_CS9_10\t0x77\n#define MP2888_MFR_VR_CONFIG1\t0xe1\n\n#define MP2888_TOTAL_CURRENT_RESOLUTION\tBIT(3)\n#define MP2888_PHASE_CURRENT_RESOLUTION\tBIT(4)\n#define MP2888_DRMOS_KCS\t\tGENMASK(2, 0)\n#define MP2888_TEMP_UNIT\t\t10\n#define MP2888_MAX_PHASE\t\t10\n\nstruct mp2888_data {\n\tstruct pmbus_driver_info info;\n\tint total_curr_resolution;\n\tint phase_curr_resolution;\n\tint curr_sense_gain;\n};\n\n#define to_mp2888_data(x)\tcontainer_of(x, struct mp2888_data, info)\n\nstatic int mp2888_read_byte_data(struct i2c_client *client, int page, int reg)\n{\n\tswitch (reg) {\n\tcase PMBUS_VOUT_MODE:\n\t\t \n\t\treturn PB_VOUT_MODE_DIRECT;\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n}\n\nstatic int\nmp2888_current_sense_gain_and_resolution_get(struct i2c_client *client, struct mp2888_data *data)\n{\n\tint ret;\n\n\t \n\tret = i2c_smbus_read_word_data(client, MP2888_MFR_SYS_CONFIG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret & MP2888_DRMOS_KCS) {\n\tcase 0:\n\t\tdata->curr_sense_gain = 85;\n\t\tbreak;\n\tcase 1:\n\t\tdata->curr_sense_gain = 97;\n\t\tbreak;\n\tcase 2:\n\t\tdata->curr_sense_gain = 100;\n\t\tbreak;\n\tcase 3:\n\t\tdata->curr_sense_gain = 50;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdata->total_curr_resolution = (ret & MP2888_TOTAL_CURRENT_RESOLUTION) >> 3;\n\tdata->phase_curr_resolution = (ret & MP2888_PHASE_CURRENT_RESOLUTION) >> 4;\n\n\treturn 0;\n}\n\nstatic int\nmp2888_read_phase(struct i2c_client *client, struct mp2888_data *data, int page, int phase, u8 reg)\n{\n\tint ret;\n\n\tret = pmbus_read_word_data(client, page, phase, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!((phase + 1) % 2))\n\t\tret >>= 8;\n\tret &= 0xff;\n\n\t \n\tret = DIV_ROUND_CLOSEST(ret * 200 - 19600, data->curr_sense_gain);\n\t \n\tret = (data->total_curr_resolution) ? ret * 2 : ret;\n\treturn ret;\n}\n\nstatic int\nmp2888_read_phases(struct i2c_client *client, struct mp2888_data *data, int page, int phase)\n{\n\tint ret;\n\n\tswitch (phase) {\n\tcase 0 ... 1:\n\t\tret = mp2888_read_phase(client, data, page, phase, MP2888_MFR_READ_CS1_2);\n\t\tbreak;\n\tcase 2 ... 3:\n\t\tret = mp2888_read_phase(client, data, page, phase, MP2888_MFR_READ_CS3_4);\n\t\tbreak;\n\tcase 4 ... 5:\n\t\tret = mp2888_read_phase(client, data, page, phase, MP2888_MFR_READ_CS5_6);\n\t\tbreak;\n\tcase 6 ... 7:\n\t\tret = mp2888_read_phase(client, data, page, phase, MP2888_MFR_READ_CS7_8);\n\t\tbreak;\n\tcase 8 ... 9:\n\t\tret = mp2888_read_phase(client, data, page, phase, MP2888_MFR_READ_CS9_10);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n\treturn ret;\n}\n\nstatic int mp2888_read_word_data(struct i2c_client *client, int page, int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct mp2888_data *data = to_mp2888_data(info);\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_READ_VIN:\n\t\tret = pmbus_read_word_data(client, page, phase, reg);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = (ret & GENMASK(9, 0)) | ((ret & GENMASK(31, 10)) << 1);\n\t\tbreak;\n\tcase PMBUS_OT_WARN_LIMIT:\n\t\tret = pmbus_read_word_data(client, page, phase, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tret *= MP2888_TEMP_UNIT;\n\t\tbreak;\n\tcase PMBUS_READ_IOUT:\n\t\tif (phase != 0xff)\n\t\t\treturn mp2888_read_phases(client, data, page, phase);\n\n\t\tret = pmbus_read_word_data(client, page, phase, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tret &= GENMASK(11, 0);\n\t\tret = data->total_curr_resolution ? ret * 2 : ret;\n\t\tbreak;\n\tcase PMBUS_IOUT_OC_WARN_LIMIT:\n\t\tret = pmbus_read_word_data(client, page, phase, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret &= GENMASK(9, 0);\n\t\t \n\t\tret = data->total_curr_resolution ? ret * 8 : ret * 4;\n\t\tbreak;\n\tcase PMBUS_READ_POUT:\n\tcase PMBUS_READ_PIN:\n\t\tret = pmbus_read_word_data(client, page, phase, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = data->total_curr_resolution ? ret : DIV_ROUND_CLOSEST(ret, 2);\n\t\tbreak;\n\tcase PMBUS_POUT_OP_WARN_LIMIT:\n\t\tret = pmbus_read_word_data(client, page, phase, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tret = data->total_curr_resolution ? ret * 2 : ret;\n\t\tbreak;\n\t \n\tcase PMBUS_OT_FAULT_LIMIT:\n\tcase PMBUS_UT_WARN_LIMIT:\n\tcase PMBUS_UT_FAULT_LIMIT:\n\tcase PMBUS_VIN_UV_FAULT_LIMIT:\n\tcase PMBUS_VOUT_UV_WARN_LIMIT:\n\tcase PMBUS_VOUT_OV_WARN_LIMIT:\n\tcase PMBUS_VOUT_UV_FAULT_LIMIT:\n\tcase PMBUS_VOUT_OV_FAULT_LIMIT:\n\tcase PMBUS_VIN_OV_WARN_LIMIT:\n\tcase PMBUS_IOUT_OC_LV_FAULT_LIMIT:\n\tcase PMBUS_IOUT_OC_FAULT_LIMIT:\n\tcase PMBUS_POUT_MAX:\n\tcase PMBUS_IOUT_UC_FAULT_LIMIT:\n\tcase PMBUS_POUT_OP_FAULT_LIMIT:\n\tcase PMBUS_PIN_OP_WARN_LIMIT:\n\tcase PMBUS_MFR_VIN_MIN:\n\tcase PMBUS_MFR_VOUT_MIN:\n\tcase PMBUS_MFR_VIN_MAX:\n\tcase PMBUS_MFR_VOUT_MAX:\n\tcase PMBUS_MFR_IIN_MAX:\n\tcase PMBUS_MFR_IOUT_MAX:\n\tcase PMBUS_MFR_PIN_MAX:\n\tcase PMBUS_MFR_POUT_MAX:\n\tcase PMBUS_MFR_MAX_TEMP_1:\n\t\treturn -ENXIO;\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n\n\treturn ret;\n}\n\nstatic int mp2888_write_word_data(struct i2c_client *client, int page, int reg, u16 word)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct mp2888_data *data = to_mp2888_data(info);\n\n\tswitch (reg) {\n\tcase PMBUS_OT_WARN_LIMIT:\n\t\tword = DIV_ROUND_CLOSEST(word, MP2888_TEMP_UNIT);\n\t\t \n\t\tword = clamp_val(word, 0, GENMASK(7, 0));\n\t\tbreak;\n\tcase PMBUS_IOUT_OC_WARN_LIMIT:\n\t\t \n\t\tword = data->total_curr_resolution ? DIV_ROUND_CLOSEST(word, 8) :\n\t\t       DIV_ROUND_CLOSEST(word, 4);\n\t\t \n\t\tword = clamp_val(word, 0, GENMASK(9, 0));\n\t\tbreak;\n\tcase PMBUS_POUT_OP_WARN_LIMIT:\n\t\t \n\t\tword = data->total_curr_resolution ? DIV_ROUND_CLOSEST(word, 4) :\n\t\t       DIV_ROUND_CLOSEST(word, 2);\n\t\t \n\t\tword = clamp_val(word, 0, GENMASK(9, 0));\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n\treturn pmbus_write_word_data(client, page, reg, word);\n}\n\nstatic int\nmp2888_identify_multiphase(struct i2c_client *client, struct mp2888_data *data,\n\t\t\t   struct pmbus_driver_info *info)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = i2c_smbus_read_word_data(client, MP2888_MFR_VR_CONFIG1);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tinfo->phases[0] = ret & GENMASK(3, 0);\n\n\t \n\tif (info->phases[0] > MP2888_MAX_PHASE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct pmbus_driver_info mp2888_info = {\n\t.pages = 1,\n\t.format[PSC_VOLTAGE_IN] = linear,\n\t.format[PSC_VOLTAGE_OUT] = direct,\n\t.format[PSC_TEMPERATURE] = direct,\n\t.format[PSC_CURRENT_IN] = linear,\n\t.format[PSC_CURRENT_OUT] = direct,\n\t.format[PSC_POWER] = direct,\n\t.m[PSC_TEMPERATURE] = 1,\n\t.R[PSC_TEMPERATURE] = 1,\n\t.m[PSC_VOLTAGE_OUT] = 1,\n\t.R[PSC_VOLTAGE_OUT] = 3,\n\t.m[PSC_CURRENT_OUT] = 4,\n\t.m[PSC_POWER] = 1,\n\t.func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT | PMBUS_HAVE_IOUT |\n\t\t   PMBUS_HAVE_STATUS_IOUT | PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP |\n\t\t   PMBUS_HAVE_POUT | PMBUS_HAVE_PIN | PMBUS_HAVE_STATUS_INPUT |\n\t\t   PMBUS_PHASE_VIRTUAL,\n\t.pfunc[0] = PMBUS_HAVE_IOUT,\n\t.pfunc[1] = PMBUS_HAVE_IOUT,\n\t.pfunc[2] = PMBUS_HAVE_IOUT,\n\t.pfunc[3] = PMBUS_HAVE_IOUT,\n\t.pfunc[4] = PMBUS_HAVE_IOUT,\n\t.pfunc[5] = PMBUS_HAVE_IOUT,\n\t.pfunc[6] = PMBUS_HAVE_IOUT,\n\t.pfunc[7] = PMBUS_HAVE_IOUT,\n\t.pfunc[8] = PMBUS_HAVE_IOUT,\n\t.pfunc[9] = PMBUS_HAVE_IOUT,\n\t.read_byte_data = mp2888_read_byte_data,\n\t.read_word_data = mp2888_read_word_data,\n\t.write_word_data = mp2888_write_word_data,\n};\n\nstatic int mp2888_probe(struct i2c_client *client)\n{\n\tstruct pmbus_driver_info *info;\n\tstruct mp2888_data *data;\n\tint ret;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct mp2888_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&data->info, &mp2888_info, sizeof(*info));\n\tinfo = &data->info;\n\n\t \n\tret = mp2888_identify_multiphase(client, data, info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mp2888_current_sense_gain_and_resolution_get(client, data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pmbus_do_probe(client, info);\n}\n\nstatic const struct i2c_device_id mp2888_id[] = {\n\t{\"mp2888\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, mp2888_id);\n\nstatic const struct of_device_id __maybe_unused mp2888_of_match[] = {\n\t{.compatible = \"mps,mp2888\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mp2888_of_match);\n\nstatic struct i2c_driver mp2888_driver = {\n\t.driver = {\n\t\t.name = \"mp2888\",\n\t\t.of_match_table = of_match_ptr(mp2888_of_match),\n\t},\n\t.probe = mp2888_probe,\n\t.id_table = mp2888_id,\n};\n\nmodule_i2c_driver(mp2888_driver);\n\nMODULE_AUTHOR(\"Vadim Pasternak <vadimp@nvidia.com>\");\nMODULE_DESCRIPTION(\"PMBus driver for MPS MP2888 device\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}