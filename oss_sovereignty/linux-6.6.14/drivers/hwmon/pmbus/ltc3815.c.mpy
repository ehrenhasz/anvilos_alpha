{
  "module_name": "ltc3815.c",
  "hash_id": "afce5df0e5451aea939935401d17530c256a78b8bddfa61ad23bdd0a11147fd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/ltc3815.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include \"pmbus.h\"\n\n#define LTC3815_MFR_IOUT_PEAK\t0xd7\n#define LTC3815_MFR_VOUT_PEAK\t0xdd\n#define LTC3815_MFR_VIN_PEAK\t0xde\n#define LTC3815_MFR_TEMP_PEAK\t0xdf\n#define LTC3815_MFR_IIN_PEAK\t0xe1\n#define LTC3815_MFR_SPECIAL_ID\t0xe7\n\n#define LTC3815_ID\t\t0x8000\n#define LTC3815_ID_MASK\t\t0xff00\n\nstatic int ltc3815_read_byte_data(struct i2c_client *client, int page, int reg)\n{\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_VOUT_MODE:\n\t\t \n\t\tret = 0x40;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ltc3815_write_byte(struct i2c_client *client, int page, u8 reg)\n{\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_CLEAR_FAULTS:\n\t\t \n\t\tret = pmbus_read_word_data(client, 0, 0xff, PMBUS_STATUS_WORD);\n\t\tif (ret > 0) {\n\t\t\tpmbus_write_word_data(client, 0, PMBUS_STATUS_WORD,\n\t\t\t\t\t      ret);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ltc3815_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t  int phase, int reg)\n{\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_READ_VIN_MAX:\n\t\tret = pmbus_read_word_data(client, page, phase,\n\t\t\t\t\t   LTC3815_MFR_VIN_PEAK);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_VOUT_MAX:\n\t\tret = pmbus_read_word_data(client, page, phase,\n\t\t\t\t\t   LTC3815_MFR_VOUT_PEAK);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_TEMP_MAX:\n\t\tret = pmbus_read_word_data(client, page, phase,\n\t\t\t\t\t   LTC3815_MFR_TEMP_PEAK);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_IOUT_MAX:\n\t\tret = pmbus_read_word_data(client, page, phase,\n\t\t\t\t\t   LTC3815_MFR_IOUT_PEAK);\n\t\tbreak;\n\tcase PMBUS_VIRT_READ_IIN_MAX:\n\t\tret = pmbus_read_word_data(client, page, phase,\n\t\t\t\t\t   LTC3815_MFR_IIN_PEAK);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_VOUT_HISTORY:\n\tcase PMBUS_VIRT_RESET_VIN_HISTORY:\n\tcase PMBUS_VIRT_RESET_TEMP_HISTORY:\n\tcase PMBUS_VIRT_RESET_IOUT_HISTORY:\n\tcase PMBUS_VIRT_RESET_IIN_HISTORY:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ltc3815_write_word_data(struct i2c_client *client, int page,\n\t\t\t\t   int reg, u16 word)\n{\n\tint ret;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_RESET_IIN_HISTORY:\n\t\tret = pmbus_write_word_data(client, page,\n\t\t\t\t\t    LTC3815_MFR_IIN_PEAK, 0);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_IOUT_HISTORY:\n\t\tret = pmbus_write_word_data(client, page,\n\t\t\t\t\t    LTC3815_MFR_IOUT_PEAK, 0);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_VOUT_HISTORY:\n\t\tret = pmbus_write_word_data(client, page,\n\t\t\t\t\t    LTC3815_MFR_VOUT_PEAK, 0);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_VIN_HISTORY:\n\t\tret = pmbus_write_word_data(client, page,\n\t\t\t\t\t    LTC3815_MFR_VIN_PEAK, 0);\n\t\tbreak;\n\tcase PMBUS_VIRT_RESET_TEMP_HISTORY:\n\t\tret = pmbus_write_word_data(client, page,\n\t\t\t\t\t    LTC3815_MFR_TEMP_PEAK, 0);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct i2c_device_id ltc3815_id[] = {\n\t{\"ltc3815\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ltc3815_id);\n\nstatic struct pmbus_driver_info ltc3815_info = {\n\t.pages = 1,\n\t.format[PSC_VOLTAGE_IN] = direct,\n\t.format[PSC_VOLTAGE_OUT] = direct,\n\t.format[PSC_CURRENT_IN] = direct,\n\t.format[PSC_CURRENT_OUT] = direct,\n\t.format[PSC_TEMPERATURE] = direct,\n\t.m[PSC_VOLTAGE_IN] = 250,\n\t.b[PSC_VOLTAGE_IN] = 0,\n\t.R[PSC_VOLTAGE_IN] = 0,\n\t.m[PSC_VOLTAGE_OUT] = 2,\n\t.b[PSC_VOLTAGE_OUT] = 0,\n\t.R[PSC_VOLTAGE_OUT] = 3,\n\t.m[PSC_CURRENT_IN] = 1,\n\t.b[PSC_CURRENT_IN] = 0,\n\t.R[PSC_CURRENT_IN] = 2,\n\t.m[PSC_CURRENT_OUT] = 1,\n\t.b[PSC_CURRENT_OUT] = 0,\n\t.R[PSC_CURRENT_OUT] = 2,\n\t.m[PSC_TEMPERATURE] = 1,\n\t.b[PSC_TEMPERATURE] = 0,\n\t.R[PSC_TEMPERATURE] = 0,\n\t.func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_IIN | PMBUS_HAVE_VOUT |\n\t\tPMBUS_HAVE_IOUT | PMBUS_HAVE_TEMP,\n\t.read_byte_data = ltc3815_read_byte_data,\n\t.read_word_data = ltc3815_read_word_data,\n\t.write_byte = ltc3815_write_byte,\n\t.write_word_data = ltc3815_write_word_data,\n};\n\nstatic int ltc3815_probe(struct i2c_client *client)\n{\n\tint chip_id;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tchip_id = i2c_smbus_read_word_data(client, LTC3815_MFR_SPECIAL_ID);\n\tif (chip_id < 0)\n\t\treturn chip_id;\n\tif ((chip_id & LTC3815_ID_MASK) != LTC3815_ID)\n\t\treturn -ENODEV;\n\n\treturn pmbus_do_probe(client, &ltc3815_info);\n}\n\nstatic struct i2c_driver ltc3815_driver = {\n\t.driver = {\n\t\t   .name = \"ltc3815\",\n\t\t   },\n\t.probe = ltc3815_probe,\n\t.id_table = ltc3815_id,\n};\n\nmodule_i2c_driver(ltc3815_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck\");\nMODULE_DESCRIPTION(\"PMBus driver for LTC3815\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}