{
  "module_name": "zl6100.c",
  "hash_id": "6023fd641756050e8679ed087bdb3267fa6aa89b6110f2c383fd04e052c05df1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/pmbus/zl6100.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/ktime.h>\n#include <linux/delay.h>\n#include \"pmbus.h\"\n\nenum chips { zl2004, zl2005, zl2006, zl2008, zl2105, zl2106, zl6100, zl6105,\n\t     zl8802, zl9101, zl9117, zls1003, zls4009 };\n\nstruct zl6100_data {\n\tint id;\n\tktime_t access;\t\t \n\tint delay;\t\t \n\tstruct pmbus_driver_info info;\n};\n\n#define to_zl6100_data(x)  container_of(x, struct zl6100_data, info)\n\n#define ZL6100_MFR_CONFIG\t\t0xd0\n#define ZL6100_DEVICE_ID\t\t0xe4\n\n#define ZL6100_MFR_XTEMP_ENABLE\t\tBIT(7)\n\n#define ZL8802_MFR_USER_GLOBAL_CONFIG\t0xe9\n#define ZL8802_MFR_TMON_ENABLE\t\tBIT(12)\n#define ZL8802_MFR_USER_CONFIG\t\t0xd1\n#define ZL8802_MFR_XTEMP_ENABLE_2\tBIT(1)\n#define ZL8802_MFR_DDC_CONFIG\t\t0xd3\n#define ZL8802_MFR_PHASES_MASK\t\t0x0007\n\n#define MFR_VMON_OV_FAULT_LIMIT\t\t0xf5\n#define MFR_VMON_UV_FAULT_LIMIT\t\t0xf6\n#define MFR_READ_VMON\t\t\t0xf7\n\n#define VMON_UV_WARNING\t\t\tBIT(5)\n#define VMON_OV_WARNING\t\t\tBIT(4)\n#define VMON_UV_FAULT\t\t\tBIT(1)\n#define VMON_OV_FAULT\t\t\tBIT(0)\n\n#define ZL6100_WAIT_TIME\t\t1000\t \n\nstatic ushort delay = ZL6100_WAIT_TIME;\nmodule_param(delay, ushort, 0644);\nMODULE_PARM_DESC(delay, \"Delay between chip accesses in uS\");\n\n \nstatic long zl6100_l2d(s16 l)\n{\n\ts16 exponent;\n\ts32 mantissa;\n\tlong val;\n\n\texponent = l >> 11;\n\tmantissa = ((s16)((l & 0x7ff) << 5)) >> 5;\n\n\tval = mantissa;\n\n\t \n\tval = val * 1000L;\n\n\tif (exponent >= 0)\n\t\tval <<= exponent;\n\telse\n\t\tval >>= -exponent;\n\n\treturn val;\n}\n\n#define MAX_MANTISSA\t(1023 * 1000)\n#define MIN_MANTISSA\t(511 * 1000)\n\nstatic u16 zl6100_d2l(long val)\n{\n\ts16 exponent = 0, mantissa;\n\tbool negative = false;\n\n\t \n\tif (val == 0)\n\t\treturn 0;\n\n\tif (val < 0) {\n\t\tnegative = true;\n\t\tval = -val;\n\t}\n\n\t \n\twhile (val >= MAX_MANTISSA && exponent < 15) {\n\t\texponent++;\n\t\tval >>= 1;\n\t}\n\t \n\twhile (val < MIN_MANTISSA && exponent > -15) {\n\t\texponent--;\n\t\tval <<= 1;\n\t}\n\n\t \n\tmantissa = DIV_ROUND_CLOSEST(val, 1000);\n\n\t \n\tif (mantissa > 0x3ff)\n\t\tmantissa = 0x3ff;\n\n\t \n\tif (negative)\n\t\tmantissa = -mantissa;\n\n\t \n\treturn (mantissa & 0x7ff) | ((exponent << 11) & 0xf800);\n}\n\n \nstatic inline void zl6100_wait(const struct zl6100_data *data)\n{\n\tif (data->delay) {\n\t\ts64 delta = ktime_us_delta(ktime_get(), data->access);\n\t\tif (delta < data->delay)\n\t\t\tudelay(data->delay - delta);\n\t}\n}\n\nstatic int zl6100_read_word_data(struct i2c_client *client, int page,\n\t\t\t\t int phase, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct zl6100_data *data = to_zl6100_data(info);\n\tint ret, vreg;\n\n\tif (page >= info->pages)\n\t\treturn -ENXIO;\n\n\tif (data->id == zl2005) {\n\t\t \n\t\tswitch (reg) {\n\t\tcase PMBUS_VOUT_OV_WARN_LIMIT:\n\t\tcase PMBUS_VOUT_UV_WARN_LIMIT:\n\t\tcase PMBUS_IOUT_OC_WARN_LIMIT:\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_READ_VMON:\n\t\tvreg = MFR_READ_VMON;\n\t\tbreak;\n\tcase PMBUS_VIRT_VMON_OV_WARN_LIMIT:\n\tcase PMBUS_VIRT_VMON_OV_FAULT_LIMIT:\n\t\tvreg = MFR_VMON_OV_FAULT_LIMIT;\n\t\tbreak;\n\tcase PMBUS_VIRT_VMON_UV_WARN_LIMIT:\n\tcase PMBUS_VIRT_VMON_UV_FAULT_LIMIT:\n\t\tvreg = MFR_VMON_UV_FAULT_LIMIT;\n\t\tbreak;\n\tdefault:\n\t\tif (reg >= PMBUS_VIRT_BASE)\n\t\t\treturn -ENXIO;\n\t\tvreg = reg;\n\t\tbreak;\n\t}\n\n\tzl6100_wait(data);\n\tret = pmbus_read_word_data(client, page, phase, vreg);\n\tdata->access = ktime_get();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_VMON_OV_WARN_LIMIT:\n\t\tret = zl6100_d2l(DIV_ROUND_CLOSEST(zl6100_l2d(ret) * 9, 10));\n\t\tbreak;\n\tcase PMBUS_VIRT_VMON_UV_WARN_LIMIT:\n\t\tret = zl6100_d2l(DIV_ROUND_CLOSEST(zl6100_l2d(ret) * 11, 10));\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int zl6100_read_byte_data(struct i2c_client *client, int page, int reg)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct zl6100_data *data = to_zl6100_data(info);\n\tint ret, status;\n\n\tif (page >= info->pages)\n\t\treturn -ENXIO;\n\n\tzl6100_wait(data);\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_STATUS_VMON:\n\t\tret = pmbus_read_byte_data(client, 0,\n\t\t\t\t\t   PMBUS_STATUS_MFR_SPECIFIC);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tstatus = 0;\n\t\tif (ret & VMON_UV_WARNING)\n\t\t\tstatus |= PB_VOLTAGE_UV_WARNING;\n\t\tif (ret & VMON_OV_WARNING)\n\t\t\tstatus |= PB_VOLTAGE_OV_WARNING;\n\t\tif (ret & VMON_UV_FAULT)\n\t\t\tstatus |= PB_VOLTAGE_UV_FAULT;\n\t\tif (ret & VMON_OV_FAULT)\n\t\t\tstatus |= PB_VOLTAGE_OV_FAULT;\n\t\tret = status;\n\t\tbreak;\n\tdefault:\n\t\tret = pmbus_read_byte_data(client, page, reg);\n\t\tbreak;\n\t}\n\tdata->access = ktime_get();\n\n\treturn ret;\n}\n\nstatic int zl6100_write_word_data(struct i2c_client *client, int page, int reg,\n\t\t\t\t  u16 word)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct zl6100_data *data = to_zl6100_data(info);\n\tint ret, vreg;\n\n\tif (page >= info->pages)\n\t\treturn -ENXIO;\n\n\tswitch (reg) {\n\tcase PMBUS_VIRT_VMON_OV_WARN_LIMIT:\n\t\tword = zl6100_d2l(DIV_ROUND_CLOSEST(zl6100_l2d(word) * 10, 9));\n\t\tvreg = MFR_VMON_OV_FAULT_LIMIT;\n\t\tpmbus_clear_cache(client);\n\t\tbreak;\n\tcase PMBUS_VIRT_VMON_OV_FAULT_LIMIT:\n\t\tvreg = MFR_VMON_OV_FAULT_LIMIT;\n\t\tpmbus_clear_cache(client);\n\t\tbreak;\n\tcase PMBUS_VIRT_VMON_UV_WARN_LIMIT:\n\t\tword = zl6100_d2l(DIV_ROUND_CLOSEST(zl6100_l2d(word) * 10, 11));\n\t\tvreg = MFR_VMON_UV_FAULT_LIMIT;\n\t\tpmbus_clear_cache(client);\n\t\tbreak;\n\tcase PMBUS_VIRT_VMON_UV_FAULT_LIMIT:\n\t\tvreg = MFR_VMON_UV_FAULT_LIMIT;\n\t\tpmbus_clear_cache(client);\n\t\tbreak;\n\tdefault:\n\t\tif (reg >= PMBUS_VIRT_BASE)\n\t\t\treturn -ENXIO;\n\t\tvreg = reg;\n\t}\n\n\tzl6100_wait(data);\n\tret = pmbus_write_word_data(client, page, vreg, word);\n\tdata->access = ktime_get();\n\n\treturn ret;\n}\n\nstatic int zl6100_write_byte(struct i2c_client *client, int page, u8 value)\n{\n\tconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\n\tstruct zl6100_data *data = to_zl6100_data(info);\n\tint ret;\n\n\tif (page >= info->pages)\n\t\treturn -ENXIO;\n\n\tzl6100_wait(data);\n\tret = pmbus_write_byte(client, page, value);\n\tdata->access = ktime_get();\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id zl6100_id[] = {\n\t{\"bmr450\", zl2005},\n\t{\"bmr451\", zl2005},\n\t{\"bmr462\", zl2008},\n\t{\"bmr463\", zl2008},\n\t{\"bmr464\", zl2008},\n\t{\"bmr465\", zls4009},\n\t{\"bmr466\", zls1003},\n\t{\"bmr467\", zls4009},\n\t{\"bmr469\", zl8802},\n\t{\"zl2004\", zl2004},\n\t{\"zl2005\", zl2005},\n\t{\"zl2006\", zl2006},\n\t{\"zl2008\", zl2008},\n\t{\"zl2105\", zl2105},\n\t{\"zl2106\", zl2106},\n\t{\"zl6100\", zl6100},\n\t{\"zl6105\", zl6105},\n\t{\"zl8802\", zl8802},\n\t{\"zl9101\", zl9101},\n\t{\"zl9117\", zl9117},\n\t{\"zls1003\", zls1003},\n\t{\"zls4009\", zls4009},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, zl6100_id);\n\nstatic int zl6100_probe(struct i2c_client *client)\n{\n\tint ret, i;\n\tstruct zl6100_data *data;\n\tstruct pmbus_driver_info *info;\n\tu8 device_id[I2C_SMBUS_BLOCK_MAX + 1];\n\tconst struct i2c_device_id *mid;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_WORD_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_READ_BLOCK_DATA))\n\t\treturn -ENODEV;\n\n\tret = i2c_smbus_read_block_data(client, ZL6100_DEVICE_ID,\n\t\t\t\t\tdevice_id);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to read device ID\\n\");\n\t\treturn ret;\n\t}\n\tdevice_id[ret] = '\\0';\n\tdev_info(&client->dev, \"Device ID %s\\n\", device_id);\n\n\tmid = NULL;\n\tfor (mid = zl6100_id; mid->name[0]; mid++) {\n\t\tif (!strncasecmp(mid->name, device_id, strlen(mid->name)))\n\t\t\tbreak;\n\t}\n\tif (!mid->name[0]) {\n\t\tdev_err(&client->dev, \"Unsupported device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (strcmp(client->name, mid->name) != 0)\n\t\tdev_notice(&client->dev,\n\t\t\t   \"Device mismatch: Configured %s, detected %s\\n\",\n\t\t\t   client->name, mid->name);\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct zl6100_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->id = mid->driver_data;\n\n\t \n\tdata->delay = delay;\n\n\t \n\tdata->access = ktime_get();\n\tzl6100_wait(data);\n\n\tinfo = &data->info;\n\n\tinfo->pages = 1;\n\tinfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\n\t  | PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\n\t  | PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\n\t  | PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\n\n\t \n\tif (data->id == zl2004 || data->id == zl8802 || data->id == zl9101 ||\n\t    data->id == zl9117 || data->id == zls4009)\n\t\tinfo->func[0] |= PMBUS_HAVE_VMON | PMBUS_HAVE_STATUS_VMON;\n\n\t \n\tif (data->id == zl8802) {\n\t\tinfo->pages = 2;\n\t\tinfo->func[0] |= PMBUS_HAVE_IIN;\n\n\t\tret = i2c_smbus_read_word_data(client, ZL8802_MFR_DDC_CONFIG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata->access = ktime_get();\n\t\tzl6100_wait(data);\n\n\t\tif (ret & ZL8802_MFR_PHASES_MASK)\n\t\t\tinfo->func[1] |= PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT;\n\t\telse\n\t\t\tinfo->func[1] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\n\t\t\t\t| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT;\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, i);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tdata->access = ktime_get();\n\t\t\tzl6100_wait(data);\n\n\t\t\tret = i2c_smbus_read_word_data(client, ZL8802_MFR_USER_CONFIG);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret & ZL8802_MFR_XTEMP_ENABLE_2)\n\t\t\t\tinfo->func[i] |= PMBUS_HAVE_TEMP2;\n\n\t\t\tdata->access = ktime_get();\n\t\t\tzl6100_wait(data);\n\t\t}\n\t\tret = i2c_smbus_read_word_data(client, ZL8802_MFR_USER_GLOBAL_CONFIG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret & ZL8802_MFR_TMON_ENABLE)\n\t\t\tinfo->func[0] |= PMBUS_HAVE_TEMP3;\n\t} else {\n\t\tret = i2c_smbus_read_word_data(client, ZL6100_MFR_CONFIG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret & ZL6100_MFR_XTEMP_ENABLE)\n\t\t\tinfo->func[0] |= PMBUS_HAVE_TEMP2;\n\t}\n\n\tdata->access = ktime_get();\n\tzl6100_wait(data);\n\n\tinfo->read_word_data = zl6100_read_word_data;\n\tinfo->read_byte_data = zl6100_read_byte_data;\n\tinfo->write_word_data = zl6100_write_word_data;\n\tinfo->write_byte = zl6100_write_byte;\n\n\treturn pmbus_do_probe(client, info);\n}\n\nstatic struct i2c_driver zl6100_driver = {\n\t.driver = {\n\t\t   .name = \"zl6100\",\n\t\t   },\n\t.probe = zl6100_probe,\n\t.id_table = zl6100_id,\n};\n\nmodule_i2c_driver(zl6100_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck\");\nMODULE_DESCRIPTION(\"PMBus driver for ZL6100 and compatibles\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PMBUS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}