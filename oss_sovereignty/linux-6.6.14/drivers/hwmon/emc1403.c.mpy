{
  "module_name": "emc1403.c",
  "hash_id": "ae683c84bb798857f040af2701d3febf6fb87a7e84327d07d437a8e505e5f93a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/emc1403.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/sysfs.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n\n#define THERMAL_PID_REG\t\t0xfd\n#define THERMAL_SMSC_ID_REG\t0xfe\n#define THERMAL_REVISION_REG\t0xff\n\nenum emc1403_chip { emc1402, emc1403, emc1404 };\n\nstruct thermal_data {\n\tstruct regmap *regmap;\n\tstruct mutex mutex;\n\tconst struct attribute_group *groups[4];\n};\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute *sda = to_sensor_dev_attr(attr);\n\tstruct thermal_data *data = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint retval;\n\n\tretval = regmap_read(data->regmap, sda->index, &val);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn sprintf(buf, \"%d000\\n\", val);\n}\n\nstatic ssize_t bit_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct sensor_device_attribute_2 *sda = to_sensor_dev_attr_2(attr);\n\tstruct thermal_data *data = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint retval;\n\n\tretval = regmap_read(data->regmap, sda->nr, &val);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn sprintf(buf, \"%d\\n\", !!(val & sda->index));\n}\n\nstatic ssize_t temp_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sda = to_sensor_dev_attr(attr);\n\tstruct thermal_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint retval;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\tretval = regmap_write(data->regmap, sda->index,\n\t\t\t      DIV_ROUND_CLOSEST(val, 1000));\n\tif (retval < 0)\n\t\treturn retval;\n\treturn count;\n}\n\nstatic ssize_t bit_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sda = to_sensor_dev_attr_2(attr);\n\tstruct thermal_data *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint retval;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tretval = regmap_update_bits(data->regmap, sda->nr, sda->index,\n\t\t\t\t    val ? sda->index : 0);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn count;\n}\n\nstatic ssize_t show_hyst_common(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf,\n\t\t\t\tbool is_min)\n{\n\tstruct sensor_device_attribute *sda = to_sensor_dev_attr(attr);\n\tstruct thermal_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int limit;\n\tunsigned int hyst;\n\tint retval;\n\n\tretval = regmap_read(regmap, sda->index, &limit);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = regmap_read(regmap, 0x21, &hyst);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn sprintf(buf, \"%d000\\n\", is_min ? limit + hyst : limit - hyst);\n}\n\nstatic ssize_t hyst_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\treturn show_hyst_common(dev, attr, buf, false);\n}\n\nstatic ssize_t min_hyst_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn show_hyst_common(dev, attr, buf, true);\n}\n\nstatic ssize_t hyst_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sda = to_sensor_dev_attr(attr);\n\tstruct thermal_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int limit;\n\tint retval;\n\tint hyst;\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->mutex);\n\tretval = regmap_read(regmap, sda->index, &limit);\n\tif (retval < 0)\n\t\tgoto fail;\n\n\thyst = limit * 1000 - val;\n\thyst = clamp_val(DIV_ROUND_CLOSEST(hyst, 1000), 0, 255);\n\tretval = regmap_write(regmap, 0x21, hyst);\n\tif (retval == 0)\n\t\tretval = count;\nfail:\n\tmutex_unlock(&data->mutex);\n\treturn retval;\n}\n\n \n\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp, 0x06);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp, 0x05);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_crit, temp, 0x20);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0x00);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_min_alarm, bit, 0x36, 0x01);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_max_alarm, bit, 0x35, 0x01);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_crit_alarm, bit, 0x37, 0x01);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_hyst, min_hyst, 0x06);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_hyst, hyst, 0x05);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_crit_hyst, hyst, 0x20);\n\nstatic SENSOR_DEVICE_ATTR_RW(temp2_min, temp, 0x08);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp, 0x07);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_crit, temp, 0x19);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, 0x01);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp2_fault, bit, 0x1b, 0x02);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp2_min_alarm, bit, 0x36, 0x02);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp2_max_alarm, bit, 0x35, 0x02);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp2_crit_alarm, bit, 0x37, 0x02);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_min_hyst, min_hyst, 0x08);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_max_hyst, hyst, 0x07);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_crit_hyst, hyst, 0x19);\n\nstatic SENSOR_DEVICE_ATTR_RW(temp3_min, temp, 0x16);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_max, temp, 0x15);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_crit, temp, 0x1A);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp, 0x23);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_fault, bit, 0x1b, 0x04);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_min_alarm, bit, 0x36, 0x04);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_max_alarm, bit, 0x35, 0x04);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_crit_alarm, bit, 0x37, 0x04);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_min_hyst, min_hyst, 0x16);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_max_hyst, hyst, 0x15);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_crit_hyst, hyst, 0x1A);\n\nstatic SENSOR_DEVICE_ATTR_RW(temp4_min, temp, 0x2D);\nstatic SENSOR_DEVICE_ATTR_RW(temp4_max, temp, 0x2C);\nstatic SENSOR_DEVICE_ATTR_RW(temp4_crit, temp, 0x30);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_input, temp, 0x2A);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp4_fault, bit, 0x1b, 0x08);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp4_min_alarm, bit, 0x36, 0x08);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp4_max_alarm, bit, 0x35, 0x08);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp4_crit_alarm, bit, 0x37, 0x08);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_min_hyst, min_hyst, 0x2D);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_max_hyst, hyst, 0x2C);\nstatic SENSOR_DEVICE_ATTR_RO(temp4_crit_hyst, hyst, 0x30);\n\nstatic SENSOR_DEVICE_ATTR_2_RW(power_state, bit, 0x03, 0x40);\n\nstatic struct attribute *emc1402_attrs[] = {\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_hyst.dev_attr.attr,\n\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit_hyst.dev_attr.attr,\n\n\t&sensor_dev_attr_power_state.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group emc1402_group = {\n\t\t.attrs = emc1402_attrs,\n};\n\nstatic struct attribute *emc1403_attrs[] = {\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit_alarm.dev_attr.attr,\n\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit_hyst.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group emc1403_group = {\n\t.attrs = emc1403_attrs,\n};\n\nstatic struct attribute *emc1404_attrs[] = {\n\t&sensor_dev_attr_temp4_min.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max.dev_attr.attr,\n\t&sensor_dev_attr_temp4_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp4_input.dev_attr.attr,\n\t&sensor_dev_attr_temp4_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp4_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp4_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp4_min_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max_hyst.dev_attr.attr,\n\t&sensor_dev_attr_temp4_crit_hyst.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group emc1404_group = {\n\t.attrs = emc1404_attrs,\n};\n\n \nstatic struct sensor_device_attribute_2 emc1402_alarms[] = {\n\tSENSOR_ATTR_2_RO(temp1_min_alarm, bit, 0x02, 0x20),\n\tSENSOR_ATTR_2_RO(temp1_max_alarm, bit, 0x02, 0x40),\n\tSENSOR_ATTR_2_RO(temp1_crit_alarm, bit, 0x02, 0x01),\n\n\tSENSOR_ATTR_2_RO(temp2_fault, bit, 0x02, 0x04),\n\tSENSOR_ATTR_2_RO(temp2_min_alarm, bit, 0x02, 0x08),\n\tSENSOR_ATTR_2_RO(temp2_max_alarm, bit, 0x02, 0x10),\n\tSENSOR_ATTR_2_RO(temp2_crit_alarm, bit, 0x02, 0x02),\n};\n\nstatic struct attribute *emc1402_alarm_attrs[] = {\n\t&emc1402_alarms[0].dev_attr.attr,\n\t&emc1402_alarms[1].dev_attr.attr,\n\t&emc1402_alarms[2].dev_attr.attr,\n\t&emc1402_alarms[3].dev_attr.attr,\n\t&emc1402_alarms[4].dev_attr.attr,\n\t&emc1402_alarms[5].dev_attr.attr,\n\t&emc1402_alarms[6].dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group emc1402_alarm_group = {\n\t.attrs = emc1402_alarm_attrs,\n};\n\nstatic int emc1403_detect(struct i2c_client *client,\n\t\t\tstruct i2c_board_info *info)\n{\n\tint id;\n\t \n\n\tid = i2c_smbus_read_byte_data(client, THERMAL_SMSC_ID_REG);\n\tif (id != 0x5d)\n\t\treturn -ENODEV;\n\n\tid = i2c_smbus_read_byte_data(client, THERMAL_PID_REG);\n\tswitch (id) {\n\tcase 0x20:\n\t\tstrscpy(info->type, \"emc1402\", I2C_NAME_SIZE);\n\t\tbreak;\n\tcase 0x21:\n\t\tstrscpy(info->type, \"emc1403\", I2C_NAME_SIZE);\n\t\tbreak;\n\tcase 0x22:\n\t\tstrscpy(info->type, \"emc1422\", I2C_NAME_SIZE);\n\t\tbreak;\n\tcase 0x23:\n\t\tstrscpy(info->type, \"emc1423\", I2C_NAME_SIZE);\n\t\tbreak;\n\tcase 0x25:\n\t\tstrscpy(info->type, \"emc1404\", I2C_NAME_SIZE);\n\t\tbreak;\n\tcase 0x27:\n\t\tstrscpy(info->type, \"emc1424\", I2C_NAME_SIZE);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tid = i2c_smbus_read_byte_data(client, THERMAL_REVISION_REG);\n\tif (id < 0x01 || id > 0x04)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic bool emc1403_regmap_is_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x00:\t \n\tcase 0x01:\t \n\tcase 0x02:\t \n\tcase 0x10:\t \n\tcase 0x1b:\t \n\tcase 0x23:\t \n\tcase 0x24:\t \n\tcase 0x29:\t \n\tcase 0x2a:\t \n\tcase 0x2b:\t \n\tcase 0x35:\t \n\tcase 0x36:\t \n\tcase 0x37:\t \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config emc1403_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = emc1403_regmap_is_volatile,\n};\n\nstatic const struct i2c_device_id emc1403_idtable[];\n\nstatic int emc1403_probe(struct i2c_client *client)\n{\n\tstruct thermal_data *data;\n\tstruct device *hwmon_dev;\n\tconst struct i2c_device_id *id = i2c_match_id(emc1403_idtable, client);\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct thermal_data),\n\t\t\t    GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &emc1403_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\tmutex_init(&data->mutex);\n\n\tswitch (id->driver_data) {\n\tcase emc1404:\n\t\tdata->groups[2] = &emc1404_group;\n\t\tfallthrough;\n\tcase emc1403:\n\t\tdata->groups[1] = &emc1403_group;\n\t\tfallthrough;\n\tcase emc1402:\n\t\tdata->groups[0] = &emc1402_group;\n\t}\n\n\tif (id->driver_data == emc1402)\n\t\tdata->groups[1] = &emc1402_alarm_group;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(&client->dev,\n\t\t\t\t\t\t\t   client->name, data,\n\t\t\t\t\t\t\t   data->groups);\n\tif (IS_ERR(hwmon_dev))\n\t\treturn PTR_ERR(hwmon_dev);\n\n\tdev_info(&client->dev, \"%s Thermal chip found\\n\", id->name);\n\treturn 0;\n}\n\nstatic const unsigned short emc1403_address_list[] = {\n\t0x18, 0x1c, 0x29, 0x4c, 0x4d, 0x5c, I2C_CLIENT_END\n};\n\n \nstatic const struct i2c_device_id emc1403_idtable[] = {\n\t{ \"emc1402\", emc1402 },\n\t{ \"emc1403\", emc1403 },\n\t{ \"emc1404\", emc1404 },\n\t{ \"emc1412\", emc1402 },\n\t{ \"emc1413\", emc1403 },\n\t{ \"emc1414\", emc1404 },\n\t{ \"emc1422\", emc1402 },\n\t{ \"emc1423\", emc1403 },\n\t{ \"emc1424\", emc1404 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, emc1403_idtable);\n\nstatic struct i2c_driver sensor_emc1403 = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"emc1403\",\n\t},\n\t.detect = emc1403_detect,\n\t.probe = emc1403_probe,\n\t.id_table = emc1403_idtable,\n\t.address_list = emc1403_address_list,\n};\n\nmodule_i2c_driver(sensor_emc1403);\n\nMODULE_AUTHOR(\"Kalhan Trisal <kalhan.trisal@intel.com\");\nMODULE_DESCRIPTION(\"emc1403 Thermal Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}