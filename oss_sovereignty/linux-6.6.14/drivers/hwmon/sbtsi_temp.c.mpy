{
  "module_name": "sbtsi_temp.c",
  "hash_id": "2673fe535f1f057877b72b420f1a8aeccdc6358a02d180af8a71086e2cb3b141",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/sbtsi_temp.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/hwmon.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n\n \n#define SBTSI_REG_TEMP_INT\t\t0x01  \n#define SBTSI_REG_STATUS\t\t0x02  \n#define SBTSI_REG_CONFIG\t\t0x03  \n#define SBTSI_REG_TEMP_HIGH_INT\t\t0x07  \n#define SBTSI_REG_TEMP_LOW_INT\t\t0x08  \n#define SBTSI_REG_TEMP_DEC\t\t0x10  \n#define SBTSI_REG_TEMP_HIGH_DEC\t\t0x13  \n#define SBTSI_REG_TEMP_LOW_DEC\t\t0x14  \n\n#define SBTSI_CONFIG_READ_ORDER_SHIFT\t5\n\n#define SBTSI_TEMP_MIN\t0\n#define SBTSI_TEMP_MAX\t255875\n\n \nstruct sbtsi_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n};\n\n \nstatic inline int sbtsi_reg_to_mc(s32 integer, s32 decimal)\n{\n\treturn ((integer << 3) + (decimal >> 5)) * 125;\n}\n\n \nstatic inline void sbtsi_mc_to_reg(s32 temp, u8 *integer, u8 *decimal)\n{\n\ttemp /= 125;\n\t*integer = temp >> 3;\n\t*decimal = (temp & 0x7) << 5;\n}\n\nstatic int sbtsi_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t      u32 attr, int channel, long *val)\n{\n\tstruct sbtsi_data *data = dev_get_drvdata(dev);\n\ts32 temp_int, temp_dec;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\t \n\t\terr = i2c_smbus_read_byte_data(data->client, SBTSI_REG_CONFIG);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmutex_lock(&data->lock);\n\t\tif (err & BIT(SBTSI_CONFIG_READ_ORDER_SHIFT)) {\n\t\t\ttemp_dec = i2c_smbus_read_byte_data(data->client, SBTSI_REG_TEMP_DEC);\n\t\t\ttemp_int = i2c_smbus_read_byte_data(data->client, SBTSI_REG_TEMP_INT);\n\t\t} else {\n\t\t\ttemp_int = i2c_smbus_read_byte_data(data->client, SBTSI_REG_TEMP_INT);\n\t\t\ttemp_dec = i2c_smbus_read_byte_data(data->client, SBTSI_REG_TEMP_DEC);\n\t\t}\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\tmutex_lock(&data->lock);\n\t\ttemp_int = i2c_smbus_read_byte_data(data->client, SBTSI_REG_TEMP_HIGH_INT);\n\t\ttemp_dec = i2c_smbus_read_byte_data(data->client, SBTSI_REG_TEMP_HIGH_DEC);\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tcase hwmon_temp_min:\n\t\tmutex_lock(&data->lock);\n\t\ttemp_int = i2c_smbus_read_byte_data(data->client, SBTSI_REG_TEMP_LOW_INT);\n\t\ttemp_dec = i2c_smbus_read_byte_data(data->client, SBTSI_REG_TEMP_LOW_DEC);\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\n\tif (temp_int < 0)\n\t\treturn temp_int;\n\tif (temp_dec < 0)\n\t\treturn temp_dec;\n\n\t*val = sbtsi_reg_to_mc(temp_int, temp_dec);\n\n\treturn 0;\n}\n\nstatic int sbtsi_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long val)\n{\n\tstruct sbtsi_data *data = dev_get_drvdata(dev);\n\tint reg_int, reg_dec, err;\n\tu8 temp_int, temp_dec;\n\n\tswitch (attr) {\n\tcase hwmon_temp_max:\n\t\treg_int = SBTSI_REG_TEMP_HIGH_INT;\n\t\treg_dec = SBTSI_REG_TEMP_HIGH_DEC;\n\t\tbreak;\n\tcase hwmon_temp_min:\n\t\treg_int = SBTSI_REG_TEMP_LOW_INT;\n\t\treg_dec = SBTSI_REG_TEMP_LOW_DEC;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = clamp_val(val, SBTSI_TEMP_MIN, SBTSI_TEMP_MAX);\n\tsbtsi_mc_to_reg(val, &temp_int, &temp_dec);\n\n\tmutex_lock(&data->lock);\n\terr = i2c_smbus_write_byte_data(data->client, reg_int, temp_int);\n\tif (err)\n\t\tgoto exit;\n\n\terr = i2c_smbus_write_byte_data(data->client, reg_dec, temp_dec);\nexit:\n\tmutex_unlock(&data->lock);\n\treturn err;\n}\n\nstatic umode_t sbtsi_is_visible(const void *data,\n\t\t\t\tenum hwmon_sensor_types type,\n\t\t\t\tu32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_min:\n\t\t\treturn 0644;\n\t\tcase hwmon_temp_max:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const sbtsi_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX),\n\tNULL\n};\n\nstatic const struct hwmon_ops sbtsi_hwmon_ops = {\n\t.is_visible = sbtsi_is_visible,\n\t.read = sbtsi_read,\n\t.write = sbtsi_write,\n};\n\nstatic const struct hwmon_chip_info sbtsi_chip_info = {\n\t.ops = &sbtsi_hwmon_ops,\n\t.info = sbtsi_info,\n};\n\nstatic int sbtsi_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct sbtsi_data *data;\n\n\tdata = devm_kzalloc(dev, sizeof(struct sbtsi_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name, data, &sbtsi_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id sbtsi_id[] = {\n\t{\"sbtsi\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, sbtsi_id);\n\nstatic const struct of_device_id __maybe_unused sbtsi_of_match[] = {\n\t{\n\t\t.compatible = \"amd,sbtsi\",\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sbtsi_of_match);\n\nstatic struct i2c_driver sbtsi_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"sbtsi\",\n\t\t.of_match_table = of_match_ptr(sbtsi_of_match),\n\t},\n\t.probe = sbtsi_probe,\n\t.id_table = sbtsi_id,\n};\n\nmodule_i2c_driver(sbtsi_driver);\n\nMODULE_AUTHOR(\"Kun Yi <kunyi@google.com>\");\nMODULE_DESCRIPTION(\"Hwmon driver for AMD SB-TSI emulated sensor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}