{
  "module_name": "w83l785ts.c",
  "hash_id": "eb632cdcf64f997ccedaba1e958ec18e29c61215a485dec77266342b738070fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/w83l785ts.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n\n \n#define MAX_RETRIES\t5\n\n \n\nstatic const unsigned short normal_i2c[] = { 0x2e, I2C_CLIENT_END };\n\n \n\n#define W83L785TS_REG_MAN_ID1\t\t0x4D\n#define W83L785TS_REG_MAN_ID2\t\t0x4C\n#define W83L785TS_REG_CHIP_ID\t\t0x4E\n#define W83L785TS_REG_CONFIG\t\t0x40\n#define W83L785TS_REG_TYPE\t\t0x52\n#define W83L785TS_REG_TEMP\t\t0x27\n#define W83L785TS_REG_TEMP_OVER\t\t0x53  \n\n \n\n#define TEMP_FROM_REG(val)\t((val) * 1000)\n\n \n\nstatic int w83l785ts_probe(struct i2c_client *client);\nstatic int w83l785ts_detect(struct i2c_client *client,\n\t\t\t    struct i2c_board_info *info);\nstatic void w83l785ts_remove(struct i2c_client *client);\nstatic u8 w83l785ts_read_value(struct i2c_client *client, u8 reg, u8 defval);\nstatic struct w83l785ts_data *w83l785ts_update_device(struct device *dev);\n\n \n\nstatic const struct i2c_device_id w83l785ts_id[] = {\n\t{ \"w83l785ts\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, w83l785ts_id);\n\nstatic struct i2c_driver w83l785ts_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"w83l785ts\",\n\t},\n\t.probe\t\t= w83l785ts_probe,\n\t.remove\t\t= w83l785ts_remove,\n\t.id_table\t= w83l785ts_id,\n\t.detect\t\t= w83l785ts_detect,\n\t.address_list\t= normal_i2c,\n};\n\n \n\nstruct w83l785ts_data {\n\tstruct device *hwmon_dev;\n\tstruct mutex update_lock;\n\tbool valid;  \n\tunsigned long last_updated;  \n\n\t \n\ts8 temp[2];  \n};\n\n \n\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *devattr,\n\tchar *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct w83l785ts_data *data = w83l785ts_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp[attr->index]));\n}\n\nstatic SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(temp1_max, S_IRUGO, show_temp, NULL, 1);\n\n \n\n \nstatic int w83l785ts_detect(struct i2c_client *client,\n\t\t\t    struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tu16 man_id;\n\tu8 chip_id;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tif ((w83l785ts_read_value(client, W83L785TS_REG_CONFIG, 0) & 0x80)\n\t || (w83l785ts_read_value(client, W83L785TS_REG_TYPE, 0) & 0xFC)) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"W83L785TS-S detection failed at 0x%02x\\n\",\n\t\t\tclient->addr);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tman_id = (w83l785ts_read_value(client, W83L785TS_REG_MAN_ID1, 0) << 8)\n\t       + w83l785ts_read_value(client, W83L785TS_REG_MAN_ID2, 0);\n\tchip_id = w83l785ts_read_value(client, W83L785TS_REG_CHIP_ID, 0);\n\n\tif (man_id != 0x5CA3\t\t \n\t || chip_id != 0x70) {\t\t \n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"Unsupported chip (man_id=0x%04X, chip_id=0x%02X)\\n\",\n\t\t\tman_id, chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, \"w83l785ts\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int w83l785ts_probe(struct i2c_client *client)\n{\n\tstruct w83l785ts_data *data;\n\tstruct device *dev = &client->dev;\n\tint err;\n\n\tdata = devm_kzalloc(dev, sizeof(struct w83l785ts_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\n\t \n\n\terr = device_create_file(dev, &sensor_dev_attr_temp1_input.dev_attr);\n\tif (err)\n\t\treturn err;\n\n\terr = device_create_file(dev, &sensor_dev_attr_temp1_max.dev_attr);\n\tif (err)\n\t\tgoto exit_remove;\n\n\t \n\tdata->hwmon_dev = hwmon_device_register(dev);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\terr = PTR_ERR(data->hwmon_dev);\n\t\tgoto exit_remove;\n\t}\n\n\treturn 0;\n\nexit_remove:\n\tdevice_remove_file(dev, &sensor_dev_attr_temp1_input.dev_attr);\n\tdevice_remove_file(dev, &sensor_dev_attr_temp1_max.dev_attr);\n\treturn err;\n}\n\nstatic void w83l785ts_remove(struct i2c_client *client)\n{\n\tstruct w83l785ts_data *data = i2c_get_clientdata(client);\n\n\thwmon_device_unregister(data->hwmon_dev);\n\tdevice_remove_file(&client->dev,\n\t\t\t   &sensor_dev_attr_temp1_input.dev_attr);\n\tdevice_remove_file(&client->dev,\n\t\t\t   &sensor_dev_attr_temp1_max.dev_attr);\n}\n\nstatic u8 w83l785ts_read_value(struct i2c_client *client, u8 reg, u8 defval)\n{\n\tint value, i;\n\tstruct device *dev;\n\tconst char *prefix;\n\n\t \n\tif (i2c_get_clientdata(client)) {\n\t\tdev = &client->dev;\n\t\tprefix = \"\";\n\t} else {\n\t\tdev = &client->adapter->dev;\n\t\tprefix = \"w83l785ts: \";\n\t}\n\n\t \n\tfor (i = 1; i <= MAX_RETRIES; i++) {\n\t\tvalue = i2c_smbus_read_byte_data(client, reg);\n\t\tif (value >= 0) {\n\t\t\tdev_dbg(dev, \"%sRead 0x%02x from register 0x%02x.\\n\",\n\t\t\t\tprefix, value, reg);\n\t\t\treturn value;\n\t\t}\n\t\tdev_dbg(dev, \"%sRead failed, will retry in %d.\\n\", prefix, i);\n\t\tmsleep(i);\n\t}\n\n\tdev_err(dev, \"%sCouldn't read value from register 0x%02x.\\n\", prefix,\n\t\treg);\n\treturn defval;\n}\n\nstatic struct w83l785ts_data *w83l785ts_update_device(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct w83l785ts_data *data = i2c_get_clientdata(client);\n\n\tmutex_lock(&data->update_lock);\n\n\tif (!data->valid || time_after(jiffies, data->last_updated + HZ * 2)) {\n\t\tdev_dbg(&client->dev, \"Updating w83l785ts data.\\n\");\n\t\tdata->temp[0] = w83l785ts_read_value(client,\n\t\t\t\tW83L785TS_REG_TEMP, data->temp[0]);\n\t\tdata->temp[1] = w83l785ts_read_value(client,\n\t\t\t\tW83L785TS_REG_TEMP_OVER, data->temp[1]);\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\nmodule_i2c_driver(w83l785ts_driver);\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"W83L785TS-S driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}