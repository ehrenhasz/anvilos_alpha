{
  "module_name": "hih6130.c",
  "hash_id": "89c6949cb7b4c4b1cbb0007ccde384f0c1d132085e137a283024c1a7a4ab74d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/hih6130.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n\n \nstruct hih6130 {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tbool valid;\n\tunsigned long last_update;\n\tint temperature;\n\tint humidity;\n\tsize_t write_length;\n};\n\n \nstatic inline int hih6130_temp_ticks_to_millicelsius(int ticks)\n{\n\tticks = ticks >> 2;\n\t \n\treturn (DIV_ROUND_CLOSEST(ticks * 1650, 16382) - 400) * 100;\n}\n\n \nstatic inline int hih6130_rh_ticks_to_per_cent_mille(int ticks)\n{\n\tticks &= ~0xC000;  \n\t \n\treturn DIV_ROUND_CLOSEST(ticks * 1000, 16382) * 100;\n}\n\n \nstatic int hih6130_update_measurements(struct device *dev)\n{\n\tstruct hih6130 *hih6130 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = hih6130->client;\n\tint ret = 0;\n\tint t;\n\tunsigned char tmp[4];\n\tstruct i2c_msg msgs[1] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 4,\n\t\t\t.buf = tmp,\n\t\t}\n\t};\n\n\tmutex_lock(&hih6130->lock);\n\n\t \n\tif (time_after(jiffies, hih6130->last_update + HZ) || !hih6130->valid) {\n\n\t\t \n\t\ttmp[0] = 0;\n\t\tret = i2c_master_send(client, tmp, hih6130->write_length);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tmsleep(40);\n\n\t\tret = i2c_transfer(client->adapter, msgs, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif ((tmp[0] & 0xC0) != 0) {\n\t\t\tdev_err(&client->dev, \"Error while reading measurement result\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tt = (tmp[0] << 8) + tmp[1];\n\t\thih6130->humidity = hih6130_rh_ticks_to_per_cent_mille(t);\n\n\t\tt = (tmp[2] << 8) + tmp[3];\n\t\thih6130->temperature = hih6130_temp_ticks_to_millicelsius(t);\n\n\t\thih6130->last_update = jiffies;\n\t\thih6130->valid = true;\n\t}\nout:\n\tmutex_unlock(&hih6130->lock);\n\n\treturn ret >= 0 ? 0 : ret;\n}\n\n \nstatic ssize_t hih6130_temperature_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct hih6130 *hih6130 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = hih6130_update_measurements(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sprintf(buf, \"%d\\n\", hih6130->temperature);\n}\n\n \nstatic ssize_t hih6130_humidity_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct hih6130 *hih6130 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = hih6130_update_measurements(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sprintf(buf, \"%d\\n\", hih6130->humidity);\n}\n\n \nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, hih6130_temperature, 0);\nstatic SENSOR_DEVICE_ATTR_RO(humidity1_input, hih6130_humidity, 0);\n\nstatic struct attribute *hih6130_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_humidity1_input.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(hih6130);\n\nstatic int hih6130_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct hih6130 *hih6130;\n\tstruct device *hwmon_dev;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"adapter does not support true I2C\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thih6130 = devm_kzalloc(dev, sizeof(*hih6130), GFP_KERNEL);\n\tif (!hih6130)\n\t\treturn -ENOMEM;\n\n\thih6130->client = client;\n\tmutex_init(&hih6130->lock);\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_QUICK))\n\t\thih6130->write_length = 1;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   hih6130,\n\t\t\t\t\t\t\t   hih6130_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\n \nstatic const struct i2c_device_id hih6130_id[] = {\n\t{ \"hih6130\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, hih6130_id);\n\nstatic const struct of_device_id __maybe_unused hih6130_of_match[] = {\n\t{ .compatible = \"honeywell,hih6130\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, hih6130_of_match);\n\nstatic struct i2c_driver hih6130_driver = {\n\t.driver = {\n\t\t.name = \"hih6130\",\n\t\t.of_match_table = of_match_ptr(hih6130_of_match),\n\t},\n\t.probe       = hih6130_probe,\n\t.id_table    = hih6130_id,\n};\n\nmodule_i2c_driver(hih6130_driver);\n\nMODULE_AUTHOR(\"Iain Paton <ipaton0@gmail.com>\");\nMODULE_DESCRIPTION(\"Honeywell HIH-6130 humidity and temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}