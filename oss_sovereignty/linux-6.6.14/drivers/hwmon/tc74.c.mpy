{
  "module_name": "tc74.c",
  "hash_id": "d1eb4cc463511b65aa0559f0506e55e01c17e3ef72be65958b8d7e6ec0943ee6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/tc74.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/i2c.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n\n \n#define TC74_REG_TEMP\t\t0x00\n#define TC74_REG_CONFIG\t\t0x01\n\nstruct tc74_data {\n\tstruct i2c_client\t*client;\n\tstruct mutex\t\tlock;\t \n\tbool\t\t\tvalid;\t \n\tunsigned long\t\tnext_update;\t \n\ts8\t\t\ttemp_input;\t \n};\n\nstatic int tc74_update_device(struct device *dev)\n{\n\tstruct tc74_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tret = mutex_lock_interruptible(&data->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (time_after(jiffies, data->next_update) || !data->valid) {\n\t\ts32 value;\n\n\t\tvalue = i2c_smbus_read_byte_data(client, TC74_REG_CONFIG);\n\t\tif (value < 0) {\n\t\t\tdev_dbg(&client->dev, \"TC74_REG_CONFIG read err %d\\n\",\n\t\t\t\t(int)value);\n\n\t\t\tret = value;\n\t\t\tgoto ret_unlock;\n\t\t}\n\n\t\tif (!(value & BIT(6))) {\n\t\t\t \n\n\t\t\tret = -EAGAIN;\n\t\t\tgoto ret_unlock;\n\t\t}\n\n\t\tvalue = i2c_smbus_read_byte_data(client, TC74_REG_TEMP);\n\t\tif (value < 0) {\n\t\t\tdev_dbg(&client->dev, \"TC74_REG_TEMP read err %d\\n\",\n\t\t\t\t(int)value);\n\n\t\t\tret = value;\n\t\t\tgoto ret_unlock;\n\t\t}\n\n\t\tdata->temp_input = value;\n\t\tdata->next_update = jiffies + HZ / 4;\n\t\tdata->valid = true;\n\t}\n\nret_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic ssize_t temp_input_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct tc74_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = tc74_update_device(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", data->temp_input * 1000);\n}\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp_input, 0);\n\nstatic struct attribute *tc74_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(tc74);\n\nstatic int tc74_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tc74_data *data;\n\tstruct device *hwmon_dev;\n\ts32 conf;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tdata = devm_kzalloc(dev, sizeof(struct tc74_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\t \n\tconf = i2c_smbus_read_byte_data(client, TC74_REG_CONFIG);\n\tif (conf < 0) {\n\t\tdev_err(dev, \"unable to read config register\\n\");\n\n\t\treturn conf;\n\t}\n\n\tif (conf & 0x3f) {\n\t\tdev_err(dev, \"invalid config register value\\n\");\n\n\t\treturn -ENODEV;\n\t}\n\n\tif (conf & BIT(7)) {\n\t\ts32 ret;\n\n\t\tconf &= ~BIT(7);\n\n\t\tret = i2c_smbus_write_byte_data(client, TC74_REG_CONFIG, conf);\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"unable to disable STANDBY\\n\");\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev,\n\t\t\t\t\t\t\t   client->name,\n\t\t\t\t\t\t\t   data, tc74_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id tc74_id[] = {\n\t{ \"tc74\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, tc74_id);\n\nstatic struct i2c_driver tc74_driver = {\n\t.driver = {\n\t\t.name\t= \"tc74\",\n\t},\n\t.probe = tc74_probe,\n\t.id_table = tc74_id,\n};\n\nmodule_i2c_driver(tc74_driver);\n\nMODULE_AUTHOR(\"Maciej Szmigiero <mail@maciej.szmigiero.name>\");\n\nMODULE_DESCRIPTION(\"TC74 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}