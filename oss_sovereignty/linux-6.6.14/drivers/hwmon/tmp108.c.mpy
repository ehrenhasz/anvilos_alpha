{
  "module_name": "tmp108.c",
  "hash_id": "a2b4c8125092e1aad3823b8093b5a1cad0a7a7aa92b62b6e819f3a2d8e648474",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/tmp108.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define\tDRIVER_NAME \"tmp108\"\n\n#define\tTMP108_REG_TEMP\t\t0x00\n#define\tTMP108_REG_CONF\t\t0x01\n#define\tTMP108_REG_TLOW\t\t0x02\n#define\tTMP108_REG_THIGH\t0x03\n\n#define TMP108_TEMP_MIN_MC\t-50000  \n#define TMP108_TEMP_MAX_MC\t127937  \n\n \n#define TMP108_CONF_M0\t\t0x0100  \n#define TMP108_CONF_M1\t\t0x0200\n#define TMP108_CONF_TM\t\t0x0400  \n#define TMP108_CONF_FL\t\t0x0800  \n#define TMP108_CONF_FH\t\t0x1000  \n#define TMP108_CONF_CR0\t\t0x2000  \n#define TMP108_CONF_CR1\t\t0x4000\n#define TMP108_CONF_ID\t\t0x8000\n#define TMP108_CONF_HYS0\t0x0010  \n#define TMP108_CONF_HYS1\t0x0020\n#define TMP108_CONF_POL\t\t0x0080  \n\n \n#define TMP108_CONF_DEFAULTS\t\t(TMP108_CONF_CR0 | TMP108_CONF_TM |\\\n\t\t\t\t\t TMP108_CONF_HYS0 | TMP108_CONF_M1)\n \n#define TMP108_CONF_READ_ONLY\t\t(TMP108_CONF_FL | TMP108_CONF_FH |\\\n\t\t\t\t\t TMP108_CONF_ID)\n\n#define TMP108_CONF_MODE_MASK\t\t(TMP108_CONF_M0|TMP108_CONF_M1)\n#define TMP108_MODE_SHUTDOWN\t\t0x0000\n#define TMP108_MODE_ONE_SHOT\t\tTMP108_CONF_M0\n#define TMP108_MODE_CONTINUOUS\t\tTMP108_CONF_M1\t\t \n\t\t\t\t\t \n\n#define TMP108_CONF_CONVRATE_MASK\t(TMP108_CONF_CR0|TMP108_CONF_CR1)\n#define TMP108_CONVRATE_0P25HZ\t\t0x0000\n#define TMP108_CONVRATE_1HZ\t\tTMP108_CONF_CR0\t\t \n#define TMP108_CONVRATE_4HZ\t\tTMP108_CONF_CR1\n#define TMP108_CONVRATE_16HZ\t\t(TMP108_CONF_CR0|TMP108_CONF_CR1)\n\n#define TMP108_CONF_HYSTERESIS_MASK\t(TMP108_CONF_HYS0|TMP108_CONF_HYS1)\n#define TMP108_HYSTERESIS_0C\t\t0x0000\n#define TMP108_HYSTERESIS_1C\t\tTMP108_CONF_HYS0\t \n#define TMP108_HYSTERESIS_2C\t\tTMP108_CONF_HYS1\n#define TMP108_HYSTERESIS_4C\t\t(TMP108_CONF_HYS0|TMP108_CONF_HYS1)\n\n#define TMP108_CONVERSION_TIME_MS\t30\t \n\nstruct tmp108 {\n\tstruct regmap *regmap;\n\tu16 orig_config;\n\tunsigned long ready_time;\n};\n\n \nstatic inline int tmp108_temp_reg_to_mC(s16 val)\n{\n\treturn (val & ~0x0f) * 1000 / 256;\n}\n\n \nstatic inline u16 tmp108_mC_to_temp_reg(int val)\n{\n\treturn (val * 256) / 1000;\n}\n\nstatic int tmp108_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long *temp)\n{\n\tstruct tmp108 *tmp108 = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err, hyst;\n\n\tif (type == hwmon_chip) {\n\t\tif (attr == hwmon_chip_update_interval) {\n\t\t\terr = regmap_read(tmp108->regmap, TMP108_REG_CONF,\n\t\t\t\t\t  &regval);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tswitch (regval & TMP108_CONF_CONVRATE_MASK) {\n\t\t\tcase TMP108_CONVRATE_0P25HZ:\n\t\t\tdefault:\n\t\t\t\t*temp = 4000;\n\t\t\t\tbreak;\n\t\t\tcase TMP108_CONVRATE_1HZ:\n\t\t\t\t*temp = 1000;\n\t\t\t\tbreak;\n\t\t\tcase TMP108_CONVRATE_4HZ:\n\t\t\t\t*temp = 250;\n\t\t\t\tbreak;\n\t\t\tcase TMP108_CONVRATE_16HZ:\n\t\t\t\t*temp = 63;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\t \n\t\tif (time_before(jiffies, tmp108->ready_time)) {\n\t\t\tdev_dbg(dev, \"%s: Conversion not ready yet..\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\terr = regmap_read(tmp108->regmap, TMP108_REG_TEMP, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*temp = tmp108_temp_reg_to_mC(regval);\n\t\tbreak;\n\tcase hwmon_temp_min:\n\tcase hwmon_temp_max:\n\t\terr = regmap_read(tmp108->regmap, attr == hwmon_temp_min ?\n\t\t\t\t  TMP108_REG_TLOW : TMP108_REG_THIGH, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*temp = tmp108_temp_reg_to_mC(regval);\n\t\tbreak;\n\tcase hwmon_temp_min_alarm:\n\tcase hwmon_temp_max_alarm:\n\t\terr = regmap_read(tmp108->regmap, TMP108_REG_CONF, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*temp = !!(regval & (attr == hwmon_temp_min_alarm ?\n\t\t\t\t     TMP108_CONF_FL : TMP108_CONF_FH));\n\t\tbreak;\n\tcase hwmon_temp_min_hyst:\n\tcase hwmon_temp_max_hyst:\n\t\terr = regmap_read(tmp108->regmap, TMP108_REG_CONF, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tswitch (regval & TMP108_CONF_HYSTERESIS_MASK) {\n\t\tcase TMP108_HYSTERESIS_0C:\n\t\tdefault:\n\t\t\thyst = 0;\n\t\t\tbreak;\n\t\tcase TMP108_HYSTERESIS_1C:\n\t\t\thyst = 1000;\n\t\t\tbreak;\n\t\tcase TMP108_HYSTERESIS_2C:\n\t\t\thyst = 2000;\n\t\t\tbreak;\n\t\tcase TMP108_HYSTERESIS_4C:\n\t\t\thyst = 4000;\n\t\t\tbreak;\n\t\t}\n\t\terr = regmap_read(tmp108->regmap, attr == hwmon_temp_min_hyst ?\n\t\t\t\t  TMP108_REG_TLOW : TMP108_REG_THIGH, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*temp = tmp108_temp_reg_to_mC(regval);\n\t\tif (attr == hwmon_temp_min_hyst)\n\t\t\t*temp += hyst;\n\t\telse\n\t\t\t*temp -= hyst;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int tmp108_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long temp)\n{\n\tstruct tmp108 *tmp108 = dev_get_drvdata(dev);\n\tu32 regval, mask;\n\tint err;\n\n\tif (type == hwmon_chip) {\n\t\tif (attr == hwmon_chip_update_interval) {\n\t\t\tif (temp < 156)\n\t\t\t\tmask = TMP108_CONVRATE_16HZ;\n\t\t\telse if (temp < 625)\n\t\t\t\tmask = TMP108_CONVRATE_4HZ;\n\t\t\telse if (temp < 2500)\n\t\t\t\tmask = TMP108_CONVRATE_1HZ;\n\t\t\telse\n\t\t\t\tmask = TMP108_CONVRATE_0P25HZ;\n\t\t\treturn regmap_update_bits(tmp108->regmap,\n\t\t\t\t\t\t  TMP108_REG_CONF,\n\t\t\t\t\t\t  TMP108_CONF_CONVRATE_MASK,\n\t\t\t\t\t\t  mask);\n\t\t}\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (attr) {\n\tcase hwmon_temp_min:\n\tcase hwmon_temp_max:\n\t\ttemp = clamp_val(temp, TMP108_TEMP_MIN_MC, TMP108_TEMP_MAX_MC);\n\t\treturn regmap_write(tmp108->regmap,\n\t\t\t\t    attr == hwmon_temp_min ?\n\t\t\t\t\tTMP108_REG_TLOW : TMP108_REG_THIGH,\n\t\t\t\t    tmp108_mC_to_temp_reg(temp));\n\tcase hwmon_temp_min_hyst:\n\tcase hwmon_temp_max_hyst:\n\t\ttemp = clamp_val(temp, TMP108_TEMP_MIN_MC, TMP108_TEMP_MAX_MC);\n\t\terr = regmap_read(tmp108->regmap,\n\t\t\t\t  attr == hwmon_temp_min_hyst ?\n\t\t\t\t\tTMP108_REG_TLOW : TMP108_REG_THIGH,\n\t\t\t\t  &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (attr == hwmon_temp_min_hyst)\n\t\t\ttemp -= tmp108_temp_reg_to_mC(regval);\n\t\telse\n\t\t\ttemp = tmp108_temp_reg_to_mC(regval) - temp;\n\t\tif (temp < 500)\n\t\t\tmask = TMP108_HYSTERESIS_0C;\n\t\telse if (temp < 1500)\n\t\t\tmask = TMP108_HYSTERESIS_1C;\n\t\telse if (temp < 3000)\n\t\t\tmask = TMP108_HYSTERESIS_2C;\n\t\telse\n\t\t\tmask = TMP108_HYSTERESIS_4C;\n\t\treturn regmap_update_bits(tmp108->regmap, TMP108_REG_CONF,\n\t\t\t\t\t  TMP108_CONF_HYSTERESIS_MASK, mask);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t tmp108_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel)\n{\n\tif (type == hwmon_chip && attr == hwmon_chip_update_interval)\n\t\treturn 0644;\n\n\tif (type != hwmon_temp)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_min_alarm:\n\tcase hwmon_temp_max_alarm:\n\t\treturn 0444;\n\tcase hwmon_temp_min:\n\tcase hwmon_temp_max:\n\tcase hwmon_temp_min_hyst:\n\tcase hwmon_temp_max_hyst:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const tmp108_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ | HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t   HWMON_T_MIN_HYST | HWMON_T_MAX_HYST |\n\t\t\t   HWMON_T_MIN_ALARM | HWMON_T_MAX_ALARM),\n\tNULL\n};\n\nstatic const struct hwmon_ops tmp108_hwmon_ops = {\n\t.is_visible = tmp108_is_visible,\n\t.read = tmp108_read,\n\t.write = tmp108_write,\n};\n\nstatic const struct hwmon_chip_info tmp108_chip_info = {\n\t.ops = &tmp108_hwmon_ops,\n\t.info = tmp108_info,\n};\n\nstatic void tmp108_restore_config(void *data)\n{\n\tstruct tmp108 *tmp108 = data;\n\n\tregmap_write(tmp108->regmap, TMP108_REG_CONF, tmp108->orig_config);\n}\n\nstatic bool tmp108_is_writeable_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg != TMP108_REG_TEMP;\n}\n\nstatic bool tmp108_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\t \n\treturn reg == TMP108_REG_TEMP || reg == TMP108_REG_CONF;\n}\n\nstatic const struct regmap_config tmp108_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = TMP108_REG_THIGH,\n\t.writeable_reg = tmp108_is_writeable_reg,\n\t.volatile_reg = tmp108_is_volatile_reg,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int tmp108_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct tmp108 *tmp108;\n\tint err;\n\tu32 config;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA)) {\n\t\tdev_err(dev,\n\t\t\t\"adapter doesn't support SMBus word transactions\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttmp108 = devm_kzalloc(dev, sizeof(*tmp108), GFP_KERNEL);\n\tif (!tmp108)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, tmp108);\n\n\ttmp108->regmap = devm_regmap_init_i2c(client, &tmp108_regmap_config);\n\tif (IS_ERR(tmp108->regmap)) {\n\t\terr = PTR_ERR(tmp108->regmap);\n\t\tdev_err(dev, \"regmap init failed: %d\", err);\n\t\treturn err;\n\t}\n\n\terr = regmap_read(tmp108->regmap, TMP108_REG_CONF, &config);\n\tif (err < 0) {\n\t\tdev_err(dev, \"error reading config register: %d\", err);\n\t\treturn err;\n\t}\n\ttmp108->orig_config = config;\n\n\t \n\tconfig &= ~TMP108_CONF_MODE_MASK;\n\tconfig |= TMP108_MODE_CONTINUOUS;\n\n\t \n\tconfig &= ~TMP108_CONF_TM;\n\n\terr = regmap_write(tmp108->regmap, TMP108_REG_CONF, config);\n\tif (err < 0) {\n\t\tdev_err(dev, \"error writing config register: %d\", err);\n\t\treturn err;\n\t}\n\n\ttmp108->ready_time = jiffies;\n\tif ((tmp108->orig_config & TMP108_CONF_MODE_MASK) ==\n\t    TMP108_MODE_SHUTDOWN)\n\t\ttmp108->ready_time +=\n\t\t\tmsecs_to_jiffies(TMP108_CONVERSION_TIME_MS);\n\n\terr = devm_add_action_or_reset(dev, tmp108_restore_config, tmp108);\n\tif (err) {\n\t\tdev_err(dev, \"add action or reset failed: %d\", err);\n\t\treturn err;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t tmp108,\n\t\t\t\t\t\t\t &tmp108_chip_info,\n\t\t\t\t\t\t\t NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic int tmp108_suspend(struct device *dev)\n{\n\tstruct tmp108 *tmp108 = dev_get_drvdata(dev);\n\n\treturn regmap_update_bits(tmp108->regmap, TMP108_REG_CONF,\n\t\t\t\t  TMP108_CONF_MODE_MASK, TMP108_MODE_SHUTDOWN);\n}\n\nstatic int tmp108_resume(struct device *dev)\n{\n\tstruct tmp108 *tmp108 = dev_get_drvdata(dev);\n\tint err;\n\n\terr = regmap_update_bits(tmp108->regmap, TMP108_REG_CONF,\n\t\t\t\t TMP108_CONF_MODE_MASK, TMP108_MODE_CONTINUOUS);\n\ttmp108->ready_time = jiffies +\n\t\t\t     msecs_to_jiffies(TMP108_CONVERSION_TIME_MS);\n\treturn err;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tmp108_dev_pm_ops, tmp108_suspend, tmp108_resume);\n\nstatic const struct i2c_device_id tmp108_i2c_ids[] = {\n\t{ \"tmp108\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tmp108_i2c_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tmp108_of_ids[] = {\n\t{ .compatible = \"ti,tmp108\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tmp108_of_ids);\n#endif\n\nstatic struct i2c_driver tmp108_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= pm_sleep_ptr(&tmp108_dev_pm_ops),\n\t\t.of_match_table = of_match_ptr(tmp108_of_ids),\n\t},\n\t.probe\t\t= tmp108_probe,\n\t.id_table\t= tmp108_i2c_ids,\n};\n\nmodule_i2c_driver(tmp108_driver);\n\nMODULE_AUTHOR(\"John Muir <john@jmuir.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments TMP108 temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}