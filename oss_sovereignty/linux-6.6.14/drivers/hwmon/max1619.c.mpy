{
  "module_name": "max1619.c",
  "hash_id": "814b1cd6a9ba0d8c2a58bce8ea3ef4216a1191566edbc99422cbd91b5d2ab2a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max1619.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n\nstatic const unsigned short normal_i2c[] = {\n\t0x18, 0x19, 0x1a, 0x29, 0x2a, 0x2b, 0x4c, 0x4d, 0x4e, I2C_CLIENT_END };\n\n \n\n#define MAX1619_REG_R_MAN_ID\t\t0xFE\n#define MAX1619_REG_R_CHIP_ID\t\t0xFF\n#define MAX1619_REG_R_CONFIG\t\t0x03\n#define MAX1619_REG_W_CONFIG\t\t0x09\n#define MAX1619_REG_R_CONVRATE\t\t0x04\n#define MAX1619_REG_W_CONVRATE\t\t0x0A\n#define MAX1619_REG_R_STATUS\t\t0x02\n#define MAX1619_REG_R_LOCAL_TEMP\t0x00\n#define MAX1619_REG_R_REMOTE_TEMP\t0x01\n#define MAX1619_REG_R_REMOTE_HIGH\t0x07\n#define MAX1619_REG_W_REMOTE_HIGH\t0x0D\n#define MAX1619_REG_R_REMOTE_LOW\t0x08\n#define MAX1619_REG_W_REMOTE_LOW\t0x0E\n#define MAX1619_REG_R_REMOTE_CRIT\t0x10\n#define MAX1619_REG_W_REMOTE_CRIT\t0x12\n#define MAX1619_REG_R_TCRIT_HYST\t0x11\n#define MAX1619_REG_W_TCRIT_HYST\t0x13\n\n \n\nstatic int temp_from_reg(int val)\n{\n\treturn (val & 0x80 ? val-0x100 : val) * 1000;\n}\n\nstatic int temp_to_reg(int val)\n{\n\treturn (val < 0 ? val+0x100*1000 : val) / 1000;\n}\n\nenum temp_index {\n\tt_input1 = 0,\n\tt_input2,\n\tt_low2,\n\tt_high2,\n\tt_crit2,\n\tt_hyst2,\n\tt_num_regs\n};\n\n \n\nstruct max1619_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tbool valid;  \n\tunsigned long last_updated;  \n\n\t \n\tu8 temp[t_num_regs];\t \n\tu8 alarms;\n};\n\nstatic const u8 regs_read[t_num_regs] = {\n\t[t_input1] = MAX1619_REG_R_LOCAL_TEMP,\n\t[t_input2] = MAX1619_REG_R_REMOTE_TEMP,\n\t[t_low2] = MAX1619_REG_R_REMOTE_LOW,\n\t[t_high2] = MAX1619_REG_R_REMOTE_HIGH,\n\t[t_crit2] = MAX1619_REG_R_REMOTE_CRIT,\n\t[t_hyst2] = MAX1619_REG_R_TCRIT_HYST,\n};\n\nstatic const u8 regs_write[t_num_regs] = {\n\t[t_low2] = MAX1619_REG_W_REMOTE_LOW,\n\t[t_high2] = MAX1619_REG_W_REMOTE_HIGH,\n\t[t_crit2] = MAX1619_REG_W_REMOTE_CRIT,\n\t[t_hyst2] = MAX1619_REG_W_TCRIT_HYST,\n};\n\nstatic struct max1619_data *max1619_update_device(struct device *dev)\n{\n\tstruct max1619_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint config, i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ * 2) || !data->valid) {\n\t\tdev_dbg(&client->dev, \"Updating max1619 data.\\n\");\n\t\tfor (i = 0; i < t_num_regs; i++)\n\t\t\tdata->temp[i] = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tregs_read[i]);\n\t\tdata->alarms = i2c_smbus_read_byte_data(client,\n\t\t\t\t\tMAX1619_REG_R_STATUS);\n\t\t \n\t\tconfig = i2c_smbus_read_byte_data(client, MAX1619_REG_R_CONFIG);\n\t\tif (!(config & 0x20))\n\t\t\tdata->alarms ^= 0x02;\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct max1619_data *data = max1619_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", temp_from_reg(data->temp[attr->index]));\n}\n\nstatic ssize_t temp_store(struct device *dev,\n\t\t\t  struct device_attribute *devattr, const char *buf,\n\t\t\t  size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct max1619_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tlong val;\n\tint err = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp[attr->index] = temp_to_reg(val);\n\ti2c_smbus_write_byte_data(client, regs_write[attr->index],\n\t\t\t\t  data->temp[attr->index]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct max1619_data *data = max1619_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->alarms);\n}\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tstruct max1619_data *data = max1619_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (data->alarms >> bitnr) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, t_input1);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, t_input2);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_min, temp, t_low2);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp, t_high2);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_crit, temp, t_crit2);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_crit_hyst, temp, t_hyst2);\n\nstatic DEVICE_ATTR_RO(alarms);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_crit_alarm, alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_fault, alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_min_alarm, alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_max_alarm, alarm, 4);\n\nstatic struct attribute *max1619_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit_hyst.dev_attr.attr,\n\n\t&dev_attr_alarms.attr,\n\t&sensor_dev_attr_temp2_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(max1619);\n\n \nstatic int max1619_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tu8 reg_config, reg_convrate, reg_status, man_id, chip_id;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\treg_config = i2c_smbus_read_byte_data(client, MAX1619_REG_R_CONFIG);\n\treg_convrate = i2c_smbus_read_byte_data(client, MAX1619_REG_R_CONVRATE);\n\treg_status = i2c_smbus_read_byte_data(client, MAX1619_REG_R_STATUS);\n\tif ((reg_config & 0x03) != 0x00\n\t || reg_convrate > 0x07 || (reg_status & 0x61) != 0x00) {\n\t\tdev_dbg(&adapter->dev, \"MAX1619 detection failed at 0x%02x\\n\",\n\t\t\tclient->addr);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tman_id = i2c_smbus_read_byte_data(client, MAX1619_REG_R_MAN_ID);\n\tchip_id = i2c_smbus_read_byte_data(client, MAX1619_REG_R_CHIP_ID);\n\tif (man_id != 0x4D || chip_id != 0x04) {\n\t\tdev_info(&adapter->dev,\n\t\t\t \"Unsupported chip (man_id=0x%02X, chip_id=0x%02X).\\n\",\n\t\t\t man_id, chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, \"max1619\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic void max1619_init_client(struct i2c_client *client)\n{\n\tu8 config;\n\n\t \n\ti2c_smbus_write_byte_data(client, MAX1619_REG_W_CONVRATE,\n\t\t\t\t  5);  \n\tconfig = i2c_smbus_read_byte_data(client, MAX1619_REG_R_CONFIG);\n\tif (config & 0x40)\n\t\ti2c_smbus_write_byte_data(client, MAX1619_REG_W_CONFIG,\n\t\t\t\t\t  config & 0xBF);  \n}\n\nstatic int max1619_probe(struct i2c_client *new_client)\n{\n\tstruct max1619_data *data;\n\tstruct device *hwmon_dev;\n\n\tdata = devm_kzalloc(&new_client->dev, sizeof(struct max1619_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = new_client;\n\tmutex_init(&data->update_lock);\n\n\t \n\tmax1619_init_client(new_client);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(&new_client->dev,\n\t\t\t\t\t\t\t   new_client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   max1619_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id max1619_id[] = {\n\t{ \"max1619\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max1619_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id max1619_of_match[] = {\n\t{ .compatible = \"maxim,max1619\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, max1619_of_match);\n#endif\n\nstatic struct i2c_driver max1619_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"max1619\",\n\t\t.of_match_table = of_match_ptr(max1619_of_match),\n\t},\n\t.probe\t\t= max1619_probe,\n\t.id_table\t= max1619_id,\n\t.detect\t\t= max1619_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(max1619_driver);\n\nMODULE_AUTHOR(\"Oleksij Rempel <bug-track@fisher-privat.net>, Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"MAX1619 sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}