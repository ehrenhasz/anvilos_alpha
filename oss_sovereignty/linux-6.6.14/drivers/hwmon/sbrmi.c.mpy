{
  "module_name": "sbrmi.c",
  "hash_id": "2bdaf96b1f57249df40fa8f202127794525b3526feeb018321031ddc0ed757cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/sbrmi.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n\n \n#define SBRMI_PWR_MIN\t0\n \n#define SW_ALERT_MASK\t0x2\n\n \n#define START_CMD\t0x80\n#define TRIGGER_MAILBOX\t0x01\n\n \nenum sbrmi_msg_id {\n\tSBRMI_READ_PKG_PWR_CONSUMPTION = 0x1,\n\tSBRMI_WRITE_PKG_PWR_LIMIT,\n\tSBRMI_READ_PKG_PWR_LIMIT,\n\tSBRMI_READ_PKG_MAX_PWR_LIMIT,\n};\n\n \nenum sbrmi_reg {\n\tSBRMI_CTRL\t\t= 0x01,\n\tSBRMI_STATUS,\n\tSBRMI_OUTBNDMSG0\t= 0x30,\n\tSBRMI_OUTBNDMSG1,\n\tSBRMI_OUTBNDMSG2,\n\tSBRMI_OUTBNDMSG3,\n\tSBRMI_OUTBNDMSG4,\n\tSBRMI_OUTBNDMSG5,\n\tSBRMI_OUTBNDMSG6,\n\tSBRMI_OUTBNDMSG7,\n\tSBRMI_INBNDMSG0,\n\tSBRMI_INBNDMSG1,\n\tSBRMI_INBNDMSG2,\n\tSBRMI_INBNDMSG3,\n\tSBRMI_INBNDMSG4,\n\tSBRMI_INBNDMSG5,\n\tSBRMI_INBNDMSG6,\n\tSBRMI_INBNDMSG7,\n\tSBRMI_SW_INTERRUPT,\n};\n\n \nstruct sbrmi_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tu32 pwr_limit_max;\n};\n\nstruct sbrmi_mailbox_msg {\n\tu8 cmd;\n\tbool read;\n\tu32 data_in;\n\tu32 data_out;\n};\n\nstatic int sbrmi_enable_alert(struct i2c_client *client)\n{\n\tint ctrl;\n\n\t \n\tctrl = i2c_smbus_read_byte_data(client, SBRMI_CTRL);\n\tif (ctrl < 0)\n\t\treturn ctrl;\n\n\tif (ctrl & 0x10) {\n\t\tctrl &= ~0x10;\n\t\treturn i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\t SBRMI_CTRL, ctrl);\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_mailbox_xfer(struct sbrmi_data *data,\n\t\t\t    struct sbrmi_mailbox_msg *msg)\n{\n\tint i, ret, retry = 10;\n\tint sw_status;\n\tu8 byte;\n\n\tmutex_lock(&data->lock);\n\n\t \n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tSBRMI_INBNDMSG7, START_CMD);\n\tif (ret < 0)\n\t\tgoto exit_unlock;\n\n\t \n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tSBRMI_INBNDMSG0, msg->cmd);\n\tif (ret < 0)\n\t\tgoto exit_unlock;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tbyte = (msg->data_in >> i * 8) & 0xff;\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t\tSBRMI_INBNDMSG1 + i, byte);\n\t\tif (ret < 0)\n\t\t\tgoto exit_unlock;\n\t}\n\n\t \n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tSBRMI_SW_INTERRUPT, TRIGGER_MAILBOX);\n\tif (ret < 0)\n\t\tgoto exit_unlock;\n\n\t \n\tdo {\n\t\tsw_status = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t\t     SBRMI_STATUS);\n\t\tif (sw_status < 0) {\n\t\t\tret = sw_status;\n\t\t\tgoto exit_unlock;\n\t\t}\n\t\tif (sw_status & SW_ALERT_MASK)\n\t\t\tbreak;\n\t\tusleep_range(50, 100);\n\t} while (retry--);\n\n\tif (retry < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"Firmware fail to indicate command completion\\n\");\n\t\tret = -EIO;\n\t\tgoto exit_unlock;\n\t}\n\n\t \n\tif (msg->read) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t\t       SBRMI_OUTBNDMSG1 + i);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit_unlock;\n\t\t\tmsg->data_out |= ret << i * 8;\n\t\t}\n\t}\n\n\t \n\tret = i2c_smbus_write_byte_data(data->client, SBRMI_STATUS,\n\t\t\t\t\tsw_status | SW_ALERT_MASK);\n\nexit_unlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int sbrmi_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t      u32 attr, int channel, long *val)\n{\n\tstruct sbrmi_data *data = dev_get_drvdata(dev);\n\tstruct sbrmi_mailbox_msg msg = { 0 };\n\tint ret;\n\n\tif (type != hwmon_power)\n\t\treturn -EINVAL;\n\n\tmsg.read = true;\n\tswitch (attr) {\n\tcase hwmon_power_input:\n\t\tmsg.cmd = SBRMI_READ_PKG_PWR_CONSUMPTION;\n\t\tret = rmi_mailbox_xfer(data, &msg);\n\t\tbreak;\n\tcase hwmon_power_cap:\n\t\tmsg.cmd = SBRMI_READ_PKG_PWR_LIMIT;\n\t\tret = rmi_mailbox_xfer(data, &msg);\n\t\tbreak;\n\tcase hwmon_power_cap_max:\n\t\tmsg.data_out = data->pwr_limit_max;\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\t*val = (long)msg.data_out * 1000;\n\treturn ret;\n}\n\nstatic int sbrmi_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t       u32 attr, int channel, long val)\n{\n\tstruct sbrmi_data *data = dev_get_drvdata(dev);\n\tstruct sbrmi_mailbox_msg msg = { 0 };\n\n\tif (type != hwmon_power && attr != hwmon_power_cap)\n\t\treturn -EINVAL;\n\t \n\tval /= 1000;\n\n\tval = clamp_val(val, SBRMI_PWR_MIN, data->pwr_limit_max);\n\n\tmsg.cmd = SBRMI_WRITE_PKG_PWR_LIMIT;\n\tmsg.data_in = val;\n\tmsg.read = false;\n\n\treturn rmi_mailbox_xfer(data, &msg);\n}\n\nstatic umode_t sbrmi_is_visible(const void *data,\n\t\t\t\tenum hwmon_sensor_types type,\n\t\t\t\tu32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_power:\n\t\tswitch (attr) {\n\t\tcase hwmon_power_input:\n\t\tcase hwmon_power_cap_max:\n\t\t\treturn 0444;\n\t\tcase hwmon_power_cap:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const sbrmi_info[] = {\n\tHWMON_CHANNEL_INFO(power,\n\t\t\t   HWMON_P_INPUT | HWMON_P_CAP | HWMON_P_CAP_MAX),\n\tNULL\n};\n\nstatic const struct hwmon_ops sbrmi_hwmon_ops = {\n\t.is_visible = sbrmi_is_visible,\n\t.read = sbrmi_read,\n\t.write = sbrmi_write,\n};\n\nstatic const struct hwmon_chip_info sbrmi_chip_info = {\n\t.ops = &sbrmi_hwmon_ops,\n\t.info = sbrmi_info,\n};\n\nstatic int sbrmi_get_max_pwr_limit(struct sbrmi_data *data)\n{\n\tstruct sbrmi_mailbox_msg msg = { 0 };\n\tint ret;\n\n\tmsg.cmd = SBRMI_READ_PKG_MAX_PWR_LIMIT;\n\tmsg.read = true;\n\tret = rmi_mailbox_xfer(data, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->pwr_limit_max = msg.data_out;\n\n\treturn ret;\n}\n\nstatic int sbrmi_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct sbrmi_data *data;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(struct sbrmi_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\t \n\tret = sbrmi_enable_alert(client);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = sbrmi_get_max_pwr_limit(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name, data,\n\t\t\t\t\t\t\t &sbrmi_chip_info, NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id sbrmi_id[] = {\n\t{\"sbrmi\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, sbrmi_id);\n\nstatic const struct of_device_id __maybe_unused sbrmi_of_match[] = {\n\t{\n\t\t.compatible = \"amd,sbrmi\",\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sbrmi_of_match);\n\nstatic struct i2c_driver sbrmi_driver = {\n\t.class = I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"sbrmi\",\n\t\t.of_match_table = of_match_ptr(sbrmi_of_match),\n\t},\n\t.probe = sbrmi_probe,\n\t.id_table = sbrmi_id,\n};\n\nmodule_i2c_driver(sbrmi_driver);\n\nMODULE_AUTHOR(\"Akshay Gupta <akshay.gupta@amd.com>\");\nMODULE_DESCRIPTION(\"Hwmon driver for AMD SB-RMI emulated sensor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}