{
  "module_name": "max31730.c",
  "hash_id": "818e3fab9f184bfd21f75fb7b3241365464cd9c6acbe67a6661cb4f77576633d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/max31730.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/hwmon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x1c, 0x1d, 0x1e, 0x1f, 0x4c,\n\t\t\t\t\t     0x4d, 0x4e, 0x4f, I2C_CLIENT_END };\n\n \n#define MAX31730_REG_TEMP\t\t0x00\n#define MAX31730_REG_CONF\t\t0x13\n#define  MAX31730_STOP\t\t\tBIT(7)\n#define  MAX31730_EXTRANGE\t\tBIT(1)\n#define MAX31730_REG_TEMP_OFFSET\t0x16\n#define  MAX31730_TEMP_OFFSET_BASELINE\t0x77\n#define MAX31730_REG_OFFSET_ENABLE\t0x17\n#define MAX31730_REG_TEMP_MAX\t\t0x20\n#define MAX31730_REG_TEMP_MIN\t\t0x30\n#define MAX31730_REG_STATUS_HIGH\t0x32\n#define MAX31730_REG_STATUS_LOW\t\t0x33\n#define MAX31730_REG_CHANNEL_ENABLE\t0x35\n#define MAX31730_REG_TEMP_FAULT\t\t0x36\n\n#define MAX31730_REG_MFG_ID\t\t0x50\n#define  MAX31730_MFG_ID\t\t0x4d\n#define MAX31730_REG_MFG_REV\t\t0x51\n#define  MAX31730_MFG_REV\t\t0x01\n\n#define MAX31730_TEMP_MIN\t\t(-128000)\n#define MAX31730_TEMP_MAX\t\t127937\n\n \nstruct max31730_data {\n\tstruct i2c_client\t*client;\n\tu8\t\t\torig_conf;\n\tu8\t\t\tcurrent_conf;\n\tu8\t\t\toffset_enable;\n\tu8\t\t\tchannel_enable;\n};\n\n \n\nstatic inline long max31730_reg_to_mc(s16 temp)\n{\n\treturn DIV_ROUND_CLOSEST((temp >> 4) * 1000, 16);\n}\n\nstatic int max31730_write_config(struct max31730_data *data, u8 set_mask,\n\t\t\t\t u8 clr_mask)\n{\n\tu8 value;\n\n\tclr_mask |= MAX31730_EXTRANGE;\n\tvalue = data->current_conf & ~clr_mask;\n\tvalue |= set_mask;\n\n\tif (data->current_conf != value) {\n\t\ts32 err;\n\n\t\terr = i2c_smbus_write_byte_data(data->client, MAX31730_REG_CONF,\n\t\t\t\t\t\tvalue);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata->current_conf = value;\n\t}\n\treturn 0;\n}\n\nstatic int max31730_set_enable(struct i2c_client *client, int reg,\n\t\t\t       u8 *confdata, int channel, bool enable)\n{\n\tu8 regval = *confdata;\n\tint err;\n\n\tif (enable)\n\t\tregval |= BIT(channel);\n\telse\n\t\tregval &= ~BIT(channel);\n\n\tif (regval != *confdata) {\n\t\terr = i2c_smbus_write_byte_data(client, reg, regval);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*confdata = regval;\n\t}\n\treturn 0;\n}\n\nstatic int max31730_set_offset_enable(struct max31730_data *data, int channel,\n\t\t\t\t      bool enable)\n{\n\treturn max31730_set_enable(data->client, MAX31730_REG_OFFSET_ENABLE,\n\t\t\t\t   &data->offset_enable, channel, enable);\n}\n\nstatic int max31730_set_channel_enable(struct max31730_data *data, int channel,\n\t\t\t\t       bool enable)\n{\n\treturn max31730_set_enable(data->client, MAX31730_REG_CHANNEL_ENABLE,\n\t\t\t\t   &data->channel_enable, channel, enable);\n}\n\nstatic int max31730_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long *val)\n{\n\tstruct max31730_data *data = dev_get_drvdata(dev);\n\tint regval, reg, offset;\n\n\tif (type != hwmon_temp)\n\t\treturn -EINVAL;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tif (!(data->channel_enable & BIT(channel)))\n\t\t\treturn -ENODATA;\n\t\treg = MAX31730_REG_TEMP + (channel * 2);\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\treg = MAX31730_REG_TEMP_MAX + (channel * 2);\n\t\tbreak;\n\tcase hwmon_temp_min:\n\t\treg = MAX31730_REG_TEMP_MIN;\n\t\tbreak;\n\tcase hwmon_temp_enable:\n\t\t*val = !!(data->channel_enable & BIT(channel));\n\t\treturn 0;\n\tcase hwmon_temp_offset:\n\t\tif (!channel)\n\t\t\treturn -EINVAL;\n\t\tif (!(data->offset_enable & BIT(channel))) {\n\t\t\t*val = 0;\n\t\t\treturn 0;\n\t\t}\n\t\toffset = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t\t  MAX31730_REG_TEMP_OFFSET);\n\t\tif (offset < 0)\n\t\t\treturn offset;\n\t\t*val = (offset - MAX31730_TEMP_OFFSET_BASELINE) * 125;\n\t\treturn 0;\n\tcase hwmon_temp_fault:\n\t\tregval = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t\t  MAX31730_REG_TEMP_FAULT);\n\t\tif (regval < 0)\n\t\t\treturn regval;\n\t\t*val = !!(regval & BIT(channel));\n\t\treturn 0;\n\tcase hwmon_temp_min_alarm:\n\t\tregval = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t\t  MAX31730_REG_STATUS_LOW);\n\t\tif (regval < 0)\n\t\t\treturn regval;\n\t\t*val = !!(regval & BIT(channel));\n\t\treturn 0;\n\tcase hwmon_temp_max_alarm:\n\t\tregval = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t\t  MAX31730_REG_STATUS_HIGH);\n\t\tif (regval < 0)\n\t\t\treturn regval;\n\t\t*val = !!(regval & BIT(channel));\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tregval = i2c_smbus_read_word_swapped(data->client, reg);\n\tif (regval < 0)\n\t\treturn regval;\n\n\t*val = max31730_reg_to_mc(regval);\n\n\treturn 0;\n}\n\nstatic int max31730_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t  u32 attr, int channel, long val)\n{\n\tstruct max31730_data *data = dev_get_drvdata(dev);\n\tint reg, err;\n\n\tif (type != hwmon_temp)\n\t\treturn -EINVAL;\n\n\tswitch (attr) {\n\tcase hwmon_temp_max:\n\t\treg = MAX31730_REG_TEMP_MAX + channel * 2;\n\t\tbreak;\n\tcase hwmon_temp_min:\n\t\treg = MAX31730_REG_TEMP_MIN;\n\t\tbreak;\n\tcase hwmon_temp_enable:\n\t\tif (val != 0 && val != 1)\n\t\t\treturn -EINVAL;\n\t\treturn max31730_set_channel_enable(data, channel, val);\n\tcase hwmon_temp_offset:\n\t\tval = clamp_val(val, -14875, 17000) + 14875;\n\t\tval = DIV_ROUND_CLOSEST(val, 125);\n\t\terr = max31730_set_offset_enable(data, channel,\n\t\t\t\t\tval != MAX31730_TEMP_OFFSET_BASELINE);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t\t MAX31730_REG_TEMP_OFFSET, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = clamp_val(val, MAX31730_TEMP_MIN, MAX31730_TEMP_MAX);\n\tval = DIV_ROUND_CLOSEST(val << 4, 1000) << 4;\n\n\treturn i2c_smbus_write_word_swapped(data->client, reg, (u16)val);\n}\n\nstatic umode_t max31730_is_visible(const void *data,\n\t\t\t\t   enum hwmon_sensor_types type,\n\t\t\t\t   u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_min_alarm:\n\t\tcase hwmon_temp_max_alarm:\n\t\tcase hwmon_temp_fault:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_min:\n\t\t\treturn channel ? 0444 : 0644;\n\t\tcase hwmon_temp_offset:\n\t\tcase hwmon_temp_enable:\n\t\tcase hwmon_temp_max:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const max31730_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |\n\t\t\t   HWMON_T_ENABLE |\n\t\t\t   HWMON_T_MIN_ALARM | HWMON_T_MAX_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |\n\t\t\t   HWMON_T_OFFSET | HWMON_T_ENABLE |\n\t\t\t   HWMON_T_MIN_ALARM | HWMON_T_MAX_ALARM |\n\t\t\t   HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |\n\t\t\t   HWMON_T_OFFSET | HWMON_T_ENABLE |\n\t\t\t   HWMON_T_MIN_ALARM | HWMON_T_MAX_ALARM |\n\t\t\t   HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |\n\t\t\t   HWMON_T_OFFSET | HWMON_T_ENABLE |\n\t\t\t   HWMON_T_MIN_ALARM | HWMON_T_MAX_ALARM |\n\t\t\t   HWMON_T_FAULT\n\t\t\t   ),\n\tNULL\n};\n\nstatic const struct hwmon_ops max31730_hwmon_ops = {\n\t.is_visible = max31730_is_visible,\n\t.read = max31730_read,\n\t.write = max31730_write,\n};\n\nstatic const struct hwmon_chip_info max31730_chip_info = {\n\t.ops = &max31730_hwmon_ops,\n\t.info = max31730_info,\n};\n\nstatic void max31730_remove(void *data)\n{\n\tstruct max31730_data *max31730 = data;\n\tstruct i2c_client *client = max31730->client;\n\n\ti2c_smbus_write_byte_data(client, MAX31730_REG_CONF,\n\t\t\t\t  max31730->orig_conf);\n}\n\nstatic int\nmax31730_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct max31730_data *data;\n\tint status, err;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\tI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EIO;\n\n\tdata = devm_kzalloc(dev, sizeof(struct max31730_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\n\t \n\tstatus = i2c_smbus_read_byte_data(client, MAX31730_REG_CHANNEL_ENABLE);\n\tif (status < 0)\n\t\treturn status;\n\tdata->channel_enable = status;\n\n\tstatus = i2c_smbus_read_byte_data(client, MAX31730_REG_OFFSET_ENABLE);\n\tif (status < 0)\n\t\treturn status;\n\tdata->offset_enable = status;\n\n\tstatus = i2c_smbus_read_byte_data(client, MAX31730_REG_CONF);\n\tif (status < 0)\n\t\treturn status;\n\tdata->orig_conf = status;\n\tdata->current_conf = status;\n\n\terr = max31730_write_config(data,\n\t\t\t\t    data->channel_enable ? 0 : MAX31730_STOP,\n\t\t\t\t    data->channel_enable ? MAX31730_STOP : 0);\n\tif (err)\n\t\treturn err;\n\n\tdev_set_drvdata(dev, data);\n\n\terr = devm_add_action_or_reset(dev, max31730_remove, data);\n\tif (err)\n\t\treturn err;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &max31730_chip_info,\n\t\t\t\t\t\t\t NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id max31730_ids[] = {\n\t{ \"max31730\", 0, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max31730_ids);\n\nstatic const struct of_device_id __maybe_unused max31730_of_match[] = {\n\t{\n\t\t.compatible = \"maxim,max31730\",\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, max31730_of_match);\n\nstatic bool max31730_check_reg_temp(struct i2c_client *client,\n\t\t\t\t    int reg)\n{\n\tint regval;\n\n\tregval = i2c_smbus_read_byte_data(client, reg + 1);\n\treturn regval < 0 || (regval & 0x0f);\n}\n\n \nstatic int max31730_detect(struct i2c_client *client,\n\t\t\t   struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint regval;\n\tint i;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tregval = i2c_smbus_read_byte_data(client, MAX31730_REG_MFG_ID);\n\tif (regval != MAX31730_MFG_ID)\n\t\treturn -ENODEV;\n\tregval = i2c_smbus_read_byte_data(client, MAX31730_REG_MFG_REV);\n\tif (regval != MAX31730_MFG_REV)\n\t\treturn -ENODEV;\n\n\t \n\tif (max31730_check_reg_temp(client, MAX31730_REG_TEMP_MIN))\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (max31730_check_reg_temp(client, MAX31730_REG_TEMP + i * 2))\n\t\t\treturn -ENODEV;\n\t\tif (max31730_check_reg_temp(client,\n\t\t\t\t\t    MAX31730_REG_TEMP_MAX + i * 2))\n\t\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, \"max31730\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int max31730_suspend(struct device *dev)\n{\n\tstruct max31730_data *data = dev_get_drvdata(dev);\n\n\treturn max31730_write_config(data, MAX31730_STOP, 0);\n}\n\nstatic int max31730_resume(struct device *dev)\n{\n\tstruct max31730_data *data = dev_get_drvdata(dev);\n\n\treturn max31730_write_config(data, 0, MAX31730_STOP);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(max31730_pm_ops, max31730_suspend, max31730_resume);\n\nstatic struct i2c_driver max31730_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"max31730\",\n\t\t.of_match_table = of_match_ptr(max31730_of_match),\n\t\t.pm\t= pm_sleep_ptr(&max31730_pm_ops),\n\t},\n\t.probe\t\t= max31730_probe,\n\t.id_table\t= max31730_ids,\n\t.detect\t\t= max31730_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(max31730_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"MAX31730 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}