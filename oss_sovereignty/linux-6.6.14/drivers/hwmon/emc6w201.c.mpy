{
  "module_name": "emc6w201.c",
  "hash_id": "0fc3c1e8f55b2bc50040f5e343f85085fc7c74583a385b591395e4b1346b8b4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/emc6w201.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n\n \n\nstatic const unsigned short normal_i2c[] = { 0x2c, 0x2d, 0x2e, I2C_CLIENT_END };\n\n \n\n#define EMC6W201_REG_IN(nr)\t\t(0x20 + (nr))\n#define EMC6W201_REG_TEMP(nr)\t\t(0x26 + (nr))\n#define EMC6W201_REG_FAN(nr)\t\t(0x2C + (nr) * 2)\n#define EMC6W201_REG_COMPANY\t\t0x3E\n#define EMC6W201_REG_VERSTEP\t\t0x3F\n#define EMC6W201_REG_CONFIG\t\t0x40\n#define EMC6W201_REG_IN_LOW(nr)\t\t(0x4A + (nr) * 2)\n#define EMC6W201_REG_IN_HIGH(nr)\t(0x4B + (nr) * 2)\n#define EMC6W201_REG_TEMP_LOW(nr)\t(0x56 + (nr) * 2)\n#define EMC6W201_REG_TEMP_HIGH(nr)\t(0x57 + (nr) * 2)\n#define EMC6W201_REG_FAN_MIN(nr)\t(0x62 + (nr) * 2)\n\nenum subfeature { input, min, max };\n\n \n\nstruct emc6w201_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\tbool valid;  \n\tunsigned long last_updated;  \n\n\t \n\tu8 in[3][6];\n\ts8 temp[3][6];\n\tu16 fan[2][5];\n};\n\n \nstatic u16 emc6w201_read16(struct i2c_client *client, u8 reg)\n{\n\tint lsb, msb;\n\n\tlsb = i2c_smbus_read_byte_data(client, reg);\n\tmsb = i2c_smbus_read_byte_data(client, reg + 1);\n\tif (unlikely(lsb < 0 || msb < 0)) {\n\t\tdev_err(&client->dev, \"%d-bit %s failed at 0x%02x\\n\",\n\t\t\t16, \"read\", reg);\n\t\treturn 0xFFFF;\t \n\t}\n\n\treturn (msb << 8) | lsb;\n}\n\n \nstatic int emc6w201_write16(struct i2c_client *client, u8 reg, u16 val)\n{\n\tint err;\n\n\terr = i2c_smbus_write_byte_data(client, reg, val & 0xff);\n\tif (likely(!err))\n\t\terr = i2c_smbus_write_byte_data(client, reg + 1, val >> 8);\n\tif (unlikely(err < 0))\n\t\tdev_err(&client->dev, \"%d-bit %s failed at 0x%02x\\n\",\n\t\t\t16, \"write\", reg);\n\n\treturn err;\n}\n\n \nstatic u8 emc6w201_read8(struct i2c_client *client, u8 reg)\n{\n\tint val;\n\n\tval = i2c_smbus_read_byte_data(client, reg);\n\tif (unlikely(val < 0)) {\n\t\tdev_err(&client->dev, \"%d-bit %s failed at 0x%02x\\n\",\n\t\t\t8, \"read\", reg);\n\t\treturn 0x00;\t \n\t}\n\n\treturn val;\n}\n\n \nstatic int emc6w201_write8(struct i2c_client *client, u8 reg, u8 val)\n{\n\tint err;\n\n\terr = i2c_smbus_write_byte_data(client, reg, val);\n\tif (unlikely(err < 0))\n\t\tdev_err(&client->dev, \"%d-bit %s failed at 0x%02x\\n\",\n\t\t\t8, \"write\", reg);\n\n\treturn err;\n}\n\nstatic struct emc6w201_data *emc6w201_update_device(struct device *dev)\n{\n\tstruct emc6w201_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\n\t\tfor (nr = 0; nr < 6; nr++) {\n\t\t\tdata->in[input][nr] =\n\t\t\t\temc6w201_read8(client,\n\t\t\t\t\t\tEMC6W201_REG_IN(nr));\n\t\t\tdata->in[min][nr] =\n\t\t\t\temc6w201_read8(client,\n\t\t\t\t\t\tEMC6W201_REG_IN_LOW(nr));\n\t\t\tdata->in[max][nr] =\n\t\t\t\temc6w201_read8(client,\n\t\t\t\t\t\tEMC6W201_REG_IN_HIGH(nr));\n\t\t}\n\n\t\tfor (nr = 0; nr < 6; nr++) {\n\t\t\tdata->temp[input][nr] =\n\t\t\t\temc6w201_read8(client,\n\t\t\t\t\t\tEMC6W201_REG_TEMP(nr));\n\t\t\tdata->temp[min][nr] =\n\t\t\t\temc6w201_read8(client,\n\t\t\t\t\t\tEMC6W201_REG_TEMP_LOW(nr));\n\t\t\tdata->temp[max][nr] =\n\t\t\t\temc6w201_read8(client,\n\t\t\t\t\t\tEMC6W201_REG_TEMP_HIGH(nr));\n\t\t}\n\n\t\tfor (nr = 0; nr < 5; nr++) {\n\t\t\tdata->fan[input][nr] =\n\t\t\t\temc6w201_read16(client,\n\t\t\t\t\t\tEMC6W201_REG_FAN(nr));\n\t\t\tdata->fan[min][nr] =\n\t\t\t\temc6w201_read16(client,\n\t\t\t\t\t\tEMC6W201_REG_FAN_MIN(nr));\n\t\t}\n\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n \n\nstatic const s16 nominal_mv[6] = { 2500, 1500, 3300, 5000, 1500, 1500 };\n\nstatic ssize_t in_show(struct device *dev, struct device_attribute *devattr,\n\t\t       char *buf)\n{\n\tstruct emc6w201_data *data = emc6w201_update_device(dev);\n\tint sf = to_sensor_dev_attr_2(devattr)->index;\n\tint nr = to_sensor_dev_attr_2(devattr)->nr;\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       (unsigned)data->in[sf][nr] * nominal_mv[nr] / 0xC0);\n}\n\nstatic ssize_t in_store(struct device *dev, struct device_attribute *devattr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct emc6w201_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint sf = to_sensor_dev_attr_2(devattr)->index;\n\tint nr = to_sensor_dev_attr_2(devattr)->nr;\n\tint err;\n\tlong val;\n\tu8 reg;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = clamp_val(val, 0, 255 * nominal_mv[nr] / 192);\n\tval = DIV_ROUND_CLOSEST(val * 192, nominal_mv[nr]);\n\treg = (sf == min) ? EMC6W201_REG_IN_LOW(nr)\n\t\t\t  : EMC6W201_REG_IN_HIGH(nr);\n\n\tmutex_lock(&data->update_lock);\n\tdata->in[sf][nr] = val;\n\terr = emc6w201_write8(client, reg, data->in[sf][nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn err < 0 ? err : count;\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct emc6w201_data *data = emc6w201_update_device(dev);\n\tint sf = to_sensor_dev_attr_2(devattr)->index;\n\tint nr = to_sensor_dev_attr_2(devattr)->nr;\n\n\treturn sprintf(buf, \"%d\\n\", (int)data->temp[sf][nr] * 1000);\n}\n\nstatic ssize_t temp_store(struct device *dev,\n\t\t\t  struct device_attribute *devattr, const char *buf,\n\t\t\t  size_t count)\n{\n\tstruct emc6w201_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint sf = to_sensor_dev_attr_2(devattr)->index;\n\tint nr = to_sensor_dev_attr_2(devattr)->nr;\n\tint err;\n\tlong val;\n\tu8 reg;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = clamp_val(val, -127000, 127000);\n\tval = DIV_ROUND_CLOSEST(val, 1000);\n\treg = (sf == min) ? EMC6W201_REG_TEMP_LOW(nr)\n\t\t\t  : EMC6W201_REG_TEMP_HIGH(nr);\n\n\tmutex_lock(&data->update_lock);\n\tdata->temp[sf][nr] = val;\n\terr = emc6w201_write8(client, reg, data->temp[sf][nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn err < 0 ? err : count;\n}\n\nstatic ssize_t fan_show(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\tstruct emc6w201_data *data = emc6w201_update_device(dev);\n\tint sf = to_sensor_dev_attr_2(devattr)->index;\n\tint nr = to_sensor_dev_attr_2(devattr)->nr;\n\tunsigned rpm;\n\n\tif (data->fan[sf][nr] == 0 || data->fan[sf][nr] == 0xFFFF)\n\t\trpm = 0;\n\telse\n\t\trpm = 5400000U / data->fan[sf][nr];\n\n\treturn sprintf(buf, \"%u\\n\", rpm);\n}\n\nstatic ssize_t fan_store(struct device *dev, struct device_attribute *devattr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct emc6w201_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint sf = to_sensor_dev_attr_2(devattr)->index;\n\tint nr = to_sensor_dev_attr_2(devattr)->nr;\n\tint err;\n\tunsigned long val;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val == 0) {\n\t\tval = 0xFFFF;\n\t} else {\n\t\tval = DIV_ROUND_CLOSEST(5400000U, val);\n\t\tval = clamp_val(val, 0, 0xFFFE);\n\t}\n\n\tmutex_lock(&data->update_lock);\n\tdata->fan[sf][nr] = val;\n\terr = emc6w201_write16(client, EMC6W201_REG_FAN_MIN(nr),\n\t\t\t       data->fan[sf][nr]);\n\tmutex_unlock(&data->update_lock);\n\n\treturn err < 0 ? err : count;\n}\n\nstatic SENSOR_DEVICE_ATTR_2_RO(in0_input, in, 0, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(in0_min, in, 0, min);\nstatic SENSOR_DEVICE_ATTR_2_RW(in0_max, in, 0, max);\nstatic SENSOR_DEVICE_ATTR_2_RO(in1_input, in, 1, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(in1_min, in, 1, min);\nstatic SENSOR_DEVICE_ATTR_2_RW(in1_max, in, 1, max);\nstatic SENSOR_DEVICE_ATTR_2_RO(in2_input, in, 2, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_min, in, 2, min);\nstatic SENSOR_DEVICE_ATTR_2_RW(in2_max, in, 2, max);\nstatic SENSOR_DEVICE_ATTR_2_RO(in3_input, in, 3, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_min, in, 3, min);\nstatic SENSOR_DEVICE_ATTR_2_RW(in3_max, in, 3, max);\nstatic SENSOR_DEVICE_ATTR_2_RO(in4_input, in, 4, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_min, in, 4, min);\nstatic SENSOR_DEVICE_ATTR_2_RW(in4_max, in, 4, max);\nstatic SENSOR_DEVICE_ATTR_2_RO(in5_input, in, 5, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(in5_min, in, 5, min);\nstatic SENSOR_DEVICE_ATTR_2_RW(in5_max, in, 5, max);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(temp1_input, temp, 0, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_min, temp, 0, min);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp1_max, temp, 0, max);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp2_input, temp, 1, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_min, temp, 1, min);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp2_max, temp, 1, max);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp3_input, temp, 2, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_min, temp, 2, min);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp3_max, temp, 2, max);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp4_input, temp, 3, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp4_min, temp, 3, min);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp4_max, temp, 3, max);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp5_input, temp, 4, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp5_min, temp, 4, min);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp5_max, temp, 4, max);\nstatic SENSOR_DEVICE_ATTR_2_RO(temp6_input, temp, 5, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp6_min, temp, 5, min);\nstatic SENSOR_DEVICE_ATTR_2_RW(temp6_max, temp, 5, max);\n\nstatic SENSOR_DEVICE_ATTR_2_RO(fan1_input, fan, 0, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan1_min, fan, 0, min);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan2_input, fan, 1, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan2_min, fan, 1, min);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan3_input, fan, 2, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan3_min, fan, 2, min);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan4_input, fan, 3, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan4_min, fan, 3, min);\nstatic SENSOR_DEVICE_ATTR_2_RO(fan5_input, fan, 4, input);\nstatic SENSOR_DEVICE_ATTR_2_RW(fan5_min, fan, 4, min);\n\nstatic struct attribute *emc6w201_attrs[] = {\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_min.dev_attr.attr,\n\t&sensor_dev_attr_in0_max.dev_attr.attr,\n\t&sensor_dev_attr_in1_input.dev_attr.attr,\n\t&sensor_dev_attr_in1_min.dev_attr.attr,\n\t&sensor_dev_attr_in1_max.dev_attr.attr,\n\t&sensor_dev_attr_in2_input.dev_attr.attr,\n\t&sensor_dev_attr_in2_min.dev_attr.attr,\n\t&sensor_dev_attr_in2_max.dev_attr.attr,\n\t&sensor_dev_attr_in3_input.dev_attr.attr,\n\t&sensor_dev_attr_in3_min.dev_attr.attr,\n\t&sensor_dev_attr_in3_max.dev_attr.attr,\n\t&sensor_dev_attr_in4_input.dev_attr.attr,\n\t&sensor_dev_attr_in4_min.dev_attr.attr,\n\t&sensor_dev_attr_in4_max.dev_attr.attr,\n\t&sensor_dev_attr_in5_input.dev_attr.attr,\n\t&sensor_dev_attr_in5_min.dev_attr.attr,\n\t&sensor_dev_attr_in5_max.dev_attr.attr,\n\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp4_input.dev_attr.attr,\n\t&sensor_dev_attr_temp4_min.dev_attr.attr,\n\t&sensor_dev_attr_temp4_max.dev_attr.attr,\n\t&sensor_dev_attr_temp5_input.dev_attr.attr,\n\t&sensor_dev_attr_temp5_min.dev_attr.attr,\n\t&sensor_dev_attr_temp5_max.dev_attr.attr,\n\t&sensor_dev_attr_temp6_input.dev_attr.attr,\n\t&sensor_dev_attr_temp6_min.dev_attr.attr,\n\t&sensor_dev_attr_temp6_max.dev_attr.attr,\n\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan3_input.dev_attr.attr,\n\t&sensor_dev_attr_fan3_min.dev_attr.attr,\n\t&sensor_dev_attr_fan4_input.dev_attr.attr,\n\t&sensor_dev_attr_fan4_min.dev_attr.attr,\n\t&sensor_dev_attr_fan5_input.dev_attr.attr,\n\t&sensor_dev_attr_fan5_min.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(emc6w201);\n\n \n\n \nstatic int emc6w201_detect(struct i2c_client *client,\n\t\t\t   struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint company, verstep, config;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tcompany = i2c_smbus_read_byte_data(client, EMC6W201_REG_COMPANY);\n\tif (company != 0x5C)\n\t\treturn -ENODEV;\n\tverstep = i2c_smbus_read_byte_data(client, EMC6W201_REG_VERSTEP);\n\tif (verstep < 0 || (verstep & 0xF0) != 0xB0)\n\t\treturn -ENODEV;\n\tif ((verstep & 0x0F) > 2) {\n\t\tdev_dbg(&client->dev, \"Unknown EMC6W201 stepping %d\\n\",\n\t\t\tverstep & 0x0F);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tconfig = i2c_smbus_read_byte_data(client, EMC6W201_REG_CONFIG);\n\tif (config < 0 || (config & 0xF4) != 0x04)\n\t\treturn -ENODEV;\n\tif (!(config & 0x01)) {\n\t\tdev_err(&client->dev, \"Monitoring not enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, \"emc6w201\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int emc6w201_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct emc6w201_data *data;\n\tstruct device *hwmon_dev;\n\n\tdata = devm_kzalloc(dev, sizeof(struct emc6w201_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tmutex_init(&data->update_lock);\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t   emc6w201_groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id emc6w201_id[] = {\n\t{ \"emc6w201\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, emc6w201_id);\n\nstatic struct i2c_driver emc6w201_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"emc6w201\",\n\t},\n\t.probe\t\t= emc6w201_probe,\n\t.id_table\t= emc6w201_id,\n\t.detect\t\t= emc6w201_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(emc6w201_driver);\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"SMSC EMC6W201 hardware monitoring driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}