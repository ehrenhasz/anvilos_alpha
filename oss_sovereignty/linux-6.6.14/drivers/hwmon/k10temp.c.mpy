{
  "module_name": "k10temp.c",
  "hash_id": "fe2d65acdd67c5a3fb1f011430034be821b7483e76a9df8133380f6431f2aaca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/k10temp.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <asm/amd_nb.h>\n#include <asm/processor.h>\n\nMODULE_DESCRIPTION(\"AMD Family 10h+ CPU core temperature monitor\");\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool force;\nmodule_param(force, bool, 0444);\nMODULE_PARM_DESC(force, \"force loading on processors with erratum 319\");\n\n \nstatic DEFINE_MUTEX(nb_smu_ind_mutex);\n\n#ifndef PCI_DEVICE_ID_AMD_15H_M70H_NB_F3\n#define PCI_DEVICE_ID_AMD_15H_M70H_NB_F3\t0x15b3\n#endif\n\n \n#define CPUID_PKGTYPE_MASK\tGENMASK(31, 28)\n#define CPUID_PKGTYPE_F\t\t0x00000000\n#define CPUID_PKGTYPE_AM2R2_AM3\t0x10000000\n\n \n#define REG_DCT0_CONFIG_HIGH\t\t0x094\n#define  DDR3_MODE\t\t\tBIT(8)\n\n \n#define REG_HARDWARE_THERMAL_CONTROL\t0x64\n#define  HTC_ENABLE\t\t\tBIT(0)\n\n#define REG_REPORTED_TEMPERATURE\t0xa4\n\n#define REG_NORTHBRIDGE_CAPABILITIES\t0xe8\n#define  NB_CAP_HTC\t\t\tBIT(10)\n\n \n#define F15H_M60H_HARDWARE_TEMP_CTRL_OFFSET\t0xd8200c64\n#define F15H_M60H_REPORTED_TEMP_CTRL_OFFSET\t0xd8200ca4\n\n \n#define ZEN_REPORTED_TEMP_CTRL_BASE\t\t0x00059800\n\n#define ZEN_CCD_TEMP(offset, x)\t\t\t(ZEN_REPORTED_TEMP_CTRL_BASE + \\\n\t\t\t\t\t\t (offset) + ((x) * 4))\n#define ZEN_CCD_TEMP_VALID\t\t\tBIT(11)\n#define ZEN_CCD_TEMP_MASK\t\t\tGENMASK(10, 0)\n\n#define ZEN_CUR_TEMP_SHIFT\t\t\t21\n#define ZEN_CUR_TEMP_RANGE_SEL_MASK\t\tBIT(19)\n#define ZEN_CUR_TEMP_TJ_SEL_MASK\t\tGENMASK(17, 16)\n\n \n#define AMD_I3255_STR\t\t\t\t\"3255\"\n\nstruct k10temp_data {\n\tstruct pci_dev *pdev;\n\tvoid (*read_htcreg)(struct pci_dev *pdev, u32 *regval);\n\tvoid (*read_tempreg)(struct pci_dev *pdev, u32 *regval);\n\tint temp_offset;\n\tu32 temp_adjust_mask;\n\tu32 show_temp;\n\tbool is_zen;\n\tu32 ccd_offset;\n\tbool disp_negative;\n};\n\n#define TCTL_BIT\t0\n#define TDIE_BIT\t1\n#define TCCD_BIT(x)\t((x) + 2)\n\n#define HAVE_TEMP(d, channel)\t((d)->show_temp & BIT(channel))\n#define HAVE_TDIE(d)\t\tHAVE_TEMP(d, TDIE_BIT)\n\nstruct tctl_offset {\n\tu8 model;\n\tchar const *id;\n\tint offset;\n};\n\nstatic const struct tctl_offset tctl_offset_table[] = {\n\t{ 0x17, \"AMD Ryzen 5 1600X\", 20000 },\n\t{ 0x17, \"AMD Ryzen 7 1700X\", 20000 },\n\t{ 0x17, \"AMD Ryzen 7 1800X\", 20000 },\n\t{ 0x17, \"AMD Ryzen 7 2700X\", 10000 },\n\t{ 0x17, \"AMD Ryzen Threadripper 19\", 27000 },  \n\t{ 0x17, \"AMD Ryzen Threadripper 29\", 27000 },  \n};\n\nstatic void read_htcreg_pci(struct pci_dev *pdev, u32 *regval)\n{\n\tpci_read_config_dword(pdev, REG_HARDWARE_THERMAL_CONTROL, regval);\n}\n\nstatic void read_tempreg_pci(struct pci_dev *pdev, u32 *regval)\n{\n\tpci_read_config_dword(pdev, REG_REPORTED_TEMPERATURE, regval);\n}\n\nstatic void amd_nb_index_read(struct pci_dev *pdev, unsigned int devfn,\n\t\t\t      unsigned int base, int offset, u32 *val)\n{\n\tmutex_lock(&nb_smu_ind_mutex);\n\tpci_bus_write_config_dword(pdev->bus, devfn,\n\t\t\t\t   base, offset);\n\tpci_bus_read_config_dword(pdev->bus, devfn,\n\t\t\t\t  base + 4, val);\n\tmutex_unlock(&nb_smu_ind_mutex);\n}\n\nstatic void read_htcreg_nb_f15(struct pci_dev *pdev, u32 *regval)\n{\n\tamd_nb_index_read(pdev, PCI_DEVFN(0, 0), 0xb8,\n\t\t\t  F15H_M60H_HARDWARE_TEMP_CTRL_OFFSET, regval);\n}\n\nstatic void read_tempreg_nb_f15(struct pci_dev *pdev, u32 *regval)\n{\n\tamd_nb_index_read(pdev, PCI_DEVFN(0, 0), 0xb8,\n\t\t\t  F15H_M60H_REPORTED_TEMP_CTRL_OFFSET, regval);\n}\n\nstatic void read_tempreg_nb_zen(struct pci_dev *pdev, u32 *regval)\n{\n\tamd_smn_read(amd_pci_dev_to_node_id(pdev),\n\t\t     ZEN_REPORTED_TEMP_CTRL_BASE, regval);\n}\n\nstatic long get_raw_temp(struct k10temp_data *data)\n{\n\tu32 regval;\n\tlong temp;\n\n\tdata->read_tempreg(data->pdev, &regval);\n\ttemp = (regval >> ZEN_CUR_TEMP_SHIFT) * 125;\n\tif ((regval & data->temp_adjust_mask) ||\n\t    (regval & ZEN_CUR_TEMP_TJ_SEL_MASK) == ZEN_CUR_TEMP_TJ_SEL_MASK)\n\t\ttemp -= 49000;\n\treturn temp;\n}\n\nstatic const char *k10temp_temp_label[] = {\n\t\"Tctl\",\n\t\"Tdie\",\n\t\"Tccd1\",\n\t\"Tccd2\",\n\t\"Tccd3\",\n\t\"Tccd4\",\n\t\"Tccd5\",\n\t\"Tccd6\",\n\t\"Tccd7\",\n\t\"Tccd8\",\n\t\"Tccd9\",\n\t\"Tccd10\",\n\t\"Tccd11\",\n\t\"Tccd12\",\n};\n\nstatic int k10temp_read_labels(struct device *dev,\n\t\t\t       enum hwmon_sensor_types type,\n\t\t\t       u32 attr, int channel, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\t*str = k10temp_temp_label[channel];\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int k10temp_read_temp(struct device *dev, u32 attr, int channel,\n\t\t\t     long *val)\n{\n\tstruct k10temp_data *data = dev_get_drvdata(dev);\n\tu32 regval;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tswitch (channel) {\n\t\tcase 0:\t\t \n\t\t\t*val = get_raw_temp(data);\n\t\t\tif (*val < 0 && !data->disp_negative)\n\t\t\t\t*val = 0;\n\t\t\tbreak;\n\t\tcase 1:\t\t \n\t\t\t*val = get_raw_temp(data) - data->temp_offset;\n\t\t\tif (*val < 0 && !data->disp_negative)\n\t\t\t\t*val = 0;\n\t\t\tbreak;\n\t\tcase 2 ... 13:\t\t \n\t\t\tamd_smn_read(amd_pci_dev_to_node_id(data->pdev),\n\t\t\t\t     ZEN_CCD_TEMP(data->ccd_offset, channel - 2),\n\t\t\t\t\t\t  &regval);\n\t\t\t*val = (regval & ZEN_CCD_TEMP_MASK) * 125 - 49000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\t*val = 70 * 1000;\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\tdata->read_htcreg(data->pdev, &regval);\n\t\t*val = ((regval >> 16) & 0x7f) * 500 + 52000;\n\t\tbreak;\n\tcase hwmon_temp_crit_hyst:\n\t\tdata->read_htcreg(data->pdev, &regval);\n\t\t*val = (((regval >> 16) & 0x7f)\n\t\t\t- ((regval >> 24) & 0xf)) * 500 + 52000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int k10temp_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn k10temp_read_temp(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t k10temp_is_visible(const void *_data,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tconst struct k10temp_data *data = _data;\n\tstruct pci_dev *pdev = data->pdev;\n\tu32 reg;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\tif (!HAVE_TEMP(data, channel))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase hwmon_temp_max:\n\t\t\tif (channel || data->is_zen)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase hwmon_temp_crit:\n\t\tcase hwmon_temp_crit_hyst:\n\t\t\tif (channel || !data->read_htcreg)\n\t\t\t\treturn 0;\n\n\t\t\tpci_read_config_dword(pdev,\n\t\t\t\t\t      REG_NORTHBRIDGE_CAPABILITIES,\n\t\t\t\t\t      &reg);\n\t\t\tif (!(reg & NB_CAP_HTC))\n\t\t\t\treturn 0;\n\n\t\t\tdata->read_htcreg(data->pdev, &reg);\n\t\t\tif (!(reg & HTC_ENABLE))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase hwmon_temp_label:\n\t\t\t \n\t\t\tif (!data->is_zen || !HAVE_TEMP(data, channel))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0444;\n}\n\nstatic bool has_erratum_319(struct pci_dev *pdev)\n{\n\tu32 pkg_type, reg_dram_cfg;\n\n\tif (boot_cpu_data.x86 != 0x10)\n\t\treturn false;\n\n\t \n\tpkg_type = cpuid_ebx(0x80000001) & CPUID_PKGTYPE_MASK;\n\tif (pkg_type == CPUID_PKGTYPE_F)\n\t\treturn true;\n\tif (pkg_type != CPUID_PKGTYPE_AM2R2_AM3)\n\t\treturn false;\n\n\t \n\tpci_bus_read_config_dword(pdev->bus,\n\t\t\t\t  PCI_DEVFN(PCI_SLOT(pdev->devfn), 2),\n\t\t\t\t  REG_DCT0_CONFIG_HIGH, &reg_dram_cfg);\n\tif (reg_dram_cfg & DDR3_MODE)\n\t\treturn false;\n\n\t \n\treturn boot_cpu_data.x86_model < 4 ||\n\t       (boot_cpu_data.x86_model == 4 && boot_cpu_data.x86_stepping <= 2);\n}\n\nstatic const struct hwmon_channel_info * const k10temp_info[] = {\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST |\n\t\t\t   HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL),\n\tNULL\n};\n\nstatic const struct hwmon_ops k10temp_hwmon_ops = {\n\t.is_visible = k10temp_is_visible,\n\t.read = k10temp_read,\n\t.read_string = k10temp_read_labels,\n};\n\nstatic const struct hwmon_chip_info k10temp_chip_info = {\n\t.ops = &k10temp_hwmon_ops,\n\t.info = k10temp_info,\n};\n\nstatic void k10temp_get_ccd_support(struct pci_dev *pdev,\n\t\t\t\t    struct k10temp_data *data, int limit)\n{\n\tu32 regval;\n\tint i;\n\n\tfor (i = 0; i < limit; i++) {\n\t\tamd_smn_read(amd_pci_dev_to_node_id(pdev),\n\t\t\t     ZEN_CCD_TEMP(data->ccd_offset, i), &regval);\n\t\tif (regval & ZEN_CCD_TEMP_VALID)\n\t\t\tdata->show_temp |= BIT(TCCD_BIT(i));\n\t}\n}\n\nstatic int k10temp_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint unreliable = has_erratum_319(pdev);\n\tstruct device *dev = &pdev->dev;\n\tstruct k10temp_data *data;\n\tstruct device *hwmon_dev;\n\tint i;\n\n\tif (unreliable) {\n\t\tif (!force) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"unreliable CPU thermal sensor; monitoring disabled\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tdev_warn(dev,\n\t\t\t \"unreliable CPU thermal sensor; check erratum 319\\n\");\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->pdev = pdev;\n\tdata->show_temp |= BIT(TCTL_BIT);\t \n\n\tif (boot_cpu_data.x86 == 0x17 &&\n\t    strstr(boot_cpu_data.x86_model_id, AMD_I3255_STR)) {\n\t\tdata->disp_negative = true;\n\t}\n\n\tif (boot_cpu_data.x86 == 0x15 &&\n\t    ((boot_cpu_data.x86_model & 0xf0) == 0x60 ||\n\t     (boot_cpu_data.x86_model & 0xf0) == 0x70)) {\n\t\tdata->read_htcreg = read_htcreg_nb_f15;\n\t\tdata->read_tempreg = read_tempreg_nb_f15;\n\t} else if (boot_cpu_data.x86 == 0x17 || boot_cpu_data.x86 == 0x18) {\n\t\tdata->temp_adjust_mask = ZEN_CUR_TEMP_RANGE_SEL_MASK;\n\t\tdata->read_tempreg = read_tempreg_nb_zen;\n\t\tdata->is_zen = true;\n\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase 0x1:\t \n\t\tcase 0x8:\t \n\t\tcase 0x11:\t \n\t\tcase 0x18:\t \n\t\t\tdata->ccd_offset = 0x154;\n\t\t\tk10temp_get_ccd_support(pdev, data, 4);\n\t\t\tbreak;\n\t\tcase 0x31:\t \n\t\tcase 0x60:\t \n\t\tcase 0x68:\t \n\t\tcase 0x71:\t \n\t\t\tdata->ccd_offset = 0x154;\n\t\t\tk10temp_get_ccd_support(pdev, data, 8);\n\t\t\tbreak;\n\t\tcase 0xa0 ... 0xaf:\n\t\t\tdata->ccd_offset = 0x300;\n\t\t\tk10temp_get_ccd_support(pdev, data, 8);\n\t\t\tbreak;\n\t\t}\n\t} else if (boot_cpu_data.x86 == 0x19) {\n\t\tdata->temp_adjust_mask = ZEN_CUR_TEMP_RANGE_SEL_MASK;\n\t\tdata->read_tempreg = read_tempreg_nb_zen;\n\t\tdata->is_zen = true;\n\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase 0x0 ... 0x1:\t \n\t\tcase 0x21:\t\t \n\t\tcase 0x50 ... 0x5f:\t \n\t\t\tdata->ccd_offset = 0x154;\n\t\t\tk10temp_get_ccd_support(pdev, data, 8);\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f:\t \n\t\t\tdata->ccd_offset = 0x300;\n\t\t\tk10temp_get_ccd_support(pdev, data, 8);\n\t\t\tbreak;\n\t\tcase 0x60 ... 0x6f:\n\t\tcase 0x70 ... 0x7f:\n\t\t\tdata->ccd_offset = 0x308;\n\t\t\tk10temp_get_ccd_support(pdev, data, 8);\n\t\t\tbreak;\n\t\tcase 0x10 ... 0x1f:\n\t\tcase 0xa0 ... 0xaf:\n\t\t\tdata->ccd_offset = 0x300;\n\t\t\tk10temp_get_ccd_support(pdev, data, 12);\n\t\t\tbreak;\n\t\t}\n\t} else if (boot_cpu_data.x86 == 0x1a) {\n\t\tdata->temp_adjust_mask = ZEN_CUR_TEMP_RANGE_SEL_MASK;\n\t\tdata->read_tempreg = read_tempreg_nb_zen;\n\t\tdata->is_zen = true;\n\t} else {\n\t\tdata->read_htcreg = read_htcreg_pci;\n\t\tdata->read_tempreg = read_tempreg_pci;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tctl_offset_table); i++) {\n\t\tconst struct tctl_offset *entry = &tctl_offset_table[i];\n\n\t\tif (boot_cpu_data.x86 == entry->model &&\n\t\t    strstr(boot_cpu_data.x86_model_id, entry->id)) {\n\t\t\tdata->show_temp |= BIT(TDIE_BIT);\t \n\t\t\tdata->temp_offset = entry->offset;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, \"k10temp\", data,\n\t\t\t\t\t\t\t &k10temp_chip_info,\n\t\t\t\t\t\t\t NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct pci_device_id k10temp_id_table[] = {\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_10H_NB_MISC) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_11H_NB_MISC) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_CNB17H_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_NB_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M10H_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M30H_NB_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M70H_NB_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_NB_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_M10H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_M30H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_M60H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_M70H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_MA0H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_19H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_19H_M10H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_19H_M40H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_19H_M50H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_19H_M60H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_19H_M70H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_19H_M78H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_1AH_M00H_DF_F3) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_1AH_M20H_DF_F3) },\n\t{ PCI_VDEVICE(HYGON, PCI_DEVICE_ID_AMD_17H_DF_F3) },\n\t{}\n};\nMODULE_DEVICE_TABLE(pci, k10temp_id_table);\n\nstatic struct pci_driver k10temp_driver = {\n\t.name = \"k10temp\",\n\t.id_table = k10temp_id_table,\n\t.probe = k10temp_probe,\n};\n\nmodule_pci_driver(k10temp_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}