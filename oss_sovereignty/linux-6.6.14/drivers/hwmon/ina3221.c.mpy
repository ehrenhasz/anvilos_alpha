{
  "module_name": "ina3221.c",
  "hash_id": "6c9c1427ecca14033a070a9172b88d23ed2ae64ef55f18f414e799fc2b46f667",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/ina3221.c",
  "human_readable_source": "\n \n\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/util_macros.h>\n\n#define INA3221_DRIVER_NAME\t\t\"ina3221\"\n\n#define INA3221_CONFIG\t\t\t0x00\n#define INA3221_SHUNT1\t\t\t0x01\n#define INA3221_BUS1\t\t\t0x02\n#define INA3221_SHUNT2\t\t\t0x03\n#define INA3221_BUS2\t\t\t0x04\n#define INA3221_SHUNT3\t\t\t0x05\n#define INA3221_BUS3\t\t\t0x06\n#define INA3221_CRIT1\t\t\t0x07\n#define INA3221_WARN1\t\t\t0x08\n#define INA3221_CRIT2\t\t\t0x09\n#define INA3221_WARN2\t\t\t0x0a\n#define INA3221_CRIT3\t\t\t0x0b\n#define INA3221_WARN3\t\t\t0x0c\n#define INA3221_SHUNT_SUM\t\t0x0d\n#define INA3221_CRIT_SUM\t\t0x0e\n#define INA3221_MASK_ENABLE\t\t0x0f\n\n#define INA3221_CONFIG_MODE_MASK\tGENMASK(2, 0)\n#define INA3221_CONFIG_MODE_POWERDOWN\t0\n#define INA3221_CONFIG_MODE_SHUNT\tBIT(0)\n#define INA3221_CONFIG_MODE_BUS\t\tBIT(1)\n#define INA3221_CONFIG_MODE_CONTINUOUS\tBIT(2)\n#define INA3221_CONFIG_VSH_CT_SHIFT\t3\n#define INA3221_CONFIG_VSH_CT_MASK\tGENMASK(5, 3)\n#define INA3221_CONFIG_VSH_CT(x)\t(((x) & GENMASK(5, 3)) >> 3)\n#define INA3221_CONFIG_VBUS_CT_SHIFT\t6\n#define INA3221_CONFIG_VBUS_CT_MASK\tGENMASK(8, 6)\n#define INA3221_CONFIG_VBUS_CT(x)\t(((x) & GENMASK(8, 6)) >> 6)\n#define INA3221_CONFIG_AVG_SHIFT\t9\n#define INA3221_CONFIG_AVG_MASK\t\tGENMASK(11, 9)\n#define INA3221_CONFIG_AVG(x)\t\t(((x) & GENMASK(11, 9)) >> 9)\n#define INA3221_CONFIG_CHs_EN_MASK\tGENMASK(14, 12)\n#define INA3221_CONFIG_CHx_EN(x)\tBIT(14 - (x))\n\n#define INA3221_MASK_ENABLE_SCC_MASK\tGENMASK(14, 12)\n\n#define INA3221_CONFIG_DEFAULT\t\t0x7127\n#define INA3221_RSHUNT_DEFAULT\t\t10000\n\nenum ina3221_fields {\n\t \n\tF_RST,\n\n\t \n\tF_CVRF,\n\n\t \n\tF_WF3, F_WF2, F_WF1,\n\n\t \n\tF_SF, F_CF3, F_CF2, F_CF1,\n\n\t \n\tF_MAX_FIELDS\n};\n\nstatic const struct reg_field ina3221_reg_fields[] = {\n\t[F_RST] = REG_FIELD(INA3221_CONFIG, 15, 15),\n\n\t[F_CVRF] = REG_FIELD(INA3221_MASK_ENABLE, 0, 0),\n\t[F_WF3] = REG_FIELD(INA3221_MASK_ENABLE, 3, 3),\n\t[F_WF2] = REG_FIELD(INA3221_MASK_ENABLE, 4, 4),\n\t[F_WF1] = REG_FIELD(INA3221_MASK_ENABLE, 5, 5),\n\t[F_SF] = REG_FIELD(INA3221_MASK_ENABLE, 6, 6),\n\t[F_CF3] = REG_FIELD(INA3221_MASK_ENABLE, 7, 7),\n\t[F_CF2] = REG_FIELD(INA3221_MASK_ENABLE, 8, 8),\n\t[F_CF1] = REG_FIELD(INA3221_MASK_ENABLE, 9, 9),\n};\n\nenum ina3221_channels {\n\tINA3221_CHANNEL1,\n\tINA3221_CHANNEL2,\n\tINA3221_CHANNEL3,\n\tINA3221_NUM_CHANNELS\n};\n\n \nstruct ina3221_input {\n\tconst char *label;\n\tint shunt_resistor;\n\tbool disconnected;\n};\n\n \nstruct ina3221_data {\n\tstruct device *pm_dev;\n\tstruct regmap *regmap;\n\tstruct regmap_field *fields[F_MAX_FIELDS];\n\tstruct ina3221_input inputs[INA3221_NUM_CHANNELS];\n\tstruct mutex lock;\n\tu32 reg_config;\n\tint summation_shunt_resistor;\n\n\tbool single_shot;\n};\n\nstatic inline bool ina3221_is_enabled(struct ina3221_data *ina, int channel)\n{\n\t \n\tif (channel > INA3221_CHANNEL3)\n\t\treturn ina->summation_shunt_resistor != 0;\n\n\treturn pm_runtime_active(ina->pm_dev) &&\n\t       (ina->reg_config & INA3221_CONFIG_CHx_EN(channel));\n}\n\n \nstatic inline int ina3221_summation_shunt_resistor(struct ina3221_data *ina)\n{\n\tstruct ina3221_input *input = ina->inputs;\n\tint i, shunt_resistor = 0;\n\n\tfor (i = 0; i < INA3221_NUM_CHANNELS; i++) {\n\t\tif (input[i].disconnected || !input[i].shunt_resistor)\n\t\t\tcontinue;\n\t\tif (!shunt_resistor) {\n\t\t\t \n\t\t\tshunt_resistor = input[i].shunt_resistor;\n\t\t} else {\n\t\t\t \n\t\t\tif (shunt_resistor != input[i].shunt_resistor)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn shunt_resistor;\n}\n\n \nstatic const u16 ina3221_conv_time[] = {\n\t140, 204, 332, 588, 1100, 2116, 4156, 8244,\n};\n\n \nstatic const int ina3221_avg_samples[] = {\n\t1, 4, 16, 64, 128, 256, 512, 1024,\n};\n\n \nstatic inline u32 ina3221_interval_ms_to_conv_time(u16 config, int interval)\n{\n\tu32 channels = hweight16(config & INA3221_CONFIG_CHs_EN_MASK);\n\tu32 samples_idx = INA3221_CONFIG_AVG(config);\n\tu32 samples = ina3221_avg_samples[samples_idx];\n\n\t \n\treturn DIV_ROUND_CLOSEST(interval * 1000 / 2, channels * samples);\n}\n\n \nstatic inline u32 ina3221_reg_to_interval_us(u16 config)\n{\n\tu32 channels = hweight16(config & INA3221_CONFIG_CHs_EN_MASK);\n\tu32 vbus_ct_idx = INA3221_CONFIG_VBUS_CT(config);\n\tu32 vsh_ct_idx = INA3221_CONFIG_VSH_CT(config);\n\tu32 vbus_ct = ina3221_conv_time[vbus_ct_idx];\n\tu32 vsh_ct = ina3221_conv_time[vsh_ct_idx];\n\n\t \n\treturn channels * (vbus_ct + vsh_ct);\n}\n\nstatic inline int ina3221_wait_for_data(struct ina3221_data *ina)\n{\n\tu32 wait, cvrf;\n\n\twait = ina3221_reg_to_interval_us(ina->reg_config);\n\n\t \n\treturn regmap_field_read_poll_timeout(ina->fields[F_CVRF],\n\t\t\t\t\t      cvrf, cvrf, wait, wait * 2);\n}\n\nstatic int ina3221_read_value(struct ina3221_data *ina, unsigned int reg,\n\t\t\t      int *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(ina->regmap, reg, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (reg == INA3221_SHUNT_SUM || reg == INA3221_CRIT_SUM)\n\t\t*val = sign_extend32(regval >> 1, 14);\n\telse\n\t\t*val = sign_extend32(regval >> 3, 12);\n\n\treturn 0;\n}\n\nstatic const u8 ina3221_in_reg[] = {\n\tINA3221_BUS1,\n\tINA3221_BUS2,\n\tINA3221_BUS3,\n\tINA3221_SHUNT1,\n\tINA3221_SHUNT2,\n\tINA3221_SHUNT3,\n\tINA3221_SHUNT_SUM,\n};\n\nstatic int ina3221_read_chip(struct device *dev, u32 attr, long *val)\n{\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tint regval;\n\n\tswitch (attr) {\n\tcase hwmon_chip_samples:\n\t\tregval = INA3221_CONFIG_AVG(ina->reg_config);\n\t\t*val = ina3221_avg_samples[regval];\n\t\treturn 0;\n\tcase hwmon_chip_update_interval:\n\t\t \n\t\t*val = ina3221_reg_to_interval_us(ina->reg_config);\n\t\t*val = DIV_ROUND_CLOSEST(*val, 1000);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ina3221_read_in(struct device *dev, u32 attr, int channel, long *val)\n{\n\tconst bool is_shunt = channel > INA3221_CHANNEL3;\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tu8 reg = ina3221_in_reg[channel];\n\tint regval, ret;\n\n\t \n\tif (channel != 6)\n\t\tchannel %= INA3221_NUM_CHANNELS;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\tif (!ina3221_is_enabled(ina, channel))\n\t\t\treturn -ENODATA;\n\n\t\t \n\t\tif (ina->single_shot) {\n\t\t\tregmap_write(ina->regmap, INA3221_CONFIG,\n\t\t\t\t     ina->reg_config);\n\n\t\t\tret = ina3221_wait_for_data(ina);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = ina3221_read_value(ina, reg, &regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\t*val = regval * (is_shunt ? 40 : 8);\n\t\treturn 0;\n\tcase hwmon_in_enable:\n\t\t*val = ina3221_is_enabled(ina, channel);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const u8 ina3221_curr_reg[][INA3221_NUM_CHANNELS + 1] = {\n\t[hwmon_curr_input] = { INA3221_SHUNT1, INA3221_SHUNT2,\n\t\t\t       INA3221_SHUNT3, INA3221_SHUNT_SUM },\n\t[hwmon_curr_max] = { INA3221_WARN1, INA3221_WARN2, INA3221_WARN3, 0 },\n\t[hwmon_curr_crit] = { INA3221_CRIT1, INA3221_CRIT2,\n\t\t\t      INA3221_CRIT3, INA3221_CRIT_SUM },\n\t[hwmon_curr_max_alarm] = { F_WF1, F_WF2, F_WF3, 0 },\n\t[hwmon_curr_crit_alarm] = { F_CF1, F_CF2, F_CF3, F_SF },\n};\n\nstatic int ina3221_read_curr(struct device *dev, u32 attr,\n\t\t\t     int channel, long *val)\n{\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tstruct ina3221_input *input = ina->inputs;\n\tu8 reg = ina3221_curr_reg[attr][channel];\n\tint resistance_uo, voltage_nv;\n\tint regval, ret;\n\n\tif (channel > INA3221_CHANNEL3)\n\t\tresistance_uo = ina->summation_shunt_resistor;\n\telse\n\t\tresistance_uo = input[channel].shunt_resistor;\n\n\tswitch (attr) {\n\tcase hwmon_curr_input:\n\t\tif (!ina3221_is_enabled(ina, channel))\n\t\t\treturn -ENODATA;\n\n\t\t \n\t\tif (ina->single_shot) {\n\t\t\tregmap_write(ina->regmap, INA3221_CONFIG,\n\t\t\t\t     ina->reg_config);\n\n\t\t\tret = ina3221_wait_for_data(ina);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tfallthrough;\n\tcase hwmon_curr_crit:\n\tcase hwmon_curr_max:\n\t\tif (!resistance_uo)\n\t\t\treturn -ENODATA;\n\n\t\tret = ina3221_read_value(ina, reg, &regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tvoltage_nv = regval * 40000;\n\t\t \n\t\t*val = DIV_ROUND_CLOSEST(voltage_nv, resistance_uo);\n\t\treturn 0;\n\tcase hwmon_curr_crit_alarm:\n\tcase hwmon_curr_max_alarm:\n\t\t \n\t\tif (!ina3221_is_enabled(ina, channel)) {\n\t\t\t \n\t\t\t*val = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tret = regmap_field_read(ina->fields[reg], &regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*val = regval;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ina3221_write_chip(struct device *dev, u32 attr, long val)\n{\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tint ret, idx;\n\tu32 tmp;\n\n\tswitch (attr) {\n\tcase hwmon_chip_samples:\n\t\tidx = find_closest(val, ina3221_avg_samples,\n\t\t\t\t   ARRAY_SIZE(ina3221_avg_samples));\n\n\t\ttmp = (ina->reg_config & ~INA3221_CONFIG_AVG_MASK) |\n\t\t      (idx << INA3221_CONFIG_AVG_SHIFT);\n\t\tret = regmap_write(ina->regmap, INA3221_CONFIG, tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tina->reg_config = tmp;\n\t\treturn 0;\n\tcase hwmon_chip_update_interval:\n\t\ttmp = ina3221_interval_ms_to_conv_time(ina->reg_config, val);\n\t\tidx = find_closest(tmp, ina3221_conv_time,\n\t\t\t\t   ARRAY_SIZE(ina3221_conv_time));\n\n\t\t \n\t\ttmp = INA3221_CONFIG_VBUS_CT_MASK | INA3221_CONFIG_VSH_CT_MASK;\n\t\ttmp = (ina->reg_config & ~tmp) |\n\t\t      (idx << INA3221_CONFIG_VBUS_CT_SHIFT) |\n\t\t      (idx << INA3221_CONFIG_VSH_CT_SHIFT);\n\t\tret = regmap_write(ina->regmap, INA3221_CONFIG, tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tina->reg_config = tmp;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ina3221_write_curr(struct device *dev, u32 attr,\n\t\t\t      int channel, long val)\n{\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tstruct ina3221_input *input = ina->inputs;\n\tu8 reg = ina3221_curr_reg[attr][channel];\n\tint resistance_uo, current_ma, voltage_uv;\n\tint regval;\n\n\tif (channel > INA3221_CHANNEL3)\n\t\tresistance_uo = ina->summation_shunt_resistor;\n\telse\n\t\tresistance_uo = input[channel].shunt_resistor;\n\n\tif (!resistance_uo)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tcurrent_ma = clamp_val(val,\n\t\t\t       INT_MIN / resistance_uo,\n\t\t\t       INT_MAX / resistance_uo);\n\n\tvoltage_uv = DIV_ROUND_CLOSEST(current_ma * resistance_uo, 1000);\n\n\t \n\tvoltage_uv = clamp_val(voltage_uv, -163800, 163800);\n\n\t \n\tif (reg == INA3221_SHUNT_SUM || reg == INA3221_CRIT_SUM)\n\t\tregval = DIV_ROUND_CLOSEST(voltage_uv, 20) & 0xfffe;\n\telse\n\t\tregval = DIV_ROUND_CLOSEST(voltage_uv, 5) & 0xfff8;\n\n\treturn regmap_write(ina->regmap, reg, regval);\n}\n\nstatic int ina3221_write_enable(struct device *dev, int channel, bool enable)\n{\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tu16 config, mask = INA3221_CONFIG_CHx_EN(channel);\n\tu16 config_old = ina->reg_config & mask;\n\tu32 tmp;\n\tint ret;\n\n\tconfig = enable ? mask : 0;\n\n\t \n\tif (config_old == config)\n\t\treturn 0;\n\n\t \n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(ina->pm_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to get PM runtime\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\ttmp = (ina->reg_config & ~mask) | (config & mask);\n\tret = regmap_write(ina->regmap, INA3221_CONFIG, tmp);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tina->reg_config = tmp;\n\n\t \n\tif (!enable)\n\t\tpm_runtime_put_sync(ina->pm_dev);\n\n\treturn 0;\n\nfail:\n\tif (enable) {\n\t\tdev_err(dev, \"Failed to enable channel %d: error %d\\n\",\n\t\t\tchannel, ret);\n\t\tpm_runtime_put_sync(ina->pm_dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int ina3221_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&ina->lock);\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tret = ina3221_read_chip(dev, attr, val);\n\t\tbreak;\n\tcase hwmon_in:\n\t\t \n\t\tret = ina3221_read_in(dev, attr, channel - 1, val);\n\t\tbreak;\n\tcase hwmon_curr:\n\t\tret = ina3221_read_curr(dev, attr, channel, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ina->lock);\n\n\treturn ret;\n}\n\nstatic int ina3221_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long val)\n{\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&ina->lock);\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tret = ina3221_write_chip(dev, attr, val);\n\t\tbreak;\n\tcase hwmon_in:\n\t\t \n\t\tret = ina3221_write_enable(dev, channel - 1, val);\n\t\tbreak;\n\tcase hwmon_curr:\n\t\tret = ina3221_write_curr(dev, attr, channel, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ina->lock);\n\n\treturn ret;\n}\n\nstatic int ina3221_read_string(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t       u32 attr, int channel, const char **str)\n{\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tint index = channel - 1;\n\n\tif (channel == 7)\n\t\t*str = \"sum of shunt voltages\";\n\telse\n\t\t*str = ina->inputs[index].label;\n\n\treturn 0;\n}\n\nstatic umode_t ina3221_is_visible(const void *drvdata,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tconst struct ina3221_data *ina = drvdata;\n\tconst struct ina3221_input *input = NULL;\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tswitch (attr) {\n\t\tcase hwmon_chip_samples:\n\t\tcase hwmon_chip_update_interval:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_in:\n\t\t \n\t\tif (channel == 0)\n\t\t\treturn 0;\n\n\t\tswitch (attr) {\n\t\tcase hwmon_in_label:\n\t\t\tif (channel - 1 <= INA3221_CHANNEL3)\n\t\t\t\tinput = &ina->inputs[channel - 1];\n\t\t\telse if (channel == 7)\n\t\t\t\treturn 0444;\n\t\t\t \n\t\t\treturn (input && input->label) ? 0444 : 0;\n\t\tcase hwmon_in_input:\n\t\t\treturn 0444;\n\t\tcase hwmon_in_enable:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_input:\n\t\tcase hwmon_curr_crit_alarm:\n\t\tcase hwmon_curr_max_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_curr_crit:\n\t\tcase hwmon_curr_max:\n\t\t\treturn 0644;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n#define INA3221_HWMON_CURR_CONFIG (HWMON_C_INPUT | \\\n\t\t\t\t   HWMON_C_CRIT | HWMON_C_CRIT_ALARM | \\\n\t\t\t\t   HWMON_C_MAX | HWMON_C_MAX_ALARM)\n\nstatic const struct hwmon_channel_info * const ina3221_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_SAMPLES,\n\t\t\t   HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t    \n\t\t\t   HWMON_I_INPUT,\n\t\t\t    \n\t\t\t   HWMON_I_INPUT | HWMON_I_ENABLE | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_ENABLE | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_ENABLE | HWMON_I_LABEL,\n\t\t\t    \n\t\t\t   HWMON_I_INPUT,\n\t\t\t   HWMON_I_INPUT,\n\t\t\t   HWMON_I_INPUT,\n\t\t\t    \n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL),\n\tHWMON_CHANNEL_INFO(curr,\n\t\t\t    \n\t\t\t   INA3221_HWMON_CURR_CONFIG,\n\t\t\t   INA3221_HWMON_CURR_CONFIG,\n\t\t\t   INA3221_HWMON_CURR_CONFIG,\n\t\t\t    \n\t\t\t   HWMON_C_INPUT | HWMON_C_CRIT | HWMON_C_CRIT_ALARM),\n\tNULL\n};\n\nstatic const struct hwmon_ops ina3221_hwmon_ops = {\n\t.is_visible = ina3221_is_visible,\n\t.read_string = ina3221_read_string,\n\t.read = ina3221_read,\n\t.write = ina3221_write,\n};\n\nstatic const struct hwmon_chip_info ina3221_chip_info = {\n\t.ops = &ina3221_hwmon_ops,\n\t.info = ina3221_info,\n};\n\n \nstatic ssize_t ina3221_shunt_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute *sd_attr = to_sensor_dev_attr(attr);\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tunsigned int channel = sd_attr->index;\n\tstruct ina3221_input *input = &ina->inputs[channel];\n\n\treturn sysfs_emit(buf, \"%d\\n\", input->shunt_resistor);\n}\n\nstatic ssize_t ina3221_shunt_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute *sd_attr = to_sensor_dev_attr(attr);\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tunsigned int channel = sd_attr->index;\n\tstruct ina3221_input *input = &ina->inputs[channel];\n\tint val;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = clamp_val(val, 1, INT_MAX);\n\n\tinput->shunt_resistor = val;\n\n\t \n\tina->summation_shunt_resistor = ina3221_summation_shunt_resistor(ina);\n\n\treturn count;\n}\n\n \nstatic SENSOR_DEVICE_ATTR_RW(shunt1_resistor, ina3221_shunt, INA3221_CHANNEL1);\nstatic SENSOR_DEVICE_ATTR_RW(shunt2_resistor, ina3221_shunt, INA3221_CHANNEL2);\nstatic SENSOR_DEVICE_ATTR_RW(shunt3_resistor, ina3221_shunt, INA3221_CHANNEL3);\n\nstatic struct attribute *ina3221_attrs[] = {\n\t&sensor_dev_attr_shunt1_resistor.dev_attr.attr,\n\t&sensor_dev_attr_shunt2_resistor.dev_attr.attr,\n\t&sensor_dev_attr_shunt3_resistor.dev_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ina3221);\n\nstatic const struct regmap_range ina3221_yes_ranges[] = {\n\tregmap_reg_range(INA3221_CONFIG, INA3221_BUS3),\n\tregmap_reg_range(INA3221_SHUNT_SUM, INA3221_SHUNT_SUM),\n\tregmap_reg_range(INA3221_MASK_ENABLE, INA3221_MASK_ENABLE),\n};\n\nstatic const struct regmap_access_table ina3221_volatile_table = {\n\t.yes_ranges = ina3221_yes_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(ina3221_yes_ranges),\n};\n\nstatic const struct regmap_config ina3221_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_table = &ina3221_volatile_table,\n};\n\nstatic int ina3221_probe_child_from_dt(struct device *dev,\n\t\t\t\t       struct device_node *child,\n\t\t\t\t       struct ina3221_data *ina)\n{\n\tstruct ina3221_input *input;\n\tu32 val;\n\tint ret;\n\n\tret = of_property_read_u32(child, \"reg\", &val);\n\tif (ret) {\n\t\tdev_err(dev, \"missing reg property of %pOFn\\n\", child);\n\t\treturn ret;\n\t} else if (val > INA3221_CHANNEL3) {\n\t\tdev_err(dev, \"invalid reg %d of %pOFn\\n\", val, child);\n\t\treturn -EINVAL;\n\t}\n\n\tinput = &ina->inputs[val];\n\n\t \n\tif (!of_device_is_available(child)) {\n\t\tinput->disconnected = true;\n\t\treturn 0;\n\t}\n\n\t \n\tof_property_read_string(child, \"label\", &input->label);\n\n\t \n\tif (!of_property_read_u32(child, \"shunt-resistor-micro-ohms\", &val)) {\n\t\tif (val < 1 || val > INT_MAX) {\n\t\t\tdev_err(dev, \"invalid shunt resistor value %u of %pOFn\\n\",\n\t\t\t\tval, child);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tinput->shunt_resistor = val;\n\t}\n\n\treturn 0;\n}\n\nstatic int ina3221_probe_from_dt(struct device *dev, struct ina3221_data *ina)\n{\n\tconst struct device_node *np = dev->of_node;\n\tstruct device_node *child;\n\tint ret;\n\n\t \n\tif (!np)\n\t\treturn 0;\n\n\tina->single_shot = of_property_read_bool(np, \"ti,single-shot\");\n\n\tfor_each_child_of_node(np, child) {\n\t\tret = ina3221_probe_child_from_dt(dev, child, ina);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ina3221_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ina3221_data *ina;\n\tstruct device *hwmon_dev;\n\tint i, ret;\n\n\tina = devm_kzalloc(dev, sizeof(*ina), GFP_KERNEL);\n\tif (!ina)\n\t\treturn -ENOMEM;\n\n\tina->regmap = devm_regmap_init_i2c(client, &ina3221_regmap_config);\n\tif (IS_ERR(ina->regmap)) {\n\t\tdev_err(dev, \"Unable to allocate register map\\n\");\n\t\treturn PTR_ERR(ina->regmap);\n\t}\n\n\tfor (i = 0; i < F_MAX_FIELDS; i++) {\n\t\tina->fields[i] = devm_regmap_field_alloc(dev,\n\t\t\t\t\t\t\t ina->regmap,\n\t\t\t\t\t\t\t ina3221_reg_fields[i]);\n\t\tif (IS_ERR(ina->fields[i])) {\n\t\t\tdev_err(dev, \"Unable to allocate regmap fields\\n\");\n\t\t\treturn PTR_ERR(ina->fields[i]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < INA3221_NUM_CHANNELS; i++)\n\t\tina->inputs[i].shunt_resistor = INA3221_RSHUNT_DEFAULT;\n\n\tret = ina3221_probe_from_dt(dev, ina);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to probe from device tree\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tina->reg_config = INA3221_CONFIG_DEFAULT;\n\n\t \n\tif (ina->single_shot)\n\t\tina->reg_config &= ~INA3221_CONFIG_MODE_CONTINUOUS;\n\n\t \n\tfor (i = 0; i < INA3221_NUM_CHANNELS; i++) {\n\t\tif (ina->inputs[i].disconnected)\n\t\t\tina->reg_config &= ~INA3221_CONFIG_CHx_EN(i);\n\t}\n\n\t \n\tina->summation_shunt_resistor = ina3221_summation_shunt_resistor(ina);\n\n\tina->pm_dev = dev;\n\tmutex_init(&ina->lock);\n\tdev_set_drvdata(dev, ina);\n\n\t \n\tpm_runtime_enable(ina->pm_dev);\n\n\t \n\tfor (i = 0; i < INA3221_NUM_CHANNELS; i++) {\n\t\tif (ina->inputs[i].disconnected)\n\t\t\tcontinue;\n\t\t \n\t\tret = pm_runtime_get_sync(ina->pm_dev);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name, ina,\n\t\t\t\t\t\t\t &ina3221_chip_info,\n\t\t\t\t\t\t\t ina3221_groups);\n\tif (IS_ERR(hwmon_dev)) {\n\t\tdev_err(dev, \"Unable to register hwmon device\\n\");\n\t\tret = PTR_ERR(hwmon_dev);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tpm_runtime_disable(ina->pm_dev);\n\tpm_runtime_set_suspended(ina->pm_dev);\n\t \n\tfor (i = 0; i < INA3221_NUM_CHANNELS; i++)\n\t\tpm_runtime_put_noidle(ina->pm_dev);\n\tmutex_destroy(&ina->lock);\n\n\treturn ret;\n}\n\nstatic void ina3221_remove(struct i2c_client *client)\n{\n\tstruct ina3221_data *ina = dev_get_drvdata(&client->dev);\n\tint i;\n\n\tpm_runtime_disable(ina->pm_dev);\n\tpm_runtime_set_suspended(ina->pm_dev);\n\n\t \n\tfor (i = 0; i < INA3221_NUM_CHANNELS; i++)\n\t\tpm_runtime_put_noidle(ina->pm_dev);\n\n\tmutex_destroy(&ina->lock);\n}\n\nstatic int ina3221_suspend(struct device *dev)\n{\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tret = regmap_read(ina->regmap, INA3221_CONFIG, &ina->reg_config);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(ina->regmap, INA3221_CONFIG,\n\t\t\t\t INA3221_CONFIG_MODE_MASK,\n\t\t\t\t INA3221_CONFIG_MODE_POWERDOWN);\n\tif (ret)\n\t\treturn ret;\n\n\tregcache_cache_only(ina->regmap, true);\n\tregcache_mark_dirty(ina->regmap);\n\n\treturn 0;\n}\n\nstatic int ina3221_resume(struct device *dev)\n{\n\tstruct ina3221_data *ina = dev_get_drvdata(dev);\n\tint ret;\n\n\tregcache_cache_only(ina->regmap, false);\n\n\t \n\tret = regmap_field_write(ina->fields[F_RST], true);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to reset device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regcache_sync(ina->regmap);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(ina->regmap, INA3221_CONFIG, ina->reg_config);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ina->summation_shunt_resistor) {\n\t\t \n\t\tret = regmap_update_bits(ina->regmap, INA3221_MASK_ENABLE,\n\t\t\t\t\t INA3221_MASK_ENABLE_SCC_MASK,\n\t\t\t\t\t INA3221_MASK_ENABLE_SCC_MASK);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Unable to control summation channel\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(ina3221_pm, ina3221_suspend, ina3221_resume,\n\t\t\t\t NULL);\n\nstatic const struct of_device_id ina3221_of_match_table[] = {\n\t{ .compatible = \"ti,ina3221\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ina3221_of_match_table);\n\nstatic const struct i2c_device_id ina3221_ids[] = {\n\t{ \"ina3221\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, ina3221_ids);\n\nstatic struct i2c_driver ina3221_i2c_driver = {\n\t.probe = ina3221_probe,\n\t.remove = ina3221_remove,\n\t.driver = {\n\t\t.name = INA3221_DRIVER_NAME,\n\t\t.of_match_table = ina3221_of_match_table,\n\t\t.pm = pm_ptr(&ina3221_pm),\n\t},\n\t.id_table = ina3221_ids,\n};\nmodule_i2c_driver(ina3221_i2c_driver);\n\nMODULE_AUTHOR(\"Andrew F. Davis <afd@ti.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments INA3221 HWMon Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}