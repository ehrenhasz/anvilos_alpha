{
  "module_name": "adm1031.c",
  "hash_id": "f183fddd82b4aa9071fde8a704b7e4b8b39e0fdafd6f767eec30a684c0e8fff6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/adm1031.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n\n \n#define ADM1031_REG_FAN_SPEED(nr)\t(0x08 + (nr))\n#define ADM1031_REG_FAN_DIV(nr)\t\t(0x20 + (nr))\n#define ADM1031_REG_PWM\t\t\t(0x22)\n#define ADM1031_REG_FAN_MIN(nr)\t\t(0x10 + (nr))\n#define ADM1031_REG_FAN_FILTER\t\t(0x23)\n\n#define ADM1031_REG_TEMP_OFFSET(nr)\t(0x0d + (nr))\n#define ADM1031_REG_TEMP_MAX(nr)\t(0x14 + 4 * (nr))\n#define ADM1031_REG_TEMP_MIN(nr)\t(0x15 + 4 * (nr))\n#define ADM1031_REG_TEMP_CRIT(nr)\t(0x16 + 4 * (nr))\n\n#define ADM1031_REG_TEMP(nr)\t\t(0x0a + (nr))\n#define ADM1031_REG_AUTO_TEMP(nr)\t(0x24 + (nr))\n\n#define ADM1031_REG_STATUS(nr)\t\t(0x2 + (nr))\n\n#define ADM1031_REG_CONF1\t\t0x00\n#define ADM1031_REG_CONF2\t\t0x01\n#define ADM1031_REG_EXT_TEMP\t\t0x06\n\n#define ADM1031_CONF1_MONITOR_ENABLE\t0x01\t \n#define ADM1031_CONF1_PWM_INVERT\t0x08\t \n#define ADM1031_CONF1_AUTO_MODE\t\t0x80\t \n\n#define ADM1031_CONF2_PWM1_ENABLE\t0x01\n#define ADM1031_CONF2_PWM2_ENABLE\t0x02\n#define ADM1031_CONF2_TACH1_ENABLE\t0x04\n#define ADM1031_CONF2_TACH2_ENABLE\t0x08\n#define ADM1031_CONF2_TEMP_ENABLE(chan)\t(0x10 << (chan))\n\n#define ADM1031_UPDATE_RATE_MASK\t0x1c\n#define ADM1031_UPDATE_RATE_SHIFT\t2\n\n \nstatic const unsigned short normal_i2c[] = { 0x2c, 0x2d, 0x2e, I2C_CLIENT_END };\n\nenum chips { adm1030, adm1031 };\n\ntypedef u8 auto_chan_table_t[8][2];\n\n \nstruct adm1031_data {\n\tstruct i2c_client *client;\n\tconst struct attribute_group *groups[3];\n\tstruct mutex update_lock;\n\tint chip_type;\n\tbool valid;\t\t \n\tunsigned long last_updated;\t \n\tunsigned int update_interval;\t \n\t \n\tconst auto_chan_table_t *chan_select_table;\n\tu16 alarm;\n\tu8 conf1;\n\tu8 conf2;\n\tu8 fan[2];\n\tu8 fan_div[2];\n\tu8 fan_min[2];\n\tu8 pwm[2];\n\tu8 old_pwm[2];\n\ts8 temp[3];\n\tu8 ext_temp[3];\n\tu8 auto_temp[3];\n\tu8 auto_temp_min[3];\n\tu8 auto_temp_off[3];\n\tu8 auto_temp_max[3];\n\ts8 temp_offset[3];\n\ts8 temp_min[3];\n\ts8 temp_max[3];\n\ts8 temp_crit[3];\n};\n\nstatic inline u8 adm1031_read_value(struct i2c_client *client, u8 reg)\n{\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic inline int\nadm1031_write_value(struct i2c_client *client, u8 reg, unsigned int value)\n{\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic struct adm1031_data *adm1031_update_device(struct device *dev)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long next_update;\n\tint chan;\n\n\tmutex_lock(&data->update_lock);\n\n\tnext_update = data->last_updated\n\t  + msecs_to_jiffies(data->update_interval);\n\tif (time_after(jiffies, next_update) || !data->valid) {\n\n\t\tdev_dbg(&client->dev, \"Starting adm1031 update\\n\");\n\t\tfor (chan = 0;\n\t\t     chan < ((data->chip_type == adm1031) ? 3 : 2); chan++) {\n\t\t\tu8 oldh, newh;\n\n\t\t\toldh =\n\t\t\t    adm1031_read_value(client, ADM1031_REG_TEMP(chan));\n\t\t\tdata->ext_temp[chan] =\n\t\t\t    adm1031_read_value(client, ADM1031_REG_EXT_TEMP);\n\t\t\tnewh =\n\t\t\t    adm1031_read_value(client, ADM1031_REG_TEMP(chan));\n\t\t\tif (newh != oldh) {\n\t\t\t\tdata->ext_temp[chan] =\n\t\t\t\t    adm1031_read_value(client,\n\t\t\t\t\t\t       ADM1031_REG_EXT_TEMP);\n#ifdef DEBUG\n\t\t\t\toldh =\n\t\t\t\t    adm1031_read_value(client,\n\t\t\t\t\t\t       ADM1031_REG_TEMP(chan));\n\n\t\t\t\t \n\t\t\t\tif (newh != oldh)\n\t\t\t\t\tdev_warn(&client->dev,\n\t\t\t\t\t  \"Remote temperature may be wrong.\\n\");\n#endif\n\t\t\t}\n\t\t\tdata->temp[chan] = newh;\n\n\t\t\tdata->temp_offset[chan] =\n\t\t\t    adm1031_read_value(client,\n\t\t\t\t\t       ADM1031_REG_TEMP_OFFSET(chan));\n\t\t\tdata->temp_min[chan] =\n\t\t\t    adm1031_read_value(client,\n\t\t\t\t\t       ADM1031_REG_TEMP_MIN(chan));\n\t\t\tdata->temp_max[chan] =\n\t\t\t    adm1031_read_value(client,\n\t\t\t\t\t       ADM1031_REG_TEMP_MAX(chan));\n\t\t\tdata->temp_crit[chan] =\n\t\t\t    adm1031_read_value(client,\n\t\t\t\t\t       ADM1031_REG_TEMP_CRIT(chan));\n\t\t\tdata->auto_temp[chan] =\n\t\t\t    adm1031_read_value(client,\n\t\t\t\t\t       ADM1031_REG_AUTO_TEMP(chan));\n\n\t\t}\n\n\t\tdata->conf1 = adm1031_read_value(client, ADM1031_REG_CONF1);\n\t\tdata->conf2 = adm1031_read_value(client, ADM1031_REG_CONF2);\n\n\t\tdata->alarm = adm1031_read_value(client, ADM1031_REG_STATUS(0))\n\t\t    | (adm1031_read_value(client, ADM1031_REG_STATUS(1)) << 8);\n\t\tif (data->chip_type == adm1030)\n\t\t\tdata->alarm &= 0xc0ff;\n\n\t\tfor (chan = 0; chan < (data->chip_type == adm1030 ? 1 : 2);\n\t\t     chan++) {\n\t\t\tdata->fan_div[chan] =\n\t\t\t    adm1031_read_value(client,\n\t\t\t\t\t       ADM1031_REG_FAN_DIV(chan));\n\t\t\tdata->fan_min[chan] =\n\t\t\t    adm1031_read_value(client,\n\t\t\t\t\t       ADM1031_REG_FAN_MIN(chan));\n\t\t\tdata->fan[chan] =\n\t\t\t    adm1031_read_value(client,\n\t\t\t\t\t       ADM1031_REG_FAN_SPEED(chan));\n\t\t\tdata->pwm[chan] =\n\t\t\t  (adm1031_read_value(client,\n\t\t\t\t\tADM1031_REG_PWM) >> (4 * chan)) & 0x0f;\n\t\t}\n\t\tdata->last_updated = jiffies;\n\t\tdata->valid = true;\n\t}\n\n\tmutex_unlock(&data->update_lock);\n\n\treturn data;\n}\n\n#define TEMP_TO_REG(val)\t\t(((val) < 0 ? ((val - 500) / 1000) : \\\n\t\t\t\t\t((val + 500) / 1000)))\n\n#define TEMP_FROM_REG(val)\t\t((val) * 1000)\n\n#define TEMP_FROM_REG_EXT(val, ext)\t(TEMP_FROM_REG(val) + (ext) * 125)\n\n#define TEMP_OFFSET_TO_REG(val)\t\t(TEMP_TO_REG(val) & 0x8f)\n#define TEMP_OFFSET_FROM_REG(val)\tTEMP_FROM_REG((val) < 0 ? \\\n\t\t\t\t\t\t      (val) | 0x70 : (val))\n\n#define FAN_FROM_REG(reg, div)\t\t((reg) ? \\\n\t\t\t\t\t (11250 * 60) / ((reg) * (div)) : 0)\n\nstatic int FAN_TO_REG(int reg, int div)\n{\n\tint tmp;\n\ttmp = FAN_FROM_REG(clamp_val(reg, 0, 65535), div);\n\treturn tmp > 255 ? 255 : tmp;\n}\n\n#define FAN_DIV_FROM_REG(reg)\t\t(1<<(((reg)&0xc0)>>6))\n\n#define PWM_TO_REG(val)\t\t\t(clamp_val((val), 0, 255) >> 4)\n#define PWM_FROM_REG(val)\t\t((val) << 4)\n\n#define FAN_CHAN_FROM_REG(reg)\t\t(((reg) >> 5) & 7)\n#define FAN_CHAN_TO_REG(val, reg)\t\\\n\t(((reg) & 0x1F) | (((val) << 5) & 0xe0))\n\n#define AUTO_TEMP_MIN_TO_REG(val, reg)\t\\\n\t((((val) / 500) & 0xf8) | ((reg) & 0x7))\n#define AUTO_TEMP_RANGE_FROM_REG(reg)\t(5000 * (1 << ((reg) & 0x7)))\n#define AUTO_TEMP_MIN_FROM_REG(reg)\t(1000 * ((((reg) >> 3) & 0x1f) << 2))\n\n#define AUTO_TEMP_MIN_FROM_REG_DEG(reg)\t((((reg) >> 3) & 0x1f) << 2)\n\n#define AUTO_TEMP_OFF_FROM_REG(reg)\t\t\\\n\t(AUTO_TEMP_MIN_FROM_REG(reg) - 5000)\n\n#define AUTO_TEMP_MAX_FROM_REG(reg)\t\t\\\n\t(AUTO_TEMP_RANGE_FROM_REG(reg) +\t\\\n\tAUTO_TEMP_MIN_FROM_REG(reg))\n\nstatic int AUTO_TEMP_MAX_TO_REG(int val, int reg, int pwm)\n{\n\tint ret;\n\tint range = ((val - AUTO_TEMP_MIN_FROM_REG(reg)) * 10) / (16 - pwm);\n\n\tret = ((reg & 0xf8) |\n\t       (range < 10000 ? 0 :\n\t\trange < 20000 ? 1 :\n\t\trange < 40000 ? 2 : range < 80000 ? 3 : 4));\n\treturn ret;\n}\n\n \n#define GET_FAN_AUTO_BITFIELD(data, idx)\t\\\n\t(*(data)->chan_select_table)[FAN_CHAN_FROM_REG((data)->conf1)][idx % 2]\n\n \nstatic const auto_chan_table_t auto_channel_select_table_adm1031 = {\n\t{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },\n\t{ 2   , 4   },\n\t{ 2   , 2   },\n\t{ 4   , 4   },\n\t{ 7   , 7   },\n};\n\nstatic const auto_chan_table_t auto_channel_select_table_adm1030 = {\n\t{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },\n\t{ 2  \t\t, 0 },\n\t{ 0xff  \t, 0 },\n\t{ 0xff  \t, 0 },\n\t{ 3  \t\t, 0 },\n};\n\n \nstatic int\nget_fan_auto_nearest(struct adm1031_data *data, int chan, u8 val, u8 reg)\n{\n\tint i;\n\tint first_match = -1, exact_match = -1;\n\tu8 other_reg_val =\n\t    (*data->chan_select_table)[FAN_CHAN_FROM_REG(reg)][chan ? 0 : 1];\n\n\tif (val == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif ((val == (*data->chan_select_table)[i][chan]) &&\n\t\t    ((*data->chan_select_table)[i][chan ? 0 : 1] ==\n\t\t     other_reg_val)) {\n\t\t\t \n\t\t\texact_match = i;\n\t\t\tbreak;\n\t\t} else if (val == (*data->chan_select_table)[i][chan] &&\n\t\t\t   first_match == -1) {\n\t\t\t \n\t\t\tfirst_match = i;\n\t\t}\n\t}\n\n\tif (exact_match >= 0)\n\t\treturn exact_match;\n\telse if (first_match >= 0)\n\t\treturn first_match;\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t fan_auto_channel_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", GET_FAN_AUTO_BITFIELD(data, nr));\n}\n\nstatic ssize_t\nfan_auto_channel_store(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\tu8 reg;\n\tint ret;\n\tu8 old_fan_mode;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\told_fan_mode = data->conf1;\n\n\tmutex_lock(&data->update_lock);\n\n\tret = get_fan_auto_nearest(data, nr, val, data->conf1);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->update_lock);\n\t\treturn ret;\n\t}\n\treg = ret;\n\tdata->conf1 = FAN_CHAN_TO_REG(reg, data->conf1);\n\tif ((data->conf1 & ADM1031_CONF1_AUTO_MODE) ^\n\t    (old_fan_mode & ADM1031_CONF1_AUTO_MODE)) {\n\t\tif (data->conf1 & ADM1031_CONF1_AUTO_MODE) {\n\t\t\t \n\t\t\tdata->old_pwm[0] = data->pwm[0];\n\t\t\tdata->old_pwm[1] = data->pwm[1];\n\t\t\tadm1031_write_value(client, ADM1031_REG_PWM, 0x55);\n\t\t} else {\n\t\t\t \n\t\t\tdata->pwm[0] = data->old_pwm[0];\n\t\t\tdata->pwm[1] = data->old_pwm[1];\n\t\t\t \n\t\t\tadm1031_write_value(client, ADM1031_REG_PWM,\n\t\t\t\t\t    data->pwm[0] | (data->pwm[1] << 4));\n\t\t}\n\t}\n\tdata->conf1 = FAN_CHAN_TO_REG(reg, data->conf1);\n\tadm1031_write_value(client, ADM1031_REG_CONF1, data->conf1);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(auto_fan1_channel, fan_auto_channel, 0);\nstatic SENSOR_DEVICE_ATTR_RW(auto_fan2_channel, fan_auto_channel, 1);\n\n \nstatic ssize_t auto_temp_off_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       AUTO_TEMP_OFF_FROM_REG(data->auto_temp[nr]));\n}\nstatic ssize_t auto_temp_min_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       AUTO_TEMP_MIN_FROM_REG(data->auto_temp[nr]));\n}\nstatic ssize_t\nauto_temp_min_store(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = clamp_val(val, 0, 127000);\n\tmutex_lock(&data->update_lock);\n\tdata->auto_temp[nr] = AUTO_TEMP_MIN_TO_REG(val, data->auto_temp[nr]);\n\tadm1031_write_value(client, ADM1031_REG_AUTO_TEMP(nr),\n\t\t\t    data->auto_temp[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\nstatic ssize_t auto_temp_max_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       AUTO_TEMP_MAX_FROM_REG(data->auto_temp[nr]));\n}\nstatic ssize_t\nauto_temp_max_store(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = clamp_val(val, 0, 127000);\n\tmutex_lock(&data->update_lock);\n\tdata->temp_max[nr] = AUTO_TEMP_MAX_TO_REG(val, data->auto_temp[nr],\n\t\t\t\t\t\t  data->pwm[nr]);\n\tadm1031_write_value(client, ADM1031_REG_AUTO_TEMP(nr),\n\t\t\t    data->temp_max[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(auto_temp1_off, auto_temp_off, 0);\nstatic SENSOR_DEVICE_ATTR_RW(auto_temp1_min, auto_temp_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(auto_temp1_max, auto_temp_max, 0);\nstatic SENSOR_DEVICE_ATTR_RO(auto_temp2_off, auto_temp_off, 1);\nstatic SENSOR_DEVICE_ATTR_RW(auto_temp2_min, auto_temp_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(auto_temp2_max, auto_temp_max, 1);\nstatic SENSOR_DEVICE_ATTR_RO(auto_temp3_off, auto_temp_off, 2);\nstatic SENSOR_DEVICE_ATTR_RW(auto_temp3_min, auto_temp_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(auto_temp3_max, auto_temp_max, 2);\n\n \nstatic ssize_t pwm_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", PWM_FROM_REG(data->pwm[nr]));\n}\nstatic ssize_t pwm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\tint ret, reg;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&data->update_lock);\n\tif ((data->conf1 & ADM1031_CONF1_AUTO_MODE) &&\n\t    (((val>>4) & 0xf) != 5)) {\n\t\t \n\t\tmutex_unlock(&data->update_lock);\n\t\treturn -EINVAL;\n\t}\n\tdata->pwm[nr] = PWM_TO_REG(val);\n\treg = adm1031_read_value(client, ADM1031_REG_PWM);\n\tadm1031_write_value(client, ADM1031_REG_PWM,\n\t\t\t    nr ? ((data->pwm[nr] << 4) & 0xf0) | (reg & 0xf)\n\t\t\t    : (data->pwm[nr] & 0xf) | (reg & 0xf0));\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RW(pwm1, pwm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(pwm2, pwm, 1);\nstatic SENSOR_DEVICE_ATTR_RW(auto_fan1_min_pwm, pwm, 0);\nstatic SENSOR_DEVICE_ATTR_RW(auto_fan2_min_pwm, pwm, 1);\n\n \n\n \nstatic int trust_fan_readings(struct adm1031_data *data, int chan)\n{\n\tint res = 0;\n\n\tif (data->conf1 & ADM1031_CONF1_AUTO_MODE) {\n\t\tswitch (data->conf1 & 0x60) {\n\t\tcase 0x00:\n\t\t\t \n\t\t\tres = data->temp[chan+1] >=\n\t\t\t    AUTO_TEMP_MIN_FROM_REG_DEG(data->auto_temp[chan+1]);\n\t\t\tbreak;\n\t\tcase 0x20:\t \n\t\t\tres =\n\t\t\t    data->temp[1] >=\n\t\t\t    AUTO_TEMP_MIN_FROM_REG_DEG(data->auto_temp[1]);\n\t\t\tbreak;\n\t\tcase 0x40:\t \n\t\t\tres =\n\t\t\t    data->temp[2] >=\n\t\t\t    AUTO_TEMP_MIN_FROM_REG_DEG(data->auto_temp[2]);\n\t\t\tbreak;\n\t\tcase 0x60:\t \n\t\t\tres =\n\t\t\t    data->temp[0] >=\n\t\t\t    AUTO_TEMP_MIN_FROM_REG_DEG(data->auto_temp[0])\n\t\t\t    || data->temp[1] >=\n\t\t\t    AUTO_TEMP_MIN_FROM_REG_DEG(data->auto_temp[1])\n\t\t\t    || (data->chip_type == adm1031\n\t\t\t\t&& data->temp[2] >=\n\t\t\t\tAUTO_TEMP_MIN_FROM_REG_DEG(data->auto_temp[2]));\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tres = data->pwm[chan] > 0;\n\t}\n\treturn res;\n}\n\nstatic ssize_t fan_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\tint value;\n\n\tvalue = trust_fan_readings(data, nr) ? FAN_FROM_REG(data->fan[nr],\n\t\t\t\t FAN_DIV_FROM_REG(data->fan_div[nr])) : 0;\n\treturn sprintf(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t fan_div_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", FAN_DIV_FROM_REG(data->fan_div[nr]));\n}\nstatic ssize_t fan_min_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       FAN_FROM_REG(data->fan_min[nr],\n\t\t\t\t    FAN_DIV_FROM_REG(data->fan_div[nr])));\n}\nstatic ssize_t fan_min_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&data->update_lock);\n\tif (val) {\n\t\tdata->fan_min[nr] =\n\t\t\tFAN_TO_REG(val, FAN_DIV_FROM_REG(data->fan_div[nr]));\n\t} else {\n\t\tdata->fan_min[nr] = 0xff;\n\t}\n\tadm1031_write_value(client, ADM1031_REG_FAN_MIN(nr), data->fan_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\nstatic ssize_t fan_div_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\tu8 tmp;\n\tint old_div;\n\tint new_min;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = val == 8 ? 0xc0 :\n\t      val == 4 ? 0x80 :\n\t      val == 2 ? 0x40 :\n\t      val == 1 ? 0x00 :\n\t      0xff;\n\tif (tmp == 0xff)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\t \n\tdata->fan_div[nr] = adm1031_read_value(client,\n\t\t\t\t\t       ADM1031_REG_FAN_DIV(nr));\n\tdata->fan_min[nr] = adm1031_read_value(client,\n\t\t\t\t\t       ADM1031_REG_FAN_MIN(nr));\n\n\t \n\told_div = FAN_DIV_FROM_REG(data->fan_div[nr]);\n\tdata->fan_div[nr] = tmp | (0x3f & data->fan_div[nr]);\n\tnew_min = data->fan_min[nr] * old_div / val;\n\tdata->fan_min[nr] = new_min > 0xff ? 0xff : new_min;\n\n\tadm1031_write_value(client, ADM1031_REG_FAN_DIV(nr),\n\t\t\t    data->fan_div[nr]);\n\tadm1031_write_value(client, ADM1031_REG_FAN_MIN(nr),\n\t\t\t    data->fan_min[nr]);\n\n\t \n\tdata->valid = false;\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_input, fan, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_min, fan_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(fan1_div, fan_div, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_input, fan, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_min, fan_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(fan2_div, fan_div, 1);\n\n \nstatic ssize_t temp_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\tint ext;\n\text = nr == 0 ?\n\t    ((data->ext_temp[nr] >> 6) & 0x3) * 2 :\n\t    (((data->ext_temp[nr] >> ((nr - 1) * 3)) & 7));\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG_EXT(data->temp[nr], ext));\n}\nstatic ssize_t temp_offset_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       TEMP_OFFSET_FROM_REG(data->temp_offset[nr]));\n}\nstatic ssize_t temp_min_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_min[nr]));\n}\nstatic ssize_t temp_max_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_max[nr]));\n}\nstatic ssize_t temp_crit_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", TEMP_FROM_REG(data->temp_crit[nr]));\n}\nstatic ssize_t temp_offset_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = clamp_val(val, -15000, 15000);\n\tmutex_lock(&data->update_lock);\n\tdata->temp_offset[nr] = TEMP_OFFSET_TO_REG(val);\n\tadm1031_write_value(client, ADM1031_REG_TEMP_OFFSET(nr),\n\t\t\t    data->temp_offset[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\nstatic ssize_t temp_min_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = clamp_val(val, -55000, 127000);\n\tmutex_lock(&data->update_lock);\n\tdata->temp_min[nr] = TEMP_TO_REG(val);\n\tadm1031_write_value(client, ADM1031_REG_TEMP_MIN(nr),\n\t\t\t    data->temp_min[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\nstatic ssize_t temp_max_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = clamp_val(val, -55000, 127000);\n\tmutex_lock(&data->update_lock);\n\tdata->temp_max[nr] = TEMP_TO_REG(val);\n\tadm1031_write_value(client, ADM1031_REG_TEMP_MAX(nr),\n\t\t\t    data->temp_max[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\nstatic ssize_t temp_crit_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tint nr = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = clamp_val(val, -55000, 127000);\n\tmutex_lock(&data->update_lock);\n\tdata->temp_crit[nr] = TEMP_TO_REG(val);\n\tadm1031_write_value(client, ADM1031_REG_TEMP_CRIT(nr),\n\t\t\t    data->temp_crit[nr]);\n\tmutex_unlock(&data->update_lock);\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_offset, temp_offset, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_min, temp_min, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, temp_max, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_crit, temp_crit, 0);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_input, temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_offset, temp_offset, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_min, temp_min, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_max, temp_max, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp2_crit, temp_crit, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_input, temp, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_offset, temp_offset, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_min, temp_min, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_max, temp_max, 2);\nstatic SENSOR_DEVICE_ATTR_RW(temp3_crit, temp_crit, 2);\n\n \nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", data->alarm);\n}\n\nstatic DEVICE_ATTR_RO(alarms);\n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint bitnr = to_sensor_dev_attr(attr)->index;\n\tstruct adm1031_data *data = adm1031_update_device(dev);\n\treturn sprintf(buf, \"%d\\n\", (data->alarm >> bitnr) & 1);\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(fan1_alarm, alarm, 0);\nstatic SENSOR_DEVICE_ATTR_RO(fan1_fault, alarm, 1);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_max_alarm, alarm, 2);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_min_alarm, alarm, 3);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_crit_alarm, alarm, 4);\nstatic SENSOR_DEVICE_ATTR_RO(temp2_fault, alarm, 5);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_max_alarm, alarm, 6);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_min_alarm, alarm, 7);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_alarm, alarm, 8);\nstatic SENSOR_DEVICE_ATTR_RO(fan2_fault, alarm, 9);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_max_alarm, alarm, 10);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_min_alarm, alarm, 11);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_crit_alarm, alarm, 12);\nstatic SENSOR_DEVICE_ATTR_RO(temp3_fault, alarm, 13);\nstatic SENSOR_DEVICE_ATTR_RO(temp1_crit_alarm, alarm, 14);\n\n \nstatic const unsigned int update_intervals[] = {\n\t16000, 8000, 4000, 2000, 1000, 500, 250, 125,\n};\n\nstatic ssize_t update_interval_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", data->update_interval);\n}\n\nstatic ssize_t update_interval_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct adm1031_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\tunsigned long val;\n\tint i, err;\n\tu8 reg;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(update_intervals) - 1; i++) {\n\t\tif (val >= update_intervals[i])\n\t\t\tbreak;\n\t}\n\t \n\n\t \n\treg = adm1031_read_value(client, ADM1031_REG_FAN_FILTER);\n\treg &= ~ADM1031_UPDATE_RATE_MASK;\n\treg |= i << ADM1031_UPDATE_RATE_SHIFT;\n\tadm1031_write_value(client, ADM1031_REG_FAN_FILTER, reg);\n\n\tmutex_lock(&data->update_lock);\n\tdata->update_interval = update_intervals[i];\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(update_interval);\n\nstatic struct attribute *adm1031_attributes[] = {\n\t&sensor_dev_attr_fan1_input.dev_attr.attr,\n\t&sensor_dev_attr_fan1_div.dev_attr.attr,\n\t&sensor_dev_attr_fan1_min.dev_attr.attr,\n\t&sensor_dev_attr_fan1_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan1_fault.dev_attr.attr,\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_auto_fan1_channel.dev_attr.attr,\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_input.dev_attr.attr,\n\t&sensor_dev_attr_temp2_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_temp2_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max.dev_attr.attr,\n\t&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp2_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp2_fault.dev_attr.attr,\n\n\t&sensor_dev_attr_auto_temp1_off.dev_attr.attr,\n\t&sensor_dev_attr_auto_temp1_min.dev_attr.attr,\n\t&sensor_dev_attr_auto_temp1_max.dev_attr.attr,\n\n\t&sensor_dev_attr_auto_temp2_off.dev_attr.attr,\n\t&sensor_dev_attr_auto_temp2_min.dev_attr.attr,\n\t&sensor_dev_attr_auto_temp2_max.dev_attr.attr,\n\n\t&sensor_dev_attr_auto_fan1_min_pwm.dev_attr.attr,\n\n\t&dev_attr_update_interval.attr,\n\t&dev_attr_alarms.attr,\n\n\tNULL\n};\n\nstatic const struct attribute_group adm1031_group = {\n\t.attrs = adm1031_attributes,\n};\n\nstatic struct attribute *adm1031_attributes_opt[] = {\n\t&sensor_dev_attr_fan2_input.dev_attr.attr,\n\t&sensor_dev_attr_fan2_div.dev_attr.attr,\n\t&sensor_dev_attr_fan2_min.dev_attr.attr,\n\t&sensor_dev_attr_fan2_alarm.dev_attr.attr,\n\t&sensor_dev_attr_fan2_fault.dev_attr.attr,\n\t&sensor_dev_attr_pwm2.dev_attr.attr,\n\t&sensor_dev_attr_auto_fan2_channel.dev_attr.attr,\n\t&sensor_dev_attr_temp3_input.dev_attr.attr,\n\t&sensor_dev_attr_temp3_offset.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_temp3_min_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_temp3_max_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp3_crit_alarm.dev_attr.attr,\n\t&sensor_dev_attr_temp3_fault.dev_attr.attr,\n\t&sensor_dev_attr_auto_temp3_off.dev_attr.attr,\n\t&sensor_dev_attr_auto_temp3_min.dev_attr.attr,\n\t&sensor_dev_attr_auto_temp3_max.dev_attr.attr,\n\t&sensor_dev_attr_auto_fan2_min_pwm.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adm1031_group_opt = {\n\t.attrs = adm1031_attributes_opt,\n};\n\n \nstatic int adm1031_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tconst char *name;\n\tint id, co;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tid = i2c_smbus_read_byte_data(client, 0x3d);\n\tco = i2c_smbus_read_byte_data(client, 0x3e);\n\n\tif (!((id == 0x31 || id == 0x30) && co == 0x41))\n\t\treturn -ENODEV;\n\tname = (id == 0x30) ? \"adm1030\" : \"adm1031\";\n\n\tstrscpy(info->type, name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic void adm1031_init_client(struct i2c_client *client)\n{\n\tunsigned int read_val;\n\tunsigned int mask;\n\tint i;\n\tstruct adm1031_data *data = i2c_get_clientdata(client);\n\n\tmask = (ADM1031_CONF2_PWM1_ENABLE | ADM1031_CONF2_TACH1_ENABLE);\n\tif (data->chip_type == adm1031) {\n\t\tmask |= (ADM1031_CONF2_PWM2_ENABLE |\n\t\t\tADM1031_CONF2_TACH2_ENABLE);\n\t}\n\t \n\tread_val = adm1031_read_value(client, ADM1031_REG_CONF2);\n\tif ((read_val | mask) != read_val)\n\t\tadm1031_write_value(client, ADM1031_REG_CONF2, read_val | mask);\n\n\tread_val = adm1031_read_value(client, ADM1031_REG_CONF1);\n\tif ((read_val | ADM1031_CONF1_MONITOR_ENABLE) != read_val) {\n\t\tadm1031_write_value(client, ADM1031_REG_CONF1,\n\t\t\t\t    read_val | ADM1031_CONF1_MONITOR_ENABLE);\n\t}\n\n\t \n\tmask = ADM1031_UPDATE_RATE_MASK;\n\tread_val = adm1031_read_value(client, ADM1031_REG_FAN_FILTER);\n\ti = (read_val & mask) >> ADM1031_UPDATE_RATE_SHIFT;\n\t \n\tdata->update_interval = update_intervals[i];\n}\n\nstatic const struct i2c_device_id adm1031_id[];\n\nstatic int adm1031_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct adm1031_data *data;\n\n\tdata = devm_kzalloc(dev, sizeof(struct adm1031_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tdata->client = client;\n\tdata->chip_type = i2c_match_id(adm1031_id, client)->driver_data;\n\tmutex_init(&data->update_lock);\n\n\tif (data->chip_type == adm1030)\n\t\tdata->chan_select_table = &auto_channel_select_table_adm1030;\n\telse\n\t\tdata->chan_select_table = &auto_channel_select_table_adm1031;\n\n\t \n\tadm1031_init_client(client);\n\n\t \n\tdata->groups[0] = &adm1031_group;\n\tif (data->chip_type == adm1031)\n\t\tdata->groups[1] = &adm1031_group_opt;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\n\t\t\t\t\t\t\t   data, data->groups);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id adm1031_id[] = {\n\t{ \"adm1030\", adm1030 },\n\t{ \"adm1031\", adm1031 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adm1031_id);\n\nstatic struct i2c_driver adm1031_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = \"adm1031\",\n\t},\n\t.probe\t\t= adm1031_probe,\n\t.id_table\t= adm1031_id,\n\t.detect\t\t= adm1031_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(adm1031_driver);\n\nMODULE_AUTHOR(\"Alexandre d'Alton <alex@alexdalton.org>\");\nMODULE_DESCRIPTION(\"ADM1031/ADM1030 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}