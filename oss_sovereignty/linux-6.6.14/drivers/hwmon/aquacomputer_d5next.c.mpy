{
  "module_name": "aquacomputer_d5next.c",
  "hash_id": "6fd7af065dc93145b59fdca6171068cb0ddb298f6a0962628432762d8861958a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/aquacomputer_d5next.c",
  "human_readable_source": "\n \n\n#include <linux/crc16.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/hid.h>\n#include <linux/hwmon.h>\n#include <linux/jiffies.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <asm/unaligned.h>\n\n#define USB_VENDOR_ID_AQUACOMPUTER\t0x0c70\n#define USB_PRODUCT_ID_AQUAERO\t\t0xf001\n#define USB_PRODUCT_ID_FARBWERK\t\t0xf00a\n#define USB_PRODUCT_ID_QUADRO\t\t0xf00d\n#define USB_PRODUCT_ID_D5NEXT\t\t0xf00e\n#define USB_PRODUCT_ID_FARBWERK360\t0xf010\n#define USB_PRODUCT_ID_OCTO\t\t0xf011\n#define USB_PRODUCT_ID_HIGHFLOWNEXT\t0xf012\n#define USB_PRODUCT_ID_LEAKSHIELD\t0xf014\n#define USB_PRODUCT_ID_AQUASTREAMXT\t0xf0b6\n#define USB_PRODUCT_ID_AQUASTREAMULT\t0xf00b\n#define USB_PRODUCT_ID_POWERADJUST3\t0xf0bd\n\nenum kinds {\n\td5next, farbwerk, farbwerk360, octo, quadro,\n\thighflownext, aquaero, poweradjust3, aquastreamult,\n\taquastreamxt, leakshield\n};\n\nstatic const char *const aqc_device_names[] = {\n\t[d5next] = \"d5next\",\n\t[farbwerk] = \"farbwerk\",\n\t[farbwerk360] = \"farbwerk360\",\n\t[octo] = \"octo\",\n\t[quadro] = \"quadro\",\n\t[highflownext] = \"highflownext\",\n\t[leakshield] = \"leakshield\",\n\t[aquastreamxt] = \"aquastreamxt\",\n\t[aquaero] = \"aquaero\",\n\t[aquastreamult] = \"aquastreamultimate\",\n\t[poweradjust3] = \"poweradjust3\"\n};\n\n#define DRIVER_NAME\t\t\t\"aquacomputer_d5next\"\n\n#define STATUS_REPORT_ID\t\t0x01\n#define STATUS_UPDATE_INTERVAL\t\t(2 * HZ)\t \n#define SERIAL_PART_OFFSET\t\t2\n\n#define CTRL_REPORT_ID\t\t\t0x03\n#define AQUAERO_CTRL_REPORT_ID\t\t0x0b\n\n#define CTRL_REPORT_DELAY\t\t200\t \n\n \n#define SECONDARY_CTRL_REPORT_ID\t0x02\n#define SECONDARY_CTRL_REPORT_SIZE\t0x0B\n\nstatic u8 secondary_ctrl_report[] = {\n\t0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x34, 0xC6\n};\n\n \n#define AQUAERO_SECONDARY_CTRL_REPORT_ID\t0x06\n#define AQUAERO_SECONDARY_CTRL_REPORT_SIZE\t0x07\n\nstatic u8 aquaero_secondary_ctrl_report[] = {\n\t0x06, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00\n};\n\n \n#define AQUASTREAMXT_STATUS_REPORT_ID\t0x04\n\n#define POWERADJUST3_STATUS_REPORT_ID\t0x03\n\n \n#define AQC_8\t\t0\n#define AQC_BE16\t1\n\n \n#define AQC_SERIAL_START\t\t0x3\n#define AQC_FIRMWARE_VERSION\t\t0xD\n\n#define AQC_SENSOR_SIZE\t\t\t0x02\n#define AQC_SENSOR_NA\t\t\t0x7FFF\n#define AQC_FAN_PERCENT_OFFSET\t\t0x00\n#define AQC_FAN_VOLTAGE_OFFSET\t\t0x02\n#define AQC_FAN_CURRENT_OFFSET\t\t0x04\n#define AQC_FAN_POWER_OFFSET\t\t0x06\n#define AQC_FAN_SPEED_OFFSET\t\t0x08\n\n \n#define AQUAERO_SERIAL_START\t\t\t0x07\n#define AQUAERO_FIRMWARE_VERSION\t\t0x0B\n#define AQUAERO_NUM_FANS\t\t\t4\n#define AQUAERO_NUM_SENSORS\t\t\t8\n#define AQUAERO_NUM_VIRTUAL_SENSORS\t\t8\n#define AQUAERO_NUM_CALC_VIRTUAL_SENSORS\t4\n#define AQUAERO_NUM_FLOW_SENSORS\t\t2\n#define AQUAERO_CTRL_REPORT_SIZE\t\t0xa93\n#define AQUAERO_CTRL_PRESET_ID\t\t\t0x5c\n#define AQUAERO_CTRL_PRESET_SIZE\t\t0x02\n#define AQUAERO_CTRL_PRESET_START\t\t0x55c\n\n \n#define AQUAERO_SENSOR_START\t\t\t0x65\n#define AQUAERO_VIRTUAL_SENSOR_START\t\t0x85\n#define AQUAERO_CALC_VIRTUAL_SENSOR_START\t0x95\n#define AQUAERO_FLOW_SENSORS_START\t\t0xF9\n#define AQUAERO_FAN_VOLTAGE_OFFSET\t\t0x04\n#define AQUAERO_FAN_CURRENT_OFFSET\t\t0x06\n#define AQUAERO_FAN_POWER_OFFSET\t\t0x08\n#define AQUAERO_FAN_SPEED_OFFSET\t\t0x00\nstatic u16 aquaero_sensor_fan_offsets[] = { 0x167, 0x173, 0x17f, 0x18B };\n\n \n#define AQUAERO_TEMP_CTRL_OFFSET\t0xdb\n#define AQUAERO_FAN_CTRL_MIN_PWR_OFFSET\t0x04\n#define AQUAERO_FAN_CTRL_MAX_PWR_OFFSET\t0x06\n#define AQUAERO_FAN_CTRL_SRC_OFFSET\t0x10\nstatic u16 aquaero_ctrl_fan_offsets[] = { 0x20c, 0x220, 0x234, 0x248 };\n\n \n#define D5NEXT_NUM_FANS\t\t\t2\n#define D5NEXT_NUM_SENSORS\t\t1\n#define D5NEXT_NUM_VIRTUAL_SENSORS\t8\n#define D5NEXT_CTRL_REPORT_SIZE\t\t0x329\n\n \n#define D5NEXT_POWER_CYCLES\t\t0x18\n#define D5NEXT_COOLANT_TEMP\t\t0x57\n#define D5NEXT_PUMP_OFFSET\t\t0x6c\n#define D5NEXT_FAN_OFFSET\t\t0x5f\n#define D5NEXT_5V_VOLTAGE\t\t0x39\n#define D5NEXT_12V_VOLTAGE\t\t0x37\n#define D5NEXT_VIRTUAL_SENSORS_START\t0x3f\nstatic u16 d5next_sensor_fan_offsets[] = { D5NEXT_PUMP_OFFSET, D5NEXT_FAN_OFFSET };\n\n \n#define D5NEXT_TEMP_CTRL_OFFSET\t\t0x2D\t \nstatic u16 d5next_ctrl_fan_offsets[] = { 0x97, 0x42 };\t \n\n \n \n#define AQUASTREAMULT_NUM_FANS\t\t1\n#define AQUASTREAMULT_NUM_SENSORS\t2\n\n \n#define AQUASTREAMULT_SENSOR_START\t\t0x2D\n#define AQUASTREAMULT_PUMP_OFFSET\t\t0x51\n#define AQUASTREAMULT_PUMP_VOLTAGE\t\t0x3D\n#define AQUASTREAMULT_PUMP_CURRENT\t\t0x53\n#define AQUASTREAMULT_PUMP_POWER\t\t0x55\n#define AQUASTREAMULT_FAN_OFFSET\t\t0x41\n#define AQUASTREAMULT_PRESSURE_OFFSET\t\t0x57\n#define AQUASTREAMULT_FLOW_SENSOR_OFFSET\t0x37\n#define AQUASTREAMULT_FAN_VOLTAGE_OFFSET\t0x02\n#define AQUASTREAMULT_FAN_CURRENT_OFFSET\t0x00\n#define AQUASTREAMULT_FAN_POWER_OFFSET\t\t0x04\n#define AQUASTREAMULT_FAN_SPEED_OFFSET\t\t0x06\nstatic u16 aquastreamult_sensor_fan_offsets[] = { AQUASTREAMULT_FAN_OFFSET };\n\n \n#define FARBWERK_NUM_SENSORS\t\t4\n#define FARBWERK_SENSOR_START\t\t0x2f\n\n \n#define FARBWERK360_NUM_SENSORS\t\t\t4\n#define FARBWERK360_NUM_VIRTUAL_SENSORS\t\t16\n#define FARBWERK360_CTRL_REPORT_SIZE\t\t0x682\n\n \n#define FARBWERK360_SENSOR_START\t\t0x32\n#define FARBWERK360_VIRTUAL_SENSORS_START\t0x3a\n\n \n#define FARBWERK360_TEMP_CTRL_OFFSET\t\t0x8\n\n \n#define OCTO_NUM_FANS\t\t\t8\n#define OCTO_NUM_SENSORS\t\t4\n#define OCTO_NUM_VIRTUAL_SENSORS\t16\n#define OCTO_CTRL_REPORT_SIZE\t\t0x65F\n\n \n#define OCTO_POWER_CYCLES\t\t0x18\n#define OCTO_SENSOR_START\t\t0x3D\n#define OCTO_VIRTUAL_SENSORS_START\t0x45\nstatic u16 octo_sensor_fan_offsets[] = { 0x7D, 0x8A, 0x97, 0xA4, 0xB1, 0xBE, 0xCB, 0xD8 };\n\n \n#define OCTO_TEMP_CTRL_OFFSET\t\t0xA\n \nstatic u16 octo_ctrl_fan_offsets[] = { 0x5B, 0xB0, 0x105, 0x15A, 0x1AF, 0x204, 0x259, 0x2AE };\n\n \n#define QUADRO_NUM_FANS\t\t\t4\n#define QUADRO_NUM_SENSORS\t\t4\n#define QUADRO_NUM_VIRTUAL_SENSORS\t16\n#define QUADRO_NUM_FLOW_SENSORS\t\t1\n#define QUADRO_CTRL_REPORT_SIZE\t\t0x3c1\n\n \n#define QUADRO_POWER_CYCLES\t\t0x18\n#define QUADRO_SENSOR_START\t\t0x34\n#define QUADRO_VIRTUAL_SENSORS_START\t0x3c\n#define QUADRO_FLOW_SENSOR_OFFSET\t0x6e\nstatic u16 quadro_sensor_fan_offsets[] = { 0x70, 0x7D, 0x8A, 0x97 };\n\n \n#define QUADRO_TEMP_CTRL_OFFSET\t\t0xA\n#define QUADRO_FLOW_PULSES_CTRL_OFFSET\t0x6\nstatic u16 quadro_ctrl_fan_offsets[] = { 0x37, 0x8c, 0xe1, 0x136 };  \n\n \n#define HIGHFLOWNEXT_NUM_SENSORS\t2\n#define HIGHFLOWNEXT_NUM_FLOW_SENSORS\t1\n\n \n#define HIGHFLOWNEXT_SENSOR_START\t85\n#define HIGHFLOWNEXT_FLOW\t\t81\n#define HIGHFLOWNEXT_WATER_QUALITY\t89\n#define HIGHFLOWNEXT_POWER\t\t91\n#define HIGHFLOWNEXT_CONDUCTIVITY\t95\n#define HIGHFLOWNEXT_5V_VOLTAGE\t\t97\n#define HIGHFLOWNEXT_5V_VOLTAGE_USB\t99\n\n \n#define LEAKSHIELD_NUM_SENSORS\t\t2\n\n \n#define LEAKSHIELD_PRESSURE_ADJUSTED\t285\n#define LEAKSHIELD_TEMPERATURE_1\t265\n#define LEAKSHIELD_TEMPERATURE_2\t287\n#define LEAKSHIELD_PRESSURE_MIN\t\t291\n#define LEAKSHIELD_PRESSURE_TARGET\t293\n#define LEAKSHIELD_PRESSURE_MAX\t\t295\n#define LEAKSHIELD_PUMP_RPM_IN\t\t101\n#define LEAKSHIELD_FLOW_IN\t\t111\n#define LEAKSHIELD_RESERVOIR_VOLUME\t313\n#define LEAKSHIELD_RESERVOIR_FILLED\t311\n\n \n#define AQUASTREAMXT_SERIAL_START\t\t0x3a\n#define AQUASTREAMXT_FIRMWARE_VERSION\t\t0x32\n#define AQUASTREAMXT_NUM_FANS\t\t\t2\n#define AQUASTREAMXT_NUM_SENSORS\t\t3\n#define AQUASTREAMXT_FAN_STOPPED\t\t0x4\n#define AQUASTREAMXT_PUMP_CONVERSION_CONST\t45000000\n#define AQUASTREAMXT_FAN_CONVERSION_CONST\t5646000\n#define AQUASTREAMXT_SENSOR_REPORT_SIZE\t\t0x42\n\n \n#define AQUASTREAMXT_SENSOR_START\t\t0xd\n#define AQUASTREAMXT_FAN_VOLTAGE_OFFSET\t\t0x7\n#define AQUASTREAMXT_FAN_STATUS_OFFSET\t\t0x1d\n#define AQUASTREAMXT_PUMP_VOLTAGE_OFFSET\t0x9\n#define AQUASTREAMXT_PUMP_CURR_OFFSET\t\t0xb\nstatic u16 aquastreamxt_sensor_fan_offsets[] = { 0x13, 0x1b };\n\n \n#define POWERADJUST3_NUM_SENSORS\t1\n#define POWERADJUST3_SENSOR_REPORT_SIZE\t0x32\n\n \n#define POWERADJUST3_SENSOR_START\t0x03\n\n \nstatic const char *const label_d5next_temp[] = {\n\t\"Coolant temp\"\n};\n\nstatic const char *const label_d5next_speeds[] = {\n\t\"Pump speed\",\n\t\"Fan speed\"\n};\n\nstatic const char *const label_d5next_power[] = {\n\t\"Pump power\",\n\t\"Fan power\"\n};\n\nstatic const char *const label_d5next_voltages[] = {\n\t\"Pump voltage\",\n\t\"Fan voltage\",\n\t\"+5V voltage\",\n\t\"+12V voltage\"\n};\n\nstatic const char *const label_d5next_current[] = {\n\t\"Pump current\",\n\t\"Fan current\"\n};\n\n \nstatic const char *const label_temp_sensors[] = {\n\t\"Sensor 1\",\n\t\"Sensor 2\",\n\t\"Sensor 3\",\n\t\"Sensor 4\",\n\t\"Sensor 5\",\n\t\"Sensor 6\",\n\t\"Sensor 7\",\n\t\"Sensor 8\"\n};\n\nstatic const char *const label_virtual_temp_sensors[] = {\n\t\"Virtual sensor 1\",\n\t\"Virtual sensor 2\",\n\t\"Virtual sensor 3\",\n\t\"Virtual sensor 4\",\n\t\"Virtual sensor 5\",\n\t\"Virtual sensor 6\",\n\t\"Virtual sensor 7\",\n\t\"Virtual sensor 8\",\n\t\"Virtual sensor 9\",\n\t\"Virtual sensor 10\",\n\t\"Virtual sensor 11\",\n\t\"Virtual sensor 12\",\n\t\"Virtual sensor 13\",\n\t\"Virtual sensor 14\",\n\t\"Virtual sensor 15\",\n\t\"Virtual sensor 16\",\n};\n\nstatic const char *const label_aquaero_calc_temp_sensors[] = {\n\t\"Calc. virtual sensor 1\",\n\t\"Calc. virtual sensor 2\",\n\t\"Calc. virtual sensor 3\",\n\t\"Calc. virtual sensor 4\"\n};\n\n \nstatic const char *const label_fan_speed[] = {\n\t\"Fan 1 speed\",\n\t\"Fan 2 speed\",\n\t\"Fan 3 speed\",\n\t\"Fan 4 speed\",\n\t\"Fan 5 speed\",\n\t\"Fan 6 speed\",\n\t\"Fan 7 speed\",\n\t\"Fan 8 speed\"\n};\n\nstatic const char *const label_fan_power[] = {\n\t\"Fan 1 power\",\n\t\"Fan 2 power\",\n\t\"Fan 3 power\",\n\t\"Fan 4 power\",\n\t\"Fan 5 power\",\n\t\"Fan 6 power\",\n\t\"Fan 7 power\",\n\t\"Fan 8 power\"\n};\n\nstatic const char *const label_fan_voltage[] = {\n\t\"Fan 1 voltage\",\n\t\"Fan 2 voltage\",\n\t\"Fan 3 voltage\",\n\t\"Fan 4 voltage\",\n\t\"Fan 5 voltage\",\n\t\"Fan 6 voltage\",\n\t\"Fan 7 voltage\",\n\t\"Fan 8 voltage\"\n};\n\nstatic const char *const label_fan_current[] = {\n\t\"Fan 1 current\",\n\t\"Fan 2 current\",\n\t\"Fan 3 current\",\n\t\"Fan 4 current\",\n\t\"Fan 5 current\",\n\t\"Fan 6 current\",\n\t\"Fan 7 current\",\n\t\"Fan 8 current\"\n};\n\n \nstatic const char *const label_quadro_speeds[] = {\n\t\"Fan 1 speed\",\n\t\"Fan 2 speed\",\n\t\"Fan 3 speed\",\n\t\"Fan 4 speed\",\n\t\"Flow speed [dL/h]\"\n};\n\n \nstatic const char *const label_aquaero_speeds[] = {\n\t\"Fan 1 speed\",\n\t\"Fan 2 speed\",\n\t\"Fan 3 speed\",\n\t\"Fan 4 speed\",\n\t\"Flow sensor 1 [dL/h]\",\n\t\"Flow sensor 2 [dL/h]\"\n};\n\n \nstatic const char *const label_highflownext_temp_sensors[] = {\n\t\"Coolant temp\",\n\t\"External sensor\"\n};\n\nstatic const char *const label_highflownext_fan_speed[] = {\n\t\"Flow [dL/h]\",\n\t\"Water quality [%]\",\n\t\"Conductivity [nS/cm]\",\n};\n\nstatic const char *const label_highflownext_power[] = {\n\t\"Dissipated power\",\n};\n\nstatic const char *const label_highflownext_voltage[] = {\n\t\"+5V voltage\",\n\t\"+5V USB voltage\"\n};\n\n \nstatic const char *const label_leakshield_temp_sensors[] = {\n\t\"Temperature 1\",\n\t\"Temperature 2\"\n};\n\nstatic const char *const label_leakshield_fan_speed[] = {\n\t\"Pressure [ubar]\",\n\t\"User-Provided Pump Speed\",\n\t\"User-Provided Flow [dL/h]\",\n\t\"Reservoir Volume [ml]\",\n\t\"Reservoir Filled [ml]\",\n};\n\n \nstatic const char *const label_aquastreamxt_temp_sensors[] = {\n\t\"Fan IC temp\",\n\t\"External sensor\",\n\t\"Coolant temp\"\n};\n\n \nstatic const char *const label_aquastreamult_temp[] = {\n\t\"Coolant temp\",\n\t\"External temp\"\n};\n\nstatic const char *const label_aquastreamult_speeds[] = {\n\t\"Fan speed\",\n\t\"Pump speed\",\n\t\"Pressure [mbar]\",\n\t\"Flow speed [dL/h]\"\n};\n\nstatic const char *const label_aquastreamult_power[] = {\n\t\"Fan power\",\n\t\"Pump power\"\n};\n\nstatic const char *const label_aquastreamult_voltages[] = {\n\t\"Fan voltage\",\n\t\"Pump voltage\"\n};\n\nstatic const char *const label_aquastreamult_current[] = {\n\t\"Fan current\",\n\t\"Pump current\"\n};\n\n \nstatic const char *const label_poweradjust3_temp_sensors[] = {\n\t\"External sensor\"\n};\n\nstruct aqc_fan_structure_offsets {\n\tu8 voltage;\n\tu8 curr;\n\tu8 power;\n\tu8 speed;\n};\n\n \nstatic struct aqc_fan_structure_offsets aqc_aquaero_fan_structure = {\n\t.voltage = AQUAERO_FAN_VOLTAGE_OFFSET,\n\t.curr = AQUAERO_FAN_CURRENT_OFFSET,\n\t.power = AQUAERO_FAN_POWER_OFFSET,\n\t.speed = AQUAERO_FAN_SPEED_OFFSET\n};\n\n \nstatic struct aqc_fan_structure_offsets aqc_aquastreamult_fan_structure = {\n\t.voltage = AQUASTREAMULT_FAN_VOLTAGE_OFFSET,\n\t.curr = AQUASTREAMULT_FAN_CURRENT_OFFSET,\n\t.power = AQUASTREAMULT_FAN_POWER_OFFSET,\n\t.speed = AQUASTREAMULT_FAN_SPEED_OFFSET\n};\n\n \nstatic struct aqc_fan_structure_offsets aqc_general_fan_structure = {\n\t.voltage = AQC_FAN_VOLTAGE_OFFSET,\n\t.curr = AQC_FAN_CURRENT_OFFSET,\n\t.power = AQC_FAN_POWER_OFFSET,\n\t.speed = AQC_FAN_SPEED_OFFSET\n};\n\nstruct aqc_data {\n\tstruct hid_device *hdev;\n\tstruct device *hwmon_dev;\n\tstruct dentry *debugfs;\n\tstruct mutex mutex;\t \n\tenum kinds kind;\n\tconst char *name;\n\n\tint status_report_id;\t \n\tint ctrl_report_id;\n\tint secondary_ctrl_report_id;\n\tint secondary_ctrl_report_size;\n\tu8 *secondary_ctrl_report;\n\n\tktime_t last_ctrl_report_op;\n\tint ctrl_report_delay;\t \n\n\tint buffer_size;\n\tu8 *buffer;\n\tint checksum_start;\n\tint checksum_length;\n\tint checksum_offset;\n\n\tint num_fans;\n\tu16 *fan_sensor_offsets;\n\tu16 *fan_ctrl_offsets;\n\tint num_temp_sensors;\n\tint temp_sensor_start_offset;\n\tint num_virtual_temp_sensors;\n\tint virtual_temp_sensor_start_offset;\n\tint num_calc_virt_temp_sensors;\n\tint calc_virt_temp_sensor_start_offset;\n\tu16 temp_ctrl_offset;\n\tu16 power_cycle_count_offset;\n\tint num_flow_sensors;\n\tu8 flow_sensors_start_offset;\n\tu8 flow_pulses_ctrl_offset;\n\tstruct aqc_fan_structure_offsets *fan_structure;\n\n\t \n\tu8 serial_number_start_offset;\n\tu32 serial_number[2];\n\tu8 firmware_version_offset;\n\tu16 firmware_version;\n\n\t \n\tu32 power_cycles;\n\n\t \n\ts32 temp_input[20];\t \n\ts32 speed_input[8];\n\tu32 speed_input_min[1];\n\tu32 speed_input_target[1];\n\tu32 speed_input_max[1];\n\tu32 power_input[8];\n\tu16 voltage_input[8];\n\tu16 current_input[8];\n\n\t \n\tconst char *const *temp_label;\n\tconst char *const *virtual_temp_label;\n\tconst char *const *calc_virt_temp_label;\t \n\tconst char *const *speed_label;\n\tconst char *const *power_label;\n\tconst char *const *voltage_label;\n\tconst char *const *current_label;\n\n\tunsigned long updated;\n};\n\n \nstatic int aqc_percent_to_pwm(u16 val)\n{\n\treturn DIV_ROUND_CLOSEST(val * 255, 100 * 100);\n}\n\n \nstatic int aqc_pwm_to_percent(long val)\n{\n\tif (val < 0 || val > 255)\n\t\treturn -EINVAL;\n\n\treturn DIV_ROUND_CLOSEST(val * 100 * 100, 255);\n}\n\n \nstatic int aqc_aquastreamxt_convert_pump_rpm(u16 val)\n{\n\tif (val > 0)\n\t\treturn DIV_ROUND_CLOSEST(AQUASTREAMXT_PUMP_CONVERSION_CONST, val);\n\treturn 0;\n}\n\n \nstatic int aqc_aquastreamxt_convert_fan_rpm(u16 val)\n{\n\tif (val > 0)\n\t\treturn DIV_ROUND_CLOSEST(AQUASTREAMXT_FAN_CONVERSION_CONST, val);\n\treturn 0;\n}\n\nstatic void aqc_delay_ctrl_report(struct aqc_data *priv)\n{\n\t \n\tif (priv->ctrl_report_delay) {\n\t\ts64 delta = ktime_ms_delta(ktime_get(), priv->last_ctrl_report_op);\n\n\t\tif (delta < priv->ctrl_report_delay)\n\t\t\tmsleep(priv->ctrl_report_delay - delta);\n\t}\n}\n\n \nstatic int aqc_get_ctrl_data(struct aqc_data *priv)\n{\n\tint ret;\n\n\taqc_delay_ctrl_report(priv);\n\n\tmemset(priv->buffer, 0x00, priv->buffer_size);\n\tret = hid_hw_raw_request(priv->hdev, priv->ctrl_report_id, priv->buffer, priv->buffer_size,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_GET_REPORT);\n\tif (ret < 0)\n\t\tret = -ENODATA;\n\n\tpriv->last_ctrl_report_op = ktime_get();\n\n\treturn ret;\n}\n\n \nstatic int aqc_send_ctrl_data(struct aqc_data *priv)\n{\n\tint ret;\n\tu16 checksum;\n\n\taqc_delay_ctrl_report(priv);\n\n\t \n\tif (priv->kind != aquaero) {\n\t\t \n\t\tchecksum = crc16(0xffff, priv->buffer + priv->checksum_start,\n\t\t\t\t priv->checksum_length);\n\t\tchecksum ^= 0xffff;\n\n\t\t \n\t\tput_unaligned_be16(checksum, priv->buffer + priv->checksum_offset);\n\t}\n\n\t \n\tret = hid_hw_raw_request(priv->hdev, priv->ctrl_report_id, priv->buffer, priv->buffer_size,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\tgoto record_access_and_ret;\n\n\t \n\tret = hid_hw_raw_request(priv->hdev, priv->secondary_ctrl_report_id,\n\t\t\t\t priv->secondary_ctrl_report, priv->secondary_ctrl_report_size,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\nrecord_access_and_ret:\n\tpriv->last_ctrl_report_op = ktime_get();\n\n\treturn ret;\n}\n\n \nstatic int aqc_get_ctrl_val(struct aqc_data *priv, int offset, long *val, int type)\n{\n\tint ret;\n\n\tmutex_lock(&priv->mutex);\n\n\tret = aqc_get_ctrl_data(priv);\n\tif (ret < 0)\n\t\tgoto unlock_and_return;\n\n\tswitch (type) {\n\tcase AQC_BE16:\n\t\t*val = (s16)get_unaligned_be16(priv->buffer + offset);\n\t\tbreak;\n\tcase AQC_8:\n\t\t*val = priv->buffer[offset];\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nunlock_and_return:\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\nstatic int aqc_set_ctrl_vals(struct aqc_data *priv, int *offsets, long *vals, int *types, int len)\n{\n\tint ret, i;\n\n\tmutex_lock(&priv->mutex);\n\n\tret = aqc_get_ctrl_data(priv);\n\tif (ret < 0)\n\t\tgoto unlock_and_return;\n\n\tfor (i = 0; i < len; i++) {\n\t\tswitch (types[i]) {\n\t\tcase AQC_BE16:\n\t\t\tput_unaligned_be16((s16)vals[i], priv->buffer + offsets[i]);\n\t\t\tbreak;\n\t\tcase AQC_8:\n\t\t\tpriv->buffer[offsets[i]] = (u8)vals[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tgoto unlock_and_return;\n\n\tret = aqc_send_ctrl_data(priv);\n\nunlock_and_return:\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\nstatic int aqc_set_ctrl_val(struct aqc_data *priv, int offset, long val, int type)\n{\n\treturn aqc_set_ctrl_vals(priv, &offset, &val, &type, 1);\n}\n\nstatic umode_t aqc_is_visible(const void *data, enum hwmon_sensor_types type, u32 attr, int channel)\n{\n\tconst struct aqc_data *priv = data;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tif (channel < priv->num_temp_sensors) {\n\t\t\tswitch (attr) {\n\t\t\tcase hwmon_temp_label:\n\t\t\tcase hwmon_temp_input:\n\t\t\t\treturn 0444;\n\t\t\tcase hwmon_temp_offset:\n\t\t\t\tif (priv->temp_ctrl_offset != 0)\n\t\t\t\t\treturn 0644;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (channel <\n\t\t    priv->num_temp_sensors + priv->num_virtual_temp_sensors +\n\t\t    priv->num_calc_virt_temp_sensors)\n\t\t\tswitch (attr) {\n\t\t\tcase hwmon_temp_label:\n\t\t\tcase hwmon_temp_input:\n\t\t\t\treturn 0444;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tif (priv->fan_ctrl_offsets && channel < priv->num_fans) {\n\t\t\tswitch (attr) {\n\t\t\tcase hwmon_pwm_input:\n\t\t\t\treturn 0644;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\tcase hwmon_fan_label:\n\t\t\tswitch (priv->kind) {\n\t\t\tcase aquastreamult:\n\t\t\t\t \n\t\t\t\tif (channel < 4)\n\t\t\t\t\treturn 0444;\n\t\t\t\tbreak;\n\t\t\tcase highflownext:\n\t\t\t\t \n\t\t\t\tif (channel < 3)\n\t\t\t\t\treturn 0444;\n\t\t\t\tbreak;\n\t\t\tcase leakshield:\n\t\t\t\t \n\t\t\t\tif (channel < 5)\n\t\t\t\t\treturn 0444;\n\t\t\t\tbreak;\n\t\t\tcase aquaero:\n\t\t\tcase quadro:\n\t\t\t\t \n\t\t\t\tif (channel < priv->num_fans + priv->num_flow_sensors)\n\t\t\t\t\treturn 0444;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (channel < priv->num_fans)\n\t\t\t\t\treturn 0444;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase hwmon_fan_pulses:\n\t\t\t \n\t\t\tif (priv->kind == quadro && channel == priv->num_fans)\n\t\t\t\treturn 0644;\n\t\t\tbreak;\n\t\tcase hwmon_fan_min:\n\t\tcase hwmon_fan_max:\n\t\tcase hwmon_fan_target:\n\t\t\t \n\t\t\tif (priv->kind == leakshield && channel == 0)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_power:\n\t\tswitch (priv->kind) {\n\t\tcase aquastreamult:\n\t\t\t \n\t\t\tif (channel < 2)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase highflownext:\n\t\t\t \n\t\t\tif (channel == 0)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase aquastreamxt:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (channel < priv->num_fans)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_curr:\n\t\tswitch (priv->kind) {\n\t\tcase aquastreamult:\n\t\t\t \n\t\t\tif (channel < 2)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase aquastreamxt:\n\t\t\t \n\t\t\tif (channel == 0)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (channel < priv->num_fans)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (priv->kind) {\n\t\tcase d5next:\n\t\t\t \n\t\t\tif (channel < priv->num_fans + 2)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase aquastreamult:\n\t\tcase highflownext:\n\t\t\t \n\t\t\tif (channel < 2)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (channel < priv->num_fans)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int aqc_legacy_read(struct aqc_data *priv)\n{\n\tint ret, i, sensor_value;\n\n\tmutex_lock(&priv->mutex);\n\n\tmemset(priv->buffer, 0x00, priv->buffer_size);\n\tret = hid_hw_raw_request(priv->hdev, priv->status_report_id, priv->buffer,\n\t\t\t\t priv->buffer_size, HID_FEATURE_REPORT, HID_REQ_GET_REPORT);\n\tif (ret < 0)\n\t\tgoto unlock_and_return;\n\n\t \n\tfor (i = 0; i < priv->num_temp_sensors; i++) {\n\t\tsensor_value = get_unaligned_le16(priv->buffer + priv->temp_sensor_start_offset +\n\t\t\t\t\t\t  i * AQC_SENSOR_SIZE);\n\t\tpriv->temp_input[i] = sensor_value * 10;\n\t}\n\n\t \n\tswitch (priv->kind) {\n\tcase aquastreamxt:\n\t\t \n\t\tpriv->serial_number[0] = get_unaligned_le16(priv->buffer +\n\t\t\t\t\t\t\t    priv->serial_number_start_offset);\n\t\tpriv->firmware_version =\n\t\t\tget_unaligned_le16(priv->buffer + priv->firmware_version_offset);\n\n\t\t \n\t\tsensor_value = get_unaligned_le16(priv->buffer + priv->fan_sensor_offsets[0]);\n\t\tpriv->speed_input[0] = aqc_aquastreamxt_convert_pump_rpm(sensor_value);\n\n\t\t \n\t\tsensor_value = get_unaligned_le16(priv->buffer + AQUASTREAMXT_FAN_STATUS_OFFSET);\n\t\tif (sensor_value == AQUASTREAMXT_FAN_STOPPED) {\n\t\t\tpriv->speed_input[1] = 0;\n\t\t} else {\n\t\t\tsensor_value =\n\t\t\t\tget_unaligned_le16(priv->buffer + priv->fan_sensor_offsets[1]);\n\t\t\tpriv->speed_input[1] = aqc_aquastreamxt_convert_fan_rpm(sensor_value);\n\t\t}\n\n\t\t \n\t\tsensor_value = get_unaligned_le16(priv->buffer + AQUASTREAMXT_PUMP_CURR_OFFSET);\n\t\tpriv->current_input[0] = DIV_ROUND_CLOSEST(sensor_value * 176, 100) - 52;\n\n\t\tsensor_value = get_unaligned_le16(priv->buffer + AQUASTREAMXT_PUMP_VOLTAGE_OFFSET);\n\t\tpriv->voltage_input[0] = DIV_ROUND_CLOSEST(sensor_value * 1000, 61);\n\n\t\tsensor_value = get_unaligned_le16(priv->buffer + AQUASTREAMXT_FAN_VOLTAGE_OFFSET);\n\t\tpriv->voltage_input[1] = DIV_ROUND_CLOSEST(sensor_value * 1000, 63);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpriv->updated = jiffies;\n\nunlock_and_return:\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\nstatic int aqc_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t    int channel, long *val)\n{\n\tint ret;\n\tstruct aqc_data *priv = dev_get_drvdata(dev);\n\n\tif (time_after(jiffies, priv->updated + STATUS_UPDATE_INTERVAL)) {\n\t\tif (priv->status_report_id != 0) {\n\t\t\t \n\t\t\tret = aqc_legacy_read(priv);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -ENODATA;\n\t\t} else {\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\tif (priv->temp_input[channel] == -ENODATA)\n\t\t\t\treturn -ENODATA;\n\n\t\t\t*val = priv->temp_input[channel];\n\t\t\tbreak;\n\t\tcase hwmon_temp_offset:\n\t\t\tret =\n\t\t\t    aqc_get_ctrl_val(priv, priv->temp_ctrl_offset +\n\t\t\t\t\t     channel * AQC_SENSOR_SIZE, val, AQC_BE16);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t*val *= 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\tif (priv->speed_input[channel] == -ENODATA)\n\t\t\t\treturn -ENODATA;\n\n\t\t\t*val = priv->speed_input[channel];\n\t\t\tbreak;\n\t\tcase hwmon_fan_min:\n\t\t\t*val = priv->speed_input_min[channel];\n\t\t\tbreak;\n\t\tcase hwmon_fan_max:\n\t\t\t*val = priv->speed_input_max[channel];\n\t\t\tbreak;\n\t\tcase hwmon_fan_target:\n\t\t\t*val = priv->speed_input_target[channel];\n\t\t\tbreak;\n\t\tcase hwmon_fan_pulses:\n\t\t\tret = aqc_get_ctrl_val(priv, priv->flow_pulses_ctrl_offset,\n\t\t\t\t\t       val, AQC_BE16);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_power:\n\t\t*val = priv->power_input[channel];\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (priv->kind) {\n\t\tcase aquaero:\n\t\t\tret = aqc_get_ctrl_val(priv,\n\t\t\t\tAQUAERO_CTRL_PRESET_START + channel * AQUAERO_CTRL_PRESET_SIZE,\n\t\t\t\tval, AQC_BE16);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = aqc_percent_to_pwm(*val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = aqc_get_ctrl_val(priv, priv->fan_ctrl_offsets[channel],\n\t\t\t\t\t       val, AQC_BE16);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t*val = aqc_percent_to_pwm(*val);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\t*val = priv->voltage_input[channel];\n\t\tbreak;\n\tcase hwmon_curr:\n\t\t*val = priv->current_input[channel];\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int aqc_read_string(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t   int channel, const char **str)\n{\n\tstruct aqc_data *priv = dev_get_drvdata(dev);\n\n\t \n\tint num_non_calc_sensors = priv->num_temp_sensors + priv->num_virtual_temp_sensors;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tif (channel < priv->num_temp_sensors) {\n\t\t\t*str = priv->temp_label[channel];\n\t\t} else {\n\t\t\tif (priv->kind == aquaero && channel >= num_non_calc_sensors)\n\t\t\t\t*str =\n\t\t\t\t    priv->calc_virt_temp_label[channel - num_non_calc_sensors];\n\t\t\telse\n\t\t\t\t*str = priv->virtual_temp_label[channel - priv->num_temp_sensors];\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\t*str = priv->speed_label[channel];\n\t\tbreak;\n\tcase hwmon_power:\n\t\t*str = priv->power_label[channel];\n\t\tbreak;\n\tcase hwmon_in:\n\t\t*str = priv->voltage_label[channel];\n\t\tbreak;\n\tcase hwmon_curr:\n\t\t*str = priv->current_label[channel];\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int aqc_write(struct device *dev, enum hwmon_sensor_types type, u32 attr, int channel,\n\t\t     long val)\n{\n\tint ret, pwm_value;\n\t \n\tint ctrl_values_offsets[4];\n\tlong ctrl_values[4];\n\tint ctrl_values_types[4];\n\tstruct aqc_data *priv = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_offset:\n\t\t\t \n\t\t\tval = clamp_val(val, -15000, 15000) / 10;\n\t\t\tret =\n\t\t\t    aqc_set_ctrl_val(priv, priv->temp_ctrl_offset +\n\t\t\t\t\t     channel * AQC_SENSOR_SIZE, val, AQC_BE16);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_pulses:\n\t\t\tval = clamp_val(val, 10, 1000);\n\t\t\tret = aqc_set_ctrl_val(priv, priv->flow_pulses_ctrl_offset,\n\t\t\t\t\t       val, AQC_BE16);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\tpwm_value = aqc_pwm_to_percent(val);\n\t\t\tif (pwm_value < 0)\n\t\t\t\treturn pwm_value;\n\n\t\t\tswitch (priv->kind) {\n\t\t\tcase aquaero:\n\t\t\t\t \n\t\t\t\tctrl_values_offsets[0] = AQUAERO_CTRL_PRESET_START +\n\t\t\t\t    channel * AQUAERO_CTRL_PRESET_SIZE;\n\t\t\t\tctrl_values[0] = pwm_value;\n\t\t\t\tctrl_values_types[0] = AQC_BE16;\n\n\t\t\t\t \n\t\t\t\tctrl_values_offsets[1] = priv->fan_ctrl_offsets[channel] +\n\t\t\t\t    AQUAERO_FAN_CTRL_SRC_OFFSET;\n\t\t\t\tctrl_values[1] = AQUAERO_CTRL_PRESET_ID + channel;\n\t\t\t\tctrl_values_types[1] = AQC_BE16;\n\n\t\t\t\t \n\t\t\t\tctrl_values_offsets[2] = priv->fan_ctrl_offsets[channel] +\n\t\t\t\t    AQUAERO_FAN_CTRL_MIN_PWR_OFFSET;\n\t\t\t\tctrl_values[2] = 0;\n\t\t\t\tctrl_values_types[2] = AQC_BE16;\n\n\t\t\t\t \n\t\t\t\tctrl_values_offsets[3] = priv->fan_ctrl_offsets[channel] +\n\t\t\t\t    AQUAERO_FAN_CTRL_MAX_PWR_OFFSET;\n\t\t\t\tctrl_values[3] = aqc_pwm_to_percent(255);\n\t\t\t\tctrl_values_types[3] = AQC_BE16;\n\n\t\t\t\tret = aqc_set_ctrl_vals(priv, ctrl_values_offsets, ctrl_values,\n\t\t\t\t\t\t\tctrl_values_types, 4);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = aqc_set_ctrl_val(priv, priv->fan_ctrl_offsets[channel],\n\t\t\t\t\t\t       pwm_value, AQC_BE16);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops aqc_hwmon_ops = {\n\t.is_visible = aqc_is_visible,\n\t.read = aqc_read,\n\t.read_string = aqc_read_string,\n\t.write = aqc_write\n};\n\nstatic const struct hwmon_channel_info * const aqc_info[] = {\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_OFFSET,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_OFFSET,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_OFFSET,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_OFFSET,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_OFFSET,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_OFFSET,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_OFFSET,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL | HWMON_T_OFFSET,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_LABEL),\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_MIN | HWMON_F_MAX |\n\t\t\t   HWMON_F_TARGET,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_PULSES,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL,\n\t\t\t   HWMON_F_INPUT | HWMON_F_LABEL),\n\tHWMON_CHANNEL_INFO(power,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL,\n\t\t\t   HWMON_P_INPUT | HWMON_P_LABEL),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT,\n\t\t\t   HWMON_PWM_INPUT),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_LABEL),\n\tHWMON_CHANNEL_INFO(curr,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL,\n\t\t\t   HWMON_C_INPUT | HWMON_C_LABEL),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info aqc_chip_info = {\n\t.ops = &aqc_hwmon_ops,\n\t.info = aqc_info,\n};\n\nstatic int aqc_raw_event(struct hid_device *hdev, struct hid_report *report, u8 *data, int size)\n{\n\tint i, j, sensor_value;\n\tstruct aqc_data *priv;\n\n\tif (report->id != STATUS_REPORT_ID)\n\t\treturn 0;\n\n\tpriv = hid_get_drvdata(hdev);\n\n\t \n\tpriv->serial_number[0] = get_unaligned_be16(data + priv->serial_number_start_offset);\n\tpriv->serial_number[1] = get_unaligned_be16(data + priv->serial_number_start_offset +\n\t\t\t\t\t\t    SERIAL_PART_OFFSET);\n\tpriv->firmware_version = get_unaligned_be16(data + priv->firmware_version_offset);\n\n\t \n\tfor (i = 0; i < priv->num_temp_sensors; i++) {\n\t\tsensor_value = get_unaligned_be16(data +\n\t\t\t\t\t\t  priv->temp_sensor_start_offset +\n\t\t\t\t\t\t  i * AQC_SENSOR_SIZE);\n\t\tif (sensor_value == AQC_SENSOR_NA)\n\t\t\tpriv->temp_input[i] = -ENODATA;\n\t\telse\n\t\t\tpriv->temp_input[i] = sensor_value * 10;\n\t}\n\n\t \n\tfor (j = 0; j < priv->num_virtual_temp_sensors; j++) {\n\t\tsensor_value = get_unaligned_be16(data +\n\t\t\t\t\t\t  priv->virtual_temp_sensor_start_offset +\n\t\t\t\t\t\t  j * AQC_SENSOR_SIZE);\n\t\tif (sensor_value == AQC_SENSOR_NA)\n\t\t\tpriv->temp_input[i] = -ENODATA;\n\t\telse\n\t\t\tpriv->temp_input[i] = sensor_value * 10;\n\t\ti++;\n\t}\n\n\t \n\tfor (i = 0; i < priv->num_fans; i++) {\n\t\tpriv->speed_input[i] =\n\t\t    get_unaligned_be16(data + priv->fan_sensor_offsets[i] +\n\t\t\t\t       priv->fan_structure->speed);\n\t\tpriv->power_input[i] =\n\t\t    get_unaligned_be16(data + priv->fan_sensor_offsets[i] +\n\t\t\t\t       priv->fan_structure->power) * 10000;\n\t\tpriv->voltage_input[i] =\n\t\t    get_unaligned_be16(data + priv->fan_sensor_offsets[i] +\n\t\t\t\t       priv->fan_structure->voltage) * 10;\n\t\tpriv->current_input[i] =\n\t\t    get_unaligned_be16(data + priv->fan_sensor_offsets[i] +\n\t\t\t\t       priv->fan_structure->curr);\n\t}\n\n\t \n\tfor (j = 0; j < priv->num_flow_sensors; j++) {\n\t\tpriv->speed_input[i] = get_unaligned_be16(data + priv->flow_sensors_start_offset +\n\t\t\t\t\t\t\t  j * AQC_SENSOR_SIZE);\n\t\ti++;\n\t}\n\n\tif (priv->power_cycle_count_offset != 0)\n\t\tpriv->power_cycles = get_unaligned_be32(data + priv->power_cycle_count_offset);\n\n\t \n\tswitch (priv->kind) {\n\tcase aquaero:\n\t\t \n\t\ti = priv->num_temp_sensors + priv->num_virtual_temp_sensors;\n\t\tfor (j = 0; j < priv->num_calc_virt_temp_sensors; j++) {\n\t\t\tsensor_value = get_unaligned_be16(data +\n\t\t\t\t\tpriv->calc_virt_temp_sensor_start_offset +\n\t\t\t\t\tj * AQC_SENSOR_SIZE);\n\t\t\tif (sensor_value == AQC_SENSOR_NA)\n\t\t\t\tpriv->temp_input[i] = -ENODATA;\n\t\t\telse\n\t\t\t\tpriv->temp_input[i] = sensor_value * 10;\n\t\t\ti++;\n\t\t}\n\t\tbreak;\n\tcase aquastreamult:\n\t\tpriv->speed_input[1] = get_unaligned_be16(data + AQUASTREAMULT_PUMP_OFFSET);\n\t\tpriv->speed_input[2] = get_unaligned_be16(data + AQUASTREAMULT_PRESSURE_OFFSET);\n\t\tpriv->speed_input[3] = get_unaligned_be16(data + AQUASTREAMULT_FLOW_SENSOR_OFFSET);\n\n\t\tpriv->power_input[1] = get_unaligned_be16(data + AQUASTREAMULT_PUMP_POWER) * 10000;\n\n\t\tpriv->voltage_input[1] = get_unaligned_be16(data + AQUASTREAMULT_PUMP_VOLTAGE) * 10;\n\n\t\tpriv->current_input[1] = get_unaligned_be16(data + AQUASTREAMULT_PUMP_CURRENT);\n\t\tbreak;\n\tcase d5next:\n\t\tpriv->voltage_input[2] = get_unaligned_be16(data + D5NEXT_5V_VOLTAGE) * 10;\n\t\tpriv->voltage_input[3] = get_unaligned_be16(data + D5NEXT_12V_VOLTAGE) * 10;\n\t\tbreak;\n\tcase highflownext:\n\t\t \n\t\tif (priv->temp_input[1] == -ENODATA)\n\t\t\tpriv->power_input[0] = -ENODATA;\n\t\telse\n\t\t\tpriv->power_input[0] =\n\t\t\t    get_unaligned_be16(data + HIGHFLOWNEXT_POWER) * 1000000;\n\n\t\tpriv->voltage_input[0] = get_unaligned_be16(data + HIGHFLOWNEXT_5V_VOLTAGE) * 10;\n\t\tpriv->voltage_input[1] =\n\t\t    get_unaligned_be16(data + HIGHFLOWNEXT_5V_VOLTAGE_USB) * 10;\n\n\t\tpriv->speed_input[1] = get_unaligned_be16(data + HIGHFLOWNEXT_WATER_QUALITY);\n\t\tpriv->speed_input[2] = get_unaligned_be16(data + HIGHFLOWNEXT_CONDUCTIVITY);\n\t\tbreak;\n\tcase leakshield:\n\t\tpriv->speed_input[0] =\n\t\t    ((s16)get_unaligned_be16(data + LEAKSHIELD_PRESSURE_ADJUSTED)) * 100;\n\t\tpriv->speed_input_min[0] = get_unaligned_be16(data + LEAKSHIELD_PRESSURE_MIN) * 100;\n\t\tpriv->speed_input_target[0] =\n\t\t    get_unaligned_be16(data + LEAKSHIELD_PRESSURE_TARGET) * 100;\n\t\tpriv->speed_input_max[0] = get_unaligned_be16(data + LEAKSHIELD_PRESSURE_MAX) * 100;\n\n\t\tpriv->speed_input[1] = get_unaligned_be16(data + LEAKSHIELD_PUMP_RPM_IN);\n\t\tif (priv->speed_input[1] == AQC_SENSOR_NA)\n\t\t\tpriv->speed_input[1] = -ENODATA;\n\n\t\tpriv->speed_input[2] = get_unaligned_be16(data + LEAKSHIELD_FLOW_IN);\n\t\tif (priv->speed_input[2] == AQC_SENSOR_NA)\n\t\t\tpriv->speed_input[2] = -ENODATA;\n\n\t\tpriv->speed_input[3] = get_unaligned_be16(data + LEAKSHIELD_RESERVOIR_VOLUME);\n\t\tpriv->speed_input[4] = get_unaligned_be16(data + LEAKSHIELD_RESERVOIR_FILLED);\n\n\t\t \n\t\tpriv->temp_input[1] = get_unaligned_be16(data + LEAKSHIELD_TEMPERATURE_2) * 10;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpriv->updated = jiffies;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic int serial_number_show(struct seq_file *seqf, void *unused)\n{\n\tstruct aqc_data *priv = seqf->private;\n\n\tseq_printf(seqf, \"%05u-%05u\\n\", priv->serial_number[0], priv->serial_number[1]);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(serial_number);\n\nstatic int firmware_version_show(struct seq_file *seqf, void *unused)\n{\n\tstruct aqc_data *priv = seqf->private;\n\n\tseq_printf(seqf, \"%u\\n\", priv->firmware_version);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(firmware_version);\n\nstatic int power_cycles_show(struct seq_file *seqf, void *unused)\n{\n\tstruct aqc_data *priv = seqf->private;\n\n\tseq_printf(seqf, \"%u\\n\", priv->power_cycles);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(power_cycles);\n\nstatic void aqc_debugfs_init(struct aqc_data *priv)\n{\n\tchar name[64];\n\n\tscnprintf(name, sizeof(name), \"%s_%s-%s\", \"aquacomputer\", priv->name,\n\t\t  dev_name(&priv->hdev->dev));\n\n\tpriv->debugfs = debugfs_create_dir(name, NULL);\n\n\tif (priv->serial_number_start_offset != 0)\n\t\tdebugfs_create_file(\"serial_number\", 0444, priv->debugfs, priv,\n\t\t\t\t    &serial_number_fops);\n\tif (priv->firmware_version_offset != 0)\n\t\tdebugfs_create_file(\"firmware_version\", 0444, priv->debugfs, priv,\n\t\t\t\t    &firmware_version_fops);\n\tif (priv->power_cycle_count_offset != 0)\n\t\tdebugfs_create_file(\"power_cycles\", 0444, priv->debugfs, priv, &power_cycles_fops);\n}\n\n#else\n\nstatic void aqc_debugfs_init(struct aqc_data *priv)\n{\n}\n\n#endif\n\nstatic int aqc_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct aqc_data *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&hdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->hdev = hdev;\n\thid_set_drvdata(hdev, priv);\n\n\tpriv->updated = jiffies - STATUS_UPDATE_INTERVAL;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hid_hw_open(hdev);\n\tif (ret)\n\t\tgoto fail_and_stop;\n\n\tswitch (hdev->product) {\n\tcase USB_PRODUCT_ID_AQUAERO:\n\t\t \n\t\tif (hdev->collection[1].type != 0) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail_and_close;\n\t\t}\n\n\t\tpriv->kind = aquaero;\n\n\t\tpriv->num_fans = AQUAERO_NUM_FANS;\n\t\tpriv->fan_sensor_offsets = aquaero_sensor_fan_offsets;\n\t\tpriv->fan_ctrl_offsets = aquaero_ctrl_fan_offsets;\n\n\t\tpriv->num_temp_sensors = AQUAERO_NUM_SENSORS;\n\t\tpriv->temp_sensor_start_offset = AQUAERO_SENSOR_START;\n\t\tpriv->num_virtual_temp_sensors = AQUAERO_NUM_VIRTUAL_SENSORS;\n\t\tpriv->virtual_temp_sensor_start_offset = AQUAERO_VIRTUAL_SENSOR_START;\n\t\tpriv->num_calc_virt_temp_sensors = AQUAERO_NUM_CALC_VIRTUAL_SENSORS;\n\t\tpriv->calc_virt_temp_sensor_start_offset = AQUAERO_CALC_VIRTUAL_SENSOR_START;\n\t\tpriv->num_flow_sensors = AQUAERO_NUM_FLOW_SENSORS;\n\t\tpriv->flow_sensors_start_offset = AQUAERO_FLOW_SENSORS_START;\n\n\t\tpriv->buffer_size = AQUAERO_CTRL_REPORT_SIZE;\n\t\tpriv->temp_ctrl_offset = AQUAERO_TEMP_CTRL_OFFSET;\n\t\tpriv->ctrl_report_delay = CTRL_REPORT_DELAY;\n\n\t\tpriv->temp_label = label_temp_sensors;\n\t\tpriv->virtual_temp_label = label_virtual_temp_sensors;\n\t\tpriv->calc_virt_temp_label = label_aquaero_calc_temp_sensors;\n\t\tpriv->speed_label = label_aquaero_speeds;\n\t\tpriv->power_label = label_fan_power;\n\t\tpriv->voltage_label = label_fan_voltage;\n\t\tpriv->current_label = label_fan_current;\n\t\tbreak;\n\tcase USB_PRODUCT_ID_D5NEXT:\n\t\tpriv->kind = d5next;\n\n\t\tpriv->num_fans = D5NEXT_NUM_FANS;\n\t\tpriv->fan_sensor_offsets = d5next_sensor_fan_offsets;\n\t\tpriv->fan_ctrl_offsets = d5next_ctrl_fan_offsets;\n\n\t\tpriv->num_temp_sensors = D5NEXT_NUM_SENSORS;\n\t\tpriv->temp_sensor_start_offset = D5NEXT_COOLANT_TEMP;\n\t\tpriv->num_virtual_temp_sensors = D5NEXT_NUM_VIRTUAL_SENSORS;\n\t\tpriv->virtual_temp_sensor_start_offset = D5NEXT_VIRTUAL_SENSORS_START;\n\t\tpriv->temp_ctrl_offset = D5NEXT_TEMP_CTRL_OFFSET;\n\n\t\tpriv->buffer_size = D5NEXT_CTRL_REPORT_SIZE;\n\t\tpriv->ctrl_report_delay = CTRL_REPORT_DELAY;\n\n\t\tpriv->power_cycle_count_offset = D5NEXT_POWER_CYCLES;\n\n\t\tpriv->temp_label = label_d5next_temp;\n\t\tpriv->virtual_temp_label = label_virtual_temp_sensors;\n\t\tpriv->speed_label = label_d5next_speeds;\n\t\tpriv->power_label = label_d5next_power;\n\t\tpriv->voltage_label = label_d5next_voltages;\n\t\tpriv->current_label = label_d5next_current;\n\t\tbreak;\n\tcase USB_PRODUCT_ID_FARBWERK:\n\t\tpriv->kind = farbwerk;\n\n\t\tpriv->num_fans = 0;\n\n\t\tpriv->num_temp_sensors = FARBWERK_NUM_SENSORS;\n\t\tpriv->temp_sensor_start_offset = FARBWERK_SENSOR_START;\n\n\t\tpriv->temp_label = label_temp_sensors;\n\t\tbreak;\n\tcase USB_PRODUCT_ID_FARBWERK360:\n\t\tpriv->kind = farbwerk360;\n\n\t\tpriv->num_fans = 0;\n\n\t\tpriv->num_temp_sensors = FARBWERK360_NUM_SENSORS;\n\t\tpriv->temp_sensor_start_offset = FARBWERK360_SENSOR_START;\n\t\tpriv->num_virtual_temp_sensors = FARBWERK360_NUM_VIRTUAL_SENSORS;\n\t\tpriv->virtual_temp_sensor_start_offset = FARBWERK360_VIRTUAL_SENSORS_START;\n\t\tpriv->temp_ctrl_offset = FARBWERK360_TEMP_CTRL_OFFSET;\n\n\t\tpriv->buffer_size = FARBWERK360_CTRL_REPORT_SIZE;\n\n\t\tpriv->temp_label = label_temp_sensors;\n\t\tpriv->virtual_temp_label = label_virtual_temp_sensors;\n\t\tbreak;\n\tcase USB_PRODUCT_ID_OCTO:\n\t\tpriv->kind = octo;\n\n\t\tpriv->num_fans = OCTO_NUM_FANS;\n\t\tpriv->fan_sensor_offsets = octo_sensor_fan_offsets;\n\t\tpriv->fan_ctrl_offsets = octo_ctrl_fan_offsets;\n\n\t\tpriv->num_temp_sensors = OCTO_NUM_SENSORS;\n\t\tpriv->temp_sensor_start_offset = OCTO_SENSOR_START;\n\t\tpriv->num_virtual_temp_sensors = OCTO_NUM_VIRTUAL_SENSORS;\n\t\tpriv->virtual_temp_sensor_start_offset = OCTO_VIRTUAL_SENSORS_START;\n\t\tpriv->temp_ctrl_offset = OCTO_TEMP_CTRL_OFFSET;\n\n\t\tpriv->buffer_size = OCTO_CTRL_REPORT_SIZE;\n\t\tpriv->ctrl_report_delay = CTRL_REPORT_DELAY;\n\n\t\tpriv->power_cycle_count_offset = OCTO_POWER_CYCLES;\n\n\t\tpriv->temp_label = label_temp_sensors;\n\t\tpriv->virtual_temp_label = label_virtual_temp_sensors;\n\t\tpriv->speed_label = label_fan_speed;\n\t\tpriv->power_label = label_fan_power;\n\t\tpriv->voltage_label = label_fan_voltage;\n\t\tpriv->current_label = label_fan_current;\n\t\tbreak;\n\tcase USB_PRODUCT_ID_QUADRO:\n\t\tpriv->kind = quadro;\n\n\t\tpriv->num_fans = QUADRO_NUM_FANS;\n\t\tpriv->fan_sensor_offsets = quadro_sensor_fan_offsets;\n\t\tpriv->fan_ctrl_offsets = quadro_ctrl_fan_offsets;\n\n\t\tpriv->num_temp_sensors = QUADRO_NUM_SENSORS;\n\t\tpriv->temp_sensor_start_offset = QUADRO_SENSOR_START;\n\t\tpriv->num_virtual_temp_sensors = QUADRO_NUM_VIRTUAL_SENSORS;\n\t\tpriv->virtual_temp_sensor_start_offset = QUADRO_VIRTUAL_SENSORS_START;\n\t\tpriv->num_flow_sensors = QUADRO_NUM_FLOW_SENSORS;\n\t\tpriv->flow_sensors_start_offset = QUADRO_FLOW_SENSOR_OFFSET;\n\n\t\tpriv->temp_ctrl_offset = QUADRO_TEMP_CTRL_OFFSET;\n\n\t\tpriv->buffer_size = QUADRO_CTRL_REPORT_SIZE;\n\t\tpriv->ctrl_report_delay = CTRL_REPORT_DELAY;\n\n\t\tpriv->flow_pulses_ctrl_offset = QUADRO_FLOW_PULSES_CTRL_OFFSET;\n\t\tpriv->power_cycle_count_offset = QUADRO_POWER_CYCLES;\n\n\t\tpriv->temp_label = label_temp_sensors;\n\t\tpriv->virtual_temp_label = label_virtual_temp_sensors;\n\t\tpriv->speed_label = label_quadro_speeds;\n\t\tpriv->power_label = label_fan_power;\n\t\tpriv->voltage_label = label_fan_voltage;\n\t\tpriv->current_label = label_fan_current;\n\t\tbreak;\n\tcase USB_PRODUCT_ID_HIGHFLOWNEXT:\n\t\tpriv->kind = highflownext;\n\n\t\tpriv->num_fans = 0;\n\n\t\tpriv->num_temp_sensors = HIGHFLOWNEXT_NUM_SENSORS;\n\t\tpriv->temp_sensor_start_offset = HIGHFLOWNEXT_SENSOR_START;\n\t\tpriv->num_flow_sensors = HIGHFLOWNEXT_NUM_FLOW_SENSORS;\n\t\tpriv->flow_sensors_start_offset = HIGHFLOWNEXT_FLOW;\n\n\t\tpriv->power_cycle_count_offset = QUADRO_POWER_CYCLES;\n\n\t\tpriv->temp_label = label_highflownext_temp_sensors;\n\t\tpriv->speed_label = label_highflownext_fan_speed;\n\t\tpriv->power_label = label_highflownext_power;\n\t\tpriv->voltage_label = label_highflownext_voltage;\n\t\tbreak;\n\tcase USB_PRODUCT_ID_LEAKSHIELD:\n\t\t \n\t\tif (hdev->type != 2) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail_and_close;\n\t\t}\n\n\t\tpriv->kind = leakshield;\n\n\t\tpriv->num_fans = 0;\n\t\tpriv->num_temp_sensors = LEAKSHIELD_NUM_SENSORS;\n\t\tpriv->temp_sensor_start_offset = LEAKSHIELD_TEMPERATURE_1;\n\n\t\tpriv->temp_label = label_leakshield_temp_sensors;\n\t\tpriv->speed_label = label_leakshield_fan_speed;\n\t\tbreak;\n\tcase USB_PRODUCT_ID_AQUASTREAMXT:\n\t\tpriv->kind = aquastreamxt;\n\n\t\tpriv->num_fans = AQUASTREAMXT_NUM_FANS;\n\t\tpriv->fan_sensor_offsets = aquastreamxt_sensor_fan_offsets;\n\n\t\tpriv->num_temp_sensors = AQUASTREAMXT_NUM_SENSORS;\n\t\tpriv->temp_sensor_start_offset = AQUASTREAMXT_SENSOR_START;\n\t\tpriv->buffer_size = AQUASTREAMXT_SENSOR_REPORT_SIZE;\n\n\t\tpriv->temp_label = label_aquastreamxt_temp_sensors;\n\t\tpriv->speed_label = label_d5next_speeds;\n\t\tpriv->voltage_label = label_d5next_voltages;\n\t\tpriv->current_label = label_d5next_current;\n\t\tbreak;\n\tcase USB_PRODUCT_ID_AQUASTREAMULT:\n\t\tpriv->kind = aquastreamult;\n\n\t\tpriv->num_fans = AQUASTREAMULT_NUM_FANS;\n\t\tpriv->fan_sensor_offsets = aquastreamult_sensor_fan_offsets;\n\n\t\tpriv->num_temp_sensors = AQUASTREAMULT_NUM_SENSORS;\n\t\tpriv->temp_sensor_start_offset = AQUASTREAMULT_SENSOR_START;\n\n\t\tpriv->temp_label = label_aquastreamult_temp;\n\t\tpriv->speed_label = label_aquastreamult_speeds;\n\t\tpriv->power_label = label_aquastreamult_power;\n\t\tpriv->voltage_label = label_aquastreamult_voltages;\n\t\tpriv->current_label = label_aquastreamult_current;\n\t\tbreak;\n\tcase USB_PRODUCT_ID_POWERADJUST3:\n\t\tpriv->kind = poweradjust3;\n\n\t\tpriv->num_fans = 0;\n\n\t\tpriv->num_temp_sensors = POWERADJUST3_NUM_SENSORS;\n\t\tpriv->temp_sensor_start_offset = POWERADJUST3_SENSOR_START;\n\t\tpriv->buffer_size = POWERADJUST3_SENSOR_REPORT_SIZE;\n\n\t\tpriv->temp_label = label_poweradjust3_temp_sensors;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (priv->kind) {\n\tcase aquaero:\n\t\tpriv->serial_number_start_offset = AQUAERO_SERIAL_START;\n\t\tpriv->firmware_version_offset = AQUAERO_FIRMWARE_VERSION;\n\n\t\tpriv->fan_structure = &aqc_aquaero_fan_structure;\n\n\t\tpriv->ctrl_report_id = AQUAERO_CTRL_REPORT_ID;\n\t\tpriv->secondary_ctrl_report_id = AQUAERO_SECONDARY_CTRL_REPORT_ID;\n\t\tpriv->secondary_ctrl_report_size = AQUAERO_SECONDARY_CTRL_REPORT_SIZE;\n\t\tpriv->secondary_ctrl_report = aquaero_secondary_ctrl_report;\n\t\tbreak;\n\tcase poweradjust3:\n\t\tpriv->status_report_id = POWERADJUST3_STATUS_REPORT_ID;\n\t\tbreak;\n\tcase aquastreamxt:\n\t\tpriv->serial_number_start_offset = AQUASTREAMXT_SERIAL_START;\n\t\tpriv->firmware_version_offset = AQUASTREAMXT_FIRMWARE_VERSION;\n\n\t\tpriv->status_report_id = AQUASTREAMXT_STATUS_REPORT_ID;\n\t\tbreak;\n\tdefault:\n\t\tpriv->serial_number_start_offset = AQC_SERIAL_START;\n\t\tpriv->firmware_version_offset = AQC_FIRMWARE_VERSION;\n\n\t\tpriv->ctrl_report_id = CTRL_REPORT_ID;\n\t\tpriv->secondary_ctrl_report_id = SECONDARY_CTRL_REPORT_ID;\n\t\tpriv->secondary_ctrl_report_size = SECONDARY_CTRL_REPORT_SIZE;\n\t\tpriv->secondary_ctrl_report = secondary_ctrl_report;\n\n\t\tif (priv->kind == aquastreamult)\n\t\t\tpriv->fan_structure = &aqc_aquastreamult_fan_structure;\n\t\telse\n\t\t\tpriv->fan_structure = &aqc_general_fan_structure;\n\t\tbreak;\n\t}\n\n\tif (priv->buffer_size != 0) {\n\t\tpriv->checksum_start = 0x01;\n\t\tpriv->checksum_length = priv->buffer_size - 3;\n\t\tpriv->checksum_offset = priv->buffer_size - 2;\n\t}\n\n\tpriv->name = aqc_device_names[priv->kind];\n\n\tpriv->buffer = devm_kzalloc(&hdev->dev, priv->buffer_size, GFP_KERNEL);\n\tif (!priv->buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_and_close;\n\t}\n\n\tmutex_init(&priv->mutex);\n\n\tpriv->hwmon_dev = hwmon_device_register_with_info(&hdev->dev, priv->name, priv,\n\t\t\t\t\t\t\t  &aqc_chip_info, NULL);\n\n\tif (IS_ERR(priv->hwmon_dev)) {\n\t\tret = PTR_ERR(priv->hwmon_dev);\n\t\tgoto fail_and_close;\n\t}\n\n\taqc_debugfs_init(priv);\n\n\treturn 0;\n\nfail_and_close:\n\thid_hw_close(hdev);\nfail_and_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void aqc_remove(struct hid_device *hdev)\n{\n\tstruct aqc_data *priv = hid_get_drvdata(hdev);\n\n\tdebugfs_remove_recursive(priv->debugfs);\n\thwmon_device_unregister(priv->hwmon_dev);\n\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic const struct hid_device_id aqc_table[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AQUACOMPUTER, USB_PRODUCT_ID_AQUAERO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AQUACOMPUTER, USB_PRODUCT_ID_D5NEXT) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AQUACOMPUTER, USB_PRODUCT_ID_FARBWERK) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AQUACOMPUTER, USB_PRODUCT_ID_FARBWERK360) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AQUACOMPUTER, USB_PRODUCT_ID_OCTO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AQUACOMPUTER, USB_PRODUCT_ID_QUADRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AQUACOMPUTER, USB_PRODUCT_ID_HIGHFLOWNEXT) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AQUACOMPUTER, USB_PRODUCT_ID_LEAKSHIELD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AQUACOMPUTER, USB_PRODUCT_ID_AQUASTREAMXT) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AQUACOMPUTER, USB_PRODUCT_ID_AQUASTREAMULT) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AQUACOMPUTER, USB_PRODUCT_ID_POWERADJUST3) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(hid, aqc_table);\n\nstatic struct hid_driver aqc_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = aqc_table,\n\t.probe = aqc_probe,\n\t.remove = aqc_remove,\n\t.raw_event = aqc_raw_event,\n};\n\nstatic int __init aqc_init(void)\n{\n\treturn hid_register_driver(&aqc_driver);\n}\n\nstatic void __exit aqc_exit(void)\n{\n\thid_unregister_driver(&aqc_driver);\n}\n\n \nlate_initcall(aqc_init);\nmodule_exit(aqc_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Aleksa Savic <savicaleksa83@gmail.com>\");\nMODULE_AUTHOR(\"Jack Doan <me@jackdoan.com>\");\nMODULE_DESCRIPTION(\"Hwmon driver for Aquacomputer devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}