{
  "module_name": "mcp3021.c",
  "hash_id": "9a64e994d483c746d78675340a1388c5f091ebdf22d712b235b3cd1f1cd06be2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/mcp3021.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/hwmon.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/of.h>\n\n \n#define MCP3021_VDD_REF_MAX\t5500\n#define MCP3021_VDD_REF_MIN\t2700\n#define MCP3021_VDD_REF_DEFAULT\t3300\n\n \n#define MCP3021_SAR_SHIFT\t2\n#define MCP3021_SAR_MASK\t0x3ff\n#define MCP3021_OUTPUT_RES\t10\t \n\n#define MCP3221_SAR_SHIFT\t0\n#define MCP3221_SAR_MASK\t0xfff\n#define MCP3221_OUTPUT_RES\t12\t \n\nenum chips {\n\tmcp3021,\n\tmcp3221\n};\n\n \nstruct mcp3021_data {\n\tstruct i2c_client *client;\n\tu32 vdd;         \n\tu16 sar_shift;\n\tu16 sar_mask;\n\tu8 output_res;\n};\n\nstatic inline u16 volts_from_reg(struct mcp3021_data *data, u16 val)\n{\n\treturn DIV_ROUND_CLOSEST(data->vdd * val, 1 << data->output_res);\n}\n\nstatic int mcp3021_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct mcp3021_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\t__be16 buf;\n\tu16 reg;\n\tint ret;\n\n\tif (type != hwmon_in)\n\t\treturn -EOPNOTSUPP;\n\n\tret = i2c_master_recv(client, (char *)&buf, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != 2)\n\t\treturn -EIO;\n\n\t \n\treg = be16_to_cpu(buf);\n\n\t \n\treg = (reg >> data->sar_shift) & data->sar_mask;\n\n\t*val = volts_from_reg(data, reg);\n\n\treturn 0;\n}\n\nstatic umode_t mcp3021_is_visible(const void *_data,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tif (type != hwmon_in)\n\t\treturn 0;\n\n\tif (attr != hwmon_in_input)\n\t\treturn 0;\n\n\treturn 0444;\n}\n\nstatic const struct hwmon_channel_info * const mcp3021_info[] = {\n\tHWMON_CHANNEL_INFO(in, HWMON_I_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops mcp3021_hwmon_ops = {\n\t.is_visible = mcp3021_is_visible,\n\t.read = mcp3021_read,\n};\n\nstatic const struct hwmon_chip_info mcp3021_chip_info = {\n\t.ops = &mcp3021_hwmon_ops,\n\t.info = mcp3021_info,\n};\n\nstatic const struct i2c_device_id mcp3021_id[];\n\nstatic int mcp3021_probe(struct i2c_client *client)\n{\n\tstruct mcp3021_data *data = NULL;\n\tstruct device_node *np = client->dev.of_node;\n\tstruct device *hwmon_dev;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct mcp3021_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\n\tif (np) {\n\t\tif (!of_property_read_u32(np, \"reference-voltage-microvolt\",\n\t\t\t\t\t  &data->vdd))\n\t\t\tdata->vdd /= 1000;\n\t\telse\n\t\t\tdata->vdd = MCP3021_VDD_REF_DEFAULT;\n\t} else {\n\t\tu32 *pdata = dev_get_platdata(&client->dev);\n\n\t\tif (pdata)\n\t\t\tdata->vdd = *pdata;\n\t\telse\n\t\t\tdata->vdd = MCP3021_VDD_REF_DEFAULT;\n\t}\n\n\tswitch (i2c_match_id(mcp3021_id, client)->driver_data) {\n\tcase mcp3021:\n\t\tdata->sar_shift = MCP3021_SAR_SHIFT;\n\t\tdata->sar_mask = MCP3021_SAR_MASK;\n\t\tdata->output_res = MCP3021_OUTPUT_RES;\n\t\tbreak;\n\n\tcase mcp3221:\n\t\tdata->sar_shift = MCP3221_SAR_SHIFT;\n\t\tdata->sar_mask = MCP3221_SAR_MASK;\n\t\tdata->output_res = MCP3221_OUTPUT_RES;\n\t\tbreak;\n\t}\n\n\tdata->client = client;\n\n\tif (data->vdd > MCP3021_VDD_REF_MAX || data->vdd < MCP3021_VDD_REF_MIN)\n\t\treturn -EINVAL;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&client->dev,\n\t\t\t\t\t\t\t client->name,\n\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t &mcp3021_chip_info,\n\t\t\t\t\t\t\t NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct i2c_device_id mcp3021_id[] = {\n\t{ \"mcp3021\", mcp3021 },\n\t{ \"mcp3221\", mcp3221 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mcp3021_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_mcp3021_match[] = {\n\t{ .compatible = \"microchip,mcp3021\", .data = (void *)mcp3021 },\n\t{ .compatible = \"microchip,mcp3221\", .data = (void *)mcp3221 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, of_mcp3021_match);\n#endif\n\nstatic struct i2c_driver mcp3021_driver = {\n\t.driver = {\n\t\t.name = \"mcp3021\",\n\t\t.of_match_table = of_match_ptr(of_mcp3021_match),\n\t},\n\t.probe = mcp3021_probe,\n\t.id_table = mcp3021_id,\n};\n\nmodule_i2c_driver(mcp3021_driver);\n\nMODULE_AUTHOR(\"Mingkai Hu <Mingkai.hu@freescale.com>\");\nMODULE_DESCRIPTION(\"Microchip MCP3021/MCP3221 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}