{
  "module_name": "lm83.c",
  "hash_id": "ab2091d634934faccc55452a62f64a55b2e5b9d6027be47cbbf6a2de9a86a37e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwmon/lm83.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/hwmon.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \n\nstatic const unsigned short normal_i2c[] = {\n\t0x18, 0x19, 0x1a, 0x29, 0x2a, 0x2b, 0x4c, 0x4d, 0x4e, I2C_CLIENT_END };\n\nenum chips { lm83, lm82 };\n\n \n\n#define LM83_REG_R_MAN_ID\t\t0xFE\n#define LM83_REG_R_CHIP_ID\t\t0xFF\n#define LM83_REG_R_CONFIG\t\t0x03\n#define LM83_REG_W_CONFIG\t\t0x09\n#define LM83_REG_R_STATUS1\t\t0x02\n#define LM83_REG_R_STATUS2\t\t0x35\n#define LM83_REG_R_LOCAL_TEMP\t\t0x00\n#define LM83_REG_R_LOCAL_HIGH\t\t0x05\n#define LM83_REG_W_LOCAL_HIGH\t\t0x0B\n#define LM83_REG_R_REMOTE1_TEMP\t\t0x30\n#define LM83_REG_R_REMOTE1_HIGH\t\t0x38\n#define LM83_REG_W_REMOTE1_HIGH\t\t0x50\n#define LM83_REG_R_REMOTE2_TEMP\t\t0x01\n#define LM83_REG_R_REMOTE2_HIGH\t\t0x07\n#define LM83_REG_W_REMOTE2_HIGH\t\t0x0D\n#define LM83_REG_R_REMOTE3_TEMP\t\t0x31\n#define LM83_REG_R_REMOTE3_HIGH\t\t0x3A\n#define LM83_REG_W_REMOTE3_HIGH\t\t0x52\n#define LM83_REG_R_TCRIT\t\t0x42\n#define LM83_REG_W_TCRIT\t\t0x5A\n\nstatic const u8 LM83_REG_TEMP[] = {\n\tLM83_REG_R_LOCAL_TEMP,\n\tLM83_REG_R_REMOTE1_TEMP,\n\tLM83_REG_R_REMOTE2_TEMP,\n\tLM83_REG_R_REMOTE3_TEMP,\n};\n\nstatic const u8 LM83_REG_MAX[] = {\n\tLM83_REG_R_LOCAL_HIGH,\n\tLM83_REG_R_REMOTE1_HIGH,\n\tLM83_REG_R_REMOTE2_HIGH,\n\tLM83_REG_R_REMOTE3_HIGH,\n};\n\n \nstatic const u8 LM83_ALARM_REG[] = {\n\tLM83_REG_R_STATUS1, LM83_REG_R_STATUS2, LM83_REG_R_STATUS1, LM83_REG_R_STATUS2\n};\n\nstatic const u8 LM83_MAX_ALARM_BIT[] = {\n\tBIT(6), BIT(7), BIT(4), BIT(4)\n};\n\nstatic const u8 LM83_CRIT_ALARM_BIT[] = {\n\tBIT(0), BIT(0), BIT(1), BIT(1)\n};\n\nstatic const u8 LM83_FAULT_BIT[] = {\n\t0, BIT(5), BIT(2), BIT(2)\n};\n\n \n\nstruct lm83_data {\n\tstruct regmap *regmap;\n\tenum chips type;\n};\n\n \n\nstatic int lm83_regmap_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct i2c_client *client = context;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\treturn 0;\n}\n\n \nstatic int lm83_regmap_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct i2c_client *client = context;\n\n\tswitch (reg) {\n\tcase LM83_REG_R_CONFIG:\n\tcase LM83_REG_R_LOCAL_HIGH:\n\tcase LM83_REG_R_REMOTE2_HIGH:\n\t\treg += 0x06;\n\t\tbreak;\n\tcase LM83_REG_R_REMOTE1_HIGH:\n\tcase LM83_REG_R_REMOTE3_HIGH:\n\tcase LM83_REG_R_TCRIT:\n\t\treg += 0x18;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn i2c_smbus_write_byte_data(client, reg, val);\n}\n\nstatic bool lm83_regmap_is_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LM83_REG_R_LOCAL_TEMP:\n\tcase LM83_REG_R_REMOTE1_TEMP:\n\tcase LM83_REG_R_REMOTE2_TEMP:\n\tcase LM83_REG_R_REMOTE3_TEMP:\n\tcase LM83_REG_R_STATUS1:\n\tcase LM83_REG_R_STATUS2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config lm83_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = lm83_regmap_is_volatile,\n\t.reg_read = lm83_regmap_reg_read,\n\t.reg_write = lm83_regmap_reg_write,\n};\n\n \n\nstatic int lm83_temp_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct lm83_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\terr = regmap_read(data->regmap, LM83_REG_TEMP[channel], &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = (s8)regval * 1000;\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\terr = regmap_read(data->regmap, LM83_REG_MAX[channel], &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = (s8)regval * 1000;\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\terr = regmap_read(data->regmap, LM83_REG_R_TCRIT, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = (s8)regval * 1000;\n\t\tbreak;\n\tcase hwmon_temp_max_alarm:\n\t\terr = regmap_read(data->regmap, LM83_ALARM_REG[channel], &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = !!(regval & LM83_MAX_ALARM_BIT[channel]);\n\t\tbreak;\n\tcase hwmon_temp_crit_alarm:\n\t\terr = regmap_read(data->regmap, LM83_ALARM_REG[channel], &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = !!(regval & LM83_CRIT_ALARM_BIT[channel]);\n\t\tbreak;\n\tcase hwmon_temp_fault:\n\t\terr = regmap_read(data->regmap, LM83_ALARM_REG[channel], &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = !!(regval & LM83_FAULT_BIT[channel]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int lm83_temp_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct lm83_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err;\n\n\tregval = DIV_ROUND_CLOSEST(clamp_val(val, -128000, 127000), 1000);\n\n\tswitch (attr) {\n\tcase hwmon_temp_max:\n\t\terr = regmap_write(data->regmap, LM83_REG_MAX[channel], regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\terr = regmap_write(data->regmap, LM83_REG_R_TCRIT, regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int lm83_chip_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct lm83_data *data = dev_get_drvdata(dev);\n\tunsigned int regval;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_chip_alarms:\n\t\terr = regmap_read(data->regmap, LM83_REG_R_STATUS1, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = regval;\n\t\terr = regmap_read(data->regmap, LM83_REG_R_STATUS2, &regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val |= regval << 8;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int lm83_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t     u32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn lm83_chip_read(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn lm83_temp_read(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lm83_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t      u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn lm83_temp_write(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t lm83_is_visible(const void *_data, enum hwmon_sensor_types type,\n\t\t\t       u32 attr, int channel)\n{\n\tconst struct lm83_data *data = _data;\n\n\t \n\tif (data->type == lm82 && (channel == 1 || channel == 3))\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\tif (attr == hwmon_chip_alarms)\n\t\t\treturn 0444;\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_max_alarm:\n\t\tcase hwmon_temp_crit_alarm:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_fault:\n\t\t\tif (channel)\n\t\t\t\treturn 0444;\n\t\t\tbreak;\n\t\tcase hwmon_temp_max:\n\t\t\treturn 0644;\n\t\tcase hwmon_temp_crit:\n\t\t\tif (channel == 2)\n\t\t\t\treturn 0644;\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const lm83_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_ALARMS),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |\n\t\t\t   HWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |\n\t\t\t   HWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |\n\t\t\t   HWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM | HWMON_T_FAULT,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |\n\t\t\t   HWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM | HWMON_T_FAULT\n\t\t\t   ),\n\tNULL\n};\n\nstatic const struct hwmon_ops lm83_hwmon_ops = {\n\t.is_visible = lm83_is_visible,\n\t.read = lm83_read,\n\t.write = lm83_write,\n};\n\nstatic const struct hwmon_chip_info lm83_chip_info = {\n\t.ops = &lm83_hwmon_ops,\n\t.info = lm83_info,\n};\n\n \nstatic int lm83_detect(struct i2c_client *client,\n\t\t       struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tconst char *name;\n\tu8 man_id, chip_id;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\tif ((i2c_smbus_read_byte_data(client, LM83_REG_R_STATUS1) & 0xA8) ||\n\t    (i2c_smbus_read_byte_data(client, LM83_REG_R_STATUS2) & 0x48) ||\n\t    (i2c_smbus_read_byte_data(client, LM83_REG_R_CONFIG) & 0x41)) {\n\t\tdev_dbg(&adapter->dev, \"LM83 detection failed at 0x%02x\\n\",\n\t\t\tclient->addr);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tman_id = i2c_smbus_read_byte_data(client, LM83_REG_R_MAN_ID);\n\tif (man_id != 0x01)\t \n\t\treturn -ENODEV;\n\n\tchip_id = i2c_smbus_read_byte_data(client, LM83_REG_R_CHIP_ID);\n\tswitch (chip_id) {\n\tcase 0x03:\n\t\t \n\t\tname = \"lm83\";\n\t\tbreak;\n\tcase 0x01:\n\t\tname = \"lm82\";\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"Unsupported chip (man_id=0x%02X, chip_id=0x%02X)\\n\",\n\t\t\tman_id, chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(info->type, name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id lm83_id[] = {\n\t{ \"lm83\", lm83 },\n\t{ \"lm82\", lm82 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm83_id);\n\nstatic int lm83_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device *hwmon_dev;\n\tstruct lm83_data *data;\n\n\tdata = devm_kzalloc(dev, sizeof(struct lm83_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = devm_regmap_init(dev, NULL, client, &lm83_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\tdata->type = i2c_match_id(lm83_id, client)->driver_data;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\n\t\t\t\t\t\t\t data, &lm83_chip_info, NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\n \n\nstatic struct i2c_driver lm83_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"lm83\",\n\t},\n\t.probe\t\t= lm83_probe,\n\t.id_table\t= lm83_id,\n\t.detect\t\t= lm83_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(lm83_driver);\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"LM83 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}