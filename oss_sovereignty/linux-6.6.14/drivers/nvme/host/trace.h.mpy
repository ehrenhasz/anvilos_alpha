{
  "module_name": "trace.h",
  "hash_id": "7c14e7716559b95344f71c3d2e77e32628d7b1490f29ecf35b475bf6ddc865ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/host/trace.h",
  "human_readable_source": " \n \n\n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM nvme\n\n#if !defined(_TRACE_NVME_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_NVME_H\n\n#include <linux/nvme.h>\n#include <linux/tracepoint.h>\n#include <linux/trace_seq.h>\n\n#include \"nvme.h\"\n\nconst char *nvme_trace_parse_admin_cmd(struct trace_seq *p, u8 opcode,\n\t\tu8 *cdw10);\nconst char *nvme_trace_parse_nvm_cmd(struct trace_seq *p, u8 opcode,\n\t\tu8 *cdw10);\nconst char *nvme_trace_parse_fabrics_cmd(struct trace_seq *p, u8 fctype,\n\t\tu8 *spc);\n\n#define parse_nvme_cmd(qid, opcode, fctype, cdw10)\t\t\t\\\n\t((opcode) == nvme_fabrics_command ?\t\t\t\t\\\n\t nvme_trace_parse_fabrics_cmd(p, fctype, cdw10) :\t\t\\\n\t((qid) ?\t\t\t\t\t\t\t\\\n\t nvme_trace_parse_nvm_cmd(p, opcode, cdw10) :\t\t\t\\\n\t nvme_trace_parse_admin_cmd(p, opcode, cdw10)))\n\nconst char *nvme_trace_disk_name(struct trace_seq *p, char *name);\n#define __print_disk_name(name)\t\t\t\t\\\n\tnvme_trace_disk_name(p, name)\n\n#ifndef TRACE_HEADER_MULTI_READ\nstatic inline void __assign_disk_name(char *name, struct gendisk *disk)\n{\n\tif (disk)\n\t\tmemcpy(name, disk->disk_name, DISK_NAME_LEN);\n\telse\n\t\tmemset(name, 0, DISK_NAME_LEN);\n}\n#endif\n\nTRACE_EVENT(nvme_setup_cmd,\n\t    TP_PROTO(struct request *req, struct nvme_command *cmd),\n\t    TP_ARGS(req, cmd),\n\t    TP_STRUCT__entry(\n\t\t__array(char, disk, DISK_NAME_LEN)\n\t\t__field(int, ctrl_id)\n\t\t__field(int, qid)\n\t\t__field(u8, opcode)\n\t\t__field(u8, flags)\n\t\t__field(u8, fctype)\n\t\t__field(u16, cid)\n\t\t__field(u32, nsid)\n\t\t__field(bool, metadata)\n\t\t__array(u8, cdw10, 24)\n\t    ),\n\t    TP_fast_assign(\n\t\t__entry->ctrl_id = nvme_req(req)->ctrl->instance;\n\t\t__entry->qid = nvme_req_qid(req);\n\t\t__entry->opcode = cmd->common.opcode;\n\t\t__entry->flags = cmd->common.flags;\n\t\t__entry->cid = cmd->common.command_id;\n\t\t__entry->nsid = le32_to_cpu(cmd->common.nsid);\n\t\t__entry->metadata = !!blk_integrity_rq(req);\n\t\t__entry->fctype = cmd->fabrics.fctype;\n\t\t__assign_disk_name(__entry->disk, req->q->disk);\n\t\tmemcpy(__entry->cdw10, &cmd->common.cdws,\n\t\t\tsizeof(__entry->cdw10));\n\t    ),\n\t    TP_printk(\"nvme%d: %sqid=%d, cmdid=%u, nsid=%u, flags=0x%x, meta=0x%x, cmd=(%s %s)\",\n\t\t      __entry->ctrl_id, __print_disk_name(__entry->disk),\n\t\t      __entry->qid, __entry->cid, __entry->nsid,\n\t\t      __entry->flags, __entry->metadata,\n\t\t      show_opcode_name(__entry->qid, __entry->opcode,\n\t\t\t\t__entry->fctype),\n\t\t      parse_nvme_cmd(__entry->qid, __entry->opcode,\n\t\t\t\t__entry->fctype, __entry->cdw10))\n);\n\nTRACE_EVENT(nvme_complete_rq,\n\t    TP_PROTO(struct request *req),\n\t    TP_ARGS(req),\n\t    TP_STRUCT__entry(\n\t\t__array(char, disk, DISK_NAME_LEN)\n\t\t__field(int, ctrl_id)\n\t\t__field(int, qid)\n\t\t__field(int, cid)\n\t\t__field(u64, result)\n\t\t__field(u8, retries)\n\t\t__field(u8, flags)\n\t\t__field(u16, status)\n\t    ),\n\t    TP_fast_assign(\n\t\t__entry->ctrl_id = nvme_req(req)->ctrl->instance;\n\t\t__entry->qid = nvme_req_qid(req);\n\t\t__entry->cid = nvme_req(req)->cmd->common.command_id;\n\t\t__entry->result = le64_to_cpu(nvme_req(req)->result.u64);\n\t\t__entry->retries = nvme_req(req)->retries;\n\t\t__entry->flags = nvme_req(req)->flags;\n\t\t__entry->status = nvme_req(req)->status;\n\t\t__assign_disk_name(__entry->disk, req->q->disk);\n\t    ),\n\t    TP_printk(\"nvme%d: %sqid=%d, cmdid=%u, res=%#llx, retries=%u, flags=0x%x, status=%#x\",\n\t\t      __entry->ctrl_id, __print_disk_name(__entry->disk),\n\t\t      __entry->qid, __entry->cid, __entry->result,\n\t\t      __entry->retries, __entry->flags, __entry->status)\n\n);\n\n#define aer_name(aer) { aer, #aer }\n\nTRACE_EVENT(nvme_async_event,\n\tTP_PROTO(struct nvme_ctrl *ctrl, u32 result),\n\tTP_ARGS(ctrl, result),\n\tTP_STRUCT__entry(\n\t\t__field(int, ctrl_id)\n\t\t__field(u32, result)\n\t),\n\tTP_fast_assign(\n\t\t__entry->ctrl_id = ctrl->instance;\n\t\t__entry->result = result;\n\t),\n\tTP_printk(\"nvme%d: NVME_AEN=%#08x [%s]\",\n\t\t__entry->ctrl_id, __entry->result,\n\t\t__print_symbolic(__entry->result & 0x7,\n\t\t\taer_name(NVME_AER_ERROR),\n\t\t\taer_name(NVME_AER_SMART),\n\t\t\taer_name(NVME_AER_NOTICE),\n\t\t\taer_name(NVME_AER_CSS),\n\t\t\taer_name(NVME_AER_VS))\n\t)\n);\n\n#undef aer_name\n\nTRACE_EVENT(nvme_sq,\n\tTP_PROTO(struct request *req, __le16 sq_head, int sq_tail),\n\tTP_ARGS(req, sq_head, sq_tail),\n\tTP_STRUCT__entry(\n\t\t__field(int, ctrl_id)\n\t\t__array(char, disk, DISK_NAME_LEN)\n\t\t__field(int, qid)\n\t\t__field(u16, sq_head)\n\t\t__field(u16, sq_tail)\n\t),\n\tTP_fast_assign(\n\t\t__entry->ctrl_id = nvme_req(req)->ctrl->instance;\n\t\t__assign_disk_name(__entry->disk, req->q->disk);\n\t\t__entry->qid = nvme_req_qid(req);\n\t\t__entry->sq_head = le16_to_cpu(sq_head);\n\t\t__entry->sq_tail = sq_tail;\n\t),\n\tTP_printk(\"nvme%d: %sqid=%d, head=%u, tail=%u\",\n\t\t__entry->ctrl_id, __print_disk_name(__entry->disk),\n\t\t__entry->qid, __entry->sq_head, __entry->sq_tail\n\t)\n);\n\n#endif  \n\n#undef TRACE_INCLUDE_PATH\n#define TRACE_INCLUDE_PATH .\n#undef TRACE_INCLUDE_FILE\n#define TRACE_INCLUDE_FILE trace\n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}