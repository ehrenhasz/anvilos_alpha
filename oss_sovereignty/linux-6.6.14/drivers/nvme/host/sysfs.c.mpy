{
  "module_name": "sysfs.c",
  "hash_id": "054a25fbad4028998d939806918dcfcd31930bcecf08ea5d36f50d602aa19191",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/host/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/nvme-auth.h>\n\n#include \"nvme.h\"\n#include \"fabrics.h\"\n\nstatic ssize_t nvme_sysfs_reset(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = nvme_reset_ctrl_sync(ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\nstatic DEVICE_ATTR(reset_controller, S_IWUSR, NULL, nvme_sysfs_reset);\n\nstatic ssize_t nvme_sysfs_rescan(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\n\tnvme_queue_scan(ctrl);\n\treturn count;\n}\nstatic DEVICE_ATTR(rescan_controller, S_IWUSR, NULL, nvme_sysfs_rescan);\n\nstatic inline struct nvme_ns_head *dev_to_ns_head(struct device *dev)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (disk->fops == &nvme_bdev_ops)\n\t\treturn nvme_get_ns_from_dev(dev)->head;\n\telse\n\t\treturn disk->private_data;\n}\n\nstatic ssize_t wwid_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct nvme_ns_head *head = dev_to_ns_head(dev);\n\tstruct nvme_ns_ids *ids = &head->ids;\n\tstruct nvme_subsystem *subsys = head->subsys;\n\tint serial_len = sizeof(subsys->serial);\n\tint model_len = sizeof(subsys->model);\n\n\tif (!uuid_is_null(&ids->uuid))\n\t\treturn sysfs_emit(buf, \"uuid.%pU\\n\", &ids->uuid);\n\n\tif (memchr_inv(ids->nguid, 0, sizeof(ids->nguid)))\n\t\treturn sysfs_emit(buf, \"eui.%16phN\\n\", ids->nguid);\n\n\tif (memchr_inv(ids->eui64, 0, sizeof(ids->eui64)))\n\t\treturn sysfs_emit(buf, \"eui.%8phN\\n\", ids->eui64);\n\n\twhile (serial_len > 0 && (subsys->serial[serial_len - 1] == ' ' ||\n\t\t\t\t  subsys->serial[serial_len - 1] == '\\0'))\n\t\tserial_len--;\n\twhile (model_len > 0 && (subsys->model[model_len - 1] == ' ' ||\n\t\t\t\t subsys->model[model_len - 1] == '\\0'))\n\t\tmodel_len--;\n\n\treturn sysfs_emit(buf, \"nvme.%04x-%*phN-%*phN-%08x\\n\", subsys->vendor_id,\n\t\tserial_len, subsys->serial, model_len, subsys->model,\n\t\thead->ns_id);\n}\nstatic DEVICE_ATTR_RO(wwid);\n\nstatic ssize_t nguid_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\treturn sysfs_emit(buf, \"%pU\\n\", dev_to_ns_head(dev)->ids.nguid);\n}\nstatic DEVICE_ATTR_RO(nguid);\n\nstatic ssize_t uuid_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct nvme_ns_ids *ids = &dev_to_ns_head(dev)->ids;\n\n\t \n\tif (uuid_is_null(&ids->uuid)) {\n\t\tdev_warn_once(dev,\n\t\t\t\"No UUID available providing old NGUID\\n\");\n\t\treturn sysfs_emit(buf, \"%pU\\n\", ids->nguid);\n\t}\n\treturn sysfs_emit(buf, \"%pU\\n\", &ids->uuid);\n}\nstatic DEVICE_ATTR_RO(uuid);\n\nstatic ssize_t eui_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\treturn sysfs_emit(buf, \"%8ph\\n\", dev_to_ns_head(dev)->ids.eui64);\n}\nstatic DEVICE_ATTR_RO(eui);\n\nstatic ssize_t nsid_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", dev_to_ns_head(dev)->ns_id);\n}\nstatic DEVICE_ATTR_RO(nsid);\n\nstatic struct attribute *nvme_ns_id_attrs[] = {\n\t&dev_attr_wwid.attr,\n\t&dev_attr_uuid.attr,\n\t&dev_attr_nguid.attr,\n\t&dev_attr_eui.attr,\n\t&dev_attr_nsid.attr,\n#ifdef CONFIG_NVME_MULTIPATH\n\t&dev_attr_ana_grpid.attr,\n\t&dev_attr_ana_state.attr,\n#endif\n\tNULL,\n};\n\nstatic umode_t nvme_ns_id_attrs_are_visible(struct kobject *kobj,\n\t\tstruct attribute *a, int n)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct nvme_ns_ids *ids = &dev_to_ns_head(dev)->ids;\n\n\tif (a == &dev_attr_uuid.attr) {\n\t\tif (uuid_is_null(&ids->uuid) &&\n\t\t    !memchr_inv(ids->nguid, 0, sizeof(ids->nguid)))\n\t\t\treturn 0;\n\t}\n\tif (a == &dev_attr_nguid.attr) {\n\t\tif (!memchr_inv(ids->nguid, 0, sizeof(ids->nguid)))\n\t\t\treturn 0;\n\t}\n\tif (a == &dev_attr_eui.attr) {\n\t\tif (!memchr_inv(ids->eui64, 0, sizeof(ids->eui64)))\n\t\t\treturn 0;\n\t}\n#ifdef CONFIG_NVME_MULTIPATH\n\tif (a == &dev_attr_ana_grpid.attr || a == &dev_attr_ana_state.attr) {\n\t\tif (dev_to_disk(dev)->fops != &nvme_bdev_ops)  \n\t\t\treturn 0;\n\t\tif (!nvme_ctrl_use_ana(nvme_get_ns_from_dev(dev)->ctrl))\n\t\t\treturn 0;\n\t}\n#endif\n\treturn a->mode;\n}\n\nstatic const struct attribute_group nvme_ns_id_attr_group = {\n\t.attrs\t\t= nvme_ns_id_attrs,\n\t.is_visible\t= nvme_ns_id_attrs_are_visible,\n};\n\nconst struct attribute_group *nvme_ns_id_attr_groups[] = {\n\t&nvme_ns_id_attr_group,\n\tNULL,\n};\n\n#define nvme_show_str_function(field)\t\t\t\t\t\t\\\nstatic ssize_t  field##_show(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n        struct nvme_ctrl *ctrl = dev_get_drvdata(dev);\t\t\t\t\\\n        return sysfs_emit(buf, \"%.*s\\n\",\t\t\t\t\t\\\n\t\t(int)sizeof(ctrl->subsys->field), ctrl->subsys->field);\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO, field##_show, NULL);\n\nnvme_show_str_function(model);\nnvme_show_str_function(serial);\nnvme_show_str_function(firmware_rev);\n\n#define nvme_show_int_function(field)\t\t\t\t\t\t\\\nstatic ssize_t  field##_show(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n        struct nvme_ctrl *ctrl = dev_get_drvdata(dev);\t\t\t\t\\\n        return sysfs_emit(buf, \"%d\\n\", ctrl->field);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO, field##_show, NULL);\n\nnvme_show_int_function(cntlid);\nnvme_show_int_function(numa_node);\nnvme_show_int_function(queue_count);\nnvme_show_int_function(sqsize);\nnvme_show_int_function(kato);\n\nstatic ssize_t nvme_sysfs_delete(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\n\tif (!test_bit(NVME_CTRL_STARTED_ONCE, &ctrl->flags))\n\t\treturn -EBUSY;\n\n\tif (device_remove_file_self(dev, attr))\n\t\tnvme_delete_ctrl_sync(ctrl);\n\treturn count;\n}\nstatic DEVICE_ATTR(delete_controller, S_IWUSR, NULL, nvme_sysfs_delete);\n\nstatic ssize_t nvme_sysfs_show_transport(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", ctrl->ops->name);\n}\nstatic DEVICE_ATTR(transport, S_IRUGO, nvme_sysfs_show_transport, NULL);\n\nstatic ssize_t nvme_sysfs_show_state(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\tstatic const char *const state_name[] = {\n\t\t[NVME_CTRL_NEW]\t\t= \"new\",\n\t\t[NVME_CTRL_LIVE]\t= \"live\",\n\t\t[NVME_CTRL_RESETTING]\t= \"resetting\",\n\t\t[NVME_CTRL_CONNECTING]\t= \"connecting\",\n\t\t[NVME_CTRL_DELETING]\t= \"deleting\",\n\t\t[NVME_CTRL_DELETING_NOIO]= \"deleting (no IO)\",\n\t\t[NVME_CTRL_DEAD]\t= \"dead\",\n\t};\n\n\tif ((unsigned)ctrl->state < ARRAY_SIZE(state_name) &&\n\t    state_name[ctrl->state])\n\t\treturn sysfs_emit(buf, \"%s\\n\", state_name[ctrl->state]);\n\n\treturn sysfs_emit(buf, \"unknown state\\n\");\n}\n\nstatic DEVICE_ATTR(state, S_IRUGO, nvme_sysfs_show_state, NULL);\n\nstatic ssize_t nvme_sysfs_show_subsysnqn(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", ctrl->subsys->subnqn);\n}\nstatic DEVICE_ATTR(subsysnqn, S_IRUGO, nvme_sysfs_show_subsysnqn, NULL);\n\nstatic ssize_t nvme_sysfs_show_hostnqn(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", ctrl->opts->host->nqn);\n}\nstatic DEVICE_ATTR(hostnqn, S_IRUGO, nvme_sysfs_show_hostnqn, NULL);\n\nstatic ssize_t nvme_sysfs_show_hostid(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%pU\\n\", &ctrl->opts->host->id);\n}\nstatic DEVICE_ATTR(hostid, S_IRUGO, nvme_sysfs_show_hostid, NULL);\n\nstatic ssize_t nvme_sysfs_show_address(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\n\treturn ctrl->ops->get_address(ctrl, buf, PAGE_SIZE);\n}\nstatic DEVICE_ATTR(address, S_IRUGO, nvme_sysfs_show_address, NULL);\n\nstatic ssize_t nvme_ctrl_loss_tmo_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\tstruct nvmf_ctrl_options *opts = ctrl->opts;\n\n\tif (ctrl->opts->max_reconnects == -1)\n\t\treturn sysfs_emit(buf, \"off\\n\");\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  opts->max_reconnects * opts->reconnect_delay);\n}\n\nstatic ssize_t nvme_ctrl_loss_tmo_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\tstruct nvmf_ctrl_options *opts = ctrl->opts;\n\tint ctrl_loss_tmo, err;\n\n\terr = kstrtoint(buf, 10, &ctrl_loss_tmo);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tif (ctrl_loss_tmo < 0)\n\t\topts->max_reconnects = -1;\n\telse\n\t\topts->max_reconnects = DIV_ROUND_UP(ctrl_loss_tmo,\n\t\t\t\t\t\topts->reconnect_delay);\n\treturn count;\n}\nstatic DEVICE_ATTR(ctrl_loss_tmo, S_IRUGO | S_IWUSR,\n\tnvme_ctrl_loss_tmo_show, nvme_ctrl_loss_tmo_store);\n\nstatic ssize_t nvme_ctrl_reconnect_delay_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\n\tif (ctrl->opts->reconnect_delay == -1)\n\t\treturn sysfs_emit(buf, \"off\\n\");\n\treturn sysfs_emit(buf, \"%d\\n\", ctrl->opts->reconnect_delay);\n}\n\nstatic ssize_t nvme_ctrl_reconnect_delay_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int v;\n\tint err;\n\n\terr = kstrtou32(buf, 10, &v);\n\tif (err)\n\t\treturn err;\n\n\tctrl->opts->reconnect_delay = v;\n\treturn count;\n}\nstatic DEVICE_ATTR(reconnect_delay, S_IRUGO | S_IWUSR,\n\tnvme_ctrl_reconnect_delay_show, nvme_ctrl_reconnect_delay_store);\n\nstatic ssize_t nvme_ctrl_fast_io_fail_tmo_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\n\tif (ctrl->opts->fast_io_fail_tmo == -1)\n\t\treturn sysfs_emit(buf, \"off\\n\");\n\treturn sysfs_emit(buf, \"%d\\n\", ctrl->opts->fast_io_fail_tmo);\n}\n\nstatic ssize_t nvme_ctrl_fast_io_fail_tmo_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\tstruct nvmf_ctrl_options *opts = ctrl->opts;\n\tint fast_io_fail_tmo, err;\n\n\terr = kstrtoint(buf, 10, &fast_io_fail_tmo);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tif (fast_io_fail_tmo < 0)\n\t\topts->fast_io_fail_tmo = -1;\n\telse\n\t\topts->fast_io_fail_tmo = fast_io_fail_tmo;\n\treturn count;\n}\nstatic DEVICE_ATTR(fast_io_fail_tmo, S_IRUGO | S_IWUSR,\n\tnvme_ctrl_fast_io_fail_tmo_show, nvme_ctrl_fast_io_fail_tmo_store);\n\nstatic ssize_t cntrltype_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstatic const char * const type[] = {\n\t\t[NVME_CTRL_IO] = \"io\\n\",\n\t\t[NVME_CTRL_DISC] = \"discovery\\n\",\n\t\t[NVME_CTRL_ADMIN] = \"admin\\n\",\n\t};\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\n\tif (ctrl->cntrltype > NVME_CTRL_ADMIN || !type[ctrl->cntrltype])\n\t\treturn sysfs_emit(buf, \"reserved\\n\");\n\n\treturn sysfs_emit(buf, type[ctrl->cntrltype]);\n}\nstatic DEVICE_ATTR_RO(cntrltype);\n\nstatic ssize_t dctype_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstatic const char * const type[] = {\n\t\t[NVME_DCTYPE_NOT_REPORTED] = \"none\\n\",\n\t\t[NVME_DCTYPE_DDC] = \"ddc\\n\",\n\t\t[NVME_DCTYPE_CDC] = \"cdc\\n\",\n\t};\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\n\tif (ctrl->dctype > NVME_DCTYPE_CDC || !type[ctrl->dctype])\n\t\treturn sysfs_emit(buf, \"reserved\\n\");\n\n\treturn sysfs_emit(buf, type[ctrl->dctype]);\n}\nstatic DEVICE_ATTR_RO(dctype);\n\n#ifdef CONFIG_NVME_AUTH\nstatic ssize_t nvme_ctrl_dhchap_secret_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\tstruct nvmf_ctrl_options *opts = ctrl->opts;\n\n\tif (!opts->dhchap_secret)\n\t\treturn sysfs_emit(buf, \"none\\n\");\n\treturn sysfs_emit(buf, \"%s\\n\", opts->dhchap_secret);\n}\n\nstatic ssize_t nvme_ctrl_dhchap_secret_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\tstruct nvmf_ctrl_options *opts = ctrl->opts;\n\tchar *dhchap_secret;\n\n\tif (!ctrl->opts->dhchap_secret)\n\t\treturn -EINVAL;\n\tif (count < 7)\n\t\treturn -EINVAL;\n\tif (memcmp(buf, \"DHHC-1:\", 7))\n\t\treturn -EINVAL;\n\n\tdhchap_secret = kzalloc(count + 1, GFP_KERNEL);\n\tif (!dhchap_secret)\n\t\treturn -ENOMEM;\n\tmemcpy(dhchap_secret, buf, count);\n\tnvme_auth_stop(ctrl);\n\tif (strcmp(dhchap_secret, opts->dhchap_secret)) {\n\t\tstruct nvme_dhchap_key *key, *host_key;\n\t\tint ret;\n\n\t\tret = nvme_auth_generate_key(dhchap_secret, &key);\n\t\tif (ret) {\n\t\t\tkfree(dhchap_secret);\n\t\t\treturn ret;\n\t\t}\n\t\tkfree(opts->dhchap_secret);\n\t\topts->dhchap_secret = dhchap_secret;\n\t\thost_key = ctrl->host_key;\n\t\tmutex_lock(&ctrl->dhchap_auth_mutex);\n\t\tctrl->host_key = key;\n\t\tmutex_unlock(&ctrl->dhchap_auth_mutex);\n\t\tnvme_auth_free_key(host_key);\n\t} else\n\t\tkfree(dhchap_secret);\n\t \n\tdev_info(ctrl->device, \"re-authenticating controller\\n\");\n\tqueue_work(nvme_wq, &ctrl->dhchap_auth_work);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(dhchap_secret, S_IRUGO | S_IWUSR,\n\tnvme_ctrl_dhchap_secret_show, nvme_ctrl_dhchap_secret_store);\n\nstatic ssize_t nvme_ctrl_dhchap_ctrl_secret_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\tstruct nvmf_ctrl_options *opts = ctrl->opts;\n\n\tif (!opts->dhchap_ctrl_secret)\n\t\treturn sysfs_emit(buf, \"none\\n\");\n\treturn sysfs_emit(buf, \"%s\\n\", opts->dhchap_ctrl_secret);\n}\n\nstatic ssize_t nvme_ctrl_dhchap_ctrl_secret_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\tstruct nvmf_ctrl_options *opts = ctrl->opts;\n\tchar *dhchap_secret;\n\n\tif (!ctrl->opts->dhchap_ctrl_secret)\n\t\treturn -EINVAL;\n\tif (count < 7)\n\t\treturn -EINVAL;\n\tif (memcmp(buf, \"DHHC-1:\", 7))\n\t\treturn -EINVAL;\n\n\tdhchap_secret = kzalloc(count + 1, GFP_KERNEL);\n\tif (!dhchap_secret)\n\t\treturn -ENOMEM;\n\tmemcpy(dhchap_secret, buf, count);\n\tnvme_auth_stop(ctrl);\n\tif (strcmp(dhchap_secret, opts->dhchap_ctrl_secret)) {\n\t\tstruct nvme_dhchap_key *key, *ctrl_key;\n\t\tint ret;\n\n\t\tret = nvme_auth_generate_key(dhchap_secret, &key);\n\t\tif (ret) {\n\t\t\tkfree(dhchap_secret);\n\t\t\treturn ret;\n\t\t}\n\t\tkfree(opts->dhchap_ctrl_secret);\n\t\topts->dhchap_ctrl_secret = dhchap_secret;\n\t\tctrl_key = ctrl->ctrl_key;\n\t\tmutex_lock(&ctrl->dhchap_auth_mutex);\n\t\tctrl->ctrl_key = key;\n\t\tmutex_unlock(&ctrl->dhchap_auth_mutex);\n\t\tnvme_auth_free_key(ctrl_key);\n\t} else\n\t\tkfree(dhchap_secret);\n\t \n\tdev_info(ctrl->device, \"re-authenticating controller\\n\");\n\tqueue_work(nvme_wq, &ctrl->dhchap_auth_work);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(dhchap_ctrl_secret, S_IRUGO | S_IWUSR,\n\tnvme_ctrl_dhchap_ctrl_secret_show, nvme_ctrl_dhchap_ctrl_secret_store);\n#endif\n\nstatic struct attribute *nvme_dev_attrs[] = {\n\t&dev_attr_reset_controller.attr,\n\t&dev_attr_rescan_controller.attr,\n\t&dev_attr_model.attr,\n\t&dev_attr_serial.attr,\n\t&dev_attr_firmware_rev.attr,\n\t&dev_attr_cntlid.attr,\n\t&dev_attr_delete_controller.attr,\n\t&dev_attr_transport.attr,\n\t&dev_attr_subsysnqn.attr,\n\t&dev_attr_address.attr,\n\t&dev_attr_state.attr,\n\t&dev_attr_numa_node.attr,\n\t&dev_attr_queue_count.attr,\n\t&dev_attr_sqsize.attr,\n\t&dev_attr_hostnqn.attr,\n\t&dev_attr_hostid.attr,\n\t&dev_attr_ctrl_loss_tmo.attr,\n\t&dev_attr_reconnect_delay.attr,\n\t&dev_attr_fast_io_fail_tmo.attr,\n\t&dev_attr_kato.attr,\n\t&dev_attr_cntrltype.attr,\n\t&dev_attr_dctype.attr,\n#ifdef CONFIG_NVME_AUTH\n\t&dev_attr_dhchap_secret.attr,\n\t&dev_attr_dhchap_ctrl_secret.attr,\n#endif\n\tNULL\n};\n\nstatic umode_t nvme_dev_attrs_are_visible(struct kobject *kobj,\n\t\tstruct attribute *a, int n)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\n\tif (a == &dev_attr_delete_controller.attr && !ctrl->ops->delete_ctrl)\n\t\treturn 0;\n\tif (a == &dev_attr_address.attr && !ctrl->ops->get_address)\n\t\treturn 0;\n\tif (a == &dev_attr_hostnqn.attr && !ctrl->opts)\n\t\treturn 0;\n\tif (a == &dev_attr_hostid.attr && !ctrl->opts)\n\t\treturn 0;\n\tif (a == &dev_attr_ctrl_loss_tmo.attr && !ctrl->opts)\n\t\treturn 0;\n\tif (a == &dev_attr_reconnect_delay.attr && !ctrl->opts)\n\t\treturn 0;\n\tif (a == &dev_attr_fast_io_fail_tmo.attr && !ctrl->opts)\n\t\treturn 0;\n#ifdef CONFIG_NVME_AUTH\n\tif (a == &dev_attr_dhchap_secret.attr && !ctrl->opts)\n\t\treturn 0;\n\tif (a == &dev_attr_dhchap_ctrl_secret.attr && !ctrl->opts)\n\t\treturn 0;\n#endif\n\n\treturn a->mode;\n}\n\nconst struct attribute_group nvme_dev_attrs_group = {\n\t.attrs\t\t= nvme_dev_attrs,\n\t.is_visible\t= nvme_dev_attrs_are_visible,\n};\nEXPORT_SYMBOL_GPL(nvme_dev_attrs_group);\n\nconst struct attribute_group *nvme_dev_attr_groups[] = {\n\t&nvme_dev_attrs_group,\n\tNULL,\n};\n\n#define SUBSYS_ATTR_RO(_name, _mode, _show)\t\t\t\\\n\tstruct device_attribute subsys_attr_##_name = \\\n\t\t__ATTR(_name, _mode, _show, NULL)\n\nstatic ssize_t nvme_subsys_show_nqn(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct nvme_subsystem *subsys =\n\t\tcontainer_of(dev, struct nvme_subsystem, dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", subsys->subnqn);\n}\nstatic SUBSYS_ATTR_RO(subsysnqn, S_IRUGO, nvme_subsys_show_nqn);\n\nstatic ssize_t nvme_subsys_show_type(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct nvme_subsystem *subsys =\n\t\tcontainer_of(dev, struct nvme_subsystem, dev);\n\n\tswitch (subsys->subtype) {\n\tcase NVME_NQN_DISC:\n\t\treturn sysfs_emit(buf, \"discovery\\n\");\n\tcase NVME_NQN_NVME:\n\t\treturn sysfs_emit(buf, \"nvm\\n\");\n\tdefault:\n\t\treturn sysfs_emit(buf, \"reserved\\n\");\n\t}\n}\nstatic SUBSYS_ATTR_RO(subsystype, S_IRUGO, nvme_subsys_show_type);\n\n#define nvme_subsys_show_str_function(field)\t\t\t\t\\\nstatic ssize_t subsys_##field##_show(struct device *dev,\t\t\\\n\t\t\t    struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct nvme_subsystem *subsys =\t\t\t\t\t\\\n\t\tcontainer_of(dev, struct nvme_subsystem, dev);\t\t\\\n\treturn sysfs_emit(buf, \"%.*s\\n\",\t\t\t\t\\\n\t\t\t   (int)sizeof(subsys->field), subsys->field);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic SUBSYS_ATTR_RO(field, S_IRUGO, subsys_##field##_show);\n\nnvme_subsys_show_str_function(model);\nnvme_subsys_show_str_function(serial);\nnvme_subsys_show_str_function(firmware_rev);\n\nstatic struct attribute *nvme_subsys_attrs[] = {\n\t&subsys_attr_model.attr,\n\t&subsys_attr_serial.attr,\n\t&subsys_attr_firmware_rev.attr,\n\t&subsys_attr_subsysnqn.attr,\n\t&subsys_attr_subsystype.attr,\n#ifdef CONFIG_NVME_MULTIPATH\n\t&subsys_attr_iopolicy.attr,\n#endif\n\tNULL,\n};\n\nstatic const struct attribute_group nvme_subsys_attrs_group = {\n\t.attrs = nvme_subsys_attrs,\n};\n\nconst struct attribute_group *nvme_subsys_attrs_groups[] = {\n\t&nvme_subsys_attrs_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}