{
  "module_name": "fabrics.c",
  "hash_id": "4c33f7d735d60773e6a12caf0f7dcf93f1b9184a1a4dc67d86b02957c3daea36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/host/fabrics.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include \"nvme.h\"\n#include \"fabrics.h\"\n\nstatic LIST_HEAD(nvmf_transports);\nstatic DECLARE_RWSEM(nvmf_transports_rwsem);\n\nstatic LIST_HEAD(nvmf_hosts);\nstatic DEFINE_MUTEX(nvmf_hosts_mutex);\n\nstatic struct nvmf_host *nvmf_default_host;\n\nstatic struct nvmf_host *nvmf_host_alloc(const char *hostnqn, uuid_t *id)\n{\n\tstruct nvmf_host *host;\n\n\thost = kmalloc(sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn NULL;\n\n\tkref_init(&host->ref);\n\tuuid_copy(&host->id, id);\n\tstrscpy(host->nqn, hostnqn, NVMF_NQN_SIZE);\n\n\treturn host;\n}\n\nstatic struct nvmf_host *nvmf_host_add(const char *hostnqn, uuid_t *id)\n{\n\tstruct nvmf_host *host;\n\n\tmutex_lock(&nvmf_hosts_mutex);\n\n\t \n\tlist_for_each_entry(host, &nvmf_hosts, list) {\n\t\tbool same_hostnqn = !strcmp(host->nqn, hostnqn);\n\t\tbool same_hostid = uuid_equal(&host->id, id);\n\n\t\tif (same_hostnqn && same_hostid) {\n\t\t\tkref_get(&host->ref);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (same_hostnqn) {\n\t\t\tpr_err(\"found same hostnqn %s but different hostid %pUb\\n\",\n\t\t\t       hostnqn, id);\n\t\t\thost = ERR_PTR(-EINVAL);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (same_hostid) {\n\t\t\tpr_err(\"found same hostid %pUb but different hostnqn %s\\n\",\n\t\t\t       id, hostnqn);\n\t\t\thost = ERR_PTR(-EINVAL);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\thost = nvmf_host_alloc(hostnqn, id);\n\tif (!host) {\n\t\thost = ERR_PTR(-ENOMEM);\n\t\tgoto out_unlock;\n\t}\n\n\tlist_add_tail(&host->list, &nvmf_hosts);\nout_unlock:\n\tmutex_unlock(&nvmf_hosts_mutex);\n\treturn host;\n}\n\nstatic struct nvmf_host *nvmf_host_default(void)\n{\n\tstruct nvmf_host *host;\n\tchar nqn[NVMF_NQN_SIZE];\n\tuuid_t id;\n\n\tuuid_gen(&id);\n\tsnprintf(nqn, NVMF_NQN_SIZE,\n\t\t\"nqn.2014-08.org.nvmexpress:uuid:%pUb\", &id);\n\n\thost = nvmf_host_alloc(nqn, &id);\n\tif (!host)\n\t\treturn NULL;\n\n\tmutex_lock(&nvmf_hosts_mutex);\n\tlist_add_tail(&host->list, &nvmf_hosts);\n\tmutex_unlock(&nvmf_hosts_mutex);\n\n\treturn host;\n}\n\nstatic void nvmf_host_destroy(struct kref *ref)\n{\n\tstruct nvmf_host *host = container_of(ref, struct nvmf_host, ref);\n\n\tmutex_lock(&nvmf_hosts_mutex);\n\tlist_del(&host->list);\n\tmutex_unlock(&nvmf_hosts_mutex);\n\n\tkfree(host);\n}\n\nstatic void nvmf_host_put(struct nvmf_host *host)\n{\n\tif (host)\n\t\tkref_put(&host->ref, nvmf_host_destroy);\n}\n\n \nint nvmf_get_address(struct nvme_ctrl *ctrl, char *buf, int size)\n{\n\tint len = 0;\n\n\tif (ctrl->opts->mask & NVMF_OPT_TRADDR)\n\t\tlen += scnprintf(buf, size, \"traddr=%s\", ctrl->opts->traddr);\n\tif (ctrl->opts->mask & NVMF_OPT_TRSVCID)\n\t\tlen += scnprintf(buf + len, size - len, \"%strsvcid=%s\",\n\t\t\t\t(len) ? \",\" : \"\", ctrl->opts->trsvcid);\n\tif (ctrl->opts->mask & NVMF_OPT_HOST_TRADDR)\n\t\tlen += scnprintf(buf + len, size - len, \"%shost_traddr=%s\",\n\t\t\t\t(len) ? \",\" : \"\", ctrl->opts->host_traddr);\n\tif (ctrl->opts->mask & NVMF_OPT_HOST_IFACE)\n\t\tlen += scnprintf(buf + len, size - len, \"%shost_iface=%s\",\n\t\t\t\t(len) ? \",\" : \"\", ctrl->opts->host_iface);\n\tlen += scnprintf(buf + len, size - len, \"\\n\");\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(nvmf_get_address);\n\n \nint nvmf_reg_read32(struct nvme_ctrl *ctrl, u32 off, u32 *val)\n{\n\tstruct nvme_command cmd = { };\n\tunion nvme_result res;\n\tint ret;\n\n\tcmd.prop_get.opcode = nvme_fabrics_command;\n\tcmd.prop_get.fctype = nvme_fabrics_type_property_get;\n\tcmd.prop_get.offset = cpu_to_le32(off);\n\n\tret = __nvme_submit_sync_cmd(ctrl->fabrics_q, &cmd, &res, NULL, 0,\n\t\t\tNVME_QID_ANY, 0, 0);\n\n\tif (ret >= 0)\n\t\t*val = le64_to_cpu(res.u64);\n\tif (unlikely(ret != 0))\n\t\tdev_err(ctrl->device,\n\t\t\t\"Property Get error: %d, offset %#x\\n\",\n\t\t\tret > 0 ? ret & ~NVME_SC_DNR : ret, off);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvmf_reg_read32);\n\n \nint nvmf_reg_read64(struct nvme_ctrl *ctrl, u32 off, u64 *val)\n{\n\tstruct nvme_command cmd = { };\n\tunion nvme_result res;\n\tint ret;\n\n\tcmd.prop_get.opcode = nvme_fabrics_command;\n\tcmd.prop_get.fctype = nvme_fabrics_type_property_get;\n\tcmd.prop_get.attrib = 1;\n\tcmd.prop_get.offset = cpu_to_le32(off);\n\n\tret = __nvme_submit_sync_cmd(ctrl->fabrics_q, &cmd, &res, NULL, 0,\n\t\t\tNVME_QID_ANY, 0, 0);\n\n\tif (ret >= 0)\n\t\t*val = le64_to_cpu(res.u64);\n\tif (unlikely(ret != 0))\n\t\tdev_err(ctrl->device,\n\t\t\t\"Property Get error: %d, offset %#x\\n\",\n\t\t\tret > 0 ? ret & ~NVME_SC_DNR : ret, off);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvmf_reg_read64);\n\n \nint nvmf_reg_write32(struct nvme_ctrl *ctrl, u32 off, u32 val)\n{\n\tstruct nvme_command cmd = { };\n\tint ret;\n\n\tcmd.prop_set.opcode = nvme_fabrics_command;\n\tcmd.prop_set.fctype = nvme_fabrics_type_property_set;\n\tcmd.prop_set.attrib = 0;\n\tcmd.prop_set.offset = cpu_to_le32(off);\n\tcmd.prop_set.value = cpu_to_le64(val);\n\n\tret = __nvme_submit_sync_cmd(ctrl->fabrics_q, &cmd, NULL, NULL, 0,\n\t\t\tNVME_QID_ANY, 0, 0);\n\tif (unlikely(ret))\n\t\tdev_err(ctrl->device,\n\t\t\t\"Property Set error: %d, offset %#x\\n\",\n\t\t\tret > 0 ? ret & ~NVME_SC_DNR : ret, off);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvmf_reg_write32);\n\n \nstatic void nvmf_log_connect_error(struct nvme_ctrl *ctrl,\n\t\tint errval, int offset, struct nvme_command *cmd,\n\t\tstruct nvmf_connect_data *data)\n{\n\tint err_sctype = errval & ~NVME_SC_DNR;\n\n\tif (errval < 0) {\n\t\tdev_err(ctrl->device,\n\t\t\t\"Connect command failed, errno: %d\\n\", errval);\n\t\treturn;\n\t}\n\n\tswitch (err_sctype) {\n\tcase NVME_SC_CONNECT_INVALID_PARAM:\n\t\tif (offset >> 16) {\n\t\t\tchar *inv_data = \"Connect Invalid Data Parameter\";\n\n\t\t\tswitch (offset & 0xffff) {\n\t\t\tcase (offsetof(struct nvmf_connect_data, cntlid)):\n\t\t\t\tdev_err(ctrl->device,\n\t\t\t\t\t\"%s, cntlid: %d\\n\",\n\t\t\t\t\tinv_data, data->cntlid);\n\t\t\t\tbreak;\n\t\t\tcase (offsetof(struct nvmf_connect_data, hostnqn)):\n\t\t\t\tdev_err(ctrl->device,\n\t\t\t\t\t\"%s, hostnqn \\\"%s\\\"\\n\",\n\t\t\t\t\tinv_data, data->hostnqn);\n\t\t\t\tbreak;\n\t\t\tcase (offsetof(struct nvmf_connect_data, subsysnqn)):\n\t\t\t\tdev_err(ctrl->device,\n\t\t\t\t\t\"%s, subsysnqn \\\"%s\\\"\\n\",\n\t\t\t\t\tinv_data, data->subsysnqn);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(ctrl->device,\n\t\t\t\t\t\"%s, starting byte offset: %d\\n\",\n\t\t\t\t       inv_data, offset & 0xffff);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tchar *inv_sqe = \"Connect Invalid SQE Parameter\";\n\n\t\t\tswitch (offset) {\n\t\t\tcase (offsetof(struct nvmf_connect_command, qid)):\n\t\t\t\tdev_err(ctrl->device,\n\t\t\t\t       \"%s, qid %d\\n\",\n\t\t\t\t\tinv_sqe, cmd->connect.qid);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(ctrl->device,\n\t\t\t\t\t\"%s, starting byte offset: %d\\n\",\n\t\t\t\t\tinv_sqe, offset);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NVME_SC_CONNECT_INVALID_HOST:\n\t\tdev_err(ctrl->device,\n\t\t\t\"Connect for subsystem %s is not allowed, hostnqn: %s\\n\",\n\t\t\tdata->subsysnqn, data->hostnqn);\n\t\tbreak;\n\tcase NVME_SC_CONNECT_CTRL_BUSY:\n\t\tdev_err(ctrl->device,\n\t\t\t\"Connect command failed: controller is busy or not available\\n\");\n\t\tbreak;\n\tcase NVME_SC_CONNECT_FORMAT:\n\t\tdev_err(ctrl->device,\n\t\t\t\"Connect incompatible format: %d\",\n\t\t\tcmd->connect.recfmt);\n\t\tbreak;\n\tcase NVME_SC_HOST_PATH_ERROR:\n\t\tdev_err(ctrl->device,\n\t\t\t\"Connect command failed: host path error\\n\");\n\t\tbreak;\n\tcase NVME_SC_AUTH_REQUIRED:\n\t\tdev_err(ctrl->device,\n\t\t\t\"Connect command failed: authentication required\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ctrl->device,\n\t\t\t\"Connect command failed, error wo/DNR bit: %d\\n\",\n\t\t\terr_sctype);\n\t\tbreak;\n\t}\n}\n\nstatic struct nvmf_connect_data *nvmf_connect_data_prep(struct nvme_ctrl *ctrl,\n\t\tu16 cntlid)\n{\n\tstruct nvmf_connect_data *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn NULL;\n\n\tuuid_copy(&data->hostid, &ctrl->opts->host->id);\n\tdata->cntlid = cpu_to_le16(cntlid);\n\tstrncpy(data->subsysnqn, ctrl->opts->subsysnqn, NVMF_NQN_SIZE);\n\tstrncpy(data->hostnqn, ctrl->opts->host->nqn, NVMF_NQN_SIZE);\n\n\treturn data;\n}\n\nstatic void nvmf_connect_cmd_prep(struct nvme_ctrl *ctrl, u16 qid,\n\t\tstruct nvme_command *cmd)\n{\n\tcmd->connect.opcode = nvme_fabrics_command;\n\tcmd->connect.fctype = nvme_fabrics_type_connect;\n\tcmd->connect.qid = cpu_to_le16(qid);\n\n\tif (qid) {\n\t\tcmd->connect.sqsize = cpu_to_le16(ctrl->sqsize);\n\t} else {\n\t\tcmd->connect.sqsize = cpu_to_le16(NVME_AQ_DEPTH - 1);\n\n\t\t \n\t\tcmd->connect.kato = cpu_to_le32(ctrl->kato * 1000);\n\t}\n\n\tif (ctrl->opts->disable_sqflow)\n\t\tcmd->connect.cattr |= NVME_CONNECT_DISABLE_SQFLOW;\n}\n\n \nint nvmf_connect_admin_queue(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_command cmd = { };\n\tunion nvme_result res;\n\tstruct nvmf_connect_data *data;\n\tint ret;\n\tu32 result;\n\n\tnvmf_connect_cmd_prep(ctrl, 0, &cmd);\n\n\tdata = nvmf_connect_data_prep(ctrl, 0xffff);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = __nvme_submit_sync_cmd(ctrl->fabrics_q, &cmd, &res,\n\t\t\tdata, sizeof(*data), NVME_QID_ANY, 1,\n\t\t\tBLK_MQ_REQ_RESERVED | BLK_MQ_REQ_NOWAIT);\n\tif (ret) {\n\t\tnvmf_log_connect_error(ctrl, ret, le32_to_cpu(res.u32),\n\t\t\t\t       &cmd, data);\n\t\tgoto out_free_data;\n\t}\n\n\tresult = le32_to_cpu(res.u32);\n\tctrl->cntlid = result & 0xFFFF;\n\tif (result & (NVME_CONNECT_AUTHREQ_ATR | NVME_CONNECT_AUTHREQ_ASCR)) {\n\t\t \n\t\tif (result & NVME_CONNECT_AUTHREQ_ASCR) {\n\t\t\tdev_warn(ctrl->device,\n\t\t\t\t \"qid 0: secure concatenation is not supported\\n\");\n\t\t\tret = NVME_SC_AUTH_REQUIRED;\n\t\t\tgoto out_free_data;\n\t\t}\n\t\t \n\t\tret = nvme_auth_negotiate(ctrl, 0);\n\t\tif (ret) {\n\t\t\tdev_warn(ctrl->device,\n\t\t\t\t \"qid 0: authentication setup failed\\n\");\n\t\t\tret = NVME_SC_AUTH_REQUIRED;\n\t\t\tgoto out_free_data;\n\t\t}\n\t\tret = nvme_auth_wait(ctrl, 0);\n\t\tif (ret)\n\t\t\tdev_warn(ctrl->device,\n\t\t\t\t \"qid 0: authentication failed\\n\");\n\t\telse\n\t\t\tdev_info(ctrl->device,\n\t\t\t\t \"qid 0: authenticated\\n\");\n\t}\nout_free_data:\n\tkfree(data);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvmf_connect_admin_queue);\n\n \nint nvmf_connect_io_queue(struct nvme_ctrl *ctrl, u16 qid)\n{\n\tstruct nvme_command cmd = { };\n\tstruct nvmf_connect_data *data;\n\tunion nvme_result res;\n\tint ret;\n\tu32 result;\n\n\tnvmf_connect_cmd_prep(ctrl, qid, &cmd);\n\n\tdata = nvmf_connect_data_prep(ctrl, ctrl->cntlid);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = __nvme_submit_sync_cmd(ctrl->connect_q, &cmd, &res,\n\t\t\tdata, sizeof(*data), qid, 1,\n\t\t\tBLK_MQ_REQ_RESERVED | BLK_MQ_REQ_NOWAIT);\n\tif (ret) {\n\t\tnvmf_log_connect_error(ctrl, ret, le32_to_cpu(res.u32),\n\t\t\t\t       &cmd, data);\n\t}\n\tresult = le32_to_cpu(res.u32);\n\tif (result & (NVME_CONNECT_AUTHREQ_ATR | NVME_CONNECT_AUTHREQ_ASCR)) {\n\t\t \n\t\tif (result & NVME_CONNECT_AUTHREQ_ASCR) {\n\t\t\tdev_warn(ctrl->device,\n\t\t\t\t \"qid 0: secure concatenation is not supported\\n\");\n\t\t\tret = NVME_SC_AUTH_REQUIRED;\n\t\t\tgoto out_free_data;\n\t\t}\n\t\t \n\t\tret = nvme_auth_negotiate(ctrl, qid);\n\t\tif (ret) {\n\t\t\tdev_warn(ctrl->device,\n\t\t\t\t \"qid %d: authentication setup failed\\n\", qid);\n\t\t\tret = NVME_SC_AUTH_REQUIRED;\n\t\t} else {\n\t\t\tret = nvme_auth_wait(ctrl, qid);\n\t\t\tif (ret)\n\t\t\t\tdev_warn(ctrl->device,\n\t\t\t\t\t \"qid %u: authentication failed\\n\", qid);\n\t\t}\n\t}\nout_free_data:\n\tkfree(data);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvmf_connect_io_queue);\n\nbool nvmf_should_reconnect(struct nvme_ctrl *ctrl)\n{\n\tif (ctrl->opts->max_reconnects == -1 ||\n\t    ctrl->nr_reconnects < ctrl->opts->max_reconnects)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(nvmf_should_reconnect);\n\n \nint nvmf_register_transport(struct nvmf_transport_ops *ops)\n{\n\tif (!ops->create_ctrl)\n\t\treturn -EINVAL;\n\n\tdown_write(&nvmf_transports_rwsem);\n\tlist_add_tail(&ops->entry, &nvmf_transports);\n\tup_write(&nvmf_transports_rwsem);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nvmf_register_transport);\n\n \nvoid nvmf_unregister_transport(struct nvmf_transport_ops *ops)\n{\n\tdown_write(&nvmf_transports_rwsem);\n\tlist_del(&ops->entry);\n\tup_write(&nvmf_transports_rwsem);\n}\nEXPORT_SYMBOL_GPL(nvmf_unregister_transport);\n\nstatic struct nvmf_transport_ops *nvmf_lookup_transport(\n\t\tstruct nvmf_ctrl_options *opts)\n{\n\tstruct nvmf_transport_ops *ops;\n\n\tlockdep_assert_held(&nvmf_transports_rwsem);\n\n\tlist_for_each_entry(ops, &nvmf_transports, entry) {\n\t\tif (strcmp(ops->name, opts->transport) == 0)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}\n\nstatic const match_table_t opt_tokens = {\n\t{ NVMF_OPT_TRANSPORT,\t\t\"transport=%s\"\t\t},\n\t{ NVMF_OPT_TRADDR,\t\t\"traddr=%s\"\t\t},\n\t{ NVMF_OPT_TRSVCID,\t\t\"trsvcid=%s\"\t\t},\n\t{ NVMF_OPT_NQN,\t\t\t\"nqn=%s\"\t\t},\n\t{ NVMF_OPT_QUEUE_SIZE,\t\t\"queue_size=%d\"\t\t},\n\t{ NVMF_OPT_NR_IO_QUEUES,\t\"nr_io_queues=%d\"\t},\n\t{ NVMF_OPT_RECONNECT_DELAY,\t\"reconnect_delay=%d\"\t},\n\t{ NVMF_OPT_CTRL_LOSS_TMO,\t\"ctrl_loss_tmo=%d\"\t},\n\t{ NVMF_OPT_KATO,\t\t\"keep_alive_tmo=%d\"\t},\n\t{ NVMF_OPT_HOSTNQN,\t\t\"hostnqn=%s\"\t\t},\n\t{ NVMF_OPT_HOST_TRADDR,\t\t\"host_traddr=%s\"\t},\n\t{ NVMF_OPT_HOST_IFACE,\t\t\"host_iface=%s\"\t\t},\n\t{ NVMF_OPT_HOST_ID,\t\t\"hostid=%s\"\t\t},\n\t{ NVMF_OPT_DUP_CONNECT,\t\t\"duplicate_connect\"\t},\n\t{ NVMF_OPT_DISABLE_SQFLOW,\t\"disable_sqflow\"\t},\n\t{ NVMF_OPT_HDR_DIGEST,\t\t\"hdr_digest\"\t\t},\n\t{ NVMF_OPT_DATA_DIGEST,\t\t\"data_digest\"\t\t},\n\t{ NVMF_OPT_NR_WRITE_QUEUES,\t\"nr_write_queues=%d\"\t},\n\t{ NVMF_OPT_NR_POLL_QUEUES,\t\"nr_poll_queues=%d\"\t},\n\t{ NVMF_OPT_TOS,\t\t\t\"tos=%d\"\t\t},\n\t{ NVMF_OPT_FAIL_FAST_TMO,\t\"fast_io_fail_tmo=%d\"\t},\n\t{ NVMF_OPT_DISCOVERY,\t\t\"discovery\"\t\t},\n#ifdef CONFIG_NVME_HOST_AUTH\n\t{ NVMF_OPT_DHCHAP_SECRET,\t\"dhchap_secret=%s\"\t},\n\t{ NVMF_OPT_DHCHAP_CTRL_SECRET,\t\"dhchap_ctrl_secret=%s\"\t},\n#endif\n\t{ NVMF_OPT_ERR,\t\t\tNULL\t\t\t}\n};\n\nstatic int nvmf_parse_options(struct nvmf_ctrl_options *opts,\n\t\tconst char *buf)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *options, *o, *p;\n\tint token, ret = 0;\n\tsize_t nqnlen  = 0;\n\tint ctrl_loss_tmo = NVMF_DEF_CTRL_LOSS_TMO;\n\tuuid_t hostid;\n\tchar hostnqn[NVMF_NQN_SIZE];\n\n\t \n\topts->queue_size = NVMF_DEF_QUEUE_SIZE;\n\topts->nr_io_queues = num_online_cpus();\n\topts->reconnect_delay = NVMF_DEF_RECONNECT_DELAY;\n\topts->kato = 0;\n\topts->duplicate_connect = false;\n\topts->fast_io_fail_tmo = NVMF_DEF_FAIL_FAST_TMO;\n\topts->hdr_digest = false;\n\topts->data_digest = false;\n\topts->tos = -1;  \n\n\toptions = o = kstrdup(buf, GFP_KERNEL);\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\t \n\tuuid_copy(&hostid, &nvmf_default_host->id);\n\tstrscpy(hostnqn, nvmf_default_host->nqn, NVMF_NQN_SIZE);\n\n\twhile ((p = strsep(&o, \",\\n\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, opt_tokens, args);\n\t\topts->mask |= token;\n\t\tswitch (token) {\n\t\tcase NVMF_OPT_TRANSPORT:\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkfree(opts->transport);\n\t\t\topts->transport = p;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_NQN:\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkfree(opts->subsysnqn);\n\t\t\topts->subsysnqn = p;\n\t\t\tnqnlen = strlen(opts->subsysnqn);\n\t\t\tif (nqnlen >= NVMF_NQN_SIZE) {\n\t\t\t\tpr_err(\"%s needs to be < %d bytes\\n\",\n\t\t\t\t\topts->subsysnqn, NVMF_NQN_SIZE);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\topts->discovery_nqn =\n\t\t\t\t!(strcmp(opts->subsysnqn,\n\t\t\t\t\t NVME_DISC_SUBSYS_NAME));\n\t\t\tbreak;\n\t\tcase NVMF_OPT_TRADDR:\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkfree(opts->traddr);\n\t\t\topts->traddr = p;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_TRSVCID:\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkfree(opts->trsvcid);\n\t\t\topts->trsvcid = p;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_QUEUE_SIZE:\n\t\t\tif (match_int(args, &token)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (token < NVMF_MIN_QUEUE_SIZE ||\n\t\t\t    token > NVMF_MAX_QUEUE_SIZE) {\n\t\t\t\tpr_err(\"Invalid queue_size %d\\n\", token);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\topts->queue_size = token;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_NR_IO_QUEUES:\n\t\t\tif (match_int(args, &token)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (token <= 0) {\n\t\t\t\tpr_err(\"Invalid number of IOQs %d\\n\", token);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (opts->discovery_nqn) {\n\t\t\t\tpr_debug(\"Ignoring nr_io_queues value for discovery controller\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\topts->nr_io_queues = min_t(unsigned int,\n\t\t\t\t\tnum_online_cpus(), token);\n\t\t\tbreak;\n\t\tcase NVMF_OPT_KATO:\n\t\t\tif (match_int(args, &token)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (token < 0) {\n\t\t\t\tpr_err(\"Invalid keep_alive_tmo %d\\n\", token);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t} else if (token == 0 && !opts->discovery_nqn) {\n\t\t\t\t \n\t\t\t\tpr_warn(\"keep_alive_tmo 0 won't execute keep alives!!!\\n\");\n\t\t\t}\n\t\t\topts->kato = token;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_CTRL_LOSS_TMO:\n\t\t\tif (match_int(args, &token)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (token < 0)\n\t\t\t\tpr_warn(\"ctrl_loss_tmo < 0 will reconnect forever\\n\");\n\t\t\tctrl_loss_tmo = token;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_FAIL_FAST_TMO:\n\t\t\tif (match_int(args, &token)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (token >= 0)\n\t\t\t\tpr_warn(\"I/O fail on reconnect controller after %d sec\\n\",\n\t\t\t\t\ttoken);\n\t\t\telse\n\t\t\t\ttoken = -1;\n\n\t\t\topts->fast_io_fail_tmo = token;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_HOSTNQN:\n\t\t\tif (opts->host) {\n\t\t\t\tpr_err(\"hostnqn already user-assigned: %s\\n\",\n\t\t\t\t       opts->host->nqn);\n\t\t\t\tret = -EADDRINUSE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnqnlen = strlen(p);\n\t\t\tif (nqnlen >= NVMF_NQN_SIZE) {\n\t\t\t\tpr_err(\"%s needs to be < %d bytes\\n\",\n\t\t\t\t\tp, NVMF_NQN_SIZE);\n\t\t\t\tkfree(p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstrscpy(hostnqn, p, NVMF_NQN_SIZE);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\tcase NVMF_OPT_RECONNECT_DELAY:\n\t\t\tif (match_int(args, &token)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (token <= 0) {\n\t\t\t\tpr_err(\"Invalid reconnect_delay %d\\n\", token);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\topts->reconnect_delay = token;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_HOST_TRADDR:\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkfree(opts->host_traddr);\n\t\t\topts->host_traddr = p;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_HOST_IFACE:\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkfree(opts->host_iface);\n\t\t\topts->host_iface = p;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_HOST_ID:\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = uuid_parse(p, &hostid);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"Invalid hostid %s\\n\", p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tkfree(p);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\tcase NVMF_OPT_DUP_CONNECT:\n\t\t\topts->duplicate_connect = true;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_DISABLE_SQFLOW:\n\t\t\topts->disable_sqflow = true;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_HDR_DIGEST:\n\t\t\topts->hdr_digest = true;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_DATA_DIGEST:\n\t\t\topts->data_digest = true;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_NR_WRITE_QUEUES:\n\t\t\tif (match_int(args, &token)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (token <= 0) {\n\t\t\t\tpr_err(\"Invalid nr_write_queues %d\\n\", token);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\topts->nr_write_queues = token;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_NR_POLL_QUEUES:\n\t\t\tif (match_int(args, &token)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (token <= 0) {\n\t\t\t\tpr_err(\"Invalid nr_poll_queues %d\\n\", token);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\topts->nr_poll_queues = token;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_TOS:\n\t\t\tif (match_int(args, &token)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (token < 0) {\n\t\t\t\tpr_err(\"Invalid type of service %d\\n\", token);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (token > 255) {\n\t\t\t\tpr_warn(\"Clamping type of service to 255\\n\");\n\t\t\t\ttoken = 255;\n\t\t\t}\n\t\t\topts->tos = token;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_DISCOVERY:\n\t\t\topts->discovery_nqn = true;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_DHCHAP_SECRET:\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strlen(p) < 11 || strncmp(p, \"DHHC-1:\", 7)) {\n\t\t\t\tpr_err(\"Invalid DH-CHAP secret %s\\n\", p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkfree(opts->dhchap_secret);\n\t\t\topts->dhchap_secret = p;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_DHCHAP_CTRL_SECRET:\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strlen(p) < 11 || strncmp(p, \"DHHC-1:\", 7)) {\n\t\t\t\tpr_err(\"Invalid DH-CHAP secret %s\\n\", p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkfree(opts->dhchap_ctrl_secret);\n\t\t\topts->dhchap_ctrl_secret = p;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unknown parameter or missing value '%s' in ctrl creation request\\n\",\n\t\t\t\tp);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (opts->discovery_nqn) {\n\t\topts->nr_io_queues = 0;\n\t\topts->nr_write_queues = 0;\n\t\topts->nr_poll_queues = 0;\n\t\topts->duplicate_connect = true;\n\t} else {\n\t\tif (!opts->kato)\n\t\t\topts->kato = NVME_DEFAULT_KATO;\n\t}\n\tif (ctrl_loss_tmo < 0) {\n\t\topts->max_reconnects = -1;\n\t} else {\n\t\topts->max_reconnects = DIV_ROUND_UP(ctrl_loss_tmo,\n\t\t\t\t\t\topts->reconnect_delay);\n\t\tif (ctrl_loss_tmo < opts->fast_io_fail_tmo)\n\t\t\tpr_warn(\"failfast tmo (%d) larger than controller loss tmo (%d)\\n\",\n\t\t\t\topts->fast_io_fail_tmo, ctrl_loss_tmo);\n\t}\n\n\topts->host = nvmf_host_add(hostnqn, &hostid);\n\tif (IS_ERR(opts->host)) {\n\t\tret = PTR_ERR(opts->host);\n\t\topts->host = NULL;\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(options);\n\treturn ret;\n}\n\nvoid nvmf_set_io_queues(struct nvmf_ctrl_options *opts, u32 nr_io_queues,\n\t\t\tu32 io_queues[HCTX_MAX_TYPES])\n{\n\tif (opts->nr_write_queues && opts->nr_io_queues < nr_io_queues) {\n\t\t \n\t\tio_queues[HCTX_TYPE_READ] = opts->nr_io_queues;\n\t\tnr_io_queues -= io_queues[HCTX_TYPE_READ];\n\t\tio_queues[HCTX_TYPE_DEFAULT] =\n\t\t\tmin(opts->nr_write_queues, nr_io_queues);\n\t\tnr_io_queues -= io_queues[HCTX_TYPE_DEFAULT];\n\t} else {\n\t\t \n\t\tio_queues[HCTX_TYPE_DEFAULT] =\n\t\t\tmin(opts->nr_io_queues, nr_io_queues);\n\t\tnr_io_queues -= io_queues[HCTX_TYPE_DEFAULT];\n\t}\n\n\tif (opts->nr_poll_queues && nr_io_queues) {\n\t\t \n\t\tio_queues[HCTX_TYPE_POLL] =\n\t\t\tmin(opts->nr_poll_queues, nr_io_queues);\n\t}\n}\nEXPORT_SYMBOL_GPL(nvmf_set_io_queues);\n\nvoid nvmf_map_queues(struct blk_mq_tag_set *set, struct nvme_ctrl *ctrl,\n\t\t     u32 io_queues[HCTX_MAX_TYPES])\n{\n\tstruct nvmf_ctrl_options *opts = ctrl->opts;\n\n\tif (opts->nr_write_queues && io_queues[HCTX_TYPE_READ]) {\n\t\t \n\t\tset->map[HCTX_TYPE_DEFAULT].nr_queues =\n\t\t\tio_queues[HCTX_TYPE_DEFAULT];\n\t\tset->map[HCTX_TYPE_DEFAULT].queue_offset = 0;\n\t\tset->map[HCTX_TYPE_READ].nr_queues =\n\t\t\tio_queues[HCTX_TYPE_READ];\n\t\tset->map[HCTX_TYPE_READ].queue_offset =\n\t\t\tio_queues[HCTX_TYPE_DEFAULT];\n\t} else {\n\t\t \n\t\tset->map[HCTX_TYPE_DEFAULT].nr_queues =\n\t\t\tio_queues[HCTX_TYPE_DEFAULT];\n\t\tset->map[HCTX_TYPE_DEFAULT].queue_offset = 0;\n\t\tset->map[HCTX_TYPE_READ].nr_queues =\n\t\t\tio_queues[HCTX_TYPE_DEFAULT];\n\t\tset->map[HCTX_TYPE_READ].queue_offset = 0;\n\t}\n\n\tblk_mq_map_queues(&set->map[HCTX_TYPE_DEFAULT]);\n\tblk_mq_map_queues(&set->map[HCTX_TYPE_READ]);\n\tif (opts->nr_poll_queues && io_queues[HCTX_TYPE_POLL]) {\n\t\t \n\t\tset->map[HCTX_TYPE_POLL].nr_queues = io_queues[HCTX_TYPE_POLL];\n\t\tset->map[HCTX_TYPE_POLL].queue_offset =\n\t\t\tio_queues[HCTX_TYPE_DEFAULT] +\n\t\t\tio_queues[HCTX_TYPE_READ];\n\t\tblk_mq_map_queues(&set->map[HCTX_TYPE_POLL]);\n\t}\n\n\tdev_info(ctrl->device,\n\t\t\"mapped %d/%d/%d default/read/poll queues.\\n\",\n\t\tio_queues[HCTX_TYPE_DEFAULT],\n\t\tio_queues[HCTX_TYPE_READ],\n\t\tio_queues[HCTX_TYPE_POLL]);\n}\nEXPORT_SYMBOL_GPL(nvmf_map_queues);\n\nstatic int nvmf_check_required_opts(struct nvmf_ctrl_options *opts,\n\t\tunsigned int required_opts)\n{\n\tif ((opts->mask & required_opts) != required_opts) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(opt_tokens); i++) {\n\t\t\tif ((opt_tokens[i].token & required_opts) &&\n\t\t\t    !(opt_tokens[i].token & opts->mask)) {\n\t\t\t\tpr_warn(\"missing parameter '%s'\\n\",\n\t\t\t\t\topt_tokens[i].pattern);\n\t\t\t}\n\t\t}\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nbool nvmf_ip_options_match(struct nvme_ctrl *ctrl,\n\t\tstruct nvmf_ctrl_options *opts)\n{\n\tif (!nvmf_ctlr_matches_baseopts(ctrl, opts) ||\n\t    strcmp(opts->traddr, ctrl->opts->traddr) ||\n\t    strcmp(opts->trsvcid, ctrl->opts->trsvcid))\n\t\treturn false;\n\n\t \n\tif ((opts->mask & NVMF_OPT_HOST_TRADDR) &&\n\t    (ctrl->opts->mask & NVMF_OPT_HOST_TRADDR)) {\n\t\tif (strcmp(opts->host_traddr, ctrl->opts->host_traddr))\n\t\t\treturn false;\n\t} else if ((opts->mask & NVMF_OPT_HOST_TRADDR) ||\n\t\t   (ctrl->opts->mask & NVMF_OPT_HOST_TRADDR)) {\n\t\treturn false;\n\t}\n\n\tif ((opts->mask & NVMF_OPT_HOST_IFACE) &&\n\t    (ctrl->opts->mask & NVMF_OPT_HOST_IFACE)) {\n\t\tif (strcmp(opts->host_iface, ctrl->opts->host_iface))\n\t\t\treturn false;\n\t} else if ((opts->mask & NVMF_OPT_HOST_IFACE) ||\n\t\t   (ctrl->opts->mask & NVMF_OPT_HOST_IFACE)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(nvmf_ip_options_match);\n\nstatic int nvmf_check_allowed_opts(struct nvmf_ctrl_options *opts,\n\t\tunsigned int allowed_opts)\n{\n\tif (opts->mask & ~allowed_opts) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(opt_tokens); i++) {\n\t\t\tif ((opt_tokens[i].token & opts->mask) &&\n\t\t\t    (opt_tokens[i].token & ~allowed_opts)) {\n\t\t\t\tpr_warn(\"invalid parameter '%s'\\n\",\n\t\t\t\t\topt_tokens[i].pattern);\n\t\t\t}\n\t\t}\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid nvmf_free_options(struct nvmf_ctrl_options *opts)\n{\n\tnvmf_host_put(opts->host);\n\tkfree(opts->transport);\n\tkfree(opts->traddr);\n\tkfree(opts->trsvcid);\n\tkfree(opts->subsysnqn);\n\tkfree(opts->host_traddr);\n\tkfree(opts->host_iface);\n\tkfree(opts->dhchap_secret);\n\tkfree(opts->dhchap_ctrl_secret);\n\tkfree(opts);\n}\nEXPORT_SYMBOL_GPL(nvmf_free_options);\n\n#define NVMF_REQUIRED_OPTS\t(NVMF_OPT_TRANSPORT | NVMF_OPT_NQN)\n#define NVMF_ALLOWED_OPTS\t(NVMF_OPT_QUEUE_SIZE | NVMF_OPT_NR_IO_QUEUES | \\\n\t\t\t\t NVMF_OPT_KATO | NVMF_OPT_HOSTNQN | \\\n\t\t\t\t NVMF_OPT_HOST_ID | NVMF_OPT_DUP_CONNECT |\\\n\t\t\t\t NVMF_OPT_DISABLE_SQFLOW | NVMF_OPT_DISCOVERY |\\\n\t\t\t\t NVMF_OPT_FAIL_FAST_TMO | NVMF_OPT_DHCHAP_SECRET |\\\n\t\t\t\t NVMF_OPT_DHCHAP_CTRL_SECRET)\n\nstatic struct nvme_ctrl *\nnvmf_create_ctrl(struct device *dev, const char *buf)\n{\n\tstruct nvmf_ctrl_options *opts;\n\tstruct nvmf_transport_ops *ops;\n\tstruct nvme_ctrl *ctrl;\n\tint ret;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = nvmf_parse_options(opts, buf);\n\tif (ret)\n\t\tgoto out_free_opts;\n\n\n\trequest_module(\"nvme-%s\", opts->transport);\n\n\t \n\tret = nvmf_check_required_opts(opts, NVMF_REQUIRED_OPTS);\n\tif (ret)\n\t\tgoto out_free_opts;\n\topts->mask &= ~NVMF_REQUIRED_OPTS;\n\n\tdown_read(&nvmf_transports_rwsem);\n\tops = nvmf_lookup_transport(opts);\n\tif (!ops) {\n\t\tpr_info(\"no handler found for transport %s.\\n\",\n\t\t\topts->transport);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!try_module_get(ops->module)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tup_read(&nvmf_transports_rwsem);\n\n\tret = nvmf_check_required_opts(opts, ops->required_opts);\n\tif (ret)\n\t\tgoto out_module_put;\n\tret = nvmf_check_allowed_opts(opts, NVMF_ALLOWED_OPTS |\n\t\t\t\tops->allowed_opts | ops->required_opts);\n\tif (ret)\n\t\tgoto out_module_put;\n\n\tctrl = ops->create_ctrl(dev, opts);\n\tif (IS_ERR(ctrl)) {\n\t\tret = PTR_ERR(ctrl);\n\t\tgoto out_module_put;\n\t}\n\n\tmodule_put(ops->module);\n\treturn ctrl;\n\nout_module_put:\n\tmodule_put(ops->module);\n\tgoto out_free_opts;\nout_unlock:\n\tup_read(&nvmf_transports_rwsem);\nout_free_opts:\n\tnvmf_free_options(opts);\n\treturn ERR_PTR(ret);\n}\n\nstatic struct class *nvmf_class;\nstatic struct device *nvmf_device;\nstatic DEFINE_MUTEX(nvmf_dev_mutex);\n\nstatic ssize_t nvmf_dev_write(struct file *file, const char __user *ubuf,\n\t\tsize_t count, loff_t *pos)\n{\n\tstruct seq_file *seq_file = file->private_data;\n\tstruct nvme_ctrl *ctrl;\n\tconst char *buf;\n\tint ret = 0;\n\n\tif (count > PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\tbuf = memdup_user_nul(ubuf, count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tmutex_lock(&nvmf_dev_mutex);\n\tif (seq_file->private) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tctrl = nvmf_create_ctrl(nvmf_device, buf);\n\tif (IS_ERR(ctrl)) {\n\t\tret = PTR_ERR(ctrl);\n\t\tgoto out_unlock;\n\t}\n\n\tseq_file->private = ctrl;\n\nout_unlock:\n\tmutex_unlock(&nvmf_dev_mutex);\n\tkfree(buf);\n\treturn ret ? ret : count;\n}\n\nstatic void __nvmf_concat_opt_tokens(struct seq_file *seq_file)\n{\n\tconst struct match_token *tok;\n\tint idx;\n\n\t \n\tseq_puts(seq_file, \"instance=-1,cntlid=-1\");\n\tfor (idx = 0; idx < ARRAY_SIZE(opt_tokens); idx++) {\n\t\ttok = &opt_tokens[idx];\n\t\tif (tok->token == NVMF_OPT_ERR)\n\t\t\tcontinue;\n\t\tseq_puts(seq_file, \",\");\n\t\tseq_puts(seq_file, tok->pattern);\n\t}\n\tseq_puts(seq_file, \"\\n\");\n}\n\nstatic int nvmf_dev_show(struct seq_file *seq_file, void *private)\n{\n\tstruct nvme_ctrl *ctrl;\n\n\tmutex_lock(&nvmf_dev_mutex);\n\tctrl = seq_file->private;\n\tif (!ctrl) {\n\t\t__nvmf_concat_opt_tokens(seq_file);\n\t\tgoto out_unlock;\n\t}\n\n\tseq_printf(seq_file, \"instance=%d,cntlid=%d\\n\",\n\t\t\tctrl->instance, ctrl->cntlid);\n\nout_unlock:\n\tmutex_unlock(&nvmf_dev_mutex);\n\treturn 0;\n}\n\nstatic int nvmf_dev_open(struct inode *inode, struct file *file)\n{\n\t \n\tfile->private_data = NULL;\n\treturn single_open(file, nvmf_dev_show, NULL);\n}\n\nstatic int nvmf_dev_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq_file = file->private_data;\n\tstruct nvme_ctrl *ctrl = seq_file->private;\n\n\tif (ctrl)\n\t\tnvme_put_ctrl(ctrl);\n\treturn single_release(inode, file);\n}\n\nstatic const struct file_operations nvmf_dev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.write\t\t= nvmf_dev_write,\n\t.read\t\t= seq_read,\n\t.open\t\t= nvmf_dev_open,\n\t.release\t= nvmf_dev_release,\n};\n\nstatic struct miscdevice nvmf_misc = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name           = \"nvme-fabrics\",\n\t.fops\t\t= &nvmf_dev_fops,\n};\n\nstatic int __init nvmf_init(void)\n{\n\tint ret;\n\n\tnvmf_default_host = nvmf_host_default();\n\tif (!nvmf_default_host)\n\t\treturn -ENOMEM;\n\n\tnvmf_class = class_create(\"nvme-fabrics\");\n\tif (IS_ERR(nvmf_class)) {\n\t\tpr_err(\"couldn't register class nvme-fabrics\\n\");\n\t\tret = PTR_ERR(nvmf_class);\n\t\tgoto out_free_host;\n\t}\n\n\tnvmf_device =\n\t\tdevice_create(nvmf_class, NULL, MKDEV(0, 0), NULL, \"ctl\");\n\tif (IS_ERR(nvmf_device)) {\n\t\tpr_err(\"couldn't create nvme-fabrics device!\\n\");\n\t\tret = PTR_ERR(nvmf_device);\n\t\tgoto out_destroy_class;\n\t}\n\n\tret = misc_register(&nvmf_misc);\n\tif (ret) {\n\t\tpr_err(\"couldn't register misc device: %d\\n\", ret);\n\t\tgoto out_destroy_device;\n\t}\n\n\treturn 0;\n\nout_destroy_device:\n\tdevice_destroy(nvmf_class, MKDEV(0, 0));\nout_destroy_class:\n\tclass_destroy(nvmf_class);\nout_free_host:\n\tnvmf_host_put(nvmf_default_host);\n\treturn ret;\n}\n\nstatic void __exit nvmf_exit(void)\n{\n\tmisc_deregister(&nvmf_misc);\n\tdevice_destroy(nvmf_class, MKDEV(0, 0));\n\tclass_destroy(nvmf_class);\n\tnvmf_host_put(nvmf_default_host);\n\n\tBUILD_BUG_ON(sizeof(struct nvmf_common_command) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvmf_connect_command) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvmf_property_get_command) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvmf_property_set_command) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvmf_auth_send_command) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvmf_auth_receive_command) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvmf_connect_data) != 1024);\n\tBUILD_BUG_ON(sizeof(struct nvmf_auth_dhchap_negotiate_data) != 8);\n\tBUILD_BUG_ON(sizeof(struct nvmf_auth_dhchap_challenge_data) != 16);\n\tBUILD_BUG_ON(sizeof(struct nvmf_auth_dhchap_reply_data) != 16);\n\tBUILD_BUG_ON(sizeof(struct nvmf_auth_dhchap_success1_data) != 16);\n\tBUILD_BUG_ON(sizeof(struct nvmf_auth_dhchap_success2_data) != 16);\n}\n\nMODULE_LICENSE(\"GPL v2\");\n\nmodule_init(nvmf_init);\nmodule_exit(nvmf_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}