{
  "module_name": "auth.c",
  "hash_id": "48ec13bfaab376260816234353858630085af52824e534398f4df9dbe43f73eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/host/auth.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/base64.h>\n#include <linux/prandom.h>\n#include <asm/unaligned.h>\n#include <crypto/hash.h>\n#include <crypto/dh.h>\n#include \"nvme.h\"\n#include \"fabrics.h\"\n#include <linux/nvme-auth.h>\n\n#define CHAP_BUF_SIZE 4096\nstatic struct kmem_cache *nvme_chap_buf_cache;\nstatic mempool_t *nvme_chap_buf_pool;\n\nstruct nvme_dhchap_queue_context {\n\tstruct list_head entry;\n\tstruct work_struct auth_work;\n\tstruct nvme_ctrl *ctrl;\n\tstruct crypto_shash *shash_tfm;\n\tstruct crypto_kpp *dh_tfm;\n\tvoid *buf;\n\tint qid;\n\tint error;\n\tu32 s1;\n\tu32 s2;\n\tu16 transaction;\n\tu8 status;\n\tu8 dhgroup_id;\n\tu8 hash_id;\n\tsize_t hash_len;\n\tu8 c1[64];\n\tu8 c2[64];\n\tu8 response[64];\n\tu8 *host_response;\n\tu8 *ctrl_key;\n\tu8 *host_key;\n\tu8 *sess_key;\n\tint ctrl_key_len;\n\tint host_key_len;\n\tint sess_key_len;\n};\n\nstatic struct workqueue_struct *nvme_auth_wq;\n\n#define nvme_auth_flags_from_qid(qid) \\\n\t(qid == 0) ? 0 : BLK_MQ_REQ_NOWAIT | BLK_MQ_REQ_RESERVED\n#define nvme_auth_queue_from_qid(ctrl, qid) \\\n\t(qid == 0) ? (ctrl)->fabrics_q : (ctrl)->connect_q\n\nstatic inline int ctrl_max_dhchaps(struct nvme_ctrl *ctrl)\n{\n\treturn ctrl->opts->nr_io_queues + ctrl->opts->nr_write_queues +\n\t\t\tctrl->opts->nr_poll_queues + 1;\n}\n\nstatic int nvme_auth_submit(struct nvme_ctrl *ctrl, int qid,\n\t\t\t    void *data, size_t data_len, bool auth_send)\n{\n\tstruct nvme_command cmd = {};\n\tblk_mq_req_flags_t flags = nvme_auth_flags_from_qid(qid);\n\tstruct request_queue *q = nvme_auth_queue_from_qid(ctrl, qid);\n\tint ret;\n\n\tcmd.auth_common.opcode = nvme_fabrics_command;\n\tcmd.auth_common.secp = NVME_AUTH_DHCHAP_PROTOCOL_IDENTIFIER;\n\tcmd.auth_common.spsp0 = 0x01;\n\tcmd.auth_common.spsp1 = 0x01;\n\tif (auth_send) {\n\t\tcmd.auth_send.fctype = nvme_fabrics_type_auth_send;\n\t\tcmd.auth_send.tl = cpu_to_le32(data_len);\n\t} else {\n\t\tcmd.auth_receive.fctype = nvme_fabrics_type_auth_receive;\n\t\tcmd.auth_receive.al = cpu_to_le32(data_len);\n\t}\n\n\tret = __nvme_submit_sync_cmd(q, &cmd, NULL, data, data_len,\n\t\t\t\t     qid == 0 ? NVME_QID_ANY : qid,\n\t\t\t\t     0, flags);\n\tif (ret > 0)\n\t\tdev_warn(ctrl->device,\n\t\t\t\"qid %d auth_send failed with status %d\\n\", qid, ret);\n\telse if (ret < 0)\n\t\tdev_err(ctrl->device,\n\t\t\t\"qid %d auth_send failed with error %d\\n\", qid, ret);\n\treturn ret;\n}\n\nstatic int nvme_auth_receive_validate(struct nvme_ctrl *ctrl, int qid,\n\t\tstruct nvmf_auth_dhchap_failure_data *data,\n\t\tu16 transaction, u8 expected_msg)\n{\n\tdev_dbg(ctrl->device, \"%s: qid %d auth_type %d auth_id %x\\n\",\n\t\t__func__, qid, data->auth_type, data->auth_id);\n\n\tif (data->auth_type == NVME_AUTH_COMMON_MESSAGES &&\n\t    data->auth_id == NVME_AUTH_DHCHAP_MESSAGE_FAILURE1) {\n\t\treturn data->rescode_exp;\n\t}\n\tif (data->auth_type != NVME_AUTH_DHCHAP_MESSAGES ||\n\t    data->auth_id != expected_msg) {\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid %d invalid message %02x/%02x\\n\",\n\t\t\t qid, data->auth_type, data->auth_id);\n\t\treturn NVME_AUTH_DHCHAP_FAILURE_INCORRECT_MESSAGE;\n\t}\n\tif (le16_to_cpu(data->t_id) != transaction) {\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid %d invalid transaction ID %d\\n\",\n\t\t\t qid, le16_to_cpu(data->t_id));\n\t\treturn NVME_AUTH_DHCHAP_FAILURE_INCORRECT_MESSAGE;\n\t}\n\treturn 0;\n}\n\nstatic int nvme_auth_set_dhchap_negotiate_data(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_dhchap_queue_context *chap)\n{\n\tstruct nvmf_auth_dhchap_negotiate_data *data = chap->buf;\n\tsize_t size = sizeof(*data) + sizeof(union nvmf_auth_protocol);\n\n\tif (size > CHAP_BUF_SIZE) {\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD;\n\t\treturn -EINVAL;\n\t}\n\tmemset((u8 *)chap->buf, 0, size);\n\tdata->auth_type = NVME_AUTH_COMMON_MESSAGES;\n\tdata->auth_id = NVME_AUTH_DHCHAP_MESSAGE_NEGOTIATE;\n\tdata->t_id = cpu_to_le16(chap->transaction);\n\tdata->sc_c = 0;  \n\tdata->napd = 1;\n\tdata->auth_protocol[0].dhchap.authid = NVME_AUTH_DHCHAP_AUTH_ID;\n\tdata->auth_protocol[0].dhchap.halen = 3;\n\tdata->auth_protocol[0].dhchap.dhlen = 6;\n\tdata->auth_protocol[0].dhchap.idlist[0] = NVME_AUTH_HASH_SHA256;\n\tdata->auth_protocol[0].dhchap.idlist[1] = NVME_AUTH_HASH_SHA384;\n\tdata->auth_protocol[0].dhchap.idlist[2] = NVME_AUTH_HASH_SHA512;\n\tdata->auth_protocol[0].dhchap.idlist[30] = NVME_AUTH_DHGROUP_NULL;\n\tdata->auth_protocol[0].dhchap.idlist[31] = NVME_AUTH_DHGROUP_2048;\n\tdata->auth_protocol[0].dhchap.idlist[32] = NVME_AUTH_DHGROUP_3072;\n\tdata->auth_protocol[0].dhchap.idlist[33] = NVME_AUTH_DHGROUP_4096;\n\tdata->auth_protocol[0].dhchap.idlist[34] = NVME_AUTH_DHGROUP_6144;\n\tdata->auth_protocol[0].dhchap.idlist[35] = NVME_AUTH_DHGROUP_8192;\n\n\treturn size;\n}\n\nstatic int nvme_auth_process_dhchap_challenge(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_dhchap_queue_context *chap)\n{\n\tstruct nvmf_auth_dhchap_challenge_data *data = chap->buf;\n\tu16 dhvlen = le16_to_cpu(data->dhvlen);\n\tsize_t size = sizeof(*data) + data->hl + dhvlen;\n\tconst char *gid_name = nvme_auth_dhgroup_name(data->dhgid);\n\tconst char *hmac_name, *kpp_name;\n\n\tif (size > CHAP_BUF_SIZE) {\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD;\n\t\treturn -EINVAL;\n\t}\n\n\thmac_name = nvme_auth_hmac_name(data->hashid);\n\tif (!hmac_name) {\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid %d: invalid HASH ID %d\\n\",\n\t\t\t chap->qid, data->hashid);\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_HASH_UNUSABLE;\n\t\treturn -EPROTO;\n\t}\n\n\tif (chap->hash_id == data->hashid && chap->shash_tfm &&\n\t    !strcmp(crypto_shash_alg_name(chap->shash_tfm), hmac_name) &&\n\t    crypto_shash_digestsize(chap->shash_tfm) == data->hl) {\n\t\tdev_dbg(ctrl->device,\n\t\t\t\"qid %d: reuse existing hash %s\\n\",\n\t\t\tchap->qid, hmac_name);\n\t\tgoto select_kpp;\n\t}\n\n\t \n\tif (chap->shash_tfm) {\n\t\tcrypto_free_shash(chap->shash_tfm);\n\t\tchap->hash_id = 0;\n\t\tchap->hash_len = 0;\n\t}\n\tchap->shash_tfm = crypto_alloc_shash(hmac_name, 0,\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY);\n\tif (IS_ERR(chap->shash_tfm)) {\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid %d: failed to allocate hash %s, error %ld\\n\",\n\t\t\t chap->qid, hmac_name, PTR_ERR(chap->shash_tfm));\n\t\tchap->shash_tfm = NULL;\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\t\treturn -ENOMEM;\n\t}\n\n\tif (crypto_shash_digestsize(chap->shash_tfm) != data->hl) {\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid %d: invalid hash length %d\\n\",\n\t\t\t chap->qid, data->hl);\n\t\tcrypto_free_shash(chap->shash_tfm);\n\t\tchap->shash_tfm = NULL;\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_HASH_UNUSABLE;\n\t\treturn -EPROTO;\n\t}\n\n\tchap->hash_id = data->hashid;\n\tchap->hash_len = data->hl;\n\tdev_dbg(ctrl->device, \"qid %d: selected hash %s\\n\",\n\t\tchap->qid, hmac_name);\n\nselect_kpp:\n\tkpp_name = nvme_auth_dhgroup_kpp(data->dhgid);\n\tif (!kpp_name) {\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid %d: invalid DH group id %d\\n\",\n\t\t\t chap->qid, data->dhgid);\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_DHGROUP_UNUSABLE;\n\t\t \n\t\treturn -EPROTO;\n\t}\n\n\tif (chap->dhgroup_id == data->dhgid &&\n\t    (data->dhgid == NVME_AUTH_DHGROUP_NULL || chap->dh_tfm)) {\n\t\tdev_dbg(ctrl->device,\n\t\t\t\"qid %d: reuse existing DH group %s\\n\",\n\t\t\tchap->qid, gid_name);\n\t\tgoto skip_kpp;\n\t}\n\n\t \n\tif (chap->dh_tfm) {\n\t\tcrypto_free_kpp(chap->dh_tfm);\n\t\tchap->dh_tfm = NULL;\n\t}\n\n\tif (data->dhgid != NVME_AUTH_DHGROUP_NULL) {\n\t\tif (dhvlen == 0) {\n\t\t\tdev_warn(ctrl->device,\n\t\t\t\t \"qid %d: empty DH value\\n\",\n\t\t\t\t chap->qid);\n\t\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_DHGROUP_UNUSABLE;\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tchap->dh_tfm = crypto_alloc_kpp(kpp_name, 0, 0);\n\t\tif (IS_ERR(chap->dh_tfm)) {\n\t\t\tint ret = PTR_ERR(chap->dh_tfm);\n\n\t\t\tdev_warn(ctrl->device,\n\t\t\t\t \"qid %d: error %d initializing DH group %s\\n\",\n\t\t\t\t chap->qid, ret, gid_name);\n\t\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_DHGROUP_UNUSABLE;\n\t\t\tchap->dh_tfm = NULL;\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(ctrl->device, \"qid %d: selected DH group %s\\n\",\n\t\t\tchap->qid, gid_name);\n\t} else if (dhvlen != 0) {\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid %d: invalid DH value for NULL DH\\n\",\n\t\t\t chap->qid);\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD;\n\t\treturn -EPROTO;\n\t}\n\tchap->dhgroup_id = data->dhgid;\n\nskip_kpp:\n\tchap->s1 = le32_to_cpu(data->seqnum);\n\tmemcpy(chap->c1, data->cval, chap->hash_len);\n\tif (dhvlen) {\n\t\tchap->ctrl_key = kmalloc(dhvlen, GFP_KERNEL);\n\t\tif (!chap->ctrl_key) {\n\t\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tchap->ctrl_key_len = dhvlen;\n\t\tmemcpy(chap->ctrl_key, data->cval + chap->hash_len,\n\t\t       dhvlen);\n\t\tdev_dbg(ctrl->device, \"ctrl public key %*ph\\n\",\n\t\t\t (int)chap->ctrl_key_len, chap->ctrl_key);\n\t}\n\n\treturn 0;\n}\n\nstatic int nvme_auth_set_dhchap_reply_data(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_dhchap_queue_context *chap)\n{\n\tstruct nvmf_auth_dhchap_reply_data *data = chap->buf;\n\tsize_t size = sizeof(*data);\n\n\tsize += 2 * chap->hash_len;\n\n\tif (chap->host_key_len)\n\t\tsize += chap->host_key_len;\n\n\tif (size > CHAP_BUF_SIZE) {\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD;\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(chap->buf, 0, size);\n\tdata->auth_type = NVME_AUTH_DHCHAP_MESSAGES;\n\tdata->auth_id = NVME_AUTH_DHCHAP_MESSAGE_REPLY;\n\tdata->t_id = cpu_to_le16(chap->transaction);\n\tdata->hl = chap->hash_len;\n\tdata->dhvlen = cpu_to_le16(chap->host_key_len);\n\tmemcpy(data->rval, chap->response, chap->hash_len);\n\tif (ctrl->ctrl_key) {\n\t\tget_random_bytes(chap->c2, chap->hash_len);\n\t\tdata->cvalid = 1;\n\t\tchap->s2 = nvme_auth_get_seqnum();\n\t\tmemcpy(data->rval + chap->hash_len, chap->c2,\n\t\t       chap->hash_len);\n\t\tdev_dbg(ctrl->device, \"%s: qid %d ctrl challenge %*ph\\n\",\n\t\t\t__func__, chap->qid, (int)chap->hash_len, chap->c2);\n\t} else {\n\t\tmemset(chap->c2, 0, chap->hash_len);\n\t\tchap->s2 = 0;\n\t}\n\tdata->seqnum = cpu_to_le32(chap->s2);\n\tif (chap->host_key_len) {\n\t\tdev_dbg(ctrl->device, \"%s: qid %d host public key %*ph\\n\",\n\t\t\t__func__, chap->qid,\n\t\t\tchap->host_key_len, chap->host_key);\n\t\tmemcpy(data->rval + 2 * chap->hash_len, chap->host_key,\n\t\t       chap->host_key_len);\n\t}\n\n\treturn size;\n}\n\nstatic int nvme_auth_process_dhchap_success1(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_dhchap_queue_context *chap)\n{\n\tstruct nvmf_auth_dhchap_success1_data *data = chap->buf;\n\tsize_t size = sizeof(*data);\n\n\tif (chap->s2)\n\t\tsize += chap->hash_len;\n\n\tif (size > CHAP_BUF_SIZE) {\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD;\n\t\treturn -EINVAL;\n\t}\n\n\tif (data->hl != chap->hash_len) {\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid %d: invalid hash length %u\\n\",\n\t\t\t chap->qid, data->hl);\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_HASH_UNUSABLE;\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tif (chap->qid == 0)\n\t\tdev_info(ctrl->device,\n\t\t\t \"qid 0: authenticated with hash %s dhgroup %s\\n\",\n\t\t\t nvme_auth_hmac_name(chap->hash_id),\n\t\t\t nvme_auth_dhgroup_name(chap->dhgroup_id));\n\n\tif (!data->rvalid)\n\t\treturn 0;\n\n\t \n\tif (memcmp(chap->response, data->rval, data->hl)) {\n\t\tdev_dbg(ctrl->device, \"%s: qid %d ctrl response %*ph\\n\",\n\t\t\t__func__, chap->qid, (int)chap->hash_len, data->rval);\n\t\tdev_dbg(ctrl->device, \"%s: qid %d host response %*ph\\n\",\n\t\t\t__func__, chap->qid, (int)chap->hash_len,\n\t\t\tchap->response);\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid %d: controller authentication failed\\n\",\n\t\t\t chap->qid);\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\t\treturn -ECONNREFUSED;\n\t}\n\n\t \n\tif (chap->qid == 0)\n\t\tdev_info(ctrl->device,\n\t\t\t \"qid 0: controller authenticated\\n\");\n\treturn 0;\n}\n\nstatic int nvme_auth_set_dhchap_success2_data(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_dhchap_queue_context *chap)\n{\n\tstruct nvmf_auth_dhchap_success2_data *data = chap->buf;\n\tsize_t size = sizeof(*data);\n\n\tmemset(chap->buf, 0, size);\n\tdata->auth_type = NVME_AUTH_DHCHAP_MESSAGES;\n\tdata->auth_id = NVME_AUTH_DHCHAP_MESSAGE_SUCCESS2;\n\tdata->t_id = cpu_to_le16(chap->transaction);\n\n\treturn size;\n}\n\nstatic int nvme_auth_set_dhchap_failure2_data(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_dhchap_queue_context *chap)\n{\n\tstruct nvmf_auth_dhchap_failure_data *data = chap->buf;\n\tsize_t size = sizeof(*data);\n\n\tmemset(chap->buf, 0, size);\n\tdata->auth_type = NVME_AUTH_COMMON_MESSAGES;\n\tdata->auth_id = NVME_AUTH_DHCHAP_MESSAGE_FAILURE2;\n\tdata->t_id = cpu_to_le16(chap->transaction);\n\tdata->rescode = NVME_AUTH_DHCHAP_FAILURE_REASON_FAILED;\n\tdata->rescode_exp = chap->status;\n\n\treturn size;\n}\n\nstatic int nvme_auth_dhchap_setup_host_response(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_dhchap_queue_context *chap)\n{\n\tSHASH_DESC_ON_STACK(shash, chap->shash_tfm);\n\tu8 buf[4], *challenge = chap->c1;\n\tint ret;\n\n\tdev_dbg(ctrl->device, \"%s: qid %d host response seq %u transaction %d\\n\",\n\t\t__func__, chap->qid, chap->s1, chap->transaction);\n\n\tif (!chap->host_response) {\n\t\tchap->host_response = nvme_auth_transform_key(ctrl->host_key,\n\t\t\t\t\t\tctrl->opts->host->nqn);\n\t\tif (IS_ERR(chap->host_response)) {\n\t\t\tret = PTR_ERR(chap->host_response);\n\t\t\tchap->host_response = NULL;\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tdev_dbg(ctrl->device, \"%s: qid %d re-using host response\\n\",\n\t\t\t__func__, chap->qid);\n\t}\n\n\tret = crypto_shash_setkey(chap->shash_tfm,\n\t\t\tchap->host_response, ctrl->host_key->len);\n\tif (ret) {\n\t\tdev_warn(ctrl->device, \"qid %d: failed to set key, error %d\\n\",\n\t\t\t chap->qid, ret);\n\t\tgoto out;\n\t}\n\n\tif (chap->dh_tfm) {\n\t\tchallenge = kmalloc(chap->hash_len, GFP_KERNEL);\n\t\tif (!challenge) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = nvme_auth_augmented_challenge(chap->hash_id,\n\t\t\t\t\t\t    chap->sess_key,\n\t\t\t\t\t\t    chap->sess_key_len,\n\t\t\t\t\t\t    chap->c1, challenge,\n\t\t\t\t\t\t    chap->hash_len);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tshash->tfm = chap->shash_tfm;\n\tret = crypto_shash_init(shash);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, challenge, chap->hash_len);\n\tif (ret)\n\t\tgoto out;\n\tput_unaligned_le32(chap->s1, buf);\n\tret = crypto_shash_update(shash, buf, 4);\n\tif (ret)\n\t\tgoto out;\n\tput_unaligned_le16(chap->transaction, buf);\n\tret = crypto_shash_update(shash, buf, 2);\n\tif (ret)\n\t\tgoto out;\n\tmemset(buf, 0, sizeof(buf));\n\tret = crypto_shash_update(shash, buf, 1);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, \"HostHost\", 8);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, ctrl->opts->host->nqn,\n\t\t\t\t  strlen(ctrl->opts->host->nqn));\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, buf, 1);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, ctrl->opts->subsysnqn,\n\t\t\t    strlen(ctrl->opts->subsysnqn));\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_final(shash, chap->response);\nout:\n\tif (challenge != chap->c1)\n\t\tkfree(challenge);\n\treturn ret;\n}\n\nstatic int nvme_auth_dhchap_setup_ctrl_response(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_dhchap_queue_context *chap)\n{\n\tSHASH_DESC_ON_STACK(shash, chap->shash_tfm);\n\tu8 *ctrl_response;\n\tu8 buf[4], *challenge = chap->c2;\n\tint ret;\n\n\tctrl_response = nvme_auth_transform_key(ctrl->ctrl_key,\n\t\t\t\tctrl->opts->subsysnqn);\n\tif (IS_ERR(ctrl_response)) {\n\t\tret = PTR_ERR(ctrl_response);\n\t\treturn ret;\n\t}\n\n\tret = crypto_shash_setkey(chap->shash_tfm,\n\t\t\tctrl_response, ctrl->ctrl_key->len);\n\tif (ret) {\n\t\tdev_warn(ctrl->device, \"qid %d: failed to set key, error %d\\n\",\n\t\t\t chap->qid, ret);\n\t\tgoto out;\n\t}\n\n\tif (chap->dh_tfm) {\n\t\tchallenge = kmalloc(chap->hash_len, GFP_KERNEL);\n\t\tif (!challenge) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = nvme_auth_augmented_challenge(chap->hash_id,\n\t\t\t\t\t\t    chap->sess_key,\n\t\t\t\t\t\t    chap->sess_key_len,\n\t\t\t\t\t\t    chap->c2, challenge,\n\t\t\t\t\t\t    chap->hash_len);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tdev_dbg(ctrl->device, \"%s: qid %d ctrl response seq %u transaction %d\\n\",\n\t\t__func__, chap->qid, chap->s2, chap->transaction);\n\tdev_dbg(ctrl->device, \"%s: qid %d challenge %*ph\\n\",\n\t\t__func__, chap->qid, (int)chap->hash_len, challenge);\n\tdev_dbg(ctrl->device, \"%s: qid %d subsysnqn %s\\n\",\n\t\t__func__, chap->qid, ctrl->opts->subsysnqn);\n\tdev_dbg(ctrl->device, \"%s: qid %d hostnqn %s\\n\",\n\t\t__func__, chap->qid, ctrl->opts->host->nqn);\n\tshash->tfm = chap->shash_tfm;\n\tret = crypto_shash_init(shash);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, challenge, chap->hash_len);\n\tif (ret)\n\t\tgoto out;\n\tput_unaligned_le32(chap->s2, buf);\n\tret = crypto_shash_update(shash, buf, 4);\n\tif (ret)\n\t\tgoto out;\n\tput_unaligned_le16(chap->transaction, buf);\n\tret = crypto_shash_update(shash, buf, 2);\n\tif (ret)\n\t\tgoto out;\n\tmemset(buf, 0, 4);\n\tret = crypto_shash_update(shash, buf, 1);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, \"Controller\", 10);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, ctrl->opts->subsysnqn,\n\t\t\t\t  strlen(ctrl->opts->subsysnqn));\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, buf, 1);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, ctrl->opts->host->nqn,\n\t\t\t\t  strlen(ctrl->opts->host->nqn));\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_final(shash, chap->response);\nout:\n\tif (challenge != chap->c2)\n\t\tkfree(challenge);\n\tkfree(ctrl_response);\n\treturn ret;\n}\n\nstatic int nvme_auth_dhchap_exponential(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_dhchap_queue_context *chap)\n{\n\tint ret;\n\n\tif (chap->host_key && chap->host_key_len) {\n\t\tdev_dbg(ctrl->device,\n\t\t\t\"qid %d: reusing host key\\n\", chap->qid);\n\t\tgoto gen_sesskey;\n\t}\n\tret = nvme_auth_gen_privkey(chap->dh_tfm, chap->dhgroup_id);\n\tif (ret < 0) {\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD;\n\t\treturn ret;\n\t}\n\n\tchap->host_key_len = crypto_kpp_maxsize(chap->dh_tfm);\n\n\tchap->host_key = kzalloc(chap->host_key_len, GFP_KERNEL);\n\tif (!chap->host_key) {\n\t\tchap->host_key_len = 0;\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\t\treturn -ENOMEM;\n\t}\n\tret = nvme_auth_gen_pubkey(chap->dh_tfm,\n\t\t\t\t   chap->host_key, chap->host_key_len);\n\tif (ret) {\n\t\tdev_dbg(ctrl->device,\n\t\t\t\"failed to generate public key, error %d\\n\", ret);\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD;\n\t\treturn ret;\n\t}\n\ngen_sesskey:\n\tchap->sess_key_len = chap->host_key_len;\n\tchap->sess_key = kmalloc(chap->sess_key_len, GFP_KERNEL);\n\tif (!chap->sess_key) {\n\t\tchap->sess_key_len = 0;\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\t\treturn -ENOMEM;\n\t}\n\n\tret = nvme_auth_gen_shared_secret(chap->dh_tfm,\n\t\t\t\t\t  chap->ctrl_key, chap->ctrl_key_len,\n\t\t\t\t\t  chap->sess_key, chap->sess_key_len);\n\tif (ret) {\n\t\tdev_dbg(ctrl->device,\n\t\t\t\"failed to generate shared secret, error %d\\n\", ret);\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD;\n\t\treturn ret;\n\t}\n\tdev_dbg(ctrl->device, \"shared secret %*ph\\n\",\n\t\t(int)chap->sess_key_len, chap->sess_key);\n\treturn 0;\n}\n\nstatic void nvme_auth_reset_dhchap(struct nvme_dhchap_queue_context *chap)\n{\n\tkfree_sensitive(chap->host_response);\n\tchap->host_response = NULL;\n\tkfree_sensitive(chap->host_key);\n\tchap->host_key = NULL;\n\tchap->host_key_len = 0;\n\tkfree_sensitive(chap->ctrl_key);\n\tchap->ctrl_key = NULL;\n\tchap->ctrl_key_len = 0;\n\tkfree_sensitive(chap->sess_key);\n\tchap->sess_key = NULL;\n\tchap->sess_key_len = 0;\n\tchap->status = 0;\n\tchap->error = 0;\n\tchap->s1 = 0;\n\tchap->s2 = 0;\n\tchap->transaction = 0;\n\tmemset(chap->c1, 0, sizeof(chap->c1));\n\tmemset(chap->c2, 0, sizeof(chap->c2));\n\tmempool_free(chap->buf, nvme_chap_buf_pool);\n\tchap->buf = NULL;\n}\n\nstatic void nvme_auth_free_dhchap(struct nvme_dhchap_queue_context *chap)\n{\n\tnvme_auth_reset_dhchap(chap);\n\tif (chap->shash_tfm)\n\t\tcrypto_free_shash(chap->shash_tfm);\n\tif (chap->dh_tfm)\n\t\tcrypto_free_kpp(chap->dh_tfm);\n}\n\nstatic void nvme_queue_auth_work(struct work_struct *work)\n{\n\tstruct nvme_dhchap_queue_context *chap =\n\t\tcontainer_of(work, struct nvme_dhchap_queue_context, auth_work);\n\tstruct nvme_ctrl *ctrl = chap->ctrl;\n\tsize_t tl;\n\tint ret = 0;\n\n\t \n\tchap->buf = mempool_alloc(nvme_chap_buf_pool, GFP_KERNEL);\n\tif (!chap->buf) {\n\t\tchap->error = -ENOMEM;\n\t\treturn;\n\t}\n\n\tchap->transaction = ctrl->transaction++;\n\n\t \n\tdev_dbg(ctrl->device, \"%s: qid %d send negotiate\\n\",\n\t\t__func__, chap->qid);\n\tret = nvme_auth_set_dhchap_negotiate_data(ctrl, chap);\n\tif (ret < 0) {\n\t\tchap->error = ret;\n\t\treturn;\n\t}\n\ttl = ret;\n\tret = nvme_auth_submit(ctrl, chap->qid, chap->buf, tl, true);\n\tif (ret) {\n\t\tchap->error = ret;\n\t\treturn;\n\t}\n\n\t \n\tdev_dbg(ctrl->device, \"%s: qid %d receive challenge\\n\",\n\t\t__func__, chap->qid);\n\n\tmemset(chap->buf, 0, CHAP_BUF_SIZE);\n\tret = nvme_auth_submit(ctrl, chap->qid, chap->buf, CHAP_BUF_SIZE,\n\t\t\t       false);\n\tif (ret) {\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid %d failed to receive challenge, %s %d\\n\",\n\t\t\t chap->qid, ret < 0 ? \"error\" : \"nvme status\", ret);\n\t\tchap->error = ret;\n\t\treturn;\n\t}\n\tret = nvme_auth_receive_validate(ctrl, chap->qid, chap->buf, chap->transaction,\n\t\t\t\t\t NVME_AUTH_DHCHAP_MESSAGE_CHALLENGE);\n\tif (ret) {\n\t\tchap->status = ret;\n\t\tchap->error = -ECONNREFUSED;\n\t\treturn;\n\t}\n\n\tret = nvme_auth_process_dhchap_challenge(ctrl, chap);\n\tif (ret) {\n\t\t \n\t\tchap->error = ret;\n\t\tgoto fail2;\n\t}\n\n\tif (chap->ctrl_key_len) {\n\t\tdev_dbg(ctrl->device,\n\t\t\t\"%s: qid %d DH exponential\\n\",\n\t\t\t__func__, chap->qid);\n\t\tret = nvme_auth_dhchap_exponential(ctrl, chap);\n\t\tif (ret) {\n\t\t\tchap->error = ret;\n\t\t\tgoto fail2;\n\t\t}\n\t}\n\n\tdev_dbg(ctrl->device, \"%s: qid %d host response\\n\",\n\t\t__func__, chap->qid);\n\tmutex_lock(&ctrl->dhchap_auth_mutex);\n\tret = nvme_auth_dhchap_setup_host_response(ctrl, chap);\n\tif (ret) {\n\t\tmutex_unlock(&ctrl->dhchap_auth_mutex);\n\t\tchap->error = ret;\n\t\tgoto fail2;\n\t}\n\tmutex_unlock(&ctrl->dhchap_auth_mutex);\n\n\t \n\tdev_dbg(ctrl->device, \"%s: qid %d send reply\\n\",\n\t\t__func__, chap->qid);\n\tret = nvme_auth_set_dhchap_reply_data(ctrl, chap);\n\tif (ret < 0) {\n\t\tchap->error = ret;\n\t\tgoto fail2;\n\t}\n\n\ttl = ret;\n\tret = nvme_auth_submit(ctrl, chap->qid, chap->buf, tl, true);\n\tif (ret) {\n\t\tchap->error = ret;\n\t\tgoto fail2;\n\t}\n\n\t \n\tdev_dbg(ctrl->device, \"%s: qid %d receive success1\\n\",\n\t\t__func__, chap->qid);\n\n\tmemset(chap->buf, 0, CHAP_BUF_SIZE);\n\tret = nvme_auth_submit(ctrl, chap->qid, chap->buf, CHAP_BUF_SIZE,\n\t\t\t       false);\n\tif (ret) {\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid %d failed to receive success1, %s %d\\n\",\n\t\t\t chap->qid, ret < 0 ? \"error\" : \"nvme status\", ret);\n\t\tchap->error = ret;\n\t\treturn;\n\t}\n\tret = nvme_auth_receive_validate(ctrl, chap->qid,\n\t\t\t\t\t chap->buf, chap->transaction,\n\t\t\t\t\t NVME_AUTH_DHCHAP_MESSAGE_SUCCESS1);\n\tif (ret) {\n\t\tchap->status = ret;\n\t\tchap->error = -ECONNREFUSED;\n\t\treturn;\n\t}\n\n\tmutex_lock(&ctrl->dhchap_auth_mutex);\n\tif (ctrl->ctrl_key) {\n\t\tdev_dbg(ctrl->device,\n\t\t\t\"%s: qid %d controller response\\n\",\n\t\t\t__func__, chap->qid);\n\t\tret = nvme_auth_dhchap_setup_ctrl_response(ctrl, chap);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&ctrl->dhchap_auth_mutex);\n\t\t\tchap->error = ret;\n\t\t\tgoto fail2;\n\t\t}\n\t}\n\tmutex_unlock(&ctrl->dhchap_auth_mutex);\n\n\tret = nvme_auth_process_dhchap_success1(ctrl, chap);\n\tif (ret) {\n\t\t \n\t\tchap->error = -ECONNREFUSED;\n\t\tgoto fail2;\n\t}\n\n\tif (chap->s2) {\n\t\t \n\t\tdev_dbg(ctrl->device, \"%s: qid %d send success2\\n\",\n\t\t\t__func__, chap->qid);\n\t\ttl = nvme_auth_set_dhchap_success2_data(ctrl, chap);\n\t\tret = nvme_auth_submit(ctrl, chap->qid, chap->buf, tl, true);\n\t\tif (ret)\n\t\t\tchap->error = ret;\n\t}\n\tif (!ret) {\n\t\tchap->error = 0;\n\t\treturn;\n\t}\n\nfail2:\n\tif (chap->status == 0)\n\t\tchap->status = NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\tdev_dbg(ctrl->device, \"%s: qid %d send failure2, status %x\\n\",\n\t\t__func__, chap->qid, chap->status);\n\ttl = nvme_auth_set_dhchap_failure2_data(ctrl, chap);\n\tret = nvme_auth_submit(ctrl, chap->qid, chap->buf, tl, true);\n\t \n\tif (ret && !chap->error)\n\t\tchap->error = ret;\n}\n\nint nvme_auth_negotiate(struct nvme_ctrl *ctrl, int qid)\n{\n\tstruct nvme_dhchap_queue_context *chap;\n\n\tif (!ctrl->host_key) {\n\t\tdev_warn(ctrl->device, \"qid %d: no key\\n\", qid);\n\t\treturn -ENOKEY;\n\t}\n\n\tif (ctrl->opts->dhchap_ctrl_secret && !ctrl->ctrl_key) {\n\t\tdev_warn(ctrl->device, \"qid %d: invalid ctrl key\\n\", qid);\n\t\treturn -ENOKEY;\n\t}\n\n\tchap = &ctrl->dhchap_ctxs[qid];\n\tcancel_work_sync(&chap->auth_work);\n\tqueue_work(nvme_auth_wq, &chap->auth_work);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_negotiate);\n\nint nvme_auth_wait(struct nvme_ctrl *ctrl, int qid)\n{\n\tstruct nvme_dhchap_queue_context *chap;\n\tint ret;\n\n\tchap = &ctrl->dhchap_ctxs[qid];\n\tflush_work(&chap->auth_work);\n\tret = chap->error;\n\t \n\tnvme_auth_reset_dhchap(chap);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_wait);\n\nstatic void nvme_ctrl_auth_work(struct work_struct *work)\n{\n\tstruct nvme_ctrl *ctrl =\n\t\tcontainer_of(work, struct nvme_ctrl, dhchap_auth_work);\n\tint ret, q;\n\n\t \n\tif (ctrl->state != NVME_CTRL_LIVE)\n\t\treturn;\n\n\t \n\tret = nvme_auth_negotiate(ctrl, 0);\n\tif (ret) {\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid 0: error %d setting up authentication\\n\", ret);\n\t\treturn;\n\t}\n\tret = nvme_auth_wait(ctrl, 0);\n\tif (ret) {\n\t\tdev_warn(ctrl->device,\n\t\t\t \"qid 0: authentication failed\\n\");\n\t\treturn;\n\t}\n\n\tfor (q = 1; q < ctrl->queue_count; q++) {\n\t\tret = nvme_auth_negotiate(ctrl, q);\n\t\tif (ret) {\n\t\t\tdev_warn(ctrl->device,\n\t\t\t\t \"qid %d: error %d setting up authentication\\n\",\n\t\t\t\t q, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (q = 1; q < ctrl->queue_count; q++) {\n\t\tret = nvme_auth_wait(ctrl, q);\n\t\tif (ret)\n\t\t\tdev_warn(ctrl->device,\n\t\t\t\t \"qid %d: authentication failed\\n\", q);\n\t}\n}\n\nint nvme_auth_init_ctrl(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_dhchap_queue_context *chap;\n\tint i, ret;\n\n\tmutex_init(&ctrl->dhchap_auth_mutex);\n\tINIT_WORK(&ctrl->dhchap_auth_work, nvme_ctrl_auth_work);\n\tif (!ctrl->opts)\n\t\treturn 0;\n\tret = nvme_auth_generate_key(ctrl->opts->dhchap_secret,\n\t\t\t&ctrl->host_key);\n\tif (ret)\n\t\treturn ret;\n\tret = nvme_auth_generate_key(ctrl->opts->dhchap_ctrl_secret,\n\t\t\t&ctrl->ctrl_key);\n\tif (ret)\n\t\tgoto err_free_dhchap_secret;\n\n\tif (!ctrl->opts->dhchap_secret && !ctrl->opts->dhchap_ctrl_secret)\n\t\treturn 0;\n\n\tctrl->dhchap_ctxs = kvcalloc(ctrl_max_dhchaps(ctrl),\n\t\t\t\tsizeof(*chap), GFP_KERNEL);\n\tif (!ctrl->dhchap_ctxs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_dhchap_ctrl_secret;\n\t}\n\n\tfor (i = 0; i < ctrl_max_dhchaps(ctrl); i++) {\n\t\tchap = &ctrl->dhchap_ctxs[i];\n\t\tchap->qid = i;\n\t\tchap->ctrl = ctrl;\n\t\tINIT_WORK(&chap->auth_work, nvme_queue_auth_work);\n\t}\n\n\treturn 0;\nerr_free_dhchap_ctrl_secret:\n\tnvme_auth_free_key(ctrl->ctrl_key);\n\tctrl->ctrl_key = NULL;\nerr_free_dhchap_secret:\n\tnvme_auth_free_key(ctrl->host_key);\n\tctrl->host_key = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_init_ctrl);\n\nvoid nvme_auth_stop(struct nvme_ctrl *ctrl)\n{\n\tcancel_work_sync(&ctrl->dhchap_auth_work);\n}\nEXPORT_SYMBOL_GPL(nvme_auth_stop);\n\nvoid nvme_auth_free(struct nvme_ctrl *ctrl)\n{\n\tint i;\n\n\tif (ctrl->dhchap_ctxs) {\n\t\tfor (i = 0; i < ctrl_max_dhchaps(ctrl); i++)\n\t\t\tnvme_auth_free_dhchap(&ctrl->dhchap_ctxs[i]);\n\t\tkfree(ctrl->dhchap_ctxs);\n\t}\n\tif (ctrl->host_key) {\n\t\tnvme_auth_free_key(ctrl->host_key);\n\t\tctrl->host_key = NULL;\n\t}\n\tif (ctrl->ctrl_key) {\n\t\tnvme_auth_free_key(ctrl->ctrl_key);\n\t\tctrl->ctrl_key = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(nvme_auth_free);\n\nint __init nvme_init_auth(void)\n{\n\tnvme_auth_wq = alloc_workqueue(\"nvme-auth-wq\",\n\t\t\t       WQ_UNBOUND | WQ_MEM_RECLAIM | WQ_SYSFS, 0);\n\tif (!nvme_auth_wq)\n\t\treturn -ENOMEM;\n\n\tnvme_chap_buf_cache = kmem_cache_create(\"nvme-chap-buf-cache\",\n\t\t\t\tCHAP_BUF_SIZE, 0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!nvme_chap_buf_cache)\n\t\tgoto err_destroy_workqueue;\n\n\tnvme_chap_buf_pool = mempool_create(16, mempool_alloc_slab,\n\t\t\tmempool_free_slab, nvme_chap_buf_cache);\n\tif (!nvme_chap_buf_pool)\n\t\tgoto err_destroy_chap_buf_cache;\n\n\treturn 0;\nerr_destroy_chap_buf_cache:\n\tkmem_cache_destroy(nvme_chap_buf_cache);\nerr_destroy_workqueue:\n\tdestroy_workqueue(nvme_auth_wq);\n\treturn -ENOMEM;\n}\n\nvoid __exit nvme_exit_auth(void)\n{\n\tmempool_destroy(nvme_chap_buf_pool);\n\tkmem_cache_destroy(nvme_chap_buf_cache);\n\tdestroy_workqueue(nvme_auth_wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}