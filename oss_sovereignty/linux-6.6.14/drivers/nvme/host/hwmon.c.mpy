{
  "module_name": "hwmon.c",
  "hash_id": "654c9525f9e18ad129db11fe800a2d70d4f764292ace4c6fb730858f4e6f424d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/host/hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/hwmon.h>\n#include <linux/units.h>\n#include <asm/unaligned.h>\n\n#include \"nvme.h\"\n\nstruct nvme_hwmon_data {\n\tstruct nvme_ctrl *ctrl;\n\tstruct nvme_smart_log *log;\n\tstruct mutex read_lock;\n};\n\nstatic int nvme_get_temp_thresh(struct nvme_ctrl *ctrl, int sensor, bool under,\n\t\t\t\tlong *temp)\n{\n\tunsigned int threshold = sensor << NVME_TEMP_THRESH_SELECT_SHIFT;\n\tu32 status;\n\tint ret;\n\n\tif (under)\n\t\tthreshold |= NVME_TEMP_THRESH_TYPE_UNDER;\n\n\tret = nvme_get_features(ctrl, NVME_FEAT_TEMP_THRESH, threshold, NULL, 0,\n\t\t\t\t&status);\n\tif (ret > 0)\n\t\treturn -EIO;\n\tif (ret < 0)\n\t\treturn ret;\n\t*temp = kelvin_to_millicelsius(status & NVME_TEMP_THRESH_MASK);\n\n\treturn 0;\n}\n\nstatic int nvme_set_temp_thresh(struct nvme_ctrl *ctrl, int sensor, bool under,\n\t\t\t\tlong temp)\n{\n\tunsigned int threshold = sensor << NVME_TEMP_THRESH_SELECT_SHIFT;\n\tint ret;\n\n\ttemp = millicelsius_to_kelvin(temp);\n\tthreshold |= clamp_val(temp, 0, NVME_TEMP_THRESH_MASK);\n\n\tif (under)\n\t\tthreshold |= NVME_TEMP_THRESH_TYPE_UNDER;\n\n\tret = nvme_set_features(ctrl, NVME_FEAT_TEMP_THRESH, threshold, NULL, 0,\n\t\t\t\tNULL);\n\tif (ret > 0)\n\t\treturn -EIO;\n\n\treturn ret;\n}\n\nstatic int nvme_hwmon_get_smart_log(struct nvme_hwmon_data *data)\n{\n\treturn nvme_get_log(data->ctrl, NVME_NSID_ALL, NVME_LOG_SMART, 0,\n\t\t\t   NVME_CSI_NVM, data->log, sizeof(*data->log), 0);\n}\n\nstatic int nvme_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t   u32 attr, int channel, long *val)\n{\n\tstruct nvme_hwmon_data *data = dev_get_drvdata(dev);\n\tstruct nvme_smart_log *log = data->log;\n\tint temp;\n\tint err;\n\n\t \n\tswitch (attr) {\n\tcase hwmon_temp_max:\n\t\treturn nvme_get_temp_thresh(data->ctrl, channel, false, val);\n\tcase hwmon_temp_min:\n\t\treturn nvme_get_temp_thresh(data->ctrl, channel, true, val);\n\tcase hwmon_temp_crit:\n\t\t*val = kelvin_to_millicelsius(data->ctrl->cctemp);\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_lock(&data->read_lock);\n\terr = nvme_hwmon_get_smart_log(data);\n\tif (err)\n\t\tgoto unlock;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tif (!channel)\n\t\t\ttemp = get_unaligned_le16(log->temperature);\n\t\telse\n\t\t\ttemp = le16_to_cpu(log->temp_sensor[channel - 1]);\n\t\t*val = kelvin_to_millicelsius(temp);\n\t\tbreak;\n\tcase hwmon_temp_alarm:\n\t\t*val = !!(log->critical_warning & NVME_SMART_CRIT_TEMPERATURE);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\nunlock:\n\tmutex_unlock(&data->read_lock);\n\treturn err;\n}\n\nstatic int nvme_hwmon_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t    u32 attr, int channel, long val)\n{\n\tstruct nvme_hwmon_data *data = dev_get_drvdata(dev);\n\n\tswitch (attr) {\n\tcase hwmon_temp_max:\n\t\treturn nvme_set_temp_thresh(data->ctrl, channel, false, val);\n\tcase hwmon_temp_min:\n\t\treturn nvme_set_temp_thresh(data->ctrl, channel, true, val);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const char * const nvme_hwmon_sensor_names[] = {\n\t\"Composite\",\n\t\"Sensor 1\",\n\t\"Sensor 2\",\n\t\"Sensor 3\",\n\t\"Sensor 4\",\n\t\"Sensor 5\",\n\t\"Sensor 6\",\n\t\"Sensor 7\",\n\t\"Sensor 8\",\n};\n\nstatic int nvme_hwmon_read_string(struct device *dev,\n\t\t\t\t  enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t  int channel, const char **str)\n{\n\t*str = nvme_hwmon_sensor_names[channel];\n\treturn 0;\n}\n\nstatic umode_t nvme_hwmon_is_visible(const void *_data,\n\t\t\t\t     enum hwmon_sensor_types type,\n\t\t\t\t     u32 attr, int channel)\n{\n\tconst struct nvme_hwmon_data *data = _data;\n\n\tswitch (attr) {\n\tcase hwmon_temp_crit:\n\t\tif (!channel && data->ctrl->cctemp)\n\t\t\treturn 0444;\n\t\tbreak;\n\tcase hwmon_temp_max:\n\tcase hwmon_temp_min:\n\t\tif ((!channel && data->ctrl->wctemp) ||\n\t\t    (channel && data->log->temp_sensor[channel - 1] &&\n\t\t     !(data->ctrl->quirks &\n\t\t       NVME_QUIRK_NO_SECONDARY_TEMP_THRESH))) {\n\t\t\tif (data->ctrl->quirks &\n\t\t\t    NVME_QUIRK_NO_TEMP_THRESH_CHANGE)\n\t\t\t\treturn 0444;\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp_alarm:\n\t\tif (!channel)\n\t\t\treturn 0444;\n\t\tbreak;\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_label:\n\t\tif (!channel || data->log->temp_sensor[channel - 1])\n\t\t\treturn 0444;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info *const nvme_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t\tHWMON_T_CRIT | HWMON_T_LABEL | HWMON_T_ALARM,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t\tHWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t\tHWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t\tHWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t\tHWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t\tHWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t\tHWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t\tHWMON_T_LABEL,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t\tHWMON_T_LABEL),\n\tNULL\n};\n\nstatic const struct hwmon_ops nvme_hwmon_ops = {\n\t.is_visible\t= nvme_hwmon_is_visible,\n\t.read\t\t= nvme_hwmon_read,\n\t.read_string\t= nvme_hwmon_read_string,\n\t.write\t\t= nvme_hwmon_write,\n};\n\nstatic const struct hwmon_chip_info nvme_hwmon_chip_info = {\n\t.ops\t= &nvme_hwmon_ops,\n\t.info\t= nvme_hwmon_info,\n};\n\nint nvme_hwmon_init(struct nvme_ctrl *ctrl)\n{\n\tstruct device *dev = ctrl->device;\n\tstruct nvme_hwmon_data *data;\n\tstruct device *hwmon;\n\tint err;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->log = kzalloc(sizeof(*data->log), GFP_KERNEL);\n\tif (!data->log) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_data;\n\t}\n\n\tdata->ctrl = ctrl;\n\tmutex_init(&data->read_lock);\n\n\terr = nvme_hwmon_get_smart_log(data);\n\tif (err) {\n\t\tdev_warn(dev, \"Failed to read smart log (error %d)\\n\", err);\n\t\tgoto err_free_log;\n\t}\n\n\thwmon = hwmon_device_register_with_info(dev, \"nvme\",\n\t\t\t\t\t\tdata, &nvme_hwmon_chip_info,\n\t\t\t\t\t\tNULL);\n\tif (IS_ERR(hwmon)) {\n\t\tdev_warn(dev, \"Failed to instantiate hwmon device\\n\");\n\t\terr = PTR_ERR(hwmon);\n\t\tgoto err_free_log;\n\t}\n\tctrl->hwmon_device = hwmon;\n\treturn 0;\n\nerr_free_log:\n\tkfree(data->log);\nerr_free_data:\n\tkfree(data);\n\treturn err;\n}\n\nvoid nvme_hwmon_exit(struct nvme_ctrl *ctrl)\n{\n\tif (ctrl->hwmon_device) {\n\t\tstruct nvme_hwmon_data *data =\n\t\t\tdev_get_drvdata(ctrl->hwmon_device);\n\n\t\thwmon_device_unregister(ctrl->hwmon_device);\n\t\tctrl->hwmon_device = NULL;\n\t\tkfree(data->log);\n\t\tkfree(data);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}