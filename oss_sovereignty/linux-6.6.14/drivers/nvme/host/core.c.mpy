{
  "module_name": "core.c",
  "hash_id": "dc5f0735c3c4759e8787218d7893c05ac6d24da6ed8cb3f99aa19bc21e0bc634",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/host/core.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/blk-mq.h>\n#include <linux/blk-integrity.h>\n#include <linux/compat.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/hdreg.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pr.h>\n#include <linux/ptrace.h>\n#include <linux/nvme_ioctl.h>\n#include <linux/pm_qos.h>\n#include <asm/unaligned.h>\n\n#include \"nvme.h\"\n#include \"fabrics.h\"\n#include <linux/nvme-auth.h>\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\n#define NVME_MINORS\t\t(1U << MINORBITS)\n\nstruct nvme_ns_info {\n\tstruct nvme_ns_ids ids;\n\tu32 nsid;\n\t__le32 anagrpid;\n\tbool is_shared;\n\tbool is_readonly;\n\tbool is_ready;\n\tbool is_removed;\n};\n\nunsigned int admin_timeout = 60;\nmodule_param(admin_timeout, uint, 0644);\nMODULE_PARM_DESC(admin_timeout, \"timeout in seconds for admin commands\");\nEXPORT_SYMBOL_GPL(admin_timeout);\n\nunsigned int nvme_io_timeout = 30;\nmodule_param_named(io_timeout, nvme_io_timeout, uint, 0644);\nMODULE_PARM_DESC(io_timeout, \"timeout in seconds for I/O\");\nEXPORT_SYMBOL_GPL(nvme_io_timeout);\n\nstatic unsigned char shutdown_timeout = 5;\nmodule_param(shutdown_timeout, byte, 0644);\nMODULE_PARM_DESC(shutdown_timeout, \"timeout in seconds for controller shutdown\");\n\nstatic u8 nvme_max_retries = 5;\nmodule_param_named(max_retries, nvme_max_retries, byte, 0644);\nMODULE_PARM_DESC(max_retries, \"max number of retries a command may have\");\n\nstatic unsigned long default_ps_max_latency_us = 100000;\nmodule_param(default_ps_max_latency_us, ulong, 0644);\nMODULE_PARM_DESC(default_ps_max_latency_us,\n\t\t \"max power saving latency for new devices; use PM QOS to change per device\");\n\nstatic bool force_apst;\nmodule_param(force_apst, bool, 0644);\nMODULE_PARM_DESC(force_apst, \"allow APST for newly enumerated devices even if quirked off\");\n\nstatic unsigned long apst_primary_timeout_ms = 100;\nmodule_param(apst_primary_timeout_ms, ulong, 0644);\nMODULE_PARM_DESC(apst_primary_timeout_ms,\n\t\"primary APST timeout in ms\");\n\nstatic unsigned long apst_secondary_timeout_ms = 2000;\nmodule_param(apst_secondary_timeout_ms, ulong, 0644);\nMODULE_PARM_DESC(apst_secondary_timeout_ms,\n\t\"secondary APST timeout in ms\");\n\nstatic unsigned long apst_primary_latency_tol_us = 15000;\nmodule_param(apst_primary_latency_tol_us, ulong, 0644);\nMODULE_PARM_DESC(apst_primary_latency_tol_us,\n\t\"primary APST latency tolerance in us\");\n\nstatic unsigned long apst_secondary_latency_tol_us = 100000;\nmodule_param(apst_secondary_latency_tol_us, ulong, 0644);\nMODULE_PARM_DESC(apst_secondary_latency_tol_us,\n\t\"secondary APST latency tolerance in us\");\n\n \nstruct workqueue_struct *nvme_wq;\nEXPORT_SYMBOL_GPL(nvme_wq);\n\nstruct workqueue_struct *nvme_reset_wq;\nEXPORT_SYMBOL_GPL(nvme_reset_wq);\n\nstruct workqueue_struct *nvme_delete_wq;\nEXPORT_SYMBOL_GPL(nvme_delete_wq);\n\nstatic LIST_HEAD(nvme_subsystems);\nstatic DEFINE_MUTEX(nvme_subsystems_lock);\n\nstatic DEFINE_IDA(nvme_instance_ida);\nstatic dev_t nvme_ctrl_base_chr_devt;\nstatic struct class *nvme_class;\nstatic struct class *nvme_subsys_class;\n\nstatic DEFINE_IDA(nvme_ns_chr_minor_ida);\nstatic dev_t nvme_ns_chr_devt;\nstatic struct class *nvme_ns_chr_class;\n\nstatic void nvme_put_subsystem(struct nvme_subsystem *subsys);\nstatic void nvme_remove_invalid_namespaces(struct nvme_ctrl *ctrl,\n\t\t\t\t\t   unsigned nsid);\nstatic void nvme_update_keep_alive(struct nvme_ctrl *ctrl,\n\t\t\t\t   struct nvme_command *cmd);\n\nvoid nvme_queue_scan(struct nvme_ctrl *ctrl)\n{\n\t \n\tif (nvme_ctrl_state(ctrl) == NVME_CTRL_LIVE && ctrl->tagset)\n\t\tqueue_work(nvme_wq, &ctrl->scan_work);\n}\n\n \nint nvme_try_sched_reset(struct nvme_ctrl *ctrl)\n{\n\tif (nvme_ctrl_state(ctrl) != NVME_CTRL_RESETTING)\n\t\treturn -EBUSY;\n\tif (!queue_work(nvme_reset_wq, &ctrl->reset_work))\n\t\treturn -EBUSY;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nvme_try_sched_reset);\n\nstatic void nvme_failfast_work(struct work_struct *work)\n{\n\tstruct nvme_ctrl *ctrl = container_of(to_delayed_work(work),\n\t\t\tstruct nvme_ctrl, failfast_work);\n\n\tif (nvme_ctrl_state(ctrl) != NVME_CTRL_CONNECTING)\n\t\treturn;\n\n\tset_bit(NVME_CTRL_FAILFAST_EXPIRED, &ctrl->flags);\n\tdev_info(ctrl->device, \"failfast expired\\n\");\n\tnvme_kick_requeue_lists(ctrl);\n}\n\nstatic inline void nvme_start_failfast_work(struct nvme_ctrl *ctrl)\n{\n\tif (!ctrl->opts || ctrl->opts->fast_io_fail_tmo == -1)\n\t\treturn;\n\n\tschedule_delayed_work(&ctrl->failfast_work,\n\t\t\t      ctrl->opts->fast_io_fail_tmo * HZ);\n}\n\nstatic inline void nvme_stop_failfast_work(struct nvme_ctrl *ctrl)\n{\n\tif (!ctrl->opts)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&ctrl->failfast_work);\n\tclear_bit(NVME_CTRL_FAILFAST_EXPIRED, &ctrl->flags);\n}\n\n\nint nvme_reset_ctrl(struct nvme_ctrl *ctrl)\n{\n\tif (!nvme_change_ctrl_state(ctrl, NVME_CTRL_RESETTING))\n\t\treturn -EBUSY;\n\tif (!queue_work(nvme_reset_wq, &ctrl->reset_work))\n\t\treturn -EBUSY;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nvme_reset_ctrl);\n\nint nvme_reset_ctrl_sync(struct nvme_ctrl *ctrl)\n{\n\tint ret;\n\n\tret = nvme_reset_ctrl(ctrl);\n\tif (!ret) {\n\t\tflush_work(&ctrl->reset_work);\n\t\tif (nvme_ctrl_state(ctrl) != NVME_CTRL_LIVE)\n\t\t\tret = -ENETRESET;\n\t}\n\n\treturn ret;\n}\n\nstatic void nvme_do_delete_ctrl(struct nvme_ctrl *ctrl)\n{\n\tdev_info(ctrl->device,\n\t\t \"Removing ctrl: NQN \\\"%s\\\"\\n\", nvmf_ctrl_subsysnqn(ctrl));\n\n\tflush_work(&ctrl->reset_work);\n\tnvme_stop_ctrl(ctrl);\n\tnvme_remove_namespaces(ctrl);\n\tctrl->ops->delete_ctrl(ctrl);\n\tnvme_uninit_ctrl(ctrl);\n}\n\nstatic void nvme_delete_ctrl_work(struct work_struct *work)\n{\n\tstruct nvme_ctrl *ctrl =\n\t\tcontainer_of(work, struct nvme_ctrl, delete_work);\n\n\tnvme_do_delete_ctrl(ctrl);\n}\n\nint nvme_delete_ctrl(struct nvme_ctrl *ctrl)\n{\n\tif (!nvme_change_ctrl_state(ctrl, NVME_CTRL_DELETING))\n\t\treturn -EBUSY;\n\tif (!queue_work(nvme_delete_wq, &ctrl->delete_work))\n\t\treturn -EBUSY;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nvme_delete_ctrl);\n\nvoid nvme_delete_ctrl_sync(struct nvme_ctrl *ctrl)\n{\n\t \n\tnvme_get_ctrl(ctrl);\n\tif (nvme_change_ctrl_state(ctrl, NVME_CTRL_DELETING))\n\t\tnvme_do_delete_ctrl(ctrl);\n\tnvme_put_ctrl(ctrl);\n}\n\nstatic blk_status_t nvme_error_status(u16 status)\n{\n\tswitch (status & 0x7ff) {\n\tcase NVME_SC_SUCCESS:\n\t\treturn BLK_STS_OK;\n\tcase NVME_SC_CAP_EXCEEDED:\n\t\treturn BLK_STS_NOSPC;\n\tcase NVME_SC_LBA_RANGE:\n\tcase NVME_SC_CMD_INTERRUPTED:\n\tcase NVME_SC_NS_NOT_READY:\n\t\treturn BLK_STS_TARGET;\n\tcase NVME_SC_BAD_ATTRIBUTES:\n\tcase NVME_SC_ONCS_NOT_SUPPORTED:\n\tcase NVME_SC_INVALID_OPCODE:\n\tcase NVME_SC_INVALID_FIELD:\n\tcase NVME_SC_INVALID_NS:\n\t\treturn BLK_STS_NOTSUPP;\n\tcase NVME_SC_WRITE_FAULT:\n\tcase NVME_SC_READ_ERROR:\n\tcase NVME_SC_UNWRITTEN_BLOCK:\n\tcase NVME_SC_ACCESS_DENIED:\n\tcase NVME_SC_READ_ONLY:\n\tcase NVME_SC_COMPARE_FAILED:\n\t\treturn BLK_STS_MEDIUM;\n\tcase NVME_SC_GUARD_CHECK:\n\tcase NVME_SC_APPTAG_CHECK:\n\tcase NVME_SC_REFTAG_CHECK:\n\tcase NVME_SC_INVALID_PI:\n\t\treturn BLK_STS_PROTECTION;\n\tcase NVME_SC_RESERVATION_CONFLICT:\n\t\treturn BLK_STS_RESV_CONFLICT;\n\tcase NVME_SC_HOST_PATH_ERROR:\n\t\treturn BLK_STS_TRANSPORT;\n\tcase NVME_SC_ZONE_TOO_MANY_ACTIVE:\n\t\treturn BLK_STS_ZONE_ACTIVE_RESOURCE;\n\tcase NVME_SC_ZONE_TOO_MANY_OPEN:\n\t\treturn BLK_STS_ZONE_OPEN_RESOURCE;\n\tdefault:\n\t\treturn BLK_STS_IOERR;\n\t}\n}\n\nstatic void nvme_retry_req(struct request *req)\n{\n\tunsigned long delay = 0;\n\tu16 crd;\n\n\t \n\tcrd = (nvme_req(req)->status & NVME_SC_CRD) >> 11;\n\tif (crd)\n\t\tdelay = nvme_req(req)->ctrl->crdt[crd - 1] * 100;\n\n\tnvme_req(req)->retries++;\n\tblk_mq_requeue_request(req, false);\n\tblk_mq_delay_kick_requeue_list(req->q, delay);\n}\n\nstatic void nvme_log_error(struct request *req)\n{\n\tstruct nvme_ns *ns = req->q->queuedata;\n\tstruct nvme_request *nr = nvme_req(req);\n\n\tif (ns) {\n\t\tpr_err_ratelimited(\"%s: %s(0x%x) @ LBA %llu, %llu blocks, %s (sct 0x%x / sc 0x%x) %s%s\\n\",\n\t\t       ns->disk ? ns->disk->disk_name : \"?\",\n\t\t       nvme_get_opcode_str(nr->cmd->common.opcode),\n\t\t       nr->cmd->common.opcode,\n\t\t       (unsigned long long)nvme_sect_to_lba(ns, blk_rq_pos(req)),\n\t\t       (unsigned long long)blk_rq_bytes(req) >> ns->lba_shift,\n\t\t       nvme_get_error_status_str(nr->status),\n\t\t       nr->status >> 8 & 7,\t \n\t\t       nr->status & 0xff,\t \n\t\t       nr->status & NVME_SC_MORE ? \"MORE \" : \"\",\n\t\t       nr->status & NVME_SC_DNR  ? \"DNR \"  : \"\");\n\t\treturn;\n\t}\n\n\tpr_err_ratelimited(\"%s: %s(0x%x), %s (sct 0x%x / sc 0x%x) %s%s\\n\",\n\t\t\t   dev_name(nr->ctrl->device),\n\t\t\t   nvme_get_admin_opcode_str(nr->cmd->common.opcode),\n\t\t\t   nr->cmd->common.opcode,\n\t\t\t   nvme_get_error_status_str(nr->status),\n\t\t\t   nr->status >> 8 & 7,\t \n\t\t\t   nr->status & 0xff,\t \n\t\t\t   nr->status & NVME_SC_MORE ? \"MORE \" : \"\",\n\t\t\t   nr->status & NVME_SC_DNR  ? \"DNR \"  : \"\");\n}\n\nenum nvme_disposition {\n\tCOMPLETE,\n\tRETRY,\n\tFAILOVER,\n\tAUTHENTICATE,\n};\n\nstatic inline enum nvme_disposition nvme_decide_disposition(struct request *req)\n{\n\tif (likely(nvme_req(req)->status == 0))\n\t\treturn COMPLETE;\n\n\tif ((nvme_req(req)->status & 0x7ff) == NVME_SC_AUTH_REQUIRED)\n\t\treturn AUTHENTICATE;\n\n\tif (blk_noretry_request(req) ||\n\t    (nvme_req(req)->status & NVME_SC_DNR) ||\n\t    nvme_req(req)->retries >= nvme_max_retries)\n\t\treturn COMPLETE;\n\n\tif (req->cmd_flags & REQ_NVME_MPATH) {\n\t\tif (nvme_is_path_error(nvme_req(req)->status) ||\n\t\t    blk_queue_dying(req->q))\n\t\t\treturn FAILOVER;\n\t} else {\n\t\tif (blk_queue_dying(req->q))\n\t\t\treturn COMPLETE;\n\t}\n\n\treturn RETRY;\n}\n\nstatic inline void nvme_end_req_zoned(struct request *req)\n{\n\tif (IS_ENABLED(CONFIG_BLK_DEV_ZONED) &&\n\t    req_op(req) == REQ_OP_ZONE_APPEND)\n\t\treq->__sector = nvme_lba_to_sect(req->q->queuedata,\n\t\t\tle64_to_cpu(nvme_req(req)->result.u64));\n}\n\nstatic inline void nvme_end_req(struct request *req)\n{\n\tblk_status_t status = nvme_error_status(nvme_req(req)->status);\n\n\tif (unlikely(nvme_req(req)->status && !(req->rq_flags & RQF_QUIET)))\n\t\tnvme_log_error(req);\n\tnvme_end_req_zoned(req);\n\tnvme_trace_bio_complete(req);\n\tif (req->cmd_flags & REQ_NVME_MPATH)\n\t\tnvme_mpath_end_request(req);\n\tblk_mq_end_request(req, status);\n}\n\nvoid nvme_complete_rq(struct request *req)\n{\n\tstruct nvme_ctrl *ctrl = nvme_req(req)->ctrl;\n\n\ttrace_nvme_complete_rq(req);\n\tnvme_cleanup_cmd(req);\n\n\t \n\tif (ctrl->kas &&\n\t    req->deadline - req->timeout >= ctrl->ka_last_check_time)\n\t\tctrl->comp_seen = true;\n\n\tswitch (nvme_decide_disposition(req)) {\n\tcase COMPLETE:\n\t\tnvme_end_req(req);\n\t\treturn;\n\tcase RETRY:\n\t\tnvme_retry_req(req);\n\t\treturn;\n\tcase FAILOVER:\n\t\tnvme_failover_req(req);\n\t\treturn;\n\tcase AUTHENTICATE:\n#ifdef CONFIG_NVME_AUTH\n\t\tqueue_work(nvme_wq, &ctrl->dhchap_auth_work);\n\t\tnvme_retry_req(req);\n#else\n\t\tnvme_end_req(req);\n#endif\n\t\treturn;\n\t}\n}\nEXPORT_SYMBOL_GPL(nvme_complete_rq);\n\nvoid nvme_complete_batch_req(struct request *req)\n{\n\ttrace_nvme_complete_rq(req);\n\tnvme_cleanup_cmd(req);\n\tnvme_end_req_zoned(req);\n}\nEXPORT_SYMBOL_GPL(nvme_complete_batch_req);\n\n \nblk_status_t nvme_host_path_error(struct request *req)\n{\n\tnvme_req(req)->status = NVME_SC_HOST_PATH_ERROR;\n\tblk_mq_set_request_complete(req);\n\tnvme_complete_rq(req);\n\treturn BLK_STS_OK;\n}\nEXPORT_SYMBOL_GPL(nvme_host_path_error);\n\nbool nvme_cancel_request(struct request *req, void *data)\n{\n\tdev_dbg_ratelimited(((struct nvme_ctrl *) data)->device,\n\t\t\t\t\"Cancelling I/O %d\", req->tag);\n\n\t \n\tif (blk_mq_rq_state(req) != MQ_RQ_IN_FLIGHT)\n\t\treturn true;\n\n\tnvme_req(req)->status = NVME_SC_HOST_ABORTED_CMD;\n\tnvme_req(req)->flags |= NVME_REQ_CANCELLED;\n\tblk_mq_complete_request(req);\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(nvme_cancel_request);\n\nvoid nvme_cancel_tagset(struct nvme_ctrl *ctrl)\n{\n\tif (ctrl->tagset) {\n\t\tblk_mq_tagset_busy_iter(ctrl->tagset,\n\t\t\t\tnvme_cancel_request, ctrl);\n\t\tblk_mq_tagset_wait_completed_request(ctrl->tagset);\n\t}\n}\nEXPORT_SYMBOL_GPL(nvme_cancel_tagset);\n\nvoid nvme_cancel_admin_tagset(struct nvme_ctrl *ctrl)\n{\n\tif (ctrl->admin_tagset) {\n\t\tblk_mq_tagset_busy_iter(ctrl->admin_tagset,\n\t\t\t\tnvme_cancel_request, ctrl);\n\t\tblk_mq_tagset_wait_completed_request(ctrl->admin_tagset);\n\t}\n}\nEXPORT_SYMBOL_GPL(nvme_cancel_admin_tagset);\n\nbool nvme_change_ctrl_state(struct nvme_ctrl *ctrl,\n\t\tenum nvme_ctrl_state new_state)\n{\n\tenum nvme_ctrl_state old_state;\n\tunsigned long flags;\n\tbool changed = false;\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\n\told_state = nvme_ctrl_state(ctrl);\n\tswitch (new_state) {\n\tcase NVME_CTRL_LIVE:\n\t\tswitch (old_state) {\n\t\tcase NVME_CTRL_NEW:\n\t\tcase NVME_CTRL_RESETTING:\n\t\tcase NVME_CTRL_CONNECTING:\n\t\t\tchanged = true;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NVME_CTRL_RESETTING:\n\t\tswitch (old_state) {\n\t\tcase NVME_CTRL_NEW:\n\t\tcase NVME_CTRL_LIVE:\n\t\t\tchanged = true;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NVME_CTRL_CONNECTING:\n\t\tswitch (old_state) {\n\t\tcase NVME_CTRL_NEW:\n\t\tcase NVME_CTRL_RESETTING:\n\t\t\tchanged = true;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NVME_CTRL_DELETING:\n\t\tswitch (old_state) {\n\t\tcase NVME_CTRL_LIVE:\n\t\tcase NVME_CTRL_RESETTING:\n\t\tcase NVME_CTRL_CONNECTING:\n\t\t\tchanged = true;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NVME_CTRL_DELETING_NOIO:\n\t\tswitch (old_state) {\n\t\tcase NVME_CTRL_DELETING:\n\t\tcase NVME_CTRL_DEAD:\n\t\t\tchanged = true;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NVME_CTRL_DEAD:\n\t\tswitch (old_state) {\n\t\tcase NVME_CTRL_DELETING:\n\t\t\tchanged = true;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (changed) {\n\t\tWRITE_ONCE(ctrl->state, new_state);\n\t\twake_up_all(&ctrl->state_wq);\n\t}\n\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\tif (!changed)\n\t\treturn false;\n\n\tif (new_state == NVME_CTRL_LIVE) {\n\t\tif (old_state == NVME_CTRL_CONNECTING)\n\t\t\tnvme_stop_failfast_work(ctrl);\n\t\tnvme_kick_requeue_lists(ctrl);\n\t} else if (new_state == NVME_CTRL_CONNECTING &&\n\t\told_state == NVME_CTRL_RESETTING) {\n\t\tnvme_start_failfast_work(ctrl);\n\t}\n\treturn changed;\n}\nEXPORT_SYMBOL_GPL(nvme_change_ctrl_state);\n\n \nstatic bool nvme_state_terminal(struct nvme_ctrl *ctrl)\n{\n\tswitch (nvme_ctrl_state(ctrl)) {\n\tcase NVME_CTRL_NEW:\n\tcase NVME_CTRL_LIVE:\n\tcase NVME_CTRL_RESETTING:\n\tcase NVME_CTRL_CONNECTING:\n\t\treturn false;\n\tcase NVME_CTRL_DELETING:\n\tcase NVME_CTRL_DELETING_NOIO:\n\tcase NVME_CTRL_DEAD:\n\t\treturn true;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unhandled ctrl state:%d\", ctrl->state);\n\t\treturn true;\n\t}\n}\n\n \nbool nvme_wait_reset(struct nvme_ctrl *ctrl)\n{\n\twait_event(ctrl->state_wq,\n\t\t   nvme_change_ctrl_state(ctrl, NVME_CTRL_RESETTING) ||\n\t\t   nvme_state_terminal(ctrl));\n\treturn nvme_ctrl_state(ctrl) == NVME_CTRL_RESETTING;\n}\nEXPORT_SYMBOL_GPL(nvme_wait_reset);\n\nstatic void nvme_free_ns_head(struct kref *ref)\n{\n\tstruct nvme_ns_head *head =\n\t\tcontainer_of(ref, struct nvme_ns_head, ref);\n\n\tnvme_mpath_remove_disk(head);\n\tida_free(&head->subsys->ns_ida, head->instance);\n\tcleanup_srcu_struct(&head->srcu);\n\tnvme_put_subsystem(head->subsys);\n\tkfree(head);\n}\n\nbool nvme_tryget_ns_head(struct nvme_ns_head *head)\n{\n\treturn kref_get_unless_zero(&head->ref);\n}\n\nvoid nvme_put_ns_head(struct nvme_ns_head *head)\n{\n\tkref_put(&head->ref, nvme_free_ns_head);\n}\n\nstatic void nvme_free_ns(struct kref *kref)\n{\n\tstruct nvme_ns *ns = container_of(kref, struct nvme_ns, kref);\n\n\tput_disk(ns->disk);\n\tnvme_put_ns_head(ns->head);\n\tnvme_put_ctrl(ns->ctrl);\n\tkfree(ns);\n}\n\nstatic inline bool nvme_get_ns(struct nvme_ns *ns)\n{\n\treturn kref_get_unless_zero(&ns->kref);\n}\n\nvoid nvme_put_ns(struct nvme_ns *ns)\n{\n\tkref_put(&ns->kref, nvme_free_ns);\n}\nEXPORT_SYMBOL_NS_GPL(nvme_put_ns, NVME_TARGET_PASSTHRU);\n\nstatic inline void nvme_clear_nvme_request(struct request *req)\n{\n\tnvme_req(req)->status = 0;\n\tnvme_req(req)->retries = 0;\n\tnvme_req(req)->flags = 0;\n\treq->rq_flags |= RQF_DONTPREP;\n}\n\n \nvoid nvme_init_request(struct request *req, struct nvme_command *cmd)\n{\n\tif (req->q->queuedata)\n\t\treq->timeout = NVME_IO_TIMEOUT;\n\telse  \n\t\treq->timeout = NVME_ADMIN_TIMEOUT;\n\n\t \n\tcmd->common.flags &= ~NVME_CMD_SGL_ALL;\n\n\treq->cmd_flags |= REQ_FAILFAST_DRIVER;\n\tif (req->mq_hctx->type == HCTX_TYPE_POLL)\n\t\treq->cmd_flags |= REQ_POLLED;\n\tnvme_clear_nvme_request(req);\n\treq->rq_flags |= RQF_QUIET;\n\tmemcpy(nvme_req(req)->cmd, cmd, sizeof(*cmd));\n}\nEXPORT_SYMBOL_GPL(nvme_init_request);\n\n \nblk_status_t nvme_fail_nonready_command(struct nvme_ctrl *ctrl,\n\t\tstruct request *rq)\n{\n\tenum nvme_ctrl_state state = nvme_ctrl_state(ctrl);\n\n\tif (state != NVME_CTRL_DELETING_NOIO &&\n\t    state != NVME_CTRL_DELETING &&\n\t    state != NVME_CTRL_DEAD &&\n\t    !test_bit(NVME_CTRL_FAILFAST_EXPIRED, &ctrl->flags) &&\n\t    !blk_noretry_request(rq) && !(rq->cmd_flags & REQ_NVME_MPATH))\n\t\treturn BLK_STS_RESOURCE;\n\treturn nvme_host_path_error(rq);\n}\nEXPORT_SYMBOL_GPL(nvme_fail_nonready_command);\n\nbool __nvme_check_ready(struct nvme_ctrl *ctrl, struct request *rq,\n\t\tbool queue_live)\n{\n\tstruct nvme_request *req = nvme_req(rq);\n\n\t \n\tif (rq->q == ctrl->admin_q && (req->flags & NVME_REQ_USERCMD))\n\t\treturn false;\n\n\tif (ctrl->ops->flags & NVME_F_FABRICS) {\n\t\t \n\t\tswitch (nvme_ctrl_state(ctrl)) {\n\t\tcase NVME_CTRL_CONNECTING:\n\t\t\tif (blk_rq_is_passthrough(rq) && nvme_is_fabrics(req->cmd) &&\n\t\t\t    (req->cmd->fabrics.fctype == nvme_fabrics_type_connect ||\n\t\t\t     req->cmd->fabrics.fctype == nvme_fabrics_type_auth_send ||\n\t\t\t     req->cmd->fabrics.fctype == nvme_fabrics_type_auth_receive))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase NVME_CTRL_DEAD:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn queue_live;\n}\nEXPORT_SYMBOL_GPL(__nvme_check_ready);\n\nstatic inline void nvme_setup_flush(struct nvme_ns *ns,\n\t\tstruct nvme_command *cmnd)\n{\n\tmemset(cmnd, 0, sizeof(*cmnd));\n\tcmnd->common.opcode = nvme_cmd_flush;\n\tcmnd->common.nsid = cpu_to_le32(ns->head->ns_id);\n}\n\nstatic blk_status_t nvme_setup_discard(struct nvme_ns *ns, struct request *req,\n\t\tstruct nvme_command *cmnd)\n{\n\tunsigned short segments = blk_rq_nr_discard_segments(req), n = 0;\n\tstruct nvme_dsm_range *range;\n\tstruct bio *bio;\n\n\t \n\tstatic const size_t alloc_size = sizeof(*range) * NVME_DSM_MAX_RANGES;\n\n\trange = kzalloc(alloc_size, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!range) {\n\t\t \n\t\tif (test_and_set_bit_lock(0, &ns->ctrl->discard_page_busy))\n\t\t\treturn BLK_STS_RESOURCE;\n\n\t\trange = page_address(ns->ctrl->discard_page);\n\t}\n\n\tif (queue_max_discard_segments(req->q) == 1) {\n\t\tu64 slba = nvme_sect_to_lba(ns, blk_rq_pos(req));\n\t\tu32 nlb = blk_rq_sectors(req) >> (ns->lba_shift - 9);\n\n\t\trange[0].cattr = cpu_to_le32(0);\n\t\trange[0].nlb = cpu_to_le32(nlb);\n\t\trange[0].slba = cpu_to_le64(slba);\n\t\tn = 1;\n\t} else {\n\t\t__rq_for_each_bio(bio, req) {\n\t\t\tu64 slba = nvme_sect_to_lba(ns, bio->bi_iter.bi_sector);\n\t\t\tu32 nlb = bio->bi_iter.bi_size >> ns->lba_shift;\n\n\t\t\tif (n < segments) {\n\t\t\t\trange[n].cattr = cpu_to_le32(0);\n\t\t\t\trange[n].nlb = cpu_to_le32(nlb);\n\t\t\t\trange[n].slba = cpu_to_le64(slba);\n\t\t\t}\n\t\t\tn++;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(n != segments)) {\n\t\tif (virt_to_page(range) == ns->ctrl->discard_page)\n\t\t\tclear_bit_unlock(0, &ns->ctrl->discard_page_busy);\n\t\telse\n\t\t\tkfree(range);\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tmemset(cmnd, 0, sizeof(*cmnd));\n\tcmnd->dsm.opcode = nvme_cmd_dsm;\n\tcmnd->dsm.nsid = cpu_to_le32(ns->head->ns_id);\n\tcmnd->dsm.nr = cpu_to_le32(segments - 1);\n\tcmnd->dsm.attributes = cpu_to_le32(NVME_DSMGMT_AD);\n\n\tbvec_set_virt(&req->special_vec, range, alloc_size);\n\treq->rq_flags |= RQF_SPECIAL_PAYLOAD;\n\n\treturn BLK_STS_OK;\n}\n\nstatic void nvme_set_ref_tag(struct nvme_ns *ns, struct nvme_command *cmnd,\n\t\t\t      struct request *req)\n{\n\tu32 upper, lower;\n\tu64 ref48;\n\n\t \n\tswitch (ns->guard_type) {\n\tcase NVME_NVM_NS_16B_GUARD:\n\t\tcmnd->rw.reftag = cpu_to_le32(t10_pi_ref_tag(req));\n\t\tbreak;\n\tcase NVME_NVM_NS_64B_GUARD:\n\t\tref48 = ext_pi_ref_tag(req);\n\t\tlower = lower_32_bits(ref48);\n\t\tupper = upper_32_bits(ref48);\n\n\t\tcmnd->rw.reftag = cpu_to_le32(lower);\n\t\tcmnd->rw.cdw3 = cpu_to_le32(upper);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic inline blk_status_t nvme_setup_write_zeroes(struct nvme_ns *ns,\n\t\tstruct request *req, struct nvme_command *cmnd)\n{\n\tmemset(cmnd, 0, sizeof(*cmnd));\n\n\tif (ns->ctrl->quirks & NVME_QUIRK_DEALLOCATE_ZEROES)\n\t\treturn nvme_setup_discard(ns, req, cmnd);\n\n\tcmnd->write_zeroes.opcode = nvme_cmd_write_zeroes;\n\tcmnd->write_zeroes.nsid = cpu_to_le32(ns->head->ns_id);\n\tcmnd->write_zeroes.slba =\n\t\tcpu_to_le64(nvme_sect_to_lba(ns, blk_rq_pos(req)));\n\tcmnd->write_zeroes.length =\n\t\tcpu_to_le16((blk_rq_bytes(req) >> ns->lba_shift) - 1);\n\n\tif (!(req->cmd_flags & REQ_NOUNMAP) && (ns->features & NVME_NS_DEAC))\n\t\tcmnd->write_zeroes.control |= cpu_to_le16(NVME_WZ_DEAC);\n\n\tif (nvme_ns_has_pi(ns)) {\n\t\tcmnd->write_zeroes.control |= cpu_to_le16(NVME_RW_PRINFO_PRACT);\n\n\t\tswitch (ns->pi_type) {\n\t\tcase NVME_NS_DPS_PI_TYPE1:\n\t\tcase NVME_NS_DPS_PI_TYPE2:\n\t\t\tnvme_set_ref_tag(ns, cmnd, req);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn BLK_STS_OK;\n}\n\nstatic inline blk_status_t nvme_setup_rw(struct nvme_ns *ns,\n\t\tstruct request *req, struct nvme_command *cmnd,\n\t\tenum nvme_opcode op)\n{\n\tu16 control = 0;\n\tu32 dsmgmt = 0;\n\n\tif (req->cmd_flags & REQ_FUA)\n\t\tcontrol |= NVME_RW_FUA;\n\tif (req->cmd_flags & (REQ_FAILFAST_DEV | REQ_RAHEAD))\n\t\tcontrol |= NVME_RW_LR;\n\n\tif (req->cmd_flags & REQ_RAHEAD)\n\t\tdsmgmt |= NVME_RW_DSM_FREQ_PREFETCH;\n\n\tcmnd->rw.opcode = op;\n\tcmnd->rw.flags = 0;\n\tcmnd->rw.nsid = cpu_to_le32(ns->head->ns_id);\n\tcmnd->rw.cdw2 = 0;\n\tcmnd->rw.cdw3 = 0;\n\tcmnd->rw.metadata = 0;\n\tcmnd->rw.slba = cpu_to_le64(nvme_sect_to_lba(ns, blk_rq_pos(req)));\n\tcmnd->rw.length = cpu_to_le16((blk_rq_bytes(req) >> ns->lba_shift) - 1);\n\tcmnd->rw.reftag = 0;\n\tcmnd->rw.apptag = 0;\n\tcmnd->rw.appmask = 0;\n\n\tif (ns->ms) {\n\t\t \n\t\tif (!blk_integrity_rq(req)) {\n\t\t\tif (WARN_ON_ONCE(!nvme_ns_has_pi(ns)))\n\t\t\t\treturn BLK_STS_NOTSUPP;\n\t\t\tcontrol |= NVME_RW_PRINFO_PRACT;\n\t\t}\n\n\t\tswitch (ns->pi_type) {\n\t\tcase NVME_NS_DPS_PI_TYPE3:\n\t\t\tcontrol |= NVME_RW_PRINFO_PRCHK_GUARD;\n\t\t\tbreak;\n\t\tcase NVME_NS_DPS_PI_TYPE1:\n\t\tcase NVME_NS_DPS_PI_TYPE2:\n\t\t\tcontrol |= NVME_RW_PRINFO_PRCHK_GUARD |\n\t\t\t\t\tNVME_RW_PRINFO_PRCHK_REF;\n\t\t\tif (op == nvme_cmd_zone_append)\n\t\t\t\tcontrol |= NVME_RW_APPEND_PIREMAP;\n\t\t\tnvme_set_ref_tag(ns, cmnd, req);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcmnd->rw.control = cpu_to_le16(control);\n\tcmnd->rw.dsmgmt = cpu_to_le32(dsmgmt);\n\treturn 0;\n}\n\nvoid nvme_cleanup_cmd(struct request *req)\n{\n\tif (req->rq_flags & RQF_SPECIAL_PAYLOAD) {\n\t\tstruct nvme_ctrl *ctrl = nvme_req(req)->ctrl;\n\n\t\tif (req->special_vec.bv_page == ctrl->discard_page)\n\t\t\tclear_bit_unlock(0, &ctrl->discard_page_busy);\n\t\telse\n\t\t\tkfree(bvec_virt(&req->special_vec));\n\t}\n}\nEXPORT_SYMBOL_GPL(nvme_cleanup_cmd);\n\nblk_status_t nvme_setup_cmd(struct nvme_ns *ns, struct request *req)\n{\n\tstruct nvme_command *cmd = nvme_req(req)->cmd;\n\tblk_status_t ret = BLK_STS_OK;\n\n\tif (!(req->rq_flags & RQF_DONTPREP))\n\t\tnvme_clear_nvme_request(req);\n\n\tswitch (req_op(req)) {\n\tcase REQ_OP_DRV_IN:\n\tcase REQ_OP_DRV_OUT:\n\t\t \n\t\tbreak;\n\tcase REQ_OP_FLUSH:\n\t\tnvme_setup_flush(ns, cmd);\n\t\tbreak;\n\tcase REQ_OP_ZONE_RESET_ALL:\n\tcase REQ_OP_ZONE_RESET:\n\t\tret = nvme_setup_zone_mgmt_send(ns, req, cmd, NVME_ZONE_RESET);\n\t\tbreak;\n\tcase REQ_OP_ZONE_OPEN:\n\t\tret = nvme_setup_zone_mgmt_send(ns, req, cmd, NVME_ZONE_OPEN);\n\t\tbreak;\n\tcase REQ_OP_ZONE_CLOSE:\n\t\tret = nvme_setup_zone_mgmt_send(ns, req, cmd, NVME_ZONE_CLOSE);\n\t\tbreak;\n\tcase REQ_OP_ZONE_FINISH:\n\t\tret = nvme_setup_zone_mgmt_send(ns, req, cmd, NVME_ZONE_FINISH);\n\t\tbreak;\n\tcase REQ_OP_WRITE_ZEROES:\n\t\tret = nvme_setup_write_zeroes(ns, req, cmd);\n\t\tbreak;\n\tcase REQ_OP_DISCARD:\n\t\tret = nvme_setup_discard(ns, req, cmd);\n\t\tbreak;\n\tcase REQ_OP_READ:\n\t\tret = nvme_setup_rw(ns, req, cmd, nvme_cmd_read);\n\t\tbreak;\n\tcase REQ_OP_WRITE:\n\t\tret = nvme_setup_rw(ns, req, cmd, nvme_cmd_write);\n\t\tbreak;\n\tcase REQ_OP_ZONE_APPEND:\n\t\tret = nvme_setup_rw(ns, req, cmd, nvme_cmd_zone_append);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tcmd->common.command_id = nvme_cid(req);\n\ttrace_nvme_setup_cmd(req, cmd);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvme_setup_cmd);\n\n \nint nvme_execute_rq(struct request *rq, bool at_head)\n{\n\tblk_status_t status;\n\n\tstatus = blk_execute_rq(rq, at_head);\n\tif (nvme_req(rq)->flags & NVME_REQ_CANCELLED)\n\t\treturn -EINTR;\n\tif (nvme_req(rq)->status)\n\t\treturn nvme_req(rq)->status;\n\treturn blk_status_to_errno(status);\n}\nEXPORT_SYMBOL_NS_GPL(nvme_execute_rq, NVME_TARGET_PASSTHRU);\n\n \nint __nvme_submit_sync_cmd(struct request_queue *q, struct nvme_command *cmd,\n\t\tunion nvme_result *result, void *buffer, unsigned bufflen,\n\t\tint qid, int at_head, blk_mq_req_flags_t flags)\n{\n\tstruct request *req;\n\tint ret;\n\n\tif (qid == NVME_QID_ANY)\n\t\treq = blk_mq_alloc_request(q, nvme_req_op(cmd), flags);\n\telse\n\t\treq = blk_mq_alloc_request_hctx(q, nvme_req_op(cmd), flags,\n\t\t\t\t\t\tqid - 1);\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\tnvme_init_request(req, cmd);\n\n\tif (buffer && bufflen) {\n\t\tret = blk_rq_map_kern(q, req, buffer, bufflen, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = nvme_execute_rq(req, at_head);\n\tif (result && ret >= 0)\n\t\t*result = nvme_req(req)->result;\n out:\n\tblk_mq_free_request(req);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__nvme_submit_sync_cmd);\n\nint nvme_submit_sync_cmd(struct request_queue *q, struct nvme_command *cmd,\n\t\tvoid *buffer, unsigned bufflen)\n{\n\treturn __nvme_submit_sync_cmd(q, cmd, NULL, buffer, bufflen,\n\t\t\tNVME_QID_ANY, 0, 0);\n}\nEXPORT_SYMBOL_GPL(nvme_submit_sync_cmd);\n\nu32 nvme_command_effects(struct nvme_ctrl *ctrl, struct nvme_ns *ns, u8 opcode)\n{\n\tu32 effects = 0;\n\n\tif (ns) {\n\t\teffects = le32_to_cpu(ns->head->effects->iocs[opcode]);\n\t\tif (effects & ~(NVME_CMD_EFFECTS_CSUPP | NVME_CMD_EFFECTS_LBCC))\n\t\t\tdev_warn_once(ctrl->device,\n\t\t\t\t\"IO command:%02x has unusual effects:%08x\\n\",\n\t\t\t\topcode, effects);\n\n\t\t \n\t\teffects &= ~NVME_CMD_EFFECTS_CSE_MASK;\n\t} else {\n\t\teffects = le32_to_cpu(ctrl->effects->acs[opcode]);\n\t}\n\n\treturn effects;\n}\nEXPORT_SYMBOL_NS_GPL(nvme_command_effects, NVME_TARGET_PASSTHRU);\n\nu32 nvme_passthru_start(struct nvme_ctrl *ctrl, struct nvme_ns *ns, u8 opcode)\n{\n\tu32 effects = nvme_command_effects(ctrl, ns, opcode);\n\n\t \n\tif (effects & NVME_CMD_EFFECTS_CSE_MASK) {\n\t\tmutex_lock(&ctrl->scan_lock);\n\t\tmutex_lock(&ctrl->subsys->lock);\n\t\tnvme_mpath_start_freeze(ctrl->subsys);\n\t\tnvme_mpath_wait_freeze(ctrl->subsys);\n\t\tnvme_start_freeze(ctrl);\n\t\tnvme_wait_freeze(ctrl);\n\t}\n\treturn effects;\n}\nEXPORT_SYMBOL_NS_GPL(nvme_passthru_start, NVME_TARGET_PASSTHRU);\n\nvoid nvme_passthru_end(struct nvme_ctrl *ctrl, struct nvme_ns *ns, u32 effects,\n\t\t       struct nvme_command *cmd, int status)\n{\n\tif (effects & NVME_CMD_EFFECTS_CSE_MASK) {\n\t\tnvme_unfreeze(ctrl);\n\t\tnvme_mpath_unfreeze(ctrl->subsys);\n\t\tmutex_unlock(&ctrl->subsys->lock);\n\t\tmutex_unlock(&ctrl->scan_lock);\n\t}\n\tif (effects & NVME_CMD_EFFECTS_CCC) {\n\t\tif (!test_and_set_bit(NVME_CTRL_DIRTY_CAPABILITY,\n\t\t\t\t      &ctrl->flags)) {\n\t\t\tdev_info(ctrl->device,\n\"controller capabilities changed, reset may be required to take effect.\\n\");\n\t\t}\n\t}\n\tif (effects & (NVME_CMD_EFFECTS_NIC | NVME_CMD_EFFECTS_NCC)) {\n\t\tnvme_queue_scan(ctrl);\n\t\tflush_work(&ctrl->scan_work);\n\t}\n\tif (ns)\n\t\treturn;\n\n\tswitch (cmd->common.opcode) {\n\tcase nvme_admin_set_features:\n\t\tswitch (le32_to_cpu(cmd->common.cdw10) & 0xFF) {\n\t\tcase NVME_FEAT_KATO:\n\t\t\t \n\t\t\tif (!status)\n\t\t\t\tnvme_update_keep_alive(ctrl, cmd);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(nvme_passthru_end, NVME_TARGET_PASSTHRU);\n\n \nstatic unsigned long nvme_keep_alive_work_period(struct nvme_ctrl *ctrl)\n{\n\tunsigned long delay = ctrl->kato * HZ / 2;\n\n\t \n\tif (ctrl->ctratt & NVME_CTRL_ATTR_TBKAS)\n\t\tdelay /= 2;\n\treturn delay;\n}\n\nstatic void nvme_queue_keep_alive_work(struct nvme_ctrl *ctrl)\n{\n\tqueue_delayed_work(nvme_wq, &ctrl->ka_work,\n\t\t\t   nvme_keep_alive_work_period(ctrl));\n}\n\nstatic enum rq_end_io_ret nvme_keep_alive_end_io(struct request *rq,\n\t\t\t\t\t\t blk_status_t status)\n{\n\tstruct nvme_ctrl *ctrl = rq->end_io_data;\n\tunsigned long flags;\n\tbool startka = false;\n\tunsigned long rtt = jiffies - (rq->deadline - rq->timeout);\n\tunsigned long delay = nvme_keep_alive_work_period(ctrl);\n\n\t \n\tif (rtt <= delay) {\n\t\tdelay -= rtt;\n\t} else {\n\t\tdev_warn(ctrl->device, \"long keepalive RTT (%u ms)\\n\",\n\t\t\t jiffies_to_msecs(rtt));\n\t\tdelay = 0;\n\t}\n\n\tblk_mq_free_request(rq);\n\n\tif (status) {\n\t\tdev_err(ctrl->device,\n\t\t\t\"failed nvme_keep_alive_end_io error=%d\\n\",\n\t\t\t\tstatus);\n\t\treturn RQ_END_IO_NONE;\n\t}\n\n\tctrl->ka_last_check_time = jiffies;\n\tctrl->comp_seen = false;\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\tif (ctrl->state == NVME_CTRL_LIVE ||\n\t    ctrl->state == NVME_CTRL_CONNECTING)\n\t\tstartka = true;\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\tif (startka)\n\t\tqueue_delayed_work(nvme_wq, &ctrl->ka_work, delay);\n\treturn RQ_END_IO_NONE;\n}\n\nstatic void nvme_keep_alive_work(struct work_struct *work)\n{\n\tstruct nvme_ctrl *ctrl = container_of(to_delayed_work(work),\n\t\t\tstruct nvme_ctrl, ka_work);\n\tbool comp_seen = ctrl->comp_seen;\n\tstruct request *rq;\n\n\tctrl->ka_last_check_time = jiffies;\n\n\tif ((ctrl->ctratt & NVME_CTRL_ATTR_TBKAS) && comp_seen) {\n\t\tdev_dbg(ctrl->device,\n\t\t\t\"reschedule traffic based keep-alive timer\\n\");\n\t\tctrl->comp_seen = false;\n\t\tnvme_queue_keep_alive_work(ctrl);\n\t\treturn;\n\t}\n\n\trq = blk_mq_alloc_request(ctrl->admin_q, nvme_req_op(&ctrl->ka_cmd),\n\t\t\t\t  BLK_MQ_REQ_RESERVED | BLK_MQ_REQ_NOWAIT);\n\tif (IS_ERR(rq)) {\n\t\t \n\t\tdev_err(ctrl->device, \"keep-alive failed: %ld\\n\", PTR_ERR(rq));\n\t\tnvme_reset_ctrl(ctrl);\n\t\treturn;\n\t}\n\tnvme_init_request(rq, &ctrl->ka_cmd);\n\n\trq->timeout = ctrl->kato * HZ;\n\trq->end_io = nvme_keep_alive_end_io;\n\trq->end_io_data = ctrl;\n\tblk_execute_rq_nowait(rq, false);\n}\n\nstatic void nvme_start_keep_alive(struct nvme_ctrl *ctrl)\n{\n\tif (unlikely(ctrl->kato == 0))\n\t\treturn;\n\n\tnvme_queue_keep_alive_work(ctrl);\n}\n\nvoid nvme_stop_keep_alive(struct nvme_ctrl *ctrl)\n{\n\tif (unlikely(ctrl->kato == 0))\n\t\treturn;\n\n\tcancel_delayed_work_sync(&ctrl->ka_work);\n}\nEXPORT_SYMBOL_GPL(nvme_stop_keep_alive);\n\nstatic void nvme_update_keep_alive(struct nvme_ctrl *ctrl,\n\t\t\t\t   struct nvme_command *cmd)\n{\n\tunsigned int new_kato =\n\t\tDIV_ROUND_UP(le32_to_cpu(cmd->common.cdw11), 1000);\n\n\tdev_info(ctrl->device,\n\t\t \"keep alive interval updated from %u ms to %u ms\\n\",\n\t\t ctrl->kato * 1000 / 2, new_kato * 1000 / 2);\n\n\tnvme_stop_keep_alive(ctrl);\n\tctrl->kato = new_kato;\n\tnvme_start_keep_alive(ctrl);\n}\n\n \nstatic bool nvme_ctrl_limited_cns(struct nvme_ctrl *ctrl)\n{\n\tif (ctrl->quirks & NVME_QUIRK_IDENTIFY_CNS)\n\t\treturn ctrl->vs < NVME_VS(1, 2, 0);\n\treturn ctrl->vs < NVME_VS(1, 1, 0);\n}\n\nstatic int nvme_identify_ctrl(struct nvme_ctrl *dev, struct nvme_id_ctrl **id)\n{\n\tstruct nvme_command c = { };\n\tint error;\n\n\t \n\tc.identify.opcode = nvme_admin_identify;\n\tc.identify.cns = NVME_ID_CNS_CTRL;\n\n\t*id = kmalloc(sizeof(struct nvme_id_ctrl), GFP_KERNEL);\n\tif (!*id)\n\t\treturn -ENOMEM;\n\n\terror = nvme_submit_sync_cmd(dev->admin_q, &c, *id,\n\t\t\tsizeof(struct nvme_id_ctrl));\n\tif (error)\n\t\tkfree(*id);\n\treturn error;\n}\n\nstatic int nvme_process_ns_desc(struct nvme_ctrl *ctrl, struct nvme_ns_ids *ids,\n\t\tstruct nvme_ns_id_desc *cur, bool *csi_seen)\n{\n\tconst char *warn_str = \"ctrl returned bogus length:\";\n\tvoid *data = cur;\n\n\tswitch (cur->nidt) {\n\tcase NVME_NIDT_EUI64:\n\t\tif (cur->nidl != NVME_NIDT_EUI64_LEN) {\n\t\t\tdev_warn(ctrl->device, \"%s %d for NVME_NIDT_EUI64\\n\",\n\t\t\t\t warn_str, cur->nidl);\n\t\t\treturn -1;\n\t\t}\n\t\tif (ctrl->quirks & NVME_QUIRK_BOGUS_NID)\n\t\t\treturn NVME_NIDT_EUI64_LEN;\n\t\tmemcpy(ids->eui64, data + sizeof(*cur), NVME_NIDT_EUI64_LEN);\n\t\treturn NVME_NIDT_EUI64_LEN;\n\tcase NVME_NIDT_NGUID:\n\t\tif (cur->nidl != NVME_NIDT_NGUID_LEN) {\n\t\t\tdev_warn(ctrl->device, \"%s %d for NVME_NIDT_NGUID\\n\",\n\t\t\t\t warn_str, cur->nidl);\n\t\t\treturn -1;\n\t\t}\n\t\tif (ctrl->quirks & NVME_QUIRK_BOGUS_NID)\n\t\t\treturn NVME_NIDT_NGUID_LEN;\n\t\tmemcpy(ids->nguid, data + sizeof(*cur), NVME_NIDT_NGUID_LEN);\n\t\treturn NVME_NIDT_NGUID_LEN;\n\tcase NVME_NIDT_UUID:\n\t\tif (cur->nidl != NVME_NIDT_UUID_LEN) {\n\t\t\tdev_warn(ctrl->device, \"%s %d for NVME_NIDT_UUID\\n\",\n\t\t\t\t warn_str, cur->nidl);\n\t\t\treturn -1;\n\t\t}\n\t\tif (ctrl->quirks & NVME_QUIRK_BOGUS_NID)\n\t\t\treturn NVME_NIDT_UUID_LEN;\n\t\tuuid_copy(&ids->uuid, data + sizeof(*cur));\n\t\treturn NVME_NIDT_UUID_LEN;\n\tcase NVME_NIDT_CSI:\n\t\tif (cur->nidl != NVME_NIDT_CSI_LEN) {\n\t\t\tdev_warn(ctrl->device, \"%s %d for NVME_NIDT_CSI\\n\",\n\t\t\t\t warn_str, cur->nidl);\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(&ids->csi, data + sizeof(*cur), NVME_NIDT_CSI_LEN);\n\t\t*csi_seen = true;\n\t\treturn NVME_NIDT_CSI_LEN;\n\tdefault:\n\t\t \n\t\treturn cur->nidl;\n\t}\n}\n\nstatic int nvme_identify_ns_descs(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_ns_info *info)\n{\n\tstruct nvme_command c = { };\n\tbool csi_seen = false;\n\tint status, pos, len;\n\tvoid *data;\n\n\tif (ctrl->vs < NVME_VS(1, 3, 0) && !nvme_multi_css(ctrl))\n\t\treturn 0;\n\tif (ctrl->quirks & NVME_QUIRK_NO_NS_DESC_LIST)\n\t\treturn 0;\n\n\tc.identify.opcode = nvme_admin_identify;\n\tc.identify.nsid = cpu_to_le32(info->nsid);\n\tc.identify.cns = NVME_ID_CNS_NS_DESC_LIST;\n\n\tdata = kzalloc(NVME_IDENTIFY_DATA_SIZE, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tstatus = nvme_submit_sync_cmd(ctrl->admin_q, &c, data,\n\t\t\t\t      NVME_IDENTIFY_DATA_SIZE);\n\tif (status) {\n\t\tdev_warn(ctrl->device,\n\t\t\t\"Identify Descriptors failed (nsid=%u, status=0x%x)\\n\",\n\t\t\tinfo->nsid, status);\n\t\tgoto free_data;\n\t}\n\n\tfor (pos = 0; pos < NVME_IDENTIFY_DATA_SIZE; pos += len) {\n\t\tstruct nvme_ns_id_desc *cur = data + pos;\n\n\t\tif (cur->nidl == 0)\n\t\t\tbreak;\n\n\t\tlen = nvme_process_ns_desc(ctrl, &info->ids, cur, &csi_seen);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tlen += sizeof(*cur);\n\t}\n\n\tif (nvme_multi_css(ctrl) && !csi_seen) {\n\t\tdev_warn(ctrl->device, \"Command set not reported for nsid:%d\\n\",\n\t\t\t info->nsid);\n\t\tstatus = -EINVAL;\n\t}\n\nfree_data:\n\tkfree(data);\n\treturn status;\n}\n\nstatic int nvme_identify_ns(struct nvme_ctrl *ctrl, unsigned nsid,\n\t\t\tstruct nvme_id_ns **id)\n{\n\tstruct nvme_command c = { };\n\tint error;\n\n\t \n\tc.identify.opcode = nvme_admin_identify;\n\tc.identify.nsid = cpu_to_le32(nsid);\n\tc.identify.cns = NVME_ID_CNS_NS;\n\n\t*id = kmalloc(sizeof(**id), GFP_KERNEL);\n\tif (!*id)\n\t\treturn -ENOMEM;\n\n\terror = nvme_submit_sync_cmd(ctrl->admin_q, &c, *id, sizeof(**id));\n\tif (error) {\n\t\tdev_warn(ctrl->device, \"Identify namespace failed (%d)\\n\", error);\n\t\tkfree(*id);\n\t}\n\treturn error;\n}\n\nstatic int nvme_ns_info_from_identify(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_ns_info *info)\n{\n\tstruct nvme_ns_ids *ids = &info->ids;\n\tstruct nvme_id_ns *id;\n\tint ret;\n\n\tret = nvme_identify_ns(ctrl, info->nsid, &id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (id->ncap == 0) {\n\t\t \n\t\tinfo->is_removed = true;\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tinfo->anagrpid = id->anagrpid;\n\tinfo->is_shared = id->nmic & NVME_NS_NMIC_SHARED;\n\tinfo->is_readonly = id->nsattr & NVME_NS_ATTR_RO;\n\tinfo->is_ready = true;\n\tif (ctrl->quirks & NVME_QUIRK_BOGUS_NID) {\n\t\tdev_info(ctrl->device,\n\t\t\t \"Ignoring bogus Namespace Identifiers\\n\");\n\t} else {\n\t\tif (ctrl->vs >= NVME_VS(1, 1, 0) &&\n\t\t    !memchr_inv(ids->eui64, 0, sizeof(ids->eui64)))\n\t\t\tmemcpy(ids->eui64, id->eui64, sizeof(ids->eui64));\n\t\tif (ctrl->vs >= NVME_VS(1, 2, 0) &&\n\t\t    !memchr_inv(ids->nguid, 0, sizeof(ids->nguid)))\n\t\t\tmemcpy(ids->nguid, id->nguid, sizeof(ids->nguid));\n\t}\n\nerror:\n\tkfree(id);\n\treturn ret;\n}\n\nstatic int nvme_ns_info_from_id_cs_indep(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_ns_info *info)\n{\n\tstruct nvme_id_ns_cs_indep *id;\n\tstruct nvme_command c = {\n\t\t.identify.opcode\t= nvme_admin_identify,\n\t\t.identify.nsid\t\t= cpu_to_le32(info->nsid),\n\t\t.identify.cns\t\t= NVME_ID_CNS_NS_CS_INDEP,\n\t};\n\tint ret;\n\n\tid = kmalloc(sizeof(*id), GFP_KERNEL);\n\tif (!id)\n\t\treturn -ENOMEM;\n\n\tret = nvme_submit_sync_cmd(ctrl->admin_q, &c, id, sizeof(*id));\n\tif (!ret) {\n\t\tinfo->anagrpid = id->anagrpid;\n\t\tinfo->is_shared = id->nmic & NVME_NS_NMIC_SHARED;\n\t\tinfo->is_readonly = id->nsattr & NVME_NS_ATTR_RO;\n\t\tinfo->is_ready = id->nstat & NVME_NSTAT_NRDY;\n\t}\n\tkfree(id);\n\treturn ret;\n}\n\nstatic int nvme_features(struct nvme_ctrl *dev, u8 op, unsigned int fid,\n\t\tunsigned int dword11, void *buffer, size_t buflen, u32 *result)\n{\n\tunion nvme_result res = { 0 };\n\tstruct nvme_command c = { };\n\tint ret;\n\n\tc.features.opcode = op;\n\tc.features.fid = cpu_to_le32(fid);\n\tc.features.dword11 = cpu_to_le32(dword11);\n\n\tret = __nvme_submit_sync_cmd(dev->admin_q, &c, &res,\n\t\t\tbuffer, buflen, NVME_QID_ANY, 0, 0);\n\tif (ret >= 0 && result)\n\t\t*result = le32_to_cpu(res.u32);\n\treturn ret;\n}\n\nint nvme_set_features(struct nvme_ctrl *dev, unsigned int fid,\n\t\t      unsigned int dword11, void *buffer, size_t buflen,\n\t\t      u32 *result)\n{\n\treturn nvme_features(dev, nvme_admin_set_features, fid, dword11, buffer,\n\t\t\t     buflen, result);\n}\nEXPORT_SYMBOL_GPL(nvme_set_features);\n\nint nvme_get_features(struct nvme_ctrl *dev, unsigned int fid,\n\t\t      unsigned int dword11, void *buffer, size_t buflen,\n\t\t      u32 *result)\n{\n\treturn nvme_features(dev, nvme_admin_get_features, fid, dword11, buffer,\n\t\t\t     buflen, result);\n}\nEXPORT_SYMBOL_GPL(nvme_get_features);\n\nint nvme_set_queue_count(struct nvme_ctrl *ctrl, int *count)\n{\n\tu32 q_count = (*count - 1) | ((*count - 1) << 16);\n\tu32 result;\n\tint status, nr_io_queues;\n\n\tstatus = nvme_set_features(ctrl, NVME_FEAT_NUM_QUEUES, q_count, NULL, 0,\n\t\t\t&result);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tif (status > 0) {\n\t\tdev_err(ctrl->device, \"Could not set queue count (%d)\\n\", status);\n\t\t*count = 0;\n\t} else {\n\t\tnr_io_queues = min(result & 0xffff, result >> 16) + 1;\n\t\t*count = min(*count, nr_io_queues);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nvme_set_queue_count);\n\n#define NVME_AEN_SUPPORTED \\\n\t(NVME_AEN_CFG_NS_ATTR | NVME_AEN_CFG_FW_ACT | \\\n\t NVME_AEN_CFG_ANA_CHANGE | NVME_AEN_CFG_DISC_CHANGE)\n\nstatic void nvme_enable_aen(struct nvme_ctrl *ctrl)\n{\n\tu32 result, supported_aens = ctrl->oaes & NVME_AEN_SUPPORTED;\n\tint status;\n\n\tif (!supported_aens)\n\t\treturn;\n\n\tstatus = nvme_set_features(ctrl, NVME_FEAT_ASYNC_EVENT, supported_aens,\n\t\t\tNULL, 0, &result);\n\tif (status)\n\t\tdev_warn(ctrl->device, \"Failed to configure AEN (cfg %x)\\n\",\n\t\t\t supported_aens);\n\n\tqueue_work(nvme_wq, &ctrl->async_event_work);\n}\n\nstatic int nvme_ns_open(struct nvme_ns *ns)\n{\n\n\t \n\tif (WARN_ON_ONCE(nvme_ns_head_multipath(ns->head)))\n\t\tgoto fail;\n\tif (!nvme_get_ns(ns))\n\t\tgoto fail;\n\tif (!try_module_get(ns->ctrl->ops->module))\n\t\tgoto fail_put_ns;\n\n\treturn 0;\n\nfail_put_ns:\n\tnvme_put_ns(ns);\nfail:\n\treturn -ENXIO;\n}\n\nstatic void nvme_ns_release(struct nvme_ns *ns)\n{\n\n\tmodule_put(ns->ctrl->ops->module);\n\tnvme_put_ns(ns);\n}\n\nstatic int nvme_open(struct gendisk *disk, blk_mode_t mode)\n{\n\treturn nvme_ns_open(disk->private_data);\n}\n\nstatic void nvme_release(struct gendisk *disk)\n{\n\tnvme_ns_release(disk->private_data);\n}\n\nint nvme_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\t \n\tgeo->heads = 1 << 6;\n\tgeo->sectors = 1 << 5;\n\tgeo->cylinders = get_capacity(bdev->bd_disk) >> 11;\n\treturn 0;\n}\n\n#ifdef CONFIG_BLK_DEV_INTEGRITY\nstatic void nvme_init_integrity(struct gendisk *disk, struct nvme_ns *ns,\n\t\t\t\tu32 max_integrity_segments)\n{\n\tstruct blk_integrity integrity = { };\n\n\tswitch (ns->pi_type) {\n\tcase NVME_NS_DPS_PI_TYPE3:\n\t\tswitch (ns->guard_type) {\n\t\tcase NVME_NVM_NS_16B_GUARD:\n\t\t\tintegrity.profile = &t10_pi_type3_crc;\n\t\t\tintegrity.tag_size = sizeof(u16) + sizeof(u32);\n\t\t\tintegrity.flags |= BLK_INTEGRITY_DEVICE_CAPABLE;\n\t\t\tbreak;\n\t\tcase NVME_NVM_NS_64B_GUARD:\n\t\t\tintegrity.profile = &ext_pi_type3_crc64;\n\t\t\tintegrity.tag_size = sizeof(u16) + 6;\n\t\t\tintegrity.flags |= BLK_INTEGRITY_DEVICE_CAPABLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tintegrity.profile = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NVME_NS_DPS_PI_TYPE1:\n\tcase NVME_NS_DPS_PI_TYPE2:\n\t\tswitch (ns->guard_type) {\n\t\tcase NVME_NVM_NS_16B_GUARD:\n\t\t\tintegrity.profile = &t10_pi_type1_crc;\n\t\t\tintegrity.tag_size = sizeof(u16);\n\t\t\tintegrity.flags |= BLK_INTEGRITY_DEVICE_CAPABLE;\n\t\t\tbreak;\n\t\tcase NVME_NVM_NS_64B_GUARD:\n\t\t\tintegrity.profile = &ext_pi_type1_crc64;\n\t\t\tintegrity.tag_size = sizeof(u16);\n\t\t\tintegrity.flags |= BLK_INTEGRITY_DEVICE_CAPABLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tintegrity.profile = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tintegrity.profile = NULL;\n\t\tbreak;\n\t}\n\n\tintegrity.tuple_size = ns->ms;\n\tblk_integrity_register(disk, &integrity);\n\tblk_queue_max_integrity_segments(disk->queue, max_integrity_segments);\n}\n#else\nstatic void nvme_init_integrity(struct gendisk *disk, struct nvme_ns *ns,\n\t\t\t\tu32 max_integrity_segments)\n{\n}\n#endif  \n\nstatic void nvme_config_discard(struct gendisk *disk, struct nvme_ns *ns)\n{\n\tstruct nvme_ctrl *ctrl = ns->ctrl;\n\tstruct request_queue *queue = disk->queue;\n\tu32 size = queue_logical_block_size(queue);\n\n\tif (ctrl->dmrsl && ctrl->dmrsl <= nvme_sect_to_lba(ns, UINT_MAX))\n\t\tctrl->max_discard_sectors = nvme_lba_to_sect(ns, ctrl->dmrsl);\n\n\tif (ctrl->max_discard_sectors == 0) {\n\t\tblk_queue_max_discard_sectors(queue, 0);\n\t\treturn;\n\t}\n\n\tBUILD_BUG_ON(PAGE_SIZE / sizeof(struct nvme_dsm_range) <\n\t\t\tNVME_DSM_MAX_RANGES);\n\n\tqueue->limits.discard_granularity = size;\n\n\t \n\tif (queue->limits.max_discard_sectors)\n\t\treturn;\n\n\tblk_queue_max_discard_sectors(queue, ctrl->max_discard_sectors);\n\tblk_queue_max_discard_segments(queue, ctrl->max_discard_segments);\n\n\tif (ctrl->quirks & NVME_QUIRK_DEALLOCATE_ZEROES)\n\t\tblk_queue_max_write_zeroes_sectors(queue, UINT_MAX);\n}\n\nstatic bool nvme_ns_ids_equal(struct nvme_ns_ids *a, struct nvme_ns_ids *b)\n{\n\treturn uuid_equal(&a->uuid, &b->uuid) &&\n\t\tmemcmp(&a->nguid, &b->nguid, sizeof(a->nguid)) == 0 &&\n\t\tmemcmp(&a->eui64, &b->eui64, sizeof(a->eui64)) == 0 &&\n\t\ta->csi == b->csi;\n}\n\nstatic int nvme_init_ms(struct nvme_ns *ns, struct nvme_id_ns *id)\n{\n\tbool first = id->dps & NVME_NS_DPS_PI_FIRST;\n\tunsigned lbaf = nvme_lbaf_index(id->flbas);\n\tstruct nvme_ctrl *ctrl = ns->ctrl;\n\tstruct nvme_command c = { };\n\tstruct nvme_id_ns_nvm *nvm;\n\tint ret = 0;\n\tu32 elbaf;\n\n\tns->pi_size = 0;\n\tns->ms = le16_to_cpu(id->lbaf[lbaf].ms);\n\tif (!(ctrl->ctratt & NVME_CTRL_ATTR_ELBAS)) {\n\t\tns->pi_size = sizeof(struct t10_pi_tuple);\n\t\tns->guard_type = NVME_NVM_NS_16B_GUARD;\n\t\tgoto set_pi;\n\t}\n\n\tnvm = kzalloc(sizeof(*nvm), GFP_KERNEL);\n\tif (!nvm)\n\t\treturn -ENOMEM;\n\n\tc.identify.opcode = nvme_admin_identify;\n\tc.identify.nsid = cpu_to_le32(ns->head->ns_id);\n\tc.identify.cns = NVME_ID_CNS_CS_NS;\n\tc.identify.csi = NVME_CSI_NVM;\n\n\tret = nvme_submit_sync_cmd(ns->ctrl->admin_q, &c, nvm, sizeof(*nvm));\n\tif (ret)\n\t\tgoto free_data;\n\n\telbaf = le32_to_cpu(nvm->elbaf[lbaf]);\n\n\t \n\tif (nvme_elbaf_sts(elbaf))\n\t\tgoto free_data;\n\n\tns->guard_type = nvme_elbaf_guard_type(elbaf);\n\tswitch (ns->guard_type) {\n\tcase NVME_NVM_NS_64B_GUARD:\n\t\tns->pi_size = sizeof(struct crc64_pi_tuple);\n\t\tbreak;\n\tcase NVME_NVM_NS_16B_GUARD:\n\t\tns->pi_size = sizeof(struct t10_pi_tuple);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nfree_data:\n\tkfree(nvm);\nset_pi:\n\tif (ns->pi_size && (first || ns->ms == ns->pi_size))\n\t\tns->pi_type = id->dps & NVME_NS_DPS_PI_MASK;\n\telse\n\t\tns->pi_type = 0;\n\n\treturn ret;\n}\n\nstatic int nvme_configure_metadata(struct nvme_ns *ns, struct nvme_id_ns *id)\n{\n\tstruct nvme_ctrl *ctrl = ns->ctrl;\n\tint ret;\n\n\tret = nvme_init_ms(ns, id);\n\tif (ret)\n\t\treturn ret;\n\n\tns->features &= ~(NVME_NS_METADATA_SUPPORTED | NVME_NS_EXT_LBAS);\n\tif (!ns->ms || !(ctrl->ops->flags & NVME_F_METADATA_SUPPORTED))\n\t\treturn 0;\n\n\tif (ctrl->ops->flags & NVME_F_FABRICS) {\n\t\t \n\t\tif (WARN_ON_ONCE(!(id->flbas & NVME_NS_FLBAS_META_EXT)))\n\t\t\treturn 0;\n\n\t\tns->features |= NVME_NS_EXT_LBAS;\n\n\t\t \n\t\tif (ctrl->max_integrity_segments && nvme_ns_has_pi(ns))\n\t\t\tns->features |= NVME_NS_METADATA_SUPPORTED;\n\t} else {\n\t\t \n\t\tif (id->flbas & NVME_NS_FLBAS_META_EXT)\n\t\t\tns->features |= NVME_NS_EXT_LBAS;\n\t\telse\n\t\t\tns->features |= NVME_NS_METADATA_SUPPORTED;\n\t}\n\treturn 0;\n}\n\nstatic void nvme_set_queue_limits(struct nvme_ctrl *ctrl,\n\t\tstruct request_queue *q)\n{\n\tbool vwc = ctrl->vwc & NVME_CTRL_VWC_PRESENT;\n\n\tif (ctrl->max_hw_sectors) {\n\t\tu32 max_segments =\n\t\t\t(ctrl->max_hw_sectors / (NVME_CTRL_PAGE_SIZE >> 9)) + 1;\n\n\t\tmax_segments = min_not_zero(max_segments, ctrl->max_segments);\n\t\tblk_queue_max_hw_sectors(q, ctrl->max_hw_sectors);\n\t\tblk_queue_max_segments(q, min_t(u32, max_segments, USHRT_MAX));\n\t}\n\tblk_queue_virt_boundary(q, NVME_CTRL_PAGE_SIZE - 1);\n\tblk_queue_dma_alignment(q, 3);\n\tblk_queue_write_cache(q, vwc, vwc);\n}\n\nstatic void nvme_update_disk_info(struct gendisk *disk,\n\t\tstruct nvme_ns *ns, struct nvme_id_ns *id)\n{\n\tsector_t capacity = nvme_lba_to_sect(ns, le64_to_cpu(id->nsze));\n\tu32 bs = 1U << ns->lba_shift;\n\tu32 atomic_bs, phys_bs, io_opt = 0;\n\n\t \n\tif (ns->lba_shift > PAGE_SHIFT || ns->lba_shift < SECTOR_SHIFT) {\n\t\tcapacity = 0;\n\t\tbs = (1 << 9);\n\t}\n\n\tblk_integrity_unregister(disk);\n\n\tatomic_bs = phys_bs = bs;\n\tif (id->nabo == 0) {\n\t\t \n\t\tif (id->nsfeat & NVME_NS_FEAT_ATOMICS && id->nawupf)\n\t\t\tatomic_bs = (1 + le16_to_cpu(id->nawupf)) * bs;\n\t\telse\n\t\t\tatomic_bs = (1 + ns->ctrl->subsys->awupf) * bs;\n\t}\n\n\tif (id->nsfeat & NVME_NS_FEAT_IO_OPT) {\n\t\t \n\t\tphys_bs = bs * (1 + le16_to_cpu(id->npwg));\n\t\t \n\t\tio_opt = bs * (1 + le16_to_cpu(id->nows));\n\t}\n\n\tblk_queue_logical_block_size(disk->queue, bs);\n\t \n\tblk_queue_physical_block_size(disk->queue, min(phys_bs, atomic_bs));\n\tblk_queue_io_min(disk->queue, phys_bs);\n\tblk_queue_io_opt(disk->queue, io_opt);\n\n\t \n\tif (ns->ms) {\n\t\tif (IS_ENABLED(CONFIG_BLK_DEV_INTEGRITY) &&\n\t\t    (ns->features & NVME_NS_METADATA_SUPPORTED))\n\t\t\tnvme_init_integrity(disk, ns,\n\t\t\t\t\t    ns->ctrl->max_integrity_segments);\n\t\telse if (!nvme_ns_has_pi(ns))\n\t\t\tcapacity = 0;\n\t}\n\n\tset_capacity_and_notify(disk, capacity);\n\n\tnvme_config_discard(disk, ns);\n\tblk_queue_max_write_zeroes_sectors(disk->queue,\n\t\t\t\t\t   ns->ctrl->max_zeroes_sectors);\n}\n\nstatic bool nvme_ns_is_readonly(struct nvme_ns *ns, struct nvme_ns_info *info)\n{\n\treturn info->is_readonly || test_bit(NVME_NS_FORCE_RO, &ns->flags);\n}\n\nstatic inline bool nvme_first_scan(struct gendisk *disk)\n{\n\t \n\treturn !disk_live(disk);\n}\n\nstatic void nvme_set_chunk_sectors(struct nvme_ns *ns, struct nvme_id_ns *id)\n{\n\tstruct nvme_ctrl *ctrl = ns->ctrl;\n\tu32 iob;\n\n\tif ((ctrl->quirks & NVME_QUIRK_STRIPE_SIZE) &&\n\t    is_power_of_2(ctrl->max_hw_sectors))\n\t\tiob = ctrl->max_hw_sectors;\n\telse\n\t\tiob = nvme_lba_to_sect(ns, le16_to_cpu(id->noiob));\n\n\tif (!iob)\n\t\treturn;\n\n\tif (!is_power_of_2(iob)) {\n\t\tif (nvme_first_scan(ns->disk))\n\t\t\tpr_warn(\"%s: ignoring unaligned IO boundary:%u\\n\",\n\t\t\t\tns->disk->disk_name, iob);\n\t\treturn;\n\t}\n\n\tif (blk_queue_is_zoned(ns->disk->queue)) {\n\t\tif (nvme_first_scan(ns->disk))\n\t\t\tpr_warn(\"%s: ignoring zoned namespace IO boundary\\n\",\n\t\t\t\tns->disk->disk_name);\n\t\treturn;\n\t}\n\n\tblk_queue_chunk_sectors(ns->queue, iob);\n}\n\nstatic int nvme_update_ns_info_generic(struct nvme_ns *ns,\n\t\tstruct nvme_ns_info *info)\n{\n\tblk_mq_freeze_queue(ns->disk->queue);\n\tnvme_set_queue_limits(ns->ctrl, ns->queue);\n\tset_disk_ro(ns->disk, nvme_ns_is_readonly(ns, info));\n\tblk_mq_unfreeze_queue(ns->disk->queue);\n\n\tif (nvme_ns_head_multipath(ns->head)) {\n\t\tblk_mq_freeze_queue(ns->head->disk->queue);\n\t\tset_disk_ro(ns->head->disk, nvme_ns_is_readonly(ns, info));\n\t\tnvme_mpath_revalidate_paths(ns);\n\t\tblk_stack_limits(&ns->head->disk->queue->limits,\n\t\t\t\t &ns->queue->limits, 0);\n\t\tns->head->disk->flags |= GENHD_FL_HIDDEN;\n\t\tblk_mq_unfreeze_queue(ns->head->disk->queue);\n\t}\n\n\t \n\tns->disk->flags |= GENHD_FL_HIDDEN;\n\tset_bit(NVME_NS_READY, &ns->flags);\n\n\treturn 0;\n}\n\nstatic int nvme_update_ns_info_block(struct nvme_ns *ns,\n\t\tstruct nvme_ns_info *info)\n{\n\tstruct nvme_id_ns *id;\n\tunsigned lbaf;\n\tint ret;\n\n\tret = nvme_identify_ns(ns->ctrl, info->nsid, &id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (id->ncap == 0) {\n\t\t \n\t\tinfo->is_removed = true;\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tblk_mq_freeze_queue(ns->disk->queue);\n\tlbaf = nvme_lbaf_index(id->flbas);\n\tns->lba_shift = id->lbaf[lbaf].ds;\n\tnvme_set_queue_limits(ns->ctrl, ns->queue);\n\n\tret = nvme_configure_metadata(ns, id);\n\tif (ret < 0) {\n\t\tblk_mq_unfreeze_queue(ns->disk->queue);\n\t\tgoto out;\n\t}\n\tnvme_set_chunk_sectors(ns, id);\n\tnvme_update_disk_info(ns->disk, ns, id);\n\n\tif (ns->head->ids.csi == NVME_CSI_ZNS) {\n\t\tret = nvme_update_zone_info(ns, lbaf);\n\t\tif (ret) {\n\t\t\tblk_mq_unfreeze_queue(ns->disk->queue);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif ((id->dlfeat & 0x7) == 0x1 && (id->dlfeat & (1 << 3)))\n\t\tns->features |= NVME_NS_DEAC;\n\tset_disk_ro(ns->disk, nvme_ns_is_readonly(ns, info));\n\tset_bit(NVME_NS_READY, &ns->flags);\n\tblk_mq_unfreeze_queue(ns->disk->queue);\n\n\tif (blk_queue_is_zoned(ns->queue)) {\n\t\tret = nvme_revalidate_zones(ns);\n\t\tif (ret && !nvme_first_scan(ns->disk))\n\t\t\tgoto out;\n\t}\n\n\tif (nvme_ns_head_multipath(ns->head)) {\n\t\tblk_mq_freeze_queue(ns->head->disk->queue);\n\t\tnvme_update_disk_info(ns->head->disk, ns, id);\n\t\tset_disk_ro(ns->head->disk, nvme_ns_is_readonly(ns, info));\n\t\tnvme_mpath_revalidate_paths(ns);\n\t\tblk_stack_limits(&ns->head->disk->queue->limits,\n\t\t\t\t &ns->queue->limits, 0);\n\t\tdisk_update_readahead(ns->head->disk);\n\t\tblk_mq_unfreeze_queue(ns->head->disk->queue);\n\t}\n\n\tret = 0;\nout:\n\t \n\tif (ret == -ENODEV) {\n\t\tns->disk->flags |= GENHD_FL_HIDDEN;\n\t\tset_bit(NVME_NS_READY, &ns->flags);\n\t\tret = 0;\n\t}\n\nerror:\n\tkfree(id);\n\treturn ret;\n}\n\nstatic int nvme_update_ns_info(struct nvme_ns *ns, struct nvme_ns_info *info)\n{\n\tswitch (info->ids.csi) {\n\tcase NVME_CSI_ZNS:\n\t\tif (!IS_ENABLED(CONFIG_BLK_DEV_ZONED)) {\n\t\t\tdev_info(ns->ctrl->device,\n\t\"block device for nsid %u not supported without CONFIG_BLK_DEV_ZONED\\n\",\n\t\t\t\tinfo->nsid);\n\t\t\treturn nvme_update_ns_info_generic(ns, info);\n\t\t}\n\t\treturn nvme_update_ns_info_block(ns, info);\n\tcase NVME_CSI_NVM:\n\t\treturn nvme_update_ns_info_block(ns, info);\n\tdefault:\n\t\tdev_info(ns->ctrl->device,\n\t\t\t\"block device for nsid %u not supported (csi %u)\\n\",\n\t\t\tinfo->nsid, info->ids.csi);\n\t\treturn nvme_update_ns_info_generic(ns, info);\n\t}\n}\n\n#ifdef CONFIG_BLK_SED_OPAL\nstatic int nvme_sec_submit(void *data, u16 spsp, u8 secp, void *buffer, size_t len,\n\t\tbool send)\n{\n\tstruct nvme_ctrl *ctrl = data;\n\tstruct nvme_command cmd = { };\n\n\tif (send)\n\t\tcmd.common.opcode = nvme_admin_security_send;\n\telse\n\t\tcmd.common.opcode = nvme_admin_security_recv;\n\tcmd.common.nsid = 0;\n\tcmd.common.cdw10 = cpu_to_le32(((u32)secp) << 24 | ((u32)spsp) << 8);\n\tcmd.common.cdw11 = cpu_to_le32(len);\n\n\treturn __nvme_submit_sync_cmd(ctrl->admin_q, &cmd, NULL, buffer, len,\n\t\t\tNVME_QID_ANY, 1, 0);\n}\n\nstatic void nvme_configure_opal(struct nvme_ctrl *ctrl, bool was_suspended)\n{\n\tif (ctrl->oacs & NVME_CTRL_OACS_SEC_SUPP) {\n\t\tif (!ctrl->opal_dev)\n\t\t\tctrl->opal_dev = init_opal_dev(ctrl, &nvme_sec_submit);\n\t\telse if (was_suspended)\n\t\t\topal_unlock_from_suspend(ctrl->opal_dev);\n\t} else {\n\t\tfree_opal_dev(ctrl->opal_dev);\n\t\tctrl->opal_dev = NULL;\n\t}\n}\n#else\nstatic void nvme_configure_opal(struct nvme_ctrl *ctrl, bool was_suspended)\n{\n}\n#endif  \n\n#ifdef CONFIG_BLK_DEV_ZONED\nstatic int nvme_report_zones(struct gendisk *disk, sector_t sector,\n\t\tunsigned int nr_zones, report_zones_cb cb, void *data)\n{\n\treturn nvme_ns_report_zones(disk->private_data, sector, nr_zones, cb,\n\t\t\tdata);\n}\n#else\n#define nvme_report_zones\tNULL\n#endif  \n\nconst struct block_device_operations nvme_bdev_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.ioctl\t\t= nvme_ioctl,\n\t.compat_ioctl\t= blkdev_compat_ptr_ioctl,\n\t.open\t\t= nvme_open,\n\t.release\t= nvme_release,\n\t.getgeo\t\t= nvme_getgeo,\n\t.report_zones\t= nvme_report_zones,\n\t.pr_ops\t\t= &nvme_pr_ops,\n};\n\nstatic int nvme_wait_ready(struct nvme_ctrl *ctrl, u32 mask, u32 val,\n\t\tu32 timeout, const char *op)\n{\n\tunsigned long timeout_jiffies = jiffies + timeout * HZ;\n\tu32 csts;\n\tint ret;\n\n\twhile ((ret = ctrl->ops->reg_read32(ctrl, NVME_REG_CSTS, &csts)) == 0) {\n\t\tif (csts == ~0)\n\t\t\treturn -ENODEV;\n\t\tif ((csts & mask) == val)\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn -EINTR;\n\t\tif (time_after(jiffies, timeout_jiffies)) {\n\t\t\tdev_err(ctrl->device,\n\t\t\t\t\"Device not ready; aborting %s, CSTS=0x%x\\n\",\n\t\t\t\top, csts);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint nvme_disable_ctrl(struct nvme_ctrl *ctrl, bool shutdown)\n{\n\tint ret;\n\n\tctrl->ctrl_config &= ~NVME_CC_SHN_MASK;\n\tif (shutdown)\n\t\tctrl->ctrl_config |= NVME_CC_SHN_NORMAL;\n\telse\n\t\tctrl->ctrl_config &= ~NVME_CC_ENABLE;\n\n\tret = ctrl->ops->reg_write32(ctrl, NVME_REG_CC, ctrl->ctrl_config);\n\tif (ret)\n\t\treturn ret;\n\n\tif (shutdown) {\n\t\treturn nvme_wait_ready(ctrl, NVME_CSTS_SHST_MASK,\n\t\t\t\t       NVME_CSTS_SHST_CMPLT,\n\t\t\t\t       ctrl->shutdown_timeout, \"shutdown\");\n\t}\n\tif (ctrl->quirks & NVME_QUIRK_DELAY_BEFORE_CHK_RDY)\n\t\tmsleep(NVME_QUIRK_DELAY_AMOUNT);\n\treturn nvme_wait_ready(ctrl, NVME_CSTS_RDY, 0,\n\t\t\t       (NVME_CAP_TIMEOUT(ctrl->cap) + 1) / 2, \"reset\");\n}\nEXPORT_SYMBOL_GPL(nvme_disable_ctrl);\n\nint nvme_enable_ctrl(struct nvme_ctrl *ctrl)\n{\n\tunsigned dev_page_min;\n\tu32 timeout;\n\tint ret;\n\n\tret = ctrl->ops->reg_read64(ctrl, NVME_REG_CAP, &ctrl->cap);\n\tif (ret) {\n\t\tdev_err(ctrl->device, \"Reading CAP failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_page_min = NVME_CAP_MPSMIN(ctrl->cap) + 12;\n\n\tif (NVME_CTRL_PAGE_SHIFT < dev_page_min) {\n\t\tdev_err(ctrl->device,\n\t\t\t\"Minimum device page size %u too large for host (%u)\\n\",\n\t\t\t1 << dev_page_min, 1 << NVME_CTRL_PAGE_SHIFT);\n\t\treturn -ENODEV;\n\t}\n\n\tif (NVME_CAP_CSS(ctrl->cap) & NVME_CAP_CSS_CSI)\n\t\tctrl->ctrl_config = NVME_CC_CSS_CSI;\n\telse\n\t\tctrl->ctrl_config = NVME_CC_CSS_NVM;\n\n\tif (ctrl->cap & NVME_CAP_CRMS_CRWMS && ctrl->cap & NVME_CAP_CRMS_CRIMS)\n\t\tctrl->ctrl_config |= NVME_CC_CRIME;\n\n\tctrl->ctrl_config |= (NVME_CTRL_PAGE_SHIFT - 12) << NVME_CC_MPS_SHIFT;\n\tctrl->ctrl_config |= NVME_CC_AMS_RR | NVME_CC_SHN_NONE;\n\tctrl->ctrl_config |= NVME_CC_IOSQES | NVME_CC_IOCQES;\n\tret = ctrl->ops->reg_write32(ctrl, NVME_REG_CC, ctrl->ctrl_config);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ctrl->ops->reg_read32(ctrl, NVME_REG_CC, &ctrl->ctrl_config);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ctrl->ops->reg_read64(ctrl, NVME_REG_CAP, &ctrl->cap);\n\tif (ret)\n\t\treturn ret;\n\n\ttimeout = NVME_CAP_TIMEOUT(ctrl->cap);\n\tif (ctrl->cap & NVME_CAP_CRMS_CRWMS) {\n\t\tu32 crto, ready_timeout;\n\n\t\tret = ctrl->ops->reg_read32(ctrl, NVME_REG_CRTO, &crto);\n\t\tif (ret) {\n\t\t\tdev_err(ctrl->device, \"Reading CRTO failed (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (ctrl->ctrl_config & NVME_CC_CRIME)\n\t\t\tready_timeout = NVME_CRTO_CRIMT(crto);\n\t\telse\n\t\t\tready_timeout = NVME_CRTO_CRWMT(crto);\n\n\t\tif (ready_timeout < timeout)\n\t\t\tdev_warn_once(ctrl->device, \"bad crto:%x cap:%llx\\n\",\n\t\t\t\t      crto, ctrl->cap);\n\t\telse\n\t\t\ttimeout = ready_timeout;\n\t}\n\n\tctrl->ctrl_config |= NVME_CC_ENABLE;\n\tret = ctrl->ops->reg_write32(ctrl, NVME_REG_CC, ctrl->ctrl_config);\n\tif (ret)\n\t\treturn ret;\n\treturn nvme_wait_ready(ctrl, NVME_CSTS_RDY, NVME_CSTS_RDY,\n\t\t\t       (timeout + 1) / 2, \"initialisation\");\n}\nEXPORT_SYMBOL_GPL(nvme_enable_ctrl);\n\nstatic int nvme_configure_timestamp(struct nvme_ctrl *ctrl)\n{\n\t__le64 ts;\n\tint ret;\n\n\tif (!(ctrl->oncs & NVME_CTRL_ONCS_TIMESTAMP))\n\t\treturn 0;\n\n\tts = cpu_to_le64(ktime_to_ms(ktime_get_real()));\n\tret = nvme_set_features(ctrl, NVME_FEAT_TIMESTAMP, 0, &ts, sizeof(ts),\n\t\t\tNULL);\n\tif (ret)\n\t\tdev_warn_once(ctrl->device,\n\t\t\t\"could not set timestamp (%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic int nvme_configure_host_options(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_feat_host_behavior *host;\n\tu8 acre = 0, lbafee = 0;\n\tint ret;\n\n\t \n\tif (ctrl->crdt[0])\n\t\tacre = NVME_ENABLE_ACRE;\n\tif (ctrl->ctratt & NVME_CTRL_ATTR_ELBAS)\n\t\tlbafee = NVME_ENABLE_LBAFEE;\n\n\tif (!acre && !lbafee)\n\t\treturn 0;\n\n\thost = kzalloc(sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn 0;\n\n\thost->acre = acre;\n\thost->lbafee = lbafee;\n\tret = nvme_set_features(ctrl, NVME_FEAT_HOST_BEHAVIOR, 0,\n\t\t\t\thost, sizeof(*host), NULL);\n\tkfree(host);\n\treturn ret;\n}\n\n \nstatic bool nvme_apst_get_transition_time(u64 total_latency,\n\t\tu64 *transition_time, unsigned *last_index)\n{\n\tif (total_latency <= apst_primary_latency_tol_us) {\n\t\tif (*last_index == 1)\n\t\t\treturn false;\n\t\t*last_index = 1;\n\t\t*transition_time = apst_primary_timeout_ms;\n\t\treturn true;\n\t}\n\tif (apst_secondary_timeout_ms &&\n\t\ttotal_latency <= apst_secondary_latency_tol_us) {\n\t\tif (*last_index <= 2)\n\t\t\treturn false;\n\t\t*last_index = 2;\n\t\t*transition_time = apst_secondary_timeout_ms;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic int nvme_configure_apst(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_feat_auto_pst *table;\n\tunsigned apste = 0;\n\tu64 max_lat_us = 0;\n\t__le64 target = 0;\n\tint max_ps = -1;\n\tint state;\n\tint ret;\n\tunsigned last_lt_index = UINT_MAX;\n\n\t \n\tif (!ctrl->apsta)\n\t\treturn 0;\n\n\tif (ctrl->npss > 31) {\n\t\tdev_warn(ctrl->device, \"NPSS is invalid; not using APST\\n\");\n\t\treturn 0;\n\t}\n\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn 0;\n\n\tif (!ctrl->apst_enabled || ctrl->ps_max_latency_us == 0) {\n\t\t \n\t\tdev_dbg(ctrl->device, \"APST disabled\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tfor (state = (int)ctrl->npss; state >= 0; state--) {\n\t\tu64 total_latency_us, exit_latency_us, transition_ms;\n\n\t\tif (target)\n\t\t\ttable->entries[state] = target;\n\n\t\t \n\t\tif (state == ctrl->npss &&\n\t\t    (ctrl->quirks & NVME_QUIRK_NO_DEEPEST_PS))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!(ctrl->psd[state].flags & NVME_PS_FLAGS_NON_OP_STATE))\n\t\t\tcontinue;\n\n\t\texit_latency_us = (u64)le32_to_cpu(ctrl->psd[state].exit_lat);\n\t\tif (exit_latency_us > ctrl->ps_max_latency_us)\n\t\t\tcontinue;\n\n\t\ttotal_latency_us = exit_latency_us +\n\t\t\tle32_to_cpu(ctrl->psd[state].entry_lat);\n\n\t\t \n\t\tif (apst_primary_timeout_ms && apst_primary_latency_tol_us) {\n\t\t\tif (!nvme_apst_get_transition_time(total_latency_us,\n\t\t\t\t\t&transition_ms, &last_lt_index))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\ttransition_ms = total_latency_us + 19;\n\t\t\tdo_div(transition_ms, 20);\n\t\t\tif (transition_ms > (1 << 24) - 1)\n\t\t\t\ttransition_ms = (1 << 24) - 1;\n\t\t}\n\n\t\ttarget = cpu_to_le64((state << 3) | (transition_ms << 8));\n\t\tif (max_ps == -1)\n\t\t\tmax_ps = state;\n\t\tif (total_latency_us > max_lat_us)\n\t\t\tmax_lat_us = total_latency_us;\n\t}\n\n\tif (max_ps == -1)\n\t\tdev_dbg(ctrl->device, \"APST enabled but no non-operational states are available\\n\");\n\telse\n\t\tdev_dbg(ctrl->device, \"APST enabled: max PS = %d, max round-trip latency = %lluus, table = %*phN\\n\",\n\t\t\tmax_ps, max_lat_us, (int)sizeof(*table), table);\n\tapste = 1;\n\ndone:\n\tret = nvme_set_features(ctrl, NVME_FEAT_AUTO_PST, apste,\n\t\t\t\ttable, sizeof(*table), NULL);\n\tif (ret)\n\t\tdev_err(ctrl->device, \"failed to set APST feature (%d)\\n\", ret);\n\tkfree(table);\n\treturn ret;\n}\n\nstatic void nvme_set_latency_tolerance(struct device *dev, s32 val)\n{\n\tstruct nvme_ctrl *ctrl = dev_get_drvdata(dev);\n\tu64 latency;\n\n\tswitch (val) {\n\tcase PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT:\n\tcase PM_QOS_LATENCY_ANY:\n\t\tlatency = U64_MAX;\n\t\tbreak;\n\n\tdefault:\n\t\tlatency = val;\n\t}\n\n\tif (ctrl->ps_max_latency_us != latency) {\n\t\tctrl->ps_max_latency_us = latency;\n\t\tif (nvme_ctrl_state(ctrl) == NVME_CTRL_LIVE)\n\t\t\tnvme_configure_apst(ctrl);\n\t}\n}\n\nstruct nvme_core_quirk_entry {\n\t \n\tu16 vid;\n\tconst char *mn;\n\tconst char *fr;\n\tunsigned long quirks;\n};\n\nstatic const struct nvme_core_quirk_entry core_quirks[] = {\n\t{\n\t\t \n\t\t.vid = 0x1179,\n\t\t.mn = \"THNSF5256GPUK TOSHIBA\",\n\t\t.quirks = NVME_QUIRK_NO_APST,\n\t},\n\t{\n\t\t \n\t\t.vid = 0x14a4,\n\t\t.fr = \"22301111\",\n\t\t.quirks = NVME_QUIRK_SIMPLE_SUSPEND,\n\t},\n\t{\n\t\t \n\t\t.vid = 0x1e0f,\n\t\t.mn = \"KCD6XVUL6T40\",\n\t\t.quirks = NVME_QUIRK_NO_APST,\n\t},\n\t{\n\t\t \n\t\t.vid = 0x144d,\n\t\t.mn = \"Samsung Portable SSD X5\",\n\t\t.quirks = NVME_QUIRK_DELAY_BEFORE_CHK_RDY |\n\t\t\t  NVME_QUIRK_NO_DEEPEST_PS |\n\t\t\t  NVME_QUIRK_IGNORE_DEV_SUBNQN,\n\t}\n};\n\n \nstatic bool string_matches(const char *idstr, const char *match, size_t len)\n{\n\tsize_t matchlen;\n\n\tif (!match)\n\t\treturn true;\n\n\tmatchlen = strlen(match);\n\tWARN_ON_ONCE(matchlen > len);\n\n\tif (memcmp(idstr, match, matchlen))\n\t\treturn false;\n\n\tfor (; matchlen < len; matchlen++)\n\t\tif (idstr[matchlen] != ' ')\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool quirk_matches(const struct nvme_id_ctrl *id,\n\t\t\t  const struct nvme_core_quirk_entry *q)\n{\n\treturn q->vid == le16_to_cpu(id->vid) &&\n\t\tstring_matches(id->mn, q->mn, sizeof(id->mn)) &&\n\t\tstring_matches(id->fr, q->fr, sizeof(id->fr));\n}\n\nstatic void nvme_init_subnqn(struct nvme_subsystem *subsys, struct nvme_ctrl *ctrl,\n\t\tstruct nvme_id_ctrl *id)\n{\n\tsize_t nqnlen;\n\tint off;\n\n\tif(!(ctrl->quirks & NVME_QUIRK_IGNORE_DEV_SUBNQN)) {\n\t\tnqnlen = strnlen(id->subnqn, NVMF_NQN_SIZE);\n\t\tif (nqnlen > 0 && nqnlen < NVMF_NQN_SIZE) {\n\t\t\tstrscpy(subsys->subnqn, id->subnqn, NVMF_NQN_SIZE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (ctrl->vs >= NVME_VS(1, 2, 1))\n\t\t\tdev_warn(ctrl->device, \"missing or invalid SUBNQN field.\\n\");\n\t}\n\n\t \n\toff = snprintf(subsys->subnqn, NVMF_NQN_SIZE,\n\t\t\t\"nqn.2014.08.org.nvmexpress:%04x%04x\",\n\t\t\tle16_to_cpu(id->vid), le16_to_cpu(id->ssvid));\n\tmemcpy(subsys->subnqn + off, id->sn, sizeof(id->sn));\n\toff += sizeof(id->sn);\n\tmemcpy(subsys->subnqn + off, id->mn, sizeof(id->mn));\n\toff += sizeof(id->mn);\n\tmemset(subsys->subnqn + off, 0, sizeof(subsys->subnqn) - off);\n}\n\nstatic void nvme_release_subsystem(struct device *dev)\n{\n\tstruct nvme_subsystem *subsys =\n\t\tcontainer_of(dev, struct nvme_subsystem, dev);\n\n\tif (subsys->instance >= 0)\n\t\tida_free(&nvme_instance_ida, subsys->instance);\n\tkfree(subsys);\n}\n\nstatic void nvme_destroy_subsystem(struct kref *ref)\n{\n\tstruct nvme_subsystem *subsys =\n\t\t\tcontainer_of(ref, struct nvme_subsystem, ref);\n\n\tmutex_lock(&nvme_subsystems_lock);\n\tlist_del(&subsys->entry);\n\tmutex_unlock(&nvme_subsystems_lock);\n\n\tida_destroy(&subsys->ns_ida);\n\tdevice_del(&subsys->dev);\n\tput_device(&subsys->dev);\n}\n\nstatic void nvme_put_subsystem(struct nvme_subsystem *subsys)\n{\n\tkref_put(&subsys->ref, nvme_destroy_subsystem);\n}\n\nstatic struct nvme_subsystem *__nvme_find_get_subsystem(const char *subsysnqn)\n{\n\tstruct nvme_subsystem *subsys;\n\n\tlockdep_assert_held(&nvme_subsystems_lock);\n\n\t \n\tif (!strcmp(subsysnqn, NVME_DISC_SUBSYS_NAME))\n\t\treturn NULL;\n\n\tlist_for_each_entry(subsys, &nvme_subsystems, entry) {\n\t\tif (strcmp(subsys->subnqn, subsysnqn))\n\t\t\tcontinue;\n\t\tif (!kref_get_unless_zero(&subsys->ref))\n\t\t\tcontinue;\n\t\treturn subsys;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline bool nvme_discovery_ctrl(struct nvme_ctrl *ctrl)\n{\n\treturn ctrl->opts && ctrl->opts->discovery_nqn;\n}\n\nstatic bool nvme_validate_cntlid(struct nvme_subsystem *subsys,\n\t\tstruct nvme_ctrl *ctrl, struct nvme_id_ctrl *id)\n{\n\tstruct nvme_ctrl *tmp;\n\n\tlockdep_assert_held(&nvme_subsystems_lock);\n\n\tlist_for_each_entry(tmp, &subsys->ctrls, subsys_entry) {\n\t\tif (nvme_state_terminal(tmp))\n\t\t\tcontinue;\n\n\t\tif (tmp->cntlid == ctrl->cntlid) {\n\t\t\tdev_err(ctrl->device,\n\t\t\t\t\"Duplicate cntlid %u with %s, subsys %s, rejecting\\n\",\n\t\t\t\tctrl->cntlid, dev_name(tmp->device),\n\t\t\t\tsubsys->subnqn);\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((id->cmic & NVME_CTRL_CMIC_MULTI_CTRL) ||\n\t\t    nvme_discovery_ctrl(ctrl))\n\t\t\tcontinue;\n\n\t\tdev_err(ctrl->device,\n\t\t\t\"Subsystem does not support multiple controllers\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int nvme_init_subsystem(struct nvme_ctrl *ctrl, struct nvme_id_ctrl *id)\n{\n\tstruct nvme_subsystem *subsys, *found;\n\tint ret;\n\n\tsubsys = kzalloc(sizeof(*subsys), GFP_KERNEL);\n\tif (!subsys)\n\t\treturn -ENOMEM;\n\n\tsubsys->instance = -1;\n\tmutex_init(&subsys->lock);\n\tkref_init(&subsys->ref);\n\tINIT_LIST_HEAD(&subsys->ctrls);\n\tINIT_LIST_HEAD(&subsys->nsheads);\n\tnvme_init_subnqn(subsys, ctrl, id);\n\tmemcpy(subsys->serial, id->sn, sizeof(subsys->serial));\n\tmemcpy(subsys->model, id->mn, sizeof(subsys->model));\n\tsubsys->vendor_id = le16_to_cpu(id->vid);\n\tsubsys->cmic = id->cmic;\n\n\t \n\tif (id->cntrltype == NVME_CTRL_DISC ||\n\t    !strcmp(subsys->subnqn, NVME_DISC_SUBSYS_NAME))\n\t\tsubsys->subtype = NVME_NQN_DISC;\n\telse\n\t\tsubsys->subtype = NVME_NQN_NVME;\n\n\tif (nvme_discovery_ctrl(ctrl) && subsys->subtype != NVME_NQN_DISC) {\n\t\tdev_err(ctrl->device,\n\t\t\t\"Subsystem %s is not a discovery controller\",\n\t\t\tsubsys->subnqn);\n\t\tkfree(subsys);\n\t\treturn -EINVAL;\n\t}\n\tsubsys->awupf = le16_to_cpu(id->awupf);\n\tnvme_mpath_default_iopolicy(subsys);\n\n\tsubsys->dev.class = nvme_subsys_class;\n\tsubsys->dev.release = nvme_release_subsystem;\n\tsubsys->dev.groups = nvme_subsys_attrs_groups;\n\tdev_set_name(&subsys->dev, \"nvme-subsys%d\", ctrl->instance);\n\tdevice_initialize(&subsys->dev);\n\n\tmutex_lock(&nvme_subsystems_lock);\n\tfound = __nvme_find_get_subsystem(subsys->subnqn);\n\tif (found) {\n\t\tput_device(&subsys->dev);\n\t\tsubsys = found;\n\n\t\tif (!nvme_validate_cntlid(subsys, ctrl, id)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_put_subsystem;\n\t\t}\n\t} else {\n\t\tret = device_add(&subsys->dev);\n\t\tif (ret) {\n\t\t\tdev_err(ctrl->device,\n\t\t\t\t\"failed to register subsystem device.\\n\");\n\t\t\tput_device(&subsys->dev);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tida_init(&subsys->ns_ida);\n\t\tlist_add_tail(&subsys->entry, &nvme_subsystems);\n\t}\n\n\tret = sysfs_create_link(&subsys->dev.kobj, &ctrl->device->kobj,\n\t\t\t\tdev_name(ctrl->device));\n\tif (ret) {\n\t\tdev_err(ctrl->device,\n\t\t\t\"failed to create sysfs link from subsystem.\\n\");\n\t\tgoto out_put_subsystem;\n\t}\n\n\tif (!found)\n\t\tsubsys->instance = ctrl->instance;\n\tctrl->subsys = subsys;\n\tlist_add_tail(&ctrl->subsys_entry, &subsys->ctrls);\n\tmutex_unlock(&nvme_subsystems_lock);\n\treturn 0;\n\nout_put_subsystem:\n\tnvme_put_subsystem(subsys);\nout_unlock:\n\tmutex_unlock(&nvme_subsystems_lock);\n\treturn ret;\n}\n\nint nvme_get_log(struct nvme_ctrl *ctrl, u32 nsid, u8 log_page, u8 lsp, u8 csi,\n\t\tvoid *log, size_t size, u64 offset)\n{\n\tstruct nvme_command c = { };\n\tu32 dwlen = nvme_bytes_to_numd(size);\n\n\tc.get_log_page.opcode = nvme_admin_get_log_page;\n\tc.get_log_page.nsid = cpu_to_le32(nsid);\n\tc.get_log_page.lid = log_page;\n\tc.get_log_page.lsp = lsp;\n\tc.get_log_page.numdl = cpu_to_le16(dwlen & ((1 << 16) - 1));\n\tc.get_log_page.numdu = cpu_to_le16(dwlen >> 16);\n\tc.get_log_page.lpol = cpu_to_le32(lower_32_bits(offset));\n\tc.get_log_page.lpou = cpu_to_le32(upper_32_bits(offset));\n\tc.get_log_page.csi = csi;\n\n\treturn nvme_submit_sync_cmd(ctrl->admin_q, &c, log, size);\n}\n\nstatic int nvme_get_effects_log(struct nvme_ctrl *ctrl, u8 csi,\n\t\t\t\tstruct nvme_effects_log **log)\n{\n\tstruct nvme_effects_log\t*cel = xa_load(&ctrl->cels, csi);\n\tint ret;\n\n\tif (cel)\n\t\tgoto out;\n\n\tcel = kzalloc(sizeof(*cel), GFP_KERNEL);\n\tif (!cel)\n\t\treturn -ENOMEM;\n\n\tret = nvme_get_log(ctrl, 0x00, NVME_LOG_CMD_EFFECTS, 0, csi,\n\t\t\tcel, sizeof(*cel), 0);\n\tif (ret) {\n\t\tkfree(cel);\n\t\treturn ret;\n\t}\n\n\txa_store(&ctrl->cels, csi, cel, GFP_KERNEL);\nout:\n\t*log = cel;\n\treturn 0;\n}\n\nstatic inline u32 nvme_mps_to_sectors(struct nvme_ctrl *ctrl, u32 units)\n{\n\tu32 page_shift = NVME_CAP_MPSMIN(ctrl->cap) + 12, val;\n\n\tif (check_shl_overflow(1U, units + page_shift - 9, &val))\n\t\treturn UINT_MAX;\n\treturn val;\n}\n\nstatic int nvme_init_non_mdts_limits(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_command c = { };\n\tstruct nvme_id_ctrl_nvm *id;\n\tint ret;\n\n\tif (ctrl->oncs & NVME_CTRL_ONCS_DSM) {\n\t\tctrl->max_discard_sectors = UINT_MAX;\n\t\tctrl->max_discard_segments = NVME_DSM_MAX_RANGES;\n\t} else {\n\t\tctrl->max_discard_sectors = 0;\n\t\tctrl->max_discard_segments = 0;\n\t}\n\n\t \n\tif ((ctrl->oncs & NVME_CTRL_ONCS_WRITE_ZEROES) &&\n\t    !(ctrl->quirks & NVME_QUIRK_DISABLE_WRITE_ZEROES))\n\t\tctrl->max_zeroes_sectors = ctrl->max_hw_sectors;\n\telse\n\t\tctrl->max_zeroes_sectors = 0;\n\n\tif (ctrl->subsys->subtype != NVME_NQN_NVME ||\n\t    nvme_ctrl_limited_cns(ctrl) ||\n\t    test_bit(NVME_CTRL_SKIP_ID_CNS_CS, &ctrl->flags))\n\t\treturn 0;\n\n\tid = kzalloc(sizeof(*id), GFP_KERNEL);\n\tif (!id)\n\t\treturn -ENOMEM;\n\n\tc.identify.opcode = nvme_admin_identify;\n\tc.identify.cns = NVME_ID_CNS_CS_CTRL;\n\tc.identify.csi = NVME_CSI_NVM;\n\n\tret = nvme_submit_sync_cmd(ctrl->admin_q, &c, id, sizeof(*id));\n\tif (ret)\n\t\tgoto free_data;\n\n\tif (id->dmrl)\n\t\tctrl->max_discard_segments = id->dmrl;\n\tctrl->dmrsl = le32_to_cpu(id->dmrsl);\n\tif (id->wzsl)\n\t\tctrl->max_zeroes_sectors = nvme_mps_to_sectors(ctrl, id->wzsl);\n\nfree_data:\n\tif (ret > 0)\n\t\tset_bit(NVME_CTRL_SKIP_ID_CNS_CS, &ctrl->flags);\n\tkfree(id);\n\treturn ret;\n}\n\nstatic void nvme_init_known_nvm_effects(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_effects_log\t*log = ctrl->effects;\n\n\tlog->acs[nvme_admin_format_nvm] |= cpu_to_le32(NVME_CMD_EFFECTS_LBCC |\n\t\t\t\t\t\tNVME_CMD_EFFECTS_NCC |\n\t\t\t\t\t\tNVME_CMD_EFFECTS_CSE_MASK);\n\tlog->acs[nvme_admin_sanitize_nvm] |= cpu_to_le32(NVME_CMD_EFFECTS_LBCC |\n\t\t\t\t\t\tNVME_CMD_EFFECTS_CSE_MASK);\n\n\t \n\tlog->acs[nvme_admin_security_recv] &= cpu_to_le32(~NVME_CMD_EFFECTS_CSE_MASK);\n\n\tlog->iocs[nvme_cmd_write] |= cpu_to_le32(NVME_CMD_EFFECTS_LBCC);\n\tlog->iocs[nvme_cmd_write_zeroes] |= cpu_to_le32(NVME_CMD_EFFECTS_LBCC);\n\tlog->iocs[nvme_cmd_write_uncor] |= cpu_to_le32(NVME_CMD_EFFECTS_LBCC);\n}\n\nstatic int nvme_init_effects(struct nvme_ctrl *ctrl, struct nvme_id_ctrl *id)\n{\n\tint ret = 0;\n\n\tif (ctrl->effects)\n\t\treturn 0;\n\n\tif (id->lpa & NVME_CTRL_LPA_CMD_EFFECTS_LOG) {\n\t\tret = nvme_get_effects_log(ctrl, NVME_CSI_NVM, &ctrl->effects);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (!ctrl->effects) {\n\t\tctrl->effects = kzalloc(sizeof(*ctrl->effects), GFP_KERNEL);\n\t\tif (!ctrl->effects)\n\t\t\treturn -ENOMEM;\n\t\txa_store(&ctrl->cels, NVME_CSI_NVM, ctrl->effects, GFP_KERNEL);\n\t}\n\n\tnvme_init_known_nvm_effects(ctrl);\n\treturn 0;\n}\n\nstatic int nvme_init_identify(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_id_ctrl *id;\n\tu32 max_hw_sectors;\n\tbool prev_apst_enabled;\n\tint ret;\n\n\tret = nvme_identify_ctrl(ctrl, &id);\n\tif (ret) {\n\t\tdev_err(ctrl->device, \"Identify Controller failed (%d)\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\tif (!(ctrl->ops->flags & NVME_F_FABRICS))\n\t\tctrl->cntlid = le16_to_cpu(id->cntlid);\n\n\tif (!ctrl->identified) {\n\t\tunsigned int i;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(core_quirks); i++) {\n\t\t\tif (quirk_matches(id, &core_quirks[i]))\n\t\t\t\tctrl->quirks |= core_quirks[i].quirks;\n\t\t}\n\n\t\tret = nvme_init_subsystem(ctrl, id);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\n\t\tret = nvme_init_effects(ctrl, id);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\tmemcpy(ctrl->subsys->firmware_rev, id->fr,\n\t       sizeof(ctrl->subsys->firmware_rev));\n\n\tif (force_apst && (ctrl->quirks & NVME_QUIRK_NO_DEEPEST_PS)) {\n\t\tdev_warn(ctrl->device, \"forcibly allowing all power states due to nvme_core.force_apst -- use at your own risk\\n\");\n\t\tctrl->quirks &= ~NVME_QUIRK_NO_DEEPEST_PS;\n\t}\n\n\tctrl->crdt[0] = le16_to_cpu(id->crdt1);\n\tctrl->crdt[1] = le16_to_cpu(id->crdt2);\n\tctrl->crdt[2] = le16_to_cpu(id->crdt3);\n\n\tctrl->oacs = le16_to_cpu(id->oacs);\n\tctrl->oncs = le16_to_cpu(id->oncs);\n\tctrl->mtfa = le16_to_cpu(id->mtfa);\n\tctrl->oaes = le32_to_cpu(id->oaes);\n\tctrl->wctemp = le16_to_cpu(id->wctemp);\n\tctrl->cctemp = le16_to_cpu(id->cctemp);\n\n\tatomic_set(&ctrl->abort_limit, id->acl + 1);\n\tctrl->vwc = id->vwc;\n\tif (id->mdts)\n\t\tmax_hw_sectors = nvme_mps_to_sectors(ctrl, id->mdts);\n\telse\n\t\tmax_hw_sectors = UINT_MAX;\n\tctrl->max_hw_sectors =\n\t\tmin_not_zero(ctrl->max_hw_sectors, max_hw_sectors);\n\n\tnvme_set_queue_limits(ctrl, ctrl->admin_q);\n\tctrl->sgls = le32_to_cpu(id->sgls);\n\tctrl->kas = le16_to_cpu(id->kas);\n\tctrl->max_namespaces = le32_to_cpu(id->mnan);\n\tctrl->ctratt = le32_to_cpu(id->ctratt);\n\n\tctrl->cntrltype = id->cntrltype;\n\tctrl->dctype = id->dctype;\n\n\tif (id->rtd3e) {\n\t\t \n\t\tu32 transition_time = le32_to_cpu(id->rtd3e) / USEC_PER_SEC;\n\n\t\tctrl->shutdown_timeout = clamp_t(unsigned int, transition_time,\n\t\t\t\t\t\t shutdown_timeout, 60);\n\n\t\tif (ctrl->shutdown_timeout != shutdown_timeout)\n\t\t\tdev_info(ctrl->device,\n\t\t\t\t \"Shutdown timeout set to %u seconds\\n\",\n\t\t\t\t ctrl->shutdown_timeout);\n\t} else\n\t\tctrl->shutdown_timeout = shutdown_timeout;\n\n\tctrl->npss = id->npss;\n\tctrl->apsta = id->apsta;\n\tprev_apst_enabled = ctrl->apst_enabled;\n\tif (ctrl->quirks & NVME_QUIRK_NO_APST) {\n\t\tif (force_apst && id->apsta) {\n\t\t\tdev_warn(ctrl->device, \"forcibly allowing APST due to nvme_core.force_apst -- use at your own risk\\n\");\n\t\t\tctrl->apst_enabled = true;\n\t\t} else {\n\t\t\tctrl->apst_enabled = false;\n\t\t}\n\t} else {\n\t\tctrl->apst_enabled = id->apsta;\n\t}\n\tmemcpy(ctrl->psd, id->psd, sizeof(ctrl->psd));\n\n\tif (ctrl->ops->flags & NVME_F_FABRICS) {\n\t\tctrl->icdoff = le16_to_cpu(id->icdoff);\n\t\tctrl->ioccsz = le32_to_cpu(id->ioccsz);\n\t\tctrl->iorcsz = le32_to_cpu(id->iorcsz);\n\t\tctrl->maxcmd = le16_to_cpu(id->maxcmd);\n\n\t\t \n\t\tif (ctrl->cntlid != le16_to_cpu(id->cntlid)) {\n\t\t\tdev_err(ctrl->device,\n\t\t\t\t\"Mismatching cntlid: Connect %u vs Identify \"\n\t\t\t\t\"%u, rejecting\\n\",\n\t\t\t\tctrl->cntlid, le16_to_cpu(id->cntlid));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (!nvme_discovery_ctrl(ctrl) && !ctrl->kas) {\n\t\t\tdev_err(ctrl->device,\n\t\t\t\t\"keep-alive support is mandatory for fabrics\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t} else {\n\t\tctrl->hmpre = le32_to_cpu(id->hmpre);\n\t\tctrl->hmmin = le32_to_cpu(id->hmmin);\n\t\tctrl->hmminds = le32_to_cpu(id->hmminds);\n\t\tctrl->hmmaxd = le16_to_cpu(id->hmmaxd);\n\t}\n\n\tret = nvme_mpath_init_identify(ctrl, id);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tif (ctrl->apst_enabled && !prev_apst_enabled)\n\t\tdev_pm_qos_expose_latency_tolerance(ctrl->device);\n\telse if (!ctrl->apst_enabled && prev_apst_enabled)\n\t\tdev_pm_qos_hide_latency_tolerance(ctrl->device);\n\nout_free:\n\tkfree(id);\n\treturn ret;\n}\n\n \nint nvme_init_ctrl_finish(struct nvme_ctrl *ctrl, bool was_suspended)\n{\n\tint ret;\n\n\tret = ctrl->ops->reg_read32(ctrl, NVME_REG_VS, &ctrl->vs);\n\tif (ret) {\n\t\tdev_err(ctrl->device, \"Reading VS failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tctrl->sqsize = min_t(u16, NVME_CAP_MQES(ctrl->cap), ctrl->sqsize);\n\n\tif (ctrl->vs >= NVME_VS(1, 1, 0))\n\t\tctrl->subsystem = NVME_CAP_NSSRC(ctrl->cap);\n\n\tret = nvme_init_identify(ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvme_configure_apst(ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nvme_configure_timestamp(ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nvme_configure_host_options(ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnvme_configure_opal(ctrl, was_suspended);\n\n\tif (!ctrl->identified && !nvme_discovery_ctrl(ctrl)) {\n\t\t \n\t\tret = nvme_hwmon_init(ctrl);\n\t\tif (ret == -EINTR)\n\t\t\treturn ret;\n\t}\n\n\tclear_bit(NVME_CTRL_DIRTY_CAPABILITY, &ctrl->flags);\n\tctrl->identified = true;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nvme_init_ctrl_finish);\n\nstatic int nvme_dev_open(struct inode *inode, struct file *file)\n{\n\tstruct nvme_ctrl *ctrl =\n\t\tcontainer_of(inode->i_cdev, struct nvme_ctrl, cdev);\n\n\tswitch (nvme_ctrl_state(ctrl)) {\n\tcase NVME_CTRL_LIVE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EWOULDBLOCK;\n\t}\n\n\tnvme_get_ctrl(ctrl);\n\tif (!try_module_get(ctrl->ops->module)) {\n\t\tnvme_put_ctrl(ctrl);\n\t\treturn -EINVAL;\n\t}\n\n\tfile->private_data = ctrl;\n\treturn 0;\n}\n\nstatic int nvme_dev_release(struct inode *inode, struct file *file)\n{\n\tstruct nvme_ctrl *ctrl =\n\t\tcontainer_of(inode->i_cdev, struct nvme_ctrl, cdev);\n\n\tmodule_put(ctrl->ops->module);\n\tnvme_put_ctrl(ctrl);\n\treturn 0;\n}\n\nstatic const struct file_operations nvme_dev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= nvme_dev_open,\n\t.release\t= nvme_dev_release,\n\t.unlocked_ioctl\t= nvme_dev_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.uring_cmd\t= nvme_dev_uring_cmd,\n};\n\nstatic struct nvme_ns_head *nvme_find_ns_head(struct nvme_ctrl *ctrl,\n\t\tunsigned nsid)\n{\n\tstruct nvme_ns_head *h;\n\n\tlockdep_assert_held(&ctrl->subsys->lock);\n\n\tlist_for_each_entry(h, &ctrl->subsys->nsheads, entry) {\n\t\t \n\t\tif (h->ns_id != nsid || !nvme_is_unique_nsid(ctrl, h))\n\t\t\tcontinue;\n\t\tif (!list_empty(&h->list) && nvme_tryget_ns_head(h))\n\t\t\treturn h;\n\t}\n\n\treturn NULL;\n}\n\nstatic int nvme_subsys_check_duplicate_ids(struct nvme_subsystem *subsys,\n\t\tstruct nvme_ns_ids *ids)\n{\n\tbool has_uuid = !uuid_is_null(&ids->uuid);\n\tbool has_nguid = memchr_inv(ids->nguid, 0, sizeof(ids->nguid));\n\tbool has_eui64 = memchr_inv(ids->eui64, 0, sizeof(ids->eui64));\n\tstruct nvme_ns_head *h;\n\n\tlockdep_assert_held(&subsys->lock);\n\n\tlist_for_each_entry(h, &subsys->nsheads, entry) {\n\t\tif (has_uuid && uuid_equal(&ids->uuid, &h->ids.uuid))\n\t\t\treturn -EINVAL;\n\t\tif (has_nguid &&\n\t\t    memcmp(&ids->nguid, &h->ids.nguid, sizeof(ids->nguid)) == 0)\n\t\t\treturn -EINVAL;\n\t\tif (has_eui64 &&\n\t\t    memcmp(&ids->eui64, &h->ids.eui64, sizeof(ids->eui64)) == 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void nvme_cdev_rel(struct device *dev)\n{\n\tida_free(&nvme_ns_chr_minor_ida, MINOR(dev->devt));\n}\n\nvoid nvme_cdev_del(struct cdev *cdev, struct device *cdev_device)\n{\n\tcdev_device_del(cdev, cdev_device);\n\tput_device(cdev_device);\n}\n\nint nvme_cdev_add(struct cdev *cdev, struct device *cdev_device,\n\t\tconst struct file_operations *fops, struct module *owner)\n{\n\tint minor, ret;\n\n\tminor = ida_alloc(&nvme_ns_chr_minor_ida, GFP_KERNEL);\n\tif (minor < 0)\n\t\treturn minor;\n\tcdev_device->devt = MKDEV(MAJOR(nvme_ns_chr_devt), minor);\n\tcdev_device->class = nvme_ns_chr_class;\n\tcdev_device->release = nvme_cdev_rel;\n\tdevice_initialize(cdev_device);\n\tcdev_init(cdev, fops);\n\tcdev->owner = owner;\n\tret = cdev_device_add(cdev, cdev_device);\n\tif (ret)\n\t\tput_device(cdev_device);\n\n\treturn ret;\n}\n\nstatic int nvme_ns_chr_open(struct inode *inode, struct file *file)\n{\n\treturn nvme_ns_open(container_of(inode->i_cdev, struct nvme_ns, cdev));\n}\n\nstatic int nvme_ns_chr_release(struct inode *inode, struct file *file)\n{\n\tnvme_ns_release(container_of(inode->i_cdev, struct nvme_ns, cdev));\n\treturn 0;\n}\n\nstatic const struct file_operations nvme_ns_chr_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= nvme_ns_chr_open,\n\t.release\t= nvme_ns_chr_release,\n\t.unlocked_ioctl\t= nvme_ns_chr_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.uring_cmd\t= nvme_ns_chr_uring_cmd,\n\t.uring_cmd_iopoll = nvme_ns_chr_uring_cmd_iopoll,\n};\n\nstatic int nvme_add_ns_cdev(struct nvme_ns *ns)\n{\n\tint ret;\n\n\tns->cdev_device.parent = ns->ctrl->device;\n\tret = dev_set_name(&ns->cdev_device, \"ng%dn%d\",\n\t\t\t   ns->ctrl->instance, ns->head->instance);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nvme_cdev_add(&ns->cdev, &ns->cdev_device, &nvme_ns_chr_fops,\n\t\t\t     ns->ctrl->ops->module);\n}\n\nstatic struct nvme_ns_head *nvme_alloc_ns_head(struct nvme_ctrl *ctrl,\n\t\tstruct nvme_ns_info *info)\n{\n\tstruct nvme_ns_head *head;\n\tsize_t size = sizeof(*head);\n\tint ret = -ENOMEM;\n\n#ifdef CONFIG_NVME_MULTIPATH\n\tsize += num_possible_nodes() * sizeof(struct nvme_ns *);\n#endif\n\n\thead = kzalloc(size, GFP_KERNEL);\n\tif (!head)\n\t\tgoto out;\n\tret = ida_alloc_min(&ctrl->subsys->ns_ida, 1, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto out_free_head;\n\thead->instance = ret;\n\tINIT_LIST_HEAD(&head->list);\n\tret = init_srcu_struct(&head->srcu);\n\tif (ret)\n\t\tgoto out_ida_remove;\n\thead->subsys = ctrl->subsys;\n\thead->ns_id = info->nsid;\n\thead->ids = info->ids;\n\thead->shared = info->is_shared;\n\tkref_init(&head->ref);\n\n\tif (head->ids.csi) {\n\t\tret = nvme_get_effects_log(ctrl, head->ids.csi, &head->effects);\n\t\tif (ret)\n\t\t\tgoto out_cleanup_srcu;\n\t} else\n\t\thead->effects = ctrl->effects;\n\n\tret = nvme_mpath_alloc_disk(ctrl, head);\n\tif (ret)\n\t\tgoto out_cleanup_srcu;\n\n\tlist_add_tail(&head->entry, &ctrl->subsys->nsheads);\n\n\tkref_get(&ctrl->subsys->ref);\n\n\treturn head;\nout_cleanup_srcu:\n\tcleanup_srcu_struct(&head->srcu);\nout_ida_remove:\n\tida_free(&ctrl->subsys->ns_ida, head->instance);\nout_free_head:\n\tkfree(head);\nout:\n\tif (ret > 0)\n\t\tret = blk_status_to_errno(nvme_error_status(ret));\n\treturn ERR_PTR(ret);\n}\n\nstatic int nvme_global_check_duplicate_ids(struct nvme_subsystem *this,\n\t\tstruct nvme_ns_ids *ids)\n{\n\tstruct nvme_subsystem *s;\n\tint ret = 0;\n\n\t \n\tmutex_lock(&nvme_subsystems_lock);\n\tlist_for_each_entry(s, &nvme_subsystems, entry) {\n\t\tif (s == this)\n\t\t\tcontinue;\n\t\tmutex_lock(&s->lock);\n\t\tret = nvme_subsys_check_duplicate_ids(s, ids);\n\t\tmutex_unlock(&s->lock);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&nvme_subsystems_lock);\n\n\treturn ret;\n}\n\nstatic int nvme_init_ns_head(struct nvme_ns *ns, struct nvme_ns_info *info)\n{\n\tstruct nvme_ctrl *ctrl = ns->ctrl;\n\tstruct nvme_ns_head *head = NULL;\n\tint ret;\n\n\tret = nvme_global_check_duplicate_ids(ctrl->subsys, &info->ids);\n\tif (ret) {\n\t\t \n\t\tnvme_print_device_info(ctrl);\n\t\tif ((ns->ctrl->ops->flags & NVME_F_FABRICS) ||  \n\t\t    ((ns->ctrl->subsys->cmic & NVME_CTRL_CMIC_MULTI_CTRL) &&\n\t\t     info->is_shared)) {\n\t\t\tdev_err(ctrl->device,\n\t\t\t\t\"ignoring nsid %d because of duplicate IDs\\n\",\n\t\t\t\tinfo->nsid);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_err(ctrl->device,\n\t\t\t\"clearing duplicate IDs for nsid %d\\n\", info->nsid);\n\t\tdev_err(ctrl->device,\n\t\t\t\"use of /dev/disk/by-id/ may cause data corruption\\n\");\n\t\tmemset(&info->ids.nguid, 0, sizeof(info->ids.nguid));\n\t\tmemset(&info->ids.uuid, 0, sizeof(info->ids.uuid));\n\t\tmemset(&info->ids.eui64, 0, sizeof(info->ids.eui64));\n\t\tctrl->quirks |= NVME_QUIRK_BOGUS_NID;\n\t}\n\n\tmutex_lock(&ctrl->subsys->lock);\n\thead = nvme_find_ns_head(ctrl, info->nsid);\n\tif (!head) {\n\t\tret = nvme_subsys_check_duplicate_ids(ctrl->subsys, &info->ids);\n\t\tif (ret) {\n\t\t\tdev_err(ctrl->device,\n\t\t\t\t\"duplicate IDs in subsystem for nsid %d\\n\",\n\t\t\t\tinfo->nsid);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\thead = nvme_alloc_ns_head(ctrl, info);\n\t\tif (IS_ERR(head)) {\n\t\t\tret = PTR_ERR(head);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t\tif (!info->is_shared || !head->shared) {\n\t\t\tdev_err(ctrl->device,\n\t\t\t\t\"Duplicate unshared namespace %d\\n\",\n\t\t\t\tinfo->nsid);\n\t\t\tgoto out_put_ns_head;\n\t\t}\n\t\tif (!nvme_ns_ids_equal(&head->ids, &info->ids)) {\n\t\t\tdev_err(ctrl->device,\n\t\t\t\t\"IDs don't match for shared namespace %d\\n\",\n\t\t\t\t\tinfo->nsid);\n\t\t\tgoto out_put_ns_head;\n\t\t}\n\n\t\tif (!multipath) {\n\t\t\tdev_warn(ctrl->device,\n\t\t\t\t\"Found shared namespace %d, but multipathing not supported.\\n\",\n\t\t\t\tinfo->nsid);\n\t\t\tdev_warn_once(ctrl->device,\n\t\t\t\t\"Support for shared namespaces without CONFIG_NVME_MULTIPATH is deprecated and will be removed in Linux 6.0\\n.\");\n\t\t}\n\t}\n\n\tlist_add_tail_rcu(&ns->siblings, &head->list);\n\tns->head = head;\n\tmutex_unlock(&ctrl->subsys->lock);\n\treturn 0;\n\nout_put_ns_head:\n\tnvme_put_ns_head(head);\nout_unlock:\n\tmutex_unlock(&ctrl->subsys->lock);\n\treturn ret;\n}\n\nstruct nvme_ns *nvme_find_get_ns(struct nvme_ctrl *ctrl, unsigned nsid)\n{\n\tstruct nvme_ns *ns, *ret = NULL;\n\n\tdown_read(&ctrl->namespaces_rwsem);\n\tlist_for_each_entry(ns, &ctrl->namespaces, list) {\n\t\tif (ns->head->ns_id == nsid) {\n\t\t\tif (!nvme_get_ns(ns))\n\t\t\t\tcontinue;\n\t\t\tret = ns;\n\t\t\tbreak;\n\t\t}\n\t\tif (ns->head->ns_id > nsid)\n\t\t\tbreak;\n\t}\n\tup_read(&ctrl->namespaces_rwsem);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(nvme_find_get_ns, NVME_TARGET_PASSTHRU);\n\n \nstatic void nvme_ns_add_to_ctrl_list(struct nvme_ns *ns)\n{\n\tstruct nvme_ns *tmp;\n\n\tlist_for_each_entry_reverse(tmp, &ns->ctrl->namespaces, list) {\n\t\tif (tmp->head->ns_id < ns->head->ns_id) {\n\t\t\tlist_add(&ns->list, &tmp->list);\n\t\t\treturn;\n\t\t}\n\t}\n\tlist_add(&ns->list, &ns->ctrl->namespaces);\n}\n\nstatic void nvme_alloc_ns(struct nvme_ctrl *ctrl, struct nvme_ns_info *info)\n{\n\tstruct nvme_ns *ns;\n\tstruct gendisk *disk;\n\tint node = ctrl->numa_node;\n\n\tns = kzalloc_node(sizeof(*ns), GFP_KERNEL, node);\n\tif (!ns)\n\t\treturn;\n\n\tdisk = blk_mq_alloc_disk(ctrl->tagset, ns);\n\tif (IS_ERR(disk))\n\t\tgoto out_free_ns;\n\tdisk->fops = &nvme_bdev_ops;\n\tdisk->private_data = ns;\n\n\tns->disk = disk;\n\tns->queue = disk->queue;\n\n\tif (ctrl->opts && ctrl->opts->data_digest)\n\t\tblk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES, ns->queue);\n\n\tblk_queue_flag_set(QUEUE_FLAG_NONROT, ns->queue);\n\tif (ctrl->ops->supports_pci_p2pdma &&\n\t    ctrl->ops->supports_pci_p2pdma(ctrl))\n\t\tblk_queue_flag_set(QUEUE_FLAG_PCI_P2PDMA, ns->queue);\n\n\tns->ctrl = ctrl;\n\tkref_init(&ns->kref);\n\n\tif (nvme_init_ns_head(ns, info))\n\t\tgoto out_cleanup_disk;\n\n\t \n\tif (nvme_ns_head_multipath(ns->head)) {\n\t\tsprintf(disk->disk_name, \"nvme%dc%dn%d\", ctrl->subsys->instance,\n\t\t\tctrl->instance, ns->head->instance);\n\t\tdisk->flags |= GENHD_FL_HIDDEN;\n\t} else if (multipath) {\n\t\tsprintf(disk->disk_name, \"nvme%dn%d\", ctrl->subsys->instance,\n\t\t\tns->head->instance);\n\t} else {\n\t\tsprintf(disk->disk_name, \"nvme%dn%d\", ctrl->instance,\n\t\t\tns->head->instance);\n\t}\n\n\tif (nvme_update_ns_info(ns, info))\n\t\tgoto out_unlink_ns;\n\n\tdown_write(&ctrl->namespaces_rwsem);\n\t \n\tif (test_bit(NVME_CTRL_FROZEN, &ctrl->flags)) {\n\t\tup_write(&ctrl->namespaces_rwsem);\n\t\tgoto out_unlink_ns;\n\t}\n\tnvme_ns_add_to_ctrl_list(ns);\n\tup_write(&ctrl->namespaces_rwsem);\n\tnvme_get_ctrl(ctrl);\n\n\tif (device_add_disk(ctrl->device, ns->disk, nvme_ns_id_attr_groups))\n\t\tgoto out_cleanup_ns_from_list;\n\n\tif (!nvme_ns_head_multipath(ns->head))\n\t\tnvme_add_ns_cdev(ns);\n\n\tnvme_mpath_add_disk(ns, info->anagrpid);\n\tnvme_fault_inject_init(&ns->fault_inject, ns->disk->disk_name);\n\n\treturn;\n\n out_cleanup_ns_from_list:\n\tnvme_put_ctrl(ctrl);\n\tdown_write(&ctrl->namespaces_rwsem);\n\tlist_del_init(&ns->list);\n\tup_write(&ctrl->namespaces_rwsem);\n out_unlink_ns:\n\tmutex_lock(&ctrl->subsys->lock);\n\tlist_del_rcu(&ns->siblings);\n\tif (list_empty(&ns->head->list))\n\t\tlist_del_init(&ns->head->entry);\n\tmutex_unlock(&ctrl->subsys->lock);\n\tnvme_put_ns_head(ns->head);\n out_cleanup_disk:\n\tput_disk(disk);\n out_free_ns:\n\tkfree(ns);\n}\n\nstatic void nvme_ns_remove(struct nvme_ns *ns)\n{\n\tbool last_path = false;\n\n\tif (test_and_set_bit(NVME_NS_REMOVING, &ns->flags))\n\t\treturn;\n\n\tclear_bit(NVME_NS_READY, &ns->flags);\n\tset_capacity(ns->disk, 0);\n\tnvme_fault_inject_fini(&ns->fault_inject);\n\n\t \n\tsynchronize_srcu(&ns->head->srcu);\n\n\t \n\tif (nvme_mpath_clear_current_path(ns))\n\t\tsynchronize_srcu(&ns->head->srcu);\n\n\tmutex_lock(&ns->ctrl->subsys->lock);\n\tlist_del_rcu(&ns->siblings);\n\tif (list_empty(&ns->head->list)) {\n\t\tlist_del_init(&ns->head->entry);\n\t\tlast_path = true;\n\t}\n\tmutex_unlock(&ns->ctrl->subsys->lock);\n\n\t \n\tsynchronize_srcu(&ns->head->srcu);\n\n\tif (!nvme_ns_head_multipath(ns->head))\n\t\tnvme_cdev_del(&ns->cdev, &ns->cdev_device);\n\tdel_gendisk(ns->disk);\n\n\tdown_write(&ns->ctrl->namespaces_rwsem);\n\tlist_del_init(&ns->list);\n\tup_write(&ns->ctrl->namespaces_rwsem);\n\n\tif (last_path)\n\t\tnvme_mpath_shutdown_disk(ns->head);\n\tnvme_put_ns(ns);\n}\n\nstatic void nvme_ns_remove_by_nsid(struct nvme_ctrl *ctrl, u32 nsid)\n{\n\tstruct nvme_ns *ns = nvme_find_get_ns(ctrl, nsid);\n\n\tif (ns) {\n\t\tnvme_ns_remove(ns);\n\t\tnvme_put_ns(ns);\n\t}\n}\n\nstatic void nvme_validate_ns(struct nvme_ns *ns, struct nvme_ns_info *info)\n{\n\tint ret = NVME_SC_INVALID_NS | NVME_SC_DNR;\n\n\tif (!nvme_ns_ids_equal(&ns->head->ids, &info->ids)) {\n\t\tdev_err(ns->ctrl->device,\n\t\t\t\"identifiers changed for nsid %d\\n\", ns->head->ns_id);\n\t\tgoto out;\n\t}\n\n\tret = nvme_update_ns_info(ns, info);\nout:\n\t \n\tif (ret > 0 && (ret & NVME_SC_DNR))\n\t\tnvme_ns_remove(ns);\n}\n\nstatic void nvme_scan_ns(struct nvme_ctrl *ctrl, unsigned nsid)\n{\n\tstruct nvme_ns_info info = { .nsid = nsid };\n\tstruct nvme_ns *ns;\n\tint ret;\n\n\tif (nvme_identify_ns_descs(ctrl, &info))\n\t\treturn;\n\n\tif (info.ids.csi != NVME_CSI_NVM && !nvme_multi_css(ctrl)) {\n\t\tdev_warn(ctrl->device,\n\t\t\t\"command set not reported for nsid: %d\\n\", nsid);\n\t\treturn;\n\t}\n\n\t \n\tif ((ctrl->cap & NVME_CAP_CRMS_CRIMS) ||\n\t    (info.ids.csi != NVME_CSI_NVM && info.ids.csi != NVME_CSI_ZNS))\n\t\tret = nvme_ns_info_from_id_cs_indep(ctrl, &info);\n\telse\n\t\tret = nvme_ns_info_from_identify(ctrl, &info);\n\n\tif (info.is_removed)\n\t\tnvme_ns_remove_by_nsid(ctrl, nsid);\n\n\t \n\tif (ret || !info.is_ready)\n\t\treturn;\n\n\tns = nvme_find_get_ns(ctrl, nsid);\n\tif (ns) {\n\t\tnvme_validate_ns(ns, &info);\n\t\tnvme_put_ns(ns);\n\t} else {\n\t\tnvme_alloc_ns(ctrl, &info);\n\t}\n}\n\nstatic void nvme_remove_invalid_namespaces(struct nvme_ctrl *ctrl,\n\t\t\t\t\tunsigned nsid)\n{\n\tstruct nvme_ns *ns, *next;\n\tLIST_HEAD(rm_list);\n\n\tdown_write(&ctrl->namespaces_rwsem);\n\tlist_for_each_entry_safe(ns, next, &ctrl->namespaces, list) {\n\t\tif (ns->head->ns_id > nsid)\n\t\t\tlist_move_tail(&ns->list, &rm_list);\n\t}\n\tup_write(&ctrl->namespaces_rwsem);\n\n\tlist_for_each_entry_safe(ns, next, &rm_list, list)\n\t\tnvme_ns_remove(ns);\n\n}\n\nstatic int nvme_scan_ns_list(struct nvme_ctrl *ctrl)\n{\n\tconst int nr_entries = NVME_IDENTIFY_DATA_SIZE / sizeof(__le32);\n\t__le32 *ns_list;\n\tu32 prev = 0;\n\tint ret = 0, i;\n\n\tns_list = kzalloc(NVME_IDENTIFY_DATA_SIZE, GFP_KERNEL);\n\tif (!ns_list)\n\t\treturn -ENOMEM;\n\n\tfor (;;) {\n\t\tstruct nvme_command cmd = {\n\t\t\t.identify.opcode\t= nvme_admin_identify,\n\t\t\t.identify.cns\t\t= NVME_ID_CNS_NS_ACTIVE_LIST,\n\t\t\t.identify.nsid\t\t= cpu_to_le32(prev),\n\t\t};\n\n\t\tret = nvme_submit_sync_cmd(ctrl->admin_q, &cmd, ns_list,\n\t\t\t\t\t    NVME_IDENTIFY_DATA_SIZE);\n\t\tif (ret) {\n\t\t\tdev_warn(ctrl->device,\n\t\t\t\t\"Identify NS List failed (status=0x%x)\\n\", ret);\n\t\t\tgoto free;\n\t\t}\n\n\t\tfor (i = 0; i < nr_entries; i++) {\n\t\t\tu32 nsid = le32_to_cpu(ns_list[i]);\n\n\t\t\tif (!nsid)\t \n\t\t\t\tgoto out;\n\t\t\tnvme_scan_ns(ctrl, nsid);\n\t\t\twhile (++prev < nsid)\n\t\t\t\tnvme_ns_remove_by_nsid(ctrl, prev);\n\t\t}\n\t}\n out:\n\tnvme_remove_invalid_namespaces(ctrl, prev);\n free:\n\tkfree(ns_list);\n\treturn ret;\n}\n\nstatic void nvme_scan_ns_sequential(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_id_ctrl *id;\n\tu32 nn, i;\n\n\tif (nvme_identify_ctrl(ctrl, &id))\n\t\treturn;\n\tnn = le32_to_cpu(id->nn);\n\tkfree(id);\n\n\tfor (i = 1; i <= nn; i++)\n\t\tnvme_scan_ns(ctrl, i);\n\n\tnvme_remove_invalid_namespaces(ctrl, nn);\n}\n\nstatic void nvme_clear_changed_ns_log(struct nvme_ctrl *ctrl)\n{\n\tsize_t log_size = NVME_MAX_CHANGED_NAMESPACES * sizeof(__le32);\n\t__le32 *log;\n\tint error;\n\n\tlog = kzalloc(log_size, GFP_KERNEL);\n\tif (!log)\n\t\treturn;\n\n\t \n\terror = nvme_get_log(ctrl, NVME_NSID_ALL, NVME_LOG_CHANGED_NS, 0,\n\t\t\tNVME_CSI_NVM, log, log_size, 0);\n\tif (error)\n\t\tdev_warn(ctrl->device,\n\t\t\t\"reading changed ns log failed: %d\\n\", error);\n\n\tkfree(log);\n}\n\nstatic void nvme_scan_work(struct work_struct *work)\n{\n\tstruct nvme_ctrl *ctrl =\n\t\tcontainer_of(work, struct nvme_ctrl, scan_work);\n\tint ret;\n\n\t \n\tif (nvme_ctrl_state(ctrl) != NVME_CTRL_LIVE || !ctrl->tagset)\n\t\treturn;\n\n\t \n\tret = nvme_init_non_mdts_limits(ctrl);\n\tif (ret < 0) {\n\t\tdev_warn(ctrl->device,\n\t\t\t\"reading non-mdts-limits failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (test_and_clear_bit(NVME_AER_NOTICE_NS_CHANGED, &ctrl->events)) {\n\t\tdev_info(ctrl->device, \"rescanning namespaces.\\n\");\n\t\tnvme_clear_changed_ns_log(ctrl);\n\t}\n\n\tmutex_lock(&ctrl->scan_lock);\n\tif (nvme_ctrl_limited_cns(ctrl)) {\n\t\tnvme_scan_ns_sequential(ctrl);\n\t} else {\n\t\t \n\t\tret = nvme_scan_ns_list(ctrl);\n\t\tif (ret > 0 && ret & NVME_SC_DNR)\n\t\t\tnvme_scan_ns_sequential(ctrl);\n\t}\n\tmutex_unlock(&ctrl->scan_lock);\n}\n\n \nvoid nvme_remove_namespaces(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_ns *ns, *next;\n\tLIST_HEAD(ns_list);\n\n\t \n\tnvme_mpath_clear_ctrl_paths(ctrl);\n\n\t \n\tnvme_unquiesce_io_queues(ctrl);\n\n\t \n\tflush_work(&ctrl->scan_work);\n\n\t \n\tif (nvme_ctrl_state(ctrl) == NVME_CTRL_DEAD)\n\t\tnvme_mark_namespaces_dead(ctrl);\n\n\t \n\tnvme_change_ctrl_state(ctrl, NVME_CTRL_DELETING_NOIO);\n\n\tdown_write(&ctrl->namespaces_rwsem);\n\tlist_splice_init(&ctrl->namespaces, &ns_list);\n\tup_write(&ctrl->namespaces_rwsem);\n\n\tlist_for_each_entry_safe(ns, next, &ns_list, list)\n\t\tnvme_ns_remove(ns);\n}\nEXPORT_SYMBOL_GPL(nvme_remove_namespaces);\n\nstatic int nvme_class_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct nvme_ctrl *ctrl =\n\t\tcontainer_of(dev, struct nvme_ctrl, ctrl_device);\n\tstruct nvmf_ctrl_options *opts = ctrl->opts;\n\tint ret;\n\n\tret = add_uevent_var(env, \"NVME_TRTYPE=%s\", ctrl->ops->name);\n\tif (ret)\n\t\treturn ret;\n\n\tif (opts) {\n\t\tret = add_uevent_var(env, \"NVME_TRADDR=%s\", opts->traddr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = add_uevent_var(env, \"NVME_TRSVCID=%s\",\n\t\t\t\topts->trsvcid ?: \"none\");\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = add_uevent_var(env, \"NVME_HOST_TRADDR=%s\",\n\t\t\t\topts->host_traddr ?: \"none\");\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = add_uevent_var(env, \"NVME_HOST_IFACE=%s\",\n\t\t\t\topts->host_iface ?: \"none\");\n\t}\n\treturn ret;\n}\n\nstatic void nvme_change_uevent(struct nvme_ctrl *ctrl, char *envdata)\n{\n\tchar *envp[2] = { envdata, NULL };\n\n\tkobject_uevent_env(&ctrl->device->kobj, KOBJ_CHANGE, envp);\n}\n\nstatic void nvme_aen_uevent(struct nvme_ctrl *ctrl)\n{\n\tchar *envp[2] = { NULL, NULL };\n\tu32 aen_result = ctrl->aen_result;\n\n\tctrl->aen_result = 0;\n\tif (!aen_result)\n\t\treturn;\n\n\tenvp[0] = kasprintf(GFP_KERNEL, \"NVME_AEN=%#08x\", aen_result);\n\tif (!envp[0])\n\t\treturn;\n\tkobject_uevent_env(&ctrl->device->kobj, KOBJ_CHANGE, envp);\n\tkfree(envp[0]);\n}\n\nstatic void nvme_async_event_work(struct work_struct *work)\n{\n\tstruct nvme_ctrl *ctrl =\n\t\tcontainer_of(work, struct nvme_ctrl, async_event_work);\n\n\tnvme_aen_uevent(ctrl);\n\n\t \n\tif (nvme_ctrl_state(ctrl) == NVME_CTRL_LIVE)\n\t\tctrl->ops->submit_async_event(ctrl);\n}\n\nstatic bool nvme_ctrl_pp_status(struct nvme_ctrl *ctrl)\n{\n\n\tu32 csts;\n\n\tif (ctrl->ops->reg_read32(ctrl, NVME_REG_CSTS, &csts))\n\t\treturn false;\n\n\tif (csts == ~0)\n\t\treturn false;\n\n\treturn ((ctrl->ctrl_config & NVME_CC_ENABLE) && (csts & NVME_CSTS_PP));\n}\n\nstatic void nvme_get_fw_slot_info(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_fw_slot_info_log *log;\n\n\tlog = kmalloc(sizeof(*log), GFP_KERNEL);\n\tif (!log)\n\t\treturn;\n\n\tif (nvme_get_log(ctrl, NVME_NSID_ALL, NVME_LOG_FW_SLOT, 0, NVME_CSI_NVM,\n\t\t\tlog, sizeof(*log), 0))\n\t\tdev_warn(ctrl->device, \"Get FW SLOT INFO log error\\n\");\n\tkfree(log);\n}\n\nstatic void nvme_fw_act_work(struct work_struct *work)\n{\n\tstruct nvme_ctrl *ctrl = container_of(work,\n\t\t\t\tstruct nvme_ctrl, fw_act_work);\n\tunsigned long fw_act_timeout;\n\n\tnvme_auth_stop(ctrl);\n\n\tif (ctrl->mtfa)\n\t\tfw_act_timeout = jiffies +\n\t\t\t\tmsecs_to_jiffies(ctrl->mtfa * 100);\n\telse\n\t\tfw_act_timeout = jiffies +\n\t\t\t\tmsecs_to_jiffies(admin_timeout * 1000);\n\n\tnvme_quiesce_io_queues(ctrl);\n\twhile (nvme_ctrl_pp_status(ctrl)) {\n\t\tif (time_after(jiffies, fw_act_timeout)) {\n\t\t\tdev_warn(ctrl->device,\n\t\t\t\t\"Fw activation timeout, reset controller\\n\");\n\t\t\tnvme_try_sched_reset(ctrl);\n\t\t\treturn;\n\t\t}\n\t\tmsleep(100);\n\t}\n\n\tif (!nvme_change_ctrl_state(ctrl, NVME_CTRL_LIVE))\n\t\treturn;\n\n\tnvme_unquiesce_io_queues(ctrl);\n\t \n\tnvme_get_fw_slot_info(ctrl);\n\n\tqueue_work(nvme_wq, &ctrl->async_event_work);\n}\n\nstatic u32 nvme_aer_type(u32 result)\n{\n\treturn result & 0x7;\n}\n\nstatic u32 nvme_aer_subtype(u32 result)\n{\n\treturn (result & 0xff00) >> 8;\n}\n\nstatic bool nvme_handle_aen_notice(struct nvme_ctrl *ctrl, u32 result)\n{\n\tu32 aer_notice_type = nvme_aer_subtype(result);\n\tbool requeue = true;\n\n\tswitch (aer_notice_type) {\n\tcase NVME_AER_NOTICE_NS_CHANGED:\n\t\tset_bit(NVME_AER_NOTICE_NS_CHANGED, &ctrl->events);\n\t\tnvme_queue_scan(ctrl);\n\t\tbreak;\n\tcase NVME_AER_NOTICE_FW_ACT_STARTING:\n\t\t \n\t\tif (nvme_change_ctrl_state(ctrl, NVME_CTRL_RESETTING)) {\n\t\t\trequeue = false;\n\t\t\tqueue_work(nvme_wq, &ctrl->fw_act_work);\n\t\t}\n\t\tbreak;\n#ifdef CONFIG_NVME_MULTIPATH\n\tcase NVME_AER_NOTICE_ANA:\n\t\tif (!ctrl->ana_log_buf)\n\t\t\tbreak;\n\t\tqueue_work(nvme_wq, &ctrl->ana_work);\n\t\tbreak;\n#endif\n\tcase NVME_AER_NOTICE_DISC_CHANGED:\n\t\tctrl->aen_result = result;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(ctrl->device, \"async event result %08x\\n\", result);\n\t}\n\treturn requeue;\n}\n\nstatic void nvme_handle_aer_persistent_error(struct nvme_ctrl *ctrl)\n{\n\tdev_warn(ctrl->device, \"resetting controller due to AER\\n\");\n\tnvme_reset_ctrl(ctrl);\n}\n\nvoid nvme_complete_async_event(struct nvme_ctrl *ctrl, __le16 status,\n\t\tvolatile union nvme_result *res)\n{\n\tu32 result = le32_to_cpu(res->u32);\n\tu32 aer_type = nvme_aer_type(result);\n\tu32 aer_subtype = nvme_aer_subtype(result);\n\tbool requeue = true;\n\n\tif (le16_to_cpu(status) >> 1 != NVME_SC_SUCCESS)\n\t\treturn;\n\n\ttrace_nvme_async_event(ctrl, result);\n\tswitch (aer_type) {\n\tcase NVME_AER_NOTICE:\n\t\trequeue = nvme_handle_aen_notice(ctrl, result);\n\t\tbreak;\n\tcase NVME_AER_ERROR:\n\t\t \n\t\tif (aer_subtype == NVME_AER_ERROR_PERSIST_INT_ERR) {\n\t\t\tnvme_handle_aer_persistent_error(ctrl);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase NVME_AER_SMART:\n\tcase NVME_AER_CSS:\n\tcase NVME_AER_VS:\n\t\tctrl->aen_result = result;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (requeue)\n\t\tqueue_work(nvme_wq, &ctrl->async_event_work);\n}\nEXPORT_SYMBOL_GPL(nvme_complete_async_event);\n\nint nvme_alloc_admin_tag_set(struct nvme_ctrl *ctrl, struct blk_mq_tag_set *set,\n\t\tconst struct blk_mq_ops *ops, unsigned int cmd_size)\n{\n\tint ret;\n\n\tmemset(set, 0, sizeof(*set));\n\tset->ops = ops;\n\tset->queue_depth = NVME_AQ_MQ_TAG_DEPTH;\n\tif (ctrl->ops->flags & NVME_F_FABRICS)\n\t\tset->reserved_tags = NVMF_RESERVED_TAGS;\n\tset->numa_node = ctrl->numa_node;\n\tset->flags = BLK_MQ_F_NO_SCHED;\n\tif (ctrl->ops->flags & NVME_F_BLOCKING)\n\t\tset->flags |= BLK_MQ_F_BLOCKING;\n\tset->cmd_size = cmd_size;\n\tset->driver_data = ctrl;\n\tset->nr_hw_queues = 1;\n\tset->timeout = NVME_ADMIN_TIMEOUT;\n\tret = blk_mq_alloc_tag_set(set);\n\tif (ret)\n\t\treturn ret;\n\n\tctrl->admin_q = blk_mq_init_queue(set);\n\tif (IS_ERR(ctrl->admin_q)) {\n\t\tret = PTR_ERR(ctrl->admin_q);\n\t\tgoto out_free_tagset;\n\t}\n\n\tif (ctrl->ops->flags & NVME_F_FABRICS) {\n\t\tctrl->fabrics_q = blk_mq_init_queue(set);\n\t\tif (IS_ERR(ctrl->fabrics_q)) {\n\t\t\tret = PTR_ERR(ctrl->fabrics_q);\n\t\t\tgoto out_cleanup_admin_q;\n\t\t}\n\t}\n\n\tctrl->admin_tagset = set;\n\treturn 0;\n\nout_cleanup_admin_q:\n\tblk_mq_destroy_queue(ctrl->admin_q);\n\tblk_put_queue(ctrl->admin_q);\nout_free_tagset:\n\tblk_mq_free_tag_set(set);\n\tctrl->admin_q = NULL;\n\tctrl->fabrics_q = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvme_alloc_admin_tag_set);\n\nvoid nvme_remove_admin_tag_set(struct nvme_ctrl *ctrl)\n{\n\tblk_mq_destroy_queue(ctrl->admin_q);\n\tblk_put_queue(ctrl->admin_q);\n\tif (ctrl->ops->flags & NVME_F_FABRICS) {\n\t\tblk_mq_destroy_queue(ctrl->fabrics_q);\n\t\tblk_put_queue(ctrl->fabrics_q);\n\t}\n\tblk_mq_free_tag_set(ctrl->admin_tagset);\n}\nEXPORT_SYMBOL_GPL(nvme_remove_admin_tag_set);\n\nint nvme_alloc_io_tag_set(struct nvme_ctrl *ctrl, struct blk_mq_tag_set *set,\n\t\tconst struct blk_mq_ops *ops, unsigned int nr_maps,\n\t\tunsigned int cmd_size)\n{\n\tint ret;\n\n\tmemset(set, 0, sizeof(*set));\n\tset->ops = ops;\n\tset->queue_depth = min_t(unsigned, ctrl->sqsize, BLK_MQ_MAX_DEPTH - 1);\n\t \n\tif (ctrl->quirks & NVME_QUIRK_SHARED_TAGS)\n\t\tset->reserved_tags = NVME_AQ_DEPTH;\n\telse if (ctrl->ops->flags & NVME_F_FABRICS)\n\t\tset->reserved_tags = NVMF_RESERVED_TAGS;\n\tset->numa_node = ctrl->numa_node;\n\tset->flags = BLK_MQ_F_SHOULD_MERGE;\n\tif (ctrl->ops->flags & NVME_F_BLOCKING)\n\t\tset->flags |= BLK_MQ_F_BLOCKING;\n\tset->cmd_size = cmd_size,\n\tset->driver_data = ctrl;\n\tset->nr_hw_queues = ctrl->queue_count - 1;\n\tset->timeout = NVME_IO_TIMEOUT;\n\tset->nr_maps = nr_maps;\n\tret = blk_mq_alloc_tag_set(set);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctrl->ops->flags & NVME_F_FABRICS) {\n\t\tctrl->connect_q = blk_mq_init_queue(set);\n        \tif (IS_ERR(ctrl->connect_q)) {\n\t\t\tret = PTR_ERR(ctrl->connect_q);\n\t\t\tgoto out_free_tag_set;\n\t\t}\n\t\tblk_queue_flag_set(QUEUE_FLAG_SKIP_TAGSET_QUIESCE,\n\t\t\t\t   ctrl->connect_q);\n\t}\n\n\tctrl->tagset = set;\n\treturn 0;\n\nout_free_tag_set:\n\tblk_mq_free_tag_set(set);\n\tctrl->connect_q = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvme_alloc_io_tag_set);\n\nvoid nvme_remove_io_tag_set(struct nvme_ctrl *ctrl)\n{\n\tif (ctrl->ops->flags & NVME_F_FABRICS) {\n\t\tblk_mq_destroy_queue(ctrl->connect_q);\n\t\tblk_put_queue(ctrl->connect_q);\n\t}\n\tblk_mq_free_tag_set(ctrl->tagset);\n}\nEXPORT_SYMBOL_GPL(nvme_remove_io_tag_set);\n\nvoid nvme_stop_ctrl(struct nvme_ctrl *ctrl)\n{\n\tnvme_mpath_stop(ctrl);\n\tnvme_auth_stop(ctrl);\n\tnvme_stop_keep_alive(ctrl);\n\tnvme_stop_failfast_work(ctrl);\n\tflush_work(&ctrl->async_event_work);\n\tcancel_work_sync(&ctrl->fw_act_work);\n\tif (ctrl->ops->stop_ctrl)\n\t\tctrl->ops->stop_ctrl(ctrl);\n}\nEXPORT_SYMBOL_GPL(nvme_stop_ctrl);\n\nvoid nvme_start_ctrl(struct nvme_ctrl *ctrl)\n{\n\tnvme_start_keep_alive(ctrl);\n\n\tnvme_enable_aen(ctrl);\n\n\t \n\tif (test_bit(NVME_CTRL_STARTED_ONCE, &ctrl->flags) &&\n\t    nvme_discovery_ctrl(ctrl))\n\t\tnvme_change_uevent(ctrl, \"NVME_EVENT=rediscover\");\n\n\tif (ctrl->queue_count > 1) {\n\t\tnvme_queue_scan(ctrl);\n\t\tnvme_unquiesce_io_queues(ctrl);\n\t\tnvme_mpath_update(ctrl);\n\t}\n\n\tnvme_change_uevent(ctrl, \"NVME_EVENT=connected\");\n\tset_bit(NVME_CTRL_STARTED_ONCE, &ctrl->flags);\n}\nEXPORT_SYMBOL_GPL(nvme_start_ctrl);\n\nvoid nvme_uninit_ctrl(struct nvme_ctrl *ctrl)\n{\n\tnvme_hwmon_exit(ctrl);\n\tnvme_fault_inject_fini(&ctrl->fault_inject);\n\tdev_pm_qos_hide_latency_tolerance(ctrl->device);\n\tcdev_device_del(&ctrl->cdev, ctrl->device);\n\tnvme_put_ctrl(ctrl);\n}\nEXPORT_SYMBOL_GPL(nvme_uninit_ctrl);\n\nstatic void nvme_free_cels(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_effects_log\t*cel;\n\tunsigned long i;\n\n\txa_for_each(&ctrl->cels, i, cel) {\n\t\txa_erase(&ctrl->cels, i);\n\t\tkfree(cel);\n\t}\n\n\txa_destroy(&ctrl->cels);\n}\n\nstatic void nvme_free_ctrl(struct device *dev)\n{\n\tstruct nvme_ctrl *ctrl =\n\t\tcontainer_of(dev, struct nvme_ctrl, ctrl_device);\n\tstruct nvme_subsystem *subsys = ctrl->subsys;\n\n\tif (!subsys || ctrl->instance != subsys->instance)\n\t\tida_free(&nvme_instance_ida, ctrl->instance);\n\n\tnvme_free_cels(ctrl);\n\tnvme_mpath_uninit(ctrl);\n\tnvme_auth_stop(ctrl);\n\tnvme_auth_free(ctrl);\n\t__free_page(ctrl->discard_page);\n\tfree_opal_dev(ctrl->opal_dev);\n\n\tif (subsys) {\n\t\tmutex_lock(&nvme_subsystems_lock);\n\t\tlist_del(&ctrl->subsys_entry);\n\t\tsysfs_remove_link(&subsys->dev.kobj, dev_name(ctrl->device));\n\t\tmutex_unlock(&nvme_subsystems_lock);\n\t}\n\n\tctrl->ops->free_ctrl(ctrl);\n\n\tif (subsys)\n\t\tnvme_put_subsystem(subsys);\n}\n\n \nint nvme_init_ctrl(struct nvme_ctrl *ctrl, struct device *dev,\n\t\tconst struct nvme_ctrl_ops *ops, unsigned long quirks)\n{\n\tint ret;\n\n\tWRITE_ONCE(ctrl->state, NVME_CTRL_NEW);\n\tclear_bit(NVME_CTRL_FAILFAST_EXPIRED, &ctrl->flags);\n\tspin_lock_init(&ctrl->lock);\n\tmutex_init(&ctrl->scan_lock);\n\tINIT_LIST_HEAD(&ctrl->namespaces);\n\txa_init(&ctrl->cels);\n\tinit_rwsem(&ctrl->namespaces_rwsem);\n\tctrl->dev = dev;\n\tctrl->ops = ops;\n\tctrl->quirks = quirks;\n\tctrl->numa_node = NUMA_NO_NODE;\n\tINIT_WORK(&ctrl->scan_work, nvme_scan_work);\n\tINIT_WORK(&ctrl->async_event_work, nvme_async_event_work);\n\tINIT_WORK(&ctrl->fw_act_work, nvme_fw_act_work);\n\tINIT_WORK(&ctrl->delete_work, nvme_delete_ctrl_work);\n\tinit_waitqueue_head(&ctrl->state_wq);\n\n\tINIT_DELAYED_WORK(&ctrl->ka_work, nvme_keep_alive_work);\n\tINIT_DELAYED_WORK(&ctrl->failfast_work, nvme_failfast_work);\n\tmemset(&ctrl->ka_cmd, 0, sizeof(ctrl->ka_cmd));\n\tctrl->ka_cmd.common.opcode = nvme_admin_keep_alive;\n\n\tBUILD_BUG_ON(NVME_DSM_MAX_RANGES * sizeof(struct nvme_dsm_range) >\n\t\t\tPAGE_SIZE);\n\tctrl->discard_page = alloc_page(GFP_KERNEL);\n\tif (!ctrl->discard_page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ida_alloc(&nvme_instance_ida, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto out;\n\tctrl->instance = ret;\n\n\tdevice_initialize(&ctrl->ctrl_device);\n\tctrl->device = &ctrl->ctrl_device;\n\tctrl->device->devt = MKDEV(MAJOR(nvme_ctrl_base_chr_devt),\n\t\t\tctrl->instance);\n\tctrl->device->class = nvme_class;\n\tctrl->device->parent = ctrl->dev;\n\tif (ops->dev_attr_groups)\n\t\tctrl->device->groups = ops->dev_attr_groups;\n\telse\n\t\tctrl->device->groups = nvme_dev_attr_groups;\n\tctrl->device->release = nvme_free_ctrl;\n\tdev_set_drvdata(ctrl->device, ctrl);\n\tret = dev_set_name(ctrl->device, \"nvme%d\", ctrl->instance);\n\tif (ret)\n\t\tgoto out_release_instance;\n\n\tnvme_get_ctrl(ctrl);\n\tcdev_init(&ctrl->cdev, &nvme_dev_fops);\n\tctrl->cdev.owner = ops->module;\n\tret = cdev_device_add(&ctrl->cdev, ctrl->device);\n\tif (ret)\n\t\tgoto out_free_name;\n\n\t \n\tctrl->device->power.set_latency_tolerance = nvme_set_latency_tolerance;\n\tdev_pm_qos_update_user_latency_tolerance(ctrl->device,\n\t\tmin(default_ps_max_latency_us, (unsigned long)S32_MAX));\n\n\tnvme_fault_inject_init(&ctrl->fault_inject, dev_name(ctrl->device));\n\tnvme_mpath_init_ctrl(ctrl);\n\tret = nvme_auth_init_ctrl(ctrl);\n\tif (ret)\n\t\tgoto out_free_cdev;\n\n\treturn 0;\nout_free_cdev:\n\tnvme_fault_inject_fini(&ctrl->fault_inject);\n\tdev_pm_qos_hide_latency_tolerance(ctrl->device);\n\tcdev_device_del(&ctrl->cdev, ctrl->device);\nout_free_name:\n\tnvme_put_ctrl(ctrl);\n\tkfree_const(ctrl->device->kobj.name);\nout_release_instance:\n\tida_free(&nvme_instance_ida, ctrl->instance);\nout:\n\tif (ctrl->discard_page)\n\t\t__free_page(ctrl->discard_page);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvme_init_ctrl);\n\n \nvoid nvme_mark_namespaces_dead(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_ns *ns;\n\n\tdown_read(&ctrl->namespaces_rwsem);\n\tlist_for_each_entry(ns, &ctrl->namespaces, list)\n\t\tblk_mark_disk_dead(ns->disk);\n\tup_read(&ctrl->namespaces_rwsem);\n}\nEXPORT_SYMBOL_GPL(nvme_mark_namespaces_dead);\n\nvoid nvme_unfreeze(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_ns *ns;\n\n\tdown_read(&ctrl->namespaces_rwsem);\n\tlist_for_each_entry(ns, &ctrl->namespaces, list)\n\t\tblk_mq_unfreeze_queue(ns->queue);\n\tup_read(&ctrl->namespaces_rwsem);\n\tclear_bit(NVME_CTRL_FROZEN, &ctrl->flags);\n}\nEXPORT_SYMBOL_GPL(nvme_unfreeze);\n\nint nvme_wait_freeze_timeout(struct nvme_ctrl *ctrl, long timeout)\n{\n\tstruct nvme_ns *ns;\n\n\tdown_read(&ctrl->namespaces_rwsem);\n\tlist_for_each_entry(ns, &ctrl->namespaces, list) {\n\t\ttimeout = blk_mq_freeze_queue_wait_timeout(ns->queue, timeout);\n\t\tif (timeout <= 0)\n\t\t\tbreak;\n\t}\n\tup_read(&ctrl->namespaces_rwsem);\n\treturn timeout;\n}\nEXPORT_SYMBOL_GPL(nvme_wait_freeze_timeout);\n\nvoid nvme_wait_freeze(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_ns *ns;\n\n\tdown_read(&ctrl->namespaces_rwsem);\n\tlist_for_each_entry(ns, &ctrl->namespaces, list)\n\t\tblk_mq_freeze_queue_wait(ns->queue);\n\tup_read(&ctrl->namespaces_rwsem);\n}\nEXPORT_SYMBOL_GPL(nvme_wait_freeze);\n\nvoid nvme_start_freeze(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_ns *ns;\n\n\tset_bit(NVME_CTRL_FROZEN, &ctrl->flags);\n\tdown_read(&ctrl->namespaces_rwsem);\n\tlist_for_each_entry(ns, &ctrl->namespaces, list)\n\t\tblk_freeze_queue_start(ns->queue);\n\tup_read(&ctrl->namespaces_rwsem);\n}\nEXPORT_SYMBOL_GPL(nvme_start_freeze);\n\nvoid nvme_quiesce_io_queues(struct nvme_ctrl *ctrl)\n{\n\tif (!ctrl->tagset)\n\t\treturn;\n\tif (!test_and_set_bit(NVME_CTRL_STOPPED, &ctrl->flags))\n\t\tblk_mq_quiesce_tagset(ctrl->tagset);\n\telse\n\t\tblk_mq_wait_quiesce_done(ctrl->tagset);\n}\nEXPORT_SYMBOL_GPL(nvme_quiesce_io_queues);\n\nvoid nvme_unquiesce_io_queues(struct nvme_ctrl *ctrl)\n{\n\tif (!ctrl->tagset)\n\t\treturn;\n\tif (test_and_clear_bit(NVME_CTRL_STOPPED, &ctrl->flags))\n\t\tblk_mq_unquiesce_tagset(ctrl->tagset);\n}\nEXPORT_SYMBOL_GPL(nvme_unquiesce_io_queues);\n\nvoid nvme_quiesce_admin_queue(struct nvme_ctrl *ctrl)\n{\n\tif (!test_and_set_bit(NVME_CTRL_ADMIN_Q_STOPPED, &ctrl->flags))\n\t\tblk_mq_quiesce_queue(ctrl->admin_q);\n\telse\n\t\tblk_mq_wait_quiesce_done(ctrl->admin_q->tag_set);\n}\nEXPORT_SYMBOL_GPL(nvme_quiesce_admin_queue);\n\nvoid nvme_unquiesce_admin_queue(struct nvme_ctrl *ctrl)\n{\n\tif (test_and_clear_bit(NVME_CTRL_ADMIN_Q_STOPPED, &ctrl->flags))\n\t\tblk_mq_unquiesce_queue(ctrl->admin_q);\n}\nEXPORT_SYMBOL_GPL(nvme_unquiesce_admin_queue);\n\nvoid nvme_sync_io_queues(struct nvme_ctrl *ctrl)\n{\n\tstruct nvme_ns *ns;\n\n\tdown_read(&ctrl->namespaces_rwsem);\n\tlist_for_each_entry(ns, &ctrl->namespaces, list)\n\t\tblk_sync_queue(ns->queue);\n\tup_read(&ctrl->namespaces_rwsem);\n}\nEXPORT_SYMBOL_GPL(nvme_sync_io_queues);\n\nvoid nvme_sync_queues(struct nvme_ctrl *ctrl)\n{\n\tnvme_sync_io_queues(ctrl);\n\tif (ctrl->admin_q)\n\t\tblk_sync_queue(ctrl->admin_q);\n}\nEXPORT_SYMBOL_GPL(nvme_sync_queues);\n\nstruct nvme_ctrl *nvme_ctrl_from_file(struct file *file)\n{\n\tif (file->f_op != &nvme_dev_fops)\n\t\treturn NULL;\n\treturn file->private_data;\n}\nEXPORT_SYMBOL_NS_GPL(nvme_ctrl_from_file, NVME_TARGET_PASSTHRU);\n\n \nstatic inline void _nvme_check_size(void)\n{\n\tBUILD_BUG_ON(sizeof(struct nvme_common_command) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_rw_command) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_identify) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_features) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_download_firmware) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_format_cmd) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_dsm_cmd) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_write_zeroes_cmd) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_abort_cmd) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_get_log_page_command) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_command) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_id_ctrl) != NVME_IDENTIFY_DATA_SIZE);\n\tBUILD_BUG_ON(sizeof(struct nvme_id_ns) != NVME_IDENTIFY_DATA_SIZE);\n\tBUILD_BUG_ON(sizeof(struct nvme_id_ns_cs_indep) !=\n\t\t\tNVME_IDENTIFY_DATA_SIZE);\n\tBUILD_BUG_ON(sizeof(struct nvme_id_ns_zns) != NVME_IDENTIFY_DATA_SIZE);\n\tBUILD_BUG_ON(sizeof(struct nvme_id_ns_nvm) != NVME_IDENTIFY_DATA_SIZE);\n\tBUILD_BUG_ON(sizeof(struct nvme_id_ctrl_zns) != NVME_IDENTIFY_DATA_SIZE);\n\tBUILD_BUG_ON(sizeof(struct nvme_id_ctrl_nvm) != NVME_IDENTIFY_DATA_SIZE);\n\tBUILD_BUG_ON(sizeof(struct nvme_lba_range_type) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_smart_log) != 512);\n\tBUILD_BUG_ON(sizeof(struct nvme_dbbuf) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_directive_cmd) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvme_feat_host_behavior) != 512);\n}\n\n\nstatic int __init nvme_core_init(void)\n{\n\tint result = -ENOMEM;\n\n\t_nvme_check_size();\n\n\tnvme_wq = alloc_workqueue(\"nvme-wq\",\n\t\t\tWQ_UNBOUND | WQ_MEM_RECLAIM | WQ_SYSFS, 0);\n\tif (!nvme_wq)\n\t\tgoto out;\n\n\tnvme_reset_wq = alloc_workqueue(\"nvme-reset-wq\",\n\t\t\tWQ_UNBOUND | WQ_MEM_RECLAIM | WQ_SYSFS, 0);\n\tif (!nvme_reset_wq)\n\t\tgoto destroy_wq;\n\n\tnvme_delete_wq = alloc_workqueue(\"nvme-delete-wq\",\n\t\t\tWQ_UNBOUND | WQ_MEM_RECLAIM | WQ_SYSFS, 0);\n\tif (!nvme_delete_wq)\n\t\tgoto destroy_reset_wq;\n\n\tresult = alloc_chrdev_region(&nvme_ctrl_base_chr_devt, 0,\n\t\t\tNVME_MINORS, \"nvme\");\n\tif (result < 0)\n\t\tgoto destroy_delete_wq;\n\n\tnvme_class = class_create(\"nvme\");\n\tif (IS_ERR(nvme_class)) {\n\t\tresult = PTR_ERR(nvme_class);\n\t\tgoto unregister_chrdev;\n\t}\n\tnvme_class->dev_uevent = nvme_class_uevent;\n\n\tnvme_subsys_class = class_create(\"nvme-subsystem\");\n\tif (IS_ERR(nvme_subsys_class)) {\n\t\tresult = PTR_ERR(nvme_subsys_class);\n\t\tgoto destroy_class;\n\t}\n\n\tresult = alloc_chrdev_region(&nvme_ns_chr_devt, 0, NVME_MINORS,\n\t\t\t\t     \"nvme-generic\");\n\tif (result < 0)\n\t\tgoto destroy_subsys_class;\n\n\tnvme_ns_chr_class = class_create(\"nvme-generic\");\n\tif (IS_ERR(nvme_ns_chr_class)) {\n\t\tresult = PTR_ERR(nvme_ns_chr_class);\n\t\tgoto unregister_generic_ns;\n\t}\n\n\tresult = nvme_init_auth();\n\tif (result)\n\t\tgoto destroy_ns_chr;\n\treturn 0;\n\ndestroy_ns_chr:\n\tclass_destroy(nvme_ns_chr_class);\nunregister_generic_ns:\n\tunregister_chrdev_region(nvme_ns_chr_devt, NVME_MINORS);\ndestroy_subsys_class:\n\tclass_destroy(nvme_subsys_class);\ndestroy_class:\n\tclass_destroy(nvme_class);\nunregister_chrdev:\n\tunregister_chrdev_region(nvme_ctrl_base_chr_devt, NVME_MINORS);\ndestroy_delete_wq:\n\tdestroy_workqueue(nvme_delete_wq);\ndestroy_reset_wq:\n\tdestroy_workqueue(nvme_reset_wq);\ndestroy_wq:\n\tdestroy_workqueue(nvme_wq);\nout:\n\treturn result;\n}\n\nstatic void __exit nvme_core_exit(void)\n{\n\tnvme_exit_auth();\n\tclass_destroy(nvme_ns_chr_class);\n\tclass_destroy(nvme_subsys_class);\n\tclass_destroy(nvme_class);\n\tunregister_chrdev_region(nvme_ns_chr_devt, NVME_MINORS);\n\tunregister_chrdev_region(nvme_ctrl_base_chr_devt, NVME_MINORS);\n\tdestroy_workqueue(nvme_delete_wq);\n\tdestroy_workqueue(nvme_reset_wq);\n\tdestroy_workqueue(nvme_wq);\n\tida_destroy(&nvme_ns_chr_minor_ida);\n\tida_destroy(&nvme_instance_ida);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.0\");\nmodule_init(nvme_core_init);\nmodule_exit(nvme_core_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}