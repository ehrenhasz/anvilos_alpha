{
  "module_name": "apple.c",
  "hash_id": "5472229f3a76ce5215f46b3513d60f5bf80e847e3f969a83c3bd09392abf5e93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/host/apple.c",
  "human_readable_source": "\n \n\n#include <linux/async.h>\n#include <linux/blkdev.h>\n#include <linux/blk-mq.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/interrupt.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/jiffies.h>\n#include <linux/mempool.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/once.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/soc/apple/rtkit.h>\n#include <linux/soc/apple/sart.h>\n#include <linux/reset.h>\n#include <linux/time64.h>\n\n#include \"nvme.h\"\n\n#define APPLE_ANS_BOOT_TIMEOUT\t  USEC_PER_SEC\n#define APPLE_ANS_MAX_QUEUE_DEPTH 64\n\n#define APPLE_ANS_COPROC_CPU_CONTROL\t 0x44\n#define APPLE_ANS_COPROC_CPU_CONTROL_RUN BIT(4)\n\n#define APPLE_ANS_ACQ_DB  0x1004\n#define APPLE_ANS_IOCQ_DB 0x100c\n\n#define APPLE_ANS_MAX_PEND_CMDS_CTRL 0x1210\n\n#define APPLE_ANS_BOOT_STATUS\t 0x1300\n#define APPLE_ANS_BOOT_STATUS_OK 0xde71ce55\n\n#define APPLE_ANS_UNKNOWN_CTRL\t 0x24008\n#define APPLE_ANS_PRP_NULL_CHECK BIT(11)\n\n#define APPLE_ANS_LINEAR_SQ_CTRL 0x24908\n#define APPLE_ANS_LINEAR_SQ_EN\t BIT(0)\n\n#define APPLE_ANS_LINEAR_ASQ_DB\t 0x2490c\n#define APPLE_ANS_LINEAR_IOSQ_DB 0x24910\n\n#define APPLE_NVMMU_NUM_TCBS\t  0x28100\n#define APPLE_NVMMU_ASQ_TCB_BASE  0x28108\n#define APPLE_NVMMU_IOSQ_TCB_BASE 0x28110\n#define APPLE_NVMMU_TCB_INVAL\t  0x28118\n#define APPLE_NVMMU_TCB_STAT\t  0x28120\n\n \n#define APPLE_NVME_AQ_DEPTH\t   2\n#define APPLE_NVME_AQ_MQ_TAG_DEPTH (APPLE_NVME_AQ_DEPTH - 1)\n\n \n#define NVME_MAX_KB_SZ 4096\n#define NVME_MAX_SEGS  127\n\n \nstruct apple_nvmmu_tcb {\n\tu8 opcode;\n\n#define APPLE_ANS_TCB_DMA_FROM_DEVICE BIT(0)\n#define APPLE_ANS_TCB_DMA_TO_DEVICE   BIT(1)\n\tu8 dma_flags;\n\n\tu8 command_id;\n\tu8 _unk0;\n\t__le16 length;\n\tu8 _unk1[18];\n\t__le64 prp1;\n\t__le64 prp2;\n\tu8 _unk2[16];\n\tu8 aes_iv[8];\n\tu8 _aes_unk[64];\n};\n\n \nstruct apple_nvme_queue {\n\tstruct nvme_command *sqes;\n\tstruct nvme_completion *cqes;\n\tstruct apple_nvmmu_tcb *tcbs;\n\n\tdma_addr_t sq_dma_addr;\n\tdma_addr_t cq_dma_addr;\n\tdma_addr_t tcb_dma_addr;\n\n\tu32 __iomem *sq_db;\n\tu32 __iomem *cq_db;\n\n\tu16 cq_head;\n\tu8 cq_phase;\n\n\tbool is_adminq;\n\tbool enabled;\n};\n\n \nstruct apple_nvme_iod {\n\tstruct nvme_request req;\n\tstruct nvme_command cmd;\n\tstruct apple_nvme_queue *q;\n\tint npages;  \n\tint nents;  \n\tdma_addr_t first_dma;\n\tunsigned int dma_len;  \n\tstruct scatterlist *sg;\n};\n\nstruct apple_nvme {\n\tstruct device *dev;\n\n\tvoid __iomem *mmio_coproc;\n\tvoid __iomem *mmio_nvme;\n\n\tstruct device **pd_dev;\n\tstruct device_link **pd_link;\n\tint pd_count;\n\n\tstruct apple_sart *sart;\n\tstruct apple_rtkit *rtk;\n\tstruct reset_control *reset;\n\n\tstruct dma_pool *prp_page_pool;\n\tstruct dma_pool *prp_small_pool;\n\tmempool_t *iod_mempool;\n\n\tstruct nvme_ctrl ctrl;\n\tstruct work_struct remove_work;\n\n\tstruct apple_nvme_queue adminq;\n\tstruct apple_nvme_queue ioq;\n\n\tstruct blk_mq_tag_set admin_tagset;\n\tstruct blk_mq_tag_set tagset;\n\n\tint irq;\n\tspinlock_t lock;\n};\n\nstatic_assert(sizeof(struct nvme_command) == 64);\nstatic_assert(sizeof(struct apple_nvmmu_tcb) == 128);\n\nstatic inline struct apple_nvme *ctrl_to_apple_nvme(struct nvme_ctrl *ctrl)\n{\n\treturn container_of(ctrl, struct apple_nvme, ctrl);\n}\n\nstatic inline struct apple_nvme *queue_to_apple_nvme(struct apple_nvme_queue *q)\n{\n\tif (q->is_adminq)\n\t\treturn container_of(q, struct apple_nvme, adminq);\n\n\treturn container_of(q, struct apple_nvme, ioq);\n}\n\nstatic unsigned int apple_nvme_queue_depth(struct apple_nvme_queue *q)\n{\n\tif (q->is_adminq)\n\t\treturn APPLE_NVME_AQ_DEPTH;\n\n\treturn APPLE_ANS_MAX_QUEUE_DEPTH;\n}\n\nstatic void apple_nvme_rtkit_crashed(void *cookie)\n{\n\tstruct apple_nvme *anv = cookie;\n\n\tdev_warn(anv->dev, \"RTKit crashed; unable to recover without a reboot\");\n\tnvme_reset_ctrl(&anv->ctrl);\n}\n\nstatic int apple_nvme_sart_dma_setup(void *cookie,\n\t\t\t\t     struct apple_rtkit_shmem *bfr)\n{\n\tstruct apple_nvme *anv = cookie;\n\tint ret;\n\n\tif (bfr->iova)\n\t\treturn -EINVAL;\n\tif (!bfr->size)\n\t\treturn -EINVAL;\n\n\tbfr->buffer =\n\t\tdma_alloc_coherent(anv->dev, bfr->size, &bfr->iova, GFP_KERNEL);\n\tif (!bfr->buffer)\n\t\treturn -ENOMEM;\n\n\tret = apple_sart_add_allowed_region(anv->sart, bfr->iova, bfr->size);\n\tif (ret) {\n\t\tdma_free_coherent(anv->dev, bfr->size, bfr->buffer, bfr->iova);\n\t\tbfr->buffer = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void apple_nvme_sart_dma_destroy(void *cookie,\n\t\t\t\t\tstruct apple_rtkit_shmem *bfr)\n{\n\tstruct apple_nvme *anv = cookie;\n\n\tapple_sart_remove_allowed_region(anv->sart, bfr->iova, bfr->size);\n\tdma_free_coherent(anv->dev, bfr->size, bfr->buffer, bfr->iova);\n}\n\nstatic const struct apple_rtkit_ops apple_nvme_rtkit_ops = {\n\t.crashed = apple_nvme_rtkit_crashed,\n\t.shmem_setup = apple_nvme_sart_dma_setup,\n\t.shmem_destroy = apple_nvme_sart_dma_destroy,\n};\n\nstatic void apple_nvmmu_inval(struct apple_nvme_queue *q, unsigned int tag)\n{\n\tstruct apple_nvme *anv = queue_to_apple_nvme(q);\n\n\twritel(tag, anv->mmio_nvme + APPLE_NVMMU_TCB_INVAL);\n\tif (readl(anv->mmio_nvme + APPLE_NVMMU_TCB_STAT))\n\t\tdev_warn_ratelimited(anv->dev,\n\t\t\t\t     \"NVMMU TCB invalidation failed\\n\");\n}\n\nstatic void apple_nvme_submit_cmd(struct apple_nvme_queue *q,\n\t\t\t\t  struct nvme_command *cmd)\n{\n\tstruct apple_nvme *anv = queue_to_apple_nvme(q);\n\tu32 tag = nvme_tag_from_cid(cmd->common.command_id);\n\tstruct apple_nvmmu_tcb *tcb = &q->tcbs[tag];\n\n\ttcb->opcode = cmd->common.opcode;\n\ttcb->prp1 = cmd->common.dptr.prp1;\n\ttcb->prp2 = cmd->common.dptr.prp2;\n\ttcb->length = cmd->rw.length;\n\ttcb->command_id = tag;\n\n\tif (nvme_is_write(cmd))\n\t\ttcb->dma_flags = APPLE_ANS_TCB_DMA_TO_DEVICE;\n\telse\n\t\ttcb->dma_flags = APPLE_ANS_TCB_DMA_FROM_DEVICE;\n\n\tmemcpy(&q->sqes[tag], cmd, sizeof(*cmd));\n\n\t \n\tspin_lock_irq(&anv->lock);\n\twritel(tag, q->sq_db);\n\tspin_unlock_irq(&anv->lock);\n}\n\n \nstatic inline size_t apple_nvme_iod_alloc_size(void)\n{\n\tconst unsigned int nprps = DIV_ROUND_UP(\n\t\tNVME_MAX_KB_SZ + NVME_CTRL_PAGE_SIZE, NVME_CTRL_PAGE_SIZE);\n\tconst int npages = DIV_ROUND_UP(8 * nprps, PAGE_SIZE - 8);\n\tconst size_t alloc_size = sizeof(__le64 *) * npages +\n\t\t\t\t  sizeof(struct scatterlist) * NVME_MAX_SEGS;\n\n\treturn alloc_size;\n}\n\nstatic void **apple_nvme_iod_list(struct request *req)\n{\n\tstruct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);\n\n\treturn (void **)(iod->sg + blk_rq_nr_phys_segments(req));\n}\n\nstatic void apple_nvme_free_prps(struct apple_nvme *anv, struct request *req)\n{\n\tconst int last_prp = NVME_CTRL_PAGE_SIZE / sizeof(__le64) - 1;\n\tstruct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);\n\tdma_addr_t dma_addr = iod->first_dma;\n\tint i;\n\n\tfor (i = 0; i < iod->npages; i++) {\n\t\t__le64 *prp_list = apple_nvme_iod_list(req)[i];\n\t\tdma_addr_t next_dma_addr = le64_to_cpu(prp_list[last_prp]);\n\n\t\tdma_pool_free(anv->prp_page_pool, prp_list, dma_addr);\n\t\tdma_addr = next_dma_addr;\n\t}\n}\n\nstatic void apple_nvme_unmap_data(struct apple_nvme *anv, struct request *req)\n{\n\tstruct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);\n\n\tif (iod->dma_len) {\n\t\tdma_unmap_page(anv->dev, iod->first_dma, iod->dma_len,\n\t\t\t       rq_dma_dir(req));\n\t\treturn;\n\t}\n\n\tWARN_ON_ONCE(!iod->nents);\n\n\tdma_unmap_sg(anv->dev, iod->sg, iod->nents, rq_dma_dir(req));\n\tif (iod->npages == 0)\n\t\tdma_pool_free(anv->prp_small_pool, apple_nvme_iod_list(req)[0],\n\t\t\t      iod->first_dma);\n\telse\n\t\tapple_nvme_free_prps(anv, req);\n\tmempool_free(iod->sg, anv->iod_mempool);\n}\n\nstatic void apple_nvme_print_sgl(struct scatterlist *sgl, int nents)\n{\n\tint i;\n\tstruct scatterlist *sg;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tdma_addr_t phys = sg_phys(sg);\n\n\t\tpr_warn(\"sg[%d] phys_addr:%pad offset:%d length:%d dma_address:%pad dma_length:%d\\n\",\n\t\t\ti, &phys, sg->offset, sg->length, &sg_dma_address(sg),\n\t\t\tsg_dma_len(sg));\n\t}\n}\n\nstatic blk_status_t apple_nvme_setup_prps(struct apple_nvme *anv,\n\t\t\t\t\t  struct request *req,\n\t\t\t\t\t  struct nvme_rw_command *cmnd)\n{\n\tstruct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);\n\tstruct dma_pool *pool;\n\tint length = blk_rq_payload_bytes(req);\n\tstruct scatterlist *sg = iod->sg;\n\tint dma_len = sg_dma_len(sg);\n\tu64 dma_addr = sg_dma_address(sg);\n\tint offset = dma_addr & (NVME_CTRL_PAGE_SIZE - 1);\n\t__le64 *prp_list;\n\tvoid **list = apple_nvme_iod_list(req);\n\tdma_addr_t prp_dma;\n\tint nprps, i;\n\n\tlength -= (NVME_CTRL_PAGE_SIZE - offset);\n\tif (length <= 0) {\n\t\tiod->first_dma = 0;\n\t\tgoto done;\n\t}\n\n\tdma_len -= (NVME_CTRL_PAGE_SIZE - offset);\n\tif (dma_len) {\n\t\tdma_addr += (NVME_CTRL_PAGE_SIZE - offset);\n\t} else {\n\t\tsg = sg_next(sg);\n\t\tdma_addr = sg_dma_address(sg);\n\t\tdma_len = sg_dma_len(sg);\n\t}\n\n\tif (length <= NVME_CTRL_PAGE_SIZE) {\n\t\tiod->first_dma = dma_addr;\n\t\tgoto done;\n\t}\n\n\tnprps = DIV_ROUND_UP(length, NVME_CTRL_PAGE_SIZE);\n\tif (nprps <= (256 / 8)) {\n\t\tpool = anv->prp_small_pool;\n\t\tiod->npages = 0;\n\t} else {\n\t\tpool = anv->prp_page_pool;\n\t\tiod->npages = 1;\n\t}\n\n\tprp_list = dma_pool_alloc(pool, GFP_ATOMIC, &prp_dma);\n\tif (!prp_list) {\n\t\tiod->first_dma = dma_addr;\n\t\tiod->npages = -1;\n\t\treturn BLK_STS_RESOURCE;\n\t}\n\tlist[0] = prp_list;\n\tiod->first_dma = prp_dma;\n\ti = 0;\n\tfor (;;) {\n\t\tif (i == NVME_CTRL_PAGE_SIZE >> 3) {\n\t\t\t__le64 *old_prp_list = prp_list;\n\n\t\t\tprp_list = dma_pool_alloc(pool, GFP_ATOMIC, &prp_dma);\n\t\t\tif (!prp_list)\n\t\t\t\tgoto free_prps;\n\t\t\tlist[iod->npages++] = prp_list;\n\t\t\tprp_list[0] = old_prp_list[i - 1];\n\t\t\told_prp_list[i - 1] = cpu_to_le64(prp_dma);\n\t\t\ti = 1;\n\t\t}\n\t\tprp_list[i++] = cpu_to_le64(dma_addr);\n\t\tdma_len -= NVME_CTRL_PAGE_SIZE;\n\t\tdma_addr += NVME_CTRL_PAGE_SIZE;\n\t\tlength -= NVME_CTRL_PAGE_SIZE;\n\t\tif (length <= 0)\n\t\t\tbreak;\n\t\tif (dma_len > 0)\n\t\t\tcontinue;\n\t\tif (unlikely(dma_len < 0))\n\t\t\tgoto bad_sgl;\n\t\tsg = sg_next(sg);\n\t\tdma_addr = sg_dma_address(sg);\n\t\tdma_len = sg_dma_len(sg);\n\t}\ndone:\n\tcmnd->dptr.prp1 = cpu_to_le64(sg_dma_address(iod->sg));\n\tcmnd->dptr.prp2 = cpu_to_le64(iod->first_dma);\n\treturn BLK_STS_OK;\nfree_prps:\n\tapple_nvme_free_prps(anv, req);\n\treturn BLK_STS_RESOURCE;\nbad_sgl:\n\tWARN(DO_ONCE(apple_nvme_print_sgl, iod->sg, iod->nents),\n\t     \"Invalid SGL for payload:%d nents:%d\\n\", blk_rq_payload_bytes(req),\n\t     iod->nents);\n\treturn BLK_STS_IOERR;\n}\n\nstatic blk_status_t apple_nvme_setup_prp_simple(struct apple_nvme *anv,\n\t\t\t\t\t\tstruct request *req,\n\t\t\t\t\t\tstruct nvme_rw_command *cmnd,\n\t\t\t\t\t\tstruct bio_vec *bv)\n{\n\tstruct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);\n\tunsigned int offset = bv->bv_offset & (NVME_CTRL_PAGE_SIZE - 1);\n\tunsigned int first_prp_len = NVME_CTRL_PAGE_SIZE - offset;\n\n\tiod->first_dma = dma_map_bvec(anv->dev, bv, rq_dma_dir(req), 0);\n\tif (dma_mapping_error(anv->dev, iod->first_dma))\n\t\treturn BLK_STS_RESOURCE;\n\tiod->dma_len = bv->bv_len;\n\n\tcmnd->dptr.prp1 = cpu_to_le64(iod->first_dma);\n\tif (bv->bv_len > first_prp_len)\n\t\tcmnd->dptr.prp2 = cpu_to_le64(iod->first_dma + first_prp_len);\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t apple_nvme_map_data(struct apple_nvme *anv,\n\t\t\t\t\tstruct request *req,\n\t\t\t\t\tstruct nvme_command *cmnd)\n{\n\tstruct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);\n\tblk_status_t ret = BLK_STS_RESOURCE;\n\tint nr_mapped;\n\n\tif (blk_rq_nr_phys_segments(req) == 1) {\n\t\tstruct bio_vec bv = req_bvec(req);\n\n\t\tif (bv.bv_offset + bv.bv_len <= NVME_CTRL_PAGE_SIZE * 2)\n\t\t\treturn apple_nvme_setup_prp_simple(anv, req, &cmnd->rw,\n\t\t\t\t\t\t\t   &bv);\n\t}\n\n\tiod->dma_len = 0;\n\tiod->sg = mempool_alloc(anv->iod_mempool, GFP_ATOMIC);\n\tif (!iod->sg)\n\t\treturn BLK_STS_RESOURCE;\n\tsg_init_table(iod->sg, blk_rq_nr_phys_segments(req));\n\tiod->nents = blk_rq_map_sg(req->q, req, iod->sg);\n\tif (!iod->nents)\n\t\tgoto out_free_sg;\n\n\tnr_mapped = dma_map_sg_attrs(anv->dev, iod->sg, iod->nents,\n\t\t\t\t     rq_dma_dir(req), DMA_ATTR_NO_WARN);\n\tif (!nr_mapped)\n\t\tgoto out_free_sg;\n\n\tret = apple_nvme_setup_prps(anv, req, &cmnd->rw);\n\tif (ret != BLK_STS_OK)\n\t\tgoto out_unmap_sg;\n\treturn BLK_STS_OK;\n\nout_unmap_sg:\n\tdma_unmap_sg(anv->dev, iod->sg, iod->nents, rq_dma_dir(req));\nout_free_sg:\n\tmempool_free(iod->sg, anv->iod_mempool);\n\treturn ret;\n}\n\nstatic __always_inline void apple_nvme_unmap_rq(struct request *req)\n{\n\tstruct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);\n\tstruct apple_nvme *anv = queue_to_apple_nvme(iod->q);\n\n\tif (blk_rq_nr_phys_segments(req))\n\t\tapple_nvme_unmap_data(anv, req);\n}\n\nstatic void apple_nvme_complete_rq(struct request *req)\n{\n\tapple_nvme_unmap_rq(req);\n\tnvme_complete_rq(req);\n}\n\nstatic void apple_nvme_complete_batch(struct io_comp_batch *iob)\n{\n\tnvme_complete_batch(iob, apple_nvme_unmap_rq);\n}\n\nstatic inline bool apple_nvme_cqe_pending(struct apple_nvme_queue *q)\n{\n\tstruct nvme_completion *hcqe = &q->cqes[q->cq_head];\n\n\treturn (le16_to_cpu(READ_ONCE(hcqe->status)) & 1) == q->cq_phase;\n}\n\nstatic inline struct blk_mq_tags *\napple_nvme_queue_tagset(struct apple_nvme *anv, struct apple_nvme_queue *q)\n{\n\tif (q->is_adminq)\n\t\treturn anv->admin_tagset.tags[0];\n\telse\n\t\treturn anv->tagset.tags[0];\n}\n\nstatic inline void apple_nvme_handle_cqe(struct apple_nvme_queue *q,\n\t\t\t\t\t struct io_comp_batch *iob, u16 idx)\n{\n\tstruct apple_nvme *anv = queue_to_apple_nvme(q);\n\tstruct nvme_completion *cqe = &q->cqes[idx];\n\t__u16 command_id = READ_ONCE(cqe->command_id);\n\tstruct request *req;\n\n\tapple_nvmmu_inval(q, command_id);\n\n\treq = nvme_find_rq(apple_nvme_queue_tagset(anv, q), command_id);\n\tif (unlikely(!req)) {\n\t\tdev_warn(anv->dev, \"invalid id %d completed\", command_id);\n\t\treturn;\n\t}\n\n\tif (!nvme_try_complete_req(req, cqe->status, cqe->result) &&\n\t    !blk_mq_add_to_batch(req, iob, nvme_req(req)->status,\n\t\t\t\t apple_nvme_complete_batch))\n\t\tapple_nvme_complete_rq(req);\n}\n\nstatic inline void apple_nvme_update_cq_head(struct apple_nvme_queue *q)\n{\n\tu32 tmp = q->cq_head + 1;\n\n\tif (tmp == apple_nvme_queue_depth(q)) {\n\t\tq->cq_head = 0;\n\t\tq->cq_phase ^= 1;\n\t} else {\n\t\tq->cq_head = tmp;\n\t}\n}\n\nstatic bool apple_nvme_poll_cq(struct apple_nvme_queue *q,\n\t\t\t       struct io_comp_batch *iob)\n{\n\tbool found = false;\n\n\twhile (apple_nvme_cqe_pending(q)) {\n\t\tfound = true;\n\n\t\t \n\t\tdma_rmb();\n\t\tapple_nvme_handle_cqe(q, iob, q->cq_head);\n\t\tapple_nvme_update_cq_head(q);\n\t}\n\n\tif (found)\n\t\twritel(q->cq_head, q->cq_db);\n\n\treturn found;\n}\n\nstatic bool apple_nvme_handle_cq(struct apple_nvme_queue *q, bool force)\n{\n\tbool found;\n\tDEFINE_IO_COMP_BATCH(iob);\n\n\tif (!READ_ONCE(q->enabled) && !force)\n\t\treturn false;\n\n\tfound = apple_nvme_poll_cq(q, &iob);\n\n\tif (!rq_list_empty(iob.req_list))\n\t\tapple_nvme_complete_batch(&iob);\n\n\treturn found;\n}\n\nstatic irqreturn_t apple_nvme_irq(int irq, void *data)\n{\n\tstruct apple_nvme *anv = data;\n\tbool handled = false;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&anv->lock, flags);\n\tif (apple_nvme_handle_cq(&anv->ioq, false))\n\t\thandled = true;\n\tif (apple_nvme_handle_cq(&anv->adminq, false))\n\t\thandled = true;\n\tspin_unlock_irqrestore(&anv->lock, flags);\n\n\tif (handled)\n\t\treturn IRQ_HANDLED;\n\treturn IRQ_NONE;\n}\n\nstatic int apple_nvme_create_cq(struct apple_nvme *anv)\n{\n\tstruct nvme_command c = {};\n\n\t \n\tc.create_cq.opcode = nvme_admin_create_cq;\n\tc.create_cq.prp1 = cpu_to_le64(anv->ioq.cq_dma_addr);\n\tc.create_cq.cqid = cpu_to_le16(1);\n\tc.create_cq.qsize = cpu_to_le16(APPLE_ANS_MAX_QUEUE_DEPTH - 1);\n\tc.create_cq.cq_flags = cpu_to_le16(NVME_QUEUE_PHYS_CONTIG | NVME_CQ_IRQ_ENABLED);\n\tc.create_cq.irq_vector = cpu_to_le16(0);\n\n\treturn nvme_submit_sync_cmd(anv->ctrl.admin_q, &c, NULL, 0);\n}\n\nstatic int apple_nvme_remove_cq(struct apple_nvme *anv)\n{\n\tstruct nvme_command c = {};\n\n\tc.delete_queue.opcode = nvme_admin_delete_cq;\n\tc.delete_queue.qid = cpu_to_le16(1);\n\n\treturn nvme_submit_sync_cmd(anv->ctrl.admin_q, &c, NULL, 0);\n}\n\nstatic int apple_nvme_create_sq(struct apple_nvme *anv)\n{\n\tstruct nvme_command c = {};\n\n\t \n\tc.create_sq.opcode = nvme_admin_create_sq;\n\tc.create_sq.prp1 = cpu_to_le64(anv->ioq.sq_dma_addr);\n\tc.create_sq.sqid = cpu_to_le16(1);\n\tc.create_sq.qsize = cpu_to_le16(APPLE_ANS_MAX_QUEUE_DEPTH - 1);\n\tc.create_sq.sq_flags = cpu_to_le16(NVME_QUEUE_PHYS_CONTIG);\n\tc.create_sq.cqid = cpu_to_le16(1);\n\n\treturn nvme_submit_sync_cmd(anv->ctrl.admin_q, &c, NULL, 0);\n}\n\nstatic int apple_nvme_remove_sq(struct apple_nvme *anv)\n{\n\tstruct nvme_command c = {};\n\n\tc.delete_queue.opcode = nvme_admin_delete_sq;\n\tc.delete_queue.qid = cpu_to_le16(1);\n\n\treturn nvme_submit_sync_cmd(anv->ctrl.admin_q, &c, NULL, 0);\n}\n\nstatic blk_status_t apple_nvme_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t\tconst struct blk_mq_queue_data *bd)\n{\n\tstruct nvme_ns *ns = hctx->queue->queuedata;\n\tstruct apple_nvme_queue *q = hctx->driver_data;\n\tstruct apple_nvme *anv = queue_to_apple_nvme(q);\n\tstruct request *req = bd->rq;\n\tstruct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);\n\tstruct nvme_command *cmnd = &iod->cmd;\n\tblk_status_t ret;\n\n\tiod->npages = -1;\n\tiod->nents = 0;\n\n\t \n\tif (unlikely(!READ_ONCE(q->enabled)))\n\t\treturn BLK_STS_IOERR;\n\n\tif (!nvme_check_ready(&anv->ctrl, req, true))\n\t\treturn nvme_fail_nonready_command(&anv->ctrl, req);\n\n\tret = nvme_setup_cmd(ns, req);\n\tif (ret)\n\t\treturn ret;\n\n\tif (blk_rq_nr_phys_segments(req)) {\n\t\tret = apple_nvme_map_data(anv, req, cmnd);\n\t\tif (ret)\n\t\t\tgoto out_free_cmd;\n\t}\n\n\tnvme_start_request(req);\n\tapple_nvme_submit_cmd(q, cmnd);\n\treturn BLK_STS_OK;\n\nout_free_cmd:\n\tnvme_cleanup_cmd(req);\n\treturn ret;\n}\n\nstatic int apple_nvme_init_hctx(struct blk_mq_hw_ctx *hctx, void *data,\n\t\t\t\tunsigned int hctx_idx)\n{\n\thctx->driver_data = data;\n\treturn 0;\n}\n\nstatic int apple_nvme_init_request(struct blk_mq_tag_set *set,\n\t\t\t\t   struct request *req, unsigned int hctx_idx,\n\t\t\t\t   unsigned int numa_node)\n{\n\tstruct apple_nvme_queue *q = set->driver_data;\n\tstruct apple_nvme *anv = queue_to_apple_nvme(q);\n\tstruct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);\n\tstruct nvme_request *nreq = nvme_req(req);\n\n\tiod->q = q;\n\tnreq->ctrl = &anv->ctrl;\n\tnreq->cmd = &iod->cmd;\n\n\treturn 0;\n}\n\nstatic void apple_nvme_disable(struct apple_nvme *anv, bool shutdown)\n{\n\tu32 csts = readl(anv->mmio_nvme + NVME_REG_CSTS);\n\tbool dead = false, freeze = false;\n\tunsigned long flags;\n\n\tif (apple_rtkit_is_crashed(anv->rtk))\n\t\tdead = true;\n\tif (!(csts & NVME_CSTS_RDY))\n\t\tdead = true;\n\tif (csts & NVME_CSTS_CFS)\n\t\tdead = true;\n\n\tif (anv->ctrl.state == NVME_CTRL_LIVE ||\n\t    anv->ctrl.state == NVME_CTRL_RESETTING) {\n\t\tfreeze = true;\n\t\tnvme_start_freeze(&anv->ctrl);\n\t}\n\n\t \n\tif (!dead && shutdown && freeze)\n\t\tnvme_wait_freeze_timeout(&anv->ctrl, NVME_IO_TIMEOUT);\n\n\tnvme_quiesce_io_queues(&anv->ctrl);\n\n\tif (!dead) {\n\t\tif (READ_ONCE(anv->ioq.enabled)) {\n\t\t\tapple_nvme_remove_sq(anv);\n\t\t\tapple_nvme_remove_cq(anv);\n\t\t}\n\n\t\t \n\t\tif (shutdown)\n\t\t\tnvme_disable_ctrl(&anv->ctrl, shutdown);\n\t\tnvme_disable_ctrl(&anv->ctrl, false);\n\t}\n\n\tWRITE_ONCE(anv->ioq.enabled, false);\n\tWRITE_ONCE(anv->adminq.enabled, false);\n\tmb();  \n\tnvme_quiesce_admin_queue(&anv->ctrl);\n\n\t \n\tspin_lock_irqsave(&anv->lock, flags);\n\tapple_nvme_handle_cq(&anv->ioq, true);\n\tapple_nvme_handle_cq(&anv->adminq, true);\n\tspin_unlock_irqrestore(&anv->lock, flags);\n\n\tnvme_cancel_tagset(&anv->ctrl);\n\tnvme_cancel_admin_tagset(&anv->ctrl);\n\n\t \n\tif (shutdown) {\n\t\tnvme_unquiesce_io_queues(&anv->ctrl);\n\t\tnvme_unquiesce_admin_queue(&anv->ctrl);\n\t}\n}\n\nstatic enum blk_eh_timer_return apple_nvme_timeout(struct request *req)\n{\n\tstruct apple_nvme_iod *iod = blk_mq_rq_to_pdu(req);\n\tstruct apple_nvme_queue *q = iod->q;\n\tstruct apple_nvme *anv = queue_to_apple_nvme(q);\n\tunsigned long flags;\n\tu32 csts = readl(anv->mmio_nvme + NVME_REG_CSTS);\n\n\tif (anv->ctrl.state != NVME_CTRL_LIVE) {\n\t\t \n\t\tdev_warn(anv->dev,\n\t\t\t \"I/O %d(aq:%d) timeout while not in live state\\n\",\n\t\t\t req->tag, q->is_adminq);\n\t\tif (blk_mq_request_started(req) &&\n\t\t    !blk_mq_request_completed(req)) {\n\t\t\tnvme_req(req)->status = NVME_SC_HOST_ABORTED_CMD;\n\t\t\tnvme_req(req)->flags |= NVME_REQ_CANCELLED;\n\t\t\tblk_mq_complete_request(req);\n\t\t}\n\t\treturn BLK_EH_DONE;\n\t}\n\n\t \n\tif (!apple_rtkit_is_crashed(anv->rtk) && !(csts & NVME_CSTS_CFS)) {\n\t\tspin_lock_irqsave(&anv->lock, flags);\n\t\tapple_nvme_handle_cq(q, false);\n\t\tspin_unlock_irqrestore(&anv->lock, flags);\n\t\tif (blk_mq_request_completed(req)) {\n\t\t\tdev_warn(anv->dev,\n\t\t\t\t \"I/O %d(aq:%d) timeout: completion polled\\n\",\n\t\t\t\t req->tag, q->is_adminq);\n\t\t\treturn BLK_EH_DONE;\n\t\t}\n\t}\n\n\t \n\tdev_warn(anv->dev, \"I/O %d(aq:%d) timeout: resetting controller\\n\",\n\t\t req->tag, q->is_adminq);\n\tnvme_req(req)->flags |= NVME_REQ_CANCELLED;\n\tapple_nvme_disable(anv, false);\n\tnvme_reset_ctrl(&anv->ctrl);\n\treturn BLK_EH_DONE;\n}\n\nstatic int apple_nvme_poll(struct blk_mq_hw_ctx *hctx,\n\t\t\t   struct io_comp_batch *iob)\n{\n\tstruct apple_nvme_queue *q = hctx->driver_data;\n\tstruct apple_nvme *anv = queue_to_apple_nvme(q);\n\tbool found;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&anv->lock, flags);\n\tfound = apple_nvme_poll_cq(q, iob);\n\tspin_unlock_irqrestore(&anv->lock, flags);\n\n\treturn found;\n}\n\nstatic const struct blk_mq_ops apple_nvme_mq_admin_ops = {\n\t.queue_rq = apple_nvme_queue_rq,\n\t.complete = apple_nvme_complete_rq,\n\t.init_hctx = apple_nvme_init_hctx,\n\t.init_request = apple_nvme_init_request,\n\t.timeout = apple_nvme_timeout,\n};\n\nstatic const struct blk_mq_ops apple_nvme_mq_ops = {\n\t.queue_rq = apple_nvme_queue_rq,\n\t.complete = apple_nvme_complete_rq,\n\t.init_hctx = apple_nvme_init_hctx,\n\t.init_request = apple_nvme_init_request,\n\t.timeout = apple_nvme_timeout,\n\t.poll = apple_nvme_poll,\n};\n\nstatic void apple_nvme_init_queue(struct apple_nvme_queue *q)\n{\n\tunsigned int depth = apple_nvme_queue_depth(q);\n\n\tq->cq_head = 0;\n\tq->cq_phase = 1;\n\tmemset(q->tcbs, 0,\n\t       APPLE_ANS_MAX_QUEUE_DEPTH * sizeof(struct apple_nvmmu_tcb));\n\tmemset(q->cqes, 0, depth * sizeof(struct nvme_completion));\n\tWRITE_ONCE(q->enabled, true);\n\twmb();  \n}\n\nstatic void apple_nvme_reset_work(struct work_struct *work)\n{\n\tunsigned int nr_io_queues = 1;\n\tint ret;\n\tu32 boot_status, aqa;\n\tstruct apple_nvme *anv =\n\t\tcontainer_of(work, struct apple_nvme, ctrl.reset_work);\n\n\tif (anv->ctrl.state != NVME_CTRL_RESETTING) {\n\t\tdev_warn(anv->dev, \"ctrl state %d is not RESETTING\\n\",\n\t\t\t anv->ctrl.state);\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tif (apple_rtkit_is_crashed(anv->rtk)) {\n\t\tdev_err(anv->dev,\n\t\t\t\"RTKit has crashed without any way to recover.\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tif (apple_rtkit_is_running(anv->rtk)) {\n\t\t \n\t\tif (anv->ctrl.ctrl_config & NVME_CC_ENABLE)\n\t\t\tapple_nvme_disable(anv, false);\n\t\tdev_dbg(anv->dev, \"Trying to shut down RTKit before reset.\");\n\t\tret = apple_rtkit_shutdown(anv->rtk);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\twritel(0, anv->mmio_coproc + APPLE_ANS_COPROC_CPU_CONTROL);\n\n\tret = reset_control_assert(anv->reset);\n\tif (ret)\n\t\tgoto out;\n\n\tret = apple_rtkit_reinit(anv->rtk);\n\tif (ret)\n\t\tgoto out;\n\n\tret = reset_control_deassert(anv->reset);\n\tif (ret)\n\t\tgoto out;\n\n\twritel(APPLE_ANS_COPROC_CPU_CONTROL_RUN,\n\t       anv->mmio_coproc + APPLE_ANS_COPROC_CPU_CONTROL);\n\tret = apple_rtkit_boot(anv->rtk);\n\tif (ret) {\n\t\tdev_err(anv->dev, \"ANS did not boot\");\n\t\tgoto out;\n\t}\n\n\tret = readl_poll_timeout(anv->mmio_nvme + APPLE_ANS_BOOT_STATUS,\n\t\t\t\t boot_status,\n\t\t\t\t boot_status == APPLE_ANS_BOOT_STATUS_OK,\n\t\t\t\t USEC_PER_MSEC, APPLE_ANS_BOOT_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(anv->dev, \"ANS did not initialize\");\n\t\tgoto out;\n\t}\n\n\tdev_dbg(anv->dev, \"ANS booted successfully.\");\n\n\t \n\tanv->ctrl.max_hw_sectors = min_t(u32, NVME_MAX_KB_SZ << 1,\n\t\t\t\t\t dma_max_mapping_size(anv->dev) >> 9);\n\tanv->ctrl.max_segments = NVME_MAX_SEGS;\n\n\tdma_set_max_seg_size(anv->dev, 0xffffffff);\n\n\t \n\twritel(APPLE_ANS_LINEAR_SQ_EN,\n\t       anv->mmio_nvme + APPLE_ANS_LINEAR_SQ_CTRL);\n\n\t \n\twritel(APPLE_ANS_MAX_QUEUE_DEPTH | (APPLE_ANS_MAX_QUEUE_DEPTH << 16),\n\t       anv->mmio_nvme + APPLE_ANS_MAX_PEND_CMDS_CTRL);\n\n\t \n\twritel(APPLE_ANS_MAX_QUEUE_DEPTH - 1,\n\t       anv->mmio_nvme + APPLE_NVMMU_NUM_TCBS);\n\n\t \n\twritel(readl(anv->mmio_nvme + APPLE_ANS_UNKNOWN_CTRL) &\n\t\t       ~APPLE_ANS_PRP_NULL_CHECK,\n\t       anv->mmio_nvme + APPLE_ANS_UNKNOWN_CTRL);\n\n\t \n\taqa = APPLE_NVME_AQ_DEPTH - 1;\n\taqa |= aqa << 16;\n\twritel(aqa, anv->mmio_nvme + NVME_REG_AQA);\n\twriteq(anv->adminq.sq_dma_addr, anv->mmio_nvme + NVME_REG_ASQ);\n\twriteq(anv->adminq.cq_dma_addr, anv->mmio_nvme + NVME_REG_ACQ);\n\n\t \n\twriteq(anv->adminq.tcb_dma_addr,\n\t       anv->mmio_nvme + APPLE_NVMMU_ASQ_TCB_BASE);\n\twriteq(anv->ioq.tcb_dma_addr,\n\t       anv->mmio_nvme + APPLE_NVMMU_IOSQ_TCB_BASE);\n\n\tanv->ctrl.sqsize =\n\t\tAPPLE_ANS_MAX_QUEUE_DEPTH - 1;  \n\tanv->ctrl.cap = readq(anv->mmio_nvme + NVME_REG_CAP);\n\n\tdev_dbg(anv->dev, \"Enabling controller now\");\n\tret = nvme_enable_ctrl(&anv->ctrl);\n\tif (ret)\n\t\tgoto out;\n\n\tdev_dbg(anv->dev, \"Starting admin queue\");\n\tapple_nvme_init_queue(&anv->adminq);\n\tnvme_unquiesce_admin_queue(&anv->ctrl);\n\n\tif (!nvme_change_ctrl_state(&anv->ctrl, NVME_CTRL_CONNECTING)) {\n\t\tdev_warn(anv->ctrl.device,\n\t\t\t \"failed to mark controller CONNECTING\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tret = nvme_init_ctrl_finish(&anv->ctrl, false);\n\tif (ret)\n\t\tgoto out;\n\n\tdev_dbg(anv->dev, \"Creating IOCQ\");\n\tret = apple_nvme_create_cq(anv);\n\tif (ret)\n\t\tgoto out;\n\tdev_dbg(anv->dev, \"Creating IOSQ\");\n\tret = apple_nvme_create_sq(anv);\n\tif (ret)\n\t\tgoto out_remove_cq;\n\n\tapple_nvme_init_queue(&anv->ioq);\n\tnr_io_queues = 1;\n\tret = nvme_set_queue_count(&anv->ctrl, &nr_io_queues);\n\tif (ret)\n\t\tgoto out_remove_sq;\n\tif (nr_io_queues != 1) {\n\t\tret = -ENXIO;\n\t\tgoto out_remove_sq;\n\t}\n\n\tanv->ctrl.queue_count = nr_io_queues + 1;\n\n\tnvme_unquiesce_io_queues(&anv->ctrl);\n\tnvme_wait_freeze(&anv->ctrl);\n\tblk_mq_update_nr_hw_queues(&anv->tagset, 1);\n\tnvme_unfreeze(&anv->ctrl);\n\n\tif (!nvme_change_ctrl_state(&anv->ctrl, NVME_CTRL_LIVE)) {\n\t\tdev_warn(anv->ctrl.device,\n\t\t\t \"failed to mark controller live state\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_remove_sq;\n\t}\n\n\tnvme_start_ctrl(&anv->ctrl);\n\n\tdev_dbg(anv->dev, \"ANS boot and NVMe init completed.\");\n\treturn;\n\nout_remove_sq:\n\tapple_nvme_remove_sq(anv);\nout_remove_cq:\n\tapple_nvme_remove_cq(anv);\nout:\n\tdev_warn(anv->ctrl.device, \"Reset failure status: %d\\n\", ret);\n\tnvme_change_ctrl_state(&anv->ctrl, NVME_CTRL_DELETING);\n\tnvme_get_ctrl(&anv->ctrl);\n\tapple_nvme_disable(anv, false);\n\tnvme_mark_namespaces_dead(&anv->ctrl);\n\tif (!queue_work(nvme_wq, &anv->remove_work))\n\t\tnvme_put_ctrl(&anv->ctrl);\n}\n\nstatic void apple_nvme_remove_dead_ctrl_work(struct work_struct *work)\n{\n\tstruct apple_nvme *anv =\n\t\tcontainer_of(work, struct apple_nvme, remove_work);\n\n\tnvme_put_ctrl(&anv->ctrl);\n\tdevice_release_driver(anv->dev);\n}\n\nstatic int apple_nvme_reg_read32(struct nvme_ctrl *ctrl, u32 off, u32 *val)\n{\n\t*val = readl(ctrl_to_apple_nvme(ctrl)->mmio_nvme + off);\n\treturn 0;\n}\n\nstatic int apple_nvme_reg_write32(struct nvme_ctrl *ctrl, u32 off, u32 val)\n{\n\twritel(val, ctrl_to_apple_nvme(ctrl)->mmio_nvme + off);\n\treturn 0;\n}\n\nstatic int apple_nvme_reg_read64(struct nvme_ctrl *ctrl, u32 off, u64 *val)\n{\n\t*val = readq(ctrl_to_apple_nvme(ctrl)->mmio_nvme + off);\n\treturn 0;\n}\n\nstatic int apple_nvme_get_address(struct nvme_ctrl *ctrl, char *buf, int size)\n{\n\tstruct device *dev = ctrl_to_apple_nvme(ctrl)->dev;\n\n\treturn snprintf(buf, size, \"%s\\n\", dev_name(dev));\n}\n\nstatic void apple_nvme_free_ctrl(struct nvme_ctrl *ctrl)\n{\n\tstruct apple_nvme *anv = ctrl_to_apple_nvme(ctrl);\n\n\tif (anv->ctrl.admin_q)\n\t\tblk_put_queue(anv->ctrl.admin_q);\n\tput_device(anv->dev);\n}\n\nstatic const struct nvme_ctrl_ops nvme_ctrl_ops = {\n\t.name = \"apple-nvme\",\n\t.module = THIS_MODULE,\n\t.flags = 0,\n\t.reg_read32 = apple_nvme_reg_read32,\n\t.reg_write32 = apple_nvme_reg_write32,\n\t.reg_read64 = apple_nvme_reg_read64,\n\t.free_ctrl = apple_nvme_free_ctrl,\n\t.get_address = apple_nvme_get_address,\n};\n\nstatic void apple_nvme_async_probe(void *data, async_cookie_t cookie)\n{\n\tstruct apple_nvme *anv = data;\n\n\tflush_work(&anv->ctrl.reset_work);\n\tflush_work(&anv->ctrl.scan_work);\n\tnvme_put_ctrl(&anv->ctrl);\n}\n\nstatic void devm_apple_nvme_put_tag_set(void *data)\n{\n\tblk_mq_free_tag_set(data);\n}\n\nstatic int apple_nvme_alloc_tagsets(struct apple_nvme *anv)\n{\n\tint ret;\n\n\tanv->admin_tagset.ops = &apple_nvme_mq_admin_ops;\n\tanv->admin_tagset.nr_hw_queues = 1;\n\tanv->admin_tagset.queue_depth = APPLE_NVME_AQ_MQ_TAG_DEPTH;\n\tanv->admin_tagset.timeout = NVME_ADMIN_TIMEOUT;\n\tanv->admin_tagset.numa_node = NUMA_NO_NODE;\n\tanv->admin_tagset.cmd_size = sizeof(struct apple_nvme_iod);\n\tanv->admin_tagset.flags = BLK_MQ_F_NO_SCHED;\n\tanv->admin_tagset.driver_data = &anv->adminq;\n\n\tret = blk_mq_alloc_tag_set(&anv->admin_tagset);\n\tif (ret)\n\t\treturn ret;\n\tret = devm_add_action_or_reset(anv->dev, devm_apple_nvme_put_tag_set,\n\t\t\t\t       &anv->admin_tagset);\n\tif (ret)\n\t\treturn ret;\n\n\tanv->tagset.ops = &apple_nvme_mq_ops;\n\tanv->tagset.nr_hw_queues = 1;\n\tanv->tagset.nr_maps = 1;\n\t \n\tanv->tagset.reserved_tags = APPLE_NVME_AQ_DEPTH;\n\tanv->tagset.queue_depth = APPLE_ANS_MAX_QUEUE_DEPTH - 1;\n\tanv->tagset.timeout = NVME_IO_TIMEOUT;\n\tanv->tagset.numa_node = NUMA_NO_NODE;\n\tanv->tagset.cmd_size = sizeof(struct apple_nvme_iod);\n\tanv->tagset.flags = BLK_MQ_F_SHOULD_MERGE;\n\tanv->tagset.driver_data = &anv->ioq;\n\n\tret = blk_mq_alloc_tag_set(&anv->tagset);\n\tif (ret)\n\t\treturn ret;\n\tret = devm_add_action_or_reset(anv->dev, devm_apple_nvme_put_tag_set,\n\t\t\t\t\t&anv->tagset);\n\tif (ret)\n\t\treturn ret;\n\n\tanv->ctrl.admin_tagset = &anv->admin_tagset;\n\tanv->ctrl.tagset = &anv->tagset;\n\n\treturn 0;\n}\n\nstatic int apple_nvme_queue_alloc(struct apple_nvme *anv,\n\t\t\t\t  struct apple_nvme_queue *q)\n{\n\tunsigned int depth = apple_nvme_queue_depth(q);\n\n\tq->cqes = dmam_alloc_coherent(anv->dev,\n\t\t\t\t      depth * sizeof(struct nvme_completion),\n\t\t\t\t      &q->cq_dma_addr, GFP_KERNEL);\n\tif (!q->cqes)\n\t\treturn -ENOMEM;\n\n\tq->sqes = dmam_alloc_coherent(anv->dev,\n\t\t\t\t      depth * sizeof(struct nvme_command),\n\t\t\t\t      &q->sq_dma_addr, GFP_KERNEL);\n\tif (!q->sqes)\n\t\treturn -ENOMEM;\n\n\t \n\tq->tcbs = dmam_alloc_coherent(anv->dev,\n\t\t\t\t      APPLE_ANS_MAX_QUEUE_DEPTH *\n\t\t\t\t\t      sizeof(struct apple_nvmmu_tcb),\n\t\t\t\t      &q->tcb_dma_addr, GFP_KERNEL);\n\tif (!q->tcbs)\n\t\treturn -ENOMEM;\n\n\t \n\tq->cq_phase = 1;\n\treturn 0;\n}\n\nstatic void apple_nvme_detach_genpd(struct apple_nvme *anv)\n{\n\tint i;\n\n\tif (anv->pd_count <= 1)\n\t\treturn;\n\n\tfor (i = anv->pd_count - 1; i >= 0; i--) {\n\t\tif (anv->pd_link[i])\n\t\t\tdevice_link_del(anv->pd_link[i]);\n\t\tif (!IS_ERR_OR_NULL(anv->pd_dev[i]))\n\t\t\tdev_pm_domain_detach(anv->pd_dev[i], true);\n\t}\n}\n\nstatic int apple_nvme_attach_genpd(struct apple_nvme *anv)\n{\n\tstruct device *dev = anv->dev;\n\tint i;\n\n\tanv->pd_count = of_count_phandle_with_args(\n\t\tdev->of_node, \"power-domains\", \"#power-domain-cells\");\n\tif (anv->pd_count <= 1)\n\t\treturn 0;\n\n\tanv->pd_dev = devm_kcalloc(dev, anv->pd_count, sizeof(*anv->pd_dev),\n\t\t\t\t   GFP_KERNEL);\n\tif (!anv->pd_dev)\n\t\treturn -ENOMEM;\n\n\tanv->pd_link = devm_kcalloc(dev, anv->pd_count, sizeof(*anv->pd_link),\n\t\t\t\t    GFP_KERNEL);\n\tif (!anv->pd_link)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < anv->pd_count; i++) {\n\t\tanv->pd_dev[i] = dev_pm_domain_attach_by_id(dev, i);\n\t\tif (IS_ERR(anv->pd_dev[i])) {\n\t\t\tapple_nvme_detach_genpd(anv);\n\t\t\treturn PTR_ERR(anv->pd_dev[i]);\n\t\t}\n\n\t\tanv->pd_link[i] = device_link_add(dev, anv->pd_dev[i],\n\t\t\t\t\t\t  DL_FLAG_STATELESS |\n\t\t\t\t\t\t  DL_FLAG_PM_RUNTIME |\n\t\t\t\t\t\t  DL_FLAG_RPM_ACTIVE);\n\t\tif (!anv->pd_link[i]) {\n\t\t\tapple_nvme_detach_genpd(anv);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void devm_apple_nvme_mempool_destroy(void *data)\n{\n\tmempool_destroy(data);\n}\n\nstatic int apple_nvme_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct apple_nvme *anv;\n\tint ret;\n\n\tanv = devm_kzalloc(dev, sizeof(*anv), GFP_KERNEL);\n\tif (!anv)\n\t\treturn -ENOMEM;\n\n\tanv->dev = get_device(dev);\n\tanv->adminq.is_adminq = true;\n\tplatform_set_drvdata(pdev, anv);\n\n\tret = apple_nvme_attach_genpd(anv);\n\tif (ret < 0) {\n\t\tdev_err_probe(dev, ret, \"Failed to attach power domains\");\n\t\tgoto put_dev;\n\t}\n\tif (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64))) {\n\t\tret = -ENXIO;\n\t\tgoto put_dev;\n\t}\n\n\tanv->irq = platform_get_irq(pdev, 0);\n\tif (anv->irq < 0) {\n\t\tret = anv->irq;\n\t\tgoto put_dev;\n\t}\n\tif (!anv->irq) {\n\t\tret = -ENXIO;\n\t\tgoto put_dev;\n\t}\n\n\tanv->mmio_coproc = devm_platform_ioremap_resource_byname(pdev, \"ans\");\n\tif (IS_ERR(anv->mmio_coproc)) {\n\t\tret = PTR_ERR(anv->mmio_coproc);\n\t\tgoto put_dev;\n\t}\n\tanv->mmio_nvme = devm_platform_ioremap_resource_byname(pdev, \"nvme\");\n\tif (IS_ERR(anv->mmio_nvme)) {\n\t\tret = PTR_ERR(anv->mmio_nvme);\n\t\tgoto put_dev;\n\t}\n\n\tanv->adminq.sq_db = anv->mmio_nvme + APPLE_ANS_LINEAR_ASQ_DB;\n\tanv->adminq.cq_db = anv->mmio_nvme + APPLE_ANS_ACQ_DB;\n\tanv->ioq.sq_db = anv->mmio_nvme + APPLE_ANS_LINEAR_IOSQ_DB;\n\tanv->ioq.cq_db = anv->mmio_nvme + APPLE_ANS_IOCQ_DB;\n\n\tanv->sart = devm_apple_sart_get(dev);\n\tif (IS_ERR(anv->sart)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(anv->sart),\n\t\t\t\t    \"Failed to initialize SART\");\n\t\tgoto put_dev;\n\t}\n\n\tanv->reset = devm_reset_control_array_get_exclusive(anv->dev);\n\tif (IS_ERR(anv->reset)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(anv->reset),\n\t\t\t\t    \"Failed to get reset control\");\n\t\tgoto put_dev;\n\t}\n\n\tINIT_WORK(&anv->ctrl.reset_work, apple_nvme_reset_work);\n\tINIT_WORK(&anv->remove_work, apple_nvme_remove_dead_ctrl_work);\n\tspin_lock_init(&anv->lock);\n\n\tret = apple_nvme_queue_alloc(anv, &anv->adminq);\n\tif (ret)\n\t\tgoto put_dev;\n\tret = apple_nvme_queue_alloc(anv, &anv->ioq);\n\tif (ret)\n\t\tgoto put_dev;\n\n\tanv->prp_page_pool = dmam_pool_create(\"prp list page\", anv->dev,\n\t\t\t\t\t      NVME_CTRL_PAGE_SIZE,\n\t\t\t\t\t      NVME_CTRL_PAGE_SIZE, 0);\n\tif (!anv->prp_page_pool) {\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\n\tanv->prp_small_pool =\n\t\tdmam_pool_create(\"prp list 256\", anv->dev, 256, 256, 0);\n\tif (!anv->prp_small_pool) {\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\n\tWARN_ON_ONCE(apple_nvme_iod_alloc_size() > PAGE_SIZE);\n\tanv->iod_mempool =\n\t\tmempool_create_kmalloc_pool(1, apple_nvme_iod_alloc_size());\n\tif (!anv->iod_mempool) {\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\tret = devm_add_action_or_reset(anv->dev,\n\t\t\tdevm_apple_nvme_mempool_destroy, anv->iod_mempool);\n\tif (ret)\n\t\tgoto put_dev;\n\n\tret = apple_nvme_alloc_tagsets(anv);\n\tif (ret)\n\t\tgoto put_dev;\n\n\tret = devm_request_irq(anv->dev, anv->irq, apple_nvme_irq, 0,\n\t\t\t       \"nvme-apple\", anv);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"Failed to request IRQ\");\n\t\tgoto put_dev;\n\t}\n\n\tanv->rtk =\n\t\tdevm_apple_rtkit_init(dev, anv, NULL, 0, &apple_nvme_rtkit_ops);\n\tif (IS_ERR(anv->rtk)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(anv->rtk),\n\t\t\t\t    \"Failed to initialize RTKit\");\n\t\tgoto put_dev;\n\t}\n\n\tret = nvme_init_ctrl(&anv->ctrl, anv->dev, &nvme_ctrl_ops,\n\t\t\t     NVME_QUIRK_SKIP_CID_GEN | NVME_QUIRK_IDENTIFY_CNS);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"Failed to initialize nvme_ctrl\");\n\t\tgoto put_dev;\n\t}\n\n\tanv->ctrl.admin_q = blk_mq_init_queue(&anv->admin_tagset);\n\tif (IS_ERR(anv->ctrl.admin_q)) {\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\n\tnvme_reset_ctrl(&anv->ctrl);\n\tasync_schedule(apple_nvme_async_probe, anv);\n\n\treturn 0;\n\nput_dev:\n\tput_device(anv->dev);\n\treturn ret;\n}\n\nstatic int apple_nvme_remove(struct platform_device *pdev)\n{\n\tstruct apple_nvme *anv = platform_get_drvdata(pdev);\n\n\tnvme_change_ctrl_state(&anv->ctrl, NVME_CTRL_DELETING);\n\tflush_work(&anv->ctrl.reset_work);\n\tnvme_stop_ctrl(&anv->ctrl);\n\tnvme_remove_namespaces(&anv->ctrl);\n\tapple_nvme_disable(anv, true);\n\tnvme_uninit_ctrl(&anv->ctrl);\n\n\tif (apple_rtkit_is_running(anv->rtk))\n\t\tapple_rtkit_shutdown(anv->rtk);\n\n\tapple_nvme_detach_genpd(anv);\n\n\treturn 0;\n}\n\nstatic void apple_nvme_shutdown(struct platform_device *pdev)\n{\n\tstruct apple_nvme *anv = platform_get_drvdata(pdev);\n\n\tapple_nvme_disable(anv, true);\n\tif (apple_rtkit_is_running(anv->rtk))\n\t\tapple_rtkit_shutdown(anv->rtk);\n}\n\nstatic int apple_nvme_resume(struct device *dev)\n{\n\tstruct apple_nvme *anv = dev_get_drvdata(dev);\n\n\treturn nvme_reset_ctrl(&anv->ctrl);\n}\n\nstatic int apple_nvme_suspend(struct device *dev)\n{\n\tstruct apple_nvme *anv = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tapple_nvme_disable(anv, true);\n\n\tif (apple_rtkit_is_running(anv->rtk))\n\t\tret = apple_rtkit_shutdown(anv->rtk);\n\n\twritel(0, anv->mmio_coproc + APPLE_ANS_COPROC_CPU_CONTROL);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(apple_nvme_pm_ops, apple_nvme_suspend,\n\t\t\t\tapple_nvme_resume);\n\nstatic const struct of_device_id apple_nvme_of_match[] = {\n\t{ .compatible = \"apple,nvme-ans2\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, apple_nvme_of_match);\n\nstatic struct platform_driver apple_nvme_driver = {\n\t.driver = {\n\t\t.name = \"nvme-apple\",\n\t\t.of_match_table = apple_nvme_of_match,\n\t\t.pm = pm_sleep_ptr(&apple_nvme_pm_ops),\n\t},\n\t.probe = apple_nvme_probe,\n\t.remove = apple_nvme_remove,\n\t.shutdown = apple_nvme_shutdown,\n};\nmodule_platform_driver(apple_nvme_driver);\n\nMODULE_AUTHOR(\"Sven Peter <sven@svenpeter.dev>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}