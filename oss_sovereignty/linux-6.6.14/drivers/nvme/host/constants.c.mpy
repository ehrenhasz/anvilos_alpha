{
  "module_name": "constants.c",
  "hash_id": "788ffe07417a6b2a08b80a1e3b807c99148472651f07659c9f91aa16749d57e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/host/constants.c",
  "human_readable_source": "\n \n\n#include \"nvme.h\"\n\nstatic const char * const nvme_ops[] = {\n\t[nvme_cmd_flush] = \"Flush\",\n\t[nvme_cmd_write] = \"Write\",\n\t[nvme_cmd_read] = \"Read\",\n\t[nvme_cmd_write_uncor] = \"Write Uncorrectable\",\n\t[nvme_cmd_compare] = \"Compare\",\n\t[nvme_cmd_write_zeroes] = \"Write Zeroes\",\n\t[nvme_cmd_dsm] = \"Dataset Management\",\n\t[nvme_cmd_verify] = \"Verify\",\n\t[nvme_cmd_resv_register] = \"Reservation Register\",\n\t[nvme_cmd_resv_report] = \"Reservation Report\",\n\t[nvme_cmd_resv_acquire] = \"Reservation Acquire\",\n\t[nvme_cmd_resv_release] = \"Reservation Release\",\n\t[nvme_cmd_zone_mgmt_send] = \"Zone Management Send\",\n\t[nvme_cmd_zone_mgmt_recv] = \"Zone Management Receive\",\n\t[nvme_cmd_zone_append] = \"Zone Append\",\n};\n\nstatic const char * const nvme_admin_ops[] = {\n\t[nvme_admin_delete_sq] = \"Delete SQ\",\n\t[nvme_admin_create_sq] = \"Create SQ\",\n\t[nvme_admin_get_log_page] = \"Get Log Page\",\n\t[nvme_admin_delete_cq] = \"Delete CQ\",\n\t[nvme_admin_create_cq] = \"Create CQ\",\n\t[nvme_admin_identify] = \"Identify\",\n\t[nvme_admin_abort_cmd] = \"Abort Command\",\n\t[nvme_admin_set_features] = \"Set Features\",\n\t[nvme_admin_get_features] = \"Get Features\",\n\t[nvme_admin_async_event] = \"Async Event\",\n\t[nvme_admin_ns_mgmt] = \"Namespace Management\",\n\t[nvme_admin_activate_fw] = \"Activate Firmware\",\n\t[nvme_admin_download_fw] = \"Download Firmware\",\n\t[nvme_admin_dev_self_test] = \"Device Self Test\",\n\t[nvme_admin_ns_attach] = \"Namespace Attach\",\n\t[nvme_admin_keep_alive] = \"Keep Alive\",\n\t[nvme_admin_directive_send] = \"Directive Send\",\n\t[nvme_admin_directive_recv] = \"Directive Receive\",\n\t[nvme_admin_virtual_mgmt] = \"Virtual Management\",\n\t[nvme_admin_nvme_mi_send] = \"NVMe Send MI\",\n\t[nvme_admin_nvme_mi_recv] = \"NVMe Receive MI\",\n\t[nvme_admin_dbbuf] = \"Doorbell Buffer Config\",\n\t[nvme_admin_format_nvm] = \"Format NVM\",\n\t[nvme_admin_security_send] = \"Security Send\",\n\t[nvme_admin_security_recv] = \"Security Receive\",\n\t[nvme_admin_sanitize_nvm] = \"Sanitize NVM\",\n\t[nvme_admin_get_lba_status] = \"Get LBA Status\",\n};\n\nstatic const char * const nvme_fabrics_ops[] = {\n\t[nvme_fabrics_type_property_set] = \"Property Set\",\n\t[nvme_fabrics_type_property_get] = \"Property Get\",\n\t[nvme_fabrics_type_connect] = \"Connect\",\n\t[nvme_fabrics_type_auth_send] = \"Authentication Send\",\n\t[nvme_fabrics_type_auth_receive] = \"Authentication Receive\",\n};\n\nstatic const char * const nvme_statuses[] = {\n\t[NVME_SC_SUCCESS] = \"Success\",\n\t[NVME_SC_INVALID_OPCODE] = \"Invalid Command Opcode\",\n\t[NVME_SC_INVALID_FIELD] = \"Invalid Field in Command\",\n\t[NVME_SC_CMDID_CONFLICT] = \"Command ID Conflict\",\n\t[NVME_SC_DATA_XFER_ERROR] = \"Data Transfer Error\",\n\t[NVME_SC_POWER_LOSS] = \"Commands Aborted due to Power Loss Notification\",\n\t[NVME_SC_INTERNAL] = \"Internal Error\",\n\t[NVME_SC_ABORT_REQ] = \"Command Abort Requested\",\n\t[NVME_SC_ABORT_QUEUE] = \"Command Aborted due to SQ Deletion\",\n\t[NVME_SC_FUSED_FAIL] = \"Command Aborted due to Failed Fused Command\",\n\t[NVME_SC_FUSED_MISSING] = \"Command Aborted due to Missing Fused Command\",\n\t[NVME_SC_INVALID_NS] = \"Invalid Namespace or Format\",\n\t[NVME_SC_CMD_SEQ_ERROR] = \"Command Sequence Error\",\n\t[NVME_SC_SGL_INVALID_LAST] = \"Invalid SGL Segment Descriptor\",\n\t[NVME_SC_SGL_INVALID_COUNT] = \"Invalid Number of SGL Descriptors\",\n\t[NVME_SC_SGL_INVALID_DATA] = \"Data SGL Length Invalid\",\n\t[NVME_SC_SGL_INVALID_METADATA] = \"Metadata SGL Length Invalid\",\n\t[NVME_SC_SGL_INVALID_TYPE] = \"SGL Descriptor Type Invalid\",\n\t[NVME_SC_CMB_INVALID_USE] = \"Invalid Use of Controller Memory Buffer\",\n\t[NVME_SC_PRP_INVALID_OFFSET] = \"PRP Offset Invalid\",\n\t[NVME_SC_ATOMIC_WU_EXCEEDED] = \"Atomic Write Unit Exceeded\",\n\t[NVME_SC_OP_DENIED] = \"Operation Denied\",\n\t[NVME_SC_SGL_INVALID_OFFSET] = \"SGL Offset Invalid\",\n\t[NVME_SC_RESERVED] = \"Reserved\",\n\t[NVME_SC_HOST_ID_INCONSIST] = \"Host Identifier Inconsistent Format\",\n\t[NVME_SC_KA_TIMEOUT_EXPIRED] = \"Keep Alive Timeout Expired\",\n\t[NVME_SC_KA_TIMEOUT_INVALID] = \"Keep Alive Timeout Invalid\",\n\t[NVME_SC_ABORTED_PREEMPT_ABORT] = \"Command Aborted due to Preempt and Abort\",\n\t[NVME_SC_SANITIZE_FAILED] = \"Sanitize Failed\",\n\t[NVME_SC_SANITIZE_IN_PROGRESS] = \"Sanitize In Progress\",\n\t[NVME_SC_SGL_INVALID_GRANULARITY] = \"SGL Data Block Granularity Invalid\",\n\t[NVME_SC_CMD_NOT_SUP_CMB_QUEUE] = \"Command Not Supported for Queue in CMB\",\n\t[NVME_SC_NS_WRITE_PROTECTED] = \"Namespace is Write Protected\",\n\t[NVME_SC_CMD_INTERRUPTED] = \"Command Interrupted\",\n\t[NVME_SC_TRANSIENT_TR_ERR] = \"Transient Transport Error\",\n\t[NVME_SC_ADMIN_COMMAND_MEDIA_NOT_READY] = \"Admin Command Media Not Ready\",\n\t[NVME_SC_INVALID_IO_CMD_SET] = \"Invalid IO Command Set\",\n\t[NVME_SC_LBA_RANGE] = \"LBA Out of Range\",\n\t[NVME_SC_CAP_EXCEEDED] = \"Capacity Exceeded\",\n\t[NVME_SC_NS_NOT_READY] = \"Namespace Not Ready\",\n\t[NVME_SC_RESERVATION_CONFLICT] = \"Reservation Conflict\",\n\t[NVME_SC_FORMAT_IN_PROGRESS] = \"Format In Progress\",\n\t[NVME_SC_CQ_INVALID] = \"Completion Queue Invalid\",\n\t[NVME_SC_QID_INVALID] = \"Invalid Queue Identifier\",\n\t[NVME_SC_QUEUE_SIZE] = \"Invalid Queue Size\",\n\t[NVME_SC_ABORT_LIMIT] = \"Abort Command Limit Exceeded\",\n\t[NVME_SC_ABORT_MISSING] = \"Reserved\",  \n\t[NVME_SC_ASYNC_LIMIT] = \"Asynchronous Event Request Limit Exceeded\",\n\t[NVME_SC_FIRMWARE_SLOT] = \"Invalid Firmware Slot\",\n\t[NVME_SC_FIRMWARE_IMAGE] = \"Invalid Firmware Image\",\n\t[NVME_SC_INVALID_VECTOR] = \"Invalid Interrupt Vector\",\n\t[NVME_SC_INVALID_LOG_PAGE] = \"Invalid Log Page\",\n\t[NVME_SC_INVALID_FORMAT] = \"Invalid Format\",\n\t[NVME_SC_FW_NEEDS_CONV_RESET] = \"Firmware Activation Requires Conventional Reset\",\n\t[NVME_SC_INVALID_QUEUE] = \"Invalid Queue Deletion\",\n\t[NVME_SC_FEATURE_NOT_SAVEABLE] = \"Feature Identifier Not Saveable\",\n\t[NVME_SC_FEATURE_NOT_CHANGEABLE] = \"Feature Not Changeable\",\n\t[NVME_SC_FEATURE_NOT_PER_NS] = \"Feature Not Namespace Specific\",\n\t[NVME_SC_FW_NEEDS_SUBSYS_RESET] = \"Firmware Activation Requires NVM Subsystem Reset\",\n\t[NVME_SC_FW_NEEDS_RESET] = \"Firmware Activation Requires Reset\",\n\t[NVME_SC_FW_NEEDS_MAX_TIME] = \"Firmware Activation Requires Maximum Time Violation\",\n\t[NVME_SC_FW_ACTIVATE_PROHIBITED] = \"Firmware Activation Prohibited\",\n\t[NVME_SC_OVERLAPPING_RANGE] = \"Overlapping Range\",\n\t[NVME_SC_NS_INSUFFICIENT_CAP] = \"Namespace Insufficient Capacity\",\n\t[NVME_SC_NS_ID_UNAVAILABLE] = \"Namespace Identifier Unavailable\",\n\t[NVME_SC_NS_ALREADY_ATTACHED] = \"Namespace Already Attached\",\n\t[NVME_SC_NS_IS_PRIVATE] = \"Namespace Is Private\",\n\t[NVME_SC_NS_NOT_ATTACHED] = \"Namespace Not Attached\",\n\t[NVME_SC_THIN_PROV_NOT_SUPP] = \"Thin Provisioning Not Supported\",\n\t[NVME_SC_CTRL_LIST_INVALID] = \"Controller List Invalid\",\n\t[NVME_SC_SELT_TEST_IN_PROGRESS] = \"Device Self-test In Progress\",\n\t[NVME_SC_BP_WRITE_PROHIBITED] = \"Boot Partition Write Prohibited\",\n\t[NVME_SC_CTRL_ID_INVALID] = \"Invalid Controller Identifier\",\n\t[NVME_SC_SEC_CTRL_STATE_INVALID] = \"Invalid Secondary Controller State\",\n\t[NVME_SC_CTRL_RES_NUM_INVALID] = \"Invalid Number of Controller Resources\",\n\t[NVME_SC_RES_ID_INVALID] = \"Invalid Resource Identifier\",\n\t[NVME_SC_PMR_SAN_PROHIBITED] = \"Sanitize Prohibited\",\n\t[NVME_SC_ANA_GROUP_ID_INVALID] = \"ANA Group Identifier Invalid\",\n\t[NVME_SC_ANA_ATTACH_FAILED] = \"ANA Attach Failed\",\n\t[NVME_SC_BAD_ATTRIBUTES] = \"Conflicting Attributes\",\n\t[NVME_SC_INVALID_PI] = \"Invalid Protection Information\",\n\t[NVME_SC_READ_ONLY] = \"Attempted Write to Read Only Range\",\n\t[NVME_SC_ONCS_NOT_SUPPORTED] = \"ONCS Not Supported\",\n\t[NVME_SC_ZONE_BOUNDARY_ERROR] = \"Zoned Boundary Error\",\n\t[NVME_SC_ZONE_FULL] = \"Zone Is Full\",\n\t[NVME_SC_ZONE_READ_ONLY] = \"Zone Is Read Only\",\n\t[NVME_SC_ZONE_OFFLINE] = \"Zone Is Offline\",\n\t[NVME_SC_ZONE_INVALID_WRITE] = \"Zone Invalid Write\",\n\t[NVME_SC_ZONE_TOO_MANY_ACTIVE] = \"Too Many Active Zones\",\n\t[NVME_SC_ZONE_TOO_MANY_OPEN] = \"Too Many Open Zones\",\n\t[NVME_SC_ZONE_INVALID_TRANSITION] = \"Invalid Zone State Transition\",\n\t[NVME_SC_WRITE_FAULT] = \"Write Fault\",\n\t[NVME_SC_READ_ERROR] = \"Unrecovered Read Error\",\n\t[NVME_SC_GUARD_CHECK] = \"End-to-end Guard Check Error\",\n\t[NVME_SC_APPTAG_CHECK] = \"End-to-end Application Tag Check Error\",\n\t[NVME_SC_REFTAG_CHECK] = \"End-to-end Reference Tag Check Error\",\n\t[NVME_SC_COMPARE_FAILED] = \"Compare Failure\",\n\t[NVME_SC_ACCESS_DENIED] = \"Access Denied\",\n\t[NVME_SC_UNWRITTEN_BLOCK] = \"Deallocated or Unwritten Logical Block\",\n\t[NVME_SC_INTERNAL_PATH_ERROR] = \"Internal Pathing Error\",\n\t[NVME_SC_ANA_PERSISTENT_LOSS] = \"Asymmetric Access Persistent Loss\",\n\t[NVME_SC_ANA_INACCESSIBLE] = \"Asymmetric Access Inaccessible\",\n\t[NVME_SC_ANA_TRANSITION] = \"Asymmetric Access Transition\",\n\t[NVME_SC_CTRL_PATH_ERROR] = \"Controller Pathing Error\",\n\t[NVME_SC_HOST_PATH_ERROR] = \"Host Pathing Error\",\n\t[NVME_SC_HOST_ABORTED_CMD] = \"Host Aborted Command\",\n};\n\nconst unsigned char *nvme_get_error_status_str(u16 status)\n{\n\tstatus &= 0x7ff;\n\tif (status < ARRAY_SIZE(nvme_statuses) && nvme_statuses[status])\n\t\treturn nvme_statuses[status & 0x7ff];\n\treturn \"Unknown\";\n}\n\nconst unsigned char *nvme_get_opcode_str(u8 opcode)\n{\n\tif (opcode < ARRAY_SIZE(nvme_ops) && nvme_ops[opcode])\n\t\treturn nvme_ops[opcode];\n\treturn \"Unknown\";\n}\nEXPORT_SYMBOL_GPL(nvme_get_opcode_str);\n\nconst unsigned char *nvme_get_admin_opcode_str(u8 opcode)\n{\n\tif (opcode < ARRAY_SIZE(nvme_admin_ops) && nvme_admin_ops[opcode])\n\t\treturn nvme_admin_ops[opcode];\n\treturn \"Unknown\";\n}\nEXPORT_SYMBOL_GPL(nvme_get_admin_opcode_str);\n\nconst unsigned char *nvme_get_fabrics_opcode_str(u8 opcode) {\n\tif (opcode < ARRAY_SIZE(nvme_fabrics_ops) && nvme_fabrics_ops[opcode])\n\t\treturn nvme_fabrics_ops[opcode];\n\treturn \"Unknown\";\n}\nEXPORT_SYMBOL_GPL(nvme_get_fabrics_opcode_str);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}