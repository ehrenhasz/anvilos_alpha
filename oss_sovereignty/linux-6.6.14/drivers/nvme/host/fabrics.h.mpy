{
  "module_name": "fabrics.h",
  "hash_id": "f77d2acb5c34421b567b9e0e6b8cc4dedff8d1db09e2b4fde0c8c3f2d7f38ed1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/host/fabrics.h",
  "human_readable_source": " \n \n#ifndef _NVME_FABRICS_H\n#define _NVME_FABRICS_H 1\n\n#include <linux/in.h>\n#include <linux/inet.h>\n\n#define NVMF_MIN_QUEUE_SIZE\t16\n#define NVMF_MAX_QUEUE_SIZE\t1024\n#define NVMF_DEF_QUEUE_SIZE\t128\n#define NVMF_DEF_RECONNECT_DELAY\t10\n \n#define NVMF_DEF_CTRL_LOSS_TMO\t\t600\n \n#define NVMF_DEF_FAIL_FAST_TMO\t\t-1\n\n \n#define NVMF_RESERVED_TAGS\t1\n\n \nstruct nvmf_host {\n\tstruct kref\t\tref;\n\tstruct list_head\tlist;\n\tchar\t\t\tnqn[NVMF_NQN_SIZE];\n\tuuid_t\t\t\tid;\n};\n\n \nenum {\n\tNVMF_OPT_ERR\t\t= 0,\n\tNVMF_OPT_TRANSPORT\t= 1 << 0,\n\tNVMF_OPT_NQN\t\t= 1 << 1,\n\tNVMF_OPT_TRADDR\t\t= 1 << 2,\n\tNVMF_OPT_TRSVCID\t= 1 << 3,\n\tNVMF_OPT_QUEUE_SIZE\t= 1 << 4,\n\tNVMF_OPT_NR_IO_QUEUES\t= 1 << 5,\n\tNVMF_OPT_TL_RETRY_COUNT\t= 1 << 6,\n\tNVMF_OPT_KATO\t\t= 1 << 7,\n\tNVMF_OPT_HOSTNQN\t= 1 << 8,\n\tNVMF_OPT_RECONNECT_DELAY = 1 << 9,\n\tNVMF_OPT_HOST_TRADDR\t= 1 << 10,\n\tNVMF_OPT_CTRL_LOSS_TMO\t= 1 << 11,\n\tNVMF_OPT_HOST_ID\t= 1 << 12,\n\tNVMF_OPT_DUP_CONNECT\t= 1 << 13,\n\tNVMF_OPT_DISABLE_SQFLOW = 1 << 14,\n\tNVMF_OPT_HDR_DIGEST\t= 1 << 15,\n\tNVMF_OPT_DATA_DIGEST\t= 1 << 16,\n\tNVMF_OPT_NR_WRITE_QUEUES = 1 << 17,\n\tNVMF_OPT_NR_POLL_QUEUES = 1 << 18,\n\tNVMF_OPT_TOS\t\t= 1 << 19,\n\tNVMF_OPT_FAIL_FAST_TMO\t= 1 << 20,\n\tNVMF_OPT_HOST_IFACE\t= 1 << 21,\n\tNVMF_OPT_DISCOVERY\t= 1 << 22,\n\tNVMF_OPT_DHCHAP_SECRET\t= 1 << 23,\n\tNVMF_OPT_DHCHAP_CTRL_SECRET = 1 << 24,\n};\n\n \nstruct nvmf_ctrl_options {\n\tunsigned\t\tmask;\n\tint\t\t\tmax_reconnects;\n\tchar\t\t\t*transport;\n\tchar\t\t\t*subsysnqn;\n\tchar\t\t\t*traddr;\n\tchar\t\t\t*trsvcid;\n\tchar\t\t\t*host_traddr;\n\tchar\t\t\t*host_iface;\n\tsize_t\t\t\tqueue_size;\n\tunsigned int\t\tnr_io_queues;\n\tunsigned int\t\treconnect_delay;\n\tbool\t\t\tdiscovery_nqn;\n\tbool\t\t\tduplicate_connect;\n\tunsigned int\t\tkato;\n\tstruct nvmf_host\t*host;\n\tchar\t\t\t*dhchap_secret;\n\tchar\t\t\t*dhchap_ctrl_secret;\n\tbool\t\t\tdisable_sqflow;\n\tbool\t\t\thdr_digest;\n\tbool\t\t\tdata_digest;\n\tunsigned int\t\tnr_write_queues;\n\tunsigned int\t\tnr_poll_queues;\n\tint\t\t\ttos;\n\tint\t\t\tfast_io_fail_tmo;\n};\n\n \nstruct nvmf_transport_ops {\n\tstruct list_head\tentry;\n\tstruct module\t\t*module;\n\tconst char\t\t*name;\n\tint\t\t\trequired_opts;\n\tint\t\t\tallowed_opts;\n\tstruct nvme_ctrl\t*(*create_ctrl)(struct device *dev,\n\t\t\t\t\tstruct nvmf_ctrl_options *opts);\n};\n\nstatic inline bool\nnvmf_ctlr_matches_baseopts(struct nvme_ctrl *ctrl,\n\t\t\tstruct nvmf_ctrl_options *opts)\n{\n\tif (ctrl->state == NVME_CTRL_DELETING ||\n\t    ctrl->state == NVME_CTRL_DELETING_NOIO ||\n\t    ctrl->state == NVME_CTRL_DEAD ||\n\t    strcmp(opts->subsysnqn, ctrl->opts->subsysnqn) ||\n\t    strcmp(opts->host->nqn, ctrl->opts->host->nqn) ||\n\t    !uuid_equal(&opts->host->id, &ctrl->opts->host->id))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline char *nvmf_ctrl_subsysnqn(struct nvme_ctrl *ctrl)\n{\n\tif (!ctrl->subsys ||\n\t    !strcmp(ctrl->opts->subsysnqn, NVME_DISC_SUBSYS_NAME))\n\t\treturn ctrl->opts->subsysnqn;\n\treturn ctrl->subsys->subnqn;\n}\n\nstatic inline void nvmf_complete_timed_out_request(struct request *rq)\n{\n\tif (blk_mq_request_started(rq) && !blk_mq_request_completed(rq)) {\n\t\tnvme_req(rq)->status = NVME_SC_HOST_ABORTED_CMD;\n\t\tblk_mq_complete_request(rq);\n\t}\n}\n\nstatic inline unsigned int nvmf_nr_io_queues(struct nvmf_ctrl_options *opts)\n{\n\treturn min(opts->nr_io_queues, num_online_cpus()) +\n\t\tmin(opts->nr_write_queues, num_online_cpus()) +\n\t\tmin(opts->nr_poll_queues, num_online_cpus());\n}\n\nint nvmf_reg_read32(struct nvme_ctrl *ctrl, u32 off, u32 *val);\nint nvmf_reg_read64(struct nvme_ctrl *ctrl, u32 off, u64 *val);\nint nvmf_reg_write32(struct nvme_ctrl *ctrl, u32 off, u32 val);\nint nvmf_connect_admin_queue(struct nvme_ctrl *ctrl);\nint nvmf_connect_io_queue(struct nvme_ctrl *ctrl, u16 qid);\nint nvmf_register_transport(struct nvmf_transport_ops *ops);\nvoid nvmf_unregister_transport(struct nvmf_transport_ops *ops);\nvoid nvmf_free_options(struct nvmf_ctrl_options *opts);\nint nvmf_get_address(struct nvme_ctrl *ctrl, char *buf, int size);\nbool nvmf_should_reconnect(struct nvme_ctrl *ctrl);\nbool nvmf_ip_options_match(struct nvme_ctrl *ctrl,\n\t\tstruct nvmf_ctrl_options *opts);\nvoid nvmf_set_io_queues(struct nvmf_ctrl_options *opts, u32 nr_io_queues,\n\t\t\tu32 io_queues[HCTX_MAX_TYPES]);\nvoid nvmf_map_queues(struct blk_mq_tag_set *set, struct nvme_ctrl *ctrl,\n\t\t     u32 io_queues[HCTX_MAX_TYPES]);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}