{
  "module_name": "ioctl.c",
  "hash_id": "2c2546a789e9c74f6ce90ca54980409ddeb8c59576164a28f48c32c72cdb29f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/host/ioctl.c",
  "human_readable_source": "\n \n#include <linux/ptrace.h>\t \n#include <linux/nvme_ioctl.h>\n#include <linux/io_uring.h>\n#include \"nvme.h\"\n\nenum {\n\tNVME_IOCTL_VEC\t\t= (1 << 0),\n\tNVME_IOCTL_PARTITION\t= (1 << 1),\n};\n\nstatic bool nvme_cmd_allowed(struct nvme_ns *ns, struct nvme_command *c,\n\t\tunsigned int flags, bool open_for_write)\n{\n\tu32 effects;\n\n\t \n\tif (flags & NVME_IOCTL_PARTITION)\n\t\tgoto admin;\n\n\t \n\tif (c->common.opcode >= nvme_cmd_vendor_start ||\n\t    c->common.opcode == nvme_fabrics_command)\n\t\tgoto admin;\n\n\t \n\tif (!ns) {\n\t\tif (c->common.opcode == nvme_admin_identify) {\n\t\t\tswitch (c->identify.cns) {\n\t\t\tcase NVME_ID_CNS_NS:\n\t\t\tcase NVME_ID_CNS_CS_NS:\n\t\t\tcase NVME_ID_CNS_NS_CS_INDEP:\n\t\t\tcase NVME_ID_CNS_CS_CTRL:\n\t\t\tcase NVME_ID_CNS_CTRL:\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tgoto admin;\n\t}\n\n\t \n\teffects = nvme_command_effects(ns->ctrl, ns, c->common.opcode);\n\tif (!(effects & NVME_CMD_EFFECTS_CSUPP))\n\t\tgoto admin;\n\n\t \n\tif (effects & ~(NVME_CMD_EFFECTS_CSUPP | NVME_CMD_EFFECTS_LBCC |\n\t\t\tNVME_CMD_EFFECTS_UUID_SEL |\n\t\t\tNVME_CMD_EFFECTS_SCOPE_MASK))\n\t\tgoto admin;\n\n\t \n\tif ((nvme_is_write(c) || (effects & NVME_CMD_EFFECTS_LBCC)) &&\n\t    !open_for_write)\n\t\tgoto admin;\n\n\treturn true;\nadmin:\n\treturn capable(CAP_SYS_ADMIN);\n}\n\n \nstatic void __user *nvme_to_user_ptr(uintptr_t ptrval)\n{\n\tif (in_compat_syscall())\n\t\tptrval = (compat_uptr_t)ptrval;\n\treturn (void __user *)ptrval;\n}\n\nstatic void *nvme_add_user_metadata(struct request *req, void __user *ubuf,\n\t\tunsigned len, u32 seed)\n{\n\tstruct bio_integrity_payload *bip;\n\tint ret = -ENOMEM;\n\tvoid *buf;\n\tstruct bio *bio = req->bio;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\tif (req_op(req) == REQ_OP_DRV_OUT) {\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(buf, ubuf, len))\n\t\t\tgoto out_free_meta;\n\t} else {\n\t\tmemset(buf, 0, len);\n\t}\n\n\tbip = bio_integrity_alloc(bio, GFP_KERNEL, 1);\n\tif (IS_ERR(bip)) {\n\t\tret = PTR_ERR(bip);\n\t\tgoto out_free_meta;\n\t}\n\n\tbip->bip_iter.bi_sector = seed;\n\tret = bio_integrity_add_page(bio, virt_to_page(buf), len,\n\t\t\toffset_in_page(buf));\n\tif (ret != len) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_meta;\n\t}\n\n\treq->cmd_flags |= REQ_INTEGRITY;\n\treturn buf;\nout_free_meta:\n\tkfree(buf);\nout:\n\treturn ERR_PTR(ret);\n}\n\nstatic int nvme_finish_user_metadata(struct request *req, void __user *ubuf,\n\t\tvoid *meta, unsigned len, int ret)\n{\n\tif (!ret && req_op(req) == REQ_OP_DRV_IN &&\n\t    copy_to_user(ubuf, meta, len))\n\t\tret = -EFAULT;\n\tkfree(meta);\n\treturn ret;\n}\n\nstatic struct request *nvme_alloc_user_request(struct request_queue *q,\n\t\tstruct nvme_command *cmd, blk_opf_t rq_flags,\n\t\tblk_mq_req_flags_t blk_flags)\n{\n\tstruct request *req;\n\n\treq = blk_mq_alloc_request(q, nvme_req_op(cmd) | rq_flags, blk_flags);\n\tif (IS_ERR(req))\n\t\treturn req;\n\tnvme_init_request(req, cmd);\n\tnvme_req(req)->flags |= NVME_REQ_USERCMD;\n\treturn req;\n}\n\nstatic int nvme_map_user_request(struct request *req, u64 ubuffer,\n\t\tunsigned bufflen, void __user *meta_buffer, unsigned meta_len,\n\t\tu32 meta_seed, void **metap, struct io_uring_cmd *ioucmd,\n\t\tunsigned int flags)\n{\n\tstruct request_queue *q = req->q;\n\tstruct nvme_ns *ns = q->queuedata;\n\tstruct block_device *bdev = ns ? ns->disk->part0 : NULL;\n\tstruct bio *bio = NULL;\n\tvoid *meta = NULL;\n\tint ret;\n\n\tif (ioucmd && (ioucmd->flags & IORING_URING_CMD_FIXED)) {\n\t\tstruct iov_iter iter;\n\n\t\t \n\t\tif (WARN_ON_ONCE(flags & NVME_IOCTL_VEC))\n\t\t\treturn -EINVAL;\n\t\tret = io_uring_cmd_import_fixed(ubuffer, bufflen,\n\t\t\t\trq_data_dir(req), &iter, ioucmd);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = blk_rq_map_user_iov(q, req, NULL, &iter, GFP_KERNEL);\n\t} else {\n\t\tret = blk_rq_map_user_io(req, NULL, nvme_to_user_ptr(ubuffer),\n\t\t\t\tbufflen, GFP_KERNEL, flags & NVME_IOCTL_VEC, 0,\n\t\t\t\t0, rq_data_dir(req));\n\t}\n\n\tif (ret)\n\t\tgoto out;\n\tbio = req->bio;\n\tif (bdev)\n\t\tbio_set_dev(bio, bdev);\n\n\tif (bdev && meta_buffer && meta_len) {\n\t\tmeta = nvme_add_user_metadata(req, meta_buffer, meta_len,\n\t\t\t\tmeta_seed);\n\t\tif (IS_ERR(meta)) {\n\t\t\tret = PTR_ERR(meta);\n\t\t\tgoto out_unmap;\n\t\t}\n\t\t*metap = meta;\n\t}\n\n\treturn ret;\n\nout_unmap:\n\tif (bio)\n\t\tblk_rq_unmap_user(bio);\nout:\n\tblk_mq_free_request(req);\n\treturn ret;\n}\n\nstatic int nvme_submit_user_cmd(struct request_queue *q,\n\t\tstruct nvme_command *cmd, u64 ubuffer, unsigned bufflen,\n\t\tvoid __user *meta_buffer, unsigned meta_len, u32 meta_seed,\n\t\tu64 *result, unsigned timeout, unsigned int flags)\n{\n\tstruct nvme_ns *ns = q->queuedata;\n\tstruct nvme_ctrl *ctrl;\n\tstruct request *req;\n\tvoid *meta = NULL;\n\tstruct bio *bio;\n\tu32 effects;\n\tint ret;\n\n\treq = nvme_alloc_user_request(q, cmd, 0, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\treq->timeout = timeout;\n\tif (ubuffer && bufflen) {\n\t\tret = nvme_map_user_request(req, ubuffer, bufflen, meta_buffer,\n\t\t\t\tmeta_len, meta_seed, &meta, NULL, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tbio = req->bio;\n\tctrl = nvme_req(req)->ctrl;\n\n\teffects = nvme_passthru_start(ctrl, ns, cmd->common.opcode);\n\tret = nvme_execute_rq(req, false);\n\tif (result)\n\t\t*result = le64_to_cpu(nvme_req(req)->result.u64);\n\tif (meta)\n\t\tret = nvme_finish_user_metadata(req, meta_buffer, meta,\n\t\t\t\t\t\tmeta_len, ret);\n\tif (bio)\n\t\tblk_rq_unmap_user(bio);\n\tblk_mq_free_request(req);\n\n\tif (effects)\n\t\tnvme_passthru_end(ctrl, ns, effects, cmd, ret);\n\n\treturn ret;\n}\n\nstatic int nvme_submit_io(struct nvme_ns *ns, struct nvme_user_io __user *uio)\n{\n\tstruct nvme_user_io io;\n\tstruct nvme_command c;\n\tunsigned length, meta_len;\n\tvoid __user *metadata;\n\n\tif (copy_from_user(&io, uio, sizeof(io)))\n\t\treturn -EFAULT;\n\tif (io.flags)\n\t\treturn -EINVAL;\n\n\tswitch (io.opcode) {\n\tcase nvme_cmd_write:\n\tcase nvme_cmd_read:\n\tcase nvme_cmd_compare:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlength = (io.nblocks + 1) << ns->lba_shift;\n\n\tif ((io.control & NVME_RW_PRINFO_PRACT) &&\n\t    ns->ms == sizeof(struct t10_pi_tuple)) {\n\t\t \n\t\tif (nvme_to_user_ptr(io.metadata))\n\t\t\treturn -EINVAL;\n\t\tmeta_len = 0;\n\t\tmetadata = NULL;\n\t} else {\n\t\tmeta_len = (io.nblocks + 1) * ns->ms;\n\t\tmetadata = nvme_to_user_ptr(io.metadata);\n\t}\n\n\tif (ns->features & NVME_NS_EXT_LBAS) {\n\t\tlength += meta_len;\n\t\tmeta_len = 0;\n\t} else if (meta_len) {\n\t\tif ((io.metadata & 3) || !io.metadata)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmemset(&c, 0, sizeof(c));\n\tc.rw.opcode = io.opcode;\n\tc.rw.flags = io.flags;\n\tc.rw.nsid = cpu_to_le32(ns->head->ns_id);\n\tc.rw.slba = cpu_to_le64(io.slba);\n\tc.rw.length = cpu_to_le16(io.nblocks);\n\tc.rw.control = cpu_to_le16(io.control);\n\tc.rw.dsmgmt = cpu_to_le32(io.dsmgmt);\n\tc.rw.reftag = cpu_to_le32(io.reftag);\n\tc.rw.apptag = cpu_to_le16(io.apptag);\n\tc.rw.appmask = cpu_to_le16(io.appmask);\n\n\treturn nvme_submit_user_cmd(ns->queue, &c, io.addr, length, metadata,\n\t\t\tmeta_len, lower_32_bits(io.slba), NULL, 0, 0);\n}\n\nstatic bool nvme_validate_passthru_nsid(struct nvme_ctrl *ctrl,\n\t\t\t\t\tstruct nvme_ns *ns, __u32 nsid)\n{\n\tif (ns && nsid != ns->head->ns_id) {\n\t\tdev_err(ctrl->device,\n\t\t\t\"%s: nsid (%u) in cmd does not match nsid (%u)\"\n\t\t\t\"of namespace\\n\",\n\t\t\tcurrent->comm, nsid, ns->head->ns_id);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int nvme_user_cmd(struct nvme_ctrl *ctrl, struct nvme_ns *ns,\n\t\tstruct nvme_passthru_cmd __user *ucmd, unsigned int flags,\n\t\tbool open_for_write)\n{\n\tstruct nvme_passthru_cmd cmd;\n\tstruct nvme_command c;\n\tunsigned timeout = 0;\n\tu64 result;\n\tint status;\n\n\tif (copy_from_user(&cmd, ucmd, sizeof(cmd)))\n\t\treturn -EFAULT;\n\tif (cmd.flags)\n\t\treturn -EINVAL;\n\tif (!nvme_validate_passthru_nsid(ctrl, ns, cmd.nsid))\n\t\treturn -EINVAL;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.common.opcode = cmd.opcode;\n\tc.common.flags = cmd.flags;\n\tc.common.nsid = cpu_to_le32(cmd.nsid);\n\tc.common.cdw2[0] = cpu_to_le32(cmd.cdw2);\n\tc.common.cdw2[1] = cpu_to_le32(cmd.cdw3);\n\tc.common.cdw10 = cpu_to_le32(cmd.cdw10);\n\tc.common.cdw11 = cpu_to_le32(cmd.cdw11);\n\tc.common.cdw12 = cpu_to_le32(cmd.cdw12);\n\tc.common.cdw13 = cpu_to_le32(cmd.cdw13);\n\tc.common.cdw14 = cpu_to_le32(cmd.cdw14);\n\tc.common.cdw15 = cpu_to_le32(cmd.cdw15);\n\n\tif (!nvme_cmd_allowed(ns, &c, 0, open_for_write))\n\t\treturn -EACCES;\n\n\tif (cmd.timeout_ms)\n\t\ttimeout = msecs_to_jiffies(cmd.timeout_ms);\n\n\tstatus = nvme_submit_user_cmd(ns ? ns->queue : ctrl->admin_q, &c,\n\t\t\tcmd.addr, cmd.data_len, nvme_to_user_ptr(cmd.metadata),\n\t\t\tcmd.metadata_len, 0, &result, timeout, 0);\n\n\tif (status >= 0) {\n\t\tif (put_user(result, &ucmd->result))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn status;\n}\n\nstatic int nvme_user_cmd64(struct nvme_ctrl *ctrl, struct nvme_ns *ns,\n\t\tstruct nvme_passthru_cmd64 __user *ucmd, unsigned int flags,\n\t\tbool open_for_write)\n{\n\tstruct nvme_passthru_cmd64 cmd;\n\tstruct nvme_command c;\n\tunsigned timeout = 0;\n\tint status;\n\n\tif (copy_from_user(&cmd, ucmd, sizeof(cmd)))\n\t\treturn -EFAULT;\n\tif (cmd.flags)\n\t\treturn -EINVAL;\n\tif (!nvme_validate_passthru_nsid(ctrl, ns, cmd.nsid))\n\t\treturn -EINVAL;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.common.opcode = cmd.opcode;\n\tc.common.flags = cmd.flags;\n\tc.common.nsid = cpu_to_le32(cmd.nsid);\n\tc.common.cdw2[0] = cpu_to_le32(cmd.cdw2);\n\tc.common.cdw2[1] = cpu_to_le32(cmd.cdw3);\n\tc.common.cdw10 = cpu_to_le32(cmd.cdw10);\n\tc.common.cdw11 = cpu_to_le32(cmd.cdw11);\n\tc.common.cdw12 = cpu_to_le32(cmd.cdw12);\n\tc.common.cdw13 = cpu_to_le32(cmd.cdw13);\n\tc.common.cdw14 = cpu_to_le32(cmd.cdw14);\n\tc.common.cdw15 = cpu_to_le32(cmd.cdw15);\n\n\tif (!nvme_cmd_allowed(ns, &c, flags, open_for_write))\n\t\treturn -EACCES;\n\n\tif (cmd.timeout_ms)\n\t\ttimeout = msecs_to_jiffies(cmd.timeout_ms);\n\n\tstatus = nvme_submit_user_cmd(ns ? ns->queue : ctrl->admin_q, &c,\n\t\t\tcmd.addr, cmd.data_len, nvme_to_user_ptr(cmd.metadata),\n\t\t\tcmd.metadata_len, 0, &cmd.result, timeout, flags);\n\n\tif (status >= 0) {\n\t\tif (put_user(cmd.result, &ucmd->result))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn status;\n}\n\nstruct nvme_uring_data {\n\t__u64\tmetadata;\n\t__u64\taddr;\n\t__u32\tdata_len;\n\t__u32\tmetadata_len;\n\t__u32\ttimeout_ms;\n};\n\n \nstruct nvme_uring_cmd_pdu {\n\tunion {\n\t\tstruct bio *bio;\n\t\tstruct request *req;\n\t};\n\tu32 meta_len;\n\tu32 nvme_status;\n\tunion {\n\t\tstruct {\n\t\t\tvoid *meta;  \n\t\t\tvoid __user *meta_buffer;\n\t\t};\n\t\tu64 result;\n\t} u;\n};\n\nstatic inline struct nvme_uring_cmd_pdu *nvme_uring_cmd_pdu(\n\t\tstruct io_uring_cmd *ioucmd)\n{\n\treturn (struct nvme_uring_cmd_pdu *)&ioucmd->pdu;\n}\n\nstatic void nvme_uring_task_meta_cb(struct io_uring_cmd *ioucmd,\n\t\t\t\t    unsigned issue_flags)\n{\n\tstruct nvme_uring_cmd_pdu *pdu = nvme_uring_cmd_pdu(ioucmd);\n\tstruct request *req = pdu->req;\n\tint status;\n\tu64 result;\n\n\tif (nvme_req(req)->flags & NVME_REQ_CANCELLED)\n\t\tstatus = -EINTR;\n\telse\n\t\tstatus = nvme_req(req)->status;\n\n\tresult = le64_to_cpu(nvme_req(req)->result.u64);\n\n\tif (pdu->meta_len)\n\t\tstatus = nvme_finish_user_metadata(req, pdu->u.meta_buffer,\n\t\t\t\t\tpdu->u.meta, pdu->meta_len, status);\n\tif (req->bio)\n\t\tblk_rq_unmap_user(req->bio);\n\tblk_mq_free_request(req);\n\n\tio_uring_cmd_done(ioucmd, status, result, issue_flags);\n}\n\nstatic void nvme_uring_task_cb(struct io_uring_cmd *ioucmd,\n\t\t\t       unsigned issue_flags)\n{\n\tstruct nvme_uring_cmd_pdu *pdu = nvme_uring_cmd_pdu(ioucmd);\n\n\tif (pdu->bio)\n\t\tblk_rq_unmap_user(pdu->bio);\n\n\tio_uring_cmd_done(ioucmd, pdu->nvme_status, pdu->u.result, issue_flags);\n}\n\nstatic enum rq_end_io_ret nvme_uring_cmd_end_io(struct request *req,\n\t\t\t\t\t\tblk_status_t err)\n{\n\tstruct io_uring_cmd *ioucmd = req->end_io_data;\n\tstruct nvme_uring_cmd_pdu *pdu = nvme_uring_cmd_pdu(ioucmd);\n\n\treq->bio = pdu->bio;\n\tif (nvme_req(req)->flags & NVME_REQ_CANCELLED) {\n\t\tpdu->nvme_status = -EINTR;\n\t} else {\n\t\tpdu->nvme_status = nvme_req(req)->status;\n\t\tif (!pdu->nvme_status)\n\t\t\tpdu->nvme_status = blk_status_to_errno(err);\n\t}\n\tpdu->u.result = le64_to_cpu(nvme_req(req)->result.u64);\n\n\t \n\tif (blk_rq_is_poll(req)) {\n\t\tWRITE_ONCE(ioucmd->cookie, NULL);\n\t\tnvme_uring_task_cb(ioucmd, IO_URING_F_UNLOCKED);\n\t} else {\n\t\tio_uring_cmd_do_in_task_lazy(ioucmd, nvme_uring_task_cb);\n\t}\n\n\treturn RQ_END_IO_FREE;\n}\n\nstatic enum rq_end_io_ret nvme_uring_cmd_end_io_meta(struct request *req,\n\t\t\t\t\t\t     blk_status_t err)\n{\n\tstruct io_uring_cmd *ioucmd = req->end_io_data;\n\tstruct nvme_uring_cmd_pdu *pdu = nvme_uring_cmd_pdu(ioucmd);\n\n\treq->bio = pdu->bio;\n\tpdu->req = req;\n\n\t \n\tif (blk_rq_is_poll(req)) {\n\t\tWRITE_ONCE(ioucmd->cookie, NULL);\n\t\tnvme_uring_task_meta_cb(ioucmd, IO_URING_F_UNLOCKED);\n\t} else {\n\t\tio_uring_cmd_do_in_task_lazy(ioucmd, nvme_uring_task_meta_cb);\n\t}\n\n\treturn RQ_END_IO_NONE;\n}\n\nstatic int nvme_uring_cmd_io(struct nvme_ctrl *ctrl, struct nvme_ns *ns,\n\t\tstruct io_uring_cmd *ioucmd, unsigned int issue_flags, bool vec)\n{\n\tstruct nvme_uring_cmd_pdu *pdu = nvme_uring_cmd_pdu(ioucmd);\n\tconst struct nvme_uring_cmd *cmd = io_uring_sqe_cmd(ioucmd->sqe);\n\tstruct request_queue *q = ns ? ns->queue : ctrl->admin_q;\n\tstruct nvme_uring_data d;\n\tstruct nvme_command c;\n\tstruct request *req;\n\tblk_opf_t rq_flags = REQ_ALLOC_CACHE;\n\tblk_mq_req_flags_t blk_flags = 0;\n\tvoid *meta = NULL;\n\tint ret;\n\n\tc.common.opcode = READ_ONCE(cmd->opcode);\n\tc.common.flags = READ_ONCE(cmd->flags);\n\tif (c.common.flags)\n\t\treturn -EINVAL;\n\n\tc.common.command_id = 0;\n\tc.common.nsid = cpu_to_le32(cmd->nsid);\n\tif (!nvme_validate_passthru_nsid(ctrl, ns, le32_to_cpu(c.common.nsid)))\n\t\treturn -EINVAL;\n\n\tc.common.cdw2[0] = cpu_to_le32(READ_ONCE(cmd->cdw2));\n\tc.common.cdw2[1] = cpu_to_le32(READ_ONCE(cmd->cdw3));\n\tc.common.metadata = 0;\n\tc.common.dptr.prp1 = c.common.dptr.prp2 = 0;\n\tc.common.cdw10 = cpu_to_le32(READ_ONCE(cmd->cdw10));\n\tc.common.cdw11 = cpu_to_le32(READ_ONCE(cmd->cdw11));\n\tc.common.cdw12 = cpu_to_le32(READ_ONCE(cmd->cdw12));\n\tc.common.cdw13 = cpu_to_le32(READ_ONCE(cmd->cdw13));\n\tc.common.cdw14 = cpu_to_le32(READ_ONCE(cmd->cdw14));\n\tc.common.cdw15 = cpu_to_le32(READ_ONCE(cmd->cdw15));\n\n\tif (!nvme_cmd_allowed(ns, &c, 0, ioucmd->file->f_mode & FMODE_WRITE))\n\t\treturn -EACCES;\n\n\td.metadata = READ_ONCE(cmd->metadata);\n\td.addr = READ_ONCE(cmd->addr);\n\td.data_len = READ_ONCE(cmd->data_len);\n\td.metadata_len = READ_ONCE(cmd->metadata_len);\n\td.timeout_ms = READ_ONCE(cmd->timeout_ms);\n\n\tif (issue_flags & IO_URING_F_NONBLOCK) {\n\t\trq_flags |= REQ_NOWAIT;\n\t\tblk_flags = BLK_MQ_REQ_NOWAIT;\n\t}\n\tif (issue_flags & IO_URING_F_IOPOLL)\n\t\trq_flags |= REQ_POLLED;\n\n\treq = nvme_alloc_user_request(q, &c, rq_flags, blk_flags);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->timeout = d.timeout_ms ? msecs_to_jiffies(d.timeout_ms) : 0;\n\n\tif (d.addr && d.data_len) {\n\t\tret = nvme_map_user_request(req, d.addr,\n\t\t\td.data_len, nvme_to_user_ptr(d.metadata),\n\t\t\td.metadata_len, 0, &meta, ioucmd, vec);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (blk_rq_is_poll(req)) {\n\t\tioucmd->flags |= IORING_URING_CMD_POLLED;\n\t\tWRITE_ONCE(ioucmd->cookie, req);\n\t}\n\n\t \n\tpdu->bio = req->bio;\n\tpdu->meta_len = d.metadata_len;\n\treq->end_io_data = ioucmd;\n\tif (pdu->meta_len) {\n\t\tpdu->u.meta = meta;\n\t\tpdu->u.meta_buffer = nvme_to_user_ptr(d.metadata);\n\t\treq->end_io = nvme_uring_cmd_end_io_meta;\n\t} else {\n\t\treq->end_io = nvme_uring_cmd_end_io;\n\t}\n\tblk_execute_rq_nowait(req, false);\n\treturn -EIOCBQUEUED;\n}\n\nstatic bool is_ctrl_ioctl(unsigned int cmd)\n{\n\tif (cmd == NVME_IOCTL_ADMIN_CMD || cmd == NVME_IOCTL_ADMIN64_CMD)\n\t\treturn true;\n\tif (is_sed_ioctl(cmd))\n\t\treturn true;\n\treturn false;\n}\n\nstatic int nvme_ctrl_ioctl(struct nvme_ctrl *ctrl, unsigned int cmd,\n\t\tvoid __user *argp, bool open_for_write)\n{\n\tswitch (cmd) {\n\tcase NVME_IOCTL_ADMIN_CMD:\n\t\treturn nvme_user_cmd(ctrl, NULL, argp, 0, open_for_write);\n\tcase NVME_IOCTL_ADMIN64_CMD:\n\t\treturn nvme_user_cmd64(ctrl, NULL, argp, 0, open_for_write);\n\tdefault:\n\t\treturn sed_ioctl(ctrl->opal_dev, cmd, argp);\n\t}\n}\n\n#ifdef COMPAT_FOR_U64_ALIGNMENT\nstruct nvme_user_io32 {\n\t__u8\topcode;\n\t__u8\tflags;\n\t__u16\tcontrol;\n\t__u16\tnblocks;\n\t__u16\trsvd;\n\t__u64\tmetadata;\n\t__u64\taddr;\n\t__u64\tslba;\n\t__u32\tdsmgmt;\n\t__u32\treftag;\n\t__u16\tapptag;\n\t__u16\tappmask;\n} __attribute__((__packed__));\n#define NVME_IOCTL_SUBMIT_IO32\t_IOW('N', 0x42, struct nvme_user_io32)\n#endif  \n\nstatic int nvme_ns_ioctl(struct nvme_ns *ns, unsigned int cmd,\n\t\tvoid __user *argp, unsigned int flags, bool open_for_write)\n{\n\tswitch (cmd) {\n\tcase NVME_IOCTL_ID:\n\t\tforce_successful_syscall_return();\n\t\treturn ns->head->ns_id;\n\tcase NVME_IOCTL_IO_CMD:\n\t\treturn nvme_user_cmd(ns->ctrl, ns, argp, flags, open_for_write);\n\t \n#ifdef COMPAT_FOR_U64_ALIGNMENT\n\tcase NVME_IOCTL_SUBMIT_IO32:\n#endif\n\tcase NVME_IOCTL_SUBMIT_IO:\n\t\treturn nvme_submit_io(ns, argp);\n\tcase NVME_IOCTL_IO64_CMD_VEC:\n\t\tflags |= NVME_IOCTL_VEC;\n\t\tfallthrough;\n\tcase NVME_IOCTL_IO64_CMD:\n\t\treturn nvme_user_cmd64(ns->ctrl, ns, argp, flags,\n\t\t\t\t       open_for_write);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nint nvme_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct nvme_ns *ns = bdev->bd_disk->private_data;\n\tbool open_for_write = mode & BLK_OPEN_WRITE;\n\tvoid __user *argp = (void __user *)arg;\n\tunsigned int flags = 0;\n\n\tif (bdev_is_partition(bdev))\n\t\tflags |= NVME_IOCTL_PARTITION;\n\n\tif (is_ctrl_ioctl(cmd))\n\t\treturn nvme_ctrl_ioctl(ns->ctrl, cmd, argp, open_for_write);\n\treturn nvme_ns_ioctl(ns, cmd, argp, flags, open_for_write);\n}\n\nlong nvme_ns_chr_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct nvme_ns *ns =\n\t\tcontainer_of(file_inode(file)->i_cdev, struct nvme_ns, cdev);\n\tbool open_for_write = file->f_mode & FMODE_WRITE;\n\tvoid __user *argp = (void __user *)arg;\n\n\tif (is_ctrl_ioctl(cmd))\n\t\treturn nvme_ctrl_ioctl(ns->ctrl, cmd, argp, open_for_write);\n\treturn nvme_ns_ioctl(ns, cmd, argp, 0, open_for_write);\n}\n\nstatic int nvme_uring_cmd_checks(unsigned int issue_flags)\n{\n\n\t \n\tif ((issue_flags & (IO_URING_F_SQE128|IO_URING_F_CQE32)) !=\n\t    (IO_URING_F_SQE128|IO_URING_F_CQE32))\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n\nstatic int nvme_ns_uring_cmd(struct nvme_ns *ns, struct io_uring_cmd *ioucmd,\n\t\t\t     unsigned int issue_flags)\n{\n\tstruct nvme_ctrl *ctrl = ns->ctrl;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct nvme_uring_cmd_pdu) > sizeof(ioucmd->pdu));\n\n\tret = nvme_uring_cmd_checks(issue_flags);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (ioucmd->cmd_op) {\n\tcase NVME_URING_CMD_IO:\n\t\tret = nvme_uring_cmd_io(ctrl, ns, ioucmd, issue_flags, false);\n\t\tbreak;\n\tcase NVME_URING_CMD_IO_VEC:\n\t\tret = nvme_uring_cmd_io(ctrl, ns, ioucmd, issue_flags, true);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t}\n\n\treturn ret;\n}\n\nint nvme_ns_chr_uring_cmd(struct io_uring_cmd *ioucmd, unsigned int issue_flags)\n{\n\tstruct nvme_ns *ns = container_of(file_inode(ioucmd->file)->i_cdev,\n\t\t\tstruct nvme_ns, cdev);\n\n\treturn nvme_ns_uring_cmd(ns, ioucmd, issue_flags);\n}\n\nint nvme_ns_chr_uring_cmd_iopoll(struct io_uring_cmd *ioucmd,\n\t\t\t\t struct io_comp_batch *iob,\n\t\t\t\t unsigned int poll_flags)\n{\n\tstruct request *req;\n\tint ret = 0;\n\n\tif (!(ioucmd->flags & IORING_URING_CMD_POLLED))\n\t\treturn 0;\n\n\treq = READ_ONCE(ioucmd->cookie);\n\tif (req && blk_rq_is_poll(req))\n\t\tret = blk_rq_poll(req, iob, poll_flags);\n\treturn ret;\n}\n#ifdef CONFIG_NVME_MULTIPATH\nstatic int nvme_ns_head_ctrl_ioctl(struct nvme_ns *ns, unsigned int cmd,\n\t\tvoid __user *argp, struct nvme_ns_head *head, int srcu_idx,\n\t\tbool open_for_write)\n\t__releases(&head->srcu)\n{\n\tstruct nvme_ctrl *ctrl = ns->ctrl;\n\tint ret;\n\n\tnvme_get_ctrl(ns->ctrl);\n\tsrcu_read_unlock(&head->srcu, srcu_idx);\n\tret = nvme_ctrl_ioctl(ns->ctrl, cmd, argp, open_for_write);\n\n\tnvme_put_ctrl(ctrl);\n\treturn ret;\n}\n\nint nvme_ns_head_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct nvme_ns_head *head = bdev->bd_disk->private_data;\n\tbool open_for_write = mode & BLK_OPEN_WRITE;\n\tvoid __user *argp = (void __user *)arg;\n\tstruct nvme_ns *ns;\n\tint srcu_idx, ret = -EWOULDBLOCK;\n\tunsigned int flags = 0;\n\n\tif (bdev_is_partition(bdev))\n\t\tflags |= NVME_IOCTL_PARTITION;\n\n\tsrcu_idx = srcu_read_lock(&head->srcu);\n\tns = nvme_find_path(head);\n\tif (!ns)\n\t\tgoto out_unlock;\n\n\t \n\tif (is_ctrl_ioctl(cmd))\n\t\treturn nvme_ns_head_ctrl_ioctl(ns, cmd, argp, head, srcu_idx,\n\t\t\t\t\t       open_for_write);\n\n\tret = nvme_ns_ioctl(ns, cmd, argp, flags, open_for_write);\nout_unlock:\n\tsrcu_read_unlock(&head->srcu, srcu_idx);\n\treturn ret;\n}\n\nlong nvme_ns_head_chr_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tbool open_for_write = file->f_mode & FMODE_WRITE;\n\tstruct cdev *cdev = file_inode(file)->i_cdev;\n\tstruct nvme_ns_head *head =\n\t\tcontainer_of(cdev, struct nvme_ns_head, cdev);\n\tvoid __user *argp = (void __user *)arg;\n\tstruct nvme_ns *ns;\n\tint srcu_idx, ret = -EWOULDBLOCK;\n\n\tsrcu_idx = srcu_read_lock(&head->srcu);\n\tns = nvme_find_path(head);\n\tif (!ns)\n\t\tgoto out_unlock;\n\n\tif (is_ctrl_ioctl(cmd))\n\t\treturn nvme_ns_head_ctrl_ioctl(ns, cmd, argp, head, srcu_idx,\n\t\t\t\topen_for_write);\n\n\tret = nvme_ns_ioctl(ns, cmd, argp, 0, open_for_write);\nout_unlock:\n\tsrcu_read_unlock(&head->srcu, srcu_idx);\n\treturn ret;\n}\n\nint nvme_ns_head_chr_uring_cmd(struct io_uring_cmd *ioucmd,\n\t\tunsigned int issue_flags)\n{\n\tstruct cdev *cdev = file_inode(ioucmd->file)->i_cdev;\n\tstruct nvme_ns_head *head = container_of(cdev, struct nvme_ns_head, cdev);\n\tint srcu_idx = srcu_read_lock(&head->srcu);\n\tstruct nvme_ns *ns = nvme_find_path(head);\n\tint ret = -EINVAL;\n\n\tif (ns)\n\t\tret = nvme_ns_uring_cmd(ns, ioucmd, issue_flags);\n\tsrcu_read_unlock(&head->srcu, srcu_idx);\n\treturn ret;\n}\n#endif  \n\nint nvme_dev_uring_cmd(struct io_uring_cmd *ioucmd, unsigned int issue_flags)\n{\n\tstruct nvme_ctrl *ctrl = ioucmd->file->private_data;\n\tint ret;\n\n\t \n\tif (issue_flags & IO_URING_F_IOPOLL)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nvme_uring_cmd_checks(issue_flags);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (ioucmd->cmd_op) {\n\tcase NVME_URING_CMD_ADMIN:\n\t\tret = nvme_uring_cmd_io(ctrl, NULL, ioucmd, issue_flags, false);\n\t\tbreak;\n\tcase NVME_URING_CMD_ADMIN_VEC:\n\t\tret = nvme_uring_cmd_io(ctrl, NULL, ioucmd, issue_flags, true);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t}\n\n\treturn ret;\n}\n\nstatic int nvme_dev_user_cmd(struct nvme_ctrl *ctrl, void __user *argp,\n\t\tbool open_for_write)\n{\n\tstruct nvme_ns *ns;\n\tint ret;\n\n\tdown_read(&ctrl->namespaces_rwsem);\n\tif (list_empty(&ctrl->namespaces)) {\n\t\tret = -ENOTTY;\n\t\tgoto out_unlock;\n\t}\n\n\tns = list_first_entry(&ctrl->namespaces, struct nvme_ns, list);\n\tif (ns != list_last_entry(&ctrl->namespaces, struct nvme_ns, list)) {\n\t\tdev_warn(ctrl->device,\n\t\t\t\"NVME_IOCTL_IO_CMD not supported when multiple namespaces present!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tdev_warn(ctrl->device,\n\t\t\"using deprecated NVME_IOCTL_IO_CMD ioctl on the char device!\\n\");\n\tkref_get(&ns->kref);\n\tup_read(&ctrl->namespaces_rwsem);\n\n\tret = nvme_user_cmd(ctrl, ns, argp, 0, open_for_write);\n\tnvme_put_ns(ns);\n\treturn ret;\n\nout_unlock:\n\tup_read(&ctrl->namespaces_rwsem);\n\treturn ret;\n}\n\nlong nvme_dev_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tbool open_for_write = file->f_mode & FMODE_WRITE;\n\tstruct nvme_ctrl *ctrl = file->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase NVME_IOCTL_ADMIN_CMD:\n\t\treturn nvme_user_cmd(ctrl, NULL, argp, 0, open_for_write);\n\tcase NVME_IOCTL_ADMIN64_CMD:\n\t\treturn nvme_user_cmd64(ctrl, NULL, argp, 0, open_for_write);\n\tcase NVME_IOCTL_IO_CMD:\n\t\treturn nvme_dev_user_cmd(ctrl, argp, open_for_write);\n\tcase NVME_IOCTL_RESET:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t\tdev_warn(ctrl->device, \"resetting controller\\n\");\n\t\treturn nvme_reset_ctrl_sync(ctrl);\n\tcase NVME_IOCTL_SUBSYS_RESET:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t\treturn nvme_reset_subsystem(ctrl);\n\tcase NVME_IOCTL_RESCAN:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t\tnvme_queue_scan(ctrl);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}