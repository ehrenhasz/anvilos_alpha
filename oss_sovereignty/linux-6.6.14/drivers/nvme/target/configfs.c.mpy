{
  "module_name": "configfs.c",
  "hash_id": "07eedd24088c8e8fbc5fd0b2b07073b0877045fa07f38c0c2270d7508472c3b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/target/configfs.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/kstrtox.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/ctype.h>\n#include <linux/pci.h>\n#include <linux/pci-p2pdma.h>\n#ifdef CONFIG_NVME_TARGET_AUTH\n#include <linux/nvme-auth.h>\n#endif\n#include <crypto/hash.h>\n#include <crypto/kpp.h>\n#include <linux/nospec.h>\n\n#include \"nvmet.h\"\n\nstatic const struct config_item_type nvmet_host_type;\nstatic const struct config_item_type nvmet_subsys_type;\n\nstatic LIST_HEAD(nvmet_ports_list);\nstruct list_head *nvmet_ports = &nvmet_ports_list;\n\nstruct nvmet_type_name_map {\n\tu8\t\ttype;\n\tconst char\t*name;\n};\n\nstatic struct nvmet_type_name_map nvmet_transport[] = {\n\t{ NVMF_TRTYPE_RDMA,\t\"rdma\" },\n\t{ NVMF_TRTYPE_FC,\t\"fc\" },\n\t{ NVMF_TRTYPE_TCP,\t\"tcp\" },\n\t{ NVMF_TRTYPE_LOOP,\t\"loop\" },\n};\n\nstatic const struct nvmet_type_name_map nvmet_addr_family[] = {\n\t{ NVMF_ADDR_FAMILY_PCI,\t\t\"pcie\" },\n\t{ NVMF_ADDR_FAMILY_IP4,\t\t\"ipv4\" },\n\t{ NVMF_ADDR_FAMILY_IP6,\t\t\"ipv6\" },\n\t{ NVMF_ADDR_FAMILY_IB,\t\t\"ib\" },\n\t{ NVMF_ADDR_FAMILY_FC,\t\t\"fc\" },\n\t{ NVMF_ADDR_FAMILY_LOOP,\t\"loop\" },\n};\n\nstatic bool nvmet_is_port_enabled(struct nvmet_port *p, const char *caller)\n{\n\tif (p->enabled)\n\t\tpr_err(\"Disable port '%u' before changing attribute in %s\\n\",\n\t\t       le16_to_cpu(p->disc_addr.portid), caller);\n\treturn p->enabled;\n}\n\n \nstatic ssize_t nvmet_addr_adrfam_show(struct config_item *item, char *page)\n{\n\tu8 adrfam = to_nvmet_port(item)->disc_addr.adrfam;\n\tint i;\n\n\tfor (i = 1; i < ARRAY_SIZE(nvmet_addr_family); i++) {\n\t\tif (nvmet_addr_family[i].type == adrfam)\n\t\t\treturn snprintf(page, PAGE_SIZE, \"%s\\n\",\n\t\t\t\t\tnvmet_addr_family[i].name);\n\t}\n\n\treturn snprintf(page, PAGE_SIZE, \"\\n\");\n}\n\nstatic ssize_t nvmet_addr_adrfam_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\tint i;\n\n\tif (nvmet_is_port_enabled(port, __func__))\n\t\treturn -EACCES;\n\n\tfor (i = 1; i < ARRAY_SIZE(nvmet_addr_family); i++) {\n\t\tif (sysfs_streq(page, nvmet_addr_family[i].name))\n\t\t\tgoto found;\n\t}\n\n\tpr_err(\"Invalid value '%s' for adrfam\\n\", page);\n\treturn -EINVAL;\n\nfound:\n\tport->disc_addr.adrfam = nvmet_addr_family[i].type;\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_, addr_adrfam);\n\nstatic ssize_t nvmet_addr_portid_show(struct config_item *item,\n\t\tchar *page)\n{\n\t__le16 portid = to_nvmet_port(item)->disc_addr.portid;\n\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\", le16_to_cpu(portid));\n}\n\nstatic ssize_t nvmet_addr_portid_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\tu16 portid = 0;\n\n\tif (kstrtou16(page, 0, &portid)) {\n\t\tpr_err(\"Invalid value '%s' for portid\\n\", page);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nvmet_is_port_enabled(port, __func__))\n\t\treturn -EACCES;\n\n\tport->disc_addr.portid = cpu_to_le16(portid);\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_, addr_portid);\n\nstatic ssize_t nvmet_addr_traddr_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", port->disc_addr.traddr);\n}\n\nstatic ssize_t nvmet_addr_traddr_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\n\tif (count > NVMF_TRADDR_SIZE) {\n\t\tpr_err(\"Invalid value '%s' for traddr\\n\", page);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nvmet_is_port_enabled(port, __func__))\n\t\treturn -EACCES;\n\n\tif (sscanf(page, \"%s\\n\", port->disc_addr.traddr) != 1)\n\t\treturn -EINVAL;\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_, addr_traddr);\n\nstatic const struct nvmet_type_name_map nvmet_addr_treq[] = {\n\t{ NVMF_TREQ_NOT_SPECIFIED,\t\"not specified\" },\n\t{ NVMF_TREQ_REQUIRED,\t\t\"required\" },\n\t{ NVMF_TREQ_NOT_REQUIRED,\t\"not required\" },\n};\n\nstatic ssize_t nvmet_addr_treq_show(struct config_item *item, char *page)\n{\n\tu8 treq = to_nvmet_port(item)->disc_addr.treq &\n\t\tNVME_TREQ_SECURE_CHANNEL_MASK;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nvmet_addr_treq); i++) {\n\t\tif (treq == nvmet_addr_treq[i].type)\n\t\t\treturn snprintf(page, PAGE_SIZE, \"%s\\n\",\n\t\t\t\t\tnvmet_addr_treq[i].name);\n\t}\n\n\treturn snprintf(page, PAGE_SIZE, \"\\n\");\n}\n\nstatic ssize_t nvmet_addr_treq_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\tu8 treq = port->disc_addr.treq & ~NVME_TREQ_SECURE_CHANNEL_MASK;\n\tint i;\n\n\tif (nvmet_is_port_enabled(port, __func__))\n\t\treturn -EACCES;\n\n\tfor (i = 0; i < ARRAY_SIZE(nvmet_addr_treq); i++) {\n\t\tif (sysfs_streq(page, nvmet_addr_treq[i].name))\n\t\t\tgoto found;\n\t}\n\n\tpr_err(\"Invalid value '%s' for treq\\n\", page);\n\treturn -EINVAL;\n\nfound:\n\ttreq |= nvmet_addr_treq[i].type;\n\tport->disc_addr.treq = treq;\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_, addr_treq);\n\nstatic ssize_t nvmet_addr_trsvcid_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", port->disc_addr.trsvcid);\n}\n\nstatic ssize_t nvmet_addr_trsvcid_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\n\tif (count > NVMF_TRSVCID_SIZE) {\n\t\tpr_err(\"Invalid value '%s' for trsvcid\\n\", page);\n\t\treturn -EINVAL;\n\t}\n\tif (nvmet_is_port_enabled(port, __func__))\n\t\treturn -EACCES;\n\n\tif (sscanf(page, \"%s\\n\", port->disc_addr.trsvcid) != 1)\n\t\treturn -EINVAL;\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_, addr_trsvcid);\n\nstatic ssize_t nvmet_param_inline_data_size_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\", port->inline_data_size);\n}\n\nstatic ssize_t nvmet_param_inline_data_size_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\tint ret;\n\n\tif (nvmet_is_port_enabled(port, __func__))\n\t\treturn -EACCES;\n\tret = kstrtoint(page, 0, &port->inline_data_size);\n\tif (ret) {\n\t\tpr_err(\"Invalid value '%s' for inline_data_size\\n\", page);\n\t\treturn -EINVAL;\n\t}\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_, param_inline_data_size);\n\n#ifdef CONFIG_BLK_DEV_INTEGRITY\nstatic ssize_t nvmet_param_pi_enable_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\", port->pi_enable);\n}\n\nstatic ssize_t nvmet_param_pi_enable_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\tbool val;\n\n\tif (kstrtobool(page, &val))\n\t\treturn -EINVAL;\n\n\tif (nvmet_is_port_enabled(port, __func__))\n\t\treturn -EACCES;\n\n\tport->pi_enable = val;\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_, param_pi_enable);\n#endif\n\nstatic ssize_t nvmet_addr_trtype_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nvmet_transport); i++) {\n\t\tif (port->disc_addr.trtype == nvmet_transport[i].type)\n\t\t\treturn snprintf(page, PAGE_SIZE,\n\t\t\t\t\t\"%s\\n\", nvmet_transport[i].name);\n\t}\n\n\treturn sprintf(page, \"\\n\");\n}\n\nstatic void nvmet_port_init_tsas_rdma(struct nvmet_port *port)\n{\n\tport->disc_addr.tsas.rdma.qptype = NVMF_RDMA_QPTYPE_CONNECTED;\n\tport->disc_addr.tsas.rdma.prtype = NVMF_RDMA_PRTYPE_NOT_SPECIFIED;\n\tport->disc_addr.tsas.rdma.cms = NVMF_RDMA_CMS_RDMA_CM;\n}\n\nstatic ssize_t nvmet_addr_trtype_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\tint i;\n\n\tif (nvmet_is_port_enabled(port, __func__))\n\t\treturn -EACCES;\n\n\tfor (i = 0; i < ARRAY_SIZE(nvmet_transport); i++) {\n\t\tif (sysfs_streq(page, nvmet_transport[i].name))\n\t\t\tgoto found;\n\t}\n\n\tpr_err(\"Invalid value '%s' for trtype\\n\", page);\n\treturn -EINVAL;\n\nfound:\n\tmemset(&port->disc_addr.tsas, 0, NVMF_TSAS_SIZE);\n\tport->disc_addr.trtype = nvmet_transport[i].type;\n\tif (port->disc_addr.trtype == NVMF_TRTYPE_RDMA)\n\t\tnvmet_port_init_tsas_rdma(port);\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_, addr_trtype);\n\n \nstatic ssize_t nvmet_ns_device_path_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%s\\n\", to_nvmet_ns(item)->device_path);\n}\n\nstatic ssize_t nvmet_ns_device_path_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_ns *ns = to_nvmet_ns(item);\n\tstruct nvmet_subsys *subsys = ns->subsys;\n\tsize_t len;\n\tint ret;\n\n\tmutex_lock(&subsys->lock);\n\tret = -EBUSY;\n\tif (ns->enabled)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tlen = strcspn(page, \"\\n\");\n\tif (!len)\n\t\tgoto out_unlock;\n\n\tkfree(ns->device_path);\n\tret = -ENOMEM;\n\tns->device_path = kmemdup_nul(page, len, GFP_KERNEL);\n\tif (!ns->device_path)\n\t\tgoto out_unlock;\n\n\tmutex_unlock(&subsys->lock);\n\treturn count;\n\nout_unlock:\n\tmutex_unlock(&subsys->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(nvmet_ns_, device_path);\n\n#ifdef CONFIG_PCI_P2PDMA\nstatic ssize_t nvmet_ns_p2pmem_show(struct config_item *item, char *page)\n{\n\tstruct nvmet_ns *ns = to_nvmet_ns(item);\n\n\treturn pci_p2pdma_enable_show(page, ns->p2p_dev, ns->use_p2pmem);\n}\n\nstatic ssize_t nvmet_ns_p2pmem_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_ns *ns = to_nvmet_ns(item);\n\tstruct pci_dev *p2p_dev = NULL;\n\tbool use_p2pmem;\n\tint ret = count;\n\tint error;\n\n\tmutex_lock(&ns->subsys->lock);\n\tif (ns->enabled) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\terror = pci_p2pdma_enable_store(page, &p2p_dev, &use_p2pmem);\n\tif (error) {\n\t\tret = error;\n\t\tgoto out_unlock;\n\t}\n\n\tns->use_p2pmem = use_p2pmem;\n\tpci_dev_put(ns->p2p_dev);\n\tns->p2p_dev = p2p_dev;\n\nout_unlock:\n\tmutex_unlock(&ns->subsys->lock);\n\n\treturn ret;\n}\n\nCONFIGFS_ATTR(nvmet_ns_, p2pmem);\n#endif  \n\nstatic ssize_t nvmet_ns_device_uuid_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%pUb\\n\", &to_nvmet_ns(item)->uuid);\n}\n\nstatic ssize_t nvmet_ns_device_uuid_store(struct config_item *item,\n\t\t\t\t\t  const char *page, size_t count)\n{\n\tstruct nvmet_ns *ns = to_nvmet_ns(item);\n\tstruct nvmet_subsys *subsys = ns->subsys;\n\tint ret = 0;\n\n\tmutex_lock(&subsys->lock);\n\tif (ns->enabled) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tif (uuid_parse(page, &ns->uuid))\n\t\tret = -EINVAL;\n\nout_unlock:\n\tmutex_unlock(&subsys->lock);\n\treturn ret ? ret : count;\n}\n\nCONFIGFS_ATTR(nvmet_ns_, device_uuid);\n\nstatic ssize_t nvmet_ns_device_nguid_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%pUb\\n\", &to_nvmet_ns(item)->nguid);\n}\n\nstatic ssize_t nvmet_ns_device_nguid_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_ns *ns = to_nvmet_ns(item);\n\tstruct nvmet_subsys *subsys = ns->subsys;\n\tu8 nguid[16];\n\tconst char *p = page;\n\tint i;\n\tint ret = 0;\n\n\tmutex_lock(&subsys->lock);\n\tif (ns->enabled) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (p + 2 > page + count) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (!isxdigit(p[0]) || !isxdigit(p[1])) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tnguid[i] = (hex_to_bin(p[0]) << 4) | hex_to_bin(p[1]);\n\t\tp += 2;\n\n\t\tif (*p == '-' || *p == ':')\n\t\t\tp++;\n\t}\n\n\tmemcpy(&ns->nguid, nguid, sizeof(nguid));\nout_unlock:\n\tmutex_unlock(&subsys->lock);\n\treturn ret ? ret : count;\n}\n\nCONFIGFS_ATTR(nvmet_ns_, device_nguid);\n\nstatic ssize_t nvmet_ns_ana_grpid_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", to_nvmet_ns(item)->anagrpid);\n}\n\nstatic ssize_t nvmet_ns_ana_grpid_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_ns *ns = to_nvmet_ns(item);\n\tu32 oldgrpid, newgrpid;\n\tint ret;\n\n\tret = kstrtou32(page, 0, &newgrpid);\n\tif (ret)\n\t\treturn ret;\n\n\tif (newgrpid < 1 || newgrpid > NVMET_MAX_ANAGRPS)\n\t\treturn -EINVAL;\n\n\tdown_write(&nvmet_ana_sem);\n\toldgrpid = ns->anagrpid;\n\tnewgrpid = array_index_nospec(newgrpid, NVMET_MAX_ANAGRPS);\n\tnvmet_ana_group_enabled[newgrpid]++;\n\tns->anagrpid = newgrpid;\n\tnvmet_ana_group_enabled[oldgrpid]--;\n\tnvmet_ana_chgcnt++;\n\tup_write(&nvmet_ana_sem);\n\n\tnvmet_send_ana_event(ns->subsys, NULL);\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_ns_, ana_grpid);\n\nstatic ssize_t nvmet_ns_enable_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", to_nvmet_ns(item)->enabled);\n}\n\nstatic ssize_t nvmet_ns_enable_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_ns *ns = to_nvmet_ns(item);\n\tbool enable;\n\tint ret = 0;\n\n\tif (kstrtobool(page, &enable))\n\t\treturn -EINVAL;\n\n\tif (enable)\n\t\tret = nvmet_ns_enable(ns);\n\telse\n\t\tnvmet_ns_disable(ns);\n\n\treturn ret ? ret : count;\n}\n\nCONFIGFS_ATTR(nvmet_ns_, enable);\n\nstatic ssize_t nvmet_ns_buffered_io_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", to_nvmet_ns(item)->buffered_io);\n}\n\nstatic ssize_t nvmet_ns_buffered_io_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_ns *ns = to_nvmet_ns(item);\n\tbool val;\n\n\tif (kstrtobool(page, &val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ns->subsys->lock);\n\tif (ns->enabled) {\n\t\tpr_err(\"disable ns before setting buffered_io value.\\n\");\n\t\tmutex_unlock(&ns->subsys->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tns->buffered_io = val;\n\tmutex_unlock(&ns->subsys->lock);\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_ns_, buffered_io);\n\nstatic ssize_t nvmet_ns_revalidate_size_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_ns *ns = to_nvmet_ns(item);\n\tbool val;\n\n\tif (kstrtobool(page, &val))\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ns->subsys->lock);\n\tif (!ns->enabled) {\n\t\tpr_err(\"enable ns before revalidate.\\n\");\n\t\tmutex_unlock(&ns->subsys->lock);\n\t\treturn -EINVAL;\n\t}\n\tif (nvmet_ns_revalidate(ns))\n\t\tnvmet_ns_changed(ns->subsys, ns->nsid);\n\tmutex_unlock(&ns->subsys->lock);\n\treturn count;\n}\n\nCONFIGFS_ATTR_WO(nvmet_ns_, revalidate_size);\n\nstatic struct configfs_attribute *nvmet_ns_attrs[] = {\n\t&nvmet_ns_attr_device_path,\n\t&nvmet_ns_attr_device_nguid,\n\t&nvmet_ns_attr_device_uuid,\n\t&nvmet_ns_attr_ana_grpid,\n\t&nvmet_ns_attr_enable,\n\t&nvmet_ns_attr_buffered_io,\n\t&nvmet_ns_attr_revalidate_size,\n#ifdef CONFIG_PCI_P2PDMA\n\t&nvmet_ns_attr_p2pmem,\n#endif\n\tNULL,\n};\n\nstatic void nvmet_ns_release(struct config_item *item)\n{\n\tstruct nvmet_ns *ns = to_nvmet_ns(item);\n\n\tnvmet_ns_free(ns);\n}\n\nstatic struct configfs_item_operations nvmet_ns_item_ops = {\n\t.release\t\t= nvmet_ns_release,\n};\n\nstatic const struct config_item_type nvmet_ns_type = {\n\t.ct_item_ops\t\t= &nvmet_ns_item_ops,\n\t.ct_attrs\t\t= nvmet_ns_attrs,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic struct config_group *nvmet_ns_make(struct config_group *group,\n\t\tconst char *name)\n{\n\tstruct nvmet_subsys *subsys = namespaces_to_subsys(&group->cg_item);\n\tstruct nvmet_ns *ns;\n\tint ret;\n\tu32 nsid;\n\n\tret = kstrtou32(name, 0, &nsid);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (nsid == 0 || nsid == NVME_NSID_ALL) {\n\t\tpr_err(\"invalid nsid %#x\", nsid);\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\tns = nvmet_ns_alloc(subsys, nsid);\n\tif (!ns)\n\t\tgoto out;\n\tconfig_group_init_type_name(&ns->group, name, &nvmet_ns_type);\n\n\tpr_info(\"adding nsid %d to subsystem %s\\n\", nsid, subsys->subsysnqn);\n\n\treturn &ns->group;\nout:\n\treturn ERR_PTR(ret);\n}\n\nstatic struct configfs_group_operations nvmet_namespaces_group_ops = {\n\t.make_group\t\t= nvmet_ns_make,\n};\n\nstatic const struct config_item_type nvmet_namespaces_type = {\n\t.ct_group_ops\t\t= &nvmet_namespaces_group_ops,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_NVME_TARGET_PASSTHRU\n\nstatic ssize_t nvmet_passthru_device_path_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item->ci_parent);\n\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", subsys->passthru_ctrl_path);\n}\n\nstatic ssize_t nvmet_passthru_device_path_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item->ci_parent);\n\tsize_t len;\n\tint ret;\n\n\tmutex_lock(&subsys->lock);\n\n\tret = -EBUSY;\n\tif (subsys->passthru_ctrl)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tlen = strcspn(page, \"\\n\");\n\tif (!len)\n\t\tgoto out_unlock;\n\n\tkfree(subsys->passthru_ctrl_path);\n\tret = -ENOMEM;\n\tsubsys->passthru_ctrl_path = kstrndup(page, len, GFP_KERNEL);\n\tif (!subsys->passthru_ctrl_path)\n\t\tgoto out_unlock;\n\n\tmutex_unlock(&subsys->lock);\n\n\treturn count;\nout_unlock:\n\tmutex_unlock(&subsys->lock);\n\treturn ret;\n}\nCONFIGFS_ATTR(nvmet_passthru_, device_path);\n\nstatic ssize_t nvmet_passthru_enable_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item->ci_parent);\n\n\treturn sprintf(page, \"%d\\n\", subsys->passthru_ctrl ? 1 : 0);\n}\n\nstatic ssize_t nvmet_passthru_enable_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item->ci_parent);\n\tbool enable;\n\tint ret = 0;\n\n\tif (kstrtobool(page, &enable))\n\t\treturn -EINVAL;\n\n\tif (enable)\n\t\tret = nvmet_passthru_ctrl_enable(subsys);\n\telse\n\t\tnvmet_passthru_ctrl_disable(subsys);\n\n\treturn ret ? ret : count;\n}\nCONFIGFS_ATTR(nvmet_passthru_, enable);\n\nstatic ssize_t nvmet_passthru_admin_timeout_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page, \"%u\\n\", to_subsys(item->ci_parent)->admin_timeout);\n}\n\nstatic ssize_t nvmet_passthru_admin_timeout_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item->ci_parent);\n\tunsigned int timeout;\n\n\tif (kstrtouint(page, 0, &timeout))\n\t\treturn -EINVAL;\n\tsubsys->admin_timeout = timeout;\n\treturn count;\n}\nCONFIGFS_ATTR(nvmet_passthru_, admin_timeout);\n\nstatic ssize_t nvmet_passthru_io_timeout_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page, \"%u\\n\", to_subsys(item->ci_parent)->io_timeout);\n}\n\nstatic ssize_t nvmet_passthru_io_timeout_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item->ci_parent);\n\tunsigned int timeout;\n\n\tif (kstrtouint(page, 0, &timeout))\n\t\treturn -EINVAL;\n\tsubsys->io_timeout = timeout;\n\treturn count;\n}\nCONFIGFS_ATTR(nvmet_passthru_, io_timeout);\n\nstatic ssize_t nvmet_passthru_clear_ids_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page, \"%u\\n\", to_subsys(item->ci_parent)->clear_ids);\n}\n\nstatic ssize_t nvmet_passthru_clear_ids_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item->ci_parent);\n\tunsigned int clear_ids;\n\n\tif (kstrtouint(page, 0, &clear_ids))\n\t\treturn -EINVAL;\n\tsubsys->clear_ids = clear_ids;\n\treturn count;\n}\nCONFIGFS_ATTR(nvmet_passthru_, clear_ids);\n\nstatic struct configfs_attribute *nvmet_passthru_attrs[] = {\n\t&nvmet_passthru_attr_device_path,\n\t&nvmet_passthru_attr_enable,\n\t&nvmet_passthru_attr_admin_timeout,\n\t&nvmet_passthru_attr_io_timeout,\n\t&nvmet_passthru_attr_clear_ids,\n\tNULL,\n};\n\nstatic const struct config_item_type nvmet_passthru_type = {\n\t.ct_attrs\t\t= nvmet_passthru_attrs,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic void nvmet_add_passthru_group(struct nvmet_subsys *subsys)\n{\n\tconfig_group_init_type_name(&subsys->passthru_group,\n\t\t\t\t    \"passthru\", &nvmet_passthru_type);\n\tconfigfs_add_default_group(&subsys->passthru_group,\n\t\t\t\t   &subsys->group);\n}\n\n#else  \n\nstatic void nvmet_add_passthru_group(struct nvmet_subsys *subsys)\n{\n}\n\n#endif  \n\nstatic int nvmet_port_subsys_allow_link(struct config_item *parent,\n\t\tstruct config_item *target)\n{\n\tstruct nvmet_port *port = to_nvmet_port(parent->ci_parent);\n\tstruct nvmet_subsys *subsys;\n\tstruct nvmet_subsys_link *link, *p;\n\tint ret;\n\n\tif (target->ci_type != &nvmet_subsys_type) {\n\t\tpr_err(\"can only link subsystems into the subsystems dir.!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsubsys = to_subsys(target);\n\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\tlink->subsys = subsys;\n\n\tdown_write(&nvmet_config_sem);\n\tret = -EEXIST;\n\tlist_for_each_entry(p, &port->subsystems, entry) {\n\t\tif (p->subsys == subsys)\n\t\t\tgoto out_free_link;\n\t}\n\n\tif (list_empty(&port->subsystems)) {\n\t\tret = nvmet_enable_port(port);\n\t\tif (ret)\n\t\t\tgoto out_free_link;\n\t}\n\n\tlist_add_tail(&link->entry, &port->subsystems);\n\tnvmet_port_disc_changed(port, subsys);\n\n\tup_write(&nvmet_config_sem);\n\treturn 0;\n\nout_free_link:\n\tup_write(&nvmet_config_sem);\n\tkfree(link);\n\treturn ret;\n}\n\nstatic void nvmet_port_subsys_drop_link(struct config_item *parent,\n\t\tstruct config_item *target)\n{\n\tstruct nvmet_port *port = to_nvmet_port(parent->ci_parent);\n\tstruct nvmet_subsys *subsys = to_subsys(target);\n\tstruct nvmet_subsys_link *p;\n\n\tdown_write(&nvmet_config_sem);\n\tlist_for_each_entry(p, &port->subsystems, entry) {\n\t\tif (p->subsys == subsys)\n\t\t\tgoto found;\n\t}\n\tup_write(&nvmet_config_sem);\n\treturn;\n\nfound:\n\tlist_del(&p->entry);\n\tnvmet_port_del_ctrls(port, subsys);\n\tnvmet_port_disc_changed(port, subsys);\n\n\tif (list_empty(&port->subsystems))\n\t\tnvmet_disable_port(port);\n\tup_write(&nvmet_config_sem);\n\tkfree(p);\n}\n\nstatic struct configfs_item_operations nvmet_port_subsys_item_ops = {\n\t.allow_link\t\t= nvmet_port_subsys_allow_link,\n\t.drop_link\t\t= nvmet_port_subsys_drop_link,\n};\n\nstatic const struct config_item_type nvmet_port_subsys_type = {\n\t.ct_item_ops\t\t= &nvmet_port_subsys_item_ops,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic int nvmet_allowed_hosts_allow_link(struct config_item *parent,\n\t\tstruct config_item *target)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(parent->ci_parent);\n\tstruct nvmet_host *host;\n\tstruct nvmet_host_link *link, *p;\n\tint ret;\n\n\tif (target->ci_type != &nvmet_host_type) {\n\t\tpr_err(\"can only link hosts into the allowed_hosts directory!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thost = to_host(target);\n\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\tlink->host = host;\n\n\tdown_write(&nvmet_config_sem);\n\tret = -EINVAL;\n\tif (subsys->allow_any_host) {\n\t\tpr_err(\"can't add hosts when allow_any_host is set!\\n\");\n\t\tgoto out_free_link;\n\t}\n\n\tret = -EEXIST;\n\tlist_for_each_entry(p, &subsys->hosts, entry) {\n\t\tif (!strcmp(nvmet_host_name(p->host), nvmet_host_name(host)))\n\t\t\tgoto out_free_link;\n\t}\n\tlist_add_tail(&link->entry, &subsys->hosts);\n\tnvmet_subsys_disc_changed(subsys, host);\n\n\tup_write(&nvmet_config_sem);\n\treturn 0;\nout_free_link:\n\tup_write(&nvmet_config_sem);\n\tkfree(link);\n\treturn ret;\n}\n\nstatic void nvmet_allowed_hosts_drop_link(struct config_item *parent,\n\t\tstruct config_item *target)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(parent->ci_parent);\n\tstruct nvmet_host *host = to_host(target);\n\tstruct nvmet_host_link *p;\n\n\tdown_write(&nvmet_config_sem);\n\tlist_for_each_entry(p, &subsys->hosts, entry) {\n\t\tif (!strcmp(nvmet_host_name(p->host), nvmet_host_name(host)))\n\t\t\tgoto found;\n\t}\n\tup_write(&nvmet_config_sem);\n\treturn;\n\nfound:\n\tlist_del(&p->entry);\n\tnvmet_subsys_disc_changed(subsys, host);\n\n\tup_write(&nvmet_config_sem);\n\tkfree(p);\n}\n\nstatic struct configfs_item_operations nvmet_allowed_hosts_item_ops = {\n\t.allow_link\t\t= nvmet_allowed_hosts_allow_link,\n\t.drop_link\t\t= nvmet_allowed_hosts_drop_link,\n};\n\nstatic const struct config_item_type nvmet_allowed_hosts_type = {\n\t.ct_item_ops\t\t= &nvmet_allowed_hosts_item_ops,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic ssize_t nvmet_subsys_attr_allow_any_host_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\",\n\t\tto_subsys(item)->allow_any_host);\n}\n\nstatic ssize_t nvmet_subsys_attr_allow_any_host_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\tbool allow_any_host;\n\tint ret = 0;\n\n\tif (kstrtobool(page, &allow_any_host))\n\t\treturn -EINVAL;\n\n\tdown_write(&nvmet_config_sem);\n\tif (allow_any_host && !list_empty(&subsys->hosts)) {\n\t\tpr_err(\"Can't set allow_any_host when explicit hosts are set!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (subsys->allow_any_host != allow_any_host) {\n\t\tsubsys->allow_any_host = allow_any_host;\n\t\tnvmet_subsys_disc_changed(subsys, NULL);\n\t}\n\nout_unlock:\n\tup_write(&nvmet_config_sem);\n\treturn ret ? ret : count;\n}\n\nCONFIGFS_ATTR(nvmet_subsys_, attr_allow_any_host);\n\nstatic ssize_t nvmet_subsys_attr_version_show(struct config_item *item,\n\t\t\t\t\t      char *page)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\n\tif (NVME_TERTIARY(subsys->ver))\n\t\treturn snprintf(page, PAGE_SIZE, \"%llu.%llu.%llu\\n\",\n\t\t\t\tNVME_MAJOR(subsys->ver),\n\t\t\t\tNVME_MINOR(subsys->ver),\n\t\t\t\tNVME_TERTIARY(subsys->ver));\n\n\treturn snprintf(page, PAGE_SIZE, \"%llu.%llu\\n\",\n\t\t\tNVME_MAJOR(subsys->ver),\n\t\t\tNVME_MINOR(subsys->ver));\n}\n\nstatic ssize_t\nnvmet_subsys_attr_version_store_locked(struct nvmet_subsys *subsys,\n\t\tconst char *page, size_t count)\n{\n\tint major, minor, tertiary = 0;\n\tint ret;\n\n\tif (subsys->subsys_discovered) {\n\t\tif (NVME_TERTIARY(subsys->ver))\n\t\t\tpr_err(\"Can't set version number. %llu.%llu.%llu is already assigned\\n\",\n\t\t\t       NVME_MAJOR(subsys->ver),\n\t\t\t       NVME_MINOR(subsys->ver),\n\t\t\t       NVME_TERTIARY(subsys->ver));\n\t\telse\n\t\t\tpr_err(\"Can't set version number. %llu.%llu is already assigned\\n\",\n\t\t\t       NVME_MAJOR(subsys->ver),\n\t\t\t       NVME_MINOR(subsys->ver));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (nvmet_is_passthru_subsys(subsys))\n\t\treturn -EINVAL;\n\n\tret = sscanf(page, \"%d.%d.%d\\n\", &major, &minor, &tertiary);\n\tif (ret != 2 && ret != 3)\n\t\treturn -EINVAL;\n\n\tsubsys->ver = NVME_VS(major, minor, tertiary);\n\n\treturn count;\n}\n\nstatic ssize_t nvmet_subsys_attr_version_store(struct config_item *item,\n\t\t\t\t\t       const char *page, size_t count)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\tssize_t ret;\n\n\tdown_write(&nvmet_config_sem);\n\tmutex_lock(&subsys->lock);\n\tret = nvmet_subsys_attr_version_store_locked(subsys, page, count);\n\tmutex_unlock(&subsys->lock);\n\tup_write(&nvmet_config_sem);\n\n\treturn ret;\n}\nCONFIGFS_ATTR(nvmet_subsys_, attr_version);\n\n \nstatic bool nvmet_is_ascii(const char c)\n{\n\treturn c >= 0x20 && c <= 0x7e;\n}\n\nstatic ssize_t nvmet_subsys_attr_serial_show(struct config_item *item,\n\t\t\t\t\t     char *page)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\n\treturn snprintf(page, PAGE_SIZE, \"%.*s\\n\",\n\t\t\tNVMET_SN_MAX_SIZE, subsys->serial);\n}\n\nstatic ssize_t\nnvmet_subsys_attr_serial_store_locked(struct nvmet_subsys *subsys,\n\t\tconst char *page, size_t count)\n{\n\tint pos, len = strcspn(page, \"\\n\");\n\n\tif (subsys->subsys_discovered) {\n\t\tpr_err(\"Can't set serial number. %s is already assigned\\n\",\n\t\t       subsys->serial);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!len || len > NVMET_SN_MAX_SIZE) {\n\t\tpr_err(\"Serial Number can not be empty or exceed %d Bytes\\n\",\n\t\t       NVMET_SN_MAX_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (pos = 0; pos < len; pos++) {\n\t\tif (!nvmet_is_ascii(page[pos])) {\n\t\t\tpr_err(\"Serial Number must contain only ASCII strings\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmemcpy_and_pad(subsys->serial, NVMET_SN_MAX_SIZE, page, len, ' ');\n\n\treturn count;\n}\n\nstatic ssize_t nvmet_subsys_attr_serial_store(struct config_item *item,\n\t\t\t\t\t      const char *page, size_t count)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\tssize_t ret;\n\n\tdown_write(&nvmet_config_sem);\n\tmutex_lock(&subsys->lock);\n\tret = nvmet_subsys_attr_serial_store_locked(subsys, page, count);\n\tmutex_unlock(&subsys->lock);\n\tup_write(&nvmet_config_sem);\n\n\treturn ret;\n}\nCONFIGFS_ATTR(nvmet_subsys_, attr_serial);\n\nstatic ssize_t nvmet_subsys_attr_cntlid_min_show(struct config_item *item,\n\t\t\t\t\t\t char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%u\\n\", to_subsys(item)->cntlid_min);\n}\n\nstatic ssize_t nvmet_subsys_attr_cntlid_min_store(struct config_item *item,\n\t\t\t\t\t\t  const char *page, size_t cnt)\n{\n\tu16 cntlid_min;\n\n\tif (sscanf(page, \"%hu\\n\", &cntlid_min) != 1)\n\t\treturn -EINVAL;\n\n\tif (cntlid_min == 0)\n\t\treturn -EINVAL;\n\n\tdown_write(&nvmet_config_sem);\n\tif (cntlid_min >= to_subsys(item)->cntlid_max)\n\t\tgoto out_unlock;\n\tto_subsys(item)->cntlid_min = cntlid_min;\n\tup_write(&nvmet_config_sem);\n\treturn cnt;\n\nout_unlock:\n\tup_write(&nvmet_config_sem);\n\treturn -EINVAL;\n}\nCONFIGFS_ATTR(nvmet_subsys_, attr_cntlid_min);\n\nstatic ssize_t nvmet_subsys_attr_cntlid_max_show(struct config_item *item,\n\t\t\t\t\t\t char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%u\\n\", to_subsys(item)->cntlid_max);\n}\n\nstatic ssize_t nvmet_subsys_attr_cntlid_max_store(struct config_item *item,\n\t\t\t\t\t\t  const char *page, size_t cnt)\n{\n\tu16 cntlid_max;\n\n\tif (sscanf(page, \"%hu\\n\", &cntlid_max) != 1)\n\t\treturn -EINVAL;\n\n\tif (cntlid_max == 0)\n\t\treturn -EINVAL;\n\n\tdown_write(&nvmet_config_sem);\n\tif (cntlid_max <= to_subsys(item)->cntlid_min)\n\t\tgoto out_unlock;\n\tto_subsys(item)->cntlid_max = cntlid_max;\n\tup_write(&nvmet_config_sem);\n\treturn cnt;\n\nout_unlock:\n\tup_write(&nvmet_config_sem);\n\treturn -EINVAL;\n}\nCONFIGFS_ATTR(nvmet_subsys_, attr_cntlid_max);\n\nstatic ssize_t nvmet_subsys_attr_model_show(struct config_item *item,\n\t\t\t\t\t    char *page)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", subsys->model_number);\n}\n\nstatic ssize_t nvmet_subsys_attr_model_store_locked(struct nvmet_subsys *subsys,\n\t\tconst char *page, size_t count)\n{\n\tint pos = 0, len;\n\tchar *val;\n\n\tif (subsys->subsys_discovered) {\n\t\tpr_err(\"Can't set model number. %s is already assigned\\n\",\n\t\t       subsys->model_number);\n\t\treturn -EINVAL;\n\t}\n\n\tlen = strcspn(page, \"\\n\");\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (len > NVMET_MN_MAX_SIZE) {\n\t\tpr_err(\"Model number size can not exceed %d Bytes\\n\",\n\t\t       NVMET_MN_MAX_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (pos = 0; pos < len; pos++) {\n\t\tif (!nvmet_is_ascii(page[pos]))\n\t\t\treturn -EINVAL;\n\t}\n\n\tval = kmemdup_nul(page, len, GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\tkfree(subsys->model_number);\n\tsubsys->model_number = val;\n\treturn count;\n}\n\nstatic ssize_t nvmet_subsys_attr_model_store(struct config_item *item,\n\t\t\t\t\t     const char *page, size_t count)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\tssize_t ret;\n\n\tdown_write(&nvmet_config_sem);\n\tmutex_lock(&subsys->lock);\n\tret = nvmet_subsys_attr_model_store_locked(subsys, page, count);\n\tmutex_unlock(&subsys->lock);\n\tup_write(&nvmet_config_sem);\n\n\treturn ret;\n}\nCONFIGFS_ATTR(nvmet_subsys_, attr_model);\n\nstatic ssize_t nvmet_subsys_attr_ieee_oui_show(struct config_item *item,\n\t\t\t\t\t    char *page)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\n\treturn sysfs_emit(page, \"0x%06x\\n\", subsys->ieee_oui);\n}\n\nstatic ssize_t nvmet_subsys_attr_ieee_oui_store_locked(struct nvmet_subsys *subsys,\n\t\tconst char *page, size_t count)\n{\n\tuint32_t val = 0;\n\tint ret;\n\n\tif (subsys->subsys_discovered) {\n\t\tpr_err(\"Can't set IEEE OUI. 0x%06x is already assigned\\n\",\n\t\t      subsys->ieee_oui);\n\t\treturn -EINVAL;\n\t}\n\n\tret = kstrtou32(page, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val >= 0x1000000)\n\t\treturn -EINVAL;\n\n\tsubsys->ieee_oui = val;\n\n\treturn count;\n}\n\nstatic ssize_t nvmet_subsys_attr_ieee_oui_store(struct config_item *item,\n\t\t\t\t\t     const char *page, size_t count)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\tssize_t ret;\n\n\tdown_write(&nvmet_config_sem);\n\tmutex_lock(&subsys->lock);\n\tret = nvmet_subsys_attr_ieee_oui_store_locked(subsys, page, count);\n\tmutex_unlock(&subsys->lock);\n\tup_write(&nvmet_config_sem);\n\n\treturn ret;\n}\nCONFIGFS_ATTR(nvmet_subsys_, attr_ieee_oui);\n\nstatic ssize_t nvmet_subsys_attr_firmware_show(struct config_item *item,\n\t\t\t\t\t    char *page)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\n\treturn sysfs_emit(page, \"%s\\n\", subsys->firmware_rev);\n}\n\nstatic ssize_t nvmet_subsys_attr_firmware_store_locked(struct nvmet_subsys *subsys,\n\t\tconst char *page, size_t count)\n{\n\tint pos = 0, len;\n\tchar *val;\n\n\tif (subsys->subsys_discovered) {\n\t\tpr_err(\"Can't set firmware revision. %s is already assigned\\n\",\n\t\t       subsys->firmware_rev);\n\t\treturn -EINVAL;\n\t}\n\n\tlen = strcspn(page, \"\\n\");\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (len > NVMET_FR_MAX_SIZE) {\n\t\tpr_err(\"Firmware revision size can not exceed %d Bytes\\n\",\n\t\t       NVMET_FR_MAX_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (pos = 0; pos < len; pos++) {\n\t\tif (!nvmet_is_ascii(page[pos]))\n\t\t\treturn -EINVAL;\n\t}\n\n\tval = kmemdup_nul(page, len, GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\n\tkfree(subsys->firmware_rev);\n\n\tsubsys->firmware_rev = val;\n\n\treturn count;\n}\n\nstatic ssize_t nvmet_subsys_attr_firmware_store(struct config_item *item,\n\t\t\t\t\t     const char *page, size_t count)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\tssize_t ret;\n\n\tdown_write(&nvmet_config_sem);\n\tmutex_lock(&subsys->lock);\n\tret = nvmet_subsys_attr_firmware_store_locked(subsys, page, count);\n\tmutex_unlock(&subsys->lock);\n\tup_write(&nvmet_config_sem);\n\n\treturn ret;\n}\nCONFIGFS_ATTR(nvmet_subsys_, attr_firmware);\n\n#ifdef CONFIG_BLK_DEV_INTEGRITY\nstatic ssize_t nvmet_subsys_attr_pi_enable_show(struct config_item *item,\n\t\t\t\t\t\tchar *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\", to_subsys(item)->pi_support);\n}\n\nstatic ssize_t nvmet_subsys_attr_pi_enable_store(struct config_item *item,\n\t\t\t\t\t\t const char *page, size_t count)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\tbool pi_enable;\n\n\tif (kstrtobool(page, &pi_enable))\n\t\treturn -EINVAL;\n\n\tsubsys->pi_support = pi_enable;\n\treturn count;\n}\nCONFIGFS_ATTR(nvmet_subsys_, attr_pi_enable);\n#endif\n\nstatic ssize_t nvmet_subsys_attr_qid_max_show(struct config_item *item,\n\t\t\t\t\t      char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%u\\n\", to_subsys(item)->max_qid);\n}\n\nstatic ssize_t nvmet_subsys_attr_qid_max_store(struct config_item *item,\n\t\t\t\t\t       const char *page, size_t cnt)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\tstruct nvmet_ctrl *ctrl;\n\tu16 qid_max;\n\n\tif (sscanf(page, \"%hu\\n\", &qid_max) != 1)\n\t\treturn -EINVAL;\n\n\tif (qid_max < 1 || qid_max > NVMET_NR_QUEUES)\n\t\treturn -EINVAL;\n\n\tdown_write(&nvmet_config_sem);\n\tsubsys->max_qid = qid_max;\n\n\t \n\tlist_for_each_entry(ctrl, &subsys->ctrls, subsys_entry)\n\t\tctrl->ops->delete_ctrl(ctrl);\n\tup_write(&nvmet_config_sem);\n\n\treturn cnt;\n}\nCONFIGFS_ATTR(nvmet_subsys_, attr_qid_max);\n\nstatic struct configfs_attribute *nvmet_subsys_attrs[] = {\n\t&nvmet_subsys_attr_attr_allow_any_host,\n\t&nvmet_subsys_attr_attr_version,\n\t&nvmet_subsys_attr_attr_serial,\n\t&nvmet_subsys_attr_attr_cntlid_min,\n\t&nvmet_subsys_attr_attr_cntlid_max,\n\t&nvmet_subsys_attr_attr_model,\n\t&nvmet_subsys_attr_attr_qid_max,\n\t&nvmet_subsys_attr_attr_ieee_oui,\n\t&nvmet_subsys_attr_attr_firmware,\n#ifdef CONFIG_BLK_DEV_INTEGRITY\n\t&nvmet_subsys_attr_attr_pi_enable,\n#endif\n\tNULL,\n};\n\n \nstatic void nvmet_subsys_release(struct config_item *item)\n{\n\tstruct nvmet_subsys *subsys = to_subsys(item);\n\n\tnvmet_subsys_del_ctrls(subsys);\n\tnvmet_subsys_put(subsys);\n}\n\nstatic struct configfs_item_operations nvmet_subsys_item_ops = {\n\t.release\t\t= nvmet_subsys_release,\n};\n\nstatic const struct config_item_type nvmet_subsys_type = {\n\t.ct_item_ops\t\t= &nvmet_subsys_item_ops,\n\t.ct_attrs\t\t= nvmet_subsys_attrs,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic struct config_group *nvmet_subsys_make(struct config_group *group,\n\t\tconst char *name)\n{\n\tstruct nvmet_subsys *subsys;\n\n\tif (sysfs_streq(name, NVME_DISC_SUBSYS_NAME)) {\n\t\tpr_err(\"can't create discovery subsystem through configfs\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsubsys = nvmet_subsys_alloc(name, NVME_NQN_NVME);\n\tif (IS_ERR(subsys))\n\t\treturn ERR_CAST(subsys);\n\n\tconfig_group_init_type_name(&subsys->group, name, &nvmet_subsys_type);\n\n\tconfig_group_init_type_name(&subsys->namespaces_group,\n\t\t\t\"namespaces\", &nvmet_namespaces_type);\n\tconfigfs_add_default_group(&subsys->namespaces_group, &subsys->group);\n\n\tconfig_group_init_type_name(&subsys->allowed_hosts_group,\n\t\t\t\"allowed_hosts\", &nvmet_allowed_hosts_type);\n\tconfigfs_add_default_group(&subsys->allowed_hosts_group,\n\t\t\t&subsys->group);\n\n\tnvmet_add_passthru_group(subsys);\n\n\treturn &subsys->group;\n}\n\nstatic struct configfs_group_operations nvmet_subsystems_group_ops = {\n\t.make_group\t\t= nvmet_subsys_make,\n};\n\nstatic const struct config_item_type nvmet_subsystems_type = {\n\t.ct_group_ops\t\t= &nvmet_subsystems_group_ops,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic ssize_t nvmet_referral_enable_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\", to_nvmet_port(item)->enabled);\n}\n\nstatic ssize_t nvmet_referral_enable_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_port *parent = to_nvmet_port(item->ci_parent->ci_parent);\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\tbool enable;\n\n\tif (kstrtobool(page, &enable))\n\t\tgoto inval;\n\n\tif (enable)\n\t\tnvmet_referral_enable(parent, port);\n\telse\n\t\tnvmet_referral_disable(parent, port);\n\n\treturn count;\ninval:\n\tpr_err(\"Invalid value '%s' for enable\\n\", page);\n\treturn -EINVAL;\n}\n\nCONFIGFS_ATTR(nvmet_referral_, enable);\n\n \nstatic struct configfs_attribute *nvmet_referral_attrs[] = {\n\t&nvmet_attr_addr_adrfam,\n\t&nvmet_attr_addr_portid,\n\t&nvmet_attr_addr_treq,\n\t&nvmet_attr_addr_traddr,\n\t&nvmet_attr_addr_trsvcid,\n\t&nvmet_attr_addr_trtype,\n\t&nvmet_referral_attr_enable,\n\tNULL,\n};\n\nstatic void nvmet_referral_notify(struct config_group *group,\n\t\tstruct config_item *item)\n{\n\tstruct nvmet_port *parent = to_nvmet_port(item->ci_parent->ci_parent);\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\n\tnvmet_referral_disable(parent, port);\n}\n\nstatic void nvmet_referral_release(struct config_item *item)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\n\tkfree(port);\n}\n\nstatic struct configfs_item_operations nvmet_referral_item_ops = {\n\t.release\t= nvmet_referral_release,\n};\n\nstatic const struct config_item_type nvmet_referral_type = {\n\t.ct_owner\t= THIS_MODULE,\n\t.ct_attrs\t= nvmet_referral_attrs,\n\t.ct_item_ops\t= &nvmet_referral_item_ops,\n};\n\nstatic struct config_group *nvmet_referral_make(\n\t\tstruct config_group *group, const char *name)\n{\n\tstruct nvmet_port *port;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&port->entry);\n\tconfig_group_init_type_name(&port->group, name, &nvmet_referral_type);\n\n\treturn &port->group;\n}\n\nstatic struct configfs_group_operations nvmet_referral_group_ops = {\n\t.make_group\t\t= nvmet_referral_make,\n\t.disconnect_notify\t= nvmet_referral_notify,\n};\n\nstatic const struct config_item_type nvmet_referrals_type = {\n\t.ct_owner\t= THIS_MODULE,\n\t.ct_group_ops\t= &nvmet_referral_group_ops,\n};\n\nstatic struct nvmet_type_name_map nvmet_ana_state[] = {\n\t{ NVME_ANA_OPTIMIZED,\t\t\"optimized\" },\n\t{ NVME_ANA_NONOPTIMIZED,\t\"non-optimized\" },\n\t{ NVME_ANA_INACCESSIBLE,\t\"inaccessible\" },\n\t{ NVME_ANA_PERSISTENT_LOSS,\t\"persistent-loss\" },\n\t{ NVME_ANA_CHANGE,\t\t\"change\" },\n};\n\nstatic ssize_t nvmet_ana_group_ana_state_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct nvmet_ana_group *grp = to_ana_group(item);\n\tenum nvme_ana_state state = grp->port->ana_state[grp->grpid];\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nvmet_ana_state); i++) {\n\t\tif (state == nvmet_ana_state[i].type)\n\t\t\treturn sprintf(page, \"%s\\n\", nvmet_ana_state[i].name);\n\t}\n\n\treturn sprintf(page, \"\\n\");\n}\n\nstatic ssize_t nvmet_ana_group_ana_state_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_ana_group *grp = to_ana_group(item);\n\tenum nvme_ana_state *ana_state = grp->port->ana_state;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nvmet_ana_state); i++) {\n\t\tif (sysfs_streq(page, nvmet_ana_state[i].name))\n\t\t\tgoto found;\n\t}\n\n\tpr_err(\"Invalid value '%s' for ana_state\\n\", page);\n\treturn -EINVAL;\n\nfound:\n\tdown_write(&nvmet_ana_sem);\n\tana_state[grp->grpid] = (enum nvme_ana_state) nvmet_ana_state[i].type;\n\tnvmet_ana_chgcnt++;\n\tup_write(&nvmet_ana_sem);\n\tnvmet_port_send_ana_event(grp->port);\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_ana_group_, ana_state);\n\nstatic struct configfs_attribute *nvmet_ana_group_attrs[] = {\n\t&nvmet_ana_group_attr_ana_state,\n\tNULL,\n};\n\nstatic void nvmet_ana_group_release(struct config_item *item)\n{\n\tstruct nvmet_ana_group *grp = to_ana_group(item);\n\n\tif (grp == &grp->port->ana_default_group)\n\t\treturn;\n\n\tdown_write(&nvmet_ana_sem);\n\tgrp->port->ana_state[grp->grpid] = NVME_ANA_INACCESSIBLE;\n\tnvmet_ana_group_enabled[grp->grpid]--;\n\tup_write(&nvmet_ana_sem);\n\n\tnvmet_port_send_ana_event(grp->port);\n\tkfree(grp);\n}\n\nstatic struct configfs_item_operations nvmet_ana_group_item_ops = {\n\t.release\t\t= nvmet_ana_group_release,\n};\n\nstatic const struct config_item_type nvmet_ana_group_type = {\n\t.ct_item_ops\t\t= &nvmet_ana_group_item_ops,\n\t.ct_attrs\t\t= nvmet_ana_group_attrs,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic struct config_group *nvmet_ana_groups_make_group(\n\t\tstruct config_group *group, const char *name)\n{\n\tstruct nvmet_port *port = ana_groups_to_port(&group->cg_item);\n\tstruct nvmet_ana_group *grp;\n\tu32 grpid;\n\tint ret;\n\n\tret = kstrtou32(name, 0, &grpid);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (grpid <= 1 || grpid > NVMET_MAX_ANAGRPS)\n\t\tgoto out;\n\n\tret = -ENOMEM;\n\tgrp = kzalloc(sizeof(*grp), GFP_KERNEL);\n\tif (!grp)\n\t\tgoto out;\n\tgrp->port = port;\n\tgrp->grpid = grpid;\n\n\tdown_write(&nvmet_ana_sem);\n\tgrpid = array_index_nospec(grpid, NVMET_MAX_ANAGRPS);\n\tnvmet_ana_group_enabled[grpid]++;\n\tup_write(&nvmet_ana_sem);\n\n\tnvmet_port_send_ana_event(grp->port);\n\n\tconfig_group_init_type_name(&grp->group, name, &nvmet_ana_group_type);\n\treturn &grp->group;\nout:\n\treturn ERR_PTR(ret);\n}\n\nstatic struct configfs_group_operations nvmet_ana_groups_group_ops = {\n\t.make_group\t\t= nvmet_ana_groups_make_group,\n};\n\nstatic const struct config_item_type nvmet_ana_groups_type = {\n\t.ct_group_ops\t\t= &nvmet_ana_groups_group_ops,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\n \nstatic void nvmet_port_release(struct config_item *item)\n{\n\tstruct nvmet_port *port = to_nvmet_port(item);\n\n\t \n\tflush_workqueue(nvmet_wq);\n\tlist_del(&port->global_entry);\n\n\tkfree(port->ana_state);\n\tkfree(port);\n}\n\nstatic struct configfs_attribute *nvmet_port_attrs[] = {\n\t&nvmet_attr_addr_adrfam,\n\t&nvmet_attr_addr_treq,\n\t&nvmet_attr_addr_traddr,\n\t&nvmet_attr_addr_trsvcid,\n\t&nvmet_attr_addr_trtype,\n\t&nvmet_attr_param_inline_data_size,\n#ifdef CONFIG_BLK_DEV_INTEGRITY\n\t&nvmet_attr_param_pi_enable,\n#endif\n\tNULL,\n};\n\nstatic struct configfs_item_operations nvmet_port_item_ops = {\n\t.release\t\t= nvmet_port_release,\n};\n\nstatic const struct config_item_type nvmet_port_type = {\n\t.ct_attrs\t\t= nvmet_port_attrs,\n\t.ct_item_ops\t\t= &nvmet_port_item_ops,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic struct config_group *nvmet_ports_make(struct config_group *group,\n\t\tconst char *name)\n{\n\tstruct nvmet_port *port;\n\tu16 portid;\n\tu32 i;\n\n\tif (kstrtou16(name, 0, &portid))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tport->ana_state = kcalloc(NVMET_MAX_ANAGRPS + 1,\n\t\t\tsizeof(*port->ana_state), GFP_KERNEL);\n\tif (!port->ana_state) {\n\t\tkfree(port);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 1; i <= NVMET_MAX_ANAGRPS; i++) {\n\t\tif (i == NVMET_DEFAULT_ANA_GRPID)\n\t\t\tport->ana_state[1] = NVME_ANA_OPTIMIZED;\n\t\telse\n\t\t\tport->ana_state[i] = NVME_ANA_INACCESSIBLE;\n\t}\n\n\tlist_add(&port->global_entry, &nvmet_ports_list);\n\n\tINIT_LIST_HEAD(&port->entry);\n\tINIT_LIST_HEAD(&port->subsystems);\n\tINIT_LIST_HEAD(&port->referrals);\n\tport->inline_data_size = -1;\t \n\n\tport->disc_addr.portid = cpu_to_le16(portid);\n\tport->disc_addr.adrfam = NVMF_ADDR_FAMILY_MAX;\n\tport->disc_addr.treq = NVMF_TREQ_DISABLE_SQFLOW;\n\tconfig_group_init_type_name(&port->group, name, &nvmet_port_type);\n\n\tconfig_group_init_type_name(&port->subsys_group,\n\t\t\t\"subsystems\", &nvmet_port_subsys_type);\n\tconfigfs_add_default_group(&port->subsys_group, &port->group);\n\n\tconfig_group_init_type_name(&port->referrals_group,\n\t\t\t\"referrals\", &nvmet_referrals_type);\n\tconfigfs_add_default_group(&port->referrals_group, &port->group);\n\n\tconfig_group_init_type_name(&port->ana_groups_group,\n\t\t\t\"ana_groups\", &nvmet_ana_groups_type);\n\tconfigfs_add_default_group(&port->ana_groups_group, &port->group);\n\n\tport->ana_default_group.port = port;\n\tport->ana_default_group.grpid = NVMET_DEFAULT_ANA_GRPID;\n\tconfig_group_init_type_name(&port->ana_default_group.group,\n\t\t\t__stringify(NVMET_DEFAULT_ANA_GRPID),\n\t\t\t&nvmet_ana_group_type);\n\tconfigfs_add_default_group(&port->ana_default_group.group,\n\t\t\t&port->ana_groups_group);\n\n\treturn &port->group;\n}\n\nstatic struct configfs_group_operations nvmet_ports_group_ops = {\n\t.make_group\t\t= nvmet_ports_make,\n};\n\nstatic const struct config_item_type nvmet_ports_type = {\n\t.ct_group_ops\t\t= &nvmet_ports_group_ops,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic struct config_group nvmet_subsystems_group;\nstatic struct config_group nvmet_ports_group;\n\n#ifdef CONFIG_NVME_TARGET_AUTH\nstatic ssize_t nvmet_host_dhchap_key_show(struct config_item *item,\n\t\tchar *page)\n{\n\tu8 *dhchap_secret = to_host(item)->dhchap_secret;\n\n\tif (!dhchap_secret)\n\t\treturn sprintf(page, \"\\n\");\n\treturn sprintf(page, \"%s\\n\", dhchap_secret);\n}\n\nstatic ssize_t nvmet_host_dhchap_key_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_host *host = to_host(item);\n\tint ret;\n\n\tret = nvmet_auth_set_key(host, page, false);\n\t \n\treturn ret < 0 ? ret : count;\n}\n\nCONFIGFS_ATTR(nvmet_host_, dhchap_key);\n\nstatic ssize_t nvmet_host_dhchap_ctrl_key_show(struct config_item *item,\n\t\tchar *page)\n{\n\tu8 *dhchap_secret = to_host(item)->dhchap_ctrl_secret;\n\n\tif (!dhchap_secret)\n\t\treturn sprintf(page, \"\\n\");\n\treturn sprintf(page, \"%s\\n\", dhchap_secret);\n}\n\nstatic ssize_t nvmet_host_dhchap_ctrl_key_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_host *host = to_host(item);\n\tint ret;\n\n\tret = nvmet_auth_set_key(host, page, true);\n\t \n\treturn ret < 0 ? ret : count;\n}\n\nCONFIGFS_ATTR(nvmet_host_, dhchap_ctrl_key);\n\nstatic ssize_t nvmet_host_dhchap_hash_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct nvmet_host *host = to_host(item);\n\tconst char *hash_name = nvme_auth_hmac_name(host->dhchap_hash_id);\n\n\treturn sprintf(page, \"%s\\n\", hash_name ? hash_name : \"none\");\n}\n\nstatic ssize_t nvmet_host_dhchap_hash_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_host *host = to_host(item);\n\tu8 hmac_id;\n\n\thmac_id = nvme_auth_hmac_id(page);\n\tif (hmac_id == NVME_AUTH_HASH_INVALID)\n\t\treturn -EINVAL;\n\tif (!crypto_has_shash(nvme_auth_hmac_name(hmac_id), 0, 0))\n\t\treturn -ENOTSUPP;\n\thost->dhchap_hash_id = hmac_id;\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_host_, dhchap_hash);\n\nstatic ssize_t nvmet_host_dhchap_dhgroup_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct nvmet_host *host = to_host(item);\n\tconst char *dhgroup = nvme_auth_dhgroup_name(host->dhchap_dhgroup_id);\n\n\treturn sprintf(page, \"%s\\n\", dhgroup ? dhgroup : \"none\");\n}\n\nstatic ssize_t nvmet_host_dhchap_dhgroup_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct nvmet_host *host = to_host(item);\n\tint dhgroup_id;\n\n\tdhgroup_id = nvme_auth_dhgroup_id(page);\n\tif (dhgroup_id == NVME_AUTH_DHGROUP_INVALID)\n\t\treturn -EINVAL;\n\tif (dhgroup_id != NVME_AUTH_DHGROUP_NULL) {\n\t\tconst char *kpp = nvme_auth_dhgroup_kpp(dhgroup_id);\n\n\t\tif (!crypto_has_kpp(kpp, 0, 0))\n\t\t\treturn -EINVAL;\n\t}\n\thost->dhchap_dhgroup_id = dhgroup_id;\n\treturn count;\n}\n\nCONFIGFS_ATTR(nvmet_host_, dhchap_dhgroup);\n\nstatic struct configfs_attribute *nvmet_host_attrs[] = {\n\t&nvmet_host_attr_dhchap_key,\n\t&nvmet_host_attr_dhchap_ctrl_key,\n\t&nvmet_host_attr_dhchap_hash,\n\t&nvmet_host_attr_dhchap_dhgroup,\n\tNULL,\n};\n#endif  \n\nstatic void nvmet_host_release(struct config_item *item)\n{\n\tstruct nvmet_host *host = to_host(item);\n\n#ifdef CONFIG_NVME_TARGET_AUTH\n\tkfree(host->dhchap_secret);\n\tkfree(host->dhchap_ctrl_secret);\n#endif\n\tkfree(host);\n}\n\nstatic struct configfs_item_operations nvmet_host_item_ops = {\n\t.release\t\t= nvmet_host_release,\n};\n\nstatic const struct config_item_type nvmet_host_type = {\n\t.ct_item_ops\t\t= &nvmet_host_item_ops,\n#ifdef CONFIG_NVME_TARGET_AUTH\n\t.ct_attrs\t\t= nvmet_host_attrs,\n#endif\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic struct config_group *nvmet_hosts_make_group(struct config_group *group,\n\t\tconst char *name)\n{\n\tstruct nvmet_host *host;\n\n\thost = kzalloc(sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn ERR_PTR(-ENOMEM);\n\n#ifdef CONFIG_NVME_TARGET_AUTH\n\t \n\thost->dhchap_hash_id = NVME_AUTH_HASH_SHA256;\n#endif\n\n\tconfig_group_init_type_name(&host->group, name, &nvmet_host_type);\n\n\treturn &host->group;\n}\n\nstatic struct configfs_group_operations nvmet_hosts_group_ops = {\n\t.make_group\t\t= nvmet_hosts_make_group,\n};\n\nstatic const struct config_item_type nvmet_hosts_type = {\n\t.ct_group_ops\t\t= &nvmet_hosts_group_ops,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic struct config_group nvmet_hosts_group;\n\nstatic const struct config_item_type nvmet_root_type = {\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic struct configfs_subsystem nvmet_configfs_subsystem = {\n\t.su_group = {\n\t\t.cg_item = {\n\t\t\t.ci_namebuf\t= \"nvmet\",\n\t\t\t.ci_type\t= &nvmet_root_type,\n\t\t},\n\t},\n};\n\nint __init nvmet_init_configfs(void)\n{\n\tint ret;\n\n\tconfig_group_init(&nvmet_configfs_subsystem.su_group);\n\tmutex_init(&nvmet_configfs_subsystem.su_mutex);\n\n\tconfig_group_init_type_name(&nvmet_subsystems_group,\n\t\t\t\"subsystems\", &nvmet_subsystems_type);\n\tconfigfs_add_default_group(&nvmet_subsystems_group,\n\t\t\t&nvmet_configfs_subsystem.su_group);\n\n\tconfig_group_init_type_name(&nvmet_ports_group,\n\t\t\t\"ports\", &nvmet_ports_type);\n\tconfigfs_add_default_group(&nvmet_ports_group,\n\t\t\t&nvmet_configfs_subsystem.su_group);\n\n\tconfig_group_init_type_name(&nvmet_hosts_group,\n\t\t\t\"hosts\", &nvmet_hosts_type);\n\tconfigfs_add_default_group(&nvmet_hosts_group,\n\t\t\t&nvmet_configfs_subsystem.su_group);\n\n\tret = configfs_register_subsystem(&nvmet_configfs_subsystem);\n\tif (ret) {\n\t\tpr_err(\"configfs_register_subsystem: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid __exit nvmet_exit_configfs(void)\n{\n\tconfigfs_unregister_subsystem(&nvmet_configfs_subsystem);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}