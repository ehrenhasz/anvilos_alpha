{
  "module_name": "fabrics-cmd-auth.c",
  "hash_id": "77784195bd7bb68208db79872d2674fcfe420cd0eec2bf5fb549378b3b29a85a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/target/fabrics-cmd-auth.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/nvme-auth.h>\n#include <crypto/hash.h>\n#include <crypto/kpp.h>\n#include \"nvmet.h\"\n\nstatic void nvmet_auth_expired_work(struct work_struct *work)\n{\n\tstruct nvmet_sq *sq = container_of(to_delayed_work(work),\n\t\t\tstruct nvmet_sq, auth_expired_work);\n\n\tpr_debug(\"%s: ctrl %d qid %d transaction %u expired, resetting\\n\",\n\t\t __func__, sq->ctrl->cntlid, sq->qid, sq->dhchap_tid);\n\tsq->dhchap_step = NVME_AUTH_DHCHAP_MESSAGE_NEGOTIATE;\n\tsq->dhchap_tid = -1;\n}\n\nvoid nvmet_auth_sq_init(struct nvmet_sq *sq)\n{\n\t \n\tINIT_DELAYED_WORK(&sq->auth_expired_work, nvmet_auth_expired_work);\n\tsq->authenticated = false;\n\tsq->dhchap_step = NVME_AUTH_DHCHAP_MESSAGE_NEGOTIATE;\n}\n\nstatic u16 nvmet_auth_negotiate(struct nvmet_req *req, void *d)\n{\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tstruct nvmf_auth_dhchap_negotiate_data *data = d;\n\tint i, hash_id = 0, fallback_hash_id = 0, dhgid, fallback_dhgid;\n\n\tpr_debug(\"%s: ctrl %d qid %d: data sc_d %d napd %d authid %d halen %d dhlen %d\\n\",\n\t\t __func__, ctrl->cntlid, req->sq->qid,\n\t\t data->sc_c, data->napd, data->auth_protocol[0].dhchap.authid,\n\t\t data->auth_protocol[0].dhchap.halen,\n\t\t data->auth_protocol[0].dhchap.dhlen);\n\treq->sq->dhchap_tid = le16_to_cpu(data->t_id);\n\tif (data->sc_c)\n\t\treturn NVME_AUTH_DHCHAP_FAILURE_CONCAT_MISMATCH;\n\n\tif (data->napd != 1)\n\t\treturn NVME_AUTH_DHCHAP_FAILURE_HASH_UNUSABLE;\n\n\tif (data->auth_protocol[0].dhchap.authid !=\n\t    NVME_AUTH_DHCHAP_AUTH_ID)\n\t\treturn NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD;\n\n\tfor (i = 0; i < data->auth_protocol[0].dhchap.halen; i++) {\n\t\tu8 host_hmac_id = data->auth_protocol[0].dhchap.idlist[i];\n\n\t\tif (!fallback_hash_id &&\n\t\t    crypto_has_shash(nvme_auth_hmac_name(host_hmac_id), 0, 0))\n\t\t\tfallback_hash_id = host_hmac_id;\n\t\tif (ctrl->shash_id != host_hmac_id)\n\t\t\tcontinue;\n\t\thash_id = ctrl->shash_id;\n\t\tbreak;\n\t}\n\tif (hash_id == 0) {\n\t\tif (fallback_hash_id == 0) {\n\t\t\tpr_debug(\"%s: ctrl %d qid %d: no usable hash found\\n\",\n\t\t\t\t __func__, ctrl->cntlid, req->sq->qid);\n\t\t\treturn NVME_AUTH_DHCHAP_FAILURE_HASH_UNUSABLE;\n\t\t}\n\t\tpr_debug(\"%s: ctrl %d qid %d: no usable hash found, falling back to %s\\n\",\n\t\t\t __func__, ctrl->cntlid, req->sq->qid,\n\t\t\t nvme_auth_hmac_name(fallback_hash_id));\n\t\tctrl->shash_id = fallback_hash_id;\n\t}\n\n\tdhgid = -1;\n\tfallback_dhgid = -1;\n\tfor (i = 0; i < data->auth_protocol[0].dhchap.dhlen; i++) {\n\t\tint tmp_dhgid = data->auth_protocol[0].dhchap.idlist[i + 30];\n\n\t\tif (tmp_dhgid != ctrl->dh_gid) {\n\t\t\tdhgid = tmp_dhgid;\n\t\t\tbreak;\n\t\t}\n\t\tif (fallback_dhgid < 0) {\n\t\t\tconst char *kpp = nvme_auth_dhgroup_kpp(tmp_dhgid);\n\n\t\t\tif (crypto_has_kpp(kpp, 0, 0))\n\t\t\t\tfallback_dhgid = tmp_dhgid;\n\t\t}\n\t}\n\tif (dhgid < 0) {\n\t\tif (fallback_dhgid < 0) {\n\t\t\tpr_debug(\"%s: ctrl %d qid %d: no usable DH group found\\n\",\n\t\t\t\t __func__, ctrl->cntlid, req->sq->qid);\n\t\t\treturn NVME_AUTH_DHCHAP_FAILURE_DHGROUP_UNUSABLE;\n\t\t}\n\t\tpr_debug(\"%s: ctrl %d qid %d: configured DH group %s not found\\n\",\n\t\t\t __func__, ctrl->cntlid, req->sq->qid,\n\t\t\t nvme_auth_dhgroup_name(fallback_dhgid));\n\t\tctrl->dh_gid = fallback_dhgid;\n\t}\n\tpr_debug(\"%s: ctrl %d qid %d: selected DH group %s (%d)\\n\",\n\t\t __func__, ctrl->cntlid, req->sq->qid,\n\t\t nvme_auth_dhgroup_name(ctrl->dh_gid), ctrl->dh_gid);\n\treturn 0;\n}\n\nstatic u16 nvmet_auth_reply(struct nvmet_req *req, void *d)\n{\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tstruct nvmf_auth_dhchap_reply_data *data = d;\n\tu16 dhvlen = le16_to_cpu(data->dhvlen);\n\tu8 *response;\n\n\tpr_debug(\"%s: ctrl %d qid %d: data hl %d cvalid %d dhvlen %u\\n\",\n\t\t __func__, ctrl->cntlid, req->sq->qid,\n\t\t data->hl, data->cvalid, dhvlen);\n\n\tif (dhvlen) {\n\t\tif (!ctrl->dh_tfm)\n\t\t\treturn NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD;\n\t\tif (nvmet_auth_ctrl_sesskey(req, data->rval + 2 * data->hl,\n\t\t\t\t\t    dhvlen) < 0)\n\t\t\treturn NVME_AUTH_DHCHAP_FAILURE_DHGROUP_UNUSABLE;\n\t}\n\n\tresponse = kmalloc(data->hl, GFP_KERNEL);\n\tif (!response)\n\t\treturn NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\n\tif (!ctrl->host_key) {\n\t\tpr_warn(\"ctrl %d qid %d no host key\\n\",\n\t\t\tctrl->cntlid, req->sq->qid);\n\t\tkfree(response);\n\t\treturn NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\t}\n\tif (nvmet_auth_host_hash(req, response, data->hl) < 0) {\n\t\tpr_debug(\"ctrl %d qid %d host hash failed\\n\",\n\t\t\t ctrl->cntlid, req->sq->qid);\n\t\tkfree(response);\n\t\treturn NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\t}\n\n\tif (memcmp(data->rval, response, data->hl)) {\n\t\tpr_info(\"ctrl %d qid %d host response mismatch\\n\",\n\t\t\tctrl->cntlid, req->sq->qid);\n\t\tkfree(response);\n\t\treturn NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\t}\n\tkfree(response);\n\tpr_debug(\"%s: ctrl %d qid %d host authenticated\\n\",\n\t\t __func__, ctrl->cntlid, req->sq->qid);\n\tif (data->cvalid) {\n\t\treq->sq->dhchap_c2 = kmemdup(data->rval + data->hl, data->hl,\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!req->sq->dhchap_c2)\n\t\t\treturn NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\n\t\tpr_debug(\"%s: ctrl %d qid %d challenge %*ph\\n\",\n\t\t\t __func__, ctrl->cntlid, req->sq->qid, data->hl,\n\t\t\t req->sq->dhchap_c2);\n\t\treq->sq->dhchap_s2 = le32_to_cpu(data->seqnum);\n\t} else {\n\t\treq->sq->authenticated = true;\n\t\treq->sq->dhchap_c2 = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic u16 nvmet_auth_failure2(void *d)\n{\n\tstruct nvmf_auth_dhchap_failure_data *data = d;\n\n\treturn data->rescode_exp;\n}\n\nvoid nvmet_execute_auth_send(struct nvmet_req *req)\n{\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tstruct nvmf_auth_dhchap_success2_data *data;\n\tvoid *d;\n\tu32 tl;\n\tu16 status = 0;\n\n\tif (req->cmd->auth_send.secp != NVME_AUTH_DHCHAP_PROTOCOL_IDENTIFIER) {\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvmf_auth_send_command, secp);\n\t\tgoto done;\n\t}\n\tif (req->cmd->auth_send.spsp0 != 0x01) {\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvmf_auth_send_command, spsp0);\n\t\tgoto done;\n\t}\n\tif (req->cmd->auth_send.spsp1 != 0x01) {\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvmf_auth_send_command, spsp1);\n\t\tgoto done;\n\t}\n\ttl = le32_to_cpu(req->cmd->auth_send.tl);\n\tif (!tl) {\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvmf_auth_send_command, tl);\n\t\tgoto done;\n\t}\n\tif (!nvmet_check_transfer_len(req, tl)) {\n\t\tpr_debug(\"%s: transfer length mismatch (%u)\\n\", __func__, tl);\n\t\treturn;\n\t}\n\n\td = kmalloc(tl, GFP_KERNEL);\n\tif (!d) {\n\t\tstatus = NVME_SC_INTERNAL;\n\t\tgoto done;\n\t}\n\n\tstatus = nvmet_copy_from_sgl(req, 0, d, tl);\n\tif (status)\n\t\tgoto done_kfree;\n\n\tdata = d;\n\tpr_debug(\"%s: ctrl %d qid %d type %d id %d step %x\\n\", __func__,\n\t\t ctrl->cntlid, req->sq->qid, data->auth_type, data->auth_id,\n\t\t req->sq->dhchap_step);\n\tif (data->auth_type != NVME_AUTH_COMMON_MESSAGES &&\n\t    data->auth_type != NVME_AUTH_DHCHAP_MESSAGES)\n\t\tgoto done_failure1;\n\tif (data->auth_type == NVME_AUTH_COMMON_MESSAGES) {\n\t\tif (data->auth_id == NVME_AUTH_DHCHAP_MESSAGE_NEGOTIATE) {\n\t\t\t \n\t\t\tpr_debug(\"%s: ctrl %d qid %d reset negotiation\\n\", __func__,\n\t\t\t\t ctrl->cntlid, req->sq->qid);\n\t\t\tif (!req->sq->qid) {\n\t\t\t\tif (nvmet_setup_auth(ctrl) < 0) {\n\t\t\t\t\tstatus = NVME_SC_INTERNAL;\n\t\t\t\t\tpr_err(\"ctrl %d qid 0 failed to setup\"\n\t\t\t\t\t       \"re-authentication\",\n\t\t\t\t\t       ctrl->cntlid);\n\t\t\t\t\tgoto done_failure1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treq->sq->dhchap_step = NVME_AUTH_DHCHAP_MESSAGE_NEGOTIATE;\n\t\t} else if (data->auth_id != req->sq->dhchap_step)\n\t\t\tgoto done_failure1;\n\t\t \n\t\tstatus = nvmet_auth_negotiate(req, d);\n\t\tif (status == 0)\n\t\t\treq->sq->dhchap_step =\n\t\t\t\tNVME_AUTH_DHCHAP_MESSAGE_CHALLENGE;\n\t\telse {\n\t\t\treq->sq->dhchap_step =\n\t\t\t\tNVME_AUTH_DHCHAP_MESSAGE_FAILURE1;\n\t\t\treq->sq->dhchap_status = status;\n\t\t\tstatus = 0;\n\t\t}\n\t\tgoto done_kfree;\n\t}\n\tif (data->auth_id != req->sq->dhchap_step) {\n\t\tpr_debug(\"%s: ctrl %d qid %d step mismatch (%d != %d)\\n\",\n\t\t\t __func__, ctrl->cntlid, req->sq->qid,\n\t\t\t data->auth_id, req->sq->dhchap_step);\n\t\tgoto done_failure1;\n\t}\n\tif (le16_to_cpu(data->t_id) != req->sq->dhchap_tid) {\n\t\tpr_debug(\"%s: ctrl %d qid %d invalid transaction %d (expected %d)\\n\",\n\t\t\t __func__, ctrl->cntlid, req->sq->qid,\n\t\t\t le16_to_cpu(data->t_id),\n\t\t\t req->sq->dhchap_tid);\n\t\treq->sq->dhchap_step =\n\t\t\tNVME_AUTH_DHCHAP_MESSAGE_FAILURE1;\n\t\treq->sq->dhchap_status =\n\t\t\tNVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD;\n\t\tgoto done_kfree;\n\t}\n\n\tswitch (data->auth_id) {\n\tcase NVME_AUTH_DHCHAP_MESSAGE_REPLY:\n\t\tstatus = nvmet_auth_reply(req, d);\n\t\tif (status == 0)\n\t\t\treq->sq->dhchap_step =\n\t\t\t\tNVME_AUTH_DHCHAP_MESSAGE_SUCCESS1;\n\t\telse {\n\t\t\treq->sq->dhchap_step =\n\t\t\t\tNVME_AUTH_DHCHAP_MESSAGE_FAILURE1;\n\t\t\treq->sq->dhchap_status = status;\n\t\t\tstatus = 0;\n\t\t}\n\t\tgoto done_kfree;\n\tcase NVME_AUTH_DHCHAP_MESSAGE_SUCCESS2:\n\t\treq->sq->authenticated = true;\n\t\tpr_debug(\"%s: ctrl %d qid %d ctrl authenticated\\n\",\n\t\t\t __func__, ctrl->cntlid, req->sq->qid);\n\t\tgoto done_kfree;\n\tcase NVME_AUTH_DHCHAP_MESSAGE_FAILURE2:\n\t\tstatus = nvmet_auth_failure2(d);\n\t\tif (status) {\n\t\t\tpr_warn(\"ctrl %d qid %d: authentication failed (%d)\\n\",\n\t\t\t\tctrl->cntlid, req->sq->qid, status);\n\t\t\treq->sq->dhchap_status = status;\n\t\t\treq->sq->authenticated = false;\n\t\t\tstatus = 0;\n\t\t}\n\t\tgoto done_kfree;\n\tdefault:\n\t\treq->sq->dhchap_status =\n\t\t\tNVME_AUTH_DHCHAP_FAILURE_INCORRECT_MESSAGE;\n\t\treq->sq->dhchap_step =\n\t\t\tNVME_AUTH_DHCHAP_MESSAGE_FAILURE2;\n\t\treq->sq->authenticated = false;\n\t\tgoto done_kfree;\n\t}\ndone_failure1:\n\treq->sq->dhchap_status = NVME_AUTH_DHCHAP_FAILURE_INCORRECT_MESSAGE;\n\treq->sq->dhchap_step = NVME_AUTH_DHCHAP_MESSAGE_FAILURE2;\n\ndone_kfree:\n\tkfree(d);\ndone:\n\tpr_debug(\"%s: ctrl %d qid %d dhchap status %x step %x\\n\", __func__,\n\t\t ctrl->cntlid, req->sq->qid,\n\t\t req->sq->dhchap_status, req->sq->dhchap_step);\n\tif (status)\n\t\tpr_debug(\"%s: ctrl %d qid %d nvme status %x error loc %d\\n\",\n\t\t\t __func__, ctrl->cntlid, req->sq->qid,\n\t\t\t status, req->error_loc);\n\treq->cqe->result.u64 = 0;\n\tif (req->sq->dhchap_step != NVME_AUTH_DHCHAP_MESSAGE_SUCCESS2 &&\n\t    req->sq->dhchap_step != NVME_AUTH_DHCHAP_MESSAGE_FAILURE2) {\n\t\tunsigned long auth_expire_secs = ctrl->kato ? ctrl->kato : 120;\n\n\t\tmod_delayed_work(system_wq, &req->sq->auth_expired_work,\n\t\t\t\t auth_expire_secs * HZ);\n\t\tgoto complete;\n\t}\n\t \n\tnvmet_auth_sq_free(req->sq);\n\tif (req->sq->dhchap_step == NVME_AUTH_DHCHAP_MESSAGE_FAILURE2)\n\t\tnvmet_ctrl_fatal_error(ctrl);\n\ncomplete:\n\tnvmet_req_complete(req, status);\n}\n\nstatic int nvmet_auth_challenge(struct nvmet_req *req, void *d, int al)\n{\n\tstruct nvmf_auth_dhchap_challenge_data *data = d;\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tint ret = 0;\n\tint hash_len = nvme_auth_hmac_hash_len(ctrl->shash_id);\n\tint data_size = sizeof(*d) + hash_len;\n\n\tif (ctrl->dh_tfm)\n\t\tdata_size += ctrl->dh_keysize;\n\tif (al < data_size) {\n\t\tpr_debug(\"%s: buffer too small (al %d need %d)\\n\", __func__,\n\t\t\t al, data_size);\n\t\treturn -EINVAL;\n\t}\n\tmemset(data, 0, data_size);\n\treq->sq->dhchap_s1 = nvme_auth_get_seqnum();\n\tdata->auth_type = NVME_AUTH_DHCHAP_MESSAGES;\n\tdata->auth_id = NVME_AUTH_DHCHAP_MESSAGE_CHALLENGE;\n\tdata->t_id = cpu_to_le16(req->sq->dhchap_tid);\n\tdata->hashid = ctrl->shash_id;\n\tdata->hl = hash_len;\n\tdata->seqnum = cpu_to_le32(req->sq->dhchap_s1);\n\treq->sq->dhchap_c1 = kmalloc(data->hl, GFP_KERNEL);\n\tif (!req->sq->dhchap_c1)\n\t\treturn -ENOMEM;\n\tget_random_bytes(req->sq->dhchap_c1, data->hl);\n\tmemcpy(data->cval, req->sq->dhchap_c1, data->hl);\n\tif (ctrl->dh_tfm) {\n\t\tdata->dhgid = ctrl->dh_gid;\n\t\tdata->dhvlen = cpu_to_le16(ctrl->dh_keysize);\n\t\tret = nvmet_auth_ctrl_exponential(req, data->cval + data->hl,\n\t\t\t\t\t\t  ctrl->dh_keysize);\n\t}\n\tpr_debug(\"%s: ctrl %d qid %d seq %d transaction %d hl %d dhvlen %zu\\n\",\n\t\t __func__, ctrl->cntlid, req->sq->qid, req->sq->dhchap_s1,\n\t\t req->sq->dhchap_tid, data->hl, ctrl->dh_keysize);\n\treturn ret;\n}\n\nstatic int nvmet_auth_success1(struct nvmet_req *req, void *d, int al)\n{\n\tstruct nvmf_auth_dhchap_success1_data *data = d;\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tint hash_len = nvme_auth_hmac_hash_len(ctrl->shash_id);\n\n\tWARN_ON(al < sizeof(*data));\n\tmemset(data, 0, sizeof(*data));\n\tdata->auth_type = NVME_AUTH_DHCHAP_MESSAGES;\n\tdata->auth_id = NVME_AUTH_DHCHAP_MESSAGE_SUCCESS1;\n\tdata->t_id = cpu_to_le16(req->sq->dhchap_tid);\n\tdata->hl = hash_len;\n\tif (req->sq->dhchap_c2) {\n\t\tif (!ctrl->ctrl_key) {\n\t\t\tpr_warn(\"ctrl %d qid %d no ctrl key\\n\",\n\t\t\t\tctrl->cntlid, req->sq->qid);\n\t\t\treturn NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\t\t}\n\t\tif (nvmet_auth_ctrl_hash(req, data->rval, data->hl))\n\t\t\treturn NVME_AUTH_DHCHAP_FAILURE_HASH_UNUSABLE;\n\t\tdata->rvalid = 1;\n\t\tpr_debug(\"ctrl %d qid %d response %*ph\\n\",\n\t\t\t ctrl->cntlid, req->sq->qid, data->hl, data->rval);\n\t}\n\treturn 0;\n}\n\nstatic void nvmet_auth_failure1(struct nvmet_req *req, void *d, int al)\n{\n\tstruct nvmf_auth_dhchap_failure_data *data = d;\n\n\tWARN_ON(al < sizeof(*data));\n\tdata->auth_type = NVME_AUTH_COMMON_MESSAGES;\n\tdata->auth_id = NVME_AUTH_DHCHAP_MESSAGE_FAILURE1;\n\tdata->t_id = cpu_to_le16(req->sq->dhchap_tid);\n\tdata->rescode = NVME_AUTH_DHCHAP_FAILURE_REASON_FAILED;\n\tdata->rescode_exp = req->sq->dhchap_status;\n}\n\nvoid nvmet_execute_auth_receive(struct nvmet_req *req)\n{\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tvoid *d;\n\tu32 al;\n\tu16 status = 0;\n\n\tif (req->cmd->auth_receive.secp != NVME_AUTH_DHCHAP_PROTOCOL_IDENTIFIER) {\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvmf_auth_receive_command, secp);\n\t\tgoto done;\n\t}\n\tif (req->cmd->auth_receive.spsp0 != 0x01) {\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvmf_auth_receive_command, spsp0);\n\t\tgoto done;\n\t}\n\tif (req->cmd->auth_receive.spsp1 != 0x01) {\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvmf_auth_receive_command, spsp1);\n\t\tgoto done;\n\t}\n\tal = le32_to_cpu(req->cmd->auth_receive.al);\n\tif (!al) {\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvmf_auth_receive_command, al);\n\t\tgoto done;\n\t}\n\tif (!nvmet_check_transfer_len(req, al)) {\n\t\tpr_debug(\"%s: transfer length mismatch (%u)\\n\", __func__, al);\n\t\treturn;\n\t}\n\n\td = kmalloc(al, GFP_KERNEL);\n\tif (!d) {\n\t\tstatus = NVME_SC_INTERNAL;\n\t\tgoto done;\n\t}\n\tpr_debug(\"%s: ctrl %d qid %d step %x\\n\", __func__,\n\t\t ctrl->cntlid, req->sq->qid, req->sq->dhchap_step);\n\tswitch (req->sq->dhchap_step) {\n\tcase NVME_AUTH_DHCHAP_MESSAGE_CHALLENGE:\n\t\tif (nvmet_auth_challenge(req, d, al) < 0) {\n\t\t\tpr_warn(\"ctrl %d qid %d: challenge error (%d)\\n\",\n\t\t\t\tctrl->cntlid, req->sq->qid, status);\n\t\t\tstatus = NVME_SC_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\treq->sq->dhchap_step = NVME_AUTH_DHCHAP_MESSAGE_REPLY;\n\t\tbreak;\n\tcase NVME_AUTH_DHCHAP_MESSAGE_SUCCESS1:\n\t\tstatus = nvmet_auth_success1(req, d, al);\n\t\tif (status) {\n\t\t\treq->sq->dhchap_status = status;\n\t\t\treq->sq->authenticated = false;\n\t\t\tnvmet_auth_failure1(req, d, al);\n\t\t\tpr_warn(\"ctrl %d qid %d: success1 status (%x)\\n\",\n\t\t\t\tctrl->cntlid, req->sq->qid,\n\t\t\t\treq->sq->dhchap_status);\n\t\t\tbreak;\n\t\t}\n\t\treq->sq->dhchap_step = NVME_AUTH_DHCHAP_MESSAGE_SUCCESS2;\n\t\tbreak;\n\tcase NVME_AUTH_DHCHAP_MESSAGE_FAILURE1:\n\t\treq->sq->authenticated = false;\n\t\tnvmet_auth_failure1(req, d, al);\n\t\tpr_warn(\"ctrl %d qid %d failure1 (%x)\\n\",\n\t\t\tctrl->cntlid, req->sq->qid, req->sq->dhchap_status);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"ctrl %d qid %d unhandled step (%d)\\n\",\n\t\t\tctrl->cntlid, req->sq->qid, req->sq->dhchap_step);\n\t\treq->sq->dhchap_step = NVME_AUTH_DHCHAP_MESSAGE_FAILURE1;\n\t\treq->sq->dhchap_status = NVME_AUTH_DHCHAP_FAILURE_FAILED;\n\t\tnvmet_auth_failure1(req, d, al);\n\t\tstatus = 0;\n\t\tbreak;\n\t}\n\n\tstatus = nvmet_copy_to_sgl(req, 0, d, al);\n\tkfree(d);\ndone:\n\treq->cqe->result.u64 = 0;\n\n\tif (req->sq->dhchap_step == NVME_AUTH_DHCHAP_MESSAGE_SUCCESS2)\n\t\tnvmet_auth_sq_free(req->sq);\n\telse if (req->sq->dhchap_step == NVME_AUTH_DHCHAP_MESSAGE_FAILURE1) {\n\t\tnvmet_auth_sq_free(req->sq);\n\t\tnvmet_ctrl_fatal_error(ctrl);\n\t}\n\tnvmet_req_complete(req, status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}