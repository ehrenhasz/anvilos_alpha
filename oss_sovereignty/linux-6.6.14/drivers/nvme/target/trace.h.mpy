{
  "module_name": "trace.h",
  "hash_id": "8a9c3402d14ac15efb54a87533da6ed11366035863404c4a570ff741929d6101",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/target/trace.h",
  "human_readable_source": " \n \n\n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM nvmet\n\n#if !defined(_TRACE_NVMET_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_NVMET_H\n\n#include <linux/nvme.h>\n#include <linux/tracepoint.h>\n#include <linux/trace_seq.h>\n\n#include \"nvmet.h\"\n\nconst char *nvmet_trace_parse_admin_cmd(struct trace_seq *p, u8 opcode,\n\t\tu8 *cdw10);\nconst char *nvmet_trace_parse_nvm_cmd(struct trace_seq *p, u8 opcode,\n\t\tu8 *cdw10);\nconst char *nvmet_trace_parse_fabrics_cmd(struct trace_seq *p, u8 fctype,\n\t\tu8 *spc);\n\n#define parse_nvme_cmd(qid, opcode, fctype, cdw10)\t\t\t\\\n\t((opcode) == nvme_fabrics_command ?\t\t\t\t\\\n\t nvmet_trace_parse_fabrics_cmd(p, fctype, cdw10) :\t\t\\\n\t(qid ?\t\t\t\t\t\t\t\t\\\n\t nvmet_trace_parse_nvm_cmd(p, opcode, cdw10) :\t\t\t\\\n\t nvmet_trace_parse_admin_cmd(p, opcode, cdw10)))\n\nconst char *nvmet_trace_ctrl_name(struct trace_seq *p, struct nvmet_ctrl *ctrl);\n#define __print_ctrl_name(ctrl)\t\t\t\t\\\n\tnvmet_trace_ctrl_name(p, ctrl)\n\nconst char *nvmet_trace_disk_name(struct trace_seq *p, char *name);\n#define __print_disk_name(name)\t\t\t\t\\\n\tnvmet_trace_disk_name(p, name)\n\n#ifndef TRACE_HEADER_MULTI_READ\nstatic inline struct nvmet_ctrl *nvmet_req_to_ctrl(struct nvmet_req *req)\n{\n\treturn req->sq->ctrl;\n}\n\nstatic inline void __assign_req_name(char *name, struct nvmet_req *req)\n{\n\tif (!req->ns) {\n\t\tmemset(name, 0, DISK_NAME_LEN);\n\t\treturn;\n\t}\n\n\tstrscpy_pad(name, req->ns->device_path, DISK_NAME_LEN);\n}\n#endif\n\nTRACE_EVENT(nvmet_req_init,\n\tTP_PROTO(struct nvmet_req *req, struct nvme_command *cmd),\n\tTP_ARGS(req, cmd),\n\tTP_STRUCT__entry(\n\t\t__field(struct nvme_command *, cmd)\n\t\t__field(struct nvmet_ctrl *, ctrl)\n\t\t__array(char, disk, DISK_NAME_LEN)\n\t\t__field(int, qid)\n\t\t__field(u16, cid)\n\t\t__field(u8, opcode)\n\t\t__field(u8, fctype)\n\t\t__field(u8, flags)\n\t\t__field(u32, nsid)\n\t\t__field(u64, metadata)\n\t\t__array(u8, cdw10, 24)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cmd = cmd;\n\t\t__entry->ctrl = nvmet_req_to_ctrl(req);\n\t\t__assign_req_name(__entry->disk, req);\n\t\t__entry->qid = req->sq->qid;\n\t\t__entry->cid = cmd->common.command_id;\n\t\t__entry->opcode = cmd->common.opcode;\n\t\t__entry->fctype = cmd->fabrics.fctype;\n\t\t__entry->flags = cmd->common.flags;\n\t\t__entry->nsid = le32_to_cpu(cmd->common.nsid);\n\t\t__entry->metadata = le64_to_cpu(cmd->common.metadata);\n\t\tmemcpy(__entry->cdw10, &cmd->common.cdws,\n\t\t\tsizeof(__entry->cdw10));\n\t),\n\tTP_printk(\"nvmet%s: %sqid=%d, cmdid=%u, nsid=%u, flags=%#x, \"\n\t\t  \"meta=%#llx, cmd=(%s, %s)\",\n\t\t__print_ctrl_name(__entry->ctrl),\n\t\t__print_disk_name(__entry->disk),\n\t\t__entry->qid, __entry->cid, __entry->nsid,\n\t\t__entry->flags, __entry->metadata,\n\t\tshow_opcode_name(__entry->qid, __entry->opcode,\n\t\t\t\t__entry->fctype),\n\t\tparse_nvme_cmd(__entry->qid, __entry->opcode,\n\t\t\t\t__entry->fctype, __entry->cdw10))\n);\n\nTRACE_EVENT(nvmet_req_complete,\n\tTP_PROTO(struct nvmet_req *req),\n\tTP_ARGS(req),\n\tTP_STRUCT__entry(\n\t\t__field(struct nvmet_ctrl *, ctrl)\n\t\t__array(char, disk, DISK_NAME_LEN)\n\t\t__field(int, qid)\n\t\t__field(int, cid)\n\t\t__field(u64, result)\n\t\t__field(u16, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->ctrl = nvmet_req_to_ctrl(req);\n\t\t__entry->qid = req->cq->qid;\n\t\t__entry->cid = req->cqe->command_id;\n\t\t__entry->result = le64_to_cpu(req->cqe->result.u64);\n\t\t__entry->status = le16_to_cpu(req->cqe->status) >> 1;\n\t\t__assign_req_name(__entry->disk, req);\n\t),\n\tTP_printk(\"nvmet%s: %sqid=%d, cmdid=%u, res=%#llx, status=%#x\",\n\t\t__print_ctrl_name(__entry->ctrl),\n\t\t__print_disk_name(__entry->disk),\n\t\t__entry->qid, __entry->cid, __entry->result, __entry->status)\n\n);\n\n#define aer_name(aer) { aer, #aer }\n\nTRACE_EVENT(nvmet_async_event,\n\tTP_PROTO(struct nvmet_ctrl *ctrl, __le32 result),\n\tTP_ARGS(ctrl, result),\n\tTP_STRUCT__entry(\n\t\t__field(int, ctrl_id)\n\t\t__field(u32, result)\n\t),\n\tTP_fast_assign(\n\t\t__entry->ctrl_id = ctrl->cntlid;\n\t\t__entry->result = (le32_to_cpu(result) & 0xff00) >> 8;\n\t),\n\tTP_printk(\"nvmet%d: NVME_AEN=%#08x [%s]\",\n\t\t__entry->ctrl_id, __entry->result,\n\t\t__print_symbolic(__entry->result,\n\t\taer_name(NVME_AER_NOTICE_NS_CHANGED),\n\t\taer_name(NVME_AER_NOTICE_ANA),\n\t\taer_name(NVME_AER_NOTICE_FW_ACT_STARTING),\n\t\taer_name(NVME_AER_NOTICE_DISC_CHANGED),\n\t\taer_name(NVME_AER_ERROR),\n\t\taer_name(NVME_AER_SMART),\n\t\taer_name(NVME_AER_CSS),\n\t\taer_name(NVME_AER_VS))\n\t)\n);\n#undef aer_name\n\n#endif  \n\n#undef TRACE_INCLUDE_PATH\n#define TRACE_INCLUDE_PATH .\n#undef TRACE_INCLUDE_FILE\n#define TRACE_INCLUDE_FILE trace\n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}