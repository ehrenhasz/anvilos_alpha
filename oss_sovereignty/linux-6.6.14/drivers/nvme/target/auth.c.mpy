{
  "module_name": "auth.c",
  "hash_id": "1c469e7fe3b76504e0229093aa22f1b89445deb9e9b36d26af1ec49037b1f571",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/target/auth.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <crypto/hash.h>\n#include <linux/crc32.h>\n#include <linux/base64.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/nvme-auth.h>\n#include <asm/unaligned.h>\n\n#include \"nvmet.h\"\n\nint nvmet_auth_set_key(struct nvmet_host *host, const char *secret,\n\t\t       bool set_ctrl)\n{\n\tunsigned char key_hash;\n\tchar *dhchap_secret;\n\n\tif (sscanf(secret, \"DHHC-1:%hhd:%*s\", &key_hash) != 1)\n\t\treturn -EINVAL;\n\tif (key_hash > 3) {\n\t\tpr_warn(\"Invalid DH-HMAC-CHAP hash id %d\\n\",\n\t\t\t key_hash);\n\t\treturn -EINVAL;\n\t}\n\tif (key_hash > 0) {\n\t\t \n\t\tconst char *hmac = nvme_auth_hmac_name(key_hash);\n\n\t\tif (!crypto_has_shash(hmac, 0, 0)) {\n\t\t\tpr_err(\"DH-HMAC-CHAP hash %s unsupported\\n\", hmac);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\tdhchap_secret = kstrdup(secret, GFP_KERNEL);\n\tif (!dhchap_secret)\n\t\treturn -ENOMEM;\n\tif (set_ctrl) {\n\t\tkfree(host->dhchap_ctrl_secret);\n\t\thost->dhchap_ctrl_secret = strim(dhchap_secret);\n\t\thost->dhchap_ctrl_key_hash = key_hash;\n\t} else {\n\t\tkfree(host->dhchap_secret);\n\t\thost->dhchap_secret = strim(dhchap_secret);\n\t\thost->dhchap_key_hash = key_hash;\n\t}\n\treturn 0;\n}\n\nint nvmet_setup_dhgroup(struct nvmet_ctrl *ctrl, u8 dhgroup_id)\n{\n\tconst char *dhgroup_kpp;\n\tint ret = 0;\n\n\tpr_debug(\"%s: ctrl %d selecting dhgroup %d\\n\",\n\t\t __func__, ctrl->cntlid, dhgroup_id);\n\n\tif (ctrl->dh_tfm) {\n\t\tif (ctrl->dh_gid == dhgroup_id) {\n\t\t\tpr_debug(\"%s: ctrl %d reuse existing DH group %d\\n\",\n\t\t\t\t __func__, ctrl->cntlid, dhgroup_id);\n\t\t\treturn 0;\n\t\t}\n\t\tcrypto_free_kpp(ctrl->dh_tfm);\n\t\tctrl->dh_tfm = NULL;\n\t\tctrl->dh_gid = 0;\n\t}\n\n\tif (dhgroup_id == NVME_AUTH_DHGROUP_NULL)\n\t\treturn 0;\n\n\tdhgroup_kpp = nvme_auth_dhgroup_kpp(dhgroup_id);\n\tif (!dhgroup_kpp) {\n\t\tpr_debug(\"%s: ctrl %d invalid DH group %d\\n\",\n\t\t\t __func__, ctrl->cntlid, dhgroup_id);\n\t\treturn -EINVAL;\n\t}\n\tctrl->dh_tfm = crypto_alloc_kpp(dhgroup_kpp, 0, 0);\n\tif (IS_ERR(ctrl->dh_tfm)) {\n\t\tpr_debug(\"%s: ctrl %d failed to setup DH group %d, err %ld\\n\",\n\t\t\t __func__, ctrl->cntlid, dhgroup_id,\n\t\t\t PTR_ERR(ctrl->dh_tfm));\n\t\tret = PTR_ERR(ctrl->dh_tfm);\n\t\tctrl->dh_tfm = NULL;\n\t\tctrl->dh_gid = 0;\n\t} else {\n\t\tctrl->dh_gid = dhgroup_id;\n\t\tpr_debug(\"%s: ctrl %d setup DH group %d\\n\",\n\t\t\t __func__, ctrl->cntlid, ctrl->dh_gid);\n\t\tret = nvme_auth_gen_privkey(ctrl->dh_tfm, ctrl->dh_gid);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"%s: ctrl %d failed to generate private key, err %d\\n\",\n\t\t\t\t __func__, ctrl->cntlid, ret);\n\t\t\tkfree_sensitive(ctrl->dh_key);\n\t\t\treturn ret;\n\t\t}\n\t\tctrl->dh_keysize = crypto_kpp_maxsize(ctrl->dh_tfm);\n\t\tkfree_sensitive(ctrl->dh_key);\n\t\tctrl->dh_key = kzalloc(ctrl->dh_keysize, GFP_KERNEL);\n\t\tif (!ctrl->dh_key) {\n\t\t\tpr_warn(\"ctrl %d failed to allocate public key\\n\",\n\t\t\t\tctrl->cntlid);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = nvme_auth_gen_pubkey(ctrl->dh_tfm, ctrl->dh_key,\n\t\t\t\t\t   ctrl->dh_keysize);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"ctrl %d failed to generate public key\\n\",\n\t\t\t\tctrl->cntlid);\n\t\t\tkfree(ctrl->dh_key);\n\t\t\tctrl->dh_key = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint nvmet_setup_auth(struct nvmet_ctrl *ctrl)\n{\n\tint ret = 0;\n\tstruct nvmet_host_link *p;\n\tstruct nvmet_host *host = NULL;\n\tconst char *hash_name;\n\n\tdown_read(&nvmet_config_sem);\n\tif (nvmet_is_disc_subsys(ctrl->subsys))\n\t\tgoto out_unlock;\n\n\tif (ctrl->subsys->allow_any_host)\n\t\tgoto out_unlock;\n\n\tlist_for_each_entry(p, &ctrl->subsys->hosts, entry) {\n\t\tpr_debug(\"check %s\\n\", nvmet_host_name(p->host));\n\t\tif (strcmp(nvmet_host_name(p->host), ctrl->hostnqn))\n\t\t\tcontinue;\n\t\thost = p->host;\n\t\tbreak;\n\t}\n\tif (!host) {\n\t\tpr_debug(\"host %s not found\\n\", ctrl->hostnqn);\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\n\tret = nvmet_setup_dhgroup(ctrl, host->dhchap_dhgroup_id);\n\tif (ret < 0)\n\t\tpr_warn(\"Failed to setup DH group\");\n\n\tif (!host->dhchap_secret) {\n\t\tpr_debug(\"No authentication provided\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tif (host->dhchap_hash_id == ctrl->shash_id) {\n\t\tpr_debug(\"Re-use existing hash ID %d\\n\",\n\t\t\t ctrl->shash_id);\n\t} else {\n\t\thash_name = nvme_auth_hmac_name(host->dhchap_hash_id);\n\t\tif (!hash_name) {\n\t\t\tpr_warn(\"Hash ID %d invalid\\n\", host->dhchap_hash_id);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tctrl->shash_id = host->dhchap_hash_id;\n\t}\n\n\t \n\tnvme_auth_free_key(ctrl->host_key);\n\tctrl->host_key = nvme_auth_extract_key(host->dhchap_secret + 10,\n\t\t\t\t\t       host->dhchap_key_hash);\n\tif (IS_ERR(ctrl->host_key)) {\n\t\tret = PTR_ERR(ctrl->host_key);\n\t\tctrl->host_key = NULL;\n\t\tgoto out_free_hash;\n\t}\n\tpr_debug(\"%s: using hash %s key %*ph\\n\", __func__,\n\t\t ctrl->host_key->hash > 0 ?\n\t\t nvme_auth_hmac_name(ctrl->host_key->hash) : \"none\",\n\t\t (int)ctrl->host_key->len, ctrl->host_key->key);\n\n\tnvme_auth_free_key(ctrl->ctrl_key);\n\tif (!host->dhchap_ctrl_secret) {\n\t\tctrl->ctrl_key = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tctrl->ctrl_key = nvme_auth_extract_key(host->dhchap_ctrl_secret + 10,\n\t\t\t\t\t       host->dhchap_ctrl_key_hash);\n\tif (IS_ERR(ctrl->ctrl_key)) {\n\t\tret = PTR_ERR(ctrl->ctrl_key);\n\t\tctrl->ctrl_key = NULL;\n\t\tgoto out_free_hash;\n\t}\n\tpr_debug(\"%s: using ctrl hash %s key %*ph\\n\", __func__,\n\t\t ctrl->ctrl_key->hash > 0 ?\n\t\t nvme_auth_hmac_name(ctrl->ctrl_key->hash) : \"none\",\n\t\t (int)ctrl->ctrl_key->len, ctrl->ctrl_key->key);\n\nout_free_hash:\n\tif (ret) {\n\t\tif (ctrl->host_key) {\n\t\t\tnvme_auth_free_key(ctrl->host_key);\n\t\t\tctrl->host_key = NULL;\n\t\t}\n\t\tctrl->shash_id = 0;\n\t}\nout_unlock:\n\tup_read(&nvmet_config_sem);\n\n\treturn ret;\n}\n\nvoid nvmet_auth_sq_free(struct nvmet_sq *sq)\n{\n\tcancel_delayed_work(&sq->auth_expired_work);\n\tkfree(sq->dhchap_c1);\n\tsq->dhchap_c1 = NULL;\n\tkfree(sq->dhchap_c2);\n\tsq->dhchap_c2 = NULL;\n\tkfree(sq->dhchap_skey);\n\tsq->dhchap_skey = NULL;\n}\n\nvoid nvmet_destroy_auth(struct nvmet_ctrl *ctrl)\n{\n\tctrl->shash_id = 0;\n\n\tif (ctrl->dh_tfm) {\n\t\tcrypto_free_kpp(ctrl->dh_tfm);\n\t\tctrl->dh_tfm = NULL;\n\t\tctrl->dh_gid = 0;\n\t}\n\tkfree_sensitive(ctrl->dh_key);\n\tctrl->dh_key = NULL;\n\n\tif (ctrl->host_key) {\n\t\tnvme_auth_free_key(ctrl->host_key);\n\t\tctrl->host_key = NULL;\n\t}\n\tif (ctrl->ctrl_key) {\n\t\tnvme_auth_free_key(ctrl->ctrl_key);\n\t\tctrl->ctrl_key = NULL;\n\t}\n}\n\nbool nvmet_check_auth_status(struct nvmet_req *req)\n{\n\tif (req->sq->ctrl->host_key &&\n\t    !req->sq->authenticated)\n\t\treturn false;\n\treturn true;\n}\n\nint nvmet_auth_host_hash(struct nvmet_req *req, u8 *response,\n\t\t\t unsigned int shash_len)\n{\n\tstruct crypto_shash *shash_tfm;\n\tstruct shash_desc *shash;\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tconst char *hash_name;\n\tu8 *challenge = req->sq->dhchap_c1, *host_response;\n\tu8 buf[4];\n\tint ret;\n\n\thash_name = nvme_auth_hmac_name(ctrl->shash_id);\n\tif (!hash_name) {\n\t\tpr_warn(\"Hash ID %d invalid\\n\", ctrl->shash_id);\n\t\treturn -EINVAL;\n\t}\n\n\tshash_tfm = crypto_alloc_shash(hash_name, 0, 0);\n\tif (IS_ERR(shash_tfm)) {\n\t\tpr_err(\"failed to allocate shash %s\\n\", hash_name);\n\t\treturn PTR_ERR(shash_tfm);\n\t}\n\n\tif (shash_len != crypto_shash_digestsize(shash_tfm)) {\n\t\tpr_debug(\"%s: hash len mismatch (len %d digest %d)\\n\",\n\t\t\t __func__, shash_len,\n\t\t\t crypto_shash_digestsize(shash_tfm));\n\t\tret = -EINVAL;\n\t\tgoto out_free_tfm;\n\t}\n\n\thost_response = nvme_auth_transform_key(ctrl->host_key, ctrl->hostnqn);\n\tif (IS_ERR(host_response)) {\n\t\tret = PTR_ERR(host_response);\n\t\tgoto out_free_tfm;\n\t}\n\n\tret = crypto_shash_setkey(shash_tfm, host_response,\n\t\t\t\t  ctrl->host_key->len);\n\tif (ret)\n\t\tgoto out_free_response;\n\n\tif (ctrl->dh_gid != NVME_AUTH_DHGROUP_NULL) {\n\t\tchallenge = kmalloc(shash_len, GFP_KERNEL);\n\t\tif (!challenge) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free_response;\n\t\t}\n\t\tret = nvme_auth_augmented_challenge(ctrl->shash_id,\n\t\t\t\t\t\t    req->sq->dhchap_skey,\n\t\t\t\t\t\t    req->sq->dhchap_skey_len,\n\t\t\t\t\t\t    req->sq->dhchap_c1,\n\t\t\t\t\t\t    challenge, shash_len);\n\t\tif (ret)\n\t\t\tgoto out_free_response;\n\t}\n\n\tpr_debug(\"ctrl %d qid %d host response seq %u transaction %d\\n\",\n\t\t ctrl->cntlid, req->sq->qid, req->sq->dhchap_s1,\n\t\t req->sq->dhchap_tid);\n\n\tshash = kzalloc(sizeof(*shash) + crypto_shash_descsize(shash_tfm),\n\t\t\tGFP_KERNEL);\n\tif (!shash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_response;\n\t}\n\tshash->tfm = shash_tfm;\n\tret = crypto_shash_init(shash);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, challenge, shash_len);\n\tif (ret)\n\t\tgoto out;\n\tput_unaligned_le32(req->sq->dhchap_s1, buf);\n\tret = crypto_shash_update(shash, buf, 4);\n\tif (ret)\n\t\tgoto out;\n\tput_unaligned_le16(req->sq->dhchap_tid, buf);\n\tret = crypto_shash_update(shash, buf, 2);\n\tif (ret)\n\t\tgoto out;\n\tmemset(buf, 0, 4);\n\tret = crypto_shash_update(shash, buf, 1);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, \"HostHost\", 8);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, ctrl->hostnqn, strlen(ctrl->hostnqn));\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, buf, 1);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, ctrl->subsysnqn,\n\t\t\t\t  strlen(ctrl->subsysnqn));\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_final(shash, response);\nout:\n\tif (challenge != req->sq->dhchap_c1)\n\t\tkfree(challenge);\n\tkfree(shash);\nout_free_response:\n\tkfree_sensitive(host_response);\nout_free_tfm:\n\tcrypto_free_shash(shash_tfm);\n\treturn 0;\n}\n\nint nvmet_auth_ctrl_hash(struct nvmet_req *req, u8 *response,\n\t\t\t unsigned int shash_len)\n{\n\tstruct crypto_shash *shash_tfm;\n\tstruct shash_desc *shash;\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tconst char *hash_name;\n\tu8 *challenge = req->sq->dhchap_c2, *ctrl_response;\n\tu8 buf[4];\n\tint ret;\n\n\thash_name = nvme_auth_hmac_name(ctrl->shash_id);\n\tif (!hash_name) {\n\t\tpr_warn(\"Hash ID %d invalid\\n\", ctrl->shash_id);\n\t\treturn -EINVAL;\n\t}\n\n\tshash_tfm = crypto_alloc_shash(hash_name, 0, 0);\n\tif (IS_ERR(shash_tfm)) {\n\t\tpr_err(\"failed to allocate shash %s\\n\", hash_name);\n\t\treturn PTR_ERR(shash_tfm);\n\t}\n\n\tif (shash_len != crypto_shash_digestsize(shash_tfm)) {\n\t\tpr_debug(\"%s: hash len mismatch (len %d digest %d)\\n\",\n\t\t\t __func__, shash_len,\n\t\t\t crypto_shash_digestsize(shash_tfm));\n\t\tret = -EINVAL;\n\t\tgoto out_free_tfm;\n\t}\n\n\tctrl_response = nvme_auth_transform_key(ctrl->ctrl_key,\n\t\t\t\t\t\tctrl->subsysnqn);\n\tif (IS_ERR(ctrl_response)) {\n\t\tret = PTR_ERR(ctrl_response);\n\t\tgoto out_free_tfm;\n\t}\n\n\tret = crypto_shash_setkey(shash_tfm, ctrl_response,\n\t\t\t\t  ctrl->ctrl_key->len);\n\tif (ret)\n\t\tgoto out_free_response;\n\n\tif (ctrl->dh_gid != NVME_AUTH_DHGROUP_NULL) {\n\t\tchallenge = kmalloc(shash_len, GFP_KERNEL);\n\t\tif (!challenge) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free_response;\n\t\t}\n\t\tret = nvme_auth_augmented_challenge(ctrl->shash_id,\n\t\t\t\t\t\t    req->sq->dhchap_skey,\n\t\t\t\t\t\t    req->sq->dhchap_skey_len,\n\t\t\t\t\t\t    req->sq->dhchap_c2,\n\t\t\t\t\t\t    challenge, shash_len);\n\t\tif (ret)\n\t\t\tgoto out_free_response;\n\t}\n\n\tshash = kzalloc(sizeof(*shash) + crypto_shash_descsize(shash_tfm),\n\t\t\tGFP_KERNEL);\n\tif (!shash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_response;\n\t}\n\tshash->tfm = shash_tfm;\n\n\tret = crypto_shash_init(shash);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, challenge, shash_len);\n\tif (ret)\n\t\tgoto out;\n\tput_unaligned_le32(req->sq->dhchap_s2, buf);\n\tret = crypto_shash_update(shash, buf, 4);\n\tif (ret)\n\t\tgoto out;\n\tput_unaligned_le16(req->sq->dhchap_tid, buf);\n\tret = crypto_shash_update(shash, buf, 2);\n\tif (ret)\n\t\tgoto out;\n\tmemset(buf, 0, 4);\n\tret = crypto_shash_update(shash, buf, 1);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, \"Controller\", 10);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, ctrl->subsysnqn,\n\t\t\t    strlen(ctrl->subsysnqn));\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, buf, 1);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(shash, ctrl->hostnqn, strlen(ctrl->hostnqn));\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_final(shash, response);\nout:\n\tif (challenge != req->sq->dhchap_c2)\n\t\tkfree(challenge);\n\tkfree(shash);\nout_free_response:\n\tkfree_sensitive(ctrl_response);\nout_free_tfm:\n\tcrypto_free_shash(shash_tfm);\n\treturn 0;\n}\n\nint nvmet_auth_ctrl_exponential(struct nvmet_req *req,\n\t\t\t\tu8 *buf, int buf_size)\n{\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tint ret = 0;\n\n\tif (!ctrl->dh_key) {\n\t\tpr_warn(\"ctrl %d no DH public key!\\n\", ctrl->cntlid);\n\t\treturn -ENOKEY;\n\t}\n\tif (buf_size != ctrl->dh_keysize) {\n\t\tpr_warn(\"ctrl %d DH public key size mismatch, need %zu is %d\\n\",\n\t\t\tctrl->cntlid, ctrl->dh_keysize, buf_size);\n\t\tret = -EINVAL;\n\t} else {\n\t\tmemcpy(buf, ctrl->dh_key, buf_size);\n\t\tpr_debug(\"%s: ctrl %d public key %*ph\\n\", __func__,\n\t\t\t ctrl->cntlid, (int)buf_size, buf);\n\t}\n\n\treturn ret;\n}\n\nint nvmet_auth_ctrl_sesskey(struct nvmet_req *req,\n\t\t\t    u8 *pkey, int pkey_size)\n{\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tint ret;\n\n\treq->sq->dhchap_skey_len = ctrl->dh_keysize;\n\treq->sq->dhchap_skey = kzalloc(req->sq->dhchap_skey_len, GFP_KERNEL);\n\tif (!req->sq->dhchap_skey)\n\t\treturn -ENOMEM;\n\tret = nvme_auth_gen_shared_secret(ctrl->dh_tfm,\n\t\t\t\t\t  pkey, pkey_size,\n\t\t\t\t\t  req->sq->dhchap_skey,\n\t\t\t\t\t  req->sq->dhchap_skey_len);\n\tif (ret)\n\t\tpr_debug(\"failed to compute shared secret, err %d\\n\", ret);\n\telse\n\t\tpr_debug(\"%s: shared secret %*ph\\n\", __func__,\n\t\t\t (int)req->sq->dhchap_skey_len,\n\t\t\t req->sq->dhchap_skey);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}