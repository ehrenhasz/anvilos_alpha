{
  "module_name": "io-cmd-file.c",
  "hash_id": "999875061564995d70a5fde1a47e34753765f307cc0d2c202081c711abfa0520",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/target/io-cmd-file.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/uio.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include \"nvmet.h\"\n\n#define NVMET_MIN_MPOOL_OBJ\t\t16\n\nvoid nvmet_file_ns_revalidate(struct nvmet_ns *ns)\n{\n\tns->size = i_size_read(ns->file->f_mapping->host);\n}\n\nvoid nvmet_file_ns_disable(struct nvmet_ns *ns)\n{\n\tif (ns->file) {\n\t\tif (ns->buffered_io)\n\t\t\tflush_workqueue(buffered_io_wq);\n\t\tmempool_destroy(ns->bvec_pool);\n\t\tns->bvec_pool = NULL;\n\t\tfput(ns->file);\n\t\tns->file = NULL;\n\t}\n}\n\nint nvmet_file_ns_enable(struct nvmet_ns *ns)\n{\n\tint flags = O_RDWR | O_LARGEFILE;\n\tint ret = 0;\n\n\tif (!ns->buffered_io)\n\t\tflags |= O_DIRECT;\n\n\tns->file = filp_open(ns->device_path, flags, 0);\n\tif (IS_ERR(ns->file)) {\n\t\tret = PTR_ERR(ns->file);\n\t\tpr_err(\"failed to open file %s: (%d)\\n\",\n\t\t\tns->device_path, ret);\n\t\tns->file = NULL;\n\t\treturn ret;\n\t}\n\n\tnvmet_file_ns_revalidate(ns);\n\n\t \n\tns->blksize_shift = min_t(u8,\n\t\t\tfile_inode(ns->file)->i_blkbits, 12);\n\n\tns->bvec_pool = mempool_create(NVMET_MIN_MPOOL_OBJ, mempool_alloc_slab,\n\t\t\tmempool_free_slab, nvmet_bvec_cache);\n\n\tif (!ns->bvec_pool) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\treturn ret;\nerr:\n\tfput(ns->file);\n\tns->file = NULL;\n\tns->size = 0;\n\tns->blksize_shift = 0;\n\treturn ret;\n}\n\nstatic ssize_t nvmet_file_submit_bvec(struct nvmet_req *req, loff_t pos,\n\t\tunsigned long nr_segs, size_t count, int ki_flags)\n{\n\tstruct kiocb *iocb = &req->f.iocb;\n\tssize_t (*call_iter)(struct kiocb *iocb, struct iov_iter *iter);\n\tstruct iov_iter iter;\n\tint rw;\n\n\tif (req->cmd->rw.opcode == nvme_cmd_write) {\n\t\tif (req->cmd->rw.control & cpu_to_le16(NVME_RW_FUA))\n\t\t\tki_flags |= IOCB_DSYNC;\n\t\tcall_iter = req->ns->file->f_op->write_iter;\n\t\trw = ITER_SOURCE;\n\t} else {\n\t\tcall_iter = req->ns->file->f_op->read_iter;\n\t\trw = ITER_DEST;\n\t}\n\n\tiov_iter_bvec(&iter, rw, req->f.bvec, nr_segs, count);\n\n\tiocb->ki_pos = pos;\n\tiocb->ki_filp = req->ns->file;\n\tiocb->ki_flags = ki_flags | iocb->ki_filp->f_iocb_flags;\n\n\treturn call_iter(iocb, &iter);\n}\n\nstatic void nvmet_file_io_done(struct kiocb *iocb, long ret)\n{\n\tstruct nvmet_req *req = container_of(iocb, struct nvmet_req, f.iocb);\n\tu16 status = NVME_SC_SUCCESS;\n\n\tif (req->f.bvec != req->inline_bvec) {\n\t\tif (likely(req->f.mpool_alloc == false))\n\t\t\tkfree(req->f.bvec);\n\t\telse\n\t\t\tmempool_free(req->f.bvec, req->ns->bvec_pool);\n\t}\n\n\tif (unlikely(ret != req->transfer_len))\n\t\tstatus = errno_to_nvme_status(req, ret);\n\tnvmet_req_complete(req, status);\n}\n\nstatic bool nvmet_file_execute_io(struct nvmet_req *req, int ki_flags)\n{\n\tssize_t nr_bvec = req->sg_cnt;\n\tunsigned long bv_cnt = 0;\n\tbool is_sync = false;\n\tsize_t len = 0, total_len = 0;\n\tssize_t ret = 0;\n\tloff_t pos;\n\tint i;\n\tstruct scatterlist *sg;\n\n\tif (req->f.mpool_alloc && nr_bvec > NVMET_MAX_MPOOL_BVEC)\n\t\tis_sync = true;\n\n\tpos = le64_to_cpu(req->cmd->rw.slba) << req->ns->blksize_shift;\n\tif (unlikely(pos + req->transfer_len > req->ns->size)) {\n\t\tnvmet_req_complete(req, errno_to_nvme_status(req, -ENOSPC));\n\t\treturn true;\n\t}\n\n\tmemset(&req->f.iocb, 0, sizeof(struct kiocb));\n\tfor_each_sg(req->sg, sg, req->sg_cnt, i) {\n\t\tbvec_set_page(&req->f.bvec[bv_cnt], sg_page(sg), sg->length,\n\t\t\t      sg->offset);\n\t\tlen += req->f.bvec[bv_cnt].bv_len;\n\t\ttotal_len += req->f.bvec[bv_cnt].bv_len;\n\t\tbv_cnt++;\n\n\t\tWARN_ON_ONCE((nr_bvec - 1) < 0);\n\n\t\tif (unlikely(is_sync) &&\n\t\t    (nr_bvec - 1 == 0 || bv_cnt == NVMET_MAX_MPOOL_BVEC)) {\n\t\t\tret = nvmet_file_submit_bvec(req, pos, bv_cnt, len, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto complete;\n\n\t\t\tpos += len;\n\t\t\tbv_cnt = 0;\n\t\t\tlen = 0;\n\t\t}\n\t\tnr_bvec--;\n\t}\n\n\tif (WARN_ON_ONCE(total_len != req->transfer_len)) {\n\t\tret = -EIO;\n\t\tgoto complete;\n\t}\n\n\tif (unlikely(is_sync)) {\n\t\tret = total_len;\n\t\tgoto complete;\n\t}\n\n\t \n\tif (!(ki_flags & IOCB_NOWAIT))\n\t\treq->f.iocb.ki_complete = nvmet_file_io_done;\n\n\tret = nvmet_file_submit_bvec(req, pos, bv_cnt, total_len, ki_flags);\n\n\tswitch (ret) {\n\tcase -EIOCBQUEUED:\n\t\treturn true;\n\tcase -EAGAIN:\n\t\tif (WARN_ON_ONCE(!(ki_flags & IOCB_NOWAIT)))\n\t\t\tgoto complete;\n\t\treturn false;\n\tcase -EOPNOTSUPP:\n\t\t \n\t\tif ((ki_flags & IOCB_NOWAIT))\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\ncomplete:\n\tnvmet_file_io_done(&req->f.iocb, ret);\n\treturn true;\n}\n\nstatic void nvmet_file_buffered_io_work(struct work_struct *w)\n{\n\tstruct nvmet_req *req = container_of(w, struct nvmet_req, f.work);\n\n\tnvmet_file_execute_io(req, 0);\n}\n\nstatic void nvmet_file_submit_buffered_io(struct nvmet_req *req)\n{\n\tINIT_WORK(&req->f.work, nvmet_file_buffered_io_work);\n\tqueue_work(buffered_io_wq, &req->f.work);\n}\n\nstatic void nvmet_file_execute_rw(struct nvmet_req *req)\n{\n\tssize_t nr_bvec = req->sg_cnt;\n\n\tif (!nvmet_check_transfer_len(req, nvmet_rw_data_len(req)))\n\t\treturn;\n\n\tif (!req->sg_cnt || !nr_bvec) {\n\t\tnvmet_req_complete(req, 0);\n\t\treturn;\n\t}\n\n\tif (nr_bvec > NVMET_MAX_INLINE_BIOVEC)\n\t\treq->f.bvec = kmalloc_array(nr_bvec, sizeof(struct bio_vec),\n\t\t\t\tGFP_KERNEL);\n\telse\n\t\treq->f.bvec = req->inline_bvec;\n\n\tif (unlikely(!req->f.bvec)) {\n\t\t \n\t\treq->f.bvec = mempool_alloc(req->ns->bvec_pool, GFP_KERNEL);\n\t\treq->f.mpool_alloc = true;\n\t} else\n\t\treq->f.mpool_alloc = false;\n\n\tif (req->ns->buffered_io) {\n\t\tif (likely(!req->f.mpool_alloc) &&\n\t\t    (req->ns->file->f_mode & FMODE_NOWAIT) &&\n\t\t    nvmet_file_execute_io(req, IOCB_NOWAIT))\n\t\t\treturn;\n\t\tnvmet_file_submit_buffered_io(req);\n\t} else\n\t\tnvmet_file_execute_io(req, 0);\n}\n\nu16 nvmet_file_flush(struct nvmet_req *req)\n{\n\treturn errno_to_nvme_status(req, vfs_fsync(req->ns->file, 1));\n}\n\nstatic void nvmet_file_flush_work(struct work_struct *w)\n{\n\tstruct nvmet_req *req = container_of(w, struct nvmet_req, f.work);\n\n\tnvmet_req_complete(req, nvmet_file_flush(req));\n}\n\nstatic void nvmet_file_execute_flush(struct nvmet_req *req)\n{\n\tif (!nvmet_check_transfer_len(req, 0))\n\t\treturn;\n\tINIT_WORK(&req->f.work, nvmet_file_flush_work);\n\tqueue_work(nvmet_wq, &req->f.work);\n}\n\nstatic void nvmet_file_execute_discard(struct nvmet_req *req)\n{\n\tint mode = FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE;\n\tstruct nvme_dsm_range range;\n\tloff_t offset, len;\n\tu16 status = 0;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i <= le32_to_cpu(req->cmd->dsm.nr); i++) {\n\t\tstatus = nvmet_copy_from_sgl(req, i * sizeof(range), &range,\n\t\t\t\t\tsizeof(range));\n\t\tif (status)\n\t\t\tbreak;\n\n\t\toffset = le64_to_cpu(range.slba) << req->ns->blksize_shift;\n\t\tlen = le32_to_cpu(range.nlb);\n\t\tlen <<= req->ns->blksize_shift;\n\t\tif (offset + len > req->ns->size) {\n\t\t\treq->error_slba = le64_to_cpu(range.slba);\n\t\t\tstatus = errno_to_nvme_status(req, -ENOSPC);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = vfs_fallocate(req->ns->file, mode, offset, len);\n\t\tif (ret && ret != -EOPNOTSUPP) {\n\t\t\treq->error_slba = le64_to_cpu(range.slba);\n\t\t\tstatus = errno_to_nvme_status(req, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnvmet_req_complete(req, status);\n}\n\nstatic void nvmet_file_dsm_work(struct work_struct *w)\n{\n\tstruct nvmet_req *req = container_of(w, struct nvmet_req, f.work);\n\n\tswitch (le32_to_cpu(req->cmd->dsm.attributes)) {\n\tcase NVME_DSMGMT_AD:\n\t\tnvmet_file_execute_discard(req);\n\t\treturn;\n\tcase NVME_DSMGMT_IDR:\n\tcase NVME_DSMGMT_IDW:\n\tdefault:\n\t\t \n\t\tnvmet_req_complete(req, 0);\n\t\treturn;\n\t}\n}\n\nstatic void nvmet_file_execute_dsm(struct nvmet_req *req)\n{\n\tif (!nvmet_check_data_len_lte(req, nvmet_dsm_len(req)))\n\t\treturn;\n\tINIT_WORK(&req->f.work, nvmet_file_dsm_work);\n\tqueue_work(nvmet_wq, &req->f.work);\n}\n\nstatic void nvmet_file_write_zeroes_work(struct work_struct *w)\n{\n\tstruct nvmet_req *req = container_of(w, struct nvmet_req, f.work);\n\tstruct nvme_write_zeroes_cmd *write_zeroes = &req->cmd->write_zeroes;\n\tint mode = FALLOC_FL_ZERO_RANGE | FALLOC_FL_KEEP_SIZE;\n\tloff_t offset;\n\tloff_t len;\n\tint ret;\n\n\toffset = le64_to_cpu(write_zeroes->slba) << req->ns->blksize_shift;\n\tlen = (((sector_t)le16_to_cpu(write_zeroes->length) + 1) <<\n\t\t\treq->ns->blksize_shift);\n\n\tif (unlikely(offset + len > req->ns->size)) {\n\t\tnvmet_req_complete(req, errno_to_nvme_status(req, -ENOSPC));\n\t\treturn;\n\t}\n\n\tret = vfs_fallocate(req->ns->file, mode, offset, len);\n\tnvmet_req_complete(req, ret < 0 ? errno_to_nvme_status(req, ret) : 0);\n}\n\nstatic void nvmet_file_execute_write_zeroes(struct nvmet_req *req)\n{\n\tif (!nvmet_check_transfer_len(req, 0))\n\t\treturn;\n\tINIT_WORK(&req->f.work, nvmet_file_write_zeroes_work);\n\tqueue_work(nvmet_wq, &req->f.work);\n}\n\nu16 nvmet_file_parse_io_cmd(struct nvmet_req *req)\n{\n\tswitch (req->cmd->common.opcode) {\n\tcase nvme_cmd_read:\n\tcase nvme_cmd_write:\n\t\treq->execute = nvmet_file_execute_rw;\n\t\treturn 0;\n\tcase nvme_cmd_flush:\n\t\treq->execute = nvmet_file_execute_flush;\n\t\treturn 0;\n\tcase nvme_cmd_dsm:\n\t\treq->execute = nvmet_file_execute_dsm;\n\t\treturn 0;\n\tcase nvme_cmd_write_zeroes:\n\t\treq->execute = nvmet_file_execute_write_zeroes;\n\t\treturn 0;\n\tdefault:\n\t\treturn nvmet_report_invalid_opcode(req);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}