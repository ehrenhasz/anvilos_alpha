{
  "module_name": "io-cmd-bdev.c",
  "hash_id": "0bda34f92adbd4979f29ed39365da53c0757f59132df6db114d5eb7d4b20bd62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/target/io-cmd-bdev.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/blkdev.h>\n#include <linux/blk-integrity.h>\n#include <linux/memremap.h>\n#include <linux/module.h>\n#include \"nvmet.h\"\n\nvoid nvmet_bdev_set_limits(struct block_device *bdev, struct nvme_id_ns *id)\n{\n\t \n\tconst __le16 lpp0b = to0based(bdev_physical_block_size(bdev) /\n\t\t\t\t      bdev_logical_block_size(bdev));\n\n\t \n\tid->nsfeat |= 1 << 1;\n\tid->nawun = lpp0b;\n\tid->nawupf = lpp0b;\n\tid->nacwu = lpp0b;\n\n\t \n\tid->nsfeat |= 1 << 4;\n\t \n\tid->npwg = lpp0b;\n\t \n\tid->npwa = id->npwg;\n\t \n\tid->npdg = to0based(bdev_discard_granularity(bdev) /\n\t\t\t    bdev_logical_block_size(bdev));\n\t \n\tid->npda = id->npdg;\n\t \n\tid->nows = to0based(bdev_io_opt(bdev) / bdev_logical_block_size(bdev));\n}\n\nvoid nvmet_bdev_ns_disable(struct nvmet_ns *ns)\n{\n\tif (ns->bdev) {\n\t\tblkdev_put(ns->bdev, NULL);\n\t\tns->bdev = NULL;\n\t}\n}\n\nstatic void nvmet_bdev_ns_enable_integrity(struct nvmet_ns *ns)\n{\n\tstruct blk_integrity *bi = bdev_get_integrity(ns->bdev);\n\n\tif (bi) {\n\t\tns->metadata_size = bi->tuple_size;\n\t\tif (bi->profile == &t10_pi_type1_crc)\n\t\t\tns->pi_type = NVME_NS_DPS_PI_TYPE1;\n\t\telse if (bi->profile == &t10_pi_type3_crc)\n\t\t\tns->pi_type = NVME_NS_DPS_PI_TYPE3;\n\t\telse\n\t\t\t \n\t\t\tns->metadata_size = 0;\n\t}\n}\n\nint nvmet_bdev_ns_enable(struct nvmet_ns *ns)\n{\n\tint ret;\n\n\t \n\tif (ns->buffered_io)\n\t\treturn -ENOTBLK;\n\n\tns->bdev = blkdev_get_by_path(ns->device_path,\n\t\t\tBLK_OPEN_READ | BLK_OPEN_WRITE, NULL, NULL);\n\tif (IS_ERR(ns->bdev)) {\n\t\tret = PTR_ERR(ns->bdev);\n\t\tif (ret != -ENOTBLK) {\n\t\t\tpr_err(\"failed to open block device %s: (%ld)\\n\",\n\t\t\t\t\tns->device_path, PTR_ERR(ns->bdev));\n\t\t}\n\t\tns->bdev = NULL;\n\t\treturn ret;\n\t}\n\tns->size = bdev_nr_bytes(ns->bdev);\n\tns->blksize_shift = blksize_bits(bdev_logical_block_size(ns->bdev));\n\n\tns->pi_type = 0;\n\tns->metadata_size = 0;\n\tif (IS_ENABLED(CONFIG_BLK_DEV_INTEGRITY_T10))\n\t\tnvmet_bdev_ns_enable_integrity(ns);\n\n\tif (bdev_is_zoned(ns->bdev)) {\n\t\tif (!nvmet_bdev_zns_enable(ns)) {\n\t\t\tnvmet_bdev_ns_disable(ns);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tns->csi = NVME_CSI_ZNS;\n\t}\n\n\treturn 0;\n}\n\nvoid nvmet_bdev_ns_revalidate(struct nvmet_ns *ns)\n{\n\tns->size = bdev_nr_bytes(ns->bdev);\n}\n\nu16 blk_to_nvme_status(struct nvmet_req *req, blk_status_t blk_sts)\n{\n\tu16 status = NVME_SC_SUCCESS;\n\n\tif (likely(blk_sts == BLK_STS_OK))\n\t\treturn status;\n\t \n\tswitch (blk_sts) {\n\tcase BLK_STS_NOSPC:\n\t\tstatus = NVME_SC_CAP_EXCEEDED | NVME_SC_DNR;\n\t\treq->error_loc = offsetof(struct nvme_rw_command, length);\n\t\tbreak;\n\tcase BLK_STS_TARGET:\n\t\tstatus = NVME_SC_LBA_RANGE | NVME_SC_DNR;\n\t\treq->error_loc = offsetof(struct nvme_rw_command, slba);\n\t\tbreak;\n\tcase BLK_STS_NOTSUPP:\n\t\treq->error_loc = offsetof(struct nvme_common_command, opcode);\n\t\tswitch (req->cmd->common.opcode) {\n\t\tcase nvme_cmd_dsm:\n\t\tcase nvme_cmd_write_zeroes:\n\t\t\tstatus = NVME_SC_ONCS_NOT_SUPPORTED | NVME_SC_DNR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = NVME_SC_INVALID_OPCODE | NVME_SC_DNR;\n\t\t}\n\t\tbreak;\n\tcase BLK_STS_MEDIUM:\n\t\tstatus = NVME_SC_ACCESS_DENIED;\n\t\treq->error_loc = offsetof(struct nvme_rw_command, nsid);\n\t\tbreak;\n\tcase BLK_STS_IOERR:\n\tdefault:\n\t\tstatus = NVME_SC_INTERNAL | NVME_SC_DNR;\n\t\treq->error_loc = offsetof(struct nvme_common_command, opcode);\n\t}\n\n\tswitch (req->cmd->common.opcode) {\n\tcase nvme_cmd_read:\n\tcase nvme_cmd_write:\n\t\treq->error_slba = le64_to_cpu(req->cmd->rw.slba);\n\t\tbreak;\n\tcase nvme_cmd_write_zeroes:\n\t\treq->error_slba =\n\t\t\tle64_to_cpu(req->cmd->write_zeroes.slba);\n\t\tbreak;\n\tdefault:\n\t\treq->error_slba = 0;\n\t}\n\treturn status;\n}\n\nstatic void nvmet_bio_done(struct bio *bio)\n{\n\tstruct nvmet_req *req = bio->bi_private;\n\n\tnvmet_req_complete(req, blk_to_nvme_status(req, bio->bi_status));\n\tnvmet_req_bio_put(req, bio);\n}\n\n#ifdef CONFIG_BLK_DEV_INTEGRITY\nstatic int nvmet_bdev_alloc_bip(struct nvmet_req *req, struct bio *bio,\n\t\t\t\tstruct sg_mapping_iter *miter)\n{\n\tstruct blk_integrity *bi;\n\tstruct bio_integrity_payload *bip;\n\tint rc;\n\tsize_t resid, len;\n\n\tbi = bdev_get_integrity(req->ns->bdev);\n\tif (unlikely(!bi)) {\n\t\tpr_err(\"Unable to locate bio_integrity\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbip = bio_integrity_alloc(bio, GFP_NOIO,\n\t\t\t\t\tbio_max_segs(req->metadata_sg_cnt));\n\tif (IS_ERR(bip)) {\n\t\tpr_err(\"Unable to allocate bio_integrity_payload\\n\");\n\t\treturn PTR_ERR(bip);\n\t}\n\n\t \n\tbip_set_seed(bip, bio->bi_iter.bi_sector >>\n\t\t     (bi->interval_exp - SECTOR_SHIFT));\n\n\tresid = bio_integrity_bytes(bi, bio_sectors(bio));\n\twhile (resid > 0 && sg_miter_next(miter)) {\n\t\tlen = min_t(size_t, miter->length, resid);\n\t\trc = bio_integrity_add_page(bio, miter->page, len,\n\t\t\t\t\t    offset_in_page(miter->addr));\n\t\tif (unlikely(rc != len)) {\n\t\t\tpr_err(\"bio_integrity_add_page() failed; %d\\n\", rc);\n\t\t\tsg_miter_stop(miter);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tresid -= len;\n\t\tif (len < miter->length)\n\t\t\tmiter->consumed -= miter->length - len;\n\t}\n\tsg_miter_stop(miter);\n\n\treturn 0;\n}\n#else\nstatic int nvmet_bdev_alloc_bip(struct nvmet_req *req, struct bio *bio,\n\t\t\t\tstruct sg_mapping_iter *miter)\n{\n\treturn -EINVAL;\n}\n#endif  \n\nstatic void nvmet_bdev_execute_rw(struct nvmet_req *req)\n{\n\tunsigned int sg_cnt = req->sg_cnt;\n\tstruct bio *bio;\n\tstruct scatterlist *sg;\n\tstruct blk_plug plug;\n\tsector_t sector;\n\tblk_opf_t opf;\n\tint i, rc;\n\tstruct sg_mapping_iter prot_miter;\n\tunsigned int iter_flags;\n\tunsigned int total_len = nvmet_rw_data_len(req) + req->metadata_len;\n\n\tif (!nvmet_check_transfer_len(req, total_len))\n\t\treturn;\n\n\tif (!req->sg_cnt) {\n\t\tnvmet_req_complete(req, 0);\n\t\treturn;\n\t}\n\n\tif (req->cmd->rw.opcode == nvme_cmd_write) {\n\t\topf = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;\n\t\tif (req->cmd->rw.control & cpu_to_le16(NVME_RW_FUA))\n\t\t\topf |= REQ_FUA;\n\t\titer_flags = SG_MITER_TO_SG;\n\t} else {\n\t\topf = REQ_OP_READ;\n\t\titer_flags = SG_MITER_FROM_SG;\n\t}\n\n\tif (is_pci_p2pdma_page(sg_page(req->sg)))\n\t\topf |= REQ_NOMERGE;\n\n\tsector = nvmet_lba_to_sect(req->ns, req->cmd->rw.slba);\n\n\tif (nvmet_use_inline_bvec(req)) {\n\t\tbio = &req->b.inline_bio;\n\t\tbio_init(bio, req->ns->bdev, req->inline_bvec,\n\t\t\t ARRAY_SIZE(req->inline_bvec), opf);\n\t} else {\n\t\tbio = bio_alloc(req->ns->bdev, bio_max_segs(sg_cnt), opf,\n\t\t\t\tGFP_KERNEL);\n\t}\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_private = req;\n\tbio->bi_end_io = nvmet_bio_done;\n\n\tblk_start_plug(&plug);\n\tif (req->metadata_len)\n\t\tsg_miter_start(&prot_miter, req->metadata_sg,\n\t\t\t       req->metadata_sg_cnt, iter_flags);\n\n\tfor_each_sg(req->sg, sg, req->sg_cnt, i) {\n\t\twhile (bio_add_page(bio, sg_page(sg), sg->length, sg->offset)\n\t\t\t\t!= sg->length) {\n\t\t\tstruct bio *prev = bio;\n\n\t\t\tif (req->metadata_len) {\n\t\t\t\trc = nvmet_bdev_alloc_bip(req, bio,\n\t\t\t\t\t\t\t  &prot_miter);\n\t\t\t\tif (unlikely(rc)) {\n\t\t\t\t\tbio_io_error(bio);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbio = bio_alloc(req->ns->bdev, bio_max_segs(sg_cnt),\n\t\t\t\t\topf, GFP_KERNEL);\n\t\t\tbio->bi_iter.bi_sector = sector;\n\n\t\t\tbio_chain(bio, prev);\n\t\t\tsubmit_bio(prev);\n\t\t}\n\n\t\tsector += sg->length >> 9;\n\t\tsg_cnt--;\n\t}\n\n\tif (req->metadata_len) {\n\t\trc = nvmet_bdev_alloc_bip(req, bio, &prot_miter);\n\t\tif (unlikely(rc)) {\n\t\t\tbio_io_error(bio);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsubmit_bio(bio);\n\tblk_finish_plug(&plug);\n}\n\nstatic void nvmet_bdev_execute_flush(struct nvmet_req *req)\n{\n\tstruct bio *bio = &req->b.inline_bio;\n\n\tif (!bdev_write_cache(req->ns->bdev)) {\n\t\tnvmet_req_complete(req, NVME_SC_SUCCESS);\n\t\treturn;\n\t}\n\n\tif (!nvmet_check_transfer_len(req, 0))\n\t\treturn;\n\n\tbio_init(bio, req->ns->bdev, req->inline_bvec,\n\t\t ARRAY_SIZE(req->inline_bvec), REQ_OP_WRITE | REQ_PREFLUSH);\n\tbio->bi_private = req;\n\tbio->bi_end_io = nvmet_bio_done;\n\n\tsubmit_bio(bio);\n}\n\nu16 nvmet_bdev_flush(struct nvmet_req *req)\n{\n\tif (!bdev_write_cache(req->ns->bdev))\n\t\treturn 0;\n\n\tif (blkdev_issue_flush(req->ns->bdev))\n\t\treturn NVME_SC_INTERNAL | NVME_SC_DNR;\n\treturn 0;\n}\n\nstatic u16 nvmet_bdev_discard_range(struct nvmet_req *req,\n\t\tstruct nvme_dsm_range *range, struct bio **bio)\n{\n\tstruct nvmet_ns *ns = req->ns;\n\tint ret;\n\n\tret = __blkdev_issue_discard(ns->bdev,\n\t\t\tnvmet_lba_to_sect(ns, range->slba),\n\t\t\tle32_to_cpu(range->nlb) << (ns->blksize_shift - 9),\n\t\t\tGFP_KERNEL, bio);\n\tif (ret && ret != -EOPNOTSUPP) {\n\t\treq->error_slba = le64_to_cpu(range->slba);\n\t\treturn errno_to_nvme_status(req, ret);\n\t}\n\treturn NVME_SC_SUCCESS;\n}\n\nstatic void nvmet_bdev_execute_discard(struct nvmet_req *req)\n{\n\tstruct nvme_dsm_range range;\n\tstruct bio *bio = NULL;\n\tint i;\n\tu16 status;\n\n\tfor (i = 0; i <= le32_to_cpu(req->cmd->dsm.nr); i++) {\n\t\tstatus = nvmet_copy_from_sgl(req, i * sizeof(range), &range,\n\t\t\t\tsizeof(range));\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tstatus = nvmet_bdev_discard_range(req, &range, &bio);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\n\tif (bio) {\n\t\tbio->bi_private = req;\n\t\tbio->bi_end_io = nvmet_bio_done;\n\t\tif (status)\n\t\t\tbio_io_error(bio);\n\t\telse\n\t\t\tsubmit_bio(bio);\n\t} else {\n\t\tnvmet_req_complete(req, status);\n\t}\n}\n\nstatic void nvmet_bdev_execute_dsm(struct nvmet_req *req)\n{\n\tif (!nvmet_check_data_len_lte(req, nvmet_dsm_len(req)))\n\t\treturn;\n\n\tswitch (le32_to_cpu(req->cmd->dsm.attributes)) {\n\tcase NVME_DSMGMT_AD:\n\t\tnvmet_bdev_execute_discard(req);\n\t\treturn;\n\tcase NVME_DSMGMT_IDR:\n\tcase NVME_DSMGMT_IDW:\n\tdefault:\n\t\t \n\t\tnvmet_req_complete(req, 0);\n\t\treturn;\n\t}\n}\n\nstatic void nvmet_bdev_execute_write_zeroes(struct nvmet_req *req)\n{\n\tstruct nvme_write_zeroes_cmd *write_zeroes = &req->cmd->write_zeroes;\n\tstruct bio *bio = NULL;\n\tsector_t sector;\n\tsector_t nr_sector;\n\tint ret;\n\n\tif (!nvmet_check_transfer_len(req, 0))\n\t\treturn;\n\n\tsector = nvmet_lba_to_sect(req->ns, write_zeroes->slba);\n\tnr_sector = (((sector_t)le16_to_cpu(write_zeroes->length) + 1) <<\n\t\t(req->ns->blksize_shift - 9));\n\n\tret = __blkdev_issue_zeroout(req->ns->bdev, sector, nr_sector,\n\t\t\tGFP_KERNEL, &bio, 0);\n\tif (bio) {\n\t\tbio->bi_private = req;\n\t\tbio->bi_end_io = nvmet_bio_done;\n\t\tsubmit_bio(bio);\n\t} else {\n\t\tnvmet_req_complete(req, errno_to_nvme_status(req, ret));\n\t}\n}\n\nu16 nvmet_bdev_parse_io_cmd(struct nvmet_req *req)\n{\n\tswitch (req->cmd->common.opcode) {\n\tcase nvme_cmd_read:\n\tcase nvme_cmd_write:\n\t\treq->execute = nvmet_bdev_execute_rw;\n\t\tif (req->sq->ctrl->pi_support && nvmet_ns_has_pi(req->ns))\n\t\t\treq->metadata_len = nvmet_rw_metadata_len(req);\n\t\treturn 0;\n\tcase nvme_cmd_flush:\n\t\treq->execute = nvmet_bdev_execute_flush;\n\t\treturn 0;\n\tcase nvme_cmd_dsm:\n\t\treq->execute = nvmet_bdev_execute_dsm;\n\t\treturn 0;\n\tcase nvme_cmd_write_zeroes:\n\t\treq->execute = nvmet_bdev_execute_write_zeroes;\n\t\treturn 0;\n\tdefault:\n\t\treturn nvmet_report_invalid_opcode(req);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}