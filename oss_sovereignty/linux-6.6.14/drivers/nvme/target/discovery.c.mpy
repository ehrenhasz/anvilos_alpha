{
  "module_name": "discovery.c",
  "hash_id": "f778f3dd02400d79aa8f9601432843e03f7271ab79f522a0b389c238365768d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/target/discovery.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/slab.h>\n#include <generated/utsrelease.h>\n#include \"nvmet.h\"\n\nstruct nvmet_subsys *nvmet_disc_subsys;\n\nstatic u64 nvmet_genctr;\n\nstatic void __nvmet_disc_changed(struct nvmet_port *port,\n\t\t\t\t struct nvmet_ctrl *ctrl)\n{\n\tif (ctrl->port != port)\n\t\treturn;\n\n\tif (nvmet_aen_bit_disabled(ctrl, NVME_AEN_BIT_DISC_CHANGE))\n\t\treturn;\n\n\tnvmet_add_async_event(ctrl, NVME_AER_TYPE_NOTICE,\n\t\t\t      NVME_AER_NOTICE_DISC_CHANGED, NVME_LOG_DISC);\n}\n\nvoid nvmet_port_disc_changed(struct nvmet_port *port,\n\t\t\t     struct nvmet_subsys *subsys)\n{\n\tstruct nvmet_ctrl *ctrl;\n\n\tlockdep_assert_held(&nvmet_config_sem);\n\tnvmet_genctr++;\n\n\tmutex_lock(&nvmet_disc_subsys->lock);\n\tlist_for_each_entry(ctrl, &nvmet_disc_subsys->ctrls, subsys_entry) {\n\t\tif (subsys && !nvmet_host_allowed(subsys, ctrl->hostnqn))\n\t\t\tcontinue;\n\n\t\t__nvmet_disc_changed(port, ctrl);\n\t}\n\tmutex_unlock(&nvmet_disc_subsys->lock);\n\n\t \n\tif (port->tr_ops && port->tr_ops->discovery_chg)\n\t\tport->tr_ops->discovery_chg(port);\n}\n\nstatic void __nvmet_subsys_disc_changed(struct nvmet_port *port,\n\t\t\t\t\tstruct nvmet_subsys *subsys,\n\t\t\t\t\tstruct nvmet_host *host)\n{\n\tstruct nvmet_ctrl *ctrl;\n\n\tmutex_lock(&nvmet_disc_subsys->lock);\n\tlist_for_each_entry(ctrl, &nvmet_disc_subsys->ctrls, subsys_entry) {\n\t\tif (host && strcmp(nvmet_host_name(host), ctrl->hostnqn))\n\t\t\tcontinue;\n\n\t\t__nvmet_disc_changed(port, ctrl);\n\t}\n\tmutex_unlock(&nvmet_disc_subsys->lock);\n}\n\nvoid nvmet_subsys_disc_changed(struct nvmet_subsys *subsys,\n\t\t\t       struct nvmet_host *host)\n{\n\tstruct nvmet_port *port;\n\tstruct nvmet_subsys_link *s;\n\n\tlockdep_assert_held(&nvmet_config_sem);\n\tnvmet_genctr++;\n\n\tlist_for_each_entry(port, nvmet_ports, global_entry)\n\t\tlist_for_each_entry(s, &port->subsystems, entry) {\n\t\t\tif (s->subsys != subsys)\n\t\t\t\tcontinue;\n\t\t\t__nvmet_subsys_disc_changed(port, subsys, host);\n\t\t}\n}\n\nvoid nvmet_referral_enable(struct nvmet_port *parent, struct nvmet_port *port)\n{\n\tdown_write(&nvmet_config_sem);\n\tif (list_empty(&port->entry)) {\n\t\tlist_add_tail(&port->entry, &parent->referrals);\n\t\tport->enabled = true;\n\t\tnvmet_port_disc_changed(parent, NULL);\n\t}\n\tup_write(&nvmet_config_sem);\n}\n\nvoid nvmet_referral_disable(struct nvmet_port *parent, struct nvmet_port *port)\n{\n\tdown_write(&nvmet_config_sem);\n\tif (!list_empty(&port->entry)) {\n\t\tport->enabled = false;\n\t\tlist_del_init(&port->entry);\n\t\tnvmet_port_disc_changed(parent, NULL);\n\t}\n\tup_write(&nvmet_config_sem);\n}\n\nstatic void nvmet_format_discovery_entry(struct nvmf_disc_rsp_page_hdr *hdr,\n\t\tstruct nvmet_port *port, char *subsys_nqn, char *traddr,\n\t\tu8 type, u32 numrec)\n{\n\tstruct nvmf_disc_rsp_page_entry *e = &hdr->entries[numrec];\n\n\te->trtype = port->disc_addr.trtype;\n\te->adrfam = port->disc_addr.adrfam;\n\te->treq = port->disc_addr.treq;\n\te->portid = port->disc_addr.portid;\n\t \n\te->cntlid = cpu_to_le16(NVME_CNTLID_DYNAMIC);\n\te->asqsz = cpu_to_le16(NVME_AQ_DEPTH);\n\te->subtype = type;\n\tmemcpy(e->trsvcid, port->disc_addr.trsvcid, NVMF_TRSVCID_SIZE);\n\tmemcpy(e->traddr, traddr, NVMF_TRADDR_SIZE);\n\tmemcpy(e->tsas.common, port->disc_addr.tsas.common, NVMF_TSAS_SIZE);\n\tstrncpy(e->subnqn, subsys_nqn, NVMF_NQN_SIZE);\n}\n\n \nstatic void nvmet_set_disc_traddr(struct nvmet_req *req, struct nvmet_port *port,\n\t\tchar *traddr)\n{\n\tif (req->ops->disc_traddr)\n\t\treq->ops->disc_traddr(req, port, traddr);\n\telse\n\t\tmemcpy(traddr, port->disc_addr.traddr, NVMF_TRADDR_SIZE);\n}\n\nstatic size_t discovery_log_entries(struct nvmet_req *req)\n{\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tstruct nvmet_subsys_link *p;\n\tstruct nvmet_port *r;\n\tsize_t entries = 1;\n\n\tlist_for_each_entry(p, &req->port->subsystems, entry) {\n\t\tif (!nvmet_host_allowed(p->subsys, ctrl->hostnqn))\n\t\t\tcontinue;\n\t\tentries++;\n\t}\n\tlist_for_each_entry(r, &req->port->referrals, entry)\n\t\tentries++;\n\treturn entries;\n}\n\nstatic void nvmet_execute_disc_get_log_page(struct nvmet_req *req)\n{\n\tconst int entry_size = sizeof(struct nvmf_disc_rsp_page_entry);\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tstruct nvmf_disc_rsp_page_hdr *hdr;\n\tu64 offset = nvmet_get_log_page_offset(req->cmd);\n\tsize_t data_len = nvmet_get_log_page_len(req->cmd);\n\tsize_t alloc_len;\n\tstruct nvmet_subsys_link *p;\n\tstruct nvmet_port *r;\n\tu32 numrec = 0;\n\tu16 status = 0;\n\tvoid *buffer;\n\tchar traddr[NVMF_TRADDR_SIZE];\n\n\tif (!nvmet_check_transfer_len(req, data_len))\n\t\treturn;\n\n\tif (req->cmd->get_log_page.lid != NVME_LOG_DISC) {\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvme_get_log_page_command, lid);\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\tgoto out;\n\t}\n\n\t \n\tif (offset & 0x3) {\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvme_get_log_page_command, lpo);\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\tgoto out;\n\t}\n\n\t \n\tdown_read(&nvmet_config_sem);\n\talloc_len = sizeof(*hdr) + entry_size * discovery_log_entries(req);\n\tbuffer = kzalloc(alloc_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tup_read(&nvmet_config_sem);\n\t\tstatus = NVME_SC_INTERNAL;\n\t\tgoto out;\n\t}\n\thdr = buffer;\n\n\tnvmet_set_disc_traddr(req, req->port, traddr);\n\n\tnvmet_format_discovery_entry(hdr, req->port,\n\t\t\t\t     nvmet_disc_subsys->subsysnqn,\n\t\t\t\t     traddr, NVME_NQN_CURR, numrec);\n\tnumrec++;\n\n\tlist_for_each_entry(p, &req->port->subsystems, entry) {\n\t\tif (!nvmet_host_allowed(p->subsys, ctrl->hostnqn))\n\t\t\tcontinue;\n\n\t\tnvmet_format_discovery_entry(hdr, req->port,\n\t\t\t\tp->subsys->subsysnqn, traddr,\n\t\t\t\tNVME_NQN_NVME, numrec);\n\t\tnumrec++;\n\t}\n\n\tlist_for_each_entry(r, &req->port->referrals, entry) {\n\t\tnvmet_format_discovery_entry(hdr, r,\n\t\t\t\tNVME_DISC_SUBSYS_NAME,\n\t\t\t\tr->disc_addr.traddr,\n\t\t\t\tNVME_NQN_DISC, numrec);\n\t\tnumrec++;\n\t}\n\n\thdr->genctr = cpu_to_le64(nvmet_genctr);\n\thdr->numrec = cpu_to_le64(numrec);\n\thdr->recfmt = cpu_to_le16(0);\n\n\tnvmet_clear_aen_bit(req, NVME_AEN_BIT_DISC_CHANGE);\n\n\tup_read(&nvmet_config_sem);\n\n\tstatus = nvmet_copy_to_sgl(req, 0, buffer + offset, data_len);\n\tkfree(buffer);\nout:\n\tnvmet_req_complete(req, status);\n}\n\nstatic void nvmet_execute_disc_identify(struct nvmet_req *req)\n{\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tstruct nvme_id_ctrl *id;\n\tu16 status = 0;\n\n\tif (!nvmet_check_transfer_len(req, NVME_IDENTIFY_DATA_SIZE))\n\t\treturn;\n\n\tif (req->cmd->identify.cns != NVME_ID_CNS_CTRL) {\n\t\treq->error_loc = offsetof(struct nvme_identify, cns);\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\tgoto out;\n\t}\n\n\tid = kzalloc(sizeof(*id), GFP_KERNEL);\n\tif (!id) {\n\t\tstatus = NVME_SC_INTERNAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(id->sn, ctrl->subsys->serial, NVMET_SN_MAX_SIZE);\n\tmemset(id->fr, ' ', sizeof(id->fr));\n\tmemcpy_and_pad(id->mn, sizeof(id->mn), ctrl->subsys->model_number,\n\t\t       strlen(ctrl->subsys->model_number), ' ');\n\tmemcpy_and_pad(id->fr, sizeof(id->fr),\n\t\t       UTS_RELEASE, strlen(UTS_RELEASE), ' ');\n\n\tid->cntrltype = NVME_CTRL_DISC;\n\n\t \n\tid->mdts = 0;\n\tid->cntlid = cpu_to_le16(ctrl->cntlid);\n\tid->ver = cpu_to_le32(ctrl->subsys->ver);\n\tid->lpa = (1 << 2);\n\n\t \n\tid->maxcmd = cpu_to_le16(NVMET_MAX_CMD);\n\n\tid->sgls = cpu_to_le32(1 << 0);\t \n\tif (ctrl->ops->flags & NVMF_KEYED_SGLS)\n\t\tid->sgls |= cpu_to_le32(1 << 2);\n\tif (req->port->inline_data_size)\n\t\tid->sgls |= cpu_to_le32(1 << 20);\n\n\tid->oaes = cpu_to_le32(NVMET_DISC_AEN_CFG_OPTIONAL);\n\n\tstrscpy(id->subnqn, ctrl->subsys->subsysnqn, sizeof(id->subnqn));\n\n\tstatus = nvmet_copy_to_sgl(req, 0, id, sizeof(*id));\n\n\tkfree(id);\nout:\n\tnvmet_req_complete(req, status);\n}\n\nstatic void nvmet_execute_disc_set_features(struct nvmet_req *req)\n{\n\tu32 cdw10 = le32_to_cpu(req->cmd->common.cdw10);\n\tu16 stat;\n\n\tif (!nvmet_check_transfer_len(req, 0))\n\t\treturn;\n\n\tswitch (cdw10 & 0xff) {\n\tcase NVME_FEAT_KATO:\n\t\tstat = nvmet_set_feat_kato(req);\n\t\tbreak;\n\tcase NVME_FEAT_ASYNC_EVENT:\n\t\tstat = nvmet_set_feat_async_event(req,\n\t\t\t\t\t\t  NVMET_DISC_AEN_CFG_OPTIONAL);\n\t\tbreak;\n\tdefault:\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvme_common_command, cdw10);\n\t\tstat = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\tbreak;\n\t}\n\n\tnvmet_req_complete(req, stat);\n}\n\nstatic void nvmet_execute_disc_get_features(struct nvmet_req *req)\n{\n\tu32 cdw10 = le32_to_cpu(req->cmd->common.cdw10);\n\tu16 stat = 0;\n\n\tif (!nvmet_check_transfer_len(req, 0))\n\t\treturn;\n\n\tswitch (cdw10 & 0xff) {\n\tcase NVME_FEAT_KATO:\n\t\tnvmet_get_feat_kato(req);\n\t\tbreak;\n\tcase NVME_FEAT_ASYNC_EVENT:\n\t\tnvmet_get_feat_async_event(req);\n\t\tbreak;\n\tdefault:\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvme_common_command, cdw10);\n\t\tstat = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\tbreak;\n\t}\n\n\tnvmet_req_complete(req, stat);\n}\n\nu16 nvmet_parse_discovery_cmd(struct nvmet_req *req)\n{\n\tstruct nvme_command *cmd = req->cmd;\n\n\tif (unlikely(!(req->sq->ctrl->csts & NVME_CSTS_RDY))) {\n\t\tpr_err(\"got cmd %d while not ready\\n\",\n\t\t       cmd->common.opcode);\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvme_common_command, opcode);\n\t\treturn NVME_SC_INVALID_OPCODE | NVME_SC_DNR;\n\t}\n\n\tswitch (cmd->common.opcode) {\n\tcase nvme_admin_set_features:\n\t\treq->execute = nvmet_execute_disc_set_features;\n\t\treturn 0;\n\tcase nvme_admin_get_features:\n\t\treq->execute = nvmet_execute_disc_get_features;\n\t\treturn 0;\n\tcase nvme_admin_async_event:\n\t\treq->execute = nvmet_execute_async_event;\n\t\treturn 0;\n\tcase nvme_admin_keep_alive:\n\t\treq->execute = nvmet_execute_keep_alive;\n\t\treturn 0;\n\tcase nvme_admin_get_log_page:\n\t\treq->execute = nvmet_execute_disc_get_log_page;\n\t\treturn 0;\n\tcase nvme_admin_identify:\n\t\treq->execute = nvmet_execute_disc_identify;\n\t\treturn 0;\n\tdefault:\n\t\tpr_debug(\"unhandled cmd %d\\n\", cmd->common.opcode);\n\t\treq->error_loc = offsetof(struct nvme_common_command, opcode);\n\t\treturn NVME_SC_INVALID_OPCODE | NVME_SC_DNR;\n\t}\n\n}\n\nint __init nvmet_init_discovery(void)\n{\n\tnvmet_disc_subsys =\n\t\tnvmet_subsys_alloc(NVME_DISC_SUBSYS_NAME, NVME_NQN_CURR);\n\treturn PTR_ERR_OR_ZERO(nvmet_disc_subsys);\n}\n\nvoid nvmet_exit_discovery(void)\n{\n\tnvmet_subsys_put(nvmet_disc_subsys);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}