{
  "module_name": "fabrics-cmd.c",
  "hash_id": "e53888290de9593a3b65d07ae970e432ee344047f61d722205d7c316a3978cfd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/target/fabrics-cmd.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/blkdev.h>\n#include \"nvmet.h\"\n\nstatic void nvmet_execute_prop_set(struct nvmet_req *req)\n{\n\tu64 val = le64_to_cpu(req->cmd->prop_set.value);\n\tu16 status = 0;\n\n\tif (!nvmet_check_transfer_len(req, 0))\n\t\treturn;\n\n\tif (req->cmd->prop_set.attrib & 1) {\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvmf_property_set_command, attrib);\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\tgoto out;\n\t}\n\n\tswitch (le32_to_cpu(req->cmd->prop_set.offset)) {\n\tcase NVME_REG_CC:\n\t\tnvmet_update_cc(req->sq->ctrl, val);\n\t\tbreak;\n\tdefault:\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvmf_property_set_command, offset);\n\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t}\nout:\n\tnvmet_req_complete(req, status);\n}\n\nstatic void nvmet_execute_prop_get(struct nvmet_req *req)\n{\n\tstruct nvmet_ctrl *ctrl = req->sq->ctrl;\n\tu16 status = 0;\n\tu64 val = 0;\n\n\tif (!nvmet_check_transfer_len(req, 0))\n\t\treturn;\n\n\tif (req->cmd->prop_get.attrib & 1) {\n\t\tswitch (le32_to_cpu(req->cmd->prop_get.offset)) {\n\t\tcase NVME_REG_CAP:\n\t\t\tval = ctrl->cap;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (le32_to_cpu(req->cmd->prop_get.offset)) {\n\t\tcase NVME_REG_VS:\n\t\t\tval = ctrl->subsys->ver;\n\t\t\tbreak;\n\t\tcase NVME_REG_CC:\n\t\t\tval = ctrl->cc;\n\t\t\tbreak;\n\t\tcase NVME_REG_CSTS:\n\t\t\tval = ctrl->csts;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (status && req->cmd->prop_get.attrib & 1) {\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvmf_property_get_command, offset);\n\t} else {\n\t\treq->error_loc =\n\t\t\toffsetof(struct nvmf_property_get_command, attrib);\n\t}\n\n\treq->cqe->result.u64 = cpu_to_le64(val);\n\tnvmet_req_complete(req, status);\n}\n\nu16 nvmet_parse_fabrics_admin_cmd(struct nvmet_req *req)\n{\n\tstruct nvme_command *cmd = req->cmd;\n\n\tswitch (cmd->fabrics.fctype) {\n\tcase nvme_fabrics_type_property_set:\n\t\treq->execute = nvmet_execute_prop_set;\n\t\tbreak;\n\tcase nvme_fabrics_type_property_get:\n\t\treq->execute = nvmet_execute_prop_get;\n\t\tbreak;\n#ifdef CONFIG_NVME_TARGET_AUTH\n\tcase nvme_fabrics_type_auth_send:\n\t\treq->execute = nvmet_execute_auth_send;\n\t\tbreak;\n\tcase nvme_fabrics_type_auth_receive:\n\t\treq->execute = nvmet_execute_auth_receive;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tpr_debug(\"received unknown capsule type 0x%x\\n\",\n\t\t\tcmd->fabrics.fctype);\n\t\treq->error_loc = offsetof(struct nvmf_common_command, fctype);\n\t\treturn NVME_SC_INVALID_OPCODE | NVME_SC_DNR;\n\t}\n\n\treturn 0;\n}\n\nu16 nvmet_parse_fabrics_io_cmd(struct nvmet_req *req)\n{\n\tstruct nvme_command *cmd = req->cmd;\n\n\tswitch (cmd->fabrics.fctype) {\n#ifdef CONFIG_NVME_TARGET_AUTH\n\tcase nvme_fabrics_type_auth_send:\n\t\treq->execute = nvmet_execute_auth_send;\n\t\tbreak;\n\tcase nvme_fabrics_type_auth_receive:\n\t\treq->execute = nvmet_execute_auth_receive;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tpr_debug(\"received unknown capsule type 0x%x\\n\",\n\t\t\tcmd->fabrics.fctype);\n\t\treq->error_loc = offsetof(struct nvmf_common_command, fctype);\n\t\treturn NVME_SC_INVALID_OPCODE | NVME_SC_DNR;\n\t}\n\n\treturn 0;\n}\n\nstatic u16 nvmet_install_queue(struct nvmet_ctrl *ctrl, struct nvmet_req *req)\n{\n\tstruct nvmf_connect_command *c = &req->cmd->connect;\n\tu16 qid = le16_to_cpu(c->qid);\n\tu16 sqsize = le16_to_cpu(c->sqsize);\n\tstruct nvmet_ctrl *old;\n\tu16 mqes = NVME_CAP_MQES(ctrl->cap);\n\tu16 ret;\n\n\tif (!sqsize) {\n\t\tpr_warn(\"queue size zero!\\n\");\n\t\treq->error_loc = offsetof(struct nvmf_connect_command, sqsize);\n\t\treq->cqe->result.u32 = IPO_IATTR_CONNECT_SQE(sqsize);\n\t\tret = NVME_SC_CONNECT_INVALID_PARAM | NVME_SC_DNR;\n\t\tgoto err;\n\t}\n\n\tif (ctrl->sqs[qid] != NULL) {\n\t\tpr_warn(\"qid %u has already been created\\n\", qid);\n\t\treq->error_loc = offsetof(struct nvmf_connect_command, qid);\n\t\treturn NVME_SC_CMD_SEQ_ERROR | NVME_SC_DNR;\n\t}\n\n\tif (sqsize > mqes) {\n\t\tpr_warn(\"sqsize %u is larger than MQES supported %u cntlid %d\\n\",\n\t\t\t\tsqsize, mqes, ctrl->cntlid);\n\t\treq->error_loc = offsetof(struct nvmf_connect_command, sqsize);\n\t\treq->cqe->result.u32 = IPO_IATTR_CONNECT_SQE(sqsize);\n\t\treturn NVME_SC_CONNECT_INVALID_PARAM | NVME_SC_DNR;\n\t}\n\n\told = cmpxchg(&req->sq->ctrl, NULL, ctrl);\n\tif (old) {\n\t\tpr_warn(\"queue already connected!\\n\");\n\t\treq->error_loc = offsetof(struct nvmf_connect_command, opcode);\n\t\treturn NVME_SC_CONNECT_CTRL_BUSY | NVME_SC_DNR;\n\t}\n\n\t \n\tnvmet_cq_setup(ctrl, req->cq, qid, sqsize + 1);\n\tnvmet_sq_setup(ctrl, req->sq, qid, sqsize + 1);\n\n\tif (c->cattr & NVME_CONNECT_DISABLE_SQFLOW) {\n\t\treq->sq->sqhd_disabled = true;\n\t\treq->cqe->sq_head = cpu_to_le16(0xffff);\n\t}\n\n\tif (ctrl->ops->install_queue) {\n\t\tret = ctrl->ops->install_queue(req->sq);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to install queue %d cntlid %d ret %x\\n\",\n\t\t\t\tqid, ctrl->cntlid, ret);\n\t\t\tctrl->sqs[qid] = NULL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\treq->sq->ctrl = NULL;\n\treturn ret;\n}\n\nstatic u32 nvmet_connect_result(struct nvmet_ctrl *ctrl)\n{\n\treturn (u32)ctrl->cntlid |\n\t\t(nvmet_has_auth(ctrl) ? NVME_CONNECT_AUTHREQ_ATR : 0);\n}\n\nstatic void nvmet_execute_admin_connect(struct nvmet_req *req)\n{\n\tstruct nvmf_connect_command *c = &req->cmd->connect;\n\tstruct nvmf_connect_data *d;\n\tstruct nvmet_ctrl *ctrl = NULL;\n\tu16 status = 0;\n\tint ret;\n\n\tif (!nvmet_check_transfer_len(req, sizeof(struct nvmf_connect_data)))\n\t\treturn;\n\n\td = kmalloc(sizeof(*d), GFP_KERNEL);\n\tif (!d) {\n\t\tstatus = NVME_SC_INTERNAL;\n\t\tgoto complete;\n\t}\n\n\tstatus = nvmet_copy_from_sgl(req, 0, d, sizeof(*d));\n\tif (status)\n\t\tgoto out;\n\n\t \n\treq->cqe->result.u32 = 0;\n\n\tif (c->recfmt != 0) {\n\t\tpr_warn(\"invalid connect version (%d).\\n\",\n\t\t\tle16_to_cpu(c->recfmt));\n\t\treq->error_loc = offsetof(struct nvmf_connect_command, recfmt);\n\t\tstatus = NVME_SC_CONNECT_FORMAT | NVME_SC_DNR;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(d->cntlid != cpu_to_le16(0xffff))) {\n\t\tpr_warn(\"connect attempt for invalid controller ID %#x\\n\",\n\t\t\td->cntlid);\n\t\tstatus = NVME_SC_CONNECT_INVALID_PARAM | NVME_SC_DNR;\n\t\treq->cqe->result.u32 = IPO_IATTR_CONNECT_DATA(cntlid);\n\t\tgoto out;\n\t}\n\n\td->subsysnqn[NVMF_NQN_FIELD_LEN - 1] = '\\0';\n\td->hostnqn[NVMF_NQN_FIELD_LEN - 1] = '\\0';\n\tstatus = nvmet_alloc_ctrl(d->subsysnqn, d->hostnqn, req,\n\t\t\t\t  le32_to_cpu(c->kato), &ctrl);\n\tif (status)\n\t\tgoto out;\n\n\tctrl->pi_support = ctrl->port->pi_enable && ctrl->subsys->pi_support;\n\n\tuuid_copy(&ctrl->hostid, &d->hostid);\n\n\tret = nvmet_setup_auth(ctrl);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to setup authentication, error %d\\n\", ret);\n\t\tnvmet_ctrl_put(ctrl);\n\t\tif (ret == -EPERM)\n\t\t\tstatus = (NVME_SC_CONNECT_INVALID_HOST | NVME_SC_DNR);\n\t\telse\n\t\t\tstatus = NVME_SC_INTERNAL;\n\t\tgoto out;\n\t}\n\n\tstatus = nvmet_install_queue(ctrl, req);\n\tif (status) {\n\t\tnvmet_ctrl_put(ctrl);\n\t\tgoto out;\n\t}\n\n\tpr_info(\"creating %s controller %d for subsystem %s for NQN %s%s%s.\\n\",\n\t\tnvmet_is_disc_subsys(ctrl->subsys) ? \"discovery\" : \"nvm\",\n\t\tctrl->cntlid, ctrl->subsys->subsysnqn, ctrl->hostnqn,\n\t\tctrl->pi_support ? \" T10-PI is enabled\" : \"\",\n\t\tnvmet_has_auth(ctrl) ? \" with DH-HMAC-CHAP\" : \"\");\n\treq->cqe->result.u32 = cpu_to_le32(nvmet_connect_result(ctrl));\nout:\n\tkfree(d);\ncomplete:\n\tnvmet_req_complete(req, status);\n}\n\nstatic void nvmet_execute_io_connect(struct nvmet_req *req)\n{\n\tstruct nvmf_connect_command *c = &req->cmd->connect;\n\tstruct nvmf_connect_data *d;\n\tstruct nvmet_ctrl *ctrl;\n\tu16 qid = le16_to_cpu(c->qid);\n\tu16 status = 0;\n\n\tif (!nvmet_check_transfer_len(req, sizeof(struct nvmf_connect_data)))\n\t\treturn;\n\n\td = kmalloc(sizeof(*d), GFP_KERNEL);\n\tif (!d) {\n\t\tstatus = NVME_SC_INTERNAL;\n\t\tgoto complete;\n\t}\n\n\tstatus = nvmet_copy_from_sgl(req, 0, d, sizeof(*d));\n\tif (status)\n\t\tgoto out;\n\n\t \n\treq->cqe->result.u32 = 0;\n\n\tif (c->recfmt != 0) {\n\t\tpr_warn(\"invalid connect version (%d).\\n\",\n\t\t\tle16_to_cpu(c->recfmt));\n\t\tstatus = NVME_SC_CONNECT_FORMAT | NVME_SC_DNR;\n\t\tgoto out;\n\t}\n\n\td->subsysnqn[NVMF_NQN_FIELD_LEN - 1] = '\\0';\n\td->hostnqn[NVMF_NQN_FIELD_LEN - 1] = '\\0';\n\tctrl = nvmet_ctrl_find_get(d->subsysnqn, d->hostnqn,\n\t\t\t\t   le16_to_cpu(d->cntlid), req);\n\tif (!ctrl) {\n\t\tstatus = NVME_SC_CONNECT_INVALID_PARAM | NVME_SC_DNR;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(qid > ctrl->subsys->max_qid)) {\n\t\tpr_warn(\"invalid queue id (%d)\\n\", qid);\n\t\tstatus = NVME_SC_CONNECT_INVALID_PARAM | NVME_SC_DNR;\n\t\treq->cqe->result.u32 = IPO_IATTR_CONNECT_SQE(qid);\n\t\tgoto out_ctrl_put;\n\t}\n\n\tstatus = nvmet_install_queue(ctrl, req);\n\tif (status)\n\t\tgoto out_ctrl_put;\n\n\tpr_debug(\"adding queue %d to ctrl %d.\\n\", qid, ctrl->cntlid);\n\treq->cqe->result.u32 = cpu_to_le32(nvmet_connect_result(ctrl));\nout:\n\tkfree(d);\ncomplete:\n\tnvmet_req_complete(req, status);\n\treturn;\n\nout_ctrl_put:\n\tnvmet_ctrl_put(ctrl);\n\tgoto out;\n}\n\nu16 nvmet_parse_connect_cmd(struct nvmet_req *req)\n{\n\tstruct nvme_command *cmd = req->cmd;\n\n\tif (!nvme_is_fabrics(cmd)) {\n\t\tpr_debug(\"invalid command 0x%x on unconnected queue.\\n\",\n\t\t\tcmd->fabrics.opcode);\n\t\treq->error_loc = offsetof(struct nvme_common_command, opcode);\n\t\treturn NVME_SC_INVALID_OPCODE | NVME_SC_DNR;\n\t}\n\tif (cmd->fabrics.fctype != nvme_fabrics_type_connect) {\n\t\tpr_debug(\"invalid capsule type 0x%x on unconnected queue.\\n\",\n\t\t\tcmd->fabrics.fctype);\n\t\treq->error_loc = offsetof(struct nvmf_common_command, fctype);\n\t\treturn NVME_SC_INVALID_OPCODE | NVME_SC_DNR;\n\t}\n\n\tif (cmd->connect.qid == 0)\n\t\treq->execute = nvmet_execute_admin_connect;\n\telse\n\t\treq->execute = nvmet_execute_io_connect;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}