{
  "module_name": "fcloop.c",
  "hash_id": "c2c87f77fd1a5885a1f1be98bd53468f67f99c0491e01c41288403c77fb81bf6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/target/fcloop.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <uapi/scsi/fc/fc_fs.h>\n\n#include \"../host/nvme.h\"\n#include \"../target/nvmet.h\"\n#include <linux/nvme-fc-driver.h>\n#include <linux/nvme-fc.h>\n\n\nenum {\n\tNVMF_OPT_ERR\t\t= 0,\n\tNVMF_OPT_WWNN\t\t= 1 << 0,\n\tNVMF_OPT_WWPN\t\t= 1 << 1,\n\tNVMF_OPT_ROLES\t\t= 1 << 2,\n\tNVMF_OPT_FCADDR\t\t= 1 << 3,\n\tNVMF_OPT_LPWWNN\t\t= 1 << 4,\n\tNVMF_OPT_LPWWPN\t\t= 1 << 5,\n};\n\nstruct fcloop_ctrl_options {\n\tint\t\t\tmask;\n\tu64\t\t\twwnn;\n\tu64\t\t\twwpn;\n\tu32\t\t\troles;\n\tu32\t\t\tfcaddr;\n\tu64\t\t\tlpwwnn;\n\tu64\t\t\tlpwwpn;\n};\n\nstatic const match_table_t opt_tokens = {\n\t{ NVMF_OPT_WWNN,\t\"wwnn=%s\"\t},\n\t{ NVMF_OPT_WWPN,\t\"wwpn=%s\"\t},\n\t{ NVMF_OPT_ROLES,\t\"roles=%d\"\t},\n\t{ NVMF_OPT_FCADDR,\t\"fcaddr=%x\"\t},\n\t{ NVMF_OPT_LPWWNN,\t\"lpwwnn=%s\"\t},\n\t{ NVMF_OPT_LPWWPN,\t\"lpwwpn=%s\"\t},\n\t{ NVMF_OPT_ERR,\t\tNULL\t\t}\n};\n\nstatic int fcloop_verify_addr(substring_t *s)\n{\n\tsize_t blen = s->to - s->from + 1;\n\n\tif (strnlen(s->from, blen) != NVME_FC_TRADDR_HEXNAMELEN + 2 ||\n\t    strncmp(s->from, \"0x\", 2))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nfcloop_parse_options(struct fcloop_ctrl_options *opts,\n\t\tconst char *buf)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *options, *o, *p;\n\tint token, ret = 0;\n\tu64 token64;\n\n\toptions = o = kstrdup(buf, GFP_KERNEL);\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\twhile ((p = strsep(&o, \",\\n\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, opt_tokens, args);\n\t\topts->mask |= token;\n\t\tswitch (token) {\n\t\tcase NVMF_OPT_WWNN:\n\t\t\tif (fcloop_verify_addr(args) ||\n\t\t\t    match_u64(args, &token64)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free_options;\n\t\t\t}\n\t\t\topts->wwnn = token64;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_WWPN:\n\t\t\tif (fcloop_verify_addr(args) ||\n\t\t\t    match_u64(args, &token64)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free_options;\n\t\t\t}\n\t\t\topts->wwpn = token64;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_ROLES:\n\t\t\tif (match_int(args, &token)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free_options;\n\t\t\t}\n\t\t\topts->roles = token;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_FCADDR:\n\t\t\tif (match_hex(args, &token)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free_options;\n\t\t\t}\n\t\t\topts->fcaddr = token;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_LPWWNN:\n\t\t\tif (fcloop_verify_addr(args) ||\n\t\t\t    match_u64(args, &token64)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free_options;\n\t\t\t}\n\t\t\topts->lpwwnn = token64;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_LPWWPN:\n\t\t\tif (fcloop_verify_addr(args) ||\n\t\t\t    match_u64(args, &token64)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free_options;\n\t\t\t}\n\t\t\topts->lpwwpn = token64;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unknown parameter or missing value '%s'\\n\", p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free_options;\n\t\t}\n\t}\n\nout_free_options:\n\tkfree(options);\n\treturn ret;\n}\n\n\nstatic int\nfcloop_parse_nm_options(struct device *dev, u64 *nname, u64 *pname,\n\t\tconst char *buf)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *options, *o, *p;\n\tint token, ret = 0;\n\tu64 token64;\n\n\t*nname = -1;\n\t*pname = -1;\n\n\toptions = o = kstrdup(buf, GFP_KERNEL);\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\twhile ((p = strsep(&o, \",\\n\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, opt_tokens, args);\n\t\tswitch (token) {\n\t\tcase NVMF_OPT_WWNN:\n\t\t\tif (fcloop_verify_addr(args) ||\n\t\t\t    match_u64(args, &token64)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free_options;\n\t\t\t}\n\t\t\t*nname = token64;\n\t\t\tbreak;\n\t\tcase NVMF_OPT_WWPN:\n\t\t\tif (fcloop_verify_addr(args) ||\n\t\t\t    match_u64(args, &token64)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free_options;\n\t\t\t}\n\t\t\t*pname = token64;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unknown parameter or missing value '%s'\\n\", p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free_options;\n\t\t}\n\t}\n\nout_free_options:\n\tkfree(options);\n\n\tif (!ret) {\n\t\tif (*nname == -1)\n\t\t\treturn -EINVAL;\n\t\tif (*pname == -1)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n\n#define LPORT_OPTS\t(NVMF_OPT_WWNN | NVMF_OPT_WWPN)\n\n#define RPORT_OPTS\t(NVMF_OPT_WWNN | NVMF_OPT_WWPN |  \\\n\t\t\t NVMF_OPT_LPWWNN | NVMF_OPT_LPWWPN)\n\n#define TGTPORT_OPTS\t(NVMF_OPT_WWNN | NVMF_OPT_WWPN)\n\n\nstatic DEFINE_SPINLOCK(fcloop_lock);\nstatic LIST_HEAD(fcloop_lports);\nstatic LIST_HEAD(fcloop_nports);\n\nstruct fcloop_lport {\n\tstruct nvme_fc_local_port *localport;\n\tstruct list_head lport_list;\n\tstruct completion unreg_done;\n};\n\nstruct fcloop_lport_priv {\n\tstruct fcloop_lport *lport;\n};\n\nstruct fcloop_rport {\n\tstruct nvme_fc_remote_port\t*remoteport;\n\tstruct nvmet_fc_target_port\t*targetport;\n\tstruct fcloop_nport\t\t*nport;\n\tstruct fcloop_lport\t\t*lport;\n\tspinlock_t\t\t\tlock;\n\tstruct list_head\t\tls_list;\n\tstruct work_struct\t\tls_work;\n};\n\nstruct fcloop_tport {\n\tstruct nvmet_fc_target_port\t*targetport;\n\tstruct nvme_fc_remote_port\t*remoteport;\n\tstruct fcloop_nport\t\t*nport;\n\tstruct fcloop_lport\t\t*lport;\n\tspinlock_t\t\t\tlock;\n\tstruct list_head\t\tls_list;\n\tstruct work_struct\t\tls_work;\n};\n\nstruct fcloop_nport {\n\tstruct fcloop_rport *rport;\n\tstruct fcloop_tport *tport;\n\tstruct fcloop_lport *lport;\n\tstruct list_head nport_list;\n\tstruct kref ref;\n\tu64 node_name;\n\tu64 port_name;\n\tu32 port_role;\n\tu32 port_id;\n};\n\nstruct fcloop_lsreq {\n\tstruct nvmefc_ls_req\t\t*lsreq;\n\tstruct nvmefc_ls_rsp\t\tls_rsp;\n\tint\t\t\t\tlsdir;\t \n\tint\t\t\t\tstatus;\n\tstruct list_head\t\tls_list;  \n};\n\nstruct fcloop_rscn {\n\tstruct fcloop_tport\t\t*tport;\n\tstruct work_struct\t\twork;\n};\n\nenum {\n\tINI_IO_START\t\t= 0,\n\tINI_IO_ACTIVE\t\t= 1,\n\tINI_IO_ABORTED\t\t= 2,\n\tINI_IO_COMPLETED\t= 3,\n};\n\nstruct fcloop_fcpreq {\n\tstruct fcloop_tport\t\t*tport;\n\tstruct nvmefc_fcp_req\t\t*fcpreq;\n\tspinlock_t\t\t\treqlock;\n\tu16\t\t\t\tstatus;\n\tu32\t\t\t\tinistate;\n\tbool\t\t\t\tactive;\n\tbool\t\t\t\taborted;\n\tstruct kref\t\t\tref;\n\tstruct work_struct\t\tfcp_rcv_work;\n\tstruct work_struct\t\tabort_rcv_work;\n\tstruct work_struct\t\ttio_done_work;\n\tstruct nvmefc_tgt_fcp_req\ttgt_fcp_req;\n};\n\nstruct fcloop_ini_fcpreq {\n\tstruct nvmefc_fcp_req\t\t*fcpreq;\n\tstruct fcloop_fcpreq\t\t*tfcp_req;\n\tspinlock_t\t\t\tinilock;\n};\n\nstatic inline struct fcloop_lsreq *\nls_rsp_to_lsreq(struct nvmefc_ls_rsp *lsrsp)\n{\n\treturn container_of(lsrsp, struct fcloop_lsreq, ls_rsp);\n}\n\nstatic inline struct fcloop_fcpreq *\ntgt_fcp_req_to_fcpreq(struct nvmefc_tgt_fcp_req *tgt_fcpreq)\n{\n\treturn container_of(tgt_fcpreq, struct fcloop_fcpreq, tgt_fcp_req);\n}\n\n\nstatic int\nfcloop_create_queue(struct nvme_fc_local_port *localport,\n\t\t\tunsigned int qidx, u16 qsize,\n\t\t\tvoid **handle)\n{\n\t*handle = localport;\n\treturn 0;\n}\n\nstatic void\nfcloop_delete_queue(struct nvme_fc_local_port *localport,\n\t\t\tunsigned int idx, void *handle)\n{\n}\n\nstatic void\nfcloop_rport_lsrqst_work(struct work_struct *work)\n{\n\tstruct fcloop_rport *rport =\n\t\tcontainer_of(work, struct fcloop_rport, ls_work);\n\tstruct fcloop_lsreq *tls_req;\n\n\tspin_lock(&rport->lock);\n\tfor (;;) {\n\t\ttls_req = list_first_entry_or_null(&rport->ls_list,\n\t\t\t\tstruct fcloop_lsreq, ls_list);\n\t\tif (!tls_req)\n\t\t\tbreak;\n\n\t\tlist_del(&tls_req->ls_list);\n\t\tspin_unlock(&rport->lock);\n\n\t\ttls_req->lsreq->done(tls_req->lsreq, tls_req->status);\n\t\t \n\n\t\tspin_lock(&rport->lock);\n\t}\n\tspin_unlock(&rport->lock);\n}\n\nstatic int\nfcloop_h2t_ls_req(struct nvme_fc_local_port *localport,\n\t\t\tstruct nvme_fc_remote_port *remoteport,\n\t\t\tstruct nvmefc_ls_req *lsreq)\n{\n\tstruct fcloop_lsreq *tls_req = lsreq->private;\n\tstruct fcloop_rport *rport = remoteport->private;\n\tint ret = 0;\n\n\ttls_req->lsreq = lsreq;\n\tINIT_LIST_HEAD(&tls_req->ls_list);\n\n\tif (!rport->targetport) {\n\t\ttls_req->status = -ECONNREFUSED;\n\t\tspin_lock(&rport->lock);\n\t\tlist_add_tail(&rport->ls_list, &tls_req->ls_list);\n\t\tspin_unlock(&rport->lock);\n\t\tqueue_work(nvmet_wq, &rport->ls_work);\n\t\treturn ret;\n\t}\n\n\ttls_req->status = 0;\n\tret = nvmet_fc_rcv_ls_req(rport->targetport, rport,\n\t\t\t\t  &tls_req->ls_rsp,\n\t\t\t\t  lsreq->rqstaddr, lsreq->rqstlen);\n\n\treturn ret;\n}\n\nstatic int\nfcloop_h2t_xmt_ls_rsp(struct nvmet_fc_target_port *targetport,\n\t\t\tstruct nvmefc_ls_rsp *lsrsp)\n{\n\tstruct fcloop_lsreq *tls_req = ls_rsp_to_lsreq(lsrsp);\n\tstruct nvmefc_ls_req *lsreq = tls_req->lsreq;\n\tstruct fcloop_tport *tport = targetport->private;\n\tstruct nvme_fc_remote_port *remoteport = tport->remoteport;\n\tstruct fcloop_rport *rport;\n\n\tmemcpy(lsreq->rspaddr, lsrsp->rspbuf,\n\t\t((lsreq->rsplen < lsrsp->rsplen) ?\n\t\t\t\tlsreq->rsplen : lsrsp->rsplen));\n\n\tlsrsp->done(lsrsp);\n\n\tif (remoteport) {\n\t\trport = remoteport->private;\n\t\tspin_lock(&rport->lock);\n\t\tlist_add_tail(&rport->ls_list, &tls_req->ls_list);\n\t\tspin_unlock(&rport->lock);\n\t\tqueue_work(nvmet_wq, &rport->ls_work);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nfcloop_tport_lsrqst_work(struct work_struct *work)\n{\n\tstruct fcloop_tport *tport =\n\t\tcontainer_of(work, struct fcloop_tport, ls_work);\n\tstruct fcloop_lsreq *tls_req;\n\n\tspin_lock(&tport->lock);\n\tfor (;;) {\n\t\ttls_req = list_first_entry_or_null(&tport->ls_list,\n\t\t\t\tstruct fcloop_lsreq, ls_list);\n\t\tif (!tls_req)\n\t\t\tbreak;\n\n\t\tlist_del(&tls_req->ls_list);\n\t\tspin_unlock(&tport->lock);\n\n\t\ttls_req->lsreq->done(tls_req->lsreq, tls_req->status);\n\t\t \n\n\t\tspin_lock(&tport->lock);\n\t}\n\tspin_unlock(&tport->lock);\n}\n\nstatic int\nfcloop_t2h_ls_req(struct nvmet_fc_target_port *targetport, void *hosthandle,\n\t\t\tstruct nvmefc_ls_req *lsreq)\n{\n\tstruct fcloop_lsreq *tls_req = lsreq->private;\n\tstruct fcloop_tport *tport = targetport->private;\n\tint ret = 0;\n\n\t \n\ttls_req->lsreq = lsreq;\n\tINIT_LIST_HEAD(&tls_req->ls_list);\n\n\tif (!tport->remoteport) {\n\t\ttls_req->status = -ECONNREFUSED;\n\t\tspin_lock(&tport->lock);\n\t\tlist_add_tail(&tport->ls_list, &tls_req->ls_list);\n\t\tspin_unlock(&tport->lock);\n\t\tqueue_work(nvmet_wq, &tport->ls_work);\n\t\treturn ret;\n\t}\n\n\ttls_req->status = 0;\n\tret = nvme_fc_rcv_ls_req(tport->remoteport, &tls_req->ls_rsp,\n\t\t\t\t lsreq->rqstaddr, lsreq->rqstlen);\n\n\treturn ret;\n}\n\nstatic int\nfcloop_t2h_xmt_ls_rsp(struct nvme_fc_local_port *localport,\n\t\t\tstruct nvme_fc_remote_port *remoteport,\n\t\t\tstruct nvmefc_ls_rsp *lsrsp)\n{\n\tstruct fcloop_lsreq *tls_req = ls_rsp_to_lsreq(lsrsp);\n\tstruct nvmefc_ls_req *lsreq = tls_req->lsreq;\n\tstruct fcloop_rport *rport = remoteport->private;\n\tstruct nvmet_fc_target_port *targetport = rport->targetport;\n\tstruct fcloop_tport *tport;\n\n\tmemcpy(lsreq->rspaddr, lsrsp->rspbuf,\n\t\t((lsreq->rsplen < lsrsp->rsplen) ?\n\t\t\t\tlsreq->rsplen : lsrsp->rsplen));\n\tlsrsp->done(lsrsp);\n\n\tif (targetport) {\n\t\ttport = targetport->private;\n\t\tspin_lock(&tport->lock);\n\t\tlist_add_tail(&tport->ls_list, &tls_req->ls_list);\n\t\tspin_unlock(&tport->lock);\n\t\tqueue_work(nvmet_wq, &tport->ls_work);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nfcloop_t2h_host_release(void *hosthandle)\n{\n\t \n}\n\n \nstatic void\nfcloop_tgt_rscn_work(struct work_struct *work)\n{\n\tstruct fcloop_rscn *tgt_rscn =\n\t\tcontainer_of(work, struct fcloop_rscn, work);\n\tstruct fcloop_tport *tport = tgt_rscn->tport;\n\n\tif (tport->remoteport)\n\t\tnvme_fc_rescan_remoteport(tport->remoteport);\n\tkfree(tgt_rscn);\n}\n\nstatic void\nfcloop_tgt_discovery_evt(struct nvmet_fc_target_port *tgtport)\n{\n\tstruct fcloop_rscn *tgt_rscn;\n\n\ttgt_rscn = kzalloc(sizeof(*tgt_rscn), GFP_KERNEL);\n\tif (!tgt_rscn)\n\t\treturn;\n\n\ttgt_rscn->tport = tgtport->private;\n\tINIT_WORK(&tgt_rscn->work, fcloop_tgt_rscn_work);\n\n\tqueue_work(nvmet_wq, &tgt_rscn->work);\n}\n\nstatic void\nfcloop_tfcp_req_free(struct kref *ref)\n{\n\tstruct fcloop_fcpreq *tfcp_req =\n\t\tcontainer_of(ref, struct fcloop_fcpreq, ref);\n\n\tkfree(tfcp_req);\n}\n\nstatic void\nfcloop_tfcp_req_put(struct fcloop_fcpreq *tfcp_req)\n{\n\tkref_put(&tfcp_req->ref, fcloop_tfcp_req_free);\n}\n\nstatic int\nfcloop_tfcp_req_get(struct fcloop_fcpreq *tfcp_req)\n{\n\treturn kref_get_unless_zero(&tfcp_req->ref);\n}\n\nstatic void\nfcloop_call_host_done(struct nvmefc_fcp_req *fcpreq,\n\t\t\tstruct fcloop_fcpreq *tfcp_req, int status)\n{\n\tstruct fcloop_ini_fcpreq *inireq = NULL;\n\n\tif (fcpreq) {\n\t\tinireq = fcpreq->private;\n\t\tspin_lock(&inireq->inilock);\n\t\tinireq->tfcp_req = NULL;\n\t\tspin_unlock(&inireq->inilock);\n\n\t\tfcpreq->status = status;\n\t\tfcpreq->done(fcpreq);\n\t}\n\n\t \n\tfcloop_tfcp_req_put(tfcp_req);\n}\n\nstatic bool drop_fabric_opcode;\n#define DROP_OPCODE_MASK\t0x00FF\n \nstatic int drop_opcode = -1;\nstatic int drop_instance;\nstatic int drop_amount;\nstatic int drop_current_cnt;\n\n \nstatic int check_for_drop(struct fcloop_fcpreq *tfcp_req)\n{\n\tstruct nvmefc_fcp_req *fcpreq = tfcp_req->fcpreq;\n\tstruct nvme_fc_cmd_iu *cmdiu = fcpreq->cmdaddr;\n\tstruct nvme_command *sqe = &cmdiu->sqe;\n\n\tif (drop_opcode == -1)\n\t\treturn 0;\n\n\tpr_info(\"%s: seq opcd x%02x fctype x%02x: drop F %s op x%02x \"\n\t\t\"inst %d start %d amt %d\\n\",\n\t\t__func__, sqe->common.opcode, sqe->fabrics.fctype,\n\t\tdrop_fabric_opcode ? \"y\" : \"n\",\n\t\tdrop_opcode, drop_current_cnt, drop_instance, drop_amount);\n\n\tif ((drop_fabric_opcode &&\n\t     (sqe->common.opcode != nvme_fabrics_command ||\n\t      sqe->fabrics.fctype != drop_opcode)) ||\n\t    (!drop_fabric_opcode && sqe->common.opcode != drop_opcode))\n\t\treturn 0;\n\n\tif (++drop_current_cnt >= drop_instance) {\n\t\tif (drop_current_cnt >= drop_instance + drop_amount)\n\t\t\tdrop_opcode = -1;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nfcloop_fcp_recv_work(struct work_struct *work)\n{\n\tstruct fcloop_fcpreq *tfcp_req =\n\t\tcontainer_of(work, struct fcloop_fcpreq, fcp_rcv_work);\n\tstruct nvmefc_fcp_req *fcpreq = tfcp_req->fcpreq;\n\tunsigned long flags;\n\tint ret = 0;\n\tbool aborted = false;\n\n\tspin_lock_irqsave(&tfcp_req->reqlock, flags);\n\tswitch (tfcp_req->inistate) {\n\tcase INI_IO_START:\n\t\ttfcp_req->inistate = INI_IO_ACTIVE;\n\t\tbreak;\n\tcase INI_IO_ABORTED:\n\t\taborted = true;\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock_irqrestore(&tfcp_req->reqlock, flags);\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&tfcp_req->reqlock, flags);\n\n\tif (unlikely(aborted))\n\t\tret = -ECANCELED;\n\telse {\n\t\tif (likely(!check_for_drop(tfcp_req)))\n\t\t\tret = nvmet_fc_rcv_fcp_req(tfcp_req->tport->targetport,\n\t\t\t\t&tfcp_req->tgt_fcp_req,\n\t\t\t\tfcpreq->cmdaddr, fcpreq->cmdlen);\n\t\telse\n\t\t\tpr_info(\"%s: dropped command ********\\n\", __func__);\n\t}\n\tif (ret)\n\t\tfcloop_call_host_done(fcpreq, tfcp_req, ret);\n}\n\nstatic void\nfcloop_fcp_abort_recv_work(struct work_struct *work)\n{\n\tstruct fcloop_fcpreq *tfcp_req =\n\t\tcontainer_of(work, struct fcloop_fcpreq, abort_rcv_work);\n\tstruct nvmefc_fcp_req *fcpreq;\n\tbool completed = false;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tfcp_req->reqlock, flags);\n\tfcpreq = tfcp_req->fcpreq;\n\tswitch (tfcp_req->inistate) {\n\tcase INI_IO_ABORTED:\n\t\tbreak;\n\tcase INI_IO_COMPLETED:\n\t\tcompleted = true;\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock_irqrestore(&tfcp_req->reqlock, flags);\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&tfcp_req->reqlock, flags);\n\n\tif (unlikely(completed)) {\n\t\t \n\t\tfcloop_tfcp_req_put(tfcp_req);\n\t\treturn;\n\t}\n\n\tif (tfcp_req->tport->targetport)\n\t\tnvmet_fc_rcv_fcp_abort(tfcp_req->tport->targetport,\n\t\t\t\t\t&tfcp_req->tgt_fcp_req);\n\n\tspin_lock_irqsave(&tfcp_req->reqlock, flags);\n\ttfcp_req->fcpreq = NULL;\n\tspin_unlock_irqrestore(&tfcp_req->reqlock, flags);\n\n\tfcloop_call_host_done(fcpreq, tfcp_req, -ECANCELED);\n\t \n}\n\n \nstatic void\nfcloop_tgt_fcprqst_done_work(struct work_struct *work)\n{\n\tstruct fcloop_fcpreq *tfcp_req =\n\t\tcontainer_of(work, struct fcloop_fcpreq, tio_done_work);\n\tstruct nvmefc_fcp_req *fcpreq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tfcp_req->reqlock, flags);\n\tfcpreq = tfcp_req->fcpreq;\n\ttfcp_req->inistate = INI_IO_COMPLETED;\n\tspin_unlock_irqrestore(&tfcp_req->reqlock, flags);\n\n\tfcloop_call_host_done(fcpreq, tfcp_req, tfcp_req->status);\n}\n\n\nstatic int\nfcloop_fcp_req(struct nvme_fc_local_port *localport,\n\t\t\tstruct nvme_fc_remote_port *remoteport,\n\t\t\tvoid *hw_queue_handle,\n\t\t\tstruct nvmefc_fcp_req *fcpreq)\n{\n\tstruct fcloop_rport *rport = remoteport->private;\n\tstruct fcloop_ini_fcpreq *inireq = fcpreq->private;\n\tstruct fcloop_fcpreq *tfcp_req;\n\n\tif (!rport->targetport)\n\t\treturn -ECONNREFUSED;\n\n\ttfcp_req = kzalloc(sizeof(*tfcp_req), GFP_ATOMIC);\n\tif (!tfcp_req)\n\t\treturn -ENOMEM;\n\n\tinireq->fcpreq = fcpreq;\n\tinireq->tfcp_req = tfcp_req;\n\tspin_lock_init(&inireq->inilock);\n\n\ttfcp_req->fcpreq = fcpreq;\n\ttfcp_req->tport = rport->targetport->private;\n\ttfcp_req->inistate = INI_IO_START;\n\tspin_lock_init(&tfcp_req->reqlock);\n\tINIT_WORK(&tfcp_req->fcp_rcv_work, fcloop_fcp_recv_work);\n\tINIT_WORK(&tfcp_req->abort_rcv_work, fcloop_fcp_abort_recv_work);\n\tINIT_WORK(&tfcp_req->tio_done_work, fcloop_tgt_fcprqst_done_work);\n\tkref_init(&tfcp_req->ref);\n\n\tqueue_work(nvmet_wq, &tfcp_req->fcp_rcv_work);\n\n\treturn 0;\n}\n\nstatic void\nfcloop_fcp_copy_data(u8 op, struct scatterlist *data_sg,\n\t\t\tstruct scatterlist *io_sg, u32 offset, u32 length)\n{\n\tvoid *data_p, *io_p;\n\tu32 data_len, io_len, tlen;\n\n\tio_p = sg_virt(io_sg);\n\tio_len = io_sg->length;\n\n\tfor ( ; offset; ) {\n\t\ttlen = min_t(u32, offset, io_len);\n\t\toffset -= tlen;\n\t\tio_len -= tlen;\n\t\tif (!io_len) {\n\t\t\tio_sg = sg_next(io_sg);\n\t\t\tio_p = sg_virt(io_sg);\n\t\t\tio_len = io_sg->length;\n\t\t} else\n\t\t\tio_p += tlen;\n\t}\n\n\tdata_p = sg_virt(data_sg);\n\tdata_len = data_sg->length;\n\n\tfor ( ; length; ) {\n\t\ttlen = min_t(u32, io_len, data_len);\n\t\ttlen = min_t(u32, tlen, length);\n\n\t\tif (op == NVMET_FCOP_WRITEDATA)\n\t\t\tmemcpy(data_p, io_p, tlen);\n\t\telse\n\t\t\tmemcpy(io_p, data_p, tlen);\n\n\t\tlength -= tlen;\n\n\t\tio_len -= tlen;\n\t\tif ((!io_len) && (length)) {\n\t\t\tio_sg = sg_next(io_sg);\n\t\t\tio_p = sg_virt(io_sg);\n\t\t\tio_len = io_sg->length;\n\t\t} else\n\t\t\tio_p += tlen;\n\n\t\tdata_len -= tlen;\n\t\tif ((!data_len) && (length)) {\n\t\t\tdata_sg = sg_next(data_sg);\n\t\t\tdata_p = sg_virt(data_sg);\n\t\t\tdata_len = data_sg->length;\n\t\t} else\n\t\t\tdata_p += tlen;\n\t}\n}\n\nstatic int\nfcloop_fcp_op(struct nvmet_fc_target_port *tgtport,\n\t\t\tstruct nvmefc_tgt_fcp_req *tgt_fcpreq)\n{\n\tstruct fcloop_fcpreq *tfcp_req = tgt_fcp_req_to_fcpreq(tgt_fcpreq);\n\tstruct nvmefc_fcp_req *fcpreq;\n\tu32 rsplen = 0, xfrlen = 0;\n\tint fcp_err = 0, active, aborted;\n\tu8 op = tgt_fcpreq->op;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tfcp_req->reqlock, flags);\n\tfcpreq = tfcp_req->fcpreq;\n\tactive = tfcp_req->active;\n\taborted = tfcp_req->aborted;\n\ttfcp_req->active = true;\n\tspin_unlock_irqrestore(&tfcp_req->reqlock, flags);\n\n\tif (unlikely(active))\n\t\t \n\t\treturn -EALREADY;\n\n\tif (unlikely(aborted)) {\n\t\t \n\t\tspin_lock_irqsave(&tfcp_req->reqlock, flags);\n\t\ttfcp_req->active = false;\n\t\tspin_unlock_irqrestore(&tfcp_req->reqlock, flags);\n\t\ttgt_fcpreq->transferred_length = 0;\n\t\ttgt_fcpreq->fcp_error = -ECANCELED;\n\t\ttgt_fcpreq->done(tgt_fcpreq);\n\t\treturn 0;\n\t}\n\n\t \n\n\tswitch (op) {\n\tcase NVMET_FCOP_WRITEDATA:\n\t\txfrlen = tgt_fcpreq->transfer_length;\n\t\tif (fcpreq) {\n\t\t\tfcloop_fcp_copy_data(op, tgt_fcpreq->sg,\n\t\t\t\t\tfcpreq->first_sgl, tgt_fcpreq->offset,\n\t\t\t\t\txfrlen);\n\t\t\tfcpreq->transferred_length += xfrlen;\n\t\t}\n\t\tbreak;\n\n\tcase NVMET_FCOP_READDATA:\n\tcase NVMET_FCOP_READDATA_RSP:\n\t\txfrlen = tgt_fcpreq->transfer_length;\n\t\tif (fcpreq) {\n\t\t\tfcloop_fcp_copy_data(op, tgt_fcpreq->sg,\n\t\t\t\t\tfcpreq->first_sgl, tgt_fcpreq->offset,\n\t\t\t\t\txfrlen);\n\t\t\tfcpreq->transferred_length += xfrlen;\n\t\t}\n\t\tif (op == NVMET_FCOP_READDATA)\n\t\t\tbreak;\n\n\t\t \n\t\tfallthrough;\n\n\tcase NVMET_FCOP_RSP:\n\t\tif (fcpreq) {\n\t\t\trsplen = ((fcpreq->rsplen < tgt_fcpreq->rsplen) ?\n\t\t\t\t\tfcpreq->rsplen : tgt_fcpreq->rsplen);\n\t\t\tmemcpy(fcpreq->rspaddr, tgt_fcpreq->rspaddr, rsplen);\n\t\t\tif (rsplen < tgt_fcpreq->rsplen)\n\t\t\t\tfcp_err = -E2BIG;\n\t\t\tfcpreq->rcv_rsplen = rsplen;\n\t\t\tfcpreq->status = 0;\n\t\t}\n\t\ttfcp_req->status = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tfcp_err = -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&tfcp_req->reqlock, flags);\n\ttfcp_req->active = false;\n\tspin_unlock_irqrestore(&tfcp_req->reqlock, flags);\n\n\ttgt_fcpreq->transferred_length = xfrlen;\n\ttgt_fcpreq->fcp_error = fcp_err;\n\ttgt_fcpreq->done(tgt_fcpreq);\n\n\treturn 0;\n}\n\nstatic void\nfcloop_tgt_fcp_abort(struct nvmet_fc_target_port *tgtport,\n\t\t\tstruct nvmefc_tgt_fcp_req *tgt_fcpreq)\n{\n\tstruct fcloop_fcpreq *tfcp_req = tgt_fcp_req_to_fcpreq(tgt_fcpreq);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&tfcp_req->reqlock, flags);\n\ttfcp_req->aborted = true;\n\tspin_unlock_irqrestore(&tfcp_req->reqlock, flags);\n\n\ttfcp_req->status = NVME_SC_INTERNAL;\n\n\t \n}\n\nstatic void\nfcloop_fcp_req_release(struct nvmet_fc_target_port *tgtport,\n\t\t\tstruct nvmefc_tgt_fcp_req *tgt_fcpreq)\n{\n\tstruct fcloop_fcpreq *tfcp_req = tgt_fcp_req_to_fcpreq(tgt_fcpreq);\n\n\tqueue_work(nvmet_wq, &tfcp_req->tio_done_work);\n}\n\nstatic void\nfcloop_h2t_ls_abort(struct nvme_fc_local_port *localport,\n\t\t\tstruct nvme_fc_remote_port *remoteport,\n\t\t\t\tstruct nvmefc_ls_req *lsreq)\n{\n}\n\nstatic void\nfcloop_t2h_ls_abort(struct nvmet_fc_target_port *targetport,\n\t\t\tvoid *hosthandle, struct nvmefc_ls_req *lsreq)\n{\n}\n\nstatic void\nfcloop_fcp_abort(struct nvme_fc_local_port *localport,\n\t\t\tstruct nvme_fc_remote_port *remoteport,\n\t\t\tvoid *hw_queue_handle,\n\t\t\tstruct nvmefc_fcp_req *fcpreq)\n{\n\tstruct fcloop_ini_fcpreq *inireq = fcpreq->private;\n\tstruct fcloop_fcpreq *tfcp_req;\n\tbool abortio = true;\n\tunsigned long flags;\n\n\tspin_lock(&inireq->inilock);\n\ttfcp_req = inireq->tfcp_req;\n\tif (tfcp_req)\n\t\tfcloop_tfcp_req_get(tfcp_req);\n\tspin_unlock(&inireq->inilock);\n\n\tif (!tfcp_req)\n\t\t \n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&tfcp_req->reqlock, flags);\n\tswitch (tfcp_req->inistate) {\n\tcase INI_IO_START:\n\tcase INI_IO_ACTIVE:\n\t\ttfcp_req->inistate = INI_IO_ABORTED;\n\t\tbreak;\n\tcase INI_IO_COMPLETED:\n\t\tabortio = false;\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock_irqrestore(&tfcp_req->reqlock, flags);\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&tfcp_req->reqlock, flags);\n\n\tif (abortio)\n\t\t \n\t\tWARN_ON(!queue_work(nvmet_wq, &tfcp_req->abort_rcv_work));\n\telse  {\n\t\t \n\t\tfcloop_tfcp_req_put(tfcp_req);\n\t}\n}\n\nstatic void\nfcloop_nport_free(struct kref *ref)\n{\n\tstruct fcloop_nport *nport =\n\t\tcontainer_of(ref, struct fcloop_nport, ref);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fcloop_lock, flags);\n\tlist_del(&nport->nport_list);\n\tspin_unlock_irqrestore(&fcloop_lock, flags);\n\n\tkfree(nport);\n}\n\nstatic void\nfcloop_nport_put(struct fcloop_nport *nport)\n{\n\tkref_put(&nport->ref, fcloop_nport_free);\n}\n\nstatic int\nfcloop_nport_get(struct fcloop_nport *nport)\n{\n\treturn kref_get_unless_zero(&nport->ref);\n}\n\nstatic void\nfcloop_localport_delete(struct nvme_fc_local_port *localport)\n{\n\tstruct fcloop_lport_priv *lport_priv = localport->private;\n\tstruct fcloop_lport *lport = lport_priv->lport;\n\n\t \n\tcomplete(&lport->unreg_done);\n}\n\nstatic void\nfcloop_remoteport_delete(struct nvme_fc_remote_port *remoteport)\n{\n\tstruct fcloop_rport *rport = remoteport->private;\n\n\tflush_work(&rport->ls_work);\n\tfcloop_nport_put(rport->nport);\n}\n\nstatic void\nfcloop_targetport_delete(struct nvmet_fc_target_port *targetport)\n{\n\tstruct fcloop_tport *tport = targetport->private;\n\n\tflush_work(&tport->ls_work);\n\tfcloop_nport_put(tport->nport);\n}\n\n#define\tFCLOOP_HW_QUEUES\t\t4\n#define\tFCLOOP_SGL_SEGS\t\t\t256\n#define FCLOOP_DMABOUND_4G\t\t0xFFFFFFFF\n\nstatic struct nvme_fc_port_template fctemplate = {\n\t.localport_delete\t= fcloop_localport_delete,\n\t.remoteport_delete\t= fcloop_remoteport_delete,\n\t.create_queue\t\t= fcloop_create_queue,\n\t.delete_queue\t\t= fcloop_delete_queue,\n\t.ls_req\t\t\t= fcloop_h2t_ls_req,\n\t.fcp_io\t\t\t= fcloop_fcp_req,\n\t.ls_abort\t\t= fcloop_h2t_ls_abort,\n\t.fcp_abort\t\t= fcloop_fcp_abort,\n\t.xmt_ls_rsp\t\t= fcloop_t2h_xmt_ls_rsp,\n\t.max_hw_queues\t\t= FCLOOP_HW_QUEUES,\n\t.max_sgl_segments\t= FCLOOP_SGL_SEGS,\n\t.max_dif_sgl_segments\t= FCLOOP_SGL_SEGS,\n\t.dma_boundary\t\t= FCLOOP_DMABOUND_4G,\n\t \n\t.local_priv_sz\t\t= sizeof(struct fcloop_lport_priv),\n\t.remote_priv_sz\t\t= sizeof(struct fcloop_rport),\n\t.lsrqst_priv_sz\t\t= sizeof(struct fcloop_lsreq),\n\t.fcprqst_priv_sz\t= sizeof(struct fcloop_ini_fcpreq),\n};\n\nstatic struct nvmet_fc_target_template tgttemplate = {\n\t.targetport_delete\t= fcloop_targetport_delete,\n\t.xmt_ls_rsp\t\t= fcloop_h2t_xmt_ls_rsp,\n\t.fcp_op\t\t\t= fcloop_fcp_op,\n\t.fcp_abort\t\t= fcloop_tgt_fcp_abort,\n\t.fcp_req_release\t= fcloop_fcp_req_release,\n\t.discovery_event\t= fcloop_tgt_discovery_evt,\n\t.ls_req\t\t\t= fcloop_t2h_ls_req,\n\t.ls_abort\t\t= fcloop_t2h_ls_abort,\n\t.host_release\t\t= fcloop_t2h_host_release,\n\t.max_hw_queues\t\t= FCLOOP_HW_QUEUES,\n\t.max_sgl_segments\t= FCLOOP_SGL_SEGS,\n\t.max_dif_sgl_segments\t= FCLOOP_SGL_SEGS,\n\t.dma_boundary\t\t= FCLOOP_DMABOUND_4G,\n\t \n\t.target_features\t= 0,\n\t \n\t.target_priv_sz\t\t= sizeof(struct fcloop_tport),\n\t.lsrqst_priv_sz\t\t= sizeof(struct fcloop_lsreq),\n};\n\nstatic ssize_t\nfcloop_create_local_port(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct nvme_fc_port_info pinfo;\n\tstruct fcloop_ctrl_options *opts;\n\tstruct nvme_fc_local_port *localport;\n\tstruct fcloop_lport *lport;\n\tstruct fcloop_lport_priv *lport_priv;\n\tunsigned long flags;\n\tint ret = -ENOMEM;\n\n\tlport = kzalloc(sizeof(*lport), GFP_KERNEL);\n\tif (!lport)\n\t\treturn -ENOMEM;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\tgoto out_free_lport;\n\n\tret = fcloop_parse_options(opts, buf);\n\tif (ret)\n\t\tgoto out_free_opts;\n\n\t \n\tif ((opts->mask & LPORT_OPTS) != LPORT_OPTS) {\n\t\tret = -EINVAL;\n\t\tgoto out_free_opts;\n\t}\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\tpinfo.node_name = opts->wwnn;\n\tpinfo.port_name = opts->wwpn;\n\tpinfo.port_role = opts->roles;\n\tpinfo.port_id = opts->fcaddr;\n\n\tret = nvme_fc_register_localport(&pinfo, &fctemplate, NULL, &localport);\n\tif (!ret) {\n\t\t \n\t\tlport_priv = localport->private;\n\t\tlport_priv->lport = lport;\n\n\t\tlport->localport = localport;\n\t\tINIT_LIST_HEAD(&lport->lport_list);\n\n\t\tspin_lock_irqsave(&fcloop_lock, flags);\n\t\tlist_add_tail(&lport->lport_list, &fcloop_lports);\n\t\tspin_unlock_irqrestore(&fcloop_lock, flags);\n\t}\n\nout_free_opts:\n\tkfree(opts);\nout_free_lport:\n\t \n\tif (ret)\n\t\tkfree(lport);\n\n\treturn ret ? ret : count;\n}\n\n\nstatic void\n__unlink_local_port(struct fcloop_lport *lport)\n{\n\tlist_del(&lport->lport_list);\n}\n\nstatic int\n__wait_localport_unreg(struct fcloop_lport *lport)\n{\n\tint ret;\n\n\tinit_completion(&lport->unreg_done);\n\n\tret = nvme_fc_unregister_localport(lport->localport);\n\n\tif (!ret)\n\t\twait_for_completion(&lport->unreg_done);\n\n\tkfree(lport);\n\n\treturn ret;\n}\n\n\nstatic ssize_t\nfcloop_delete_local_port(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct fcloop_lport *tlport, *lport = NULL;\n\tu64 nodename, portname;\n\tunsigned long flags;\n\tint ret;\n\n\tret = fcloop_parse_nm_options(dev, &nodename, &portname, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&fcloop_lock, flags);\n\n\tlist_for_each_entry(tlport, &fcloop_lports, lport_list) {\n\t\tif (tlport->localport->node_name == nodename &&\n\t\t    tlport->localport->port_name == portname) {\n\t\t\tlport = tlport;\n\t\t\t__unlink_local_port(lport);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&fcloop_lock, flags);\n\n\tif (!lport)\n\t\treturn -ENOENT;\n\n\tret = __wait_localport_unreg(lport);\n\n\treturn ret ? ret : count;\n}\n\nstatic struct fcloop_nport *\nfcloop_alloc_nport(const char *buf, size_t count, bool remoteport)\n{\n\tstruct fcloop_nport *newnport, *nport = NULL;\n\tstruct fcloop_lport *tmplport, *lport = NULL;\n\tstruct fcloop_ctrl_options *opts;\n\tunsigned long flags;\n\tu32 opts_mask = (remoteport) ? RPORT_OPTS : TGTPORT_OPTS;\n\tint ret;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn NULL;\n\n\tret = fcloop_parse_options(opts, buf);\n\tif (ret)\n\t\tgoto out_free_opts;\n\n\t \n\tif ((opts->mask & opts_mask) != opts_mask) {\n\t\tret = -EINVAL;\n\t\tgoto out_free_opts;\n\t}\n\n\tnewnport = kzalloc(sizeof(*newnport), GFP_KERNEL);\n\tif (!newnport)\n\t\tgoto out_free_opts;\n\n\tINIT_LIST_HEAD(&newnport->nport_list);\n\tnewnport->node_name = opts->wwnn;\n\tnewnport->port_name = opts->wwpn;\n\tif (opts->mask & NVMF_OPT_ROLES)\n\t\tnewnport->port_role = opts->roles;\n\tif (opts->mask & NVMF_OPT_FCADDR)\n\t\tnewnport->port_id = opts->fcaddr;\n\tkref_init(&newnport->ref);\n\n\tspin_lock_irqsave(&fcloop_lock, flags);\n\n\tlist_for_each_entry(tmplport, &fcloop_lports, lport_list) {\n\t\tif (tmplport->localport->node_name == opts->wwnn &&\n\t\t    tmplport->localport->port_name == opts->wwpn)\n\t\t\tgoto out_invalid_opts;\n\n\t\tif (tmplport->localport->node_name == opts->lpwwnn &&\n\t\t    tmplport->localport->port_name == opts->lpwwpn)\n\t\t\tlport = tmplport;\n\t}\n\n\tif (remoteport) {\n\t\tif (!lport)\n\t\t\tgoto out_invalid_opts;\n\t\tnewnport->lport = lport;\n\t}\n\n\tlist_for_each_entry(nport, &fcloop_nports, nport_list) {\n\t\tif (nport->node_name == opts->wwnn &&\n\t\t    nport->port_name == opts->wwpn) {\n\t\t\tif ((remoteport && nport->rport) ||\n\t\t\t    (!remoteport && nport->tport)) {\n\t\t\t\tnport = NULL;\n\t\t\t\tgoto out_invalid_opts;\n\t\t\t}\n\n\t\t\tfcloop_nport_get(nport);\n\n\t\t\tspin_unlock_irqrestore(&fcloop_lock, flags);\n\n\t\t\tif (remoteport)\n\t\t\t\tnport->lport = lport;\n\t\t\tif (opts->mask & NVMF_OPT_ROLES)\n\t\t\t\tnport->port_role = opts->roles;\n\t\t\tif (opts->mask & NVMF_OPT_FCADDR)\n\t\t\t\tnport->port_id = opts->fcaddr;\n\t\t\tgoto out_free_newnport;\n\t\t}\n\t}\n\n\tlist_add_tail(&newnport->nport_list, &fcloop_nports);\n\n\tspin_unlock_irqrestore(&fcloop_lock, flags);\n\n\tkfree(opts);\n\treturn newnport;\n\nout_invalid_opts:\n\tspin_unlock_irqrestore(&fcloop_lock, flags);\nout_free_newnport:\n\tkfree(newnport);\nout_free_opts:\n\tkfree(opts);\n\treturn nport;\n}\n\nstatic ssize_t\nfcloop_create_remote_port(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct nvme_fc_remote_port *remoteport;\n\tstruct fcloop_nport *nport;\n\tstruct fcloop_rport *rport;\n\tstruct nvme_fc_port_info pinfo;\n\tint ret;\n\n\tnport = fcloop_alloc_nport(buf, count, true);\n\tif (!nport)\n\t\treturn -EIO;\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\tpinfo.node_name = nport->node_name;\n\tpinfo.port_name = nport->port_name;\n\tpinfo.port_role = nport->port_role;\n\tpinfo.port_id = nport->port_id;\n\n\tret = nvme_fc_register_remoteport(nport->lport->localport,\n\t\t\t\t\t\t&pinfo, &remoteport);\n\tif (ret || !remoteport) {\n\t\tfcloop_nport_put(nport);\n\t\treturn ret;\n\t}\n\n\t \n\trport = remoteport->private;\n\trport->remoteport = remoteport;\n\trport->targetport = (nport->tport) ?  nport->tport->targetport : NULL;\n\tif (nport->tport) {\n\t\tnport->tport->remoteport = remoteport;\n\t\tnport->tport->lport = nport->lport;\n\t}\n\trport->nport = nport;\n\trport->lport = nport->lport;\n\tnport->rport = rport;\n\tspin_lock_init(&rport->lock);\n\tINIT_WORK(&rport->ls_work, fcloop_rport_lsrqst_work);\n\tINIT_LIST_HEAD(&rport->ls_list);\n\n\treturn count;\n}\n\n\nstatic struct fcloop_rport *\n__unlink_remote_port(struct fcloop_nport *nport)\n{\n\tstruct fcloop_rport *rport = nport->rport;\n\n\tif (rport && nport->tport)\n\t\tnport->tport->remoteport = NULL;\n\tnport->rport = NULL;\n\n\treturn rport;\n}\n\nstatic int\n__remoteport_unreg(struct fcloop_nport *nport, struct fcloop_rport *rport)\n{\n\tif (!rport)\n\t\treturn -EALREADY;\n\n\treturn nvme_fc_unregister_remoteport(rport->remoteport);\n}\n\nstatic ssize_t\nfcloop_delete_remote_port(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct fcloop_nport *nport = NULL, *tmpport;\n\tstatic struct fcloop_rport *rport;\n\tu64 nodename, portname;\n\tunsigned long flags;\n\tint ret;\n\n\tret = fcloop_parse_nm_options(dev, &nodename, &portname, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&fcloop_lock, flags);\n\n\tlist_for_each_entry(tmpport, &fcloop_nports, nport_list) {\n\t\tif (tmpport->node_name == nodename &&\n\t\t    tmpport->port_name == portname && tmpport->rport) {\n\t\t\tnport = tmpport;\n\t\t\trport = __unlink_remote_port(nport);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&fcloop_lock, flags);\n\n\tif (!nport)\n\t\treturn -ENOENT;\n\n\tret = __remoteport_unreg(nport, rport);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t\nfcloop_create_target_port(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct nvmet_fc_target_port *targetport;\n\tstruct fcloop_nport *nport;\n\tstruct fcloop_tport *tport;\n\tstruct nvmet_fc_port_info tinfo;\n\tint ret;\n\n\tnport = fcloop_alloc_nport(buf, count, false);\n\tif (!nport)\n\t\treturn -EIO;\n\n\ttinfo.node_name = nport->node_name;\n\ttinfo.port_name = nport->port_name;\n\ttinfo.port_id = nport->port_id;\n\n\tret = nvmet_fc_register_targetport(&tinfo, &tgttemplate, NULL,\n\t\t\t\t\t\t&targetport);\n\tif (ret) {\n\t\tfcloop_nport_put(nport);\n\t\treturn ret;\n\t}\n\n\t \n\ttport = targetport->private;\n\ttport->targetport = targetport;\n\ttport->remoteport = (nport->rport) ?  nport->rport->remoteport : NULL;\n\tif (nport->rport)\n\t\tnport->rport->targetport = targetport;\n\ttport->nport = nport;\n\ttport->lport = nport->lport;\n\tnport->tport = tport;\n\tspin_lock_init(&tport->lock);\n\tINIT_WORK(&tport->ls_work, fcloop_tport_lsrqst_work);\n\tINIT_LIST_HEAD(&tport->ls_list);\n\n\treturn count;\n}\n\n\nstatic struct fcloop_tport *\n__unlink_target_port(struct fcloop_nport *nport)\n{\n\tstruct fcloop_tport *tport = nport->tport;\n\n\tif (tport && nport->rport)\n\t\tnport->rport->targetport = NULL;\n\tnport->tport = NULL;\n\n\treturn tport;\n}\n\nstatic int\n__targetport_unreg(struct fcloop_nport *nport, struct fcloop_tport *tport)\n{\n\tif (!tport)\n\t\treturn -EALREADY;\n\n\treturn nvmet_fc_unregister_targetport(tport->targetport);\n}\n\nstatic ssize_t\nfcloop_delete_target_port(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct fcloop_nport *nport = NULL, *tmpport;\n\tstruct fcloop_tport *tport = NULL;\n\tu64 nodename, portname;\n\tunsigned long flags;\n\tint ret;\n\n\tret = fcloop_parse_nm_options(dev, &nodename, &portname, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&fcloop_lock, flags);\n\n\tlist_for_each_entry(tmpport, &fcloop_nports, nport_list) {\n\t\tif (tmpport->node_name == nodename &&\n\t\t    tmpport->port_name == portname && tmpport->tport) {\n\t\t\tnport = tmpport;\n\t\t\ttport = __unlink_target_port(nport);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&fcloop_lock, flags);\n\n\tif (!nport)\n\t\treturn -ENOENT;\n\n\tret = __targetport_unreg(nport, tport);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t\nfcloop_set_cmd_drop(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tunsigned int opcode;\n\tint starting, amount;\n\n\tif (sscanf(buf, \"%x:%d:%d\", &opcode, &starting, &amount) != 3)\n\t\treturn -EBADRQC;\n\n\tdrop_current_cnt = 0;\n\tdrop_fabric_opcode = (opcode & ~DROP_OPCODE_MASK) ? true : false;\n\tdrop_opcode = (opcode & DROP_OPCODE_MASK);\n\tdrop_instance = starting;\n\t \n\tdrop_amount = amount - 1;\n\n\tpr_info(\"%s: DROP: Starting at instance %d of%s opcode x%x drop +%d \"\n\t\t\"instances\\n\",\n\t\t__func__, drop_instance, drop_fabric_opcode ? \" fabric\" : \"\",\n\t\tdrop_opcode, drop_amount);\n\n\treturn count;\n}\n\n\nstatic DEVICE_ATTR(add_local_port, 0200, NULL, fcloop_create_local_port);\nstatic DEVICE_ATTR(del_local_port, 0200, NULL, fcloop_delete_local_port);\nstatic DEVICE_ATTR(add_remote_port, 0200, NULL, fcloop_create_remote_port);\nstatic DEVICE_ATTR(del_remote_port, 0200, NULL, fcloop_delete_remote_port);\nstatic DEVICE_ATTR(add_target_port, 0200, NULL, fcloop_create_target_port);\nstatic DEVICE_ATTR(del_target_port, 0200, NULL, fcloop_delete_target_port);\nstatic DEVICE_ATTR(set_cmd_drop, 0200, NULL, fcloop_set_cmd_drop);\n\nstatic struct attribute *fcloop_dev_attrs[] = {\n\t&dev_attr_add_local_port.attr,\n\t&dev_attr_del_local_port.attr,\n\t&dev_attr_add_remote_port.attr,\n\t&dev_attr_del_remote_port.attr,\n\t&dev_attr_add_target_port.attr,\n\t&dev_attr_del_target_port.attr,\n\t&dev_attr_set_cmd_drop.attr,\n\tNULL\n};\n\nstatic const struct attribute_group fclopp_dev_attrs_group = {\n\t.attrs\t\t= fcloop_dev_attrs,\n};\n\nstatic const struct attribute_group *fcloop_dev_attr_groups[] = {\n\t&fclopp_dev_attrs_group,\n\tNULL,\n};\n\nstatic struct class *fcloop_class;\nstatic struct device *fcloop_device;\n\n\nstatic int __init fcloop_init(void)\n{\n\tint ret;\n\n\tfcloop_class = class_create(\"fcloop\");\n\tif (IS_ERR(fcloop_class)) {\n\t\tpr_err(\"couldn't register class fcloop\\n\");\n\t\tret = PTR_ERR(fcloop_class);\n\t\treturn ret;\n\t}\n\n\tfcloop_device = device_create_with_groups(\n\t\t\t\tfcloop_class, NULL, MKDEV(0, 0), NULL,\n\t\t\t\tfcloop_dev_attr_groups, \"ctl\");\n\tif (IS_ERR(fcloop_device)) {\n\t\tpr_err(\"couldn't create ctl device!\\n\");\n\t\tret = PTR_ERR(fcloop_device);\n\t\tgoto out_destroy_class;\n\t}\n\n\tget_device(fcloop_device);\n\n\treturn 0;\n\nout_destroy_class:\n\tclass_destroy(fcloop_class);\n\treturn ret;\n}\n\nstatic void __exit fcloop_exit(void)\n{\n\tstruct fcloop_lport *lport = NULL;\n\tstruct fcloop_nport *nport = NULL;\n\tstruct fcloop_tport *tport;\n\tstruct fcloop_rport *rport;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&fcloop_lock, flags);\n\n\tfor (;;) {\n\t\tnport = list_first_entry_or_null(&fcloop_nports,\n\t\t\t\t\t\ttypeof(*nport), nport_list);\n\t\tif (!nport)\n\t\t\tbreak;\n\n\t\ttport = __unlink_target_port(nport);\n\t\trport = __unlink_remote_port(nport);\n\n\t\tspin_unlock_irqrestore(&fcloop_lock, flags);\n\n\t\tret = __targetport_unreg(nport, tport);\n\t\tif (ret)\n\t\t\tpr_warn(\"%s: Failed deleting target port\\n\", __func__);\n\n\t\tret = __remoteport_unreg(nport, rport);\n\t\tif (ret)\n\t\t\tpr_warn(\"%s: Failed deleting remote port\\n\", __func__);\n\n\t\tspin_lock_irqsave(&fcloop_lock, flags);\n\t}\n\n\tfor (;;) {\n\t\tlport = list_first_entry_or_null(&fcloop_lports,\n\t\t\t\t\t\ttypeof(*lport), lport_list);\n\t\tif (!lport)\n\t\t\tbreak;\n\n\t\t__unlink_local_port(lport);\n\n\t\tspin_unlock_irqrestore(&fcloop_lock, flags);\n\n\t\tret = __wait_localport_unreg(lport);\n\t\tif (ret)\n\t\t\tpr_warn(\"%s: Failed deleting local port\\n\", __func__);\n\n\t\tspin_lock_irqsave(&fcloop_lock, flags);\n\t}\n\n\tspin_unlock_irqrestore(&fcloop_lock, flags);\n\n\tput_device(fcloop_device);\n\n\tdevice_destroy(fcloop_class, MKDEV(0, 0));\n\tclass_destroy(fcloop_class);\n}\n\nmodule_init(fcloop_init);\nmodule_exit(fcloop_exit);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}