{
  "module_name": "auth.c",
  "hash_id": "b23ea0935a9612b386ea5c8b407e31ef5a3986d3accd1d1d5e7f24913c9b614d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvme/common/auth.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/crc32.h>\n#include <linux/base64.h>\n#include <linux/prandom.h>\n#include <linux/scatterlist.h>\n#include <asm/unaligned.h>\n#include <crypto/hash.h>\n#include <crypto/dh.h>\n#include <linux/nvme.h>\n#include <linux/nvme-auth.h>\n\nstatic u32 nvme_dhchap_seqnum;\nstatic DEFINE_MUTEX(nvme_dhchap_mutex);\n\nu32 nvme_auth_get_seqnum(void)\n{\n\tu32 seqnum;\n\n\tmutex_lock(&nvme_dhchap_mutex);\n\tif (!nvme_dhchap_seqnum)\n\t\tnvme_dhchap_seqnum = get_random_u32();\n\telse {\n\t\tnvme_dhchap_seqnum++;\n\t\tif (!nvme_dhchap_seqnum)\n\t\t\tnvme_dhchap_seqnum++;\n\t}\n\tseqnum = nvme_dhchap_seqnum;\n\tmutex_unlock(&nvme_dhchap_mutex);\n\treturn seqnum;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_get_seqnum);\n\nstatic struct nvme_auth_dhgroup_map {\n\tconst char name[16];\n\tconst char kpp[16];\n} dhgroup_map[] = {\n\t[NVME_AUTH_DHGROUP_NULL] = {\n\t\t.name = \"null\", .kpp = \"null\" },\n\t[NVME_AUTH_DHGROUP_2048] = {\n\t\t.name = \"ffdhe2048\", .kpp = \"ffdhe2048(dh)\" },\n\t[NVME_AUTH_DHGROUP_3072] = {\n\t\t.name = \"ffdhe3072\", .kpp = \"ffdhe3072(dh)\" },\n\t[NVME_AUTH_DHGROUP_4096] = {\n\t\t.name = \"ffdhe4096\", .kpp = \"ffdhe4096(dh)\" },\n\t[NVME_AUTH_DHGROUP_6144] = {\n\t\t.name = \"ffdhe6144\", .kpp = \"ffdhe6144(dh)\" },\n\t[NVME_AUTH_DHGROUP_8192] = {\n\t\t.name = \"ffdhe8192\", .kpp = \"ffdhe8192(dh)\" },\n};\n\nconst char *nvme_auth_dhgroup_name(u8 dhgroup_id)\n{\n\tif (dhgroup_id >= ARRAY_SIZE(dhgroup_map))\n\t\treturn NULL;\n\treturn dhgroup_map[dhgroup_id].name;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_dhgroup_name);\n\nconst char *nvme_auth_dhgroup_kpp(u8 dhgroup_id)\n{\n\tif (dhgroup_id >= ARRAY_SIZE(dhgroup_map))\n\t\treturn NULL;\n\treturn dhgroup_map[dhgroup_id].kpp;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_dhgroup_kpp);\n\nu8 nvme_auth_dhgroup_id(const char *dhgroup_name)\n{\n\tint i;\n\n\tif (!dhgroup_name || !strlen(dhgroup_name))\n\t\treturn NVME_AUTH_DHGROUP_INVALID;\n\tfor (i = 0; i < ARRAY_SIZE(dhgroup_map); i++) {\n\t\tif (!strlen(dhgroup_map[i].name))\n\t\t\tcontinue;\n\t\tif (!strncmp(dhgroup_map[i].name, dhgroup_name,\n\t\t\t     strlen(dhgroup_map[i].name)))\n\t\t\treturn i;\n\t}\n\treturn NVME_AUTH_DHGROUP_INVALID;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_dhgroup_id);\n\nstatic struct nvme_dhchap_hash_map {\n\tint len;\n\tconst char hmac[15];\n\tconst char digest[8];\n} hash_map[] = {\n\t[NVME_AUTH_HASH_SHA256] = {\n\t\t.len = 32,\n\t\t.hmac = \"hmac(sha256)\",\n\t\t.digest = \"sha256\",\n\t},\n\t[NVME_AUTH_HASH_SHA384] = {\n\t\t.len = 48,\n\t\t.hmac = \"hmac(sha384)\",\n\t\t.digest = \"sha384\",\n\t},\n\t[NVME_AUTH_HASH_SHA512] = {\n\t\t.len = 64,\n\t\t.hmac = \"hmac(sha512)\",\n\t\t.digest = \"sha512\",\n\t},\n};\n\nconst char *nvme_auth_hmac_name(u8 hmac_id)\n{\n\tif (hmac_id >= ARRAY_SIZE(hash_map))\n\t\treturn NULL;\n\treturn hash_map[hmac_id].hmac;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_hmac_name);\n\nconst char *nvme_auth_digest_name(u8 hmac_id)\n{\n\tif (hmac_id >= ARRAY_SIZE(hash_map))\n\t\treturn NULL;\n\treturn hash_map[hmac_id].digest;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_digest_name);\n\nu8 nvme_auth_hmac_id(const char *hmac_name)\n{\n\tint i;\n\n\tif (!hmac_name || !strlen(hmac_name))\n\t\treturn NVME_AUTH_HASH_INVALID;\n\n\tfor (i = 0; i < ARRAY_SIZE(hash_map); i++) {\n\t\tif (!strlen(hash_map[i].hmac))\n\t\t\tcontinue;\n\t\tif (!strncmp(hash_map[i].hmac, hmac_name,\n\t\t\t     strlen(hash_map[i].hmac)))\n\t\t\treturn i;\n\t}\n\treturn NVME_AUTH_HASH_INVALID;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_hmac_id);\n\nsize_t nvme_auth_hmac_hash_len(u8 hmac_id)\n{\n\tif (hmac_id >= ARRAY_SIZE(hash_map))\n\t\treturn 0;\n\treturn hash_map[hmac_id].len;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_hmac_hash_len);\n\nstruct nvme_dhchap_key *nvme_auth_extract_key(unsigned char *secret,\n\t\t\t\t\t      u8 key_hash)\n{\n\tstruct nvme_dhchap_key *key;\n\tunsigned char *p;\n\tu32 crc;\n\tint ret, key_len;\n\tsize_t allocated_len = strlen(secret);\n\n\t \n\tp = strrchr(secret, ':');\n\tif (p)\n\t\tallocated_len = p - secret;\n\tkey = kzalloc(sizeof(*key), GFP_KERNEL);\n\tif (!key)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkey->key = kzalloc(allocated_len, GFP_KERNEL);\n\tif (!key->key) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_key;\n\t}\n\n\tkey_len = base64_decode(secret, allocated_len, key->key);\n\tif (key_len < 0) {\n\t\tpr_debug(\"base64 key decoding error %d\\n\",\n\t\t\t key_len);\n\t\tret = key_len;\n\t\tgoto out_free_secret;\n\t}\n\n\tif (key_len != 36 && key_len != 52 &&\n\t    key_len != 68) {\n\t\tpr_err(\"Invalid key len %d\\n\", key_len);\n\t\tret = -EINVAL;\n\t\tgoto out_free_secret;\n\t}\n\n\tif (key_hash > 0 &&\n\t    (key_len - 4) != nvme_auth_hmac_hash_len(key_hash)) {\n\t\tpr_err(\"Mismatched key len %d for %s\\n\", key_len,\n\t\t       nvme_auth_hmac_name(key_hash));\n\t\tret = -EINVAL;\n\t\tgoto out_free_secret;\n\t}\n\n\t \n\tkey_len -= 4;\n\t \n\tcrc = ~crc32(~0, key->key, key_len);\n\n\tif (get_unaligned_le32(key->key + key_len) != crc) {\n\t\tpr_err(\"key crc mismatch (key %08x, crc %08x)\\n\",\n\t\t       get_unaligned_le32(key->key + key_len), crc);\n\t\tret = -EKEYREJECTED;\n\t\tgoto out_free_secret;\n\t}\n\tkey->len = key_len;\n\tkey->hash = key_hash;\n\treturn key;\nout_free_secret:\n\tkfree_sensitive(key->key);\nout_free_key:\n\tkfree(key);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(nvme_auth_extract_key);\n\nvoid nvme_auth_free_key(struct nvme_dhchap_key *key)\n{\n\tif (!key)\n\t\treturn;\n\tkfree_sensitive(key->key);\n\tkfree(key);\n}\nEXPORT_SYMBOL_GPL(nvme_auth_free_key);\n\nu8 *nvme_auth_transform_key(struct nvme_dhchap_key *key, char *nqn)\n{\n\tconst char *hmac_name;\n\tstruct crypto_shash *key_tfm;\n\tstruct shash_desc *shash;\n\tu8 *transformed_key;\n\tint ret;\n\n\tif (!key || !key->key) {\n\t\tpr_warn(\"No key specified\\n\");\n\t\treturn ERR_PTR(-ENOKEY);\n\t}\n\tif (key->hash == 0) {\n\t\ttransformed_key = kmemdup(key->key, key->len, GFP_KERNEL);\n\t\treturn transformed_key ? transformed_key : ERR_PTR(-ENOMEM);\n\t}\n\thmac_name = nvme_auth_hmac_name(key->hash);\n\tif (!hmac_name) {\n\t\tpr_warn(\"Invalid key hash id %d\\n\", key->hash);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tkey_tfm = crypto_alloc_shash(hmac_name, 0, 0);\n\tif (IS_ERR(key_tfm))\n\t\treturn (u8 *)key_tfm;\n\n\tshash = kmalloc(sizeof(struct shash_desc) +\n\t\t\tcrypto_shash_descsize(key_tfm),\n\t\t\tGFP_KERNEL);\n\tif (!shash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_key;\n\t}\n\n\ttransformed_key = kzalloc(crypto_shash_digestsize(key_tfm), GFP_KERNEL);\n\tif (!transformed_key) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_shash;\n\t}\n\n\tshash->tfm = key_tfm;\n\tret = crypto_shash_setkey(key_tfm, key->key, key->len);\n\tif (ret < 0)\n\t\tgoto out_free_transformed_key;\n\tret = crypto_shash_init(shash);\n\tif (ret < 0)\n\t\tgoto out_free_transformed_key;\n\tret = crypto_shash_update(shash, nqn, strlen(nqn));\n\tif (ret < 0)\n\t\tgoto out_free_transformed_key;\n\tret = crypto_shash_update(shash, \"NVMe-over-Fabrics\", 17);\n\tif (ret < 0)\n\t\tgoto out_free_transformed_key;\n\tret = crypto_shash_final(shash, transformed_key);\n\tif (ret < 0)\n\t\tgoto out_free_transformed_key;\n\n\tkfree(shash);\n\tcrypto_free_shash(key_tfm);\n\n\treturn transformed_key;\n\nout_free_transformed_key:\n\tkfree_sensitive(transformed_key);\nout_free_shash:\n\tkfree(shash);\nout_free_key:\n\tcrypto_free_shash(key_tfm);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(nvme_auth_transform_key);\n\nstatic int nvme_auth_hash_skey(int hmac_id, u8 *skey, size_t skey_len, u8 *hkey)\n{\n\tconst char *digest_name;\n\tstruct crypto_shash *tfm;\n\tint ret;\n\n\tdigest_name = nvme_auth_digest_name(hmac_id);\n\tif (!digest_name) {\n\t\tpr_debug(\"%s: failed to get digest for %d\\n\", __func__,\n\t\t\t hmac_id);\n\t\treturn -EINVAL;\n\t}\n\ttfm = crypto_alloc_shash(digest_name, 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn -ENOMEM;\n\n\tret = crypto_shash_tfm_digest(tfm, skey, skey_len, hkey);\n\tif (ret < 0)\n\t\tpr_debug(\"%s: Failed to hash digest len %zu\\n\", __func__,\n\t\t\t skey_len);\n\n\tcrypto_free_shash(tfm);\n\treturn ret;\n}\n\nint nvme_auth_augmented_challenge(u8 hmac_id, u8 *skey, size_t skey_len,\n\t\tu8 *challenge, u8 *aug, size_t hlen)\n{\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *desc;\n\tu8 *hashed_key;\n\tconst char *hmac_name;\n\tint ret;\n\n\thashed_key = kmalloc(hlen, GFP_KERNEL);\n\tif (!hashed_key)\n\t\treturn -ENOMEM;\n\n\tret = nvme_auth_hash_skey(hmac_id, skey,\n\t\t\t\t  skey_len, hashed_key);\n\tif (ret < 0)\n\t\tgoto out_free_key;\n\n\thmac_name = nvme_auth_hmac_name(hmac_id);\n\tif (!hmac_name) {\n\t\tpr_warn(\"%s: invalid hash algorithm %d\\n\",\n\t\t\t__func__, hmac_id);\n\t\tret = -EINVAL;\n\t\tgoto out_free_key;\n\t}\n\n\ttfm = crypto_alloc_shash(hmac_name, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out_free_key;\n\t}\n\n\tdesc = kmalloc(sizeof(struct shash_desc) + crypto_shash_descsize(tfm),\n\t\t       GFP_KERNEL);\n\tif (!desc) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_hash;\n\t}\n\tdesc->tfm = tfm;\n\n\tret = crypto_shash_setkey(tfm, hashed_key, hlen);\n\tif (ret)\n\t\tgoto out_free_desc;\n\n\tret = crypto_shash_init(desc);\n\tif (ret)\n\t\tgoto out_free_desc;\n\n\tret = crypto_shash_update(desc, challenge, hlen);\n\tif (ret)\n\t\tgoto out_free_desc;\n\n\tret = crypto_shash_final(desc, aug);\nout_free_desc:\n\tkfree_sensitive(desc);\nout_free_hash:\n\tcrypto_free_shash(tfm);\nout_free_key:\n\tkfree_sensitive(hashed_key);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_augmented_challenge);\n\nint nvme_auth_gen_privkey(struct crypto_kpp *dh_tfm, u8 dh_gid)\n{\n\tint ret;\n\n\tret = crypto_kpp_set_secret(dh_tfm, NULL, 0);\n\tif (ret)\n\t\tpr_debug(\"failed to set private key, error %d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_gen_privkey);\n\nint nvme_auth_gen_pubkey(struct crypto_kpp *dh_tfm,\n\t\tu8 *host_key, size_t host_key_len)\n{\n\tstruct kpp_request *req;\n\tstruct crypto_wait wait;\n\tstruct scatterlist dst;\n\tint ret;\n\n\treq = kpp_request_alloc(dh_tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcrypto_init_wait(&wait);\n\tkpp_request_set_input(req, NULL, 0);\n\tsg_init_one(&dst, host_key, host_key_len);\n\tkpp_request_set_output(req, &dst, host_key_len);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t crypto_req_done, &wait);\n\n\tret = crypto_wait_req(crypto_kpp_generate_public_key(req), &wait);\n\tkpp_request_free(req);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_gen_pubkey);\n\nint nvme_auth_gen_shared_secret(struct crypto_kpp *dh_tfm,\n\t\tu8 *ctrl_key, size_t ctrl_key_len,\n\t\tu8 *sess_key, size_t sess_key_len)\n{\n\tstruct kpp_request *req;\n\tstruct crypto_wait wait;\n\tstruct scatterlist src, dst;\n\tint ret;\n\n\treq = kpp_request_alloc(dh_tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcrypto_init_wait(&wait);\n\tsg_init_one(&src, ctrl_key, ctrl_key_len);\n\tkpp_request_set_input(req, &src, ctrl_key_len);\n\tsg_init_one(&dst, sess_key, sess_key_len);\n\tkpp_request_set_output(req, &dst, sess_key_len);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t crypto_req_done, &wait);\n\n\tret = crypto_wait_req(crypto_kpp_compute_shared_secret(req), &wait);\n\n\tkpp_request_free(req);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_gen_shared_secret);\n\nint nvme_auth_generate_key(u8 *secret, struct nvme_dhchap_key **ret_key)\n{\n\tstruct nvme_dhchap_key *key;\n\tu8 key_hash;\n\n\tif (!secret) {\n\t\t*ret_key = NULL;\n\t\treturn 0;\n\t}\n\n\tif (sscanf(secret, \"DHHC-1:%hhd:%*s:\", &key_hash) != 1)\n\t\treturn -EINVAL;\n\n\t \n\tkey = nvme_auth_extract_key(secret + 10, key_hash);\n\tif (IS_ERR(key)) {\n\t\t*ret_key = NULL;\n\t\treturn PTR_ERR(key);\n\t}\n\n\t*ret_key = key;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nvme_auth_generate_key);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}