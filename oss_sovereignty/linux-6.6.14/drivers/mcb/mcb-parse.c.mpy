{
  "module_name": "mcb-parse.c",
  "hash_id": "d78817d0454853b2fa9236b1d619a6cc4d20a99e62e1bec03082e136a693c9f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mcb/mcb-parse.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/mcb.h>\n\n#include \"mcb-internal.h\"\n\nstruct mcb_parse_priv {\n\tphys_addr_t mapbase;\n\tvoid __iomem *base;\n};\n\n#define for_each_chameleon_cell(dtype, p)\t\\\n\tfor ((dtype) = get_next_dtype((p));\t\\\n\t     (dtype) != CHAMELEON_DTYPE_END;\t\\\n\t     (dtype) = get_next_dtype((p)))\n\nstatic inline uint32_t get_next_dtype(void __iomem *p)\n{\n\tuint32_t dtype;\n\n\tdtype = readl(p);\n\treturn dtype >> 28;\n}\n\nstatic int chameleon_parse_bdd(struct mcb_bus *bus,\n\t\t\tstruct chameleon_bar *cb,\n\t\t\tvoid __iomem *base)\n{\n\treturn 0;\n}\n\nstatic int chameleon_parse_gdd(struct mcb_bus *bus,\n\t\t\tstruct chameleon_bar *cb,\n\t\t\tvoid __iomem *base, int bar_count)\n{\n\tstruct chameleon_gdd __iomem *gdd =\n\t\t(struct chameleon_gdd __iomem *) base;\n\tstruct mcb_device *mdev;\n\tu32 dev_mapbase;\n\tu32 offset;\n\tu32 size;\n\tint ret;\n\t__le32 reg1;\n\t__le32 reg2;\n\n\tmdev = mcb_alloc_dev(bus);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\treg1 = readl(&gdd->reg1);\n\treg2 = readl(&gdd->reg2);\n\toffset = readl(&gdd->offset);\n\tsize = readl(&gdd->size);\n\n\tmdev->id = GDD_DEV(reg1);\n\tmdev->rev = GDD_REV(reg1);\n\tmdev->var = GDD_VAR(reg1);\n\tmdev->bar = GDD_BAR(reg2);\n\tmdev->group = GDD_GRP(reg2);\n\tmdev->inst = GDD_INS(reg2);\n\n\t \n\tif (mdev->bar > bar_count - 1) {\n\t\tpr_info(\"No BAR for 16z%03d\\n\", mdev->id);\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\n\tdev_mapbase = cb[mdev->bar].addr;\n\tif (!dev_mapbase) {\n\t\tpr_info(\"BAR not assigned for 16z%03d\\n\", mdev->id);\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\n\tif (dev_mapbase & 0x01) {\n\t\tpr_info(\"IO mapped Device (16z%03d) not yet supported\\n\",\n\t\t\tmdev->id);\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\n\tpr_debug(\"Found a 16z%03d\\n\", mdev->id);\n\n\tmdev->irq.start = GDD_IRQ(reg1);\n\tmdev->irq.end = GDD_IRQ(reg1);\n\tmdev->irq.flags = IORESOURCE_IRQ;\n\n\tmdev->mem.start = dev_mapbase + offset;\n\n\tmdev->mem.end = mdev->mem.start + size - 1;\n\tmdev->mem.flags = IORESOURCE_MEM;\n\n\tret = mcb_device_register(bus, mdev);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tmcb_free_dev(mdev);\n\n\treturn ret;\n}\n\nstatic void chameleon_parse_bar(void __iomem *base,\n\t\t\t\tstruct chameleon_bar *cb, int bar_count)\n{\n\tchar __iomem *p = base;\n\tint i;\n\n\t \n\tp += sizeof(__le32);\n\n\tfor (i = 0; i < bar_count; i++) {\n\t\tcb[i].addr = readl(p);\n\t\tcb[i].size = readl(p + 4);\n\n\t\tp += sizeof(struct chameleon_bar);\n\t}\n}\n\nstatic int chameleon_get_bar(void __iomem **base, phys_addr_t mapbase,\n\t\t\t     struct chameleon_bar **cb)\n{\n\tstruct chameleon_bar *c;\n\tint bar_count;\n\t__le32 reg;\n\tu32 dtype;\n\n\t \n\tdtype = get_next_dtype(*base);\n\tif (dtype == CHAMELEON_DTYPE_BAR) {\n\t\treg = readl(*base);\n\n\t\tbar_count = BAR_CNT(reg);\n\t\tif (bar_count <= 0 || bar_count > CHAMELEON_BAR_MAX)\n\t\t\treturn -ENODEV;\n\n\t\tc = kcalloc(bar_count, sizeof(struct chameleon_bar),\n\t\t\t    GFP_KERNEL);\n\t\tif (!c)\n\t\t\treturn -ENOMEM;\n\n\t\tchameleon_parse_bar(*base, c, bar_count);\n\t\t*base += BAR_DESC_SIZE(bar_count);\n\t} else {\n\t\tc = kzalloc(sizeof(struct chameleon_bar), GFP_KERNEL);\n\t\tif (!c)\n\t\t\treturn -ENOMEM;\n\n\t\tbar_count = 1;\n\t\tc->addr = mapbase;\n\t}\n\n\t*cb = c;\n\n\treturn bar_count;\n}\n\nint chameleon_parse_cells(struct mcb_bus *bus, phys_addr_t mapbase,\n\t\t\tvoid __iomem *base)\n{\n\tstruct chameleon_fpga_header *header;\n\tstruct chameleon_bar *cb;\n\tvoid __iomem *p = base;\n\tint num_cells = 0;\n\tuint32_t dtype;\n\tint bar_count;\n\tint ret;\n\tu32 hsize;\n\tu32 table_size;\n\n\thsize = sizeof(struct chameleon_fpga_header);\n\n\theader = kzalloc(hsize, GFP_KERNEL);\n\tif (!header)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy_fromio(header, p, hsize);\n\t \n\theader->magic = le16_to_cpu(header->magic);\n\tif (header->magic != CHAMELEONV2_MAGIC) {\n\t\tpr_err(\"Unsupported chameleon version 0x%x\\n\",\n\t\t\t\theader->magic);\n\t\tret = -ENODEV;\n\t\tgoto free_header;\n\t}\n\tp += hsize;\n\n\tbus->revision = header->revision;\n\tbus->model = header->model;\n\tbus->minor = header->minor;\n\tsnprintf(bus->name, CHAMELEON_FILENAME_LEN + 1, \"%s\",\n\t\t header->filename);\n\n\tbar_count = chameleon_get_bar(&p, mapbase, &cb);\n\tif (bar_count < 0) {\n\t\tret = bar_count;\n\t\tgoto free_header;\n\t}\n\n\tfor_each_chameleon_cell(dtype, p) {\n\t\tswitch (dtype) {\n\t\tcase CHAMELEON_DTYPE_GENERAL:\n\t\t\tret = chameleon_parse_gdd(bus, cb, p, bar_count);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_bar;\n\t\t\tp += sizeof(struct chameleon_gdd);\n\t\t\tbreak;\n\t\tcase CHAMELEON_DTYPE_BRIDGE:\n\t\t\tchameleon_parse_bdd(bus, cb, p);\n\t\t\tp += sizeof(struct chameleon_bdd);\n\t\t\tbreak;\n\t\tcase CHAMELEON_DTYPE_END:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid chameleon descriptor type 0x%x\\n\",\n\t\t\t\tdtype);\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_bar;\n\t\t}\n\t\tnum_cells++;\n\t}\n\n\tif (num_cells == 0) {\n\t\tret = -EINVAL;\n\t\tgoto free_bar;\n\t}\n\n\ttable_size = p - base;\n\tpr_debug(\"%d cell(s) found. Chameleon table size: 0x%04x bytes\\n\", num_cells, table_size);\n\tkfree(cb);\n\tkfree(header);\n\treturn table_size;\n\nfree_bar:\n\tkfree(cb);\nfree_header:\n\tkfree(header);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(chameleon_parse_cells, MCB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}