{
  "module_name": "mcb-lpc.c",
  "hash_id": "4fd340e86a0dcdd421e17aa6793f9d167f6a0ca2e22f59f56c82267e86023c21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mcb/mcb-lpc.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/dmi.h>\n#include <linux/mcb.h>\n#include <linux/io.h>\n#include \"mcb-internal.h\"\n\nstruct priv {\n\tstruct mcb_bus *bus;\n\tstruct resource *mem;\n\tvoid __iomem *base;\n};\n\nstatic int mcb_lpc_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct priv *priv;\n\tint ret = 0, table_size;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!priv->mem) {\n\t\tdev_err(&pdev->dev, \"No Memory resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tres = devm_request_mem_region(&pdev->dev, priv->mem->start,\n\t\t\t\t      resource_size(priv->mem),\n\t\t\t\t      KBUILD_MODNAME);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to request IO memory\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tpriv->base = devm_ioremap(&pdev->dev, priv->mem->start,\n\t\t\t\t  resource_size(priv->mem));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"Cannot ioremap\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->bus = mcb_alloc_bus(&pdev->dev);\n\tif (IS_ERR(priv->bus))\n\t\treturn PTR_ERR(priv->bus);\n\n\tret = chameleon_parse_cells(priv->bus, priv->mem->start, priv->base);\n\tif (ret < 0) {\n\t\tgoto out_mcb_bus;\n\t}\n\n\ttable_size = ret;\n\n\tif (table_size < CHAM_HEADER_SIZE) {\n\t\t \n\t\tdevm_iounmap(&pdev->dev, priv->base);\n\t\tdevm_release_mem_region(&pdev->dev, priv->mem->start, resource_size(priv->mem));\n\n\t\t \n\t\tres = devm_request_mem_region(&pdev->dev, priv->mem->start,\n\t\t\t\t\t      table_size,\n\t\t\t\t\t      KBUILD_MODNAME);\n\t\tif (!res) {\n\t\t\tdev_err(&pdev->dev, \"Failed to request PCI memory\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_mcb_bus;\n\t\t}\n\n\t\tpriv->base = devm_ioremap(&pdev->dev, priv->mem->start, table_size);\n\t\tif (!priv->base) {\n\t\t\tdev_err(&pdev->dev, \"Cannot ioremap\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_mcb_bus;\n\t\t}\n\n\t\tplatform_set_drvdata(pdev, priv);\n\t}\n\n\tmcb_bus_add_devices(priv->bus);\n\n\treturn 0;\n\nout_mcb_bus:\n\tmcb_release_bus(priv->bus);\n\treturn ret;\n}\n\nstatic int mcb_lpc_remove(struct platform_device *pdev)\n{\n\tstruct priv *priv = platform_get_drvdata(pdev);\n\n\tmcb_release_bus(priv->bus);\n\n\treturn 0;\n}\n\nstatic struct platform_device *mcb_lpc_pdev;\n\nstatic int mcb_lpc_create_platform_device(const struct dmi_system_id *id)\n{\n\tstruct resource *res = id->driver_data;\n\tint ret;\n\n\tmcb_lpc_pdev = platform_device_alloc(\"mcb-lpc\", -1);\n\tif (!mcb_lpc_pdev)\n\t\treturn -ENOMEM;\n\n\tret = platform_device_add_resources(mcb_lpc_pdev, res, 1);\n\tif (ret)\n\t\tgoto out_put;\n\n\tret = platform_device_add(mcb_lpc_pdev);\n\tif (ret)\n\t\tgoto out_put;\n\n\treturn 0;\n\nout_put:\n\tplatform_device_put(mcb_lpc_pdev);\n\treturn ret;\n}\n\nstatic struct resource sc24_fpga_resource = DEFINE_RES_MEM(0xe000e000, CHAM_HEADER_SIZE);\nstatic struct resource sc31_fpga_resource = DEFINE_RES_MEM(0xf000e000, CHAM_HEADER_SIZE);\n\nstatic struct platform_driver mcb_lpc_driver = {\n\t.driver\t\t= {\n\t\t.name = \"mcb-lpc\",\n\t},\n\t.probe\t\t= mcb_lpc_probe,\n\t.remove\t\t= mcb_lpc_remove,\n};\n\nstatic const struct dmi_system_id mcb_lpc_dmi_table[] = {\n\t{\n\t\t.ident = \"SC24\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEN\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"14SC24\"),\n\t\t},\n\t\t.driver_data = (void *)&sc24_fpga_resource,\n\t\t.callback = mcb_lpc_create_platform_device,\n\t},\n\t{\n\t\t.ident = \"SC31\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEN\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"14SC31\"),\n\t\t},\n\t\t.driver_data = (void *)&sc31_fpga_resource,\n\t\t.callback = mcb_lpc_create_platform_device,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(dmi, mcb_lpc_dmi_table);\n\nstatic int __init mcb_lpc_init(void)\n{\n\tif (!dmi_check_system(mcb_lpc_dmi_table))\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&mcb_lpc_driver);\n}\n\nstatic void __exit mcb_lpc_exit(void)\n{\n\tplatform_device_unregister(mcb_lpc_pdev);\n\tplatform_driver_unregister(&mcb_lpc_driver);\n}\n\nmodule_init(mcb_lpc_init);\nmodule_exit(mcb_lpc_exit);\n\nMODULE_AUTHOR(\"Andreas Werner <andreas.werner@men.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MCB over LPC support\");\nMODULE_IMPORT_NS(MCB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}