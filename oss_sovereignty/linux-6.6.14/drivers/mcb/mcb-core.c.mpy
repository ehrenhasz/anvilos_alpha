{
  "module_name": "mcb-core.c",
  "hash_id": "cb250ba8a2320fae52c38c30c7063a57aed1a961e2b63ebb195fba2322ae396c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mcb/mcb-core.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/idr.h>\n#include <linux/mcb.h>\n\nstatic DEFINE_IDA(mcb_ida);\n\nstatic const struct mcb_device_id *mcb_match_id(const struct mcb_device_id *ids,\n\t\t\t\t\t\tstruct mcb_device *dev)\n{\n\tif (ids) {\n\t\twhile (ids->device) {\n\t\t\tif (ids->device == dev->id)\n\t\t\t\treturn ids;\n\t\t\tids++;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int mcb_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct mcb_driver *mdrv = to_mcb_driver(drv);\n\tstruct mcb_device *mdev = to_mcb_device(dev);\n\tconst struct mcb_device_id *found_id;\n\n\tfound_id = mcb_match_id(mdrv->id_table, mdev);\n\tif (found_id)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int mcb_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct mcb_device *mdev = to_mcb_device(dev);\n\tint ret;\n\n\tret = add_uevent_var(env, \"MODALIAS=mcb:16z%03d\", mdev->id);\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int mcb_probe(struct device *dev)\n{\n\tstruct mcb_driver *mdrv = to_mcb_driver(dev->driver);\n\tstruct mcb_device *mdev = to_mcb_device(dev);\n\tconst struct mcb_device_id *found_id;\n\tstruct module *carrier_mod;\n\tint ret;\n\n\tfound_id = mcb_match_id(mdrv->id_table, mdev);\n\tif (!found_id)\n\t\treturn -ENODEV;\n\n\tcarrier_mod = mdev->dev.parent->driver->owner;\n\tif (!try_module_get(carrier_mod))\n\t\treturn -EINVAL;\n\n\tget_device(dev);\n\tret = mdrv->probe(mdev, found_id);\n\tif (ret) {\n\t\tmodule_put(carrier_mod);\n\t\tput_device(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void mcb_remove(struct device *dev)\n{\n\tstruct mcb_driver *mdrv = to_mcb_driver(dev->driver);\n\tstruct mcb_device *mdev = to_mcb_device(dev);\n\tstruct module *carrier_mod;\n\n\tmdrv->remove(mdev);\n\n\tcarrier_mod = mdev->dev.parent->driver->owner;\n\tmodule_put(carrier_mod);\n\n\tput_device(&mdev->dev);\n}\n\nstatic void mcb_shutdown(struct device *dev)\n{\n\tstruct mcb_driver *mdrv = to_mcb_driver(dev->driver);\n\tstruct mcb_device *mdev = to_mcb_device(dev);\n\n\tif (mdrv && mdrv->shutdown)\n\t\tmdrv->shutdown(mdev);\n}\n\nstatic ssize_t revision_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mcb_bus *bus = to_mcb_bus(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", bus->revision);\n}\nstatic DEVICE_ATTR_RO(revision);\n\nstatic ssize_t model_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mcb_bus *bus = to_mcb_bus(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%c\\n\", bus->model);\n}\nstatic DEVICE_ATTR_RO(model);\n\nstatic ssize_t minor_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mcb_bus *bus = to_mcb_bus(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", bus->minor);\n}\nstatic DEVICE_ATTR_RO(minor);\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mcb_bus *bus = to_mcb_bus(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", bus->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic struct attribute *mcb_bus_attrs[] = {\n\t&dev_attr_revision.attr,\n\t&dev_attr_model.attr,\n\t&dev_attr_minor.attr,\n\t&dev_attr_name.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mcb_carrier_group = {\n\t.attrs = mcb_bus_attrs,\n};\n\nstatic const struct attribute_group *mcb_carrier_groups[] = {\n\t&mcb_carrier_group,\n\tNULL,\n};\n\n\nstatic struct bus_type mcb_bus_type = {\n\t.name = \"mcb\",\n\t.match = mcb_match,\n\t.uevent = mcb_uevent,\n\t.probe = mcb_probe,\n\t.remove = mcb_remove,\n\t.shutdown = mcb_shutdown,\n};\n\nstatic struct device_type mcb_carrier_device_type = {\n\t.name = \"mcb-carrier\",\n\t.groups = mcb_carrier_groups,\n};\n\n \nint __mcb_register_driver(struct mcb_driver *drv, struct module *owner,\n\t\t\tconst char *mod_name)\n{\n\tif (!drv->probe || !drv->remove)\n\t\treturn -EINVAL;\n\n\tdrv->driver.owner = owner;\n\tdrv->driver.bus = &mcb_bus_type;\n\tdrv->driver.mod_name = mod_name;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_NS_GPL(__mcb_register_driver, MCB);\n\n \nvoid mcb_unregister_driver(struct mcb_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_NS_GPL(mcb_unregister_driver, MCB);\n\nstatic void mcb_release_dev(struct device *dev)\n{\n\tstruct mcb_device *mdev = to_mcb_device(dev);\n\n\tmcb_bus_put(mdev->bus);\n\tkfree(mdev);\n}\n\n \nint mcb_device_register(struct mcb_bus *bus, struct mcb_device *dev)\n{\n\tint ret;\n\tint device_id;\n\n\tdevice_initialize(&dev->dev);\n\tmcb_bus_get(bus);\n\tdev->dev.bus = &mcb_bus_type;\n\tdev->dev.parent = bus->dev.parent;\n\tdev->dev.release = mcb_release_dev;\n\tdev->dma_dev = bus->carrier;\n\n\tdevice_id = dev->id;\n\tdev_set_name(&dev->dev, \"mcb%d-16z%03d-%d:%d:%d\",\n\t\tbus->bus_nr, device_id, dev->inst, dev->group, dev->var);\n\n\tret = device_add(&dev->dev);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed registering device 16z%03d on bus mcb%d (%d)\\n\",\n\t\t\tdevice_id, bus->bus_nr, ret);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tput_device(&dev->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(mcb_device_register, MCB);\n\nstatic void mcb_free_bus(struct device *dev)\n{\n\tstruct mcb_bus *bus = to_mcb_bus(dev);\n\n\tput_device(bus->carrier);\n\tida_free(&mcb_ida, bus->bus_nr);\n\tkfree(bus);\n}\n\n \nstruct mcb_bus *mcb_alloc_bus(struct device *carrier)\n{\n\tstruct mcb_bus *bus;\n\tint bus_nr;\n\tint rc;\n\n\tbus = kzalloc(sizeof(struct mcb_bus), GFP_KERNEL);\n\tif (!bus)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbus_nr = ida_alloc(&mcb_ida, GFP_KERNEL);\n\tif (bus_nr < 0) {\n\t\tkfree(bus);\n\t\treturn ERR_PTR(bus_nr);\n\t}\n\n\tbus->bus_nr = bus_nr;\n\tbus->carrier = get_device(carrier);\n\n\tdevice_initialize(&bus->dev);\n\tbus->dev.parent = carrier;\n\tbus->dev.bus = &mcb_bus_type;\n\tbus->dev.type = &mcb_carrier_device_type;\n\tbus->dev.release = &mcb_free_bus;\n\n\tdev_set_name(&bus->dev, \"mcb:%d\", bus_nr);\n\trc = device_add(&bus->dev);\n\tif (rc)\n\t\tgoto err_put;\n\n\treturn bus;\n\nerr_put:\n\tput_device(&bus->dev);\n\treturn ERR_PTR(rc);\n}\nEXPORT_SYMBOL_NS_GPL(mcb_alloc_bus, MCB);\n\nstatic int __mcb_devices_unregister(struct device *dev, void *data)\n{\n\tdevice_unregister(dev);\n\treturn 0;\n}\n\nstatic void mcb_devices_unregister(struct mcb_bus *bus)\n{\n\tbus_for_each_dev(&mcb_bus_type, NULL, NULL, __mcb_devices_unregister);\n}\n \nvoid mcb_release_bus(struct mcb_bus *bus)\n{\n\tmcb_devices_unregister(bus);\n}\nEXPORT_SYMBOL_NS_GPL(mcb_release_bus, MCB);\n\n \nstruct mcb_bus *mcb_bus_get(struct mcb_bus *bus)\n{\n\tif (bus)\n\t\tget_device(&bus->dev);\n\n\treturn bus;\n}\nEXPORT_SYMBOL_NS_GPL(mcb_bus_get, MCB);\n\n \nvoid mcb_bus_put(struct mcb_bus *bus)\n{\n\tif (bus)\n\t\tput_device(&bus->dev);\n}\nEXPORT_SYMBOL_NS_GPL(mcb_bus_put, MCB);\n\n \nstruct mcb_device *mcb_alloc_dev(struct mcb_bus *bus)\n{\n\tstruct mcb_device *dev;\n\n\tdev = kzalloc(sizeof(struct mcb_device), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev->bus = bus;\n\n\treturn dev;\n}\nEXPORT_SYMBOL_NS_GPL(mcb_alloc_dev, MCB);\n\n \nvoid mcb_free_dev(struct mcb_device *dev)\n{\n\tkfree(dev);\n}\nEXPORT_SYMBOL_NS_GPL(mcb_free_dev, MCB);\n\nstatic int __mcb_bus_add_devices(struct device *dev, void *data)\n{\n\tint retval;\n\n\tretval = device_attach(dev);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"Error adding device (%d)\\n\", retval);\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\n \nvoid mcb_bus_add_devices(const struct mcb_bus *bus)\n{\n\tbus_for_each_dev(&mcb_bus_type, NULL, NULL, __mcb_bus_add_devices);\n}\nEXPORT_SYMBOL_NS_GPL(mcb_bus_add_devices, MCB);\n\n \nstruct resource *mcb_get_resource(struct mcb_device *dev, unsigned int type)\n{\n\tif (type == IORESOURCE_MEM)\n\t\treturn &dev->mem;\n\telse if (type == IORESOURCE_IRQ)\n\t\treturn &dev->irq;\n\telse\n\t\treturn NULL;\n}\nEXPORT_SYMBOL_NS_GPL(mcb_get_resource, MCB);\n\n \nstruct resource *mcb_request_mem(struct mcb_device *dev, const char *name)\n{\n\tstruct resource *mem;\n\tu32 size;\n\n\tif (!name)\n\t\tname = dev->dev.driver->name;\n\n\tsize = resource_size(&dev->mem);\n\n\tmem = request_mem_region(dev->mem.start, size, name);\n\tif (!mem)\n\t\treturn ERR_PTR(-EBUSY);\n\n\treturn mem;\n}\nEXPORT_SYMBOL_NS_GPL(mcb_request_mem, MCB);\n\n \nvoid mcb_release_mem(struct resource *mem)\n{\n\tu32 size;\n\n\tsize = resource_size(mem);\n\trelease_mem_region(mem->start, size);\n}\nEXPORT_SYMBOL_NS_GPL(mcb_release_mem, MCB);\n\nstatic int __mcb_get_irq(struct mcb_device *dev)\n{\n\tstruct resource *irq;\n\n\tirq = mcb_get_resource(dev, IORESOURCE_IRQ);\n\n\treturn irq->start;\n}\n\n \nint mcb_get_irq(struct mcb_device *dev)\n{\n\tstruct mcb_bus *bus = dev->bus;\n\n\tif (bus->get_irq)\n\t\treturn bus->get_irq(dev);\n\n\treturn __mcb_get_irq(dev);\n}\nEXPORT_SYMBOL_NS_GPL(mcb_get_irq, MCB);\n\nstatic int mcb_init(void)\n{\n\treturn bus_register(&mcb_bus_type);\n}\n\nstatic void mcb_exit(void)\n{\n\tida_destroy(&mcb_ida);\n\tbus_unregister(&mcb_bus_type);\n}\n\n \nfs_initcall(mcb_init);\nmodule_exit(mcb_exit);\n\nMODULE_DESCRIPTION(\"MEN Chameleon Bus Driver\");\nMODULE_AUTHOR(\"Johannes Thumshirn <johannes.thumshirn@men.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}