{
  "module_name": "mcb-pci.c",
  "hash_id": "7a2cdc7ba13562b98b71fc4d9a181a8a69e2583c5dd196ad162e4125a7329522",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mcb/mcb-pci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/mcb.h>\n\n#include \"mcb-internal.h\"\n\nstruct priv {\n\tstruct mcb_bus *bus;\n\tphys_addr_t mapbase;\n\tvoid __iomem *base;\n};\n\nstatic int mcb_pci_get_irq(struct mcb_device *mdev)\n{\n\tstruct mcb_bus *mbus = mdev->bus;\n\tstruct device *dev = mbus->carrier;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn pdev->irq;\n}\n\nstatic int mcb_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct resource *res;\n\tstruct priv *priv;\n\tint ret, table_size;\n\tunsigned long flags;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to enable PCI device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpci_set_master(pdev);\n\n\tpriv->mapbase = pci_resource_start(pdev, 0);\n\tif (!priv->mapbase) {\n\t\tdev_err(&pdev->dev, \"No PCI resource\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_disable;\n\t}\n\n\tres = devm_request_mem_region(&pdev->dev, priv->mapbase,\n\t\t\t\t      CHAM_HEADER_SIZE,\n\t\t\t\t      KBUILD_MODNAME);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to request PCI memory\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_disable;\n\t}\n\n\tpriv->base = devm_ioremap(&pdev->dev, priv->mapbase, CHAM_HEADER_SIZE);\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"Cannot ioremap\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_disable;\n\t}\n\n\tflags = pci_resource_flags(pdev, 0);\n\tif (flags & IORESOURCE_IO) {\n\t\tret = -ENOTSUPP;\n\t\tdev_err(&pdev->dev,\n\t\t\t\"IO mapped PCI devices are not supported\\n\");\n\t\tgoto out_disable;\n\t}\n\n\tpci_set_drvdata(pdev, priv);\n\n\tpriv->bus = mcb_alloc_bus(&pdev->dev);\n\tif (IS_ERR(priv->bus)) {\n\t\tret = PTR_ERR(priv->bus);\n\t\tgoto out_disable;\n\t}\n\n\tpriv->bus->get_irq = mcb_pci_get_irq;\n\n\tret = chameleon_parse_cells(priv->bus, priv->mapbase, priv->base);\n\tif (ret < 0)\n\t\tgoto out_mcb_bus;\n\n\ttable_size = ret;\n\n\tif (table_size < CHAM_HEADER_SIZE) {\n\t\t \n\t\tdevm_iounmap(&pdev->dev, priv->base);\n\t\tdevm_release_mem_region(&pdev->dev, priv->mapbase, CHAM_HEADER_SIZE);\n\n\t\t \n\t\tres = devm_request_mem_region(&pdev->dev, priv->mapbase,\n\t\t\t\t\t\ttable_size,\n\t\t\t\t\t\tKBUILD_MODNAME);\n\t\tif (!res) {\n\t\t\tdev_err(&pdev->dev, \"Failed to request PCI memory\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_mcb_bus;\n\t\t}\n\n\t\tpriv->base = devm_ioremap(&pdev->dev, priv->mapbase, table_size);\n\t\tif (!priv->base) {\n\t\t\tdev_err(&pdev->dev, \"Cannot ioremap\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_mcb_bus;\n\t\t}\n\t}\n\n\tmcb_bus_add_devices(priv->bus);\n\n\treturn 0;\n\nout_mcb_bus:\n\tmcb_release_bus(priv->bus);\nout_disable:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic void mcb_pci_remove(struct pci_dev *pdev)\n{\n\tstruct priv *priv = pci_get_drvdata(pdev);\n\n\tmcb_release_bus(priv->bus);\n\n\tpci_disable_device(pdev);\n}\n\nstatic const struct pci_device_id mcb_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEN, PCI_DEVICE_ID_MEN_CHAMELEON) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ALTERA, PCI_DEVICE_ID_MEN_CHAMELEON) },\n\t{ 0 },\n};\nMODULE_DEVICE_TABLE(pci, mcb_pci_tbl);\n\nstatic struct pci_driver mcb_pci_driver = {\n\t.name = \"mcb-pci\",\n\t.id_table = mcb_pci_tbl,\n\t.probe = mcb_pci_probe,\n\t.remove = mcb_pci_remove,\n};\n\nmodule_pci_driver(mcb_pci_driver);\n\nMODULE_AUTHOR(\"Johannes Thumshirn <johannes.thumshirn@men.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MCB over PCI support\");\nMODULE_IMPORT_NS(MCB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}